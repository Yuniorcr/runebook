<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="git">
    <body>
      <group id="git">
        <trans-unit id="82b93c6560af27195da14e70510e2b3d8651c3b7" translate="yes" xml:space="preserve">
          <source>Use the specified HTTP protocol version when communicating with a server. If you want to force the default. The available and default version depend on libcurl. Actually the possible values of this option are:</source>
          <target state="translated">서버와 통신 할 때 지정된 HTTP 프로토콜 버전을 사용하십시오. 기본값을 적용하려는 경우. 사용 가능한 기본 버전은 libcurl에 따라 다릅니다. 실제로이 옵션의 가능한 값은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="becfdaabcf538340d904ac918eb155dd5d16c802" translate="yes" xml:space="preserve">
          <source>Use the specified URL to connect to the destination Subversion repository. This is useful in cases where the source SVN repository is read-only. This option overrides configuration property &lt;code&gt;commiturl&lt;/code&gt;.</source>
          <target state="translated">지정된 URL을 사용하여 대상 Subversion 저장소에 연결하십시오. 소스 SVN 저장소가 읽기 전용 인 경우에 유용합니다. 이 옵션은 구성 특성 &lt;code&gt;commiturl&lt;/code&gt; 을 대체합니다 .</target>
        </trans-unit>
        <trans-unit id="9e057e9e47493412f91dea4102ac0984cb71bdeb" translate="yes" xml:space="preserve">
          <source>Use the value of the &lt;code&gt;core.whitespace&lt;/code&gt; configuration variable to decide what to notice as error.</source>
          <target state="translated">&lt;code&gt;core.whitespace&lt;/code&gt; 구성 변수 의 값을 사용하여 오류로 주목할 사항을 결정하십시오.</target>
        </trans-unit>
        <trans-unit id="810f8c03feb9550dd6740190f543dbb37624e241" translate="yes" xml:space="preserve">
          <source>Use this custom program instead of &quot;&lt;code&gt;gpg&lt;/code&gt;&quot; found on &lt;code&gt;$PATH&lt;/code&gt; when making or verifying a PGP signature. The program must support the same command-line interface as GPG, namely, to verify a detached signature, &quot;&lt;code&gt;gpg --verify $signature - &amp;lt;$file&lt;/code&gt;&quot; is run, and the program is expected to signal a good signature by exiting with code 0, and to generate an ASCII-armored detached signature, the standard input of &quot;&lt;code&gt;gpg -bsau $key&lt;/code&gt;&quot; is fed with the contents to be signed, and the program is expected to send the result to its standard output.</source>
          <target state="translated">PGP 서명을 만들거나 확인할 때 &lt;code&gt;$PATH&lt;/code&gt; 에있는 &quot; &lt;code&gt;gpg&lt;/code&gt; &quot; 대신이 사용자 지정 프로그램을 사용하십시오 . 프로그램은 분리 된 서명 &quot; &lt;code&gt;gpg --verify $signature - &amp;lt;$file&lt;/code&gt; &quot;이 실행 되는지 확인하기 위해 GPG와 동일한 명령 행 인터페이스를 지원해야 하며 프로그램은 코드로 종료하여 올바른 서명을 신호해야합니다 0으로 ASCII-armored 분리 된 서명을 생성하기 위해 &quot; &lt;code&gt;gpg -bsau $key&lt;/code&gt; &quot; 의 표준 입력에 서명 할 내용이 제공되며 프로그램은 결과를 표준 출력으로 보냅니다.</target>
        </trans-unit>
        <trans-unit id="ad85fb495e355ea9ee99bf9caef60d6a5acc4df9" translate="yes" xml:space="preserve">
          <source>Use this for compatibility with old-style branch names used by earlier versions of &lt;code&gt;git archimport&lt;/code&gt;. Old-style branch names were category{litdd}branch, whereas new-style branch names are archive,category{litdd}branch{litdd}version. In both cases, names given on the command-line will override the automatically-generated ones.</source>
          <target state="translated">이전 버전의 &lt;code&gt;git archimport&lt;/code&gt; 에서 사용하는 구식 분기 이름과의 호환성을 위해 이것을 사용하십시오 . 구식 지사 이름은 category {litdd} 지점 인 반면, 새 스타일 지사 이름은 archive, category {litdd} 지점 {litdd} 버전입니다. 두 경우 모두 명령 줄에 지정된 이름이 자동으로 생성 된 이름보다 우선합니다.</target>
        </trans-unit>
        <trans-unit id="f09efb8456c99114df5272977533145bfda3715e" translate="yes" xml:space="preserve">
          <source>Use this option to integrate changes from the upstream subproject with your submodule&amp;rsquo;s current HEAD. Alternatively, you can run &lt;code&gt;git pull&lt;/code&gt; from the submodule, which is equivalent except for the remote branch name: &lt;code&gt;update --remote&lt;/code&gt; uses the default upstream repository and &lt;code&gt;submodule.&amp;lt;name&amp;gt;.branch&lt;/code&gt;, while &lt;code&gt;git pull&lt;/code&gt; uses the submodule&amp;rsquo;s &lt;code&gt;branch.&amp;lt;name&amp;gt;.merge&lt;/code&gt;. Prefer &lt;code&gt;submodule.&amp;lt;name&amp;gt;.branch&lt;/code&gt; if you want to distribute the default upstream branch with the superproject and &lt;code&gt;branch.&amp;lt;name&amp;gt;.merge&lt;/code&gt; if you want a more native feel while working in the submodule itself.</source>
          <target state="translated">업스트림 서브 프로젝트의 변경 사항을 서브 모듈의 현재 HEAD와 통합하려면이 옵션을 사용하십시오. 양자 택일로, 당신은 실행할 수 있습니다 &lt;code&gt;git pull&lt;/code&gt; 원격 지점 이름을 제외하고 동일합니다 서브 모듈에서 : &lt;code&gt;update --remote&lt;/code&gt; 사용하는 기본 업스트림 저장소와 &lt;code&gt;submodule.&amp;lt;name&amp;gt;.branch&lt;/code&gt; , 동안 &lt;code&gt;git pull&lt;/code&gt; 서브 모듈의 사용 &lt;code&gt;branch.&amp;lt;name&amp;gt;.merge&lt;/code&gt; . 선호 &lt;code&gt;submodule.&amp;lt;name&amp;gt;.branch&lt;/code&gt; 당신이 superproject와 함께 기본 상류 지점을 배포 할 경우 &lt;code&gt;branch.&amp;lt;name&amp;gt;.merge&lt;/code&gt; 서브 모듈 자체에서 작업하는 동안 좀 더 네이티브 느낌을 원하는 경우.</target>
        </trans-unit>
        <trans-unit id="205f9bc458a5cacd665ee1af1eac8a989bc13811" translate="yes" xml:space="preserve">
          <source>Use this option to set the namespace where the original commits will be stored. The default value is &lt;code&gt;refs/original&lt;/code&gt;.</source>
          <target state="translated">원래 커밋이 저장 될 네임 스페이스를 설정하려면이 옵션을 사용하십시오. 기본값은 &lt;code&gt;refs/original&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="978a87da673ee3d6baf57006a070d2ceaf2e0a29" translate="yes" xml:space="preserve">
          <source>Use this option to set the path to the temporary directory used for rewriting. When applying a tree filter, the command needs to temporarily check out the tree to some directory, which may consume considerable space in case of large projects. By default it does this in the &lt;code&gt;.git-rewrite/&lt;/code&gt; directory but you can override that choice by this parameter.</source>
          <target state="translated">다시 쓰기에 사용되는 임시 디렉토리의 경로를 설정하려면이 옵션을 사용하십시오. 트리 필터를 적용 할 때 명령은 트리를 일부 디렉토리로 일시적으로 체크 아웃해야하므로 대규모 프로젝트의 경우 상당한 공간을 소비 할 수 있습니다. 기본적으로 &lt;code&gt;.git-rewrite/&lt;/code&gt; 디렉토리에서이를 수행하지만이 매개 변수로 해당 선택을 대체 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7dad6966beac366ffc5d985e757265d090b93f5a" translate="yes" xml:space="preserve">
          <source>Use this option to unstage and remove paths only from the index. Working tree files, whether modified or not, will be left alone.</source>
          <target state="translated">인덱스에서만 경로를 스테이지 해제하고 제거하려면이 옵션을 사용하십시오. 작업 트리 파일은 수정 여부에 관계없이 그대로 유지됩니다.</target>
        </trans-unit>
        <trans-unit id="22e3468b42fc7b02294ecbf3cdd521f378eedf7b" translate="yes" xml:space="preserve">
          <source>Use this to customize the program used for the signing format you chose. (see &lt;code&gt;gpg.program&lt;/code&gt; and &lt;code&gt;gpg.format&lt;/code&gt;) &lt;code&gt;gpg.program&lt;/code&gt; can still be used as a legacy synonym for &lt;code&gt;gpg.openpgp.program&lt;/code&gt;. The default value for &lt;code&gt;gpg.x509.program&lt;/code&gt; is &quot;gpgsm&quot;.</source>
          <target state="translated">이를 사용하여 선택한 서명 형식에 사용되는 프로그램을 사용자 정의하십시오. (참조 &lt;code&gt;gpg.program&lt;/code&gt; 및 &lt;code&gt;gpg.format&lt;/code&gt; 를 ) &lt;code&gt;gpg.program&lt;/code&gt; 는 여전히위한 기존의 동의어로 사용할 수 있습니다 &lt;code&gt;gpg.openpgp.program&lt;/code&gt; . &lt;code&gt;gpg.x509.program&lt;/code&gt; 의 기본값 은 &quot;gpgsm&quot;입니다.</target>
        </trans-unit>
        <trans-unit id="2c0ec0febb1ffdfb71fd1faf1bdd4ef5cebdb7eb" translate="yes" xml:space="preserve">
          <source>Use this to specify the path to &lt;code&gt;git-upload-pack&lt;/code&gt; on the remote side, if is not found on your $PATH. Installations of sshd ignores the user&amp;rsquo;s environment setup scripts for login shells (e.g. .bash_profile) and your privately installed git may not be found on the system default $PATH. Another workaround suggested is to set up your $PATH in &quot;.bashrc&quot;, but this flag is for people who do not want to pay the overhead for non-interactive shells by having a lean .bashrc file (they set most of the things up in .bash_profile).</source>
          <target state="translated">$ PATH에 없으면 원격 측에서 &lt;code&gt;git-upload-pack&lt;/code&gt; 의 경로를 지정하려면 이것을 사용하십시오 . sshd를 설치하면 로그인 쉘에 대한 사용자 환경 설정 스크립트 (예 : .bash_profile)가 무시되고 시스템 기본 $ PATH에 개인 설치 git이 없을 수 있습니다. 제안 된 또 다른 해결 방법은 &quot;.bashrc&quot;에 $ PATH를 설정하는 것이지만이 플래그는 .bashrc 파일을 기울여서 비 대화식 쉘의 오버 헤드를 지불하지 않으려는 사람들을위한 것입니다. .bash_profile에서).</target>
        </trans-unit>
        <trans-unit id="1f3cdffd9311e81ebd0ee41b41de344f546bb6a2" translate="yes" xml:space="preserve">
          <source>Used DBI driver. You can specify any available driver for this here, but it might not work. cvsserver is tested with &lt;code&gt;DBD::SQLite&lt;/code&gt;, reported to work with &lt;code&gt;DBD::Pg&lt;/code&gt;, and reported &lt;strong&gt;not&lt;/strong&gt; to work with &lt;code&gt;DBD::mysql&lt;/code&gt;. Please regard this as an experimental feature. May not contain colons (&lt;code&gt;:&lt;/code&gt;). Default: &lt;code&gt;SQLite&lt;/code&gt;</source>
          <target state="translated">사용 된 DBI 드라이버. 여기에 사용 가능한 드라이버를 지정할 수 있지만 작동하지 않을 수 있습니다. cvsserver는 &lt;code&gt;DBD::SQLite&lt;/code&gt; 로 테스트되었으며 DBD :: &lt;code&gt;DBD::Pg&lt;/code&gt; 와 함께 작동하는 것으로보고 되었으며 &lt;code&gt;DBD::mysql&lt;/code&gt; 과는 작동 &lt;strong&gt;하지 않는&lt;/strong&gt; 것으로보고 되었습니다 . 이것을 실험적인 기능으로 생각하십시오. 콜론이 포함되어 있지 않을 수도 있습니다 ( &lt;code&gt;:&lt;/code&gt; ). 디폴트 : &lt;code&gt;SQLite&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="e96c8aa1d6db1322edc422d5cc1ffbd12e71daed" translate="yes" xml:space="preserve">
          <source>Used Perl DBI driver. You can specify any available driver for this here, but it might not work. git-cvsserver is tested with &lt;code&gt;DBD::SQLite&lt;/code&gt;, reported to work with &lt;code&gt;DBD::Pg&lt;/code&gt;, and reported &lt;strong&gt;not&lt;/strong&gt; to work with &lt;code&gt;DBD::mysql&lt;/code&gt;. Experimental feature. May not contain double colons (&lt;code&gt;:&lt;/code&gt;). Default: &lt;code&gt;SQLite&lt;/code&gt;. See &lt;a href=&quot;git-cvsserver&quot;&gt;git-cvsserver[1]&lt;/a&gt;.</source>
          <target state="translated">Perl DBI 드라이버를 사용했습니다. 여기에 사용 가능한 드라이버를 지정할 수 있지만 작동하지 않을 수 있습니다. git-cvsserver는 &lt;code&gt;DBD::SQLite&lt;/code&gt; 로 테스트되었으며 DBD &lt;code&gt;DBD::Pg&lt;/code&gt; 와 함께 작동하는 것으로보고 되었으며 &lt;code&gt;DBD::mysql&lt;/code&gt; 과는 작동 &lt;strong&gt;하지 않는&lt;/strong&gt; 것으로보고 되었습니다 . 실험적인 특징. 이중 콜론이 포함되어 있지 않을 수도 있습니다 ( &lt;code&gt;:&lt;/code&gt; ). 기본 : &lt;code&gt;SQLite&lt;/code&gt; 는 . &lt;a href=&quot;git-cvsserver&quot;&gt;git-cvsserver [1]을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="3dcc5e110a8886980641614ba00244bbf70eb3c6" translate="yes" xml:space="preserve">
          <source>Used as %(if)&amp;hellip;​%(then)&amp;hellip;​%(end) or %(if)&amp;hellip;​%(then)&amp;hellip;​%(else)&amp;hellip;​%(end). If there is an atom with value or string literal after the %(if) then everything after the %(then) is printed, else if the %(else) atom is used, then everything after %(else) is printed. We ignore space when evaluating the string before %(then), this is useful when we use the %(HEAD) atom which prints either &quot;*&quot; or &quot; &quot; and we want to apply the &lt;code&gt;if&lt;/code&gt; condition only on the &lt;code&gt;HEAD&lt;/code&gt; ref. Append &quot;:equals=&amp;lt;string&amp;gt;&quot; or &quot;:notequals=&amp;lt;string&amp;gt;&quot; to compare the value between the %(if:&amp;hellip;​) and %(then) atoms with the given string.</source>
          <target state="translated">% (if)&amp;hellip; % (then)&amp;hellip; % (end) 또는 % (if)&amp;hellip; % (then)&amp;hellip; % (else)&amp;hellip; % (end)로 사용됩니다. % (if) 뒤에 값 또는 문자열 리터럴이있는 원자가있는 경우 % (then) 이후의 모든 것이 인쇄되고, 그렇지 않으면 % (else) 원자가 사용되면 % (else) 뒤의 모든 것이 인쇄됩니다. % (then) 이전의 문자열을 평가할 때 공간을 무시합니다. 이것은 &quot;*&quot;또는 &quot;&quot;를 인쇄하는 % (HEAD) 원자를 사용할 때 유용 하며 &lt;code&gt;HEAD&lt;/code&gt; 참조 에만 &lt;code&gt;if&lt;/code&gt; 조건 을 적용하려고합니다 . &quot;: equals = &amp;lt;string&amp;gt;&quot;또는 &quot;: notequals = &amp;lt;string&amp;gt;&quot;을 추가하여 주어진 문자열과 % (if :&amp;hellip;) 및 % (then) 원자 사이의 값을 비교하십시오.</target>
        </trans-unit>
        <trans-unit id="88972a7007de9e429d28d6bad7487052b23f9b65" translate="yes" xml:space="preserve">
          <source>Used to check that a bundle file is valid and will apply cleanly to the current repository. This includes checks on the bundle format itself as well as checking that the prerequisite commits exist and are fully linked in the current repository. &lt;code&gt;git bundle&lt;/code&gt; prints a list of missing commits, if any, and exits with a non-zero status.</source>
          <target state="translated">번들 파일이 유효하고 현재 저장소에 올바르게 적용되는지 확인하는 데 사용됩니다. 여기에는 번들 형식 자체에 대한 점검과 전제 조건 확약이 존재하며 현재 저장소에 완전히 링크되어 있는지 점검하는 것이 포함됩니다. &lt;code&gt;git bundle&lt;/code&gt; 은 누락 된 커밋 목록을 인쇄하고 0이 아닌 상태로 종료합니다.</target>
        </trans-unit>
        <trans-unit id="a81dfbb4b6756f63bb43c72d54c78dd02ef851d4" translate="yes" xml:space="preserve">
          <source>Used to create a bundle named &lt;code&gt;file&lt;/code&gt;. This requires the &lt;code&gt;&amp;lt;git-rev-list-args&amp;gt;&lt;/code&gt; arguments to define the bundle contents. &lt;code&gt;options&lt;/code&gt; contains the options specific to the &lt;code&gt;git bundle create&lt;/code&gt; subcommand.</source>
          <target state="translated">&lt;code&gt;file&lt;/code&gt; 이라는 번들을 작성하는 데 사용 됩니다 . 번들 내용을 정의 하려면 &lt;code&gt;&amp;lt;git-rev-list-args&amp;gt;&lt;/code&gt; 인수가 필요합니다. &lt;code&gt;options&lt;/code&gt; 에는 &lt;code&gt;git bundle create&lt;/code&gt; 하위 명령과 관련된 옵션이 포함되어 있습니다 .</target>
        </trans-unit>
        <trans-unit id="fe127bac2ab0b61ffb60c0284f3741224c9951e1" translate="yes" xml:space="preserve">
          <source>Used to enforce or disable certificate revocation checks in cURL when http.sslBackend is set to &quot;schannel&quot;. Defaults to &lt;code&gt;true&lt;/code&gt; if unset. Only necessary to disable this if Git consistently errors and the message is about checking the revocation status of a certificate. This option is ignored if cURL lacks support for setting the relevant SSL option at runtime.</source>
          <target state="translated">http.sslBackend가 &quot;schannel&quot;로 설정된 경우 cURL에서 인증서 해지 확인을 시행 또는 비활성화하는 데 사용됩니다. 설정하지 않으면 기본값은 &lt;code&gt;true&lt;/code&gt; 입니다. Git에서 지속적으로 오류가 발생하고 메시지가 인증서의 해지 상태를 확인하는 것에 관한 경우에만이를 비활성화해야합니다. cURL에 런타임시 관련 SSL 옵션 설정 지원이 부족한 경우이 옵션은 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="526891fe0801e3a16c20e50ecde492e75d4f6490" translate="yes" xml:space="preserve">
          <source>Used to set the maximum load that we will still respond to gitweb queries. If the server load exceeds this value then gitweb will return &quot;503 Service Unavailable&quot; error. The server load is taken to be 0 if gitweb cannot determine its value. Currently it works only on Linux, where it uses &lt;code&gt;/proc/loadavg&lt;/code&gt;; the load there is the number of active tasks on the system &amp;mdash; processes that are actually running &amp;mdash; averaged over the last minute.</source>
          <target state="translated">여전히 gitweb 쿼리에 응답 할 최대로드를 설정하는 데 사용됩니다. 서버로드가이 값을 초과하면 gitweb은 &quot;503 Service Unavailable&quot;오류를 반환합니다. gitweb이 그 값을 결정할 수 없으면 서버로드는 0이됩니다. 현재는 &lt;code&gt;/proc/loadavg&lt;/code&gt; 를 사용하는 Linux에서만 작동합니다 . 시스템에서 수행중인 작업 (실제로 실행중인 프로세스)의 수는 마지막 1 분 동안 평균입니다.</target>
        </trans-unit>
        <trans-unit id="184dba4369820f49a823e624aa006f74d3fc96ef" translate="yes" xml:space="preserve">
          <source>Used with --remote to specify the path to the &lt;code&gt;git-upload-archive&lt;/code&gt; on the remote side.</source>
          <target state="translated">원격 에서 &lt;code&gt;git-upload-archive&lt;/code&gt; 의 경로를 지정하기 위해 --remote와 함께 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="a985abb59dca2d23760f5b7ff00e7d00f2d0f353" translate="yes" xml:space="preserve">
          <source>Used with &lt;code&gt;--range-diff&lt;/code&gt;, tweak the heuristic which matches up commits between the previous and current series of patches by adjusting the creation/deletion cost fudge factor. See &lt;a href=&quot;git-range-diff&quot;&gt;git-range-diff[1]&lt;/a&gt;) for details.</source>
          <target state="translated">&lt;code&gt;--range-diff&lt;/code&gt; 와 함께 사용 하면 생성 / 삭제 비용 퍼지 팩터를 조정하여 이전 및 현재 일련의 패치 사이의 커밋을 일치시키는 휴리스틱을 조정합니다. 자세한 내용은 &lt;a href=&quot;git-range-diff&quot;&gt;git-range-diff [1]&lt;/a&gt; )를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="9777df5e2d0f3ca27a559e53074b9f39896040e8" translate="yes" xml:space="preserve">
          <source>Used with the &lt;code&gt;fetch&lt;/code&gt; command.</source>
          <target state="translated">&lt;code&gt;fetch&lt;/code&gt; 명령 과 함께 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="ea99fa3d480e34606197cb808cc4a18c1d6b1306" translate="yes" xml:space="preserve">
          <source>User Manual</source>
          <target state="translated">사용자 매뉴얼</target>
        </trans-unit>
        <trans-unit id="3d338fa6790366b9708dc60a5019a8d98f73c4b3" translate="yes" xml:space="preserve">
          <source>User configuration and preferences are stored at:</source>
          <target state="translated">사용자 구성 및 환경 설정은 다음 위치에 저장됩니다.</target>
        </trans-unit>
        <trans-unit id="ba3e3bfcde6395de2671f768450f02d32f692aba" translate="yes" xml:space="preserve">
          <source>User name (e.g., &lt;code&gt;user&lt;/code&gt; in &lt;code&gt;https://user@example.com/repo.git&lt;/code&gt;). If the config key has a user name it must match the user name in the URL exactly. If the config key does not have a user name, that config key will match a URL with any user name (including none), but at a lower precedence than a config key with a user name.</source>
          <target state="translated">사용자 이름 (예를 들어, &lt;code&gt;user&lt;/code&gt; 의 &lt;code&gt;https://user@example.com/repo.git&lt;/code&gt; ). 구성 키에 사용자 이름이 있으면 URL의 사용자 이름과 정확히 일치해야합니다. 구성 키에 사용자 이름이없는 경우 해당 구성 키는 사용자 이름이있는 URL (없음 포함)과 일치하지만 사용자 이름이있는 구성 키보다 우선 순위가 낮습니다.</target>
        </trans-unit>
        <trans-unit id="9eabd3862d3bc88b6d20553afdc4c28a880bd15a" translate="yes" xml:space="preserve">
          <source>User specified as an option to all p4 commands, with &lt;code&gt;-u &amp;lt;user&amp;gt;&lt;/code&gt;. The environment variable &lt;code&gt;P4USER&lt;/code&gt; can be used instead.</source>
          <target state="translated">&lt;code&gt;-u &amp;lt;user&amp;gt;&lt;/code&gt; 와 함께 모든 p4 명령에 대한 옵션으로 사용자가 지정되었습니다 . 환경 변수 &lt;code&gt;P4USER&lt;/code&gt; 를 대신 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3129c28f60cb352aa378d9055c2dee4b71cd917d" translate="yes" xml:space="preserve">
          <source>User-specific configuration file. Also called &quot;global&quot; configuration file.</source>
          <target state="translated">사용자 별 구성 파일 &quot;글로벌&quot;구성 파일이라고도합니다.</target>
        </trans-unit>
        <trans-unit id="53b3f2b51348a1a5a4076e004425d0d150df3f8e" translate="yes" xml:space="preserve">
          <source>User-specific credentials file.</source>
          <target state="translated">사용자 별 자격 증명 파일.</target>
        </trans-unit>
        <trans-unit id="fbb3c5af6a1b800cb6bfa442ae5c6ae5ee1a4454" translate="yes" xml:space="preserve">
          <source>Username for SMTP-AUTH. Default is the value of &lt;code&gt;sendemail.smtpUser&lt;/code&gt;; if a username is not specified (with &lt;code&gt;--smtp-user&lt;/code&gt; or &lt;code&gt;sendemail.smtpUser&lt;/code&gt;), then authentication is not attempted.</source>
          <target state="translated">SMTP-AUTH의 사용자 이름 기본값은 &lt;code&gt;sendemail.smtpUser&lt;/code&gt; 의 값입니다 . &lt;code&gt;--smtp-user&lt;/code&gt; 또는 &lt;code&gt;sendemail.smtpUser&lt;/code&gt; 를사용 하여 사용자 이름을 지정 하지 않으면 인증을 시도하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="dd5ba62269befa999225c8d360ebd4fd64f50001" translate="yes" xml:space="preserve">
          <source>Users may select an automated merge strategy from among the following using either -s/--strategy option or configuring notes.mergeStrategy accordingly:</source>
          <target state="translated">사용자는 -s /-strategy 옵션을 사용하거나 이에 따라 notes.mergeStrategy를 사용하여 다음 중에서 자동 병합 전략을 선택할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="312954bd3f459a8154fbfda7b5edb71c57c929c2" translate="yes" xml:space="preserve">
          <source>Users migrating from CVS may also want to read &lt;a href=&quot;gitcvs-migration&quot;&gt;gitcvs-migration[7]&lt;/a&gt;.</source>
          <target state="translated">CVS에서 마이그레이션하는 사용자는 &lt;a href=&quot;gitcvs-migration&quot;&gt;gitcvs-migration [7]&lt;/a&gt; 을 읽을 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="d2fd200f233551c846ddc52433b7473972ba45cd" translate="yes" xml:space="preserve">
          <source>Using &amp;ldquo;assume unchanged&amp;rdquo; bit</source>
          <target state="translated">&quot;변경되지 않은 것으로 가정&quot;비트 사용</target>
        </trans-unit>
        <trans-unit id="db59534f65c86c428a7a540c110ff1130d39acfc" translate="yes" xml:space="preserve">
          <source>Using &amp;ldquo;git add -A&amp;rdquo;</source>
          <target state="translated">&amp;ldquo;git add -A&amp;rdquo;사용</target>
        </trans-unit>
        <trans-unit id="3f756864c1cac8254338a14f16b7888b4cd11774" translate="yes" xml:space="preserve">
          <source>Using &amp;ldquo;git commit -a&amp;rdquo;</source>
          <target state="translated">&amp;ldquo;git commit -a&amp;rdquo;사용</target>
        </trans-unit>
        <trans-unit id="1ad6e2bdca2ef33d6f60d1165c40af77488df73e" translate="yes" xml:space="preserve">
          <source>Using --cacheinfo or --info-only</source>
          <target state="translated">--cacheinfo 또는 --info-only 사용</target>
        </trans-unit>
        <trans-unit id="63a49bc3316ec7fe7ab1c50a106ab3c187422a12" translate="yes" xml:space="preserve">
          <source>Using --index-info</source>
          <target state="translated">--index-info 사용</target>
        </trans-unit>
        <trans-unit id="9465002aca9e596e405478c595d6ec82ecf19f4d" translate="yes" xml:space="preserve">
          <source>Using --recurse-submodules can only fetch new commits in already checked out submodules right now. When e.g. upstream added a new submodule in the just fetched commits of the superproject the submodule itself cannot be fetched, making it impossible to check out that submodule later without having to do a fetch again. This is expected to be fixed in a future Git version.</source>
          <target state="translated">--recurse-submodules를 사용하면 이미 체크 아웃 된 하위 모듈에서만 새 커밋을 가져올 수 있습니다. 예를 들어 업스트림에서 수퍼 프로젝트의 페치 된 커밋에 새로운 서브 모듈을 추가하면 서브 모듈 자체를 페치 할 수 없으므로 나중에 페치를 다시 수행 할 필요없이 서브 모듈을 체크 아웃 할 수 없습니다. 향후 Git 버전에서 수정 될 예정입니다.</target>
        </trans-unit>
        <trans-unit id="3b6c4766d3d128d670a5d5adf42fc526da676a66" translate="yes" xml:space="preserve">
          <source>Using --recurse-submodules will update the content of all initialized submodules according to the commit recorded in the superproject by calling read-tree recursively, also setting the submodules HEAD to be detached at that commit.</source>
          <target state="translated">--recurse-submodules를 사용하면 읽기 트리를 재귀 적으로 호출하여 수퍼 프로젝트에 기록 된 커밋에 따라 초기화 된 모든 하위 모듈의 내용을 업데이트하고 해당 커밋에서 하위 모듈 HEAD가 분리되도록 설정합니다.</target>
        </trans-unit>
        <trans-unit id="8315f077dd8f5ad49468aff013d2df68acafcb5e" translate="yes" xml:space="preserve">
          <source>Using --refresh</source>
          <target state="translated">--refresh 사용</target>
        </trans-unit>
        <trans-unit id="0565ce691b52b5953c2fb97dfb806a2f764f48e2" translate="yes" xml:space="preserve">
          <source>Using --temp or --stage=all</source>
          <target state="translated">--temp 또는 --stage = all 사용</target>
        </trans-unit>
        <trans-unit id="509888a40362653e71adbbdc6d4e59bc0d3d4ce4" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;--index-filter&lt;/code&gt; with &lt;code&gt;git rm&lt;/code&gt; yields a significantly faster version. Like with using &lt;code&gt;rm filename&lt;/code&gt;, &lt;code&gt;git rm --cached filename&lt;/code&gt; will fail if the file is absent from the tree of a commit. If you want to &quot;completely forget&quot; a file, it does not matter when it entered history, so we also add &lt;code&gt;--ignore-unmatch&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;git rm&lt;/code&gt; 과 함께 &lt;code&gt;--index-filter&lt;/code&gt; 를 사용하면 버전이 훨씬 빨라집니다. 사용과 같이 &lt;code&gt;rm filename&lt;/code&gt; , &lt;code&gt;git rm --cached filename&lt;/code&gt; 파일이 커밋의 트리에서 존재하지 않는 경우 실패합니다. 파일을 &quot;완전히 잊어 버리려면&quot;파일이 언제 기록 &lt;code&gt;--ignore-unmatch&lt;/code&gt; 는 중요하지 않으므로 --ignore-unmatch 도 추가합니다 .</target>
        </trans-unit>
        <trans-unit id="47e7ecf39552b28db7a0c771cb5239db7d4a81af" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;--recurse-submodules&lt;/code&gt; will update the content of all initialized submodules according to the commit recorded in the superproject. If local modifications in a submodule would be overwritten the checkout will fail unless &lt;code&gt;-f&lt;/code&gt; is used. If nothing (or &lt;code&gt;--no-recurse-submodules&lt;/code&gt;) is used, the work trees of submodules will not be updated. Just like &lt;a href=&quot;git-submodule&quot;&gt;git-submodule[1]&lt;/a&gt;, this will detach &lt;code&gt;HEAD&lt;/code&gt; of the submodule.</source>
          <target state="translated">&lt;code&gt;--recurse-submodules&lt;/code&gt; 를 사용 하면 수퍼 프로젝트에 기록 된 커밋에 따라 초기화 된 모든 하위 모듈의 내용이 업데이트됩니다. 서브 모듈의 로컬 수정 사항을 겹쳐 쓰면 &lt;code&gt;-f&lt;/code&gt; 를 사용 하지 않으면 체크 아웃에 실패 합니다. 아무것도 사용하지 않으면 (또는 &lt;code&gt;--no-recurse-submodules&lt;/code&gt; ) 하위 모듈 의 작업 트리가 업데이트되지 않습니다. 마찬가지로 &lt;a href=&quot;git-submodule&quot;&gt;자식 - 서브 모듈 [1]&lt;/a&gt; , 이는 분리한다 &lt;code&gt;HEAD&lt;/code&gt; 서브 모듈의이.</target>
        </trans-unit>
        <trans-unit id="87e05fa35b92ebd2beac592a4000f99e52c8fa99" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;--recurse-submodules&lt;/code&gt; will update the content of all initialized submodules according to the commit recorded in the superproject. If nothing (or &lt;code&gt;--no-recurse-submodules&lt;/code&gt;) is used, the work trees of submodules will not be updated. Just like &lt;a href=&quot;git-submodule&quot;&gt;git-submodule[1]&lt;/a&gt;, this will detach &lt;code&gt;HEAD&lt;/code&gt; of the submodules.</source>
          <target state="translated">&lt;code&gt;--recurse-submodules&lt;/code&gt; 를 사용 하면 수퍼 프로젝트에 기록 된 커밋에 따라 초기화 된 모든 하위 모듈의 내용이 업데이트됩니다. 아무것도 사용하지 않으면 (또는 &lt;code&gt;--no-recurse-submodules&lt;/code&gt; ) 하위 모듈 의 작업 트리가 업데이트되지 않습니다. 마찬가지로 &lt;a href=&quot;git-submodule&quot;&gt;자식 - 서브 모듈 [1]&lt;/a&gt; , 이는 분리한다 &lt;code&gt;HEAD&lt;/code&gt; 서브 모듈의이.</target>
        </trans-unit>
        <trans-unit id="131907fc18369579f75831dbffd3a45262caaa68" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;-a&lt;/code&gt; would conflate &amp;lt;remote&amp;gt; with any local branches you happen to have been prefixed with the same &amp;lt;remote&amp;gt; pattern.</source>
          <target state="translated">&lt;code&gt;-a&lt;/code&gt; 를 사용하면 &amp;lt;remote&amp;gt;와 접두사가 같은 로컬 분기와 &amp;lt;remote&amp;gt;가 충돌합니다.</target>
        </trans-unit>
        <trans-unit id="bc196497d8f80228e3ec0969c92ba077224b9158" translate="yes" xml:space="preserve">
          <source>Using &lt;em&gt;git checkout-index&lt;/em&gt; to &quot;export an entire tree&quot;</source>
          <target state="translated">&lt;em&gt;git checkout-index&lt;/em&gt; 를 사용 하여 &quot;전체 트리 내보내기&quot;</target>
        </trans-unit>
        <trans-unit id="f145740948f023493614f8cb28fc352a33b08d80" translate="yes" xml:space="preserve">
          <source>Using a limit</source>
          <target state="translated">한도 사용</target>
        </trans-unit>
        <trans-unit id="0d18e7415acaf5bf1693b96116e4340271619597" translate="yes" xml:space="preserve">
          <source>Using another project while maintaining independent history. Submodules allow you to contain the working tree of another project within your own working tree while keeping the history of both projects separate. Also, since submodules are fixed to an arbitrary version, the other project can be independently developed without affecting the superproject, allowing the superproject project to fix itself to new versions only when desired.</source>
          <target state="translated">독립 이력을 유지하면서 다른 프로젝트를 사용합니다. 서브 모듈을 사용하면 자신의 작업 트리 내에 다른 프로젝트의 작업 트리를 포함시키면서 두 프로젝트의 기록을 별도로 유지할 수 있습니다. 또한, 서브 모듈은 임의의 버전으로 고정되어 있기 때문에, 다른 프로젝트는 수퍼 프로젝트에 영향을주지 않고 독립적으로 개발 될 수 있으며, 수퍼 프로젝트 프로젝트는 원하는 경우에만 새 버전으로 고정 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="03266ad998c58f3651e774794904a59499884e04" translate="yes" xml:space="preserve">
          <source>Using complex scripts</source>
          <target state="translated">복잡한 스크립트 사용</target>
        </trans-unit>
        <trans-unit id="9a4e17fa716627d801ba04248e7c13675c63f6bf" translate="yes" xml:space="preserve">
          <source>Using direct mode with SSL:</source>
          <target state="translated">SSL과 함께 직접 모드 사용 :</target>
        </trans-unit>
        <trans-unit id="80be60b71aa62e009a5472e7b71ecca69fb605f2" translate="yes" xml:space="preserve">
          <source>Using direct mode:</source>
          <target state="translated">직접 모드 사용 :</target>
        </trans-unit>
        <trans-unit id="1c1bc19943239ea53498134ee5024657c6f7482f" translate="yes" xml:space="preserve">
          <source>Using git for collaboration</source>
          <target state="translated">협업을 위해 git 사용</target>
        </trans-unit>
        <trans-unit id="e742dd237e897f0c09d1168ed38eeca1316d409b" translate="yes" xml:space="preserve">
          <source>Using interactive rebases</source>
          <target state="translated">대화식 리베이스 사용</target>
        </trans-unit>
        <trans-unit id="16c9cb76d4ea0981714eee54828fc3305174e2d5" translate="yes" xml:space="preserve">
          <source>Using macro attributes</source>
          <target state="translated">매크로 속성 사용</target>
        </trans-unit>
        <trans-unit id="0bcad514939a1a512d30defc1dd83a6988408bd1" translate="yes" xml:space="preserve">
          <source>Using more options generally further limits the output (e.g. &lt;code&gt;--since=&amp;lt;date1&amp;gt;&lt;/code&gt; limits to commits newer than &lt;code&gt;&amp;lt;date1&amp;gt;&lt;/code&gt;, and using it with &lt;code&gt;--grep=&amp;lt;pattern&amp;gt;&lt;/code&gt; further limits to commits whose log message has a line that matches &lt;code&gt;&amp;lt;pattern&amp;gt;&lt;/code&gt;), unless otherwise noted.</source>
          <target state="translated">일반적으로 상기 기준 출력 (예를 들면 더 많은 옵션을 사용 &lt;code&gt;--since=&amp;lt;date1&amp;gt;&lt;/code&gt; 보다 최신 커밋에 제한 &lt;code&gt;&amp;lt;date1&amp;gt;&lt;/code&gt; 과 함께 사용 &lt;code&gt;--grep=&amp;lt;pattern&amp;gt;&lt;/code&gt; 그 로그 메시지 커밋을 더욱 제한하는 라인과 일치를 갖는 &lt;code&gt;&amp;lt;pattern&amp;gt;&lt;/code&gt; 달리 명시되지 않는 한 pattern&amp;gt; ).</target>
        </trans-unit>
        <trans-unit id="aab9e25047cbd960c71a3d6743c695a0fbcee99d" translate="yes" xml:space="preserve">
          <source>Using refspecs explicitly:</source>
          <target state="translated">Refspec을 명시 적으로 사용하기 :</target>
        </trans-unit>
        <trans-unit id="e240eb205361a2a50754a2cbbad5230917e3c8f6" translate="yes" xml:space="preserve">
          <source>Using test suites and git bisect together</source>
          <target state="translated">테스트 스위트와 git bisect를 함께 사용</target>
        </trans-unit>
        <trans-unit id="8fdfb0e1e33426ffa586ab6e967bc34118a45d25" translate="yes" xml:space="preserve">
          <source>Using the &lt;code&gt;--submodule=log&lt;/code&gt; option with &lt;a href=&quot;git-diff&quot;&gt;git-diff[1]&lt;/a&gt; will provide that information too.</source>
          <target state="translated">&lt;a href=&quot;git-diff&quot;&gt;git-diff [1]&lt;/a&gt; 과 함께 &lt;code&gt;--submodule=log&lt;/code&gt; 옵션을 사용하면 해당 정보도 제공합니다.</target>
        </trans-unit>
        <trans-unit id="d42f8d8f39d5c1ce54e65e242137998175012054" translate="yes" xml:space="preserve">
          <source>Using these options, &lt;a href=&quot;git-rev-list&quot;&gt;git-rev-list[1]&lt;/a&gt; will act similar to the more specialized family of commit log tools: &lt;a href=&quot;git-log&quot;&gt;git-log[1]&lt;/a&gt;, &lt;a href=&quot;git-show&quot;&gt;git-show[1]&lt;/a&gt;, and &lt;a href=&quot;git-whatchanged&quot;&gt;git-whatchanged[1]&lt;/a&gt;</source>
          <target state="translated">이 옵션을 사용하면 &lt;a href=&quot;git-rev-list&quot;&gt;git-rev-list [1]&lt;/a&gt; 은보다 전문화 된 커밋 로그 도구 제품군 인 &lt;a href=&quot;git-log&quot;&gt;git-log [1]&lt;/a&gt; , &lt;a href=&quot;git-show&quot;&gt;git-show [1]&lt;/a&gt; 및 &lt;a href=&quot;git-whatchanged&quot;&gt;git-whatchanged [1]와 유사하게 작동합니다.&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="a34d360db274a11502bc402ef7758f2bc5adf11b" translate="yes" xml:space="preserve">
          <source>Using this helper will store your passwords unencrypted on disk, protected only by filesystem permissions. If this is not an acceptable security tradeoff, try &lt;a href=&quot;git-credential-cache&quot;&gt;git-credential-cache[1]&lt;/a&gt;, or find a helper that integrates with secure storage provided by your operating system.</source>
          <target state="translated">이 도우미를 사용하면 암호가 디스크에 암호화되지 않고 파일 시스템 권한으로 만 보호됩니다. 이것이 허용 가능한 보안 상충 관계가 아닌 경우 &lt;a href=&quot;git-credential-cache&quot;&gt;git-credential-cache [1]을&lt;/a&gt; 시도 하거나 운영 체제에서 제공하는 보안 스토리지와 통합되는 헬퍼를 찾으십시오.</target>
        </trans-unit>
        <trans-unit id="86d0ca06bdb5a3aacec696a9b10115a302a90ea4" translate="yes" xml:space="preserve">
          <source>Using this hook, it is easy to generate mails describing the updates to the repository. This example script sends one mail message per ref listing the commits pushed to the repository, and logs the push certificates of signed pushes with good signatures to a logger service:</source>
          <target state="translated">이 후크를 사용하면 리포지토리의 업데이트를 설명하는 메일을 쉽게 생성 할 수 있습니다. 이 예제 스크립트는 ref 당 하나의 메일 메시지를 저장소로 푸시 된 커밋을 나열하고 서명이있는 푸시 푸시 인증서를 로거 서비스에 로깅합니다.</target>
        </trans-unit>
        <trans-unit id="7ae98ad0643543d139a0ccded2d96be6c57e816c" translate="yes" xml:space="preserve">
          <source>Using this option for any other purpose (don&amp;rsquo;t ask) is very strongly discouraged.</source>
          <target state="translated">다른 목적으로 사용하지 않는 것이 좋습니다 (권장하지 않음).</target>
        </trans-unit>
        <trans-unit id="ebe89d9e15d8a582f6b4a48c6c03d60cf9c673f1" translate="yes" xml:space="preserve">
          <source>Using tunnel mode:</source>
          <target state="translated">터널 모드 사용 :</target>
        </trans-unit>
        <trans-unit id="f17a1449e9ed80dcff59f550977b6693d42b10bf" translate="yes" xml:space="preserve">
          <source>Usual 3-way file level merge for text files. Conflicted regions are marked with conflict markers &lt;code&gt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&lt;/code&gt;, &lt;code&gt;=======&lt;/code&gt; and &lt;code&gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&lt;/code&gt;. The version from your branch appears before the &lt;code&gt;=======&lt;/code&gt; marker, and the version from the merged branch appears after the &lt;code&gt;=======&lt;/code&gt; marker.</source>
          <target state="translated">텍스트 파일에 대한 일반적인 3 방향 파일 수준 병합. 충돌 영역에는 충돌 마커 &lt;code&gt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&lt;/code&gt; , &lt;code&gt;=======&lt;/code&gt; 및 &lt;code&gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&lt;/code&gt; 가 표시됩니다 . 브랜치의 버전은 &lt;code&gt;=======&lt;/code&gt; 마커 앞에 나타나고 병합 된 브랜치의 버전은 &lt;code&gt;=======&lt;/code&gt; 마커 뒤에 나타납니다 .</target>
        </trans-unit>
        <trans-unit id="6cb51fab051882aaba81e0715d7acfa80e2ce09c" translate="yes" xml:space="preserve">
          <source>Usually &lt;code&gt;git gc&lt;/code&gt; runs very quickly while providing good disk space utilization and performance. This option will cause &lt;code&gt;git gc&lt;/code&gt; to more aggressively optimize the repository at the expense of taking much more time. The effects of this optimization are mostly persistent. See the &quot;AGGRESSIVE&quot; section below for details.</source>
          <target state="translated">일반적으로 &lt;code&gt;git gc&lt;/code&gt; 는 디스크 공간 활용도 및 성능을 향상시키면서 매우 빠르게 실행됩니다. 이 옵션을 사용하면 &lt;code&gt;git gc&lt;/code&gt; 가 훨씬 더 많은 시간을 소비하면서 저장소를보다 적극적으로 최적화합니다. 이 최적화의 효과는 대부분 영구적입니다. 자세한 내용은 아래 &quot;응급&quot;섹션을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="da9e2cbf852524ee1edb371514af799c05f82c93" translate="yes" xml:space="preserve">
          <source>Usually a merge requires the index file as well as the files in the working tree to be up to date with the current head commit, in order not to lose local changes. This flag disables the check with the working tree and is meant to be used when creating a merge of trees that are not directly related to the current working tree status into a temporary index file.</source>
          <target state="translated">일반적으로 병합은 로컬 변경 사항을 잃지 않기 위해 작업 헤드의 파일뿐만 아니라 인덱스 파일도 현재 헤드 커밋으로 최신 상태로 유지해야합니다. 이 플래그는 작업 트리에서 검사를 비활성화하며 현재 작업 트리 상태와 직접 관련이없는 트리를 임시 인덱스 파일로 병합 할 때 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="27214bb5573e76f1f8a1f21396536681c10927d6" translate="yes" xml:space="preserve">
          <source>Usually a three-way merge by &lt;code&gt;git read-tree&lt;/code&gt; resolves the merge for really trivial cases and leaves other cases unresolved in the index, so that porcelains can implement different merge policies. This flag makes the command resolve a few more cases internally:</source>
          <target state="translated">일반적으로 &lt;code&gt;git read-tree&lt;/code&gt; 에 의한 3 방향 병합은 사소한 경우에 대한 병합을 해결하고 색인에서 다른 경우는 해결되지 않은 상태로 두므로 도자기는 다른 병합 정책을 구현할 수 있습니다. 이 플래그는 명령이 내부적으로 몇 가지 경우를 해결하도록합니다.</target>
        </trans-unit>
        <trans-unit id="1a018c180f83561166ef04fc1c1b049dd7bef5e3" translate="yes" xml:space="preserve">
          <source>Usually given &quot;&amp;lt;feature&amp;gt;&quot; is configurable via the &lt;code&gt;gitweb.&amp;lt;feature&amp;gt;&lt;/code&gt; config variable in the per-repository Git configuration file.</source>
          <target state="translated">일반적으로 &quot;&amp;lt;feature&amp;gt;&quot;는 저장소 별 Git 구성 파일 의 &lt;code&gt;gitweb.&amp;lt;feature&amp;gt;&lt;/code&gt; 구성 변수를 통해 구성 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="06bd62b74600c2b58fc5390378d7102461c2b477" translate="yes" xml:space="preserve">
          <source>Usually it is easier to configure any desired options through your personal &lt;code&gt;.ssh/config&lt;/code&gt; file. Please consult your ssh documentation for further details.</source>
          <target state="translated">일반적으로 개인 &lt;code&gt;.ssh/config&lt;/code&gt; 파일 을 통해 원하는 옵션을 구성하는 것이 더 쉽습니다 . 자세한 내용은 ssh 설명서를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="e92c22e35ceb9b2c8da5295a992718e30d5c9f60" translate="yes" xml:space="preserve">
          <source>Usually recording a commit that has the exact same tree as its sole parent commit is a mistake, and the command prevents you from making such a commit. This option bypasses the safety, and is primarily for use by foreign SCM interface scripts.</source>
          <target state="translated">일반적으로 유일한 상위 커밋과 정확히 같은 트리를 가진 커밋을 기록하는 것은 실수이며, 명령은 그러한 커밋을 방지합니다. 이 옵션은 안전을 우회하며 주로 외부 SCM 인터페이스 스크립트에서 사용합니다.</target>
        </trans-unit>
        <trans-unit id="8ce3f0d516dc2a9d67b8e4ba143055eaf7bab452" translate="yes" xml:space="preserve">
          <source>Usually the command automatically creates a sequence of commits. This flag applies the changes necessary to cherry-pick each named commit to your working tree and the index, without making any commit. In addition, when this option is used, your index does not have to match the HEAD commit. The cherry-pick is done against the beginning state of your index.</source>
          <target state="translated">일반적으로이 명령은 일련의 커밋을 자동으로 만듭니다. 이 플래그는 커밋하지 않고 이름이 지정된 각 커밋을 작업 트리와 인덱스에 체리 픽 선택하는 데 필요한 변경 사항을 적용합니다. 또한이 옵션을 사용하면 인덱스가 HEAD 커밋과 일치하지 않아도됩니다. 체리 픽은 인덱스의 시작 상태에 대해 수행됩니다.</target>
        </trans-unit>
        <trans-unit id="55875ee1e78ad1cfc5a25d1e098bc17781327203" translate="yes" xml:space="preserve">
          <source>Usually the command automatically creates some commits with commit log messages stating which commits were reverted. This flag applies the changes necessary to revert the named commits to your working tree and the index, but does not make the commits. In addition, when this option is used, your index does not have to match the HEAD commit. The revert is done against the beginning state of your index.</source>
          <target state="translated">일반적으로이 명령은 어떤 커밋이 되돌려 졌는지를 나타내는 커밋 로그 메시지와 함께 일부 커밋을 자동으로 만듭니다. 이 플래그는 명명 된 커밋을 작업 트리와 인덱스로 되 돌리는 데 필요한 변경 사항을 적용하지만 커밋은하지 않습니다. 또한이 옵션을 사용하면 인덱스가 HEAD 커밋과 일치하지 않아도됩니다. 복귀는 색인의 시작 상태에 대해 수행됩니다.</target>
        </trans-unit>
        <trans-unit id="51d5f6e8faedb5ef4d1204f14e2f7ab2d7b77eaf" translate="yes" xml:space="preserve">
          <source>Usually the command stops output upon showing the commit that is the common ancestor of all the branches. This flag tells the command to go &amp;lt;n&amp;gt; more common commits beyond that. When &amp;lt;n&amp;gt; is negative, display only the &amp;lt;reference&amp;gt;s given, without showing the commit ancestry tree.</source>
          <target state="translated">일반적으로 명령은 모든 분기의 공통 조상 인 커밋을 표시하면 출력을 중지합니다. 이 플래그는 명령이 그보다 더 일반적인 커밋을 &amp;lt;n&amp;gt; 가도록 지시합니다. &amp;lt;n&amp;gt;이 음수이면, 커밋 상위 트리를 표시하지 않고 주어진 &amp;lt;reference&amp;gt; 만 표시하십시오.</target>
        </trans-unit>
        <trans-unit id="29097abe7ecd686605680556737a55dc5b7468af" translate="yes" xml:space="preserve">
          <source>Usually the object names are output in SHA-1 form (with possible &lt;code&gt;^&lt;/code&gt; prefix); this option makes them output in a form as close to the original input as possible.</source>
          <target state="translated">일반적으로 개체 이름은 SHA-1 형식 ( &lt;code&gt;^&lt;/code&gt; 접두사 포함) 으로 출력됩니다 . 이 옵션은 가능한 한 원래 입력에 가장 가까운 형태로 출력합니다.</target>
        </trans-unit>
        <trans-unit id="576f849692364345fa924f476c3413707294c315" translate="yes" xml:space="preserve">
          <source>Usually the output is made one line per flag and parameter. This option makes output a single line, properly quoted for consumption by shell. Useful when you expect your parameter to contain whitespaces and newlines (e.g. when using pickaxe &lt;code&gt;-S&lt;/code&gt; with &lt;code&gt;git diff-*&lt;/code&gt;). In contrast to the &lt;code&gt;--sq-quote&lt;/code&gt; option, the command input is still interpreted as usual.</source>
          <target state="translated">일반적으로 출력은 플래그와 매개 변수 당 한 줄로 만들어집니다. 이 옵션은 출력을 단일 행으로 만들어 셸에서 사용하기에 적합하게 인용합니다. 매개 변수에 공백과 줄 바꿈이 포함될 것으로 예상 할 때 유용합니다 (예 : &lt;code&gt;git diff-*&lt;/code&gt; 와 함께 pickaxe &lt;code&gt;-S&lt;/code&gt; 를 사용하는 경우 ). 받는 반면 &lt;code&gt;--sq-quote&lt;/code&gt; 옵션, 명령 입력은 여전히 평소와 같이 해석됩니다.</target>
        </trans-unit>
        <trans-unit id="52303fe63fddea8a07d49fe1df917ff950ba6541" translate="yes" xml:space="preserve">
          <source>Usually the program removes email cruft from the Subject: header line to extract the title line for the commit log message. This option prevents this munging, and is most useful when used to read back &lt;code&gt;git format-patch -k&lt;/code&gt; output.</source>
          <target state="translated">일반적으로 프로그램은 Subject : 헤더 행에서 전자 메일 크루프를 제거하여 커밋 로그 메시지의 제목 줄을 추출합니다. 이 옵션은 이러한 뭉침 현상을 방지하며 &lt;code&gt;git format-patch -k&lt;/code&gt; 출력을 다시 읽을 때 가장 유용 합니다.</target>
        </trans-unit>
        <trans-unit id="12904fba6e8c31d350b5463557502fba670802b3" translate="yes" xml:space="preserve">
          <source>Usually you cannot cherry-pick a merge because you do not know which side of the merge should be considered the mainline. This option specifies the parent number (starting from 1) of the mainline and allows cherry-pick to replay the change relative to the specified parent.</source>
          <target state="translated">일반적으로 병합의 어느 쪽이 메인 라인으로 간주되어야하는지 모르기 때문에 병합을 체리 픽픽으로 선택할 수 없습니다. 이 옵션은 메인 라인의 부모 번호 (1부터 시작)를 지정하고 체리 픽이 지정된 부모에 대한 변경을 재생할 수 있도록합니다.</target>
        </trans-unit>
        <trans-unit id="8ec09d5ac366ce3cd2a5e3c6c67d0b4fe311e4bf" translate="yes" xml:space="preserve">
          <source>Usually you cannot revert a merge because you do not know which side of the merge should be considered the mainline. This option specifies the parent number (starting from 1) of the mainline and allows revert to reverse the change relative to the specified parent.</source>
          <target state="translated">일반적으로 병합의 어느 쪽이 메인 라인으로 간주되어야하는지 모르기 때문에 병합을 되돌릴 수 없습니다. 이 옵션은 메인 라인의 상위 번호 (1부터 시작)를 지정하고 지정된 상위를 기준으로 변경 사항을 되돌릴 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6969d1a350dfc3fafb277e2e6995e5ac7a289ac5" translate="yes" xml:space="preserve">
          <source>Usually you should not need to change (adjust) any of configuration variables described below; they should be automatically set by gitweb to correct value.</source>
          <target state="translated">일반적으로 아래 설명 된 구성 변수를 변경 (조정) 할 필요는 없습니다. 그것들은 값을 수정하기 위해 gitweb에 의해 자동으로 설정되어야합니다.</target>
        </trans-unit>
        <trans-unit id="b172c85defacdb686b541793ef9e8aeee0cdf60e" translate="yes" xml:space="preserve">
          <source>Usually you would want to use &lt;code&gt;git fetch&lt;/code&gt;, which is a higher level wrapper of this command, instead.</source>
          <target state="translated">일반적 으로이 명령의 상위 레벨 래퍼 인 &lt;code&gt;git fetch&lt;/code&gt; 를 사용하려고합니다 .</target>
        </trans-unit>
        <trans-unit id="bec645de31c299cb10f93b6253e1e1669a5f0a31" translate="yes" xml:space="preserve">
          <source>Usually you would want to use &lt;code&gt;git push&lt;/code&gt;, which is a higher-level wrapper of this command, instead. See &lt;a href=&quot;git-push&quot;&gt;git-push[1]&lt;/a&gt;.</source>
          <target state="translated">일반적으로 대신이 명령의 상위 레벨 래퍼 인 &lt;code&gt;git push&lt;/code&gt; 를 사용하려고합니다 . &lt;a href=&quot;git-push&quot;&gt;git-push [1]을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="5982263578e4f00875c00a40da810fe92911cebc" translate="yes" xml:space="preserve">
          <source>Usually, &quot;git push&quot; refuses to update a remote ref that is not an ancestor of the local ref used to overwrite it.</source>
          <target state="translated">일반적으로 &quot;git push&quot;는 덮어 쓰기에 사용 된 로컬 참조의 조상이 아닌 원격 참조 업데이트를 거부합니다.</target>
        </trans-unit>
        <trans-unit id="f8497b6ab754b20f8d36f9efb8dfea581706bc5d" translate="yes" xml:space="preserve">
          <source>Usually, dangling blobs and trees aren&amp;rsquo;t very interesting. They&amp;rsquo;re almost always the result of either being a half-way mergebase (the blob will often even have the conflict markers from a merge in it, if you have had conflicting merges that you fixed up by hand), or simply because you interrupted a &lt;code&gt;git fetch&lt;/code&gt; with ^C or something like that, leaving &lt;code&gt;some&lt;/code&gt; of the new objects in the object database, but just dangling and useless.</source>
          <target state="translated">일반적으로 매달린 얼룩과 나무는 그리 흥미롭지 않습니다. 그것들은 거의 항상 반-웨이 머지베이스 (혼합 된 머지가있는 경우 블롭이 머지에서 충돌 마커를 가질 수도 있음)이거나 단순히 중단했기 때문에 발생합니다. ^ C와 같은 &lt;code&gt;git fetch&lt;/code&gt; 는 객체 데이터베이스에 새로운 객체 &lt;code&gt;some&lt;/code&gt; 를 남겨두고 매달려 있지만 쓸모가 없습니다.</target>
        </trans-unit>
        <trans-unit id="ebecb811fcb50ea2c9e80ad196b73df5b02ee5fc" translate="yes" xml:space="preserve">
          <source>Usually, the command refuses to update a remote ref that is not an ancestor of the local ref used to overwrite it. Also, when &lt;code&gt;--force-with-lease&lt;/code&gt; option is used, the command refuses to update a remote ref whose current value does not match what is expected.</source>
          <target state="translated">일반적으로이 명령은 덮어 쓰기에 사용 된 로컬 참조의 조상이 아닌 원격 참조 업데이트를 거부합니다. 또한 &lt;code&gt;--force-with-lease&lt;/code&gt; 옵션을 사용하는 경우 명령은 현재 값이 예상 한 값과 일치하지 않는 원격 참조 업데이트를 거부합니다.</target>
        </trans-unit>
        <trans-unit id="1039e5d0aca0474d85bb0cc56a14c21769cd56ed" translate="yes" xml:space="preserve">
          <source>Usually, the command refuses to update a remote ref that is not an ancestor of the local ref used to overwrite it. This flag disables the check. What this means is that the remote repository can lose commits; use it with care.</source>
          <target state="translated">일반적으로이 명령은 덮어 쓰기에 사용 된 로컬 참조의 조상이 아닌 원격 참조 업데이트를 거부합니다. 이 플래그는 검사를 비활성화합니다. 이것이 의미하는 것은 원격 저장소가 커밋을 잃을 수 있다는 것입니다. 조심해서 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="b573cab97a4c7ff4e65c78f089627a289eeb14b6" translate="yes" xml:space="preserve">
          <source>Valid &lt;code&gt;&amp;lt;type&amp;gt;&lt;/code&gt;'s include:</source>
          <target state="translated">유효한 &lt;code&gt;&amp;lt;type&amp;gt;&lt;/code&gt; 은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="2f441e23dc9e42a84676feea9743dbd62f2c9b12" translate="yes" xml:space="preserve">
          <source>Valid object types are:</source>
          <target state="translated">유효한 객체 유형은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="9b5bd1c32c0119d43f13ecb3f634510bb032afd7" translate="yes" xml:space="preserve">
          <source>Validate packed Git archive files</source>
          <target state="translated">압축 된 Git 아카이브 파일 검증</target>
        </trans-unit>
        <trans-unit id="c95efe4a20b3c90ba09bca423cb347dacda4f997" translate="yes" xml:space="preserve">
          <source>Validates the GPG signature created by &lt;code&gt;git commit -S&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;git commit -S&lt;/code&gt; 로 작성된 GPG 서명을 검증합니다 .</target>
        </trans-unit>
        <trans-unit id="ee833db09826b15f6656c228fc09101a4d262c96" translate="yes" xml:space="preserve">
          <source>Validates the gpg signature created by &lt;code&gt;git tag&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;git tag&lt;/code&gt; 에 의해 생성 된 gpg 서명을 확인합니다 .</target>
        </trans-unit>
        <trans-unit id="b1564f6b1512cbfa3cfcebc9a5badb6b239954f1" translate="yes" xml:space="preserve">
          <source>Values</source>
          <target state="translated">Values</target>
        </trans-unit>
        <trans-unit id="38ecbfb58a1b4075db82e349628396bb680485d8" translate="yes" xml:space="preserve">
          <source>Values for other tools can be used if there is a corresponding &lt;code&gt;man.&amp;lt;tool&amp;gt;.cmd&lt;/code&gt; configuration entry (see below).</source>
          <target state="translated">해당 &lt;code&gt;man.&amp;lt;tool&amp;gt;.cmd&lt;/code&gt; 구성 항목 이있는 경우 다른 도구의 값을 사용할 수 있습니다 (아래 참조).</target>
        </trans-unit>
        <trans-unit id="4590af9796b7774b94529a47844bbbd8cd70381f" translate="yes" xml:space="preserve">
          <source>Values obtained in later configuration files override values obtained earlier in the above sequence.</source>
          <target state="translated">이후 구성 파일에서 얻은 값은 위의 순서에서 이전에 얻은 값보다 우선합니다.</target>
        </trans-unit>
        <trans-unit id="42a2c91c112ab20fb86d229e79049c16aac8f47b" translate="yes" xml:space="preserve">
          <source>Values of many variables are treated as a simple string, but there are variables that take values of specific types and there are rules as to how to spell them.</source>
          <target state="translated">많은 변수의 값은 간단한 문자열로 취급되지만 특정 유형의 값을 취하는 변수가 있으며 철자를 철자하는 방법에 대한 규칙이 있습니다.</target>
        </trans-unit>
        <trans-unit id="af6a117cf9cae5d8127a5c83e908e26e4094605c" translate="yes" xml:space="preserve">
          <source>Variable substitution</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ac018db1f7b00972061adff843d37497d8ee153c" translate="yes" xml:space="preserve">
          <source>Variables</source>
          <target state="translated">Variables</target>
        </trans-unit>
        <trans-unit id="36ae09eeb0daa8ef3fa73e86b507f064c6f1150e" translate="yes" xml:space="preserve">
          <source>Various Git commands use the following environment variables:</source>
          <target state="translated">다양한 Git 명령은 다음 환경 변수를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="c808db304a88e67e4d99602bde96a3fd73a86c36" translate="yes" xml:space="preserve">
          <source>Various aspects of gitweb&amp;rsquo;s behavior can be controlled through the configuration file &lt;code&gt;gitweb_config.perl&lt;/code&gt; or &lt;code&gt;/etc/gitweb.conf&lt;/code&gt;. See the &lt;a href=&quot;gitweb.conf&quot;&gt;gitweb.conf[5]&lt;/a&gt; for details.</source>
          <target state="translated">gitweb 동작의 다양한 측면은 구성 파일 &lt;code&gt;gitweb_config.perl&lt;/code&gt; 또는 &lt;code&gt;/etc/gitweb.conf&lt;/code&gt; 를 통해 제어 할 수 있습니다 . 자세한 내용은 &lt;a href=&quot;gitweb.conf&quot;&gt;gitweb.conf [5]&lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="514c3adc237433a43f04caf698ef6f51638f8f03" translate="yes" xml:space="preserve">
          <source>Various commands read from the configuration file and adjust their operation accordingly. See &lt;a href=&quot;git-config&quot;&gt;git-config[1]&lt;/a&gt; for a list and more details about the configuration mechanism.</source>
          <target state="translated">구성 파일에서 다양한 명령을 읽고 그에 따라 작업을 조정합니다. 구성 메커니즘에 대한 자세한 내용과 목록 은 &lt;a href=&quot;git-config&quot;&gt;git-config [1]&lt;/a&gt; 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="9d741cda072f8e825584f9d44fb913d01a1b3645" translate="yes" xml:space="preserve">
          <source>Various values from structured fields in referenced objects can be used to interpolate into the resulting output, or as sort keys.</source>
          <target state="translated">참조 된 객체의 구조화 된 필드의 다양한 값을 사용하여 결과 출력에 보간하거나 정렬 키로 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0e52597805b02b27bbf6fa8afb053d38cd1cf9a2" translate="yes" xml:space="preserve">
          <source>Various ways to check your working tree</source>
          <target state="translated">작업 트리를 확인하는 다양한 방법</target>
        </trans-unit>
        <trans-unit id="8a8830ff167eaa3505bc00fdd4111ea514743436" translate="yes" xml:space="preserve">
          <source>Verbose output.</source>
          <target state="translated">자세한 출력.</target>
        </trans-unit>
        <trans-unit id="5e80e8afa8277ee05efe0825f2f72b290ab38b7f" translate="yes" xml:space="preserve">
          <source>Verbose.</source>
          <target state="translated">Verbose.</target>
        </trans-unit>
        <trans-unit id="1eee329978eae57e0140879a7cb5a19a8e448f4c" translate="yes" xml:space="preserve">
          <source>Verbosely display information about the searching strategy being employed to standard error. The tag name will still be printed to standard out.</source>
          <target state="translated">표준 오류에 사용되는 검색 전략에 대한 정보를 자세하게 표시합니다. 태그 이름은 여전히 ​​표준 출력으로 인쇄됩니다.</target>
        </trans-unit>
        <trans-unit id="17eca013b0d71c76732d4067f559197bffc5dc5a" translate="yes" xml:space="preserve">
          <source>Verbosity: let &lt;code&gt;cvsimport&lt;/code&gt; report what it is doing.</source>
          <target state="translated">자세한 정보 : &lt;code&gt;cvsimport&lt;/code&gt; 가 수행중인 작업을보고 하도록 합니다.</target>
        </trans-unit>
        <trans-unit id="43241483b8c2e2b351480246076bc9d9d3aeeb38" translate="yes" xml:space="preserve">
          <source>Verifies the connectivity and validity of the objects in the database</source>
          <target state="translated">데이터베이스에서 개체의 연결성과 유효성을 확인합니다</target>
        </trans-unit>
        <trans-unit id="083f6e6fa7581860cb22a12637eec790f2c234d9" translate="yes" xml:space="preserve">
          <source>Verifies the connectivity and validity of the objects in the database.</source>
          <target state="translated">데이터베이스에서 오브젝트의 연결성과 유효성을 검증합니다.</target>
        </trans-unit>
        <trans-unit id="121ce6e2fb35359b4c456b6cab91a3389a1154d2" translate="yes" xml:space="preserve">
          <source>Verify &amp;lt;ref&amp;gt; against &amp;lt;oldvalue&amp;gt; but do not change it. If &amp;lt;oldvalue&amp;gt; zero or missing, the ref must not exist.</source>
          <target state="translated">&amp;lt;oldvalue&amp;gt;에 대해 &amp;lt;ref&amp;gt;를 확인하지만 변경하지 마십시오. &amp;lt;oldvalue&amp;gt;가 0이거나 누락 된 경우 심판이 존재하지 않아야합니다.</target>
        </trans-unit>
        <trans-unit id="f2a6ea4dcf4e13700439c2c62eb9c887c3645654" translate="yes" xml:space="preserve">
          <source>Verify that everything reachable from target is fetched. Used after an earlier fetch is interrupted.</source>
          <target state="translated">대상에서 도달 가능한 모든 항목을 가져 왔는지 확인하십시오. 이전 반입이 중단 된 후에 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="dc19dfe6277cd8889c0ce32fc30714a767c456fd" translate="yes" xml:space="preserve">
          <source>Verify that exactly one parameter is provided, and that it can be turned into a raw 20-byte SHA-1 that can be used to access the object database. If so, emit it to the standard output; otherwise, error out.</source>
          <target state="translated">정확히 하나의 매개 변수가 제공되고 오브젝트 데이터베이스에 액세스하는 데 사용할 수있는 원시 20 바이트 SHA-1로 변환 될 수 있는지 확인하십시오. 그렇다면 표준 출력으로 방출하십시오. 그렇지 않으면 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="e921c65f691e2b371e3e29dc398bb292612d2860" translate="yes" xml:space="preserve">
          <source>Verify that the tip commit of the side branch being merged is signed with a valid key, i.e. a key that has a valid uid: in the default trust model, this means the signing key has been signed by a trusted key. If the tip commit of the side branch is not signed with a valid key, the merge is aborted.</source>
          <target state="translated">병합중인 사이드 브랜치의 팁 커밋이 유효한 키, 즉 유효한 uid가있는 키로 서명되었는지 확인하십시오. 기본 신뢰 모델에서 이는 서명 키가 신뢰할 수있는 키로 서명되었음을 의미합니다. 사이드 브랜치의 팁 커밋이 유효한 키로 서명되지 않은 경우 병합이 중단됩니다.</target>
        </trans-unit>
        <trans-unit id="baf3600caf9cbc675ef33fe6c51f69bd006b47ea" translate="yes" xml:space="preserve">
          <source>Verify the GPG signature of the given tag names.</source>
          <target state="translated">주어진 태그 이름의 GPG 서명을 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="2977304de3538ddff5d274481548280fa86926b6" translate="yes" xml:space="preserve">
          <source>Verify the MIDX file for the packfiles in the current .git folder.</source>
          <target state="translated">현재 .git 폴더에서 팩 파일에 대한 MIDX 파일을 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="593811a1bcc6cbc445bcfa7fdf52e4a760c41784" translate="yes" xml:space="preserve">
          <source>Verify the contents of the MIDX file.</source>
          <target state="translated">MIDX 파일의 내용을 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="63de76d12bfde7fe2c14402fe2f03160cc3a7318" translate="yes" xml:space="preserve">
          <source>Version 1 porcelain format is similar to the short format, but is guaranteed not to change in a backwards-incompatible way between Git versions or based on user configuration. This makes it ideal for parsing by scripts. The description of the short format above also describes the porcelain format, with a few exceptions:</source>
          <target state="translated">버전 1 도자기 형식은 짧은 형식과 비슷하지만 Git 버전간에 또는 사용자 구성에 따라 이전 버전과 호환되지 않는 방식으로 변경되지 않습니다. 따라서 스크립트로 구문 분석하는 데 이상적입니다. 위의 짧은 형식에 대한 설명은 몇 가지 예외를 제외하고 도자기 형식에 대해서도 설명합니다.</target>
        </trans-unit>
        <trans-unit id="33e409adcd5a97d5085c0477fcb4b42dc9a034a9" translate="yes" xml:space="preserve">
          <source>Version 2 format adds more detailed information about the state of the worktree and changed items. Version 2 also defines an extensible set of easy to parse optional headers.</source>
          <target state="translated">버전 2 형식은 작업 트리의 상태 및 변경된 항목에 대한 자세한 정보를 추가합니다. 버전 2는 확장 가능한 파싱 옵션 헤더 세트도 정의합니다.</target>
        </trans-unit>
        <trans-unit id="2b8063c91f48f5daba279d42a4965f292b8198dd" translate="yes" xml:space="preserve">
          <source>Version 2 pack-*.idx files support packs larger than 4 gib, and</source>
          <target state="translated">버전 2 pack-*. idx 파일은 4 gib보다 큰 팩을 지원합니다.</target>
        </trans-unit>
        <trans-unit id="5a28a75eceea6b3fb1730e69daff64901cead811" translate="yes" xml:space="preserve">
          <source>Version 4 performs a simple pathname compression that reduces index size by 30%-50% on large repositories, which results in faster load time. Version 4 is relatively young (first released in 1.8.0 in October 2012). Other Git implementations such as JGit and libgit2 may not support it yet.</source>
          <target state="translated">버전 4는 간단한 경로 이름 압축을 수행하여 큰 저장소에서 색인 크기를 30 % -50 % 줄이므로로드 시간이 단축됩니다. 버전 4는 비교적 젊습니다 (2012 년 10 월 1.8.0에 처음 릴리스 됨). JGit 및 libgit2와 같은 다른 Git 구현은 아직 지원하지 않을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5b61ffa7c699cf77c98fcf76236048d42ca5d233" translate="yes" xml:space="preserve">
          <source>Version &lt;code&gt;0&lt;/code&gt;</source>
          <target state="translated">버전 &lt;code&gt;0&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="7fc1164df4f366b4e06ce848f94e3799671648de" translate="yes" xml:space="preserve">
          <source>Version &lt;code&gt;1&lt;/code&gt;</source>
          <target state="translated">버전 &lt;code&gt;1&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="26980b77b1e7ef480646032aebce78732551db11" translate="yes" xml:space="preserve">
          <source>Versions of Git older than 1.7.7 don&amp;rsquo;t know about the &lt;code&gt;tar.gz&lt;/code&gt; format, you&amp;rsquo;ll need to use gzip explicitly:</source>
          <target state="translated">1.7.7 이전의 Git 버전은 &lt;code&gt;tar.gz&lt;/code&gt; 형식을 알지 못하므로 gzip을 명시 적으로 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="48cda44638e8ce2f3c6e764951e4cd137e88bacc" translate="yes" xml:space="preserve">
          <source>Via the alternates mechanism, a &lt;a href=&quot;#def_repository&quot;&gt;repository&lt;/a&gt; can inherit part of its &lt;a href=&quot;#def_object_database&quot;&gt;object database&lt;/a&gt; from another object database, which is called an &quot;alternate&quot;.</source>
          <target state="translated">대체 메커니즘을 통해 &lt;a href=&quot;#def_repository&quot;&gt;저장소&lt;/a&gt; 는 &quot;alternate&quot;라고하는 다른 오브젝트 데이터베이스에서 &lt;a href=&quot;#def_object_database&quot;&gt;오브젝트 데이터베이스의&lt;/a&gt; 일부를 상속 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="d75bfce3768015c62af9c4bd29fd7cad894764e0" translate="yes" xml:space="preserve">
          <source>Viewing everything that was changed in a revision, and step through revisions one at a time, viewing the history of the repository.</source>
          <target state="translated">개정판에서 변경된 모든 내용을보고 한 번에 하나씩 개정판을 살펴보고 리포지토리의 기록을 봅니다.</target>
        </trans-unit>
        <trans-unit id="8e797001d4524362e7db8f18210266901eb28403" translate="yes" xml:space="preserve">
          <source>Viewing files in GUI tools</source>
          <target state="translated">GUI 도구에서 파일보기</target>
        </trans-unit>
        <trans-unit id="05c33ea7de1cccd62a72042e46bec3b3d340cf9f" translate="yes" xml:space="preserve">
          <source>Viewing multiple Git repositories with common root.</source>
          <target state="translated">공통 루트로 여러 Git 리포지토리보기</target>
        </trans-unit>
        <trans-unit id="1439a80405107c5dd4ca129513bf97eb92ca8c3f" translate="yes" xml:space="preserve">
          <source>Viewing old file versions</source>
          <target state="translated">이전 파일 버전보기</target>
        </trans-unit>
        <trans-unit id="cba1ab24737b9af4081eae74baa579853869959f" translate="yes" xml:space="preserve">
          <source>Viewing project history</source>
          <target state="translated">프로젝트 히스토리보기</target>
        </trans-unit>
        <trans-unit id="48e788f7b4905bc5801452134707bb74e1fddd3c" translate="yes" xml:space="preserve">
          <source>Viewing the blame/annotation details of any file (if enabled).</source>
          <target state="translated">모든 파일의 책임 / 주석 세부 정보보기 (활성화 된 경우).</target>
        </trans-unit>
        <trans-unit id="afd57038f9956faea3beadae2f663a8f18e1dd6a" translate="yes" xml:space="preserve">
          <source>Viewing the contents of files in the repository at any revision.</source>
          <target state="translated">개정판에서 저장소의 파일 내용보기</target>
        </trans-unit>
        <trans-unit id="79e8c237bcc343324671ba4de89f13c4632b7437" translate="yes" xml:space="preserve">
          <source>Viewing the revision log of branches, history of files and directories, see what was changed when, by who.</source>
          <target state="translated">분기의 개정 로그, 파일 및 디렉토리 기록을보고 누가 언제 변경했는지 확인합니다.</target>
        </trans-unit>
        <trans-unit id="5d3b4279714ad2970a30b9dfdfce1d9cde0d271d" translate="yes" xml:space="preserve">
          <source>Voila.</source>
          <target state="translated">Voila.</target>
        </trans-unit>
        <trans-unit id="f7dda342bfe7129409283096bf9eae6889a3617d" translate="yes" xml:space="preserve">
          <source>Waiting $&amp;lt;int&amp;gt; seconds before reconnecting to SMTP server. Used together with --batch-size option. Defaults to the &lt;code&gt;sendemail.smtpReloginDelay&lt;/code&gt; configuration variable.</source>
          <target state="translated">SMTP 서버에 다시 연결하기 전에 $ &amp;lt;int&amp;gt; 초 동안 대기 중입니다. --batch-size 옵션과 함께 사용됩니다. &lt;code&gt;sendemail.smtpReloginDelay&lt;/code&gt; 구성 변수가 기본값 입니다.</target>
        </trans-unit>
        <trans-unit id="6abfc589b188840a4520edd8282e2221d54aed84" translate="yes" xml:space="preserve">
          <source>Walk history forward instead of backward. Instead of showing the revision in which a line appeared, this shows the last revision in which a line has existed. This requires a range of revision like START..END where the path to blame exists in START. &lt;code&gt;git blame --reverse START&lt;/code&gt; is taken as &lt;code&gt;git blame
--reverse START..HEAD&lt;/code&gt; for convenience.</source>
          <target state="translated">뒤로가 아니라 앞으로 걸어가십시오. 선이 나타난 개정을 표시하는 대신 선이 존재하는 마지막 개정을 표시합니다. 이것은 비난의 경로가 START에 존재하는 START..END와 같은 범위의 수정이 필요합니다. &lt;code&gt;git blame --reverse START&lt;/code&gt; 는 편의상 &lt;code&gt;git blame --reverse START..HEAD&lt;/code&gt; 로 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="246770a4db6a59723366cd008c0806351012631a" translate="yes" xml:space="preserve">
          <source>Walk through the patches in the series and warn if we cannot find all of the necessary information to commit a patch. At the time of this writing only missing author information is warned about.</source>
          <target state="translated">시리즈의 패치를 살펴보고 패치를 커밋하는 데 필요한 정보를 모두 찾을 수없는 경우 경고합니다. 이 글을 쓰는 시점에는 누락 된 저자 정보 만 경고됩니다.</target>
        </trans-unit>
        <trans-unit id="8741434725596a0a6dcba1ea6ce0540165fbeb38" translate="yes" xml:space="preserve">
          <source>Warn if changes introduce conflict markers or whitespace errors. What are considered whitespace errors is controlled by &lt;code&gt;core.whitespace&lt;/code&gt; configuration. By default, trailing whitespaces (including lines that consist solely of whitespaces) and a space character that is immediately followed by a tab character inside the initial indent of the line are considered whitespace errors. Exits with non-zero status if problems are found. Not compatible with --exit-code.</source>
          <target state="translated">변경으로 인해 충돌 마커 또는 공백 오류가 발생하면 경고합니다. 공백 오류로 간주되는 것은 &lt;code&gt;core.whitespace&lt;/code&gt; 구성에 의해 제어됩니다 . 기본적으로 후행 공백 (공백만으로 구성되는 줄 포함)과 줄의 처음 들여 쓰기 안에 탭 문자가 뒤에 오는 공백 문자는 공백 오류로 간주됩니다. 문제가 발견되면 0이 아닌 상태로 종료합니다. --exit-code와 호환되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="d0219dea42624b30174e17cfd1bb37d7d1a042a1" translate="yes" xml:space="preserve">
          <source>Warn of patches that contain lines longer than 998 characters unless a suitable transfer encoding (&lt;code&gt;auto&lt;/code&gt;, &lt;code&gt;base64&lt;/code&gt;, or &lt;code&gt;quoted-printable&lt;/code&gt;) is used; this is due to SMTP limits as described by &lt;a href=&quot;http://www.ietf.org/rfc/rfc5322.txt&quot;&gt;http://www.ietf.org/rfc/rfc5322.txt&lt;/a&gt;.</source>
          <target state="translated">적절한 전송 인코딩 ( &lt;code&gt;auto&lt;/code&gt; , &lt;code&gt;base64&lt;/code&gt; 또는 &lt;code&gt;quoted-printable&lt;/code&gt; )을 사용 하지 않는 한 998자를 초과하는 행이 포함 된 패치에 대해 경고합니다 . 이는 &lt;a href=&quot;http://www.ietf.org/rfc/rfc5322.txt&quot;&gt;http://www.ietf.org/rfc/rfc5322.txt에&lt;/a&gt; 설명 된 SMTP 제한으로 인한 것 입니다.</target>
        </trans-unit>
        <trans-unit id="e9c45563358e813f157ba81b33143542165ba84e" translate="yes" xml:space="preserve">
          <source>Warning</source>
          <target state="translated">Warning</target>
        </trans-unit>
        <trans-unit id="d9a62a2598117c2be58c53a722de6576cd225a89" translate="yes" xml:space="preserve">
          <source>Warnings are printed on the standard error output for any explicitly unsupported constructs, and any other lines that are not recognized by the parser.</source>
          <target state="translated">명시 적으로 지원되지 않는 구성 및 구문 분석기가 인식하지 못하는 다른 행에 대해서는 표준 오류 출력에 경고가 인쇄됩니다.</target>
        </trans-unit>
        <trans-unit id="54490e8680807566a4db5e14166b54af9ee18d68" translate="yes" xml:space="preserve">
          <source>We already saw in &lt;a href=&quot;#understanding-commits&quot;&gt;Understanding History: Commits&lt;/a&gt; that all commits are stored under a 40-digit &quot;object name&quot;. In fact, all the information needed to represent the history of a project is stored in objects with such names. In each case the name is calculated by taking the SHA-1 hash of the contents of the object. The SHA-1 hash is a cryptographic hash function. What that means to us is that it is impossible to find two different objects with the same name. This has a number of advantages; among others:</source>
          <target state="translated">우리는 이미 &lt;a href=&quot;#understanding-commits&quot;&gt;이력 이해 : 커밋&lt;/a&gt; 에서 모든 커밋이 40 자리 &quot;객체 이름&quot;으로 저장되어 있음을 보았습니다 . 실제로 프로젝트 히스토리를 나타내는 데 필요한 모든 정보는 해당 이름을 가진 오브젝트에 저장됩니다. 각각의 경우에 이름은 객체 내용의 SHA-1 해시를 사용하여 계산됩니다. SHA-1 해시는 암호화 해시 기능입니다. 그것이 우리에게 의미하는 것은 같은 이름을 가진 두 개의 다른 물체를 찾는 것이 불가능하다는 것입니다. 여기에는 여러 가지 장점이 있습니다. 다른 것들 중에서 :</target>
        </trans-unit>
        <trans-unit id="d6fd523936a98d1231393ad2931c9779a4d79b0e" translate="yes" xml:space="preserve">
          <source>We are looking for a &quot;best&quot; explanation of the new series in terms of the old one. We can represent an &quot;explanation&quot; as an edge in the graph:</source>
          <target state="translated">우리는 이전 시리즈와 관련하여 새로운 시리즈에 대한 &quot;최상의&quot;설명을 찾고 있습니다. 그래프에서 &quot;설명&quot;을 모서리로 나타낼 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9b940c15e60e8d5e30f8f0dd6fb317eefa03a3c7" translate="yes" xml:space="preserve">
          <source>We assume that GITWEB_CONFIG has its default Makefile value, namely &lt;code&gt;gitweb_config.perl&lt;/code&gt;. Put the following in &lt;code&gt;gitweb_make_index.perl&lt;/code&gt; file:</source>
          <target state="translated">우리는 GITWEB_CONFIG는 기본 메이크 값, 즉이 있다고 가정 &lt;code&gt;gitweb_config.perl&lt;/code&gt; 을 . &lt;code&gt;gitweb_make_index.perl&lt;/code&gt; 파일에 다음을 입력 하십시오.</target>
        </trans-unit>
        <trans-unit id="860f449f084465687d5f3065e9dcdf4471fe0c53" translate="yes" xml:space="preserve">
          <source>We assume the following in /etc/services</source>
          <target state="translated">/ etc / services에서 다음을 가정합니다.</target>
        </trans-unit>
        <trans-unit id="e666201c4a3affd420bf339541f1e66f556269f5" translate="yes" xml:space="preserve">
          <source>We assume you have already created a Git repository for your project, possibly created from scratch or from a tarball (see &lt;a href=&quot;gittutorial&quot;&gt;gittutorial[7]&lt;/a&gt;), or imported from an already existing CVS repository (see the next section).</source>
          <target state="translated">프로젝트를 위해 Git 저장소를 이미 작성했거나 처음부터 또는 tarball ( &lt;a href=&quot;gittutorial&quot;&gt;gittutorial [7]&lt;/a&gt; 참조 )로 작성했거나 기존 CVS 저장소에서 가져온 것으로 가정합니다 (다음 섹션 참조).</target>
        </trans-unit>
        <trans-unit id="a35a2d4ac8af99272cba8ca44431c44847ef0735" translate="yes" xml:space="preserve">
          <source>We can also create a tag to refer to a particular commit; after running</source>
          <target state="translated">특정 커밋을 나타내는 태그를 만들 수도 있습니다. 실행 후</target>
        </trans-unit>
        <trans-unit id="ec584a188dcd2e25a99263b54f2feb909dc57e99" translate="yes" xml:space="preserve">
          <source>We can ask Git about this particular object with the &lt;code&gt;cat-file&lt;/code&gt; command. Don&amp;rsquo;t copy the 40 hex digits from this example but use those from your own version. Note that you can shorten it to only a few characters to save yourself typing all 40 hex digits:</source>
          <target state="translated">&lt;code&gt;cat-file&lt;/code&gt; 명령으로 Git에게이 특정 객체에 대해 물어볼 수 있습니다 . 이 예에서 40 자리 16 진수를 복사하지 말고 자신의 버전에서 사용하십시오. 40 자릿수를 모두 입력하면 자신을 저장하기 위해 몇 자로 줄일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3d0c7ad92eed63e4b86ed7fcdbe0a2af116dc20a" translate="yes" xml:space="preserve">
          <source>We can further investigate the time spent scanning for untracked files.</source>
          <target state="translated">추적되지 않은 파일을 검색하는 데 걸린 시간을 추가로 조사 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="14c5f91f2f30d67e424b3d8fa6177783e08a84fd" translate="yes" xml:space="preserve">
          <source>We can get just the branch-head names, and remove &lt;code&gt;master&lt;/code&gt;, with the help of the standard utilities cut and grep:</source>
          <target state="translated">표준 유틸리티 cut 및 grep을 사용 하여 브랜치 헤드 이름 만 가져오고 &lt;code&gt;master&lt;/code&gt; 를 제거 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="a00f6027326a1e03d87c7714c37d6396c5fc0f07" translate="yes" xml:space="preserve">
          <source>We can get this using the following command:</source>
          <target state="translated">다음 명령을 사용하여이를 얻을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="308213d749ac73498be48acb36aa505b62d477c8" translate="yes" xml:space="preserve">
          <source>We can give this name to &lt;code&gt;git show&lt;/code&gt; to see the details about this commit.</source>
          <target state="translated">이 커밋에 대한 세부 사항을보기 위해이 이름을 &lt;code&gt;git show&lt;/code&gt; 로 지정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="164a7b582707458e7c29a45bdd3cb932a29b3ca1" translate="yes" xml:space="preserve">
          <source>We can list all the heads in this repository with &lt;a href=&quot;git-show-ref&quot;&gt;git-show-ref[1]&lt;/a&gt;:</source>
          <target state="translated">이 저장소의 모든 헤드를 &lt;a href=&quot;git-show-ref&quot;&gt;git-show-ref [1]로&lt;/a&gt; 나열 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="3342879e047ae36a38db13969064b38d54ccc902" translate="yes" xml:space="preserve">
          <source>We divide Git into high level (&quot;porcelain&quot;) commands and low level (&quot;plumbing&quot;) commands.</source>
          <target state="translated">Git을 상위 레벨 ( &quot;porcelain&quot;) 명령과 하위 레벨 ( &quot;plumbing&quot;) 명령으로 나눕니다.</target>
        </trans-unit>
        <trans-unit id="011f9d254149abd4e25f111f5f8f2bc847e7e4cc" translate="yes" xml:space="preserve">
          <source>We explain how to do this in the following sections.</source>
          <target state="translated">다음 섹션에서이를 수행하는 방법을 설명합니다.</target>
        </trans-unit>
        <trans-unit id="4822ab43c46db1b5802e2f53899245649e4398bd" translate="yes" xml:space="preserve">
          <source>We formulate a set of &lt;code&gt;rules&lt;/code&gt; for quick reference, while the prose tries to motivate each of them. Do not always take them literally; you should value good reasons for your actions higher than manpages such as this one.</source>
          <target state="translated">우리는 빠른 참조를 위해 일련의 &lt;code&gt;rules&lt;/code&gt; 을 구성하는 반면, 산문은 각각의 규칙 에 동기를 부여하려고 시도합니다. 항상 문자 그대로 받아들이지 마십시오. 이 같은 맨 페이지보다 높은 작업을 수행해야하는 적절한 이유를 고려해야합니다.</target>
        </trans-unit>
        <trans-unit id="27af85d69b0e1da45afccff7b9c2331995331c55" translate="yes" xml:space="preserve">
          <source>We found that most commits on the graph may give quite a lot of information when they are tested. And the commits that will not on average give a lot of information are the one near the good and bad commits.</source>
          <target state="translated">그래프에 대한 대부분의 커밋은 테스트 할 때 많은 정보를 제공 할 수 있음을 발견했습니다. 그리고 평균적으로 많은 정보를 제공하지 않는 커밋은 좋은 커밋과 나쁜 커밋에 가까운 것입니다.</target>
        </trans-unit>
        <trans-unit id="319c4fde5f53d3ebfff60d2ca81633ff5c5e7332" translate="yes" xml:space="preserve">
          <source>We have already seen &lt;a href=&quot;#Updating-a-repository-With-git-fetch&quot;&gt;how to keep remote-tracking branches up to date&lt;/a&gt; with &lt;a href=&quot;git-fetch&quot;&gt;git-fetch[1]&lt;/a&gt;, and how to merge two branches. So you can merge in changes from the original repository&amp;rsquo;s master branch with:</source>
          <target state="translated">우리는 이미 본 &lt;a href=&quot;#Updating-a-repository-With-git-fetch&quot;&gt;최신 지점을 원격 추적 유지하는 방법&lt;/a&gt; 과 &lt;a href=&quot;git-fetch&quot;&gt;[1] 자식 페치&lt;/a&gt; 및 방법 두 가지를 병합 할 수 있습니다. 따라서 원본 리포지토리의 마스터 브랜치에서 다음과 같이 변경 사항을 병합 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9313b2be3fe8f9ef5431fd57e740ed2c389d7c2c" translate="yes" xml:space="preserve">
          <source>We have already seen how branches work previously, with &quot;fun and work&quot; example using two branches. The idea is the same if there are more than two branches. Let&amp;rsquo;s say you started out from &quot;master&quot; head, and have some new code in the &quot;master&quot; branch, and two independent fixes in the &quot;commit-fix&quot; and &quot;diff-fix&quot; branches:</source>
          <target state="translated">우리는 이미 두 가지를 사용하는 &quot;재미와 일&quot;예제를 통해 가지가 어떻게 작동하는지 이미 보았다. 가지가 두 개 이상인 경우에도 같은 생각입니다. &quot;마스터&quot;헤드에서 시작하여 &quot;마스터&quot;분기에 새로운 코드가 있고 &quot;커밋 수정&quot;및 &quot;diff-fix&quot;분기에 두 개의 독립적 인 수정이 있다고 가정 해 봅시다.</target>
        </trans-unit>
        <trans-unit id="1170354586d8db2806a89632eb01397ff1d5b39a" translate="yes" xml:space="preserve">
          <source>We have seen several ways of naming commits already:</source>
          <target state="translated">커밋의 이름을 지정하는 몇 가지 방법이 이미 있습니다.</target>
        </trans-unit>
        <trans-unit id="ea2d131015439270646c4d9deb94b3238eec4d65" translate="yes" xml:space="preserve">
          <source>We have seen that regressions are an important problem, and that &quot;git bisect&quot; has nice features that complement very well practices and other tools, especially test suites, that are generally used to fight regressions. But it might be needed to change some work-flows and (bad) habits to get the most out of it.</source>
          <target state="translated">우리는 회귀가 중요한 문제이며 &quot;git bisect&quot;는 일반적으로 회귀와 싸우는 데 사용되는 다른 도구, 특히 테스트 스위트를 보완하는 훌륭한 기능을 가지고 있음을 알았습니다. 그러나 그것을 최대한 활용하기 위해 일부 작업 흐름과 (나쁜) 습관을 변경해야 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="58d71328c844eab6bb246a8885f29a926cbaf29b" translate="yes" xml:space="preserve">
          <source>We have seen that test suites and git bisect are very powerful when used together. It can be even more powerful if you can combine them with other systems.</source>
          <target state="translated">우리는 테스트 스위트와 git bisect가 함께 사용될 때 매우 강력하다는 것을 알았습니다. 다른 시스템과 결합 할 수 있다면 더욱 강력해질 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0dc1429b571e4014b12f464201faf90142f01343" translate="yes" xml:space="preserve">
          <source>We ignore all SVN properties except svn:executable. Any unhandled properties are logged to $GIT_DIR/svn/&amp;lt;refname&amp;gt;/unhandled.log</source>
          <target state="translated">svn : executable을 제외한 모든 SVN 속성은 무시합니다. 처리되지 않은 속성은 $ GIT_DIR / svn / &amp;lt;refname&amp;gt; /unhandled.log에 기록됩니다.</target>
        </trans-unit>
        <trans-unit id="5e0e70c2a550cebe0f64341bc25aba4f82846837" translate="yes" xml:space="preserve">
          <source>We said this tutorial shows what plumbing does to help you cope with the porcelain that isn&amp;rsquo;t flushing, but we so far did not talk about how the merge really works. If you are following this tutorial the first time, I&amp;rsquo;d suggest to skip to &quot;Publishing your work&quot; section and come back here later.</source>
          <target state="translated">이 튜토리얼에서는 플러싱되지 않은 도자기에 대처하기 위해 배관이 무엇을하는지 보여 주지만 지금까지 병합이 실제로 어떻게 작동하는지에 대해서는 이야기하지 않았습니다. 이 튜토리얼을 처음 수행하는 경우 &quot;작업 게시&quot;섹션으로 건너 뛰고 나중에 다시 방문하십시오.</target>
        </trans-unit>
        <trans-unit id="038e0426e816e440e5c183b0ccfae9faca0c65b5" translate="yes" xml:space="preserve">
          <source>We saw above that &lt;code&gt;origin&lt;/code&gt; is just a shortcut to refer to the repository that you originally cloned from. This information is stored in Git configuration variables, which you can see using &lt;a href=&quot;git-config&quot;&gt;git-config[1]&lt;/a&gt;:</source>
          <target state="translated">위에서 본 &lt;code&gt;origin&lt;/code&gt; 은 원래 복제 한 저장소를 나타내는 바로 가기 일뿐입니다. 이 정보는 Git 구성 변수에 저장되며 &lt;a href=&quot;git-config&quot;&gt;git-config [1]&lt;/a&gt; 사용하여 볼 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="789eeb5f51968bf21d9746b92623ca08838d8bcb" translate="yes" xml:space="preserve">
          <source>We saw earlier that &quot;git bisect skip&quot; is now using a PRNG to try to avoid areas in the commit graph where commits are untestable. The problem is that sometimes the first bad commit will be in an untestable area.</source>
          <target state="translated">&quot;git bisect skip&quot;은 이제 커밋을 테스트 할 수없는 커밋 그래프의 영역을 피하기 위해 PRNG를 사용하고 있음을 알았습니다. 문제는 때때로 첫 번째 잘못된 커밋이 테스트 할 수없는 영역에 있다는 것입니다.</target>
        </trans-unit>
        <trans-unit id="e6f53989efc34bb4d6e54dcd09f15943b6a8a36c" translate="yes" xml:space="preserve">
          <source>We saw in &lt;a href=&quot;#conflict-resolution&quot;&gt;Getting conflict-resolution help during a merge&lt;/a&gt; that during a merge the index can store multiple versions of a single file (called &quot;stages&quot;). The third column in the &lt;a href=&quot;git-ls-files&quot;&gt;git-ls-files[1]&lt;/a&gt; output above is the stage number, and will take on values other than 0 for files with merge conflicts.</source>
          <target state="translated">&lt;a href=&quot;#conflict-resolution&quot;&gt;병합 중 충돌 해결 도움말 얻기에서 병합&lt;/a&gt; 중에 색인이 단일 파일의 여러 버전 ( &quot;스테이지&quot;)을 저장할 수 있다는 것을 알았습니다 . 위의 &lt;a href=&quot;git-ls-files&quot;&gt;git-ls-files [1]&lt;/a&gt; 출력 에서 세 번째 열 은 스테이지 번호이며 병합 충돌이있는 파일의 경우 0 이외의 값을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="d5d682276e6a6d081a241de022b4ded4aef9c418" translate="yes" xml:space="preserve">
          <source>We saw in &lt;a href=&quot;#fixing-a-mistake-by-rewriting-history&quot;&gt;Fixing a mistake by rewriting history&lt;/a&gt; that you can replace the most recent commit using</source>
          <target state="translated">가장 최근의 커밋을 대체 할 수있는 &lt;a href=&quot;#fixing-a-mistake-by-rewriting-history&quot;&gt;기록&lt;/a&gt; 을 다시 작성하여 실수 를 수정했습니다.</target>
        </trans-unit>
        <trans-unit id="aafdc07c8e0d9b297fcdd505608f380ef754ed45" translate="yes" xml:space="preserve">
          <source>We saw in part one of the tutorial that commits have names like this. It turns out that every object in the Git history is stored under a 40-digit hex name. That name is the SHA-1 hash of the object&amp;rsquo;s contents; among other things, this ensures that Git will never store the same data twice (since identical data is given an identical SHA-1 name), and that the contents of a Git object will never change (since that would change the object&amp;rsquo;s name as well). The 7 char hex strings here are simply the abbreviation of such 40 character long strings. Abbreviations can be used everywhere where the 40 character strings can be used, so long as they are unambiguous.</source>
          <target state="translated">우리는 튜토리얼의 한 부분에서 커밋이 이와 같은 이름을 갖는 것을 보았습니다. Git 히스토리의 모든 객체는 40 자리 16 진수 이름으로 저장됩니다. 그 이름은 객체 내용의 SHA-1 해시입니다. 무엇보다도 이것은 Git이 동일한 데이터를 두 번 저장하지 않도록하고 (동일한 데이터에는 동일한 SHA-1 이름이 주어지기 때문에) Git 객체의 내용이 변경되지 않기 때문에 (오브젝트의 이름도 변경되기 때문에) ). 여기서 7 개의 문자 16 진 문자열은 단순히 40 자 길이의 약어입니다. 40 개의 문자열을 사용할 수있는 곳이라면 어디에서나 약어를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="09c046487d09b436218fe11aa8c1087251442281" translate="yes" xml:space="preserve">
          <source>We separate the porcelain commands into the main commands and some ancillary user utilities.</source>
          <target state="translated">우리는 도자기 명령을 기본 명령과 일부 보조 사용자 유틸리티로 분리합니다.</target>
        </trans-unit>
        <trans-unit id="f2e875357a5ce85901234308b841a3138ebd851b" translate="yes" xml:space="preserve">
          <source>We should point out that &quot;habitually&quot; (regularly for no real reason) merging an integration branch into your topics &amp;mdash; and by extension, merging anything upstream into anything downstream on a regular basis &amp;mdash; is frowned upon:</source>
          <target state="translated">우리는 통합 지점을 주제에 통합하는 (거의 어떤 이유도없이) &quot;거의&quot;(일반적으로 아무 이유없이) 정기적으로 다운 스트림에 상류의 것을 병합하는 것은 다음과 같이 찌그러짐을 지적해야한다.</target>
        </trans-unit>
        <trans-unit id="3b0c2056ade966758c96efbd333ad03c787ca3ac" translate="yes" xml:space="preserve">
          <source>We start with one specialized tool that is useful for finding the commit that introduced a bug into a project.</source>
          <target state="translated">프로젝트에 버그를 도입 한 커밋을 찾는 데 유용한 하나의 특수 도구로 시작합니다.</target>
        </trans-unit>
        <trans-unit id="3bb7fbe62fd9b3fa1a7f67f6a431251fe7b02079" translate="yes" xml:space="preserve">
          <source>We start with the most important, the &lt;a href=&quot;#def_object_database&quot;&gt;object database&lt;/a&gt; and the &lt;a href=&quot;#def_index&quot;&gt;index&lt;/a&gt;.</source>
          <target state="translated">가장 중요한 &lt;a href=&quot;#def_object_database&quot;&gt;객체 데이터베이스&lt;/a&gt; 와 &lt;a href=&quot;#def_index&quot;&gt;색인으로 시작&lt;/a&gt; 합니다.</target>
        </trans-unit>
        <trans-unit id="fa1acdd625946113b786a5983b045431892f2e96" translate="yes" xml:space="preserve">
          <source>We supposed in the previous examples that the &quot;good&quot; commits were ancestors of the &quot;bad&quot; commit. But this is not a requirement of &quot;git bisect&quot;.</source>
          <target state="translated">앞의 예에서 &quot;좋은&quot;커밋은 &quot;나쁜&quot;커밋의 조상이라고 가정했습니다. 그러나 이것은 &quot;git bisect&quot;의 요구 사항은 아닙니다.</target>
        </trans-unit>
        <trans-unit id="09e675bfb62532c536d372645ebddf19b07c5684" translate="yes" xml:space="preserve">
          <source>We want to make &lt;code&gt;topic&lt;/code&gt; forked from branch &lt;code&gt;master&lt;/code&gt;; for example, because the functionality on which &lt;code&gt;topic&lt;/code&gt; depends was merged into the more stable &lt;code&gt;master&lt;/code&gt; branch. We want our tree to look like this:</source>
          <target state="translated">우리는 브랜치 &lt;code&gt;master&lt;/code&gt; 로부터 &lt;code&gt;topic&lt;/code&gt; 를 분기 시키려고합니다 . 예를 들어, &lt;code&gt;topic&lt;/code&gt; 의존 하는 기능 이보다 안정적인 &lt;code&gt;master&lt;/code&gt; 브랜치 로 병합 되었기 때문 입니다. 우리는 나무가 다음과 같이 보이기를 원합니다.</target>
        </trans-unit>
        <trans-unit id="0fa006b18282abd83f954d3423dfd83f70f68c0d" translate="yes" xml:space="preserve">
          <source>We will introduce some tools that can help you do this, explain how to use them, and then explain some of the problems that can arise because you are rewriting history.</source>
          <target state="translated">이 작업을 수행하는 데 도움이되는 몇 가지 도구를 소개하고 사용 방법을 설명한 다음 기록을 다시 작성하여 발생할 수있는 몇 가지 문제에 대해 설명합니다.</target>
        </trans-unit>
        <trans-unit id="e34d86d215639adac5ecaa74d7f70d803a2ef9de" translate="yes" xml:space="preserve">
          <source>We will sometimes represent Git history using diagrams like the one below. Commits are shown as &quot;o&quot;, and the links between them with lines drawn with - / and \. Time goes left to right:</source>
          <target state="translated">때때로 아래와 같은 다이어그램을 사용하여 Git 히스토리를 표현할 것입니다. 커밋은 &quot;o&quot;로 표시되고-/ 및 \로 그려진 선으로 링크가 연결됩니다. 시간은 왼쪽에서 오른쪽으로갑니다.</target>
        </trans-unit>
        <trans-unit id="ab9fd84ced67b4e6059fb12091ba4144199c5397" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ll assume that the problem is a single missing or corrupted blob, which is sometimes a solvable problem. (Recovering missing trees and especially commits is &lt;strong&gt;much&lt;/strong&gt; harder).</source>
          <target state="translated">우리는 문제가 단일 누락 또는 손상된 얼룩이라고 가정하며, 때로는 해결할 수있는 문제입니다. 누락 된 트리 및 특히 커밋을 복구하는 것이 &lt;strong&gt;훨씬&lt;/strong&gt; 어렵습니다.</target>
        </trans-unit>
        <trans-unit id="2aa7b1ec194976812ce4b6b3f7e0ba34eba549a8" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ll keep this simple and stupid, so we&amp;rsquo;ll start off with populating a few trivial files just to get a feel for it.</source>
          <target state="translated">우리는 이것을 간단하고 어리석게 유지할 것이므로, 간단한 파일을 채우는 것으로 시작하겠습니다.</target>
        </trans-unit>
        <trans-unit id="2d4db37414a68811cd95f44af4830929ada62273" translate="yes" xml:space="preserve">
          <source>Webserver configuration</source>
          <target state="translated">웹 서버 구성</target>
        </trans-unit>
        <trans-unit id="c0f36d74c982d11ffbdfaa17b6ab39308ec52a2f" translate="yes" xml:space="preserve">
          <source>Webserver configuration with multiple projects' root</source>
          <target state="translated">여러 프로젝트 루트가있는 웹 서버 구성</target>
        </trans-unit>
        <trans-unit id="ef6d4f2b2672206d0b50ce512c5b9cc1369fe95f" translate="yes" xml:space="preserve">
          <source>What an alias file in each format looks like can be found in the documentation of the email program of the same name. The differences and limitations from the standard formats are described below:</source>
          <target state="translated">각 형식의 별명 파일은 동일한 이름의 이메일 프로그램 문서에서 찾을 수 있습니다. 표준 형식과의 차이점과 제한 사항은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="fa6325f935566c907b8b84855ddf6b390a1827e3" translate="yes" xml:space="preserve">
          <source>What are the 7 digits of hex that Git responded to the commit with?</source>
          <target state="translated">Git이 커밋에 응답 한 16 진수의 7 자리 숫자는 무엇입니까?</target>
        </trans-unit>
        <trans-unit id="5fb651419665147da76edfca56099f33ccd0e645" translate="yes" xml:space="preserve">
          <source>What does this mean?</source>
          <target state="translated">이것은 무엇을 의미 하는가?</target>
        </trans-unit>
        <trans-unit id="b77fdbd3385bc488b50aa891b5b4c124304a8f69" translate="yes" xml:space="preserve">
          <source>What is interesting too is that end users that are reporting bugs (or QA people that reproduced a bug) have access to the environment where the bug happens. So they can often more easily reproduce a regression. And if they can bisect, then more information will be extracted from the environment where the bug happens, which means that it will be easier to understand and then fix the bug.</source>
          <target state="translated">흥미로운 점은 버그를보고하는 최종 사용자 (또는 버그를 재현 한 QA 담당자)가 버그가 발생한 환경에 액세스 할 수 있다는 것입니다. 따라서 회귀를보다 쉽게 ​​재현 할 수 있습니다. 그리고 이등분 할 수 있다면 버그가 발생한 환경에서 더 많은 정보가 추출되므로 버그를 이해하고 수정하기가 더 쉬워 질 것입니다.</target>
        </trans-unit>
        <trans-unit id="549056214cd4b23720c4559829b5b36cc5cf6d0c" translate="yes" xml:space="preserve">
          <source>What next?</source>
          <target state="translated">다음은?</target>
        </trans-unit>
        <trans-unit id="fe77441e9cc191fb4a5181d6f98e51e7bf6ce4ab" translate="yes" xml:space="preserve">
          <source>What people don&amp;rsquo;t get is that this is a situation where the &quot;end node principle&quot; applies. When you have limited resources (here: developers) you don&amp;rsquo;t push the bulk of the burden upon them. Instead you push things out to the resource you have a lot of, the end nodes (here: users), so that the situation actually scales.</source>
          <target state="translated">사람들이 얻지 못하는 것은 이것이 &quot;엔드 노드 원칙&quot;이 적용되는 상황이라는 것입니다. 리소스가 제한되어있는 경우 (여기 : 개발자) 많은 부담을주지 않습니다. 대신 상황을 실제로 확장 할 수 있도록 많은 최종 노드 (여기서는 사용자)가있는 리소스로 작업을 푸시합니다.</target>
        </trans-unit>
        <trans-unit id="e4950cd435094a3f200db11a5c1b540d80d04769" translate="yes" xml:space="preserve">
          <source>What should you do when you tag a wrong commit and you would want to re-tag?</source>
          <target state="translated">잘못된 커밋에 태그를 지정하고 다시 태그를 지정하려는 경우 어떻게해야합니까?</target>
        </trans-unit>
        <trans-unit id="049920ec0574fb80b08ccee259e5814b007cd44c" translate="yes" xml:space="preserve">
          <source>What the -p option produces is slightly different from the traditional diff format:</source>
          <target state="translated">-p 옵션이 생성하는 것은 기존의 diff 형식과 약간 다릅니다.</target>
        </trans-unit>
        <trans-unit id="e27b60d4391d6c41de480e30a2d0df50a6723ae8" translate="yes" xml:space="preserve">
          <source>What to do when a push fails</source>
          <target state="translated">푸시 실패시 수행 할 작업</target>
        </trans-unit>
        <trans-unit id="42a1dbf4390cedcf2f183fba444335bae8d5ae11" translate="yes" xml:space="preserve">
          <source>What you chose are then highlighted with &lt;code&gt;*&lt;/code&gt;, like this:</source>
          <target state="translated">선택한 내용은 다음과 같이 &lt;code&gt;*&lt;/code&gt; 로 강조 표시됩니다 .</target>
        </trans-unit>
        <trans-unit id="e11a716b5dc9d27d9966b39b2c63b32b4c67e627" translate="yes" xml:space="preserve">
          <source>When &amp;lt;rev&amp;gt; is not specified, the command annotates the changes starting backwards from the working tree copy. This flag makes the command pretend as if the working tree copy has the contents of the named file (specify &lt;code&gt;-&lt;/code&gt; to make the command read from the standard input).</source>
          <target state="translated">&amp;lt;rev&amp;gt;를 지정하지 않으면 명령은 작업 트리 사본에서 거꾸로 시작하여 변경 사항에 주석을 달 수 있습니다. 이 플래그는 작업 트리 사본에 명명 된 파일의 내용이있는 것처럼 명령을 가장합니다 (지정 &lt;code&gt;-&lt;/code&gt; 표준 입력에서 명령을 읽도록 지정 ).</target>
        </trans-unit>
        <trans-unit id="df8212af8d2323e7260f5fa3c4bc0bbc714643ff" translate="yes" xml:space="preserve">
          <source>When --fork-point is active, &lt;code&gt;fork_point&lt;/code&gt; will be used instead of &amp;lt;upstream&amp;gt; to calculate the set of commits to rebase, where &lt;code&gt;fork_point&lt;/code&gt; is the result of &lt;code&gt;git merge-base --fork-point &amp;lt;upstream&amp;gt;
&amp;lt;branch&amp;gt;&lt;/code&gt; command (see &lt;a href=&quot;git-merge-base&quot;&gt;git-merge-base[1]&lt;/a&gt;). If &lt;code&gt;fork_point&lt;/code&gt; ends up being empty, the &amp;lt;upstream&amp;gt; will be used as a fallback.</source>
          <target state="translated">--fork-point가 활성화되면 &amp;lt;upstream&amp;gt; 대신 &lt;code&gt;fork_point&lt;/code&gt; 를 사용하여 rebase에 대한 커밋 세트를 계산합니다. 여기서 &lt;code&gt;fork_point&lt;/code&gt; 는 &lt;code&gt;git merge-base --fork-point &amp;lt;upstream&amp;gt; &amp;lt;branch&amp;gt;&lt;/code&gt; 명령의 결과입니다 ( 참조 &lt;a href=&quot;git-merge-base&quot;&gt;이눔 병합 계를 [1]&lt;/a&gt; ). 경우 &lt;code&gt;fork_point&lt;/code&gt; 끝까지 비어있는,의 &amp;lt;상류&amp;gt;는 대체해서 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="0b903c4e9a3738f389f65549fe23dcd21fd8909d" translate="yes" xml:space="preserve">
          <source>When --graph is not used, all history branches are flattened which can make it hard to see that the two consecutive commits do not belong to a linear branch. This option puts a barrier in between them in that case. If &lt;code&gt;&amp;lt;barrier&amp;gt;&lt;/code&gt; is specified, it is the string that will be shown instead of the default one.</source>
          <target state="translated">--graph를 사용하지 않으면 모든 히스토리 브랜치가 병합되어 두 개의 연속 커밋이 선형 브랜치에 속하지 않음을 알기가 어려울 수 있습니다. 이 경우이 옵션을 사용하면 그 사이에 장벽이 생깁니다. 경우 &lt;code&gt;&amp;lt;barrier&amp;gt;&lt;/code&gt; 지정, 대신 기본 하나의 표시 될 문자열입니다.</target>
        </trans-unit>
        <trans-unit id="24ff3c267435a7dcecd3166ed52f8210a7c7f0de" translate="yes" xml:space="preserve">
          <source>When --stdout is specified then progress report is displayed during the object count and compression phases but inhibited during the write-out phase. The reason is that in some cases the output stream is directly linked to another command which may wish to display progress status of its own as it processes incoming pack data. This flag is like --progress except that it forces progress report for the write-out phase as well even if --stdout is used.</source>
          <target state="translated">--stdout을 지정하면 객체 수 및 압축 단계에서 진행률 보고서가 표시되지만 쓰기 단계에서는 금지됩니다. 그 이유는 출력 스트림이 다른 명령에 직접 연결되어 들어오는 팩 데이터를 처리 할 때 자체의 진행 상태를 표시하고자 할 수 있기 때문입니다. 이 플래그는 --stdout을 사용하더라도 쓰기 단계에 대한 진행률 보고서를 강제한다는 점을 제외하면 --progress와 같습니다.</target>
        </trans-unit>
        <trans-unit id="d3e80ca53bd7d57db503ac84208eff0dbe6d901f" translate="yes" xml:space="preserve">
          <source>When -k is not in effect, all leading strings bracketed with &lt;code&gt;[&lt;/code&gt; and &lt;code&gt;]&lt;/code&gt; pairs are stripped. This option limits the stripping to only the pairs whose bracketed string contains the word &quot;PATCH&quot;.</source>
          <target state="translated">-k가 적용되지 않으면 &lt;code&gt;[&lt;/code&gt; 및 &lt;code&gt;]&lt;/code&gt; 쌍으로 묶인 모든 선행 문자열 이 제거됩니다. 이 옵션은 괄호로 묶인 문자열에 &quot;PATCH&quot;라는 단어가 포함 된 쌍으로 만 스트립을 제한합니다.</target>
        </trans-unit>
        <trans-unit id="882475218cb0a9fc17e76a3d4266386adec5dd71" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;&quot;$@&quot;&lt;/code&gt; is &lt;code&gt;-h&lt;/code&gt; or &lt;code&gt;--help&lt;/code&gt; in the above example, the following usage text would be shown:</source>
          <target state="translated">때 &lt;code&gt;&quot;$@&quot;&lt;/code&gt; 입니다 &lt;code&gt;-h&lt;/code&gt; 또는 &lt;code&gt;--help&lt;/code&gt; 위의 예에서, 다음 사용 텍스트가 표시 될 것입니다 :</target>
        </trans-unit>
        <trans-unit id="d78a0cbb0812363470a0c64a4a94d40dd1da90bb" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;--batch-all-objects&lt;/code&gt; is in use, visit objects in an order which may be more efficient for accessing the object contents than hash order. The exact details of the order are unspecified, but if you do not require a specific order, this should generally result in faster output, especially with &lt;code&gt;--batch&lt;/code&gt;. Note that &lt;code&gt;cat-file&lt;/code&gt; will still show each object only once, even if it is stored multiple times in the repository.</source>
          <target state="translated">때 &lt;code&gt;--batch-all-objects&lt;/code&gt; 사용하고, 방문은 해시 위해보다 객체의 내용을 액세스하기위한보다 효율적으로 할 수 순서로 객체. 주문의 정확한 세부 사항은 지정되어 있지 않지만 특정 주문이 필요하지 않은 경우 일반적으로 특히 &lt;code&gt;--batch&lt;/code&gt; 를 사용 하여 더 빠른 출력을 얻을 수 있습니다. 참고 &lt;code&gt;cat-file&lt;/code&gt; 이 저장소에 여러 번 저장되어있는 경우에도, 여전히 한 번만 각 개체를 보여줄 것이다.</target>
        </trans-unit>
        <trans-unit id="95919047a579b82415a0ddd6c6f601bfbb7dc80f" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;--check&lt;/code&gt; is in effect, or when applying the patch (which is the default when none of the options that disables it is in effect), make sure the patch is applicable to what the current index file records. If the file to be patched in the working tree is not up to date, it is flagged as an error. This flag also causes the index file to be updated.</source>
          <target state="translated">때 &lt;code&gt;--check&lt;/code&gt; 가 유효하거나 패치를 적용 할 때, (기본값 인이 유효 비활성화하는 옵션 중 어느 것도 경우)도하지 않습니다 확인 패치는 무엇 현재 인덱스 파일 레코드에 적용 할 수있다. 작업 트리에서 패치 할 파일이 최신이 아닌 경우 오류로 플래그가 지정됩니다. 이 플래그는 또한 색인 파일이 갱신되도록합니다.</target>
        </trans-unit>
        <trans-unit id="526cf7ed548b3415806841ff6b0e065a944a8f5e" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;--compose&lt;/code&gt; is used, git send-email will use the From, Subject, and In-Reply-To headers specified in the message. If the body of the message (what you type after the headers and a blank line) only contains blank (or Git: prefixed) lines, the summary won&amp;rsquo;t be sent, but From, Subject, and In-Reply-To headers will be used unless they are removed.</source>
          <target state="translated">때 &lt;code&gt;--compose&lt;/code&gt; 가 사용되며, 자식 전송 - 이메일을 조건으로,부터를 사용하고,에서가-회신에 메시지에 지정된 헤더. 메시지 본문 (머리글과 빈 줄 다음에 입력 한 내용)에 빈 (또는 Git : 접두사) 줄만 포함 된 경우 요약이 전송되지 않지만 From, Subject 및 In-Reply-To 헤더는 제거하지 않으면 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="ac6d168ca5e25a70ab78d5a850025a2ad07d998b" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;--exclude&lt;/code&gt; and &lt;code&gt;--include&lt;/code&gt; patterns are used, they are examined in the order they appear on the command line, and the first match determines if a patch to each path is used. A patch to a path that does not match any include/exclude pattern is used by default if there is no include pattern on the command line, and ignored if there is any include pattern.</source>
          <target state="translated">경우 &lt;code&gt;--exclude&lt;/code&gt; 및 &lt;code&gt;--include&lt;/code&gt; 패턴이 사용되며, 그들이 명령 행에 나타나는 순서대로 시험하고, 각 경로에 대한 패치가 이용되는 경우 첫 번째 일치를 판단한다. 포함 / 제외 패턴과 일치하지 않는 경로에 대한 패치는 명령 행에 포함 패턴이없는 경우 기본적으로 사용되며 포함 패턴이 있으면 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="febfb7b902fc970c3396f3068a5c66e59c7ec8ea" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;--notes&lt;/code&gt; is in effect, the message from the notes is matched as if it were part of the log message.</source>
          <target state="translated">때 &lt;code&gt;--notes&lt;/code&gt; 이 적용되는, 노트에서 메시지가 로그 메시지의 일부인 것처럼 일치합니다.</target>
        </trans-unit>
        <trans-unit id="b84c74a91c715b3bf1b4e927529a07a15aed9721" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;--numstat&lt;/code&gt; has been given, do not munge pathnames, but use a NUL-terminated machine-readable format.</source>
          <target state="translated">때 &lt;code&gt;--numstat&lt;/code&gt; 이 주어졌다,하지로 찾으면 경로 이름을하지만, NUL 종료 시스템에서 읽을 수있는 형식을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="d371e700585c518084c33d84fef0af43b13c3439" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;--raw&lt;/code&gt;, &lt;code&gt;--numstat&lt;/code&gt;, &lt;code&gt;--name-only&lt;/code&gt; or &lt;code&gt;--name-status&lt;/code&gt; has been given, do not munge pathnames and use NULs as output field terminators.</source>
          <target state="translated">때 &lt;code&gt;--raw&lt;/code&gt; , &lt;code&gt;--numstat&lt;/code&gt; , &lt;code&gt;--name-only&lt;/code&gt; 또는 &lt;code&gt;--name-status&lt;/code&gt; 주어졌다, 출력 필드 터미네이터로하지로 찾으면 경로 이름과 사용 NUL을 해.</target>
        </trans-unit>
        <trans-unit id="e163d548a1a886a531d60736c2ba3e851388a10a" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;--root&lt;/code&gt; is specified the initial commit will be shown as a big creation event. This is equivalent to a diff against the NULL tree.</source>
          <target state="translated">때 &lt;code&gt;--root&lt;/code&gt; 이 초기 커밋 지정되어 큰 생성 이벤트로 표시됩니다. 이것은 NULL 트리에 대한 diff와 같습니다.</target>
        </trans-unit>
        <trans-unit id="5b88ba2b22685842fbd9b8b75fb2959da8ea9e8b" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;--stdin&lt;/code&gt; is specified, the command does not take &amp;lt;tree-ish&amp;gt; arguments from the command line. Instead, it reads lines containing either two &amp;lt;tree&amp;gt;, one &amp;lt;commit&amp;gt;, or a list of &amp;lt;commit&amp;gt; from its standard input. (Use a single space as separator.)</source>
          <target state="translated">때 &lt;code&gt;--stdin&lt;/code&gt; 옵션이 지정되면, 명령은 명령 줄에서 &amp;lt;트리 틱&amp;gt; 인수를 고려하지 않습니다. 대신 표준 입력에서 두 개의 &amp;lt;tree&amp;gt;, 하나의 &amp;lt;commit&amp;gt; 또는 &amp;lt;commit&amp;gt; 목록을 포함하는 행을 읽습니다. (단일 공백을 구분 기호로 사용하십시오.)</target>
        </trans-unit>
        <trans-unit id="c23ac888d8fe422c1532e2aed10782043e7c6859" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;--temp&lt;/code&gt; is used (or implied by &lt;code&gt;--stage=all&lt;/code&gt;) &lt;code&gt;git checkout-index&lt;/code&gt; will create a temporary file for each index entry being checked out. The index will not be updated with stat information. These options can be useful if the caller needs all stages of all unmerged entries so that the unmerged files can be processed by an external merge tool.</source>
          <target state="translated">때 &lt;code&gt;--temp&lt;/code&gt; 이 사용 (또는 묵시적으로 &lt;code&gt;--stage=all&lt;/code&gt; ) &lt;code&gt;git checkout-index&lt;/code&gt; 각 인덱스 항목의 존재에 대한 임시 파일을 만듭니다 체크 아웃. 인덱스는 통계 정보로 업데이트되지 않습니다. 이러한 옵션은 호출자가 병합되지 않은 모든 항목의 모든 단계를 필요로하여 병합되지 않은 파일을 외부 병합 도구로 처리 할 수있는 경우에 유용합니다.</target>
        </trans-unit>
        <trans-unit id="5c97ac9560dda79ead627bde39274f79b6e5dd8a" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;-S&lt;/code&gt; or &lt;code&gt;-G&lt;/code&gt; are used without &lt;code&gt;--pickaxe-all&lt;/code&gt;, only filepairs that match their respective criterion are kept in the output. When &lt;code&gt;--pickaxe-all&lt;/code&gt; is used, if even one filepair matches their respective criterion in a changeset, the entire changeset is kept. This behavior is designed to make reviewing changes in the context of the whole changeset easier.</source>
          <target state="translated">경우 &lt;code&gt;-S&lt;/code&gt; 또는 &lt;code&gt;-G&lt;/code&gt; 이 없이 사용 &lt;code&gt;--pickaxe-all&lt;/code&gt; , 각각의 기준에 맞는 단지 filepairs 출력으로 유지된다. 경우 &lt;code&gt;--pickaxe-all&lt;/code&gt; 사용 되더라도 하나 filepair가 변경 집합에서 각 기준과 일치하는 경우, 전체 변경 집합이 보존된다. 이 동작은 전체 변경 집합의 컨텍스트에서 변경 사항을 쉽게 검토 할 수 있도록 설계되었습니다.</target>
        </trans-unit>
        <trans-unit id="b7230470efbcbdb8b4c76cdcdcf3272fde68030f" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;-S&lt;/code&gt; or &lt;code&gt;-G&lt;/code&gt; finds a change, show all the changes in that changeset, not just the files that contain the change in &amp;lt;string&amp;gt;.</source>
          <target state="translated">때 &lt;code&gt;-S&lt;/code&gt; 또는 &lt;code&gt;-G&lt;/code&gt; 이 변화를 발견, 그 변경 집합의 모든 변경, &amp;lt;문자열&amp;gt;의 변화를 포함 할뿐만 아니라 파일을 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="b52ce403c26e2631158c50ee6bd3c17065ed82dc" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;-u&lt;/code&gt; option is not used, untracked files and directories are shown (i.e. the same as specifying &lt;code&gt;normal&lt;/code&gt;), to help you avoid forgetting to add newly created files. Because it takes extra work to find untracked files in the filesystem, this mode may take some time in a large working tree. Consider enabling untracked cache and split index if supported (see &lt;code&gt;git update-index --untracked-cache&lt;/code&gt; and &lt;code&gt;git update-index
--split-index&lt;/code&gt;), Otherwise you can use &lt;code&gt;no&lt;/code&gt; to have &lt;code&gt;git status&lt;/code&gt; return more quickly without showing untracked files.</source>
          <target state="translated">때 &lt;code&gt;-u&lt;/code&gt; 옵션을 사용하지, 비 추적 파일 및 디렉토리 (지정하는 것과 즉, 같은 표시됩니다 &lt;code&gt;normal&lt;/code&gt; 이 새로 생성 된 파일을 추가 할 잊는 피할 수 있도록,). 파일 시스템에서 추적되지 않은 파일을 찾으려면 추가 작업이 필요하므로이 모드는 큰 작업 트리에서 시간이 걸릴 수 있습니다. 지원되는 경우 추적되지 않은 캐시 및 분할 인덱스 사용을 고려하십시오 ( &lt;code&gt;git update-index --untracked-cache&lt;/code&gt; 및 &lt;code&gt;git update-index --split-index&lt;/code&gt; ). 그렇지 않으면 추적되지 않은 파일을 표시하지 않고 &lt;code&gt;git status&lt;/code&gt; 더 빨리 반환 하도록 &lt;code&gt;no&lt;/code&gt; 를 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="97c7c816e31485397947c4cd78f79e742f80ec39" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;-z&lt;/code&gt; output option is in effect, the output is formatted this way:</source>
          <target state="translated">때 &lt;code&gt;-z&lt;/code&gt; 출력 옵션이 적용되는 출력이 방법을 포맷 :</target>
        </trans-unit>
        <trans-unit id="2bf71954fc8fac90c9030e3b9b1232971580d22a" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;FETCH_HEAD&lt;/code&gt; (and no other commit) is specified, the branches recorded in the &lt;code&gt;.git/FETCH_HEAD&lt;/code&gt; file by the previous invocation of &lt;code&gt;git fetch&lt;/code&gt; for merging are merged to the current branch.</source>
          <target state="translated">때 &lt;code&gt;FETCH_HEAD&lt;/code&gt; (그리고 다른 커밋하지)가 지정되면, 기록 가지 &lt;code&gt;.git/FETCH_HEAD&lt;/code&gt; 의 이전 호출에 의해 파일 &lt;code&gt;git fetch&lt;/code&gt; 현재 브랜치에 병합 병합.</target>
        </trans-unit>
        <trans-unit id="093107f57324ea8ddf834562dc5da735634ce1c2" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;fetch.fsckObjects&lt;/code&gt; or &lt;code&gt;receive.fsckObjects&lt;/code&gt; are not set, the value of this variable is used instead. Defaults to false.</source>
          <target state="translated">경우 &lt;code&gt;fetch.fsckObjects&lt;/code&gt; 또는 &lt;code&gt;receive.fsckObjects&lt;/code&gt; 가 설정되지 않은 경우,이 변수의 값이 대신 사용된다. 기본값은 false입니다.</target>
        </trans-unit>
        <trans-unit id="f0f4e4ab298d72d3ce878991ffe1cd2532ffab74" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;fetch.unpackLimit&lt;/code&gt; or &lt;code&gt;receive.unpackLimit&lt;/code&gt; are not set, the value of this variable is used instead. The default value is 100.</source>
          <target state="translated">경우 &lt;code&gt;fetch.unpackLimit&lt;/code&gt; 또는 &lt;code&gt;receive.unpackLimit&lt;/code&gt; 가 설정되지 않은 경우,이 변수의 값이 대신 사용된다. 기본값은 100입니다.</target>
        </trans-unit>
        <trans-unit id="0f43e1a31ad9e45784cdafec68b8141e1a628402" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;fsck.&amp;lt;msg-id&amp;gt;&lt;/code&gt; is set, errors can be switched to warnings and vice versa by configuring the &lt;code&gt;fsck.&amp;lt;msg-id&amp;gt;&lt;/code&gt; setting where the &lt;code&gt;&amp;lt;msg-id&amp;gt;&lt;/code&gt; is the fsck message ID and the value is one of &lt;code&gt;error&lt;/code&gt;, &lt;code&gt;warn&lt;/code&gt; or &lt;code&gt;ignore&lt;/code&gt;. For convenience, fsck prefixes the error/warning with the message ID, e.g. &quot;missingEmail: invalid author/committer line - missing email&quot; means that setting &lt;code&gt;fsck.missingEmail = ignore&lt;/code&gt; will hide that issue.</source>
          <target state="translated">경우 &lt;code&gt;fsck.&amp;lt;msg-id&amp;gt;&lt;/code&gt; 설정 오류는 마찬가지 구성하여 경고 및 부사로 전환 될 수 &lt;code&gt;fsck.&amp;lt;msg-id&amp;gt;&lt;/code&gt; 설정 여기서 &lt;code&gt;&amp;lt;msg-id&amp;gt;&lt;/code&gt; fsck를 메시지 ID이고, 값 중 하나 인 &lt;code&gt;error&lt;/code&gt; , &lt;code&gt;warn&lt;/code&gt; 또는 &lt;code&gt;ignore&lt;/code&gt; . 편의상 fsck는 오류 / 경고에 메시지 ID가 접두어로 붙습니다 (예 : &quot;missingEmail : 잘못된 작성자 / 커미터 라인-이메일 누락&quot;)는 &lt;code&gt;fsck.missingEmail = ignore&lt;/code&gt; 를 설정 하면 해당 문제가 숨겨집니다.</target>
        </trans-unit>
        <trans-unit id="ce3f108ee8253a42ecb067bc1a011bcbcd3ad290" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;git apply&lt;/code&gt; is used as a &quot;better GNU patch&quot;, the user can pass the &lt;code&gt;--unsafe-paths&lt;/code&gt; option to override this safety check. This option has no effect when &lt;code&gt;--index&lt;/code&gt; or &lt;code&gt;--cached&lt;/code&gt; is in use.</source>
          <target state="translated">때 &lt;code&gt;git apply&lt;/code&gt; 는 &quot;더 나은 GNU 패치&quot;로 사용하는 경우, 사용자는 통과 할 수 &lt;code&gt;--unsafe-paths&lt;/code&gt; 이 안전 점검을 무시하는 옵션을 선택합니다. &lt;code&gt;--index&lt;/code&gt; 또는 &lt;code&gt;--cached&lt;/code&gt; 를 사용중인 경우이 옵션은 적용되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="dea5ce8f581717a21d1ee89e4952655599f11488" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;git difftool&lt;/code&gt; is invoked with this tool (either through the &lt;code&gt;-t&lt;/code&gt; or &lt;code&gt;--tool&lt;/code&gt; option or the &lt;code&gt;diff.tool&lt;/code&gt; configuration variable) the configured command line will be invoked with the following variables available: &lt;code&gt;$LOCAL&lt;/code&gt; is set to the name of the temporary file containing the contents of the diff pre-image and &lt;code&gt;$REMOTE&lt;/code&gt; is set to the name of the temporary file containing the contents of the diff post-image. &lt;code&gt;$MERGED&lt;/code&gt; is the name of the file which is being compared. &lt;code&gt;$BASE&lt;/code&gt; is provided for compatibility with custom merge tool commands and has the same value as &lt;code&gt;$MERGED&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;git difftool&lt;/code&gt; 이이 도구로 호출 되면 ( &lt;code&gt;-t&lt;/code&gt; 또는 &lt;code&gt;--tool&lt;/code&gt; 옵션 또는 &lt;code&gt;diff.tool&lt;/code&gt; 구성 변수를 통해) 다음 명령을 사용하여 구성된 명령 행이 호출됩니다. &lt;code&gt;$LOCAL&lt;/code&gt; 은 임시 이름으로 설정됩니다. diff pre-image의 내용이 포함 된 파일 및 &lt;code&gt;$REMOTE&lt;/code&gt; 는 diff post-image의 내용이 포함 된 임시 파일의 이름으로 설정됩니다. &lt;code&gt;$MERGED&lt;/code&gt; 는 비교중인 파일의 이름입니다. &lt;code&gt;$BASE&lt;/code&gt; 는 사용자 정의 병합 도구 명령과의 호환성을 위해 제공되며 &lt;code&gt;$MERGED&lt;/code&gt; 와 동일한 값을 갖습니다 .</target>
        </trans-unit>
        <trans-unit id="02bc7953c8eb819402a97fdb05db86103d3e94f0" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;git fetch&lt;/code&gt; is run with explicit branches and/or tags to fetch on the command line, e.g. &lt;code&gt;git fetch origin master&lt;/code&gt;, the &amp;lt;refspec&amp;gt;s given on the command line determine what are to be fetched (e.g. &lt;code&gt;master&lt;/code&gt; in the example, which is a short-hand for &lt;code&gt;master:&lt;/code&gt;, which in turn means &quot;fetch the &lt;code&gt;master&lt;/code&gt; branch but I do not explicitly say what remote-tracking branch to update with it from the command line&quot;), and the example command will fetch &lt;code&gt;only&lt;/code&gt; the &lt;code&gt;master&lt;/code&gt; branch. The &lt;code&gt;remote.&amp;lt;repository&amp;gt;.fetch&lt;/code&gt; values determine which remote-tracking branch, if any, is updated. When used in this way, the &lt;code&gt;remote.&amp;lt;repository&amp;gt;.fetch&lt;/code&gt; values do not have any effect in deciding &lt;code&gt;what&lt;/code&gt; gets fetched (i.e. the values are not used as refspecs when the command-line lists refspecs); they are only used to decide &lt;code&gt;where&lt;/code&gt; the refs that are fetched are stored by acting as a mapping.</source>
          <target state="translated">때 &lt;code&gt;git fetch&lt;/code&gt; , 명령 행에서 가져 오기 위해 명시 적 지점 및 / 또는 태그 실행 예를 들어 &lt;code&gt;git fetch origin master&lt;/code&gt; 의 &amp;lt;refspec&amp;gt;의 (가져온 것으로 예를 들어 어떤 결정 명령 행에 주어진 &lt;code&gt;master&lt;/code&gt; 인 예에서 에 대한 간략 &lt;code&gt;master:&lt;/code&gt; 회전 수단 &quot;페치, &lt;code&gt;master&lt;/code&gt; ) 지점을하지만 명시 적으로 명령 줄에서 그것으로 업데이 트에 지점을 원격 추적 무슨 말을하지 않습니다&quot;하고 예제 명령은 가져옵니다 &lt;code&gt;only&lt;/code&gt; &lt;code&gt;master&lt;/code&gt; 분기를. &lt;code&gt;remote.&amp;lt;repository&amp;gt;.fetch&lt;/code&gt; 값이 갱신되어있는 경우, 분기 원격 추적 결정. 이런 식으로 사용하면 &lt;code&gt;remote.&amp;lt;repository&amp;gt;.fetch&lt;/code&gt; 가져올 값 을 결정 &lt;code&gt;what&lt;/code&gt; 데 값이 영향을 미치지 않습니다 (즉, 명령 행이 참조 스펙을 나열 할 때 값이 참조 스펙으로 사용되지 않음). 페치 된 참조가 맵핑 역할을 수행하여 저장되는 &lt;code&gt;where&lt;/code&gt; 를 결정 하는 데에만 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="d3bb27ea8d5739147518646e08d478432b5ac353" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;git fetch&lt;/code&gt; is run without specifying what branches and/or tags to fetch on the command line, e.g. &lt;code&gt;git fetch origin&lt;/code&gt; or &lt;code&gt;git fetch&lt;/code&gt;, &lt;code&gt;remote.&amp;lt;repository&amp;gt;.fetch&lt;/code&gt; values are used as the refspecs&amp;mdash;​they specify which refs to fetch and which local refs to update. The example above will fetch all branches that exist in the &lt;code&gt;origin&lt;/code&gt; (i.e. any ref that matches the left-hand side of the value, &lt;code&gt;refs/heads/*&lt;/code&gt;) and update the corresponding remote-tracking branches in the &lt;code&gt;refs/remotes/origin/*&lt;/code&gt; hierarchy.</source>
          <target state="translated">때 &lt;code&gt;git fetch&lt;/code&gt; 지점 및 / 또는 태그 예를 들어, 명령 행에서 가져 오기 위해 무엇을 지정하지 않고 실행 &lt;code&gt;git fetch origin&lt;/code&gt; 또는 &lt;code&gt;git fetch&lt;/code&gt; , &lt;code&gt;remote.&amp;lt;repository&amp;gt;.fetch&lt;/code&gt; 값들이 인출 할 심판 지정 refspecs-로 사용되며, 업데이트 할 로컬 참조 위의 예는 &lt;code&gt;origin&lt;/code&gt; 존재하는 모든 분기 (예 : 값의 왼쪽과 일치하는 &lt;code&gt;refs/heads/*&lt;/code&gt; )를 가져오고 &lt;code&gt;refs/remotes/origin/*&lt;/code&gt; 에서 해당 원격 추적 분기를 업데이트합니다. 계층.</target>
        </trans-unit>
        <trans-unit id="6bfc306f6ccec6cbac00c82d44f7befe47671739" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;git fetch&lt;/code&gt; is used with &lt;code&gt;&amp;lt;src&amp;gt;:&amp;lt;dst&amp;gt;&lt;/code&gt; refspec it may refuse to update the local branch as discussed in the &lt;code&gt;&amp;lt;refspec&amp;gt;&lt;/code&gt; part below. This option overrides that check.</source>
          <target state="translated">&lt;code&gt;git fetch&lt;/code&gt; 를 &lt;code&gt;&amp;lt;src&amp;gt;:&amp;lt;dst&amp;gt;&lt;/code&gt; refspec 과 함께 사용 하면 아래 &lt;code&gt;&amp;lt;refspec&amp;gt;&lt;/code&gt; 부분 에서 설명한대로 로컬 분기 업데이트를 거부 할 수 있습니다. 이 옵션은 해당 검사를 무시합니다.</target>
        </trans-unit>
        <trans-unit id="b8a0a18f13c1248a211519fc4b6c3ee775403075" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;git fetch&lt;/code&gt; is used with &lt;code&gt;&amp;lt;src&amp;gt;:&amp;lt;dst&amp;gt;&lt;/code&gt; refspec it may refuse to update the local branch as discussed in the &lt;code&gt;&amp;lt;refspec&amp;gt;&lt;/code&gt; part of the &lt;a href=&quot;git-fetch&quot;&gt;git-fetch[1]&lt;/a&gt; documentation. This option overrides that check.</source>
          <target state="translated">경우 &lt;code&gt;git fetch&lt;/code&gt; 에 사용되는 &lt;code&gt;&amp;lt;src&amp;gt;:&amp;lt;dst&amp;gt;&lt;/code&gt; refspec는 논의 된 것처럼 로컬 브랜치를 업데이트 거부 &lt;code&gt;&amp;lt;refspec&amp;gt;&lt;/code&gt; 의 일부 &lt;a href=&quot;git-fetch&quot;&gt;자식 페치 [1]&lt;/a&gt; 문서. 이 옵션은 해당 검사를 무시합니다.</target>
        </trans-unit>
        <trans-unit id="946d45913d1a6d20975808ddb9f4de7a3a592055" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;git gc&lt;/code&gt; is run, it calls &lt;code&gt;git worktree prune --expire 3.months.ago&lt;/code&gt;. This config variable can be used to set a different grace period. The value &quot;now&quot; may be used to disable the grace period and prune &lt;code&gt;$GIT_DIR/worktrees&lt;/code&gt; immediately, or &quot;never&quot; may be used to suppress pruning.</source>
          <target state="translated">&lt;code&gt;git gc&lt;/code&gt; 가 실행될 때 git &lt;code&gt;git worktree prune --expire 3.months.ago&lt;/code&gt; 호출합니다 . 이 구성 변수를 사용하여 다른 유예 기간을 설정할 수 있습니다. &quot;now&quot;값은 유예 기간을 비활성화하고 &lt;code&gt;$GIT_DIR/worktrees&lt;/code&gt; 즉시 프룬 (prune)하거나 &quot;never&quot;를 사용하여 프 루닝을 억제 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="bdaf9b565f5bc5effacd5e94ca1e6e23df9c9f7a" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;git gc&lt;/code&gt; is run, it will call &lt;code&gt;prune --expire 2.weeks.ago&lt;/code&gt;. Override the grace period with this config variable. The value &quot;now&quot; may be used to disable this grace period and always prune unreachable objects immediately, or &quot;never&quot; may be used to suppress pruning. This feature helps prevent corruption when &lt;code&gt;git gc&lt;/code&gt; runs concurrently with another process writing to the repository; see the &quot;NOTES&quot; section of &lt;a href=&quot;git-gc&quot;&gt;git-gc[1]&lt;/a&gt;.</source>
          <target state="translated">때 &lt;code&gt;git gc&lt;/code&gt; 실행되고, 그것은 호출 &lt;code&gt;prune --expire 2.weeks.ago&lt;/code&gt; . 이 구성 변수로 유예 기간을 재정의하십시오. &quot;now&quot;값은이 유예 기간을 비활성화하고 항상 도달 할 수없는 개체를 즉시 제거하거나 &quot;never&quot;를 사용하여 제거를 억제 할 수 있습니다. 이 기능은 &lt;code&gt;git gc&lt;/code&gt; 가 저장소에 쓰는 다른 프로세스와 동시에 실행될 때 손상을 방지 합니다. &lt;a href=&quot;git-gc&quot;&gt;git-gc [1]&lt;/a&gt; 의 &quot;NOTES&quot;섹션을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="9771ab35f0db8c62ffb81b026ac116ab479df958" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;git mergetool&lt;/code&gt; is invoked with this tool (either through the &lt;code&gt;-t&lt;/code&gt; or &lt;code&gt;--tool&lt;/code&gt; option or the &lt;code&gt;merge.tool&lt;/code&gt; configuration variable) the configured command line will be invoked with &lt;code&gt;$BASE&lt;/code&gt; set to the name of a temporary file containing the common base for the merge, if available; &lt;code&gt;$LOCAL&lt;/code&gt; set to the name of a temporary file containing the contents of the file on the current branch; &lt;code&gt;$REMOTE&lt;/code&gt; set to the name of a temporary file containing the contents of the file to be merged, and &lt;code&gt;$MERGED&lt;/code&gt; set to the name of the file to which the merge tool should write the result of the merge resolution.</source>
          <target state="translated">때 &lt;code&gt;git mergetool&lt;/code&gt; (스루 중 하나를이 도구를 호출 &lt;code&gt;-t&lt;/code&gt; 또는 &lt;code&gt;--tool&lt;/code&gt; 옵션 또는 &lt;code&gt;merge.tool&lt;/code&gt; 에 구성된 명령 줄이 호출됩니다 구성 변수) &lt;code&gt;$BASE&lt;/code&gt; 공통 기반을 포함하는 임시 파일의 이름으로 설정 가능한 경우 병합; &lt;code&gt;$LOCAL&lt;/code&gt; 은 현재 분기의 파일 내용을 포함하는 임시 파일 이름으로 설정됩니다. &lt;code&gt;$REMOTE&lt;/code&gt; 는 병합 될 파일의 ​​내용을 포함하는 임시 파일 이름으로 설정 되고 &lt;code&gt;$MERGED&lt;/code&gt; 는 병합 도구가 병합 분석 결과를 작성해야하는 파일 이름으로 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="8d649c2a1b515f828b380ed0228639a9abf6f2e7" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;git-difftool&lt;/code&gt; is invoked with the &lt;code&gt;-g&lt;/code&gt; or &lt;code&gt;--gui&lt;/code&gt; option the default diff tool will be read from the configured &lt;code&gt;diff.guitool&lt;/code&gt; variable instead of &lt;code&gt;diff.tool&lt;/code&gt;. The &lt;code&gt;--no-gui&lt;/code&gt; option can be used to override this setting. If &lt;code&gt;diff.guitool&lt;/code&gt; is not set, we will fallback in the order of &lt;code&gt;merge.guitool&lt;/code&gt;, &lt;code&gt;diff.tool&lt;/code&gt;, &lt;code&gt;merge.tool&lt;/code&gt; until a tool is found.</source>
          <target state="translated">때 &lt;code&gt;git-difftool&lt;/code&gt; 를 호출 &lt;code&gt;-g&lt;/code&gt; 또는 &lt;code&gt;--gui&lt;/code&gt; 옵션 기본은 diff 도구는 구성에서 읽을 수 있습니다 &lt;code&gt;diff.guitool&lt;/code&gt; 의 변수 대신 &lt;code&gt;diff.tool&lt;/code&gt; . &lt;code&gt;--no-gui&lt;/code&gt; 옵션이 설정을 대체 할 수 있습니다. 경우 &lt;code&gt;diff.guitool&lt;/code&gt; 가 설정되어 있지 않은, 우리의 순서로 폴백합니다 &lt;code&gt;merge.guitool&lt;/code&gt; , &lt;code&gt;diff.tool&lt;/code&gt; , &lt;code&gt;merge.tool&lt;/code&gt; 도구가 발견 될 때까지.</target>
        </trans-unit>
        <trans-unit id="dab1778e78eece39a70fe4959b77fef05af95366" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;git-mergetool&lt;/code&gt; is invoked with the &lt;code&gt;-g&lt;/code&gt; or &lt;code&gt;--gui&lt;/code&gt; option the default merge tool will be read from the configured &lt;code&gt;merge.guitool&lt;/code&gt; variable instead of &lt;code&gt;merge.tool&lt;/code&gt;. If &lt;code&gt;merge.guitool&lt;/code&gt; is not set, we will fallback to the tool configured under &lt;code&gt;merge.tool&lt;/code&gt;.</source>
          <target state="translated">때 &lt;code&gt;git-mergetool&lt;/code&gt; 를 호출 &lt;code&gt;-g&lt;/code&gt; 또는 &lt;code&gt;--gui&lt;/code&gt; 옵션 기본 병합 도구는 구성에서 읽을 수 있습니다 &lt;code&gt;merge.guitool&lt;/code&gt; 의 변수 대신 &lt;code&gt;merge.tool&lt;/code&gt; . 경우 &lt;code&gt;merge.guitool&lt;/code&gt; 가 설정되어 있지 않은, 우리는에서 구성 도구로 폴백합니다 &lt;code&gt;merge.tool&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="55d1f905322639499a3e0c7d64b920e915841fa1" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;group&lt;/code&gt; (or &lt;code&gt;true&lt;/code&gt;), the repository is made shareable between several users in a group (making sure all the files and objects are group-writable). When &lt;code&gt;all&lt;/code&gt; (or &lt;code&gt;world&lt;/code&gt; or &lt;code&gt;everybody&lt;/code&gt;), the repository will be readable by all users, additionally to being group-shareable. When &lt;code&gt;umask&lt;/code&gt; (or &lt;code&gt;false&lt;/code&gt;), Git will use permissions reported by umask(2). When &lt;code&gt;0xxx&lt;/code&gt;, where &lt;code&gt;0xxx&lt;/code&gt; is an octal number, files in the repository will have this mode value. &lt;code&gt;0xxx&lt;/code&gt; will override user&amp;rsquo;s umask value (whereas the other options will only override requested parts of the user&amp;rsquo;s umask value). Examples: &lt;code&gt;0660&lt;/code&gt; will make the repo read/write-able for the owner and group, but inaccessible to others (equivalent to &lt;code&gt;group&lt;/code&gt; unless umask is e.g. &lt;code&gt;0022&lt;/code&gt;). &lt;code&gt;0640&lt;/code&gt; is a repository that is group-readable but not group-writable. See &lt;a href=&quot;git-init&quot;&gt;git-init[1]&lt;/a&gt;. False by default.</source>
          <target state="translated">때 &lt;code&gt;group&lt;/code&gt; (또는 &lt;code&gt;true&lt;/code&gt; ), 저장소가 그룹에 여러 사용자간에 공유한다 (파일 및 객체 그룹 쓸 수 있는지 모든 제작). 때 &lt;code&gt;all&lt;/code&gt; (또는 &lt;code&gt;world&lt;/code&gt; 또는 &lt;code&gt;everybody&lt;/code&gt; ), 저장소에 추가 그룹 공유되기 위해서는, 모든 사용자가 읽을 수 있습니다. 때 &lt;code&gt;umask&lt;/code&gt; (또는 &lt;code&gt;false&lt;/code&gt; ), 힘내 권한을 사용의 umask (2)에 의해보고했다. 때 &lt;code&gt;0xxx&lt;/code&gt; 여기서 &lt;code&gt;0xxx&lt;/code&gt; 는 8 진수이며, 저장소에있는 파일이 모드의 값을 갖게됩니다. &lt;code&gt;0xxx&lt;/code&gt; 는 사용자의 umask 값을 대체합니다 (다른 옵션은 사용자의 umask 값의 요청 된 부분 만 대체합니다). 예 : &lt;code&gt;0660&lt;/code&gt; repo는 소유자와 그룹에 대해 읽기 / 쓰기가 가능하지만 다른 사람은 액세스 할 수 없게합니다 ( umask가 예를 들어 &lt;code&gt;0022&lt;/code&gt; 가 아닌 경우 &lt;code&gt;group&lt;/code&gt; 과 동일 ). &lt;code&gt;0640&lt;/code&gt; 은 그룹에서 읽을 수 있지만 그룹에서 쓸 수없는 저장소입니다. &lt;a href=&quot;git-init&quot;&gt;git-init [1]을&lt;/a&gt; 참조하십시오 . 기본적으로 False입니다.</target>
        </trans-unit>
        <trans-unit id="0c640b1443fdc376fb0e05e5b19871e0f70bfa75" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;interactive&lt;/code&gt;, enable the interactive mode of rebase.</source>
          <target state="translated">때 &lt;code&gt;interactive&lt;/code&gt; , REBASE의 대화 형 모드를 가능하게한다.</target>
        </trans-unit>
        <trans-unit id="0e5d1d0d5309f291d73a19a6f71347b59d761978" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;konqueror&lt;/code&gt; is specified in the &lt;code&gt;man.viewer&lt;/code&gt; configuration variable, we launch &lt;code&gt;kfmclient&lt;/code&gt; to try to open the man page on an already opened konqueror in a new tab if possible.</source>
          <target state="translated">&lt;code&gt;konqueror&lt;/code&gt; 가 &lt;code&gt;man.viewer&lt;/code&gt; 구성 변수에 지정 되면 &lt;code&gt;kfmclient&lt;/code&gt; 를 시작 하여 가능한 경우 이미 열린 konqueror의 매뉴얼 페이지를 새 탭에서 열려고 시도합니다.</target>
        </trans-unit>
        <trans-unit id="162b4f89725e01e084b1d2a9bb66f41a211da6f6" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;matching&lt;/code&gt; mode is specified, paths that explicitly match an ignored pattern are shown. If a directory matches an ignore pattern, then it is shown, but not paths contained in the ignored directory. If a directory does not match an ignore pattern, but all contents are ignored, then the directory is not shown, but all contents are shown.</source>
          <target state="translated">때 &lt;code&gt;matching&lt;/code&gt; 모드를 지정, 명시 적으로 무시 패턴과 일치하는 경로가 표시됩니다. 디렉토리가 무시 패턴과 일치하면 무시 된 디렉토리에 포함 된 경로는 표시되지 않습니다. 디렉토리가 무시 패턴과 일치하지 않지만 모든 내용이 무시되면 디렉토리는 표시되지 않지만 모든 내용이 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="239b51beb1f8c13233881b0568518d58e269df96" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;merges&lt;/code&gt;, pass the &lt;code&gt;--rebase-merges&lt;/code&gt; option to &lt;code&gt;git rebase&lt;/code&gt; so that the local merge commits are included in the rebase (see &lt;a href=&quot;git-rebase&quot;&gt;git-rebase[1]&lt;/a&gt; for details).</source>
          <target state="translated">하면 &lt;code&gt;merges&lt;/code&gt; , 통과 &lt;code&gt;--rebase-merges&lt;/code&gt; 하는 옵션이 &lt;code&gt;git rebase&lt;/code&gt; 로컬 병합 커밋이 REBASE에 포함되는 정도 (참조 &lt;a href=&quot;git-rebase&quot;&gt;자식-REBASE [1]&lt;/a&gt; 세부 사항 참조).</target>
        </trans-unit>
        <trans-unit id="26887709475bb99a484f3550dfcf66463a02ff1c" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;preserve&lt;/code&gt; (deprecated in favor of &lt;code&gt;merges&lt;/code&gt;), also pass &lt;code&gt;--preserve-merges&lt;/code&gt; along to &lt;code&gt;git rebase&lt;/code&gt; so that locally committed merge commits will not be flattened by running &lt;code&gt;git pull&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;preserve&lt;/code&gt; 할 때 ( &lt;code&gt;merges&lt;/code&gt; 을 위해 더 이상 사용되지 않음 ), &lt;code&gt;git pull&lt;/code&gt; 을 실행하여 로컬 커밋 된 병합 커밋이 병합되지 않도록 &lt;code&gt;--preserve-merges&lt;/code&gt; 를 &lt;code&gt;git rebase&lt;/code&gt; 에전달하십시오 .</target>
        </trans-unit>
        <trans-unit id="c040d756e251986ff4d930aa40402b774da81b76" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;preserveUser&lt;/code&gt; is true, &lt;code&gt;git p4&lt;/code&gt; normally dies if it cannot find an author in the p4 user map. This setting submits the change regardless.</source>
          <target state="translated">때 &lt;code&gt;preserveUser&lt;/code&gt; 는 사실, &lt;code&gt;git p4&lt;/code&gt; 그것이 P4 사용자 맵에서 저자를 찾을 수없는 경우 일반적으로 죽는다. 이 설정은 관계없이 변경 사항을 제출합니다.</target>
        </trans-unit>
        <trans-unit id="f1cb457481e4cab2531cdb48fb2ed70a72c47f80" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;receive-pack&lt;/code&gt; takes in objects, they are placed into a temporary &quot;quarantine&quot; directory within the &lt;code&gt;$GIT_DIR/objects&lt;/code&gt; directory and migrated into the main object store only after the &lt;code&gt;pre-receive&lt;/code&gt; hook has completed. If the push fails before then, the temporary directory is removed entirely.</source>
          <target state="translated">&lt;code&gt;receive-pack&lt;/code&gt; 이 오브젝트를 가져 오면 &lt;code&gt;$GIT_DIR/objects&lt;/code&gt; 디렉토리 내의 임시 &quot;검역&quot;디렉토리에 배치되고 &lt;code&gt;pre-receive&lt;/code&gt; 후크가 완료된 후에 만 주 오브젝트 저장소로 마이그레이션됩니다 . 그 전에 푸시가 실패하면 임시 디렉토리가 완전히 제거됩니다.</target>
        </trans-unit>
        <trans-unit id="13eed45e8cb127a4420b06f0b52f497c696b7d45" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;text&lt;/code&gt; is set to &quot;auto&quot;, the path is marked for automatic end-of-line conversion. If Git decides that the content is text, its line endings are converted to LF on checkin. When the file has been committed with CRLF, no conversion is done.</source>
          <target state="translated">&lt;code&gt;text&lt;/code&gt; 가 &quot;자동&quot;으로 설정 되면 경로가 자동 줄 끝 변환으로 표시됩니다. Git이 내용이 텍스트라고 결정하면 체크인시 줄 끝이 LF로 변환됩니다. 파일이 CRLF로 커밋되면 변환이 수행되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="2bb8610f0d3f51c94aca7dd51e3603814301750d" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;text=auto&lt;/code&gt; conversion is enabled in a cross-platform project using push and pull to a central repository the text files containing CRLFs should be normalized.</source>
          <target state="translated">때 &lt;code&gt;text=auto&lt;/code&gt; 변환이 중앙 저장소에있는 CRLF를 포함하는 텍스트 파일을 푸시와 풀을 사용하여 크로스 플랫폼 프로젝트에서 사용 가능 정상화해야한다.</target>
        </trans-unit>
        <trans-unit id="f1b569ad0a0d3f731d90377a830d25de99487fad" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;upload-pack&lt;/code&gt; has started &lt;code&gt;pack-objects&lt;/code&gt;, there may be a quiet period while &lt;code&gt;pack-objects&lt;/code&gt; prepares the pack. Normally it would output progress information, but if &lt;code&gt;--quiet&lt;/code&gt; was used for the fetch, &lt;code&gt;pack-objects&lt;/code&gt; will output nothing at all until the pack data begins. Some clients and networks may consider the server to be hung and give up. Setting this option instructs &lt;code&gt;upload-pack&lt;/code&gt; to send an empty keepalive packet every &lt;code&gt;uploadpack.keepAlive&lt;/code&gt; seconds. Setting this option to 0 disables keepalive packets entirely. The default is 5 seconds.</source>
          <target state="translated">때 &lt;code&gt;upload-pack&lt;/code&gt; 시작 &lt;code&gt;pack-objects&lt;/code&gt; 하면서, 조용한 기간이있을 수 있습니다 &lt;code&gt;pack-objects&lt;/code&gt; 팩을 준비합니다. 일반적으로는 출력 진행 정보는 것이지만, 경우에 &lt;code&gt;--quiet&lt;/code&gt; 이 사용 된이 인출 &lt;code&gt;pack-objects&lt;/code&gt; 것이다 팩 데이터까지 모두에서 출력 아무것도 시작하지 않습니다. 일부 클라이언트와 네트워크는 서버가 중단 된 것으로 간주 할 수 있습니다. 이 옵션을 설정하면 &lt;code&gt;upload-pack&lt;/code&gt; 이 &lt;code&gt;uploadpack.keepAlive&lt;/code&gt; 초 마다 빈 keepalive 패킷을 보내도록 지시 합니다. 이 옵션을 0으로 설정하면 keepalive 패킷이 완전히 비활성화됩니다. 기본값은 5 초입니다.</target>
        </trans-unit>
        <trans-unit id="09ea8c9e4617731ed2a0cdf40185d39ec477e171" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;uploadpack.hideRefs&lt;/code&gt; is in effect, allow &lt;code&gt;upload-pack&lt;/code&gt; to accept a fetch request that asks for an object at the tip of a hidden ref (by default, such a request is rejected). See also &lt;code&gt;uploadpack.hideRefs&lt;/code&gt;. Even if this is false, a client may be able to steal objects via the techniques described in the &quot;SECURITY&quot; section of the &lt;a href=&quot;gitnamespaces&quot;&gt;gitnamespaces[7]&lt;/a&gt; man page; it&amp;rsquo;s best to keep private data in a separate repository.</source>
          <target state="translated">때 &lt;code&gt;uploadpack.hideRefs&lt;/code&gt; 가 적용되는 허용 &lt;code&gt;upload-pack&lt;/code&gt; 숨겨진 심판의 끝에서 개체에 대해 묻는 가져 오기 요청을 수락 (기본적으로, 이러한 요청이 거부됩니다). &lt;code&gt;uploadpack.hideRefs&lt;/code&gt; 도 참조하십시오 . 이것이 잘못된 경우에도 클라이언트는 &lt;a href=&quot;gitnamespaces&quot;&gt;gitnamespaces [7]&lt;/a&gt; 매뉴얼 페이지 의 &quot;보안&quot;섹션에 설명 된 기술을 통해 객체를 훔칠 수 있습니다 . 개인 데이터를 별도의 저장소에 보관하는 것이 가장 좋습니다.</target>
        </trans-unit>
        <trans-unit id="5f953a201b0ae4d35f35034718b3114ef928787f" translate="yes" xml:space="preserve">
          <source>When Git doesn&amp;rsquo;t know how to handle a certain transport protocol, it attempts to use the &lt;code&gt;remote-&amp;lt;transport&amp;gt;&lt;/code&gt; remote helper, if one exists. To explicitly request a remote helper, the following syntax may be used:</source>
          <target state="translated">Git이 특정 전송 프로토콜을 처리하는 방법을 모르면 &lt;code&gt;remote-&amp;lt;transport&amp;gt;&lt;/code&gt; 원격 도우미 (있는 경우) 를 사용하려고 시도 합니다. 원격 헬퍼를 명시 적으로 요청하기 위해 다음 구문을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="cf58a154a8f8fa8889640812d376b7964ce7bef2" translate="yes" xml:space="preserve">
          <source>When Git encounters a URL of the form &lt;code&gt;&amp;lt;transport&amp;gt;://&amp;lt;address&amp;gt;&lt;/code&gt;, where &lt;code&gt;&amp;lt;transport&amp;gt;&lt;/code&gt; is a protocol that it cannot handle natively, it automatically invokes &lt;code&gt;git remote-&amp;lt;transport&amp;gt;&lt;/code&gt; with the full URL as the second argument. If such a URL is encountered directly on the command line, the first argument is the same as the second, and if it is encountered in a configured remote, the first argument is the name of that remote.</source>
          <target state="translated">힘내 형식의 URL 발견하면 &lt;code&gt;&amp;lt;transport&amp;gt;://&amp;lt;address&amp;gt;&lt;/code&gt; 여기서 &lt;code&gt;&amp;lt;transport&amp;gt;&lt;/code&gt; 입니다 그것은 기본적으로, 자동으로 발동 할 처리 할 수없는 프로토콜 &lt;code&gt;git remote-&amp;lt;transport&amp;gt;&lt;/code&gt; 두 번째 인수로 전체 URL과 함께. 이러한 URL이 명령 행에서 직접 발견되면 첫 번째 인수는 두 번째 인수와 동일하며 구성된 리모트에서 발견되는 경우 첫 번째 인수는 해당 리모트의 이름입니다.</target>
        </trans-unit>
        <trans-unit id="27018e5bb4c8622ebcfed2f81b80284203c3bc2f" translate="yes" xml:space="preserve">
          <source>When Git encounters the first file that needs to be cleaned or smudged, it starts the filter and performs the handshake. In the handshake, the welcome message sent by Git is &quot;git-filter-client&quot;, only version 2 is supported, and the supported capabilities are &quot;clean&quot;, &quot;smudge&quot;, and &quot;delay&quot;.</source>
          <target state="translated">Git은 청소 또는 얼룩이 필요한 첫 번째 파일을 발견하면 필터를 시작하고 핸드 셰이크를 수행합니다. 핸드 셰이크에서 Git이 보낸 환영 메시지는 &quot;git-filter-client&quot;이고 버전 2 만 지원되며 지원되는 기능은 &quot;clean&quot;, &quot;smudge&quot;및 &quot;delay&quot;입니다.</target>
        </trans-unit>
        <trans-unit id="f51f886a7edb2e397d8670010685e9d17fb9bc09" translate="yes" xml:space="preserve">
          <source>When Git needs authentication for a particular URL context, credential-store will consider that context a pattern to match against each entry in the credentials file. If the protocol, hostname, and username (if we already have one) match, then the password is returned to Git. See the discussion of configuration in &lt;a href=&quot;gitcredentials&quot;&gt;gitcredentials[7]&lt;/a&gt; for more information.</source>
          <target state="translated">Git이 특정 URL 컨텍스트에 대한 인증이 필요한 경우 credential-store는 해당 컨텍스트를 자격 증명 파일의 각 항목과 일치하는 패턴으로 간주합니다. 프로토콜, 호스트 이름 및 사용자 이름 (이미있는 경우)이 일치하면 암호가 Git으로 반환됩니다. 자세한 정보 는 &lt;a href=&quot;gitcredentials&quot;&gt;gitcredentials [7]&lt;/a&gt; 의 구성에 대한 설명 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="fbdc4494c8c569621bd35073fd02055c267f7e54" translate="yes" xml:space="preserve">
          <source>When Git needs to show you a diff for the path with &lt;code&gt;diff&lt;/code&gt; attribute set to &lt;code&gt;jcdiff&lt;/code&gt;, it calls the command you specified with the above configuration, i.e. &lt;code&gt;j-c-diff&lt;/code&gt;, with 7 parameters, just like &lt;code&gt;GIT_EXTERNAL_DIFF&lt;/code&gt; program is called. See &lt;a href=&quot;git&quot;&gt;git[1]&lt;/a&gt; for details.</source>
          <target state="translated">Git에 &lt;code&gt;diff&lt;/code&gt; 속성이 &lt;code&gt;jcdiff&lt;/code&gt; 로 설정된 경로에 대한 diff를 표시 해야하는 경우 &lt;code&gt;GIT_EXTERNAL_DIFF&lt;/code&gt; 프로그램이 호출되는 것처럼 7 개의 매개 변수를 사용하여 위 구성 (예 : &lt;code&gt;j-c-diff&lt;/code&gt; )으로 지정한 명령을 호출합니다 . 자세한 내용은 &lt;a href=&quot;git&quot;&gt;git [1]&lt;/a&gt; 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="bb3065603615c6a64dfcb623c10f42c6b9e417fa" translate="yes" xml:space="preserve">
          <source>When a &lt;code&gt;git push --signed&lt;/code&gt; sent a push certificate with a &quot;nonce&quot; that was issued by a receive-pack serving the same repository within this many seconds, export the &quot;nonce&quot; found in the certificate to &lt;code&gt;GIT_PUSH_CERT_NONCE&lt;/code&gt; to the hooks (instead of what the receive-pack asked the sending side to include). This may allow writing checks in &lt;code&gt;pre-receive&lt;/code&gt; and &lt;code&gt;post-receive&lt;/code&gt; a bit easier. Instead of checking &lt;code&gt;GIT_PUSH_CERT_NONCE_SLOP&lt;/code&gt; environment variable that records by how many seconds the nonce is stale to decide if they want to accept the certificate, they only can check &lt;code&gt;GIT_PUSH_CERT_NONCE_STATUS&lt;/code&gt; is &lt;code&gt;OK&lt;/code&gt;.</source>
          <target state="translated">때 &lt;code&gt;git push --signed&lt;/code&gt; a로 발행 된 &quot;넌스&quot;로 푸시 인증서를 보내이 많은 초 이내에 같은 저장소를 제공하는 팩을 수신에 인증서에있는 &quot;비표&quot;수출 &lt;code&gt;GIT_PUSH_CERT_NONCE&lt;/code&gt; (대신 후크를 수신 팩이 송신 측에 요청한 내용). 이 수표 쓰기 허용 할 수 있습니다 &lt;code&gt;pre-receive&lt;/code&gt; 및 &lt;code&gt;post-receive&lt;/code&gt; 좀 더 쉽게. nonce가 인증서를 수락할지 여부를 결정하기 위해 부실한 시간 (초)을 기록하는 &lt;code&gt;GIT_PUSH_CERT_NONCE_SLOP&lt;/code&gt; 환경 변수를 확인하는 대신 &lt;code&gt;GIT_PUSH_CERT_NONCE_STATUS&lt;/code&gt; 가 &lt;code&gt;OK&lt;/code&gt; 인지 확인할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="f34a76491c47ddfcf2959dd6944574eeda479afa" translate="yes" xml:space="preserve">
          <source>When a command has finished, and the client has received the entire response from the server, a client can either request that another command be executed or can terminate the connection. A client may optionally send an empty request consisting of just a flush-pkt to indicate that no more requests will be made.</source>
          <target state="translated">명령이 완료되고 클라이언트가 서버로부터 전체 응답을 받으면 클라이언트는 다른 명령의 실행을 요청하거나 연결을 종료 할 수 있습니다. 클라이언트는 선택적으로 더 이상 요청이 없다는 것을 나타 내기 위해 flush-pkt로만 구성된 빈 요청을 보낼 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="98e606d10b24cc0c03b08a4efd9e014e2a7d092f" translate="yes" xml:space="preserve">
          <source>When a commit is created in this state, the branch is updated to refer to the new commit. Specifically, &lt;code&gt;git commit&lt;/code&gt; creates a new commit &lt;code&gt;d&lt;/code&gt;, whose parent is commit &lt;code&gt;c&lt;/code&gt;, and then updates branch &lt;code&gt;master&lt;/code&gt; to refer to new commit &lt;code&gt;d&lt;/code&gt;. &lt;code&gt;HEAD&lt;/code&gt; still refers to branch &lt;code&gt;master&lt;/code&gt; and so indirectly now refers to commit &lt;code&gt;d&lt;/code&gt;:</source>
          <target state="translated">이 상태에서 커밋이 생성되면 새 커밋을 참조하도록 분기가 업데이트됩니다. 특히, &lt;code&gt;git commit&lt;/code&gt; 새로운 커밋 생성 &lt;code&gt;d&lt;/code&gt; 부모가 저지하고, &lt;code&gt;c&lt;/code&gt; 다음 지점 업데이트 &lt;code&gt;master&lt;/code&gt; 새로운 확정 참조 &lt;code&gt;d&lt;/code&gt; . &lt;code&gt;HEAD&lt;/code&gt; 는 여전히 브랜치 &lt;code&gt;master&lt;/code&gt; 를 참조하므로 간접적으로 커밋 &lt;code&gt;d&lt;/code&gt; 를 참조합니다 .</target>
        </trans-unit>
        <trans-unit id="a1d656a10ad8d92cd23d5675fa9c3ba2b92a8d6f" translate="yes" xml:space="preserve">
          <source>When a curl trace is enabled (see &lt;code&gt;GIT_TRACE_CURL&lt;/code&gt; above), do not dump data (that is, only dump info lines and headers).</source>
          <target state="translated">컬 추적이 활성화되면 ( 위의 &lt;code&gt;GIT_TRACE_CURL&lt;/code&gt; 참조) 데이터를 덤프하지 마십시오 (즉, 정보 행 및 헤더 만 덤프).</target>
        </trans-unit>
        <trans-unit id="855748d09cda03242c615ed9f83d928cff4dd252" translate="yes" xml:space="preserve">
          <source>When a fetch mirror is created with &lt;code&gt;--mirror=fetch&lt;/code&gt;, the refs will not be stored in the &lt;code&gt;refs/remotes/&lt;/code&gt; namespace, but rather everything in &lt;code&gt;refs/&lt;/code&gt; on the remote will be directly mirrored into &lt;code&gt;refs/&lt;/code&gt; in the local repository. This option only makes sense in bare repositories, because a fetch would overwrite any local commits.</source>
          <target state="translated">페치 미러가 &lt;code&gt;--mirror=fetch&lt;/code&gt; 로 생성되면 참조는 &lt;code&gt;refs/remotes/&lt;/code&gt; 네임 스페이스에 저장되지 않지만 원격의 &lt;code&gt;refs/&lt;/code&gt; 에있는 모든 것은 로컬 리포지토리의 &lt;code&gt;refs/&lt;/code&gt; 에 직접 미러링됩니다 . 페치는 로컬 커밋을 덮어 쓰기 때문에이 옵션은 베어 리포지토리에서만 의미가 있습니다.</target>
        </trans-unit>
        <trans-unit id="747511f053f093bdd8637c2efa65029ba86d5e79" translate="yes" xml:space="preserve">
          <source>When a git process is a (direct or indirect) child of another git process, it inherits Trace2 context information. This allows the child to print the command hierarchy. This example shows gc as child[3] of fetch. When the gc process reports its name as &quot;gc&quot;, it also reports the hierarchy as &quot;fetch/gc&quot;. (In this example, trace2 messages from the child process is indented for clarity.)</source>
          <target state="translated">자식 프로세스가 다른 자식 프로세스의 (직접 또는 간접) 자식 인 경우 Trace2 컨텍스트 정보를 상속합니다. 이를 통해 자식은 명령 계층을 인쇄 할 수 있습니다. 이 예는 gc를 fetch의 child [3]으로 표시합니다. gc 프로세스가 이름을 &quot;gc&quot;로보고하면 계층 구조도 &quot;fetch / gc&quot;로보고합니다. (이 예에서, 하위 프로세스의 trace2 메시지는 명확성을 위해 들여 쓰기됩니다.)</target>
        </trans-unit>
        <trans-unit id="79294381fcaa0a0dccaa2b41ac29dc7daa74e3f5" translate="yes" xml:space="preserve">
          <source>When a local branch is started off a remote-tracking branch, Git sets up the branch (specifically the &lt;code&gt;branch.&amp;lt;name&amp;gt;.remote&lt;/code&gt; and &lt;code&gt;branch.&amp;lt;name&amp;gt;.merge&lt;/code&gt; configuration entries) so that &lt;code&gt;git pull&lt;/code&gt; will appropriately merge from the remote-tracking branch. This behavior may be changed via the global &lt;code&gt;branch.autoSetupMerge&lt;/code&gt; configuration flag. That setting can be overridden by using the &lt;code&gt;--track&lt;/code&gt; and &lt;code&gt;--no-track&lt;/code&gt; options, and changed later using &lt;code&gt;git branch --set-upstream-to&lt;/code&gt;.</source>
          <target state="translated">로컬 분기가 원격 추적 분기에서 시작되면 Git은 분기 (특히 &lt;code&gt;branch.&amp;lt;name&amp;gt;.remote&lt;/code&gt; 및 &lt;code&gt;branch.&amp;lt;name&amp;gt;.merge&lt;/code&gt; 구성 항목)를 설정하여 &lt;code&gt;git pull&lt;/code&gt; 이 원격에서 적절히 병합되도록합니다. 추적 지점. 이 동작은 global &lt;code&gt;branch.autoSetupMerge&lt;/code&gt; 구성 플래그 를 통해 변경 될 수 있습니다 . 이 설정은 &lt;code&gt;--track&lt;/code&gt; 및 &lt;code&gt;--no-track&lt;/code&gt; 옵션 을 사용하여 무시 하고 나중에 &lt;code&gt;git branch --set-upstream-to&lt;/code&gt; 를 사용하여 변경할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8e12783acd89ac9262429bc89fcf85d9b95e88c1" translate="yes" xml:space="preserve">
          <source>When a merge conflict happens during switching branches with the &lt;code&gt;-m&lt;/code&gt; option, you would see something like this:</source>
          <target state="translated">&lt;code&gt;-m&lt;/code&gt; 옵션으로 분기를 전환하는 동안 병합 충돌이 발생 하면 다음과 같이 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="8b8f6236a48634fd451e67557b1ed432c992a4a6" translate="yes" xml:space="preserve">
          <source>When a merge conflict happens, the index entries for conflicting paths are left unmerged, and you need to resolve the conflicts and mark the resolved paths with &lt;code&gt;git add&lt;/code&gt; (or &lt;code&gt;git rm&lt;/code&gt; if the merge should result in deletion of the path).</source>
          <target state="translated">병합 충돌이 발생하면 충돌하는 경로에 대한 색인 항목이 병합되지 않은 상태로 유지되며 충돌을 해결하고 해결 된 경로를 &lt;code&gt;git add&lt;/code&gt; (또는 병합으로 인해 경로가 삭제되어야하는 경우 &lt;code&gt;git rm&lt;/code&gt; )로 표시해야합니다.</target>
        </trans-unit>
        <trans-unit id="054b9e9957838ff74728498487ffff5f26346d88" translate="yes" xml:space="preserve">
          <source>When a merge isn&amp;rsquo;t resolved automatically, Git leaves the index and the working tree in a special state that gives you all the information you need to help resolve the merge.</source>
          <target state="translated">병합이 자동으로 해결되지 않으면 Git은 색인과 작업 트리를 병합 상태를 유지하는 데 필요한 모든 정보를 제공하는 특수 상태로 둡니다.</target>
        </trans-unit>
        <trans-unit id="1d6b6e4ed4a39cb92155b19d26f3a8478b8d6d5c" translate="yes" xml:space="preserve">
          <source>When a new branch is created with &lt;code&gt;git branch&lt;/code&gt;, &lt;code&gt;git switch&lt;/code&gt; or &lt;code&gt;git checkout&lt;/code&gt; that tracks another branch, this variable tells Git to set up pull to rebase instead of merge (see &quot;branch.&amp;lt;name&amp;gt;.rebase&quot;). When &lt;code&gt;never&lt;/code&gt;, rebase is never automatically set to true. When &lt;code&gt;local&lt;/code&gt;, rebase is set to true for tracked branches of other local branches. When &lt;code&gt;remote&lt;/code&gt;, rebase is set to true for tracked branches of remote-tracking branches. When &lt;code&gt;always&lt;/code&gt;, rebase will be set to true for all tracking branches. See &quot;branch.autoSetupMerge&quot; for details on how to set up a branch to track another branch. This option defaults to never.</source>
          <target state="translated">다른 브랜치를 추적 하는 &lt;code&gt;git branch&lt;/code&gt; , &lt;code&gt;git switch&lt;/code&gt; 또는 &lt;code&gt;git checkout&lt;/code&gt; 으로 새 브랜치를 만들면이 변수는 Git에게 병합 대신 rebase로 pull을 설정하도록 지시합니다 ( &quot;branch. &amp;lt;name&amp;gt; .rebase&quot;참조). &lt;code&gt;never&lt;/code&gt; 일 때 rebase는 자동으로 true로 설정되지 않습니다. 때 &lt;code&gt;local&lt;/code&gt; , REBASE 다른 지역 지점의 추적 지점에 대해 true로 설정됩니다. 때 &lt;code&gt;remote&lt;/code&gt; , REBASE 원격 추적 브랜치의 추적 지점에 대해 true로 설정됩니다. 때 &lt;code&gt;always&lt;/code&gt; , REBASE 모든 추적 지점 true로 설정됩니다. 다른 지점을 추적하도록 지점을 설정하는 방법에 대한 자세한 내용은 &quot;branch.autoSetupMerge&quot;를 참조하십시오. 이 옵션의 기본값은 never입니다.</target>
        </trans-unit>
        <trans-unit id="ed0adff8e63a6741e1694d5ebc304264bd392424" translate="yes" xml:space="preserve">
          <source>When a patch failure occurs, &amp;lt;msg&amp;gt; will be printed to the screen before exiting. This overrides the standard message informing you to use &lt;code&gt;--continue&lt;/code&gt; or &lt;code&gt;--skip&lt;/code&gt; to handle the failure. This is solely for internal use between &lt;code&gt;git rebase&lt;/code&gt; and &lt;code&gt;git am&lt;/code&gt;.</source>
          <target state="translated">패치 실패가 발생하면 종료하기 전에 &amp;lt;msg&amp;gt;가 화면에 인쇄됩니다. 이는 &lt;code&gt;--continue&lt;/code&gt; 또는 &lt;code&gt;--skip&lt;/code&gt; 을 사용하여 실패를 처리 하라는 표준 메시지를 무시합니다 . 이것은 &lt;code&gt;git rebase&lt;/code&gt; 와 &lt;code&gt;git am&lt;/code&gt; 사이의 내부 용 입니다.</target>
        </trans-unit>
        <trans-unit id="d5b066fa036c4bb98c79472fbdf38de3d119f100" translate="yes" xml:space="preserve">
          <source>When a patch is part of an ongoing discussion, the patch generated by &lt;code&gt;git format-patch&lt;/code&gt; can be tweaked to take advantage of the &lt;code&gt;git am --scissors&lt;/code&gt; feature. After your response to the discussion comes a line that consists solely of &quot;&lt;code&gt;-- &amp;gt;8 --&lt;/code&gt;&quot; (scissors and perforation), followed by the patch with unnecessary header fields removed:</source>
          <target state="translated">패치가 진행중인 토론의 일부인 경우 &lt;code&gt;git format-patch&lt;/code&gt; 에 의해 생성 된 패치 를 조정하여 &lt;code&gt;git am --scissors&lt;/code&gt; 기능 을 활용할 수 있습니다 . 토론에 대한 응답이 끝나면 &quot; &lt;code&gt;-- &amp;gt;8 --&lt;/code&gt; &quot;(가위 및 천공)으로 구성되고 불필요한 헤더 필드가 제거 된 패치가 나타납니다.</target>
        </trans-unit>
        <trans-unit id="f3cb24e54c9837370739d06bd25b8c911a05ee6b" translate="yes" xml:space="preserve">
          <source>When a path is in the &quot;unmerged&quot; state, running &lt;code&gt;git update-index&lt;/code&gt; for that path tells Git to mark the path resolved.</source>
          <target state="translated">경로가 &quot;머지되지 않은&quot;상태 인 경우 해당 경로에 대해 &lt;code&gt;git update-index&lt;/code&gt; 를 실행 하면 Git에 경로가 해결되었음을 표시하도록 지시합니다.</target>
        </trans-unit>
        <trans-unit id="f8965008f9824bf8da0b033710c2d7ac1f3f6568" translate="yes" xml:space="preserve">
          <source>When a pure mode change is encountered (which has no index information), the information is read from the current index instead.</source>
          <target state="translated">순수한 모드 변경이 발생하면 (인덱스 정보가 없음) 대신 현재 인덱스에서 정보를 읽습니다.</target>
        </trans-unit>
        <trans-unit id="ef4651b07e5b8cb97cb93de85df1d7e556426d24" translate="yes" xml:space="preserve">
          <source>When a push mirror is created with &lt;code&gt;--mirror=push&lt;/code&gt;, then &lt;code&gt;git push&lt;/code&gt; will always behave as if &lt;code&gt;--mirror&lt;/code&gt; was passed.</source>
          <target state="translated">와 푸시 미러가 생성 될 때 &lt;code&gt;--mirror=push&lt;/code&gt; , 다음 &lt;code&gt;git push&lt;/code&gt; 것처럼 항상 작동합니다 &lt;code&gt;--mirror&lt;/code&gt; 이 통과되었다.</target>
        </trans-unit>
        <trans-unit id="deb13d30f8ba66c920f6495f36b99921916b0fbc" translate="yes" xml:space="preserve">
          <source>When a rebase required merge conflicts to be resolved, compare the changes introduced by the rebase directly afterwards using:</source>
          <target state="translated">리베이스에서 병합 충돌을 해결해야하는 경우 다음을 사용하여 리베이스에서 직접 도입 된 변경 사항을 비교하십시오.</target>
        </trans-unit>
        <trans-unit id="350766930233515327656bc7b70b13214a7aa33c" translate="yes" xml:space="preserve">
          <source>When a ref is updated, reflog entries are created to keep track of the reason why the ref was updated (which is typically the name of the high-level command that updated the ref), in addition to the old and new values of the ref. A scripted Porcelain command can use set_reflog_action helper function in &lt;code&gt;git-sh-setup&lt;/code&gt; to set its name to this variable when it is invoked as the top level command by the end user, to be recorded in the body of the reflog.</source>
          <target state="translated">ref가 업데이트되면 ref의 이전 값과 새로운 값 외에 ref가 업데이트 된 이유 (일반적으로 ref를 업데이트 한 상위 명령 이름)를 추적하기 위해 reflog 항목이 작성됩니다. . 스크립트 된 Porcelain 명령은 &lt;code&gt;git-sh-setup&lt;/code&gt; 의 set_reflog_action 헬퍼 함수를 ​​사용 하여 최종 사용자가 최상위 레벨 명령으로 호출 할 때이 변수로 이름을 설정 하여 참조 로그 본문에 기록 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0a564cf0d83332d2cd6fd3ac884cec9942b078c7" translate="yes" xml:space="preserve">
          <source>When a repository is synchronized via &lt;code&gt;git push&lt;/code&gt; and &lt;code&gt;git pull&lt;/code&gt; objects packed in the source repository are usually stored unpacked in the destination. While this allows you to use different packing strategies on both ends, it also means you may need to repack both repositories every once in a while.</source>
          <target state="translated">소스 리포지토리에 압축 된 &lt;code&gt;git push&lt;/code&gt; 및 &lt;code&gt;git pull&lt;/code&gt; 객체 를 통해 리포지토리가 동기화되면 일반적으로 대상에 압축을 푼 상태로 저장됩니다. 이렇게하면 양쪽에 서로 다른 패킹 전략을 사용할 수 있지만 두 리포지토리를 한 번에 한 번씩 다시 포장해야 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="89c3a76b400f69bc409951d41f44580e1ce5b550" translate="yes" xml:space="preserve">
          <source>When a scripting language specific quoting is in effect, everything between a top-level opening atom and its matching %(end) is evaluated according to the semantics of the opening atom and only its result from the top-level is quoted.</source>
          <target state="translated">스크립팅 언어 별 인용이 유효 할 때 최상위 수준 원자와 일치하는 % (end) 사이의 모든 항목은 기초 원자의 의미에 따라 평가되며 최상위 수준의 결과 만 인용됩니다.</target>
        </trans-unit>
        <trans-unit id="1d0d6b410e7d083b396401fa9485dd3214d89132" translate="yes" xml:space="preserve">
          <source>When a variable is said to take a boolean value, many synonyms are accepted for &lt;code&gt;true&lt;/code&gt; and &lt;code&gt;false&lt;/code&gt;; these are all case-insensitive.</source>
          <target state="translated">변수가 부울 값을 사용한다고 말하면 많은 동의어가 &lt;code&gt;true&lt;/code&gt; 및 &lt;code&gt;false&lt;/code&gt; 에 대해 허용됩니다 . 이것들은 모두 대소 문자를 구분하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="085e4eddfd9be8c4f3b576466769939a6475604e" translate="yes" xml:space="preserve">
          <source>When accepting a new code drop for a vendor branch, you probably want to record both the removal of paths and additions of new paths as well as modifications of existing paths.</source>
          <target state="translated">공급 업체 지점에 대해 새 코드 삭제를 승인 할 때 경로 제거 및 새 경로 추가 및 기존 경로 수정을 모두 기록하려고 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="98d4ec1ab85d43886cf359223c5c65ec41aa50b0" translate="yes" xml:space="preserve">
          <source>When accepting a signed push (see &lt;a href=&quot;git-push&quot;&gt;git-push[1]&lt;/a&gt;), the signed push certificate is stored in a blob and an environment variable &lt;code&gt;GIT_PUSH_CERT&lt;/code&gt; can be consulted for its object name. See the description of &lt;code&gt;post-receive&lt;/code&gt; hook for an example. In addition, the certificate is verified using GPG and the result is exported with the following environment variables:</source>
          <target state="translated">서명 된 푸시 ( &lt;a href=&quot;git-push&quot;&gt;git-push [1]&lt;/a&gt; 참조)를 수락 하면 서명 된 푸시 인증서가 BLOB에 저장되고 해당 객체 이름에 대해 환경 변수 &lt;code&gt;GIT_PUSH_CERT&lt;/code&gt; 를 참조 할 수 있습니다. 예는 &lt;code&gt;post-receive&lt;/code&gt; 후크에 대한 설명을 참조하십시오 . 또한 인증서는 GPG를 사용하여 확인되며 결과는 다음 환경 변수와 함께 내보내집니다.</target>
        </trans-unit>
        <trans-unit id="5d78f94855bee5654824b328b5c74fbbbf68d2ce" translate="yes" xml:space="preserve">
          <source>When acquiring credentials, consider the &quot;path&quot; component of an http or https URL to be important. Defaults to false. See &lt;a href=&quot;gitcredentials&quot;&gt;gitcredentials[7]&lt;/a&gt; for more information.</source>
          <target state="translated">신임 정보를 획득 할 때 http 또는 https URL의 &quot;경로&quot;구성 요소가 중요하다고 생각하십시오. 기본값은 false입니다. 자세한 내용은 &lt;a href=&quot;gitcredentials&quot;&gt;gitcredentials [7]&lt;/a&gt; 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="36125e3b1dadcf8415f427875bfbe6e3edb592ec" translate="yes" xml:space="preserve">
          <source>When adding notes to an object that already has notes, overwrite the existing notes (instead of aborting).</source>
          <target state="translated">이미 메모가있는 개체에 메모를 추가 할 때 중단 대신 기존 메모를 덮어 씁니다.</target>
        </trans-unit>
        <trans-unit id="31a6893d1f507cb4bce24b6631d6f67bbe0ca8c3" translate="yes" xml:space="preserve">
          <source>When advertising tips of available history from an alternate, use the shell to execute the specified command instead of &lt;a href=&quot;git-for-each-ref&quot;&gt;git-for-each-ref[1]&lt;/a&gt;. The first argument is the absolute path of the alternate. Output must contain one hex object id per line (i.e., the same as produced by &lt;code&gt;git for-each-ref
--format='%(objectname)'&lt;/code&gt;).</source>
          <target state="translated">대체에서 사용 가능한 히스토리 팁을 광고 할 때 &lt;a href=&quot;git-for-each-ref&quot;&gt;git-for-each-ref [1]&lt;/a&gt; 대신 쉘을 사용하여 지정된 명령을 실행하십시오 . 첫 번째 인수는 대체의 절대 경로입니다. 출력은 라인 당 하나의 16 진 오브젝트 ID를 포함해야합니다 (즉, &lt;code&gt;git for-each-ref --format='%(objectname)'&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="aee562f05eaa47b0988f9365fa4403a675334ce1" translate="yes" xml:space="preserve">
          <source>When an argument can be misunderstood as either a revision or a path, they can be disambiguated by placing &lt;code&gt;--&lt;/code&gt; between them. E.g. &lt;code&gt;git diff -- HEAD&lt;/code&gt; is, &quot;I have a file called HEAD in my work tree. Please show changes between the version I staged in the index and what I have in the work tree for that file&quot;, not &quot;show difference between the HEAD commit and the work tree as a whole&quot;. You can say &lt;code&gt;git diff HEAD --&lt;/code&gt; to ask for the latter.</source>
          <target state="translated">인수가 개정이나 경로 중 하나로 오해 할 수있을 때, 그들은 배치하여 명확화 할 수있다 &lt;code&gt;--&lt;/code&gt; 그들 사이. 예를 들어 &lt;code&gt;git diff -- HEAD&lt;/code&gt; 는 &quot;작업 트리에 HEAD라는 파일이 있습니다. 색인에서 준비한 버전과 해당 파일의 작업 트리에있는 버전 간의 변경 사항을 표시하십시오&quot;라는 차이점이 아니라 HEAD 커밋 및 작업 트리 전체 &quot; &lt;code&gt;git diff HEAD --&lt;/code&gt; 라고 말하면 후자를 요청할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="8ed1e316e9f06aa8f0fbb451acc5e5dd1d53d618" translate="yes" xml:space="preserve">
          <source>When an argument may be understood either as a reference or as a file name, choose to understand it as a format-patch argument (&lt;code&gt;--format-patch&lt;/code&gt;) or as a file name (&lt;code&gt;--no-format-patch&lt;/code&gt;). By default, when such a conflict occurs, git send-email will fail.</source>
          <target state="translated">인수가 참조 또는 파일 이름으로 이해 될 수있는 경우, 인수를 format-patch 인수 ( &lt;code&gt;--format-patch&lt;/code&gt; ) 또는 파일 이름 ( &lt;code&gt;--no-format-patch&lt;/code&gt; ) 으로 이해하도록 선택하십시오 . 기본적으로 이러한 충돌이 발생하면 git send-email이 실패합니다.</target>
        </trans-unit>
        <trans-unit id="daa45faaafc93f57dcfa6219226fd8a2224c7353" translate="yes" xml:space="preserve">
          <source>When an interactive command (such as &lt;code&gt;git add --patch&lt;/code&gt;) shows a colorized diff, git will pipe the diff through the shell command defined by this configuration variable. The command may mark up the diff further for human consumption, provided that it retains a one-to-one correspondence with the lines in the original diff. Defaults to disabled (no filtering).</source>
          <target state="translated">대화식 명령 (예 : &lt;code&gt;git add --patch&lt;/code&gt; )에 색상 화 된 diff가 표시되면 git은이 구성 변수로 정의 된 쉘 명령을 통해 diff를 파이프합니다. 이 명령은 원래 diff의 라인과 일대일로 대응되는 경우 diff를 사람이 소비 할 수 있도록 추가로 마크 업할 수 있습니다. 기본값은 비활성화 (필터링 없음)입니다.</target>
        </trans-unit>
        <trans-unit id="66bd09d84d7f728fe64b22afe9c1d5b02faccf2f" translate="yes" xml:space="preserve">
          <source>When an optional Git branch name (or a Git commit object name) is specified as an argument, the subcommand works on the specified branch, not on the current branch.</source>
          <target state="translated">선택적 Git 브랜치 이름 (또는 Git 커밋 오브젝트 이름)이 인수로 지정되면 부속 명령은 현재 브랜치가 아닌 지정된 브랜치에서 작동합니다.</target>
        </trans-unit>
        <trans-unit id="54600ca959ccb5286a6125f852754e8a441f6246" translate="yes" xml:space="preserve">
          <source>When an update changes a branch (or more in general, a ref) that used to point at commit A to point at another commit B, it is called a fast-forward update if and only if B is a descendant of A.</source>
          <target state="translated">업데이트가 커밋 A를 가리키고 다른 커밋 B를 가리킬 때 사용 된 분기 (또는 일반적으로 ref)를 변경하면 B가 A의 자손 인 경우에만 업데이트를 빨리 감기라고합니다.</target>
        </trans-unit>
        <trans-unit id="b999dfcfa57d71ee62dbc42f4d8a0527e63491d1" translate="yes" xml:space="preserve">
          <source>When applying a patch, detect a new or modified line that has whitespace errors. What are considered whitespace errors is controlled by &lt;code&gt;core.whitespace&lt;/code&gt; configuration. By default, trailing whitespaces (including lines that solely consist of whitespaces) and a space character that is immediately followed by a tab character inside the initial indent of the line are considered whitespace errors.</source>
          <target state="translated">패치를 적용 할 때 공백 오류가있는 새 줄이나 수정 된 줄을 찾으십시오. 공백 오류로 간주되는 것은 &lt;code&gt;core.whitespace&lt;/code&gt; 구성에 의해 제어됩니다 . 기본적으로 후행 공백 (공백만으로 구성되는 줄 포함)과 줄의 처음 들여 쓰기 안에 탭 문자가 뒤에 오는 공백 문자는 공백 오류로 간주됩니다.</target>
        </trans-unit>
        <trans-unit id="b3581e25b4edfc3eae85f688560f931e31414d31" translate="yes" xml:space="preserve">
          <source>When applying a patch, ignore additions made by the patch. This can be used to extract the common part between two files by first running &lt;code&gt;diff&lt;/code&gt; on them and applying the result with this option, which would apply the deletion part but not the addition part.</source>
          <target state="translated">패치를 적용 할 때 패치가 추가 한 내용은 무시하십시오. 이 파일을 사용하여 먼저 &lt;code&gt;diff&lt;/code&gt; 를 실행 하고이 옵션으로 결과를 적용하여 두 파일 사이의 공통 부분을 추출하는 데 사용할 수 있습니다. 이 옵션은 삭제 부분을 적용하지만 추가 부분은 적용하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="6bf2c606b0bf760a50dfcc2e9e2a1dfc6d6ce1b9" translate="yes" xml:space="preserve">
          <source>When applying a patch, ignore changes in whitespace in context lines if necessary. Context lines will preserve their whitespace, and they will not undergo whitespace fixing regardless of the value of the &lt;code&gt;--whitespace&lt;/code&gt; option. New lines will still be fixed, though.</source>
          <target state="translated">패치를 적용 할 때 필요한 경우 컨텍스트 행에서 공백의 변경을 무시하십시오. 상황에 맞는 줄은 공백을 유지하며 &lt;code&gt;--whitespace&lt;/code&gt; 옵션 의 값에 관계없이 공백을 수정하지 않습니다 . 그러나 새로운 줄은 여전히 ​​수정 될 것입니다.</target>
        </trans-unit>
        <trans-unit id="588f408b6e1e0374e87fb8fe5ff6e5cd0dca42b8" translate="yes" xml:space="preserve">
          <source>When applying the patch only to the working tree, mark new files to be added to the index later (see &lt;code&gt;--intent-to-add&lt;/code&gt; option in &lt;a href=&quot;git-add&quot;&gt;git-add[1]&lt;/a&gt;). This option is ignored unless running in a Git repository and &lt;code&gt;--index&lt;/code&gt; is not specified. Note that &lt;code&gt;--index&lt;/code&gt; could be implied by other options such as &lt;code&gt;--cached&lt;/code&gt; or &lt;code&gt;--3way&lt;/code&gt;.</source>
          <target state="translated">작업 트리에만 패치를 적용하는 경우 나중에 색인에 추가 할 새 파일을 표시하십시오 ( &lt;a href=&quot;git-add&quot;&gt;git-add [1]의 &lt;/a&gt; &lt;code&gt;--intent-to-add&lt;/code&gt; 옵션 참조 ). Git 리포지토리에서 실행 중이고 &lt;code&gt;--index&lt;/code&gt; 를 지정 하지 않으면이 옵션은 무시 됩니다. 참고 &lt;code&gt;--index&lt;/code&gt; 이 같은 다른 옵션을 암시 할 수 &lt;code&gt;--cached&lt;/code&gt; 또는 &lt;code&gt;--3way&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="59fa333bf5332a3a74a0fa1b62097787ae41682d" translate="yes" xml:space="preserve">
          <source>When asking to &lt;code&gt;abort&lt;/code&gt; (which is the default), this program will die when encountering a signed tag. With &lt;code&gt;strip&lt;/code&gt;, the tags will silently be made unsigned, with &lt;code&gt;warn-strip&lt;/code&gt; they will be made unsigned but a warning will be displayed, with &lt;code&gt;verbatim&lt;/code&gt;, they will be silently exported and with &lt;code&gt;warn&lt;/code&gt;, they will be exported, but you will see a warning.</source>
          <target state="translated">&lt;code&gt;abort&lt;/code&gt; 요청하면 (기본값) 서명 된 태그가 발생하면이 프로그램이 종료됩니다. 함께 &lt;code&gt;strip&lt;/code&gt; 과 태그가 자동으로 서명되지 않은 될 것이다 &lt;code&gt;warn-strip&lt;/code&gt; 과, 그들이 서명하게되지만 경고가 표시됩니다 &lt;code&gt;verbatim&lt;/code&gt; , 그들은 자동으로 내 보냅니다과 함께 &lt;code&gt;warn&lt;/code&gt; , 그들은 내보낼 것이다, 그러나 경고가 표시됩니다 .</target>
        </trans-unit>
        <trans-unit id="a094fa226ab8da9ad05df22ffe9e8c64cbd9aea9" translate="yes" xml:space="preserve">
          <source>When asking to &lt;code&gt;abort&lt;/code&gt; (which is the default), this program will die when encountering such a tag. With &lt;code&gt;drop&lt;/code&gt; it will omit such tags from the output. With &lt;code&gt;rewrite&lt;/code&gt;, if the tagged object is a commit, it will rewrite the tag to tag an ancestor commit (via parent rewriting; see &lt;a href=&quot;git-rev-list&quot;&gt;git-rev-list[1]&lt;/a&gt;)</source>
          <target state="translated">&lt;code&gt;abort&lt;/code&gt; 요청할 때 (기본값)이 태그가 있으면이 프로그램이 종료됩니다. &lt;code&gt;drop&lt;/code&gt; 을 사용 하면 출력에서 ​​해당 태그를 생략합니다. 로 &lt;code&gt;rewrite&lt;/code&gt; 태깅 된 물체가있는 경우, A는 커밋이 조상 커밋 태그 태그 재기록한다 (재기록 부모를 통해, 참조 &lt;a href=&quot;git-rev-list&quot;&gt;자식-REV-목록 [1]&lt;/a&gt; )</target>
        </trans-unit>
        <trans-unit id="034f3e54dc418fd0aaba391926e4cdc6f9338cc5" translate="yes" xml:space="preserve">
          <source>When called with &lt;code&gt;--incremental&lt;/code&gt; option, the command outputs the result as it is built. The output generally will talk about lines touched by more recent commits first (i.e. the lines will be annotated out of order) and is meant to be used by interactive viewers.</source>
          <target state="translated">&lt;code&gt;--incremental&lt;/code&gt; 옵션 과 함께 호출 하면 명령이 빌드 될 때 결과를 출력합니다. 출력은 일반적으로 가장 최근의 커밋에 의해 먼저 터치 된 라인에 대해 이야기합니다 (즉, 라인에 순서가 지정되지 않음). 인터랙티브 뷰어가 사용하도록되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="37ed40c0b9c191bc52be1eea56e95c21c8c30c92" translate="yes" xml:space="preserve">
          <source>When checking out paths from the index, check out stage #2 (&lt;code&gt;ours&lt;/code&gt;) or #3 (&lt;code&gt;theirs&lt;/code&gt;) for unmerged paths.</source>
          <target state="translated">인덱스에서 경로를 조사한 결과에 의하면,이 스테이지 # 2 (체크 아웃 &lt;code&gt;ours&lt;/code&gt; ) 또는 # 3 ( &lt;code&gt;theirs&lt;/code&gt; 병합 경로에 대한 참조).</target>
        </trans-unit>
        <trans-unit id="b2d7eb083886da1526ca38a6780f9e98825df5e6" translate="yes" xml:space="preserve">
          <source>When checking out paths from the index, do not fail upon unmerged entries; instead, unmerged entries are ignored.</source>
          <target state="translated">색인에서 경로를 체크 아웃 할 때 병합되지 않은 항목에 실패하지 마십시오. 대신 병합되지 않은 항목은 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="87b021689017efd0b4fbe642f48fde6408f7cde4" translate="yes" xml:space="preserve">
          <source>When checking out paths from the index, this option lets you recreate the conflicted merge in the specified paths.</source>
          <target state="translated">인덱스에서 경로를 체크 아웃 할 때이 옵션을 사용하면 지정된 경로에서 충돌 병합을 다시 만들 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="44968c91f62b2f1c7eb77848556b128eac9d4512" translate="yes" xml:space="preserve">
          <source>When cloning an SVN repository, if none of the options for describing the repository layout is used (--trunk, --tags, --branches, --stdlayout), &lt;code&gt;git svn clone&lt;/code&gt; will create a Git repository with completely linear history, where branches and tags appear as separate directories in the working copy. While this is the easiest way to get a copy of a complete repository, for projects with many branches it will lead to a working copy many times larger than just the trunk. Thus for projects using the standard directory structure (trunk/branches/tags), it is recommended to clone with option &lt;code&gt;--stdlayout&lt;/code&gt;. If the project uses a non-standard structure, and/or if branches and tags are not required, it is easiest to only clone one directory (typically trunk), without giving any repository layout options. If the full history with branches and tags is required, the options &lt;code&gt;--trunk&lt;/code&gt; / &lt;code&gt;--branches&lt;/code&gt; / &lt;code&gt;--tags&lt;/code&gt; must be used.</source>
          <target state="translated">SVN 저장소를 복제 할 때 저장소 레이아웃을 설명하는 옵션이 사용되지 않으면 (--trunk, --tags, --branches, --stdlayout) &lt;code&gt;git svn clone&lt;/code&gt; 은 완전히 선형 히스토리가있는 Git 저장소를 작성합니다. 분기 및 태그는 작업 복사본에서 별도의 디렉토리로 나타납니다. 이것이 완전한 저장소의 사본을 얻는 가장 쉬운 방법이지만 분기가 많은 프로젝트의 경우 트렁크보다 몇 배 더 큰 작업 사본으로 이어질 것입니다. 따라서 표준 디렉토리 구조 (트렁크 / 분기 / 태그)를 사용하는 프로젝트의 경우 &lt;code&gt;--stdlayout&lt;/code&gt; 옵션을 사용하여 복제하는 것이 좋습니다.. 프로젝트가 비표준 구조를 사용하거나 분기 및 태그가 필요하지 않은 경우 저장소 레이아웃 옵션을 제공하지 않고 하나의 디렉토리 (일반적으로 트렁크) 만 복제하는 것이 가장 쉽습니다. 브랜치와 태그와 전체 역사는이 필요한 경우, 옵션은 &lt;code&gt;--trunk&lt;/code&gt; / &lt;code&gt;--branches&lt;/code&gt; / &lt;code&gt;--tags&lt;/code&gt; 가 사용되어야합니다.</target>
        </trans-unit>
        <trans-unit id="cf5bdc8ee9de0e891bd2e2ffd6ad5374a27fb398" translate="yes" xml:space="preserve">
          <source>When cloning or pulling a repository containing submodules the submodules will not be checked out by default; You can instruct &lt;code&gt;clone&lt;/code&gt; to recurse into submodules. The &lt;code&gt;init&lt;/code&gt; and &lt;code&gt;update&lt;/code&gt; subcommands of &lt;code&gt;git submodule&lt;/code&gt; will maintain submodules checked out and at an appropriate revision in your working tree. Alternatively you can set &lt;code&gt;submodule.recurse&lt;/code&gt; to have &lt;code&gt;checkout&lt;/code&gt; recursing into submodules.</source>
          <target state="translated">서브 모듈을 포함하는 저장소를 복제하거나 가져올 때 서브 모듈은 기본적으로 체크 아웃되지 않습니다. &lt;code&gt;clone&lt;/code&gt; 가 하위 모듈로 재귀 하도록 지시 할 수 있습니다 . &lt;code&gt;git submodule&lt;/code&gt; 의 &lt;code&gt;init&lt;/code&gt; 및 &lt;code&gt;update&lt;/code&gt; 하위 명령은 하위 트리를 체크 아웃 한 상태로 작업 트리에서 적절히 수정합니다. 또는 &lt;code&gt;submodule.recurse&lt;/code&gt; 를 설정 하여 &lt;code&gt;checkout&lt;/code&gt; 서브 모듈 로 되풀이되도록 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="f6f5e261fa8e1325a05e77f0fa02cd4e804a016b" translate="yes" xml:space="preserve">
          <source>When committing fixups, consider using &lt;code&gt;merge&lt;/code&gt; to connect the commit(s) which are supplying file revisions to the fixup branch. Doing so will allow tools such as &lt;code&gt;git blame&lt;/code&gt; to track through the real commit history and properly annotate the source files.</source>
          <target state="translated">수정 사항을 커미트 할 때 &lt;code&gt;merge&lt;/code&gt; 을 사용하여 파일 개정판을 제공하는 커미트를 수정 사항 브랜치에 연결하십시오. 그렇게하면 &lt;code&gt;git blame&lt;/code&gt; 과 같은 도구 가 실제 커밋 기록을 추적하고 소스 파일에 주석을 달 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="187746ad8497cb1dac2dfe493269450955422d85" translate="yes" xml:space="preserve">
          <source>When committing to svn from Git (as part of &lt;code&gt;set-tree&lt;/code&gt; or &lt;code&gt;dcommit&lt;/code&gt; operations), if the existing log message doesn&amp;rsquo;t already have a &lt;code&gt;From:&lt;/code&gt; or &lt;code&gt;Signed-off-by:&lt;/code&gt; line, append a &lt;code&gt;From:&lt;/code&gt; line based on the Git commit&amp;rsquo;s author string. If you use this, then &lt;code&gt;--use-log-author&lt;/code&gt; will retrieve a valid author string for all commits.</source>
          <target state="translated">&lt;code&gt;set-tree&lt;/code&gt; 또는 &lt;code&gt;dcommit&lt;/code&gt; 작업의 일부로 Git에서 svn을 커밋 할 때 기존 로그 메시지에 &lt;code&gt;From:&lt;/code&gt; 또는 &lt;code&gt;Signed-off-by:&lt;/code&gt; 행 이없는 경우 Git 커밋을 기반으로 &lt;code&gt;From:&lt;/code&gt; 행을 추가하십시오 . 저자 문자열. 이것을 사용하면 &lt;code&gt;--use-log-author&lt;/code&gt; 는 모든 커밋에 대해 유효한 작성자 문자열을 검색합니다.</target>
        </trans-unit>
        <trans-unit id="df4d9e8de337675930b7c7d126c3cbfdb0d919e8" translate="yes" xml:space="preserve">
          <source>When common porcelain operations that create objects are run, they will check whether the repository has grown substantially since the last maintenance, and if so run &lt;code&gt;git gc&lt;/code&gt; automatically. See &lt;code&gt;gc.auto&lt;/code&gt; below for how to disable this behavior.</source>
          <target state="translated">객체를 생성하는 일반적인 도자기 작업이 실행될 때 리포지토리가 마지막 유지 관리 이후 실질적으로 커 졌는지 확인하고 &lt;code&gt;git gc&lt;/code&gt; 를 자동으로 실행 합니다. 이 동작을 비활성화하는 방법은 아래 &lt;code&gt;gc.auto&lt;/code&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="5cef5cc19d56f034a0850f6ce0dc6add0c966a70" translate="yes" xml:space="preserve">
          <source>When comparing two trees, the ID of both trees (separated by a space and terminated by a newline) is printed before the difference. When comparing commits, the ID of the first (or only) commit, followed by a newline, is printed.</source>
          <target state="translated">두 트리를 비교할 때 두 트리의 ID (공백으로 구분되고 줄 바꾸기로 종료 됨)가 차이 전에 인쇄됩니다. 커밋을 비교할 때 첫 번째 (또는 유일한) 커밋의 ID와 그 뒤에 줄 바꿈이 인쇄됩니다.</target>
        </trans-unit>
        <trans-unit id="fe249445673b1134855083e0c3b366c4aeeb2c8e" translate="yes" xml:space="preserve">
          <source>When converting a value to its canonical form using the &lt;code&gt;--type=bool&lt;/code&gt; type specifier, &lt;code&gt;git config&lt;/code&gt; will ensure that the output is &quot;true&quot; or &quot;false&quot; (spelled in lowercase).</source>
          <target state="translated">&lt;code&gt;--type=bool&lt;/code&gt; 유형 지정자를 사용하여 값을 표준 형식으로 변환 할 때 &lt;code&gt;git config&lt;/code&gt; 는 출력이 &quot;true&quot;또는 &quot;false&quot;(소문자로 표시)인지 확인합니다.</target>
        </trans-unit>
        <trans-unit id="5800d8777d6f116b967a3c4b503079e04a8dd27b" translate="yes" xml:space="preserve">
          <source>When copying a remote repository, you&amp;rsquo;ll want to at a minimum update the index cache when you do this, and especially with other peoples' repositories you often want to make sure that the index cache is in some known state (you don&amp;rsquo;t know &lt;strong&gt;what&lt;/strong&gt; they&amp;rsquo;ve done and not yet checked in), so usually you&amp;rsquo;ll precede the &lt;code&gt;git update-index&lt;/code&gt; with a</source>
          <target state="translated">원격 리포지토리를 복사 할 때는 인덱스 캐시를 최소한 업데이트해야하며, 특히 다른 사람의 리포지토리를 사용하는 경우 인덱스 캐시가 알려진 상태에 있는지 확인하려고합니다. 그들이 &lt;strong&gt;무엇&lt;/strong&gt; 을했고 아직 체크인하지 않았 &lt;strong&gt;는지&lt;/strong&gt; 알기 때문에 일반적으로 &lt;code&gt;git update-index&lt;/code&gt; 앞에 a</target>
        </trans-unit>
        <trans-unit id="a0c9c076efebd050282e8220820bf37e469a5914" translate="yes" xml:space="preserve">
          <source>When copying notes during a rewrite (see the &quot;notes.rewrite.&amp;lt;command&amp;gt;&quot; option), determines what to do if the target commit already has a note. Must be one of &lt;code&gt;overwrite&lt;/code&gt;, &lt;code&gt;concatenate&lt;/code&gt;, &lt;code&gt;cat_sort_uniq&lt;/code&gt;, or &lt;code&gt;ignore&lt;/code&gt;. Defaults to &lt;code&gt;concatenate&lt;/code&gt;.</source>
          <target state="translated">다시 쓰는 동안 메모를 복사 할 때 ( &quot;notes.rewrite. &amp;lt;command&amp;gt;&quot;옵션 참조) 대상 커밋에 이미 메모가있는 경우 수행 할 작업을 결정합니다. &lt;code&gt;overwrite&lt;/code&gt; , &lt;code&gt;concatenate&lt;/code&gt; , &lt;code&gt;cat_sort_uniq&lt;/code&gt; 또는 &lt;code&gt;ignore&lt;/code&gt; 중 하나 여야합니다 . &lt;code&gt;concatenate&lt;/code&gt; 기본값 입니다.</target>
        </trans-unit>
        <trans-unit id="f2daf889c63a8ae3ef0bd84b9e0a7bae3186ea5d" translate="yes" xml:space="preserve">
          <source>When copying notes during a rewrite, specifies the (fully qualified) ref whose notes should be copied. May be a glob, in which case notes in all matching refs will be copied. You may also specify this configuration several times.</source>
          <target state="translated">다시 쓰는 동안 메모를 복사 할 때 메모를 복사해야하는 정규화 된 참조를 지정합니다. glob 일 수 있으며,이 경우 일치하는 모든 참조의 메모가 복사됩니다. 이 구성을 여러 번 지정할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="c445d369a5c50740a59f3ad28697ace644e2811e" translate="yes" xml:space="preserve">
          <source>When copying notes during a rewrite, specifies the (fully qualified) ref whose notes should be copied. The ref may be a glob, in which case notes in all matching refs will be copied. You may also specify this configuration several times.</source>
          <target state="translated">다시 쓰는 동안 메모를 복사 할 때 메모를 복사해야하는 정규화 된 참조를 지정합니다. 심판은 글로브 일 수 있으며,이 경우 일치하는 모든 심판의 노트가 복사됩니다. 이 구성을 여러 번 지정할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="1243aaab79ff33e7a2d49c8eb8b4f16703a1c016" translate="yes" xml:space="preserve">
          <source>When copying notes during a rewrite, what to do if the target commit already has a note. Must be one of &lt;code&gt;overwrite&lt;/code&gt;, &lt;code&gt;concatenate&lt;/code&gt;, &lt;code&gt;cat_sort_uniq&lt;/code&gt;, or &lt;code&gt;ignore&lt;/code&gt;. Defaults to &lt;code&gt;concatenate&lt;/code&gt;.</source>
          <target state="translated">다시 쓰는 동안 메모를 복사 할 때 대상 커밋에 이미 메모가있는 경우 수행 할 작업입니다. &lt;code&gt;overwrite&lt;/code&gt; , &lt;code&gt;concatenate&lt;/code&gt; , &lt;code&gt;cat_sort_uniq&lt;/code&gt; 또는 &lt;code&gt;ignore&lt;/code&gt; 중 하나 여야합니다 . &lt;code&gt;concatenate&lt;/code&gt; 기본값 입니다.</target>
        </trans-unit>
        <trans-unit id="fb6ea94e62e06bb5ee870300111df0d9f630f320" translate="yes" xml:space="preserve">
          <source>When copying notes during a rewrite, what to do if the target commit already has a note. Must be one of &lt;code&gt;overwrite&lt;/code&gt;, &lt;code&gt;concatenate&lt;/code&gt;, &lt;code&gt;cat_sort_uniq&lt;/code&gt;, or &lt;code&gt;ignore&lt;/code&gt;. This overrides the &lt;code&gt;core.rewriteMode&lt;/code&gt; setting.</source>
          <target state="translated">다시 쓰는 동안 메모를 복사 할 때 대상 커밋에 이미 메모가있는 경우 수행 할 작업입니다. &lt;code&gt;overwrite&lt;/code&gt; , &lt;code&gt;concatenate&lt;/code&gt; , &lt;code&gt;cat_sort_uniq&lt;/code&gt; 또는 &lt;code&gt;ignore&lt;/code&gt; 중 하나 여야합니다 . 이것은 &lt;code&gt;core.rewriteMode&lt;/code&gt; 설정을 무시합니다 .</target>
        </trans-unit>
        <trans-unit id="fa7e030aba2e9a9a4e5882753f19d2b4a66b4e16" translate="yes" xml:space="preserve">
          <source>When creating a new branch, if &lt;code&gt;&amp;lt;commit-ish&amp;gt;&lt;/code&gt; is a branch, mark it as &quot;upstream&quot; from the new branch. This is the default if &lt;code&gt;&amp;lt;commit-ish&amp;gt;&lt;/code&gt; is a remote-tracking branch. See &quot;--track&quot; in &lt;a href=&quot;git-branch&quot;&gt;git-branch[1]&lt;/a&gt; for details.</source>
          <target state="translated">새 분기를 만들 때 &lt;code&gt;&amp;lt;commit-ish&amp;gt;&lt;/code&gt; 가 분기 인 경우 새 분기에서 &quot;업스트림&quot;으로 표시하십시오. &lt;code&gt;&amp;lt;commit-ish&amp;gt;&lt;/code&gt; 가 원격 추적 분기 인 경우 이것이 기본값 입니다. 자세한 내용은 &lt;a href=&quot;git-branch&quot;&gt;git-branch [1]의&lt;/a&gt; &quot;--track&quot; 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="54d8049451fa958ada38921d90347d3ee7c4d771" translate="yes" xml:space="preserve">
          <source>When creating a new branch, set up &quot;upstream&quot; configuration. &lt;code&gt;-c&lt;/code&gt; is implied. See &lt;code&gt;--track&lt;/code&gt; in &lt;a href=&quot;git-branch&quot;&gt;git-branch[1]&lt;/a&gt; for details.</source>
          <target state="translated">새 브랜치를 생성 할 때 &quot;업스트림&quot;구성을 설정하십시오. &lt;code&gt;-c&lt;/code&gt; 가 암시됩니다. 자세한 내용 은 &lt;a href=&quot;git-branch&quot;&gt;git-branch [1]의 &lt;/a&gt; &lt;code&gt;--track&lt;/code&gt; 을 참조 하십시오.</target>
        </trans-unit>
        <trans-unit id="fc590aa31fec73c4296b9f428640a84b6d3e91a7" translate="yes" xml:space="preserve">
          <source>When creating a new branch, set up &quot;upstream&quot; configuration. See &quot;--track&quot; in &lt;a href=&quot;git-branch&quot;&gt;git-branch[1]&lt;/a&gt; for details.</source>
          <target state="translated">새 브랜치를 생성 할 때 &quot;업스트림&quot;구성을 설정하십시오. 자세한 내용은 &lt;a href=&quot;git-branch&quot;&gt;git-branch [1]의&lt;/a&gt; &quot;--track&quot; 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="67211ea9327a11f7c102d4d6622e44707e57316e" translate="yes" xml:space="preserve">
          <source>When creating a new branch, set up &lt;code&gt;branch.&amp;lt;name&amp;gt;.remote&lt;/code&gt; and &lt;code&gt;branch.&amp;lt;name&amp;gt;.merge&lt;/code&gt; configuration entries to mark the start-point branch as &quot;upstream&quot; from the new branch. This configuration will tell git to show the relationship between the two branches in &lt;code&gt;git status&lt;/code&gt; and &lt;code&gt;git branch -v&lt;/code&gt;. Furthermore, it directs &lt;code&gt;git pull&lt;/code&gt; without arguments to pull from the upstream when the new branch is checked out.</source>
          <target state="translated">새 분기를 만들 때는 &lt;code&gt;branch.&amp;lt;name&amp;gt;.remote&lt;/code&gt; 및 &lt;code&gt;branch.&amp;lt;name&amp;gt;.merge&lt;/code&gt; 구성 항목을 설정하여 시작 분기 분기를 새 분기에서 &quot;업스트림&quot;으로 표시하십시오. 이 설정은 git에게 &lt;code&gt;git status&lt;/code&gt; 와 &lt;code&gt;git branch -v&lt;/code&gt; 의 두 브랜치 사이의 관계를 보여줄 것을 지시합니다 . 또한 새로운 분기가 체크 아웃 될 때 인수없이 &lt;code&gt;git pull&lt;/code&gt; 이 업스트림에서 당겨 지도록 지시 합니다.</target>
        </trans-unit>
        <trans-unit id="30421c6d8900807173aa121649f943a72b9b4dbe" translate="yes" xml:space="preserve">
          <source>When creating a packed archive in a repository that has existing packs, the command reuses existing deltas. This sometimes results in a slightly suboptimal pack. This flag tells the command not to reuse existing deltas but compute them from scratch.</source>
          <target state="translated">기존 팩이있는 저장소에서 묶음 아카이브를 작성할 때 명령은 기존 델타를 재사용합니다. 이것은 때때로 약간 차선책이됩니다. 이 플래그는 명령에 기존 델타를 재사용하지 말고 처음부터 계산하도록 지시합니다.</target>
        </trans-unit>
        <trans-unit id="40641904740525d3a46d2f53ea1f042429403d62" translate="yes" xml:space="preserve">
          <source>When creating files, prepend &amp;lt;string&amp;gt; (usually a directory including a trailing /)</source>
          <target state="translated">파일을 만들 때 &amp;lt;string&amp;gt;을 추가하십시오 (일반적으로 후행 /를 포함하는 디렉토리)</target>
        </trans-unit>
        <trans-unit id="55d2573d14b31c180f96244b6210a62251fe4b79" translate="yes" xml:space="preserve">
          <source>When dealing with &lt;code&gt;git diff-tree&lt;/code&gt; output, it takes advantage of the fact that the patch is prefixed with the object name of the commit, and outputs two 40-byte hexadecimal strings. The first string is the patch ID, and the second string is the commit ID. This can be used to make a mapping from patch ID to commit ID.</source>
          <target state="translated">&lt;code&gt;git diff-tree&lt;/code&gt; 출력을 다룰 때 , 패치는 커밋의 객체 이름으로 접두사가 붙고 2 개의 40 바이트 16 진 문자열을 출력한다는 사실을 이용합니다. 첫 번째 문자열은 패치 ID이고 두 번째 문자열은 커밋 ID입니다. 패치 ID에서 커밋 ID로 매핑하는 데 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d776ef3252048cd13183a8501d7c0015731386cd" translate="yes" xml:space="preserve">
          <source>When deciding what attributes are assigned to a path, Git consults &lt;code&gt;$GIT_DIR/info/attributes&lt;/code&gt; file (which has the highest precedence), &lt;code&gt;.gitattributes&lt;/code&gt; file in the same directory as the path in question, and its parent directories up to the toplevel of the work tree (the further the directory that contains &lt;code&gt;.gitattributes&lt;/code&gt; is from the path in question, the lower its precedence). Finally global and system-wide files are considered (they have the lowest precedence).</source>
          <target state="translated">경로에 할당 할 속성을 결정할 때 Git은 &lt;code&gt;$GIT_DIR/info/attributes&lt;/code&gt; 파일 (가장 높은 우선 순위), 해당 경로와 동일한 디렉토리에있는 &lt;code&gt;.gitattributes&lt;/code&gt; 파일 및 상위 디렉토리까지 상위 디렉토리를 참조합니다. 작업 트리 ( &lt;code&gt;.gitattributes&lt;/code&gt; 를 포함하는 디렉토리가 문제의 경로에서 멀 수록 우선 순위가 낮습니다). 마지막으로 전역 및 시스템 전체 파일이 고려됩니다 (가장 낮은 우선 순위를 가짐).</target>
        </trans-unit>
        <trans-unit id="be47e73cae5925c270f0353e0b448f44fba38688" translate="yes" xml:space="preserve">
          <source>When deinitialized or deleted (see below), the submodule&amp;rsquo;s Git directory is automatically moved to &lt;code&gt;$GIT_DIR/modules/&amp;lt;name&amp;gt;/&lt;/code&gt; of the superproject.</source>
          <target state="translated">초기화를 해제하거나 삭제하면 (아래 참조) 서브 모듈의 Git 디렉토리가 자동으로 수퍼 &lt;code&gt;$GIT_DIR/modules/&amp;lt;name&amp;gt;/&lt;/code&gt; 으로 이동합니다 .</target>
        </trans-unit>
        <trans-unit id="d6198e5c096df70165a4ba7282b14c9062838d85" translate="yes" xml:space="preserve">
          <source>When displaying names of reachable objects, in addition to the SHA-1 also display a name that describes &lt;strong&gt;how&lt;/strong&gt; they are reachable, compatible with &lt;a href=&quot;git-rev-parse&quot;&gt;git-rev-parse[1]&lt;/a&gt;, e.g. &lt;code&gt;HEAD@{1234567890}~25^2:src/&lt;/code&gt;.</source>
          <target state="translated">도달 가능한 객체의 이름을 표시 할 때 SHA-1 외에도 &lt;a href=&quot;git-rev-parse&quot;&gt;git-rev-parse [1]&lt;/a&gt; 과 호환되는 &lt;strong&gt;방법 (&lt;/strong&gt; 예 : &lt;code&gt;HEAD@{1234567890}~25^2:src/&lt;/code&gt; 을 설명 &lt;strong&gt;하는&lt;/strong&gt; 이름도 표시합니다 .</target>
        </trans-unit>
        <trans-unit id="39ccc422d97039f55d5b75b982904e65809f0ab0" translate="yes" xml:space="preserve">
          <source>When doing a dry-run, give the output in a porcelain-ready format. See &lt;a href=&quot;git-status&quot;&gt;git-status[1]&lt;/a&gt; for details. Implies &lt;code&gt;--dry-run&lt;/code&gt;.</source>
          <target state="translated">드라이-런을 수행 할 때는 출력을 도자기 준비 형식으로 제공하십시오. 자세한 내용은 &lt;a href=&quot;git-status&quot;&gt;git-status [1]&lt;/a&gt; 를 참조하십시오. &lt;code&gt;--dry-run&lt;/code&gt; 을 의미 합니다 .</target>
        </trans-unit>
        <trans-unit id="91fdf83cd4cf2351c13b94fc0d59dcd9a51c5b73" translate="yes" xml:space="preserve">
          <source>When doing a dry-run, give the output in the long-format. Implies &lt;code&gt;--dry-run&lt;/code&gt;.</source>
          <target state="translated">드라 이런을 수행 할 때는 출력을 긴 형식으로 제공하십시오. &lt;code&gt;--dry-run&lt;/code&gt; 을 의미 합니다 .</target>
        </trans-unit>
        <trans-unit id="7320eee3c7f6d76666dfe697952518d827846a03" translate="yes" xml:space="preserve">
          <source>When doing a dry-run, give the output in the short-format. See &lt;a href=&quot;git-status&quot;&gt;git-status[1]&lt;/a&gt; for details. Implies &lt;code&gt;--dry-run&lt;/code&gt;.</source>
          <target state="translated">드라 이런을 수행 할 때는 짧은 형식으로 출력하십시오. 자세한 내용은 &lt;a href=&quot;git-status&quot;&gt;git-status [1]&lt;/a&gt; 를 참조하십시오. &lt;code&gt;--dry-run&lt;/code&gt; 을 의미 합니다 .</target>
        </trans-unit>
        <trans-unit id="9aa102d4a4b04252e6d4b5a0080dce309ef777d4" translate="yes" xml:space="preserve">
          <source>When doing a repository conversion, use a unique mark per commit (&lt;code&gt;mark :&amp;lt;n&amp;gt;&lt;/code&gt;) and supply the --export-marks option on the command line. fast-import will dump a file which lists every mark and the Git object SHA-1 that corresponds to it. If the frontend can tie the marks back to the source repository, it is easy to verify the accuracy and completeness of the import by comparing each Git commit to the corresponding source revision.</source>
          <target state="translated">저장소 변환을 수행 할 때 고유 한 커밋 당 표시 ( &lt;code&gt;mark :&amp;lt;n&amp;gt;&lt;/code&gt; )를 사용하고 명령 행에 --export-marks 옵션을 제공하십시오. fast-import는 모든 마크와 이에 해당하는 Git 객체 SHA-1을 나열하는 파일을 덤프합니다. 프론트 엔드가 마크를 소스 리포지토리에 다시 묶을 수있는 경우 각 Git 커밋을 해당 소스 개정판과 비교하여 가져 오기의 정확성과 완전성을 쉽게 확인할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6f397bf185a0b1be7403f8c718221517e54d79b2" translate="yes" xml:space="preserve">
          <source>When editing the commit message, start the editor with the contents in the given file. The &lt;code&gt;commit.template&lt;/code&gt; configuration variable is often used to give this option implicitly to the command. This mechanism can be used by projects that want to guide participants with some hints on what to write in the message in what order. If the user exits the editor without editing the message, the commit is aborted. This has no effect when a message is given by other means, e.g. with the &lt;code&gt;-m&lt;/code&gt; or &lt;code&gt;-F&lt;/code&gt; options.</source>
          <target state="translated">커밋 메시지를 편집 할 때 주어진 파일의 내용으로 편집기를 시작하십시오. &lt;code&gt;commit.template&lt;/code&gt; 의 구성 변수는 종종 명령에 암시 적으로이 옵션을 제공하는 데 사용됩니다. 이 메커니즘은 메시지에 어떤 순서로 작성해야하는지에 대한 힌트를 참가자에게 안내하려는 프로젝트에서 사용할 수 있습니다. 사용자가 메시지를 편집하지 않고 편집기를 종료하면 커밋이 중단됩니다. 메시지가 다른 수단 (예 : &lt;code&gt;-m&lt;/code&gt; 또는 &lt;code&gt;-F&lt;/code&gt; 옵션 )으로 제공되는 경우에는 효과가 없습니다 .</target>
        </trans-unit>
        <trans-unit id="7835173f74e58e15c8891f5a3e0b3af743fd1c66" translate="yes" xml:space="preserve">
          <source>When editing, provide the raw object contents rather than pretty-printed ones. Currently this only affects trees, which will be shown in their binary form. This is harder to work with, but can help when repairing a tree that is so corrupted it cannot be pretty-printed. Note that you may need to configure your editor to cleanly read and write binary data.</source>
          <target state="translated">편집 할 때 예쁘게 인쇄 된 것이 아니라 원시 객체 내용을 제공하십시오. 현재 이것은 나무에만 영향을 미치며 이진 형식으로 표시됩니다. 이것은 작업하기가 어렵지만 너무 손상된 나무를 고칠 때는 꽤 인쇄 할 수 없습니다. 이진 데이터를 깨끗하게 읽고 쓰도록 편집기를 구성해야 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="ce47e94310de9fcb0d82c1f052bbcc38f3a11f76" translate="yes" xml:space="preserve">
          <source>When enabled, the default &lt;code&gt;post-update&lt;/code&gt; hook runs &lt;code&gt;git update-server-info&lt;/code&gt; to keep the information used by dumb transports (e.g., HTTP) up to date. If you are publishing a Git repository that is accessible via HTTP, you should probably enable this hook.</source>
          <target state="translated">사용 가능한 경우 기본 &lt;code&gt;post-update&lt;/code&gt; 후크는 &lt;code&gt;git update-server-info&lt;/code&gt; 를 실행 하여 바보 전송 (예 : HTTP)에서 사용하는 정보를 최신 상태로 유지합니다. HTTP를 통해 액세스 할 수있는 Git 저장소를 공개하는 경우이 후크를 사용 가능하게해야합니다.</target>
        </trans-unit>
        <trans-unit id="a529b1482d7666548417edb1d901df1240194350" translate="yes" xml:space="preserve">
          <source>When encountering a non-ASCII message or subject that does not declare its encoding, add headers/quoting to indicate it is encoded in &amp;lt;encoding&amp;gt;. Default is the value of the &lt;code&gt;sendemail.assume8bitEncoding&lt;/code&gt;; if that is unspecified, this will be prompted for if any non-ASCII files are encountered.</source>
          <target state="translated">비 ASCII 메시지 또는 인코딩을 선언하지 않은 제목이 나타나면 &amp;lt;encoding&amp;gt;으로 인코딩되었음을 나타내는 헤더 / 인용 부호를 추가하십시오. 기본값은 &lt;code&gt;sendemail.assume8bitEncoding&lt;/code&gt; 의 값입니다 . 지정되지 않은 경우 비 ASCII 파일이 있는지 묻는 메시지가 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="c331bd8bb74634e4f18684aaa53f36ba8f8cf37d" translate="yes" xml:space="preserve">
          <source>When erasing credentials, matching credentials will be erased from all files.</source>
          <target state="translated">자격 증명을 지우면 일치하는 자격 증명이 모든 파일에서 지워집니다.</target>
        </trans-unit>
        <trans-unit id="74e58a3904b06fc63c005d33dc33b553098868b7" translate="yes" xml:space="preserve">
          <source>When extensions.worktreeConfig is enabled, the config file &lt;code&gt;.git/worktrees/&amp;lt;id&amp;gt;/config.worktree&lt;/code&gt; is read after &lt;code&gt;.git/config&lt;/code&gt; is.</source>
          <target state="translated">extensions.worktreeConfig가 활성화되면 &lt;code&gt;.git/config&lt;/code&gt; 가 실행 된 후 구성 파일 &lt;code&gt;.git/worktrees/&amp;lt;id&amp;gt;/config.worktree&lt;/code&gt; 를 읽습니다 .</target>
        </trans-unit>
        <trans-unit id="3a73371934954e7de3c00c5b21339d1552e97b06" translate="yes" xml:space="preserve">
          <source>When false, merge the current branch into the upstream branch.</source>
          <target state="translated">false 인 경우 현재 분기를 업스트림 분기로 병합하십시오.</target>
        </trans-unit>
        <trans-unit id="c8afe72df4116adf55dd615031acfafbceae0ec5" translate="yes" xml:space="preserve">
          <source>When fetching refs listed on the command line, use the specified refspec (can be given more than once) to map the refs to remote-tracking branches, instead of the values of &lt;code&gt;remote.*.fetch&lt;/code&gt; configuration variables for the remote repository. See section on &quot;Configured Remote-tracking Branches&quot; for details.</source>
          <target state="translated">명령 행에 나열된 참조를 페치 할 때, 지정된 refspec (두 번 이상 제공 가능)을 사용 하여 원격 저장소에 대한 &lt;code&gt;remote.*.fetch&lt;/code&gt; 구성 변수 값 대신 참조를 원격 추적 분기에 맵핑하십시오 . 자세한 내용은 &quot;구성된 원격 추적 분기&quot;섹션을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="f131c02a4584603f0de6ca46a404ddf3258dbf13" translate="yes" xml:space="preserve">
          <source>When files are modified outside of Git, the user will need to stage the modified files explicitly (e.g. see &lt;code&gt;Examples&lt;/code&gt; section in &lt;a href=&quot;git-update-index&quot;&gt;git-update-index[1]&lt;/a&gt;). Git will not normally detect changes to those files.</source>
          <target state="translated">Git 외부에서 파일을 수정하는 경우 사용자는 수정 된 파일을 명시 적으로 스테이징해야합니다 (예 : &lt;a href=&quot;git-update-index&quot;&gt;git-update-index [1]의 &lt;/a&gt; &lt;code&gt;Examples&lt;/code&gt; 섹션 참조 ). Git은 일반적으로 해당 파일의 변경 사항을 감지하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="e95f7718835508fa2f714691dae7615b5ccee03a" translate="yes" xml:space="preserve">
          <source>When filtering history with &lt;code&gt;&amp;lt;path&amp;gt;&amp;hellip;​&lt;/code&gt;, does not prune some history. (See &quot;History simplification&quot; in &lt;a href=&quot;git-log&quot;&gt;git-log[1]&lt;/a&gt; for a more detailed explanation.)</source>
          <target state="translated">와 역사를 필터링 할 때 &lt;code&gt;&amp;lt;path&amp;gt;&amp;hellip;​&lt;/code&gt; , 어떤 역사를 제거하지 않습니다. ( 자세한 설명 은 &lt;a href=&quot;git-log&quot;&gt;git-log [1]의&lt;/a&gt; &quot;히스토리 단순화&quot;를 참조하십시오 .)</target>
        </trans-unit>
        <trans-unit id="18f94df4064f0faddb37415d13a088dd57356563" translate="yes" xml:space="preserve">
          <source>When first created, objects are stored in individual files, but for efficiency may later be compressed together into &quot;pack files&quot;.</source>
          <target state="translated">처음 생성 될 때 개체는 개별 파일에 저장되지만 효율성을 위해 나중에 &quot;팩 파일&quot;로 압축 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3ce1186a221491da0c957498f84e962314b0f4f4" translate="yes" xml:space="preserve">
          <source>When given a range of commits to display (e.g. &lt;code&gt;commit1..commit2&lt;/code&gt; or &lt;code&gt;commit2 ^commit1&lt;/code&gt;), only display commits that exist directly on the ancestry chain between the &lt;code&gt;commit1&lt;/code&gt; and &lt;code&gt;commit2&lt;/code&gt;, i.e. commits that are both descendants of &lt;code&gt;commit1&lt;/code&gt;, and ancestors of &lt;code&gt;commit2&lt;/code&gt;.</source>
          <target state="translated">(예를 들어 디스플레이 커밋의 범위를 특정하면 &lt;code&gt;commit1..commit2&lt;/code&gt; 또는 &lt;code&gt;commit2 ^commit1&lt;/code&gt; )만을 사이 조상 체인에 직접 존재 커밋 표시 &lt;code&gt;commit1&lt;/code&gt; 및 &lt;code&gt;commit2&lt;/code&gt; 의 자손들 모두, 즉, 커밋 &lt;code&gt;commit1&lt;/code&gt; , 그리고 조상 &lt;code&gt;commit2&lt;/code&gt; 를 .</target>
        </trans-unit>
        <trans-unit id="e006844e32fc3d063be827d3911798e9ae2b69bd" translate="yes" xml:space="preserve">
          <source>When given a range of commits to display (e.g. &lt;code&gt;commit1..commit2&lt;/code&gt; or &lt;code&gt;commit2 ^commit1&lt;/code&gt;), only display commits that exist directly on the ancestry chain between the &lt;code&gt;commit1&lt;/code&gt; and &lt;code&gt;commit2&lt;/code&gt;, i.e. commits that are both descendants of &lt;code&gt;commit1&lt;/code&gt;, and ancestors of &lt;code&gt;commit2&lt;/code&gt;. (See &quot;History simplification&quot; in &lt;a href=&quot;git-log&quot;&gt;git-log[1]&lt;/a&gt; for a more detailed explanation.)</source>
          <target state="translated">(예를 들어 디스플레이 커밋의 범위를 특정하면 &lt;code&gt;commit1..commit2&lt;/code&gt; 또는 &lt;code&gt;commit2 ^commit1&lt;/code&gt; )만을 사이 조상 체인에 직접 존재 커밋 표시 &lt;code&gt;commit1&lt;/code&gt; 및 &lt;code&gt;commit2&lt;/code&gt; 의 자손들 모두, 즉, 커밋 &lt;code&gt;commit1&lt;/code&gt; , 그리고 조상 &lt;code&gt;commit2&lt;/code&gt; 를 . ( 자세한 설명 은 &lt;a href=&quot;git-log&quot;&gt;git-log [1]의&lt;/a&gt; &quot;히스토리 단순화&quot;를 참조하십시오 .)</target>
        </trans-unit>
        <trans-unit id="8281565ed0f01821dd04f5b4f8a282147fc8eb15" translate="yes" xml:space="preserve">
          <source>When given a two-part name section.key, the value for section.&amp;lt;url&amp;gt;.key whose &amp;lt;url&amp;gt; part matches the best to the given URL is returned (if no such key exists, the value for section.key is used as a fallback). When given just the section as name, do so for all the keys in the section and list them. Returns error code 1 if no value is found.</source>
          <target state="translated">두 부분으로 된 section.key라는 이름이 주어지면 &amp;lt;url&amp;gt; 부분이 주어진 URL과 가장 일치하는 section. &amp;lt;url&amp;gt; .key의 값이 반환됩니다 (해당 키가 없으면 section.key의 값이 사용됨). 대체로). 섹션으로 만 이름이 지정되면 섹션의 모든 키에 대해 그렇게하고 나열하십시오. 값이 없으면 오류 코드 1을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="f88bacf945cb9e0553c03a8ac1d906d306ca24eb" translate="yes" xml:space="preserve">
          <source>When given an SVN revision number of the form &lt;code&gt;rN&lt;/code&gt;, returns the corresponding Git commit hash (this can optionally be followed by a tree-ish to specify which branch should be searched). When given a tree-ish, returns the corresponding SVN revision number.</source>
          <target state="translated">&lt;code&gt;rN&lt;/code&gt; 형식의 SVN 개정 번호 가 제공되면 해당 Git 커밋 해시를 반환합니다 (선택적으로 검색 할 브랜치를 지정하기 위해 트리를 따를 수 있음). 트리가 주어지면 해당 SVN 개정 번호를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="a96423d691859ec79cd98b29f7765677feb267ba" translate="yes" xml:space="preserve">
          <source>When given, and the repository to clone from is accessed via ssh, this specifies a non-default path for the command run on the other end.</source>
          <target state="translated">지정된 경우 복제 할 저장소에 ssh를 통해 액세스하면 다른 쪽에서 실행되는 명령의 기본 경로가 아닌 경로를 지정합니다.</target>
        </trans-unit>
        <trans-unit id="d1fb59a7ba9cbb456b044d488d1684f86345d108" translate="yes" xml:space="preserve">
          <source>When given, and the repository to fetch from is handled by &lt;code&gt;git fetch-pack&lt;/code&gt;, &lt;code&gt;--exec=&amp;lt;upload-pack&amp;gt;&lt;/code&gt; is passed to the command to specify non-default path for the command run on the other end.</source>
          <target state="translated">주어진 저장소에서 가져올 저장소가 &lt;code&gt;git fetch-pack&lt;/code&gt; 에 의해 처리 되면 &lt;code&gt;--exec=&amp;lt;upload-pack&amp;gt;&lt;/code&gt; 이 명령으로 전달되어 다른 쪽에서 실행되는 명령의 기본 경로가 아닌 경로를 지정합니다.</target>
        </trans-unit>
        <trans-unit id="347806ba4d643d64e35fb6159f6ca9df9bd36627" translate="yes" xml:space="preserve">
          <source>When giving multiple pattern expressions combined with &lt;code&gt;--or&lt;/code&gt;, this flag is specified to limit the match to files that have lines to match all of them.</source>
          <target state="translated">&lt;code&gt;--or&lt;/code&gt; 와 결합 된 여러 패턴 표현식을 제공 할 때이 플래그는 모두 일치하는 행이있는 파일로 일치를 제한하도록 지정됩니다.</target>
        </trans-unit>
        <trans-unit id="4aea2178dff194f0c4c01be5fd5d2a4667a09068" translate="yes" xml:space="preserve">
          <source>When he&amp;rsquo;s ready, he tells Alice to pull changes from the repository at /home/bob/myrepo. She does this with:</source>
          <target state="translated">준비가되면 / home / bob / myrepo의 저장소에서 변경 사항을 가져 오도록 Alice에게 지시합니다. 그녀는 다음을 수행합니다.</target>
        </trans-unit>
        <trans-unit id="66bba6f8c73ac5f72ec362ac6e58a5210f96d2e5" translate="yes" xml:space="preserve">
          <source>When importing a renamed file or directory, simply delete the old name(s) and modify the new name(s) during the corresponding commit. Git performs rename detection after-the-fact, rather than explicitly during a commit.</source>
          <target state="translated">이름이 바뀐 파일이나 디렉토리를 가져올 때는 해당 커밋 중에 이전 이름을 삭제하고 새 이름을 수정하면됩니다. Git은 커밋하는 동안 명시 적으로 수행하지 않고 이름 변경 감지를 수행합니다.</target>
        </trans-unit>
        <trans-unit id="3cdd5299d04b153fd0e295904b9e12eec6b499c8" translate="yes" xml:space="preserve">
          <source>When in list mode, show sha1 and commit subject line for each head, along with relationship to upstream branch (if any). If given twice, print the path of the linked worktree (if any) and the name of the upstream branch, as well (see also &lt;code&gt;git remote show &amp;lt;remote&amp;gt;&lt;/code&gt;). Note that the current worktree&amp;rsquo;s HEAD will not have its path printed (it will always be your current directory).</source>
          <target state="translated">목록 모드에있을 경우, 업스트림 브랜치 (있는 경우)와의 관계와 함께 sha1을 표시하고 각 헤드의 제목 줄을 커밋하십시오. 두 번 주어진 경우, 연결된 작업 트리의 경로 (있는 경우)와 업스트림 분기의 이름도 인쇄하십시오 ( &lt;code&gt;git remote show &amp;lt;remote&amp;gt;&lt;/code&gt; 참조 ). 현재 작업 트리의 HEAD에는 경로가 인쇄되지 않습니다 (항상 현재 디렉토리 임).</target>
        </trans-unit>
        <trans-unit id="df3e42ff48559b3d46a4606cc43ea02a4d5742e5" translate="yes" xml:space="preserve">
          <source>When informative errors are turned on, git-daemon will report more verbose errors to the client, differentiating conditions like &quot;no such repository&quot; from &quot;repository not exported&quot;. This is more convenient for clients, but may leak information about the existence of unexported repositories. When informative errors are not enabled, all errors report &quot;access denied&quot; to the client. The default is --no-informative-errors.</source>
          <target state="translated">유익한 오류가 설정되면 git-daemon은 클라이언트에 더 자세한 오류를보고하여 &quot;이러한 저장소 없음&quot;과 같은 조건을 &quot;저장소가 내보내지지 않음&quot;과 구별합니다. 이는 클라이언트에게는 더 편리하지만 내 보내지 않은 저장소의 존재에 대한 정보가 유출 될 수 있습니다. 정보 오류가 활성화되지 않은 경우 모든 오류는 클라이언트에 &quot;액세스 거부&quot;를보고합니다. 기본값은 --no-informative-errors입니다.</target>
        </trans-unit>
        <trans-unit id="882f7c25abfabdf5a0527656f301ec49c21b72e8" translate="yes" xml:space="preserve">
          <source>When initializing submodules, a &lt;code&gt;.gitmodules&lt;/code&gt; file in the top-level directory of the containing repository is used to find the url of each submodule. This file should be formatted in the same way as &lt;code&gt;$GIT_DIR/config&lt;/code&gt;. The key to each submodule url is &quot;submodule.$name.url&quot;. See &lt;a href=&quot;gitmodules&quot;&gt;gitmodules[5]&lt;/a&gt; for details.</source>
          <target state="translated">하위 모듈을 초기화 할 때 포함 저장소의 최상위 디렉토리에 있는 &lt;code&gt;.gitmodules&lt;/code&gt; 파일이 각 하위 모듈의 URL을 찾는 데 사용됩니다. 이 파일은 &lt;code&gt;$GIT_DIR/config&lt;/code&gt; 와 같은 방식으로 포맷되어야합니다 . 각 하위 모듈 URL의 키는 &quot;submodule. $ name.url&quot;입니다. 자세한 내용은 &lt;a href=&quot;gitmodules&quot;&gt;gitmodules [5]&lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="854c3f2001a62b8064a99a360e1e32072b64ad8e" translate="yes" xml:space="preserve">
          <source>When initially invoking &lt;code&gt;git am&lt;/code&gt;, you give it the names of the mailboxes to process. Upon seeing the first patch that does not apply, it aborts in the middle. You can recover from this in one of two ways:</source>
          <target state="translated">처음 &lt;code&gt;git am&lt;/code&gt; 을 호출 할 때 처리 할 메일 함의 이름을 지정하십시오. 적용되지 않는 첫 번째 패치를 보면 중간에 중단됩니다. 다음 두 가지 방법 중 하나로이를 복구 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ae919810620b188b4a098cb2c7010981f59eb2a8" translate="yes" xml:space="preserve">
          <source>When invoking a custom merge tool, Git uses a set of temporary files to pass to the tool. If the tool returns an error and this variable is set to &lt;code&gt;true&lt;/code&gt;, then these temporary files will be preserved, otherwise they will be removed after the tool has exited. Defaults to &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">사용자 정의 병합 도구를 호출 할 때 Git은 임시 파일 세트를 사용하여 도구에 전달합니다. 도구가 오류를 리턴하고이 변수가 &lt;code&gt;true&lt;/code&gt; 로 설정된 경우 이러한 임시 파일은 보존되며 그렇지 않으면 도구가 종료 된 후 제거됩니다. 기본값은 &lt;code&gt;false&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="8b149cf0c1c59f45e7d020f119cab62bcf88ef5e" translate="yes" xml:space="preserve">
          <source>When it comes to editing that commit, execute &lt;code&gt;git reset HEAD^&lt;/code&gt;. The effect is that the HEAD is rewound by one, and the index follows suit. However, the working tree stays the same.</source>
          <target state="translated">커밋을 편집 할 때 &lt;code&gt;git reset HEAD^&lt;/code&gt; 실행하십시오 . 그 결과 HEAD가 1 개씩 되 감겨지고 인덱스가 적합합니다. 그러나 작업 트리는 동일하게 유지됩니다.</target>
        </trans-unit>
        <trans-unit id="54d95c16d8a8ecd15ca228486caba0d9b645aa97" translate="yes" xml:space="preserve">
          <source>When it is not obvious how to apply a change, the following happens:</source>
          <target state="translated">변경 사항을 적용하는 방법이 확실하지 않은 경우 다음이 발생합니다.</target>
        </trans-unit>
        <trans-unit id="42b78027e34d66bfdfc08d7cf571f024832571b4" translate="yes" xml:space="preserve">
          <source>When it is not obvious how to reconcile the changes, the following happens:</source>
          <target state="translated">변경 사항을 조정하는 방법이 명확하지 않은 경우 다음이 발생합니다.</target>
        </trans-unit>
        <trans-unit id="ac3a9525cba718f2ba4c34b577914369145b2d3f" translate="yes" xml:space="preserve">
          <source>When listing references from an alternate, list only references that begin with the given prefix. Prefixes match as if they were given as arguments to &lt;a href=&quot;git-for-each-ref&quot;&gt;git-for-each-ref[1]&lt;/a&gt;. To list multiple prefixes, separate them with whitespace. If &lt;code&gt;core.alternateRefsCommand&lt;/code&gt; is set, setting &lt;code&gt;core.alternateRefsPrefixes&lt;/code&gt; has no effect.</source>
          <target state="translated">대체의 참조를 나열 할 때는 주어진 접두사로 시작하는 참조 만 나열하십시오. 접두사는 마치 &lt;a href=&quot;git-for-each-ref&quot;&gt;git-for-each-ref [1]에&lt;/a&gt; 인수로 주어진 것처럼 일치 합니다. 접두사를 여러 개 나열하려면 접두사를 공백으로 구분하십시오. 경우 &lt;code&gt;core.alternateRefsCommand&lt;/code&gt; 가 설정되어, 설정 &lt;code&gt;core.alternateRefsPrefixes&lt;/code&gt; 하는 것은 효과가 없습니다.</target>
        </trans-unit>
        <trans-unit id="9485b24ac5fd9e24de580d1b4ae98203a381daa8" translate="yes" xml:space="preserve">
          <source>When listing, use the specified &amp;lt;format&amp;gt;, which can be one of &lt;code&gt;short&lt;/code&gt;, &lt;code&gt;medium&lt;/code&gt; and &lt;code&gt;long&lt;/code&gt;. When omitted, the format defaults to &lt;code&gt;short&lt;/code&gt;.</source>
          <target state="translated">나열 할 때 지정된 &amp;lt;format&amp;gt;을 사용하십시오 . &lt;code&gt;short&lt;/code&gt; , &lt;code&gt;medium&lt;/code&gt; 및 &lt;code&gt;long&lt;/code&gt; 중 하나 일 수 있습니다 . 생략하면 형식은 기본적으로 &lt;code&gt;short&lt;/code&gt; 로 설정 됩니다.</target>
        </trans-unit>
        <trans-unit id="0de171dd2f5efd6969d6cc172c7d84e26d4bf231" translate="yes" xml:space="preserve">
          <source>When loosening unreachable objects, do not bother loosening any objects older than &lt;code&gt;&amp;lt;when&amp;gt;&lt;/code&gt;. This can be used to optimize out the write of any objects that would be immediately pruned by a follow-up &lt;code&gt;git prune&lt;/code&gt;.</source>
          <target state="translated">도달 할 수없는 객체를 풀 &lt;code&gt;&amp;lt;when&amp;gt;&lt;/code&gt; 보다 오래된 객체를 풀지 마십시오 . 이것은 후속 &lt;code&gt;git prune&lt;/code&gt; 에 의해 즉시 제거 될 오브젝트의 쓰기를 최적화하는 데 사용될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="2ecd3bb7ffbd4f19e0c8d754d499b7e6453c84ef" translate="yes" xml:space="preserve">
          <source>When merging an annotated (and possibly signed) tag, Git always creates a merge commit even if a fast-forward merge is possible, and the commit message template is prepared with the tag message. Additionally, if the tag is signed, the signature check is reported as a comment in the message template. See also &lt;a href=&quot;git-tag&quot;&gt;git-tag[1]&lt;/a&gt;.</source>
          <target state="translated">주석이 달린 (및 서명 될 수있는) 태그를 병합 할 때 Git은 빨리 감기 병합이 가능하더라도 항상 병합 커밋을 생성하고 커밋 메시지 템플릿은 태그 메시지와 함께 준비됩니다. 또한 태그에 서명 한 경우 서명 확인이 메시지 템플릿에 주석으로보고됩니다. &lt;a href=&quot;git-tag&quot;&gt;git-tag [1]&lt;/a&gt; 도 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="fe18117100b1e7049979d08b3604c39a0ff0f463" translate="yes" xml:space="preserve">
          <source>When merging notes, be more verbose. When pruning notes, report all object names whose notes are removed.</source>
          <target state="translated">노트를 병합 할 때 더 자세하게 설명하십시오. 메모를 제거 할 때 메모가 제거 된 모든 개체 이름을보고하십시오.</target>
        </trans-unit>
        <trans-unit id="2a6ffb56c555f1836377a0b4eb9f01a6db423b92" translate="yes" xml:space="preserve">
          <source>When merging notes, operate quietly.</source>
          <target state="translated">음표를 병합 할 때는 조용히 조작하십시오.</target>
        </trans-unit>
        <trans-unit id="452e3643271eefd0a90ad1d2e336613f571129ec" translate="yes" xml:space="preserve">
          <source>When merging notes, resolve notes conflicts using the given strategy. The following strategies are recognized: &quot;manual&quot; (default), &quot;ours&quot;, &quot;theirs&quot;, &quot;union&quot; and &quot;cat_sort_uniq&quot;. This option overrides the &quot;notes.mergeStrategy&quot; configuration setting. See the &quot;NOTES MERGE STRATEGIES&quot; section below for more information on each notes merge strategy.</source>
          <target state="translated">메모를 병합 할 때 주어진 전략을 사용하여 메모 충돌을 해결하십시오. &quot;수동&quot;(기본값), &quot;우리&quot;, &quot;그들의&quot;, &quot;연합&quot;및 &quot;cat_sort_uniq&quot;전략이 인식됩니다. 이 옵션은 &quot;notes.mergeStrategy&quot;구성 설정을 대체합니다. 각 노트 병합 전략에 대한 자세한 내용은 아래의 &quot;노트 병합 전략&quot;섹션을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="a1f0170f40742ebfd5d162ab78a6fe6f60fbd4e1" translate="yes" xml:space="preserve">
          <source>When missing or is set to &lt;code&gt;default&lt;/code&gt;, many fields in the stat structure are checked to detect if a file has been modified since Git looked at it. When this configuration variable is set to &lt;code&gt;minimal&lt;/code&gt;, sub-second part of mtime and ctime, the uid and gid of the owner of the file, the inode number (and the device number, if Git was compiled to use it), are excluded from the check among these fields, leaving only the whole-second part of mtime (and ctime, if &lt;code&gt;core.trustCtime&lt;/code&gt; is set) and the filesize to be checked.</source>
          <target state="translated">누락되거나 &lt;code&gt;default&lt;/code&gt; 설정되면 Git을 검토 한 후 파일이 수정되었는지 여부를 감지하기 위해 통계 구조의 많은 필드가 검사됩니다. 이 구성 변수로 설정하면 &lt;code&gt;minimal&lt;/code&gt; 에 mtime 및 ctime을 상기 UID의 서브 번째 부분과 파일 아이 노드 번호의 소유자 gid가 (및 장치 번호 힘내 사용하도록 컴파일 된 경우)에서 제외 mtime의 전체 초 부분 ( &lt;code&gt;core.trustCtime&lt;/code&gt; 이 설정된 경우 ctime) 만 남겨두고 파일 크기를 검사하도록 남겨 두면서이 필드 를 점검하십시오.</target>
        </trans-unit>
        <trans-unit id="0689b4b76e007bf9e9f69e1368a4eed9e3d9055a" translate="yes" xml:space="preserve">
          <source>When more than one pattern matches the path, a later line overrides an earlier line. This overriding is done per attribute.</source>
          <target state="translated">둘 이상의 패턴이 경로와 일치하면 나중 라인이 이전 라인보다 우선합니다. 이 재정의는 속성마다 수행됩니다.</target>
        </trans-unit>
        <trans-unit id="7de11bcf0fc6f31a9913abfce53b7b83c6075119" translate="yes" xml:space="preserve">
          <source>When moved lines are colored using e.g. the &lt;code&gt;diff.colorMoved&lt;/code&gt; setting, this option controls the &lt;code&gt;&amp;lt;mode&amp;gt;&lt;/code&gt; how spaces are treated for details of valid modes see &lt;code&gt;--color-moved-ws&lt;/code&gt; in &lt;a href=&quot;git-diff&quot;&gt;git-diff[1]&lt;/a&gt;.</source>
          <target state="translated">이동 된 선은 예를 들면 컬러를 사용하는 경우 &lt;code&gt;diff.colorMoved&lt;/code&gt; 의 설정이 옵션 제어 &lt;code&gt;&amp;lt;mode&amp;gt;&lt;/code&gt; 스페이스를 유효 모드의 세부 사항을 처리하는 방법을 알 &lt;code&gt;--color-moved-ws&lt;/code&gt; 의 &lt;a href=&quot;git-diff&quot;&gt;자식 DIFF-[1]&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="52b8058d0bfbbff70a9ce60ad478453479b9a747" translate="yes" xml:space="preserve">
          <source>When multiple patches are output, the subject prefix will instead be &quot;[PATCH n/m] &quot;. To force 1/1 to be added for a single patch, use &lt;code&gt;-n&lt;/code&gt;. To omit patch numbers from the subject, use &lt;code&gt;-N&lt;/code&gt;.</source>
          <target state="translated">여러 패치가 출력되면 제목 접두사가 &quot;[PATCH n / m]&quot;이됩니다. 단일 패치에 1/1을 강제로 추가하려면 &lt;code&gt;-n&lt;/code&gt; 을 사용하십시오 . 주제에서 패치 번호를 생략하려면 &lt;code&gt;-N&lt;/code&gt; 을 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="f1cdd3c7b73eb4476790691d3f8180aaaecc09ec" translate="yes" xml:space="preserve">
          <source>When multiple working trees are used, most of files in $GIT_DIR are per-worktree with a few known exceptions. All files under &lt;code&gt;common&lt;/code&gt; however will be shared between all working trees.</source>
          <target state="translated">여러 작업 트리가 사용되는 경우 $ GIT_DIR에있는 대부분의 파일은 몇 가지 알려진 예외를 제외하고 작업 트리 별입니다. 그러나 &lt;code&gt;common&lt;/code&gt; 모든 파일 은 모든 작업 트리간에 공유됩니다.</target>
        </trans-unit>
        <trans-unit id="dea6d60865820d20f017799a5c24231f89c30494" translate="yes" xml:space="preserve">
          <source>When neither the command-line nor the configuration specify what to push, the default behavior is used, which corresponds to the &lt;code&gt;simple&lt;/code&gt; value for &lt;code&gt;push.default&lt;/code&gt;: the current branch is pushed to the corresponding upstream branch, but as a safety measure, the push is aborted if the upstream branch does not have the same name as the local one.</source>
          <target state="translated">명령 줄이나 구성에서 푸시 대상을 지정하지 않으면 push에 대한 &lt;code&gt;simple&lt;/code&gt; 값에 해당하는 기본 동작이 사용됩니다. &lt;code&gt;push.default&lt;/code&gt; : 현재 분기가 해당 업스트림 분기로 푸시되지만 안전 측정으로 푸시 업스트림 브랜치가 로컬 브랜치와 이름이 같지 않으면 중단됩니다.</target>
        </trans-unit>
        <trans-unit id="60de604c8e6be170ca14a17caf3d8c66cf8e4c1f" translate="yes" xml:space="preserve">
          <source>When no &lt;code&gt;&amp;lt;stash&amp;gt;&lt;/code&gt; is given, &lt;code&gt;stash@{0}&lt;/code&gt; is assumed, otherwise &lt;code&gt;&amp;lt;stash&amp;gt;&lt;/code&gt; must be a reference of the form &lt;code&gt;stash@{&amp;lt;revision&amp;gt;}&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&amp;lt;stash&amp;gt;&lt;/code&gt; 가 제공 되지 않으면 &lt;code&gt;stash@{0}&lt;/code&gt; 이 가정되고, 그렇지 않으면 &lt;code&gt;&amp;lt;stash&amp;gt;&lt;/code&gt; 는 &lt;code&gt;stash@{&amp;lt;revision&amp;gt;}&lt;/code&gt; 형식의 참조 여야합니다 .</target>
        </trans-unit>
        <trans-unit id="1cb728a038f1c7e17113ec68844d5bac04accdd7" translate="yes" xml:space="preserve">
          <source>When no &lt;code&gt;--push-option=&amp;lt;option&amp;gt;&lt;/code&gt; argument is given from the command line, &lt;code&gt;git push&lt;/code&gt; behaves as if each &amp;lt;value&amp;gt; of this variable is given as &lt;code&gt;--push-option=&amp;lt;value&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">어떠한 경우 &lt;code&gt;--push-option=&amp;lt;option&amp;gt;&lt;/code&gt; 인수는 명령 라인에서 제공되지 않는, &lt;code&gt;git push&lt;/code&gt; 동작합니다이 변수들 각각 &amp;lt;값&amp;gt;로 주어진 것처럼 &lt;code&gt;--push-option=&amp;lt;value&amp;gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a166fc08fc71ee0e3d700a37b70f8845fb53d565" translate="yes" xml:space="preserve">
          <source>When no &lt;code&gt;--whitespace&lt;/code&gt; flag is given from the command line, this configuration item is used as the default.</source>
          <target state="translated">명령 행에서 &lt;code&gt;--whitespace&lt;/code&gt; 플래그가 제공 되지 않으면 이 구성 항목이 기본값으로 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="b29755631cf67968424c24b41012b3c14a5bc20f" translate="yes" xml:space="preserve">
          <source>When no refspec was given on the command line, then &lt;code&gt;git pull&lt;/code&gt; uses the refspec from the configuration or &lt;code&gt;$GIT_DIR/remotes/&amp;lt;origin&amp;gt;&lt;/code&gt;. In such cases, the following rules apply:</source>
          <target state="translated">명령 행에 refspec이 없으면 &lt;code&gt;git pull&lt;/code&gt; 은 구성 또는 &lt;code&gt;$GIT_DIR/remotes/&amp;lt;origin&amp;gt;&lt;/code&gt; 의 refspec을 사용합니다 . 이러한 경우 다음 규칙이 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="feee7e6efffd7b04e5558aa779c91bc6a7b795bd" translate="yes" xml:space="preserve">
          <source>When no remote is specified (via -r) the &lt;code&gt;HEAD&lt;/code&gt; branch from CVS is imported to the &lt;code&gt;origin&lt;/code&gt; branch within the Git repository, as &lt;code&gt;HEAD&lt;/code&gt; already has a special meaning for Git. When a remote is specified the &lt;code&gt;HEAD&lt;/code&gt; branch is named remotes/&amp;lt;remote&amp;gt;/master mirroring &lt;code&gt;git clone&lt;/code&gt; behaviour. Use this option if you want to import into a different branch.</source>
          <target state="translated">&lt;code&gt;HEAD&lt;/code&gt; 가 이미 Git에 특별한 의미를 가지고 있기 때문에 -r을 통해 원격이 지정되지 않은 경우 (-r을 통해) CVS 의 &lt;code&gt;HEAD&lt;/code&gt; 분기 가 Git 리포지토리 의 &lt;code&gt;origin&lt;/code&gt; 분기로 가져옵니다 . 리모트가 지정되면 &lt;code&gt;HEAD&lt;/code&gt; 브랜치의 이름은 remotes / &amp;lt;remote&amp;gt; / master mirroring &lt;code&gt;git clone&lt;/code&gt; behavior로 지정됩니다. 다른 지점으로 가져 오려면이 옵션을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="ac03f302c1aadb048fb52d65d000d2a5006af96e" translate="yes" xml:space="preserve">
          <source>When no remote is specified, by default the &lt;code&gt;origin&lt;/code&gt; remote will be used, unless there&amp;rsquo;s an upstream branch configured for the current branch.</source>
          <target state="translated">원격이 지정 되지 않은 경우 현재 분기에 대해 업스트림 분기가 구성되어 있지 않으면 기본적으로 &lt;code&gt;origin&lt;/code&gt; 원격이 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="d52e3dbbfef371828cf1a5d65a8a3d7860fbbc07" translate="yes" xml:space="preserve">
          <source>When on branch &amp;lt;name&amp;gt;, it overrides &lt;code&gt;branch.&amp;lt;name&amp;gt;.remote&lt;/code&gt; for pushing. It also overrides &lt;code&gt;remote.pushDefault&lt;/code&gt; for pushing from branch &amp;lt;name&amp;gt;. When you pull from one place (e.g. your upstream) and push to another place (e.g. your own publishing repository), you would want to set &lt;code&gt;remote.pushDefault&lt;/code&gt; to specify the remote to push to for all branches, and use this option to override it for a specific branch.</source>
          <target state="translated">분기 &amp;lt;name&amp;gt;에있는 경우 밀어 &lt;code&gt;branch.&amp;lt;name&amp;gt;.remote&lt;/code&gt; 위해 branch. &amp;lt;name&amp;gt; .remote 를 재정의 합니다. 또한 &amp;lt;name&amp;gt; 분기에서 푸시하기 위해 &lt;code&gt;remote.pushDefault&lt;/code&gt; 를 재정의 합니다. 한 장소 (예 : 업스트림)에서 다른 장소 (예 : 자체 게시 저장소) 로 푸시 할 때 &lt;code&gt;remote.pushDefault&lt;/code&gt; 를 설정하여 모든 지점에 대해 푸시 할 원격을 지정하고이 옵션을 사용하여이를 재정의하려는 경우 특정 지점의 경우</target>
        </trans-unit>
        <trans-unit id="2c5d62eaf7dc4c0abb09284bfc14bacce3f382aa" translate="yes" xml:space="preserve">
          <source>When on branch &amp;lt;name&amp;gt;, it tells &lt;code&gt;git fetch&lt;/code&gt; and &lt;code&gt;git push&lt;/code&gt; which remote to fetch from/push to. The remote to push to may be overridden with &lt;code&gt;remote.pushDefault&lt;/code&gt; (for all branches). The remote to push to, for the current branch, may be further overridden by &lt;code&gt;branch.&amp;lt;name&amp;gt;.pushRemote&lt;/code&gt;. If no remote is configured, or if you are not on any branch, it defaults to &lt;code&gt;origin&lt;/code&gt; for fetching and &lt;code&gt;remote.pushDefault&lt;/code&gt; for pushing. Additionally, &lt;code&gt;.&lt;/code&gt; (a period) is the current local repository (a dot-repository), see &lt;code&gt;branch.&amp;lt;name&amp;gt;.merge&lt;/code&gt;'s final note below.</source>
          <target state="translated">분기 &amp;lt;name&amp;gt;에있을 때 &lt;code&gt;git fetch&lt;/code&gt; 및 &lt;code&gt;git push&lt;/code&gt; 에게 어느 리모트에서 페치 / 푸시할지 알려줍니다 . 푸시 할 리모컨은 &lt;code&gt;remote.pushDefault&lt;/code&gt; (모든 분기에 대해) 로 재정의 될 수 있습니다 . 현재 브랜치에 대해 푸시 할 리모트는 &lt;code&gt;branch.&amp;lt;name&amp;gt;.pushRemote&lt;/code&gt; 로 더 우선 될 수 있습니다 . 원격이 구성되어 있지 않거나 브랜치에 있지 않은 경우 기본적으로 페치의 &lt;code&gt;origin&lt;/code&gt; 이되고 푸시의 경우 &lt;code&gt;remote.pushDefault&lt;/code&gt; 가됩니다. 또한 &lt;code&gt;.&lt;/code&gt; (마침표)는 현재 로컬 리포지토리 (도트 리포지토리)입니다. 아래의 &lt;code&gt;branch.&amp;lt;name&amp;gt;.merge&lt;/code&gt; 마지막 참고 사항을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="99875f2b6ac5843dc20c0934eb9cdf10f7711c8e" translate="yes" xml:space="preserve">
          <source>When one of these flags is specified, the object name recorded for the paths are not updated. Instead, these options set and unset the &quot;fsmonitor valid&quot; bit for the paths. See section &quot;File System Monitor&quot; below for more information.</source>
          <target state="translated">이러한 플래그 중 하나가 지정되면 경로에 대해 기록 된 오브젝트 이름이 업데이트되지 않습니다. 대신,이 옵션은 경로에 대한 &quot;fsmonitor valid&quot;비트를 설정 및 설정 해제합니다. 자세한 내용은 아래의 &quot;파일 시스템 모니터&quot;섹션을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="095b3a1631077463d64190b5c04e9903f37eec26" translate="yes" xml:space="preserve">
          <source>When one of these flags is specified, the object name recorded for the paths are not updated. Instead, these options set and unset the &quot;skip-worktree&quot; bit for the paths. See section &quot;Skip-worktree bit&quot; below for more information.</source>
          <target state="translated">이러한 플래그 중 하나가 지정되면 경로에 대해 기록 된 오브젝트 이름이 업데이트되지 않습니다. 대신,이 옵션은 경로에 대한 &quot;skip-worktree&quot;비트를 설정 및 설정 해제합니다. 자세한 내용은 아래의 &quot;건너 뛰기 작업 비트&quot;섹션을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="6e8f4e10b13b6ff83d83df5063d58c36d64a87b8" translate="yes" xml:space="preserve">
          <source>When one or more &lt;code&gt;&amp;lt;ref&amp;gt;&lt;/code&gt; are specified explicitly (whether on the command line or via &lt;code&gt;--stdin&lt;/code&gt;), it can be either a single pattern, or a pair of such pattern separated by a colon &quot;:&quot; (this means that a ref name cannot have a colon in it). A single pattern &lt;code&gt;&amp;lt;name&amp;gt;&lt;/code&gt; is just a shorthand for &lt;code&gt;&amp;lt;name&amp;gt;:&amp;lt;name&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">하나 이상의 &lt;code&gt;&amp;lt;ref&amp;gt;&lt;/code&gt; 가 명시 적으로 지정되면 (명령 행 또는 &lt;code&gt;--stdin&lt;/code&gt; 을 통해 ) 콜론 &quot;:&quot;으로 구분 된 단일 패턴 또는 이러한 패턴 쌍일 수 있습니다 (이는 ref 이름에는 콜론을 사용할 수 없습니다). 단일 패턴 &lt;code&gt;&amp;lt;name&amp;gt;&lt;/code&gt; 은 &lt;code&gt;&amp;lt;name&amp;gt;:&amp;lt;name&amp;gt;&lt;/code&gt; 의 약어입니다 .</target>
        </trans-unit>
        <trans-unit id="9a9b16c534806b7638cc46892a28dd173752ed8c" translate="yes" xml:space="preserve">
          <source>When packing a blob fast-import always attempts to deltify against the last blob written. Unless specifically arranged for by the frontend, this will probably not be a prior version of the same file, so the generated delta will not be the smallest possible. The resulting packfile will be compressed, but will not be optimal.</source>
          <target state="translated">Blob 빠른 가져 오기를 패킹 할 때는 항상 마지막으로 작성된 Blob에 대해 deltify를 시도합니다. 프론트 엔드에서 특별히 지정하지 않는 한, 이는 동일한 파일의 이전 버전이 아닐 수 있으므로 생성 된 델타가 가장 작을 수는 없습니다. 결과 팩 파일은 압축되지만 최적은 아닙니다.</target>
        </trans-unit>
        <trans-unit id="76e4bf1d99930055a44aa05818b2c065730f60bb" translate="yes" xml:space="preserve">
          <source>When passed to &lt;code&gt;init&lt;/code&gt; or &lt;code&gt;clone&lt;/code&gt; this regular expression will be preserved as a config key. See &lt;code&gt;fetch&lt;/code&gt; for a description of &lt;code&gt;--ignore-paths&lt;/code&gt;.</source>
          <target state="translated">에 전달하면 &lt;code&gt;init&lt;/code&gt; 또는 &lt;code&gt;clone&lt;/code&gt; 이 정규 표현식은 설정 키로 유지됩니다. &lt;code&gt;--ignore-paths&lt;/code&gt; 에 대한 설명은 &lt;code&gt;fetch&lt;/code&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="d6a3308486ea0114e28423fc585e726bdfefa0d3" translate="yes" xml:space="preserve">
          <source>When passed to &lt;code&gt;init&lt;/code&gt; or &lt;code&gt;clone&lt;/code&gt; this regular expression will be preserved as a config key. See &lt;code&gt;fetch&lt;/code&gt; for a description of &lt;code&gt;--ignore-refs&lt;/code&gt;.</source>
          <target state="translated">에 전달하면 &lt;code&gt;init&lt;/code&gt; 또는 &lt;code&gt;clone&lt;/code&gt; 이 정규 표현식은 설정 키로 유지됩니다. &lt;code&gt;--ignore-refs&lt;/code&gt; 에 대한 설명은 &lt;code&gt;fetch&lt;/code&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="247954c989ece2f916f72b869f8bb1eb7f01f09e" translate="yes" xml:space="preserve">
          <source>When passed to &lt;code&gt;init&lt;/code&gt; or &lt;code&gt;clone&lt;/code&gt; this regular expression will be preserved as a config key. See &lt;code&gt;fetch&lt;/code&gt; for a description of &lt;code&gt;--include-paths&lt;/code&gt;.</source>
          <target state="translated">에 전달하면 &lt;code&gt;init&lt;/code&gt; 또는 &lt;code&gt;clone&lt;/code&gt; 이 정규 표현식은 설정 키로 유지됩니다. &lt;code&gt;--include-paths&lt;/code&gt; 에 대한 설명은 &lt;code&gt;fetch&lt;/code&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="701b3c119f368819101d8af88b842359e5cb7ac8" translate="yes" xml:space="preserve">
          <source>When paths are given, show them (note that this isn&amp;rsquo;t really raw pathnames, but rather a list of patterns to match). Otherwise implicitly uses the root level of the tree as the sole path argument.</source>
          <target state="translated">경로가 주어지면 표시하십시오 (이것은 실제로 원시 경로 이름이 아니라 일치하는 패턴 목록입니다). 그렇지 않으면 내재적으로 트리의 루트 레벨을 유일한 경로 인수로 사용합니다.</target>
        </trans-unit>
        <trans-unit id="a12bc3537fe67daac72917848a655d5078c91711" translate="yes" xml:space="preserve">
          <source>When pathspec is given on the command line, commit the contents of the files that match the pathspec without recording the changes already added to the index. The contents of these files are also staged for the next commit on top of what have been staged before.</source>
          <target state="translated">명령 행에 pathspec이 지정되면 색인에 이미 추가 된 변경 사항을 기록하지 않고 pathspec과 일치하는 파일의 컨텐츠를 커미트하십시오. 이 파일의 내용은 이전에 준비된 것 외에 다음 커밋을 위해 준비됩니다.</target>
        </trans-unit>
        <trans-unit id="1a6dc462ca36ebe8779cf750259e000c162a076a" translate="yes" xml:space="preserve">
          <source>When pathspec is given to &lt;code&gt;git stash push&lt;/code&gt;, the new stash entry records the modified states only for the files that match the pathspec. The index entries and working tree files are then rolled back to the state in HEAD only for these files, too, leaving files that do not match the pathspec intact.</source>
          <target state="translated">pathspec이 &lt;code&gt;git stash push&lt;/code&gt; 에 제공되면 새 숨김 항목은 pathspec과 일치하는 파일에 대해서만 수정 된 상태를 기록합니다. 그런 다음 인덱스 항목과 작업 트리 파일은 이러한 파일에 대해서만 HEAD의 상태로 롤백되므로 pathspec과 일치하지 않는 파일은 그대로 유지됩니다.</target>
        </trans-unit>
        <trans-unit id="20284d20320c7f9cdd342728ed75cf98e12a1b6c" translate="yes" xml:space="preserve">
          <source>When possible, &lt;code&gt;pack-objects&lt;/code&gt; tries to reuse existing on-disk deltas to avoid having to search for new ones on the fly. This is an important optimization for serving fetches, because it means the server can avoid inflating most objects at all and just send the bytes directly from disk. This optimization can&amp;rsquo;t work when an object is stored as a delta against a base which the receiver does not have (and which we are not already sending). In that case the server &quot;breaks&quot; the delta and has to find a new one, which has a high CPU cost. Therefore it&amp;rsquo;s important for performance that the set of objects in on-disk delta relationships match what a client would fetch.</source>
          <target state="translated">가능하면 &lt;code&gt;pack-objects&lt;/code&gt; 는 기존 온 디스크 델타를 재사용하여 새로운 것을 검색하지 않아도됩니다. 이것은 서버가 대부분의 객체를 전혀 팽창시키지 않고 바이트를 디스크에서 직접 보낼 수 있기 때문에 가져 오기를 제공하는 데 중요한 최적화입니다. 이 최적화는 객체가 수신자가 가지고 있지 않은 (그리고 아직 보내지 않은)베이스에 대한 델타로 저장 될 때 작동하지 않습니다. 이 경우 서버는 델타를 &quot;중단&quot;하고 CPU 비용이 높은 새로운 델타를 찾아야합니다. 따라서 디스크상의 델타 관계에있는 오브젝트 세트가 클라이언트가 페치하는 것과 일치하는 것이 성능에 중요합니다.</target>
        </trans-unit>
        <trans-unit id="a5d1e2c9c76493f4d0a607592b15388eabc93e4e" translate="yes" xml:space="preserve">
          <source>When present, it will also copy the value of &lt;code&gt;submodule.$name.update&lt;/code&gt;. This command does not alter existing information in .git/config. You can then customize the submodule clone URLs in .git/config for your local setup and proceed to &lt;code&gt;git submodule update&lt;/code&gt;; you can also just use &lt;code&gt;git submodule update --init&lt;/code&gt; without the explicit &lt;code&gt;init&lt;/code&gt; step if you do not intend to customize any submodule locations.</source>
          <target state="translated">존재할 경우 &lt;code&gt;submodule.$name.update&lt;/code&gt; 의 값도 복사합니다 . 이 명령은 .git / config의 기존 정보를 변경하지 않습니다. 그런 다음 로컬 설정을 위해 .git / config에서 하위 모듈 복제 URL을 사용자 정의하고 &lt;code&gt;git submodule update&lt;/code&gt; 진행할 수 있습니다 . 하위 모듈 위치를 사용자 정의하지 않으려는 경우 명시적인 &lt;code&gt;init&lt;/code&gt; 단계 없이 &lt;code&gt;git submodule update --init&lt;/code&gt; 을 사용할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="fb5aacfd35a68a879acea2ba6edf150f79c935f9" translate="yes" xml:space="preserve">
          <source>When pushing to a remote that is different from the remote you normally pull from, work as &lt;code&gt;current&lt;/code&gt;. This is the safest option and is suited for beginners.</source>
          <target state="translated">일반적으로 당기는 리모컨과 다른 리모컨으로 밀 때 &lt;code&gt;current&lt;/code&gt; 작동하십시오 . 이것은 가장 안전한 옵션이며 초보자에게 적합합니다.</target>
        </trans-unit>
        <trans-unit id="f99e4f9643f5e033d51557f2aab4b69c000e9e23" translate="yes" xml:space="preserve">
          <source>When pushing, request the remote server to update refs in a single atomic transaction. If successful, all refs will be updated, or none will. If the remote side does not support this capability, the push will fail.</source>
          <target state="translated">푸시 할 때 단일 원자 트랜잭션에서 원격 서버에 참조를 업데이트하도록 요청하십시오. 성공하면 모든 심판이 업데이트되거나 아무도 없습니다. 원격 측이이 기능을 지원하지 않으면 푸시가 실패합니다.</target>
        </trans-unit>
        <trans-unit id="24e8d08f5bcd393fd98db303b5bfff38ae149335" translate="yes" xml:space="preserve">
          <source>When reading the &lt;code&gt;core.repositoryformatversion&lt;/code&gt; variable, a git implementation which supports version 1 MUST also read any configuration keys found in the &lt;code&gt;extensions&lt;/code&gt; section of the configuration file.</source>
          <target state="translated">&lt;code&gt;core.repositoryformatversion&lt;/code&gt; 변수를 읽을 때 버전 1을 지원하는 git 구현 은 구성 파일 의 &lt;code&gt;extensions&lt;/code&gt; 섹션에있는 구성 키도 읽어야 합니다.</target>
        </trans-unit>
        <trans-unit id="d49438aa2f88cdc57a3b7001a0406b8491bbad55" translate="yes" xml:space="preserve">
          <source>When reading trailers, there can be whitespaces after the token, the separator and the value. There can also be whitespaces inside the token and the value. The value may be split over multiple lines with each subsequent line starting with whitespace, like the &quot;folding&quot; in RFC 822.</source>
          <target state="translated">트레일러를 읽을 때 토큰, 구분 기호 및 값 뒤에 공백이있을 수 있습니다. 토큰 내부에 공백과 값이있을 수도 있습니다. RFC 822의 &quot;접기&quot;와 같이 공백으로 시작하는 각 후속 줄을 사용하여 값을 여러 줄로 나눌 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c808cfa1e01223bf6f90ceb1edbec20a1b9b3321" translate="yes" xml:space="preserve">
          <source>When reading, the values are read from the system, global and repository local configuration files by default, and options &lt;code&gt;--system&lt;/code&gt;, &lt;code&gt;--global&lt;/code&gt;, &lt;code&gt;--local&lt;/code&gt;, &lt;code&gt;--worktree&lt;/code&gt; and &lt;code&gt;--file &amp;lt;filename&amp;gt;&lt;/code&gt; can be used to tell the command to read from only that location (see &lt;a href=&quot;#FILES&quot;&gt;FILES&lt;/a&gt;).</source>
          <target state="translated">읽을 때 기본적으로 시스템, 글로벌 및 저장소 로컬 구성 파일에서 값을 읽으며 &lt;code&gt;--system&lt;/code&gt; , &lt;code&gt;--global&lt;/code&gt; , &lt;code&gt;--local&lt;/code&gt; , &lt;code&gt;--worktree&lt;/code&gt; 및 &lt;code&gt;--file &amp;lt;filename&amp;gt;&lt;/code&gt; 옵션 을 사용하여 해당 위치에서만 읽을 수있는 명령입니다 ( &lt;a href=&quot;#FILES&quot;&gt;FILES&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="35058e27fd0502a5cbd6b1225fdbfa49a5b7004d" translate="yes" xml:space="preserve">
          <source>When recording the commit, append a line that says &quot;(cherry picked from commit &amp;hellip;​)&quot; to the original commit message in order to indicate which commit this change was cherry-picked from. This is done only for cherry picks without conflicts. Do not use this option if you are cherry-picking from your private branch because the information is useless to the recipient. If on the other hand you are cherry-picking between two publicly visible branches (e.g. backporting a fix to a maintenance branch for an older release from a development branch), adding this information can be useful.</source>
          <target state="translated">커밋을 기록 할 때이 변경이 체리에서 선택된 커밋을 나타 내기 위해 원래 커밋 메시지에 &quot;(체리에서 커밋 &amp;hellip;&amp;hellip;)&quot;이라는 행을 추가하십시오. 이것은 충돌없이 체리 픽에만 적용됩니다. 정보는 수신자에게 쓸모가 없으므로 개인 지점에서 체리 피킹하는 경우이 옵션을 사용하지 마십시오. 반면에 공개적으로 보이는 두 가지 사이에서 체리 픽을 선택하는 경우 (예 : 개발 브랜치에서 이전 릴리스의 유지 보수 브랜치로 수정을 백 포트하는 경우)이 정보를 추가하면 유용 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ccaf8e1c6e304870dc79f0b6ba9e209459375c19" translate="yes" xml:space="preserve">
          <source>When recording your own work, the contents of modified files in your working tree are temporarily stored to a staging area called the &quot;index&quot; with &lt;code&gt;git add&lt;/code&gt;. A file can be reverted back, only in the index but not in the working tree, to that of the last commit with &lt;code&gt;git restore --staged &amp;lt;file&amp;gt;&lt;/code&gt;, which effectively reverts &lt;code&gt;git add&lt;/code&gt; and prevents the changes to this file from participating in the next commit. After building the state to be committed incrementally with these commands, &lt;code&gt;git commit&lt;/code&gt; (without any pathname parameter) is used to record what has been staged so far. This is the most basic form of the command. An example:</source>
          <target state="translated">자신의 작업을 기록 할 때 작업 트리에서 수정 된 파일의 내용은 &lt;code&gt;git add&lt;/code&gt; 를 사용하여 &quot;index&quot;라는 준비 영역에 임시 저장됩니다 . 파일은 작업 트리가 아닌 인덱스에서만 &lt;code&gt;git restore --staged &amp;lt;file&amp;gt;&lt;/code&gt; 을 사용하여 마지막 커밋으로 되돌릴 수 있습니다 .git add --staged &amp;lt;file&amp;gt; 은 효과적으로 &lt;code&gt;git add&lt;/code&gt; 를 되돌리고이 파일에 대한 변경 사항이 다음 커밋. 이러한 명령으로 상태를 점진적으로 커밋하도록 빌드 한 후 &lt;code&gt;git commit&lt;/code&gt; (경로 매개 변수없이)은 지금까지 준비된 내용을 기록하는 데 사용됩니다. 이것이 가장 기본적인 형태의 명령입니다. 예를 들면 :</target>
        </trans-unit>
        <trans-unit id="35cd60207a202ee3a283a2d8b2047b148806b6b3" translate="yes" xml:space="preserve">
          <source>When remote and local branch are both named &quot;test&quot;:</source>
          <target state="translated">원격 및 로컬 지점의 이름이 &quot;test&quot;인 경우 :</target>
        </trans-unit>
        <trans-unit id="2eefb86cce90a60f5ab07db6487aa99da3ba4333" translate="yes" xml:space="preserve">
          <source>When rename/copy is involved, &lt;code&gt;file1&lt;/code&gt; and &lt;code&gt;file2&lt;/code&gt; show the name of the source file of the rename/copy and the name of the file that rename/copy produces, respectively.</source>
          <target state="translated">이름 바꾸기 / 복사가 관련된 경우, &lt;code&gt;file1&lt;/code&gt; 및 &lt;code&gt;file2&lt;/code&gt; 는 이름 바꾸기 / 복사의 소스 파일 이름과 이름 바꾸기 / 복사에 의해 생성되는 파일 이름을 각각 표시합니다.</target>
        </trans-unit>
        <trans-unit id="3475b12f6b8e32c3a9c4f496f5f906d95460d63d" translate="yes" xml:space="preserve">
          <source>When repacking with delta islands the delta window tends to get clogged with candidates that are forbidden by the config. Repacking with a big --window helps (and doesn&amp;rsquo;t take as long as it otherwise might because we can reject some object pairs based on islands before doing any computation on the content).</source>
          <target state="translated">델타 아일랜드로 리 패킹 할 때 델타 창은 구성에서 금지 된 후보로 막히는 경향이 있습니다. 큰 창으로 재 포장하면 도움이됩니다 (콘텐츠에 대한 계산을 수행하기 전에 섬을 기반으로 일부 객체 쌍을 거부 할 수 있기 때문에 시간이 오래 걸리지 않습니다).</target>
        </trans-unit>
        <trans-unit id="9f9b14ed67913870e54606a7e4140c245c13e689" translate="yes" xml:space="preserve">
          <source>When restoring files in the working tree from the index, use stage #2 (&lt;code&gt;ours&lt;/code&gt;) or #3 (&lt;code&gt;theirs&lt;/code&gt;) for unmerged paths.</source>
          <target state="translated">작업 트리의 파일을 인덱스에서 복원 할 때 병합되지 않은 경로에 스테이지 # 2 ( &lt;code&gt;ours&lt;/code&gt; ) 또는 # 3 ( &lt;code&gt;theirs&lt;/code&gt; )을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="f350add778942f50c4b0b2f8798762ec9d6fc205" translate="yes" xml:space="preserve">
          <source>When restoring files on the working tree from the index, do not abort the operation if there are unmerged entries and neither &lt;code&gt;--ours&lt;/code&gt;, &lt;code&gt;--theirs&lt;/code&gt;, &lt;code&gt;--merge&lt;/code&gt; or &lt;code&gt;--conflict&lt;/code&gt; is specified. Unmerged paths on the working tree are left alone.</source>
          <target state="translated">인덱스에서 작업 트리에서 파일을 복원 할 때이 병합되지 않은 항목과도있는 경우 작업을 중단하지 &lt;code&gt;--ours&lt;/code&gt; , &lt;code&gt;--theirs&lt;/code&gt; , &lt;code&gt;--merge&lt;/code&gt; 또는 &lt;code&gt;--conflict&lt;/code&gt; 이 지정됩니다. 작업 트리의 병합되지 않은 경로는 그대로 남아 있습니다.</target>
        </trans-unit>
        <trans-unit id="84ac309392e16a1f3dcc1a792805de1c5dea7161" translate="yes" xml:space="preserve">
          <source>When restoring files on the working tree from the index, recreate the conflicted merge in the unmerged paths.</source>
          <target state="translated">작업 트리의 파일을 인덱스에서 복원 할 때 병합되지 않은 경로에서 충돌이 발생한 병합을 다시 만듭니다.</target>
        </trans-unit>
        <trans-unit id="273a9228c51e5936f4d142f339102a2bbdd8c3b8" translate="yes" xml:space="preserve">
          <source>When retrieving svn commits into Git (as part of &lt;code&gt;fetch&lt;/code&gt;, &lt;code&gt;rebase&lt;/code&gt;, or &lt;code&gt;dcommit&lt;/code&gt; operations), look for the first &lt;code&gt;From:&lt;/code&gt; or &lt;code&gt;Signed-off-by:&lt;/code&gt; line in the log message and use that as the author string.</source>
          <target state="translated">svn 커밋을 Git으로 가져올 때 ( &lt;code&gt;fetch&lt;/code&gt; , &lt;code&gt;rebase&lt;/code&gt; 또는 &lt;code&gt;dcommit&lt;/code&gt; 작업의 일부로 ) 로그 메시지에서 첫 번째 &lt;code&gt;From:&lt;/code&gt; 또는 &lt;code&gt;Signed-off-by:&lt;/code&gt; 행을 찾아 저자 문자열로 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="78d119701beb340fc1dce20129de3c1bebaf8055" translate="yes" xml:space="preserve">
          <source>When revision range specifiers are used to limit the annotation, lines that have not changed since the range boundary (either the commit v2.6.18 or the most recent commit that is more than 3 weeks old in the above example) are blamed for that range boundary commit.</source>
          <target state="translated">수정 범위 지정자를 사용하여 주석을 제한하는 경우, 범위 경계 이후에 변경되지 않은 행 (커밋 v2.6.18 또는 위의 예에서 3 주 이상 지난 가장 최근의 커밋)은 해당 범위 경계에 대한 책임이 있습니다. 범하다.</target>
        </trans-unit>
        <trans-unit id="802f2e7848870b44ce9f04fb441477cd05447e6c" translate="yes" xml:space="preserve">
          <source>When rewriting commits with &amp;lt;command&amp;gt; (currently &lt;code&gt;amend&lt;/code&gt; or &lt;code&gt;rebase&lt;/code&gt;) and this variable is set to &lt;code&gt;true&lt;/code&gt;, Git automatically copies your notes from the original to the rewritten commit. Defaults to &lt;code&gt;true&lt;/code&gt;, but see &quot;notes.rewriteRef&quot; below.</source>
          <target state="translated">&amp;lt;command&amp;gt; (현재 &lt;code&gt;amend&lt;/code&gt; 또는 &lt;code&gt;rebase&lt;/code&gt; )로 커밋을 다시 쓰고이 변수가 &lt;code&gt;true&lt;/code&gt; 로 설정 되면 Git은 자동으로 노트를 원래의 커밋으로 다시 복사합니다. 기본값은 &lt;code&gt;true&lt;/code&gt; 이지만 아래의 &quot;notes.rewriteRef&quot;를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="b9c5c034bfc575d885230ecf217359276486be76" translate="yes" xml:space="preserve">
          <source>When rewriting commits with &amp;lt;command&amp;gt; (currently &lt;code&gt;amend&lt;/code&gt; or &lt;code&gt;rebase&lt;/code&gt;), if this variable is &lt;code&gt;false&lt;/code&gt;, git will not copy notes from the original to the rewritten commit. Defaults to &lt;code&gt;true&lt;/code&gt;. See also &quot;&lt;code&gt;notes.rewriteRef&lt;/code&gt;&quot; below.</source>
          <target state="translated">&amp;lt;command&amp;gt; (현재 &lt;code&gt;amend&lt;/code&gt; 또는 &lt;code&gt;rebase&lt;/code&gt; )로 커밋을 다시 쓸 때이 변수가 &lt;code&gt;false&lt;/code&gt; 인 경우 git은 원본에서 다시 쓴 커밋으로 노트를 복사하지 않습니다. 기본값은 &lt;code&gt;true&lt;/code&gt; 입니다. 아래의 &quot; &lt;code&gt;notes.rewriteRef&lt;/code&gt; &quot; 도 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="0528b909a801bc351dbefd46a3e339150f63bb9d" translate="yes" xml:space="preserve">
          <source>When rewriting commits, which notes to copy from the original to the rewritten commit. Must be a colon-delimited list of refs or globs.</source>
          <target state="translated">커밋을 다시 쓸 때 원본에서 다시 쓴 커밋으로 복사 할 노트입니다. 콜론으로 구분 된 심판 또는 글로브 목록이어야합니다.</target>
        </trans-unit>
        <trans-unit id="777967b1b1cbeac1b786b4e659ef472d75c08474" translate="yes" xml:space="preserve">
          <source>When run from a subdirectory of the project, it can be told to exclude changes outside the directory and show pathnames relative to it with this option. When you are not in a subdirectory (e.g. in a bare repository), you can name which subdirectory to make the output relative to by giving a &amp;lt;path&amp;gt; as an argument.</source>
          <target state="translated">프로젝트의 서브 디렉토리에서 실행될 때 디렉토리 외부의 변경 사항을 제외하고이 옵션을 사용하여 디렉토리와 관련된 경로 이름을 표시하도록 지시 할 수 있습니다. 하위 디렉토리에없는 경우 (예 : Bare Repository) &amp;lt;path&amp;gt;를 인수로 지정하여 출력을 기준으로하는 하위 디렉토리의 이름을 지정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c27ca634a7183f46a280e82c3af06c829ca10b89" translate="yes" xml:space="preserve">
          <source>When run from a subdirectory, the command usually outputs paths relative to the current directory. This option forces paths to be output relative to the project top directory.</source>
          <target state="translated">하위 디렉토리에서 실행할 때 명령은 일반적으로 현재 디렉토리에 상대적인 경로를 출력합니다. 이 옵션은 프로젝트 최상위 디렉토리를 기준으로 경로를 강제로 출력합니다.</target>
        </trans-unit>
        <trans-unit id="ed0ff11c4a5dd052209fd6d888b93db83b1003f1" translate="yes" xml:space="preserve">
          <source>When run in a directory that does not have &quot;.git&quot; repository directory, Git tries to find such a directory in the parent directories to find the top of the working tree, but by default it does not cross filesystem boundaries. This environment variable can be set to true to tell Git not to stop at filesystem boundaries. Like &lt;code&gt;GIT_CEILING_DIRECTORIES&lt;/code&gt;, this will not affect an explicit repository directory set via &lt;code&gt;GIT_DIR&lt;/code&gt; or on the command line.</source>
          <target state="translated">&quot;.git&quot;저장소 디렉토리가없는 디렉토리에서 실행될 때, Git은 부모 디렉토리에서 이러한 디렉토리를 찾아 작업 트리의 최상위를 찾으려고하지만 기본적으로 파일 시스템 경계를 넘지 않습니다. 이 환경 변수는 Git에게 파일 시스템 경계에서 멈추지 말도록 true로 설정할 수 있습니다. 마찬가지로 &lt;code&gt;GIT_CEILING_DIRECTORIES&lt;/code&gt; ,이를 통해 명시 적 저장소 디렉토리 설정에 영향을주지 않습니다 &lt;code&gt;GIT_DIR&lt;/code&gt; 또는 명령 줄을.</target>
        </trans-unit>
        <trans-unit id="9ce1b9e20fc14e8e8925879039b8daf3d52acd6a" translate="yes" xml:space="preserve">
          <source>When running the command with &lt;code&gt;-u&lt;/code&gt; and &lt;code&gt;-m&lt;/code&gt; options, the merge result may need to overwrite paths that are not tracked in the current branch. The command usually refuses to proceed with the merge to avoid losing such a path. However this safety valve sometimes gets in the way. For example, it often happens that the other branch added a file that used to be a generated file in your branch, and the safety valve triggers when you try to switch to that branch after you ran &lt;code&gt;make&lt;/code&gt; but before running &lt;code&gt;make clean&lt;/code&gt; to remove the generated file. This option tells the command to read per-directory exclude file (usually &lt;code&gt;.gitignore&lt;/code&gt;) and allows such an untracked but explicitly ignored file to be overwritten.</source>
          <target state="translated">&lt;code&gt;-u&lt;/code&gt; 및 &lt;code&gt;-m&lt;/code&gt; 옵션 과 함께 명령을 실행할 때 병합 결과는 현재 분기에서 추적되지 않은 경로를 덮어 써야 할 수 있습니다. 명령은 일반적으로 이러한 경로를 잃지 않도록 병합을 진행하지 않습니다. 그러나이 안전 밸브는 때때로 방해가됩니다. 예를 들어, 종종 그 지점에 스위치하려고 할 때 실행 한 후 다른 지점이 지점에서 생성 된 파일로 사용하는 파일 및 안전 밸브 트리거를 추가 한 일이 &lt;code&gt;make&lt;/code&gt; 하지만 실행하기 전에 &lt;code&gt;make clean&lt;/code&gt; 제거하기 위해 생성 된 파일. 이 옵션은 디렉토리 별 제외 파일 (일반적으로 &lt;code&gt;.gitignore&lt;/code&gt; ) 을 읽도록 명령에 지시하고 추적되지 않지만 명시 적으로 무시 된 파일을 덮어 쓸 수 있도록합니다.</target>
        </trans-unit>
        <trans-unit id="df426fd8f20937aff52c156a03a07b3202618140" translate="yes" xml:space="preserve">
          <source>When sending a patch this way, most often you are sending your own patch, so in addition to the &quot;&lt;code&gt;From $SHA1 $magic_timestamp&lt;/code&gt;&quot; marker you should omit &lt;code&gt;From:&lt;/code&gt; and &lt;code&gt;Date:&lt;/code&gt; lines from the patch file. The patch title is likely to be different from the subject of the discussion the patch is in response to, so it is likely that you would want to keep the Subject: line, like the example above.</source>
          <target state="translated">이런 방식으로 패치를 보낼 때 가장 자주 패치를 보내므로 &quot; &lt;code&gt;From $SHA1 $magic_timestamp&lt;/code&gt; &quot;표시 자 외에도 패치 파일에서 &lt;code&gt;From:&lt;/code&gt; 및 &lt;code&gt;Date:&lt;/code&gt; 행을 생략해야 합니다. 패치 제목은 패치에 대한 토론의 주제와 다를 수 있으므로 위의 예와 같이 Subject : 행을 유지하고 싶을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="85b26b0293721642a3d3ba409cae09a21a570f47" translate="yes" xml:space="preserve">
          <source>When set to &lt;code&gt;always&lt;/code&gt;, always highlight matches. When &lt;code&gt;false&lt;/code&gt; (or &lt;code&gt;never&lt;/code&gt;), never. When set to &lt;code&gt;true&lt;/code&gt; or &lt;code&gt;auto&lt;/code&gt;, use color only when the output is written to the terminal. If unset, then the value of &lt;code&gt;color.ui&lt;/code&gt; is used (&lt;code&gt;auto&lt;/code&gt; by default).</source>
          <target state="translated">&lt;code&gt;always&lt;/code&gt; 로 설정하면 항상 일치 항목을 강조 표시하십시오. &lt;code&gt;false&lt;/code&gt; 때 (또는 &lt;code&gt;never&lt;/code&gt; ) 절대로 &lt;code&gt;true&lt;/code&gt; 또는 &lt;code&gt;auto&lt;/code&gt; 로 설정되면 출력이 터미널에 쓰여질 때만 색상을 사용하십시오. 설정하지 않으면 &lt;code&gt;color.ui&lt;/code&gt; 의 값 이 사용됩니다 ( 기본적으로 &lt;code&gt;auto&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="dfd0a45591bf4cdb6d73f4e9b16cc039b04690be" translate="yes" xml:space="preserve">
          <source>When set to &lt;code&gt;always&lt;/code&gt;, always use colors for interactive prompts and displays (such as those used by &quot;git-add --interactive&quot; and &quot;git-clean --interactive&quot;). When false (or &lt;code&gt;never&lt;/code&gt;), never. When set to &lt;code&gt;true&lt;/code&gt; or &lt;code&gt;auto&lt;/code&gt;, use colors only when the output is to the terminal. If unset, then the value of &lt;code&gt;color.ui&lt;/code&gt; is used (&lt;code&gt;auto&lt;/code&gt; by default).</source>
          <target state="translated">&lt;code&gt;always&lt;/code&gt; 로 설정되면 대화 형 프롬프트 및 디스플레이에 항상 색상을 사용하십시오 (예 : &quot;git-add --interactive&quot;및 &quot;git-clean --interactive&quot;에 사용되는 색상). 거짓 일 때 (또는 &lt;code&gt;never&lt;/code&gt; ) 절대로 &lt;code&gt;true&lt;/code&gt; 또는 &lt;code&gt;auto&lt;/code&gt; 로 설정되면 출력이 터미널에있을 때만 색상을 사용하십시오. 설정하지 않으면 &lt;code&gt;color.ui&lt;/code&gt; 의 값 이 사용됩니다 ( 기본적으로 &lt;code&gt;auto&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="9ba7d00c9f4d532d2b9486b8c87259ed84e278f3" translate="yes" xml:space="preserve">
          <source>When set to &lt;code&gt;change&lt;/code&gt;, tells &lt;code&gt;git apply&lt;/code&gt; to ignore changes in whitespace, in the same way as the &lt;code&gt;--ignore-space-change&lt;/code&gt; option. When set to one of: no, none, never, false tells &lt;code&gt;git apply&lt;/code&gt; to respect all whitespace differences. See &lt;a href=&quot;git-apply&quot;&gt;git-apply[1]&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;change&lt;/code&gt; 로 설정 하면 &lt;code&gt;--ignore-space-change&lt;/code&gt; 옵션 과 같은 방식으로 &lt;code&gt;git apply&lt;/code&gt; 가 공백 변경을 무시하도록 지시 합니다. no, none, never 중 하나로 설정되면 &lt;code&gt;git apply&lt;/code&gt; 모든 공백 차이를 존중하도록 git에 지시 합니다. &lt;a href=&quot;git-apply&quot;&gt;git-apply [1]을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="8d6e4c3c7b2c6d56efae11b1e0ed0dcb5ce2357b" translate="yes" xml:space="preserve">
          <source>When set to &lt;code&gt;merges&lt;/code&gt;, rebase using &lt;code&gt;git rebase --rebase-merges&lt;/code&gt; so that the local merge commits are included in the rebase (see &lt;a href=&quot;git-rebase&quot;&gt;git-rebase[1]&lt;/a&gt; for details).</source>
          <target state="translated">로 설정하면 &lt;code&gt;merges&lt;/code&gt; 사용 리베이스 &lt;code&gt;git rebase --rebase-merges&lt;/code&gt; 그래서 로컬 병합 커밋이 REBASE에 포함되어 있는지 (참조 &lt;a href=&quot;git-rebase&quot;&gt;자식-REBASE [1]&lt;/a&gt; 세부 사항 참조).</target>
        </trans-unit>
        <trans-unit id="3726def44fed6d7863a8f10abeef80361e6f2701" translate="yes" xml:space="preserve">
          <source>When set to &lt;code&gt;preserve&lt;/code&gt; (deprecated in favor of &lt;code&gt;merges&lt;/code&gt;), rebase with the &lt;code&gt;--preserve-merges&lt;/code&gt; option passed to &lt;code&gt;git rebase&lt;/code&gt; so that locally created merge commits will not be flattened.</source>
          <target state="translated">&lt;code&gt;preserve&lt;/code&gt; 하도록 설정하면 ( &lt;code&gt;merges&lt;/code&gt; 를 위해 더 이상 사용되지 않음 ) &lt;code&gt;--preserve-merges&lt;/code&gt; 옵션을 사용하여 &lt;code&gt;git rebase&lt;/code&gt; 를 git rebase로 전달하면 로컬로 생성 된 병합 커밋이 병합되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="14ded32327ec4343589fd7082ddc1f7fdc8962f6" translate="yes" xml:space="preserve">
          <source>When set to true, &lt;code&gt;git reset&lt;/code&gt; will default to the &lt;code&gt;--quiet&lt;/code&gt; option.</source>
          <target state="translated">true로 설정하면 &lt;code&gt;git reset&lt;/code&gt; 은 &lt;code&gt;--quiet&lt;/code&gt; 옵션 으로 기본 설정 됩니다 .</target>
        </trans-unit>
        <trans-unit id="01f095efe30e9d32fee48e094d88f96d4eba1bad" translate="yes" xml:space="preserve">
          <source>When set to true, &lt;code&gt;git-rerere&lt;/code&gt; updates the index with the resulting contents after it cleanly resolves conflicts using previously recorded resolution. Defaults to false.</source>
          <target state="translated">true로 설정하면 &lt;code&gt;git-rerere&lt;/code&gt; 는 이전에 기록 된 해상도를 사용하여 충돌을 완전히 해결 한 후 결과 내용으로 색인을 업데이트합니다. 기본값은 false입니다.</target>
        </trans-unit>
        <trans-unit id="e2cc234f1ab166d2852bd6878a576806a19d5021" translate="yes" xml:space="preserve">
          <source>When set to true, a clone of this submodule will be performed as a shallow clone (with a history depth of 1) unless the user explicitly asks for a non-shallow clone.</source>
          <target state="translated">true로 설정되면 사용자가 명시 적으로 얕은 클론을 요청하지 않는 한이 서브 모듈의 복제는 얕은 복제본 (이력 깊이가 1 인)으로 수행됩니다.</target>
        </trans-unit>
        <trans-unit id="c92df8026c7e3a5d595e452302b48399c0fa7807" translate="yes" xml:space="preserve">
          <source>When set to true, automatically create a temporary stash entry before the operation begins, and apply it after the operation ends. This means that you can run rebase on a dirty worktree. However, use with care: the final stash application after a successful rebase might result in non-trivial conflicts. This option can be overridden by the &lt;code&gt;--no-autostash&lt;/code&gt; and &lt;code&gt;--autostash&lt;/code&gt; options of &lt;a href=&quot;git-rebase&quot;&gt;git-rebase[1]&lt;/a&gt;. Defaults to false.</source>
          <target state="translated">true로 설정하면 작업이 시작되기 전에 임시 숨김 항목을 자동으로 생성하고 작업이 끝난 후에 적용합니다. 이는 더티 작업 트리에서 리베이스를 실행할 수 있음을 의미합니다. 그러나주의해서 사용하십시오. 리베이스에 성공한 후 마지막 숨김 응용 프로그램은 사소한 충돌을 초래할 수 있습니다. 이 옵션 은 &lt;a href=&quot;git-rebase&quot;&gt;git-rebase [1]&lt;/a&gt; 의 &lt;code&gt;--no-autostash&lt;/code&gt; 및 &lt;code&gt;--autostash&lt;/code&gt; 옵션 으로 재정의 할 수 있습니다 . 기본값은 false입니다.</target>
        </trans-unit>
        <trans-unit id="454e58d95a3a4a743aeef0859eac2b9c78e6f07a" translate="yes" xml:space="preserve">
          <source>When set to true, fetching from this remote by default will also remove any local tags that no longer exist on the remote if pruning is activated in general via &lt;code&gt;remote.&amp;lt;name&amp;gt;.prune&lt;/code&gt;, &lt;code&gt;fetch.prune&lt;/code&gt; or &lt;code&gt;--prune&lt;/code&gt;. Overrides &lt;code&gt;fetch.pruneTags&lt;/code&gt; settings, if any.</source>
          <target state="translated">true로 설정하면 기본적으로이 원격에서 가져 오면 정리가 일반적으로 &lt;code&gt;remote.&amp;lt;name&amp;gt;.prune&lt;/code&gt; , &lt;code&gt;fetch.prune&lt;/code&gt; 또는 &lt;code&gt;--prune&lt;/code&gt; 을 통해 활성화되면 원격에 더 이상 존재하지 않는 로컬 태그도 제거됩니다 . &lt;code&gt;fetch.pruneTags&lt;/code&gt; 설정을 재정의 합니다 (있는 경우).</target>
        </trans-unit>
        <trans-unit id="2f08cdfbf2bbbb5ba49961d7515ae4f7f92a166e" translate="yes" xml:space="preserve">
          <source>When set to true, fetching from this remote by default will also remove any remote-tracking references that no longer exist on the remote (as if the &lt;code&gt;--prune&lt;/code&gt; option was given on the command line). Overrides &lt;code&gt;fetch.prune&lt;/code&gt; settings, if any.</source>
          <target state="translated">true로 설정하면 기본적으로이 원격 장치에서 가져 오면 원격에 더 이상 존재하지 않는 원격 추적 참조도 제거됩니다 ( &lt;code&gt;--prune&lt;/code&gt; 옵션이 명령 줄에 지정된 것처럼 ). &lt;code&gt;fetch.prune&lt;/code&gt; 설정을 재정의 합니다 (있는 경우).</target>
        </trans-unit>
        <trans-unit id="5739477a3b9489a88899be9378f898520709209f" translate="yes" xml:space="preserve">
          <source>When set to true, git-receive-pack will advertise the push options capability to its clients. False by default.</source>
          <target state="translated">true로 설정하면 git-receive-pack은 푸시 옵션 기능을 클라이언트에게 알립니다. 기본적으로 False입니다.</target>
        </trans-unit>
        <trans-unit id="af12eb66ec26d00e256f0fbfcc7125aeb108aa2e" translate="yes" xml:space="preserve">
          <source>When set to true, this remote will be used to fetch promisor objects.</source>
          <target state="translated">true로 설정하면이 리모콘을 사용하여 약속 개체를 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="384788e82f8977bea09d8463e5bbfca26ec8a699" translate="yes" xml:space="preserve">
          <source>When set, the fetch or receive will abort in the case of a malformed object or a link to a nonexistent object. In addition, various other issues are checked for, including legacy issues (see &lt;code&gt;fsck.&amp;lt;msg-id&amp;gt;&lt;/code&gt;), and potential security issues like the existence of a &lt;code&gt;.GIT&lt;/code&gt; directory or a malicious &lt;code&gt;.gitmodules&lt;/code&gt; file (see the release notes for v2.2.1 and v2.17.1 for details). Other sanity and security checks may be added in future releases.</source>
          <target state="translated">설정하면, 잘못된 오브젝트 또는 존재하지 않는 오브젝트에 대한 링크의 경우 페치 또는 수신이 중단됩니다. 또한, 다양한 다른 문제는 기존의 문제 (참조를 포함하여 검사하는 &lt;code&gt;fsck.&amp;lt;msg-id&amp;gt;&lt;/code&gt; ), 그리고의 존재와 같은 잠재적 인 보안 문제 &lt;code&gt;.GIT&lt;/code&gt; 의 디렉토리 또는 악의적 인 &lt;code&gt;.gitmodules&lt;/code&gt; 의 파일 (v2의 릴리스 노트를 참조하십시오. 자세한 내용은 2.1 및 v2.17.1). 다른 안전성 및 보안 검사는 향후 릴리스에서 추가 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="51a9809b150b3fa600feb6c1ea57e78e8de9e787" translate="yes" xml:space="preserve">
          <source>When showing &lt;code&gt;short&lt;/code&gt; or &lt;code&gt;porcelain&lt;/code&gt; status output, print the filename verbatim and terminate the entries with NUL, instead of LF. If no format is given, implies the &lt;code&gt;--porcelain&lt;/code&gt; output format. Without the &lt;code&gt;-z&lt;/code&gt; option, filenames with &quot;unusual&quot; characters are quoted as explained for the configuration variable &lt;code&gt;core.quotePath&lt;/code&gt; (see &lt;a href=&quot;git-config&quot;&gt;git-config[1]&lt;/a&gt;).</source>
          <target state="translated">도시 때 &lt;code&gt;short&lt;/code&gt; 이나 &lt;code&gt;porcelain&lt;/code&gt; 상태 출력을, LF 대신에, 축어 파일명 인쇄 NUL과 같이 종료. 형식이 지정되지 않으면 &lt;code&gt;--porcelain&lt;/code&gt; 출력 형식을 나타냅니다. &lt;code&gt;-z&lt;/code&gt; 옵션이 없으면 구성 변수 &lt;code&gt;core.quotePath&lt;/code&gt; 에 설명 된대로 &quot;비정상적인&quot;문자가 포함 된 파일 이름이 인용됩니다 ( &lt;a href=&quot;git-config&quot;&gt;git-config [1] 참조&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="43f2e6f1690661b84f31283fe1b400a9df885029" translate="yes" xml:space="preserve">
          <source>When showing a change that involves a rename or a copy, &lt;code&gt;--stat&lt;/code&gt; output formats the pathnames compactly by combining common prefix and suffix of the pathnames. For example, a change that moves &lt;code&gt;arch/i386/Makefile&lt;/code&gt; to &lt;code&gt;arch/x86/Makefile&lt;/code&gt; while modifying 4 lines will be shown like this:</source>
          <target state="translated">이름 바꾸기 또는 사본과 관련된 변경 사항을 표시 할 때 &lt;code&gt;--stat&lt;/code&gt; 출력은 경로 이름의 공통 접두사와 접미사를 결합하여 경로 이름을 압축합니다. 예를 들어, 4 줄을 수정하는 동안 &lt;code&gt;arch/i386/Makefile&lt;/code&gt; 을 &lt;code&gt;arch/x86/Makefile&lt;/code&gt; 로 이동하는 변경 사항은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="5d4332d6cfe825bd00a3bfef76e9ffde728a5dde" translate="yes" xml:space="preserve">
          <source>When showing commit messages, also show notes which are stored in the given ref. The ref must be fully qualified. If the given ref does not exist, it is not an error but means that no notes should be printed.</source>
          <target state="translated">커밋 메시지를 표시 할 때 주어진 참조에 저장된 노트도 표시합니다. 심판은 정규화되어야합니다. 주어진 심판이 존재하지 않는다면, 그것은 오류가 아니지만 노트가 인쇄되지 않아야 함을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="43020b05da28d5245a5572e708a459c7bb4d40bf" translate="yes" xml:space="preserve">
          <source>When showing object names, prefix them with &lt;code&gt;^&lt;/code&gt; and strip &lt;code&gt;^&lt;/code&gt; prefix from the object names that already have one.</source>
          <target state="translated">개체 이름을 표시 할 때, 그들을 앞에 &lt;code&gt;^&lt;/code&gt; 스트립 &lt;code&gt;^&lt;/code&gt; 개체 이름에서 접두어 이미 하나를 가지고 그.</target>
        </trans-unit>
        <trans-unit id="bf158ec030a04af48fd84ff99f4cdef61dbc802c" translate="yes" xml:space="preserve">
          <source>When showing the value of &amp;lt;name&amp;gt; as a symbolic ref, try to shorten the value, e.g. from &lt;code&gt;refs/heads/master&lt;/code&gt; to &lt;code&gt;master&lt;/code&gt;.</source>
          <target state="translated">&amp;lt;name&amp;gt;의 값을 기호 참조로 표시 할 때 값을 줄이십시오 (예 : &lt;code&gt;refs/heads/master&lt;/code&gt; 에서 &lt;code&gt;master&lt;/code&gt; 로) .</target>
        </trans-unit>
        <trans-unit id="d07871fea9de7a0886062f3dfa8bbc506d97b667" translate="yes" xml:space="preserve">
          <source>When shown by &lt;code&gt;git diff-tree -c&lt;/code&gt;, it compares the parents of a merge commit with the merge result (i.e. file1..fileN are the parents). When shown by &lt;code&gt;git diff-files -c&lt;/code&gt;, it compares the two unresolved merge parents with the working tree file (i.e. file1 is stage 2 aka &quot;our version&quot;, file2 is stage 3 aka &quot;their version&quot;).</source>
          <target state="translated">&lt;code&gt;git diff-tree -c&lt;/code&gt; 로 표시되면 병합 커밋의 부모를 병합 결과와 비교합니다 (즉, file1..fileN은 부모입니다). 로 표시하면 &lt;code&gt;git diff-files -c&lt;/code&gt; , 그것은 (파일 2 일명 3 단계 &quot;자신의 버전&quot;입니다, 즉 파일 1 일명 2 단계 &quot;우리의 버전&quot;입니다) 작업 트리 파일과 함께이 해결되지 않은 병합 부모를 비교합니다.</target>
        </trans-unit>
        <trans-unit id="aea42e2933202e5e3d5f69076d6bebeb378dfcd9" translate="yes" xml:space="preserve">
          <source>When some commits have been skipped (using &quot;git bisect skip&quot;), then the bisection algorithm is the same for step 1) to 3). But then we use roughly the following steps:</source>
          <target state="translated">일부 커밋을 건너 뛴 경우 ( &quot;git bisect skip&quot;사용) 이분법 알고리즘은 1 단계와 동일) ~ 3). 그러나 우리는 대략 다음 단계를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="4192528671a22eca45fcad6bb5614a7ec165a5d4" translate="yes" xml:space="preserve">
          <source>When specified one or more times, &lt;code&gt;-L&lt;/code&gt; restricts annotation to the requested lines.</source>
          <target state="translated">한 번 이상 지정된 경우 &lt;code&gt;-L&lt;/code&gt; 은 주석을 요청 된 행으로 제한합니다.</target>
        </trans-unit>
        <trans-unit id="75acd7ee44b0e77c6b233d3615dca447d4cfdc8c" translate="yes" xml:space="preserve">
          <source>When specifying the -v option the format used is:</source>
          <target state="translated">-v 옵션을 지정할 때 사용되는 형식은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="0550af8039db48de114d18431bb7375cee83b91b" translate="yes" xml:space="preserve">
          <source>When switching branches with &lt;code&gt;--merge&lt;/code&gt;, staged changes may be lost.</source>
          <target state="translated">&lt;code&gt;--merge&lt;/code&gt; 를 사용 하여 분기를 전환하면 단계적 변경 내용이 손실 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1f4fa4b7e00510c39cb24519dad3b49f07cff89d" translate="yes" xml:space="preserve">
          <source>When switching branches, if you have local modifications to one or more files that are different between the current branch and the branch to which you are switching, the command refuses to switch branches in order to preserve your modifications in context. However, with this option, a three-way merge between the current branch, your working tree contents, and the new branch is done, and you will be on the new branch.</source>
          <target state="translated">분기를 전환 할 때 현재 분기와 전환중인 분기간에 다른 하나 이상의 파일을 로컬로 수정 한 경우 명령은 컨텍스트에서 수정 사항을 보존하기 위해 분기 전환을 거부합니다. 그러나이 옵션을 사용하면 현재 분기, 작업 트리 내용 및 새 분기간에 3 방향 병합이 수행되고 새 분기에있게됩니다.</target>
        </trans-unit>
        <trans-unit id="7b0d58bb9103d272bfd260e85d337e6780ed225d" translate="yes" xml:space="preserve">
          <source>When switching branches, proceed even if the index or the working tree differs from &lt;code&gt;HEAD&lt;/code&gt;. This is used to throw away local changes.</source>
          <target state="translated">분기를 전환 할 때 색인 또는 작업 트리가 &lt;code&gt;HEAD&lt;/code&gt; 와 다른 경우에도 진행하십시오 . 로컬 변경 사항을 버리는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="c0e1144ec53aca779c8724f81a0ba0a804f51a81" translate="yes" xml:space="preserve">
          <source>When the &quot;-C&quot; option is used, the original contents of modified files, and deleted files (and also unmodified files, if the &quot;--find-copies-harder&quot; option is used) are considered as candidates of the source files in rename/copy operation. If the input were like these filepairs, that talk about a modified file fileY and a newly created file file0:</source>
          <target state="translated">&quot;-C&quot;옵션을 사용하면 수정 된 파일의 원래 내용과 삭제 된 파일 (및 &quot;--find-copies-harder&quot;옵션을 사용하는 경우 수정되지 않은 파일)도 소스 파일의 후보로 간주됩니다. 이름 바꾸기 / 복사 작업. 입력이 이러한 파일 쌍과 같은 경우 수정 된 파일 fileY 및 새로 작성된 파일 file0에 대해 설명합니다.</target>
        </trans-unit>
        <trans-unit id="f6565c60ff0e235a6b049473d40ff8e72074a702" translate="yes" xml:space="preserve">
          <source>When the &lt;code&gt;&amp;lt;commit&amp;gt;&lt;/code&gt; argument is a branch name, the &lt;code&gt;--detach&lt;/code&gt; option can be used to detach &lt;code&gt;HEAD&lt;/code&gt; at the tip of the branch (&lt;code&gt;git checkout
&amp;lt;branch&amp;gt;&lt;/code&gt; would check out that branch without detaching &lt;code&gt;HEAD&lt;/code&gt;).</source>
          <target state="translated">때 &lt;code&gt;&amp;lt;commit&amp;gt;&lt;/code&gt; 인수가 지점 이름의 &lt;code&gt;--detach&lt;/code&gt; 옵션을 분리하는 데 사용할 수 있습니다 &lt;code&gt;HEAD&lt;/code&gt; 분기의 끝에서 ( &lt;code&gt;git checkout &amp;lt;branch&amp;gt;&lt;/code&gt; 분리하지 않고 해당 분기 체크 아웃 할 &lt;code&gt;HEAD&lt;/code&gt; 를 ).</target>
        </trans-unit>
        <trans-unit id="588cf4af82a088b4d8241fca9de08188511b35c3" translate="yes" xml:space="preserve">
          <source>When the &lt;code&gt;--aggressive&lt;/code&gt; option is supplied, &lt;a href=&quot;git-repack&quot;&gt;git-repack[1]&lt;/a&gt; will be invoked with the &lt;code&gt;-f&lt;/code&gt; flag, which in turn will pass &lt;code&gt;--no-reuse-delta&lt;/code&gt; to &lt;a href=&quot;git-pack-objects&quot;&gt;git-pack-objects[1]&lt;/a&gt;. This will throw away any existing deltas and re-compute them, at the expense of spending much more time on the repacking.</source>
          <target state="translated">때 &lt;code&gt;--aggressive&lt;/code&gt; 옵션이 제공되며, &lt;a href=&quot;git-repack&quot;&gt;자식 - 재 포장 [1]&lt;/a&gt; 호출한다 &lt;code&gt;-f&lt;/code&gt; 차례로 통과 할 플래그 &lt;code&gt;--no-reuse-delta&lt;/code&gt; 로 &lt;a href=&quot;git-pack-objects&quot;&gt;자식 팩 - 오브젝트 [1]&lt;/a&gt; . 이렇게하면 기존 델타를 버리고 재 포장에 훨씬 더 많은 시간을 소비하면서 재 계산할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="82879b1b4c41ea78abef977470f6f223214f239a" translate="yes" xml:space="preserve">
          <source>When the &lt;code&gt;--stdin&lt;/code&gt; option is provided, the patterns are read from standard in as a newline-delimited list instead of from the arguments.</source>
          <target state="translated">때 &lt;code&gt;--stdin&lt;/code&gt; 옵션 옵션이 제공되면, 패턴의 개행 문자로 분리 된 목록으로 대신 인수에서 표준에서 읽습니다.</target>
        </trans-unit>
        <trans-unit id="0e72b560677fc7dbf879d4b64bab949efbe4ffc6" translate="yes" xml:space="preserve">
          <source>When the &lt;code&gt;-l&lt;/code&gt; option is used, format changes to</source>
          <target state="translated">때 &lt;code&gt;-l&lt;/code&gt; 옵션을 사용, 형식으로 변경</target>
        </trans-unit>
        <trans-unit id="2d7535050bbd171bed81a20302444843893d883d" translate="yes" xml:space="preserve">
          <source>When the &lt;code&gt;-z&lt;/code&gt; option is given, pathnames are printed as is and without any quoting and lines are terminated with a NUL (ASCII 0x00) byte.</source>
          <target state="translated">때 &lt;code&gt;-z&lt;/code&gt; 옵션이 주어, 경로 이름은 그대로 인쇄하고 인용하고 라인이 NUL 종료된다 (ASCII &amp;times; 00) 바이트 않고있다.</target>
        </trans-unit>
        <trans-unit id="e231e06fa3f3b3606e814466b6e12bf27e65315d" translate="yes" xml:space="preserve">
          <source>When the &lt;code&gt;.gitattributes&lt;/code&gt; file is missing from the work tree, the path in the index is used as a fall-back. During checkout process, &lt;code&gt;.gitattributes&lt;/code&gt; in the index is used and then the file in the working tree is used as a fall-back.</source>
          <target state="translated">때 &lt;code&gt;.gitattributes&lt;/code&gt; 의 파일이 작업 트리에서 누락 된 인덱스의 경로는 가을 백으로 사용됩니다. 체크 아웃 프로세스 중에 인덱스의 &lt;code&gt;.gitattributes&lt;/code&gt; 가 사용 된 다음 작업 트리의 파일이 폴백으로 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="ca6fe469ff13b0a4412dea9bd34db705e00a71db" translate="yes" xml:space="preserve">
          <source>When the &lt;code&gt;LESS&lt;/code&gt; environment variable is unset, Git sets it to &lt;code&gt;FRX&lt;/code&gt; (if &lt;code&gt;LESS&lt;/code&gt; environment variable is set, Git does not change it at all). If you want to selectively override Git&amp;rsquo;s default setting for &lt;code&gt;LESS&lt;/code&gt;, you can set &lt;code&gt;core.pager&lt;/code&gt; to e.g. &lt;code&gt;less -S&lt;/code&gt;. This will be passed to the shell by Git, which will translate the final command to &lt;code&gt;LESS=FRX less -S&lt;/code&gt;. The environment does not set the &lt;code&gt;S&lt;/code&gt; option but the command line does, instructing less to truncate long lines. Similarly, setting &lt;code&gt;core.pager&lt;/code&gt; to &lt;code&gt;less -+F&lt;/code&gt; will deactivate the &lt;code&gt;F&lt;/code&gt; option specified by the environment from the command-line, deactivating the &quot;quit if one screen&quot; behavior of &lt;code&gt;less&lt;/code&gt;. One can specifically activate some flags for particular commands: for example, setting &lt;code&gt;pager.blame&lt;/code&gt; to &lt;code&gt;less -S&lt;/code&gt; enables line truncation only for &lt;code&gt;git blame&lt;/code&gt;.</source>
          <target state="translated">때 &lt;code&gt;LESS&lt;/code&gt; 환경 변수를 설정하고, 힘내로 설정 &lt;code&gt;FRX&lt;/code&gt; (경우 &lt;code&gt;LESS&lt;/code&gt; 의 환경 변수 설정, 힘내 전혀 변경하지 않음). &lt;code&gt;LESS&lt;/code&gt; 에 대한 Git의 기본 설정을 선택적으로 무시 하려면 &lt;code&gt;core.pager&lt;/code&gt; 를 예를 들어 &lt;code&gt;less -S&lt;/code&gt; 로 설정할 수 있습니다 . 이것은 Git에 의해 쉘로 전달되며 최종 명령은 &lt;code&gt;LESS=FRX less -S&lt;/code&gt; 로 변환 됩니다. 환경은 &lt;code&gt;S&lt;/code&gt; 옵션을 설정하지 않지만 명령 행은 긴 행을 자르도록 지시합니다. 마찬가지로, 설정 &lt;code&gt;core.pager&lt;/code&gt; 을 에 &lt;code&gt;less -+F&lt;/code&gt; 비활성화됩니다 &lt;code&gt;F&lt;/code&gt; 를명령 줄에서 환경에 의해 지정된 옵션을 사용하여 &lt;code&gt;less&lt;/code&gt; 의 &quot;한 화면 만 종료&quot;동작을 비활성화하십시오 . 특정 명령에 대해 일부 플래그를 구체적으로 활성화 할 수 있습니다. 예를 들어 &lt;code&gt;pager.blame&lt;/code&gt; 을 &lt;code&gt;less -S&lt;/code&gt; 로 설정 하면 &lt;code&gt;git blame&lt;/code&gt; 에 대해서만 줄 잘림이 가능합니다 .</target>
        </trans-unit>
        <trans-unit id="74ad9f83ee4c2323b6a50919a4a444bb844e349c" translate="yes" xml:space="preserve">
          <source>When the &lt;code&gt;core.fsmonitor&lt;/code&gt; configuration variable is changed, the file system monitor is added to or removed from the index the next time a command reads the index. When &lt;code&gt;--[no-]fsmonitor&lt;/code&gt; are used, the file system monitor is immediately added to or removed from the index.</source>
          <target state="translated">때 &lt;code&gt;core.fsmonitor&lt;/code&gt; 의 구성 변수 변경, 파일 시스템 모니터는 인덱스에서 명령 인덱스를 판독 다음번에 추가되거나 제거된다. 시 &lt;code&gt;--[no-]fsmonitor&lt;/code&gt; 사용되고, 파일 시스템 모니터 즉시 추가 또는 인덱스로부터 제거된다.</target>
        </trans-unit>
        <trans-unit id="a4c9cc7c80e5659747cb4b3bf0914ba1addde698" translate="yes" xml:space="preserve">
          <source>When the &lt;code&gt;core.untrackedCache&lt;/code&gt; configuration variable is changed, the untracked cache is added to or removed from the index the next time a command reads the index; while when &lt;code&gt;--[no-|force-]untracked-cache&lt;/code&gt; are used, the untracked cache is immediately added to or removed from the index.</source>
          <target state="translated">때 &lt;code&gt;core.untrackedCache&lt;/code&gt; 의 구성 변수 변경의 추적 된 캐시 인덱스의 명령은 인덱스를 읽어 다음 번에 첨가되거나 제거; 반면 때 &lt;code&gt;--[no-|force-]untracked-cache&lt;/code&gt; 사용하는 상기 추적 된 캐시에 즉시 첨가 또는 인덱스로부터 제거.</target>
        </trans-unit>
        <trans-unit id="a212ca612f0b7b9b082dffe71078dd396d414402" translate="yes" xml:space="preserve">
          <source>When the attribute &lt;code&gt;ident&lt;/code&gt; is set for a path, Git replaces &lt;code&gt;$Id$&lt;/code&gt; in the blob object with &lt;code&gt;$Id:&lt;/code&gt;, followed by the 40-character hexadecimal blob object name, followed by a dollar sign &lt;code&gt;$&lt;/code&gt; upon checkout. Any byte sequence that begins with &lt;code&gt;$Id:&lt;/code&gt; and ends with &lt;code&gt;$&lt;/code&gt; in the worktree file is replaced with &lt;code&gt;$Id$&lt;/code&gt; upon check-in.</source>
          <target state="translated">속성 &lt;code&gt;ident&lt;/code&gt; 가 경로에 대해 설정되면 Git은 blob 객체의 &lt;code&gt;$Id$&lt;/code&gt; 를 &lt;code&gt;$Id:&lt;/code&gt; 바꾸고 , 그 뒤에 40 자 16 진 blob 객체 이름, 체크 아웃시 달러 기호 &lt;code&gt;$&lt;/code&gt; 를 차례로 바꿉니다 . 모든 바이트로 시작 순서 &lt;code&gt;$Id:&lt;/code&gt; 와 끝 &lt;code&gt;$&lt;/code&gt; worktree 파일로 대체됩니다 &lt;code&gt;$Id$&lt;/code&gt; 체크인시.</target>
        </trans-unit>
        <trans-unit id="fa514f01de77ed627378917f2aa0b40cefa8c9a0" translate="yes" xml:space="preserve">
          <source>When the command enters the interactive mode, it shows the files and directories to be cleaned, and goes into its interactive command loop.</source>
          <target state="translated">명령이 대화식 모드로 들어가면 정리할 파일 및 디렉토리가 표시되고 대화식 명령 루프로 이동합니다.</target>
        </trans-unit>
        <trans-unit id="8e767c7023b00ca52d4fb770ab49ce4dc284f987" translate="yes" xml:space="preserve">
          <source>When the command enters the interactive mode, it shows the output of the &lt;code&gt;status&lt;/code&gt; subcommand, and then goes into its interactive command loop.</source>
          <target state="translated">명령이 대화식 모드로 들어가면 &lt;code&gt;status&lt;/code&gt; 부속 명령 의 출력 이 표시되고 대화식 명령 루프로 들어갑니다.</target>
        </trans-unit>
        <trans-unit id="e95952399796aad65deb415e39c303153d01cdf9" translate="yes" xml:space="preserve">
          <source>When the command is invoked from a subdirectory, show the path of the current directory relative to the top-level directory.</source>
          <target state="translated">하위 디렉토리에서 명령을 호출하면 최상위 디렉토리를 기준으로 현재 디렉토리의 경로를 표시하십시오.</target>
        </trans-unit>
        <trans-unit id="45506eccf72696bf6e0287a6eeda327142bb0f41" translate="yes" xml:space="preserve">
          <source>When the command is invoked from a subdirectory, show the path of the top-level directory relative to the current directory (typically a sequence of &quot;../&quot;, or an empty string).</source>
          <target state="translated">하위 디렉토리에서 명령을 호출 할 때 현재 디렉토리 (일반적으로 &quot;../&quot;시퀀스 또는 빈 문자열)를 기준으로 최상위 디렉토리의 경로를 표시하십시오.</target>
        </trans-unit>
        <trans-unit id="609d76b7287e730d5e5fcae1b57a1cde4d02d1ae" translate="yes" xml:space="preserve">
          <source>When the command is run without pathspec, it errors out, instead of deinit-ing everything, to prevent mistakes.</source>
          <target state="translated">pathspec없이 명령을 실행하면 실수를 방지하기 위해 모든 것을 초기화하는 대신 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="2ebded60d45ed8776b0324d8d2138df90f552a15" translate="yes" xml:space="preserve">
          <source>When the command line does not specify what to push with &lt;code&gt;&amp;lt;refspec&amp;gt;...&lt;/code&gt; arguments or &lt;code&gt;--all&lt;/code&gt;, &lt;code&gt;--mirror&lt;/code&gt;, &lt;code&gt;--tags&lt;/code&gt; options, the command finds the default &lt;code&gt;&amp;lt;refspec&amp;gt;&lt;/code&gt; by consulting &lt;code&gt;remote.*.push&lt;/code&gt; configuration, and if it is not found, honors &lt;code&gt;push.default&lt;/code&gt; configuration to decide what to push (See &lt;a href=&quot;git-config&quot;&gt;git-config[1]&lt;/a&gt; for the meaning of &lt;code&gt;push.default&lt;/code&gt;).</source>
          <target state="translated">명령 행에서 &lt;code&gt;&amp;lt;refspec&amp;gt;...&lt;/code&gt; 인수 또는 &lt;code&gt;--all&lt;/code&gt; , &lt;code&gt;--mirror&lt;/code&gt; , &lt;code&gt;--tags&lt;/code&gt; 옵션 으로 푸시 할 내용을 지정하지 않으면 명령은 &lt;code&gt;remote.*.push&lt;/code&gt; 구성 을 참조 하여 기본 &lt;code&gt;&amp;lt;refspec&amp;gt;&lt;/code&gt; 을 찾습니다 . 찾을 수없는 경우 &lt;code&gt;push.default&lt;/code&gt; 구성을 준수 하여 푸시 대상을 결정합니다 ( &lt;code&gt;push.default&lt;/code&gt; 의 의미는 &lt;a href=&quot;git-config&quot;&gt;git-config [1]&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="4f61ade639e58b8586884fe92cb9eea816606ac2" translate="yes" xml:space="preserve">
          <source>When the command line does not specify where to push with the &lt;code&gt;&amp;lt;repository&amp;gt;&lt;/code&gt; argument, &lt;code&gt;branch.*.remote&lt;/code&gt; configuration for the current branch is consulted to determine where to push. If the configuration is missing, it defaults to &lt;code&gt;origin&lt;/code&gt;.</source>
          <target state="translated">명령 행이 &lt;code&gt;&amp;lt;repository&amp;gt;&lt;/code&gt; 인수 로 푸시 할 위치를 지정하지 않으면 푸시 할 위치를 결정하기 위해 현재 분기에 대한 &lt;code&gt;branch.*.remote&lt;/code&gt; 구성을 참조합니다. 구성이 누락되면 기본값은 &lt;code&gt;origin&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="4dd963bd8e58b7ff2b11f8f622df35ecbcf28d58" translate="yes" xml:space="preserve">
          <source>When the commit diffs differ, &lt;code&gt;git range-diff&lt;/code&gt; recreates the original diffs' coloring, and adds outer -/+ diff markers with the &lt;strong&gt;background&lt;/strong&gt; being red/green to make it easier to see e.g. when there was a change in what exact lines were added.</source>
          <target state="translated">커밋 차이가 다르면 &lt;code&gt;git range-diff&lt;/code&gt; 는 원래 diff의 채색을 재현하고 &lt;strong&gt;배경&lt;/strong&gt; 이 빨간색 / 녹색 인 외부-/ + diff 마커를 추가하여 정확한 행이 추가 된 변경 사항이있을 때 더 쉽게 볼 수 있도록합니다. .</target>
        </trans-unit>
        <trans-unit id="3625aba84b870871330cdfd48d8779c4e4badb58" translate="yes" xml:space="preserve">
          <source>When the commit log message begins with &quot;squash! &amp;hellip;​&quot; (or &quot;fixup! &amp;hellip;​&quot;), and there is already a commit in the todo list that matches the same &lt;code&gt;...&lt;/code&gt;, automatically modify the todo list of rebase -i so that the commit marked for squashing comes right after the commit to be modified, and change the action of the moved commit from &lt;code&gt;pick&lt;/code&gt; to &lt;code&gt;squash&lt;/code&gt; (or &lt;code&gt;fixup&lt;/code&gt;). A commit matches the &lt;code&gt;...&lt;/code&gt; if the commit subject matches, or if the &lt;code&gt;...&lt;/code&gt; refers to the commit&amp;rsquo;s hash. As a fall-back, partial matches of the commit subject work, too. The recommended way to create fixup/squash commits is by using the &lt;code&gt;--fixup&lt;/code&gt;/&lt;code&gt;--squash&lt;/code&gt; options of &lt;a href=&quot;git-commit&quot;&gt;git-commit[1]&lt;/a&gt;.</source>
          <target state="translated">커밋 로그 메시지가 &quot;squash!&amp;hellip;&quot;(또는 &quot;fixup!&amp;hellip;&quot;)로 시작하고 동일한 todo 목록에 이미 &lt;code&gt;...&lt;/code&gt; 같은 커밋이있는 경우 rebase -i의 할 일 목록을 자동으로 수정하십시오. 스쿼시로 표시된 커밋이 수정 된 커밋 직후에 발생하고 이동 된 커밋의 동작을 &lt;code&gt;pick&lt;/code&gt; 에서 &lt;code&gt;squash&lt;/code&gt; (또는 &lt;code&gt;fixup&lt;/code&gt; )로 변경하십시오. 커밋 주제가 일치하거나 &lt;code&gt;...&lt;/code&gt; 가 커밋의 해시를 나타내는 경우 커밋 은 &lt;code&gt;...&lt;/code&gt; 과 일치합니다 . 대체로 커밋 주제의 부분 일치도 작동합니다. 수정 / 스쿼시 커밋을 만드는 권장 방법 은 &lt;a href=&quot;git-commit&quot;&gt;git-commit [1]&lt;/a&gt; 의 &lt;code&gt;--fixup&lt;/code&gt; / &lt;code&gt;--squash&lt;/code&gt; 옵션을 사용하는 것입니다 ..</target>
        </trans-unit>
        <trans-unit id="777196d17b1a10c66d0cd105e5fb66da2363f7b1" translate="yes" xml:space="preserve">
          <source>When the config key &lt;code&gt;extensions.partialclone&lt;/code&gt; is set, it indicates that the repo was created with a partial clone (or later performed a partial fetch) and that the remote may have omitted sending certain unwanted objects. Such a remote is called a &quot;promisor remote&quot; and it promises that all such omitted objects can be fetched from it in the future.</source>
          <target state="translated">config key &lt;code&gt;extensions.partialclone&lt;/code&gt; 을 설정하면 리포지토리가 부분 복제본으로 생성되었거나 나중에 부분 페치를 수행하여 원격이 특정 원하지 않는 개체를 보내는 것을 생략했을 수 있습니다. 이러한 리모컨을 &quot;프로 미저 리모컨&quot;이라고하며, 생략 된 모든 객체를 앞으로 가져올 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ef73607bec133cc1d32aaf64deafc8c72104731d" translate="yes" xml:space="preserve">
          <source>When the config key &lt;code&gt;extensions.preciousObjects&lt;/code&gt; is set to &lt;code&gt;true&lt;/code&gt;, objects in the repository MUST NOT be deleted (e.g., by &lt;code&gt;git-prune&lt;/code&gt; or &lt;code&gt;git repack -d&lt;/code&gt;).</source>
          <target state="translated">config key &lt;code&gt;extensions.preciousObjects&lt;/code&gt; 가 &lt;code&gt;true&lt;/code&gt; 로 설정 되면 저장소의 객체는 삭제해서는 안됩니다 (예 : &lt;code&gt;git-prune&lt;/code&gt; 또는 &lt;code&gt;git repack -d&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="e23e26ad367e6b915821bbb7b38753fa6fd4c240" translate="yes" xml:space="preserve">
          <source>When the current working directory is below the repository directory print &quot;true&quot;, otherwise &quot;false&quot;.</source>
          <target state="translated">현재 작업 디렉토리가 저장소 디렉토리 아래에 있으면 &quot;true&quot;를 인쇄하고, 그렇지 않으면 &quot;false&quot;를 인쇄하십시오.</target>
        </trans-unit>
        <trans-unit id="8a7aa53d7bbe6bfa657a2a1bb84359882384d7fa" translate="yes" xml:space="preserve">
          <source>When the current working directory is inside the work tree of the repository print &quot;true&quot;, otherwise &quot;false&quot;.</source>
          <target state="translated">현재 작업 디렉토리가 저장소의 작업 트리 내에있는 경우 &quot;true&quot;를 인쇄하고 그렇지 않으면 &quot;false&quot;를 인쇄하십시오.</target>
        </trans-unit>
        <trans-unit id="dd7dc6a4dcd86a8d725c2332772df83ad820f427" translate="yes" xml:space="preserve">
          <source>When the environment variable &lt;code&gt;GIT_EXTERNAL_DIFF&lt;/code&gt; is set, the program named by it is called, instead of the diff invocation described above. For a path that is added, removed, or modified, &lt;code&gt;GIT_EXTERNAL_DIFF&lt;/code&gt; is called with 7 parameters:</source>
          <target state="translated">환경 변수 &lt;code&gt;GIT_EXTERNAL_DIFF&lt;/code&gt; 가 설정되면 위에서 설명한 diff 호출 대신 이름이 지정된 프로그램이 호출됩니다. 추가, 제거 또는 수정 된 경로의 경우 7 개의 매개 변수로 &lt;code&gt;GIT_EXTERNAL_DIFF&lt;/code&gt; 가 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="ec4de571b6827b1e0107c62834d6f8cf9f50bba2" translate="yes" xml:space="preserve">
          <source>When the git-rebase command is run, it will first execute a &quot;pre-rebase&quot; hook if one exists. You can use this hook to do sanity checks and reject the rebase if it isn&amp;rsquo;t appropriate. Please see the template pre-rebase hook script for an example.</source>
          <target state="translated">git-rebase 명령이 실행될 때 &quot;pre-rebase&quot;훅이 있으면 먼저 실행합니다. 이 후크를 사용하여 상태 검사를 수행하고 적절하지 않은 경우 리베이스를 거부 할 수 있습니다. 예제는 템플릿 사전 리베이스 후크 스크립트를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="4663df00f4cd516023be3e887d8ecce789e72f00" translate="yes" xml:space="preserve">
          <source>When the history involves criss-cross merges, there can be more than one &lt;code&gt;best&lt;/code&gt; common ancestor for two commits. For example, with this topology:</source>
          <target state="translated">역사 십자 병합을 포함 할 경우, 하나 이상의있을 수 있습니다 &lt;code&gt;best&lt;/code&gt; 두 커밋에 대한 공통 조상. 예를 들어이 토폴로지의 경우</target>
        </trans-unit>
        <trans-unit id="58beafa5cea14c3b99014fb314d938b1ee9fac65" translate="yes" xml:space="preserve">
          <source>When the man viewer, specified by the &lt;code&gt;man.viewer&lt;/code&gt; configuration variables, is not among the supported ones, then the corresponding &lt;code&gt;man.&amp;lt;tool&amp;gt;.cmd&lt;/code&gt; configuration variable will be looked up. If this variable exists then the specified tool will be treated as a custom command and a shell eval will be used to run the command with the man page passed as arguments.</source>
          <target state="translated">&lt;code&gt;man.viewer&lt;/code&gt; 구성 변수로 지정된 man 뷰어 가 지원되는 변수 중 하나가 아닌 경우 해당 &lt;code&gt;man.&amp;lt;tool&amp;gt;.cmd&lt;/code&gt; 구성 변수가 조회됩니다. 이 변수가 존재하면 지정된 도구는 사용자 정의 명령으로 취급되며 셸 평가는 명령 페이지를 인수로 전달하여 명령을 실행하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="d01c091e9d01b5baf9f294a1d7b9c823d7d014bc" translate="yes" xml:space="preserve">
          <source>When the output goes to a terminal, it is color-coded by default, just like regular &lt;code&gt;git diff&lt;/code&gt;'s output. In addition, the first line (adding a commit) is green, the last line (deleting a commit) is red, the second line (with a perfect match) is yellow like the commit header of &lt;code&gt;git
show&lt;/code&gt;'s output, and the third line colors the old commit red, the new one green and the rest like &lt;code&gt;git show&lt;/code&gt;'s commit header.</source>
          <target state="translated">출력이 터미널로 이동하면 일반 &lt;code&gt;git diff&lt;/code&gt; 출력 과 마찬가지로 기본적으로 색상이 코딩됩니다 . 또한 첫 번째 줄 (커밋 추가)은 녹색이고, 마지막 줄 (커밋 삭제)은 빨간색, 두 번째 줄 (완벽한 일치)은 &lt;code&gt;git show&lt;/code&gt; 출력 의 커밋 헤더와 같이 노란색입니다. 라인은 오래된 커밋 빨간색, 새로운 커밋 녹색 및 나머지는 &lt;code&gt;git show&lt;/code&gt; 의 커밋 헤더와 같습니다.</target>
        </trans-unit>
        <trans-unit id="ecf68ce55bda2542529810833e005e7f157f71c2" translate="yes" xml:space="preserve">
          <source>When the patch does not apply cleanly, fall back on 3-way merge if the patch records the identity of blobs it is supposed to apply to and we have those blobs available locally. &lt;code&gt;--no-3way&lt;/code&gt; can be used to override am.threeWay configuration variable. For more information, see am.threeWay in &lt;a href=&quot;git-config&quot;&gt;git-config[1]&lt;/a&gt;.</source>
          <target state="translated">패치가 제대로 적용되지 않으면 패치가 적용되어야 할 얼룩의 ID를 기록하고 해당 얼룩을 로컬로 사용할 수있게되면 3 방향 병합으로 대체됩니다. &lt;code&gt;--no-3way&lt;/code&gt; 를 사용하여 am.threeWay 구성 변수를 대체 할 수 있습니다. 자세한 내용은 &lt;a href=&quot;git-config&quot;&gt;git-config [1]의&lt;/a&gt; am.threeWay를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="28728fcf386b485f532ec99285643062f0405ba5" translate="yes" xml:space="preserve">
          <source>When the patch does not apply cleanly, fall back on 3-way merge if the patch records the identity of blobs it is supposed to apply to, and we have those blobs available locally, possibly leaving the conflict markers in the files in the working tree for the user to resolve. This option implies the &lt;code&gt;--index&lt;/code&gt; option, and is incompatible with the &lt;code&gt;--reject&lt;/code&gt; and the &lt;code&gt;--cached&lt;/code&gt; options.</source>
          <target state="translated">패치가 제대로 적용되지 않는 경우 패치에 적용 할 얼룩의 ID를 기록하고 해당 얼룩을 로컬로 사용할 수 있으면 작업 트리의 파일에 충돌 마커가 남을 수 있습니다. 사용자가 해결할 수 있습니다. 이 옵션은 &lt;code&gt;--index&lt;/code&gt; 옵션을 의미하며 &lt;code&gt;--reject&lt;/code&gt; 및 &lt;code&gt;--cached&lt;/code&gt; 옵션 과 호환되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="bdd1b4760c591dff915e966378bff929405d28b1" translate="yes" xml:space="preserve">
          <source>When the push is complete, outputs one or more &lt;code&gt;ok &amp;lt;dst&amp;gt;&lt;/code&gt; or &lt;code&gt;error &amp;lt;dst&amp;gt; &amp;lt;why&amp;gt;?&lt;/code&gt; lines to indicate success or failure of each pushed ref. The status report output is terminated by a blank line. The option field &amp;lt;why&amp;gt; may be quoted in a C style string if it contains an LF.</source>
          <target state="translated">푸시가 완료되면 하나 이상의 &lt;code&gt;ok &amp;lt;dst&amp;gt;&lt;/code&gt; 또는 &lt;code&gt;error &amp;lt;dst&amp;gt; &amp;lt;why&amp;gt;?&lt;/code&gt; 푸시 된 각 심판의 성공 또는 실패를 나타내는 선. 상태 보고서 출력은 빈 줄로 종료됩니다. 옵션 필드 &amp;lt;why&amp;gt;는 LF를 포함하는 경우 C 스타일 문자열로 인용 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c36826b0bb47b2400e28127fc2b6b138c228a63f" translate="yes" xml:space="preserve">
          <source>When the remote branch you want to fetch is known to be rewound and rebased regularly, it is expected that its new tip will not be descendant of its previous tip (as stored in your remote-tracking branch the last time you fetched). You would want to use the &lt;code&gt;+&lt;/code&gt; sign to indicate non-fast-forward updates will be needed for such branches. There is no way to determine or declare that a branch will be made available in a repository with this behavior; the pulling user simply must know this is the expected usage pattern for a branch.</source>
          <target state="translated">가져 오려는 원격 브랜치가 되감기 고 정기적으로 리베이스되는 것으로 알려진 경우 새 팁이 이전 팁의 후손이 아닌 것으로 예상됩니다 (마지막 페치시 원격 추적 브랜치에 저장 됨). &lt;code&gt;+&lt;/code&gt; 기호 를 사용하여 해당 분기에 빨리 감기가 아닌 업데이트가 필요함을 나타냅니다. 이 동작으로 저장소에서 브랜치를 사용할 수 있다고 결정하거나 선언 할 방법이 없습니다. 당기는 사용자는 이것이 브랜치의 예상 사용 패턴임을 알고 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="c2d02d0fdbdd6b68f91184ab0fd8a5fcfd84e982" translate="yes" xml:space="preserve">
          <source>When the repository is bare print &quot;true&quot;, otherwise &quot;false&quot;.</source>
          <target state="translated">리포지토리가 베어 인쇄 된 경우 &quot;true&quot;, 그렇지 않으면 &quot;false&quot;</target>
        </trans-unit>
        <trans-unit id="4881892c9231f2a8cbf0d32abf5995af521026ca" translate="yes" xml:space="preserve">
          <source>When the repository is shallow print &quot;true&quot;, otherwise &quot;false&quot;.</source>
          <target state="translated">저장소가 얕게 인쇄되면 &quot;true&quot;이고 그렇지 않으면 &quot;false&quot;입니다.</target>
        </trans-unit>
        <trans-unit id="37826a890a4b64bdd1230276a23bd80630675ca5" translate="yes" xml:space="preserve">
          <source>When the repository named by &lt;code&gt;&amp;lt;url&amp;gt;&lt;/code&gt; has the commit at a tip of a ref that is different from the ref you have locally, you can use the &lt;code&gt;&amp;lt;local&amp;gt;:&amp;lt;remote&amp;gt;&lt;/code&gt; syntax, to have its local name, a colon &lt;code&gt;:&lt;/code&gt;, and its remote name.</source>
          <target state="translated">&lt;code&gt;&amp;lt;url&amp;gt;&lt;/code&gt; 이라는 이름의 저장소에 로컬 참조와 다른 참조 끝에 커밋이있는 경우 &lt;code&gt;&amp;lt;local&amp;gt;:&amp;lt;remote&amp;gt;&lt;/code&gt; 구문을 사용하여 로컬 이름 인 콜론 &lt;code&gt;:&lt;/code&gt; , 그리고 그 원격 이름.</target>
        </trans-unit>
        <trans-unit id="a7fe7f8247bda757ca8d697055bcfe0913ae2caf" translate="yes" xml:space="preserve">
          <source>When the repository to clone from is on a local machine, this flag bypasses the normal &quot;Git aware&quot; transport mechanism and clones the repository by making a copy of HEAD and everything under objects and refs directories. The files under &lt;code&gt;.git/objects/&lt;/code&gt; directory are hardlinked to save space when possible.</source>
          <target state="translated">복제 할 저장소가 로컬 시스템에있는 경우이 플래그는 일반적인 &quot;Git aware&quot;전송 메커니즘을 무시하고 오브젝트 및 참조 디렉토리 아래에 HEAD 및 모든 사본을 작성하여 저장소를 복제합니다. &lt;code&gt;.git/objects/&lt;/code&gt; 디렉토리 의 파일 은 가능한 경우 공간을 절약하기 위해 하드 링크되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="87edb2bef2f28c0f63de7720d331d50db0279e94" translate="yes" xml:space="preserve">
          <source>When the repository to clone is on the local machine, instead of using hard links, automatically setup &lt;code&gt;.git/objects/info/alternates&lt;/code&gt; to share the objects with the source repository. The resulting repository starts out without any object of its own.</source>
          <target state="translated">복제 할 리포지토리가 로컬 컴퓨터에있는 경우 하드 링크를 사용하는 대신 소스 리포지토리와 개체를 공유하도록 &lt;code&gt;.git/objects/info/alternates&lt;/code&gt; 를 자동으로 설정 합니다. 결과 리포지토리는 자체 개체없이 시작됩니다.</target>
        </trans-unit>
        <trans-unit id="e18b845f941d21aaf5232c387f67cb23d0a4e759" translate="yes" xml:space="preserve">
          <source>When the result of a &lt;code&gt;git bisect&lt;/code&gt; is a non-merge commit, you should normally be able to discover the problem by examining just that commit. Developers can make this easy by breaking their changes into small self-contained commits. That won&amp;rsquo;t help in the case above, however, because the problem isn&amp;rsquo;t obvious from examination of any single commit; instead, a global view of the development is required. To make matters worse, the change in semantics in the problematic function may be just one small part of the changes in the upper line of development.</source>
          <target state="translated">&lt;code&gt;git bisect&lt;/code&gt; 의 결과가 병합되지 않은 커밋 인 경우 일반적으로 해당 커밋 만 검사하여 문제를 발견 할 수 있습니다. 개발자는 변경 사항을 작은 자체 커밋으로 변경하여이를 쉽게 수행 할 수 있습니다. 그러나 위의 경우에는 도움이되지 않습니다. 단일 커밋을 검사하면 문제가 분명하지 않기 때문입니다. 대신, 개발에 대한 세계적인 시각이 필요합니다. 설상가상으로, 문제가있는 함수에서 의미론의 변화는 개발의 상위 라인 변화의 작은 부분 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="57dfd8622d0e5d97d5c5344dbdac2c35010a468d" translate="yes" xml:space="preserve">
          <source>When the split index feature is used, shared index files that were not modified since the time this variable specifies will be removed when a new shared index file is created. The value &quot;now&quot; expires all entries immediately, and &quot;never&quot; suppresses expiration altogether. The default value is &quot;2.weeks.ago&quot;. Note that a shared index file is considered modified (for the purpose of expiration) each time a new split-index file is either created based on it or read from it. See &lt;a href=&quot;git-update-index&quot;&gt;git-update-index[1]&lt;/a&gt;.</source>
          <target state="translated">인덱스 분할 기능을 사용하는 경우이 변수가 지정한 시간 이후 수정되지 않은 공유 인덱스 파일은 새 공유 인덱스 파일이 만들어 질 때 제거됩니다. &quot;now&quot;값은 모든 항목을 즉시 만료 시키며 &quot;never&quot;는 만료를 완전히 억제합니다. 기본값은 &quot;2.weeks.ago&quot;입니다. 공유 인덱스 파일은 새 분할 인덱스 파일을 기반으로 만들거나 읽을 때마다 (만료 목적으로) 수정 된 것으로 간주됩니다. &lt;a href=&quot;git-update-index&quot;&gt;git-update-index [1]를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="887ef75c2523fd6b4da84b3a0a714f4995305746" translate="yes" xml:space="preserve">
          <source>When the split index feature is used, this specifies the percent of entries the split index can contain compared to the total number of entries in both the split index and the shared index before a new shared index is written. The value should be between 0 and 100. If the value is 0 then a new shared index is always written, if it is 100 a new shared index is never written. By default the value is 20, so a new shared index is written if the number of entries in the split index would be greater than 20 percent of the total number of entries. See &lt;a href=&quot;git-update-index&quot;&gt;git-update-index[1]&lt;/a&gt;.</source>
          <target state="translated">분할 인덱스 기능을 사용하는 경우 새 공유 인덱스를 작성하기 전에 분할 인덱스와 공유 인덱스 모두의 총 항목 수와 비교할 때 분할 인덱스에 포함 할 수있는 항목의 백분율을 지정합니다. 값은 0과 100 사이 여야합니다. 값이 0이면 새 공유 인덱스가 항상 기록되고 100이면 새 공유 인덱스가 기록되지 않습니다. 기본적으로 값은 20이므로 분할 인덱스의 항목 수가 총 항목 수의 20 %보다 클 경우 새 공유 인덱스가 작성됩니다. &lt;a href=&quot;git-update-index&quot;&gt;git-update-index [1]를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="249674ff1351f5c865508a34f368a209ce692426" translate="yes" xml:space="preserve">
          <source>When the value is &lt;code&gt;interactive&lt;/code&gt;, the rebase is run in interactive mode.</source>
          <target state="translated">값이 &lt;code&gt;interactive&lt;/code&gt; 이면 rebase는 대화식 모드에서 실행됩니다.</target>
        </trans-unit>
        <trans-unit id="bbc30d1504ae5818b5ebed3f68f464e3d8d41b06" translate="yes" xml:space="preserve">
          <source>When there are approximately more than this many loose objects in the repository, &lt;code&gt;git gc --auto&lt;/code&gt; will pack them. Some Porcelain commands use this command to perform a light-weight garbage collection from time to time. The default value is 6700.</source>
          <target state="translated">저장소에이 많은 수의 느슨한 객체가있는 경우 &lt;code&gt;git gc --auto&lt;/code&gt; 가이 를 포장합니다. 일부 Porcelain 명령은이 명령을 사용하여 때때로 가벼운 가비지 콜렉션을 수행합니다. 기본값은 6700입니다.</target>
        </trans-unit>
        <trans-unit id="62fefa7cb364ff9a836bef0837ac15925fecc8f2" translate="yes" xml:space="preserve">
          <source>When there are more than this many packs that are not marked with &lt;code&gt;*.keep&lt;/code&gt; file in the repository, &lt;code&gt;git gc
--auto&lt;/code&gt; consolidates them into one larger pack. The default value is 50. Setting this to 0 disables it. Setting &lt;code&gt;gc.auto&lt;/code&gt; to 0 will also disable this.</source>
          <target state="translated">저장소에 &lt;code&gt;*.keep&lt;/code&gt; 파일 로 표시되지 않은이 팩보다 많은 팩이 있으면 &lt;code&gt;git gc --auto&lt;/code&gt; 는이 팩을 하나의 큰 팩으로 통합합니다. 기본값은 50입니다.이 값을 0으로 설정하면 비활성화됩니다. &lt;code&gt;gc.auto&lt;/code&gt; 를 0으로 설정하면 이 기능도 비활성화됩니다.</target>
        </trans-unit>
        <trans-unit id="a99bf9777c550eb2f6602e82876314f8cadcb15d" translate="yes" xml:space="preserve">
          <source>When there is only one argument given and it is not &lt;code&gt;--&lt;/code&gt; (e.g. &lt;code&gt;git
checkout abc&lt;/code&gt;), and when the argument is both a valid &lt;code&gt;&amp;lt;tree-ish&amp;gt;&lt;/code&gt; (e.g. a branch &lt;code&gt;abc&lt;/code&gt; exists) and a valid &lt;code&gt;&amp;lt;pathspec&amp;gt;&lt;/code&gt; (e.g. a file or a directory whose name is &quot;abc&quot; exists), Git would usually ask you to disambiguate. Because checking out a branch is so common an operation, however, &lt;code&gt;git checkout abc&lt;/code&gt; takes &quot;abc&quot; as a &lt;code&gt;&amp;lt;tree-ish&amp;gt;&lt;/code&gt; in such a situation. Use &lt;code&gt;git checkout -- &amp;lt;pathspec&amp;gt;&lt;/code&gt; if you want to checkout these paths out of the index.</source>
          <target state="translated">거기에 주어진 단 하나 개의 인수이며이 아닌 경우 &lt;code&gt;--&lt;/code&gt; (예를 들어 &lt;code&gt;git checkout abc&lt;/code&gt; ), 인수는 모두 유효한 경우 &lt;code&gt;&amp;lt;tree-ish&amp;gt;&lt;/code&gt; (예 : 분기 &lt;code&gt;abc&lt;/code&gt; 존재하는) 유효한 &lt;code&gt;&amp;lt;pathspec&amp;gt;&lt;/code&gt; (예 : 파일 또는 이름이 &quot;abc&quot;인 디렉토리가 존재하는 경우) Git은 일반적으로 명확성을 요구합니다. 분기를 체크 아웃하는 것은 일반적인 작업이므로 &lt;code&gt;git checkout abc&lt;/code&gt; 는 이러한 상황에서 &quot;abc&quot;를 &lt;code&gt;&amp;lt;tree-ish&amp;gt;&lt;/code&gt; 로 사용합니다. 인덱스에서 이러한 경로를 체크 &lt;code&gt;git checkout -- &amp;lt;pathspec&amp;gt;&lt;/code&gt; 하려면 git checkout-&amp;lt;pathspec&amp;gt;을 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="3ff1d02c565a22d417998ec283b077273b716d4a" translate="yes" xml:space="preserve">
          <source>When these environment variables are set, the corresponding command-line arguments may not be used.</source>
          <target state="translated">이러한 환경 변수가 설정되면 해당 명령 줄 인수를 사용할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="86c4d2dcd046b538b0d9c792061f20bffd3f8c8e" translate="yes" xml:space="preserve">
          <source>When this flag is provided, the pack is read from stdin instead and a copy is then written to &amp;lt;pack-file&amp;gt;. If &amp;lt;pack-file&amp;gt; is not specified, the pack is written to objects/pack/ directory of the current Git repository with a default name determined from the pack content. If &amp;lt;pack-file&amp;gt; is not specified consider using --keep to prevent a race condition between this process and &lt;code&gt;git repack&lt;/code&gt;.</source>
          <target state="translated">이 플래그가 제공되면, 대신 stdin에서 팩을 읽은 다음 &amp;lt;pack-file&amp;gt;에 사본을 씁니다. &amp;lt;pack-file&amp;gt;을 지정하지 않으면 팩은 현재 Git 저장소의 objects / pack / 디렉토리에 팩 컨텐츠에서 결정된 기본 이름으로 기록됩니다. &amp;lt;pack-file&amp;gt;이 지정되지 않은 경우 --keep을 사용하여이 프로세스와 &lt;code&gt;git repack&lt;/code&gt; 간의 경쟁 조건을 방지하십시오 .</target>
        </trans-unit>
        <trans-unit id="c91915e7d5f6096e68c1652d49f4ac505147354d" translate="yes" xml:space="preserve">
          <source>When this flag is specified, the object names recorded for the paths are not updated. Instead, this option sets/unsets the &quot;assume unchanged&quot; bit for the paths. When the &quot;assume unchanged&quot; bit is on, the user promises not to change the file and allows Git to assume that the working tree file matches what is recorded in the index. If you want to change the working tree file, you need to unset the bit to tell Git. This is sometimes helpful when working with a big project on a filesystem that has very slow lstat(2) system call (e.g. cifs).</source>
          <target state="translated">이 플래그를 지정하면 경로에 대해 기록 된 오브젝트 이름이 업데이트되지 않습니다. 대신이 옵션은 경로에 대해 &quot;변경되지 않은 것으로 가정&quot;비트를 설정 / 설정 해제합니다. &quot;변경되지 않은 것으로 가정&quot;비트가 켜져 있으면 사용자는 파일을 변경하지 않겠다고 약속하고 Git이 작업 트리 파일이 인덱스에 기록 된 것과 일치한다고 가정 할 수 있습니다. 작업 트리 파일을 변경하려면 Git에 알리기 위해 비트를 설정 해제해야합니다. lstat (2) 시스템 호출이 매우 느린 파일 시스템 (예 : cifs)에서 큰 프로젝트로 작업 할 때 가끔 유용합니다.</target>
        </trans-unit>
        <trans-unit id="b1f75c6b9b1b22670befceda22525699cad697f2" translate="yes" xml:space="preserve">
          <source>When this form of &lt;code&gt;git read-tree&lt;/code&gt; returns successfully, you can see which of the &quot;local changes&quot; that you made were carried forward by running &lt;code&gt;git diff-index --cached $M&lt;/code&gt;. Note that this does not necessarily match what &lt;code&gt;git diff-index --cached $H&lt;/code&gt; would have produced before such a two tree merge. This is because of cases 18 and 19 --- if you already had the changes in $M (e.g. maybe you picked it up via e-mail in a patch form), &lt;code&gt;git diff-index
--cached $H&lt;/code&gt; would have told you about the change before this merge, but it would not show in &lt;code&gt;git diff-index --cached $M&lt;/code&gt; output after the two-tree merge.</source>
          <target state="translated">이 형식의 &lt;code&gt;git read-tree&lt;/code&gt; 가 성공적으로 반환되면 &lt;code&gt;git diff-index --cached $M&lt;/code&gt; 을 실행하여 수행 한 &quot;로컬 변경&quot;중 어느 것이 수행 되었는지 확인할 수 있습니다. 이것은 두 개의 트리 병합 전에 &lt;code&gt;git diff-index --cached $H&lt;/code&gt; 가 생성 한 것과 반드시 ​​일치하지는 않습니다 . 이것은 18 번과 19 번 사건 때문입니다 --- 만약 $ M에 이미 변경이 있었다면 (예를 들어, 패치 형식으로 이메일을 통해 받아 들일 수 있습니다 ), &lt;code&gt;git diff-index --cached $H&lt;/code&gt; 가 당신에게 말했을 것입니다 이 병합 전에 변경 사항에 대해 설명하지만 2 트리 병합 후 &lt;code&gt;git diff-index --cached $M&lt;/code&gt; 출력 에는 표시되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="a7b5d3881356f9c9c7fd25660fd80f9c16873a97" translate="yes" xml:space="preserve">
          <source>When this option is specified, the behavior is as if a special &lt;code&gt;&amp;lt;token&amp;gt;=&amp;lt;value&amp;gt;&lt;/code&gt; argument were added at the beginning of the command line, where &amp;lt;value&amp;gt; is taken to be the standard output of the specified command with any leading and trailing whitespace trimmed off.</source>
          <target state="translated">이 옵션을 지정 하면 명령 행의 시작 부분에 특수 &lt;code&gt;&amp;lt;token&amp;gt;=&amp;lt;value&amp;gt;&lt;/code&gt; 인수가 추가 된 것처럼 작동 합니다. 여기서 &amp;lt;value&amp;gt;는 지정된 명령의 표준 출력이됩니다. 후행 공백이 잘립니다.</target>
        </trans-unit>
        <trans-unit id="de58814133990da5a575ac12a35ef9b3b981ae4a" translate="yes" xml:space="preserve">
          <source>When this special attribute is read by &lt;code&gt;git credential&lt;/code&gt;, the value is parsed as a URL and treated as if its constituent parts were read (e.g., &lt;code&gt;url=https://example.com&lt;/code&gt; would behave as if &lt;code&gt;protocol=https&lt;/code&gt; and &lt;code&gt;host=example.com&lt;/code&gt; had been provided). This can help callers avoid parsing URLs themselves. Note that any components which are missing from the URL (e.g., there is no username in the example above) will be set to empty; if you want to provide a URL and override some attributes, provide the URL attribute first, followed by any overrides.</source>
          <target state="translated">이 특수 속성이 &lt;code&gt;git credential&lt;/code&gt; 에 의해 읽 히면 값은 URL로 구문 분석되고 구성 부분을 읽은 것처럼 처리됩니다 (예 : &lt;code&gt;url=https://example.com&lt;/code&gt; 은 &lt;code&gt;protocol=https&lt;/code&gt; 및 &lt;code&gt;host=example.com&lt;/code&gt; 처럼 작동 함) . com 이 제공되었습니다). 이렇게하면 발신자가 URL을 구문 분석하지 않아도됩니다. URL에서 누락 된 구성 요소 (예 : 위의 예에서 사용자 이름이 없음)는 비어 있습니다. URL을 제공하고 일부 속성을 재정의하려면 먼저 URL 특성을 제공 한 다음 재정의를 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="882eafec7b82da90c1fd3ae7dc7040457d013cf9" translate="yes" xml:space="preserve">
          <source>When trace files are written to a target directory, they will be named according to the last component of the SID (optionally followed by a counter to avoid filename collisions).</source>
          <target state="translated">추적 파일이 대상 디렉토리에 기록되면 SID의 마지막 구성 요소에 따라 이름이 지정됩니다 (선택적으로 파일 이름 충돌을 피하기 위해 카운터가 뒤 따름).</target>
        </trans-unit>
        <trans-unit id="1771ffd8c74f9f0b2e623ff3c52581b28a17469b" translate="yes" xml:space="preserve">
          <source>When tracking multiple directories (using --stdlayout, --branches, or --tags options), git svn will attempt to connect to the root (or highest allowed level) of the Subversion repository. This default allows better tracking of history if entire projects are moved within a repository, but may cause issues on repositories where read access restrictions are in place. Passing &lt;code&gt;--no-minimize-url&lt;/code&gt; will allow git svn to accept URLs as-is without attempting to connect to a higher level directory. This option is off by default when only one URL/branch is tracked (it would do little good).</source>
          <target state="translated">--stdlayout, --branches 또는 --tags 옵션을 사용하여 여러 디렉토리를 추적 할 때 git svn은 Subversion 저장소의 루트 (또는 최고 허용 레벨)에 연결을 시도합니다. 이 기본값은 전체 프로젝트가 저장소 내에서 이동 된 경우 히스토리를 더 잘 추적 할 수 있지만 읽기 액세스 제한이있는 저장소에 문제를 일으킬 수 있습니다. &lt;code&gt;--no-minimize-url&lt;/code&gt; 을 전달 하면 git svn이 더 높은 수준의 디렉토리에 연결하지 않고있는 그대로 URL을 수락 할 수 있습니다. 이 옵션은 하나의 URL / 브랜치 만 추적 할 때 기본적으로 해제되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="fce35b3add797f616ba5b3be537b437a03e625f0" translate="yes" xml:space="preserve">
          <source>When true, git will default to using the &lt;code&gt;--sparse&lt;/code&gt; option in &lt;code&gt;git pack-objects&lt;/code&gt; when the &lt;code&gt;--revs&lt;/code&gt; option is present. This algorithm only walks trees that appear in paths that introduce new objects. This can have significant performance benefits when computing a pack to send a small change. However, it is possible that extra objects are added to the pack-file if the included commits contain certain types of direct renames. Default is &lt;code&gt;false&lt;/code&gt; unless &lt;code&gt;feature.experimental&lt;/code&gt; is enabled.</source>
          <target state="translated">true 인 경우 &lt;code&gt;--revs&lt;/code&gt; 옵션이 있으면 git은 기본적으로 &lt;code&gt;git pack-objects&lt;/code&gt; 에서 &lt;code&gt;--sparse&lt;/code&gt; 옵션 을 사용합니다 . 이 알고리즘은 새로운 객체를 도입하는 경로에 나타나는 트리 만 걷는다. 이것은 작은 변화를 보내기 위해 팩을 계산할 때 상당한 성능 이점을 가질 수 있습니다. 그러나 포함 된 커밋에 특정 유형의 직접 이름 바꾸기가 포함되어 있으면 추가 객체가 팩 파일에 추가 될 수 있습니다. &lt;code&gt;feature.experimental&lt;/code&gt; 을 사용 하지 않으면 기본값은 &lt;code&gt;false&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="5d73311a3b4a00977d7e2237078b01efb9320bfa" translate="yes" xml:space="preserve">
          <source>When true, git will include a &quot;hash cache&quot; section in the bitmap index (if one is written). This cache can be used to feed git&amp;rsquo;s delta heuristics, potentially leading to better deltas between bitmapped and non-bitmapped objects (e.g., when serving a fetch between an older, bitmapped pack and objects that have been pushed since the last gc). The downside is that it consumes 4 bytes per object of disk space. Defaults to true.</source>
          <target state="translated">true 인 경우 git은 &quot;해시 캐시&quot;섹션을 비트 맵 인덱스에 작성합니다 (작성된 경우). 이 캐시는 git의 델타 휴리스틱을 제공하는 데 사용될 수 있으며, 잠재적으로 비트 맵 및 비트 맵되지 않은 객체 사이의 델타를 향상시킬 수 있습니다 (예 : 이전, 비트 맵 된 팩과 마지막 gc 이후 푸시 된 객체 간의 페치 제공시). 단점은 디스크 공간 개체 당 4 바이트를 소비한다는 것입니다. 기본값은 true입니다.</target>
        </trans-unit>
        <trans-unit id="98f36898b39f3ac14609adb644f7b367554be4b3" translate="yes" xml:space="preserve">
          <source>When true, git will use pack bitmaps (if available) when packing to stdout (e.g., during the server side of a fetch). Defaults to true. You should not generally need to turn this off unless you are debugging pack bitmaps.</source>
          <target state="translated">true 일 경우, git은 stdout으로 패킹 할 때 (예를 들어, 페치의 서버 측에서) 팩 비트 맵 (사용 가능한 경우)을 사용합니다. 기본값은 true입니다. 팩 비트 맵을 디버깅하지 않는 한 일반적으로이 기능을 해제하지 않아도됩니다.</target>
        </trans-unit>
        <trans-unit id="3060361b8b64f7f4f15aa5d402b402d65fd1ef21" translate="yes" xml:space="preserve">
          <source>When true, git will write a bitmap index when packing all objects to disk (e.g., when &lt;code&gt;git repack -a&lt;/code&gt; is run). This index can speed up the &quot;counting objects&quot; phase of subsequent packs created for clones and fetches, at the cost of some disk space and extra time spent on the initial repack. This has no effect if multiple packfiles are created. Defaults to true on bare repos, false otherwise.</source>
          <target state="translated">참이면, git은 모든 객체를 디스크에 패킹 할 때 (예를 들어, &lt;code&gt;git repack -a&lt;/code&gt; 가 실행될 때) 비트 맵 인덱스를 씁니다 . 이 인덱스는 일부 디스크 공간과 초기 재 포장에 소요되는 추가 시간을 소비하면서 클론 및 페치에 대해 생성 된 후속 팩의 &quot;개체 수 계산&quot;단계를 가속화 할 수 있습니다. 여러 팩 파일이 생성 된 경우에는 효과가 없습니다. 기본 저장소에서는 기본값이 true이고, 그렇지 않으면 false입니다.</target>
        </trans-unit>
        <trans-unit id="b7b0c56b83a62c5cf7d9e0b77ba1430747588d7a" translate="yes" xml:space="preserve">
          <source>When true, rebase branches on top of the fetched branch, instead of merging the default branch from the default remote when &quot;git pull&quot; is run. See &quot;branch.&amp;lt;name&amp;gt;.rebase&quot; for setting this on a per-branch basis.</source>
          <target state="translated">true 인 경우 &quot;git pull&quot;이 실행될 때 기본 원격에서 기본 분기를 병합하는 대신 가져온 분기 위에 분기를 리베이스하십시오. 분기별로이를 설정하려면 &quot;branch. &amp;lt;name&amp;gt; .rebase&quot;를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="c15c8ba9ac152f7e581087f6ca67eb8a95961a05" translate="yes" xml:space="preserve">
          <source>When true, rebase the branch &amp;lt;name&amp;gt; on top of the fetched branch, instead of merging the default branch from the default remote when &quot;git pull&quot; is run. See &quot;pull.rebase&quot; for doing this in a non branch-specific manner.</source>
          <target state="translated">true 인 경우 &quot;git pull&quot;이 실행될 때 기본 원격에서 기본 분기를 병합하는 대신 가져온 분기의 맨 위에 &amp;lt;name&amp;gt; 분기를 리베이스하십시오. 비지정 방식으로이를 수행하려면 &quot;pull.rebase&quot;를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="32f2ccfcaf97ac2d1b8fdcbcf4ee46e8d18499a7" translate="yes" xml:space="preserve">
          <source>When true, rebase the current branch on top of the upstream branch after fetching. If there is a remote-tracking branch corresponding to the upstream branch and the upstream branch was rebased since last fetched, the rebase uses that information to avoid rebasing non-local changes.</source>
          <target state="translated">참이면 페치 한 후 업스트림 브랜치 위에 현재 브랜치를 리베이스합니다. 업스트림 브랜치에 해당하는 원격 추적 브랜치가 있고 마지막 페치 이후 업스트림 브랜치가 리베이스 된 경우 리베이스는 해당 정보를 사용하여 로컬이 아닌 변경 사항의 재베이스를 피합니다.</target>
        </trans-unit>
        <trans-unit id="e3872f2dbeef66b0c7927df02dbbfa3a35c8d12b" translate="yes" xml:space="preserve">
          <source>When two trees are given, it compares the first tree with the second. When a single commit is given, it compares the commit with its parents. The remaining commits, when given, are used as if they are parents of the first commit.</source>
          <target state="translated">두 개의 나무가 주어지면 첫 번째 나무와 두 번째 나무를 비교합니다. 단일 커밋이 제공되면 해당 커밋을 부모와 비교합니다. 주어진 커밋은 마치 첫 커밋의 부모 인 것처럼 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="6b17aa5b71b9d47ea9adc71f193314f65da5b538" translate="yes" xml:space="preserve">
          <source>When two trees are specified, the user is telling &lt;code&gt;git read-tree&lt;/code&gt; the following:</source>
          <target state="translated">두 개의 트리가 지정되면 사용자는 &lt;code&gt;git read-tree&lt;/code&gt; 에게 다음을 알려줍니다 .</target>
        </trans-unit>
        <trans-unit id="0b1c4e2bbef526c82867f5bdebb7889317040a32" translate="yes" xml:space="preserve">
          <source>When unpacking a corrupt packfile, the command dies at the first corruption. This flag tells it to keep going and make the best effort to recover as many objects as possible.</source>
          <target state="translated">손상된 팩 파일의 압축을 풀 때 첫 번째 손상시 명령이 종료됩니다. 이 플래그는 계속 진행하고 가능한 많은 오브젝트를 복구하기 위해 최선을 다하도록 지시합니다.</target>
        </trans-unit>
        <trans-unit id="5a3166bdcd39ee71b5c10c4011020b35e1491541" translate="yes" xml:space="preserve">
          <source>When unspecified, all references, after filtering done with --heads and --tags, are shown. When &amp;lt;refs&amp;gt;&amp;hellip;​ are specified, only references matching the given patterns are displayed.</source>
          <target state="translated">지정하지 않으면 --heads 및 --tags로 필터링 한 후 모든 참조가 표시됩니다. &amp;lt;refs&amp;gt;&amp;hellip;가 지정되면 주어진 패턴과 일치하는 참조 만 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="fa62c673234c7d272766be9489825a6b1fba8b8c" translate="yes" xml:space="preserve">
          <source>When used in conjunction with the untracked cache, it can further improve performance by avoiding the cost of scanning the entire working directory looking for new files.</source>
          <target state="translated">추적되지 않은 캐시와 함께 사용하면 새 파일을 찾는 전체 작업 디렉토리를 스캔하는 비용을 피함으로써 성능을 더욱 향상시킬 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4699c35836688678c5cc37f1963f740eb7581527" translate="yes" xml:space="preserve">
          <source>When used together with &lt;code&gt;-B&lt;/code&gt;, omit also the preimage in the deletion part of a delete/create pair.</source>
          <target state="translated">&lt;code&gt;-B&lt;/code&gt; 와 함께 사용되는 경우 삭제 / 작성 쌍의 삭제 부분에서 사전 이미지도 생략하십시오.</target>
        </trans-unit>
        <trans-unit id="81ec7d099c83d3c361cd6013c655cfcd1bc1c8c9" translate="yes" xml:space="preserve">
          <source>When used with -C/-c/--amend options, or when committing after a conflicting cherry-pick, declare that the authorship of the resulting commit now belongs to the committer. This also renews the author timestamp.</source>
          <target state="translated">-C / -c /-amend 옵션과 함께 사용하거나 충돌하는 체리 픽 후 커밋 할 때 결과 커밋의 권한이 이제 커미터에 속한다고 선언합니다. 또한 작성자 타임 스탬프도 갱신됩니다.</target>
        </trans-unit>
        <trans-unit id="b6df5147373d036993fb497c4d7575874db40c5c" translate="yes" xml:space="preserve">
          <source>When used with -M, a totally-rewritten file is also considered as the source of a rename (usually -M only considers a file that disappeared as the source of a rename), and the number &lt;code&gt;n&lt;/code&gt; controls this aspect of the -B option (defaults to 50%). &lt;code&gt;-B20%&lt;/code&gt; specifies that a change with addition and deletion compared to 20% or more of the file&amp;rsquo;s size are eligible for being picked up as a possible source of a rename to another file.</source>
          <target state="translated">-M과 함께 사용하면 완전히 다시 작성된 파일도 이름 바꾸기의 소스로 간주되며 (보통 -M은 이름 바꾸기의 소스로 사라진 파일 만 고려함) 숫자 &lt;code&gt;n&lt;/code&gt; 은 -B 옵션의이 측면을 제어합니다. (기본값은 50 %). &lt;code&gt;-B20%&lt;/code&gt; 는 파일 크기의 20 % 이상과 비교하여 추가 및 삭제가있는 변경 사항이 다른 파일의 이름 바꾸기 소스로 선택 될 수 있음을 지정합니다.</target>
        </trans-unit>
        <trans-unit id="372d4fbee27ed51979ac65f708d9745903af8bc0" translate="yes" xml:space="preserve">
          <source>When used with &lt;code&gt;--all&lt;/code&gt; print description for all recognized commands. This is the default.</source>
          <target state="translated">인식 된 모든 명령에 대해 &lt;code&gt;--all&lt;/code&gt; print description 과 함께 사용됩니다 . 이것이 기본값입니다.</target>
        </trans-unit>
        <trans-unit id="9b2454d94f74e12e4789baf13180d6dd9add197c" translate="yes" xml:space="preserve">
          <source>When used with &lt;code&gt;-ad&lt;/code&gt;, any unreachable objects from existing packs will be appended to the end of the packfile instead of being removed. In addition, any unreachable loose objects will be packed (and their loose counterparts removed).</source>
          <target state="translated">&lt;code&gt;-ad&lt;/code&gt; 와 함께 사용하면 기존 팩에서 도달 할 수없는 모든 객체가 제거되지 않고 팩 파일의 끝에 추가됩니다. 또한 닿을 수없는 느슨한 물체는 포장되어 있으며 느슨한 물체는 제거됩니다.</target>
        </trans-unit>
        <trans-unit id="f93c22c6857bec96ca286a73d77a732b313ba7be" translate="yes" xml:space="preserve">
          <source>When using --error-unmatch to expand the user supplied &amp;lt;file&amp;gt; (i.e. path pattern) arguments to paths, pretend that paths which were removed in the index since the named &amp;lt;tree-ish&amp;gt; are still present. Using this option with &lt;code&gt;-s&lt;/code&gt; or &lt;code&gt;-u&lt;/code&gt; options does not make any sense.</source>
          <target state="translated">--error-unmatch를 사용하여 사용자가 제공 한 &amp;lt;file&amp;gt; (예 : 경로 패턴) 인수를 경로로 확장 할 때 명명 된 &amp;lt;tree-ish&amp;gt; 이후 인덱스에서 제거 된 경로가 여전히 존재합니다. 이 옵션을 &lt;code&gt;-s&lt;/code&gt; 또는 &lt;code&gt;-u&lt;/code&gt; 옵션과 함께 사용하면 의미가 없습니다.</target>
        </trans-unit>
        <trans-unit id="c409615f2beb16e70015d6d6f46a1b549d1fd7f1" translate="yes" xml:space="preserve">
          <source>When using --hash (and not --dereference) the output format is: &lt;code&gt;&amp;lt;SHA-1 ID&amp;gt;&lt;/code&gt;</source>
          <target state="translated">--hash를 사용하고 --dereference가 아닌 경우 출력 형식은 다음과 같습니다. &lt;code&gt;&amp;lt;SHA-1 ID&amp;gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="081b8dc63c3bf5b426e1b11153b55d3d12af50bd" translate="yes" xml:space="preserve">
          <source>When using &lt;code&gt;--get&lt;/code&gt;, and the requested variable is not found, behave as if &amp;lt;value&amp;gt; were the value assigned to the that variable.</source>
          <target state="translated">&lt;code&gt;--get&lt;/code&gt; 을 사용할 때 요청 된 변수를 찾을 수 없으면 &amp;lt;value&amp;gt;가 해당 변수에 지정된 값인 것처럼 동작합니다.</target>
        </trans-unit>
        <trans-unit id="a0e35ae72d386768f718c98e1facc75ecb16026b" translate="yes" xml:space="preserve">
          <source>When using &lt;code&gt;git diff&lt;/code&gt; to compare with work tree files, do not consider stat-only change as changed. Instead, silently run &lt;code&gt;git update-index --refresh&lt;/code&gt; to update the cached stat information for paths whose contents in the work tree match the contents in the index. This option defaults to true. Note that this affects only &lt;code&gt;git diff&lt;/code&gt; Porcelain, and not lower level &lt;code&gt;diff&lt;/code&gt; commands such as &lt;code&gt;git diff-files&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;git diff&lt;/code&gt; 를 사용하여 작업 트리 파일과 비교할 때 통계 전용 변경을 변경된 것으로 간주하지 마십시오. 대신, &lt;code&gt;git update-index --refresh&lt;/code&gt; 를 자동으로 실행 하여 작업 트리의 내용이 색인의 내용과 일치하는 경로에 대해 캐시 된 통계 정보를 업데이트하십시오. 이 옵션의 기본값은 true입니다. 이것은 &lt;code&gt;git diff&lt;/code&gt; Porcelain 에만 영향을 미치며 &lt;code&gt;git diff-files&lt;/code&gt; 와 같은 하위 수준 &lt;code&gt;diff&lt;/code&gt; 명령 에는 영향을 미치지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="b88f8d37a4b8b52b11aa1a9190d81927513fc837" translate="yes" xml:space="preserve">
          <source>When using either the ssh:// or file:// transport, the GIT_PROTOCOL environment variable must be set explicitly to include &quot;version=2&quot;.</source>
          <target state="translated">ssh : // 또는 file : // 전송을 사용하는 경우 GIT_PROTOCOL 환경 변수는 &quot;version = 2&quot;를 포함하도록 명시 적으로 설정해야합니다.</target>
        </trans-unit>
        <trans-unit id="0ba437f399f8167203a8f1358d574f4341e76291" translate="yes" xml:space="preserve">
          <source>When using multiple --branches or --tags, &lt;code&gt;git svn&lt;/code&gt; does not automatically handle name collisions (for example, if two branches from different paths have the same name, or if a branch and a tag have the same name). In these cases, use &lt;code&gt;init&lt;/code&gt; to set up your Git repository then, before your first &lt;code&gt;fetch&lt;/code&gt;, edit the $GIT_DIR/config file so that the branches and tags are associated with different name spaces. For example:</source>
          <target state="translated">여러 --branches 또는 --tags를 사용하는 경우 &lt;code&gt;git svn&lt;/code&gt; 은 이름 충돌을 자동으로 처리하지 않습니다 (예 : 서로 다른 경로의 두 분기가 같은 이름을 가지거나 분기와 태그의 이름이 같은 경우). 이 경우 &lt;code&gt;init&lt;/code&gt; 을 사용 하여 Git 저장소를 설정 한 다음 첫 번째 &lt;code&gt;fetch&lt;/code&gt; 전에 분기 및 태그가 다른 네임 스페이스와 연관되도록 $ GIT_DIR / config 파일을 편집하십시오. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="bb2aee242441b06254e02f3a0a2e1341fe75fee4" translate="yes" xml:space="preserve">
          <source>When using the &lt;code&gt;--verify&lt;/code&gt; flag, the command requires an exact path:</source>
          <target state="translated">&lt;code&gt;--verify&lt;/code&gt; 플래그를 사용하는 경우 명령에 정확한 경로가 필요합니다.</target>
        </trans-unit>
        <trans-unit id="33199341df233e06da35e7d1be5de579f81a31d0" translate="yes" xml:space="preserve">
          <source>When using the &lt;code&gt;refspec&lt;/code&gt; capability, git normally updates the private ref on successful push. This update is disabled when the remote-helper declares the capability &lt;code&gt;no-private-update&lt;/code&gt;.</source>
          <target state="translated">참조 사양 기능을 사용하는 경우 git은 일반적으로 성공적인 &lt;code&gt;refspec&lt;/code&gt; 개인 참조를 업데이트합니다. 원격 도우미가 &lt;code&gt;no-private-update&lt;/code&gt; 기능을 선언하면이 업데이트가 비활성화됩니다 .</target>
        </trans-unit>
        <trans-unit id="9344e268a1ce18a0fd23fc1ab7349b109ba09f95" translate="yes" xml:space="preserve">
          <source>When using the deprecated &lt;code&gt;[section.subsection]&lt;/code&gt; syntax, changing a value will result in adding a multi-line key instead of a change, if the subsection is given with at least one uppercase character. For example when the config looks like</source>
          <target state="translated">더 이상 사용되지 않는 &lt;code&gt;[section.subsection]&lt;/code&gt; 구문을 사용할 때 하위 섹션에 하나 이상의 대문자가 제공되면 값을 변경하면 변경 대신 여러 줄 키가 추가됩니다. 예를 들어 구성이 다음과 같은 경우</target>
        </trans-unit>
        <trans-unit id="d587eeb587978498a5260d6dbb9ec4ed92ae5139" translate="yes" xml:space="preserve">
          <source>When using the git:// transport, you can request to use protocol v2 by sending &quot;version=2&quot; as an extra parameter:</source>
          <target state="translated">git : // 전송을 사용할 때 &quot;version = 2&quot;를 추가 매개 변수로 보내 프로토콜 v2 사용을 요청할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="32ff889e17de28054dd0cab540306ba1d148a08f" translate="yes" xml:space="preserve">
          <source>When using the http:// or https:// transport a client makes a &quot;smart&quot; info/refs request as described in &lt;code&gt;http-protocol.txt&lt;/code&gt; and requests that v2 be used by supplying &quot;version=2&quot; in the &lt;code&gt;Git-Protocol&lt;/code&gt; header.</source>
          <target state="translated">http : // 또는 https : // 전송을 사용하는 경우 클라이언트는 &lt;code&gt;http-protocol.txt&lt;/code&gt; 에 설명 된대로 &quot;스마트&quot;정보 / 참조 요청을하고 &lt;code&gt;Git-Protocol&lt;/code&gt; 에 &quot;version = 2&quot;를 제공하여 v2를 사용하도록 요청합니다. 헤더.</target>
        </trans-unit>
        <trans-unit id="1119c741c1d5ff1dc358a8c521dcf54497e7a91a" translate="yes" xml:space="preserve">
          <source>When we discuss merges we&amp;rsquo;ll also see the special name MERGE_HEAD, which refers to the other branch that we&amp;rsquo;re merging in to the current branch.</source>
          <target state="translated">병합에 대해 논의 할 때 특수 분기 이름 MERGE_HEAD도 볼 수 있는데, 이는 현재 분기에 병합 할 다른 분기를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="26b492dec7c9b7098cc4171f2408a6f7f7e92986" translate="yes" xml:space="preserve">
          <source>When we need to be precise, we will use the word &quot;branch&quot; to mean a line of development, and &quot;branch head&quot; (or just &quot;head&quot;) to mean a reference to the most recent commit on a branch. In the example above, the branch head named &quot;A&quot; is a pointer to one particular commit, but we refer to the line of three commits leading up to that point as all being part of &quot;branch A&quot;.</source>
          <target state="translated">정확해야 할 때 &quot;분기&quot;라는 단어를 사용하여 개발 라인을 의미하고 &quot;분기 헤드&quot;(또는 &quot;헤드&quot;)를 사용하여 분기에서 가장 최근의 커밋에 대한 참조를 의미합니다. 위의 예에서 &quot;A&quot;라는 분기 헤드는 하나의 특정 커밋에 대한 포인터이지만 해당 지점까지 이어지는 3 개의 커밋 라인은 모두 &quot;브랜치 A&quot;의 일부입니다.</target>
        </trans-unit>
        <trans-unit id="af865a0e18421a331501b917b6b084d9f08c05af" translate="yes" xml:space="preserve">
          <source>When we want to find out what commits in &lt;code&gt;M&lt;/code&gt; are contaminated with the bug introduced by &lt;code&gt;D&lt;/code&gt; and need fixing, however, we might want to view only the subset of &lt;code&gt;D..M&lt;/code&gt; that are actually descendants of &lt;code&gt;D&lt;/code&gt;, i.e. excluding &lt;code&gt;C&lt;/code&gt; and &lt;code&gt;K&lt;/code&gt;. This is exactly what the &lt;code&gt;--ancestry-path&lt;/code&gt; option does. Applied to the &lt;code&gt;D..M&lt;/code&gt; range, it results in:</source>
          <target state="translated">&lt;code&gt;M&lt;/code&gt; 에서 어떤 커밋 이 &lt;code&gt;D&lt;/code&gt; 에 의해 도입 된 버그로 오염되어 있고 수정이 필요한지 알아 내려면 실제로 &lt;code&gt;D&lt;/code&gt; 의 후손 인 &lt;code&gt;D..M&lt;/code&gt; 의 하위 집합 만 보려고 할 수 있습니다 ( 예 : &lt;code&gt;C&lt;/code&gt; 및 &lt;code&gt;K&lt;/code&gt; 제외) . 이것이 바로 &lt;code&gt;--ancestry-path&lt;/code&gt; 옵션의 기능입니다. &lt;code&gt;D..M&lt;/code&gt; 범위에 적용하면 다음과 같은 결과가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="bd2b751f52f03b9f39eaea429dccc385cd6f8cb7" translate="yes" xml:space="preserve">
          <source>When writing a script that is expected to handle random user-input, it is a good practice to make it explicit which arguments are which by placing disambiguating &lt;code&gt;--&lt;/code&gt; at appropriate places.</source>
          <target state="translated">임의의 사용자 입력을 처리 할 것으로 예상되는 스크립트를 작성할 때, 그것은 좋은 연습이 인수하는 명확하게하는 배치하여있는이 명시 적으로 만드는 것입니다 &lt;code&gt;--&lt;/code&gt; 적절한 장소에서.</target>
        </trans-unit>
        <trans-unit id="ec9cac719dc2571ad31301b21a571a63039a88c5" translate="yes" xml:space="preserve">
          <source>When writing remote-helpers for decentralized version control systems, it is advised to keep a local copy of the repository to interact with, and to let the private namespace refs point to this local repository, while the refs/remotes namespace is used to track the remote repository.</source>
          <target state="translated">분산 버전 제어 시스템에 대한 원격 헬퍼를 작성할 때 refs / remotes 네임 스페이스는 추적하는 데 사용되는 반면, 저장소의 로컬 사본이 상호 작용하고 개인 네임 스페이스 ref 가이 로컬 저장소를 가리 키도록하는 것이 좋습니다. 원격 저장소.</target>
        </trans-unit>
        <trans-unit id="20c75e316d5f2bc9ee11a82eb08a64c8e94c8af1" translate="yes" xml:space="preserve">
          <source>When writing, the new value is written to the repository local configuration file by default, and options &lt;code&gt;--system&lt;/code&gt;, &lt;code&gt;--global&lt;/code&gt;, &lt;code&gt;--worktree&lt;/code&gt;, &lt;code&gt;--file &amp;lt;filename&amp;gt;&lt;/code&gt; can be used to tell the command to write to that location (you can say &lt;code&gt;--local&lt;/code&gt; but that is the default).</source>
          <target state="translated">쓸 때 기본적으로 새 값이 저장소 로컬 구성 파일에 기록되고 &lt;code&gt;--system&lt;/code&gt; , &lt;code&gt;--global&lt;/code&gt; , &lt;code&gt;--worktree&lt;/code&gt; , &lt;code&gt;--file &amp;lt;filename&amp;gt;&lt;/code&gt; 옵션을 사용하여 명령에 해당 위치에 쓰도록 지시 할 수 있습니다 ( &lt;code&gt;--local&lt;/code&gt; 이라고 말할 수 있지만 이것이 기본값입니다).</target>
        </trans-unit>
        <trans-unit id="cd8a515ddc50bbc57c4721fd114c9828b7d7e56b" translate="yes" xml:space="preserve">
          <source>When you are happy with the state of this change, you can merge it into the &quot;test&quot; branch in preparation to make it public:</source>
          <target state="translated">이 변경 상태에 만족하면 변경 사항을 &quot;테스트&quot;분기로 병합하여 공개 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="778f60f4a64466f8d291144e663a70b4838a03f8" translate="yes" xml:space="preserve">
          <source>When you are in the middle of something, you learn that there are upstream changes that are possibly relevant to what you are doing. When your local changes do not conflict with the changes in the upstream, a simple &lt;code&gt;git pull&lt;/code&gt; will let you move forward.</source>
          <target state="translated">당신이 무언가의 중간에있을 때, 당신은 아마도 당신이하고있는 일과 관련이있는 상류 변화가 있음을 알게됩니다. 로컬 변경 사항이 업스트림 변경 사항과 충돌하지 않으면 간단한 &lt;code&gt;git pull&lt;/code&gt; 을 사용하여 앞으로 이동할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f6b623b307a4c06027202dc5b8021ae4a369fe95" translate="yes" xml:space="preserve">
          <source>When you are in the middle of something, your boss comes in and demands that you fix something immediately. Traditionally, you would make a commit to a temporary branch to store your changes away, and return to your original branch to make the emergency fix, like this:</source>
          <target state="translated">당신이 무언가의 중간에있을 때, 상사가 와서 즉시 무언가를 고치라고 요구합니다. 일반적으로 변경 사항을 저장하기 위해 임시 지점에 커밋하고 원래 지점으로 돌아가서 다음과 같이 응급 수정을 수행합니다.</target>
        </trans-unit>
        <trans-unit id="5dab203d26aab56f5ab1012e5091a813403ff2db" translate="yes" xml:space="preserve">
          <source>When you are interested in finding the origin for lines 40-60 for file &lt;code&gt;foo&lt;/code&gt;, you can use the &lt;code&gt;-L&lt;/code&gt; option like so (they mean the same thing &amp;mdash; both ask for 21 lines starting at line 40):</source>
          <target state="translated">&lt;code&gt;foo&lt;/code&gt; 파일에 대해 40-60 행의 원점을 찾는 데 관심 이있는 경우, &lt;code&gt;-L&lt;/code&gt; 옵션을 사용할 수 있습니다 (두 줄 40 행에서 21 행을 요청 함).</target>
        </trans-unit>
        <trans-unit id="709f7df580972f427522b82ef732f913e20c2078" translate="yes" xml:space="preserve">
          <source>When you are not interested in changes older than version v2.6.18, or changes older than 3 weeks, you can use revision range specifiers similar to &lt;code&gt;git rev-list&lt;/code&gt;:</source>
          <target state="translated">버전 v2.6.18 이전의 변경 사항 또는 3 주 이전의 변경 사항에 관심이없는 경우 &lt;code&gt;git rev-list&lt;/code&gt; 와 유사한 개정 범위 지정자를 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="da9f31c43174e26846193d472d4442e982c36d7b" translate="yes" xml:space="preserve">
          <source>When you are working in a small closely knit group, it is not unusual to interact with the same repository over and over again. By defining &lt;code&gt;remote&lt;/code&gt; repository shorthand, you can make it easier:</source>
          <target state="translated">작고 밀접한 그룹에서 작업 할 때 동일한 저장소와 반복해서 상호 작용하는 것은 드문 일이 아닙니다. &lt;code&gt;remote&lt;/code&gt; 저장소를 속기 로 정의 하면보다 쉽게 ​​만들 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9ac50cc4cb199a994adc57ff3704f94a4fe6fd25" translate="yes" xml:space="preserve">
          <source>When you ask &lt;a href=&quot;git-diff&quot;&gt;git-diff[1]&lt;/a&gt; to show the conflicts, it runs a three-way diff between the conflicted merge results in the work tree with stages 2 and 3 to show only hunks whose contents come from both sides, mixed (in other words, when a hunk&amp;rsquo;s merge results come only from stage 2, that part is not conflicting and is not shown. Same for stage 3).</source>
          <target state="translated">&lt;a href=&quot;git-diff&quot;&gt;git-diff [1]&lt;/a&gt; 에게 충돌을 보여 달라고 요청하면 , 단계 2와 3의 작업 트리에서 충돌 된 병합 결과 사이에 3 방향 차이를 실행하여 내용이 양쪽에서 나온 덩어리 만 표시합니다 (기타 즉, 덩어리의 병합 결과가 2 단계에서만 나오면 해당 부분은 충돌하지 않으며 표시되지 않습니다 (3 단계와 동일).</target>
        </trans-unit>
        <trans-unit id="3f0add0b9e7571c844c4ae8fb98b59f1c64d874a" translate="yes" xml:space="preserve">
          <source>When you run &lt;code&gt;git checkout &amp;lt;something&amp;gt;&lt;/code&gt; or &lt;code&gt;git switch &amp;lt;something&amp;gt;&lt;/code&gt; and only have one remote, it may implicitly fall back on checking out and tracking e.g. &lt;code&gt;origin/&amp;lt;something&amp;gt;&lt;/code&gt;. This stops working as soon as you have more than one remote with a &lt;code&gt;&amp;lt;something&amp;gt;&lt;/code&gt; reference. This setting allows for setting the name of a preferred remote that should always win when it comes to disambiguation. The typical use-case is to set this to &lt;code&gt;origin&lt;/code&gt;.</source>
          <target state="translated">당신이 실행하면 &lt;code&gt;git checkout &amp;lt;something&amp;gt;&lt;/code&gt; 또는 &lt;code&gt;git switch &amp;lt;something&amp;gt;&lt;/code&gt; 만 원격 하나를 가지고, 그것은 암시 적으로 체크 아웃하고 예를 들어 추적에 다시 떨어질 수 &lt;code&gt;origin/&amp;lt;something&amp;gt;&lt;/code&gt; . &lt;code&gt;&amp;lt;something&amp;gt;&lt;/code&gt; 참조 가있는 리모콘이 둘 이상있는 즉시 작동이 중지됩니다 . 이 설정을 통해 선호하는 리모컨의 이름을 명확하게 지정할 수 있습니다. 일반적인 유스 케이스는 이것을 &lt;code&gt;origin&lt;/code&gt; 으로 설정하는 것 입니다 .</target>
        </trans-unit>
        <trans-unit id="9f93e702904ad75a7ffcc41597ebc2474895e0b0" translate="yes" xml:space="preserve">
          <source>When you start a 3-way merge with an index file that is already populated, it is assumed that it represents the state of the files in your work tree, and you can even have files with changes unrecorded in the index file. It is further assumed that this state is &quot;derived&quot; from the stage 2 tree. The 3-way merge refuses to run if it finds an entry in the original index file that does not match stage 2.</source>
          <target state="translated">이미 채워진 인덱스 파일과의 3 방향 병합을 시작하면 작업 트리에있는 파일의 상태를 나타내며 인덱스 파일에 변경 사항이 기록되지 않은 파일도있을 수 있습니다. 또한이 상태는 2 단계 트리에서 &quot;유도&quot;된 것으로 가정합니다. 3 단계 병합은 원래 인덱스 파일에서 2 단계와 일치하지 않는 항목을 찾으면 실행을 거부합니다.</target>
        </trans-unit>
        <trans-unit id="6831d00e1f830a484b6c5799e343f596bbc55899" translate="yes" xml:space="preserve">
          <source>When you want to just integrate with the work leading to the commit that happens to be tagged, e.g. synchronizing with an upstream release point, you may not want to make an unnecessary merge commit.</source>
          <target state="translated">업스트림 릴리스 포인트와 동기화하는 등 태그가 붙은 커밋을 일으키는 작업과 통합하려는 경우 불필요한 병합 커밋을 원하지 않을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2f28e5d62e5a87453e903e81e941382b8ac566c1" translate="yes" xml:space="preserve">
          <source>When you&amp;rsquo;re ready, just run</source>
          <target state="translated">준비가되면 그냥 달려</target>
        </trans-unit>
        <trans-unit id="4aa6b6296b8d97b342099d335ec15bc55634ad41" translate="yes" xml:space="preserve">
          <source>When your topic branch is long-lived, however, your topic branch would end up having many such &quot;Merge from master&quot; commits on it, which would unnecessarily clutter the development history. Readers of the Linux kernel mailing list may remember that Linus complained about such too frequent test merges when a subsystem maintainer asked to pull from a branch full of &quot;useless merges&quot;.</source>
          <target state="translated">그러나 토픽 브랜치가 오래 지속되면 토픽 브랜치에 &quot;마스터에서 병합&quot;커밋이 많이 발생하여 개발 히스토리가 불필요하게 복잡해집니다. 리눅스 커널 메일 링리스트를 읽는 사람들은 서브 시스템 관리자가 &quot;무용 한 병합&quot;으로 가득 찬 지점에서 가져 오기를 요청했을 때 Linus가 너무 빈번한 테스트 병합에 대해 불평했다는 것을 기억할 것입니다.</target>
        </trans-unit>
        <trans-unit id="bd4128428344ae6c28977b2bc5cf00953da1175f" translate="yes" xml:space="preserve">
          <source>When your topic branch modifies an overlapping area that your master branch (or upstream) touched since your topic branch forked from it, you may want to test it with the latest master, even before your topic branch is ready to be pushed upstream:</source>
          <target state="translated">주제 분기가 분기 된 이후 주제 분기 (또는 업스트림)가 터치 한 겹치는 영역을 주제 분기에서 수정하는 경우 주제 분기를 업스트림으로 푸시 할 준비가되기 전에도 최신 마스터로 테스트 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4f4eaf255ffc69df0530167a4810c74e9370cd43" translate="yes" xml:space="preserve">
          <source>Whenever possible, section headings should clearly describe the task they explain how to do, in language that requires no more knowledge than necessary: for example, &quot;importing patches into a project&quot; rather than &quot;the &lt;code&gt;git am&lt;/code&gt; command&quot;</source>
          <target state="translated">가능할 때마다 섹션 제목에는 필요한 것 이상의 지식이 필요없는 언어 (예 : &quot; &lt;code&gt;git am&lt;/code&gt; 명령&quot; 대신 &quot;프로젝트로 패치 가져 오기&quot;)로 수행하는 작업을 명확하게 설명해야합니다.</target>
        </trans-unit>
        <trans-unit id="11683716a14fb2e59c3ad4d48a607606706a0329" translate="yes" xml:space="preserve">
          <source>Where &quot;oldsha1&quot; is the 40 character hexadecimal value previously stored in &amp;lt;ref&amp;gt;, &quot;newsha1&quot; is the 40 character hexadecimal value of &amp;lt;newvalue&amp;gt; and &quot;committer&quot; is the committer&amp;rsquo;s name, email address and date in the standard Git committer ident format.</source>
          <target state="translated">&quot;oldsha1&quot;은 이전에 &amp;lt;ref&amp;gt;에 저장된 40 자의 16 진 값이고, &quot;newsha1&quot;은 &amp;lt;newvalue&amp;gt;의 40 자의 16 진 값이고 &quot;committer&quot;는 표준 Git 커미터 ID 형식의 커미터 이름, 이메일 주소 및 날짜입니다. .</target>
        </trans-unit>
        <trans-unit id="9a6682bd90b10ed7b65387d46ac6e3098ba208ce" translate="yes" xml:space="preserve">
          <source>Where all fields are as described above and &quot;message&quot; is the value supplied to the -m option.</source>
          <target state="translated">모든 필드가 위에서 설명한대로 &quot;message&quot;는 -m 옵션에 제공된 값입니다.</target>
        </trans-unit>
        <trans-unit id="1047cdb3a9504c1e49ba180691c6de133fb29736" translate="yes" xml:space="preserve">
          <source>Where to create the Git repository. If not provided, the last component in the p4 depot path is used to create a new directory.</source>
          <target state="translated">Git 리포지토리를 생성 할 위치 제공되지 않은 경우 p4 저장소 경로의 마지막 구성 요소가 새 디렉토리를 작성하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="de8afe671960d7a395defa2e40a80901d96e2485" translate="yes" xml:space="preserve">
          <source>Whereas &lt;code&gt;--batch-check='%(objectname) %(objecttype)'&lt;/code&gt; would produce:</source>
          <target state="translated">반면 &lt;code&gt;--batch-check='%(objectname) %(objecttype)'&lt;/code&gt; 은 다음을 생성합니다.</target>
        </trans-unit>
        <trans-unit id="92669e9b8b127c2ba15691914d72dae97b880d0d" translate="yes" xml:space="preserve">
          <source>Whether Git detects directory renames, affecting what happens at merge time to new files added to a directory on one side of history when that directory was renamed on the other side of history. If merge.directoryRenames is set to &quot;false&quot;, directory rename detection is disabled, meaning that such new files will be left behind in the old directory. If set to &quot;true&quot;, directory rename detection is enabled, meaning that such new files will be moved into the new directory. If set to &quot;conflict&quot;, a conflict will be reported for such paths. If merge.renames is false, merge.directoryRenames is ignored and treated as false. Defaults to &quot;conflict&quot;.</source>
          <target state="translated">Git이 디렉토리 이름 바꾸기를 감지하는지 여부는 해당 디렉토리가 히스토리의 다른 쪽에서 이름이 바뀔 때 히스토리의 한쪽에있는 디렉토리에 추가 된 새 파일에 병합시 발생하는 영향에 영향을줍니다. merge.directoryRenames가 &quot;false&quot;로 설정되면 디렉토리 이름 바꾸기 감지가 사용 불가능하게되어 새 파일이 이전 디렉토리에 남게됩니다. &quot;true&quot;로 설정하면 디렉토리 이름 바꾸기 감지가 사용됩니다. 이는 새 파일이 새 디렉토리로 이동 함을 의미합니다. &quot;충돌&quot;로 설정하면 해당 경로에 대한 충돌이보고됩니다. merge.renames가 false이면 merge.directoryRenames가 무시되고 false로 처리됩니다. 기본값은 &quot;충돌&quot;입니다.</target>
        </trans-unit>
        <trans-unit id="6720b94e3bf2c12c61b3c14de0415d18239394a0" translate="yes" xml:space="preserve">
          <source>Whether Git detects renames. If set to &quot;false&quot;, rename detection is disabled. If set to &quot;true&quot;, basic rename detection is enabled. Defaults to the value of diff.renames.</source>
          <target state="translated">Git이 이름 변경을 감지하는지 여부 &quot;false&quot;로 설정하면 이름 바꾸기 감지가 비활성화됩니다. &quot;true&quot;로 설정하면 기본 이름 변경 감지가 사용됩니다. 기본값은 diff.renames입니다.</target>
        </trans-unit>
        <trans-unit id="d1f68ec7a1f81e21d54ab2e76eaccedf11117ff8" translate="yes" xml:space="preserve">
          <source>Whether and how Git detects renames in &lt;a href=&quot;git-status&quot;&gt;git-status[1]&lt;/a&gt; and &lt;a href=&quot;git-commit&quot;&gt;git-commit[1]&lt;/a&gt; . If set to &quot;false&quot;, rename detection is disabled. If set to &quot;true&quot;, basic rename detection is enabled. If set to &quot;copies&quot; or &quot;copy&quot;, Git will detect copies, as well. Defaults to the value of diff.renames.</source>
          <target state="translated">Git이 &lt;a href=&quot;git-status&quot;&gt;git-status [1]&lt;/a&gt; 및 &lt;a href=&quot;git-commit&quot;&gt;git-commit [1]&lt;/a&gt; 에서 이름 변경을 감지하는지 여부와 방법 . &quot;false&quot;로 설정하면 이름 바꾸기 감지가 비활성화됩니다. &quot;true&quot;로 설정하면 기본 이름 변경 감지가 사용됩니다. &quot;복사본&quot;또는 &quot;복사본&quot;으로 설정하면 Git은 복사본도 감지합니다. 기본값은 diff.renames입니다.</target>
        </trans-unit>
        <trans-unit id="cd914284b278d491020fec9d972b776a56df2f14" translate="yes" xml:space="preserve">
          <source>Whether and how Git detects renames. If set to &quot;false&quot;, rename detection is disabled. If set to &quot;true&quot;, basic rename detection is enabled. If set to &quot;copies&quot; or &quot;copy&quot;, Git will detect copies, as well. Defaults to true. Note that this affects only &lt;code&gt;git diff&lt;/code&gt; Porcelain like &lt;a href=&quot;git-diff&quot;&gt;git-diff[1]&lt;/a&gt; and &lt;a href=&quot;git-log&quot;&gt;git-log[1]&lt;/a&gt;, and not lower level commands such as &lt;a href=&quot;git-diff-files&quot;&gt;git-diff-files[1]&lt;/a&gt;.</source>
          <target state="translated">Git이 이름 변경을 감지하는지 여부와 방법. &quot;false&quot;로 설정하면 이름 바꾸기 감지가 비활성화됩니다. &quot;true&quot;로 설정하면 기본 이름 변경 감지가 사용됩니다. &quot;복사본&quot;또는 &quot;복사본&quot;으로 설정하면 Git은 복사본도 감지합니다. 기본값은 true입니다. 이는 &lt;a href=&quot;git-diff&quot;&gt;git-diff [1]&lt;/a&gt; 및 &lt;a href=&quot;git-log&quot;&gt;git-log [1]&lt;/a&gt; 과 같은 &lt;code&gt;git diff&lt;/code&gt; Porcelain 에만 영향을 미치며 &lt;a href=&quot;git-diff-files&quot;&gt;git-diff-files [1]&lt;/a&gt; 와 같은 하위 수준 명령에는 영향을주지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="2329b3f81f31d1e7aac7efc37e396ae5ccc9b5fe" translate="yes" xml:space="preserve">
          <source>Whether git should follow HTTP redirects. If set to &lt;code&gt;true&lt;/code&gt;, git will transparently follow any redirect issued by a server it encounters. If set to &lt;code&gt;false&lt;/code&gt;, git will treat all redirects as errors. If set to &lt;code&gt;initial&lt;/code&gt;, git will follow redirects only for the initial request to a remote, but not for subsequent follow-up HTTP requests. Since git uses the redirected URL as the base for the follow-up requests, this is generally sufficient. The default is &lt;code&gt;initial&lt;/code&gt;.</source>
          <target state="translated">git이 HTTP 리디렉션을 따라야하는지 여부입니다. &lt;code&gt;true&lt;/code&gt; 로 설정하면 git은 서버에서 발생한 모든 리디렉션을 투명하게 따릅니다. &lt;code&gt;false&lt;/code&gt; 로 설정하면 git은 모든 리디렉션을 오류로 처리합니다. &lt;code&gt;initial&lt;/code&gt; 으로 설정하면 git은 초기 요청에 대해서만 원격으로 리디렉션하지만 후속 후속 HTTP 요청에는 리디렉션하지 않습니다. git은 후속 요청의 기반으로 리디렉션 된 URL을 사용하기 때문에 일반적으로 충분합니다. 기본값은 &lt;code&gt;initial&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="cd0092aedf4252969afafd8803ba8faf98999493" translate="yes" xml:space="preserve">
          <source>Whether that update is allowed without &lt;code&gt;--force&lt;/code&gt; depends on the ref namespace it&amp;rsquo;s being fetched to, the type of object being fetched, and whether the update is considered to be a fast-forward. Generally, the same rules apply for fetching as when pushing, see the &lt;code&gt;&amp;lt;refspec&amp;gt;...&lt;/code&gt; section of &lt;a href=&quot;git-push&quot;&gt;git-push[1]&lt;/a&gt; for what those are. Exceptions to those rules particular to &lt;code&gt;git fetch&lt;/code&gt; are noted below.</source>
          <target state="translated">&lt;code&gt;--force&lt;/code&gt; 없이 업데이트가 허용되는지 여부 는 가져 오는 ref 네임 스페이스, 가져 오는 객체의 유형 및 업데이트가 빠른 것으로 간주되는지 여부에 따라 다릅니다. 일반적으로, 푸시 할 때와 같은 규칙이 페치에 적용됩니다. &lt;a href=&quot;git-push&quot;&gt;git-push [1]&lt;/a&gt; 의 &lt;code&gt;&amp;lt;refspec&amp;gt;...&lt;/code&gt; 섹션을 참조하십시오 . &lt;code&gt;git fetch&lt;/code&gt; 와 관련된 규칙에 대한 예외 는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="9c31395d6226db0f96527cf13d7284a32596aaef" translate="yes" xml:space="preserve">
          <source>Whether the CVS server interface is enabled for this repository. See &lt;a href=&quot;git-cvsserver&quot;&gt;git-cvsserver[1]&lt;/a&gt;.</source>
          <target state="translated">이 저장소에 CVS 서버 인터페이스가 사용 가능한지 여부 &lt;a href=&quot;git-cvsserver&quot;&gt;git-cvsserver [1]을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="e99c94b5e67663cef6460c2b09cda34348e975de" translate="yes" xml:space="preserve">
          <source>Whether to enable the grouping of projects by category on the project list page. The category of a project is determined by the &lt;code&gt;$GIT_DIR/category&lt;/code&gt; file or the &lt;code&gt;gitweb.category&lt;/code&gt; variable in each repository&amp;rsquo;s configuration. Disabled by default (set to 0).</source>
          <target state="translated">프로젝트 목록 페이지에서 카테고리별로 프로젝트를 그룹화 할 수 있는지 여부 프로젝트 &lt;code&gt;$GIT_DIR/category&lt;/code&gt; 는 각 저장소 구성 의 $ &lt;code&gt;gitweb.category&lt;/code&gt; / category 파일 또는 gitweb.category 변수에 의해 결정됩니다 . 기본적으로 비활성화되어 있습니다 (0으로 설정).</target>
        </trans-unit>
        <trans-unit id="be60442dc9a2bb750c3ffb3e91f602fa8cf454b7" translate="yes" xml:space="preserve">
          <source>Whether to print the diffstat between ORIG_HEAD and the merge result at the end of the merge. True by default.</source>
          <target state="translated">ORIG_HEAD와 병합 종료시 병합 결과 사이의 diffstat를 인쇄할지 여부. 기본적으로 true입니다.</target>
        </trans-unit>
        <trans-unit id="e6d010b4fa5fb27d92c64dc2f59319c4e77b544c" translate="yes" xml:space="preserve">
          <source>Whether to show a diffstat of what changed upstream since the last rebase. False by default.</source>
          <target state="translated">마지막 리베이스 이후 업스트림에서 변경된 내용의 차이를 표시할지 여부입니다. 기본적으로 False입니다.</target>
        </trans-unit>
        <trans-unit id="2153c59644d7df4b2ed210d8ef453074b1a6c2ac" translate="yes" xml:space="preserve">
          <source>Whether to skip reading settings from the system-wide $(prefix)/etc/gitconfig file. See &lt;a href=&quot;git&quot;&gt;git[1]&lt;/a&gt; for details.</source>
          <target state="translated">시스템 전체 $ (prefix) / etc / gitconfig 파일에서 설정 읽기를 건너 뛸지 여부입니다. 자세한 내용은 &lt;a href=&quot;git&quot;&gt;git [1]&lt;/a&gt; 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="7c8173d7da296bd9c5f5aef35e3d739c8852bc79" translate="yes" xml:space="preserve">
          <source>Whether to skip reading settings from the system-wide &lt;code&gt;$(prefix)/etc/gitconfig&lt;/code&gt; file. This environment variable can be used along with &lt;code&gt;$HOME&lt;/code&gt; and &lt;code&gt;$XDG_CONFIG_HOME&lt;/code&gt; to create a predictable environment for a picky script, or you can set it temporarily to avoid using a buggy &lt;code&gt;/etc/gitconfig&lt;/code&gt; file while waiting for someone with sufficient permissions to fix it.</source>
          <target state="translated">시스템 전체 &lt;code&gt;$(prefix)/etc/gitconfig&lt;/code&gt; 파일 에서 설정 읽기를 건너 뛸지 여부 입니다. 이 환경 변수를 &lt;code&gt;$HOME&lt;/code&gt; 및 &lt;code&gt;$XDG_CONFIG_HOME&lt;/code&gt; 과 함께 사용 하여 까다로운 스크립트를위한 예측 가능한 환경을 만들거나 버그가있는 &lt;code&gt;/etc/gitconfig&lt;/code&gt; 파일을 사용하지 않고 임시로 설정 하여 문제를 해결할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="488ddc0ec5d5c663a8e8059a323ed70db5316b78" translate="yes" xml:space="preserve">
          <source>Whether to use ANSI escape sequences to add color to patches. If this is set to &lt;code&gt;always&lt;/code&gt;, &lt;a href=&quot;git-diff&quot;&gt;git-diff[1]&lt;/a&gt;, &lt;a href=&quot;git-log&quot;&gt;git-log[1]&lt;/a&gt;, and &lt;a href=&quot;git-show&quot;&gt;git-show[1]&lt;/a&gt; will use color for all patches. If it is set to &lt;code&gt;true&lt;/code&gt; or &lt;code&gt;auto&lt;/code&gt;, those commands will only use color when output is to the terminal. If unset, then the value of &lt;code&gt;color.ui&lt;/code&gt; is used (&lt;code&gt;auto&lt;/code&gt; by default).</source>
          <target state="translated">패치에 색상을 추가하기 위해 ANSI 이스케이프 시퀀스를 사용할지 여부 이로 설정하면 &lt;code&gt;always&lt;/code&gt; , &lt;a href=&quot;git-diff&quot;&gt;자식-DIFF는 [1]&lt;/a&gt; , &lt;a href=&quot;git-log&quot;&gt;자식 로그 [1]&lt;/a&gt; , 그리고 &lt;a href=&quot;git-show&quot;&gt;자식 쇼 [1]&lt;/a&gt; 모든 패치의 색상을 사용합니다. &lt;code&gt;true&lt;/code&gt; 또는 &lt;code&gt;auto&lt;/code&gt; 로 설정된 경우 해당 명령은 출력이 터미널로 출력 될 때만 색상을 사용합니다. 설정하지 않으면 &lt;code&gt;color.ui&lt;/code&gt; 의 값 이 사용됩니다 ( 기본적으로 &lt;code&gt;auto&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="21386b2036d855c8d8dd6eb4c84085329fcf2561" translate="yes" xml:space="preserve">
          <source>Whether to use empty blobs as rename source.</source>
          <target state="translated">빈 BLOB을 이름 바꾸기 소스로 사용할지 여부입니다.</target>
        </trans-unit>
        <trans-unit id="63ea1a80cc99dbbdec2d362a1b57aa7468c9ed6d" translate="yes" xml:space="preserve">
          <source>Whether to verify the SSL certificate when fetching or pushing over HTTPS. Defaults to true. Can be overridden by the &lt;code&gt;GIT_SSL_NO_VERIFY&lt;/code&gt; environment variable.</source>
          <target state="translated">HTTPS를 가져 오거나 푸시 할 때 SSL 인증서를 확인할지 여부입니다. 기본값은 true입니다. &lt;code&gt;GIT_SSL_NO_VERIFY&lt;/code&gt; 환경 변수 로 대체 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="ec9fdb5354be84561f27023760593b27a86cd126" translate="yes" xml:space="preserve">
          <source>Which file to place a pattern in depends on how the pattern is meant to be used.</source>
          <target state="translated">패턴을 배치 할 파일은 패턴의 사용 방법에 따라 다릅니다.</target>
        </trans-unit>
        <trans-unit id="9342c5a7ca74e113fca6826c098da1e9dea46c59" translate="yes" xml:space="preserve">
          <source>Which merge strategy to choose by default when resolving notes conflicts. Must be one of &lt;code&gt;manual&lt;/code&gt;, &lt;code&gt;ours&lt;/code&gt;, &lt;code&gt;theirs&lt;/code&gt;, &lt;code&gt;union&lt;/code&gt;, or &lt;code&gt;cat_sort_uniq&lt;/code&gt;. Defaults to &lt;code&gt;manual&lt;/code&gt;. See &quot;NOTES MERGE STRATEGIES&quot; section above for more information on each strategy.</source>
          <target state="translated">메모 충돌을 해결할 때 기본적으로 선택할 병합 전략 중 하나 여야합니다 &lt;code&gt;manual&lt;/code&gt; , &lt;code&gt;ours&lt;/code&gt; , &lt;code&gt;theirs&lt;/code&gt; , &lt;code&gt;union&lt;/code&gt; , 또는 &lt;code&gt;cat_sort_uniq&lt;/code&gt; . 기본값은 &lt;code&gt;manual&lt;/code&gt; 입니다. 각 전략에 대한 자세한 내용은 위의 &quot;NOTES MERGE STRATEGIES&quot;섹션을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="7dd75dabb694bc7182031b6cdb5c605283f3ff3a" translate="yes" xml:space="preserve">
          <source>Which merge strategy to choose by default when resolving notes conflicts. Must be one of &lt;code&gt;manual&lt;/code&gt;, &lt;code&gt;ours&lt;/code&gt;, &lt;code&gt;theirs&lt;/code&gt;, &lt;code&gt;union&lt;/code&gt;, or &lt;code&gt;cat_sort_uniq&lt;/code&gt;. Defaults to &lt;code&gt;manual&lt;/code&gt;. See &quot;NOTES MERGE STRATEGIES&quot; section of &lt;a href=&quot;git-notes&quot;&gt;git-notes[1]&lt;/a&gt; for more information on each strategy.</source>
          <target state="translated">메모 충돌을 해결할 때 기본적으로 선택할 병합 전략 중 하나 여야합니다 &lt;code&gt;manual&lt;/code&gt; , &lt;code&gt;ours&lt;/code&gt; , &lt;code&gt;theirs&lt;/code&gt; , &lt;code&gt;union&lt;/code&gt; , 또는 &lt;code&gt;cat_sort_uniq&lt;/code&gt; . 기본값은 &lt;code&gt;manual&lt;/code&gt; 입니다. 각 전략에 대한 자세한 내용 은 &lt;a href=&quot;git-notes&quot;&gt;git-notes [1]&lt;/a&gt; 의 &quot;NOTES MERGE 전략&quot;섹션 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="9bd73c0d97037644e549ed3fed8d2491f5cfc8e0" translate="yes" xml:space="preserve">
          <source>Which merge strategy to choose when doing a notes merge into refs/notes/&amp;lt;name&amp;gt;. This overrides the more general &quot;notes.mergeStrategy&quot;. See the &quot;NOTES MERGE STRATEGIES&quot; section above for more information on each available strategy.</source>
          <target state="translated">노트를 수행 할 때 선택할 병합 전략은 refs / notes / &amp;lt;name&amp;gt;에 병합됩니다. 이것은 더 일반적인 &quot;notes.mergeStrategy&quot;를 대체합니다. 사용 가능한 각 전략에 대한 자세한 내용은 위의 &quot;NOTES MERGE STRATEGIES&quot;섹션을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="f202b61699020bcfa082fe897d7a8560aea486a1" translate="yes" xml:space="preserve">
          <source>Which merge strategy to choose when doing a notes merge into refs/notes/&amp;lt;name&amp;gt;. This overrides the more general &quot;notes.mergeStrategy&quot;. See the &quot;NOTES MERGE STRATEGIES&quot; section in &lt;a href=&quot;git-notes&quot;&gt;git-notes[1]&lt;/a&gt; for more information on the available strategies.</source>
          <target state="translated">노트를 수행 할 때 선택할 병합 전략은 refs / notes / &amp;lt;name&amp;gt;에 병합됩니다. 이것은 더 일반적인 &quot;notes.mergeStrategy&quot;를 대체합니다. 사용 가능한 전략에 대한 자세한 내용 은 &lt;a href=&quot;git-notes&quot;&gt;git-notes [1]&lt;/a&gt; 의 &quot;NOTES MERGE 전략&quot;섹션 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="556a322f94dd1e45943ded0ebea9906e93ca0c80" translate="yes" xml:space="preserve">
          <source>Which ref (or refs, if a glob or specified more than once), in addition to the default set by &lt;code&gt;core.notesRef&lt;/code&gt; or &lt;code&gt;GIT_NOTES_REF&lt;/code&gt;, to read notes from when showing commit messages with the &lt;code&gt;git log&lt;/code&gt; family of commands. This setting can be overridden on the command line or by the &lt;code&gt;GIT_NOTES_DISPLAY_REF&lt;/code&gt; environment variable. See &lt;a href=&quot;git-log&quot;&gt;git-log[1]&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;core.notesRef&lt;/code&gt; 또는 &lt;code&gt;GIT_NOTES_REF&lt;/code&gt; 에 의해 설정된 기본값 외에 &lt;code&gt;git log&lt;/code&gt; 계열 명령으로 커밋 메시지를 표시 할 때 메모를 읽을 수있는 참조 (또는 glob 또는 두 번 이상 지정된 경우 참조) 이 설정은 명령 행 또는 &lt;code&gt;GIT_NOTES_DISPLAY_REF&lt;/code&gt; 환경 변수 로 대체 할 수 있습니다 . &lt;a href=&quot;git-log&quot;&gt;git-log [1]을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="08e8ee8d98ea130471cc368fbf1a571f3d29a34d" translate="yes" xml:space="preserve">
          <source>Which ref to manipulate notes from, instead of &lt;code&gt;refs/notes/commits&lt;/code&gt;. This overrides the &lt;code&gt;core.notesRef&lt;/code&gt; setting.</source>
          <target state="translated">어떤에서 대신 메모를 조작하는 심판 &lt;code&gt;refs/notes/commits&lt;/code&gt; . 이것은 &lt;code&gt;core.notesRef&lt;/code&gt; 설정을 무시합니다 .</target>
        </trans-unit>
        <trans-unit id="180171a89f79828ca3aedfa4194b8ff07f802f3f" translate="yes" xml:space="preserve">
          <source>Which refs, in addition to the default set by &lt;code&gt;core.notesRef&lt;/code&gt; or &lt;code&gt;GIT_NOTES_REF&lt;/code&gt;, to read notes from when showing commit messages with the &lt;code&gt;log&lt;/code&gt; family of commands. See &lt;a href=&quot;git-notes&quot;&gt;git-notes[1]&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;core.notesRef&lt;/code&gt; 또는 &lt;code&gt;GIT_NOTES_REF&lt;/code&gt; 에 의해 설정된 기본값 외에 &lt;code&gt;log&lt;/code&gt; 명령 군으로 커밋 메시지를 표시 할 때 메모를 읽는 참조 &lt;a href=&quot;git-notes&quot;&gt;git-notes [1]을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="f4dbbdac6096ee85d080e618f1dfec3eb7804653" translate="yes" xml:space="preserve">
          <source>Which will add the following to a file named &lt;code&gt;.gitconfig&lt;/code&gt; in your home directory:</source>
          <target state="translated">홈 디렉토리의 &lt;code&gt;.gitconfig&lt;/code&gt; 파일에 다음을 추가합니다 .</target>
        </trans-unit>
        <trans-unit id="0b383fc769f1bfb4acb136b5be3ea84e9742db33" translate="yes" xml:space="preserve">
          <source>Which would result in:</source>
          <target state="translated">결과는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="5efe59371f7c539c77a16fb753d65287a4a1a881" translate="yes" xml:space="preserve">
          <source>While &lt;code&gt;$GIT_DIR/info/sparse-checkout&lt;/code&gt; is usually used to specify what files are in, you can also specify what files are &lt;code&gt;not&lt;/code&gt; in, using negate patterns. For example, to remove the file &lt;code&gt;unwanted&lt;/code&gt;:</source>
          <target state="translated">하지만 &lt;code&gt;$GIT_DIR/info/sparse-checkout&lt;/code&gt; 보통 파일에 무엇을 지정하는 데 사용됩니다, 당신은 또한 파일이 무엇인지를 지정할 수 &lt;code&gt;not&lt;/code&gt; 부정 패턴을 사용하여,에. 예를 들어, 파일을 제거하려면 &lt;code&gt;unwanted&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="133c634c89411bc7bbb73a5aa8f4cda72b5442c2" translate="yes" xml:space="preserve">
          <source>While &lt;code&gt;$GIT_DIR/info/sparse-checkout&lt;/code&gt; is usually used to specify what files are included, you can also specify what files are &lt;code&gt;not&lt;/code&gt; included, using negative patterns. For example, to remove the file &lt;code&gt;unwanted&lt;/code&gt;:</source>
          <target state="translated">하지만 &lt;code&gt;$GIT_DIR/info/sparse-checkout&lt;/code&gt; 일반적으로 파일이 포함되어있는 것을 지정하는 데 사용됩니다, 당신은 또한 파일이 무엇인지를 지정할 수 &lt;code&gt;not&lt;/code&gt; 부정적인 패턴을 사용하여, 포함되어 있습니다. 예를 들어, 파일을 제거하려면 &lt;code&gt;unwanted&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="118bfe73a3b1ef14dd8bb7fedadb7cb55f01bcfb" translate="yes" xml:space="preserve">
          <source>While &lt;code&gt;&amp;lt;rev&amp;gt;^&amp;lt;n&amp;gt;&lt;/code&gt; was about specifying a single commit parent, these three notations also consider its parents. For example you can say &lt;code&gt;HEAD^2^@&lt;/code&gt;, however you cannot say &lt;code&gt;HEAD^@^2&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&amp;lt;rev&amp;gt;^&amp;lt;n&amp;gt;&lt;/code&gt; 은 단일 커밋 부모를 지정하는 것이 었지만 이 세 가지 표기법은 부모를 고려합니다. 예를 들어 &lt;code&gt;HEAD^2^@&lt;/code&gt; 말할 수 있지만 &lt;code&gt;HEAD^@^2&lt;/code&gt; 말할 수는 없습니다 .</target>
        </trans-unit>
        <trans-unit id="92e92ccd1a34f0875d32051d1b819b76c11daddf" translate="yes" xml:space="preserve">
          <source>While &lt;code&gt;git archimport&lt;/code&gt; will try to create sensible branch names for the archives that it imports, it is also possible to specify Git branch names manually. To do so, write a Git branch name after each &amp;lt;archive/branch&amp;gt; parameter, separated by a colon. This way, you can shorten the Arch branch names and convert Arch jargon to Git jargon, for example mapping a &quot;PROJECT{litdd}devo{litdd}VERSION&quot; branch to &quot;master&quot;.</source>
          <target state="translated">&lt;code&gt;git archimport&lt;/code&gt; 는 가져 오는 아카이브에 대해 합리적인 지점 이름을 만들려고 시도 하지만 Git 지점 이름을 수동으로 지정할 수도 있습니다. 이렇게하려면 각 &amp;lt;archive / branch&amp;gt; 매개 변수 뒤에 콜론으로 구분하여 Git 브랜치 이름을 작성하십시오. 이런 식으로 아치 분기 이름을 줄이고 아치 전문 용어를 Git 전문 용어로 변환 할 수 있습니다 (예 : &quot;PROJECT {litdd} devo {litdd} VERSION&quot;분기를 &quot;master&quot;에 매핑).</target>
        </trans-unit>
        <trans-unit id="6e3c7753b36510ea58174f6c4603b4398587f401" translate="yes" xml:space="preserve">
          <source>While &lt;code&gt;git log -G&quot;regexec\(regexp&quot;&lt;/code&gt; will show this commit, &lt;code&gt;git log
-S&quot;regexec\(regexp&quot; --pickaxe-regex&lt;/code&gt; will not (because the number of occurrences of that string did not change).</source>
          <target state="translated">하지만 &lt;code&gt;git log -G&quot;regexec\(regexp&quot;&lt;/code&gt; 이 커밋 표시됩니다 &lt;code&gt;git log -S&quot;regexec\(regexp&quot; --pickaxe-regex&lt;/code&gt; 하지 않습니다 (해당 문자열의 발생 수) 변경하지 않은 때문이다.</target>
        </trans-unit>
        <trans-unit id="9fa3ab181478a04a41a15d625153bef4e8a57c74" translate="yes" xml:space="preserve">
          <source>While &lt;code&gt;git svn&lt;/code&gt; can track copy history (including branches and tags) for repositories adopting a standard layout, it cannot yet represent merge history that happened inside git back upstream to SVN users. Therefore it is advised that users keep history as linear as possible inside Git to ease compatibility with SVN (see the CAVEATS section below).</source>
          <target state="translated">&lt;code&gt;git svn&lt;/code&gt; 은 표준 레이아웃을 채택한 리포지토리에 대한 복사 기록 (분기 및 태그 포함)을 추적 할 수 있지만 SVN 사용자에게 git back 상류에서 발생한 병합 기록을 아직 나타낼 수는 없습니다. 따라서 사용자는 SVN과의 호환성을 쉽게하기 위해 Git 내에서 가능한 한 히스토리를 선형으로 유지하는 것이 좋습니다 (아래의 CAVEATS 섹션 참조).</target>
        </trans-unit>
        <trans-unit id="6dffb65164b8303d8f69a39b7acb7d5c91ede142" translate="yes" xml:space="preserve">
          <source>While Git normally leaves file contents alone, it can be configured to normalize line endings to LF in the repository and, optionally, to convert them to CRLF when files are checked out.</source>
          <target state="translated">Git은 일반적으로 파일 내용 만 남겨두고 저장소에서 줄 끝을 LF로 정규화하고 선택적으로 파일을 체크 아웃 할 때 CRLF로 변환하도록 구성 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="28e5e3e789710acfbe64ae88514ac76e33edddf4" translate="yes" xml:space="preserve">
          <source>While a tree represents a particular directory state of a working directory, a commit represents that state in &quot;time&quot;, and explains how to get there.</source>
          <target state="translated">트리는 작업중인 디렉토리의 특정 디렉토리 상태를 나타내는 반면, 커밋은 해당 시간을 &quot;시간&quot;으로 나타내며 도달하는 방법을 설명합니다.</target>
        </trans-unit>
        <trans-unit id="4340adfab1f511dfd0a9b398534e55b63d70f9b2" translate="yes" xml:space="preserve">
          <source>While an &quot;easy case recovery&quot; sometimes appears to be successful even in the hard case, it may have unintended consequences. For example, a commit that was removed via &lt;code&gt;git rebase
      --interactive&lt;/code&gt; will be &lt;strong&gt;resurrected&lt;/strong&gt;!</source>
          <target state="translated">어려운 경우에도 &quot;쉬운 사례 복구&quot;가 성공한 것처럼 보이지만 의도하지 않은 결과가 발생할 수 있습니다. 예를 들어, 커밋 그 제거를 통해 &lt;code&gt;git rebase --interactive&lt;/code&gt; 됩니다 &lt;strong&gt;부활&lt;/strong&gt; !</target>
        </trans-unit>
        <trans-unit id="aeca28e54d758d00b7b9efe81e9021c3ae168604" translate="yes" xml:space="preserve">
          <source>While at it, check the &lt;code&gt;info&lt;/code&gt; and &lt;code&gt;final-commit&lt;/code&gt; files as well. If what is in &lt;code&gt;final-commit&lt;/code&gt; is not exactly what you would want to see in the commit log message, it is very likely that the receiver would end up hand editing the log message when applying your patch. Things like &quot;Hi, this is my first patch.\n&quot; in the patch e-mail should come after the three-dash line that signals the end of the commit message.</source>
          <target state="translated">&lt;code&gt;info&lt;/code&gt; 와 &lt;code&gt;final-commit&lt;/code&gt; 파일도 확인하십시오 . 무엇 경우 &lt;code&gt;final-commit&lt;/code&gt; 당신이 커밋 로그 메시지의, 매우 가능성이 수신기가 당신의 패치를 적용 할 때 로그 메시지를 편집하는 손을 끝낼 것입니다보고 싶은 것이 무엇인지 정확히하지 않습니다. 패치 전자 우편의 &quot;안녕하세요. \ n&quot;과 같은 것은 커밋 메시지의 끝을 알리는 3 개의 대시 줄 다음에 와야합니다.</target>
        </trans-unit>
        <trans-unit id="8ae695a4eabf8fe5dbbd3e5b96e3d4b6e1234599" translate="yes" xml:space="preserve">
          <source>While creating changes is useful, it&amp;rsquo;s even more useful if you can tell later what changed. The most useful command for this is another of the &lt;code&gt;diff&lt;/code&gt; family, namely &lt;code&gt;git diff-tree&lt;/code&gt;.</source>
          <target state="translated">변경 사항을 작성하는 것이 유용하지만 나중에 변경 사항을 알려줄 수 있으면 더욱 유용합니다. 이것에 가장 유용한 명령은 다른 &lt;code&gt;diff&lt;/code&gt; 패밀리, 즉 &lt;code&gt;git diff-tree&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="84a06403fddbfbdfed756ddcbe7e1b6ff85edd7a" translate="yes" xml:space="preserve">
          <source>While one could just alter the configuration settings in the gitweb CGI itself, those changes would be lost upon upgrade. Configuration settings might also be placed into a file in the same directory as the CGI script with the default name &lt;code&gt;gitweb_config.perl&lt;/code&gt; &amp;mdash; allowing one to have multiple gitweb instances with different configurations by the use of symlinks.</source>
          <target state="translated">gitweb CGI 자체의 구성 설정을 변경할 수는 있지만 업그레이드하면 변경 사항이 손실됩니다. 구성 설정은 기본 이름이 &lt;code&gt;gitweb_config.perl&lt;/code&gt; 인 CGI 스크립트와 동일한 디렉토리에있는 파일에 배치 할 수도 있습니다 . 심볼릭 링크를 사용하여 구성이 다른 여러 gitweb 인스턴스를 가질 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3129dc27b36b536bbc925e644f78f32bde86376a" translate="yes" xml:space="preserve">
          <source>While parent object ids are provided on the command line, author and committer information is taken from the following environment variables, if set:</source>
          <target state="translated">명령 행에 상위 오브젝트 ID가 제공되지만 작성자 및 커미터 정보는 설정된 경우 다음 환경 변수에서 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="7921bb694427f6298ff631684ef33f9b3436be57" translate="yes" xml:space="preserve">
          <source>While you are in the middle of working on something complicated, you find an unrelated but obvious and trivial bug. You would like to fix it before continuing. You can use &lt;a href=&quot;git-stash&quot;&gt;git-stash[1]&lt;/a&gt; to save the current state of your work, and after fixing the bug (or, optionally after doing so on a different branch and then coming back), unstash the work-in-progress changes.</source>
          <target state="translated">복잡한 작업을하는 동안 관련이 없지만 명백하고 사소한 버그가 있습니다. 계속하기 전에 문제를 해결하고 싶습니다. 당신이 사용할 수있는 &lt;a href=&quot;git-stash&quot;&gt;자식-숨긴 [1]&lt;/a&gt; 워크에서 진행중인 변화를 unstash, 그리고 (다시하거나, 선택적으로 다른 지점에 이렇게 후 다음 예정) 버그를 해결 한 후 작업의 현재 상태를 저장합니다.</target>
        </trans-unit>
        <trans-unit id="aa47dd8a2f0ebe83c1c9e1c5b54451eb489a4bd1" translate="yes" xml:space="preserve">
          <source>Whitespace separated fields; any run of whitespace can be used as field separator (rules for Perl&amp;rsquo;s &quot;&lt;code&gt;split(&quot; &quot;, $line)&lt;/code&gt;&quot;).</source>
          <target state="translated">공백으로 구분 된 필드; 모든 공백은 필드 분리 자로 사용할 수 있습니다 (Perl의 &quot; &lt;code&gt;split(&quot; &quot;, $line)&lt;/code&gt; &quot;에 대한 규칙 ).</target>
        </trans-unit>
        <trans-unit id="863aeb0371f511e273bc66c19d53b7877f38ac8a" translate="yes" xml:space="preserve">
          <source>Whitespace-separated list of allowed SMTP-AUTH mechanisms. This setting forces using only the listed mechanisms. Example:</source>
          <target state="translated">허용 된 SMTP-AUTH 메커니즘의 공백으로 구분 된 목록입니다. 이 설정은 나열된 메커니즘 만 사용합니다. 예:</target>
        </trans-unit>
        <trans-unit id="389ff74463b52646838e41646e64e38a902b85eb" translate="yes" xml:space="preserve">
          <source>Why bisecting merge commits can be harder than bisecting linear history</source>
          <target state="translated">이차 커밋 병합 커밋이 이력 선형 이력보다 어려운 이유</target>
        </trans-unit>
        <trans-unit id="4ae988a6589a0546387522087a0861a61e3e4225" translate="yes" xml:space="preserve">
          <source>Wildcards in the pattern such as &lt;code&gt;*&lt;/code&gt; or &lt;code&gt;?&lt;/code&gt; are treated as literal characters.</source>
          <target state="translated">&lt;code&gt;*&lt;/code&gt; 또는 &lt;code&gt;?&lt;/code&gt; 와 같은 패턴의 와일드 카드 리터럴 문자로 취급됩니다.</target>
        </trans-unit>
        <trans-unit id="af4b569cb0fc1bae5a933e3532b964dc5d61facd" translate="yes" xml:space="preserve">
          <source>Will copy all files listed from the index to the working directory (not overwriting existing files).</source>
          <target state="translated">색인에서 나열된 모든 파일을 작업 디렉토리로 복사합니다 (기존 파일을 덮어 쓰지 않음).</target>
        </trans-unit>
        <trans-unit id="712e5286413fd90307ff92f23e110885525f2bb8" translate="yes" xml:space="preserve">
          <source>Will fail unless you manually run &lt;code&gt;git fetch origin-push&lt;/code&gt;. This method is of course entirely defeated by something that runs &lt;code&gt;git fetch
--all&lt;/code&gt;, in that case you&amp;rsquo;d need to either disable it or do something more tedious like:</source>
          <target state="translated">&lt;code&gt;git fetch origin-push&lt;/code&gt; 를 수동으로 실행하지 않으면 실패합니다 . 이 메소드는 물론 &lt;code&gt;git fetch --all&lt;/code&gt; 을 실행하는 것에 의해 완전히 패배합니다 .이 경우 메소드 를 비활성화하거나 더 지루한 작업을 수행해야합니다.</target>
        </trans-unit>
        <trans-unit id="bfd8a0b8d0916903c6596ed358a3cc07670d304e" translate="yes" xml:space="preserve">
          <source>Windows-only: allow redirecting the standard input/output/error handles to paths specified by the environment variables. This is particularly useful in multi-threaded applications where the canonical way to pass standard handles via &lt;code&gt;CreateProcess()&lt;/code&gt; is not an option because it would require the handles to be marked inheritable (and consequently &lt;strong&gt;every&lt;/strong&gt; spawned process would inherit them, possibly blocking regular Git operations). The primary intended use case is to use named pipes for communication (e.g. &lt;code&gt;\\.\pipe\my-git-stdin-123&lt;/code&gt;).</source>
          <target state="translated">Windows 전용 : 표준 입력 / 출력 / 오류 핸들을 환경 변수로 지정된 경로로 경로 재 지정할 수 있습니다. 이것은 &lt;code&gt;CreateProcess()&lt;/code&gt; 를 통해 표준 핸들을 전달하는 표준 방법 이 핸들이 상속 가능한 것으로 표시되어야하기 때문에 옵션이 아닌 다중 스레드 응용 프로그램에서 특히 유용합니다. 결과적으로 생성 된 &lt;strong&gt;모든&lt;/strong&gt; 프로세스가이를 상속하여 정기적 인 Git 작업을 차단할 수 있습니다. ). 기본 사용 사례는 통신에 명명 된 파이프를 사용하는 것입니다 (예 : &lt;code&gt;\\.\pipe\my-git-stdin-123&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="9c510c80ca0db551792868481dfce7936d126272" translate="yes" xml:space="preserve">
          <source>Windows-only: comma-separated list of environment variables' names that need to be unset before spawning any other process. Defaults to &lt;code&gt;PERL5LIB&lt;/code&gt; to account for the fact that Git for Windows insists on using its own Perl interpreter.</source>
          <target state="translated">Windows 전용 : 다른 프로세스를 생성하기 전에 설정을 해제해야하는 쉼표로 구분 된 환경 변수 이름 목록입니다. Git for Windows가 자체 Perl 인터프리터를 사용해야한다는 사실을 설명하기 위해 기본값은 &lt;code&gt;PERL5LIB&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="e74f053e0d02cafdbd0bbd14c65f9fd314f00d13" translate="yes" xml:space="preserve">
          <source>Windows-only: override whether spawned processes inherit only standard file handles (&lt;code&gt;stdin&lt;/code&gt;, &lt;code&gt;stdout&lt;/code&gt; and &lt;code&gt;stderr&lt;/code&gt;) or all handles. Can be &lt;code&gt;auto&lt;/code&gt;, &lt;code&gt;true&lt;/code&gt; or &lt;code&gt;false&lt;/code&gt;. Defaults to &lt;code&gt;auto&lt;/code&gt;, which means &lt;code&gt;true&lt;/code&gt; on Windows 7 and later, and &lt;code&gt;false&lt;/code&gt; on older Windows versions.</source>
          <target state="translated">Windows 전용 : 생성 된 프로세스가 표준 파일 핸들 ( &lt;code&gt;stdin&lt;/code&gt; , &lt;code&gt;stdout&lt;/code&gt; 및 &lt;code&gt;stderr&lt;/code&gt; ) 만 상속하는지 아니면 모든 핸들을 상속하는지 여부를 대체하십시오 . &lt;code&gt;auto&lt;/code&gt; , &lt;code&gt;true&lt;/code&gt; 또는 &lt;code&gt;false&lt;/code&gt; 일 수 있습니다 . 기본값은 &lt;code&gt;auto&lt;/code&gt; 이며, 이는 Windows 7 이상에서는 &lt;code&gt;false&lt;/code&gt; 를, 이전 Windows 버전에서는 false 를 의미 &lt;code&gt;true&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="949442d2f0c16b026f680dbb7df65e881242333c" translate="yes" xml:space="preserve">
          <source>With --abbrev set to 0, the command can be used to find the closest tagname without any suffix:</source>
          <target state="translated">--abbrev를 0으로 설정하면이 명령을 사용하여 접미사없이 가장 가까운 태그 이름을 찾을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a158e0380ec8b734a269ad9d0f52eb5eb98f2274" translate="yes" xml:space="preserve">
          <source>With --all, the command can use branch heads as references, so the output shows the reference path as well:</source>
          <target state="translated">--all을 사용하면 명령에서 분기 헤드를 참조로 사용할 수 있으므로 출력에 참조 경로도 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="65ee9a1948ccba3bbf4e1e0783ded1eb1bf032c9" translate="yes" xml:space="preserve">
          <source>With --batch or --batch-check, follow symlinks inside the repository when requesting objects with extended SHA-1 expressions of the form tree-ish:path-in-tree. Instead of providing output about the link itself, provide output about the linked-to object. If a symlink points outside the tree-ish (e.g. a link to /foo or a root-level link to ../foo), the portion of the link which is outside the tree will be printed.</source>
          <target state="translated">--batch 또는 --batch-check를 사용하면 tree-ish : path-in-tree 형식의 확장 된 SHA-1식이있는 객체를 요청할 때 저장소 내부의 심볼릭 링크를 따릅니다. 링크 자체에 대한 출력을 제공하는 대신 링크 된 오브젝트에 대한 출력을 제공하십시오. 심볼릭 링크가 트리 -ish 외부를 가리키는 경우 (예 : / foo에 대한 링크 또는 ../foo에 대한 루트 수준 링크) 트리 외부에있는 링크 부분이 인쇄됩니다.</target>
        </trans-unit>
        <trans-unit id="4f48f3dcfb8092537ede5a515e981d6e213aeb9f" translate="yes" xml:space="preserve">
          <source>With --no-commit perform the merge and stop just before creating a merge commit, to give the user a chance to inspect and further tweak the merge result before committing.</source>
          <target state="translated">--no-commit을 사용하면 병합 커밋을 만들기 직전에 병합을 수행하고 중지하여 사용자가 커밋하기 전에 병합 결과를 검사하고 추가로 조정할 수있는 기회를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="3e8c9cc261afe4f0a3a9c88b1d66c9688df929d7" translate="yes" xml:space="preserve">
          <source>With --no-log do not list one-line descriptions from the actual commits being merged.</source>
          <target state="translated">--no-log를 사용하면 병합되는 실제 커밋의 한 줄 설명을 나열하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="e1adfa5cefd427bf7d3a2a21965629dcaf3c3388" translate="yes" xml:space="preserve">
          <source>With --no-signoff do not add a Signed-off-by line.</source>
          <target state="translated">--no-signoff를 사용하면 Signed-off-by 행을 추가하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="268060b1be32cd8bc70e7e3bb40c821b809c90c3" translate="yes" xml:space="preserve">
          <source>With --no-squash perform the merge and commit the result. This option can be used to override --squash.</source>
          <target state="translated">--no-squash를 사용하면 병합을 수행하고 결과를 커밋합니다. 이 옵션은 --squash를 재정의하는 데 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2060c61f3742702f58530c81f5eefb302aeb60c1" translate="yes" xml:space="preserve">
          <source>With --squash, --commit is not allowed, and will fail.</source>
          <target state="translated">--squash를 사용하면 --commit이 허용되지 않으며 실패합니다.</target>
        </trans-unit>
        <trans-unit id="865b225dd999d9769e36118a7e13e933131732f5" translate="yes" xml:space="preserve">
          <source>With -n or --no-stat do not show a diffstat at the end of the merge.</source>
          <target state="translated">-n 또는 --no-stat를 사용하면 병합 끝에 diffstat가 표시되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="008f5911b332311009571603d4810039f3b0a542" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;--add&lt;/code&gt;, instead of changing existing URLs, new URL is added.</source>
          <target state="translated">&lt;code&gt;--add&lt;/code&gt; 를 사용 하면 기존 URL을 변경하는 대신 새 URL이 추가됩니다.</target>
        </trans-unit>
        <trans-unit id="6b50c366c66c543504b13b437403fc08b0e99b0f" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;--add&lt;/code&gt;, instead of replacing the list of currently tracked branches, adds to that list.</source>
          <target state="translated">&lt;code&gt;--add&lt;/code&gt; 를 사용 하면 현재 추적 된 분기 목록을 바꾸지 않고 해당 목록에 추가합니다.</target>
        </trans-unit>
        <trans-unit id="b5c6ad97197083d8f93283087955bd70bd89f95f" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;--all&lt;/code&gt; flag, all refs that exist locally are transferred to the remote side. You cannot specify any &lt;code&gt;&amp;lt;ref&amp;gt;&lt;/code&gt; if you use this flag.</source>
          <target state="translated">&lt;code&gt;--all&lt;/code&gt; 플래그를 사용하면 로컬로 존재하는 모든 참조가 원격으로 전송됩니다. 이 플래그를 사용하면 &lt;code&gt;&amp;lt;ref&amp;gt;&lt;/code&gt; 를 지정할 수 없습니다 .</target>
        </trans-unit>
        <trans-unit id="487cd0ed38992f1c8c21d61869ab0ba8c9131e91" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;--all&lt;/code&gt;, all URLs for the remote will be listed.</source>
          <target state="translated">로 &lt;code&gt;--all&lt;/code&gt; , 원격에 대한 모든 URL이 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="ea729f224a85b66147f6e662a1c5d14a2abdd751" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;--contains&lt;/code&gt;, shows only the branches that contain the named commit (in other words, the branches whose tip commits are descendants of the named commit), &lt;code&gt;--no-contains&lt;/code&gt; inverts it. With &lt;code&gt;--merged&lt;/code&gt;, only branches merged into the named commit (i.e. the branches whose tip commits are reachable from the named commit) will be listed. With &lt;code&gt;--no-merged&lt;/code&gt; only branches not merged into the named commit will be listed. If the &amp;lt;commit&amp;gt; argument is missing it defaults to &lt;code&gt;HEAD&lt;/code&gt; (i.e. the tip of the current branch).</source>
          <target state="translated">&lt;code&gt;--contains&lt;/code&gt; 를 사용하면 명명 된 커밋이 포함 된 분기 (즉, 팁 커밋이 명명 된 커밋의 하위 항목 인 분기 ) 만 표시합니다. &lt;code&gt;--no-contains&lt;/code&gt; 는 반전합니다. 로 &lt;code&gt;--merged&lt;/code&gt; 만 가지라는 커밋에 병합 (즉, 그 끝 커밋 커밋의 이름에서 연결할 수있는 지점)가 표시됩니다. 로 &lt;code&gt;--no-merged&lt;/code&gt; 라는 이름이 나열됩니다 커밋으로 통합뿐만 아니라 지점. &amp;lt;commit&amp;gt; 인수가 없으면 기본값은 &lt;code&gt;HEAD&lt;/code&gt; (즉, 현재 분기의 끝)입니다.</target>
        </trans-unit>
        <trans-unit id="a1afc8d7fd506e98e5a974a8f26c84b23238fb92" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;--create-reflog&lt;/code&gt;, update-ref will create a reflog for each ref even if one would not ordinarily be created.</source>
          <target state="translated">&lt;code&gt;--create-reflog&lt;/code&gt; 를 사용하면 update-ref는 일반적으로 작성되지 않더라도 각 참조에 대한 참조를 작성합니다.</target>
        </trans-unit>
        <trans-unit id="7fef88021ca55186dc4070339cc8624e9a30485c" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;--delete&lt;/code&gt;, instead of changing existing URLs, all URLs matching regex &amp;lt;url&amp;gt; are deleted for remote &amp;lt;name&amp;gt;. Trying to delete all non-push URLs is an error.</source>
          <target state="translated">&lt;code&gt;--delete&lt;/code&gt; 를 사용 하면 기존 URL을 변경하는 대신 원격 &amp;lt;name&amp;gt;에 대해 정규식 &amp;lt;url&amp;gt;과 일치하는 모든 URL이 삭제됩니다. 푸시가 아닌 URL을 모두 삭제하려고하면 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="30918cb51e4372be35c787127ec3b8958bb72e8d" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;--dry-run&lt;/code&gt; option, report what branches will be pruned, but do not actually prune them.</source>
          <target state="translated">&lt;code&gt;--dry-run&lt;/code&gt; 옵션을 사용하면 잘라낼 가지를보고하지만 실제로 제거하지는 않습니다.</target>
        </trans-unit>
        <trans-unit id="5189cda6779864f8bd2f5726b39c4529ff52ddf8" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;--ff-only&lt;/code&gt;, resolve the merge as a fast-forward when possible. When not possible, refuse to merge and exit with a non-zero status.</source>
          <target state="translated">&lt;code&gt;--ff-only&lt;/code&gt; 를 사용 하면 가능한 경우 빨리 병합으로 병합을 해결하십시오. 가능하지 않은 경우 0이 아닌 상태로 병합 및 종료를 거부하십시오.</target>
        </trans-unit>
        <trans-unit id="7e8f4fddd68a3a89ff49906c538a7ca7b5ef9dea" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;--ff&lt;/code&gt;, when possible resolve the merge as a fast-forward (only update the branch pointer to match the merged branch; do not create a merge commit). When not possible (when the merged-in history is not a descendant of the current history), create a merge commit.</source>
          <target state="translated">와 &lt;code&gt;--ff&lt;/code&gt; , 가능하면 해결과 병합 빨리 감기 (만 병합 된 지점과 일치하는 지점 포인터를 업데이트, 병합 커밋을 작성하지 않습니다). 가능하지 않은 경우 (병합 된 내역이 현재 내역의 후손이 아닌 경우) 병합 커밋을 만듭니다.</target>
        </trans-unit>
        <trans-unit id="1362a77896d8f49d16b2f9c5015389cf3c365072" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;--force&lt;/code&gt;, the fast-forward check is disabled for all refs.</source>
          <target state="translated">함께 &lt;code&gt;--force&lt;/code&gt; , 빨리 감기 검사는 모든 심판을 위해 사용할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="ba76b155ec3c447a87cfd160419204d256e0f486" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;--keep-cr&lt;/code&gt;, call &lt;code&gt;git mailsplit&lt;/code&gt; (see &lt;a href=&quot;git-mailsplit&quot;&gt;git-mailsplit[1]&lt;/a&gt;) with the same option, to prevent it from stripping CR at the end of lines. &lt;code&gt;am.keepcr&lt;/code&gt; configuration variable can be used to specify the default behaviour. &lt;code&gt;--no-keep-cr&lt;/code&gt; is useful to override &lt;code&gt;am.keepcr&lt;/code&gt;.</source>
          <target state="translated">함께 &lt;code&gt;--keep-cr&lt;/code&gt; 호출 &lt;code&gt;git mailsplit&lt;/code&gt; (참조 &lt;a href=&quot;git-mailsplit&quot;&gt;자식-mailsplit을 [1]&lt;/a&gt; 라인의 끝에 CR 박리되는 것을 방지하기 위해, 동일한 옵션). &lt;code&gt;am.keepcr&lt;/code&gt; 구성 변수를 사용하여 기본 동작을 지정할 수 있습니다. &lt;code&gt;--no-keep-cr&lt;/code&gt; 은 &lt;code&gt;am.keepcr&lt;/code&gt; 을 재정의하는 데 유용합니다 .</target>
        </trans-unit>
        <trans-unit id="22e7d426b38d094430582cb84fc0432b42834058" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;--no-ff&lt;/code&gt;, create a merge commit in all cases, even when the merge could instead be resolved as a fast-forward.</source>
          <target state="translated">로 &lt;code&gt;--no-ff&lt;/code&gt; , 병합 대신 빨리 감기로 해결 될 수있는 경우에도, 병합이 모든 경우에 커밋 만듭니다.</target>
        </trans-unit>
        <trans-unit id="5aa5b8e96804090cb89f3aab6cdc283e2c00d87e" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;--no-tags&lt;/code&gt; option, &lt;code&gt;git fetch &amp;lt;name&amp;gt;&lt;/code&gt; does not import tags from the remote repository.</source>
          <target state="translated">로 &lt;code&gt;--no-tags&lt;/code&gt; 옵션, &lt;code&gt;git fetch &amp;lt;name&amp;gt;&lt;/code&gt; 원격 저장소에서 수행하지 가져 태그를.</target>
        </trans-unit>
        <trans-unit id="37eed19521c790d78f1c0615d39722d6298a6cc8" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;--patch&lt;/code&gt;, you can interactively select hunks from the diff between HEAD and the working tree to be stashed. The stash entry is constructed such that its index state is the same as the index state of your repository, and its worktree contains only the changes you selected interactively. The selected changes are then rolled back from your worktree. See the &amp;ldquo;Interactive Mode&amp;rdquo; section of &lt;a href=&quot;git-add&quot;&gt;git-add[1]&lt;/a&gt; to learn how to operate the &lt;code&gt;--patch&lt;/code&gt; mode.</source>
          <target state="translated">로 &lt;code&gt;--patch&lt;/code&gt; , 대화 형 HEAD와 작업 트리의 DIFF에서 심술쟁이를 선택하는 은닉한다. 숨김 항목은 색인 상태가 저장소의 색인 상태와 동일하도록 구성되며 작업 트리에는 대화식으로 선택한 변경 사항 만 포함됩니다. 선택한 변경 사항이 작업 트리에서 롤백됩니다. &lt;code&gt;--patch&lt;/code&gt; 모드 작동 방법을 알아 보려면 &lt;a href=&quot;git-add&quot;&gt;git-add [1]&lt;/a&gt; 의 &quot;대화식 모드&quot;섹션을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="8d4d7e74d0f493c9b38977e43daed9cfd8d04693" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;--pretty&lt;/code&gt; format other than &lt;code&gt;oneline&lt;/code&gt; and &lt;code&gt;reference&lt;/code&gt; (for obvious reasons), this causes the output to have two extra lines of information taken from the reflog. The reflog designator in the output may be shown as &lt;code&gt;ref@{Nth}&lt;/code&gt; (where &lt;code&gt;Nth&lt;/code&gt; is the reverse-chronological index in the reflog) or as &lt;code&gt;ref@{timestamp}&lt;/code&gt; (with the timestamp for that entry), depending on a few rules:</source>
          <target state="translated">&lt;code&gt;oneline&lt;/code&gt; 및 &lt;code&gt;reference&lt;/code&gt; 이외의 &lt;code&gt;--pretty&lt;/code&gt; 형식을 사용하면 (명백한 이유로) 출력에 reflog에서 가져온 두 개의 추가 정보 행이 있습니다. 출력의 reflog 지정 자는 몇 가지 규칙에 따라 &lt;code&gt;ref@{Nth}&lt;/code&gt; (여기서 &lt;code&gt;Nth&lt;/code&gt; 는 reflog의 역 시간 색인) 또는 &lt;code&gt;ref@{timestamp}&lt;/code&gt; (해당 항목의 타임 스탬프 포함)로 표시 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="35b7bcaa0d1a12c16e7ebe5749afd0aa0913b69d" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;--prune&lt;/code&gt; option, run pruning against all the remotes that are updated.</source>
          <target state="translated">&lt;code&gt;--prune&lt;/code&gt; 옵션을 사용하면 업데이트 된 모든 원격 장치에 대해 제거를 실행하십시오.</target>
        </trans-unit>
        <trans-unit id="9a993d0e8bfe45705897018a009a33a68fb547fb" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;--push&lt;/code&gt;, push URLs are manipulated instead of fetch URLs.</source>
          <target state="translated">&lt;code&gt;--push&lt;/code&gt; 를 사용하면 URL 가져 오기 대신 푸시 URL이 조작됩니다.</target>
        </trans-unit>
        <trans-unit id="d0c8d67cd6d67334176bbc781201963c60a05697" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;--push&lt;/code&gt;, push URLs are queried rather than fetch URLs.</source>
          <target state="translated">&lt;code&gt;--push&lt;/code&gt; 를 사용하면 URL을 가져 오는 대신 푸시 URL을 쿼리합니다.</target>
        </trans-unit>
        <trans-unit id="a26943d9e66efe8045d055005cf22b61dc280b47" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;--stdin&lt;/code&gt;, update-ref reads instructions from standard input and performs all modifications together. Specify commands of the form:</source>
          <target state="translated">&lt;code&gt;--stdin&lt;/code&gt; 을 사용 하여 update-ref는 표준 입력에서 명령어를 읽고 모든 수정을 함께 수행합니다. 다음 형식의 명령을 지정하십시오.</target>
        </trans-unit>
        <trans-unit id="46644e8c0f7ae9adba68ae4958242044a646f477" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;--tags&lt;/code&gt; option, &lt;code&gt;git fetch &amp;lt;name&amp;gt;&lt;/code&gt; imports every tag from the remote repository.</source>
          <target state="translated">&lt;code&gt;--tags&lt;/code&gt; 옵션을 사용하면 &lt;code&gt;git fetch &amp;lt;name&amp;gt;&lt;/code&gt; 은 원격 저장소에서 모든 태그를 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="9afd8cc2d67d37867f3891e80c5ed22f0441334c" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;--topo-order&lt;/code&gt;, they would show 8 6 5 3 7 4 2 1 (or 8 7 4 2 6 5 3 1); some older commits are shown before newer ones in order to avoid showing the commits from two parallel development track mixed together.</source>
          <target state="translated">&lt;code&gt;--topo-order&lt;/code&gt; 를 사용하면 8 6 5 3 7 4 2 1 (또는 8 7 4 2 6 5 3 1)을 표시합니다. 두 개의 병렬 개발 트랙의 커밋이 함께 혼합되어 표시되지 않도록하기 위해 일부 이전 커밋이 최신 커밋보다 먼저 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="bbe3bdb143c872f8bc3522bea317a2ad84af9235" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;-a&lt;/code&gt; or &lt;code&gt;--auto&lt;/code&gt;, the remote is queried to determine its &lt;code&gt;HEAD&lt;/code&gt;, then the symbolic-ref &lt;code&gt;refs/remotes/&amp;lt;name&amp;gt;/HEAD&lt;/code&gt; is set to the same branch. e.g., if the remote &lt;code&gt;HEAD&lt;/code&gt; is pointed at &lt;code&gt;next&lt;/code&gt;, &quot;&lt;code&gt;git remote set-head origin -a&lt;/code&gt;&quot; will set the symbolic-ref &lt;code&gt;refs/remotes/origin/HEAD&lt;/code&gt; to &lt;code&gt;refs/remotes/origin/next&lt;/code&gt;. This will only work if &lt;code&gt;refs/remotes/origin/next&lt;/code&gt; already exists; if not it must be fetched first.</source>
          <target state="translated">함께 &lt;code&gt;-a&lt;/code&gt; 또는 &lt;code&gt;--auto&lt;/code&gt; 원격는 그 결정하도록 쿼리 &lt;code&gt;HEAD&lt;/code&gt; 후 기호-REF &lt;code&gt;refs/remotes/&amp;lt;name&amp;gt;/HEAD&lt;/code&gt; 동일한 지점으로 설정된다. 예를 들어, 원격 &lt;code&gt;HEAD&lt;/code&gt; 가 &lt;code&gt;next&lt;/code&gt; 에 지시 되면 &quot; &lt;code&gt;git remote set-head origin -a&lt;/code&gt; &quot;는 &lt;code&gt;refs/remotes/origin/HEAD&lt;/code&gt; -ref refs / remotes / origin / HEAD 를 &lt;code&gt;refs/remotes/origin/next&lt;/code&gt; 로 설정 합니다. &lt;code&gt;refs/remotes/origin/next&lt;/code&gt; 이미 존재하는 경우에만 작동 합니다. 그렇지 않은 경우 먼저 가져와야합니다.</target>
        </trans-unit>
        <trans-unit id="5f69d8ea721996a0e954b69bd77400aaa01f9c55" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;-d&lt;/code&gt; flag, it deletes the named &amp;lt;ref&amp;gt; after verifying it still contains &amp;lt;oldvalue&amp;gt;.</source>
          <target state="translated">&lt;code&gt;-d&lt;/code&gt; 플래그를 사용하면 &amp;lt;oldvalue&amp;gt;가 여전히 포함되어 있는지 확인한 후 명명 된 &amp;lt;ref&amp;gt;를 삭제합니다.</target>
        </trans-unit>
        <trans-unit id="da9e1b9da40421df76a154165f2b54d479838ea5" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;-d&lt;/code&gt; or &lt;code&gt;--delete&lt;/code&gt;, the symbolic ref &lt;code&gt;refs/remotes/&amp;lt;name&amp;gt;/HEAD&lt;/code&gt; is deleted.</source>
          <target state="translated">함께 &lt;code&gt;-d&lt;/code&gt; 또는 &lt;code&gt;--delete&lt;/code&gt; , 상징적 심판이 &lt;code&gt;refs/remotes/&amp;lt;name&amp;gt;/HEAD&lt;/code&gt; 삭제됩니다.</target>
        </trans-unit>
        <trans-unit id="6b0b5064fe468e227911615a2b7fcbafb431eef7" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;-f&lt;/code&gt; option, &lt;code&gt;git fetch &amp;lt;name&amp;gt;&lt;/code&gt; is run immediately after the remote information is set up.</source>
          <target state="translated">&lt;code&gt;-f&lt;/code&gt; 옵션을 사용하면 &lt;code&gt;git fetch &amp;lt;name&amp;gt;&lt;/code&gt; 은 원격 정보가 설정된 직후에 실행됩니다.</target>
        </trans-unit>
        <trans-unit id="4c11581a6169e0a17084bd502989c1df6d5ff9b6" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;-m &amp;lt;master&amp;gt;&lt;/code&gt; option, a symbolic-ref &lt;code&gt;refs/remotes/&amp;lt;name&amp;gt;/HEAD&lt;/code&gt; is set up to point at remote&amp;rsquo;s &lt;code&gt;&amp;lt;master&amp;gt;&lt;/code&gt; branch. See also the set-head command.</source>
          <target state="translated">함께 &lt;code&gt;-m &amp;lt;master&amp;gt;&lt;/code&gt; 옵션 상징적-REF &lt;code&gt;refs/remotes/&amp;lt;name&amp;gt;/HEAD&lt;/code&gt; 원격의에서 지점으로 설정되어 &lt;code&gt;&amp;lt;master&amp;gt;&lt;/code&gt; 지점입니다. set-head 명령도 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="734f06f2f4ad450ab9efcf1cd7537f18bb0a22f5" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;-n&lt;/code&gt; option, the remote heads are not queried first with &lt;code&gt;git ls-remote &amp;lt;name&amp;gt;&lt;/code&gt;; cached information is used instead.</source>
          <target state="translated">&lt;code&gt;-n&lt;/code&gt; 옵션을 사용하면 &lt;code&gt;git ls-remote &amp;lt;name&amp;gt;&lt;/code&gt; 으로 원격 헤드를 먼저 쿼리하지 않습니다 . 캐시 된 정보가 대신 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="dd75e538fb39d452e807a34068040583ee9147bc" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;-t &amp;lt;branch&amp;gt;&lt;/code&gt; option, instead of the default glob refspec for the remote to track all branches under the &lt;code&gt;refs/remotes/&amp;lt;name&amp;gt;/&lt;/code&gt; namespace, a refspec to track only &lt;code&gt;&amp;lt;branch&amp;gt;&lt;/code&gt; is created. You can give more than one &lt;code&gt;-t &amp;lt;branch&amp;gt;&lt;/code&gt; to track multiple branches without grabbing all branches.</source>
          <target state="translated">함께 &lt;code&gt;-t &amp;lt;branch&amp;gt;&lt;/code&gt; 옵션 대신 아래에있는 모든 지점 추적 할 수있는 원격의 기본 글로브의 refspec의 &lt;code&gt;refs/remotes/&amp;lt;name&amp;gt;/&lt;/code&gt; 네임 스페이스하는 refspec 만 추적하는 &lt;code&gt;&amp;lt;branch&amp;gt;&lt;/code&gt; 가 만들어집니다. 모든 분기를 잡지 않고 여러 분기를 추적하기 위해 둘 이상의 &lt;code&gt;-t &amp;lt;branch&amp;gt;&lt;/code&gt; 를 제공 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="3a17d1e0c132aee2d2be1ec1ea02b9a88fab2a36" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;add&lt;/code&gt;, a new trailer will be added, even if some trailers with the same (&amp;lt;token&amp;gt;, &amp;lt;value&amp;gt;) pair are already in the message.</source>
          <target state="translated">함께 &lt;code&gt;add&lt;/code&gt; 새로운 예고편 같은 일부 트레일러 (&amp;lt;토큰&amp;gt;, &amp;lt;값&amp;gt;) 쌍들이 이미 메시지의 경우에도 추가된다.</target>
        </trans-unit>
        <trans-unit id="bdb99f7baa9796a7b973194e1a5ab4a7e3d82b92" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;add&lt;/code&gt;, a new trailer will be added.</source>
          <target state="translated">로 &lt;code&gt;add&lt;/code&gt; , 새로운 트레일러가 추가됩니다.</target>
        </trans-unit>
        <trans-unit id="6b61b0983644b0774834807009f4d278bb642b5a" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;add&lt;/code&gt;, create a new branch named &lt;code&gt;&amp;lt;new-branch&amp;gt;&lt;/code&gt; starting at &lt;code&gt;&amp;lt;commit-ish&amp;gt;&lt;/code&gt;, and check out &lt;code&gt;&amp;lt;new-branch&amp;gt;&lt;/code&gt; into the new working tree. If &lt;code&gt;&amp;lt;commit-ish&amp;gt;&lt;/code&gt; is omitted, it defaults to HEAD. By default, &lt;code&gt;-b&lt;/code&gt; refuses to create a new branch if it already exists. &lt;code&gt;-B&lt;/code&gt; overrides this safeguard, resetting &lt;code&gt;&amp;lt;new-branch&amp;gt;&lt;/code&gt; to &lt;code&gt;&amp;lt;commit-ish&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">로 &lt;code&gt;add&lt;/code&gt; 라는 새로운 지점 생성 &lt;code&gt;&amp;lt;new-branch&amp;gt;&lt;/code&gt; 에서 시작하는 &lt;code&gt;&amp;lt;commit-ish&amp;gt;&lt;/code&gt; , 체크 아웃 &lt;code&gt;&amp;lt;new-branch&amp;gt;&lt;/code&gt; 새로운 작업 트리에. 경우 &lt;code&gt;&amp;lt;commit-ish&amp;gt;&lt;/code&gt; HEAD가 기본값을 생략하기로한다. 기본적으로 &lt;code&gt;-b&lt;/code&gt; 는 이미 존재하는 경우 새 분기 작성을 거부합니다. &lt;code&gt;-B&lt;/code&gt; 는이 보호 기능을 무시하고 &lt;code&gt;&amp;lt;new-branch&amp;gt;&lt;/code&gt; 를 &lt;code&gt;&amp;lt;commit-ish&amp;gt;&lt;/code&gt; 로 재설정 합니다.</target>
        </trans-unit>
        <trans-unit id="9a273ddd960841784db1a589aad98c4feff6c226" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;add&lt;/code&gt;, detach HEAD in the new working tree. See &quot;DETACHED HEAD&quot; in &lt;a href=&quot;git-checkout&quot;&gt;git-checkout[1]&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;add&lt;/code&gt; 를 사용 하여 새 작업 트리에서 HEAD를 분리하십시오. &lt;a href=&quot;git-checkout&quot;&gt;git-checkout [1]의&lt;/a&gt; &quot;DETACHED HEAD&quot;를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="187a01bfec37522a00b693f68238b703a4e0897c" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;add&lt;/code&gt;, suppress feedback messages.</source>
          <target state="translated">&lt;code&gt;add&lt;/code&gt; 를 사용하면 피드백 메시지가 표시되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="45995ca3706219a58e816f38cd1d9bf0922ce8ca" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;addIfDifferent&lt;/code&gt;, a new trailer will be added only if no trailer with the same (&amp;lt;token&amp;gt;, &amp;lt;value&amp;gt;) pair is already in the message.</source>
          <target state="translated">함께 &lt;code&gt;addIfDifferent&lt;/code&gt; 새로운 트레일러와 같은 더 트레일러 (&amp;lt;토큰&amp;gt;, &amp;lt;값&amp;gt;) 쌍 메시지 이미없는 경우에만 추가된다.</target>
        </trans-unit>
        <trans-unit id="6e3bd24c09b16e87e69f4ad565a18cc8f733f593" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;addIfDifferentNeighbor&lt;/code&gt;, a new trailer will be added only if no trailer with the same (&amp;lt;token&amp;gt;, &amp;lt;value&amp;gt;) pair is above or below the line where the new trailer will be added.</source>
          <target state="translated">함께 &lt;code&gt;addIfDifferentNeighbor&lt;/code&gt; 새로운 트레일러와 같은 더 트레일러 (&amp;lt;토큰&amp;gt;, &amp;lt;값&amp;gt;) 쌍 새로운 트레일러가 추가 될 라인 위 또는 아래에없는 경우에만 추가된다.</target>
        </trans-unit>
        <trans-unit id="c538516bcb20191b3fc9da51228fff3eefb68cdf" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;doNothing&lt;/code&gt;, nothing will be done.</source>
          <target state="translated">&lt;code&gt;doNothing&lt;/code&gt; 을 사용하면 아무 것도 수행되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="91898a3512235050c32c7a99a50c8394d7a8397d" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;doNothing&lt;/code&gt;, nothing will be done; that is no new trailer will be added if there is already one with the same &amp;lt;token&amp;gt; in the message.</source>
          <target state="translated">&lt;code&gt;doNothing&lt;/code&gt; 을 사용하면 아무 것도 수행되지 않습니다. 메시지에 &amp;lt;토큰&amp;gt;이 같은 트레일러가 이미 있으면 새 트레일러가 추가되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="fafece11b5178185f0dda98fe61f1218eca3ec1e" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;git format-patch --base=P -3 C&lt;/code&gt; (or variants thereof, e.g. with &lt;code&gt;--cover-letter&lt;/code&gt; or using &lt;code&gt;Z..C&lt;/code&gt; instead of &lt;code&gt;-3 C&lt;/code&gt; to specify the range), the base tree information block is shown at the end of the first message the command outputs (either the first patch, or the cover letter), like this:</source>
          <target state="translated">와 &lt;code&gt;git format-patch --base=P -3 C&lt;/code&gt; (또는 그 변형 예와 &lt;code&gt;--cover-letter&lt;/code&gt; 또는 사용 &lt;code&gt;Z..C&lt;/code&gt; 대신 &lt;code&gt;-3 C&lt;/code&gt; 를 범위 지정),베이스 트리 정보 블록에 나타낸다 다음과 같이 명령이 출력하는 첫 번째 메시지의 끝 (첫 번째 패치 또는 자기 소개서) :</target>
        </trans-unit>
        <trans-unit id="0dbfc249aea522f6a40d4b8be190d1fc0f0eadd8" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;list&lt;/code&gt;, output in an easy-to-parse format for scripts. This format will remain stable across Git versions and regardless of user configuration. See below for details.</source>
          <target state="translated">&lt;code&gt;list&lt;/code&gt; 를 사용하면 파싱하기 쉬운 스크립트 형식으로 출력됩니다. 이 형식은 사용자 구성에 관계없이 Git 버전에서 안정적으로 유지됩니다. 자세한 내용은 아래를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="021957faebf0fa8a6ba6fb4276abb6b8c72afba9" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;lock&lt;/code&gt;, an explanation why the working tree is locked.</source>
          <target state="translated">&lt;code&gt;lock&lt;/code&gt; 을 사용 하면 작업 트리가 잠긴 이유를 설명합니다.</target>
        </trans-unit>
        <trans-unit id="bbe63cab2529b193584b4f7d1c86ee0207fc9968" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;prune&lt;/code&gt;, do not remove anything; just report what it would remove.</source>
          <target state="translated">&lt;code&gt;prune&lt;/code&gt; 사용하면 아무것도 제거하지 마십시오. 제거 할 내용 만보고하면됩니다.</target>
        </trans-unit>
        <trans-unit id="97f5cdb302d7f0a46689004724feb3d1aca29383" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;prune&lt;/code&gt;, only expire unused working trees older than &amp;lt;time&amp;gt;.</source>
          <target state="translated">&lt;code&gt;prune&lt;/code&gt; 을 사용하면 &amp;lt;time&amp;gt;보다 오래된 미사용 작업 트리 만 만료됩니다.</target>
        </trans-unit>
        <trans-unit id="92ffa86e9306849b846038bae2a07ad322d0f86c" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;prune&lt;/code&gt;, report all removals.</source>
          <target state="translated">&lt;code&gt;prune&lt;/code&gt; 을 사용하여 모든 제거를보고하십시오.</target>
        </trans-unit>
        <trans-unit id="f6631b122f785beeb20cb0ef884a421b144138ae" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;replace&lt;/code&gt;, an existing trailer with the same &amp;lt;token&amp;gt; will be deleted and the new trailer will be added. The deleted trailer will be the closest one (with the same &amp;lt;token&amp;gt;) to the place where the new one will be added.</source>
          <target state="translated">&lt;code&gt;replace&lt;/code&gt; 를 사용하면 &amp;lt;토큰&amp;gt;과 동일한 기존 예고편이 삭제되고 새 예고편이 추가됩니다. 삭제 된 예고편은 새 예고편이 추가 될 장소와 가장 가까운 예고편 (예 : &amp;lt;토큰&amp;gt;)입니다.</target>
        </trans-unit>
        <trans-unit id="7b787c22358696a7fd63895c838388aed6d7912a" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;worktree add &amp;lt;path&amp;gt;&lt;/code&gt;, without &lt;code&gt;&amp;lt;commit-ish&amp;gt;&lt;/code&gt;, instead of creating a new branch from HEAD, if there exists a tracking branch in exactly one remote matching the basename of &lt;code&gt;&amp;lt;path&amp;gt;&lt;/code&gt;, base the new branch on the remote-tracking branch, and mark the remote-tracking branch as &quot;upstream&quot; from the new branch.</source>
          <target state="translated">함께 &lt;code&gt;worktree add &amp;lt;path&amp;gt;&lt;/code&gt; 없이 &lt;code&gt;&amp;lt;commit-ish&amp;gt;&lt;/code&gt; 대신 리모트베이스 이름과 일치하는 정확히 하나의 추적 지점이 존재하는 경우, 선두로부터의 새로운 지점을 만드는 &lt;code&gt;&amp;lt;path&amp;gt;&lt;/code&gt; 원격 추적의 새로운 지점,베이스 원격 추적 분기를 새 분기에서 &quot;업스트림&quot;으로 표시하십시오.</target>
        </trans-unit>
        <trans-unit id="660d18378dc3af084a2ac18df92d87c9aea68c5a" translate="yes" xml:space="preserve">
          <source>With Git bisect it&amp;rsquo;s a breeze: in the best case i can get a ~15 step kernel bisection done in 20-30 minutes, in an automated way. Even with manual help or when bisecting multiple, overlapping bugs, it&amp;rsquo;s rarely more than an hour.</source>
          <target state="translated">Git bisect를 사용하면 산들 바람이납니다. 최상의 경우 20-30 분 안에 ~ 15 단계의 커널 이분법을 자동으로 수행 할 수 있습니다. 수동 도움말이나 여러 개의 겹치는 버그를 이등분 할 때도 거의 1 시간 이상 걸리지 않습니다.</target>
        </trans-unit>
        <trans-unit id="46d101f0f209ac246ff187c45b6b808668e526b7" translate="yes" xml:space="preserve">
          <source>With a &lt;code&gt;-d&lt;/code&gt; or &lt;code&gt;-D&lt;/code&gt; option, &lt;code&gt;&amp;lt;branchname&amp;gt;&lt;/code&gt; will be deleted. You may specify more than one branch for deletion. If the branch currently has a reflog then the reflog will also be deleted.</source>
          <target state="translated">A를 &lt;code&gt;-d&lt;/code&gt; 또는 &lt;code&gt;-D&lt;/code&gt; 옵션, &lt;code&gt;&amp;lt;branchname&amp;gt;&lt;/code&gt; 삭제됩니다. 삭제할 분기를 둘 이상 지정할 수 있습니다. 분기에 현재 reflog가있는 경우 reflog도 삭제됩니다.</target>
        </trans-unit>
        <trans-unit id="f74d36fd60998cbf589b7f2b7f7bc156998c0334" translate="yes" xml:space="preserve">
          <source>With a &lt;code&gt;-m&lt;/code&gt; or &lt;code&gt;-M&lt;/code&gt; option, &amp;lt;oldbranch&amp;gt; will be renamed to &amp;lt;newbranch&amp;gt;. If &amp;lt;oldbranch&amp;gt; had a corresponding reflog, it is renamed to match &amp;lt;newbranch&amp;gt;, and a reflog entry is created to remember the branch renaming. If &amp;lt;newbranch&amp;gt; exists, -M must be used to force the rename to happen.</source>
          <target state="translated">A를 &lt;code&gt;-m&lt;/code&gt; 또는 &lt;code&gt;-M&lt;/code&gt; 옵션, &amp;lt;oldbranch&amp;gt; 이름이 바뀐에 &amp;lt;newbranch&amp;gt; 일 것이다. &amp;lt;oldbranch&amp;gt;에 해당 reflog가 있으면 이름이 &amp;lt;newbranch&amp;gt;와 일치하도록 이름이 바뀌고 분기 이름 변경을 기억하기 위해 reflog 항목이 작성됩니다. &amp;lt;newbranch&amp;gt;가 존재하면 -M을 사용하여 이름 변경을 강제 실행해야합니다.</target>
        </trans-unit>
        <trans-unit id="078f9b93867e54fc6fd5cb6cccb717d173a4bdbb" translate="yes" xml:space="preserve">
          <source>With a small group, developers may just pull changes from each other&amp;rsquo;s repositories without the need for a central maintainer.</source>
          <target state="translated">소규모 그룹에서는 개발자가 중앙 관리자 없이도 서로의 리포지토리에서 변경 사항을 가져올 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d93af44627c4056a70413d4d1086a466c1eb6057" translate="yes" xml:space="preserve">
          <source>With an optional &lt;code&gt;&amp;lt;ref&amp;gt;&lt;/code&gt; argument, use the ref to find the notes to display. The ref can specify the full refname when it begins with &lt;code&gt;refs/notes/&lt;/code&gt;; when it begins with &lt;code&gt;notes/&lt;/code&gt;, &lt;code&gt;refs/&lt;/code&gt; and otherwise &lt;code&gt;refs/notes/&lt;/code&gt; is prefixed to form a full name of the ref.</source>
          <target state="translated">선택적 &lt;code&gt;&amp;lt;ref&amp;gt;&lt;/code&gt; 인수 와 함께 ref를 사용하여 표시 할 메모를 찾으십시오. ref는 &lt;code&gt;refs/notes/&lt;/code&gt; 시작할 때 전체 refname을 지정할 수 있습니다 . &lt;code&gt;notes/&lt;/code&gt; 시작 하면 &lt;code&gt;refs/&lt;/code&gt; 및 그렇지 않으면 &lt;code&gt;refs/notes/&lt;/code&gt; 가 접두어로 ref의 전체 이름을 형성합니다.</target>
        </trans-unit>
        <trans-unit id="5888510f888416379a4d4b5651fc198f809cb1eb" translate="yes" xml:space="preserve">
          <source>With an optional argument, you can return to a different commit instead:</source>
          <target state="translated">선택적 인수를 사용하면 대신 다른 커밋으로 돌아갈 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="70761b9c0ed85e86f5fe4551851f4fb12dda8ef2" translate="yes" xml:space="preserve">
          <source>With centralized revision control systems this is often accomplished by including every module in one single repository. Developers can check out all modules or only the modules they need to work with. They can even modify files across several modules in a single commit while moving things around or updating APIs and translations.</source>
          <target state="translated">중앙 집중식 개정 제어 시스템을 사용하면 모든 모듈을 하나의 단일 리포지토리에 포함하여 수행 할 수 있습니다. 개발자는 모든 모듈 또는 작업해야하는 모듈 만 체크 아웃 할 수 있습니다. 또한 한 번의 커밋으로 여러 모듈에서 파일을 수정하거나 API 및 번역을 이동하거나 업데이트 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="34547cdab6bbebc8d70f8627cf92ce4ed49693c0" translate="yes" xml:space="preserve">
          <source>With no arguments, shows a list of existing remotes. Several subcommands are available to perform operations on the remotes.</source>
          <target state="translated">인수없이 기존 리모컨 목록을 표시합니다. 리모트에서 조작을 수행하기 위해 여러 부속 명령을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2d8eac222dcf5b2fb83219646b45ebbea55b5081" translate="yes" xml:space="preserve">
          <source>With no arguments, shows the status of existing submodules. Several subcommands are available to perform operations on the submodules.</source>
          <target state="translated">인수없이 기존 하위 모듈의 상태를 표시합니다. 서브 모듈에 대한 조작을 수행하기 위해 여러 부속 명령을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2955e54fe9fa9b7446c513283cbd98f27b722daf" translate="yes" xml:space="preserve">
          <source>With no arguments, this will:</source>
          <target state="translated">논증없이, 이것은 :</target>
        </trans-unit>
        <trans-unit id="07ab1293ff3b475c814f1fed59da838b442b2582" translate="yes" xml:space="preserve">
          <source>With no options and no COMMAND or GUIDE given, the synopsis of the &lt;code&gt;git&lt;/code&gt; command and a list of the most commonly used Git commands are printed on the standard output.</source>
          <target state="translated">옵션과 COMMAND 또는 GUIDE를 지정하지 않으면 &lt;code&gt;git&lt;/code&gt; 명령 의 개요 와 가장 일반적으로 사용되는 Git 명령 목록이 표준 출력에 인쇄됩니다.</target>
        </trans-unit>
        <trans-unit id="5afd0acc1bfdb6a1daab0a26aea947b62407909e" translate="yes" xml:space="preserve">
          <source>With something like git.git current tree, I get:</source>
          <target state="translated">git.git 현재 트리와 같은 것으로 다음을 얻습니다.</target>
        </trans-unit>
        <trans-unit id="48292de53da5a3060e12b426e889eefbf2d24e76" translate="yes" xml:space="preserve">
          <source>With that configuration the full path to browse repositories would be:</source>
          <target state="translated">이 구성을 사용하면 리포지토리를 탐색하는 전체 경로는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="de963656527f9e7a6067d643ee4aa5bfca1b2d08" translate="yes" xml:space="preserve">
          <source>With the &lt;code&gt;--append&lt;/code&gt; option, include all commits that are present in the existing commit-graph file.</source>
          <target state="translated">&lt;code&gt;--append&lt;/code&gt; 옵션을 사용하여 기존 커밋 그래프 파일에있는 모든 커밋을 포함시킵니다.</target>
        </trans-unit>
        <trans-unit id="14495f11a1a9217fb75c7d6db611a80cccd6e859" translate="yes" xml:space="preserve">
          <source>With the &lt;code&gt;--branch&lt;/code&gt; option, the command takes a name and checks if it can be used as a valid branch name (e.g. when creating a new branch). But be cautious when using the previous checkout syntax that may refer to a detached HEAD state. The rule &lt;code&gt;git check-ref-format --branch $name&lt;/code&gt; implements may be stricter than what &lt;code&gt;git check-ref-format refs/heads/$name&lt;/code&gt; says (e.g. a dash may appear at the beginning of a ref component, but it is explicitly forbidden at the beginning of a branch name). When run with &lt;code&gt;--branch&lt;/code&gt; option in a repository, the input is first expanded for the &amp;ldquo;previous checkout syntax&amp;rdquo; &lt;code&gt;@{-n}&lt;/code&gt;. For example, &lt;code&gt;@{-1}&lt;/code&gt; is a way to refer the last thing that was checked out using &quot;git switch&quot; or &quot;git checkout&quot; operation. This option should be used by porcelains to accept this syntax anywhere a branch name is expected, so they can act as if you typed the branch name. As an exception note that, the &amp;ldquo;previous checkout operation&amp;rdquo; might result in a commit object name when the N-th last thing checked out was not a branch.</source>
          <target state="translated">으로 &lt;code&gt;--branch&lt;/code&gt; 가 (예를 들어, 새로운 지점을 만들 때) 유효한 지점 이름으로 사용 할 수있는 경우 옵션, 명령은 이름과 검사를합니다. 그러나 분리 된 HEAD 상태를 참조 할 수있는 이전 체크 아웃 구문을 사용할 때는주의하십시오. &lt;code&gt;git check-ref-format --branch $name&lt;/code&gt; 구현 규칙 은 &lt;code&gt;git check-ref-format refs/heads/$name&lt;/code&gt; 보다 엄격 할 수 있습니다 (예 : 대시는 ref 구성 요소의 시작 부분에 나타날 수 있지만 명시 적으로 나타납니다) 지점 이름의 시작 부분에서 금지됨). 저장소에서 &lt;code&gt;--branch&lt;/code&gt; 옵션을 사용하여 실행하면 먼저 &quot;이전 체크 아웃 구문&quot; &lt;code&gt;@{-n}&lt;/code&gt; 대한 입력이 확장됩니다 . 예를 들어, &lt;code&gt;@{-1}&lt;/code&gt; &quot;git switch&quot;또는 &quot;git checkout&quot;조작을 사용하여 마지막으로 체크 아웃 한 것을 참조하는 방법입니다. 이 옵션은 도자기에서 분기 이름이 필요한 곳이면 어디에서나이 구문을 허용하므로 분기 이름을 입력 한 것처럼 작동 할 수 있어야합니다. 예외적으로,&amp;ldquo;이전 체크 아웃 작업&amp;rdquo;으로 인해 마지막으로 체크 아웃 한 N 번째 항목이 분기가 아닌 경우 커밋 개체 이름이 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f26f07033bd08bfdb6102afbc60e4bb690a51e35" translate="yes" xml:space="preserve">
          <source>With the &lt;code&gt;--reachable&lt;/code&gt; option, generate the new commit graph by walking commits starting at all refs. (Cannot be combined with &lt;code&gt;--stdin-commits&lt;/code&gt; or &lt;code&gt;--stdin-packs&lt;/code&gt;.)</source>
          <target state="translated">&lt;code&gt;--reachable&lt;/code&gt; 옵션을 사용하면 모든 심판에서 커밋을 걸어 새로운 커밋 그래프를 생성합니다. &lt;code&gt;--stdin-commits&lt;/code&gt; 또는 &lt;code&gt;--stdin-packs&lt;/code&gt; 와 함께 사용할 수 없습니다 .</target>
        </trans-unit>
        <trans-unit id="bced3fa737464959bcb0c4d4992aedaa6293d7b5" translate="yes" xml:space="preserve">
          <source>With the &lt;code&gt;--shallow&lt;/code&gt; option, only check the tip commit-graph file in a chain of split commit-graphs.</source>
          <target state="translated">&lt;code&gt;--shallow&lt;/code&gt; 옵션을 사용하면 분할 커밋 그래프 체인에서 tip commit-graph 파일 만 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="023fb87ae200847a2eb976930adb7f7ff9a576bb" translate="yes" xml:space="preserve">
          <source>With the &lt;code&gt;--split&lt;/code&gt; option, write the commit-graph as a chain of multiple commit-graph files stored in &lt;code&gt;&amp;lt;dir&amp;gt;/info/commit-graphs&lt;/code&gt;. The new commits not already in the commit-graph are added in a new &quot;tip&quot; file. This file is merged with the existing file if the following merge conditions are met:</source>
          <target state="translated">&lt;code&gt;--split&lt;/code&gt; 옵션을 사용하여 commit-graph를 &lt;code&gt;&amp;lt;dir&amp;gt;/info/commit-graphs&lt;/code&gt; 에 저장된 여러 commit-graph 파일의 체인으로 작성하십시오 . commit-graph에 아직없는 새로운 commit은 새로운 &quot;tip&quot;파일에 추가됩니다. 다음 병합 조건이 충족되면이 파일은 기존 파일과 병합됩니다.</target>
        </trans-unit>
        <trans-unit id="0f402e69b2097f87a53ae26564ee053ba1f630ec" translate="yes" xml:space="preserve">
          <source>With the &lt;code&gt;--stdin-commits&lt;/code&gt; option, generate the new commit graph by walking commits starting at the commits specified in stdin as a list of OIDs in hex, one OID per line. (Cannot be combined with &lt;code&gt;--stdin-packs&lt;/code&gt; or &lt;code&gt;--reachable&lt;/code&gt;.)</source>
          <target state="translated">으로 &lt;code&gt;--stdin-commits&lt;/code&gt; 옵션, 새로운 16 진수의 OID를 목록, 한 줄에 하나의 OID로하여 stdin에 지정된 커밋에서 시작 도보 커밋으로 그래프를 저지 생성합니다. &lt;code&gt;--stdin-packs&lt;/code&gt; 또는 &lt;code&gt;--reachable&lt;/code&gt; 과 함께 사용할 수 없습니다 .</target>
        </trans-unit>
        <trans-unit id="eaf73ef52d157ce1e4ddc4b827c0a6415ea79de1" translate="yes" xml:space="preserve">
          <source>With the &lt;code&gt;--stdin-packs&lt;/code&gt; option, generate the new commit graph by walking objects only in the specified pack-indexes. (Cannot be combined with &lt;code&gt;--stdin-commits&lt;/code&gt; or &lt;code&gt;--reachable&lt;/code&gt;.)</source>
          <target state="translated">으로 &lt;code&gt;--stdin-packs&lt;/code&gt; 옵션, 새로운 도보로 그래프는 지정된 팩 - 인덱스에서 개체를 커밋 생성합니다. &lt;code&gt;--stdin-commits&lt;/code&gt; 또는 &lt;code&gt;--reachable&lt;/code&gt; 과 함께 사용할 수 없습니다 .</target>
        </trans-unit>
        <trans-unit id="17857b1a19de2786ab177b98550f7755d5958169" translate="yes" xml:space="preserve">
          <source>With the &lt;code&gt;subsystem&lt;/code&gt; reflog: after &lt;code&gt;git fetch&lt;/code&gt;, the old tip of &lt;code&gt;subsystem&lt;/code&gt; is at &lt;code&gt;subsystem@{1}&lt;/code&gt;. Subsequent fetches will increase the number. (See &lt;a href=&quot;git-reflog&quot;&gt;git-reflog[1]&lt;/a&gt;.)</source>
          <target state="translated">으로 &lt;code&gt;subsystem&lt;/code&gt; reflog : 후 &lt;code&gt;git fetch&lt;/code&gt; 의 이전 팁 &lt;code&gt;subsystem&lt;/code&gt; 에있다 &lt;code&gt;subsystem@{1}&lt;/code&gt; . 이후에 가져 오면 숫자가 증가합니다. ( &lt;a href=&quot;git-reflog&quot;&gt;git-reflog [1]&lt;/a&gt; 참조 )</target>
        </trans-unit>
        <trans-unit id="b4f2100600cd65d2bb507aefd40b38b428ed31a7" translate="yes" xml:space="preserve">
          <source>With the example above that would give:</source>
          <target state="translated">위의 예를 통해 다음과 같은 결과를 얻을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a003c8ea87ae62c71ced8657b18db066ae621f53" translate="yes" xml:space="preserve">
          <source>With the exception of raw file data (which Git does not interpret) the fast-import input format is text (ASCII) based. This text based format simplifies development and debugging of frontend programs, especially when a higher level language such as Perl, Python or Ruby is being used.</source>
          <target state="translated">원시 파일 데이터 (Git이 해석하지 않는)를 제외하고 빠른 가져 오기 입력 형식은 텍스트 (ASCII)입니다. 이 텍스트 기반 형식은 특히 Perl, Python 또는 Ruby와 같은 고급 언어를 사용하는 경우 프론트 엔드 프로그램의 개발 및 디버깅을 단순화합니다.</target>
        </trans-unit>
        <trans-unit id="832b24adba81a74f8f3c27d1a374c3c9abe6eae9" translate="yes" xml:space="preserve">
          <source>With the latter, you can use the manual viewer of your choice; see &lt;a href=&quot;git-help&quot;&gt;git-help[1]&lt;/a&gt; for more information.</source>
          <target state="translated">후자를 사용하면 선택한 수동 뷰어를 사용할 수 있습니다. 자세한 내용은 &lt;a href=&quot;git-help&quot;&gt;git-help [1]&lt;/a&gt; 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="fd552b2cf02d64fea6c3a2fbecdcfeec69fa5199" translate="yes" xml:space="preserve">
          <source>With the right arguments, &lt;code&gt;git diff&lt;/code&gt; can also show us the difference between the working directory and the last commit, or between the index and the last commit:</source>
          <target state="translated">올바른 인수를 사용하면 &lt;code&gt;git diff&lt;/code&gt; 는 작업 디렉토리와 마지막 커밋 또는 인덱스와 마지막 커밋의 차이점을 보여줄 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6936b3f47f8ae1f272ba09aecb9105ac3f327d8a" translate="yes" xml:space="preserve">
          <source>With the strategies that use 3-way merge (including the default, &lt;code&gt;recursive&lt;/code&gt;), if a change is made on both branches, but later reverted on one of the branches, that change will be present in the merged result; some people find this behavior confusing. It occurs because only the heads and the merge base are considered when performing a merge, not the individual commits. The merge algorithm therefore considers the reverted change as no change at all, and substitutes the changed version instead.</source>
          <target state="translated">3 방향 병합 (기본값, &lt;code&gt;recursive&lt;/code&gt; 포함)을 사용하는 전략을 사용 하여 두 분기에서 변경을 수행 한 후 나중에 분기 중 하나에서 되 돌리면 해당 변경이 병합 된 결과에 나타납니다. 어떤 사람들은이 행동이 혼란 스럽다고 생각합니다. 개별 커밋이 아닌 병합을 수행 할 때 헤드와 병합 기반 만 고려되기 때문에 발생합니다. 따라서 병합 알고리즘은 되 돌린 변경 사항을 전혀 변경되지 않은 것으로 간주하고 변경된 버전을 대신 사용합니다.</target>
        </trans-unit>
        <trans-unit id="993a54cdc4357f066aea765f4571bf68eff0acc7" translate="yes" xml:space="preserve">
          <source>With this option, &lt;code&gt;git cherry-pick&lt;/code&gt; will let you edit the commit message prior to committing.</source>
          <target state="translated">이 옵션을 사용하면 &lt;code&gt;git cherry-pick&lt;/code&gt; 을 사용하여 커밋하기 전에 커밋 메시지를 편집 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="333853f3b4bc551496449cd51ab3f625f2fd83b5" translate="yes" xml:space="preserve">
          <source>With this option, &lt;code&gt;git gc&lt;/code&gt; checks whether any housekeeping is required; if not, it exits without performing any work.</source>
          <target state="translated">이 옵션을 사용하면 &lt;code&gt;git gc&lt;/code&gt; 는 하우스 키핑이 필요한지 확인합니다. 그렇지 않으면 작업을 수행하지 않고 종료됩니다.</target>
        </trans-unit>
        <trans-unit id="71e625d3b0cf2785820345a3c9b0fc38126ae685" translate="yes" xml:space="preserve">
          <source>With this option, &lt;code&gt;git revert&lt;/code&gt; will let you edit the commit message prior to committing the revert. This is the default if you run the command from a terminal.</source>
          <target state="translated">이 옵션을 사용하면 &lt;code&gt;git revert&lt;/code&gt; 를 사용하여 되돌리기를 커밋하기 전에 커밋 메시지를 편집 할 수 있습니다. 터미널에서 명령을 실행하는 경우 이것이 기본값입니다.</target>
        </trans-unit>
        <trans-unit id="c4b763c3b176a1288a147104d8354f56c0e27e09" translate="yes" xml:space="preserve">
          <source>With this option, &lt;code&gt;git revert&lt;/code&gt; will not start the commit message editor.</source>
          <target state="translated">이 옵션을 사용하면 &lt;code&gt;git revert&lt;/code&gt; 는 커밋 메시지 편집기를 시작하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="8c4fe13a9c7d1e41585a8e2b5418a2b1ca5a28f1" translate="yes" xml:space="preserve">
          <source>With this option, &lt;code&gt;merge-recursive&lt;/code&gt; spends a little extra time to avoid mismerges that sometimes occur due to unimportant matching lines (e.g., braces from distinct functions). Use this when the branches to be merged have diverged wildly. See also &lt;a href=&quot;git-diff&quot;&gt;git-diff[1]&lt;/a&gt;&lt;code&gt;--patience&lt;/code&gt;.</source>
          <target state="translated">이 옵션을 사용하면 &lt;code&gt;merge-recursive&lt;/code&gt; 는 중요하지 않은 일치하는 줄 (예 : 고유 함수의 중괄호)로 인해 때때로 발생하는 혼동을 피하기 위해 약간의 추가 시간을 소비합니다. 병합 할 브랜치가 심하게 분기 된 경우이 옵션을 사용하십시오. &lt;a href=&quot;git-diff&quot;&gt;git-diff [1] &lt;/a&gt; &lt;code&gt;--patience&lt;/code&gt; 도 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="9b7fa933690b4dfe40d9dc500f9cfa6ba3897c3d" translate="yes" xml:space="preserve">
          <source>With this option, diff output for a merge commit shows the differences from each of the parents to the merge result simultaneously instead of showing pairwise diff between a parent and the result one at a time. Furthermore, it lists only files which were modified from all parents.</source>
          <target state="translated">이 옵션을 사용하면 병합 커밋에 대한 diff 출력은 부모와 결과 사이에 한 번에 하나씩 diff를 표시하는 대신 각 부모와 병합 결과의 차이를 동시에 표시합니다. 또한 모든 상위에서 수정 된 파일 만 나열합니다.</target>
        </trans-unit>
        <trans-unit id="3524864d6b6fccf88decb6caefb79eeb0a8e7c7e" translate="yes" xml:space="preserve">
          <source>With this option, git will replace all refnames, paths, blob contents, commit and tag messages, names, and email addresses in the output with anonymized data. Two instances of the same string will be replaced equivalently (e.g., two commits with the same author will have the same anonymized author in the output, but bear no resemblance to the original author string). The relationship between commits, branches, and tags is retained, as well as the commit timestamps (but the commit messages and refnames bear no resemblance to the originals). The relative makeup of the tree is retained (e.g., if you have a root tree with 10 files and 3 trees, so will the output), but their names and the contents of the files will be replaced.</source>
          <target state="translated">이 옵션을 사용하면 git은 출력의 모든 참조 이름, 경로, 얼룩 내용, 커밋 및 태그 메시지, 이름 및 전자 메일 주소를 익명 데이터로 바꿉니다. 동일한 문자열의 두 인스턴스는 동일하게 대체됩니다 (예 : 동일한 작성자의 두 커밋은 출력에서 ​​동일한 익명의 작성자를 갖지만 원래 작성자 문자열과 유사하지 않음). 커밋, 분기 및 태그 간의 관계는 커밋 타임 스탬프와 함께 유지되지만 커밋 메시지 및 참조 이름은 원본과 유사하지 않습니다. 트리의 상대적 구성은 유지되지만 (예를 들어, 파일이 10 개이고 트리가 3 개인 루트 트리가있는 경우 출력도 마찬가지 임) 파일의 이름과 내용이 바뀝니다.</target>
        </trans-unit>
        <trans-unit id="cbb1ff7744c2585e2c6b4c0275539aaae99818d7" translate="yes" xml:space="preserve">
          <source>With this option, parents that are hidden by grafts are packed nevertheless.</source>
          <target state="translated">그럼에도 불구하고이 옵션을 사용하면 이식편에 의해 숨겨진 부모가 포장됩니다.</target>
        </trans-unit>
        <trans-unit id="64d24b372615e7424e92210d8b3079a3b6d54b46" translate="yes" xml:space="preserve">
          <source>With this option, the command includes the current branch to the list of revs to be shown when it is not given on the command line.</source>
          <target state="translated">이 옵션을 사용하면 명령 행에 표시되지 않을 때 표시 할 revs 목록에 대한 현재 분기가 명령에 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="a7994938c4128018ec7f46d918cac8d359a1f2eb" translate="yes" xml:space="preserve">
          <source>With this, &lt;code&gt;git show-branch&lt;/code&gt; without extra parameters would show only the primary branches. In addition, if you happen to be on your topic branch, it is shown as well.</source>
          <target state="translated">이를 통해 추가 매개 변수가없는 &lt;code&gt;git show-branch&lt;/code&gt; 는 기본 분기 만 표시합니다. 또한 토픽 브랜치에있는 경우에도 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="7d389d82d11c207ddbcbb54d477d308b2e5d9f7f" translate="yes" xml:space="preserve">
          <source>With this, Alice can perform the first part of the &quot;pull&quot; operation alone using the &lt;code&gt;git fetch&lt;/code&gt; command without merging them with her own branch, using:</source>
          <target state="translated">이를 통해 Alice는 다음을 사용하여 자체 분기와 병합하지 않고 &lt;code&gt;git fetch&lt;/code&gt; 명령을 사용하여 &quot;풀&quot;작업의 첫 번째 부분 만 수행 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="6062bf6506f2ab2b976dee38aa5322c59a129e2f" translate="yes" xml:space="preserve">
          <source>Within a linked working tree, $GIT_DIR is set to point to this private directory (e.g. &lt;code&gt;/path/main/.git/worktrees/test-next&lt;/code&gt; in the example) and $GIT_COMMON_DIR is set to point back to the main working tree&amp;rsquo;s $GIT_DIR (e.g. &lt;code&gt;/path/main/.git&lt;/code&gt;). These settings are made in a &lt;code&gt;.git&lt;/code&gt; file located at the top directory of the linked working tree.</source>
          <target state="translated">연결된 작업 트리 내에서 $ &lt;code&gt;/path/main/.git/worktrees/test-next&lt;/code&gt; 개인 디렉토리 (예 : /path/main/.git/worktrees/test-next )를 가리 키도록 설정되고 $ GIT_COMMON_DIR은 기본 작업 트리의 $ GIT_DIR을 다시 가리 키도록 설정됩니다. (예 : &lt;code&gt;/path/main/.git&lt;/code&gt; ). 이러한 설정은 연결된 작업 트리의 최상위 디렉토리 에있는 &lt;code&gt;.git&lt;/code&gt; 파일 에서 이루어집니다 .</target>
        </trans-unit>
        <trans-unit id="f531335c76344721aaf744205582ff3be68651bd" translate="yes" xml:space="preserve">
          <source>Without &lt;code&gt;--all&lt;/code&gt; and without any &lt;code&gt;&amp;lt;ref&amp;gt;&lt;/code&gt;, the heads that exist both on the local side and on the remote side are updated.</source>
          <target state="translated">않고 &lt;code&gt;--all&lt;/code&gt; 어떤없이 &lt;code&gt;&amp;lt;ref&amp;gt;&lt;/code&gt; 로컬 측과 원격 측에 모두 존재하는 헤드가 갱신된다.</target>
        </trans-unit>
        <trans-unit id="af870a4c72e2ec7c668a803b1e745b16df6d1c9d" translate="yes" xml:space="preserve">
          <source>Without &lt;code&gt;--follow-symlinks&lt;/code&gt;, these would print data about the symlink itself. In the case of &lt;code&gt;HEAD:link&lt;/code&gt;, you would see</source>
          <target state="translated">&lt;code&gt;--follow-symlinks&lt;/code&gt; 가 없으면 심볼릭 링크 자체에 대한 데이터를 인쇄합니다. 의 경우 &lt;code&gt;HEAD:link&lt;/code&gt; , 당신은 볼 것이다</target>
        </trans-unit>
        <trans-unit id="a213d6298e44415b29925050ee6ffa235637e828" translate="yes" xml:space="preserve">
          <source>Without &lt;code&gt;--force&lt;/code&gt;, the &amp;lt;src&amp;gt; ref is stored at the remote only if &amp;lt;dst&amp;gt; does not exist, or &amp;lt;dst&amp;gt; is a proper subset (i.e. an ancestor) of &amp;lt;src&amp;gt;. This check, known as &quot;fast-forward check&quot;, is performed in order to avoid accidentally overwriting the remote ref and lose other peoples' commits from there.</source>
          <target state="translated">&lt;code&gt;--force&lt;/code&gt; 없이 &amp;lt;src&amp;gt; ref는 &amp;lt;dst&amp;gt;가 없거나 &amp;lt;dst&amp;gt;가 &amp;lt;src&amp;gt;의 적절한 하위 집합 (즉, 조상) 인 경우에만 원격에 저장됩니다. &quot;빨리 감기 검사&quot;라고하는이 검사는 실수로 원격 참조를 덮어 쓰지 않고 다른 사람들의 커밋을 잃지 않도록하기 위해 수행됩니다.</target>
        </trans-unit>
        <trans-unit id="44aa5155d389a8a00fc9a9c0d5c5dc24c0b6b423" translate="yes" xml:space="preserve">
          <source>Without additional configuration, pushes the current branch to the configured upstream (&lt;code&gt;remote.origin.merge&lt;/code&gt; configuration variable) if it has the same name as the current branch, and errors out without pushing otherwise.</source>
          <target state="translated">추가 구성없이 현재 분기와 현재 분기 와 이름이 같은 경우 현재 분기를 구성된 업스트림 ( &lt;code&gt;remote.origin.merge&lt;/code&gt; 구성 변수)으로 푸시하고 그렇지 않으면 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="0d4981e0bf66e69e6f534946531426d82d26ec6d" translate="yes" xml:space="preserve">
          <source>Without an optional path parameter, all files and subdirectories of the current working directory are included in the archive. If one or more paths are specified, only these are included.</source>
          <target state="translated">선택적 경로 매개 변수가 없으면 현재 작업 디렉토리의 모든 파일 및 서브 디렉토리가 아카이브에 포함됩니다. 하나 이상의 경로가 지정되면 해당 경로 만 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="0aaf17e36c6d625d7976371bb21725d2cea205e0" translate="yes" xml:space="preserve">
          <source>Without any credential helpers defined, Git will try the following strategies to ask the user for usernames and passwords:</source>
          <target state="translated">자격 증명 도우미가 정의되지 않은 경우 Git은 사용자에게 사용자 이름과 암호를 요청하기 위해 다음 전략을 시도합니다.</target>
        </trans-unit>
        <trans-unit id="6f8c2669a27a9c22abf3f515b27b1a9a5be3b6dc" translate="yes" xml:space="preserve">
          <source>Without disambiguating &lt;code&gt;--&lt;/code&gt;, Git makes a reasonable guess, but errors out and asking you to disambiguate when ambiguous. E.g. if you have a file called HEAD in your work tree, &lt;code&gt;git diff HEAD&lt;/code&gt; is ambiguous, and you have to say either &lt;code&gt;git diff HEAD --&lt;/code&gt; or &lt;code&gt;git diff -- HEAD&lt;/code&gt; to disambiguate.</source>
          <target state="translated">명확하지 않은 &lt;code&gt;--&lt;/code&gt; , Git은 합리적인 추측을했지만, 오류가 발생하여 모호 할 때 명확하게 할 것을 요구합니다. 예를 들어 작업 트리에 HEAD라는 파일이 있으면 &lt;code&gt;git diff HEAD&lt;/code&gt; 가 모호 &lt;code&gt;git diff HEAD --&lt;/code&gt; 또는 &lt;code&gt;git diff -- HEAD&lt;/code&gt; 중 하나 를 명확히해야합니다.</target>
        </trans-unit>
        <trans-unit id="636ef8b24660180a9f9d02cde9f707a809036029" translate="yes" xml:space="preserve">
          <source>Without the &lt;code&gt;-z&lt;/code&gt; option, pathnames with &quot;unusual&quot; characters are quoted as explained for the configuration variable &lt;code&gt;core.quotePath&lt;/code&gt; (see &lt;a href=&quot;git-config&quot;&gt;git-config[1]&lt;/a&gt;).</source>
          <target state="translated">&lt;code&gt;-z&lt;/code&gt; 옵션이 없으면 구성 변수 &lt;code&gt;core.quotePath&lt;/code&gt; 에 설명 된대로 &quot;비정상적인&quot;문자가 포함 된 경로 이름이 인용됩니다 ( &lt;a href=&quot;git-config&quot;&gt;git-config [1] 참조&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="fbf6695514712c3a8e39b514953f35111f6c3ca8" translate="yes" xml:space="preserve">
          <source>Without the &lt;code&gt;-z&lt;/code&gt; option, pathnames with &quot;unusual&quot; characters are quoted as explained for the configuration variable &lt;code&gt;core.quotePath&lt;/code&gt; (see &lt;a href=&quot;git-config&quot;&gt;git-config[1]&lt;/a&gt;). Using &lt;code&gt;-z&lt;/code&gt; the filename is output verbatim and the line is terminated by a NUL byte.</source>
          <target state="translated">&lt;code&gt;-z&lt;/code&gt; 옵션이 없으면 구성 변수 &lt;code&gt;core.quotePath&lt;/code&gt; 에 설명 된대로 &quot;비정상적인&quot;문자가 포함 된 경로 이름이 인용됩니다 ( &lt;a href=&quot;git-config&quot;&gt;git-config [1] 참조&lt;/a&gt; ). &lt;code&gt;-z&lt;/code&gt; 를 사용 하면 파일 이름이 그대로 출력되고 행이 NUL 바이트로 종료됩니다.</target>
        </trans-unit>
        <trans-unit id="94da29d7f90d6f6f16856adba693bd0f5ed5aeb9" translate="yes" xml:space="preserve">
          <source>Without the &lt;em&gt;--more=1&lt;/em&gt; option, &lt;em&gt;git show-branch&lt;/em&gt; would not output the &lt;em&gt;[master^]&lt;/em&gt; commit, as &lt;em&gt;[mybranch]&lt;/em&gt; commit is a common ancestor of both &lt;em&gt;master&lt;/em&gt; and &lt;em&gt;mybranch&lt;/em&gt; tips. Please see &lt;a href=&quot;git-show-branch&quot;&gt;git-show-branch[1]&lt;/a&gt; for details.</source>
          <target state="translated">&lt;em&gt;--more = 1&lt;/em&gt; 옵션이 없으면 &lt;em&gt;git show-branch&lt;/em&gt; 는 &lt;em&gt;[master ^]&lt;/em&gt; 커밋을 출력하지 않습니다. &lt;em&gt;[mybranch]&lt;/em&gt; 커밋은 &lt;em&gt;마스터&lt;/em&gt; 및 &lt;em&gt;mybranch&lt;/em&gt; 팁 의 공통 조상이기 때문 입니다. 자세한 내용은 &lt;a href=&quot;git-show-branch&quot;&gt;git-show-branch [1]&lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="c29d8269d6df0a76bd7b7031ef1a5a35a844def8" translate="yes" xml:space="preserve">
          <source>Without this flag, &lt;code&gt;git log -p &amp;lt;path&amp;gt;...&lt;/code&gt; shows commits that touch the specified paths, and diffs about the same specified paths. With this, the full diff is shown for commits that touch the specified paths; this means that &quot;&amp;lt;path&amp;gt;&amp;hellip;​&quot; limits only commits, and doesn&amp;rsquo;t limit diff for those commits.</source>
          <target state="translated">이 플래그가 없으면 &lt;code&gt;git log -p &amp;lt;path&amp;gt;...&lt;/code&gt; 는 지정된 경로를 터치하는 커밋을 표시하고 동일한 지정된 경로를 비교합니다. 이를 통해 지정된 경로를 터치하는 커밋에 대한 전체 diff가 표시됩니다. 이것은 &quot;&amp;lt;path&amp;gt;&amp;hellip;&quot;는 커밋 만 제한하고 커밋에 대한 diff를 제한하지 않음을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="b86cf57585935f6e60cc9059e45208393d99c9a8" translate="yes" xml:space="preserve">
          <source>Without this option, pathnames with &quot;unusual&quot; characters are quoted as explained for the configuration variable &lt;code&gt;core.quotePath&lt;/code&gt; (see &lt;a href=&quot;git-config&quot;&gt;git-config[1]&lt;/a&gt;).</source>
          <target state="translated">이 옵션이 없으면 구성 변수 &lt;code&gt;core.quotePath&lt;/code&gt; 에 설명 된대로 &quot;비정상적인&quot;문자가 포함 된 경로 이름이 인용됩니다 ( &lt;a href=&quot;git-config&quot;&gt;git-config [1] 참조&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="8450aafea5471fb336aa6711b707fb955fd65d91" translate="yes" xml:space="preserve">
          <source>Workflow for a third party library</source>
          <target state="translated">써드 파티 라이브러리의 워크 플로우</target>
        </trans-unit>
        <trans-unit id="8dfb0e4b50fd82c5ff8bc5fed81147f5e4aadb05" translate="yes" xml:space="preserve">
          <source>Workflow for an artificially split repo</source>
          <target state="translated">인위적으로 분할 된 저장소에 대한 워크 플로우</target>
        </trans-unit>
        <trans-unit id="825ce9e97dc41179ec167b83be91179b5dacd316" translate="yes" xml:space="preserve">
          <source>Workflows</source>
          <target state="translated">Workflows</target>
        </trans-unit>
        <trans-unit id="72b02433b5041ac5ef6045242ff8d0e2784944a3" translate="yes" xml:space="preserve">
          <source>Working branch; defaults to HEAD.</source>
          <target state="translated">워킹 브랜치; 기본값은 HEAD입니다.</target>
        </trans-unit>
        <trans-unit id="a2b68acce45b31c1701e61880a9ac430bd217ef5" translate="yes" xml:space="preserve">
          <source>Working directory specific configuration file for the main working directory in multiple working directory setup (see &lt;a href=&quot;git-worktree&quot;&gt;git-worktree[1]&lt;/a&gt;).</source>
          <target state="translated">여러 작업 디렉토리 설정에서 기본 작업 디렉토리에 대한 작업 디렉토리 특정 구성 파일 ( &lt;a href=&quot;git-worktree&quot;&gt;git-worktree [1] 참조&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="29f32a47a3074cae8d2558abdc45a4c7a3f4de27" translate="yes" xml:space="preserve">
          <source>Working directory specific configuration file.</source>
          <target state="translated">작업 디렉토리 특정 구성 파일.</target>
        </trans-unit>
        <trans-unit id="b7010e71f35d363293e1c71cea9eb7b673f227d7" translate="yes" xml:space="preserve">
          <source>Working trees can be identified by path, either relative or absolute.</source>
          <target state="translated">작업 트리는 상대 또는 절대 경로로 식별 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e5850a4e043e763eb3c70b51337df764ed12f013" translate="yes" xml:space="preserve">
          <source>Working with others</source>
          <target state="translated">다른 사람들과 함께 일하기</target>
        </trans-unit>
        <trans-unit id="883363a342498bf776fadbacf0d9322246ddce5d" translate="yes" xml:space="preserve">
          <source>Working with others, shared repository style</source>
          <target state="translated">다른 사람과 작업, 공유 저장소 스타일</target>
        </trans-unit>
        <trans-unit id="62159bf12f9108d11431e1d1114bdbbeecf78451" translate="yes" xml:space="preserve">
          <source>Works just like --signature except the signature is read from a file.</source>
          <target state="translated">서명을 파일에서 읽는 것을 제외하고 --signature와 동일하게 작동합니다.</target>
        </trans-unit>
        <trans-unit id="097006f59137099e2d2ccff414198fea83903044" translate="yes" xml:space="preserve">
          <source>Works just like format.signature except the contents of the file specified by this variable will be used as the signature.</source>
          <target state="translated">이 변수로 지정된 파일의 내용이 서명으로 사용된다는 점을 제외하면 format.signature와 동일하게 작동합니다.</target>
        </trans-unit>
        <trans-unit id="c45647582ec4fc92bdcd3ecd1a16e9638ca339a8" translate="yes" xml:space="preserve">
          <source>Works like &lt;code&gt;git push &amp;lt;remote&amp;gt;&lt;/code&gt;, where &amp;lt;remote&amp;gt; is the current branch&amp;rsquo;s remote (or &lt;code&gt;origin&lt;/code&gt;, if no remote is configured for the current branch).</source>
          <target state="translated">&lt;code&gt;git push &amp;lt;remote&amp;gt;&lt;/code&gt; 와 같이 작동합니다 . 여기서 &amp;lt;remote&amp;gt;는 현재 브랜치의 리모트 (또는 현재 브랜치에 대해 리모트가 구성되지 않은 경우 &lt;code&gt;origin&lt;/code&gt; )입니다.</target>
        </trans-unit>
        <trans-unit id="96f0b3b7db8530493b30466426fa80c5c21f66c1" translate="yes" xml:space="preserve">
          <source>Wrap code spawning child processes.</source>
          <target state="translated">코드 생성 하위 프로세스를 랩핑하십시오.</target>
        </trans-unit>
        <trans-unit id="1f9c72af7bca7c9666626fcb471d6065e154c93d" translate="yes" xml:space="preserve">
          <source>Write a MIDX file for the packfiles in an alternate object store.</source>
          <target state="translated">대체 오브젝트 저장소에 팩 파일에 대한 MIDX 파일을 작성하십시오.</target>
        </trans-unit>
        <trans-unit id="36b48ab2e331354b7c3cc2f14ff9d8ea9d1001c3" translate="yes" xml:space="preserve">
          <source>Write a MIDX file for the packfiles in the current .git folder.</source>
          <target state="translated">현재 .git 폴더에 팩 파일에 대한 MIDX 파일을 작성하십시오.</target>
        </trans-unit>
        <trans-unit id="b42a0c66496716fcd8c88f5906d20e5cf08f4975" translate="yes" xml:space="preserve">
          <source>Write a chapter on using plumbing and writing scripts.</source>
          <target state="translated">배관 사용 및 스크립트 작성에 관한 장을 작성하십시오.</target>
        </trans-unit>
        <trans-unit id="c8e128b9f546fd58c7e614d0f8b8821821084ae1" translate="yes" xml:space="preserve">
          <source>Write a commit-graph after fetching. This overrides the config setting &lt;code&gt;fetch.writeCommitGraph&lt;/code&gt;.</source>
          <target state="translated">페치 후 커밋 그래프를 작성하십시오. 이는 구성 설정 &lt;code&gt;fetch.writeCommitGraph&lt;/code&gt; 를 대체합니다 .</target>
        </trans-unit>
        <trans-unit id="e518a1279678087b263b8a6d5d4572c2e8b9dd3b" translate="yes" xml:space="preserve">
          <source>Write a commit-graph file based on the commits found in packfiles.</source>
          <target state="translated">packfile에있는 커밋을 기반으로 커밋 그래프 파일을 작성하십시오.</target>
        </trans-unit>
        <trans-unit id="a8a7e9f2485bf10bd9980490fdf55b0594e99b5f" translate="yes" xml:space="preserve">
          <source>Write a commit-graph file containing all commits in the current commit-graph file along with those reachable from &lt;code&gt;HEAD&lt;/code&gt;.</source>
          <target state="translated">현재 커밋 그래프 파일의 모든 커밋과 &lt;code&gt;HEAD&lt;/code&gt; 에서 도달 가능한 커밋이 포함 된 커밋 그래프 파일을 작성하십시오 .</target>
        </trans-unit>
        <trans-unit id="8c34e4cbacab76dc7a95f5e0f46081aab1f59603" translate="yes" xml:space="preserve">
          <source>Write a commit-graph file containing all reachable commits.</source>
          <target state="translated">도달 가능한 모든 커밋을 포함하는 커밋 그래프 파일을 작성하십시오.</target>
        </trans-unit>
        <trans-unit id="e1238f6b25cc5d29bebfcc60e794e1647b6dd786" translate="yes" xml:space="preserve">
          <source>Write a commit-graph file for the packed commits in your local &lt;code&gt;.git&lt;/code&gt; directory.</source>
          <target state="translated">압축 된 커밋에 대한 커밋 그래프 파일을 로컬 &lt;code&gt;.git&lt;/code&gt; 디렉토리에 작성하십시오.</target>
        </trans-unit>
        <trans-unit id="7ba716e808cc8cf569e10d2453e1761bc59eae40" translate="yes" xml:space="preserve">
          <source>Write a commit-graph file, extending the current commit-graph file using commits in &lt;code&gt;&amp;lt;pack-index&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&amp;lt;pack-index&amp;gt;&lt;/code&gt; 의 커밋을 사용하여 현재 커밋 그래프 파일을 확장하여 커밋 그래프 파일을 작성하십시오 .</target>
        </trans-unit>
        <trans-unit id="73c3a355bd823c82bb9b3a929df0d2e920a5e648" translate="yes" xml:space="preserve">
          <source>Write a new MIDX file.</source>
          <target state="translated">새로운 MIDX 파일을 작성하십시오.</target>
        </trans-unit>
        <trans-unit id="b0d7b6d61dd4b6501290a029b72f9ed15f8cc305" translate="yes" xml:space="preserve">
          <source>Write a reachability bitmap index as part of the repack. This only makes sense when used with &lt;code&gt;-a&lt;/code&gt; or &lt;code&gt;-A&lt;/code&gt;, as the bitmaps must be able to refer to all reachable objects. This option overrides the setting of &lt;code&gt;repack.writeBitmaps&lt;/code&gt;. This option has no effect if multiple packfiles are created.</source>
          <target state="translated">재 포장의 일부로 도달 가능성 비트 맵 인덱스를 작성하십시오. 비트 맵이 도달 가능한 모든 객체를 참조 할 수 있어야하므로 &lt;code&gt;-a&lt;/code&gt; 또는 &lt;code&gt;-A&lt;/code&gt; 와 함께 사용하는 경우에만 의미가 있습니다. 이 옵션은 &lt;code&gt;repack.writeBitmaps&lt;/code&gt; 설정을 대체합니다 . 이 옵션은 여러 팩 파일이 작성된 경우 적용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="0ec591cf31eda36450bc843a926c4fd529f9a0da" translate="yes" xml:space="preserve">
          <source>Write a set of patterns to the sparse-checkout file, as given as a list of arguments following the &lt;code&gt;set&lt;/code&gt; subcommand. Update the working directory to match the new patterns. Enable the core.sparseCheckout config setting if it is not already enabled.</source>
          <target state="translated">&lt;code&gt;set&lt;/code&gt; 부속 명령 다음에 인수 목록으로 제공된대로 패턴 세트를 스파 스 체크 아웃 파일에 씁니다 . 새 패턴과 일치하도록 작업 디렉토리를 업데이트하십시오. core.sparseCheckout 구성 설정이 아직 활성화되지 않은 경우 활성화하십시오.</target>
        </trans-unit>
        <trans-unit id="041470620f3506e6e154d55da89dd48b2bba6ec8" translate="yes" xml:space="preserve">
          <source>Write and verify Git commit-graph files</source>
          <target state="translated">Git 커밋 그래프 파일 작성 및 확인</target>
        </trans-unit>
        <trans-unit id="fbde21d9f61e2faa3e597fb0c951212436d2d05f" translate="yes" xml:space="preserve">
          <source>Write and verify multi-pack-indexes</source>
          <target state="translated">멀티 팩 인덱스 작성 및 확인</target>
        </trans-unit>
        <trans-unit id="0874d3d36a3af067f281de19e268427b067828a4" translate="yes" xml:space="preserve">
          <source>Write dangling objects into .git/lost-found/commit/ or .git/lost-found/other/, depending on type. If the object is a blob, the contents are written into the file, rather than its object name.</source>
          <target state="translated">매달린 객체를 유형에 따라 .git / lost-found / commit / 또는 .git / lost-found / other /에 씁니다. 오브젝트가 Blob 인 경우 컨텐츠는 오브젝트 이름이 아닌 파일에 기록됩니다.</target>
        </trans-unit>
        <trans-unit id="d9accbc71f1215e3614372f554930a021fe71b0a" translate="yes" xml:space="preserve">
          <source>Write into pairs of files (.pack and .idx), using &amp;lt;base-name&amp;gt; to determine the name of the created file. When this option is used, the two files in a pair are written in &amp;lt;base-name&amp;gt;-&amp;lt;SHA-1&amp;gt;.{pack,idx} files. &amp;lt;SHA-1&amp;gt; is a hash based on the pack content and is written to the standard output of the command.</source>
          <target state="translated">&amp;lt;base-name&amp;gt;을 사용하여 파일 쌍 (.pack 및 .idx)에 작성하여 작성된 파일의 이름을 판별하십시오. 이 옵션을 사용하면 한 쌍의 두 파일이 &amp;lt;base-name&amp;gt;-&amp;lt;SHA-1&amp;gt;. {pack, idx} 파일에 기록됩니다. &amp;lt;SHA-1&amp;gt;은 팩 내용을 기반으로하는 해시이며 명령의 표준 출력에 기록됩니다.</target>
        </trans-unit>
        <trans-unit id="7fe0c30065baa84a0511c3d3081d91c7d606dfea" translate="yes" xml:space="preserve">
          <source>Write or verify a multi-pack-index (MIDX) file.</source>
          <target state="translated">다중 팩 인덱스 (MIDX) 파일을 쓰거나 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="e39d29fa27aa3fd795b76126771a3ffa6c08d16a" translate="yes" xml:space="preserve">
          <source>Write responses to &lt;code&gt;get-mark&lt;/code&gt;, &lt;code&gt;cat-blob&lt;/code&gt;, and &lt;code&gt;ls&lt;/code&gt; queries to the file descriptor &amp;lt;fd&amp;gt; instead of &lt;code&gt;stdout&lt;/code&gt;. Allows &lt;code&gt;progress&lt;/code&gt; output intended for the end-user to be separated from other output.</source>
          <target state="translated">&lt;code&gt;stdout&lt;/code&gt; 대신 &lt;code&gt;get-mark&lt;/code&gt; , &lt;code&gt;cat-blob&lt;/code&gt; 및 &lt;code&gt;ls&lt;/code&gt; 쿼리에 대한 응답을 파일 디스크립터 &amp;lt;fd&amp;gt;에 씁니다 . 허용 &lt;code&gt;progress&lt;/code&gt; 최종 사용자를위한 출력은 다른 출력으로부터 분리된다.</target>
        </trans-unit>
        <trans-unit id="e189db14fd9c8dacb74b437fa25a566d7b39760b" translate="yes" xml:space="preserve">
          <source>Write the archive to &amp;lt;file&amp;gt; instead of stdout.</source>
          <target state="translated">아카이브를 stdout 대신 &amp;lt;file&amp;gt;에 씁니다.</target>
        </trans-unit>
        <trans-unit id="7dc7fd5fc893589e612150dc5a94bc95c63f6644" translate="yes" xml:space="preserve">
          <source>Write the generated pack index into the specified file. Without this option the name of pack index file is constructed from the name of packed archive file by replacing .pack with .idx (and the program fails if the name of packed archive does not end with .pack).</source>
          <target state="translated">생성 된 팩 색인을 지정된 파일에 기록하십시오. 이 옵션이 없으면 팩 색인 파일의 이름은 .pack을 .idx로 바꾸어 압축 된 아카이브 파일 이름으로 구성됩니다 (그리고 압축 된 아카이브 이름이 .pack으로 끝나지 않으면 프로그램이 실패 함).</target>
        </trans-unit>
        <trans-unit id="7ee51e3bc5f984d1828334228be7ce34fc987d1e" translate="yes" xml:space="preserve">
          <source>Write the pack contents (what would have been written to .pack file) out to the standard output.</source>
          <target state="translated">팩 내용 (.pack 파일에 기록 된 내용)을 표준 출력에 기록하십시오.</target>
        </trans-unit>
        <trans-unit id="f8fab17bc8f3e5385c26a96bd869170c9b748651" translate="yes" xml:space="preserve">
          <source>Write the resulting index out in the named on-disk format version. Supported versions are 2, 3 and 4. The current default version is 2 or 3, depending on whether extra features are used, such as &lt;code&gt;git add -N&lt;/code&gt;.</source>
          <target state="translated">결과 색인을 명명 된 온 디스크 형식 버전으로 작성하십시오. 지원되는 버전은 2, 3 및 4입니다. 현재 기본 버전은 &lt;code&gt;git add -N&lt;/code&gt; 과 같은 추가 기능의 사용 여부에 따라 2 또는 3 입니다.</target>
        </trans-unit>
        <trans-unit id="efedecbf7e9a176a45aaee6d10ad017d653ffad6" translate="yes" xml:space="preserve">
          <source>Write to standard error. Note that if &lt;code&gt;--detach&lt;/code&gt; is specified, the process disconnects from the real standard error, making this destination effectively equivalent to &lt;code&gt;none&lt;/code&gt;.</source>
          <target state="translated">표준 오류에 씁니다. 참고 경우 것으로 &lt;code&gt;--detach&lt;/code&gt; 가 지정되어, 실제 표준 오류에서 프로세스 연결 해제는, 효과적으로 상당이 대상 만드는 &lt;code&gt;none&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="04570d31869f8fe0ff9437709cb2be3000b6efb7" translate="yes" xml:space="preserve">
          <source>Write to syslog, using the &lt;code&gt;git-daemon&lt;/code&gt; identifier.</source>
          <target state="translated">&lt;code&gt;git-daemon&lt;/code&gt; 식별자를 사용하여 syslog에 씁니다 .</target>
        </trans-unit>
        <trans-unit id="b06c59a883065a2aa7a048f19cdd388e420a56a1" translate="yes" xml:space="preserve">
          <source>Write whatever message you want, and all the lines that start with &lt;code&gt;#&lt;/code&gt; will be pruned out, and the rest will be used as the commit message for the change. If you decide you don&amp;rsquo;t want to commit anything after all at this point (you can continue to edit things and update the index), you can just leave an empty message. Otherwise &lt;code&gt;git commit&lt;/code&gt; will commit the change for you.</source>
          <target state="translated">원하는 메시지를 쓰면 &lt;code&gt;#&lt;/code&gt; 으로 시작하는 모든 줄이 정리되고 나머지는 변경에 대한 커밋 메시지로 사용됩니다. 이 시점에서 아무 것도 커밋하지 않기로 결정한 경우 (항목을 계속 편집하고 인덱스를 업데이트 할 수 있음) 빈 메시지를 남길 수 있습니다. 그렇지 않으면 &lt;code&gt;git commit&lt;/code&gt; 이 변경 사항을 커밋합니다.</target>
        </trans-unit>
        <trans-unit id="61b122f3a92e6ba319a161e3ee36a5061ca2ea4c" translate="yes" xml:space="preserve">
          <source>Writes a tree object that represents a subdirectory &lt;code&gt;&amp;lt;prefix&amp;gt;&lt;/code&gt;. This can be used to write the tree object for a subproject that is in the named subdirectory.</source>
          <target state="translated">&lt;code&gt;&amp;lt;prefix&amp;gt;&lt;/code&gt; 서브 디렉토리를 나타내는 트리 오브젝트를 작성합니다 . 이름이 지정된 서브 디렉토리에있는 서브 프로젝트의 트리 오브젝트를 작성하는 데 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="157114a94f76dd225b6968a998012309617b01fe" translate="yes" xml:space="preserve">
          <source>Writes the commit-id into the filename under $GIT_DIR/refs/&amp;lt;filename&amp;gt; on the local end after the transfer is complete.</source>
          <target state="translated">전송이 완료된 후 로컬 끝에서 $ GIT_DIR / refs / &amp;lt;filename&amp;gt; 아래의 파일 이름에 commit-id를 씁니다.</target>
        </trans-unit>
        <trans-unit id="e02c77bcdadadb66d0f7703e015b6bcd89a6c5e3" translate="yes" xml:space="preserve">
          <source>X: &quot;unknown&quot; change type (most probably a bug, please report it)</source>
          <target state="translated">X : &quot;알 수없는&quot;변경 유형 (아마도 버그 일 것입니다.)</target>
        </trans-unit>
        <trans-unit id="c4701ab33311f5af4d25d032b9d36f7ee2d229e7" translate="yes" xml:space="preserve">
          <source>You &lt;code&gt;must&lt;/code&gt; therefore ensure that the most recent commit of the branch you want to dcommit to is the &lt;code&gt;first&lt;/code&gt; parent of the merge. Chaos will ensue otherwise, especially if the first parent is an older commit on the same SVN branch.</source>
          <target state="translated">당신은 &lt;code&gt;must&lt;/code&gt; , 따라서 가장 최근의 당신에 dcommit 할 브랜치의 커밋되도록하는 것은입니다 &lt;code&gt;first&lt;/code&gt; 병합의 부모입니다. 특히 첫 번째 부모가 같은 SVN 브랜치에서 이전 커밋 인 경우 혼돈이 발생합니다.</target>
        </trans-unit>
        <trans-unit id="33b03e34a8212275c562b3fd47359312e9fb9f26" translate="yes" xml:space="preserve">
          <source>You also could say &lt;code&gt;c&lt;/code&gt; or &lt;code&gt;clean&lt;/code&gt; above as long as the choice is unique.</source>
          <target state="translated">선택이 독특하다면 &lt;code&gt;c&lt;/code&gt; 를 말 하거나 위에서 &lt;code&gt;clean&lt;/code&gt; 말할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="3633df0f340d7a5b00e10a65751fa4510ce91fa7" translate="yes" xml:space="preserve">
          <source>You also could say &lt;code&gt;s&lt;/code&gt; or &lt;code&gt;sta&lt;/code&gt; or &lt;code&gt;status&lt;/code&gt; above as long as the choice is unique.</source>
          <target state="translated">선택 사항이 고유 한 한 &lt;code&gt;s&lt;/code&gt; 또는 &lt;code&gt;sta&lt;/code&gt; 또는 &lt;code&gt;status&lt;/code&gt; 를 위와 같이 말할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="80dcbb43282a1e399b57f0acd29e7d516598c299" translate="yes" xml:space="preserve">
          <source>You also need to ensure that each repository is &quot;bare&quot; (without a Git index file) for &lt;code&gt;cvs commit&lt;/code&gt; to work. See &lt;a href=&quot;gitcvs-migration&quot;&gt;gitcvs-migration[7]&lt;/a&gt;.</source>
          <target state="translated">또한 &lt;code&gt;cvs commit&lt;/code&gt; 이 작동하려면 각 저장소가 Git 인덱스 파일없이 &quot;베어&quot;인지 확인해야합니다 . &lt;a href=&quot;gitcvs-migration&quot;&gt;gitcvs-migration [7]을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="63d1d5a88c78a80cfc3950acb2e452ff58df3b69" translate="yes" xml:space="preserve">
          <source>You also should not rewind branches in a submodule beyond commits that were ever recorded in any superproject.</source>
          <target state="translated">또한 수퍼 프로젝트에서 기록 된 커밋 이외의 하위 모듈에서 분기를 되 감지 않아야합니다.</target>
        </trans-unit>
        <trans-unit id="9cb8652293d991a8fc334c9f946fb5900f566815" translate="yes" xml:space="preserve">
          <source>You are happily working on something, and find the changes in these files are in good order. You do not want to see them when you run &lt;code&gt;git diff&lt;/code&gt;, because you plan to work on other files and changes with these files are distracting.</source>
          <target state="translated">행복하게 작업하고 있으며 이러한 파일의 변경 사항이 올바른지 확인하십시오. &lt;code&gt;git diff&lt;/code&gt; 를 실행할 때 다른 파일에 대한 작업을 계획하고 이러한 파일에 대한 변경 내용이 산만 해지기 때문에 이를보고 싶지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="48f9e78ec61620aadfc7c1e71bab372f08845a6f" translate="yes" xml:space="preserve">
          <source>You are in the middle of a refactoring session and your boss comes in and demands that you fix something immediately. You might typically use &lt;a href=&quot;git-stash&quot;&gt;git-stash[1]&lt;/a&gt; to store your changes away temporarily, however, your working tree is in such a state of disarray (with new, moved, and removed files, and other bits and pieces strewn around) that you don&amp;rsquo;t want to risk disturbing any of it. Instead, you create a temporary linked working tree to make the emergency fix, remove it when done, and then resume your earlier refactoring session.</source>
          <target state="translated">리팩토링 세션 중에 상사가 와서 즉시 무언가를 고치라고 요구합니다. 일반적으로 &lt;a href=&quot;git-stash&quot;&gt;git-stash [1]&lt;/a&gt; 를 사용하여 변경 사항을 임시로 저장하지만 작업 트리는 (새 파일, 이동 및 제거 된 파일 및 기타 비트와 조각이 흩어져있는) 혼란 상태에 있습니다. 방해 할 위험이 없습니다. 대신 임시 링크 작업 트리를 작성하여 응급 수정을 수행하고 완료되면 제거하고 이전 리팩토링 세션을 재개하십시오.</target>
        </trans-unit>
        <trans-unit id="bb2df2ca18755cbd46a4ed871293669f22530506" translate="yes" xml:space="preserve">
          <source>You are now ready to commit. You can see what is about to be committed using &lt;code&gt;git diff&lt;/code&gt; with the --cached option:</source>
          <target state="translated">이제 커밋 할 준비가되었습니다. --cached 옵션과 함께 &lt;code&gt;git diff&lt;/code&gt; 를 사용하여 커밋하려는 내용을 확인할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="074e56336e1be0630703b280d6a3b60899f28a4c" translate="yes" xml:space="preserve">
          <source>You can adjust how pages generated by gitweb look using the variables described below. You can change the site name, add common headers and footers for all pages, and add a description of this gitweb installation on its main page (which is the projects list page), etc.</source>
          <target state="translated">아래 설명 된 변수를 사용하여 gitweb에 의해 생성 된 페이지 모양을 조정할 수 있습니다. 사이트 이름을 변경하고 모든 페이지에 공통 머리글과 바닥 글을 추가하고 기본 페이지 (프로젝트 목록 페이지)에이 gitweb 설치에 대한 설명을 추가 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f5130cbe18f25cdc12700266fadc1f554b9c37ce" translate="yes" xml:space="preserve">
          <source>You can also ask git log to show patches:</source>
          <target state="translated">git log에게 패치를 보여달라고 요청할 수도 있습니다 :</target>
        </trans-unit>
        <trans-unit id="f5378640dc8884e7695fa8d24ebc61aad94be600" translate="yes" xml:space="preserve">
          <source>You can also check out &lt;code&gt;origin/todo&lt;/code&gt; directly to examine it or write a one-off patch. See &lt;a href=&quot;#detached-head&quot;&gt;detached head&lt;/a&gt;.</source>
          <target state="translated">당신은 또한 확인할 수 있습니다 &lt;code&gt;origin/todo&lt;/code&gt; 을 검사하거나 일회성 패치를 작성하는 직접. &lt;a href=&quot;#detached-head&quot;&gt;분리 된 헤드를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="1dba829f7b6e6b2354184e851e59ecadab491f50" translate="yes" xml:space="preserve">
          <source>You can also edit a patch series with an interactive rebase. This is the same as &lt;a href=&quot;#reordering-patch-series&quot;&gt;reordering a patch series using &lt;code&gt;format-patch&lt;/code&gt;&lt;/a&gt;, so use whichever interface you like best.</source>
          <target state="translated">대화식 rebase를 사용하여 패치 시리즈를 편집 할 수도 있습니다. &lt;a href=&quot;#reordering-patch-series&quot;&gt; &lt;code&gt;format-patch&lt;/code&gt; 를&lt;/a&gt; 사용하여 패치 시리즈를 재정렬하는 것과 동일 하므로 가장 선호하는 인터페이스를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="a56f9e1e04034dbb228cdfc1e0cb38c07a8bcbf1" translate="yes" xml:space="preserve">
          <source>You can also fetch branches from other repositories; so</source>
          <target state="translated">다른 리포지토리에서 분기를 가져올 수도 있습니다. 그래서</target>
        </trans-unit>
        <trans-unit id="bb4e25e283a061b1bebe5a9dd36fbbd03f0e1b4b" translate="yes" xml:space="preserve">
          <source>You can also give &lt;code&gt;git log&lt;/code&gt; a &quot;range&quot; of commits where the first is not necessarily an ancestor of the second; for example, if the tips of the branches &quot;stable&quot; and &quot;master&quot; diverged from a common commit some time ago, then</source>
          <target state="translated">&lt;code&gt;git log&lt;/code&gt; 에 커밋의 &quot;범위&quot;를 줄 수도 있습니다 . 첫 번째는 반드시 두 번째의 조상이 아닙니다. 예를 들어 분기 &quot;안정한&quot;및 &quot;마스터&quot;의 팁이 얼마 전에 공통 커밋에서 벗어난 경우</target>
        </trans-unit>
        <trans-unit id="c219057e4d44e965fab9fe1f77892cd8f09c5753" translate="yes" xml:space="preserve">
          <source>You can also give commits names of your own; after running</source>
          <target state="translated">또한 커밋 이름을 지정할 수도 있습니다. 실행 후</target>
        </trans-unit>
        <trans-unit id="cecebc054603ae5ff87afcd3e6caec5420b5c866" translate="yes" xml:space="preserve">
          <source>You can also override locations of gitweb configuration files during runtime by setting the following environment variables: &lt;code&gt;GITWEB_CONFIG_COMMON&lt;/code&gt;, &lt;code&gt;GITWEB_CONFIG_SYSTEM&lt;/code&gt; and &lt;code&gt;GITWEB_CONFIG&lt;/code&gt; to a non-empty value.</source>
          <target state="translated">&lt;code&gt;GITWEB_CONFIG_COMMON&lt;/code&gt; , &lt;code&gt;GITWEB_CONFIG_SYSTEM&lt;/code&gt; 및 &lt;code&gt;GITWEB_CONFIG&lt;/code&gt; 환경 변수를 비어 있지 않은 값 으로 설정하여 런타임 동안 gitweb 구성 파일의 위치를 ​​무시할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="c335f539c67224e67ef9ba8bcb55a78f32c2ba64" translate="yes" xml:space="preserve">
          <source>You can also revert an earlier change, for example, the next-to-last:</source>
          <target state="translated">또한 다음 변경 사항과 같은 이전 변경 사항을 되돌릴 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="f6f0f4e5da7f74f3d7e6aefa5597ca88126ce358" translate="yes" xml:space="preserve">
          <source>You can also run &lt;code&gt;git daemon&lt;/code&gt; as an inetd service; see the &lt;a href=&quot;git-daemon&quot;&gt;git-daemon[1]&lt;/a&gt; man page for details. (See especially the examples section.)</source>
          <target state="translated">&lt;code&gt;git daemon&lt;/code&gt; 을 inetd 서비스로 실행할 수도 있습니다 . 자세한 내용은 &lt;a href=&quot;git-daemon&quot;&gt;git-daemon [1]&lt;/a&gt; 매뉴얼 페이지를 참조하십시오. (특히 예제 섹션을 참조하십시오.)</target>
        </trans-unit>
        <trans-unit id="f0a51538febea0717277859dfbb5418b689055cc" translate="yes" xml:space="preserve">
          <source>You can also see what references it offers:</source>
          <target state="translated">어떤 참조가 제공되는지 확인할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="f06fdd5b89ee465ae510128ba09f10dd8adf5eac" translate="yes" xml:space="preserve">
          <source>You can also skip a range of commits, instead of just one commit, using range notation. For example:</source>
          <target state="translated">범위 표기법을 사용하여 단 하나의 커밋 대신 커밋 범위를 건너 뛸 수도 있습니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="54e517ee1d2086de2439776d35ac41cdff2f30f7" translate="yes" xml:space="preserve">
          <source>You can also track branches from repositories other than the one you cloned from, using &lt;a href=&quot;git-remote&quot;&gt;git-remote[1]&lt;/a&gt;:</source>
          <target state="translated">&lt;a href=&quot;git-remote&quot;&gt;git-remote [1]을&lt;/a&gt; 사용하여 복제 한 저장소 이외의 저장소에서 분기를 추적 할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="28b63a93050077dfe73e5bbbcd2b4df244cc4f26" translate="yes" xml:space="preserve">
          <source>You can also use &lt;a href=&quot;git-gui&quot;&gt;git-gui[1]&lt;/a&gt; to create commits, view changes in the index and the working tree files, and individually select diff hunks for inclusion in the index (by right-clicking on the diff hunk and choosing &quot;Stage Hunk For Commit&quot;).</source>
          <target state="translated">당신은 또한 사용할 수 있습니다 &lt;a href=&quot;git-gui&quot;&gt;자식 - GUI [1]&lt;/a&gt; 은 diff 화물선과 &quot;무대 덩어리에 대한 선택을 마우스 오른쪽 버튼으로 클릭 (인덱스에 포함 DIFF 심술쟁이을 선택 개별적으로 커밋,보기 변경 인덱스와 작업 트리 파일을 생성하고, 범하다&quot;).</target>
        </trans-unit>
        <trans-unit id="2d89b19204028ed2768f0a7d6951c7af3234e547" translate="yes" xml:space="preserve">
          <source>You can also use &lt;code&gt;git format-patch --base=P -3 C&lt;/code&gt; to generate patches for A, B and C, and the identifiers for P, X, Y, Z are appended at the end of the first message.</source>
          <target state="translated">또한 사용할 수있는 &lt;code&gt;git format-patch --base=P -3 C&lt;/code&gt; A, B 및 C에 대한 패치를 생성하고, P, X, Y, Z에 대한 식별자는 제 메시지의 끝에 추가된다.</target>
        </trans-unit>
        <trans-unit id="2c144befb1f45c546071ce64e48b303dc0e810a7" translate="yes" xml:space="preserve">
          <source>You can also use &lt;code&gt;git show&lt;/code&gt; to see any such file:</source>
          <target state="translated">&lt;code&gt;git show&lt;/code&gt; 를 사용 하여 그러한 파일을 볼 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="49c3eff4b4dfbb20ea17f1bea994d4ab08b8a178" translate="yes" xml:space="preserve">
          <source>You can also use the &lt;code&gt;git_commit_non_empty_tree &quot;$@&quot;&lt;/code&gt; instead of &lt;code&gt;git commit-tree &quot;$@&quot;&lt;/code&gt; if you don&amp;rsquo;t wish to keep commits with a single parent and that makes no change to the tree.</source>
          <target state="translated">단일 부모와 커밋을 유지하지 않고 트리를 변경하지 않으려면 &lt;code&gt;git commit-tree &quot;$@&quot;&lt;/code&gt; &lt;code&gt;git_commit_non_empty_tree &quot;$@&quot;&lt;/code&gt; 대신 git_commit_non_empty_tree &quot;$ @&quot;을 사용할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="015df615c0d1b650e7dd0d33e1d03af134ab36e3" translate="yes" xml:space="preserve">
          <source>You can always just jump back to your original &lt;code&gt;master&lt;/code&gt; branch by doing</source>
          <target state="translated">당신은 항상 원래의 &lt;code&gt;master&lt;/code&gt; 브랜치로 돌아갈 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e3173f9b04378ce969d4435b57687de248be9e7d" translate="yes" xml:space="preserve">
          <source>You can always view an old version of a file by just checking out the correct revision first. But sometimes it is more convenient to be able to view an old version of a single file without checking anything out; this command does that:</source>
          <target state="translated">올바른 수정본을 먼저 확인하여 항상 파일의 이전 버전을 볼 수 있습니다. 그러나 때로는 아무것도 확인하지 않고 단일 파일의 이전 버전을 볼 수있는 것이 더 편리합니다. 이 명령은 다음을 수행합니다.</target>
        </trans-unit>
        <trans-unit id="ac57e48df46d91546d0b6c2ab36f112078813032" translate="yes" xml:space="preserve">
          <source>You can at any time create a new branch by just picking an arbitrary point in the project history, and just writing the SHA-1 name of that object into a file under &lt;code&gt;.git/refs/heads/&lt;/code&gt;. You can use any filename you want (and indeed, subdirectories), but the convention is that the &quot;normal&quot; branch is called &lt;code&gt;master&lt;/code&gt;. That&amp;rsquo;s just a convention, though, and nothing enforces it.</source>
          <target state="translated">프로젝트 히스토리에서 임의의 지점을 선택하고 해당 오브젝트의 SHA-1 이름을 &lt;code&gt;.git/refs/heads/&lt;/code&gt; 아래의 파일에 작성하여 언제든지 새 브랜치를 작성할 수 있습니다 . 원하는 파일 이름 (및 실제로 서브 디렉토리)을 사용할 수 있지만 &quot;일반&quot;브랜치는 &lt;code&gt;master&lt;/code&gt; 라고 합니다. 그것은 단지 관습 일 뿐이며, 그것을 강요하는 것은 없습니다.</target>
        </trans-unit>
        <trans-unit id="28fdfbc805da6922683f26cc12f785c6a111b6ce" translate="yes" xml:space="preserve">
          <source>You can choose to provide the name of a file in &lt;code&gt;$GIT_DIR/branches&lt;/code&gt;. The URL in this file will be used to access the repository. This file should have the following format:</source>
          <target state="translated">&lt;code&gt;$GIT_DIR/branches&lt;/code&gt; 파일 이름을 제공하도록 선택할 수 있습니다 . 이 파일의 URL은 저장소에 액세스하는 데 사용됩니다. 이 파일은 다음 형식이어야합니다.</target>
        </trans-unit>
        <trans-unit id="184c3e9bbc8e0af36908329654dfda91364d6a99" translate="yes" xml:space="preserve">
          <source>You can choose to provide the name of a file in &lt;code&gt;$GIT_DIR/remotes&lt;/code&gt;. The URL in this file will be used to access the repository. The refspec in this file will be used as default when you do not provide a refspec on the command line. This file should have the following format:</source>
          <target state="translated">&lt;code&gt;$GIT_DIR/remotes&lt;/code&gt; 파일 이름을 제공하도록 선택할 수 있습니다 . 이 파일의 URL은 저장소에 액세스하는 데 사용됩니다. 이 파일의 참조 스펙은 명령 행에 참조 스펙을 제공하지 않을 때 기본값으로 사용됩니다. 이 파일은 다음 형식이어야합니다.</target>
        </trans-unit>
        <trans-unit id="a92f2a4a63c6c2d142357d1e5947af0b6de272f3" translate="yes" xml:space="preserve">
          <source>You can choose to provide the name of a remote which you had previously configured using &lt;a href=&quot;git-remote&quot;&gt;git-remote[1]&lt;/a&gt;, &lt;a href=&quot;git-config&quot;&gt;git-config[1]&lt;/a&gt; or even by a manual edit to the &lt;code&gt;$GIT_DIR/config&lt;/code&gt; file. The URL of this remote will be used to access the repository. The refspec of this remote will be used by default when you do not provide a refspec on the command line. The entry in the config file would appear like this:</source>
          <target state="translated">&lt;a href=&quot;git-remote&quot;&gt;git-remote [1]&lt;/a&gt; , &lt;a href=&quot;git-config&quot;&gt;git-config [1]&lt;/a&gt; 또는 &lt;code&gt;$GIT_DIR/config&lt;/code&gt; 파일 을 수동으로 편집 하여 이전에 구성한 리모컨의 이름을 제공하도록 선택할 수 있습니다 . 이 리모트의 URL은 저장소에 액세스하는 데 사용됩니다. 이 리모트의 참조 스펙은 명령 행에 참조 스펙을 제공하지 않을 때 기본적으로 사용됩니다. 구성 파일의 항목은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="d377d9322805f2d9d1e87d74e556de9916d572ec" translate="yes" xml:space="preserve">
          <source>You can choose whether you want to trust the index file entirely (using the &lt;code&gt;--cached&lt;/code&gt; flag) or ask the diff logic to show any files that don&amp;rsquo;t match the stat state as being &quot;tentatively changed&quot;. Both of these operations are very useful indeed.</source>
          <target state="translated">&lt;code&gt;--cached&lt;/code&gt; 플래그를 사용하여 인덱스 파일을 완전히 신뢰할지 또는 stat 상태와 일치하지 않는 파일을 &quot;잠정적으로 변경됨&quot;으로 표시하도록 diff 논리에 요청 할지 여부를 선택할 수 있습니다 . 이 두 작업은 실제로 매우 유용합니다.</target>
        </trans-unit>
        <trans-unit id="7c0716128ee4fbd827cb316e0652131c44810ab6" translate="yes" xml:space="preserve">
          <source>You can configure gitweb to only list and allow viewing of the explicitly exported repositories, via &lt;code&gt;$export_ok&lt;/code&gt; variable in gitweb config file; see &lt;a href=&quot;gitweb.conf&quot;&gt;gitweb.conf[5]&lt;/a&gt; manpage. If it evaluates to true, gitweb shows repositories only if this file named by &lt;code&gt;$export_ok&lt;/code&gt; exists in its object database (if directory has the magic file named &lt;code&gt;$export_ok&lt;/code&gt;).</source>
          <target state="translated">gitweb 설정 파일의 &lt;code&gt;$export_ok&lt;/code&gt; 변수를 통해 명시 적으로 내 보낸 리포지토리 만 나열하고 볼 수 있도록 gitweb을 구성 할 수 있습니다 . &lt;a href=&quot;gitweb.conf&quot;&gt;gitweb.conf [5]&lt;/a&gt; 맨 페이지를 참조하십시오 . true로 평가되면 gitweb은 &lt;code&gt;$export_ok&lt;/code&gt; 이름 지정된이 파일이 오브젝트 데이터베이스에 존재하는 경우에만 디렉토리를 표시합니다 (디렉토리에 &lt;code&gt;$export_ok&lt;/code&gt; 라는 매직 파일이있는 경우 ).</target>
        </trans-unit>
        <trans-unit id="03a65df391294815ab470e62357c9e62de1fcfb2" translate="yes" xml:space="preserve">
          <source>You can configure individual repositories shown in gitweb by creating file in the &lt;code&gt;GIT_DIR&lt;/code&gt; of Git repository, or by setting some repo configuration variable (in &lt;code&gt;GIT_DIR/config&lt;/code&gt;, see &lt;a href=&quot;git-config&quot;&gt;git-config[1]&lt;/a&gt;).</source>
          <target state="translated">Git 리포지토리 의 &lt;code&gt;GIT_DIR&lt;/code&gt; 에 파일을 만들 거나 일부 repo 구성 변수를 설정 하여 gitweb에 표시되는 개별 리포지토리를 구성 할 수 있습니다 ( &lt;code&gt;GIT_DIR/config&lt;/code&gt; 에서 &lt;a href=&quot;git-config&quot;&gt;git-config [1] 참조&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="45321feeff0945f0a2ba053e8ab969c82cc417c8" translate="yes" xml:space="preserve">
          <source>You can configure the database backend with the following configuration variables:</source>
          <target state="translated">다음 구성 변수를 사용하여 데이터베이스 백엔드를 구성 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d268b7f609741cf4701b8230b6d95314deb17a7a" translate="yes" xml:space="preserve">
          <source>You can create a new commit that undoes whatever was done by the old commit. This is the correct thing if your mistake has already been made public.</source>
          <target state="translated">이전 커밋이 수행 한 모든 작업을 취소하는 새 커밋을 만들 수 있습니다. 실수가 이미 공개 된 경우 이것이 올바른 것입니다.</target>
        </trans-unit>
        <trans-unit id="d8a9d4babf707e6fca47541eba4fa0b4e8c8edd2" translate="yes" xml:space="preserve">
          <source>You can customize the rules that &lt;code&gt;git diff --word-diff&lt;/code&gt; uses to split words in a line, by specifying an appropriate regular expression in the &quot;diff.*.wordRegex&quot; configuration variable. For example, in TeX a backslash followed by a sequence of letters forms a command, but several such commands can be run together without intervening whitespace. To separate them, use a regular expression in your &lt;code&gt;$GIT_DIR/config&lt;/code&gt; file (or &lt;code&gt;$HOME/.gitconfig&lt;/code&gt; file) like this:</source>
          <target state="translated">&quot;diff. *. wordRegex&quot;구성 변수에 적절한 정규식을 지정하여 &lt;code&gt;git diff --word-diff&lt;/code&gt; 가 단어를 한 줄로 나누는 데 사용 하는 규칙을 사용자 정의 할 수 있습니다 . 예를 들어, TeX에서 백 슬래시와 일련의 문자는 명령을 구성하지만 공백을 개입시키지 않고 여러 명령을 함께 실행할 수 있습니다. 이를 분리하려면 &lt;code&gt;$GIT_DIR/config&lt;/code&gt; 파일 (또는 &lt;code&gt;$HOME/.gitconfig&lt;/code&gt; 파일)에서 다음과 같이 정규식을 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="38bcfec4c9f80337cd439b12b7afb0a63bb0fcb7" translate="yes" xml:space="preserve">
          <source>You can declare that a filter turns a content that by itself is unusable into a usable content by setting the filter.&amp;lt;driver&amp;gt;.required configuration variable to &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">filter. &amp;lt;driver&amp;gt; .required 구성 변수를 &lt;code&gt;true&lt;/code&gt; 로 설정하여 필터가 자체적으로 사용할 수없는 컨텐츠를 사용 가능한 컨텐츠로 변환 함을 선언 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="d7aeeb9d27bdf323aad4937a225d2c2d1d7d6f4b" translate="yes" xml:space="preserve">
          <source>You can easily create such a branch with Git using interactive rebase.</source>
          <target state="translated">대화식 리베이스를 사용하여 Git으로 이러한 브랜치를 쉽게 만들 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2f7816df4cc860a9cfdb50146ff125e3acb46178" translate="yes" xml:space="preserve">
          <source>You can enforce finer grained permissions using update hooks. See &lt;a href=&quot;https://git-scm.com/docs/howto/update-hook-example&quot;&gt;Controlling access to branches using update hooks&lt;/a&gt;.</source>
          <target state="translated">업데이트 후크를 사용하여보다 세분화 된 권한을 적용 할 수 있습니다. &lt;a href=&quot;https://git-scm.com/docs/howto/update-hook-example&quot;&gt;업데이트 후크를 사용하여 분기에 대한 액세스 제어를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="dca6628a0b53b9b002cd44ea35104ed275c53c21" translate="yes" xml:space="preserve">
          <source>You can examine one of those dangling commits with, for example,</source>
          <target state="translated">예를 들어 다음과 같이 매달린 커밋 중 하나를 검사 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4807484ba96d5012055b128c8602211fd418a27a" translate="yes" xml:space="preserve">
          <source>You can examine such index state with &lt;code&gt;git ls-files --unmerged&lt;/code&gt; command. An example:</source>
          <target state="translated">&lt;code&gt;git ls-files --unmerged&lt;/code&gt; 명령을 사용 하여 이러한 인덱스 상태를 검사 할 수 있습니다 . 예를 들면 :</target>
        </trans-unit>
        <trans-unit id="b5f066a300ab7fb920ca504e5ef4559d46dabfb5" translate="yes" xml:space="preserve">
          <source>You can examine the data represented in the object database and the index with various helper tools. For every object, you can use &lt;a href=&quot;git-cat-file&quot;&gt;git-cat-file[1]&lt;/a&gt; to examine details about the object:</source>
          <target state="translated">다양한 도우미 도구를 사용하여 개체 데이터베이스와 인덱스에 표시된 데이터를 검사 할 수 있습니다. 모든 객체에 대해 &lt;a href=&quot;git-cat-file&quot;&gt;git-cat-file [1]&lt;/a&gt; 을 사용하여 객체에 대한 세부 정보를 검사 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="fd093df539bb25e8d4c6b75d7c53e29317d7deb5" translate="yes" xml:space="preserve">
          <source>You can explicitly provide a full path to the tool by setting the configuration variable &lt;code&gt;difftool.&amp;lt;tool&amp;gt;.path&lt;/code&gt;. For example, you can configure the absolute path to kdiff3 by setting &lt;code&gt;difftool.kdiff3.path&lt;/code&gt;. Otherwise, &lt;code&gt;git difftool&lt;/code&gt; assumes the tool is available in PATH.</source>
          <target state="translated">구성 변수 &lt;code&gt;difftool.&amp;lt;tool&amp;gt;.path&lt;/code&gt; 를 설정하여 도구의 전체 경로를 명시 적으로 제공 할 수 있습니다 . 예를 들어 &lt;code&gt;difftool.kdiff3.path&lt;/code&gt; 를 설정하여 kdiff3의 절대 경로를 구성 할 수 있습니다 . 그렇지 않으면 &lt;code&gt;git difftool&lt;/code&gt; 은 도구가 PATH에서 사용 가능하다고 가정합니다.</target>
        </trans-unit>
        <trans-unit id="146074b490cdd862abeb41d866c18f9aaa225cf8" translate="yes" xml:space="preserve">
          <source>You can explicitly provide a full path to the tool by setting the configuration variable &lt;code&gt;mergetool.&amp;lt;tool&amp;gt;.path&lt;/code&gt;. For example, you can configure the absolute path to kdiff3 by setting &lt;code&gt;mergetool.kdiff3.path&lt;/code&gt;. Otherwise, &lt;code&gt;git mergetool&lt;/code&gt; assumes the tool is available in PATH.</source>
          <target state="translated">구성 변수 &lt;code&gt;mergetool.&amp;lt;tool&amp;gt;.path&lt;/code&gt; 를 설정하여 도구의 전체 경로를 명시 적으로 제공 할 수 있습니다 . 예를 들어 &lt;code&gt;mergetool.kdiff3.path&lt;/code&gt; 를 설정하여 kdiff3의 절대 경로를 구성 할 수 있습니다 . 그렇지 않으면 &lt;code&gt;git mergetool&lt;/code&gt; 은 도구가 PATH에서 사용 가능하다고 가정합니다.</target>
        </trans-unit>
        <trans-unit id="1d73514fe413b4199a0b5fc2096f965b3e1620ee" translate="yes" xml:space="preserve">
          <source>You can explicitly provide a full path to your preferred man viewer by setting the configuration variable &lt;code&gt;man.&amp;lt;tool&amp;gt;.path&lt;/code&gt;. For example, you can configure the absolute path to konqueror by setting &lt;code&gt;man.konqueror.path&lt;/code&gt;. Otherwise, &lt;code&gt;git help&lt;/code&gt; assumes the tool is available in PATH.</source>
          <target state="translated">구성 변수 &lt;code&gt;man.&amp;lt;tool&amp;gt;.path&lt;/code&gt; 를 설정하여 원하는 man 뷰어에 대한 전체 경로를 명시 적으로 제공 할 수 있습니다 . 예를 들어, &lt;code&gt;man.konqueror.path&lt;/code&gt; 를 설정하여 konqueror의 절대 경로를 구성 할 수 있습니다 . 그렇지 않으면 &lt;code&gt;git help&lt;/code&gt; 는 도구를 PATH에서 사용할 수 있다고 가정합니다.</target>
        </trans-unit>
        <trans-unit id="11d166169fafafa437c100a2b764012cf5981ced" translate="yes" xml:space="preserve">
          <source>You can focus your efforts to check at a few points (for example rc and beta releases) that all the T test cases pass for all the N configurations. And when some tests don&amp;rsquo;t pass you can use &quot;git bisect&quot; (or better &quot;git bisect run&quot;). So you should perform roughly:</source>
          <target state="translated">모든 T 테스트 사례가 모든 N 구성에 대해 통과하는 몇 가지 지점 (예 : rc 및 베타 릴리스)에서 확인하려는 노력에 집중할 수 있습니다. 그리고 일부 테스트가 통과되지 않으면 &quot;git bisect&quot;(또는 더 나은 &quot;git bisect run&quot;)를 사용할 수 있습니다. 따라서 대략적으로 수행해야합니다.</target>
        </trans-unit>
        <trans-unit id="59d0d873078b4f91b40c2ee1e2770f185d430915" translate="yes" xml:space="preserve">
          <source>You can further cut down the number of trials, if you know what part of the tree is involved in the problem you are tracking down, by specifying path parameters when issuing the &lt;code&gt;bisect start&lt;/code&gt; command:</source>
          <target state="translated">&lt;code&gt;bisect start&lt;/code&gt; 명령을 실행할 때 경로 매개 변수를 지정하여 추적 할 문제에 관련된 트리 부분을 알고있는 경우 시행 횟수를 추가로 줄일 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="e5857d2949fb11d516cd50de71765499d023b3f6" translate="yes" xml:space="preserve">
          <source>You can generate diffs between any two versions using &lt;a href=&quot;git-diff&quot;&gt;git-diff[1]&lt;/a&gt;:</source>
          <target state="translated">&lt;a href=&quot;git-diff&quot;&gt;git-diff [1]을&lt;/a&gt; 사용하여 두 버전간에 차이를 생성 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="98e4a2c67e91124741c5ae666b50315da705ecdc" translate="yes" xml:space="preserve">
          <source>You can generate the projects list index file using the project_index action (the &lt;code&gt;TXT&lt;/code&gt; link on projects list page) directly from gitweb; see also &quot;Generating projects list using gitweb&quot; section below.</source>
          <target state="translated">gitweb에서 직접 project_index 조치 ( 프로젝트 목록 페이지 의 &lt;code&gt;TXT&lt;/code&gt; 링크)를 사용하여 프로젝트 목록 색인 파일을 생성 할 수 있습니다 . 아래의 &quot;gitweb을 사용하여 프로젝트 목록 생성&quot;섹션을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="5b042e446e3f9ebd4b31fc02aac55f5c329ead7e" translate="yes" xml:space="preserve">
          <source>You can get a list of all available encodings on your platform with the following command:</source>
          <target state="translated">다음 명령을 사용하여 플랫폼에서 사용 가능한 모든 인코딩 목록을 얻을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3d921181a0df868b1892f0a3e234a9c29e516883" translate="yes" xml:space="preserve">
          <source>You can get just the old (respectively new) term with &lt;code&gt;git bisect terms
--term-old&lt;/code&gt; or &lt;code&gt;git bisect terms --term-good&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;git bisect terms --term-old&lt;/code&gt; 또는 &lt;code&gt;git bisect terms --term-good&lt;/code&gt; 으로 오래된 (각각 새로운) 용어를 얻을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="41b9643f0720517e2c1772471e0c09d5c46b9644" translate="yes" xml:space="preserve">
          <source>You can give the &lt;code&gt;-m&lt;/code&gt; flag to the command, which would try a three-way merge:</source>
          <target state="translated">명령에 &lt;code&gt;-m&lt;/code&gt; 플래그를 부여하면 3 방향 병합을 시도 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="36617ae8104572554e1e13e9574934aea0623eb3" translate="yes" xml:space="preserve">
          <source>You can go back and modify the old commit. You should never do this if you have already made the history public; Git does not normally expect the &quot;history&quot; of a project to change, and cannot correctly perform repeated merges from a branch that has had its history changed.</source>
          <target state="translated">돌아가서 이전 커밋을 수정할 수 있습니다. 이미 역사를 공개 한 경우에는이 작업을 수행해서는 안됩니다. Git은 일반적으로 프로젝트의 &quot;히스토리&quot;가 변경 될 것으로 예상하지 않으며 히스토리가 변경된 지점에서 반복 병합을 올바르게 수행 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="427cec7db1c8d9c41ec669de64df63aacc49a26f" translate="yes" xml:space="preserve">
          <source>You can grow a new branch from any commit. For example, switch to &quot;HEAD~3&quot; and create branch &quot;fixup&quot;:</source>
          <target state="translated">모든 커밋에서 새 브랜치를 성장시킬 수 있습니다. 예를 들어 &quot;HEAD ~ 3&quot;으로 전환하고 &quot;fixup&quot;분기를 작성하십시오.</target>
        </trans-unit>
        <trans-unit id="8abddb96169bb94a7080d5c82ed5cac7b229954a" translate="yes" xml:space="preserve">
          <source>You can have a mixture of files show up as &quot;has been updated&quot; and &quot;is still dirty in the working directory&quot; together. You can always tell which file is in which state, since the &quot;has been updated&quot; ones show a valid sha1, and the &quot;not in sync with the index&quot; ones will always have the special all-zero sha1.</source>
          <target state="translated">파일이 &quot;업데이트되었습니다&quot;로 표시되고 &quot;작업 디렉토리에서 여전히 더럽습니다&quot;로 표시 될 수 있습니다. &quot;갱신 된&quot;파일에는 유효한 sha1이 표시되고 &quot;인덱스와 동기화되지 않은&quot;파일에는 항상 모든 0의 특수 sha1이 있으므로 어떤 파일이 어떤 상태인지 항상 알 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ae3f7bca446e950bd716349b25ee5d05aaee6a26" translate="yes" xml:space="preserve">
          <source>You can include a config file from another by setting the special &lt;code&gt;include.path&lt;/code&gt; (or &lt;code&gt;includeIf.*.path&lt;/code&gt;) variable to the name of the file to be included. The variable takes a pathname as its value, and is subject to tilde expansion. These variables can be given multiple times.</source>
          <target state="translated">특수 &lt;code&gt;include.path&lt;/code&gt; (또는 &lt;code&gt;includeIf.*.path&lt;/code&gt; ) 변수를 포함 할 파일 이름으로 설정하여 다른 구성 파일을 구성 파일에 포함시킬 수 있습니다. 변수는 경로 이름을 값으로 사용하며 물결표 확장이 적용됩니다. 이 변수들은 여러 번 주어질 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5145f6f36a43ec5e98537ca833d15e8282538fcf" translate="yes" xml:space="preserve">
          <source>You can include a config file from another conditionally by setting a &lt;code&gt;includeIf.&amp;lt;condition&amp;gt;.path&lt;/code&gt; variable to the name of the file to be included.</source>
          <target state="translated">&lt;code&gt;includeIf.&amp;lt;condition&amp;gt;.path&lt;/code&gt; 변수를 포함 할 파일 이름으로 설정하여 다른 조건부에서 구성 파일을 포함시킬 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="509dfc228243cbfccb732c55df31d8f926c42b85" translate="yes" xml:space="preserve">
          <source>You can include other configuration file using read_config_file() subroutine. For example, one might want to put gitweb configuration related to access control for viewing repositories via Gitolite (one of Git repository management tools) in a separate file, e.g. in &lt;code&gt;/etc/gitweb-gitolite.conf&lt;/code&gt;. To include it, put</source>
          <target state="translated">read_config_file () 서브 루틴을 사용하여 다른 구성 파일을 포함 할 수 있습니다. 예를 들어, Gitolite (Git 리포지토리 관리 도구 중 하나)를 통해 리포지토리를보기위한 액세스 제어와 관련된 gitweb 구성을 별도의 파일 (예 : &lt;code&gt;/etc/gitweb-gitolite.conf&lt;/code&gt; ) 에 넣을 수 있습니다. 포함하려면</target>
        </trans-unit>
        <trans-unit id="645452c6d997e8f480a9efb060142f580408b9f7" translate="yes" xml:space="preserve">
          <source>You can make a different change on the master branch:</source>
          <target state="translated">마스터 브랜치에서 다른 변경을 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9d56811ee77d2943d64ee7741c452578a4d84979" translate="yes" xml:space="preserve">
          <source>You can make interesting things happen to a repository every time you push into it, by setting up &lt;code&gt;hooks&lt;/code&gt; there. See documentation for &lt;a href=&quot;git-receive-pack&quot;&gt;git-receive-pack[1]&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;hooks&lt;/code&gt; 를 설정하여 저장소에 푸시 할 때마다 흥미로운 일을 저장소에 만들 수 있습니다 . &lt;a href=&quot;git-receive-pack&quot;&gt;git-receive-pack [1]&lt;/a&gt; 문서를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="31caee42f233cd83de2778af5287eb406c23a1ef" translate="yes" xml:space="preserve">
          <source>You can make sure &lt;code&gt;git show-branch&lt;/code&gt; matches the state before those two &lt;code&gt;git merge&lt;/code&gt; you just did. Then, instead of running two &lt;code&gt;git merge&lt;/code&gt; commands in a row, you would merge these two branch heads (this is known as &lt;code&gt;making an Octopus&lt;/code&gt;):</source>
          <target state="translated">&lt;code&gt;git show-branch&lt;/code&gt; 가 방금 한 두 &lt;code&gt;git merge&lt;/code&gt; 전에 상태와 일치 하는지 확인할 수 있습니다 . 그런 다음 두 개의 &lt;code&gt;git merge&lt;/code&gt; 명령을 연속 으로 실행하는 대신 이 두 가지 분기 헤드를 병합합니다 (이것은 &lt;code&gt;making an Octopus&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="9f748b043bbe97de82ec4f7b6a5308c58b703d36" translate="yes" xml:space="preserve">
          <source>You can make the server use the end-of-line conversion attributes to set the &lt;code&gt;-k&lt;/code&gt; modes for files by setting the &lt;code&gt;gitcvs.usecrlfattr&lt;/code&gt; config variable. See &lt;a href=&quot;gitattributes&quot;&gt;gitattributes[5]&lt;/a&gt; for more information about end-of-line conversion.</source>
          <target state="translated">&lt;code&gt;gitcvs.usecrlfattr&lt;/code&gt; 구성 변수를 설정하여 서버가 행 끝 변환 속성을 사용하여 파일에 대한 &lt;code&gt;-k&lt;/code&gt; 모드 를 설정할 수 있습니다. 참조 &lt;a href=&quot;gitattributes&quot;&gt;gitattributes을 [5]&lt;/a&gt; 끝 (end-of-line) 변환에 대한 자세한 정보를 얻을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="015443f769a79760c1933372fa244563a6a25aba" translate="yes" xml:space="preserve">
          <source>You can omit having to type return here, by setting the configuration variable &lt;code&gt;interactive.singleKey&lt;/code&gt; to &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">구성 변수 &lt;code&gt;interactive.singleKey&lt;/code&gt; 를 &lt;code&gt;true&lt;/code&gt; 로 설정하여 여기에 return을 입력하지 않아도됩니다 .</target>
        </trans-unit>
        <trans-unit id="358c29af25eb707e9507c2c41ba2c41fddac22f4" translate="yes" xml:space="preserve">
          <source>You can override these rules either by command-line options or by environment variables. The &lt;code&gt;--global&lt;/code&gt;, &lt;code&gt;--system&lt;/code&gt; and &lt;code&gt;--worktree&lt;/code&gt; options will limit the file used to the global, system-wide or per-worktree file respectively. The &lt;code&gt;GIT_CONFIG&lt;/code&gt; environment variable has a similar effect, but you can specify any filename you want.</source>
          <target state="translated">명령 행 옵션 또는 환경 변수로 이러한 규칙을 대체 할 수 있습니다. &lt;code&gt;--global&lt;/code&gt; 는 , &lt;code&gt;--system&lt;/code&gt; 및 &lt;code&gt;--worktree&lt;/code&gt; 옵션은 글로벌, 전체 시스템 또는 당 worktree 파일을 각각 사용되는 파일을 제한합니다. &lt;code&gt;GIT_CONFIG&lt;/code&gt; 의 환경 변수도 비슷한 효과를 가지고 있지만, 당신은 당신이 원하는 파일 이름을 지정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b9256a8bfff0f4e1e2098927e9ff118ae66b3eab" translate="yes" xml:space="preserve">
          <source>You can perform &quot;git pull&quot;, resolve potential conflicts, and &quot;git push&quot; the result. A &quot;git pull&quot; will create a merge commit C between commits A and B.</source>
          <target state="translated">&quot;git pull&quot;을 수행하고 잠재적 충돌을 해결하고 결과를 &quot;git push&quot;할 수 있습니다. &quot;git pull&quot;은 커밋 A와 B 사이에 병합 커밋 C를 생성합니다.</target>
        </trans-unit>
        <trans-unit id="189a9ed33e189223869b33620d09d0f720bf3fe1" translate="yes" xml:space="preserve">
          <source>You can provide options via the credential.helper configuration variable (this example drops the cache time to 5 minutes):</source>
          <target state="translated">credential.helper 구성 변수를 통해 옵션을 제공 할 수 있습니다 (이 예에서는 캐시 시간을 5 분으로 줄입니다).</target>
        </trans-unit>
        <trans-unit id="82656460f1d1171626ca7a2547e75d0458741fd5" translate="yes" xml:space="preserve">
          <source>You can query/set/replace/unset options with this command. The name is actually the section and the key separated by a dot, and the value will be escaped.</source>
          <target state="translated">이 명령으로 옵션을 쿼리 / 설정 / 바꾸기 / 설정 해제 할 수 있습니다. 실제로 이름은 점으로 구분 된 섹션과 키이며 값은 이스케이프됩니다.</target>
        </trans-unit>
        <trans-unit id="10e463ee2669848fa9bb9fc90b4474d38bbf73be" translate="yes" xml:space="preserve">
          <source>You can rejoin two diverging branches of development using &lt;a href=&quot;git-merge&quot;&gt;git-merge[1]&lt;/a&gt;:</source>
          <target state="translated">&lt;a href=&quot;git-merge&quot;&gt;git-merge [1]을&lt;/a&gt; 사용하여 두 가지 분기되는 개발 분기에 다시 참여할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="3e4277417393477fbeb632e41395d74e0a0e4169" translate="yes" xml:space="preserve">
          <source>You can repack this private repository whenever you feel like.</source>
          <target state="translated">필요할 때마다이 개인 저장소를 다시 포장 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3425cb44f3c2a0393cb24a6806cf1648e47fe578" translate="yes" xml:space="preserve">
          <source>You can repeat steps 2-4 multiple times to break the original code into any number of commits.</source>
          <target state="translated">2-4 단계를 여러 번 반복하여 원래 코드를 여러 커밋으로 나눌 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f016259f2ce9ae7193e573b7fa2135698ca39f54" translate="yes" xml:space="preserve">
          <source>You can rewrite the commit log messages using &lt;code&gt;--msg-filter&lt;/code&gt;. For example, &lt;code&gt;git svn-id&lt;/code&gt; strings in a repository created by &lt;code&gt;git svn&lt;/code&gt; can be removed this way:</source>
          <target state="translated">&lt;code&gt;--msg-filter&lt;/code&gt; 를 사용하여 커밋 로그 메시지를 다시 작성할 수 있습니다 . 예를 들어, &lt;code&gt;git svn-id&lt;/code&gt; 의해 생성 된 스트링 저장소 &lt;code&gt;git svn&lt;/code&gt; 이 방법으로 제거 될 수있다 :</target>
        </trans-unit>
        <trans-unit id="6928e91b0b4a87a6f0188b338ec935fa803e932d" translate="yes" xml:space="preserve">
          <source>You can run &lt;code&gt;git-bundle verify&lt;/code&gt; to see if you can extract from a bundle that was created with a basis:</source>
          <target state="translated">&lt;code&gt;git-bundle verify&lt;/code&gt; 를 실행 하여 기본으로 작성된 번들에서 추출 할 수 있는지 확인할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="28f57e6715a38d45260ef8d226913fe9d5e46420" translate="yes" xml:space="preserve">
          <source>You can run &lt;code&gt;gitk --all&lt;/code&gt; again to see how the commit ancestry looks like, or run &lt;code&gt;show-branch&lt;/code&gt;, which tells you this.</source>
          <target state="translated">&lt;code&gt;gitk --all&lt;/code&gt; 을 다시 실행 하여 커밋 조상이 어떻게 보이는지 보거나 &lt;code&gt;show-branch&lt;/code&gt; 를 실행하여 이를 알 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ee22a2dcf21325c45ae74e5933824496ebc88dee" translate="yes" xml:space="preserve">
          <source>You can save space and make Git faster by moving these loose objects in to a &quot;pack file&quot;, which stores a group of objects in an efficient compressed format; the details of how pack files are formatted can be found in &lt;a href=&quot;pack-format&quot;&gt;pack format&lt;/a&gt;.</source>
          <target state="translated">이 느슨한 객체를 효율적인 압축 형식으로 객체 그룹을 저장하는 &quot;팩 파일&quot;로 이동하여 공간을 절약하고 Git을 더 빠르게 만들 수 있습니다. 팩 파일의 형식 지정 방법에 대한 자세한 내용은 &lt;a href=&quot;pack-format&quot;&gt;팩 형식을 참조하십시오&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="923ef556c5ea1d367a9ceb952e817561488d6f46" translate="yes" xml:space="preserve">
          <source>You can see easily that the above is a rename.</source>
          <target state="translated">위의 이름이 바뀌 었음을 쉽게 알 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5724c58e846fc905ad55d8bc9c332033225407c5" translate="yes" xml:space="preserve">
          <source>You can set this to &lt;code&gt;link&lt;/code&gt;, in which case a hardlink followed by a delete of the source are used to make sure that object creation will not overwrite existing objects.</source>
          <target state="translated">이것을 &lt;code&gt;link&lt;/code&gt; 로 설정할 수 있습니다.이 경우 소스를 삭제 한 후 하드 링크를 사용하여 객체 생성시 기존 객체를 덮어 쓰지 않도록합니다.</target>
        </trans-unit>
        <trans-unit id="02df8661fe031a54ab42701feedaa37cd7c87875" translate="yes" xml:space="preserve">
          <source>You can setup one single value (single entry/item in this list) at build time by setting the &lt;code&gt;GITWEB_BASE_URL&lt;/code&gt; build-time configuration variable. By default it is set to (), i.e. an empty list. This means that gitweb would not try to create project URL (to fetch) from project name.</source>
          <target state="translated">&lt;code&gt;GITWEB_BASE_URL&lt;/code&gt; 빌드 시간 구성 변수 를 설정하여 빌드시 하나의 단일 값 (이 목록의 단일 항목 / 항목)을 설정할 수 있습니다. 기본적으로 (), 즉 빈 목록으로 설정됩니다. 이것은 gitweb이 프로젝트 이름에서 프로젝트 URL을 가져 오려고 시도하지 않음을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="af5fba33ca90f8278cecf2701efca5c8b71085ca" translate="yes" xml:space="preserve">
          <source>You can specify a list of allowed directories. If no directories are given, all are allowed. This is an additional restriction, gitcvs access still needs to be enabled by the &lt;code&gt;gitcvs.enabled&lt;/code&gt; config option unless &lt;code&gt;--export-all&lt;/code&gt; was given, too.</source>
          <target state="translated">허용 된 디렉토리 목록을 지정할 수 있습니다. 디렉토리가 제공되지 않으면 모두 허용됩니다. 이것은 추가적인 제한 사항입니다. &lt;code&gt;--export-all&lt;/code&gt; 을 지정 하지 않은 경우 gitcvs 액세스를 &lt;code&gt;gitcvs.enabled&lt;/code&gt; 구성 옵션 으로 활성화해야합니다 .</target>
        </trans-unit>
        <trans-unit id="a2f1a86c57fcd513fcca4d9c2bf5f81069f36bf3" translate="yes" xml:space="preserve">
          <source>You can specify extra mail header lines to be added to each message, defaults for the subject prefix and file suffix, number patches when outputting more than one patch, add &quot;To:&quot; or &quot;Cc:&quot; headers, configure attachments, change the patch output directory, and sign off patches with configuration variables.</source>
          <target state="translated">각 메일에 추가 할 추가 메일 헤더 행, 제목 접두사 및 파일 접미사에 대한 기본값, 둘 이상의 패치를 출력 할 때의 패치 수, &quot;To :&quot;또는 &quot;Cc :&quot;헤더 추가, 첨부 파일 구성, 패치 변경 출력 디렉토리 및 구성 변수로 패치를 사인 오프하십시오.</target>
        </trans-unit>
        <trans-unit id="c33dd2cd2261f81cbd0fc492df4e16b1e747c25d" translate="yes" xml:space="preserve">
          <source>You can specify the information shown for each object by using a custom &lt;code&gt;&amp;lt;format&amp;gt;&lt;/code&gt;. The &lt;code&gt;&amp;lt;format&amp;gt;&lt;/code&gt; is copied literally to stdout for each object, with placeholders of the form &lt;code&gt;%(atom)&lt;/code&gt; expanded, followed by a newline. The available atoms are:</source>
          <target state="translated">사용자 정의 &lt;code&gt;&amp;lt;format&amp;gt;&lt;/code&gt; 을 사용하여 각 오브젝트에 대해 표시되는 정보를 지정할 수 있습니다 . &lt;code&gt;&amp;lt;format&amp;gt;&lt;/code&gt; 폼의 자리에, 각 개체에 대한 표준 출력에 그대로 복사된다 &lt;code&gt;%(atom)&lt;/code&gt; 개행 뒤에 확장. 사용 가능한 원자는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="5a94d83b2aa4f52ca10b82e1786cdc28d9f55e56" translate="yes" xml:space="preserve">
          <source>You can tell Git to ignore certain files by creating a file called &lt;code&gt;.gitignore&lt;/code&gt; in the top level of your working directory, with contents such as:</source>
          <target state="translated">작업 디렉토리의 최상위 레벨에 다음과 같은 내용으로 &lt;code&gt;.gitignore&lt;/code&gt; 라는 파일을 작성하여 Git에게 특정 파일을 무시하도록 지시 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="491f06c247008ffc2db5fcd9f930c35d5e25a466" translate="yes" xml:space="preserve">
          <source>You can tell Git to split the Git internal information from the directory that it tracks, but we&amp;rsquo;ll ignore that for now: it&amp;rsquo;s not how normal projects work, and it&amp;rsquo;s really only meant for special uses. So the mental model of &quot;the Git information is always tied directly to the working tree that it describes&quot; may not be technically 100% accurate, but it&amp;rsquo;s a good model for all normal use.</source>
          <target state="translated">Git에게 추적하는 디렉토리에서 Git 내부 정보를 분리하도록 지시 할 수 있지만 현재로서는 무시할 것입니다. 일반적인 프로젝트의 작동 방식이 아니며 실제로는 특수 용도로만 사용됩니다. 따라서 &quot;Git 정보는 항상 작업 트리에 직접 연결되어 있습니다&quot;라는 정신 모델이 기술적으로 100 % 정확하지는 않지만 모든 정상적인 사용에 적합한 모델입니다.</target>
        </trans-unit>
        <trans-unit id="eba2ddb51d288f0b3a9988b4f1ccbdcde132a1f4" translate="yes" xml:space="preserve">
          <source>You can test whether the filesystem supports that with the &lt;code&gt;--test-untracked-cache&lt;/code&gt; option. The &lt;code&gt;--untracked-cache&lt;/code&gt; option used to implicitly perform that test in older versions of Git, but that&amp;rsquo;s no longer the case.</source>
          <target state="translated">&lt;code&gt;--test-untracked-cache&lt;/code&gt; 옵션 을 사용하여 파일 시스템이이를 지원하는지 테스트 할 수 있습니다 . &lt;code&gt;--untracked-cache&lt;/code&gt; 암시 적으로 사용되는 옵션은 망할 놈의 이전 버전에서이 테스트를 수행하지 않습니다, 그러나 그것은 더 이상 사건.</target>
        </trans-unit>
        <trans-unit id="33337304817f97abbb584fa2c7541a14abb9bfcd" translate="yes" xml:space="preserve">
          <source>You can then fix the conflicts during the rebase. Presumably you have not published your topic other than by mail, so rebasing it is not a problem.</source>
          <target state="translated">그런 다음 리베이스 중에 충돌을 해결할 수 있습니다. 아마 당신은 우편이 아닌 다른 주제를 출판하지 않았기 때문에 문제를 해결하는 것은 문제가되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="d6b74e3d43432e56c49f83bf0e8c1bc1b7ac50b8" translate="yes" xml:space="preserve">
          <source>You can then import these into your mail client and send them by hand. However, if you have a lot to send at once, you may prefer to use the &lt;a href=&quot;git-send-email&quot;&gt;git-send-email[1]&lt;/a&gt; script to automate the process. Consult the mailing list for your project first to determine their requirements for submitting patches.</source>
          <target state="translated">그런 다음 메일 클라이언트로 가져 와서 직접 보낼 수 있습니다. 그러나 한 번에 보낼 것이 많으면 &lt;a href=&quot;git-send-email&quot;&gt;git-send-email [1]&lt;/a&gt; 스크립트를 사용하여 프로세스를 자동화하는 것이 좋습니다. 패치 제출 요구 사항을 판별하려면 먼저 프로젝트의 메일 링리스트를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="ad2194dc994cc556c2451e6a9d4c256f90b5afd4" translate="yes" xml:space="preserve">
          <source>You can then transplant the old &lt;code&gt;subsystem..topic&lt;/code&gt; to the new tip by saying (for the reflog case, and assuming you are on &lt;code&gt;topic&lt;/code&gt; already):</source>
          <target state="translated">그런 다음 (reflog 사례의 경우 이미 &lt;code&gt;topic&lt;/code&gt; 에 있다고 가정) 이전 &lt;code&gt;subsystem..topic&lt;/code&gt; ..topic을 새 팁에 이식 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="b5bb69809c9820257d5f27c5ec379a4130c453d8" translate="yes" xml:space="preserve">
          <source>You can think of this as a set operation. Commits given on the command line form a set of commits that are reachable from any of them, and then commits reachable from any of the ones given with &lt;code&gt;^&lt;/code&gt; in front are subtracted from that set. The remaining commits are what comes out in the command&amp;rsquo;s output. Various other options and paths parameters can be used to further limit the result.</source>
          <target state="translated">이것을 설정된 작업으로 생각할 수 있습니다. 커맨드 라인에 주어진 커밋은 커밋 세트 중 하나에서 도달 할 수 있으며, 앞에 &lt;code&gt;^&lt;/code&gt; 로 주어진 커밋에서 커밋 할 수있는 커밋 은 해당 세트에서 뺍니다. 나머지 커밋은 명령의 출력에서 ​​나오는 것입니다. 다양한 다른 옵션 및 경로 매개 변수를 사용하여 결과를 추가로 제한 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="eacfd2b96f144de251fd3721b44d6ad9ca988b86" translate="yes" xml:space="preserve">
          <source>You can try running &lt;code&gt;find .git/objects -type f&lt;/code&gt; before and after you run &lt;code&gt;git prune-packed&lt;/code&gt; if you are curious. Also &lt;code&gt;git
count-objects&lt;/code&gt; would tell you how many unpacked objects are in your repository and how much space they are consuming.</source>
          <target state="translated">궁금하다면 &lt;code&gt;git prune-packed&lt;/code&gt; 를 실행하기 전후에 &lt;code&gt;find .git/objects -type f&lt;/code&gt; 를 실행 해보 십시오 . 또한 &lt;code&gt;git count-objects&lt;/code&gt; 는 리포지토리에 압축 해제 된 오브젝트의 수와 사용중인 공간의 양을 알려줍니다.</target>
        </trans-unit>
        <trans-unit id="78c0fba98badb6e25ce1949ee53cb8839b8be51a" translate="yes" xml:space="preserve">
          <source>You can update the shared repository with your changes by first committing your changes, and then using the &lt;code&gt;git push&lt;/code&gt; command:</source>
          <target state="translated">먼저 변경 사항을 커밋 한 다음 &lt;code&gt;git push&lt;/code&gt; 명령 을 사용하여 변경 사항으로 공유 리포지토리를 업데이트 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="fe24364fca4da5268b93a1c7c864762589bec5d4" translate="yes" xml:space="preserve">
          <source>You can use &lt;a href=&quot;git-show&quot;&gt;git-show[1]&lt;/a&gt; to examine the contents of a blob; take, for example, the blob in the entry for &lt;code&gt;COPYING&lt;/code&gt; from the tree above:</source>
          <target state="translated">&lt;a href=&quot;git-show&quot;&gt;git-show [1]&lt;/a&gt; 을 사용하여 blob의 내용을 검사 할 수 있습니다 . 예를 들어 위의 트리에서 &lt;code&gt;COPYING&lt;/code&gt; 항목의 얼룩을 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="cdee252fbf6b663369bb36f7a81711483c778043" translate="yes" xml:space="preserve">
          <source>You can use &lt;code&gt;git stash push --keep-index&lt;/code&gt; when you want to make two or more commits out of the changes in the work tree, and you want to test each change before committing:</source>
          <target state="translated">당신이 사용할 수있는 &lt;code&gt;git stash push --keep-index&lt;/code&gt; 사용하면 작업 트리의 변화에서 두 개 이상의 커밋을 할 때, 당신은 커밋하기 전에 각 변경 사항을 테스트하려면 :</target>
        </trans-unit>
        <trans-unit id="b954fc6ff3f193031cbeca4547760f3425491805" translate="yes" xml:space="preserve">
          <source>You can use &lt;code&gt;git stash&lt;/code&gt; to simplify the above, like this:</source>
          <target state="translated">당신이 사용할 수있는 &lt;code&gt;git stash&lt;/code&gt; 과 같이 위를 단순화 :</target>
        </trans-unit>
        <trans-unit id="c482710749f3dcad6cbdc9701b2eb8b0d7f62e6a" translate="yes" xml:space="preserve">
          <source>You can use &lt;code&gt;stable-1&lt;/code&gt; to refer to the commit 1b2e1d63ff.</source>
          <target state="translated">steady &lt;code&gt;stable-1&lt;/code&gt; 을 사용하여 커밋 1b2e1d63ff를 참조 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="783e49ef6897108ce62c504df5bb1071160ba897" translate="yes" xml:space="preserve">
          <source>You can use a basis based on time:</source>
          <target state="translated">시간을 기준으로 기준을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0dcaab83279bcfe9c2e3dbaa6b4f0d035029ab31" translate="yes" xml:space="preserve">
          <source>You can use a tag that is present in both:</source>
          <target state="translated">두 가지 모두에있는 태그를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0967772702daca79ec55cd9be52c70fe75848751" translate="yes" xml:space="preserve">
          <source>You can use different &lt;code&gt;&amp;lt;action&amp;gt;&lt;/code&gt; values to control this behavior:</source>
          <target state="translated">다른 &lt;code&gt;&amp;lt;action&amp;gt;&lt;/code&gt; 값을 사용하여이 동작을 제어 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="72733e82f897a2af21fcfc3df3447e66ece75165" translate="yes" xml:space="preserve">
          <source>You can use it as a human-readable bundle replacement (see &lt;a href=&quot;git-bundle&quot;&gt;git-bundle[1]&lt;/a&gt;), or as a format that can be edited before being fed to &lt;code&gt;git fast-import&lt;/code&gt; in order to do history rewrites (an ability relied on by tools like &lt;code&gt;git filter-repo&lt;/code&gt;).</source>
          <target state="translated">사람이 읽을 수있는 번들 대체 ( &lt;a href=&quot;git-bundle&quot;&gt;git-bundle [1]&lt;/a&gt; 참조) 또는 히스토리 다시 쓰기 (도구에 의존하는 기능)를 위해 &lt;code&gt;git fast-import&lt;/code&gt; 로 공급되기 전에 편집 할 수있는 형식으로 사용할 수 있습니다. &lt;code&gt;git filter-repo&lt;/code&gt; 와 같은 ).</target>
        </trans-unit>
        <trans-unit id="6b34e82e0ff80209e7866272f371ddd1420b0f13" translate="yes" xml:space="preserve">
          <source>You can use mod_perl with gitweb. You must install Apache::Registry (for mod_perl 1.x) or ModPerl::Registry (for mod_perl 2.x) to enable this support.</source>
          <target state="translated">gitweb과 함께 mod_perl을 사용할 수 있습니다. 이 지원을 사용하려면 Apache :: Registry (mod_perl 1.x) 또는 ModPerl :: Registry (mod_perl 2.x)를 설치해야합니다.</target>
        </trans-unit>
        <trans-unit id="625924bfa2e6c050ea9730ca7a0edb6cfce2bfdc" translate="yes" xml:space="preserve">
          <source>You can use notes to add annotations with information that was not available at the time a commit was written.</source>
          <target state="translated">메모를 사용하여 커밋이 작성 될 때 사용할 수 없었던 정보가 포함 된 주석을 추가 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0bbbcd5b5890880e82d452d584e7cf77013dabac" translate="yes" xml:space="preserve">
          <source>You can use the &lt;code&gt;@&lt;/code&gt; construct with an empty ref part to get at a reflog entry of the current branch. For example, if you are on branch &lt;code&gt;blabla&lt;/code&gt; then &lt;code&gt;@{1}&lt;/code&gt; means the same as &lt;code&gt;blabla@{1}&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;@&lt;/code&gt; 참조를 빈 참조 부분과 함께 사용 하면 현재 분기의 참조 로그 항목을 얻을 수 있습니다. 당신이 지점에있는 경우 예를 들어, &lt;code&gt;blabla&lt;/code&gt; 다음 &lt;code&gt;@{1}&lt;/code&gt; 과 같은 의미 &lt;code&gt;blabla@{1}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="bd3a4b2dd2cada66b7023aa9fae3c933422c9fcc" translate="yes" xml:space="preserve">
          <source>You can use the &lt;code&gt;@{-N}&lt;/code&gt; syntax to refer to the N-th last branch/commit checked out using &quot;git checkout&quot; operation. You may also specify &lt;code&gt;-&lt;/code&gt; which is synonymous to &lt;code&gt;@{-1}&lt;/code&gt;.</source>
          <target state="translated">당신은 사용할 수 있습니다 &lt;code&gt;@{-N}&lt;/code&gt; N 번째 마지막 지점을 참조하는 구문을 / &quot;자식 체크 아웃&quot;작업을 사용하여 체크 아웃 커밋. 당신은 또한 지정할 수 있습니다 &lt;code&gt;-&lt;/code&gt; 동의어이다 &lt;code&gt;@{-1}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e21f11f93a4b8bdb963de3cd700b58b5db33242a" translate="yes" xml:space="preserve">
          <source>You can use the &lt;code&gt;@{-N}&lt;/code&gt; syntax to refer to the N-th last branch/commit switched to using &quot;git switch&quot; or &quot;git checkout&quot; operation. You may also specify &lt;code&gt;-&lt;/code&gt; which is synonymous to &lt;code&gt;@{-1}&lt;/code&gt;. This is often used to switch quickly between two branches, or to undo a branch switch by mistake.</source>
          <target state="translated">당신은 사용할 수 있습니다 &lt;code&gt;@{-N}&lt;/code&gt; N 번째 마지막 지점을 참조하는 구문을 / &quot;자식 스위치&quot;또는 &quot;자식 체크 아웃&quot;작업을 사용하여 전환 커밋. 당신은 또한 지정할 수 있습니다 &lt;code&gt;-&lt;/code&gt; 동의어이다 &lt;code&gt;@{-1}&lt;/code&gt; . 이것은 종종 두 분기 사이를 빠르게 전환하거나 실수로 분기 스위치를 실행 취소하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="736fc09a09a7b16017fd49ac75e258e953294134" translate="yes" xml:space="preserve">
          <source>You can use the &lt;code&gt;gitweb.owner&lt;/code&gt; repository configuration variable to set repository&amp;rsquo;s owner. It is displayed in the project list and summary page.</source>
          <target state="translated">&lt;code&gt;gitweb.owner&lt;/code&gt; 저장소 구성 변수를 사용하여 저장소의 소유자를 설정할 수 있습니다 . 프로젝트 목록 및 요약 페이지에 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="b3762dc0cf78ebbd7cf935ac045ade59a2e3acbf" translate="yes" xml:space="preserve">
          <source>You can use the &lt;code&gt;htpasswd&lt;/code&gt; facility that comes with Apache to make these files, but Apache&amp;rsquo;s MD5 crypt method differs from the one used by most C library&amp;rsquo;s crypt() function, so don&amp;rsquo;t use the -m option.</source>
          <target state="translated">Apache와 함께 제공 되는 &lt;code&gt;htpasswd&lt;/code&gt; 기능을 사용하여 이러한 파일을 만들 수 있지만 Apache의 MD5 암호화 방법은 대부분의 C 라이브러리의 crypt () 함수에서 사용하는 방법과 다르므로 -m 옵션을 사용하지 마십시오.</target>
        </trans-unit>
        <trans-unit id="80aa1363be3995d4ec384e59561a0e7a0903c070" translate="yes" xml:space="preserve">
          <source>You can use the &lt;code&gt;map&lt;/code&gt; convenience function in this filter, and other convenience functions, too. For example, calling &lt;code&gt;skip_commit &quot;$@&quot;&lt;/code&gt; will leave out the current commit (but not its changes! If you want that, use &lt;code&gt;git rebase&lt;/code&gt; instead).</source>
          <target state="translated">당신이 사용할 수있는 &lt;code&gt;map&lt;/code&gt; 도이 필터 및 기타 편의 기능에 편리한 기능입니다. 예를 들어, &lt;code&gt;skip_commit &quot;$@&quot;&lt;/code&gt; 호출 하면 현재 커밋이 생략됩니다 (그러나 변경 사항은 아닙니다! 원하는 경우 대신 &lt;code&gt;git rebase&lt;/code&gt; 를 사용하십시오).</target>
        </trans-unit>
        <trans-unit id="c32abff787b36e9c877031d224291d8c643f61f1" translate="yes" xml:space="preserve">
          <source>You can use the following files in repository:</source>
          <target state="translated">저장소에서 다음 파일을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b6c6eac74692734c5ec1dc3c689d37b0eb0dcea6" translate="yes" xml:space="preserve">
          <source>You can use the number of commits:</source>
          <target state="translated">커밋 수를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4a928f707b340dd3df65a93fa7f9942c5a65d9b2" translate="yes" xml:space="preserve">
          <source>You can very easily automatically bisect broken builds using something like:</source>
          <target state="translated">다음과 같은 방법으로 깨진 빌드를 매우 쉽게 자동으로 이등분 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="77487b0c89edd8fd842e99d65a1b39d2c6b378f5" translate="yes" xml:space="preserve">
          <source>You can work through the conflict with a number of tools:</source>
          <target state="translated">여러 도구와의 충돌을 통해 작업 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="918d78d55a9c451b1a86101242b3194591c9e6cc" translate="yes" xml:space="preserve">
          <source>You can write the mandatory option parameter to an option as a separate word on the command line. That means that all the following uses work:</source>
          <target state="translated">명령 행에서 별도의 단어로 옵션에 필수 옵션 매개 변수를 쓸 수 있습니다. 이는 다음의 모든 용도가 작동 함을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="d7f91f3a076bca347349424f4008dca0a1518c15" translate="yes" xml:space="preserve">
          <source>You can write your own custom helpers to interface with any system in which you keep credentials. See credential.h for details.</source>
          <target state="translated">신임 정보를 유지하는 모든 시스템과 인터페이스하기 위해 사용자 정의 헬퍼를 작성할 수 있습니다. 자세한 내용은 credential.h를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="c06b90a2f16de670e5df5d7464445ae0f28559f2" translate="yes" xml:space="preserve">
          <source>You could be using the &lt;code&gt;objects/info/alternates&lt;/code&gt; or &lt;code&gt;$GIT_ALTERNATE_OBJECT_DIRECTORIES&lt;/code&gt; mechanisms to &lt;code&gt;borrow&lt;/code&gt; objects from other object stores. A repository with this kind of incomplete object store is not suitable to be published for use with dumb transports but otherwise is OK as long as &lt;code&gt;objects/info/alternates&lt;/code&gt; points at the object stores it borrows from.</source>
          <target state="translated">당신은 사용이 될 수 &lt;code&gt;objects/info/alternates&lt;/code&gt; 또는 &lt;code&gt;$GIT_ALTERNATE_OBJECT_DIRECTORIES&lt;/code&gt; 할 수있는 메커니즘을 &lt;code&gt;borrow&lt;/code&gt; 다른 물체 매장에서 오브젝트를. 이러한 종류의 불완전한 오브젝트 저장소가있는 저장소는 바보 전송과 함께 사용하기에 공개되지 않지만 , 오브젝트 저장소에서 &lt;code&gt;objects/info/alternates&lt;/code&gt; 포인트가 빌려 오는 한 괜찮 습니다.</target>
        </trans-unit>
        <trans-unit id="e2e5ecc00e320fd7f95c1d7def9e5cd07e7e5d74" translate="yes" xml:space="preserve">
          <source>You could do without using any branches at all, by keeping as many local repositories as you would like to have branches, and merging between them with &lt;em&gt;git pull&lt;/em&gt;, just like you merge between branches. The advantage of this approach is that it lets you keep a set of files for each &lt;code&gt;branch&lt;/code&gt; checked out and you may find it easier to switch back and forth if you juggle multiple lines of development simultaneously. Of course, you will pay the price of more disk usage to hold multiple working trees, but disk space is cheap these days.</source>
          <target state="translated">브랜치를 가지고있는 것처럼 많은 로컬 리포지토리를 유지하고 브랜치간에 병합하는 것처럼 &lt;em&gt;git pull으로&lt;/em&gt; 병합하여 브랜치를 전혀 사용하지 않아도됩니다 . 이 접근 방식의 장점은 각 &lt;code&gt;branch&lt;/code&gt; 에 대해 파일 세트를 체크 아웃 할 수 있으며 여러 개발 라인을 동시에 저글링하는 경우 더 쉽게 전환 할 수 있다는 것입니다. 물론 여러 작업 트리를 보유하기 위해 더 많은 디스크 사용량을 지불해야하지만 요즘에는 디스크 공간이 저렴합니다.</target>
        </trans-unit>
        <trans-unit id="8ff03510fc9dfa2f41199478909f4845fc0f0bb6" translate="yes" xml:space="preserve">
          <source>You could have an incomplete but locally usable repository by creating a shallow clone. See &lt;a href=&quot;git-clone&quot;&gt;git-clone[1]&lt;/a&gt;.</source>
          <target state="translated">얕은 클론을 생성하여 불완전하지만 로컬에서 사용할 수있는 저장소를 가질 수 있습니다. &lt;a href=&quot;git-clone&quot;&gt;git-clone [1]을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="f736fa76fc678c4f130db13f45faf6b48f41687a" translate="yes" xml:space="preserve">
          <source>You could just visually inspect the commits since e05db0fd:</source>
          <target state="translated">e05db0fd 이후 커밋을 시각적으로 검사 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0d78b2a8d8354041e789d882f2348db69275bdcd" translate="yes" xml:space="preserve">
          <source>You could omit &lt;code&gt;&amp;lt;branch&amp;gt;&lt;/code&gt;, in which case the command degenerates to &quot;check out the current branch&quot;, which is a glorified no-op with rather expensive side-effects to show only the tracking information, if exists, for the current branch.</source>
          <target state="translated">&lt;code&gt;&amp;lt;branch&amp;gt;&lt;/code&gt; 를 생략 할 수 있습니다 .이 경우 명령이 &quot;현재 분기를 체크 아웃&quot;하도록 퇴화됩니다.이 분기는 현재 분기에 대한 추적 정보 만있는 경우 비용이 많이 드는 부작용이없는 영광스러운 no-op입니다.</target>
        </trans-unit>
        <trans-unit id="7c5b22847ee058ce78c26cbc63e773fbbc9499cd" translate="yes" xml:space="preserve">
          <source>You create a commit object by giving it the tree that describes the state at the time of the commit, and a list of parents:</source>
          <target state="translated">커밋 객체는 커밋 시점의 상태를 설명하는 트리와 부모 목록을 제공하여 만듭니다.</target>
        </trans-unit>
        <trans-unit id="0fca09140e6ecd8df23b487785db8ea6f6692c80" translate="yes" xml:space="preserve">
          <source>You do not want any end-of-line conversions applied to, nor textual diffs produced for, any binary file you track. You would need to specify e.g.</source>
          <target state="translated">추적하는 이진 파일에 줄 끝 변환을 적용하거나 텍스트 차이를 만들지 않습니다. 당신은 예를 들어 지정해야합니다</target>
        </trans-unit>
        <trans-unit id="3b6ec2c54535f15330b4b3b431cf4481da43a55b" translate="yes" xml:space="preserve">
          <source>You do random edits, without running &lt;code&gt;git update-index&lt;/code&gt;. And then you notice that the tip of your &quot;upstream&quot; tree has advanced since you pulled from him:</source>
          <target state="translated">&lt;code&gt;git update-index&lt;/code&gt; 를 실행하지 않고 무작위 편집을 수행 합니다. 그리고 나서 &quot;상류&quot;트리의 끝이 당신이 그를 뽑아 낸 이후로 진행되었음을 알 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="96b7f9c5e1f885ad6155a2dabe0351e9e08cd246" translate="yes" xml:space="preserve">
          <source>You do your real work in your working tree that has your primary repository hanging under it as its &lt;code&gt;.git&lt;/code&gt; subdirectory. You &lt;strong&gt;could&lt;/strong&gt; make that repository accessible remotely and ask people to pull from it, but in practice that is not the way things are usually done. A recommended way is to have a public repository, make it reachable by other people, and when the changes you made in your primary working tree are in good shape, update the public repository from it. This is often called &lt;code&gt;pushing&lt;/code&gt;.</source>
          <target state="translated">기본 저장소가 &lt;code&gt;.git&lt;/code&gt; 하위 디렉토리 로 매달려있는 작업 트리에서 실제 작업을 수행합니다 . 당신은 &lt;strong&gt;할 수&lt;/strong&gt; 원격으로 저장소에 접근을하고 그것에서 풀에 사람을 물어하지만, 실제로 일을 주로 수행하는 방법이 아니다 그. 권장되는 방법은 공용 저장소를 갖고 다른 사람이 접근 할 수있게하고 기본 작업 트리에서 변경 한 내용이 올바른 경우 공용 저장소를 업데이트하는 것입니다. 이것을 종종 &lt;code&gt;pushing&lt;/code&gt; 라고 합니다.</target>
        </trans-unit>
        <trans-unit id="0911499c26fd93762ba87b20e89843bed2558fd8" translate="yes" xml:space="preserve">
          <source>You have made some commits, but realize they were premature to be in the &lt;code&gt;master&lt;/code&gt; branch. You want to continue polishing them in a topic branch, so create &lt;code&gt;topic/wip&lt;/code&gt; branch off of the current &lt;code&gt;HEAD&lt;/code&gt;.</source>
          <target state="translated">커밋을했지만 &lt;code&gt;master&lt;/code&gt; 브랜치 에 조기에 참여했음을 알 수 있습니다 . 토픽 브랜치에서 계속 연마하고 싶기 때문에 현재 &lt;code&gt;HEAD&lt;/code&gt; 에서 &lt;code&gt;topic/wip&lt;/code&gt; 브랜치를 생성 하십시오 .</target>
        </trans-unit>
        <trans-unit id="9321ccbae87a4bc4f97065bb17cb67a1a81520be" translate="yes" xml:space="preserve">
          <source>You have now created your first Git repository. Of course, since it&amp;rsquo;s empty, that&amp;rsquo;s not very useful, so let&amp;rsquo;s start populating it with data.</source>
          <target state="translated">이제 첫 번째 Git 저장소를 작성했습니다. 물론 비어 있기 때문에 그다지 유용하지 않으므로 데이터로 채우기를 시작하겠습니다.</target>
        </trans-unit>
        <trans-unit id="d177c25ea329a8110bbd819e0cb66c6b6619b0d7" translate="yes" xml:space="preserve">
          <source>You have now successfully copied somebody else&amp;rsquo;s (mine) remote repository, and checked it out.</source>
          <target state="translated">이제 다른 사람의 (마인) 원격 저장소를 성공적으로 복사하고 체크 아웃했습니다.</target>
        </trans-unit>
        <trans-unit id="3cc6b09871d23a7d903d56d9d6eb61d9c29d1dd4" translate="yes" xml:space="preserve">
          <source>You have performed no merges into mywork, so it is just a simple linear sequence of patches on top of &lt;code&gt;origin&lt;/code&gt;:</source>
          <target state="translated">그 위에 패치의 순서 선형 단순한, 그래서 당신은 MYWORK에 더 병합을 수행하지 않은 &lt;code&gt;origin&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="2f8744f866557cd48a608818edcb46f21bfb3d75" translate="yes" xml:space="preserve">
          <source>You have to run &lt;code&gt;git submodule update&lt;/code&gt; after &lt;code&gt;git pull&lt;/code&gt; if you want to update submodules, too.</source>
          <target state="translated">&lt;code&gt;git submodule update&lt;/code&gt; 하려면 &lt;code&gt;git pull&lt;/code&gt; 후에 git 하위 모듈 업데이트 를 실행해야합니다 .</target>
        </trans-unit>
        <trans-unit id="f82b6e7678c4aeade044d41684916154b148e08d" translate="yes" xml:space="preserve">
          <source>You haven&amp;rsquo;t specified any nodes as heads so it won&amp;rsquo;t be possible to differentiate between un-parented commits and root nodes.</source>
          <target state="translated">노드를 헤드로 지정하지 않았으므로 부모없는 커밋과 루트 노드를 구별 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="60617aeef2563268db523c5fdc5a619452e83d26" translate="yes" xml:space="preserve">
          <source>You may also add new content that does not exist in the patch; simply add new lines, each starting with &quot;+&quot;. The addition will appear reverted in the working tree.</source>
          <target state="translated">패치에 존재하지 않는 새 컨텐츠를 추가 할 수도 있습니다. 각각 &quot;+&quot;로 시작하는 새로운 줄을 추가하면됩니다. 작업 트리에서 추가 된 내용이 되돌려 나타납니다.</target>
        </trans-unit>
        <trans-unit id="ef502914f7e8ab4571571ef4343614d654bb655c" translate="yes" xml:space="preserve">
          <source>You may also have third-party helpers installed; search for &lt;code&gt;credential-*&lt;/code&gt; in the output of &lt;code&gt;git help -a&lt;/code&gt;, and consult the documentation of individual helpers. Once you have selected a helper, you can tell Git to use it by putting its name into the credential.helper variable.</source>
          <target state="translated">타사 도우미가 설치되어있을 수도 있습니다. &lt;code&gt;git help -a&lt;/code&gt; 출력에서 &lt;code&gt;credential-*&lt;/code&gt; 를 검색하고 개별 헬퍼의 문서를 참조하십시오. 헬퍼를 선택한 후에는 이름을 credential.helper 변수에 넣어 Git에게 사용하도록 지시 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f2298abd2d14c4384844acf0edbfaf0baea1ecae" translate="yes" xml:space="preserve">
          <source>You may also include a &lt;code&gt;!&lt;/code&gt; in front of the ref name to negate the entry, explicitly exposing it, even if an earlier entry marked it as hidden. If you have multiple hideRefs values, later entries override earlier ones (and entries in more-specific config files override less-specific ones).</source>
          <target state="translated">당신은 또한 포함 할 수 있습니다 &lt;code&gt;!&lt;/code&gt; ref 이름 앞에는 항목을 무효화하고 이전 항목이 숨겨진 것으로 표시 되더라도 명시 적으로 노출합니다. hideRefs 값이 여러 개인 경우 이후 항목은 이전 항목보다 우선합니다 (보다 구체적인 구성 파일의 항목은 덜 구체적인 값보다 우선 함).</target>
        </trans-unit>
        <trans-unit id="ea31f49a09c0b721c12c5805f99a1757f98a096f" translate="yes" xml:space="preserve">
          <source>You may also use &lt;a href=&quot;git-mergetool&quot;&gt;git-mergetool[1]&lt;/a&gt;, which lets you merge the unmerged files using external tools such as Emacs or kdiff3.</source>
          <target state="translated">당신은 또한 사용할 수 있습니다 &lt;a href=&quot;git-mergetool&quot;&gt;자식 - mergetool [1]&lt;/a&gt; 당신이 이맥스 나 kdiff3과 같은 외부 도구를 사용하여 병합되지 않은 파일을 병합 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9adc4f69fd1939534db6a41ec486285df53ebd63" translate="yes" xml:space="preserve">
          <source>You may execute several commands by either using one instance of &lt;code&gt;--exec&lt;/code&gt; with several commands:</source>
          <target state="translated">여러 개의 명령 과 함께 하나의 &lt;code&gt;--exec&lt;/code&gt; 인스턴스를 사용하여 여러 명령을 실행할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="a70c5e0fed390964e6d887a35161883ab1754024" translate="yes" xml:space="preserve">
          <source>You may find this helpful after reverting a topic branch merge, as this option recreates the topic branch with fresh commits so it can be remerged successfully without needing to &quot;revert the reversion&quot; (see the &lt;a href=&quot;https://git-scm.com/docs/howto/revert-a-faulty-merge&quot;&gt;revert-a-faulty-merge How-To&lt;/a&gt; for details).</source>
          <target state="translated">이 옵션은 신선한 커밋과 주제 분기를 재현으로는 &quot;복귀를 되돌릴&quot;할 필요없이 성공적으로 remerged 할 수 있도록, 주제 지점 병합을 되 돌린 후이 도움을 찾을 수 있습니다합니다 (참조 &lt;a href=&quot;https://git-scm.com/docs/howto/revert-a-faulty-merge&quot;&gt;되돌리기-A-결함이 병합 작업 방법&lt;/a&gt; 에 대한을 세부).</target>
        </trans-unit>
        <trans-unit id="08631c52a6efa8d7c45c6edcb816f877829615bc" translate="yes" xml:space="preserve">
          <source>You may force &lt;code&gt;git push&lt;/code&gt; to perform the update anyway by preceding the branch name with a plus sign:</source>
          <target state="translated">분기 이름 앞에 더하기 부호를 붙여서 &lt;code&gt;git push&lt;/code&gt; 가 강제로 업데이트를 수행하도록 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="ae2bd0ef4c886d9dfce1ee8146a7755d847ffcc2" translate="yes" xml:space="preserve">
          <source>You may often find that during a bisect session you want to have temporary modifications (e.g. s/#define DEBUG 0/#define DEBUG 1/ in a header file, or &quot;revision that does not have this commit needs this patch applied to work around another problem this bisection is not interested in&quot;) applied to the revision being tested.</source>
          <target state="translated">bisect 세션 동안 헤더 파일의 s / # define DEBUG 0 / # define DEBUG 1 / 또는 &quot;이 커밋이없는 수정본에는이 패치가 필요합니다. 이 양분에 관심이없는 또 다른 문제 &quot;) 테스트중인 개정에 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="014dba50ebab24a63a38baad57ed8364492c1d37" translate="yes" xml:space="preserve">
          <source>You may override individual configuration parameters when running any git command by using the &lt;code&gt;-c&lt;/code&gt; option. See &lt;a href=&quot;git&quot;&gt;git[1]&lt;/a&gt; for details.</source>
          <target state="translated">&lt;code&gt;-c&lt;/code&gt; 옵션 을 사용하여 git 명령을 실행할 때 개별 구성 매개 변수를 대체 할 수 있습니다 . 자세한 내용은 &lt;a href=&quot;git&quot;&gt;git [1]&lt;/a&gt; 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="ac5fdcda86efd0f875c444e1e9c4b64fbcccd8a8" translate="yes" xml:space="preserve">
          <source>You may specify configuration in your .git/config</source>
          <target state="translated">.git / config에서 구성을 지정할 수 있습니다</target>
        </trans-unit>
        <trans-unit id="13fb0fac683620e44c1d9b40bc74efe99d0db2f0" translate="yes" xml:space="preserve">
          <source>You may still choose to publish branches whose history is rewritten, and it may be useful for others to be able to fetch those branches in order to examine or test them, but they should not attempt to pull such branches into their own work.</source>
          <target state="translated">여전히 히스토리가 재 작성된 브랜치를 공개하도록 선택할 수 있으며, 다른 브랜치가 해당 브랜치를 검사하거나 테스트하기 위해 해당 브랜치를 가져 오는 것이 유용 할 수 있지만 해당 브랜치를 자신의 작업으로 가져 오려고 시도해서는 안됩니다.</target>
        </trans-unit>
        <trans-unit id="2cb3e9e45a2fe07905a833e4999cf989715a0ad3" translate="yes" xml:space="preserve">
          <source>You might need to instead use: folder = &quot;[Google Mail]/Drafts&quot; if you get an error that the &quot;Folder doesn&amp;rsquo;t exist&quot;.</source>
          <target state="translated">&quot;폴더가 존재하지 않습니다&quot;라는 오류가 발생하면 대신 folder = &quot;[Google Mail] / Drafts&quot;를 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="ce52beb4e545845637d5d5a0a1bc64e60b253c82" translate="yes" xml:space="preserve">
          <source>You might want to build on one of these remote-tracking branches on a branch of your own, just as you would for a tag:</source>
          <target state="translated">태그와 마찬가지로 다음과 같은 원격 추적 분기 중 하나를 자체 분기에 구축 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d0620c25fa90dc1aefb86ac91dfbd9e4eb8b29d0" translate="yes" xml:space="preserve">
          <source>You might want to recreate merge commits, e.g. if you have a history like this:</source>
          <target state="translated">예를 들어 다음과 같은 기록이있는 경우 병합 커밋을 다시 만들 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="76dbf6258421c615799bec755123a1d09c6ae993" translate="yes" xml:space="preserve">
          <source>You need to push the new tag to a public Git server (see &quot;DISTRIBUTED WORKFLOWS&quot; below). This makes the tag available to others tracking your project. The push could also trigger a post-update hook to perform release-related items such as building release tarballs and preformatted documentation pages.</source>
          <target state="translated">새 태그를 공개 Git 서버에 푸시해야합니다 (아래의 &quot;분산 된 워크 플로&quot;참조). 이렇게하면 프로젝트를 추적하는 다른 사람들이 태그를 사용할 수 있습니다. 이 푸시는 또한 업데이트 후 후크를 트리거하여 릴리스 타르볼 작성 및 사전 형식화 된 문서 페이지와 같은 릴리스 관련 항목을 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="23c2bb7cb1fc9b6f4a240d36b5b4f0b94079730d" translate="yes" xml:space="preserve">
          <source>You need to set the configuration variable &lt;code&gt;rerere.enabled&lt;/code&gt; in order to enable this command.</source>
          <target state="translated">이 명령을 사용하려면 구성 변수 &lt;code&gt;rerere.enabled&lt;/code&gt; 를 설정해야합니다 .</target>
        </trans-unit>
        <trans-unit id="beb1062efd31de3a255af22760556d9dc5fafa01" translate="yes" xml:space="preserve">
          <source>You normally only do signed tags for major releases or things like that, while the light-weight tags are useful for any marking you want to do &amp;mdash; any time you decide that you want to remember a certain point, just create a private tag for it, and you have a nice symbolic name for the state at that point.</source>
          <target state="translated">일반적으로 주요 릴리스 또는 이와 유사한 작업에 대해서는 서명 된 태그 만 수행하는 반면, 경량 태그는 원하는 마크에 유용합니다. 특정 지점을 기억하기로 결정한 경우 개인 태그를 작성하면됩니다. , 그 시점의 상태에 대한 훌륭한 상징적 이름이 있습니다.</target>
        </trans-unit>
        <trans-unit id="0eafb62c845e9f30a39264ada6b686e1d1ebb7b8" translate="yes" xml:space="preserve">
          <source>You often interact with the same remote repository by regularly and repeatedly fetching from it. In order to keep track of the progress of such a remote repository, &lt;code&gt;git fetch&lt;/code&gt; allows you to configure &lt;code&gt;remote.&amp;lt;repository&amp;gt;.fetch&lt;/code&gt; configuration variables.</source>
          <target state="translated">정기적으로 반복해서 가져와 동일한 원격 저장소와 상호 작용하는 경우가 많습니다. 이러한 원격 저장소의 진행 상황을 추적하기 위해 &lt;code&gt;git fetch&lt;/code&gt; 를 사용하면 &lt;code&gt;remote.&amp;lt;repository&amp;gt;.fetch&lt;/code&gt; 구성 변수 를 구성 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="0b67cab4bffb98d3ad72ff6748f9f8b98887d9f3" translate="yes" xml:space="preserve">
          <source>You probably don&amp;rsquo;t want to invoke this command directly; it is meant to be used as a credential helper by other parts of Git. See &lt;a href=&quot;gitcredentials&quot;&gt;gitcredentials[7]&lt;/a&gt; or &lt;code&gt;EXAMPLES&lt;/code&gt; below.</source>
          <target state="translated">이 명령을 직접 호출하고 싶지 않을 수도 있습니다. Git의 다른 부분에서 자격 증명 도우미로 사용되도록 고안되었습니다. 아래의 &lt;a href=&quot;gitcredentials&quot;&gt;gitcredentials [7]&lt;/a&gt; 또는 &lt;code&gt;EXAMPLES&lt;/code&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="467e6fc50e0615f651de6ffbcc6e0f17ecbae432" translate="yes" xml:space="preserve">
          <source>You probably don&amp;rsquo;t want to invoke this command directly; it is meant to be used as a credential helper by other parts of git. See &lt;a href=&quot;gitcredentials&quot;&gt;gitcredentials[7]&lt;/a&gt; or &lt;code&gt;EXAMPLES&lt;/code&gt; below.</source>
          <target state="translated">이 명령을 직접 호출하고 싶지 않을 수도 있습니다. 그것은 git의 다른 부분에서 자격 증명 도우미로 사용하기위한 것입니다. 아래의 &lt;a href=&quot;gitcredentials&quot;&gt;gitcredentials [7]&lt;/a&gt; 또는 &lt;code&gt;EXAMPLES&lt;/code&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="c924d93ebd8e89f99e14509235b47dec1acfaa5d" translate="yes" xml:space="preserve">
          <source>You read a &quot;tree&quot; file from the object database, and use that to populate (and overwrite&amp;mdash;​don&amp;rsquo;t do this if your index contains any unsaved state that you might want to restore later!) your current index. Normal operation is just</source>
          <target state="translated">객체 데이터베이스에서 &quot;트리&quot;파일을 읽고 현재 인덱스를 인덱스에 저장하고 덮어 쓰십시오. 인덱스에 저장하지 않은 상태가있는 경우이 작업을 수행하지 마십시오! 정상적인 작동은</target>
        </trans-unit>
        <trans-unit id="e01bf60bb2a8e848b7516e87eb6405fb0e476f7b" translate="yes" xml:space="preserve">
          <source>You really filtered all refs: use &lt;code&gt;--tag-name-filter cat -- --all&lt;/code&gt; when calling git-filter-branch.</source>
          <target state="translated">git-filter-branch를 호출 할 때 &lt;code&gt;--tag-name-filter cat -- --all&lt;/code&gt; 사용하여 모든 참조를 실제로 필터링했습니다 .</target>
        </trans-unit>
        <trans-unit id="0cb205f517a67a8e523ed9cfa8681dc8f8d7b0ce" translate="yes" xml:space="preserve">
          <source>You really removed all variants of a filename, if a blob was moved over its lifetime. &lt;code&gt;git log --name-only --follow --all -- filename&lt;/code&gt; can help you find renames.</source>
          <target state="translated">얼룩이 수명 동안 이동 한 경우 파일 이름의 모든 변형을 실제로 제거했습니다. &lt;code&gt;git log --name-only --follow --all -- filename&lt;/code&gt; 은 이름 바꾸기를 찾는 데 도움이 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a347f016fee70b8901448b2a81ecd1980ba100a9" translate="yes" xml:space="preserve">
          <source>You see, Git is actually the best tool to find out about the source of Git itself!</source>
          <target state="translated">아시다시피, Git은 실제로 Git 자체의 소스를 찾는 최고의 도구입니다!</target>
        </trans-unit>
        <trans-unit id="2f7c7430f5ab3ddee895946cce58e0edcbc9b3f3" translate="yes" xml:space="preserve">
          <source>You should &lt;strong&gt;never&lt;/strong&gt; do any work of your own on the branches that are created by &lt;code&gt;git cvsimport&lt;/code&gt;. By default initial import will create and populate a &quot;master&quot; branch from the CVS repository&amp;rsquo;s main branch which you&amp;rsquo;re free to work with; after that, you need to &lt;code&gt;git merge&lt;/code&gt; incremental imports, or any CVS branches, yourself. It is advisable to specify a named remote via -r to separate and protect the incoming branches.</source>
          <target state="translated">&lt;code&gt;git cvsimport&lt;/code&gt; 에 의해 생성 된 브랜치에서 어떤 작업도 수행 해서는 &lt;strong&gt;안됩니다&lt;/strong&gt; . 기본적으로 초기 가져 오기는 CVS 저장소의 기본 분기에서 &quot;마스터&quot;분기를 작성하고 채울 수 있습니다. 그런 다음 증분 가져 오기 또는 CVS 분기를 직접 &lt;code&gt;git merge&lt;/code&gt; 해야합니다 . 들어오는 분기를 분리하고 보호하기 위해 -r을 통해 명명 된 원격을 지정하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="ac5b50c688e69b32b2a523ca6520323d9259e65e" translate="yes" xml:space="preserve">
          <source>You should consider using &lt;code&gt;dcommit&lt;/code&gt; instead of this command. Commit specified commit or tree objects to SVN. This relies on your imported fetch data being up to date. This makes absolutely no attempts to do patching when committing to SVN, it simply overwrites files with those specified in the tree or commit. All merging is assumed to have taken place independently of &lt;code&gt;git svn&lt;/code&gt; functions.</source>
          <target state="translated">이 명령 대신 &lt;code&gt;dcommit&lt;/code&gt; 사용을 고려해야 합니다. 지정된 커밋 또는 트리 객체를 SVN에 커밋합니다. 가져온 가져 오기 데이터가 최신 상태인지 확인합니다. 이것은 SVN에 커밋 할 때 패치를 시도하지 않으며 트리 또는 커밋에 지정된 파일로 단순히 파일을 덮어 씁니다. 모든 병합은 &lt;code&gt;git svn&lt;/code&gt; 함수와 독립적으로 수행 된 것으로 가정 합니다.</target>
        </trans-unit>
        <trans-unit id="f0db0149a7a61b2b34d3de583889773851c606fb" translate="yes" xml:space="preserve">
          <source>You should now compile the checked-out version and test it. If that version works correctly, type</source>
          <target state="translated">이제 체크 아웃 된 버전을 컴파일하고 테스트해야합니다. 해당 버전이 제대로 작동하면 다음을 입력하십시오.</target>
        </trans-unit>
        <trans-unit id="4ce522d2b57e2c5b1484c387e3121e7cf3c762ef" translate="yes" xml:space="preserve">
          <source>You should refrain from abusing this option to sneak substantial changes into a merge commit. Small fixups like bumping release/version name would be acceptable.</source>
          <target state="translated">이 옵션을 남용하여 실질적인 변경 사항을 병합 커밋에 몰래 넣지 마십시오. 충돌 릴리스 / 버전 이름과 같은 작은 수정은 허용됩니다.</target>
        </trans-unit>
        <trans-unit id="de1993c72b3b1ad3dd18c76738408f9f041af6eb" translate="yes" xml:space="preserve">
          <source>You should understand the implications of rewriting history if you amend a commit that has already been published. (See the &quot;RECOVERING FROM UPSTREAM REBASE&quot; section in &lt;a href=&quot;git-rebase&quot;&gt;git-rebase[1]&lt;/a&gt;.)</source>
          <target state="translated">이미 게시 된 커밋을 수정 한 경우 기록 다시 쓰기의 의미를 이해해야합니다. ( &lt;a href=&quot;git-rebase&quot;&gt;git-rebase [1]의&lt;/a&gt; &quot;UPSTREAM REBASE 복구&quot;섹션을 참조하십시오 .)</target>
        </trans-unit>
        <trans-unit id="a5048e0c5c1221139fe969fc6db15713d2b83eb5" translate="yes" xml:space="preserve">
          <source>You should understand the implications of using &lt;code&gt;git rebase&lt;/code&gt; on a repository that you share. See also RECOVERING FROM UPSTREAM REBASE below.</source>
          <target state="translated">공유하는 저장소에서 &lt;code&gt;git rebase&lt;/code&gt; 를 사용할 때의 의미를 이해해야합니다 . 아래의 UPSTREAM REBASE에서 복구를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="7550fee71eb33261ce4427a0e3743a34c95d7107" translate="yes" xml:space="preserve">
          <source>You should work through &lt;a href=&quot;gittutorial&quot;&gt;gittutorial[7]&lt;/a&gt; before reading this tutorial.</source>
          <target state="translated">이 튜토리얼을 읽기 전에 &lt;a href=&quot;gittutorial&quot;&gt;gittutorial [7]을&lt;/a&gt; 통해 작업해야합니다 .</target>
        </trans-unit>
        <trans-unit id="33b464d633d5d3d359d8c081bd1ef24a08ba23d1" translate="yes" xml:space="preserve">
          <source>You then transfer the bundle to the other machine to replace /home/me/tmp/file.bundle, and pull from it.</source>
          <target state="translated">그런 다음 번들을 다른 시스템으로 전송하여 /home/me/tmp/file.bundle을 바꾸고 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="98122f0a874f3f8b610fdbc33b228a3b5afee64a" translate="yes" xml:space="preserve">
          <source>You update your working directory from the index by &quot;checking out&quot; files. This is not a very common operation, since normally you&amp;rsquo;d just keep your files updated, and rather than write to your working directory, you&amp;rsquo;d tell the index files about the changes in your working directory (i.e. &lt;code&gt;git update-index&lt;/code&gt;).</source>
          <target state="translated">파일을 &quot;체크 아웃&quot;하여 색인에서 작업 디렉토리를 업데이트합니다. 일반적으로 파일을 업데이트 한 상태로 유지하고 작업 디렉토리에 쓰지 않고 색인 파일에 작업 디렉토리의 변경 사항 (예 : &lt;code&gt;git update-index&lt;/code&gt; )을 알려주므로 매우 일반적인 작업은 아닙니다 .</target>
        </trans-unit>
        <trans-unit id="57134770b9c7f61c90927970f67f3d2eceaa4a12" translate="yes" xml:space="preserve">
          <source>You will continue to do your day-to-day work in your personal repository, but periodically &quot;push&quot; changes from your personal repository into your public repository, allowing other developers to pull from that repository. So the flow of changes, in a situation where there is one other developer with a public repository, looks like this:</source>
          <target state="translated">개인 저장소에서 일상적인 작업을 계속 수행하지만 개인 저장소에서 공용 저장소로 변경 사항을 주기적으로 &quot;밀어 넣어&quot;다른 개발자가 해당 저장소에서 가져올 수 있습니다. 따라서 공용 저장소를 가진 다른 개발자가있는 경우 변경 흐름은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="8876e4496883cded62698bb08d4c1d5f289e1dee" translate="yes" xml:space="preserve">
          <source>You will see both of these things throughout the code.</source>
          <target state="translated">코드 전체에서이 두 가지를 볼 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4dda56fbfc3230573e73ab526d0f70db698497a1" translate="yes" xml:space="preserve">
          <source>You will see informational messages on dangling objects. They are objects that still exist in the repository but are no longer referenced by any of your branches, and can (and will) be removed after a while with &lt;code&gt;gc&lt;/code&gt;. You can run &lt;code&gt;git fsck --no-dangling&lt;/code&gt; to suppress these messages, and still view real errors.</source>
          <target state="translated">매달려있는 개체에 대한 정보 메시지가 표시됩니다. 그것들은 여전히 ​​저장소에 존재하지만 더 이상 어떤 브랜치에서도 참조하지 않는 객체이며 &lt;code&gt;gc&lt;/code&gt; 로 잠시 후에 제거 할 수 있습니다 . &lt;code&gt;git fsck --no-dangling&lt;/code&gt; 을 실행 하여 이러한 메시지를 억제하고 실제 오류를 볼 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f2fc4e070409aa778dc2444037511e0ef4801d3d" translate="yes" xml:space="preserve">
          <source>You will see two files, &lt;code&gt;pack-*.pack&lt;/code&gt; and &lt;code&gt;pack-*.idx&lt;/code&gt;, in &lt;code&gt;.git/objects/pack&lt;/code&gt; directory. They are closely related to each other, and if you ever copy them by hand to a different repository for whatever reason, you should make sure you copy them together. The former holds all the data from the objects in the pack, and the latter holds the index for random access.</source>
          <target state="translated">&lt;code&gt;.git/objects/pack&lt;/code&gt; 디렉토리 에 pack- &lt;code&gt;pack-*.pack&lt;/code&gt; 및 &lt;code&gt;pack-*.idx&lt;/code&gt; 파일이 표시됩니다 . 그것들은 서로 밀접하게 관련되어 있으며 어떤 이유로 든 다른 저장소에 직접 복사하는 경우 함께 복사해야합니다. 전자는 팩에있는 개체의 모든 데이터를 보유하고 후자는 임의 액세스를위한 색인을 보유합니다.</target>
        </trans-unit>
        <trans-unit id="266addba668945d927bfdfb63b85369114140000" translate="yes" xml:space="preserve">
          <source>You will still have to tell people by other means, such as mail. (Git provides the &lt;a href=&quot;git-request-pull&quot;&gt;git-request-pull[1]&lt;/a&gt; to send preformatted pull requests to upstream maintainers to simplify this task.)</source>
          <target state="translated">우편과 같은 다른 방법으로 사람들에게 계속 알려야합니다. Git은 &lt;a href=&quot;git-request-pull&quot;&gt;git-request-pull [1]&lt;/a&gt; 을 제공하여이 작업을 단순화하기 위해 사전 형식화 된 풀 요청을 업스트림 관리자에게 보냅니다.</target>
        </trans-unit>
        <trans-unit id="67a2c97a3fe15102ccbc39363d071f9caa744775" translate="yes" xml:space="preserve">
          <source>You would normally use &lt;code&gt;git merge-index&lt;/code&gt; with supplied &lt;code&gt;git merge-one-file&lt;/code&gt; to do this last step. The script updates the files in the working tree as it merges each path and at the end of a successful merge.</source>
          <target state="translated">일반적으로 제공된 &lt;code&gt;git merge-one-file&lt;/code&gt; 과 함께 &lt;code&gt;git merge-index&lt;/code&gt; 를 사용 하여 마지막 단계를 수행합니다. 스크립트는 각 경로를 병합하고 성공적인 병합이 끝날 때 작업 트리의 파일을 업데이트합니다.</target>
        </trans-unit>
        <trans-unit id="acf5d70c570af359d1fc1b3db4b2e1cb44907ec4" translate="yes" xml:space="preserve">
          <source>You wouldn&amp;rsquo;t need to ever change it in gitweb config file.</source>
          <target state="translated">gitweb 설정 파일에서 변경할 필요가 없습니다.</target>
        </trans-unit>
        <trans-unit id="065eff42d50778a1002dd0b7a890143f4063288e" translate="yes" xml:space="preserve">
          <source>You write your current index file to a &quot;tree&quot; object with the program</source>
          <target state="translated">프로그램을 사용하여 현재 색인 파일을 &quot;트리&quot;개체에 씁니다.</target>
        </trans-unit>
        <trans-unit id="49012e7b5c219e4c44033d7ce0ec88b78d68a780" translate="yes" xml:space="preserve">
          <source>You&amp;rsquo;ve now initialized the working directory&amp;mdash;​you may notice a new directory created, named &quot;.git&quot;.</source>
          <target state="translated">이제 작업 디렉토리를 초기화했습니다. &quot;.git&quot;라는 새 디렉토리가 생성 된 것을 볼 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8e4b96aa3f69a0a980be2d48bd9eb2298bc44f3c" translate="yes" xml:space="preserve">
          <source>You&amp;rsquo;ve now made your first real Git commit. And if you&amp;rsquo;re interested in looking at what &lt;code&gt;git commit&lt;/code&gt; really does, feel free to investigate: it&amp;rsquo;s a few very simple shell scripts to generate the helpful (?) commit message headers, and a few one-liners that actually do the commit itself (&lt;code&gt;git commit&lt;/code&gt;).</source>
          <target state="translated">이제 첫 번째 실제 Git 커밋을 만들었습니다. 그리고 &lt;code&gt;git commit&lt;/code&gt; 이 실제로 무엇을하는지 관심이 있다면 , 자유롭게 조사해보십시오. 유용한 (?) commit 메시지 헤더를 생성하는 매우 간단한 쉘 스크립트와 실제로 commit 자체를 수행하는 하나의 라이너 ( &lt;code&gt;git commit&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="6fd65e242e5023949f1979a313cb8892375303bf" translate="yes" xml:space="preserve">
          <source>Your &quot;public repository&quot; is now ready to accept your changes. Come back to the machine you have your private repository. From there, run this command:</source>
          <target state="translated">&quot;공개 저장소&quot;가 이제 변경 사항을 승인 할 준비가되었습니다. 개인 저장소가있는 머신으로 돌아 오십시오. 거기에서 다음 명령을 실행하십시오.</target>
        </trans-unit>
        <trans-unit id="77f5c1536424041eff5dddce9b9dc699480c5921" translate="yes" xml:space="preserve">
          <source>Your private repository&amp;rsquo;s Git directory is usually &lt;code&gt;.git&lt;/code&gt;, but your public repository is often named after the project name, i.e. &lt;code&gt;&amp;lt;project&amp;gt;.git&lt;/code&gt;. Let&amp;rsquo;s create such a public repository for project &lt;code&gt;my-git&lt;/code&gt;. After logging into the remote machine, create an empty directory:</source>
          <target state="translated">개인 저장소의 Git 디렉토리는 일반적으로 &lt;code&gt;.git&lt;/code&gt; 이지만 공용 저장소의 이름은 종종 프로젝트 이름 (예 : &lt;code&gt;&amp;lt;project&amp;gt;.git&lt;/code&gt; )으로 지정 됩니다. &lt;code&gt;my-git&lt;/code&gt; 프로젝트를위한 공개 저장소를 만들어 보자 . 원격 머신에 로그인 한 후 빈 디렉토리를 작성하십시오.</target>
        </trans-unit>
        <trans-unit id="b96e6decf426a8986abe42a514d0d538e2f36071" translate="yes" xml:space="preserve">
          <source>Your work tree is still based on your HEAD ($JC), but you have some edits since. Three-way merge makes sure that you have not added or modified index entries since $JC, and if you haven&amp;rsquo;t, then does the right thing. So with the following sequence:</source>
          <target state="translated">작업 트리는 여전히 HEAD ($ JC)를 기반으로하지만 그 이후로 몇 가지 수정 사항이 있습니다. 3 방향 병합은 $ JC 이후로 색인 항목을 추가하거나 수정하지 않았으며, 그렇지 않은 경우 올바른 작업을 수행합니다. 따라서 다음 순서로 :</target>
        </trans-unit>
        <trans-unit id="8ff2148494456dea5c056275d6718302d7ecd982" translate="yes" xml:space="preserve">
          <source>Zero or more &lt;code&gt;filemodify&lt;/code&gt;, &lt;code&gt;filedelete&lt;/code&gt;, &lt;code&gt;filecopy&lt;/code&gt;, &lt;code&gt;filerename&lt;/code&gt;, &lt;code&gt;filedeleteall&lt;/code&gt; and &lt;code&gt;notemodify&lt;/code&gt; commands may be included to update the contents of the branch prior to creating the commit. These commands may be supplied in any order. However it is recommended that a &lt;code&gt;filedeleteall&lt;/code&gt; command precede all &lt;code&gt;filemodify&lt;/code&gt;, &lt;code&gt;filecopy&lt;/code&gt;, &lt;code&gt;filerename&lt;/code&gt; and &lt;code&gt;notemodify&lt;/code&gt; commands in the same commit, as &lt;code&gt;filedeleteall&lt;/code&gt; wipes the branch clean (see below).</source>
          <target state="translated">커밋을 만들기 전에 분기의 내용을 업데이트하기 위해 0 개 이상의 &lt;code&gt;filemodify&lt;/code&gt; , &lt;code&gt;filedelete&lt;/code&gt; , &lt;code&gt;filecopy&lt;/code&gt; , &lt;code&gt;filerename&lt;/code&gt; , &lt;code&gt;filedeleteall&lt;/code&gt; 및 &lt;code&gt;notemodify&lt;/code&gt; 명령이 포함될 수 있습니다. 이러한 명령은 임의의 순서로 제공 될 수 있습니다. 그러나 &lt;code&gt;filedeleteall&lt;/code&gt; 은 브랜치를 정리하므로 (아래 참조) , 동일한 커밋에서 &lt;code&gt;filedeleteall&lt;/code&gt; 명령이 모든 &lt;code&gt;filemodify&lt;/code&gt; , &lt;code&gt;filecopy&lt;/code&gt; , &lt;code&gt;filerename&lt;/code&gt; 및 &lt;code&gt;notemodify&lt;/code&gt; 명령 앞에 오는 것이 좋습니다 .</target>
        </trans-unit>
        <trans-unit id="480b45cead8c71eaa647209c97491be4a36ea289" translate="yes" xml:space="preserve">
          <source>Zero or more protocol options may be entered after the last &lt;code&gt;push&lt;/code&gt; command, before the batch&amp;rsquo;s terminating blank line.</source>
          <target state="translated">일괄 처리 종료 빈 줄 앞에 마지막 &lt;code&gt;push&lt;/code&gt; 명령 후 0 개 이상의 프로토콜 옵션을 입력 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="fbdec3db39874b3b5b75476184662777ddc44fd6" translate="yes" xml:space="preserve">
          <source>[&amp;lt;git-rev-list-args&amp;gt;&amp;hellip;​]</source>
          <target state="translated">[&amp;lt;git-rev-list-args&amp;gt;&amp;hellip;​]</target>
        </trans-unit>
        <trans-unit id="b3a075bbccfeeb4bedba2aca4addb159d1acee3d" translate="yes" xml:space="preserve">
          <source>[&amp;lt;path&amp;gt;&amp;hellip;​]</source>
          <target state="translated">[&amp;lt;path&amp;gt;&amp;hellip;​]</target>
        </trans-unit>
        <trans-unit id="d31c8b5c3af548ff2d95f4e227ea28f0f9277441" translate="yes" xml:space="preserve">
          <source>[&amp;lt;refname&amp;gt;&amp;hellip;​]</source>
          <target state="translated">[&amp;lt;refname&amp;gt;&amp;hellip;​]</target>
        </trans-unit>
        <trans-unit id="e961d55ee5b355694495464c07c86f7fba23e9a9" translate="yes" xml:space="preserve">
          <source>[--] &amp;lt;path&amp;gt;&amp;hellip;​</source>
          <target state="translated">[--] &amp;lt;path&amp;gt;&amp;hellip;​</target>
        </trans-unit>
        <trans-unit id="1eb3d578c1f910d18345d8eb23a781efa2f8d23d" translate="yes" xml:space="preserve">
          <source>[0] &lt;a href=&quot;https://bugs.chromium.org/p/git/issues/detail?id=6&quot;&gt;https://bugs.chromium.org/p/git/issues/detail?id=6&lt;/a&gt; Chromium work item for: Multi-Pack Index (MIDX)</source>
          <target state="translated">[0] &lt;a href=&quot;https://bugs.chromium.org/p/git/issues/detail?id=6&quot;&gt;https://bugs.chromium.org/p/git/issues/detail?id=6&lt;/a&gt; Chromium work item for: Multi-Pack Index (MIDX)</target>
        </trans-unit>
        <trans-unit id="25a96ba2d3b7a7d8ee2c18075362c090194ac1d0" translate="yes" xml:space="preserve">
          <source>[1] &lt;a href=&quot;https://lore.kernel.org/git/20180107181459.222909-1-dstolee@microsoft.com/&quot;&gt;https://lore.kernel.org/git/20180107181459.222909-1-dstolee@microsoft.com/&lt;/a&gt; An earlier RFC for the multi-pack-index feature</source>
          <target state="translated">[1] &lt;a href=&quot;https://lore.kernel.org/git/20180107181459.222909-1-dstolee@microsoft.com/&quot;&gt;https://lore.kernel.org/git/20180107181459.222909-1-dstolee@microsoft.com/&lt;/a&gt; An earlier RFC for the multi-pack-index feature</target>
        </trans-unit>
        <trans-unit id="347fffb72e72a788a9461ff2e246ae61494e14d7" translate="yes" xml:space="preserve">
          <source>[2] &lt;a href=&quot;https://lore.kernel.org/git/alpine.DEB.2.20.1803091557510.23109@alexmv-linux/&quot;&gt;https://lore.kernel.org/git/alpine.DEB.2.20.1803091557510.23109@alexmv-linux/&lt;/a&gt; Git Merge 2018 Contributor&amp;rsquo;s summit notes (includes discussion of MIDX)</source>
          <target state="translated">[2] &lt;a href=&quot;https://lore.kernel.org/git/alpine.DEB.2.20.1803091557510.23109@alexmv-linux/&quot;&gt;https://lore.kernel.org/git/alpine.DEB.2.20.1803091557510.23109@alexmv-linux/&lt;/a&gt; Git Merge 2018 Contributor&amp;rsquo;s summit notes (includes discussion of MIDX)</target>
        </trans-unit>
        <trans-unit id="feea73f842c5a1ec74b307b98128568bae22544a" translate="yes" xml:space="preserve">
          <source>[DEPRECATED: use &lt;code&gt;--rebase-merges&lt;/code&gt; instead] Recreate merge commits instead of flattening the history by replaying commits a merge commit introduces. Merge conflict resolutions or manual amendments to merge commits are not preserved.</source>
          <target state="translated">[DEPRECATED: use &lt;code&gt;--rebase-merges&lt;/code&gt; instead] Recreate merge commits instead of flattening the history by replaying commits a merge commit introduces. Merge conflict resolutions or manual amendments to merge commits are not preserved.</target>
        </trans-unit>
        <trans-unit id="a59f280e0e654176579fad979c6b2390d4560b5d" translate="yes" xml:space="preserve">
          <source>[EXPERIMENTAL] Set to &lt;code&gt;true&lt;/code&gt; to use the experimental built-in implementation of the interactive version of &lt;a href=&quot;git-add&quot;&gt;git-add[1]&lt;/a&gt; instead of the Perl script version. Is &lt;code&gt;false&lt;/code&gt; by default.</source>
          <target state="translated">[EXPERIMENTAL] Set to &lt;code&gt;true&lt;/code&gt; to use the experimental built-in implementation of the interactive version of &lt;a href=&quot;git-add&quot;&gt;git-add[1]&lt;/a&gt; instead of the Perl script version. Is &lt;code&gt;false&lt;/code&gt; by default.</target>
        </trans-unit>
        <trans-unit id="f8205d704abeeab8758bae84f0f9eac80a6c4899" translate="yes" xml:space="preserve">
          <source>[NOTE] &lt;code&gt;git rerere&lt;/code&gt; relies on the conflict markers in the file to detect the conflict. If the file already contains lines that look the same as lines with conflict markers, &lt;code&gt;git rerere&lt;/code&gt; may fail to record a conflict resolution. To work around this, the &lt;code&gt;conflict-marker-size&lt;/code&gt; setting in &lt;a href=&quot;gitattributes&quot;&gt;gitattributes[5]&lt;/a&gt; can be used.</source>
          <target state="translated">[NOTE] &lt;code&gt;git rerere&lt;/code&gt; relies on the conflict markers in the file to detect the conflict. If the file already contains lines that look the same as lines with conflict markers, &lt;code&gt;git rerere&lt;/code&gt; may fail to record a conflict resolution. To work around this, the &lt;code&gt;conflict-marker-size&lt;/code&gt; setting in &lt;a href=&quot;gitattributes&quot;&gt;gitattributes[5]&lt;/a&gt; can be used.</target>
        </trans-unit>
        <trans-unit id="ac4bc8630c3c03bfd813e3fe5057d1c466974ce5" translate="yes" xml:space="preserve">
          <source>[[[1]]] &lt;a href=&quot;https://www.nist.gov/sites/default/files/documents/director/planning/report02-3.pdf&quot;&gt;&lt;em&gt;The Economic Impacts of Inadequate Infratructure for Software Testing&lt;/em&gt;. Nist Planning Report 02-3&lt;/a&gt;, see Executive Summary and Chapter 8.</source>
          <target state="translated">[[[1]]] &lt;a href=&quot;https://www.nist.gov/sites/default/files/documents/director/planning/report02-3.pdf&quot;&gt;&lt;em&gt;The Economic Impacts of Inadequate Infratructure for Software Testing&lt;/em&gt;. Nist Planning Report 02-3&lt;/a&gt;, see Executive Summary and Chapter 8.</target>
        </trans-unit>
        <trans-unit id="e5f919a0494a6ccb56ff39496ebf8651f04232d2" translate="yes" xml:space="preserve">
          <source>[[[2]]] &lt;a href=&quot;http://www.oracle.com/technetwork/java/codeconvtoc-136057.html&quot;&gt;&lt;em&gt;Code Conventions for the Java Programming Language&lt;/em&gt;. Sun Microsystems.&lt;/a&gt;</source>
          <target state="translated">[[[2]]] &lt;a href=&quot;http://www.oracle.com/technetwork/java/codeconvtoc-136057.html&quot;&gt;&lt;em&gt;Code Conventions for the Java Programming Language&lt;/em&gt;. Sun Microsystems.&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="de6da26d7d92c3d4bdee11d004d96506e88a1b00" translate="yes" xml:space="preserve">
          <source>[[[3]]] &lt;a href=&quot;https://en.wikipedia.org/wiki/Software_maintenance&quot;&gt;&lt;em&gt;Software maintenance&lt;/em&gt;. Wikipedia.&lt;/a&gt;</source>
          <target state="translated">[[[3]]] &lt;a href=&quot;https://en.wikipedia.org/wiki/Software_maintenance&quot;&gt;&lt;em&gt;Software maintenance&lt;/em&gt;. Wikipedia.&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="a21dac2771422b1ce396ac7103119df3289ef40d" translate="yes" xml:space="preserve">
          <source>[[[4]]] &lt;a href=&quot;https://lore.kernel.org/git/7vps5xsbwp.fsf_-_@assigned-by-dhcp.cox.net/&quot;&gt;Junio C Hamano. &lt;em&gt;Automated bisect success story&lt;/em&gt;.&lt;/a&gt;</source>
          <target state="translated">[[[4]]] &lt;a href=&quot;https://lore.kernel.org/git/7vps5xsbwp.fsf_-_@assigned-by-dhcp.cox.net/&quot;&gt;Junio C Hamano. &lt;em&gt;Automated bisect success story&lt;/em&gt;.&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="06e39006ce98590e4632510795aafbc71a8d5177" translate="yes" xml:space="preserve">
          <source>[[[5]]] &lt;a href=&quot;https://lwn.net/Articles/317154/&quot;&gt;Christian Couder. &lt;em&gt;Fully automated bisecting with &quot;git bisect run&quot;&lt;/em&gt;. LWN.net.&lt;/a&gt;</source>
          <target state="translated">[[[5]]] &lt;a href=&quot;https://lwn.net/Articles/317154/&quot;&gt;Christian Couder. &lt;em&gt;Fully automated bisecting with &quot;git bisect run&quot;&lt;/em&gt;. LWN.net.&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="a12b60ab9e79fee2e4613d666532029fdb7e1f4d" translate="yes" xml:space="preserve">
          <source>[[[6]]] &lt;a href=&quot;https://lwn.net/Articles/277872/&quot;&gt;Jonathan Corbet. &lt;em&gt;Bisection divides users and developers&lt;/em&gt;. LWN.net.&lt;/a&gt;</source>
          <target state="translated">[[[6]]] &lt;a href=&quot;https://lwn.net/Articles/277872/&quot;&gt;Jonathan Corbet. &lt;em&gt;Bisection divides users and developers&lt;/em&gt;. LWN.net.&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="fb3a1d698c871451809a03759d2052ad730db3fa" translate="yes" xml:space="preserve">
          <source>[[[7]]] &lt;a href=&quot;https://lore.kernel.org/lkml/20071207113734.GA14598@elte.hu/&quot;&gt;Ingo Molnar. &lt;em&gt;Re: BUG 2.6.23-rc3 can&amp;rsquo;t see sd partitions on Alpha&lt;/em&gt;. Linux-kernel mailing list.&lt;/a&gt;</source>
          <target state="translated">[[[7]]] &lt;a href=&quot;https://lore.kernel.org/lkml/20071207113734.GA14598@elte.hu/&quot;&gt;Ingo Molnar. &lt;em&gt;Re: BUG 2.6.23-rc3 can&amp;rsquo;t see sd partitions on Alpha&lt;/em&gt;. Linux-kernel mailing list.&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="91adb50bf54c20a1b51a7a5bd4f97f72154e309d" translate="yes" xml:space="preserve">
          <source>[[[8]]] &lt;a href=&quot;https://www.kernel.org/pub/software/scm/git/docs/git-bisect.html&quot;&gt;Junio C Hamano and the git-list. &lt;em&gt;git-bisect(1) Manual Page&lt;/em&gt;. Linux Kernel Archives.&lt;/a&gt;</source>
          <target state="translated">[[[8]]] &lt;a href=&quot;https://www.kernel.org/pub/software/scm/git/docs/git-bisect.html&quot;&gt;Junio C Hamano and the git-list. &lt;em&gt;git-bisect(1) Manual Page&lt;/em&gt;. Linux Kernel Archives.&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="62e3bcbb19b635de003c473322577e0da443bd26" translate="yes" xml:space="preserve">
          <source>[[[9]]] &lt;a href=&quot;https://github.com/Ealdwulf/bbchop&quot;&gt;Ealdwulf. &lt;em&gt;bbchop&lt;/em&gt;. GitHub.&lt;/a&gt;</source>
          <target state="translated">[[[9]]] &lt;a href=&quot;https://github.com/Ealdwulf/bbchop&quot;&gt;Ealdwulf. &lt;em&gt;bbchop&lt;/em&gt;. GitHub.&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="4720dfbb1b4c30f403e79c3ea73865f0f4c5faef" translate="yes" xml:space="preserve">
          <source>[user@]host.xz:/~[user]/path/to/repo.git/</source>
          <target state="translated">[user@]host.xz:/~[user]/path/to/repo.git/</target>
        </trans-unit>
        <trans-unit id="5995beae7c11faa4cc7064555dea6942a8fa3779" translate="yes" xml:space="preserve">
          <source>[user@]host.xz:path/to/repo.git/</source>
          <target state="translated">[user@]host.xz:path/to/repo.git/</target>
        </trans-unit>
        <trans-unit id="8bc9eff643c5f26b1d25ab8fdf5a5ddc87d11ead" translate="yes" xml:space="preserve">
          <source>\0 line termination on output and do not quote filenames. See OUTPUT FORMAT below for more information.</source>
          <target state="translated">\0 line termination on output and do not quote filenames. See OUTPUT FORMAT below for more information.</target>
        </trans-unit>
        <trans-unit id="d0b23d6e6728ae49ec5909ad48b79671e7245999" translate="yes" xml:space="preserve">
          <source>\0 line termination on output and do not quote filenames. See OUTPUT below for more information.</source>
          <target state="translated">\0 line termination on output and do not quote filenames. See OUTPUT below for more information.</target>
        </trans-unit>
        <trans-unit id="ec441d8e621550cb4deb96e2b1ad67311ed0768f" translate="yes" xml:space="preserve">
          <source>a &lt;code&gt;&amp;lt;project&amp;gt;.git&lt;/code&gt; directory that is a &lt;code&gt;bare&lt;/code&gt; repository (i.e. without its own working tree), that is typically used for exchanging histories with others by pushing into it and fetching from it.</source>
          <target state="translated">&lt;code&gt;&amp;lt;project&amp;gt;.git&lt;/code&gt; A는 디렉토리 &lt;code&gt;bare&lt;/code&gt; 저장소 (즉, 자신의 작업 트리없이) 일반적으로 그것으로 밀고 그것에서 인출하여 다른 사람들과 역사를 교환하기 위해 사용된다.</target>
        </trans-unit>
        <trans-unit id="ea844fb65222d001b2e2f561d577c3d6a932db4a" translate="yes" xml:space="preserve">
          <source>a &lt;code&gt;.git&lt;/code&gt; directory at the root of the working tree;</source>
          <target state="translated">작업 트리의 루트에 있는 &lt;code&gt;.git&lt;/code&gt; 디렉토리;</target>
        </trans-unit>
        <trans-unit id="f0d4bf33608fee8383e25a39f62fec37be3db742" translate="yes" xml:space="preserve">
          <source>a &lt;code&gt;lot&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;lot&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="cc234069c4e3ee03ef8f7670cb491ed5411b65b6" translate="yes" xml:space="preserve">
          <source>a NUL (only exists if renamed/copied);</source>
          <target state="translated">NUL (이름이 바뀌거나 복사 된 경우에만 존재);</target>
        </trans-unit>
        <trans-unit id="079f5a842faae1ecf0933e998354e66093295bb8" translate="yes" xml:space="preserve">
          <source>a NUL.</source>
          <target state="translated">NUL.</target>
        </trans-unit>
        <trans-unit id="e9278592288a5c5c028d9d1d04c2201af670c4f7" translate="yes" xml:space="preserve">
          <source>a URL like &quot;git://example.org/path/to/repo.git&quot; will be rewritten to &quot;ssh://example.org/path/to/repo.git&quot; for pushes, but pulls will still use the original URL.</source>
          <target state="translated">&quot;git : //example.org/path/to/repo.git&quot;와 같은 URL은 푸시를 위해 &quot;ssh : //example.org/path/to/repo.git&quot;로 다시 쓰여지지만 풀은 여전히 원래 URL.</target>
        </trans-unit>
        <trans-unit id="96a7d2b2a7356a40bc207f3d1e0038c9f743ef8f" translate="yes" xml:space="preserve">
          <source>a URL like &quot;work:repo.git&quot; or like &quot;host.xz:/path/to/repo.git&quot; will be rewritten in any context that takes a URL to be &quot;git://git.host.xz/repo.git&quot;.</source>
          <target state="translated">&quot;work : repo.git&quot;또는 &quot;host.xz : /path/to/repo.git&quot;과 같은 URL은 URL이 &quot;git : //git.host.xz/repo 인 모든 컨텍스트에서 다시 작성됩니다. .git &quot;.</target>
        </trans-unit>
        <trans-unit id="da90a472a42edab28f6103dd507b377a59e39919" translate="yes" xml:space="preserve">
          <source>a colon.</source>
          <target state="translated">결장.</target>
        </trans-unit>
        <trans-unit id="07112c294a121f7cc6ed6654ce50e53f206b098f" translate="yes" xml:space="preserve">
          <source>a comment describing this commit.</source>
          <target state="translated">이 커밋을 설명하는 주석.</target>
        </trans-unit>
        <trans-unit id="6fd45c543fb44740f3ae2218676d1d2f809372d6" translate="yes" xml:space="preserve">
          <source>a committer: The name of the person who actually created the commit, with the date it was done. This may be different from the author, for example, if the author was someone who wrote a patch and emailed it to the person who used it to create the commit.</source>
          <target state="translated">커미터 : 커밋을 실제로 만든 사람의 이름과 날짜를 포함합니다. 예를 들어, 작성자가 패치를 작성하여 커밋을 생성하는 데 사용했던 사람에게 전자 메일을 보낸 사람인 경우에는 작성자와 다를 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="475363380919fa9dad3daaa5151af4a7ecf7fe63" translate="yes" xml:space="preserve">
          <source>a file called &lt;code&gt;HEAD&lt;/code&gt;, that has &lt;code&gt;ref: refs/heads/master&lt;/code&gt; in it. This is similar to a symbolic link and points at &lt;code&gt;refs/heads/master&lt;/code&gt; relative to the &lt;code&gt;HEAD&lt;/code&gt; file.</source>
          <target state="translated">라는 파일 &lt;code&gt;HEAD&lt;/code&gt; 가, &lt;code&gt;ref: refs/heads/master&lt;/code&gt; 그것입니다. 이것은 심볼릭 링크와 유사 하며 &lt;code&gt;HEAD&lt;/code&gt; 파일을 기준으로 &lt;code&gt;refs/heads/master&lt;/code&gt; 를 가리 킵니다 .</target>
        </trans-unit>
        <trans-unit id="956892125b0edbb5f2b693d0431acccf4dd5c1cd" translate="yes" xml:space="preserve">
          <source>a file in the &lt;code&gt;$GIT_DIR/branches&lt;/code&gt; directory.</source>
          <target state="translated">&lt;code&gt;$GIT_DIR/branches&lt;/code&gt; 디렉토리 의 파일 .</target>
        </trans-unit>
        <trans-unit id="7a8f92bb4f6fe9e686ed78d483dc8804c1d0837c" translate="yes" xml:space="preserve">
          <source>a file in the &lt;code&gt;$GIT_DIR/remotes&lt;/code&gt; directory, or</source>
          <target state="translated">&lt;code&gt;$GIT_DIR/remotes&lt;/code&gt; 디렉토리 의 파일 또는</target>
        </trans-unit>
        <trans-unit id="6fb331171394d95fbb7a35c4b995f2a83f23618c" translate="yes" xml:space="preserve">
          <source>a file that has &lt;code&gt;any&lt;/code&gt; difference what-so-ever in the three trees will stay as separate entries in the index. It&amp;rsquo;s up to &quot;porcelain policy&quot; to determine how to remove the non-0 stages, and insert a merged version.</source>
          <target state="translated">이 파일에 &lt;code&gt;any&lt;/code&gt; 세 개의 나무에서 무엇을 그리 적 차이는 인덱스에 별도의 항목으로 유지됩니다. 0이 아닌 단계를 제거하고 병합 된 버전을 삽입하는 방법은 &quot;도자기 정책&quot;에 달려 있습니다.</target>
        </trans-unit>
        <trans-unit id="fcb1d336b0be584d8054e8f7d63b3480aea0ee1d" translate="yes" xml:space="preserve">
          <source>a function called &lt;code&gt;cmd_&amp;lt;bla&amp;gt;&lt;/code&gt;, typically defined in &lt;code&gt;builtin/&amp;lt;bla.c&amp;gt;&lt;/code&gt; (note that older versions of Git used to have it in &lt;code&gt;builtin-&amp;lt;bla&amp;gt;.c&lt;/code&gt; instead), and declared in &lt;code&gt;builtin.h&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;cmd_&amp;lt;bla&amp;gt;&lt;/code&gt; 라는 함수는 일반적으로 &lt;code&gt;builtin/&amp;lt;bla.c&amp;gt;&lt;/code&gt; 에 정의되어 있으며 (이전 버전의 Git은 대신 &lt;code&gt;builtin-&amp;lt;bla&amp;gt;.c&lt;/code&gt; 에 사용 했었다는 점에 유의하십시오 ) &lt;code&gt;builtin.h&lt;/code&gt; 에 선언되었습니다 .</target>
        </trans-unit>
        <trans-unit id="d20b77e1575c57d2803f17741070661ffe1f7923" translate="yes" xml:space="preserve">
          <source>a line that begins with &quot;Index: &quot;</source>
          <target state="translated">&quot;Index :&quot;로 시작하는 줄</target>
        </trans-unit>
        <trans-unit id="eac485dbe3dc8258452b85ab1fdc03917425590f" translate="yes" xml:space="preserve">
          <source>a line that begins with &quot;diff -&quot;, or</source>
          <target state="translated">&quot;diff-&quot;로 시작하는 줄 또는</target>
        </trans-unit>
        <trans-unit id="8cb077e79c6b205418cec26b6f4930fe1ae56b3b" translate="yes" xml:space="preserve">
          <source>a newline.</source>
          <target state="translated">개행.</target>
        </trans-unit>
        <trans-unit id="678e3fa85625ddb634df3223f890cd55081ea7cd" translate="yes" xml:space="preserve">
          <source>a raw &lt;code&gt;%&lt;/code&gt;</source>
          <target state="translated">생 &lt;code&gt;%&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="a6a839de3aabe2c207992e1add851477714b9c5e" translate="yes" xml:space="preserve">
          <source>a remote in the Git configuration file: &lt;code&gt;$GIT_DIR/config&lt;/code&gt;,</source>
          <target state="translated">Git 구성 파일의 원격 : &lt;code&gt;$GIT_DIR/config&lt;/code&gt; ,</target>
        </trans-unit>
        <trans-unit id="f9af7071efb1bd7dd22ebf85f05d8810442b8586" translate="yes" xml:space="preserve">
          <source>a space between time and time zone</source>
          <target state="translated">시간대와 시간대</target>
        </trans-unit>
        <trans-unit id="65b604e2f985f7317d6866f6730d409a3832783e" translate="yes" xml:space="preserve">
          <source>a space instead of the &lt;code&gt;T&lt;/code&gt; date/time delimiter</source>
          <target state="translated">&lt;code&gt;T&lt;/code&gt; 날짜 / 시간 분리 문자 대신 공백</target>
        </trans-unit>
        <trans-unit id="5bc00ebd3440c4f401b07128f1c136e115562dd8" translate="yes" xml:space="preserve">
          <source>a space.</source>
          <target state="translated">우주.</target>
        </trans-unit>
        <trans-unit id="97a7ee5f8a960df69981e9527fa176cfdf9705cf" translate="yes" xml:space="preserve">
          <source>a subdirectory called &lt;code&gt;objects&lt;/code&gt;, which will contain all the objects of your project. You should never have any real reason to look at the objects directly, but you might want to know that these objects are what contains all the real &lt;code&gt;data&lt;/code&gt; in your repository.</source>
          <target state="translated">&lt;code&gt;objects&lt;/code&gt; 라는 서브 디렉토리 . 여기에는 프로젝트의 모든 오브젝트가 포함됩니다. 객체를 직접보아야 할 실질적인 이유가 없어야하지만 이러한 객체가 리포지토리의 모든 실제 &lt;code&gt;data&lt;/code&gt; 를 포함하고 있다는 것을 알고 싶을 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="045a27e5aab449465c7a517674ebf98a06438921" translate="yes" xml:space="preserve">
          <source>a subdirectory called &lt;code&gt;refs&lt;/code&gt;, which contains references to objects.</source>
          <target state="translated">객체에 대한 참조를 포함하는 &lt;code&gt;refs&lt;/code&gt; 라는 서브 디렉토리</target>
        </trans-unit>
        <trans-unit id="03097f133fc01ec710880af30fddc9a8cd7c34db" translate="yes" xml:space="preserve">
          <source>a tab or a NUL when &lt;code&gt;-z&lt;/code&gt; option is used.</source>
          <target state="translated">&lt;code&gt;-z&lt;/code&gt; 옵션을 사용하는 경우 탭 또는 NUL</target>
        </trans-unit>
        <trans-unit id="9346da07fb77dd97b82dc62a47eb3edc36d2b7a0" translate="yes" xml:space="preserve">
          <source>a tab or a NUL when &lt;code&gt;-z&lt;/code&gt; option is used; only exists for C or R.</source>
          <target state="translated">&lt;code&gt;-z&lt;/code&gt; 옵션이 사용되는 경우 탭 또는 NUL ; C 또는 R에만 존재합니다.</target>
        </trans-unit>
        <trans-unit id="c40734bc76bdc997f13a3bade66db88cc0dc137e" translate="yes" xml:space="preserve">
          <source>a tab;</source>
          <target state="translated">탭;</target>
        </trans-unit>
        <trans-unit id="19150edbe2f84d3c01f8f24ddf7de6b06a212def" translate="yes" xml:space="preserve">
          <source>a tree: The SHA-1 name of a tree object (as defined below), representing the contents of a directory at a certain point in time.</source>
          <target state="translated">트리 : 특정 시점의 디렉토리 내용을 나타내는 트리 객체 (아래에 정의 된대로)의 SHA-1 이름.</target>
        </trans-unit>
        <trans-unit id="013edfaa8480f23dc64a9a565714902a0f70e19a" translate="yes" xml:space="preserve">
          <source>a valid head &lt;code&gt;name&lt;/code&gt; (i.e. a &lt;code&gt;refs/heads/&amp;lt;head&amp;gt;&lt;/code&gt; reference).</source>
          <target state="translated">유효한 헤드 &lt;code&gt;name&lt;/code&gt; (예 : 참조 &lt;code&gt;refs/heads/&amp;lt;head&amp;gt;&lt;/code&gt; 참조)</target>
        </trans-unit>
        <trans-unit id="c3796b26d9f35f82d5c7ba0548ce633809586698" translate="yes" xml:space="preserve">
          <source>a valid tag &lt;code&gt;name&lt;/code&gt; (i.e. a &lt;code&gt;refs/tags/&amp;lt;tag&amp;gt;&lt;/code&gt; reference).</source>
          <target state="translated">유효한 태그 &lt;code&gt;name&lt;/code&gt; (예 : &lt;code&gt;refs/tags/&amp;lt;tag&amp;gt;&lt;/code&gt; 참조)</target>
        </trans-unit>
        <trans-unit id="fdbf716e8cd4fd3ff778984618bbe33ffeee814c" translate="yes" xml:space="preserve">
          <source>a) are ancestor of the &quot;bad&quot; commit (including the &quot;bad&quot; commit itself), b) are not ancestor of a &quot;good&quot; commit (excluding the &quot;good&quot; commits).</source>
          <target state="translated">a) &quot;나쁜&quot;커밋의 조상 ( &quot;나쁜&quot;커밋 자체 포함) b) &quot;좋은&quot;커밋의 조상 ( &quot;좋은&quot;커밋 제외)</target>
        </trans-unit>
        <trans-unit id="8682c02d1bc4bfce128a794497013605d86c32b6" translate="yes" xml:space="preserve">
          <source>a) regular use</source>
          <target state="translated">a) 정기적 인 사용</target>
        </trans-unit>
        <trans-unit id="4ff2759bc14568ced83be0be38a4abafea668a32" translate="yes" xml:space="preserve">
          <source>abbreviated commit hash</source>
          <target state="translated">약식 커밋 해시</target>
        </trans-unit>
        <trans-unit id="83baab4c4f5445b3450e34e24f8066fea1ac11f2" translate="yes" xml:space="preserve">
          <source>abbreviated parent hashes</source>
          <target state="translated">약식 부모 해시</target>
        </trans-unit>
        <trans-unit id="33579b1cb5338205dc784843012a5c0a9e8cacae" translate="yes" xml:space="preserve">
          <source>abbreviated tree hash</source>
          <target state="translated">약식 트리 해시</target>
        </trans-unit>
        <trans-unit id="832e60dfe198126ed45442b9d54f0a366515eefc" translate="yes" xml:space="preserve">
          <source>absorbgitdirs</source>
          <target state="translated">absorbgitdirs</target>
        </trans-unit>
        <trans-unit id="f412f21dd1d844e9ed4c1cbd73b06dc725c5d8bd" translate="yes" xml:space="preserve">
          <source>access method (one of &quot;ext&quot; or &quot;pserver&quot;)</source>
          <target state="translated">액세스 방법 ( &quot;ext&quot;또는 &quot;pserver&quot;중 하나)</target>
        </trans-unit>
        <trans-unit id="34eb4c4ef005207e8b8f916b9f1fffacccd6945e" translate="yes" xml:space="preserve">
          <source>action</source>
          <target state="translated">action</target>
        </trans-unit>
        <trans-unit id="326b426f9ac7a96ed6baf62f8838565416d27df8" translate="yes" xml:space="preserve">
          <source>actions</source>
          <target state="translated">actions</target>
        </trans-unit>
        <trans-unit id="58d1bbce297de3c304a9fefc3b483181872a5c6b" translate="yes" xml:space="preserve">
          <source>add</source>
          <target state="translated">add</target>
        </trans-unit>
        <trans-unit id="6d8bcdb6bdc1c6a236c5092142b208eb67008cee" translate="yes" xml:space="preserve">
          <source>add &amp;lt;path&amp;gt; [&amp;lt;commit-ish&amp;gt;]</source>
          <target state="translated">&amp;lt;path&amp;gt; [&amp;lt;commit-ish&amp;gt;] 추가</target>
        </trans-unit>
        <trans-unit id="89052c7d90a34c914815c621a3c8abaf890dfcb5" translate="yes" xml:space="preserve">
          <source>add [-b &amp;lt;branch&amp;gt;] [-f|--force] [--name &amp;lt;name&amp;gt;] [--reference &amp;lt;repository&amp;gt;] [--depth &amp;lt;depth&amp;gt;] [--] &amp;lt;repository&amp;gt; [&amp;lt;path&amp;gt;]</source>
          <target state="translated">추가 [-b &amp;lt;branch&amp;gt;] [-f | --force] [--name &amp;lt;name&amp;gt;] [--reference &amp;lt;repository&amp;gt;] [--depth &amp;lt;depth&amp;gt;] [-] &amp;lt;repository&amp;gt; [&amp;lt;path &amp;gt;]</target>
        </trans-unit>
        <trans-unit id="96b545065b00a5b7501087e2c1e93926449febd5" translate="yes" xml:space="preserve">
          <source>add a missing &lt;code&gt;\n&lt;/code&gt; to the last line if necessary.</source>
          <target state="translated">필요한 경우 누락 된 &lt;code&gt;\n&lt;/code&gt; 을 마지막 줄에 추가 하십시오.</target>
        </trans-unit>
        <trans-unit id="90bc127779a3e8fd8565532d33e4a134cd45f11d" translate="yes" xml:space="preserve">
          <source>add everything under the current directory.</source>
          <target state="translated">현재 디렉토리 아래에 모든 것을 추가하십시오.</target>
        </trans-unit>
        <trans-unit id="cb81f0f2d76a3c8759a19442b315f5c3a72e8b01" translate="yes" xml:space="preserve">
          <source>add untracked</source>
          <target state="translated">추적되지 않은 추가</target>
        </trans-unit>
        <trans-unit id="c22e3f3bd42e15a0bc002a5cba9cb2e9cb547df3" translate="yes" xml:space="preserve">
          <source>add.ignore-errors (deprecated)</source>
          <target state="translated">add.ignore-errors (더 이상 사용되지 않음)</target>
        </trans-unit>
        <trans-unit id="0d6211d85b6c5ebebd00bc700587b97d87d96f79" translate="yes" xml:space="preserve">
          <source>add.ignoreErrors</source>
          <target state="translated">add.ignoreErrors</target>
        </trans-unit>
        <trans-unit id="47d07ea3a984d5f17b8a52280b424c7e874d91e2" translate="yes" xml:space="preserve">
          <source>add.interactive.useBuiltin</source>
          <target state="translated">add.interactive.useBuiltin</target>
        </trans-unit>
        <trans-unit id="e441bfa1c3e8c860d35d02080c0d58234a3dc31b" translate="yes" xml:space="preserve">
          <source>addEmbeddedRepo</source>
          <target state="translated">addEmbeddedRepo</target>
        </trans-unit>
        <trans-unit id="ceb99972d01848a4af9e45ab5cd53f0d9ea700b4" translate="yes" xml:space="preserve">
          <source>added content</source>
          <target state="translated">추가 된 내용</target>
        </trans-unit>
        <trans-unit id="782f82176de20dd76d4373d2acfc3406073964ff" translate="yes" xml:space="preserve">
          <source>adding context (&quot; &quot;) or removal (&quot;-&quot;) lines</source>
          <target state="translated">컨텍스트 ( &quot;&quot;) 또는 제거 ( &quot;-&quot;) 행 추가</target>
        </trans-unit>
        <trans-unit id="39de4cfc4c6e6827c5f11475b89460e1b545a7f9" translate="yes" xml:space="preserve">
          <source>adds the following to &lt;code&gt;.git/config&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;.git/config&lt;/code&gt; 에 다음을 추가합니다 .</target>
        </trans-unit>
        <trans-unit id="f6acb502d3f3dcf967568ec1f1f05756c7001015" translate="yes" xml:space="preserve">
          <source>advice.*</source>
          <target state="translated">advice.*</target>
        </trans-unit>
        <trans-unit id="0608c4054662dd902e1314f7e450e3eaa81c1143" translate="yes" xml:space="preserve">
          <source>agent</source>
          <target state="translated">agent</target>
        </trans-unit>
        <trans-unit id="dc642557f3a1ed15b666c3bf8c010e9d1bceffe0" translate="yes" xml:space="preserve">
          <source>alias.*</source>
          <target state="translated">alias.*</target>
        </trans-unit>
        <trans-unit id="16f3bac085c702b24dd56dd8fdf474c5d21e6639" translate="yes" xml:space="preserve">
          <source>alice and cindy can push into master, only bob can push into doc-update. david is the release manager and is the only person who can create and push version tags.</source>
          <target state="translated">alice와 cindy는 마스터로 푸시 할 수 있으며 bob 만 doc-update로 푸시 할 수 있습니다. david는 릴리스 관리자이며 버전 태그를 작성하고 푸시 할 수있는 유일한 사람입니다.</target>
        </trans-unit>
        <trans-unit id="ae21c64a87f6bb0b8e16e55c48be4cc638d7bd3f" translate="yes" xml:space="preserve">
          <source>align</source>
          <target state="translated">align</target>
        </trans-unit>
        <trans-unit id="d87c448044defb778f33158d8ccf94a20531d600" translate="yes" xml:space="preserve">
          <source>all</source>
          <target state="translated">all</target>
        </trans-unit>
        <trans-unit id="29702e41afdcf565d852a6355913f10360a2f8b0" translate="yes" xml:space="preserve">
          <source>all parent object ids</source>
          <target state="translated">모든 부모 객체 ID</target>
        </trans-unit>
        <trans-unit id="6664a4a284b9aeecc837369fce6272fe3547f795" translate="yes" xml:space="preserve">
          <source>allow-indentation-change</source>
          <target state="translated">allow-indentation-change</target>
        </trans-unit>
        <trans-unit id="890c8ad25c4c255f4dda7bba71ccde4b6eb54f1a" translate="yes" xml:space="preserve">
          <source>allows you to browse any commits from the last 2 weeks of commits that modified files under the &quot;drivers&quot; directory. (Note: you can adjust gitk&amp;rsquo;s fonts by holding down the control key while pressing &quot;-&quot; or &quot;+&quot;.)</source>
          <target state="translated">&quot;드라이버&quot;디렉토리 아래에있는 파일을 수정 한 지난 2주의 커밋에서 커밋을 찾아 볼 수 있습니다. (참고 : &quot;-&quot;또는 &quot;+&quot;를 누른 상태에서 제어 키를 누르면 gitk의 글꼴을 조정할 수 있습니다.)</target>
        </trans-unit>
        <trans-unit id="8733169fb7d8912aa579031eed0a4b26ef5718fe" translate="yes" xml:space="preserve">
          <source>alternate object database</source>
          <target state="translated">대체 객체 데이터베이스</target>
        </trans-unit>
        <trans-unit id="385d97ddc2cf0f165b1e517e2de9a74c662d0d92" translate="yes" xml:space="preserve">
          <source>alternate: absolute path of alternate object databases; may appear multiple times, one line per path. Note that if the path contains non-printable characters, it may be surrounded by double-quotes and contain C-style backslashed escape sequences.</source>
          <target state="translated">대체 : 대체 객체 데이터베이스의 절대 경로. 경로당 한 줄에 여러 번 나타날 수 있습니다. 경로에 인쇄 할 수없는 문자가 포함 된 경우 큰 따옴표로 묶고 C 스타일 백 슬래시 이스케이프 시퀀스를 포함 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="459a9aeba984b09598ccfb2133b8ae65d179153d" translate="yes" xml:space="preserve">
          <source>although the full, 40-character SHA-1s would be supplied. If the foreign ref does not yet exist the &lt;code&gt;&amp;lt;remote SHA-1&amp;gt;&lt;/code&gt; will be 40 &lt;code&gt;0&lt;/code&gt;. If a ref is to be deleted, the &lt;code&gt;&amp;lt;local ref&amp;gt;&lt;/code&gt; will be supplied as &lt;code&gt;(delete)&lt;/code&gt; and the &lt;code&gt;&amp;lt;local
SHA-1&amp;gt;&lt;/code&gt; will be 40 &lt;code&gt;0&lt;/code&gt;. If the local commit was specified by something other than a name which could be expanded (such as &lt;code&gt;HEAD~&lt;/code&gt;, or a SHA-1) it will be supplied as it was originally given.</source>
          <target state="translated">전체 40 자 SHA-1이 제공되지만. 외부 참조가 아직 없으면 &lt;code&gt;&amp;lt;remote SHA-1&amp;gt;&lt;/code&gt; 은 40 &lt;code&gt;0&lt;/code&gt; 입니다. 의 Ref 삭제할 경우 &lt;code&gt;&amp;lt;local ref&amp;gt;&lt;/code&gt; 로서 공급된다 &lt;code&gt;(delete)&lt;/code&gt; 하고, &lt;code&gt;&amp;lt;local SHA-1&amp;gt;&lt;/code&gt; 40 것이다 &lt;code&gt;0&lt;/code&gt; . 확장 될 수있는 이름 이외의 이름 (예 : &lt;code&gt;HEAD~&lt;/code&gt; 또는 SHA-1)으로 로컬 커밋이 지정된 경우 원래 커밋 된대로 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="b16bb5afab4c1802eaeada40ac59f4ec78c01be8" translate="yes" xml:space="preserve">
          <source>always show in columns</source>
          <target state="translated">항상 열에 표시</target>
        </trans-unit>
        <trans-unit id="b0c4ba6a734338f8b0a5e21fcbb05d3afcd198af" translate="yes" xml:space="preserve">
          <source>always shows the difference between the HEAD and the index file&amp;mdash;​this is what you&amp;rsquo;d commit if you created the commit now&amp;mdash;​and that</source>
          <target state="translated">항상 HEAD와 인덱스 파일의 차이점을 보여줍니다. 지금 커밋을 만든 경우 커밋 한 것입니다.</target>
        </trans-unit>
        <trans-unit id="96e8155732e8324ae26f64d4516eb6fe696ac84f" translate="yes" xml:space="preserve">
          <source>am</source>
          <target state="translated">am</target>
        </trans-unit>
        <trans-unit id="400226a3b8758d7d662c424a478d16cceecd29ed" translate="yes" xml:space="preserve">
          <source>am.keepcr</source>
          <target state="translated">am.keepcr</target>
        </trans-unit>
        <trans-unit id="80b11664f9cdc0c4da5b2cf9cbae91e78f24cb5f" translate="yes" xml:space="preserve">
          <source>am.threeWay</source>
          <target state="translated">am.threeWay</target>
        </trans-unit>
        <trans-unit id="d9de89ed653daadc282d17fa341547ccd80f5e0c" translate="yes" xml:space="preserve">
          <source>amWorkDir</source>
          <target state="translated">amWorkDir</target>
        </trans-unit>
        <trans-unit id="b1cc99b811681fb579eeabe4a14a5e1ec1bab455" translate="yes" xml:space="preserve">
          <source>amend the previous commit, adding all your new changes, using your original message.</source>
          <target state="translated">원래 메시지를 사용하여 모든 새로운 변경 사항을 추가하여 이전 커밋을 수정하십시오.</target>
        </trans-unit>
        <trans-unit id="461152b367e8ab9740fb2e9ee2da4d7175e9e2a2" translate="yes" xml:space="preserve">
          <source>an LF or a NUL when &lt;code&gt;-z&lt;/code&gt; option is used, to terminate the record.</source>
          <target state="translated">&lt;code&gt;-z&lt;/code&gt; 옵션을 사용 하는 경우 LF 또는 NUL을 사용하여 레코드를 종료합니다.</target>
        </trans-unit>
        <trans-unit id="75eada615f3da2b986734d58bb672366de760679" translate="yes" xml:space="preserve">
          <source>an author: The name of the person responsible for this change, together with its date.</source>
          <target state="translated">저자 :이 변경을 담당하는 사람의 이름과 날짜.</target>
        </trans-unit>
        <trans-unit id="b441fe44ea3ab3bff759abb792c8a7f4c7974b0c" translate="yes" xml:space="preserve">
          <source>an entry in &lt;code&gt;BUILTIN_OBJECTS&lt;/code&gt; in the &lt;code&gt;Makefile&lt;/code&gt;.</source>
          <target state="translated">의 항목 &lt;code&gt;BUILTIN_OBJECTS&lt;/code&gt; 에서 &lt;code&gt;Makefile&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9d25597e1ded62863dd59e418a49b42af285a609" translate="yes" xml:space="preserve">
          <source>an entry in the &lt;code&gt;commands[]&lt;/code&gt; array in &lt;code&gt;git.c&lt;/code&gt;, and</source>
          <target state="translated">에 진입 &lt;code&gt;commands[]&lt;/code&gt; 의 배열 &lt;code&gt;git.c&lt;/code&gt; 및</target>
        </trans-unit>
        <trans-unit id="5037f82b8aa7002eda9aed7d8c0898525bc2f00d" translate="yes" xml:space="preserve">
          <source>and Git will continue applying the rest of the patches.</source>
          <target state="translated">Git은 나머지 패치를 계속 적용합니다.</target>
        </trans-unit>
        <trans-unit id="b3b2e45f7b37ac14dc28b61e29aee3c419229fda" translate="yes" xml:space="preserve">
          <source>and Git will create the commit for you and continue applying the remaining patches from the mailbox.</source>
          <target state="translated">Git은 커밋을 만들고 메일 함의 나머지 패치를 계속 적용합니다.</target>
        </trans-unit>
        <trans-unit id="7067f391e9f25da3da4a562c780b468101adb659" translate="yes" xml:space="preserve">
          <source>and Git will prompt you for a commit message and then create the new commit. Check to make sure it looks like what you expected with</source>
          <target state="translated">Git은 커밋 메시지를 물어보고 새로운 커밋을 만듭니다. 예상대로 보이는지 확인하십시오</target>
        </trans-unit>
        <trans-unit id="11bda7867b55ea900931dbe2ab8c87a36a0443d9" translate="yes" xml:space="preserve">
          <source>and bundle topic branches still cooking.</source>
          <target state="translated">그리고 여전히 요리하는 주제 분기를 묶습니다.</target>
        </trans-unit>
        <trans-unit id="06675e26cc6f5bedf7b0e9b9d71e33fb64fa4ef8" translate="yes" xml:space="preserve">
          <source>and email them.</source>
          <target state="translated">이메일로 보내주세요.</target>
        </trans-unit>
        <trans-unit id="d5d63b233efdc161b2104f0e091d210beeb2fe60" translate="yes" xml:space="preserve">
          <source>and hack away. The equivalent of &lt;code&gt;cvs update&lt;/code&gt; is</source>
          <target state="translated">해킹. 의 등가 &lt;code&gt;cvs update&lt;/code&gt; 입니다</target>
        </trans-unit>
        <trans-unit id="d4b59596148297f0688711ac4f92721dbc18215b" translate="yes" xml:space="preserve">
          <source>and if it detects that the file &quot;file0&quot; is completely rewritten, it changes it to:</source>
          <target state="translated">&quot;file0&quot;파일이 완전히 다시 작성된 것을 발견하면 다음과 같이 변경됩니다.</target>
        </trans-unit>
        <trans-unit id="e1426704be98b9dd3d938c5a6a31b3fe4ee9a995" translate="yes" xml:space="preserve">
          <source>and in fact a lot of the common Git command combinations can be scripted with the &lt;code&gt;git xyz&lt;/code&gt; interfaces. You can learn things by just looking at what the various git scripts do. For example, &lt;code&gt;git reset&lt;/code&gt; used to be the above two lines implemented in &lt;code&gt;git reset&lt;/code&gt;, but some things like &lt;code&gt;git status&lt;/code&gt; and &lt;code&gt;git commit&lt;/code&gt; are slightly more complex scripts around the basic Git commands.</source>
          <target state="translated">사실 많은 공통 Git 명령 조합을 &lt;code&gt;git xyz&lt;/code&gt; 인터페이스 로 스크립팅 할 수 있습니다 . 다양한 git 스크립트가하는 일만 살펴보면 사물을 배울 수 있습니다. 예를 들어, &lt;code&gt;git reset&lt;/code&gt; 은 &lt;code&gt;git reset&lt;/code&gt; 에서 구현 된 위의 두 줄 이었지만 &lt;code&gt;git status&lt;/code&gt; 및 &lt;code&gt;git commit&lt;/code&gt; 과 같은 일부 는 기본 Git 명령 주위에 약간 더 복잡한 스크립트입니다.</target>
        </trans-unit>
        <trans-unit id="c2f880dab39040d1bcbb6d73323cfccc9f1141f6" translate="yes" xml:space="preserve">
          <source>and it is assumed unchanged.</source>
          <target state="translated">그리고 변경되지 않은 것으로 가정합니다.</target>
        </trans-unit>
        <trans-unit id="6fdb49363e42ba495e98dac786aceef7ea588734" translate="yes" xml:space="preserve">
          <source>and it will be gone. There&amp;rsquo;s no external repository, and there&amp;rsquo;s no history outside the project you created.</source>
          <target state="translated">그리고 사라질 것입니다. 외부 리포지토리가 없으며 생성 한 프로젝트 외부에 기록이 없습니다.</target>
        </trans-unit>
        <trans-unit id="14be792a7fbd836c220980afe820c5835c201a25" translate="yes" xml:space="preserve">
          <source>and it would create the new branch &lt;code&gt;mybranch&lt;/code&gt; at the earlier commit, and check out the state at that time.</source>
          <target state="translated">이전 커밋에서 새 브랜치 &lt;code&gt;mybranch&lt;/code&gt; 를 만들고 그 당시의 상태를 확인합니다.</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
