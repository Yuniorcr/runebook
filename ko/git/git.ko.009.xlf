<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="git">
    <body>
      <group id="git">
        <trans-unit id="a8fe9598336f37cb9328ca8052e59b151a7933de" translate="yes" xml:space="preserve">
          <source>Text viewer for use by Git commands (e.g., &lt;code&gt;less&lt;/code&gt;). The value is meant to be interpreted by the shell. The order of preference is the &lt;code&gt;$GIT_PAGER&lt;/code&gt; environment variable, then &lt;code&gt;core.pager&lt;/code&gt; configuration, then &lt;code&gt;$PAGER&lt;/code&gt;, and then the default chosen at compile time (usually &lt;code&gt;less&lt;/code&gt;).</source>
          <target state="translated">Git 명령에 사용되는 텍스트 뷰어 (예 : &lt;code&gt;less&lt;/code&gt; ). 값은 쉘에 의해 해석됩니다. 우선 순위는 &lt;code&gt;$GIT_PAGER&lt;/code&gt; 환경 변수, &lt;code&gt;core.pager&lt;/code&gt; 구성, &lt;code&gt;$PAGER&lt;/code&gt; 및 컴파일 타임에 선택된 기본값 (보통은 &lt;code&gt;less&lt;/code&gt; )입니다.</target>
        </trans-unit>
        <trans-unit id="0bd1b0b7ad0ea4fe7d508b463e4e610ef00887b1" translate="yes" xml:space="preserve">
          <source>That is, a pattern followed by an attributes list, separated by whitespaces. Leading and trailing whitespaces are ignored. Lines that begin with &lt;code&gt;#&lt;/code&gt; are ignored. Patterns that begin with a double quote are quoted in C style. When the pattern matches the path in question, the attributes listed on the line are given to the path.</source>
          <target state="translated">즉, 공백으로 구분 된 패턴 뒤에 속성 목록이옵니다. 선행 및 후행 공백은 무시됩니다. &lt;code&gt;#&lt;/code&gt; 으로 시작하는 줄 은 무시됩니다. 큰 따옴표로 시작하는 패턴은 C 스타일로 인용됩니다. 패턴이 해당 경로와 일치하면 라인에 나열된 속성이 경로에 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="a2ed6bb3b9b6e451ccc6f660ef58cfb1d5aab73c" translate="yes" xml:space="preserve">
          <source>That is, from left to right:</source>
          <target state="translated">즉, 왼쪽에서 오른쪽으로 :</target>
        </trans-unit>
        <trans-unit id="8f093c96f9e4fd62eb55be18fd622f6079c4aad2" translate="yes" xml:space="preserve">
          <source>That is, from the left to the right:</source>
          <target state="translated">즉, 왼쪽에서 오른쪽으로</target>
        </trans-unit>
        <trans-unit id="11e8a09abfceb997eddb8423e1781ebd95db28e7" translate="yes" xml:space="preserve">
          <source>That is:</source>
          <target state="translated">그건:</target>
        </trans-unit>
        <trans-unit id="aa54aa26ef67ef77a7b5a4203a2f21478483f336" translate="yes" xml:space="preserve">
          <source>That means that even if you offer only read access (e.g. by using the pserver method), &lt;code&gt;git-cvsserver&lt;/code&gt; should have write access to the database to work reliably (otherwise you need to make sure that the database is up to date any time &lt;code&gt;git-cvsserver&lt;/code&gt; is executed).</source>
          <target state="translated">당신이합니다 (PSERVER 방법을 사용하여 예를 들어) 읽기 전용 액세스를 제공하는 경우에도 수단, 즉 &lt;code&gt;git-cvsserver&lt;/code&gt; 안정적으로 작업 할 수있는 데이터베이스에 대한 쓰기 권한이 있어야합니다 (그렇지 않으면 데이터베이스는 날짜 언제든지까지이 있는지 확인해야합니다 &lt;code&gt;git-cvsserver&lt;/code&gt; 가 실행됩니다).</target>
        </trans-unit>
        <trans-unit id="452813997abf32b7a81b495ef3287ae8cfa66246" translate="yes" xml:space="preserve">
          <source>That means that if you do a &lt;code&gt;git read-tree -m &amp;lt;newtree&amp;gt;&lt;/code&gt; followed by a &lt;code&gt;git checkout-index -f -u -a&lt;/code&gt;, the &lt;code&gt;git checkout-index&lt;/code&gt; only checks out the stuff that really changed.</source>
          <target state="translated">즉, &lt;code&gt;git read-tree -m &amp;lt;newtree&amp;gt;&lt;/code&gt; 다음에 &lt;code&gt;git checkout-index -f -u -a&lt;/code&gt; 를 수행하면 &lt;code&gt;git checkout-index&lt;/code&gt; 는 실제로 변경된 항목 만 체크 아웃합니다.</target>
        </trans-unit>
        <trans-unit id="a1aaaec20914cfb53973b0431f384394f0c406ca" translate="yes" xml:space="preserve">
          <source>That puts the heads and tags for each fork in their own island (named &quot;1234&quot; or similar), and the pull refs for each go into their own &quot;1234-pull&quot;.</source>
          <target state="translated">그러면 각 포크의 헤드와 태그가 자체 섬 ( &quot;1234&quot;또는 이와 유사한 이름)에 배치되고 각각의 풀 참조는 자체 &quot;1234- 풀&quot;로 이동합니다.</target>
        </trans-unit>
        <trans-unit id="767670eb6ab18d660b358046eb00166f0a64fef3" translate="yes" xml:space="preserve">
          <source>That will produce the diff between the tips of the two branches. If you&amp;rsquo;d prefer to find the diff from their common ancestor to test, you can use three dots instead of two:</source>
          <target state="translated">그러면 두 가지 끝 사이에 차이가 생깁니다. 테스트 할 공통 조상에서 diff를 찾으려면 두 개 대신 세 개의 점을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2ab4548e0b841bbace5e0a92c23778ab654224e3" translate="yes" xml:space="preserve">
          <source>That&amp;rsquo;s why the &quot;git replace&quot; command was created. Technically it stores replacements &quot;refs&quot; in the &quot;refs/replace/&quot; hierarchy. These &quot;refs&quot; are like branches (that are stored in &quot;refs/heads/&quot;) or tags (that are stored in &quot;refs/tags&quot;), and that means that they can automatically be shared like branches or tags among developers.</source>
          <target state="translated">이것이 &quot;git replace&quot;명령이 작성된 이유입니다. 기술적으로 &quot;refs / replace /&quot;계층에 대체 &quot;refs&quot;를 저장합니다. 이러한 &quot;refs&quot;는 브랜치 ( &quot;refs / heads /&quot;에 저장 됨) 또는 태그 ( &quot;refs / tags&quot;에 저장 됨)와 비슷하며 개발자들 사이에서 브랜치 또는 태그처럼 자동으로 공유 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e7f78784e12fead6a14f302d919d7dfe2a02b05b" translate="yes" xml:space="preserve">
          <source>The &quot;child_class&quot; field is a rough classification, such as &quot;editor&quot;, &quot;pager&quot;, &quot;transport/*&quot;, and &quot;hook&quot;. Unclassified children are classified with &quot;?&quot;.</source>
          <target state="translated">&quot;child_class&quot;필드는 &quot;editor&quot;, &quot;pager&quot;, &quot;transport / *&quot;및 &quot;hook&quot;과 같은 대략적인 분류입니다. 분류되지 않은 어린이는 &quot;?&quot;로 분류됩니다.</target>
        </trans-unit>
        <trans-unit id="fe5496d60fae83b54bfa30bb265cd284e395a597" translate="yes" xml:space="preserve">
          <source>The &quot;child_id&quot; field can be used to match this child_start with the corresponding child_exit event.</source>
          <target state="translated">&quot;child_id&quot;필드는이 child_start를 해당 child_exit 이벤트와 일치시키는 데 사용될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2ee1a593683be8a9c62bf7139373ea713a6461c3" translate="yes" xml:space="preserve">
          <source>The &quot;commit&quot; object links a physical state of a tree with a description of how we got there and why. Use the &lt;code&gt;--pretty=raw&lt;/code&gt; option to &lt;a href=&quot;git-show&quot;&gt;git-show[1]&lt;/a&gt; or &lt;a href=&quot;git-log&quot;&gt;git-log[1]&lt;/a&gt; to examine your favorite commit:</source>
          <target state="translated">&quot;commit&quot;객체는 트리의 물리적 상태를 우리가 도착한 방법과 이유에 대한 설명과 연결합니다. &lt;code&gt;--pretty=raw&lt;/code&gt; 옵션을 사용하여 &lt;a href=&quot;git-show&quot;&gt;git-show [1]&lt;/a&gt; 또는 &lt;a href=&quot;git-log&quot;&gt;git-log [1]&lt;/a&gt; 을 사용하여 선호하는 커밋을 검사하십시오.</target>
        </trans-unit>
        <trans-unit id="6db6601ce62b96f9f8fba54efac9ee5967a731f4" translate="yes" xml:space="preserve">
          <source>The &quot;default&quot; value consists of a list of triplets in the form &lt;code&gt;(&quot;&amp;lt;label&amp;gt;&quot;, &quot;&amp;lt;link&amp;gt;&quot;, &quot;&amp;lt;position&amp;gt;&quot;)&lt;/code&gt; where &quot;position&quot; is the label after which to insert the link, &quot;link&quot; is a format string where &lt;code&gt;%n&lt;/code&gt; expands to the project name, &lt;code&gt;%f&lt;/code&gt; to the project path within the filesystem (i.e. &quot;$projectroot/$project&quot;), &lt;code&gt;%h&lt;/code&gt; to the current hash ('h' gitweb parameter) and &lt;code&gt;%b&lt;/code&gt; to the current hash base ('hb' gitweb parameter); &lt;code&gt;%%&lt;/code&gt; expands to '%'.</source>
          <target state="translated">&quot;default&quot;값은 &lt;code&gt;(&quot;&amp;lt;label&amp;gt;&quot;, &quot;&amp;lt;link&amp;gt;&quot;, &quot;&amp;lt;position&amp;gt;&quot;)&lt;/code&gt; 형식의 트리플렛 목록으로 구성됩니다. 여기서 &quot;position&quot;은 &quot;link&quot;링크를 삽입 한 후의 레이블입니다. 포맷 문자열 &lt;code&gt;%n&lt;/code&gt; 프로젝트 이름으로 확장, &lt;code&gt;%f&lt;/code&gt; 파일 시스템 내의 프로젝트 경로 (즉, &quot;$ projectroot / $ 프로젝트&quot;), 행 &lt;code&gt;%h&lt;/code&gt; 현재 해시 ( 'H'gitweb 파라미터) 및 &lt;code&gt;%b&lt;/code&gt; 로는 현재 해시베이스 ( 'hb'gitweb 매개 변수); &lt;code&gt;%%&lt;/code&gt; 는 '%'로 확장됩니다.</target>
        </trans-unit>
        <trans-unit id="a92a8477d5d97d17f1c481b90522235992b0aec5" translate="yes" xml:space="preserve">
          <source>The &quot;delete&quot; subcommand deletes single entries from the reflog. Its argument must be an &lt;code&gt;exact&lt;/code&gt; entry (e.g. &quot;&lt;code&gt;git reflog delete
master@{2}&lt;/code&gt;&quot;). This subcommand is also typically not used directly by end users.</source>
          <target state="translated">&quot;delete&quot;부속 명령은 참조 로그에서 단일 항목을 삭제합니다. 인수는 &lt;code&gt;exact&lt;/code&gt; 항목 이어야합니다 (예 : &quot; &lt;code&gt;git reflog delete master@{2}&lt;/code&gt; &quot;). 이 하위 명령은 일반적으로 최종 사용자가 직접 사용하지도 않습니다.</target>
        </trans-unit>
        <trans-unit id="15cc724d6cfbdaca681c81ec6b39527ea7ba3e75" translate="yes" xml:space="preserve">
          <source>The &quot;downwards graduation&quot; discussed above cannot be done by actually merging downwards, however, since that would merge &lt;code&gt;all&lt;/code&gt; changes on the unstable branch into the stable one. Hence the following:</source>
          <target state="translated">위에서 논의한 &quot;아래로 눈금&quot;은 실제로 아래쪽으로 병합하여 수행 할 수 없습니다 . 불안정한 지점의 &lt;code&gt;all&lt;/code&gt; 변경 사항이 안정적인 지점으로 병합되기 때문입니다 . 따라서 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="4b681909e4d1085f8faa13044f43a355b4e9ca0a" translate="yes" xml:space="preserve">
          <source>The &quot;exec&quot; command launches the command in a shell (the one specified in &lt;code&gt;$SHELL&lt;/code&gt;, or the default shell if &lt;code&gt;$SHELL&lt;/code&gt; is not set), so you can use shell features (like &quot;cd&quot;, &quot;&amp;gt;&quot;, &quot;;&quot; &amp;hellip;​). The command is run from the root of the working tree.</source>
          <target state="translated">&quot;exec&quot;명령은 쉘 ( &lt;code&gt;$SHELL&lt;/code&gt; 지정된 명령 또는 &lt;code&gt;$SHELL&lt;/code&gt; 이 설정되지 않은 경우 기본 쉘) 에서 명령을 실행 하므로 쉘 기능 (예 : &quot;cd&quot;, &quot;&amp;gt;&quot;, &quot;;&quot;)을 사용할 수 있습니다. &amp;hellip;). 작업 트리의 루트에서 명령이 실행됩니다.</target>
        </trans-unit>
        <trans-unit id="3e27bb28ac33a3ed0da91ec19b0543d1741f2754" translate="yes" xml:space="preserve">
          <source>The &quot;exec_id&quot; field is a command-unique id and is only useful if the &lt;code&gt;exec()&lt;/code&gt; fails and a corresponding exec_result event is generated.</source>
          <target state="translated">&quot;exec_id&quot;필드는 명령 고유 ID이며 &lt;code&gt;exec()&lt;/code&gt; 가 실패하고 해당 exec_result 이벤트가 생성 된 경우에만 유용합니다 .</target>
        </trans-unit>
        <trans-unit id="111dec81403753e6a7d49025386f92b4f5a7ce80" translate="yes" xml:space="preserve">
          <source>The &quot;exists&quot; subcommand checks whether a ref has a reflog. It exits with zero status if the reflog exists, and non-zero status if it does not.</source>
          <target state="translated">&quot;exists&quot;부속 명령은 ref에 reflog가 있는지 점검합니다. reflog가 존재하면 상태가 0이고, 존재하지 않으면 0이 아닌 상태로 종료됩니다.</target>
        </trans-unit>
        <trans-unit id="b084a3a2964fff409a1c4bd5eaf3ff2af985bb46" translate="yes" xml:space="preserve">
          <source>The &quot;experimental&quot; branch is the one you just created, and the &quot;master&quot; branch is a default branch that was created for you automatically. The asterisk marks the branch you are currently on; type</source>
          <target state="translated">&quot;실험&quot;브랜치는 방금 생성 한 브랜치이며 &quot;마스터&quot;브랜치는 자동으로 생성 된 기본 브랜치입니다. 별표는 현재있는 지점을 표시합니다. 유형</target>
        </trans-unit>
        <trans-unit id="8a5c55e5646a8a6620c2e2207d5f34af5eadc4f2" translate="yes" xml:space="preserve">
          <source>The &quot;expire&quot; subcommand prunes older reflog entries. Entries older than &lt;code&gt;expire&lt;/code&gt; time, or entries older than &lt;code&gt;expire-unreachable&lt;/code&gt; time and not reachable from the current tip, are removed from the reflog. This is typically not used directly by end users &amp;mdash; instead, see &lt;a href=&quot;git-gc&quot;&gt;git-gc[1]&lt;/a&gt;.</source>
          <target state="translated">&quot;expire&quot;부속 명령은 이전 reflog 항목을 제거합니다. &lt;code&gt;expire&lt;/code&gt; 시간이 지난 항목 또는 &lt;code&gt;expire-unreachable&lt;/code&gt; 시간이 지난 항목 과 현재 팁에서 도달 할 수 없는 항목 은 reflog에서 제거됩니다. 일반적으로 최종 사용자가 직접 사용하지는 않으며 &lt;a href=&quot;git-gc&quot;&gt;git-gc [1]을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="51ddfbdb206861a134ce9d36a0cd6f8dcb912a92" translate="yes" xml:space="preserve">
          <source>The &quot;extent of changes&quot; parameter can be tweaked from the default 80% (that is, unless more than 80% of the original material is deleted, the broken pairs are merged back into a single modification) by giving a second number to -B option, like these:</source>
          <target state="translated">-B에 두 번째 숫자를 지정하여 &quot;변경 범위&quot;매개 변수를 기본 80 %에서 조정할 수 있습니다. 다음과 같은 옵션 :</target>
        </trans-unit>
        <trans-unit id="4be913eb74285fc0f11c845775de3706d8e8ac4f" translate="yes" xml:space="preserve">
          <source>The &quot;git-diff-tree&quot; command begins its output by printing the hash of what is being compared. After that, all the commands print one output line per changed file.</source>
          <target state="translated">&quot;git-diff-tree&quot;명령은 비교 대상의 해시를 인쇄하여 출력을 시작합니다. 그 후, 모든 명령은 변경된 파일 당 하나의 출력 행을 인쇄합니다.</target>
        </trans-unit>
        <trans-unit id="14e841537fdff67ebd6d58e11774065ab0f0ebfa" translate="yes" xml:space="preserve">
          <source>The &quot;indent&quot; filter is well-behaved in this regard: it will not modify input that is already correctly indented. In this case, the lack of a smudge filter means that the clean filter &lt;code&gt;must&lt;/code&gt; accept its own output without modifying it.</source>
          <target state="translated">&quot;들여 쓰기&quot;필터는 이와 관련하여 잘 작동합니다. 이미 올바르게 들여 쓰기 된 입력은 수정하지 않습니다. 이 경우 스미 지 필터가 없으면 클린 필터 &lt;code&gt;must&lt;/code&gt; 수정하지 않고 자체 출력을 수용 해야 합니다.</target>
        </trans-unit>
        <trans-unit id="2a9f18fc49cc181471bfbc97a47a88e9bcc1179f" translate="yes" xml:space="preserve">
          <source>The &quot;index&quot; holds a snapshot of the content of the working tree, and it is this snapshot that is taken as the contents of the next commit. Thus after making any changes to the working tree, and before running the commit command, you must use the &lt;code&gt;add&lt;/code&gt; command to add any new or modified files to the index.</source>
          <target state="translated">&quot;인덱스&quot;에는 작업 트리의 내용에 대한 스냅 샷이 있으며 다음 커밋의 내용으로 사용되는 것이이 스냅 샷입니다. 따라서 작업 트리를 변경 한 후 commit 명령을 실행하기 전에 &lt;code&gt;add&lt;/code&gt; 명령을 사용하여 새 파일이나 수정 된 파일을 색인에 추가 해야합니다 .</target>
        </trans-unit>
        <trans-unit id="6b5b86b50febe55839cf4e73fade50a78b6b0a0e" translate="yes" xml:space="preserve">
          <source>The &quot;master&quot; branch that was created at the time you cloned is a copy of the HEAD in the repository that you cloned from. That repository may also have had other branches, though, and your local repository keeps branches which track each of those remote branches, called remote-tracking branches, which you can view using the &lt;code&gt;-r&lt;/code&gt; option to &lt;a href=&quot;git-branch&quot;&gt;git-branch[1]&lt;/a&gt;:</source>
          <target state="translated">복제 할 때 작성된 &quot;마스터&quot;브랜치는 복제 한 저장소에있는 HEAD의 사본입니다. 그러나이 저장소에는 다른 분기가있을 수 있으며 로컬 저장소는 원격 추적 분기라고하는 각 원격 분기를 추적하는 분기를 유지합니다.이 추적은 &lt;code&gt;-r&lt;/code&gt; 옵션을 사용하여 &lt;a href=&quot;git-branch&quot;&gt;git-branch [1]&lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="b0e05ae2162ea2794c2d7383fd67bd0eb622aa45" translate="yes" xml:space="preserve">
          <source>The &quot;name&quot; field is an arbitrary string to describe the command mode. For example, checkout can checkout a branch or an individual file. And these variations typically have different performance characteristics that are not comparable.</source>
          <target state="translated">&quot;이름&quot;필드는 명령 모드를 설명하는 임의의 문자열입니다. 예를 들어, 체크 아웃은 분기 또는 개별 파일을 체크 아웃 할 수 있습니다. 이러한 변형은 일반적으로 비교할 수없는 다른 성능 특성을 가지고 있습니다.</target>
        </trans-unit>
        <trans-unit id="dd5002fa5ace7f79f3506e0a4b77fdeff5bda038" translate="yes" xml:space="preserve">
          <source>The &quot;non-cached&quot; mode takes a different approach, and is potentially the more useful of the two in that what it does can&amp;rsquo;t be emulated with a &lt;code&gt;git write-tree&lt;/code&gt; + &lt;code&gt;git diff-tree&lt;/code&gt;. Thus that&amp;rsquo;s the default mode. The non-cached version asks the question:</source>
          <target state="translated">&quot;캐시되지 않은&quot;모드는 다른 접근 방식을 취하며 &lt;code&gt;git write-tree&lt;/code&gt; + &lt;code&gt;git diff-tree&lt;/code&gt; 로 에뮬레이션 할 수 없다는 점에서 두 가지 중 더 유용합니다 . 이것이 기본 모드입니다. 캐시되지 않은 버전은 다음과 같은 질문을합니다.</target>
        </trans-unit>
        <trans-unit id="fb600e178320a3e93fbf20a6c6f69b12e2843e17" translate="yes" xml:space="preserve">
          <source>The &quot;pull&quot; command thus performs two operations: it fetches changes from a remote branch, then merges them into the current branch.</source>
          <target state="translated">따라서 &quot;pull&quot;명령은 두 가지 작업을 수행합니다. 원격 지점에서 변경 사항을 가져 와서 현재 지점으로 병합합니다.</target>
        </trans-unit>
        <trans-unit id="70b3edc9504f2665b7793306c4b0a620ef20dadb" translate="yes" xml:space="preserve">
          <source>The &quot;remote&quot; repository that is destination of a push operation. This parameter can be either a URL (see the section &lt;a href=&quot;#URLS&quot;&gt;GIT URLS&lt;/a&gt; below) or the name of a remote (see the section &lt;a href=&quot;#REMOTES&quot;&gt;REMOTES&lt;/a&gt; below).</source>
          <target state="translated">푸시 조작의 대상인 &quot;원격&quot;저장소 이 매개 변수는 URL ( 아래 &lt;a href=&quot;#URLS&quot;&gt;GIT URL&lt;/a&gt; 섹션 참조) 또는 리모트 이름 ( 아래 섹션 &lt;a href=&quot;#REMOTES&quot;&gt;REMOTES&lt;/a&gt; 섹션 참조)이 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0610be2d46404a8f9561c2512c45bc2650bc2b77" translate="yes" xml:space="preserve">
          <source>The &quot;remote&quot; repository that is the source of a fetch or pull operation. This parameter can be either a URL (see the section &lt;a href=&quot;#URLS&quot;&gt;GIT URLS&lt;/a&gt; below) or the name of a remote (see the section &lt;a href=&quot;#REMOTES&quot;&gt;REMOTES&lt;/a&gt; below).</source>
          <target state="translated">페치 또는 풀 조작의 소스 인 &quot;원격&quot;저장소. 이 매개 변수는 URL ( 아래 &lt;a href=&quot;#URLS&quot;&gt;GIT URL&lt;/a&gt; 섹션 참조) 또는 리모트 이름 ( 아래 섹션 &lt;a href=&quot;#REMOTES&quot;&gt;REMOTES&lt;/a&gt; 섹션 참조)이 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="672e385879e10047919cb534a388204453fa9b9b" translate="yes" xml:space="preserve">
          <source>The &quot;remote&quot; repository to query. This parameter can be either a URL or the name of a remote (see the GIT URLS and REMOTES sections of &lt;a href=&quot;git-fetch&quot;&gt;git-fetch[1]&lt;/a&gt;).</source>
          <target state="translated">조회 할 &quot;원격&quot;저장소. 이 매개 변수는 URL이거나 원격의 이름 일 수 있습니다 ( &lt;a href=&quot;git-fetch&quot;&gt;git-fetch [1]&lt;/a&gt; 의 GIT URLS 및 REMOTES 섹션 참조 ).</target>
        </trans-unit>
        <trans-unit id="c6967bbb137406cb4cb1860aeca604a66e63b551" translate="yes" xml:space="preserve">
          <source>The &quot;show&quot; subcommand (which is also the default, in the absence of any subcommands) shows the log of the reference provided in the command-line (or &lt;code&gt;HEAD&lt;/code&gt;, by default). The reflog covers all recent actions, and in addition the &lt;code&gt;HEAD&lt;/code&gt; reflog records branch switching. &lt;code&gt;git reflog show&lt;/code&gt; is an alias for &lt;code&gt;git log -g --abbrev-commit
--pretty=oneline&lt;/code&gt;; see &lt;a href=&quot;git-log&quot;&gt;git-log[1]&lt;/a&gt; for more information.</source>
          <target state="translated">&quot;show&quot;하위 명령 (하위 명령이없는 경우 기본값 임)은 명령 줄에 제공된 참조 로그 (또는 기본적으로 &lt;code&gt;HEAD&lt;/code&gt; )를 표시합니다. reflog는 모든 최근 조치를 다루며 &lt;code&gt;HEAD&lt;/code&gt; reflog는 분기 전환을 기록합니다. &lt;code&gt;git reflog show&lt;/code&gt; 는 git log 의 별명입니다. &lt;code&gt;git log -g --abbrev-commit --pretty=oneline&lt;/code&gt; ; 자세한 내용은 &lt;a href=&quot;git-log&quot;&gt;git-log [1]&lt;/a&gt; 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="9f44e4ac17ec1a545f86623659c266196a2646a2" translate="yes" xml:space="preserve">
          <source>The &quot;status&quot; command is a useful way to get a quick summary of the situation:</source>
          <target state="translated">&quot;status&quot;명령은 상황을 빠르게 요약 할 수있는 유용한 방법입니다.</target>
        </trans-unit>
        <trans-unit id="97877392fd9cfcae446bf7fdee6a5be7af0d7e1e" translate="yes" xml:space="preserve">
          <source>The &quot;tar.gz&quot; and &quot;tgz&quot; formats are defined automatically and default to &lt;code&gt;gzip -cn&lt;/code&gt;. You may override them with custom commands.</source>
          <target state="translated">&quot;tar.gz&quot;및 &quot;tgz&quot;형식은 자동으로 정의되며 기본값은 &lt;code&gt;gzip -cn&lt;/code&gt; 입니다. 사용자 정의 명령으로이를 대체 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="de5a671425f0a835fc1aa7cc9c82d529d93b1856" translate="yes" xml:space="preserve">
          <source>The &quot;tree&quot; object here refers to the new state of the tree:</source>
          <target state="translated">여기서 &quot;트리&quot;개체는 트리의 새로운 상태를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="e01253337b76bf7642cbcef035c48eb0188a2f7d" translate="yes" xml:space="preserve">
          <source>The &quot;value&quot; field may be an integer or a string.</source>
          <target state="translated">&quot;값&quot;필드는 정수 또는 문자열 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="38b8f4a1de6f86897b3e2a50acc4b0dda41fe280" translate="yes" xml:space="preserve">
          <source>The &amp;lt;dataref&amp;gt; represents the blob, tree, or commit object at &amp;lt;path&amp;gt; and can be used in later &lt;code&gt;get-mark&lt;/code&gt;, &lt;code&gt;cat-blob&lt;/code&gt;, &lt;code&gt;filemodify&lt;/code&gt;, or &lt;code&gt;ls&lt;/code&gt; commands.</source>
          <target state="translated">&amp;lt;dataref&amp;gt;는 &amp;lt;path&amp;gt;의 blob, tree 또는 commit 객체를 나타내며 나중에 &lt;code&gt;get-mark&lt;/code&gt; , &lt;code&gt;cat-blob&lt;/code&gt; , &lt;code&gt;filemodify&lt;/code&gt; 또는 &lt;code&gt;ls&lt;/code&gt; 명령에서 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="118ecd88d0a05a5c1cb4a877b8fac543b0b9ad8d" translate="yes" xml:space="preserve">
          <source>The &amp;lt;dst&amp;gt; tells which ref on the remote side is updated with this push. Arbitrary expressions cannot be used here, an actual ref must be named. If &lt;code&gt;git push [&amp;lt;repository&amp;gt;]&lt;/code&gt; without any &lt;code&gt;&amp;lt;refspec&amp;gt;&lt;/code&gt; argument is set to update some ref at the destination with &lt;code&gt;&amp;lt;src&amp;gt;&lt;/code&gt; with &lt;code&gt;remote.&amp;lt;repository&amp;gt;.push&lt;/code&gt; configuration variable, &lt;code&gt;:&amp;lt;dst&amp;gt;&lt;/code&gt; part can be omitted&amp;mdash;​such a push will update a ref that &lt;code&gt;&amp;lt;src&amp;gt;&lt;/code&gt; normally updates without any &lt;code&gt;&amp;lt;refspec&amp;gt;&lt;/code&gt; on the command line. Otherwise, missing &lt;code&gt;:&amp;lt;dst&amp;gt;&lt;/code&gt; means to update the same ref as the &lt;code&gt;&amp;lt;src&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">&amp;lt;dst&amp;gt;는이 푸시로 업데이트 된 원격 측의 참조를 알려줍니다. 여기서는 임의의 표현식을 사용할 수 없으며 실제 참조 이름을 지정해야합니다. 만일 &lt;code&gt;git push [&amp;lt;repository&amp;gt;]&lt;/code&gt; 어떤없이 &lt;code&gt;&amp;lt;refspec&amp;gt;&lt;/code&gt; 인수와 목적지 일부 REF를 업데이트하도록 설정 &lt;code&gt;&amp;lt;src&amp;gt;&lt;/code&gt; 와 &lt;code&gt;remote.&amp;lt;repository&amp;gt;.push&lt;/code&gt; 구성 변수 &lt;code&gt;:&amp;lt;dst&amp;gt;&lt;/code&gt; 부분 omitted- 될 수 그러한 push는 &lt;code&gt;&amp;lt;src&amp;gt;&lt;/code&gt; 가 일반적으로 명령 줄에 &lt;code&gt;&amp;lt;refspec&amp;gt;&lt;/code&gt; 없이 업데이트되는 참조를 업데이트합니다 . 그렇지 않으면, 누락 &lt;code&gt;:&amp;lt;dst&amp;gt;&lt;/code&gt; 는 &lt;code&gt;&amp;lt;src&amp;gt;&lt;/code&gt; 와 동일한 참조를 업데이트하는 것을 의미합니다 .</target>
        </trans-unit>
        <trans-unit id="a11f746174b65907575be3c7e94b2869a6db53ed" translate="yes" xml:space="preserve">
          <source>The &amp;lt;feature&amp;gt; part of the command may be any one of the following:</source>
          <target state="translated">명령의 &amp;lt;feature&amp;gt; 부분은 다음 중 하나 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="12c10723a00c71e41369dc4ab439f9bc656fc9a7" translate="yes" xml:space="preserve">
          <source>The &amp;lt;file&amp;gt; list given to the command can be exact pathnames, file glob patterns, or leading directory names. The command removes only the paths that are known to Git. Giving the name of a file that you have not told Git about does not remove that file.</source>
          <target state="translated">명령에 제공된 &amp;lt;file&amp;gt; 목록은 정확한 경로 이름, 파일 glob 패턴 또는 선행 디렉토리 이름 일 수 있습니다. 이 명령은 Git에 알려진 경로 만 제거합니다. Git에 알리지 않은 파일 이름을 제공해도 해당 파일은 제거되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="d9a9d78d51370431396c79c2da7d525a4215ec53" translate="yes" xml:space="preserve">
          <source>The &amp;lt;paths&amp;gt; parameters, when given, are used to limit the diff to the named paths (you can give directory names and get diff for all files under them).</source>
          <target state="translated">&amp;lt;paths&amp;gt; 매개 변수는 주어진 경우 diff를 명명 된 경로로 제한하는 데 사용됩니다 (디렉토리 이름을 지정하고 그 아래의 모든 파일에 대해 diff를 얻을 수 있음).</target>
        </trans-unit>
        <trans-unit id="be0e9224a3c31468000ef31d0ee2d41289501c7f" translate="yes" xml:space="preserve">
          <source>The &amp;lt;src&amp;gt; is often the name of the branch you would want to push, but it can be any arbitrary &quot;SHA-1 expression&quot;, such as &lt;code&gt;master~4&lt;/code&gt; or &lt;code&gt;HEAD&lt;/code&gt; (see &lt;a href=&quot;gitrevisions&quot;&gt;gitrevisions[7]&lt;/a&gt;).</source>
          <target state="translated">&amp;lt;src&amp;gt;는 종종 푸시하려는 브랜치의 이름이지만 &lt;code&gt;master~4&lt;/code&gt; 또는 &lt;code&gt;HEAD&lt;/code&gt; 와 같은 임의의 &quot;SHA-1 표현식&quot;일 수 있습니다 ( &lt;a href=&quot;gitrevisions&quot;&gt;gitrevisions [7]&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="94b79c58bc3ec3bceec3b732165a2a52f94063c6" translate="yes" xml:space="preserve">
          <source>The &amp;lt;type&amp;gt; object &amp;lt;object&amp;gt;, is present in the database but never &lt;code&gt;directly&lt;/code&gt; used. A dangling commit could be a root node.</source>
          <target state="translated">&amp;lt;type&amp;gt; 오브젝트 &amp;lt;object&amp;gt;는 데이터베이스에 있지만 &lt;code&gt;directly&lt;/code&gt; 사용 되지는 않습니다 . 매달려있는 커밋은 루트 노드 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c165697ba8df58634f80c6f82752d5afcdee5578" translate="yes" xml:space="preserve">
          <source>The &amp;lt;type&amp;gt; object &amp;lt;object&amp;gt;, is referred to but isn&amp;rsquo;t present in the database.</source>
          <target state="translated">&amp;lt;type&amp;gt; 객체 &amp;lt;object&amp;gt;은 (는) 데이터베이스에 참조되어 있지만 존재하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="5e6573bf54036812f2655d363c6262b69c0dca40" translate="yes" xml:space="preserve">
          <source>The &amp;lt;type&amp;gt; object &amp;lt;object&amp;gt;, isn&amp;rsquo;t actually referred to directly or indirectly in any of the trees or commits seen. This can mean that there&amp;rsquo;s another root node that you&amp;rsquo;re not specifying or that the tree is corrupt. If you haven&amp;rsquo;t missed a root node then you might as well delete unreachable nodes since they can&amp;rsquo;t be used.</source>
          <target state="translated">&amp;lt;type&amp;gt; 객체 &amp;lt;object&amp;gt;는 실제로 보이는 트리 나 커밋에서 직접 또는 간접적으로 참조되지 않습니다. 이것은 지정하지 않은 또 다른 루트 노드가 있거나 트리가 손상되었음을 의미 할 수 있습니다. 루트 노드를 놓치지 않았다면 도달 할 수없는 노드는 사용할 수 없으므로 삭제할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="afa0888330a84b7e0fff615f1c9b8a57ecf94505" translate="yes" xml:space="preserve">
          <source>The 'git sh-i18n scriptlet is designed to be sourced (using &lt;code&gt;.&lt;/code&gt;) by Git&amp;rsquo;s porcelain programs implemented in shell script. It provides wrappers for the GNU &lt;code&gt;gettext&lt;/code&gt; and &lt;code&gt;eval_gettext&lt;/code&gt; functions accessible through the &lt;code&gt;gettext.sh&lt;/code&gt; script, and provides pass-through fallbacks on systems without GNU gettext.</source>
          <target state="translated">'git sh-i18n 스크립틀릿은 쉘 스크립트로 구현 된 Git의 도자기 프로그램에 의해 ( &lt;code&gt;.&lt;/code&gt; 를 사용하여 ) 제공되도록 설계되었습니다 . &lt;code&gt;gettext.sh&lt;/code&gt; 스크립트를 통해 액세스 할 수 있는 GNU &lt;code&gt;gettext&lt;/code&gt; 및 &lt;code&gt;eval_gettext&lt;/code&gt; 함수에 대한 랩퍼를 제공하고 GNU gettext가 없는 시스템에서 패스 스루 폴백을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="75c51ca5866a2731f86888419b9fb61d16567aec" translate="yes" xml:space="preserve">
          <source>The (fully qualified) refname from which to show notes when showing commit messages. The value of this variable can be set to a glob, in which case notes from all matching refs will be shown. You may also specify this configuration variable several times. A warning will be issued for refs that do not exist, but a glob that does not match any refs is silently ignored.</source>
          <target state="translated">커밋 메시지를 표시 할 때 메모를 표시 할 정규화 된 refname입니다. 이 변수의 값은 glob로 설정 될 수 있으며,이 경우 일치하는 모든 참조의 노트가 표시됩니다. 이 구성 변수를 여러 번 지정할 수도 있습니다. 존재하지 않는 심판에 대해서는 경고가 표시되지만 어떤 심판과도 일치하지 않는 글롭은 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="1e4ce979f13cefaaddaddc6c3ce47e1170286daa" translate="yes" xml:space="preserve">
          <source>The (possibly remote) repository to clone from. See the &lt;a href=&quot;#URLS&quot;&gt;GIT URLS&lt;/a&gt; section below for more information on specifying repositories.</source>
          <target state="translated">복제 할 원격 저장소입니다. 참고 항목 &lt;a href=&quot;#URLS&quot;&gt;GIT 된 URL&lt;/a&gt; 저장소 지정에 대한 자세한 내용은 아래 절을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="0958323d0ba18cc1a0d938e257756d1659d52ec9" translate="yes" xml:space="preserve">
          <source>The --exclude-existing form is a filter that does the inverse. It reads refs from stdin, one ref per line, and shows those that don&amp;rsquo;t exist in the local repository.</source>
          <target state="translated">--exclude-existing 형식은 반대로하는 필터입니다. stdin에서 refs, 한 줄에 하나의 ref를 읽고 로컬 저장소에없는 ref를 표시합니다.</target>
        </trans-unit>
        <trans-unit id="a043107d8410def266c54e81fdffaefcdaf6dd4c" translate="yes" xml:space="preserve">
          <source>The --smtp-server-option option must be repeated for each option you want to pass to the server. Likewise, different lines in the configuration files must be used for each option.</source>
          <target state="translated">서버에 전달하려는 각 옵션에 대해 --smtp-server-option 옵션을 반복해야합니다. 마찬가지로, 각 옵션마다 구성 파일의 다른 행을 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="b478196a2fb02489b622996c5ea9b31713647e4d" translate="yes" xml:space="preserve">
          <source>The .git location may be auto-discovered, or come from &lt;code&gt;$GIT_DIR&lt;/code&gt; environment variable. If the repository is auto discovered via a .git file (e.g. from submodules, or a linked worktree), the .git location would be the final location where the .git directory is, not where the .git file is.</source>
          <target state="translated">.git 위치는 자동 검색되거나 &lt;code&gt;$GIT_DIR&lt;/code&gt; 환경 변수 에서 제공 될 수 있습니다 . .git 파일을 통해 리포지토리가 자동으로 검색되는 경우 (예 : 하위 모듈 또는 연결된 작업 트리에서) .git 위치는 .git 파일이 아닌 .git 디렉토리가있는 최종 위치가됩니다.</target>
        </trans-unit>
        <trans-unit id="489d70f8c8831a28cdf6bb81a4079dab3fec8b7e" translate="yes" xml:space="preserve">
          <source>The 40-hex object name of the object.</source>
          <target state="translated">개체의 40 진수 개체 이름입니다.</target>
        </trans-unit>
        <trans-unit id="edba0bac58d4604af8b0ccc3234ca39328b25c20" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;git-archive&quot;&gt;git-archive[1]&lt;/a&gt; command can create a tar or zip archive from any version of a project; for example:</source>
          <target state="translated">&lt;a href=&quot;git-archive&quot;&gt;자식 아카이브 [1]&lt;/a&gt; 명령은 타르를 생성하거나 프로젝트의 모든 버전에서 보관할 수 지퍼; 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="8ff01ddb94fa5e45588517f77b5eb76be2068bf4" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;git-bisect&quot;&gt;git-bisect[1]&lt;/a&gt; command correctly handles history that includes merge commits. However, when the commit that it finds is a merge commit, the user may need to work harder than usual to figure out why that commit introduced a problem.</source>
          <target state="translated">&lt;a href=&quot;git-bisect&quot;&gt;자식-이등분 [1]&lt;/a&gt; 병합 커밋 명령을 포함하고 정확하게 기록 핸들. 그러나 찾은 커밋이 병합 커밋 인 경우 사용자는 커밋이 문제를 일으킨 이유를 파악하기 위해 평소보다 더 열심히 노력해야 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="a1047413b5c194a852bce97f1a7a5b5c064c8f0a" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;git-cat-file&quot;&gt;git-cat-file[1]&lt;/a&gt; command can show the contents of any object, though the higher-level &lt;a href=&quot;git-show&quot;&gt;git-show[1]&lt;/a&gt; is usually more useful.</source>
          <target state="translated">&lt;a href=&quot;git-cat-file&quot;&gt;자식 고양이 파일 [1]&lt;/a&gt; 높은 수준이지만 명령은 모든 개체의 내용을 표시 할 수 있습니다 &lt;a href=&quot;git-show&quot;&gt;자식 쇼 [1]&lt;/a&gt; 일반적으로 더 유용하다.</target>
        </trans-unit>
        <trans-unit id="0ea75322cb21a3c3c8fac48d1e6228de3fae3cce" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;git-commit-tree&quot;&gt;git-commit-tree[1]&lt;/a&gt; command allows constructing commits with arbitrary parents and trees.</source>
          <target state="translated">&lt;a href=&quot;git-commit-tree&quot;&gt;자식 커밋 트리 [1]&lt;/a&gt; 명령은 임의의 부모와 나무와 커밋을 구성 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="efc26cd7227657520a6926ebb23db38544c357a6" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;git-describe&quot;&gt;git-describe[1]&lt;/a&gt; command does the opposite, naming the revision using a tag on which the given commit is based:</source>
          <target state="translated">&lt;a href=&quot;git-describe&quot;&gt;자식이-설명 [1]&lt;/a&gt; 명령이 주어진 기반 커밋 된 태그를 사용하여 수정 명명 반대을 수행</target>
        </trans-unit>
        <trans-unit id="9903942bbbf43f525c7cf036d25898c86f9d9d7c" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;git-fsck&quot;&gt;git-fsck[1]&lt;/a&gt; command runs a number of self-consistency checks on the repository, and reports on any problems. This may take some time.</source>
          <target state="translated">&lt;a href=&quot;git-fsck&quot;&gt;자식 - fsck를 [1]&lt;/a&gt; 명령은 저장소에 자기 일관성 검사의 숫자를 실행하고, 문제에 대한 보고서. 시간이 좀 걸릴 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ff835519b77a7ea3e8c99474cee535ec38ab3bd6" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;git-fsck&quot;&gt;git-fsck[1]&lt;/a&gt; command will sometimes complain about dangling objects. They are not a problem.</source>
          <target state="translated">&lt;a href=&quot;git-fsck&quot;&gt;자식 - fsck를 [1]&lt;/a&gt; 명령은 때때로 객체를 매달려에 대해 불평 할 것이다. 그들은 문제가되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="d818a9097a56e35195bf0f4a41317be4c1298cc7" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;git-gc&quot;&gt;git-gc[1]&lt;/a&gt; command performs packing, pruning, and more for you, so is normally the only high-level command you need.</source>
          <target state="translated">&lt;a href=&quot;git-gc&quot;&gt;자식-GC [1]&lt;/a&gt; 명령 수행은 포장 치기, 그리고 더 많은 당신을 위해, 그래서 당신이 필요로하는 유일한 높은 수준의 명령이 일반적이다.</target>
        </trans-unit>
        <trans-unit id="7674cbc9fda493edc257e040882a4d3b2fee5da7" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;git-instaweb&quot;&gt;git-instaweb[1]&lt;/a&gt; command provides a simple way to start browsing the repository using gitweb. The default server when using instaweb is lighttpd.</source>
          <target state="translated">&lt;a href=&quot;git-instaweb&quot;&gt;자식-instaweb [1]&lt;/a&gt; 명령 gitweb를 사용하여 저장소를 탐색을 시작하는 간단한 방법을 제공한다. Instaweb을 사용할 때의 기본 서버는 lighttpd입니다.</target>
        </trans-unit>
        <trans-unit id="3d865565a2d1aab8d65d5524c33990e3ecd5eee4" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;git-log&quot;&gt;git-log[1]&lt;/a&gt; and &lt;a href=&quot;gitk&quot;&gt;gitk[1]&lt;/a&gt; commands also provide special help for merges:</source>
          <target state="translated">&lt;a href=&quot;git-log&quot;&gt;자식 로그 [1]&lt;/a&gt; 및 &lt;a href=&quot;gitk&quot;&gt;gitk이 명령은 [1]&lt;/a&gt; 명령은 병합을위한 특별한 도움을 제공 :</target>
        </trans-unit>
        <trans-unit id="869571e8bf360d23843fed69fde509a99aec51ce" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;git-log&quot;&gt;git-log[1]&lt;/a&gt; command can show lists of commits. On its own, it shows all commits reachable from the parent commit; but you can also make more specific requests:</source>
          <target state="translated">&lt;a href=&quot;git-log&quot;&gt;자식 로그 [1]&lt;/a&gt; 명령은 커밋의 목록을 표시 할 수 있습니다. 자체적으로 상위 커밋에서 도달 가능한 모든 커밋을 보여줍니다. 그러나 더 구체적인 요청을 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="49730fd39b9c73a554b2cce254c7d8e26a1047e1" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;git-rev-parse&quot;&gt;git-rev-parse[1]&lt;/a&gt; command is a low-level command that is occasionally useful for translating some name for a commit to the object name for that commit:</source>
          <target state="translated">&lt;a href=&quot;git-rev-parse&quot;&gt;자식 반전 파싱 [1]&lt;/a&gt; 명령 커밋에 대한 오브젝트 명에 커밋위한 몇몇 이름 번역을위한 때때로 유용 로우 레벨 명령이다 :</target>
        </trans-unit>
        <trans-unit id="d0ac1c8438cdf91fddee2ad5a2dd381f720a6756" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;git-submodule&quot;&gt;git-submodule[1]&lt;/a&gt; command is available since Git 1.5.3. Users with Git 1.5.2 can look up the submodule commits in the repository and manually check them out; earlier versions won&amp;rsquo;t recognize the submodules at all.</source>
          <target state="translated">&lt;a href=&quot;git-submodule&quot;&gt;자식 - 서브 모듈 [1]&lt;/a&gt; 명령 힘내 1.5.3 때문에 가능하다. Git 1.5.2 사용자는 저장소에서 서브 모듈 커밋을 찾아 수동으로 체크 아웃 할 수 있습니다. 이전 버전에서는 하위 모듈을 전혀 인식하지 못합니다.</target>
        </trans-unit>
        <trans-unit id="8ffc16af4f4197ccdbaaceb3fe6721dcc4562d83" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;git-update-index&quot;&gt;git-update-index[1]&lt;/a&gt; command updates the index with information from the working directory. You generally update the index information by just specifying the filename you want to update, like so:</source>
          <target state="translated">&lt;a href=&quot;git-update-index&quot;&gt;자식 업데이트 인덱스 [1]&lt;/a&gt; 명령은 작업 디렉토리 정보로 인덱스를 업데이트합니다. 일반적으로 업데이트하려는 파일 이름을 지정하여 색인 정보를 업데이트합니다.</target>
        </trans-unit>
        <trans-unit id="20874526426e66810d4174f5227a378a8de7e91c" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;https://github.com/newren/git-filter-repo/&quot;&gt;git filter-repo&lt;/a&gt; tool is an alternative to git-filter-branch which does not suffer from these performance problems or the safety problems (mentioned below). For those with existing tooling which relies upon git-filter-branch, &lt;code&gt;git repo-filter&lt;/code&gt; also provides &lt;a href=&quot;https://github.com/newren/git-filter-repo/blob/master/contrib/filter-repo-demos/filter-lamely&quot;&gt;filter-lamely&lt;/a&gt;, a drop-in git-filter-branch replacement (with a few caveats). While filter-lamely suffers from all the same safety issues as git-filter-branch, it at least ameliorates the performance issues a little.</source>
          <target state="translated">&lt;a href=&quot;https://github.com/newren/git-filter-repo/&quot;&gt;자식 필터의 repo&lt;/a&gt; 도구는 이러한 성능 문제 나 안전 문제 (아래에서 설명)으로 고생하지 않는 자식 필터 - 지점의 대안입니다. 자식 필터 - 지점에 의존 기존 공구와 사람들을 위해, &lt;code&gt;git repo-filter&lt;/code&gt; 또한 제공하는 &lt;a href=&quot;https://github.com/newren/git-filter-repo/blob/master/contrib/filter-repo-demos/filter-lamely&quot;&gt;필터 lamely&lt;/a&gt; , (몇 가지주의와) 자식 필터 - 지점 드롭 인 교체. 필터는 거의 git-filter-branch와 동일한 모든 안전 문제를 겪지 만 최소한 성능 문제를 약간 개선합니다.</target>
        </trans-unit>
        <trans-unit id="ad21d56fce6cdd39ef4f92ed0708902d059eaafc" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;user-manual&quot;&gt;Git User&amp;rsquo;s Manual&lt;/a&gt; provides a more comprehensive introduction to Git.</source>
          <target state="translated">&lt;a href=&quot;user-manual&quot;&gt;망할 놈의 사용 설명서는&lt;/a&gt; 힘내에 대한보다 포괄적 인 소개를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="89c784f1b1d17488cfe361d4581fd69d6d34303d" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;user-manual#git-concepts&quot;&gt;Git concepts chapter of the user-manual&lt;/a&gt; and &lt;a href=&quot;gitcore-tutorial&quot;&gt;gitcore-tutorial[7]&lt;/a&gt; both provide introductions to the underlying Git architecture.</source>
          <target state="translated">&lt;a href=&quot;user-manual#git-concepts&quot;&gt;사용자 매뉴얼&lt;/a&gt; 및 &lt;a href=&quot;gitcore-tutorial&quot;&gt;gitcore-tutorial [7]&lt;/a&gt; 의 Git 개념 장은 기본 Git 아키텍처에 대한 소개를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="5f7a0a0ce9975de955e97678d53d0386ebf8b091" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;$GIT_DIR/info/sparse-checkout&lt;/code&gt; file is used to define the skip-worktree reference bitmap. When Git updates the working directory, it updates the skip-worktree bits in the index based on this file. The files matching the patterns in the file will appear in the working directory, and the rest will not.</source>
          <target state="translated">&lt;code&gt;$GIT_DIR/info/sparse-checkout&lt;/code&gt; 파일은 스킵-worktree 참조 비트 맵을 정의하는 데 사용됩니다. Git은 작업 디렉토리를 업데이트 할 때이 파일을 기반으로 인덱스의 skip-worktree 비트를 업데이트합니다. 파일의 패턴과 일치하는 파일이 작업 디렉토리에 나타나고 나머지는 그렇지 않습니다.</target>
        </trans-unit>
        <trans-unit id="18927ccc4077efc9fa00280f487bf7ea52068011" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&amp;lt;any&amp;gt;&lt;/code&gt; part of the command may contain any sequence of bytes that does not contain &lt;code&gt;LF&lt;/code&gt;. The &lt;code&gt;LF&lt;/code&gt; after the command is optional. Callers may wish to process the output through a tool such as sed to remove the leading part of the line, for example:</source>
          <target state="translated">명령 의 &lt;code&gt;&amp;lt;any&amp;gt;&lt;/code&gt; 부분에는 &lt;code&gt;LF&lt;/code&gt; 가 포함되지 않은 바이트 시퀀스가 ​​포함될 수 있습니다 . &lt;code&gt;LF&lt;/code&gt; 명령 후에는 선택 사항입니다. 발신자는 sed와 같은 도구를 통해 출력을 처리하여 회선의 앞 부분을 제거 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="38ecaff497a30523addb0d68ac2f3ff7d62121ca" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&amp;lt;dataref&amp;gt;&lt;/code&gt; can be a mark reference (&lt;code&gt;:&amp;lt;idnum&amp;gt;&lt;/code&gt;) or the full 40-byte SHA-1 of a Git tag, commit, or tree object, preexisting or waiting to be written. The path is relative to the top level of the tree named by &lt;code&gt;&amp;lt;dataref&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&amp;lt;dataref&amp;gt;&lt;/code&gt; 일 수있는 기준 마크 ( &lt;code&gt;:&amp;lt;idnum&amp;gt;&lt;/code&gt; ) 또는 전체 40 바이트의 SHA-1 힘내 태그가 이미 존재하거나 기입하도록 대기 커밋 또는 트리 오브젝트. 경로는 &lt;code&gt;&amp;lt;dataref&amp;gt;&lt;/code&gt; 로 명명 된 트리의 최상위 레벨을 기준으로합니다 .</target>
        </trans-unit>
        <trans-unit id="df9429d81584e26f1a55e7eff78d6952383c6adf" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&amp;lt;dataref&amp;gt;&lt;/code&gt; can be either a mark reference (&lt;code&gt;:&amp;lt;idnum&amp;gt;&lt;/code&gt;) set previously or a full 40-byte SHA-1 of a Git blob, preexisting or ready to be written.</source>
          <target state="translated">&lt;code&gt;&amp;lt;dataref&amp;gt;&lt;/code&gt; 일 수있는 기준 마크 중 ( &lt;code&gt;:&amp;lt;idnum&amp;gt;&lt;/code&gt; ) 또는 기존 기록 할 준비가 미리 설정하거나 전체 40 바이트의 SHA-1 힘내의 블롭.</target>
        </trans-unit>
        <trans-unit id="d38490ce2af2d9b14b21e7e25c13d2a1c79c408e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&amp;lt;option&amp;gt;&lt;/code&gt; part of the command may contain any of the options listed in the OPTIONS section that do not change import semantics, without the leading &lt;code&gt;--&lt;/code&gt; and is treated in the same way.</source>
          <target state="translated">&lt;code&gt;&amp;lt;option&amp;gt;&lt;/code&gt; 명령의 일부 선도하지 않고, 수입의 의미를 변경하지 않는 옵션 섹션에 나열된 옵션 중 하나를 포함 할 수있다 &lt;code&gt;--&lt;/code&gt; 과 같은 방식으로 처리됩니다.</target>
        </trans-unit>
        <trans-unit id="73cfe0e2f7b7cccff976b7e355044194793ceedb" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&amp;lt;pushurl&amp;gt;&lt;/code&gt; is used for pushes only. It is optional and defaults to &lt;code&gt;&amp;lt;url&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">이 &lt;code&gt;&amp;lt;pushurl&amp;gt;&lt;/code&gt; 만 밀어 사용된다. 선택 사항이며 기본값은 &lt;code&gt;&amp;lt;url&amp;gt;&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="226bf97de37dae89426f4bcaf2c8464c2aaac4ce" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&amp;lt;rev&amp;gt;^-[&amp;lt;n&amp;gt;]&lt;/code&gt; notation includes &lt;code&gt;&amp;lt;rev&amp;gt;&lt;/code&gt; but excludes the &amp;lt;n&amp;gt;th parent (i.e. a shorthand for &lt;code&gt;&amp;lt;rev&amp;gt;^&amp;lt;n&amp;gt;..&amp;lt;rev&amp;gt;&lt;/code&gt;), with &lt;code&gt;&amp;lt;n&amp;gt;&lt;/code&gt; = 1 if not given. This is typically useful for merge commits where you can just pass &lt;code&gt;&amp;lt;commit&amp;gt;^-&lt;/code&gt; to get all the commits in the branch that was merged in merge commit &lt;code&gt;&amp;lt;commit&amp;gt;&lt;/code&gt; (including &lt;code&gt;&amp;lt;commit&amp;gt;&lt;/code&gt; itself).</source>
          <target state="translated">&lt;code&gt;&amp;lt;rev&amp;gt;^-[&amp;lt;n&amp;gt;]&lt;/code&gt; 표기 포함 &lt;code&gt;&amp;lt;rev&amp;gt;&lt;/code&gt; 대상이지만 &amp;lt;N&amp;gt; 제 부모 (즉, 쉬트를위한 &lt;code&gt;&amp;lt;rev&amp;gt;^&amp;lt;n&amp;gt;..&amp;lt;rev&amp;gt;&lt;/code&gt; 로) &lt;code&gt;&amp;lt;n&amp;gt;&lt;/code&gt; = 1이면 주어지지 않았습니다. 이것은 일반적으로 &lt;code&gt;&amp;lt;commit&amp;gt;^-&lt;/code&gt; 를 전달 하여 병합 커밋 &lt;code&gt;&amp;lt;commit&amp;gt;&lt;/code&gt; 에 병합 된 분기의 모든 커밋 ( &lt;code&gt;&amp;lt;commit&amp;gt;&lt;/code&gt; 자체 포함) 을 가져올 수있는 병합 커밋에 유용합니다 .</target>
        </trans-unit>
        <trans-unit id="382c52b269a126869d3f5e611e50db349c01a555" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;--&lt;/code&gt; is just a good idea when you know the rest will be filenames; it will prevent problems with a filename of, for example, &lt;code&gt;-a&lt;/code&gt;. Using &lt;code&gt;--&lt;/code&gt; is probably a good policy in scripts.</source>
          <target state="translated">은 &lt;code&gt;--&lt;/code&gt; 당신이 나머지 파일 이름이 될 것입니다 알고 그냥 좋은 아이디어이다; 예를 들어 &lt;code&gt;-a&lt;/code&gt; 와 같은 파일 이름 문제를 방지합니다 . &lt;code&gt;--&lt;/code&gt; 사용 하는 것이 스크립트에서 좋은 정책 일 것입니다.</target>
        </trans-unit>
        <trans-unit id="1a7c2f7d5b7ec8386e86076d812d974232af3082" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;--cached&lt;/code&gt; option is used to ask a command that usually works on files in the working tree to &lt;strong&gt;only&lt;/strong&gt; work with the index. For example, &lt;code&gt;git grep&lt;/code&gt;, when used without a commit to specify from which commit to look for strings in, usually works on files in the working tree, but with the &lt;code&gt;--cached&lt;/code&gt; option, it looks for strings in the index.</source>
          <target state="translated">&lt;code&gt;--cached&lt;/code&gt; 옵션은 일반적으로 작업 트리에있는 파일에 작동하는 명령을 요청하는 데 사용됩니다 &lt;strong&gt;에만&lt;/strong&gt; 인덱스와 함께 일을. 예를 들어, &lt;code&gt;git grep&lt;/code&gt; 은 커밋없이 문자열을 찾는 커밋을 지정하면 일반적으로 작업 트리의 파일에서 작동하지만 &lt;code&gt;--cached&lt;/code&gt; 옵션을 사용하면 인덱스에서 문자열을 찾습니다.</target>
        </trans-unit>
        <trans-unit id="93eb90d6c0bfdb16dcadbf4c72d38d80f8bf4451" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;--dry-run&lt;/code&gt; option can be used to obtain a summary of what is included by any of the above for the next commit by giving the same set of parameters (options and paths).</source>
          <target state="translated">&lt;code&gt;--dry-run&lt;/code&gt; 옵션은 다음 매개 변수 (옵션 및 경로)의 동일한 세트를 제공하여 커밋 위의 모든으로 무엇이 포함되어 있는지의 요약 정보를 얻을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="45e26263ba79c46b47e35a4fe67d4d8f33b37e0e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;--env-filter&lt;/code&gt; option can be used to modify committer and/or author identity. For example, if you found out that your commits have the wrong identity due to a misconfigured user.email, you can make a correction, before publishing the project, like this:</source>
          <target state="translated">&lt;code&gt;--env-filter&lt;/code&gt; 옵션은 커미터 및 / 또는 저자의 정체성을 수정하는 데 사용할 수 있습니다. 예를 들어, 잘못 구성된 user.email로 인해 커밋에 잘못된 ID가있는 것을 발견 한 경우 프로젝트를 게시하기 전에 다음과 같이 수정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b4b7635118d0a90fb277012f2d96d5181b61e4f5" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;--index&lt;/code&gt; option is used to ask a command that usually works on files in the working tree to &lt;strong&gt;also&lt;/strong&gt; affect the index. For example, &lt;code&gt;git stash apply&lt;/code&gt; usually merges changes recorded in a stash entry to the working tree, but with the &lt;code&gt;--index&lt;/code&gt; option, it also merges changes to the index as well.</source>
          <target state="translated">&lt;code&gt;--index&lt;/code&gt; 옵션에 있음은 일반적으로 작업 트리에있는 파일에 작동하는 명령을 요청하는 데 사용됩니다 &lt;strong&gt;또한&lt;/strong&gt; 인덱스에 영향을 미칠합니다. 예를 들어, &lt;code&gt;git stash apply&lt;/code&gt; 는 일반적으로 숨김 항목에 기록 된 변경 사항을 작업 트리에 병합 하지만 &lt;code&gt;--index&lt;/code&gt; 옵션을 사용하면 변경 사항도 색인에 병합합니다.</target>
        </trans-unit>
        <trans-unit id="f5e672ca7275921f27bc57abfee8498efa38d837" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;--numstat&lt;/code&gt; option gives the diffstat(1) information but is designed for easier machine consumption. An entry in &lt;code&gt;--numstat&lt;/code&gt; output looks like this:</source>
          <target state="translated">&lt;code&gt;--numstat&lt;/code&gt; 옵션은 diffstat (1) 정보를 제공하지만, 쉽게 기계 소비를 위해 설계되었습니다. &lt;code&gt;--numstat&lt;/code&gt; 출력 의 항목은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="824224d8413c92cfa07b10a7d5f109653a254225" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;--patch&lt;/code&gt; option implies &lt;code&gt;--keep-index&lt;/code&gt;. You can use &lt;code&gt;--no-keep-index&lt;/code&gt; to override this.</source>
          <target state="translated">&lt;code&gt;--patch&lt;/code&gt; 옵션은 의미 &lt;code&gt;--keep-index&lt;/code&gt; . 당신은 사용할 수 있습니다 &lt;code&gt;--no-keep-index&lt;/code&gt; 이 메소드를 오버라이드 (override) 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="cd53bf0606653a9e38fc2f67928f722d519b8437" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;--prune-tags&lt;/code&gt; option is equivalent to having &lt;code&gt;refs/tags/*:refs/tags/*&lt;/code&gt; declared in the refspecs of the remote. This can lead to some seemingly strange interactions:</source>
          <target state="translated">&lt;code&gt;--prune-tags&lt;/code&gt; 옵션은 리모컨 의 참조 사양에 &lt;code&gt;refs/tags/*:refs/tags/*&lt;/code&gt; 가 선언되어있는 것과 같습니다. 이것은 겉보기에 이상한 상호 작용으로 이어질 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="eedbb7a82985c4671f5041c09553972a9225fc17" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;--rebase-merges&lt;/code&gt; mode is similar in spirit to the deprecated &lt;code&gt;--preserve-merges&lt;/code&gt; but works with interactive rebases, where commits can be reordered, inserted and dropped at will.</source>
          <target state="translated">&lt;code&gt;--rebase-merges&lt;/code&gt; 모드는 사용되지 않는 정신에는 변함이있다 &lt;code&gt;--preserve-merges&lt;/code&gt; 하지만 커밋이 순서가 삽입 의지에 드롭 할 수있는 대화 형 rebases, 작동합니다.</target>
        </trans-unit>
        <trans-unit id="8061f1189be4b513311a10997c4e6fc449baeaf4" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;--simplify-by-decoration&lt;/code&gt; option allows you to view only the big picture of the topology of the history, by omitting commits that are not referenced by tags. Commits are marked as !TREESAME (in other words, kept after history simplification rules described above) if (1) they are referenced by tags, or (2) they change the contents of the paths given on the command line. All other commits are marked as TREESAME (subject to be simplified away).</source>
          <target state="translated">&lt;code&gt;--simplify-by-decoration&lt;/code&gt; 옵션을 사용하면 태그에 의해 참조되지 않는 커밋을 생략하여, 역사의 토폴로지의 큰 그림을 볼 수 있습니다. 커밋은 (1) 태그로 참조되거나 (2) 명령 줄에 지정된 경로의 내용을 변경하는 경우! TREESAME (즉, 위에서 설명한 기록 단순화 규칙 후에 유지됨)로 표시됩니다. 다른 모든 커밋은 TREESAME로 표시됩니다 (간단히 삭제해야 함).</target>
        </trans-unit>
        <trans-unit id="16b8753fdc735c82bb8e4b4e3197e33fe132b018" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;--summary&lt;/code&gt; option describes newly added, deleted, renamed and copied files. The &lt;code&gt;--stat&lt;/code&gt; option adds diffstat(1) graph to the output. These options can be combined with other options, such as &lt;code&gt;-p&lt;/code&gt;, and are meant for human consumption.</source>
          <target state="translated">&lt;code&gt;--summary&lt;/code&gt; 옵션은 새로 추가, 삭제, 파일 이름 및 복사에 대해 설명합니다. &lt;code&gt;--stat&lt;/code&gt; 옵션 출력 diffstat (1)의 그래프를 추가한다. 이러한 옵션은 &lt;code&gt;-p&lt;/code&gt; 와 같은 다른 옵션과 결합하여 사람이 소비 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2fb3a538afbb18a8ca912f0cecf9a31cb6701775" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;--type=&amp;lt;type&amp;gt;&lt;/code&gt; option instructs &lt;code&gt;git config&lt;/code&gt; to ensure that incoming and outgoing values are canonicalize-able under the given &amp;lt;type&amp;gt;. If no &lt;code&gt;--type=&amp;lt;type&amp;gt;&lt;/code&gt; is given, no canonicalization will be performed. Callers may unset an existing &lt;code&gt;--type&lt;/code&gt; specifier with &lt;code&gt;--no-type&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;--type=&amp;lt;type&amp;gt;&lt;/code&gt; 옵션을 지시 &lt;code&gt;git config&lt;/code&gt; 이 수신 및 발신 값이 주어진 &amp;lt;형&amp;gt;에서-수를 정규화를하고 있는지 확인할 수도 있습니다. 어떤 경우 &lt;code&gt;--type=&amp;lt;type&amp;gt;&lt;/code&gt; 주어지지 않는 어떤 정규화가 수행되지 않는다. 호출자는 &lt;code&gt;--no-type&lt;/code&gt; 으로 기존 &lt;code&gt;--type&lt;/code&gt; 지정자를 설정 해제 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="0c9422891d35819a54a8ef0ba6d7016d122547ff" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;-M&lt;/code&gt; and &lt;code&gt;-C&lt;/code&gt; options require O(n^2) processing time where n is the number of potential rename/copy targets. This option prevents rename/copy detection from running if the number of rename/copy targets exceeds the specified number.</source>
          <target state="translated">&lt;code&gt;-M&lt;/code&gt; 및 &lt;code&gt;-C&lt;/code&gt; 옵션 타겟 복사 / N 전위 바꾸기의 수이고 처리 시간 O (N ^ 2)을 필요로한다. 이 옵션은 이름 바꾸기 / 복사 대상 수가 지정된 수를 초과하는 경우 이름 바꾸기 / 복사 감지가 실행되지 않도록합니다.</target>
        </trans-unit>
        <trans-unit id="73fff0c26b859dbfe915afb814a50fa7bc541c41" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;-c&lt;/code&gt; and &lt;code&gt;-C&lt;/code&gt; options have the exact same semantics as &lt;code&gt;-m&lt;/code&gt; and &lt;code&gt;-M&lt;/code&gt;, except instead of the branch being renamed it along with its config and reflog will be copied to a new name.</source>
          <target state="translated">&lt;code&gt;-c&lt;/code&gt; 및 &lt;code&gt;-C&lt;/code&gt; 옵션과 동일한 의미가 &lt;code&gt;-m&lt;/code&gt; 과 &lt;code&gt;-M&lt;/code&gt; 을 새 이름으로 복사됩니다의 설정 및 reflog와 함께 이름을 변경 분기되는 대신 제외시켰다.</target>
        </trans-unit>
        <trans-unit id="89a7df63322c3f15984d17c0e2db0a5d71e95aa3" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;-m&lt;/code&gt; and &lt;code&gt;-F&lt;/code&gt; options can be given any number of times, in any order. The commit log message will be composed in the order in which the options are given.</source>
          <target state="translated">&lt;code&gt;-m&lt;/code&gt; 및 &lt;code&gt;-F&lt;/code&gt; 옵션은 임의의 순서로, 여러 번을 부여 할 수 있습니다. 커밋 로그 메시지는 옵션이 주어진 순서대로 구성됩니다.</target>
        </trans-unit>
        <trans-unit id="f4502e6a26132411ed2e9fd1c43849a487e5e5a8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;-m&lt;/code&gt; option is mutually exclusive with &lt;code&gt;-c&lt;/code&gt;, &lt;code&gt;-C&lt;/code&gt;, and &lt;code&gt;-F&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;-m&lt;/code&gt; 옵션과 함께 사용할 수있다 &lt;code&gt;-c&lt;/code&gt; , &lt;code&gt;-C&lt;/code&gt; , 및 &lt;code&gt;-F&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="38779d2c15d6e090718b82e6af2f8c359ec976d3" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;.git-credentials&lt;/code&gt; file is stored in plaintext. Each credential is stored on its own line as a URL like:</source>
          <target state="translated">&lt;code&gt;.git-credentials&lt;/code&gt; 파일은 일반 텍스트로 저장됩니다. 각 자격 증명은 다음과 같은 URL로 자체 줄에 저장됩니다.</target>
        </trans-unit>
        <trans-unit id="905c63d14654cde00625cb5e82c7038bc34ea94e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;.gitmodules&lt;/code&gt; file inside the superproject. A project usually uses this file to suggest defaults for the upstream collection of repositories for the mapping that is required between a submodule&amp;rsquo;s name and its path.</source>
          <target state="translated">&lt;code&gt;.gitmodules&lt;/code&gt; 는 superproject 내부 파일. 프로젝트는 일반적으로이 파일을 사용하여 서브 모듈의 이름과 경로 사이에 필요한 매핑의 업스트림 리포지토리 모음에 대한 기본값을 제안합니다.</target>
        </trans-unit>
        <trans-unit id="0bb4fdb786947245a90430b5697a0e9422df1d21" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;.gitmodules&lt;/code&gt; file, located in the top-level directory of a Git working tree, is a text file with a syntax matching the requirements of &lt;a href=&quot;git-config&quot;&gt;git-config[1]&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;.gitmodules&lt;/code&gt; 의 망할 놈의 작업 트리의 최상위 디렉토리에있는 파일의 요구 사항과 일치하는 구문을 사용하여 텍스트 파일입니다 &lt;a href=&quot;git-config&quot;&gt;자식-설정 [1]을&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="d5324d8792f18dd9ac59490b336e09b1bd43353e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;.mailmap&lt;/code&gt; feature is used to coalesce together commits by the same person in the shortlog, where their name and/or email address was spelled differently.</source>
          <target state="translated">&lt;code&gt;.mailmap&lt;/code&gt; 기능은 자신의 이름 및 / 또는 이메일 주소가 다르게 철자 된 shortlog에서 같은 사람에 의해 병합 함께 커밋하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="73c3a5a96a8a6a48d412facd438733454a4a63a1" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;CHERRY_PICK_HEAD&lt;/code&gt; ref is set to point at the commit that introduced the change that is difficult to apply.</source>
          <target state="translated">&lt;code&gt;CHERRY_PICK_HEAD&lt;/code&gt; 의 심판을 가리 키도록 설정되어 적용하기 어려운 변화를 도입하는 것이 커밋합니다.</target>
        </trans-unit>
        <trans-unit id="df208c183263acdaf73c0a978db9f5c35380bc6b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;GIT_AUTHOR_DATE&lt;/code&gt;, &lt;code&gt;GIT_COMMITTER_DATE&lt;/code&gt; environment variables and the &lt;code&gt;--date&lt;/code&gt; option support the following date formats:</source>
          <target state="translated">&lt;code&gt;GIT_AUTHOR_DATE&lt;/code&gt; , &lt;code&gt;GIT_COMMITTER_DATE&lt;/code&gt; 의 환경 변수와 &lt;code&gt;--date&lt;/code&gt; 옵션 지원 다음과 같은 날짜 형식 :</target>
        </trans-unit>
        <trans-unit id="ad08232602558aa9979e8ccc7bf4df9612b12ec8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;GIT_AUTHOR_DATE&lt;/code&gt;, &lt;code&gt;GIT_COMMITTER_DATE&lt;/code&gt; environment variables support the following date formats:</source>
          <target state="translated">&lt;code&gt;GIT_AUTHOR_DATE&lt;/code&gt; , &lt;code&gt;GIT_COMMITTER_DATE&lt;/code&gt; 의 환경 변수는 다음과 같은 날짜 형식을 지원합니다 :</target>
        </trans-unit>
        <trans-unit id="9c24e5e1da9f8726ec7abe4516a017b9495c2fe3" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;GIT_HTTP_EXPORT_ALL&lt;/code&gt; environmental variable may be passed to &lt;code&gt;git-http-backend&lt;/code&gt; to bypass the check for the &quot;git-daemon-export-ok&quot; file in each repository before allowing export of that repository.</source>
          <target state="translated">&lt;code&gt;GIT_HTTP_EXPORT_ALL&lt;/code&gt; 환경 변수에 전달 될 수 &lt;code&gt;git-http-backend&lt;/code&gt; 그 저장소의 수출을 허용하기 전에 각 저장소에 &quot;자식 - 데몬 - 수출 - 확인&quot;파일에 대한 검사 우회.</target>
        </trans-unit>
        <trans-unit id="387cfeb550226cfd9e601b1b72a83920c3f36040" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;GIT_HTTP_MAX_REQUEST_BUFFER&lt;/code&gt; environment variable (or the &lt;code&gt;http.maxRequestBuffer&lt;/code&gt; config variable) may be set to change the largest ref negotiation request that git will handle during a fetch; any fetch requiring a larger buffer will not succeed. This value should not normally need to be changed, but may be helpful if you are fetching from a repository with an extremely large number of refs. The value can be specified with a unit (e.g., &lt;code&gt;100M&lt;/code&gt; for 100 megabytes). The default is 10 megabytes.</source>
          <target state="translated">&lt;code&gt;GIT_HTTP_MAX_REQUEST_BUFFER&lt;/code&gt; 의 환경 변수 (또는 &lt;code&gt;http.maxRequestBuffer&lt;/code&gt; 설정 변수) 자식은 인출 중에 처리하는 것이 가장 REF 협상 요청을 변경하도록 설정 될 수있다; 더 큰 버퍼를 요구하는 페치는 성공하지 못합니다. 이 값은 일반적으로 변경하지 않아도되지만 참조 수가 많은 리포지토리에서 가져 오는 경우 유용 할 수 있습니다. 값은 단위로 지정할 수 있습니다 (예 : &lt;code&gt;100M&lt;/code&gt; B의 경우 100M ). 기본값은 10MB입니다.</target>
        </trans-unit>
        <trans-unit id="166eca4501cd90cd3b21f8df969c5ee397d12242" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;GIT_NO_REPLACE_OBJECTS&lt;/code&gt; environment variable can be set to achieve the same effect as the &lt;code&gt;--no-replace-objects&lt;/code&gt; option.</source>
          <target state="translated">&lt;code&gt;GIT_NO_REPLACE_OBJECTS&lt;/code&gt; 의 환경 변수는 동일한 효과를 달성하기 위해 설정 될 수있다 &lt;code&gt;--no-replace-objects&lt;/code&gt; 옵션.</target>
        </trans-unit>
        <trans-unit id="8bee9745a8d6377da5f35089625008b4042f0f35" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;GIT_PUSH_CERT*&lt;/code&gt; environment variables can be inspected, just as in &lt;code&gt;pre-receive&lt;/code&gt; hook, after accepting a signed push.</source>
          <target state="translated">&lt;code&gt;GIT_PUSH_CERT*&lt;/code&gt; 환경 변수는 단지 같이 검사 될 수있는 &lt;code&gt;pre-receive&lt;/code&gt; 서명 푸시 접수 후, 후크.</target>
        </trans-unit>
        <trans-unit id="8bc6550bd201f7a8ce8611abf35f278e4b89d03c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;HEAD&lt;/code&gt; pointer stays the same.</source>
          <target state="translated">&lt;code&gt;HEAD&lt;/code&gt; 의 포인터는 동일하게 유지됩니다.</target>
        </trans-unit>
        <trans-unit id="652c0cf20ffd72216eb399a1f559569365b85933" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;LF&lt;/code&gt; after &lt;code&gt;&amp;lt;delim&amp;gt; LF&lt;/code&gt; is optional (it used to be required).</source>
          <target state="translated">&lt;code&gt;LF&lt;/code&gt; 후 &lt;code&gt;&amp;lt;delim&amp;gt; LF&lt;/code&gt; 선택적이며 (이것은 필요에 사용됨).</target>
        </trans-unit>
        <trans-unit id="c1bff9f88ec1fe482fd273291dfad27de492749b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;LF&lt;/code&gt; after &lt;code&gt;&amp;lt;raw&amp;gt;&lt;/code&gt; is optional (it used to be required) but recommended. Always including it makes debugging a fast-import stream easier as the next command always starts in column 0 of the next line, even if &lt;code&gt;&amp;lt;raw&amp;gt;&lt;/code&gt; did not end with an &lt;code&gt;LF&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&amp;lt;raw&amp;gt;&lt;/code&gt; 이후 의 &lt;code&gt;LF&lt;/code&gt; 는 선택 사항이지만 (필요 했음) 권장됩니다. &lt;code&gt;&amp;lt;raw&amp;gt;&lt;/code&gt; 가 &lt;code&gt;LF&lt;/code&gt; 로 끝나지 않았어도 다음 명령이 항상 다음 행의 0 열에서 시작되므로 항상이를 포함하면 빠른 가져 오기 스트림 디버깅이 쉬워집니다 .</target>
        </trans-unit>
        <trans-unit id="ec7a854b1a4c70ca562f0584186eed412906ec8d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;LF&lt;/code&gt; after the command is optional (it used to be required).</source>
          <target state="translated">명령 뒤 의 &lt;code&gt;LF&lt;/code&gt; 는 선택 사항입니다 (필요 했음).</target>
        </trans-unit>
        <trans-unit id="9a136595a2c2895a25e4571b5fe242dd49c2174e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;LF&lt;/code&gt; after the command is optional (it used to be required). Note that for reasons of backward compatibility, if the commit ends with a &lt;code&gt;data&lt;/code&gt; command (i.e. it has no &lt;code&gt;from&lt;/code&gt;, &lt;code&gt;merge&lt;/code&gt;, &lt;code&gt;filemodify&lt;/code&gt;, &lt;code&gt;filedelete&lt;/code&gt;, &lt;code&gt;filecopy&lt;/code&gt;, &lt;code&gt;filerename&lt;/code&gt;, &lt;code&gt;filedeleteall&lt;/code&gt; or &lt;code&gt;notemodify&lt;/code&gt; commands) then two &lt;code&gt;LF&lt;/code&gt; commands may appear at the end of the command instead of just one.</source>
          <target state="translated">명령 뒤 의 &lt;code&gt;LF&lt;/code&gt; 는 선택 사항입니다 (필요 했음). 이전 버전과의 호환성을 위해 커밋이 &lt;code&gt;data&lt;/code&gt; 명령으로 끝나는 경우 (즉 , &lt;code&gt;from&lt;/code&gt; , &lt;code&gt;merge&lt;/code&gt; , &lt;code&gt;filemodify&lt;/code&gt; , &lt;code&gt;filedelete&lt;/code&gt; , &lt;code&gt;filecopy&lt;/code&gt; , &lt;code&gt;filerename&lt;/code&gt; , &lt;code&gt;filedeleteall&lt;/code&gt; 또는 &lt;code&gt;notemodify&lt;/code&gt; 명령이없는 경우) 명령 끝에 두 개의 &lt;code&gt;LF&lt;/code&gt; 명령이 나타날 수 있습니다. 하나 대신에.</target>
        </trans-unit>
        <trans-unit id="6afb1837ee3e8f65249dcb4905156711b603dd19" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;MERGE_HEAD&lt;/code&gt; ref is set to point to the other branch head.</source>
          <target state="translated">&lt;code&gt;MERGE_HEAD&lt;/code&gt; 의 심판이 다른 지점 머리에 포인트로 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="4dcd07a8427d3cae73e7340717a2be5da78b122e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;^0&lt;/code&gt; suffix is necessary as fast-import does not permit a branch to start from itself, and the branch is created in memory before the &lt;code&gt;from&lt;/code&gt; command is even read from the input. Adding &lt;code&gt;^0&lt;/code&gt; will force fast-import to resolve the commit through Git&amp;rsquo;s revision parsing library, rather than its internal branch table, thereby loading in the existing value of the branch.</source>
          <target state="translated">&lt;code&gt;^0&lt;/code&gt; 접미사는 빠른 가져 오기 자체에서 시작하는 지점을 허용하지 않는 한 필요하고, 전 분기 메모리에 생성 &lt;code&gt;from&lt;/code&gt; 명령도 입력에서 읽습니다. &lt;code&gt;^0&lt;/code&gt; 을 추가하면 내부 가져 오기 테이블이 아닌 Git의 개정 구문 분석 라이브러리를 통해 커밋을 해결하기 위해 빠른 가져 오기를 강제 실행하여 기존 분기 값으로로드합니다.</target>
        </trans-unit>
        <trans-unit id="675155c0bc0c9682b02ea7dc72c6fe717f8d57df" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;^r1 r2&lt;/code&gt; set operation appears so often that there is a shorthand for it. When you have two commits &lt;code&gt;r1&lt;/code&gt; and &lt;code&gt;r2&lt;/code&gt; (named according to the syntax explained in SPECIFYING REVISIONS above), you can ask for commits that are reachable from r2 excluding those that are reachable from r1 by &lt;code&gt;^r1 r2&lt;/code&gt; and it can be written as &lt;code&gt;r1..r2&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;^r1 r2&lt;/code&gt; 설정 동작은 너무 자주 속기있을 것으로 보인다. 두 개의 커밋 &lt;code&gt;r1&lt;/code&gt; 과 &lt;code&gt;r2&lt;/code&gt; 가있는 경우 (위의 스펙 수정에 설명 된 구문에 따라 명명 됨), r1에서 &lt;code&gt;^r1 r2&lt;/code&gt; 로 도달 할 수있는 커밋을 제외하고 r2에서 도달 할 수있는 커밋을 요청할 수 있으며 r1 으로 작성할 수 있습니다 &lt;code&gt;r1..r2&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c300333c575f956c2060e4236a825e5a15abf118" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;a/&lt;/code&gt; and &lt;code&gt;b/&lt;/code&gt; filenames are the same unless rename/copy is involved. Especially, even for a creation or a deletion, &lt;code&gt;/dev/null&lt;/code&gt; is &lt;code&gt;not&lt;/code&gt; used in place of the &lt;code&gt;a/&lt;/code&gt; or &lt;code&gt;b/&lt;/code&gt; filenames.</source>
          <target state="translated">&lt;code&gt;a/&lt;/code&gt; 및 &lt;code&gt;b/&lt;/code&gt; 파일 이름 바꾸기 / 복사본을 포함하지 않는 동일하다. 특히, 작성 또는 삭제 의 경우에도 &lt;code&gt;a/&lt;/code&gt; 또는 &lt;code&gt;b/&lt;/code&gt; 파일 이름 대신 &lt;code&gt;/dev/null&lt;/code&gt; 이 사용 &lt;code&gt;not&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="eab33dae66d0744b7d6024e6ba0526d3cbdb099d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;base commit&lt;/code&gt; is shown as &quot;base-commit: &quot; followed by the 40-hex of the commit object name. A &lt;code&gt;prerequisite patch&lt;/code&gt; is shown as &quot;prerequisite-patch-id: &quot; followed by the 40-hex &lt;code&gt;patch id&lt;/code&gt;, which can be obtained by passing the patch through the &lt;code&gt;git patch-id --stable&lt;/code&gt; command.</source>
          <target state="translated">&lt;code&gt;base commit&lt;/code&gt; 커밋 객체 이름의 40 진수 뒤에 &quot;베이스 커밋&quot;로 도시되어있다. &lt;code&gt;prerequisite patch&lt;/code&gt; 40 진수 다음 &quot;필수 패치-ID '로서 도시되어 &lt;code&gt;patch id&lt;/code&gt; 관통 패치를 통과시킴으로써 얻을 수 있고, &lt;code&gt;git patch-id --stable&lt;/code&gt; 명령.</target>
        </trans-unit>
        <trans-unit id="4310c66d08d5e3db5f29a0976c449ecfedbc1c27" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;category&lt;/code&gt; field may be used in a future enhancement to do category-based filtering.</source>
          <target state="translated">&lt;code&gt;category&lt;/code&gt; 필드는 장르 기반 필터링을 할 수있는 미래의 개선에 이용 될 수있다.</target>
        </trans-unit>
        <trans-unit id="957c03f80393df2f84f209da8b3d5d5b6c66e351" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;commit walkers&lt;/code&gt; are sometimes also called &lt;code&gt;dumb transports&lt;/code&gt;, because they do not require any Git aware smart server like Git Native transport does. Any stock HTTP server that does not even support directory index would suffice. But you must prepare your repository with &lt;code&gt;git update-server-info&lt;/code&gt; to help dumb transport downloaders.</source>
          <target state="translated">&lt;code&gt;commit walkers&lt;/code&gt; 때때로라고 &lt;code&gt;dumb transports&lt;/code&gt; 망할 놈의 기본 전송이하는 것처럼 그들이 어떤 망할 놈의 인식 스마트 서버를 필요로하지 않기 때문에. 디렉토리 색인을 지원하지 않는 모든 기본 HTTP 서버로 충분합니다. 그러나 멍청한 전송 다운로더를 돕기 위해 &lt;code&gt;git update-server-info&lt;/code&gt; 로 저장소를 준비해야합니다 .</target>
        </trans-unit>
        <trans-unit id="16292719b3497b67052d324a828a5bf607c10cb8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;committer&lt;/code&gt; command indicates who made this commit, and when they made it.</source>
          <target state="translated">&lt;code&gt;committer&lt;/code&gt; 명령은이 커밋했고, 그들이 그것을 만들 때 사람을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="7e0ffba56fb259ff8ccb9999d0c02587815b0675" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;core.whitespace&lt;/code&gt; configuration variable allows you to define what &lt;code&gt;diff&lt;/code&gt; and &lt;code&gt;apply&lt;/code&gt; should consider whitespace errors for all paths in the project (See &lt;a href=&quot;git-config&quot;&gt;git-config[1]&lt;/a&gt;). This attribute gives you finer control per path.</source>
          <target state="translated">&lt;code&gt;core.whitespace&lt;/code&gt; 의 구성 변수 당신이 무엇을 정의 할 수 있습니다 &lt;code&gt;diff&lt;/code&gt; 하고 &lt;code&gt;apply&lt;/code&gt; 고려해야 공백 프로젝트의 모든 경로에 대한 오류 (참조 &lt;a href=&quot;git-config&quot;&gt;자식-설정 [1]&lt;/a&gt; ). 이 속성은 경로마다 더 세밀한 제어를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="c4cf312c5837f50305786c4fff7bd921da0df1e0" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;data&lt;/code&gt; command following &lt;code&gt;committer&lt;/code&gt; must supply the commit message (see below for &lt;code&gt;data&lt;/code&gt; command syntax). To import an empty commit message use a 0 length data. Commit messages are free-form and are not interpreted by Git. Currently they must be encoded in UTF-8, as fast-import does not permit other encodings to be specified.</source>
          <target state="translated">&lt;code&gt;committer&lt;/code&gt; 다음 의 &lt;code&gt;data&lt;/code&gt; 명령 은 커밋 메시지를 제공해야합니다 ( &lt;code&gt;data&lt;/code&gt; 명령 구문 은 아래 참조 ). 빈 커밋 메시지를 가져 오려면 길이가 0 인 데이터를 사용하십시오. 커밋 메시지는 자유 형식이며 Git이 해석하지 않습니다. 빠른 가져 오기에서는 다른 인코딩을 지정할 수 없으므로 현재 UTF-8로 인코딩해야합니다.</target>
        </trans-unit>
        <trans-unit id="fe1dcaff1f205cb554cce0caa7f556f5b3750431" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;data&lt;/code&gt; command following &lt;code&gt;tagger&lt;/code&gt; must supply the annotated tag message (see below for &lt;code&gt;data&lt;/code&gt; command syntax). To import an empty tag message use a 0 length data. Tag messages are free-form and are not interpreted by Git. Currently they must be encoded in UTF-8, as fast-import does not permit other encodings to be specified.</source>
          <target state="translated">&lt;code&gt;tagger&lt;/code&gt; 다음 의 &lt;code&gt;data&lt;/code&gt; 명령 은 주석이 달린 태그 메시지를 제공해야합니다 ( &lt;code&gt;data&lt;/code&gt; 명령 구문 은 아래 참조 ). 빈 태그 메시지를 가져 오려면 길이가 0 인 데이터를 사용하십시오. 태그 메시지는 자유 형식이며 Git에서 해석하지 않습니다. 빠른 가져 오기에서는 다른 인코딩을 지정할 수 없으므로 현재 UTF-8로 인코딩해야합니다.</target>
        </trans-unit>
        <trans-unit id="463a929e2c19b7bbf028008ad9aa5a5763e6cf66" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;export-marks&lt;/code&gt; and &lt;code&gt;import-marks&lt;/code&gt; capabilities, if specified, affect this command in so far as they are passed on to &lt;code&gt;git fast-export&lt;/code&gt;, which then will load/store a table of marks for local objects. This can be used to implement for incremental operations.</source>
          <target state="translated">&lt;code&gt;export-marks&lt;/code&gt; 및 &lt;code&gt;import-marks&lt;/code&gt; 에 기능을 지정하는 경우, 지금까지 그들이 통과로이 명령에 영향을 &lt;code&gt;git fast-export&lt;/code&gt; 다음로드 / 지역 객체에 대한 마크의 테이블을 저장합니다. 증분 작업을 구현하는 데 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b29369cc7c91f799f3a98b04ce067ccee4eaff48" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;extra-info&lt;/code&gt; is again command-dependent. If it is empty, the preceding SP is also omitted. Currently, no commands pass any &lt;code&gt;extra-info&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;extra-info&lt;/code&gt; 다시 명령 의존한다. 비어 있으면 앞의 SP도 생략됩니다. 현재 어떤 명령도 &lt;code&gt;extra-info&lt;/code&gt; 를 전달하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="42c3cfeeb6fb7d3b809e4b2424ab05b633a62a10" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;format:&amp;lt;string&amp;gt;&lt;/code&gt; format allows you to specify which information you want to show. It works a little bit like printf format, with the notable exception that you get a newline with &lt;code&gt;%n&lt;/code&gt; instead of &lt;code&gt;\n&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;format:&amp;lt;string&amp;gt;&lt;/code&gt; 형식은 당신이 표시하려는 정보를 지정할 수 있습니다. &lt;code&gt;\n&lt;/code&gt; 대신 &lt;code&gt;%n&lt;/code&gt; 사용 하여 줄 바꿈을 얻는다는 점을 제외하면 printf 형식과 약간 비슷합니다 .</target>
        </trans-unit>
        <trans-unit id="6d12446e6ba50613ffa6591e4d86ab902d5b116f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;from&lt;/code&gt; command is the same as in the &lt;code&gt;commit&lt;/code&gt; command; see above for details.</source>
          <target state="translated">&lt;code&gt;from&lt;/code&gt; (가)와 같이 명령은 동일 &lt;code&gt;commit&lt;/code&gt; 명령; 자세한 내용은 위를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="d9bc1ff5b134d7635edcea3cd4e631a291483167" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;from&lt;/code&gt; command is used to specify the commit to initialize this branch from. This revision will be the first ancestor of the new commit. The state of the tree built at this commit will begin with the state at the &lt;code&gt;from&lt;/code&gt; commit, and be altered by the content modifications in this commit.</source>
          <target state="translated">&lt;code&gt;from&lt;/code&gt; 명령은이에서이 지점을 초기화하는 커밋 지정하는 데 사용됩니다. 이 개정판은 새로운 커밋의 첫 번째 조상이 될 것입니다. 이 커밋에서 빌드 된 트리의 상태는 &lt;code&gt;from&lt;/code&gt; 커밋 의 상태로 시작 되며이 커밋의 내용 수정에 의해 변경됩니다.</target>
        </trans-unit>
        <trans-unit id="75dab416c6ca16533650ccb3bdbb6f1c8c80e31e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;git add&lt;/code&gt; command will not add ignored files by default. If any ignored files were explicitly specified on the command line, &lt;code&gt;git add&lt;/code&gt; will fail with a list of ignored files. Ignored files reached by directory recursion or filename globbing performed by Git (quote your globs before the shell) will be silently ignored. The &lt;code&gt;git add&lt;/code&gt; command can be used to add ignored files with the &lt;code&gt;-f&lt;/code&gt; (force) option.</source>
          <target state="translated">&lt;code&gt;git add&lt;/code&gt; 명령은 기본적으로 파일을 무시 추가하지 않습니다. 명령 행에 무시 된 파일이 명시 적으로 지정된 경우, &lt;code&gt;git add&lt;/code&gt; 는 무시 된 파일 목록과 함께 실패합니다. Git이 수행 한 디렉토리 재귀 또는 파일 이름 globbing (쉘 앞에 globs 인용)에 의해 무시 된 파일은 자동으로 무시됩니다. &lt;code&gt;git add&lt;/code&gt; 명령이 함께 무시 파일을 추가 할 수 있습니다 &lt;code&gt;-f&lt;/code&gt; (강제) 옵션을 선택합니다.</target>
        </trans-unit>
        <trans-unit id="9bd7293224a598d82d7fb9b059bf233156e9f91a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;git bundle&lt;/code&gt; command packages objects and references in an archive at the originating machine, which can then be imported into another repository using &lt;code&gt;git fetch&lt;/code&gt;, &lt;code&gt;git pull&lt;/code&gt;, or &lt;code&gt;git clone&lt;/code&gt;, after moving the archive by some means (e.g., by sneakernet).</source>
          <target state="translated">&lt;code&gt;git bundle&lt;/code&gt; 다음 다른 사용 저장소로 가져올 수 발신 시스템에서 아카이브 명령 패키지 목적 및 참조 &lt;code&gt;git fetch&lt;/code&gt; , &lt;code&gt;git pull&lt;/code&gt; 또는 &lt;code&gt;git clone&lt;/code&gt; (체크를하면서 의해, 예) 일부에 의해 압축을 이동 한 후,.</target>
        </trans-unit>
        <trans-unit id="3d9620664b0c9d56c3287a812c3ff6b6d1c8717f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;git diff-*&lt;/code&gt; family works by first comparing two sets of files:</source>
          <target state="translated">&lt;code&gt;git diff-*&lt;/code&gt; 첫번째 파일의 두 세트를 비교하여 가족 작품 :</target>
        </trans-unit>
        <trans-unit id="597ca1f538bf6e2f60b9e6f9e15d7129efb080fb" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;git fetch&lt;/code&gt; operation always stores the head of the last fetched branch in FETCH_HEAD. For example, if you run &lt;code&gt;git fetch&lt;/code&gt; without specifying a local branch as the target of the operation</source>
          <target state="translated">&lt;code&gt;git fetch&lt;/code&gt; 작업은 항상 FETCH_HEAD의 마지막 인출 지점의 머리를 저장합니다. 예를 들어, 로컬 분기를 작업 대상으로 지정하지 않고 &lt;code&gt;git fetch&lt;/code&gt; 를 실행하는 경우</target>
        </trans-unit>
        <trans-unit id="f809c0db2fabe1b716a044f1ae315c3eafe27e59" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;git fmt-merge-msg&lt;/code&gt; command can be used to give a good default for automated &lt;code&gt;git merge&lt;/code&gt; invocations. The automated message can include the branch description.</source>
          <target state="translated">&lt;code&gt;git fmt-merge-msg&lt;/code&gt; 명령은 자동화를위한 좋은 기본 제공하는 데 사용할 수있는 &lt;code&gt;git merge&lt;/code&gt; 호출을. 자동화 된 메시지에는 지사 설명이 포함될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="dae50540309298598631c32bc4ba09615f81ee1b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;git gc --auto&lt;/code&gt; command will run the &lt;code&gt;pre-auto-gc&lt;/code&gt; hook. See &lt;a href=&quot;githooks&quot;&gt;githooks[5]&lt;/a&gt; for more information.</source>
          <target state="translated">&lt;code&gt;git gc --auto&lt;/code&gt; 명령은 실행 &lt;code&gt;pre-auto-gc&lt;/code&gt; 훅을. 자세한 내용은 &lt;a href=&quot;githooks&quot;&gt;githooks [5]&lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="cfc7fc175318cd6dff60f69f9572984dc7656815" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;git grep&lt;/code&gt; command can search for strings in any version of your project, so</source>
          <target state="translated">&lt;code&gt;git grep&lt;/code&gt; 명령 때문에, 프로젝트의 모든 버전에서 문자열을 검색 할 수 있습니다</target>
        </trans-unit>
        <trans-unit id="10370106ed757f0fcfa619078db112558b3f4b4c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;git log&lt;/code&gt; command has a weakness: it must present commits in a list. When the history has lines of development that diverged and then merged back together, the order in which &lt;code&gt;git log&lt;/code&gt; presents those commits is meaningless.</source>
          <target state="translated">&lt;code&gt;git log&lt;/code&gt; 명령은 약점이있다 : 그것은 목록에 커밋을 제시해야합니다. 히스토리에 개발 라인이 분기되어 다시 병합 된 경우 &lt;code&gt;git log&lt;/code&gt; 가 해당 커밋을 표시 하는 순서 는 의미가 없습니다.</target>
        </trans-unit>
        <trans-unit id="2918fcbf92a1ba7da67f920488e3f1571c6c776d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;git pull&lt;/code&gt; command can also be given &lt;code&gt;.&lt;/code&gt; as the &quot;remote&quot; repository, in which case it just merges in a branch from the current repository; so the commands</source>
          <target state="translated">&lt;code&gt;git pull&lt;/code&gt; 명령도 제공 할 수있다 &lt;code&gt;.&lt;/code&gt; &quot;원격&quot;리포지토리로,이 경우에는 현재 리포지토리의 분기로 병합됩니다. 그래서 명령</target>
        </trans-unit>
        <trans-unit id="ae6be494d942d11be1fef84bf75e14340e42ba70" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;git sh-setup&lt;/code&gt; scriptlet is designed to be sourced (using &lt;code&gt;.&lt;/code&gt;) by other shell scripts to set up some variables pointing at the normal Git directories and a few helper shell functions.</source>
          <target state="translated">&lt;code&gt;git sh-setup&lt;/code&gt; 스크립틀릿은 (사용하여 공급하도록 설계되어 있습니다 &lt;code&gt;.&lt;/code&gt; 일반 망할 놈의 디렉토리와 몇 도우미 쉘 기능을 가리키는 몇 가지 변수를 설정하는 다른 쉘 스크립트에 의해).</target>
        </trans-unit>
        <trans-unit id="b8d00251834fb59fdb3aac3b6b6d2fd6617d8c54" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;git status&lt;/code&gt; command can be used to obtain a summary of which files have changes that are staged for the next commit.</source>
          <target state="translated">&lt;code&gt;git status&lt;/code&gt; 명령은 파일을 다음 커밋을 위해 개최되는 변경 사항이있는 요약을 얻을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1114dd8f20b27292636eee44dbca10b695a7e192" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;git submodule add &amp;lt;repo&amp;gt; &amp;lt;path&amp;gt;&lt;/code&gt; command does a couple of things:</source>
          <target state="translated">&lt;code&gt;git submodule add &amp;lt;repo&amp;gt; &amp;lt;path&amp;gt;&lt;/code&gt; 명령 않는 몇 가지 :</target>
        </trans-unit>
        <trans-unit id="851ad3692f8ce86e89fabf82d757953cfb293665" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;git svn log&lt;/code&gt; command will not work on repositories using this, either. Using this conflicts with the &lt;code&gt;useSvmProps&lt;/code&gt; option for (hopefully) obvious reasons.</source>
          <target state="translated">&lt;code&gt;git svn log&lt;/code&gt; 명령 중 하나,이를 사용하여 저장소에서 작동하지 않습니다. 이 방법을 사용하면 명백한 이유로 &lt;code&gt;useSvmProps&lt;/code&gt; 옵션 과 충돌합니다 .</target>
        </trans-unit>
        <trans-unit id="54f2e5960f99dce6a894019f61b5f183cfaf541a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;git switch&lt;/code&gt; command normally expects a branch head, but will also accept an arbitrary commit when invoked with --detach; for example, you can check out the commit referenced by a tag:</source>
          <target state="translated">&lt;code&gt;git switch&lt;/code&gt; 명령은 일반적으로 분기 머리를 기대하고, 또한 --detach 호출 할 때 임의의 커밋 받아 들일 것입니다; 예를 들어 태그가 참조하는 커밋을 확인할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5df4353714e03396f22186d308b555d9fc45aa0a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;git unpack-objects&lt;/code&gt; command can read the packed archive and expand the objects contained in the pack into &quot;one-file one-object&quot; format; this is typically done by the smart-pull commands when a pack is created on-the-fly for efficient network transport by their peers.</source>
          <target state="translated">&lt;code&gt;git unpack-objects&lt;/code&gt; 명령은 포장 된 압축 파일을 읽고 개체가 &quot;하나의 파일을 하나의 객체&quot;형식으로 팩에 포함 된 확장 할 수 있습니다; 이는 일반적으로 동료가 효율적인 네트워크 전송을 위해 팩을 즉석에서 생성 할 때 스마트 풀 명령으로 수행됩니다.</target>
        </trans-unit>
        <trans-unit id="472b18d3af19081ec08acbffb4a8b9828ded3de3" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;git write-tree&lt;/code&gt; command refuses to write a nonsensical tree, and it will complain about unmerged entries if it sees a single entry that is not stage 0.</source>
          <target state="translated">&lt;code&gt;git write-tree&lt;/code&gt; 명령은 무의미한 트리 쓰기를 거부하고 무대 0이 아닌 하나의 항목을 보는 경우가 병합되지 않은 항목에 대해 불평 할 것이다.</target>
        </trans-unit>
        <trans-unit id="57ed6fd41631cf164adf8f1a5f87022b80e95155" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;git-fetch&lt;/code&gt; command, with no arguments, will update all of the remote-tracking branches to the latest version found in the original repository. It will not touch any of your own branches&amp;mdash;​not even the &quot;master&quot; branch that was created for you on clone.</source>
          <target state="translated">&lt;code&gt;git-fetch&lt;/code&gt; 원래 저장소에있는 최신 버전으로 원격 추적 브랜치의 모든 업데이트됩니다, 인수없이 명령을. 클론에서 생성 한 &quot;마스터&quot;브랜치조차도 자신의 브랜치에 닿지 않습니다.</target>
        </trans-unit>
        <trans-unit id="b7a1f970e8485b643b6fd9d3ee5bf5ec87b44b17" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;gitlink&lt;/code&gt; entry contains the object name of the commit that the superproject expects the submodule&amp;rsquo;s working directory to be at.</source>
          <target state="translated">&lt;code&gt;gitlink&lt;/code&gt; 항목은이 superproject이 서브 모듈의 작업 디렉토리에있을 것으로 예상 것을 커밋의 객체 이름이 포함되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="20a22a2e8dd656430183eebd26fcd541802b3980" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;help.browser&lt;/code&gt;, &lt;code&gt;web.browser&lt;/code&gt; and &lt;code&gt;browser.&amp;lt;tool&amp;gt;.path&lt;/code&gt; will also be checked if the &lt;code&gt;web&lt;/code&gt; format is chosen (either by command-line option or configuration variable). See &lt;code&gt;-w|--web&lt;/code&gt; in the OPTIONS section above and git-web{litdd}browse[1].</source>
          <target state="translated">&lt;code&gt;help.browser&lt;/code&gt; , &lt;code&gt;web.browser&lt;/code&gt; 및 &lt;code&gt;browser.&amp;lt;tool&amp;gt;.path&lt;/code&gt; 경우 생성도 체크한다 &lt;code&gt;web&lt;/code&gt; 포맷이 선택된다 (어느 명령 행 옵션 또는 구성 변수). 참조 &lt;code&gt;-w|--web&lt;/code&gt; 와 자식 - 웹 {litdd} 찾아 [1] 위의 옵션 섹션입니다.</target>
        </trans-unit>
        <trans-unit id="d643b3df461bdc6854f7d047b7c0264699b4e1d2" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;include&lt;/code&gt; and &lt;code&gt;includeIf&lt;/code&gt; sections allow you to include config directives from another source. These sections behave identically to each other with the exception that &lt;code&gt;includeIf&lt;/code&gt; sections may be ignored if their condition does not evaluate to true; see &quot;Conditional includes&quot; below.</source>
          <target state="translated">은 &lt;code&gt;include&lt;/code&gt; 하고 &lt;code&gt;includeIf&lt;/code&gt; 의 섹션은 다른 소스에서 설정 지시어를 포함 할 수 있습니다. 이러한 섹션 은 조건이 true로 평가되지 않으면 &lt;code&gt;includeIf&lt;/code&gt; 섹션이 무시 될 수 있다는 점을 제외하고 서로 동일하게 동작 합니다. 아래의 &quot;조건부 포함&quot;을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="25df8c5531688eabec317d8bad065a9bd5755f39" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;label&lt;/code&gt; command associates a label with the current HEAD when that command is executed. These labels are created as worktree-local refs (&lt;code&gt;refs/rewritten/&amp;lt;label&amp;gt;&lt;/code&gt;) that will be deleted when the rebase finishes. That way, rebase operations in multiple worktrees linked to the same repository do not interfere with one another. If the &lt;code&gt;label&lt;/code&gt; command fails, it is rescheduled immediately, with a helpful message how to proceed.</source>
          <target state="translated">&lt;code&gt;label&lt;/code&gt; 이 명령이 실행될 때 명령은 현재 HEAD와 레이블을 연결합니다. 이 레이블은 리베이스가 완료 될 때 삭제되는 작업 트리 로컬 참조 ( &lt;code&gt;refs/rewritten/&amp;lt;label&amp;gt;&lt;/code&gt; )로 작성 됩니다. 이렇게하면 동일한 리포지토리에 연결된 여러 작업 트리의 리베이스 작업이 서로 간섭하지 않습니다. 경우 &lt;code&gt;label&lt;/code&gt; 명령이 실패 진행 방법, 그것은 도움이 메시지와 함께 즉시 재조정된다.</target>
        </trans-unit>
        <trans-unit id="a21f07c748b4f824d325c5d844a166616c79a19e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;list&lt;/code&gt; command produces a list of refs in which each ref may be followed by a list of attributes. The following ref list attributes are defined.</source>
          <target state="translated">&lt;code&gt;list&lt;/code&gt; 명령 (REF)는 각 속성 목록 다음 될 수있는 심판의리스트를 생성한다. 다음 참조 목록 속성이 정의됩니다.</target>
        </trans-unit>
        <trans-unit id="a1948673e2dc6e9b36baf9466260194608388c73" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;ls&lt;/code&gt; command can also be used where a &lt;code&gt;filemodify&lt;/code&gt; directive can appear, allowing it to be used in the middle of a commit.</source>
          <target state="translated">&lt;code&gt;ls&lt;/code&gt; 명령은 또한 어디에 사용할 수 있습니다 &lt;code&gt;filemodify&lt;/code&gt; 지시어는이 커밋의 중간에 사용할 수 있도록 나타날 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9f751fdc4139000f76be8c4b7f0362d024d6ccd7" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;maint&lt;/code&gt; branch should now be fast-forwarded to the newly released code so that maintenance fixes can be tracked for the current release:</source>
          <target state="translated">&lt;code&gt;maint&lt;/code&gt; 지점은 이제 유지 보수 수정은 현재 릴리스에 대해 추적 할 수 있도록 새로 출시 된 코드를 빠르게 전달해야합니다 :</target>
        </trans-unit>
        <trans-unit id="3d08be0d91fe4ba76005ea415ec8dd980a19baaf" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;man.viewer&lt;/code&gt; configuration variable will be checked if the &lt;code&gt;man&lt;/code&gt; format is chosen. The following values are currently supported:</source>
          <target state="translated">&lt;code&gt;man.viewer&lt;/code&gt; 의 경우 생성 구성 변수가 확인됩니다 &lt;code&gt;man&lt;/code&gt; 포맷이 선택됩니다. 현재 다음 값이 지원됩니다.</target>
        </trans-unit>
        <trans-unit id="4d99fda454f21ad231a7b020da5a33fbc1590dfe" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;master&lt;/code&gt; branch is supposed to be a superset of &lt;code&gt;maint&lt;/code&gt;. If this condition does not hold, then &lt;code&gt;maint&lt;/code&gt; contains some commits that are not included on &lt;code&gt;master&lt;/code&gt;. The fixes represented by those commits will therefore not be included in your feature release.</source>
          <target state="translated">&lt;code&gt;master&lt;/code&gt; 브랜치의 상위 집합이기로되어있다 &lt;code&gt;maint&lt;/code&gt; . 이 조건이 유지되지 않으면 &lt;code&gt;maint&lt;/code&gt; 에는 &lt;code&gt;master&lt;/code&gt; 에 포함되지 않은 커밋이 포함됩니다 . 따라서 해당 커밋으로 표시되는 수정 프로그램은 기능 릴리스에 포함되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="60a9438818e32daade34327aac8510a028d0a280" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;merge.*.driver&lt;/code&gt; variable&amp;rsquo;s value is used to construct a command to run to merge ancestor&amp;rsquo;s version (&lt;code&gt;%O&lt;/code&gt;), current version (&lt;code&gt;%A&lt;/code&gt;) and the other branches' version (&lt;code&gt;%B&lt;/code&gt;). These three tokens are replaced with the names of temporary files that hold the contents of these versions when the command line is built. Additionally, %L will be replaced with the conflict marker size (see below).</source>
          <target state="translated">&lt;code&gt;merge.*.driver&lt;/code&gt; 변수 값이 병합 상위 버전 (에 실행할 명령 구성하는데 사용된다 &lt;code&gt;%O&lt;/code&gt; ) 현재 버전 ( &lt;code&gt;%A&lt;/code&gt; ) 다른 지점 '버전 ( &lt;code&gt;%B&lt;/code&gt; ). 이 세 개의 토큰은 명령 행이 빌드 될 때이 버전의 내용을 보유하는 임시 파일 이름으로 대체됩니다. 또한 % L은 충돌 마커 크기로 대체됩니다 (아래 참조).</target>
        </trans-unit>
        <trans-unit id="8135860bcb3c213dc65a79f9d59c1c4cf76a9b52" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;merge.*.name&lt;/code&gt; variable gives the driver a human-readable name.</source>
          <target state="translated">&lt;code&gt;merge.*.name&lt;/code&gt; 변수는 드라이버에 사람이 읽을 수있는 이름을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="531f58358e8d95bd1e04306b8f06edec09e06aba" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;merge.*.recursive&lt;/code&gt; variable specifies what other merge driver to use when the merge driver is called for an internal merge between common ancestors, when there are more than one. When left unspecified, the driver itself is used for both internal merge and the final merge.</source>
          <target state="translated">&lt;code&gt;merge.*.recursive&lt;/code&gt; 하나 이상 존재하는 경우 변수의 내용을 지정 다른 병합 드라이버 병합 드라이버가 공통 조상과 내부 병합 호출 될 때 사용한다. 지정하지 않은 경우 드라이버 자체는 내부 병합 및 최종 병합에 모두 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="0e9e9f9df980dcf05008ee310843fafb365f76e7" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;merge&lt;/code&gt; command will merge the specified revision(s) into whatever is HEAD at that time. With &lt;code&gt;-C &amp;lt;original-commit&amp;gt;&lt;/code&gt;, the commit message of the specified merge commit will be used. When the &lt;code&gt;-C&lt;/code&gt; is changed to a lower-case &lt;code&gt;-c&lt;/code&gt;, the message will be opened in an editor after a successful merge so that the user can edit the message.</source>
          <target state="translated">&lt;code&gt;merge&lt;/code&gt; 명령은 그 시간에 HEAD 무엇이든 지정된 개정 (들)에 병합됩니다. 함께 &lt;code&gt;-C &amp;lt;original-commit&amp;gt;&lt;/code&gt; 의 병합은 특정의 메시지가 사용될 확약. &lt;code&gt;-C&lt;/code&gt; 가 소문자 &lt;code&gt;-c&lt;/code&gt; 로 변경 되면 병합이 성공한 후 편집기에서 메시지가 열리므로 사용자가 메시지를 편집 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="103d9db55b62f87264ea4e2293c619e5e886c09f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;mode &amp;lt;mode&amp;gt;,&amp;lt;mode&amp;gt;..&amp;lt;mode&amp;gt;&lt;/code&gt; line appears only if at least one of the &amp;lt;mode&amp;gt; is different from the rest. Extended headers with information about detected contents movement (renames and copying detection) are designed to work with diff of two &amp;lt;tree-ish&amp;gt; and are not used by combined diff format.</source>
          <target state="translated">&lt;code&gt;mode &amp;lt;mode&amp;gt;,&amp;lt;mode&amp;gt;..&amp;lt;mode&amp;gt;&lt;/code&gt; &amp;lt;모드&amp;gt; 중 적어도 하나는 나머지 다른 경우 라인에만 나타난다. 감지 된 컨텐츠 이동 (이름 변경 및 복사 감지)에 대한 정보가있는 확장 헤더는 두 가지 &amp;lt;tree-ish&amp;gt;의 diff와 함께 작동하도록 설계되었으며 결합 된 diff 형식으로 사용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="245bf1c27c1e24c16ea60d971116c678983044e7" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;p4-pre-submit&lt;/code&gt; hook is executed if it exists and is executable. The hook takes no parameters and nothing from standard input. Exiting with non-zero status from this script prevents &lt;code&gt;git-p4 submit&lt;/code&gt; from launching.</source>
          <target state="translated">&lt;code&gt;p4-pre-submit&lt;/code&gt; 이 존재하고 실행 가능한 경우 후크가 실행됩니다. 후크는 표준 입력에서 매개 변수를 사용하지 않습니다. 이 스크립트에서 0이 아닌 상태로 종료하면 &lt;code&gt;git-p4 submit&lt;/code&gt; 이 시작되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="55ac82e7ce6eab5b9d775518541be1b358e64d26" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;post-update&lt;/code&gt; hook can tell what are the heads that were pushed, but it does not know what their original and updated values are, so it is a poor place to do log old..new. The &lt;a href=&quot;#post-receive&quot;&gt;&lt;em&gt;post-receive&lt;/em&gt;&lt;/a&gt; hook does get both original and updated values of the refs. You might consider it instead if you need them.</source>
          <target state="translated">&lt;code&gt;post-update&lt;/code&gt; 그래서 old..new 로그인 할 수있는 가난한 곳, 후크 밀렸다 머리 무엇인지 말할 수 있지만, 원래 및 업데이트 된 값이 무엇인지 알 수 없습니다. &lt;a href=&quot;#post-receive&quot;&gt;&lt;em&gt;후받을&lt;/em&gt;&lt;/a&gt; 후크는 심판의 모두 원본과 업데이트 된 값을 얻을 수 없습니다. 필요한 경우 대신 고려할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7b1878af31d43f94d962552d8195f8f92835c4ec" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;pre-receive&lt;/code&gt; hook MUST NOT update any refs to point to quarantined objects. Other programs accessing the repository will not be able to see the objects (and if the pre-receive hook fails, those refs would become corrupted). For safety, any ref updates from within &lt;code&gt;pre-receive&lt;/code&gt; are automatically rejected.</source>
          <target state="translated">&lt;code&gt;pre-receive&lt;/code&gt; 후크 격리 된 개체에 포인트에 대한 심판을 업데이트 안된다. 저장소에 액세스하는 다른 프로그램은 오브젝트를 볼 수 없습니다 (사전 수신 후크가 실패하면 해당 참조가 손상됨). 안전을 위해 &lt;code&gt;pre-receive&lt;/code&gt; 내의 모든 참조 업데이트 는 자동으로 거부됩니다.</target>
        </trans-unit>
        <trans-unit id="eb98cabc50bf16dce560817c25a1c4d64601cce6" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;pu&lt;/code&gt; branch will be updated even if it does not fast-forward, because it is prefixed with a plus sign; &lt;code&gt;tmp&lt;/code&gt; will not be.</source>
          <target state="translated">&lt;code&gt;pu&lt;/code&gt; 분기 그것는 더하기 기호로 시작되어 있기 때문에, 아니 빨리 감기 않는 경우에도 업데이트됩니다; &lt;code&gt;tmp&lt;/code&gt; 는 그렇지 않습니다.</target>
        </trans-unit>
        <trans-unit id="d5f7235d0f9a5c833ca324eff7dc4ec19b6e7285" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;pull&lt;/code&gt; command knows where to get updates from because of certain configuration variables that were set by the first &lt;code&gt;git clone&lt;/code&gt; command; see &lt;code&gt;git config -l&lt;/code&gt; and the &lt;a href=&quot;git-config&quot;&gt;git-config[1]&lt;/a&gt; man page for details.</source>
          <target state="translated">&lt;code&gt;pull&lt;/code&gt; 명령 때문에 처음에 의해 설정된 특정 구성 변수의 업데이트를 구할 수있는 곳을 알고 &lt;code&gt;git clone&lt;/code&gt; 명령; 자세한 내용은 &lt;code&gt;git config -l&lt;/code&gt; 및 &lt;a href=&quot;git-config&quot;&gt;git-config [1]&lt;/a&gt; 매뉴얼 페이지를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="9716ab4c9bb8eabfdb4d2f2052c2761838dfc4ea" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;r1^!&lt;/code&gt; notation includes commit &lt;code&gt;r1&lt;/code&gt; but excludes all of its parents. By itself, this notation denotes the single commit &lt;code&gt;r1&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;r1^!&lt;/code&gt; 표기법에는 커밋 &lt;code&gt;r1&lt;/code&gt; 이 포함 되지만 모든 부모는 제외됩니다. 자체적으로이 표기법은 단일 커밋 &lt;code&gt;r1&lt;/code&gt; 을 나타냅니다 .</target>
        </trans-unit>
        <trans-unit id="ec7b0d87246117fbc7ede1e9fb5e445953432dc9" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;r1^@&lt;/code&gt; notation means all parents of &lt;code&gt;r1&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;r1^@&lt;/code&gt; 표기는 모든 부모 의미 &lt;code&gt;r1&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="906a6c33616cfaeeffbd4277ee44152fa9cd28f3" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;raw&lt;/code&gt; format shows the entire commit exactly as stored in the commit object. Notably, the hashes are displayed in full, regardless of whether --abbrev or --no-abbrev are used, and &lt;code&gt;parents&lt;/code&gt; information show the true parent commits, without taking grafts or history simplification into account. Note that this format affects the way commits are displayed, but not the way the diff is shown e.g. with &lt;code&gt;git log --raw&lt;/code&gt;. To get full object names in a raw diff format, use &lt;code&gt;--no-abbrev&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;raw&lt;/code&gt; 전체 정확히 같은 저장 형식 커밋 쇼 오브젝트 커밋. 특히 --abbrev 또는 --no-abbrev의 사용 여부에 관계없이 해시가 전체로 표시되며 그래프 또는 기록 단순화를 고려하지 않고 &lt;code&gt;parents&lt;/code&gt; 정보에 실제 부모 커밋이 표시됩니다. 이 형식은 커밋이 표시되는 방식에 영향을 미치지 만 &lt;code&gt;git log --raw&lt;/code&gt; 와 같이 diff가 표시되는 방식에는 영향을 미치지 않습니다 . 원시 diff 형식으로 전체 객체 이름을 얻으려면 &lt;code&gt;--no-abbrev&lt;/code&gt; 를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="3e2ae08cd51826a72547a4936e1fee7033d540d2" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;recursive&lt;/code&gt; strategy can take the following options:</source>
          <target state="translated">&lt;code&gt;recursive&lt;/code&gt; 전략은 다음과 같은 옵션을 수행 할 수 있습니다</target>
        </trans-unit>
        <trans-unit id="2274cd304e0d47984767afeee4d877ca51fbdd54" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;refs/heads/*&lt;/code&gt; namespace will only accept commit objects, and updates only if they can be fast-forwarded.</source>
          <target state="translated">&lt;code&gt;refs/heads/*&lt;/code&gt; 가 될 수있는 경우에만 네임 스페이스 개체 만 커밋 받아 들일 것입니다 및 업데이트는 빠르게 전달.</target>
        </trans-unit>
        <trans-unit id="73d202d810478ee27aec0a92a74e6cf7efe8db45" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;refs/tags/*&lt;/code&gt; namespace will accept any kind of object (as commits, trees and blobs can be tagged), and any updates to them will be rejected.</source>
          <target state="translated">&lt;code&gt;refs/tags/*&lt;/code&gt; (커밋, 나무와 모양을 태그 할 수있는) 네임 스페이스는 모든 종류의 객체를 받아, 그들에 대한 업데이트가 거부됩니다.</target>
        </trans-unit>
        <trans-unit id="8f1fa8b6ca43d585bbef39f492a9db57e9ecc9a4" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;reset&lt;/code&gt; command can also be used to create lightweight (non-annotated) tags. For example:</source>
          <target state="translated">&lt;code&gt;reset&lt;/code&gt; 명령은 또한 경량 (비 주석) 태그를 만드는 데 사용할 수 있습니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="bd2e909f258c6aa58fa07c5acaee67caeb1da10e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;reset&lt;/code&gt; command resets the HEAD, index and worktree to the specified revision. It is similar to an &lt;code&gt;exec git reset --hard &amp;lt;label&amp;gt;&lt;/code&gt;, but refuses to overwrite untracked files. If the &lt;code&gt;reset&lt;/code&gt; command fails, it is rescheduled immediately, with a helpful message how to edit the todo list (this typically happens when a &lt;code&gt;reset&lt;/code&gt; command was inserted into the todo list manually and contains a typo).</source>
          <target state="translated">&lt;code&gt;reset&lt;/code&gt; 명령은 지정된 개정에 HEAD, 인덱스 및 worktree를 재설정합니다. 그것은과 유사 &lt;code&gt;exec git reset --hard &amp;lt;label&amp;gt;&lt;/code&gt; 하지만, 비 추적 파일을 덮어 거부합니다. 경우 &lt;code&gt;reset&lt;/code&gt; 명령이 실패, 그것은 도움이 메시지와 함께 즉시 재조정하는 방법을 편집 할 일 목록 (A 때 일반적으로 발생 &lt;code&gt;reset&lt;/code&gt; 명령을 수동으로 할 일 목록에 삽입 오타가 포함되었다).</target>
        </trans-unit>
        <trans-unit id="06cca2918a8a255dfff1d384369e4d4195e47f51" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;shortlog&lt;/code&gt; view is more compact; it shows one commit per line.</source>
          <target state="translated">&lt;code&gt;shortlog&lt;/code&gt; 의 보기는 더 컴팩트; 행당 하나의 커밋을 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="49d7635e517e74681985e2d5acfe0d3faa2b57eb" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;tagger&lt;/code&gt; command uses the same format as &lt;code&gt;committer&lt;/code&gt; within &lt;code&gt;commit&lt;/code&gt;; again see above for details.</source>
          <target state="translated">&lt;code&gt;tagger&lt;/code&gt; 명령과 같은 포맷 사용 &lt;code&gt;committer&lt;/code&gt; 내의 &lt;code&gt;commit&lt;/code&gt; ; 자세한 내용은 위를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="c5d1574573f9cb9deb3517e06eb81c31c726f5b5" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;textconv&lt;/code&gt; config option is used to define a program for performing such a conversion. The program should take a single argument, the name of a file to convert, and produce the resulting text on stdout.</source>
          <target state="translated">&lt;code&gt;textconv&lt;/code&gt; 설정 옵션은 이러한 변환을 수행하기위한 프로그램을 정의하는 데 사용됩니다. 프로그램은 변환 할 파일 이름 인 단일 인수를 가져 와서 stdout에 결과 텍스트를 생성해야합니다.</target>
        </trans-unit>
        <trans-unit id="5a024de933cb7ecb7f2684cd23c20dd59cced4c6" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;tformat:&lt;/code&gt; format works exactly like &lt;code&gt;format:&lt;/code&gt;, except that it provides &quot;terminator&quot; semantics instead of &quot;separator&quot; semantics. In other words, each commit has the message terminator character (usually a newline) appended, rather than a separator placed between entries. This means that the final entry of a single-line format will be properly terminated with a new line, just as the &quot;oneline&quot; format does. For example:</source>
          <target state="translated">&lt;code&gt;tformat:&lt;/code&gt; 형식은 정확히 같은 작품 &lt;code&gt;format:&lt;/code&gt; , 대신 &quot;분리&quot;의미의 &quot;터미네이터&quot;의미를 제공하는 것을 제외하고. 즉, 각 커밋에는 항목 사이에 구분 기호가 아닌 메시지 종료 문자 (보통 줄 바꿈)가 추가됩니다. 즉, &quot;한 줄&quot;형식과 마찬가지로 한 줄 형식의 최종 항목이 새 줄로 올바르게 종료됩니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="52696bbc1bd35a1c1c6d78b6535a11990db3bb34" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;user.name&lt;/code&gt; and &lt;code&gt;user.email&lt;/code&gt; variables determine what ends up in the &lt;code&gt;author&lt;/code&gt; and &lt;code&gt;committer&lt;/code&gt; field of commit objects. If you need the &lt;code&gt;author&lt;/code&gt; or &lt;code&gt;committer&lt;/code&gt; to be different, the &lt;code&gt;author.name&lt;/code&gt;, &lt;code&gt;author.email&lt;/code&gt;, &lt;code&gt;committer.name&lt;/code&gt; or &lt;code&gt;committer.email&lt;/code&gt; variables can be set. Also, all of these can be overridden by the &lt;code&gt;GIT_AUTHOR_NAME&lt;/code&gt;, &lt;code&gt;GIT_AUTHOR_EMAIL&lt;/code&gt;, &lt;code&gt;GIT_COMMITTER_NAME&lt;/code&gt;, &lt;code&gt;GIT_COMMITTER_EMAIL&lt;/code&gt; and &lt;code&gt;EMAIL&lt;/code&gt; environment variables. See &lt;a href=&quot;git-commit-tree&quot;&gt;git-commit-tree[1]&lt;/a&gt; for more information.</source>
          <target state="translated">&lt;code&gt;user.name&lt;/code&gt; 및 &lt;code&gt;user.email&lt;/code&gt; 변수는에 끝을 결정 &lt;code&gt;author&lt;/code&gt; 및 &lt;code&gt;committer&lt;/code&gt; 객체를 커밋의 필드. 당신이 필요한 경우 &lt;code&gt;author&lt;/code&gt; 또는 &lt;code&gt;committer&lt;/code&gt; 다른 것으로는 &lt;code&gt;author.name&lt;/code&gt; , &lt;code&gt;author.email&lt;/code&gt; , &lt;code&gt;committer.name&lt;/code&gt; 또는 &lt;code&gt;committer.email&lt;/code&gt; 변수를 설정할 수 있습니다. 또한 이들 모두는 &lt;code&gt;GIT_AUTHOR_NAME&lt;/code&gt; , &lt;code&gt;GIT_AUTHOR_EMAIL&lt;/code&gt; , &lt;code&gt;GIT_COMMITTER_NAME&lt;/code&gt; , &lt;code&gt;GIT_COMMITTER_EMAIL&lt;/code&gt; 및 &lt;code&gt;EMAIL&lt;/code&gt; 환경 변수 로 대체 될 수 있습니다 . &lt;a href=&quot;git-commit-tree&quot;&gt;자식 커밋 트리&lt;/a&gt; 참조 [1] 자세한 내용은.</target>
        </trans-unit>
        <trans-unit id="16ffcc56d5f44fe2ccdfd792b9ad74a964b837f9" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;&amp;hellip;​&lt;/em&gt; (three-dot) Symmetric Difference Notation</source>
          <target state="translated">&lt;em&gt;...&lt;/em&gt; (세 점) 대칭 차이 표기</target>
        </trans-unit>
        <trans-unit id="3ca01d997f3f16d56fc54554bfe9b469c32c5dff" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;..&lt;/em&gt; (two-dot) Range Notation</source>
          <target state="translated">&lt;em&gt;..&lt;/em&gt; (두 점) 범위 표기법</target>
        </trans-unit>
        <trans-unit id="28292c9406d9116658f021a9e7e686e22523649d" translate="yes" xml:space="preserve">
          <source>The C rewrite is first included with Git version 2.22 (and Git for Windows version 2.19). This option serves as an escape hatch to re-enable the legacy version in case any bugs are found in the rewrite. This option and the shell script version of &lt;a href=&quot;git-stash&quot;&gt;git-stash[1]&lt;/a&gt; will be removed in some future release.</source>
          <target state="translated">C 다시 쓰기는 Git 버전 2.22 (및 Windows 용 Git 버전 2.19)에 처음 포함됩니다. 이 옵션은 다시 쓰기에서 버그가 발견 될 경우 레거시 버전을 다시 활성화하는 이스케이프 해치 역할을합니다. 이 옵션과 &lt;a href=&quot;git-stash&quot;&gt;git-stash [1]&lt;/a&gt; 의 쉘 스크립트 버전은 향후 릴리스에서 제거 될 예정입니다.</target>
        </trans-unit>
        <trans-unit id="dbe462d7e2f126482bf0dec3d004def2c9c89bb6" translate="yes" xml:space="preserve">
          <source>The CVS module you want to import. Relative to &amp;lt;CVSROOT&amp;gt;. If not given, &lt;code&gt;git cvsimport&lt;/code&gt; tries to read it from &lt;code&gt;CVS/Repository&lt;/code&gt;.</source>
          <target state="translated">가져올 CVS 모듈 &amp;lt;CVSROOT&amp;gt;와 관련이 있습니다. 지정하지 않으면 &lt;code&gt;git cvsimport&lt;/code&gt; 는 &lt;code&gt;CVS/Repository&lt;/code&gt; 에서 읽습니다 .</target>
        </trans-unit>
        <trans-unit id="d9fdb00c7bf3f2937ed399ea5a7eb5783533387f" translate="yes" xml:space="preserve">
          <source>The Event Format Target</source>
          <target state="translated">이벤트 형식 대상</target>
        </trans-unit>
        <trans-unit id="91f31eeacecff37ec38db2aff37269235d7422bb" translate="yes" xml:space="preserve">
          <source>The GIT_TRACE_&amp;lt;key&amp;gt; mechanism allows each &amp;lt;key&amp;gt; to write to a different file (in addition to just stderr).</source>
          <target state="translated">GIT_TRACE_ &amp;lt;key&amp;gt; 메커니즘을 사용하면 각 &amp;lt;key&amp;gt;가 다른 파일에 쓸 수 있습니다 (stderr뿐 아니라).</target>
        </trans-unit>
        <trans-unit id="eb9c24f633d0777727caf33c8ede260c0246d232" translate="yes" xml:space="preserve">
          <source>The GPG key ID of the key that signed the push certificate.</source>
          <target state="translated">푸시 인증서에 서명 한 키의 GPG 키 ID입니다.</target>
        </trans-unit>
        <trans-unit id="7fd047e9e0dcddc0ec24d2bfa4a8d0b4477b60c4" translate="yes" xml:space="preserve">
          <source>The Git Repository</source>
          <target state="translated">힘내 리포지토리</target>
        </trans-unit>
        <trans-unit id="ec69c4a3fd32f0743df23ab218ec13475fdae8cc" translate="yes" xml:space="preserve">
          <source>The Git configuration file contains a number of variables that affect the Git commands' behavior. The files &lt;code&gt;.git/config&lt;/code&gt; and optionally &lt;code&gt;config.worktree&lt;/code&gt; (see &lt;code&gt;extensions.worktreeConfig&lt;/code&gt; below) in each repository are used to store the configuration for that repository, and &lt;code&gt;$HOME/.gitconfig&lt;/code&gt; is used to store a per-user configuration as fallback values for the &lt;code&gt;.git/config&lt;/code&gt; file. The file &lt;code&gt;/etc/gitconfig&lt;/code&gt; can be used to store a system-wide default configuration.</source>
          <target state="translated">Git 구성 파일에는 Git 명령의 동작에 영향을주는 여러 변수가 포함되어 있습니다. 각 저장소의 &lt;code&gt;.git/config&lt;/code&gt; 및 선택적으로 &lt;code&gt;config.worktree&lt;/code&gt; 파일 (아래 &lt;code&gt;extensions.worktreeConfig&lt;/code&gt; 참조)은 해당 저장소의 구성을 저장하는 데 사용되고 &lt;code&gt;$HOME/.gitconfig&lt;/code&gt; 는 사용자 별 구성을 대체 값으로 저장하는 데 사용됩니다. &lt;code&gt;.git/config&lt;/code&gt; 파일. &lt;code&gt;/etc/gitconfig&lt;/code&gt; 파일 을 사용하여 시스템 전체 기본 구성을 저장할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c4676de1f2b8af7673ad60d0d802fc7e29d8da30" translate="yes" xml:space="preserve">
          <source>The Git object directory contains a &lt;code&gt;pack&lt;/code&gt; directory containing packfiles (with suffix &quot;.pack&quot;) and pack-indexes (with suffix &quot;.idx&quot;). The pack-indexes provide a way to lookup objects and navigate to their offset within the pack, but these must come in pairs with the packfiles. This pairing depends on the file names, as the pack-index differs only in suffix with its pack- file. While the pack-indexes provide fast lookup per packfile, this performance degrades as the number of packfiles increases, because abbreviations need to inspect every packfile and we are more likely to have a miss on our most-recently-used packfile. For some large repositories, repacking into a single packfile is not feasible due to storage space or excessive repack times.</source>
          <target state="translated">Git 객체 디렉토리에는 packfiles (접미사 &quot;.pack&quot;)와 pack-indexes (접미사 &quot;.idx&quot;) 가 들어있는 &lt;code&gt;pack&lt;/code&gt; 디렉토리가 있습니다. 팩 인덱스는 팩 내에서 객체를 찾고 오프셋으로 이동하는 방법을 제공하지만 팩 파일과 쌍을 이루어야합니다. pack-index는 pack- 파일의 접미사 만 다르기 때문에이 쌍은 파일 이름에 따라 다릅니다. 팩 인덱스는 팩 파일 당 빠른 조회를 제공하지만 약어는 모든 팩 파일을 검사해야하고 가장 최근에 사용 된 팩 파일을 놓칠 가능성이 높기 때문에 팩 파일 수가 증가함에 따라 성능이 저하됩니다. 일부 큰 리포지토리의 경우 저장 공간이나 과도한 재 포장 시간으로 인해 단일 팩 파일로 재 포장 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="a2329c4ac9f08d776040ac221ffa562b7323c3f6" translate="yes" xml:space="preserve">
          <source>The Git protocol gives better performance and reliability, but on a host with a web server set up, HTTP exports may be simpler to set up.</source>
          <target state="translated">Git 프로토콜은 더 나은 성능과 안정성을 제공하지만 웹 서버가 설정된 호스트에서 HTTP 내보내기를 설정하는 것이 더 간단 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1179b23d825b14c0a26acd1779bd21e4b7a2880e" translate="yes" xml:space="preserve">
          <source>The Git remote to import this CVS repository into. Moves all CVS branches into remotes/&amp;lt;remote&amp;gt;/&amp;lt;branch&amp;gt; akin to the way &lt;code&gt;git clone&lt;/code&gt; uses &lt;code&gt;origin&lt;/code&gt; by default.</source>
          <target state="translated">이 CVS 저장소를 가져올 Git 원격. &lt;code&gt;git clone&lt;/code&gt; 이 기본적으로 &lt;code&gt;origin&lt;/code&gt; 을 사용 하는 방식과 유사하게 모든 CVS 분기를 remotes / &amp;lt;remote&amp;gt; / &amp;lt;branch&amp;gt;로 이동합니다 .</target>
        </trans-unit>
        <trans-unit id="bd47eb27f30e04cbdc75cd21789edadd8836d3bb" translate="yes" xml:space="preserve">
          <source>The Git repository browser</source>
          <target state="translated">Git 리포지토리 브라우저</target>
        </trans-unit>
        <trans-unit id="076055123196294023f50dc3852a8243be06956f" translate="yes" xml:space="preserve">
          <source>The Git repository browser. Shows branches, commit history and file differences. gitk is the utility started by &lt;code&gt;git gui&lt;/code&gt;'s Repository Visualize actions.</source>
          <target state="translated">Git 리포지토리 브라우저. 브랜치, 커밋 히스토리 및 파일 차이를 보여줍니다. gitk는 &lt;code&gt;git gui&lt;/code&gt; 의 Repository Visualize 액션에 의해 시작된 유틸리티 입니다.</target>
        </trans-unit>
        <trans-unit id="703dfd23887a83d4329e915dd0bcbd7608c6b6a7" translate="yes" xml:space="preserve">
          <source>The Git repository to import to. If the directory doesn&amp;rsquo;t exist, it will be created. Default is the current directory.</source>
          <target state="translated">가져올 Git 저장소. 디렉토리가 존재하지 않으면 작성됩니다. 기본값은 현재 디렉토리입니다.</target>
        </trans-unit>
        <trans-unit id="6970e04ce98d2b4a3b2c6e8de2880e4a745e2c4f" translate="yes" xml:space="preserve">
          <source>The HEAD then refers to the SHA-1 of the commit instead of to a branch, and git branch shows that you are no longer on a branch:</source>
          <target state="translated">그러면 HEAD는 브랜치 대신 커밋의 SHA-1을 참조하고 git 브랜치는 더 이상 브랜치에 있지 않음을 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="895d60d2bce01273de11df4a950c78fe3184bcf0" translate="yes" xml:space="preserve">
          <source>The HTTP USER_AGENT string presented to an HTTP server. The default value represents the version of the client Git such as git/1.7.1. This option allows you to override this value to a more common value such as Mozilla/4.0. This may be necessary, for instance, if connecting through a firewall that restricts HTTP connections to a set of common USER_AGENT strings (but not including those like git/1.7.1). Can be overridden by the &lt;code&gt;GIT_HTTP_USER_AGENT&lt;/code&gt; environment variable.</source>
          <target state="translated">HTTP USER_AGENT 문자열이 HTTP 서버에 제공되었습니다. 기본값은 git / 1.7.1과 같은 클라이언트 Git의 버전을 나타냅니다. 이 옵션을 사용하면이 값을 Mozilla / 4.0과 같은보다 일반적인 값으로 대체 할 수 있습니다. 예를 들어, HTTP 연결을 공통 USER_AGENT 문자열 세트로 제한하는 방화벽을 통해 연결하는 경우 (git / 1.7.1과 같은 문자열은 제외) 필요할 수 있습니다. &lt;code&gt;GIT_HTTP_USER_AGENT&lt;/code&gt; 환경 변수 로 대체 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="00aa9820c66c0255936f6c8707aec2ad36a5c140" translate="yes" xml:space="preserve">
          <source>The HTTP daemon command-line that will be executed. Command-line options may be specified here, and the configuration file will be added at the end of the command-line. Currently apache2, lighttpd, mongoose, plackup, python and webrick are supported. (Default: lighttpd)</source>
          <target state="translated">실행될 HTTP 데몬 명령 줄. 여기서 명령 줄 옵션을 지정할 수 있으며 구성 파일은 명령 줄 끝에 추가됩니다. 현재 apache2, lighttpd, mongoose, plackup, python 및 webrick이 지원됩니다. (기본값 : lighttpd)</target>
        </trans-unit>
        <trans-unit id="adee6c32cf5372a9cc214e1cabc3f604f4a421cf" translate="yes" xml:space="preserve">
          <source>The HTTP daemon command-line to start gitweb on your working repository. See &lt;a href=&quot;git-instaweb&quot;&gt;git-instaweb[1]&lt;/a&gt;.</source>
          <target state="translated">작업 저장소에서 gitweb을 시작하기위한 HTTP 데몬 명령 줄. &lt;a href=&quot;git-instaweb&quot;&gt;git-instaweb [1]을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="a20118bebd861685578a19065b0fb24ab670ec89" translate="yes" xml:space="preserve">
          <source>The MIDX file format uses a chunk-based approach (similar to the commit-graph file) that allows optional data to be added.</source>
          <target state="translated">MIDX 파일 형식은 선택적인 데이터를 추가 할 수있는 청크 기반 접근 방식 (커밋 그래프 파일과 유사)을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="64e372cd9f501c41226d338629f4adfe7884c507" translate="yes" xml:space="preserve">
          <source>The MIDX is stored in a file named &lt;code&gt;multi-pack-index&lt;/code&gt; in the .git/objects/pack directory. This could be stored in the pack directory of an alternate. It refers only to packfiles in that same directory.</source>
          <target state="translated">MIDX는 .git / objects / pack 디렉토리의 &lt;code&gt;multi-pack-index&lt;/code&gt; 라는 파일에 저장됩니다 . 이것은 대체의 pack 디렉토리에 저장 될 수 있습니다. 동일한 디렉토리에있는 팩 파일 만 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="be240040a2b303919e9f8b3f8c55bd2d4b871823" translate="yes" xml:space="preserve">
          <source>The MIDX keeps only one record per object ID. If an object appears in multiple packfiles, then the MIDX selects the copy in the most- recently modified packfile.</source>
          <target state="translated">MIDX는 객체 ID 당 하나의 레코드 만 유지합니다. 객체가 여러 팩 파일에 나타나는 경우 MIDX는 가장 최근에 수정 된 팩 파일에서 사본을 선택합니다.</target>
        </trans-unit>
        <trans-unit id="d248ab48f510e2fbd4b16391dc71868ce2bb9eb7" translate="yes" xml:space="preserve">
          <source>The MUA corrupted your patch; &quot;am&quot; would complain that the patch does not apply. Look in the .git/rebase-apply/ subdirectory and see what &lt;code&gt;patch&lt;/code&gt; file contains and check for the common corruption patterns mentioned above.</source>
          <target state="translated">MUA가 패치를 손상 시켰습니다. &quot;am&quot;은 패치가 적용되지 않는다고 불평합니다. .git / rebase-apply / 서브 디렉토리에서 &lt;code&gt;patch&lt;/code&gt; 파일에 어떤 패치 파일이 포함되어 있는지 확인하고 위에서 언급 한 일반적인 손상 패턴을 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="dcfedffa2e791a211c838c6711816e41fded8f05" translate="yes" xml:space="preserve">
          <source>The Normal Format Target</source>
          <target state="translated">일반 형식 대상</target>
        </trans-unit>
        <trans-unit id="500d32200a061b0c3eb8acb59a37b1ba3087273e" translate="yes" xml:space="preserve">
          <source>The Object Database</source>
          <target state="translated">객체 데이터베이스</target>
        </trans-unit>
        <trans-unit id="b3b387e6e23160b9001074a3b231e88c333277a0" translate="yes" xml:space="preserve">
          <source>The PERF target is intended for interactive performance analysis during development and is quite noisy.</source>
          <target state="translated">PERF 목표는 개발 중 대화 형 성능 분석을위한 것이며 시끄 럽습니다.</target>
        </trans-unit>
        <trans-unit id="716ba6c2a540215443944eab8349af10087e97bb" translate="yes" xml:space="preserve">
          <source>The Performance Format Target</source>
          <target state="translated">성능 형식 목표</target>
        </trans-unit>
        <trans-unit id="ca04878afc5a61720c26b830b963e827e884a4f1" translate="yes" xml:space="preserve">
          <source>The SSL version to use when negotiating an SSL connection, if you want to force the default. The available and default version depend on whether libcurl was built against NSS or OpenSSL and the particular configuration of the crypto library in use. Internally this sets the &lt;code&gt;CURLOPT_SSL_VERSION&lt;/code&gt; option; see the libcurl documentation for more details on the format of this option and for the ssl version supported. Actually the possible values of this option are:</source>
          <target state="translated">기본값을 강제로 적용하려는 경우 SSL 연결을 협상 할 때 사용할 SSL 버전입니다. 사용 가능한 기본 버전은 libcurl이 NSS 또는 OpenSSL을 기반으로 구축되었는지 여부와 사용중인 암호화 라이브러리의 특정 구성에 따라 다릅니다. 내부적으로 &lt;code&gt;CURLOPT_SSL_VERSION&lt;/code&gt; 옵션 이 설정됩니다 . 이 옵션의 형식과 지원되는 SSL 버전에 대한 자세한 내용은 libcurl 설명서를 참조하십시오. 실제로이 옵션의 가능한 값은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="6c8d77384dcf5927fceefc0c82e6aa35599c0a0b" translate="yes" xml:space="preserve">
          <source>The Trace2 API can be used to print debug, performance, and telemetry information to stderr or a file. The Trace2 feature is inactive unless explicitly enabled by enabling one or more Trace2 Targets.</source>
          <target state="translated">Trace2 API를 사용하여 디버그, 성능 및 원격 분석 정보를 stderr 또는 파일로 인쇄 할 수 있습니다. 하나 이상의 Trace2 대상을 활성화하여 명시 적으로 활성화하지 않으면 Trace2 기능이 비활성화됩니다.</target>
        </trans-unit>
        <trans-unit id="6bdbd91221731e97e635f28174406bd894d81047" translate="yes" xml:space="preserve">
          <source>The Trace2 API defines a set of high-level messages with known fields, such as (&lt;code&gt;start&lt;/code&gt;: &lt;code&gt;argv&lt;/code&gt;) and (&lt;code&gt;exit&lt;/code&gt;: {&lt;code&gt;exit-code&lt;/code&gt;, &lt;code&gt;elapsed-time&lt;/code&gt;}).</source>
          <target state="translated">Trace2 API는 ( &lt;code&gt;start&lt;/code&gt; : &lt;code&gt;argv&lt;/code&gt; ) 및 ( &lt;code&gt;exit&lt;/code&gt; : { &lt;code&gt;exit-code&lt;/code&gt; , &lt;code&gt;elapsed-time&lt;/code&gt; }) 과 같이 알려진 필드가있는 상위 레벨 메시지 세트를 정의합니다 .</target>
        </trans-unit>
        <trans-unit id="c8d932fd39b46f7d652bfdd2be6511ab09fc4671" translate="yes" xml:space="preserve">
          <source>The Trace2 API is intended to replace the existing (Trace1) printf-style tracing provided by the existing &lt;code&gt;GIT_TRACE&lt;/code&gt; and &lt;code&gt;GIT_TRACE_PERFORMANCE&lt;/code&gt; facilities. During initial implementation, Trace2 and Trace1 may operate in parallel.</source>
          <target state="translated">Trace2 API는 기존 &lt;code&gt;GIT_TRACE&lt;/code&gt; 및 &lt;code&gt;GIT_TRACE_PERFORMANCE&lt;/code&gt; 기능이 제공하는 기존 (Trace1) printf 스타일 추적을 대체하기위한 것 입니다. 초기 구현 중에 Trace2와 Trace1이 병렬로 작동 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a5397d7e9698d7ad87ff097450bf8a8e1a772416" translate="yes" xml:space="preserve">
          <source>The Trace2 code also defines a set of private functions and data types in the &lt;code&gt;trace2/&lt;/code&gt; directory. These symbols are prefixed with &lt;code&gt;tr2_&lt;/code&gt; and should only be used by functions in &lt;code&gt;trace2.c&lt;/code&gt;.</source>
          <target state="translated">Trace2 코드는 &lt;code&gt;trace2/&lt;/code&gt; 디렉토리 에 개인 함수 및 데이터 유형 세트도 정의합니다 . 이 기호는 접두사가 &lt;code&gt;tr2_&lt;/code&gt; 이고 &lt;code&gt;trace2.c&lt;/code&gt; 의 함수 만 사용해야합니다 .</target>
        </trans-unit>
        <trans-unit id="8e231fe7d9a0eb53151c1a418399ded2fd9db9e8" translate="yes" xml:space="preserve">
          <source>The URL for a submodule. This variable is copied from the .gitmodules file to the git config via &lt;code&gt;git submodule init&lt;/code&gt;. The user can change the configured URL before obtaining the submodule via &lt;code&gt;git submodule update&lt;/code&gt;. If neither submodule.&amp;lt;name&amp;gt;.active or submodule.active are set, the presence of this variable is used as a fallback to indicate whether the submodule is of interest to git commands. See &lt;a href=&quot;git-submodule&quot;&gt;git-submodule[1]&lt;/a&gt; and &lt;a href=&quot;gitmodules&quot;&gt;gitmodules[5]&lt;/a&gt; for details.</source>
          <target state="translated">하위 모듈의 URL입니다. 이 변수는 &lt;code&gt;git submodule init&lt;/code&gt; 를 통해 .gitmodules 파일에서 git config로 복사됩니다 . 사용자는 &lt;code&gt;git submodule update&lt;/code&gt; 를 통해 서브 모듈을 얻기 전에 구성된 URL을 변경할 수 있습니다 . submodule. &amp;lt;name&amp;gt; .active 또는 submodule.active가 설정되지 않은 경우이 변수의 존재는 하위 모듈이 git 명령에 관심이 있는지 여부를 나타내는 대체로 사용됩니다. 자세한 내용은 &lt;a href=&quot;git-submodule&quot;&gt;git-submodule [1]&lt;/a&gt; 및 &lt;a href=&quot;gitmodules&quot;&gt;gitmodules [5]&lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="307f8458b88cd1196dc3047eb250fdb8e3348b46" translate="yes" xml:space="preserve">
          <source>The URL of a remote repository. See &lt;a href=&quot;git-fetch&quot;&gt;git-fetch[1]&lt;/a&gt; or &lt;a href=&quot;git-push&quot;&gt;git-push[1]&lt;/a&gt;.</source>
          <target state="translated">원격 저장소의 URL입니다. 참조 &lt;a href=&quot;git-fetch&quot;&gt;[1] 자식 페치&lt;/a&gt; 또는 &lt;a href=&quot;git-push&quot;&gt;자식 푸시 [1]&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="92c06c873fe7803ddcdb456ba837dbd24d10b389" translate="yes" xml:space="preserve">
          <source>The URL to the remote repository.</source>
          <target state="translated">원격 저장소의 URL입니다.</target>
        </trans-unit>
        <trans-unit id="846d99295948de526a5621f0a520c5a9a78af747" translate="yes" xml:space="preserve">
          <source>The Workflow</source>
          <target state="translated">워크 플로우</target>
        </trans-unit>
        <trans-unit id="91d8165377483e9123ecf4a3d5455b3b1999d185" translate="yes" xml:space="preserve">
          <source>The above can also be written as simply</source>
          <target state="translated">위도 간단하게 쓸 수 있습니다</target>
        </trans-unit>
        <trans-unit id="13c712cb6756cc53fb3407886d0503d18cb537c0" translate="yes" xml:space="preserve">
          <source>The above command copies all branches from the remote refs/heads/ namespace and stores them to the local refs/remotes/origin/ namespace, unless the branch.&amp;lt;name&amp;gt;.fetch option is used to specify a non-default refspec.</source>
          <target state="translated">위의 명령은 기본 refspec을 지정하는 데 branch. &amp;lt;name&amp;gt; .fetch 옵션을 사용하지 않으면 원격 refs / heads / 네임 스페이스에서 모든 분기를 복사하여 로컬 refs / remotes / origin / 네임 스페이스에 저장합니다.</target>
        </trans-unit>
        <trans-unit id="61e1efd32cbb415eea7b734b98558317a6d1aac3" translate="yes" xml:space="preserve">
          <source>The above command would change the origin repository to</source>
          <target state="translated">위의 명령은 원본 저장소를</target>
        </trans-unit>
        <trans-unit id="cc504649b9359e7717badcdf0f10e04d6127c3a0" translate="yes" xml:space="preserve">
          <source>The above configuration expects your public repositories to live under &lt;code&gt;/pub/git&lt;/code&gt; and will serve them as &lt;code&gt;http://git.domain.org/dir-under-pub-git&lt;/code&gt;, both as clonable Git URL and as browseable gitweb interface. If you then start your &lt;a href=&quot;git-daemon&quot;&gt;git-daemon[1]&lt;/a&gt; with &lt;code&gt;--base-path=/pub/git --export-all&lt;/code&gt; then you can even use the &lt;code&gt;git://&lt;/code&gt; URL with exactly the same path.</source>
          <target state="translated">위의 구성은 퍼블릭 리포지토리가 &lt;code&gt;/pub/git&lt;/code&gt; 아래에 있어야 하며 복제 가능한 Git URL과 탐색 가능한 gitweb 인터페이스 로 &lt;code&gt;http://git.domain.org/dir-under-pub-git&lt;/code&gt; 으로 제공됩니다. 그런 다음 시작하면 &lt;a href=&quot;git-daemon&quot;&gt;자식 - 데몬 [1]&lt;/a&gt; 로 &lt;code&gt;--base-path=/pub/git --export-all&lt;/code&gt; 당신도 사용할 수있는 &lt;code&gt;git://&lt;/code&gt; URL 정확히 같은 경로.</target>
        </trans-unit>
        <trans-unit id="baa5f35656f9b3f3ba646932132fa97233a197b9" translate="yes" xml:space="preserve">
          <source>The above is all you need to know to resolve a simple merge. But Git also provides more information to help resolve conflicts:</source>
          <target state="translated">위의 간단한 병합을 해결하기 위해 알아야 할 모든 것입니다. 그러나 Git은 충돌 해결에 도움이되는 추가 정보도 제공합니다.</target>
        </trans-unit>
        <trans-unit id="70fce3bc08ea4ed40bcc99c52f88c26bd24f0b87" translate="yes" xml:space="preserve">
          <source>The above is the description of a Git merge at the lowest level, to help you understand what conceptually happens under the hood. In practice, nobody, not even Git itself, runs &lt;code&gt;git cat-file&lt;/code&gt; three times for this. There is a &lt;code&gt;git merge-index&lt;/code&gt; program that extracts the stages to temporary files and calls a &quot;merge&quot; script on it:</source>
          <target state="translated">위의 내용은 Git 병합에 대한 설명입니다. 실제로 Git 자체조차도 아무도 &lt;code&gt;git cat-file&lt;/code&gt; 을 세 번 실행하지 않습니다 . 이 &lt;code&gt;git merge-index&lt;/code&gt; 추출물 임시 파일에 대한 단계를하고 그 위에 &quot;병합&quot;스크립트를 호출하는 프로그램은 :</target>
        </trans-unit>
        <trans-unit id="eb77c0d462477bf4637c28037a03befbbf605c33" translate="yes" xml:space="preserve">
          <source>The absolute path to the worktree in which the ref is checked out, if it is checked out in any linked worktree. Empty string otherwise.</source>
          <target state="translated">연결된 작업 트리에서 체크 아웃 된 경우 참조가 체크 아웃되는 작업 트리의 절대 경로입니다. 그렇지 않으면 빈 문자열입니다.</target>
        </trans-unit>
        <trans-unit id="76cd9fb4bfcc53cf44ccfea4ed1923acc958405e" translate="yes" xml:space="preserve">
          <source>The accepted attributes are &lt;code&gt;bold&lt;/code&gt;, &lt;code&gt;dim&lt;/code&gt;, &lt;code&gt;ul&lt;/code&gt;, &lt;code&gt;blink&lt;/code&gt;, &lt;code&gt;reverse&lt;/code&gt;, &lt;code&gt;italic&lt;/code&gt;, and &lt;code&gt;strike&lt;/code&gt; (for crossed-out or &quot;strikethrough&quot; letters). The position of any attributes with respect to the colors (before, after, or in between), doesn&amp;rsquo;t matter. Specific attributes may be turned off by prefixing them with &lt;code&gt;no&lt;/code&gt; or &lt;code&gt;no-&lt;/code&gt; (e.g., &lt;code&gt;noreverse&lt;/code&gt;, &lt;code&gt;no-ul&lt;/code&gt;, etc).</source>
          <target state="translated">허용되는 속성은 &lt;code&gt;bold&lt;/code&gt; , &lt;code&gt;dim&lt;/code&gt; , &lt;code&gt;ul&lt;/code&gt; , &lt;code&gt;blink&lt;/code&gt; , &lt;code&gt;reverse&lt;/code&gt; , &lt;code&gt;italic&lt;/code&gt; 및 &lt;code&gt;strike&lt;/code&gt; (교차 문자 또는 &quot; 파업 문자&quot;)입니다. 색상 (전, 후 또는 사이)에 대한 속성의 위치는 중요하지 않습니다. 접두사로 &lt;code&gt;no&lt;/code&gt; 또는 &lt;code&gt;no-&lt;/code&gt; 를 붙임으로써 특정 속성을 끌 수 있습니다 (예 : &lt;code&gt;noreverse&lt;/code&gt; , &lt;code&gt;no-ul&lt;/code&gt; 등).</target>
        </trans-unit>
        <trans-unit id="0bb8a69a5cde6b982a60a95e4956ebdf1a59fa5f" translate="yes" xml:space="preserve">
          <source>The accepted patterns in the cone pattern set are:</source>
          <target state="translated">원뿔 패턴 세트에서 허용되는 패턴은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="ec26e1bb6d1ddd903fea6ea4b1aec39f9a4bdff7" translate="yes" xml:space="preserve">
          <source>The action of fixing up manually what a failed automatic &lt;a href=&quot;#def_merge&quot;&gt;merge&lt;/a&gt; left behind.</source>
          <target state="translated">실패한 자동 &lt;a href=&quot;#def_merge&quot;&gt;병합이&lt;/a&gt; 남은 것을 수동으로 수정하는 작업 .</target>
        </trans-unit>
        <trans-unit id="91929f919cdca3ddad9711d4446a1108e24ab05c" translate="yes" xml:space="preserve">
          <source>The action of updating all or part of the &lt;a href=&quot;#def_working_tree&quot;&gt;working tree&lt;/a&gt; with a &lt;a href=&quot;#def_tree_object&quot;&gt;tree object&lt;/a&gt; or &lt;a href=&quot;#def_blob_object&quot;&gt;blob&lt;/a&gt; from the &lt;a href=&quot;#def_object_database&quot;&gt;object database&lt;/a&gt;, and updating the &lt;a href=&quot;#def_index&quot;&gt;index&lt;/a&gt; and &lt;a href=&quot;#def_HEAD&quot;&gt;HEAD&lt;/a&gt; if the whole working tree has been pointed at a new &lt;a href=&quot;#def_branch&quot;&gt;branch&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#def_working_tree&quot;&gt;작업 트리&lt;/a&gt; 의 전체 또는 일부가 새 &lt;a href=&quot;#def_branch&quot;&gt;분기를&lt;/a&gt; 가리키면 작업 트리의 전체 또는 일부를 &lt;a href=&quot;#def_object_database&quot;&gt;개체 데이터베이스&lt;/a&gt; 의 &lt;a href=&quot;#def_tree_object&quot;&gt;트리 개체&lt;/a&gt; 또는 &lt;a href=&quot;#def_blob_object&quot;&gt;얼룩&lt;/a&gt; 으로 업데이트하고 &lt;a href=&quot;#def_index&quot;&gt;인덱스&lt;/a&gt; 와 &lt;a href=&quot;#def_HEAD&quot;&gt;HEAD를&lt;/a&gt; 업데이트하는 작업입니다 .</target>
        </trans-unit>
        <trans-unit id="bf91c6dac7e4978798d8310657f124dd799f4bf4" translate="yes" xml:space="preserve">
          <source>The action that will be run. Defaults to &lt;code&gt;projects_list&lt;/code&gt; if repo is not set, and to &lt;code&gt;summary&lt;/code&gt; otherwise.</source>
          <target state="translated">실행될 조치입니다. repo가 ​​설정되지 않은 경우 기본값은 &lt;code&gt;projects_list&lt;/code&gt; 이고 그렇지 않으면 &lt;code&gt;summary&lt;/code&gt; 됩니다.</target>
        </trans-unit>
        <trans-unit id="e262b52287502541a33fa85d5cf2fdae897da448" translate="yes" xml:space="preserve">
          <source>The active branch LRU, when coupled with the filename string pool and lazy loading of subtrees, allows fast-import to efficiently import projects with 2,000+ branches and 45,114+ files in a very limited memory footprint (less than 2.7 MiB per active branch).</source>
          <target state="translated">활성 분기 LRU는 파일 이름 문자열 풀 및 하위 트리의 느린로드와 결합 될 때 매우 제한된 메모리 공간 (활성 분기당 2.7 MiB 미만)으로 2,000 개 이상의 분기와 45,114 개 이상의 파일이있는 프로젝트를 빠르게 가져올 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5b37048d4139b83b97c29aa7a22d2da66c283ae2" translate="yes" xml:space="preserve">
          <source>The actual configuration line should be on one line.</source>
          <target state="translated">실제 구성 줄은 한 줄에 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="b70c0ba474f3173fff896ac2745af10a69e6cc3b" translate="yes" xml:space="preserve">
          <source>The additional AliasMatch makes it so that</source>
          <target state="translated">추가 AliasMatch를 통해</target>
        </trans-unit>
        <trans-unit id="d6139a3bd26979c3a7767519a48aa9c385b73634" translate="yes" xml:space="preserve">
          <source>The advantage of doing this is that the history of &lt;code&gt;next&lt;/code&gt; will be clean. For example, some topics merged into &lt;code&gt;next&lt;/code&gt; may have initially looked promising, but were later found to be undesirable or premature. In such a case, the topic is reverted out of &lt;code&gt;next&lt;/code&gt; but the fact remains in the history that it was once merged and reverted. By recreating &lt;code&gt;next&lt;/code&gt;, you give another incarnation of such topics a clean slate to retry, and a feature release is a good point in history to do so.</source>
          <target state="translated">이 작업의 장점은 &lt;code&gt;next&lt;/code&gt; 역사가 깨끗 하다는 것입니다. 예를 들어, &lt;code&gt;next&lt;/code&gt; 병합 된 일부 주제 는 처음에는 유망 해 보였지만 나중에 바람직하지 않거나 조기에 발견되었습니다. 이 경우 주제는 &lt;code&gt;next&lt;/code&gt; 로 되돌아 가지만 사실은 한 번 병합되고 되돌아 간 역사에 남아 있습니다. 다시 만들어 &lt;code&gt;next&lt;/code&gt; , 다시 시도에 같은 주제의 또 다른 화신에게 백지를주고, 기능 해제 그렇게 할 역사에 좋은 지점입니다.</target>
        </trans-unit>
        <trans-unit id="2f1746fed6139a8489ee3d916322bdcbeb17e684" translate="yes" xml:space="preserve">
          <source>The advantage of using an external diff command is flexibility. You are not bound to find line-oriented changes, nor is it necessary for the output to resemble unified diff. You are free to locate and report changes in the most appropriate way for your data format.</source>
          <target state="translated">외부 diff 명령을 사용하면 얻을 수있는 이점은 유연성입니다. 라인 중심의 변경 사항을 찾아야하거나 출력이 통합 된 diff와 유사 할 필요도 없습니다. 데이터 형식에 가장 적합한 방식으로 변경 사항을 찾아보고 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="37f935f00ace4f7aca8e441adbbf1abe0704a83a" translate="yes" xml:space="preserve">
          <source>The am backend drops any &quot;empty&quot; commits, regardless of whether the commit started empty (had no changes relative to its parent to start with) or ended empty (all changes were already applied upstream in other commits).</source>
          <target state="translated">am 백엔드는 커밋이 비어 있기 시작했거나 (부모에 대한 변경 사항이 없었 음) 비어 있었는지 (모든 변경 사항이 이미 다른 커밋에서 업스트림에 적용되었는지) 여부에 관계없이 &quot;빈&quot;커밋을 삭제합니다.</target>
        </trans-unit>
        <trans-unit id="013053835d145f0cc494db8211a188c9999bae09" translate="yes" xml:space="preserve">
          <source>The area where a pair of conflicting changes happened is marked with markers &lt;code&gt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&lt;/code&gt;, &lt;code&gt;=======&lt;/code&gt;, and &lt;code&gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&lt;/code&gt;. The part before the &lt;code&gt;=======&lt;/code&gt; is typically your side, and the part afterwards is typically their side.</source>
          <target state="translated">충돌하는 한 쌍의 변경이 발생한 영역에는 마커 &lt;code&gt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&lt;/code&gt; , &lt;code&gt;=======&lt;/code&gt; 및 &lt;code&gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&lt;/code&gt; 가 표시됩니다 . &lt;code&gt;=======&lt;/code&gt; 앞 부분 은 일반적으로 당신 편이고 , 그 이후 부분은 일반적으로 그들의 편입니다.</target>
        </trans-unit>
        <trans-unit id="bbce7a566319a0fa5122538fad84df16b94a33f3" translate="yes" xml:space="preserve">
          <source>The argument to this option may be a glob on ref names, a ref, or the (possibly abbreviated) SHA-1 of a commit. Specifying a glob is equivalent to specifying this option multiple times, one for each matching ref name.</source>
          <target state="translated">이 옵션에 대한 논거는 심판 이름, 심판, 또는 커밋의 (약어) SHA-1에 대한 glob 일 수 있습니다. glob를 지정하는 것은 일치하는 각 ref 이름에 대해 하나씩이 옵션을 여러 번 지정하는 것과 같습니다.</target>
        </trans-unit>
        <trans-unit id="6083c463b2a8fa637d23cd99c59e9746cb6a7539" translate="yes" xml:space="preserve">
          <source>The attribute &lt;code&gt;diff&lt;/code&gt; affects how Git generates diffs for particular files. It can tell Git whether to generate a textual patch for the path or to treat the path as a binary file. It can also affect what line is shown on the hunk header &lt;code&gt;@@ -k,l +n,m @@&lt;/code&gt; line, tell Git to use an external command to generate the diff, or ask Git to convert binary files to a text format before generating the diff.</source>
          <target state="translated">&lt;code&gt;diff&lt;/code&gt; 속성 은 Git이 특정 파일에 대해 diff를 생성하는 방법에 영향을줍니다. 경로에 대한 텍스트 패치를 생성할지 또는 경로를 이진 파일로 처리할지 여부를 Git에 알릴 수 있습니다. 또한 펑크 헤더 &lt;code&gt;@@ -k,l +n,m @@&lt;/code&gt; 행 에 표시되는 행에 영향을 줄 수 있으며 , Git에 외부 명령을 사용하여 diff를 생성하도록 지시하거나, Git에 바이너리 파일을 텍스트 형식으로 변환하도록 요청하십시오. diff를 생성합니다.</target>
        </trans-unit>
        <trans-unit id="e3fef41e3a691b83ea57e915fd492f173e96b0ec" translate="yes" xml:space="preserve">
          <source>The attribute &lt;code&gt;merge&lt;/code&gt; affects how three versions of a file are merged when a file-level merge is necessary during &lt;code&gt;git merge&lt;/code&gt;, and other commands such as &lt;code&gt;git revert&lt;/code&gt; and &lt;code&gt;git cherry-pick&lt;/code&gt;.</source>
          <target state="translated">속성 &lt;code&gt;merge&lt;/code&gt; 은 &lt;code&gt;git merge&lt;/code&gt; 동안 파일 레벨 병합이 필요할 때 &lt;code&gt;git revert&lt;/code&gt; 및 &lt;code&gt;git cherry-pick&lt;/code&gt; 과 같은 다른 명령 이 필요한 경우 세 가지 버전의 파일이 병합되는 방식에 영향을줍니다 .</target>
        </trans-unit>
        <trans-unit id="2fe7b4a122d21c0258f6159b6aeead7d915c58b4" translate="yes" xml:space="preserve">
          <source>The attributes allow a fine-grained control, how the line endings are converted. Here is an example that will make Git normalize .txt, .vcproj and .sh files, ensure that .vcproj files have CRLF and .sh files have LF in the working directory, and prevent .jpg files from being normalized regardless of their content.</source>
          <target state="translated">이 속성을 사용하면 줄 끝이 변환되는 방식을 세밀하게 제어 할 수 있습니다. 다음은 Git을 .txt, .vcproj 및 .sh 파일로 정규화하고, .vcproj 파일에 CRLF가 있고 .sh 파일에 작업 디렉토리에 LF가 있는지 확인하고, 내용에 관계없이 .jpg 파일이 정규화되는 것을 방지하는 예제입니다.</target>
        </trans-unit>
        <trans-unit id="0849ab3d36b0ce6d3f6183dc21f6e83ad1520176" translate="yes" xml:space="preserve">
          <source>The author name and email address to use when no author information can be found in the patch description.</source>
          <target state="translated">패치 정보에서 저자 정보가 없을 때 사용할 저자 이름과 이메일 주소.</target>
        </trans-unit>
        <trans-unit id="b012a2641006f12bad01716515743698d7deabe2" translate="yes" xml:space="preserve">
          <source>The author of a piece of code.</source>
          <target state="translated">코드 조각의 저자.</target>
        </trans-unit>
        <trans-unit id="147440e8e5aa984c82659720dc655a2dca5add95" translate="yes" xml:space="preserve">
          <source>The backend process sets GIT_COMMITTER_NAME to &lt;code&gt;$REMOTE_USER&lt;/code&gt; and GIT_COMMITTER_EMAIL to &lt;code&gt;${REMOTE_USER}@http.${REMOTE_ADDR}&lt;/code&gt;, ensuring that any reflogs created by &lt;code&gt;git-receive-pack&lt;/code&gt; contain some identifying information of the remote user who performed the push.</source>
          <target state="translated">백엔드 프로세스는 GIT_COMMITTER_NAME을 &lt;code&gt;$REMOTE_USER&lt;/code&gt; , GIT_COMMITTER_EMAIL을 &lt;code&gt;${REMOTE_USER}@http.${REMOTE_ADDR}&lt;/code&gt; 으로 설정하여 &lt;code&gt;git-receive-pack&lt;/code&gt; 으로 작성된 모든 reflog 에 푸시를 수행 한 원격 사용자의 식별 정보가 포함되도록합니다.</target>
        </trans-unit>
        <trans-unit id="21e5e59ef58a1f64125adda00de18248644f6705" translate="yes" xml:space="preserve">
          <source>The base object could also be deltified if it&amp;rsquo;s in the same pack. Ref-delta can also refer to an object outside the pack (i.e. the so-called &quot;thin pack&quot;). When stored on disk however, the pack should be self contained to avoid cyclic dependency.</source>
          <target state="translated">기본 팩이 동일한 팩에있는 경우 기본 객체를 제거 할 수도 있습니다. Ref-delta는 또한 팩 외부의 객체 (즉, &quot;얇은 팩&quot;)를 가리킬 수도 있습니다. 그러나 디스크에 저장 될 때 팩은 주기적 종속성을 피하기 위해 자체 포함되어야합니다.</target>
        </trans-unit>
        <trans-unit id="1877d075d52f12eee201f2607da0c072a35f24bc" translate="yes" xml:space="preserve">
          <source>The base tree information block is used for maintainers or third party testers to know the exact state the patch series applies to. It consists of the &lt;code&gt;base commit&lt;/code&gt;, which is a well-known commit that is part of the stable part of the project history everybody else works off of, and zero or more &lt;code&gt;prerequisite patches&lt;/code&gt;, which are well-known patches in flight that is not yet part of the &lt;code&gt;base commit&lt;/code&gt; that need to be applied on top of &lt;code&gt;base commit&lt;/code&gt; in topological order before the patches can be applied.</source>
          <target state="translated">기본 트리 정보 블록은 유지 관리자 또는 타사 테스터가 패치 시리즈가 적용되는 정확한 상태를 알기 위해 사용됩니다. 그것은 구성 &lt;code&gt;base commit&lt;/code&gt; 잘 알려진 그 다른 프로젝트 역사 모두의 안정적인 부분의 일부의 오프 작동 커밋이다, 0 개 이상의 &lt;code&gt;prerequisite patches&lt;/code&gt; 아직없는 비행 패치를 잘 알려져있다, 패치를 적용하기 전에 &lt;code&gt;base commit&lt;/code&gt; 위에 토폴로지 순서 로 적용해야하는 &lt;code&gt;base commit&lt;/code&gt; 일부 .</target>
        </trans-unit>
        <trans-unit id="dc39b1b9637026dfb15dfa743421fbe1dc2277e7" translate="yes" xml:space="preserve">
          <source>The basic colors accepted are &lt;code&gt;normal&lt;/code&gt;, &lt;code&gt;black&lt;/code&gt;, &lt;code&gt;red&lt;/code&gt;, &lt;code&gt;green&lt;/code&gt;, &lt;code&gt;yellow&lt;/code&gt;, &lt;code&gt;blue&lt;/code&gt;, &lt;code&gt;magenta&lt;/code&gt;, &lt;code&gt;cyan&lt;/code&gt; and &lt;code&gt;white&lt;/code&gt;. The first color given is the foreground; the second is the background.</source>
          <target state="translated">허용되는 기본 색상은 &lt;code&gt;normal&lt;/code&gt; , &lt;code&gt;black&lt;/code&gt; , &lt;code&gt;red&lt;/code&gt; , &lt;code&gt;green&lt;/code&gt; , &lt;code&gt;yellow&lt;/code&gt; , &lt;code&gt;blue&lt;/code&gt; , &lt;code&gt;magenta&lt;/code&gt; , &lt;code&gt;cyan&lt;/code&gt; 및 &lt;code&gt;white&lt;/code&gt; 입니다. 주어진 첫 번째 색상은 전경입니다. 두 번째는 배경입니다.</target>
        </trans-unit>
        <trans-unit id="d4e1b119ab89bbecfc6f0f5d854268dcecbb088f" translate="yes" xml:space="preserve">
          <source>The basic form described in DESCRIPTION with a Git directory, a working directory, a &lt;code&gt;gitlink&lt;/code&gt;, and a &lt;code&gt;.gitmodules&lt;/code&gt; entry.</source>
          <target state="translated">Git 디렉토리, 작업 디렉토리, &lt;code&gt;gitlink&lt;/code&gt; 및 &lt;code&gt;.gitmodules&lt;/code&gt; 항목 과 함께 DESCRIPTION에 설명 된 기본 양식 .</target>
        </trans-unit>
        <trans-unit id="b21f7863c055f0aa6938a038ffa25acf7017fe84" translate="yes" xml:space="preserve">
          <source>The basic greedy diff algorithm. Currently, this is the default.</source>
          <target state="translated">욕심 많은 기본 알고리즘. 현재는 이것이 기본값입니다.</target>
        </trans-unit>
        <trans-unit id="ebbd31d9dd00322abaa4bb83a8b03f787c70d43c" translate="yes" xml:space="preserve">
          <source>The basic requirements:</source>
          <target state="translated">기본 요구 사항 :</target>
        </trans-unit>
        <trans-unit id="675f96a5f033def81701bda4e874ec2fbad8a388" translate="yes" xml:space="preserve">
          <source>The below documentation is the same as what&amp;rsquo;s found in &lt;a href=&quot;git-config&quot;&gt;git-config[1]&lt;/a&gt;:</source>
          <target state="translated">아래 문서는 &lt;a href=&quot;git-config&quot;&gt;git-config [1]에&lt;/a&gt; 있는 것과 동일합니다 .</target>
        </trans-unit>
        <trans-unit id="f55762f9996c39bda184001319965b733714f313" translate="yes" xml:space="preserve">
          <source>The best way to get one is by using the &lt;a href=&quot;git-clone&quot;&gt;git-clone[1]&lt;/a&gt; command to download a copy of an existing repository. If you don&amp;rsquo;t already have a project in mind, here are some interesting examples:</source>
          <target state="translated">하나를 얻는 가장 좋은 방법은 &lt;a href=&quot;git-clone&quot;&gt;git-clone [1]&lt;/a&gt; 명령을 사용하여 기존 리포지토리의 복사본을 다운로드하는 것입니다. 아직 프로젝트를 염두에 두지 않은 경우 몇 가지 흥미로운 예가 있습니다.</target>
        </trans-unit>
        <trans-unit id="e2b6c88cac94cf24687d4ba9657759c1ab28582a" translate="yes" xml:space="preserve">
          <source>The best way to see how this works is using the &lt;a href=&quot;gitk&quot;&gt;gitk[1]&lt;/a&gt; command; running gitk now on a Git repository and looking for merge commits will help understand how Git organizes history.</source>
          <target state="translated">이것이 어떻게 작동하는지 확인하는 가장 좋은 방법은 &lt;a href=&quot;gitk&quot;&gt;gitk [1]&lt;/a&gt; 명령을 사용하는 것입니다. 이제 Git 저장소에서 gitk를 실행하고 병합 커밋을 찾으면 Git이 히스토리를 구성하는 방법을 이해하는 데 도움이됩니다.</target>
        </trans-unit>
        <trans-unit id="8130ad227eb2e1ffe8f116dc4280c5919bb4cd97" translate="yes" xml:space="preserve">
          <source>The branch &lt;code&gt;test&lt;/code&gt; is short for &lt;code&gt;refs/heads/test&lt;/code&gt;.</source>
          <target state="translated">분기 &lt;code&gt;test&lt;/code&gt; 는 &lt;code&gt;refs/heads/test&lt;/code&gt; 약자입니다 .</target>
        </trans-unit>
        <trans-unit id="420b2dd61e4562065a5bd273fcdbaecde70d1742" translate="yes" xml:space="preserve">
          <source>The branch LRU builtin to fast-import tends to behave very well, and the cost of activating an inactive branch is so low that bouncing around between branches has virtually no impact on import performance.</source>
          <target state="translated">빠른 가져 오기에 내장 된 지점 LRU는 매우 잘 작동하는 경향이 있으며, 비활성 지점 활성화 비용이 너무 낮아서 지점 간 반송이 가져 오기 성능에 거의 영향을 미치지 않습니다.</target>
        </trans-unit>
        <trans-unit id="58be5b6cbe7d7c0a923608fe1415c68702e2aa84" translate="yes" xml:space="preserve">
          <source>The chain of operation</source>
          <target state="translated">운영 체인</target>
        </trans-unit>
        <trans-unit id="cb0b83bdafd60672fc0fb681d6c09ff33adfb7dc" translate="yes" xml:space="preserve">
          <source>The changes are still visible in the submodule&amp;rsquo;s reflog.</source>
          <target state="translated">변경 사항은 여전히 ​​서브 모듈의 reflog에서 볼 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e18a17400a7fdeb34351715eb209f43bb56b69d6" translate="yes" xml:space="preserve">
          <source>The clone command creates a new directory named after the project (&lt;code&gt;git&lt;/code&gt; or &lt;code&gt;linux&lt;/code&gt; in the examples above). After you cd into this directory, you will see that it contains a copy of the project files, called the &lt;a href=&quot;#def_working_tree&quot;&gt;working tree&lt;/a&gt;, together with a special top-level directory named &lt;code&gt;.git&lt;/code&gt;, which contains all the information about the history of the project.</source>
          <target state="translated">clone 명령은 프로젝트의 이름을 딴 새 디렉토리를 만듭니다 ( 위 예에서는 &lt;code&gt;git&lt;/code&gt; 또는 &lt;code&gt;linux&lt;/code&gt; ). 이 디렉토리로 들어가면 &lt;a href=&quot;#def_working_tree&quot;&gt;작업 트리&lt;/a&gt; 라는 프로젝트 파일의 사본과 &lt;code&gt;.git&lt;/code&gt; 이라는 특수 최상위 디렉토리 와 프로젝트 히스토리에 대한 모든 정보가 들어있는 것을 볼 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9b1ff6b6614bf65ff7cf18fa7ac8ca0c73c31da4" translate="yes" xml:space="preserve">
          <source>The command &lt;code&gt;git commit -a&lt;/code&gt; first looks at your working tree, notices that you have modified hello.c and removed goodbye.c, and performs necessary &lt;code&gt;git add&lt;/code&gt; and &lt;code&gt;git rm&lt;/code&gt; for you.</source>
          <target state="translated">&lt;code&gt;git commit -a&lt;/code&gt; 명령 은 먼저 작업 트리를보고 hello.c를 수정하고 goodbye.c를 제거한 것을 확인하고 필요한 &lt;code&gt;git add&lt;/code&gt; 및 &lt;code&gt;git rm&lt;/code&gt; 을 수행합니다.</target>
        </trans-unit>
        <trans-unit id="95cb34ce247ae47a8a7d5a122ee875bb99decb40" translate="yes" xml:space="preserve">
          <source>The command allows for creation and fast-forwarding of sha1 refs (heads/tags) on the remote end (strictly speaking, it is the local end &lt;code&gt;git-receive-pack&lt;/code&gt; runs, but to the user who is sitting at the send-pack end, it is updating the remote. Confused?)</source>
          <target state="translated">이 명령을 사용하면 원격 엔드에서 sha1 참조 (헤드 / 태그)를 작성하고 빨리 전달할 수 있습니다 (엄격히 말해서 로컬 엔드 &lt;code&gt;git-receive-pack&lt;/code&gt; 실행이지만 send-pack 엔드에 앉아있는 사용자에게는 리모컨 업데이트 중입니다. 혼란 스럽습니까?)</target>
        </trans-unit>
        <trans-unit id="2b42e9d45bef456324952e5870d272017a1a991c" translate="yes" xml:space="preserve">
          <source>The command also looks at &lt;code&gt;core.trustctime&lt;/code&gt; configuration variable. It can be useful when the inode change time is regularly modified by something outside Git (file system crawlers and backup systems use ctime for marking files processed) (see &lt;a href=&quot;git-config&quot;&gt;git-config[1]&lt;/a&gt;).</source>
          <target state="translated">이 명령은 &lt;code&gt;core.trustctime&lt;/code&gt; 구성 변수도 확인합니다. inode 변경 시간이 Git 외부의 파일에 의해 정기적으로 수정 될 때 유용합니다 (파일 시스템 크롤러 및 백업 시스템은 ctime을 사용하여 처리 된 파일을 표시 함) ( &lt;a href=&quot;git-config&quot;&gt;git-config [1] 참조&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="b2d2a0a5d3ee3b745ff8e27d667799782d3fee27" translate="yes" xml:space="preserve">
          <source>The command by default does not allow an update that is not a fast-forward to prevent such loss of history.</source>
          <target state="translated">기본적으로이 명령은 이러한 기록 손실을 방지하기 위해 빨리 감기가 아닌 업데이트를 허용하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="57bd298a9fbda93bedda739fa9a93ffd1fbe53dd" translate="yes" xml:space="preserve">
          <source>The command by default packs all tags and refs that are already packed, and leaves other refs alone. This is because branches are expected to be actively developed and packing their tips does not help performance. This option causes branch tips to be packed as well. Useful for a repository with many branches of historical interests.</source>
          <target state="translated">기본적으로이 명령은 이미 압축 된 모든 태그와 참조를 압축하고 다른 참조는 그대로 둡니다. 이는 브랜치가 적극적으로 개발되고 팁을 포장하는 것이 성능에 도움이되지 않기 때문입니다. 이 옵션을 사용하면 분기 팁도 포장됩니다. 많은 역사적 관심 분야가있는 저장소에 유용합니다.</target>
        </trans-unit>
        <trans-unit id="affc62639786f9435bc3e40b781bdaefab9bf88f" translate="yes" xml:space="preserve">
          <source>The command can also be used to restore the content in the index with &lt;code&gt;--staged&lt;/code&gt;, or restore both the working tree and the index with &lt;code&gt;--staged --worktree&lt;/code&gt;.</source>
          <target state="translated">또한이 명령으로 인덱스의 내용을 복원 할 수 있습니다 &lt;code&gt;--staged&lt;/code&gt; , 또는 작업 트리와 인덱스를 모두 복원 &lt;code&gt;--staged --worktree&lt;/code&gt; 을 .</target>
        </trans-unit>
        <trans-unit id="033264e01f6eaf7651e64aee25dc83cea3397f0e" translate="yes" xml:space="preserve">
          <source>The command finds the most recent tag that is reachable from a commit. If the tag points to the commit, then only the tag is shown. Otherwise, it suffixes the tag name with the number of additional commits on top of the tagged object and the abbreviated object name of the most recent commit. The result is a &quot;human-readable&quot; object name which can also be used to identify the commit to other git commands.</source>
          <target state="translated">이 명령은 커밋에서 도달 할 수있는 가장 최근 태그를 찾습니다. 태그가 커밋을 가리키는 경우 태그 만 표시됩니다. 그렇지 않으면 태그 된 객체 위에 추가 커밋 수와 가장 최근의 커밋의 약식 객체 이름으로 태그 이름에 접미사를 붙입니다. 결과는 다른 사람 명령에 대한 커밋을 식별하는 데 사용될 수있는 &quot;사람이 읽을 수있는&quot;객체 이름입니다.</target>
        </trans-unit>
        <trans-unit id="3ab56fbe7068ffbc29e1e09d644dcd93a3d4ced5" translate="yes" xml:space="preserve">
          <source>The command honors &lt;code&gt;color.status&lt;/code&gt; (or &lt;code&gt;status.color&lt;/code&gt; &amp;mdash; they mean the same thing and the latter is kept for backward compatibility) and &lt;code&gt;color.status.&amp;lt;slot&amp;gt;&lt;/code&gt; configuration variables to colorize its output.</source>
          <target state="translated">이 명령은 &lt;code&gt;color.status&lt;/code&gt; (또는 &lt;code&gt;status.color&lt;/code&gt; - 동일한 것을 의미하고 후자는 이전 버전과의 호환성을 위해 유지됨)와 &lt;code&gt;color.status.&amp;lt;slot&amp;gt;&lt;/code&gt; 구성 변수를 사용하여 출력을 채색합니다.</target>
        </trans-unit>
        <trans-unit id="426f574eb4223ad0c1806f2471b371a9ce2ce62b" translate="yes" xml:space="preserve">
          <source>The command honors &lt;code&gt;core.filemode&lt;/code&gt; configuration variable. If your repository is on a filesystem whose executable bits are unreliable, this should be set to &lt;code&gt;false&lt;/code&gt; (see &lt;a href=&quot;git-config&quot;&gt;git-config[1]&lt;/a&gt;). This causes the command to ignore differences in file modes recorded in the index and the file mode on the filesystem if they differ only on executable bit. On such an unfortunate filesystem, you may need to use &lt;code&gt;git update-index --chmod=&lt;/code&gt;.</source>
          <target state="translated">이 명령은 &lt;code&gt;core.filemode&lt;/code&gt; 구성 변수를 사용합니다. 저장소가 실행 가능 비트가 신뢰할 수없는 파일 시스템에있는 경우 이는 &lt;code&gt;false&lt;/code&gt; 로 설정해야합니다 ( &lt;a href=&quot;git-config&quot;&gt;git-config [1] 참조&lt;/a&gt; ). 이로 인해 명령 비트가 실행 가능 비트에서만 다른 경우 색인에 기록 된 파일 모드와 파일 시스템의 파일 모드의 차이점을 무시합니다. 이러한 불행한 파일 시스템에서는 &lt;code&gt;git update-index --chmod=&lt;/code&gt; 를 사용해야 합니다.</target>
        </trans-unit>
        <trans-unit id="1c1fbeab69cdf1a35e381ef7eff39e0ef873ae8e" translate="yes" xml:space="preserve">
          <source>The command is kept primarily for historical reasons; fingers of many people who learned Git long before &lt;code&gt;git log&lt;/code&gt; was invented by reading Linux kernel mailing list are trained to type it.</source>
          <target state="translated">명령은 주로 역사적 이유로 유지됩니다. 리눅스 커널 메일 링리스트를 읽어서 &lt;code&gt;git log&lt;/code&gt; 가 발명 되기 오래 전에 Git을 배운 많은 사람들의 손가락이 그것을 입력하도록 훈련 받았다.</target>
        </trans-unit>
        <trans-unit id="078766939aed50311c1dcee68ff982a08734592e" translate="yes" xml:space="preserve">
          <source>The command line for those commands that support taking submodules as part of their pathspecs. Most commands have a boolean flag &lt;code&gt;--recurse-submodules&lt;/code&gt; which specify whether to recurse into submodules. Examples are &lt;code&gt;grep&lt;/code&gt; and &lt;code&gt;checkout&lt;/code&gt;. Some commands take enums, such as &lt;code&gt;fetch&lt;/code&gt; and &lt;code&gt;push&lt;/code&gt;, where you can specify how submodules are affected.</source>
          <target state="translated">서브 모듈을 경로 스펙의 일부로 사용하도록 지원하는 명령의 명령 행. 대부분의 명령에는 부울 플래그 &lt;code&gt;--recurse-submodules&lt;/code&gt; 가 있으며,이 플래그 는 하위 모듈로의 재귀 여부를 지정합니다. 예는 &lt;code&gt;grep&lt;/code&gt; 및 &lt;code&gt;checkout&lt;/code&gt; 입니다. &lt;code&gt;fetch&lt;/code&gt; 및 &lt;code&gt;push&lt;/code&gt; 와 같은 일부 명령은 하위 모듈의 영향을 지정할 수있는 열거 형 을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="0c67f633874ba0fbe1af2a193c1c589167c2ab4d" translate="yes" xml:space="preserve">
          <source>The command looks at &lt;code&gt;core.ignorestat&lt;/code&gt; configuration variable. See &lt;code&gt;Using &quot;assume unchanged&quot; bit&lt;/code&gt; section above.</source>
          <target state="translated">이 명령은 &lt;code&gt;core.ignorestat&lt;/code&gt; 구성 변수를 확인합니다. 위의 &lt;code&gt;Using &quot;assume unchanged&quot; bit&lt;/code&gt; 섹션 사용을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="5f7f0d79e587cabe73eebce8a6424fb5cae3c144" translate="yes" xml:space="preserve">
          <source>The command looks at &lt;code&gt;core.ignorestat&lt;/code&gt; configuration variable. When this is true, paths updated with &lt;code&gt;git update-index paths...&lt;/code&gt; and paths updated with other Git commands that update both index and working tree (e.g. &lt;code&gt;git apply --index&lt;/code&gt;, &lt;code&gt;git checkout-index -u&lt;/code&gt;, and &lt;code&gt;git read-tree -u&lt;/code&gt;) are automatically marked as &quot;assume unchanged&quot;. Note that &quot;assume unchanged&quot; bit is &lt;strong&gt;not&lt;/strong&gt; set if &lt;code&gt;git update-index --refresh&lt;/code&gt; finds the working tree file matches the index (use &lt;code&gt;git update-index --really-refresh&lt;/code&gt; if you want to mark them as &quot;assume unchanged&quot;).</source>
          <target state="translated">이 명령은 &lt;code&gt;core.ignorestat&lt;/code&gt; 구성 변수를 확인합니다. 이것이 사실이면 &lt;code&gt;git update-index paths...&lt;/code&gt; 업데이트 된 경로와 인덱스와 작업 트리를 모두 업데이트하는 다른 Git 명령으로 업데이트 된 경로 (예 : &lt;code&gt;git apply --index&lt;/code&gt; , &lt;code&gt;git checkout-index -u&lt;/code&gt; 및 &lt;code&gt;git read-tree -u&lt;/code&gt; )는 &quot;변경되지 않은 것으로 가정&quot;으로 자동 표시됩니다. 비트가 &quot;변하지 가정&quot;주의 &lt;strong&gt;하지&lt;/strong&gt; 경우 설정 &lt;code&gt;git update-index --refresh&lt;/code&gt; (사용 작업 트리 파일을 발견 인덱스 일치 &lt;code&gt;git update-index --really-refresh&lt;/code&gt; 하면 &quot;변하지 가정&quot;로 표시 할 경우).</target>
        </trans-unit>
        <trans-unit id="719021beca97cba355f40567331ed4531fab91cd" translate="yes" xml:space="preserve">
          <source>The command loop shows the list of subcommands available, and gives a prompt &quot;What now&amp;gt; &quot;. In general, when the prompt ends with a single &lt;code&gt;&amp;gt;&lt;/code&gt;, you can pick only one of the choices given and type return, like this:</source>
          <target state="translated">명령 루프는 사용 가능한 하위 명령 목록을 표시하고 &quot;지금 무엇&amp;gt;&quot;프롬프트를 표시합니다. 일반적으로 프롬프트가 단일 &lt;code&gt;&amp;gt;&lt;/code&gt; 로 끝나는 경우 다음과 같이 주어진 선택 중 하나만 선택하고 return을 입력 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="653e31d7d7203bdc451cd54eed957012f41434d3" translate="yes" xml:space="preserve">
          <source>The command refuses to process new mailboxes until the current operation is finished, so if you decide to start over from scratch, run &lt;code&gt;git am --abort&lt;/code&gt; before running the command with mailbox names.</source>
          <target state="translated">명령은 현재 작업이 완료 될 때까지 새 메일 함을 처리하지 않으므로 처음부터 다시 시작하기로 결정한 경우 메일 함 이름으로 명령을 실행하기 전에 &lt;code&gt;git am --abort&lt;/code&gt; 를 실행하십시오.</target>
        </trans-unit>
        <trans-unit id="ddc41d8aed51eb71b1c7af7000815eb2a4b359d3" translate="yes" xml:space="preserve">
          <source>The command stream is terminated by a blank line. In some cases (indicated in the documentation of the relevant commands), this blank line is followed by a payload in some other protocol (e.g., the pack protocol), while in others it indicates the end of input.</source>
          <target state="translated">명령 스트림은 빈 줄로 종료됩니다. 경우에 따라 (관련 명령의 문서에 표시됨)이 빈 줄 뒤에 다른 프로토콜 (예 : 팩 프로토콜)의 페이로드가 오는 반면, 다른 경우에는 입력 끝을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="d1cdce0d3b2e7df2146074a7208b9f02c1bab1a7" translate="yes" xml:space="preserve">
          <source>The command takes options applicable to the &lt;code&gt;git diff-tree&lt;/code&gt; command to control how the changes the commit introduces are shown.</source>
          <target state="translated">이 명령은 &lt;code&gt;git diff-tree&lt;/code&gt; 명령에 적용 가능한 옵션을 사용 하여 커밋이 도입 한 변경 사항이 표시되는 방법을 제어합니다.</target>
        </trans-unit>
        <trans-unit id="35fc48f2de1638c3a16917e24656f5cccec37735" translate="yes" xml:space="preserve">
          <source>The command takes options applicable to the &lt;code&gt;git log&lt;/code&gt; command to control what is shown and how. See &lt;a href=&quot;git-log&quot;&gt;git-log[1]&lt;/a&gt;.</source>
          <target state="translated">이 명령은 &lt;code&gt;git log&lt;/code&gt; 명령에 적용 가능한 옵션을 사용하여 표시된 내용과 방법을 제어합니다. &lt;a href=&quot;git-log&quot;&gt;git-log [1]을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="704cfc598be528aca39957bda30b48a4e32947ac" translate="yes" xml:space="preserve">
          <source>The command takes options applicable to the &lt;code&gt;git rev-list&lt;/code&gt; command to control what is shown and how, and options applicable to the &lt;code&gt;git diff-*&lt;/code&gt; commands to control how the changes each commit introduces are shown.</source>
          <target state="translated">이 명령은 &lt;code&gt;git rev-list&lt;/code&gt; 명령에 적용 가능한 옵션을 사용하여 표시되는 내용과 방법 을 제어 하고 &lt;code&gt;git diff-*&lt;/code&gt; 명령에 적용 할 수있는 옵션을 사용하여 각 커밋의 변경 내용이 표시되는 방식을 제어합니다.</target>
        </trans-unit>
        <trans-unit id="05dd6533643357a7eb4c0a33aa8aafdf86be046c" translate="yes" xml:space="preserve">
          <source>The command takes various subcommands, and different options depending on the subcommand:</source>
          <target state="translated">이 명령은 다양한 하위 명령과 하위 명령에 따라 다른 옵션을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="5dfb0879d1b00c6726b4c473489aecee6c7360c1" translate="yes" xml:space="preserve">
          <source>The command that the diff driver should call to generate the text-converted version of a file. The result of the conversion is used to generate a human-readable diff. See &lt;a href=&quot;gitattributes&quot;&gt;gitattributes[5]&lt;/a&gt; for details.</source>
          <target state="translated">diff 드라이버가 텍스트 변환 버전의 파일을 생성하기 위해 호출해야하는 명령입니다. 변환 결과는 사람이 읽을 수있는 diff를 생성하는 데 사용됩니다. 자세한 내용은 &lt;a href=&quot;gitattributes&quot;&gt;gitattributes [5]&lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="76561fd073c2b7875043b506e4a6c918bbf27fef" translate="yes" xml:space="preserve">
          <source>The command usually removes loose refs under &lt;code&gt;$GIT_DIR/refs&lt;/code&gt; hierarchy after packing them. This option tells it not to.</source>
          <target state="translated">이 명령은 보통 &lt;code&gt;$GIT_DIR/refs&lt;/code&gt; 계층 구조 에서 느슨한 참조를 압축 한 후 제거 합니다. 이 옵션은하지 말라고 지시합니다.</target>
        </trans-unit>
        <trans-unit id="77170493947dd63f2044149c05ae4eb27dc0d118" translate="yes" xml:space="preserve">
          <source>The command usually shows percentage progress. This flag suppresses it.</source>
          <target state="translated">이 명령은 일반적으로 백분율 진행률을 보여줍니다. 이 플래그는 억제합니다.</target>
        </trans-unit>
        <trans-unit id="3df5350b5d92a4c7df677ed19aeefaf4fd05338a" translate="yes" xml:space="preserve">
          <source>The command which is used to convert the content of a blob object to a worktree file upon checkout. See &lt;a href=&quot;gitattributes&quot;&gt;gitattributes[5]&lt;/a&gt; for details.</source>
          <target state="translated">체크 아웃시 Blob 오브젝트의 컨텐츠를 작업 트리 파일로 변환하는 데 사용되는 명령입니다. 자세한 내용은 &lt;a href=&quot;gitattributes&quot;&gt;gitattributes [5]&lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="e78c7e2042e4de22f48dc29ab38867e1c8242106" translate="yes" xml:space="preserve">
          <source>The command which is used to convert the content of a worktree file to a blob upon checkin. See &lt;a href=&quot;gitattributes&quot;&gt;gitattributes[5]&lt;/a&gt; for details.</source>
          <target state="translated">체크인시 작업 트리 파일의 컨텐츠를 Blob으로 변환하는 데 사용되는 명령입니다. 자세한 내용은 &lt;a href=&quot;gitattributes&quot;&gt;gitattributes [5]&lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="a6711f072ffccd6a7948d8fcfc289d0284bd97d1" translate="yes" xml:space="preserve">
          <source>The command will only rewrite the &lt;code&gt;positive&lt;/code&gt; refs mentioned in the command line (e.g. if you pass &lt;code&gt;a..b&lt;/code&gt;, only &lt;code&gt;b&lt;/code&gt; will be rewritten). If you specify no filters, the commits will be recommitted without any changes, which would normally have no effect. Nevertheless, this may be useful in the future for compensating for some Git bugs or such, therefore such a usage is permitted.</source>
          <target state="translated">명령은 명령 행에 언급 된 &lt;code&gt;positive&lt;/code&gt; 만 다시 작성합니다 (예 : &lt;code&gt;a..b&lt;/code&gt; 를 전달하면 &lt;code&gt;b&lt;/code&gt; 만 다시 작성 됨). 필터를 지정하지 않으면 변경 사항없이 커밋이 다시 커밋되며 일반적으로 적용되지 않습니다. 그럼에도 불구하고, 이것은 미래에 일부 Git 버그 등을 보상하는 데 유용 할 수 있으므로 이러한 사용이 허용됩니다.</target>
        </trans-unit>
        <trans-unit id="6c1d44a42d537aa236fa8b0c18f8ebc1e0d665b8" translate="yes" xml:space="preserve">
          <source>The command writes the commit object name of the common ancestor to the standard output, so we captured its output to a variable, because we will be using it in the next step. By the way, the common ancestor commit is the &quot;Initial commit&quot; commit in this case. You can tell it by:</source>
          <target state="translated">이 명령은 공통 조상의 커밋 객체 이름을 표준 출력에 기록하므로 다음 단계에서 사용할 것이므로 출력을 변수로 캡처했습니다. 그런데이 경우 공통 조상 커밋은 &quot;초기 커밋&quot;커밋입니다. 당신은 그것을 말할 수 있습니다 :</target>
        </trans-unit>
        <trans-unit id="277f50b8984fb8f1e24e58a015e232c719b0136b" translate="yes" xml:space="preserve">
          <source>The command&amp;rsquo;s second form creates a new branch head named &amp;lt;branchname&amp;gt; which points to the current &lt;code&gt;HEAD&lt;/code&gt;, or &amp;lt;start-point&amp;gt; if given. As a special case, for &amp;lt;start-point&amp;gt;, you may use &lt;code&gt;&quot;A...B&quot;&lt;/code&gt; as a shortcut for the merge base of &lt;code&gt;A&lt;/code&gt; and &lt;code&gt;B&lt;/code&gt; if there is exactly one merge base. You can leave out at most one of &lt;code&gt;A&lt;/code&gt; and &lt;code&gt;B&lt;/code&gt;, in which case it defaults to &lt;code&gt;HEAD&lt;/code&gt;.</source>
          <target state="translated">명령의 두 번째 형식은 현재 &lt;code&gt;HEAD&lt;/code&gt; 를 가리키는 &amp;lt;branchname&amp;gt;이라는 새 분기 헤드를 작성 하거나 지정된 경우 &amp;lt;start-point&amp;gt;를 작성합니다. 특별한 경우로 &amp;lt;start-point&amp;gt;의 경우 정확히 하나의 병합 기준이있는 경우 &lt;code&gt;&quot;A...B&quot;&lt;/code&gt; 를 &lt;code&gt;A&lt;/code&gt; 와 &lt;code&gt;B&lt;/code&gt; 의 병합 기준에 대한 바로 가기로 사용할 수 있습니다 . &lt;code&gt;A&lt;/code&gt; 와 &lt;code&gt;B&lt;/code&gt; 중 하나만 남겨 둘 수 있으며 ,이 경우 기본값은 &lt;code&gt;HEAD&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="0384db43c537c0cba33bbce02fa39c058435bd6c" translate="yes" xml:space="preserve">
          <source>The command-line flag --exclude-from=&amp;lt;file&amp;gt; specifies a file containing a list of patterns. Patterns are ordered in the same order they appear in the file.</source>
          <target state="translated">명령 줄 플래그 --exclude-from = &amp;lt;file&amp;gt;은 패턴 목록이 포함 된 파일을 지정합니다. 패턴은 파일에 나타나는 것과 같은 순서로 정렬됩니다.</target>
        </trans-unit>
        <trans-unit id="84de3c7a7b3ba54b91bb57a464ea60b526231897" translate="yes" xml:space="preserve">
          <source>The command-line flag --exclude-per-directory=&amp;lt;name&amp;gt; specifies a name of the file in each directory &lt;code&gt;git ls-files&lt;/code&gt; examines, normally &lt;code&gt;.gitignore&lt;/code&gt;. Files in deeper directories take precedence. Patterns are ordered in the same order they appear in the files.</source>
          <target state="translated">명령 행 플래그 --exclude-per-directory = &amp;lt;name&amp;gt;은 &lt;code&gt;git ls-files&lt;/code&gt; 가 검사하는 각 디렉토리의 파일 이름을 지정 합니다 (일반적으로 &lt;code&gt;.gitignore&lt;/code&gt; ) . 더 깊은 디렉토리의 파일이 우선합니다. 패턴은 파일에 나타나는 순서와 동일한 순서로 정렬됩니다.</target>
        </trans-unit>
        <trans-unit id="de25d36c95ea6a374c3001c57d5c8bbae6052f57" translate="yes" xml:space="preserve">
          <source>The command-line flag --exclude=&amp;lt;pattern&amp;gt; specifies a single pattern. Patterns are ordered in the same order they appear in the command line.</source>
          <target state="translated">명령 줄 플래그 --exclude = &amp;lt;pattern&amp;gt;은 단일 패턴을 지정합니다. 패턴은 명령 행에 나타나는 것과 동일한 순서로 정렬됩니다.</target>
        </trans-unit>
        <trans-unit id="57163e2560363b464673a4a43dc95a7ad9f9ef3b" translate="yes" xml:space="preserve">
          <source>The commit &quot;D&quot; is called a &quot;merge base&quot; for branch &quot;main&quot; and &quot;dev&quot; because it&amp;rsquo;s the best common ancestor for these branches for a merge.</source>
          <target state="translated">커밋 &quot;D&quot;는 &quot;main&quot;및 &quot;dev&quot;브랜치의 &quot;병합베이스&quot;라고하며이 브랜치의 병합에 대한 가장 일반적인 조상이기 때문입니다.</target>
        </trans-unit>
        <trans-unit id="f185c14cbc82f3e4dae044b7f66a7608424887fa" translate="yes" xml:space="preserve">
          <source>The commit author name is taken from the &quot;From: &quot; line of the message, and commit author date is taken from the &quot;Date: &quot; line of the message. The &quot;Subject: &quot; line is used as the title of the commit, after stripping common prefix &quot;[PATCH &amp;lt;anything&amp;gt;]&quot;. The &quot;Subject: &quot; line is supposed to concisely describe what the commit is about in one line of text.</source>
          <target state="translated">커밋 작성자 이름은 메시지의 &quot;보낸 사람 :&quot;줄에서 가져오고 커밋 작성자 날짜는 메시지의 &quot;날짜 :&quot;줄에서 가져옵니다. &quot;Subject :&quot;행은 공통 접두사 &quot;[PATCH &amp;lt;anything&amp;gt;]&quot;을 제거한 후 커밋 제목으로 사용됩니다. &quot;제목 :&quot;줄은 한 줄의 텍스트에서 커밋에 대해 간결하게 설명해야합니다.</target>
        </trans-unit>
        <trans-unit id="2f12acdb07fb960bc2fd1e07b27cc4a2b35ad054" translate="yes" xml:space="preserve">
          <source>The commit list format can be changed by setting the configuration option rebase.instructionFormat. A customized instruction format will automatically have the long commit hash prepended to the format.</source>
          <target state="translated">구성 옵션 rebase.instructionFormat을 설정하여 커밋 목록 형식을 변경할 수 있습니다. 사용자 정의 된 명령 형식은 긴 커밋 해시가 형식 앞에 자동으로 추가됩니다.</target>
        </trans-unit>
        <trans-unit id="56b4186deed0365516ca63a760921d1d85d5abd6" translate="yes" xml:space="preserve">
          <source>The commit log message extracted from e-mail, usually except the title line which comes from e-mail Subject.</source>
          <target state="translated">전자 메일에서 추출 된 커밋 로그 메시지 (일반적으로 전자 메일 제목에서 나오는 제목 줄 제외).</target>
        </trans-unit>
        <trans-unit id="448543278984728d32d400e55fc12701ecc9668d" translate="yes" xml:space="preserve">
          <source>The commit log message, author name and author email are taken from the e-mail, and after minimally decoding MIME transfer encoding, re-coded in the charset specified by i18n.commitencoding (defaulting to UTF-8) by transliterating them. This used to be optional but now it is the default.</source>
          <target state="translated">커밋 로그 메시지, 작성자 이름 및 저자 이메일은 전자 메일에서 가져오고 MIME 전송 인코딩을 최소한으로 디코딩 한 후 음역을 통해 i18n.commitencoding (기본값은 UTF-8)으로 지정된 문자 세트로 다시 코딩됩니다. 이것은 선택 사항 이었지만 이제는 기본값입니다.</target>
        </trans-unit>
        <trans-unit id="682ec5a16062666d3ac4c15995f4c320f0569ce3" translate="yes" xml:space="preserve">
          <source>The commit message is formed by the title taken from the &quot;Subject: &quot;, a blank line and the body of the message up to where the patch begins. Excess whitespace at the end of each line is automatically stripped.</source>
          <target state="translated">커밋 메시지는 &quot;Subject :&quot;에서 가져온 제목, 빈 줄 및 패치가 시작된 위치까지 메시지 본문으로 구성됩니다. 각 줄 끝의 초과 공백은 자동으로 제거됩니다.</target>
        </trans-unit>
        <trans-unit id="9d14a63335261988fcede52b815289c8a87983a5" translate="yes" xml:space="preserve">
          <source>The commit message is supplied either directly with the &lt;code&gt;-m&lt;/code&gt; or &lt;code&gt;-F&lt;/code&gt; option, or indirectly from the tag or commit when the second tree-ish denotes such an object, or it is requested by invoking an editor (see &lt;code&gt;--edit&lt;/code&gt; option below).</source>
          <target state="translated">커밋 메시지는 &lt;code&gt;-m&lt;/code&gt; 또는 &lt;code&gt;-F&lt;/code&gt; 옵션 과 함께 직접 제공되거나 두 번째 tree-ish가 그러한 객체를 나타낼 때 커밋 또는 커밋에서 간접적으로 제공되거나 편집기를 호출하여 요청합니다 (아래 &lt;code&gt;--edit&lt;/code&gt; 옵션 참조). .</target>
        </trans-unit>
        <trans-unit id="50413d61f19e8e0d39eb4098c01c599c7c407f25" translate="yes" xml:space="preserve">
          <source>The commit object names shown above would be different for you, but they should match the HEAD commit object names of your repositories. You can check it by running &lt;code&gt;git ls-remote ../a&lt;/code&gt;.</source>
          <target state="translated">위에 표시된 커밋 개체 이름은 사용자마다 다르지만 리포지토리의 HEAD 커밋 개체 이름과 일치해야합니다. &lt;code&gt;git ls-remote ../a&lt;/code&gt; 를 실행하여 확인할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="8b7bb35b4ae403135d95400938252724b91ca0d2" translate="yes" xml:space="preserve">
          <source>The commit objects record the encoding used for the log message in their encoding header; this option can be used to tell the command to re-code the commit log message in the encoding preferred by the user. For non plumbing commands this defaults to UTF-8. Note that if an object claims to be encoded in &lt;code&gt;X&lt;/code&gt; and we are outputting in &lt;code&gt;X&lt;/code&gt;, we will output the object verbatim; this means that invalid sequences in the original commit may be copied to the output.</source>
          <target state="translated">커밋 개체는 로그 메시지에 사용 된 인코딩을 인코딩 헤더에 기록합니다. 이 옵션은 커밋 로그 메시지를 사용자가 선호하는 인코딩으로 다시 코딩하도록 명령에 지시하는 데 사용할 수 있습니다. 배관이 아닌 명령의 경우 기본값은 UTF-8입니다. 참고 오브젝트 청구항에서 부호화되는 경우, &lt;code&gt;X&lt;/code&gt; 및 우리가 출력되는 &lt;code&gt;X&lt;/code&gt; 우리가 그대로 출력 객체 것이다; 이는 원래 커밋의 잘못된 시퀀스가 ​​출력으로 복사 될 수 있음을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="8a40378090f508382eab3e21e0b4382b3bab0ad4" translate="yes" xml:space="preserve">
          <source>The commit, equivalent to what other systems call a &quot;changeset&quot; or &quot;version&quot;, represents a step in the project&amp;rsquo;s history, and each parent represents an immediately preceding step. Commits with more than one parent represent merges of independent lines of development.</source>
          <target state="translated">다른 시스템이 &quot;changeset&quot;또는 &quot;version&quot;이라고 부르는 것과 동일한 커밋은 프로젝트 히스토리의 단계를 나타내며 각 상위는 직전 단계를 나타냅니다. 둘 이상의 부모가있는 커밋은 독립적 인 개발 라인의 병합을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="7d3d64efc4f4511458592fa6c8a58dcfb8579da7" translate="yes" xml:space="preserve">
          <source>The commits are guaranteed to be listed in the order that they were processed by rebase.</source>
          <target state="translated">커밋은 rebase에 의해 처리 된 순서대로 나열됩니다.</target>
        </trans-unit>
        <trans-unit id="00a94582df69c83885533dbdc944c957c3a549e0" translate="yes" xml:space="preserve">
          <source>The commits marked with &lt;code&gt;*&lt;/code&gt; touch the same area in the same file; you need to resolve the conflicts when creating the commit marked with &lt;code&gt;+&lt;/code&gt;. Then you can test the result to make sure your work-in-progress still works with what is in the latest master.</source>
          <target state="translated">&lt;code&gt;*&lt;/code&gt; 로 표시된 커밋 은 같은 파일에서 같은 영역을 터치합니다. &lt;code&gt;+&lt;/code&gt; 로 표시된 커밋을 만들 때 충돌을 해결해야합니다 . 그런 다음 결과를 테스트하여 진행중인 작업이 최신 마스터의 작업과 계속 작동하는지 확인할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a3fd88845d0ae86224cb7a800b3122f1cf56cb03" translate="yes" xml:space="preserve">
          <source>The commits that were previously saved into the temporary area are then reapplied to the current branch, one by one, in order. Note that any commits in HEAD which introduce the same textual changes as a commit in HEAD..&amp;lt;upstream&amp;gt; are omitted (i.e., a patch already accepted upstream with a different commit message or timestamp will be skipped).</source>
          <target state="translated">이전에 임시 영역에 저장된 커밋은 순서대로 현재 분기에 하나씩 다시 적용됩니다. HEAD .. &amp;lt;upstream&amp;gt;에서 커밋과 동일한 텍스트 변경을 도입하는 HEAD에서 커밋은 생략됩니다 (즉, 다른 커밋 메시지 또는 타임 스탬프가있는 업스트림에서 이미 승인 된 패치는 건너 뜁니다).</target>
        </trans-unit>
        <trans-unit id="18d247bf08e46b2d89a403ce14a86d7b99503646" translate="yes" xml:space="preserve">
          <source>The complete message in a commit and tag object is &lt;code&gt;contents&lt;/code&gt;. Its first line is &lt;code&gt;contents:subject&lt;/code&gt;, where subject is the concatenation of all lines of the commit message up to the first blank line. The next line is &lt;code&gt;contents:body&lt;/code&gt;, where body is all of the lines after the first blank line. The optional GPG signature is &lt;code&gt;contents:signature&lt;/code&gt;. The first &lt;code&gt;N&lt;/code&gt; lines of the message is obtained using &lt;code&gt;contents:lines=N&lt;/code&gt;. Additionally, the trailers as interpreted by &lt;a href=&quot;git-interpret-trailers&quot;&gt;git-interpret-trailers[1]&lt;/a&gt; are obtained as &lt;code&gt;trailers&lt;/code&gt; (or by using the historical alias &lt;code&gt;contents:trailers&lt;/code&gt;). Non-trailer lines from the trailer block can be omitted with &lt;code&gt;trailers:only&lt;/code&gt;. Whitespace-continuations can be removed from trailers so that each trailer appears on a line by itself with its full content with &lt;code&gt;trailers:unfold&lt;/code&gt;. Both can be used together as &lt;code&gt;trailers:unfold,only&lt;/code&gt;.</source>
          <target state="translated">커밋 및 태그 객체의 전체 메시지는 &lt;code&gt;contents&lt;/code&gt; 입니다. 첫 번째 행은 &lt;code&gt;contents:subject&lt;/code&gt; 입니다 . 여기서 subject는 커밋 메시지의 모든 행을 첫 번째 빈 행으로 연결합니다. 다음 줄은 &lt;code&gt;contents:body&lt;/code&gt; 입니다 . 여기서 body는 첫 번째 빈 줄 다음의 모든 줄입니다. 선택적인 GPG 서명은 &lt;code&gt;contents:signature&lt;/code&gt; 입니다. 메시지 의 첫 &lt;code&gt;N&lt;/code&gt; 줄은 &lt;code&gt;contents:lines=N&lt;/code&gt; 을 사용하여 얻습니다 . 또한, &lt;a href=&quot;git-interpret-trailers&quot;&gt;git-interpret-trailers [1]에&lt;/a&gt; 의해 해석 된 트레일러 는 &lt;code&gt;trailers&lt;/code&gt; (또는 역사적인 별명 &lt;code&gt;contents:trailers&lt;/code&gt; 을 사용하여 트레일러) 로 얻습니다 .). 트레일러 블록의 비 트레일러 라인은 &lt;code&gt;trailers:only&lt;/code&gt; 로 생략 할 수 있습니다 . 각 트레일러와의 전체 내용으로 한 줄에 단독으로 나타나도록 공백-연속성을 트레일러에서 제거 할 수 있습니다 &lt;code&gt;trailers:unfold&lt;/code&gt; . 둘 다 &lt;code&gt;trailers:unfold,only&lt;/code&gt; 함께 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="0cfefd9783776d68186cc88921bf5543257f8ee9" translate="yes" xml:space="preserve">
          <source>The complete series produces the same end result as your own (probably much messier!) development process did.</source>
          <target state="translated">전체 시리즈는 자신의 (아마도 더 지저분한) 개발 프로세스와 동일한 최종 결과를 생성합니다.</target>
        </trans-unit>
        <trans-unit id="94ed81b46eb91e159691e77d6f1f3c669ea0f93b" translate="yes" xml:space="preserve">
          <source>The condition starts with a keyword followed by a colon and some data whose format and meaning depends on the keyword. Supported keywords are:</source>
          <target state="translated">조건은 키워드로 시작하고 콜론과 형식 및 의미에 따라 일부 데이터가 키워드에 따라 달라집니다. 지원되는 키워드는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="b796e8b15faa41177d638a7b320c951a662a1b91" translate="yes" xml:space="preserve">
          <source>The config settings that start with &lt;code&gt;feature.&lt;/code&gt; modify the defaults of a group of other config settings. These groups are created by the Git developer community as recommended defaults and are subject to change. In particular, new config options may be added with different defaults.</source>
          <target state="translated">&lt;code&gt;feature.&lt;/code&gt; 시작하는 구성 설정입니다 . 다른 구성 설정 그룹의 기본값을 수정하십시오. 이 그룹은 Git 개발자 커뮤니티에서 권장되는 기본값으로 생성되며 변경 될 수 있습니다. 특히, 새로운 구성 옵션이 다른 기본값으로 추가 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0fd18e355006d4a8cb0ab9547d6ae9db29a772ac" translate="yes" xml:space="preserve">
          <source>The config variable &lt;code&gt;ssh.variant&lt;/code&gt; can be set to override this detection. Valid values are &lt;code&gt;ssh&lt;/code&gt; (to use OpenSSH options), &lt;code&gt;plink&lt;/code&gt;, &lt;code&gt;putty&lt;/code&gt;, &lt;code&gt;tortoiseplink&lt;/code&gt;, &lt;code&gt;simple&lt;/code&gt; (no options except the host and remote command). The default auto-detection can be explicitly requested using the value &lt;code&gt;auto&lt;/code&gt;. Any other value is treated as &lt;code&gt;ssh&lt;/code&gt;. This setting can also be overridden via the environment variable &lt;code&gt;GIT_SSH_VARIANT&lt;/code&gt;.</source>
          <target state="translated">구성 변수 &lt;code&gt;ssh.variant&lt;/code&gt; 는이 탐지를 무시하도록 설정할 수 있습니다. 유효한 값은 &lt;code&gt;ssh&lt;/code&gt; (OpenSSH 옵션 사용), &lt;code&gt;plink&lt;/code&gt; , &lt;code&gt;putty&lt;/code&gt; , &lt;code&gt;tortoiseplink&lt;/code&gt; , &lt;code&gt;simple&lt;/code&gt; (호스트 및 원격 명령을 제외한 옵션은 없음)입니다. 기본 자동 감지 기능은 명시 적으로 값을 사용하여 요청 할 수 있습니다 &lt;code&gt;auto&lt;/code&gt; . 다른 값은 &lt;code&gt;ssh&lt;/code&gt; 로 취급됩니다 . 이 설정은 환경 변수 &lt;code&gt;GIT_SSH_VARIANT&lt;/code&gt; 를 통해 무시할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="82dcb1f42fdd78b7a73229a297c6923dd8af63df" translate="yes" xml:space="preserve">
          <source>The configuration file &lt;code&gt;$GIT_DIR/config&lt;/code&gt; in the superproject. Git only recurses into active submodules (see &quot;ACTIVE SUBMODULES&quot; section below).</source>
          <target state="translated">수퍼 &lt;code&gt;$GIT_DIR/config&lt;/code&gt; 의 구성 파일 $ GIT_DIR / config . 힘내는 활성 하위 모듈로만 되풀이됩니다 (아래의 &quot;활성 하위 모듈&quot;섹션 참조).</target>
        </trans-unit>
        <trans-unit id="774734ca6d9570e50bffe1b21770dfa34405f67a" translate="yes" xml:space="preserve">
          <source>The configuration file is used to override the default settings that were built into gitweb at the time the &lt;code&gt;gitweb.cgi&lt;/code&gt; script was generated.</source>
          <target state="translated">구성 파일은 &lt;code&gt;gitweb.cgi&lt;/code&gt; 스크립트가 생성 될 때 gitweb에 내장 된 기본 설정을 재정의하는 데 사용 됩니다.</target>
        </trans-unit>
        <trans-unit id="b47107ae705aecdb184ade3561dff30a01436bf4" translate="yes" xml:space="preserve">
          <source>The configuration inside the submodule. This includes &lt;code&gt;$GIT_DIR/config&lt;/code&gt; in the submodule, but also settings in the tree such as a &lt;code&gt;.gitattributes&lt;/code&gt; or &lt;code&gt;.gitignore&lt;/code&gt; files that specify behavior of commands inside the submodule.</source>
          <target state="translated">서브 모듈 내부의 구성. 여기에는 서브 모듈에 &lt;code&gt;$GIT_DIR/config&lt;/code&gt; 가 포함 되지만 서브 모듈 내부의 명령 동작을 지정 하는 &lt;code&gt;.gitattributes&lt;/code&gt; 또는 &lt;code&gt;.gitignore&lt;/code&gt; 파일 과 같은 트리의 설정도 포함됩니다 .</target>
        </trans-unit>
        <trans-unit id="9f6d6d393008f1bcb3935ac97c688c0c97bcd837" translate="yes" xml:space="preserve">
          <source>The configuration of submodules</source>
          <target state="translated">서브 모듈의 구성</target>
        </trans-unit>
        <trans-unit id="386a88f6456b2a92a88834767dd0b8e7846f5609" translate="yes" xml:space="preserve">
          <source>The configuration variables &lt;code&gt;$projects_list_group_categories&lt;/code&gt; and &lt;code&gt;$project_list_default_category&lt;/code&gt; are described in &lt;a href=&quot;gitweb.conf&quot;&gt;gitweb.conf[5]&lt;/a&gt;</source>
          <target state="translated">구성 변수 &lt;code&gt;$projects_list_group_categories&lt;/code&gt; 및 &lt;code&gt;$project_list_default_category&lt;/code&gt; 는 &lt;a href=&quot;gitweb.conf&quot;&gt;gitweb.conf [5]에&lt;/a&gt; 설명되어 있습니다 .</target>
        </trans-unit>
        <trans-unit id="7bf08d06e6b6627f964eab6068d66314f0702240" translate="yes" xml:space="preserve">
          <source>The configuration variables are used by both the Git plumbing and the porcelains. The variables are divided into sections, wherein the fully qualified variable name of the variable itself is the last dot-separated segment and the section name is everything before the last dot. The variable names are case-insensitive, allow only alphanumeric characters and &lt;code&gt;-&lt;/code&gt;, and must start with an alphabetic character. Some variables may appear multiple times; we say then that the variable is multivalued.</source>
          <target state="translated">구성 변수는 Git 배관과 도자기 모두에서 사용됩니다. 변수는 섹션으로 나뉩니다. 여기서 변수 자체의 정규화 된 변수 이름은 마지막 점으로 구분 된 세그먼트이고 섹션 이름은 마지막 점 이전의 모든 것입니다. 변수 이름은 대소 문자를 구분하지 않으며 영숫자 및 &lt;code&gt;-&lt;/code&gt; 만 허용하며 알파벳 문자로 시작해야합니다. 일부 변수는 여러 번 나타날 수 있습니다. 그런 다음 변수가 다중 값이라고 말합니다.</target>
        </trans-unit>
        <trans-unit id="9ba005fddfd40c1aca4a3afcc24f0bfe0be0d141" translate="yes" xml:space="preserve">
          <source>The configuration variables described below configure some of gitweb links: their target and their look (text or image), and where to find page prerequisites (stylesheet, favicon, images, scripts). Usually they are left at their default values, with the possible exception of &lt;code&gt;@stylesheets&lt;/code&gt; variable.</source>
          <target state="translated">아래에 설명 된 구성 변수는 대상 및 모양 (텍스트 또는 이미지)과 페이지 전제 조건 (스타일 시트, 즐겨 찾기 아이콘, 이미지, 스크립트)을 찾을 수있는 gitweb 링크의 일부를 구성합니다. 일반적으로 &lt;code&gt;@stylesheets&lt;/code&gt; 변수를 제외하고 기본값으로 남아 있습니다.</target>
        </trans-unit>
        <trans-unit id="352cabf788111a2af3c96521f974380812252a38" translate="yes" xml:space="preserve">
          <source>The configuration variables described below control how gitweb finds Git repositories, and how repositories are displayed and accessed.</source>
          <target state="translated">아래 설명 된 구성 변수는 gitweb이 Git 리포지토리를 찾는 방법과 리포지토리가 표시되고 액세스되는 방법을 제어합니다.</target>
        </trans-unit>
        <trans-unit id="3f43fd6b4f50ff73ead39001e9e7b24eaf91129d" translate="yes" xml:space="preserve">
          <source>The construct &lt;code&gt;@{-&amp;lt;n&amp;gt;}&lt;/code&gt; means the &amp;lt;n&amp;gt;th branch/commit checked out before the current one.</source>
          <target state="translated">구문 &lt;code&gt;@{-&amp;lt;n&amp;gt;}&lt;/code&gt; 은 현재 분기 전에 체크 아웃 된 &amp;lt;n&amp;gt; 분기 / 커밋을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="532c17d263ea0447251201d507a716aaf6f28f2e" translate="yes" xml:space="preserve">
          <source>The content to be committed can be specified in several ways:</source>
          <target state="translated">커밋 할 내용은 여러 가지 방법으로 지정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a3c1db69a05b050bddfd156a5df9e51b55df4af8" translate="yes" xml:space="preserve">
          <source>The contents of the actual line is output after the above header, prefixed by a TAB. This is to allow adding more header elements later.</source>
          <target state="translated">실제 행의 내용은 TAB 접두사가 붙은 위의 헤더 다음에 출력됩니다. 나중에 더 많은 헤더 요소를 추가 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="07ff8c430a66890255703acd59c46fb9590b9dc8" translate="yes" xml:space="preserve">
          <source>The contents of the blob objects are uninterpreted sequences of bytes. There is no encoding translation at the core level.</source>
          <target state="translated">Blob 객체의 내용은 해석되지 않은 바이트 시퀀스입니다. 핵심 수준에는 인코딩 변환이 없습니다.</target>
        </trans-unit>
        <trans-unit id="1b5efb2fc6b2c2f5d21112887ebec33fa1322cd1" translate="yes" xml:space="preserve">
          <source>The contents of the included file are inserted immediately, as if they had been found at the location of the include directive. If the value of the variable is a relative path, the path is considered to be relative to the configuration file in which the include directive was found. See below for examples.</source>
          <target state="translated">포함 지시문의 위치에서 찾은 것처럼 포함 된 파일의 내용이 즉시 삽입됩니다. 변수 값이 상대 경로 인 경우 경로는 include 지시문이 발견 된 구성 파일에 상대적인 것으로 간주됩니다. 예는 아래를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="8e2acace54c1bc95e05b068c1615156bf7369b0d" translate="yes" xml:space="preserve">
          <source>The core Git is often called &quot;plumbing&quot;, with the prettier user interfaces on top of it called &quot;porcelain&quot;. You may not want to use the plumbing directly very often, but it can be good to know what the plumbing does when the porcelain isn&amp;rsquo;t flushing.</source>
          <target state="translated">핵심 Git은 종종 &quot;배관 (Plumbing)&quot;으로 불리며, 그 위에 &quot;포세린 (porcelain)&quot;이라는 더 아름다운 사용자 인터페이스가 있습니다. 배관을 매우 자주 직접 사용하고 싶지 않을 수도 있지만, 도자기가 플러시되지 않을 때 배관이 무엇을하는지 아는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="bdff9728a51893f686262a6a471251953f8ca49c" translate="yes" xml:space="preserve">
          <source>The core.multiPackIndex config setting must be on to consume MIDX files.</source>
          <target state="translated">MIDX 파일을 사용하려면 core.multiPackIndex 구성 설정이 켜져 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="4fd34d18ba310e6b91e875c3fcf517fe13b68829" translate="yes" xml:space="preserve">
          <source>The cost matrix is populated thusly: for each pair of commits, both diffs are generated and the &quot;diff of diffs&quot; is generated, with 3 context lines, then the number of lines in that diff is used as cost.</source>
          <target state="translated">비용 매트릭스는 이렇게 채워집니다. 각 커밋 쌍에 대해 두 개의 diff가 생성되고 &quot;diff of diffs&quot;가 3 개의 컨텍스트 라인으로 생성 된 다음 해당 diff의 라인 수가 비용으로 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="588bd7a488f6b8b596aae7dca46a3809b4412eb0" translate="yes" xml:space="preserve">
          <source>The cost of an edge &lt;code&gt;o--C&lt;/code&gt; is the size of &lt;code&gt;C&lt;/code&gt;'s diff, modified by a fudge factor that should be smaller than 100%. The cost of an edge &lt;code&gt;o--o&lt;/code&gt; is free. The fudge factor is necessary because even if &lt;code&gt;1&lt;/code&gt; and &lt;code&gt;C&lt;/code&gt; have nothing in common, they may still share a few empty lines and such, possibly making the assignment &lt;code&gt;1--C&lt;/code&gt;, &lt;code&gt;o--o&lt;/code&gt; slightly cheaper than &lt;code&gt;1--o&lt;/code&gt;, &lt;code&gt;o--C&lt;/code&gt; even if &lt;code&gt;1&lt;/code&gt; and &lt;code&gt;C&lt;/code&gt; have nothing in common. With the fudge factor we require a much larger common part to consider patches as corresponding.</source>
          <target state="translated">모서리 &lt;code&gt;o--C&lt;/code&gt; 의 비용은 &lt;code&gt;C&lt;/code&gt; 의 diff 크기이며 퍼지 팩터로 수정하여 100 %보다 작아야합니다. 엣지 &lt;code&gt;o--o&lt;/code&gt; 의 비용 은 무료입니다. 퍼지 팩터는 &lt;code&gt;1&lt;/code&gt; 과 &lt;code&gt;C&lt;/code&gt; 에 공통점이없는 경우에도 여전히 몇 개의 빈 줄을 공유 할 수 있으므로 &lt;code&gt;1--C&lt;/code&gt; , &lt;code&gt;o--o&lt;/code&gt; 는 &lt;code&gt;1--o&lt;/code&gt; , &lt;code&gt;o--C&lt;/code&gt; 보다 약간 저렴합니다. &lt;code&gt;1&lt;/code&gt; 과 &lt;code&gt;C&lt;/code&gt; 에 공통점이없는 경우에도 -C . 퍼지 계수를 사용하면 패치를 해당하는 것으로 간주하기 위해 훨씬 큰 공통 부분이 필요합니다.</target>
        </trans-unit>
        <trans-unit id="1995b336f91a29b5d0cf1cb6bf6d7c2407fa802c" translate="yes" xml:space="preserve">
          <source>The credential is split into a set of named attributes, with one attribute per line. Each attribute is specified by a key-value pair, separated by an &lt;code&gt;=&lt;/code&gt; (equals) sign, followed by a newline. The key may contain any bytes except &lt;code&gt;=&lt;/code&gt;, newline, or NUL. The value may contain any bytes except newline or NUL. In both cases, all bytes are treated as-is (i.e., there is no quoting, and one cannot transmit a value with newline or NUL in it). The list of attributes is terminated by a blank line or end-of-file. Git understands the following attributes:</source>
          <target state="translated">자격 증명은 한 줄에 하나의 속성이있는 명명 된 속성 집합으로 분할됩니다. 각 속성은 키-값 쌍으로 지정되며 &lt;code&gt;=&lt;/code&gt; (등호) 기호로 구분되고 줄 바꿈이 뒤 따릅니다. 키에는 &lt;code&gt;=&lt;/code&gt; , 개행 또는 NUL을 제외한 모든 바이트가 포함될 수 있습니다 . 값은 개행 또는 NUL을 제외한 모든 바이트를 포함 할 수 있습니다. 두 경우 모두, 모든 바이트는있는 그대로 처리됩니다 (즉, 인용 부호가 없으며 그 안에 개행 문자 나 NUL이있는 값을 전송할 수 없습니다). 속성 목록은 빈 줄 또는 파일 끝으로 종료됩니다. Git은 다음 속성을 이해합니다.</target>
        </trans-unit>
        <trans-unit id="332163de0b53725f6a8fdbb5dfbee2d72f5e952f" translate="yes" xml:space="preserve">
          <source>The credential&amp;rsquo;s password, if we are asking it to be stored.</source>
          <target state="translated">자격 증명 암호 (저장하도록 요청하는 경우)</target>
        </trans-unit>
        <trans-unit id="b2af82f2f4002bb109eae365a3025f169b56089c" translate="yes" xml:space="preserve">
          <source>The credential&amp;rsquo;s username, if we already have one (e.g., from a URL, from the user, or from a previously run helper).</source>
          <target state="translated">자격 증명의 사용자 이름 (예 : URL, 사용자 또는 이전에 실행 한 도우미)이 이미있는 경우</target>
        </trans-unit>
        <trans-unit id="327d8af868005c380ff04a569542ec1ad381deca" translate="yes" xml:space="preserve">
          <source>The current &lt;a href=&quot;#def_branch&quot;&gt;branch&lt;/a&gt;. In more detail: Your &lt;a href=&quot;#def_working_tree&quot;&gt;working tree&lt;/a&gt; is normally derived from the state of the tree referred to by HEAD. HEAD is a reference to one of the &lt;a href=&quot;#def_head&quot;&gt;heads&lt;/a&gt; in your repository, except when using a &lt;a href=&quot;#def_detached_HEAD&quot;&gt;detached HEAD&lt;/a&gt;, in which case it directly references an arbitrary commit.</source>
          <target state="translated">현재 &lt;a href=&quot;#def_branch&quot;&gt;지점&lt;/a&gt; . 더 자세하게 : &lt;a href=&quot;#def_working_tree&quot;&gt;작업 트리는&lt;/a&gt; 일반적으로 HEAD가 참조하는 트리의 상태에서 파생됩니다. HEAD는 &lt;a href=&quot;#def_detached_HEAD&quot;&gt;분리 된 HEAD를&lt;/a&gt; 사용하는 경우를 제외하고 저장소 의 &lt;a href=&quot;#def_head&quot;&gt;헤드&lt;/a&gt; 중 하나에 대한 참조 이며,이 경우 임의 커밋을 직접 참조합니다.</target>
        </trans-unit>
        <trans-unit id="6a22129f9e2c1c598b41ac7718060a19c57ba2df" translate="yes" xml:space="preserve">
          <source>The current branch and &lt;code&gt;HEAD&lt;/code&gt; pointer stay at the last commit successfully made.</source>
          <target state="translated">현재 브랜치 및 &lt;code&gt;HEAD&lt;/code&gt; 포인터는 성공적으로 마지막으로 커밋 된 상태를 유지합니다.</target>
        </trans-unit>
        <trans-unit id="0f49d1c21e2564ca60f22933641a619ec1965bd6" translate="yes" xml:space="preserve">
          <source>The current branch is reset to &amp;lt;upstream&amp;gt;, or &amp;lt;newbase&amp;gt; if the --onto option was supplied. This has the exact same effect as &lt;code&gt;git reset --hard &amp;lt;upstream&amp;gt;&lt;/code&gt; (or &amp;lt;newbase&amp;gt;). ORIG_HEAD is set to point at the tip of the branch before the reset.</source>
          <target state="translated">--onto 옵션이 제공된 경우 현재 분기는 &amp;lt;upstream&amp;gt; 또는 &amp;lt;newbase&amp;gt;로 재설정됩니다. 이것은 &lt;code&gt;git reset --hard &amp;lt;upstream&amp;gt;&lt;/code&gt; (또는 &amp;lt;newbase&amp;gt;) 와 동일한 효과를 갖습니다. ORIG_HEAD는 재설정 전 분기의 끝을 가리 키도록 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="485fe33a04a6d00e71aec5bce139a108011107ac" translate="yes" xml:space="preserve">
          <source>The current command-line parameters used for each variant are as follows:</source>
          <target state="translated">각 변형에 사용되는 현재 명령 줄 매개 변수는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="f1d20a076d93bfe14eb345a4d54fe76b72904bc4" translate="yes" xml:space="preserve">
          <source>The current index and work tree is derived from $H, but the user may have local changes in them since $H.</source>
          <target state="translated">현재 색인 및 작업 트리는 $ H에서 파생되지만 사용자는 $ H 이후로 로컬 변경이있을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7bc299cda3bedfdcbabc4a6883d29c81bf74d5df" translate="yes" xml:space="preserve">
          <source>The current index file for the repository. It is usually not found in a bare repository.</source>
          <target state="translated">저장소의 현재 색인 파일 일반적으로 베어 저장소에는 없습니다.</target>
        </trans-unit>
        <trans-unit id="6561295b83003ebae9a9c6ca19e06cdfe7bf9b70" translate="yes" xml:space="preserve">
          <source>The currently defined format versions are:</source>
          <target state="translated">현재 정의 된 형식 버전은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="66a8472981ef80b1cce56bd59cf5f4d97c11f9f9" translate="yes" xml:space="preserve">
          <source>The currently supported hooks are described below.</source>
          <target state="translated">현재 지원되는 후크는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="8715361e5840de7b556e67eacf990927a206b328" translate="yes" xml:space="preserve">
          <source>The custom diff driver command. See &lt;a href=&quot;gitattributes&quot;&gt;gitattributes[5]&lt;/a&gt; for details.</source>
          <target state="translated">사용자 정의 diff 드라이버 명령 자세한 내용은 &lt;a href=&quot;gitattributes&quot;&gt;gitattributes [5]&lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="1e530b24daf8e53e45f57000d6a6174670a1f6d2" translate="yes" xml:space="preserve">
          <source>The data content for the file has not been supplied yet. The frontend wants to supply it as part of this modify command.</source>
          <target state="translated">파일의 데이터 내용이 아직 제공되지 않았습니다. 프론트 엔드는이 수정 명령의 일부로이를 제공하려고합니다.</target>
        </trans-unit>
        <trans-unit id="f92713104ec45ad60b839fa902e6ffedd1e05a41" translate="yes" xml:space="preserve">
          <source>The data content for the file was already supplied by a prior &lt;code&gt;blob&lt;/code&gt; command. The frontend just needs to connect it.</source>
          <target state="translated">파일의 데이터 내용은 이미 이전 &lt;code&gt;blob&lt;/code&gt; 명령으로 제공되었습니다 . 프론트 엔드 만 연결하면됩니다.</target>
        </trans-unit>
        <trans-unit id="abeb69d3d4bae2cc1a5a16e58850f1c93c17369b" translate="yes" xml:space="preserve">
          <source>The data content for the note has not been supplied yet. The frontend wants to supply it as part of this modify command.</source>
          <target state="translated">메모의 데이터 내용이 아직 제공되지 않았습니다. 프론트 엔드는이 수정 명령의 일부로이를 제공하려고합니다.</target>
        </trans-unit>
        <trans-unit id="81c47d0a0bfa5328ac109608aa42a36ac0ca6a45" translate="yes" xml:space="preserve">
          <source>The data content for the note was already supplied by a prior &lt;code&gt;blob&lt;/code&gt; command. The frontend just needs to connect it to the commit that is to be annotated.</source>
          <target state="translated">노트의 데이터 컨텐츠는 이미 이전 &lt;code&gt;blob&lt;/code&gt; 명령으로 제공되었습니다 . 프론트 엔드는 주석을 달 수있는 커밋에 연결해야합니다.</target>
        </trans-unit>
        <trans-unit id="d1c68865b9a230a071410342b903f7a0e48271ba" translate="yes" xml:space="preserve">
          <source>The data that follows the keyword &lt;code&gt;gitdir:&lt;/code&gt; is used as a glob pattern. If the location of the .git directory matches the pattern, the include condition is met.</source>
          <target state="translated">키워드 &lt;code&gt;gitdir:&lt;/code&gt; 다음에 오는 데이터 는 glob 패턴으로 사용됩니다. .git 디렉토리의 위치가 패턴과 일치하면 포함 조건이 충족됩니다.</target>
        </trans-unit>
        <trans-unit id="c1597312d460a92e79d09c37c305ec85acdf7d09" translate="yes" xml:space="preserve">
          <source>The data that follows the keyword &lt;code&gt;onbranch:&lt;/code&gt; is taken to be a pattern with standard globbing wildcards and two additional ones, &lt;code&gt;**/&lt;/code&gt; and &lt;code&gt;/**&lt;/code&gt;, that can match multiple path components. If we are in a worktree where the name of the branch that is currently checked out matches the pattern, the include condition is met.</source>
          <target state="translated">&lt;code&gt;onbranch:&lt;/code&gt; 키워드 뒤에 오는 데이터는 표준 경로 지정 와일드 카드와 여러 경로 구성 요소와 일치 할 수있는 두 개의 추가 &lt;code&gt;**/&lt;/code&gt; 및 &lt;code&gt;/**&lt;/code&gt; 가있는 패턴으로 간주 됩니다. 현재 체크 아웃 된 분기 이름이 패턴과 일치하는 작업 트리에있는 경우 포함 조건이 충족됩니다.</target>
        </trans-unit>
        <trans-unit id="7c053d7b296d35ca64db938819dea858103dc6da" translate="yes" xml:space="preserve">
          <source>The data transfer of the packfile is always multiplexed, using the same semantics of the &lt;code&gt;side-band-64k&lt;/code&gt; capability from protocol version 1. This means that each packet, during the packfile data stream, is made up of a leading 4-byte pkt-line length (typical of the pkt-line format), followed by a 1-byte stream code, followed by the actual data.</source>
          <target state="translated">팩 파일의 데이터 전송은 항상 프로토콜 버전 1 의 &lt;code&gt;side-band-64k&lt;/code&gt; 기능 과 동일한 의미를 사용하여 멀티플렉싱됩니다 . 이는 팩 파일 데이터 스트림 동안 각 패킷이 선행 4 바이트 pkt- 행 길이 (일반적으로 pkt-line 형식), 1 바이트 스트림 코드, 실제 데이터가 뒤 따릅니다.</target>
        </trans-unit>
        <trans-unit id="c2900c14cd751c2ba06b33eb8d53cbdb905b94a4" translate="yes" xml:space="preserve">
          <source>The database cannot be reliably regenerated in a consistent form after the branch it is tracking has changed. Example: For merged branches, &lt;code&gt;git-cvsserver&lt;/code&gt; only tracks one branch of development, and after a &lt;code&gt;git merge&lt;/code&gt; an incrementally updated database may track a different branch than a database regenerated from scratch, causing inconsistent CVS revision numbers. &lt;code&gt;git-cvsserver&lt;/code&gt; has no way of knowing which branch it would have picked if it had been run incrementally pre-merge. So if you have to fully or partially (from old backup) regenerate the database, you should be suspicious of pre-existing CVS sandboxes.</source>
          <target state="translated">추적중인 분기가 변경된 후에는 데이터베이스를 일관된 형태로 안정적으로 재생성 할 수 없습니다. 예 : 병합 된 브랜치의 경우, &lt;code&gt;git-cvsserver&lt;/code&gt; 는 하나의 개발 브랜치 만 추적하며, &lt;code&gt;git merge&lt;/code&gt; 후 증분 업데이트 된 데이터베이스는 처음부터 다시 생성 된 데이터베이스와 다른 브랜치를 추적하여 CVS 개정 번호가 일치하지 않을 수 있습니다. &lt;code&gt;git-cvsserver&lt;/code&gt; 는 점진적으로 사전 병합 된 경우 어느 지점을 선택했는지 알 방법이 없습니다. 따라서 (이전 백업에서) 데이터베이스를 완전히 또는 부분적으로 재생성해야하는 경우 기존 CVS 샌드 박스가 의심됩니다.</target>
        </trans-unit>
        <trans-unit id="44d2a77b29a1133933d2693560e181324cc0bf34" translate="yes" xml:space="preserve">
          <source>The database has an object whose hash doesn&amp;rsquo;t match the object database value. This indicates a serious data integrity problem.</source>
          <target state="translated">데이터베이스에 해시가 객체 데이터베이스 값과 일치하지 않는 객체가 있습니다. 이는 심각한 데이터 무결성 문제를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="28234e35fb4524e90d740d3154dc66c02cb1f7a2" translate="yes" xml:space="preserve">
          <source>The default &amp;lt;ref&amp;gt; is &quot;master&quot;.</source>
          <target state="translated">기본 &amp;lt;ref&amp;gt;는 &quot;master&quot;입니다.</target>
        </trans-unit>
        <trans-unit id="c033f0ddddff0b7a496ef058316bfe1c29b59dcb" translate="yes" xml:space="preserve">
          <source>The default &lt;a href=&quot;#def_branch&quot;&gt;branch&lt;/a&gt; that is merged into the branch in question (or the branch in question is rebased onto). It is configured via branch.&amp;lt;name&amp;gt;.remote and branch.&amp;lt;name&amp;gt;.merge. If the upstream branch of 'A' is 'origin/B' sometimes we say &quot;'A' is tracking 'origin/B'&quot;.</source>
          <target state="translated">해당 &lt;a href=&quot;#def_branch&quot;&gt;브랜치&lt;/a&gt; 에 병합 된 기본 브랜치 (또는 해당 브랜치가 기반) branch. &amp;lt;name&amp;gt; .remote 및 branch. &amp;lt;name&amp;gt; .merge를 통해 구성됩니다. 'A'의 상류 지점이 'origin / B'인 경우 ''A '는'origin / B '를 추적하고 있습니다'라고 말합니다.</target>
        </trans-unit>
        <trans-unit id="0e2c938aad423666052c9b862a31c7bd282b15cb" translate="yes" xml:space="preserve">
          <source>The default &lt;a href=&quot;#def_branch&quot;&gt;branch&lt;/a&gt; that is merged into the branch in question (or the branch in question is rebased onto). It is configured via branch.&amp;lt;name&amp;gt;.remote and branch.&amp;lt;name&amp;gt;.merge. If the upstream branch of &lt;code&gt;A&lt;/code&gt; is &lt;code&gt;origin/B&lt;/code&gt; sometimes we say &quot;&lt;code&gt;A&lt;/code&gt; is tracking &lt;code&gt;origin/B&lt;/code&gt;&quot;.</source>
          <target state="translated">해당 &lt;a href=&quot;#def_branch&quot;&gt;브랜치&lt;/a&gt; 에 병합 된 기본 브랜치 (또는 해당 브랜치가 기반) branch. &amp;lt;name&amp;gt; .remote 및 branch. &amp;lt;name&amp;gt; .merge를 통해 구성됩니다. &lt;code&gt;A&lt;/code&gt; 의 업스트림 분기 가 &lt;code&gt;origin/B&lt;/code&gt; 경우 &quot; &lt;code&gt;A&lt;/code&gt; 는 &lt;code&gt;origin/B&lt;/code&gt; 추적합니다 &quot;라고 말합니다 .</target>
        </trans-unit>
        <trans-unit id="2a57474834373f0012a2eee4dc03542456f6b683" translate="yes" xml:space="preserve">
          <source>The default &lt;code&gt;applypatch-msg&lt;/code&gt; hook, when enabled, runs the &lt;code&gt;commit-msg&lt;/code&gt; hook, if the latter is enabled.</source>
          <target state="translated">활성화 된 경우 기본 &lt;code&gt;applypatch-msg&lt;/code&gt; 후크는 &lt;code&gt;commit-msg&lt;/code&gt; 후크를 실행 합니다 (후자가 활성화 된 경우).</target>
        </trans-unit>
        <trans-unit id="1004092b458b148233da1997202a081689268a8e" translate="yes" xml:space="preserve">
          <source>The default &lt;code&gt;commit-msg&lt;/code&gt; hook, when enabled, detects duplicate &quot;Signed-off-by&quot; lines, and aborts the commit if one is found.</source>
          <target state="translated">기본 &lt;code&gt;commit-msg&lt;/code&gt; 훅은 활성화되면 중복 된 &quot;Signed-off-by&quot;라인을 감지하고 커밋이 발견되면 중단합니다.</target>
        </trans-unit>
        <trans-unit id="54e7a2ab7a7ead4c100931e31ff4408636c3868d" translate="yes" xml:space="preserve">
          <source>The default &lt;code&gt;post-receive&lt;/code&gt; hook is empty, but there is a sample script &lt;code&gt;post-receive-email&lt;/code&gt; provided in the &lt;code&gt;contrib/hooks&lt;/code&gt; directory in Git distribution, which implements sending commit emails.</source>
          <target state="translated">기본 &lt;code&gt;post-receive&lt;/code&gt; 후크는 비어 있지만 Git 배포 의 &lt;code&gt;contrib/hooks&lt;/code&gt; 디렉토리에 샘플 스크립트 &lt;code&gt;post-receive-email&lt;/code&gt; 제공되어 커밋 이메일 전송을 구현합니다.</target>
        </trans-unit>
        <trans-unit id="a71e842d9eb90ca6731ba585809c1f8c19eb80f6" translate="yes" xml:space="preserve">
          <source>The default &lt;code&gt;pre-applypatch&lt;/code&gt; hook, when enabled, runs the &lt;code&gt;pre-commit&lt;/code&gt; hook, if the latter is enabled.</source>
          <target state="translated">활성화 된 기본 &lt;code&gt;pre-applypatch&lt;/code&gt; 후크는 &lt;code&gt;pre-commit&lt;/code&gt; 후크를 활성화합니다 (후자가 활성화 된 경우).</target>
        </trans-unit>
        <trans-unit id="b4266565542333c335464dc9285134a4a9b31011" translate="yes" xml:space="preserve">
          <source>The default &lt;code&gt;pre-commit&lt;/code&gt; hook, when enabled&amp;mdash;​and with the &lt;code&gt;hooks.allownonascii&lt;/code&gt; config option unset or set to false&amp;mdash;​prevents the use of non-ASCII filenames.</source>
          <target state="translated">활성화되어 있고 &lt;code&gt;hooks.allownonascii&lt;/code&gt; 구성 옵션이 설정되지 않았거나 false로 설정된 기본 &lt;code&gt;pre-commit&lt;/code&gt; 후크는 ASCII가 아닌 파일 이름을 사용하지 못하게합니다.</target>
        </trans-unit>
        <trans-unit id="c591fe93d0021a0c7991225b1a062c31f35ddd16" translate="yes" xml:space="preserve">
          <source>The default &lt;code&gt;pre-commit&lt;/code&gt; hook, when enabled, catches introduction of lines with trailing whitespaces and aborts the commit when such a line is found.</source>
          <target state="translated">사용 가능한 경우 기본 &lt;code&gt;pre-commit&lt;/code&gt; 후크는 후행 공백이있는 라인의 도입을 포착하고 해당 라인이 발견되면 커미트를 중단합니다.</target>
        </trans-unit>
        <trans-unit id="5c24125124251d23fec260bbe8f20bf4ce1ae496" translate="yes" xml:space="preserve">
          <source>The default &lt;code&gt;pre-merge-commit&lt;/code&gt; hook, when enabled, runs the &lt;code&gt;pre-commit&lt;/code&gt; hook, if the latter is enabled.</source>
          <target state="translated">기본 &lt;code&gt;pre-merge-commit&lt;/code&gt; 후크 (사용 가능한 경우)는 &lt;code&gt;pre-commit&lt;/code&gt; 후크 ( 사용 가능한 경우)를 실행합니다 .</target>
        </trans-unit>
        <trans-unit id="c0f0841a2790ebd8e4684a32dafde265e2735139" translate="yes" xml:space="preserve">
          <source>The default &lt;code&gt;update&lt;/code&gt; hook, when enabled&amp;mdash;​and with &lt;code&gt;hooks.allowunannotated&lt;/code&gt; config option unset or set to false&amp;mdash;​prevents unannotated tags to be pushed.</source>
          <target state="translated">활성화되어 있고 &lt;code&gt;hooks.allowunannotated&lt;/code&gt; 구성 옵션이 설정되지 않았거나 false로 설정된 기본 &lt;code&gt;update&lt;/code&gt; 후크 는 주석이없는 태그가 푸시되는 것을 방지합니다.</target>
        </trans-unit>
        <trans-unit id="e99caaee535fa5770d85355802dd91eb002c650f" translate="yes" xml:space="preserve">
          <source>The default behavior of this command when no &amp;lt;refspec&amp;gt; is given can be configured by setting the &lt;code&gt;push&lt;/code&gt; option of the remote, or the &lt;code&gt;push.default&lt;/code&gt; configuration variable.</source>
          <target state="translated">&amp;lt;refspec&amp;gt;을 지정하지 않은 경우이 명령의 기본 동작은 리모콘 의 &lt;code&gt;push&lt;/code&gt; 옵션 또는 &lt;code&gt;push.default&lt;/code&gt; 구성 변수 를 설정하여 구성 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="04fb2222b71daf513a74198926f20b6eb1c65e53" translate="yes" xml:space="preserve">
          <source>The default can be changed by the &lt;code&gt;commit.cleanup&lt;/code&gt; configuration variable (see &lt;a href=&quot;git-config&quot;&gt;git-config[1]&lt;/a&gt;).</source>
          <target state="translated">&lt;code&gt;commit.cleanup&lt;/code&gt; 구성 변수 로 기본값을 변경할 수 있습니다 ( &lt;a href=&quot;git-config&quot;&gt;git-config [1] 참조&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="6d2b951210087bf6a12979c879cea7654da192ce" translate="yes" xml:space="preserve">
          <source>The default can be changed using the status.showUntrackedFiles configuration variable documented in &lt;a href=&quot;git-config&quot;&gt;git-config[1]&lt;/a&gt;.</source>
          <target state="translated">기본값은 &lt;a href=&quot;git-config&quot;&gt;git-config [1]에&lt;/a&gt; 설명 된 status.showUntrackedFiles 구성 변수를 사용하여 변경할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="f4804356dda86c0d39019920e2a204580a3348e0" translate="yes" xml:space="preserve">
          <source>The default configuration with no configuration file at all may work perfectly well for some installations. Still, a configuration file is useful for customizing or tweaking the behavior of gitweb in many ways, and some optional features will not be present unless explicitly enabled using the configurable &lt;code&gt;%features&lt;/code&gt; variable (see also &quot;Configuring gitweb features&quot; section below).</source>
          <target state="translated">구성 파일이 전혀없는 기본 구성은 일부 설치에서 완벽하게 작동 할 수 있습니다. 그래도 구성 파일은 여러 가지 방법으로 gitweb의 동작을 사용자 정의하거나 조정하는 데 유용하며 구성 가능한 &lt;code&gt;%features&lt;/code&gt; 변수를 사용하여 명시 적으로 활성화하지 않으면 일부 선택적 기능이 나타나지 않습니다 (아래 &quot;gitweb 기능 구성&quot;섹션 참조).</target>
        </trans-unit>
        <trans-unit id="ba35598baf99b4759b4ac8e8e152046ad84f4f70" translate="yes" xml:space="preserve">
          <source>The default destination is &lt;code&gt;syslog&lt;/code&gt; if &lt;code&gt;--inetd&lt;/code&gt; or &lt;code&gt;--detach&lt;/code&gt; is specified, otherwise &lt;code&gt;stderr&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;--inetd&lt;/code&gt; 또는 &lt;code&gt;--detach&lt;/code&gt; 가 지정된 경우 기본 대상은 &lt;code&gt;syslog&lt;/code&gt; 이고 , 그렇지 않으면 &lt;code&gt;stderr&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="08a91820da4ab8ff0557091a83e78baf95e62cbc" translate="yes" xml:space="preserve">
          <source>The default development &lt;a href=&quot;#def_branch&quot;&gt;branch&lt;/a&gt;. Whenever you create a Git &lt;a href=&quot;#def_repository&quot;&gt;repository&lt;/a&gt;, a branch named &quot;master&quot; is created, and becomes the active branch. In most cases, this contains the local development, though that is purely by convention and is not required.</source>
          <target state="translated">기본 개발 &lt;a href=&quot;#def_branch&quot;&gt;지점&lt;/a&gt; . Git &lt;a href=&quot;#def_repository&quot;&gt;리포지토리&lt;/a&gt; 를 만들 때마다 &quot;master&quot;라는 분기가 만들어지고 활성 분기가됩니다. 대부분의 경우 여기에는 로컬 개발이 포함되어 있지만 이는 순전히 규칙에 의한 것이며 필수는 아닙니다.</target>
        </trans-unit>
        <trans-unit id="9cfb0587d78b80316db2bf990e0689e616d2c4e9" translate="yes" xml:space="preserve">
          <source>The default diff tool to use when &lt;code&gt;--gui&lt;/code&gt; is specified.</source>
          <target state="translated">&lt;code&gt;--gui&lt;/code&gt; 를 지정할 때 사용할 기본 diff 도구 입니다.</target>
        </trans-unit>
        <trans-unit id="2106f60990b064f5f08c291bb6d584e30eb4aef6" translate="yes" xml:space="preserve">
          <source>The default diff tool to use.</source>
          <target state="translated">사용할 기본 diff 도구입니다.</target>
        </trans-unit>
        <trans-unit id="ef7818a768aaedb1852c90af2f69c6d87d81a9be" translate="yes" xml:space="preserve">
          <source>The default for format-patch is to output a signature containing the Git version number. Use this variable to change that default. Set this variable to the empty string (&quot;&quot;) to suppress signature generation.</source>
          <target state="translated">format-patch의 기본값은 Git 버전 번호가 포함 된 서명을 출력하는 것입니다. 이 변수를 사용하여 해당 기본값을 변경하십시오. 서명 생성을 억제하려면이 변수를 빈 문자열 ( &quot;&quot;)로 설정하십시오.</target>
        </trans-unit>
        <trans-unit id="04f69f6bfbe685cc6892bfe73707b968c4b7e627" translate="yes" xml:space="preserve">
          <source>The default for format-patch is to output files with the &lt;code&gt;[PATCH]&lt;/code&gt; subject prefix. Use this variable to change that prefix.</source>
          <target state="translated">format-patch의 기본값은 &lt;code&gt;[PATCH]&lt;/code&gt; 제목 접두어로 파일을 출력하는 것입니다 . 이 변수를 사용하여 해당 접 두부를 변경하십시오.</target>
        </trans-unit>
        <trans-unit id="9305a301a407a477c0982cd809ad589540305e9b" translate="yes" xml:space="preserve">
          <source>The default for format-patch is to output files with the suffix &lt;code&gt;.patch&lt;/code&gt;. Use this variable to change that suffix (make sure to include the dot if you want it).</source>
          <target state="translated">format-patch의 기본값은 접미사 &lt;code&gt;.patch&lt;/code&gt; 로 파일을 출력하는 것입니다 . 이 변수를 사용하여 해당 접미사를 변경하십시오 (원하는 경우 점을 포함 시키십시오).</target>
        </trans-unit>
        <trans-unit id="82f6ff06915abbfaa5bafadf3e71c6515eea8a49" translate="yes" xml:space="preserve">
          <source>The default for the patch directory is patches or the value of the &lt;code&gt;$QUILT_PATCHES&lt;/code&gt; environment variable.</source>
          <target state="translated">패치 디렉토리의 기본값은 패치 또는 &lt;code&gt;$QUILT_PATCHES&lt;/code&gt; 환경 변수 의 값입니다 .</target>
        </trans-unit>
        <trans-unit id="63e417c4ba57abb65259188be896bb91267bad84" translate="yes" xml:space="preserve">
          <source>The default for the series file is &amp;lt;patches&amp;gt;/series or the value of the &lt;code&gt;$QUILT_SERIES&lt;/code&gt; environment variable.</source>
          <target state="translated">시리즈 파일의 기본값은 &amp;lt;patches&amp;gt; / series 또는 &lt;code&gt;$QUILT_SERIES&lt;/code&gt; 환경 변수 의 값입니다 .</target>
        </trans-unit>
        <trans-unit id="43b413a4d69c795f1a4cc6e5069d43aa254cba9e" translate="yes" xml:space="preserve">
          <source>The default format does not show what the original said in the conflicting area. You cannot tell how many lines are deleted and replaced with Barbie&amp;rsquo;s remark on your side. The only thing you can tell is that your side wants to say it is hard and you&amp;rsquo;d prefer to go shopping, while the other side wants to claim it is easy.</source>
          <target state="translated">기본 형식은 충돌 영역에서 원본이 말한 내용을 표시하지 않습니다. 몇 줄이 삭제되고 바비의 발언으로 바뀔지 알 수 없습니다. 당신이 말할 수있는 유일한 것은 당신의 측이 어렵다고 말하고 싶어하고 당신이 쇼핑하러 가고 싶어하는 반면, 다른 쪽은 그것이 쉽다고 주장하기를 원한다는 것입니다.</target>
        </trans-unit>
        <trans-unit id="2c9ac4b5e02925d5a2242fa228d32b0af91d581b" translate="yes" xml:space="preserve">
          <source>The default is &lt;code&gt;--no-notes&lt;/code&gt;, unless the &lt;code&gt;format.notes&lt;/code&gt; configuration is set.</source>
          <target state="translated">&lt;code&gt;format.notes&lt;/code&gt; 구성이 설정되어 있지 않으면 기본값은 &lt;code&gt;--no-notes&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="e210eb7dbec89858b8e72d64e2d379a9aada6a48" translate="yes" xml:space="preserve">
          <source>The default is &lt;code&gt;--no-thread&lt;/code&gt;, unless the &lt;code&gt;format.thread&lt;/code&gt; configuration is set. If &lt;code&gt;--thread&lt;/code&gt; is specified without a style, it defaults to the style specified by &lt;code&gt;format.thread&lt;/code&gt; if any, or else &lt;code&gt;shallow&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;format.thread&lt;/code&gt; 구성이 설정되어 있지 않으면 기본값은 &lt;code&gt;--no-thread&lt;/code&gt; 입니다. 경우 &lt;code&gt;--thread&lt;/code&gt; 는 스타일없이 지정에 의해 지정된 스타일을 기본값 &lt;code&gt;format.thread&lt;/code&gt; 있는 경우, 또는 다른 &lt;code&gt;shallow&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9abe1131612b105426f13be17707662aa8662d23" translate="yes" xml:space="preserve">
          <source>The default is false, except &lt;a href=&quot;git-clone&quot;&gt;git-clone[1]&lt;/a&gt; or &lt;a href=&quot;git-init&quot;&gt;git-init[1]&lt;/a&gt; will probe and set core.ignoreCase true if appropriate when the repository is created.</source>
          <target state="translated">&lt;a href=&quot;git-clone&quot;&gt;git-clone [1]&lt;/a&gt; 또는 &lt;a href=&quot;git-init&quot;&gt;git-init [1]&lt;/a&gt; 이 리포지토리 생성시 적절한 경우 core.ignoreCase를 검사하고 true로 설정한다는 점을 제외하고 기본값은 false 입니다.</target>
        </trans-unit>
        <trans-unit id="fcf73b7882b6e3d265136d0071b137412decce56" translate="yes" xml:space="preserve">
          <source>The default is not to print any annotation lines. If no number is given to &lt;code&gt;-n&lt;/code&gt;, only the first line is printed. If the tag is not annotated, the commit message is displayed instead.</source>
          <target state="translated">기본값은 주석 행을 인쇄하지 않는 것입니다. &lt;code&gt;-n&lt;/code&gt; 에 숫자가 제공되지 않으면 첫 번째 행만 인쇄됩니다. 태그에 주석을 달지 않으면 커밋 메시지가 대신 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="19baf950afb8f746e54b7299adf6fbd6966f659a" translate="yes" xml:space="preserve">
          <source>The default is to diff against our branch (-2) and the cleanly resolved paths. The option -0 can be given to omit diff output for unmerged entries and just show &quot;Unmerged&quot;.</source>
          <target state="translated">디폴트는 브랜치 (-2)와 깨끗하게 해결 된 경로와 다른 것입니다. 옵션 -0을 사용하면 병합되지 않은 항목에 대한 diff 출력을 생략하고 &quot;Unmerged&quot;만 표시 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="70f152ab57d660d365ae81763277f72b2d86f307" translate="yes" xml:space="preserve">
          <source>The default is true (when core.filemode is not specified in the config file).</source>
          <target state="translated">기본값은 true입니다 (config 파일에 core.filemode가 지정되지 않은 경우).</target>
        </trans-unit>
        <trans-unit id="03228e9bc81b32ffbccac2430f1d794dd7591d2a" translate="yes" xml:space="preserve">
          <source>The default is true, except &lt;a href=&quot;git-clone&quot;&gt;git-clone[1]&lt;/a&gt; or &lt;a href=&quot;git-init&quot;&gt;git-init[1]&lt;/a&gt; will probe and set core.symlinks false if appropriate when the repository is created.</source>
          <target state="translated">&lt;a href=&quot;git-clone&quot;&gt;git-clone [1]&lt;/a&gt; 또는 &lt;a href=&quot;git-init&quot;&gt;git-init [1]&lt;/a&gt; 이 리포지토리 생성시 적절한 경우 core.symlinks를 검사하고 설정하지 않는 것을 제외하고 기본값은 true 입니다.</target>
        </trans-unit>
        <trans-unit id="72445c1104c1c11ef748913a9c6e570e5a73c947" translate="yes" xml:space="preserve">
          <source>The default location of the CVS checkout to use for the export.</source>
          <target state="translated">내보내기에 사용할 CVS 체크 아웃의 기본 위치입니다.</target>
        </trans-unit>
        <trans-unit id="116262510e324641581bf8e5fe54c44cc1ec58f5" translate="yes" xml:space="preserve">
          <source>The default merge strategy to use when pulling a single branch.</source>
          <target state="translated">단일 분기를 가져올 때 사용할 기본 병합 전략입니다.</target>
        </trans-unit>
        <trans-unit id="a808540aa8de08b00cb350dbc14ab54e33fa8faf" translate="yes" xml:space="preserve">
          <source>The default merge strategy to use when pulling multiple branches at once.</source>
          <target state="translated">한 번에 여러 분기를 가져올 때 사용할 기본 병합 전략입니다.</target>
        </trans-unit>
        <trans-unit id="e2e648395119cc70a2e9e998b6f3d4c60294fc12" translate="yes" xml:space="preserve">
          <source>The default mode for format-patch to determine which parts of the cover letter will be populated using the branch&amp;rsquo;s description. See the &lt;code&gt;--cover-from-description&lt;/code&gt; option in &lt;a href=&quot;git-format-patch&quot;&gt;git-format-patch[1]&lt;/a&gt;.</source>
          <target state="translated">분기의 설명을 사용하여 표지의 어떤 부분을 채울지 결정하는 format-patch의 기본 모드입니다. &lt;a href=&quot;git-format-patch&quot;&gt;git-format-patch [1]&lt;/a&gt; 의 &lt;code&gt;--cover-from-description&lt;/code&gt; 옵션을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="063faead523251f77be0529092965c3429cc8003" translate="yes" xml:space="preserve">
          <source>The default module path for &lt;a href=&quot;git-instaweb&quot;&gt;git-instaweb[1]&lt;/a&gt; to use instead of /usr/lib/apache2/modules. Only used if httpd is Apache.</source>
          <target state="translated">/ usr / lib / apache2 / modules 대신 사용할 &lt;a href=&quot;git-instaweb&quot;&gt;git-instaweb [1]&lt;/a&gt; 의 기본 모듈 경로입니다 . httpd가 Apache 인 경우에만 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="91f8aff2bf27bb7f60525104a4a75d78c7ffe52b" translate="yes" xml:space="preserve">
          <source>The default notes merge strategy is &quot;manual&quot;, which checks out conflicting notes in a special work tree for resolving notes conflicts (&lt;code&gt;.git/NOTES_MERGE_WORKTREE&lt;/code&gt;), and instructs the user to resolve the conflicts in that work tree. When done, the user can either finalize the merge with &lt;code&gt;git notes merge --commit&lt;/code&gt;, or abort the merge with &lt;code&gt;git notes merge --abort&lt;/code&gt;.</source>
          <target state="translated">기본 메모 병합 전략은 &quot;수동&quot;으로, 메모 충돌을 해결하기 위해 특수 작업 트리에서 충돌 메모를 확인하고 ( &lt;code&gt;.git/NOTES_MERGE_WORKTREE&lt;/code&gt; ) 해당 작업 트리에서 충돌을 해결하도록 사용자에게 지시합니다. 완료되면 사용자는 &lt;code&gt;git notes merge --commit&lt;/code&gt; 으로 병합을 완료하거나 git notes merge --abort로 병합을 중단 &lt;code&gt;git notes merge --abort&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d49acb565d9b642605b0a997d7ebc3213ecdde25" translate="yes" xml:space="preserve">
          <source>The default pretty format for log/show/whatchanged command, See &lt;a href=&quot;git-log&quot;&gt;git-log[1]&lt;/a&gt;, &lt;a href=&quot;git-show&quot;&gt;git-show[1]&lt;/a&gt;, &lt;a href=&quot;git-whatchanged&quot;&gt;git-whatchanged[1]&lt;/a&gt;.</source>
          <target state="translated">log / show / whatchanged 명령의 기본 pretty 형식은 &lt;a href=&quot;git-log&quot;&gt;git-log [1]&lt;/a&gt; , &lt;a href=&quot;git-show&quot;&gt;git-show [1]&lt;/a&gt; , &lt;a href=&quot;git-whatchanged&quot;&gt;git-whatchanged [1]을 참조하십시오&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="c642123af45071133c151f29614b42c5bfc1ffac" translate="yes" xml:space="preserve">
          <source>The default program to execute on the remote side when fetching. See option --upload-pack of &lt;a href=&quot;git-fetch-pack&quot;&gt;git-fetch-pack[1]&lt;/a&gt;.</source>
          <target state="translated">가져올 때 원격에서 실행할 기본 프로그램입니다. &lt;a href=&quot;git-fetch-pack&quot;&gt;git-fetch-pack [1]&lt;/a&gt; 의 --upload-pack 옵션을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="02bc1378d0d05db5e7ff2ca7062e80f4098e5579" translate="yes" xml:space="preserve">
          <source>The default program to execute on the remote side when pushing. See option --receive-pack of &lt;a href=&quot;git-push&quot;&gt;git-push[1]&lt;/a&gt;.</source>
          <target state="translated">밀 때 원격에서 실행할 기본 프로그램입니다. &lt;a href=&quot;git-push&quot;&gt;git-push [1]&lt;/a&gt; 의 --receive-pack 옵션을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="1520b8813a02e6817b17665a2200c8c1eb73489c" translate="yes" xml:space="preserve">
          <source>The default remote is the remote of the remote-tracking branch of the current branch. If no such remote-tracking branch exists or the HEAD is detached, &quot;origin&quot; is assumed to be the default remote. If the superproject doesn&amp;rsquo;t have a default remote configured the superproject is its own authoritative upstream and the current working directory is used instead.</source>
          <target state="translated">기본 원격은 현재 지점의 원격 추적 분기의 원격입니다. 이러한 원격 추적 분기가 없거나 HEAD가 분리 된 경우 &quot;원본&quot;이 기본 원격으로 간주됩니다. 수퍼 프로젝트에 기본 원격이 구성되어 있지 않은 경우 수퍼 프로젝트는 자체 권위있는 업스트림이며 현재 작업 디렉토리가 대신 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="0d78370864f4fde80869e4efb080139612c8d161" translate="yes" xml:space="preserve">
          <source>The default set of &quot;refspec&quot; for &lt;a href=&quot;git-fetch&quot;&gt;git-fetch[1]&lt;/a&gt;. See &lt;a href=&quot;git-fetch&quot;&gt;git-fetch[1]&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;git-fetch&quot;&gt;git-fetch [1]&lt;/a&gt; 의 기본 &quot;refspec&quot;세트 . &lt;a href=&quot;git-fetch&quot;&gt;git-fetch [1]을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="6e7461b63dbe3a9bd4be74e77260f6121d70becf" translate="yes" xml:space="preserve">
          <source>The default set of &quot;refspec&quot; for &lt;a href=&quot;git-push&quot;&gt;git-push[1]&lt;/a&gt;. See &lt;a href=&quot;git-push&quot;&gt;git-push[1]&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;git-push&quot;&gt;git-push [1]&lt;/a&gt; 의 기본 &quot;refspec&quot;세트 . &lt;a href=&quot;git-push&quot;&gt;git-push [1]을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="9b1d55965a766c32086046542d13a0c5cafb5d20" translate="yes" xml:space="preserve">
          <source>The default set of branches for &lt;a href=&quot;git-show-branch&quot;&gt;git-show-branch[1]&lt;/a&gt;. See &lt;a href=&quot;git-show-branch&quot;&gt;git-show-branch[1]&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;git-show-branch&quot;&gt;git-show-branch [1]&lt;/a&gt; 의 기본 분기 세트입니다 . &lt;a href=&quot;git-show-branch&quot;&gt;git-show-branch [1]을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="8f8a6ecfdcb232e0e35afa31c75a9bb76e3ba014" translate="yes" xml:space="preserve">
          <source>The default template directory includes some directory structure, suggested &quot;exclude patterns&quot; (see &lt;a href=&quot;gitignore&quot;&gt;gitignore[5]&lt;/a&gt;), and sample hook files.</source>
          <target state="translated">기본 템플리트 디렉토리에는 일부 디렉토리 구조, 제안 된 &quot;제외 패턴&quot;( &lt;a href=&quot;gitignore&quot;&gt;gitignore [5]&lt;/a&gt; 참조 ) 및 샘플 후크 파일이 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="5c5dda91be7317473d73b4f4f28156d762d8905f" translate="yes" xml:space="preserve">
          <source>The default threading style for &lt;code&gt;git format-patch&lt;/code&gt;. Can be a boolean value, or &lt;code&gt;shallow&lt;/code&gt; or &lt;code&gt;deep&lt;/code&gt;. &lt;code&gt;shallow&lt;/code&gt; threading makes every mail a reply to the head of the series, where the head is chosen from the cover letter, the &lt;code&gt;--in-reply-to&lt;/code&gt;, and the first patch mail, in this order. &lt;code&gt;deep&lt;/code&gt; threading makes every mail a reply to the previous one. A true boolean value is the same as &lt;code&gt;shallow&lt;/code&gt;, and a false value disables threading.</source>
          <target state="translated">&lt;code&gt;git format-patch&lt;/code&gt; 의 기본 스레딩 스타일입니다 . 부울 값이거나 &lt;code&gt;shallow&lt;/code&gt; 또는 &lt;code&gt;deep&lt;/code&gt; 일 수 있습니다 . &lt;code&gt;shallow&lt;/code&gt; 스레드는 모든 메일을 시리즈의 헤드에 대한 답장으로 만듭니다. 여기서 헤드는 커버 레터, &lt;code&gt;--in-reply-to&lt;/code&gt; 및 첫 번째 패치 메일에서이 순서대로 선택됩니다. &lt;code&gt;deep&lt;/code&gt; 스레딩은 모든 메일을 이전 메일에 대한 회신으로 만듭니다. true 부울 값은 &lt;code&gt;shallow&lt;/code&gt; 과 동일 하며 false 값은 스레딩을 비활성화합니다.</target>
        </trans-unit>
        <trans-unit id="0eb7f832f6b33a6020eb8629fee287c4b15b4801" translate="yes" xml:space="preserve">
          <source>The default upstream &lt;a href=&quot;#def_repository&quot;&gt;repository&lt;/a&gt;. Most projects have at least one upstream project which they track. By default 'origin' is used for that purpose. New upstream updates will be fetched into &lt;a href=&quot;#def_remote_tracking_branch&quot;&gt;remote-tracking branches&lt;/a&gt; named origin/name-of-upstream-branch, which you can see using &lt;code&gt;git branch -r&lt;/code&gt;.</source>
          <target state="translated">기본 업스트림 &lt;a href=&quot;#def_repository&quot;&gt;저장소&lt;/a&gt; . 대부분의 프로젝트에는 추적 할 하나 이상의 업스트림 프로젝트가 있습니다. 기본적으로 'origin'이 해당 목적으로 사용됩니다. 새로운 업스트림 업데이트는 origin / name-of-upstream-branch라는 &lt;a href=&quot;#def_remote_tracking_branch&quot;&gt;원격 추적 분기&lt;/a&gt; 로 가져 &lt;code&gt;git branch -r&lt;/code&gt; 사용하여 볼 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="4f838be44da45fd1828d0b46b391485ccd56187e" translate="yes" xml:space="preserve">
          <source>The default upstream &lt;a href=&quot;#def_repository&quot;&gt;repository&lt;/a&gt;. Most projects have at least one upstream project which they track. By default &lt;code&gt;origin&lt;/code&gt; is used for that purpose. New upstream updates will be fetched into &lt;a href=&quot;#def_remote_tracking_branch&quot;&gt;remote-tracking branches&lt;/a&gt; named origin/name-of-upstream-branch, which you can see using &lt;code&gt;git branch -r&lt;/code&gt;.</source>
          <target state="translated">기본 업스트림 &lt;a href=&quot;#def_repository&quot;&gt;저장소&lt;/a&gt; . 대부분의 프로젝트에는 추적 할 하나 이상의 업스트림 프로젝트가 있습니다. 기본적으로 해당 용도로 &lt;code&gt;origin&lt;/code&gt; 이 사용됩니다. 새로운 업스트림 업데이트는 origin / name-of-upstream-branch라는 &lt;a href=&quot;#def_remote_tracking_branch&quot;&gt;원격 추적 분기&lt;/a&gt; 로 가져 &lt;code&gt;git branch -r&lt;/code&gt; 사용하여 볼 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="66087a54aa582dff2f539d6f92ec2461ac3012fd" translate="yes" xml:space="preserve">
          <source>The default value for --window is 10 and --depth is 50. The maximum depth is 4095.</source>
          <target state="translated">--window의 기본값은 10이고 --depth는 50입니다. 최대 깊이는 4095입니다.</target>
        </trans-unit>
        <trans-unit id="90d3816cdd271ff4f563d74700f0c34c9ae7702c" translate="yes" xml:space="preserve">
          <source>The default value for &lt;code&gt;$projectroot&lt;/code&gt; is &lt;code&gt;/pub/git&lt;/code&gt;. You can change it during building gitweb via &lt;code&gt;GITWEB_PROJECTROOT&lt;/code&gt; build configuration variable.</source>
          <target state="translated">&lt;code&gt;$projectroot&lt;/code&gt; 의 기본값 은 &lt;code&gt;/pub/git&lt;/code&gt; 입니다. &lt;code&gt;GITWEB_PROJECTROOT&lt;/code&gt; 빌드 구성 변수 를 통해 gitweb을 빌드 하는 동안이를 변경할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="78bcbc1a976cbafa1db494161487aec966c7436d" translate="yes" xml:space="preserve">
          <source>The default value is either &lt;code&gt;static/gitweb.js&lt;/code&gt;, or &lt;code&gt;static/gitweb.min.js&lt;/code&gt; if the &lt;code&gt;JSMIN&lt;/code&gt; build variable was defined, i.e. if JavaScript minifier was used at build time. &lt;strong&gt;Note&lt;/strong&gt; that this single file is generated from multiple individual JavaScript &quot;modules&quot;.</source>
          <target state="translated">&lt;code&gt;JSMIN&lt;/code&gt; 빌드 변수가 정의 된 경우 (예 : 빌드시 JavaScript minifier가 사용 된 경우) 기본값은 &lt;code&gt;static/gitweb.js&lt;/code&gt; 또는 &lt;code&gt;static/gitweb.min.js&lt;/code&gt; 입니다. &lt;strong&gt;참고&lt;/strong&gt; 이 하나의 파일이 여러 개인 자바 스크립트 &quot;모듈&quot;에서 생성됩니다.&lt;strong&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="88fcf9aad2af8490af6dabfabbb5732019a6c8e1" translate="yes" xml:space="preserve">
          <source>The default value of this variable is determined by the &lt;code&gt;GITWEB_LIST&lt;/code&gt; makefile variable at installation time. If this variable is empty, gitweb will fall back to scanning the &lt;code&gt;$projectroot&lt;/code&gt; directory for repositories.</source>
          <target state="translated">이 변수의 기본값 은 설치시 &lt;code&gt;GITWEB_LIST&lt;/code&gt; makefile 변수에 의해 결정됩니다 . 이 변수가 비어 있으면 gitweb은 &lt;code&gt;$projectroot&lt;/code&gt; 디렉토리에서 리포지토리 를 검색 합니다.</target>
        </trans-unit>
        <trans-unit id="da622b41696b803144c5254aad9443c84211d515" translate="yes" xml:space="preserve">
          <source>The default value of this variable is determined by the build-time configuration variable &lt;code&gt;GITWEB_PROJECT_MAXDEPTH&lt;/code&gt;, which defaults to 2007.</source>
          <target state="translated">이 변수의 기본값은 빌드 시간 구성 변수 &lt;code&gt;GITWEB_PROJECT_MAXDEPTH&lt;/code&gt; 에 의해 결정되며 기본값은 2007입니다.</target>
        </trans-unit>
        <trans-unit id="777a0a86855d35a436d0a0e990f3b787a636cb43" translate="yes" xml:space="preserve">
          <source>The defined extensions are:</source>
          <target state="translated">정의 된 확장자는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="2309a4e043845fb6e7e786e69af3d5ed57221f3f" translate="yes" xml:space="preserve">
          <source>The definition of a diff driver is done in &lt;code&gt;gitconfig&lt;/code&gt;, not &lt;code&gt;gitattributes&lt;/code&gt; file, so strictly speaking this manual page is a wrong place to talk about it. However&amp;hellip;​</source>
          <target state="translated">diff 드라이버의 정의는 &lt;code&gt;gitattributes&lt;/code&gt; 파일이 아닌 &lt;code&gt;gitconfig&lt;/code&gt; 에서 수행 되므로이 매뉴얼 페이지를 엄격하게 말하면 잘못된 위치입니다. 그러나&amp;hellip;</target>
        </trans-unit>
        <trans-unit id="05fbc211f0bbdc85a5cbba915fe02006f8119e9e" translate="yes" xml:space="preserve">
          <source>The definition of a merge driver is done in the &lt;code&gt;.git/config&lt;/code&gt; file, not in the &lt;code&gt;gitattributes&lt;/code&gt; file, so strictly speaking this manual page is a wrong place to talk about it. However&amp;hellip;​</source>
          <target state="translated">병합 드라이버의 정의는 &lt;code&gt;gitattributes&lt;/code&gt; 파일이 아닌 &lt;code&gt;.git/config&lt;/code&gt; 파일에서 수행 되므로이 매뉴얼 페이지를 엄격하게 말하면 잘못된 위치입니다. 그러나&amp;hellip;</target>
        </trans-unit>
        <trans-unit id="096c7fcd9c9053c9edd8c72ca9c95b04e65c3409" translate="yes" xml:space="preserve">
          <source>The deletion removes the superproject&amp;rsquo;s tracking data, which are both the &lt;code&gt;gitlink&lt;/code&gt; entry and the section in the &lt;code&gt;.gitmodules&lt;/code&gt; file. The submodule&amp;rsquo;s working directory is removed from the file system, but the Git directory is kept around as it to make it possible to checkout past commits without requiring fetching from another repository.</source>
          <target state="translated">삭제하면 &lt;code&gt;gitlink&lt;/code&gt; 항목과 &lt;code&gt;.gitmodules&lt;/code&gt; 파일 의 섹션 인 수퍼 프로젝트의 추적 데이터가 제거 됩니다. 서브 모듈의 작업 디렉토리는 파일 시스템에서 제거되지만 Git 디렉토리는 다른 저장소에서 가져 오지 않고도 과거의 커밋을 체크 아웃 할 수 있도록 유지됩니다.</target>
        </trans-unit>
        <trans-unit id="c4fe2a741691af413a8b078592b8e6a937844e84" translate="yes" xml:space="preserve">
          <source>The delta data is a sequence of instructions to reconstruct an object from the base object. If the base object is deltified, it must be converted to canonical form first. Each instruction appends more and more data to the target object until it&amp;rsquo;s complete. There are two supported instructions so far: one for copy a byte range from the source object and one for inserting new data embedded in the instruction itself.</source>
          <target state="translated">델타 데이터는 기본 객체에서 객체를 재구성하기위한 일련의 명령어입니다. 기본 개체가 deltified이면 먼저 정식 형식으로 변환해야합니다. 각 명령어는 완료 될 때까지 대상 객체에 더 많은 데이터를 추가합니다. 지금까지 두 가지 지원되는 명령어가 있습니다. 하나는 소스 객체에서 바이트 범위를 복사하기위한 것이고 다른 하나는 명령어 자체에 포함 된 새 데이터를 삽입하기위한 것입니다.</target>
        </trans-unit>
        <trans-unit id="892bc72de2972bd5305c51b8962327a3cfb2518f" translate="yes" xml:space="preserve">
          <source>The depth parameter used in the delta compression algorithm used by &lt;code&gt;git gc --aggressive&lt;/code&gt;. This defaults to 50, which is the default for the &lt;code&gt;--depth&lt;/code&gt; option when &lt;code&gt;--aggressive&lt;/code&gt; isn&amp;rsquo;t in use.</source>
          <target state="translated">&lt;code&gt;git gc --aggressive&lt;/code&gt; 가 사용하는 델타 압축 알고리즘에 사용되는 깊이 매개 변수 입니다. 기본값은 50으로, &lt;code&gt;--aggressive&lt;/code&gt; 를 사용하지 않는 경우 &lt;code&gt;--depth&lt;/code&gt; 옵션 의 기본값입니다 .</target>
        </trans-unit>
        <trans-unit id="71588492154c20723b86643e523c1d2b33771cc9" translate="yes" xml:space="preserve">
          <source>The design of fast-import allows it to import large projects in a minimum amount of memory usage and processing time. Assuming the frontend is able to keep up with fast-import and feed it a constant stream of data, import times for projects holding 10+ years of history and containing 100,000+ individual commits are generally completed in just 1-2 hours on quite modest (~$2,000 USD) hardware.</source>
          <target state="translated">빠른 가져 오기의 설계를 통해 최소한의 메모리 사용 및 처리 시간으로 대규모 프로젝트를 가져올 수 있습니다. 프론트 엔드가 빠른 가져 오기를 유지하고 일정한 데이터 스트림을 제공 할 수 있다고 가정하면 10 년 이상의 역사를 보유하고 100,000 개 이상의 개별 커밋을 포함하는 프로젝트의 가져 오기 시간은 일반적으로 아주 완만 한 1-2 시간 안에 완료됩니다 ( ~ $ 2,000 USD) 하드웨어.</target>
        </trans-unit>
        <trans-unit id="c420d947d2d5939e423cde725977f1dbb1cf946b" translate="yes" xml:space="preserve">
          <source>The developer might want to rebase those commits to a newer &lt;code&gt;master&lt;/code&gt; while keeping the branch topology, for example when the first topic branch is expected to be integrated into &lt;code&gt;master&lt;/code&gt; much earlier than the second one, say, to resolve merge conflicts with changes to the DownloadButton class that made it into &lt;code&gt;master&lt;/code&gt;.</source>
          <target state="translated">예를 들어 첫 번째 토픽 브랜치가 두 번째 토픽 브랜치 보다 훨씬 일찍 &lt;code&gt;master&lt;/code&gt; 통합 될 것으로 예상되는 경우 (예 : DownloadButton의 변경 사항과의 병합 충돌을 해결 하려는 경우) 개발자 는 브랜치 토폴로지를 유지하면서 이러한 커밋을 최신 &lt;code&gt;master&lt;/code&gt; 로 리베이스 할 수 있습니다. 그것을 &lt;code&gt;master&lt;/code&gt; 로 만든 클래스 .</target>
        </trans-unit>
        <trans-unit id="38adb1a4eb1052b4c27e8f4f4a52ae35ba0619ad" translate="yes" xml:space="preserve">
          <source>The diff above shows the differences between the working-tree version of file.txt and the stage 2 and stage 3 versions. So instead of preceding each line by a single &lt;code&gt;+&lt;/code&gt; or &lt;code&gt;-&lt;/code&gt;, it now uses two columns: the first column is used for differences between the first parent and the working directory copy, and the second for differences between the second parent and the working directory copy. (See the &quot;COMBINED DIFF FORMAT&quot; section of &lt;a href=&quot;git-diff-files&quot;&gt;git-diff-files[1]&lt;/a&gt; for a details of the format.)</source>
          <target state="translated">위의 diff는 file.txt의 작업 트리 버전과 2 단계 및 3 단계 버전의 차이점을 보여줍니다. 따라서 각 행 앞에 단일 &lt;code&gt;+&lt;/code&gt; 또는 &lt;code&gt;-&lt;/code&gt; 를 사용 하는 대신 이제 두 개의 열을 사용합니다. 첫 번째 열은 첫 번째 상위와 작업 디렉토리 사본의 차이점에 사용되고 두 번째 열은 두 번째 상위와 작업 디렉토리 사본의 차이점에 사용됩니다. . 형식 에 대한 자세한 내용은 &lt;a href=&quot;git-diff-files&quot;&gt;git-diff-files [1]&lt;/a&gt; 의 &quot;COMBINED DIFF FORMAT&quot;섹션을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="330f16adb7b4cb162abae538c3471400c6f3dfa4" translate="yes" xml:space="preserve">
          <source>The diff commands &lt;code&gt;git diff-index&lt;/code&gt;, &lt;code&gt;git diff-files&lt;/code&gt;, and &lt;code&gt;git diff-tree&lt;/code&gt; can be told to manipulate differences they find in unconventional ways before showing &lt;code&gt;diff&lt;/code&gt; output. The manipulation is collectively called &quot;diffcore transformation&quot;. This short note describes what they are and how to use them to produce &lt;code&gt;diff&lt;/code&gt; output that is easier to understand than the conventional kind.</source>
          <target state="translated">diff 명령 &lt;code&gt;git diff-index&lt;/code&gt; , &lt;code&gt;git diff-files&lt;/code&gt; 및 &lt;code&gt;git diff-tree&lt;/code&gt; 는 &lt;code&gt;diff&lt;/code&gt; 출력을 표시하기 전에 기존 방식으로 발견 된 차이를 조작하도록 지시 할 수 있습니다 . 조작을 통칭하여 &quot;diffcore transformation&quot;이라고합니다. 이 짧은 노트 는 기존의 것보다 이해하기 쉬운 &lt;code&gt;diff&lt;/code&gt; 출력 을 생성하기 위해 그것들이 무엇인지 그리고 그것들을 사용하는 방법을 설명합니다 .</target>
        </trans-unit>
        <trans-unit id="4e50a3e21215031cd44c450ab91735643c2d6198" translate="yes" xml:space="preserve">
          <source>The diffcore mechanism is fed a list of such comparison results (each of which is called &quot;filepair&quot;, although at this point each of them talks about a single file), and transforms such a list into another list. There are currently 5 such transformations:</source>
          <target state="translated">diffcore 메커니즘에는 이러한 비교 결과 목록이 제공되며 (각각 &quot;단일 파일에 대해 말하지만&quot;파일 쌍 &quot;이라고 함) 이러한 목록을 다른 목록으로 변환합니다. 현재 5 가지의 그러한 변환이 있습니다 :</target>
        </trans-unit>
        <trans-unit id="5ccc68add0025f283e287a514f59373a91910067" translate="yes" xml:space="preserve">
          <source>The directory holding the sha1 objects is missing.</source>
          <target state="translated">sha1 오브젝트를 보유한 디렉토리가 누락되었습니다.</target>
        </trans-unit>
        <trans-unit id="3e56ce3070b6d1fe8bc11b5262f83540c8411c39" translate="yes" xml:space="preserve">
          <source>The directory to find the quilt patches.</source>
          <target state="translated">퀼트 패치를 찾을 디렉토리입니다.</target>
        </trans-unit>
        <trans-unit id="0bb0f16c4fefb50922eb2b1990a8580cecff19f2" translate="yes" xml:space="preserve">
          <source>The easiest way to do this is with:</source>
          <target state="translated">가장 쉬운 방법은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="114ebd710b84299f5cb327f93e8be01e979eae23" translate="yes" xml:space="preserve">
          <source>The easy case</source>
          <target state="translated">쉬운 경우</target>
        </trans-unit>
        <trans-unit id="ae6685a0ed898fdf61a802d261028cc9079a0958" translate="yes" xml:space="preserve">
          <source>The editor used to edit the commit log message will be chosen from the &lt;code&gt;GIT_EDITOR&lt;/code&gt; environment variable, the core.editor configuration variable, the &lt;code&gt;VISUAL&lt;/code&gt; environment variable, or the &lt;code&gt;EDITOR&lt;/code&gt; environment variable (in that order). See &lt;a href=&quot;git-var&quot;&gt;git-var[1]&lt;/a&gt; for details.</source>
          <target state="translated">커밋 로그 메시지를 편집하는 데 사용되는 편집기는 &lt;code&gt;GIT_EDITOR&lt;/code&gt; 환경 변수, core.editor 구성 변수, &lt;code&gt;VISUAL&lt;/code&gt; 환경 변수 또는 &lt;code&gt;EDITOR&lt;/code&gt; 환경 변수 (순서대로)에서 선택됩니다. 자세한 내용은 &lt;a href=&quot;git-var&quot;&gt;git-var [1]&lt;/a&gt; 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="0e4dbd523803a96213d55b1fc234d8888f00a89f" translate="yes" xml:space="preserve">
          <source>The effect of the &lt;code&gt;git add&lt;/code&gt; was to add one entry to the index file:</source>
          <target state="translated">&lt;code&gt;git add&lt;/code&gt; 의 효과 는 인덱스 파일에 하나의 항목을 추가하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="8c668b981ec948c02063906a293d8a4332dec951" translate="yes" xml:space="preserve">
          <source>The effect of this is best shown by way of comparing to &lt;code&gt;--full-history&lt;/code&gt; with parent rewriting. The example turns into:</source>
          <target state="translated">이것의 효과는 부모 재 작성과 &lt;code&gt;--full-history&lt;/code&gt; 와 비교하여 가장 잘 나타납니다 . 예제는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="f01b79da1b24a8459870505ceabc7acd5dc253cb" translate="yes" xml:space="preserve">
          <source>The effective value of &quot;core.notesRef&quot; (possibly overridden by GIT_NOTES_REF) is also implicitly added to the list of refs to be displayed.</source>
          <target state="translated">&quot;core.notesRef&quot;의 유효 값 (GIT_NOTES_REF로 재정의 됨)도 표시 될 참조 목록에 내재적으로 추가됩니다.</target>
        </trans-unit>
        <trans-unit id="47170c140110158e7cecc3842f11a773c4cf2ae7" translate="yes" xml:space="preserve">
          <source>The effects of this are mostly persistent, e.g. when packs and loose objects are coalesced into one another pack the existing deltas in that pack might get re-used, but there are also various cases where we might pick a sub-optimal delta from a newer pack instead.</source>
          <target state="translated">팩과 느슨한 객체가 서로 다른 팩으로 통합 될 때, 그 팩의 기존 델타가 재사용 될 수 있지만, 새로운 팩터에서 차선의 델타를 선택할 수있는 경우도 있습니다. 대신 팩.</target>
        </trans-unit>
        <trans-unit id="e05ce4cdee1f111bdf6e1a5c14e6220d9920c4e2" translate="yes" xml:space="preserve">
          <source>The equivalence test is based on the diff, after removing whitespace and line numbers. git-cherry therefore detects when commits have been &quot;copied&quot; by means of &lt;a href=&quot;git-cherry-pick&quot;&gt;git-cherry-pick[1]&lt;/a&gt;, &lt;a href=&quot;git-am&quot;&gt;git-am[1]&lt;/a&gt; or &lt;a href=&quot;git-rebase&quot;&gt;git-rebase[1]&lt;/a&gt;.</source>
          <target state="translated">동등성 테스트는 공백과 줄 번호를 제거한 후 diff를 기준으로합니다. git-cherry는 커밋이 &lt;a href=&quot;git-cherry-pick&quot;&gt;git-cherry-pick [1]&lt;/a&gt; , &lt;a href=&quot;git-am&quot;&gt;git-am [1]&lt;/a&gt; 또는 &lt;a href=&quot;git-rebase&quot;&gt;git-rebase [1]에&lt;/a&gt; 의해 &quot;복사&quot;된시기를 감지 합니다.</target>
        </trans-unit>
        <trans-unit id="1c5c570f3616a5224dd6e91327ceb211453e9ddc" translate="yes" xml:space="preserve">
          <source>The error event may be emitted more than once. The format string allows post-processors to group errors by type without worrying about specific error arguments.</source>
          <target state="translated">오류 이벤트가 두 번 이상 발생할 수 있습니다. 형식 문자열을 사용하면 포스트 프로세서가 특정 오류 인수에 대한 걱정없이 유형별로 오류를 그룹화 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2c5c3dbbaebe5825bdfa9c22deed2d10f337e86e" translate="yes" xml:space="preserve">
          <source>The event format target is a JSON-based format of event data suitable for telemetry analysis. This format is enabled with the &lt;code&gt;GIT_TRACE2_EVENT&lt;/code&gt; environment variable or the &lt;code&gt;trace2.eventTarget&lt;/code&gt; system or global config setting.</source>
          <target state="translated">이벤트 형식 대상은 원격 분석에 적합한 JSON 기반의 이벤트 데이터 형식입니다. 이 형식은 &lt;code&gt;GIT_TRACE2_EVENT&lt;/code&gt; 환경 변수 또는 &lt;code&gt;trace2.eventTarget&lt;/code&gt; 시스템 또는 글로벌 구성 설정으로 사용 가능합니다.</target>
        </trans-unit>
        <trans-unit id="bb53cc945a6f48ddfeb31dcd9983e9640d488cf9" translate="yes" xml:space="preserve">
          <source>The ever-versatile &lt;a href=&quot;git-show&quot;&gt;git-show[1]&lt;/a&gt; command can also be used to examine tree objects, but &lt;a href=&quot;git-ls-tree&quot;&gt;git-ls-tree[1]&lt;/a&gt; will give you more details:</source>
          <target state="translated">다양한 기능을 갖춘 &lt;a href=&quot;git-show&quot;&gt;git-show [1]&lt;/a&gt; 명령을 사용하여 트리 객체를 검사 할 수도 있지만 &lt;a href=&quot;git-ls-tree&quot;&gt;git-ls-tree [1]&lt;/a&gt; 은 다음과 같은 세부 정보를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="2cae5c144ae6a6f552f7dcee7bbaf0209258a3bd" translate="yes" xml:space="preserve">
          <source>The example configuration presented here is guaranteed to be backwards and forward compatible.</source>
          <target state="translated">여기에 제시된 예제 구성은 이전 버전과 이전 버전과 호환됩니다.</target>
        </trans-unit>
        <trans-unit id="77578078110fe9093d1036dd58aeebc2db7df1b8" translate="yes" xml:space="preserve">
          <source>The exit code from this hook invocation is ignored, however a non-zero exit code will generate an error message.</source>
          <target state="translated">이 후크 호출의 종료 코드는 무시되지만 0이 아닌 종료 코드는 오류 메시지를 생성합니다.</target>
        </trans-unit>
        <trans-unit id="1e405cb397afa437170eea29059b03dcf97426f6" translate="yes" xml:space="preserve">
          <source>The exit code from this hook invocation is ignored; the only thing left for &lt;code&gt;git-receive-pack&lt;/code&gt; to do at that point is to exit itself anyway.</source>
          <target state="translated">이 후크 호출의 종료 코드는 무시됩니다. &lt;code&gt;git-receive-pack&lt;/code&gt; 이 그 시점에서해야 할 유일한 일은 어쨌든 자체를 종료하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="5a81c04e486b5c66b0be7554a6e91773cfd1a9a9" translate="yes" xml:space="preserve">
          <source>The exit status determines whether git will use the data from the hook to limit its search. On error, it will fall back to verifying all files and folders.</source>
          <target state="translated">종료 상태는 git이 후크의 데이터를 사용하여 검색을 제한할지 여부를 결정합니다. 오류가 발생하면 모든 파일 및 폴더 확인으로 돌아갑니다.</target>
        </trans-unit>
        <trans-unit id="863cf74b97781c15eaa4bf39c81be105821817bd" translate="yes" xml:space="preserve">
          <source>The exit value of this program is negative on error, and the number of conflicts otherwise (truncated to 127 if there are more than that many conflicts). If the merge was clean, the exit value is 0.</source>
          <target state="translated">오류가 발생하면이 프로그램의 종료 값이 음수이고, 그렇지 않으면 충돌 수가 발생합니다 (충돌이 많은 경우 127로 잘림). 병합이 깨끗하면 종료 값은 0입니다.</target>
        </trans-unit>
        <trans-unit id="600e0ed5040d09634bf101b6adc431e3349d2258" translate="yes" xml:space="preserve">
          <source>The expected use case of this is to write supporting explanation for the commit that does not belong to the commit log message proper, and include it with the patch submission. While one can simply write these explanations after &lt;code&gt;format-patch&lt;/code&gt; has run but before sending, keeping them as Git notes allows them to be maintained between versions of the patch series (but see the discussion of the &lt;code&gt;notes.rewrite&lt;/code&gt; configuration options in &lt;a href=&quot;git-notes&quot;&gt;git-notes[1]&lt;/a&gt; to use this workflow).</source>
          <target state="translated">예상되는 사용 사례는 커밋 로그 메시지에 속하지 않은 커밋에 대한 지원 설명을 작성하고 패치 제출에 포함시키는 것입니다. &lt;code&gt;format-patch&lt;/code&gt; 가 실행 된 후 , 보내기 전에 이러한 설명을 간단히 작성할 수 있지만, Git 노트로 패치 시리즈 버전간에 유지 보수 할 수 있도록 메모를 유지하십시오 (하지만 &lt;a href=&quot;git-notes&quot;&gt;git-notes&lt;/a&gt; 의 &lt;code&gt;notes.rewrite&lt;/code&gt; 구성 옵션에 대한 설명 참조 ) 1] 이 워크 플로를 사용합니다).</target>
        </trans-unit>
        <trans-unit id="7c7921a0c6ea4cec42a427f589011997d35e15f9" translate="yes" xml:space="preserve">
          <source>The external command can optionally write a single line to its standard output to be sent to the requestor as an error message when it declines the service.</source>
          <target state="translated">외부 명령은 선택적으로 서비스를 거부 할 때 요청자에게 오류 메시지로 전송되도록 단일 출력을 표준 출력에 쓸 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="34c4f9db557882c9df4177a31e00a543de8934c9" translate="yes" xml:space="preserve">
          <source>The extra &lt;code&gt;NUL&lt;/code&gt; before the preimage path in renamed case is to allow scripts that read the output to tell if the current record being read is a single-path record or a rename/copy record without reading ahead. After reading added and deleted lines, reading up to &lt;code&gt;NUL&lt;/code&gt; would yield the pathname, but if that is &lt;code&gt;NUL&lt;/code&gt;, the record will show two paths.</source>
          <target state="translated">이름이 바뀐 경우 사전 이미지 경로 앞 의 추가 &lt;code&gt;NUL&lt;/code&gt; 은 출력을 읽는 스크립트가 현재 읽고있는 레코드가 단일 경로 레코드인지 또는 미리 읽지 않고 이름 바꾸기 / 복사 레코드인지를 알리는 것입니다. 추가 및 삭제 된 행을 읽은 후 &lt;code&gt;NUL&lt;/code&gt; 까지 읽으면 경로 이름이 생성되지만 &lt;code&gt;NUL&lt;/code&gt; 인 경우 레코드에 두 개의 경로가 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="1b54438722ed3844a0702f9ed09c56d6aef28ee2" translate="yes" xml:space="preserve">
          <source>The fast-import backend itself can import into an empty repository (one that has already been initialized by &lt;code&gt;git init&lt;/code&gt;) or incrementally update an existing populated repository. Whether or not incremental imports are supported from a particular foreign source depends on the frontend program in use.</source>
          <target state="translated">빠른 가져 오기 백엔드 자체는 비어있는 저장소 ( &lt;code&gt;git init&lt;/code&gt; 로 이미 초기화 된 저장소 )로 가져 오거나 기존의 채워진 저장소를 증분 업데이트 할 수 있습니다. 특정 외부 소스에서 증분 가져 오기를 지원하는지 여부는 사용중인 프론트 엔드 프로그램에 따라 다릅니다.</target>
        </trans-unit>
        <trans-unit id="3dfacf796b68e98a60c628fed43445479dc82ce1" translate="yes" xml:space="preserve">
          <source>The fast-import mechanism used by &lt;code&gt;git p4&lt;/code&gt; creates one pack file for each invocation of &lt;code&gt;git p4 sync&lt;/code&gt;. Normally, Git garbage compression (&lt;a href=&quot;git-gc&quot;&gt;git-gc[1]&lt;/a&gt;) automatically compresses these to fewer pack files, but explicit invocation of &lt;code&gt;git repack -adf&lt;/code&gt; may improve performance.</source>
          <target state="translated">&lt;code&gt;git p4&lt;/code&gt; 에서 사용하는 빠른 가져 오기 메커니즘 은 &lt;code&gt;git p4 sync&lt;/code&gt; 호출마다 하나의 팩 파일을 작성 합니다 . 일반적으로 Git 가비지 압축 ( &lt;a href=&quot;git-gc&quot;&gt;git-gc [1]&lt;/a&gt; ) &lt;code&gt;git repack -adf&lt;/code&gt; 파일을 더 적은 팩 파일로 자동 압축하지만 git repack -adf를 명시 적으로 호출 하면 성능이 향상 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="53e903dc94674f5b365dd31d16a6c2e334c714e3" translate="yes" xml:space="preserve">
          <source>The fetch and push protocols are not designed to prevent one side from stealing data from the other repository that was not intended to be shared. If you have private data that you need to protect from a malicious peer, your best option is to store it in another repository. This applies to both clients and servers. In particular, namespaces on a server are not effective for read access control; you should only grant read access to a namespace to clients that you would trust with read access to the entire repository.</source>
          <target state="translated">페치 및 푸시 프로토콜은 한 쪽이 공유하지 않을 다른 리포지토리의 데이터를 훔치지 않도록 설계되지 않았습니다. 악의적 인 피어로부터 보호해야하는 개인 데이터가있는 경우 가장 좋은 방법은 다른 리포지토리에 저장하는 것입니다. 이것은 클라이언트와 서버 모두에 적용됩니다. 특히 서버의 네임 스페이스는 읽기 액세스 제어에 효과적이지 않습니다. 전체 저장소에 대한 읽기 권한으로 신뢰할 수있는 클라이언트에게 네임 스페이스에 대한 읽기 권한 만 부여해야합니다.</target>
        </trans-unit>
        <trans-unit id="648bf821f46e9909499e1fbac0dd96a1ab871eb7" translate="yes" xml:space="preserve">
          <source>The fields (including the &lt;code&gt;-&amp;gt;&lt;/code&gt;) are separated from each other by a single space. If a filename contains whitespace or other nonprintable characters, that field will be quoted in the manner of a C string literal: surrounded by ASCII double quote (34) characters, and with interior special characters backslash-escaped.</source>
          <target state="translated">필드 ( &lt;code&gt;-&amp;gt;&lt;/code&gt; 포함 )는 단일 공백으로 구분됩니다. 파일 이름에 공백이나 인쇄 할 수없는 다른 문자가 포함 된 경우 해당 필드는 C 문자열 리터럴 방식으로 인용됩니다 : ASCII 큰 따옴표 (34) 문자로 묶고 내부 특수 문자는 백 슬래시 이스케이프 처리됩니다.</target>
        </trans-unit>
        <trans-unit id="3994e582754827987cb1dab035b29a73b90c4b3e" translate="yes" xml:space="preserve">
          <source>The file consists of sections and variables. A section begins with the name of the section in square brackets and continues until the next section begins. Section names are case-insensitive. Only alphanumeric characters, &lt;code&gt;-&lt;/code&gt; and &lt;code&gt;.&lt;/code&gt; are allowed in section names. Each variable must belong to some section, which means that there must be a section header before the first setting of a variable.</source>
          <target state="translated">파일은 섹션과 변수로 구성됩니다. 섹션은 대괄호 안에 섹션 이름으로 시작하고 다음 섹션이 시작될 때까지 계속됩니다. 섹션 이름은 대소 문자를 구분하지 않습니다. 영숫자 만 &lt;code&gt;-&lt;/code&gt; 및 &lt;code&gt;.&lt;/code&gt; 섹션 이름에 허용됩니다. 각 변수는 일부 섹션에 속해야합니다. 즉, 변수의 첫 번째 설정 전에 섹션 헤더가 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="b77694751b662ffffe51a33dc2cd7f9b8be897f4" translate="yes" xml:space="preserve">
          <source>The file contains one subsection per submodule, and the subsection value is the name of the submodule. The name is set to the path where the submodule has been added unless it was customized with the &lt;code&gt;--name&lt;/code&gt; option of &lt;code&gt;git submodule add&lt;/code&gt;. Each submodule section also contains the following required keys:</source>
          <target state="translated">파일은 서브 모듈 당 하나의 서브 섹션을 포함하며 서브 섹션 값은 서브 모듈의 이름입니다. &lt;code&gt;git submodule add&lt;/code&gt; 의 &lt;code&gt;--name&lt;/code&gt; 옵션 으로 사용자 정의되지 않은 경우 이름은 서브 모듈이 추가 된 경로로 설정됩니다 . 각 하위 모듈 섹션에는 다음과 같은 필수 키가 있습니다.</target>
        </trans-unit>
        <trans-unit id="d7d8ebbce919f993c68a8bac80b9fbb16d92024e" translate="yes" xml:space="preserve">
          <source>The file format includes parameters for the object ID hash function, so a future change of hash algorithm does not require a change in format.</source>
          <target state="translated">파일 형식에는 오브젝트 ID 해시 함수에 대한 매개 변수가 포함되므로 향후 해시 알고리즘 변경시 형식 변경이 필요하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="1bb6e340dc566db02505e0c4003761a9d85c40c1" translate="yes" xml:space="preserve">
          <source>The file is concluded with a trailer:</source>
          <target state="translated">파일은 예고편으로 마무리됩니다.</target>
        </trans-unit>
        <trans-unit id="996f5fbcdb16f7d7ee85c3a6ae77d46a1781884a" translate="yes" xml:space="preserve">
          <source>The file parameters can point at the user&amp;rsquo;s working file (e.g. &lt;code&gt;new-file&lt;/code&gt; in &quot;git-diff-files&quot;), &lt;code&gt;/dev/null&lt;/code&gt; (e.g. &lt;code&gt;old-file&lt;/code&gt; when a new file is added), or a temporary file (e.g. &lt;code&gt;old-file&lt;/code&gt; in the index). &lt;code&gt;GIT_EXTERNAL_DIFF&lt;/code&gt; should not worry about unlinking the temporary file --- it is removed when &lt;code&gt;GIT_EXTERNAL_DIFF&lt;/code&gt; exits.</source>
          <target state="translated">파일 매개 변수는 사용자의 작업 파일에서 (예를 가리킬 수 있습니다 &lt;code&gt;new-file&lt;/code&gt; &quot;자식-DIFF-파일&quot;의을) &lt;code&gt;/dev/null&lt;/code&gt; (예를 들어 &lt;code&gt;old-file&lt;/code&gt; 새로운 파일이 추가된다), 또는 임시 파일을 (예를 들어 &lt;code&gt;old-file&lt;/code&gt; 색인에 파일 ). &lt;code&gt;GIT_EXTERNAL_DIFF&lt;/code&gt; 는 임시 파일의 연결을 해제하지 않아도 됩니다. --- &lt;code&gt;GIT_EXTERNAL_DIFF&lt;/code&gt; 가 종료 될 때 제거 됩니다.</target>
        </trans-unit>
        <trans-unit id="b979e5d416845ad4db7c29ab613bf67d05d7d448" translate="yes" xml:space="preserve">
          <source>The files are read in the order given above, with last value found taking precedence over values read earlier. When multiple values are taken then all values of a key from all files will be used.</source>
          <target state="translated">파일은 위에 주어진 순서대로 읽히고 마지막 값은 이전에 읽은 값보다 우선합니다. 여러 값을 가져 오면 모든 파일의 모든 키 값이 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="22cd650e22be9431ebec70f16e27f0954b25a243" translate="yes" xml:space="preserve">
          <source>The files to read the patch from. &lt;code&gt;-&lt;/code&gt; can be used to read from the standard input.</source>
          <target state="translated">패치를 읽을 파일입니다. &lt;code&gt;-&lt;/code&gt; 표준 입력에서 읽는 데 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="fc839d554b73db3187cb52551b31c221d5647965" translate="yes" xml:space="preserve">
          <source>The filter is expected to respond with a list of &quot;key=value&quot; pairs terminated with a flush packet. If the filter does not experience problems then the list must contain a &quot;success&quot; status. Right after these packets the filter is expected to send the content in zero or more pkt-line packets and a flush packet at the end. Finally, a second list of &quot;key=value&quot; pairs terminated with a flush packet is expected. The filter can change the status in the second list or keep the status as is with an empty list. Please note that the empty list must be terminated with a flush packet regardless.</source>
          <target state="translated">필터는 플러시 패킷으로 종료 된 &quot;key = value&quot;쌍 목록으로 응답합니다. 필터에 문제가 없으면 목록에 &quot;성공&quot;상태가 포함되어야합니다. 이러한 패킷 바로 뒤에 필터는 0 개 이상의 pkt-line 패킷으로 콘텐츠를 전송하고 마지막에는 플러시 패킷을 전송합니다. 마지막으로 플러시 패킷으로 종료 된 &quot;key = value&quot;쌍의 두 번째 목록이 예상됩니다. 필터는 두 번째 목록의 상태를 변경하거나 빈 목록으로 상태를 유지할 수 있습니다. 빈 목록은 플러시 패킷으로 종료해야합니다.</target>
        </trans-unit>
        <trans-unit id="48c7b9e769ad1a8ac7a03d8a91befba4e1dc75d4" translate="yes" xml:space="preserve">
          <source>The filter that will be applied when fetching from this promisor remote.</source>
          <target state="translated">이 Promisor Remote에서 가져올 때 적용되는 필터입니다.</target>
        </trans-unit>
        <trans-unit id="67e1cbcd0bc26ca591869ec55e18981d4a05f31d" translate="yes" xml:space="preserve">
          <source>The filters are applied in the order as listed below. The &amp;lt;command&amp;gt; argument is always evaluated in the shell context using the &lt;code&gt;eval&lt;/code&gt; command (with the notable exception of the commit filter, for technical reasons). Prior to that, the &lt;code&gt;$GIT_COMMIT&lt;/code&gt; environment variable will be set to contain the id of the commit being rewritten. Also, GIT_AUTHOR_NAME, GIT_AUTHOR_EMAIL, GIT_AUTHOR_DATE, GIT_COMMITTER_NAME, GIT_COMMITTER_EMAIL, and GIT_COMMITTER_DATE are taken from the current commit and exported to the environment, in order to affect the author and committer identities of the replacement commit created by &lt;a href=&quot;git-commit-tree&quot;&gt;git-commit-tree[1]&lt;/a&gt; after the filters have run.</source>
          <target state="translated">필터는 아래 나열된 순서대로 적용됩니다. &amp;lt;command&amp;gt; 인수는 &lt;code&gt;eval&lt;/code&gt; 명령을 사용하여 셸 컨텍스트에서 항상 평가됩니다 (기술적 인 이유로 커밋 필터는 예외). 그 전에 &lt;code&gt;$GIT_COMMIT&lt;/code&gt; 환경 변수는 다시 작성되는 커밋의 ID를 포함하도록 설정됩니다. 또한 GIT_AUTHOR_NAME, GIT_AUTHOR_EMAIL, GIT_AUTHOR_DATE, GIT_COMMITTER_NAME, GIT_COMMITTER_EMAIL 및 GIT_COMMITTER_DATE는 현재 커밋에서 가져 와서 환경으로 내 보내져 &lt;a href=&quot;git-commit-tree&quot;&gt;git-commit-tree&lt;/a&gt; 후 생성 된 교체 커밋의 작성자 및 커미터 신원에 영향을 미칩니다. 필터가 작동했습니다.</target>
        </trans-unit>
        <trans-unit id="96e6a8e11c595c66ed126e7ed94498b41b8ef74c" translate="yes" xml:space="preserve">
          <source>The final &quot;/&quot; is important. The exported name is literally just prefixed with the specified string. Contrast this with the following example.</source>
          <target state="translated">마지막 &quot;/&quot;가 중요합니다. 내 보낸 이름은 문자 그대로 지정된 문자열로 시작합니다. 이것을 다음 예제와 대조하십시오.</target>
        </trans-unit>
        <trans-unit id="5e71083855686454b686d549c1aa754044d9c24f" translate="yes" xml:space="preserve">
          <source>The final result will be a series of commits, one for each patch in the original mailbox, with authorship and commit log message each taken from the message containing each patch.</source>
          <target state="translated">최종 결과는 원래 메일 함의 각 패치마다 하나씩 일련의 커밋이되며 각 패치가 포함 된 메시지에서 각각 작성된 소유권 및 커밋 로그 메시지가 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="d06dc79919ba8d7d4e32bae22586b9e61ea6ab90" translate="yes" xml:space="preserve">
          <source>The first &quot;git bisect&quot; subcommand to use is &quot;git bisect start&quot; to start the search. Then bounds must be set to limit the commit space. This is done usually by giving one &quot;bad&quot; and at least one &quot;good&quot; commit. They can be passed in the initial call to &quot;git bisect start&quot; like this:</source>
          <target state="translated">사용할 첫 번째 &quot;git bisect&quot;하위 명령은 검색을 시작하는 &quot;git bisect start&quot;입니다. 그런 다음 확약 공간을 제한하도록 경계를 설정해야합니다. 이것은 일반적으로 하나의 &quot;나쁜&quot;및 하나 이상의 &quot;좋은&quot;커밋을 제공하여 수행됩니다. 다음과 같이 &quot;git bisect start&quot;에 대한 초기 호출에서 전달 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3dd96cc8c67fe6f3794e1faadfc16d4e75778490" translate="yes" xml:space="preserve">
          <source>The first argument, &lt;code&gt;origin&lt;/code&gt;, just tells Git to fetch from the repository you originally cloned from. The second argument tells Git to fetch the branch named &lt;code&gt;todo&lt;/code&gt; from the remote repository, and to store it locally under the name &lt;code&gt;refs/heads/my-todo-work&lt;/code&gt;.</source>
          <target state="translated">첫 번째 인자 인 &lt;code&gt;origin&lt;/code&gt; 은 Git에게 원래 복제 한 저장소에서 가져 오도록 지시합니다. 두 번째 인수는 Git에게 원격 저장소에서 &lt;code&gt;todo&lt;/code&gt; 라는 브랜치를 가져오고 &lt;code&gt;refs/heads/my-todo-work&lt;/code&gt; 라는 이름으로 로컬로 저장하도록 지시합니다 .</target>
        </trans-unit>
        <trans-unit id="81bbac8df429c9294b949507806676c0327c9227" translate="yes" xml:space="preserve">
          <source>The first character given by this option will be the default character used when another separator is not specified in the config for this trailer.</source>
          <target state="translated">이 옵션이 제공하는 첫 번째 문자는이 트레일러 구성에서 다른 구분 기호를 지정하지 않은 경우 사용되는 기본 문자입니다.</target>
        </trans-unit>
        <trans-unit id="39b9ae2f52daae0742c9cd959c54a342268035c6" translate="yes" xml:space="preserve">
          <source>The first command fetches the &lt;code&gt;maint&lt;/code&gt; branch from the repository at &lt;code&gt;git://git.kernel.org/pub/scm/git/git.git&lt;/code&gt; and the second command uses &lt;code&gt;FETCH_HEAD&lt;/code&gt; to examine the branch with &lt;a href=&quot;git-log&quot;&gt;git-log[1]&lt;/a&gt;. The fetched objects will eventually be removed by git&amp;rsquo;s built-in housekeeping (see &lt;a href=&quot;git-gc&quot;&gt;git-gc[1]&lt;/a&gt;).</source>
          <target state="translated">첫 번째 명령 은 &lt;code&gt;git://git.kernel.org/pub/scm/git/git.git&lt;/code&gt; 의 저장소에서 &lt;code&gt;maint&lt;/code&gt; 브랜치를 가져오고 두 번째 명령은 &lt;code&gt;FETCH_HEAD&lt;/code&gt; 를 사용 하여 &lt;a href=&quot;git-log&quot;&gt;git-log [1]으로&lt;/a&gt; 브랜치를 검사합니다 . 가져온 객체는 git의 내장 하우스 키핑에 의해 제거됩니다 ( &lt;a href=&quot;git-gc&quot;&gt;git-gc [1] 참조&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="fc54aa6f7f46c36afb224191ab9ce02506aa2fd9" translate="yes" xml:space="preserve">
          <source>The first defense against such problems is backups. You can back up a Git directory using clone, or just using cp, tar, or any other backup mechanism.</source>
          <target state="translated">이러한 문제에 대한 첫 번째 방어책은 백업입니다. clone을 사용하거나 cp, tar 또는 기타 백업 메커니즘을 사용하여 Git 디렉토리를 백업 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="eb17679ed2c14d3eecb0f1bd83c98beea1f4bea4" translate="yes" xml:space="preserve">
          <source>The first format is what gets used when &lt;code&gt;--stage&lt;/code&gt; is omitted or is not &lt;code&gt;--stage=all&lt;/code&gt;. The field tempname is the temporary file name holding the file content and path is the tracked path name in the index. Only the requested entries are output.</source>
          <target state="translated">첫 번째 형식은 &lt;code&gt;--stage&lt;/code&gt; 가 생략되거나 &lt;code&gt;--stage=all&lt;/code&gt; 이 아닐 때 사용되는 형식입니다 . tempname 필드는 파일 내용이 들어있는 임시 파일 이름이고 path는 색인에서 추적 된 경로 이름입니다. 요청 된 항목 만 출력됩니다.</target>
        </trans-unit>
        <trans-unit id="e7e26fcb00a95d796be86027e9776fd349443123" translate="yes" xml:space="preserve">
          <source>The first is simple and appropriate if you do not have secure storage available for a password. It is generally configured by adding this to your config:</source>
          <target state="translated">첫 번째는 암호에 사용 가능한 보안 저장소가없는 경우 간단하고 적절합니다. 일반적으로 이것을 구성에 추가하여 구성됩니다.</target>
        </trans-unit>
        <trans-unit id="561e4f0c34cc864db97b2078e570c6b7cf2ee83d" translate="yes" xml:space="preserve">
          <source>The first line of the input feeds 0 as the mode to remove the path; the SHA-1 does not matter as long as it is well formatted. Then the second and third line feeds stage 1 and stage 2 entries for that path. After the above, we would end up with this:</source>
          <target state="translated">입력의 첫 번째 줄은 경로를 제거하는 모드로 0을 공급합니다. SHA-1은 형식이 올바른 한 중요하지 않습니다. 그런 다음 두 번째 및 세 번째 행은 해당 경로의 1 단계 및 2 단계 항목을 공급합니다. 위의 후, 우리는 이것으로 끝날 것입니다 :</target>
        </trans-unit>
        <trans-unit id="d7a467221d570ce5d2e2454d168c252049fa7e64" translate="yes" xml:space="preserve">
          <source>The first number is the number of objects which are kept in individual files. The second is the amount of space taken up by those &quot;loose&quot; objects.</source>
          <target state="translated">첫 번째 숫자는 개별 파일에 보관 된 개체 수입니다. 두 번째는 &quot;느슨한&quot;개체가 차지하는 공간입니다.</target>
        </trans-unit>
        <trans-unit id="1517f019c895db91a3158888218e464c0e667ed4" translate="yes" xml:space="preserve">
          <source>The first parameter passed to the hook is the indicator for the working directory being updated. &quot;1&quot; meaning working directory was updated or &quot;0&quot; when the working directory was not updated.</source>
          <target state="translated">후크에 전달 된 첫 번째 매개 변수는 업데이트중인 작업 디렉토리의 표시기입니다. &quot;1&quot;은 작업 디렉토리가 업데이트되었음을 ​​의미하거나 작업 디렉토리가 업데이트되지 않은 경우 &quot;0&quot;을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="69f4b05a4b19ebccc10062a19a78b72d37ff6b60" translate="yes" xml:space="preserve">
          <source>The first rule takes precedence in the case of a single &amp;lt;commit&amp;gt;. To apply the second rule, i.e., format everything since the beginning of history up until &amp;lt;commit&amp;gt;, use the &lt;code&gt;--root&lt;/code&gt; option: &lt;code&gt;git format-patch
--root &amp;lt;commit&amp;gt;&lt;/code&gt;. If you want to format only &amp;lt;commit&amp;gt; itself, you can do this with &lt;code&gt;git format-patch -1 &amp;lt;commit&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">단일 &amp;lt;commit&amp;gt;의 경우 첫 번째 규칙이 우선합니다. 두 번째 규칙을 적용하려면, 즉 &amp;lt;commit&amp;gt;까지 히스토리가 시작된 이후부터 모든 것을 포맷하려면 &lt;code&gt;--root&lt;/code&gt; 옵션을 사용하십시오 : &lt;code&gt;git format-patch --root &amp;lt;commit&amp;gt;&lt;/code&gt; . &amp;lt;commit&amp;gt; 자체 만 포맷하려면 &lt;code&gt;git format-patch -1 &amp;lt;commit&amp;gt;&lt;/code&gt; 으로 이를 수행 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="088dfc95ab36375e45956a12e0a84d20b54cd1e3" translate="yes" xml:space="preserve">
          <source>The first step is trivial: when you want to tell Git about any changes to your working tree, you use the &lt;code&gt;git update-index&lt;/code&gt; program. That program normally just takes a list of filenames you want to update, but to avoid trivial mistakes, it refuses to add new entries to the index (or remove existing ones) unless you explicitly tell it that you&amp;rsquo;re adding a new entry with the &lt;code&gt;--add&lt;/code&gt; flag (or removing an entry with the &lt;code&gt;--remove&lt;/code&gt;) flag.</source>
          <target state="translated">첫 번째 단계는 간단합니다. 작업 트리의 변경 사항에 대해 Git에 알리려면 &lt;code&gt;git update-index&lt;/code&gt; 프로그램 을 사용하십시오 . 이 프로그램은 일반적으로 업데이트하려는 파일 이름 목록을 가져 오지만 사소한 실수를 피하기 위해 색인에 새 항목을 추가한다고 명시 적으로 명시하지 않는 한 색인에 새 항목을 추가하거나 기존 항목을 제거하지 않습니다. &lt;code&gt;--add&lt;/code&gt; 플래그 (또는 &lt;code&gt;--remove&lt;/code&gt; 를 사용 하여 항목 제거 ) 플래그</target>
        </trans-unit>
        <trans-unit id="a1763915dd6826ebefd6dfcb3fd9fb79e61ff2f7" translate="yes" xml:space="preserve">
          <source>The first time that a commit shows up in the stream, it has various other information about it printed out with a one-word tag at the beginning of each line describing the extra commit information (author, email, committer, dates, summary, etc.).</source>
          <target state="translated">커밋이 처음으로 스트림에 표시되면 추가 커밋 정보 (작성자, 전자 메일, 커미터, 날짜, 요약 등)를 설명하는 각 줄의 시작 부분에 한 단어 태그로 인쇄 된 다양한 정보가 있습니다. ).</target>
        </trans-unit>
        <trans-unit id="33e2d00ff1c333999b37d340bc5ae3e8a3bfd826" translate="yes" xml:space="preserve">
          <source>The first time you run it, you will be prompted for your credentials. Enter the app-specific or your regular password as appropriate. If you have credential helper configured (see &lt;a href=&quot;git-credential&quot;&gt;git-credential[1]&lt;/a&gt;), the password will be saved in the credential store so you won&amp;rsquo;t have to type it the next time.</source>
          <target state="translated">처음 실행할 때 자격 증명을 묻는 메시지가 나타납니다. 앱 비밀번호 또는 일반 비밀번호를 적절히 입력하십시오. 자격 증명 도우미를 구성한 경우 ( &lt;a href=&quot;git-credential&quot;&gt;git-credential [1] 참조&lt;/a&gt; ) 자격 증명 저장소에 암호가 저장되므로 다음에 암호를 입력 할 필요가 없습니다.</target>
        </trans-unit>
        <trans-unit id="1c77b9db9c00c5ba7e83e0fb24758e48237c23ee" translate="yes" xml:space="preserve">
          <source>The first two lines indicate that it is showing the two branches with the titles of their top-of-the-tree commits, you are currently on &lt;code&gt;master&lt;/code&gt; branch (notice the asterisk &lt;code&gt;*&lt;/code&gt; character), and the first column for the later output lines is used to show commits contained in the &lt;code&gt;master&lt;/code&gt; branch, and the second column for the &lt;code&gt;mybranch&lt;/code&gt; branch. Three commits are shown along with their titles. All of them have non blank characters in the first column (&lt;code&gt;*&lt;/code&gt; shows an ordinary commit on the current branch, &lt;code&gt;-&lt;/code&gt; is a merge commit), which means they are now part of the &lt;code&gt;master&lt;/code&gt; branch. Only the &quot;Some work&quot; commit has the plus &lt;code&gt;+&lt;/code&gt; character in the second column, because &lt;code&gt;mybranch&lt;/code&gt; has not been merged to incorporate these commits from the master branch. The string inside brackets before the commit log message is a short name you can use to name the commit. In the above example, &lt;code&gt;master&lt;/code&gt; and &lt;code&gt;mybranch&lt;/code&gt; are branch heads. &lt;code&gt;master^&lt;/code&gt; is the first parent of &lt;code&gt;master&lt;/code&gt; branch head. Please see &lt;a href=&quot;gitrevisions&quot;&gt;gitrevisions[7]&lt;/a&gt; if you want to see more complex cases.</source>
          <target state="translated">처음 두 줄은 트리 상단 커밋의 제목과 함께 두 개의 분기를 표시하고 있음을 나타냅니다. 현재 &lt;code&gt;master&lt;/code&gt; 분기 (별표 &lt;code&gt;*&lt;/code&gt; 문자)에 있고 나중에 출력 줄의 첫 번째 열은 &lt;code&gt;master&lt;/code&gt; 브랜치에 포함 된 커밋 과 &lt;code&gt;mybranch&lt;/code&gt; 브랜치 의 두 번째 열 을 표시하는 데 사용됩니다 . 3 개의 커밋이 제목과 함께 표시됩니다. 그들 모두가 첫 번째 열에 비 공백 문자가 ( &lt;code&gt;*&lt;/code&gt; 보통의 현재 지점에 커밋 쇼, &lt;code&gt;-&lt;/code&gt; 그들은 지금의 일부 의미, 커밋 병합입니다) &lt;code&gt;master&lt;/code&gt; 분기. &quot;일부 작업&quot;커밋에만 &lt;code&gt;+&lt;/code&gt; &lt;code&gt;mybranch&lt;/code&gt; 가 병합되어 마스터 분기의 커밋을 통합하지 않았 으므로 두 번째 열의 문자 커밋 로그 메시지 앞의 괄호 안의 문자열은 커밋 이름을 지정하는 데 사용할 수있는 짧은 이름입니다. 위의 예에서 &lt;code&gt;master&lt;/code&gt; 및 &lt;code&gt;mybranch&lt;/code&gt; 는 분기 헤드입니다. &lt;code&gt;master^&lt;/code&gt; 는 &lt;code&gt;master&lt;/code&gt; 브랜치 헤드 의 첫 번째 부모입니다 . 더 복잡한 사례를 보려면 &lt;a href=&quot;gitrevisions&quot;&gt;gitrevisions [7]&lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="6b2c923c8cb34a6329089d3ed63e2b76d6f7ceed" translate="yes" xml:space="preserve">
          <source>The folder to drop the mails into, which is typically the Drafts folder. For example: &quot;INBOX.Drafts&quot;, &quot;INBOX/Drafts&quot; or &quot;[Gmail]/Drafts&quot;. Required.</source>
          <target state="translated">메일을 넣을 폴더 (보통 임시 보관함)입니다. 예 : &quot;INBOX.Drafts&quot;, &quot;INBOX / Drafts&quot;또는 &quot;[Gmail] / Drafts&quot;. 필수입니다.</target>
        </trans-unit>
        <trans-unit id="396ef1fe12b6dc07f4e5a4f66f87333df9fb56e3" translate="yes" xml:space="preserve">
          <source>The following &lt;code&gt;update&lt;/code&gt; procedures are only available via the &lt;code&gt;submodule.&amp;lt;name&amp;gt;.update&lt;/code&gt; configuration variable:</source>
          <target state="translated">다음 &lt;code&gt;update&lt;/code&gt; 절차는 &lt;code&gt;submodule.&amp;lt;name&amp;gt;.update&lt;/code&gt; 구성 변수 를 통해서만 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="109e44e80a38f6553ddae4455bbabc5ec0d98180" translate="yes" xml:space="preserve">
          <source>The following Thunderbird extensions are needed: AboutConfig from &lt;a href=&quot;http://aboutconfig.mozdev.org/&quot;&gt;http://aboutconfig.mozdev.org/&lt;/a&gt; and External Editor from &lt;a href=&quot;http://globs.org/articles.php?lng=en&amp;amp;pg=8&quot;&gt;http://globs.org/articles.php?lng=en&amp;amp;pg=8&lt;/a&gt;</source>
          <target state="translated">다음 Thunderbird 확장이 필요합니다. &lt;a href=&quot;http://aboutconfig.mozdev.org/&quot;&gt;http://aboutconfig.mozdev.org/의&lt;/a&gt; AboutConfig 및 &lt;a href=&quot;http://globs.org/articles.php?lng=en&amp;amp;pg=8&quot;&gt;http://globs.org/articles.php?lng=en&amp;amp;pg=8의&lt;/a&gt; 외부 편집기</target>
        </trans-unit>
        <trans-unit id="f6722fafbaf6d78a6b809eec36e0605e28b20857" translate="yes" xml:space="preserve">
          <source>The following are helper commands used by the above; end users typically do not use them directly.</source>
          <target state="translated">다음은 위에서 사용한 도우미 명령입니다. 최종 사용자는 일반적으로 직접 사용하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="7e10909a1942dd56a826033bd880f2f38314517d" translate="yes" xml:space="preserve">
          <source>The following command switches to the &quot;master&quot; branch:</source>
          <target state="translated">다음 명령은 &quot;마스터&quot;분기로 전환됩니다.</target>
        </trans-unit>
        <trans-unit id="7a4f4c25f3029fcde1d4a38239fa9b13c5887156" translate="yes" xml:space="preserve">
          <source>The following command-line options change import semantics and may therefore not be passed as option:</source>
          <target state="translated">다음 명령 행 옵션은 가져 오기 시맨틱을 변경하므로 옵션으로 전달되지 않을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="932cde1c301ce345d40b274a1f81ff3e5be711e6" translate="yes" xml:space="preserve">
          <source>The following command-specific comments apply:</source>
          <target state="translated">다음과 같은 명령 별 설명이 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="d6f2de10386ef19748ad0fa0931b3359b3969227" translate="yes" xml:space="preserve">
          <source>The following config settings can be used to modify &lt;code&gt;git p4&lt;/code&gt; behavior. They all are in the &lt;code&gt;git-p4&lt;/code&gt; section.</source>
          <target state="translated">다음 구성 설정을 사용하여 &lt;code&gt;git p4&lt;/code&gt; 동작 을 수정할 수 있습니다 . 그것들은 모두 &lt;code&gt;git-p4&lt;/code&gt; 섹션에 있습니다.</target>
        </trans-unit>
        <trans-unit id="f68ee79cc1f0c0e26a0c766d89a6823644298bab" translate="yes" xml:space="preserve">
          <source>The following configuration variables tell gitweb where to find files. The values of these variables are paths on the filesystem.</source>
          <target state="translated">다음 구성 변수는 gitweb에 파일을 찾을 위치를 알려줍니다. 이 변수의 값은 파일 시스템의 경로입니다.</target>
        </trans-unit>
        <trans-unit id="446ebc694e2441273405a78869483ed3506272c8" translate="yes" xml:space="preserve">
          <source>The following date formats are supported. A frontend should select the format it will use for this import by passing the format name in the --date-format=&amp;lt;fmt&amp;gt; command-line option.</source>
          <target state="translated">다음 날짜 형식이 지원됩니다. 프런트 엔드는 --date-format = &amp;lt;fmt&amp;gt; 명령 줄 옵션에 형식 이름을 전달하여이 가져 오기에 사용할 형식을 선택해야합니다.</target>
        </trans-unit>
        <trans-unit id="e77a52167245e31f57d9305063355588365e98e5" translate="yes" xml:space="preserve">
          <source>The following description divides the low-level commands into commands that manipulate objects (in the repository, index, and working tree), commands that interrogate and compare objects, and commands that move objects and references between repositories.</source>
          <target state="translated">다음 설명에서는 저수준 명령을 개체 (리포지토리, 인덱스 및 작업 트리에서)를 조작하는 명령, 개체를 조사 및 비교하는 명령 및 개체와 참조를 리포지토리간에 이동하는 명령으로 나눕니다.</target>
        </trans-unit>
        <trans-unit id="8ce90b7b29314319d9c33a8b52e106d84ec9670f" translate="yes" xml:space="preserve">
          <source>The following escape sequences (beside &lt;code&gt;\&quot;&lt;/code&gt; and &lt;code&gt;\\&lt;/code&gt;) are recognized: &lt;code&gt;\n&lt;/code&gt; for newline character (NL), &lt;code&gt;\t&lt;/code&gt; for horizontal tabulation (HT, TAB) and &lt;code&gt;\b&lt;/code&gt; for backspace (BS). Other char escape sequences (including octal escape sequences) are invalid.</source>
          <target state="translated">줄 바꿈 문자 (NL)의 경우 &lt;code&gt;\n&lt;/code&gt; , 가로 표 (HT, TAB)의 경우 &lt;code&gt;\t&lt;/code&gt; , 백 스페이스 (BS)의 경우 &lt;code&gt;\b&lt;/code&gt; 이스케이프 시퀀스 ( &lt;code&gt;\&quot;&lt;/code&gt; 및 &lt;code&gt;\\&lt;/code&gt; 옆 )가 인식 됩니다. 다른 문자 이스케이프 시퀀스 (8 진 포함) 이스케이프 시퀀스)가 유효하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="11e92a0ce8b123a34278f747bf61153deb05c5a4" translate="yes" xml:space="preserve">
          <source>The following example shows three branches, &quot;master&quot;, &quot;fixes&quot; and &quot;mhf&quot;:</source>
          <target state="translated">다음 예는 &quot;master&quot;, &quot;fixes&quot;및 &quot;mhf&quot;의 세 가지 분기를 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="4297ab330b843af6f1af2259ff9a055a87b6bf37" translate="yes" xml:space="preserve">
          <source>The following features from &amp;lsquo;svn log&amp;rsquo; are supported:</source>
          <target state="translated">'svn log'의 다음 기능이 지원됩니다.</target>
        </trans-unit>
        <trans-unit id="9b96392c24cd31061920293e2fd2511a8543969f" translate="yes" xml:space="preserve">
          <source>The following flags further affect the behavior when comparing commits (but not trees).</source>
          <target state="translated">다음 플래그는 커밋을 비교할 때 동작에 영향을 미칩니다 (트리는 아님).</target>
        </trans-unit>
        <trans-unit id="c98119f1eba9806e1383e47ef0aa9d751dbdff13" translate="yes" xml:space="preserve">
          <source>The following format are available:</source>
          <target state="translated">다음 형식을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5f08fc55d496958a337ddcb6a67febfb89f85554" translate="yes" xml:space="preserve">
          <source>The following key/value pairs are common to all events:</source>
          <target state="translated">다음 키 / 값 쌍은 모든 이벤트에 공통입니다.</target>
        </trans-unit>
        <trans-unit id="0a5e5ff367236dbd6bf5580d5af5e71ae090b770" translate="yes" xml:space="preserve">
          <source>The following options affect the way the simplification is performed:</source>
          <target state="translated">다음 옵션은 단순화 수행 방식에 영향을줍니다.</target>
        </trans-unit>
        <trans-unit id="d99d5d2882d3fb95fadc56a0416699f5b886386d" translate="yes" xml:space="preserve">
          <source>The following options are available in either location:</source>
          <target state="translated">어느 위치에서나 다음 옵션을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6e9dd1ef0925dcf9e09b1e6e501e8d0360e77eba" translate="yes" xml:space="preserve">
          <source>The following options are defined and (under suitable circumstances) set by Git if the remote helper has the &lt;code&gt;option&lt;/code&gt; capability.</source>
          <target state="translated">원격 도우미에 &lt;code&gt;option&lt;/code&gt; 기능 이있는 경우 다음 옵션이 정의되고 적절한 환경에서 Git에 의해 설정됩니다 .</target>
        </trans-unit>
        <trans-unit id="ad97d4ffb6c58a93bf3193a5402926d11d214aa1" translate="yes" xml:space="preserve">
          <source>The following options select the commits to be shown:</source>
          <target state="translated">다음 옵션은 표시 할 커밋을 선택합니다.</target>
        </trans-unit>
        <trans-unit id="04bd1c24e8e494894e5123ce96e6c123a135b194" translate="yes" xml:space="preserve">
          <source>The following options:</source>
          <target state="translated">다음과 같은 옵션이 있습니다.</target>
        </trans-unit>
        <trans-unit id="7b3b3b2ba3a3d71942fecd2cbccdbee3fd847246" translate="yes" xml:space="preserve">
          <source>The following sequence attempts to backport a patch, bails out because the code the patch applies to has changed too much, and then tries again, this time exercising more care about matching up context lines.</source>
          <target state="translated">다음 순서는 패치를 백 포트하려고 시도하고 패치가 적용되는 코드가 너무 많이 변경 되었기 때문에 구제됩니다. 이번에는 컨텍스트 라인 일치에 대해 더 많은주의를 기울입니다.</target>
        </trans-unit>
        <trans-unit id="0fb6c7c3c1a2e6361aa6d0f3ddafd309ebc6378c" translate="yes" xml:space="preserve">
          <source>The following sequence checks out the &lt;code&gt;master&lt;/code&gt; branch, reverts the &lt;code&gt;Makefile&lt;/code&gt; to two revisions back, deletes &lt;code&gt;hello.c&lt;/code&gt; by mistake, and gets it back from the index.</source>
          <target state="translated">다음 순서는 &lt;code&gt;master&lt;/code&gt; 브랜치를 체크 아웃하고 &lt;code&gt;Makefile&lt;/code&gt; 을 두 개의 수정본으로 되돌리고 실수로 &lt;code&gt;hello.c&lt;/code&gt; 를 삭제 한 다음 인덱스에서 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="b8a40037f7e020ad1f156eb7f08942ca8112c080" translate="yes" xml:space="preserve">
          <source>The following sequence switches to the &lt;code&gt;master&lt;/code&gt; branch, reverts the &lt;code&gt;Makefile&lt;/code&gt; to two revisions back, deletes hello.c by mistake, and gets it back from the index.</source>
          <target state="translated">다음 순서는 &lt;code&gt;master&lt;/code&gt; 브랜치로 전환하고 &lt;code&gt;Makefile&lt;/code&gt; 을 두 개의 수정본으로 되돌리고 실수로 hello.c를 삭제 한 다음 인덱스에서 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="75477915a08ed3777518303fe3302c5a880167a8" translate="yes" xml:space="preserve">
          <source>The following sequences have a special meaning:</source>
          <target state="translated">다음 순서는 특별한 의미가 있습니다.</target>
        </trans-unit>
        <trans-unit id="b07d72a39fdd44876a293ab8f917fa6a1014bd8c" translate="yes" xml:space="preserve">
          <source>The following subcommands are available:</source>
          <target state="translated">다음과 같은 하위 명령을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="55332124e1bbf00265c49abce68b19cb8696bb39" translate="yes" xml:space="preserve">
          <source>The following syntaxes may be used with them:</source>
          <target state="translated">다음과 같은 구문을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f9c489d8b69bf82a63ff4a237dd2bd772b8fb351" translate="yes" xml:space="preserve">
          <source>The following tables show what happens when there are unmerged entries:</source>
          <target state="translated">다음 표는 병합되지 않은 항목이있을 때 발생하는 상황을 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="3cc98c85c7406728df501340aea8c7fdc3f04d78" translate="yes" xml:space="preserve">
          <source>The following tips and tricks have been collected from various users of fast-import, and are offered here as suggestions.</source>
          <target state="translated">다음은 다양한 빠른 가져 오기 사용자로부터 얻은 팁과 요령이며 여기에서 제안으로 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="177a564b8e3982405afb3b516ab4bbb5063d1ee7" translate="yes" xml:space="preserve">
          <source>The form &lt;code&gt;--filter=blob:limit=&amp;lt;n&amp;gt;[kmg]&lt;/code&gt; omits blobs larger than n bytes or units. n may be zero. The suffixes k, m, and g can be used to name units in KiB, MiB, or GiB. For example, &lt;code&gt;blob:limit=1k&lt;/code&gt; is the same as &lt;code&gt;blob:limit=1024&lt;/code&gt;.</source>
          <target state="translated">형태 &lt;code&gt;--filter=blob:limit=&amp;lt;n&amp;gt;[kmg]&lt;/code&gt; 를 생략 블롭 바이트 단위 N보다 크다. n은 0 일 수있다. 접미사 k, m 및 g를 사용하여 KiB, MiB 또는 GiB의 단위 이름을 지정할 수 있습니다. 예를 들어, &lt;code&gt;blob:limit=1k&lt;/code&gt; 는 &lt;code&gt;blob:limit=1024&lt;/code&gt; 와 동일 합니다.</target>
        </trans-unit>
        <trans-unit id="94349f8d4383b34d05a696da3b05af67f12eec03" translate="yes" xml:space="preserve">
          <source>The form &lt;code&gt;--filter=blob:none&lt;/code&gt; omits all blobs.</source>
          <target state="translated">양식 &lt;code&gt;--filter=blob:none&lt;/code&gt; 모든 모양을 생략합니다.</target>
        </trans-unit>
        <trans-unit id="39c705af761382dd23f074438f9b0e646bf492af" translate="yes" xml:space="preserve">
          <source>The form &lt;code&gt;--filter=combine:&amp;lt;filter1&amp;gt;+&amp;lt;filter2&amp;gt;+&amp;hellip;​&amp;lt;filterN&amp;gt;&lt;/code&gt; can also be used to combined several filters, but this is harder than just repeating the &lt;code&gt;--filter&lt;/code&gt; flag and is usually not necessary. Filters are joined by &lt;code&gt;+&lt;/code&gt; and individual filters are %-encoded (i.e. URL-encoded). Besides the &lt;code&gt;+&lt;/code&gt; and &lt;code&gt;%&lt;/code&gt; characters, the following characters are reserved and also must be encoded: &lt;code&gt;~!@#$^&amp;amp;*()[]{}\;&quot;,&amp;lt;&amp;gt;?&lt;/code&gt;&lt;code&gt;'`&lt;/code&gt; as well as all characters with ASCII code &amp;lt;= &lt;code&gt;0x20&lt;/code&gt;, which includes space and newline.</source>
          <target state="translated">양식 &lt;code&gt;--filter=combine:&amp;lt;filter1&amp;gt;+&amp;lt;filter2&amp;gt;+&amp;hellip;​&amp;lt;filterN&amp;gt;&lt;/code&gt; 또한 결합 된 여러 필터를 사용할 수 있지만, 열심히 단지 반복보다 수 &lt;code&gt;--filter&lt;/code&gt; 플래그를 일반적으로 필요하지 않습니다. 필터는 &lt;code&gt;+&lt;/code&gt; 로 결합되며 개별 필터는 %로 인코딩됩니다 (예 : URL 인코딩). &lt;code&gt;+&lt;/code&gt; 및 &lt;code&gt;%&lt;/code&gt; 문자 외에도 다음 문자가 예약되어 있으며 인코딩되어야합니다. &lt;code&gt;~!@#$^&amp;amp;*()[]{}\;&quot;,&amp;lt;&amp;gt;?&lt;/code&gt; &lt;code&gt;'`&lt;/code&gt; 및 ASCII 코드가있는 모든 문자 &amp;lt; = &lt;code&gt;0x20&lt;/code&gt; 에는 공백과 줄 바꿈이 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="d52505ec75878146eb9054dceb4728d58b485513" translate="yes" xml:space="preserve">
          <source>The form &lt;code&gt;--filter=sparse:oid=&amp;lt;blob-ish&amp;gt;&lt;/code&gt; uses a sparse-checkout specification contained in the blob (or blob-expression) &lt;code&gt;&amp;lt;blob-ish&amp;gt;&lt;/code&gt; to omit blobs that would not be not required for a sparse checkout on the requested refs.</source>
          <target state="translated">형태 &lt;code&gt;--filter=sparse:oid=&amp;lt;blob-ish&amp;gt;&lt;/code&gt; 스파 스 결제 명세가 블롭 함유 사용 (또는 블로 표현) &lt;code&gt;&amp;lt;blob-ish&amp;gt;&lt;/code&gt; 을 생략 블롭 희소 결제에 필요한지지 않을 것이라고 요청 된 심판.</target>
        </trans-unit>
        <trans-unit id="ef46a11218e9457b2745a05e86c211527bd23b7c" translate="yes" xml:space="preserve">
          <source>The form &lt;code&gt;--filter=tree:&amp;lt;depth&amp;gt;&lt;/code&gt; omits all blobs and trees whose depth from the root tree is &amp;gt;= &amp;lt;depth&amp;gt; (minimum depth if an object is located at multiple depths in the commits traversed). &amp;lt;depth&amp;gt;=0 will not include any trees or blobs unless included explicitly in the command-line (or standard input when --stdin is used). &amp;lt;depth&amp;gt;=1 will include only the tree and blobs which are referenced directly by a commit reachable from &amp;lt;commit&amp;gt; or an explicitly-given object. &amp;lt;depth&amp;gt;=2 is like &amp;lt;depth&amp;gt;=1 while also including trees and blobs one more level removed from an explicitly-given commit or tree.</source>
          <target state="translated">&lt;code&gt;--filter=tree:&amp;lt;depth&amp;gt;&lt;/code&gt; 형식 은 루트 트리에서 깊이가&amp;gt; = &amp;lt;depth&amp;gt; (객체가 커밋을 통과 한 여러 깊이에있는 경우 최소 깊이) 인 모든 블롭 및 트리를 생략합니다. &amp;lt;depth&amp;gt; = 0은 명령 줄에 명시 적으로 포함되지 않은 경우 (또는 --stdin을 사용하는 경우 표준 입력) 트리 나 얼룩을 포함하지 않습니다. &amp;lt;depth&amp;gt; = 1은 &amp;lt;commit&amp;gt;에서 도달 할 수있는 커밋 또는 명시 적으로 제공된 객체에 의해 직접 참조되는 트리와 블로 브 만 포함합니다. &amp;lt;depth&amp;gt; = 2는 &amp;lt;depth&amp;gt; = 1과 같지만 명시 적으로 제공된 커밋 또는 트리에서 제거 된 한 단계 이상의 트리 및 얼룩도 포함합니다.</target>
        </trans-unit>
        <trans-unit id="143c72f9a0abe1adb065cd1c00c0271a08c274c4" translate="yes" xml:space="preserve">
          <source>The form &lt;code&gt;--missing=allow-any&lt;/code&gt; will allow object traversal to continue if a missing object is encountered. Missing objects will silently be omitted from the results.</source>
          <target state="translated">&lt;code&gt;--missing=allow-any&lt;/code&gt; 형식 은 누락 된 객체가 발견되면 객체 순회가 계속되도록합니다. 누락 된 개체는 결과에서 자동으로 생략됩니다.</target>
        </trans-unit>
        <trans-unit id="280716e3ccf86616960848b089fdadef81ba797d" translate="yes" xml:space="preserve">
          <source>The form &lt;code&gt;--missing=allow-promisor&lt;/code&gt; is like &lt;code&gt;allow-any&lt;/code&gt;, but will only allow object traversal to continue for EXPECTED promisor missing objects. Unexpected missing object will raise an error.</source>
          <target state="translated">&lt;code&gt;--missing=allow-promisor&lt;/code&gt; 형식 은 &lt;code&gt;allow-any&lt;/code&gt; 와 유사 하지만 예상 통과 유망 누락 객체에 대해 객체 순회 만 계속 허용합니다. 예상치 못한 누락 된 개체는 오류를 발생시킵니다.</target>
        </trans-unit>
        <trans-unit id="563d9e750d01dbe920d57035d16bed3d91b9aea6" translate="yes" xml:space="preserve">
          <source>The form &lt;code&gt;--missing=allow-promisor&lt;/code&gt; is like &lt;code&gt;allow-any&lt;/code&gt;, but will only allow object traversal to continue for EXPECTED promisor missing objects. Unexpected missing objects will raise an error.</source>
          <target state="translated">&lt;code&gt;--missing=allow-promisor&lt;/code&gt; 형식 은 &lt;code&gt;allow-any&lt;/code&gt; 와 유사 하지만 예상 통과 유망 누락 객체에 대해 객체 순회 만 계속 허용합니다. 예상치 못한 누락 된 개체는 오류를 발생시킵니다.</target>
        </trans-unit>
        <trans-unit id="28c618ed732782b866de4c7dcf716daa2ac64119" translate="yes" xml:space="preserve">
          <source>The form &lt;code&gt;--missing=error&lt;/code&gt; requests that pack-objects stop with an error if a missing object is encountered. This is the default action.</source>
          <target state="translated">&lt;code&gt;--missing=error&lt;/code&gt; 양식 은 누락 된 객체가 발견되면 pack-objects가 오류와 함께 중지되도록 요청합니다. 이것이 기본 동작입니다.</target>
        </trans-unit>
        <trans-unit id="2ed32158adb2f2f236ac5307d5ba7c30f0630796" translate="yes" xml:space="preserve">
          <source>The form &lt;code&gt;--missing=error&lt;/code&gt; requests that rev-list stop with an error if a missing object is encountered. This is the default action.</source>
          <target state="translated">&lt;code&gt;--missing=error&lt;/code&gt; 양식 은 누락 된 객체가 발견되면 rev-list가 오류와 함께 중지되도록 요청합니다. 이것이 기본 동작입니다.</target>
        </trans-unit>
        <trans-unit id="67e4b67693941fe412533d5210bde2a413de8fb1" translate="yes" xml:space="preserve">
          <source>The form &lt;code&gt;--missing=print&lt;/code&gt; is like &lt;code&gt;allow-any&lt;/code&gt;, but will also print a list of the missing objects. Object IDs are prefixed with a &amp;ldquo;?&amp;rdquo; character.</source>
          <target state="translated">&lt;code&gt;--missing=print&lt;/code&gt; 형식 은 &lt;code&gt;allow-any&lt;/code&gt; 와 유사 하지만 누락 된 개체의 목록도 인쇄합니다. 개체 ID 앞에는 &quot;?&quot;가 붙습니다. 캐릭터.</target>
        </trans-unit>
        <trans-unit id="09994cb2384da5eddbe0ae0a9a1ceca76d8c8bcc" translate="yes" xml:space="preserve">
          <source>The format of a &amp;lt;refspec&amp;gt; parameter is an optional plus &lt;code&gt;+&lt;/code&gt;, followed by the source &amp;lt;src&amp;gt;, followed by a colon &lt;code&gt;:&lt;/code&gt;, followed by the destination ref &amp;lt;dst&amp;gt;. The colon can be omitted when &amp;lt;dst&amp;gt; is empty. &amp;lt;src&amp;gt; is typically a ref, but it can also be a fully spelled hex object name.</source>
          <target state="translated">&amp;lt;refspec&amp;gt; 매개 변수의 형식은 선택적인 plus &lt;code&gt;+&lt;/code&gt; , 소스 &amp;lt;src&amp;gt;, 콜론 &lt;code&gt;:&lt;/code&gt; , 목적지 ref &amp;lt;dst&amp;gt;입니다. &amp;lt;dst&amp;gt;가 비어 있으면 콜론을 생략 할 수 있습니다. &amp;lt;src&amp;gt;는 일반적으로 ref이지만, 완전한 철자 16 진 오브젝트 이름 일 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="05c09db4c870e826391cf6ebde5a8cc33d2791f6" translate="yes" xml:space="preserve">
          <source>The format of these files is username followed by the encrypted password, for example:</source>
          <target state="translated">이러한 파일의 형식은 사용자 이름 뒤에 암호화 된 비밀번호가 있습니다 (예 :</target>
        </trans-unit>
        <trans-unit id="65670970ee487305077ce344ca1fb6c36a889cee" translate="yes" xml:space="preserve">
          <source>The former lets your shell expand the fileglob, and you are asking the dot-C files in your working tree to be overwritten with the version in the index. The latter passes the &lt;code&gt;*.c&lt;/code&gt; to Git, and you are asking the paths in the index that match the pattern to be checked out to your working tree. After running &lt;code&gt;git add hello.c; rm hello.c&lt;/code&gt;, you will &lt;code&gt;not&lt;/code&gt; see &lt;code&gt;hello.c&lt;/code&gt; in your working tree with the former, but with the latter you will.</source>
          <target state="translated">전자는 쉘이 fileglob를 확장 할 수있게하여 작업 트리의 dot-C 파일을 색인의 버전으로 겹쳐 쓰도록 요청합니다. 후자는 &lt;code&gt;*.c&lt;/code&gt; 를 Git에 전달하고, 작업 트리에 체크 아웃 할 패턴과 일치하는 인덱스의 경로를 묻습니다. &lt;code&gt;git add hello.c; rm hello.c&lt;/code&gt; 실행 한 후 hello.c를 추가하십시오; rm hello.c , 작업 트리에서 &lt;code&gt;hello.c&lt;/code&gt; 를 전자와 함께 보지 &lt;code&gt;not&lt;/code&gt; 후자 에서는 hello.c 를 볼 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b363974f459c2a2b237a919650aa9dc9f75161d2" translate="yes" xml:space="preserve">
          <source>The frontend must specify the number of bytes of data.</source>
          <target state="translated">프론트 엔드는 데이터의 바이트 수를 지정해야합니다.</target>
        </trans-unit>
        <trans-unit id="23957db0f038e6b4263285c2923ad6ce72a805ca" translate="yes" xml:space="preserve">
          <source>The full SHA-1 object name (40-byte hexadecimal string), or a leading substring that is unique within the repository. E.g. dae86e1950b1277e545cee180551750029cfe735 and dae86e both name the same commit object if there is no other object in your repository whose object name starts with dae86e.</source>
          <target state="translated">전체 SHA-1 오브젝트 이름 (40 바이트 16 진 문자열) 또는 저장소 내에서 고유 한 선행 서브 스트링 예를 들어 dae86e1950b1277e545cee180551750029cfe735와 dae86e는 저장소에 객체 이름이 dae86e로 시작하는 다른 객체가없는 경우 동일한 커밋 객체의 이름을 지정합니다.</target>
        </trans-unit>
        <trans-unit id="ce332106cb9361add9aaf31aea030a425aeed7be" translate="yes" xml:space="preserve">
          <source>The full name is occasionally useful if, for example, there ever exists a tag and a branch with the same name.</source>
          <target state="translated">전체 이름은 예를 들어 같은 이름의 태그와 분기가있는 경우에 유용합니다.</target>
        </trans-unit>
        <trans-unit id="d24187cae372eb76b2a26570ccfd9def8c8abdf6" translate="yes" xml:space="preserve">
          <source>The full pattern set allows for arbitrary pattern matches and complicated inclusion/exclusion rules. These can result in O(N*M) pattern matches when updating the index, where N is the number of patterns and M is the number of paths in the index. To combat this performance issue, a more restricted pattern set is allowed when &lt;code&gt;core.spareCheckoutCone&lt;/code&gt; is enabled.</source>
          <target state="translated">전체 패턴 세트는 임의의 패턴 일치 및 복잡한 포함 / 제외 규칙을 허용합니다. 이로 인해 인덱스를 업데이트 할 때 O (N * M) 패턴 일치가 발생할 수 있습니다. 여기서 N은 패턴 수이고 M은 인덱스의 경로 수입니다. 이 성능 문제를 해결하기 위해 &lt;code&gt;core.spareCheckoutCone&lt;/code&gt; 이 활성화 된 경우보다 제한된 패턴 세트가 허용됩니다 .</target>
        </trans-unit>
        <trans-unit id="6d3e98918a57498bee35c9ef416c5932bb448c1f" translate="yes" xml:space="preserve">
          <source>The full syntax for a p4 view is documented in &lt;code&gt;p4 help views&lt;/code&gt;. &lt;code&gt;git p4&lt;/code&gt; knows only a subset of the view syntax. It understands multi-line mappings, overlays with &lt;code&gt;+&lt;/code&gt;, exclusions with &lt;code&gt;-&lt;/code&gt; and double-quotes around whitespace. Of the possible wildcards, &lt;code&gt;git p4&lt;/code&gt; only handles &lt;code&gt;&amp;hellip;​&lt;/code&gt;, and only when it is at the end of the path. &lt;code&gt;git p4&lt;/code&gt; will complain if it encounters an unhandled wildcard.</source>
          <target state="translated">p4보기의 전체 구문은 &lt;code&gt;p4 help views&lt;/code&gt; 설명되어 있습니다 . &lt;code&gt;git p4&lt;/code&gt; 는 뷰 구문의 하위 집합 만 알고 있습니다. 여러 줄 매핑, &lt;code&gt;+&lt;/code&gt; 오버레이 , 공백 주위의 &lt;code&gt;-&lt;/code&gt; 및 큰 따옴표 제외를 이해 합니다. 가능한 와일드 카드, &lt;code&gt;git p4&lt;/code&gt; 만 핸들 &lt;code&gt;&amp;hellip;​&lt;/code&gt; , 그것은 경로 끝에 때만. &lt;code&gt;git p4&lt;/code&gt; 는 처리되지 않은 와일드 카드가 발생하면 불평합니다.</target>
        </trans-unit>
        <trans-unit id="18d1519c9cf5420b92be3f082cd6f0aa89c3d260" translate="yes" xml:space="preserve">
          <source>The function &lt;code&gt;skip_commit&lt;/code&gt; is defined as follows:</source>
          <target state="translated">&lt;code&gt;skip_commit&lt;/code&gt; 함수 는 다음과 같이 정의됩니다.</target>
        </trans-unit>
        <trans-unit id="af7dd50b5e9b3d3ec2ae519f399794527002dc23" translate="yes" xml:space="preserve">
          <source>The functions defined by the Trace2 API are declared and documented in &lt;code&gt;trace2.h&lt;/code&gt;. It defines the API functions and wrapper macros for Trace2.</source>
          <target state="translated">Trace2 API에 의해 정의 된 함수 선언에 설명되어 있습니다 &lt;code&gt;trace2.h&lt;/code&gt; . Trace2의 API 함수 및 랩퍼 매크로를 정의합니다.</target>
        </trans-unit>
        <trans-unit id="e5521fd46bed9d589b56b651d5f3ef04e9a3b2a8" translate="yes" xml:space="preserve">
          <source>The future of bisecting</source>
          <target state="translated">이등분의 미래</target>
        </trans-unit>
        <trans-unit id="2aa4427c10c7d5c13ef7bbb9898f5fea28090dd1" translate="yes" xml:space="preserve">
          <source>The general idea is this: we generate a cost matrix between the commits in both commit ranges, then solve the least-cost assignment.</source>
          <target state="translated">일반적인 아이디어는 다음과 같습니다. 두 커밋 범위에서 커밋간에 비용 매트릭스를 생성 한 다음 최소 비용 할당을 해결합니다.</target>
        </trans-unit>
        <trans-unit id="0339eef2339eb8367ea8564b9ff6721cd9dea407" translate="yes" xml:space="preserve">
          <source>The git commit is created relative to the current origin revision (HEAD by default). A parent commit is created based on the origin, and then the unshelve commit is created based on that.</source>
          <target state="translated">git commit은 현재 원점 개정판 (기본적으로 HEAD)을 기준으로 작성됩니다. 원본 커밋을 기반으로 부모 커밋이 생성 된 다음이를 기반으로 unshelve 커밋이 생성됩니다.</target>
        </trans-unit>
        <trans-unit id="a5bbcd1beb35762403be84a14e62e0a4eb5d5226" translate="yes" xml:space="preserve">
          <source>The git object database</source>
          <target state="translated">자식 객체 데이터베이스</target>
        </trans-unit>
        <trans-unit id="80d403b9b878573aec88e9c705123dc6feedf769" translate="yes" xml:space="preserve">
          <source>The gitweb CGI script for viewing Git repositories over the web uses a perl script fragment as its configuration file. You can set variables using &quot;&lt;code&gt;our $variable = value&lt;/code&gt;&quot;; text from a &quot;#&quot; character until the end of a line is ignored. See &lt;strong&gt;perlsyn&lt;/strong&gt;(1) for details.</source>
          <target state="translated">웹에서 Git 저장소를보기위한 gitweb CGI 스크립트는 구성 파일로 perl 스크립트 조각을 사용합니다. &quot; &lt;code&gt;our $variable = value&lt;/code&gt; &quot;;를 사용하여 변수를 설정할 수 있습니다 . &quot;#&quot;문자부터 줄 끝까지의 텍스트는 무시됩니다. 자세한 내용은 &lt;strong&gt;perlsyn&lt;/strong&gt; (1)을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="a1a6c42c76028a67bf39dd75b77a2307812be731" translate="yes" xml:space="preserve">
          <source>The gitweb cgi script provides users an easy way to browse your project&amp;rsquo;s revisions, file contents and logs without having to install Git. Features like RSS/Atom feeds and blame/annotation details may optionally be enabled.</source>
          <target state="translated">gitweb cgi 스크립트는 Git을 설치하지 않고도 프로젝트 개정, 파일 내용 및 로그를 쉽게 탐색 할 수있는 방법을 제공합니다. RSS / Atom 피드 및 Blame / Annotation 세부 사항과 같은 기능을 선택적으로 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="eefcb42be74db518327d9c82beb9a165d884846e" translate="yes" xml:space="preserve">
          <source>The gitweb features that are configurable via &lt;code&gt;%feature&lt;/code&gt; hash are listed below. This should be a complete list, but ultimately the authoritative and complete list is in gitweb.cgi source code, with features described in the comments.</source>
          <target state="translated">&lt;code&gt;%feature&lt;/code&gt; 해시 를 통해 구성 할 수있는 gitweb 기능 은 다음과 같습니다. 이것은 완전한 목록이어야하지만 궁극적으로 권위 있고 완전한 목록은 gitweb.cgi 소스 코드에 있으며 주석에 설명 된 기능이 있습니다.</target>
        </trans-unit>
        <trans-unit id="bee84a897df9efb668b9aee969a1e660ed8af0a4" translate="yes" xml:space="preserve">
          <source>The gitweb.extraBranchRefs is actually a multi-valued configuration variable, so following example is also correct and the result is the same as of the snippet above:</source>
          <target state="translated">gitweb.extraBranchRefs는 실제로 다중 값 구성 변수이므로 다음 예제도 정확하며 결과는 위의 스 니펫과 동일합니다.</target>
        </trans-unit>
        <trans-unit id="ab9a5e4603e46ba18e0a4c5efe881c7ac8def35b" translate="yes" xml:space="preserve">
          <source>The given URL is recorded into &lt;code&gt;.gitmodules&lt;/code&gt; for use by subsequent users cloning the superproject. If the URL is given relative to the superproject&amp;rsquo;s repository, the presumption is the superproject and submodule repositories will be kept together in the same relative location, and only the superproject&amp;rsquo;s URL needs to be provided. git-submodule will correctly locate the submodule using the relative URL in &lt;code&gt;.gitmodules&lt;/code&gt;.</source>
          <target state="translated">주어진 URL은 수퍼 프로젝트를 복제하는 후속 사용자가 사용할 수 있도록 &lt;code&gt;.gitmodules&lt;/code&gt; 에 기록됩니다 . URL이 수퍼 프로젝트의 저장소와 관련하여 제공되는 경우 수퍼 프로젝트와 하위 모듈 저장소는 동일한 상대 위치에 함께 유지되며 수퍼 프로젝트의 URL 만 제공하면됩니다. git-submodule은 &lt;code&gt;.gitmodules&lt;/code&gt; 의 상대 URL을 사용하여 서브 모듈을 올바르게 찾습니다 .</target>
        </trans-unit>
        <trans-unit id="1190edfebfe2406cf333713a0e461379865b033f" translate="yes" xml:space="preserve">
          <source>The goal of this tutorial is to introduce two fundamental pieces of Git&amp;rsquo;s architecture&amp;mdash;​the object database and the index file&amp;mdash;​and to provide the reader with everything necessary to understand the rest of the Git documentation.</source>
          <target state="translated">이 튜토리얼의 목적은 Git 아키텍처의 두 가지 기본 요소 인 객체 데이터베이스와 인덱스 파일을 소개하고 나머지 Git 문서를 이해하는 데 필요한 모든 것을 독자에게 제공하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="880a291c14c1099392ebdd9b73ec08c93b7220d1" translate="yes" xml:space="preserve">
          <source>The hard case</source>
          <target state="translated">어려운 경우</target>
        </trans-unit>
        <trans-unit id="7d2a187748caf680c0e66173f60176ec60ea02ab" translate="yes" xml:space="preserve">
          <source>The header consists of 256 4-byte network byte order integers. N-th entry of this table records the number of objects in the corresponding pack, the first byte of whose object name is less than or equal to N. This is called the &lt;code&gt;first-level fan-out&lt;/code&gt; table.</source>
          <target state="translated">헤더는 256 4 바이트 네트워크 바이트 순서 정수로 구성됩니다. 이 테이블의 N 번째 항목은 해당 팩에있는 오브젝트의 수를 기록합니다. 첫 번째 바이트의 오브젝트 이름은 N보다 작거나 같습니다.이를 &lt;code&gt;first-level fan-out&lt;/code&gt; 테이블이라고합니다.</target>
        </trans-unit>
        <trans-unit id="0e2dd021a6a8dc94bfb40a62a04904f17b8f1dab" translate="yes" xml:space="preserve">
          <source>The header is followed by number of object entries, each of which looks like this:</source>
          <target state="translated">헤더 다음에는 여러 객체 항목이 있으며 각 항목은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="10743ced5c1563e940127b440ba806235a399ac8" translate="yes" xml:space="preserve">
          <source>The header is followed by sorted 24-byte entries, one entry per object in the pack. Each entry is:</source>
          <target state="translated">헤더 다음에는 팩의 오브젝트 당 하나의 항목으로 정렬 된 24 바이트 항목이 있습니다. 각 항목은 다음과 같습니다</target>
        </trans-unit>
        <trans-unit id="03910dca7f1c0af7f3d0e6986f455aceaec86f05" translate="yes" xml:space="preserve">
          <source>The header of the email is configurable via command-line options. If not specified on the command line, the user will be prompted with a ReadLine enabled interface to provide the necessary information.</source>
          <target state="translated">이메일 헤더는 명령 행 옵션을 통해 구성 할 수 있습니다. 명령 행에 지정되지 않은 경우 필요한 정보를 제공하기 위해 ReadLine 사용 인터페이스가 프롬프트됩니다.</target>
        </trans-unit>
        <trans-unit id="53d28fdf80ee055eff1005765033449c285d4f79" translate="yes" xml:space="preserve">
          <source>The hook always runs after the automatic note copying (see &quot;notes.rewrite.&amp;lt;command&amp;gt;&quot; in &lt;a href=&quot;git-config&quot;&gt;git-config[1]&lt;/a&gt;) has happened, and thus has access to these notes.</source>
          <target state="translated">후크는 자동 노트 복사 ( &lt;a href=&quot;git-config&quot;&gt;git-config [1]의&lt;/a&gt; &quot;notes.rewrite. &amp;lt;command&amp;gt;&quot;참조)가 발생한 후에 항상 실행 되므로 이러한 노트에 액세스 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="55997df4465d2b793292e1300e70ff2f9e1a3588" translate="yes" xml:space="preserve">
          <source>The hook executes once for each ref to be updated, and takes three parameters:</source>
          <target state="translated">후크는 각 참조가 업데이트 될 때마다 한 번씩 실행되며 세 개의 매개 변수를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="6422fdbff7a8b80abf6e11b9c756369981239875" translate="yes" xml:space="preserve">
          <source>The hook is allowed to edit the message file in place, and can be used to normalize the message into some project standard format. It can also be used to refuse the commit after inspecting the message file.</source>
          <target state="translated">후크는 메시지 파일을 제자리에서 편집 할 수 있으며 메시지를 일부 프로젝트 표준 형식으로 정규화하는 데 사용할 수 있습니다. 메시지 파일을 검사 한 후 커밋을 거부하는 데 사용할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="7dd8785c8f6fdd3a8a45999afa9f773631b556f1" translate="yes" xml:space="preserve">
          <source>The hook receives a list of the rewritten commits on stdin, in the format</source>
          <target state="translated">후크는 stdin에서 다시 작성된 커밋 목록을 형식으로받습니다.</target>
        </trans-unit>
        <trans-unit id="ffb0d43685532aa46e893849969758ab23367451" translate="yes" xml:space="preserve">
          <source>The hook receives the commit with which the tip of the current branch is going to be updated. It can exit with a non-zero status to refuse the push (when it does so, it must not modify the index or the working tree). Or it can make any necessary changes to the working tree and to the index to bring them to the desired state when the tip of the current branch is updated to the new commit, and exit with a zero status.</source>
          <target state="translated">후크는 현재 분기의 팁이 업데이트 될 커밋을 수신합니다. 푸시를 거부하기 위해 0이 아닌 상태로 종료 할 수 있습니다 (그렇게 할 경우 인덱스 또는 작업 트리를 수정해서는 안 됨). 또는 현재 분기의 팁이 새 커밋으로 업데이트 될 때 작업 트리와 인덱스를 원하는대로 변경하여 원하는 상태로 만들고 0 상태로 종료 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6e0236cadc345b5114c4c6984e7438ed153e1f2f" translate="yes" xml:space="preserve">
          <source>The hook should exit with non-zero status if it wants to disallow updating the named ref. Otherwise it should exit with zero.</source>
          <target state="translated">명명 된 참조를 업데이트하지 않으려면 후크가 0이 아닌 상태로 종료해야합니다. 그렇지 않으면 0으로 종료해야합니다.</target>
        </trans-unit>
        <trans-unit id="9739d79c49b82b53238e48aeefee9c342d93a499" translate="yes" xml:space="preserve">
          <source>The hook should output to stdout the list of all files in the working directory that may have changed since the requested time. The logic should be inclusive so that it does not miss any potential changes. The paths should be relative to the root of the working directory and be separated by a single NUL.</source>
          <target state="translated">후크는 요청 된 시간 이후 변경되었을 수있는 작업 디렉토리의 모든 파일 목록을 stdout하기 위해 출력해야합니다. 잠재적 인 변경 사항을 놓치지 않도록 논리가 포괄적이어야합니다. 경로는 작업 디렉토리의 루트에 상대적이어야하며 단일 NUL로 구분되어야합니다.</target>
        </trans-unit>
        <trans-unit id="022998a9843b7be307eb2d587f13704cf2ce86bd" translate="yes" xml:space="preserve">
          <source>The horizontal line of history A---Q is taken to be the first parent of each merge. The commits are:</source>
          <target state="translated">히스토리 A--Q의 수평선은 각 병합의 첫 번째 상위로 간주됩니다. 커밋은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="bdf0ebdfb4273a6fce7952dfa28834b6e411cd7f" translate="yes" xml:space="preserve">
          <source>The hypothetical proxy command entries actually have a postfix to discern what URL they apply to. Here is how to change the entry for kernel.org to &quot;ssh&quot;.</source>
          <target state="translated">가상 프록시 명령 항목에는 실제로 적용 할 URL을 식별하기위한 접미사가 있습니다. 다음은 kernel.org의 항목을 &quot;ssh&quot;로 변경하는 방법입니다.</target>
        </trans-unit>
        <trans-unit id="4399284bfb632a08cce3f3533db563320f49af23" translate="yes" xml:space="preserve">
          <source>The id of a tree object to diff against.</source>
          <target state="translated">비교할 트리 객체의 ID입니다.</target>
        </trans-unit>
        <trans-unit id="0505b9e9f78e78efa1c8b76bc422638cba05b1b7" translate="yes" xml:space="preserve">
          <source>The id of a tree object.</source>
          <target state="translated">트리 객체의 ID입니다.</target>
        </trans-unit>
        <trans-unit id="2e60e84271eec03fd28b067b32c84bb5fbe76999" translate="yes" xml:space="preserve">
          <source>The id of the tree object(s) to be read/merged.</source>
          <target state="translated">읽거나 병합 할 트리 개체의 ID입니다.</target>
        </trans-unit>
        <trans-unit id="fb9074ec22bab96e3e97d4855db9bfaed224187c" translate="yes" xml:space="preserve">
          <source>The idea is that every 3 test for example, &quot;git bisect&quot; could ask the user to test a commit that has already been found to be &quot;good&quot; or &quot;bad&quot; (because one of its descendants or one of its ancestors has been found to be &quot;good&quot; or &quot;bad&quot; respectively). If it happens that a commit has been previously incorrectly classified then the bisection can be aborted early, hopefully before too many mistakes have been made. Then the user will have to look at what happened and then restart the bisection using a fixed bisect log.</source>
          <target state="translated">아이디어는 예를 들어 &quot;git bisect&quot;마다 3 가지 테스트 (자손 중 하나 또는 조상 중 하나가 발견 되었기 때문에 이미 &quot;좋음&quot;또는 &quot;나쁜&quot;것으로 확인 된 커밋을 테스트하도록 요청할 수 있습니다. '좋은'또는 '나쁜' 커밋이 이전에 잘못 분류 된 경우 너무 많은 실수가 있기 전에 이분법이 일찍 중단 될 수 있습니다. 그런 다음 사용자는 발생한 상황을 확인한 다음 고정 된 이등분 로그를 사용하여 이분법을 다시 시작해야합니다.</target>
        </trans-unit>
        <trans-unit id="b3a07b8c786a1b03697e9ded467b22cd2ece1ab4" translate="yes" xml:space="preserve">
          <source>The idea is to manually tell &lt;code&gt;git rebase&lt;/code&gt; &quot;where the old &lt;code&gt;subsystem&lt;/code&gt; ended and your &lt;code&gt;topic&lt;/code&gt; began&quot;, that is, what the old merge base between them was. You will have to find a way to name the last commit of the old &lt;code&gt;subsystem&lt;/code&gt;, for example:</source>
          <target state="translated">아이디어는 수동으로 &lt;code&gt;git rebase&lt;/code&gt; 에게 &quot;오래된 &lt;code&gt;subsystem&lt;/code&gt; 종료되고 &lt;code&gt;topic&lt;/code&gt; 시작된 위치&quot;, 즉 그들 사이의 기존 병합베이스가 무엇인지를 알려주는 것입니다. 예를 들어 이전 &lt;code&gt;subsystem&lt;/code&gt; 의 마지막 커밋 이름을 지정하는 방법을 찾아야합니다 .</target>
        </trans-unit>
        <trans-unit id="1ff2a3a30d68d12ef6b058f357f43e3bd9cd4f0f" translate="yes" xml:space="preserve">
          <source>The idx files to verify.</source>
          <target state="translated">확인할 idx 파일</target>
        </trans-unit>
        <trans-unit id="fd29bd486dc43b124e6d98a808e18b86c2905ae4" translate="yes" xml:space="preserve">
          <source>The import checks out from CVS every revision of every file. Reportedly cvsimport can average some twenty revisions per second, so for a medium-sized project this should not take more than a couple of minutes. Larger projects or remote repositories may take longer.</source>
          <target state="translated">가져 오기는 모든 파일의 모든 개정판을 CVS에서 체크 아웃합니다. 보도에 따르면 cvsimport는 초당 평균 20 회의 수정을 수행 할 수 있으므로 중간 규모 프로젝트의 경우 몇 분 이상 걸리지 않아야합니다. 더 큰 프로젝트 또는 원격 저장소는 더 오래 걸릴 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="69f04e00f7076b8b130e67c7134e53f7f1076bf2" translate="yes" xml:space="preserve">
          <source>The import is incremental, so if you call it again next month it will fetch any CVS updates that have been made in the meantime. For this to work, you must not modify the imported branches; instead, create new branches for your own changes, and merge in the imported branches as necessary.</source>
          <target state="translated">가져 오기는 증분이므로 다음 달에 다시 호출하면 그 동안 작성된 CVS 업데이트를 가져옵니다. 이렇게하려면 가져온 분기를 수정하지 않아야합니다. 대신 자신의 변경 사항에 대한 새 분기를 만들고 필요한 경우 가져온 분기를 병합하십시오.</target>
        </trans-unit>
        <trans-unit id="807035ab1f5be4f0cb3563dc9b49740571ca0fa4" translate="yes" xml:space="preserve">
          <source>The index</source>
          <target state="translated">색인</target>
        </trans-unit>
        <trans-unit id="4284ed429265f3c1afc30e4fc09197d88352698c" translate="yes" xml:space="preserve">
          <source>The index and the working tree are adjusted as if you had previously run &lt;code&gt;git checkout &amp;lt;start_point&amp;gt;&lt;/code&gt;. This allows you to start a new history that records a set of paths similar to &lt;code&gt;&amp;lt;start_point&amp;gt;&lt;/code&gt; by easily running &lt;code&gt;git commit -a&lt;/code&gt; to make the root commit.</source>
          <target state="translated">인덱스와 작업 트리는 이전에 &lt;code&gt;git checkout &amp;lt;start_point&amp;gt;&lt;/code&gt; 를 실행 한 것처럼 조정됩니다 . 이를 통해 &lt;code&gt;git commit -a&lt;/code&gt; 를 쉽게 실행 하여 루트 커밋을 만들어 &lt;code&gt;&amp;lt;start_point&amp;gt;&lt;/code&gt; 와 비슷한 경로 집합을 기록하는 새 기록을 시작할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="0818281aa21612fb5fa362015c64c5645d861084" translate="yes" xml:space="preserve">
          <source>The index contains all the information necessary to generate a single (uniquely determined) tree object.</source>
          <target state="translated">색인에는 단일 (독특하게 결정된) 트리 오브젝트를 생성하는 데 필요한 모든 정보가 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="3d9fb9e020c0d003a42d72f87f16ba2ba38226e6" translate="yes" xml:space="preserve">
          <source>The index enables fast comparisons between the tree object it defines and the working tree.</source>
          <target state="translated">인덱스를 사용하면 정의한 트리 개체와 작업 트리를 빠르게 비교할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="eb65460c6179ccddcd4479166e9da44d8f5c40d8" translate="yes" xml:space="preserve">
          <source>The index file</source>
          <target state="translated">색인 파일</target>
        </trans-unit>
        <trans-unit id="181ab401ce7a15640077d5cb413c24fc6eb6a97e" translate="yes" xml:space="preserve">
          <source>The index file is a cache of the state of a directory tree, used to create commits, check out working directories, and hold the various trees involved in a merge.</source>
          <target state="translated">인덱스 파일은 디렉토리 트리 상태의 캐시로, 커밋을 생성하고 작업 디렉토리를 체크 아웃하며 병합과 관련된 다양한 트리를 보유하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="a98935eae61bfe66b9928e790965f624bf2f8b5b" translate="yes" xml:space="preserve">
          <source>The index file is initialized with a list of all paths and, for each path, a blob object and a set of attributes. The blob object represents the contents of the file as of the head of the current branch. The attributes (last modified time, size, etc.) are taken from the corresponding file in the working tree. Subsequent changes to the working tree can be found by comparing these attributes. The index may be updated with new content, and new commits may be created from the content stored in the index.</source>
          <target state="translated">인덱스 파일은 모든 경로 목록과 각 경로에 대해 BLOB 개체 및 특성 집합으로 초기화됩니다. Blob 객체는 현재 분기의 헤드를 기준으로 파일의 내용을 나타냅니다. 속성 (마지막으로 수정 한 시간, 크기 등)은 작업 트리의 해당 파일에서 가져옵니다. 이러한 속성을 비교하여 작업 트리에 대한 후속 변경 사항을 찾을 수 있습니다. 인덱스는 새로운 컨텐츠로 업데이트 될 수 있으며 인덱스에 저장된 컨텐츠로부터 새로운 커밋이 생성 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="803387e9a63472a3287bdc2446032cf6e023e1d9" translate="yes" xml:space="preserve">
          <source>The index is a binary file (generally kept in &lt;code&gt;.git/index&lt;/code&gt;) containing a sorted list of path names, each with permissions and the SHA-1 of a blob object; &lt;a href=&quot;git-ls-files&quot;&gt;git-ls-files[1]&lt;/a&gt; can show you the contents of the index:</source>
          <target state="translated">인덱스는 경로 이름의 정렬 된 목록을 포함 하는 이진 파일 (일반적으로 &lt;code&gt;.git/index&lt;/code&gt; 로 유지됨 )이며 각각은 권한과 BLOB 개체의 SHA-1을 갖습니다. &lt;a href=&quot;git-ls-files&quot;&gt;git-ls-files [1]&lt;/a&gt; 은 인덱스의 내용을 보여줄 수 있습니다 :</target>
        </trans-unit>
        <trans-unit id="a9316182499a37d7c3626ac01aa8aab4c013b473" translate="yes" xml:space="preserve">
          <source>The index is also capable of storing multiple entries (called &quot;stages&quot;) for a given pathname. These stages are used to hold the various unmerged version of a file when a merge is in progress.</source>
          <target state="translated">색인은 또한 주어진 경로 이름에 대해 여러 항목 ( &quot;단계&quot;라고 함)을 저장할 수 있습니다. 이 단계는 병합이 진행될 때 병합되지 않은 다양한 버전의 파일을 보유하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="188f5a2d7cb942916f4771a1884b995e88b4142c" translate="yes" xml:space="preserve">
          <source>The index is thus a sort of temporary staging area, which is filled with a tree which you are in the process of working on.</source>
          <target state="translated">따라서 인덱스는 일종의 임시 준비 영역으로, 작업중인 트리로 채워져 있습니다.</target>
        </trans-unit>
        <trans-unit id="272f4c7f98ef3d0d8ac3fea3ee0b1455507c7b6c" translate="yes" xml:space="preserve">
          <source>The index is updated after successful completion, but the change must still be committed.</source>
          <target state="translated">성공적으로 완료 한 후에는 색인이 업데이트되지만 변경 사항은 계속 커밋해야합니다.</target>
        </trans-unit>
        <trans-unit id="aaf3f3d73cad6f7ed8d83d0912688100fa696756" translate="yes" xml:space="preserve">
          <source>The index line includes the blob object names before and after the change. The &amp;lt;mode&amp;gt; is included if the file mode does not change; otherwise, separate lines indicate the old and the new mode.</source>
          <target state="translated">색인 줄에는 변경 전후의 얼룩 개체 이름이 포함됩니다. 파일 모드가 변경되지 않으면 &amp;lt;mode&amp;gt;가 포함됩니다. 그렇지 않으면 별도의 줄이 이전 및 새 모드를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="0c2192b5aebec33a414387c35e4e32f7ffc2561e" translate="yes" xml:space="preserve">
          <source>The index may contain unmerged entries because of a previous failed merge. By default, if you try to check out such an entry from the index, the checkout operation will fail and nothing will be checked out. Using &lt;code&gt;-f&lt;/code&gt; will ignore these unmerged entries. The contents from a specific side of the merge can be checked out of the index by using &lt;code&gt;--ours&lt;/code&gt; or &lt;code&gt;--theirs&lt;/code&gt;. With &lt;code&gt;-m&lt;/code&gt;, changes made to the working tree file can be discarded to re-create the original conflicted merge result.</source>
          <target state="translated">이전에 실패한 병합으로 인해 색인에 병합되지 않은 항목이 포함될 수 있습니다. 기본적으로 색인에서 이러한 항목을 체크 아웃하려고하면 체크 아웃 조작이 실패하고 체크 아웃되지 않습니다. &lt;code&gt;-f&lt;/code&gt; 를 사용하면 병합되지 않은 항목은 무시됩니다. 병합의 특정 측면에있는 내용은 &lt;code&gt;--ours&lt;/code&gt; 또는 &lt;code&gt;--theirs&lt;/code&gt; 를 사용하여 색인에서 확인할 수 있습니다 . 함께 &lt;code&gt;-m&lt;/code&gt; , 다시 만들 원래 충돌 병합 결과에 폐기 될 수 작업 트리 파일에 변경합니다.</target>
        </trans-unit>
        <trans-unit id="4d0d51f29d49355316c3cef38c96a8eb5dfc2a8a" translate="yes" xml:space="preserve">
          <source>The index must be in a fully merged state.</source>
          <target state="translated">인덱스는 완전히 병합 된 상태 여야합니다.</target>
        </trans-unit>
        <trans-unit id="76af7fc7918327fcfae98949c1f8a57aa6273691" translate="yes" xml:space="preserve">
          <source>The information &lt;code&gt;git rerere&lt;/code&gt; records is also used when running &lt;code&gt;git rebase&lt;/code&gt;. After blowing away the test merge and continuing development on the topic branch:</source>
          <target state="translated">정보 &lt;code&gt;git rerere&lt;/code&gt; 레코드는 &lt;code&gt;git rebase&lt;/code&gt; 를 실행할 때도 사용됩니다 . 테스트 병합을 날려 버리고 주제 분기에서 개발을 계속 한 후 :</target>
        </trans-unit>
        <trans-unit id="15901a24c7f8cf8a87522005a6e5af387df87a55" translate="yes" xml:space="preserve">
          <source>The information regarding a particular file, stored in the &lt;a href=&quot;#def_index&quot;&gt;index&lt;/a&gt;. An index entry can be unmerged, if a &lt;a href=&quot;#def_merge&quot;&gt;merge&lt;/a&gt; was started, but not yet finished (i.e. if the index contains multiple versions of that file).</source>
          <target state="translated">&lt;a href=&quot;#def_index&quot;&gt;index에&lt;/a&gt; 저장된 특정 파일에 관한 정보 . &lt;a href=&quot;#def_merge&quot;&gt;병합&lt;/a&gt; 이 시작되었지만 아직 완료되지 않은 경우 (즉, 색인에 해당 파일의 여러 버전이 포함 된 경우) 색인 항목을 병합 해제 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="e1b41d54924f3d005ef481db0b83a44bcb5b9a26" translate="yes" xml:space="preserve">
          <source>The initial &lt;code&gt;git svn clone&lt;/code&gt; can be quite time-consuming (especially for large Subversion repositories). If multiple people (or one person with multiple machines) want to use &lt;code&gt;git svn&lt;/code&gt; to interact with the same Subversion repository, you can do the initial &lt;code&gt;git svn clone&lt;/code&gt; to a repository on a server and have each person clone that repository with &lt;code&gt;git clone&lt;/code&gt;:</source>
          <target state="translated">초기 &lt;code&gt;git svn clone&lt;/code&gt; 은 특히 ​​많은 Subversion 저장소의 경우 시간이 오래 걸릴 수 있습니다. 여러 사람 (또는 여러 시스템을 가진 한 사람)이 &lt;code&gt;git svn&lt;/code&gt; 을 사용하여 동일한 Subversion 저장소와 상호 작용 하려는 경우 초기 &lt;code&gt;git svn clone&lt;/code&gt; 를 서버의 저장소에 수행하고 각 사람이 해당 저장소를 &lt;code&gt;git clone&lt;/code&gt; 으로 복제하도록 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="086eba2d4da1f4350d7506d860bddbb6a3656718" translate="yes" xml:space="preserve">
          <source>The initial clone may be time-consuming for a large project, but you will only need to clone once.</source>
          <target state="translated">대규모 프로젝트의 경우 초기 복제에 시간이 오래 걸릴 수 있지만 한 번만 복제하면됩니다.</target>
        </trans-unit>
        <trans-unit id="de40e4660568a286f9924fcf84aa107b9295fcd9" translate="yes" xml:space="preserve">
          <source>The initial revision lays the foundation for almost everything Git has today, but is small enough to read in one sitting.</source>
          <target state="translated">초기 개정판은 오늘날 Git의 거의 모든 것을위한 토대를 마련하지만 한 번에 읽을 수있을 정도로 작습니다.</target>
        </trans-unit>
        <trans-unit id="c62040180edff3420ed3a70f2f1e520bccaa26ac" translate="yes" xml:space="preserve">
          <source>The insane thing. You really want to call the new version &quot;X&quot; too, &lt;code&gt;even though&lt;/code&gt; others have already seen the old one. So just use &lt;code&gt;git tag -f&lt;/code&gt; again, as if you hadn&amp;rsquo;t already published the old one.</source>
          <target state="translated">미친 것. 다른 사람들이 이미 이전 버전을 &lt;code&gt;even though&lt;/code&gt; 새 버전 &quot;X&quot;도 호출하려고합니다 . 따라서 이전 &lt;code&gt;git tag -f&lt;/code&gt; 아직 게시하지 않은 것처럼 git tag -f를 다시 사용 하십시오.</target>
        </trans-unit>
        <trans-unit id="861707a12241605e66eb9230fb32f3c54a08448e" translate="yes" xml:space="preserve">
          <source>The intent of this option is to pick and choose lines of the patch to apply, or even to modify the contents of lines to be staged. This can be quicker and more flexible than using the interactive hunk selector. However, it is easy to confuse oneself and create a patch that does not apply to the index. See EDITING PATCHES below.</source>
          <target state="translated">이 옵션의 목적은 적용 할 패치의 행을 선택하여 선택하거나 스테이징 할 행의 내용을 수정하는 것입니다. 이것은 대화식 덩어리 선택기를 사용하는 것보다 더 빠르고 유연 할 수 있습니다. 그러나 자신을 혼동하고 색인에 적용되지 않는 패치를 만드는 것은 쉽습니다. 아래의 패치 편집을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="44c76b656c6ccb35aba2b96c920b5e782121a3bc" translate="yes" xml:space="preserve">
          <source>The interactive backend drops commits by default that started empty and halts if it hits a commit that ended up empty. The &lt;code&gt;--keep-empty&lt;/code&gt; option exists for the interactive backend to allow it to keep commits that started empty.</source>
          <target state="translated">대화식 백엔드는 기본적으로 비어있는 시작된 커밋을 삭제하고 비어있는 커밋에 도달하면 중지됩니다. &lt;code&gt;--keep-empty&lt;/code&gt; 옵션은 빈 시작 커밋을 유지 할 수 있도록 대화 형 백엔드 존재합니다.</target>
        </trans-unit>
        <trans-unit id="c4d1b3aab1a5f39909af0bdb9766437575ff6138" translate="yes" xml:space="preserve">
          <source>The interactive mode is meant for this type of workflow:</source>
          <target state="translated">대화식 모드는 다음 유형의 워크 플로우에 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="bed5d62a356c4ef72d5d10899b110555c8810a69" translate="yes" xml:space="preserve">
          <source>The interactive rebase command was originally designed to handle individual patch series. As such, it makes sense to exclude merge commits from the todo list, as the developer may have merged the then-current &lt;code&gt;master&lt;/code&gt; while working on the branch, only to rebase all the commits onto &lt;code&gt;master&lt;/code&gt; eventually (skipping the merge commits).</source>
          <target state="translated">대화식 rebase 명령은 원래 개별 패치 시리즈를 처리하도록 설계되었습니다. 따라서, 그것은 개발자가 당시 합병 한 수 있으므로, 할 일 목록에서 병합 커밋을 제외하는 것이 합리적 &lt;code&gt;master&lt;/code&gt; 브랜치에서 작업하는 동안 단지 위에 모든 커밋 리베이스하는, &lt;code&gt;master&lt;/code&gt; (병합 커밋 생략) 결국합니다.</target>
        </trans-unit>
        <trans-unit id="54aff08446e09f30da133e329eb3f3646033c66c" translate="yes" xml:space="preserve">
          <source>The interactive rebase will stop when a command fails (i.e. exits with non-0 status) to give you an opportunity to fix the problem. You can continue with &lt;code&gt;git rebase --continue&lt;/code&gt;.</source>
          <target state="translated">명령이 실패하면 (예 : 0이 아닌 상태로 종료) 대화식 리베이스가 중지되어 문제를 해결할 수있는 기회를 제공합니다. &lt;code&gt;git rebase --continue&lt;/code&gt; 로 계속 진행할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="5a7f537099e4a0d8d8faba9c5e743d565b88b9dd" translate="yes" xml:space="preserve">
          <source>The interface (input, output, set of options and the semantics) to these low-level commands are meant to be a lot more stable than Porcelain level commands, because these commands are primarily for scripted use. The interface to Porcelain commands on the other hand are subject to change in order to improve the end user experience.</source>
          <target state="translated">이러한 하위 수준 명령에 대한 인터페이스 (입력, 출력, 옵션 집합 및 의미론)는 주로 스크립트 용도로 사용되므로 Porcelain 수준 명령보다 훨씬 안정적입니다. 반면에 Porcelain 명령에 대한 인터페이스는 최종 사용자 경험을 향상시키기 위해 변경 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="bf907bc1bbd0905aa866d8781057341315704641" translate="yes" xml:space="preserve">
          <source>The internal block size to use when converting a revision specifier such as &lt;code&gt;@all&lt;/code&gt; into a list of specific change numbers. Instead of using a single call to &lt;code&gt;p4 changes&lt;/code&gt; to find the full list of changes for the conversion, there are a sequence of calls to &lt;code&gt;p4 changes -m&lt;/code&gt;, each of which requests one block of changes of the given size. The default block size is 500, which should usually be suitable.</source>
          <target state="translated">&lt;code&gt;@all&lt;/code&gt; 과 같은 개정 지정자 를 특정 변경 번호 목록 으로 변환 할 때 사용할 내부 블록 크기 입니다. &lt;code&gt;p4 changes&lt;/code&gt; 에 대한 단일 호출을 사용 하여 변환에 대한 전체 변경 사항 목록을 찾는 대신 , &lt;code&gt;p4 changes -m&lt;/code&gt; 에 대한 호출 순서가 있습니다. 각 호출 은 지정된 크기의 한 변경 블록을 요청합니다. 기본 블록 크기는 500이며 일반적으로 적합합니다.</target>
        </trans-unit>
        <trans-unit id="b58ee91a98701b75ecd0edc6713c67b3efbc3330" translate="yes" xml:space="preserve">
          <source>The internals are documented in the &lt;a href=&quot;api-index&quot;&gt;Git API documentation&lt;/a&gt;.</source>
          <target state="translated">내부는 &lt;a href=&quot;api-index&quot;&gt;Git API 문서에 문서화되어&lt;/a&gt; 있습니다.</target>
        </trans-unit>
        <trans-unit id="051387312310d89e1f2cd1a7644ba37793a94a7c" translate="yes" xml:space="preserve">
          <source>The known attack vectors are as follows:</source>
          <target state="translated">알려진 공격 경로는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="d0880a7ce92ec68d75b7997f1b8b330766294029" translate="yes" xml:space="preserve">
          <source>The lack of a central group of &quot;committers&quot; means there is less need for formal decisions about who is &quot;in&quot; and who is &quot;out&quot;.</source>
          <target state="translated">중앙 집중된 &quot;커미터&quot;그룹이 없다는 것은 &quot;누가&quot;누가 &quot;누가&quot;있는지에 대한 공식적인 결정이 덜 필요하다는 것을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="d217f82f775261a888c8090d4fd57de90a2943db" translate="yes" xml:space="preserve">
          <source>The last diff is empty, but no new commits have been made, and the head still doesn&amp;rsquo;t contain the new line:</source>
          <target state="translated">마지막 diff는 비어 있지만 새로운 커밋은 없었으며 헤드에는 여전히 새로운 줄이 포함되어 있지 않습니다.</target>
        </trans-unit>
        <trans-unit id="fc6ae42476a6037281df209d5a37adfb042c084d" translate="yes" xml:space="preserve">
          <source>The last three commits (&lt;code&gt;HEAD&lt;/code&gt;, &lt;code&gt;HEAD^&lt;/code&gt;, and &lt;code&gt;HEAD~2&lt;/code&gt;) were bad and you do not want to ever see them again. Do &lt;strong&gt;not&lt;/strong&gt; do this if you have already given these commits to somebody else. (See the &quot;RECOVERING FROM UPSTREAM REBASE&quot; section in &lt;a href=&quot;git-rebase&quot;&gt;git-rebase[1]&lt;/a&gt; for the implications of doing so.)</source>
          <target state="translated">마지막 3 개의 커밋 ( &lt;code&gt;HEAD&lt;/code&gt; , &lt;code&gt;HEAD^&lt;/code&gt; 및 &lt;code&gt;HEAD~2&lt;/code&gt; )이 잘못되어 다시보고 싶지 않습니다. 마십시오 &lt;strong&gt;하지&lt;/strong&gt; 이미 다른 사람이 이러한 커밋을 제공 한 경우이 작업을 수행. ( 그렇게하는 의미에 대해서는 &lt;a href=&quot;git-rebase&quot;&gt;git-rebase [1]의&lt;/a&gt; &quot;UPSTREAM REBASE 복구&quot;섹션을 참조하십시오 .)</target>
        </trans-unit>
        <trans-unit id="9b2685798225cd4befed46a027cdbd30eb245ee2" translate="yes" xml:space="preserve">
          <source>The latest stash you created is stored in &lt;code&gt;refs/stash&lt;/code&gt;; older stashes are found in the reflog of this reference and can be named using the usual reflog syntax (e.g. &lt;code&gt;stash@{0}&lt;/code&gt; is the most recently created stash, &lt;code&gt;stash@{1}&lt;/code&gt; is the one before it, &lt;code&gt;stash@{2.hours.ago}&lt;/code&gt; is also possible). Stashes may also be referenced by specifying just the stash index (e.g. the integer &lt;code&gt;n&lt;/code&gt; is equivalent to &lt;code&gt;stash@{n}&lt;/code&gt;).</source>
          <target state="translated">생성 한 최신 숨김은 &lt;code&gt;refs/stash&lt;/code&gt; 에 저장됩니다 . 이전 스 &lt;code&gt;stash@{0}&lt;/code&gt; 는이 참조의 참조 로그에 있으며 일반적인 참조 로그 구문을 사용하여 이름을 지정할 수 있습니다 (예 : stash @ {0} 은 가장 최근에 생성 된 stash, &lt;code&gt;stash@{1}&lt;/code&gt; 은 그 이전의 &lt;code&gt;stash@{2.hours.ago}&lt;/code&gt; 도 가능합니다). 스 태시는 스 태시 인덱스 만 지정하여 참조 할 수도 있습니다 (예 : 정수 &lt;code&gt;n&lt;/code&gt; 은 &lt;code&gt;stash@{n}&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="8bb7601b8118e6905d96f76a29452df6bc2ae98e" translate="yes" xml:space="preserve">
          <source>The latter is not available by default, unless configured.</source>
          <target state="translated">구성되지 않으면 후자는 기본적으로 사용할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="9096be046e467fbce79d2a6fe63b310a7a8be174" translate="yes" xml:space="preserve">
          <source>The latter use of the &lt;code&gt;remote.&amp;lt;repository&amp;gt;.fetch&lt;/code&gt; values can be overridden by giving the &lt;code&gt;--refmap=&amp;lt;refspec&amp;gt;&lt;/code&gt; parameter(s) on the command line.</source>
          <target state="translated">후자의 &lt;code&gt;remote.&amp;lt;repository&amp;gt;.fetch&lt;/code&gt; 값 사용은 명령 행에 &lt;code&gt;--refmap=&amp;lt;refspec&amp;gt;&lt;/code&gt; 매개 변수 를 제공하여 대체 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="55ffd562f6b8b4abf7958d261df418cb81ead100" translate="yes" xml:space="preserve">
          <source>The length of time, in milliseconds, to retry when trying to lock an individual reference. Value 0 means not to retry at all; -1 means to try indefinitely. Default is 100 (i.e., retry for 100ms).</source>
          <target state="translated">개별 참조를 잠그려고 시도 할 때 재 시도하는 시간 (밀리 초)입니다. 값 0은 전혀 재 시도하지 않음을 의미합니다. -1은 무한정 시도하는 것을 의미합니다. 기본값은 100입니다 (즉, 100ms 동안 다시 시도).</target>
        </trans-unit>
        <trans-unit id="68a6d4f84896f5fe182696f59cffd1c668106a0a" translate="yes" xml:space="preserve">
          <source>The length of time, in milliseconds, to retry when trying to lock the &lt;code&gt;packed-refs&lt;/code&gt; file. Value 0 means not to retry at all; -1 means to try indefinitely. Default is 1000 (i.e., retry for 1 second).</source>
          <target state="translated">&lt;code&gt;packed-refs&lt;/code&gt; 파일 을 잠글 때 다시 시도하는 시간 (밀리 초) 입니다. 값 0은 전혀 재 시도하지 않음을 의미합니다. -1은 무한정 시도하는 것을 의미합니다. 기본값은 1000입니다 (즉, 1 초 동안 재시도).</target>
        </trans-unit>
        <trans-unit id="fff6cc41c6311b04938a1f36a103054a2f1d2e11" translate="yes" xml:space="preserve">
          <source>The list above is ordered by decreasing precedence; a URL that matches a config key&amp;rsquo;s path is preferred to one that matches its user name. For example, if the URL is &lt;code&gt;https://user@example.com/foo/bar&lt;/code&gt; a config key match of &lt;code&gt;https://example.com/foo&lt;/code&gt; will be preferred over a config key match of &lt;code&gt;https://user@example.com&lt;/code&gt;.</source>
          <target state="translated">위의 목록은 우선 순위를 낮추어 정렬됩니다. 구성 키의 경로와 일치하는 URL이 사용자 이름과 일치하는 URL보다 선호됩니다. 예를 들어 URL이 &lt;code&gt;https://user@example.com/foo/bar&lt;/code&gt; 인 경우 &lt;code&gt;https://example.com/foo&lt;/code&gt; 의 구성 키 일치가 &lt;code&gt;https://user@example.com&lt;/code&gt; 의 구성 키 일치보다 선호됩니다 . .com .</target>
        </trans-unit>
        <trans-unit id="34cf6a4a25da733f5b8366288a8f31ad385fa0ee" translate="yes" xml:space="preserve">
          <source>The list of identifiers, and other information, of the objects in a &lt;a href=&quot;#def_pack&quot;&gt;pack&lt;/a&gt;, to assist in efficiently accessing the contents of a pack.</source>
          <target state="translated">&lt;a href=&quot;#def_pack&quot;&gt;팩&lt;/a&gt; 의 내용에 효율적으로 액세스 할 수 있도록 팩 에있는 객체의 식별자 목록 및 기타 정보 입니다.</target>
        </trans-unit>
        <trans-unit id="58413b6422259538de8b3cfc5351841a4fb3ade2" translate="yes" xml:space="preserve">
          <source>The list of mailbox files to read patches from. If you do not supply this argument, the command reads from the standard input. If you supply directories, they will be treated as Maildirs.</source>
          <target state="translated">패치를 읽을 메일 함 파일 목록. 이 인수를 제공하지 않으면 명령이 표준 입력에서 읽습니다. 디렉토리를 제공하면 Maildirs로 취급됩니다.</target>
        </trans-unit>
        <trans-unit id="811a0eecf6c6689902c9fc1e00fe667f20b10132" translate="yes" xml:space="preserve">
          <source>The list of remotes which are fetched by &quot;git remote update &amp;lt;group&amp;gt;&quot;. See &lt;a href=&quot;git-remote&quot;&gt;git-remote[1]&lt;/a&gt;.</source>
          <target state="translated">&quot;git remote update &amp;lt;group&amp;gt;&quot;에 의해 페치 된 리모트 목록. &lt;a href=&quot;git-remote&quot;&gt;git-remote [1]을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="3aadf5969931435dfd81a576572d271c1b7df1e4" translate="yes" xml:space="preserve">
          <source>The list you get with &quot;ls&quot; :-)</source>
          <target state="translated">&quot;ls&quot;로 얻는 목록 :-)</target>
        </trans-unit>
        <trans-unit id="2d5bfecbee3eeb5c71f69bd43de88bc34222a07d" translate="yes" xml:space="preserve">
          <source>The local offset is specified by &lt;code&gt;&amp;lt;offutc&amp;gt;&lt;/code&gt; as a positive or negative offset from UTC. For example EST (which is 5 hours behind UTC) would be expressed in &lt;code&gt;&amp;lt;tz&amp;gt;&lt;/code&gt; by &amp;ldquo;-0500&amp;rdquo; while UTC is &amp;ldquo;+0000&amp;rdquo;. The local offset does not affect &lt;code&gt;&amp;lt;time&amp;gt;&lt;/code&gt;; it is used only as an advisement to help formatting routines display the timestamp.</source>
          <target state="translated">로컬 오프셋은 &lt;code&gt;&amp;lt;offutc&amp;gt;&lt;/code&gt; 에서 UTC의 양수 또는 음수 오프셋으로 지정됩니다 . 예를 들어 EST (UTC보다 5 시간 늦음)는 &lt;code&gt;&amp;lt;tz&amp;gt;&lt;/code&gt; 에서 &quot;-0500&quot;으로 표시되고 UTC는 &quot;+0000&quot;으로 표시됩니다. 로컬 오프셋은 &lt;code&gt;&amp;lt;time&amp;gt;&lt;/code&gt; 에 영향을 미치지 않습니다 . 형식화 루틴이 시간 소인을 표시하는 것을 돕기위한 조언으로 만 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="ab508d82c7d8a4545e2bb32ec9ec4fb2386a14cb" translate="yes" xml:space="preserve">
          <source>The location of an augmenting mailmap file. The default mailmap, located in the root of the repository, is loaded first, then the mailmap file pointed to by this variable. The location of the mailmap file may be in a repository subdirectory, or somewhere outside of the repository itself. See &lt;a href=&quot;git-shortlog&quot;&gt;git-shortlog[1]&lt;/a&gt; and &lt;a href=&quot;git-blame&quot;&gt;git-blame[1]&lt;/a&gt;.</source>
          <target state="translated">기능 보강 메일 맵 파일의 위치입니다. 저장소의 루트에있는 기본 메일 맵이 먼저로드 된 다음이 변수가 가리키는 메일 맵 파일입니다. 메일 맵 파일의 위치는 저장소 하위 디렉토리에 있거나 저장소 자체 외부에있을 수 있습니다. 참조 &lt;a href=&quot;git-shortlog&quot;&gt;자식-shortlog [1]&lt;/a&gt; 와 &lt;a href=&quot;git-blame&quot;&gt;자식 비난 [1]&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="d3bb0979c637e06c575b3f731f106ded5d4b916f" translate="yes" xml:space="preserve">
          <source>The location of per-instance and system-wide configuration files can be overridden using the following environment variables:</source>
          <target state="translated">인스턴스 별 및 시스템 전체 구성 파일의 위치는 다음 환경 변수를 사용하여 재정의 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9446c1e5cce4b2ece4fc10ff79540962e21c6551" translate="yes" xml:space="preserve">
          <source>The magic word &lt;code&gt;top&lt;/code&gt; (magic signature: &lt;code&gt;/&lt;/code&gt;) makes the pattern match from the root of the working tree, even when you are running the command from inside a subdirectory.</source>
          <target state="translated">magic word &lt;code&gt;top&lt;/code&gt; (magic signature : &lt;code&gt;/&lt;/code&gt; )은 하위 디렉토리 내부에서 명령을 실행하는 경우에도 작업 트리의 루트에서 패턴을 일치시킵니다.</target>
        </trans-unit>
        <trans-unit id="64ba77ac0581cbecc6b691422d0c5681817b2387" translate="yes" xml:space="preserve">
          <source>The main command loop has 6 subcommands (plus help and quit).</source>
          <target state="translated">기본 명령 루프에는 6 개의 하위 명령이 있습니다 (도움말 및 종료).</target>
        </trans-unit>
        <trans-unit id="0b0bee129956915b1cb776d4190a01b55932ed3c" translate="yes" xml:space="preserve">
          <source>The main command loop has 6 subcommands.</source>
          <target state="translated">기본 명령 루프에는 6 개의 하위 명령이 있습니다.</target>
        </trans-unit>
        <trans-unit id="821ddd85eba2b4bc6e95a82521b10b32287622db" translate="yes" xml:space="preserve">
          <source>The main trunk is stored in the Git branch named &lt;code&gt;origin&lt;/code&gt;, and additional CVS branches are stored in Git branches with the same names. The most recent version of the main trunk is also left checked out on the &lt;code&gt;master&lt;/code&gt; branch, so you can start adding your own changes right away.</source>
          <target state="translated">기본 트렁크는 &lt;code&gt;origin&lt;/code&gt; 이라는 Git 브랜치에 저장 되고 추가 CVS 브랜치는 동일한 이름의 Git 브랜치에 저장됩니다. 기본 트렁크의 최신 버전도 &lt;code&gt;master&lt;/code&gt; 브랜치에서 체크 아웃 된 상태로 유지 되므로 직접 변경 사항을 추가 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f31023370321849385c22bc8ae521136bfffac45" translate="yes" xml:space="preserve">
          <source>The mapping of file names from the p4 depot path to Git, by default, involves removing the entire depot path. With this option, the full p4 depot path is retained in Git. For example, path &lt;code&gt;//depot/main/foo/bar.c&lt;/code&gt;, when imported from &lt;code&gt;//depot/main/&lt;/code&gt;, becomes &lt;code&gt;foo/bar.c&lt;/code&gt;. With &lt;code&gt;--keep-path&lt;/code&gt;, the Git path is instead &lt;code&gt;depot/main/foo/bar.c&lt;/code&gt;.</source>
          <target state="translated">기본적으로 p4 저장소 경로에서 Git으로 파일 이름을 맵핑하려면 전체 저장소 경로를 제거해야합니다. 이 옵션을 사용하면 전체 p4 저장소 경로가 Git에 유지됩니다. 예를 들어 &lt;code&gt;//depot/main/&lt;/code&gt; 에서 가져올 때 &lt;code&gt;//depot/main/foo/bar.c&lt;/code&gt; 경로 는 &lt;code&gt;foo/bar.c&lt;/code&gt; 가 됩니다. &lt;code&gt;--keep-path&lt;/code&gt; 사용 하면 Git 경로는 &lt;code&gt;depot/main/foo/bar.c&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="696795b724c116f40755fe0ffd2f815f95c8f529" translate="yes" xml:space="preserve">
          <source>The mark command is optional here as some frontends have chosen to generate the Git SHA-1 for the blob on their own, and feed that directly to &lt;code&gt;commit&lt;/code&gt;. This is typically more work than it&amp;rsquo;s worth however, as marks are inexpensive to store and easy to use.</source>
          <target state="translated">mark 명령은 여기서 일부 프론트 엔드가 자체적으로 Blob에 대한 Git SHA-1을 생성하고이를 직접 &lt;code&gt;commit&lt;/code&gt; 하도록 공급하므로 선택 사항 입니다. 마크는 저장 비용이 저렴하고 사용하기 쉽기 때문에 일반적으로 가치보다 더 많은 작업입니다.</target>
        </trans-unit>
        <trans-unit id="154d6f76415eae422478f55f25c1ddb853a4e1ab" translate="yes" xml:space="preserve">
          <source>The maximum delta depth used by &lt;a href=&quot;git-pack-objects&quot;&gt;git-pack-objects[1]&lt;/a&gt; when no maximum depth is given on the command line. Defaults to 50. Maximum value is 4095.</source>
          <target state="translated">명령 행에 최대 깊이가 지정되지 않은 경우 &lt;a href=&quot;git-pack-objects&quot;&gt;git-pack-objects [1]에서&lt;/a&gt; 사용하는 최대 델타 깊이 . 기본값은 50입니다. 최대 값은 4095입니다.</target>
        </trans-unit>
        <trans-unit id="9325da9117f9b4afd884e4f7e837bf9ca641172e" translate="yes" xml:space="preserve">
          <source>The maximum memory in bytes used for caching deltas in &lt;a href=&quot;git-pack-objects&quot;&gt;git-pack-objects[1]&lt;/a&gt; before writing them out to a pack. This cache is used to speed up the writing object phase by not having to recompute the final delta result once the best match for all objects is found. Repacking large repositories on machines which are tight with memory might be badly impacted by this though, especially if this cache pushes the system into swapping. A value of 0 means no limit. The smallest size of 1 byte may be used to virtually disable this cache. Defaults to 256 MiB.</source>
          <target state="translated">&lt;a href=&quot;git-pack-objects&quot;&gt;git-pack-objects [1]&lt;/a&gt; 에서 델타를 팩에 쓰기 전에 캐싱하는 데 사용되는 최대 메모리 (바이트) 입니다. 이 캐시는 모든 객체에 대해 가장 일치하는 것이 발견되면 최종 델타 결과를 다시 계산하지 않아도되므로 쓰기 객체 단계를 가속화하는 데 사용됩니다. 메모리가 부족한 머신에서 큰 리포지토리를 다시 패키징하면 특히 캐시가 시스템을 스왑으로 푸시 할 경우 이로 인해 영향을받을 수 있습니다. 값이 0이면 제한이 없음을 의미합니다. 이 캐시를 사실상 비활성화하는 데 가장 작은 1 바이트 크기를 사용할 수 있습니다. 기본값은 256MiB입니다.</target>
        </trans-unit>
        <trans-unit id="a0015a1c1a155cb39bc99dd58a785f6e45fb6909" translate="yes" xml:space="preserve">
          <source>The maximum size of a delta, that is cached in &lt;a href=&quot;git-pack-objects&quot;&gt;git-pack-objects[1]&lt;/a&gt;. This cache is used to speed up the writing object phase by not having to recompute the final delta result once the best match for all objects is found. Defaults to 1000. Maximum value is 65535.</source>
          <target state="translated">델타의 최대 크기는 &lt;a href=&quot;git-pack-objects&quot;&gt;git-pack-objects [1]에&lt;/a&gt; 캐시됩니다 . 이 캐시는 모든 객체에 대해 가장 일치하는 것이 발견되면 최종 델타 결과를 다시 계산하지 않아도되므로 쓰기 객체 단계를 가속화하는 데 사용됩니다. 기본값은 1000입니다. 최대 값은 65535입니다.</target>
        </trans-unit>
        <trans-unit id="d2696797b76aad16406d56dd354feaf085869327" translate="yes" xml:space="preserve">
          <source>The maximum size of a pack. This setting only affects packing to a file when repacking, i.e. the git:// protocol is unaffected. It can be overridden by the &lt;code&gt;--max-pack-size&lt;/code&gt; option of &lt;a href=&quot;git-repack&quot;&gt;git-repack[1]&lt;/a&gt;. Reaching this limit results in the creation of multiple packfiles; which in turn prevents bitmaps from being created. The minimum size allowed is limited to 1 MiB. The default is unlimited. Common unit suffixes of &lt;code&gt;k&lt;/code&gt;, &lt;code&gt;m&lt;/code&gt;, or &lt;code&gt;g&lt;/code&gt; are supported.</source>
          <target state="translated">팩의 최대 크기입니다. 이 설정은 재 포장 할 때 파일로의 압축에만 영향을 미칩니다. 즉, git : // 프로토콜은 영향을받지 않습니다. &lt;a href=&quot;git-repack&quot;&gt;git-repack [1]&lt;/a&gt; 의 &lt;code&gt;--max-pack-size&lt;/code&gt; 옵션 으로 덮어 쓸 수 있습니다 . 이 한계에 도달하면 여러 팩 파일이 작성됩니다. 비트 맵이 생성되는 것을 방지합니다. 허용되는 최소 크기는 1MiB로 제한됩니다. 기본값은 무제한입니다. &lt;code&gt;k&lt;/code&gt; , &lt;code&gt;m&lt;/code&gt; 또는 &lt;code&gt;g&lt;/code&gt; 의 공통 단위 접미사 가 지원됩니다.</target>
        </trans-unit>
        <trans-unit id="bb8ed32c533714ca4a8bb85ec574c3c5791f3a2f" translate="yes" xml:space="preserve">
          <source>The maximum size of memory that is consumed by each thread in &lt;a href=&quot;git-pack-objects&quot;&gt;git-pack-objects[1]&lt;/a&gt; for pack window memory when no limit is given on the command line. The value can be suffixed with &quot;k&quot;, &quot;m&quot;, or &quot;g&quot;. When left unconfigured (or set explicitly to 0), there will be no limit.</source>
          <target state="translated">명령 행에 제한이없는 경우 팩 창 메모리에 대해 &lt;a href=&quot;git-pack-objects&quot;&gt;git-pack-objects [1]의&lt;/a&gt; 각 스레드가 소비하는 최대 메모리 크기입니다 . 값은 &quot;k&quot;, &quot;m&quot;또는 &quot;g&quot;로 접미사를 붙일 수 있습니다. 구성되지 않은 상태로 두거나 명시 적으로 0으로 설정하면 제한이 없습니다.</target>
        </trans-unit>
        <trans-unit id="565cc584b68c5b675a716ec7daae7fd9f3343784" translate="yes" xml:space="preserve">
          <source>The meaning of each part of feature configuration is described below:</source>
          <target state="translated">기능 구성의 각 부분의 의미는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="657f593653b8985b76ea363799992d9ccd8552d1" translate="yes" xml:space="preserve">
          <source>The merge driver can learn the pathname in which the merged result will be stored via placeholder &lt;code&gt;%P&lt;/code&gt;.</source>
          <target state="translated">병합 드라이버는 자리 표시 자 &lt;code&gt;%P&lt;/code&gt; 를 통해 병합 된 결과가 저장 될 경로 이름을 알 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="3a4ee88dc1fd419e5903b5a6b97383e8c2a1fab9" translate="yes" xml:space="preserve">
          <source>The merge driver is expected to leave the result of the merge in the file named with &lt;code&gt;%A&lt;/code&gt; by overwriting it, and exit with zero status if it managed to merge them cleanly, or non-zero if there were conflicts.</source>
          <target state="translated">병합 드라이버는 병합 결과를 &lt;code&gt;%A&lt;/code&gt; 로 이름이 지정된 파일 에 겹쳐 써서 그대로두고, 완전히 병합 할 경우 상태가 0으로, 충돌이있는 경우 0이 아닌 상태로 종료됩니다.</target>
        </trans-unit>
        <trans-unit id="d39522f0982abae4a359335f63ed088d0f4a4c4e" translate="yes" xml:space="preserve">
          <source>The merge mechanism (&lt;code&gt;git merge&lt;/code&gt; and &lt;code&gt;git pull&lt;/code&gt; commands) allows the backend &lt;code&gt;merge strategies&lt;/code&gt; to be chosen with &lt;code&gt;-s&lt;/code&gt; option. Some strategies can also take their own options, which can be passed by giving &lt;code&gt;-X&amp;lt;option&amp;gt;&lt;/code&gt; arguments to &lt;code&gt;git merge&lt;/code&gt; and/or &lt;code&gt;git pull&lt;/code&gt;.</source>
          <target state="translated">병합 메커니즘 ( &lt;code&gt;git merge&lt;/code&gt; 및 &lt;code&gt;git pull&lt;/code&gt; 명령)을 사용하면 백엔드 &lt;code&gt;merge strategies&lt;/code&gt; 을 &lt;code&gt;-s&lt;/code&gt; 옵션 으로 선택할 수 있습니다 . 일부 전략은 자체 옵션을 사용할 수도 있습니다.이 &lt;code&gt;-X&amp;lt;option&amp;gt;&lt;/code&gt; 은 &lt;code&gt;git merge&lt;/code&gt; 및 / 또는 &lt;code&gt;git pull&lt;/code&gt; 에-X &amp;lt;option&amp;gt; 인수를 제공하여 전달할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="fa594438c3581495b74bb79c047cb66382bd8b0d" translate="yes" xml:space="preserve">
          <source>The merge workflow works by copying branches between upstream and downstream. Upstream can merge contributions into the official history; downstream base their work on the official history.</source>
          <target state="translated">병합 워크 플로는 업스트림과 다운 스트림간에 분기를 복사하여 작동합니다. 업스트림은 기여를 공식 역사에 병합 할 수 있습니다. 공식적인 역사를 바탕으로 작업을 진행합니다.</target>
        </trans-unit>
        <trans-unit id="1df107645dfce75dc8613a8a0f6007cf8381d780" translate="yes" xml:space="preserve">
          <source>The merge-base command finds a common ancestor of the given commits, and always returns one or the other in the case where one is a descendant of the other; so the above output shows that e05db0fd actually is an ancestor of v1.5.0-rc1.</source>
          <target state="translated">merge-base 명령은 주어진 커밋의 공통 조상을 찾고 하나가 다른 하나의 자손 인 경우 항상 하나 또는 다른 하나를 반환합니다. 위의 출력은 e05db0fd가 실제로 v1.5.0-rc1의 조상임을 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="19f5c4372c6fc154ead993a9f4b5a82da922524d" translate="yes" xml:space="preserve">
          <source>The message taken from file with &lt;code&gt;-F&lt;/code&gt; and command line with &lt;code&gt;-m&lt;/code&gt; are usually used as the tag message unmodified. This option lets you further edit the message taken from these sources.</source>
          <target state="translated">&lt;code&gt;-F&lt;/code&gt; 를 사용하여 파일에서 가져온 메시지 와 &lt;code&gt;-m&lt;/code&gt; 을 사용하는 명령 행 은 일반적으로 수정되지 않은 태그 메시지로 사용됩니다. 이 옵션을 사용하면 이러한 소스에서 가져온 메시지를 추가로 편집 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1e2b72f6afed427d21f4e345d320e470730d82f9" translate="yes" xml:space="preserve">
          <source>The message taken from file with &lt;code&gt;-F&lt;/code&gt;, command line with &lt;code&gt;-m&lt;/code&gt;, and from commit object with &lt;code&gt;-C&lt;/code&gt; are usually used as the commit log message unmodified. This option lets you further edit the message taken from these sources.</source>
          <target state="translated">&lt;code&gt;-F&lt;/code&gt; 로 파일에서 , &lt;code&gt;-m&lt;/code&gt; 으로 명령 행 및 &lt;code&gt;-C&lt;/code&gt; 로 커미트 오브젝트에서 가져온 메시지는 일반적으로 수정되지 않은 커미트 로그 메시지로 사용됩니다. 이 옵션을 사용하면 이러한 소스에서 가져온 메시지를 추가로 편집 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ae16f65784862fd6e529b736650355763df13327" translate="yes" xml:space="preserve">
          <source>The method by which a submodule is updated by &lt;code&gt;git submodule update&lt;/code&gt;, which is the only affected command, others such as &lt;code&gt;git checkout --recurse-submodules&lt;/code&gt; are unaffected. It exists for historical reasons, when &lt;code&gt;git submodule&lt;/code&gt; was the only command to interact with submodules; settings like &lt;code&gt;submodule.active&lt;/code&gt; and &lt;code&gt;pull.rebase&lt;/code&gt; are more specific. It is populated by &lt;code&gt;git submodule init&lt;/code&gt; from the &lt;a href=&quot;gitmodules&quot;&gt;gitmodules[5]&lt;/a&gt; file. See description of &lt;code&gt;update&lt;/code&gt; command in &lt;a href=&quot;git-submodule&quot;&gt;git-submodule[1]&lt;/a&gt;.</source>
          <target state="translated">영향을받는 유일한 명령 인 &lt;code&gt;git submodule update&lt;/code&gt; 에 의해 서브 모듈이 업데이트되는 방법 은 &lt;code&gt;git checkout --recurse-submodules&lt;/code&gt; 와 같은 다른 영향을받지 않습니다. &lt;code&gt;git submodule&lt;/code&gt; 이 하위 모듈과 상호 작용하는 유일한 명령이었던 역사적인 이유가 있습니다 . &lt;code&gt;submodule.active&lt;/code&gt; 및 &lt;code&gt;pull.rebase&lt;/code&gt; 와 같은 설정 이 더 구체적입니다. &lt;a href=&quot;gitmodules&quot;&gt;gitmodules [5]&lt;/a&gt; 파일 에서 &lt;code&gt;git submodule init&lt;/code&gt; 로 채워집니다 . &lt;a href=&quot;git-submodule&quot;&gt;git-submodule [1]&lt;/a&gt; 의 &lt;code&gt;update&lt;/code&gt; 명령에 대한 설명을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="04ef06b50b9899f38b1e5f5c81eb00396b6d2328" translate="yes" xml:space="preserve">
          <source>The mode parameter is optional (defaults to &lt;code&gt;all&lt;/code&gt;), and is used to specify the handling of untracked files; when -u is not used, the default is &lt;code&gt;normal&lt;/code&gt;, i.e. show untracked files and directories.</source>
          <target state="translated">mode 매개 변수는 선택 사항이며 (기본값은 &lt;code&gt;all&lt;/code&gt; ) 추적되지 않은 파일 처리를 지정하는 데 사용됩니다. -u를 사용하지 않으면 기본값은 &lt;code&gt;normal&lt;/code&gt; 입니다 (예 : 추적되지 않은 파일 및 디렉토리 표시).</target>
        </trans-unit>
        <trans-unit id="daee71f2e966cf5f390a0401b9f0381f1242178c" translate="yes" xml:space="preserve">
          <source>The mode parameter is used to specify the handling of ignored files. It is optional: it defaults to &lt;code&gt;traditional&lt;/code&gt;.</source>
          <target state="translated">mode 매개 변수는 무시 된 파일 처리를 지정하는 데 사용됩니다. 선택 사항입니다. 기본값은 &lt;code&gt;traditional&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="789771a80f50eaf70002a855307c4e88ea3d25bd" translate="yes" xml:space="preserve">
          <source>The mode parameter is used to specify the handling of untracked files. It is optional: it defaults to &lt;code&gt;all&lt;/code&gt;, and if specified, it must be stuck to the option (e.g. &lt;code&gt;-uno&lt;/code&gt;, but not &lt;code&gt;-u no&lt;/code&gt;).</source>
          <target state="translated">mode 매개 변수는 추적되지 않은 파일 처리를 지정하는 데 사용됩니다. 에 기본값 : 그것은 선택 사항입니다 &lt;code&gt;all&lt;/code&gt; , 지정된 경우,이 옵션에 붙어 있어야합니다 (예 : &lt;code&gt;-uno&lt;/code&gt; ,하지만 &lt;code&gt;-u no&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="d56062b3fd6eee94e49e5896b7d127ee25df01a1" translate="yes" xml:space="preserve">
          <source>The modifications stashed away by this command can be listed with &lt;code&gt;git stash list&lt;/code&gt;, inspected with &lt;code&gt;git stash show&lt;/code&gt;, and restored (potentially on top of a different commit) with &lt;code&gt;git stash apply&lt;/code&gt;. Calling &lt;code&gt;git stash&lt;/code&gt; without any arguments is equivalent to &lt;code&gt;git stash push&lt;/code&gt;. A stash is by default listed as &quot;WIP on &lt;code&gt;branchname&lt;/code&gt; &amp;hellip;​&quot;, but you can give a more descriptive message on the command line when you create one.</source>
          <target state="translated">이 명령으로 &lt;code&gt;git stash list&lt;/code&gt; 된 수정 사항은 git stash list 로 나열하고 git &lt;code&gt;git stash show&lt;/code&gt; 검사 하고 &lt;code&gt;git stash apply&lt;/code&gt; 로 잠재적으로 다른 커밋 위에 복원 할 수 있습니다 . 인수없이 &lt;code&gt;git stash&lt;/code&gt; 를 호출 하는 것은 &lt;code&gt;git stash push&lt;/code&gt; 와 같습니다 . 감춰는 &quot;에 WIP로 나열 디폴트로 &lt;code&gt;branchname&lt;/code&gt; ...&quot;하지만, 당신이 하나를 만들 때 명령 행에 더 자세한 설명 메시지를 제공 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e06fa83026ee56ec3b62a659fa5a44c6e4e4728d" translate="yes" xml:space="preserve">
          <source>The module path (only needed if httpd is Apache). (Default: /usr/lib/apache2/modules)</source>
          <target state="translated">모듈 경로 (httpd가 Apache 인 경우에만 필요) (기본값 : / usr / lib / apache2 / modules)</target>
        </trans-unit>
        <trans-unit id="08ed4170506fa174e84f549a0e3f26086c486529" translate="yes" xml:space="preserve">
          <source>The more complex forms are:</source>
          <target state="translated">더 복잡한 형태는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="7d735293dee944ca58932a7261110828d307c793" translate="yes" xml:space="preserve">
          <source>The most common cause of dangling objects is that you&amp;rsquo;ve rebased a branch, or you have pulled from somebody else who rebased a branch&amp;mdash;​see &lt;a href=&quot;#cleaning-up-history&quot;&gt;Rewriting history and maintaining patch series&lt;/a&gt;. In that case, the old head of the original branch still exists, as does everything it pointed to. The branch pointer itself just doesn&amp;rsquo;t, since you replaced it with another one.</source>
          <target state="translated">매달린 오브젝트의 가장 일반적인 원인은 브랜치를 리베이스했거나 브랜치를 리베이스 한 다른 사람으로부터 가져온 것입니다 . &lt;a href=&quot;#cleaning-up-history&quot;&gt;히스토리 다시 작성 및 패치 시리즈 유지 보수를&lt;/a&gt; 참조하십시오 . 이 경우 원래 브랜치의 오래된 헤드는 여전히 똑같이 존재합니다. 분기 포인터 자체는 다른 포인터로 대체 되었기 때문에 그렇지 않습니다.</target>
        </trans-unit>
        <trans-unit id="8bc143dd44c89f63596943262174b04211332773" translate="yes" xml:space="preserve">
          <source>The multi-pack-index (MIDX for short) stores a list of objects and their offsets into multiple packfiles. It contains:</source>
          <target state="translated">다중 팩 인덱스 (MIDX)는 객체 목록과 해당 오프셋을 여러 팩 파일에 저장합니다. 그것은 포함합니다 :</target>
        </trans-unit>
        <trans-unit id="4ca15f678a55a1443f2d701a54958e45ad8a0235" translate="yes" xml:space="preserve">
          <source>The multi-pack-index allows many packfiles, especially in a context where repacking is expensive (such as a very large repo), or unexpected maintenance time is unacceptable (such as a high-demand build machine). However, the multi-pack-index needs to be rewritten in full every time. We can extend the format to be incremental, so writes are fast. By storing a small &quot;tip&quot; multi-pack-index that points to large &quot;base&quot; MIDX files, we can keep writes fast while still reducing the number of binary searches required for object lookups.</source>
          <target state="translated">다중 팩 색인은 특히 재 포장이 비싸거나 (예 : 매우 큰 리포지토리) 예상치 못한 유지 보수 시간이 수용 할 수없는 상황 (예 : 수요가 많은 빌드 머신)에서 많은 팩 파일을 허용합니다. 그러나 다중 팩 인덱스는 매번 다시 작성해야합니다. 형식을 증분으로 확장 할 수 있으므로 쓰기 속도가 빠릅니다. 큰 &quot;기본&quot;MIDX 파일을 가리키는 작은 &quot;팁&quot;다중 팩 인덱스를 저장하면 객체 조회에 필요한 이진 검색 수를 줄이면서 빠르게 기록을 유지할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d98c840529f1ab7c2fa3df48a823219f4ff9a17e" translate="yes" xml:space="preserve">
          <source>The multi-pack-index files refer to multiple pack-files and loose objects.</source>
          <target state="translated">다중 팩 인덱스 파일은 다중 팩 파일 및 느슨한 객체를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="1e0c8af9211e361d1a35789c37df84247f7ae9ac" translate="yes" xml:space="preserve">
          <source>The name and the e-mail address of the owner of the key that signed the push certificate.</source>
          <target state="translated">푸시 인증서에 서명 한 키 소유자의 이름 및 이메일 주소입니다.</target>
        </trans-unit>
        <trans-unit id="2551d22d5e60fb51293e5ef827d3f2d640624d55" translate="yes" xml:space="preserve">
          <source>The name of a commit at which to start the new branch; see &lt;a href=&quot;git-branch&quot;&gt;git-branch[1]&lt;/a&gt; for details. Defaults to &lt;code&gt;HEAD&lt;/code&gt;.</source>
          <target state="translated">새 브랜치를 시작할 커밋의 이름. 자세한 내용은 &lt;a href=&quot;git-branch&quot;&gt;git-branch [1]&lt;/a&gt; 을 참조하십시오. 기본값은 &lt;code&gt;HEAD&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="0efd5464958e1be85e38672256be6f6e17bc462a" translate="yes" xml:space="preserve">
          <source>The name of a local ref which can be considered &amp;ldquo;upstream&amp;rdquo; from the displayed ref. Respects &lt;code&gt;:short&lt;/code&gt;, &lt;code&gt;:lstrip&lt;/code&gt; and &lt;code&gt;:rstrip&lt;/code&gt; in the same way as &lt;code&gt;refname&lt;/code&gt; above. Additionally respects &lt;code&gt;:track&lt;/code&gt; to show &quot;[ahead N, behind M]&quot; and &lt;code&gt;:trackshort&lt;/code&gt; to show the terse version: &quot;&amp;gt;&quot; (ahead), &quot;&amp;lt;&quot; (behind), &quot;&amp;lt;&amp;gt;&quot; (ahead and behind), or &quot;=&quot; (in sync). &lt;code&gt;:track&lt;/code&gt; also prints &quot;[gone]&quot; whenever unknown upstream ref is encountered. Append &lt;code&gt;:track,nobracket&lt;/code&gt; to show tracking information without brackets (i.e &quot;ahead N, behind M&quot;).</source>
          <target state="translated">표시된 참조에서 &quot;업스트림&quot;으로 간주 될 수있는 로컬 참조의 이름입니다. 위의 &lt;code&gt;refname&lt;/code&gt; 과 같은 방식으로 &lt;code&gt;:short&lt;/code&gt; , &lt;code&gt;:lstrip&lt;/code&gt; 및 &lt;code&gt;:rstrip&lt;/code&gt; 을 존중 합니다. 또한 &lt;code&gt;:track&lt;/code&gt; 은 &quot;[ahead N, behind M]&quot; 을 표시 하고 &lt;code&gt;:trackshort&lt;/code&gt; 는 &quot;&amp;gt;&quot;(ahead), &quot;&amp;lt;&quot;(behind), &quot;&amp;lt;&amp;gt;&quot;(ahead and behind) 또는 &quot; = &quot;(동기화). &lt;code&gt;:track&lt;/code&gt; 은 알 수없는 업스트림 참조가 발생할 때마다 &quot;[gone]&quot;을 인쇄합니다. Append &lt;code&gt;:track,nobracket&lt;/code&gt; 은 대괄호없이 추적 정보를 표시합니다 (예 : &quot;M 뒤에 M&quot;).</target>
        </trans-unit>
        <trans-unit id="285243cf13ade280f7038dfb92bbdaa7d26dec36" translate="yes" xml:space="preserve">
          <source>The name of a local ref which represents the &lt;code&gt;@{push}&lt;/code&gt; location for the displayed ref. Respects &lt;code&gt;:short&lt;/code&gt;, &lt;code&gt;:lstrip&lt;/code&gt;, &lt;code&gt;:rstrip&lt;/code&gt;, &lt;code&gt;:track&lt;/code&gt;, &lt;code&gt;:trackshort&lt;/code&gt;, &lt;code&gt;:remotename&lt;/code&gt;, and &lt;code&gt;:remoteref&lt;/code&gt; options as &lt;code&gt;upstream&lt;/code&gt; does. Produces an empty string if no &lt;code&gt;@{push}&lt;/code&gt; ref is configured.</source>
          <target state="translated">표시된 참조 의 &lt;code&gt;@{push}&lt;/code&gt; 위치를 나타내는 로컬 참조의 이름입니다 . 존중 &lt;code&gt;:short&lt;/code&gt; , &lt;code&gt;:lstrip&lt;/code&gt; , &lt;code&gt;:rstrip&lt;/code&gt; , &lt;code&gt;:track&lt;/code&gt; , &lt;code&gt;:trackshort&lt;/code&gt; , &lt;code&gt;:remotename&lt;/code&gt; , 그리고 &lt;code&gt;:remoteref&lt;/code&gt; 같은 옵션 &lt;code&gt;upstream&lt;/code&gt; 않습니다. &lt;code&gt;@{push}&lt;/code&gt; 참조가 구성 되지 않은 경우 빈 문자열을 생성 합니다.</target>
        </trans-unit>
        <trans-unit id="25973fbcb02049e23787d52ffa23363b0665166c" translate="yes" xml:space="preserve">
          <source>The name of a new directory to clone into. The &quot;humanish&quot; part of the source repository is used if no directory is explicitly given (&lt;code&gt;repo&lt;/code&gt; for &lt;code&gt;/path/to/repo.git&lt;/code&gt; and &lt;code&gt;foo&lt;/code&gt; for &lt;code&gt;host.xz:foo/.git&lt;/code&gt;). Cloning into an existing directory is only allowed if the directory is empty.</source>
          <target state="translated">복제 할 새 디렉토리의 이름입니다. 어떤 디렉토리이 명시 적으로 지정되지 않는 경우, 소스 저장소의 &quot;humanish&quot;부분이 사용됩니다 ( &lt;code&gt;repo&lt;/code&gt; 에 대한 &lt;code&gt;/path/to/repo.git&lt;/code&gt; 및 &lt;code&gt;foo&lt;/code&gt; 에 대한 &lt;code&gt;host.xz:foo/.git&lt;/code&gt; ). 기존 디렉토리로의 복제는 디렉토리가 비어있는 경우에만 허용됩니다.</target>
        </trans-unit>
        <trans-unit id="3c836d4cc86fbcc3a897aa8fab973465c40a1899" translate="yes" xml:space="preserve">
          <source>The name of an existing branch already in fast-import&amp;rsquo;s internal branch table. If fast-import doesn&amp;rsquo;t know the name, it&amp;rsquo;s treated as a SHA-1 expression.</source>
          <target state="translated">이미 빠른 가져 오기의 내부 분기 테이블에있는 기존 분기의 이름입니다. 빠른 가져 오기에서 이름을 모르면 SHA-1 표현식으로 처리됩니다.</target>
        </trans-unit>
        <trans-unit id="c21a579b2f8550495cd7f286a4f77b45b3df2f6e" translate="yes" xml:space="preserve">
          <source>The name of an existing branch to rename.</source>
          <target state="translated">이름을 바꿀 기존 지점의 이름입니다.</target>
        </trans-unit>
        <trans-unit id="b35cfa9e6735c6918643ac8769ab4e5dd81020f0" translate="yes" xml:space="preserve">
          <source>The name of an external credential helper, and any associated options. If the helper name is not an absolute path, then the string &lt;code&gt;git
credential-&lt;/code&gt; is prepended. The resulting string is executed by the shell (so, for example, setting this to &lt;code&gt;foo --option=bar&lt;/code&gt; will execute &lt;code&gt;git credential-foo --option=bar&lt;/code&gt; via the shell. See the manual of specific helpers for examples of their use.</source>
          <target state="translated">외부 자격 증명 도우미의 이름 및 관련 옵션 도우미 이름이 절대 경로가 아닌 경우 문자열 &lt;code&gt;git credential-&lt;/code&gt; 이 앞에 붙습니다. 결과 문자열은 쉘에 의해 실행되는 (그래서, 예를 들어,이 설정 &lt;code&gt;foo --option=bar&lt;/code&gt; 실행됩니다 &lt;code&gt;git credential-foo --option=bar&lt;/code&gt; 통해 쉘에게. 그 사용의 예는 특정 헬퍼의 설명서를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="7efaaad02f8c0d5eaaddaa5b6f8a8113410c8ef1" translate="yes" xml:space="preserve">
          <source>The name of one of the following can be used instead of a URL as &lt;code&gt;&amp;lt;repository&amp;gt;&lt;/code&gt; argument:</source>
          <target state="translated">&lt;code&gt;&amp;lt;repository&amp;gt;&lt;/code&gt; 인수 로 URL 대신 다음 중 하나의 이름을 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="f54520854ea19fafb55997c9840c558f7f80fed9" translate="yes" xml:space="preserve">
          <source>The name of the &lt;code&gt;replace&lt;/code&gt; reference is the SHA-1 of the object that is replaced. The content of the &lt;code&gt;replace&lt;/code&gt; reference is the SHA-1 of the replacement object.</source>
          <target state="translated">&lt;code&gt;replace&lt;/code&gt; 참조 의 이름은 교체 된 개체의 SHA-1입니다. &lt;code&gt;replace&lt;/code&gt; 참조 의 내용은 교체 객체의 SHA-1입니다.</target>
        </trans-unit>
        <trans-unit id="117daad0c937bbfd67b26eaa98382dde664a6203" translate="yes" xml:space="preserve">
          <source>The name of the branch to create or delete. The new branch name must pass all checks defined by &lt;a href=&quot;git-check-ref-format&quot;&gt;git-check-ref-format[1]&lt;/a&gt;. Some of these checks may restrict the characters allowed in a branch name.</source>
          <target state="translated">만들거나 삭제할 지점의 이름입니다. 새로운 브랜치 이름은 &lt;a href=&quot;git-check-ref-format&quot;&gt;git-check-ref-format [1]에&lt;/a&gt; 의해 정의 된 모든 검사를 통과해야합니다 . 이러한 검사 중 일부는 지사 이름에 허용되는 문자를 제한 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f40b450a4e1f94bf798289a960712dae0a6f632b" translate="yes" xml:space="preserve">
          <source>The name of the client can be given to &lt;code&gt;git p4&lt;/code&gt; in multiple ways. The variable &lt;code&gt;git-p4.client&lt;/code&gt; takes precedence if it exists. Otherwise, normal p4 mechanisms of determining the client are used: environment variable &lt;code&gt;P4CLIENT&lt;/code&gt;, a file referenced by &lt;code&gt;P4CONFIG&lt;/code&gt;, or the local host name.</source>
          <target state="translated">클라이언트의 이름은 &lt;code&gt;git p4&lt;/code&gt; 에 여러 가지 방법 으로 주어질 수 있습니다 . 변수 &lt;code&gt;git-p4.client&lt;/code&gt; 가있는 경우 우선권을 갖습니다. 그렇지 않으면, 클라이언트를 결정하는 일반적인 p4 메커니즘 (환경 변수 &lt;code&gt;P4CLIENT&lt;/code&gt; , &lt;code&gt;P4CONFIG&lt;/code&gt; 가 참조하는 파일 또는 로컬 호스트 이름)이 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="d25f4900ca4ac26428c337fc8a49a0fffaa87baa" translate="yes" xml:space="preserve">
          <source>The name of the current branch is stored in .git/HEAD.</source>
          <target state="translated">현재 브랜치의 이름은 .git / HEAD에 저장됩니다.</target>
        </trans-unit>
        <trans-unit id="9192c74ec25457f29baaadaeb1d2b767ba20ddac" translate="yes" xml:space="preserve">
          <source>The name of the local ref being pushed, minus its &lt;code&gt;refs/&amp;lt;type&amp;gt;/&lt;/code&gt; prefix. In the case of deletion, the name of the local ref is omitted.</source>
          <target state="translated">푸시되는 로컬 참조의 이름에서 &lt;code&gt;refs/&amp;lt;type&amp;gt;/&lt;/code&gt; 접두사를 뺀 것 입니다. 삭제시 로컬 참조 이름은 생략됩니다.</target>
        </trans-unit>
        <trans-unit id="61c75d700127b0c70d569d247bca51622e343006" translate="yes" xml:space="preserve">
          <source>The name of the local ref being updated, minus its &lt;code&gt;refs/&amp;lt;type&amp;gt;/&lt;/code&gt; prefix.</source>
          <target state="translated">업데이트되는 로컬 참조의 이름에서 &lt;code&gt;refs/&amp;lt;type&amp;gt;/&lt;/code&gt; 접두사를 뺀 것 입니다.</target>
        </trans-unit>
        <trans-unit id="40299b8374a45bc90296f421fddf5763cb8c6908" translate="yes" xml:space="preserve">
          <source>The name of the object to show. For a more complete list of ways to spell object names, see the &quot;SPECIFYING REVISIONS&quot; section in &lt;a href=&quot;gitrevisions&quot;&gt;gitrevisions[7]&lt;/a&gt;.</source>
          <target state="translated">표시 할 객체의 이름입니다. 객체 이름을 철자하는 방법에 대한 전체 목록은 &lt;a href=&quot;gitrevisions&quot;&gt;gitrevisions [7]의&lt;/a&gt; &quot; SPECIFYING REVISIONS&quot;섹션을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="15cfdda92a704493f44c3f6bda85fdb4fe25cc87" translate="yes" xml:space="preserve">
          <source>The name of the ref (the part after $GIT_DIR/). For a non-ambiguous short name of the ref append &lt;code&gt;:short&lt;/code&gt;. The option core.warnAmbiguousRefs is used to select the strict abbreviation mode. If &lt;code&gt;lstrip=&amp;lt;N&amp;gt;&lt;/code&gt; (&lt;code&gt;rstrip=&amp;lt;N&amp;gt;&lt;/code&gt;) is appended, strips &lt;code&gt;&amp;lt;N&amp;gt;&lt;/code&gt; slash-separated path components from the front (back) of the refname (e.g. &lt;code&gt;%(refname:lstrip=2)&lt;/code&gt; turns &lt;code&gt;refs/tags/foo&lt;/code&gt; into &lt;code&gt;foo&lt;/code&gt; and &lt;code&gt;%(refname:rstrip=2)&lt;/code&gt; turns &lt;code&gt;refs/tags/foo&lt;/code&gt; into &lt;code&gt;refs&lt;/code&gt;). If &lt;code&gt;&amp;lt;N&amp;gt;&lt;/code&gt; is a negative number, strip as many path components as necessary from the specified end to leave &lt;code&gt;-&amp;lt;N&amp;gt;&lt;/code&gt; path components (e.g. &lt;code&gt;%(refname:lstrip=-2)&lt;/code&gt; turns &lt;code&gt;refs/tags/foo&lt;/code&gt; into &lt;code&gt;tags/foo&lt;/code&gt; and &lt;code&gt;%(refname:rstrip=-1)&lt;/code&gt; turns &lt;code&gt;refs/tags/foo&lt;/code&gt; into &lt;code&gt;refs&lt;/code&gt;). When the ref does not have enough components, the result becomes an empty string if stripping with positive &amp;lt;N&amp;gt;, or it becomes the full refname if stripping with negative &amp;lt;N&amp;gt;. Neither is an error.</source>
          <target state="translated">심판의 이름 ($ GIT_DIR / 다음 부분). ref append &lt;code&gt;:short&lt;/code&gt; 의 모호하지 않은 짧은 이름 . core.warnAmbiguousRefs 옵션은 엄격한 약어 모드를 선택하는 데 사용됩니다. 만약 &lt;code&gt;lstrip=&amp;lt;N&amp;gt;&lt;/code&gt; ( &lt;code&gt;rstrip=&amp;lt;N&amp;gt;&lt;/code&gt; )가 추가되어, 스트립 &lt;code&gt;&amp;lt;N&amp;gt;&lt;/code&gt; refname의 앞 (뒤)로부터 슬래시 구분 경로 구성 요소 (예 &lt;code&gt;%(refname:lstrip=2)&lt;/code&gt; 온 &lt;code&gt;refs/tags/foo&lt;/code&gt; 에 &lt;code&gt;foo&lt;/code&gt; 에 와 &lt;code&gt;%(refname:rstrip=2)&lt;/code&gt; 회전 &lt;code&gt;refs/tags/foo&lt;/code&gt; 에 &lt;code&gt;refs&lt;/code&gt; ). 경우 &lt;code&gt;&amp;lt;N&amp;gt;&lt;/code&gt; 떠날 지정된 단부로부터 필요한만큼 경로 성분으로서 음극 번호, 스트립은 &lt;code&gt;-&amp;lt;N&amp;gt;&lt;/code&gt; 경로 구성 요소 (예 : &lt;code&gt;%(refname:lstrip=-2)&lt;/code&gt; 회전 &lt;code&gt;refs/tags/foo&lt;/code&gt; 로 &lt;code&gt;tags/foo&lt;/code&gt; 및 &lt;code&gt;%(refname:rstrip=-1)&lt;/code&gt; 온 &lt;code&gt;refs/tags/foo&lt;/code&gt; 로 &lt;code&gt;refs&lt;/code&gt; ). 참조에 충분한 구성 요소가없는 경우 양수 &amp;lt;N&amp;gt;으로 제거하면 결과가 빈 문자열이되거나 음수 &amp;lt;N&amp;gt;으로 제거하면 전체 참조 이름이됩니다. 오류도 아닙니다.</target>
        </trans-unit>
        <trans-unit id="d3667dc69f3d60260150d30873ae903291e9c610" translate="yes" xml:space="preserve">
          <source>The name of the remote ref being fetched from, minus its &lt;code&gt;refs/&amp;lt;type&amp;gt;/&lt;/code&gt; prefix. In the case of deletion, the name of the remote ref is &quot;(none)&quot;.</source>
          <target state="translated">가져 오는 원격 참조의 이름에서 &lt;code&gt;refs/&amp;lt;type&amp;gt;/&lt;/code&gt; 접두사를 뺀 값 입니다. 삭제하는 경우 원격 참조의 이름은 &quot;(없음)&quot;입니다.</target>
        </trans-unit>
        <trans-unit id="f1e1380262032f81dbdd04e4a724dd0dac2f66a0" translate="yes" xml:space="preserve">
          <source>The name of the remote ref being updated, minus its &lt;code&gt;refs/&amp;lt;type&amp;gt;/&lt;/code&gt; prefix.</source>
          <target state="translated">업데이트중인 원격 참조의 이름에서 &lt;code&gt;refs/&amp;lt;type&amp;gt;/&lt;/code&gt; 접두사를 뺀 것 입니다.</target>
        </trans-unit>
        <trans-unit id="cf1208454bdf4c7c5a0ab602103e6dd838ca212a" translate="yes" xml:space="preserve">
          <source>The name of the repository in gitweb is the path to its &lt;code&gt;$GIT_DIR&lt;/code&gt; (its object database) relative to &lt;code&gt;$projectroot&lt;/code&gt;. Therefore the repository $repo can be found at &quot;$projectroot/$repo&quot;.</source>
          <target state="translated">gitweb에있는 저장소의 이름은 그것의 경로입니다 &lt;code&gt;$GIT_DIR&lt;/code&gt; 에 (의 객체 데이터베이스) 기준으로 &lt;code&gt;$projectroot&lt;/code&gt; . 따라서 저장소 $ repo는 &quot;$ projectroot / $ repo&quot;에서 찾을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1b6cc45302b6351d18e813818cde0845c0a5a22a" translate="yes" xml:space="preserve">
          <source>The name of the tag to create, delete, or describe. The new tag name must pass all checks defined by &lt;a href=&quot;git-check-ref-format&quot;&gt;git-check-ref-format[1]&lt;/a&gt;. Some of these checks may restrict the characters allowed in a tag name.</source>
          <target state="translated">작성, 삭제 또는 설명 할 태그의 이름입니다. 새 태그 이름은 &lt;a href=&quot;git-check-ref-format&quot;&gt;git-check-ref-format [1]에&lt;/a&gt; 의해 정의 된 모든 검사를 통과해야합니다 . 이러한 검사 중 일부는 태그 이름에 허용되는 문자를 제한 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="964fd80a7ebc3b646125e059ac3c7f8c3a22061f" translate="yes" xml:space="preserve">
          <source>The named branches will be interpreted as if specified with the &lt;code&gt;-t&lt;/code&gt; option on the &lt;code&gt;git remote add&lt;/code&gt; command line.</source>
          <target state="translated">명명 된 브랜치는 &lt;code&gt;git remote add&lt;/code&gt; 명령 행 에서 &lt;code&gt;-t&lt;/code&gt; 옵션으로 지정된 것처럼 해석됩니다 .</target>
        </trans-unit>
        <trans-unit id="a7226417649eb7c8f42ca4934a290033c08aad1c" translate="yes" xml:space="preserve">
          <source>The names of objects to show (defaults to &lt;code&gt;HEAD&lt;/code&gt;). For a more complete list of ways to spell object names, see &quot;SPECIFYING REVISIONS&quot; section in &lt;a href=&quot;gitrevisions&quot;&gt;gitrevisions[7]&lt;/a&gt;.</source>
          <target state="translated">표시 할 객체의 이름입니다 (기본값은 &lt;code&gt;HEAD&lt;/code&gt; ). 객체 이름을 철자하는 방법에 대한 전체 목록은 &lt;a href=&quot;gitrevisions&quot;&gt;gitrevisions [7]의&lt;/a&gt; &quot; SPECIFYING REVISIONS&quot;섹션을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="df439b2df93c9264d2652e8aa379f62f3b6ab5ac" translate="yes" xml:space="preserve">
          <source>The names of refs that are fetched, together with the object names they point at, are written to &lt;code&gt;.git/FETCH_HEAD&lt;/code&gt;. This information may be used by scripts or other git commands, such as &lt;a href=&quot;git-pull&quot;&gt;git-pull[1]&lt;/a&gt;.</source>
          <target state="translated">페치 된 참조 이름은 이들이 가리키는 오브젝트 이름과 함께 &lt;code&gt;.git/FETCH_HEAD&lt;/code&gt; 에 기록됩니다 . 이 정보는 스크립트 또는 &lt;a href=&quot;git-pull&quot;&gt;git-pull [1]&lt;/a&gt; 과 같은 다른 git 명령에 의해 사용될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="1b9c4b549f992b26edb42d00411780a65661d81d" translate="yes" xml:space="preserve">
          <source>The native transport (i.e. git:// URL) does no authentication and should be used with caution on unsecured networks.</source>
          <target state="translated">원시 전송 (예 : git : // URL)은 인증되지 않으므로 보안되지 않은 네트워크에서는주의해서 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="86d32cda4c46d201605240981feec896fb3daceb" translate="yes" xml:space="preserve">
          <source>The new branch head will point to this commit. It may be given as a branch name, a commit-id, or a tag. If this option is omitted, the current HEAD will be used instead.</source>
          <target state="translated">새로운 지점장은이 커밋을 가리 킵니다. 브랜치 이름, 커밋 ID 또는 태그로 제공 될 수 있습니다. 이 옵션을 생략하면 현재 HEAD가 대신 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="597e47a48a8bd8b3528838dd5cebedeb7b241f60" translate="yes" xml:space="preserve">
          <source>The new name for an existing branch. The same restrictions as for &amp;lt;branchname&amp;gt; apply.</source>
          <target state="translated">기존 지점의 새 이름 &amp;lt;branchname&amp;gt;과 동일한 제한 사항이 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="ade318097a09c67b5bdaa6c1344cf2a281d7cac8" translate="yes" xml:space="preserve">
          <source>The next parameter is the pattern. This option has to be used for patterns starting with &lt;code&gt;-&lt;/code&gt; and should be used in scripts passing user input to grep. Multiple patterns are combined by &lt;code&gt;or&lt;/code&gt;.</source>
          <target state="translated">다음 매개 변수는 패턴입니다. 이 옵션은 &lt;code&gt;-&lt;/code&gt; 로 시작하는 패턴에 사용해야하며 grep에 사용자 입력을 전달하는 스크립트에 사용해야합니다. 여러 패턴이 &lt;code&gt;or&lt;/code&gt; 로 결합됩니다 .</target>
        </trans-unit>
        <trans-unit id="00f28e3b882b5553d45ceeb08082d3dcda522dd0" translate="yes" xml:space="preserve">
          <source>The next step of merging is to merge these three versions of the file, using 3-way merge. This is done by giving &lt;code&gt;git merge-one-file&lt;/code&gt; command as one of the arguments to &lt;code&gt;git merge-index&lt;/code&gt; command:</source>
          <target state="translated">병합의 다음 단계는 3 방향 병합을 사용하여이 세 가지 버전의 파일을 병합하는 것입니다. 이것은 &lt;code&gt;git merge-one-file&lt;/code&gt; 명령을 &lt;code&gt;git merge-index&lt;/code&gt; 명령 의 인수 중 하나로 제공하여 수행됩니다 .</target>
        </trans-unit>
        <trans-unit id="c203649e7405cacf1f66f3229b4d864ccf1b5f34" translate="yes" xml:space="preserve">
          <source>The nonce string the process asked the signer to include in the push certificate. If this does not match the value recorded on the &quot;nonce&quot; header in the push certificate, it may indicate that the certificate is a valid one that is being replayed from a separate &quot;git push&quot; session.</source>
          <target state="translated">프로세스에서 nonce 문자열은 서명자에게 푸시 인증서에 포함하도록 요청했습니다. 이것이 푸시 인증서의 &quot;nonce&quot;헤더에 기록 된 값과 일치하지 않으면 인증서가 별도의 &quot;git push&quot;세션에서 재생되는 유효한 인증서임을 나타낼 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a81eae6f204563324e9f0299e6e5a18af11339c2" translate="yes" xml:space="preserve">
          <source>The normal format target is a tradition printf format and similar to GIT_TRACE format. This format is enabled with the &lt;code&gt;GIT_TRACE2&lt;/code&gt; environment variable or the &lt;code&gt;trace2.normalTarget&lt;/code&gt; system or global config setting.</source>
          <target state="translated">일반 형식 대상은 일반적인 printf 형식이며 GIT_TRACE 형식과 유사합니다. 이 형식은 &lt;code&gt;GIT_TRACE2&lt;/code&gt; 환경 변수 또는 &lt;code&gt;trace2.normalTarget&lt;/code&gt; 시스템 또는 글로벌 구성 설정으로 사용 가능합니다.</target>
        </trans-unit>
        <trans-unit id="08867837836724d3f4c3cfbd7d03fa5d964eec62" translate="yes" xml:space="preserve">
          <source>The number of additional commits is the number of commits which would be displayed by &quot;git log v1.0.4..parent&quot;. The hash suffix is &quot;-g&quot; + unambiguous abbreviation for the tip commit of parent (which was &lt;code&gt;2414721b194453f058079d897d13c4e377f92dc6&lt;/code&gt;). The &quot;g&quot; prefix stands for &quot;git&quot; and is used to allow describing the version of a software depending on the SCM the software is managed with. This is useful in an environment where people may use different SCMs.</source>
          <target state="translated">추가 커밋 수는 &quot;git log v1.0.4..parent&quot;로 표시되는 커밋 수입니다. 해시 접미사는 &quot;-g&quot;+ 부모의 팁 커밋 ( &lt;code&gt;2414721b194453f058079d897d13c4e377f92dc6&lt;/code&gt; )에 대한 모호하지 않은 약어입니다 . &quot;g&quot;접두어는 &quot;git&quot;을 나타내며 소프트웨어가 관리되는 SCM에 따라 소프트웨어 버전을 설명하는 데 사용됩니다. 사람들이 다른 SCM을 사용할 수있는 환경에서 유용합니다.</target>
        </trans-unit>
        <trans-unit id="83386653d6009935020ea78a4c28a793cc5fa198" translate="yes" xml:space="preserve">
          <source>The number of curl sessions (counted across slots) to be kept across requests. They will not be ended with curl_easy_cleanup() until http_cleanup() is invoked. If USE_CURL_MULTI is not defined, this value will be capped at 1. Defaults to 1.</source>
          <target state="translated">여러 요청에 걸쳐 유지 될 curl 세션 (슬롯에 걸쳐 계산) 수 http_cleanup ()이 호출 될 때까지 curl_easy_cleanup ()으로 끝나지 않습니다. USE_CURL_MULTI가 정의되지 않은 경우이 값은 1로 제한됩니다. 기본값은 1입니다.</target>
        </trans-unit>
        <trans-unit id="eb593ed0188a165abaa2fc9b58825ac993fcfa11" translate="yes" xml:space="preserve">
          <source>The number of files to consider when performing rename detection during a merge; if not specified, defaults to the value of diff.renameLimit. This setting has no effect if rename detection is turned off.</source>
          <target state="translated">병합 중에 이름 바꾸기 감지를 수행 할 때 고려할 파일 수입니다. 지정하지 않으면 기본값은 diff.renameLimit입니다. 이름 바꾸기 감지 기능이 해제되어 있으면이 설정이 적용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="b49ca7e6ecad75b8cf0b0ec3dcf469e017a13140" translate="yes" xml:space="preserve">
          <source>The number of files to consider when performing rename detection in &lt;a href=&quot;git-status&quot;&gt;git-status[1]&lt;/a&gt; and &lt;a href=&quot;git-commit&quot;&gt;git-commit[1]&lt;/a&gt;. Defaults to the value of diff.renameLimit.</source>
          <target state="translated">&lt;a href=&quot;git-status&quot;&gt;git-status [1]&lt;/a&gt; 및 &lt;a href=&quot;git-commit&quot;&gt;git-commit [1]&lt;/a&gt; 에서 이름 바꾸기 감지를 수행 할 때 고려할 파일 수입니다 . 기본값은 diff.renameLimit입니다.</target>
        </trans-unit>
        <trans-unit id="62caddb975571c60931b3e5e41910f9ec3dfea6e" translate="yes" xml:space="preserve">
          <source>The number of files to consider when performing the copy/rename detection; equivalent to the &lt;code&gt;git diff&lt;/code&gt; option &lt;code&gt;-l&lt;/code&gt;. This setting has no effect if rename detection is turned off.</source>
          <target state="translated">복사 / 이름 바꾸기 감지를 수행 할 때 고려할 파일 수입니다. &lt;code&gt;git diff&lt;/code&gt; 옵션 &lt;code&gt;-l&lt;/code&gt; 과 같습니다 . 이름 바꾸기 감지 기능이 해제되어 있으면이 설정이 적용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="f40a726880d5eda55c8da498a0add02c8ea2a7b1" translate="yes" xml:space="preserve">
          <source>The number of push options given on the command line of &lt;code&gt;git push --push-option=...&lt;/code&gt; can be read from the environment variable &lt;code&gt;GIT_PUSH_OPTION_COUNT&lt;/code&gt;, and the options themselves are found in &lt;code&gt;GIT_PUSH_OPTION_0&lt;/code&gt;, &lt;code&gt;GIT_PUSH_OPTION_1&lt;/code&gt;,&amp;hellip;​ If it is negotiated to not use the push options phase, the environment variables will not be set. If the client selects to use push options, but doesn&amp;rsquo;t transmit any, the count variable will be set to zero, &lt;code&gt;GIT_PUSH_OPTION_COUNT=0&lt;/code&gt;.</source>
          <target state="translated">의 명령 행에서 주어진 푸시 옵션의 수는 &lt;code&gt;git push --push-option=...&lt;/code&gt; 환경 변수에서 읽을 수 &lt;code&gt;GIT_PUSH_OPTION_COUNT&lt;/code&gt; 하고, 옵션 자체에서 발견되는 &lt;code&gt;GIT_PUSH_OPTION_0&lt;/code&gt; , &lt;code&gt;GIT_PUSH_OPTION_1&lt;/code&gt; 이하지에 협상 경우 ... 푸시 옵션 단계를 사용하면 환경 변수가 설정되지 않습니다. 클라이언트가 푸시 옵션을 사용하도록 선택했지만 전송하지 않으면 카운트 변수는 0으로 설정됩니다 ( &lt;code&gt;GIT_PUSH_OPTION_COUNT=0&lt;/code&gt; ) .</target>
        </trans-unit>
        <trans-unit id="c5ad10bd3ab58adc794f2122271c46d58529bef4" translate="yes" xml:space="preserve">
          <source>The number of spaces between columns. One space by default.</source>
          <target state="translated">열 사이의 공백 수입니다. 기본적으로 하나의 공간.</target>
        </trans-unit>
        <trans-unit id="911462b0802b22317c5a57a0a0510dbf0c397a66" translate="yes" xml:space="preserve">
          <source>The number of submodules fetched at the same time. Defaults to the &lt;code&gt;submodule.fetchJobs&lt;/code&gt; option.</source>
          <target state="translated">동시에 가져온 서브 모듈의 수입니다. &lt;code&gt;submodule.fetchJobs&lt;/code&gt; 옵션이 기본값 입니다.</target>
        </trans-unit>
        <trans-unit id="34de3b8749bfae0c14ff8d34783f05c9920748b5" translate="yes" xml:space="preserve">
          <source>The object can be a blob or a submodule commit. It implies the &lt;code&gt;-t&lt;/code&gt; option in &lt;code&gt;git-log&lt;/code&gt; to also find trees.</source>
          <target state="translated">오브젝트는 Blob 또는 서브 모듈 커밋 일 수 있습니다. &lt;code&gt;git-log&lt;/code&gt; 의 &lt;code&gt;-t&lt;/code&gt; 옵션을 사용하여 트리를 찾습니다.</target>
        </trans-unit>
        <trans-unit id="2794f5933199b4937a09c41b8d049f6b88620c25" translate="yes" xml:space="preserve">
          <source>The object database contains objects of three main types: blobs, which hold file data; trees, which point to blobs and other trees to build up directory hierarchies; and commits, which each reference a single tree and some number of parent commits.</source>
          <target state="translated">오브젝트 데이터베이스에는 세 가지 주요 유형의 오브젝트가 있습니다. 파일 데이터를 보유하는 블롭; 디렉토리 계층을 구축하기위한 블롭 및 다른 트리를 가리키는 트리; 커밋-각각은 단일 트리와 몇 개의 부모 커밋을 참조합니다.</target>
        </trans-unit>
        <trans-unit id="b5ea163b65a2243d9fc238d7c50700c517adc350" translate="yes" xml:space="preserve">
          <source>The object database is the rather elegant system used to store the history of your project&amp;mdash;​files, directories, and commits.</source>
          <target state="translated">객체 데이터베이스는 파일, 디렉토리 및 커밋과 같은 프로젝트 기록을 저장하는 데 사용되는 다소 우아한 시스템입니다.</target>
        </trans-unit>
        <trans-unit id="db080c7937810b605e4381605a2e18077b89e3c0" translate="yes" xml:space="preserve">
          <source>The object name (aka SHA-1). For a non-ambiguous abbreviation of the object name append &lt;code&gt;:short&lt;/code&gt;. For an abbreviation of the object name with desired length append &lt;code&gt;:short=&amp;lt;length&amp;gt;&lt;/code&gt;, where the minimum length is MINIMUM_ABBREV. The length may be exceeded to ensure unique object names.</source>
          <target state="translated">객체 이름 (일명 SHA-1). 객체 이름의 모호하지 않은 약어의 경우 append &lt;code&gt;:short&lt;/code&gt; . 원하는 길이가 추가 된 객체 이름의 약어 인 append &lt;code&gt;:short=&amp;lt;length&amp;gt;&lt;/code&gt; 는 최소 길이가 MINIMUM_ABBREV입니다. 고유 한 객체 이름을 보장하기 위해 길이를 초과 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b335d1a75376848bee9affb50a6203b316fcc02d" translate="yes" xml:space="preserve">
          <source>The object referenced by &amp;lt;src&amp;gt; is used to update the &amp;lt;dst&amp;gt; reference on the remote side. Whether this is allowed depends on where in &lt;code&gt;refs/*&lt;/code&gt; the &amp;lt;dst&amp;gt; reference lives as described in detail below, in those sections &quot;update&quot; means any modifications except deletes, which as noted after the next few sections are treated differently.</source>
          <target state="translated">&amp;lt;src&amp;gt;가 참조하는 객체는 원격 측에서 &amp;lt;dst&amp;gt; 참조를 업데이트하는 데 사용됩니다. 이것이 허용되는지 여부는 &lt;code&gt;refs/*&lt;/code&gt; 에서 &amp;lt;dst&amp;gt; 참조가 아래에 자세히 설명 된대로 존재 하는 위치에 따라 달라집니다. &quot;업데이트&quot;섹션에서 &quot;업데이트&quot;는 삭제를 제외한 모든 수정을 의미하며, 다음 섹션은 다르게 처리됩니다.</target>
        </trans-unit>
        <trans-unit id="afdbad7acf93ca3457880eb431fd58ab07141e11" translate="yes" xml:space="preserve">
          <source>The object table is actually a hashtable keyed on the object name (the unique SHA-1). This storage configuration allows fast-import to reuse an existing or already written object and avoid writing duplicates to the output packfile. Duplicate blobs are surprisingly common in an import, typically due to branch merges in the source.</source>
          <target state="translated">객체 테이블은 실제로 객체 이름 (고유 한 SHA-1)을 기준으로 해시 테이블입니다. 이 저장소 구성을 사용하면 빠른 가져 오기를 통해 기존 또는 이미 작성된 개체를 재사용 할 수 있으며 출력 팩 파일에 중복 된 쓰기를 피할 수 있습니다. 일반적으로 소스의 브랜치 병합으로 인해 가져 오기에서 중복 얼룩이 흔하게 발생합니다.</target>
        </trans-unit>
        <trans-unit id="0b16e9c4d73790474d293fcd4d96547c235d7d1f" translate="yes" xml:space="preserve">
          <source>The object that the new tag will refer to, usually a commit. Defaults to HEAD.</source>
          <target state="translated">새 태그가 참조 할 객체, 일반적으로 커밋. 기본값은 HEAD입니다.</target>
        </trans-unit>
        <trans-unit id="5468420c6f62137502c6bb00574138b237765047" translate="yes" xml:space="preserve">
          <source>The object type may be a blob, representing the contents of a file, or another tree, representing the contents of a subdirectory. Since trees and blobs, like all other objects, are named by the SHA-1 hash of their contents, two trees have the same SHA-1 name if and only if their contents (including, recursively, the contents of all subdirectories) are identical. This allows Git to quickly determine the differences between two related tree objects, since it can ignore any entries with identical object names.</source>
          <target state="translated">객체 유형은 파일의 내용을 나타내는 블롭이거나 하위 디렉토리의 내용을 나타내는 다른 트리 일 수 있습니다. 다른 모든 객체와 마찬가지로 트리와 블로 브는 컨텐츠의 SHA-1 해시로 이름이 지정되므로 컨텐츠 (재귀 적으로 모든 서브 디렉토리의 컨텐츠 포함)가 동일한 경우에만 두 개의 트리가 동일한 SHA-1 이름을 갖습니다. . 이를 통해 Git은 동일한 객체 이름을 가진 항목을 무시할 수 있으므로 두 개의 관련 트리 객체 간의 차이점을 신속하게 확인할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="abf9c48e6cb6157bcc4ecdd7fbfd1167ee2a4bc5" translate="yes" xml:space="preserve">
          <source>The object types in some more detail:</source>
          <target state="translated">객체 유형에 대한 자세한 내용은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="1aa11fdf087f0d8d0d32eb67b923b0efa29ecf46" translate="yes" xml:space="preserve">
          <source>The objects are output in the order in which they are found in the index file, which should be (in a correctly constructed file) sorted by object id.</source>
          <target state="translated">객체는 색인 파일에서 찾은 순서대로 출력되며,이 파일은 객체 ID별로 (정확하게 구성된 파일에서) 정렬되어야합니다.</target>
        </trans-unit>
        <trans-unit id="113c9617d3615ff46d1de3788621403d384bc970" translate="yes" xml:space="preserve">
          <source>The official repository of the &lt;code&gt;git gui&lt;/code&gt; project can be found at:</source>
          <target state="translated">&lt;code&gt;git gui&lt;/code&gt; 프로젝트 의 공식 저장소는 다음 에서 찾을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d2925f4342d92a06228b4eeddfbffd0ada540f91" translate="yes" xml:space="preserve">
          <source>The one commit in this list that is not related to CMake may very well have been motivated by working on fixing all those bugs introduced by switching to CMake, but it addresses a different concern. To split this branch into two topic branches, the todo list could be edited like this:</source>
          <target state="translated">CMake와 관련이없는이 목록의 커밋은 CMake로 전환하여 발생하는 모든 버그를 수정하여 동기를 부여 받았을 수도 있지만 다른 문제를 해결합니다. 이 브랜치를 두 개의 토픽 브랜치로 나누기 위해 할 일 목록을 다음과 같이 편집 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="680930999bd0e3bf9880124c135a89bca3a329f3" translate="yes" xml:space="preserve">
          <source>The oneline descriptions are purely for your pleasure; &lt;code&gt;git rebase&lt;/code&gt; will not look at them but at the commit names (&quot;deadbee&quot; and &quot;fa1afe1&quot; in this example), so do not delete or edit the names.</source>
          <target state="translated">oneline 설명은 순전히 당신의 즐거움을위한 것입니다. &lt;code&gt;git rebase&lt;/code&gt; 는 커밋 이름 (이 예제에서는 &quot;deadbee&quot;및 &quot;fa1afe1&quot;)을 보지 않으므로 이름을 삭제하거나 편집하지 마십시오.</target>
        </trans-unit>
        <trans-unit id="b174b5f513a45da66bee660cec63368b38af2a1f" translate="yes" xml:space="preserve">
          <source>The only difference between this command and &lt;a href=&quot;git-blame&quot;&gt;git-blame[1]&lt;/a&gt; is that they use slightly different output formats, and this command exists only for backward compatibility to support existing scripts, and provide a more familiar command name for people coming from other SCM systems.</source>
          <target state="translated">이 명령과 &lt;a href=&quot;git-blame&quot;&gt;git-blame [1]&lt;/a&gt; 의 유일한 차이점은 약간 다른 출력 형식을 사용한다는 점입니다.이 명령은 기존 스크립트를 지원하는 이전 버전과의 호환성을 위해서만 존재하며 다른 SCM 시스템에서 온 사람들에게보다 친숙한 명령 이름을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="90482aceb580582ec33d188b8fb1bca29f8136a1" translate="yes" xml:space="preserve">
          <source>The option can have the following values, defaulting to &lt;code&gt;group&lt;/code&gt; if no value is given:</source>
          <target state="translated">이 옵션은 다음과 같은 값을 가질 수 있으며, 값이 제공되지 않으면 &lt;code&gt;group&lt;/code&gt; 됩니다.</target>
        </trans-unit>
        <trans-unit id="72a352b7174eb63582b749d1295b267e0dae9887" translate="yes" xml:space="preserve">
          <source>The optional &amp;lt;limit&amp;gt; is useful in cases where your topic is based on other work that is not in upstream. Expanding on the previous example, this might look like:</source>
          <target state="translated">선택적인 &amp;lt;limit&amp;gt;는 주제가 업스트림이 아닌 다른 작업을 기반으로하는 경우에 유용합니다. 이전 예제에서 확장하면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="4136e1c0c625091f77db10ec0b76e55e39fdb1b6" translate="yes" xml:space="preserve">
          <source>The optional &amp;lt;style&amp;gt; argument can be either &lt;code&gt;shallow&lt;/code&gt; or &lt;code&gt;deep&lt;/code&gt;. &lt;code&gt;shallow&lt;/code&gt; threading makes every mail a reply to the head of the series, where the head is chosen from the cover letter, the &lt;code&gt;--in-reply-to&lt;/code&gt;, and the first patch mail, in this order. &lt;code&gt;deep&lt;/code&gt; threading makes every mail a reply to the previous one.</source>
          <target state="translated">선택적 &amp;lt;style&amp;gt; 인수는 &lt;code&gt;shallow&lt;/code&gt; 또는 &lt;code&gt;deep&lt;/code&gt; 일 수 있습니다 . &lt;code&gt;shallow&lt;/code&gt; 스레드는 모든 메일을 시리즈의 헤드에 대한 답장으로 만듭니다. 여기서 헤드는 커버 레터, &lt;code&gt;--in-reply-to&lt;/code&gt; 및 첫 번째 패치 메일에서이 순서대로 선택됩니다. &lt;code&gt;deep&lt;/code&gt; 스레딩은 모든 메일을 이전 메일에 대한 회신으로 만듭니다.</target>
        </trans-unit>
        <trans-unit id="3dd98bdacd886ba292b303baaba2ecefebed8bab" translate="yes" xml:space="preserve">
          <source>The optional &lt;code&gt;encoding&lt;/code&gt; command indicates the encoding of the commit message. Most commits are UTF-8 and the encoding is omitted, but this allows importing commit messages into git without first reencoding them.</source>
          <target state="translated">선택적 &lt;code&gt;encoding&lt;/code&gt; 명령은 커밋 메시지의 인코딩을 나타냅니다. 대부분의 커밋은 UTF-8이며 인코딩은 생략되지만 커밋 메시지를 먼저 다시 인코딩하지 않고 git으로 가져올 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b0ae75c1b10bf71d7e20ef9926e29585fa74a2e0" translate="yes" xml:space="preserve">
          <source>The optional argument &amp;lt;path&amp;gt; is the relative location for the cloned submodule to exist in the superproject. If &amp;lt;path&amp;gt; is not given, the canonical part of the source repository is used (&quot;repo&quot; for &quot;/path/to/repo.git&quot; and &quot;foo&quot; for &quot;host.xz:foo/.git&quot;). If &amp;lt;path&amp;gt; exists and is already a valid Git repository, then it is staged for commit without cloning. The &amp;lt;path&amp;gt; is also used as the submodule&amp;rsquo;s logical name in its configuration entries unless &lt;code&gt;--name&lt;/code&gt; is used to specify a logical name.</source>
          <target state="translated">선택적 인수 &amp;lt;path&amp;gt;는 복제 된 하위 모듈이 수퍼 프로젝트에 존재하는 상대 위치입니다. &amp;lt;path&amp;gt;를 지정하지 않으면 소스 저장소의 정식 부분이 사용됩니다 ( &quot;/path/to/repo.git&quot;의 경우 &quot;repo&quot;, &quot;host.xz : foo / .git&quot;의 경우 &quot;foo&quot;). &amp;lt;path&amp;gt;가 있고 이미 유효한 Git 리포지토리 인 경우 복제하지 않고 커밋을 위해 준비됩니다. &lt;code&gt;--name&lt;/code&gt; 을 사용하여 논리적 이름을 지정 하지 않으면 &amp;lt;path&amp;gt;는 구성 항목에서 하위 모듈의 논리적 이름으로도 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="476c5c2c4870d6be72c4d31b42e1450136c51807" translate="yes" xml:space="preserve">
          <source>The optional configuration variable &lt;code&gt;core.excludesFile&lt;/code&gt; indicates a path to a file containing patterns of file names to exclude, similar to &lt;code&gt;$GIT_DIR/info/exclude&lt;/code&gt;. Patterns in the exclude file are used in addition to those in &lt;code&gt;$GIT_DIR/info/exclude&lt;/code&gt;.</source>
          <target state="translated">선택적 구성 변수 &lt;code&gt;core.excludesFile&lt;/code&gt; 은 &lt;code&gt;$GIT_DIR/info/exclude&lt;/code&gt; 와 유사하게 제외 할 파일 이름 패턴이 포함 된 파일의 경로를 나타냅니다 . 제외 파일의 패턴은 &lt;code&gt;$GIT_DIR/info/exclude&lt;/code&gt; 패턴과 함께 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="ad80c43bd988ae6e6061dfab8a056d2afaee7691" translate="yes" xml:space="preserve">
          <source>The options &lt;code&gt;--contains&lt;/code&gt;, &lt;code&gt;--no-contains&lt;/code&gt;, &lt;code&gt;--merged&lt;/code&gt; and &lt;code&gt;--no-merged&lt;/code&gt; serve four related but different purposes:</source>
          <target state="translated">옵션의 &lt;code&gt;--contains&lt;/code&gt; 는 , &lt;code&gt;--no-contains&lt;/code&gt; , &lt;code&gt;--merged&lt;/code&gt; 및 &lt;code&gt;--no-merged&lt;/code&gt; 사 관련이 있지만, 다른 용도로 사용</target>
        </trans-unit>
        <trans-unit id="081a3bdc8213b4774c97cebf32978af69c3476cb" translate="yes" xml:space="preserve">
          <source>The order of stages 1, 2 and 3 (hence the order of three &amp;lt;tree-ish&amp;gt; command-line arguments) are significant when you start a 3-way merge with an index file that is already populated. Here is an outline of how the algorithm works:</source>
          <target state="translated">1, 2 및 3 단계의 순서 (따라서 세 개의 &amp;lt;tree-ish&amp;gt; 명령 행 인수의 순서)는 이미 채워진 색인 파일과 3 방향 병합을 시작할 때 중요합니다. 다음은 알고리즘 작동 방식에 대한 개요입니다.</target>
        </trans-unit>
        <trans-unit id="3fb57cf5101f783ba73fc6eba17ed42ef2940627" translate="yes" xml:space="preserve">
          <source>The order of the flags used to matter, but not anymore.</source>
          <target state="translated">중요했던 플래그의 순서는 더 이상 중요하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="32a54a6aa8ff67e3d76c47c6fabd2affc1e5cbb5" translate="yes" xml:space="preserve">
          <source>The origin of lines is automatically followed across whole-file renames (currently there is no option to turn the rename-following off). To follow lines moved from one file to another, or to follow lines that were copied and pasted from another file, etc., see the &lt;code&gt;-C&lt;/code&gt; and &lt;code&gt;-M&lt;/code&gt; options.</source>
          <target state="translated">행의 원점은 전체 파일 이름 바꾸기에서 자동으로 따릅니다 (현재 이름 바꾸기를 끄는 옵션은 없습니다). 한 파일에서 다른 파일로 이동 한 행을 따르거나 다른 파일에서 복사하여 붙여 넣은 행을 따르려면 &lt;code&gt;-C&lt;/code&gt; 및 &lt;code&gt;-M&lt;/code&gt; 옵션을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="b66619a4ae8f145d6aac4431781b08d6ac86597a" translate="yes" xml:space="preserve">
          <source>The origin revision can be changed with the &quot;--origin&quot; option.</source>
          <target state="translated">원점 수정은 &quot;--origin&quot;옵션으로 변경할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="617fe8d1d55cfe9ccc09f76fcfa190410b239da3" translate="yes" xml:space="preserve">
          <source>The original format used by Greg Kroah-Hartman&amp;rsquo;s &lt;code&gt;send_lots_of_email.pl&lt;/code&gt; script</source>
          <target state="translated">Greg Kroah-Hartman의 &lt;code&gt;send_lots_of_email.pl&lt;/code&gt; 스크립트가 사용하는 원래 형식</target>
        </trans-unit>
        <trans-unit id="a7a5cdcdcd4d6fcaaf02e53acebd8443c9b015da" translate="yes" xml:space="preserve">
          <source>The original job of &lt;code&gt;git rev-parse&lt;/code&gt; is now taken by the function &lt;code&gt;setup_revisions()&lt;/code&gt;, which parses the revisions and the common command-line options for the revision walker. This information is stored in the struct &lt;code&gt;rev_info&lt;/code&gt; for later consumption. You can do your own command-line option parsing after calling &lt;code&gt;setup_revisions()&lt;/code&gt;. After that, you have to call &lt;code&gt;prepare_revision_walk()&lt;/code&gt; for initialization, and then you can get the commits one by one with the function &lt;code&gt;get_revision()&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;git rev-parse&lt;/code&gt; 의 원래 작업 은 이제 &lt;code&gt;setup_revisions()&lt;/code&gt; 함수에 의해 수행됩니다.이 함수 는 개정 및 워커에 대한 공통 명령 행 옵션을 구문 분석합니다. 이 정보는 나중에 &lt;code&gt;rev_info&lt;/code&gt; 있도록 struct rev_info 에 저장됩니다 . &lt;code&gt;setup_revisions()&lt;/code&gt; 호출 한 후 고유 한 명령 행 옵션 구문 분석을 수행 할 수 있습니다 . 그런 다음 초기화를 위해 &lt;code&gt;prepare_revision_walk()&lt;/code&gt; 를 호출해야하며 &lt;code&gt;get_revision()&lt;/code&gt; 함수를 사용하여 커밋을 하나씩 가져올 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="4c9da327e28b59015cec84abd98a33aec635328d" translate="yes" xml:space="preserve">
          <source>The original tags are not deleted, but can be overwritten; use &quot;--tag-name-filter cat&quot; to simply update the tags. In this case, be very careful and make sure you have the old tags backed up in case the conversion has run afoul.</source>
          <target state="translated">원래 태그는 삭제되지 않지만 덮어 쓸 수 있습니다. 단순히 태그를 업데이트하려면 &quot;--tag-name-filter cat&quot;을 사용하십시오. 이 경우 전환에 문제가있는 경우를 대비하여 매우 신중하고 이전 태그를 백업해야합니다.</target>
        </trans-unit>
        <trans-unit id="6c2cf73d4477ea65ac2368f08dedbcc07c9eafb4" translate="yes" xml:space="preserve">
          <source>The other nice thing with test suites, is that when you have one, you already know how to test for bad behavior. So you can use this knowledge to create a new test case for &quot;git bisect&quot; when it appears that there is a regression. So it will be easier to bisect the bug and fix it. And then you can add the test case you just created to your test suite.</source>
          <target state="translated">테스트 스위트의 또 다른 좋은 점은 하나가 있으면 나쁜 동작을 테스트하는 방법을 이미 알고 있다는 것입니다. 따라서이 지식을 사용하여 회귀가있는 경우 &quot;git bisect&quot;에 대한 새로운 테스트 사례를 만들 수 있습니다. 따라서 버그를 양분하고 수정하는 것이 더 쉬울 것입니다. 그런 다음 방금 생성 한 테스트 사례를 테스트 스위트에 추가 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="94bda500b4b5c47f0218909469e6ab7f1eee52b6" translate="yes" xml:space="preserve">
          <source>The other way to drive the bisection process is to tell &quot;git bisect&quot; to launch a script or command at each bisection step to know if the current commit is &quot;good&quot; or &quot;bad&quot;. To do that, we use the &quot;git bisect run&quot; command. For example:</source>
          <target state="translated">bisection 프로세스를 구동하는 다른 방법은 &quot;git bisect&quot;에게 각 bisection 단계에서 스크립트 또는 명령을 실행하여 현재 커밋이 &quot;good&quot;또는 &quot;bad&quot;인지 알도록 지시하는 것입니다. 이를 위해 &quot;git bisect run&quot;명령을 사용합니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="013b9f528101f55f667633859403afae697697c4" translate="yes" xml:space="preserve">
          <source>The output format is modified to be machine-parsable (see below). If &lt;code&gt;--stdin&lt;/code&gt; is also given, input paths are separated with a NUL character instead of a linefeed character.</source>
          <target state="translated">출력 형식이 기계 구문 분석 가능하도록 수정되었습니다 (아래 참조). 경우 &lt;code&gt;--stdin&lt;/code&gt; 옵션은 또한 주어진 입력 경로는 널 문자 대신 개행 문자로 분리된다.</target>
        </trans-unit>
        <trans-unit id="4ebdc78d172a0b82e38a898aa2ae716344def4d5" translate="yes" xml:space="preserve">
          <source>The output format is modified to be machine-parsable. If &lt;code&gt;--stdin&lt;/code&gt; is also given, input paths are separated with a NUL character instead of a linefeed character.</source>
          <target state="translated">출력 형식이 기계 구문 분석 가능하도록 수정되었습니다. 경우 &lt;code&gt;--stdin&lt;/code&gt; 옵션은 또한 주어진 입력 경로는 널 문자 대신 개행 문자로 분리된다.</target>
        </trans-unit>
        <trans-unit id="885a3d9b027501a3f7ddd2554d827f984cacfcf5" translate="yes" xml:space="preserve">
          <source>The output format is similar to the Porcelain format, but it does not contain the actual lines from the file that is being annotated.</source>
          <target state="translated">출력 형식은 Porcelain 형식과 유사하지만 주석이 추가 된 파일의 실제 줄은 포함하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="16ca2e6d144e9c4d47f91cfe57ded6c4b6f874af" translate="yes" xml:space="preserve">
          <source>The output from this command is designed to be used as a commit template comment. The default, long format, is designed to be human readable, verbose and descriptive. Its contents and format are subject to change at any time.</source>
          <target state="translated">이 명령의 출력은 커밋 템플릿 주석으로 사용되도록 설계되었습니다. 기본적으로 긴 형식은 사람이 읽을 수 있고 장황하며 설명이 가능하도록 설계되었습니다. 내용과 형식은 언제든지 변경 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="467b04ab4f0f42e5eb4db50995625d7a06a04bbc" translate="yes" xml:space="preserve">
          <source>The output is in the format: &lt;code&gt;&amp;lt;SHA-1 ID&amp;gt;&lt;/code&gt;&lt;code&gt;&amp;lt;space&amp;gt;&lt;/code&gt;&lt;code&gt;&amp;lt;reference name&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">출력은 &lt;code&gt;&amp;lt;SHA-1 ID&amp;gt;&lt;/code&gt; &lt;code&gt;&amp;lt;space&amp;gt;&lt;/code&gt; &lt;code&gt;&amp;lt;reference name&amp;gt;&lt;/code&gt; 형식 입니다.</target>
        </trans-unit>
        <trans-unit id="297e105083265b9b5df9c784faa30006468bc5fd" translate="yes" xml:space="preserve">
          <source>The output is of the form: &amp;lt;path&amp;gt; COLON SP &amp;lt;attribute&amp;gt; COLON SP &amp;lt;info&amp;gt; LF</source>
          <target state="translated">출력은 &amp;lt;path&amp;gt; COLON SP &amp;lt;attribute&amp;gt; COLON SP &amp;lt;info&amp;gt; LF 형식입니다.</target>
        </trans-unit>
        <trans-unit id="00d47eecfb8e7c432b9a2a4461da0aa0b0a14445" translate="yes" xml:space="preserve">
          <source>The output is the new tag&amp;rsquo;s &amp;lt;object&amp;gt; identifier.</source>
          <target state="translated">출력은 새 태그의 &amp;lt;object&amp;gt; 식별자입니다.</target>
        </trans-unit>
        <trans-unit id="c209f5f99a30592095be06f60778bfc6143218e8" translate="yes" xml:space="preserve">
          <source>The output of &quot;git fetch&quot; depends on the transport method used; this section describes the output when fetching over the Git protocol (either locally or via ssh) and Smart HTTP protocol.</source>
          <target state="translated">&quot;git fetch&quot;의 출력은 사용 된 전송 방법에 따라 다릅니다. 이 섹션에서는 Git 프로토콜 (로컬 또는 ssh를 통해) 및 Smart HTTP 프로토콜을 통해 가져올 때의 출력에 대해 설명합니다.</target>
        </trans-unit>
        <trans-unit id="249df455a76d6d8a4ee813f24ba8c68836888f67" translate="yes" xml:space="preserve">
          <source>The output of &quot;git push&quot; depends on the transport method used; this section describes the output when pushing over the Git protocol (either locally or via ssh).</source>
          <target state="translated">&quot;git push&quot;의 출력은 사용 된 전송 방법에 따라 다릅니다. 이 섹션에서는 로컬 또는 ssh를 통해 Git 프로토콜을 푸시 할 때의 출력에 대해 설명합니다.</target>
        </trans-unit>
        <trans-unit id="2012a50a7ce95c41c81b087cc42352c50e07741b" translate="yes" xml:space="preserve">
          <source>The output of ls-refs is as follows:</source>
          <target state="translated">ls-refs의 출력은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="c9897264787fe814346af61567793268dae2ec95" translate="yes" xml:space="preserve">
          <source>The output of the &lt;code&gt;range-diff&lt;/code&gt; command is subject to change. It is intended to be human-readable porcelain output, not something that can be used across versions of Git to get a textually stable &lt;code&gt;range-diff&lt;/code&gt; (as opposed to something like the &lt;code&gt;--stable&lt;/code&gt; option to &lt;a href=&quot;git-patch-id&quot;&gt;git-patch-id[1]&lt;/a&gt;). There&amp;rsquo;s also no equivalent of &lt;a href=&quot;git-apply&quot;&gt;git-apply[1]&lt;/a&gt; for &lt;code&gt;range-diff&lt;/code&gt;, the output is not intended to be machine-readable.</source>
          <target state="translated">&lt;code&gt;range-diff&lt;/code&gt; 명령 의 출력은 변경 될 수 있습니다. Git의 모든 버전에서 텍스트로 안정적인 &lt;code&gt;range-diff&lt;/code&gt; 를 얻는 데 사용할 수있는 것이 아니라 사람이 읽을 수있는 도자기 출력이되도록 고안되었습니다 ( &lt;a href=&quot;git-patch-id&quot;&gt;git-patch-id [-]에&lt;/a&gt; 대한 &lt;code&gt;--stable&lt;/code&gt; 옵션 과 반대 ) . 어떠한 등가도 없다 &lt;a href=&quot;git-apply&quot;&gt;자식이 신청 [1]&lt;/a&gt; 에 대한 &lt;code&gt;range-diff&lt;/code&gt; 출력은 기계 판독되는 것은 아니다.</target>
        </trans-unit>
        <trans-unit id="acccdb81223db3ebfe60a727e12d9a4ed87719fe" translate="yes" xml:space="preserve">
          <source>The output order is determined by the order of glob patterns in &amp;lt;orderfile&amp;gt;. All files with pathnames that match the first pattern are output first, all files with pathnames that match the second pattern (but not the first) are output next, and so on. All files with pathnames that do not match any pattern are output last, as if there was an implicit match-all pattern at the end of the file. If multiple pathnames have the same rank (they match the same pattern but no earlier patterns), their output order relative to each other is the normal order.</source>
          <target state="translated">출력 순서는 &amp;lt;orderfile&amp;gt;의 glob 패턴 순서에 따라 결정됩니다. 첫 번째 패턴과 일치하는 경로 이름을 가진 모든 파일이 먼저 출력되고 두 번째 패턴과 일치하는 경로 이름을 가진 모든 파일 (첫 번째는 아님)이 다음에 출력됩니다. 어떤 패턴과도 일치하지 않는 경로 이름을 가진 모든 파일은 파일의 끝에 암시 적 일치 패턴이있는 것처럼 마지막에 출력됩니다. 여러 경로 이름이 동일한 순위를 갖는 경우 (동일한 패턴과 일치하지만 이전 패턴은 일치하지 않음) 서로에 대한 출력 순서는 정상적인 순서입니다.</target>
        </trans-unit>
        <trans-unit id="70ec2e58d64c53608a589a3f892a41e430e23c0e" translate="yes" xml:space="preserve">
          <source>The overall time needed to compute this algorithm is the time needed to compute n+m commit diffs and then n*m diffs of patches, plus the time needed to compute the least-cost assignment between n and m diffs. Git uses an implementation of the Jonker-Volgenant algorithm to solve the assignment problem, which has cubic runtime complexity. The matching found in this case will look like this:</source>
          <target state="translated">이 알고리즘을 계산하는 데 필요한 전체 시간은 n + m 커밋 차이를 계산 한 다음 n * m 패치를 계산하는 데 필요한 시간과 n과 m 차이 사이의 최소 비용 할당을 계산하는 데 필요한 시간입니다. Git은 Jonker-Volgenant 알고리즘의 구현을 사용하여 3 차 런타임 복잡성을 갖는 할당 문제를 해결합니다. 이 경우에 일치하는 내용은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="f8c05a901b25f6434301621f82a267dcb0caae54" translate="yes" xml:space="preserve">
          <source>The p4 changes will be created as the user invoking &lt;code&gt;git p4 submit&lt;/code&gt;. The &lt;code&gt;--preserve-user&lt;/code&gt; option will cause ownership to be modified according to the author of the Git commit. This option requires admin privileges in p4, which can be granted using &lt;code&gt;p4 protect&lt;/code&gt;.</source>
          <target state="translated">사용자가 &lt;code&gt;git p4 submit&lt;/code&gt; 를 호출하면 p4 변경 사항이 작성됩니다 . &lt;code&gt;--preserve-user&lt;/code&gt; 옵션은 커밋 망할 놈의 저자에 따라 소유권이 변경되는 원인이됩니다. 이 옵션은 &lt;code&gt;p4 protect&lt;/code&gt; 를 사용하여 부여 할 수있는 p4의 관리자 권한이 필요합니다 .</target>
        </trans-unit>
        <trans-unit id="bc53387773cbb38b899a330a03a788e5288eab48" translate="yes" xml:space="preserve">
          <source>The p4 client specification is maintained with the &lt;code&gt;p4 client&lt;/code&gt; command and contains among other fields, a View that specifies how the depot is mapped into the client repository. The &lt;code&gt;clone&lt;/code&gt; and &lt;code&gt;sync&lt;/code&gt; commands can consult the client spec when given the &lt;code&gt;--use-client-spec&lt;/code&gt; option or when the useClientSpec variable is true. After &lt;code&gt;git p4 clone&lt;/code&gt;, the useClientSpec variable is automatically set in the repository configuration file. This allows future &lt;code&gt;git p4 submit&lt;/code&gt; commands to work properly; the submit command looks only at the variable and does not have a command-line option.</source>
          <target state="translated">p4 클라이언트 스펙은 &lt;code&gt;p4 client&lt;/code&gt; 명령으로 유지 보수되며 , 저장소가 클라이언트 저장소에 맵핑되는 방법을 지정하는보기 인 다른 필드를 포함합니다. &lt;code&gt;clone&lt;/code&gt; 및 &lt;code&gt;sync&lt;/code&gt; 주어진 경우 명령은 클라이언트 사양을 참조 할 수 &lt;code&gt;--use-client-spec&lt;/code&gt; 옵션 또는 때 useClientSpec 변수가 true를. &lt;code&gt;git p4 clone&lt;/code&gt; 후에 는 useClientSpec 변수가 저장소 구성 파일에 자동으로 설정됩니다. 이것은 미래의 &lt;code&gt;git p4 submit&lt;/code&gt; 명령이 올바르게 작동 하도록 합니다. submit 명령은 변수 만보고 명령 행 옵션이 없습니다.</target>
        </trans-unit>
        <trans-unit id="9fec68b06723905b09b9270262e6a13c1b490876" translate="yes" xml:space="preserve">
          <source>The p4 depot path argument to &lt;code&gt;git p4 sync&lt;/code&gt; and &lt;code&gt;git p4 clone&lt;/code&gt; can be one or more space-separated p4 depot paths, with an optional p4 revision specifier on the end:</source>
          <target state="translated">&lt;code&gt;git p4 sync&lt;/code&gt; 및 &lt;code&gt;git p4 clone&lt;/code&gt; 에 대한 p4 저장소 경로 인수 는 선택적 p4 개정 지정자가 끝에있는 하나 이상의 공백으로 구분 된 p4 저장소 경로 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d877dea1de89fdb5a15efd47a5debfe5403b96f4" translate="yes" xml:space="preserve">
          <source>The pack-indexes (.idx files) remain in the pack directory so we can delete the MIDX file, set core.midx to false, or downgrade without any loss of information.</source>
          <target state="translated">팩 인덱스 (.idx 파일)는 팩 디렉토리에 남아 있으므로 MIDX 파일을 삭제하거나 core.midx를 false로 설정하거나 정보 손실없이 다운 그레이드 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="933f30be1e83e4fe09dc8528b693f5b5a75f065d" translate="yes" xml:space="preserve">
          <source>The packed archive format (.pack) is designed to be self-contained so that it can be unpacked without any further information. Therefore, each object that a delta depends upon must be present within the pack.</source>
          <target state="translated">압축 아카이브 형식 (.pack)은 추가 정보없이 압축을 풀 수 있도록 자체 포함되도록 설계되었습니다. 따라서 델타가 의존하는 각 오브젝트는 팩 내에 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="75cd7427877d4a48fded775aaaba114771e37304" translate="yes" xml:space="preserve">
          <source>The packfile(s) created by fast-import do not encourage good disk access patterns. This is caused by fast-import writing the data in the order it is received on standard input, while Git typically organizes data within packfiles to make the most recent (current tip) data appear before historical data. Git also clusters commits together, speeding up revision traversal through better cache locality.</source>
          <target state="translated">빠른 가져 오기로 작성된 팩 파일은 양호한 디스크 액세스 패턴을 권장하지 않습니다. 이는 표준 입력에서 수신 한 순서대로 데이터를 빠르게 가져 오기 때문에 발생합니다. Git은 일반적으로 가장 최근 (현재의 팁) 데이터가 기록 데이터 앞에 나타나도록 팩 파일 내에서 데이터를 구성합니다. 또한 Git은 클러스터를 함께 커밋하여 더 나은 캐시 위치를 통해 개정 순회를 가속화합니다.</target>
        </trans-unit>
        <trans-unit id="73715b9a828b5f7ca9623cd366d376d487c8e126" translate="yes" xml:space="preserve">
          <source>The partial clone feature records special &quot;promisor&quot; packs that may point to objects that are not stored locally, but available on request to a server. The multi-pack-index does not currently track these promisor packs.</source>
          <target state="translated">부분 복제 기능은 로컬에 저장되지 않지만 요청시 서버에 사용 가능한 개체를 가리킬 수있는 특수 &quot;프로 미저&quot;팩을 기록합니다. 다중 팩 인덱스는 현재 이러한 유망 팩을 추적하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="608e992a19f0287b5b2e4cbdc92416d882bd253c" translate="yes" xml:space="preserve">
          <source>The password to use when logging in to the server.</source>
          <target state="translated">서버에 로그인 할 때 사용할 비밀번호입니다.</target>
        </trans-unit>
        <trans-unit id="f899bc9ba76fee3c960f01f1f955c5a4bf020e98" translate="yes" xml:space="preserve">
          <source>The patch extracted from e-mail.</source>
          <target state="translated">전자 우편에서 추출한 패치입니다.</target>
        </trans-unit>
        <trans-unit id="621265bbad5d0651c63283720f8a5ccddfdeeb61" translate="yes" xml:space="preserve">
          <source>The patch is expected to be inline, directly following the message. Any line that is of the form:</source>
          <target state="translated">패치는 메시지 바로 다음에 인라인이 될 것으로 예상됩니다. 다음과 같은 형식의 라인 :</target>
        </trans-unit>
        <trans-unit id="eedf9ed2547b7a76bcd6fb69785bf954af8d224f" translate="yes" xml:space="preserve">
          <source>The patch itself does not apply cleanly. That is &lt;code&gt;bad&lt;/code&gt; but does not have much to do with your MUA. You might want to rebase the patch with &lt;a href=&quot;git-rebase&quot;&gt;git-rebase[1]&lt;/a&gt; before regenerating it in this case.</source>
          <target state="translated">패치 자체는 깨끗하게 적용되지 않습니다. 그것은 &lt;code&gt;bad&lt;/code&gt; MUA와 관련이 없습니다. 이 경우 패치를 다시 생성하기 전에 &lt;a href=&quot;git-rebase&quot;&gt;git-rebase [1]로&lt;/a&gt; 패치를 리베이스 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="c9ecbf09d9172bac5285d567a6e1031058a01024" translate="yes" xml:space="preserve">
          <source>The patch produced by &lt;code&gt;git format-patch&lt;/code&gt; is in UNIX mailbox format, with a fixed &quot;magic&quot; time stamp to indicate that the file is output from format-patch rather than a real mailbox, like so:</source>
          <target state="translated">&lt;code&gt;git format-patch&lt;/code&gt; 에 의해 생성 된 패치 는 UNIX 메일 박스 형식이며, 고정 된 &quot;마법의&quot;타임 스탬프는 다음과 같이 파일이 실제 메일 상자가 아닌 format-patch에서 출력됨을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="7072603eb0a607d061c366f3e4a9cba6cffbd377" translate="yes" xml:space="preserve">
          <source>The path can be either absolute or relative. A relative path is taken as relative to the directory where the hooks are run (see the &quot;DESCRIPTION&quot; section of &lt;a href=&quot;githooks&quot;&gt;githooks[5]&lt;/a&gt;).</source>
          <target state="translated">경로는 절대적이거나 상대적 일 수 있습니다. 상대 경로는 후크가 실행되는 디렉토리를 기준으로합니다 ( &lt;a href=&quot;githooks&quot;&gt;githooks [5]&lt;/a&gt; 의 &quot;DESCRIPTION&quot;섹션 참조 ).</target>
        </trans-unit>
        <trans-unit id="6ccace0f35f0f4e5cab0e8cffbdf924135579b2e" translate="yes" xml:space="preserve">
          <source>The path has the attribute with special value &quot;false&quot;; this is specified by listing the name of the attribute prefixed with a dash &lt;code&gt;-&lt;/code&gt; in the attribute list.</source>
          <target state="translated">경로에는 특수 값이 &quot;false&quot;인 속성이 있습니다. 이것은 대시로 시작하는 속성의 이름을 나열하여 지정 &lt;code&gt;-&lt;/code&gt; 속성리스트에 있습니다.</target>
        </trans-unit>
        <trans-unit id="96cc920a42ed7b296307f756480841c1366430ee" translate="yes" xml:space="preserve">
          <source>The path has the attribute with special value &quot;true&quot;; this is specified by listing only the name of the attribute in the attribute list.</source>
          <target state="translated">경로에는 특수 값 &quot;true&quot;를 갖는 속성이 있습니다. 이것은 속성 목록에 속성 이름 만 나열하여 지정됩니다.</target>
        </trans-unit>
        <trans-unit id="f3d259c7dde8e69cba5e131da2dcac58054c5102" translate="yes" xml:space="preserve">
          <source>The path has the attribute with specified string value; this is specified by listing the name of the attribute followed by an equal sign &lt;code&gt;=&lt;/code&gt; and its value in the attribute list.</source>
          <target state="translated">경로에는 지정된 문자열 값을 가진 속성이 있습니다. 이것은 속성 이름과 등호 &lt;code&gt;=&lt;/code&gt; 및 속성 값을 속성 목록에 나열하여 지정됩니다.</target>
        </trans-unit>
        <trans-unit id="9a89a340b481b20bfabef5b1bcb5482c1e173e57" translate="yes" xml:space="preserve">
          <source>The path to a list of object names (i.e. one unabbreviated SHA-1 per line) that are known to be broken in a non-fatal way and should be ignored. On versions of Git 2.20 and later comments (&lt;code&gt;#&lt;/code&gt;), empty lines, and any leading and trailing whitespace is ignored. Everything but a SHA-1 per line will error out on older versions.</source>
          <target state="translated">치명적이지 않은 방식으로 손상되어 무시해야하는 개체 이름 목록 (즉, 줄당 하나의 SHA-1 하나)에 대한 경로입니다. Git 2.20 및 이후 버전의 주석 ( &lt;code&gt;#&lt;/code&gt; ), 빈 줄 및 선행 및 후행 공백은 무시됩니다. 라인 당 SHA-1을 제외한 모든 것은 이전 버전에서 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="66bacdcfb6546645ce51a1173beecea036fe198b" translate="yes" xml:space="preserve">
          <source>The path to higher software quality is significantly improved software testing.</source>
          <target state="translated">소프트웨어 품질 향상의 길은 소프트웨어 테스트를 크게 개선하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="a62f8e77f19dbb91947274f4224d3b2000deceef" translate="yes" xml:space="preserve">
          <source>The path with which the credential will be used. E.g., for accessing a remote https repository, this will be the repository&amp;rsquo;s path on the server.</source>
          <target state="translated">신임 정보가 사용될 경로입니다. 예를 들어 원격 https 리포지토리에 액세스하려면 서버의 리포지토리 경로가됩니다.</target>
        </trans-unit>
        <trans-unit id="75a6542b84624c1ec2a2753cb02bac2dc12deb38" translate="yes" xml:space="preserve">
          <source>The path within the &amp;lt;repository&amp;gt; that the action is performed on, for those actions that require it.</source>
          <target state="translated">조치가 필요한 &amp;lt;repository&amp;gt; 내의 경로.</target>
        </trans-unit>
        <trans-unit id="42c5355b2496aa717e00373f3c96e2614e271309" translate="yes" xml:space="preserve">
          <source>The pathname of a file containing previously stored cookie lines, which should be used in the Git http session, if they match the server. The file format of the file to read cookies from should be plain HTTP headers or the Netscape/Mozilla cookie file format (see &lt;code&gt;curl(1)&lt;/code&gt;). NOTE that the file specified with http.cookieFile is used only as input unless http.saveCookies is set.</source>
          <target state="translated">이전에 저장된 쿠키 행을 포함하는 파일의 경로 이름으로, 서버와 일치하는 경우 Git http 세션에서 사용해야합니다. 쿠키를 읽을 파일의 파일 형식은 일반 HTTP 헤더 또는 Netscape / Mozilla 쿠키 파일 형식이어야합니다 ( &lt;code&gt;curl(1)&lt;/code&gt; 참조 ). http.cookieFile로 지정된 파일은 http.saveCookies가 설정되어 있지 않으면 입력으로 만 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="cdb891f79fbec881d22446bf8cf74ef0a3e451e0" translate="yes" xml:space="preserve">
          <source>The paths mentioned in the output, unlike many other Git commands, are made relative to the current directory if you are working in a subdirectory (this is on purpose, to help cutting and pasting). See the status.relativePaths config option below.</source>
          <target state="translated">다른 Git 명령과 달리 출력에 언급 된 경로는 하위 디렉토리에서 작업하는 경우 현재 디렉토리를 기준으로 만들어집니다 (절삭 및 붙여 넣기를 돕기위한 것임). 아래 status.relativePaths 구성 옵션을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="ae851010ea42ad696931dec57e7a58d6d0655b81" translate="yes" xml:space="preserve">
          <source>The pathspecs are used to limit the world diff operates in. They remove the filepairs outside the specified sets of pathnames. E.g. If the input set of filepairs included:</source>
          <target state="translated">pathspec은 월드 diff가 작동하는 것을 제한하는 데 사용됩니다. 지정된 pathname 세트 외부의 파일 쌍을 제거합니다. 예를 들어 입력 파일 세트 세트가 포함 된 경우 :</target>
        </trans-unit>
        <trans-unit id="a35fe6e03b5cf8e686f61a60362e87d3cf937722" translate="yes" xml:space="preserve">
          <source>The pattern &quot;foo/*&quot;, matches &quot;foo/test.json&quot; (a regular file), &quot;foo/bar&quot; (a directory), but it does not match &quot;foo/bar/hello.c&quot; (a regular file), as the asterisk in the pattern does not match &quot;bar/hello.c&quot; which has a slash in it.</source>
          <target state="translated">&quot;foo / *&quot;패턴은 &quot;foo / test.json&quot;(일반 파일), &quot;foo / bar&quot;(디렉토리)와 일치하지만 &quot;foo / bar / hello.c&quot;(일반 파일)와 일치하지 않습니다 ), 패턴의 별표가 슬래시가있는 &quot;bar / hello.c&quot;와 일치하지 않기 때문입니다.</target>
        </trans-unit>
        <trans-unit id="472a6ff8d8e6e0153adf76e5ad83f89df7215b9f" translate="yes" xml:space="preserve">
          <source>The pattern &lt;code&gt;doc/frotz&lt;/code&gt; and &lt;code&gt;/doc/frotz&lt;/code&gt; have the same effect in any &lt;code&gt;.gitignore&lt;/code&gt; file. In other words, a leading slash is not relevant if there is already a middle slash in the pattern.</source>
          <target state="translated">패턴 &lt;code&gt;doc/frotz&lt;/code&gt; 및 &lt;code&gt;/doc/frotz&lt;/code&gt; 어떤에서 같은 효과가 &lt;code&gt;.gitignore&lt;/code&gt; 의 파일을. 즉, 패턴에 중간 슬래시가있는 경우 선행 슬래시는 관련이 없습니다.</target>
        </trans-unit>
        <trans-unit id="7f3e3da749b8fed6cc11585c7aa5dbe77eee53ad" translate="yes" xml:space="preserve">
          <source>The pattern &lt;code&gt;foo/&lt;/code&gt; will match a directory &lt;code&gt;foo&lt;/code&gt; and paths underneath it, but will not match a regular file or a symbolic link &lt;code&gt;foo&lt;/code&gt; (this is consistent with the way how pathspec works in general in Git)</source>
          <target state="translated">패턴 &lt;code&gt;foo/&lt;/code&gt; 는 디렉토리 &lt;code&gt;foo&lt;/code&gt; 및 그 아래의 경로와 일치하지만 일반 파일 또는 기호 링크 &lt;code&gt;foo&lt;/code&gt; 와 일치하지 않습니다 (이것은 경로 스펙이 Git에서 일반적으로 작동하는 방식과 일치합니다)</target>
        </trans-unit>
        <trans-unit id="32166ee916b00891724c1bd52223b5e1e2d10da0" translate="yes" xml:space="preserve">
          <source>The pattern &lt;code&gt;hello.*&lt;/code&gt; matches any file or folder whose name begins with &lt;code&gt;hello&lt;/code&gt;. If one wants to restrict this only to the directory and not in its subdirectories, one can prepend the pattern with a slash, i.e. &lt;code&gt;/hello.*&lt;/code&gt;; the pattern now matches &lt;code&gt;hello.txt&lt;/code&gt;, &lt;code&gt;hello.c&lt;/code&gt; but not &lt;code&gt;a/hello.java&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;hello.*&lt;/code&gt; 패턴 은 이름이 &lt;code&gt;hello&lt;/code&gt; 로 시작하는 파일 또는 폴더와 일치합니다 . 서브 디렉토리가 아닌 디렉토리로만 제한하려는 경우 슬래시 (예 : &lt;code&gt;/hello.*&lt;/code&gt; )를 사용 하여 패턴을 추가 할 수 있습니다 . 패턴은 이제 &lt;code&gt;hello.txt&lt;/code&gt; , &lt;code&gt;hello.c&lt;/code&gt; 와 일치 하지만 &lt;code&gt;a/hello.java&lt;/code&gt; 와는 일치 하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="b35cb663783a3682a66157f3dc9fd508efdfceba" translate="yes" xml:space="preserve">
          <source>The pattern can contain standard globbing wildcards and two additional ones, &lt;code&gt;**/&lt;/code&gt; and &lt;code&gt;/**&lt;/code&gt;, that can match multiple path components. Please refer to &lt;a href=&quot;gitignore&quot;&gt;gitignore[5]&lt;/a&gt; for details. For convenience:</source>
          <target state="translated">이 패턴에는 표준 경로 지정 와일드 카드와 여러 경로 구성 요소와 일치 할 수있는 두 개의 추가 &lt;code&gt;**/&lt;/code&gt; 및 &lt;code&gt;/**&lt;/code&gt; 가 포함될 수 있습니다 . 자세한 내용은 &lt;a href=&quot;gitignore&quot;&gt;gitignore [5]&lt;/a&gt; 를 참조하십시오. 편의상:</target>
        </trans-unit>
        <trans-unit id="ae88d32c3f9079756948f2fdc8ae4c4c2e834b93" translate="yes" xml:space="preserve">
          <source>The patterns given should not begin with &lt;code&gt;refs/heads&lt;/code&gt;, &lt;code&gt;refs/tags&lt;/code&gt;, or &lt;code&gt;refs/remotes&lt;/code&gt; when applied to &lt;code&gt;--branches&lt;/code&gt;, &lt;code&gt;--tags&lt;/code&gt;, or &lt;code&gt;--remotes&lt;/code&gt;, respectively, and they must begin with &lt;code&gt;refs/&lt;/code&gt; when applied to &lt;code&gt;--glob&lt;/code&gt; or &lt;code&gt;--all&lt;/code&gt;. If a trailing &lt;code&gt;/*&lt;/code&gt; is intended, it must be given explicitly.</source>
          <target state="translated">로 시작하지 않아야 주어진 패턴 &lt;code&gt;refs/heads&lt;/code&gt; , &lt;code&gt;refs/tags&lt;/code&gt; , 또는 &lt;code&gt;refs/remotes&lt;/code&gt; 에 적용 할 때 &lt;code&gt;--branches&lt;/code&gt; 는 , &lt;code&gt;--tags&lt;/code&gt; , 또는 &lt;code&gt;--remotes&lt;/code&gt; 는 각각, 그들은 시작해야 &lt;code&gt;refs/&lt;/code&gt; 에 적용 할 때 &lt;code&gt;--glob&lt;/code&gt; 또는 &lt;code&gt;--all&lt;/code&gt; . 후행 &lt;code&gt;/*&lt;/code&gt; 가 의도 된 경우 명시 적으로 제공해야합니다.</target>
        </trans-unit>
        <trans-unit id="86b0de7f6b1176e8c07c5aaa523447c3abd4915b" translate="yes" xml:space="preserve">
          <source>The performance format target (PERF) is a column-based format to replace GIT_TRACE_PERFORMANCE and is suitable for development and testing, possibly to complement tools like gprof. This format is enabled with the &lt;code&gt;GIT_TRACE2_PERF&lt;/code&gt; environment variable or the &lt;code&gt;trace2.perfTarget&lt;/code&gt; system or global config setting.</source>
          <target state="translated">PERF (Performance Format Target)는 GIT_TRACE_PERFORMANCE를 대체하는 열 기반 형식이며 개발 및 테스트에 적합하며 gprof와 같은 도구를 보완 할 수 있습니다. 이 형식은 &lt;code&gt;GIT_TRACE2_PERF&lt;/code&gt; 환경 변수 또는 &lt;code&gt;trace2.perfTarget&lt;/code&gt; 시스템 또는 글로벌 구성 설정으로 사용 가능합니다.</target>
        </trans-unit>
        <trans-unit id="506071bbd9d0908b14e8f015ca1b0ff23e4ec21e" translate="yes" xml:space="preserve">
          <source>The performance of git-filter-branch is glacially slow; its design makes it impossible for a backward-compatible implementation to ever be fast:</source>
          <target state="translated">git-filter-branch의 성능은 빙하 적으로 느립니다. 그것의 디자인은 이전 버전과 호환되는 구현이 빠를 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="d698b970e30734158c98cc5647b57a259a47bb36" translate="yes" xml:space="preserve">
          <source>The person who put a piece of code into Git.</source>
          <target state="translated">코드 조각을 Git에 넣은 사람.</target>
        </trans-unit>
        <trans-unit id="81b84527afb0ae2e697e75bbd7638af25fa12741" translate="yes" xml:space="preserve">
          <source>The pickaxe search is described in &lt;a href=&quot;git-log&quot;&gt;git-log[1]&lt;/a&gt; (the description of &lt;code&gt;-S&amp;lt;string&amp;gt;&lt;/code&gt; option, which refers to pickaxe entry in &lt;a href=&quot;gitdiffcore&quot;&gt;gitdiffcore[7]&lt;/a&gt; for more details).</source>
          <target state="translated">곡괭이 검색은 &lt;a href=&quot;git-log&quot;&gt;git-log [1]&lt;/a&gt; ( 자세한 내용 은 &lt;a href=&quot;gitdiffcore&quot;&gt;gitdiffcore [7]의&lt;/a&gt; 곡괭이 항목을 나타내는 &lt;code&gt;-S&amp;lt;string&amp;gt;&lt;/code&gt; 옵션에 대한 설명)에 설명되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="525e6a0e6ee3d9fa31ab39c46532aa0c693111e1" translate="yes" xml:space="preserve">
          <source>The placeholders are:</source>
          <target state="translated">자리 표시자는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="1651136b42ed906ec527c0b5bb6ead2e015774c3" translate="yes" xml:space="preserve">
          <source>The point of this helper is to reduce the number of times you must type your username or password. For example:</source>
          <target state="translated">이 도우미의 요점은 사용자 이름이나 암호를 입력해야하는 횟수를 줄이는 것입니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="c89cea9d29e269d3d21a2bb103d39e43b1e539d2" translate="yes" xml:space="preserve">
          <source>The porcelain format</source>
          <target state="translated">도자기 형식</target>
        </trans-unit>
        <trans-unit id="26e08a1995b67cc0010521ba6bed170106483645" translate="yes" xml:space="preserve">
          <source>The porcelain format generally suppresses commit information that has already been seen. For example, two lines that are blamed to the same commit will both be shown, but the details for that commit will be shown only once. This is more efficient, but may require more state be kept by the reader. The &lt;code&gt;--line-porcelain&lt;/code&gt; option can be used to output full commit information for each line, allowing simpler (but less efficient) usage like:</source>
          <target state="translated">도자기 형식은 일반적으로 이미 본 커밋 정보를 억제합니다. 예를 들어, 동일한 커밋으로 비난 된 두 줄이 모두 표시되지만 해당 커밋에 대한 세부 정보는 한 번만 표시됩니다. 이것은 더 효율적이지만 독자가 더 많은 상태를 유지해야 할 수도 있습니다. &lt;code&gt;--line-porcelain&lt;/code&gt; 옵션은 전체 같은 간단한 (하지만 비효율적) 사용을 허용, 각 라인에 대한 정보를 커밋 출력에 사용할 수 있습니다 :</target>
        </trans-unit>
        <trans-unit id="20c54b7279b5d1b2be6928d44083be1fd00dfbb8" translate="yes" xml:space="preserve">
          <source>The porcelain format has a line per attribute. Attributes are listed with a label and value separated by a single space. Boolean attributes (like &lt;code&gt;bare&lt;/code&gt; and &lt;code&gt;detached&lt;/code&gt;) are listed as a label only, and are only present if and only if the value is true. The first attribute of a worktree is always &lt;code&gt;worktree&lt;/code&gt;, an empty line indicates the end of the record. For example:</source>
          <target state="translated">도자기 형식에는 속성 당 한 줄이 있습니다. 속성은 단일 공백으로 구분 된 레이블 및 값과 함께 나열됩니다. 부울 속성 ( &lt;code&gt;bare&lt;/code&gt; 및 &lt;code&gt;detached&lt;/code&gt; 등 )은 레이블로만 나열되며 값이 true 인 경우에만 나타납니다. 작업 트리의 첫 번째 속성은 항상 &lt;code&gt;worktree&lt;/code&gt; 이며 빈 줄은 레코드의 끝을 나타냅니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="a362940b066b853917862099c8e9ab263cba72b1" translate="yes" xml:space="preserve">
          <source>The port number to bind the gitweb httpd to. See &lt;a href=&quot;git-instaweb&quot;&gt;git-instaweb[1]&lt;/a&gt;.</source>
          <target state="translated">gitweb httpd를 바인딩 할 포트 번호. &lt;a href=&quot;git-instaweb&quot;&gt;git-instaweb [1]을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="0cecf31c324042fa16f4839249194885b3982bae" translate="yes" xml:space="preserve">
          <source>The port number to bind the httpd to. (Default: 1234)</source>
          <target state="translated">httpd를 바인딩 할 포트 번호입니다. (기본값 : 1234)</target>
        </trans-unit>
        <trans-unit id="735bfd35b5b101e4c116696c3cd1ebf6bc58faa9" translate="yes" xml:space="preserve">
          <source>The possible options are:</source>
          <target state="translated">가능한 옵션은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="8bc0e360ec6eefb74bc5a1aed65f13e846b6d915" translate="yes" xml:space="preserve">
          <source>The preferred strategy for rolling out a version bump (whether whole repository or for a single file) is to teach git to read the new format, and allow writing the new format with a config switch or command line option (for experimentation or for those who do not care about backwards compatibility with older gits). Then after a long period to allow the reading capability to become common, we may switch to writing the new format by default.</source>
          <target state="translated">버전 범프 (전체 저장소 또는 단일 파일에 관계없이)를 롤아웃하는 데 선호되는 전략은 git에게 새 형식을 읽도록 설정하고 구성 스위치 또는 명령 줄 옵션으로 실험 또는 이전 gits와의 하위 호환성에 대해서는 신경 쓰지 마십시오. 그런 다음 읽기 기능이 일반화되도록 오랜 시간이 지난 후 기본적으로 새 형식 쓰기로 전환 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="adf8f6f66c16d1ab5dcd5c39342b75931e439ba4" translate="yes" xml:space="preserve">
          <source>The prefix ability basically makes it trivial to use &lt;code&gt;git checkout-index&lt;/code&gt; as an &quot;export as tree&quot; function. Just read the desired tree into the index, and do:</source>
          <target state="translated">접두사 기능은 기본적으로 &lt;code&gt;git checkout-index&lt;/code&gt; 를 &quot;트리로 내보내기&quot;기능 으로 사용하는 것이 간단 합니다. 원하는 트리를 인덱스로 읽고 다음을 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="0f1fc4f35ab6b79f4468bd7525c0542dc9193da5" translate="yes" xml:space="preserve">
          <source>The previously introduced &lt;a href=&quot;git-add&quot;&gt;git-add[1]&lt;/a&gt; is just a wrapper for &lt;a href=&quot;git-update-index&quot;&gt;git-update-index[1]&lt;/a&gt;.</source>
          <target state="translated">이전에 소개 된 &lt;a href=&quot;git-add&quot;&gt;git-add [1]&lt;/a&gt; 은 &lt;a href=&quot;git-update-index&quot;&gt;git-update-index [1]&lt;/a&gt; 의 래퍼 일뿐 입니다.</target>
        </trans-unit>
        <trans-unit id="675ae216ecd575fef2e1ffa9eadeda52bdab6e90" translate="yes" xml:space="preserve">
          <source>The primary problem with rewriting the history of a branch has to do with merging. Suppose somebody fetches your branch and merges it into their branch, with a result something like this:</source>
          <target state="translated">브랜치 히스토리를 재 작성할 때의 주요 문제점은 병합과 관련이 있습니다. 누군가가 분기를 가져 와서 분기로 병합한다고 가정하면 다음과 같은 결과가 나타납니다.</target>
        </trans-unit>
        <trans-unit id="ff3dc4a94f1f540e3dd725f6eef6c2d405d85a87" translate="yes" xml:space="preserve">
          <source>The primary tool we&amp;rsquo;ve been using to create commits is &lt;code&gt;git-commit
-a&lt;/code&gt;, which creates a commit including every change you&amp;rsquo;ve made to your working tree. But what if you want to commit changes only to certain files? Or only certain changes to certain files?</source>
          <target state="translated">커밋을 만드는 데 사용했던 기본 도구는 &lt;code&gt;git-commit -a&lt;/code&gt; 이며 작업 트리의 모든 변경 사항을 포함하여 커밋을 만듭니다. 그러나 특정 파일에만 변경 사항을 커밋하려면 어떻게해야합니까? 아니면 특정 파일에 대한 특정 변경 사항 만 있습니까?</target>
        </trans-unit>
        <trans-unit id="bc32172ebad82b3a8531284b76fc91d0e2655fc8" translate="yes" xml:space="preserve">
          <source>The protection it offers over &lt;code&gt;--force&lt;/code&gt; is ensuring that subsequent changes your work wasn&amp;rsquo;t based on aren&amp;rsquo;t clobbered, but this is trivially defeated if some background process is updating refs in the background. We don&amp;rsquo;t have anything except the remote tracking info to go by as a heuristic for refs you&amp;rsquo;re expected to have seen &amp;amp; are willing to clobber.</source>
          <target state="translated">그것이 &lt;code&gt;--force&lt;/code&gt; 로 제공하는 보호는 작업이 기반으로하지 않은 후속 변경 사항이 방해받지 않도록 보장하지만 일부 백그라운드 프로세스가 백그라운드에서 참조를 업데이트하면 사소하게 무시됩니다. 원격 추적 정보 이외의 다른 정보는 없습니다.</target>
        </trans-unit>
        <trans-unit id="c8ef7004934ae749808b9e22322b2c11275f98e4" translate="yes" xml:space="preserve">
          <source>The protocol names currently used by git are:</source>
          <target state="translated">현재 git에서 사용되는 프로토콜 이름은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="19913c2c5a680884fd5ab271ea84dfe92e10bf53" translate="yes" xml:space="preserve">
          <source>The protocol over which the credential will be used (e.g., &lt;code&gt;https&lt;/code&gt;).</source>
          <target state="translated">신임 정보가 사용될 프로토콜 (예 : &lt;code&gt;https&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="27c53e4d1c63b3496c93b1976851fe0522937712" translate="yes" xml:space="preserve">
          <source>The provided options must not contain a NUL or LF character.</source>
          <target state="translated">제공된 옵션에는 NUL 또는 LF 문자가 포함되지 않아야합니다.</target>
        </trans-unit>
        <trans-unit id="5fb1f43ddd5fc4b8ac18d086f82e6f88c9ed5855" translate="yes" xml:space="preserve">
          <source>The purpose of gitignore files is to ensure that certain files not tracked by Git remain untracked.</source>
          <target state="translated">gitignore 파일의 목적은 Git이 추적하지 않는 특정 파일이 추적되지 않도록하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="a2b9675d20ab3c1e80e15b296d660914f6ea2131" translate="yes" xml:space="preserve">
          <source>The purpose of the hook is to edit the message file in place, and it is not suppressed by the &lt;code&gt;--no-verify&lt;/code&gt; option. A non-zero exit means a failure of the hook and aborts the commit. It should not be used as replacement for pre-commit hook.</source>
          <target state="translated">후크의 목적은 메시지 파일을 제자리에서 편집하는 것이며 &lt;code&gt;--no-verify&lt;/code&gt; 옵션으로 억제되지 않습니다 . 0이 아닌 종료는 후크 실패를 의미하며 커밋을 중단합니다. 사전 커미트 후크를 대체하는 데 사용해서는 안됩니다.</target>
        </trans-unit>
        <trans-unit id="383a661ab7ffdec395082f1f22f245f53263885b" translate="yes" xml:space="preserve">
          <source>The push URL of a remote repository. See &lt;a href=&quot;git-push&quot;&gt;git-push[1]&lt;/a&gt;.</source>
          <target state="translated">원격 저장소의 푸시 URL입니다. &lt;a href=&quot;git-push&quot;&gt;git-push [1]을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="e8cd29a2b80ae7f4721c7a9c69324052af609357" translate="yes" xml:space="preserve">
          <source>The push done by the other person updated the branch that used to point at commit X to point at commit A. It is a fast-forward.</source>
          <target state="translated">다른 사람이 한 푸시는 커밋 X가 커밋 A를 가리 키도록 사용했던 브랜치를 업데이트했습니다.</target>
        </trans-unit>
        <trans-unit id="79a20eedac198c71849aef6d1fe1606ea1ee319f" translate="yes" xml:space="preserve">
          <source>The quilt series file.</source>
          <target state="translated">이불 시리즈 파일.</target>
        </trans-unit>
        <trans-unit id="eb2f9ed5ec284eab8396a9b582f3da5582d364ca" translate="yes" xml:space="preserve">
          <source>The raw output format from &quot;git-diff-index&quot;, &quot;git-diff-tree&quot;, &quot;git-diff-files&quot; and &quot;git diff --raw&quot; are very similar.</source>
          <target state="translated">&quot;git-diff-index&quot;, &quot;git-diff-tree&quot;, &quot;git-diff-files&quot;및 &quot;git diff --raw&quot;의 원시 출력 형식은 매우 유사합니다.</target>
        </trans-unit>
        <trans-unit id="a6ab1028c44c2d54846a9217b4a7ad959d178f38" translate="yes" xml:space="preserve">
          <source>The reachability bitmap is currently paired directly with a single packfile, using the pack-order as the object order to hopefully compress the bitmaps well using run-length encoding. This could be extended to pair a reachability bitmap with a multi-pack-index. If the multi-pack-index is extended to store a &quot;stable object order&quot; (a function Order(hash) = integer that is constant for a given hash, even as the multi-pack-index is updated) then a reachability bitmap could point to a multi-pack-index and be updated independently.</source>
          <target state="translated">도달 가능성 비트 맵은 현재 실행 순서 인코딩을 사용하여 비트 맵을 잘 압축하기 위해 팩 순서를 객체 순서로 사용하여 단일 팩 파일과 직접 쌍을 이룹니다. 도달 가능성 비트 맵을 다중 팩 인덱스와 쌍으로 확장 할 수 있습니다. 멀티 팩 인덱스가 &quot;안정된 객체 순서&quot;(멀티 팩 인덱스가 업데이트 되더라도 주어진 해시에 대해 상수 인 함수 Order (hash) = 정수)를 저장하도록 확장되면 도달 가능성 비트 맵은 멀티 팩 인덱스를 가리키고 독립적으로 업데이트하십시오.</target>
        </trans-unit>
        <trans-unit id="0aca04dff2f76e52dde4dcdd1542bfe4e1470100" translate="yes" xml:space="preserve">
          <source>The reason fast-import uses &lt;code&gt;:&lt;/code&gt; to denote a mark reference is this character is not legal in a Git branch name. The leading &lt;code&gt;:&lt;/code&gt; makes it easy to distinguish between the mark 42 (&lt;code&gt;:42&lt;/code&gt;) and the branch 42 (&lt;code&gt;42&lt;/code&gt; or &lt;code&gt;refs/heads/42&lt;/code&gt;), or an abbreviated SHA-1 which happened to consist only of base-10 digits.</source>
          <target state="translated">빠른 가져 오기가 &lt;code&gt;:&lt;/code&gt; 를 사용하여 마크 참조를 표시하는 이유 는이 문자가 Git 브랜치 이름에 적합하지 않기 때문입니다. 선행 &lt;code&gt;:&lt;/code&gt; 마크 42 ( &lt;code&gt;:42&lt;/code&gt; )와 분기 42 ( &lt;code&gt;42&lt;/code&gt; 또는 &lt;code&gt;refs/heads/42&lt;/code&gt; ) 또는 10 진수만으로 구성된 약어 SHA-1을 쉽게 구분할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1aba410e8fcfe74102eea2fcf73898889acee3ed" translate="yes" xml:space="preserve">
          <source>The reason it doesn&amp;rsquo;t error out when provided without &lt;code&gt;--prune&lt;/code&gt; or its config versions is for flexibility of the configured versions, and to maintain a 1=1 mapping between what the command line flags do, and what the configuration versions do.</source>
          <target state="translated">&lt;code&gt;--prune&lt;/code&gt; 또는 구성 버전 없이 제공 될 때 오류가 발생하지 않는 이유 는 구성된 버전의 유연성과 명령 줄 플래그의 기능과 구성 버전의 기능간에 1 = 1 매핑을 유지하기 위함 입니다.</target>
        </trans-unit>
        <trans-unit id="b2defd752d90b2a93e28eb3efe0e516f3fc264fc" translate="yes" xml:space="preserve">
          <source>The rebase will stop where &lt;code&gt;pick&lt;/code&gt; has been replaced with &lt;code&gt;edit&lt;/code&gt; or when a step in the list fails to mechanically resolve conflicts and needs your help. When you are done editing and/or resolving conflicts you can continue with &lt;code&gt;git rebase --continue&lt;/code&gt;. If you decide that things are getting too hairy, you can always bail out with &lt;code&gt;git rebase
--abort&lt;/code&gt;. Even after the rebase is complete, you can still recover the original branch by using the &lt;a href=&quot;#reflogs&quot;&gt;reflog&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;pick&lt;/code&gt; 이 &lt;code&gt;edit&lt;/code&gt; 으로 대체 되거나 목록의 단계가 충돌을 기계적으로 해결하지 못해 도움이 필요한 경우 rebase가 중지됩니다 . 충돌 편집 및 / 또는 해결이 끝나면 &lt;code&gt;git rebase --continue&lt;/code&gt; 를 계속할 수 있습니다 . 물건이 너무 털이 있다고 결정하면 언제든지 &lt;code&gt;git rebase --abort&lt;/code&gt; 구제 할 수 있습니다 . 리베이스가 완료된 후에도 &lt;a href=&quot;#reflogs&quot;&gt;reflog&lt;/a&gt; 를 사용하여 원래 분기를 복구 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="939cf091c711a461fc7775d9278b48a4457f30c1" translate="yes" xml:space="preserve">
          <source>The ref namespace is hierarchical. Different subhierarchies are used for different purposes (e.g. the &lt;code&gt;refs/heads/&lt;/code&gt; hierarchy is used to represent local branches).</source>
          <target state="translated">참조 네임 스페이스는 계층 적입니다. 서로 다른 하위 계층이 서로 다른 목적으로 사용됩니다 (예 : 참조 &lt;code&gt;refs/heads/&lt;/code&gt; 계층이 로컬 분기를 나타내는 데 사용됨).</target>
        </trans-unit>
        <trans-unit id="d11d2f57237e560f1ae2f7da112ae694568b2d78" translate="yes" xml:space="preserve">
          <source>The ref which the given symbolic ref refers to. If not a symbolic ref, nothing is printed. Respects the &lt;code&gt;:short&lt;/code&gt;, &lt;code&gt;:lstrip&lt;/code&gt; and &lt;code&gt;:rstrip&lt;/code&gt; options in the same way as &lt;code&gt;refname&lt;/code&gt; above.</source>
          <target state="translated">주어진 기호 참조가 참조하는 참조. 기호 참조가 아닌 경우 아무것도 인쇄되지 않습니다. 위의 &lt;code&gt;refname&lt;/code&gt; 과 같은 방식으로 &lt;code&gt;:short&lt;/code&gt; , &lt;code&gt;:lstrip&lt;/code&gt; 및 &lt;code&gt;:rstrip&lt;/code&gt; 옵션을 존중합니다 .</target>
        </trans-unit>
        <trans-unit id="09256802b46aa557905f47df9fc0a1148d341199" translate="yes" xml:space="preserve">
          <source>The reflogs are kept by default for 30 days, after which they may be pruned. See &lt;a href=&quot;git-reflog&quot;&gt;git-reflog[1]&lt;/a&gt; and &lt;a href=&quot;git-gc&quot;&gt;git-gc[1]&lt;/a&gt; to learn how to control this pruning, and see the &quot;SPECIFYING REVISIONS&quot; section of &lt;a href=&quot;gitrevisions&quot;&gt;gitrevisions[7]&lt;/a&gt; for details.</source>
          <target state="translated">reflog는 기본적으로 30 일 동안 유지되며 그 후에 정리 될 수 있습니다. 참조 &lt;a href=&quot;git-reflog&quot;&gt;자식-reflog [1]&lt;/a&gt; 와 &lt;a href=&quot;git-gc&quot;&gt;자식-GC [1]&lt;/a&gt; 의 &quot;개정 이력을 지정하기&quot;섹션이 가지 치기를 제어하고 참조하는 방법을 배울 수 &lt;a href=&quot;gitrevisions&quot;&gt;gitrevisions [7]&lt;/a&gt; 세부 사항을.</target>
        </trans-unit>
        <trans-unit id="29e87ce112fa8f38582e71025c0e3c162626939f" translate="yes" xml:space="preserve">
          <source>The refname parameter is relative to $GIT_DIR; e.g. for the master head this is &quot;refs/heads/master&quot;. The two sha1 arguments are the object names for the refname before and after the update. Note that the hook is called before the refname is updated, so either sha1-old is 0{40} (meaning there is no such ref yet), or it should match what is recorded in refname.</source>
          <target state="translated">refname 매개 변수는 $ GIT_DIR에 상대적입니다. 예를 들어 마스터 헤드의 경우 &quot;refs / heads / master&quot;입니다. 두 sha1 인수는 업데이트 전후의 참조 이름에 대한 객체 이름입니다. 참조 이름이 업데이트되기 전에 후크가 호출되므로 sha1-old는 0 {40} (아직 그러한 참조가 없음을 의미 함)이거나 참조 이름에 기록 된 것과 일치해야합니다.</target>
        </trans-unit>
        <trans-unit id="21810fe3549bedbdcfb85519d93701f4c1ec8042" translate="yes" xml:space="preserve">
          <source>The refname value is relative to $GIT_DIR; e.g. for the master head this is &quot;refs/heads/master&quot;. The two sha1 values before each refname are the object names for the refname before and after the update. Refs that were created will have sha1-old equal to 0{40}, while refs that were deleted will have sha1-new equal to 0{40}, otherwise sha1-old and sha1-new should be valid objects in the repository.</source>
          <target state="translated">참조 이름 값은 $ GIT_DIR에 상대적입니다. 예를 들어 마스터 헤드의 경우 &quot;refs / heads / master&quot;입니다. 각 참조 이름 앞의 두 sha1 값은 업데이트 전후의 참조 이름에 대한 객체 이름입니다. 작성된 참조는 sha1이 0 {40}이고, 삭제 된 참조는 sha1이 0 {40}과 같으며, 그렇지 않으면 sha1-old 및 sha1new는 저장소에서 유효한 오브젝트 여야합니다.</target>
        </trans-unit>
        <trans-unit id="f7cd6bb7198b77eda24e90f3bdabb1a4fb56aeb0" translate="yes" xml:space="preserve">
          <source>The refname value is relative to $GIT_DIR; e.g. for the master head this is &quot;refs/heads/master&quot;. The two sha1 values before each refname are the object names for the refname before and after the update. Refs to be created will have sha1-old equal to 0{40}, while refs to be deleted will have sha1-new equal to 0{40}, otherwise sha1-old and sha1-new should be valid objects in the repository.</source>
          <target state="translated">참조 이름 값은 $ GIT_DIR에 상대적입니다. 예를 들어 마스터 헤드의 경우 &quot;refs / heads / master&quot;입니다. 각 참조 이름 앞의 두 sha1 값은 업데이트 전후의 참조 이름에 대한 객체 이름입니다. 생성 된 참조는 sha1-old는 0 {40}이고, 삭제 될 참조는 sha1-new는 0 {40}입니다. 그렇지 않으면 sha1-old 및 sha1-new는 리포지토리에서 유효한 객체 여야합니다.</target>
        </trans-unit>
        <trans-unit id="ce26e3499eea5a4c24942a8e072b3a9539557d0b" translate="yes" xml:space="preserve">
          <source>The regex can also be set via a diff driver or configuration option, see &lt;a href=&quot;gitattributes&quot;&gt;gitattributes[5]&lt;/a&gt; or &lt;a href=&quot;git-config&quot;&gt;git-config[1]&lt;/a&gt;. Giving it explicitly overrides any diff driver or configuration setting. Diff drivers override configuration settings.</source>
          <target state="translated">정규식은 diff 드라이버 또는 구성 옵션을 통해 설정할 수도 있습니다 ( &lt;a href=&quot;gitattributes&quot;&gt;gitattributes [5]&lt;/a&gt; 또는 &lt;a href=&quot;git-config&quot;&gt;git-config [1] 참조)&lt;/a&gt; . 이를 제공하면 diff 드라이버 또는 구성 설정이 명시 적으로 무시됩니다. Diff 드라이버는 구성 설정보다 우선합니다.</target>
        </trans-unit>
        <trans-unit id="db9cbae31eee7dd0453a2f75d2431a49c7ce5a43" translate="yes" xml:space="preserve">
          <source>The regex must capture the source branch name in $1.</source>
          <target state="translated">정규식은 소스 분기 이름을 $ 1로 캡처해야합니다.</target>
        </trans-unit>
        <trans-unit id="2f22e3781909efae9d373f9fa46942441b8a264c" translate="yes" xml:space="preserve">
          <source>The regular expression that the diff driver should use to recognize the hunk header. A built-in pattern may also be used. See &lt;a href=&quot;gitattributes&quot;&gt;gitattributes[5]&lt;/a&gt; for details.</source>
          <target state="translated">diff 드라이버가 덩어리 헤더를 인식하는 데 사용해야하는 정규식입니다. 내장 패턴을 사용할 수도 있습니다. 자세한 내용은 &lt;a href=&quot;gitattributes&quot;&gt;gitattributes [5]&lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="4211f7342bdc098f581fc9d7939f84dc24cd9689" translate="yes" xml:space="preserve">
          <source>The regular expression that the diff driver should use to split words in a line. See &lt;a href=&quot;gitattributes&quot;&gt;gitattributes[5]&lt;/a&gt; for details.</source>
          <target state="translated">diff 드라이버가 단어를 한 줄로 나눌 때 사용해야하는 정규식입니다. 자세한 내용은 &lt;a href=&quot;gitattributes&quot;&gt;gitattributes [5]&lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="f0619f2eb83a7faf485cba23bd4bbef8fb0cb4dd" translate="yes" xml:space="preserve">
          <source>The remainder of the line, after stripping the spaces, is used as the help associated to the option.</source>
          <target state="translated">공백을 제거한 후 나머지 줄은 옵션과 관련된 도움말로 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="19c5350e9da63f63a8abbccc7168a03dfd13ebac" translate="yes" xml:space="preserve">
          <source>The remaining features cannot be overridden on a per project basis.</source>
          <target state="translated">나머지 기능은 프로젝트별로 재정의 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="303228bfc99fc67a561e0782dc3e0ceb08c259bb" translate="yes" xml:space="preserve">
          <source>The remote branch name for a submodule, used by &lt;code&gt;git submodule
update --remote&lt;/code&gt;. Set this option to override the value found in the &lt;code&gt;.gitmodules&lt;/code&gt; file. See &lt;a href=&quot;git-submodule&quot;&gt;git-submodule[1]&lt;/a&gt; and &lt;a href=&quot;gitmodules&quot;&gt;gitmodules[5]&lt;/a&gt; for details.</source>
          <target state="translated">&lt;code&gt;git submodule update --remote&lt;/code&gt; 의해 사용되는 서브 모듈의 원격 브랜치 이름 . &lt;code&gt;.gitmodules&lt;/code&gt; 파일 에있는 값을 무시하려면이 옵션을 설정 하십시오. 자세한 내용은 &lt;a href=&quot;git-submodule&quot;&gt;git-submodule [1]&lt;/a&gt; 및 &lt;a href=&quot;gitmodules&quot;&gt;gitmodules [5]&lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="4fdf928f1cd746e7574e5e26895f63052b9e3300" translate="yes" xml:space="preserve">
          <source>The remote configuration is achieved using the &lt;code&gt;remote.origin.url&lt;/code&gt; and &lt;code&gt;remote.origin.fetch&lt;/code&gt; configuration variables. (See &lt;a href=&quot;git-config&quot;&gt;git-config[1]&lt;/a&gt;).</source>
          <target state="translated">원격 구성은 &lt;code&gt;remote.origin.url&lt;/code&gt; 및 &lt;code&gt;remote.origin.fetch&lt;/code&gt; 구성 변수를 사용하여 수행됩니다 . ( &lt;a href=&quot;git-config&quot;&gt;git-config [1] 참조&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="e7b65b070cfabceee72964f903404025034f8258" translate="yes" xml:space="preserve">
          <source>The remote end did not report the successful update of the ref, perhaps because of a temporary error on the remote side, a break in the network connection, or other transient error.</source>
          <target state="translated">원격 측에서 원격 측의 일시적인 오류, 네트워크 연결 끊기 또는 기타 일시적인 오류로 인해 참조의 성공적인 업데이트를보고하지 않았습니다.</target>
        </trans-unit>
        <trans-unit id="53c927a78ca0c11dc61a2c100f0e02c446d49374" translate="yes" xml:space="preserve">
          <source>The remote end refused the update. Usually caused by a hook on the remote side, or because the remote repository has one of the following safety options in effect: &lt;code&gt;receive.denyCurrentBranch&lt;/code&gt; (for pushes to the checked out branch), &lt;code&gt;receive.denyNonFastForwards&lt;/code&gt; (for forced non-fast-forward updates), &lt;code&gt;receive.denyDeletes&lt;/code&gt; or &lt;code&gt;receive.denyDeleteCurrent&lt;/code&gt;. See &lt;a href=&quot;git-config&quot;&gt;git-config[1]&lt;/a&gt;.</source>
          <target state="translated">원격 끝이 업데이트를 거부했습니다. 일반적으로 원격 측의 후크로 인해 발생하거나 원격 저장소에 다음 안전 옵션 중 하나가 적용되어 있기 때문에 발생합니다. &lt;code&gt;receive.denyCurrentBranch&lt;/code&gt; (체크 아웃 된 분기로 푸시), &lt;code&gt;receive.denyNonFastForwards&lt;/code&gt; (비 빨리 감기 강제 업데이트의 경우) ), &lt;code&gt;receive.denyDeletes&lt;/code&gt; 또는 &lt;code&gt;receive.denyDeleteCurrent&lt;/code&gt; 입니다. &lt;a href=&quot;git-config&quot;&gt;git-config [1]을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="c9422d899b3eadda77c8387091e37d96facb6c2f" translate="yes" xml:space="preserve">
          <source>The remote heads to update from. This is relative to $GIT_DIR (e.g. &quot;HEAD&quot;, &quot;refs/heads/master&quot;). When unspecified, update from all heads the remote side has.</source>
          <target state="translated">업데이트 할 원격 헤드. 이는 $ GIT_DIR과 관련이 있습니다 (예 : &quot;HEAD&quot;, &quot;refs / heads / master&quot;). 지정되지 않은 경우 원격 측에있는 모든 헤드에서 업데이트하십시오.</target>
        </trans-unit>
        <trans-unit id="0419c5b470511fe246bdc207ab1f44978b5929c7" translate="yes" xml:space="preserve">
          <source>The remote hostname for a network credential.</source>
          <target state="translated">네트워크 자격 증명의 원격 호스트 이름입니다.</target>
        </trans-unit>
        <trans-unit id="a7632b9807699f7e6cd146f3dd66e0428b068933" translate="yes" xml:space="preserve">
          <source>The remote ref that matches &amp;lt;src&amp;gt; is fetched, and if &amp;lt;dst&amp;gt; is not an empty string, an attempt is made to update the local ref that matches it.</source>
          <target state="translated">&amp;lt;src&amp;gt;와 일치하는 원격 참조가 페치되고 &amp;lt;dst&amp;gt;가 빈 문자열이 아닌 경우 해당 참조와 일치하는 로컬 참조를 업데이트하려고 시도합니다.</target>
        </trans-unit>
        <trans-unit id="282ef7eedc5a5bdee9740e04ed8375ea205f3da3" translate="yes" xml:space="preserve">
          <source>The remote refs to update.</source>
          <target state="translated">원격은 업데이트를 참조합니다.</target>
        </trans-unit>
        <trans-unit id="1126548b6dd0a73d0e4b3cf8a47f765ced5296ec" translate="yes" xml:space="preserve">
          <source>The remote to push to by default. Overrides &lt;code&gt;branch.&amp;lt;name&amp;gt;.remote&lt;/code&gt; for all branches, and is overridden by &lt;code&gt;branch.&amp;lt;name&amp;gt;.pushRemote&lt;/code&gt; for specific branches.</source>
          <target state="translated">기본적으로 푸시 할 리모콘입니다. 오버라이드 (override) &lt;code&gt;branch.&amp;lt;name&amp;gt;.remote&lt;/code&gt; 모든 지점에 대한, 그리고에 의해 무시되는 &lt;code&gt;branch.&amp;lt;name&amp;gt;.pushRemote&lt;/code&gt; 특정 지점에 대해.</target>
        </trans-unit>
        <trans-unit id="69cc315a656a6408b19c28c1250214347094ab33" translate="yes" xml:space="preserve">
          <source>The replaced object and the replacement object must be of the same type. This restriction can be bypassed using &lt;code&gt;-f&lt;/code&gt;.</source>
          <target state="translated">대체 된 오브젝트와 대체 오브젝트는 동일한 유형이어야합니다. 이 제한은 &lt;code&gt;-f&lt;/code&gt; 를 사용하여 무시할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="1ad56792b1c232c0733d7ad92a2a6edfcbfd7d1e" translate="yes" xml:space="preserve">
          <source>The report does not tell you anything about lines which have been deleted or replaced; you need to use a tool such as &lt;code&gt;git diff&lt;/code&gt; or the &quot;pickaxe&quot; interface briefly mentioned in the following paragraph.</source>
          <target state="translated">보고서는 삭제되거나 교체 된 라인에 대해서는 아무 것도 알려주지 않습니다. 다음 단락에서 간략하게 언급 한 &lt;code&gt;git diff&lt;/code&gt; 또는 &quot;pickaxe&quot;인터페이스 와 같은 도구를 사용해야합니다 .</target>
        </trans-unit>
        <trans-unit id="2c986c29f6ffa22f2a8c706bbb75b7aeb4461294" translate="yes" xml:space="preserve">
          <source>The repository URL to be pulled from.</source>
          <target state="translated">가져올 리포지토리 URL입니다.</target>
        </trans-unit>
        <trans-unit id="944d2d5ccd37faa608b4a3dce165543a5adf2fbf" translate="yes" xml:space="preserve">
          <source>The repository the action will be performed on.</source>
          <target state="translated">조치가 수행 될 저장소입니다.</target>
        </trans-unit>
        <trans-unit id="0e7c4601cfd7634812fd5318d08d4f529fb59bef" translate="yes" xml:space="preserve">
          <source>The repository to get a tar archive from.</source>
          <target state="translated">tar 아카이브를 가져올 저장소입니다.</target>
        </trans-unit>
        <trans-unit id="bc81f7623489d466e462d3597d8dc6ebd3c462a1" translate="yes" xml:space="preserve">
          <source>The repository to sync from.</source>
          <target state="translated">동기화 할 저장소입니다.</target>
        </trans-unit>
        <trans-unit id="3d7b45c15d44961366710f29c0592cfbaf8293a2" translate="yes" xml:space="preserve">
          <source>The repository to sync into.</source>
          <target state="translated">동기화 할 저장소입니다.</target>
        </trans-unit>
        <trans-unit id="85a32286326310d42bba4488de0fbceb84f9845b" translate="yes" xml:space="preserve">
          <source>The repository to update.</source>
          <target state="translated">업데이트 할 저장소입니다.</target>
        </trans-unit>
        <trans-unit id="15ea4cb9c0b7ca59bf54604e4e274c258d2ab5d8" translate="yes" xml:space="preserve">
          <source>The response of &lt;code&gt;fetch&lt;/code&gt; is broken into a number of sections separated by delimiter packets (0001), with each section beginning with its section header.</source>
          <target state="translated">&lt;code&gt;fetch&lt;/code&gt; 응답은 구분자 패킷 (0001)으로 구분 된 여러 섹션으로 구분되며 각 섹션은 섹션 헤더로 시작합니다.</target>
        </trans-unit>
        <trans-unit id="4f1a001f6b3f7c16917c0e0241e976b8717f870a" translate="yes" xml:space="preserve">
          <source>The rest of the documentation discusses &lt;code&gt;fsck.*&lt;/code&gt; for brevity, but the same applies for the corresponding &lt;code&gt;receive.fsck.*&lt;/code&gt; and &lt;code&gt;fetch.&amp;lt;msg-id&amp;gt;.*&lt;/code&gt;. variables.</source>
          <target state="translated">설명서의 나머지 부분에서는 간결성을 위해 &lt;code&gt;fsck.*&lt;/code&gt; 에 대해 설명 하지만 해당 &lt;code&gt;receive.fsck.*&lt;/code&gt; 및 &lt;code&gt;fetch.&amp;lt;msg-id&amp;gt;.*&lt;/code&gt; 에도 동일하게 적용됩니다 . 변수.</target>
        </trans-unit>
        <trans-unit id="ac10b74ced74e00c661f52e9250a42f47fd6add4" translate="yes" xml:space="preserve">
          <source>The result of &lt;code&gt;git merge-base --octopus A B C&lt;/code&gt; is &lt;code&gt;2&lt;/code&gt;, because &lt;code&gt;2&lt;/code&gt; is the best common ancestor of all commits.</source>
          <target state="translated">의 결과 &lt;code&gt;git merge-base --octopus A B C&lt;/code&gt; 이다 &lt;code&gt;2&lt;/code&gt; 때문에, &lt;code&gt;2&lt;/code&gt; 모든 커밋의 최선의 공통 조상이다.</target>
        </trans-unit>
        <trans-unit id="1e8fa948e18ddfaa21178042cd566eaada7aae80" translate="yes" xml:space="preserve">
          <source>The result of comparison is passed from these commands to what is internally called &quot;diffcore&quot;, in a format similar to what is output when the -p option is not used. E.g.</source>
          <target state="translated">비교 결과는 -p 옵션을 사용하지 않을 때 출력되는 것과 유사한 형식으로 이러한 명령에서 내부적으로 &quot;diffcore&quot;로 전달됩니다. 예 :</target>
        </trans-unit>
        <trans-unit id="d6478eddd3e6be6e1f0703d8450a597d1ea3dfe6" translate="yes" xml:space="preserve">
          <source>The result of such a bisection would be that we would find that H is the first bad commit, when in fact it&amp;rsquo;s B. So that would be wrong!</source>
          <target state="translated">그러한 이분법의 결과는 실제로 B 일 때 H가 첫 번째 잘못된 커밋임을 알게 될 것입니다.</target>
        </trans-unit>
        <trans-unit id="baad8b31b0f95aa1296c5c88ad34816424f2926e" translate="yes" xml:space="preserve">
          <source>The resulting directory proj.git contains a &quot;bare&quot; git repository&amp;mdash;​it is just the contents of the &lt;code&gt;.git&lt;/code&gt; directory, without any files checked out around it.</source>
          <target state="translated">결과 디렉토리 proj.git에는 &quot;bare&quot;git 저장소가 있습니다. 파일을 체크 아웃하지 않고 &lt;code&gt;.git&lt;/code&gt; 디렉토리 의 내용 일뿐 입니다.</target>
        </trans-unit>
        <trans-unit id="31dc4b206e7be8ca9a78c4871cc58f03a5340e5b" translate="yes" xml:space="preserve">
          <source>The revision data is appended to the file if it already exists, for use when doing incremental imports.</source>
          <target state="translated">증분 가져 오기를 수행 할 때 사용할 수 있도록 수정본 데이터가 이미 존재하는 경우 파일에 추가됩니다.</target>
        </trans-unit>
        <trans-unit id="0ca811b30547ebe29846859e95a6c9147e8141b4" translate="yes" xml:space="preserve">
          <source>The rewrite rule guarantees that existing static files will be properly served, whereas any other URL will be passed to gitweb as PATH_INFO parameter.</source>
          <target state="translated">다시 쓰기 규칙은 기존 정적 파일이 올바르게 제공되는 반면 다른 URL은 PATH_INFO 매개 변수로 gitweb에 전달됩니다.</target>
        </trans-unit>
        <trans-unit id="7511d9248c0671ec876d283606ae9df0bea2f6b2" translate="yes" xml:space="preserve">
          <source>The ripple effect of a &quot;hard case&quot; recovery is especially bad: &lt;code&gt;everyone&lt;/code&gt; downstream from &lt;code&gt;topic&lt;/code&gt; will now have to perform a &quot;hard case&quot; recovery too!</source>
          <target state="translated">&quot;하드 케이스&quot;복구의 파급 효과는 특히 나쁩니다. 이제 &lt;code&gt;topic&lt;/code&gt; &lt;code&gt;everyone&lt;/code&gt; 다운 스트림 사용자도 &quot;하드 케이스&quot;복구를 수행해야합니다!</target>
        </trans-unit>
        <trans-unit id="93d5c7537e241865d860131eb6d72edc95c9d772" translate="yes" xml:space="preserve">
          <source>The root of the CVS archive. May be local (a simple path) or remote; currently, only the :local:, :ext: and :pserver: access methods are supported. If not given, &lt;code&gt;git cvsimport&lt;/code&gt; will try to read it from &lt;code&gt;CVS/Root&lt;/code&gt;. If no such file exists, it checks for the &lt;code&gt;CVSROOT&lt;/code&gt; environment variable.</source>
          <target state="translated">CVS 아카이브의 루트 로컬 (간단한 경로) 또는 원격 일 수 있습니다. 현재 : local :, : ext : 및 : pserver : 액세스 방법 만 지원됩니다. 지정하지 않으면 &lt;code&gt;git cvsimport&lt;/code&gt; 는 &lt;code&gt;CVS/Root&lt;/code&gt; 에서 읽습니다 . 그러한 파일이 없으면 &lt;code&gt;CVSROOT&lt;/code&gt; 환경 변수를 확인 합니다.</target>
        </trans-unit>
        <trans-unit id="df41fdf293aec02e3dee1ead27003284471a1181" translate="yes" xml:space="preserve">
          <source>The root of the tree can be represented by an empty string as &lt;code&gt;&amp;lt;path&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">트리의 루트는 &lt;code&gt;&amp;lt;path&amp;gt;&lt;/code&gt; 로 빈 문자열로 표시 될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="557dc21e01559e09224bc25bcbd6a672b4e3d883" translate="yes" xml:space="preserve">
          <source>The rule to determine which remote branch to merge after fetching is a bit involved, in order not to break backward compatibility.</source>
          <target state="translated">이전 버전과의 호환성을 위반하지 않기 위해 페치 후 병합 할 원격 브랜치를 결정하는 규칙이 약간 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="bbff5506f0bff9eed6d1a29f80ce8f838449bb56" translate="yes" xml:space="preserve">
          <source>The rules by which the pattern matches paths are the same as in &lt;code&gt;.gitignore&lt;/code&gt; files (see &lt;a href=&quot;gitignore&quot;&gt;gitignore[5]&lt;/a&gt;), with a few exceptions:</source>
          <target state="translated">패턴이 경로와 일치하는 규칙은 &lt;code&gt;.gitignore&lt;/code&gt; 파일 ( &lt;a href=&quot;gitignore&quot;&gt;gitignore [5]&lt;/a&gt; 참조 )과 동일하지만 몇 가지 예외가 있습니다.</target>
        </trans-unit>
        <trans-unit id="579e7c08387accae89723ba13e3ec53145837232" translate="yes" xml:space="preserve">
          <source>The same as &lt;code&gt;--merge&lt;/code&gt; option above, but changes the way the conflicting hunks are presented, overriding the &lt;code&gt;merge.conflictStyle&lt;/code&gt; configuration variable. Possible values are &quot;merge&quot; (default) and &quot;diff3&quot; (in addition to what is shown by &quot;merge&quot; style, shows the original contents).</source>
          <target state="translated">위의 &lt;code&gt;--merge&lt;/code&gt; 옵션 과 동일 하지만 충돌하는 덩어리가 표시되는 방식을 변경하여 &lt;code&gt;merge.conflictStyle&lt;/code&gt; 구성 변수를 재정의하십시오 . 가능한 값은 &quot;병합&quot;(기본값) 및 &quot;diff3&quot;입니다 ( &quot;병합&quot;스타일로 표시되는 것 외에 원래 내용 표시).</target>
        </trans-unit>
        <trans-unit id="1a11cc7f94381fe2de07d484775d2914bf62d241" translate="yes" xml:space="preserve">
          <source>The same as the previous one:</source>
          <target state="translated">이전과 동일</target>
        </trans-unit>
        <trans-unit id="ebdfbbadd1b4e3e4d3c390aed297730072348592" translate="yes" xml:space="preserve">
          <source>The same rewind and rebuild process may be followed for &lt;code&gt;pu&lt;/code&gt;. A public announcement is not necessary since &lt;code&gt;pu&lt;/code&gt; is a throw-away branch, as described above.</source>
          <target state="translated">&lt;code&gt;pu&lt;/code&gt; 에 대해 동일한 되감기 및 재구성 프로세스가 수행 될 수 있습니다 . &lt;code&gt;pu&lt;/code&gt; 는 위에서 설명한 것처럼 버림 지점 이므로 공개 발표가 필요하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="30d931302d20c8d2d3f4d29cdb99720d08f56244" translate="yes" xml:space="preserve">
          <source>The same trailer as a v1 pack file:</source>
          <target state="translated">v1 팩 파일과 동일한 트레일러 :</target>
        </trans-unit>
        <trans-unit id="ef6e4cd5de79a2002e4df69090fc16d7024fe532" translate="yes" xml:space="preserve">
          <source>The sample &lt;code&gt;prepare-commit-msg&lt;/code&gt; hook that comes with Git removes the help message found in the commented portion of the commit template.</source>
          <target state="translated">Git과 함께 제공 되는 샘플 &lt;code&gt;prepare-commit-msg&lt;/code&gt; 훅은 커밋 템플릿의 주석 처리 된 부분에있는 도움말 메시지를 제거합니다.</target>
        </trans-unit>
        <trans-unit id="0814a224cf6ffffca90b05b46ffd264f8d62f600" translate="yes" xml:space="preserve">
          <source>The sample hooks are all disabled by default. To enable one of the sample hooks rename it by removing its &lt;code&gt;.sample&lt;/code&gt; suffix.</source>
          <target state="translated">샘플 후크는 기본적으로 비활성화되어 있습니다. 샘플 후크 중 하나를 사용하려면 &lt;code&gt;.sample&lt;/code&gt; 접미 부를 제거하여 이름을 바꾸십시오 .</target>
        </trans-unit>
        <trans-unit id="ee2f5fb52849fdcd69a62a399938c4c71ec4e36c" translate="yes" xml:space="preserve">
          <source>The sane thing. Just admit you screwed up, and use a different name. Others have already seen one tag-name, and if you keep the same name, you may be in the situation that two people both have &quot;version X&quot;, but they actually have &lt;code&gt;different&lt;/code&gt; &quot;X&quot;'s. So just call it &quot;X.1&quot; and be done with it.</source>
          <target state="translated">제정신. 망했음을 인정하고 다른 이름을 사용하십시오. 다른 사람들은 이미 하나의 태그 이름을 보았으며 같은 이름을 유지하면 두 사람이 모두 &quot;버전 X&quot;를 가지고 있지만 실제로는 &quot;X&quot; 가 &lt;code&gt;different&lt;/code&gt; 상황에있을 수 있습니다 . &quot;X.1&quot;이라고 부르고 완료하십시오.</target>
        </trans-unit>
        <trans-unit id="16a78cd21b6c709f016f4a17d2a1069e970db97c" translate="yes" xml:space="preserve">
          <source>The script expects you to provide the key roots where it can start the import from an &lt;code&gt;initial import&lt;/code&gt; or &lt;code&gt;tag&lt;/code&gt; type of Arch commit. It will follow and import new branches within the provided roots.</source>
          <target state="translated">스크립트는 &lt;code&gt;initial import&lt;/code&gt; 또는 &lt;code&gt;tag&lt;/code&gt; 유형의 Arch commit 에서 가져 오기를 시작할 수있는 핵심 루트를 제공 할 것으로 예상합니다 . 제공된 루트 내에서 새 분기를 따르고 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="793ca81ee99913a2e3edc7ca33209f79549422e8" translate="yes" xml:space="preserve">
          <source>The scriptlet sets &lt;code&gt;GIT_DIR&lt;/code&gt; and &lt;code&gt;GIT_OBJECT_DIRECTORY&lt;/code&gt; shell variables, but does &lt;strong&gt;not&lt;/strong&gt; export them to the environment.</source>
          <target state="translated">스크립틀릿은 설정 &lt;code&gt;GIT_DIR&lt;/code&gt; 및 &lt;code&gt;GIT_OBJECT_DIRECTORY&lt;/code&gt; 쉘 변수를하지만, 않습니다 &lt;strong&gt;없는&lt;/strong&gt; 환경에 내보낼 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8b53f7beee61a37b0174ea389f5f36080ff3c1b7" translate="yes" xml:space="preserve">
          <source>The second .gitignore prevents Git from ignoring &lt;code&gt;arch/foo/kernel/vmlinux.lds.S&lt;/code&gt;.</source>
          <target state="translated">두 번째 .gitignore는 Git이 &lt;code&gt;arch/foo/kernel/vmlinux.lds.S&lt;/code&gt; 를 무시하지 못하게 합니다.</target>
        </trans-unit>
        <trans-unit id="fc737587a80c0c07a4fffd3646c479ff0f86cddd" translate="yes" xml:space="preserve">
          <source>The second example demonstrates that you can abbreviate the object name to only the first several hexadecimal digits in most places.</source>
          <target state="translated">두 번째 예는 대부분의 장소에서 처음 몇 개의 16 진수로만 객체 이름을 약어로 표시 할 수 있음을 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="2890a9def3fff903603dee47b68cd9b5af108707" translate="yes" xml:space="preserve">
          <source>The second format is what gets used when &lt;code&gt;--stage=all&lt;/code&gt;. The three stage temporary fields (stage1temp, stage2temp, stage3temp) list the name of the temporary file if there is a stage entry in the index or &lt;code&gt;.&lt;/code&gt; if there is no stage entry. Paths which only have a stage 0 entry will always be omitted from the output.</source>
          <target state="translated">두 번째 형식은 &lt;code&gt;--stage=all&lt;/code&gt; 일 때 사용됩니다 . 세 개의 스테이지 임시 필드 (stage1temp, stage2temp, stage3temp)는 색인 또는에 스테이지 항목이있는 경우 임시 파일의 이름을 나열합니다 &lt;code&gt;.&lt;/code&gt; 무대 진입이없는 경우 단계 0 항목 만있는 경로는 항상 출력에서 ​​생략됩니다.</target>
        </trans-unit>
        <trans-unit id="86b87f951d8d8be1a02da6e062a3489256945d73" translate="yes" xml:space="preserve">
          <source>The second parameter passed to the hook is the indicator for whether or not the index was updated and the skip-worktree bit could have changed. &quot;1&quot; meaning skip-worktree bits could have been updated and &quot;0&quot; meaning they were not.</source>
          <target state="translated">후크에 전달 된 두 번째 매개 변수는 색인이 업데이트되었고 스킵 작업 트리 비트가 변경 될 수 있는지 여부에 대한 표시기입니다. &quot;1&quot;은 건너 뛰기 작업 비트를 의미하고 &quot;0&quot;은 업데이트되지 않았 음을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="b730007914036d9f0fb3ba6052d64853bae216ae" translate="yes" xml:space="preserve">
          <source>The second syntax (&quot;&lt;code&gt;git merge --abort&lt;/code&gt;&quot;) can only be run after the merge has resulted in conflicts. &lt;code&gt;git merge --abort&lt;/code&gt; will abort the merge process and try to reconstruct the pre-merge state. However, if there were uncommitted changes when the merge started (and especially if those changes were further modified after the merge was started), &lt;code&gt;git merge --abort&lt;/code&gt; will in some cases be unable to reconstruct the original (pre-merge) changes. Therefore:</source>
          <target state="translated">두 번째 구문 ( &quot; &lt;code&gt;git merge --abort&lt;/code&gt; &quot;)은 병합이 충돌 한 후에 만 ​​실행할 수 있습니다. &lt;code&gt;git merge --abort&lt;/code&gt; 는 병합 프로세스를 중단하고 병합 전 상태를 재구성하려고 시도합니다. 그러나 병합이 시작될 때 커밋되지 않은 변경 사항이 있었을 때 (특히 병합이 시작된 후 이러한 변경 사항이 추가로 수정 된 경우) &lt;code&gt;git merge --abort&lt;/code&gt; 는 원래 (병합 전) 변경 사항을 재구성 할 수없는 경우가 있습니다. 따라서:</target>
        </trans-unit>
        <trans-unit id="1f7dcee78b5872602756cd0d868ad6253db301fe" translate="yes" xml:space="preserve">
          <source>The second transformation in the chain is diffcore-break, and is controlled by the -B option to the &lt;code&gt;git diff-*&lt;/code&gt; commands. This is used to detect a filepair that represents &quot;complete rewrite&quot; and break such filepair into two filepairs that represent delete and create. E.g. If the input contained this filepair:</source>
          <target state="translated">체인의 두 번째 변환은 diffcore-break이며, &lt;code&gt;git diff-*&lt;/code&gt; 명령 에 대한 -B 옵션으로 제어됩니다 . &quot;완전한 다시 쓰기&quot;를 나타내는 파일 쌍을 감지하고 해당 파일 쌍을 삭제 및 작성을 나타내는 두 개의 파일 쌍으로 나눕니다. 예를 들어, 입력에이 파일 쌍이 포함 된 경우 :</target>
        </trans-unit>
        <trans-unit id="5aa738048a0181b9705365955bd04c18156f9d33" translate="yes" xml:space="preserve">
          <source>The section &lt;code&gt;submodule.foo.*&lt;/code&gt; in the &lt;code&gt;.gitmodules&lt;/code&gt; file gives additional hints to Git&amp;rsquo;s porcelain layer. For example, the &lt;code&gt;submodule.foo.url&lt;/code&gt; setting specifies where to obtain the submodule.</source>
          <target state="translated">&lt;code&gt;.gitmodules&lt;/code&gt; 파일 의 &lt;code&gt;submodule.foo.*&lt;/code&gt; 섹션 은 Git의 도자기 레이어에 대한 추가 힌트를 제공합니다. 예를 들어, &lt;code&gt;submodule.foo.url&lt;/code&gt; 설정 은 서브 모듈 을 얻을 위치를 지정합니다.</target>
        </trans-unit>
        <trans-unit id="addff8a92e5ddb901ae8a38330bc2dcce4be9fbb" translate="yes" xml:space="preserve">
          <source>The section or key is invalid (ret=1),</source>
          <target state="translated">섹션 또는 키가 유효하지 않습니다 (ret = 1).</target>
        </trans-unit>
        <trans-unit id="463ba2454fad2719570e32271a038c3acce699a7" translate="yes" xml:space="preserve">
          <source>The server MUST NOT send any &quot;unshallow&quot; lines for anything which the client has not indicated was shallow as a part of its request.</source>
          <target state="translated">서버는 클라이언트가 요청의 일부로 얕은 것으로 표시하지 않은 항목에 대해 &quot;얕지 않은&quot;행을 보내서는 안됩니다.</target>
        </trans-unit>
        <trans-unit id="d868af4cbdec034778f61defdf53e9a4307fd341" translate="yes" xml:space="preserve">
          <source>The server MUST NOT send any refs which were not requested using &lt;code&gt;want-ref&lt;/code&gt; lines.</source>
          <target state="translated">서버는 &lt;code&gt;want-ref&lt;/code&gt; 라인을 사용하여 요청되지 않은 심판을 보내서는 안됩니다 .</target>
        </trans-unit>
        <trans-unit id="446930d87bed0e82e29e329dd081708ba37057c2" translate="yes" xml:space="preserve">
          <source>The server can advertise the &lt;code&gt;agent&lt;/code&gt; capability with a value &lt;code&gt;X&lt;/code&gt; (in the form &lt;code&gt;agent=X&lt;/code&gt;) to notify the client that the server is running version &lt;code&gt;X&lt;/code&gt;. The client may optionally send its own agent string by including the &lt;code&gt;agent&lt;/code&gt; capability with a value &lt;code&gt;Y&lt;/code&gt; (in the form &lt;code&gt;agent=Y&lt;/code&gt;) in its request to the server (but it MUST NOT do so if the server did not advertise the agent capability). The &lt;code&gt;X&lt;/code&gt; and &lt;code&gt;Y&lt;/code&gt; strings may contain any printable ASCII characters except space (i.e., the byte range 32 &amp;lt; x &amp;lt; 127), and are typically of the form &quot;package/version&quot; (e.g., &quot;git/1.8.3.1&quot;). The agent strings are purely informative for statistics and debugging purposes, and MUST NOT be used to programmatically assume the presence or absence of particular features.</source>
          <target state="translated">서버는 &lt;code&gt;agent&lt;/code&gt; 기능을 값 &lt;code&gt;X&lt;/code&gt; ( &lt;code&gt;agent=X&lt;/code&gt; 양식 )로 알리면 서버가 버전 &lt;code&gt;X&lt;/code&gt; 를 실행 중임을 클라이언트에 알릴 수 있습니다. 클라이언트는 요청 에 값 &lt;code&gt;Y&lt;/code&gt; ( &lt;code&gt;agent=Y&lt;/code&gt; 형식) 의 &lt;code&gt;agent&lt;/code&gt; 기능을 서버 에 포함 시켜서 자체 에이전트 문자열을 선택적으로 전송할 수 있습니다 (그러나 서버가 에이전트 기능을 광고하지 않은 경우에는 그렇게하지 않아야합니다). &lt;code&gt;X&lt;/code&gt; 및 &lt;code&gt;Y&lt;/code&gt; 문자열은 공백 (예 : 바이트 범위 32 &amp;lt;x &amp;lt;127)을 제외한 인쇄 가능한 ASCII 문자를 포함 할 수 있으며 일반적으로 &quot;package / version&quot;형식 (예 : &quot;git / 1.8.3.1&quot;)입니다. 에이전트 문자열은 통계 및 디버깅 목적으로 만 정보를 제공하며 특정 기능의 존재 유무를 프로그래밍 방식으로 가정하는 데 사용해서는 안됩니다.</target>
        </trans-unit>
        <trans-unit id="5dbb8fc2dd2ef1317864e26b0a2f75da26a1d7f0" translate="yes" xml:space="preserve">
          <source>The server sends a &quot;shallow obj-id&quot; line for each commit whose parents will not be sent in the following packfile.</source>
          <target state="translated">서버는 부모가 다음 팩 파일로 전송되지 않는 각 커밋에 대해 &quot;shallow obj-id&quot;행을 보냅니다.</target>
        </trans-unit>
        <trans-unit id="15cbc52acb55c8a437e7a9fc2cb2ebb8c994afc3" translate="yes" xml:space="preserve">
          <source>The server sends an &quot;unshallow obj-id&quot; line for each commit which the client has indicated is shallow, but is no longer shallow as a result of the fetch (due to its parents being sent in the following packfile).</source>
          <target state="translated">서버는 클라이언트가 표시 한 각 커밋에 대해 &quot;unshallow obj-id&quot;라인을 전송하지만, 페치 결과로 더 이상 얕은 것은 아닙니다 (부모가 다음 팩 파일로 전송 됨).</target>
        </trans-unit>
        <trans-unit id="3f482eecb5e3fca563243c0419eece540e0582ac" translate="yes" xml:space="preserve">
          <source>The server will respond with &quot;ACK obj-id&quot; for all of the object ids sent as have lines which are common.</source>
          <target state="translated">서버는 공통의 행이있는 것으로 전송 된 모든 객체 ID에 대해 &quot;ACK obj-id&quot;로 응답합니다.</target>
        </trans-unit>
        <trans-unit id="543a974b0aa8c62d541ca2830198235b945cc003" translate="yes" xml:space="preserve">
          <source>The server will respond with &quot;NAK&quot; if none of the object ids sent as have lines were common.</source>
          <target state="translated">라인이있는 것으로 전송 된 오브젝트 ID가 공통되지 않은 경우 서버는 &quot;NAK&quot;로 응답합니다.</target>
        </trans-unit>
        <trans-unit id="568256da628f1737b5310a22de9a07629ce73e0d" translate="yes" xml:space="preserve">
          <source>The server will respond with a &quot;ready&quot; line indicating that the server has found an acceptable common base and is ready to make and send a packfile (which will be found in the packfile section of the same response)</source>
          <target state="translated">서버는 서버가 허용 가능한 공통 기반을 찾았고 팩 파일 (동일한 응답의 packfile 섹션에 있음)을 작성할 준비가되었음을 나타내는 &quot;준비&quot;행으로 응답합니다.</target>
        </trans-unit>
        <trans-unit id="69ff3eec8c55e5a8095ea13f51e31e429dc845d6" translate="yes" xml:space="preserve">
          <source>The server will send a ref listing (&quot;&amp;lt;oid&amp;gt; &amp;lt;refname&amp;gt;&quot;) for each reference requested using &lt;code&gt;want-ref&lt;/code&gt; lines.</source>
          <target state="translated">서버는 &lt;code&gt;want-ref&lt;/code&gt; 행을 사용하여 요청 된 각 참조에 대해 참조 목록 ( &quot;&amp;lt;oid&amp;gt; &amp;lt;refname&amp;gt;&quot;)을 보냅니다 .</target>
        </trans-unit>
        <trans-unit id="afb7e2ac1ca268d29d3dabe65a1485bc3c99ebf1" translate="yes" xml:space="preserve">
          <source>The server will then check to ensure that the client&amp;rsquo;s request is comprised of a valid command as well as valid capabilities which were advertised. If the request is valid the server will then execute the command. A server MUST wait till it has received the client&amp;rsquo;s entire request before issuing a response. The format of the response is determined by the command being executed, but in all cases a flush-pkt indicates the end of the response.</source>
          <target state="translated">그런 다음 서버는 클라이언트 요청이 유효한 명령뿐만 아니라 알려진 유효한 기능으로 구성되어 있는지 확인합니다. 요청이 유효하면 서버는 명령을 실행합니다. 서버는 응답을 발행하기 전에 클라이언트의 전체 요청을 수신 할 때까지 기다려야합니다. 응답의 형식은 실행중인 명령에 따라 결정되지만 flush-pkt는 응답의 끝을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="537b1e0777fad4eaaafbf4ccf5940ab37b1e2ed6" translate="yes" xml:space="preserve">
          <source>The shared index part, to be referenced by $GIT_DIR/index and other temporary index files. Only valid in split index mode.</source>
          <target state="translated">$ GIT_DIR / index 및 기타 임시 색인 파일에서 참조 할 공유 색인 부분. 분할 인덱스 모드에서만 유효합니다.</target>
        </trans-unit>
        <trans-unit id="d11a14c0103fd18e1ebb96bcb7251e0f8abbce80" translate="yes" xml:space="preserve">
          <source>The shift magic first throws away the tree id and then the -p parameters. Note that this handles merges properly! In case Darl committed a merge between P1 and P2, it will be propagated properly and all children of the merge will become merge commits with P1,P2 as their parents instead of the merge commit.</source>
          <target state="translated">시프트 매직은 먼저 트리 ID와 -p 매개 변수를 모두 버립니다. 이 처리는 병합을 올바르게 처리합니다. Darl이 P1과 P2간에 병합을 커밋 한 경우 제대로 전파되고 병합의 모든 자식은 병합 커밋 대신 부모로 P1, P2를 사용하여 병합 커밋이됩니다.</target>
        </trans-unit>
        <trans-unit id="e33b2d8b27401f604cb70ad4d214df90a2abf20c" translate="yes" xml:space="preserve">
          <source>The similarity index is the percentage of unchanged lines, and the dissimilarity index is the percentage of changed lines. It is a rounded down integer, followed by a percent sign. The similarity index value of 100% is thus reserved for two equal files, while 100% dissimilarity means that no line from the old file made it into the new one.</source>
          <target state="translated">유사성 지수는 변경되지 않은 라인의 백분율이며, 비 유사성 지수는 변경된 라인의 백분율입니다. 반올림 된 정수 다음에 백분율 기호가옵니다. 따라서 100 %의 유사성 색인 값은 두 개의 동일한 파일에 예약되어 있으며 100 %의 유사하지 않음은 이전 파일의 행이 새 파일로 작성되지 않았 음을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="09f0c715250f8ac9e78727d6768d66502facff83" translate="yes" xml:space="preserve">
          <source>The simplest commit to find is the HEAD commit, which we can find from .git/HEAD:</source>
          <target state="translated">가장 간단한 커밋은 .git / HEAD에서 찾을 수있는 HEAD 커밋입니다.</target>
        </trans-unit>
        <trans-unit id="938f800e1b465bd0f07eb377492ba2456bfbed2c" translate="yes" xml:space="preserve">
          <source>The simplest way to do this is using &lt;a href=&quot;git-push&quot;&gt;git-push[1]&lt;/a&gt; and ssh; to update the remote branch named &lt;code&gt;master&lt;/code&gt; with the latest state of your branch named &lt;code&gt;master&lt;/code&gt;, run</source>
          <target state="translated">가장 간단한 방법은 &lt;a href=&quot;git-push&quot;&gt;git-push [1]&lt;/a&gt; 및 ssh; 라는 이름의 원격 지사 업데이트 &lt;code&gt;master&lt;/code&gt; 지사라는 이름의 최신 상태 &lt;code&gt;master&lt;/code&gt; , 실행</target>
        </trans-unit>
        <trans-unit id="a5eba655ac4b55a1106bdc6c6dbf2b0d1ad04c8a" translate="yes" xml:space="preserve">
          <source>The simplest way to mark a file as binary is to unset the diff attribute in the &lt;code&gt;.gitattributes&lt;/code&gt; file:</source>
          <target state="translated">파일을 바이너리로 표시하는 가장 간단한 방법은 &lt;code&gt;.gitattributes&lt;/code&gt; 파일 에서 diff 속성을 설정 해제하는 것입니다 .</target>
        </trans-unit>
        <trans-unit id="99bb329f9f9a76ae9c81982693e8d5911709e87c" translate="yes" xml:space="preserve">
          <source>The size of the object (the same as &lt;code&gt;git cat-file -s&lt;/code&gt; reports). Append &lt;code&gt;:disk&lt;/code&gt; to get the size, in bytes, that the object takes up on disk. See the note about on-disk sizes in the &lt;code&gt;CAVEATS&lt;/code&gt; section below.</source>
          <target state="translated">객체의 크기 ( &lt;code&gt;git cat-file -s&lt;/code&gt; reports 와 동일 ) &lt;code&gt;:disk&lt;/code&gt; 를 추가 하여 개체가 디스크에서 차지하는 크기 (바이트)를 가져옵니다. 아래 의 &lt;code&gt;CAVEATS&lt;/code&gt; 섹션 에서 온 디스크 크기에 대한 참고 사항을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="3527fa64b6fd749102c379b2fd96b0df5cd454cb" translate="yes" xml:space="preserve">
          <source>The size of the window used by &lt;a href=&quot;git-pack-objects&quot;&gt;git-pack-objects[1]&lt;/a&gt; when no window size is given on the command line. Defaults to 10.</source>
          <target state="translated">창 크기가 사용 &lt;a href=&quot;git-pack-objects&quot;&gt;자식 팩 - 오브젝트 [1]&lt;/a&gt; 어떤 윈도우 사이즈는 명령 라인에 제공되지 않는 경우. 기본값은 10입니다.</target>
        </trans-unit>
        <trans-unit id="2372575566ae8c805d7580bdcbad6da1c4463611" translate="yes" xml:space="preserve">
          <source>The size, in bytes, of the object (the same as &lt;code&gt;cat-file -s&lt;/code&gt; reports).</source>
          <target state="translated">개체의 크기 (바이트) ( &lt;code&gt;cat-file -s&lt;/code&gt; 보고서 와 동일 )</target>
        </trans-unit>
        <trans-unit id="43c333a5a6bd3bca8b34d5163a7aa7b6d79d2d40" translate="yes" xml:space="preserve">
          <source>The size, in bytes, that the object takes up on disk. See the note about on-disk sizes in the &lt;code&gt;CAVEATS&lt;/code&gt; section below.</source>
          <target state="translated">객체가 디스크에서 차지하는 크기 (바이트)입니다. 아래 의 &lt;code&gt;CAVEATS&lt;/code&gt; 섹션 에서 온 디스크 크기에 대한 참고 사항을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="7d544171c06a9cb39c4059f830c0a8558d3922c9" translate="yes" xml:space="preserve">
          <source>The slash &lt;code&gt;/&lt;/code&gt; is used as the directory separator. Separators may occur at the beginning, middle or end of the &lt;code&gt;.gitignore&lt;/code&gt; search pattern.</source>
          <target state="translated">슬래시 ( &lt;code&gt;/&lt;/code&gt; ) 는 디렉토리 구분 기호로 사용됩니다. 분리자는 &lt;code&gt;.gitignore&lt;/code&gt; 검색 패턴 의 시작, 중간 또는 끝에서 발생할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="e18b2266f1b1b9062e466bd05dd697dc8d44c68f" translate="yes" xml:space="preserve">
          <source>The smaller the changes in your commit, the most effective &quot;git bisect&quot; will be. And you will probably need &quot;git bisect&quot; less in the first place, as small changes are easier to review even if they are only reviewed by the committer.</source>
          <target state="translated">커밋의 변경 사항이 작을수록 가장 효과적인 &quot;git bisect&quot;가됩니다. 그리고 커미터에 의해서만 검토 되더라도 작은 변경 사항을 검토하기가 더 쉬우므로 처음에는 &quot;git bisect&quot;가 덜 필요할 것입니다.</target>
        </trans-unit>
        <trans-unit id="0dab2fe7462a5d0c0b797d08e789dbaaf7bfa1df" translate="yes" xml:space="preserve">
          <source>The smart HTTP server, &lt;a href=&quot;git-http-backend&quot;&gt;git-http-backend[1]&lt;/a&gt;, will pass GIT_NAMESPACE through to the backend programs; see &lt;a href=&quot;git-http-backend&quot;&gt;git-http-backend[1]&lt;/a&gt; for sample configuration to expose repository namespaces as repositories.</source>
          <target state="translated">스마트 HTTP 서버 인 &lt;a href=&quot;git-http-backend&quot;&gt;git-http-backend [1]&lt;/a&gt; 은 GIT_NAMESPACE를 백엔드 프로그램으로 전달합니다. 리포지토리 네임 스페이스를 리포지토리로 노출하는 샘플 구성 은 &lt;a href=&quot;git-http-backend&quot;&gt;git-http-backend [1]&lt;/a&gt; 을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="9ee3be6f644f850e9ae409b580b74ced862493f8" translate="yes" xml:space="preserve">
          <source>The solution, of course, is to make a merge that we can undo: merge into a throw-away branch.</source>
          <target state="translated">물론 해결책은 취소 할 수있는 병합을 만드는 것입니다.</target>
        </trans-unit>
        <trans-unit id="8a1117f540255f9a5dcffa1baa25558f77657b0e" translate="yes" xml:space="preserve">
          <source>The special case of restarting an incremental import from the current branch value should be written as:</source>
          <target state="translated">현재 분기 값에서 증분 가져 오기를 다시 시작하는 특별한 경우는 다음과 같이 작성해야합니다.</target>
        </trans-unit>
        <trans-unit id="3599d1b8b89ee48d0b633dcff9041c57284c3251" translate="yes" xml:space="preserve">
          <source>The special exit code 125 should be used when the current source code cannot be tested. If the script exits with this code, the current revision will be skipped (see &lt;code&gt;git bisect skip&lt;/code&gt; above). 125 was chosen as the highest sensible value to use for this purpose, because 126 and 127 are used by POSIX shells to signal specific error status (127 is for command not found, 126 is for command found but not executable&amp;mdash;​these details do not matter, as they are normal errors in the script, as far as &lt;code&gt;bisect run&lt;/code&gt; is concerned).</source>
          <target state="translated">현재 소스 코드를 테스트 할 수없는 경우 특수 종료 코드 125를 사용해야합니다. 스크립트가이 코드와 함께 종료되면 현재 개정판을 건너 뜁니다 ( 위의 &lt;code&gt;git bisect skip&lt;/code&gt; 참조). 126과 127은 POSIX 셸에서 특정 오류 상태를 알리기 위해 사용하기 때문에 125가이 목적에 가장 적합한 값으로 선택되었습니다 (127은 명령을 찾을 수없고 126은 명령을 찾았지만 실행할 수 없음). &lt;code&gt;bisect run&lt;/code&gt; 과 관련 하여 스크립트에서 정상적인 오류 이므로 문제가 발생합니다).</target>
        </trans-unit>
        <trans-unit id="60ac8fe2a99f998c150bb7d9adc8dfbeed95a10d" translate="yes" xml:space="preserve">
          <source>The special null SHA-1 (40 zeros) specifies that the branch is to be removed.</source>
          <target state="translated">특수 null SHA-1 (40 개의 0)은 분기가 제거되도록 지정합니다.</target>
        </trans-unit>
        <trans-unit id="a4c2fa6682338e4d7c45557107add1984be0213c" translate="yes" xml:space="preserve">
          <source>The special refspec &lt;code&gt;:&lt;/code&gt; (or &lt;code&gt;+:&lt;/code&gt; to allow non-fast-forward updates) directs Git to push &quot;matching&quot; branches: for every branch that exists on the local side, the remote side is updated if a branch of the same name already exists on the remote side.</source>
          <target state="translated">특별한 refspec &lt;code&gt;:&lt;/code&gt; (또는 &lt;code&gt;+:&lt;/code&gt; 빨리 감기가 아닌 업데이트를 허용하기 위해) Git은 &quot;일치하는&quot;분기를 푸시하도록 지시합니다. 로컬 측에 존재하는 모든 분기에 대해 동일한 이름의 분기가 이미 존재하면 원격 측이 업데이트됩니다 원격쪽에.</target>
        </trans-unit>
        <trans-unit id="f2f702d2704e1b64279419d712ca4460c3b7f78e" translate="yes" xml:space="preserve">
          <source>The special string &lt;code&gt;none&lt;/code&gt; can be used as the proxy command to specify that no proxy be used for a given domain pattern. This is useful for excluding servers inside a firewall from proxy use, while defaulting to a common proxy for external domains.</source>
          <target state="translated">지정된 문자열 패턴에 프록시를 사용하지 않도록 지정하기 위해 특수 문자열 &lt;code&gt;none&lt;/code&gt; 을 proxy 명령으로 사용할 수 없습니다. 이는 방화벽 내부의 서버를 프록시 사용에서 제외하고 외부 도메인의 공통 프록시로 기본 설정하는 데 유용합니다.</target>
        </trans-unit>
        <trans-unit id="65b859a3a4528b4a1eebafeebe9d2d28ac0eb085" translate="yes" xml:space="preserve">
          <source>The special symbol &quot;HEAD&quot; can always be used to refer to the current branch. In fact, Git uses a file named &lt;code&gt;HEAD&lt;/code&gt; in the &lt;code&gt;.git&lt;/code&gt; directory to remember which branch is current:</source>
          <target state="translated">특수 기호 &quot;HEAD&quot;는 항상 현재 분기를 나타내는 데 사용될 수 있습니다. 사실, 힘내라는 이름의 파일 사용 &lt;code&gt;HEAD&lt;/code&gt; 에 &lt;code&gt;.git&lt;/code&gt; 현재 어느 지점 기억해야 할 디렉토리를 :</target>
        </trans-unit>
        <trans-unit id="54b91d851f1b23aa70b29c0e74d2c28879b6de30" translate="yes" xml:space="preserve">
          <source>The ssh and git protocols additionally support ~username expansion:</source>
          <target state="translated">ssh 및 git 프로토콜은 ~ username 확장을 추가로 지원합니다.</target>
        </trans-unit>
        <trans-unit id="ac6c6d73b5f6b7c3cef28dfe32da61495601bd7c" translate="yes" xml:space="preserve">
          <source>The standard actions are:</source>
          <target state="translated">표준 조치는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="a72f515f06e2719cd062e161d9ed80a61b68c92f" translate="yes" xml:space="preserve">
          <source>The standard email format as described by RFC 2822, for example &lt;code&gt;Thu, 07 Apr 2005 22:13:13 +0200&lt;/code&gt;.</source>
          <target state="translated">RFC 2822에 설명 된 표준 이메일 형식 (예 : &lt;code&gt;Thu, 07 Apr 2005 22:13:13 +0200&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8128f4cfe82d86e129a0094608260664c3bb1ba3" translate="yes" xml:space="preserve">
          <source>The standard helper program to use with git-merge-index</source>
          <target state="translated">git-merge-index와 함께 사용할 표준 도우미 프로그램</target>
        </trans-unit>
        <trans-unit id="4d34b021b617aa2bf3f93982ac428b041f085fbe" translate="yes" xml:space="preserve">
          <source>The starting point for the new branch. Specifying a &lt;code&gt;&amp;lt;start-point&amp;gt;&lt;/code&gt; allows you to create a branch based on some other point in history than where HEAD currently points. (Or, in the case of &lt;code&gt;--detach&lt;/code&gt;, allows you to inspect and detach from some other point.)</source>
          <target state="translated">새로운 지점의 출발점. &lt;code&gt;&amp;lt;start-point&amp;gt;&lt;/code&gt; 를 지정하면 HEAD가 현재 가리키는 위치 이외의 다른 기록 포인트를 기반으로 분기를 만들 수 있습니다. 또는 &lt;code&gt;--detach&lt;/code&gt; 의 경우 다른 지점을 검사하고 분리 할 수 ​​있습니다.</target>
        </trans-unit>
        <trans-unit id="ca9ba47b83a1def4d8a6c769f2e642f061d5236a" translate="yes" xml:space="preserve">
          <source>The status of GPG verification of the push certificate, using the same mnemonic as used in &lt;code&gt;%G?&lt;/code&gt; format of &lt;code&gt;git log&lt;/code&gt; family of commands (see &lt;a href=&quot;git-log&quot;&gt;git-log[1]&lt;/a&gt;).</source>
          <target state="translated">&lt;code&gt;%G?&lt;/code&gt; 사용 된 것과 동일한 니모닉을 사용하여 푸시 인증서의 GPG 확인 상태 ? &lt;code&gt;git log&lt;/code&gt; 명령 계열 형식 ( &lt;a href=&quot;git-log&quot;&gt;git-log [1] 참조&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="c902748a09ab505851b0b39809c60f3db2027be9" translate="yes" xml:space="preserve">
          <source>The status of the fetch is output in tabular form, with each line representing the status of a single ref. Each line is of the form:</source>
          <target state="translated">페치 상태는 표 형식으로 출력되며 각 라인은 단일 심판의 상태를 나타냅니다. 각 줄의 형식은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="7729563c964ef73ba71f39abfa320766ac0cea33" translate="yes" xml:space="preserve">
          <source>The status of the push is output in tabular form, with each line representing the status of a single ref. Each line is of the form:</source>
          <target state="translated">푸시 상태는 표 형식으로 출력되며 각 라인은 단일 심판의 상태를 나타냅니다. 각 줄의 형식은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="e939f21e3282d453b1398071feb25115360b90b4" translate="yes" xml:space="preserve">
          <source>The status of up-to-date refs is shown only if --porcelain or --verbose option is used.</source>
          <target state="translated">최신 참조 상태는 --porcelain 또는 --verbose 옵션을 사용하는 경우에만 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="0ebfa7ce02ec5605e425e0cd98062f5bbd8f2510" translate="yes" xml:space="preserve">
          <source>The status of up-to-date refs is shown only if the --verbose option is used.</source>
          <target state="translated">최신 참조 상태는 --verbose 옵션이 사용 된 경우에만 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="a97643bd561fabe3d136679e4752cb73667ec062" translate="yes" xml:space="preserve">
          <source>The structured objects can further have their structure and connectivity to other objects verified. This is generally done with the &lt;code&gt;git fsck&lt;/code&gt; program, which generates a full dependency graph of all objects, and verifies their internal consistency (in addition to just verifying their superficial consistency through the hash).</source>
          <target state="translated">구조화 된 객체는 구조 및 다른 객체와의 연결성을 확인할 수 있습니다. 일반적으로 &lt;code&gt;git fsck&lt;/code&gt; 프로그램을 사용하면 모든 객체의 전체 의존성 그래프를 생성하고 해시를 통해 표면 일관성을 확인하는 것 외에도 내부 일관성을 확인합니다.</target>
        </trans-unit>
        <trans-unit id="af4ab93b8907c3bc82033e90c4bc6eedaac09e1c" translate="yes" xml:space="preserve">
          <source>The submit process invokes the editor before each p4 change is submitted. If this setting is true, though, the editing step is skipped.</source>
          <target state="translated">제출 프로세스는 각 p4 변경 사항이 제출되기 전에 편집기를 호출합니다. 그러나이 설정이 참이면 편집 단계를 건너 뜁니다.</target>
        </trans-unit>
        <trans-unit id="72386229ffdfc0f6ba847ccdd7620fcafabeae30" translate="yes" xml:space="preserve">
          <source>The submodule directories are there, but they&amp;rsquo;re empty:</source>
          <target state="translated">하위 모듈 디렉토리가 있지만 비어 있습니다.</target>
        </trans-unit>
        <trans-unit id="802b1c9a36cac97c548242e11fe5baa3275576f0" translate="yes" xml:space="preserve">
          <source>The submodule will never be considered modified (but will nonetheless show up in the output of status and commit when it has been staged).</source>
          <target state="translated">서브 모듈은 수정 된 것으로 간주되지 않습니다 (그러나 그럼에도 불구하고 스테이트 출력시 상태 출력 및 커밋에 표시됨).</target>
        </trans-unit>
        <trans-unit id="7180d60887d97b6ca57dd91c2b86681f019ca631" translate="yes" xml:space="preserve">
          <source>The submodule&amp;rsquo;s &lt;code&gt;$GIT_DIR/config&lt;/code&gt; file would come into play when running &lt;code&gt;git push --recurse-submodules=check&lt;/code&gt; in the superproject, as this would check if the submodule has any changes not published to any remote. The remotes are configured in the submodule as usual in the &lt;code&gt;$GIT_DIR/config&lt;/code&gt; file.</source>
          <target state="translated">서브 &lt;code&gt;$GIT_DIR/config&lt;/code&gt; 의 $ GIT_DIR / config 파일은 수퍼 &lt;code&gt;git push --recurse-submodules=check&lt;/code&gt; 에서 git push --recurse-submodules = check 를 실행할 때 서브 모듈이 원격에 게시되지 않은 변경 사항이 있는지 확인하므로 실행 됩니다. 리모트는 &lt;code&gt;$GIT_DIR/config&lt;/code&gt; 파일 에서 평소와 같이 서브 모듈에서 구성 됩니다.</target>
        </trans-unit>
        <trans-unit id="2a87578b15befa74b2d27eca3216884ceb35493c" translate="yes" xml:space="preserve">
          <source>The suffix &lt;code&gt;@{push}&lt;/code&gt; reports the branch &quot;where we would push to&quot; if &lt;code&gt;git push&lt;/code&gt; were run while &lt;code&gt;branchname&lt;/code&gt; was checked out (or the current &lt;code&gt;HEAD&lt;/code&gt; if no branchname is specified). Since our push destination is in a remote repository, of course, we report the local tracking branch that corresponds to that branch (i.e., something in &lt;code&gt;refs/remotes/&lt;/code&gt;).</source>
          <target state="translated">접미사 &lt;code&gt;@{push}&lt;/code&gt; 는 &lt;code&gt;branchname&lt;/code&gt; 이 체크 아웃 된 상태에서 &lt;code&gt;git push&lt;/code&gt; 가 실행 된 경우 (또는 branchname이 지정되지 않은 경우 현재 &lt;code&gt;HEAD&lt;/code&gt; ) &quot;분기 할 위치&quot;를보고합니다 . 푸시 대상은 원격 저장소에 있기 때문에 해당 분기에 해당하는 로컬 추적 분기 (예 : &lt;code&gt;refs/remotes/&lt;/code&gt; )를보고합니다.</target>
        </trans-unit>
        <trans-unit id="c10fd9c6c93e1de11dbe32978aa15d853b4103fb" translate="yes" xml:space="preserve">
          <source>The suffix &lt;code&gt;@{upstream}&lt;/code&gt; to a branchname (short form &lt;code&gt;&amp;lt;branchname&amp;gt;@{u}&lt;/code&gt;) refers to the branch that the branch specified by branchname is set to build on top of (configured with &lt;code&gt;branch.&amp;lt;name&amp;gt;.remote&lt;/code&gt; and &lt;code&gt;branch.&amp;lt;name&amp;gt;.merge&lt;/code&gt;). A missing branchname defaults to the current one. These suffixes are also accepted when spelled in uppercase, and they mean the same thing no matter the case.</source>
          <target state="translated">분기 이름 의 접미사 &lt;code&gt;@{upstream}&lt;/code&gt; (약식 &lt;code&gt;&amp;lt;branchname&amp;gt;@{u}&lt;/code&gt; )은 branchname으로 지정된 분기가 ( &lt;code&gt;branch.&amp;lt;name&amp;gt;.remote&lt;/code&gt; 및 &lt;code&gt;branch.&amp;lt;name&amp;gt;.merge&lt;/code&gt; 구성됨) 위에 빌드되도록 설정된 분기를 나타냅니다. &amp;lt;이름&amp;gt; .merge ). 누락 된 분기 이름은 기본적으로 현재 이름입니다. 이 접미어는 대문자로 표기 할 때도 허용되며 경우에 상관없이 동일한 의미를 갖습니다.</target>
        </trans-unit>
        <trans-unit id="35fca7d90e0c51050df5863335fd96cb674d847a" translate="yes" xml:space="preserve">
          <source>The symlink will either be absolute (beginning with a /), or relative to the tree root. For instance, if dir/link points to ../../foo, then &amp;lt;symlink&amp;gt; will be ../foo. &amp;lt;size&amp;gt; is the size of the symlink in bytes.</source>
          <target state="translated">심볼릭 링크는 절대적이거나 (/로 시작) 나무 루트에 상대적입니다. 예를 들어 dir / link가 ../../foo를 가리키는 경우 &amp;lt;symlink&amp;gt;는 ../foo가됩니다. &amp;lt;size&amp;gt;는 바이트 단위의 심볼릭 링크 크기입니다.</target>
        </trans-unit>
        <trans-unit id="1e32c77f2578ce3c979cd217827d9aa3c6897be9" translate="yes" xml:space="preserve">
          <source>The syntax is fairly flexible and permissive; whitespaces are mostly ignored. The &lt;code&gt;#&lt;/code&gt; and &lt;code&gt;;&lt;/code&gt; characters begin comments to the end of line, blank lines are ignored.</source>
          <target state="translated">구문은 상당히 유연하고 허용 적입니다. 공백은 대부분 무시됩니다. &lt;code&gt;#&lt;/code&gt; 와 &lt;code&gt;;&lt;/code&gt; 문자는 줄 끝에 주석을 시작하고 빈 줄은 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="e9a240786337cb206c43c416821000b9a6721022" translate="yes" xml:space="preserve">
          <source>The syntax of the configuration files is that of Perl, since these files are handled by sourcing them as fragments of Perl code (the language that gitweb itself is written in). Variables are typically set using the &lt;code&gt;our&lt;/code&gt; qualifier (as in &quot;&lt;code&gt;our $variable = &amp;lt;value&amp;gt;;&lt;/code&gt;&quot;) to avoid syntax errors if a new version of gitweb no longer uses a variable and therefore stops declaring it.</source>
          <target state="translated">구성 파일의 구문은 Perl의 구문입니다. 이러한 파일은 Perl 코드의 조각 (gitweb 자체가 작성하는 언어)으로 소싱하여 처리되기 때문입니다. 변수는 일반적으로 사용되지 설정된 &lt;code&gt;our&lt;/code&gt; ( &quot;과 규정을 &lt;code&gt;our $variable = &amp;lt;value&amp;gt;;&lt;/code&gt; gitweb의 새 버전이 더 이상 변수를 사용하며, 따라서 선언 멈 추면 않도록 문법 에러&quot;).</target>
        </trans-unit>
        <trans-unit id="85d5722bf15562fb833fe3c8f580a92fe2e2d3db" translate="yes" xml:space="preserve">
          <source>The tables below show what happens when running:</source>
          <target state="translated">아래 표는 실행시 발생하는 상황을 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="0ab961c529e0da6916842ede03d74fc7b0e0f90e" translate="yes" xml:space="preserve">
          <source>The tag &lt;code&gt;v2.6.18&lt;/code&gt; is short for &lt;code&gt;refs/tags/v2.6.18&lt;/code&gt;.</source>
          <target state="translated">태그 &lt;code&gt;v2.6.18&lt;/code&gt; 은 &lt;code&gt;refs/tags/v2.6.18&lt;/code&gt; 의 줄임말입니다 .</target>
        </trans-unit>
        <trans-unit id="e5173af0305c1d6df2de24b7ea317c256f65109e" translate="yes" xml:space="preserve">
          <source>The template directory will be one of the following (in order):</source>
          <target state="translated">템플릿 디렉토리는 다음 중 하나입니다 (순서대로).</target>
        </trans-unit>
        <trans-unit id="45d4fdaf8fe9ac583ec50051c8f5eb8c944a1ec1" translate="yes" xml:space="preserve">
          <source>The term &lt;a href=&quot;#def_pickaxe&quot;&gt;pickaxe&lt;/a&gt; refers to an option to the diffcore routines that help select changes that add or delete a given text string. With the &lt;code&gt;--pickaxe-all&lt;/code&gt; option, it can be used to view the full &lt;a href=&quot;#def_changeset&quot;&gt;changeset&lt;/a&gt; that introduced or removed, say, a particular line of text. See &lt;a href=&quot;git-diff&quot;&gt;git-diff[1]&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#def_pickaxe&quot;&gt;pickaxe&lt;/a&gt; 라는 용어 는 주어진 텍스트 문자열을 추가하거나 삭제하는 변경 사항을 선택하는 데 도움이되는 diffcore 루틴에 대한 옵션을 나타냅니다. 으로 &lt;code&gt;--pickaxe-all&lt;/code&gt; 옵션, 전체 볼 수 있습니다 &lt;a href=&quot;#def_changeset&quot;&gt;변경 집합을&lt;/a&gt; 말한다, 텍스트의 특정 라인을 도입하거나 제거 할 것이다. &lt;a href=&quot;git-diff&quot;&gt;git-diff [1]을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="d2ba0595fa8d197d8c3640c03007e070ceba5b47" translate="yes" xml:space="preserve">
          <source>The text conversion is generally a one-way conversion; in this example, we lose the actual image contents and focus just on the text data. This means that diffs generated by textconv are &lt;em&gt;not&lt;/em&gt; suitable for applying. For this reason, only &lt;code&gt;git diff&lt;/code&gt; and the &lt;code&gt;git log&lt;/code&gt; family of commands (i.e., log, whatchanged, show) will perform text conversion. &lt;code&gt;git
format-patch&lt;/code&gt; will never generate this output. If you want to send somebody a text-converted diff of a binary file (e.g., because it quickly conveys the changes you have made), you should generate it separately and send it as a comment &lt;em&gt;in addition to&lt;/em&gt; the usual binary diff that you might send.</source>
          <target state="translated">텍스트 변환은 일반적으로 단방향 변환입니다. 이 예에서는 실제 이미지 내용을 잃고 텍스트 데이터에만 집중합니다. 이것은 textconv에 의해 생성 된 diff가 적용하기에 적합 &lt;em&gt;하지 않음을&lt;/em&gt; 의미합니다 . 따라서 &lt;code&gt;git diff&lt;/code&gt; 및 &lt;code&gt;git log&lt;/code&gt; 명령 계열 (즉, log, whatchanged, show) 만 텍스트 변환을 수행합니다. &lt;code&gt;git format-patch&lt;/code&gt; 는이 출력을 생성하지 않습니다. 누군가에게 이진 파일의 텍스트로 변환 된 diff를 보내려면 (예를 들어, 변경 한 내용을 빠르게 전달하기 때문에),이 파일을 별도로 생성 하여 일반적인 바이너리 diff &lt;em&gt;외에&lt;/em&gt; 주석으로 보내야합니다. 보내다.</target>
        </trans-unit>
        <trans-unit id="eb234a21c48fd769b7576108683d04bf29f253cb" translate="yes" xml:space="preserve">
          <source>The third syntax (&quot;&lt;code&gt;git merge --continue&lt;/code&gt;&quot;) can only be run after the merge has resulted in conflicts.</source>
          <target state="translated">세 번째 구문 ( &quot; &lt;code&gt;git merge --continue&lt;/code&gt; &quot;)은 병합 결과 충돌이 발생한 후에 만 ​​실행할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a25be90a41e318ce76ddb9737f9c1a04e1e950e3" translate="yes" xml:space="preserve">
          <source>The time between the first rc release and the final release is supposed to be used to test rc versions and fight bugs and especially regressions. And this time is more than 80% of the release cycle time. But this is not the end of the fight yet, as of course it continues after the release.</source>
          <target state="translated">첫 번째 rc 릴리스와 마지막 릴리스 사이의 시간은 rc 버전을 테스트하고 버그 및 특히 회귀와 싸우는 데 사용됩니다. 그리고이 시간은 릴리스주기 시간의 80 % 이상입니다. 그러나 이것은 아직 싸움의 끝이 아니며, 물론 석방 후에도 계속됩니다.</target>
        </trans-unit>
        <trans-unit id="75271c1b7d85cdfdc3bad04249d4464b9c292a44" translate="yes" xml:space="preserve">
          <source>The time of the change is specified by &lt;code&gt;&amp;lt;when&amp;gt;&lt;/code&gt; using the date format that was selected by the --date-format=&amp;lt;fmt&amp;gt; command-line option. See &amp;ldquo;Date Formats&amp;rdquo; above for the set of supported formats, and their syntax.</source>
          <target state="translated">변경 시간은 --date-format = &amp;lt;fmt&amp;gt; 명령 줄 옵션에 의해 선택된 날짜 형식을 사용하여 &lt;code&gt;&amp;lt;when&amp;gt;&lt;/code&gt; 에 의해 지정됩니다 . 지원되는 형식 및 구문에 대해서는 위의&amp;ldquo;날짜 형식&amp;rdquo;을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="05b9a4ac37ff05623171d65150ac27013efa2fa0" translate="yes" xml:space="preserve">
          <source>The time of the event is specified by &lt;code&gt;&amp;lt;time&amp;gt;&lt;/code&gt; as the number of seconds since the UNIX epoch (midnight, Jan 1, 1970, UTC) and is written as an ASCII decimal integer.</source>
          <target state="translated">이벤트 &lt;code&gt;&amp;lt;time&amp;gt;&lt;/code&gt; 은 UNIX 시간 (1970 년 1 월 1 일 자정, UTC) 이후의 초 수로 &amp;lt;time&amp;gt; 으로 지정되며 ASCII 십진 정수로 작성됩니다.</target>
        </trans-unit>
        <trans-unit id="e85bdfa8e02113c7aa36696add629ec632f05440" translate="yes" xml:space="preserve">
          <source>The todo list presented by the deprecated &lt;code&gt;--preserve-merges --interactive&lt;/code&gt; does not represent the topology of the revision graph (use &lt;code&gt;--rebase-merges&lt;/code&gt; instead). Editing commits and rewording their commit messages should work fine, but attempts to reorder commits tend to produce counterintuitive results. Use &lt;code&gt;--rebase-merges&lt;/code&gt; in such scenarios instead.</source>
          <target state="translated">더 이상 사용되지 않는 &lt;code&gt;--preserve-merges --interactive&lt;/code&gt; 로 표시되는 할 일 목록 은 개정 그래프의 토폴로지를 나타내지 않습니다 ( 대신 &lt;code&gt;--rebase-merges&lt;/code&gt; 를 사용하십시오). 커밋을 편집하고 커밋 메시지를 다시 쓰는 것은 잘 작동하지만 커밋 순서를 바꾸려는 시도는 반 직관적 인 결과를 생성하는 경향이 있습니다. 사용 &lt;code&gt;--rebase-merges&lt;/code&gt; 대신 같은 시나리오를.</target>
        </trans-unit>
        <trans-unit id="0f8166907df228eb9266d7566c3cde991d9d39bd" translate="yes" xml:space="preserve">
          <source>The total number of paths.</source>
          <target state="translated">총 경로 수</target>
        </trans-unit>
        <trans-unit id="46c0269533706ef03961ed4548e480cdcfd7a84a" translate="yes" xml:space="preserve">
          <source>The trailer records 20-byte SHA-1 checksum of all of the above.</source>
          <target state="translated">트레일러는 위의 모든 것의 20 바이트 SHA-1 체크섬을 기록합니다.</target>
        </trans-unit>
        <trans-unit id="9380254df0eb0e126f55d72177d625190ab23928" translate="yes" xml:space="preserve">
          <source>The transmission of the packfile begins immediately after the section header</source>
          <target state="translated">팩 파일의 전송은 섹션 헤더 바로 다음에 시작됩니다.</target>
        </trans-unit>
        <trans-unit id="de285c430d2e1f897693d7ccc23434e1a3a5c103" translate="yes" xml:space="preserve">
          <source>The tree object is the tree we examined first, and this commit is unusual in that it lacks any parent.</source>
          <target state="translated">트리 객체는 우리가 먼저 검사 한 트리이며,이 커밋은 부모가 없다는 점에서 특이합니다.</target>
        </trans-unit>
        <trans-unit id="9178b43dc9b2907a6afd7a3693f2c6894ec0ecd9" translate="yes" xml:space="preserve">
          <source>The tree of actual checked out files. The working tree normally contains the contents of the &lt;a href=&quot;#def_HEAD&quot;&gt;HEAD&lt;/a&gt; commit&amp;rsquo;s tree, plus any local changes that you have made but not yet committed.</source>
          <target state="translated">실제로 체크 아웃 된 파일의 트리입니다. 작업 트리에는 일반적으로 &lt;a href=&quot;#def_HEAD&quot;&gt;HEAD&lt;/a&gt; 커밋 트리 의 내용과 함께 아직 커밋하지 않은 로컬 변경 내용이 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="26b5c7d70f82997ceabb111adeeb911e4d89a340" translate="yes" xml:space="preserve">
          <source>The tree or commit to produce an archive for.</source>
          <target state="translated">아카이브를 생성하기위한 트리 또는 커밋.</target>
        </trans-unit>
        <trans-unit id="90f78952a054862b4ed6d79982e2eab2fc081a24" translate="yes" xml:space="preserve">
          <source>The twist is that if some file doesn&amp;rsquo;t match the index, we don&amp;rsquo;t have a backing store thing for it, and we use the magic &quot;all-zero&quot; sha1 to show that. So let&amp;rsquo;s say that you have edited &lt;code&gt;kernel/sched.c&lt;/code&gt;, but have not actually done a &lt;code&gt;git update-index&lt;/code&gt; on it yet - there is no &quot;object&quot; associated with the new state, and you get:</source>
          <target state="translated">일부 파일이 색인과 일치하지 않으면 백업 저장소가 없으며 마술 &quot;0&quot;sha1을 사용하여 표시합니다. 따라서 &lt;code&gt;kernel/sched.c&lt;/code&gt; 를 편집 했지만 실제로 &lt;code&gt;git update-index&lt;/code&gt; 를 아직 수행하지 않았다고 가정 해 봅시다 . 새로운 상태와 관련된 &quot;객체&quot;가 없으며 다음과 같은 결과가 나타납니다.</target>
        </trans-unit>
        <trans-unit id="43d0ee9ad50c1c3c133c4c2ff3f216463ab119aa" translate="yes" xml:space="preserve">
          <source>The two options can be specified together to ask a command to work on both the index and the working tree.</source>
          <target state="translated">인덱스와 작업 트리 모두에서 작동하도록 명령을 요청하기 위해 두 옵션을 함께 지정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="293c342524c5d665ec090c34f37c73d153be74d5" translate="yes" xml:space="preserve">
          <source>The type of the object (&lt;code&gt;blob&lt;/code&gt;, &lt;code&gt;tree&lt;/code&gt;, &lt;code&gt;commit&lt;/code&gt;, &lt;code&gt;tag&lt;/code&gt;).</source>
          <target state="translated">객체의 유형 ( &lt;code&gt;blob&lt;/code&gt; , &lt;code&gt;tree&lt;/code&gt; , &lt;code&gt;commit&lt;/code&gt; , &lt;code&gt;tag&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="35ca6d49608b210b7cf8be4b86261fa4bd55e249" translate="yes" xml:space="preserve">
          <source>The type of the object (the same as &lt;code&gt;cat-file -t&lt;/code&gt; reports).</source>
          <target state="translated">개체의 유형입니다 ( &lt;code&gt;cat-file -t&lt;/code&gt; 보고서 와 동일 ).</target>
        </trans-unit>
        <trans-unit id="4785efb96aaa5561500dccbb8420f79e52290b85" translate="yes" xml:space="preserve">
          <source>The underlying Git plumbing tools, such as &lt;code&gt;git ls-files&lt;/code&gt; and &lt;code&gt;git read-tree&lt;/code&gt;, read &lt;code&gt;gitignore&lt;/code&gt; patterns specified by command-line options, or from files specified by command-line options. Higher-level Git tools, such as &lt;code&gt;git status&lt;/code&gt; and &lt;code&gt;git add&lt;/code&gt;, use patterns from the sources specified above.</source>
          <target state="translated">&lt;code&gt;git ls-files&lt;/code&gt; 및 &lt;code&gt;git read-tree&lt;/code&gt; 와 같은 기본 Git 배관 도구 는 명령 행 옵션으로 지정된 &lt;code&gt;gitignore&lt;/code&gt; 패턴을 읽 거나 명령 행 옵션으로 지정된 파일에서 읽습니다 . &lt;code&gt;git status&lt;/code&gt; 및 &lt;code&gt;git add&lt;/code&gt; 와 같은 상위 레벨 Git 도구는 위에 지정된 소스의 패턴을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="c7717dd458d0c51efaa12d77d8ac91e6b1b7952a" translate="yes" xml:space="preserve">
          <source>The unique identifier of an &lt;a href=&quot;#def_object&quot;&gt;object&lt;/a&gt;. The object name is usually represented by a 40 character hexadecimal string. Also colloquially called &lt;a href=&quot;#def_SHA1&quot;&gt;SHA-1&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#def_object&quot;&gt;객체&lt;/a&gt; 의 고유 식별자입니다 . 오브젝트 이름은 일반적으로 40 자 16 진 문자열로 표시됩니다. 구어 적으로 &lt;a href=&quot;#def_SHA1&quot;&gt;SHA-1&lt;/a&gt; 이라고도 합니다.</target>
        </trans-unit>
        <trans-unit id="190c2fffcaa0444f677f39ee7f8533684a0964b1" translate="yes" xml:space="preserve">
          <source>The unit of storage in Git. It is uniquely identified by the &lt;a href=&quot;#def_SHA1&quot;&gt;SHA-1&lt;/a&gt; of its contents. Consequently, an object cannot be changed.</source>
          <target state="translated">Git의 저장 단위. 내용 의 &lt;a href=&quot;#def_SHA1&quot;&gt;SHA-1&lt;/a&gt; 로 고유하게 식별됩니다 . 따라서 개체를 변경할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="39871fae2a5575ced5627a5aed0eb792e4c6cc2e" translate="yes" xml:space="preserve">
          <source>The untracked cache extension can be enabled by the &lt;code&gt;core.untrackedCache&lt;/code&gt; configuration variable (see &lt;a href=&quot;git-config&quot;&gt;git-config[1]&lt;/a&gt;).</source>
          <target state="translated">추적되지 않은 캐시 확장은 &lt;code&gt;core.untrackedCache&lt;/code&gt; 구성 변수에 의해 활성화 될 수 있습니다 ( &lt;a href=&quot;git-config&quot;&gt;git-config [1] 참조&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="cc7260429a75073116cdc4eb67dbd95326cbd29d" translate="yes" xml:space="preserve">
          <source>The upstream project is expected to have the commit named by &lt;code&gt;&amp;lt;start&amp;gt;&lt;/code&gt; and the output asks it to integrate the changes you made since that commit, up to the commit named by &lt;code&gt;&amp;lt;end&amp;gt;&lt;/code&gt;, by visiting the repository named by &lt;code&gt;&amp;lt;url&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">업스트림 프로젝트는 &lt;code&gt;&amp;lt;start&amp;gt;&lt;/code&gt; 라는 커밋을 가질 것으로 예상되며 출력은 &lt;code&gt;&amp;lt;url&amp;gt;&lt;/code&gt; 이라는 저장소를 방문하여 커밋 이후 변경 사항을 &lt;code&gt;&amp;lt;end&amp;gt;&lt;/code&gt; 라는 커밋까지 통합하도록 요청합니다 .</target>
        </trans-unit>
        <trans-unit id="90c1df21766dd92e926e4168cc9d516f756c7832" translate="yes" xml:space="preserve">
          <source>The upstream reference is generally &lt;code&gt;refs/remotes/p4/master&lt;/code&gt;, but can be overridden using the &lt;code&gt;--origin=&lt;/code&gt; command-line option.</source>
          <target state="translated">업스트림 참조는 일반적으로 &lt;code&gt;refs/remotes/p4/master&lt;/code&gt; 이지만 &lt;code&gt;--origin=&lt;/code&gt; 명령 줄 옵션을 사용하여 재정의 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="26e6d639f86a47deca57ab3911edaae9c5141f38" translate="yes" xml:space="preserve">
          <source>The user wants to fast-forward to $M.</source>
          <target state="translated">사용자는 $ M으로 빨리 감기를 원합니다.</target>
        </trans-unit>
        <trans-unit id="6df61c6f9e257fdbf1ce4a60fb1d73b618d329ca" translate="yes" xml:space="preserve">
          <source>The user&amp;rsquo;s color.status configuration is not respected; color will always be off.</source>
          <target state="translated">사용자의 color.status 구성은 존중되지 않습니다. 색상은 항상 꺼져 있습니다.</target>
        </trans-unit>
        <trans-unit id="ab6a20b222f27dba657bc91ae7970effd7a690ca" translate="yes" xml:space="preserve">
          <source>The user&amp;rsquo;s status.relativePaths configuration is not respected; paths shown will always be relative to the repository root.</source>
          <target state="translated">사용자의 status.relativePaths 구성은 존중되지 않습니다. 표시된 경로는 항상 저장소 루트를 기준으로합니다.</target>
        </trans-unit>
        <trans-unit id="20126eaca194f3ace1deaba2aaa4133e6326b674" translate="yes" xml:space="preserve">
          <source>The user-provided shell commands will likely involve a pipeline of commands, resulting in the creation of many processes per commit. Creating and running another process takes a widely varying amount of time between operating systems, but on any platform it is very slow relative to invoking a function.</source>
          <target state="translated">사용자가 제공 한 셸 명령에는 명령 파이프 라인이 포함되어 커밋 당 많은 프로세스가 만들어집니다. 다른 프로세스를 작성하고 실행하는 데는 운영 체제간에 시간이 많이 걸리지 만 플랫폼에 관계없이 함수 호출에 비해 속도가 느립니다.</target>
        </trans-unit>
        <trans-unit id="b70cc2efdcbaf68bada34e0550746a0012d52bae" translate="yes" xml:space="preserve">
          <source>The username to use when logging in to the server.</source>
          <target state="translated">서버에 로그인 할 때 사용할 사용자 이름입니다.</target>
        </trans-unit>
        <trans-unit id="46c33e134557b27ccb1a85349808f80ba518bd84" translate="yes" xml:space="preserve">
          <source>The valid values for this option are: &lt;code&gt;add&lt;/code&gt; (this is the default) and &lt;code&gt;doNothing&lt;/code&gt;.</source>
          <target state="translated">이 옵션의 유효한 값은 &lt;code&gt;add&lt;/code&gt; (이것이 기본값) 및 &lt;code&gt;doNothing&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="17a990c606d2e2e22a8f755a1f843b57ef2f5ef2" translate="yes" xml:space="preserve">
          <source>The valid values for this option are: &lt;code&gt;addIfDifferentNeighbor&lt;/code&gt; (this is the default), &lt;code&gt;addIfDifferent&lt;/code&gt;, &lt;code&gt;add&lt;/code&gt;, &lt;code&gt;replace&lt;/code&gt; or &lt;code&gt;doNothing&lt;/code&gt;.</source>
          <target state="translated">이 옵션의 유효한 값은 &lt;code&gt;addIfDifferentNeighbor&lt;/code&gt; (기본값), &lt;code&gt;addIfDifferent&lt;/code&gt; , &lt;code&gt;add&lt;/code&gt; , &lt;code&gt;replace&lt;/code&gt; 또는 &lt;code&gt;doNothing&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="505e929c5c3b27eed17b03a2625718de5c7f7031" translate="yes" xml:space="preserve">
          <source>The value for a variable that takes a color is a list of colors (at most two, one for foreground and one for background) and attributes (as many as you want), separated by spaces.</source>
          <target state="translated">색상을 취하는 변수의 값은 공백으로 구분 된 색상 (최대 2 개, 전경 및 1) 및 속성 (원하는 수) 목록입니다.</target>
        </trans-unit>
        <trans-unit id="e1d242fc18797a443a86ba553d48e3f3cae01e9a" translate="yes" xml:space="preserve">
          <source>The value for many variables that specify various sizes can be suffixed with &lt;code&gt;k&lt;/code&gt;, &lt;code&gt;M&lt;/code&gt;,&amp;hellip;​ to mean &quot;scale the number by 1024&quot;, &quot;by 1024x1024&quot;, etc.</source>
          <target state="translated">다양한 크기를 지정하는 많은 변수의 값은 &lt;code&gt;k&lt;/code&gt; , &lt;code&gt;M&lt;/code&gt; 으로 접미사로 붙일 수 있습니다. &quot;1024의 숫자로 스케일링&quot;, &quot;1024x1024에 의해&quot;스케일링 등을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="f1dedc58ec3c676ad597a786553123421e517365" translate="yes" xml:space="preserve">
          <source>The value is a list of three values: a default time zone (for if the client hasn&amp;rsquo;t selected some other time zone and saved it in a cookie), a name of cookie where to store selected time zone, and a CSS class used to mark up dates for manipulation. If you want to turn this feature off, set &quot;default&quot; to empty list: &lt;code&gt;[]&lt;/code&gt;.</source>
          <target state="translated">이 값은 기본 시간대 (클라이언트가 다른 시간대를 선택하지 않고 쿠키에 저장 한 경우), 선택한 시간대를 저장할 쿠키 이름 및 사용 된 CSS 클래스의 세 가지 값 목록입니다. 조작 날짜를 표시합니다. 이 기능을 끄려면 &quot;default&quot;를 빈 목록으로 설정하십시오 : &lt;code&gt;[]&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0462ada8e80b752f4ecad69fb2563ec0b8b930aa" translate="yes" xml:space="preserve">
          <source>The value of 'default' is a list of names of snapshot formats, defined in &lt;code&gt;%known_snapshot_formats&lt;/code&gt; hash, that you wish to offer. Supported formats include &quot;tgz&quot;, &quot;tbz2&quot;, &quot;txz&quot; (gzip/bzip2/xz compressed tar archive) and &quot;zip&quot;; please consult gitweb sources for a definitive list. By default only &quot;tgz&quot; is offered.</source>
          <target state="translated">'default'값은 제공하려는 &lt;code&gt;%known_snapshot_formats&lt;/code&gt; 해시에 정의 된 스냅 샷 형식의 이름 목록입니다 . 지원되는 형식은 &quot;tgz&quot;, &quot;tbz2&quot;, &quot;txz&quot;(gzip / bzip2 / xz 압축 tar 아카이브) 및 &quot;zip&quot;입니다. 결정적인 목록은 gitweb 소스를 참조하십시오. 기본적으로 &quot;tgz&quot;만 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="c34b53e9a12553098df9adad4c30762484ffde18" translate="yes" xml:space="preserve">
          <source>The value of &lt;code&gt;&amp;lt;name&amp;gt;&lt;/code&gt; must be a valid refname in Git and therefore may contain forward slashes. As &lt;code&gt;LF&lt;/code&gt; is not valid in a Git refname, no quoting or escaping syntax is supported here.</source>
          <target state="translated">&lt;code&gt;&amp;lt;name&amp;gt;&lt;/code&gt; 의 값은 Git에서 유효한 참조 이름 이어야하므로 슬래시를 포함 할 수 있습니다. 으로 &lt;code&gt;LF&lt;/code&gt; 가 힘내 refname에 유효하지 않은, 더 인용 또는 이스케이프 구문은 여기에 지원되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="8b5a30f586808b1827fdb8f433a15c6c9d49f6ba" translate="yes" xml:space="preserve">
          <source>The value of &lt;code&gt;&amp;lt;path&amp;gt;&lt;/code&gt; must be in canonical form. That is it must not:</source>
          <target state="translated">&lt;code&gt;&amp;lt;path&amp;gt;&lt;/code&gt; 의 값은 정식 형식이어야합니다. 그것은해서는 안됩니다 :</target>
        </trans-unit>
        <trans-unit id="dfb2ec984e9987b1b930824861a3abbf3e4aa29f" translate="yes" xml:space="preserve">
          <source>The value of this attribute specifies the character encoding that should be used by GUI tools (e.g. &lt;a href=&quot;gitk&quot;&gt;gitk[1]&lt;/a&gt; and &lt;a href=&quot;git-gui&quot;&gt;git-gui[1]&lt;/a&gt;) to display the contents of the relevant file. Note that due to performance considerations &lt;a href=&quot;gitk&quot;&gt;gitk[1]&lt;/a&gt; does not use this attribute unless you manually enable per-file encodings in its options.</source>
          <target state="translated">이 속성의 값은 GUI 도구 (예 : &lt;a href=&quot;gitk&quot;&gt;gitk [1]&lt;/a&gt; 및 &lt;a href=&quot;git-gui&quot;&gt;git-gui [1]&lt;/a&gt; )가 관련 파일의 내용을 표시하는 데 사용해야하는 문자 인코딩을 지정 합니다. 성능 고려 사항으로 인해 &lt;a href=&quot;gitk&quot;&gt;gitk [1]&lt;/a&gt; 은 옵션에서 파일 별 인코딩을 수동으로 활성화하지 않는 한이 속성을 사용하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="4bdcd2a8dee01aee6c5f0f23e7e10ac25985aae6" translate="yes" xml:space="preserve">
          <source>The value of this key is the name of the promisor remote.</source>
          <target state="translated">이 키의 값은 Promisor Remote의 이름입니다.</target>
        </trans-unit>
        <trans-unit id="49e3be97b83e2e2d47823db7b33592c5066364cc" translate="yes" xml:space="preserve">
          <source>The version parameter is used to specify the format version. This is optional and defaults to the original version &lt;code&gt;v1&lt;/code&gt; format.</source>
          <target state="translated">version 매개 변수는 형식 버전을 지정하는 데 사용됩니다. 이것은 선택 사항이며 기본값은 원래 버전 &lt;code&gt;v1&lt;/code&gt; 형식입니다.</target>
        </trans-unit>
        <trans-unit id="a720bc9826a296e909d26ea1e1addd2076945090" translate="yes" xml:space="preserve">
          <source>The victim sends &quot;have&quot; lines advertising the IDs of objects it has that are not explicitly intended to be shared but can be used to optimize the transfer if the peer also has them. The attacker chooses an object ID X to steal and sends a ref to X, but isn&amp;rsquo;t required to send the content of X because the victim already has it. Now the victim believes that the attacker has X, and it sends the content of X back to the attacker later. (This attack is most straightforward for a client to perform on a server, by creating a ref to X in the namespace the client has access to and then fetching it. The most likely way for a server to perform it on a client is to &quot;merge&quot; X into a public branch and hope that the user does additional work on this branch and pushes it back to the server without noticing the merge.)</source>
          <target state="translated">피해자는 명시 적으로 공유 할 의도는 없지만 피어가 가지고있는 경우 전송을 최적화하는 데 사용할 수있는 오브젝트의 ID를 알리는 &quot;have&quot;라인을 보냅니다. 공격자는 개체 ID X를 선택하여 도용하고 참조를 X로 보냅니다. 그러나 피해자가 이미 가지고 있기 때문에 X의 내용을 보낼 필요는 없습니다. 이제 피해자는 공격자가 X를 가지고 있다고 믿고 나중에 X의 내용을 공격자에게 다시 보냅니다. (이 공격은 클라이언트가 액세스 할 수있는 네임 스페이스에서 X에 대한 참조를 생성 한 후 가져 와서 클라이언트가 서버에서 수행하는 가장 간단한 방법입니다. 서버가 클라이언트에서이를 수행하는 가장 가능성이 높은 방법은 &quot; X를 공개 브랜치로 병합하고 사용자가이 브랜치에서 추가 작업을 수행하고 병합을 알리지 않고 서버로 다시 밀어 넣기를 바랍니다.)</target>
        </trans-unit>
        <trans-unit id="bad569f9e07003c7e9ba90b91ff6d5e2d3ebab92" translate="yes" xml:space="preserve">
          <source>The virtual host configuration (in Apache configuration file) should look like this:</source>
          <target state="translated">Apache 구성 파일의 가상 호스트 구성은 다음과 같아야합니다.</target>
        </trans-unit>
        <trans-unit id="6258db9fdd3beac891e6dcfd7dedb19764ce413e" translate="yes" xml:space="preserve">
          <source>The way &lt;code&gt;git update-index&lt;/code&gt; handles files it is told about can be modified using the various options:</source>
          <target state="translated">&lt;code&gt;git update-index&lt;/code&gt; 가 파일을 처리 하는 방식 은 다양한 옵션을 사용하여 수정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="dc2adc08265063993fb836b81a622f1e26249d55" translate="yes" xml:space="preserve">
          <source>The web browser can be specified using the configuration variable &lt;code&gt;help.browser&lt;/code&gt;, or &lt;code&gt;web.browser&lt;/code&gt; if the former is not set. If none of these config variables is set, the &lt;code&gt;git web{litdd}browse&lt;/code&gt; helper script (called by &lt;code&gt;git help&lt;/code&gt;) will pick a suitable default. See git-web{litdd}browse[1] for more information about this.</source>
          <target state="translated">구성 변수 &lt;code&gt;help.browser&lt;/code&gt; 또는 &lt;code&gt;web.browser&lt;/code&gt; 를 설정하지 않은 경우 웹 브라우저를 구성 변수로 지정할 수 있습니다 . 이러한 구성 변수가 설정되지 않은 경우 &lt;code&gt;git web{litdd}browse&lt;/code&gt; 도우미 스크립트 ( &lt;code&gt;git help&lt;/code&gt; 라고 함 )가 적절한 기본값을 선택합니다. 이에 대한 자세한 내용은 git-web {litdd} browse [1]를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="c38f40c77930468f76ac59e3f127231f37c11803" translate="yes" xml:space="preserve">
          <source>The web browser that should be used to view the gitweb page. This will be passed to the &lt;code&gt;git web{litdd}browse&lt;/code&gt; helper script along with the URL of the gitweb instance. See git-web{litdd}browse[1] for more information about this. If the script fails, the URL will be printed to stdout.</source>
          <target state="translated">gitweb 페이지를 보는 데 사용해야하는 웹 브라우저. 이것은 gitweb 인스턴스의 URL과 함께 &lt;code&gt;git web{litdd}browse&lt;/code&gt; 도우미 스크립트 로 전달됩니다 . 이에 대한 자세한 내용은 git-web {litdd} browse [1]를 참조하십시오. 스크립트가 실패하면 URL이 표준 출력으로 인쇄됩니다.</target>
        </trans-unit>
        <trans-unit id="c7492cc5fa9e9927a227312bd1f1ea85a3766cb5" translate="yes" xml:space="preserve">
          <source>The width (in characters) of the &quot;Description&quot; column of the projects list. Longer descriptions will be truncated (trying to cut at word boundary); the full description is available in the &lt;code&gt;title&lt;/code&gt; attribute (usually shown on mouseover). The default is 25, which might be too small if you use long project descriptions.</source>
          <target state="translated">프로젝트 목록의 &quot;설명&quot;열의 너비 (문자)입니다. 더 긴 설명은 잘립니다 (단어 경계에서 자르려고 시도 함). 자세한 설명은 &lt;code&gt;title&lt;/code&gt; 속성 (일반적으로 마우스 오버에 표시)에서 사용할 수 있습니다 . 기본값은 25이며, 긴 프로젝트 설명을 사용하면 너무 작을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2a9553b8b798d28f6c8fd9f09980f5b7959498e9" translate="yes" xml:space="preserve">
          <source>The window size parameter used in the delta compression algorithm used by &lt;code&gt;git gc --aggressive&lt;/code&gt;. This defaults to 250, which is a much more aggressive window size than the default &lt;code&gt;--window&lt;/code&gt; of 10.</source>
          <target state="translated">&lt;code&gt;git gc --aggressive&lt;/code&gt; 가 사용하는 델타 압축 알고리즘에 사용되는 창 크기 매개 변수 입니다. 기본값은 250으로, 기본 &lt;code&gt;--window&lt;/code&gt; 10 보다 훨씬 공격적인 창 크기 입니다.</target>
        </trans-unit>
        <trans-unit id="046739930d5e8946cdceaf820a70c4ac9ebc8d51" translate="yes" xml:space="preserve">
          <source>The working directory then reflects the contents that the project had when it was tagged v2.6.13, and &lt;a href=&quot;git-branch&quot;&gt;git-branch[1]&lt;/a&gt; shows two branches, with an asterisk marking the currently checked-out branch:</source>
          <target state="translated">작업 디렉토리는 프로젝트가 v2.6.13으로 태그 될 때 가지고 있던 내용을 반영하고 &lt;a href=&quot;git-branch&quot;&gt;git-branch [1]&lt;/a&gt; 은 현재 체크 아웃 된 분기를 표시하는 별표와 함께 두 개의 분기를 표시합니다.</target>
        </trans-unit>
        <trans-unit id="c76d23bfcb6d4a63fd96acda23f8bee068090518" translate="yes" xml:space="preserve">
          <source>The worktree list command has two output formats. The default format shows the details on a single line with columns. For example:</source>
          <target state="translated">worktree list 명령에는 두 가지 출력 형식이 있습니다. 기본 형식은 열이있는 단일 행에 세부 사항을 표시합니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="ecaf7c5f30215b083ffbd406549425a7d1040c7d" translate="yes" xml:space="preserve">
          <source>Then &quot;&lt;code&gt;git merge topic&lt;/code&gt;&quot; will replay the changes made on the &lt;code&gt;topic&lt;/code&gt; branch since it diverged from &lt;code&gt;master&lt;/code&gt; (i.e., &lt;code&gt;E&lt;/code&gt;) until its current commit (&lt;code&gt;C&lt;/code&gt;) on top of &lt;code&gt;master&lt;/code&gt;, and record the result in a new commit along with the names of the two parent commits and a log message from the user describing the changes.</source>
          <target state="translated">그런 다음 &quot; &lt;code&gt;git merge topic&lt;/code&gt; &quot;는에 변경 사항 재생됩니다 &lt;code&gt;topic&lt;/code&gt; 는에서 분기 이후 분기 &lt;code&gt;master&lt;/code&gt; (즉, &lt;code&gt;E&lt;/code&gt; 현재는 (커밋 될 때까지) &lt;code&gt;C&lt;/code&gt; 의 상단에) &lt;code&gt;master&lt;/code&gt; 의 이름과 함께 커밋, 새로운의 결과를 기록 부모 커밋 두 개와 변경 사항을 설명하는 사용자의 로그 메시지</target>
        </trans-unit>
        <trans-unit id="f3bf49c80f1bf671798b336ee7a6337eb982b2bc" translate="yes" xml:space="preserve">
          <source>Then &quot;&lt;code&gt;git pull&lt;/code&gt;&quot; will fetch and replay the changes from the remote &lt;code&gt;master&lt;/code&gt; branch since it diverged from the local &lt;code&gt;master&lt;/code&gt; (i.e., &lt;code&gt;E&lt;/code&gt;) until its current commit (&lt;code&gt;C&lt;/code&gt;) on top of &lt;code&gt;master&lt;/code&gt; and record the result in a new commit along with the names of the two parent commits and a log message from the user describing the changes.</source>
          <target state="translated">그런 다음 &quot; &lt;code&gt;git pull&lt;/code&gt; &quot;가져 오기 및 원격의 변경 재생됩니다 &lt;code&gt;master&lt;/code&gt; 는 지역에서 분기 이후 분기를 &lt;code&gt;master&lt;/code&gt; (즉, &lt;code&gt;E&lt;/code&gt; ) 현재 커밋 될 때까지 ( &lt;code&gt;C&lt;/code&gt; 위에) &lt;code&gt;master&lt;/code&gt; 과 함께 커밋하고 새에 결과를 기록 두 개의 상위 커밋 이름과 사용자가 변경 내용을 설명하는 로그 메시지.</target>
        </trans-unit>
        <trans-unit id="44f92500b7ae9560ae64e2f2fc4f1af900d3ff26" translate="yes" xml:space="preserve">
          <source>Then &quot;git bisect&quot; will checkout a commit of its choosing and ask the user to test it, like this:</source>
          <target state="translated">그런 다음 &quot;git bisect&quot;는 선택한 커밋을 체크 아웃하고 사용자에게 다음과 같이 테스트하도록 요청합니다.</target>
        </trans-unit>
        <trans-unit id="e1ef052a3cd59f805d0ae45d1b9033a6a2faaa95" translate="yes" xml:space="preserve">
          <source>Then &lt;code&gt;git bisect&lt;/code&gt; will respond with something like</source>
          <target state="translated">그런 다음 &lt;code&gt;git bisect&lt;/code&gt; 는 다음과 같이 응답합니다.</target>
        </trans-unit>
        <trans-unit id="307236a389d15c9e88cc574f3c2b3a0314992840" translate="yes" xml:space="preserve">
          <source>Then compile and test the chosen revision, and afterwards mark the revision as good or bad in the usual manner.</source>
          <target state="translated">그런 다음 선택한 개정을 컴파일하고 테스트 한 후 일반적인 방식으로 개정을 양호 또는 불량으로 표시합니다.</target>
        </trans-unit>
        <trans-unit id="876e252bd62eb2a97f748800c6625b2b00ccfdec" translate="yes" xml:space="preserve">
          <source>Then confirm that the bug persists in a repository created from that stream (many bugs will not, as they really do depend on the exact repository contents):</source>
          <target state="translated">그런 다음 해당 스트림에서 생성 된 리포지토리에 버그가 지속되는지 확인합니다 (정확한 리포지토리 내용에 따라 많은 버그가 발생하지 않음).</target>
        </trans-unit>
        <trans-unit id="87463a5d117dae6022935ddfd68f09bfbb9b0943" translate="yes" xml:space="preserve">
          <source>Then create the following script to get list of project in the format suitable for GITWEB_LIST build configuration variable (or &lt;code&gt;$projects_list&lt;/code&gt; variable in gitweb config):</source>
          <target state="translated">그런 다음 GITWEB_LIST 빌드 구성 변수 (또는 gitweb config의 &lt;code&gt;$projects_list&lt;/code&gt; 변수)에 적합한 형식으로 프로젝트 목록을 가져 오려면 다음 스크립트를 작성하십시오 .</target>
        </trans-unit>
        <trans-unit id="b5a742d8577423cd13ed5705b5290de27ff73949" translate="yes" xml:space="preserve">
          <source>Then fixup &quot;master&quot; with &lt;code&gt;git rebase&lt;/code&gt;. Do NOT use &lt;code&gt;git merge&lt;/code&gt; or your history will not be compatible with a future &lt;code&gt;dcommit&lt;/code&gt;!</source>
          <target state="translated">그런 다음 &lt;code&gt;git rebase&lt;/code&gt; 로 &quot;master&quot;를 수정하십시오 . &lt;code&gt;git merge&lt;/code&gt; 를 사용하지 마십시오. 그러면 히스토리는 향후 &lt;code&gt;dcommit&lt;/code&gt; 과 호환되지 않습니다 !</target>
        </trans-unit>
        <trans-unit id="78318329e21f0014f75ba54a708b1f46ad0d023c" translate="yes" xml:space="preserve">
          <source>Then it compares the new skip-worktree value with the previous one. If skip-worktree turns from set to unset, it will add the corresponding file back. If it turns from unset to set, that file will be removed.</source>
          <target state="translated">그런 다음 새로운 skip-worktree 값과 이전 skip-worktree 값을 비교합니다. skip-worktree가 set에서 unset으로 바뀌면 해당 파일이 다시 추가됩니다. 설정되지 않은 상태에서 설정 상태로 바뀌면 해당 파일이 제거됩니다.</target>
        </trans-unit>
        <trans-unit id="5e9c59419a3e5d8568740259a39319d49129c624" translate="yes" xml:space="preserve">
          <source>Then it examines &lt;code&gt;.gitattributes&lt;/code&gt; (which is in the parent directory), and finds that the first line matches, but &lt;code&gt;t/.gitattributes&lt;/code&gt; file already decided how &lt;code&gt;merge&lt;/code&gt;, &lt;code&gt;foo&lt;/code&gt; and &lt;code&gt;bar&lt;/code&gt; attributes should be given to this path, so it leaves &lt;code&gt;foo&lt;/code&gt; and &lt;code&gt;bar&lt;/code&gt; unset. Attribute &lt;code&gt;baz&lt;/code&gt; is set.</source>
          <target state="translated">그런 다음 &lt;code&gt;.gitattributes&lt;/code&gt; (부모 디렉토리에 있음)를 검사 하고 첫 번째 줄이 일치하는 것을 발견하지만 &lt;code&gt;t/.gitattributes&lt;/code&gt; 파일은 이미 &lt;code&gt;merge&lt;/code&gt; , &lt;code&gt;foo&lt;/code&gt; 및 &lt;code&gt;bar&lt;/code&gt; 속성 이이 경로에 제공되어야 하는 방법을 결정 했기 때문에 &lt;code&gt;foo&lt;/code&gt; 및 &lt;code&gt;bar&lt;/code&gt; 를 남깁니다. 설정되지 않았습니다. 속성 &lt;code&gt;baz&lt;/code&gt; 가 설정되었습니다.</target>
        </trans-unit>
        <trans-unit id="1100f313a3d209e54bf3bc725a364711886dbfc4" translate="yes" xml:space="preserve">
          <source>Then modify, reorder, or eliminate patches as needed before applying them again with &lt;a href=&quot;git-am&quot;&gt;git-am[1]&lt;/a&gt;:</source>
          <target state="translated">그런 다음 &lt;a href=&quot;git-am&quot;&gt;git-am [1]으로&lt;/a&gt; 다시 적용하기 전에 필요에 따라 패치를 수정, 재정렬 또는 제거하십시오 .</target>
        </trans-unit>
        <trans-unit id="cd43ef848f2d3c4afb2a44ae28c2a413397c1d96" translate="yes" xml:space="preserve">
          <source>Then provide your password via the pserver method, for example:</source>
          <target state="translated">그런 다음 pserver 메소드를 통해 비밀번호를 제공하십시오 (예 :</target>
        </trans-unit>
        <trans-unit id="a774f276f116b48d127c0c1418ef7aa2fe46b49b" translate="yes" xml:space="preserve">
          <source>Then simplify each commit &lt;code&gt;C&lt;/code&gt; to its replacement &lt;code&gt;C'&lt;/code&gt; in the final history according to the following rules:</source>
          <target state="translated">그런 다음 다음 규칙에 따라 각 커밋 &lt;code&gt;C&lt;/code&gt; 를 최종 히스토리에서 대체 &lt;code&gt;C'&lt;/code&gt; 로 단순화 하십시오.</target>
        </trans-unit>
        <trans-unit id="2f5d7fdcf8fcb013dcf3c597507de91a5cb0f77d" translate="yes" xml:space="preserve">
          <source>Then simply fork your topic branches from the stable remotes as explained earlier.</source>
          <target state="translated">그런 다음 앞에서 설명한대로 안정적인 리모컨에서 주제 분기를 포크하면됩니다.</target>
        </trans-unit>
        <trans-unit id="b19a7b2e2b2e2252f0564256c9b87915d5db46d3" translate="yes" xml:space="preserve">
          <source>Then suppose you modify the last three commits:</source>
          <target state="translated">그런 다음 마지막 3 개의 커밋을 수정한다고 가정합니다.</target>
        </trans-unit>
        <trans-unit id="e69e2e34d497710c4127a780d2a5ed5c7d7fac83" translate="yes" xml:space="preserve">
          <source>Then there are two ways to get a smaller repository. A safer way is to clone, that keeps your original intact.</source>
          <target state="translated">그러면 더 작은 저장소를 얻는 두 가지 방법이 있습니다. 더 안전한 방법은 복제하여 원본을 그대로 유지하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="5c871054b486e3acaf28dc409c1ab3e693b4fc90" translate="yes" xml:space="preserve">
          <source>Then this &lt;code&gt;git p4 clone&lt;/code&gt; command:</source>
          <target state="translated">그런 다음이 &lt;code&gt;git p4 clone&lt;/code&gt; 명령 :</target>
        </trans-unit>
        <trans-unit id="db9b57b987ef397bc0b191d278e31ed2d827cb0a" translate="yes" xml:space="preserve">
          <source>Then you can disable sparse checkout. Sparse checkout support in &lt;code&gt;git read-tree&lt;/code&gt; and similar commands is disabled by default. You need to turn &lt;code&gt;core.sparseCheckout&lt;/code&gt; on in order to have sparse checkout support.</source>
          <target state="translated">그런 다음 스파 스 체크 아웃을 비활성화 할 수 있습니다. &lt;code&gt;git read-tree&lt;/code&gt; 및 유사한 명령 에서 스파 스 체크 아웃 지원은 기본적으로 비활성화되어 있습니다. 스파 스 체크 아웃을 지원하려면 &lt;code&gt;core.sparseCheckout&lt;/code&gt; 을 켜야 합니다.</target>
        </trans-unit>
        <trans-unit id="87a33f516a8ffec885e906dbb29e388a5f30ada0" translate="yes" xml:space="preserve">
          <source>Then you can pull and merge, leaving &lt;code&gt;frotz.c&lt;/code&gt; and &lt;code&gt;filfre.c&lt;/code&gt; changes still in the working tree.</source>
          <target state="translated">그런 다음 &lt;code&gt;frotz.c&lt;/code&gt; 및 &lt;code&gt;filfre.c&lt;/code&gt; 변경 사항을 작업 트리에 그대로두고 끌어서 병합 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="fa280cd97c17d646b4ce0e60bbbcb27953b34fb3" translate="yes" xml:space="preserve">
          <source>Then you can push both the test and release trees using &lt;a href=&quot;git-push&quot;&gt;git-push[1]&lt;/a&gt;:</source>
          <target state="translated">그런 다음 &lt;a href=&quot;git-push&quot;&gt;git-push [1]을&lt;/a&gt; 사용하여 테스트 트리와 릴리스 트리를 모두 푸시 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="9015e54306232b9477b76c544780cb6cb29e184c" translate="yes" xml:space="preserve">
          <source>Then you might want a &lt;code&gt;.mailmap&lt;/code&gt; file that looks like:</source>
          <target state="translated">그러면 다음과 같은 &lt;code&gt;.mailmap&lt;/code&gt; 파일 이 필요할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="bdefcc2b7f4d341c71ca424367a0164c209ac375" translate="yes" xml:space="preserve">
          <source>Then you transfer file.bundle to the target machine B. Because this bundle does not require any existing object to be extracted, you can create a new repository on machine B by cloning from it:</source>
          <target state="translated">그런 다음 file.bundle을 대상 머신 B로 전송합니다.이 번들은 기존 오브젝트를 추출 할 필요가 없으므로 머신 B에서 복제하여 새 저장소를 작성할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e826c3727c0c79aa7b30f2352881ef1c5a35f171" translate="yes" xml:space="preserve">
          <source>Then you would define a &quot;filter.indent.clean&quot; and &quot;filter.indent.smudge&quot; configuration in your .git/config to specify a pair of commands to modify the contents of C programs when the source files are checked in (&quot;clean&quot; is run) and checked out (no change is made because the command is &quot;cat&quot;).</source>
          <target state="translated">그런 다음 .git / config에서 &quot;filter.indent.clean&quot;및 &quot;filter.indent.smudge&quot;구성을 정의하여 소스 파일이 체크인 될 때 ​​C 프로그램의 내용을 수정하는 명령 쌍을 지정합니다 ( &quot;clean &quot;가 실행 됨) 및 체크 아웃되었습니다 (명령이&quot;cat &quot;이므로 변경되지 않음).</target>
        </trans-unit>
        <trans-unit id="c6308f4c83137c8ddf705f0b33927bc3a2a2d3bf" translate="yes" xml:space="preserve">
          <source>Then, make that directory into a Git repository by running &lt;code&gt;git init&lt;/code&gt;, but this time, since its name is not the usual &lt;code&gt;.git&lt;/code&gt;, we do things slightly differently:</source>
          <target state="translated">그런 다음 &lt;code&gt;git init&lt;/code&gt; 을 실행하여 해당 디렉토리를 Git 저장소로 만드십시오 .하지만 이번에는 이름이 일반적인 &lt;code&gt;.git&lt;/code&gt; 이 아니기 때문에 약간 다르게 작동합니다.</target>
        </trans-unit>
        <trans-unit id="4d45e0228f3dfbda52666260c02f45c435d7f13c" translate="yes" xml:space="preserve">
          <source>Then, use &lt;code&gt;git bisect &amp;lt;term-old&amp;gt;&lt;/code&gt; and &lt;code&gt;git bisect &amp;lt;term-new&amp;gt;&lt;/code&gt; instead of &lt;code&gt;git bisect good&lt;/code&gt; and &lt;code&gt;git bisect bad&lt;/code&gt; to mark commits.</source>
          <target state="translated">그런 다음 커밋을 표시하기 위해 &lt;code&gt;git bisect good&lt;/code&gt; 및 &lt;code&gt;git bisect bad&lt;/code&gt; 대신 &lt;code&gt;git bisect &amp;lt;term-old&amp;gt;&lt;/code&gt; 및 &lt;code&gt;git bisect &amp;lt;term-new&amp;gt;&lt;/code&gt; 를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="b100177b4f5d14520d5631ccbd2bc2ff52393e78" translate="yes" xml:space="preserve">
          <source>Then, you run this command:</source>
          <target state="translated">그런 다음이 명령을 실행하십시오.</target>
        </trans-unit>
        <trans-unit id="ebbdc2314a6104dc9178c4c9ed7835ad78f84727" translate="yes" xml:space="preserve">
          <source>Then, you would define a &quot;diff.tex.xfuncname&quot; configuration to specify a regular expression that matches a line that you would want to appear as the hunk header &quot;TEXT&quot;. Add a section to your &lt;code&gt;$GIT_DIR/config&lt;/code&gt; file (or &lt;code&gt;$HOME/.gitconfig&lt;/code&gt; file) like this:</source>
          <target state="translated">그런 다음 &quot;diff.tex.xfuncname&quot;구성을 정의하여 헝크 헤더 &quot;TEXT&quot;로 표시 할 행과 일치하는 정규식을 지정하십시오. &lt;code&gt;$GIT_DIR/config&lt;/code&gt; 파일 (또는 &lt;code&gt;$HOME/.gitconfig&lt;/code&gt; 파일)에 다음과 같이 섹션을 추가하십시오 .</target>
        </trans-unit>
        <trans-unit id="8d94c9456285c171a8f18dcac7b76fd1fccc9ff4" translate="yes" xml:space="preserve">
          <source>There are (number of parents + 1) &lt;code&gt;@&lt;/code&gt; characters in the chunk header for combined diff format.</source>
          <target state="translated">결합 된 diff 형식의 청크 헤더 에는 (부모 수 + 1) &lt;code&gt;@&lt;/code&gt; 문자가 있습니다.</target>
        </trans-unit>
        <trans-unit id="f7e9cf96a6ce9ed5c513750352c4736c076b5145" translate="yes" xml:space="preserve">
          <source>There are CPP wrapper macros and ifdefs to hide most of these details. See &lt;code&gt;trace2.h&lt;/code&gt; for more details. The following discussion will only describe the simplified forms.</source>
          <target state="translated">CPP 래퍼 매크로와 ifdef는 대부분의 세부 사항을 숨길 수 있습니다. 자세한 내용은 &lt;code&gt;trace2.h&lt;/code&gt; 를 참조하십시오. 다음 설명에서는 단순화 된 양식 만 설명합니다.</target>
        </trans-unit>
        <trans-unit id="e4287f1e47cb2bfc1b9e5f25165aef43ceec9d6c" translate="yes" xml:space="preserve">
          <source>There are a few built-in low-level merge drivers defined that can be asked for via the &lt;code&gt;merge&lt;/code&gt; attribute.</source>
          <target state="translated">&lt;code&gt;merge&lt;/code&gt; 속성 을 통해 요청할 수있는 몇 가지 기본 제공 저수준 병합 드라이버가 정의되어 있습니다 .</target>
        </trans-unit>
        <trans-unit id="12f3989319ea3c0cba3d029a62ee2c306fd0616b" translate="yes" xml:space="preserve">
          <source>There are a few built-in patterns to make this easier, and &lt;code&gt;tex&lt;/code&gt; is one of them, so you do not have to write the above in your configuration file (you still need to enable this with the attribute mechanism, via &lt;code&gt;.gitattributes&lt;/code&gt;). The following built in patterns are available:</source>
          <target state="translated">이것을 쉽게하기 위해 몇 가지 내장 패턴이 있으며 &lt;code&gt;tex&lt;/code&gt; 는 그중 하나이므로 구성 파일에 위의 내용을 쓸 필요가 없습니다 (여전히 &lt;code&gt;.gitattributes&lt;/code&gt; 를 통해 속성 메커니즘으로 이것을 활성화해야합니다 ). 다음과 같은 내장 패턴을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="336d04ab3583042f88f12edf2d051324b94f62a0" translate="yes" xml:space="preserve">
          <source>There are a few issues to resolve before we can completely switch to Trace2.</source>
          <target state="translated">Trace2로 완전히 전환하기 전에 해결해야 할 몇 가지 문제가 있습니다.</target>
        </trans-unit>
        <trans-unit id="f553cccafe9fdfa62552e6e1af4be573be245c47" translate="yes" xml:space="preserve">
          <source>There are a few special-purpose refs that do not begin with &lt;code&gt;refs/&lt;/code&gt;. The most notable example is &lt;code&gt;HEAD&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;refs/&lt;/code&gt; 시작하지 않는 몇 가지 특수 목적 ref가 있습니다. 가장 주목할만한 예는 &lt;code&gt;HEAD&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="cc9f53378dabd08666f7e5c5af2a717dbbd37e28" translate="yes" xml:space="preserve">
          <source>There are a number of factors which affect how much memory fast-import requires to perform an import. Like critical sections of core Git, fast-import uses its own memory allocators to amortize any overheads associated with malloc. In practice fast-import tends to amortize any malloc overheads to 0, due to its use of large block allocations.</source>
          <target state="translated">가져 오기를 수행하기 위해 빠른 가져 오기에 필요한 메모리 양에 영향을주는 여러 가지 요소가 있습니다. 핵심 Git의 중요한 섹션과 마찬가지로 빠른 가져 오기는 자체 메모리 할당자를 사용하여 malloc과 관련된 모든 오버 헤드를 상각합니다. 실제로 빠른 가져 오기는 큰 블록 할당을 사용하기 때문에 malloc 오버 헤드를 0으로 상각하는 경향이 있습니다.</target>
        </trans-unit>
        <trans-unit id="e0b2b532209e8b05d8ee20f67e782301986fd65a" translate="yes" xml:space="preserve">
          <source>There are also cases where existing indexes written by git versions before 2.17 will reference directories that don&amp;rsquo;t exist anymore, potentially causing many &quot;could not open directory&quot; warnings to be printed on &quot;git status&quot;. These are new warnings for existing issues that were previously silently discarded.</source>
          <target state="translated">2.17 이전의 git 버전으로 작성된 기존 인덱스가 더 이상 존재하지 않는 디렉토리를 참조하여 &quot;git status&quot;에 많은 &quot;디렉토리를 열 수 없음&quot;경고가 표시되는 경우도 있습니다. 이전에 자동으로 삭제 된 기존 문제에 대한 새로운 경고입니다.</target>
        </trans-unit>
        <trans-unit id="aec0acb7fb7522f7c5da2df9b13975842cb9d1be" translate="yes" xml:space="preserve">
          <source>There are also more complex operations that can be performed. But beware that because the patch is applied only to the index and not the working tree, the working tree will appear to &quot;undo&quot; the change in the index. For example, introducing a new line into the index that is in neither the HEAD nor the working tree will stage the new line for commit, but the line will appear to be reverted in the working tree.</source>
          <target state="translated">수행 할 수있는 더 복잡한 작업도 있습니다. 그러나 패치는 작업 트리가 아닌 인덱스에만 적용되므로 작업 트리는 인덱스 변경을 &quot;실행 취소&quot;하는 것처럼 보입니다. 예를 들어, HEAD 나 작업 트리에없는 색인에 새 줄을 도입하면 커밋을 위해 새 줄을 스테이징하지만 작업 트리에서 줄이 되돌려 진 것처럼 보입니다.</target>
        </trans-unit>
        <trans-unit id="a266660a35cd18470141c43d8a3ffa2b3074c06a" translate="yes" xml:space="preserve">
          <source>There are also other situations that cause dangling objects. For example, a &quot;dangling blob&quot; may arise because you did a &lt;code&gt;git add&lt;/code&gt; of a file, but then, before you actually committed it and made it part of the bigger picture, you changed something else in that file and committed that &lt;strong&gt;updated&lt;/strong&gt; thing&amp;mdash;​the old state that you added originally ends up not being pointed to by any commit or tree, so it&amp;rsquo;s now a dangling blob object.</source>
          <target state="translated">매달린 물체를 일으키는 다른 상황도 있습니다. 예를 들어, &quot;매달려 BLOB는&quot;당신이했기 때문에 발생할 수있는 &lt;code&gt;git add&lt;/code&gt; 당신이 실제로 노력과 더 큰 그림의 일부가 만든 전에, 다음의 파일을하지만, 그 파일에 다른 뭔가를 변경 한 것을 최선을 다하고 &lt;strong&gt;업데이트&lt;/strong&gt; 쿄코 원래 추가 한 이전 상태는 커밋이나 트리가 가리 키지 않으므로 이제 매달려있는 얼룩 개체입니다.</target>
        </trans-unit>
        <trans-unit id="232088d916b340ecad3098c72c2ebccbe30b76e5" translate="yes" xml:space="preserve">
          <source>There are also several operations which should be avoided entirely, as they will make the patch impossible to apply:</source>
          <target state="translated">패치를 적용 할 수 없게하기 때문에 완전히 피해야하는 여러 작업이 있습니다.</target>
        </trans-unit>
        <trans-unit id="eeb0752be9462c9bd2e54575f2023419e06b3d3b" translate="yes" xml:space="preserve">
          <source>There are also ways to automate the bisecting process if you have a test script that can tell a good from a bad commit. See &lt;a href=&quot;git-bisect&quot;&gt;git-bisect[1]&lt;/a&gt; for more information about this and other &lt;code&gt;git
bisect&lt;/code&gt; features.</source>
          <target state="translated">잘못된 커밋에서 좋은 것을 알 수있는 테스트 스크립트가있는 경우 이등분 프로세스를 자동화하는 방법도 있습니다. 참조 &lt;a href=&quot;git-bisect&quot;&gt;자식-양분 [1]&lt;/a&gt; 및 기타에 대한 자세한 내용은 &lt;code&gt;git bisect&lt;/code&gt; 기능을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="753d0dde7d0dbacd496fb113e3e96e5ea6d9494d" translate="yes" xml:space="preserve">
          <source>There are four different types of objects: &quot;blob&quot;, &quot;tree&quot;, &quot;commit&quot;, and &quot;tag&quot;.</source>
          <target state="translated">&quot;blob&quot;, &quot;tree&quot;, &quot;commit&quot;및 &quot;tag&quot;의 네 가지 유형의 개체가 있습니다.</target>
        </trans-unit>
        <trans-unit id="a3d0232ce28c94288cf502f722ca216e09b8c5b1" translate="yes" xml:space="preserve">
          <source>There are implementations of Git that do not leave usable values in some fields (e.g. JGit); by excluding these fields from the comparison, the &lt;code&gt;minimal&lt;/code&gt; mode may help interoperability when the same repository is used by these other systems at the same time.</source>
          <target state="translated">일부 필드에 사용 가능한 값을 남기지 않는 Git 구현이 있습니다 (예 : JGit). 이러한 필드를 비교에서 제외함으로써 &lt;code&gt;minimal&lt;/code&gt; 모드는 다른 시스템에서 동일한 저장소를 동시에 사용할 때 상호 운용성을 도울 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ac26d523869587e187089ca0cfe8dfa88bde0428" translate="yes" xml:space="preserve">
          <source>There are many more; see the &quot;SPECIFYING REVISIONS&quot; section of the &lt;a href=&quot;gitrevisions&quot;&gt;gitrevisions[7]&lt;/a&gt; man page for the complete list of ways to name revisions. Some examples:</source>
          <target state="translated">더 많은 것이 있습니다. 개정판 이름을 지정하는 전체 방법 목록은 &lt;a href=&quot;gitrevisions&quot;&gt;gitrevisions [7]&lt;/a&gt; 매뉴얼 페이지 의 &quot;사양 수정&quot;섹션을 참조하십시오. 몇 가지 예 :</target>
        </trans-unit>
        <trans-unit id="caa64d4f477bb9cc6ae8b8763c8d93ec4bfb0cef" translate="yes" xml:space="preserve">
          <source>There are no facilities for helping users find what unwanted crud they should delete, which means they are much more likely to have incomplete or partial cleanups that sometimes result in confusion and people wasting time trying to understand. (For example, folks tend to just look for big files to delete instead of big directories or extensions, and once they do so, then sometime later folks using the new repository who are going through history will notice a build artifact directory that has some files but not others, or a cache of dependencies (node_modules or similar) which couldn&amp;rsquo;t have ever been functional since it&amp;rsquo;s missing some files.)</source>
          <target state="translated">사용자가 삭제해야하는 원치 않는 크 러드를 찾도록 도와주는 기능이 없기 때문에 때때로 불완전하거나 부분적으로 정리되어 혼동을 일으키고 사람들이 이해하려고 시간을 낭비하는 경우가 훨씬 많습니다. (예를 들어, 사람들은 큰 디렉토리 또는 확장명 대신 삭제할 큰 파일을 찾는 경향이 있으며 일단 그렇게되면 역사를 겪고있는 새로운 저장소를 사용하는 사람들은 나중에 일부 파일이있는 빌드 아티팩트 디렉토리를 보게됩니다 그러나 다른 파일이나 종속성 캐시 (node_modules 또는 이와 유사한 것)는 파일이 없기 때문에 작동 할 수 없었습니다.)</target>
        </trans-unit>
        <trans-unit id="ce4a9f9a1026ea763732ff998a2bcfb7b60f26ca" translate="yes" xml:space="preserve">
          <source>There are no public Trace2 data structures.</source>
          <target state="translated">공개 Trace2 데이터 구조가 없습니다.</target>
        </trans-unit>
        <trans-unit id="5a1dbdef2a9d4fcde2fec24ad984bfc7ec6f3aa2" translate="yes" xml:space="preserve">
          <source>There are numerous other tools, such as StGit, which exist for the purpose of maintaining a patch series. These are outside of the scope of this manual.</source>
          <target state="translated">패치 시리즈를 유지하기 위해 존재하는 StGit과 같은 다른 많은 도구가 있습니다. 이것들은이 매뉴얼의 범위를 벗어납니다.</target>
        </trans-unit>
        <trans-unit id="306721e74c73edf4b4a1c2554be600724c25d3f0" translate="yes" xml:space="preserve">
          <source>There are other estimates saying that 80% of the cost related to software is about maintenance &lt;a href=&quot;#2&quot;&gt;[2]&lt;/a&gt;.</source>
          <target state="translated">소프트웨어와 관련된 비용의 80 %가 유지 보수에 관한 것이라고 다른 추정이 있습니다 &lt;a href=&quot;#2&quot;&gt;[2]&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="7eccee0caa41472aded0ea349d3d3fa4831b32ab" translate="yes" xml:space="preserve">
          <source>There are other real-world examples of using update and post-update hooks found in the Documentation/howto directory.</source>
          <target state="translated">Documentation / howto 디렉토리에있는 업데이트 및 사후 업데이트 후크 사용에 대한 다른 실제 예가 있습니다.</target>
        </trans-unit>
        <trans-unit id="ddc4304f0c733f93eaa36c71971b210be6c86baa" translate="yes" xml:space="preserve">
          <source>There are several built-in formats, and you can define additional formats by setting a pretty.&amp;lt;name&amp;gt; config option to either another format name, or a &lt;code&gt;format:&lt;/code&gt; string, as described below (see &lt;a href=&quot;git-config&quot;&gt;git-config[1]&lt;/a&gt;). Here are the details of the built-in formats:</source>
          <target state="translated">몇 가지 기본 제공 형식이 있으며 아래에 설명 된대로 pretty. &amp;lt;name&amp;gt; 구성 옵션을 다른 형식 이름 또는 &lt;code&gt;format:&lt;/code&gt; 문자열 로 설정하여 추가 형식을 정의 할 수 있습니다 ( &lt;a href=&quot;git-config&quot;&gt;git-config [1] 참조&lt;/a&gt; ). 내장 형식의 세부 사항은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="172e083c83bf7e6cbde177805c61722f6bdc0777" translate="yes" xml:space="preserve">
          <source>There are some numbers about bugs in general, like a NIST study in 2002 &lt;a href=&quot;#1&quot;&gt;[1]&lt;/a&gt; that said:</source>
          <target state="translated">2002 년 NIST 연구 &lt;a href=&quot;#1&quot;&gt;[1]&lt;/a&gt; 와 같이 일반적으로 버그에 관한 몇 가지 숫자 가있다 :</target>
        </trans-unit>
        <trans-unit id="1a73feb2f257a54073e6e874ef78ceeefd47d29e" translate="yes" xml:space="preserve">
          <source>There are some subtle differences how the backends behave.</source>
          <target state="translated">백엔드의 작동 방식에는 미묘한 차이가 있습니다.</target>
        </trans-unit>
        <trans-unit id="a41ebe77f2eb54fbd4f30714a2e14c8c1d436ea0" translate="yes" xml:space="preserve">
          <source>There are three commands with similar names: &lt;code&gt;git reset&lt;/code&gt;, &lt;code&gt;git restore&lt;/code&gt; and &lt;code&gt;git revert&lt;/code&gt;.</source>
          <target state="translated">비슷한 이름을 가진 &lt;code&gt;git reset&lt;/code&gt; , &lt;code&gt;git restore&lt;/code&gt; 및 &lt;code&gt;git revert&lt;/code&gt; 의 세 가지 명령이 있습니다 .</target>
        </trans-unit>
        <trans-unit id="27e17ed315eeb27fa67bd10d3870c4d2deb8a92d" translate="yes" xml:space="preserve">
          <source>There are three different approaches: use an add-on to turn off line wraps, configure Thunderbird to not mangle patches, or use an external editor to keep Thunderbird from mangling the patches.</source>
          <target state="translated">추가 기능을 사용하여 줄 바꿈 기능을 해제하고, 패치를 맹 글링하지 않도록 Thunderbird를 구성하거나, 외부 편집기를 사용하여 패치를 엉망으로 만드는 것을 방지하는 세 가지 접근 방식이 있습니다.</target>
        </trans-unit>
        <trans-unit id="8c553f5839a8296a42918c5ea6f6a2fcca19fa49" translate="yes" xml:space="preserve">
          <source>There are three main tools that can be used for this:</source>
          <target state="translated">이를 위해 사용할 수있는 세 가지 주요 도구가 있습니다.</target>
        </trans-unit>
        <trans-unit id="86e24f426735724adb9ab7ea59c461905251e8e9" translate="yes" xml:space="preserve">
          <source>There are three ways to specify which refs to update on the remote end.</source>
          <target state="translated">원격 측에서 업데이트 할 참조를 지정하는 세 가지 방법이 있습니다.</target>
        </trans-unit>
        <trans-unit id="5544b2d42620b4375dbc730230171fe04b9f972b" translate="yes" xml:space="preserve">
          <source>There are two different types of capabilities: normal capabilities, which can be used to convey information or alter the behavior of a request, and commands, which are the core actions that a client wants to perform (fetch, push, etc).</source>
          <target state="translated">두 가지 유형의 기능이 있습니다. 정보를 전달하거나 요청의 동작을 변경하는 데 사용할 수있는 일반 기능과 클라이언트가 수행하고자하는 핵심 작업 (페치, 푸시 등) 인 명령입니다.</target>
        </trans-unit>
        <trans-unit id="c2015c03c4c8786233c499c7815e06c17100a16b" translate="yes" xml:space="preserve">
          <source>There are two formats accepted for patch files:</source>
          <target state="translated">패치 파일에는 두 가지 형식이 허용됩니다.</target>
        </trans-unit>
        <trans-unit id="9b5e9b84c7e0cf0cc62bfad7ffc7f5a42847bbc1" translate="yes" xml:space="preserve">
          <source>There are two kinds of fixes, discussed in the following subsections:</source>
          <target state="translated">다음 하위 섹션에서 설명하는 두 가지 수정 사항이 있습니다.</target>
        </trans-unit>
        <trans-unit id="afe3df249e404830655fd820b0b8e96397ac9183" translate="yes" xml:space="preserve">
          <source>There are two main tools that can be used to include changes from one branch on another: &lt;a href=&quot;git-merge&quot;&gt;git-merge[1]&lt;/a&gt; and &lt;a href=&quot;git-cherry-pick&quot;&gt;git-cherry-pick[1]&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;git-merge&quot;&gt;git-merge [1]&lt;/a&gt; 및 &lt;a href=&quot;git-cherry-pick&quot;&gt;git-cherry-pick [1]의&lt;/a&gt; 한 가지 분기 변경 사항을 포함하는 데 사용할 수있는 두 가지 주요 도구가 있습니다 .</target>
        </trans-unit>
        <trans-unit id="1432c9def859812f2dcccb492cbe2b422538cffb" translate="yes" xml:space="preserve">
          <source>There are two ways to specify which commits to operate on.</source>
          <target state="translated">작동 할 커밋을 지정하는 방법에는 두 가지가 있습니다.</target>
        </trans-unit>
        <trans-unit id="04a6eae6f43fc050171fa2270096884eaba0fee3" translate="yes" xml:space="preserve">
          <source>There is a difference between listing multiple &amp;lt;refspec&amp;gt; directly on &lt;em&gt;git pull&lt;/em&gt; command line and having multiple &lt;code&gt;remote.&amp;lt;repository&amp;gt;.fetch&lt;/code&gt; entries in your configuration for a &amp;lt;repository&amp;gt; and running a &lt;em&gt;git pull&lt;/em&gt; command without any explicit &amp;lt;refspec&amp;gt; parameters. &amp;lt;refspec&amp;gt;s listed explicitly on the command line are always merged into the current branch after fetching. In other words, if you list more than one remote ref, &lt;em&gt;git pull&lt;/em&gt; will create an Octopus merge. On the other hand, if you do not list any explicit &amp;lt;refspec&amp;gt; parameter on the command line, &lt;em&gt;git pull&lt;/em&gt; will fetch all the &amp;lt;refspec&amp;gt;s it finds in the &lt;code&gt;remote.&amp;lt;repository&amp;gt;.fetch&lt;/code&gt; configuration and merge only the first &amp;lt;refspec&amp;gt; found into the current branch. This is because making an Octopus from remote refs is rarely done, while keeping track of multiple remote heads in one-go by fetching more than one is often useful.</source>
          <target state="translated">&lt;em&gt;git pull&lt;/em&gt; 명령 행 에 직접 여러 &amp;lt;refspec&amp;gt;을 나열 하고 &lt;code&gt;remote.&amp;lt;repository&amp;gt;.fetch&lt;/code&gt; 에 대한 구성에서 여러 remote. &amp;lt;repository&amp;gt; .fetch 항목을 갖는 것과 명시적인 &amp;lt;refspec&amp;gt; 매개 변수없이 &lt;em&gt;git pull&lt;/em&gt; 명령을 실행하는 것에는 차이가 있습니다. 명령 행에 명시 적으로 나열된 &amp;lt;refspec&amp;gt;은 페치 후에 항상 현재 분기로 병합됩니다. 즉, 하나 이상의 원격 참조를 나열하면 &lt;em&gt;git pull&lt;/em&gt; 이 Octopus 병합을 생성합니다. 반면에 명령 행에 명시 적 &amp;lt;refspec&amp;gt; 매개 변수를 나열하지 않으면 &lt;em&gt;git pull&lt;/em&gt; 은 &lt;code&gt;remote.&amp;lt;repository&amp;gt;.fetch&lt;/code&gt; 에서 찾은 모든 &amp;lt;refspec&amp;gt;을 가져옵니다 . &amp;lt;repository&amp;gt; .fetch구성하고 현재 분기에있는 첫 번째 &amp;lt;refspec&amp;gt; 만 병합하십시오. 원격 참조에서 Octopus를 만드는 것은 거의 이루어지지 않기 때문에 여러 원격 헤드를 한 번에 가져 와서 여러 원격 헤드를 추적하는 것이 종종 유용하기 때문입니다.</target>
        </trans-unit>
        <trans-unit id="08d27e369ae02f07111163548604defe0fd7ba02" translate="yes" xml:space="preserve">
          <source>There is a fourth official branch that is used slightly differently:</source>
          <target state="translated">약간 다르게 사용되는 네 번째 공식 지점이 있습니다.</target>
        </trans-unit>
        <trans-unit id="3ab0818052937d36eff9b5a2767bc99b339b1151" translate="yes" xml:space="preserve">
          <source>There is a script in contrib/thunderbird-patch-inline which can help you include patches with Thunderbird in an easy way. To use it, do the steps above and then use the script as the external editor.</source>
          <target state="translated">contrib / thunderbird-patch-inline에는 Thunderbird 패치를 쉽게 포함시킬 수있는 스크립트가 있습니다. 이를 사용하려면 위 단계를 수행 한 다음 스크립트를 외부 편집기로 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="1232149fc68bcd969b013f8dcdb8f804dc24a0d6" translate="yes" xml:space="preserve">
          <source>There is a tradeoff of course: merges require a more careful branch management. The following subsections discuss the important points.</source>
          <target state="translated">물론 절충이 있습니다. 병합에는보다 신중한 지점 관리가 필요합니다. 다음 하위 섹션에서는 중요한 사항에 대해 설명합니다.</target>
        </trans-unit>
        <trans-unit id="dad64266cc32a47cdf74ec10317455f91f86159c" translate="yes" xml:space="preserve">
          <source>There is already a project called BBChop created by Ealdwulf Wuffinga on Github that does something like that using Bayesian Search Theory &lt;a href=&quot;#9&quot;&gt;[9]&lt;/a&gt;:</source>
          <target state="translated">Github에서 Ealdwulf Wuffinga가 만든 BBChop이라는 프로젝트가 이미 베이지안 검색 이론 (Bayesian Search Theory) &lt;a href=&quot;#9&quot;&gt;[9]&lt;/a&gt; 을 사용하여 이와 같은 작업을 수행하고 있습니다 .</target>
        </trans-unit>
        <trans-unit id="72c8cb7314c2d9e687a4188f4607320887a3abaf" translate="yes" xml:space="preserve">
          <source>There is also a deprecated &lt;code&gt;[section.subsection]&lt;/code&gt; syntax. With this syntax, the subsection name is converted to lower-case and is also compared case sensitively. These subsection names follow the same restrictions as section names.</source>
          <target state="translated">더 이상 사용되지 않는 &lt;code&gt;[section.subsection]&lt;/code&gt; 구문도 있습니다. 이 구문을 사용하면 하위 섹션 이름이 소문자로 변환되고 대소 문자를 구분합니다. 이 하위 섹션 이름은 섹션 이름과 동일한 제한 사항을 따릅니다.</target>
        </trans-unit>
        <trans-unit id="562a7aac41f0a6a2b8bd94c80ba1df49ae8c2861" translate="yes" xml:space="preserve">
          <source>There is also an alternate -z format recommended for machine parsing. In that format, the status field is the same, but some other things change. First, the &lt;code&gt;-&amp;gt;&lt;/code&gt; is omitted from rename entries and the field order is reversed (e.g &lt;code&gt;from -&amp;gt; to&lt;/code&gt; becomes &lt;code&gt;to from&lt;/code&gt;). Second, a NUL (ASCII 0) follows each filename, replacing space as a field separator and the terminating newline (but a space still separates the status field from the first filename). Third, filenames containing special characters are not specially formatted; no quoting or backslash-escaping is performed.</source>
          <target state="translated">기계 구문 분석에 권장되는 대체 -z 형식도 있습니다. 이 형식에서 상태 필드는 동일하지만 다른 사항이 변경됩니다. 먼저, &lt;code&gt;-&amp;gt;&lt;/code&gt; (예 바꾸기 항목 생략하고 필드 순서 반전 &lt;code&gt;from -&amp;gt; to&lt;/code&gt; 된다 &lt;code&gt;to from&lt;/code&gt; ). 둘째, NUL (ASCII 0)은 각 파일 이름 뒤에 공백을 필드 구분 기호와 종료 줄 바꿈으로 바꿉니다 (그러나 공백은 여전히 ​​상태 필드를 첫 번째 파일 이름과 분리합니다). 셋째, 특수 문자가 포함 된 파일 이름은 특별히 형식이 지정되지 않습니다. 인용 또는 백 슬래시 이스케이프가 수행되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="23b53316aea0dd64f8f21ea0eae539235bf45a74" translate="yes" xml:space="preserve">
          <source>There is also an option to sort by versions, this can be done by using the fieldname &lt;code&gt;version:refname&lt;/code&gt; or its alias &lt;code&gt;v:refname&lt;/code&gt;.</source>
          <target state="translated">버전별로 정렬하는 옵션도 있습니다. fieldname &lt;code&gt;version:refname&lt;/code&gt; 또는 별명 &lt;code&gt;v:refname&lt;/code&gt; 을 사용하여 수행 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="490f0c7223e032436f3ed74187899d6766a21bb5" translate="yes" xml:space="preserve">
          <source>There is another common situation where you may encounter non-fast-forward rejection when you try to push, and it is possible even when you are pushing into a repository nobody else pushes into. After you push commit A yourself (in the first picture in this section), replace it with &quot;git commit --amend&quot; to produce commit B, and you try to push it out, because forgot that you have pushed A out already. In such a case, and only if you are certain that nobody in the meantime fetched your earlier commit A (and started building on top of it), you can run &quot;git push --force&quot; to overwrite it. In other words, &quot;git push --force&quot; is a method reserved for a case where you do mean to lose history.</source>
          <target state="translated">푸시하려고 할 때 빨리 감기를 거부 할 수있는 또 다른 일반적인 상황이 있으며, 아무도 저장소로 푸시하지 않아도 가능합니다. 커밋 A를 직접 푸시 한 후 (이 섹션의 첫 번째 그림에서) 커밋 B를 생성하기 위해 &quot;git commit --amend&quot;로 바꾸고, 이미 푸시 아웃 한 것을 잊었 기 때문에 밀어 내려고합니다. 이 경우, 그 동안 아무도 이전 커밋 A를 가져 오지 않고 그 위에 빌드를 시작한 사람이 아무도없는 경우에만 &quot;git push --force&quot;를 실행하여 덮어 쓸 수 있습니다. 즉, &quot;git push --force&quot;는 히스토리를 잃어 버리려는 경우를 위해 예약 된 방법입니다.</target>
        </trans-unit>
        <trans-unit id="76938def2c927fda8d1c815e17291d57380d4a8a" translate="yes" xml:space="preserve">
          <source>There is another tweak in the bisection algorithm that has not been described in the &quot;bisection algorithm&quot; above.</source>
          <target state="translated">이분법 알고리즘에는 위의 &quot;이분법 알고리즘&quot;에 설명되지 않은 또 다른 조정이 있습니다.</target>
        </trans-unit>
        <trans-unit id="6cd697be600e420b39bb68cc6d967c4ceca70af4" translate="yes" xml:space="preserve">
          <source>There is no option for &lt;code&gt;git rm&lt;/code&gt; to remove from the index only the paths that have disappeared from the filesystem. However, depending on the use case, there are several ways that can be done.</source>
          <target state="translated">&lt;code&gt;git rm&lt;/code&gt; 이 파일 시스템에서 사라진 경로 만 인덱스에서 제거하는 옵션은 없습니다 . 그러나 사용 사례에 따라 수행 할 수있는 몇 가지 방법이 있습니다.</target>
        </trans-unit>
        <trans-unit id="60bcaa98facce6fa9b4916fcb4556840549eaf70" translate="yes" xml:space="preserve">
          <source>There is no other restriction on the replaced and replacement objects. Merge commits can be replaced by non-merge commits and vice versa.</source>
          <target state="translated">교체 및 교체 객체에 대한 다른 제한은 없습니다. 병합 커밋은 병합되지 않은 커밋으로 대체 할 수 있으며 그 반대도 가능합니다.</target>
        </trans-unit>
        <trans-unit id="5b920fe2651a1acef3f4de11b5f87d418bf37e32" translate="yes" xml:space="preserve">
          <source>There is now a new commit &lt;code&gt;e&lt;/code&gt;, but it is referenced only by &lt;code&gt;HEAD&lt;/code&gt;. We can of course add yet another commit in this state:</source>
          <target state="translated">이제 새로운 커밋 &lt;code&gt;e&lt;/code&gt; 가 있지만 &lt;code&gt;HEAD&lt;/code&gt; 에서만 참조됩니다 . 물론이 상태에서 또 다른 커밋을 추가 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e84a3494173a3e4e1765afc114a7bb8588db5e4e" translate="yes" xml:space="preserve">
          <source>There is one special case not mentioned above, which is treated differently. Normally, a merge results in a merge commit, with two parents, one pointing at each of the two lines of development that were merged.</source>
          <target state="translated">위에서 언급하지 않은 특별한 경우가 하나 있는데, 다르게 취급됩니다. 일반적으로 병합을 수행하면 병합 된 두 개발 라인 각각을 가리키는 두 개의 부모가있는 병합 커밋이 발생합니다.</target>
        </trans-unit>
        <trans-unit id="9c233ac02212216497063926a3cd425b73c1b106" translate="yes" xml:space="preserve">
          <source>There may be other problems when using &lt;code&gt;git rev-list&lt;/code&gt; related to pending objects.</source>
          <target state="translated">보류중인 객체와 관련된 &lt;code&gt;git rev-list&lt;/code&gt; 를 사용할 때 다른 문제가있을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="3cc97d3b58e95d007d294ed252208117b7ea36ad" translate="yes" xml:space="preserve">
          <source>There was a discussion at one point on the linux kernel mailing list of whether it was ok to always ask end user to bisect, and very good points were made to support the point of view that it is ok.</source>
          <target state="translated">리눅스 커널 메일 링리스트의 어느 시점에서 최종 사용자에게 항상 이등분을 요구하는 것이 좋았는지에 대한 토론이 있었고, 괜찮다는 관점을 지원하기 위해 매우 좋은 점이 만들어졌습니다.</target>
        </trans-unit>
        <trans-unit id="e31f2056d77b9761665b1e39804c963e7c7e3f73" translate="yes" xml:space="preserve">
          <source>Therefore if the refspec for the remote includes e.g. &lt;code&gt;refs/tags/*:refs/tags/*&lt;/code&gt;, or you manually run e.g. &lt;code&gt;git fetch
--prune &amp;lt;name&amp;gt; &quot;refs/tags/*:refs/tags/*&quot;&lt;/code&gt; it won&amp;rsquo;t be stale remote tracking branches that are deleted, but any local tag that doesn&amp;rsquo;t exist on the remote.</source>
          <target state="translated">따라서 원격에 대한 참조 사양에 &lt;code&gt;refs/tags/*:refs/tags/*&lt;/code&gt; 가 포함 되어 있거나 수동으로 &lt;code&gt;git fetch --prune &amp;lt;name&amp;gt; &quot;refs/tags/*:refs/tags/*&quot;&lt;/code&gt; 하면 ' 삭제 된 오래된 원격 추적 분기는 아니지만 원격에 존재하지 않는 로컬 태그는 없어야합니다.</target>
        </trans-unit>
        <trans-unit id="22e33781a4f63d74c967572b3d2d5742f6f5b3cf" translate="yes" xml:space="preserve">
          <source>These are applied in sequence. The set of filepairs &lt;code&gt;git diff-*&lt;/code&gt; commands find are used as the input to diffcore-break, and the output from diffcore-break is used as the input to the next transformation. The final result is then passed to the output routine and generates either diff-raw format (see Output format sections of the manual for &lt;code&gt;git diff-*&lt;/code&gt; commands) or diff-patch format.</source>
          <target state="translated">이들은 순차적으로 적용됩니다. &lt;code&gt;git diff-*&lt;/code&gt; diff- * 명령 find 파일 쌍 세트는 diffcore -break에 대한 입력으로 사용되며 diffcore-break의 출력은 다음 변환에 대한 입력으로 사용됩니다. 최종 결과는 출력 루틴으로 전달되고 diff-raw 형식 ( &lt;code&gt;git diff-*&lt;/code&gt; 명령 에 대한 매뉴얼의 출력 형식 섹션 참조 ) 또는 diff-patch 형식을 생성합니다.</target>
        </trans-unit>
        <trans-unit id="5e4c5d2d8cb413a7bc102a12d4b32266eb5dffbd" translate="yes" xml:space="preserve">
          <source>These are concerned with describing the specific Git command after the command line, config, and environment are inspected. e.g: &lt;code&gt;void trace2_cmd_name(const char *name)&lt;/code&gt;, &lt;code&gt;void trace2_cmd_mode(const char *mode)&lt;/code&gt;.</source>
          <target state="translated">이것들은 커맨드 라인, 구성 및 환경을 검사 한 후 특정 Git 명령을 설명하는 것과 관련이 있습니다. 예 : &lt;code&gt;void trace2_cmd_name(const char *name)&lt;/code&gt; , &lt;code&gt;void trace2_cmd_mode(const char *mode)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="dd918e1aed68e545e545890a5d457bd39124acbb" translate="yes" xml:space="preserve">
          <source>These are concerned with recording performance data over regions or spans of code. e.g: &lt;code&gt;void trace2_region_enter(const char *category, const char *label, const struct repository *repo)&lt;/code&gt;.</source>
          <target state="translated">이들은 영역 또는 코드 범위에 걸쳐 성능 데이터를 기록하는 것과 관련이 있습니다. 예 : &lt;code&gt;void trace2_region_enter(const char *category, const char *label, const struct repository *repo)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="10ea7c6e4b3ea51596f6b19ba236a57b5e812041" translate="yes" xml:space="preserve">
          <source>These are concerned with the lifetime of the overall git process. e.g: &lt;code&gt;void trace2_initialize_clock()&lt;/code&gt;, &lt;code&gt;void trace2_initialize()&lt;/code&gt;, &lt;code&gt;int trace2_is_enabled()&lt;/code&gt;, &lt;code&gt;void trace2_cmd_start(int argc, const char **argv)&lt;/code&gt;.</source>
          <target state="translated">이것들은 전체 자식 프로세스의 수명과 관련이 있습니다. 예 : &lt;code&gt;void trace2_initialize_clock()&lt;/code&gt; , &lt;code&gt;void trace2_initialize()&lt;/code&gt; , &lt;code&gt;int trace2_is_enabled()&lt;/code&gt; , &lt;code&gt;void trace2_cmd_start(int argc, const char **argv)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3dce3473c941e3b3b27a31ac8449a2f1991a75d0" translate="yes" xml:space="preserve">
          <source>These are concerned with the various spawned child processes, including shell scripts, git commands, editors, pagers, and hooks.</source>
          <target state="translated">이들은 쉘 스크립트, git 명령, 편집기, 호출기 및 후크를 포함하여 다양한 생성 된 자식 프로세스와 관련이 있습니다.</target>
        </trans-unit>
        <trans-unit id="64d6caf87f558c78a882445d71ea9cd47be32d78" translate="yes" xml:space="preserve">
          <source>These are internal helper commands used by other commands; end users typically do not use them directly.</source>
          <target state="translated">이들은 다른 명령에서 사용되는 내부 도우미 명령입니다. 최종 사용자는 일반적으로 직접 사용하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="14e40973cf60a547a4fee511ff95c4f84a31a06f" translate="yes" xml:space="preserve">
          <source>These are only used with the &lt;code&gt;dcommit&lt;/code&gt; and &lt;code&gt;rebase&lt;/code&gt; commands.</source>
          <target state="translated">이들은 &lt;code&gt;dcommit&lt;/code&gt; 및 &lt;code&gt;rebase&lt;/code&gt; 명령 에만 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="1f4226446a769c76931ca392e2a09f31777b3654" translate="yes" xml:space="preserve">
          <source>These are optional command-line options for init. Each of these flags can point to a relative repository path (--tags=project/tags) or a full url (--tags=https://foo.org/project/tags). You can specify more than one --tags and/or --branches options, in case your Subversion repository places tags or branches under multiple paths. The option --stdlayout is a shorthand way of setting trunk,tags,branches as the relative paths, which is the Subversion default. If any of the other options are given as well, they take precedence.</source>
          <target state="translated">이들은 init에 대한 선택적 명령 행 옵션입니다. 이러한 각 플래그는 상대 리포지토리 경로 (--tags = project / tags) 또는 전체 URL (--tags = https : //foo.org/project/tags)을 가리킬 수 있습니다. Subversion 저장소가 여러 경로 아래에 태그 또는 분기를 배치하는 경우 둘 이상의 --tags 및 / 또는 --branches 옵션을 지정할 수 있습니다. --stdlayout 옵션은 트렁크, 태그, 분기를 상대 경로로 설정하는 간단한 방법으로 Subversion 기본값입니다. 다른 옵션도 제공되면 우선권을 갖습니다.</target>
        </trans-unit>
        <trans-unit id="ef89fe03d8c6b725e4e01a5ddca75169500d3912" translate="yes" xml:space="preserve">
          <source>These attributes affect how the contents stored in the repository are copied to the working tree files when commands such as &lt;code&gt;git switch&lt;/code&gt;, &lt;code&gt;git checkout&lt;/code&gt; and &lt;code&gt;git merge&lt;/code&gt; run. They also affect how Git stores the contents you prepare in the working tree in the repository upon &lt;code&gt;git add&lt;/code&gt; and &lt;code&gt;git commit&lt;/code&gt;.</source>
          <target state="translated">이러한 속성은 &lt;code&gt;git switch&lt;/code&gt; , &lt;code&gt;git checkout&lt;/code&gt; 및 &lt;code&gt;git merge&lt;/code&gt; 와 같은 명령이 실행될 때 리포지토리에 저장된 내용이 작업 트리 파일에 복사되는 방식에 영향을줍니다 . 또한 &lt;code&gt;git add&lt;/code&gt; 및 &lt;code&gt;git commit&lt;/code&gt; 시 작업 트리에서 준비한 내용을 저장소에 저장하는 방법에 영향을줍니다 .</target>
        </trans-unit>
        <trans-unit id="1e36f59cc4fba5296689c97860f8ef3c808cbf54" translate="yes" xml:space="preserve">
          <source>These can be easily kept up to date using &lt;a href=&quot;git-pull&quot;&gt;git-pull[1]&lt;/a&gt;.</source>
          <target state="translated">이것들은 &lt;a href=&quot;git-pull&quot;&gt;git-pull [1]을&lt;/a&gt; 사용하여 쉽게 최신 상태로 유지할 수 있습니다 .</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
