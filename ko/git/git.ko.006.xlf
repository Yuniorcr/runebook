<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="git">
    <body>
      <group id="git">
        <trans-unit id="ae19e2f586d76eb404950c906a0e28fc48bd4144" translate="yes" xml:space="preserve">
          <source>If the target branch in refs/remotes/p4-unshelved already exists, the old one will be renamed.</source>
          <target state="translated">refs / remotes / p4-unshelved의 대상 분기가 이미 존재하면 이전 분기의 이름이 바뀝니다.</target>
        </trans-unit>
        <trans-unit id="2f7883dbe6de00b83ac31c035cb47ace7f18b215" translate="yes" xml:space="preserve">
          <source>If the timestamp order of different files cross the revision order within the commit matching time window the order of commits may be wrong.</source>
          <target state="translated">다른 파일의 타임 스탬프 순서가 커밋 일치 시간 창 내에서 개정 순서를 넘으면 커밋 순서가 잘못되었을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9e02bc5f839968fa2bd55c9715c548322d410f70" translate="yes" xml:space="preserve">
          <source>If the update is done via merge, the submodule conflicts are resolved and checked out.</source>
          <target state="translated">병합을 통해 업데이트가 완료되면 하위 모듈 충돌이 해결되고 체크 아웃됩니다.</target>
        </trans-unit>
        <trans-unit id="e429444552f2f76afd93b7eab781098fd53d76ab" translate="yes" xml:space="preserve">
          <source>If the upstream branch already contains a change you have made (e.g., because you mailed a patch which was applied upstream), then that commit will be skipped. For example, running &lt;code&gt;git rebase master&lt;/code&gt; on the following history (in which &lt;code&gt;A'&lt;/code&gt; and &lt;code&gt;A&lt;/code&gt; introduce the same set of changes, but have different committer information):</source>
          <target state="translated">업스트림 브랜치에 이미 변경 한 내용이 포함 된 경우 (예 : 업스트림으로 적용된 패치를 메일로 발송 한 경우) 해당 커밋은 건너 뜁니다. 예를 들어, 다음 히스토리 에서 &lt;code&gt;git rebase master&lt;/code&gt; 를 실행 하면 ( &lt;code&gt;A'&lt;/code&gt; 와 &lt;code&gt;A&lt;/code&gt; 는 동일한 변경 사항 세트를 도입하지만 커미터 정보는 다릅니다) :</target>
        </trans-unit>
        <trans-unit id="8dd2ebfbc7db6f2a970a9204f7e4fecacb05b440" translate="yes" xml:space="preserve">
          <source>If the user is driving it, then at each step of the search, the user will have to test the current commit and say if it is &quot;good&quot; or &quot;bad&quot; using the &quot;git bisect good&quot; or &quot;git bisect bad&quot; commands respectively that have been described above. For example:</source>
          <target state="translated">사용자가이를 검색하는 경우 검색의 각 단계에서 현재 커밋을 테스트하고 &quot;git bisect good&quot;또는 &quot;git bisect bad&quot;명령을 사용하여 현재 커밋을 테스트해야합니다. 위에서 설명한 각각. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="6929af54c2109d01f0c27eda6b64b41906b00393" translate="yes" xml:space="preserve">
          <source>If the user provides a --tag-name-filter that maps multiple tags to the same name, no warning or error is provided; git-filter-branch simply overwrites each tag in some undocumented pre-defined order resulting in only one tag at the end. (A git-filter-branch regression test requires this surprising behavior.)</source>
          <target state="translated">사용자가 여러 태그를 같은 이름으로 매핑하는 --tag-name-filter를 제공하면 경고 또는 오류가 제공되지 않습니다. git-filter-branch는 각 태그를 문서화되지 않은 사전 정의 된 순서로 덮어 쓰기하여 끝에 하나의 태그 만 만듭니다. git-filter-branch 회귀 테스트에는이 놀라운 동작이 필요합니다.</target>
        </trans-unit>
        <trans-unit id="115afcefe8deea6713a6376b9b3612622ce5ff41" translate="yes" xml:space="preserve">
          <source>If the user running &lt;code&gt;git p4 submit&lt;/code&gt; does not exist in the p4 user map, &lt;code&gt;git p4&lt;/code&gt; exits. This option can be used to force submission regardless.</source>
          <target state="translated">&lt;code&gt;git p4 submit&lt;/code&gt; 을 실행하는 사용자 가 p4 사용자 맵에 존재하지 않으면 &lt;code&gt;git p4&lt;/code&gt; 가 종료됩니다. 이 옵션을 사용하여 제출을 강제 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4ce7fbc3c51757d8b6052ea0a42e4807120e305f" translate="yes" xml:space="preserve">
          <source>If the value is boolean, turns on or off pagination of the output of a particular Git subcommand when writing to a tty. Otherwise, turns on pagination for the subcommand using the pager specified by the value of &lt;code&gt;pager.&amp;lt;cmd&amp;gt;&lt;/code&gt;. If &lt;code&gt;--paginate&lt;/code&gt; or &lt;code&gt;--no-pager&lt;/code&gt; is specified on the command line, it takes precedence over this option. To disable pagination for all commands, set &lt;code&gt;core.pager&lt;/code&gt; or &lt;code&gt;GIT_PAGER&lt;/code&gt; to &lt;code&gt;cat&lt;/code&gt;.</source>
          <target state="translated">값이 부울 인 경우 tty에 쓸 때 특정 Git 부속 명령의 출력에 대한 페이지 매김을 켜거나 끕니다. 그렇지 않으면, &lt;code&gt;pager.&amp;lt;cmd&amp;gt;&lt;/code&gt; 값으로 지정된 페이저를 사용하여 부속 명령에 대한 페이지 매김을 설정하십시오 . 경우 &lt;code&gt;--paginate&lt;/code&gt; 또는 &lt;code&gt;--no-pager&lt;/code&gt; 명령 행에 지정되어,이 옵션보다 우선합니다. 모든 명령에 대해 페이지 매김을 비활성화하려면 &lt;code&gt;core.pager&lt;/code&gt; 또는 &lt;code&gt;GIT_PAGER&lt;/code&gt; 을 &lt;code&gt;cat&lt;/code&gt; 로 설정하십시오 .</target>
        </trans-unit>
        <trans-unit id="d03e93ea222dab8f641cb8201b06b8ce56eb4397" translate="yes" xml:space="preserve">
          <source>If the variable is set to an integer value greater than 2 and lower than 10 (strictly) then Git will interpret this value as an open file descriptor and will try to write the trace messages into this file descriptor.</source>
          <target state="translated">변수가 2보다 크고 10보다 작은 정수 값으로 설정되면 (엄격히) Git은이 값을 열린 파일 디스크립터로 해석하고이 파일 디스크립터에 추적 메시지를 쓰려고 시도합니다.</target>
        </trans-unit>
        <trans-unit id="68e78b3aa184c7970e4ea72bcfa1c35c1841182d" translate="yes" xml:space="preserve">
          <source>If there are a large number of similarly-named remote repositories and you want to use a different format for them (such that the URLs you use will be rewritten into URLs that work), you can create a configuration section of the form:</source>
          <target state="translated">비슷한 이름의 원격 저장소가 많이 있고 다른 형식을 사용하려는 경우 (사용하는 URL이 작동하는 URL로 다시 작성되도록) 다음과 같은 형식의 구성 섹션을 작성할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1add756b76a7c17e78b77f722a60e35881bd1c18" translate="yes" xml:space="preserve">
          <source>If there are conflicts, the user should edit the result and delete one of the alternatives. When &lt;code&gt;--ours&lt;/code&gt;, &lt;code&gt;--theirs&lt;/code&gt;, or &lt;code&gt;--union&lt;/code&gt; option is in effect, however, these conflicts are resolved favouring lines from &lt;code&gt;&amp;lt;current-file&amp;gt;&lt;/code&gt;, lines from &lt;code&gt;&amp;lt;other-file&amp;gt;&lt;/code&gt;, or lines from both respectively. The length of the conflict markers can be given with the &lt;code&gt;--marker-size&lt;/code&gt; option.</source>
          <target state="translated">충돌이있는 경우 결과를 편집하고 대체 방법 중 하나를 삭제해야합니다. 때 &lt;code&gt;--ours&lt;/code&gt; , &lt;code&gt;--theirs&lt;/code&gt; , 또는 &lt;code&gt;--union&lt;/code&gt; 옵션이 유효하지만, 이러한 충돌에서 라인을 선호 해결이다 &lt;code&gt;&amp;lt;current-file&amp;gt;&lt;/code&gt; 에서 선 &lt;code&gt;&amp;lt;other-file&amp;gt;&lt;/code&gt; 모두 각각에서, 또는 라인. 충돌 마커의 길이는 &lt;code&gt;--marker-size&lt;/code&gt; 옵션 으로 제공 될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="86762a48683c371a4cc7c3de1cb012419562ae87" translate="yes" xml:space="preserve">
          <source>If there are multiple branches, doing &lt;code&gt;git p4 sync&lt;/code&gt; will automatically use the &quot;BRANCH DETECTION&quot; algorithm to try to partition new changes into the right branch. This can be overridden with the &lt;code&gt;--branch&lt;/code&gt; option to specify just a single branch to update.</source>
          <target state="translated">분기가 여러 개인 경우, &lt;code&gt;git p4 sync&lt;/code&gt; 를 수행 하면 자동으로 &quot;BRANCH DETECTION&quot;알고리즘을 사용하여 새 변경 사항을 올바른 분기로 분할합니다. &lt;code&gt;--branch&lt;/code&gt; 옵션으로 이를 재정 의하여 업데이트 할 단일 분기 만 지정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="618accc0d1d550b6b8ec069f55b5b09af649e985" translate="yes" xml:space="preserve">
          <source>If there are multiple instances of the &lt;code&gt;credential.helper&lt;/code&gt; configuration variable, each helper will be tried in turn, and may provide a username, password, or nothing. Once Git has acquired both a username and a password, no more helpers will be tried.</source>
          <target state="translated">&lt;code&gt;credential.helper&lt;/code&gt; 구성 변수의 인스턴스가 여러 개인 경우 각 헬퍼는 차례로 시도되며 사용자 이름, 비밀번호 또는 아무것도 제공하지 않을 수 있습니다. Git이 사용자 이름과 비밀번호를 모두 획득하면 더 이상 도우미가 시도되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="af9d46d5bd3ac828de63ddb9d4effe59327aaa5a" translate="yes" xml:space="preserve">
          <source>If there are other repositories that you also use frequently, you can create similar configuration options to save typing; for example,</source>
          <target state="translated">자주 사용하는 다른 리포지토리가있는 경우 유사한 구성 옵션을 만들어 입력을 저장할 수 있습니다. 예를 들어</target>
        </trans-unit>
        <trans-unit id="591918eb06b2723ac86bd0a089445e6e294cf8c5" translate="yes" xml:space="preserve">
          <source>If there exist packfiles in the pack directory not registered in the MIDX, then those packfiles are loaded into the &lt;code&gt;packed_git&lt;/code&gt; list and &lt;code&gt;packed_git_mru&lt;/code&gt; cache.</source>
          <target state="translated">MIDX에 등록되지 않은 pack 디렉토리에 packfile이있는 경우 해당 packfile은 &lt;code&gt;packed_git&lt;/code&gt; 목록 및 &lt;code&gt;packed_git_mru&lt;/code&gt; 캐시에 로드됩니다 .</target>
        </trans-unit>
        <trans-unit id="03e18f44da1b610f354ea9baeb478307ccf925f8" translate="yes" xml:space="preserve">
          <source>If there is a separator at the beginning or middle (or both) of the pattern, then the pattern is relative to the directory level of the particular &lt;code&gt;.gitignore&lt;/code&gt; file itself. Otherwise the pattern may also match at any level below the &lt;code&gt;.gitignore&lt;/code&gt; level.</source>
          <target state="translated">패턴의 시작 또는 중간 (또는 둘 다)에 구분 기호가있는 경우 패턴은 특정 &lt;code&gt;.gitignore&lt;/code&gt; 파일 자체 의 디렉토리 레벨을 기준으로합니다 . 그렇지 않으면 패턴이 &lt;code&gt;.gitignore&lt;/code&gt; 레벨 아래의 어떤 레벨에서도 일치 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="73c5dbd4863767291eb0584c1211aa56213f1838" translate="yes" xml:space="preserve">
          <source>If there is a separator at the end of the pattern then the pattern will only match directories, otherwise the pattern can match both files and directories.</source>
          <target state="translated">패턴 끝에 구분 기호가있는 경우 패턴은 디렉토리와 만 일치하고 그렇지 않으면 패턴은 파일과 디렉토리 모두와 일치 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7e5e3b6d9186f0b0d9ca9ea83f70b7fee637fea2" translate="yes" xml:space="preserve">
          <source>If there is a separator, then the key will be used instead of both the &amp;lt;token&amp;gt; and the default separator when adding the trailer.</source>
          <target state="translated">구분 기호가있는 경우 트레일러를 추가 할 때 &amp;lt;토큰&amp;gt;과 기본 구분 기호 대신 키가 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="110096af5aaaf08aca8aad30cdfe6c3abec7eaf2" translate="yes" xml:space="preserve">
          <source>If there is no file or subtree at that path, &lt;code&gt;git fast-import&lt;/code&gt; will instead report</source>
          <target state="translated">해당 경로에 파일이나 하위 트리가 없으면 &lt;code&gt;git fast-import&lt;/code&gt; 는 대신보고합니다.</target>
        </trans-unit>
        <trans-unit id="1db0218c6ea3cc08d2d45a6158a3df08d714812b" translate="yes" xml:space="preserve">
          <source>If there is no parameter given by the user, use &lt;code&gt;&amp;lt;arg&amp;gt;&lt;/code&gt; instead.</source>
          <target state="translated">사용자가 제공 한 매개 변수가 없으면 &lt;code&gt;&amp;lt;arg&amp;gt;&lt;/code&gt; 를 대신 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="08079a827cded7daddc3f36e473048d3482101ec" translate="yes" xml:space="preserve">
          <source>If there is only one &amp;lt;tree-ish&amp;gt; given, the commit is compared with its parents (see --stdin below).</source>
          <target state="translated">&amp;lt;tree-ish&amp;gt;가 하나만 있으면 커밋이 부모와 비교됩니다 (아래 --stdin 참조).</target>
        </trans-unit>
        <trans-unit id="f3b2c7580e6489ea5e91cbe02a9f524e00ba7a5a" translate="yes" xml:space="preserve">
          <source>If there were more commits on the &lt;em&gt;master&lt;/em&gt; branch after the merge, the merge commit itself would not be shown by &lt;em&gt;git show-branch&lt;/em&gt; by default. You would need to provide &lt;code&gt;--sparse&lt;/code&gt; option to make the merge commit visible in this case.</source>
          <target state="translated">병합 후 &lt;em&gt;마스터&lt;/em&gt; 브랜치 에 더 많은 커밋이 있으면 병합 커밋 자체는 기본적으로 &lt;em&gt;git show-branch에&lt;/em&gt; 의해 &lt;em&gt;표시&lt;/em&gt; 되지 않습니다 . 이 경우 병합 커밋을 표시하려면 &lt;code&gt;--sparse&lt;/code&gt; 옵션 을 제공해야합니다 .</target>
        </trans-unit>
        <trans-unit id="0ab64f384f8b476963c3f64ac176ef68ee6de9f2" translate="yes" xml:space="preserve">
          <source>If there were uncommitted worktree changes present when the merge started, &lt;code&gt;git merge --abort&lt;/code&gt; will in some cases be unable to reconstruct these changes. It is therefore recommended to always commit or stash your changes before running &lt;code&gt;git merge&lt;/code&gt;.</source>
          <target state="translated">병합이 시작될 때 커밋되지 않은 작업 트리 변경이있는 경우 &lt;code&gt;git merge --abort&lt;/code&gt; 는 이러한 변경을 재구성 할 수없는 경우가 있습니다. 따라서 &lt;code&gt;git merge&lt;/code&gt; 를 실행하기 전에 항상 변경 사항을 커밋하거나 숨기는 것이 좋습니다 .</target>
        </trans-unit>
        <trans-unit id="967d5740c3c32e83504fdb7318f7465d81e3c6cb" translate="yes" xml:space="preserve">
          <source>If this atom is used in the output string, input lines are split at the first whitespace boundary. All characters before that whitespace are considered to be the object name; characters after that first run of whitespace (i.e., the &quot;rest&quot; of the line) are output in place of the &lt;code&gt;%(rest)&lt;/code&gt; atom.</source>
          <target state="translated">이 아톰이 출력 문자열에 사용되면 입력 행이 첫 번째 공백 경계에서 분할됩니다. 공백 앞에있는 모든 문자는 객체 이름으로 간주됩니다. 공백이 처음 실행 된 후의 문자 (즉, 줄의 &quot;rest&quot;)는 &lt;code&gt;%(rest)&lt;/code&gt; 원자 대신에 출력됩니다 .</target>
        </trans-unit>
        <trans-unit id="4b6208e01f164e5f8b5cfeffb592a9b059f78c4e" translate="yes" xml:space="preserve">
          <source>If this attribute is not set or has an invalid value, the value of the &lt;code&gt;gui.encoding&lt;/code&gt; configuration variable is used instead (See &lt;a href=&quot;git-config&quot;&gt;git-config[1]&lt;/a&gt;).</source>
          <target state="translated">이 속성이 설정되지 않았거나 유효하지 않은 값을 가지고 있으면 &lt;code&gt;gui.encoding&lt;/code&gt; 구성 변수 의 값이 대신 사용됩니다 ( &lt;a href=&quot;git-config&quot;&gt;git-config [1] 참조&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="d21856ae35021bd75d04c1b344656e77c3e714d8" translate="yes" xml:space="preserve">
          <source>If this config variable is set, diff generation is not performed using the internal diff machinery, but using the given command. Can be overridden with the &amp;lsquo;GIT_EXTERNAL_DIFF&amp;rsquo; environment variable. The command is called with parameters as described under &quot;git Diffs&quot; in &lt;a href=&quot;git&quot;&gt;git[1]&lt;/a&gt;. Note: if you want to use an external diff program only on a subset of your files, you might want to use &lt;a href=&quot;gitattributes&quot;&gt;gitattributes[5]&lt;/a&gt; instead.</source>
          <target state="translated">이 구성 변수가 설정되면 내부 diff 기계를 사용하지 않고 주어진 명령을 사용하여 diff 생성이 수행됩니다. 'GIT_EXTERNAL_DIFF'환경 변수로 대체 할 수 있습니다. 이 명령은 &lt;a href=&quot;git&quot;&gt;git [1]의&lt;/a&gt; &quot;git Diffs&quot;에 설명 된대로 매개 변수와 함께 호출됩니다 . 참고 : 파일의 서브 세트에만 외부 diff 프로그램을 사용하려면 대신 &lt;a href=&quot;gitattributes&quot;&gt;gitattributes [5]를&lt;/a&gt; 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="c67dbd9b5b9d0c250d594cf0e82ea55d38dac133" translate="yes" xml:space="preserve">
          <source>If this environment variable is set to &quot;1&quot;, then commands such as &lt;code&gt;git blame&lt;/code&gt; (in incremental mode), &lt;code&gt;git rev-list&lt;/code&gt;, &lt;code&gt;git log&lt;/code&gt;, &lt;code&gt;git check-attr&lt;/code&gt; and &lt;code&gt;git check-ignore&lt;/code&gt; will force a flush of the output stream after each record have been flushed. If this variable is set to &quot;0&quot;, the output of these commands will be done using completely buffered I/O. If this environment variable is not set, Git will choose buffered or record-oriented flushing based on whether stdout appears to be redirected to a file or not.</source>
          <target state="translated">이 환경 변수가 &quot;1&quot;로 설정되면 &lt;code&gt;git blame&lt;/code&gt; (증분 모드), &lt;code&gt;git rev-list&lt;/code&gt; , &lt;code&gt;git log&lt;/code&gt; , &lt;code&gt;git check-attr&lt;/code&gt; 및 &lt;code&gt;git check-ignore&lt;/code&gt; 와 같은 명령 은 각각의 출력 스트림을 강제로 플러시합니다. 레코드가 플러시되었습니다. 이 변수가 &quot;0&quot;으로 설정되면 이러한 명령의 출력은 완전히 버퍼링 된 I / O를 사용하여 수행됩니다. 이 환경 변수가 설정되지 않으면 Git은 stdout이 파일로 리디렉션되는지 여부에 따라 버퍼링 또는 레코드 지향 플러싱을 선택합니다.</target>
        </trans-unit>
        <trans-unit id="3c510f35b5c52541d7f8ff48371ed312cadc959c" translate="yes" xml:space="preserve">
          <source>If this environment variable is set to &lt;code&gt;0&lt;/code&gt;, git will not prompt on the terminal (e.g., when asking for HTTP authentication).</source>
          <target state="translated">이 환경 변수가 &lt;code&gt;0&lt;/code&gt; 으로 설정 되면 git은 터미널에 프롬프트를 표시하지 않습니다 (예 : HTTP 인증을 요청할 때).</target>
        </trans-unit>
        <trans-unit id="f0e0816f1f387058c1f2d75f7ff32a01f9295472" translate="yes" xml:space="preserve">
          <source>If this environment variable is set, it overrides Git&amp;rsquo;s autodetection whether &lt;code&gt;GIT_SSH&lt;/code&gt;/&lt;code&gt;GIT_SSH_COMMAND&lt;/code&gt;/&lt;code&gt;core.sshCommand&lt;/code&gt; refer to OpenSSH, plink or tortoiseplink. This variable overrides the config setting &lt;code&gt;ssh.variant&lt;/code&gt; that serves the same purpose.</source>
          <target state="translated">이 환경 변수가 설정되면 &lt;code&gt;GIT_SSH&lt;/code&gt; / &lt;code&gt;GIT_SSH_COMMAND&lt;/code&gt; / &lt;code&gt;core.sshCommand&lt;/code&gt; 가 OpenSSH, plink 또는 tortoiseplink를 참조 하는지 여부에 따라 Git의 자동 감지를 무시합니다 . 이 변수 는 동일한 목적을 수행하는 구성 설정 &lt;code&gt;ssh.variant&lt;/code&gt; 를 대체합니다 .</target>
        </trans-unit>
        <trans-unit id="81f782a4dbe0e346a4da365c1a6b3a9cbeb4a6e2" translate="yes" xml:space="preserve">
          <source>If this environment variable is set, then Git commands which need to acquire passwords or passphrases (e.g. for HTTP or IMAP authentication) will call this program with a suitable prompt as command-line argument and read the password from its STDOUT. See also the &lt;code&gt;core.askPass&lt;/code&gt; option in &lt;a href=&quot;git-config&quot;&gt;git-config[1]&lt;/a&gt;.</source>
          <target state="translated">이 환경 변수가 설정되면 비밀번호 또는 비밀번호 문구 (예 : HTTP 또는 IMAP 인증)를 가져와야하는 Git 명령은 적절한 프롬프트를 명령 행 인수로 사용하여이 프로그램을 호출하고 STDOUT에서 비밀번호를 읽습니다. &lt;a href=&quot;git-config&quot;&gt;git-config [1]&lt;/a&gt; 의 &lt;code&gt;core.askPass&lt;/code&gt; 옵션 도 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="372352ecb2d8c55afffa99890c0eb497f2b1382d" translate="yes" xml:space="preserve">
          <source>If this feature is enabled, gitweb considers projects in subdirectories of project root (basename) to be forks of existing projects. For each project &lt;code&gt;$projname.git&lt;/code&gt;, projects in the &lt;code&gt;$projname/&lt;/code&gt; directory and its subdirectories will not be shown in the main projects list. Instead, a '+' mark is shown next to &lt;code&gt;$projname&lt;/code&gt;, which links to a &quot;forks&quot; view that lists all the forks (all projects in &lt;code&gt;$projname/&lt;/code&gt; subdirectory). Additionally a &quot;forks&quot; view for a project is linked from project summary page.</source>
          <target state="translated">이 기능이 활성화되면 gitweb은 프로젝트 루트 (기본 이름)의 하위 디렉토리에있는 프로젝트를 기존 프로젝트의 포크로 간주합니다. 각 프로젝트 &lt;code&gt;$projname.git&lt;/code&gt; 에 대해 &lt;code&gt;$projname/&lt;/code&gt; 디렉토리 의 프로젝트 와 해당 서브 디렉토리는 기본 프로젝트 목록에 표시되지 않습니다. 대신 &lt;code&gt;$projname&lt;/code&gt; 옆에 '+'표시가 표시됩니다.이 표시는 모든 포크 ( &lt;code&gt;$projname/&lt;/code&gt; 하위 디렉토리의 모든 프로젝트)를 나열하는 &quot;포크&quot;보기로 연결됩니다 . 또한 프로젝트의 &quot;포크&quot;보기는 프로젝트 요약 페이지에서 연결됩니다.</target>
        </trans-unit>
        <trans-unit id="728d51c620f0870eff1b0d62261ab6934369adf2" translate="yes" xml:space="preserve">
          <source>If this field has a true value then the given feature is overridable, which means that it can be configured (or enabled/disabled) on a per-repository basis.</source>
          <target state="translated">이 필드에 실제 값이 있으면 지정된 기능을 재정의 할 수 있습니다. 즉, 리포지토리별로 구성 (또는 활성화 / 비활성화) 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="582826e66f53339e6d7b4dc6a0d6a2edeb312487" translate="yes" xml:space="preserve">
          <source>If this file exists, $GIT_COMMON_DIR (see &lt;a href=&quot;git&quot;&gt;git[1]&lt;/a&gt;) will be set to the path specified in this file if it is not explicitly set. If the specified path is relative, it is relative to $GIT_DIR. The repository with commondir is incomplete without the repository pointed by &quot;commondir&quot;.</source>
          <target state="translated">이 파일이 존재하면 $ GIT_COMMON_DIR ( &lt;a href=&quot;git&quot;&gt;git [1]&lt;/a&gt; 참조 )이 명시 적으로 설정되지 않은 경우이 파일에 지정된 경로로 설정됩니다. 지정된 경로가 상대 경로이면 $ GIT_DIR에 상대 경로입니다. commondir이있는 저장소는 &quot;commondir&quot;이 가리키는 저장소가 없으면 불완전합니다.</target>
        </trans-unit>
        <trans-unit id="1e44552a87aaa0e818702548719ba07ebc0f8696" translate="yes" xml:space="preserve">
          <source>If this file exists, the linked working tree may be on a portable device and not available. The presence of this file prevents &lt;code&gt;worktrees/&amp;lt;id&amp;gt;&lt;/code&gt; from being pruned either automatically or manually by &lt;code&gt;git worktree prune&lt;/code&gt;. The file may contain a string explaining why the repository is locked.</source>
          <target state="translated">이 파일이 존재하면 연결된 작업 트리가 휴대용 장치에 있고 사용하지 못할 수 있습니다. 이 파일이 있으면 &lt;code&gt;git worktree prune&lt;/code&gt; 에 의해 &lt;code&gt;worktrees/&amp;lt;id&amp;gt;&lt;/code&gt; 가 자동 또는 수동으로 제거되지 않습니다 . 파일에는 리포지토리가 잠긴 이유를 설명하는 문자열이 포함될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6849302064fdf0db00fe326dd1a92636c39a6d43" translate="yes" xml:space="preserve">
          <source>If this hook exits with a non-zero status, &lt;code&gt;git push&lt;/code&gt; will abort without pushing anything. Information about why the push is rejected may be sent to the user by writing to standard error.</source>
          <target state="translated">이 후크가 0이 아닌 상태로 종료되면 &lt;code&gt;git push&lt;/code&gt; 는 아무 것도 누르지 않고 중단됩니다. 푸시가 거부 된 이유에 대한 정보는 표준 오류에 기록하여 사용자에게 전송 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9e422a5c19027398b3db2e62a2dfa8c2a2031ac5" translate="yes" xml:space="preserve">
          <source>If this is reinitialization, the repository will be moved to the specified path.</source>
          <target state="translated">다시 초기화하는 경우 리포지토리가 지정된 경로로 이동합니다.</target>
        </trans-unit>
        <trans-unit id="ae49e42c53a829e13a69befb7e448cbf7a3ab5aa" translate="yes" xml:space="preserve">
          <source>If this is set to code reference, it will be run once for each request. You can set parts of configuration that change per session this way. For example, one might use the following code in a gitweb configuration file</source>
          <target state="translated">이것이 코드 참조로 설정되면 각 요청마다 한 번씩 실행됩니다. 이 방법으로 세션마다 변경되는 구성 부분을 설정할 수 있습니다. 예를 들어, gitweb 구성 파일에서 다음 코드를 사용할 수 있습니다</target>
        </trans-unit>
        <trans-unit id="2ecaf4f8ea5745cd5a451b94ab44dd28ff120dab" translate="yes" xml:space="preserve">
          <source>If this is set to true, the &lt;code&gt;git stash show&lt;/code&gt; command without an option will show diffstat of the stash entry. Defaults to true. See description of &lt;code&gt;show&lt;/code&gt; command in &lt;a href=&quot;git-stash&quot;&gt;git-stash[1]&lt;/a&gt;.</source>
          <target state="translated">이것이 true로 설정되면 , 옵션이없는 &lt;code&gt;git stash show&lt;/code&gt; 명령은 숨김 항목의 diffstat를 표시합니다. 기본값은 true입니다. &lt;a href=&quot;git-stash&quot;&gt;git-stash [1]&lt;/a&gt; 의 &lt;code&gt;show&lt;/code&gt; 명령 설명을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="ee4998fa7e703962f55f3297f84fc3b952ae4a7f" translate="yes" xml:space="preserve">
          <source>If this is set to true, the &lt;code&gt;git stash show&lt;/code&gt; command without an option will show the stash entry in patch form. Defaults to false. See description of &lt;code&gt;show&lt;/code&gt; command in &lt;a href=&quot;git-stash&quot;&gt;git-stash[1]&lt;/a&gt;.</source>
          <target state="translated">이것이 true로 설정 되면 옵션없이 &lt;code&gt;git stash show&lt;/code&gt; 명령은 숨김 항목을 패치 형식으로 표시합니다. 기본값은 false입니다. &lt;a href=&quot;git-stash&quot;&gt;git-stash [1]&lt;/a&gt; 의 &lt;code&gt;show&lt;/code&gt; 명령 설명을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="7e98f4c395c1b49b1de4c0111925dea856a6d079" translate="yes" xml:space="preserve">
          <source>If this is set, add emails found in Signed-off-by: or Cc: lines to the cc list. Default is the value of &lt;code&gt;sendemail.signedoffbycc&lt;/code&gt; configuration value; if that is unspecified, default to --signed-off-by-cc.</source>
          <target state="translated">이것이 설정되어 있으면 Signed-off-by :: 또는 Cc : 행에있는 전자 메일을 참조 목록에 추가하십시오. 기본값은 &lt;code&gt;sendemail.signedoffbycc&lt;/code&gt; 구성 값입니다. 지정되지 않은 경우 기본값은 --signed-off-by-cc입니다.</target>
        </trans-unit>
        <trans-unit id="6cf7f20765eaeb225b14832d24072d63179e161f" translate="yes" xml:space="preserve">
          <source>If this is set, do not add the From: address to the cc: list. Default is the value of &lt;code&gt;sendemail.suppressFrom&lt;/code&gt; configuration value; if that is unspecified, default to --no-suppress-from.</source>
          <target state="translated">이것이 설정된 경우, From : 주소를 cc : 목록에 추가하지 마십시오. 기본값은 &lt;code&gt;sendemail.suppressFrom&lt;/code&gt; 구성 값입니다. 지정하지 않으면 기본값은 --no-suppress-from입니다.</target>
        </trans-unit>
        <trans-unit id="048d4528d0951754849879e2b4b5802f6461c9fb" translate="yes" xml:space="preserve">
          <source>If this is set, each email will be sent as a reply to the previous email sent. If disabled with &quot;--no-chain-reply-to&quot;, all emails after the first will be sent as replies to the first email sent. When using this, it is recommended that the first file given be an overview of the entire patch series. Disabled by default, but the &lt;code&gt;sendemail.chainReplyTo&lt;/code&gt; configuration variable can be used to enable it.</source>
          <target state="translated">이것이 설정되면, 각 이메일은 이전에 전송 된 이메일에 대한 응답으로 전송됩니다. &quot;-체인 없음 회신&quot;으로 비활성화하면 첫 번째 전자 메일 이후의 모든 전자 메일이 첫 번째 전자 메일에 대한 회신으로 전송됩니다. 이것을 사용할 때, 주어진 첫 번째 파일은 전체 패치 시리즈의 개요 일 것을 권장합니다. 기본적으로 비활성화되어 있지만 &lt;code&gt;sendemail.chainReplyTo&lt;/code&gt; 구성 변수를 사용하여 활성화 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b4073ff276c4f44294d676470e6aaaeb5a46458f" translate="yes" xml:space="preserve">
          <source>If this is set, emails found in Cc: headers in the first patch of the series (typically the cover letter) are added to the cc list for each email set. Default is the value of &lt;code&gt;sendemail.cccover&lt;/code&gt; configuration value; if that is unspecified, default to --no-cc-cover.</source>
          <target state="translated">이것이 설정되면 시리즈의 첫 번째 패치에있는 Cc : 헤더에있는 이메일 (일반적으로 표지)이 각 이메일 세트의 cc 목록에 추가됩니다. 기본값은 &lt;code&gt;sendemail.cccover&lt;/code&gt; 구성 값입니다. 지정되지 않은 경우 기본값은 --no-cc-cover입니다.</target>
        </trans-unit>
        <trans-unit id="c3505cfc9a16fb3a406321b32681f1c27b3f4828" translate="yes" xml:space="preserve">
          <source>If this is set, emails found in To: headers in the first patch of the series (typically the cover letter) are added to the to list for each email set. Default is the value of &lt;code&gt;sendemail.tocover&lt;/code&gt; configuration value; if that is unspecified, default to --no-to-cover.</source>
          <target state="translated">이것이 설정되면 시리즈의 첫 번째 패치 (보통 겉 표지)의 To : 헤더에있는 이메일이 각 이메일 세트의받는 사람 목록에 추가됩니다. 기본값은 &lt;code&gt;sendemail.tocover&lt;/code&gt; 구성 값입니다. 지정되지 않은 경우 기본값은 --no-to-cover입니다.</target>
        </trans-unit>
        <trans-unit id="bd074611e2ce23fe3651c7c21615bc5d5c90b653" translate="yes" xml:space="preserve">
          <source>If this is set, the In-Reply-To and References headers will be added to each email sent. Whether each mail refers to the previous email (&lt;code&gt;deep&lt;/code&gt; threading per &lt;code&gt;git format-patch&lt;/code&gt; wording) or to the first email (&lt;code&gt;shallow&lt;/code&gt; threading) is governed by &quot;--[no-]chain-reply-to&quot;.</source>
          <target state="translated">이것이 설정되면, In-Reply-To 및 References 헤더가 전송 된 각 이메일에 추가됩니다. 각 메일이 이전 이메일 ( &lt;code&gt;git format-patch&lt;/code&gt; wording 당 &lt;code&gt;deep&lt;/code&gt; 스레딩 ) 또는 첫 번째 이메일 ( &lt;code&gt;shallow&lt;/code&gt; 스레딩)을 참조하는지 여부 는 &quot;-[no-] chain-reply-to&quot;에 의해 관리됩니다.</target>
        </trans-unit>
        <trans-unit id="83fefd231faf2237df4d2ca57ddb91f5733dd174" translate="yes" xml:space="preserve">
          <source>If this option is also present in the submodules entry in .git/config of the superproject, the setting there will override the one found in .gitmodules.</source>
          <target state="translated">이 옵션이 수퍼 프로젝트의 .git / config에있는 서브 모듈 항목에도있는 경우, 설정은 .gitmodules에있는 설정보다 우선합니다.</target>
        </trans-unit>
        <trans-unit id="b576cec09f399abde10801d9e3b482a3974a7942" translate="yes" xml:space="preserve">
          <source>If this option is set, &lt;code&gt;upload-pack&lt;/code&gt; will support partial clone and partial fetch object filtering.</source>
          <target state="translated">이 옵션을 설정하면 &lt;code&gt;upload-pack&lt;/code&gt; 은 부분 복제 및 부분 가져 오기 객체 필터링을 지원합니다.</target>
        </trans-unit>
        <trans-unit id="46df2747ed059ec465747bf23f6d93b6698f2ce3" translate="yes" xml:space="preserve">
          <source>If this option is set, &lt;code&gt;upload-pack&lt;/code&gt; will support the &lt;code&gt;ref-in-want&lt;/code&gt; feature of the protocol version 2 &lt;code&gt;fetch&lt;/code&gt; command. This feature is intended for the benefit of load-balanced servers which may not have the same view of what OIDs their refs point to due to replication delay.</source>
          <target state="translated">이 옵션을 설정하면 &lt;code&gt;upload-pack&lt;/code&gt; 은 프로토콜 버전 2 &lt;code&gt;fetch&lt;/code&gt; 명령 의 &lt;code&gt;ref-in-want&lt;/code&gt; 기능을 지원합니다 . 이 기능은로드 밸런싱 된 서버의 이점을 위해 만들어졌으며 복제 지연으로 인해 참조가 가리키는 OID와 동일한보기를 갖지 않을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3691063a71adef86ec77db2886b5e8b672228551" translate="yes" xml:space="preserve">
          <source>If this option is set, when &lt;code&gt;upload-pack&lt;/code&gt; would run &lt;code&gt;git pack-objects&lt;/code&gt; to create a packfile for a client, it will run this shell command instead. The &lt;code&gt;pack-objects&lt;/code&gt; command and arguments it &lt;code&gt;would&lt;/code&gt; have run (including the &lt;code&gt;git pack-objects&lt;/code&gt; at the beginning) are appended to the shell command. The stdin and stdout of the hook are treated as if &lt;code&gt;pack-objects&lt;/code&gt; itself was run. I.e., &lt;code&gt;upload-pack&lt;/code&gt; will feed input intended for &lt;code&gt;pack-objects&lt;/code&gt; to the hook, and expects a completed packfile on stdout.</source>
          <target state="translated">이 옵션을 설정하면 &lt;code&gt;upload-pack&lt;/code&gt; 이 &lt;code&gt;git pack-objects&lt;/code&gt; 를 실행하여 클라이언트에 대한 팩 파일 을 만들 때 대신이 셸 명령을 실행합니다. &lt;code&gt;pack-objects&lt;/code&gt; 명령과 그 인수 &lt;code&gt;would&lt;/code&gt; 합니다 (를 포함하여 실행 한 &lt;code&gt;git pack-objects&lt;/code&gt; 시작 부분) 쉘 명령에 추가됩니다. 후크의 stdin 및 stdout은 &lt;code&gt;pack-objects&lt;/code&gt; 자체가 실행 된 것처럼 처리됩니다 . 즉, &lt;code&gt;upload-pack&lt;/code&gt; 은 &lt;code&gt;pack-objects&lt;/code&gt; 용 입력 을 후크에 공급하고 stdout에서 완료된 packfile을 기대합니다.</target>
        </trans-unit>
        <trans-unit id="043d313af4e6bae8eb0dfe37d6ed595c4f6e4603" translate="yes" xml:space="preserve">
          <source>If this option is specified and &lt;code&gt;git svn&lt;/code&gt; encounters an SVN committer name that does not exist in the authors-file, &lt;code&gt;git svn&lt;/code&gt; will abort operation. The user will then have to add the appropriate entry. Re-running the previous &lt;code&gt;git svn&lt;/code&gt; command after the authors-file is modified should continue operation.</source>
          <target state="translated">이 옵션이 지정되고 &lt;code&gt;git svn&lt;/code&gt; 이 authors 파일에 존재하지 않는 SVN 커미터 이름을 발견하면 &lt;code&gt;git svn&lt;/code&gt; 은 작업을 중단합니다. 그런 다음 사용자는 적절한 항목을 추가해야합니다. authors-file을 수정 한 후 이전 &lt;code&gt;git svn&lt;/code&gt; 명령을 다시 실행하면 작업이 계속됩니다.</target>
        </trans-unit>
        <trans-unit id="68c99ad12996bd9192637a1c1520fb2b24def75b" translate="yes" xml:space="preserve">
          <source>If this option is specified, for each SVN committer name that does not exist in the authors file, the given file is executed with the committer name as the first argument. The program is expected to return a single line of the form &quot;Name &amp;lt;email&amp;gt;&quot; or &quot;Name &amp;lt;&amp;gt;&quot;, which will be treated as if included in the authors file.</source>
          <target state="translated">이 옵션을 지정하면 authors 파일에 존재하지 않는 각 SVN 커미터 이름에 대해 지정된 파일이 첫 번째 인수로 커미터 이름과 함께 실행됩니다. 프로그램은 &quot;이름 &amp;lt;이메일&amp;gt;&quot;또는 &quot;이름 &amp;lt;&amp;gt;&quot;형식의 단일 행을 반환해야하며 이는 작성자 파일에 포함 된 것으로 간주됩니다.</target>
        </trans-unit>
        <trans-unit id="9706c1068d7b5bd67656b65aa296c50f3e651323" translate="yes" xml:space="preserve">
          <source>If this variable is not specified, it defaults to &lt;code&gt;normal&lt;/code&gt;. This variable can be overridden with the -u|--untracked-files option of &lt;a href=&quot;git-status&quot;&gt;git-status[1]&lt;/a&gt; and &lt;a href=&quot;git-commit&quot;&gt;git-commit[1]&lt;/a&gt;.</source>
          <target state="translated">이 변수를 지정하지 않으면 기본값은 &lt;code&gt;normal&lt;/code&gt; 입니다. 이 변수는 &lt;a href=&quot;git-status&quot;&gt;git-status [1]&lt;/a&gt; 및 &lt;a href=&quot;git-commit&quot;&gt;git-commit [1]&lt;/a&gt; 의 -u | --untracked-files 옵션으로 재정의 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="9b0cae3fed40383cf5d614f1da46a2c524e4930e" translate="yes" xml:space="preserve">
          <source>If this variable is set to &quot;1&quot;, &quot;2&quot; or &quot;true&quot; (comparison is case insensitive), trace messages will be printed to stderr.</source>
          <target state="translated">이 변수가 &quot;1&quot;, &quot;2&quot;또는 &quot;true&quot;로 설정되면 (비교는 대소 문자를 구분하지 않음) 추적 메시지가 stderr에 인쇄됩니다.</target>
        </trans-unit>
        <trans-unit id="c1357386502b4e540a41766c550326b57fc0ea56" translate="yes" xml:space="preserve">
          <source>If this variable is set to a path, non-worktree files that are normally in $GIT_DIR will be taken from this path instead. Worktree-specific files such as HEAD or index are taken from $GIT_DIR. See &lt;a href=&quot;gitrepository-layout&quot;&gt;gitrepository-layout[5]&lt;/a&gt; and &lt;a href=&quot;git-worktree&quot;&gt;git-worktree[1]&lt;/a&gt; for details. This variable has lower precedence than other path variables such as GIT_INDEX_FILE, GIT_OBJECT_DIRECTORY&amp;hellip;​</source>
          <target state="translated">이 변수가 경로로 설정되면 일반적으로 $ GIT_DIR에있는 비 작업 트리 파일이이 경로에서 가져옵니다. HEAD 또는 인덱스와 같은 워크 트리 특정 파일은 $ GIT_DIR에서 가져옵니다. 자세한 내용은 &lt;a href=&quot;gitrepository-layout&quot;&gt;gitrepository-layout [5]&lt;/a&gt; 및 &lt;a href=&quot;git-worktree&quot;&gt;git-worktree [1]&lt;/a&gt; 을 참조하십시오. 이 변수는 GIT_INDEX_FILE, GIT_OBJECT_DIRECTORY와 같은 다른 경로 변수보다 우선 순위가 낮습니다.</target>
        </trans-unit>
        <trans-unit id="8249d2ab5516fac15cd6ed908f0ba3c1a12338b5" translate="yes" xml:space="preserve">
          <source>If this variable is set, &lt;code&gt;git fetch&lt;/code&gt; and &lt;code&gt;git push&lt;/code&gt; will use the specified command instead of &lt;code&gt;ssh&lt;/code&gt; when they need to connect to a remote system. The command is in the same form as the &lt;code&gt;GIT_SSH_COMMAND&lt;/code&gt; environment variable and is overridden when the environment variable is set.</source>
          <target state="translated">이 변수가 설정되면 &lt;code&gt;git fetch&lt;/code&gt; 및 &lt;code&gt;git push&lt;/code&gt; 는 원격 시스템에 연결해야 할 때 &lt;code&gt;ssh&lt;/code&gt; 대신 지정된 명령 을 사용합니다. 명령은 &lt;code&gt;GIT_SSH_COMMAND&lt;/code&gt; 환경 변수와 동일한 형식 이며 환경 변수가 설정되면 대체됩니다.</target>
        </trans-unit>
        <trans-unit id="3af55b279f11e2f816fa42fab0cbda45b206e1ef" translate="yes" xml:space="preserve">
          <source>If timestamps of commits in the CVS repository are not stable enough to be used for ordering commits changes may show up in the wrong order.</source>
          <target state="translated">CVS 저장소의 커밋 타임 스탬프가 커밋 순서를 정하기에 충분히 안정적이지 않으면 변경 사항이 잘못된 순서로 표시 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="51615abc07df5f5fedb19397be1e475bae29e04c" translate="yes" xml:space="preserve">
          <source>If true (default), a single editor instance will be spawned to edit files you have to edit (patches when &lt;code&gt;--annotate&lt;/code&gt; is used, and the summary when &lt;code&gt;--compose&lt;/code&gt; is used). If false, files will be edited one after the other, spawning a new editor each time.</source>
          <target state="translated">(기본값) true의 경우, 하나의 에디터 인스턴스가 편집이 편집 파일에 양산 될 것입니다 (패치 때 &lt;code&gt;--annotate&lt;/code&gt; 가 사용되며, 요약하면 &lt;code&gt;--compose&lt;/code&gt; 이 사용된다). false 인 경우 파일이 하나씩 편집되어 매번 새 편집기를 생성합니다.</target>
        </trans-unit>
        <trans-unit id="6c99dc0ffc12cab74a91d9cd9821ddfe241990c4" translate="yes" xml:space="preserve">
          <source>If true prevents displaying information about repository owner.</source>
          <target state="translated">true이면 저장소 소유자에 대한 정보가 표시되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="fad7b766b28596874c184072e4308f81cec3bb8e" translate="yes" xml:space="preserve">
          <source>If true the web server started by &lt;a href=&quot;git-instaweb&quot;&gt;git-instaweb[1]&lt;/a&gt; will be bound to the local IP (127.0.0.1).</source>
          <target state="translated">true 인 경우 &lt;a href=&quot;git-instaweb&quot;&gt;git-instaweb [1]에&lt;/a&gt; 의해 시작된 웹 서버 는 로컬 IP (127.0.0.1)에 바인딩됩니다.</target>
        </trans-unit>
        <trans-unit id="24fc21f99a5940a5b287a59503e7df044758b9be" translate="yes" xml:space="preserve">
          <source>If true this repository is assumed to be &lt;code&gt;bare&lt;/code&gt; and has no working directory associated with it. If this is the case a number of commands that require a working directory will be disabled, such as &lt;a href=&quot;git-add&quot;&gt;git-add[1]&lt;/a&gt; or &lt;a href=&quot;git-merge&quot;&gt;git-merge[1]&lt;/a&gt;.</source>
          <target state="translated">true 인 경우이 저장소는 &lt;code&gt;bare&lt;/code&gt; 것으로 간주되며 연관된 작업 디렉토리가 없습니다. 이 경우 작업 디렉토리가 필요한 여러 명령 (예 : &lt;a href=&quot;git-add&quot;&gt;git-add [1]&lt;/a&gt; 또는 &lt;a href=&quot;git-merge&quot;&gt;git-merge [1])&lt;/a&gt; 이 비활성화됩니다 .</target>
        </trans-unit>
        <trans-unit id="18d14681f32fdc08f62b0e7a189d6a89008757fd" translate="yes" xml:space="preserve">
          <source>If true, &lt;code&gt;git gui blame&lt;/code&gt; uses &lt;code&gt;-C&lt;/code&gt; instead of &lt;code&gt;-C -C&lt;/code&gt; for original location detection. It makes blame significantly faster on huge repositories at the expense of less thorough copy detection.</source>
          <target state="translated">true 인 경우 &lt;code&gt;git gui blame&lt;/code&gt; 은 원래 위치 감지 에 &lt;code&gt;-C -C&lt;/code&gt; 대신 &lt;code&gt;-C&lt;/code&gt; 를 사용합니다 . 덜 철저한 사본 탐지를 희생시키면서 거대한 리포지토리에서 비난을 훨씬 빠르게 만듭니다.</target>
        </trans-unit>
        <trans-unit id="a4dc06197e1e60c2601c1eee394ecb56132cf3c4" translate="yes" xml:space="preserve">
          <source>If true, Git will avoid using lstat() calls to detect if files have changed by setting the &quot;assume-unchanged&quot; bit for those tracked files which it has updated identically in both the index and working tree.</source>
          <target state="translated">참이면 Git은 lstat () 호출을 사용하여 인덱스와 작업 트리에서 동일하게 업데이트 된 추적 된 파일에 대해 &quot;가정되지 않은&quot;비트를 설정하여 파일이 변경되었는지 감지하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="f52d8aadd1ed60dd80b38e7a96aadc385cabb931" translate="yes" xml:space="preserve">
          <source>If true, Git will warn you if the ref name you passed it is ambiguous and might match multiple refs in the repository. True by default.</source>
          <target state="translated">true 인 경우 Git은 전달한 참조 이름이 모호하고 저장소의 여러 참조와 일치 할 경우 경고합니다. 기본적으로 true입니다.</target>
        </trans-unit>
        <trans-unit id="b4f1cbcb9d6580097e1319f75786e1aefcc4a19a" translate="yes" xml:space="preserve">
          <source>If true, allow clients to use &lt;code&gt;git archive --remote&lt;/code&gt; to request any tree, whether reachable from the ref tips or not. See the discussion in the &quot;SECURITY&quot; section of &lt;a href=&quot;git-upload-archive&quot;&gt;git-upload-archive[1]&lt;/a&gt; for more details. Defaults to &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">참이면 클라이언트가 참조 팁에서 도달 가능한지 여부에 관계없이 클라이언트가 &lt;code&gt;git archive --remote&lt;/code&gt; 를 사용 하여 트리를 요청할 수 있습니다. 자세한 내용은 &lt;a href=&quot;git-upload-archive&quot;&gt;git-upload-archive [1]&lt;/a&gt; 의 &quot;보안&quot;섹션에서 논의 를 참조하십시오. 기본값은 &lt;code&gt;false&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="9577d8134a35c2d555845d35ede1972ec309a7fc" translate="yes" xml:space="preserve">
          <source>If true, enable &lt;code&gt;&amp;lt;format&amp;gt;&lt;/code&gt; for use by remote clients via &lt;a href=&quot;git-upload-archive&quot;&gt;git-upload-archive[1]&lt;/a&gt;. Defaults to false for user-defined formats, but true for the &quot;tar.gz&quot; and &quot;tgz&quot; formats.</source>
          <target state="translated">true 인 경우 &lt;a href=&quot;git-upload-archive&quot;&gt;git-upload-archive [1]을&lt;/a&gt; 통해 원격 클라이언트가 사용하도록 &lt;code&gt;&amp;lt;format&amp;gt;&lt;/code&gt; 을 활성화하십시오 . 사용자 정의 형식의 경우 기본값은 false이지만 &quot;tar.gz&quot;및 &quot;tgz&quot;형식의 경우 true입니다.</target>
        </trans-unit>
        <trans-unit id="5f15956c2db32b4b1b45dac474661942b8aa7008" translate="yes" xml:space="preserve">
          <source>If true, fetch will automatically behave as if the &lt;code&gt;--prune&lt;/code&gt; option was given on the command line. See also &lt;code&gt;remote.&amp;lt;name&amp;gt;.prune&lt;/code&gt; and the PRUNING section of &lt;a href=&quot;git-fetch&quot;&gt;git-fetch[1]&lt;/a&gt;.</source>
          <target state="translated">true이면 fetch는 &lt;code&gt;--prune&lt;/code&gt; 옵션이 명령 줄에 제공된 것처럼 자동으로 작동합니다 . &lt;code&gt;remote.&amp;lt;name&amp;gt;.prune&lt;/code&gt; 및 &lt;a href=&quot;git-fetch&quot;&gt;git-fetch [1]&lt;/a&gt; 의 PRUNING 섹션 도 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="7d985f4709f0d26edc0babef707e65f833d349aa" translate="yes" xml:space="preserve">
          <source>If true, fetch will automatically behave as if the &lt;code&gt;refs/tags/*:refs/tags/*&lt;/code&gt; refspec was provided when pruning, if not set already. This allows for setting both this option and &lt;code&gt;fetch.prune&lt;/code&gt; to maintain a 1=1 mapping to upstream refs. See also &lt;code&gt;remote.&amp;lt;name&amp;gt;.pruneTags&lt;/code&gt; and the PRUNING section of &lt;a href=&quot;git-fetch&quot;&gt;git-fetch[1]&lt;/a&gt;.</source>
          <target state="translated">true 인 경우, 가져 오기는 정리되지 않은 경우 &lt;code&gt;refs/tags/*:refs/tags/*&lt;/code&gt; refspec이 제공된 것처럼 자동으로 작동합니다 . 이를 통해이 옵션과 &lt;code&gt;fetch.prune&lt;/code&gt; 을 설정 하여 업스트림 참조에 1 = 1 매핑을 유지할 수 있습니다. &lt;code&gt;remote.&amp;lt;name&amp;gt;.pruneTags&lt;/code&gt; 및 &lt;a href=&quot;git-fetch&quot;&gt;git-fetch [1]&lt;/a&gt; 의 PRUNING 섹션 도 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="2de6ae2b37da0c5dc299e33fe86fea1c6d9d4a0f" translate="yes" xml:space="preserve">
          <source>If true, git-am will call git-mailsplit for patches in mbox format with parameter &lt;code&gt;--keep-cr&lt;/code&gt;. In this case git-mailsplit will not remove &lt;code&gt;\r&lt;/code&gt; from lines ending with &lt;code&gt;\r\n&lt;/code&gt;. Can be overridden by giving &lt;code&gt;--no-keep-cr&lt;/code&gt; from the command line. See &lt;a href=&quot;git-am&quot;&gt;git-am[1]&lt;/a&gt;, &lt;a href=&quot;git-mailsplit&quot;&gt;git-mailsplit[1]&lt;/a&gt;.</source>
          <target state="translated">true 인 경우 git-am은 매개 변수 &lt;code&gt;--keep-cr&lt;/code&gt; 을 사용하여 mbox 형식의 패치에 대해 git-mailsplit을 호출 합니다. 이 경우 git-mailsplit은 &lt;code&gt;\r\n&lt;/code&gt; 끝나는 줄에서 &lt;code&gt;\r&lt;/code&gt; 을 제거하지 않습니다 . 명령 줄에서 &lt;code&gt;--no-keep-cr&lt;/code&gt; 을 지정하여 재정의 할 수 있습니다 . 참조 &lt;a href=&quot;git-am&quot;&gt;자식-오전 [1]&lt;/a&gt; , &lt;a href=&quot;git-mailsplit&quot;&gt;자식-mailsplit [1]&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="e94bf962607289b1694c70432d3fab451c61737d" translate="yes" xml:space="preserve">
          <source>If true, makes &lt;a href=&quot;git-log&quot;&gt;git-log[1]&lt;/a&gt;, &lt;a href=&quot;git-show&quot;&gt;git-show[1]&lt;/a&gt;, and &lt;a href=&quot;git-whatchanged&quot;&gt;git-whatchanged[1]&lt;/a&gt; assume &lt;code&gt;--abbrev-commit&lt;/code&gt;. You may override this option with &lt;code&gt;--no-abbrev-commit&lt;/code&gt;.</source>
          <target state="translated">true 인 경우 &lt;a href=&quot;git-log&quot;&gt;git-log [1]&lt;/a&gt; , &lt;a href=&quot;git-show&quot;&gt;git-show [1]&lt;/a&gt; 및 &lt;a href=&quot;git-whatchanged&quot;&gt;git-whatchanged [1]가 &lt;/a&gt; &lt;code&gt;--abbrev-commit&lt;/code&gt; 을 가정 합니다. 이 옵션을 &lt;code&gt;--no-abbrev-commit&lt;/code&gt; 으로 재정의 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="f7c96ef3a79b38b8c56dee4db799ed4d172ce90c" translate="yes" xml:space="preserve">
          <source>If true, makes &lt;a href=&quot;git-log&quot;&gt;git-log[1]&lt;/a&gt;, &lt;a href=&quot;git-show&quot;&gt;git-show[1]&lt;/a&gt;, and &lt;a href=&quot;git-whatchanged&quot;&gt;git-whatchanged[1]&lt;/a&gt; assume &lt;code&gt;--show-signature&lt;/code&gt;.</source>
          <target state="translated">true 인 경우 &lt;a href=&quot;git-log&quot;&gt;git-log [1]&lt;/a&gt; , &lt;a href=&quot;git-show&quot;&gt;git-show [1]&lt;/a&gt; 및 &lt;a href=&quot;git-whatchanged&quot;&gt;git-whatchanged [1]&lt;/a&gt; 이 &lt;code&gt;--show-signature&lt;/code&gt; 로 가정 합니다 .</target>
        </trans-unit>
        <trans-unit id="6cb33eaf81fb27f3c3d3ba0e81d6670ba0d0bfaf" translate="yes" xml:space="preserve">
          <source>If true, makes &lt;a href=&quot;git-log&quot;&gt;git-log[1]&lt;/a&gt;, &lt;a href=&quot;git-show&quot;&gt;git-show[1]&lt;/a&gt;, and &lt;a href=&quot;git-whatchanged&quot;&gt;git-whatchanged[1]&lt;/a&gt; assume &lt;code&gt;--use-mailmap&lt;/code&gt;, otherwise assume &lt;code&gt;--no-use-mailmap&lt;/code&gt;. True by default.</source>
          <target state="translated">true이면 &lt;a href=&quot;git-log&quot;&gt;git-log [1]&lt;/a&gt; , &lt;a href=&quot;git-show&quot;&gt;git-show [1]&lt;/a&gt; 및 &lt;a href=&quot;git-whatchanged&quot;&gt;git-whatchanged [1]&lt;/a&gt; 이 &lt;code&gt;--use-mailmap&lt;/code&gt; 을 , 그렇지 않으면 &lt;code&gt;--no-use-mailmap&lt;/code&gt; 을 가정 합니다. 기본적으로 true입니다.</target>
        </trans-unit>
        <trans-unit id="672cef13127670a717c7a3aa65681a15ad776d1b" translate="yes" xml:space="preserve">
          <source>If true, makes &lt;a href=&quot;git-mailinfo&quot;&gt;git-mailinfo[1]&lt;/a&gt; (and therefore &lt;a href=&quot;git-am&quot;&gt;git-am[1]&lt;/a&gt;) act by default as if the --scissors option was provided on the command-line. When active, this features removes everything from the message body before a scissors line (i.e. consisting mainly of &quot;&amp;gt;8&quot;, &quot;8&amp;lt;&quot; and &quot;-&quot;).</source>
          <target state="translated">true 인 경우 --scissors 옵션이 명령 행에 제공된 것처럼 &lt;a href=&quot;git-mailinfo&quot;&gt;git-mailinfo [1]&lt;/a&gt; (및 &lt;a href=&quot;git-am&quot;&gt;git-am [1]&lt;/a&gt; )가 기본적으로 작동합니다. 활성화되면이 기능은 가위 선 이전의 메시지 본문에서 모든 것을 제거합니다 (예 : 주로 &quot;&amp;gt; 8&quot;, &quot;8 &amp;lt;&quot;및 &quot;-&quot;로 구성).</target>
        </trans-unit>
        <trans-unit id="d25b510a17b04a17cfbdc40d0999d1586f4d5f91" translate="yes" xml:space="preserve">
          <source>If true, makes Git check if converting &lt;code&gt;CRLF&lt;/code&gt; is reversible when end-of-line conversion is active. Git will verify if a command modifies a file in the work tree either directly or indirectly. For example, committing a file followed by checking out the same file should yield the original file in the work tree. If this is not the case for the current setting of &lt;code&gt;core.autocrlf&lt;/code&gt;, Git will reject the file. The variable can be set to &quot;warn&quot;, in which case Git will only warn about an irreversible conversion but continue the operation.</source>
          <target state="translated">참이면 줄 끝 변환이 활성화되어있을 때 &lt;code&gt;CRLF&lt;/code&gt; 변환 이 되돌릴 수 있는지 Git에서 확인합니다 . Git은 명령이 작업 트리에서 파일을 직접 또는 간접적으로 수정하는지 확인합니다. 예를 들어, 파일을 커밋 한 다음 동일한 파일을 체크 아웃하면 작업 트리에 원본 파일이 생성됩니다. 이것이 &lt;code&gt;core.autocrlf&lt;/code&gt; 의 현재 설정이 아닌 경우 Git은 파일을 거부합니다. 변수를 &quot;경고&quot;로 설정할 수 있습니다.이 경우 Git은 되돌릴 수없는 변환에 대해서만 경고하지만 작업을 계속합니다.</target>
        </trans-unit>
        <trans-unit id="3a6f979740fe111373346b7083b54b9e059af003" translate="yes" xml:space="preserve">
          <source>If true, omit the column with date of the most current commit on the projects list page. It can save a bit of I/O and a fork per repository.</source>
          <target state="translated">true 인 경우 프로젝트 목록 페이지에서 최신 커밋 날짜가있는 열을 생략하십시오. 리포지토리 당 약간의 I / O 및 포크를 저장할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9e101a02df349b50a39b60288665a643391bcf24" translate="yes" xml:space="preserve">
          <source>If true, pushing to this remote will automatically behave as if the &lt;code&gt;--mirror&lt;/code&gt; option was given on the command line.</source>
          <target state="translated">true 인 경우이 리모콘을 누르면 &lt;code&gt;--mirror&lt;/code&gt; 옵션이 명령 행에 제공된 것처럼 자동으로 작동합니다 .</target>
        </trans-unit>
        <trans-unit id="561edb27b58ccdfdecb1aae75865de22935f3cd3" translate="yes" xml:space="preserve">
          <source>If true, some gitweb features are disabled to prevent content in repositories from launching cross-site scripting (XSS) attacks. Set this to true if you don&amp;rsquo;t trust the content of your repositories. False by default (set to 0).</source>
          <target state="translated">true 인 경우 리포지토리의 콘텐츠가 XSS (Cross-Site Scripting) 공격을 시작하지 못하도록 일부 gitweb 기능이 비활성화됩니다. 리포지토리의 내용을 신뢰할 수없는 경우이를 true로 설정하십시오. 기본적으로 False입니다 (0으로 설정).</target>
        </trans-unit>
        <trans-unit id="698e5f4a0ab76eb97600c890fa9adac3c5e93fa4" translate="yes" xml:space="preserve">
          <source>If true, the initial commit will be shown as a big creation event. This is equivalent to a diff against an empty tree. Tools like &lt;a href=&quot;git-log&quot;&gt;git-log[1]&lt;/a&gt; or &lt;a href=&quot;git-whatchanged&quot;&gt;git-whatchanged[1]&lt;/a&gt;, which normally hide the root commit will now show it. True by default.</source>
          <target state="translated">true 인 경우 초기 커밋이 큰 생성 이벤트로 표시됩니다. 이것은 빈 트리에 대한 diff와 같습니다. 일반적으로 루트 커밋을 숨기는 &lt;a href=&quot;git-log&quot;&gt;git-log [1]&lt;/a&gt; 또는 &lt;a href=&quot;git-whatchanged&quot;&gt;git-whatchanged [1]&lt;/a&gt; 과 같은 도구 가 이제이를 표시합니다. 기본적으로 true입니다.</target>
        </trans-unit>
        <trans-unit id="7f4771e5273a3a0e51423699c29e2caf790623f9" translate="yes" xml:space="preserve">
          <source>If true, the server will look up the end-of-line conversion attributes for files to determine the &lt;code&gt;-k&lt;/code&gt; modes to use. If the attributes force Git to treat a file as text, the &lt;code&gt;-k&lt;/code&gt; mode will be left blank so CVS clients will treat it as text. If they suppress text conversion, the file will be set with &lt;code&gt;-kb&lt;/code&gt; mode, which suppresses any newline munging the client might otherwise do. If the attributes do not allow the file type to be determined, then &lt;code&gt;gitcvs.allBinary&lt;/code&gt; is used. See &lt;a href=&quot;gitattributes&quot;&gt;gitattributes[5]&lt;/a&gt;.</source>
          <target state="translated">true 인 경우, 서버는 사용할 &lt;code&gt;-k&lt;/code&gt; 모드를 결정하기 위해 파일의 라인 끝 변환 속성을 찾습니다 . 속성으로 인해 Git이 파일을 텍스트로 취급하면, &lt;code&gt;-k&lt;/code&gt; 모드는 비워져 CVS 클라이언트는 파일을 텍스트 로 취급합니다. 텍스트 변환을 억제하면 파일이 &lt;code&gt;-kb&lt;/code&gt; 모드 로 설정되어 클라이언트가 수행 할 수있는 줄 바꿈을 억제합니다. 속성으로 파일 유형을 결정할 수 &lt;code&gt;gitcvs.allBinary&lt;/code&gt; 가 사용됩니다. &lt;a href=&quot;gitattributes&quot;&gt;gitattributes [5]를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="36ac6e641c359be495ff334484c92173e0b7c3c8" translate="yes" xml:space="preserve">
          <source>If true, the split-index feature of the index will be used. See &lt;a href=&quot;git-update-index&quot;&gt;git-update-index[1]&lt;/a&gt;. False by default.</source>
          <target state="translated">참이면 인덱스의 분할 인덱스 기능이 사용됩니다. &lt;a href=&quot;git-update-index&quot;&gt;git-update-index [1]를&lt;/a&gt; 참조하십시오 . 기본적으로 False입니다.</target>
        </trans-unit>
        <trans-unit id="521397cd2bc3f328c7b75df2807813cd34103bfb" translate="yes" xml:space="preserve">
          <source>If true, then gc will rewrite the commit-graph file when &lt;a href=&quot;git-gc&quot;&gt;git-gc[1]&lt;/a&gt; is run. When using &lt;code&gt;git gc --auto&lt;/code&gt; the commit-graph will be updated if housekeeping is required. Default is true. See &lt;a href=&quot;git-commit-graph&quot;&gt;git-commit-graph[1]&lt;/a&gt; for details.</source>
          <target state="translated">true이면, &lt;a href=&quot;git-gc&quot;&gt;git-gc [1]&lt;/a&gt; 이 실행될 때 gc는 commit-graph 파일을 다시 작성합니다 . &lt;code&gt;git gc --auto&lt;/code&gt; 를 사용할 때 커밋 그래프는 하우스 키핑이 필요한 경우 업데이트됩니다. 기본값은 true입니다. 자세한 내용은 &lt;a href=&quot;git-commit-graph&quot;&gt;git-commit-graph [1]&lt;/a&gt; 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="902fdcf00401d2e7de222ff42ce846a756cbb163" translate="yes" xml:space="preserve">
          <source>If true, then git will read the commit-graph file (if it exists) to parse the graph structure of commits. Defaults to true. See &lt;a href=&quot;git-commit-graph&quot;&gt;git-commit-graph[1]&lt;/a&gt; for more information.</source>
          <target state="translated">true이면, git은 commit-graph 파일 (있는 경우)을 읽어 commit의 그래프 구조를 구문 분석합니다. 기본값은 true입니다. 자세한 내용은 &lt;a href=&quot;git-commit-graph&quot;&gt;git-commit-graph [1]&lt;/a&gt; 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="615bfb2827e0f7022b5822b60fa7f8c63365efe6" translate="yes" xml:space="preserve">
          <source>If true, this is equivalent to the --verify-signatures command line option. See &lt;a href=&quot;git-merge&quot;&gt;git-merge[1]&lt;/a&gt; for details.</source>
          <target state="translated">true 인 경우 --verify-signatures 명령 줄 옵션과 같습니다. 자세한 내용은 &lt;a href=&quot;git-merge&quot;&gt;git-merge [1]&lt;/a&gt; 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="5ab6fd64e80cf040c0dbc59c3bda45e3cb1c29b3" translate="yes" xml:space="preserve">
          <source>If true, this remote will be skipped by default when updating using &lt;a href=&quot;git-fetch&quot;&gt;git-fetch[1]&lt;/a&gt; or the &lt;code&gt;update&lt;/code&gt; subcommand of &lt;a href=&quot;git-remote&quot;&gt;git-remote[1]&lt;/a&gt;.</source>
          <target state="translated">true 인 경우 &lt;a href=&quot;git-fetch&quot;&gt;git-fetch [1]&lt;/a&gt; 또는 &lt;a href=&quot;git-remote&quot;&gt;git-remote [1]&lt;/a&gt; 의 &lt;code&gt;update&lt;/code&gt; 하위 명령을 사용하여 업데이트 할 때이 원격은 기본적으로 건너 뜁니다 .</target>
        </trans-unit>
        <trans-unit id="537153cdd9a230b7ef7748cee5c002a80aec5646" translate="yes" xml:space="preserve">
          <source>If we compute the following non optimal function on it:</source>
          <target state="translated">다음과 같은 비 최적 함수를 계산하면 :</target>
        </trans-unit>
        <trans-unit id="b2bbf437e467ca2cfec5d122277b398062cce56a" translate="yes" xml:space="preserve">
          <source>If we examined all this history together in one repository, it will look like:</source>
          <target state="translated">하나의 저장소에서이 모든 히스토리를 함께 조사하면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="f77fa3523026c17c64002e6f77dd7e18ad8c7cf7" translate="yes" xml:space="preserve">
          <source>If we have moved away from commit &lt;code&gt;f&lt;/code&gt;, then we must first recover its object name (typically by using git reflog), and then we can create a reference to it. For example, to see the last two commits to which &lt;code&gt;HEAD&lt;/code&gt; referred, we can use either of these commands:</source>
          <target state="translated">commit &lt;code&gt;f&lt;/code&gt; 에서 멀어지면 먼저 객체 이름을 복구해야하며 (일반적으로 git reflog를 사용하여) 객체에 대한 참조를 만들 수 있습니다. 예를 들어 &lt;code&gt;HEAD&lt;/code&gt; 가 참조한 마지막 두 커밋을 보려면 다음 명령 중 하나를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1d5fb2a96e98dbf044763df4f4d84c289b1a7a1e" translate="yes" xml:space="preserve">
          <source>If we look at the way commits are created under the cover, we&amp;rsquo;ll see that there are more flexible ways creating commits.</source>
          <target state="translated">커버 아래에서 커밋이 생성되는 방식을 살펴보면 커밋을 만드는 더 유연한 방법이 있음을 알 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2a7aed1833634138d2979858dc472c551054c3f5" translate="yes" xml:space="preserve">
          <source>If we need to talk about a particular commit, the character &quot;o&quot; may be replaced with another letter or number.</source>
          <target state="translated">특정 커밋에 대해 이야기해야 할 경우 문자 &quot;o&quot;는 다른 문자 나 숫자로 대체 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="73117dc442919d58c7658111f0e65fc3ffc2d92d" translate="yes" xml:space="preserve">
          <source>If width is &lt;code&gt;0&lt;/code&gt; (zero) then indent the lines of the output without wrapping them.</source>
          <target state="translated">너비가 &lt;code&gt;0&lt;/code&gt; 이면 출력 줄을 줄 바꿈없이 들여 씁니다.</target>
        </trans-unit>
        <trans-unit id="a0f8f4ea612137fd1324a3c99aa8cca8319d30d8" translate="yes" xml:space="preserve">
          <source>If you add a &lt;code&gt;+&lt;/code&gt; (plus sign) after &lt;code&gt;%&lt;/code&gt; of a placeholder, a line-feed is inserted immediately before the expansion if and only if the placeholder expands to a non-empty string.</source>
          <target state="translated">플레이스 홀더의 &lt;code&gt;%&lt;/code&gt; 뒤에 &lt;code&gt;+&lt;/code&gt; (더하기 부호) 를 추가 하면 플레이스 홀더가 비어 있지 않은 문자열로 확장되는 경우에만 확장 직전에 라인 피드가 삽입됩니다.</target>
        </trans-unit>
        <trans-unit id="f83e564943919127dff3b2d8ad2099402ce321cb" translate="yes" xml:space="preserve">
          <source>If you add a &lt;code&gt;-&lt;/code&gt; (minus sign) after &lt;code&gt;%&lt;/code&gt; of a placeholder, all consecutive line-feeds immediately preceding the expansion are deleted if and only if the placeholder expands to an empty string.</source>
          <target state="translated">자리 표시 자 &lt;code&gt;%&lt;/code&gt; 뒤에 &lt;code&gt;-&lt;/code&gt; (빼기 부호) 를 추가 하면 자리 표시자가 빈 문자열로 확장되는 경우에만 확장 바로 앞의 모든 연속 줄 바꿈이 삭제됩니다.</target>
        </trans-unit>
        <trans-unit id="a78fb3b12f14b3649d1e2f03162a9771701e268a" translate="yes" xml:space="preserve">
          <source>If you add a ` ` (space) after &lt;code&gt;%&lt;/code&gt; of a placeholder, a space is inserted immediately before the expansion if and only if the placeholder expands to a non-empty string.</source>
          <target state="translated">자리 표시 자 &lt;code&gt;%&lt;/code&gt; 뒤에``(공백)를 추가 하면 자리 표시자가 비어 있지 않은 문자열로 확장되는 경우에만 확장 바로 앞에 공백이 삽입됩니다.</target>
        </trans-unit>
        <trans-unit id="2c694abd299e141b455acf195b0e2c24045c8fb9" translate="yes" xml:space="preserve">
          <source>If you allow overriding for the snapshot feature, you can specify which snapshot formats are globally disabled. You can also add any command-line options you want (such as setting the compression level). For instance, you can disable Zip compressed snapshots and set &lt;strong&gt;gzip&lt;/strong&gt;(1) to run at level 6 by adding the following lines to your gitweb configuration file:</source>
          <target state="translated">스냅 샷 기능에 대한 재정의를 허용하면 전역 적으로 비활성화 할 스냅 샷 형식을 지정할 수 있습니다. 압축 수준 설정과 같은 원하는 명령 줄 옵션을 추가 할 수도 있습니다. 예를 들어, gitweb 구성 파일에 다음 행을 추가하여 Zip 압축 스냅 샷을 비활성화하고 &lt;strong&gt;gzip&lt;/strong&gt; (1)을 레벨 6에서 실행하도록 설정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1eda80bb2b9aeb620d19886733f7a0a33613b07f" translate="yes" xml:space="preserve">
          <source>If you already use &lt;code&gt;mod_userdir&lt;/code&gt; in your virtual host or you don&amp;rsquo;t want to use the '~' as first character, just comment or remove the second rewrite rule, and uncomment one of the following according to what you want.</source>
          <target state="translated">가상 호스트에서 이미 &lt;code&gt;mod_userdir&lt;/code&gt; 을 사용하거나 '~'를 첫 문자로 사용하지 않으려면 두 번째 다시 쓰기 규칙에 주석을 달거나 제거하고 원하는 내용에 따라 다음 중 하나의 주석을 해제하십시오.</target>
        </trans-unit>
        <trans-unit id="28aab4433d981c882862a14d41ff2a1b6ecf68f5" translate="yes" xml:space="preserve">
          <source>If you also want to see complete diffs at each step, use</source>
          <target state="translated">각 단계에서 완전한 diff를 보려면 다음을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="cc8e02bd7d5fd8efba31a3f28960e44c003964ed" translate="yes" xml:space="preserve">
          <source>If you and the maintainer both have accounts on the same machine, then you can just pull changes from each other&amp;rsquo;s repositories directly; commands that accept repository URLs as arguments will also accept a local directory name:</source>
          <target state="translated">관리자와 관리자가 모두 같은 컴퓨터에 계정을 가지고 있다면 서로의 리포지토리에서 직접 변경 사항을 가져올 수 있습니다. 저장소 URL을 인수로 허용하는 명령은 로컬 디렉토리 이름도 허용합니다.</target>
        </trans-unit>
        <trans-unit id="41ebdd5e935074b399d696e8dc1f4204152e3f63" translate="yes" xml:space="preserve">
          <source>If you are a contributor that sends changes upstream in the form of emails, you should use topic branches as usual (see above). Then use &lt;a href=&quot;git-format-patch&quot;&gt;git-format-patch[1]&lt;/a&gt; to generate the corresponding emails (highly recommended over manually formatting them because it makes the maintainer&amp;rsquo;s life easier).</source>
          <target state="translated">변경 사항을 전자 메일 형식으로 업스트림으로 보내는 기고자 인 경우 평소와 같이 주제 분기를 사용해야합니다 (위 참조). 그런 다음 &lt;a href=&quot;git-format-patch&quot;&gt;git-format-patch [1]&lt;/a&gt; 를 사용하여 해당 이메일을 생성하십시오 (관리자가보다 쉽게 ​​사용할 수 있으므로 수동으로 포맷하는 것보다 강력하게 권장 됨).</target>
        </trans-unit>
        <trans-unit id="f7586aada4dc4dabc26450bca6e988967f6c8334" translate="yes" xml:space="preserve">
          <source>If you are a maintainer and would like to merge other people&amp;rsquo;s topic branches to the integration branches, they will typically send a request to do so by mail. Such a request looks like</source>
          <target state="translated">관리자 인 경우 다른 사람의 주제 분기를 통합 분기에 병합하려는 경우 일반적으로 우편으로 요청을 보냅니다. 이러한 요청은 다음과 같습니다</target>
        </trans-unit>
        <trans-unit id="6a4170b1f048a116a2a20a0123a6634648180f67" translate="yes" xml:space="preserve">
          <source>If you are coming from a CVS background, the style of cooperation suggested in the previous section may be new to you. You do not have to worry. Git supports the &quot;shared public repository&quot; style of cooperation you are probably more familiar with as well.</source>
          <target state="translated">CVS 배경에서 온 경우 이전 섹션에서 제안한 협력 스타일이 새로운 것일 수 있습니다. 당신은 걱정할 필요가 없습니다. Git은 &quot;공유 공용 저장소&quot;스타일의 협력 방식을 지원합니다.</target>
        </trans-unit>
        <trans-unit id="d473d9569ed7194445a9c66a5a376371d037be9a" translate="yes" xml:space="preserve">
          <source>If you are creating a branch that you want to switch to immediately, it is easier to use the &quot;git switch&quot; command with its &lt;code&gt;-c&lt;/code&gt; option to do the same thing with a single command.</source>
          <target state="translated">즉시 전환하려는 분기를 작성하는 경우 &quot;git switch&quot;명령을 &lt;code&gt;-c&lt;/code&gt; 옵션과 함께 사용하여 단일 명령으로 동일한 작업을 수행하는 것이 더 쉽습니다 .</target>
        </trans-unit>
        <trans-unit id="882d5e43cce8c196ac8e463999e712ea9e114942" translate="yes" xml:space="preserve">
          <source>If you are following somebody else&amp;rsquo;s tree, you are most likely using remote-tracking branches (eg. &lt;code&gt;refs/remotes/origin/master&lt;/code&gt;). You usually want the tags from the other end.</source>
          <target state="translated">다른 사람의 나무를 따르는 경우 원격 추적 분기를 사용하는 것 같습니다 (예 : &lt;code&gt;refs/remotes/origin/master&lt;/code&gt; ). 일반적으로 다른 쪽 끝의 태그를 원합니다.</target>
        </trans-unit>
        <trans-unit id="0f51d0b61f348c2beb156a534ba33bcb5f141385" translate="yes" xml:space="preserve">
          <source>If you are going to offer CVS access via pserver, add a line in /etc/inetd.conf like</source>
          <target state="translated">pserver를 통해 CVS 액세스를 제공하려면 다음과 같이 /etc/inetd.conf에 행을 추가하십시오.</target>
        </trans-unit>
        <trans-unit id="e1c58ac4057b121c58f1f5681f07adc3f2f06c66" translate="yes" xml:space="preserve">
          <source>If you are instead primarily interested in using Git to fetch a project, for example, to test the latest version, you may prefer to start with the first two chapters of &lt;a href=&quot;user-manual&quot;&gt;The Git User&amp;rsquo;s Manual&lt;/a&gt;.</source>
          <target state="translated">대신 Git을 사용하여 프로젝트를 가져 와서 최신 버전을 테스트하는 데 주로 관심이있는 경우 &lt;a href=&quot;user-manual&quot;&gt;Git 사용자 매뉴얼&lt;/a&gt; 의 처음 두 장으로 시작하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="9ce35cf81da423ef90a67288a1d702b7e25d4c6b" translate="yes" xml:space="preserve">
          <source>If you are interested in more details of the revision walking process, just have a look at the first implementation of &lt;code&gt;cmd_log()&lt;/code&gt;; call &lt;code&gt;git show v1.3.0&lt;sub&gt;155^2&lt;/sub&gt;4&lt;/code&gt; and scroll down to that function (note that you no longer need to call &lt;code&gt;setup_pager()&lt;/code&gt; directly).</source>
          <target state="translated">수정 보행 프로세스에 대한 자세한 내용을 &lt;code&gt;cmd_log()&lt;/code&gt; 의 첫 번째 구현을 살펴보십시오 . &lt;code&gt;git show v1.3.0&lt;sub&gt;155^2&lt;/sub&gt;4&lt;/code&gt; 호출 하고 해당 함수로 스크롤하십시오 (더 이상 &lt;code&gt;setup_pager()&lt;/code&gt; 직접 호출 할 필요는 없습니다 ).</target>
        </trans-unit>
        <trans-unit id="a5b0f41c084141a75721908d0d5d7971792ac89f" translate="yes" xml:space="preserve">
          <source>If you are not absolutely sure that the intermediate revisions are consistent (they compile, pass the testsuite, etc.) you should use &lt;code&gt;git stash&lt;/code&gt; to stash away the not-yet-committed changes after each commit, test, and amend the commit if fixes are necessary.</source>
          <target state="translated">중간 개정이 일관성이 있는지 확실하지 않은 경우 (컴파일, 테스트 슈트 등 전달) &lt;code&gt;git stash&lt;/code&gt; 를 사용 하여 각 커밋, 테스트 후 수정되지 않은 경우 아직 커밋되지 않은 변경 사항을 제거해야합니다. 필요합니다.</target>
        </trans-unit>
        <trans-unit id="f188b17d328d7a9e1b61bcc0d2e0defbbf399561" translate="yes" xml:space="preserve">
          <source>If you are only interested in changes of the currently initialized submodules with respect to the commit recorded in the index or the HEAD, &lt;a href=&quot;git-status&quot;&gt;git-status[1]&lt;/a&gt; and &lt;a href=&quot;git-diff&quot;&gt;git-diff[1]&lt;/a&gt; will provide that information too (and can also report changes to a submodule&amp;rsquo;s work tree).</source>
          <target state="translated">인덱스 또는 HEAD에 기록 된 커밋과 관련하여 현재 초기화 된 서브 모듈의 변경에만 관심이있는 경우 &lt;a href=&quot;git-status&quot;&gt;git-status [1]&lt;/a&gt; 및 &lt;a href=&quot;git-diff&quot;&gt;git-diff [1]&lt;/a&gt; 도 해당 정보를 제공합니다 (또한 변경 사항을 하위 모듈의 작업 트리).</target>
        </trans-unit>
        <trans-unit id="9fb9a58a453e5ac1de19a98e53575241a40d1da0" translate="yes" xml:space="preserve">
          <source>If you are paranoid, running &lt;code&gt;git verify-pack&lt;/code&gt; command would detect if you have a corrupt pack, but do not worry too much. Our programs are always perfect ;-).</source>
          <target state="translated">편집증이라면 &lt;code&gt;git verify-pack&lt;/code&gt; 명령을 실행 하면 손상된 팩이 있는지 감지하지만 너무 걱정하지 마십시오. 우리의 프로그램은 항상 완벽합니다 ;-).</target>
        </trans-unit>
        <trans-unit id="277e03057ecd44d387d6f501d21982d9ff59224b" translate="yes" xml:space="preserve">
          <source>If you are repacking very old imported data (e.g. older than the last year), consider expending some extra CPU time and supplying --window=50 (or higher) when you run &lt;code&gt;git repack&lt;/code&gt;. This will take longer, but will also produce a smaller packfile. You only need to expend the effort once, and everyone using your project will benefit from the smaller repository.</source>
          <target state="translated">아주 오래된 가져온 데이터를 다시 포장하는 경우 (예 : 작년보다 오래된) &lt;code&gt;git repack&lt;/code&gt; 을 실행할 때 추가 CPU 시간을 연장하고 --window = 50 (또는 그 이상)을 제공하는 것을 고려하십시오 . 시간이 오래 걸리지 만 더 작은 팩 파일이 생성됩니다. 한 번만 노력하면되며 프로젝트를 사용하는 모든 사람은 소규모 저장소를 활용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c500814f6020ec6c3d1c5a9b455910ea7fc36da1" translate="yes" xml:space="preserve">
          <source>If you are using &quot;git bisect run&quot;, you can use the same manual fix up as above, and then start another &quot;git bisect run&quot; in the special branch. Or as the &quot;git bisect&quot; man page says, the script passed to &quot;git bisect run&quot; can apply a patch before it compiles and test the software &lt;a href=&quot;#8&quot;&gt;[8]&lt;/a&gt;. The patch should turn a current untestable commits into a testable one. So the testing will result in &quot;good&quot; or &quot;bad&quot; and &quot;git bisect&quot; will be able to find the first bad commit. And the script should not forget to remove the patch once the testing is done before exiting from the script.</source>
          <target state="translated">&quot;git bisect run&quot;을 사용하는 경우 위와 동일한 수동 수정을 사용한 다음 특수 분기에서 다른 &quot;git bisect run&quot;을 시작할 수 있습니다. 또는 &quot;git bisect&quot;매뉴얼 페이지에서 알 수 있듯이 &quot;git bisect run&quot;에 전달 된 스크립트는 소프트웨어를 컴파일하고 테스트하기 전에 패치를 적용 할 수 있습니다 &lt;a href=&quot;#8&quot;&gt;[8]&lt;/a&gt; . 패치는 현재 테스트 할 수없는 커밋을 테스트 가능한 커밋으로 바꿔야합니다. 따라서 테스트 결과 &quot;good&quot;또는 &quot;bad&quot;가 발생하고 &quot;git bisect&quot;는 첫 번째 잘못된 커밋을 찾을 수 있습니다. 스크립트는 스크립트에서 나가기 전에 테스트가 끝나면 패치를 제거하는 것을 잊지 않아야합니다.</target>
        </trans-unit>
        <trans-unit id="c6c0585fbbb0e19d850e67091effac179b4cf010" translate="yes" xml:space="preserve">
          <source>If you blow the index away entirely, you generally haven&amp;rsquo;t lost any information as long as you have the name of the tree that it described.</source>
          <target state="translated">색인을 완전히 없애 버린 경우 일반적으로 설명 된 트리의 이름이있는 한 정보가 손실되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="2d2eeeb68a563ca60a2c585f75afbad9b4a5940e" translate="yes" xml:space="preserve">
          <source>If you both have a test suite and use git bisect, then it becomes less important to check that all tests pass after each commit. Though of course it is probably a good idea to have some checks to avoid breaking too many things because it could make bisecting other bugs more difficult.</source>
          <target state="translated">둘 다 테스트 스위트가 있고 git bisect를 사용하는 경우 각 커밋 후에 모든 테스트가 통과하는지 확인하는 것이 중요하지 않습니다. 물론 너무 많은 것들을 깨뜨리지 않기 위해 몇 가지 검사를하는 것이 좋은 생각 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7c966eb4fc191c72371d7ddd65b21062f03ccb57" translate="yes" xml:space="preserve">
          <source>If you can do that, you can now recreate the missing object with</source>
          <target state="translated">그렇게 할 수 있다면 다음과 같이 누락 된 개체를 다시 만들 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5c6e6ccfdc26bd491d9ed428be6d535f807a44d7" translate="yes" xml:space="preserve">
          <source>If you choose to wait for the repack, don&amp;rsquo;t try to run benchmarks or performance tests until repacking is completed. fast-import outputs suboptimal packfiles that are simply never seen in real use situations.</source>
          <target state="translated">재 포장 대기를 선택한 경우 재 포장이 완료 될 때까지 벤치 마크 또는 성능 테스트를 실행하지 마십시오. 빠른 가져 오기는 실제 사용 상황에서는 절대 볼 수없는 차선책 팩 파일을 출력합니다.</target>
        </trans-unit>
        <trans-unit id="db9a66177c2b117d0740a2ed1a511dcc1bea6811" translate="yes" xml:space="preserve">
          <source>If you decide that you&amp;rsquo;d rather see version 2.6.17, you can modify the current branch to point at v2.6.17 instead, with</source>
          <target state="translated">버전 2.6.17을보고자한다면 대신 현재 분기를 v2.6.17을 가리 키도록 수정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c943de9e92fabf055b174eed9b10ced62cf6d401" translate="yes" xml:space="preserve">
          <source>If you decide you want the history back, you can always create a new reference pointing to it, for example, a new branch:</source>
          <target state="translated">히스토리를 다시 사용하기로 결정한 경우 언제든지 새 분기와 같이이를 가리키는 새 참조를 작성할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1f288af5e76ef5a4f231f5810c9960b284e03991" translate="yes" xml:space="preserve">
          <source>If you develop on a branch crazy-idea, then regret it, you can always delete the branch with</source>
          <target state="translated">미친 미친 아이디어에서 개발했다면 후회한다면 언제든지 다음과 같이 분기를 삭제할 수 있습니다</target>
        </trans-unit>
        <trans-unit id="6d7822c644d713e2101d339a30a68a502f988e1b" translate="yes" xml:space="preserve">
          <source>If you didn&amp;rsquo;t specify the CVSROOT/CVS_SERVER directly in the checkout command, automatically saving it in your &lt;code&gt;CVS/Root&lt;/code&gt; files, then you need to set them explicitly in your environment. CVSROOT should be set as per normal, but the directory should point at the appropriate Git repo. As above, for SSH clients &lt;code&gt;not&lt;/code&gt; restricted to &lt;code&gt;git-shell&lt;/code&gt;, CVS_SERVER should be set to &lt;code&gt;git-cvsserver&lt;/code&gt;.</source>
          <target state="translated">checkout 명령에서 CVSROOT / CVS_SERVER를 직접 지정하지 않고 &lt;code&gt;CVS/Root&lt;/code&gt; 파일 에 자동으로 저장 한 경우 환경에서 명시 적으로 설정해야합니다. CVSROOT는 정상적으로 설정해야하지만 디렉토리는 적절한 Git 저장소를 가리켜 야합니다. 위와 같이 SSH 클라이언트 가 &lt;code&gt;git-shell&lt;/code&gt; 로 제한 &lt;code&gt;not&lt;/code&gt; 경우 CVS_SERVER는 &lt;code&gt;git-cvsserver&lt;/code&gt; 로 설정해야합니다 .</target>
        </trans-unit>
        <trans-unit id="467e5efa7fe7a25688df5c19177b2c4b9a971487" translate="yes" xml:space="preserve">
          <source>If you discover that you made a mistake in specifying the status of a revision, you can save the output of this command to a file, edit it to remove the incorrect entries, and then issue the following commands to return to a corrected state:</source>
          <target state="translated">개정 상태를 잘못 지정한 경우,이 명령의 출력을 파일로 저장하고 편집하여 잘못된 항목을 제거한 후 다음 명령을 실행하여 정정 된 상태로 되돌릴 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="fdb535b3114700ba9158b47e1cadbbb4ffee0391" translate="yes" xml:space="preserve">
          <source>If you do merge, note the following rule: &lt;code&gt;git svn dcommit&lt;/code&gt; will attempt to commit on top of the SVN commit named in</source>
          <target state="translated">병합하는 경우 다음 규칙에 유의하십시오. &lt;code&gt;git svn dcommit&lt;/code&gt; 은에서 명명 된 SVN 커밋 위에 커밋을 시도합니다.</target>
        </trans-unit>
        <trans-unit id="d7d53a76c809507d4642710878a2561fe720cf02" translate="yes" xml:space="preserve">
          <source>If you do not have &lt;code&gt;mod_rewrite&lt;/code&gt; available to match against the query string, it is sufficient to just protect &lt;code&gt;git-receive-pack&lt;/code&gt; itself, like:</source>
          <target state="translated">쿼리 문자열과 일치하도록 &lt;code&gt;mod_rewrite&lt;/code&gt; 를 사용할 수 없으면 다음 과 같이 &lt;code&gt;git-receive-pack&lt;/code&gt; 자체를 보호하는 것으로 충분합니다 .</target>
        </trans-unit>
        <trans-unit id="61817ad83cf40051c64b68562493dd77ca2fe6f8" translate="yes" xml:space="preserve">
          <source>If you do not have this configuration variable, the value of &lt;code&gt;i18n.commitEncoding&lt;/code&gt; is used instead.</source>
          <target state="translated">이 구성 변수가없는 경우 &lt;code&gt;i18n.commitEncoding&lt;/code&gt; 값이 대신 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="14f3fbb24beba0c7fa85b6385a5b3979968f4593" translate="yes" xml:space="preserve">
          <source>If you do not know the encoding of a file, then you can use the &lt;code&gt;file&lt;/code&gt; command to guess the encoding:</source>
          <target state="translated">파일의 인코딩을 모르는 경우 &lt;code&gt;file&lt;/code&gt; 명령을 사용 하여 인코딩을 추측 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="371074e4db6e9a2527bbe63c09ef576231a57ee5" translate="yes" xml:space="preserve">
          <source>If you do not want this feature on your server just remove the second rewrite rule.</source>
          <target state="translated">서버에서이 기능을 원하지 않으면 두 번째 다시 쓰기 규칙을 제거하십시오.</target>
        </trans-unit>
        <trans-unit id="b68a865397b0b847cde7a3d94bca4e3b8a2b1c61" translate="yes" xml:space="preserve">
          <source>If you do not want to lose your work (history from X to B) or the work by the other person (history from X to A), you would need to first fetch the history from the repository, create a history that contains changes done by both parties, and push the result back.</source>
          <target state="translated">작업 (X에서 B 로의 히스토리) 또는 다른 사람의 작업 (X에서 A 로의 히스토리)을 잃지 않으려면 먼저 저장소에서 히스토리를 가져 와서 변경 사항이 포함 된 히스토리를 작성해야합니다. 양 당사자에 의해 결과를 다시 밀어 넣습니다.</target>
        </trans-unit>
        <trans-unit id="86c596eda084e162303624098fd515841984d889" translate="yes" xml:space="preserve">
          <source>If you do this, then you should make a public announcement indicating that &lt;code&gt;next&lt;/code&gt; was rewound and rebuilt.</source>
          <target state="translated">이렇게하면 &lt;code&gt;next&lt;/code&gt; 이 되감기 고 재건 되었음을 알리는 공개 발표를해야 합니다.</target>
        </trans-unit>
        <trans-unit id="325a3c2222e4d4aaa5c937ccab45f34c95352c49" translate="yes" xml:space="preserve">
          <source>If you don&amp;rsquo;t want to continue with that right away, a few other digressions that may be interesting at this point are:</source>
          <target state="translated">지금 당장 계속하고 싶지 않다면이 시점에서 흥미로운 몇 가지 다른 위반 사항이 있습니다.</target>
        </trans-unit>
        <trans-unit id="bf36326b8dfc35954574299040bce7c304964cb4" translate="yes" xml:space="preserve">
          <source>If you enable PATH_INFO usage in gitweb by putting</source>
          <target state="translated">gitweb에서 PATH_INFO 사용을 활성화하면</target>
        </trans-unit>
        <trans-unit id="3e267e16654424679545d579a56c2fc25a567700" translate="yes" xml:space="preserve">
          <source>If you examine the file &lt;code&gt;.git/config&lt;/code&gt;, you will see that Git has added a new stanza:</source>
          <target state="translated">&lt;code&gt;.git/config&lt;/code&gt; 파일을 살펴보면 Git이 새로운 스탠자를 추가 한 것을 볼 수 있습니다 :</target>
        </trans-unit>
        <trans-unit id="adaf459f23d870ce117760016108b7b8ca67ba63" translate="yes" xml:space="preserve">
          <source>If you examine the resulting commit using gitk, you will see that it has two parents, one pointing to the top of the current branch, and one to the top of the other branch.</source>
          <target state="translated">gitk를 사용하여 커밋 결과를 살펴보면 현재 분기의 상단을 가리키는 부모와 다른 분기의 상단을 가리키는 부모가 두 개 있음을 알 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f87315138be947ec0afa0ac1351920e4dfe2a0c2" translate="yes" xml:space="preserve">
          <source>If you find some reason to set this option to &lt;code&gt;false&lt;/code&gt;, other than one-off testing, you should report the behavior difference as a bug in Git (see &lt;a href=&quot;https://git-scm.com/community&quot;&gt;https://git-scm.com/community&lt;/a&gt; for details).</source>
          <target state="translated">일회성 테스트 이외 의이 옵션을 &lt;code&gt;false&lt;/code&gt; 로 설정 해야하는 이유가 있는 경우 동작 차이를 Git의 버그로보고해야합니다 (자세한 내용은 &lt;a href=&quot;https://git-scm.com/community&quot;&gt;https://git-scm.com/community&lt;/a&gt; 참조).</target>
        </trans-unit>
        <trans-unit id="bbcb62743d9f0aa650833d05c94c3e3db4eb4e0d" translate="yes" xml:space="preserve">
          <source>If you find you forked off the wrong branch and want to move it &quot;back in time&quot;, use &lt;a href=&quot;git-rebase&quot;&gt;git-rebase[1]&lt;/a&gt;.</source>
          <target state="translated">잘못된 브랜치를 분리하고 &quot;시간으로&quot;이동 시키려면 &lt;a href=&quot;git-rebase&quot;&gt;git-rebase [1]을 사용하십시오&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="12cef549aa55079a651285c652b78bc4bc8af80c" translate="yes" xml:space="preserve">
          <source>If you find you need new features from the branch &lt;code&gt;other&lt;/code&gt; to continue working on your topic, merge &lt;code&gt;other&lt;/code&gt; to &lt;code&gt;topic&lt;/code&gt;. (However, do not do this &quot;just habitually&quot;, see below.)</source>
          <target state="translated">당신이 지점에서 새로운 기능이 필요 발견하면 &lt;code&gt;other&lt;/code&gt; 사용자의 주제에 대한 작업을 계속할 병합 &lt;code&gt;other&lt;/code&gt; 에 &lt;code&gt;topic&lt;/code&gt; . (단, &quot;임상 적으로&quot;하지 마십시오. 아래를 참조하십시오.)</target>
        </trans-unit>
        <trans-unit id="c89cdceb268014744fee40998409a87331a70cef" translate="yes" xml:space="preserve">
          <source>If you followed the last paragraph, you will now have many small topic branches, and occasionally wonder how they interact. Perhaps the result of merging them does not even work? But on the other hand, we want to avoid merging them anywhere &quot;stable&quot; because such merges cannot easily be undone.</source>
          <target state="translated">마지막 단락을 따르면 작은 주제 분기가 많이 생겨서 때로는 어떻게 상호 작용하는지 궁금해합니다. 아마도 병합 결과가 작동하지 않습니까? 그러나 다른 한편으로는 이러한 병합은 쉽게 취소 할 수 없기 때문에 &quot;안정된&quot;위치에 병합하는 것을 피하고 싶습니다.</target>
        </trans-unit>
        <trans-unit id="f8ccc691fa447494e794dd8643eee96c05ab0ca5" translate="yes" xml:space="preserve">
          <source>If you get stuck and decide to just give up and throw the whole mess away, you can always return to the pre-merge state with</source>
          <target state="translated">당신이 붙어서 그냥 엉망으로 전체 쓰레기를 버릴하기로 결정했다면, 당신은 항상 합병 전 상태로 돌아갈 수 있습니다</target>
        </trans-unit>
        <trans-unit id="8d7c02e3dd22e344be3301eb8a2278c07f5b614c" translate="yes" xml:space="preserve">
          <source>If you grasp the ideas in that initial commit, you should check out a more recent version and skim &lt;code&gt;cache.h&lt;/code&gt;, &lt;code&gt;object.h&lt;/code&gt; and &lt;code&gt;commit.h&lt;/code&gt;.</source>
          <target state="translated">초기 커밋에서 아이디어를 파악하면 최신 버전을 확인하고 &lt;code&gt;cache.h&lt;/code&gt; , &lt;code&gt;object.h&lt;/code&gt; 및 &lt;code&gt;commit.h&lt;/code&gt; 을 살펴보십시오 .</target>
        </trans-unit>
        <trans-unit id="b91c4875b14e285ca788a5bd5edf75dfcd9633ab" translate="yes" xml:space="preserve">
          <source>If you have a clone of git.git itself, the output of &lt;a href=&quot;git-shortlog&quot;&gt;git-shortlog[1]&lt;/a&gt; and &lt;a href=&quot;git-blame&quot;&gt;git-blame[1]&lt;/a&gt; can show you the authors for specific parts of the project.</source>
          <target state="translated">git.git 자체의 복제본이있는 경우 &lt;a href=&quot;git-shortlog&quot;&gt;git-shortlog [1]&lt;/a&gt; 및 &lt;a href=&quot;git-blame&quot;&gt;git-blame [1]&lt;/a&gt; 의 출력으로 프로젝트의 특정 부분에 대한 작성자를 표시 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d76da65add1ab668fa52a438912f17a42719fc64" translate="yes" xml:space="preserve">
          <source>If you have a repository where all the branches of interest exist as subdirectories of a single depot path, you can use &lt;code&gt;--detect-branches&lt;/code&gt; when cloning or syncing to have &lt;code&gt;git p4&lt;/code&gt; automatically find subdirectories in p4, and to generate these as branches in Git.</source>
          <target state="translated">관심있는 모든 브랜치가 단일 저장소 경로의 서브 디렉토리로 존재하는 저장소가있는 경우, 복제 또는 동기화시 &lt;code&gt;--detect-branches&lt;/code&gt; 를 사용 하여 &lt;code&gt;git p4&lt;/code&gt; 가 p4에서 서브 디렉토리를 자동으로 찾도록하고 Git에서 브랜치로이를 생성 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="0a6081c46922db10b6bc6f47a7f76b221a6196d2" translate="yes" xml:space="preserve">
          <source>If you have a script that can tell if the current source code is good or bad, you can bisect by issuing the command:</source>
          <target state="translated">현재 소스 코드가 좋은지 나쁜지를 알 수있는 스크립트가있는 경우 다음 명령을 실행하여 이등분 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="863f4e57810f45268a83fecc8614e1be7d434564" translate="yes" xml:space="preserve">
          <source>If you have added attributes to a file that cause the canonical repository format for that file to change, such as adding a clean/smudge filter or text/eol/ident attributes, merging anything where the attribute is not in place would normally cause merge conflicts.</source>
          <target state="translated">정리 / 스머지 필터 또는 텍스트 / Eol / ident 속성 추가와 같이 해당 파일의 표준 저장소 형식을 변경하는 속성을 파일에 추가 한 경우 속성이없는 위치를 병합하면 일반적으로 병합 충돌이 발생합니다 .</target>
        </trans-unit>
        <trans-unit id="0176ab2e378e3df6f1e24b7af5113bcd1e2d5987" translate="yes" xml:space="preserve">
          <source>If you have an old Git that does not understand the version 2 &lt;code&gt;*.idx&lt;/code&gt; file, cloning or fetching over a non native protocol (e.g. &quot;http&quot;) that will copy both &lt;code&gt;*.pack&lt;/code&gt; file and corresponding &lt;code&gt;*.idx&lt;/code&gt; file from the other side may give you a repository that cannot be accessed with your older version of Git. If the &lt;code&gt;*.pack&lt;/code&gt; file is smaller than 2 GB, however, you can use &lt;a href=&quot;git-index-pack&quot;&gt;git-index-pack[1]&lt;/a&gt; on the *.pack file to regenerate the &lt;code&gt;*.idx&lt;/code&gt; file.</source>
          <target state="translated">버전 2 &lt;code&gt;*.idx&lt;/code&gt; 파일을 이해하지 못하는 오래된 Git이있는 경우 &lt;code&gt;*.pack&lt;/code&gt; 파일과 해당 &lt;code&gt;*.idx&lt;/code&gt; 파일을 다른 쪽에서 복사하는 비 기본 프로토콜 (예 : &quot;http&quot;)을 통해 복제하거나 가져 오는 경우 이전 버전의 Git으로 액세스 할 수없는 저장소를 제공 할 수 있습니다. 는 IF &lt;code&gt;*.pack&lt;/code&gt; 의 파일 2 GB보다 작은, 그러나, 당신이 사용할 수있는 &lt;a href=&quot;git-index-pack&quot;&gt;자식 인덱스 팩 [1]를&lt;/a&gt; 재생성하기 위해 * .pack 파일을 &lt;code&gt;*.idx&lt;/code&gt; 파일을.</target>
        </trans-unit>
        <trans-unit id="1c4d7bfb0f77357b6cf0e14e83f75e3ad3892e2a" translate="yes" xml:space="preserve">
          <source>If you have an unfortunate branch that is named &lt;code&gt;hello.c&lt;/code&gt;, this step would be confused as an instruction to switch to that branch. You should instead write:</source>
          <target state="translated">&lt;code&gt;hello.c&lt;/code&gt; 라는 불행한 분기가있는 경우이 단계는 해당 분기로 전환하라는 지시로 혼동됩니다. 대신 다음과 같이 작성해야합니다.</target>
        </trans-unit>
        <trans-unit id="6748330dc78a7c7da8f6ed8d92c497a5f2638cdd" translate="yes" xml:space="preserve">
          <source>If you have imported some changes from another VCS and would like to add tags for major releases of your work, it is useful to be able to specify the date to embed inside of the tag object; such data in the tag object affects, for example, the ordering of tags in the gitweb interface.</source>
          <target state="translated">다른 VCS에서 일부 변경 사항을 가져오고 주요 릴리스의 작업에 대한 태그를 추가하려는 경우 태그 오브젝트에 임베드 할 날짜를 지정할 수 있습니다. 태그 객체의 이러한 데이터는 예를 들어 gitweb 인터페이스의 태그 순서에 영향을줍니다.</target>
        </trans-unit>
        <trans-unit id="d87d691ee6c65f8321e66034d85f79793605b8a9" translate="yes" xml:space="preserve">
          <source>If you have local modifications to one or more files that are different between the current branch and the branch to which you are switching, the command refuses to switch branches in order to preserve your modifications in context. However, with this option, a three-way merge between the current branch, your working tree contents, and the new branch is done, and you will be on the new branch.</source>
          <target state="translated">현재 분기와 전환하려는 분기간에 다른 하나 이상의 파일을 로컬로 수정 한 경우 명령은 컨텍스트에서 수정 사항을 보존하기 위해 분기 전환을 거부합니다. 그러나이 옵션을 사용하면 현재 분기, 작업 트리 내용 및 새 분기간에 3 방향 병합이 수행되고 새 분기에있게됩니다.</target>
        </trans-unit>
        <trans-unit id="8478bf298413f91bee793cf9d5101299eaa200bd" translate="yes" xml:space="preserve">
          <source>If you have multifactor authentication setup on your gmail account, you will need to generate an app-specific password for use with &lt;code&gt;git send-email&lt;/code&gt;. Visit &lt;a href=&quot;https://security.google.com/settings/security/apppasswords&quot;&gt;https://security.google.com/settings/security/apppasswords&lt;/a&gt; to create it.</source>
          <target state="translated">Gmail 계정에 다단계 인증을 설정 한 경우 &lt;code&gt;git send-email&lt;/code&gt; 과 함께 사용하려면 앱 비밀번호를 생성해야합니다 . &lt;a href=&quot;https://security.google.com/settings/security/apppasswords&quot;&gt;https://security.google.com/settings/security/apppasswords&lt;/a&gt; 를 방문 하여 만드십시오.</target>
        </trans-unit>
        <trans-unit id="a8709177c278b5c18333d173ba933d08e65c6841" translate="yes" xml:space="preserve">
          <source>If you have some initial content (say, a tarball):</source>
          <target state="translated">초기 내용이 있다면 (예 : 타르볼) :</target>
        </trans-unit>
        <trans-unit id="495e5ec3bcea1de47c24c2073588d5c3b0cf061c" translate="yes" xml:space="preserve">
          <source>If you have these three &lt;code&gt;gitattributes&lt;/code&gt; file:</source>
          <target state="translated">다음 세 가지 &lt;code&gt;gitattributes&lt;/code&gt; 파일이있는 경우 :</target>
        </trans-unit>
        <trans-unit id="8c8ea948fec03c8051df6ee29e66dada48224b15" translate="yes" xml:space="preserve">
          <source>If you have uncommitted changes in your submodule working tree, &lt;code&gt;git
submodule update&lt;/code&gt; will not overwrite them. Instead, you get the usual warning about not being able switch from a dirty branch.</source>
          <target state="translated">서브 모듈 작업 트리에서 커밋되지 않은 변경 사항이 있으면 &lt;code&gt;git submodule update&lt;/code&gt; 가 덮어 쓰지 않습니다. 대신 더티 브랜치에서 전환 할 수 없다는 일반적인 경고가 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="4ccda3cb1e710a989feb173887174c1818fd9d4a" translate="yes" xml:space="preserve">
          <source>If you intend that your next commit should record all modifications of tracked files in the working tree and record all removals of files that have been removed from the working tree with &lt;code&gt;rm&lt;/code&gt; (as opposed to &lt;code&gt;git rm&lt;/code&gt;), use &lt;code&gt;git commit -a&lt;/code&gt;, as it will automatically notice and record all removals. You can also have a similar effect without committing by using &lt;code&gt;git add -u&lt;/code&gt;.</source>
          <target state="translated">다음 커밋이 작업 트리에서 추적 된 파일의 모든 수정 사항을 기록하고 &lt;code&gt;rm&lt;/code&gt; 을 사용하여 작업 트리에서 제거 된 모든 파일 제거를 기록 하려면 ( &lt;code&gt;git rm&lt;/code&gt; 과 반대 ) &lt;code&gt;git commit -a&lt;/code&gt; 를 사용하십시오. 모든 제거를 자동으로 인식하고 기록합니다. &lt;code&gt;git add -u&lt;/code&gt; 를 사용하여 커밋하지 않고도 비슷한 효과를 얻을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="5223949abb561108f8606da60ebd3c3b78a9872c" translate="yes" xml:space="preserve">
          <source>If you intend to set up a shared public repository that all developers can read/write, or if you want to use &lt;a href=&quot;git-cvsserver&quot;&gt;git-cvsserver[1]&lt;/a&gt;, then you probably want to make a bare clone of the imported repository, and use the clone as the shared repository. See &lt;a href=&quot;gitcvs-migration&quot;&gt;gitcvs-migration[7]&lt;/a&gt;.</source>
          <target state="translated">모든 개발자가 읽고 쓸 수있는 공유 공용 저장소를 설정하려는 경우 또는 &lt;a href=&quot;git-cvsserver&quot;&gt;git-cvsserver [1]&lt;/a&gt; 을 사용하려는 경우 가져온 저장소의 베어 복제본을 작성하고 복제본을 다음과 같이 사용하려고합니다. 공유 리포지토리 &lt;a href=&quot;gitcvs-migration&quot;&gt;gitcvs-migration [7]을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="1e8fe75eb0be8caf3b1c84cce78f8d98c5c3831c" translate="yes" xml:space="preserve">
          <source>If you just have a few changes, the simplest way to submit them may just be to send them as patches in email:</source>
          <target state="translated">몇 가지 변경 사항이있는 경우 제출하는 가장 간단한 방법은 변경 사항을 이메일로 패치로 보내는 것입니다.</target>
        </trans-unit>
        <trans-unit id="c3509063d9c8d28fc350d64af9974d7f7ad07d9f" translate="yes" xml:space="preserve">
          <source>If you just need to use Git as a revision control system you may prefer to start with &quot;A Tutorial Introduction to Git&quot; (&lt;a href=&quot;gittutorial&quot;&gt;gittutorial[7]&lt;/a&gt;) or &lt;a href=&quot;user-manual&quot;&gt;the Git User Manual&lt;/a&gt;.</source>
          <target state="translated">수정 제어 시스템으로 Git을 사용해야하는 경우 &quot;Git에 대한 자습서 소개&quot;( &lt;a href=&quot;gittutorial&quot;&gt;gittutorial [7]&lt;/a&gt; ) 또는 &lt;a href=&quot;user-manual&quot;&gt;Git 사용자 매뉴얼로 시작하는 것이&lt;/a&gt; 좋습니다.</target>
        </trans-unit>
        <trans-unit id="6a839fbf210e306e2136c31f2a968baa357075d1" translate="yes" xml:space="preserve">
          <source>If you just want to edit the commit message for a commit, replace the command &quot;pick&quot; with the command &quot;reword&quot;.</source>
          <target state="translated">커밋에 대한 커밋 메시지를 편집하려면 &quot;pick&quot;명령을 &quot;reword&quot;명령으로 바꾸십시오.</target>
        </trans-unit>
        <trans-unit id="1a22bf44debddb2b1654740b48fdcb88c27e49eb" translate="yes" xml:space="preserve">
          <source>If you just want to get the newest copies of the integration branches, staying up to date is easy too:</source>
          <target state="translated">통합 분기의 최신 사본을 얻으려면 최신 상태를 유지하는 것도 쉽습니다.</target>
        </trans-unit>
        <trans-unit id="5a13a90084d33cb33125eb2c50fff6e07ce8c0d9" translate="yes" xml:space="preserve">
          <source>If you just want to look at an old version of the file, without modifying the working directory, you can do that with &lt;a href=&quot;git-show&quot;&gt;git-show[1]&lt;/a&gt;:</source>
          <target state="translated">작업 디렉토리를 수정하지 않고 파일의 이전 버전을 보려는 경우 &lt;a href=&quot;git-show&quot;&gt;git-show [1]로&lt;/a&gt; 수행 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="68f30cb563d71e3909ec492d5d34c92facf1030b" translate="yes" xml:space="preserve">
          <source>If you just want to verify whether a given tagged version contains a given commit, you could use &lt;a href=&quot;git-merge-base&quot;&gt;git-merge-base[1]&lt;/a&gt;:</source>
          <target state="translated">주어진 태그 버전에 주어진 커밋이 포함되어 있는지 확인하려면 &lt;a href=&quot;git-merge-base&quot;&gt;git-merge-base [1]&lt;/a&gt; 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="d8a6261ebe4a4d52d4d9a2234a54f319605d4abc" translate="yes" xml:space="preserve">
          <source>If you keep your primary branches immediately under &lt;code&gt;refs/heads&lt;/code&gt;, and topic branches in subdirectories of it, having the following in the configuration file may help:</source>
          <target state="translated">기본 분기를 &lt;code&gt;refs/heads&lt;/code&gt; 바로 아래에 두고 하위 분기의 주제 분기를 구성하는 경우 구성 파일에 다음이 있으면 도움이 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="933889a0268ded50e3304543b4e7167783337a6d" translate="yes" xml:space="preserve">
          <source>If you know beforehand more than one good commit, you can narrow the bisect space down by specifying all of the good commits immediately after the bad commit when issuing the &lt;code&gt;bisect start&lt;/code&gt; command:</source>
          <target state="translated">사전에 둘 이상의 양호한 커밋을 알고있는 경우 &lt;code&gt;bisect start&lt;/code&gt; 명령을 실행할 때 잘못된 커밋 직후에 모든 올바른 커밋을 지정하여 bisect 공간을 좁힐 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="0d0efb22e26170e5f6a2a2c939fcf419b948a8aa" translate="yes" xml:space="preserve">
          <source>If you know up to what commit the intended recipient repository should have the necessary objects, you can use that knowledge to specify the basis, giving a cut-off point to limit the revisions and objects that go in the resulting bundle. The previous example used the lastR2bundle tag for this purpose, but you can use any other options that you would give to the &lt;a href=&quot;git-log&quot;&gt;git-log[1]&lt;/a&gt; command. Here are more examples:</source>
          <target state="translated">의도 된 수신자 저장소에 필요한 오브젝트가 있어야하는 확약을 아는 경우 해당 지식을 사용하여 기준을 지정하여 결과 번들에 포함 된 개정 및 오브젝트를 제한하는 컷오프 지점을 제공 할 수 있습니다. 이전 예제에서는 이러한 목적으로 lastR2bundle 태그를 사용했지만 &lt;a href=&quot;git-log&quot;&gt;git-log [1]&lt;/a&gt; 명령에 제공하는 다른 옵션을 사용할 수 있습니다 . 더 많은 예는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="6178dcf6380091f437345048b81ae6acd9e3fdb2" translate="yes" xml:space="preserve">
          <source>If you leave out the commit name, &lt;code&gt;git grep&lt;/code&gt; will search any of the files it manages in your current directory. So</source>
          <target state="translated">커밋 이름을 생략하면 &lt;code&gt;git grep&lt;/code&gt; 은 현재 디렉토리에서 관리하는 파일을 검색합니다. 그래서</target>
        </trans-unit>
        <trans-unit id="1d3a773743dd2af35a158be46f7bad29aaa6f592" translate="yes" xml:space="preserve">
          <source>If you like to live dangerously, you can replace &lt;strong&gt;all&lt;/strong&gt; core.gitproxy by a new one with</source>
          <target state="translated">위험한 생활을 원한다면 &lt;strong&gt;모든&lt;/strong&gt; core.gitproxy를 새로운 것으로 대체 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9bff9b22c3bcd9cedd5449471391b1cdf79647bb" translate="yes" xml:space="preserve">
          <source>If you make a commit and then find a mistake immediately after that, you can recover from it with &lt;code&gt;git reset&lt;/code&gt;.</source>
          <target state="translated">커밋을 한 다음 그 직후에 실수를 찾으면 &lt;code&gt;git reset&lt;/code&gt; 으로 복구 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="de1cbbe8d26471b895b54a3d07b205ed1595e0f4" translate="yes" xml:space="preserve">
          <source>If you make a commit that you later wish you hadn&amp;rsquo;t, there are two fundamentally different ways to fix the problem:</source>
          <target state="translated">나중에 원하지 않았던 커밋을하는 경우 근본적으로 다른 두 가지 방법으로 문제를 해결할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="99ec09f13fb1346102b0f372f091bd234e630539" translate="yes" xml:space="preserve">
          <source>If you make it (very) clear that this branch is going to be deleted right after the testing, you can even publish this branch, for example to give the testers a chance to work with it, or other developers a chance to see if their in-progress work will be compatible. &lt;code&gt;git.git&lt;/code&gt; has such an official throw-away integration branch called &lt;code&gt;pu&lt;/code&gt;.</source>
          <target state="translated">테스트 직후에이 브랜치가 삭제 될 것임을 명확하게하면 (예 : 테스터에게 해당 브랜치와 함께 작업 할 수있는 기회를 제공하기 위해)이 브랜치를 게시하거나 다른 개발자에게 진행중인 작업이 호환됩니다. &lt;code&gt;git.git&lt;/code&gt; 에는 &lt;code&gt;pu&lt;/code&gt; 라는 공식적인 버림받은 통합 브랜치가 있습니다 .</target>
        </trans-unit>
        <trans-unit id="d532db8eaaa16fed286ca601d3c879ce0db79d29" translate="yes" xml:space="preserve">
          <source>If you make the decision to start your new branch at some other point in the history than the current &lt;code&gt;HEAD&lt;/code&gt;, you can do so by just telling &lt;code&gt;git checkout&lt;/code&gt; what the base of the checkout would be. In other words, if you have an earlier tag or branch, you&amp;rsquo;d just do</source>
          <target state="translated">현재 &lt;code&gt;HEAD&lt;/code&gt; 이외의 다른 지점에서 새 분기를 시작하기로 결정한 경우 &lt;code&gt;git checkout&lt;/code&gt; 에 결제 의 기준을 알려 주면 됩니다. 다시 말해, 이전에 태그 나 지점이 있다면</target>
        </trans-unit>
        <trans-unit id="ef318d408cfc2262e9ecdfec6313bac5c50bc49a" translate="yes" xml:space="preserve">
          <source>If you manually move a linked working tree, you need to update the &lt;code&gt;gitdir&lt;/code&gt; file in the entry&amp;rsquo;s directory. For example, if a linked working tree is moved to &lt;code&gt;/newpath/test-next&lt;/code&gt; and its &lt;code&gt;.git&lt;/code&gt; file points to &lt;code&gt;/path/main/.git/worktrees/test-next&lt;/code&gt;, then update &lt;code&gt;/path/main/.git/worktrees/test-next/gitdir&lt;/code&gt; to reference &lt;code&gt;/newpath/test-next&lt;/code&gt; instead.</source>
          <target state="translated">연결된 작업 트리를 수동으로 이동하는 경우 항목 디렉토리에서 &lt;code&gt;gitdir&lt;/code&gt; 파일 을 업데이트해야합니다 . 예를 들어, 연결된 작업 트리가 &lt;code&gt;/newpath/test-next&lt;/code&gt; 로 이동 하고 해당 &lt;code&gt;.git&lt;/code&gt; 파일이 &lt;code&gt;/path/main/.git/worktrees/test-next&lt;/code&gt; 를 가리키는 경우 &lt;code&gt;/path/main/.git/worktrees/test-next/gitdir&lt;/code&gt; 대신 &lt;code&gt;/newpath/test-next&lt;/code&gt; 를 참조하는 test-next / gitdir .</target>
        </trans-unit>
        <trans-unit id="bb87bde3a880515ee52eb5a157ecf80cef103126" translate="yes" xml:space="preserve">
          <source>If you mistakenly drop or clear stash entries, they cannot be recovered through the normal safety mechanisms. However, you can try the following incantation to get a list of stash entries that are still in your repository, but not reachable any more:</source>
          <target state="translated">실수로 숨김 항목을 삭제하거나 지우면 일반적인 안전 메커니즘을 통해 복구 할 수 없습니다. 그러나 다음 주문을 시도하여 아직 저장소에 있지만 더 이상 연결할 수없는 숨김 항목 목록을 가져올 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="110b0b8058519e9efd87b798163b83180b4fd090" translate="yes" xml:space="preserve">
          <source>If you need to add &lt;code&gt;Acked-by&lt;/code&gt; lines to, say, the last 10 commits (none of which is a merge), use this command:</source>
          <target state="translated">예를 들어 마지막 10 개의 커밋 ( &lt;code&gt;Acked-by&lt;/code&gt; 중 하나는 병합되지 않음)에 Acked-by 행 을 추가 해야하는 경우 다음 명령을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="a06310bf48a43d3f06d75e4fe748345a055d13a9" translate="yes" xml:space="preserve">
          <source>If you need to amend commits from deeper in your history, you can use &lt;a href=&quot;#interactive-rebase&quot;&gt;interactive rebase&amp;rsquo;s &lt;code&gt;edit&lt;/code&gt; instruction&lt;/a&gt;.</source>
          <target state="translated">히스토리에서 더 깊이 커밋을 수정해야하는 경우 &lt;a href=&quot;#interactive-rebase&quot;&gt;대화식 rebase의 &lt;code&gt;edit&lt;/code&gt; 명령을&lt;/a&gt; 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="f26f13a2edb916f980bf0b233ef42611b499ae1c" translate="yes" xml:space="preserve">
          <source>If you need to make any further adjustments, do so now, and then add any newly modified content to the index. Finally, commit your changes with:</source>
          <target state="translated">추가 조정이 필요한 경우 지금 수정 한 다음 새로 수정 된 내용을 색인에 추가하십시오. 마지막으로 다음을 사용하여 변경 사항을 커밋하십시오.</target>
        </trans-unit>
        <trans-unit id="b7346c069533043ab7106064793cec780b496e9d" translate="yes" xml:space="preserve">
          <source>If you need to pass multiple options, separate them with a comma.</source>
          <target state="translated">여러 옵션을 전달해야하는 경우 쉼표로 구분하십시오.</target>
        </trans-unit>
        <trans-unit id="809b912a9ed5d5a0eab31e3007d95029a30a63c6" translate="yes" xml:space="preserve">
          <source>If you need to reorder or edit a number of commits in a branch, it may be easier to use &lt;code&gt;git rebase -i&lt;/code&gt;, which allows you to reorder and squash commits, as well as marking them for individual editing during the rebase. See &lt;a href=&quot;#interactive-rebase&quot;&gt;Using interactive rebases&lt;/a&gt; for details, and &lt;a href=&quot;#reordering-patch-series&quot;&gt;Reordering or selecting from a patch series&lt;/a&gt; for alternatives.</source>
          <target state="translated">브랜치에서 여러 커밋을 재정렬하거나 편집 해야하는 경우 &lt;code&gt;git rebase -i&lt;/code&gt; 를 사용하면 커밋을 재정렬하고 스쿼시하고 리베이스 중에 개별 편집을 위해 표시 할 수 있습니다. 자세한 내용은 &lt;a href=&quot;#interactive-rebase&quot;&gt;대화식 리베이스 사용&lt;/a&gt; 및 대안을 위해 &lt;a href=&quot;#reordering-patch-series&quot;&gt;패치 시리즈에서 재정렬 또는 선택을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="653cbb8173c66cbe6d9c641e8756d2055e0c1628" translate="yes" xml:space="preserve">
          <source>If you never pushed anything out, just re-tag it. Use &quot;-f&quot; to replace the old one. And you&amp;rsquo;re done.</source>
          <target state="translated">아무 것도 푸시하지 않은 경우 다시 태그를 지정하십시오. &quot;-f&quot;를 사용하여 이전 것을 바꿉니다. 그리고 당신은 끝났습니다.</target>
        </trans-unit>
        <trans-unit id="e0169e9e6701b28da91f9800a1f0eacd543a0e6b" translate="yes" xml:space="preserve">
          <source>If you now continue development as usual, and eventually merge &lt;code&gt;topic&lt;/code&gt; to &lt;code&gt;subsystem&lt;/code&gt;, the commits from &lt;code&gt;subsystem&lt;/code&gt; will remain duplicated forever:</source>
          <target state="translated">당신은 지금 평소와 같이 개발을 계속, 결국 병합 경우 &lt;code&gt;topic&lt;/code&gt; 로 &lt;code&gt;subsystem&lt;/code&gt; 에서 커밋 &lt;code&gt;subsystem&lt;/code&gt; 영원히 복제를 유지합니다 :</target>
        </trans-unit>
        <trans-unit id="d9ba20830393f58c8170e264c4d66d9dd0605070" translate="yes" xml:space="preserve">
          <source>If you now run</source>
          <target state="translated">지금 달리면</target>
        </trans-unit>
        <trans-unit id="ee95c7e5ff1bbdc349787f30139d15eef70dff52" translate="yes" xml:space="preserve">
          <source>If you only want to remove the local checkout of a submodule from your work tree without committing the removal, use &lt;a href=&quot;git-submodule&quot;&gt;git-submodule[1]&lt;/a&gt;&lt;code&gt;deinit&lt;/code&gt; instead. Also see &lt;a href=&quot;gitsubmodules&quot;&gt;gitsubmodules[7]&lt;/a&gt; for details on submodule removal.</source>
          <target state="translated">제거를 커밋하지 않고 작업 트리에서 하위 모듈의 로컬 체크 아웃 만 제거하려면 대신 &lt;a href=&quot;git-submodule&quot;&gt;git-submodule [1] &lt;/a&gt; &lt;code&gt;deinit&lt;/code&gt; 를 사용하십시오. 서브 모듈 제거에 대한 자세한 내용 은 &lt;a href=&quot;gitsubmodules&quot;&gt;gitsubmodules [7]&lt;/a&gt; 도 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="de4ecb2fda4e4a17fa4230cd7b06e657b6ab1e40" translate="yes" xml:space="preserve">
          <source>If you plan to publish this repository to be accessed over http, you should do &lt;code&gt;mv my-git.git/hooks/post-update.sample
my-git.git/hooks/post-update&lt;/code&gt; at this point. This makes sure that every time you push into this repository, &lt;code&gt;git update-server-info&lt;/code&gt; is run.</source>
          <target state="translated">http를 통해 액세스 할 수 있도록이 리포지토리를 게시하려면이 &lt;code&gt;mv my-git.git/hooks/post-update.sample my-git.git/hooks/post-update&lt;/code&gt; 를 수행해야합니다. 이를 통해이 저장소로 푸시 할 때마다 &lt;code&gt;git update-server-info&lt;/code&gt; 가 실행됩니다.</target>
        </trans-unit>
        <trans-unit id="dce58b5a972f1c023066ee29ac3c991fde1e2420" translate="yes" xml:space="preserve">
          <source>If you present all of your changes as a single patch (or commit), they may find that it is too much to digest all at once.</source>
          <target state="translated">모든 변경 사항을 단일 패치 (또는 커밋)로 표시하면 한 번에 모두 다이제스트하기에는 너무 많은 것을 알 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6e4131986cf58f7abe3d9d87945a8e4a59143945" translate="yes" xml:space="preserve">
          <source>If you present them with the entire history of your work, complete with mistakes, corrections, and dead ends, they may be overwhelmed.</source>
          <target state="translated">당신이 그들에게 당신의 작업의 전체 역사를 제시하고, 실수, 수정, 막 다른 골목으로 완성한다면, 그들은 압도 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="21ee16e384bb8d43949dac71aebc6ab455b71a15" translate="yes" xml:space="preserve">
          <source>If you provide a &lt;code&gt;directory&lt;/code&gt;, the command is run inside it. If this directory does not exist, it will be created.</source>
          <target state="translated">&lt;code&gt;directory&lt;/code&gt; 를 제공 하면 명령이 그 안에서 실행됩니다. 이 디렉토리가 존재하지 않으면 작성됩니다.</target>
        </trans-unit>
        <trans-unit id="e318df70fba90a3c817f7eb76621f705fc69949d" translate="yes" xml:space="preserve">
          <source>If you pushed your change to a branch whose name is different from the one you have locally, e.g.</source>
          <target state="translated">이름이 로컬에있는 것과 다른 지점으로 변경을 푸시 한 경우 (예 :</target>
        </trans-unit>
        <trans-unit id="f36c21fb05ddb2d8eeea70a503cb3c797b4a7baa" translate="yes" xml:space="preserve">
          <source>If you really don&amp;rsquo;t want to clone it, for whatever reasons, check the following points instead (in this order). This is a very destructive approach, so &lt;strong&gt;make a backup&lt;/strong&gt; or go back to cloning it. You have been warned.</source>
          <target state="translated">어떤 이유로 든 복제하지 않으려면 대신 다음 사항을 순서대로 확인하십시오. 이것은 매우 파괴적인 접근 방식이므로 &lt;strong&gt;백업을&lt;/strong&gt; 하거나 복제로 돌아갑니다. 경고를 받았습니다.</target>
        </trans-unit>
        <trans-unit id="3a0d5ef629f0a421a47e2200b4c6f6985f396b8e" translate="yes" xml:space="preserve">
          <source>If you really want to remove a submodule from the repository and commit that use &lt;a href=&quot;git-rm&quot;&gt;git-rm[1]&lt;/a&gt; instead. See &lt;a href=&quot;gitsubmodules&quot;&gt;gitsubmodules[7]&lt;/a&gt; for removal options.</source>
          <target state="translated">리포지토리에서 하위 모듈을 제거하고 커밋하려면 &lt;a href=&quot;git-rm&quot;&gt;git-rm [1]을&lt;/a&gt; 대신 사용하십시오. 제거 옵션에 대해서는 &lt;a href=&quot;gitsubmodules&quot;&gt;gitsubmodules [7]&lt;/a&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="a5e65b5631472cf01bf2ff6d1fb37eb4b5d6b41d" translate="yes" xml:space="preserve">
          <source>If you really want to use &lt;code&gt;konqueror&lt;/code&gt;, then you can use something like the following:</source>
          <target state="translated">실제로 &lt;code&gt;konqueror&lt;/code&gt; 를 사용 하려면 다음과 같은 것을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e3a8dad6f18366292640cec2d899866b39003a2b" translate="yes" xml:space="preserve">
          <source>If you receive such a patch series (as maintainer, or perhaps as a reader of the mailing list it was sent to), save the mails to files, create a new topic branch and use &lt;code&gt;git am&lt;/code&gt; to import the commits:</source>
          <target state="translated">이러한 패치 시리즈 (관리자 또는 메일 링리스트의 독자로서)를 받으면, 메일을 파일에 저장하고 새 토픽 브랜치를 작성하고 &lt;code&gt;git am&lt;/code&gt; 을 사용 하여 커밋을 가져 오십시오.</target>
        </trans-unit>
        <trans-unit id="8122cfb5e210d22279775f15b8524f8a454a6069" translate="yes" xml:space="preserve">
          <source>If you receive the SHA-1 name of a blob from one source, and its contents from another (possibly untrusted) source, you can still trust that those contents are correct as long as the SHA-1 name agrees. This is because the SHA-1 is designed so that it is infeasible to find different contents that produce the same hash.</source>
          <target state="translated">한 소스에서 Blob의 SHA-1 이름을 수신하고 다른 소스 (신뢰할 수없는) 소스에서 해당 컨텐츠를 수신하더라도 SHA-1 이름이 동의하는 한 해당 컨텐츠가 올바르다 고 여전히 신뢰할 수 있습니다. SHA-1은 동일한 해시를 생성하는 다른 컨텐츠를 찾을 수 없도록 설계 되었기 때문입니다.</target>
        </trans-unit>
        <trans-unit id="72b668cfa18e4e3a824ca9d20a1fa4e3cde95d1f" translate="yes" xml:space="preserve">
          <source>If you recognize such corruption early you can easily fix it by setting the conversion type explicitly in .gitattributes. Right after committing you still have the original file in your work tree and this file is not yet corrupted. You can explicitly tell Git that this file is binary and Git will handle the file appropriately.</source>
          <target state="translated">이러한 손상을 조기에 인식하면 변환 유형을 .gitattributes에 명시 적으로 설정하여 쉽게 수정할 수 있습니다. 커밋 한 후에도 여전히 작업 트리에 원본 파일이 있으며이 파일은 아직 손상되지 않았습니다. Git에게이 파일이 바이너리이고 Git이 파일을 적절히 처리 할 것이라고 명시 적으로 말할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6d44148625d48b9905fb64fc2d01c214d013573d" translate="yes" xml:space="preserve">
          <source>If you run &lt;code&gt;git branch&lt;/code&gt; at this point, you&amp;rsquo;ll see that Git has temporarily moved you in &quot;(no branch)&quot;. HEAD is now detached from any branch and points directly to a commit (with commit id 65934) that is reachable from &quot;master&quot; but not from v2.6.18. Compile and test it, and see whether it crashes. Assume it does crash. Then:</source>
          <target state="translated">이 시점에서 &lt;code&gt;git branch&lt;/code&gt; 를 실행 하면 Git이 일시적으로 &quot;(분기 없음)&quot;으로 이동했음을 알 수 있습니다. HEAD는 이제 모든 브랜치에서 분리되며 v2.6.18이 아닌 &quot;마스터&quot;에서는 도달 할 수있는 커밋 (커밋 ID 65934)을 직접 가리 킵니다. 컴파일하고 테스트하여 충돌하는지 확인하십시오. 충돌한다고 가정하십시오. 그때:</target>
        </trans-unit>
        <trans-unit id="e4f37857c4f0244dcc0891e65a70e27a5bbdffad" translate="yes" xml:space="preserve">
          <source>If you run &lt;code&gt;git fetch &amp;lt;remote&amp;gt;&lt;/code&gt; later, the remote-tracking branches for the named &lt;code&gt;&amp;lt;remote&amp;gt;&lt;/code&gt; will be updated.</source>
          <target state="translated">나중에 &lt;code&gt;git fetch &amp;lt;remote&amp;gt;&lt;/code&gt; 를 실행 하면 이름이 지정된 &lt;code&gt;&amp;lt;remote&amp;gt;&lt;/code&gt; 의 원격 추적 분기 가 업데이트됩니다.</target>
        </trans-unit>
        <trans-unit id="086aebbf0140fb264a45c34927db290b089af7f6" translate="yes" xml:space="preserve">
          <source>If you run &lt;code&gt;git repack&lt;/code&gt; again at this point, it will say &quot;Nothing new to pack.&quot;. Once you continue your development and accumulate the changes, running &lt;code&gt;git repack&lt;/code&gt; again will create a new pack, that contains objects created since you packed your repository the last time. We recommend that you pack your project soon after the initial import (unless you are starting your project from scratch), and then run &lt;code&gt;git repack&lt;/code&gt; every once in a while, depending on how active your project is.</source>
          <target state="translated">이 시점에서 &lt;code&gt;git repack&lt;/code&gt; 을 다시 실행하면 &quot;Nothing new to pack&quot;이라고 표시됩니다. 개발을 계속하고 변경 사항을 누적하면 &lt;code&gt;git repack&lt;/code&gt; 을 다시 실행 하면 저장소를 마지막으로 압축 한 이후 생성 된 객체가 포함 된 새 팩이 생성됩니다. 처음 가져 오기 직후 (프로젝트를 처음부터 시작하지 않는 한) 프로젝트를 &lt;code&gt;git repack&lt;/code&gt; 한 다음 프로젝트의 활동 정도에 따라 가끔씩 git repack 을 실행 하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="f6784580fd898de2457fa8e4a33fffee5347973c" translate="yes" xml:space="preserve">
          <source>If you simply want to have CRLF line endings in your working directory regardless of the repository you are working with, you can set the config variable &quot;core.autocrlf&quot; without using any attributes.</source>
          <target state="translated">작업중인 저장소에 관계없이 작업 디렉토리에 CRLF 줄 끝을 표시하려는 경우 속성을 사용하지 않고 구성 변수 &quot;core.autocrlf&quot;를 설정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7c25024f01247f9dfa8226991c206d71987ca030" translate="yes" xml:space="preserve">
          <source>If you suspect that any of these issues may apply to the repository you want to import, consider using cvs2git:</source>
          <target state="translated">가져올 저장소에 이러한 문제가 발생할 수 있다고 생각되면 cvs2git 사용을 고려하십시오.</target>
        </trans-unit>
        <trans-unit id="d4145f8caae501b7db828bb5aa5f527a21b88535" translate="yes" xml:space="preserve">
          <source>If you think you have found a git bug, you can start by exporting an anonymized stream of the whole repository:</source>
          <target state="translated">git 버그를 발견했다고 생각되면 전체 저장소의 익명 스트림을 내 보내서 시작할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="846aba2aee9d2174839c8e896f13afd75da487fc" translate="yes" xml:space="preserve">
          <source>If you tried a merge which resulted in complex conflicts and want to start over, you can recover with &lt;code&gt;git merge --abort&lt;/code&gt;.</source>
          <target state="translated">복잡한 충돌을 &lt;code&gt;git merge --abort&lt;/code&gt; 병합을 시도하고 다시 시작하려는 경우 git merge --abort로 복구 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="0e65bb746f0318eba11b3455708b3d4c243b8cb3" translate="yes" xml:space="preserve">
          <source>If you tried a pull which resulted in complex conflicts and would want to start over, you can recover with &lt;code&gt;git reset&lt;/code&gt;.</source>
          <target state="translated">풀을 시도하여 복잡한 충돌이 발생하고 다시 시작하려는 경우 &lt;code&gt;git reset&lt;/code&gt; 으로 복구 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="a4f4230d5ba7e1273c96751869d78c8666680eb6" translate="yes" xml:space="preserve">
          <source>If you try and cheat and try to make git-filter-branch only work on files modified in a commit, then two things happen</source>
          <target state="translated">커밋에서 수정 된 파일에서만 git-filter-branch를 작동 시키려고하면 두 가지 일이 발생합니다.</target>
        </trans-unit>
        <trans-unit id="8c2ff328d40e63aa92549620e7b30dc7bd79b356" translate="yes" xml:space="preserve">
          <source>If you use any of the options marked &quot;Turns off &lt;code&gt;apply&lt;/code&gt;&quot; above, &lt;code&gt;git apply&lt;/code&gt; reads and outputs the requested information without actually applying the patch. Give this flag after those flags to also apply the patch.</source>
          <target state="translated">위에서 &quot;Turns off &lt;code&gt;apply&lt;/code&gt; &quot; 로 표시된 옵션을 사용하면 &lt;code&gt;git apply&lt;/code&gt; 는 실제로 패치를 적용하지 않고 요청 된 정보를 읽고 출력합니다. 패치를 적용하려면이 플래그 뒤에이 플래그를 지정하십시오.</target>
        </trans-unit>
        <trans-unit id="9ac6e5a034fc806d1c17415da5d8566070ff7060" translate="yes" xml:space="preserve">
          <source>If you use the rewrite rules from the example you &lt;strong&gt;might&lt;/strong&gt; also need something like the following in your gitweb configuration file (&lt;code&gt;/etc/gitweb.conf&lt;/code&gt; following example):</source>
          <target state="translated">예제에서 다시 쓰기 규칙을 사용하는 경우 gitweb 구성 파일 ( 예 : &lt;code&gt;/etc/gitweb.conf&lt;/code&gt; 다음)에 다음 과 같은 것이 필요할 &lt;strong&gt;수도&lt;/strong&gt; 있습니다 .</target>
        </trans-unit>
        <trans-unit id="7b6c2f4a6c5d4d8aeea38b5e0c4e8e111c81122f" translate="yes" xml:space="preserve">
          <source>If you want a shared repository, you will need to make a bare clone of the imported directory, as described above. Then treat the imported directory as another development clone for purposes of merging incremental imports.</source>
          <target state="translated">공유 리포지토리를 원할 경우 위에서 설명한대로 가져온 디렉터리를 완전 복제해야합니다. 그런 다음 증분 가져 오기를 병합하기 위해 가져온 디렉토리를 다른 개발 복제본으로 취급하십시오.</target>
        </trans-unit>
        <trans-unit id="f7444f839f8aa37b3a95b6650647c55221c170f1" translate="yes" xml:space="preserve">
          <source>If you want command input to still be interpreted as usual by &lt;code&gt;git rev-parse&lt;/code&gt; before the output is shell quoted, see the &lt;code&gt;--sq&lt;/code&gt; option.</source>
          <target state="translated">출력을 쉘 인용하기 전에 &lt;code&gt;git rev-parse&lt;/code&gt; 에서 명령 입력을 평소대로 해석 하려면 &lt;code&gt;--sq&lt;/code&gt; 옵션을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="54d050e248b6c4afcd2cdb81603440db07ba11e1" translate="yes" xml:space="preserve">
          <source>If you want to break the dependency of a repository cloned with &lt;code&gt;--shared&lt;/code&gt; on its source repository, you can simply run &lt;code&gt;git repack -a&lt;/code&gt; to copy all objects from the source repository into a pack in the cloned repository.</source>
          <target state="translated">소스 리포지토리에서 &lt;code&gt;--shared&lt;/code&gt; 로 복제 된 리포지토리의 종속성을 중단하려면 간단히 &lt;code&gt;git repack -a&lt;/code&gt; 를 실행 하여 소스 리포지토리의 모든 객체를 복제 된 리포지토리의 팩으로 복사하면됩니다.</target>
        </trans-unit>
        <trans-unit id="175eedbbcb252ccb8b65afc8343c53ee6468a326" translate="yes" xml:space="preserve">
          <source>If you want to check out &lt;code&gt;all&lt;/code&gt; C source files out of the index, you can say</source>
          <target state="translated">인덱스에서 &lt;code&gt;all&lt;/code&gt; C 소스 파일 을 체크 아웃하려면</target>
        </trans-unit>
        <trans-unit id="e8498bad4ba6680850d835a14e8199fc54c7601f" translate="yes" xml:space="preserve">
          <source>If you want to delete an entry for a multivar (like core.gitproxy above), you have to provide a regex matching the value of exactly one line.</source>
          <target state="translated">multivar의 항목을 삭제하려면 (위의 core.gitproxy와 같이) 정확히 한 줄의 값과 일치하는 정규식을 제공해야합니다.</target>
        </trans-unit>
        <trans-unit id="b6ce9e2807ee6d14a7a74a4824bf5e00e758331b" translate="yes" xml:space="preserve">
          <source>If you want to enable (or disable) this feature, it is easier to use the &lt;code&gt;core.fsmonitor&lt;/code&gt; configuration variable (see &lt;a href=&quot;git-config&quot;&gt;git-config[1]&lt;/a&gt;) than using the &lt;code&gt;--fsmonitor&lt;/code&gt; option to &lt;code&gt;git update-index&lt;/code&gt; in each repository, especially if you want to do so across all repositories you use, because you can set the configuration variable in your &lt;code&gt;$HOME/.gitconfig&lt;/code&gt; just once and have it affect all repositories you touch.</source>
          <target state="translated">이 기능을 활성화 또는 비활성화 하려면 &lt;code&gt;--fsmonitor&lt;/code&gt; 옵션을 사용하여 각 리포지토리에서 &lt;code&gt;git update-index&lt;/code&gt; 를 git 하는 것보다 &lt;code&gt;core.fsmonitor&lt;/code&gt; 구성 변수 ( &lt;a href=&quot;git-config&quot;&gt;git-config [1]&lt;/a&gt; 참조) 를 사용하는 것이 더 쉽습니다. &lt;code&gt;$HOME/.gitconfig&lt;/code&gt; 에서 구성 변수를 한 번만 설정하고 터치하는 모든 리포지토리에 영향을 줄 수 있기 때문에 사용하는 모든 리포지토리에서 그렇게하고 싶습니다 .</target>
        </trans-unit>
        <trans-unit id="fade353b5f9f7d0b204907810eaa983a2e094489" translate="yes" xml:space="preserve">
          <source>If you want to enable (or disable) this feature, it is easier to use the &lt;code&gt;core.untrackedCache&lt;/code&gt; configuration variable (see &lt;a href=&quot;git-config&quot;&gt;git-config[1]&lt;/a&gt;) than using the &lt;code&gt;--untracked-cache&lt;/code&gt; option to &lt;code&gt;git update-index&lt;/code&gt; in each repository, especially if you want to do so across all repositories you use, because you can set the configuration variable to &lt;code&gt;true&lt;/code&gt; (or &lt;code&gt;false&lt;/code&gt;) in your &lt;code&gt;$HOME/.gitconfig&lt;/code&gt; just once and have it affect all repositories you touch.</source>
          <target state="translated">이 기능을 활성화 또는 비활성화 하려면 &lt;code&gt;--untracked-cache&lt;/code&gt; 옵션을 사용하여 각 저장소에서 &lt;code&gt;git update-index&lt;/code&gt; 를 사용하는 것보다 &lt;code&gt;core.untrackedCache&lt;/code&gt; 구성 변수 ( &lt;a href=&quot;git-config&quot;&gt;git-config [1]&lt;/a&gt; 참조) 를 사용하는 것이 더 쉽습니다 . 특히 &lt;code&gt;$HOME/.gitconfig&lt;/code&gt; 에서 구성 변수를 &lt;code&gt;true&lt;/code&gt; (또는 &lt;code&gt;false&lt;/code&gt; )로 한 번만 설정하고 터치하는 모든 리포지토리에 영향을 줄 수 있기 때문에 사용하는 모든 리포지토리에서 수행하려는 경우 특히 그렇습니다 .</target>
        </trans-unit>
        <trans-unit id="58323cdd8a68e6e1cc6d62c47524db6593349b87" translate="yes" xml:space="preserve">
          <source>If you want to ensure that text files that any contributor introduces to the repository have their line endings normalized, you can set the &lt;code&gt;text&lt;/code&gt; attribute to &quot;auto&quot; for &lt;code&gt;all&lt;/code&gt; files.</source>
          <target state="translated">기고자가 저장소에 도입 한 텍스트 파일의 줄 끝이 정규화 되도록하려면 &lt;code&gt;all&lt;/code&gt; 파일에 대해 &lt;code&gt;text&lt;/code&gt; 속성을 &quot;auto&quot;로 설정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="46aa6af5bcc60a63656632720781ded6cb9a0464" translate="yes" xml:space="preserve">
          <source>If you want to fold two or more commits into one, replace the command &quot;pick&quot; for the second and subsequent commits with &quot;squash&quot; or &quot;fixup&quot;. If the commits had different authors, the folded commit will be attributed to the author of the first commit. The suggested commit message for the folded commit is the concatenation of the commit messages of the first commit and of those with the &quot;squash&quot; command, but omits the commit messages of commits with the &quot;fixup&quot; command.</source>
          <target state="translated">둘 이상의 커밋을 하나로 묶으려면 두 번째 및 이후 커밋에 대한 &quot;pick&quot;명령을 &quot;squash&quot;또는 &quot;fixup&quot;으로 바꾸십시오. 커밋에 다른 작성자가있는 경우 접힌 커밋은 첫 번째 커밋의 작성자에 기인합니다. 폴딩 된 커밋에 대해 제안 된 커밋 메시지는 첫 번째 커밋과 &quot;squash&quot;명령이있는 커밋 메시지의 연결이지만 &quot;fixup&quot;명령으로 커밋의 커밋 메시지는 생략합니다.</target>
        </trans-unit>
        <trans-unit id="a1fc176bf758306e3705a3dd88ad77db4fb55698" translate="yes" xml:space="preserve">
          <source>If you want to have one URL for both gitweb and your &lt;code&gt;http://&lt;/code&gt; repositories, you can configure Apache like this:</source>
          <target state="translated">gitweb과 &lt;code&gt;http://&lt;/code&gt; 저장소 모두에 대해 하나의 URL을 원한다면 다음 과 같이 Apache를 구성 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="23a694ff61b56e5a1054639701ce379b6eeb6564" translate="yes" xml:space="preserve">
          <source>If you want to know all the values for a multivar, do:</source>
          <target state="translated">multivar의 모든 값을 알고 싶다면 다음을 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="be838b052e83d8fa0d4980781547923358bc58d3" translate="yes" xml:space="preserve">
          <source>If you want to make a change within a submodule and you have a detached head, then you should create or checkout a branch, make your changes, publish the change within the submodule, and then update the superproject to reference the new commit:</source>
          <target state="translated">서브 모듈 내에서 변경을 원하고 헤드가 분리 된 경우, 브랜치를 작성 또는 체크 아웃하고, 변경을 수행하고, 서브 모듈 내에서 변경 사항을 공개 한 후 수퍼 프로젝트를 업데이트하여 새 커밋을 참조해야합니다.</target>
        </trans-unit>
        <trans-unit id="f02c3e1c88ba7fbd299965b88348f8af1bb2eec2" translate="yes" xml:space="preserve">
          <source>If you want to make sure that the output actually names an object in your object database and/or can be used as a specific type of object you require, you can add the &lt;code&gt;^{type}&lt;/code&gt; peeling operator to the parameter. For example, &lt;code&gt;git rev-parse &quot;$VAR^{commit}&quot;&lt;/code&gt; will make sure &lt;code&gt;$VAR&lt;/code&gt; names an existing object that is a commit-ish (i.e. a commit, or an annotated tag that points at a commit). To make sure that &lt;code&gt;$VAR&lt;/code&gt; names an existing object of any type, &lt;code&gt;git rev-parse &quot;$VAR^{object}&quot;&lt;/code&gt; can be used.</source>
          <target state="translated">출력이 실제로 오브젝트 데이터베이스에서 오브젝트의 이름을 지정하고 /하거나 필요한 특정 오브젝트 유형으로 사용될 수 있도록하려면 &lt;code&gt;^{type}&lt;/code&gt; 필링 연산자를 매개 변수에 추가 할 수 있습니다 . 예를 들어, &lt;code&gt;git rev-parse &quot;$VAR^{commit}&quot;&lt;/code&gt; 은 &lt;code&gt;$VAR&lt;/code&gt; 이름을 커밋 대상인 기존 객체 (예 : 커밋 또는 커밋을 가리키는 주석이 달린 태그)로 지정합니다. &lt;code&gt;$VAR&lt;/code&gt; 이 모든 유형의 기존 객체를 명명하도록 하기 위해 &lt;code&gt;git rev-parse &quot;$VAR^{object}&quot;&lt;/code&gt; 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="136531f3c928e37ad60b2649b3285deac4e99b46" translate="yes" xml:space="preserve">
          <source>If you want to refer to a git refspec that has characters that are not allowed by CVS, you have two options. First, it may just work to supply the git refspec directly to the appropriate CVS -r argument; some CVS clients don&amp;rsquo;t seem to do much sanity checking of the argument. Second, if that fails, you can use a special character escape mechanism that only uses characters that are valid in CVS tags. A sequence of 4 or 5 characters of the form (underscore (&lt;code&gt;&quot;_&quot;&lt;/code&gt;), dash (&lt;code&gt;&quot;-&quot;&lt;/code&gt;), one or two characters, and dash (&lt;code&gt;&quot;-&quot;&lt;/code&gt;)) can encode various characters based on the one or two letters: &lt;code&gt;&quot;s&quot;&lt;/code&gt; for slash (&lt;code&gt;&quot;/&quot;&lt;/code&gt;), &lt;code&gt;&quot;p&quot;&lt;/code&gt; for period (&lt;code&gt;&quot;.&quot;&lt;/code&gt;), &lt;code&gt;&quot;u&quot;&lt;/code&gt; for underscore (&lt;code&gt;&quot;_&quot;&lt;/code&gt;), or two hexadecimal digits for any byte value at all (typically an ASCII number, or perhaps a part of a UTF-8 encoded character).</source>
          <target state="translated">CVS에서 허용되지 않는 문자가있는 git refspec을 참조하려는 경우 두 가지 옵션이 있습니다. 먼저 git refspec을 적절한 CVS -r 인수에 직접 제공하는 것이 효과적 일 수 있습니다. 일부 CVS 클라이언트는 인수에 대한 온전한 검사를 수행하지 않는 것 같습니다. 두 번째로 실패하면 CVS 태그에서 유효한 문자 만 사용하는 특수 문자 이스케이프 메커니즘을 사용할 수 있습니다. 밑줄 ( &lt;code&gt;&quot;_&quot;&lt;/code&gt; ), 대시 ( &lt;code&gt;&quot;-&quot;&lt;/code&gt; ), 하나 또는 두 개의 문자 및 대시 ( &lt;code&gt;&quot;-&quot;&lt;/code&gt; ) 형식의 4 개 또는 5 개의 문자 시퀀스는 하나 또는 두 개의 문자를 기반으로 다양한 문자를 인코딩 할 수 있습니다. 슬래시는 &lt;code&gt;&quot;s&quot;&lt;/code&gt; ( &lt;code&gt;&quot;/&quot;&lt;/code&gt; ), 기간은 &lt;code&gt;&quot;p&quot;&lt;/code&gt; ( &lt;code&gt;&quot;.&quot;&lt;/code&gt; ), &lt;code&gt;&quot;u&quot;&lt;/code&gt; 밑줄 ( &lt;code&gt;&quot;_&quot;&lt;/code&gt; ) 또는 모든 바이트 값 (일반적으로 ASCII 번호 또는 UTF-8로 인코딩 된 문자의 일부)에 대한 두 개의 16 진수입니다.</target>
        </trans-unit>
        <trans-unit id="e8beaf63d7e0d62995b4c7a9252b3f2ea0574fab" translate="yes" xml:space="preserve">
          <source>If you want to replace many blobs, trees or commits that are part of a string of commits, you may just want to create a replacement string of commits and then only replace the commit at the tip of the target string of commits with the commit at the tip of the replacement string of commits.</source>
          <target state="translated">커밋 문자열의 일부인 많은 블롭, 트리 또는 커밋을 바꾸려면 커밋 대체 문자열을 만든 다음 커밋 대상 문자열의 끝에 커밋을 커밋으로 바꿉니다. 대체 커밋 문자열의 끝.</target>
        </trans-unit>
        <trans-unit id="44f075cf045ec7b6bbf9c6b54de29b3e2085d2d6" translate="yes" xml:space="preserve">
          <source>If you want to restore &lt;code&gt;all&lt;/code&gt; C source files to match the version in the index, you can say</source>
          <target state="translated">인덱스의 버전과 일치하도록 &lt;code&gt;all&lt;/code&gt; C 소스 파일 을 복원하려는 경우 다음 과 같이 말할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7bbbea69a50b6a93a6b75d0ba68d2bc45319d47b" translate="yes" xml:space="preserve">
          <source>If you want to rewrite URLs for push only, you can create a configuration section of the form:</source>
          <target state="translated">푸시 전용 URL을 다시 쓰려면 다음과 같은 형식의 구성 섹션을 만들 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="295a38729bbd2cc488fb271a44e4d101d6ee7a15" translate="yes" xml:space="preserve">
          <source>If you want to show differences between binary or specially-formatted blobs in your repository, you can choose to use either an external diff command, or to use textconv to convert them to a diff-able text format. Which method you choose depends on your exact situation.</source>
          <target state="translated">저장소에서 2 진 또는 특수 형식의 Blob 간의 차이점을 표시하려면 외부 diff 명령을 사용하거나 textconv를 사용하여이를 diff 가능한 텍스트 형식으로 변환하도록 선택할 수 있습니다. 어떤 방법을 선택 하느냐는 정확한 상황에 따라 다릅니다.</target>
        </trans-unit>
        <trans-unit id="e3f3cfd8a6d2a1c0d741f6415c0be4ad8848457f" translate="yes" xml:space="preserve">
          <source>If you want to show other people your bisection process, you can get a log using for example:</source>
          <target state="translated">다른 사람에게 이분법 프로세스를 표시하려면 다음과 같이 로그를 얻을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="07b554efbcde38cd3d8cb2b2cd3fe1b74a5f9d9d" translate="yes" xml:space="preserve">
          <source>If you want to start a disconnected history that records a set of paths that is totally different from the one of &lt;code&gt;&amp;lt;start_point&amp;gt;&lt;/code&gt;, then you should clear the index and the working tree right after creating the orphan branch by running &lt;code&gt;git rm -rf .&lt;/code&gt; from the top level of the working tree. Afterwards you will be ready to prepare your new files, repopulating the working tree, by copying them from elsewhere, extracting a tarball, etc.</source>
          <target state="translated">&lt;code&gt;&amp;lt;start_point&amp;gt;&lt;/code&gt; 와 완전히 다른 경로 세트를 기록하는 연결이 끊긴 히스토리를 시작 하려면 &lt;code&gt;git rm -rf .&lt;/code&gt; 를 실행하여 고아 브랜치를 작성한 후 색인 및 작업 트리를 지우십시오 . 작업 트리의 최상위 레벨에서 그런 다음 새 파일을 준비하고, 작업 트리를 다른 곳에 복사하거나, 타르볼을 추출하는 등의 작업 트리를 다시 채울 준비가됩니다.</target>
        </trans-unit>
        <trans-unit id="5dc24ba332edd3d8bebaa76b808aacd296106da2" translate="yes" xml:space="preserve">
          <source>If you want to start a new branch from a remote branch of the same name:</source>
          <target state="translated">동일한 이름의 원격 브랜치에서 새 브랜치를 시작하려면 다음을 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="b533f775f69c9c29e40e15bb405c24bc01b04dac" translate="yes" xml:space="preserve">
          <source>If you want to use gitweb with several project roots you can edit your Apache virtual host and gitweb configuration files in the following way.</source>
          <target state="translated">gitweb을 여러 프로젝트 루트와 함께 사용하려면 다음과 같은 방법으로 Apache 가상 호스트 및 gitweb 구성 파일을 편집 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="cced0d77bb2b4a5861e7555078781fd81234d732" translate="yes" xml:space="preserve">
          <source>If you want to, you can use &lt;code&gt;git cat-file&lt;/code&gt; to look at those objects, but you&amp;rsquo;ll have to use the object name, not the filename of the object:</source>
          <target state="translated">원하는 경우 &lt;code&gt;git cat-file&lt;/code&gt; 을 사용 하여 해당 객체를 볼 수 있지만 객체의 파일 이름이 아닌 객체 이름을 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="9eff57ed3284da22d90930841774b80f0270e4be" translate="yes" xml:space="preserve">
          <source>If you wish the exclude patterns to affect only certain repositories (instead of every repository for a given project), you may instead put them in a file in your repository named &lt;code&gt;.git/info/exclude&lt;/code&gt;, or in any file specified by the &lt;code&gt;core.excludesFile&lt;/code&gt; configuration variable. Some Git commands can also take exclude patterns directly on the command line. See &lt;a href=&quot;gitignore&quot;&gt;gitignore[5]&lt;/a&gt; for the details.</source>
          <target state="translated">제외 패턴이 특정 프로젝트의 모든 저장소 대신 특정 저장소에만 영향을 미치도록하려면 대신 &lt;code&gt;.git/info/exclude&lt;/code&gt; 라는 저장소의 파일 또는 &lt;code&gt;core.excludesFile&lt;/code&gt; 지정한 파일에 파일을 넣을 수 있습니다 . excludesFile 구성 변수. 일부 Git 명령은 명령 행에서 직접 제외 패턴을 사용할 수도 있습니다. 자세한 내용은 &lt;a href=&quot;gitignore&quot;&gt;gitignore [5]&lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="f3a956a01313129dd0835296263e6883d7abec99" translate="yes" xml:space="preserve">
          <source>If you wish to affect only a single repository (i.e., to assign attributes to files that are particular to one user&amp;rsquo;s workflow for that repository), then attributes should be placed in the &lt;code&gt;$GIT_DIR/info/attributes&lt;/code&gt; file. Attributes which should be version-controlled and distributed to other repositories (i.e., attributes of interest to all users) should go into &lt;code&gt;.gitattributes&lt;/code&gt; files. Attributes that should affect all repositories for a single user should be placed in a file specified by the &lt;code&gt;core.attributesFile&lt;/code&gt; configuration option (see &lt;a href=&quot;git-config&quot;&gt;git-config[1]&lt;/a&gt;). Its default value is $XDG_CONFIG_HOME/git/attributes. If $XDG_CONFIG_HOME is either not set or empty, $HOME/.config/git/attributes is used instead. Attributes for all users on a system should be placed in the &lt;code&gt;$(prefix)/etc/gitattributes&lt;/code&gt; file.</source>
          <target state="translated">단일 리포지토리에만 영향을 미치려면 (즉, 해당 리포지토리에 대한 한 사용자의 워크 플로에 특정한 파일에 속성을 할당하려는 경우) 속성은 &lt;code&gt;$GIT_DIR/info/attributes&lt;/code&gt; 파일에 배치해야 합니다. 버전 관리 및 다른 리포지토리에 배포해야하는 특성 (즉, 모든 사용자가 관심을 갖는 특성)은 &lt;code&gt;.gitattributes&lt;/code&gt; 파일 로 이동해야 합니다. 단일 사용자의 모든 저장소에 영향을 미치는 속성은 &lt;code&gt;core.attributesFile&lt;/code&gt; 구성 옵션에 의해 지정된 파일에 있어야합니다 ( &lt;a href=&quot;git-config&quot;&gt;git-config [1]&lt;/a&gt; 참조) .). 기본값은 $ XDG_CONFIG_HOME / git / attributes입니다. $ XDG_CONFIG_HOME이 설정되지 않았거나 비어 있지 않으면 $ HOME / .config / git / attributes가 대신 사용됩니다. 시스템의 모든 사용자에 대한 속성은 &lt;code&gt;$(prefix)/etc/gitattributes&lt;/code&gt; 파일에 있어야 합니다.</target>
        </trans-unit>
        <trans-unit id="8bef77486a59978a04a1c46b2c068b3863595296" translate="yes" xml:space="preserve">
          <source>If you work with other people, you will need commands listed in the &lt;a href=&quot;#PARTICIPANT&quot;&gt;Individual Developer (Participant)&lt;/a&gt; section as well.</source>
          <target state="translated">다른 사람과 함께 작업하는 경우 &lt;a href=&quot;#PARTICIPANT&quot;&gt;개별 개발자 (참가자)&lt;/a&gt; 섹션에 나열된 명령도 필요합니다 .</target>
        </trans-unit>
        <trans-unit id="4cb8198fe4b8e422fe561ded3cf681f52266950f" translate="yes" xml:space="preserve">
          <source>If you would like the daemon to exit early, forgetting all cached credentials before their timeout, you can issue an &lt;code&gt;exit&lt;/code&gt; action:</source>
          <target state="translated">데몬을 조기에 종료하고 시간 초과 전에 캐시 된 모든 자격 증명을 잊어 버리려면 &lt;code&gt;exit&lt;/code&gt; 조치를 발행 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="6fb92003fb885c97541d201047e1ea900190bac9" translate="yes" xml:space="preserve">
          <source>If you would like to use your own terms instead of &quot;bad&quot;/&quot;good&quot; or &quot;new&quot;/&quot;old&quot;, you can choose any names you like (except existing bisect subcommands like &lt;code&gt;reset&lt;/code&gt;, &lt;code&gt;start&lt;/code&gt;, &amp;hellip;​) by starting the bisection using</source>
          <target state="translated">&quot;bad&quot;/ &quot;good&quot;또는 &quot;new&quot;/ &quot;old&quot;대신 자신의 용어를 사용하려면 원하는 이름을 선택할 수 있습니다 ( &lt;code&gt;reset&lt;/code&gt; , &lt;code&gt;start&lt;/code&gt; 등의 기존 bisect 하위 명령 제외 ). 이등분</target>
        </trans-unit>
        <trans-unit id="ac9785fae40224d0d9d1a9569429bd18f0ceb511" translate="yes" xml:space="preserve">
          <source>If you&amp;rsquo;re releasing a new version of a software project, you may want to simultaneously make a changelog to include in the release announcement.</source>
          <target state="translated">새 버전의 소프트웨어 프로젝트를 배포하는 경우 릴리스 알림에 포함 할 변경 로그를 동시에 만들 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6cd2cc907ee3e17f5caea471b5027cb72158e075" translate="yes" xml:space="preserve">
          <source>If you&amp;rsquo;ve been committing small enough changes, you may now have a good shot at reconstructing the contents of the in-between state 4b9458b.</source>
          <target state="translated">충분히 작은 변경 사항을 적용한 경우 중간 상태 4b9458b의 내용을 재구성하는 데 도움이 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5516e4c9c575f8921939c0e95aa6e39fac3c93e0" translate="yes" xml:space="preserve">
          <source>If you&amp;rsquo;ve configured a web server that isn&amp;rsquo;t listed here for gitweb, please send in the instructions so they can be included in a future release.</source>
          <target state="translated">gitweb에 대해 여기에 나열되지 않은 웹 서버를 구성한 경우 이후 릴리스에 포함될 수 있도록 지침을 보내십시오.</target>
        </trans-unit>
        <trans-unit id="2ca9c9b64a14bae5a21173833d4a0e06ad289f34" translate="yes" xml:space="preserve">
          <source>If you&amp;rsquo;ve messed up the working tree, but haven&amp;rsquo;t yet committed your mistake, you can return the entire working tree to the last committed state with</source>
          <target state="translated">작업 트리를 망가 뜨 렸지만 아직 실수를 저 지르지 않은 경우 전체 작업 트리를 마지막 커밋 된 상태로 되돌릴 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7bdd278937e1b543d6e4ef46f26f74578bcd1798" translate="yes" xml:space="preserve">
          <source>If your branch was based on &amp;lt;upstream&amp;gt; but &amp;lt;upstream&amp;gt; was rewound and your branch contains commits which were dropped, this option can be used with &lt;code&gt;--keep-base&lt;/code&gt; in order to drop those commits from your branch.</source>
          <target state="translated">브랜치가 &amp;lt;upstream&amp;gt;을 기반으로했지만 &amp;lt;upstream&amp;gt;이 되 감고 브랜치에 삭제 된 커밋이 포함 된 경우이 옵션을 &lt;code&gt;--keep-base&lt;/code&gt; 와 함께 사용 하여 브랜치에서 커밋을 삭제할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="862f720d820aceb82a46583ae7c2b519ed5f9115" translate="yes" xml:space="preserve">
          <source>If your editor or some other system is running &lt;code&gt;git fetch&lt;/code&gt; in the background for you a way to mitigate this is to simply set up another remote:</source>
          <target state="translated">편집기 또는 다른 시스템이 백그라운드에서 &lt;code&gt;git fetch&lt;/code&gt; 를 실행중인 경우 이를 완화하는 방법은 다른 리모컨을 설정하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="6fc3997d817725ac54010e2c723e5760c4e0b90b" translate="yes" xml:space="preserve">
          <source>If your repository contains one or more submodules, then those submodules will appear based on which you initialized with the &lt;code&gt;git submodule&lt;/code&gt; command. If your sparse-checkout patterns exclude an initialized submodule, then that submodule will still appear in your working directory.</source>
          <target state="translated">저장소에 하나 이상의 하위 모듈이 포함 된 경우 &lt;code&gt;git submodule&lt;/code&gt; 명령으로 초기화 한 것을 기준으로 해당 하위 모듈이 나타납니다 . 스파 스 체크 아웃 패턴이 초기화 된 하위 모듈을 제외하더라도 해당 하위 모듈은 여전히 ​​작업 디렉토리에 나타납니다.</target>
        </trans-unit>
        <trans-unit id="17a3911595f90d594aeea889e0f0755079e1efba" translate="yes" xml:space="preserve">
          <source>If, in the middle of a bisect session, you know that the suggested revision is not a good one to test (e.g. it fails to build and you know that the failure does not have anything to do with the bug you are chasing), you can manually select a nearby commit and test that one instead.</source>
          <target state="translated">bisect 세션 중간에 제안 된 개정판이 테스트하기에 적합하지 않다는 것을 알고있는 경우 (예 : 빌드하지 못하고 실패가 추적하는 버그와 관련이 없음을 알고있는 경우) 근처 커밋을 수동으로 선택하고 대신 커밋을 테스트 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4eaf7ef623b220dfff5cf0aad12284c2791aab6b" translate="yes" xml:space="preserve">
          <source>Ignore carriage-return at the end of line when doing a comparison.</source>
          <target state="translated">비교할 때 줄 끝에서 캐리지 리턴을 무시하십시오.</target>
        </trans-unit>
        <trans-unit id="14129ef50a9ff92ecf5a9d9520de0a5438b9b27c" translate="yes" xml:space="preserve">
          <source>Ignore case differences between the patterns and the files.</source>
          <target state="translated">패턴과 파일의 대소 문자 차이를 무시하십시오.</target>
        </trans-unit>
        <trans-unit id="93adbe048de005f652abeded323ffca0e07802f9" translate="yes" xml:space="preserve">
          <source>Ignore changes in amount of whitespace. This ignores whitespace at line end, and considers all other sequences of one or more whitespace characters to be equivalent.</source>
          <target state="translated">공백 양의 변경을 무시하십시오. 이것은 줄 끝의 공백을 무시하고 하나 이상의 공백 문자의 다른 모든 시퀀스를 동등한 것으로 간주합니다.</target>
        </trans-unit>
        <trans-unit id="dceba3e490b99e465dabc6c0a6eb46378a762d2c" translate="yes" xml:space="preserve">
          <source>Ignore changes in whitespace at EOL.</source>
          <target state="translated">EOL에서 공백의 변경을 무시하십시오.</target>
        </trans-unit>
        <trans-unit id="0e8a5619a2125f597eccb060c4d8cfcacf8da768" translate="yes" xml:space="preserve">
          <source>Ignore changes made by the revision when assigning blame, as if the change never happened. Lines that were changed or added by an ignored commit will be blamed on the previous commit that changed that line or nearby lines. This option may be specified multiple times to ignore more than one revision. If the &lt;code&gt;blame.markIgnoredLines&lt;/code&gt; config option is set, then lines that were changed by an ignored commit and attributed to another commit will be marked with a &lt;code&gt;?&lt;/code&gt; in the blame output. If the &lt;code&gt;blame.markUnblamableLines&lt;/code&gt; config option is set, then those lines touched by an ignored commit that we could not attribute to another revision are marked with a &lt;code&gt;*&lt;/code&gt;.</source>
          <target state="translated">변경 사항이 발생하지 않은 것처럼 비난을 할당 할 때 개정판의 변경 사항은 무시하십시오. 무시 된 커밋으로 변경되거나 추가 된 라인은 해당 라인 또는 근처의 라인을 변경 한 이전 커밋에서 비난을받습니다. 이 옵션은 여러 개정을 무시하도록 여러 번 지정할 수 있습니다. 는 IF &lt;code&gt;blame.markIgnoredLines&lt;/code&gt; 설정 옵션을 설정, 다음 커밋 무시하고 다른에 기인으로 표시됩니다 커밋에 의해 변경된 라인이 &lt;code&gt;?&lt;/code&gt; 책임 출력에서. 는 IF &lt;code&gt;blame.markUnblamableLines&lt;/code&gt; 설정 옵션을 설정 한 후 무시 감동 그 라인은 우리가 다른 개정 속성이 표시되어 수 없음을 확약 &lt;code&gt;*&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="847c383f096e8b2857c23f7df697a300205d1cde" translate="yes" xml:space="preserve">
          <source>Ignore changes to submodules in the diff generation. &amp;lt;when&amp;gt; can be either &quot;none&quot;, &quot;untracked&quot;, &quot;dirty&quot; or &quot;all&quot;, which is the default. Using &quot;none&quot; will consider the submodule modified when it either contains untracked or modified files or its HEAD differs from the commit recorded in the superproject and can be used to override any settings of the &lt;code&gt;ignore&lt;/code&gt; option in &lt;a href=&quot;git-config&quot;&gt;git-config[1]&lt;/a&gt; or &lt;a href=&quot;gitmodules&quot;&gt;gitmodules[5]&lt;/a&gt;. When &quot;untracked&quot; is used submodules are not considered dirty when they only contain untracked content (but they are still scanned for modified content). Using &quot;dirty&quot; ignores all changes to the work tree of submodules, only changes to the commits stored in the superproject are shown (this was the behavior until 1.7.0). Using &quot;all&quot; hides all changes to submodules.</source>
          <target state="translated">diff 생성에서 하위 모듈에 대한 변경은 무시하십시오. &amp;lt;when&amp;gt;은 &quot;없음&quot;, &quot;추적되지 않은&quot;, &quot;더러운&quot;또는 &quot;모두&quot;(기본값) 일 수 있습니다. 그 중 하나가 superproject에 기록 된 커밋과는의 설정을 무시할 수 있습니다에서 추적되지 않는 파일이나 수정 된 파일 또는 HEAD의 다릅니다 포함되어있는 경우 &quot;없음&quot;을 사용하지 않는 것은 수정 된 서브 모듈을 고려할 것입니다 &lt;code&gt;ignore&lt;/code&gt; 에서 옵션 &lt;a href=&quot;git-config&quot;&gt;자식-설정 [1]&lt;/a&gt; 또는 &lt;a href=&quot;gitmodules&quot;&gt;gitmodules을 [ 5]&lt;/a&gt; . &quot;트래킹되지 않은&quot;이 사용될 때 서브 모듈은 추적되지 않은 컨텐츠 만 포함 할 때 더티로 간주되지 않지만 여전히 수정 된 컨텐츠를 스캔합니다. &quot;dirty&quot;를 사용하면 하위 모듈의 작업 트리에 대한 모든 변경 사항이 무시됩니다.수퍼 프로젝트에 저장된 커밋에 대한 변경 사항 만 표시됩니다 (1.7.0까지의 동작). &quot;all&quot;을 사용하면 하위 모듈에 대한 모든 변경 사항이 숨겨집니다.</target>
        </trans-unit>
        <trans-unit id="0a92f8e585ade182f513a5692eb0bb44a7e837dd" translate="yes" xml:space="preserve">
          <source>Ignore changes to submodules when looking for changes. &amp;lt;when&amp;gt; can be either &quot;none&quot;, &quot;untracked&quot;, &quot;dirty&quot; or &quot;all&quot;, which is the default. Using &quot;none&quot; will consider the submodule modified when it either contains untracked or modified files or its HEAD differs from the commit recorded in the superproject and can be used to override any settings of the &lt;code&gt;ignore&lt;/code&gt; option in &lt;a href=&quot;git-config&quot;&gt;git-config[1]&lt;/a&gt; or &lt;a href=&quot;gitmodules&quot;&gt;gitmodules[5]&lt;/a&gt;. When &quot;untracked&quot; is used submodules are not considered dirty when they only contain untracked content (but they are still scanned for modified content). Using &quot;dirty&quot; ignores all changes to the work tree of submodules, only changes to the commits stored in the superproject are shown (this was the behavior before 1.7.0). Using &quot;all&quot; hides all changes to submodules (and suppresses the output of submodule summaries when the config option &lt;code&gt;status.submoduleSummary&lt;/code&gt; is set).</source>
          <target state="translated">변경 사항을 찾을 때 서브 모듈에 대한 변경 사항을 무시하십시오. &amp;lt;when&amp;gt;은 &quot;없음&quot;, &quot;추적되지 않은&quot;, &quot;더러운&quot;또는 &quot;모두&quot;(기본값) 일 수 있습니다. 그 중 하나가 superproject에 기록 된 커밋과는의 설정을 무시할 수 있습니다에서 추적되지 않는 파일이나 수정 된 파일 또는 HEAD의 다릅니다 포함되어있는 경우 &quot;없음&quot;을 사용하지 않는 것은 수정 된 서브 모듈을 고려할 것입니다 &lt;code&gt;ignore&lt;/code&gt; 에서 옵션 &lt;a href=&quot;git-config&quot;&gt;자식-설정 [1]&lt;/a&gt; 또는 &lt;a href=&quot;gitmodules&quot;&gt;gitmodules을 [ 5]&lt;/a&gt;. &quot;트래킹되지 않은&quot;이 사용될 때 서브 모듈은 추적되지 않은 컨텐츠 만 포함 할 때 더티로 간주되지 않지만 여전히 수정 된 컨텐츠를 스캔합니다. &quot;dirty&quot;를 사용하면 하위 모듈의 작업 트리에 대한 모든 변경 사항이 무시되고 수퍼 프로젝트에 저장된 커밋에 대한 변경 사항 만 표시됩니다 (1.7.0 이전의 동작). &quot;all&quot;을 사용하면 하위 모듈에 대한 모든 변경 사항이 숨겨지며 구성 옵션 &lt;code&gt;status.submoduleSummary&lt;/code&gt; 가 설정되어 있으면 하위 모듈 요약의 출력이 표시되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="f616e5a6b317fb9674ab4a6ecd11655583864222" translate="yes" xml:space="preserve">
          <source>Ignore changes whose lines are all blank.</source>
          <target state="translated">행이 모두 비어있는 변경 사항은 무시하십시오.</target>
        </trans-unit>
        <trans-unit id="6b93913a06aa23ba136e18a208983b558968a818" translate="yes" xml:space="preserve">
          <source>Ignore refs for branches or tags matching the Perl regular expression. A &quot;negative look-ahead assertion&quot; like &lt;code&gt;^refs/remotes/origin/(?!tags/wanted-tag|wanted-branch).*$&lt;/code&gt; can be used to allow only certain refs.</source>
          <target state="translated">Perl 정규식과 일치하는 분기 또는 태그에 대한 참조는 무시하십시오. &lt;code&gt;^refs/remotes/origin/(?!tags/wanted-tag|wanted-branch).*$&lt;/code&gt; 와 같은 &quot;부정적인 미리보기 어설 션&quot; . * $ 는 특정 참조 만 허용하는 데 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="cca615474ea8523b5665d433104181e17b949af0" translate="yes" xml:space="preserve">
          <source>Ignore revisions listed in &lt;code&gt;file&lt;/code&gt;, which must be in the same format as an &lt;code&gt;fsck.skipList&lt;/code&gt;. This option may be repeated, and these files will be processed after any files specified with the &lt;code&gt;blame.ignoreRevsFile&lt;/code&gt; config option. An empty file name, &lt;code&gt;&quot;&quot;&lt;/code&gt;, will clear the list of revs from previously processed files.</source>
          <target state="translated">&lt;code&gt;fsck.skipList&lt;/code&gt; 와 동일한 형식이어야하는 &lt;code&gt;file&lt;/code&gt; 나열된 개정을 무시하십시오 . 이 옵션은 반복 될 수 있으며 이러한 파일은 &lt;code&gt;blame.ignoreRevsFile&lt;/code&gt; 구성 옵션으로 지정된 파일 후에 처리됩니다 . 빈 파일 이름 &lt;code&gt;&quot;&quot;&lt;/code&gt; 은 이전에 처리 된 파일에서 개정 목록을 지 웁니다.</target>
        </trans-unit>
        <trans-unit id="0cee361918756e813fbfde1e81b931c608ea0bab" translate="yes" xml:space="preserve">
          <source>Ignore revisions listed in the file, one unabbreviated object name per line, in &lt;a href=&quot;git-blame&quot;&gt;git-blame[1]&lt;/a&gt;. Whitespace and comments beginning with &lt;code&gt;#&lt;/code&gt; are ignored. This option may be repeated multiple times. Empty file names will reset the list of ignored revisions. This option will be handled before the command line option &lt;code&gt;--ignore-revs-file&lt;/code&gt;.</source>
          <target state="translated">&lt;a href=&quot;git-blame&quot;&gt;git-blame [1]&lt;/a&gt; 에서 파일에 나열된 개정판 (한 줄에 하나의 축약되지 않은 객체 이름)을 무시하십시오 . &lt;code&gt;#&lt;/code&gt; 으로 시작하는 공백과 주석은 무시됩니다. 이 옵션은 여러 번 반복 될 수 있습니다. 빈 파일 이름은 무시 된 개정 목록을 재설정합니다. 이 옵션은 명령 행 옵션 &lt;code&gt;--ignore-revs-file&lt;/code&gt; 전에 처리 됩니다 .</target>
        </trans-unit>
        <trans-unit id="ecf2829d6b1d696605f65878628b97d7705cf8bc" translate="yes" xml:space="preserve">
          <source>Ignore scissors lines (see &lt;a href=&quot;git-mailinfo&quot;&gt;git-mailinfo[1]&lt;/a&gt;).</source>
          <target state="translated">가위 선은 무시하십시오 ( &lt;a href=&quot;git-mailinfo&quot;&gt;git-mailinfo [1] 참조&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="2348d1bd6f42459d3ee1b173782de699bb2835d4" translate="yes" xml:space="preserve">
          <source>Ignore scissors lines. Useful for overriding mailinfo.scissors settings.</source>
          <target state="translated">가위 선은 무시하십시오. mailinfo.scissors 설정을 재정의하는 데 유용합니다.</target>
        </trans-unit>
        <trans-unit id="b8c0493eeab50cd9f84c9bb7fb54695bfa5cd858" translate="yes" xml:space="preserve">
          <source>Ignore whitespace when comparing lines. This ignores differences even if one line has whitespace where the other line has none.</source>
          <target state="translated">행을 비교할 때 공백을 무시하십시오. 한 줄에 공백이 있고 다른 줄에는없는 경우에도 차이를 무시합니다.</target>
        </trans-unit>
        <trans-unit id="f41139f9e81b5ab318787773cf3063813dbcefdd" translate="yes" xml:space="preserve">
          <source>Ignore whitespace when comparing the parent&amp;rsquo;s version and the child&amp;rsquo;s to find where the lines came from.</source>
          <target state="translated">부모의 버전과 자식의 버전을 비교할 때 공백을 무시하고 행의 출처를 찾으십시오.</target>
        </trans-unit>
        <trans-unit id="67259bef7d0f56e262c4cda325ae4b91dc800c88" translate="yes" xml:space="preserve">
          <source>Ignored files are not listed, unless &lt;code&gt;--ignored&lt;/code&gt; option is in effect, in which case &lt;code&gt;XY&lt;/code&gt; are &lt;code&gt;!!&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;--ignored&lt;/code&gt; 옵션이 적용 되지 않으면 무시 된 파일이 나열되지 않습니다 .이 경우 &lt;code&gt;XY&lt;/code&gt; 는 &lt;code&gt;!!&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5a64e868764637ce6fa403b78bdbf74f10990fd5" translate="yes" xml:space="preserve">
          <source>Ignored items have the following format:</source>
          <target state="translated">무시 된 항목의 형식은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="fe5aad4a58f02d9cd03afd86649692db9ed515bd" translate="yes" xml:space="preserve">
          <source>Ignores missing files during a --refresh</source>
          <target state="translated">-새로 고침 중 누락 된 파일을 무시합니다</target>
        </trans-unit>
        <trans-unit id="87a5b84b90eaf9c6a4ea4cf7776f8cdbe987e92e" translate="yes" xml:space="preserve">
          <source>Ignoring files</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d83f269a97cfa5cb2870ace661718351e9ef1d6f" translate="yes" xml:space="preserve">
          <source>Imagine that on top of the public commit P, you applied well-known patches X, Y and Z from somebody else, and then built your three-patch series A, B, C, the history would be like:</source>
          <target state="translated">퍼블릭 커밋 P 위에 다른 누군가로부터 잘 알려진 패치 X, Y 및 Z를 적용한 다음 3 패치 시리즈 A, B, C를 빌드했다고 가정하십시오. 이력은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="220433d0f0fcbc1334d4126616d73a1ad095f039" translate="yes" xml:space="preserve">
          <source>Imagine that you built your work on your &lt;code&gt;master&lt;/code&gt; branch on top of the &lt;code&gt;v1.0&lt;/code&gt; release, and want it to be integrated to the project. First you push that change to your public repository for others to see:</source>
          <target state="translated">&lt;code&gt;v1.0&lt;/code&gt; 릴리스 위에 &lt;code&gt;master&lt;/code&gt; 브랜치에서 작업을 빌드 하고 프로젝트에 통합하려고한다고 가정하십시오. 먼저 다른 사람들이 볼 수 있도록 해당 변경 사항을 공용 저장소로 푸시합니다.</target>
        </trans-unit>
        <trans-unit id="d92dfaf42e4c06410357fc423fdf173e48ba5a6c" translate="yes" xml:space="preserve">
          <source>Imagine that you have to rebase what you have already published. You will have to bypass the &quot;must fast-forward&quot; rule in order to replace the history you originally published with the rebased history. If somebody else built on top of your original history while you are rebasing, the tip of the branch at the remote may advance with her commit, and blindly pushing with &lt;code&gt;--force&lt;/code&gt; will lose her work.</source>
          <target state="translated">이미 게시 한 내용을 리베이스해야한다고 상상해보십시오. 원래 게시 한 기록을 다시 기반 기록으로 바꾸려면 &quot;빠른 진행해야 함&quot;규칙을 무시해야합니다. 당신이 rebasing하는 동안 당신의 원래 역사 위에 다른 누군가가 지었다면, 원격지 지점의 끝이 그녀의 커밋으로 전진 할 수 있으며, 맹목적으로 &lt;code&gt;--force&lt;/code&gt; 를 밀면 그녀의 일을 잃을 것입니다.</target>
        </trans-unit>
        <trans-unit id="8a9ff0ad91f2190aebd8f7874a38eff49a81d587" translate="yes" xml:space="preserve">
          <source>Imagine this history:</source>
          <target state="translated">이 역사를 상상해보십시오.</target>
        </trans-unit>
        <trans-unit id="db144a77867a22b1db2aa0f495d3082ced7cfb54" translate="yes" xml:space="preserve">
          <source>Imitate &lt;code&gt;git clone&lt;/code&gt; but track only selected branches</source>
          <target state="translated">&lt;code&gt;git clone&lt;/code&gt; 모방 하지만 선택한 지점 만 추적</target>
        </trans-unit>
        <trans-unit id="4a694f013e1a15bee19331c0c7b9e3ce34840db9" translate="yes" xml:space="preserve">
          <source>Imitate a CVS server. See &lt;a href=&quot;git-cvsserver&quot;&gt;git-cvsserver[1]&lt;/a&gt;.</source>
          <target state="translated">CVS 서버를 모방합니다. &lt;a href=&quot;git-cvsserver&quot;&gt;git-cvsserver [1]을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="81ebe12aa11cc123fdb7f8c88133ffaff6347b23" translate="yes" xml:space="preserve">
          <source>Implementation details</source>
          <target state="translated">구현 세부 사항</target>
        </trans-unit>
        <trans-unit id="f1c03dca591efe03ac168cd03c30c9d29e88acc3" translate="yes" xml:space="preserve">
          <source>Import Now, Repack Later</source>
          <target state="translated">지금 가져 오기, 나중에 다시 포장</target>
        </trans-unit>
        <trans-unit id="b3e1462f677f3a661ca64753ac202708178b3a16" translate="yes" xml:space="preserve">
          <source>Import a GNU Arch repository into Git</source>
          <target state="translated">GNU Arch 리포지토리를 Git으로 가져 오기</target>
        </trans-unit>
        <trans-unit id="502aadd2b2c2382144812aea24a52e335147d4a4" translate="yes" xml:space="preserve">
          <source>Import all changes from both named depot paths into a single repository. Only files below these directories are included. There is not a subdirectory in Git for each &quot;proj1&quot; and &quot;proj2&quot;. You must use the &lt;code&gt;--destination&lt;/code&gt; option when specifying more than one depot path. The revision specifier must be specified identically on each depot path. If there are files in the depot paths with the same name, the path with the most recently updated version of the file is the one that appears in Git.</source>
          <target state="translated">이름이 지정된 두 저장소 경로의 모든 변경 사항을 단일 저장소로 가져 오십시오. 이 디렉토리 아래의 파일 만 포함됩니다. Git에는 각 &quot;proj1&quot;및 &quot;proj2&quot;에 대한 하위 디렉토리가 없습니다. 둘 이상의 저장소 경로를 지정할 때 &lt;code&gt;--destination&lt;/code&gt; 옵션을 사용해야합니다 . 개정 지정자는 각 저장소 경로에서 동일하게 지정되어야합니다. 저장소 경로에 이름이 같은 파일이 있으면 가장 최근에 업데이트 된 버전의 파일이있는 경로가 Git에 나타나는 경로입니다.</target>
        </trans-unit>
        <trans-unit id="90051e560d673faccfb0bfe61644ca104b05b719" translate="yes" xml:space="preserve">
          <source>Import all commits, including recent ones. cvsimport by default skips commits that have a timestamp less than 10 minutes ago.</source>
          <target state="translated">최근 커밋을 포함하여 모든 커밋을 가져옵니다. 기본적으로 cvsimport는 시간이 10 분 미만인 커밋을 건너 뜁니다.</target>
        </trans-unit>
        <trans-unit id="3ffbc41d8e969bcf6a3014a353f6e7a2bfd3e3ba" translate="yes" xml:space="preserve">
          <source>Import at most &lt;code&gt;n&lt;/code&gt; changes, rather than the entire range of changes included in the given revision specifier. A typical usage would be use &lt;code&gt;@all&lt;/code&gt; as the revision specifier, but then to use &lt;code&gt;--max-changes 1000&lt;/code&gt; to import only the last 1000 revisions rather than the entire revision history.</source>
          <target state="translated">지정된 수정 자에 포함 된 전체 변경 범위가 아닌 최대 &lt;code&gt;n&lt;/code&gt; 개의 변경 사항을 가져 옵니다. 일반적인 사용법은 &lt;code&gt;@all&lt;/code&gt; 을 개정 지정자로 사용하지만 &lt;code&gt;--max-changes 1000&lt;/code&gt; 을 사용 하여 전체 개정 내역이 아닌 마지막 1000 개정 만 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="a203d27ce8c09d6ab5f978bc976ed19c7da8bd29" translate="yes" xml:space="preserve">
          <source>Import changes into &amp;lt;ref&amp;gt; instead of refs/remotes/p4/master. If &amp;lt;ref&amp;gt; starts with refs/, it is used as is. Otherwise, if it does not start with p4/, that prefix is added.</source>
          <target state="translated">refs / remotes / p4 / master 대신 &amp;lt;ref&amp;gt;로 변경 사항을 가져옵니다. &amp;lt;ref&amp;gt;가 refs /로 시작하면 그대로 사용됩니다. 그렇지 않으면 p4 /로 시작하지 않으면 해당 접두사가 추가됩니다.</target>
        </trans-unit>
        <trans-unit id="3446130415616c26cfbd9b0cb3b27c636fdfb1f4" translate="yes" xml:space="preserve">
          <source>Import exactly the p4 change numbers listed in &lt;code&gt;file&lt;/code&gt;, one per line. Normally, &lt;code&gt;git p4&lt;/code&gt; inspects the current p4 repository state and detects the changes it should import.</source>
          <target state="translated">&lt;code&gt;file&lt;/code&gt; 에 나열된 p4 변경 번호를 한 줄에 하나씩 정확하게 가져옵니다 . 일반적으로 &lt;code&gt;git p4&lt;/code&gt; 는 현재 p4 저장소 상태를 검사하고 가져와야 할 변경 사항을 감지합니다.</target>
        </trans-unit>
        <trans-unit id="051514630860e82d8e6dfeb8000cb04203f0530f" translate="yes" xml:space="preserve">
          <source>Import from and submit to Perforce repositories</source>
          <target state="translated">Perforce 리포지토리에서 가져 오기 및 제출</target>
        </trans-unit>
        <trans-unit id="bc1da86269dd0fa043570d9e0331c263ee1c8e9b" translate="yes" xml:space="preserve">
          <source>Import labels from p4 into Git.</source>
          <target state="translated">p4에서 Git으로 레이블을 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="01c4fe3eff92a8abc6c7acba932cff943343d8ce" translate="yes" xml:space="preserve">
          <source>Import one commit for each change in the history of that depot path.</source>
          <target state="translated">해당 저장소 경로 히스토리의 각 변경 사항에 대해 하나의 커미트를 가져 오십시오.</target>
        </trans-unit>
        <trans-unit id="5fa6a825ca52ecc53990e4e3e6add862904fa4f4" translate="yes" xml:space="preserve">
          <source>Import one commit with all files in the &lt;code&gt;#head&lt;/code&gt; change under that tree.</source>
          <target state="translated">해당 트리 아래 의 &lt;code&gt;#head&lt;/code&gt; change 에있는 모든 파일과 함께 하나의 커밋을 가져 옵니다 .</target>
        </trans-unit>
        <trans-unit id="1a475e0c7f94606844ba9fa0d34742cd54c3d13c" translate="yes" xml:space="preserve">
          <source>Import only changes 1 through 6.</source>
          <target state="translated">변경 사항 1 ~ 6 만 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="e9848e9219c243527c0682e352e98364329421b1" translate="yes" xml:space="preserve">
          <source>Import p4 labels into git, as per --import-labels.</source>
          <target state="translated">--import-labels에 따라 p4 레이블을 git로 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="34d234038bf4e799d075c2933026167918f64329" translate="yes" xml:space="preserve">
          <source>Import p4 labels.</source>
          <target state="translated">p4 레이블을 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="2f4ea105dee6a1ad94ce6623f490fbb875775ee0" translate="yes" xml:space="preserve">
          <source>Import-only: don&amp;rsquo;t perform a checkout after importing. This option ensures the working directory and index remain untouched and will not create them if they do not exist.</source>
          <target state="translated">가져 오기 전용 : 가져 오기 후 체크 아웃을 수행하지 마십시오. 이 옵션은 작업 디렉토리 및 색인을 그대로 유지하고 존재하지 않는 경우 작성하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="4b6d6a30150a506f9b79caf45da5aecb76b0018e" translate="yes" xml:space="preserve">
          <source>Important</source>
          <target state="translated">Important</target>
        </trans-unit>
        <trans-unit id="a64c4afd3bd1cef7955450469801cfbdf061341b" translate="yes" xml:space="preserve">
          <source>Important note! If you have any local changes in these branches, then this merge will create a commit object in the history (with no local changes Git will simply do a &quot;fast-forward&quot; merge). Many people dislike the &quot;noise&quot; that this creates in the Linux history, so you should avoid doing this capriciously in the &lt;code&gt;release&lt;/code&gt; branch, as these noisy commits will become part of the permanent history when you ask Linus to pull from the release branch.</source>
          <target state="translated">중요 사항! 이러한 브랜치에 로컬 변경이있는 경우이 병합은 히스토리에 커밋 객체를 생성합니다 (로컬 변경없이 Git은 단순히 &quot;빨리 감기&quot;병합을 수행함). 많은 사람들이 이것이 리눅스 히스토리에서 생성되는 &quot;노이즈&quot;를 싫어하므로, 리노스가 &lt;code&gt;release&lt;/code&gt; 브랜치에서 가져 오도록 요청할 때 이러한 노이즈 커밋은 영구 히스토리의 일부가되므로 릴리스 브랜치 에서이를 신중하게 수행하지 않아야합니다 .</target>
        </trans-unit>
        <trans-unit id="a87b614cdbaa5301ddda5b9a1cda5205ccdf1bbc" translate="yes" xml:space="preserve">
          <source>Importing a cvs archive</source>
          <target state="translated">cvs 아카이브 가져 오기</target>
        </trans-unit>
        <trans-unit id="3e30801aed656938780d8d09defb05967bf70053" translate="yes" xml:space="preserve">
          <source>Importing a new project</source>
          <target state="translated">새 프로젝트 가져 오기</target>
        </trans-unit>
        <trans-unit id="7d3eb76e15d3e80f60fde0cbe9f4a9a66f1cc724" translate="yes" xml:space="preserve">
          <source>Importing or exporting patches:</source>
          <target state="translated">패치 가져 오기 또는 내보내기 :</target>
        </trans-unit>
        <trans-unit id="8c866a3a4bff8b0052306000b7abfebb33a38b38" translate="yes" xml:space="preserve">
          <source>Importing patches to a project</source>
          <target state="translated">프로젝트로 패치 가져 오기</target>
        </trans-unit>
        <trans-unit id="19051f1cf9bd70907beeecdf5147851f44537c38" translate="yes" xml:space="preserve">
          <source>Importing these tags as-is in Git is impossible without making at least one commit which &amp;ldquo;fixes up&amp;rdquo; the files to match the content of the tag. Use fast-import&amp;rsquo;s &lt;code&gt;reset&lt;/code&gt; command to reset a dummy branch outside of your normal branch space to the base commit for the tag, then commit one or more file fixup commits, and finally tag the dummy branch.</source>
          <target state="translated">태그의 내용과 일치하도록 파일을 &quot;수정&quot;하는 커밋을 하나 이상 만들지 않으면 Git에서 이러한 태그를 그대로 가져올 수 없습니다. fast-import의 &lt;code&gt;reset&lt;/code&gt; 명령을 사용 하여 일반 분기 공간 외부의 더미 분기를 태그의 기본 커밋으로 재설정 한 다음 하나 이상의 파일 수정 커밋을 커밋하고 마지막으로 더미 분기에 태그를 지정하십시오.</target>
        </trans-unit>
        <trans-unit id="ffa5110d0a0de3d5244ac22023669387afe15c4d" translate="yes" xml:space="preserve">
          <source>Imports a CVS repository into Git. It will either create a new repository, or incrementally import into an existing one.</source>
          <target state="translated">CVS 저장소를 Git으로 가져옵니다. 새 저장소를 작성하거나 기존 저장소로 점진적으로 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="189a5fab4172fe96418112b3abf1f29736c5a78f" translate="yes" xml:space="preserve">
          <source>Imports a project from one or more GNU Arch repositories. It will follow branches and repositories within the namespaces defined by the &amp;lt;archive/branch&amp;gt; parameters supplied. If it cannot find the remote branch a merge comes from it will just import it as a regular commit. If it can find it, it will mark it as a merge whenever possible (see discussion below).</source>
          <target state="translated">하나 이상의 GNU Arch 리포지토리에서 프로젝트를 가져옵니다. 제공된 &amp;lt;archive / branch&amp;gt; 매개 변수로 정의 된 네임 스페이스 내의 브랜치 및 저장소를 따릅니다. 원격 브랜치를 찾을 수 없으면 병합을 통해 일반 커밋으로 가져옵니다. 찾을 수 있으면 가능하면 병합으로 표시합니다 (아래 설명 참조).</target>
        </trans-unit>
        <trans-unit id="0e7ba011d44c49f30a4b102d2d50cfa93397d28b" translate="yes" xml:space="preserve">
          <source>Imports the full contents of the head revision from the given p4 depot path into a single commit in the Git branch &lt;code&gt;refs/remotes/p4/master&lt;/code&gt;.</source>
          <target state="translated">주어진 p4 저장소 경로에서 헤드 개정의 전체 내용을 Git 브랜치 &lt;code&gt;refs/remotes/p4/master&lt;/code&gt; 의 단일 커밋으로 가져옵니다 .</target>
        </trans-unit>
        <trans-unit id="bc75793944c924c387fa08f2263917093a9e6ee9" translate="yes" xml:space="preserve">
          <source>In &lt;a href=&quot;#def_SCM&quot;&gt;SCM&lt;/a&gt; jargon, &quot;cherry pick&quot; means to choose a subset of changes out of a series of changes (typically commits) and record them as a new series of changes on top of a different codebase. In Git, this is performed by the &quot;git cherry-pick&quot; command to extract the change introduced by an existing &lt;a href=&quot;#def_commit&quot;&gt;commit&lt;/a&gt; and to record it based on the tip of the current &lt;a href=&quot;#def_branch&quot;&gt;branch&lt;/a&gt; as a new commit.</source>
          <target state="translated">에서 &lt;a href=&quot;#def_SCM&quot;&gt;SCM&lt;/a&gt; 전문 용어 변경 (일반적으로 커밋)의 시리즈 중 변경의 일부를 선택하고 다른 코드베이스의 상단에 변화의 새로운 시리즈로 기록한다 &quot;는 의미 벚꽃 선택&quot;. Git에서는 &quot;git cherry-pick&quot;명령으로 기존 &lt;a href=&quot;#def_commit&quot;&gt;커밋이&lt;/a&gt; 도입 한 변경 사항을 추출 하고 현재 &lt;a href=&quot;#def_branch&quot;&gt;분기&lt;/a&gt; 의 끝을 기반으로 새 커밋으로 기록합니다.</target>
        </trans-unit>
        <trans-unit id="5a7b7bab83d67b10ed8bbe7275df22f645616a7a" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;--parseopt&lt;/code&gt; mode, &lt;code&gt;git rev-parse&lt;/code&gt; helps massaging options to bring to shell scripts the same facilities C builtins have. It works as an option normalizer (e.g. splits single switches aggregate values), a bit like &lt;code&gt;getopt(1)&lt;/code&gt; does.</source>
          <target state="translated">에서 &lt;code&gt;--parseopt&lt;/code&gt; 모드, &lt;code&gt;git rev-parse&lt;/code&gt; 스크립트를 C의 내장 명령은이 같은 시설 쉘을 가져다주는 옵션을 완화하는 데 도움이됩니다. &lt;code&gt;getopt(1)&lt;/code&gt; 과 비슷한 옵션 노멀 라이저 (예 : 단일 스위치 집계 값 분할 )로 작동합니다.</target>
        </trans-unit>
        <trans-unit id="a61808962b5b6bb1a272b1dd2c4e90c87c42eb63" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;--sq-quote&lt;/code&gt; mode, &lt;code&gt;git rev-parse&lt;/code&gt; echoes on the standard output a single line suitable for &lt;code&gt;sh(1)&lt;/code&gt;&lt;code&gt;eval&lt;/code&gt;. This line is made by normalizing the arguments following &lt;code&gt;--sq-quote&lt;/code&gt;. Nothing other than quoting the arguments is done.</source>
          <target state="translated">에서는 &lt;code&gt;--sq-quote&lt;/code&gt; 모드 &lt;code&gt;git rev-parse&lt;/code&gt; 표준 출력에 적합한 단일 라인 에코 &lt;code&gt;sh(1)&lt;/code&gt; &lt;code&gt;eval&lt;/code&gt; . 이 줄은 &lt;code&gt;--sq-quote&lt;/code&gt; 다음에 나오는 인수를 정규화하여 만들어집니다 . 인수를 인용하는 것 외에는 아무것도 수행되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="02025b63af6480e186ac72d3a5a618d5536d1d9c" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;--stdin&lt;/code&gt; mode, take lines in the format</source>
          <target state="translated">에서 &lt;code&gt;--stdin&lt;/code&gt; 옵션 모드 형식의 라인을</target>
        </trans-unit>
        <trans-unit id="46fb44ff2c3ae3502717728ebf0f15532f206b66" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;A&lt;/code&gt;, &lt;code&gt;foo&lt;/code&gt; contains just &amp;ldquo;foo&amp;rdquo;.</source>
          <target state="translated">에서 , &lt;code&gt;foo&lt;/code&gt; 그냥 &quot;foo는&quot;이 포함되어 있습니다. &lt;code&gt;A&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="0e95077ff33e18325bb9215a9cc5764269fc90de" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;dbDriver&lt;/code&gt; and &lt;code&gt;dbUser&lt;/code&gt; you can use the following variables:</source>
          <target state="translated">에서 &lt;code&gt;dbDriver&lt;/code&gt; 및 &lt;code&gt;dbUser&lt;/code&gt; 다음과 같은 변수를 사용할 수 있습니다 :</target>
        </trans-unit>
        <trans-unit id="6c351c60eb0e6d6c6a7b2ff86bb73c9f63bc0dc3" translate="yes" xml:space="preserve">
          <source>In Git 1.7.0 or later, to cancel a conflicting merge, use &lt;code&gt;git reset --merge&lt;/code&gt;. &lt;strong&gt;Warning&lt;/strong&gt;: In older versions of Git, running &lt;code&gt;git pull&lt;/code&gt; with uncommitted changes is discouraged: while possible, it leaves you in a state that may be hard to back out of in the case of a conflict.</source>
          <target state="translated">Git 1.7.0 이상에서 충돌하는 병합을 취소하려면 &lt;code&gt;git reset --merge&lt;/code&gt; 를 사용하십시오 . &lt;strong&gt;경고&lt;/strong&gt; : 이전 버전의 Git에서는 커밋되지 않은 변경 사항으로 &lt;code&gt;git pull&lt;/code&gt; 을 실행 하지 않는 것이 좋습니다. 가능한 경우 충돌이 발생했을 때 되돌릴 수없는 상태가됩니다.</target>
        </trans-unit>
        <trans-unit id="e5fbbb479d61fa23b446f30021dbc9109422a0ad" translate="yes" xml:space="preserve">
          <source>In Git like in many other Version Control Systems (VCS), the different states of the data that is managed by the system are called commits. And, as VCS are mostly used to manage software source code, sometimes &quot;interesting&quot; changes of behavior in the software are introduced in some commits.</source>
          <target state="translated">다른 많은 VCS (Version Control Systems)와 마찬가지로 Git에서는 시스템이 관리하는 데이터의 다른 상태를 커밋이라고합니다. 또한 VCS는 주로 소프트웨어 소스 코드를 관리하는 데 사용되므로 소프트웨어의 &quot;흥미로운&quot;동작 변경이 일부 커밋에 도입되기도합니다.</target>
        </trans-unit>
        <trans-unit id="8b9196b57e8598c90aa9a79e64e11940ec4bed09" translate="yes" xml:space="preserve">
          <source>In Git&amp;rsquo;s context, synonym for &lt;a href=&quot;#def_object_name&quot;&gt;object name&lt;/a&gt;.</source>
          <target state="translated">Git의 맥락에서 &lt;a href=&quot;#def_object_name&quot;&gt;object name&lt;/a&gt; 과 동의어입니다 .</target>
        </trans-unit>
        <trans-unit id="644d8f376b3ac284860f081b25e96334d4db2911" translate="yes" xml:space="preserve">
          <source>In Git, there are two kinds of tags, a &quot;light&quot; one, and an &quot;annotated tag&quot;.</source>
          <target state="translated">Git에는 &quot;light&quot;태그와 &quot;annotated tag&quot;태그가 있습니다.</target>
        </trans-unit>
        <trans-unit id="1e877f57bcce771b4a2551649d22c402a8ae8603" translate="yes" xml:space="preserve">
          <source>In SVN, it is possible (though discouraged) to commit changes to a tag (because a tag is just a directory copy, thus technically the same as a branch). When cloning an SVN repository, &lt;code&gt;git svn&lt;/code&gt; cannot know if such a commit to a tag will happen in the future. Thus it acts conservatively and imports all SVN tags as branches, prefixing the tag name with &lt;code&gt;tags/&lt;/code&gt;.</source>
          <target state="translated">SVN에서는 (태그가 디렉토리 사본이므로 기술적으로 브랜치와 동일하기 때문에) 태그에 변경 사항을 커밋 할 수 있습니다 (권장하지는 않음). SVN 저장소를 복제 할 때 &lt;code&gt;git svn&lt;/code&gt; 은 앞으로 태그에 대한 커밋이 발생하는지 알 수 없습니다. 따라서 보수적으로 작동하고 모든 SVN 태그를 분기로 가져오고 태그 이름 앞에 &lt;code&gt;tags/&lt;/code&gt; 붙입니다 .</target>
        </trans-unit>
        <trans-unit id="c215580302a5f52c2e27d45d0d7c1d84a4eccdbe" translate="yes" xml:space="preserve">
          <source>In Thunderbird 2: Edit..Preferences..Composition, wrap plain text messages at 0</source>
          <target state="translated">Thunderbird 2 : Edit..Preferences..Composition에서 일반 텍스트 메시지를 0으로 줄 바꿈</target>
        </trans-unit>
        <trans-unit id="f440374532f0b3d43494a1b042e56f8d4bce5f5d" translate="yes" xml:space="preserve">
          <source>In Thunderbird 3: Edit..Preferences..Advanced..Config Editor. Search for &quot;mail.wrap_long_lines&quot;. Toggle it to make sure it is set to &lt;code&gt;false&lt;/code&gt;. Also, search for &quot;mailnews.wraplength&quot; and set the value to 0.</source>
          <target state="translated">Thunderbird 3 : Edit..Preferences..Advanced..Config 편집기에서. &quot;mail.wrap_long_lines&quot;를 검색하십시오. &lt;code&gt;false&lt;/code&gt; 로 설정되도록 전환하십시오 . 또한 &quot;mailnews.wraplength&quot;를 검색하고 값을 0으로 설정하십시오.</target>
        </trans-unit>
        <trans-unit id="17583a69f7262368825714769d6089546a690b45" translate="yes" xml:space="preserve">
          <source>In a fast-forward update from A to B, the set of commits that the original commit A built on top of is a subset of the commits the new commit B builds on top of. Hence, it does not lose any history.</source>
          <target state="translated">A에서 B로 빨리 감기에서, 원래 커밋 A가 위에있는 커밋 세트는 새 커밋 B가 위에 커밋하는 커밋의 하위 집합입니다. 따라서 역사를 잃지 않습니다.</target>
        </trans-unit>
        <trans-unit id="3d5b5c31f19f75af08174ee7bc83bae8bb6f0e50" translate="yes" xml:space="preserve">
          <source>In a normal repository, this tends to work automatically. The objects are mostly reachable from the branches and tags, and that&amp;rsquo;s what clients fetch. Any deltas we find on the server are likely to be between objects the client has or will have.</source>
          <target state="translated">일반 리포지토리에서는 자동으로 작동하는 경향이 있습니다. 객체는 대부분 브랜치와 태그에서 접근 할 수 있으며 클라이언트가 가져옵니다. 서버에서 찾은 델타는 클라이언트가 가지고 있거나 가질 수있는 객체 사이에있을 가능성이 높습니다.</target>
        </trans-unit>
        <trans-unit id="566e8925a0c194716258bb9a397f522567172cf6" translate="yes" xml:space="preserve">
          <source>In a situation where topic consisted of three commits, and the maintainer applied two of them, the situation might look like:</source>
          <target state="translated">주제가 3 개의 커밋으로 구성되고 관리자가 2 개의 커밋을 적용한 경우 상황은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="ee8b5fc930f29435d4aa076d7196ceac4e277fb2" translate="yes" xml:space="preserve">
          <source>In a workflow employing relatively long lived topic branches, the developer sometimes needs to resolve the same conflicts over and over again until the topic branches are done (either merged to the &quot;release&quot; branch, or sent out and accepted upstream).</source>
          <target state="translated">상대적으로 오래 사용되는 토픽 브랜치를 사용하는 워크 플로우에서 개발자는 토픽 브랜치가 완료 될 때까지 ( &quot;릴리스&quot;브랜치로 병합되거나 업스트림으로 전송 및 승인 된) 동일한 충돌을 반복해서 해결해야하는 경우가 있습니다.</target>
        </trans-unit>
        <trans-unit id="f7c91952cc20e93e498fb039cc3dfb4469b10f04" translate="yes" xml:space="preserve">
          <source>In addition there are a number of other widely deployed hosting, browsing and reviewing solutions such as:</source>
          <target state="translated">또한 다음과 같은 널리 배포 된 다른 호스팅, 탐색 및 검토 솔루션이 많이 있습니다.</target>
        </trans-unit>
        <trans-unit id="666628046a18a0e7af967b1de7c1a7d7baa813ae" translate="yes" xml:space="preserve">
          <source>In addition to &lt;code&gt;--full-index&lt;/code&gt;, output a binary diff that can be applied with &lt;code&gt;git-apply&lt;/code&gt;. Implies &lt;code&gt;--patch&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;--full-index&lt;/code&gt; 외에도 &lt;code&gt;git-apply&lt;/code&gt; 로 적용 할 수있는 이진 diff를 출력하십시오 . &lt;code&gt;--patch&lt;/code&gt; 를 의미 합니다.</target>
        </trans-unit>
        <trans-unit id="3f6c767f6bc5922d93e508ae1661b26c77720a8f" translate="yes" xml:space="preserve">
          <source>In addition to &lt;code&gt;-M&lt;/code&gt;, detect lines moved or copied from other files that were modified in the same commit. This is useful when you reorganize your program and move code around across files. When this option is given twice, the command additionally looks for copies from other files in the commit that creates the file. When this option is given three times, the command additionally looks for copies from other files in any commit.</source>
          <target state="translated">&lt;code&gt;-M&lt;/code&gt; 외에도 동일한 커밋에서 수정 된 다른 파일에서 이동 또는 복사 된 행을 감지합니다. 프로그램을 재구성하고 파일간에 코드를 이동할 때 유용합니다. 이 옵션이 두 번 제공되면 명령은 파일을 작성하는 커밋의 다른 파일에서 사본을 추가로 찾습니다. 이 옵션이 세 번 제공되면 명령은 커밋에서 다른 파일의 복사본을 추가로 찾습니다.</target>
        </trans-unit>
        <trans-unit id="1888d5f31940dfed593ca4ff2d62ba84db0ce760" translate="yes" xml:space="preserve">
          <source>In addition to &lt;code&gt;.gitattributes&lt;/code&gt; (per-directory) and &lt;code&gt;.git/info/attributes&lt;/code&gt;, Git looks into this file for attributes (see &lt;a href=&quot;gitattributes&quot;&gt;gitattributes[5]&lt;/a&gt;). Path expansions are made the same way as for &lt;code&gt;core.excludesFile&lt;/code&gt;. Its default value is &lt;code&gt;$XDG_CONFIG_HOME/git/attributes&lt;/code&gt;. If &lt;code&gt;$XDG_CONFIG_HOME&lt;/code&gt; is either not set or empty, &lt;code&gt;$HOME/.config/git/attributes&lt;/code&gt; is used instead.</source>
          <target state="translated">뿐만 아니라 &lt;code&gt;.gitattributes&lt;/code&gt; (디렉토리 별) 및 &lt;code&gt;.git/info/attributes&lt;/code&gt; , 속성이 파일에 망할 놈의 외모 (참조 &lt;a href=&quot;gitattributes&quot;&gt;gitattributes을 [5]&lt;/a&gt; ). 경로 확장은 &lt;code&gt;core.excludesFile&lt;/code&gt; 과 동일한 방식으로 이루어집니다 . 기본값은 &lt;code&gt;$XDG_CONFIG_HOME/git/attributes&lt;/code&gt; 입니다. 경우 &lt;code&gt;$XDG_CONFIG_HOME&lt;/code&gt; 하나 설정하거나 비어 있지 않은, &lt;code&gt;$HOME/.config/git/attributes&lt;/code&gt; 대신 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="a80ff33db6a243344cb7df3dd9b8d8d41e916e5f" translate="yes" xml:space="preserve">
          <source>In addition to HEAD, there are several other special names for commits:</source>
          <target state="translated">HEAD 외에도 커밋에 대한 몇 가지 다른 특수 이름이 있습니다.</target>
        </trans-unit>
        <trans-unit id="3d952784176d6003ec5b2f9f790384bd9b8c8247" translate="yes" xml:space="preserve">
          <source>In addition to being the staging area for new commits, the index file is also populated from the object database when checking out a branch, and is used to hold the trees involved in a merge operation. See &lt;a href=&quot;gitcore-tutorial&quot;&gt;gitcore-tutorial[7]&lt;/a&gt; and the relevant man pages for details.</source>
          <target state="translated">새 커밋을위한 준비 영역 일뿐 아니라, 분기를 체크 아웃 할 때 인덱스 파일이 개체 데이터베이스에서 채워지고 병합 작업과 관련된 트리를 보유하는 데 사용됩니다. 자세한 내용은 &lt;a href=&quot;gitcore-tutorial&quot;&gt;gitcore-tutorial [7]&lt;/a&gt; 및 관련 매뉴얼 페이지를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="e26ec25b7f02c15aecd179e2dad4bd1f6afe8d5c" translate="yes" xml:space="preserve">
          <source>In addition to branch names, populate the log message with at most the specified number of one-line descriptions from the actual commits that are being merged. Defaults to false, and true is a synonym for 20.</source>
          <target state="translated">분기 이름 외에도 병합중인 실제 커밋의 최대 한 줄 설명으로 로그 메시지를 채 웁니다. 기본값은 false이며 true는 20과 동의어입니다.</target>
        </trans-unit>
        <trans-unit id="c5e07d7771d3e15091a04a68ed9a697dc979376c" translate="yes" xml:space="preserve">
          <source>In addition to branch names, populate the log message with one-line descriptions from at most &amp;lt;n&amp;gt; actual commits that are being merged. See also &lt;a href=&quot;git-fmt-merge-msg&quot;&gt;git-fmt-merge-msg[1]&lt;/a&gt;.</source>
          <target state="translated">분기 이름 외에도 병합중인 실제 커밋 최대 &amp;lt;n&amp;gt;에서 한 줄 설명으로 로그 메시지를 채 웁니다. &lt;a href=&quot;git-fmt-merge-msg&quot;&gt;git-fmt-merge-msg [1]&lt;/a&gt; 도 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="53e8184a4fded8ffd5d3887baaffe37015550f76" translate="yes" xml:space="preserve">
          <source>In addition to branch names, populate the log message with one-line descriptions from the actual commits that are being merged. At most &amp;lt;n&amp;gt; commits from each merge parent will be used (20 if &amp;lt;n&amp;gt; is omitted). This overrides the &lt;code&gt;merge.log&lt;/code&gt; configuration variable.</source>
          <target state="translated">분기 이름 외에도 병합중인 실제 커밋의 한 줄 설명으로 로그 메시지를 채 웁니다. 각 병합 상위의 최대 &amp;lt;n&amp;gt; 커밋이 사용됩니다 (&amp;lt;n&amp;gt;이 생략 된 경우 20). 이는 &lt;code&gt;merge.log&lt;/code&gt; 구성 변수를 대체합니다 .</target>
        </trans-unit>
        <trans-unit id="6235bcb46867554949f149e203ea63eff52ea516" translate="yes" xml:space="preserve">
          <source>In addition to branch names, populate the log message with the branch description text associated with them. Defaults to false.</source>
          <target state="translated">분기 이름 외에도 로그 메시지와 관련된 분기 설명 텍스트를 채 웁니다. 기본값은 false입니다.</target>
        </trans-unit>
        <trans-unit id="f62e3d2f843321847fb42ac94f40312c54d52ccf" translate="yes" xml:space="preserve">
          <source>In addition to labelling blobs and commits with mark ids, also label tags. This is useful in conjunction with &lt;code&gt;--export-marks&lt;/code&gt; and &lt;code&gt;--import-marks&lt;/code&gt;, and is also useful (and necessary) for exporting of nested tags. It does not hurt other cases and would be the default, but many fast-import frontends are not prepared to accept tags with mark identifiers.</source>
          <target state="translated">마크 ID를 사용하여 Blob 및 커밋에 레이블을 지정하는 것 외에도 레이블 태그도 지정합니다. 이는 &lt;code&gt;--export-marks&lt;/code&gt; 및 &lt;code&gt;--import-marks&lt;/code&gt; 와 함께 유용하며 중첩 된 태그를 내보내는데도 유용합니다 (필요한 경우). 다른 경우에는 영향을 미치지 않으며 기본값이지만, 빠른 가져 오기 프런트 엔드는 마크 식별자가있는 태그를 수락 할 준비가되어 있지 않습니다.</target>
        </trans-unit>
        <trans-unit id="22782295e6ea8ee2d620246684c55c016d61141f" translate="yes" xml:space="preserve">
          <source>In addition to objects reachable from any of our references, keep objects reachable from listed &amp;lt;head&amp;gt;s.</source>
          <target state="translated">참조에서 접근 할 수있는 객체 외에도 나열된 &amp;lt;head&amp;gt;에서 객체에 접근 할 수 있도록 유지하십시오.</target>
        </trans-unit>
        <trans-unit id="99c28f63ba36fb0fcaa38897708f95d9a693e369" translate="yes" xml:space="preserve">
          <source>In addition to saving you keystrokes, &lt;code&gt;git pull&lt;/code&gt; also helps you by producing a default commit message documenting the branch and repository that you pulled from.</source>
          <target state="translated">키 입력을 저장하는 것 외에도 &lt;code&gt;git pull&lt;/code&gt; 은 가져온 브랜치 및 리포지토리를 설명하는 기본 커밋 메시지를 생성하여 도움을줍니다.</target>
        </trans-unit>
        <trans-unit id="7129d0d8ea665296c3d9391d29a173f1ab2fc5f1" translate="yes" xml:space="preserve">
          <source>In addition to searching in the tracked files in the working tree, search also in untracked files.</source>
          <target state="translated">작업 트리에서 추적 된 파일을 검색 할뿐만 아니라 추적되지 않은 파일도 검색합니다.</target>
        </trans-unit>
        <trans-unit id="d5b7aa3ae2fa07bc2a7838db49f832f9fd332a95" translate="yes" xml:space="preserve">
          <source>In addition to the &lt;code&gt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&lt;/code&gt;, &lt;code&gt;=======&lt;/code&gt;, and &lt;code&gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&lt;/code&gt; markers, it uses another &lt;code&gt;|||||||&lt;/code&gt; marker that is followed by the original text. You can tell that the original just stated a fact, and your side simply gave in to that statement and gave up, while the other side tried to have a more positive attitude. You can sometimes come up with a better resolution by viewing the original.</source>
          <target state="translated">또한받는 &lt;code&gt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&lt;/code&gt; , &lt;code&gt;=======&lt;/code&gt; 및 &lt;code&gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&lt;/code&gt; 마커는 다른 사용 &lt;code&gt;|||||||&lt;/code&gt; 원본 텍스트 뒤에 표시됩니다. 당신은 원본이 사실을 말하고 당신 편이 단순히 그 진술을 포기하고 포기한 반면, 다른 쪽은 더 긍정적 인 태도를 가지려고 노력했다는 것을 알 수 있습니다. 원본을보고 더 나은 해상도를 얻을 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="3a9ee73184ef3bce8e3d7aa50aca9c03ee962a97" translate="yes" xml:space="preserve">
          <source>In addition to the &lt;code&gt;&amp;lt;commit&amp;gt;&lt;/code&gt; listed on the command line, read them from the standard input. If a &lt;code&gt;--&lt;/code&gt; separator is seen, stop reading commits and start reading paths to limit the result.</source>
          <target state="translated">명령 행에 나열된 &lt;code&gt;&amp;lt;commit&amp;gt;&lt;/code&gt; 외에도 표준 입력에서 읽습니다. 경우 &lt;code&gt;--&lt;/code&gt; 분리가 볼 수, 커밋 읽기를 중단하고 결과를 제한하는 경로를 읽기 시작합니다.</target>
        </trans-unit>
        <trans-unit id="e57f382f37af963780a48b9b24f281a677f73e3f" translate="yes" xml:space="preserve">
          <source>In addition to the above settings, you can change whether TREESAME affects inclusion:</source>
          <target state="translated">위의 설정 외에도 TREESAME가 포함에 영향을 미치는지 여부를 변경할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="15a1839e21183f6c87dd1989058c966575a3a5b3" translate="yes" xml:space="preserve">
          <source>In addition to the above two patterns, we also expect that all files in the root directory are included. If a recursive pattern is added, then all leading directories are added as parent patterns.</source>
          <target state="translated">위의 두 가지 패턴 외에도 루트 디렉토리의 모든 파일이 포함되어야합니다. 재귀 패턴이 추가되면 모든 선행 디렉토리가 상위 패턴으로 추가됩니다.</target>
        </trans-unit>
        <trans-unit id="5cdd7d140b9026d9dc5fc6d397fdc9a74057bb4e" translate="yes" xml:space="preserve">
          <source>In addition to the above, for commit and tag objects, the header field names (&lt;code&gt;tree&lt;/code&gt;, &lt;code&gt;parent&lt;/code&gt;, &lt;code&gt;object&lt;/code&gt;, &lt;code&gt;type&lt;/code&gt;, and &lt;code&gt;tag&lt;/code&gt;) can be used to specify the value in the header field.</source>
          <target state="translated">위의 커밋 및 태그 객체의 경우 헤더 필드 이름 ( &lt;code&gt;tree&lt;/code&gt; , &lt;code&gt;parent&lt;/code&gt; , &lt;code&gt;object&lt;/code&gt; , &lt;code&gt;type&lt;/code&gt; 및 &lt;code&gt;tag&lt;/code&gt; )을 사용하여 헤더 필드에 값을 지정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4a3a21fa25ba67eb3d7f9da7f4344fe1b071989c" translate="yes" xml:space="preserve">
          <source>In addition to the names of files that have been changed, also show the textual changes that are staged to be committed (i.e., like the output of &lt;code&gt;git diff --cached&lt;/code&gt;). If &lt;code&gt;-v&lt;/code&gt; is specified twice, then also show the changes in the working tree that have not yet been staged (i.e., like the output of &lt;code&gt;git diff&lt;/code&gt;).</source>
          <target state="translated">변경된 파일 이름 외에도 커밋되기 위해 준비된 텍스트 변경 사항도 표시합니다 (예 : &lt;code&gt;git diff --cached&lt;/code&gt; 출력 ). &lt;code&gt;-v&lt;/code&gt; 가 두 번 지정 되면 아직 준비되지 않은 작업 트리의 변경 사항도 표시합니다 (예 : &lt;code&gt;git diff&lt;/code&gt; 출력 ).</target>
        </trans-unit>
        <trans-unit id="9d2884340103002807461c187c73c074fbbd3657" translate="yes" xml:space="preserve">
          <source>In addition to the object pointed by it, show the underlying ref pointed by it when showing a symbolic ref. Currently, upload-pack only shows the symref HEAD, so it will be the only one shown by ls-remote.</source>
          <target state="translated">객체가 가리키는 객체 외에도 상징적 참조를 표시 할 때 객체가 가리키는 기본 참조를 표시합니다. 현재 upload-pack은 symref HEAD 만 표시하므로 ls-remote가 표시하는 유일한 것입니다.</target>
        </trans-unit>
        <trans-unit id="6c7a07603f44cd9719a4b680d9f7256b9473029e" translate="yes" xml:space="preserve">
          <source>In addition to the patches, generate a cover letter file containing the branch description, shortlog and the overall diffstat. You can fill in a description in the file before sending it out.</source>
          <target state="translated">패치 외에도 분기 설명, 짧은 로그 및 전체 diffstat를 포함하는 표지 파일을 생성하십시오. 파일을 보내기 전에 파일에 설명을 입력 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="102ba20e10a0928862b597a4b85d8411aa7a16cb" translate="yes" xml:space="preserve">
          <source>In addition to the text-based messages available in &lt;code&gt;GIT_TRACE2&lt;/code&gt;, this setting writes a column-based format for understanding nesting regions. See &lt;code&gt;GIT_TRACE2&lt;/code&gt; for available trace output options and &lt;a href=&quot;api-trace2&quot;&gt;Trace2 documentation&lt;/a&gt; for full details.</source>
          <target state="translated">&lt;code&gt;GIT_TRACE2&lt;/code&gt; 에서 사용 가능한 텍스트 기반 메시지 외에도이 설정은 중첩 영역을 이해하기위한 열 기반 형식을 씁니다. 사용 가능한 추적 출력 옵션 은 &lt;code&gt;GIT_TRACE2&lt;/code&gt; 및 자세한 내용은 &lt;a href=&quot;api-trace2&quot;&gt;Trace2 설명서&lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="547bdce4dd37bfda9e1c54bdf493ad3c6de08ff9" translate="yes" xml:space="preserve">
          <source>In addition, any unrecognized string that has a &lt;code&gt;%&lt;/code&gt; in it is interpreted as if it has &lt;code&gt;tformat:&lt;/code&gt; in front of it. For example, these two are equivalent:</source>
          <target state="translated">또한 &lt;code&gt;%&lt;/code&gt; 가 포함 된 인식 할 수없는 문자열 은 앞에 &lt;code&gt;tformat:&lt;/code&gt; 있는 것처럼 해석됩니다 . 예를 들어이 두 가지는 동일합니다.</target>
        </trans-unit>
        <trans-unit id="bc74e38407c657e1d62a835de829f2a0637ff932" translate="yes" xml:space="preserve">
          <source>In addition, if the variable is set to &lt;code&gt;af_unix:[&amp;lt;socket_type&amp;gt;:]&amp;lt;absolute-pathname&amp;gt;&lt;/code&gt;, Git will try to open the path as a Unix Domain Socket. The socket type can be either &lt;code&gt;stream&lt;/code&gt; or &lt;code&gt;dgram&lt;/code&gt;.</source>
          <target state="translated">또한 변수가 &lt;code&gt;af_unix:[&amp;lt;socket_type&amp;gt;:]&amp;lt;absolute-pathname&amp;gt;&lt;/code&gt; 으로 설정 되면 Git은 Unix 도메인 소켓으로 경로를 열려고 시도합니다. 소켓 유형은 &lt;code&gt;stream&lt;/code&gt; 또는 &lt;code&gt;dgram&lt;/code&gt; 일 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="fdc73bece50193400c9954e5c33b0d5db46ea312" translate="yes" xml:space="preserve">
          <source>In addition, some Git commands (such as &lt;a href=&quot;git-show&quot;&gt;git-show[1]&lt;/a&gt; and &lt;a href=&quot;git-push&quot;&gt;git-push[1]&lt;/a&gt;) can also take revision parameters which denote other objects than commits, e.g. blobs (&quot;files&quot;) or trees (&quot;directories of files&quot;).</source>
          <target state="translated">또한 일부 Git 명령 (예 : &lt;a href=&quot;git-show&quot;&gt;git-show [1]&lt;/a&gt; 및 &lt;a href=&quot;git-push&quot;&gt;git-push [1]&lt;/a&gt; )은 커밋 이외의 다른 오브젝트를 나타내는 수정 매개 변수 (예 : Blob ( &quot;파일&quot;) 또는 트리 ( &quot;파일 디렉토리&quot;))를 사용할 수도 있습니다. ).</target>
        </trans-unit>
        <trans-unit id="9c0114752cc3965279675b92f9d509a7719a899c" translate="yes" xml:space="preserve">
          <source>In addition, the date part is accepted in the following formats: &lt;code&gt;YYYY.MM.DD&lt;/code&gt;, &lt;code&gt;MM/DD/YYYY&lt;/code&gt; and &lt;code&gt;DD.MM.YYYY&lt;/code&gt;.</source>
          <target state="translated">또한 날짜 부분은 &lt;code&gt;YYYY.MM.DD&lt;/code&gt; , &lt;code&gt;MM/DD/YYYY&lt;/code&gt; 및 &lt;code&gt;DD.MM.YYYY&lt;/code&gt; 형식으로 허용됩니다 .</target>
        </trans-unit>
        <trans-unit id="b090b5874a4f9cb2a75963ffefe67f7cff33a14b" translate="yes" xml:space="preserve">
          <source>In addition, the following pairs of options are incompatible:</source>
          <target state="translated">또한 다음 옵션 쌍은 호환되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="c9eac4f7a75d08c8d5ecd2f93cae76dbdd2c65fb" translate="yes" xml:space="preserve">
          <source>In addition, there are a number of optional keys:</source>
          <target state="translated">또한 여러 개의 선택적 키가 있습니다.</target>
        </trans-unit>
        <trans-unit id="3170175bde47695f8d16d1aa859fc39830538d4d" translate="yes" xml:space="preserve">
          <source>In all &quot;keep index&quot; cases, the index entry stays as in the original index file. If the entry is not up to date, &lt;code&gt;git read-tree&lt;/code&gt; keeps the copy in the work tree intact when operating under the -u flag.</source>
          <target state="translated">모든 &quot;인덱스 유지&quot;사례에서 인덱스 항목은 원본 인덱스 파일과 동일하게 유지됩니다. 항목이 최신이 아닌 경우, &lt;code&gt;git read-tree&lt;/code&gt; 는 -u 플래그로 작동 할 때 작업 트리의 사본을 그대로 유지합니다.</target>
        </trans-unit>
        <trans-unit id="518e45973547d44ae8b0cf643cea7c8e1439a6f7" translate="yes" xml:space="preserve">
          <source>In all of these cases, the commands themselves first optionally limit the two sets of files by any pathspecs given on their command-lines, and compare corresponding paths in the two resulting sets of files.</source>
          <target state="translated">이러한 모든 경우에, 명령 자체는 먼저 명령 행에 제공된 경로 스펙에 따라 두 파일 세트를 선택적으로 제한하고 두 결과 파일 세트의 해당 경로를 비교합니다.</target>
        </trans-unit>
        <trans-unit id="a976d8376129a573bbe9b45628bf2bdf5e1fe7e1" translate="yes" xml:space="preserve">
          <source>In an environment that restricts the users' access only to git commands over the wire, this hook can be used to implement access control without relying on filesystem ownership and group membership. See &lt;a href=&quot;git-shell&quot;&gt;git-shell[1]&lt;/a&gt; for how you might use the login shell to restrict the user&amp;rsquo;s access to only git commands.</source>
          <target state="translated">유선으로 git 명령에 대해서만 사용자의 액세스를 제한하는 환경에서이 후크는 파일 시스템 소유권 및 그룹 멤버쉽에 의존하지 않고 액세스 제어를 구현하는 데 사용될 수 있습니다. 로그인 쉘을 사용하여 git 명령만으로 사용자의 액세스를 제한하는 방법 은 &lt;a href=&quot;git-shell&quot;&gt;git-shell [1]&lt;/a&gt; 을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="9220471bbc29ec41ed13c216a79cb80f852ef698" translate="yes" xml:space="preserve">
          <source>In any case, a field name that refers to a field inapplicable to the object referred by the ref does not cause an error. It returns an empty string instead.</source>
          <target state="translated">어쨌든 ref가 참조하는 객체에 적용 할 수없는 필드를 참조하는 필드 이름은 오류를 발생시키지 않습니다. 대신 빈 문자열을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="55cc553818c07e93d42b2d9a9da22e8f0487ba9d" translate="yes" xml:space="preserve">
          <source>In both formats &lt;code&gt;&amp;lt;commit-ish&amp;gt;&lt;/code&gt; is any of the commit specification expressions also accepted by &lt;code&gt;from&lt;/code&gt; (see above).</source>
          <target state="translated">두 형식 모두에서 &lt;code&gt;&amp;lt;commit-ish&amp;gt;&lt;/code&gt; 는 &lt;code&gt;from&lt;/code&gt; 에 의해 승인 된 커밋 사양 표현식 중 하나 입니다 (위 참조).</target>
        </trans-unit>
        <trans-unit id="9838d0f6a0615e5345bacba941fa3a7ae58fc03e" translate="yes" xml:space="preserve">
          <source>In both formats &lt;code&gt;&amp;lt;mode&amp;gt;&lt;/code&gt; is the type of file entry, specified in octal. Git only supports the following modes:</source>
          <target state="translated">두 가지 형식 모두에서 &lt;code&gt;&amp;lt;mode&amp;gt;&lt;/code&gt; 는 8 진수로 지정된 파일 항목 유형입니다. Git은 다음 모드 만 지원합니다 :</target>
        </trans-unit>
        <trans-unit id="e124f640b7099c2dfc555e83763a437b341aea9d" translate="yes" xml:space="preserve">
          <source>In both formats &lt;code&gt;&amp;lt;path&amp;gt;&lt;/code&gt; is the complete path of the file to be added (if not already existing) or modified (if already existing).</source>
          <target state="translated">두 형식 모두에서 &lt;code&gt;&amp;lt;path&amp;gt;&lt;/code&gt; 는 추가 (존재하지 않는 경우) 또는 수정 (존재하는 경우) 할 파일의 전체 경로입니다.</target>
        </trans-unit>
        <trans-unit id="e22465a192b99fdb8a38ceb6e2163b1bb2a55eaa" translate="yes" xml:space="preserve">
          <source>In both formats RS (the record separator) is newline by default but will be the null byte if -z was passed on the command line. The temporary file names are always safe strings; they will never contain directory separators or whitespace characters. The path field is always relative to the current directory and the temporary file names are always relative to the top level directory.</source>
          <target state="translated">두 형식 모두 RS (레코드 구분 기호)는 기본적으로 줄 바꿈이지만 명령 줄에 -z가 전달되면 널 바이트가됩니다. 임시 파일 이름은 항상 안전한 문자열입니다. 디렉토리 구분 기호 나 공백 문자는 절대 포함하지 않습니다. 경로 필드는 항상 현재 디렉토리를 기준으로하며 임시 파일 이름은 항상 최상위 디렉토리를 기준으로합니다.</target>
        </trans-unit>
        <trans-unit id="bbdfd88cae7c8d5fe4027454edb7c9f3a518f214" translate="yes" xml:space="preserve">
          <source>In both rename and copy detection, the same &quot;extent of changes&quot; algorithm used in diffcore-break is used to determine if two files are &quot;similar enough&quot;, and can be customized to use a similarity score different from the default of 50% by giving a number after the &quot;-M&quot; or &quot;-C&quot; option (e.g. &quot;-M8&quot; to tell it to use 8/10 = 80%).</source>
          <target state="translated">이름 바꾸기 및 복사 감지에서 diffcore-break에 사용 된 동일한 &quot;extent of changes&quot;알고리즘을 사용하여 두 파일이 &quot;충분히 유사한 지&quot;판별하고 기본값 50 %와 다른 유사성 점수를 사용하도록 사용자 정의 할 수 있습니다. &quot;-M&quot;또는 &quot;-C&quot;옵션 뒤에 숫자를 제공합니다 (예 : 8/10 = 80 %를 사용하도록 &quot;-M8&quot;).</target>
        </trans-unit>
        <trans-unit id="cef1680a7a27c73f800aa2ae728f37bb9ebeed5c" translate="yes" xml:space="preserve">
          <source>In case &amp;lt;old&amp;gt; and &amp;lt;new&amp;gt; are the same, and &amp;lt;old&amp;gt; is a file under &lt;code&gt;$GIT_DIR/remotes&lt;/code&gt; or &lt;code&gt;$GIT_DIR/branches&lt;/code&gt;, the remote is converted to the configuration file format.</source>
          <target state="translated">&amp;lt;old&amp;gt;와 &amp;lt;new&amp;gt;가 동일하고 &amp;lt;old&amp;gt;가 &lt;code&gt;$GIT_DIR/remotes&lt;/code&gt; 또는 &lt;code&gt;$GIT_DIR/branches&lt;/code&gt; 아래에있는 파일 인 경우, 리모트는 구성 파일 형식으로 변환됩니다.</target>
        </trans-unit>
        <trans-unit id="3736cf7c9e88d8830feeb4facce5d47bac7822e0" translate="yes" xml:space="preserve">
          <source>In case (some of) these environment variables are not set, the information is taken from the configuration items user.name and user.email, or, if not present, the environment variable EMAIL, or, if that is not set, system user name and the hostname used for outgoing mail (taken from &lt;code&gt;/etc/mailname&lt;/code&gt; and falling back to the fully qualified hostname when that file does not exist).</source>
          <target state="translated">이러한 환경 변수 중 일부가 설정되지 않은 경우 구성 항목 user.name 및 user.email 또는 환경 변수 EMAIL (설정되지 않은 경우 시스템 사용자)에서 정보를 가져옵니다. 발신 메일에 사용되는 이름 및 호스트 이름 ( &lt;code&gt;/etc/mailname&lt;/code&gt; 에서 가져와 해당 파일이 없을 때 정규화 된 호스트 이름으로 폴백 )</target>
        </trans-unit>
        <trans-unit id="fab172a52a0d96a15d352f159439993a534e8fe5" translate="yes" xml:space="preserve">
          <source>In case of conflict, &lt;code&gt;git rebase&lt;/code&gt; will stop at the first problematic commit and leave conflict markers in the tree. You can use &lt;code&gt;git diff&lt;/code&gt; to locate the markers (&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;) and make edits to resolve the conflict. For each file you edit, you need to tell Git that the conflict has been resolved, typically this would be done with</source>
          <target state="translated">충돌이 발생하는 경우, &lt;code&gt;git rebase&lt;/code&gt; 는 문제가있는 첫 커밋에서 중지하고 충돌 마커를 트리에 남겨 둡니다. &lt;code&gt;git diff&lt;/code&gt; 를 사용 하여 마커 (&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;)를 찾고 편집하여 충돌을 해결할 수 있습니다. 편집하는 각 파일에 대해 Git에 충돌이 해결되었다고 알려 주어야합니다.</target>
        </trans-unit>
        <trans-unit id="8de3ddb587a19db9387af113a7f3cb72b19328d0" translate="yes" xml:space="preserve">
          <source>In case of failure in the output of &lt;a href=&quot;git-rm&quot;&gt;git-rm[1]&lt;/a&gt;, show directions on how to proceed from the current state.</source>
          <target state="translated">&lt;a href=&quot;git-rm&quot;&gt;git-rm [1]&lt;/a&gt; 출력에 실패한 경우 현재 상태에서 진행하는 방법에 대한 지시 사항을 표시하십시오.</target>
        </trans-unit>
        <trans-unit id="1ca6e2b22c66fb3bb4920e7b16e070cab433e13d" translate="yes" xml:space="preserve">
          <source>In case the filter cannot or does not want to process the content as well as any future content for the lifetime of the Git process, then it is expected to respond with an &quot;abort&quot; status at any point in the protocol.</source>
          <target state="translated">필터가 Git 프로세스의 수명 동안 컨텐츠 및 향후 컨텐츠를 처리 할 수 ​​없거나 처리하지 않으려는 경우, 프로토콜의 어느 시점에서나 &quot;중단&quot;상태로 응답 할 것으로 예상됩니다.</target>
        </trans-unit>
        <trans-unit id="a44b155f3278323b322b1edffc06fec805c87137" translate="yes" xml:space="preserve">
          <source>In case the filter cannot or does not want to process the content, it is expected to respond with an &quot;error&quot; status.</source>
          <target state="translated">필터가 내용을 처리 할 수 ​​없거나 처리하지 않으려는 경우 &quot;오류&quot;상태로 응답합니다.</target>
        </trans-unit>
        <trans-unit id="063d2c577358a9002bf9810cc43ec764ca0682e1" translate="yes" xml:space="preserve">
          <source>In command synopses, the word &quot;tree-ish&quot; is sometimes used to designate such an argument.</source>
          <target state="translated">명령 시놉시스에서, &quot;tree-ish&quot;라는 단어는 때때로 그러한 주장을 지정하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="0cb56babf143d18da14e8d5b38b880de0eb432ae" translate="yes" xml:space="preserve">
          <source>In compact output mode, specified with configuration variable fetch.output, if either entire &lt;code&gt;&amp;lt;from&amp;gt;&lt;/code&gt; or &lt;code&gt;&amp;lt;to&amp;gt;&lt;/code&gt; is found in the other string, it will be substituted with &lt;code&gt;*&lt;/code&gt; in the other string. For example, &lt;code&gt;master -&amp;gt; origin/master&lt;/code&gt; becomes &lt;code&gt;master -&amp;gt; origin/*&lt;/code&gt;.</source>
          <target state="translated">구성 변수 fetch.output으로 지정된 컴팩트 출력 모드에서 전체 &lt;code&gt;&amp;lt;from&amp;gt;&lt;/code&gt; 또는 &lt;code&gt;&amp;lt;to&amp;gt;&lt;/code&gt; 가 다른 문자열에서 발견되면 다른 문자열에서 &lt;code&gt;*&lt;/code&gt; 로 대체됩니다 . 예를 들어 &lt;code&gt;master -&amp;gt; origin/master&lt;/code&gt; 는 &lt;code&gt;master -&amp;gt; origin/*&lt;/code&gt; 됩니다.</target>
        </trans-unit>
        <trans-unit id="17a206b483cbd4faf3ff1c681d69d041ba456195" translate="yes" xml:space="preserve">
          <source>In contrast to a regular interactive rebase, there are &lt;code&gt;label&lt;/code&gt;, &lt;code&gt;reset&lt;/code&gt; and &lt;code&gt;merge&lt;/code&gt; commands in addition to &lt;code&gt;pick&lt;/code&gt; ones.</source>
          <target state="translated">일반 대화 REBASE 대조적으로, 거기 &lt;code&gt;label&lt;/code&gt; , &lt;code&gt;reset&lt;/code&gt; 및 &lt;code&gt;merge&lt;/code&gt; 에 추가 명령을 &lt;code&gt;pick&lt;/code&gt; 것들.</target>
        </trans-unit>
        <trans-unit id="a91f8ccdcda758152dfb84f7e032555a6abd0478" translate="yes" xml:space="preserve">
          <source>In contrast, a non-fast-forward update will lose history. For example, suppose you and somebody else started at the same commit X, and you built a history leading to commit B while the other person built a history leading to commit A. The history looks like this:</source>
          <target state="translated">반대로 빨리 감기가 아닌 업데이트는 기록을 잃게됩니다. 예를 들어, 당신과 다른 누군가가 동일한 커밋 X에서 시작했다고 가정하고 B가 커밋하는 히스토리를 작성하고 다른 사람이 커밋 A로 이어지는 히스토리를 빌드했다고 가정하십시오. 히스토리는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="07b2f985753911580a2527f5513df7870e7e2eaf" translate="yes" xml:space="preserve">
          <source>In editing files, git-filter-branch by design checks out each and every commit as it existed in the original repo. If your repo has 10\^5 files and 10\^5 commits, but each commit only modifies 5 files, then git-filter-branch will make you do 10\^10 modifications, despite only having (at most) 5*10^5 unique blobs.</source>
          <target state="translated">파일을 편집 할 때 git-filter-branch는 의도적으로 원본 저장소에 존재하는 모든 커밋을 체크 아웃합니다. 리포지토리에 10 \ ^ 5 개의 파일과 10 \ ^ 5 개의 커밋이 있지만 각 커밋이 5 개의 파일 만 수정하면 git-filter-branch는 (최대) 5 * 10 만 있음에도 불구하고 10 \ ^ 10 수정을 수행합니다. ^ 5 개의 독특한 얼룩.</target>
        </trans-unit>
        <trans-unit id="a532459a44f155e770ddc46e416638b81292d839" translate="yes" xml:space="preserve">
          <source>In either format, values can be specified in any form that Git recognizes as an object name. Commands in any other format or a repeated &amp;lt;ref&amp;gt; produce an error. Command meanings are:</source>
          <target state="translated">어느 형식이든 값을 Git이 객체 이름으로 인식하는 모든 형식으로 지정할 수 있습니다. 다른 형식의 명령이나 반복되는 &amp;lt;ref&amp;gt; 명령은 오류를 생성합니다. 명령 의미는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="9c49e183be0df7128f7b7d238522888866505455" translate="yes" xml:space="preserve">
          <source>In fact development teams often maintain both a development branch and a maintenance branch, and it would be quite easy for them if &quot;git bisect&quot; just worked when they want to bisect a regression on the development branch that is not on the maintenance branch. They should be able to start bisecting using:</source>
          <target state="translated">실제로 개발 팀은 종종 개발 브랜치와 유지 관리 브랜치를 모두 유지 관리하며 유지 관리 브랜치가 아닌 개발 브랜치에서 회귀를 이등분하려고 할 때 &quot;git bisect&quot;가 제대로 작동하면 매우 쉽습니다. 다음을 사용하여 이등분을 시작할 수 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="49c9270dc1d07096e092a06d8107784ae1248f61" translate="yes" xml:space="preserve">
          <source>In fact it&amp;rsquo;s invaluable because there are bugs i would never even &lt;code&gt;try&lt;/code&gt; to debug if it wasn&amp;rsquo;t for git bisect. In the past there were bug patterns that were immediately hopeless for me to debug - at best i could send the crash/bug signature to lkml and hope that someone else can think of something.</source>
          <target state="translated">사실 git bisect가 아닌 경우 디버깅을 &lt;code&gt;try&lt;/code&gt; 하지 않는 버그가 있기 때문에 매우 중요 합니다. 과거에는 즉시 디버그 할 수 없었던 버그 패턴이있었습니다. 기껏해야 충돌 / 버그 서명을 lkml에 보내고 다른 사람이 무언가를 생각할 수 있기를 바랍니다.</target>
        </trans-unit>
        <trans-unit id="4d0defa9e6e327fdaa3580beb798bb05e9bb4ad4" translate="yes" xml:space="preserve">
          <source>In fact it&amp;rsquo;s this last feature that &quot;sold&quot; it to the Git community, so it is now in the &quot;master&quot; branch of Git&amp;rsquo;s Git repository and it should be released in Git 1.6.5 in October or November 2009.</source>
          <target state="translated">실제로이 기능은 Git 커뮤니티에 &quot;판매 된&quot;마지막 기능이므로 이제 Git Git 저장소의 &quot;마스터&quot;브랜치에 있으며 2009 년 10 월 또는 11 월에 Git 1.6.5에 출시 될 예정입니다.</target>
        </trans-unit>
        <trans-unit id="a503332ebe0b76ca226cc7fab9355da1cbc846ca" translate="yes" xml:space="preserve">
          <source>In fact people are specially interested in commits that introduce a &quot;bad&quot; behavior, called a bug or a regression. They are interested in these commits because a commit (hopefully) contains a very small set of source code changes. And it&amp;rsquo;s much easier to understand and properly fix a problem when you only need to check a very small set of changes, than when you don&amp;rsquo;t know where look in the first place.</source>
          <target state="translated">실제로 사람들은 버그 나 회귀라고하는 &quot;나쁜&quot;행동을 일으키는 커밋에 특히 관심이 있습니다. 커밋은 (아마도) 아주 작은 소스 코드 변경 사항을 포함하기 때문에 이러한 커밋에 관심이 있습니다. 또한 처음 어디에서 보이는지 알 수 없을 때보 다 아주 작은 변경 사항 만 확인하면 문제를 이해하고 올바르게 수정하는 것이 훨씬 쉽습니다.</target>
        </trans-unit>
        <trans-unit id="ef62eb9471b68497e696b504f306bae12d5b62ac" translate="yes" xml:space="preserve">
          <source>In fact the problem is that big software often has many different configuration options and that each test case should pass for each configuration after each commit. So if you have for each release: N configurations, M commits and T test cases, you should perform:</source>
          <target state="translated">실제로 문제는 큰 소프트웨어에는 종종 여러 가지 구성 옵션이 있으며 각 테스트 사례는 각 커밋 후에 각 구성에 대해 통과해야한다는 것입니다. 따라서 각 릴리스 (N 구성, M 커밋 및 T 테스트 사례)가있는 경우 다음을 수행해야합니다.</target>
        </trans-unit>
        <trans-unit id="99977c45d37760acd8d4612dba46dd63b60c39cd" translate="yes" xml:space="preserve">
          <source>In fact, &lt;code&gt;git bisect&lt;/code&gt; can be used to find the commit that changed &lt;strong&gt;any&lt;/strong&gt; property of your project; e.g., the commit that fixed a bug, or the commit that caused a benchmark&amp;rsquo;s performance to improve. To support this more general usage, the terms &quot;old&quot; and &quot;new&quot; can be used in place of &quot;good&quot; and &quot;bad&quot;, or you can choose your own terms. See section &quot;Alternate terms&quot; below for more information.</source>
          <target state="translated">사실, &lt;code&gt;git bisect&lt;/code&gt; (가) 그 변경 커밋 찾을 수 있습니다 &lt;strong&gt;어떤&lt;/strong&gt; 프로젝트의 속성, 예를 들어, 버그를 수정 한 커밋 또는 벤치 마크 성능을 향상시키는 커밋. 보다 일반적인 사용법을 지원하기 위해 &quot;좋은&quot;및 &quot;나쁜&quot;대신 &quot;오래된&quot;및 &quot;새&quot;라는 용어를 사용하거나 원하는 용어를 선택할 수 있습니다. 자세한 내용은 아래의 &quot;대체 용어&quot;섹션을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="7071f9821fe5bdd2a61f333d551d92b1d1a7cc62" translate="yes" xml:space="preserve">
          <source>In fact, &lt;code&gt;git diff-index --cached&lt;/code&gt;&lt;strong&gt;should&lt;/strong&gt; always be entirely equivalent to actually doing a &lt;code&gt;git write-tree&lt;/code&gt; and comparing that. Except this one is much nicer for the case where you just want to check where you are.</source>
          <target state="translated">실제로 &lt;code&gt;git diff-index --cached&lt;/code&gt; &lt;strong&gt;는&lt;/strong&gt; 항상 실제로 &lt;code&gt;git write-tree&lt;/code&gt; 를 수행 하고 비교하는 것과 완전히 동일 &lt;strong&gt;해야&lt;/strong&gt; 합니다. 이것을 제외하고는 당신이 어디에 있는지 확인하고 싶을 때 훨씬 좋습니다.</target>
        </trans-unit>
        <trans-unit id="4ed30cb15a7bebad154936439885b3df49088a74" translate="yes" xml:space="preserve">
          <source>In fact, as you did that, if you now look into your object directory, you&amp;rsquo;ll notice that Git will have added two new objects to the object database. If you did exactly the steps above, you should now be able to do</source>
          <target state="translated">실제로 그렇게했던 것처럼 이제 객체 디렉토리를 살펴보면 Git이 객체 데이터베이스에 두 개의 새로운 객체를 추가 한 것을 알 수 있습니다. 위의 단계를 정확하게 수행했다면 이제 할 수 있습니다</target>
        </trans-unit>
        <trans-unit id="c9492aea4e59a8249b05f0197902254019664286" translate="yes" xml:space="preserve">
          <source>In fact, if you have &lt;code&gt;master&lt;/code&gt; checked out, then this branch has been configured by &lt;code&gt;git clone&lt;/code&gt; to get changes from the HEAD branch of the origin repository. So often you can accomplish the above with just a simple</source>
          <target state="translated">실제로, &lt;code&gt;master&lt;/code&gt; 체크 아웃 한 경우이 분기는 &lt;code&gt;git clone&lt;/code&gt; 에 의해 오리진 저장소의 HEAD 분기에서 변경 사항을 가져 오도록 구성되었습니다 . 종종 간단한 방법으로 위의 내용을 달성 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c5bd224f8ecefe700eae1705d4f2a63ae227649f" translate="yes" xml:space="preserve">
          <source>In fact, in &lt;a href=&quot;#git-concepts&quot;&gt;Git concepts&lt;/a&gt; we shall see that everything stored in Git history, including file data and directory contents, is stored in an object with a name that is a hash of its contents.</source>
          <target state="translated">실제로 &lt;a href=&quot;#git-concepts&quot;&gt;Git 개념&lt;/a&gt; 에서는 파일 데이터 및 디렉토리 내용을 포함하여 Git 기록에 저장된 모든 내용이 해당 내용의 해시 이름을 가진 객체에 저장되어 있음을 알 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9ce4601e5a5f52f186df099525d9504862a821c8" translate="yes" xml:space="preserve">
          <source>In fact, together with the &lt;code&gt;git rev-list&lt;/code&gt; program (which generates a list of revisions), &lt;code&gt;git diff-tree&lt;/code&gt; ends up being a veritable fount of changes. You can emulate &lt;code&gt;git log&lt;/code&gt;, &lt;code&gt;git log -p&lt;/code&gt;, etc. with a trivial script that pipes the output of &lt;code&gt;git rev-list&lt;/code&gt; to &lt;code&gt;git diff-tree --stdin&lt;/code&gt;, which was exactly how early versions of &lt;code&gt;git log&lt;/code&gt; were implemented.</source>
          <target state="translated">사실, &lt;code&gt;git rev-list&lt;/code&gt; 프로그램 ( 개정판 목록 을 생성 함)과 함께 &lt;code&gt;git diff-tree&lt;/code&gt; 는 실제로 변경 사항이 있습니다. &lt;code&gt;git rev-list&lt;/code&gt; 의 출력 을 &lt;code&gt;git diff-tree --stdin&lt;/code&gt; 으로 파이프하는 간단한 스크립트로 &lt;code&gt;git log&lt;/code&gt; , &lt;code&gt;git log -p&lt;/code&gt; 등을 에뮬레이션 할 수 있습니다 . 이것은 &lt;code&gt;git log&lt;/code&gt; 의 초기 버전이 정확히 어떻게 구현 되었는지 입니다.</target>
        </trans-unit>
        <trans-unit id="da9de14a63db6e5a8e5a19a81e9a6160f95eb222" translate="yes" xml:space="preserve">
          <source>In fact, we can perform all the normal Git operations. But, let&amp;rsquo;s look at what happens when we then checkout &lt;code&gt;master&lt;/code&gt;:</source>
          <target state="translated">사실, 우리는 모든 정상적인 Git 작업을 수행 할 수 있습니다. 하지만 &lt;code&gt;master&lt;/code&gt; 를 체크 아웃 할 때 어떤 일이 발생하는지 봅시다 .</target>
        </trans-unit>
        <trans-unit id="728d90294e037628a986d3380572564cc895d389" translate="yes" xml:space="preserve">
          <source>In future versions we may learn to support patterns containing \0 for more search backends, until then we&amp;rsquo;ll die when the pattern type in question doesn&amp;rsquo;t support them.</source>
          <target state="translated">이후 버전에서는 더 많은 검색 백엔드에 대해 \ 0을 포함하는 패턴을 지원하는 방법을 배울 수 있습니다. 그때까지는 해당 패턴 유형이 지원하지 않으면 죽을 것입니다.</target>
        </trans-unit>
        <trans-unit id="674a2666658c40a25d4cd65b3ea28af975f1fa97" translate="yes" xml:space="preserve">
          <source>In general a client can request to speak protocol v2 by sending &lt;code&gt;version=2&lt;/code&gt; through the respective side-channel for the transport being used which inevitably sets &lt;code&gt;GIT_PROTOCOL&lt;/code&gt;. More information can be found in &lt;code&gt;pack-protocol.txt&lt;/code&gt; and &lt;code&gt;http-protocol.txt&lt;/code&gt;. In all cases the response from the server is the capability advertisement.</source>
          <target state="translated">일반적으로 클라이언트 는 &lt;code&gt;GIT_PROTOCOL&lt;/code&gt; 을 설정하는 사용중인 전송에 대해 각 사이드 채널을 통해 &lt;code&gt;version=2&lt;/code&gt; 를 전송하여 프로토콜 v2 말하기를 요청할 수 있습니다 . 자세한 정보는 &lt;code&gt;pack-protocol.txt&lt;/code&gt; 및 &lt;code&gt;http-protocol.txt&lt;/code&gt; 에서 찾을 수 있습니다 . 모든 경우에 서버의 응답은 기능 알림입니다.</target>
        </trans-unit>
        <trans-unit id="1aaa12db7c29bdac4538baf95940db6bed82a0b8" translate="yes" xml:space="preserve">
          <source>In general, URLs contain information about the transport protocol, the address of the remote server, and the path to the repository. Depending on the transport protocol, some of this information may be absent.</source>
          <target state="translated">일반적으로 URL에는 전송 프로토콜, 원격 서버 주소 및 리포지토리 경로에 대한 정보가 포함됩니다. 전송 프로토콜에 따라이 정보 중 일부가 없을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="811906db3a55c059a1cd7d72b959827c93f94a02" translate="yes" xml:space="preserve">
          <source>In general, all pseudo refs are per working tree and all refs starting with &quot;refs/&quot; are shared. Pseudo refs are ones like HEAD which are directly under GIT_DIR instead of inside GIT_DIR/refs. There is one exception to this: refs inside refs/bisect and refs/worktree is not shared.</source>
          <target state="translated">일반적으로 모든 의사 참조는 작업 트리 당이며 &quot;refs /&quot;로 시작하는 모든 참조는 공유됩니다. 의사 참조는 HEAD와 같은 것으로, GIT_DIR / refs 대신 GIT_DIR 바로 아래에 있습니다. 이에 대한 한 가지 예외가 있습니다. refs / bisect 내부의 refs와 refs / worktree는 공유되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="e394e7bf320940c252fcc858f73aeff38e0e3c05" translate="yes" xml:space="preserve">
          <source>In general, it is better to enumerate existing objects with problems with &lt;code&gt;fsck.skipList&lt;/code&gt;, instead of listing the kind of breakages these problematic objects share to be ignored, as doing the latter will allow new instances of the same breakages go unnoticed.</source>
          <target state="translated">일반적으로 &lt;code&gt;fsck.skipList&lt;/code&gt; 에 문제가있는 기존 객체를 열거하는 것이 좋습니다. 문제가있는 객체가 무시할 공유 유형을 나열하는 대신이를 무시하면 동일한 파손의 새 인스턴스가 눈에 띄지 않게됩니다.</target>
        </trans-unit>
        <trans-unit id="7dc03507399a3b4938c051e86309da2b5ba01f5b" translate="yes" xml:space="preserve">
          <source>In general, the interrogate commands do not touch the files in the working tree.</source>
          <target state="translated">일반적으로 질문 명령은 작업 트리의 파일을 건드리지 않습니다.</target>
        </trans-unit>
        <trans-unit id="0830c69bce9b1a4ab3ff9dbb3ca0e63e381af048" translate="yes" xml:space="preserve">
          <source>In general, using</source>
          <target state="translated">일반적으로</target>
        </trans-unit>
        <trans-unit id="37034b2d8b34e79ca4767d593d59ca39d0651fd5" translate="yes" xml:space="preserve">
          <source>In here all submodules except &lt;code&gt;baz&lt;/code&gt; (foo, bar, bob) are active. &lt;code&gt;foo&lt;/code&gt; due to its own active flag and all the others due to the submodule active pathspec, which specifies that any submodule starting with &lt;code&gt;b&lt;/code&gt; except &lt;code&gt;baz&lt;/code&gt; are also active, regardless of the presence of the .url field.</source>
          <target state="translated">여기에서 &lt;code&gt;baz&lt;/code&gt; (foo, bar, bob)를 제외한 모든 하위 모듈 이 활성화됩니다. &lt;code&gt;foo&lt;/code&gt; 에 의한 자체 활성 플래그 인한 서브 모듈로 시작 함을 지정하는 서브 모듈 활성 pathspec, 모든 다른 행 &lt;code&gt;b&lt;/code&gt; 제외 &lt;code&gt;baz&lt;/code&gt; 관계없이 .URL 필드의 존재, 또한 활성.</target>
        </trans-unit>
        <trans-unit id="f129c819372eb3b42173e4b2d9e114ef285b7635" translate="yes" xml:space="preserve">
          <source>In interactive commands, allow the user to provide one-letter input with a single key (i.e., without hitting enter). Currently this is used by the &lt;code&gt;--patch&lt;/code&gt; mode of &lt;a href=&quot;git-add&quot;&gt;git-add[1]&lt;/a&gt;, &lt;a href=&quot;git-checkout&quot;&gt;git-checkout[1]&lt;/a&gt;, &lt;a href=&quot;git-restore&quot;&gt;git-restore[1]&lt;/a&gt;, &lt;a href=&quot;git-commit&quot;&gt;git-commit[1]&lt;/a&gt;, &lt;a href=&quot;git-reset&quot;&gt;git-reset[1]&lt;/a&gt;, and &lt;a href=&quot;git-stash&quot;&gt;git-stash[1]&lt;/a&gt;. Note that this setting is silently ignored if portable keystroke input is not available; requires the Perl module Term::ReadKey.</source>
          <target state="translated">대화식 명령에서 사용자는 단일 문자 입력으로 단일 키를 제공 할 수 있습니다 (예 : Enter 키를 누르지 않음). 현재 이것은 &lt;a href=&quot;git-add&quot;&gt;git-add [1]&lt;/a&gt; , &lt;a href=&quot;git-checkout&quot;&gt;git-checkout [1]&lt;/a&gt; , &lt;a href=&quot;git-restore&quot;&gt;git-restore [1]&lt;/a&gt; , &lt;a href=&quot;git-commit&quot;&gt;git-commit [1]&lt;/a&gt; , &lt;a href=&quot;git-reset&quot;&gt;git-reset [1]&lt;/a&gt; 및 &lt;a href=&quot;git-stash&quot;&gt;git-stash &lt;/a&gt; &lt;code&gt;--patch&lt;/code&gt; 모드에서 사용됩니다 [1] . 휴대용 키 입력을 사용할 수없는 경우이 설정은 자동으로 무시됩니다. Perl 모듈 Term :: ReadKey가 필요합니다.</target>
        </trans-unit>
        <trans-unit id="1d1c8ed607ef3eefbb04beacb314688e02741550" translate="yes" xml:space="preserve">
          <source>In interactive mode, you can mark commits with the action &quot;edit&quot;. However, this does not necessarily mean that &lt;code&gt;git rebase&lt;/code&gt; expects the result of this edit to be exactly one commit. Indeed, you can undo the commit, or you can add other commits. This can be used to split a commit into two:</source>
          <target state="translated">대화식 모드에서 &quot;edit&quot;조치로 커미트를 표시 할 수 있습니다. 그러나 이것이 반드시 &lt;code&gt;git rebase&lt;/code&gt; 가이 편집의 결과가 정확히 하나의 커밋 일 것으로 기대 한다는 것을 의미하지는 않습니다 . 실제로 커밋을 취소하거나 다른 커밋을 추가 할 수 있습니다. 커밋을 두 개로 나누는 데 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="15b1add937944ed893f52c8ec0293a4127b76c00" translate="yes" xml:space="preserve">
          <source>In its first form, the command provides the content or the type of an object in the repository. The type is required unless &lt;code&gt;-t&lt;/code&gt; or &lt;code&gt;-p&lt;/code&gt; is used to find the object type, or &lt;code&gt;-s&lt;/code&gt; is used to find the object size, or &lt;code&gt;--textconv&lt;/code&gt; or &lt;code&gt;--filters&lt;/code&gt; is used (which imply type &quot;blob&quot;).</source>
          <target state="translated">첫 번째 형식으로, 명령은 저장소에있는 오브젝트의 컨텐츠 또는 유형을 제공합니다. &lt;code&gt;-t&lt;/code&gt; 또는 &lt;code&gt;-p&lt;/code&gt; 를 사용하여 객체 유형을 찾거나 &lt;code&gt;-s&lt;/code&gt; 를 사용하여 객체 크기를 찾거나 &lt;code&gt;--textconv&lt;/code&gt; 또는 &lt;code&gt;--filters&lt;/code&gt; ( &quot;blob&quot;를 의미)를 사용 하지 않는 한 유형이 필요합니다 .</target>
        </trans-unit>
        <trans-unit id="1ce9842f8f482fa7cd77bb4bd4603b72b75e4e0b" translate="yes" xml:space="preserve">
          <source>In its most compact form, this instruction only takes up one byte (0x80) with both offset and size omitted, which will have default values zero. There is another exception: size zero is automatically converted to 0x10000.</source>
          <target state="translated">가장 간단한 형식으로,이 명령어는 오프셋과 크기가 생략 된 1 바이트 (0x80) 만 사용하며 기본값은 0입니다. 또 다른 예외가 있습니다. 크기 0은 자동으로 0x10000으로 변환됩니다.</target>
        </trans-unit>
        <trans-unit id="70413e1dbdf33a9cdd6044f089c7e374f7b737c4" translate="yes" xml:space="preserve">
          <source>In mathematical terms, what we are looking for is some sort of a minimum cost bipartite matching; &lt;code&gt;1&lt;/code&gt; is matched to &lt;code&gt;C&lt;/code&gt; at some cost, etc. The underlying graph is in fact a complete bipartite graph; the cost we associate with every edge is the size of the diff between the two commits' patches. To explain also new commits, we introduce dummy nodes on both sides:</source>
          <target state="translated">수학적 용어로, 우리가 찾고있는 것은 일종의 최소 비용 이분법 일치입니다. &lt;code&gt;1&lt;/code&gt; 은 약간의 비용 등 으로 &lt;code&gt;C&lt;/code&gt; 와 일치합니다 . 기본 그래프는 사실상 완전한 이분 그래프입니다. 우리가 모든 에지와 연관시키는 비용은 두 커밋 패치 사이의 차이 크기입니다. 새로운 커밋도 설명하기 위해 양쪽에 더미 노드를 도입했습니다.</target>
        </trans-unit>
        <trans-unit id="abc4a2c282027431dbb87981bf40f5240785d9ef" translate="yes" xml:space="preserve">
          <source>In modern git, you can say this in a more direct way:</source>
          <target state="translated">현대 git에서는보다 직접적인 방법으로 이것을 말할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1cd9dc714cc1317fe8fea12649b27b5eeab6e568" translate="yes" xml:space="preserve">
          <source>In most cases, this means the attributes given in the input will be repeated in the output, but Git may also modify the credential description, for example by removing the &lt;code&gt;path&lt;/code&gt; attribute when the protocol is HTTP(s) and &lt;code&gt;credential.useHttpPath&lt;/code&gt; is false.</source>
          <target state="translated">대부분의 경우 이는 입력에 제공된 속성이 출력에서 ​​반복되지만 Git은 예를 들어 프로토콜이 HTTP (s)이고 &lt;code&gt;credential.useHttpPath&lt;/code&gt; 가 false 일 때 &lt;code&gt;path&lt;/code&gt; 속성 을 제거하여 자격 증명 설명을 수정할 수 있음을 의미합니다 .</target>
        </trans-unit>
        <trans-unit id="c12479d09bff69f421dbf9e45fddc92269d1f574" translate="yes" xml:space="preserve">
          <source>In most cases, users should run &lt;em&gt;git gc&lt;/em&gt;, which calls &lt;em&gt;git prune&lt;/em&gt;. See the section &quot;NOTES&quot;, below.</source>
          <target state="translated">대부분의 경우 사용자는 &lt;em&gt;git prune&lt;/em&gt; 을 호출 하는 &lt;em&gt;git gc를&lt;/em&gt; 실행해야합니다 . 아래의 &quot;노트&quot;섹션을 참조하십시오.&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="6d4e8e52070be526725731839d6ade7553803d5e" translate="yes" xml:space="preserve">
          <source>In most cases, users will not need to call &lt;code&gt;git prune&lt;/code&gt; directly, but should instead call &lt;code&gt;git gc&lt;/code&gt;, which handles pruning along with many other housekeeping tasks.</source>
          <target state="translated">대부분의 경우 사용자는 &lt;code&gt;git prune&lt;/code&gt; 을 직접 호출하지 않아도 되지만 대신 다른 많은 관리 작업과 함께 가지 치기를 처리하는 &lt;code&gt;git gc&lt;/code&gt; 를 호출해야 합니다.</target>
        </trans-unit>
        <trans-unit id="fa1d2a97ebd3bb9e2d938b11b92fc4a8e0c826fa" translate="yes" xml:space="preserve">
          <source>In multiple working trees, some refs may be shared between all working trees, some refs are local. One example is HEAD is different for all working trees. This section is about the sharing rules and how to access refs of one working tree from another.</source>
          <target state="translated">여러 작업 트리에서 일부 참조는 모든 작업 트리간에 공유 될 수 있으며 일부 참조는 로컬입니다. 한 가지 예는 HEAD가 모든 작업 트리에서 다르다는 것입니다. 이 섹션은 공유 규칙과 다른 작업 트리의 참조에 액세스하는 방법에 대한 것입니다.</target>
        </trans-unit>
        <trans-unit id="fef9e754382e4f5002bb7f83483631df5de227e1" translate="yes" xml:space="preserve">
          <source>In older Git versions it could be easily forgotten to commit new or modified files in a submodule, which silently leads to similar problems as not pushing the submodule changes. Starting with Git 1.7.0 both &lt;code&gt;git status&lt;/code&gt; and &lt;code&gt;git diff&lt;/code&gt; in the superproject show submodules as modified when they contain new or modified files to protect against accidentally committing such a state. &lt;code&gt;git
diff&lt;/code&gt; will also add a &lt;code&gt;-dirty&lt;/code&gt; to the work tree side when generating patch output or used with the &lt;code&gt;--submodule&lt;/code&gt; option:</source>
          <target state="translated">이전 Git 버전에서는 하위 모듈에서 새 파일이나 수정 된 파일을 커밋하는 것을 쉽게 잊어 버릴 수 있으며, 이로 인해 하위 모듈 변경 사항을 적용하지 않는 것과 유사한 문제가 발생합니다. Git 1.7.0부터는 superproject의 &lt;code&gt;git status&lt;/code&gt; 및 &lt;code&gt;git diff&lt;/code&gt; 가 하위 모듈에 새 파일 또는 수정 된 파일이 포함되어있을 때 실수로 그러한 상태를 커밋하는 것을 방지하기 위해 수정 된 것으로 표시됩니다. &lt;code&gt;git diff&lt;/code&gt; 는 패치 출력을 생성하거나 &lt;code&gt;--submodule&lt;/code&gt; 옵션 과 함께 사용할 때 작업 트리 측에 &lt;code&gt;-dirty&lt;/code&gt; 를 추가합니다 .</target>
        </trans-unit>
        <trans-unit id="cea51be0687534aeac695491ce11f4552163d8c9" translate="yes" xml:space="preserve">
          <source>In order to allow extensions that add extra data to the MIDX, we organize the body into &quot;chunks&quot; and provide a lookup table at the beginning of the body. The header includes certain length values, such as the number of packs, the number of base MIDX files, hash lengths and types.</source>
          <target state="translated">MIDX에 추가 데이터를 추가하는 확장을 허용하기 위해 본문을 &quot;청크&quot;로 구성하고 본문 시작 부분에 조회 테이블을 제공합니다. 헤더에는 팩 수, 기본 MIDX 파일 수, 해시 길이 및 유형과 같은 특정 길이 값이 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="f6b8f2c2e89120a466dd40e221531b6adf7a10b9" translate="yes" xml:space="preserve">
          <source>In order to determine what URL to use to fetch from, the value of the configuration &lt;code&gt;remote.&amp;lt;origin&amp;gt;.url&lt;/code&gt; is consulted and if there is not any such variable, the value on the &lt;code&gt;URL:&lt;/code&gt; line in &lt;code&gt;$GIT_DIR/remotes/&amp;lt;origin&amp;gt;&lt;/code&gt; is used.</source>
          <target state="translated">가져올 URL을 결정하기 위해 구성 &lt;code&gt;remote.&amp;lt;origin&amp;gt;.url&lt;/code&gt; 의 값을 참조하고 해당 변수가없는 경우 &lt;code&gt;$GIT_DIR/remotes/&amp;lt;origin&amp;gt;&lt;/code&gt; 의 &lt;code&gt;URL:&lt;/code&gt; 행에 있는 값 &amp;gt; 가 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="1bb65c849d69cb9e41866b99d141938531c8bf39" translate="yes" xml:space="preserve">
          <source>In order to determine what remote branches to fetch (and optionally store in the remote-tracking branches) when the command is run without any refspec parameters on the command line, values of the configuration variable &lt;code&gt;remote.&amp;lt;origin&amp;gt;.fetch&lt;/code&gt; are consulted, and if there aren&amp;rsquo;t any, &lt;code&gt;$GIT_DIR/remotes/&amp;lt;origin&amp;gt;&lt;/code&gt; is consulted and its &lt;code&gt;Pull:&lt;/code&gt; lines are used. In addition to the refspec formats described in the OPTIONS section, you can have a globbing refspec that looks like this:</source>
          <target state="translated">명령 행에서 refspec 매개 변수없이 명령을 실행할 때 가져올 원격 분기를 가져오고 선택적으로 원격 추적 분기에 저장할 원격 분기를 판별하기 위해 구성 변수 &lt;code&gt;remote.&amp;lt;origin&amp;gt;.fetch&lt;/code&gt; 의 값을 참조합니다. 없는 경우 &lt;code&gt;$GIT_DIR/remotes/&amp;lt;origin&amp;gt;&lt;/code&gt; 을 참조하고 &lt;code&gt;Pull:&lt;/code&gt; 행을 사용합니다. OPTIONS 섹션에 설명 된 refspec 형식 외에도 다음과 같은 globbing refspec을 가질 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b571757e7fe93a92c37f6bdbb5b1d110de433e8f" translate="yes" xml:space="preserve">
          <source>In order to ensure a current tracking branch state, &lt;code&gt;update --remote&lt;/code&gt; fetches the submodule&amp;rsquo;s remote repository before calculating the SHA-1. If you don&amp;rsquo;t want to fetch, you should use &lt;code&gt;submodule update
--remote --no-fetch&lt;/code&gt;.</source>
          <target state="translated">현재 추적 분기 상태를 보장하기 위해 &lt;code&gt;update --remote&lt;/code&gt; 는 SHA-1을 계산하기 전에 하위 모듈의 원격 저장소를 가져옵니다. 가져 오지 않으려면 &lt;code&gt;submodule update --remote --no-fetch&lt;/code&gt; 를 사용해야합니다 .</target>
        </trans-unit>
        <trans-unit id="9ecc869f1231e06aba76a745114504d0b9155917" translate="yes" xml:space="preserve">
          <source>In order to have configuration specific to working trees, you can turn on &quot;worktreeConfig&quot; extension, e.g.:</source>
          <target state="translated">작업 트리에 특정한 구성을 갖기 위해 다음과 같이 &quot;worktreeConfig&quot;확장을 켤 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="eb76ce16c3a3c52ec0347fc95609ba6324ad6c16" translate="yes" xml:space="preserve">
          <source>In order to protect the privacy of objects that have been removed from history but may not yet have been pruned, &lt;code&gt;git-upload-archive&lt;/code&gt; avoids serving archives for commits and trees that are not reachable from the repository&amp;rsquo;s refs. However, because calculating object reachability is computationally expensive, &lt;code&gt;git-upload-archive&lt;/code&gt; implements a stricter but easier-to-check set of rules:</source>
          <target state="translated">히스토리에서 제거되었지만 아직 정리되지 않은 오브젝트의 프라이버시를 보호하기 위해 &lt;code&gt;git-upload-archive&lt;/code&gt; 는 저장소 참조에서 도달 할 수없는 커밋 및 트리에 대한 아카이브를 제공하지 않습니다. 그러나 객체 도달 가능성을 계산하는 데 계산 비용이 많이 들기 때문에 &lt;code&gt;git-upload-archive&lt;/code&gt; 는 엄격하지만 확인하기 쉬운 규칙 세트를 구현합니다.</target>
        </trans-unit>
        <trans-unit id="17696fe6311cd47e2efc1108f911bdeb8c2c0989" translate="yes" xml:space="preserve">
          <source>In order to set &quot;assume unchanged&quot; bit, use &lt;code&gt;--assume-unchanged&lt;/code&gt; option. To unset, use &lt;code&gt;--no-assume-unchanged&lt;/code&gt;. To see which files have the &quot;assume unchanged&quot; bit set, use &lt;code&gt;git ls-files -v&lt;/code&gt; (see &lt;a href=&quot;git-ls-files&quot;&gt;git-ls-files[1]&lt;/a&gt;).</source>
          <target state="translated">&quot;변경되지 않은 가정&quot;비트를 설정하려면 &lt;code&gt;--assume-unchanged&lt;/code&gt; 옵션을 사용하십시오. 설정을 해제하려면 &lt;code&gt;--no-assume-unchanged&lt;/code&gt; 를 사용하십시오 . &quot;변경되지 않은 것으로 가정&quot;비트 세트가있는 파일을 보려면 &lt;code&gt;git ls-files -v&lt;/code&gt; 를 사용 하십시오 ( &lt;a href=&quot;git-ls-files&quot;&gt;git-ls-files [1] 참조&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="267b1e8e9ade7b3919e26586bb280b53787cfd98" translate="yes" xml:space="preserve">
          <source>In other messages Andreas says that they also use the &quot;best practices&quot; described above: small logical commits, topic branches, no evil merge,&amp;hellip;​ These practices all improve the bisectability of the commit graph, by making it easier and more useful to bisect.</source>
          <target state="translated">다른 메시지에서 Andreas는 작은 논리적 커밋, 토픽 브랜치, 사악한 병합이 아니라 위에서 설명한 &quot;모범 사례&quot;도 사용한다고 말합니다. 이러한 방식은 모두 커밋 그래프의 이등분 성을 개선하여 이분법을보다 쉽고 유용하게 만듭니다. .</target>
        </trans-unit>
        <trans-unit id="cbba08cd602a94910294469b1bfe69221cf43d34" translate="yes" xml:space="preserve">
          <source>In other words, &lt;code&gt;--merge&lt;/code&gt; does something like a &lt;code&gt;git read-tree -u -m &amp;lt;commit&amp;gt;&lt;/code&gt;, but carries forward unmerged index entries.</source>
          <target state="translated">즉, &lt;code&gt;--merge&lt;/code&gt; 는 &lt;code&gt;git read-tree -u -m &amp;lt;commit&amp;gt;&lt;/code&gt; 과 같은 작업을 수행하지만 병합되지 않은 인덱스 항목을 전달합니다.</target>
        </trans-unit>
        <trans-unit id="2c3347c08edbf67732cb77724b9990f6671bac50" translate="yes" xml:space="preserve">
          <source>In other words, &lt;code&gt;git diff-files&lt;/code&gt; always shows us the difference between what is recorded in the index, and what is currently in the working tree. That&amp;rsquo;s very useful.</source>
          <target state="translated">다시 말해, &lt;code&gt;git diff-files&lt;/code&gt; 는 항상 인덱스에 기록 된 것과 현재 작업 트리에있는 것과의 차이점을 보여줍니다. 매우 유용합니다.</target>
        </trans-unit>
        <trans-unit id="7466e77eb24cbec56937901c0950f635d6a29d08" translate="yes" xml:space="preserve">
          <source>In other words, &lt;code&gt;git diff-index&lt;/code&gt; normally compares a tree against the working tree, but when given the &lt;code&gt;--cached&lt;/code&gt; flag, it is told to instead compare against just the index cache contents, and ignore the current working tree state entirely. Since we just wrote the index file to HEAD, doing &lt;code&gt;git diff-index --cached -p HEAD&lt;/code&gt; should thus return an empty set of differences, and that&amp;rsquo;s exactly what it does.</source>
          <target state="translated">즉, &lt;code&gt;git diff-index&lt;/code&gt; 는 일반적으로 트리를 작업 트리와 비교하지만 &lt;code&gt;--cached&lt;/code&gt; 플래그 가 주어지면 대신 인덱스 캐시 내용과 비교하고 현재 작업 트리 상태를 완전히 무시하도록 지시합니다. 우리는 방금 색인 파일을 HEAD에 썼기 때문에 &lt;code&gt;git diff-index --cached -p HEAD&lt;/code&gt; 를 수행하면 빈 차이 집합이 반환되어야합니다. 이것이 바로 그 일입니다.</target>
        </trans-unit>
        <trans-unit id="8c2ef787b7de3a9f3b5df9786c452fde9692465e" translate="yes" xml:space="preserve">
          <source>In other words, there is no need to worry about what exists only in the working tree. When you have local changes in a part of the project that is not involved in the merge, your changes do not interfere with the merge, and are kept intact. When they &lt;strong&gt;do&lt;/strong&gt; interfere, the merge does not even start (&lt;code&gt;git read-tree&lt;/code&gt; complains loudly and fails without modifying anything). In such a case, you can simply continue doing what you were in the middle of doing, and when your working tree is ready (i.e. you have finished your work-in-progress), attempt the merge again.</source>
          <target state="translated">다시 말해, 작업 트리에만 존재하는 것에 대해 걱정할 필요가 없습니다. 병합과 관련이없는 프로젝트 부분에 로컬 변경이 있으면 변경 내용이 병합을 방해하지 않으며 그대로 유지됩니다. 그들이 때 &lt;strong&gt;않는&lt;/strong&gt; 방해, 병합도 (시작되지 않습니다 &lt;code&gt;git read-tree&lt;/code&gt; 큰 소리로 불평 아무것도 수정하지 않고 실패). 이 경우 작업 도중에 있던 작업을 계속하고 작업 트리가 준비된 경우 (즉, 진행중인 작업을 완료 한 경우) 다시 병합을 시도하십시오.</target>
        </trans-unit>
        <trans-unit id="5a674f35b2eda0a90a7f397ea7dadc5a212b7275" translate="yes" xml:space="preserve">
          <source>In other words, while a &quot;tree&quot; represents a particular directory state of a working directory, a &quot;commit&quot; represents that state in time, and explains how we got there.</source>
          <target state="translated">다시 말해, &quot;트리&quot;는 작업 디렉토리의 특정 디렉토리 상태를 나타내는 반면, &quot;커밋&quot;은 해당 상태를 시간으로 나타내며 어떻게 도착했는지를 설명합니다.</target>
        </trans-unit>
        <trans-unit id="857191c898a7fbefd37c145d86f76b0005dd57eb" translate="yes" xml:space="preserve">
          <source>In other words, you can easily validate a whole archive by just sending out a single email that tells the people the name (SHA-1 hash) of the top commit, and digitally sign that email using something like GPG/PGP.</source>
          <target state="translated">다시 말해, 사람들에게 최고 커밋의 이름 (SHA-1 해시)을 알려주는 단일 이메일을 발송하고 GPG / PGP와 같은 것을 사용하여 해당 이메일에 디지털 서명함으로써 전체 아카이브를 쉽게 검증 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e52122aac7e01b0550d02d6bfc5c4fbaa85b48ac" translate="yes" xml:space="preserve">
          <source>In our example of only two files, we did not have unchanged files so only &lt;code&gt;example&lt;/code&gt; resulted in collapsing. But in real-life large projects, when only a small number of files change in one commit, this &lt;code&gt;collapsing&lt;/code&gt; tends to trivially merge most of the paths fairly quickly, leaving only a handful of real changes in non-zero stages.</source>
          <target state="translated">두 개의 파일 만있는 &lt;code&gt;example&lt;/code&gt; 에서는 변경되지 않은 파일이 없으므로 예제 만 축소되었습니다. 그러나 실제 대규모 프로젝트에서 한 번의 커밋에서 적은 수의 파일 만 변경되는 경우이 &lt;code&gt;collapsing&lt;/code&gt; 는 대부분의 경로를 상당히 빠르게 병합하여 0이 아닌 단계에서 소수의 실제 변경 사항 만 남겨 둡니다.</target>
        </trans-unit>
        <trans-unit id="a3569415a118c16e9c5d7e18e58096bbd8336f98" translate="yes" xml:space="preserve">
          <source>In our example, when you do the test merge, the manual resolution is recorded, and it will be reused when you do the actual merge later with the updated master and topic branch, as long as the recorded resolution is still applicable.</source>
          <target state="translated">이 예에서는 테스트 병합을 수행 할 때 수동 해상도가 기록되며, 기록 된 해상도가 여전히 적용 가능한 한 업데이트 된 마스터 및 토픽 브랜치에서 나중에 실제 병합을 수행 할 때 재사용됩니다.</target>
        </trans-unit>
        <trans-unit id="8e5ca17ff33890ba6e129c741e431196f019fa29" translate="yes" xml:space="preserve">
          <source>In overlay mode, the command never removes files when restoring. In no-overlay mode, tracked files that do not appear in the &lt;code&gt;--source&lt;/code&gt; tree are removed, to make them match &lt;code&gt;&amp;lt;tree&amp;gt;&lt;/code&gt; exactly. The default is no-overlay mode.</source>
          <target state="translated">오버레이 모드에서 명령은 복원시 파일을 제거하지 않습니다. 오버레이 없음 모드에서는 &lt;code&gt;--source&lt;/code&gt; 트리에 나타나지 않는 추적 된 파일 이 제거되어 &lt;code&gt;&amp;lt;tree&amp;gt;&lt;/code&gt; 와 정확하게 일치합니다. 기본값은 오버레이 없음 모드입니다.</target>
        </trans-unit>
        <trans-unit id="5b1c0d5c1dcebbb2369ea9f003ec30402ee8a395" translate="yes" xml:space="preserve">
          <source>In particular, let&amp;rsquo;s not even check in the two files into Git yet, we&amp;rsquo;ll start off by adding another line to &lt;code&gt;hello&lt;/code&gt; first:</source>
          <target state="translated">특히 두 파일을 Git에 체크인하지 말고 먼저 &lt;code&gt;hello&lt;/code&gt; 에 다른 줄을 추가하여 시작하겠습니다 .</target>
        </trans-unit>
        <trans-unit id="d0e454374a9a3ee3d6a441cd0674139a3f061022" translate="yes" xml:space="preserve">
          <source>In particular, the &lt;code&gt;refs&lt;/code&gt; subdirectory will contain two other subdirectories, named &lt;code&gt;heads&lt;/code&gt; and &lt;code&gt;tags&lt;/code&gt; respectively. They do exactly what their names imply: they contain references to any number of different &lt;code&gt;heads&lt;/code&gt; of development (aka &lt;code&gt;branches&lt;/code&gt;), and to any &lt;code&gt;tags&lt;/code&gt; that you have created to name specific versions in your repository.</source>
          <target state="translated">특히 &lt;code&gt;refs&lt;/code&gt; 서브 디렉토리에는 각각 &lt;code&gt;heads&lt;/code&gt; 및 &lt;code&gt;tags&lt;/code&gt; 라는 두 개의 다른 서브 디렉토리가 포함 됩니다. 그것들은 그들의 이름이 의미하는 바를 정확하게 수행합니다 : 그것들은 여러 가지 다른 개발 &lt;code&gt;heads&lt;/code&gt; (일명 &lt;code&gt;branches&lt;/code&gt; )와 저장소의 특정 버전의 이름을 지정하기 위해 생성 한 &lt;code&gt;tags&lt;/code&gt; 에 대한 참조를 포함합니다.</target>
        </trans-unit>
        <trans-unit id="2037a0a7d55894c0e552cd3905604e14aef5f5cc" translate="yes" xml:space="preserve">
          <source>In practice, you can interleave and repeat steps 1 and 2 as many times as you want: in order to keep track of what you want committed at step 3, Git maintains a snapshot of the tree&amp;rsquo;s contents in a special staging area called &quot;the index.&quot;</source>
          <target state="translated">실제로 1 단계와 2 단계를 원하는만큼 여러 번 인터리빙하고 반복 할 수 있습니다. 3 단계에서 커밋하려는 내용을 추적하기 위해 Git은 &quot;인덱스&quot;라는 특수한 준비 영역에서 트리 내용의 스냅 샷을 유지합니다. &quot;</target>
        </trans-unit>
        <trans-unit id="f0e4ad3997791ffc68facd5c602055afb63229a5" translate="yes" xml:space="preserve">
          <source>In principle, a note is a regular Git blob, and any kind of (non-)format is accepted. You can binary-safely create notes from arbitrary files using &lt;code&gt;git hash-object&lt;/code&gt;:</source>
          <target state="translated">원칙적으로 메모는 일반적인 Git Blob이며 모든 종류의 (비) 형식이 허용됩니다. &lt;code&gt;git hash-object&lt;/code&gt; 를 사용하여 임의의 파일에서 이진으로 안전하게 메모를 만들 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="4601fb728bee4aeccfe338414983070eaafe0d7b" translate="yes" xml:space="preserve">
          <source>In protocol v2 communication is command oriented. When first contacting a server a list of capabilities will advertised. Some of these capabilities will be commands which a client can request be executed. Once a command has completed, a client can reuse the connection and request that other commands be executed.</source>
          <target state="translated">프로토콜 v2에서 통신은 명령 지향적입니다. 서버에 처음 접속할 때 기능 목록이 광고됩니다. 이러한 기능 중 일부는 클라이언트가 요청할 수있는 명령입니다. 명령이 완료되면 클라이언트는 연결을 재사용하고 다른 명령의 실행을 요청할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f1e89ddf0408f3e3f9aa71b3da7906ab579cf106" translate="yes" xml:space="preserve">
          <source>In protocol v2 these special packets will have the following semantics:</source>
          <target state="translated">프로토콜 v2에서 이러한 특수 패킷은 다음 의미를 갖습니다.</target>
        </trans-unit>
        <trans-unit id="0b2a25ba5b09240510379a9523ee7fbbaeebe9c6" translate="yes" xml:space="preserve">
          <source>In some cases it is possible that the new head will &lt;strong&gt;not&lt;/strong&gt; actually be a descendant of the old head. For example, the developer may have realized she made a serious mistake, and decided to backtrack, resulting in a situation like:</source>
          <target state="translated">경우에 따라 새 헤드가 실제로 이전 헤드의 후손 이 &lt;strong&gt;아닐&lt;/strong&gt; 수도 있습니다. 예를 들어, 개발자는 자신이 심각한 실수를 저지르고 역 추적하기로 결정하여 다음과 같은 상황이 발생했을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="013d925394580efad8fc98d09cd78b65808be1a0" translate="yes" xml:space="preserve">
          <source>In some cases like for kernel development it can be worth developing complex scripts to be able to fully automate bisecting.</source>
          <target state="translated">커널 개발과 같은 경우에는 이등분을 완전히 자동화 할 수있는 복잡한 스크립트를 개발할 가치가 있습니다.</target>
        </trans-unit>
        <trans-unit id="0a49ce3de43e8ee8d78f327f1f504c6a86228a99" translate="yes" xml:space="preserve">
          <source>In some situations the reflog may not be able to save you. For example, suppose you delete a branch, then realize you need the history it contained. The reflog is also deleted; however, if you have not yet pruned the repository, then you may still be able to find the lost commits in the dangling objects that &lt;code&gt;git fsck&lt;/code&gt; reports. See &lt;a href=&quot;#dangling-objects&quot;&gt;Dangling objects&lt;/a&gt; for the details.</source>
          <target state="translated">경우에 따라 reflog가 저장하지 못할 수도 있습니다. 예를 들어, 분기를 삭제 한 다음 포함 된 히스토리가 필요하다고 가정하십시오. reflog도 삭제됩니다. 그러나 아직 리포지토리를 프룬 (prune)하지 않은 경우 여전히 &lt;code&gt;git fsck&lt;/code&gt; 에서 보고 하는 매달려있는 오브젝트에서 손실 된 커밋을 찾을 수 있습니다 . 자세한 내용은 &lt;a href=&quot;#dangling-objects&quot;&gt;댕글 링 개체&lt;/a&gt; 를 참조 하십시오.</target>
        </trans-unit>
        <trans-unit id="4f2c24901ef5f6fa3a7b78ff609de06af9cfd2f7" translate="yes" xml:space="preserve">
          <source>In sparse checkout mode, &lt;code&gt;git checkout -- &amp;lt;paths&amp;gt;&lt;/code&gt; would update only entries matched by &lt;code&gt;&amp;lt;paths&amp;gt;&lt;/code&gt; and sparse patterns in &lt;code&gt;$GIT_DIR/info/sparse-checkout&lt;/code&gt;. This option ignores the sparse patterns and adds back any files in &lt;code&gt;&amp;lt;paths&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">스파 스 체크 아웃 모드에서 &lt;code&gt;git checkout -- &amp;lt;paths&amp;gt;&lt;/code&gt; 는 &lt;code&gt;$GIT_DIR/info/sparse-checkout&lt;/code&gt; &lt;code&gt;&amp;lt;paths&amp;gt;&lt;/code&gt; 및 스파 스 패턴과 일치하는 항목 만 업데이트합니다 . 이 옵션은 희소 패턴을 무시하고 &lt;code&gt;&amp;lt;paths&amp;gt;&lt;/code&gt; 에있는 파일을 다시 추가합니다 .</target>
        </trans-unit>
        <trans-unit id="91e2068ee07240a386da6a01584d7cb7bf48667f" translate="yes" xml:space="preserve">
          <source>In sparse checkout mode, by default is to only update entries matched by &lt;code&gt;&amp;lt;pathspec&amp;gt;&lt;/code&gt; and sparse patterns in $GIT_DIR/info/sparse-checkout. This option ignores the sparse patterns and unconditionally restores any files in &lt;code&gt;&amp;lt;pathspec&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">스파 스 체크 아웃 모드에서 기본적 으로 $ GIT_DIR / info / sparse-checkout에서 &lt;code&gt;&amp;lt;pathspec&amp;gt;&lt;/code&gt; 및 스파 스 패턴과 일치하는 항목 만 업데이트합니다 . 이 옵션은 희소 패턴을 무시하고 &lt;code&gt;&amp;lt;pathspec&amp;gt;&lt;/code&gt; 의 파일을 무조건 복원합니다 .</target>
        </trans-unit>
        <trans-unit id="9805e95abc4cc7297991de78ec147328f379f9f9" translate="yes" xml:space="preserve">
          <source>In such a case, &lt;code&gt;git merge-base origin/master topic&lt;/code&gt; would return the parent of B0 in the above picture, but B0^..D is &lt;strong&gt;not&lt;/strong&gt; the range of commits you would want to replay on top of B (it includes B0, which is not what you wrote; it is a commit the other side discarded when it moved its tip from B0 to B1).</source>
          <target state="translated">이 경우 &lt;code&gt;git merge-base origin/master topic&lt;/code&gt; 는 위 그림에서 B0의 부모를 반환하지만 B0 ^ .. D는 B 위에서 재생할 커밋 범위 가 &lt;strong&gt;아닙니다&lt;/strong&gt; (B0, 그것은 당신이 쓴 것이 아닙니다; 그것은 팁을 B0에서 B1로 옮길 때 버린 커밋입니다).</target>
        </trans-unit>
        <trans-unit id="38c59b4cda1fb890b6373e0ee120752a69f46faf" translate="yes" xml:space="preserve">
          <source>In such a case, you can &quot;unwrap&quot; the tag yourself before feeding it to &lt;code&gt;git merge&lt;/code&gt;, or pass &lt;code&gt;--ff-only&lt;/code&gt; when you do not have any work on your own. e.g.</source>
          <target state="translated">이 경우 태그를 &lt;code&gt;git merge&lt;/code&gt; 에 공급하기 전에 직접 태그를 &quot;포장 &lt;code&gt;--ff-only&lt;/code&gt; 하거나 직접 작업이없는 경우 --ff- 만 전달할 수 있습니다. 예 :</target>
        </trans-unit>
        <trans-unit id="122c6a9f6232138a6047defa817d1eec04cb3f10" translate="yes" xml:space="preserve">
          <source>In such a case, you do not want to automatically follow the other person&amp;rsquo;s tags.</source>
          <target state="translated">이 경우 다른 사람의 태그를 자동으로 따르고 싶지 않습니다.</target>
        </trans-unit>
        <trans-unit id="14b066e7c220e701d278a048087bd2ff212888b8" translate="yes" xml:space="preserve">
          <source>In such cases it can be very confusing to use the terms &quot;good&quot; and &quot;bad&quot; to refer to &quot;the state before the change&quot; and &quot;the state after the change&quot;. So instead, you can use the terms &quot;old&quot; and &quot;new&quot;, respectively, in place of &quot;good&quot; and &quot;bad&quot;. (But note that you cannot mix &quot;good&quot; and &quot;bad&quot; with &quot;old&quot; and &quot;new&quot; in a single session.)</source>
          <target state="translated">이러한 경우 &quot;좋은&quot;및 &quot;나쁜&quot;이라는 용어를 사용하여 &quot;변경 전 상태&quot;및 &quot;변경 후 상태&quot;를 나타내는 것은 매우 혼란 스러울 수 있습니다. 대신 &quot;good&quot;및 &quot;bad&quot;대신 &quot;old&quot;및 &quot;new&quot;라는 용어를 각각 사용할 수 있습니다. 단, 단일 세션에서 &quot;양호한&quot;및 &quot;나쁜&quot;을 &quot;이전&quot;및 &quot;신규&quot;와 혼합 할 수는 없습니다.</target>
        </trans-unit>
        <trans-unit id="abac94a936763ce45a21b8291dbe11f8fcd73ae6" translate="yes" xml:space="preserve">
          <source>In such cases, git-cherry shows a concise summary of what has yet to be applied:</source>
          <target state="translated">그러한 경우, git-cherry는 아직 적용되지 않은 것에 대한 간결한 요약을 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="46cccce64f7cd9f50066dd3d9623630b5fee1925" translate="yes" xml:space="preserve">
          <source>In that case, &lt;code&gt;git pull&lt;/code&gt; can do the fetch and merge in one go, as follows.</source>
          <target state="translated">이 경우 &lt;code&gt;git pull&lt;/code&gt; 은 다음과 같이 가져 오기 및 병합을 한 번에 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="724c7d4dfedb54b8a53a948ec5bdabaee78995fb" translate="yes" xml:space="preserve">
          <source>In that case, the fix is easy because &lt;code&gt;git rebase&lt;/code&gt; knows to skip changes that are already present in the new upstream. So if you say (assuming you&amp;rsquo;re on &lt;code&gt;topic&lt;/code&gt;)</source>
          <target state="translated">이 경우 &lt;code&gt;git rebase&lt;/code&gt; 가 새로운 업스트림에 이미 존재하는 변경 사항을 건너 뛰는 것을 알고 있기 때문에 수정이 쉽습니다 . 당신이 말하면 (당신이 &lt;code&gt;topic&lt;/code&gt; 에 있다고 가정 )</target>
        </trans-unit>
        <trans-unit id="e2f5cdfecd5b61a82b453fde83701ee64b8d8237" translate="yes" xml:space="preserve">
          <source>In that case, you can still force Git to update to the new head, as described in the following section. However, note that in the situation above this may mean losing the commits labeled &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt;, unless you&amp;rsquo;ve already created a reference of your own pointing to them.</source>
          <target state="translated">이 경우 다음 섹션에 설명 된대로 여전히 Git이 새 헤드로 업데이트되도록 할 수 있습니다. 그러나 위의 상황에서 &lt;code&gt;a&lt;/code&gt; 및 &lt;code&gt;b&lt;/code&gt; 라는 커밋을 잃어 버릴 수 있습니다. 단, 자신을 가리키는 참조를 이미 만들지 않은 경우.</target>
        </trans-unit>
        <trans-unit id="23201c1eda40e4016771870c9d54dd5324857456" translate="yes" xml:space="preserve">
          <source>In the &lt;code&gt;git push&lt;/code&gt; command above we specify the name of the remote branch to update (&lt;code&gt;master&lt;/code&gt;). If we leave that out, &lt;code&gt;git push&lt;/code&gt; tries to update any branches in the remote repository that have the same name as a branch in the local repository. So the last &lt;code&gt;push&lt;/code&gt; can be done with either of:</source>
          <target state="translated">위의 &lt;code&gt;git push&lt;/code&gt; 명령에서 업데이트 할 원격 브랜치의 이름을 지정합니다 ( &lt;code&gt;master&lt;/code&gt; ). 이를 생략하면 &lt;code&gt;git push&lt;/code&gt; 는 로컬 저장소의 분기와 이름이 같은 원격 저장소의 분기를 업데이트하려고 시도합니다. 따라서 마지막 &lt;code&gt;push&lt;/code&gt; 는 다음 중 하나를 사용하여 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="090c003198124abd0a59f9db99cb23a0a9d08a0d" translate="yes" xml:space="preserve">
          <source>In the above config only the submodule &lt;code&gt;bar&lt;/code&gt; and &lt;code&gt;baz&lt;/code&gt; are active, &lt;code&gt;bar&lt;/code&gt; due to (1) and &lt;code&gt;baz&lt;/code&gt; due to (3). &lt;code&gt;foo&lt;/code&gt; is inactive because (1) takes precedence over (3)</source>
          <target state="translated">전용 서브 모듈, 상기 구성에서 &lt;code&gt;bar&lt;/code&gt; 과 &lt;code&gt;baz&lt;/code&gt; 활성화되어, &lt;code&gt;bar&lt;/code&gt; (1)에 의한 &lt;code&gt;baz&lt;/code&gt; 때문에 (3)에 관한 것이다. (1)이 (3)보다 우선하기 때문에 &lt;code&gt;foo&lt;/code&gt; 가 비활성 상태입니다.</target>
        </trans-unit>
        <trans-unit id="f2615d435cf358760e53af78267e9744a2a4cd7e" translate="yes" xml:space="preserve">
          <source>In the above example output, the function signature was changed from both files (hence two &lt;code&gt;-&lt;/code&gt; removals from both file1 and file2, plus &lt;code&gt;++&lt;/code&gt; to mean one line that was added does not appear in either file1 or file2). Also eight other lines are the same from file1 but do not appear in file2 (hence prefixed with &lt;code&gt;+&lt;/code&gt;).</source>
          <target state="translated">(따라서 두 개의 상기 예제 출력에서, 함수 서명은 모두 파일에서 변경된 &lt;code&gt;-&lt;/code&gt; 파일 1과 파일 2 모두로부터 삭제 플러스 &lt;code&gt;++&lt;/code&gt; 어느 FILE1이나 파일 2에 나타나지 첨가 한 평균 선). 또한 8 개의 다른 행은 file1과 동일하지만 file2에 나타나지 않습니다 (따라서 접두사 &lt;code&gt;+&lt;/code&gt; 가 붙습니다 ).</target>
        </trans-unit>
        <trans-unit id="236d1518399c3b158b7b503f699f9dfd06244979" translate="yes" xml:space="preserve">
          <source>In the above example we have N = 8, so this will give:</source>
          <target state="translated">위의 예에서 N = 8이므로 다음과 같이 나타납니다.</target>
        </trans-unit>
        <trans-unit id="4faa5ab35bd05c089c7f00cb50d40bc6a34dd151" translate="yes" xml:space="preserve">
          <source>In the case where the input consists entirely of whitespace characters, no output will be produced.</source>
          <target state="translated">입력이 전체적으로 공백 문자로 구성된 경우 출력이 생성되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="6722ed28b0a968c96593a6b207713cd0f24f7d3a" translate="yes" xml:space="preserve">
          <source>In the check-in codepath, the worktree file is first converted with &lt;code&gt;filter&lt;/code&gt; driver (if specified and corresponding driver defined), then the result is processed with &lt;code&gt;ident&lt;/code&gt; (if specified), and then finally with &lt;code&gt;text&lt;/code&gt; (again, if specified and applicable).</source>
          <target state="translated">체크인 코드 경로에서 작업 트리 파일은 먼저 &lt;code&gt;filter&lt;/code&gt; 드라이버 (지정된 경우 해당 드라이버가 정의 된 경우) 로 변환 된 다음 결과가 &lt;code&gt;ident&lt;/code&gt; (지정된 경우)로 처리 된 다음 &lt;code&gt;text&lt;/code&gt; (지정되고 적용 가능한 경우)로 처리됩니다. .</target>
        </trans-unit>
        <trans-unit id="41a87794ee334f48f97053e2010dfe2b224b3e78" translate="yes" xml:space="preserve">
          <source>In the check-out codepath, the blob content is first converted with &lt;code&gt;text&lt;/code&gt;, and then &lt;code&gt;ident&lt;/code&gt; and fed to &lt;code&gt;filter&lt;/code&gt;.</source>
          <target state="translated">체크 아웃 코드 경로에서 Blob 컨텐츠는 먼저 &lt;code&gt;text&lt;/code&gt; 로 변환 된 다음 &lt;code&gt;ident&lt;/code&gt; 및 &lt;code&gt;filter&lt;/code&gt; 됩니다.</target>
        </trans-unit>
        <trans-unit id="113fa915b38684bf235e931affc2401ec6de4a63" translate="yes" xml:space="preserve">
          <source>In the cone mode case, the &lt;code&gt;git sparse-checkout list&lt;/code&gt; subcommand will list the directories that define the recursive patterns. For the example sparse-checkout file above, the output is as follows:</source>
          <target state="translated">cone 모드의 경우, &lt;code&gt;git sparse-checkout list&lt;/code&gt; 하위 명령은 재귀 패턴을 정의하는 디렉토리를 나열합니다. 위의 스파 스 체크 아웃 파일 예의 출력 결과는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="50d1a515997c60c54243bae252639aa03db105b6" translate="yes" xml:space="preserve">
          <source>In the default overlay mode, &lt;code&gt;git checkout&lt;/code&gt; never removes files from the index or the working tree. When specifying &lt;code&gt;--no-overlay&lt;/code&gt;, files that appear in the index and working tree, but not in &lt;code&gt;&amp;lt;tree-ish&amp;gt;&lt;/code&gt; are removed, to make them match &lt;code&gt;&amp;lt;tree-ish&amp;gt;&lt;/code&gt; exactly.</source>
          <target state="translated">기본 오버레이 모드에서 &lt;code&gt;git checkout&lt;/code&gt; 은 색인 또는 작업 트리에서 파일을 제거하지 않습니다. &lt;code&gt;--no-overlay&lt;/code&gt; 를 지정하면 &lt;code&gt;&amp;lt;tree-ish&amp;gt;&lt;/code&gt; 가 아닌 인덱스 및 작업 트리에 나타나는 파일 이 제거되어 &lt;code&gt;&amp;lt;tree-ish&amp;gt;&lt;/code&gt; 와 정확하게 일치합니다.</target>
        </trans-unit>
        <trans-unit id="6cdd96542ff31058533f7beb40eadd124991c8c5" translate="yes" xml:space="preserve">
          <source>In the early days, Git (in the tradition of UNIX) was a bunch of programs which were extremely simple, and which you used in scripts, piping the output of one into another. This turned out to be good for initial development, since it was easier to test new things. However, recently many of these parts have become builtins, and some of the core has been &quot;libified&quot;, i.e. put into libgit.a for performance, portability reasons, and to avoid code duplication.</source>
          <target state="translated">초기에는 Git (UNIX 전통)은 매우 간단하고 스크립트에서 사용하여 서로 다른 출력을 파이프하는 프로그램이었습니다. 새로운 것을 테스트하는 것이 더 쉽기 때문에 초기 개발에 좋았습니다. 그러나 최근에는 이러한 많은 부분이 내장되어 있으며 일부 핵심 부분은 성능, 이식성 및 코드 중복을 피하기 위해 libgit.a에 포함되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="5c0100c9df6abb7d7f1348c7fe307c535cc01a6e" translate="yes" xml:space="preserve">
          <source>In the examples, the following &lt;code&gt;.gitattributes&lt;/code&gt; file is used:</source>
          <target state="translated">예제에서는 다음 &lt;code&gt;.gitattributes&lt;/code&gt; 파일이 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="cc3fe53f7a76d1235b536b2f3e4aace1aeafd632" translate="yes" xml:space="preserve">
          <source>In the external editor window, read in the patch file and exit the editor normally.</source>
          <target state="translated">외부 편집기 창에서 패치 파일을 읽고 편집기를 정상적으로 종료하십시오.</target>
        </trans-unit>
        <trans-unit id="8ef2e6de3f32f727ff12807f3683863dc57cb535" translate="yes" xml:space="preserve">
          <source>In the first form, it renames &amp;lt;source&amp;gt;, which must exist and be either a file, symlink or directory, to &amp;lt;destination&amp;gt;. In the second form, the last argument has to be an existing directory; the given sources will be moved into this directory.</source>
          <target state="translated">첫 번째 형식에서는 존재해야하며 파일, symlink 또는 디렉토리 중 하나 인 &amp;lt;source&amp;gt;의 이름을 &amp;lt;destination&amp;gt;으로 바꿉니다. 두 번째 형식에서 마지막 인수는 기존 디렉토리 여야합니다. 주어진 소스가이 디렉토리로 이동합니다.</target>
        </trans-unit>
        <trans-unit id="76aeefd352a6b656fb05dc49a2aa92d1acbe97ce" translate="yes" xml:space="preserve">
          <source>In the first three forms, copy entries from &lt;code&gt;&amp;lt;tree-ish&amp;gt;&lt;/code&gt; to the index. In the last form, set the current branch head (&lt;code&gt;HEAD&lt;/code&gt;) to &lt;code&gt;&amp;lt;commit&amp;gt;&lt;/code&gt;, optionally modifying index and working tree to match. The &lt;code&gt;&amp;lt;tree-ish&amp;gt;&lt;/code&gt;/&lt;code&gt;&amp;lt;commit&amp;gt;&lt;/code&gt; defaults to &lt;code&gt;HEAD&lt;/code&gt; in all forms.</source>
          <target state="translated">처음 세 양식에서 &lt;code&gt;&amp;lt;tree-ish&amp;gt;&lt;/code&gt; 에서 색인으로 항목을 복사 하십시오. 마지막 양식에서 현재 분기 헤드 ( &lt;code&gt;HEAD&lt;/code&gt; )를 &lt;code&gt;&amp;lt;commit&amp;gt;&lt;/code&gt; 으로 설정 하고 선택적으로 색인 및 작업 트리를 일치하도록 수정하십시오. &lt;code&gt;&amp;lt;tree-ish&amp;gt;&lt;/code&gt; / &lt;code&gt;&amp;lt;commit&amp;gt;&lt;/code&gt; 기본값 &lt;code&gt;HEAD&lt;/code&gt; 를 모든 형태.</target>
        </trans-unit>
        <trans-unit id="ef10a113d8afc34781099a24e1e343890650a1e1" translate="yes" xml:space="preserve">
          <source>In the following example, the developer works on a topic branch that refactors the way buttons are defined, and on another topic branch that uses that refactoring to implement a &quot;Report a bug&quot; button. The output of &lt;code&gt;git log --graph --format=%s -5&lt;/code&gt; may look like this:</source>
          <target state="translated">다음 예제에서 개발자는 단추가 정의 된 방식을 리팩토링하는 토픽 브랜치 및 해당 리팩토링을 사용하여 &quot;버그보고&quot;버튼을 구현하는 다른 토픽 브랜치에서 작업합니다. 출력 &lt;code&gt;git log --graph --format=%s -5&lt;/code&gt; 과 같을 수있다 :</target>
        </trans-unit>
        <trans-unit id="e8d35f4a27576cd3ee599047c232398088d285ec" translate="yes" xml:space="preserve">
          <source>In the following, we list all defined capabilities and for each we list which commands a helper with that capability must provide.</source>
          <target state="translated">다음에는 정의 된 모든 기능과 각 기능에 대해 도우미가 제공해야하는 명령이 나열되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="c56abbab61e08007b56db2739d2660b32ff3baf6" translate="yes" xml:space="preserve">
          <source>In the following, we say that commit X is &quot;reachable&quot; from commit Y if commit X is an ancestor of commit Y. Equivalently, you could say that Y is a descendant of X, or that there is a chain of parents leading from commit Y to commit X.</source>
          <target state="translated">다음에서, 커밋 X가 커밋 Y의 조상이면 커밋 X가 커밋 Y에서 &quot;도달 가능&quot;하다고 말합니다. 마찬가지로, Y가 X의 자손이거나 커밋에서 이어지는 부모의 체인이 있다고 말할 수 있습니다 X를 커밋하려면 Y</target>
        </trans-unit>
        <trans-unit id="2ab0015fa4bf468aa51dfb7b06e67d10a59ee05a" translate="yes" xml:space="preserve">
          <source>In the following, we will always refer to the same example history to illustrate the differences between simplification settings. We assume that you are filtering for a file &lt;code&gt;foo&lt;/code&gt; in this commit graph:</source>
          <target state="translated">다음에서는 단순화 설정 간의 차이점을 설명하기 위해 항상 동일한 예제 기록을 참조합니다. 이 커밋 그래프에서 파일 &lt;code&gt;foo&lt;/code&gt; 를 필터링한다고 가정합니다 .</target>
        </trans-unit>
        <trans-unit id="1a1825758e9c1b0f3cada9dea61b97f18e404ba1" translate="yes" xml:space="preserve">
          <source>In the ideal world, you could have realized that the earlier commit did not belong to the new topic when you created and switched to &lt;code&gt;branch2&lt;/code&gt; (i.e. &lt;code&gt;git switch -c branch2 start&lt;/code&gt;), but nobody is perfect.</source>
          <target state="translated">이상적인 세계에서, 이전 커밋이 여러분이 &lt;code&gt;branch2&lt;/code&gt; 를 생성하고 전환 할 때 (예 : &lt;code&gt;git switch -c branch2 start&lt;/code&gt; ) 새로운 토픽에 속하지 않았지만 아무도 완벽하지 않다는 것을 알 수있었습니다 .</target>
        </trans-unit>
        <trans-unit id="d370a0f8ed20ae4cd4e933b9beff011b3187e6ad" translate="yes" xml:space="preserve">
          <source>In the long form, the leading colon &lt;code&gt;:&lt;/code&gt; is followed by an open parenthesis &lt;code&gt;(&lt;/code&gt;, a comma-separated list of zero or more &quot;magic words&quot;, and a close parentheses &lt;code&gt;)&lt;/code&gt;, and the remainder is the pattern to match against the path.</source>
          <target state="translated">긴 형태에서, 최고의 콜론 &lt;code&gt;:&lt;/code&gt; 여는 괄호 뒤에 &lt;code&gt;(&lt;/code&gt; 0 개 이상의 &quot;마법의 단어&quot;, 그리고 가까운 괄호의 쉼표로 구분 된 목록 &lt;code&gt;)&lt;/code&gt; , 나머지는 경로에 대해 일치하는 패턴이다.</target>
        </trans-unit>
        <trans-unit id="ecbb466c633c8f376663d1974093b0b801e94fbc" translate="yes" xml:space="preserve">
          <source>In the main Thunderbird window, &lt;code&gt;before&lt;/code&gt; you open the compose window for the patch, use Tools&amp;rarr;about:config to set the following to the indicated values:</source>
          <target state="translated">기본 Thunderbird 창 에서 패치의 작성 창을 열기 &lt;code&gt;before&lt;/code&gt; 도구 &amp;rarr; about : config를 사용하여 다음을 표시된 값으로 설정하십시오.</target>
        </trans-unit>
        <trans-unit id="3f70c7e45d5c392e715fb2023b23a65e5f20b82a" translate="yes" xml:space="preserve">
          <source>In the output from &lt;code&gt;git show-branch&lt;/code&gt;, &lt;code&gt;master&lt;/code&gt; should have everything &lt;code&gt;ko/master&lt;/code&gt; has, and &lt;code&gt;next&lt;/code&gt; should have everything &lt;code&gt;ko/next&lt;/code&gt; has, etc.</source>
          <target state="translated">의 출력에서 &lt;code&gt;git show-branch&lt;/code&gt; , &lt;code&gt;master&lt;/code&gt; 모든 것을해야한다 &lt;code&gt;ko/master&lt;/code&gt; 있으며, &lt;code&gt;next&lt;/code&gt; 모든 것을해야한다 &lt;code&gt;ko/next&lt;/code&gt; 이 등</target>
        </trans-unit>
        <trans-unit id="9fb474287214ed4886618f1399ff63bbd11f6810" translate="yes" xml:space="preserve">
          <source>In the pager (&lt;code&gt;less&lt;/code&gt;), just search for &quot;bundle&quot;, go a few lines back, and see that it is in commit 18449ab0. Now just copy this object name, and paste it into the command line</source>
          <target state="translated">호출기 ( &lt;code&gt;less&lt;/code&gt; )에서 &quot;bundle&quot;을 검색하고 몇 줄을 뒤로 이동하여 커밋 18449ab0에 있는지 확인하십시오. 이제이 오브젝트 이름을 복사하여 명령 행에 붙여 넣으십시오.</target>
        </trans-unit>
        <trans-unit id="5fc7016d20b7cd82938bb283d4d8443cc61835c8" translate="yes" xml:space="preserve">
          <source>In the past, &lt;code&gt;.git/HEAD&lt;/code&gt; was a symbolic link pointing at &lt;code&gt;refs/heads/master&lt;/code&gt;. When we wanted to switch to another branch, we did &lt;code&gt;ln -sf refs/heads/newbranch .git/HEAD&lt;/code&gt;, and when we wanted to find out which branch we are on, we did &lt;code&gt;readlink .git/HEAD&lt;/code&gt;. But symbolic links are not entirely portable, so they are now deprecated and symbolic refs (as described above) are used by default.</source>
          <target state="translated">과거에는 &lt;code&gt;.git/HEAD&lt;/code&gt; 는 &lt;code&gt;refs/heads/master&lt;/code&gt; 를 가리키는 심볼릭 링크였습니다 . 우리가 다른 지점으로 전환하고 싶어 할 때, 우리는 한 &lt;code&gt;ln -sf refs/heads/newbranch .git/HEAD&lt;/code&gt; , 우리는 우리가있는 지점 발견하고 싶어 할 때, 우리는 한 &lt;code&gt;readlink .git/HEAD&lt;/code&gt; . 그러나 심볼릭 링크는 완전히 이식 가능하지 않으므로 이제 더 이상 사용되지 않으며 위에서 설명한 것처럼 심볼릭 참조가 기본적으로 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="8dfab80b468101639bf9d627830b7559e865891a" translate="yes" xml:space="preserve">
          <source>In the previous example, when updating an existing branch, &lt;code&gt;git fetch&lt;/code&gt; checks to make sure that the most recent commit on the remote branch is a descendant of the most recent commit on your copy of the branch before updating your copy of the branch to point at the new commit. Git calls this process a &lt;a href=&quot;#fast-forwards&quot;&gt;fast-forward&lt;/a&gt;.</source>
          <target state="translated">이전 예제에서 기존 분기를 업데이트 할 때 &lt;code&gt;git fetch&lt;/code&gt; 는 원격 분기에서 가장 최근의 커밋이 지점의 복사본을 업데이트하기 전에 분기의 복사본에서 가장 최근의 커밋의 하위 항목인지 확인합니다. 새로운 커밋. 힘내이 프로세스를 &lt;a href=&quot;#fast-forwards&quot;&gt;빨리 진행이라고&lt;/a&gt; 합니다.</target>
        </trans-unit>
        <trans-unit id="39fc6243d8461e10163ad54b5cc61dfd9c9ca8f0" translate="yes" xml:space="preserve">
          <source>In the process of undoing a previous bad change, you may find it useful to check out an older version of a particular file using &lt;a href=&quot;git-restore&quot;&gt;git-restore[1]&lt;/a&gt;. The command</source>
          <target state="translated">이전의 잘못된 변경을 취소하는 과정에서 &lt;a href=&quot;git-restore&quot;&gt;git-restore [1]을&lt;/a&gt; 사용하여 특정 파일의 이전 버전을 체크 아웃하는 것이 유용 할 수 있습니다 . 명령</target>
        </trans-unit>
        <trans-unit id="ce5a30d6d89274fe8c4b93a655981ad3cb2875fa" translate="yes" xml:space="preserve">
          <source>In the process, it may discover conflicts. In that case it will stop and allow you to fix the conflicts; after fixing conflicts, use &lt;code&gt;git add&lt;/code&gt; to update the index with those contents, and then, instead of running &lt;code&gt;git commit&lt;/code&gt;, just run</source>
          <target state="translated">이 과정에서 충돌이 발견 될 수 있습니다. 이 경우 중지되고 충돌을 해결할 수 있습니다. 충돌을 수정 한 후 &lt;code&gt;git add&lt;/code&gt; 를 사용 하여 해당 내용으로 색인을 업데이트 한 다음 &lt;code&gt;git commit&lt;/code&gt; 을 실행하는 대신 다음을 실행하십시오.</target>
        </trans-unit>
        <trans-unit id="ecd16080120d9546efe5335b66c01332d8bc5340" translate="yes" xml:space="preserve">
          <source>In the second form, a list of objects (separated by linefeeds) is provided on stdin, and the SHA-1, type, and size of each object is printed on stdout. The output format can be overridden using the optional &lt;code&gt;&amp;lt;format&amp;gt;&lt;/code&gt; argument. If either &lt;code&gt;--textconv&lt;/code&gt; or &lt;code&gt;--filters&lt;/code&gt; was specified, the input is expected to list the object names followed by the path name, separated by a single whitespace, so that the appropriate drivers can be determined.</source>
          <target state="translated">두 번째 형태로, 개체 목록 (줄 바꿈으로 구분)이 stdin에 제공되고 각 개체의 SHA-1, 유형 및 크기가 stdout에 인쇄됩니다. 선택적 &lt;code&gt;&amp;lt;format&amp;gt;&lt;/code&gt; 인수를 사용하여 출력 형식을 재정의 할 수 있습니다 . 어느 경우 &lt;code&gt;--textconv&lt;/code&gt; 또는 &lt;code&gt;--filters&lt;/code&gt; 이 지정된 입력은 적절한 드라이버를 결정할 수 있도록하는 것이 단일 공백으로 분리 된 경로 이름 다음에 개체 이름을 나열 할 것으로 예상된다.</target>
        </trans-unit>
        <trans-unit id="909b0b19015ead3714bd1690a7877da1cf97f4fa" translate="yes" xml:space="preserve">
          <source>In the short-format, the status of each path is shown as one of these forms</source>
          <target state="translated">짧은 형식에서는 각 경로의 상태가 다음 형식 중 하나로 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="abe3a521aeac4a8adcc3faf0711763fbfd40b505" translate="yes" xml:space="preserve">
          <source>In the simple form, each line in the file consists of the canonical real name of an author, whitespace, and an email address used in the commit (enclosed by &lt;code&gt;&amp;lt;&lt;/code&gt; and &lt;code&gt;&amp;gt;&lt;/code&gt;) to map to the name. For example:</source>
          <target state="translated">간단한 형식으로 파일의 각 줄은 저자의 정식 실제 이름, 공백 및 커밋 ( &lt;code&gt;&amp;lt;&lt;/code&gt; 및 &lt;code&gt;&amp;gt;&lt;/code&gt; 으로 묶음 )에서 이름에 매핑하는 데 사용되는 전자 메일 주소로 구성됩니다 . 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="eecf34aeaad64fff7ea38378d33edc5335145626" translate="yes" xml:space="preserve">
          <source>In these cases you can tell Git the encoding of a file in the working directory with the &lt;code&gt;working-tree-encoding&lt;/code&gt; attribute. If a file with this attribute is added to Git, then Git re-encodes the content from the specified encoding to UTF-8. Finally, Git stores the UTF-8 encoded content in its internal data structure (called &quot;the index&quot;). On checkout the content is re-encoded back to the specified encoding.</source>
          <target state="translated">이 경우 &lt;code&gt;working-tree-encoding&lt;/code&gt; 속성을 사용 하여 작업 디렉토리의 파일 인코딩을 Git에 알릴 수 있습니다 . 이 속성을 가진 파일이 Git에 추가되면 Git은 지정된 인코딩에서 UTF-8로 컨텐츠를 다시 인코딩합니다. 마지막으로 Git은 UTF-8로 인코딩 된 콘텐츠를 내부 데이터 구조 ( &quot;인덱스&quot;라고 함)에 저장합니다. 체크 아웃시 컨텐츠는 지정된 인코딩으로 다시 인코딩됩니다.</target>
        </trans-unit>
        <trans-unit id="5322604525a9aed1b9bf470c8d7df77aa5a14cc1" translate="yes" xml:space="preserve">
          <source>In these tables, &lt;code&gt;A&lt;/code&gt;, &lt;code&gt;B&lt;/code&gt;, &lt;code&gt;C&lt;/code&gt; and &lt;code&gt;D&lt;/code&gt; are some different states of a file. For example, the first line of the first table means that if a file is in state &lt;code&gt;A&lt;/code&gt; in the working tree, in state &lt;code&gt;B&lt;/code&gt; in the index, in state &lt;code&gt;C&lt;/code&gt; in &lt;code&gt;HEAD&lt;/code&gt; and in state &lt;code&gt;D&lt;/code&gt; in the target, then &lt;code&gt;git reset --soft
target&lt;/code&gt; will leave the file in the working tree in state &lt;code&gt;A&lt;/code&gt; and in the index in state &lt;code&gt;B&lt;/code&gt;. It resets (i.e. moves) the &lt;code&gt;HEAD&lt;/code&gt; (i.e. the tip of the current branch, if you are on one) to &lt;code&gt;target&lt;/code&gt; (which has the file in state &lt;code&gt;D&lt;/code&gt;).</source>
          <target state="translated">이 표에서 &lt;code&gt;A&lt;/code&gt; , &lt;code&gt;B&lt;/code&gt; , &lt;code&gt;C&lt;/code&gt; 및 &lt;code&gt;D&lt;/code&gt; 는 파일의 다른 상태입니다. 예를 들어, 첫 번째 테이블 수단의 첫 번째 행의 파일이 상태에있는 경우 그 상태에서 작업 트리에서 &lt;code&gt;B&lt;/code&gt; 상태에서, 인덱스 &lt;code&gt;C&lt;/code&gt; 에 &lt;code&gt;HEAD&lt;/code&gt; 와 상태에서 &lt;code&gt;D&lt;/code&gt; 대상의 다음 &lt;code&gt;git reset --soft target&lt;/code&gt; 은 파일을 상태 &lt;code&gt;A&lt;/code&gt; 의 작업 트리에 있고 상태 &lt;code&gt;B&lt;/code&gt; 의 색인에 그대로 둡니다 . &lt;code&gt;HEAD&lt;/code&gt; (즉, 현재 브랜치의 팁이있는 경우)를 &lt;code&gt;target&lt;/code&gt; (파일이있는 상태 )으로 재설정 (즉, 이동) &lt;code&gt;A&lt;/code&gt; &lt;code&gt;D&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="31d8ef3e97391069cf0655f41499162005f123c2" translate="yes" xml:space="preserve">
          <source>In these two shorthand notations, you can omit one end and let it default to HEAD. For example, &lt;code&gt;origin..&lt;/code&gt; is a shorthand for &lt;code&gt;origin..HEAD&lt;/code&gt; and asks &quot;What did I do since I forked from the origin branch?&quot; Similarly, &lt;code&gt;..origin&lt;/code&gt; is a shorthand for &lt;code&gt;HEAD..origin&lt;/code&gt; and asks &quot;What did the origin do since I forked from them?&quot; Note that &lt;code&gt;..&lt;/code&gt; would mean &lt;code&gt;HEAD..HEAD&lt;/code&gt; which is an empty range that is both reachable and unreachable from HEAD.</source>
          <target state="translated">이 두 가지 속기 표기법에서는 한쪽 끝을 생략하고 기본값을 HEAD로 설정할 수 있습니다. 예를 들어 &lt;code&gt;origin..&lt;/code&gt; 은 &lt;code&gt;origin..HEAD&lt;/code&gt; 의 축약 형이며 &quot;원점에서 분기 한 후 어떻게 했습니까?&quot; 마찬가지로, &lt;code&gt;..origin&lt;/code&gt; 을 위한 속기 &lt;code&gt;HEAD..origin&lt;/code&gt; 은 묻는다 &quot;나는 그들로부터 나눠서 기원은 어떻게 했는가?&quot; 있습니다 &lt;code&gt;..&lt;/code&gt; 의미 &lt;code&gt;HEAD..HEAD&lt;/code&gt; 도달 및 HEAD에서 도달 할 수없는 둘 다 빈 범위입니다.</target>
        </trans-unit>
        <trans-unit id="fda0649080e4ad73be213a95d0150567b39a9905" translate="yes" xml:space="preserve">
          <source>In this case Git will attempt to undo the old change while leaving intact any changes made since then. If more recent changes overlap with the changes to be reverted, then you will be asked to fix conflicts manually, just as in the case of &lt;a href=&quot;#resolving-a-merge&quot;&gt;resolving a merge&lt;/a&gt;.</source>
          <target state="translated">이 경우 Git은 변경 사항을 그대로 유지하면서 이전 변경 내용을 취소하려고 시도합니다. 최근 변경 사항이 되돌릴 변경 사항과 겹치는 경우 &lt;a href=&quot;#resolving-a-merge&quot;&gt;병합&lt;/a&gt; 을 해결하는 경우와 마찬가지로 수동으로 충돌을 수정하라는 메시지가 표시됩니다 .</target>
        </trans-unit>
        <trans-unit id="b7e31e9f418486f831893dd264d133713a86e996" translate="yes" xml:space="preserve">
          <source>In this case if you are bisecting manually, what you can do is create a special branch that starts just before the BBC. The first commit in this branch should be the BBC with the BFC squashed into it. And the other commits in the branch should be the commits between BBC and BFC rebased on the first commit of the branch and then the commit after BFC also rebased on.</source>
          <target state="translated">이 경우 수동으로 이등분하는 경우 BBC 직전에 시작하는 특수 분기를 만드는 것이 가능합니다. 이 지점의 첫 번째 커밋은 BFC가 찌그러진 BBC가되어야합니다. 그리고 브랜치의 다른 커밋은 브랜치의 첫 커밋에 기반한 BBC와 BFC 간의 커밋이어야하며, BFC가 다시 기반한 이후의 커밋이어야합니다.</target>
        </trans-unit>
        <trans-unit id="717fbe628e5024a7ab31b6335fd291caf38b26b3" translate="yes" xml:space="preserve">
          <source>In this case this creates a totally new commit that is not related to anything else. Normally you do this only &lt;strong&gt;once&lt;/strong&gt; for a project ever, and all later commits will be parented on top of an earlier commit.</source>
          <target state="translated">이 경우 다른 것과 관련이없는 완전히 새로운 커밋이 만들어집니다. 일반적으로 프로젝트에 대해 &lt;strong&gt;한 번만&lt;/strong&gt; 이 작업을 수행 하며 이후의 모든 커밋은 이전 커밋 위에 부모로 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="8d602afd53dc502b1f39532e44b808e7e4006de6" translate="yes" xml:space="preserve">
          <source>In this case we say that the HEAD is &quot;detached&quot;.</source>
          <target state="translated">이 경우 HEAD가 &quot;분리&quot;되었다고합니다.</target>
        </trans-unit>
        <trans-unit id="84d70e62f46cda65cca1be0dfe61a185714e74d6" translate="yes" xml:space="preserve">
          <source>In this case, &lt;code&gt;git fetch&lt;/code&gt; will fail, and print out a warning.</source>
          <target state="translated">이 경우 &lt;code&gt;git fetch&lt;/code&gt; 는 실패하고 경고를 출력합니다.</target>
        </trans-unit>
        <trans-unit id="ec2a36fb392a8671d4d7ad6f96adda81069f0cb4" translate="yes" xml:space="preserve">
          <source>In this case, the &lt;code&gt;git read-tree -m $H $M&lt;/code&gt; command makes sure that no local change is lost as the result of this &quot;merge&quot;. Here are the &quot;carry forward&quot; rules, where &quot;I&quot; denotes the index, &quot;clean&quot; means that index and work tree coincide, and &quot;exists&quot;/&quot;nothing&quot; refer to the presence of a path in the specified commit:</source>
          <target state="translated">이 경우, &lt;code&gt;git read-tree -m $H $M&lt;/code&gt; 명령은이 &quot;병합&quot;의 결과로 로컬 변경이 손실되지 않도록합니다. &quot;이월&quot;규칙은 다음과 같습니다. &quot;I&quot;는 색인을 나타내고 &quot;정리&quot;는 색인과 작업 트리가 일치하고 &quot;존재&quot;/ &quot;없음&quot;은 지정된 커밋에 경로가 있음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="53de38de1c4937be3492ea2adad08075be0660b2" translate="yes" xml:space="preserve">
          <source>In this case, though, Git may not eventually be able to tell the first bad one between some first skipped commits and a later bad commit.</source>
          <target state="translated">그러나이 경우 Git은 처음으로 건너 뛴 커밋과 이후의 잘못된 커밋 사이에서 첫 번째 잘못된 것을 알지 못할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="cc3568a850f36cf3d79c68cf0d9db0591ec5b81e" translate="yes" xml:space="preserve">
          <source>In this case, when &lt;code&gt;git bisect run&lt;/code&gt; finishes, bisect/bad will refer to a commit that has at least one parent whose reachable graph is fully traversable in the sense required by &lt;code&gt;git pack objects&lt;/code&gt;.</source>
          <target state="translated">이 경우, &lt;code&gt;git bisect run&lt;/code&gt; 이 완료되면 bisect / bad는 도달 가능한 그래프가 &lt;code&gt;git pack objects&lt;/code&gt; 필요한 의미로 완전히 통과 할 수있는 부모가 하나 이상있는 커밋을 나타 냅니다.</target>
        </trans-unit>
        <trans-unit id="052b0bf9d817f9d1efdbc01c640d54d8fda7ad16" translate="yes" xml:space="preserve">
          <source>In this example preload_index() was executed by the &lt;code&gt;main&lt;/code&gt; thread and started the &lt;code&gt;preload&lt;/code&gt; region. Seven threads, named &lt;code&gt;th01:preload_thread&lt;/code&gt; through &lt;code&gt;th07:preload_thread&lt;/code&gt;, were started. Events from each thread are atomically appended to the shared target stream as they occur so they may appear in random order with respect other threads. Finally, the main thread waits for the threads to finish and leaves the region.</source>
          <target state="translated">이 예제에서 preload_index ()는 &lt;code&gt;main&lt;/code&gt; 스레드에 의해 실행되었으며 프리 &lt;code&gt;preload&lt;/code&gt; 영역을 시작했습니다 . &lt;code&gt;th01:preload_thread&lt;/code&gt; ~ &lt;code&gt;th07:preload_thread&lt;/code&gt; 라는 7 개의 스레드 가 시작되었습니다. 각 스레드의 이벤트는 발생시 공유 대상 스트림에 원자 적으로 추가되므로 다른 스레드와 관련하여 임의의 순서로 나타날 수 있습니다. 마지막으로 주 스레드는 스레드가 완료 될 때까지 기다렸다가 영역을 떠납니다.</target>
        </trans-unit>
        <trans-unit id="8e1c791b90ef2153c52f59ff823e2b7a9d806696" translate="yes" xml:space="preserve">
          <source>In this example, &quot;origin&quot; is called a remote repository, or &quot;remote&quot; for short. The branches of this repository are called &quot;remote branches&quot; from our point of view. The remote-tracking branches listed above were created based on the remote branches at clone time and will be updated by &lt;code&gt;git fetch&lt;/code&gt; (hence &lt;code&gt;git pull&lt;/code&gt;) and &lt;code&gt;git push&lt;/code&gt;. See &lt;a href=&quot;#Updating-a-repository-With-git-fetch&quot;&gt;Updating a repository with git fetch&lt;/a&gt; for details.</source>
          <target state="translated">이 예에서 &quot;origin&quot;은 원격 저장소 또는 &quot;원격&quot;이라고합니다. 이 저장소의 지점을 우리의 관점에서 &quot;원격 지점&quot;이라고합니다. 위에 나열된 원격 추적 분기는 복제시 원격 분기를 기반으로 작성되었으며 &lt;code&gt;git fetch&lt;/code&gt; (따라서 &lt;code&gt;git pull&lt;/code&gt; ) 및 &lt;code&gt;git push&lt;/code&gt; 로 업데이트됩니다 . 자세한 내용 &lt;a href=&quot;#Updating-a-repository-With-git-fetch&quot;&gt;은 git fetch로 리포지토리 업데이트&lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="888891869abe63aa603e61303e6b4eda4f092540" translate="yes" xml:space="preserve">
          <source>In this example, scanning for untracked files ran from +0.012568 to +0.027149 (since the process started) and took 0.014581 seconds.</source>
          <target state="translated">이 예에서 추적되지 않은 파일 검색은 프로세스가 시작된 이후 +0.012568에서 +0.027149까지 실행되었으며 0.014581 초가 걸렸습니다.</target>
        </trans-unit>
        <trans-unit id="06524b5c41784cbbacde83bd5045f27a411dfe64" translate="yes" xml:space="preserve">
          <source>In this example, the &lt;code&gt;ko&lt;/code&gt; shorthand points at the Git maintainer&amp;rsquo;s repository at kernel.org, and looks like this:</source>
          <target state="translated">이 예제에서 &lt;code&gt;ko&lt;/code&gt; 축약 형은 kernel.org의 Git 관리자 저장소에 있으며 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="f509bc56ecf3e22348180170f4391a6c5749bec9" translate="yes" xml:space="preserve">
          <source>In this example, the preload region took 0.009122 seconds. The 7 threads took between 0.006069 and 0.008947 seconds to work on their portion of the index. Thread &quot;th01&quot; worked on 508 items at offset 0. Thread &quot;th02&quot; worked on 508 items at offset 2032. Thread &quot;th04&quot; worked on 508 items at offset 508.</source>
          <target state="translated">이 예에서, 예압 영역은 0.009122 초가 걸렸습니다. 7 개의 스레드는 0.006069와 0.008947 초 사이에서 인덱스의 일부를 처리했습니다. 스레드 &quot;th01&quot;은 오프셋 0의 508 개 항목에서 작동했습니다. 스레드 &quot;th02&quot;는 오프셋 2032의 508 개 항목에서 작동했습니다. 스레드 &quot;th04&quot;는 오프셋 508의 508 개 항목에서 작동했습니다.</target>
        </trans-unit>
        <trans-unit id="24b2f8c33beed03671571687642648d3c34d3255" translate="yes" xml:space="preserve">
          <source>In this example, the root-level directory &lt;code&gt;/pub&lt;/code&gt; will contain a subdirectory for each virtual host IP address supported. Repositories can still be accessed by hostname though, assuming they correspond to these IP addresses.</source>
          <target state="translated">이 예에서 루트 레벨 디렉토리 &lt;code&gt;/pub&lt;/code&gt; 는 지원되는 각 가상 호스트 IP 주소에 대한 서브 디렉토리를 포함합니다. 그러나 이러한 IP 주소에 해당한다고 가정하면 호스트 이름으로 리포지토리에 계속 액세스 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1b3657f6aff85ab6f6a5a7f723164213b6e98109" translate="yes" xml:space="preserve">
          <source>In this example, the root-level directory &lt;code&gt;/pub&lt;/code&gt; will contain a subdirectory for each virtual host name supported. Further, both hosts advertise repositories simply as &lt;code&gt;git://www.example.com/software/repo.git&lt;/code&gt;. For pre-1.4.0 clients, a symlink from &lt;code&gt;/software&lt;/code&gt; into the appropriate default repository could be made as well.</source>
          <target state="translated">이 예에서 루트 레벨 디렉토리 &lt;code&gt;/pub&lt;/code&gt; 는 지원되는 각 가상 호스트 이름에 대한 서브 디렉토리를 포함합니다. 또한 두 호스트 모두 단순히 &lt;code&gt;git://www.example.com/software/repo.git&lt;/code&gt; 과 같이 리포지토리를 보급합니다 . 1.4.0 이전 클라이언트의 경우 &lt;code&gt;/software&lt;/code&gt; 에서 적절한 기본 리포지토리로 심볼릭 링크를 만들 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="4f73381570064f6ad92295b54ae4d9111ba415e0" translate="yes" xml:space="preserve">
          <source>In this example, there are 3 old and 3 new commits, where the developer removed the 3rd, added a new one before the first two, and modified the commit message of the 2nd commit as well its diff.</source>
          <target state="translated">이 예에는 3 개의 이전 커밋과 3 개의 새로운 커밋이 있으며, 여기서 개발자는 3 번째를 제거하고 처음 2 개 전에 새로운 것을 추가하고 2 번째 커밋의 커밋 메시지와 diff를 수정했습니다.</target>
        </trans-unit>
        <trans-unit id="5f85b35b8b6aae26894cfdfbe33e3822a8120573" translate="yes" xml:space="preserve">
          <source>In this example, we passed &quot;grep &lt;code&gt;^SUBLEVEL = 25&lt;/code&gt; Makefile&quot; as parameter to &quot;git bisect run&quot;. This means that at each step, the grep command we passed will be launched. And if it exits with code 0 (that means success) then git bisect will mark the current state as &quot;good&quot;. If it exits with code 1 (or any code between 1 and 127 included, except the special code 125), then the current state will be marked as &quot;bad&quot;.</source>
          <target state="translated">이 예에서는 매개 변수로 &quot; grep &lt;code&gt;^SUBLEVEL = 25&lt;/code&gt; Makefile&quot;을 &quot;git bisect run&quot;에 전달했습니다. 이는 각 단계에서 전달한 grep 명령이 시작됨을 의미합니다. 그리고 코드 0 (성공을 의미)으로 종료되면 git bisect는 현재 상태를 &quot;good&quot;으로 표시합니다. 코드 1 (또는 특수 코드 125를 제외하고 1과 127 사이의 코드 포함)로 종료되면 현재 상태가 &quot;나쁜&quot;것으로 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="eee8776c9677f60ee6e97b993bed2ed1a91281bf" translate="yes" xml:space="preserve">
          <source>In this format, each line is output after a header; the header at the minimum has the first line which has:</source>
          <target state="translated">이 형식에서 각 줄은 헤더 다음에 출력됩니다. 최소한 헤더에는 다음과 같은 첫 번째 줄이 있습니다.</target>
        </trans-unit>
        <trans-unit id="991df4351922c60c45e086aff27d9273fe47de49" translate="yes" xml:space="preserve">
          <source>In this format, use 40 &quot;0&quot; to specify a zero value, and use the empty string to specify a missing value.</source>
          <target state="translated">이 형식에서는 40 &quot;0&quot;을 사용하여 0 값을 지정하고 빈 문자열을 사용하여 결 측값을 지정하십시오.</target>
        </trans-unit>
        <trans-unit id="b4a37ae142e5dfb709dfd08bf26fc04d26f39f66" translate="yes" xml:space="preserve">
          <source>In this mode, specific configuration stays in the path pointed by &lt;code&gt;git
rev-parse --git-path config.worktree&lt;/code&gt;. You can add or update configuration in this file with &lt;code&gt;git config --worktree&lt;/code&gt;. Older Git versions will refuse to access repositories with this extension.</source>
          <target state="translated">이 모드에서 특정 구성은 &lt;code&gt;git rev-parse --git-path config.worktree&lt;/code&gt; 가리키는 경로에 유지됩니다 . 이 파일에서 &lt;code&gt;git config --worktree&lt;/code&gt; 를 사용 하여 구성을 추가하거나 업데이트 할 수 있습니다 . 이전 Git 버전은이 확장을 사용하여 리포지토리에 대한 액세스를 거부합니다.</target>
        </trans-unit>
        <trans-unit id="26cf2860c6712d39e5cbcd807f1756d9308dfdb3" translate="yes" xml:space="preserve">
          <source>In this mode, the index is split into two files, $GIT_DIR/index and $GIT_DIR/sharedindex.&amp;lt;SHA-1&amp;gt;. Changes are accumulated in $GIT_DIR/index, the split index, while the shared index file contains all index entries and stays unchanged.</source>
          <target state="translated">이 모드에서 인덱스는 $ GIT_DIR / index 및 $ GIT_DIR / sharedindex. &amp;lt;SHA-1&amp;gt;의 두 파일로 분할됩니다. 변경 사항은 $ GIT_DIR / index (분할 인덱스)에 누적되는 반면 공유 인덱스 파일에는 모든 인덱스 항목이 포함되며 변경되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="ffc9d6f506ae4dc0ef8e821987c60f58237503b7" translate="yes" xml:space="preserve">
          <source>In this mode, the server will not request authentication until the client actually starts the object negotiation phase of the push, rather than during the initial contact. For this reason, you must also enable the &lt;code&gt;http.receivepack&lt;/code&gt; config option in any repositories that should accept a push. The default behavior, if &lt;code&gt;http.receivepack&lt;/code&gt; is not set, is to reject any pushes by unauthenticated users; the initial request will therefore report &lt;code&gt;403 Forbidden&lt;/code&gt; to the client, without even giving an opportunity for authentication.</source>
          <target state="translated">이 모드에서 서버는 클라이언트가 실제로 초기 접촉 중에가 아니라 푸시의 개체 협상 단계를 시작할 때까지 인증을 요청하지 않습니다. 이러한 이유로 푸시를 허용해야하는 모든 저장소에서 &lt;code&gt;http.receivepack&lt;/code&gt; 구성 옵션 도 활성화해야합니다 . &lt;code&gt;http.receivepack&lt;/code&gt; 이 설정되지 않은 경우 기본 동작 은 인증되지 않은 사용자의 푸시를 거부하는 것입니다. 따라서 초기 요청은 인증 기회를주지 않고 클라이언트에게 &lt;code&gt;403 Forbidden&lt;/code&gt; 을 보고 합니다.</target>
        </trans-unit>
        <trans-unit id="427d8f8d92a71761648b972f0beb3c2aad83aaaa" translate="yes" xml:space="preserve">
          <source>In this more general usage, you provide &lt;code&gt;git bisect&lt;/code&gt; with a &quot;new&quot; commit that has some property and an &quot;old&quot; commit that doesn&amp;rsquo;t have that property. Each time &lt;code&gt;git bisect&lt;/code&gt; checks out a commit, you test if that commit has the property. If it does, mark the commit as &quot;new&quot;; otherwise, mark it as &quot;old&quot;. When the bisection is done, &lt;code&gt;git bisect&lt;/code&gt; will report which commit introduced the property.</source>
          <target state="translated">이 일반적인 사용법에서는 &lt;code&gt;git bisect&lt;/code&gt; 에 일부 속성이있는 &quot;new&quot;커밋과 해당 속성이없는 &quot;old&quot;커밋을 제공합니다. &lt;code&gt;git bisect&lt;/code&gt; 가 커밋을 체크 아웃 할 때마다 해당 커밋에 속성이 있는지 테스트합니다. 그렇다면 커밋을 &quot;new&quot;로 표시하십시오. 그렇지 않으면 &quot;이전&quot;으로 표시하십시오. bisection이 완료되면 &lt;code&gt;git bisect&lt;/code&gt; 는 어떤 커밋이 속성을 도입했는지보고합니다.</target>
        </trans-unit>
        <trans-unit id="e6da0601a9e7aee317ec7d6d594e01f938b779c4" translate="yes" xml:space="preserve">
          <source>In unusual scenarios, you may not be able to create files larger than a certain size on your filesystem, and this option can be used to tell the command to split the output packfile into multiple independent packfiles, each not larger than the given size. The size can be suffixed with &quot;k&quot;, &quot;m&quot;, or &quot;g&quot;. The minimum size allowed is limited to 1 MiB. This option prevents the creation of a bitmap index. The default is unlimited, unless the config variable &lt;code&gt;pack.packSizeLimit&lt;/code&gt; is set.</source>
          <target state="translated">비정상적인 시나리오에서는 파일 시스템에서 특정 크기보다 큰 파일을 작성하지 못할 수 있으며이 옵션을 사용하여 출력 팩 파일을 지정된 크기보다 크지 않은 여러 개의 독립된 팩 파일로 분할하도록 명령에 지시 할 수 있습니다. 크기는 &quot;k&quot;, &quot;m&quot;또는 &quot;g&quot;로 접미사를 붙일 수 있습니다. 허용되는 최소 크기는 1MiB로 제한됩니다. 이 옵션은 비트 맵 인덱스 생성을 방지합니다. 구성 변수 &lt;code&gt;pack.packSizeLimit&lt;/code&gt; 가 설정되어 있지 않으면 기본값은 무제한 입니다.</target>
        </trans-unit>
        <trans-unit id="4e6119784d7cd9e9e9f521473e212223da8f242e" translate="yes" xml:space="preserve">
          <source>In versions of Git before 2.23.0 patterns containing \0 would be silently considered fixed. This was never documented, there were also odd and undocumented interactions between e.g. non-ASCII patterns containing \0 and &lt;code&gt;--ignore-case&lt;/code&gt;.</source>
          <target state="translated">\ 0을 포함하는 2.23.0 패턴 이전의 Git 버전에서는 자동으로 수정 된 것으로 간주됩니다. 이것은 문서화되지 않았으며, \ 0과 &lt;code&gt;--ignore-case&lt;/code&gt; 를 포함하는 비 ASCII 패턴 사이에 홀수 및 문서화되지 않은 상호 작용도있었습니다 .</target>
        </trans-unit>
        <trans-unit id="5da95a93eebb0b267da3b6f30d0296fee9bbc09f" translate="yes" xml:space="preserve">
          <source>Inactive branches are stored in a structure which uses 96 or 120 bytes (32 bit or 64 bit systems, respectively), plus the length of the branch name (typically under 200 bytes), per branch. fast-import will easily handle as many as 10,000 inactive branches in under 2 MiB of memory.</source>
          <target state="translated">비활성 분기는 분기당 96 또는 120 바이트 (각각 32 비트 또는 64 비트 시스템)와 분기 이름의 길이 (일반적으로 200 바이트 미만)를 사용하는 구조에 저장됩니다. 빠른 가져 오기는 2MiB 미만의 메모리에서 최대 10,000 개의 비활성 분기를 쉽게 처리합니다.</target>
        </trans-unit>
        <trans-unit id="40bf5b4a4e7b04d6908a8f7645b8e99e811e42d8" translate="yes" xml:space="preserve">
          <source>Include Some Progress Messages</source>
          <target state="translated">일부 진행 메시지 포함</target>
        </trans-unit>
        <trans-unit id="d1a7a0c5683de418c5f98fc4beae70e15874a175" translate="yes" xml:space="preserve">
          <source>Include a line &amp;ldquo;log size &amp;lt;number&amp;gt;&amp;rdquo; in the output for each commit, where &amp;lt;number&amp;gt; is the length of that commit&amp;rsquo;s message in bytes. Intended to speed up tools that read log messages from &lt;code&gt;git log&lt;/code&gt; output by allowing them to allocate space in advance.</source>
          <target state="translated">각 커밋에 대한 출력에&amp;ldquo;log size &amp;lt;number&amp;gt;&amp;rdquo;행을 포함 시키십시오. 여기서 &amp;lt;number&amp;gt;는 해당 커밋 메시지의 길이 (바이트)입니다. 공간을 미리 할당하여 &lt;code&gt;git log&lt;/code&gt; 출력 에서 로그 메시지를 읽는 도구의 속도를 높이기 위해 사용 되었습니다.</target>
        </trans-unit>
        <trans-unit id="af14d11414c6ac75b39c95b283e5bcf0f4ccb002" translate="yes" xml:space="preserve">
          <source>Include additional statistics at the end of blame output.</source>
          <target state="translated">비난 출력의 끝에 추가 통계를 포함시킵니다.</target>
        </trans-unit>
        <trans-unit id="47c5e0ca752d4a1deb14e562052c4b503ef081b0" translate="yes" xml:space="preserve">
          <source>Include commits that are reachable from &amp;lt;rev&amp;gt; (i.e. &amp;lt;rev&amp;gt; and its ancestors).</source>
          <target state="translated">&amp;lt;rev&amp;gt;에서 도달 할 수있는 커밋을 포함하십시오 (예 : &amp;lt;rev&amp;gt; 및 해당 조상).</target>
        </trans-unit>
        <trans-unit id="9605f416b0921199291f14b56df68cc8fe57350a" translate="yes" xml:space="preserve">
          <source>Include commits that are reachable from &amp;lt;rev2&amp;gt; but exclude those that are reachable from &amp;lt;rev1&amp;gt;. When either &amp;lt;rev1&amp;gt; or &amp;lt;rev2&amp;gt; is omitted, it defaults to &lt;code&gt;HEAD&lt;/code&gt;.</source>
          <target state="translated">&amp;lt;rev2&amp;gt;에서 도달 가능한 커밋은 포함하지만 &amp;lt;rev1&amp;gt;에서 도달 가능한 커밋은 제외하십시오. &amp;lt;rev1&amp;gt; 또는 &amp;lt;rev2&amp;gt;가 생략되면 기본값은 &lt;code&gt;HEAD&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="ce2adffe692042c194b87264e9afec51300d7f42" translate="yes" xml:space="preserve">
          <source>Include commits that are reachable from either &amp;lt;rev1&amp;gt; or &amp;lt;rev2&amp;gt; but exclude those that are reachable from both. When either &amp;lt;rev1&amp;gt; or &amp;lt;rev2&amp;gt; is omitted, it defaults to &lt;code&gt;HEAD&lt;/code&gt;.</source>
          <target state="translated">&amp;lt;rev1&amp;gt; 또는 &amp;lt;rev2&amp;gt;에서 도달 할 수있는 커밋을 포함하지만 둘 다에서 도달 할 수있는 커밋은 제외하십시오. &amp;lt;rev1&amp;gt; 또는 &amp;lt;rev2&amp;gt;가 생략되면 기본값은 &lt;code&gt;HEAD&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="a1236fce64f1fb93f2ef7dcc7912c2d79c1d22c1" translate="yes" xml:space="preserve">
          <source>Include cross-references to the glossary, where appropriate.</source>
          <target state="translated">적절한 경우 용어집에 대한 상호 참조를 포함하십시오.</target>
        </trans-unit>
        <trans-unit id="ac12c15729a8f56d7cafe2e8c1b0d7927d0e53f1" translate="yes" xml:space="preserve">
          <source>Include debugging information related to the movement of lines between files (see &lt;code&gt;-C&lt;/code&gt;) and lines moved within a file (see &lt;code&gt;-M&lt;/code&gt;). The first number listed is the score. This is the number of alphanumeric characters detected as having been moved between or within files. This must be above a certain threshold for &lt;code&gt;git blame&lt;/code&gt; to consider those lines of code to have been moved.</source>
          <target state="translated">파일 간 행 이동 ( &lt;code&gt;-C&lt;/code&gt; 참조 )과 파일 내에서 이동 한 행 ( &lt;code&gt;-M&lt;/code&gt; 참조)과 관련된 디버깅 정보를 포함 하십시오 . 첫 번째 숫자는 점수입니다. 파일 간 또는 파일 내에서 이동 한 것으로 감지 된 영숫자 수입니다. &lt;code&gt;git blame&lt;/code&gt; 이 이러한 코드 행을 이동 한 것으로 간주하려면 특정 임계 값보다 높아야 합니다.</target>
        </trans-unit>
        <trans-unit id="eac52c02432a2a159a563ec983012928139e33b8" translate="yes" xml:space="preserve">
          <source>Include objects in &lt;code&gt;.keep&lt;/code&gt; files when repacking. Note that we still do not delete &lt;code&gt;.keep&lt;/code&gt; packs after &lt;code&gt;pack-objects&lt;/code&gt; finishes. This means that we may duplicate objects, but this makes the option safe to use when there are concurrent pushes or fetches. This option is generally only useful if you are writing bitmaps with &lt;code&gt;-b&lt;/code&gt; or &lt;code&gt;repack.writeBitmaps&lt;/code&gt;, as it ensures that the bitmapped packfile has the necessary objects.</source>
          <target state="translated">재 포장 할 때 &lt;code&gt;.keep&lt;/code&gt; 파일에 객체를 포함 시킵니다 . &lt;code&gt;pack-objects&lt;/code&gt; 가 완료된 후에도 &lt;code&gt;.keep&lt;/code&gt; pack을 삭제하지는 않습니다 . 즉, 객체를 복제 할 수 있지만 동시 푸시 또는 페치가있을 때 옵션을 안전하게 사용할 수 있습니다. 이 옵션은 일반적으로 비트 맵 팩 파일에 필요한 객체가 있으므로 &lt;code&gt;-b&lt;/code&gt; 또는 &lt;code&gt;repack.writeBitmaps&lt;/code&gt; 로 비트 맵을 작성하는 경우에만 유용 합니다.</target>
        </trans-unit>
        <trans-unit id="3b3acf7c7b624670bc98269d1db58c312d8f1ad9" translate="yes" xml:space="preserve">
          <source>Include patch text in the output.</source>
          <target state="translated">출력에 패치 텍스트를 포함하십시오.</target>
        </trans-unit>
        <trans-unit id="7f58d83c9ac95ca37a657dfc92f2d025971598c2" translate="yes" xml:space="preserve">
          <source>Include the output of &lt;a href=&quot;git-status&quot;&gt;git-status[1]&lt;/a&gt; in the commit message template when using an editor to prepare the commit message. Defaults to on, but can be used to override configuration variable commit.status.</source>
          <target state="translated">커밋 메시지를 준비하기 위해 편집기를 사용할 때 커밋 메시지 템플릿 에 &lt;a href=&quot;git-status&quot;&gt;git-status [1]&lt;/a&gt; 의 출력을 포함시킵니다 . 기본값은 on이지만 구성 변수 commit.status를 재정의하는 데 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="798a42403927f2977bd316b8bb1bba46f3e2c944" translate="yes" xml:space="preserve">
          <source>Include unasked-for annotated tags if the object they reference was included in the resulting packfile. This can be useful to send new tags to native Git clients.</source>
          <target state="translated">참조하는 객체가 결과 팩 파일에 포함 된 경우 주석이 달린 태그가없는 태그를 포함시킵니다. 기본 Git 클라이언트에 새 태그를 보내는 데 유용 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c5f574d342fa2383147936f6ccc821ddf1edb5ef" translate="yes" xml:space="preserve">
          <source>Included in a &lt;code&gt;commit&lt;/code&gt; command to add a new file or change the content of an existing file. This command has two different means of specifying the content of the file.</source>
          <target state="translated">새 파일을 추가하거나 기존 파일의 내용을 변경하기 위해 &lt;code&gt;commit&lt;/code&gt; 명령에 포함 됩니다. 이 명령에는 파일의 내용을 지정하는 두 가지 방법이 있습니다.</target>
        </trans-unit>
        <trans-unit id="8dfee16c07e63cf25f2958c656ce64f423b1c0b9" translate="yes" xml:space="preserve">
          <source>Included in a &lt;code&gt;commit&lt;/code&gt; command to remove a file or recursively delete an entire directory from the branch. If the file or directory removal makes its parent directory empty, the parent directory will be automatically removed too. This cascades up the tree until the first non-empty directory or the root is reached.</source>
          <target state="translated">&lt;code&gt;commit&lt;/code&gt; 명령에 포함되어 파일을 제거하거나 분기에서 전체 디렉토리를 반복적으로 삭제합니다. 파일 또는 디렉토리를 제거하면 상위 디렉토리가 비어 있으면 상위 디렉토리도 자동으로 제거됩니다. 비어 있지 않은 첫 번째 디렉토리 또는 루트에 도달 할 때까지 트리를 계단식으로 표시합니다.</target>
        </trans-unit>
        <trans-unit id="87d365412b703101b1d281d9e93e3f278251dd0d" translate="yes" xml:space="preserve">
          <source>Included in a &lt;code&gt;commit&lt;/code&gt; command to remove all files (and also all directories) from the branch. This command resets the internal branch structure to have no files in it, allowing the frontend to subsequently add all interesting files from scratch.</source>
          <target state="translated">분기에서 모든 파일 (및 모든 디렉토리)을 제거 하는 &lt;code&gt;commit&lt;/code&gt; 명령에 포함됩니다 . 이 명령은 내부 분기 구조에 파일이 없도록 다시 설정하여 프런트 엔드가 모든 흥미로운 파일을 처음부터 추가 할 수 있도록합니다.</target>
        </trans-unit>
        <trans-unit id="28dccd9788a09aa2f373fa8c25c3b39e9406a080" translate="yes" xml:space="preserve">
          <source>Included in a &lt;code&gt;commit&lt;/code&gt;&lt;code&gt;&amp;lt;notes_ref&amp;gt;&lt;/code&gt; command to add a new note annotating a &lt;code&gt;&amp;lt;commit-ish&amp;gt;&lt;/code&gt; or change this annotation contents. Internally it is similar to filemodify 100644 on &lt;code&gt;&amp;lt;commit-ish&amp;gt;&lt;/code&gt; path (maybe split into subdirectories). It&amp;rsquo;s not advised to use any other commands to write to the &lt;code&gt;&amp;lt;notes_ref&amp;gt;&lt;/code&gt; tree except &lt;code&gt;filedeleteall&lt;/code&gt; to delete all existing notes in this tree. This command has two different means of specifying the content of the note.</source>
          <target state="translated">&lt;code&gt;commit&lt;/code&gt; &lt;code&gt;&amp;lt;notes_ref&amp;gt;&lt;/code&gt; 명령에 포함되어 &lt;code&gt;&amp;lt;commit-ish&amp;gt;&lt;/code&gt; 에 주석을 달는 새 메모를 추가 하거나이 주석 내용을 변경합니다. 내부적으로 &lt;code&gt;&amp;lt;commit-ish&amp;gt;&lt;/code&gt; 경로의 filemodify 100644와 유사 합니다 (하위 디렉토리로 분할 될 수 있음). &lt;code&gt;filedeleteall&lt;/code&gt; 을 제외하고 &lt;code&gt;&amp;lt;notes_ref&amp;gt;&lt;/code&gt; 트리 에 쓰는 다른 명령을 사용 하여이 트리에있는 기존의 모든 노트를 삭제 하지 않는 것이 좋습니다 . 이 명령에는 메모 내용을 지정하는 두 가지 방법이 있습니다.</target>
        </trans-unit>
        <trans-unit id="db54974f7f0ad531e35648ba85b9388029b4d7ef" translate="yes" xml:space="preserve">
          <source>Includes</source>
          <target state="translated">Includes</target>
        </trans-unit>
        <trans-unit id="de153f024523e4c2c467ece94c841922a681ecff" translate="yes" xml:space="preserve">
          <source>Includes one additional ancestor commit. The additional ancestry link does not change the way the tree state is built at this commit. If the &lt;code&gt;from&lt;/code&gt; command is omitted when creating a new branch, the first &lt;code&gt;merge&lt;/code&gt; commit will be the first ancestor of the current commit, and the branch will start out with no files. An unlimited number of &lt;code&gt;merge&lt;/code&gt; commands per commit are permitted by fast-import, thereby establishing an n-way merge.</source>
          <target state="translated">하나의 추가 조상 커밋을 포함합니다. 추가 상위 링크는이 커밋에서 트리 상태가 구축되는 방식을 변경하지 않습니다. 는 IF &lt;code&gt;from&lt;/code&gt; 새로운 지점을 만들 때 명령이 생략 첫 번째 &lt;code&gt;merge&lt;/code&gt; 커밋 현재의 첫 조상이 커밋 될 것이며, 지점이없는 파일로 시작됩니다. 커밋 당 무제한의 &lt;code&gt;merge&lt;/code&gt; 명령이 빠른 가져 오기로 허용되므로 n-way 병합이 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="8623cf320c015aba351966293c038ddef6f53905" translate="yes" xml:space="preserve">
          <source>Incompatible options</source>
          <target state="translated">호환되지 않는 옵션</target>
        </trans-unit>
        <trans-unit id="9020a39adcad5a9de717e37976fa2cef184a1df6" translate="yes" xml:space="preserve">
          <source>Incorporates changes from a remote repository into the current branch. In its default mode, &lt;code&gt;git pull&lt;/code&gt; is shorthand for &lt;code&gt;git fetch&lt;/code&gt; followed by &lt;code&gt;git merge FETCH_HEAD&lt;/code&gt;.</source>
          <target state="translated">원격 저장소에서 현재 분기로 변경 사항을 통합합니다. 기본 모드에서는 &lt;code&gt;git pull&lt;/code&gt; 위한 속기 &lt;code&gt;git fetch&lt;/code&gt; 다음에 &lt;code&gt;git merge FETCH_HEAD&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4d61077e89adde5af7a04457989a77b3c48490ae" translate="yes" xml:space="preserve">
          <source>Incorporates changes from the named commits (since the time their histories diverged from the current branch) into the current branch. This command is used by &lt;code&gt;git pull&lt;/code&gt; to incorporate changes from another repository and can be used by hand to merge changes from one branch into another.</source>
          <target state="translated">이름이 지정된 커밋 (이력이 현재 분기에서 분기 된 시점부터)에서 현재 분기로 변경 사항을 통합합니다. 이 명령은 &lt;code&gt;git pull&lt;/code&gt; 에서 다른 저장소의 변경 사항을 통합하는 데 사용되며 한 분기에서 다른 분기로 변경 사항을 병합하는 데 직접 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="709702f7f984cb3913cdb163bc5d2fe003c81b05" translate="yes" xml:space="preserve">
          <source>Incremental output</source>
          <target state="translated">증분 출력</target>
        </trans-unit>
        <trans-unit id="571937052d91a812bc84d435a3200a79bb1a0ee1" translate="yes" xml:space="preserve">
          <source>Indeed untestable commits are often untestable because a breakage was introduced at one time, and that breakage was fixed only after many other commits were introduced.</source>
          <target state="translated">실제로 테스트 할 수없는 커밋은 한 번에 파손이 발생하여 테스트 할 수없는 경우가 많으며, 다른 많은 커밋이 도입 된 후에야 손상이 수정되었습니다.</target>
        </trans-unit>
        <trans-unit id="78699f384a94184571a61ab6b2f36f5cdf341b61" translate="yes" xml:space="preserve">
          <source>Indicate that only the objects wanted need to be fetched, not their dependents.</source>
          <target state="translated">종속물이 아닌 원하는 객체 만 가져와야 함을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="d063c49b2950871e5e846c69f89ed3fa8315be66" translate="yes" xml:space="preserve">
          <source>Indicate that these objects are being fetched from a promisor.</source>
          <target state="translated">이러한 개체가 약속에서 가져오고 있음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="d4b8f31320c23f43d173d656edb4ca6c63551ac5" translate="yes" xml:space="preserve">
          <source>Indicates a blob object name.</source>
          <target state="translated">얼룩 개체 이름을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="6d441ed12cf0b86c55591d731de178963fe6c1ee" translate="yes" xml:space="preserve">
          <source>Indicates a commit object name.</source>
          <target state="translated">커밋 개체 이름을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="e89d58f77c5643f4921d84ac3c1216b6dc569e02" translate="yes" xml:space="preserve">
          <source>Indicates a commit or tag object name. A command that takes a &amp;lt;commit-ish&amp;gt; argument ultimately wants to operate on a &amp;lt;commit&amp;gt; object but automatically dereferences &amp;lt;tag&amp;gt; objects that point at a &amp;lt;commit&amp;gt;.</source>
          <target state="translated">커밋 또는 태그 객체 이름을 나타냅니다. &amp;lt;commit-ish&amp;gt; 인수를 사용하는 명령은 궁극적으로 &amp;lt;commit&amp;gt; 객체에서 작동하려고하지만 &amp;lt;commit&amp;gt;을 가리키는 &amp;lt;tag&amp;gt; 객체를 자동으로 역 참조합니다.</target>
        </trans-unit>
        <trans-unit id="31963740af1f01e0807009b4b0a81e30ade64f1a" translate="yes" xml:space="preserve">
          <source>Indicates a filename - almost always relative to the root of the tree structure &lt;code&gt;GIT_INDEX_FILE&lt;/code&gt; describes.</source>
          <target state="translated">파일 이름을 나타냅니다. 거의 항상 &lt;code&gt;GIT_INDEX_FILE&lt;/code&gt; 이 설명 하는 트리 구조의 루트를 기준으로합니다 .</target>
        </trans-unit>
        <trans-unit id="c59be5c9a5ab736a07e28f031fa629ea1cac80d9" translate="yes" xml:space="preserve">
          <source>Indicates a tree object name.</source>
          <target state="translated">트리 개체 이름을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="0236f6573fabb077368d656582f35373ba9e33e6" translate="yes" xml:space="preserve">
          <source>Indicates a tree, commit or tag object name. A command that takes a &amp;lt;tree-ish&amp;gt; argument ultimately wants to operate on a &amp;lt;tree&amp;gt; object but automatically dereferences &amp;lt;commit&amp;gt; and &amp;lt;tag&amp;gt; objects that point at a &amp;lt;tree&amp;gt;.</source>
          <target state="translated">트리, 커밋 또는 태그 객체 이름을 나타냅니다. &amp;lt;tree-ish&amp;gt; 인수를받는 명령은 궁극적으로 &amp;lt;tree&amp;gt; 객체에서 작동하려고하지만 &amp;lt;tree&amp;gt;를 가리키는 &amp;lt;commit&amp;gt; 및 &amp;lt;tag&amp;gt; 객체를 자동으로 역 참조합니다.</target>
        </trans-unit>
        <trans-unit id="73ecb0013f5389f15738299d7b0ca5b5c29b261f" translate="yes" xml:space="preserve">
          <source>Indicates that an object type is required. Currently one of: &lt;code&gt;blob&lt;/code&gt;, &lt;code&gt;tree&lt;/code&gt;, &lt;code&gt;commit&lt;/code&gt;, or &lt;code&gt;tag&lt;/code&gt;.</source>
          <target state="translated">객체 유형이 필요함을 나타냅니다. 현재 &lt;code&gt;blob&lt;/code&gt; , &lt;code&gt;tree&lt;/code&gt; , &lt;code&gt;commit&lt;/code&gt; 또는 &lt;code&gt;tag&lt;/code&gt; 중 하나입니다 .</target>
        </trans-unit>
        <trans-unit id="db4dbaff6f210d92fcd8a0947f8ffe2ad6166cf6" translate="yes" xml:space="preserve">
          <source>Indicates the object name for any type of object.</source>
          <target state="translated">모든 유형의 객체에 대한 객체 이름을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="c66f56b69efd11f38dd2949f22030f51d42bccb8" translate="yes" xml:space="preserve">
          <source>Individual developer (participant)</source>
          <target state="translated">개인 개발자 (참가자)</target>
        </trans-unit>
        <trans-unit id="dc704b04bf6fc4b099b66d2f7d86d56e0d061d7a" translate="yes" xml:space="preserve">
          <source>Individual developer (standalone)</source>
          <target state="translated">개별 개발자 (독립형)</target>
        </trans-unit>
        <trans-unit id="a964b0aa320ab2176eba7cb0319b97ea34b340ac" translate="yes" xml:space="preserve">
          <source>Individually replay all rebased commits instead of fast-forwarding over the unchanged ones. This ensures that the entire history of the rebased branch is composed of new commits.</source>
          <target state="translated">변경되지 않은 것을 빠르게 전달하는 대신 모든 재 기반 커밋을 개별적으로 재생합니다. 이를 통해 리베이스 브랜치의 전체 히스토리가 새 확약으로 구성됩니다.</target>
        </trans-unit>
        <trans-unit id="0eb5ed506e4923c28d7f4a8aa69efe99b3ad75d1" translate="yes" xml:space="preserve">
          <source>Information</source>
          <target state="translated">Information</target>
        </trans-unit>
        <trans-unit id="9bceb94c72e397fee5b7ad78b8c9312ee6319e43" translate="yes" xml:space="preserve">
          <source>Information about what is to be pushed is provided on the hook&amp;rsquo;s standard input with lines of the form:</source>
          <target state="translated">푸시 대상에 대한 정보는 다음과 같은 형식의 후크가있는 후크의 표준 입력에 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="43d35f7b76c469225469fd7a04662a08053d1e63" translate="yes" xml:space="preserve">
          <source>Initial client request</source>
          <target state="translated">초기 고객 요청</target>
        </trans-unit>
        <trans-unit id="68fa16ffd48f366e4fa8d57fea78ff03fcab0191" translate="yes" xml:space="preserve">
          <source>Initialization</source>
          <target state="translated">Initialization</target>
        </trans-unit>
        <trans-unit id="1b499097655f7a7af4711e162d7e54be3deca803" translate="yes" xml:space="preserve">
          <source>Initialization happens in &lt;code&gt;main()&lt;/code&gt;. Behind the scenes, an &lt;code&gt;atexit&lt;/code&gt; and &lt;code&gt;signal&lt;/code&gt; handler are registered.</source>
          <target state="translated">초기화는 &lt;code&gt;main()&lt;/code&gt; 에서 발생합니다 . 장면 뒤에는 &lt;code&gt;atexit&lt;/code&gt; 과 &lt;code&gt;signal&lt;/code&gt; handler가 등록되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="42e32f1c6a8cf663f45361425590d312db136ea3" translate="yes" xml:space="preserve">
          <source>Initialize and modify the sparse-checkout</source>
          <target state="translated">스파 스 체크 아웃 초기화 및 수정</target>
        </trans-unit>
        <trans-unit id="5be83bd5256f93987e394207f3c5233baf2d713e" translate="yes" xml:space="preserve">
          <source>Initialize and modify the sparse-checkout configuration, which reduces the checkout to a set of paths given by a list of patterns.</source>
          <target state="translated">스파 스 체크 아웃 구성을 초기화하고 수정하여 체크 아웃을 패턴 목록으로 지정된 경로 세트로 줄입니다.</target>
        </trans-unit>
        <trans-unit id="825b58a6f65001fb659dd3ff519bf4df985a29aa" translate="yes" xml:space="preserve">
          <source>Initialize the sparse-checkout file so the working directory starts with only the files in the root of the repository. The sparse-checkout file can be modified to grow the working directory as needed.</source>
          <target state="translated">스파 스 체크 아웃 파일을 초기화하여 작업 디렉토리가 저장소 루트의 파일로만 시작되도록하십시오. 스파 스 체크 아웃 파일을 수정하여 필요에 따라 작업 디렉토리를 확장 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9e0eca47ea83eb468f0ac7fe2e029fd23bbe773e" translate="yes" xml:space="preserve">
          <source>Initialize the submodules recorded in the index (which were added and committed elsewhere) by setting &lt;code&gt;submodule.$name.url&lt;/code&gt; in .git/config. It uses the same setting from &lt;code&gt;.gitmodules&lt;/code&gt; as a template. If the URL is relative, it will be resolved using the default remote. If there is no default remote, the current repository will be assumed to be upstream.</source>
          <target state="translated">.git / config에서 &lt;code&gt;submodule.$name.url&lt;/code&gt; 을 설정하여 인덱스에 기록 된 서브 모듈 (다른 곳에서 추가되고 커밋 된)을 초기화하십시오 . &lt;code&gt;.gitmodules&lt;/code&gt; 의 템플릿 과 동일한 설정을 사용합니다 . 상대 URL 인 경우 기본 원격을 사용하여 해결됩니다. 기본 원격이없는 경우 현재 저장소는 업스트림 인 것으로 가정합니다.</target>
        </trans-unit>
        <trans-unit id="52f8f7589ec2fc901a83216cac5106872728a87d" translate="yes" xml:space="preserve">
          <source>Initialize, update or inspect submodules</source>
          <target state="translated">서브 모듈 초기화, 업데이트 또는 검사</target>
        </trans-unit>
        <trans-unit id="0d880d50dc463cd4220f01bcf54c48c1f2d57098" translate="yes" xml:space="preserve">
          <source>Initializes an empty Git repository with additional metadata directories for &lt;code&gt;git svn&lt;/code&gt;. The Subversion URL may be specified as a command-line argument, or as full URL arguments to -T/-t/-b. Optionally, the target directory to operate on can be specified as a second argument. Normally this command initializes the current directory.</source>
          <target state="translated">&lt;code&gt;git svn&lt;/code&gt; 에 대한 추가 메타 데이터 디렉토리를 사용하여 빈 Git 저장소를 초기화합니다 . Subversion URL은 명령 줄 인수 또는 -T / -t / -b에 대한 전체 URL 인수로 지정할 수 있습니다. 선택적으로 조작 할 대상 디렉토리를 두 ​​번째 인수로 지정할 수 있습니다. 일반적으로이 명령은 현재 디렉토리를 초기화합니다.</target>
        </trans-unit>
        <trans-unit id="01c2c8357a87e8a6148f1dd9a9c884aae5e4de53" translate="yes" xml:space="preserve">
          <source>Initially ignore any whitespace in the move detection, then group the moved code blocks only into a block if the change in whitespace is the same per line. This is incompatible with the other modes.</source>
          <target state="translated">이동 감지에서 공백을 먼저 무시한 다음 공백 변경이 한 줄에 동일한 경우 이동 된 코드 블록을 블록으로 만 그룹화하십시오. 다른 모드와 호환되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="229b7991e581f774e065f13c78dfa8719c8c393f" translate="yes" xml:space="preserve">
          <source>Inline data format</source>
          <target state="translated">인라인 데이터 형식</target>
        </trans-unit>
        <trans-unit id="7c7935726f449ea7185a4fe42a9ddf2d1c53a2e4" translate="yes" xml:space="preserve">
          <source>Input Format</source>
          <target state="translated">입력 형식</target>
        </trans-unit>
        <trans-unit id="1b77a7f4983f9ce773f466c761a7f6e9771bf925" translate="yes" xml:space="preserve">
          <source>Input format</source>
          <target state="translated">입력 형식</target>
        </trans-unit>
        <trans-unit id="789cc08a97020bab893e17ca6133192d1f9f1dac" translate="yes" xml:space="preserve">
          <source>Input is of the &quot;mboxrd&quot; format and &quot;^&amp;gt;+From &quot; line escaping is reversed.</source>
          <target state="translated">입력은 &quot;mboxrd&quot;형식이며 &quot;^&amp;gt; + From&quot;줄 이스케이프는 반대로됩니다.</target>
        </trans-unit>
        <trans-unit id="26242e7bd97bd8eebf44f9f25f143aed3a9bdc4d" translate="yes" xml:space="preserve">
          <source>Input/output format</source>
          <target state="translated">입출력 형식</target>
        </trans-unit>
        <trans-unit id="4038e1c7ebc07b210c228498bd5816f54233b768" translate="yes" xml:space="preserve">
          <source>Insert &lt;code&gt;progress&lt;/code&gt; statements every &amp;lt;n&amp;gt; objects, to be shown by &lt;code&gt;git fast-import&lt;/code&gt; during import.</source>
          <target state="translated">&lt;code&gt;git fast-import&lt;/code&gt; 동안 git fast-import 로 표시 될 &amp;lt;n&amp;gt; 객체마다 &lt;code&gt;progress&lt;/code&gt; 문을 삽입하십시오 .</target>
        </trans-unit>
        <trans-unit id="39c559793b49987eea00aba844e216707b6e7dcc" translate="yes" xml:space="preserve">
          <source>Insert custom links to the action bar of all project pages. This allows you to link to third-party scripts integrating into gitweb.</source>
          <target state="translated">모든 프로젝트 페이지의 작업 표시 줄에 사용자 정의 링크를 삽입하십시오. 이를 통해 gitweb에 통합 된 타사 스크립트에 연결할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ce8fd02283c353dc3cacd2d3e6c1eab64a1913a3" translate="yes" xml:space="preserve">
          <source>Inside double quotes, double quote &lt;code&gt;&quot;&lt;/code&gt; and backslash &lt;code&gt;\&lt;/code&gt; characters must be escaped: use &lt;code&gt;\&quot;&lt;/code&gt; for &lt;code&gt;&quot;&lt;/code&gt; and &lt;code&gt;\\&lt;/code&gt; for &lt;code&gt;\&lt;/code&gt;.</source>
          <target state="translated">큰 따옴표, 큰 따옴표 내부 &lt;code&gt;&quot;&lt;/code&gt; 와 백 슬래시 &lt;code&gt;\&lt;/code&gt; 문자는 이스케이프해야합니다 : 사용 &lt;code&gt;\&quot;&lt;/code&gt; 에 대한 &lt;code&gt;&quot;&lt;/code&gt; 과 &lt;code&gt;\\&lt;/code&gt; 를 들어 &lt;code&gt;\&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ab67c68674bb4a9f1f690fac98c95aa9c2e1e750" translate="yes" xml:space="preserve">
          <source>Inspecting changes</source>
          <target state="translated">변경 사항 검사</target>
        </trans-unit>
        <trans-unit id="ecf21e44dd8609734c0bc387cabc376ab485d9f8" translate="yes" xml:space="preserve">
          <source>Inspection and Comparison</source>
          <target state="translated">검사 및 비교</target>
        </trans-unit>
        <trans-unit id="e0c3f2780ee983978068137722cf2d423843d21f" translate="yes" xml:space="preserve">
          <source>Inspects, updates and manages submodules.</source>
          <target state="translated">하위 모듈을 검사, 업데이트 및 관리합니다.</target>
        </trans-unit>
        <trans-unit id="d9fb6eb12bbc11fdad6f18ee5bfa79361ddad72b" translate="yes" xml:space="preserve">
          <source>Install the Toggle Word Wrap add-on that is available from &lt;a href=&quot;https://addons.mozilla.org/thunderbird/addon/toggle-word-wrap/&quot;&gt;https://addons.mozilla.org/thunderbird/addon/toggle-word-wrap/&lt;/a&gt; It adds a menu entry &quot;Enable Word Wrap&quot; in the composer&amp;rsquo;s &quot;Options&quot; menu that you can tick off. Now you can compose the message as you otherwise do (cut + paste, &lt;code&gt;git format-patch&lt;/code&gt; | &lt;code&gt;git imap-send&lt;/code&gt;, etc), but you have to insert line breaks manually in any text that you type.</source>
          <target state="translated">&lt;a href=&quot;https://addons.mozilla.org/thunderbird/addon/toggle-word-wrap/&quot;&gt;https://addons.mozilla.org/thunderbird/addon/toggle-word-wrap/&lt;/a&gt; 에서 제공되는 Toggle Word Wrap 추가 기능을 설치합니다 . 작곡가의 &quot;옵션&quot;메뉴에 &quot;Word Wrap 사용&quot;메뉴 항목이 추가됩니다. 똑딱 거릴 수 있습니다. 이제 다른 방법으로 메시지를 작성할 수 있지만 (cut + paste, &lt;code&gt;git format-patch&lt;/code&gt; | &lt;code&gt;git imap-send&lt;/code&gt; 등) 입력하는 모든 텍스트에 줄 바꿈을 수동으로 삽입해야합니다.</target>
        </trans-unit>
        <trans-unit id="c81b79df3c6448eae7c4f80428b54cd5692a17d7" translate="yes" xml:space="preserve">
          <source>Installation</source>
          <target state="translated">Installation</target>
        </trans-unit>
        <trans-unit id="7fad939655efbad1612ce7f4867922684d56913b" translate="yes" xml:space="preserve">
          <source>Instantly browse your working repository in gitweb</source>
          <target state="translated">gitweb에서 작업 저장소를 즉시 탐색하십시오.</target>
        </trans-unit>
        <trans-unit id="53c902fb07156c6117155b6a0b0738c7ca12a6bf" translate="yes" xml:space="preserve">
          <source>Instead of &lt;code&gt;git bisect visualize&lt;/code&gt; and then &lt;code&gt;git reset --hard
fb47ddb2db&lt;/code&gt;, you might just want to tell Git that you want to skip the current commit:</source>
          <target state="translated">&lt;code&gt;git bisect visualize&lt;/code&gt; 한 다음 &lt;code&gt;git reset --hard fb47ddb2db&lt;/code&gt; 대신 Git에 현재 커밋을 건너 뛰고 싶다고 알려주십시오.</target>
        </trans-unit>
        <trans-unit id="483617d942bddc8b6c044cd054e06089960e1981" translate="yes" xml:space="preserve">
          <source>Instead of a commit id on the command line (which is not expected in this case), &lt;code&gt;git http-fetch&lt;/code&gt; expects lines on stdin in the format</source>
          <target state="translated">&lt;code&gt;git http-fetch&lt;/code&gt; 는 커맨드 라인에서 커밋 ID 대신 (이 경우에는 예상되지 않음) stdin의 라인을 형식으로 예상합니다.</target>
        </trans-unit>
        <trans-unit id="978fdd37a8d1d967862cc9e916d011571d6998cf" translate="yes" xml:space="preserve">
          <source>Instead of an absolute timestamp relative timestamps work as well, e.g. 2.weeks.ago is valid to address anything older than 2 weeks.</source>
          <target state="translated">절대 타임 스탬프 대신 상대적 타임 스탬프도 작동합니다. 예를 들어 2.weeks.ago는 2 주보다 오래된 모든 것을 처리하는 데 유효합니다.</target>
        </trans-unit>
        <trans-unit id="ad6345e758058b67dc8e001b3a11fe48b9b5f52b" translate="yes" xml:space="preserve">
          <source>Instead of applying the patch, output a condensed summary of information obtained from git diff extended headers, such as creations, renames and mode changes. Turns off &quot;apply&quot;.</source>
          <target state="translated">패치를 적용하는 대신, 생성, 이름 변경 및 모드 변경과 같은 git diff 확장 헤더에서 얻은 정보 요약 요약을 출력합니다. &quot;적용&quot;을 끕니다.</target>
        </trans-unit>
        <trans-unit id="5429abc21a21a789987424e6c0ab7612e06a85eb" translate="yes" xml:space="preserve">
          <source>Instead of applying the patch, output diffstat for the input. Turns off &quot;apply&quot;.</source>
          <target state="translated">패치를 적용하는 대신 입력에 대해 diffstat를 출력하십시오. &quot;적용&quot;을 끕니다.</target>
        </trans-unit>
        <trans-unit id="881bf52883e6605d5234b3f22aaf3b7b4afc6968" translate="yes" xml:space="preserve">
          <source>Instead of applying the patch, see if the patch is applicable to the current working tree and/or the index file and detects errors. Turns off &quot;apply&quot;.</source>
          <target state="translated">패치를 적용하는 대신 패치가 현재 작업 트리 및 / 또는 인덱스 파일에 적용 가능한지 확인하고 오류를 감지하십시오. &quot;적용&quot;을 끕니다.</target>
        </trans-unit>
        <trans-unit id="6e355f85b13671d925fde0c740a0dbae977bb0bc" translate="yes" xml:space="preserve">
          <source>Instead of basing a new branch on current HEAD (the default), use:</source>
          <target state="translated">현재 HEAD (기본값)를 기반으로 새 분기를 작성하는 대신 다음을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="54f9cd044bb973ffe696d82cb4d71b8b1fd61c38" translate="yes" xml:space="preserve">
          <source>Instead of calling cvsps, read the provided cvsps output file. Useful for debugging or when cvsps is being handled outside cvsimport.</source>
          <target state="translated">cvsp를 호출하는 대신 제공된 cvsps 출력 파일을 읽으십시오. 디버깅 또는 cvsps가 cvsimport 외부에서 처리 될 때 유용합니다.</target>
        </trans-unit>
        <trans-unit id="bb5ec3e62f50f37c713576e81a7468472cf1721e" translate="yes" xml:space="preserve">
          <source>Instead of checking out unmerged entries, copy out the files from named stage. &amp;lt;number&amp;gt; must be between 1 and 3. Note: --stage=all automatically implies --temp.</source>
          <target state="translated">병합되지 않은 항목을 체크 아웃하는 대신 명명 된 스테이지에서 파일을 복사하십시오. &amp;lt;number&amp;gt;는 1과 3 사이 여야합니다. 참고 : --stage = all은 자동으로 --temp를 의미합니다.</target>
        </trans-unit>
        <trans-unit id="15d18d5e837d77d2ad93145197274038afcfa944" translate="yes" xml:space="preserve">
          <source>Instead of choosing a nearby commit by yourself, you can ask Git to do it for you by issuing the command:</source>
          <target state="translated">근처 커밋을 직접 선택하는 대신 다음 명령을 실행하여 Git에 요청합니다.</target>
        </trans-unit>
        <trans-unit id="071c6c805d6df82b0ae0937a6e3d6e7d94979975" translate="yes" xml:space="preserve">
          <source>Instead of comparing with the tip of &quot;test&quot; branch, compare with the tip of the current branch, but limit the comparison to the file &quot;test&quot;.</source>
          <target state="translated">&quot;테스트&quot;분기의 팁과 비교하는 대신 현재 분기의 팁과 비교하지만 &quot;test&quot;파일로 비교를 제한하십시오.</target>
        </trans-unit>
        <trans-unit id="17207c6e7e5006477485c406ccec2ab95d9a0907" translate="yes" xml:space="preserve">
          <source>Instead of considering only the 10 most recent tags as candidates to describe the input commit-ish consider up to &amp;lt;n&amp;gt; candidates. Increasing &amp;lt;n&amp;gt; above 10 will take slightly longer but may produce a more accurate result. An &amp;lt;n&amp;gt; of 0 will cause only exact matches to be output.</source>
          <target state="translated">입력 커밋을 설명하기 위해 가장 최근 10 개의 태그 만 후보로 간주하는 대신 최대 &amp;lt;n&amp;gt; 개의 후보를 고려하십시오. &amp;lt;n&amp;gt;을 10보다 높이면 약간 더 오래 걸리지 만보다 정확한 결과를 얻을 수 있습니다. &amp;lt;n&amp;gt;이 0이면 정확히 일치하는 항목 만 출력됩니다.</target>
        </trans-unit>
        <trans-unit id="3d51a8a573b601f04a9b432f10be7818f6056cab" translate="yes" xml:space="preserve">
          <source>Instead of copying the files to the working directory write the content to temporary files. The temporary name associations will be written to stdout.</source>
          <target state="translated">작업 디렉토리에 파일을 복사하는 대신 컨텐츠를 임시 파일에 작성하십시오. 임시 이름 연결은 stdout에 작성됩니다.</target>
        </trans-unit>
        <trans-unit id="aece37f2a7e1b433117b2533e4c10ff1af967895" translate="yes" xml:space="preserve">
          <source>Instead of explicitly specifying which refs to update, update all heads that locally exist.</source>
          <target state="translated">업데이트 할 참조를 명시 적으로 지정하는 대신 로컬에 존재하는 모든 헤드를 업데이트하십시오.</target>
        </trans-unit>
        <trans-unit id="c9dd00560176cb59ca6811a38f98f0a00cea59a2" translate="yes" xml:space="preserve">
          <source>Instead of finding the tag that predates the commit, find the tag that comes after the commit, and thus contains it. Automatically implies --tags.</source>
          <target state="translated">커밋 이전의 태그를 찾는 대신 커밋 뒤에 오는 태그를 찾아서 포함합니다. --tags를 자동으로 암시합니다.</target>
        </trans-unit>
        <trans-unit id="c3bcf62d531bd115333abb263736c08fc67412f8" translate="yes" xml:space="preserve">
          <source>Instead of having gitweb find repositories by scanning filesystem starting from $projectroot, you can provide a pre-generated list of visible projects by setting &lt;code&gt;$projects_list&lt;/code&gt; to point to a plain text file with a list of projects (with some additional info).</source>
          <target state="translated">$ projectroot에서 시작하는 파일 시스템을 스캔하여 gitweb이 저장소를 찾도록하는 대신 &lt;code&gt;$projects_list&lt;/code&gt; 를 설정하여 프로젝트 목록이 있는 일반 텍스트 파일을 가리 키도록 (일부 추가 정보 포함) 미리 생성 된 가시적 프로젝트 목록을 제공 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="b8a426e0ceafe99f9ee69973b04f605e2dee7cb4" translate="yes" xml:space="preserve">
          <source>Instead of incrementally packing the unpacked objects, pack everything referenced into a single pack. Especially useful when packing a repository that is used for private development. Use with &lt;code&gt;-d&lt;/code&gt;. This will clean up the objects that &lt;code&gt;git prune&lt;/code&gt; leaves behind, but &lt;code&gt;git fsck --full --dangling&lt;/code&gt; shows as dangling.</source>
          <target state="translated">압축을 푼 개체를 점진적으로 포장하는 대신 참조 된 모든 것을 단일 팩에 포장하십시오. 개인 개발에 사용되는 저장소를 포장 할 때 특히 유용합니다. &lt;code&gt;-d&lt;/code&gt; 와 함께 사용하십시오 . 이것은 &lt;code&gt;git prune&lt;/code&gt; 이 남겨둔 객체를 정리 하지만 &lt;code&gt;git fsck --full --dangling&lt;/code&gt; 은 매달려있는 것으로 표시합니다.</target>
        </trans-unit>
        <trans-unit id="f1ffab5966e331d53c3cb8a3d86f241f936c7bef" translate="yes" xml:space="preserve">
          <source>Instead of initializing the repository as a directory to either &lt;code&gt;$GIT_DIR&lt;/code&gt; or &lt;code&gt;./.git/&lt;/code&gt;, create a text file there containing the path to the actual repository. This file acts as filesystem-agnostic Git symbolic link to the repository.</source>
          <target state="translated">저장소를 &lt;code&gt;$GIT_DIR&lt;/code&gt; &lt;code&gt;./.git/&lt;/code&gt; 또는 ./.git/ 디렉토리로 초기화하는 대신 실제 저장소의 경로를 포함하는 텍스트 파일을 작성하십시오. 이 파일은 저장소에 대한 파일 시스템과 무관 한 Git 심볼릭 링크 역할을합니다.</target>
        </trans-unit>
        <trans-unit id="f0ef88b9adcd939e8a3f3a231e5d0c4737f1545c" translate="yes" xml:space="preserve">
          <source>Instead of leaving conflicts in the file, resolve conflicts favouring our (or their or both) side of the lines.</source>
          <target state="translated">파일에 충돌을 남기지 말고 회선의 (또는 둘 모두) 선호하는 충돌을 해결하십시오.</target>
        </trans-unit>
        <trans-unit id="ca8be3d7e71d110990923e82a424a61c61fcfea3" translate="yes" xml:space="preserve">
          <source>Instead of making a tar archive from the local repository, retrieve a tar archive from a remote repository. Note that the remote repository may place restrictions on which sha1 expressions may be allowed in &lt;code&gt;&amp;lt;tree-ish&amp;gt;&lt;/code&gt;. See &lt;a href=&quot;git-upload-archive&quot;&gt;git-upload-archive[1]&lt;/a&gt; for details.</source>
          <target state="translated">로컬 저장소에서 tar 아카이브를 작성하는 대신 원격 저장소에서 tar 아카이브를 검색하십시오. 원격 저장소는 &lt;code&gt;&amp;lt;tree-ish&amp;gt;&lt;/code&gt; 에서 sha1 표현식이 허용 될 수있는 제한 사항을 둘 수 있습니다 . 자세한 내용은 &lt;a href=&quot;git-upload-archive&quot;&gt;git-upload-archive [1]&lt;/a&gt; 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="7f9313c2b37d59bfbfa07ff3336c61ac5f242846" translate="yes" xml:space="preserve">
          <source>Instead of multiple service names, multiple commands will be supported by a single service</source>
          <target state="translated">여러 서비스 이름 대신 단일 서비스에서 여러 명령이 지원됩니다.</target>
        </trans-unit>
        <trans-unit id="9913e3351ae1177f0328b10cfa41d1a78100d839" translate="yes" xml:space="preserve">
          <source>Instead of naming each ref to push, specifies that all refs under &lt;code&gt;refs/&lt;/code&gt; (which includes but is not limited to &lt;code&gt;refs/heads/&lt;/code&gt;, &lt;code&gt;refs/remotes/&lt;/code&gt;, and &lt;code&gt;refs/tags/&lt;/code&gt;) be mirrored to the remote repository. Newly created local refs will be pushed to the remote end, locally updated refs will be force updated on the remote end, and deleted refs will be removed from the remote end. This is the default if the configuration option &lt;code&gt;remote.&amp;lt;remote&amp;gt;.mirror&lt;/code&gt; is set.</source>
          <target state="translated">각 참조의 이름을 푸시로 지정하는 대신, 참조 &lt;code&gt;refs/&lt;/code&gt; 아래의 모든 참조 (참조 &lt;code&gt;refs/heads/&lt;/code&gt; , 참조 &lt;code&gt;refs/remotes/&lt;/code&gt; 및 참조 &lt;code&gt;refs/tags/&lt;/code&gt; 를 포함하지만 이에 국한되지 않음 )가 원격 저장소에 미러링되도록 지정합니다. 새로 생성 된 로컬 참조는 원격 끝으로 푸시되고 로컬로 업데이트 된 참조는 원격 끝에서 강제로 업데이트되며 삭제 된 참조는 원격 끝에서 제거됩니다. 구성 옵션 &lt;code&gt;remote.&amp;lt;remote&amp;gt;.mirror&lt;/code&gt; 가 설정된 경우 이것이 기본값 입니다.</target>
        </trans-unit>
        <trans-unit id="9634150ab7e71bf3eb3f2b25ec8ede96c11d4e06" translate="yes" xml:space="preserve">
          <source>Instead of naming the commits using the path to reach them from heads (e.g. &quot;master~2&quot; to mean the grandparent of &quot;master&quot;), name them with the unique prefix of their object names.</source>
          <target state="translated">경로를 사용하여 커밋에 이름을 지정하는 대신 (예 : &quot;master&quot;의 조부모를 의미하는 &quot;master ~ 2&quot;) 개체 이름의 고유 접두사로 이름을 지정하십시오.</target>
        </trans-unit>
        <trans-unit id="17b0b1c8040238e6478f5b3afd0b8cbc3b08f080" translate="yes" xml:space="preserve">
          <source>Instead of placing the cloned repository where it is supposed to be, place the cloned repository at the specified directory, then make a filesystem-agnostic Git symbolic link to there. The result is Git repository can be separated from working tree.</source>
          <target state="translated">복제 된 저장소를 원래 위치에 배치하는 대신 지정된 디렉토리에 복제 된 저장소를 배치 한 다음 파일 시스템에 독립적 인 Git 기호 링크를 작성하십시오. 결과적으로 Git 저장소는 작업 트리에서 분리 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="22fb130092ca941fcb14aff3909ae71b595afba3" translate="yes" xml:space="preserve">
          <source>Instead of pointing the newly created HEAD to the branch pointed to by the cloned repository&amp;rsquo;s HEAD, point to &lt;code&gt;&amp;lt;name&amp;gt;&lt;/code&gt; branch instead. In a non-bare repository, this is the branch that will be checked out. &lt;code&gt;--branch&lt;/code&gt; can also take tags and detaches the HEAD at that commit in the resulting repository.</source>
          <target state="translated">새로 작성된 HEAD를 복제 된 저장소의 HEAD가 가리키는 분기를 가리 키지 않고 대신 &lt;code&gt;&amp;lt;name&amp;gt;&lt;/code&gt; 분기를 가리 킵니다 . Bare 이외의 저장소에서는 체크 아웃 할 분기입니다. &lt;code&gt;--branch&lt;/code&gt; 는 결과 저장소의 해당 커밋에서 태그를 가져와 HEAD를 분리 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="33ebce829b735e00e4c7bea8b4f644ee8c315aa6" translate="yes" xml:space="preserve">
          <source>Instead of printing both the SHA-1 and the name, print only the name. If given with --tags the usual tag prefix of &quot;tags/&quot; is also omitted from the name, matching the output of &lt;code&gt;git-describe&lt;/code&gt; more closely.</source>
          <target state="translated">SHA-1과 이름을 모두 인쇄하는 대신 이름 만 인쇄하십시오. --tags를 지정하면 &quot;tags /&quot;의 일반적인 태그 접두어도 이름에서 생략되어 &lt;code&gt;git-describe&lt;/code&gt; 의 출력과 더 밀접하게 일치합니다 .</target>
        </trans-unit>
        <trans-unit id="064cb6e81b93b30bcf346d10dc97336e618d6fae" translate="yes" xml:space="preserve">
          <source>Instead of printing merge bases, print a minimal subset of the supplied commits with the same ancestors. In other words, among the commits given, list those which cannot be reached from any other. This mimics the behavior of &lt;code&gt;git show-branch --independent&lt;/code&gt;.</source>
          <target state="translated">병합베이스를 인쇄하는 대신 제공된 상위 커밋의 최소 서브 세트를 동일한 조상으로 인쇄하십시오. 다시 말해서, 주어진 커밋 중에서 다른 것으로부터 도달 할 수없는 커밋을 나열하십시오. 이것은 &lt;code&gt;git show-branch --independent&lt;/code&gt; 의 동작을 모방합니다 .</target>
        </trans-unit>
        <trans-unit id="a77a1e8325cae4bfdfe406c89eaae3fe4ca07d52" translate="yes" xml:space="preserve">
          <source>Instead of reading a list of objects on stdin, perform the requested batch operation on all objects in the repository and any alternate object stores (not just reachable objects). Requires &lt;code&gt;--batch&lt;/code&gt; or &lt;code&gt;--batch-check&lt;/code&gt; be specified. Note that the objects are visited in order sorted by their hashes.</source>
          <target state="translated">stdin에서 오브젝트 목록을 읽는 대신, 저장소 및 모든 대체 오브젝트 저장소 (연결 가능한 오브젝트뿐만 아니라)의 모든 오브젝트에서 요청 된 일괄 처리 조작을 수행하십시오. 필요 &lt;code&gt;--batch&lt;/code&gt; 또는 &lt;code&gt;--batch-check&lt;/code&gt; 지정. 객체는 해시별로 정렬 된 순서대로 방문합니다.</target>
        </trans-unit>
        <trans-unit id="d4a14000f7e28706a0e6c2e4729bb02543a4d281" translate="yes" xml:space="preserve">
          <source>Instead of reading tree object(s) into the index, just empty it.</source>
          <target state="translated">인덱스로 트리 객체를 읽는 대신 비우십시오.</target>
        </trans-unit>
        <trans-unit id="5828d05fd5c0a35f4392daf67536f9a77ece2b90" translate="yes" xml:space="preserve">
          <source>Instead of running &lt;code&gt;git repack&lt;/code&gt; you can also run &lt;code&gt;git gc
--aggressive&lt;/code&gt;, which will also optimize other things after an import (e.g. pack loose refs). As noted in the &quot;AGGRESSIVE&quot; section in &lt;a href=&quot;git-gc&quot;&gt;git-gc[1]&lt;/a&gt; the &lt;code&gt;--aggressive&lt;/code&gt; option will find new deltas with the &lt;code&gt;-f&lt;/code&gt; option to &lt;a href=&quot;git-repack&quot;&gt;git-repack[1]&lt;/a&gt;. For the reasons elaborated on above using &lt;code&gt;--aggressive&lt;/code&gt; after a fast-import is one of the few cases where it&amp;rsquo;s known to be worthwhile.</source>
          <target state="translated">&lt;code&gt;git repack&lt;/code&gt; 을 실행하는 대신 &lt;code&gt;git gc --aggressive&lt;/code&gt; 실행 하여 가져 오기 후 다른 항목을 최적화 할 수도 있습니다 (예 : 팩 느슨한 참조). 의 &quot;공격성&quot;부분에서 언급 한 바와 같이 &lt;a href=&quot;git-gc&quot;&gt;자식-GC [1] &lt;/a&gt; &lt;code&gt;--aggressive&lt;/code&gt; 옵션은 새로운 델타 찾을 &lt;code&gt;-f&lt;/code&gt; 에 옵션 &lt;a href=&quot;git-repack&quot;&gt;자식 - 재 포장 [1]&lt;/a&gt; . 빠른 가져 오기 후 &lt;code&gt;--aggressive&lt;/code&gt; 를 사용하여 위에서 자세히 설명한 이유 는 가치있는 것으로 알려진 몇 안되는 경우 중 하나입니다.</target>
        </trans-unit>
        <trans-unit id="27d7e1d82cdbf4a022b1041bc3a4b5c02db03622" translate="yes" xml:space="preserve">
          <source>Instead of running one of the known diff tools, &lt;code&gt;git difftool&lt;/code&gt; can be customized to run an alternative program by specifying the command line to invoke in a configuration variable &lt;code&gt;difftool.&amp;lt;tool&amp;gt;.cmd&lt;/code&gt;.</source>
          <target state="translated">알려진 diff 도구 중 하나 를 실행하는 대신 구성 변수 &lt;code&gt;difftool.&amp;lt;tool&amp;gt;.cmd&lt;/code&gt; 에서 호출 할 명령 행을 지정하여 대체 프로그램을 실행하도록 &lt;code&gt;git difftool&lt;/code&gt; 을 사용자 정의 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="0a6ec50c9a1e350ef9a3f4f762c317cd2d6e8233" translate="yes" xml:space="preserve">
          <source>Instead of running one of the known merge tool programs, &lt;code&gt;git mergetool&lt;/code&gt; can be customized to run an alternative program by specifying the command line to invoke in a configuration variable &lt;code&gt;mergetool.&amp;lt;tool&amp;gt;.cmd&lt;/code&gt;.</source>
          <target state="translated">알려진 병합 도구 프로그램 중 하나 를 실행하는 대신 구성 변수 &lt;code&gt;mergetool.&amp;lt;tool&amp;gt;.cmd&lt;/code&gt; 에서 호출 할 명령 행을 지정하여 대체 프로그램을 실행 &lt;code&gt;git mergetool&lt;/code&gt; 을 사용자 정의 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="09dffc4d1650e5ccccc05b0bf19a3e3e59eb7116" translate="yes" xml:space="preserve">
          <source>Instead of searching tracked files in the working tree, search blobs in the given trees.</source>
          <target state="translated">작업 트리에서 추적 된 파일을 검색하는 대신 지정된 트리에서 얼룩을 검색하십시오.</target>
        </trans-unit>
        <trans-unit id="31ae83b44368ffd8feca3b205d3db8ea7d6a3c5c" translate="yes" xml:space="preserve">
          <source>Instead of searching tracked files in the working tree, search blobs registered in the index file.</source>
          <target state="translated">작업 트리에서 추적 된 파일을 검색하는 대신 색인 파일에 등록 된 Blob을 검색하십시오.</target>
        </trans-unit>
        <trans-unit id="55e6c9aa38dceb73a0632da59bc95f69bdfc3cb4" translate="yes" xml:space="preserve">
          <source>Instead of showing every matched line, show only the names of files that contain (or do not contain) matches. For better compatibility with &lt;code&gt;git diff&lt;/code&gt;, &lt;code&gt;--name-only&lt;/code&gt; is a synonym for &lt;code&gt;--files-with-matches&lt;/code&gt;.</source>
          <target state="translated">일치하는 모든 행을 표시하는 대신 일치하는 파일이 있거나 포함되지 않은 파일 이름 만 표시하십시오. 더 나은 호환성을 위해 &lt;code&gt;git diff&lt;/code&gt; , &lt;code&gt;--name-only&lt;/code&gt; 동의어입니다 &lt;code&gt;--files-with-matches&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f1fdcf67f0afaa931922f6239ba4fdd53758ce0d" translate="yes" xml:space="preserve">
          <source>Instead of showing every matched line, show the number of lines that match.</source>
          <target state="translated">일치하는 모든 줄을 표시하는 대신 일치하는 줄 수를 표시하십시오.</target>
        </trans-unit>
        <trans-unit id="9ddb49ffe2885e9ce52c33a63e80e23af2a075a9" translate="yes" xml:space="preserve">
          <source>Instead of showing the commit list, determine possible merge bases for the specified commits. All merge bases will be contained in all specified commits. This is different from how &lt;a href=&quot;git-merge-base&quot;&gt;git-merge-base[1]&lt;/a&gt; handles the case of three or more commits.</source>
          <target state="translated">커밋 목록을 표시하는 대신 지정된 커밋에 대해 가능한 병합 기준을 결정하십시오. 모든 병합 기준은 지정된 모든 커밋에 포함됩니다. 이것은 &lt;a href=&quot;git-merge-base&quot;&gt;git-merge-base [1]&lt;/a&gt; 이 3 개 이상의 커밋을 처리하는 방법과 다릅니다 .</target>
        </trans-unit>
        <trans-unit id="6ba3d7561fe60e77ce239084badd1d1856e50d97" translate="yes" xml:space="preserve">
          <source>Instead of showing the full 40-byte hexadecimal commit object name, show only a partial prefix. Non default number of digits can be specified with &quot;--abbrev=&amp;lt;n&amp;gt;&quot; (which also modifies diff output, if it is displayed).</source>
          <target state="translated">전체 40 바이트 16 진 확약 오브젝트 이름을 표시하는 대신 부분 접 두부 만 표시하십시오. 기본이 아닌 숫자는 &quot;--abbrev = &amp;lt;n&amp;gt;&quot;으로 지정할 수 있습니다 (표시되는 경우 diff 출력도 수정 함).</target>
        </trans-unit>
        <trans-unit id="7d6a3b8755cc865088fd97c8d79f6b68eb4292bc" translate="yes" xml:space="preserve">
          <source>Instead of showing the full 40-byte hexadecimal object lines, show only a partial prefix. Non default number of digits can be specified with --abbrev=&amp;lt;n&amp;gt;.</source>
          <target state="translated">전체 40 바이트 16 진 오브젝트 행을 표시하는 대신 부분 접 두부 만 표시하십시오. 기본 숫자가 아닌 숫자는 --abbrev = &amp;lt;n&amp;gt;으로 지정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="dcd3315e868be633e341c6b1fc6b217d4459f224" translate="yes" xml:space="preserve">
          <source>Instead of showing the full 40-byte hexadecimal object name in diff-raw format output and diff-tree header lines, show only a partial prefix. This is independent of the &lt;code&gt;--full-index&lt;/code&gt; option above, which controls the diff-patch output format. Non default number of digits can be specified with &lt;code&gt;--abbrev=&amp;lt;n&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">diff-raw 형식 출력 및 diff-tree 헤더 행에 전체 40 바이트 16 진 오브젝트 이름을 표시하는 대신 부분 접 두부 만 표시하십시오. 이것은 diff-patch 출력 형식을 제어하는 ​​위 의 &lt;code&gt;--full-index&lt;/code&gt; 옵션 과 독립적입니다 . 기본 숫자가 아닌 숫자는 &lt;code&gt;--abbrev=&amp;lt;n&amp;gt;&lt;/code&gt; 으로 지정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="0ac504d3062e8b5bad74846fd627b7807bedc4f2" translate="yes" xml:space="preserve">
          <source>Instead of showing the path names relative to the current working directory, show the full path names.</source>
          <target state="translated">현재 작업 디렉토리에 상대적인 경로 이름을 표시하는 대신 전체 경로 이름을 표시하십시오.</target>
        </trans-unit>
        <trans-unit id="5f0ed09aafafab46ef0c48e35d2b30851c21ae6a" translate="yes" xml:space="preserve">
          <source>Instead of staging files after each individual change, you can tell &lt;code&gt;git commit&lt;/code&gt; to notice the changes to the files whose contents are tracked in your working tree and do corresponding &lt;code&gt;git add&lt;/code&gt; and &lt;code&gt;git rm&lt;/code&gt; for you. That is, this example does the same as the earlier example if there is no other change in your working tree:</source>
          <target state="translated">각각의 개별 변경 후 파일을 준비하는 대신 &lt;code&gt;git commit&lt;/code&gt; 에게 작업 트리에서 내용이 추적되는 파일의 변경 사항을 확인하고 해당 &lt;code&gt;git add&lt;/code&gt; 및 &lt;code&gt;git rm&lt;/code&gt; 을 수행 하도록 지시 할 수 있습니다. 즉,이 예제는 작업 트리에 다른 변경 사항이없는 경우 이전 예제와 동일합니다.</target>
        </trans-unit>
        <trans-unit id="a675a0b8f5c03b948f0d18f87a17852f45d21abd" translate="yes" xml:space="preserve">
          <source>Instead of stopping at the first failed merge, do all of them in one shot - continue with merging even when previous merges returned errors, and only return the error code after all the merges.</source>
          <target state="translated">첫 번째 실패한 병합에서 중지하는 대신 한 번에 모든 병합을 수행하십시오. 이전 병합에서 리턴 된 오류가 있어도 병합을 계속하고 모든 병합 후에 만 ​​오류 코드를 리턴하십시오.</target>
        </trans-unit>
        <trans-unit id="de32bccd3ddde71a98cffd2de1232e1c99dfd513" translate="yes" xml:space="preserve">
          <source>Instead of submitting create a series of shelved changelists. After creating each shelve, the relevant files are reverted/deleted. If you have multiple commits pending multiple shelves will be created.</source>
          <target state="translated">제출하는 대신 일련의 보류 된 변경 목록을 작성하십시오. 각 선반을 생성 한 후 관련 파일이 복귀 / 삭제됩니다. 보류중인 커밋이 여러 개인 경우 여러 선반이 만들어집니다.</target>
        </trans-unit>
        <trans-unit id="140c71a8b471c44c130e5b1eee8b0237e8238e05" translate="yes" xml:space="preserve">
          <source>Instead of taking list of paths from the command line, read list of paths from the standard input. Paths are separated by LF (i.e. one path per line) by default.</source>
          <target state="translated">명령 행에서 경로 목록을 가져 오는 대신 표준 입력에서 경로 목록을 읽으십시오. 경로는 기본적으로 LF (예 : 한 줄에 하나의 경로)로 구분됩니다.</target>
        </trans-unit>
        <trans-unit id="f4ba2e4e1080efba3c28ca42286f9295fb7a6889" translate="yes" xml:space="preserve">
          <source>Instead of the commit subject, use some other information to describe each commit. &lt;code&gt;&amp;lt;format&amp;gt;&lt;/code&gt; can be any string accepted by the &lt;code&gt;--format&lt;/code&gt; option of &lt;code&gt;git log&lt;/code&gt;, such as &lt;code&gt;* [%h] %s&lt;/code&gt;. (See the &quot;PRETTY FORMATS&quot; section of &lt;a href=&quot;git-log&quot;&gt;git-log[1]&lt;/a&gt;.)</source>
          <target state="translated">커밋 제목 대신 다른 정보를 사용하여 각 커밋을 설명하십시오. &lt;code&gt;&amp;lt;format&amp;gt;&lt;/code&gt; 은 &lt;code&gt;git log&lt;/code&gt; 의 &lt;code&gt;--format&lt;/code&gt; 옵션에 허용되는 모든 문자열 ( 예 : &lt;code&gt;* [%h] %s&lt;/code&gt; 있습니다. ( &lt;a href=&quot;git-log&quot;&gt;git-log [1]&lt;/a&gt; 의 &quot;PRETTY FORMATS&quot;섹션을 참조하십시오 .)</target>
        </trans-unit>
        <trans-unit id="a4e872330a2ee34ffbac6bb806a9bf43b1d76b3c" translate="yes" xml:space="preserve">
          <source>Instead of the content, show the object size identified by &amp;lt;object&amp;gt;.</source>
          <target state="translated">내용 대신 &amp;lt;object&amp;gt;로 식별 된 개체 크기를 표시하십시오.</target>
        </trans-unit>
        <trans-unit id="f066e23ab4bd2d63e94325b4a2a048945fb424e1" translate="yes" xml:space="preserve">
          <source>Instead of the content, show the object type identified by &amp;lt;object&amp;gt;.</source>
          <target state="translated">컨텐츠 대신 &amp;lt;object&amp;gt;로 식별 된 오브젝트 유형을 표시하십시오.</target>
        </trans-unit>
        <trans-unit id="01b660ce7f25b8747605b72657d7e3925704df33" translate="yes" xml:space="preserve">
          <source>Instead of the default &quot;symref&quot; format for HEAD and other symbolic reference files, use symbolic links. This is sometimes needed to work with old scripts that expect HEAD to be a symbolic link.</source>
          <target state="translated">HEAD 및 기타 기호 참조 파일의 기본 &quot;symref&quot;형식 대신 기호 링크를 사용하십시오. HEAD가 심볼릭 링크가 될 것으로 예상되는 오래된 스크립트와 함께 작동하려면 때때로 필요합니다.</target>
        </trans-unit>
        <trans-unit id="f146d5682a8b5a97d10d05b37274aa1ba3a49c07" translate="yes" xml:space="preserve">
          <source>Instead of the default 4 digits with leading zeros, different precision can be specified for the generated filenames.</source>
          <target state="translated">앞에 0이있는 기본 4 자리 대신 생성 된 파일 이름에 대해 다른 정밀도를 지정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e1d28ba0f9256454e559ca46e186461c224089ef" translate="yes" xml:space="preserve">
          <source>Instead of the first handful of characters, show the full pre- and post-image blob object names on the &quot;index&quot; line when generating patch format output.</source>
          <target state="translated">패치 형식 출력을 생성 할 때 첫 소수 문자 대신 &quot;인덱스&quot;행에 전체 사전 및 사후 이미지 Blob 오브젝트 이름을 표시하십시오.</target>
        </trans-unit>
        <trans-unit id="e3b6588aa8ce45f7528fa4adfa5f41dc47858a56" translate="yes" xml:space="preserve">
          <source>Instead of the normal operation, dump the shorthand alias names from the configured alias file(s), one per line in alphabetical order. Note, this only includes the alias name and not its expanded email addresses. See &lt;code&gt;sendemail.aliasesfile&lt;/code&gt; for more information about aliases.</source>
          <target state="translated">정상적인 조작 대신, 구성된 별명 파일에서 축약 별명 이름을 사전 순으로 한 줄에 하나씩 덤프하십시오. 여기에는 확장 된 전자 메일 주소가 아닌 별칭 이름 만 포함됩니다. 별명에 대한 자세한 정보는 &lt;code&gt;sendemail.aliasesfile&lt;/code&gt; 을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="77a59d82290cfd961dc9ff35f15683facfa89709" translate="yes" xml:space="preserve">
          <source>Instead of the standard &lt;code&gt;[PATCH]&lt;/code&gt; prefix in the subject line, instead use &lt;code&gt;[&amp;lt;subject prefix&amp;gt;]&lt;/code&gt;. This allows for useful naming of a patch series, and can be combined with the &lt;code&gt;--numbered&lt;/code&gt; option.</source>
          <target state="translated">제목 줄에 표준 &lt;code&gt;[PATCH]&lt;/code&gt; 접두사 대신 &lt;code&gt;[&amp;lt;subject prefix&amp;gt;]&lt;/code&gt; 를 사용하십시오 . 이를 통해 패치 시리즈의 이름을 유용하게 지정할 수 있으며 &lt;code&gt;--numbered&lt;/code&gt; 옵션 과 함께 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="440b20677cca3bad5d5589368544d09ff6997de8" translate="yes" xml:space="preserve">
          <source>Instead of using &lt;a href=&quot;git-remote&quot;&gt;git-remote[1]&lt;/a&gt;, you can also choose just to update one branch at a time, and to store it locally under an arbitrary name:</source>
          <target state="translated">&lt;a href=&quot;git-remote&quot;&gt;git-remote [1]&lt;/a&gt; 을 사용하는 대신 한 번에 하나의 브랜치를 업데이트하고 임의의 이름으로 로컬로 저장하도록 선택할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="c80da0469d96c6db5cfae1c5b4b2cc65c570bdb0" translate="yes" xml:space="preserve">
          <source>Instead of using &lt;code&gt;.patch&lt;/code&gt; as the suffix for generated filenames, use specified suffix. A common alternative is &lt;code&gt;--suffix=.txt&lt;/code&gt;. Leaving this empty will remove the &lt;code&gt;.patch&lt;/code&gt; suffix.</source>
          <target state="translated">생성 된 파일 이름의 접미사로 &lt;code&gt;.patch&lt;/code&gt; 를 사용하는 대신 지정된 접미사를 사용하십시오. 일반적인 대안은 &lt;code&gt;--suffix=.txt&lt;/code&gt; 입니다. 이 항목을 비워두면 &lt;code&gt;.patch&lt;/code&gt; 접미사 가 제거 됩니다.</target>
        </trans-unit>
        <trans-unit id="f82d2e94f21038afaa9f1d66d3a9a0e365538f7c" translate="yes" xml:space="preserve">
          <source>Instead of using only the annotated tags, use any ref found in &lt;code&gt;refs/&lt;/code&gt; namespace. This option enables matching any known branch, remote-tracking branch, or lightweight tag.</source>
          <target state="translated">주석이 달린 태그 만 사용하는 대신 &lt;code&gt;refs/&lt;/code&gt; 네임 스페이스 에있는 ref를 사용하십시오 . 이 옵션을 사용하면 알려진 지점, 원격 추적 지점 또는 경량 태그를 일치시킬 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1177311a3949b6b80d45daef7bf2616b79441b65" translate="yes" xml:space="preserve">
          <source>Instead of using only the annotated tags, use any tag found in &lt;code&gt;refs/tags&lt;/code&gt; namespace. This option enables matching a lightweight (non-annotated) tag.</source>
          <target state="translated">주석이 달린 태그 만 사용하는 대신 &lt;code&gt;refs/tags&lt;/code&gt; 네임 스페이스 에있는 태그를 사용하십시오 . 이 옵션을 사용하면 주석이 달린 가벼운 태그를 일치시킬 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="fa50874379be0d623d79d8af182cc42f83a49b1c" translate="yes" xml:space="preserve">
          <source>Instead of using the default 7 hexadecimal digits as the abbreviated object name, use &amp;lt;n&amp;gt; digits, or as many digits as needed to form a unique object name. An &amp;lt;n&amp;gt; of 0 will suppress long format, only showing the closest tag.</source>
          <target state="translated">기본 7 자리 16 진수를 축약 된 오브젝트 이름으로 사용하는 대신 &amp;lt;n&amp;gt; 숫자 또는 고유 오브젝트 이름을 형성하는 데 필요한만큼의 숫자를 사용하십시오. &amp;lt;n&amp;gt;이 0이면 긴 형식이 억제되고 가장 가까운 태그 만 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="183487409af3884cbc9c819c550a69752622875c" translate="yes" xml:space="preserve">
          <source>Instead of using the default 7+1 hexadecimal digits as the abbreviated object name, use &amp;lt;n&amp;gt;+1 digits. Note that 1 column is used for a caret to mark the boundary commit.</source>
          <target state="translated">기본 7 + 1 16 진 숫자를 축약 된 오브젝트 이름으로 사용하는 대신 &amp;lt;n&amp;gt; +1 숫자를 사용하십시오. 캐럿이 경계 커밋을 표시하는 데 1 개의 열이 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="ee5547b5d72f6d52e84d0986cad360b6f68e956a" translate="yes" xml:space="preserve">
          <source>Instead of using the remote name &lt;code&gt;origin&lt;/code&gt; to keep track of the upstream repository, use &lt;code&gt;&amp;lt;name&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">업스트림 저장소를 추적하기 위해 원격 이름 &lt;code&gt;origin&lt;/code&gt; 을 사용하는 대신 &lt;code&gt;&amp;lt;name&amp;gt;&lt;/code&gt; 을 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="acaf18a5ec5cac3fd2f3b3d56ba27133d9e16abf" translate="yes" xml:space="preserve">
          <source>Instead of using the tip of the current branch, compare with the tip of &quot;test&quot; branch.</source>
          <target state="translated">현재 분기의 팁을 사용하는 대신 &quot;테스트&quot;분기의 팁과 비교하십시오.</target>
        </trans-unit>
        <trans-unit id="0e0bb2a4d944b8f5531055e279607820e676a94b" translate="yes" xml:space="preserve">
          <source>Instead of walking the commit ancestry chain, walk reflog entries from the most recent one to older ones. When this option is used you cannot specify commits to exclude (that is, &lt;code&gt;^commit&lt;/code&gt;, &lt;code&gt;commit1..commit2&lt;/code&gt;, and &lt;code&gt;commit1...commit2&lt;/code&gt; notations cannot be used).</source>
          <target state="translated">커밋 조상 체인을 걷는 대신, 가장 최근의 것부터 오래된 것까지 reflog 항목을 걷습니다. 이 옵션을 사용하면 제외 할 커밋을 지정할 수 없습니다 (즉, &lt;code&gt;^commit&lt;/code&gt; , &lt;code&gt;commit1..commit2&lt;/code&gt; 및 &lt;code&gt;commit1...commit2&lt;/code&gt; 표기법을 사용할 수 없음).</target>
        </trans-unit>
        <trans-unit id="00c411b0a21221afdc6e21c624bf253d7212e3a9" translate="yes" xml:space="preserve">
          <source>Instead of writing the results out to &lt;code&gt;$GIT_INDEX_FILE&lt;/code&gt;, write the resulting index in the named file. While the command is operating, the original index file is locked with the same mechanism as usual. The file must allow to be rename(2)ed into from a temporary file that is created next to the usual index file; typically this means it needs to be on the same filesystem as the index file itself, and you need write permission to the directories the index file and index output file are located in.</source>
          <target state="translated">결과를 &lt;code&gt;$GIT_INDEX_FILE&lt;/code&gt; 에 기록하는 대신 결과 색인을 명명 된 파일에 기록하십시오. 명령이 작동하는 동안 원래 색인 파일은 평소와 동일한 메커니즘으로 잠 깁니다. 파일은 일반적인 색인 파일 옆에 작성된 임시 파일에서 이름을 바꿀 수 있어야합니다 (2). 일반적으로 이는 색인 파일 자체와 동일한 파일 시스템에 있어야하며 색인 파일 및 색인 출력 파일이있는 디렉토리에 대한 쓰기 권한이 필요합니다.</target>
        </trans-unit>
        <trans-unit id="ef06396aed739ff032fb1ddeda938ad4cf5e4280" translate="yes" xml:space="preserve">
          <source>Instruct Git to avoid trying to guess defaults for &lt;code&gt;user.email&lt;/code&gt; and &lt;code&gt;user.name&lt;/code&gt;, and instead retrieve the values only from the configuration. For example, if you have multiple email addresses and would like to use a different one for each repository, then with this configuration option set to &lt;code&gt;true&lt;/code&gt; in the global config along with a name, Git will prompt you to set up an email before making new commits in a newly cloned repository. Defaults to &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">Git에게 &lt;code&gt;user.email&lt;/code&gt; 및 &lt;code&gt;user.name&lt;/code&gt; 의 기본값을 추측 하지 말고 대신 구성에서만 값을 검색하도록 지시 하십시오. 예를 들어 이메일 주소가 여러 개이고 각 저장소마다 다른 주소를 사용하려는 경우 전역 구성에서 이름 과 함께이 구성 옵션을 &lt;code&gt;true&lt;/code&gt; 로 설정하면 Git에서 새로 만들기 전에 이메일을 설정하라는 메시지를 표시합니다 새로 복제 된 저장소에서 커밋합니다. 기본값은 &lt;code&gt;false&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="a592acd9f11ad3bff77a1878bfa756913e7df3fe" translate="yes" xml:space="preserve">
          <source>Instruction to add new data</source>
          <target state="translated">새로운 데이터를 추가하는 방법</target>
        </trans-unit>
        <trans-unit id="c222c271406b6a5c2fcfc84ba72b7981aee6b09e" translate="yes" xml:space="preserve">
          <source>Instruction to copy from base object</source>
          <target state="translated">기본 객체에서 복사하는 방법</target>
        </trans-unit>
        <trans-unit id="6131d2bc98a67fbf2df419d53c2a5951a56eb747" translate="yes" xml:space="preserve">
          <source>Instructs the remote helper that any subsequent input is part of a fast-import stream (generated by &lt;code&gt;git fast-export&lt;/code&gt;) containing objects which should be pushed to the remote.</source>
          <target state="translated">후속 입력이 원격으로 푸시되어야하는 오브젝트를 포함하는 &lt;code&gt;git fast-export&lt;/code&gt; 가져 오기 스트림 ( git fast-export에 의해 생성됨)의 일부임을 원격 헬퍼에게 지시합니다 .</target>
        </trans-unit>
        <trans-unit id="563eacc97631ea8eeadfe6b54ffbd63455326490" translate="yes" xml:space="preserve">
          <source>Integer. Specifies desired depth of nested regions in the event output. Regions deeper than this value will be omitted. May be overridden by the &lt;code&gt;GIT_TRACE2_EVENT_NESTING&lt;/code&gt; environment variable. Defaults to 2.</source>
          <target state="translated">정수. 이벤트 출력에서 ​​원하는 중첩 영역의 깊이를 지정합니다. 이 값보다 깊은 영역은 생략됩니다. &lt;code&gt;GIT_TRACE2_EVENT_NESTING&lt;/code&gt; 환경 변수 로 대체 될 수 있습니다 . 기본값은 2입니다.</target>
        </trans-unit>
        <trans-unit id="f3e0144605c9578fc597fd7ff39de75aab2afefe" translate="yes" xml:space="preserve">
          <source>Integer. When writing trace files to a target directory, do not write additional traces if we would exceed this many files. Instead, write a sentinel file that will block further tracing to this directory. Defaults to 0, which disables this check.</source>
          <target state="translated">정수. 대상 파일에 추적 파일을 쓸 때이 파일을 초과 할 경우 추가 추적을 쓰지 마십시오. 대신이 디렉토리에 대한 추가 추적을 차단할 센티넬 파일을 작성하십시오. 기본값은 0이며,이 검사는 비활성화됩니다.</target>
        </trans-unit>
        <trans-unit id="a6768cae9c51930f13c302375f3385c6c77b2104" translate="yes" xml:space="preserve">
          <source>Integrator</source>
          <target state="translated">Integrator</target>
        </trans-unit>
        <trans-unit id="e30f6e398ba3d7dd3d6ee2f7d0d8940d3116f2a5" translate="yes" xml:space="preserve">
          <source>Interacting with Others</source>
          <target state="translated">다른 사람들과 교류</target>
        </trans-unit>
        <trans-unit id="e9854d76872b55831675241f09e80f37f1939cea" translate="yes" xml:space="preserve">
          <source>Interaction between checkin/checkout attributes</source>
          <target state="translated">체크인 / 체크 아웃 속성 간의 상호 작용</target>
        </trans-unit>
        <trans-unit id="0d798c0b1cd4a6d135dc1e4671cde5f33dab863b" translate="yes" xml:space="preserve">
          <source>Interactive mode</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fb0ea93fbb85b738df0bd31fcf1bc9eb5468d22b" translate="yes" xml:space="preserve">
          <source>Interactive use</source>
          <target state="translated">대화식 사용</target>
        </trans-unit>
        <trans-unit id="94db97a8381d05a800daa18ce0818d37326de61f" translate="yes" xml:space="preserve">
          <source>Interactively choose hunks of patch between the index and the work tree and add them to the index. This gives the user a chance to review the difference before adding modified contents to the index.</source>
          <target state="translated">색인과 작업 트리 사이에서 대화식으로 패치 덩어리를 선택하여 색인에 추가하십시오. 이를 통해 사용자는 수정 된 내용을 색인에 추가하기 전에 차이점을 검토 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="942e3b50f8575a931a7b62b4970978b40b59bcee" translate="yes" xml:space="preserve">
          <source>Interactively select hunks in the difference between the &lt;code&gt;&amp;lt;tree-ish&amp;gt;&lt;/code&gt; (or the index, if unspecified) and the working tree. The chosen hunks are then applied in reverse to the working tree (and if a &lt;code&gt;&amp;lt;tree-ish&amp;gt;&lt;/code&gt; was specified, the index).</source>
          <target state="translated">&lt;code&gt;&amp;lt;tree-ish&amp;gt;&lt;/code&gt; (또는 지정되지 않은 경우 인덱스)와 작업 트리 의 차이에서 대화식으로 덩어리를 선택 합니다. 선택한 덩어리는 작업 트리와 반대로 적용됩니다 ( &lt;code&gt;&amp;lt;tree-ish&amp;gt;&lt;/code&gt; 가 지정된 경우 인덱스).</target>
        </trans-unit>
        <trans-unit id="6b61a0bfaba36c21326a6cc1d8076250bbb8f781" translate="yes" xml:space="preserve">
          <source>Interactively select hunks in the difference between the index and &lt;code&gt;&amp;lt;tree-ish&amp;gt;&lt;/code&gt; (defaults to &lt;code&gt;HEAD&lt;/code&gt;). The chosen hunks are applied in reverse to the index.</source>
          <target state="translated">인덱스와 &lt;code&gt;&amp;lt;tree-ish&amp;gt;&lt;/code&gt; 의 차이에서 대화식으로 덩어리를 선택합니다 (기본값은 &lt;code&gt;HEAD&lt;/code&gt; ). 선택한 덩어리는 색인과 반대로 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="11c4e8d4b31fcec1faa8b21ab916ae6d7ecd6196" translate="yes" xml:space="preserve">
          <source>Interactively select hunks in the difference between the restore source and the restore location. See the &amp;ldquo;Interactive Mode&amp;rdquo; section of &lt;a href=&quot;git-add&quot;&gt;git-add[1]&lt;/a&gt; to learn how to operate the &lt;code&gt;--patch&lt;/code&gt; mode.</source>
          <target state="translated">복원 소스와 복원 위치의 차이에서 대화식으로 덩어리를 선택하십시오. &lt;code&gt;--patch&lt;/code&gt; 모드 작동 방법을 알아 보려면 &lt;a href=&quot;git-add&quot;&gt;git-add [1]&lt;/a&gt; 의 &quot;대화식 모드&quot;섹션을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="37d460e42c18dd6a2f67dd6cfcf736b2dc4e3735" translate="yes" xml:space="preserve">
          <source>Internal detail of implementation. What is important is that if this field is not present then per-repository override for given feature is not supported.</source>
          <target state="translated">구현의 내부 세부 사항. 중요한 것은이 필드가 존재하지 않으면 주어진 기능에 대한 저장소 별 재정의가 지원되지 않는다는 것입니다.</target>
        </trans-unit>
        <trans-unit id="fcd742802f00593c0aa9a5d67d6ee0045ea54dd6" translate="yes" xml:space="preserve">
          <source>Internal helper commands</source>
          <target state="translated">내부 도우미 명령</target>
        </trans-unit>
        <trans-unit id="99089329f972015329c6ab2c5f20f49ab1b0fb2e" translate="yes" xml:space="preserve">
          <source>Internal variable identifying the repository format and layout version.</source>
          <target state="translated">저장소 형식 및 레이아웃 버전을 식별하는 내부 변수입니다.</target>
        </trans-unit>
        <trans-unit id="d2a9fe262eee692f1042088fcd5412df8b02ed0e" translate="yes" xml:space="preserve">
          <source>Internal variable which enables various workarounds to enable Git to work better on filesystems that are not case sensitive, like APFS, HFS+, FAT, NTFS, etc. For example, if a directory listing finds &quot;makefile&quot; when Git expects &quot;Makefile&quot;, Git will assume it is really the same file, and continue to remember it as &quot;Makefile&quot;.</source>
          <target state="translated">APFS, HFS +, FAT, NTFS 등과 같이 대소 문자를 구분하지 않는 파일 시스템에서 Git이 더 잘 작동 할 수 있도록하는 다양한 해결 방법을 제공하는 내부 변수입니다. 파일이 실제로 같은 파일이라고 가정하고 &quot;Makefile&quot;로 계속 기억합니다.</target>
        </trans-unit>
        <trans-unit id="fd5dd045ecadbef7edb9976d5bf76d5e7548b5a7" translate="yes" xml:space="preserve">
          <source>Interpret &amp;lt;refname&amp;gt; as a reference name pattern for a refspec (as used with remote repositories). If this option is enabled, &amp;lt;refname&amp;gt; is allowed to contain a single &lt;code&gt;*&lt;/code&gt; in the refspec (e.g., &lt;code&gt;foo/bar*/baz&lt;/code&gt; or &lt;code&gt;foo/bar*baz/&lt;/code&gt; but not &lt;code&gt;foo/bar*/baz*&lt;/code&gt;).</source>
          <target state="translated">&amp;lt;refname&amp;gt;을 참조 스펙에 대한 참조 이름 패턴으로 해석하십시오 (원격 저장소와 함께 사용됨). 이 옵션을 활성화하면 &amp;lt;refname&amp;gt;은 참조 스펙에 단일 &lt;code&gt;*&lt;/code&gt; 를 포함 할 수 있습니다 (예 : &lt;code&gt;foo/bar*/baz&lt;/code&gt; 또는 &lt;code&gt;foo/bar*baz/&lt;/code&gt; 이지만 &lt;code&gt;foo/bar*/baz*&lt;/code&gt; 아님).</target>
        </trans-unit>
        <trans-unit id="670ef7722a61e3342fef6602c3dc04b50457ccb3" translate="yes" xml:space="preserve">
          <source>Interpret all preceding arguments as attributes and all following arguments as path names.</source>
          <target state="translated">앞의 모든 인수를 속성으로 해석하고 다음의 모든 인수를 경로 이름으로 해석하십시오.</target>
        </trans-unit>
        <trans-unit id="c75cadb4ae816991e0dd6b40f2cda63b6ea63eb7" translate="yes" xml:space="preserve">
          <source>Interrogation commands</source>
          <target state="translated">심문 명령</target>
        </trans-unit>
        <trans-unit id="f1e6fa1e2ddb5fcd808e3092148f74242800360f" translate="yes" xml:space="preserve">
          <source>Interrogators:</source>
          <target state="translated">Interrogators:</target>
        </trans-unit>
        <trans-unit id="8b0b6bf2544da29702a138cd7dd487472490ccff" translate="yes" xml:space="preserve">
          <source>Interrupt transfer after &amp;lt;n&amp;gt; seconds of inactivity.</source>
          <target state="translated">&amp;lt;n&amp;gt; 초 동안 활동이 없으면 인터럽트 전송.</target>
        </trans-unit>
        <trans-unit id="9f1df172d790d81927bf10eb32b7a53862fd94a5" translate="yes" xml:space="preserve">
          <source>Interrupted workflow</source>
          <target state="translated">중단 된 워크 플로우</target>
        </trans-unit>
        <trans-unit id="b566252f7afe805214a7771e6b2a586b4e458c82" translate="yes" xml:space="preserve">
          <source>Introduction to &quot;git bisect&quot;</source>
          <target state="translated">&quot;git bisect&quot;소개</target>
        </trans-unit>
        <trans-unit id="273a20c96a580af6e0e1fc6c4491680cd6e13de6" translate="yes" xml:space="preserve">
          <source>Intuitiveness is not the goal here. Repeatability is. The reason for the &quot;no arguments means no work&quot; behavior is that from scripts you are supposed to be able to do:</source>
          <target state="translated">직관적 인 목표는 여기에 없습니다. 반복성은 &quot;인수 없음&quot;은 작동하지 않는 동작의 이유는 스크립트에서 수행 할 수 있어야하기 때문입니다.</target>
        </trans-unit>
        <trans-unit id="6a9b44369c96eafd66d755034e5ce80488ad8832" translate="yes" xml:space="preserve">
          <source>Invocation</source>
          <target state="translated">Invocation</target>
        </trans-unit>
        <trans-unit id="1d5f124f7b2f261867ec41e2c056658bb6e88c34" translate="yes" xml:space="preserve">
          <source>Invoke a text editor (see GIT_EDITOR in &lt;a href=&quot;git-var&quot;&gt;git-var[1]&lt;/a&gt;) to edit an introductory message for the patch series.</source>
          <target state="translated">텍스트 편집기 ( &lt;a href=&quot;git-var&quot;&gt;git-var [1]의&lt;/a&gt; GIT_EDITOR 참조)를 호출 하여 패치 시리즈에 대한 소개 메시지를 편집하십시오.</target>
        </trans-unit>
        <trans-unit id="9ba2ef7b89376be98d487b046c212677da3221b4" translate="yes" xml:space="preserve">
          <source>Invoke an editor before committing successful mechanical merge to further edit the auto-generated merge message, so that the user can explain and justify the merge. The &lt;code&gt;--no-edit&lt;/code&gt; option can be used to accept the auto-generated message (this is generally discouraged).</source>
          <target state="translated">성공적인 자동 병합을 커미트하기 전에 편집기를 호출하여 자동 생성 된 병합 메시지를 추가로 편집하여 사용자가 병합을 설명하고 정당화 할 수 있습니다. &lt;code&gt;--no-edit&lt;/code&gt; 옵션 (이것은 일반적으로 권장하지 않습니다) 자동 생성 된 메시지를 수락 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a978683542367bbc42f0a41dd9d11a4a00c553d9" translate="yes" xml:space="preserve">
          <source>Invoke an editor before committing successful mechanical merge to further edit the auto-generated merge message, so that the user can explain and justify the merge. The &lt;code&gt;--no-edit&lt;/code&gt; option can be used to accept the auto-generated message (this is generally discouraged). The &lt;code&gt;--edit&lt;/code&gt; (or &lt;code&gt;-e&lt;/code&gt;) option is still useful if you are giving a draft message with the &lt;code&gt;-m&lt;/code&gt; option from the command line and want to edit it in the editor.</source>
          <target state="translated">성공적인 자동 병합을 커미트하기 전에 편집기를 호출하여 자동 생성 된 병합 메시지를 추가로 편집하여 사용자가 병합을 설명하고 정당화 할 수 있습니다. &lt;code&gt;--no-edit&lt;/code&gt; 옵션 (이것은 일반적으로 권장하지 않습니다) 자동 생성 된 메시지를 수락 할 수 있습니다. &lt;code&gt;--edit&lt;/code&gt; (또는 &lt;code&gt;-e&lt;/code&gt; 당신이 가진 초안 메시지를주는 경우) 옵션은 여전히 유용 &lt;code&gt;-m&lt;/code&gt; 명령 행에서 옵션을하고 편집기에서 편집을하고 싶습니다.</target>
        </trans-unit>
        <trans-unit id="ab51558f752b86c08b9c277e1cd35bd4f5da28bc" translate="yes" xml:space="preserve">
          <source>Invoke the sendemail-validate hook if present (see &lt;a href=&quot;githooks&quot;&gt;githooks[5]&lt;/a&gt;).</source>
          <target state="translated">있는 경우 sendemail-validate 후크를 호출하십시오 ( &lt;a href=&quot;githooks&quot;&gt;githooks [5]&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="6307458f7efb25e5d4237ad7a4e972e464f2ab54" translate="yes" xml:space="preserve">
          <source>Invoked by &lt;code&gt;git archive --remote&lt;/code&gt; and sends a generated archive to the other end over the Git protocol.</source>
          <target state="translated">&lt;code&gt;git archive --remote&lt;/code&gt; 에 의해 호출되며 생성 된 아카이브를 Git 프로토콜을 통해 다른 쪽 끝으로 보냅니다.</target>
        </trans-unit>
        <trans-unit id="4591feb10dd06f62e310d9c287cf3f981ce9babf" translate="yes" xml:space="preserve">
          <source>Invoked by &lt;code&gt;git fetch-pack&lt;/code&gt;, learns what objects the other side is missing, and sends them after packing.</source>
          <target state="translated">&lt;code&gt;git fetch-pack&lt;/code&gt; 에 의해 호출되어 다른 쪽에서 누락 된 객체를 파악하고 패킹 후 보냅니다.</target>
        </trans-unit>
        <trans-unit id="a7f91dd525c007f2b681e8a032a0618f9a34ea1c" translate="yes" xml:space="preserve">
          <source>Invoked by &lt;code&gt;git send-pack&lt;/code&gt; and updates the repository with the information fed from the remote end.</source>
          <target state="translated">&lt;code&gt;git send-pack&lt;/code&gt; 에 의해 호출되며 원격 엔드에서 제공된 정보로 저장소를 업데이트합니다.</target>
        </trans-unit>
        <trans-unit id="d65563f7b9f547034dceec39b8ac04f9c683c150" translate="yes" xml:space="preserve">
          <source>Invokes &lt;code&gt;git-receive-pack&lt;/code&gt; on a possibly remote repository, and updates it from the current repository, sending named refs.</source>
          <target state="translated">원격 저장소에서 &lt;code&gt;git-receive-pack&lt;/code&gt; 을 호출 하고 이름이 지정된 ref를 전송하여 현재 저장소에서 업데이트합니다.</target>
        </trans-unit>
        <trans-unit id="b53ca0a7337f2511de77389036559a87c502bc3d" translate="yes" xml:space="preserve">
          <source>Invokes &lt;code&gt;git-upload-pack&lt;/code&gt; on a possibly remote repository and asks it to send objects missing from this repository, to update the named heads. The list of commits available locally is found out by scanning the local refs/ hierarchy and sent to &lt;code&gt;git-upload-pack&lt;/code&gt; running on the other end.</source>
          <target state="translated">원격 저장소에서 &lt;code&gt;git-upload-pack&lt;/code&gt; 을 호출 하고이 저장소에서 누락 된 객체를 보내 이름 지정된 헤드를 업데이트하도록 요청합니다. 로컬 사용 가능한 커밋 목록은 로컬 refs / 계층 구조를 스캔하여 찾아서 다른 쪽 끝에서 실행되는 &lt;code&gt;git-upload-pack&lt;/code&gt; 으로 보냅니다 .</target>
        </trans-unit>
        <trans-unit id="a31ffeaabebc608f725ad5aea0019f330d8c2ea7" translate="yes" xml:space="preserve">
          <source>Invoking &lt;code&gt;git add -e&lt;/code&gt; or selecting &lt;code&gt;e&lt;/code&gt; from the interactive hunk selector will open a patch in your editor; after the editor exits, the result is applied to the index. You are free to make arbitrary changes to the patch, but note that some changes may have confusing results, or even result in a patch that cannot be applied. If you want to abort the operation entirely (i.e., stage nothing new in the index), simply delete all lines of the patch. The list below describes some common things you may see in a patch, and which editing operations make sense on them.</source>
          <target state="translated">&lt;code&gt;git add -e&lt;/code&gt; 를 호출 하거나 대화식 덩어리 선택기에서 &lt;code&gt;e&lt;/code&gt; 를 선택하면 편집기에서 패치가 열립니다. 편집기가 종료되면 결과가 색인에 적용됩니다. 패치를 임의로 변경할 수는 있지만 일부 변경 사항이 혼란스러워 지거나 적용 할 수없는 패치가 발생할 수 있습니다. 작업을 완전히 중단하려면 (즉, 인덱스에서 새로운 것을 스테이징하지 않으려면) 패치의 모든 줄을 삭제하십시오. 아래 목록은 패치에서 볼 수있는 몇 가지 일반적인 사항과 그에 적합한 편집 작업에 대해 설명합니다.</target>
        </trans-unit>
        <trans-unit id="7eda501750cd6c5e49ea1b4fd74542b592feab87" translate="yes" xml:space="preserve">
          <source>Involving QA people and if possible end users</source>
          <target state="translated">품질 보증 담당자 및 가능한 경우 최종 사용자</target>
        </trans-unit>
        <trans-unit id="4ddb9cd693a2e162ef85f6fbfe4abc845111ebb9" translate="yes" xml:space="preserve">
          <source>Is a synonym for &lt;code&gt;zebra&lt;/code&gt;. This may change to a more sensible mode in the future.</source>
          <target state="translated">&lt;code&gt;zebra&lt;/code&gt; 의 동의어입니다 . 앞으로 더 합리적인 모드로 변경 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4f13daaae3d7fc7ba5d15c4ccfc54188d83d267e" translate="yes" xml:space="preserve">
          <source>Is used as suggested name when creating new branches using the &lt;a href=&quot;git-gui&quot;&gt;git-gui[1]&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;git-gui&quot;&gt;git-gui [1]을&lt;/a&gt; 사용하여 새 분기를 만들 때 제안 된 이름으로 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="6f3229278b909458bc76fcc500cf44677191a296" translate="yes" xml:space="preserve">
          <source>Islands are configured via the &lt;code&gt;pack.island&lt;/code&gt; option, which can be specified multiple times. Each value is a left-anchored regular expressions matching refnames. For example:</source>
          <target state="translated">아일랜드는 &lt;code&gt;pack.island&lt;/code&gt; 옵션을 통해 구성되며 여러 번 지정할 수 있습니다. 각 값은 참조 이름과 일치하는 왼쪽 고정식입니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="30ce4cb25faae86427d8ac22e8f50a0a74f3f393" translate="yes" xml:space="preserve">
          <source>Issues</source>
          <target state="translated">Issues</target>
        </trans-unit>
        <trans-unit id="0120e142d77ed0c1102a3548e5e6ca12ae1c469b" translate="yes" xml:space="preserve">
          <source>Issues which are security relevant should be disclosed privately to the Git Security mailing list &amp;lt;&lt;a href=&quot;mailto:git-security@googlegroups.com&quot;&gt;git-security@googlegroups.com&lt;/a&gt;&amp;gt;.</source>
          <target state="translated">보안 관련 문제는 Git 보안 메일 링리스트 &amp;lt; &lt;a href=&quot;mailto:git-security@googlegroups.com&quot;&gt;git-security@googlegroups.com&lt;/a&gt; &amp;gt;에 비공개로 공개해야합니다 .</target>
        </trans-unit>
        <trans-unit id="7e6ca0d89968d14a4a145a03ebcf512ab164b2cf" translate="yes" xml:space="preserve">
          <source>Issuing a &lt;code&gt;filedeleteall&lt;/code&gt; followed by the needed &lt;code&gt;filemodify&lt;/code&gt; commands to set the correct content will produce the same results as sending only the needed &lt;code&gt;filemodify&lt;/code&gt; and &lt;code&gt;filedelete&lt;/code&gt; commands. The &lt;code&gt;filedeleteall&lt;/code&gt; approach may however require fast-import to use slightly more memory per active branch (less than 1 MiB for even most large projects); so frontends that can easily obtain only the affected paths for a commit are encouraged to do so.</source>
          <target state="translated">올바른 컨텐츠를 설정 하기 위해 &lt;code&gt;filedeleteall&lt;/code&gt; 다음에 필요한 &lt;code&gt;filemodify&lt;/code&gt; 명령을 발행 하면 필요한 &lt;code&gt;filemodify&lt;/code&gt; 및 &lt;code&gt;filedelete&lt;/code&gt; 명령 만 보내는 것과 동일한 결과가 생성됩니다 . 그러나 &lt;code&gt;filedeleteall&lt;/code&gt; 접근 방식은 활성 브랜치 당 약간 더 많은 메모리를 사용하기 위해 빠른 가져 오기가 필요할 수 있습니다 (대규모 프로젝트의 경우 1MiB 미만). 따라서 커밋에 영향을받는 경로 만 쉽게 얻을 수있는 프런트 엔드가 권장됩니다.</target>
        </trans-unit>
        <trans-unit id="bdf45bc4332be1bec5eceb55b9547e5441cbefc8" translate="yes" xml:space="preserve">
          <source>It adds the submodule&amp;rsquo;s clone path to the &lt;a href=&quot;gitmodules&quot;&gt;gitmodules[5]&lt;/a&gt; file and adds this file to the index, ready to be committed.</source>
          <target state="translated">서브 모듈의 클론 경로를 &lt;a href=&quot;gitmodules&quot;&gt;gitmodules [5]&lt;/a&gt; 파일에 추가하고이 파일을 인덱스에 추가하여 커밋 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8c81521fe76c33a9e0c12152a7126a3168cdc6bc" translate="yes" xml:space="preserve">
          <source>It adds the submodule&amp;rsquo;s current commit ID to the index, ready to be committed.</source>
          <target state="translated">서브 모듈의 현재 커밋 ID를 인덱스에 추가하여 커밋 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d31bfc2387ea73611500553c1004cb0667d4f160" translate="yes" xml:space="preserve">
          <source>It affects the way a change that amounts to a total rewrite of a file not as a series of deletion and insertion mixed together with a very few lines that happen to match textually as the context, but as a single deletion of everything old followed by a single insertion of everything new, and the number &lt;code&gt;m&lt;/code&gt; controls this aspect of the -B option (defaults to 60%). &lt;code&gt;-B/70%&lt;/code&gt; specifies that less than 30% of the original should remain in the result for Git to consider it a total rewrite (i.e. otherwise the resulting patch will be a series of deletion and insertion mixed together with context lines).</source>
          <target state="translated">그것은 일련의 삭제 및 삽입이 아니라 텍스트와 문맥 상 텍스트로 일치하는 아주 적은 행과 함께 파일을 완전히 다시 작성하는 변경에 영향을 미칩니다. 새로운 모든 것을 한 번만 삽입하면 숫자 &lt;code&gt;m&lt;/code&gt; 은 -B 옵션의이 측면을 제어합니다 (기본값은 60 %). &lt;code&gt;-B/70%&lt;/code&gt; 는 Git이 원본을 30 % 미만으로 유지하여 결과를 총 재 작성으로 간주하도록 지정합니다 (그렇지 않으면 결과 패치는 컨텍스트 라인과 함께 일련의 삭제 및 삽입이됩니다).</target>
        </trans-unit>
        <trans-unit id="3769038328418f1b146bfedf460a0d4ea1eab91b" translate="yes" xml:space="preserve">
          <source>It also allows a &quot;ref&quot; file to be a symbolic pointer to another ref file by starting with the four-byte header sequence of &quot;ref:&quot;.</source>
          <target state="translated">또한 &quot;ref :&quot;의 4 바이트 헤더 시퀀스로 시작하여 &quot;ref&quot;파일이 다른 ref 파일에 대한 기호 포인터가되도록합니다.</target>
        </trans-unit>
        <trans-unit id="c1a8e562ae70e23b9286b736cb60f8fd411f796d" translate="yes" xml:space="preserve">
          <source>It can also be useful in scripts passed to &quot;git bisect run&quot; to &quot;exit 255&quot; if some very abnormal situation is detected.</source>
          <target state="translated">매우 비정상적인 상황이 감지되면 &quot;git bisect run&quot;으로 전달 된 스크립트에서 &quot;255를 종료&quot;하는 데 유용 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="79b5b9aab5919bae0a6145dab082f1d19cd80f67" translate="yes" xml:space="preserve">
          <source>It can be cumbersome to input the same credentials over and over. Git provides two methods to reduce this annoyance:</source>
          <target state="translated">동일한 자격 증명을 반복해서 입력하는 것은 번거로울 수 있습니다. 힘내는이 성가심을 줄이기 위해 두 가지 방법을 제공합니다 :</target>
        </trans-unit>
        <trans-unit id="4e1aaed29365e5e25e94340f3a0f563a3458fb95" translate="yes" xml:space="preserve">
          <source>It can be used to inspect the current working tree and refuse to make a commit if it does not pass certain test.</source>
          <target state="translated">현재 작업 트리를 검사하고 특정 테스트를 통과하지 못하면 커밋을 거부하는 데 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="15367977bf1bc97e62677f2311accebdf50497b6" translate="yes" xml:space="preserve">
          <source>It can efficiently represent information about merge conflicts between different tree objects, allowing each pathname to be associated with sufficient information about the trees involved that you can create a three-way merge between them.</source>
          <target state="translated">서로 다른 트리 개체 간의 병합 충돌에 대한 정보를 효율적으로 나타낼 수 있으므로 각 경로 이름을 트리 간 병합을 만들 수있는 관련 트리에 대한 충분한 정보와 연결할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="61f59429096395b0e09a9585119ef97dbe0f3099" translate="yes" xml:space="preserve">
          <source>It cannot show more than 29 branches and commits at a time.</source>
          <target state="translated">한 번에 29 개 이상의 분기와 커밋을 표시 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="84908290c2ad8351819557b635db90afccbc35f1" translate="yes" xml:space="preserve">
          <source>It clones the submodule from &lt;code&gt;&amp;lt;repo&amp;gt;&lt;/code&gt; to the given &lt;code&gt;&amp;lt;path&amp;gt;&lt;/code&gt; under the current directory and by default checks out the master branch.</source>
          <target state="translated">하위 디렉토리 를 &lt;code&gt;&amp;lt;repo&amp;gt;&lt;/code&gt; 에서 현재 디렉토리 아래의 지정된 &lt;code&gt;&amp;lt;path&amp;gt;&lt;/code&gt; 로 복제하고 기본적으로 마스터 분기를 체크 아웃합니다.</target>
        </trans-unit>
        <trans-unit id="d2f2a22f8382dea93b62981d5e21e0c74a8c6b46" translate="yes" xml:space="preserve">
          <source>It could also be used to log the old..new status. However, it does not know the entire set of branches, so it would end up firing one e-mail per ref when used naively, though. The &lt;a href=&quot;#post-receive&quot;&gt;&lt;em&gt;post-receive&lt;/em&gt;&lt;/a&gt; hook is more suited to that.</source>
          <target state="translated">old..new 상태를 기록하는 데 사용될 수도 있습니다. 그러나 전체 브랜치 세트를 알지 못하므로 순진하게 사용될 때 참조 당 하나의 이메일을 발행하게됩니다. 는 &lt;a href=&quot;#post-receive&quot;&gt;&lt;em&gt;이후 수신&lt;/em&gt;&lt;/a&gt; 후크가 더 적합하다.</target>
        </trans-unit>
        <trans-unit id="784deb932c786d53caa1d9cefe7cd05964d957b0" translate="yes" xml:space="preserve">
          <source>It defaults to &lt;code&gt;blue,12 month ago,white,1 month ago,red&lt;/code&gt;, which colors everything older than one year blue, recent changes between one month and one year old are kept white, and lines introduced within the last month are colored red.</source>
          <target state="translated">1 년보다 오래된 모든 것을 채색 하는 &lt;code&gt;blue,12 month ago,white,1 month ago,red&lt;/code&gt; 기본 설정되며 , 1 개월과 1 년 사이의 최근 변경 사항은 흰색으로 유지되고 지난 달에 도입 된 선은 빨간색으로 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="91de163844ee67c93c1b1c843cc5bef0832c9f25" translate="yes" xml:space="preserve">
          <source>It does its best to do the safe thing, it will check that the files are unchanged and up to date in the CVS checkout, and it will not autocommit by default.</source>
          <target state="translated">안전한 작업을 수행하는 것이 가장 좋으며 CVS 체크 아웃에서 파일이 변경되지 않고 최신 상태인지 확인하며 기본적으로 자동 커밋되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="92564150ed02a0207f639f4b1e8f897270e7157d" translate="yes" xml:space="preserve">
          <source>It does this by storing some additional data for each entry (such as the last modified time). This data is not displayed above, and is not stored in the created tree object, but it can be used to determine quickly which files in the working directory differ from what was stored in the index, and thus save Git from having to read all of the data from such files to look for changes.</source>
          <target state="translated">각 항목에 대한 추가 데이터 (예 : 마지막 수정 시간)를 저장하여이를 수행합니다. 이 데이터는 위에 표시되지 않고 작성된 트리 오브젝트에 저장되지 않지만 작업 디렉토리의 파일이 색인에 저장된 파일과 다른 파일을 신속하게 판별하여 Git을 모두 읽지 않아도되도록하는 데 사용할 수 있습니다. 변경 사항을 찾기 위해 해당 파일의 데이터</target>
        </trans-unit>
        <trans-unit id="af8ba1869bb0a79ae9cea38b1af5617b9069dca1" translate="yes" xml:space="preserve">
          <source>It enables git to work together with a file system monitor (see the &quot;fsmonitor-watchman&quot; section of &lt;a href=&quot;githooks&quot;&gt;githooks[5]&lt;/a&gt;) that can inform it as to what files have been modified. This enables git to avoid having to lstat() every file to find modified files.</source>
          <target state="translated">git은 파일 시스템 모니터 ( &lt;a href=&quot;githooks&quot;&gt;githooks [5]&lt;/a&gt; 의 &quot;fsmonitor-watchman&quot;섹션 참조)와 함께 작동 하여 어떤 파일이 수정되었는지 알 수 있습니다. 이를 통해 git은 수정 된 파일을 찾기 위해 모든 파일을 lstat ()하지 않아도됩니다.</target>
        </trans-unit>
        <trans-unit id="af9f31199487ba705eebc5dd4bc13449d71955c8" translate="yes" xml:space="preserve">
          <source>It expects to be dealing with one project only. If it sees branches that have different roots, it will refuse to run. In that case, edit your &amp;lt;archive/branch&amp;gt; parameters to define clearly the scope of the import.</source>
          <target state="translated">하나의 프로젝트 만 처리 할 것으로 예상됩니다. 뿌리가 다른 가지가 보이면 달리기를 거부합니다. 이 경우 &amp;lt;archive / branch&amp;gt; 매개 변수를 편집하여 가져 오기 범위를 명확하게 정의하십시오.</target>
        </trans-unit>
        <trans-unit id="d015f51d5305572fa694969daaad327b702a39d6" translate="yes" xml:space="preserve">
          <source>It helps to divide these functions into groups for discussion purposes.</source>
          <target state="translated">토론 목적으로 이러한 기능을 그룹으로 나누는 데 도움이됩니다.</target>
        </trans-unit>
        <trans-unit id="cf8815ec8cef4d3d8f9a8adf49f25148a4887929" translate="yes" xml:space="preserve">
          <source>It is &lt;code&gt;&amp;lt;unix timestamp&amp;gt; &amp;lt;time zone offset&amp;gt;&lt;/code&gt;, where &lt;code&gt;&amp;lt;unix
timestamp&amp;gt;&lt;/code&gt; is the number of seconds since the UNIX epoch. &lt;code&gt;&amp;lt;time zone offset&amp;gt;&lt;/code&gt; is a positive or negative offset from UTC. For example CET (which is 1 hour ahead of UTC) is &lt;code&gt;+0100&lt;/code&gt;.</source>
          <target state="translated">그것은 인 &lt;code&gt;&amp;lt;unix timestamp&amp;gt; &amp;lt;time zone offset&amp;gt;&lt;/code&gt; 여기서 &lt;code&gt;&amp;lt;unix timestamp&amp;gt;&lt;/code&gt; 유닉스 에포크 초이다. &lt;code&gt;&amp;lt;time zone offset&amp;gt;&lt;/code&gt; 은 UTC의 양수 또는 음수 오프셋입니다. 예를 들어 CET (UTC보다 1 시간 &lt;code&gt;+0100&lt;/code&gt; )은 +0100 입니다.</target>
        </trans-unit>
        <trans-unit id="3f4ae55d14bc9f41dc555ac55a4684de8bea2c17" translate="yes" xml:space="preserve">
          <source>It is OK to include files which have not actually changed. All changes including newly-created and deleted files should be included. When files are renamed, both the old and the new name should be included.</source>
          <target state="translated">실제로 변경되지 않은 파일을 포함해도됩니다. 새로 생성되고 삭제 된 파일을 포함한 모든 변경 사항이 포함되어야합니다. 파일 이름이 바뀌면 이전 이름과 새 이름이 모두 포함되어야합니다.</target>
        </trans-unit>
        <trans-unit id="854a36265382bec82daa5a74f777ff212834a549" translate="yes" xml:space="preserve">
          <source>It is a good idea to introduce yourself to Git with your name and public email address before doing any operation. The easiest way to do so is:</source>
          <target state="translated">작업을 수행하기 전에 이름과 공개 이메일 주소로 Git에 자신을 소개하는 것이 좋습니다. 가장 쉬운 방법은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="0dc733d75bf5327e08cfc3134be1a3042cbb2515" translate="yes" xml:space="preserve">
          <source>It is a rough equivalent for:</source>
          <target state="translated">대략적으로 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="95c229774b9b51315840e554d56265719cd8be5c" translate="yes" xml:space="preserve">
          <source>It is also a good idea when using any VCS to have only one small logical change in each commit.</source>
          <target state="translated">또한 VCS를 사용하여 각 커밋마다 하나의 작은 논리적 변경 만 가하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="6c5a3acbba80472c3128c6339cb1639b4bd8a27a" translate="yes" xml:space="preserve">
          <source>It is also permitted for a notes ref to point directly to a tree object, in which case the history of the notes can be read with &lt;code&gt;git log -p -g &amp;lt;refname&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">노트 참조가 트리 객체를 직접 가리킬 수도 있습니다.이 경우 노트의 히스토리를 &lt;code&gt;git log -p -g &amp;lt;refname&amp;gt;&lt;/code&gt; 으로 읽을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="b16dc4f2558875d3f67cc118d8aee343695acae5" translate="yes" xml:space="preserve">
          <source>It is also possible to fetch a subset of branches or tags by using a comma-separated list of names within braces. For example:</source>
          <target state="translated">중괄호 안에 쉼표로 구분 된 이름 목록을 사용하여 분기 또는 태그의 하위 집합을 가져올 수도 있습니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="12b7523072e662c296ea1a80ba59ec7ed5fcb7e4" translate="yes" xml:space="preserve">
          <source>It is also possible to introduce completely new merge commits from scratch by adding a command of the form &lt;code&gt;merge &amp;lt;merge-head&amp;gt;&lt;/code&gt;. This form will generate a tentative commit message and always open an editor to let the user edit it. This can be useful e.g. when a topic branch turns out to address more than a single concern and wants to be split into two or even more topic branches. Consider this todo list:</source>
          <target state="translated">&lt;code&gt;merge &amp;lt;merge-head&amp;gt;&lt;/code&gt; 형식의 명령을 추가하여 완전히 새로운 병합 커밋을 처음부터 도입 할 수도 있습니다 . 이 양식은 임시 커밋 메시지를 생성하고 항상 사용자가 편집 할 수 있도록 편집기를 엽니 다. 예를 들어 주제 분기가 하나 이상의 관심사를 해결하고 둘 이상의 주제 분기로 분할하려는 경우에 유용 할 수 있습니다. 이 할 일 목록을 고려하십시오.</target>
        </trans-unit>
        <trans-unit id="e8d4e8a65d3b558ba4900bdd06798676f68d11ad" translate="yes" xml:space="preserve">
          <source>It is also possible to provide true CVS access to a Git repository, so that developers can still use CVS; see &lt;a href=&quot;git-cvsserver&quot;&gt;git-cvsserver[1]&lt;/a&gt; for details.</source>
          <target state="translated">개발자가 여전히 CVS를 사용할 수 있도록 Git 저장소에 대한 진정한 CVS 액세스를 제공 할 수도 있습니다. 자세한 내용은 &lt;a href=&quot;git-cvsserver&quot;&gt;git-cvsserver [1]&lt;/a&gt; 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="3fcb2e34d6c27144258c45911fcc9298afaeeefa" translate="yes" xml:space="preserve">
          <source>It is also possible to replace commits further back in the history, but this is an advanced topic to be left for &lt;a href=&quot;#cleaning-up-history&quot;&gt;another chapter&lt;/a&gt;.</source>
          <target state="translated">히스토리에서 커밋을 다시 대체하는 것도 가능하지만 이것은 &lt;a href=&quot;#cleaning-up-history&quot;&gt;다른 장에서&lt;/a&gt; 남겨 두어야 할 고급 주제 입니다.</target>
        </trans-unit>
        <trans-unit id="14665d6ab0c5fa19cd26aec534fecd5dda3c4692" translate="yes" xml:space="preserve">
          <source>It is also run after &lt;a href=&quot;git-clone&quot;&gt;git-clone[1]&lt;/a&gt;, unless the &lt;code&gt;--no-checkout&lt;/code&gt; (&lt;code&gt;-n&lt;/code&gt;) option is used. The first parameter given to the hook is the null-ref, the second the ref of the new HEAD and the flag is always 1. Likewise for &lt;code&gt;git worktree add&lt;/code&gt; unless &lt;code&gt;--no-checkout&lt;/code&gt; is used.</source>
          <target state="translated">&lt;code&gt;--no-checkout&lt;/code&gt; ( &lt;code&gt;-n&lt;/code&gt; ) 옵션을 사용 하지 않으면 &lt;a href=&quot;git-clone&quot;&gt;git-clone [1]&lt;/a&gt; 이후에도 실행 됩니다. 후크에 주어진 첫 번째 매개 변수는 null-ref이고, 두 번째는 새 HEAD의 ref이며 플래그는 항상 1 입니다. &lt;code&gt;--no-checkout&lt;/code&gt; 을 사용 하지 않는 한 &lt;code&gt;git worktree add&lt;/code&gt; 의 경우와 유사합니다 .</target>
        </trans-unit>
        <trans-unit id="2bf0b4701dd5a8615d5c5a4270f19ec18f43aa49" translate="yes" xml:space="preserve">
          <source>It is an error if &amp;lt;dst&amp;gt; matches more than one remote refs.</source>
          <target state="translated">&amp;lt;dst&amp;gt;가 둘 이상의 원격 참조와 일치하면 오류입니다.</target>
        </trans-unit>
        <trans-unit id="47ed8fd8a6ccf512f8dd41b7de1bb50b3d494692" translate="yes" xml:space="preserve">
          <source>It is an error if &amp;lt;src&amp;gt; does not match exactly one of the local refs.</source>
          <target state="translated">&amp;lt;src&amp;gt;가 로컬 참조 중 하나와 정확히 일치하지 않으면 오류입니다.</target>
        </trans-unit>
        <trans-unit id="08551e573ca80a9130c1ec33d2456a204ee6a838" translate="yes" xml:space="preserve">
          <source>It is an error to specify a ref that does not pass &quot;git check-ref-format&quot; scrutiny. Duplicated values are filtered.</source>
          <target state="translated">&quot;git check-ref-format&quot;검사를 통과하지 않은 참조를 지정하는 것은 오류입니다. 중복 된 값이 필터링됩니다.</target>
        </trans-unit>
        <trans-unit id="91dc5c05cc945b2e35d03a4d25f4568585356b02" translate="yes" xml:space="preserve">
          <source>It is assumed that any handshaking procedures have already been completed (such as sending service request for git://) before this helper is started.</source>
          <target state="translated">이 헬퍼가 시작되기 전에 핸드 셰이 킹 절차 (git : //에 대한 서비스 요청 전송 등)가 이미 완료된 것으로 가정합니다.</target>
        </trans-unit>
        <trans-unit id="7a3002fc7973dbc26474a90f4bdcb162301b4e67" translate="yes" xml:space="preserve">
          <source>It is currently only possible to recreate the merge commits using the &lt;code&gt;recursive&lt;/code&gt; merge strategy; Different merge strategies can be used only via explicit &lt;code&gt;exec git merge -s &amp;lt;strategy&amp;gt; [...]&lt;/code&gt; commands.</source>
          <target state="translated">현재 &lt;code&gt;recursive&lt;/code&gt; 병합 전략을 사용하여 병합 커밋을 다시 만들 수만 있습니다 . 다른 병합 전략은 명시 적 &lt;code&gt;exec git merge -s &amp;lt;strategy&amp;gt; [...]&lt;/code&gt; 명령을 통해서만 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="bd70cf0a22a7ad38ee60197dd400f891cf0d57a3" translate="yes" xml:space="preserve">
          <source>It is expected that the content of the commit object you created while following the example above generates a different SHA-1 hash than the one shown above because the commit object records the time when it was created and the name of the person performing the commit.</source>
          <target state="translated">커밋 개체는 생성 된 시간과 커밋을 수행하는 사람의 이름을 기록하기 때문에 위의 예를 따르는 동안 생성 한 커밋 개체의 내용은 위에 표시된 것과 다른 SHA-1 해시를 생성 할 것으로 예상됩니다.</target>
        </trans-unit>
        <trans-unit id="f78a88555b80a7cb6f279e6cf8551b4ade125a2a" translate="yes" xml:space="preserve">
          <source>It is followed by one or more extended header lines (this example shows a merge with two parents):</source>
          <target state="translated">그 뒤에 하나 이상의 확장 된 헤더 행이옵니다 (이 예에서는 두 부모와의 병합을 보여줍니다).</target>
        </trans-unit>
        <trans-unit id="4d181ca929d0bcae1d19e843f3c648e99a609d36" translate="yes" xml:space="preserve">
          <source>It is followed by one or more extended header lines:</source>
          <target state="translated">그 뒤에 하나 이상의 확장 된 헤더 행이옵니다.</target>
        </trans-unit>
        <trans-unit id="a6770fb3a63d614ebdc42bea002a81ec83ae2568" translate="yes" xml:space="preserve">
          <source>It is followed by two-line from-file/to-file header</source>
          <target state="translated">그 다음에 2 줄 From 파일 / to 파일 헤더가옵니다.</target>
        </trans-unit>
        <trans-unit id="31bbdf9a81fa3062a8106d3f0d5511057b4a5222" translate="yes" xml:space="preserve">
          <source>It is highly functional. However, not all methods are implemented, and for those methods that are implemented, not all switches are implemented.</source>
          <target state="translated">매우 기능적입니다. 그러나 모든 방법이 구현되는 것은 아니며 구현 된 방법에 대해 모든 스위치가 구현되는 것은 아닙니다.</target>
        </trans-unit>
        <trans-unit id="13209c7d424e2b65e2d35ccb5123d7d58e26c1e7" translate="yes" xml:space="preserve">
          <source>It is important to realize that at this point nothing refers to commit &lt;code&gt;f&lt;/code&gt;. Eventually commit &lt;code&gt;f&lt;/code&gt; (and by extension commit &lt;code&gt;e&lt;/code&gt;) will be deleted by the routine Git garbage collection process, unless we create a reference before that happens. If we have not yet moved away from commit &lt;code&gt;f&lt;/code&gt;, any of these will create a reference to it:</source>
          <target state="translated">이 시점에서 아무것도 커밋 &lt;code&gt;f&lt;/code&gt; 를 의미하지 않는다는 것을 인식하는 것이 중요합니다 . 결과적으로 커밋 &lt;code&gt;f&lt;/code&gt; (및 확장 커밋 &lt;code&gt;e&lt;/code&gt; )는 Git 가비지 수집 프로세스에 의해 삭제됩니다. commit &lt;code&gt;f&lt;/code&gt; 에서 멀어지지 않았다면 , 이것들에 대한 참조가 생성 될 것입니다 :</target>
        </trans-unit>
        <trans-unit id="15e77b99d56294dd4d998fab1260c89fc2b1f677" translate="yes" xml:space="preserve">
          <source>It is likely that you will be pulling from the same remote repository from time to time. As a short hand, you can store the remote repository URL in the local repository&amp;rsquo;s config file like this:</source>
          <target state="translated">때때로 동일한 원격 저장소에서 가져 오는 것 같습니다. 간단히 말해 다음과 같이 원격 저장소 URL을 로컬 저장소의 구성 파일에 저장할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e468ce82ca7a37df3e0ccb7eddd0ee514020b622" translate="yes" xml:space="preserve">
          <source>It is likely that you will be working on more than one thing at a time. It is easy to manage those more-or-less independent tasks using branches with Git.</source>
          <target state="translated">한 번에 둘 이상의 작업을 수행 할 수 있습니다. Git이있는 브랜치를 사용하여 다소 독립적 인 작업을 쉽게 관리 할 수 ​​있습니다.</target>
        </trans-unit>
        <trans-unit id="cdfac588afc71ee687618e7ec3bc2f824e200606" translate="yes" xml:space="preserve">
          <source>It is not always easy for new developers to find their way through Git&amp;rsquo;s source code. This section gives you a little guidance to show where to start.</source>
          <target state="translated">새로운 개발자가 Git의 소스 코드를 통해 길을 찾는 것이 항상 쉬운 것은 아닙니다. 이 섹션에서는 어디서부터 시작해야하는지에 대한 약간의 지침을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="deded1cb8baf6033568ee8de4cb9cb55818cb450" translate="yes" xml:space="preserve">
          <source>It is not recommended to use this feature if you intend to export changes back to CVS again later with &lt;code&gt;git cvsexportcommit&lt;/code&gt;.</source>
          <target state="translated">나중에 &lt;code&gt;git cvsexportcommit&lt;/code&gt; 을 사용하여 변경 사항을 CVS로 다시 내보내려면이 기능을 사용하지 않는 것이 좋습니다 .</target>
        </trans-unit>
        <trans-unit id="598d612724092a05c80fc92ca656e4e685e7e227" translate="yes" xml:space="preserve">
          <source>It is obviously a good idea not to have commits with changes that knowingly break things, even if some other commits later fix the breakage.</source>
          <target state="translated">다른 커밋이 나중에 파손을 수정하더라도 고의로 문제를 해결하는 변경 사항을 커밋하지 않는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="8402ec5252190f6132c0772d2b1eafbec27785df" translate="yes" xml:space="preserve">
          <source>It is possible that a merge failure will prevent this process from being completely automatic. You will have to resolve any such merge failure and run &lt;code&gt;git rebase --continue&lt;/code&gt;. Another option is to bypass the commit that caused the merge failure with &lt;code&gt;git rebase --skip&lt;/code&gt;. To check out the original &amp;lt;branch&amp;gt; and remove the .git/rebase-apply working files, use the command &lt;code&gt;git rebase --abort&lt;/code&gt; instead.</source>
          <target state="translated">병합 실패로 인해이 프로세스가 완전히 자동으로 진행되지 않을 수 있습니다. 이러한 병합 실패를 해결하고 &lt;code&gt;git rebase --continue&lt;/code&gt; 을 실행해야합니다 . 또 다른 옵션은 &lt;code&gt;git rebase --skip&lt;/code&gt; 로 병합 실패를 일으킨 커밋을 무시하는 것 입니다. 원본 &amp;lt;branch&amp;gt;를 확인하고 .git / rebase-apply 작업 파일을 제거하려면 대신 &lt;code&gt;git rebase --abort&lt;/code&gt; 명령을 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="2ea7f2913c3e95cfd4ae5ff1f6d8aecb190ef204" translate="yes" xml:space="preserve">
          <source>It is possible to construct these old form repositories manually.</source>
          <target state="translated">이러한 이전 양식 저장소를 수동으로 구성 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="548453998a9c855739e7eb9ec21e0581e0ed374b" translate="yes" xml:space="preserve">
          <source>It is possible to disable use of replacement references for any command using the &lt;code&gt;--no-replace-objects&lt;/code&gt; option just after &lt;code&gt;git&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;git&lt;/code&gt; 바로 다음에 &lt;code&gt;--no-replace-objects&lt;/code&gt; 옵션을 사용하여 명령에 대한 대체 참조 사용을 비활성화 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="c06956dd566d0990dc7bdbc85eb39fd34edd8452" translate="yes" xml:space="preserve">
          <source>It is preceded with a &quot;git diff&quot; header that looks like this:</source>
          <target state="translated">다음과 같은 &quot;git diff&quot;헤더가 앞에옵니다 :</target>
        </trans-unit>
        <trans-unit id="fae83443f259566d0e3ea169c2bee02ad7796585" translate="yes" xml:space="preserve">
          <source>It is preceded with a &quot;git diff&quot; header, that looks like this (when the &lt;code&gt;-c&lt;/code&gt; option is used):</source>
          <target state="translated">&quot;git diff&quot;헤더가 앞에옵니다. ( &lt;code&gt;-c&lt;/code&gt; 옵션을 사용하는 경우) :</target>
        </trans-unit>
        <trans-unit id="41c2e2ee7c9260a90ac9d47c12dc86595dc670c7" translate="yes" xml:space="preserve">
          <source>It is purely performance optimization, originally intended for MacOS X, where recursive directory traversal is slow. Gitweb follows symbolic links, but it detects cycles, ignoring any duplicate files and directories.</source>
          <target state="translated">재귀 적 디렉토리 탐색 속도가 느린 MacOS X를위한 순수한 성능 최적화입니다. Gitweb은 심볼릭 링크를 따르지만 중복 파일과 디렉토리는 무시하고주기를 감지합니다.</target>
        </trans-unit>
        <trans-unit id="bcd29e9bb49344b0e527480d5a1209557826cefc" translate="yes" xml:space="preserve">
          <source>It is recommended that &lt;code&gt;&amp;lt;path&amp;gt;&lt;/code&gt; always be encoded using UTF-8.</source>
          <target state="translated">&lt;code&gt;&amp;lt;path&amp;gt;&lt;/code&gt; 는 항상 UTF-8을 사용하여 인코딩하는 것이 좋습니다 .</target>
        </trans-unit>
        <trans-unit id="987c2f12e083069e2c3c6529da1c2b8427b5d901" translate="yes" xml:space="preserve">
          <source>It is safer if both &lt;code&gt;test.sh&lt;/code&gt; and &lt;code&gt;check_test_case.sh&lt;/code&gt; are outside the repository to prevent interactions between the bisect, make and test processes and the scripts.</source>
          <target state="translated">bisect, make 및 test 프로세스와 스크립트 간의 상호 작용을 방지하기 위해 &lt;code&gt;test.sh&lt;/code&gt; 와 &lt;code&gt;check_test_case.sh&lt;/code&gt; 가 모두 저장소 외부에 있으면 더 안전합니다 .</target>
        </trans-unit>
        <trans-unit id="07dbd897b2b790cda3e0cd6c93a27be05c0967a5" translate="yes" xml:space="preserve">
          <source>It is sometimes useful to be able to checkout a commit that is not at the tip of any named branch, or even to create a new commit that is not referenced by a named branch. Let&amp;rsquo;s look at what happens when we checkout commit &lt;code&gt;b&lt;/code&gt; (here we show two ways this may be done):</source>
          <target state="translated">명명 된 분기의 끝에없는 커밋을 체크 아웃하거나 명명 된 분기에서 참조하지 않는 새 커밋을 만드는 것이 유용한 경우가 있습니다. 커밋 &lt;code&gt;b&lt;/code&gt; 를 체크 아웃 할 때 어떤 일이 발생하는지 살펴 보자 (여기서는 두 가지 방법이있다).</target>
        </trans-unit>
        <trans-unit id="19dd47dcbbf16a9cccaac6e901efe1eb6d41c6b4" translate="yes" xml:space="preserve">
          <source>It is still your responsibility to make sure that the email message sent by your email program meets the standards of your project. Many projects do not like patches to be attached. Some mail agents will transform patches (e.g. wrap lines, send them as format=flowed) in ways that make them fail. You will get angry flames ridiculing you if you don&amp;rsquo;t check this.</source>
          <target state="translated">이메일 프로그램에서 보낸 이메일 메시지가 프로젝트 표준을 충족하는지 확인하는 것은 여전히 ​​귀하의 책임입니다. 많은 프로젝트는 패치를 첨부하는 것을 좋아하지 않습니다. 일부 메일 에이전트는 패치를 변형시키는 방식으로 패치를 변환합니다 (예 : 줄 바꿈, 형식 = 흐름으로 전송). 이것을 확인하지 않으면 화염이 날 것입니다.</target>
        </trans-unit>
        <trans-unit id="446989de9f552ff7a375d76851b391396cb21747" translate="yes" xml:space="preserve">
          <source>It is unlikely that you would have any conflicts here &amp;hellip;​ but you might if you spent a while on this step and had also pulled new versions from upstream.</source>
          <target state="translated">여기서 충돌이 발생하지는 않지만 ...이 단계에서 잠시 시간을 보내고 업스트림에서 새 버전을 가져 왔을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5d35217f8f6c81e1e684634a0bdd90859d19f06a" translate="yes" xml:space="preserve">
          <source>It is up to the user to ensure that no In-Reply-To header already exists when &lt;code&gt;git send-email&lt;/code&gt; is asked to add it (especially note that &lt;code&gt;git format-patch&lt;/code&gt; can be configured to do the threading itself). Failure to do so may not produce the expected result in the recipient&amp;rsquo;s MUA.</source>
          <target state="translated">&lt;code&gt;git send-email&lt;/code&gt; 에 헤더 를 추가하라는 요청 이있을 때 In-Reply-To 헤더가 없는지 확인하는 것은 사용자의 몫입니다 (특히 &lt;code&gt;git format-patch&lt;/code&gt; 는 스레딩 자체를 수행하도록 구성 될 수 있음). 그렇게하지 않으면 수신자의 MUA에서 예상되는 결과를 얻지 못할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="28ab82f4261b972bffcbd084fca6120764f529fe" translate="yes" xml:space="preserve">
          <source>It is useful when you&amp;rsquo;re looking for an exact block of code (like a struct), and want to know the history of that block since it first came into being: use the feature iteratively to feed the interesting block in the preimage back into &lt;code&gt;-S&lt;/code&gt;, and keep going until you get the very first version of the block.</source>
          <target state="translated">구조체와 같은 정확한 코드 블록을 찾고 처음 시작한 이후 해당 블록의 히스토리를 알고 싶을 때 유용합니다.이 기능을 반복적으로 사용하여 사전 이미지의 흥미로운 블록을 &lt;code&gt;-S&lt;/code&gt; 이고 블록의 첫 번째 버전을 얻을 때까지 계속 진행하십시오.</target>
        </trans-unit>
        <trans-unit id="212ba732375c1f9e18ce6b37fe943bc0a79e8a67" translate="yes" xml:space="preserve">
          <source>It is very important that the basis used be held by the destination. It is okay to err on the side of caution, causing the bundle file to contain objects already in the destination, as these are ignored when unpacking at the destination.</source>
          <target state="translated">사용 된 기준이 목적지에 의해 유지되는 것이 매우 중요합니다. 번들 파일에 대상에 이미있는 오브젝트가 포함되어 있으므로 대상 측에서 압축을 풀 때 무시되기 때문에주의를 기울여야합니다.</target>
        </trans-unit>
        <trans-unit id="f89d35d0ac276c4d31876791b9f069b985ca50ec" translate="yes" xml:space="preserve">
          <source>It may well be that among networking people, they may want to exchange the tags internal to their group, but in that workflow they are most likely tracking each other&amp;rsquo;s progress by having remote-tracking branches. Again, the heuristic to automatically follow such tags is a good thing.</source>
          <target state="translated">네트워킹 사람들 사이에서 그룹 내부의 태그를 교환하고 싶을 수도 있지만, 워크 플로에서 원격 추적 지점을 통해 서로의 진행 상황을 추적 할 가능성이 높습니다. 다시 말하지만, 그러한 태그를 자동으로 따르는 휴리스틱은 좋은 것입니다.</target>
        </trans-unit>
        <trans-unit id="b30dde80280e412c885fe09e1718d04b65bebbd4" translate="yes" xml:space="preserve">
          <source>It must be readable in order, from beginning to end, by someone intelligent with a basic grasp of the UNIX command line, but without any special knowledge of Git. If necessary, any other prerequisites should be specifically mentioned as they arise.</source>
          <target state="translated">유닉스 명령 줄에 대한 기본적인 지식이 있지만 Git에 대한 특별한 지식이없는 사람이 처음부터 끝까지 읽을 수 있어야한다. 필요한 경우, 다른 전제 조건을 구체적으로 언급해야합니다.</target>
        </trans-unit>
        <trans-unit id="105999ab02cc181d3d21d02fda72679e92aee0b2" translate="yes" xml:space="preserve">
          <source>It should be stressed that this hierarchy is purely &lt;strong&gt;informal&lt;/strong&gt;. There is nothing fundamental in Git that enforces the &quot;chain of patch flow&quot; this hierarchy implies. You do not have to pull from only one remote repository.</source>
          <target state="translated">이 계층은 순수하게 &lt;strong&gt;비공식적&lt;/strong&gt; 이라는 점을 강조해야합니다 . Git에는이 계층 구조가 의미하는 &quot;패치 흐름 체인&quot;을 적용하는 기본 사항이 없습니다. 하나의 원격 저장소 만 가져올 필요는 없습니다.</target>
        </trans-unit>
        <trans-unit id="593ae3fc1288babccd02a202f40d492d26634f5a" translate="yes" xml:space="preserve">
          <source>It shows that foo.png has differences from HEAD (but that is binary so line count cannot be shown) and there is no difference between indexed copy and the working tree version (if the working tree version were also different, &lt;code&gt;binary&lt;/code&gt; would have been shown in place of &lt;code&gt;nothing&lt;/code&gt;). The other file, git-add{litdd}interactive.perl, has 403 lines added and 35 lines deleted if you commit what is in the index, but working tree file has further modifications (one addition and one deletion).</source>
          <target state="translated">그것은 foo.png가 HEAD와 차이가 있지만 (이진수이므로 줄 수를 표시 할 수 없음) 색인화 된 사본과 작업 트리 버전 사이에는 차이가 없습니다 (작업 트리 버전도 다르면 &lt;code&gt;binary&lt;/code&gt; 되었을 것입니다) &lt;code&gt;nothing&lt;/code&gt; 대신 ). 색인에있는 내용을 커밋하면 다른 파일 인 git-add {litdd} interactive.perl에 403 줄이 추가되고 35 줄이 삭제되지만 작업 트리 파일에는 추가 수정 (한 번의 추가 및 한 번의 삭제)이 있습니다.</target>
        </trans-unit>
        <trans-unit id="1f22531fd9489cd1b4496c81c3454037c20af1a5" translate="yes" xml:space="preserve">
          <source>It takes a variable number of parameters, each of which is the name of ref that was actually updated.</source>
          <target state="translated">가변 개수의 매개 변수를 사용하며 각 매개 변수는 실제로 업데이트 된 ref의 이름입니다.</target>
        </trans-unit>
        <trans-unit id="8d1640303505dff202eb78d383641a82298beff2" translate="yes" xml:space="preserve">
          <source>It takes on the standard input the specification of the options to parse and understand, and echoes on the standard output a string suitable for &lt;code&gt;sh(1)&lt;/code&gt;&lt;code&gt;eval&lt;/code&gt; to replace the arguments with normalized ones. In case of error, it outputs usage on the standard error stream, and exits with code 129.</source>
          <target state="translated">표준 입력에서 구문 분석 및 이해하는 옵션의 스펙을 취하고 표준 출력 에서 인수를 정규화 된 인수로 대체 하기 위해 &lt;code&gt;sh(1)&lt;/code&gt; &lt;code&gt;eval&lt;/code&gt; 에 적합한 문자열을 에코 합니다. 오류가 발생하면 표준 오류 스트림에서 사용량을 출력하고 코드 129로 종료됩니다.</target>
        </trans-unit>
        <trans-unit id="9fc9d0adb73a5f351f66393e06f90ebbcd611062" translate="yes" xml:space="preserve">
          <source>It takes one to three parameters. The first is the name of the file that contains the commit log message. The second is the source of the commit message, and can be: &lt;code&gt;message&lt;/code&gt; (if a &lt;code&gt;-m&lt;/code&gt; or &lt;code&gt;-F&lt;/code&gt; option was given); &lt;code&gt;template&lt;/code&gt; (if a &lt;code&gt;-t&lt;/code&gt; option was given or the configuration option &lt;code&gt;commit.template&lt;/code&gt; is set); &lt;code&gt;merge&lt;/code&gt; (if the commit is a merge or a &lt;code&gt;.git/MERGE_MSG&lt;/code&gt; file exists); &lt;code&gt;squash&lt;/code&gt; (if a &lt;code&gt;.git/SQUASH_MSG&lt;/code&gt; file exists); or &lt;code&gt;commit&lt;/code&gt;, followed by a commit SHA-1 (if a &lt;code&gt;-c&lt;/code&gt;, &lt;code&gt;-C&lt;/code&gt; or &lt;code&gt;--amend&lt;/code&gt; option was given).</source>
          <target state="translated">1 ~ 3 개의 매개 변수가 필요합니다. 첫 번째는 커밋 로그 메시지가 포함 된 파일 이름입니다. 두 번째는 커밋 메시지의 소스이며 다음과 같습니다. &lt;code&gt;message&lt;/code&gt; ( &lt;code&gt;-m&lt;/code&gt; 또는 &lt;code&gt;-F&lt;/code&gt; 옵션이 제공된 경우); &lt;code&gt;template&lt;/code&gt; ( &lt;code&gt;-t&lt;/code&gt; 옵션이 제공되었거나 구성 옵션 &lt;code&gt;commit.template&lt;/code&gt; 이 설정된 경우); &lt;code&gt;merge&lt;/code&gt; (커밋이 병합이거나 &lt;code&gt;.git/MERGE_MSG&lt;/code&gt; 파일이있는 경우); &lt;code&gt;squash&lt;/code&gt; ( &lt;code&gt;.git/SQUASH_MSG&lt;/code&gt; 파일이있는 경우); 또는 &lt;code&gt;commit&lt;/code&gt; 다음에 commit SHA-1 ( &lt;code&gt;-c&lt;/code&gt; , &lt;code&gt;-C&lt;/code&gt; 또는 &lt;code&gt;--amend&lt;/code&gt; 인 경우) 옵션이 제공되었습니다).</target>
        </trans-unit>
        <trans-unit id="ee62cbb1781a10ccff3a10f01577042e41951364" translate="yes" xml:space="preserve">
          <source>It tells you that it did an &quot;Automatic merge&quot;, which failed due to conflicts in &lt;code&gt;hello&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;hello&lt;/code&gt; 의 충돌로 인해 실패한 &quot;자동 병합&quot;을 수행했음을 알려줍니다 .</target>
        </trans-unit>
        <trans-unit id="31dbee78e4c488ce29554dd490d874937eb736b5" translate="yes" xml:space="preserve">
          <source>It used to be that the command defaulted to do &lt;code&gt;-x&lt;/code&gt; described above, and &lt;code&gt;-r&lt;/code&gt; was to disable it. Now the default is not to do &lt;code&gt;-x&lt;/code&gt; so this option is a no-op.</source>
          <target state="translated">이전에는 명령이 위에서 설명한 &lt;code&gt;-x&lt;/code&gt; 를 기본 으로 사용했으며 &lt;code&gt;-r&lt;/code&gt; 은 명령을 비활성화했습니다. 이제 기본값은 &lt;code&gt;-x&lt;/code&gt; 를 수행하지 않으므로이 옵션은 작동하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="d5579126502958d7cf2a79d1e6eb0f1ab9f1fb74" translate="yes" xml:space="preserve">
          <source>It uses &lt;code&gt;showbranch.default&lt;/code&gt; multi-valued configuration items if no &amp;lt;rev&amp;gt; or &amp;lt;glob&amp;gt; is given on the command line.</source>
          <target state="translated">그것은 사용 &lt;code&gt;showbranch.default&lt;/code&gt; 더 &amp;lt;REV&amp;gt; 또는 &amp;lt;글로브&amp;gt;이 명령 행에 주어지지 않으면 다치 구성 항목.</target>
        </trans-unit>
        <trans-unit id="c599d3ca0dc61039dd83109e0beef002f0abd196" translate="yes" xml:space="preserve">
          <source>It verifies that the directory has the magic file &quot;git-daemon-export-ok&quot;, and it will refuse to export any Git directory that hasn&amp;rsquo;t explicitly been marked for export this way (unless the &lt;code&gt;--export-all&lt;/code&gt; parameter is specified). If you pass some directory paths as &lt;code&gt;git daemon&lt;/code&gt; arguments, you can further restrict the offers to a whitelist comprising of those.</source>
          <target state="translated">디렉토리에 매직 파일 &quot;git-daemon-export-ok&quot;가 있는지 확인하고 &lt;code&gt;--export-all&lt;/code&gt; 매개 변수를 지정 하지 않는 한 명시 적으로 내보내기 용으로 표시되지 않은 Git 디렉토리의 내보내기를 거부 합니다. ). 일부 디렉토리 경로를 &lt;code&gt;git daemon&lt;/code&gt; 인수 로 전달 하면 해당 오퍼를 추가로 화이트리스트로 제한 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3fd1b09d35c94e426d7de9278697f8281d2f9b0b" translate="yes" xml:space="preserve">
          <source>It verifies that the directory has the magic file &quot;git-daemon-export-ok&quot;, and it will refuse to export any Git directory that hasn&amp;rsquo;t explicitly been marked for export this way (unless the &lt;code&gt;GIT_HTTP_EXPORT_ALL&lt;/code&gt; environmental variable is set).</source>
          <target state="translated">디렉토리에 매직 파일 &quot;git-daemon-export-ok&quot;가 &lt;code&gt;GIT_HTTP_EXPORT_ALL&lt;/code&gt; 하고 GIT_HTTP_EXPORT_ALL 환경 변수가 설정 되지 않은 경우 명시 적으로 내 보내지 않은 Git 디렉토리의 내보내기를 거부합니다 .</target>
        </trans-unit>
        <trans-unit id="6a949f37aaca4177eee5df32a3761a98f4054a56" translate="yes" xml:space="preserve">
          <source>It was a tool of absolute last resort. I&amp;rsquo;d rather spend days looking at printk output than do a manual &lt;code&gt;patch bisection&lt;/code&gt;.</source>
          <target state="translated">절대 최후의 수단이었습니다. 수동 &lt;code&gt;patch bisection&lt;/code&gt; 보다 printk 출력을 보는 데 며칠을 보내고 싶습니다 .</target>
        </trans-unit>
        <trans-unit id="839ea1dcb179bd0fd1a734d84c9b044b60c7a423" translate="yes" xml:space="preserve">
          <source>It will be useful to have a Git repository to experiment with as you read this manual.</source>
          <target state="translated">이 매뉴얼을 읽을 때 Git 저장소를 시험해 보는 것이 유용합니다.</target>
        </trans-unit>
        <trans-unit id="a1e588b366d6eee7b2a111ab040de25b982fdb3f" translate="yes" xml:space="preserve">
          <source>It&amp;rsquo;s also possible for a push to fail in this way when other people have the right to push to the same repository. In that case, the correct solution is to retry the push after first updating your work: either by a pull, or by a fetch followed by a rebase; see the &lt;a href=&quot;#setting-up-a-shared-repository&quot;&gt;next section&lt;/a&gt; and &lt;a href=&quot;gitcvs-migration&quot;&gt;gitcvs-migration[7]&lt;/a&gt; for more.</source>
          <target state="translated">다른 사람이 동일한 저장소에 푸시 할 권한이있는 경우 이러한 방식으로 푸시가 실패 할 수도 있습니다. 이 경우 올바른 해결책은 작업을 처음 업데이트 한 후 푸시를 다시 시도하는 것입니다. 풀 (pull) 또는 페치 (fetch) 및 리베이스 (rebase); 자세한 내용은 &lt;a href=&quot;#setting-up-a-shared-repository&quot;&gt;다음 섹션&lt;/a&gt; 과 &lt;a href=&quot;gitcvs-migration&quot;&gt;gitcvs-migration [7]&lt;/a&gt; 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="c8e637a625c72275676a912327970832afbb1fc7" translate="yes" xml:space="preserve">
          <source>It&amp;rsquo;s especially instructive to look at &quot;commit&quot; objects, since those tend to be small and fairly self-explanatory. In particular, if you follow the convention of having the top commit name in &lt;code&gt;.git/HEAD&lt;/code&gt;, you can do</source>
          <target state="translated">&quot;커밋&quot;객체는 작고 상당히 설명적인 경향이 있기 때문에 &quot;커밋&quot;객체를 보는 것이 특히 유익합니다. 특히 &lt;code&gt;.git/HEAD&lt;/code&gt; 에서 최상위 커밋 이름을 갖는 규칙을 따르는 경우 다음을 수행 할 수 있습니다</target>
        </trans-unit>
        <trans-unit id="ebca6c1346b961bb4e2f8a08e1112a09cf4c4143" translate="yes" xml:space="preserve">
          <source>It&amp;rsquo;s far too easy to accidentally mix up old and new history. It&amp;rsquo;s still possible with any tool, but git-filter-branch almost invites it. If lucky, the only downside is users getting frustrated that they don&amp;rsquo;t know how to shrink their repo and remove the old stuff. If unlucky, they merge old and new history and end up with multiple &quot;copies&quot; of each commit, some of which have unwanted or sensitive files and others which don&amp;rsquo;t. This comes about in multiple different ways:</source>
          <target state="translated">실수로 오래된 것과 새로운 역사를 섞는 것은 너무 쉽습니다. 어떤 도구로도 가능하지만 git-filter-branch가 거의 초대합니다. 운이 좋으면 유일한 단점은 사용자가 레포를 축소하고 오래된 것을 제거하는 방법을 모른다는 좌절감입니다. 운이 좋지 않으면 구약과 새 기록을 병합하고 각 커밋의 여러 &quot;복사본&quot;으로 끝나며, 그 중 일부는 원치 않거나 민감한 파일이 있고 그렇지 않은 파일도 있습니다. 이것은 여러 가지 방법으로 발생합니다.</target>
        </trans-unit>
        <trans-unit id="7fb3124f269af4d6382e41b308c15a44d9e7c09f" translate="yes" xml:space="preserve">
          <source>It&amp;rsquo;s not safe to run &lt;code&gt;git submodule update&lt;/code&gt; if you&amp;rsquo;ve made and committed changes within a submodule without checking out a branch first. They will be silently overwritten:</source>
          <target state="translated">분기를 먼저 체크 아웃하지 않고 서브 모듈 내에서 변경을 수행하고 커밋 한 경우 &lt;code&gt;git submodule update&lt;/code&gt; 를 실행하는 것은 안전하지 않습니다 . 그들은 자동으로 덮어 쓰기됩니다 :</target>
        </trans-unit>
        <trans-unit id="199b24a07e7c4f542f5c9b6cd233e68c58c149e6" translate="yes" xml:space="preserve">
          <source>It&amp;rsquo;s possible to push any type of object to any namespace outside of &lt;code&gt;refs/{tags,heads}/*&lt;/code&gt;. In the case of tags and commits, these will be treated as if they were the commits inside &lt;code&gt;refs/heads/*&lt;/code&gt; for the purposes of whether the update is allowed.</source>
          <target state="translated">모든 유형의 객체를 &lt;code&gt;refs/{tags,heads}/*&lt;/code&gt; 외부의 네임 스페이스로 푸시 할 수 있습니다 . 태그와 커밋의 경우 업데이트 허용 여부를 위해 &lt;code&gt;refs/heads/*&lt;/code&gt; 내의 커밋 인 것처럼 처리됩니다 .</target>
        </trans-unit>
        <trans-unit id="cd25bf8e6a6252931a48d686e2c25ca4a7c9f16e" translate="yes" xml:space="preserve">
          <source>It&amp;rsquo;s probably not worth it to use this option on a given repository without running tailored performance benchmarks on it. It takes a lot more time, and the resulting space/delta optimization may or may not be worth it. Not using this at all is the right trade-off for most users and their repositories.</source>
          <target state="translated">맞춤형 성능 벤치 마크를 실행하지 않고 주어진 저장소에서이 옵션을 사용하는 것은 가치가 없습니다. 시간이 더 많이 걸리며 결과적으로 공간 / 델타 최적화는 그만한 가치가있을 수도 있고 그렇지 않을 수도 있습니다. 이것을 전혀 사용하지 않는 것은 대부분의 사용자와 그 저장소에 대한 올바른 균형입니다.</target>
        </trans-unit>
        <trans-unit id="6c2d9fe7b4d73e7c5f324adf6070448f4f753fb5" translate="yes" xml:space="preserve">
          <source>It&amp;rsquo;s reasonable to e.g. configure &lt;code&gt;fetch.pruneTags=true&lt;/code&gt; in &lt;code&gt;~/.gitconfig&lt;/code&gt; to have tags pruned whenever &lt;code&gt;git fetch --prune&lt;/code&gt; is run, without making every invocation of &lt;code&gt;git fetch&lt;/code&gt; without &lt;code&gt;--prune&lt;/code&gt; an error.</source>
          <target state="translated">예를 들어 &lt;code&gt;~/.gitconfig&lt;/code&gt; 에서 &lt;code&gt;fetch.pruneTags=true&lt;/code&gt; 를 구성 하여 &lt;code&gt;git fetch --prune&lt;/code&gt; 이 실행될 때마다 태그 를 &lt;code&gt;--prune&lt;/code&gt; 오류 를 제거 하지 않고 &lt;code&gt;git fetch&lt;/code&gt; 를 호출 하지 않아도 됩니다.</target>
        </trans-unit>
        <trans-unit id="b2ec8a66f406e3cd9a737fd2597d771efa24775d" translate="yes" xml:space="preserve">
          <source>It&amp;rsquo;s usually much more common that you merge with somebody else than merging with your own branches, so it&amp;rsquo;s worth pointing out that Git makes that very easy too, and in fact, it&amp;rsquo;s not that different from doing a &lt;code&gt;git merge&lt;/code&gt;. In fact, a remote merge ends up being nothing more than &quot;fetch the work from a remote repository into a temporary tag&quot; followed by a &lt;code&gt;git merge&lt;/code&gt;.</source>
          <target state="translated">일반적으로 자신의 브랜치와 병합하는 것 이외의 다른 사람과 병합하는 것이 훨씬 일반적이므로 Git을 사용하면 매우 쉽게 수행 할 수 있으며 실제로 &lt;code&gt;git merge&lt;/code&gt; 를 수행하는 것과 크게 다르지 않습니다 . 실제로, 원격 병합은 &quot;원격 저장소에서 작업을 임시 태그로 가져 오기&quot;다음에 &lt;code&gt;git merge&lt;/code&gt; 에 지나지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="09aeea995eee0f7341283401be15ea3abb990fd5" translate="yes" xml:space="preserve">
          <source>Iterate over all refs that match &lt;code&gt;&amp;lt;pattern&amp;gt;&lt;/code&gt; and show them according to the given &lt;code&gt;&amp;lt;format&amp;gt;&lt;/code&gt;, after sorting them according to the given set of &lt;code&gt;&amp;lt;key&amp;gt;&lt;/code&gt;. If &lt;code&gt;&amp;lt;count&amp;gt;&lt;/code&gt; is given, stop after showing that many refs. The interpolated values in &lt;code&gt;&amp;lt;format&amp;gt;&lt;/code&gt; can optionally be quoted as string literals in the specified host language allowing their direct evaluation in that language.</source>
          <target state="translated">&lt;code&gt;&amp;lt;pattern&amp;gt;&lt;/code&gt; 과 일치하는 모든 참조를 반복 하고 주어진 &lt;code&gt;&amp;lt;key&amp;gt;&lt;/code&gt; 세트에 따라 정렬 한 후 주어진 &lt;code&gt;&amp;lt;format&amp;gt;&lt;/code&gt; 에 따라 표시합니다 . 경우 &lt;code&gt;&amp;lt;count&amp;gt;&lt;/code&gt; 주어, 많은 심판을 표시 한 후 중지합니다. &lt;code&gt;&amp;lt;format&amp;gt;&lt;/code&gt; 의 보간 된 값 은 지정된 호스트 언어에서 문자열 리터럴로 선택적으로 인용하여 해당 언어로 직접 평가할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ddf6f030820afdde653bed6b6ae7f0e48144f06d" translate="yes" xml:space="preserve">
          <source>Join two or more development histories together</source>
          <target state="translated">둘 이상의 개발 히스토리에 참여</target>
        </trans-unit>
        <trans-unit id="045fff3a75d61e019edb089792c9fca9353d7073" translate="yes" xml:space="preserve">
          <source>Just as the filesystem &lt;code&gt;.&lt;/code&gt; (period) refers to the current directory, using a &lt;code&gt;.&lt;/code&gt; as a repository name in Git (a dot-repository) is a relative path and means your current repository.</source>
          <target state="translated">파일 시스템과 같습니다 &lt;code&gt;.&lt;/code&gt; (마침표)는를 사용하여 현재 디렉토리를 나타냅니다 &lt;code&gt;.&lt;/code&gt; Git의 저장소 이름으로 (점 저장소)는 상대 경로이며 현재 저장소를 의미합니다.</target>
        </trans-unit>
        <trans-unit id="dec0baabf794bebc3957d3bc4ac6d462cd46c778" translate="yes" xml:space="preserve">
          <source>Just doing &lt;code&gt;git checkout-index&lt;/code&gt; does nothing. You probably meant &lt;code&gt;git checkout-index -a&lt;/code&gt;. And if you want to force it, you want &lt;code&gt;git checkout-index -f -a&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;git checkout-index&lt;/code&gt; 만하면 아무것도하지 않습니다. 아마도 &lt;code&gt;git checkout-index -a&lt;/code&gt; 을 의미했을 것입니다 . 그리고 그것을 강제하고 싶다면 &lt;code&gt;git checkout-index -f -a&lt;/code&gt; 원합니다 .</target>
        </trans-unit>
        <trans-unit id="4909a5e9d012cc77cb3f33966c75c24bd556a2c1" translate="yes" xml:space="preserve">
          <source>Just in case you are doing something exotic, it should be noted that all of the &amp;lt;commit&amp;gt; in the above description, except in the last two forms that use &quot;..&quot; notations, can be any &amp;lt;tree&amp;gt;.</source>
          <target state="translated">만약 당신이 이국적인 것을하고있는 경우에, &quot;..&quot;표기법을 사용하는 마지막 두 형태를 제외하고는 위의 설명에서 모든 &amp;lt;commit&amp;gt;은 모든 &amp;lt;tree&amp;gt;가 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4be9ee55a1cb0649bc08a5f7fcba1609e56fcabe" translate="yes" xml:space="preserve">
          <source>Just like &lt;code&gt;push&lt;/code&gt;, a batch sequence of one or more &lt;code&gt;import&lt;/code&gt; is terminated with a blank line. For each batch of &lt;code&gt;import&lt;/code&gt;, the remote helper should produce a fast-import stream terminated by a &lt;code&gt;done&lt;/code&gt; command.</source>
          <target state="translated">&lt;code&gt;push&lt;/code&gt; 와 마찬가지로 하나 이상의 &lt;code&gt;import&lt;/code&gt; 의 일괄 처리 시퀀스 는 빈 줄로 종료됩니다. 각 &lt;code&gt;import&lt;/code&gt; 배치에 대해 원격 헬퍼는 &lt;code&gt;done&lt;/code&gt; 명령으로 종료 된 빠른 가져 오기 스트림을 생성해야합니다 .</target>
        </trans-unit>
        <trans-unit id="586f68de6dc69eba27bb1d4e9d9bb6d0f56b4317" translate="yes" xml:space="preserve">
          <source>Just make sure to disable line wrapping in the email client (GMail&amp;rsquo;s web interface will wrap lines no matter what, so you need to use a real IMAP client).</source>
          <target state="translated">이메일 클라이언트에서 줄 바꿈 기능을 비활성화하십시오 (Gmail의 웹 인터페이스는 내용에 상관없이 줄 바꿈하므로 실제 IMAP 클라이언트를 사용해야합니다).</target>
        </trans-unit>
        <trans-unit id="a7ee38bb7be4fc44198cb2685d9601dcf2b9f569" translate="yes" xml:space="preserve">
          <source>K</source>
          <target state="translated">K</target>
        </trans-unit>
        <trans-unit id="b97e8895c584b11a83b65d2dacb8c53b7178dd19" translate="yes" xml:space="preserve">
          <source>KMail</source>
          <target state="translated">KMail</target>
        </trans-unit>
        <trans-unit id="2341c447151da84825db8427aea972cadd7288d2" translate="yes" xml:space="preserve">
          <source>Keep a list of repositories you work with regularly:</source>
          <target state="translated">정기적으로 작업하는 리포지토리 목록을 유지하십시오.</target>
        </trans-unit>
        <trans-unit id="2367d7104c669108a5a4faee96aaf23e4129a768" translate="yes" xml:space="preserve">
          <source>Keep changes in working tree while discarding some previous commits</source>
          <target state="translated">이전 커밋을 삭제하면서 작업 트리의 변경 사항을 유지하십시오.</target>
        </trans-unit>
        <trans-unit id="efc112fed108eb2af53bef134295307559c52881" translate="yes" xml:space="preserve">
          <source>Keep downloaded pack.</source>
          <target state="translated">다운로드 한 팩을 보관하십시오.</target>
        </trans-unit>
        <trans-unit id="9b356018df37cea79789cf69374ce84ecae93c35" translate="yes" xml:space="preserve">
          <source>Keep in mind that the &lt;code&gt;*&lt;/code&gt; (asterisk) wildcard of the local ref (right of the &lt;code&gt;:&lt;/code&gt;) &lt;strong&gt;must&lt;/strong&gt; be the farthest right path component; however the remote wildcard may be anywhere as long as it&amp;rsquo;s an independent path component (surrounded by &lt;code&gt;/&lt;/code&gt; or EOL). This type of configuration is not automatically created by &lt;code&gt;init&lt;/code&gt; and should be manually entered with a text-editor or using &lt;code&gt;git config&lt;/code&gt;.</source>
          <target state="translated">것을 명심 &lt;code&gt;*&lt;/code&gt; (오른쪽의 로컬 심판의 (별표) 와일드 카드 &lt;code&gt;:&lt;/code&gt; ) &lt;strong&gt;있어야&lt;/strong&gt; 가장 먼 올바른 경로 구성 요소가 될; 그러나 원격 와일드 카드는 독립 경로 구성 요소 ( &lt;code&gt;/&lt;/code&gt; 또는 EOL로 둘러 쌓인) 인 경우 어디에나있을 수 있습니다 . 이 유형의 구성은 &lt;code&gt;init&lt;/code&gt; 에 의해 자동으로 작성되지 않으며 텍스트 편집기 또는 &lt;code&gt;git config&lt;/code&gt; 를 사용하여 수동으로 입력해야합니다 .</target>
        </trans-unit>
        <trans-unit id="f28d8482458ad8eaca4da9ce6d9f18435a267b61" translate="yes" xml:space="preserve">
          <source>Keep repeating the process: compile the tree, test it, and depending on whether it is good or bad run &lt;code&gt;git bisect good&lt;/code&gt; or &lt;code&gt;git bisect bad&lt;/code&gt; to ask for the next commit that needs testing.</source>
          <target state="translated">프로세스를 계속 반복하십시오 : 트리를 컴파일하고 테스트 한 다음 테스트가 필요한 다음 커밋을 요청하기에 &lt;code&gt;git bisect good&lt;/code&gt; 또는 &lt;code&gt;git bisect bad&lt;/code&gt; 가 좋은지 여부에 따라 테스트하십시오.</target>
        </trans-unit>
        <trans-unit id="4faf21022722c230f52c5287ce302764467e820e" translate="yes" xml:space="preserve">
          <source>Keep the commits that do not change anything from its parents in the result.</source>
          <target state="translated">결과에서 부모로부터 아무것도 변경하지 않는 커밋을 유지하십시오.</target>
        </trans-unit>
        <trans-unit id="ea4937dada87f98e69877594a5bd03ebc5a4fc74" translate="yes" xml:space="preserve">
          <source>Keep the current index contents, and read the contents of the named tree-ish under the directory at &lt;code&gt;&amp;lt;prefix&amp;gt;&lt;/code&gt;. The command will refuse to overwrite entries that already existed in the original index file.</source>
          <target state="translated">현재 색인 컨텐츠를 유지하고 &lt;code&gt;&amp;lt;prefix&amp;gt;&lt;/code&gt; 의 디렉토리에서 명명 된 tree-ish의 컨텐츠를 읽으십시오 . 명령은 원래 색인 파일에 이미 존재하는 항목을 겹쳐 쓰지 않습니다.</target>
        </trans-unit>
        <trans-unit id="d737c66ea055bf55ed844d15e52460a96096a67f" translate="yes" xml:space="preserve">
          <source>Keep the version from your branch in the work tree, but leave the path in the conflicted state for the user to sort out.</source>
          <target state="translated">작업 트리에서 분기의 버전을 유지하되 경로를 충돌 상태로 유지하여 사용자가 정렬하십시오.</target>
        </trans-unit>
        <trans-unit id="95e57eb6304d53fb35eb7b893fc3d7458db2c90c" translate="yes" xml:space="preserve">
          <source>Keep the working tree locked after creation. This is the equivalent of &lt;code&gt;git worktree lock&lt;/code&gt; after &lt;code&gt;git worktree add&lt;/code&gt;, but without race condition.</source>
          <target state="translated">작성 후 작업 트리를 잠근 상태로 유지하십시오. 이것은 &lt;code&gt;git worktree add&lt;/code&gt; 후 git worktree &lt;code&gt;git worktree lock&lt;/code&gt; 과 동일 하지만 경쟁 조건이 없습니다.</target>
        </trans-unit>
        <trans-unit id="b288ae9d082d21fcccb8cbea92de9e2fd90c35f9" translate="yes" xml:space="preserve">
          <source>Keep unreachable objects in loose form. This implies &lt;code&gt;--revs&lt;/code&gt;.</source>
          <target state="translated">손이 닿지 않는 물건은 느슨한 형태로 보관하십시오. 이것은 &lt;code&gt;--revs&lt;/code&gt; 를 의미 합니다 .</target>
        </trans-unit>
        <trans-unit id="5fef7648dce54325886b4bd2e05123b8e3f3ba8b" translate="yes" xml:space="preserve">
          <source>Keep working in your primary repository. Your changes include modifications of your own, patches you receive via e-mails, and merges resulting from pulling the &quot;public&quot; repositories of your &quot;project lead&quot; and possibly your &quot;sub-subsystem maintainers&quot;.</source>
          <target state="translated">기본 저장소에서 계속 작업하십시오. 변경 사항에는 자신의 수정 사항, 전자 메일을 통해받는 패치 및 &quot;프로젝트 리드&quot;의 &quot;공용&quot;리포지토리 및 &quot;하위 서브 시스템 유지 관리자&quot;를 가져 와서 병합됩니다.</target>
        </trans-unit>
        <trans-unit id="ca6eb7beb12ef44a32102578e1d606b2be688242" translate="yes" xml:space="preserve">
          <source>Keep working in your primary repository. Your changes include modifications of your own, patches you receive via e-mails, and merges resulting from pulling the &quot;public&quot; repositories of your &quot;subsystem maintainers&quot;.</source>
          <target state="translated">기본 저장소에서 계속 작업하십시오. 변경 사항에는 자신의 수정 사항, 전자 메일을 통해받는 패치 및 &quot;하위 시스템 관리자&quot;의 &quot;공용&quot;리포지토리를 가져 와서 병합되는 내용이 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="04e2360cc7b28c2ccb26642bb98ceb0fcbba2f5a" translate="yes" xml:space="preserve">
          <source>Keeping a patch series up to date using git rebase</source>
          <target state="translated">git rebase를 사용하여 패치 시리즈를 최신 상태로 유지</target>
        </trans-unit>
        <trans-unit id="b81b785228a23fa6b75a5abffb474819b40a8136" translate="yes" xml:space="preserve">
          <source>Kill keywords: will extract files with &lt;code&gt;-kk&lt;/code&gt; from the CVS archive to avoid noisy changesets. Highly recommended, but off by default to preserve compatibility with early imported trees.</source>
          <target state="translated">키워드 삭제 : 노이즈가 많은 변경 세트를 피하기 위해 CVS 아카이브에서 &lt;code&gt;-kk&lt;/code&gt; 를 사용하여 파일을 추출합니다 . 초기에 가져온 트리와의 호환성을 유지하려면 강력히 권장하지만 기본적으로 해제되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="02658e782a0ecc008f0ca6ffc2a20f7bdbee96d7" translate="yes" xml:space="preserve">
          <source>Label for the &quot;home link&quot; at the top of all pages, leading to &lt;code&gt;$home_link&lt;/code&gt; (usually the main gitweb page, which contains the projects list). It is used as the first component of gitweb&amp;rsquo;s &quot;breadcrumb trail&quot;: &lt;code&gt;&amp;lt;home link&amp;gt; / &amp;lt;project&amp;gt; / &amp;lt;action&amp;gt;&lt;/code&gt;. Can be set at build time using the &lt;code&gt;GITWEB_HOME_LINK_STR&lt;/code&gt; variable. By default it is set to &quot;projects&quot;, as this link leads to the list of projects. Another popular choice is to set it to the name of site. Note that it is treated as raw HTML so it should not be set from untrusted sources.</source>
          <target state="translated">모든 페이지의 상단에있는 &quot;홈 링크&quot;에 대한 레이블로 &lt;code&gt;$home_link&lt;/code&gt; (일반적으로 프로젝트 목록이 포함 된 기본 gitweb 페이지)로 연결됩니다. gitweb의 &quot;breadcrumb trail&quot;의 첫 번째 구성 요소로 사용됩니다 : &lt;code&gt;&amp;lt;home link&amp;gt; / &amp;lt;project&amp;gt; / &amp;lt;action&amp;gt;&lt;/code&gt; . 빌드시 &lt;code&gt;GITWEB_HOME_LINK_STR&lt;/code&gt; 변수를 사용하여 설정할 수 있습니다 . 이 링크는 프로젝트 목록으로 연결되므로 기본적으로 &quot;프로젝트&quot;로 설정됩니다. 또 다른 인기있는 선택은 사이트 이름으로 설정하는 것입니다. 원시 HTML로 취급되므로 신뢰할 수없는 소스에서 설정해서는 안됩니다.</target>
        </trans-unit>
        <trans-unit id="19b52717c24503e82535f1da97544e03ef42f759" translate="yes" xml:space="preserve">
          <source>Large projects are often composed of smaller, self-contained modules. For example, an embedded Linux distribution&amp;rsquo;s source tree would include every piece of software in the distribution with some local modifications; a movie player might need to build against a specific, known-working version of a decompression library; several independent programs might all share the same build scripts.</source>
          <target state="translated">대규모 프로젝트는 종종 작은 독립형 모듈로 구성됩니다. 예를 들어, 임베디드 Linux 배포판의 소스 트리에는 일부 로컬 수정 사항이 포함 된 배포판의 모든 소프트웨어가 포함됩니다. 영화 플레이어는 작동하는 특정 버전의 압축 해제 라이브러리에 대해 빌드해야합니다. 여러 독립 프로그램이 모두 동일한 빌드 스크립트를 공유 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="eebf4c31734b36e391dbec8f9bdc861cf73858fc" translate="yes" xml:space="preserve">
          <source>Later, Bob can update his repo with Alice&amp;rsquo;s latest changes using</source>
          <target state="translated">나중에 Bob은 Alice의 최신 변경 사항을 사용하여 자신의 저장소를 업데이트 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b67e320eff785b446a82207f60f64bae4d9398b2" translate="yes" xml:space="preserve">
          <source>Later, you can see whether your changes have been applied by saying (still on &lt;code&gt;topic&lt;/code&gt;):</source>
          <target state="translated">나중에 ( &lt;code&gt;topic&lt;/code&gt; )를 말하여 변경 사항이 적용되었는지 확인할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="0c480c6f24e2582817904a3ca717bfe059eaf9ba" translate="yes" xml:space="preserve">
          <source>Leading &lt;code&gt;Re:&lt;/code&gt;, &lt;code&gt;re:&lt;/code&gt;, and &lt;code&gt;:&lt;/code&gt;.</source>
          <target state="translated">선도 &lt;code&gt;Re:&lt;/code&gt; , &lt;code&gt;re:&lt;/code&gt; 및 &lt;code&gt;:&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6cba31f4e857a58fc5d56324b4f5b7ba501d5431" translate="yes" xml:space="preserve">
          <source>Leading and trailing whitespace are ignored.</source>
          <target state="translated">선행 및 후행 공백은 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="9400d93a0e4bf560ae2ff2a8521028a1c12485de" translate="yes" xml:space="preserve">
          <source>Leading and trailing whitespace.</source>
          <target state="translated">선행 및 후행 공백.</target>
        </trans-unit>
        <trans-unit id="b0ca289dea1d9e545043917d0313a90afe03b7b2" translate="yes" xml:space="preserve">
          <source>Leading bracketed strings (between &lt;code&gt;[&lt;/code&gt; and &lt;code&gt;]&lt;/code&gt;, usually &lt;code&gt;[PATCH]&lt;/code&gt;).</source>
          <target state="translated">선행 대괄호 문자열 ( &lt;code&gt;[&lt;/code&gt; 와 &lt;code&gt;]&lt;/code&gt; 사이 , 일반적으로 &lt;code&gt;[PATCH]&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="c5fae931542a3559bb8c0d5b861a24e60a1ac67c" translate="yes" xml:space="preserve">
          <source>Left-, middle-, or right-align the content between %(align:&amp;hellip;​) and %(end). The &quot;align:&quot; is followed by &lt;code&gt;width=&amp;lt;width&amp;gt;&lt;/code&gt; and &lt;code&gt;position=&amp;lt;position&amp;gt;&lt;/code&gt; in any order separated by a comma, where the &lt;code&gt;&amp;lt;position&amp;gt;&lt;/code&gt; is either left, right or middle, default being left and &lt;code&gt;&amp;lt;width&amp;gt;&lt;/code&gt; is the total length of the content with alignment. For brevity, the &quot;width=&quot; and/or &quot;position=&quot; prefixes may be omitted, and bare &amp;lt;width&amp;gt; and &amp;lt;position&amp;gt; used instead. For instance, &lt;code&gt;%(align:&amp;lt;width&amp;gt;,&amp;lt;position&amp;gt;)&lt;/code&gt;. If the contents length is more than the width then no alignment is performed. If used with &lt;code&gt;--quote&lt;/code&gt; everything in between %(align:&amp;hellip;​) and %(end) is quoted, but if nested then only the topmost level performs quoting.</source>
          <target state="translated">% (align :&amp;hellip;)와 % (end) 사이에서 내용을 왼쪽, 중간 또는 오른쪽으로 맞 춥니 다. &quot;align :&quot;뒤에는 쉼표로 구분 된 순서대로 &lt;code&gt;width=&amp;lt;width&amp;gt;&lt;/code&gt; 및 &lt;code&gt;position=&amp;lt;position&amp;gt;&lt;/code&gt; 이옵니다. 여기서 &lt;code&gt;&amp;lt;position&amp;gt;&lt;/code&gt; 은 왼쪽, 오른쪽 또는 중간이며 기본값은 왼쪽이고 &lt;code&gt;&amp;lt;width&amp;gt;&lt;/code&gt; 는 총계입니다. 정렬 내용의 길이. 간결하게하기 위해, &quot;width =&quot;및 / 또는 &quot;position =&quot;접두사는 생략하고 대신 &amp;lt;width&amp;gt; 및 &amp;lt;position&amp;gt;을 사용할 수 있습니다. 예를 들어 &lt;code&gt;%(align:&amp;lt;width&amp;gt;,&amp;lt;position&amp;gt;)&lt;/code&gt; 입니다. 내용 길이가 너비보다 크면 정렬이 수행되지 않습니다. % (align :&amp;hellip;)와 % (end) 사이의 모든 것을 &lt;code&gt;--quote&lt;/code&gt; 와 함께 사용하면 ,그러나 중첩 된 경우 최상위 레벨 만 인용을 수행합니다.</target>
        </trans-unit>
        <trans-unit id="4913da5c2a93f28cfca5df10654d75686a764062" translate="yes" xml:space="preserve">
          <source>Legacy alias for &lt;code&gt;--smtp-encryption ssl&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;--smtp-encryption ssl&lt;/code&gt; 의 레거시 별명 .</target>
        </trans-unit>
        <trans-unit id="8c79d7d578b1dfedd061424fe06d7bbd7bf7860a" translate="yes" xml:space="preserve">
          <source>Legacy monitoring operations are not supported (edit, watch and related). Exports and tagging (tags and branches) are not supported at this stage.</source>
          <target state="translated">레거시 모니터링 작업은 지원되지 않습니다 (편집, 감시 및 관련). 이 단계에서는 내보내기 및 태그 지정 (태그 및 분기)이 지원되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="efdb524a0ef0e2256e12ca50686b4d8bc222c208" translate="yes" xml:space="preserve">
          <source>Lesson three is: study the code. Really, it is the best way to learn about the organization of Git (after you know the basic concepts).</source>
          <target state="translated">세 번째 교훈은 코드를 연구하는 것입니다. 실제로 Git의 조직에 대해 배우는 가장 좋은 방법입니다 (기본 개념을 알고 난 후에).</target>
        </trans-unit>
        <trans-unit id="893b35eb2ef36c307a5615060033f2510cf02d9b" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s also suppose that we have a cleaned up graph like one after step 1) in the bisection algorithm above. This means that we can measure the information we get in terms of number of commit we can remove from the graph..</source>
          <target state="translated">또한 위의 이분법 알고리즘에서 1) 단계 후 하나씩 정리 된 그래프가 있다고 가정 해 봅시다. 즉, 그래프에서 제거 할 수있는 커밋 수와 관련하여 얻은 정보를 측정 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c8d0e17bfd7a63329a6082665d278b7fb499b0b6" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s skip over the obvious details; the only really interesting part here is the call to &lt;code&gt;get_sha1()&lt;/code&gt;. It tries to interpret &lt;code&gt;argv[2]&lt;/code&gt; as an object name, and if it refers to an object which is present in the current repository, it writes the resulting SHA-1 into the variable &lt;code&gt;sha1&lt;/code&gt;.</source>
          <target state="translated">명백한 세부 사항을 건너 뛰십시오. 여기서 정말로 흥미로운 부분은 &lt;code&gt;get_sha1()&lt;/code&gt; 대한 호출 입니다. &lt;code&gt;argv[2]&lt;/code&gt; 를 객체 이름으로 해석하려고 시도 하고 현재 저장소에있는 객체를 참조하면 결과 SHA-1을 변수 &lt;code&gt;sha1&lt;/code&gt; 에 씁니다 .</target>
        </trans-unit>
        <trans-unit id="cc9abf37f1be76cb29eb48ded27f1fe2938a8b22" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s start a new project and create a small amount of history:</source>
          <target state="translated">새 프로젝트를 시작하고 적은 역사를 만들어 봅시다 :</target>
        </trans-unit>
        <trans-unit id="f0d62f9783a955198cc607ca11b36e935a346c02" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s take the following graph as an example:</source>
          <target state="translated">다음 그래프를 예로 들어 보겠습니다.</target>
        </trans-unit>
        <trans-unit id="1c0b60e2ec5a47fbbf8d5055a8c4fd552a20bdbd" translate="yes" xml:space="preserve">
          <source>Lets you rewrite Git revision history by rewriting the branches mentioned in the &amp;lt;rev-list options&amp;gt;, applying custom filters on each revision. Those filters can modify each tree (e.g. removing a file or running a perl rewrite on all files) or information about each commit. Otherwise, all information (including original commit times or merge information) will be preserved.</source>
          <target state="translated">&amp;lt;rev-list options&amp;gt;에 언급 된 브랜치를 다시 작성하여 각 개정판에 사용자 정의 필터를 적용하여 Git 개정 내역을 다시 작성할 수 있습니다. 이러한 필터는 각 트리 (예 : 파일 제거 또는 모든 파일에서 perl 다시 쓰기 실행) 또는 각 커밋에 대한 정보를 수정할 수 있습니다. 그렇지 않으면 모든 정보 (원래 커밋 시간 또는 병합 정보 포함)가 유지됩니다.</target>
        </trans-unit>
        <trans-unit id="58fd3b1b83cc7fc933d72fe934bdb6e534441281" translate="yes" xml:space="preserve">
          <source>Licensed under the MIT License.</source>
          <target state="translated">MIT 라이센스에 따라 라이센스가 부여되었습니다.</target>
        </trans-unit>
        <trans-unit id="8a762e028503c19597a52f977263fd61a8df56e0" translate="yes" xml:space="preserve">
          <source>Lighttpd</source>
          <target state="translated">Lighttpd</target>
        </trans-unit>
        <trans-unit id="c20b9e30add4d8fcb9e944c3a79357b0eb58faf9" translate="yes" xml:space="preserve">
          <source>Like --allow-empty this command is primarily for use by foreign SCM interface scripts. It allows you to create a commit with an empty commit message without using plumbing commands like &lt;a href=&quot;git-commit-tree&quot;&gt;git-commit-tree[1]&lt;/a&gt;.</source>
          <target state="translated">--allow-empty와 같이이 명령은 주로 외부 SCM 인터페이스 스크립트에서 사용됩니다. &lt;a href=&quot;git-commit-tree&quot;&gt;git-commit-tree [1]&lt;/a&gt; 과 같은 배관 명령을 사용하지 않고 빈 커밋 메시지로 커밋을 만들 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="5f6f49e5a6f1778648e9730643fd43474f2dbc13" translate="yes" xml:space="preserve">
          <source>Like --get-all, but interprets the name as a regular expression and writes out the key names. Regular expression matching is currently case-sensitive and done against a canonicalized version of the key in which section and variable names are lowercased, but subsection names are not.</source>
          <target state="translated">--get-all과 비슷하지만 이름을 정규식으로 해석하고 키 이름을 씁니다. 정규식 일치는 현재 대소 문자를 구분하며 섹션 및 변수 이름이 소문자로 된 하위 키 이름의 정규화 된 키에 대해 수행됩니다.</target>
        </trans-unit>
        <trans-unit id="f93e6625e77c19d6664d2e45faf25a33780dbe37" translate="yes" xml:space="preserve">
          <source>Like --import-marks but instead of erroring out, silently skips the file if it does not exist.</source>
          <target state="translated">--import-marks와 비슷하지만 오류가 아닌 파일이 없으면 자동으로 건너 뜁니다.</target>
        </trans-unit>
        <trans-unit id="0eda32196b28e34b5200ae38915b28d72ba0802b" translate="yes" xml:space="preserve">
          <source>Like --import-marks except in two respects: first, only one &quot;feature import-marks&quot; or &quot;feature import-marks-if-exists&quot; command is allowed per stream; second, an --import-marks= or --import-marks-if-exists command-line option overrides any of these &quot;feature&quot; commands in the stream; third, &quot;feature import-marks-if-exists&quot; like a corresponding command-line option silently skips a nonexistent file.</source>
          <target state="translated">두 가지 측면을 제외하고 --import-marks와 유사합니다. 첫째, 스트림 당 하나의 &quot;feature import-marks&quot;또는 &quot;feature import-marks-if-exists&quot;명령 만 허용됩니다. 둘째, --import-marks = 또는 --import-marks-if-exists 명령 줄 옵션은 스트림에서 이러한 &quot;기능&quot;명령을 무시합니다. 셋째, 해당 명령 줄 옵션과 같은 &quot;기능 가져 오기 표시가있는 경우&quot;는 존재하지 않는 파일을 자동으로 건너 뜁니다.</target>
        </trans-unit>
        <trans-unit id="ea166a12e166b75ad46458f975797a03647dc62d" translate="yes" xml:space="preserve">
          <source>Like --keep create a .keep file before moving the index into its final destination, but rather than creating an empty file place &lt;code&gt;&amp;lt;msg&amp;gt;&lt;/code&gt; followed by an LF into the .keep file. The &lt;code&gt;&amp;lt;msg&amp;gt;&lt;/code&gt; message can later be searched for within all .keep files to locate any which have outlived their usefulness.</source>
          <target state="translated">--keep과 같이 색인을 최종 대상으로 이동하기 전에 .keep 파일을 작성하십시오. 빈 파일 위치 &lt;code&gt;&amp;lt;msg&amp;gt;&lt;/code&gt; 를 작성하고 LF를 .keep 파일에 작성하지 마십시오. &lt;code&gt;&amp;lt;msg&amp;gt;&lt;/code&gt; 메시지는 나중에 모든 .keep 파일을 자신의 유용성을 지났다 한 어느 하나를 찾는 내에서 검색 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="da58772c0d323657b31dd0d6c68daa01b72022dc" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;--cherry-pick&lt;/code&gt; (see below) but mark equivalent commits with &lt;code&gt;=&lt;/code&gt; rather than omitting them, and inequivalent ones with &lt;code&gt;+&lt;/code&gt;.</source>
          <target state="translated">마찬가지로 &lt;code&gt;--cherry-pick&lt;/code&gt; (아래 참조)하지만 동등한 커밋 표시 &lt;code&gt;=&lt;/code&gt; 보다는를 생략하고와 inequivalent 사람 &lt;code&gt;+&lt;/code&gt; 를 .</target>
        </trans-unit>
        <trans-unit id="18b014ee75198b1ce501d5b1546fe06cd49ddd23" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;--git-dir&lt;/code&gt;, but its output is always the canonicalized absolute path.</source>
          <target state="translated">마찬가지로 &lt;code&gt;--git-dir&lt;/code&gt; , 그러나 그것의 출력은 항상 정규화 절대 경로입니다.</target>
        </trans-unit>
        <trans-unit id="af1d4315bb510027eb7e61b588f2b477e26e55d4" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;--refresh&lt;/code&gt;, but checks stat information unconditionally, without regard to the &quot;assume unchanged&quot; setting.</source>
          <target state="translated">&lt;code&gt;--refresh&lt;/code&gt; 와 비슷 하지만 &quot;변경되지 않은 것으로 가정&quot;설정과 상관없이 무조건 통계 정보를 검사합니다.</target>
        </trans-unit>
        <trans-unit id="649d7b810a2269259a3e3571033e0da598ccd04e" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;-C&lt;/code&gt;, but with &lt;code&gt;-c&lt;/code&gt; the editor is invoked, so that the user can further edit the commit message.</source>
          <target state="translated">마찬가지로 &lt;code&gt;-C&lt;/code&gt; 는 하지만, 함께 &lt;code&gt;-c&lt;/code&gt; 편집기를 호출, 사용자는 더 편집이 커밋 메시지를 수 있도록있다.</target>
        </trans-unit>
        <trans-unit id="72f500fc1c4bd05ad014fbedf9cd9b9fb51f168b" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;-C&lt;/code&gt;, but with &lt;code&gt;-c&lt;/code&gt; the editor is invoked, so that the user can further edit the note message.</source>
          <target state="translated">마찬가지로 &lt;code&gt;-C&lt;/code&gt; 만에 &lt;code&gt;-c&lt;/code&gt; 편집기를 호출하므로 사용자가 할 수있는 더 편집 노트 메시지가.</target>
        </trans-unit>
        <trans-unit id="5f2734a31de3aa99c55dc536f672e3afeacd6e67" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;fsck.&amp;lt;msg-id&amp;gt;&lt;/code&gt; this variable has corresponding &lt;code&gt;receive.fsck.skipList&lt;/code&gt; and &lt;code&gt;fetch.fsck.skipList&lt;/code&gt; variants.</source>
          <target state="translated">마찬가지로 &lt;code&gt;fsck.&amp;lt;msg-id&amp;gt;&lt;/code&gt; 이 변수 대응있다 &lt;code&gt;receive.fsck.skipList&lt;/code&gt; 및 &lt;code&gt;fetch.fsck.skipList&lt;/code&gt; 은 변종.</target>
        </trans-unit>
        <trans-unit id="8f4973bf138d30d1fbff518822c72869393d6ab3" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;git push&lt;/code&gt; or &lt;code&gt;git fetch&lt;/code&gt;, imports handled by fast-import are safe to run alongside parallel &lt;code&gt;git repack -a -d&lt;/code&gt; or &lt;code&gt;git gc&lt;/code&gt; invocations, or any other Git operation (including &lt;code&gt;git prune&lt;/code&gt;, as loose objects are never used by fast-import).</source>
          <target state="translated">마찬가지로 &lt;code&gt;git push&lt;/code&gt; 또는 &lt;code&gt;git fetch&lt;/code&gt; 빠른 가져 오기에 의해 처리 수입, 병렬 함께 실행하는 데 안전 &lt;code&gt;git repack -a -d&lt;/code&gt; 또는 &lt;code&gt;git gc&lt;/code&gt; 호출, 또는 포함한 다른 힘내 작업 ( &lt;code&gt;git prune&lt;/code&gt; , 느슨한 객체에 의해 사용되지 않습니다로 빠르게 가져 오기 ).</target>
        </trans-unit>
        <trans-unit id="c7a0caab42cb430b8f7eb62e2b9ee91196438e5f" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;git rebase&lt;/code&gt;; this requires that the working tree be clean and have no uncommitted changes.</source>
          <target state="translated">&lt;code&gt;git rebase&lt;/code&gt; 처럼 ; 작업 트리가 깨끗하고 커밋되지 않은 변경 사항이 없어야합니다.</target>
        </trans-unit>
        <trans-unit id="94b902a35ff412729993e3558dc74f40d9a138f0" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;mailmap.file&lt;/code&gt;, but consider the value as a reference to a blob in the repository. If both &lt;code&gt;mailmap.file&lt;/code&gt; and &lt;code&gt;mailmap.blob&lt;/code&gt; are given, both are parsed, with entries from &lt;code&gt;mailmap.file&lt;/code&gt; taking precedence. In a bare repository, this defaults to &lt;code&gt;HEAD:.mailmap&lt;/code&gt;. In a non-bare repository, it defaults to empty.</source>
          <target state="translated">&lt;code&gt;mailmap.file&lt;/code&gt; 과 유사 하지만 값을 저장소의 blob에 대한 참조로 고려하십시오. 두 경우 &lt;code&gt;mailmap.file&lt;/code&gt; 및 &lt;code&gt;mailmap.blob&lt;/code&gt; 이 주어진다, 모두의 항목으로, 구문 분석 &lt;code&gt;mailmap.file&lt;/code&gt; 복용 우선 순위. Bare 저장소에서 기본값은 &lt;code&gt;HEAD:.mailmap&lt;/code&gt; 입니다. Bare가 아닌 저장소에서는 기본적으로 비어 있습니다.</target>
        </trans-unit>
        <trans-unit id="e5b79d6b46ed0bad865e7c66642f5df5197bbc3e" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;pop&lt;/code&gt;, but do not remove the state from the stash list. Unlike &lt;code&gt;pop&lt;/code&gt;, &lt;code&gt;&amp;lt;stash&amp;gt;&lt;/code&gt; may be any commit that looks like a commit created by &lt;code&gt;stash push&lt;/code&gt; or &lt;code&gt;stash create&lt;/code&gt;.</source>
          <target state="translated">마찬가지로 &lt;code&gt;pop&lt;/code&gt; 하지만, 숨김 목록에서 상태를 제거하지 마십시오. 달리 &lt;code&gt;pop&lt;/code&gt; , &lt;code&gt;&amp;lt;stash&amp;gt;&lt;/code&gt; A를 만든 커밋 원하는 그 모습을 저지 할 수있다 &lt;code&gt;stash push&lt;/code&gt; 또는 &lt;code&gt;stash create&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b42cf6e877b403442b6c5e230e0a3121abfa79f2" translate="yes" xml:space="preserve">
          <source>Like get, but returns all values for a multi-valued key.</source>
          <target state="translated">get과 비슷하지만 다중 값 키의 모든 값을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="73701f369b01fba26e9d0bb68ef652b62a8e8ce1" translate="yes" xml:space="preserve">
          <source>Like host.example:foo/repo, but use /home/foo/.ssh/somekey as keypair and user as user on remote side. This avoids needing to edit .ssh/config.</source>
          <target state="translated">host.example : foo / repo와 유사하지만 /home/foo/.ssh/somekey를 키 쌍으로 사용하고 사용자를 원격 측에서 사용자로 사용하십시오. 이렇게하면 .ssh / config를 편집 할 필요가 없습니다.</target>
        </trans-unit>
        <trans-unit id="6a22ef6226883a7823ee7468ab3e5221cd1b0fcc" translate="yes" xml:space="preserve">
          <source>Like many programs that switch user id, the daemon does not reset environment variables such as &lt;code&gt;$HOME&lt;/code&gt; when it runs git programs, e.g. &lt;code&gt;upload-pack&lt;/code&gt; and &lt;code&gt;receive-pack&lt;/code&gt;. When using this option, you may also want to set and export &lt;code&gt;HOME&lt;/code&gt; to point at the home directory of &lt;code&gt;&amp;lt;user&amp;gt;&lt;/code&gt; before starting the daemon, and make sure any Git configuration files in that directory are readable by &lt;code&gt;&amp;lt;user&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">사용자 ID를 전환하는 많은 프로그램과 마찬가지로 데몬은 git 프로그램을 실행할 때 &lt;code&gt;$HOME&lt;/code&gt; 과 같은 환경 변수를 재설정하지 않습니다 ( 예 : &lt;code&gt;upload-pack&lt;/code&gt; 및 &lt;code&gt;receive-pack&lt;/code&gt; ) . 이 옵션을 사용하는 경우, 당신은 또한 세트 내보낼 수 있습니다 &lt;code&gt;HOME&lt;/code&gt; 의 홈 디렉토리에서 점에 &lt;code&gt;&amp;lt;user&amp;gt;&lt;/code&gt; 데몬을 시작하기 전에, 있는지 그 디렉토리에있는 망할 놈의 구성 파일을 읽을 수 있습니다 있도록 &lt;code&gt;&amp;lt;user&amp;gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="955d6409ae367c03bad138119c6bf959eda46b3c" translate="yes" xml:space="preserve">
          <source>Likewise, when the &lt;code&gt;LV&lt;/code&gt; environment variable is unset, Git sets it to &lt;code&gt;-c&lt;/code&gt;. You can override this setting by exporting &lt;code&gt;LV&lt;/code&gt; with another value or setting &lt;code&gt;core.pager&lt;/code&gt; to &lt;code&gt;lv +c&lt;/code&gt;.</source>
          <target state="translated">마찬가지로 &lt;code&gt;LV&lt;/code&gt; 환경 변수가 설정 해제되면 Git은 &lt;code&gt;-c&lt;/code&gt; 로 설정합니다 . &lt;code&gt;LV&lt;/code&gt; 를 다른 값 으로 내보내 거나 &lt;code&gt;core.pager&lt;/code&gt; 를 &lt;code&gt;lv +c&lt;/code&gt; 설정 하여이 설정을 무시할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="da647d41a556bd9f858a9fb821a95fe4fa6d0849" translate="yes" xml:space="preserve">
          <source>Limit commits to the ones touching files in the given paths. Note, to avoid ambiguity with respect to revision names use &quot;--&quot; to separate the paths from any preceding options.</source>
          <target state="translated">주어진 경로에서 파일을 터치하는 커밋을 제한합니다. 개정판 이름과 관련하여 모호성을 피하려면 &quot;-&quot;를 사용하여 이전 옵션과 경로를 구분하십시오.</target>
        </trans-unit>
        <trans-unit id="a8f6287e3aa57458fad3449d202e28c228d6d460" translate="yes" xml:space="preserve">
          <source>Limit diff output to named subtrees.</source>
          <target state="translated">diff 출력을 명명 된 하위 트리로 제한하십시오.</target>
        </trans-unit>
        <trans-unit id="73ea1d1481ae126a39e8d8a25424a40b0120067c" translate="yes" xml:space="preserve">
          <source>Limit fetching to ancestor-chains not longer than n. &lt;code&gt;git-upload-pack&lt;/code&gt; treats the special depth 2147483647 as infinite even if there is an ancestor-chain that long.</source>
          <target state="translated">가져 오기를 n 이하의 조상 체인으로 제한하십시오. &lt;code&gt;git-upload-pack&lt;/code&gt; 은 조상 체인이 길더라도 특수 깊이 2147483647을 무한대로 취급합니다.</target>
        </trans-unit>
        <trans-unit id="3548328e70b776f579a206b5e26f3a2cdd3bf54c" translate="yes" xml:space="preserve">
          <source>Limit fetching to the specified number of commits from the tip of each remote branch history. If fetching to a &lt;code&gt;shallow&lt;/code&gt; repository created by &lt;code&gt;git clone&lt;/code&gt; with &lt;code&gt;--depth=&amp;lt;depth&amp;gt;&lt;/code&gt; option (see &lt;a href=&quot;git-clone&quot;&gt;git-clone[1]&lt;/a&gt;), deepen or shorten the history to the specified number of commits. Tags for the deepened commits are not fetched.</source>
          <target state="translated">각 원격 브랜치 히스토리의 끝에서 지정된 커밋 수로 인출을 제한하십시오. &lt;code&gt;--depth=&amp;lt;depth&amp;gt;&lt;/code&gt; 옵션 ( &lt;a href=&quot;git-clone&quot;&gt;git-clone [1]&lt;/a&gt; 참조)을 사용 하여 &lt;code&gt;git clone&lt;/code&gt; 으로 작성된 &lt;code&gt;shallow&lt;/code&gt; 저장소로 페치하는 경우 , 지정된 커밋 수만큼 히스토리를 깊게하거나 줄이십시오. 강화 된 커밋에 대한 태그는 가져 오지 않습니다.</target>
        </trans-unit>
        <trans-unit id="406e704b5fa6637d1092aef900d6bea100f59424" translate="yes" xml:space="preserve">
          <source>Limit output to the one commit object which is roughly halfway between included and excluded commits. Note that the bad bisection ref &lt;code&gt;refs/bisect/bad&lt;/code&gt; is added to the included commits (if it exists) and the good bisection refs &lt;code&gt;refs/bisect/good-*&lt;/code&gt; are added to the excluded commits (if they exist). Thus, supposing there are no refs in &lt;code&gt;refs/bisect/&lt;/code&gt;, if</source>
          <target state="translated">포함 된 커밋과 제외 된 커밋 사이의 중간 정도 인 하나의 커밋 객체로 출력을 제한합니다. 불량 biref &lt;code&gt;refs/bisect/bad&lt;/code&gt; 가 포함 된 커밋에 추가되고 (존재하는 경우) good bisection refs &lt;code&gt;refs/bisect/good-*&lt;/code&gt; 가 제외 된 커밋에 추가됩니다 (존재하는 경우). 따라서 &lt;code&gt;refs/bisect/&lt;/code&gt; 에 참조가 없다고 가정 하면</target>
        </trans-unit>
        <trans-unit id="2b149769f0e9e62c7755e40f7d9c9b100ff198f3" translate="yes" xml:space="preserve">
          <source>Limit the commits output to ones that match all given &lt;code&gt;--grep&lt;/code&gt;, instead of ones that match at least one.</source>
          <target state="translated">커밋 출력을 하나 이상의 일치하는 것이 아니라 지정된 모든 &lt;code&gt;--grep&lt;/code&gt; 와 일치하는 것으로 제한하십시오 .</target>
        </trans-unit>
        <trans-unit id="119c553a83e823fd710ae4f2da2e455c4cb090b7" translate="yes" xml:space="preserve">
          <source>Limit the commits output to ones with author/committer header lines that match the specified pattern (regular expression). With more than one &lt;code&gt;--author=&amp;lt;pattern&amp;gt;&lt;/code&gt;, commits whose author matches any of the given patterns are chosen (similarly for multiple &lt;code&gt;--committer=&amp;lt;pattern&amp;gt;&lt;/code&gt;).</source>
          <target state="translated">지정된 패턴 (정규 표현식)과 일치하는 작성자 / 커미터 헤더 행이있는 커밋 출력으로 커밋 출력을 제한합니다. 이상 하나 &lt;code&gt;--author=&amp;lt;pattern&amp;gt;&lt;/code&gt; , 그 저자 커밋은 주어진 패턴 중 일치 선택된다 (마찬가지로 여러 대 &lt;code&gt;--committer=&amp;lt;pattern&amp;gt;&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="dd1c85bc38b39ba5aff2bee57d4deea0c60fd712" translate="yes" xml:space="preserve">
          <source>Limit the commits output to ones with log message that do not match the pattern specified with &lt;code&gt;--grep=&amp;lt;pattern&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">커밋 출력을 &lt;code&gt;--grep=&amp;lt;pattern&amp;gt;&lt;/code&gt; 에 지정된 패턴과 일치하지 않는 로그 메시지가있는 것으로 제한합니다 .</target>
        </trans-unit>
        <trans-unit id="bd9eadb3ad8dfb9ffb371dc1589fe6576ab540f4" translate="yes" xml:space="preserve">
          <source>Limit the commits output to ones with log message that matches the specified pattern (regular expression). With more than one &lt;code&gt;--grep=&amp;lt;pattern&amp;gt;&lt;/code&gt;, commits whose message matches any of the given patterns are chosen (but see &lt;code&gt;--all-match&lt;/code&gt;).</source>
          <target state="translated">커밋 출력을 지정된 패턴 (정규 표현식)과 일치하는 로그 메시지가있는 것으로 제한합니다. 둘 이상의 &lt;code&gt;--grep=&amp;lt;pattern&amp;gt;&lt;/code&gt; 을 사용하면 지정된 패턴과 일치하는 메시지가 선택된 커밋이 선택됩니다 (그러나 &lt;code&gt;--all-match&lt;/code&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="d1b86714045e4612b85a2fa8cf22123bd3513cb6" translate="yes" xml:space="preserve">
          <source>Limit the commits output to ones with reflog entries that match the specified pattern (regular expression). With more than one &lt;code&gt;--grep-reflog&lt;/code&gt;, commits whose reflog message matches any of the given patterns are chosen. It is an error to use this option unless &lt;code&gt;--walk-reflogs&lt;/code&gt; is in use.</source>
          <target state="translated">커밋 출력을 지정된 패턴 (정규 표현식)과 일치하는 reflog 항목이있는 출력으로 제한합니다. 하나 이상의 &lt;code&gt;--grep-reflog&lt;/code&gt; 를 사용하면 지정된 패턴과 일치하는 reflog 메시지를 가진 커밋이 선택됩니다. &lt;code&gt;--walk-reflogs&lt;/code&gt; 를 사용하지 않으면이 옵션을 사용하는 것은 오류 입니다.</target>
        </trans-unit>
        <trans-unit id="2b5d877818bdb0956a66e366504390cf3fe65b29" translate="yes" xml:space="preserve">
          <source>Limit the commits output to specified time range.</source>
          <target state="translated">커밋 출력을 지정된 시간 범위로 제한합니다.</target>
        </trans-unit>
        <trans-unit id="d8dbf5f629bd3296e9ab1177de95e69729e1d54b" translate="yes" xml:space="preserve">
          <source>Limit the displayed commits to those directly on the ancestry chain between the &amp;ldquo;from&amp;rdquo; and &amp;ldquo;to&amp;rdquo; commits in the given commit range. I.e. only display commits that are ancestor of the &amp;ldquo;to&amp;rdquo; commit and descendants of the &amp;ldquo;from&amp;rdquo; commit.</source>
          <target state="translated">표시된 커밋은 주어진 커밋 범위에서 &quot;시작&quot;과 &quot;끝&quot;커밋 사이의 상위 체인에있는 커밋으로 제한합니다. 즉, &quot;to&quot;커밋의 조상이자 &quot;from&quot;커밋의 자손 인 커밋 만 표시합니다.</target>
        </trans-unit>
        <trans-unit id="ed8c2d4ed1408e7d7da83719bcf77ad7b5896ff9" translate="yes" xml:space="preserve">
          <source>Limit the number of commits imported. Workaround for cases where cvsimport leaks memory.</source>
          <target state="translated">가져온 커밋 수를 제한하십시오. cvsimport가 메모리를 누출하는 경우의 해결 방법.</target>
        </trans-unit>
        <trans-unit id="1adada65b7a03da88bf0748c36055d961c64b07a" translate="yes" xml:space="preserve">
          <source>Limit the number of commits to output.</source>
          <target state="translated">출력 커밋 수를 제한하십시오.</target>
        </trans-unit>
        <trans-unit id="38e02fe4379a543b3e47180cba4d6468bec3e601" translate="yes" xml:space="preserve">
          <source>Limit the revisions to show. This can be either a single revision meaning show from the given revision and back, or it can be a range in the form &quot;&lt;code&gt;&amp;lt;from&amp;gt;&lt;/code&gt;..&lt;code&gt;&amp;lt;to&amp;gt;&lt;/code&gt;&quot; to show all revisions between &lt;code&gt;&amp;lt;from&amp;gt;&lt;/code&gt; and back to &lt;code&gt;&amp;lt;to&amp;gt;&lt;/code&gt;. Note, more advanced revision selection can be applied. For a more complete list of ways to spell object names, see &lt;a href=&quot;gitrevisions&quot;&gt;gitrevisions[7]&lt;/a&gt;.</source>
          <target state="translated">표시 할 수정을 제한하십시오. 이것은 다시 주어진 수요일 수정에서 단일 수요일 수정 의미 표시가 될 수 있거나,이 형태의 범위 일 수있다 &quot; &lt;code&gt;&amp;lt;from&amp;gt;&lt;/code&gt; .. &lt;code&gt;&amp;lt;to&amp;gt;&lt;/code&gt; &quot;사이의 모든 수정 보여 &lt;code&gt;&amp;lt;from&amp;gt;&lt;/code&gt; 위로 및 &lt;code&gt;&amp;lt;to&amp;gt;&lt;/code&gt; . 보다 고급 버전 선택을 적용 할 수 있습니다. 객체 이름을 철자하는 방법에 대한 전체 목록은 &lt;a href=&quot;gitrevisions&quot;&gt;gitrevisions [7]를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="674ff0df4160db3404d979762630ae612e98f156" translate="yes" xml:space="preserve">
          <source>Limit the width of the graph part in --stat output. If set, applies to all commands generating --stat output except format-patch.</source>
          <target state="translated">--stat 출력에서 ​​그래프 부분의 너비를 제한하십시오. 설정하면 format-patch를 제외한 --stat 출력을 생성하는 모든 명령에 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="29e45322508b52ceb051971d532eab460b3dc7d7" translate="yes" xml:space="preserve">
          <source>Limit to &quot;refs/heads&quot; and &quot;refs/tags&quot;, respectively. These options are not mutually exclusive; when given both, references stored in &quot;refs/heads&quot; and &quot;refs/tags&quot; are displayed.</source>
          <target state="translated">&quot;refs / heads&quot;및 &quot;refs / tags&quot;로 각각 제한합니다. 이러한 옵션은 상호 배타적이지 않습니다. 둘 다 지정하면 &quot;refs / heads&quot;및 &quot;refs / tags&quot;에 저장된 참조가 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="66b9fb961da3804ca95085a20ace37a86529e6f7" translate="yes" xml:space="preserve">
          <source>Limit to only refs/heads and refs/tags, respectively. These options are &lt;code&gt;not&lt;/code&gt; mutually exclusive; when given both, references stored in refs/heads and refs/tags are displayed.</source>
          <target state="translated">심판 / 헤드 및 심판 / 태그로만 제한합니다. 이러한 옵션은 상호 배타적이지 &lt;code&gt;not&lt;/code&gt; . 둘 다 주어지면 참조 / 헤드 및 참조 / 태그에 저장된 참조가 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="a7c04c64ed3f2a9374590c76c50d3b7f1b18e3da" translate="yes" xml:space="preserve">
          <source>Limitations</source>
          <target state="translated">Limitations</target>
        </trans-unit>
        <trans-unit id="e8bb22d887f5d59400be2b36a39e61d714bda7bc" translate="yes" xml:space="preserve">
          <source>Limiting the diff output</source>
          <target state="translated">diff 출력 제한</target>
        </trans-unit>
        <trans-unit id="b7748eb338af2086cdad1f6af364c3481df64676" translate="yes" xml:space="preserve">
          <source>Limits the number of commits to show to 3.</source>
          <target state="translated">표시 할 커밋 수를 3으로 제한합니다.</target>
        </trans-unit>
        <trans-unit id="efd756293dbb86969a7022bf4157b3145d6076f3" translate="yes" xml:space="preserve">
          <source>Limits the paths affected by the operation.</source>
          <target state="translated">작업의 영향을받는 경로를 제한합니다.</target>
        </trans-unit>
        <trans-unit id="8375cb461aa1ace8d2ffdda18edb87b333f2f4d1" translate="yes" xml:space="preserve">
          <source>Line numbers count from 1.</source>
          <target state="translated">줄 번호는 1부터 계산됩니다.</target>
        </trans-unit>
        <trans-unit id="3d9326a0fc6538daba3b0f3096cf5c416812b52b" translate="yes" xml:space="preserve">
          <source>Lines starting with a hash (&quot;&lt;code&gt;#&lt;/code&gt;&quot;) are ignored, so they can be used for comments. Add a backslash (&quot;&lt;code&gt;\&lt;/code&gt;&quot;) to the beginning of the pattern if it starts with a hash.</source>
          <target state="translated">해시 ( &quot; &lt;code&gt;#&lt;/code&gt; &quot;)로 시작하는 줄 은 무시되므로 주석에 사용할 수 있습니다. 해시로 시작하는 경우 패턴 시작 부분에 백 슬래시 ( &quot; &lt;code&gt;\&lt;/code&gt; &quot;)를 추가하십시오 .</target>
        </trans-unit>
        <trans-unit id="8e28fd820953d60830c4b1106307e2e0b6872452" translate="yes" xml:space="preserve">
          <source>Linewrap the output by wrapping each line at &lt;code&gt;width&lt;/code&gt;. The first line of each entry is indented by &lt;code&gt;indent1&lt;/code&gt; spaces, and the second and subsequent lines are indented by &lt;code&gt;indent2&lt;/code&gt; spaces. &lt;code&gt;width&lt;/code&gt;, &lt;code&gt;indent1&lt;/code&gt;, and &lt;code&gt;indent2&lt;/code&gt; default to 76, 6 and 9 respectively.</source>
          <target state="translated">각 줄을 &lt;code&gt;width&lt;/code&gt; 로 감싸서 출력을 줄 바꿈하십시오 . 각 항목의 첫 번째 줄은 &lt;code&gt;indent1&lt;/code&gt; 공백으로 들여 쓰기되고 두 번째 및 후속 줄은 &lt;code&gt;indent2&lt;/code&gt; 공백 만큼 들여 쓰기됩니다 . &lt;code&gt;width&lt;/code&gt; , &lt;code&gt;indent1&lt;/code&gt; 및 &lt;code&gt;indent2&lt;/code&gt; 의 기본값은 각각 76, 6 및 9입니다.</target>
        </trans-unit>
        <trans-unit id="1d1f6a47e210ac264339f2e30472d9fdf4025a54" translate="yes" xml:space="preserve">
          <source>Links and their targets</source>
          <target state="translated">링크와 목표</target>
        </trans-unit>
        <trans-unit id="7177342122325630102d4a83723d13417535ac19" translate="yes" xml:space="preserve">
          <source>Linus Torvalds originally designed Git to be a user space file system, i.e. the infrastructure to hold files and directories. That ensured the efficiency and speed of Git.</source>
          <target state="translated">Linus Torvalds는 원래 Git을 사용자 공간 파일 시스템, 즉 파일과 디렉토리를 보유하는 인프라로 설계했습니다. 이는 Git의 효율성과 속도를 보장했습니다.</target>
        </trans-unit>
        <trans-unit id="9f9879c2ed0b6b8dfd5d9b1ecb4faa0c5584d26d" translate="yes" xml:space="preserve">
          <source>Linus Torvalds, for example, makes new kernel releases by tagging them, then running:</source>
          <target state="translated">예를 들어, Linus Torvalds는 새로운 커널 릴리스를 태깅 한 다음 실행하여 만듭니다.</target>
        </trans-unit>
        <trans-unit id="c215fd74e10e91e4728dc7ef559cf830d21a3457" translate="yes" xml:space="preserve">
          <source>Linus&amp;rsquo;s tree will be stored in the remote-tracking branch named origin/master, and can be updated using &lt;a href=&quot;git-fetch&quot;&gt;git-fetch[1]&lt;/a&gt;; you can track other public trees using &lt;a href=&quot;git-remote&quot;&gt;git-remote[1]&lt;/a&gt; to set up a &quot;remote&quot; and &lt;a href=&quot;git-fetch&quot;&gt;git-fetch[1]&lt;/a&gt; to keep them up to date; see &lt;a href=&quot;#repositories-and-branches&quot;&gt;Repositories and Branches&lt;/a&gt;.</source>
          <target state="translated">Linus의 트리는 origin / master라는 원격 추적 브랜치에 저장되며 &lt;a href=&quot;git-fetch&quot;&gt;git-fetch [1]&lt;/a&gt; ; &lt;a href=&quot;git-remote&quot;&gt;git-remote [1]&lt;/a&gt; 을 사용하여 &quot;remote&quot;를 설정하고 &lt;a href=&quot;git-fetch&quot;&gt;git-fetch [1]&lt;/a&gt; 을 사용하여 다른 공용 트리를 추적 하여 최신 상태로 유지할 수 있습니다. &lt;a href=&quot;#repositories-and-branches&quot;&gt;리포지토리 및 분기를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="4a79bad3bb798b3bdc01c2a7bbb2df04a2b261bb" translate="yes" xml:space="preserve">
          <source>List (array reference) of feature parameters (if there are any), used also to toggle (enable or disable) given feature.</source>
          <target state="translated">기능 매개 변수 (있는 경우)의 목록 (배열 참조). 또한 주어진 기능을 토글 (활성화 또는 비활성화)하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="7ee03188f58cdb7509c4f88e1a300f564da6d9fa" translate="yes" xml:space="preserve">
          <source>List all attributes that are associated with the specified paths. If this option is used, then &lt;code&gt;unspecified&lt;/code&gt; attributes will not be included in the output.</source>
          <target state="translated">지정된 경로와 연관된 모든 속성을 나열하십시오. 이 옵션을 사용하면 &lt;code&gt;unspecified&lt;/code&gt; 속성이 출력에 포함되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="250839942391006b259bdb87bdef885727a6f6a9" translate="yes" xml:space="preserve">
          <source>List all available configuration variables. This is a short summary of the list in &lt;a href=&quot;git-config&quot;&gt;git-config[1]&lt;/a&gt;.</source>
          <target state="translated">사용 가능한 모든 구성 변수를 나열하십시오. 이것은 &lt;a href=&quot;git-config&quot;&gt;git-config [1]&lt;/a&gt; 의 목록에 대한 간단한 요약입니다 .</target>
        </trans-unit>
        <trans-unit id="12ac07106316dd6381b9d3b75b7cd7d028c9fa93" translate="yes" xml:space="preserve">
          <source>List all commits reachable from all refs</source>
          <target state="translated">모든 심판에서 도달 할 수있는 모든 커밋을 나열하십시오.</target>
        </trans-unit>
        <trans-unit id="dca598d76b2fd502e68ee09810f65324e1da32ae" translate="yes" xml:space="preserve">
          <source>List all tags (lightweight and annotated) in given repository.</source>
          <target state="translated">지정된 저장소에있는 모든 태그 (경량 및 주석이있는)를 나열하십시오.</target>
        </trans-unit>
        <trans-unit id="df1447e22cac81b01f2aee49d9517212423de9a9" translate="yes" xml:space="preserve">
          <source>List all variables set in config file, along with their values.</source>
          <target state="translated">구성 파일에 설정된 모든 변수와 해당 값을 나열하십시오.</target>
        </trans-unit>
        <trans-unit id="aa1b92c795a51cb41c1ee54087151d51eda95116" translate="yes" xml:space="preserve">
          <source>List both remote-tracking branches and local branches. Combine with &lt;code&gt;--list&lt;/code&gt; to match optional pattern(s).</source>
          <target state="translated">원격 추적 지점과 로컬 지점을 모두 나열하십시오. 선택적 패턴을 일치 시키려면 &lt;code&gt;--list&lt;/code&gt; 와 결합하십시오 .</target>
        </trans-unit>
        <trans-unit id="670ea777adabe92ea2a21ddec9e8062878d9ce68" translate="yes" xml:space="preserve">
          <source>List branches. With optional &lt;code&gt;&amp;lt;pattern&amp;gt;...&lt;/code&gt;, e.g. &lt;code&gt;git
branch --list 'maint-*'&lt;/code&gt;, list only the branches that match the pattern(s).</source>
          <target state="translated">지점을 나열하십시오. 선택적 &lt;code&gt;&amp;lt;pattern&amp;gt;...&lt;/code&gt; 을 사용 하여 (예 : &lt;code&gt;git branch --list 'maint-*'&lt;/code&gt; ) 패턴과 일치하는 분기 만 나열하십시오.</target>
        </trans-unit>
        <trans-unit id="ecd6ee4f3b1cdf8c4e62426b401b6921926e6641" translate="yes" xml:space="preserve">
          <source>List commands by group. This is an internal/experimental option and may change or be removed in the future. Supported groups are: builtins, parseopt (builtin commands that use parse-options), main (all commands in libexec directory), others (all other commands in &lt;code&gt;$PATH&lt;/code&gt; that have git- prefix), list-&amp;lt;category&amp;gt; (see categories in command-list.txt), nohelpers (exclude helper commands), alias and config (retrieve command list from config variable completion.commands)</source>
          <target state="translated">그룹별로 명령을 나열하십시오. 이는 내부 / 실험 옵션이며 향후 변경되거나 제거 될 수 있습니다. 지원되는 그룹은 builtins, parseopt (구문 분석 옵션을 사용하는 내장 명령), main (libexec 디렉토리의 모든 명령), 기타 ( git 접두어가 있는 &lt;code&gt;$PATH&lt;/code&gt; 다른 모든 명령 ), list- &amp;lt;category&amp;gt; (카테고리 참조) command-list.txt), nohelpers (헬퍼 명령 제외), 별명 및 config (구성 변수 완성에서 명령 목록 검색)</target>
        </trans-unit>
        <trans-unit id="238ed7681a7fd585fe1d585aba4d3e4521202ffa" translate="yes" xml:space="preserve">
          <source>List commits that are reachable by following the &lt;code&gt;parent&lt;/code&gt; links from the given commit(s), but exclude commits that are reachable from the one(s) given with a &lt;code&gt;^&lt;/code&gt; in front of them. The output is given in reverse chronological order by default.</source>
          <target state="translated">주어진 커밋에서 &lt;code&gt;parent&lt;/code&gt; 링크를 따라 도달 할 수있는 커밋을 나열 하지만 앞에 &lt;code&gt;^&lt;/code&gt; 가 있는 커밋은 제외 합니다. 출력은 기본적으로 역순으로 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="adfacb775267bd93896cdbdf525c103ac26c16d4" translate="yes" xml:space="preserve">
          <source>List details of each worktree. The main worktree is listed first, followed by each of the linked worktrees. The output details include if the worktree is bare, the revision currently checked out, and the branch currently checked out (or &lt;code&gt;detached HEAD&lt;/code&gt; if none).</source>
          <target state="translated">각 작업 트리의 세부 사항을 나열하십시오. 기본 작업 트리가 먼저 나열되고 연결된 각 작업 트리가 나열됩니다. 출력 세부 사항에는 작업 트리가없는 경우, 현재 체크 아웃 한 개정 및 현재 체크 아웃 된 분기 (또는 없는 경우 &lt;code&gt;detached HEAD&lt;/code&gt; )가 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="1481dab663abae987b5437270fc0152b6258984f" translate="yes" xml:space="preserve">
          <source>List of Git base URLs. These URLs are used to generate URLs describing from where to fetch a project, which are shown on project summary page. The full fetch URL is &quot;&lt;code&gt;$git_base_url/$project&lt;/code&gt;&quot;, for each element of this list. You can set up multiple base URLs (for example one for &lt;code&gt;git://&lt;/code&gt; protocol, and one for &lt;code&gt;http://&lt;/code&gt; protocol).</source>
          <target state="translated">Git 기본 URL 목록. 이 URL은 프로젝트 요약 페이지에 표시되는 프로젝트를 가져올 위치를 설명하는 URL을 생성하는 데 사용됩니다. 전체 가져 오기 URL 은이 목록의 각 요소에 대해 &quot; &lt;code&gt;$git_base_url/$project&lt;/code&gt; &quot;입니다. 여러 개의 기본 URL을 설정할 수 있습니다 (예 &lt;code&gt;git://&lt;/code&gt; 프로토콜 용 URL 및 &lt;code&gt;http://&lt;/code&gt; 프로토콜 용 URL ).</target>
        </trans-unit>
        <trans-unit id="e9453e698a4a15232ec2c038afd4c298aede850c" translate="yes" xml:space="preserve">
          <source>List of URIs of stylesheets (relative to the base URI of a page). You might specify more than one stylesheet, for example to use &quot;gitweb.css&quot; as base with site specific modifications in a separate stylesheet to make it easier to upgrade gitweb. For example, you can add a &lt;code&gt;site&lt;/code&gt; stylesheet by putting</source>
          <target state="translated">스타일 시트의 URI 목록 (페이지의 기본 URI에 상대적). 예를 들어 gitweb을 쉽게 업그레이드 할 수 있도록 별도의 스타일 시트에서 사이트 특정 수정 사항이있는 &quot;gitweb.css&quot;를 기본으로 사용하도록 둘 이상의 스타일 시트를 지정할 수 있습니다. 예를 들어 &lt;code&gt;site&lt;/code&gt; 스타일 시트를 추가하여</target>
        </trans-unit>
        <trans-unit id="d9ab3387c39e123d7aac2edb253dcdba7080f753" translate="yes" xml:space="preserve">
          <source>List of additional directories under &quot;refs&quot; which are going to be used as branch refs. For example if you have a gerrit setup where all branches under refs/heads/ are official, push-after-review ones and branches under refs/sandbox/, refs/wip and refs/other are user ones where permissions are much wider, then you might want to set this variable as follows:</source>
          <target state="translated">분기 참조로 사용될 &quot;refs&quot;아래의 추가 디렉토리 목록 예를 들어 refs / heads / 아래의 모든 브랜치가 공식 인 gerrit 설정을 사용하는 경우 refs / sandbox /, refs / wip 및 refs / other 아래의 브랜치가 검토 후 푸시 및 refs / other는 권한이 훨씬 넓은 사용자입니다. 이 변수를 다음과 같이 설정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c919f43c88ec5761218ece7f29ac150fc5c1298f" translate="yes" xml:space="preserve">
          <source>List of branches to be imported when branch detection is enabled. Each entry should be a pair of branch names separated by a colon (:). This example declares that both branchA and branchB were created from main:</source>
          <target state="translated">분기 감지가 활성화 될 때 가져올 분기 목록입니다. 각 항목은 콜론 (:)으로 구분 된 분기 이름 쌍이어야합니다. 이 예제는 branchA와 branchB가 모두 main에서 생성되었음을 선언합니다.</target>
        </trans-unit>
        <trans-unit id="3d6057539fc43b4e5580b21aa940b705e61341be" translate="yes" xml:space="preserve">
          <source>List of p4 labels to ignore. This is built automatically as unimportable labels are discovered.</source>
          <target state="translated">무시할 p4 레이블 목록입니다. 가져올 수없는 레이블이 발견되면 자동으로 작성됩니다.</target>
        </trans-unit>
        <trans-unit id="ed979d0137e2b09484f09056901ac3efce874117" translate="yes" xml:space="preserve">
          <source>List only commits on the respective side of a symmetric difference, i.e. only those which would be marked &lt;code&gt;&amp;lt;&lt;/code&gt; resp. &lt;code&gt;&amp;gt;&lt;/code&gt; by &lt;code&gt;--left-right&lt;/code&gt;.</source>
          <target state="translated">List는 대칭 적 차이의 각면, 즉 &lt;code&gt;&amp;lt;&lt;/code&gt; resp 로 표시된 것만 커밋 합니다. &lt;code&gt;&amp;gt;&lt;/code&gt; by &lt;code&gt;--left-right&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="db38d2130aa4774e0a5e01e813cbe87b286b5c58" translate="yes" xml:space="preserve">
          <source>List only filenames (instead of the &quot;long&quot; output), one per line.</source>
          <target state="translated">한 줄에 하나씩 &quot;긴&quot;출력 대신 파일 이름 만 나열하십시오.</target>
        </trans-unit>
        <trans-unit id="ca0ba00456e1892ce61ce3c77aa65cb5194d4e6c" translate="yes" xml:space="preserve">
          <source>List or delete (if used with -d) the remote-tracking branches. Combine with &lt;code&gt;--list&lt;/code&gt; to match the optional pattern(s).</source>
          <target state="translated">원격 추적 분기를 나열하거나 삭제합니다 (-d와 함께 사용하는 경우). &lt;code&gt;--list&lt;/code&gt; 와 결합 하여 선택적 패턴을 일치시킵니다.</target>
        </trans-unit>
        <trans-unit id="22eb51b821276ed4742fd46da8d914f3eb506ca1" translate="yes" xml:space="preserve">
          <source>List output format</source>
          <target state="translated">리스트 출력 형식</target>
        </trans-unit>
        <trans-unit id="961866b18d2006e9e2f1c57af615530c0dcb0176" translate="yes" xml:space="preserve">
          <source>List references in a local repository</source>
          <target state="translated">로컬 저장소의 참조 목록</target>
        </trans-unit>
        <trans-unit id="7a309b311eeb5429dbbc4c270383e0c9240ea7dd" translate="yes" xml:space="preserve">
          <source>List references in a remote repository</source>
          <target state="translated">원격 저장소에서 참조 목록</target>
        </trans-unit>
        <trans-unit id="c3c4b04779710ca49a121ec3b626bb207fe0cc86" translate="yes" xml:space="preserve">
          <source>List replace refs for objects that match the given pattern (or all if no pattern is given). Typing &quot;git replace&quot; without arguments, also lists all replace refs.</source>
          <target state="translated">주어진 패턴과 일치하는 (또는 패턴이 제공되지 않은 경우 모두) 오브젝트의 대체 참조를 나열합니다. 인수없이 &quot;git replace&quot;를 입력하면 모든 교체 참조가 나열됩니다.</target>
        </trans-unit>
        <trans-unit id="dd864736379915e26071e39557a37c9a699c5cd9" translate="yes" xml:space="preserve">
          <source>List some tags in a table with unequal column widths:</source>
          <target state="translated">열 너비가 다른 테이블에 일부 태그를 나열하십시오.</target>
        </trans-unit>
        <trans-unit id="c3a7e0023c585da8fc00add926f4e7fe3e4bed2d" translate="yes" xml:space="preserve">
          <source>List tags. With optional &lt;code&gt;&amp;lt;pattern&amp;gt;...&lt;/code&gt;, e.g. &lt;code&gt;git tag --list
'v-*'&lt;/code&gt;, list only the tags that match the pattern(s).</source>
          <target state="translated">태그를 나열하십시오. 선택적 &lt;code&gt;&amp;lt;pattern&amp;gt;...&lt;/code&gt; (예 : &lt;code&gt;git tag --list 'v-*'&lt;/code&gt; )을 사용하면 패턴과 일치하는 태그 만 나열하십시오.</target>
        </trans-unit>
        <trans-unit id="42f93b25d56793afc3463e924a37b81b3e45f73d" translate="yes" xml:space="preserve">
          <source>List the GIT_* environment variables that are local to the repository (e.g. GIT_DIR or GIT_WORK_TREE, but not GIT_EDITOR). Only the names of the variables are listed, not their value, even if they are set.</source>
          <target state="translated">저장소에 로컬 인 GIT_ * 환경 변수를 나열하십시오 (예 : GIT_DIR 또는 GIT_WORK_TREE이지만 GIT_EDITOR는 아님). 변수 이름이 설정되어 있어도 값이 아닌 변수 이름 만 나열됩니다.</target>
        </trans-unit>
        <trans-unit id="dc410162c15e0c2fc959648b2d515436ff66231c" translate="yes" xml:space="preserve">
          <source>List the contents of a tree object</source>
          <target state="translated">트리 객체의 내용을 나열합니다</target>
        </trans-unit>
        <trans-unit id="c77a61ab930b102983b7633429f2e1c89c8a648a" translate="yes" xml:space="preserve">
          <source>List the notes object for a given object. If no object is given, show a list of all note objects and the objects they annotate (in the format &quot;&amp;lt;note object&amp;gt; &amp;lt;annotated object&amp;gt;&quot;). This is the default subcommand if no subcommand is given.</source>
          <target state="translated">주어진 객체에 대한 노트 객체를 나열합니다. 개체가 제공되지 않은 경우 모든 메모 개체 및 메모를 추가 한 개체 목록 ( &quot;&amp;lt;note object&amp;gt; &amp;lt;annotated object&amp;gt;&quot;형식으로 표시)을 표시하십시오. 부속 명령이없는 경우 이것이 디폴트 부속 명령입니다.</target>
        </trans-unit>
        <trans-unit id="160440cac4234691b237108179766c8ac388a3dd" translate="yes" xml:space="preserve">
          <source>List the stash entries that you currently have. Each &lt;code&gt;stash entry&lt;/code&gt; is listed with its name (e.g. &lt;code&gt;stash@{0}&lt;/code&gt; is the latest entry, &lt;code&gt;stash@{1}&lt;/code&gt; is the one before, etc.), the name of the branch that was current when the entry was made, and a short description of the commit the entry was based on.</source>
          <target state="translated">현재 가지고있는 숨김 항목을 나열하십시오. 각 &lt;code&gt;stash entry&lt;/code&gt; 은 이름과 함께 나열됩니다 (예 : &lt;code&gt;stash@{0}&lt;/code&gt; 은 최신 항목, &lt;code&gt;stash@{1}&lt;/code&gt; 은 이전 항목 등), 항목을 작성할 당시의 현재 지점 이름 및 항목이 기반으로 한 커밋에 대한 간단한 설명.</target>
        </trans-unit>
        <trans-unit id="0928a18c981cee8dd1bbd962ad11b79b09b49f73" translate="yes" xml:space="preserve">
          <source>List, create, or delete branches</source>
          <target state="translated">분기 나열, 작성 또는 삭제</target>
        </trans-unit>
        <trans-unit id="7d888e358c6ef40ec2a0a8a674979b45cd6d1cf4" translate="yes" xml:space="preserve">
          <source>Listed below are options that control the formatting of diff output. Some of them are specific to &lt;a href=&quot;git-rev-list&quot;&gt;git-rev-list[1]&lt;/a&gt;, however other diff options may be given. See &lt;a href=&quot;git-diff-files&quot;&gt;git-diff-files[1]&lt;/a&gt; for more options.</source>
          <target state="translated">아래는 diff 출력의 형식을 제어하는 ​​옵션입니다. 그중 일부는 &lt;a href=&quot;git-rev-list&quot;&gt;git-rev-list [1]&lt;/a&gt; 에만 적용 되지만 다른 diff 옵션이 제공 될 수 있습니다. 더 많은 옵션 은 &lt;a href=&quot;git-diff-files&quot;&gt;git-diff-files [1]&lt;/a&gt; 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="3248fa00aea630b8bbaf0b4709f9f26882639bdc" translate="yes" xml:space="preserve">
          <source>Listen on a specific IP address or hostname. IP addresses can be either an IPv4 address or an IPv6 address if supported. If IPv6 is not supported, then --listen=hostname is also not supported and --listen must be given an IPv4 address. Can be given more than once. Incompatible with &lt;code&gt;--inetd&lt;/code&gt; option.</source>
          <target state="translated">특정 IP 주소 또는 호스트 이름을 듣습니다. 지원되는 경우 IP 주소는 IPv4 주소 또는 IPv6 주소 일 수 있습니다. IPv6이 지원되지 않으면 --listen = hostname도 지원되지 않으며 --listen에 IPv4 주소가 제공되어야합니다. 두 번 이상 제공 될 수 있습니다. &lt;code&gt;--inetd&lt;/code&gt; 옵션 과 호환되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="4f53ff7586b49256325ec58801bfe143f18e21e3" translate="yes" xml:space="preserve">
          <source>Listen on an alternative port. Incompatible with &lt;code&gt;--inetd&lt;/code&gt; option.</source>
          <target state="translated">대체 포트에서 청취하십시오. &lt;code&gt;--inetd&lt;/code&gt; 옵션 과 호환되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="3e35805a9773260286dfbc09d02caaf5994dc0ce" translate="yes" xml:space="preserve">
          <source>Listing a single attribute:</source>
          <target state="translated">단일 속성 나열 :</target>
        </trans-unit>
        <trans-unit id="69751d90f1fec1736a7673316bf3b759c5271c7d" translate="yes" xml:space="preserve">
          <source>Listing all attributes for a file:</source>
          <target state="translated">파일의 모든 속성 나열 :</target>
        </trans-unit>
        <trans-unit id="e231fe1cc3d8844bfddb76169e22179c8767ce9e" translate="yes" xml:space="preserve">
          <source>Listing an attribute for multiple files:</source>
          <target state="translated">여러 파일에 대한 속성 나열 :</target>
        </trans-unit>
        <trans-unit id="d1d9eec0e1bd38bd76cb67feb04b08b5d78c11bd" translate="yes" xml:space="preserve">
          <source>Listing branches from a specific remote</source>
          <target state="translated">특정 리모콘에서 분기 나열</target>
        </trans-unit>
        <trans-unit id="14162152c45d26fb9527c9f0660bef886294e5bf" translate="yes" xml:space="preserve">
          <source>Listing multiple attributes for a file:</source>
          <target state="translated">파일에 대한 여러 속성 나열 :</target>
        </trans-unit>
        <trans-unit id="540f872616da666be00fd2f7f78a7ae984c11b9a" translate="yes" xml:space="preserve">
          <source>Lists all local or all remote-tracking branches in given repository.</source>
          <target state="translated">지정된 저장소에있는 모든 로컬 또는 모든 원격 추적 분기를 나열합니다.</target>
        </trans-unit>
        <trans-unit id="b5500d120a9a13cb3af42448653e0cde10752de4" translate="yes" xml:space="preserve">
          <source>Lists commit objects in reverse chronological order</source>
          <target state="translated">커밋 객체를 시간순으로 나열</target>
        </trans-unit>
        <trans-unit id="6385084e9b2c3e78376900259ba28376e3a28618" translate="yes" xml:space="preserve">
          <source>Lists the available Git repositories. This is the default command if no repository is specified in the URL.</source>
          <target state="translated">사용 가능한 Git 리포지토리를 나열합니다. URL에 저장소가 지정되지 않은 경우 이것이 기본 명령입니다.</target>
        </trans-unit>
        <trans-unit id="9438685d87876d6c82356bf9b864c1c6136c1266" translate="yes" xml:space="preserve">
          <source>Lists the capabilities of the helper, one per line, ending with a blank line. Each capability may be preceded with &lt;code&gt;*&lt;/code&gt;, which marks them mandatory for Git versions using the remote helper to understand. Any unknown mandatory capability is a fatal error.</source>
          <target state="translated">빈 줄로 끝나는 도우미의 기능을 한 줄에 하나씩 나열합니다. 각 기능 앞에는 &lt;code&gt;*&lt;/code&gt; 가있을 수 있으며 , 원격 헬퍼를 사용하여 Git 버전에 필수임을 표시합니다. 알려지지 않은 필수 기능은 치명적인 오류입니다.</target>
        </trans-unit>
        <trans-unit id="8c594a1bf48edecf6065890a7f89cc7fa404495f" translate="yes" xml:space="preserve">
          <source>Lists the contents of a given tree object, like what &quot;/bin/ls -a&quot; does in the current working directory. Note that:</source>
          <target state="translated">현재 작업 디렉토리에서 &quot;/ bin / ls -a&quot;가 수행하는 것과 같이 지정된 트리 오브젝트의 내용을 나열합니다. 참고 :</target>
        </trans-unit>
        <trans-unit id="9cc5eb61d77cd46774cb42ac22301b7d413d58c5" translate="yes" xml:space="preserve">
          <source>Lists the properties stored in the Subversion repository about a given file or directory. Use -r/--revision to refer to a specific Subversion revision.</source>
          <target state="translated">지정된 파일 또는 디렉토리에 대한 Subversion 저장소에 저장된 특성을 나열합니다. 특정 Subversion 개정판을 참조하려면 -r /-revision을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="11c5aa2ca7f7c3e091142bb69f047bf1ca338d7f" translate="yes" xml:space="preserve">
          <source>Lists the references defined in the bundle. If followed by a list of references, only references matching those given are printed out.</source>
          <target state="translated">번들에 정의 된 참조를 나열합니다. 그 뒤에 참조 목록이 있으면 주어진 참조와 일치하는 참조 만 인쇄됩니다.</target>
        </trans-unit>
        <trans-unit id="cb27642bee7df675e576f1467eabd36ebf236a0c" translate="yes" xml:space="preserve">
          <source>Lists the refs, one per line, in the format &quot;&amp;lt;value&amp;gt; &amp;lt;name&amp;gt; [&amp;lt;attr&amp;gt; &amp;hellip;​]&quot;. The value may be a hex sha1 hash, &quot;@&amp;lt;dest&amp;gt;&quot; for a symref, or &quot;?&quot; to indicate that the helper could not get the value of the ref. A space-separated list of attributes follows the name; unrecognized attributes are ignored. The list ends with a blank line.</source>
          <target state="translated">&quot;&amp;lt;값&amp;gt; &amp;lt;이름&amp;gt; [&amp;lt;attr&amp;gt;&amp;hellip;]&quot;형식으로 한 줄에 하나씩 참조를 나열합니다. 값은 16 진 sha1 해시, &quot;@ &amp;lt;dest&amp;gt;&quot;, 또는 symref 또는 &quot;?&quot;일 수 있습니다. 도우미가 심판의 가치를 얻을 수 없음을 나타냅니다. 공백으로 구분 된 속성 목록은 이름 뒤에옵니다. 인식 할 수없는 속성은 무시됩니다. 목록은 빈 줄로 끝납니다.</target>
        </trans-unit>
        <trans-unit id="8cf165480241df10f979b6b7157595e5407c755f" translate="yes" xml:space="preserve">
          <source>Literal percent sign.</source>
          <target state="translated">리터럴 퍼센트 부호.</target>
        </trans-unit>
        <trans-unit id="c9b025ce8a30fb92786ef26cc44501e09df585de" translate="yes" xml:space="preserve">
          <source>Literal space in command or argument.</source>
          <target state="translated">명령 또는 인수의 리터럴 공간.</target>
        </trans-unit>
        <trans-unit id="3e47004eca06847317d03882ea01098236feca24" translate="yes" xml:space="preserve">
          <source>Loads annotations as described above and automatically scrolls the view to center on line &lt;code&gt;100&lt;/code&gt;.</source>
          <target state="translated">위에서 설명한대로 주석을로드하고 선 &lt;code&gt;100&lt;/code&gt; 을 중심으로보기를 자동으로 스크롤합니다 .</target>
        </trans-unit>
        <trans-unit id="f638d2718f9a7fa3228a4c22ea27ab0cb7ce0ed8" translate="yes" xml:space="preserve">
          <source>Local directory</source>
          <target state="translated">로컬 디렉토리</target>
        </trans-unit>
        <trans-unit id="83cd95e5e26d810cf34fa10fd02190221225a995" translate="yes" xml:space="preserve">
          <source>Locate a good region of the object graph in a damaged repository</source>
          <target state="translated">손상된 저장소에서 오브젝트 그래프의 올바른 영역을 찾으십시오.</target>
        </trans-unit>
        <trans-unit id="c6b89ef8cfe5b4e0d5f71a9018f7c23272508e1d" translate="yes" xml:space="preserve">
          <source>Location of repositories</source>
          <target state="translated">리포지토리의 위치</target>
        </trans-unit>
        <trans-unit id="a8464429b3dd8a54d4c3a8d0aaf7809c3b93d077" translate="yes" xml:space="preserve">
          <source>Locations of Marks Files</source>
          <target state="translated">마크 파일의 위치</target>
        </trans-unit>
        <trans-unit id="747742f75a08750185466d70d49a66f609262970" translate="yes" xml:space="preserve">
          <source>Locations of the common system-wide configuration file, the fallback system-wide configuration file and the per-instance configuration file are defined at compile time using build-time Makefile configuration variables, respectively &lt;code&gt;GITWEB_CONFIG_COMMON&lt;/code&gt;, &lt;code&gt;GITWEB_CONFIG_SYSTEM&lt;/code&gt; and &lt;code&gt;GITWEB_CONFIG&lt;/code&gt;.</source>
          <target state="translated">공통 시스템 전체 구성 파일, 대체 시스템 전체 구성 파일 및 인스턴스 별 구성 파일의 위치는 각각 빌드 타임 Makefile 구성 변수 &lt;code&gt;GITWEB_CONFIG_COMMON&lt;/code&gt; , &lt;code&gt;GITWEB_CONFIG_SYSTEM&lt;/code&gt; 및 &lt;code&gt;GITWEB_CONFIG&lt;/code&gt; 를 사용하여 컴파일 타임에 정의됩니다 .</target>
        </trans-unit>
        <trans-unit id="ff8e7c6671e74ff8d9e440b7a275b6b3047a92bf" translate="yes" xml:space="preserve">
          <source>Log details about the incoming connections and requested files.</source>
          <target state="translated">들어오는 연결 및 요청 된 파일에 대한 세부 정보를 기록합니다.</target>
        </trans-unit>
        <trans-unit id="c1bbca864796e717c6563546ee8bb0273fbae9ac" translate="yes" xml:space="preserve">
          <source>Logging updates</source>
          <target state="translated">업데이트 로깅</target>
        </trans-unit>
        <trans-unit id="e76f4d6fb1700b21a7cf7fc7a62d7a34c7014ae2" translate="yes" xml:space="preserve">
          <source>Long Running Filter Process</source>
          <target state="translated">장기 필터 프로세스</target>
        </trans-unit>
        <trans-unit id="555712d9829e6328a9b7d5ec70facbda745fb9b3" translate="yes" xml:space="preserve">
          <source>Look at the diffs from each branch. &lt;code&gt;git log --merge -p &amp;lt;path&amp;gt;&lt;/code&gt; will show diffs first for the &lt;code&gt;HEAD&lt;/code&gt; version and then the &lt;code&gt;MERGE_HEAD&lt;/code&gt; version.</source>
          <target state="translated">각 지점의 diff를보십시오. &lt;code&gt;git log --merge -p &amp;lt;path&amp;gt;&lt;/code&gt; 는 &lt;code&gt;HEAD&lt;/code&gt; 버전에 대한 diff를 먼저 표시 한 다음 &lt;code&gt;MERGE_HEAD&lt;/code&gt; 버전을 표시합니다.</target>
        </trans-unit>
        <trans-unit id="a326ab540e0d9536d53dbc94d57cb0c25e24d9a1" translate="yes" xml:space="preserve">
          <source>Look at the diffs. &lt;code&gt;git diff&lt;/code&gt; will show a three-way diff, highlighting changes from both the &lt;code&gt;HEAD&lt;/code&gt; and &lt;code&gt;MERGE_HEAD&lt;/code&gt; versions.</source>
          <target state="translated">차이점을보세요. &lt;code&gt;git diff&lt;/code&gt; 는 &lt;code&gt;HEAD&lt;/code&gt; 및 &lt;code&gt;MERGE_HEAD&lt;/code&gt; 버전 의 변경 사항을 강조 표시하는 3 방향 diff를 표시 합니다.</target>
        </trans-unit>
        <trans-unit id="f8c63749f2ae2fa24fa7ef48c360ef59f66a1f48" translate="yes" xml:space="preserve">
          <source>Look at the originals. &lt;code&gt;git show :1:filename&lt;/code&gt; shows the common ancestor, &lt;code&gt;git show :2:filename&lt;/code&gt; shows the &lt;code&gt;HEAD&lt;/code&gt; version, and &lt;code&gt;git show :3:filename&lt;/code&gt; shows the &lt;code&gt;MERGE_HEAD&lt;/code&gt; version.</source>
          <target state="translated">원본을보십시오. &lt;code&gt;git show :1:filename&lt;/code&gt; 은 공통 조상을 나타내고 &lt;code&gt;git show :2:filename&lt;/code&gt; 은 &lt;code&gt;HEAD&lt;/code&gt; 버전을, &lt;code&gt;git show :3:filename&lt;/code&gt; 은 &lt;code&gt;MERGE_HEAD&lt;/code&gt; 버전을 나타냅니다 .</target>
        </trans-unit>
        <trans-unit id="6a423d84e076a3272fdc685127299ea63ea761ac" translate="yes" xml:space="preserve">
          <source>Look for a fix instead of a regression in the code</source>
          <target state="translated">코드에서 회귀 대신 수정 사항을 찾으십시오.</target>
        </trans-unit>
        <trans-unit id="4ab23275475ac09a44d78ac861e7af3c95082023" translate="yes" xml:space="preserve">
          <source>Look for attributes in .gitattributes files in the working tree as well (see &lt;a href=&quot;#ATTRIBUTES&quot;&gt;ATTRIBUTES&lt;/a&gt;).</source>
          <target state="translated">작업 트리에서 .gitattributes 파일에서도 속성을 찾으십시오 ( &lt;a href=&quot;#ATTRIBUTES&quot;&gt;ATTRIBUTES&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="5e41023ffb67a9b868c13a5cdc624ea0d794092d" translate="yes" xml:space="preserve">
          <source>Look for differences that change the number of occurrences of the specified object. Similar to &lt;code&gt;-S&lt;/code&gt;, just the argument is different in that it doesn&amp;rsquo;t search for a specific string but for a specific object id.</source>
          <target state="translated">지정된 오브젝트의 발생 횟수를 변경하는 차이점을 찾으십시오. &lt;code&gt;-S&lt;/code&gt; 와 유사하게 , 특정 문자열을 검색하지 않고 특정 객체 ID를 검색한다는 점에서 인수 만 다릅니다.</target>
        </trans-unit>
        <trans-unit id="a838d092d782360d96378f1e4ff8a0b5fffd060f" translate="yes" xml:space="preserve">
          <source>Look for differences that change the number of occurrences of the specified string (i.e. addition/deletion) in a file. Intended for the scripter&amp;rsquo;s use.</source>
          <target state="translated">파일에서 지정된 문자열 (예 : 추가 / 삭제)의 발생 횟수를 변경하는 차이점을 찾으십시오. 스크립터의 사용을 목적으로합니다.</target>
        </trans-unit>
        <trans-unit id="b8df136f2384d637ef409fc2baddd2b9dce73992" translate="yes" xml:space="preserve">
          <source>Look for differences whose patch text contains added/removed lines that match &amp;lt;regex&amp;gt;.</source>
          <target state="translated">패치 텍스트에 &amp;lt;regex&amp;gt;와 일치하는 추가 / 제거 된 행이 포함 된 차이점을 찾으십시오.</target>
        </trans-unit>
        <trans-unit id="4cef9adbc5be0f5f01b5c2739071b69091cb4a32" translate="yes" xml:space="preserve">
          <source>Look for specified patterns in the tracked files in the work tree, blobs registered in the index file, or blobs in given tree objects. Patterns are lists of one or more search expressions separated by newline characters. An empty string as search expression matches all lines.</source>
          <target state="translated">작업 트리의 추적 파일, 인덱스 파일에 등록 된 얼룩 또는 지정된 트리 개체의 얼룩에서 지정된 패턴을 찾으십시오. 패턴은 개행 문자로 구분 된 하나 이상의 검색 표현식 목록입니다. 검색 표현식으로 빈 문자열은 모든 행과 일치합니다.</target>
        </trans-unit>
        <trans-unit id="07448c29252081320f670b2265de0e9cba50a292" translate="yes" xml:space="preserve">
          <source>Look up layout mode using configuration variable column.&amp;lt;name&amp;gt; and column.ui.</source>
          <target state="translated">구성 변수 column. &amp;lt;name&amp;gt; 및 column.ui를 사용하여 레이아웃 모드를 찾으십시오.</target>
        </trans-unit>
        <trans-unit id="b62eefc27e1aeffa75b2d4761547bc2b8bc497bd" translate="yes" xml:space="preserve">
          <source>Looks at the current index and checks to see if merges or updates are needed by checking stat() information.</source>
          <target state="translated">현재 인덱스를보고 stat () 정보를 확인하여 병합 또는 업데이트가 필요한지 확인합니다.</target>
        </trans-unit>
        <trans-unit id="4b7876b6a8ad520457ce71bfe745148e3c567edb" translate="yes" xml:space="preserve">
          <source>Looks for &lt;code&gt;solution&lt;/code&gt;, excluding files in &lt;code&gt;Documentation&lt;/code&gt;.</source>
          <target state="translated">를 검색 &lt;code&gt;solution&lt;/code&gt; 의 파일 제외, &lt;code&gt;Documentation&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2f3233017974f60253fdf12d744b51a535433787" translate="yes" xml:space="preserve">
          <source>Looks for &lt;code&gt;time_t&lt;/code&gt; in all tracked .c and .h files in the working directory and its subdirectories.</source>
          <target state="translated">찾습니다 &lt;code&gt;time_t&lt;/code&gt; 작업 디렉토리 및 하위 디렉토리의 모든 추적 된이 .c 및 .H 파일.</target>
        </trans-unit>
        <trans-unit id="558837c842e106c2ed3e4e9a131c3a7442c122b9" translate="yes" xml:space="preserve">
          <source>Looks for a line that has &lt;code&gt;#define&lt;/code&gt; and either &lt;code&gt;MAX_PATH&lt;/code&gt; or &lt;code&gt;PATH_MAX&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;#define&lt;/code&gt; 과 &lt;code&gt;MAX_PATH&lt;/code&gt; 또는 &lt;code&gt;PATH_MAX&lt;/code&gt; 가있는 줄을 찾습니다 .</target>
        </trans-unit>
        <trans-unit id="432adcaf916374b14ccc5f4491d7cd8a1e3d3e44" translate="yes" xml:space="preserve">
          <source>Looks for a line that has &lt;code&gt;NODE&lt;/code&gt; or &lt;code&gt;Unexpected&lt;/code&gt; in files that have lines that match both.</source>
          <target state="translated">둘 다 일치하는 줄이있는 파일에서 &lt;code&gt;NODE&lt;/code&gt; 또는 &lt;code&gt;Unexpected&lt;/code&gt; 줄이있는 줄을 찾습니다.</target>
        </trans-unit>
        <trans-unit id="b11d66d44e8db145700e0edb6375620b652f740a" translate="yes" xml:space="preserve">
          <source>Low-level commands (plumbing)</source>
          <target state="translated">저수준 명령 (배관)</target>
        </trans-unit>
        <trans-unit id="0ffc3dae4e51a700bf1ca804b93845e0102810f8" translate="yes" xml:space="preserve">
          <source>Low-level git operations</source>
          <target state="translated">저수준 git 연산</target>
        </trans-unit>
        <trans-unit id="c63ae6dd4fc9f9dda66970e827d13f7c73fe841c" translate="yes" xml:space="preserve">
          <source>M</source>
          <target state="translated">M</target>
        </trans-unit>
        <trans-unit id="5d487fc78e43a0306fd5f718aec828744ee6e786" translate="yes" xml:space="preserve">
          <source>M: modification of the contents or mode of a file</source>
          <target state="translated">M : 파일 내용 또는 모드 수정</target>
        </trans-unit>
        <trans-unit id="0f48f030cf13414eeafe91359c3c62bf97314f35" translate="yes" xml:space="preserve">
          <source>Magic Options</source>
          <target state="translated">매직 옵션</target>
        </trans-unit>
        <trans-unit id="7d828d176880cf3ec5ec8010d93f54010eebda7b" translate="yes" xml:space="preserve">
          <source>Maildir splitting relies upon filenames being sorted to output patches in the correct order.</source>
          <target state="translated">Maildir 분할은 올바른 순서로 패치를 출력하기 위해 파일 이름을 정렬하는 데 의존합니다.</target>
        </trans-unit>
        <trans-unit id="57a6217babf3a984d54a72505b0f2a4f3e1be542" translate="yes" xml:space="preserve">
          <source>Main porcelain commands</source>
          <target state="translated">주요 도자기 명령</target>
        </trans-unit>
        <trans-unit id="46b62a0f964fab2f018eee342e7b4db44adbc685" translate="yes" xml:space="preserve">
          <source>Maintaining topic branches for a Linux subsystem maintainer</source>
          <target state="translated">Linux 서브 시스템 관리자의 토픽 브랜치 유지</target>
        </trans-unit>
        <trans-unit id="52f0f393e457cb924c234a7254a4daec3a0cbf32" translate="yes" xml:space="preserve">
          <source>Maintenance branch management after a feature release</source>
          <target state="translated">기능 릴리스 후 유지 관리 지점 관리</target>
        </trans-unit>
        <trans-unit id="319909b05c9210e6ff8b8a19f69dc9189ee2cca4" translate="yes" xml:space="preserve">
          <source>Make &lt;code&gt;git gc --auto&lt;/code&gt; return immediately and run in background if the system supports it. Default is true.</source>
          <target state="translated">확인 &lt;code&gt;git gc --auto&lt;/code&gt; 즉시 실행 백그라운드에서 시스템 지원이 경우 수익을. 기본값은 true입니다.</target>
        </trans-unit>
        <trans-unit id="77c42361d50b9bdea29b692160b9eae95cceb52e" translate="yes" xml:space="preserve">
          <source>Make &lt;code&gt;git show-ref&lt;/code&gt; act as a filter that reads refs from stdin of the form &quot;&lt;code&gt;^(?:&amp;lt;anything&amp;gt;\s)?&amp;lt;refname&amp;gt;(?:\^{})?$&lt;/code&gt;&quot; and performs the following actions on each: (1) strip &quot;^{}&quot; at the end of line if any; (2) ignore if pattern is provided and does not head-match refname; (3) warn if refname is not a well-formed refname and skip; (4) ignore if refname is a ref that exists in the local repository; (5) otherwise output the line.</source>
          <target state="translated">확인 &lt;code&gt;git show-ref&lt;/code&gt; 형태의 stdin에서 심판을 읽는 필터의 역할을 &quot; &lt;code&gt;^(?:&amp;lt;anything&amp;gt;\s)?&amp;lt;refname&amp;gt;(?:\^{})?$&lt;/code&gt; &quot;각과 수행 다음 작업 : (1) 줄 끝에 &quot;^ {}&quot;를 제거하십시오 (있는 경우). (2) 패턴이 제공되고 refname과 일치하지 않는 경우 무시합니다. (3) refname이 올바른 형식의 refname이 아닌 경우 경고하고 건너 뜁니다. (4) refname이 로컬 저장소에 존재하는 ref이면 무시하십시오. (5) 그렇지 않으면 라인을 출력하십시오.</target>
        </trans-unit>
        <trans-unit id="51befbcaeb5eba297db1a634b8802a7f0078cead" translate="yes" xml:space="preserve">
          <source>Make &lt;code&gt;git svn&lt;/code&gt; less verbose. Specify a second time to make it even less verbose.</source>
          <target state="translated">&lt;code&gt;git svn&lt;/code&gt; 을 덜 장황하게 만드십시오 . 덜 장황하게하려면 두 번째 시간을 지정하십시오.</target>
        </trans-unit>
        <trans-unit id="2da3bd3f8069e8e437af583aecc3a384c81edd34" translate="yes" xml:space="preserve">
          <source>Make a &lt;code&gt;bare&lt;/code&gt; Git repository. That is, instead of creating &lt;code&gt;&amp;lt;directory&amp;gt;&lt;/code&gt; and placing the administrative files in &lt;code&gt;&amp;lt;directory&amp;gt;/.git&lt;/code&gt;, make the &lt;code&gt;&amp;lt;directory&amp;gt;&lt;/code&gt; itself the &lt;code&gt;$GIT_DIR&lt;/code&gt;. This obviously implies the &lt;code&gt;--no-checkout&lt;/code&gt; because there is nowhere to check out the working tree. Also the branch heads at the remote are copied directly to corresponding local branch heads, without mapping them to &lt;code&gt;refs/remotes/origin/&lt;/code&gt;. When this option is used, neither remote-tracking branches nor the related configuration variables are created.</source>
          <target state="translated">&lt;code&gt;bare&lt;/code&gt; Git 리포지토리를 만듭니다 . 즉, &lt;code&gt;&amp;lt;directory&amp;gt;&lt;/code&gt; 를 작성 하고 관리 파일을 &lt;code&gt;&amp;lt;directory&amp;gt;/.git&lt;/code&gt; 에 배치하는 대신 &lt;code&gt;&amp;lt;directory&amp;gt;&lt;/code&gt; 자체를 &lt;code&gt;$GIT_DIR&lt;/code&gt; 만드십시오 . 이것은 작업 트리를 확인할 곳이 없기 때문에 분명히 &lt;code&gt;--no-checkout&lt;/code&gt; 을 의미합니다 . 또한 리모컨의 분기 헤드는 &lt;code&gt;refs/remotes/origin/&lt;/code&gt; 매핑하지 않고 해당 로컬 분기 헤드로 직접 복사됩니다 . 이 옵션을 사용하면 원격 추적 분기 나 관련 구성 변수가 만들어지지 않습니다.</target>
        </trans-unit>
        <trans-unit id="6ca024f41825508ff37398849dd7bbbd184e78e6" translate="yes" xml:space="preserve">
          <source>Make a GPG-signed tag, using the default e-mail address&amp;rsquo;s key. The default behavior of tag GPG-signing is controlled by &lt;code&gt;tag.gpgSign&lt;/code&gt; configuration variable if it exists, or disabled otherwise. See &lt;a href=&quot;git-config&quot;&gt;git-config[1]&lt;/a&gt;.</source>
          <target state="translated">기본 이메일 주소의 키를 사용하여 GPG 서명 태그를 만듭니다. 태그 GPG 서명의 기본 동작은 &lt;code&gt;tag.gpgSign&lt;/code&gt; 구성 변수가 있으면 제어 하거나 그렇지 않으면 비활성화합니다. &lt;a href=&quot;git-config&quot;&gt;git-config [1]을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="d5a6f6bd2dfbdab5f143e86ea9155fad4e43a30c" translate="yes" xml:space="preserve">
          <source>Make a GPG-signed tag, using the given key.</source>
          <target state="translated">주어진 키를 사용하여 GPG 서명 태그를 만듭니다.</target>
        </trans-unit>
        <trans-unit id="99f2296af5452e1eec1986dbc7a0151a5ba6b1fc" translate="yes" xml:space="preserve">
          <source>Make a commit by taking the updated working tree contents of the paths specified on the command line, disregarding any contents that have been staged for other paths. This is the default mode of operation of &lt;code&gt;git commit&lt;/code&gt; if any paths are given on the command line, in which case this option can be omitted. If this option is specified together with &lt;code&gt;--amend&lt;/code&gt;, then no paths need to be specified, which can be used to amend the last commit without committing changes that have already been staged. If used together with &lt;code&gt;--allow-empty&lt;/code&gt; paths are also not required, and an empty commit will be created.</source>
          <target state="translated">다른 경로에 대해 준비된 내용을 무시하고 명령 행에 지정된 경로의 업데이트 된 작업 트리 내용을 가져 와서 커밋하십시오. 명령 행에 경로가 지정된 경우 &lt;code&gt;git commit&lt;/code&gt; 의 기본 작동 모드입니다 .이 경우이 옵션을 생략 할 수 있습니다. 이 옵션을 &lt;code&gt;--amend&lt;/code&gt; 과 함께 지정하면 경로를 지정할 필요가 없으므로 이미 준비된 변경 사항을 커밋하지 않고 마지막 커밋을 수정하는 데 사용할 수 있습니다. &lt;code&gt;--allow-empty&lt;/code&gt; 경로 와 함께 사용 하면 빈 커밋이 생성됩니다.</target>
        </trans-unit>
        <trans-unit id="2e9bf6a1a9ac175346438fe9d4c19601601a0ebd" translate="yes" xml:space="preserve">
          <source>Make a list of the commits which are about to be rebased. Let the user edit that list before rebasing. This mode can also be used to split commits (see SPLITTING COMMITS below).</source>
          <target state="translated">리베이스 될 커밋 목록을 만듭니다. 리베이스하기 전에 사용자가 해당 목록을 편집하도록합니다. 이 모드는 커밋을 분할하는 데에도 사용할 수 있습니다 (아래의 커밋 분할 참조).</target>
        </trans-unit>
        <trans-unit id="f382849103310ffba0e3d31128dfababfd915957" translate="yes" xml:space="preserve">
          <source>Make a local clone that borrows from the current directory, without checking things out:</source>
          <target state="translated">확인하지 않고 현재 디렉토리에서 빌려 오는 로컬 복제본을 만듭니다.</target>
        </trans-unit>
        <trans-unit id="d7a3e91b3667d18f363db6d6cc32c0afec1ed1d5" translate="yes" xml:space="preserve">
          <source>Make a side branch for every topic (feature, bugfix, &amp;hellip;​). Fork it off at the oldest integration branch that you will eventually want to merge it into.</source>
          <target state="translated">모든 주제 (기능, 버그 수정, ...)에 대한 사이드 브랜치를 만듭니다. 가장 오래된 통합 브랜치에서 결국 통합하려는 경우이를 제거하십시오.</target>
        </trans-unit>
        <trans-unit id="89db797c5d89c53349b8d88ec549bb720f48d1f7" translate="yes" xml:space="preserve">
          <source>Make an unsigned, annotated tag object</source>
          <target state="translated">부호없는 주석이 달린 태그 객체 만들기</target>
        </trans-unit>
        <trans-unit id="f88ecf2f4eb0c5509c792cd2c61ea44a524baf96" translate="yes" xml:space="preserve">
          <source>Make corrections to working tree files.</source>
          <target state="translated">작업 트리 파일을 수정하십시오.</target>
        </trans-unit>
        <trans-unit id="79ee7beb56d7493ce335c85dd0a8333674bff17b" translate="yes" xml:space="preserve">
          <source>Make git-send-email less verbose. One line per email should be all that is output.</source>
          <target state="translated">git-send-email을 덜 장황하게 만드십시오. 이메일 당 한 줄만 출력됩니다.</target>
        </trans-unit>
        <trans-unit id="ff429cc18c1dac972928cb3da6e4d06bbfe2d8ec" translate="yes" xml:space="preserve">
          <source>Make one commit and return to the shell when it is complete. This command returns a non-zero exit code if the window was closed in any way other than by making a commit.</source>
          <target state="translated">하나의 커밋을 만들고 완료되면 셸로 돌아갑니다. 이 명령은 커밋을 수행하는 것 이외의 방법으로 창이 닫힌 경우 0이 아닌 종료 코드를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="31ca9c9bf3eab94aff99250728fe74f77977b844" translate="yes" xml:space="preserve">
          <source>Make sure Git knows who to blame:</source>
          <target state="translated">Git이 비난 할 사람을 알고 있는지 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="cf12b54cc8063982ae2c9b96588de4f236c9e743" translate="yes" xml:space="preserve">
          <source>Make sure all submodule commits used by the revisions to be pushed are available on a remote-tracking branch. If the value is &lt;code&gt;check&lt;/code&gt; then Git will verify that all submodule commits that changed in the revisions to be pushed are available on at least one remote of the submodule. If any commits are missing, the push will be aborted and exit with non-zero status. If the value is &lt;code&gt;on-demand&lt;/code&gt; then all submodules that changed in the revisions to be pushed will be pushed. If on-demand was not able to push all necessary revisions it will also be aborted and exit with non-zero status. If the value is &lt;code&gt;no&lt;/code&gt; then default behavior of ignoring submodules when pushing is retained. You may override this configuration at time of push by specifying &lt;code&gt;--recurse-submodules=check|on-demand|no&lt;/code&gt;.</source>
          <target state="translated">푸시 할 개정에 사용 된 모든 서브 모듈 커밋이 원격 추적 브랜치에서 사용 가능한지 확인하십시오. 값이 &lt;code&gt;check&lt;/code&gt; 되면 Git은 푸시 할 개정에서 변경된 모든 서브 모듈 커밋이 서브 모듈의 하나 이상의 리모트에서 사용 가능한지 검증합니다. 커밋이 누락되면 푸시가 중단되고 0이 아닌 상태로 종료됩니다. 값이 &lt;code&gt;on-demand&lt;/code&gt; 이면 푸시 될 개정에서 변경된 모든 서브 모듈이 푸시됩니다. 요청시 필요한 모든 수정 사항을 푸시 할 수없는 경우 중단되고 0이 아닌 상태로 종료됩니다. 값이 &lt;code&gt;no&lt;/code&gt; 밀어 넣을 때 하위 모듈을 무시하는 기본 동작이 유지됩니다. 푸시시이 구성을 재정 의하여 다음을 지정할 수 있습니다. &lt;code&gt;--recurse-submodules=check|on-demand|no&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="70b6629c434b51e7d9186d1fc6fe97c1a3725440" translate="yes" xml:space="preserve">
          <source>Make sure committers have a umask of at most 027, so that the directories they create are writable and searchable by other group members.</source>
          <target state="translated">커미터가 최대 027의 umask를 가지도록하여, 작성된 디렉토리가 다른 그룹 구성원이 쓰기 가능하고 검색 할 수 있도록하십시오.</target>
        </trans-unit>
        <trans-unit id="4b35196a3d616941ad0c8a125c3a9f25e1bdc376" translate="yes" xml:space="preserve">
          <source>Make sure this directory is available for others you want your changes to be pulled via the transport of your choice. Also you need to make sure that you have the &lt;code&gt;git-receive-pack&lt;/code&gt; program on the &lt;code&gt;$PATH&lt;/code&gt;.</source>
          <target state="translated">선택한 전송을 통해 변경 사항을 가져 오려는 다른 사용자가이 디렉토리를 사용할 수 있는지 확인하십시오. 또한 &lt;code&gt;$PATH&lt;/code&gt; 에 &lt;code&gt;git-receive-pack&lt;/code&gt; 프로그램 이 있는지 확인해야합니다 .</target>
        </trans-unit>
        <trans-unit id="6631b9ca24ae751d7ee25163002526a066325c25" translate="yes" xml:space="preserve">
          <source>Make the first mail (or all the mails with &lt;code&gt;--no-thread&lt;/code&gt;) appear as a reply to the given &amp;lt;message id&amp;gt;, which avoids breaking threads to provide a new patch series.</source>
          <target state="translated">첫 번째 메일 (또는 &lt;code&gt;--no-thread&lt;/code&gt; 가 있는 모든 메일 )이 지정된 &amp;lt;message id&amp;gt;에 대한 응답으로 나타나게하여 스레드를 끊어 새로운 패치 시리즈를 제공하지 않도록합니다.</target>
        </trans-unit>
        <trans-unit id="5a1ce0ecb5c94a2505e8bfd1950281f48170d98f" translate="yes" xml:space="preserve">
          <source>Make the first mail (or all the mails with &lt;code&gt;--no-thread&lt;/code&gt;) appear as a reply to the given Message-Id, which avoids breaking threads to provide a new patch series. The second and subsequent emails will be sent as replies according to the &lt;code&gt;--[no-]chain-reply-to&lt;/code&gt; setting.</source>
          <target state="translated">첫 번째 메일 (또는 &lt;code&gt;--no-thread&lt;/code&gt; 가 있는 모든 메일 )이 지정된 Message-Id에 대한 응답으로 나타나게하여 스레드를 끊어 새로운 패치 시리즈를 제공하지 않도록합니다. 두 번째 이후 이메일은 &lt;code&gt;--[no-]chain-reply-to&lt;/code&gt; 설정 에 따라 회신으로 전송됩니다 .</target>
        </trans-unit>
        <trans-unit id="b064d6e8766baf86355fa160624701d28d48e0eb" translate="yes" xml:space="preserve">
          <source>Make the program exit with codes similar to diff(1). That is, it exits with 1 if there were differences and 0 means no differences.</source>
          <target state="translated">diff (1)와 유사한 코드로 프로그램을 종료하십시오. 즉, 차이가 있으면 1로 종료하고 0은 차이가 없음을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="033698ff1d93839c9dc26bb7039e879974408d51" translate="yes" xml:space="preserve">
          <source>Make the repository group-writable, (and g+sx, since the git group may be not the primary group of all users). This is used to loosen the permissions of an otherwise safe umask(2) value. Note that the umask still applies to the other permission bits (e.g. if umask is &lt;code&gt;0022&lt;/code&gt;, using &lt;code&gt;group&lt;/code&gt; will not remove read privileges from other (non-group) users). See &lt;code&gt;0xxx&lt;/code&gt; for how to exactly specify the repository permissions.</source>
          <target state="translated">저장소를 그룹 쓰기 가능으로 설정하십시오 (git 그룹은 모든 사용자의 기본 그룹이 아니기 때문에 g + sx). 안전한 umask (2) 값의 권한을 완화하는 데 사용됩니다. umask는 여전히 다른 권한 비트에 적용됩니다 (예 : umask가 &lt;code&gt;0022&lt;/code&gt; 인 경우 &lt;code&gt;group&lt;/code&gt; 을 사용하면 그룹 이 아닌 다른 사용자의 읽기 권한이 제거되지 않음). 저장소 권한을 정확하게 지정하는 방법 은 &lt;code&gt;0xxx&lt;/code&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="daa563a54f59f3d95749377d0e4af4c611fecd18" translate="yes" xml:space="preserve">
          <source>Making a change</source>
          <target state="translated">변경</target>
        </trans-unit>
        <trans-unit id="9aef7fbf27451a8c36fe7bf7a109aea9540e01ca" translate="yes" xml:space="preserve">
          <source>Making changes</source>
          <target state="translated">변경</target>
        </trans-unit>
        <trans-unit id="992a7beb5615876037da9b0e5b4a3e7c21af51d8" translate="yes" xml:space="preserve">
          <source>Making some changes to the working directory using your favorite editor.</source>
          <target state="translated">선호하는 편집기를 사용하여 작업 디렉토리를 변경하십시오.</target>
        </trans-unit>
        <trans-unit id="bf4919466a0f70dfd02acc3627e75ad16a05f620" translate="yes" xml:space="preserve">
          <source>Manage multiple working trees</source>
          <target state="translated">여러 작업 트리 관리</target>
        </trans-unit>
        <trans-unit id="6ec4a25401fa228522c7be97da233480069758e8" translate="yes" xml:space="preserve">
          <source>Manage multiple working trees attached to the same repository.</source>
          <target state="translated">동일한 저장소에 연결된 여러 작업 트리를 관리하십시오.</target>
        </trans-unit>
        <trans-unit id="5f089a6eb7f251a9a2fe0a3f833141f8db37c3ff" translate="yes" xml:space="preserve">
          <source>Manage reflog information</source>
          <target state="translated">Reflog 정보 관리</target>
        </trans-unit>
        <trans-unit id="021ab6f7ef8793b1b816ea4bdd5e727ce06994e0" translate="yes" xml:space="preserve">
          <source>Manage set of tracked repositories</source>
          <target state="translated">추적 된 리포지토리 집합 관리</target>
        </trans-unit>
        <trans-unit id="65f908ba554d3d8c75571c008e2b6e59e8585d63" translate="yes" xml:space="preserve">
          <source>Manage the serialized commit-graph file.</source>
          <target state="translated">직렬화 된 커밋 그래프 파일을 관리합니다.</target>
        </trans-unit>
        <trans-unit id="4a3e0eed31d02104159aa0bed6d5acb0e05768b8" translate="yes" xml:space="preserve">
          <source>Manage the set of repositories (&quot;remotes&quot;) whose branches you track.</source>
          <target state="translated">분기를 추적하는 리포지토리 세트 ( &quot;원격&quot;)를 관리합니다.</target>
        </trans-unit>
        <trans-unit id="3507e0027b822825db37aad1b6a1e0779dcd0d96" translate="yes" xml:space="preserve">
          <source>Managing branches</source>
          <target state="translated">지점 관리</target>
        </trans-unit>
        <trans-unit id="279735249dbe3dcc024592a529bd9cb39b1b8496" translate="yes" xml:space="preserve">
          <source>Manipulate the notes tree in &amp;lt;ref&amp;gt;. This overrides &lt;code&gt;GIT_NOTES_REF&lt;/code&gt; and the &quot;core.notesRef&quot; configuration. The ref specifies the full refname when it begins with &lt;code&gt;refs/notes/&lt;/code&gt;; when it begins with &lt;code&gt;notes/&lt;/code&gt;, &lt;code&gt;refs/&lt;/code&gt; and otherwise &lt;code&gt;refs/notes/&lt;/code&gt; is prefixed to form a full name of the ref.</source>
          <target state="translated">&amp;lt;ref&amp;gt;에서 노트 트리를 조작하십시오. 이는 &lt;code&gt;GIT_NOTES_REF&lt;/code&gt; 및 &quot;core.notesRef&quot;구성을 대체 합니다. ref는 &lt;code&gt;refs/notes/&lt;/code&gt; 시작할 때 전체 참조 이름을 지정합니다 . &lt;code&gt;notes/&lt;/code&gt; 시작 하면 &lt;code&gt;refs/&lt;/code&gt; 및 그렇지 않으면 &lt;code&gt;refs/notes/&lt;/code&gt; 가 접두어로 ref의 전체 이름을 형성합니다.</target>
        </trans-unit>
        <trans-unit id="ad0e6ab545d99b4fca1e842f2d64e34b5bf6ca91" translate="yes" xml:space="preserve">
          <source>Manipulating branches</source>
          <target state="translated">가지 조작</target>
        </trans-unit>
        <trans-unit id="e163593ceb018ccfe91e5474069f8880c01bf32f" translate="yes" xml:space="preserve">
          <source>Manipulation commands</source>
          <target state="translated">조작 명령</target>
        </trans-unit>
        <trans-unit id="a4c79f29e9d9d5fa1534359d2910523c3bd41716" translate="yes" xml:space="preserve">
          <source>Manipulators:</source>
          <target state="translated">Manipulators:</target>
        </trans-unit>
        <trans-unit id="2d6fc489721f7990b3e0a46d8dbd0fae7613420d" translate="yes" xml:space="preserve">
          <source>Many (most?) public remote repositories will not contain any of the checked out files or even an index file, and will &lt;strong&gt;only&lt;/strong&gt; contain the actual core Git files. Such a repository usually doesn&amp;rsquo;t even have the &lt;code&gt;.git&lt;/code&gt; subdirectory, but has all the Git files directly in the repository.</source>
          <target state="translated">많은 (대부분?) 공개 원격 저장소에는 체크 아웃 된 파일이나 색인 파일이 &lt;strong&gt;없으며&lt;/strong&gt; 실제 코어 Git 파일 &lt;strong&gt;만&lt;/strong&gt; 포함 됩니다 . 이러한 저장소에는 일반적으로 &lt;code&gt;.git&lt;/code&gt; 하위 디렉토리가 없지만 모든 Git 파일이 저장소에 직접 있습니다.</target>
        </trans-unit>
        <trans-unit id="23a4d8d6b8951ee492fd478361a461e34445c192" translate="yes" xml:space="preserve">
          <source>Many Git commands also take sets of commits, which can be specified in a number of ways. Here are some examples with &lt;code&gt;git log&lt;/code&gt;:</source>
          <target state="translated">많은 Git 명령은 여러 가지 방법으로 지정할 수있는 커밋 세트를 사용합니다. &lt;code&gt;git log&lt;/code&gt; 를 사용한 몇 가지 예는 다음과 같습니다 .</target>
        </trans-unit>
        <trans-unit id="cb5f624f4f524730b1dad471a4cc62df1265c105" translate="yes" xml:space="preserve">
          <source>Many Git commands take revision parameters as arguments. Depending on the command, they denote a specific commit or, for commands which walk the revision graph (such as &lt;a href=&quot;git-log&quot;&gt;git-log[1]&lt;/a&gt;), all commits which are reachable from that commit. For commands that walk the revision graph one can also specify a range of revisions explicitly.</source>
          <target state="translated">많은 Git 명령은 수정 매개 변수를 인수로 사용합니다. 명령에 따라 특정 커밋 또는 수정 그래프를 걷는 명령 (예 : &lt;a href=&quot;git-log&quot;&gt;git-log [1]&lt;/a&gt; )에 대해 해당 커밋에서 도달 할 수있는 모든 커밋을 나타냅니다. 리비전 그래프를 걷는 명령의 경우 리비전 범위를 명시 적으로 지정할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="8eadff7d5c23284bf3e40779cca1324c9880e38b" translate="yes" xml:space="preserve">
          <source>Many Git porcelainish commands take mixture of flags (i.e. parameters that begin with a dash &lt;code&gt;-&lt;/code&gt;) and parameters meant for the underlying &lt;code&gt;git rev-list&lt;/code&gt; command they use internally and flags and parameters for the other commands they use downstream of &lt;code&gt;git rev-list&lt;/code&gt;. This command is used to distinguish between them.</source>
          <target state="translated">많은 힘내 porcelainish 명령 (즉, 대시로 시작 매개 변수 플래그의 혼합물을 &lt;code&gt;-&lt;/code&gt; 그리고 기본 의미 매개 변수) &lt;code&gt;git rev-list&lt;/code&gt; 가 하류 사용하는 다른 명령에 대한가 내부적으로 사용하는 명령 및 플래그 및 매개 변수 &lt;code&gt;git rev-list&lt;/code&gt; . 이 명령은 이들을 구별하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="07f9a7fabb84ff55c93b5220c84bc1016373588c" translate="yes" xml:space="preserve">
          <source>Many command-line options can be provided as part of the fast-import stream itself by using the &lt;code&gt;feature&lt;/code&gt; or &lt;code&gt;option&lt;/code&gt; commands. However, some of these options are unsafe (e.g., allowing fast-import to access the filesystem outside of the repository). These options are disabled by default, but can be allowed by providing this option on the command line. This currently impacts only the &lt;code&gt;export-marks&lt;/code&gt;, &lt;code&gt;import-marks&lt;/code&gt;, and &lt;code&gt;import-marks-if-exists&lt;/code&gt; feature commands.</source>
          <target state="translated">&lt;code&gt;feature&lt;/code&gt; 또는 &lt;code&gt;option&lt;/code&gt; 명령 을 사용하여 빠른 가져 오기 스트림 자체의 일부로 많은 명령 줄 옵션을 제공 할 수 있습니다 . 그러나 이러한 옵션 중 일부는 안전하지 않습니다 (예 : 빠른 가져 오기를 통해 저장소 외부의 파일 시스템에 액세스 할 수 있도록 허용). 이러한 옵션은 기본적으로 비활성화되어 있지만 명령 줄에서이 옵션을 제공하여 허용 할 수 있습니다. 이는 현재 &lt;code&gt;export-marks&lt;/code&gt; , &lt;code&gt;import-marks&lt;/code&gt; 및 &lt;code&gt;import-marks-if-exists&lt;/code&gt; 기능 명령 에만 영향을줍니다 .</target>
        </trans-unit>
        <trans-unit id="b810424b3fea997d54a1c6f50a7ffa7b2bdf31cc" translate="yes" xml:space="preserve">
          <source>Many commands allow wildcards in paths, but you need to protect them from getting globbed by the shell. These two mean different things:</source>
          <target state="translated">많은 명령은 경로에서 와일드 카드를 허용하지만 쉘에 의해 붙 잡히지 않도록 보호해야합니다. 이 두 가지는 다른 의미입니다.</target>
        </trans-unit>
        <trans-unit id="f769735173b4b17536b3bddf331e35fc94c1f6c2" translate="yes" xml:space="preserve">
          <source>Many commands take revisions (most often &quot;commits&quot;, but sometimes &quot;tree-ish&quot;, depending on the context and command) and paths as their arguments. Here are the rules:</source>
          <target state="translated">많은 명령은 수정 (대부분 &quot;커밋&quot;이지만 컨텍스트 및 명령에 따라 &quot;트리-쉬&quot;) 및 경로를 인수로 사용합니다. 규칙은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="51a04d163df59d3e4e585f46784dd69c625e4feb" translate="yes" xml:space="preserve">
          <source>Many commands that can work on files in the working tree and/or in the index can take &lt;code&gt;--cached&lt;/code&gt; and/or &lt;code&gt;--index&lt;/code&gt; options. Sometimes people incorrectly think that, because the index was originally called cache, these two are synonyms. They are &lt;strong&gt;not&lt;/strong&gt; &amp;mdash; these two options mean very different things.</source>
          <target state="translated">작업 트리 및 / 또는 인덱스의 파일에서 작동 할 수있는 많은 명령은 &lt;code&gt;--cached&lt;/code&gt; 및 / 또는 &lt;code&gt;--index&lt;/code&gt; 옵션을 사용할 수 있습니다. 때때로 사람들은 색인이 원래 캐시라고했기 때문에이 두 가지는 동의어라고 잘못 생각합니다. 그들은는 &lt;strong&gt;없습니다&lt;/strong&gt; -이 두 옵션은 매우 다른 것을 의미한다.</target>
        </trans-unit>
        <trans-unit id="41a419d79cd72b9d54b27ecee9672655c35e91cc" translate="yes" xml:space="preserve">
          <source>Many gitweb features can be enabled (or disabled) and configured using the &lt;code&gt;%feature&lt;/code&gt; hash. Names of gitweb features are keys of this hash.</source>
          <target state="translated">&lt;code&gt;%feature&lt;/code&gt; 해시를 사용하여 많은 gitweb 기능을 활성화 (또는 비활성화) 할 수 있습니다 . gitweb 기능의 이름은이 해시의 키입니다.</target>
        </trans-unit>
        <trans-unit id="919a2ac82af6ff1bc82b2171d1abca264db10f6e" translate="yes" xml:space="preserve">
          <source>Many installations of sshd do not invoke your shell as the login shell when you directly run programs; what this means is that if your login shell is &lt;em&gt;bash&lt;/em&gt;, only &lt;code&gt;.bashrc&lt;/code&gt; is read and not &lt;code&gt;.bash_profile&lt;/code&gt;. As a workaround, make sure &lt;code&gt;.bashrc&lt;/code&gt; sets up &lt;code&gt;$PATH&lt;/code&gt; so that you can run &lt;em&gt;git-receive-pack&lt;/em&gt; program.</source>
          <target state="translated">많은 sshd 설치는 프로그램을 직접 실행할 때 쉘을 로그인 쉘로 호출하지 않습니다. 이것은 로그인 쉘이 &lt;em&gt;bash&lt;/em&gt; 이면 &lt;code&gt;.bashrc&lt;/code&gt; 만 읽히고 &lt;code&gt;.bash_profile&lt;/code&gt; 이 아니라는 것을 의미합니다 . 해결 방법으로 &lt;code&gt;.bashrc&lt;/code&gt; 가 &lt;code&gt;$PATH&lt;/code&gt; 설정하여 &lt;em&gt;git-receive-pack&lt;/em&gt; 프로그램을 실행할 수 있는지 확인하십시오 .</target>
        </trans-unit>
        <trans-unit id="b683891958210e2ee979b3e8c7ad10f12997dda2" translate="yes" xml:space="preserve">
          <source>Many mailers if not set up properly will corrupt whitespace. Here are two common types of corruption:</source>
          <target state="translated">제대로 설정하지 않으면 많은 메일러가 공백을 손상시킵니다. 두 가지 일반적인 유형의 손상이 있습니다.</target>
        </trans-unit>
        <trans-unit id="193dde6b7f3a20700543ed6450f24935f7b33dfa" translate="yes" xml:space="preserve">
          <source>Many of the higher-level commands were originally implemented as shell scripts using a smaller core of low-level Git commands. These can still be useful when doing unusual things with Git, or just as a way to understand its inner workings.</source>
          <target state="translated">많은 상위 레벨 명령은 원래 더 작은 코어의 하위 레벨 Git 명령을 사용하여 쉘 스크립트로 구현되었습니다. 이것들은 Git으로 비정상적인 일을 할 때 또는 내부 작업을 이해하는 방법으로 여전히 유용 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3d6c28c55f8170d273c49f3e427a981c665cf6ea" translate="yes" xml:space="preserve">
          <source>Many operations in Git depend on your filesystem to have an efficient &lt;code&gt;lstat(2)&lt;/code&gt; implementation, so that &lt;code&gt;st_mtime&lt;/code&gt; information for working tree files can be cheaply checked to see if the file contents have changed from the version recorded in the index file. Unfortunately, some filesystems have inefficient &lt;code&gt;lstat(2)&lt;/code&gt;. If your filesystem is one of them, you can set &quot;assume unchanged&quot; bit to paths you have not changed to cause Git not to do this check. Note that setting this bit on a path does not mean Git will check the contents of the file to see if it has changed &amp;mdash; it makes Git to omit any checking and assume it has &lt;strong&gt;not&lt;/strong&gt; changed. When you make changes to working tree files, you have to explicitly tell Git about it by dropping &quot;assume unchanged&quot; bit, either before or after you modify them.</source>
          <target state="translated">Git의 많은 작업은 효율적인 &lt;code&gt;lstat(2)&lt;/code&gt; 구현 을 위해 파일 시스템에 의존하므로 작업 트리 파일에 대한 &lt;code&gt;st_mtime&lt;/code&gt; 정보를 저렴하게 검사하여 파일 내용이 인덱스 파일에 기록 된 버전에서 변경되었는지 확인할 수 있습니다. 불행하게도 일부 파일 시스템에는 비효율적 인 &lt;code&gt;lstat(2)&lt;/code&gt; 있습니다. 파일 시스템이 그 중 하나 인 경우 &quot;변경되지 않은 것으로 가정&quot;비트를 변경하지 않은 경로로 설정하여 Git이이 검사를 수행하지 않도록 할 수 있습니다. 경로에서이 비트를 설정한다고해서 Git이 파일의 내용을 검사하여 파일이 변경되었는지 확인한다는 의미는 아닙니다. Git이 검사를 생략하고 &lt;strong&gt;그렇지 않은&lt;/strong&gt; 것으로 가정합니다.&lt;strong&gt;&lt;/strong&gt;변경되었습니다. 작업 트리 파일을 변경할 때는 수정하기 전이나 후에 &quot;변경되지 않은 것으로 가정&quot;비트를 삭제하여 Git에 명시 적으로 알려 주어야합니다.</target>
        </trans-unit>
        <trans-unit id="a799d1cceae5d3b6566df7c502b0ed31229cf195" translate="yes" xml:space="preserve">
          <source>Many revision control systems provide an &lt;code&gt;add&lt;/code&gt; command that tells the system to start tracking changes to a new file. Git&amp;rsquo;s &lt;code&gt;add&lt;/code&gt; command does something simpler and more powerful: &lt;code&gt;git add&lt;/code&gt; is used both for new and newly modified files, and in both cases it takes a snapshot of the given files and stages that content in the index, ready for inclusion in the next commit.</source>
          <target state="translated">많은 개정 제어 시스템 은 시스템에 새 파일의 변경 내용 추적을 시작하도록 지시 하는 &lt;code&gt;add&lt;/code&gt; 명령을 제공 합니다. Git의 &lt;code&gt;add&lt;/code&gt; 명령은보다 간단하고 강력한 기능을 수행합니다. &lt;code&gt;git add&lt;/code&gt; 는 새로 수정 된 파일과 새로 수정 된 파일 모두에 사용되며 두 경우 모두 주어진 파일의 스냅 샷을 생성하고 인덱스의 내용을 준비하여 다음 커밋에 포함시킬 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f4ad3aa56684a237b2a48778413d62e45b68868b" translate="yes" xml:space="preserve">
          <source>Many tags. Will create a tag for every commit, reflecting the commit name in the Arch repository.</source>
          <target state="translated">많은 태그. Arch 저장소의 커밋 이름을 반영하여 모든 커밋에 대한 태그를 만듭니다.</target>
        </trans-unit>
        <trans-unit id="6b4939f173ca46ae5e70f2a578215c85acafb3ce" translate="yes" xml:space="preserve">
          <source>Many thanks to Ingo Molnar for giving me very useful information that appears in this paper, for commenting on this paper, for his suggestions to improve &quot;git bisect&quot; and for evangelizing &quot;git bisect&quot; on the linux kernel mailing lists.</source>
          <target state="translated">이 백서에 나오는 매우 유용한 정보를 제공하고이 논문에 대한 의견을 제시하고 &quot;git bisect&quot;를 개선하기위한 그의 제안과 리눅스 커널 메일 링리스트에서 &quot;git bisect&quot;를 복음화 해 주신 Ingo Molnar에게 많은 감사를드립니다.</target>
        </trans-unit>
        <trans-unit id="5bd4feea472ac1f81e9eed337015c1647da376b9" translate="yes" xml:space="preserve">
          <source>Many thanks to Junio Hamano for his help in reviewing this paper, for reviewing the patches I sent to the Git mailing list, for discussing some ideas and helping me improve them, for improving &quot;git bisect&quot; a lot and for his awesome work in maintaining and developing Git.</source>
          <target state="translated">이 논문을 검토하고, Git 메일 링리스트에 보낸 패치를 검토하고, 일부 아이디어를 논의하고, 개선하는 데 도움이되고, &quot;git bisect&quot;를 많이 개선하고, 유지 관리에있어 훌륭한 작업을 해준 Junio ​​Hamano에게 많은 감사를드립니다. 그리고 힘내 개발.</target>
        </trans-unit>
        <trans-unit id="a308e878405ccac0452dc3a943e6c4f471d0d0f3" translate="yes" xml:space="preserve">
          <source>Many thanks to Linus Torvalds for inventing, developing and evangelizing &quot;git bisect&quot;, Git and Linux.</source>
          <target state="translated">&quot;git bisect&quot;, Git 및 Linux를 발명, 개발 및 복음화 한 Linus Torvalds에게 감사드립니다.</target>
        </trans-unit>
        <trans-unit id="64e052904657c30a32be467111b38e2db70890d3" translate="yes" xml:space="preserve">
          <source>Many thanks to the Linux-Kongress program committee for choosing the author to given a talk and for publishing this paper.</source>
          <target state="translated">연설을 할 작가를 선택하고이 논문을 발표 한 Linux-Kongress 프로그램위원회에 감사드립니다.</target>
        </trans-unit>
        <trans-unit id="a813e2d801820a3507d225cfe410c73c1e3814a5" translate="yes" xml:space="preserve">
          <source>Many thanks to the many other great people who helped one way or another when I worked on Git, especially to Andreas Ericsson, Johannes Schindelin, H. Peter Anvin, Daniel Barkalow, Bill Lear, John Hawley, Shawn O. Pierce, Jeff King, Sam Vilain, Jon Seymour.</source>
          <target state="translated">Git에서 일할 때 도움을 준 많은 위대한 사람들, 특히 Andreas Ericsson, Johannes Schindelin, H. Peter Anvin, Daniel Barkalow, Bill Lear, John Hawley, Shawn O. Pierce, Jeff King, 샘 빌린, 존 시모어</target>
        </trans-unit>
        <trans-unit id="970bd5edbccf4926f346f36ced29b782ff134b0f" translate="yes" xml:space="preserve">
          <source>Many things can then be done very naturally:</source>
          <target state="translated">그러면 많은 것들이 매우 자연스럽게 이루어질 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="08ed471839ae0d35cbf114cdc8b4fb025451ea78" translate="yes" xml:space="preserve">
          <source>Map a P4 user to a name and email address in Git. Use a string with the following format to create a mapping:</source>
          <target state="translated">P4 사용자를 Git의 이름과 이메일 주소로 매핑하십시오. 다음 형식의 문자열을 사용하여 맵핑을 작성하십시오.</target>
        </trans-unit>
        <trans-unit id="84e3b6902de1ae94c28d951dff280df12bc818fa" translate="yes" xml:space="preserve">
          <source>Mapping authors</source>
          <target state="translated">지도 제작자</target>
        </trans-unit>
        <trans-unit id="ecca08ad6644372b493b29196801e0262451ee0a" translate="yes" xml:space="preserve">
          <source>Mapping between Subversion revision numbers and Git commit names. In a repository where the noMetadata option is not set, this can be rebuilt from the git-svn-id: lines that are at the end of every commit (see the &lt;code&gt;svn.noMetadata&lt;/code&gt; section above for details).</source>
          <target state="translated">Subversion 개정 번호와 Git 커밋 이름 간의 매핑 noMetadata 옵션이 설정되지 않은 리포지토리에서 모든 커밋 끝에있는 git-svn-id : 행에서이를 재구성 할 수 있습니다 (자세한 내용은 위 의 &lt;code&gt;svn.noMetadata&lt;/code&gt; 섹션 참조).</target>
        </trans-unit>
        <trans-unit id="f80c6e32aadbd525747e2562fb58002684c64ae1" translate="yes" xml:space="preserve">
          <source>Mark lines that were changed by an ignored revision that we attributed to another commit with a &lt;code&gt;?&lt;/code&gt; in the output of &lt;a href=&quot;git-blame&quot;&gt;git-blame[1]&lt;/a&gt;.</source>
          <target state="translated">무시 된 개정으로 변경 한 마크 라인은 &lt;code&gt;?&lt;/code&gt; &lt;a href=&quot;git-blame&quot;&gt;git-blame [1]&lt;/a&gt; 의 출력에서 .</target>
        </trans-unit>
        <trans-unit id="e0a93a83bc77d4e299bb423ede0b0e7523360c05" translate="yes" xml:space="preserve">
          <source>Mark lines that were changed by an ignored revision that we could not attribute to another commit with a &lt;code&gt;*&lt;/code&gt; in the output of &lt;a href=&quot;git-blame&quot;&gt;git-blame[1]&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;git-blame&quot;&gt;git-blame [1]&lt;/a&gt; 출력에서 &lt;code&gt;*&lt;/code&gt; 를 사용하여 다른 커밋에 속할 수없는 무시 된 개정으로 변경된 행을 표시합니다 .</target>
        </trans-unit>
        <trans-unit id="ffa04a5e9e510ce8e8a9af22652c96cb5f2a2455" translate="yes" xml:space="preserve">
          <source>Mark the commit you want to split with the action &quot;edit&quot;.</source>
          <target state="translated">&quot;edit&quot;조치로 분할하려는 커밋을 표시하십시오.</target>
        </trans-unit>
        <trans-unit id="9ad05336158823a7d5e9d2740631e3ed3e7b77cc" translate="yes" xml:space="preserve">
          <source>Mark the series as the &amp;lt;n&amp;gt;-th iteration of the topic. The output filenames have &lt;code&gt;v&amp;lt;n&amp;gt;&lt;/code&gt; prepended to them, and the subject prefix (&quot;PATCH&quot; by default, but configurable via the &lt;code&gt;--subject-prefix&lt;/code&gt; option) has ` v&amp;lt;n&amp;gt;` appended to it. E.g. &lt;code&gt;--reroll-count=4&lt;/code&gt; may produce &lt;code&gt;v4-0001-add-makefile.patch&lt;/code&gt; file that has &quot;Subject: [PATCH v4 1/20] Add makefile&quot; in it.</source>
          <target state="translated">시리즈를 주제의 &amp;lt;n&amp;gt; 번째 반복으로 표시하십시오. 출력 파일 이름 앞에는 &lt;code&gt;v&amp;lt;n&amp;gt;&lt;/code&gt; 붙고 제목 접두사 (기본적으로 &quot;PATCH&quot;이지만 &lt;code&gt;--subject-prefix&lt;/code&gt; 옵션을 통해 구성 할 수 있음)에`v &amp;lt;n&amp;gt;`이 추가됩니다. 예를 들어 &lt;code&gt;--reroll-count=4&lt;/code&gt; 는 &quot;Subject : [PATCH v4 1/20] Makefile 추가&quot;가 포함 된 &lt;code&gt;v4-0001-add-makefile.patch&lt;/code&gt; 파일을 생성 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="eb02cc756d5e31341021dd6b9e08120c18cfff12" translate="yes" xml:space="preserve">
          <source>Mark which side of a symmetric difference a commit is reachable from. Commits from the left side are prefixed with &lt;code&gt;&amp;lt;&lt;/code&gt; and those from the right with &lt;code&gt;&amp;gt;&lt;/code&gt;. If combined with &lt;code&gt;--boundary&lt;/code&gt;, those commits are prefixed with &lt;code&gt;-&lt;/code&gt;.</source>
          <target state="translated">커밋에 도달 할 수있는 대칭 차이의 측면을 표시하십시오. 왼쪽에서 커밋은 접두어 &lt;code&gt;&amp;lt;&lt;/code&gt; 및 오른쪽 것과 &lt;code&gt;&amp;gt;&lt;/code&gt; . &lt;code&gt;--boundary&lt;/code&gt; 와 결합하면 해당 커밋 앞에 &lt;code&gt;-&lt;/code&gt; 가 붙습니다 .</target>
        </trans-unit>
        <trans-unit id="6cf65e398a783b020004a05bc4b12965bd321675" translate="yes" xml:space="preserve">
          <source>Mark which side of a symmetric difference a commit is reachable from. Commits from the left side are prefixed with a &lt;code&gt;&amp;lt;&lt;/code&gt; symbol and those from the right with a &lt;code&gt;&amp;gt;&lt;/code&gt; symbol.</source>
          <target state="translated">커밋에 도달 할 수있는 대칭 차이의 측면을 표시하십시오. 왼쪽에서 커밋은 &lt;code&gt;&amp;lt;&lt;/code&gt; 기호 로 시작하고 오른쪽에서 커밋은 &lt;code&gt;&amp;gt;&lt;/code&gt; 기호로 시작합니다.</target>
        </trans-unit>
        <trans-unit id="d120d1dcfa9af04a37a29923ad102f9ac75edbe0" translate="yes" xml:space="preserve">
          <source>Marking files as binary</source>
          <target state="translated">파일을 이진으로 표시</target>
        </trans-unit>
        <trans-unit id="3549e52dba075c1ca63de7856965a26fd121848f" translate="yes" xml:space="preserve">
          <source>Marks are stored in a sparse array, using 1 pointer (4 bytes or 8 bytes, depending on pointer size) per mark. Although the array is sparse, frontends are still strongly encouraged to use marks between 1 and n, where n is the total number of marks required for this import.</source>
          <target state="translated">마크는 마크 당 1 포인터 (포인터 크기에 따라 4 바이트 또는 8 바이트)를 사용하여 희소 배열에 저장됩니다. 배열이 희소하지만 프런트 엔드는 여전히 1과 n 사이의 마크를 사용하는 것이 좋습니다. 여기서 n은이 가져 오기에 필요한 총 마크 수입니다.</target>
        </trans-unit>
        <trans-unit id="c020b534de76a3110681e8b3a1131c198a04e4dd" translate="yes" xml:space="preserve">
          <source>Marks must be declared (via &lt;code&gt;mark&lt;/code&gt;) before they can be used.</source>
          <target state="translated">마크를 사용하려면 마크를 통해 ( &lt;code&gt;mark&lt;/code&gt; 를 통해 ) 선언해야합니다 .</target>
        </trans-unit>
        <trans-unit id="e23875af098ed58ac7ddbf626ebbfd55b3530c2d" translate="yes" xml:space="preserve">
          <source>Marks the end of the stream. This command is optional unless the &lt;code&gt;done&lt;/code&gt; feature was requested using the &lt;code&gt;--done&lt;/code&gt; command-line option or &lt;code&gt;feature done&lt;/code&gt; command.</source>
          <target state="translated">스트림의 끝을 표시합니다. &lt;code&gt;--done&lt;/code&gt; 명령 줄 옵션 또는 &lt;code&gt;feature done&lt;/code&gt; 명령을 사용하여 &lt;code&gt;done&lt;/code&gt; 기능을 요청 하지 않은 경우이 명령은 선택 사항 입니다.</target>
        </trans-unit>
        <trans-unit id="6dd5e3d7525f7c72ed149669f4682e8cf2613e2e" translate="yes" xml:space="preserve">
          <source>Match paths exactly (i.e. don&amp;rsquo;t allow &quot;/foo/repo&quot; when the real path is &quot;/foo/repo.git&quot; or &quot;/foo/repo/.git&quot;) and don&amp;rsquo;t do user-relative paths. &lt;code&gt;git daemon&lt;/code&gt; will refuse to start when this option is enabled and no whitelist is specified.</source>
          <target state="translated">실제 경로가 &quot;/foo/repo.git&quot;또는 &quot;/foo/repo/.git&quot;인 경우 &quot;/ foo / repo&quot;를 허용하지 않고 경로를 정확하게 일치시키고 사용자 기준 경로를 수행하지 마십시오. 이 옵션이 활성화되고 화이트리스트가 지정되지 않으면 &lt;code&gt;git daemon&lt;/code&gt; 은 시작을 거부합니다.</target>
        </trans-unit>
        <trans-unit id="1c5cb990d5ea569aee72e359a127ac5dd4a253ea" translate="yes" xml:space="preserve">
          <source>Match the pattern only at word boundary (either begin at the beginning of a line, or preceded by a non-word character; end at the end of a line or followed by a non-word character).</source>
          <target state="translated">단어 경계에서만 패턴을 일치시킵니다 (줄의 시작 부분에서 시작하거나 단어가 아닌 문자가 앞에옵니다. 줄의 끝에서 끝나거나 단어가 아닌 문자가옵니다).</target>
        </trans-unit>
        <trans-unit id="ca182a2e7bbbd5ec9c62eec976529a0aa078540e" translate="yes" xml:space="preserve">
          <source>Match the regular expression limiting patterns without regard to letter case.</source>
          <target state="translated">대소 문자와 상관없이 정규 표현식 제한 패턴을 일치시킵니다.</target>
        </trans-unit>
        <trans-unit id="1452c4b1c4eed7c80174fb8c82a8ed6f95d98c4d" translate="yes" xml:space="preserve">
          <source>Maximum delta depth, for blob and tree deltification. Default is 50.</source>
          <target state="translated">얼룩 및 나무 껍질 제거를위한 최대 델타 깊이. 기본값은 50입니다.</target>
        </trans-unit>
        <trans-unit id="384f40abc20254795ab29a564353f53402412c1e" translate="yes" xml:space="preserve">
          <source>Maximum number of branches to maintain active at once. See &amp;ldquo;Memory Utilization&amp;rdquo; below for details. Default is 5.</source>
          <target state="translated">한 번에 활성을 유지할 최대 분기 수입니다. 자세한 내용은 아래의 &quot;메모리 사용률&quot;을 참조하십시오. 기본값은 5입니다.</target>
        </trans-unit>
        <trans-unit id="5ba691ad2489c6a98bfddfb725c399a5433235ec" translate="yes" xml:space="preserve">
          <source>Maximum number of bytes to map simultaneously into memory from pack files. If Git needs to access more than this many bytes at once to complete an operation it will unmap existing regions to reclaim virtual address space within the process.</source>
          <target state="translated">팩 파일에서 메모리에 동시에 맵핑 할 최대 바이트 수입니다. Git이 작업을 완료하기 위해 한 번에이 바이트 이상에 액세스해야하는 경우 프로세스 내에서 가상 주소 공간을 확보하기 위해 기존 영역을 매핑 해제합니다.</target>
        </trans-unit>
        <trans-unit id="015780ae5eaf5a16460a6c6f6a47f9fd68665f6e" translate="yes" xml:space="preserve">
          <source>Maximum number of bytes to reserve for caching base objects that may be referenced by multiple deltified objects. By storing the entire decompressed base objects in a cache Git is able to avoid unpacking and decompressing frequently used base objects multiple times.</source>
          <target state="translated">여러 deltified 객체가 참조 할 수있는 기본 객체를 캐싱하기 위해 예약 할 최대 바이트 수입니다. 압축 해제 된 전체 기본 개체를 캐시에 저장함으로써 Git은 자주 사용하는 기본 개체를 여러 번 풀고 압축 해제하는 것을 피할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9639a9871e3fa301072f34b62bd6d8d1df5dfde8" translate="yes" xml:space="preserve">
          <source>Maximum number of concurrent clients, defaults to 32. Set it to zero for no limit.</source>
          <target state="translated">최대 동시 클라이언트 수, 기본값은 32입니다. 제한없이 0으로 설정하십시오.</target>
        </trans-unit>
        <trans-unit id="3fca64028c3b9d66663fb33bbabf381bdeaeb020" translate="yes" xml:space="preserve">
          <source>Maximum size in bytes of the buffer used by smart HTTP transports when POSTing data to the remote system. For requests larger than this buffer size, HTTP/1.1 and Transfer-Encoding: chunked is used to avoid creating a massive pack file locally. Default is 1 MiB, which is sufficient for most requests.</source>
          <target state="translated">원격 시스템에 데이터를 POST 할 때 스마트 HTTP 전송에 사용되는 버퍼의 최대 크기 (바이트)입니다. 이 버퍼 크기보다 큰 요청의 경우 HTTP / 1.1 및 Transfer-Encoding : chunked는 대규모 팩 파일을 로컬로 작성하지 않도록하기 위해 사용됩니다. 기본값은 1MiB이며 대부분의 요청에 충분합니다.</target>
        </trans-unit>
        <trans-unit id="d63005f2c2b8f8c3239933e10d80e78d75fee39e" translate="yes" xml:space="preserve">
          <source>Maximum size of a blob that fast-import will attempt to create a delta for, expressed in bytes. The default is 512m (512 MiB). Some importers may wish to lower this on systems with constrained memory.</source>
          <target state="translated">빠른 가져 오기에서 바이트 단위로 표현 된 델타를 만들려고 시도하는 Blob의 최대 크기입니다. 기본값은 512m (512MiB)입니다. 일부 수입 업체는 메모리가 제한된 시스템에서이 값을 낮추기를 원할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d3dd84835c1a4e2de21619e12a6eaaff0c2d1fd8" translate="yes" xml:space="preserve">
          <source>Maximum size of each output pack file. The size can be suffixed with &quot;k&quot;, &quot;m&quot;, or &quot;g&quot;. The minimum size allowed is limited to 1 MiB. If specified, multiple packfiles may be created, which also prevents the creation of a bitmap index. The default is unlimited, unless the config variable &lt;code&gt;pack.packSizeLimit&lt;/code&gt; is set.</source>
          <target state="translated">각 출력 팩 파일의 최대 크기 크기는 &quot;k&quot;, &quot;m&quot;또는 &quot;g&quot;로 접미사를 붙일 수 있습니다. 허용되는 최소 크기는 1MiB로 제한됩니다. 지정된 경우 여러 팩 파일이 만들어져 비트 맵 인덱스가 만들어지지 않을 수도 있습니다. 구성 변수 &lt;code&gt;pack.packSizeLimit&lt;/code&gt; 가 설정되어 있지 않으면 기본값은 무제한 입니다.</target>
        </trans-unit>
        <trans-unit id="b8685db9c67d15fcb99750ad6a0c6f6dc3e27c92" translate="yes" xml:space="preserve">
          <source>Maximum size of each output packfile. The default is unlimited.</source>
          <target state="translated">각 출력 팩 파일의 최대 크기 기본값은 무제한입니다.</target>
        </trans-unit>
        <trans-unit id="ecff084a0c01e319db62c5b088c7a98c5cc26a2a" translate="yes" xml:space="preserve">
          <source>May be an unabbreviated ref name or a glob and may be specified multiple times. A warning will be issued for refs that do not exist, but a glob that does not match any refs is silently ignored.</source>
          <target state="translated">축약되지 않은 참조 이름 또는 glob 일 수 있으며 여러 번 지정할 수 있습니다. 존재하지 않는 심판에 대해서는 경고가 표시되지만 어떤 심판과도 일치하지 않는 글롭은 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="706c83c32d28c2f1cb1aaafc37be7356f71e7631" translate="yes" xml:space="preserve">
          <source>May be set to a boolean value, or the string &lt;code&gt;if-asked&lt;/code&gt;. A true value causes all pushes to be GPG signed, as if &lt;code&gt;--signed&lt;/code&gt; is passed to &lt;a href=&quot;git-push&quot;&gt;git-push[1]&lt;/a&gt;. The string &lt;code&gt;if-asked&lt;/code&gt; causes pushes to be signed if the server supports it, as if &lt;code&gt;--signed=if-asked&lt;/code&gt; is passed to &lt;code&gt;git push&lt;/code&gt;. A false value may override a value from a lower-priority config file. An explicit command-line flag always overrides this config option.</source>
          <target state="translated">부울 값 또는 문자열 &lt;code&gt;if-asked&lt;/code&gt; 로 설정 될 수 있습니다 . true 값은 &lt;code&gt;--signed&lt;/code&gt; 가 &lt;a href=&quot;git-push&quot;&gt;git-push [1]에&lt;/a&gt; 전달되는 것처럼 모든 푸시에 GPG 서명이됩니다 . &lt;code&gt;if-asked&lt;/code&gt; 문자열 은 &lt;code&gt;--signed=if-asked&lt;/code&gt; 가 &lt;code&gt;git push&lt;/code&gt; 로 전달되는 것처럼 서버가 지원하는 경우 푸시에 서명을합니다 . 잘못된 값은 우선 순위가 낮은 구성 파일의 값보다 우선합니다. 명시적인 명령 줄 플래그는 항상이 구성 옵션을 재정의합니다.</target>
        </trans-unit>
        <trans-unit id="8555af2d5095b661ce8d37e9e0375fb4c8ea77d6" translate="yes" xml:space="preserve">
          <source>May be used to make sure all submodule commits used by the revisions to be pushed are available on a remote-tracking branch. If &lt;code&gt;check&lt;/code&gt; is used Git will verify that all submodule commits that changed in the revisions to be pushed are available on at least one remote of the submodule. If any commits are missing the push will be aborted and exit with non-zero status. If &lt;code&gt;on-demand&lt;/code&gt; is used all submodules that changed in the revisions to be pushed will be pushed. If on-demand was not able to push all necessary revisions it will also be aborted and exit with non-zero status. If &lt;code&gt;only&lt;/code&gt; is used all submodules will be recursively pushed while the superproject is left unpushed. A value of &lt;code&gt;no&lt;/code&gt; or using &lt;code&gt;--no-recurse-submodules&lt;/code&gt; can be used to override the push.recurseSubmodules configuration variable when no submodule recursion is required.</source>
          <target state="translated">푸시 할 개정에 사용 된 모든 서브 모듈 커밋이 원격 추적 브랜치에서 사용 가능한지 확인하는 데 사용될 수 있습니다. 경우 &lt;code&gt;check&lt;/code&gt; 사용 힘내 밀어하기 위해 수정 변경하는 모든 서브 모듈 커밋 원격 서브 모듈 중 적어도 하나에 사용할 수 있는지 확인합니다. 커밋이 누락되면 푸시가 중단되고 0이 아닌 상태로 종료됩니다. 경우 &lt;code&gt;on-demand&lt;/code&gt; 추진한다 추진되는 수정 변경하는 모든 서브 모듈을 사용한다. 요청시 필요한 모든 수정 사항을 푸시 할 수없는 경우 중단되고 0이 아닌 상태로 종료됩니다. 경우 &lt;code&gt;only&lt;/code&gt; 사용되는 superproject이 unpushed 남아있는 동안 모든 서브 모듈은 재귀 적으로 추진 될 것입니다. &lt;code&gt;--no-recurse-submodules&lt;/code&gt; 를 사용하거나 사용 &lt;code&gt;no&lt;/code&gt; 값 하위 모듈 재귀가 필요하지 않은 경우 push.recurseSubmodules 구성 변수를 재정의하는 데 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8be2a61b9ad007dcdaebc339c9660a293e37ceee" translate="yes" xml:space="preserve">
          <source>Mbox file to split. If not given, the mbox is read from the standard input.</source>
          <target state="translated">분할 할 Mbox 파일. 지정하지 않으면 표준 입력에서 mbox를 읽습니다.</target>
        </trans-unit>
        <trans-unit id="1ce7743133ea15a3c11834ae295610d6b0aca98e" translate="yes" xml:space="preserve">
          <source>Memory utilization</source>
          <target state="translated">메모리 활용</target>
        </trans-unit>
        <trans-unit id="94804378bc64156caa1411beabf938d0cc1f334a" translate="yes" xml:space="preserve">
          <source>Merge a topic branch into the current branch, which resulted in a fast-forward.</source>
          <target state="translated">토픽 브랜치를 현재 브랜치로 병합하면 빨리 진행됩니다.</target>
        </trans-unit>
        <trans-unit id="aa4cb5d8e33b071846e0985dfd9e8a73b7ff3b77" translate="yes" xml:space="preserve">
          <source>Merge branch &lt;code&gt;maint&lt;/code&gt; into the current branch, but do not make a new commit automatically:</source>
          <target state="translated">분기 &lt;code&gt;maint&lt;/code&gt; 을 현재 분기로 병합 하지만 자동으로 새 커밋을 만들지 마십시오.</target>
        </trans-unit>
        <trans-unit id="36c2108053218bb1c9bd1daf5d80ef9e2b56153b" translate="yes" xml:space="preserve">
          <source>Merge branch &lt;code&gt;obsolete&lt;/code&gt; into the current branch, using &lt;code&gt;ours&lt;/code&gt; merge strategy:</source>
          <target state="translated">병합 지점 &lt;code&gt;obsolete&lt;/code&gt; 사용하여 현재 지점에, &lt;code&gt;ours&lt;/code&gt; 병합 전략 :</target>
        </trans-unit>
        <trans-unit id="2340cae4ab971b09adab3732a6eccbc0f94439af" translate="yes" xml:space="preserve">
          <source>Merge branches &lt;code&gt;fixes&lt;/code&gt; and &lt;code&gt;enhancements&lt;/code&gt; on top of the current branch, making an octopus merge:</source>
          <target state="translated">현재 브랜치 위에 브랜치 &lt;code&gt;fixes&lt;/code&gt; 및 &lt;code&gt;enhancements&lt;/code&gt; 을 병합하여 문어를 병합합니다.</target>
        </trans-unit>
        <trans-unit id="3b3fe151c69070e113efe45497e8fbe34f98eda0" translate="yes" xml:space="preserve">
          <source>Merge into the current branch the remote branch &lt;code&gt;next&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;next&lt;/code&gt; 현재 브랜치를 원격 브랜치로 병합하십시오 .</target>
        </trans-unit>
        <trans-unit id="c5d9976d41384cd800a73252d5887846f7995334" translate="yes" xml:space="preserve">
          <source>Merge one patch into CVS</source>
          <target state="translated">하나의 패치를 CVS에 병합</target>
        </trans-unit>
        <trans-unit id="ebf628d17763f2d1db5244a9d541825468f6e3f2" translate="yes" xml:space="preserve">
          <source>Merge one patch into CVS (-c and -w options). The working directory is within the Git Repo</source>
          <target state="translated">하나의 패치를 CVS에 병합합니다 (-c 및 -w 옵션). 작업 디렉토리는 Git Repo 내에 있습니다.</target>
        </trans-unit>
        <trans-unit id="374bc1e6ce1c863c36094e824049bd53454731f0" translate="yes" xml:space="preserve">
          <source>Merge pending patches into CVS automatically &amp;mdash; only if you really know what you are doing</source>
          <target state="translated">보류중인 패치를 CVS에 자동으로 병합 &amp;ndash; 실제로 수행중인 작업을 알고있는 경우에만</target>
        </trans-unit>
        <trans-unit id="1ecf516cb34751fcee31d345dc521d62850b1084" translate="yes" xml:space="preserve">
          <source>Merge strategies</source>
          <target state="translated">전략 병합</target>
        </trans-unit>
        <trans-unit id="6455bb1c3dd50961d850d4ec4f8b22adf354885c" translate="yes" xml:space="preserve">
          <source>Merge the given notes ref into the current notes ref. This will try to merge the changes made by the given notes ref (called &quot;remote&quot;) since the merge-base (if any) into the current notes ref (called &quot;local&quot;).</source>
          <target state="translated">주어진 노트 참조를 현재 노트 참조에 병합합니다. 그러면 병합베이스 (있는 경우) 이후의 지정된 노트 참조 ( &quot;원격&quot;이라고 함)의 변경 사항을 현재 노트 참조 ( &quot;로컬&quot;이라고 함)로 병합하려고합니다.</target>
        </trans-unit>
        <trans-unit id="06a4a977ae422fbb370e91879e13703bae28bf9d" translate="yes" xml:space="preserve">
          <source>Merge tracking</source>
          <target state="translated">병합 병합</target>
        </trans-unit>
        <trans-unit id="af8c9dbb2cf6a08b436fada56eb16ee91017d8ce" translate="yes" xml:space="preserve">
          <source>Merge workflow</source>
          <target state="translated">워크 플로우 병합</target>
        </trans-unit>
        <trans-unit id="01d28a50eda177ec75942bb24c131250cdadabfb" translate="yes" xml:space="preserve">
          <source>Merges</source>
          <target state="translated">Merges</target>
        </trans-unit>
        <trans-unit id="c4dada76f0f6e7dcbd827c4ba6bada46b3c6714c" translate="yes" xml:space="preserve">
          <source>Merges (to be discussed later), as well as operations such as &lt;code&gt;git reset&lt;/code&gt;, which change the currently checked-out commit, generally set ORIG_HEAD to the value HEAD had before the current operation.</source>
          <target state="translated">현재 체크 아웃 된 커밋을 변경하는 &lt;code&gt;git reset&lt;/code&gt; 과 같은 작업과 병합 (나중에 설명)은 일반적으로 ORIG_HEAD를 현재 작업 이전의 HEAD 값으로 설정합니다.</target>
        </trans-unit>
        <trans-unit id="376269fe69e269c1639bc7c223893145d88653cf" translate="yes" xml:space="preserve">
          <source>Merges are always included. However, their parent list is rewritten: Along each parent, prune away commits that are not included themselves. This results in</source>
          <target state="translated">병합은 항상 포함됩니다. 그러나 부모 목록이 다시 작성됩니다. 각 부모와 함께 포함되지 않은 커밋을 정리하십시오. 결과</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
