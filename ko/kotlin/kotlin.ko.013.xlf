<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="kotlin">
    <body>
      <group id="kotlin">
        <trans-unit id="8310a54b24568803ae04cc82e73e4ed7d64a2ce9" translate="yes" xml:space="preserve">
          <source>In Java:</source>
          <target state="translated">자바에서 :</target>
        </trans-unit>
        <trans-unit id="abb66954294d1e4253f6894befd4961b0fc88ece" translate="yes" xml:space="preserve">
          <source>In JavaScript you can define members either on a prototype or a class itself. I.e.:</source>
          <target state="translated">JavaScript에서는 프로토 타입 또는 클래스 자체에서 멤버를 정의 할 수 있습니다. 즉 :</target>
        </trans-unit>
        <trans-unit id="b73e80ab874eb4a673c8b0548f2f4b1a57e2e5b0" translate="yes" xml:space="preserve">
          <source>In Kotlin 1.0, code in the lambda passed to &lt;code&gt;td&lt;/code&gt; has access to three implicit receivers: the one passed to &lt;code&gt;table&lt;/code&gt;, to &lt;code&gt;tr&lt;/code&gt; and to &lt;code&gt;td&lt;/code&gt;. This allows you to call methods that make no sense in the context - for example to call &lt;code&gt;tr&lt;/code&gt; inside &lt;code&gt;td&lt;/code&gt; and thus to put a &lt;code&gt;&amp;lt;tr&amp;gt;&lt;/code&gt; tag in a &lt;code&gt;&amp;lt;td&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">Kotlin 1.0에서 &lt;code&gt;td&lt;/code&gt; 에 전달 된 람다의 코드는 3 개의 암시 적 수신자에 액세스 할 수 있습니다. 하나는 &lt;code&gt;table&lt;/code&gt; , &lt;code&gt;tr&lt;/code&gt; 및 &lt;code&gt;td&lt;/code&gt; 에 전달됩니다 . 이를 통해 컨텍스트에서 의미가없는 메소드를 호출 할 수 있습니다. 예를 들어 &lt;code&gt;td&lt;/code&gt; 내부에서 &lt;code&gt;tr&lt;/code&gt; 을 호출 하여 &lt;code&gt;&amp;lt;td&amp;gt;&lt;/code&gt; 에 &lt;code&gt;&amp;lt;tr&amp;gt;&lt;/code&gt; 태그 를 넣습니다 .</target>
        </trans-unit>
        <trans-unit id="faca07a0c2f2dcf45e7526d00d395e3cdc377fcb" translate="yes" xml:space="preserve">
          <source>In Kotlin 1.1, you can restrict that, so that only methods defined on the implicit receiver of &lt;code&gt;td&lt;/code&gt; will be available inside the lambda passed to &lt;code&gt;td&lt;/code&gt;. You do that by defining your annotation marked with the &lt;code&gt;@DslMarker&lt;/code&gt; meta-annotation and applying it to the base class of the tag classes.</source>
          <target state="translated">코 틀린 1.1에서는 암시 적 수신기에 정의 된 메소드 만 그래서, 그것을 제한 할 수 있습니다 &lt;code&gt;td&lt;/code&gt; 람다가 전달 내에서 사용할 수 &lt;code&gt;td&lt;/code&gt; . &lt;code&gt;@DslMarker&lt;/code&gt; 메타 주석으로 표시된 주석을 정의 하고 태그 클래스의 기본 클래스에 적용하면됩니다.</target>
        </trans-unit>
        <trans-unit id="24a213ee88ffeaa2bec3378db48986b075744611" translate="yes" xml:space="preserve">
          <source>In Kotlin 1.1.x, use &lt;code&gt;kotlin-stdlib-jre7&lt;/code&gt; and &lt;code&gt;kotlin-stdlib-jre8&lt;/code&gt; instead.</source>
          <target state="translated">Kotlin 1.1.x에서는 &lt;code&gt;kotlin-stdlib-jre7&lt;/code&gt; 및 &lt;code&gt;kotlin-stdlib-jre8&lt;/code&gt; 을 대신 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="6ea3af6627b279c964f114bd464c51ab696c689f" translate="yes" xml:space="preserve">
          <source>In Kotlin 1.3 it is possible for annotations to have nested classes, interfaces, objects, and companions:</source>
          <target state="translated">Kotlin 1.3에서는 주석에 중첩 클래스, 인터페이스, 객체 및 컴패니언이있을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3098d1aa730f31e91846c87eaae7ac71342cdc7e" translate="yes" xml:space="preserve">
          <source>In Kotlin 1.3, it is now possible to capture the &lt;code&gt;when&lt;/code&gt; subject into variable:</source>
          <target state="translated">Kotlin 1.3에서는 이제 변수 가 &lt;code&gt;when&lt;/code&gt; 를 캡처 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2a99d2573a55fb319e350044cce69239e344a488" translate="yes" xml:space="preserve">
          <source>In Kotlin functions can be declared at top level in a file, meaning you do not need to create a class to hold a function, which you are required to do in languages such as Java, C# or Scala. In addition to top level functions, Kotlin functions can also be declared local, as member functions and extension functions.</source>
          <target state="translated">Kotlin에서 함수는 파일에서 최상위 레벨로 선언 될 수 있습니다. 즉, Java, C # 또는 Scala와 같은 언어로 수행해야하는 함수를 보유하기 위해 클래스를 작성할 필요가 없습니다. Kotlin 함수는 최상위 함수 외에도 멤버 함수 및 확장 함수로 로컬로 선언 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d5176ee2358fd7911cf590e90f48fd7d921131e2" translate="yes" xml:space="preserve">
          <source>In Kotlin there are two types of equality:</source>
          <target state="translated">코 틀린에는 두 가지 유형의 평등이 있습니다.</target>
        </trans-unit>
        <trans-unit id="1307e7346626ce5c88b95620e1843731ae3969f4" translate="yes" xml:space="preserve">
          <source>In Kotlin this line can be concisely parsed with the following statement using &lt;a href=&quot;../reference/multi-declarations#destructuring-declarations&quot;&gt;destructuring declaration&lt;/a&gt; from a list of integers:</source>
          <target state="translated">Kotlin 에서이 줄 은 정수 목록에서 &lt;a href=&quot;../reference/multi-declarations#destructuring-declarations&quot;&gt;파괴 선언&lt;/a&gt; 을 사용하여 다음 문장으로 간결하게 구문 분석 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="d2cb95a39c5087932a02f405cc63f954a5dedc22" translate="yes" xml:space="preserve">
          <source>In Kotlin you can provide upper bounds for a generic type. Objective-C also supports this, but that support is unavailable in more complex cases, and is currently not supported in the Kotlin - Objective-C interop. The exception here being a non-null upper bound will make Objective-C methods/properties non-null.</source>
          <target state="translated">Kotlin에서는 일반 유형에 대한 상한을 제공 할 수 있습니다. Objective-C도이를 지원하지만보다 복잡한 경우에는 지원되지 않으며 현재 Kotlin-Objective-C interop에서는 지원되지 않습니다. 여기서 null이 아닌 상한 인 경우 Objective-C 메서드 / 속성이 null이 아닙니다.</target>
        </trans-unit>
        <trans-unit id="ef29e345af9c063df71b3f01a21f78a928c57611" translate="yes" xml:space="preserve">
          <source>In Kotlin you can't work with fields directly, you work with &lt;a href=&quot;../reference/properties&quot;&gt;properties&lt;/a&gt;. You annotate the property:</source>
          <target state="translated">Kotlin에서는 필드로 직접 작업 할 수 없으며 &lt;a href=&quot;../reference/properties&quot;&gt;properties로&lt;/a&gt; 작업 할 수 있습니다 . 속성에 주석을 답니다.</target>
        </trans-unit>
        <trans-unit id="b1411aa40ea7c5b9a0de303333e37baf632f1665" translate="yes" xml:space="preserve">
          <source>In Kotlin you have to add the &lt;code&gt;kotlin-kapt&lt;/code&gt; plugin to enable &lt;code&gt;kapt&lt;/code&gt;, and then replace &lt;code&gt;annotationProcessor&lt;/code&gt; with &lt;code&gt;kapt&lt;/code&gt;:</source>
          <target state="translated">코 틀린에서 당신은 추가 할 필요가 &lt;code&gt;kotlin-kapt&lt;/code&gt; 수 있도록 플러그인을 &lt;code&gt;kapt&lt;/code&gt; 하고 대체 &lt;code&gt;annotationProcessor&lt;/code&gt; 을 함께 &lt;code&gt;kapt&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="da7a2b73e175cb7362740b3fbdff60c8cc8e5724" translate="yes" xml:space="preserve">
          <source>In Kotlin you specify the dependencies in a similar to Java way using &lt;a href=&quot;../reference/kapt&quot;&gt;Kotlin Annotation processing tool&lt;/a&gt; (&lt;code&gt;kapt&lt;/code&gt;) instead of &lt;code&gt;annotationProcessor&lt;/code&gt;.</source>
          <target state="translated">Kotlin에서는 &lt;code&gt;annotationProcessor&lt;/code&gt; 대신 &lt;a href=&quot;../reference/kapt&quot;&gt;Kotlin Annotation Processing Tool&lt;/a&gt; ( &lt;code&gt;kapt&lt;/code&gt; )을 사용하여 Java와 유사한 방식으로 종속성을 지정합니다 .</target>
        </trans-unit>
        <trans-unit id="0a2601b06937bb12c0744830de8e7b372473464e" translate="yes" xml:space="preserve">
          <source>In Kotlin, &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/plus&quot;&gt;&lt;code&gt;plus&lt;/code&gt;&lt;/a&gt; (&lt;code&gt;+&lt;/code&gt;) and &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/minus&quot;&gt;&lt;code&gt;minus&lt;/code&gt;&lt;/a&gt; (&lt;code&gt;-&lt;/code&gt;) operators are defined for collections. They take a collection as the first operand; the second operand can be either an element or another collection. The return value is a new read-only collection:</source>
          <target state="translated">코 틀린에서는 &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/plus&quot;&gt; &lt;code&gt;plus&lt;/code&gt; &lt;/a&gt; ( &lt;code&gt;+&lt;/code&gt; ) 및 &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/minus&quot;&gt; &lt;code&gt;minus&lt;/code&gt; &lt;/a&gt; ( &lt;code&gt;-&lt;/code&gt; ) 연산자가 콜렉션에 대해 정의됩니다. 그들은 첫 번째 피연산자로 컬렉션을 취합니다. 두 번째 피연산자는 요소 또는 다른 컬렉션 일 수 있습니다. 반환 값은 새로운 읽기 전용 컬렉션입니다.</target>
        </trans-unit>
        <trans-unit id="630fd5574aed5de24f8dfa12e49c30f220082837" translate="yes" xml:space="preserve">
          <source>In Kotlin, &lt;em&gt;if&lt;/em&gt; is an expression, i.e. it returns a value. Therefore there is no ternary operator (condition ? then : else), because ordinary &lt;em&gt;if&lt;/em&gt; works fine in this role.</source>
          <target state="translated">Kotlin에서 &lt;em&gt;if&lt;/em&gt; 는 표현식입니다. 즉, 값을 반환합니다. 따라서 평범한 &lt;em&gt;경우이&lt;/em&gt; 역할에서 정상적으로 작동 하기 때문에 삼항 연산자 (조건? then : else)는 없습니다 .</target>
        </trans-unit>
        <trans-unit id="449834b1db02375da0148e9e57aea36e01ccf956" translate="yes" xml:space="preserve">
          <source>In Kotlin, all exceptions are unchecked, meaning that the compiler does not force you to catch any of them. So, when you call a Java method that declares a checked exception, Kotlin does not force you to do anything:</source>
          <target state="translated">Kotlin에서는 모든 예외가 선택 해제되어있어 컴파일러가 강제로 예외를 포착하지 않습니다. 따라서 확인 된 예외를 선언하는 Java 메소드를 호출 할 때 Kotlin은 다음을 수행하도록 강요하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="ccb7acc6feff10a66296746e0c93a95c37a6267f" translate="yes" xml:space="preserve">
          <source>In Kotlin, everything is an object in the sense that we can call member functions and properties on any variable. Some of the types can have a special internal representation - for example, numbers, characters and booleans can be represented as primitive values at runtime - but to the user they look like ordinary classes. In this section we describe the basic types used in Kotlin: numbers, characters, booleans, arrays, and strings.</source>
          <target state="translated">Kotlin에서 모든 것은 모든 변수에서 멤버 함수 및 속성을 호출 할 수 있다는 의미에서 객체입니다. 일부 유형은 특수한 내부 표현을 가질 수 있습니다 (예 : 숫자, 문자 및 부울은 런타임시 기본 값으로 표시 될 수 있음). 그러나 사용자에게는 일반 클래스처럼 보입니다. 이 섹션에서는 Kotlin에서 사용되는 기본 유형 (숫자, 문자, 부울, 배열 및 문자열)에 대해 설명합니다.</target>
        </trans-unit>
        <trans-unit id="bcc1b8c2a992c6c34b455f92da91c74149cd8719" translate="yes" xml:space="preserve">
          <source>In Kotlin, functional types are represented as generic classes taking a different number of parameters: &lt;code&gt;Function0&amp;lt;R&amp;gt;&lt;/code&gt;, &lt;code&gt;Function1&amp;lt;P0, R&amp;gt;&lt;/code&gt;, &lt;code&gt;Function2&amp;lt;P0, P1, R&amp;gt;&lt;/code&gt;, &amp;hellip; This approach has a problem in that this list is finite, and it currently ends with &lt;code&gt;Function22&lt;/code&gt;.</source>
          <target state="translated">Kotlin에서 기능 유형은 다른 수의 매개 변수를 갖는 일반 클래스로 표시됩니다. &lt;code&gt;Function0&amp;lt;R&amp;gt;&lt;/code&gt; , &lt;code&gt;Function1&amp;lt;P0, R&amp;gt;&lt;/code&gt; , &lt;code&gt;Function2&amp;lt;P0, P1, R&amp;gt;&lt;/code&gt; ,&amp;hellip;이 방법은이 목록이 유한하다는 문제가 있습니다. 현재 &lt;code&gt;Function22&lt;/code&gt; 로 끝납니다 .</target>
        </trans-unit>
        <trans-unit id="dda94f8bd95fbc2c5d984c18e048611fb7b42dbc" translate="yes" xml:space="preserve">
          <source>In Kotlin, implementation inheritance is regulated by the following rule: if a class inherits many implementations of the same member from its immediate superclasses, it must override this member and provide its own implementation (perhaps, using one of the inherited ones). To denote the supertype from which the inherited implementation is taken, we use &lt;em&gt;super&lt;/em&gt; qualified by the supertype name in angle brackets, e.g. &lt;code&gt;super&amp;lt;Base&amp;gt;&lt;/code&gt;:</source>
          <target state="translated">Kotlin에서 구현 상속은 다음 규칙에 의해 규제됩니다. 클래스가 직속 슈퍼 클래스에서 동일한 멤버의 많은 구현을 상속하는 경우이 멤버를 재정의하고 자체 구현을 제공해야합니다 (상속 된 상속 된 클래스 중 하나 사용). 상속 구현이 촬영되는 슈퍼 타입을 표시하기 위해, 우리가 사용하는 &lt;em&gt;슈퍼&lt;/em&gt; 꺾쇠 괄호 상위 유형의 이름으로 규정, 예를 들어 &lt;code&gt;super&amp;lt;Base&amp;gt;&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="7dcc76eece2b8bf2e4ff6b5b682eb767b78c7f50" translate="yes" xml:space="preserve">
          <source>In Kotlin, importing is a compile-time concept - importing something does not actually cause any code to run (unlike Python, where all top-level statements in a file are executed at import time). Therefore, circular imports are allowed, but they might suggest a design problem in your code. However, during execution, a class will be loaded the first time it (or any of its properties or functions) is referenced, and class loading causes &lt;a href=&quot;objects-and-companion-objects#companion-objects&quot;&gt;companion objects&lt;/a&gt; to be initialized - this can lead to runtime exceptions if you have circular dependencies.</source>
          <target state="translated">Kotlin에서 가져 오기는 컴파일 타임 개념입니다. 무언가를 가져 오면 실제로 코드가 실행되지 않습니다 (파이썬과 달리 파일의 모든 최상위 문은 가져 오기 시간에 실행 됨). 따라서 순환 가져 오기는 허용되지만 코드의 디자인 문제를 암시 할 수 있습니다. 그러나 실행하는 동안 클래스 (또는 해당 속성 또는 함수)가 처음 참조 될 때 클래스가로드되고 클래스로드로 인해 &lt;a href=&quot;objects-and-companion-objects#companion-objects&quot;&gt;컴패니언 개체&lt;/a&gt; 가 초기화됩니다. 따라서 순환 종속성이있는 경우 런타임 예외가 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9724d2f4d0f2fb74f7ee2235878c749f495a0bad" translate="yes" xml:space="preserve">
          <source>In Kotlin, polymorphism is achieved via the class hierarchy, in such a way that it is impossible to run into a situation where a property or function is missing. The basic rule is that a variable/property/parameter whose declared type is &lt;code&gt;A&lt;/code&gt; may refer to an instance of a class &lt;code&gt;B&lt;/code&gt; if and only if &lt;code&gt;B&lt;/code&gt; is a subtype of &lt;code&gt;A&lt;/code&gt;. This means that either, &lt;code&gt;A&lt;/code&gt; must be a class and &lt;code&gt;B&lt;/code&gt; must be a subclass of &lt;code&gt;A&lt;/code&gt;, or that &lt;code&gt;A&lt;/code&gt; must be an interface and &lt;code&gt;B&lt;/code&gt; must be a class that implements that interface or be a subclass of a class that does. With our classes and interfaces from the previous sections, we can define these functions:</source>
          <target state="translated">Kotlin에서 다형성은 클래스 계층 구조를 통해 달성되므로 속성이나 함수가 누락 된 상황에 빠질 수 없습니다. 기본 규칙은 선언 된 유형이 &lt;code&gt;A&lt;/code&gt; 인 변수 / 속성 / 매개 변수가 &lt;code&gt;B&lt;/code&gt; 가 &lt;code&gt;A&lt;/code&gt; 의 하위 유형 인 경우에만 클래스 &lt;code&gt;B&lt;/code&gt; 의 인스턴스를 참조 할 수 있다는 것 입니다. 즉, &lt;code&gt;A&lt;/code&gt; 는 클래스 여야 하고 &lt;code&gt;B&lt;/code&gt; 는 &lt;code&gt;A&lt;/code&gt; 의 서브 클래스 여야 하거나 &lt;code&gt;A&lt;/code&gt; 는 인터페이스 여야 하고 &lt;code&gt;B&lt;/code&gt; 는 해당 인터페이스를 구현하는 클래스이거나 수행하는 클래스의 서브 클래스 여야합니다. 이전 섹션의 클래스와 인터페이스를 사용하여 다음 함수를 정의 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1ea952e978cda6b66f0b076e1bf4afae5776a252" translate="yes" xml:space="preserve">
          <source>In Kotlin, the default implementation of &lt;code&gt;List&lt;/code&gt; is &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/-array-list/index&quot;&gt;&lt;code&gt;ArrayList&lt;/code&gt;&lt;/a&gt; which you can think of as a resizable array.</source>
          <target state="translated">코 틀린에서의 기본 구현 &lt;code&gt;List&lt;/code&gt; 입니다 &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/-array-list/index&quot;&gt; &lt;code&gt;ArrayList&lt;/code&gt; 에&lt;/a&gt; 당신이 크기 조정 배열로 생각할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b0f2e47b033955ac0009c7acc59029af121c0f6e" translate="yes" xml:space="preserve">
          <source>In Kotlin, the expression for a default value is evaluated every time the function is invoked. Therefore, you will avoid the above trap as long as you use an expression that produces a new list every time it is evaluated:</source>
          <target state="translated">Kotlin에서, 기본값에 대한 표현식은 함수가 호출 될 때마다 평가됩니다. 따라서 평가할 때마다 새 목록을 생성하는 표현식을 사용하는 한 위의 트랩을 피할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1f711d573309109397667a32c94fd541ceecdc60" translate="yes" xml:space="preserve">
          <source>In Kotlin, the orders of objects can be defined in several ways.</source>
          <target state="translated">코 틀린에서는 객체의 순서를 여러 가지 방법으로 정의 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2339e3beff8d4c7968bd5b14328be82bd9a5b046" translate="yes" xml:space="preserve">
          <source>In Kotlin, the type system distinguishes between references that can hold &lt;em&gt;null&lt;/em&gt; (nullable references) and those that can not (non-null references). For example, a regular variable of type &lt;code&gt;String&lt;/code&gt; can not hold &lt;em&gt;null&lt;/em&gt;:</source>
          <target state="translated">Kotlin에서 유형 시스템은 &lt;em&gt;널&lt;/em&gt; (NULL)을 보유 할 수있는 참조와 &lt;em&gt;널&lt;/em&gt; (NULL)이 아닌 참조를 보유하는 참조를 구별 합니다. 예를 들어, &lt;code&gt;String&lt;/code&gt; 유형의 일반 변수는 &lt;em&gt;null을&lt;/em&gt; 보유 할 수 없습니다 .</target>
        </trans-unit>
        <trans-unit id="832014b08edc07489a35f79862dd60fe09daab6f" translate="yes" xml:space="preserve">
          <source>In Kotlin, there is a convention: if the last parameter of a function is a function, then a lambda expression passed as the corresponding argument can be placed outside the parentheses:</source>
          <target state="translated">Kotlin에는 규칙이 있습니다. 함수의 마지막 매개 변수가 함수이면 해당 인수로 전달 된 람다 식을 괄호 밖에 넣을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c2a3923bf671e235e84ea1d045b896ec7fad1d7d" translate="yes" xml:space="preserve">
          <source>In Kotlin, there is a way to explain this sort of thing to the compiler. This is called &lt;strong&gt;declaration-site variance&lt;/strong&gt;: we can annotate the &lt;strong&gt;type parameter&lt;/strong&gt;&lt;code&gt;T&lt;/code&gt; of Source to make sure that it is only &lt;strong&gt;returned&lt;/strong&gt; (produced) from members of &lt;code&gt;Source&amp;lt;T&amp;gt;&lt;/code&gt;, and never consumed. To do this we provide the &lt;strong&gt;out&lt;/strong&gt; modifier:</source>
          <target state="translated">코 틀린에는 이런 종류의 것을 컴파일러에게 설명 할 수있는 방법이 있습니다. 이것을 &lt;strong&gt;선언 사이트 분산&lt;/strong&gt; 이라고합니다 . &lt;code&gt;Source&amp;lt;T&amp;gt;&lt;/code&gt; 멤버로부터 만 &lt;strong&gt;반환&lt;/strong&gt; (생산)되고 소비되지 않도록 Source 의 &lt;strong&gt;형식 매개 변수 &lt;/strong&gt; &lt;code&gt;T&lt;/code&gt; 에 주석을 달 수 있습니다 . 이를 위해 &lt;strong&gt;out&lt;/strong&gt; 수정자를 제공합니다 .&lt;strong&gt;&lt;/strong&gt;&lt;strong&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="feddf47fe54f2c3f729a6d26efa190cb7e973f88" translate="yes" xml:space="preserve">
          <source>In Kotlin, unlike Java or C#, classes do not have static methods. In most cases, it's recommended to simply use package-level functions instead.</source>
          <target state="translated">Kotlin에서 Java 또는 C #과 달리 클래스에는 정적 메소드가 없습니다. 대부분의 경우 패키지 수준 함수를 대신 사용하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="d5e92ec06e3b15b62ad5ec58ebeffa93765ab71a" translate="yes" xml:space="preserve">
          <source>In Kotlin, we can only use a normal, unqualified &lt;code&gt;return&lt;/code&gt; to exit a named function or an anonymous function. This means that to exit a lambda, we have to use a &lt;a href=&quot;returns#return-at-labels&quot;&gt;label&lt;/a&gt;, and a bare &lt;code&gt;return&lt;/code&gt; is forbidden inside a lambda, because a lambda cannot make the enclosing function return:</source>
          <target state="translated">Kotlin에서는 정규화되지 않은 정규 &lt;code&gt;return&lt;/code&gt; 만 사용 하여 명명 된 함수 또는 익명 함수를 종료 할 수 있습니다. 이것은 람다를 종료하려면 &lt;a href=&quot;returns#return-at-labels&quot;&gt;label&lt;/a&gt; 을 사용해야 하고 람다는 둘러싼 함수를 반환 할 수 없기 때문에 람다 내에서 베어 &lt;code&gt;return&lt;/code&gt; 이 금지됨을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="6b416b284c329b83d138fdf71a7f58ad406d7c9b" translate="yes" xml:space="preserve">
          <source>In Maven</source>
          <target state="translated">메이븐에서</target>
        </trans-unit>
        <trans-unit id="9ce095374b679dfd053dccebdba1f6ce80a67e34" translate="yes" xml:space="preserve">
          <source>In Maven, enable the &lt;code&gt;jpa&lt;/code&gt; plugin:</source>
          <target state="translated">Maven에서 &lt;code&gt;jpa&lt;/code&gt; 플러그인을 활성화하십시오 .</target>
        </trans-unit>
        <trans-unit id="4cf1f43e65b88c5f6958702897fafbb7af63f2e9" translate="yes" xml:space="preserve">
          <source>In Maven, enable the &lt;code&gt;spring&lt;/code&gt; plugin:</source>
          <target state="translated">Maven에서 &lt;code&gt;spring&lt;/code&gt; 플러그인을 활성화하십시오 .</target>
        </trans-unit>
        <trans-unit id="6dc887971001bc1cd4775889e759bfb59211b14c" translate="yes" xml:space="preserve">
          <source>In Python, function names must be unique within a module or a class. In Kotlin, we can &lt;em&gt;overload&lt;/em&gt; functions: there can be multiple declarations of functions that have the same name. Overloaded functions must be distinguishable from each other through their parameter lists. (The types of the parameter list, together with the return type, is known as a function's &lt;em&gt;signature&lt;/em&gt;, but the return type cannot be used to disambiguate overloaded functions.) For example, we can have both of these functions in the same file:</source>
          <target state="translated">Python에서 함수 이름은 모듈 또는 클래스 내에서 고유해야합니다. Kotlin에서는 함수 를 &lt;em&gt;오버로드&lt;/em&gt; 할 수 있습니다. 이름이 같은 함수를 여러 번 선언 할 수 있습니다. 과부하 된 기능은 파라미터 목록을 통해 서로 구별 할 수 있어야합니다. (반환 유형과 함께 매개 변수 목록의 유형을 함수의 &lt;em&gt;시그니처&lt;/em&gt; 라고 하지만, 리턴 유형을 사용하여 오버로드 된 기능을 명확하게하는 데 사용할 수 없습니다.) 예를 들어,이 두 기능을 동일한 파일에 둘 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1c0f7f91981a6ecf109d226f21e3069c8aabc15a" translate="yes" xml:space="preserve">
          <source>In Python, the expression for a default value is evaluated once, at function definition time. That leads to this classic trap, where the developer hopes to get a new, empty list every time the function is called without a value for &lt;code&gt;numbers&lt;/code&gt;, but instead, the same list is being used every time:</source>
          <target state="translated">Python에서는 기본값 정의가 함수 정의시 한 번 평가됩니다. 이 고전적인 함정으로 연결됩니다. 개발자는 &lt;code&gt;numbers&lt;/code&gt; 값없이 함수가 호출 될 때마다 새로운 빈 목록을 얻으려고 하지만 매번 동일한 목록이 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="cd3d02ed8996a5f9eaf8b21aad3a4aaadb80de18" translate="yes" xml:space="preserve">
          <source>In a &lt;code&gt;when&lt;/code&gt; statement, if a branch is more than a single line, consider separating it from adjacent case blocks with a blank line:</source>
          <target state="translated">A의 &lt;code&gt;when&lt;/code&gt; 지점이 한 줄보다 더 많은 경우 문, 빈 라인과 인접한 경우 블록에서 분리 고려 :</target>
        </trans-unit>
        <trans-unit id="3a1b36cf0bd1ee7bba19fe0760cca000ad48b849" translate="yes" xml:space="preserve">
          <source>In a long-running application you might need fine-grained control on your background coroutines. For example, a user might have closed the page that launched a coroutine and now its result is no longer needed and its operation can be cancelled. The &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/launch.html&quot;&gt;launch&lt;/a&gt; function returns a &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-job/index.html&quot;&gt;Job&lt;/a&gt; that can be used to cancel the running coroutine:</source>
          <target state="translated">오래 실행되는 응용 프로그램에서는 백그라운드 코 루틴에 대한 세밀한 제어가 필요할 수 있습니다. 예를 들어, 사용자가 코 루틴을 시작한 페이지를 닫았을 때 결과가 더 이상 필요하지 않고 작업을 취소 할 수 있습니다. &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/launch.html&quot;&gt;발사&lt;/a&gt; 함수는 반환 &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-job/index.html&quot;&gt;작업&lt;/a&gt; 실행중인 코 루틴을 취소 할 수 있습니다 :</target>
        </trans-unit>
        <trans-unit id="e333c99581fbe52762649b5ab0c35c55ffcd093c" translate="yes" xml:space="preserve">
          <source>In a member of a &lt;a href=&quot;classes#inheritance&quot;&gt;class&lt;/a&gt;, &lt;em&gt;this&lt;/em&gt; refers to the current object of that class.</source>
          <target state="translated">(A)의 부재 &lt;a href=&quot;classes#inheritance&quot;&gt;클래스&lt;/a&gt; , &lt;em&gt;이&lt;/em&gt; 클래스의 현재 오브젝트를 말한다.</target>
        </trans-unit>
        <trans-unit id="15a56874c4866fabbe734af8a3fb102f28e0b12f" translate="yes" xml:space="preserve">
          <source>In a nutshell, you can use libraries such as &lt;a href=&quot;https://google.github.io/dagger/&quot;&gt;Dagger&lt;/a&gt; or &lt;a href=&quot;https://developer.android.com/topic/libraries/data-binding/index.html&quot;&gt;Data Binding&lt;/a&gt; in your Kotlin projects.</source>
          <target state="translated">간단히 말해서 Kotlin 프로젝트에서 &lt;a href=&quot;https://google.github.io/dagger/&quot;&gt;Dagger&lt;/a&gt; 또는 &lt;a href=&quot;https://developer.android.com/topic/libraries/data-binding/index.html&quot;&gt;Data Binding&lt;/a&gt; 과 같은 라이브러리를 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="5544e7dcfdd04da3eceaae6a1614ec1e4f550da9" translate="yes" xml:space="preserve">
          <source>In addition to &lt;strong&gt;out&lt;/strong&gt;, Kotlin provides a complementary variance annotation: &lt;strong&gt;in&lt;/strong&gt;. It makes a type parameter &lt;strong&gt;contravariant&lt;/strong&gt;: it can only be consumed and never produced. A good example of a contravariant type is &lt;code&gt;Comparable&lt;/code&gt;:</source>
          <target state="translated">뿐만 아니라 &lt;strong&gt;밖으로&lt;/strong&gt; , 코 틀린은 보완 분산 주석을 제공 : &lt;strong&gt;에&lt;/strong&gt; . 유형 매개 변수를 &lt;strong&gt;반 변형으로&lt;/strong&gt; 만듭니다 . 소비 만 가능하며 절대로 생산할 수 없습니다. contravariant 유형의 좋은 예입니다 &lt;code&gt;Comparable&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="c6329f208d955601deb101d4b33fc1acdf8accac" translate="yes" xml:space="preserve">
          <source>In addition to common operations for &lt;a href=&quot;collection-parts&quot;&gt;Retrieving Collection Parts&lt;/a&gt;, lists provide the &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/-list/sub-list&quot;&gt;&lt;code&gt;subList()&lt;/code&gt;&lt;/a&gt; function that returns a view of the specified elements range as a list. Thus, if an element of the original collection changes, it also changes in the previously created sublists and vice versa.</source>
          <target state="translated">&lt;a href=&quot;collection-parts&quot;&gt;콜렉션은 파트 콜렉션 검색에&lt;/a&gt; 대한 공통 조작 외에도 지정된 요소 범위의보기를 목록으로 리턴하는 &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/-list/sub-list&quot;&gt; &lt;code&gt;subList()&lt;/code&gt; &lt;/a&gt; 함수를 제공 합니다. 따라서 원본 컬렉션의 요소가 변경되면 이전에 만든 하위 목록에서도 변경되며 그 반대도 마찬가지입니다.</target>
        </trans-unit>
        <trans-unit id="9674c96ddd7757af7200ad4daae22ce260bb2047" translate="yes" xml:space="preserve">
          <source>In addition to removing elements, the &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/-mutable-list-iterator/index&quot;&gt;&lt;code&gt;MutableListIterator&lt;/code&gt;&lt;/a&gt; can also insert and replace elements while iterating the list.</source>
          <target state="translated">요소를 제거하는 것 외에도 &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/-mutable-list-iterator/index&quot;&gt; &lt;code&gt;MutableListIterator&lt;/code&gt; &lt;/a&gt; 는 목록을 반복하면서 요소를 삽입하고 바꿀 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="38a6e3c954dde3e3eb6edba41ad0b83ce52bd70c" translate="yes" xml:space="preserve">
          <source>In addition to scope functions, the standard library contains the functions &lt;code&gt;takeIf&lt;/code&gt; and &lt;code&gt;takeUnless&lt;/code&gt;. These functions let you embed checks of the object state in call chains.</source>
          <target state="translated">범위 함수 외에 표준 라이브러리에는 &lt;code&gt;takeIf&lt;/code&gt; 및 &lt;code&gt;takeUnless&lt;/code&gt; 함수가 포함되어 있습니다 . 이 함수를 사용하면 콜 체인에 객체 상태 확인을 포함시킬 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="acfd15e725bcfef6236f16c4782a0f3dc2126f4d" translate="yes" xml:space="preserve">
          <source>In addition to that, you can use &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.js/js&quot;&gt;KClass.js&lt;/a&gt; to access the &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.js/-js-class/index&quot;&gt;JsClass&lt;/a&gt; instance corresponding to the class. The &lt;code&gt;JsClass&lt;/code&gt; instance itself is a reference to the constructor function. This can be used to interoperate with JS functions that expect a reference to a constructor.</source>
          <target state="translated">또한 &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.js/js&quot;&gt;KClass.js&lt;/a&gt; 를 사용 하여 클래스에 해당하는 &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.js/-js-class/index&quot;&gt;JsClass&lt;/a&gt; 인스턴스 에 액세스 할 수 있습니다 . &lt;code&gt;JsClass&lt;/code&gt; 의 인스턴스 생성자 자체 기능에 대한 참조이다. 생성자에 대한 참조가 필요한 JS 함수와 상호 운용하는 데 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5594aa712f7692fd1a48c40180fe2939a4654a66" translate="yes" xml:space="preserve">
          <source>In addition to the &lt;code&gt;kotlin-gradle-plugin&lt;/code&gt; dependency shown above, you need to add a dependency on the Kotlin standard library:</source>
          <target state="translated">위에 표시된 &lt;code&gt;kotlin-gradle-plugin&lt;/code&gt; 종속성 외에도 Kotlin 표준 라이브러리에 대한 종속성을 추가해야합니다.</target>
        </trans-unit>
        <trans-unit id="ea7c2f23dd342e78eba03e7edea502fd9fbb6ef4" translate="yes" xml:space="preserve">
          <source>In addition to the build tasks, the Gradle build includes helpful tasks to run the application directly via &lt;code&gt;runDebugExecutableNative&lt;/code&gt; and &lt;code&gt;runReleaseExecutableNative&lt;/code&gt;.</source>
          <target state="translated">빌드 작업 외에도 Gradle 빌드에는 &lt;code&gt;runDebugExecutableNative&lt;/code&gt; 및 &lt;code&gt;runReleaseExecutableNative&lt;/code&gt; 를 통해 애플리케이션을 직접 실행하는 유용한 작업이 포함되어 있습니다 .</target>
        </trans-unit>
        <trans-unit id="1d5b7f7ad1a1556c56ce8e8eb4580dccfbc4c337" translate="yes" xml:space="preserve">
          <source>In addition to the collection modification operations described in &lt;a href=&quot;collection-write&quot;&gt;Collection Write Operations&lt;/a&gt;, &lt;a href=&quot;collections-overview#collection-types&quot;&gt;mutable&lt;/a&gt; lists support specific write operations. Such operations use the index to access elements to broaden the list modification capabilities.</source>
          <target state="translated">설명 컬렉션 수정 작업 외에도 &lt;a href=&quot;collection-write&quot;&gt;컬렉션 쓰기 작업&lt;/a&gt; , &lt;a href=&quot;collections-overview#collection-types&quot;&gt;변경 가능한&lt;/a&gt; 목록은 특정 쓰기 작업을 지원합니다. 이러한 작업은 색인을 사용하여 요소에 액세스하여 목록 수정 기능을 확장합니다.</target>
        </trans-unit>
        <trans-unit id="edff8af41569526ee6f34e250c39b84435f2d3a3" translate="yes" xml:space="preserve">
          <source>In addition to the command line compiler and IntelliJ IDEA, you can also build Kotlin projects with Ant, Maven, and Gradle.</source>
          <target state="translated">명령 행 컴파일러 및 IntelliJ IDEA 외에도 Ant, Maven 및 Gradle을 사용하여 Kotlin 프로젝트를 빌드 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="13939289a96ed1a1e50225139ac3fbd7b0bc2be9" translate="yes" xml:space="preserve">
          <source>In addition to the coroutine scope provided by different builders, it is possible to declare your own scope using &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/coroutine-scope.html&quot;&gt;coroutineScope&lt;/a&gt; builder. It creates a coroutine scope and does not complete until all launched children complete. The main difference between &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/run-blocking.html&quot;&gt;runBlocking&lt;/a&gt; and &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/coroutine-scope.html&quot;&gt;coroutineScope&lt;/a&gt; is that the latter does not block the current thread while waiting for all children to complete.</source>
          <target state="translated">다른 빌더가 제공하는 코 루틴 범위 외에도 &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/coroutine-scope.html&quot;&gt;coroutineScope&lt;/a&gt; 빌더를 사용하여 고유 한 범위를 선언 할 수 있습니다 . 코 루틴 범위를 작성하고 시작된 모든 하위 항목이 완료 될 때까지 완료되지 않습니다. &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/run-blocking.html&quot;&gt;runBlocking&lt;/a&gt; 과 &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/coroutine-scope.html&quot;&gt;coroutineScope&lt;/a&gt; 의 주요 차이점 은 후자가 모든 자식이 완료 될 때까지 기다리는 동안 현재 스레드를 차단하지 않는다는 것입니다.</target>
        </trans-unit>
        <trans-unit id="063fa2441ff30c74a010fc27ec5f2018d7ca4ef2" translate="yes" xml:space="preserve">
          <source>In addition to the output JavaScript file, the plugin by default creates an additional JS file with binary descriptors. This file is required if you're building a reusable library that other Kotlin modules can depend on, and should be distributed together with the result of translation. The generation is controlled by the &lt;code&gt;kotlinOptions.metaInfo&lt;/code&gt; option:</source>
          <target state="translated">출력 JavaScript 파일 외에도 플러그인은 기본적으로 이진 설명자가 포함 된 추가 JS 파일을 만듭니다. 이 파일은 다른 Kotlin 모듈이 의존 할 수있는 재사용 가능한 라이브러리를 작성하고 번역 결과와 함께 배포해야하는 경우에 필요합니다. 생성은 &lt;code&gt;kotlinOptions.metaInfo&lt;/code&gt; 옵션에 의해 제어됩니다 .</target>
        </trans-unit>
        <trans-unit id="4c8c93a8699f08045725902510444a7e2a812bf3" translate="yes" xml:space="preserve">
          <source>In addition, Rx does introduce a somewhat nicer approach to error handling.</source>
          <target state="translated">또한 Rx는 오류 처리에 대해 좀 더 멋진 접근 방식을 도입합니다.</target>
        </trans-unit>
        <trans-unit id="3434b058fadc1fd97196abc0cd226b5de0eff131" translate="yes" xml:space="preserve">
          <source>In addition, each of these also have a corresponding &lt;code&gt;{file}.meta.js&lt;/code&gt; meta file which will be used for reflection and other functionality.</source>
          <target state="translated">또한 이들 각각에는 리플렉션 및 기타 기능에 사용되는 해당 &lt;code&gt;{file}.meta.js&lt;/code&gt; 메타 파일도 있습니다.</target>
        </trans-unit>
        <trans-unit id="adf05c9d4a5ea22db47de9f6cd0f0a1f61618f95" translate="yes" xml:space="preserve">
          <source>In all cases, the C string is supposed to be encoded as UTF-8.</source>
          <target state="translated">모든 경우에 C 문자열은 UTF-8로 인코딩됩니다.</target>
        </trans-unit>
        <trans-unit id="2ad8a2cde437dc29e925bd2e2608bcf1efd428d2" translate="yes" xml:space="preserve">
          <source>In all respects, this is just the same as in Java since access to private properties with default getters and setters is optimized so that no function call overhead is introduced.</source>
          <target state="translated">기본적으로 getter 및 setter를 사용하여 개인 속성에 대한 액세스가 최적화되어 함수 호출 오버 헤드가 발생하지 않도록하기 때문에 모든면에서 Java와 동일합니다.</target>
        </trans-unit>
        <trans-unit id="af3fb6a2c1c95a7bcc9ea3f79ae7998d4cb1b27a" translate="yes" xml:space="preserve">
          <source>In an &lt;a href=&quot;extensions&quot;&gt;extension function&lt;/a&gt; or a &lt;a href=&quot;lambdas#function-literals-with-receiver&quot;&gt;function literal with receiver&lt;/a&gt;&lt;em&gt;this&lt;/em&gt; denotes the &lt;em&gt;receiver&lt;/em&gt; parameter that is passed on the left-hand side of a dot.</source>
          <target state="translated">에 &lt;a href=&quot;extensions&quot;&gt;확장 함수&lt;/a&gt; 또는 &lt;a href=&quot;lambdas#function-literals-with-receiver&quot;&gt;수신기 기능 리터럴 &lt;/a&gt;&lt;em&gt;이&lt;/em&gt; 나타낸다 &lt;em&gt;수신&lt;/em&gt; 점의 좌측에 전달되는 파라미터.</target>
        </trans-unit>
        <trans-unit id="751813b87d30d6501d1bf6ea23fd73a02ca28ea0" translate="yes" xml:space="preserve">
          <source>In an inline function definition, you can use &lt;code&gt;noinline&lt;/code&gt; in front of any function-typed parameter to prevent the lambda that will be passed to it from also being inlined.</source>
          <target state="translated">인라인 함수 정의에서 함수 유형 매개 변수 앞에 &lt;code&gt;noinline&lt;/code&gt; 을 사용 하여 전달되는 람다가 인라인되지 않도록 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="751fca68ff5e9efd6f13ba9f691a416e15e88e6e" translate="yes" xml:space="preserve">
          <source>In any lists, you can find the position of an element using the functions &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/index-of&quot;&gt;&lt;code&gt;indexOf()&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/last-index-of&quot;&gt;&lt;code&gt;lastIndexOf()&lt;/code&gt;&lt;/a&gt;. They return the first and the last position of an element equal to the given argument in the list. If there are no such elements, both functions return &lt;code&gt;-1&lt;/code&gt;.</source>
          <target state="translated">모든 목록에서 &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/index-of&quot;&gt; &lt;code&gt;indexOf()&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/last-index-of&quot;&gt; &lt;code&gt;lastIndexOf()&lt;/code&gt; &lt;/a&gt; 함수를 사용하여 요소의 위치를 ​​찾을 수 있습니다 . 리스트에서 주어진 인수와 같은 요소의 첫 번째와 마지막 위치를 리턴합니다. 그러한 요소가 없으면 두 함수 모두 &lt;code&gt;-1&lt;/code&gt; 을 반환 합니다.</target>
        </trans-unit>
        <trans-unit id="c3c35f058a2881495687f9b24556ffc42c9b3b89" translate="yes" xml:space="preserve">
          <source>In approach it's quite similar to Futures, but one can think of a Future as returning a discrete element, whereby Rx returns a stream. However, similar to the previous, it also introduces a complete new way of thinking about our programming model, famously phrased as</source>
          <target state="translated">접근 방식에서는 Future와 매우 유사하지만 Future를 개별 요소를 반환하는 것으로 생각할 수 있습니다. Rx는 스트림을 반환합니다. 그러나 이전과 마찬가지로 프로그래밍 모델에 대한 완전히 새로운 사고 방식을 소개합니다.</target>
        </trans-unit>
        <trans-unit id="afaa57d188a4de777b467f6dcde31f2f2cfb5700" translate="yes" xml:space="preserve">
          <source>In case if any two entries are mapped to the equal keys, the value of the latter one will overwrite the value associated with the former one.</source>
          <target state="translated">두 항목이 동일한 키에 매핑되는 경우 후자의 값이 이전의 값을 덮어 씁니다.</target>
        </trans-unit>
        <trans-unit id="ab773dc6434fe9e51f59bd2f39f7407e2e315f54" translate="yes" xml:space="preserve">
          <source>In case if the resource is being closed due to an exception occurred in &lt;a href=&quot;use#kotlin%24use%28kotlin.use.T%2C+kotlin.Function1%28%28kotlin.use.T%2C+kotlin.use.R%29%29%29%2Fblock&quot;&gt;block&lt;/a&gt;, and the closing also fails with an exception, the latter is added to the &lt;a href=&quot;http://docs.oracle.com/javase/8/docs/api/java/lang/Throwable.html#addSuppressed(java.lang.Throwable)&quot;&gt;suppressed&lt;/a&gt; exceptions of the former.</source>
          <target state="translated">&lt;a href=&quot;use#kotlin%24use%28kotlin.use.T%2C+kotlin.Function1%28%28kotlin.use.T%2C+kotlin.use.R%29%29%29%2Fblock&quot;&gt;block&lt;/a&gt; 에서 예외가 발생하여 자원이 닫히고 예외가 발생 하여 종료에 실패한 경우에는 전자가 &lt;a href=&quot;http://docs.oracle.com/javase/8/docs/api/java/lang/Throwable.html#addSuppressed(java.lang.Throwable)&quot;&gt;억제 된&lt;/a&gt; 예외에 추가됩니다 .</target>
        </trans-unit>
        <trans-unit id="a99d3de27a9334d7d61ccdc4fea1d3937e232802" translate="yes" xml:space="preserve">
          <source>In case if there are non-blank lines with no leading whitespace characters (no indent at all) then the common indent is 0, and therefore this function doesn't change the indentation.</source>
          <target state="translated">공백 문자 앞에 공백 문자가없는 경우 (공백 없음) 공통 들여 쓰기는 0이므로이 함수는 들여 쓰기를 변경하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="c60b20e0301bd757b71bb24ccc047d80b78f21b1" translate="yes" xml:space="preserve">
          <source>In case of a name conflict between the members of the dispatch receiver and the extension receiver, the extension receiver takes precedence. To refer to the member of the dispatch receiver you can use the &lt;a href=&quot;this-expressions#qualified&quot;&gt;qualified &lt;code&gt;this&lt;/code&gt; syntax&lt;/a&gt;.</source>
          <target state="translated">디스패치 수신기와 확장 수신기의 구성원간에 이름이 충돌하는 경우 확장 수신기가 우선합니다. 디스패치 수신자의 멤버를 참조하기 위해 &lt;a href=&quot;this-expressions#qualified&quot;&gt;규정 된 &lt;code&gt;this&lt;/code&gt; 구문을&lt;/a&gt; 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="2564f2a33e66657de3341732c5e625e51d4323de" translate="yes" xml:space="preserve">
          <source>In case of the extension property in a class, the instance of the class should be passed first and the instance of the extension receiver second.</source>
          <target state="translated">클래스의 확장 속성의 경우 클래스의 인스턴스가 먼저 전달되고 확장 수신기의 인스턴스가 두 번째로 전달되어야합니다.</target>
        </trans-unit>
        <trans-unit id="1a1fb30f33e29cde0e4a9adce651bb450975c80d" translate="yes" xml:space="preserve">
          <source>In case this type is based on an inner class, the returned list contains the type arguments provided for the innermost class first, then its outer class, and so on. For example, in the type &lt;code&gt;Outer&amp;lt;A, B&amp;gt;.Inner&amp;lt;C, D&amp;gt;&lt;/code&gt; the returned list is &lt;code&gt;[C, D, A, B]&lt;/code&gt;.</source>
          <target state="translated">이 유형이 내부 클래스를 기반으로하는 경우, 리턴 된 목록에는 가장 안쪽 클래스에 먼저 제공된 유형 인수가 포함 된 다음 외부 클래스 등이 포함됩니다. 예를 들어, &lt;code&gt;Outer&amp;lt;A, B&amp;gt;.Inner&amp;lt;C, D&amp;gt;&lt;/code&gt; 에서 리턴 된 목록은 &lt;code&gt;[C, D, A, B]&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="744293bc64c3188af17bab32f33333fe2cad85c9" translate="yes" xml:space="preserve">
          <source>In case you want only some of the lambdas passed to an inline function to be inlined, you can mark some of your function parameters with the &lt;code&gt;noinline&lt;/code&gt; modifier:</source>
          <target state="translated">인라인 함수로 전달 된 일부 람다 만 인라인되도록하려면 &lt;code&gt;noinline&lt;/code&gt; 수정자를 사용하여 일부 함수 매개 변수를 표시 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="816f79d2ddebc85fd82a80af3cc580e6eeb81694" translate="yes" xml:space="preserve">
          <source>In case you're wondering about how &lt;code&gt;use&lt;/code&gt;, which is a function, can just be followed by a block like that, see the section on &lt;a href=&quot;functional-programming#receivers&quot;&gt;DSL support&lt;/a&gt;.</source>
          <target state="translated">함수 인 &lt;code&gt;use&lt;/code&gt; 가 어떻게 그런 블록 뒤에 올 수 있는지 궁금하다면 &lt;a href=&quot;functional-programming#receivers&quot;&gt;DSL 지원&lt;/a&gt; 섹션을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="de1e14373afc30cdce829d5ccf1028c05a1345bf" translate="yes" xml:space="preserve">
          <source>In common code:</source>
          <target state="translated">일반적인 코드에서 :</target>
        </trans-unit>
        <trans-unit id="dbd13320c78fae25fd6f48673f77aea087d10896" translate="yes" xml:space="preserve">
          <source>In essence, this allows for the following code:</source>
          <target state="translated">본질적으로 이것은 다음 코드를 허용합니다.</target>
        </trans-unit>
        <trans-unit id="b797e297636a01e5f39faa44903e3922322a2f0c" translate="yes" xml:space="preserve">
          <source>In fact, for declaring properties and initializing them from the primary constructor, Kotlin has a concise syntax:</source>
          <target state="translated">실제로 Kotlin은 속성을 선언하고 기본 생성자에서 속성을 초기화하기 위해 간결한 구문을 가지고 있습니다.</target>
        </trans-unit>
        <trans-unit id="8575e5bc9be645637c35224eaab5422d26408ea8" translate="yes" xml:space="preserve">
          <source>In further sections, these concepts are described in more detail along with the DSL to configure them in a project.</source>
          <target state="translated">추가 섹션에서 이러한 개념은 프로젝트에서 구성하기 위해 DSL과 함께 자세히 설명됩니다.</target>
        </trans-unit>
        <trans-unit id="093d33db378ee271b0948a0579ab35389d4e97d5" translate="yes" xml:space="preserve">
          <source>In general, for small projects, we recommend converting all the files at once.</source>
          <target state="translated">일반적으로 소규모 프로젝트의 경우 모든 파일을 한 번에 변환하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="2ad6bf46a8b188e9bc3522dea93919d7678b502b" translate="yes" xml:space="preserve">
          <source>In general, identifiers may consist of letters, digits, and underscores, and may not begin with a digit. However, if you are writing code that e.g. autogenerates JSON based on identifiers and you want the JSON key to be a string that does not conform to these rules or that collides with a keyword, you can enclose it in backticks: &lt;code&gt;`I can't believe this is not an error!`&lt;/code&gt; is a valid identifier.</source>
          <target state="translated">일반적으로 식별자는 문자, 숫자 및 밑줄로 구성 될 수 있으며 숫자로 시작하지 않을 수 있습니다. 그러나 식별자를 기반으로 JSON을 자동 생성하는 코드를 작성하고 있고 JSON 키가 이러한 규칙을 따르지 않거나 키워드와 충돌하는 문자열이되기를 원하는 경우 백틱으로 묶을 &lt;code&gt;`I can't believe this is not an error!`&lt;/code&gt; 는 유효한 식별자입니다.</target>
        </trans-unit>
        <trans-unit id="def8cf1480d12ae42f29a02a77be00f6fa6a05e6" translate="yes" xml:space="preserve">
          <source>In general, if a certain syntactic construction in Kotlin is optional and highlighted by the IDE as redundant, you should omit it in your code. Do not leave unnecessary syntactic elements in code just &quot;for clarity&quot;.</source>
          <target state="translated">일반적으로 Kotlin의 특정 구문 구조가 선택적이고 IDE에서 중복으로 강조 표시되는 경우 코드에서 생략해야합니다. &quot;명확성을 위해&quot;불필요한 구문 요소를 코드에 두지 마십시오.</target>
        </trans-unit>
        <trans-unit id="01b3fb6a7b9e95b734c635ce49024c6d660e14c4" translate="yes" xml:space="preserve">
          <source>In general, to create an instance of such a class, we need to provide the type arguments:</source>
          <target state="translated">일반적으로 이러한 클래스의 인스턴스를 만들려면 형식 인수를 제공해야합니다.</target>
        </trans-unit>
        <trans-unit id="450c32ce21d7e1cf7d82473c6445b4ccee4985e3" translate="yes" xml:space="preserve">
          <source>In generated code, the Kotlin compiler keeps a &lt;em&gt;wrapper&lt;/em&gt; for each inline class. Inline class instances can be represented at runtime either as wrappers or as the underlying type. This is similar to how &lt;code&gt;Int&lt;/code&gt; can be &lt;a href=&quot;basic-types#representation&quot;&gt;represented&lt;/a&gt; either as a primitive &lt;code&gt;int&lt;/code&gt; or as the wrapper &lt;code&gt;Integer&lt;/code&gt;.</source>
          <target state="translated">생성 된 코드에서 Kotlin 컴파일러 는 각 인라인 클래스에 대한 &lt;em&gt;래퍼&lt;/em&gt; 를 유지합니다 . 인라인 클래스 인스턴스는 런타임시 랩퍼 또는 기본 유형으로 표시 될 수 있습니다. 이것은 &lt;code&gt;Int&lt;/code&gt; 가 프리미티브 &lt;code&gt;int&lt;/code&gt; 또는 래퍼 &lt;code&gt;Integer&lt;/code&gt; 로 &lt;a href=&quot;basic-types#representation&quot;&gt;표현&lt;/a&gt; 되는 방법과 유사합니다 .</target>
        </trans-unit>
        <trans-unit id="fd80bee1bf4ef4cc9fdfdeda947dd40e1e56db38" translate="yes" xml:space="preserve">
          <source>In lambda expressions, spaces should be used around the curly braces, as well as around the arrow which separates the parameters from the body. If a call takes a single lambda, it should be passed outside of parentheses whenever possible.</source>
          <target state="translated">람다 식에서 매개 변수를 본문과 구분하는 화살표뿐만 아니라 중괄호 주위에 공백을 사용해야합니다. 호출이 단일 람다를 사용하는 경우 가능할 때마다 괄호 외부로 전달해야합니다.</target>
        </trans-unit>
        <trans-unit id="80c8a890c9d273e819066140d09ce2d0bc285c7d" translate="yes" xml:space="preserve">
          <source>In lambdas which are short and not nested, it's recommended to use the &lt;code&gt;it&lt;/code&gt; convention instead of declaring the parameter explicitly. In nested lambdas with parameters, parameters should be always declared explicitly.</source>
          <target state="translated">짧고 중첩되지 않은 람다에서는 매개 변수를 명시 적으로 선언하는 대신 &lt;code&gt;it&lt;/code&gt; 규칙 을 사용하는 것이 좋습니다 . 매개 변수가있는 중첩 된 람다에서 매개 변수는 항상 명시 적으로 선언해야합니다.</target>
        </trans-unit>
        <trans-unit id="0f96591676e8e90474bcc2e9cbd0fe550a87c6d7" translate="yes" xml:space="preserve">
          <source>In long argument lists, put a line break after the opening parenthesis. Indent arguments by 4 spaces. Group multiple closely related arguments on the same line.</source>
          <target state="translated">긴 인수 목록에서 여는 괄호 뒤에 줄 바꿈을 넣으십시오. 인수를 4 칸 들여 쓰기 밀접하게 관련된 여러 인수를 같은 줄에 그룹화하십시오.</target>
        </trans-unit>
        <trans-unit id="e70f274fab45a9ad1cf0f5234b5a4c58fefd78f6" translate="yes" xml:space="preserve">
          <source>In many cases, one does not need to use explicit cast operators in Kotlin, because the compiler tracks the &lt;code&gt;is&lt;/code&gt;-checks and &lt;a href=&quot;#unsafe-cast-operator&quot;&gt;explicit casts&lt;/a&gt; for immutable values and inserts (safe) casts automatically when needed:</source>
          <target state="translated">대부분의 경우 컴파일러는 Kotlin에서 명시 적 캐스트 연산자를 사용할 필요가 없습니다. 컴파일러는 &lt;code&gt;is&lt;/code&gt; - checks 및 불변 값에 대한 &lt;a href=&quot;#unsafe-cast-operator&quot;&gt;명시 적 캐스트&lt;/a&gt; 를 추적하고 필요할 때 자동으로 삽입 (안전한) 캐스트를 추적하기 때문입니다 .</target>
        </trans-unit>
        <trans-unit id="d05a001b4fb4f64cd4a87d987f4f265545ae66a8" translate="yes" xml:space="preserve">
          <source>In mixed-language projects, Kotlin source files should reside in the same source root as the Java source files, and follow the same directory structure (each file should be stored in the directory corresponding to each package statement).</source>
          <target state="translated">혼합 언어 프로젝트에서 Kotlin 소스 파일은 Java 소스 파일과 동일한 소스 루트에 있어야하며 동일한 디렉토리 구조를 따라야합니다 (각 파일은 각 패키지 명령문에 해당하는 디렉토리에 저장되어야 함).</target>
        </trans-unit>
        <trans-unit id="a772373d726c1ea1dd1e4b5bd74e75bb5171d98d" translate="yes" xml:space="preserve">
          <source>In modules that don't provide their own API, such as application modules, you can use experimental APIs without propagating the experimental status to your code. In this case, mark your code with the &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin/-use-experimental/index&quot;&gt;@UseExperimental(Marker::class)&lt;/a&gt; annotation specifying the marker annotation of the experimental API:</source>
          <target state="translated">응용 프로그램 모듈과 같이 자체 API를 제공하지 않는 모듈에서는 실험 상태를 코드로 전파하지 않고도 실험용 API를 사용할 수 있습니다. 이 경우 실험용 API의 마커 주석을 지정하여 &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin/-use-experimental/index&quot;&gt;@UseExperimental (Marker :: class)&lt;/a&gt; 주석으로 코드를 표시하십시오 .</target>
        </trans-unit>
        <trans-unit id="cfed7f25e3bb00e2797542765d6c2ca96af68b87" translate="yes" xml:space="preserve">
          <source>In most cases, Kotlin follows the Java coding conventions.</source>
          <target state="translated">대부분의 경우 Kotlin은 Java 코딩 규칙을 따릅니다.</target>
        </trans-unit>
        <trans-unit id="d126b0359662ea6c66b61b9e3af53b0d85339044" translate="yes" xml:space="preserve">
          <source>In multiline mode the expressions &lt;code&gt;^&lt;/code&gt; and &lt;code&gt;$&lt;/code&gt; match just after or just before, respectively, a line terminator or the end of the input sequence.</source>
          <target state="translated">여러 줄 모드에서 &lt;code&gt;^&lt;/code&gt; 및 &lt;code&gt;$&lt;/code&gt; 표현식 은 각각 줄 종결 자 또는 입력 시퀀스의 끝 바로 직후 또는 바로 앞과 일치합니다.</target>
        </trans-unit>
        <trans-unit id="6667a323602babcf47c04e12460b410e75814d22" translate="yes" xml:space="preserve">
          <source>In order to assemble an application, we also need to include the Kotlin standard library, i.e. &lt;code&gt;kotlin.js&lt;/code&gt;, which was included as a dependency, and the other libraries if any.</source>
          <target state="translated">애플리케이션을 어셈블하려면 Kotlin 표준 라이브러리 (예 : 종속성으로 포함 된 &lt;code&gt;kotlin.js&lt;/code&gt; )와 다른 라이브러리 (있는 경우)도 포함해야합니다.</target>
        </trans-unit>
        <trans-unit id="034cc52464c28236e3f8c4183a0d3673ce621a3f" translate="yes" xml:space="preserve">
          <source>In order to avoid compatibility issues during an Xcode build, the plugin requires using a &lt;a href=&quot;https://docs.gradle.org/current/userguide/gradle_wrapper.html&quot;&gt;Gradle wrapper&lt;/a&gt;. To generate the wrapper automatically during execution of the &lt;code&gt;podspec&lt;/code&gt; task, run it with the parameter &lt;code&gt;-Pkotlin.native.cocoapods.generate.wrapper=true&lt;/code&gt;.</source>
          <target state="translated">Xcode 빌드 중에 호환성 문제를 피하려면 플러그인에 &lt;a href=&quot;https://docs.gradle.org/current/userguide/gradle_wrapper.html&quot;&gt;Gradle 래퍼를&lt;/a&gt; 사용해야합니다 . &lt;code&gt;podspec&lt;/code&gt; 태스크 실행 중 랩퍼를 자동으로 생성하려면 &lt;code&gt;-Pkotlin.native.cocoapods.generate.wrapper=true&lt;/code&gt; 매개 변수 를 사용하여 랩퍼를 실행하십시오 .</target>
        </trans-unit>
        <trans-unit id="4a047d1f6392366b3f681991fe461367b7be253f" translate="yes" xml:space="preserve">
          <source>In order to build a Kotlin project with Gradle, you should &lt;a href=&quot;#plugin-and-versions&quot;&gt;set up the &lt;em&gt;kotlin-gradle&lt;/em&gt; plugin&lt;/a&gt;, &lt;a href=&quot;#targeting-the-jvm&quot;&gt;apply it&lt;/a&gt; to your project and &lt;a href=&quot;#configuring-dependencies&quot;&gt;add &lt;em&gt;kotlin-stdlib&lt;/em&gt; dependencies&lt;/a&gt;. Those actions may also be performed automatically in IntelliJ IDEA by invoking &lt;strong&gt;Tools | Kotlin | Configure Kotlin&lt;/strong&gt; in &lt;strong&gt;Project&lt;/strong&gt; action.</source>
          <target state="translated">Gradle을 가진 코 틀린 프로젝트를 구축하기 위해, 당신은해야 &lt;a href=&quot;#plugin-and-versions&quot;&gt;셋업 &lt;em&gt;코 틀린-Gradle을&lt;/em&gt; 플러그인을&lt;/a&gt; , &lt;a href=&quot;#targeting-the-jvm&quot;&gt;적용&lt;/a&gt; 프로젝트와 &lt;a href=&quot;#configuring-dependencies&quot;&gt;추가 &lt;em&gt;- 다음 stdlib 코 틀린&lt;/em&gt; 종속성을&lt;/a&gt; . 이러한 조치는 IntelliJ IDEA에서 &lt;strong&gt;도구 | 코 틀린 | &lt;/strong&gt;&lt;strong&gt;프로젝트&lt;/strong&gt; 작업 에서 &lt;strong&gt;Kotlin&lt;/strong&gt; 을 &lt;strong&gt;구성하십시오&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="e347f51a9c40cc493b347c1bed8c2d5285726dad" translate="yes" xml:space="preserve">
          <source>In order to compile JavaScript code, you need to use the &lt;code&gt;js&lt;/code&gt; and &lt;code&gt;test-js&lt;/code&gt; goals for the &lt;code&gt;compile&lt;/code&gt; execution:</source>
          <target state="translated">JavaScript 코드를 컴파일 하려면 &lt;code&gt;compile&lt;/code&gt; 실행을 위해 &lt;code&gt;js&lt;/code&gt; 및 &lt;code&gt;test-js&lt;/code&gt; 목표 를 사용해야합니다 .</target>
        </trans-unit>
        <trans-unit id="7888ab5509b34a7615518c3269c358c32f2dd548" translate="yes" xml:space="preserve">
          <source>In order to debug the application using IntelliJ IDEA, we need to perform two steps:</source>
          <target state="translated">IntelliJ IDEA를 사용하여 응용 프로그램을 디버깅하려면 다음 두 단계를 수행해야합니다.</target>
        </trans-unit>
        <trans-unit id="0d60abc6454bf0506cb62dd1ac746f025ab62610" translate="yes" xml:space="preserve">
          <source>In order to generate these bindings, we need to create a library definition &lt;code&gt;.def&lt;/code&gt; file that contains some information about the headers we need to generate. In our case we want to use the famous &lt;code&gt;libcurl&lt;/code&gt; library to make some HTTP calls, so we'll create a file named &lt;code&gt;libcurl.def&lt;/code&gt; with the following contents</source>
          <target state="translated">이러한 바인딩 을 생성하려면 생성해야하는 헤더에 대한 정보가 포함 된 라이브러리 정의 &lt;code&gt;.def&lt;/code&gt; 파일 을 작성 해야합니다. 우리의 경우 유명한 &lt;code&gt;libcurl&lt;/code&gt; 라이브러리 를 사용하여 HTTP 호출을 만들고 &lt;code&gt;libcurl.def&lt;/code&gt; 때문에 다음 내용으로 libcurl.def 라는 파일을 만듭니다.</target>
        </trans-unit>
        <trans-unit id="ffbf97f9cc48e7603dadd7a45b25bf4f6b7e3989" translate="yes" xml:space="preserve">
          <source>In order to run, we need the corresponding WAR(s) for deploying. We can generate these using the &lt;em&gt;war&lt;/em&gt; task in Gradle which can easily be executed via the Gradle tool window in IntelliJ IDEA.</source>
          <target state="translated">실행하려면 배포 할 해당 WAR이 필요합니다. IntelliJ IDEA의 Gradle 도구 창을 통해 쉽게 실행할 수있는 Gradle 의 &lt;em&gt;war&lt;/em&gt; 태스크를 사용하여이를 생성 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="24dcbfd34df21e70b79c4b2191a485e90cc3e450" translate="yes" xml:space="preserve">
          <source>In order to share the changes across the project developers &lt;code&gt;.idea/codeStyle&lt;/code&gt; folder, it has to be committed to VCS. Alternatively &lt;strong&gt;kotlin.code.style&lt;/strong&gt;=&lt;strong&gt;obsolete&lt;/strong&gt; can be used for projects configured with Gradle or Maven.</source>
          <target state="translated">프로젝트 개발자 &lt;code&gt;.idea/codeStyle&lt;/code&gt; 폴더 에서 변경 사항을 공유하려면 VCS에 커밋해야합니다. 대안 &lt;strong&gt;kotlin.code.style&lt;/strong&gt; = &lt;strong&gt;쓸모가&lt;/strong&gt; Gradle을 구성 또는 메이븐 프로젝트에 사용될 수있다.</target>
        </trans-unit>
        <trans-unit id="155fb0f00f3221a063feea137fb0401c04ce9dd5" translate="yes" xml:space="preserve">
          <source>In order to share those changes for all project developers &lt;code&gt;.idea/codeStyle&lt;/code&gt; folder have to be committed to VCS.</source>
          <target state="translated">모든 프로젝트 개발자를 위해 이러한 변경 사항을 공유하려면 &lt;code&gt;.idea/codeStyle&lt;/code&gt; 폴더를 VCS에 커밋해야합니다.</target>
        </trans-unit>
        <trans-unit id="fa88cf692336fd455afd07788cc5c7d6ab06d938" translate="yes" xml:space="preserve">
          <source>In order to specify the module kind, we can add a configuration to our plugin as below</source>
          <target state="translated">모듈 종류를 지정하기 위해 다음과 같이 플러그인에 구성을 추가 할 수 있습니다</target>
        </trans-unit>
        <trans-unit id="59607fe0baf1ba77b3f9ca8983f516dc1d471c45" translate="yes" xml:space="preserve">
          <source>In order to support a potentially nullable type, the Objc header needs to define &lt;code&gt;myVal&lt;/code&gt; with a nullable return value.</source>
          <target state="translated">잠재적으로 널 입력 가능 유형을 지원하려면 Objc 헤더가 널 입력 가능 리턴 값으로 &lt;code&gt;myVal&lt;/code&gt; 을 정의해야 합니다.</target>
        </trans-unit>
        <trans-unit id="9aac89688353374371a7ae0f65a4346b1a58df3a" translate="yes" xml:space="preserve">
          <source>In order to use Gradle to target JavaScript, we need to use the &lt;code&gt;kotlin2js&lt;/code&gt; plugin as opposed to the &lt;code&gt;kotlin&lt;/code&gt; plugin.</source>
          <target state="translated">자바 스크립트를 대상으로 Gradle을을 사용하기 위해, 우리는 사용할 필요가 &lt;code&gt;kotlin2js&lt;/code&gt; 받는 반대로 플러그인 &lt;code&gt;kotlin&lt;/code&gt; 플러그인을.</target>
        </trans-unit>
        <trans-unit id="33526a8ed38f3fde7c6b4f6af71779367c169bbc" translate="yes" xml:space="preserve">
          <source>In order to use Kotlin with node.js, we need to set the compiler option to use CommonJS. Once we do that, the output of the application should be accessible using the node module system.</source>
          <target state="translated">node.js와 함께 Kotlin을 사용하려면 CommonJS를 사용하도록 컴파일러 옵션을 설정해야합니다. 그렇게하면 노드 모듈 시스템을 사용하여 응용 프로그램의 출력에 액세스 할 수 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="5bdfd7a958cb3b5e6a62acec15106d2a72aa846c" translate="yes" xml:space="preserve">
          <source>In order to use coroutines as well as follow the examples in this guide, you need to add a dependency on &lt;code&gt;kotlinx-coroutines-core&lt;/code&gt; module as explained &lt;a href=&quot;https://github.com/kotlin/kotlinx.coroutines/blob/master/README.md#using-in-your-projects&quot;&gt;in the project README&lt;/a&gt;.</source>
          <target state="translated">코 루틴을 사용하고이 안내서의 예를 따르려면 &lt;a href=&quot;https://github.com/kotlin/kotlinx.coroutines/blob/master/README.md#using-in-your-projects&quot;&gt;README 프로젝트에&lt;/a&gt; 설명 된 대로 &lt;code&gt;kotlinx-coroutines-core&lt;/code&gt; 모듈 에 대한 종속성을 추가해야합니다 .</target>
        </trans-unit>
        <trans-unit id="1cc60ead46c9defc457295413372bae706d2254f" translate="yes" xml:space="preserve">
          <source>In order to use something from a package, it is sufficient to use the package name to fully qualify the name of the symbol at the place where you use the symbol:</source>
          <target state="translated">패키지에서 무언가를 사용하려면 패키지 이름을 사용하여 심볼을 사용하는 위치에서 심볼 이름을 완전히 규정하는 것으로 충분합니다.</target>
        </trans-unit>
        <trans-unit id="9abc8ef7836ac20fac6436adb16fe6c5da1f6518" translate="yes" xml:space="preserve">
          <source>In order to use this, we also need to include the Kotlin standard library in our application, i.e. &lt;code&gt;kotlin.js&lt;/code&gt;, which was included as a dependency. By default, Maven does not expand the JAR as part of the build process, so we would need to add an additional step in our build to do so.</source>
          <target state="translated">이를 사용하려면 응용 프로그램에 Kotlin 표준 라이브러리 (예 : 종속성으로 포함 된 &lt;code&gt;kotlin.js&lt;/code&gt; )도 포함해야합니다. 기본적으로 Maven은 빌드 프로세스의 일부로 JAR을 확장하지 않으므로 빌드에 추가 단계를 추가해야합니다.</target>
        </trans-unit>
        <trans-unit id="a5c6ba86278357c55cc58dbde4e4e54ec8ffad3f" translate="yes" xml:space="preserve">
          <source>In other words, inline classes introduce a truly &lt;em&gt;new&lt;/em&gt; type, contrary to type aliases which only introduce an alternative name (alias) for an existing type:</source>
          <target state="translated">다시 말해, 인라인 클래스 는 기존 유형에 대한 대체 이름 (별칭) 만 도입하는 유형 별명과 달리 진정으로 &lt;em&gt;새로운&lt;/em&gt; 유형을 도입합니다.</target>
        </trans-unit>
        <trans-unit id="2fcd261cf566bdf17c9a0226c120616065441d92" translate="yes" xml:space="preserve">
          <source>In our DSL all the tag classes extend the same superclass &lt;code&gt;Tag&lt;/code&gt;. It's enough to annotate only the superclass with &lt;code&gt;@HtmlTagMarker&lt;/code&gt; and after that the Kotlin compiler will treat all the inherited classes as annotated:</source>
          <target state="translated">DSL에서 모든 태그 클래스는 동일한 수퍼 클래스 &lt;code&gt;Tag&lt;/code&gt; 를 확장합니다 . &lt;code&gt;@HtmlTagMarker&lt;/code&gt; 로 수퍼 클래스에만 주석을 달면 충분하며 그 후에 Kotlin 컴파일러는 상속 된 모든 클래스를 주석이 달린 것으로 취급합니다.</target>
        </trans-unit>
        <trans-unit id="055ba8d22e98a479f59a07d7a075048bb0a20fe4" translate="yes" xml:space="preserve">
          <source>In our example, we have &lt;code&gt;main&lt;/code&gt; function that is turned into a coroutine using &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/run-blocking.html&quot;&gt;runBlocking&lt;/a&gt; coroutine builder. Every coroutine builder, including &lt;code&gt;runBlocking&lt;/code&gt;, adds an instance of &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/coroutine-scope.html&quot;&gt;CoroutineScope&lt;/a&gt; to the scope of its code block. We can launch coroutines in this scope without having to &lt;code&gt;join&lt;/code&gt; them explicitly, because an outer coroutine (&lt;code&gt;runBlocking&lt;/code&gt; in our example) does not complete until all the coroutines launched in its scope complete. Thus, we can make our example simpler:</source>
          <target state="translated">이 예에서는 &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/run-blocking.html&quot;&gt;runBlocking&lt;/a&gt; 코 루틴 빌더를 사용하여 코 루틴으로 변환되는 &lt;code&gt;main&lt;/code&gt; 기능이 있습니다. &lt;code&gt;runBlocking&lt;/code&gt; 을 포함한 모든 코 루틴 빌더 는 코드 블록의 범위에 &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/coroutine-scope.html&quot;&gt;CoroutineScope&lt;/a&gt; 인스턴스를 추가합니다 . 범위에서 실행 된 모든 코 루틴이 완료 될 때까지 외부 코 루틴 (이 예에서는 &lt;code&gt;runBlocking&lt;/code&gt; )이 완료되지 않으므로이 범위에서 코 루틴을 명시 적으로 &lt;code&gt;join&lt;/code&gt; 하지 않고도 실행할 수 있습니다 . 따라서 예제를 더 단순하게 만들 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="99c50d394fc235f8eeca8f1ea6662b1ec125d6bd" translate="yes" xml:space="preserve">
          <source>In our main function we create activity, call our test &lt;code&gt;doSomething&lt;/code&gt; function, and destroy activity after 500ms. This cancels all the coroutines that were launched which we can confirm by noting that it does not print onto the screen anymore if we wait:</source>
          <target state="translated">우리의 주요 함수에서 우리는 활동을 생성하고, 테스트 &lt;code&gt;doSomething&lt;/code&gt; 함수를 호출하고 , 500ms 후에 활동을 파괴합니다. 이렇게하면 시작된 모든 코 루틴이 취소되며, 기다릴 경우 더 이상 화면에 인쇄되지 않음을 확인하여 확인할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4e33cfe3a798666f120dafc2300d3a53a316781b" translate="yes" xml:space="preserve">
          <source>In particular, when defining extension functions for a class which are relevant for all clients of this class, put them in the same file where the class itself is defined. When defining extension functions that make sense only for a specific client, put them next to the code of that client. Do not create files just to hold &quot;all extensions of Foo&quot;.</source>
          <target state="translated">특히이 클래스의 모든 클라이언트와 관련된 클래스의 확장 함수를 정의 할 때는 클래스 자체가 정의 된 동일한 파일에 추가하십시오. 특정 클라이언트에게만 적합한 확장 기능을 정의 할 때는 해당 클라이언트의 코드 옆에 두십시오. &quot;Foo의 모든 확장명&quot;을 담기 위해 파일을 만들지 마십시오.</target>
        </trans-unit>
        <trans-unit id="2683ff56288a092d85a9176c5ad7bb38fce09a9b" translate="yes" xml:space="preserve">
          <source>In practice some changes can't be accurately detected at compile time, so no warnings can be reported, but at least the users will be notified through Release notes of version A that a change is coming in version B.</source>
          <target state="translated">실제로 컴파일시 일부 변경 사항을 정확하게 감지 할 수 없으므로 경고를보고 할 수 없지만 최소한 버전 A의 릴리스 정보를 통해 버전 B에서 변경 사항이 있음을 사용자에게 알립니다.</target>
        </trans-unit>
        <trans-unit id="1e5d38479fe45d55c10d169d2b3903a772bc6139" translate="yes" xml:space="preserve">
          <source>In practice, quite a bit of code is affected, so this can be considered a major code style update.</source>
          <target state="translated">실제로는 약간의 코드가 영향을 받기 때문에 주요 코드 스타일 업데이트로 간주 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="57e5b70de31acdb27d8d2c67fea04b3d16fdd8a7" translate="yes" xml:space="preserve">
          <source>In practice, thread confinement is performed in large chunks, e.g. big pieces of state-updating business logic are confined to the single thread. The following example does it like that, running each coroutine in the single-threaded context to start with.</source>
          <target state="translated">실제로 스레드 제한은 큰 청크로 수행됩니다. 예를 들어 상태 업데이트 비즈니스 로직의 큰 부분이 단일 스레드로 제한됩니다. 다음 예제는 단일 스레드 컨텍스트에서 각 코 루틴을 실행하여 시작합니다.</target>
        </trans-unit>
        <trans-unit id="40969ff7e4fed85e58f626291a67f5273e20a573" translate="yes" xml:space="preserve">
          <source>In progressive mode, some fixes in language semantics can arrive immediately. All these fixes have two important properties:</source>
          <target state="translated">프로그레시브 모드에서는 언어 시맨틱의 일부 수정 사항이 즉시 도착할 수 있습니다. 이 모든 수정 사항에는 두 가지 중요한 특성이 있습니다.</target>
        </trans-unit>
        <trans-unit id="d10877f2d49f4fb7859f1ddc63051feb0cebe60b" translate="yes" xml:space="preserve">
          <source>In pure Kotlin projects, the recommended directory structure is to follow the package structure with the common root package omitted (e.g. if all the code in the project is in the &quot;org.example.kotlin&quot; package and its subpackages, files with the &quot;org.example.kotlin&quot; package should be placed directly under the source root, and files in &quot;org.example.kotlin.foo.bar&quot; should be in the &quot;foo/bar&quot; subdirectory of the source root).</source>
          <target state="translated">순수한 Kotlin 프로젝트에서 권장되는 디렉토리 구조는 공통 루트 패키지가 생략 된 패키지 구조를 따르는 것입니다 (예 : 프로젝트의 모든 코드가 &quot;org.example.kotlin&quot;패키지 및 하위 패키지에있는 경우 &quot;org .example.kotlin &quot;패키지는 소스 루트 바로 아래에 배치해야하며&quot;org.example.kotlin.foo.bar &quot;의 파일은 소스 루트의&quot;foo / bar &quot;하위 디렉토리에 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="7a5be9888b7ba5a318d3261861baf4d32fa8861a" translate="yes" xml:space="preserve">
          <source>In short: &lt;em&gt;think carefully through your declarations of integers, and be absolutely certain that the value will never ever need to be larger than the limits of the type!&lt;/em&gt; If you need an integer of unlimited size, use the non-primitive type &lt;code&gt;BigInteger&lt;/code&gt;.</source>
          <target state="translated">간단히 말하면 &lt;em&gt;정수 선언을 신중하게 생각하고 값이 유형의 한계보다 클 필요는 없다는 것을 절대적으로 확신하십시오! &lt;/em&gt;무제한 크기의 정수가 필요한 경우 기본이 아닌 유형 &lt;code&gt;BigInteger&lt;/code&gt; 를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="4a3b75ce2c9b15401d05148e77e0306873596e7e" translate="yes" xml:space="preserve">
          <source>In situations like this we can use the &lt;code&gt;dynamic&lt;/code&gt; type, which allows us to work with dynamic types when targeting JavaScript. The following variable is declared as &lt;code&gt;dynamic&lt;/code&gt; meaning that whatever we invoke on it will not result in a compile-time error:</source>
          <target state="translated">이와 같은 상황에서는 &lt;code&gt;dynamic&lt;/code&gt; 유형을 사용하여 JavaScript를 타겟팅 할 때 동적 유형으로 작업 할 수 있습니다. 다음 변수는 &lt;code&gt;dynamic&lt;/code&gt; 으로 선언되어 우리가 호출하는 것이 컴파일 타임 오류를 일으키지 않음을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="55bd36b85c22e6a1c4d10234a638ea714c3940ad" translate="yes" xml:space="preserve">
          <source>In some cases (for example, to support overloads), Kotlin compiler mangles names of generated functions and attributes in JavaScript code. To control the generated names, you can use the &lt;code&gt;@JsName&lt;/code&gt; annotation:</source>
          <target state="translated">일부 경우 (예 : 과부하 지원) Kotlin 컴파일러는 생성 된 함수 및 속성 이름을 JavaScript 코드로 맹 글링합니다. 생성 된 이름을 제어하기 위해 &lt;code&gt;@JsName&lt;/code&gt; 어노테이션을 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="8f1f57175de66b286d8ac98729c81851940d41f3" translate="yes" xml:space="preserve">
          <source>In some cases functions with no arguments might be interchangeable with read-only properties. Although the semantics are similar, there are some stylistic conventions on when to prefer one to another.</source>
          <target state="translated">경우에 따라 인수가없는 함수는 읽기 전용 속성과 호환 될 수 있습니다. 시맨틱은 유사하지만 서로 선호하는시기에 대한 스타일 규칙이 있습니다.</target>
        </trans-unit>
        <trans-unit id="4526b2f446cfa690eb7c5baadbe7c8dea021438f" translate="yes" xml:space="preserve">
          <source>In some ways, this is easier to read because the operations are specified in the order they are applied to the values. The result will be an immutable &lt;code&gt;List&amp;lt;T&amp;gt;&lt;/code&gt;, where &lt;code&gt;T&lt;/code&gt; is whichever type is produced by the transformations you use (in this case, &lt;code&gt;String&lt;/code&gt;). If you need a mutable list, call &lt;code&gt;toMutableList()&lt;/code&gt; at the end. If you want a set, call &lt;code&gt;toSet()&lt;/code&gt; or &lt;code&gt;toMutableSet()&lt;/code&gt; at the end. If you want to transform a collection into a map, call &lt;code&gt;associateBy()&lt;/code&gt;, which takes two lambdas that specify how to extract the key and the value from each element: &lt;code&gt;people.associateBy({it.ssn}, {it.name})&lt;/code&gt; (you can omit the second lambda if you want the entire element to be the value, and you can call &lt;code&gt;toMutableMap()&lt;/code&gt; at the end if you want the result to be mutable).</source>
          <target state="translated">어떤 방식으로, 조작이 값에 적용되는 순서대로 지정되므로 읽기가 더 쉽습니다. 결과는 불변 인 &lt;code&gt;List&amp;lt;T&amp;gt;&lt;/code&gt; . 여기서 &lt;code&gt;T&lt;/code&gt; 는 사용하는 변환에 의해 생성되는 유형 (이 경우 &lt;code&gt;String&lt;/code&gt; )입니다. 변경 가능한 목록이 필요한 경우 마지막에 &lt;code&gt;toMutableList()&lt;/code&gt; 를 호출 하십시오. 세트를 원하면 &lt;code&gt;toSet()&lt;/code&gt; 또는 &lt;code&gt;toMutableSet()&lt;/code&gt; 을 호출 하십시오. 콜렉션을 맵으로 변환하려는 경우 &lt;code&gt;associateBy()&lt;/code&gt; 호출하십시오.이 메소드 는 각 요소에서 키와 값을 추출하는 방법을 지정하는 두 개의 람다를 사용합니다. &lt;code&gt;people.associateBy({it.ssn}, {it.name})&lt;/code&gt; 전체 요소를 값으로 사용하려면 두 번째 람다를 생략 하고 결과를 변경하려면 끝에 &lt;code&gt;toMutableMap()&lt;/code&gt; 을 호출 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="482c7a83b939d337af8bf0cb41a70749c1cb67ed" translate="yes" xml:space="preserve">
          <source>In spite of the &lt;code&gt;object&lt;/code&gt; keyword being used, a new instance of the anonymous class will be created whenever the object expression is evaluated.</source>
          <target state="translated">사용중인 &lt;code&gt;object&lt;/code&gt; 키워드 에도 불구하고 객체 표현식이 평가 될 때마다 익명 클래스의 새 인스턴스가 생성됩니다.</target>
        </trans-unit>
        <trans-unit id="10fed13cfcbccf5e09d7648e3ceabcf9a0d8e2f5" translate="yes" xml:space="preserve">
          <source>In spite of this syntactical convenience, the companion object is a proper object on its own, and can have its own supertypes - and you can assign it to a variable and pass it around. If you're integrating with Java code and need a true &lt;code&gt;static&lt;/code&gt; member, you can &lt;a href=&quot;annotations&quot;&gt;annotate&lt;/a&gt; a member inside a companion object with &lt;code&gt;@JvmStatic&lt;/code&gt;.</source>
          <target state="translated">이 구문상의 편의성에도 불구하고 동반 객체는 자체적으로 적절한 객체이며 자체 슈퍼 유형을 가질 수 있으며 변수에 할당하고 전달할 수 있습니다. Java 코드와 통합하고 진정한 &lt;code&gt;static&lt;/code&gt; 멤버 가 필요한 경우 &lt;code&gt;@JvmStatic&lt;/code&gt; 을 사용 하여 컴패니언 객체 내부에 멤버에 &lt;a href=&quot;annotations&quot;&gt;주석을 달&lt;/a&gt; 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="8be34c3c318a79f1a61390cd86ad3bb03f42aee7" translate="yes" xml:space="preserve">
          <source>In subsequent tutorials we'll show how you can influence the files generated, for example, change location, prefix and suffixes, and how you can work with modules.</source>
          <target state="translated">다음 자습서에서는 위치, 접두사 및 접미사 변경과 같이 생성 된 파일에 영향을 줄 수있는 방법과 모듈 작업 방법을 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="de0700bb726b0915ca84006a652a9bb020053b41" translate="yes" xml:space="preserve">
          <source>In tests (and only in tests), it's acceptable to use method names with spaces enclosed in backticks. (Note that such method names are currently not supported by the Android runtime.) Underscores in method names are also allowed in test code.</source>
          <target state="translated">테스트 (및 테스트에서만)에는 공백으로 백틱으로 묶인 메소드 이름을 사용할 수 있습니다. (이러한 메소드 이름은 현재 Android 런타임에서 지원되지 않습니다.) 메소드 이름의 밑줄도 테스트 코드에서 허용됩니다.</target>
        </trans-unit>
        <trans-unit id="e4ad3e9e93913c50444eb70a3c6d491b3cf74240" translate="yes" xml:space="preserve">
          <source>In that case you need to use the spread operator &lt;code&gt;*&lt;/code&gt; to pass the &lt;code&gt;IntArray&lt;/code&gt;:</source>
          <target state="translated">이 경우 스프레드 연산자 &lt;code&gt;*&lt;/code&gt; 를 사용 하여 &lt;code&gt;IntArray&lt;/code&gt; 를 전달해야합니다 .</target>
        </trans-unit>
        <trans-unit id="dfa4bedab09a124fc51fd33f0b20a721f3509f7a" translate="yes" xml:space="preserve">
          <source>In the &lt;a href=&quot;#enabling-experimental-features&quot;&gt;experimental mode&lt;/a&gt;, you can specify any variant name (not only flavor), e.g. &lt;code&gt;freeDebug&lt;/code&gt; or &lt;code&gt;freeRelease&lt;/code&gt; will work as well.</source>
          <target state="translated">에서 &lt;a href=&quot;#enabling-experimental-features&quot;&gt;실험 모드&lt;/a&gt; , 당신은 어떤 변형 이름 (뿐만 아니라 맛), 예를 지정할 수 있습니다 &lt;code&gt;freeDebug&lt;/code&gt; 을 하거나 &lt;code&gt;freeRelease&lt;/code&gt; 는 잘 작동합니다.</target>
        </trans-unit>
        <trans-unit id="34502d3bacebdc9ab51090cbc1ee8b5aa02dcb57" translate="yes" xml:space="preserve">
          <source>In the &lt;code&gt;libnative_api.h&lt;/code&gt;, we'll find the following code. We will discuss the code in parts to make it easier to understand.</source>
          <target state="translated">에서 &lt;code&gt;libnative_api.h&lt;/code&gt; , 우리는 다음과 같은 코드를 찾을 수 있습니다. 이해하기 쉽도록 코드를 부분적으로 살펴 보겠습니다.</target>
        </trans-unit>
        <trans-unit id="97cbe1bbd40fde30fcff61322aab402c1acd97ce" translate="yes" xml:space="preserve">
          <source>In the Gradle dependencies you use add the &lt;code&gt;kotlin-kapt&lt;/code&gt; plugin and replace &lt;code&gt;annotationProcessor&lt;/code&gt; with &lt;code&gt;kapt&lt;/code&gt;:</source>
          <target state="translated">Gradle 의존성에서 &lt;code&gt;kotlin-kapt&lt;/code&gt; 플러그인을 추가하고 &lt;code&gt;annotationProcessor&lt;/code&gt; 를 &lt;code&gt;kapt&lt;/code&gt; 로 대체하십시오 .</target>
        </trans-unit>
        <trans-unit id="a87144873c9b9ee0a65c1c2fda83f3948fb32756" translate="yes" xml:space="preserve">
          <source>In the JavaScript world, a completely different set of APIs is availiable, so one could instead implement logging to the console:</source>
          <target state="translated">JavaScript 세계에서는 완전히 다른 API 세트를 사용할 수 있으므로 대신 콘솔에 로깅을 구현할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="952c75185ceff6a4ea2264e236a32b30e1121e70" translate="yes" xml:space="preserve">
          <source>In the code above, the parameter &lt;code&gt;combine&lt;/code&gt; has a &lt;a href=&quot;#function-types&quot;&gt;function type&lt;/a&gt;&lt;code&gt;(R, T) -&amp;gt; R&lt;/code&gt;, so it accepts a function that takes two arguments of types &lt;code&gt;R&lt;/code&gt; and &lt;code&gt;T&lt;/code&gt; and returns a value of type &lt;code&gt;R&lt;/code&gt;. It is &lt;a href=&quot;#invoking-a-function-type-instance&quot;&gt;invoked&lt;/a&gt; inside the &lt;em&gt;for&lt;/em&gt;-loop, and the return value is then assigned to &lt;code&gt;accumulator&lt;/code&gt;.</source>
          <target state="translated">위의 코드에서, 매개 변수는 &lt;code&gt;combine&lt;/code&gt; 갖는 &lt;a href=&quot;#function-types&quot;&gt;기능 타입 &lt;/a&gt; &lt;code&gt;(R, T) -&amp;gt; R&lt;/code&gt; 가 수용되도록 타입의 두 개의 인자를 취하는 함수 &lt;code&gt;R&lt;/code&gt; 과 &lt;code&gt;T&lt;/code&gt; 형의 복귀 값 &lt;code&gt;R&lt;/code&gt; 을 . 그것은되는 &lt;a href=&quot;#invoking-a-function-type-instance&quot;&gt;호출&lt;/a&gt; 공진 영역 &lt;em&gt;에 대한&lt;/em&gt; -loop 및 반환 값은 다음에 할당 된 &lt;code&gt;accumulator&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="983dc81454e62d4d8dfeb15d4d6704ae3670a9b1" translate="yes" xml:space="preserve">
          <source>In the example above, the production sources for the JVM target are compiled by its &lt;code&gt;main&lt;/code&gt; compilation and therefore include the sources and dependencies from the source sets &lt;code&gt;jvmMain&lt;/code&gt; and &lt;code&gt;commonMain&lt;/code&gt; (due to the &lt;em&gt;depends on&lt;/em&gt; relation):</source>
          <target state="translated">위의 예에서 JVM 대상의 프로덕션 소스는 &lt;code&gt;main&lt;/code&gt; 컴파일에 의해 컴파일되므로 소스 세트 &lt;code&gt;jvmMain&lt;/code&gt; 및 &lt;code&gt;commonMain&lt;/code&gt; 의 소스 및 종속성 ( 관계에 &lt;em&gt;따라 달라짐&lt;/em&gt; )이 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="92a4732d4ba58bb8eb4b7a1a153809f54718cd39" translate="yes" xml:space="preserve">
          <source>In the example below, we assume that there is a &lt;code&gt;DbModel&lt;/code&gt; base class, and that every subclass has got a parameterless primary constructor. In the inline function, &lt;code&gt;T&lt;/code&gt; is reified, so we can get the class metadata. We pass this to the function that does the real work of talking to the database.</source>
          <target state="translated">아래 예제에서는 &lt;code&gt;DbModel&lt;/code&gt; 기본 클래스가 있고 모든 하위 클래스에 매개 변수가없는 기본 생성자 가 있다고 가정합니다 . 인라인 함수에서 &lt;code&gt;T&lt;/code&gt; 가 구체화되어 클래스 메타 데이터를 얻을 수 있습니다. 우리는 이것을 데이터베이스와 대화하는 실제 작업을 수행하는 함수에 전달합니다.</target>
        </trans-unit>
        <trans-unit id="f9725b5629cf5c05b1dabad8df3abc795d27f14a" translate="yes" xml:space="preserve">
          <source>In the example we have the most popular ways to pass or receive a string in the C language. We should take the return of &lt;code&gt;return_string&lt;/code&gt; with care. In general, it is best to make sure we use the right function to dispose the returned &lt;code&gt;char*&lt;/code&gt; with the right &lt;code&gt;free(..)&lt;/code&gt; function call.</source>
          <target state="translated">이 예에서는 C 언어로 문자열을 전달하거나받는 가장 일반적인 방법이 있습니다. &lt;code&gt;return_string&lt;/code&gt; 을주의 해서 반환해야 합니다. 일반적으로 올바른 함수를 사용하여 반환 된 &lt;code&gt;char*&lt;/code&gt; 를 올바른 &lt;code&gt;free(..)&lt;/code&gt; 함수 호출 로 처리하는 것이 가장 좋습니다 .</target>
        </trans-unit>
        <trans-unit id="45b64e498fcd11490ca143779a88435b7d9e0b0c" translate="yes" xml:space="preserve">
          <source>In the following example, &lt;code&gt;findViewById()&lt;/code&gt; is only invoked once:</source>
          <target state="translated">다음 예제에서 &lt;code&gt;findViewById()&lt;/code&gt; 는 한 번만 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="8cf0c93c6e85cb80e10b5e71f71e2e6899fc70c7" translate="yes" xml:space="preserve">
          <source>In the generated Kotlin declarations, we see that &lt;code&gt;str&lt;/code&gt; is represented as &lt;code&gt;CValuesRef&amp;lt;ByteVar/&amp;gt;?&lt;/code&gt;. The type is nullable, and we can simply pass Kotlin &lt;code&gt;null&lt;/code&gt; as the parameter value.</source>
          <target state="translated">생성 된 Kotlin 선언에서 &lt;code&gt;str&lt;/code&gt; 이 &lt;code&gt;CValuesRef&amp;lt;ByteVar/&amp;gt;?&lt;/code&gt; . 유형은 nullable이며 Kotlin &lt;code&gt;null&lt;/code&gt; 을 매개 변수 값으로 전달할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="6ffd682e74db1be23092050eecf5e03af23b3260" translate="yes" xml:space="preserve">
          <source>In the generated code, the &lt;code&gt;provideDelegate&lt;/code&gt; method is called to initialize the auxiliary &lt;code&gt;prop$delegate&lt;/code&gt; property. Compare the generated code for the property declaration &lt;code&gt;val prop: Type by MyDelegate()&lt;/code&gt; with the generated code &lt;a href=&quot;delegated-properties#translation-rules&quot;&gt;above&lt;/a&gt; (when the &lt;code&gt;provideDelegate&lt;/code&gt; method is not present):</source>
          <target state="translated">생성 된 코드에서 &lt;code&gt;provideDelegate&lt;/code&gt; 메소드가 호출되어 보조 &lt;code&gt;prop$delegate&lt;/code&gt; 특성 을 초기화합니다 . 속성 선언 &lt;code&gt;val prop: Type by MyDelegate()&lt;/code&gt; 에 대해 생성 된 코드와 &lt;a href=&quot;delegated-properties#translation-rules&quot;&gt;위&lt;/a&gt; 의 생성 된 코드를 비교하십시오 ( &lt;code&gt;provideDelegate&lt;/code&gt; 메소드가없는 경우).</target>
        </trans-unit>
        <trans-unit id="f86f30c4d84e613891c93b386289b1fcc35ce4d5" translate="yes" xml:space="preserve">
          <source>In the last line &lt;code&gt;button&lt;/code&gt; is referenced by &lt;code&gt;id&lt;/code&gt; using the &lt;a href=&quot;android-plugin&quot;&gt;Kotlin Android Extensions&lt;/a&gt; plugin. Consider using this plugin as an alternative which allows you to keep binding logic in code and have the concise syntax at the same time.</source>
          <target state="translated">마지막 줄 에서 &lt;a href=&quot;android-plugin&quot;&gt;Kotlin Android Extensions&lt;/a&gt; 플러그인을 사용하여 &lt;code&gt;id&lt;/code&gt; 로 &lt;code&gt;button&lt;/code&gt; 을 참조합니다 . 이 플러그인을 대안으로 사용하여 코드에서 바인딩 로직을 유지하고 간결한 구문을 동시에 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7da80e212e3fb5a8c2cf3d597abb266f174acf51" translate="yes" xml:space="preserve">
          <source>In the last line, there's an implicit &lt;code&gt;this.&lt;/code&gt; in front of both &lt;code&gt;memberFunction()&lt;/code&gt; and &lt;code&gt;memberProperty&lt;/code&gt; (if these exist on the type of &lt;code&gt;someExpression&lt;/code&gt;). The return value is that of the last expression.</source>
          <target state="translated">마지막 줄에는 암시적인 내용 &lt;code&gt;this.&lt;/code&gt; &lt;code&gt;memberFunction()&lt;/code&gt; 및 &lt;code&gt;memberProperty&lt;/code&gt; (이는 &lt;code&gt;someExpression&lt;/code&gt; 유형에있는 경우 ) 앞에 있습니다. 리턴 값은 마지막 표현식의 리턴 값입니다.</target>
        </trans-unit>
        <trans-unit id="21de312c94f28c9a74e944cc50e80500b0df440a" translate="yes" xml:space="preserve">
          <source>In the next dialog, provide the project details:</source>
          <target state="translated">다음 대화 상자에서 프로젝트 세부 사항을 제공하십시오.</target>
        </trans-unit>
        <trans-unit id="fb8d123847c0bf27cf6ffe6e978d7163ff9a921d" translate="yes" xml:space="preserve">
          <source>In the old model, common and platform-specific code needed to be placed in separate modules, linked by &lt;code&gt;expectedBy&lt;/code&gt; dependencies. Now, common and platform-specific code is placed in different source roots of the same module, making projects easier to configure.</source>
          <target state="translated">이전 모델에서는 공통 및 플랫폼 별 코드를 &lt;code&gt;expectedBy&lt;/code&gt; 종속성으로 연결된 별도의 모듈에 배치해야했습니다 . 이제 공통 및 플랫폼 별 코드가 동일한 모듈의 다른 소스 루트에 배치되어 프로젝트를보다 쉽게 ​​구성 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ca766f4efd26534c30d9c87798187848fcb65628" translate="yes" xml:space="preserve">
          <source>In the presence of &lt;code&gt;maven-publish&lt;/code&gt; plugin the publications for all the binaries built are created. The plugin uses Gradle metadata to publish the artifacts so this feature must be enabled (see the &lt;a href=&quot;#dependencies&quot;&gt;dependencies&lt;/a&gt; section).</source>
          <target state="translated">&lt;code&gt;maven-publish&lt;/code&gt; 플러그인 이 있으면 빌드 된 모든 바이너리에 대한 발행물이 작성됩니다. 플러그인은 Gradle 메타 데이터를 사용하여 아티팩트를 공개하므로이 기능을 사용하도록 설정해야합니다 ( &lt;a href=&quot;#dependencies&quot;&gt;종속성&lt;/a&gt; 섹션 참조).</target>
        </trans-unit>
        <trans-unit id="d60dd59e4676a95bd7097287912e2ec3768e0f9a" translate="yes" xml:space="preserve">
          <source>In the previous example the JavaScript module exports a single package. However, some JavaScript libraries export multiple packages from within a module. This case is also supported by Kotlin, though you have to declare a new &lt;code&gt;.kt&lt;/code&gt; file for each package you import.</source>
          <target state="translated">이전 예제에서 JavaScript 모듈은 단일 패키지를 내 보냅니다. 그러나 일부 JavaScript 라이브러리는 모듈 내에서 여러 패키지를 내 보냅니다. 이 사례는 Kotlin에서도 지원되지만 가져 오는 각 패키지에 대해 새 &lt;code&gt;.kt&lt;/code&gt; 파일 을 선언해야합니다 .</target>
        </trans-unit>
        <trans-unit id="42d1f7acaeec00a73953ae801ded4c35e710f59f" translate="yes" xml:space="preserve">
          <source>In the tutorial we will learn:</source>
          <target state="translated">튜토리얼에서 우리는 배울 것입니다 :</target>
        </trans-unit>
        <trans-unit id="5c983473a452d20ce90bb4b7f97f64c188d78e2f" translate="yes" xml:space="preserve">
          <source>In the tutorial we:</source>
          <target state="translated">튜토리얼에서 우리는 :</target>
        </trans-unit>
        <trans-unit id="095e7f10496f59e9c1f965ea0b808ca458b5529c" translate="yes" xml:space="preserve">
          <source>In this case the compiler will not be downloaded by the plugin.</source>
          <target state="translated">이 경우 플러그인에서 컴파일러를 다운로드하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="f1f881dff617021acda0968035a0c51bb38a1c2d" translate="yes" xml:space="preserve">
          <source>In this case, JQuery will be imported as a module named &lt;code&gt;jquery&lt;/code&gt;. Alternatively, it can be used as a $-object, depending on what module system Kotlin compiler is configured to use.</source>
          <target state="translated">이 경우 JQuery를 &lt;code&gt;jquery&lt;/code&gt; 라는 모듈로 가져 옵니다 . 또는 Kotlin 컴파일러가 사용하도록 구성된 모듈 시스템에 따라 $ -object로 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c032e19443eb1eff2c0c1528c6eb2e5d72dfce23" translate="yes" xml:space="preserve">
          <source>In this case, we've set the output of our compilation to the &lt;code&gt;scripts&lt;/code&gt; folder. On running the application we should see the following output:</source>
          <target state="translated">이 경우 컴파일 결과를 &lt;code&gt;scripts&lt;/code&gt; 폴더로 설정했습니다. 응용 프로그램을 실행하면 다음과 같은 결과가 나타납니다.</target>
        </trans-unit>
        <trans-unit id="de0ac72463e7c41b8825d92484726f740a2112b2" translate="yes" xml:space="preserve">
          <source>In this dense code, in addition to collection transformations, you can see such handy Kotlin features as local functions and the &lt;a href=&quot;../reference/null-safety#elvis-operator&quot;&gt;elvis operator&lt;/a&gt;&lt;code&gt;?:&lt;/code&gt; that allow to express &lt;a href=&quot;../reference/idioms&quot;&gt;idioms&lt;/a&gt; like &quot;take the value if it is positive or else use length&quot; with a concise and readable expressions like &lt;code&gt;.takeIf { it &amp;gt;= 0 } ?: s.length&lt;/code&gt;, yet it is perfectly fine with Kotlin to create additional mutable variables and express the same code in imperative style, too.</source>
          <target state="translated">이 고밀도 코드에서 수집 변환뿐만 아니라, 당신은 편리한 코 틀린 지역 함수로 기능하고 볼 수있는 &lt;a href=&quot;../reference/null-safety#elvis-operator&quot;&gt;연산자를 엘비스 &lt;/a&gt; &lt;code&gt;?:&lt;/code&gt; 표현할 수 있도록하는 &lt;a href=&quot;../reference/idioms&quot;&gt;숙어&lt;/a&gt; 간결한와 &quot;는 긍정적 그렇지 않으면 사용 길이의 경우는 값을&quot;과 같은를 &lt;code&gt;.takeIf { it &amp;gt;= 0 } ?: s.length&lt;/code&gt; 와 같이 읽을 수있는 표현식 이지만 Kotlin을 사용하면 추가 가변 변수를 만들고 동일한 코드를 명령형 스타일로 표현하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="e691bb86d414ab1eeeac0ce8d8cf107c13b24d6b" translate="yes" xml:space="preserve">
          <source>In this doc, we'll sometimes specify the type unnecessarily, in order to highlight what type is produced by an expression. (Also, a good IDE will be able to show you the resulting type.)</source>
          <target state="translated">이 문서에서는 표현식에 의해 생성되는 유형을 강조하기 위해 불필요하게 유형을 지정하는 경우가 있습니다. 또한 좋은 IDE는 결과 유형을 보여줄 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7d12593ba02967f080622029b34989f6d346aaf9" translate="yes" xml:space="preserve">
          <source>In this document we introduce several kinds of compatibility:</source>
          <target state="translated">이 문서에서는 여러 종류의 호환성을 소개합니다.</target>
        </trans-unit>
        <trans-unit id="537f8c16fc8f03cc135b33707b31eb29f9995ea0" translate="yes" xml:space="preserve">
          <source>In this example only members of the nearest implicit receiver &lt;code&gt;this@head&lt;/code&gt; must be available; &lt;code&gt;head()&lt;/code&gt; is a member of the outer receiver &lt;code&gt;this@html&lt;/code&gt;, so it must be illegal to call it.</source>
          <target state="translated">이 예에서는 가장 가까운 암시 적 수신자 &lt;code&gt;this@head&lt;/code&gt; 멤버 만 사용 가능해야합니다. &lt;code&gt;head()&lt;/code&gt; 는 외부 수신자 &lt;code&gt;this@html&lt;/code&gt; 의 멤버 이므로 호출하는 것은 불법입니다.</target>
        </trans-unit>
        <trans-unit id="67582c167007a9ba92244086b3d65c9a9e9700f4" translate="yes" xml:space="preserve">
          <source>In this example we launch a new coroutine in a background thread pool using &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-dispatchers/-default.html&quot;&gt;Dispatchers.Default&lt;/a&gt;, so it works on a different threads from a thread pool, but it still has the value of thread local variable, that we've specified using &lt;code&gt;threadLocal.asContextElement(value = &quot;launch&quot;)&lt;/code&gt;, no matter on what thread the coroutine is executed. Thus, output (with &lt;a href=&quot;#debugging-coroutines-and-threads&quot;&gt;debug&lt;/a&gt;) is:</source>
          <target state="translated">이 예제에서는 &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-dispatchers/-default.html&quot;&gt;Dispatchers.Default를&lt;/a&gt; 사용하여 백그라운드 스레드 풀에서 새 코 루틴을 시작 하므로 스레드 풀과 다른 스레드에서 작동하지만 여전히 스레드 로컬 변수의 값을 &lt;code&gt;threadLocal.asContextElement(value = &quot;launch&quot;)&lt;/code&gt; 사용하여 지정한 값입니다. 코 루틴이 실행되는 스레드에 관계없이 (value = &quot;launch&quot;) . 따라서 출력 ( &lt;a href=&quot;#debugging-coroutines-and-threads&quot;&gt;debug 포함&lt;/a&gt; )은 다음 과 같습니다.</target>
        </trans-unit>
        <trans-unit id="872d3ddd1be8b8c4ec3ab8cc792f3b5cde57d822" translate="yes" xml:space="preserve">
          <source>In this example, all values passed to the C API &lt;code&gt;new_menu()&lt;/code&gt; have a lifetime of the innermost &lt;code&gt;memScope&lt;/code&gt; it belongs to. Once the control flow leaves the &lt;code&gt;memScoped&lt;/code&gt; scope the C pointers become invalid.</source>
          <target state="translated">이 예에서, C API &lt;code&gt;new_menu()&lt;/code&gt; 전달 된 모든 값은 &lt;code&gt;memScope&lt;/code&gt; 이 속한 가장 안쪽 memScope 의 수명을 갖 습니다. 제어 흐름이 &lt;code&gt;memScoped&lt;/code&gt; 범위를 벗어나 면 C 포인터가 유효하지 않게됩니다.</target>
        </trans-unit>
        <trans-unit id="5b70f0a7dd260f72c7acee91c3f5762c472a459a" translate="yes" xml:space="preserve">
          <source>In this example, the constructor takes a map:</source>
          <target state="translated">이 예제에서 생성자는 맵을 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="06698ce38b883fc740d14dcc830fa9e382960eb5" translate="yes" xml:space="preserve">
          <source>In this example, the sequence processing takes 18 steps instead of 23 steps for doing the same with lists.</source>
          <target state="translated">이 예에서, 시퀀스 처리는리스트와 동일한 작업을 수행하기 위해 23 단계 대신 18 단계를 수행합니다.</target>
        </trans-unit>
        <trans-unit id="550b3c67b81cc4d4252fe83306649fc1df1e86da" translate="yes" xml:space="preserve">
          <source>In this example, using &lt;code&gt;Person&lt;/code&gt; and &lt;code&gt;callAndPrintTwoParam()&lt;/code&gt; from the previous section, we locate a member function reference by name and call it:</source>
          <target state="translated">이 예제 에서 이전 섹션의 &lt;code&gt;Person&lt;/code&gt; 및 &lt;code&gt;callAndPrintTwoParam()&lt;/code&gt; 을 사용하여 이름으로 멤버 함수 참조를 찾아서 호출합니다.</target>
        </trans-unit>
        <trans-unit id="25017fcbb3e37d1b9106fc29788136cb1c456365" translate="yes" xml:space="preserve">
          <source>In this function both &lt;a href=&quot;-continuation/resume&quot;&gt;Continuation.resume&lt;/a&gt; and &lt;a href=&quot;-continuation/resume-with-exception&quot;&gt;Continuation.resumeWithException&lt;/a&gt; can be used either synchronously in the same stack-frame where suspension function is run or asynchronously later in the same thread or from a different thread of execution. Repeated invocation of any resume function produces &lt;a href=&quot;../kotlin/-illegal-state-exception/index#kotlin.IllegalStateException&quot;&gt;IllegalStateException&lt;/a&gt;.</source>
          <target state="translated">이 함수에서 &lt;a href=&quot;-continuation/resume&quot;&gt;Continuation.resume&lt;/a&gt; 및 &lt;a href=&quot;-continuation/resume-with-exception&quot;&gt;Continuation.resumeWithException&lt;/a&gt; 은 서스펜션 기능이 실행되는 동일한 스택 프레임에서 동 기적으로 또는 나중에 동일한 스레드에서 또는 다른 실행 스레드에서 비동기 적으로 사용될 수 있습니다. 재개 함수를 반복해서 호출하면 &lt;a href=&quot;../kotlin/-illegal-state-exception/index#kotlin.IllegalStateException&quot;&gt;IllegalStateException이 발생합니다&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="a802dce08d5c39703b387f16a864974235e44de0" translate="yes" xml:space="preserve">
          <source>In this function both &lt;a href=&quot;resume&quot;&gt;Continuation.resume&lt;/a&gt; and &lt;a href=&quot;resume-with-exception&quot;&gt;Continuation.resumeWithException&lt;/a&gt; can be used either synchronously in the same stack-frame where the suspension function is run or asynchronously later in the same thread or from a different thread of execution. Subsequent invocation of any resume function will produce an &lt;a href=&quot;../kotlin/-illegal-state-exception/index#kotlin.IllegalStateException&quot;&gt;IllegalStateException&lt;/a&gt;.</source>
          <target state="translated">이 함수에서 &lt;a href=&quot;resume&quot;&gt;Continuation.resume&lt;/a&gt; 및 &lt;a href=&quot;resume-with-exception&quot;&gt;Continuation.resumeWithException&lt;/a&gt; 은 서스펜션 기능이 실행되는 동일한 스택 프레임에서 동 기적으로 또는 나중에 같은 스레드에서 또는 다른 실행 스레드에서 비동기 적으로 사용될 수 있습니다. 이력서 함수의 후속 호출은 &lt;a href=&quot;../kotlin/-illegal-state-exception/index#kotlin.IllegalStateException&quot;&gt;IllegalStateException&lt;/a&gt; 을 생성 합니다 .</target>
        </trans-unit>
        <trans-unit id="677125a2bada551194ff25d8eec9f1b62a3c4ba4" translate="yes" xml:space="preserve">
          <source>In this section a commented DSL is shown. See also the example projects that use this plugin, e.g. &lt;a href=&quot;https://github.com/Kotlin/kotlinx.coroutines&quot;&gt;Kotlinx.coroutines&lt;/a&gt;, &lt;a href=&quot;https://github.com/e5l/http-client-common/tree/master/samples/ios-test-application&quot;&gt;MPP http client&lt;/a&gt;</source>
          <target state="translated">이 섹션에는 주석 처리 된 DSL이 표시됩니다. 이 플러그인을 사용하는 프로젝트 예 (예 : &lt;a href=&quot;https://github.com/Kotlin/kotlinx.coroutines&quot;&gt;Kotlinx.coroutines&lt;/a&gt; , &lt;a href=&quot;https://github.com/e5l/http-client-common/tree/master/samples/ios-test-application&quot;&gt;MPP http 클라이언트)도 참조하십시오.&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="45d0e31509240af7f0d899e0847fb308f3f6c3d9" translate="yes" xml:space="preserve">
          <source>In this tutorial We will learn how to:</source>
          <target state="translated">이 학습서에서는 다음을 수행하는 방법을 학습합니다.</target>
        </trans-unit>
        <trans-unit id="b8d78e48aa113b25ef679f219669ead0543c6d9d" translate="yes" xml:space="preserve">
          <source>In this tutorial however, we'll see how to use some specific libraries, such as &lt;code&gt;libcurl&lt;/code&gt;. We'll learn to</source>
          <target state="translated">그러나이 튜토리얼에서는 &lt;code&gt;libcurl&lt;/code&gt; 과 같은 특정 라이브러리를 사용하는 방법을 살펴 봅니다 . 우리는 배울 것이다</target>
        </trans-unit>
        <trans-unit id="38ae904b992e64be7d6f1c95db212a698e90d2ef" translate="yes" xml:space="preserve">
          <source>In this tutorial we have:</source>
          <target state="translated">이 튜토리얼에서 우리는 :</target>
        </trans-unit>
        <trans-unit id="814c4fd32a87a880ed24663823d0826f5fba0218" translate="yes" xml:space="preserve">
          <source>In this tutorial we see how to deal with C strings in Kotlin/Native. We will learn how to:</source>
          <target state="translated">이 튜토리얼에서는 Kotlin / Native에서 C 문자열을 처리하는 방법을 살펴 봅니다. 우리는 방법을 배울 것입니다 :</target>
        </trans-unit>
        <trans-unit id="f187570814c6d6abda5a2c00ead30d73ef74a12e" translate="yes" xml:space="preserve">
          <source>In this tutorial we will create an iOS and Android application, by making use of Kotlin's code sharing features. For Android we'll be using Kotlin/JVM, while for iOS it will be Kotlin/Native.</source>
          <target state="translated">이 튜토리얼에서는 Kotlin의 코드 공유 기능을 사용하여 iOS 및 Android 애플리케이션을 작성합니다. 안드로이드의 경우 Kotlin / JVM을 사용하고 iOS의 경우 Kotlin / Native가됩니다.</target>
        </trans-unit>
        <trans-unit id="e75dd7cce5c41f63288c1748bd5bfd1c78d1ff1b" translate="yes" xml:space="preserve">
          <source>In this tutorial we'll see how to</source>
          <target state="translated">이 튜토리얼에서 우리는</target>
        </trans-unit>
        <trans-unit id="73192ff47f695a8d1b74a36ad93cdb6ae37eb2de" translate="yes" xml:space="preserve">
          <source>In this tutorial we'll walk through the steps required to use the Kotlin Android Extensions plugin, enhancing the experience of Android development.</source>
          <target state="translated">이 튜토리얼에서는 Kotlin Android Extensions 플러그인을 사용하여 Android 개발 환경을 향상시키는 데 필요한 단계를 안내합니다.</target>
        </trans-unit>
        <trans-unit id="f0e340bf119483d38d43d3af161837206adf260c" translate="yes" xml:space="preserve">
          <source>In this tutorial we'll walk through the steps required. For a more thorough explanation of Spring Boot and Kotlin, please see &lt;a href=&quot;https://spring.io/guides/tutorials/spring-boot-kotlin/&quot;&gt;Building web applications with Spring Boot and Kotlin&lt;/a&gt;.</source>
          <target state="translated">이 자습서에서는 필요한 단계를 안내합니다. Spring Boot 및 Kotlin에 대한 자세한 설명은 Spring Boot 및 Kotlin을 &lt;a href=&quot;https://spring.io/guides/tutorials/spring-boot-kotlin/&quot;&gt;사용하여 웹 애플리케이션 빌드&lt;/a&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="04ead99e3026a0a00111c1c9a4f51b0c3c739752" translate="yes" xml:space="preserve">
          <source>In this tutorial we'll:</source>
          <target state="translated">이 자습서에서는 다음을 수행합니다.</target>
        </trans-unit>
        <trans-unit id="0f464678d81fef87702589d2f00f58596a930600" translate="yes" xml:space="preserve">
          <source>In this tutorial we're going to use IntelliJ IDEA. For instructions on how to compile and execute Kotlin applications using the command line compiler, see &lt;a href=&quot;command-line&quot;&gt;Working with the Command Line Compiler&lt;/a&gt;.</source>
          <target state="translated">이 자습서에서는 IntelliJ IDEA를 사용합니다. 명령 행 컴파일러를 사용하여 Kotlin 애플리케이션을 컴파일하고 실행하는 방법에 대한 지시 사항은 명령 행 컴파일러 &lt;a href=&quot;command-line&quot;&gt;작업을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="a5d5b9a27b34d95239a0c33821d0a9b033c40bd3" translate="yes" xml:space="preserve">
          <source>In this tutorial we've seen how to create a Kotlin application that targets JavaScript, debug it as well as set compiler options. In other tutorials we'll cover more in-depth topics such as interacting with the DOM, etc.</source>
          <target state="translated">이 튜토리얼에서는 JavaScript를 대상으로하는 Kotlin 응용 프로그램을 만들고 디버깅하고 컴파일러 옵션을 설정하는 방법을 살펴 보았습니다. 다른 튜토리얼에서는 DOM과의 상호 작용 등과 같은 더 자세한 주제를 다룰 것입니다.</target>
        </trans-unit>
        <trans-unit id="15ab8dc4bd9f08f596ae63880b3958cb4434a6d7" translate="yes" xml:space="preserve">
          <source>In this tutorial, we learn what C data types are visible in Kotlin/Native and vice versa. We will:</source>
          <target state="translated">이 학습서에서는 Kotlin / Native에 표시되는 C 데이터 유형과 그 반대에 대해 알아 봅니다. 우리는 :</target>
        </trans-unit>
        <trans-unit id="8a05d2cdb1fd77bc1ee6b2a0bfc489f7b20f51b2" translate="yes" xml:space="preserve">
          <source>In this tutorial, we look at how we can use the Kotlin/Native code from existing native applications or libraries. For this, we need to compile our Kotlin code into a dynamic library, &lt;code&gt;.so&lt;/code&gt;, &lt;code&gt;.dylib&lt;/code&gt;, and &lt;code&gt;.dll&lt;/code&gt;.</source>
          <target state="translated">이 학습서에서는 기존 기본 애플리케이션 또는 라이브러리의 Kotlin / Native 코드를 사용하는 방법을 살펴 봅니다. 이를 위해 Kotlin 코드를 동적 라이브러리 &lt;code&gt;.so&lt;/code&gt; , &lt;code&gt;.dylib&lt;/code&gt; 및 &lt;code&gt;.dll&lt;/code&gt; 로 컴파일해야합니다 .</target>
        </trans-unit>
        <trans-unit id="701903e9f376cd1d8503774a4d299554e97196a0" translate="yes" xml:space="preserve">
          <source>In this tutorial, we will build a small library available from the worlds of JVM, JS, and Native. You will learn step-by-step how to create a multiplatform library which can be used from any other common code (e.g., one shared with Android and iOS), and how to write tests which will be executed on all platforms and use an efficient implementation provided by the concrete platform.</source>
          <target state="translated">이 학습서에서는 JVM, JS 및 Native의 세계에서 사용 가능한 작은 라이브러리를 빌드합니다. 다른 일반적인 코드 (예 : Android 및 iOS와 공유 된 코드)에서 사용할 수있는 멀티 플랫폼 라이브러리를 만드는 방법과 모든 플랫폼에서 실행되고 효율적인 테스트를 작성하는 방법을 단계별로 학습합니다. 구체적인 플랫폼에서 제공하는 구현.</target>
        </trans-unit>
        <trans-unit id="8459da0cf638e813dae1e5c0fa95e9568c3582bd" translate="yes" xml:space="preserve">
          <source>In this tutorial, we will look at how to use Kotlin/Native code from Objective-C and Swift applications on macOS and iOS. We will build a framework from Kotlin code.</source>
          <target state="translated">이 튜토리얼에서는 macOS 및 iOS에서 Objective-C 및 Swift 애플리케이션의 Kotlin / 네이티브 코드를 사용하는 방법을 살펴 봅니다. Kotlin 코드에서 프레임 워크를 빌드합니다.</target>
        </trans-unit>
        <trans-unit id="864dde628feba0ddb56fa697c290d183bee8b077" translate="yes" xml:space="preserve">
          <source>In this tutorial, we will:</source>
          <target state="translated">이 자습서에서는 다음을 수행합니다.</target>
        </trans-unit>
        <trans-unit id="98c10d04454a966f67cb1dfe790300722810cd2d" translate="yes" xml:space="preserve">
          <source>In this tutorial, we'll look at how to</source>
          <target state="translated">이 자습서에서는 방법을 살펴 보겠습니다.</target>
        </trans-unit>
        <trans-unit id="0c3ebd5f96036d4c23f2a9d6d5dd9911faa69aff" translate="yes" xml:space="preserve">
          <source>In this tutorial, we're going to be using Gradle but the same can be accomplished using either IntelliJ IDEA project structure or Maven. For details on setting up Gradle to work with Kotlin, see &lt;a href=&quot;../reference/using-gradle&quot;&gt;Using Gradle&lt;/a&gt;.</source>
          <target state="translated">이 튜토리얼에서는 Gradle을 사용하지만 IntelliJ IDEA 프로젝트 구조 또는 Maven을 사용하여 동일하게 수행 할 수 있습니다. Kotlin과 함께 작동하도록 Gradle 설정에 대한 자세한 내용은 Gradle &lt;a href=&quot;../reference/using-gradle&quot;&gt;사용을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="aa1a5fa948935055fc078b1993ec8baed9df514c" translate="yes" xml:space="preserve">
          <source>In this tutorial, we're going to be using Gradle but the same can be accomplished using either IntelliJ IDEA project structure or Maven. For details on setting up Gradle to work with Kotlin, see &lt;a href=&quot;../reference/using-gradle&quot;&gt;Using Gradle&lt;/a&gt;. The main dependency required for using HTTP servlets is the JavaEE API:</source>
          <target state="translated">이 튜토리얼에서는 Gradle을 사용하지만 IntelliJ IDEA 프로젝트 구조 또는 Maven을 사용하여 동일하게 수행 할 수 있습니다. Kotlin과 함께 작동하도록 Gradle 설정에 대한 자세한 내용은 Gradle &lt;a href=&quot;../reference/using-gradle&quot;&gt;사용을&lt;/a&gt; 참조하십시오 . HTTP 서블릿 사용에 필요한 주요 종속성은 JavaEE API입니다.</target>
        </trans-unit>
        <trans-unit id="23e1b785f9b5814cd84a43b0c10801c0740b41ac" translate="yes" xml:space="preserve">
          <source>In turn, &lt;code&gt;let&lt;/code&gt; and &lt;code&gt;also&lt;/code&gt; have the context object as a lambda argument. If the argument name is not specified, the object is accessed by the implicit default name &lt;code&gt;it&lt;/code&gt;. &lt;code&gt;it&lt;/code&gt; is shorter than &lt;code&gt;this&lt;/code&gt; and expressions with &lt;code&gt;it&lt;/code&gt; are usually easier for reading. However, when calling the object functions or properties you don't have the object available implicitly like &lt;code&gt;this&lt;/code&gt;. Hence, having the context object as &lt;code&gt;it&lt;/code&gt; is better when the object is mostly used as an argument in function calls. &lt;code&gt;it&lt;/code&gt; is also better if you use multiple variables in the code block.</source>
          <target state="translated">차례로, &lt;code&gt;let&lt;/code&gt; 하고 &lt;code&gt;also&lt;/code&gt; 람다 인수로 컨텍스트 개체가 있습니다. 인수 이름을 지정하지 않으면 암시 적 기본 이름 인 &lt;code&gt;it&lt;/code&gt; 의해 오브젝트에 액세스 합니다 . &lt;code&gt;it&lt;/code&gt; 보다 짧은 &lt;code&gt;this&lt;/code&gt; 와와 표현 &lt;code&gt;it&lt;/code&gt; 일반적으로 읽기 쉽다. 오브젝트의 기능이나 속성을 호출 할 때, 당신은 암시 적으로 같이 사용할 수있는 오브젝트가없는 &lt;code&gt;this&lt;/code&gt; . 따라서 객체가 함수 호출에서 인수로 주로 사용될 때 컨텍스트 객체를 사용 &lt;code&gt;it&lt;/code&gt; 것이 좋습니다. &lt;code&gt;it&lt;/code&gt; 당신이 코드 블록에 여러 변수를 사용하는 경우 더 나은이기도합니다.</target>
        </trans-unit>
        <trans-unit id="812b574e96ace8dd4cdbeccd6ad6e3f2e4f0aabb" translate="yes" xml:space="preserve">
          <source>In turn, mutable collections aren't covariant; otherwise, this would lead to runtime failures. If &lt;code&gt;MutableList&amp;lt;Rectangle&amp;gt;&lt;/code&gt; was a subtype of &lt;code&gt;MutableList&amp;lt;Shape&amp;gt;&lt;/code&gt;, you could insert other &lt;code&gt;Shape&lt;/code&gt; inheritors (for example, &lt;code&gt;Circle&lt;/code&gt;) into it, thus violating its &lt;code&gt;Rectangle&lt;/code&gt; type argument.</source>
          <target state="translated">결과적으로 변경 가능한 컬렉션은 공변량이 아닙니다. 그렇지 않으면 런타임 오류가 발생합니다. 경우 &lt;code&gt;MutableList&amp;lt;Rectangle&amp;gt;&lt;/code&gt; 의 하위 유형이었다 &lt;code&gt;MutableList&amp;lt;Shape&amp;gt;&lt;/code&gt; , 당신은 다른 삽입 할 수 &lt;code&gt;Shape&lt;/code&gt; (예를 들어, 상속자를 &lt;code&gt;Circle&lt;/code&gt; 따라서 그 위반, 그것으로) &lt;code&gt;Rectangle&lt;/code&gt; 타입의 인수를.</target>
        </trans-unit>
        <trans-unit id="2a50d6665033bbbaf15909f2a8b12edea9bb1926" translate="yes" xml:space="preserve">
          <source>In turn, set is not an ordered collection by &lt;a href=&quot;collections-overview&quot;&gt;definition&lt;/a&gt;. However, the Kotlin &lt;code&gt;Set&lt;/code&gt; stores elements in certain orders. These can be the order of insertion (in &lt;code&gt;LinkedHashSet&lt;/code&gt;), natural sorting order (in &lt;code&gt;SortedSet&lt;/code&gt;), or another order. The order of a set of elements can also be unknown. In such cases, the elements are still ordered somehow, so the functions that rely on the element positions still return their results. However, such results are unpredictable to the caller unless they know the specific implementation of &lt;code&gt;Set&lt;/code&gt; used.</source>
          <target state="translated">차례로 set은 &lt;a href=&quot;collections-overview&quot;&gt;정의에&lt;/a&gt; 따라 정렬 된 컬렉션이 아닙니다 . 그러나 Kotlin &lt;code&gt;Set&lt;/code&gt; 는 특정 순서로 요소를 저장합니다. 삽입 순서 ( &lt;code&gt;LinkedHashSet&lt;/code&gt; ), 자연 정렬 순서 ( &lt;code&gt;SortedSet&lt;/code&gt; ) 또는 다른 순서 일 수 있습니다. 요소 집합의 순서도 알 수 없습니다. 이러한 경우 요소는 여전히 순서대로 정렬되므로 요소 위치에 의존하는 함수는 여전히 결과를 반환합니다. 그러나 사용 된 &lt;code&gt;Set&lt;/code&gt; 의 특정 구현을 모르면 이러한 결과는 호출자에게 예측할 수 없습니다 .</target>
        </trans-unit>
        <trans-unit id="01b654ef30cda18991ddded390d4b967ccf9e9a4" translate="yes" xml:space="preserve">
          <source>In your scratch, you can write any valid Kotlin code, including new functions and classes. Syntax highlighting, auto-completion, and other code editing features of IntelliJ IDEA are supported in scratches.</source>
          <target state="translated">처음에는 새로운 함수와 클래스를 포함하여 유효한 Kotlin 코드를 작성할 수 있습니다. IntelliJ IDEA의 구문 강조, 자동 완성 및 기타 코드 편집 기능은 처음부터 지원됩니다.</target>
        </trans-unit>
        <trans-unit id="f2699078d9287cbd90f76ee50448a4fec028de87" translate="yes" xml:space="preserve">
          <source>Including static library in your klib</source>
          <target state="translated">klib에 정적 라이브러리 포함</target>
        </trans-unit>
        <trans-unit id="84996d5891b1f1a645c33eb5c3b22433a18e3eec" translate="yes" xml:space="preserve">
          <source>Incompatible Changes</source>
          <target state="translated">호환되지 않는 변경</target>
        </trans-unit>
        <trans-unit id="8d41722fdaa1b8acfa42d80a00302ec1d80e560e" translate="yes" xml:space="preserve">
          <source>IncorrectDereferenceException</source>
          <target state="translated">IncorrectDereferenceException</target>
        </trans-unit>
        <trans-unit id="7c15aa041f9a78e640a95e3034dce236ee5d488b" translate="yes" xml:space="preserve">
          <source>Incremental Compilation</source>
          <target state="translated">증분 컴파일</target>
        </trans-unit>
        <trans-unit id="1d25e364e8dc05079a68a8ada56d8fbeda70bc16" translate="yes" xml:space="preserve">
          <source>Incremental annotation processing (since 1.3.30)</source>
          <target state="translated">증분 주석 처리 (1.3.30부터)</target>
        </trans-unit>
        <trans-unit id="b1262b9eb921db266028505964086f28ad7e7f94" translate="yes" xml:space="preserve">
          <source>Incremental compilation</source>
          <target state="translated">증분 컴파일</target>
        </trans-unit>
        <trans-unit id="33b5061796594b36b41f624484bcfb3853bb6d0c" translate="yes" xml:space="preserve">
          <source>Incremental compilation is supported for Kotlin/JVM and Kotlin/JS projects. It's enabled by default since Kotlin 1.1.1 for Kotlin/JVM and 1.3.20 for Kotlin/JS.</source>
          <target state="translated">Kotlin / JVM 및 Kotlin / JS 프로젝트에 대해 증분 컴파일이 지원됩니다. Kotlin / JVM의 경우 Kotlin 1.1.1 및 Kotlin / JS의 경우 1.3.20부터 기본적으로 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="d6dbea2b53708e66e73d3f1a6a99defec97fa2a9" translate="yes" xml:space="preserve">
          <source>Incremental releases bring updates in the tooling (often including features), performance improvements and bug fixes. We try to keep such versions compatible with each other, so changes to the compiler are mostly optimizations and warning additions/removals. Experimental features may, of course, be added, removed or changed at any time.</source>
          <target state="translated">증분 릴리스는 툴링 (종종 기능 포함), 성능 개선 및 버그 수정에 대한 업데이트를 제공합니다. 우리는 이러한 버전을 서로 호환되도록 유지하려고 노력하므로 컴파일러의 변경은 대부분 최적화 및 경고 추가 / 제거입니다. 실험 기능은 물론 언제든지 추가, 제거 또는 변경 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9c0b336ea67b1169e696bcad497094e1948f51aa" translate="yes" xml:space="preserve">
          <source>Increments and decrements</source>
          <target state="translated">증감</target>
        </trans-unit>
        <trans-unit id="51065cc396f6ec67a2538e872f538ab2d9ab75c9" translate="yes" xml:space="preserve">
          <source>Increments the value by &lt;a href=&quot;add-and-get#kotlin.native.concurrent.AtomicInt%24addAndGet%28kotlin.Int%29%2Fdelta&quot;&gt;delta&lt;/a&gt; and returns the new value.</source>
          <target state="translated">&lt;a href=&quot;add-and-get#kotlin.native.concurrent.AtomicInt%24addAndGet%28kotlin.Int%29%2Fdelta&quot;&gt;델타&lt;/a&gt; 단위로 값을 증가시키고 새로운 값을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="44233843d94836d1fccccf70b3b2b867d9acc067" translate="yes" xml:space="preserve">
          <source>Increments the value by &lt;a href=&quot;add-and-get#kotlin.native.concurrent.AtomicLong%24addAndGet%28kotlin.Long%29%2Fdelta&quot;&gt;delta&lt;/a&gt; and returns the new value.</source>
          <target state="translated">&lt;a href=&quot;add-and-get#kotlin.native.concurrent.AtomicLong%24addAndGet%28kotlin.Long%29%2Fdelta&quot;&gt;델타&lt;/a&gt; 단위로 값을 증가시키고 새로운 값을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="28411949be3415589036a91826011ccfec40fbd4" translate="yes" xml:space="preserve">
          <source>Increments this value.</source>
          <target state="translated">이 값을 증가시킵니다.</target>
        </trans-unit>
        <trans-unit id="b8fcfd847cda35bcb6945261dd3c4eb8f88f412a" translate="yes" xml:space="preserve">
          <source>Increments value by one.</source>
          <target state="translated">값을 1 씩 증가시킵니다.</target>
        </trans-unit>
        <trans-unit id="c2df9b932637fe9d32a0f16da1c11873398f873d" translate="yes" xml:space="preserve">
          <source>Index</source>
          <target state="translated">Index</target>
        </trans-unit>
        <trans-unit id="83f705f84f3e506a637956b9907406ba6fe9f41e" translate="yes" xml:space="preserve">
          <source>IndexOutOfBoundsException</source>
          <target state="translated">IndexOutOfBoundsException</target>
        </trans-unit>
        <trans-unit id="4a12f879063aea0813ebab8015ddf21b727cd7af" translate="yes" xml:space="preserve">
          <source>Indexed access operator</source>
          <target state="translated">인덱스 액세스 연산자</target>
        </trans-unit>
        <trans-unit id="d4e1cf8d774b0c0bb9b5921ec7fa833544082d60" translate="yes" xml:space="preserve">
          <source>IndexedValue</source>
          <target state="translated">IndexedValue</target>
        </trans-unit>
        <trans-unit id="4ad24986a96806bcf716cdb15281ed398b1a31f5" translate="yes" xml:space="preserve">
          <source>Indicates whether some other object is &quot;equal to&quot; this one. Implementations must fulfil the following requirements:</source>
          <target state="translated">다른 객체가이 객체와 &quot;동일한 지&quot;여부를 나타냅니다. 구현은 다음 요구 사항을 충족해야합니다.</target>
        </trans-unit>
        <trans-unit id="53f09d01b93a3110068a373094e1fb376a10c3c8" translate="yes" xml:space="preserve">
          <source>Indicates whether the regular expression can find at least one match in the specified &lt;a href=&quot;contains-match-in#kotlin.text.Regex%24containsMatchIn%28kotlin.CharSequence%29%2Finput&quot;&gt;input&lt;/a&gt;.</source>
          <target state="translated">정규식이 지정된 &lt;a href=&quot;contains-match-in#kotlin.text.Regex%24containsMatchIn%28kotlin.CharSequence%29%2Finput&quot;&gt;입력&lt;/a&gt; 에서 하나 이상의 일치 항목을 찾을 수 있는지 여부를 나타냅니다 .</target>
        </trans-unit>
        <trans-unit id="cc670204f79af50c97c85084d6a41b77270ab6a4" translate="yes" xml:space="preserve">
          <source>Indicates whether the regular expression matches the entire &lt;a href=&quot;matches#kotlin.text.Regex%24matches%28kotlin.CharSequence%29%2Finput&quot;&gt;input&lt;/a&gt;.</source>
          <target state="translated">정규식이 전체 &lt;a href=&quot;matches#kotlin.text.Regex%24matches%28kotlin.CharSequence%29%2Finput&quot;&gt;입력&lt;/a&gt; 과 일치하는지 여부를 나타냅니다 .</target>
        </trans-unit>
        <trans-unit id="767a32bb6d83112e90455e54a6dd8a16300ca86c" translate="yes" xml:space="preserve">
          <source>Infix calls for named functions</source>
          <target state="translated">명명 된 함수에 대한 호출 호출</target>
        </trans-unit>
        <trans-unit id="1cea4b28540c3fbdd2e2436ba68910be38a3f387" translate="yes" xml:space="preserve">
          <source>Infix function calls have lower precedence than the arithmetic operators, type casts, and the &lt;code&gt;rangeTo&lt;/code&gt; operator. The following expressions are equivalent:</source>
          <target state="translated">대입 함수 호출은 산술 연산자, 유형 캐스트 ​​및 &lt;code&gt;rangeTo&lt;/code&gt; 연산자 보다 우선 순위가 낮습니다 . 다음 표현식은 동일합니다.</target>
        </trans-unit>
        <trans-unit id="c345bbff4a1e1fc76b2e4ede7fbe52f5de947e6b" translate="yes" xml:space="preserve">
          <source>Infix functions</source>
          <target state="translated">삽입 기능</target>
        </trans-unit>
        <trans-unit id="19c6abcd2f2f19793afb1f4565bae99cd5d50667" translate="yes" xml:space="preserve">
          <source>Infix notation</source>
          <target state="translated">접두사 표기</target>
        </trans-unit>
        <trans-unit id="c5a135f955f6a2349a2d4263f326ff3a2a3304ed" translate="yes" xml:space="preserve">
          <source>Information from explicit casts is used for type inference</source>
          <target state="translated">명시 적 캐스트의 정보는 유형 유추에 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="fdaddb9ce367c2ca746a97cc24d2e8817a51f27d" translate="yes" xml:space="preserve">
          <source>Inheritance</source>
          <target state="translated">Inheritance</target>
        </trans-unit>
        <trans-unit id="fc3ff49d31fe091e3831cd8bc1f2e6d38992276d" translate="yes" xml:space="preserve">
          <source>Inheritance from Java classes</source>
          <target state="translated">자바 클래스로부터 상속</target>
        </trans-unit>
        <trans-unit id="060c830dba717926ce4d26ef9693decc297e0680" translate="yes" xml:space="preserve">
          <source>Inheritance that leads to a &lt;code&gt;copy&lt;/code&gt; conflict has become deprecated with a warning in Kotlin 1.2 and will be an error in Kotlin 1.3.</source>
          <target state="translated">&lt;code&gt;copy&lt;/code&gt; 충돌로 이어지는 상속 은 Kotlin 1.2에서 경고로 더 이상 사용되지 않으며 Kotlin 1.3에서 오류가됩니다.</target>
        </trans-unit>
        <trans-unit id="fe8f308745a21bdbf9c67ae8f86198813253366c" translate="yes" xml:space="preserve">
          <source>Inherited Functions</source>
          <target state="translated">상속 된 함수</target>
        </trans-unit>
        <trans-unit id="a97b2d009dc11ee2399b0468fc72e941eebbf165" translate="yes" xml:space="preserve">
          <source>Inherited Properties</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f54b5bc69098e64d7fae998cd4e9df2d4fa8e7af" translate="yes" xml:space="preserve">
          <source>Inherited built-in functions</source>
          <target state="translated">상속 된 내장 함수</target>
        </trans-unit>
        <trans-unit id="af6ed82fe139bda1a895add0ffee5c78ca3dcf12" translate="yes" xml:space="preserve">
          <source>Inheritors</source>
          <target state="translated">Inheritors</target>
        </trans-unit>
        <trans-unit id="68fa16ffd48f366e4fa8d57fea78ff03fcab0191" translate="yes" xml:space="preserve">
          <source>Initialization</source>
          <target state="translated">Initialization</target>
        </trans-unit>
        <trans-unit id="100b184b34b9bc80bfe5761ad8aa4a5db3c27036" translate="yes" xml:space="preserve">
          <source>Initialized with a value of type &lt;code&gt;String&lt;/code&gt; or a primitive type</source>
          <target state="translated">&lt;code&gt;String&lt;/code&gt; 유형 또는 기본 유형 의 값으로 초기화</target>
        </trans-unit>
        <trans-unit id="0c55ba13e2bd9dbfd35641ebe93792c6061e39cd" translate="yes" xml:space="preserve">
          <source>Initializer</source>
          <target state="translated">Initializer</target>
        </trans-unit>
        <trans-unit id="cddbd43ce85bc15d27c1f2848a884d7030458b88" translate="yes" xml:space="preserve">
          <source>Initializer function can be called several times on concurrent access to uninitialized &lt;a href=&quot;../-lazy/index&quot;&gt;Lazy&lt;/a&gt; instance value, but only the first returned value will be used as the value of &lt;a href=&quot;../-lazy/index&quot;&gt;Lazy&lt;/a&gt; instance.</source>
          <target state="translated">초기화되지 않은 &lt;a href=&quot;../-lazy/index&quot;&gt;Lazy&lt;/a&gt; 인스턴스 값 에 동시에 액세스하면 초기화 기능을 여러 번 호출 할 수 있지만 첫 번째로 반환 된 값만 &lt;a href=&quot;../-lazy/index&quot;&gt;Lazy&lt;/a&gt; 인스턴스 의 값으로 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="8de9a4ea59b21de32db609afcfc607895faed0de" translate="yes" xml:space="preserve">
          <source>Initializer functions for lists</source>
          <target state="translated">리스트의 이니셜 라이저 기능</target>
        </trans-unit>
        <trans-unit id="db5e65d8fc7dddd98f6860c2416bcbcc90ec0fba" translate="yes" xml:space="preserve">
          <source>Initializers</source>
          <target state="translated">Initializers</target>
        </trans-unit>
        <trans-unit id="96e412fcc42808e35495dbc64ebcde5c69c261de" translate="yes" xml:space="preserve">
          <source>Initializes Kotlin runtime for the current thread, if not inited already.</source>
          <target state="translated">아직 초기화되지 않은 경우 현재 스레드에 대한 Kotlin 런타임을 초기화합니다.</target>
        </trans-unit>
        <trans-unit id="be787dbbf62b5076f4a13439769f15509c2967ea" translate="yes" xml:space="preserve">
          <source>Inlinable lambdas can only be called inside the inline functions or passed as inlinable arguments, but &lt;code&gt;noinline&lt;/code&gt; ones can be manipulated in any way we like: stored in fields, passed around etc.</source>
          <target state="translated">inlinable lambdas는 인라인 함수 내에서만 호출하거나 inlinable 인수로 전달할 수 있지만, &lt;code&gt;noinline&lt;/code&gt; 람다는 필드에 저장하거나 전달하는 등 원하는 방식으로 조작 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b60019f47df04ae92897fa912c6748a6013313fa" translate="yes" xml:space="preserve">
          <source>Inline Functions</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="77dc1cce985d17f15f3bb54896d9ab82a2428c34" translate="yes" xml:space="preserve">
          <source>Inline JavaScript</source>
          <target state="translated">인라인 JavaScript</target>
        </trans-unit>
        <trans-unit id="62d048ab15fe71589a192aa32dfde8cfed8f778a" translate="yes" xml:space="preserve">
          <source>Inline Markup</source>
          <target state="translated">인라인 마크 업</target>
        </trans-unit>
        <trans-unit id="5d360c4149ca0224f961067c92c26613a7104175" translate="yes" xml:space="preserve">
          <source>Inline classes</source>
          <target state="translated">인라인 클래스</target>
        </trans-unit>
        <trans-unit id="9286e6770b0362425ca42b0e3ebc568ac630fc5b" translate="yes" xml:space="preserve">
          <source>Inline classes are allowed to inherit from interfaces:</source>
          <target state="translated">인라인 클래스는 인터페이스에서 상속 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4c5881ab063c0ce817cf6f52ab599309c2d3110f" translate="yes" xml:space="preserve">
          <source>Inline classes are available only since Kotlin 1.3 and currently are &lt;em&gt;experimental&lt;/em&gt;. See details &lt;a href=&quot;#experimental-status-of-inline-classes&quot;&gt;below&lt;/a&gt;</source>
          <target state="translated">인라인 클래스는 Kotlin 1.3 이후부터 사용 가능하며 현재 &lt;em&gt;실험 중&lt;/em&gt; 입니다. 세부 사항을 참조하십시오 &lt;a href=&quot;#experimental-status-of-inline-classes&quot;&gt;아래를&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="f253e2ca96472e7c3372c8639328c1d3867dc3b6" translate="yes" xml:space="preserve">
          <source>Inline classes are available only since Kotlin 1.3 and currently are &lt;em&gt;experimental&lt;/em&gt;. See details in the &lt;a href=&quot;inline-classes#experimental-status-of-inline-classes&quot;&gt;reference&lt;/a&gt;.</source>
          <target state="translated">인라인 클래스는 Kotlin 1.3 이후부터 사용 가능하며 현재 &lt;em&gt;실험 중&lt;/em&gt; 입니다. 에서 자세한 내용을 참조하십시오 &lt;a href=&quot;inline-classes#experimental-status-of-inline-classes&quot;&gt;참조&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="a7a2cb12c8331fe8180ea13004fae9e89ef3e1fd" translate="yes" xml:space="preserve">
          <source>Inline classes support some functionality of regular classes. In particular, they are allowed to declare properties and functions:</source>
          <target state="translated">인라인 클래스는 일반 클래스의 일부 기능을 지원합니다. 특히 속성과 함수를 선언 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6c7769b31582b2d304756a0e1ee20904b47b72a0" translate="yes" xml:space="preserve">
          <source>Inline classes vs type aliases</source>
          <target state="translated">인라인 클래스와 타입 별칭</target>
        </trans-unit>
        <trans-unit id="126b7ff7e58c488c8dbbe2c35dcf311f885d0926" translate="yes" xml:space="preserve">
          <source>Inline extension functions that were called on a null value of a platform type did not check the receiver for null and would thus allow null to escape into the other code. Kotlin 1.2 forces this check at the call sites, throwing an exception if the receiver is null.</source>
          <target state="translated">플랫폼 유형의 널값에서 호출 된 인라인 확장 함수는 수신자가 널을 검사하지 않아 널이 다른 코드로 이스케이프되도록 허용합니다. Kotlin 1.2는 콜 사이트에서이 검사를 강제 실행하고 수신자가 null 인 경우 예외를 발생시킵니다.</target>
        </trans-unit>
        <trans-unit id="5c804513cadec43c33b180af13b2e9aec456a962" translate="yes" xml:space="preserve">
          <source>Inline functions</source>
          <target state="translated">인라인 함수</target>
        </trans-unit>
        <trans-unit id="9d0d1200e09d5fde96bd026c2e6ca0b2d04d5ad5" translate="yes" xml:space="preserve">
          <source>Inline functions are explained &lt;a href=&quot;inline-functions&quot;&gt;here&lt;/a&gt;.</source>
          <target state="translated">인라인 함수는 &lt;a href=&quot;inline-functions&quot;&gt;여기&lt;/a&gt; 에 설명되어 있습니다 .</target>
        </trans-unit>
        <trans-unit id="aa8db13612a09f046bbacee8122bb577b38d70fa" translate="yes" xml:space="preserve">
          <source>Inline functions are now allowed to have default values for their inlined functional parameters:</source>
          <target state="translated">인라인 함수는 이제 인라인 된 기능 매개 변수에 대한 기본값을 가질 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d6c978967701dd3225fcc54de37cf91805dd0b8d" translate="yes" xml:space="preserve">
          <source>Inline functions with &lt;a href=&quot;inline-functions#reified-type-parameters&quot;&gt;reified type parameters&lt;/a&gt; have their actual type arguments inlined at each call site, which enables &lt;code&gt;arg is T&lt;/code&gt; checks for the type parameters, but if &lt;code&gt;arg&lt;/code&gt; is an instance of a generic type itself, &lt;em&gt;its&lt;/em&gt; type arguments are still erased. Example:</source>
          <target state="translated">&lt;a href=&quot;inline-functions#reified-type-parameters&quot;&gt;형식&lt;/a&gt; 이 지정된 매개 변수 가있는 인라인 함수에는 각 호출 사이트에 실제 형식 인수가 인라인되어 있으므로 &lt;code&gt;arg is T&lt;/code&gt; 형식 매개 변수에 대한 T 검사이지만 &lt;code&gt;arg&lt;/code&gt; 가 일반 형식의 인스턴스 인 경우 &lt;em&gt;해당&lt;/em&gt; 형식 인수는 여전히 지워집니다. 예:</target>
        </trans-unit>
        <trans-unit id="dad40d691cb152e5ea04161c10815db00953ebbb" translate="yes" xml:space="preserve">
          <source>Inline functions with default functional parameters</source>
          <target state="translated">기본 기능 매개 변수가있는 인라인 함수</target>
        </trans-unit>
        <trans-unit id="e60dd1451a60d33b2eca72439470d0150cb5cb84" translate="yes" xml:space="preserve">
          <source>Inline properties (since 1.1)</source>
          <target state="translated">인라인 속성 (1.1 이후)</target>
        </trans-unit>
        <trans-unit id="6fec8c0d06ca4be7ff0c4bc9fa753ee420aa8bbc" translate="yes" xml:space="preserve">
          <source>Inline property accessors</source>
          <target state="translated">인라인 속성 접근 자</target>
        </trans-unit>
        <trans-unit id="01185d7fc605bc19fbe95771073571a841e3e817" translate="yes" xml:space="preserve">
          <source>Inlining may cause the generated code to grow; however, if we do it in a reasonable way (i.e. avoiding inlining large functions), it will pay off in performance, especially at &quot;megamorphic&quot; call-sites inside loops.</source>
          <target state="translated">인라이닝하면 생성 된 코드가 커질 수 있습니다. 그러나 합리적인 방법으로 (즉, 큰 함수를 인라인하지 않고) 수행하면 특히 루프 내부의 &quot;거시적 인&quot;콜 사이트에서 성능이 향상됩니다.</target>
        </trans-unit>
        <trans-unit id="aacf14c4398ec9fe537fae7e92753856f34743cb" translate="yes" xml:space="preserve">
          <source>Inner classes</source>
          <target state="translated">내부 수업</target>
        </trans-unit>
        <trans-unit id="bc3fa717af37b9f1e13149ace0b8f86497367e3c" translate="yes" xml:space="preserve">
          <source>Inner classes inheriting &lt;code&gt;Throwable&lt;/code&gt; that capture generic parameters from the outer class</source>
          <target state="translated">외부 클래스에서 일반 매개 변수를 캡처하는 &lt;code&gt;Throwable&lt;/code&gt; 을 상속 하는 내부 클래스</target>
        </trans-unit>
        <trans-unit id="258becf2f7c7396759bd76072890548fa224b9a4" translate="yes" xml:space="preserve">
          <source>Inner classes of generic types that inherit from &lt;code&gt;Throwable&lt;/code&gt; could violate type-safety in a throw-catch scenario and thus have been deprecated, with a warning in Kotlin 1.2 and an error in Kotlin 1.3.</source>
          <target state="translated">&lt;code&gt;Throwable&lt;/code&gt; 에서 상속되는 제네릭 형식의 내부 클래스는 throw-catch 시나리오에서 형식 안전성을 위반할 수 있으므로 Kotlin 1.2의 경고와 Kotlin 1.3의 오류와 함께 사용되지 않을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b14a7c09e5913aa9efafcb8d3f6e59361da51506" translate="yes" xml:space="preserve">
          <source>InputEventInit</source>
          <target state="translated">InputEventInit</target>
        </trans-unit>
        <trans-unit id="081e0fb72f26260fc891fc2cb6cbf71cf9e0d97f" translate="yes" xml:space="preserve">
          <source>Inserts all of the elements of the specified collection &lt;a href=&quot;../-mutable-list/add-all#kotlin.collections.MutableList%24addAll%28kotlin.Int%2C+kotlin.collections.Collection%28%28kotlin.collections.MutableList.E%29%29%29%2Felements&quot;&gt;elements&lt;/a&gt; into this list at the specified &lt;a href=&quot;../-mutable-list/add-all#kotlin.collections.MutableList%24addAll%28kotlin.Int%2C+kotlin.collections.Collection%28%28kotlin.collections.MutableList.E%29%29%29%2Findex&quot;&gt;index&lt;/a&gt;.</source>
          <target state="translated">지정된 컬렉션 요소의 모든 &lt;a href=&quot;../-mutable-list/add-all#kotlin.collections.MutableList%24addAll%28kotlin.Int%2C+kotlin.collections.Collection%28%28kotlin.collections.MutableList.E%29%29%29%2Felements&quot;&gt;요소&lt;/a&gt; 를 지정된 &lt;a href=&quot;../-mutable-list/add-all#kotlin.collections.MutableList%24addAll%28kotlin.Int%2C+kotlin.collections.Collection%28%28kotlin.collections.MutableList.E%29%29%29%2Findex&quot;&gt;인덱스&lt;/a&gt; 의이 목록에 삽입합니다 .</target>
        </trans-unit>
        <trans-unit id="887d8e7112f2b5499df8e54becfa68d97d70bd00" translate="yes" xml:space="preserve">
          <source>Inserts all of the elements of the specified collection &lt;a href=&quot;add-all#kotlin.collections.MutableList%24addAll%28kotlin.Int%2C+kotlin.collections.Collection%28%28kotlin.collections.MutableList.E%29%29%29%2Felements&quot;&gt;elements&lt;/a&gt; into this list at the specified &lt;a href=&quot;add-all#kotlin.collections.MutableList%24addAll%28kotlin.Int%2C+kotlin.collections.Collection%28%28kotlin.collections.MutableList.E%29%29%29%2Findex&quot;&gt;index&lt;/a&gt;.</source>
          <target state="translated">지정된 컬렉션 요소의 모든 &lt;a href=&quot;add-all#kotlin.collections.MutableList%24addAll%28kotlin.Int%2C+kotlin.collections.Collection%28%28kotlin.collections.MutableList.E%29%29%29%2Felements&quot;&gt;요소&lt;/a&gt; 를 지정된 &lt;a href=&quot;add-all#kotlin.collections.MutableList%24addAll%28kotlin.Int%2C+kotlin.collections.Collection%28%28kotlin.collections.MutableList.E%29%29%29%2Findex&quot;&gt;인덱스&lt;/a&gt; 의이 목록에 삽입합니다 .</target>
        </trans-unit>
        <trans-unit id="d0c7a2de4f7654463ee73faa30f98d50a3b73e7e" translate="yes" xml:space="preserve">
          <source>Inserts an element into the list at the specified &lt;a href=&quot;../-mutable-list/add#kotlin.collections.MutableList%24add%28kotlin.Int%2C+kotlin.collections.MutableList.E%29%2Findex&quot;&gt;index&lt;/a&gt;.</source>
          <target state="translated">지정된 &lt;a href=&quot;../-mutable-list/add#kotlin.collections.MutableList%24add%28kotlin.Int%2C+kotlin.collections.MutableList.E%29%2Findex&quot;&gt;인덱스&lt;/a&gt; 의 목록에 요소를 삽입합니다 .</target>
        </trans-unit>
        <trans-unit id="f6b6ae35f6d9d56e894884fb222d27eda900dc09" translate="yes" xml:space="preserve">
          <source>Inserts an element into the list at the specified &lt;a href=&quot;add#kotlin.collections.AbstractMutableList%24add%28kotlin.Int%2C+kotlin.collections.AbstractMutableList.E%29%2Findex&quot;&gt;index&lt;/a&gt;.</source>
          <target state="translated">지정된 &lt;a href=&quot;add#kotlin.collections.AbstractMutableList%24add%28kotlin.Int%2C+kotlin.collections.AbstractMutableList.E%29%2Findex&quot;&gt;인덱스&lt;/a&gt; 의 목록에 요소를 삽입합니다 .</target>
        </trans-unit>
        <trans-unit id="6c1226de8bd8dc851fb3874b9c31e306f3fa56c5" translate="yes" xml:space="preserve">
          <source>Inserts an element into the list at the specified &lt;a href=&quot;add#kotlin.collections.MutableList%24add%28kotlin.Int%2C+kotlin.collections.MutableList.E%29%2Findex&quot;&gt;index&lt;/a&gt;.</source>
          <target state="translated">지정된 &lt;a href=&quot;add#kotlin.collections.MutableList%24add%28kotlin.Int%2C+kotlin.collections.MutableList.E%29%2Findex&quot;&gt;인덱스&lt;/a&gt; 의 목록에 요소를 삽입합니다 .</target>
        </trans-unit>
        <trans-unit id="40e63a4d54fc0992dbc62da98003576fd7d50dbb" translate="yes" xml:space="preserve">
          <source>Inside a class, you can declare extensions for another class. Inside such an extension, there are multiple &lt;em&gt;implicit receivers&lt;/em&gt; - objects members of which can be accessed without a qualifier. The instance of the class in which the extension is declared is called &lt;em&gt;dispatch receiver&lt;/em&gt;, and the instance of the receiver type of the extension method is called &lt;em&gt;extension receiver&lt;/em&gt;.</source>
          <target state="translated">클래스 내에서 다른 클래스의 확장을 선언 할 수 있습니다. 이러한 확장에는 여러 개의 &lt;em&gt;암시 적 수신자&lt;/em&gt; 가 있습니다. 오브젝트 멤버는 규정 자없이 액세스 할 수 있습니다. 확장이 선언 된 클래스의 인스턴스를 &lt;em&gt;디스패치 수신기&lt;/em&gt; 라고 하고 확장 메소드의 수신자 유형 인스턴스는 &lt;em&gt;확장 수신기&lt;/em&gt; 라고 &lt;em&gt;합니다&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="97c34b033d93e70cd2130ab46bfa71cd52ac56f6" translate="yes" xml:space="preserve">
          <source>Inside a function a &lt;code&gt;vararg&lt;/code&gt;-parameter of type &lt;code&gt;T&lt;/code&gt; is visible as an array of &lt;code&gt;T&lt;/code&gt;, i.e. the &lt;code&gt;ts&lt;/code&gt; variable in the example above has type &lt;code&gt;Array&amp;lt;out T&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">함수, 안쪽 &lt;code&gt;vararg&lt;/code&gt; -parameter 타입 &lt;code&gt;T&lt;/code&gt; 는 배열로 표시되는 &lt;code&gt;T&lt;/code&gt; , 즉 &lt;code&gt;ts&lt;/code&gt; 입력 갖는 위의 예에서 변수 &lt;code&gt;Array&amp;lt;out T&amp;gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="826cc6f6147dd291bf22ea4078acd71a79ba87cf" translate="yes" xml:space="preserve">
          <source>Inside a lambda expression with receiver, you can use &lt;code&gt;this&lt;/code&gt; to refer to the receiver object (in this case, &lt;code&gt;car&lt;/code&gt;). As usual, you can omit &lt;code&gt;this&lt;/code&gt; if there are no naming conflicts, which is why we can simply say &lt;code&gt;$horsepowers&lt;/code&gt; instead of &lt;code&gt;${this.horsepowers}&lt;/code&gt;. So beware that in Kotlin, &lt;code&gt;this&lt;/code&gt; can have different meanings depending on the context: if used inside (possibly nested) lambda expressions with receivers, it refers to the receiver object of the innermost enclosing lambda expression with receiver. If you need to &quot;break out&quot; of the function literal and get the &quot;original&quot; &lt;code&gt;this&lt;/code&gt; (the instance the member function you're inside is executing on), mention the containing class name after &lt;code&gt;this@&lt;/code&gt; - so if you're inside a function literal with receiver inside a member function of Car, use &lt;code&gt;this@Car&lt;/code&gt;.</source>
          <target state="translated">수신자가있는 람다 식 내부에서 &lt;code&gt;this&lt;/code&gt; 사용 하여 수신자 객체 (이 경우 &lt;code&gt;car&lt;/code&gt; ) 를 참조 할 수 있습니다 . 평소와 같이 이름 충돌이없는 경우 &lt;code&gt;this&lt;/code&gt; 생략 할 수 있으므로 &lt;code&gt;${this.horsepowers}&lt;/code&gt; 대신 &lt;code&gt;$horsepowers&lt;/code&gt; 라고 간단히 말할 수 있습니다 . 그래서 코 틀린, 즉 조심 &lt;code&gt;this&lt;/code&gt; (가능하게 중첩)을 사용 내부 수신기와 람다 식, 그것은 수신기 최 둘러싸 람다 식의 수신기 객체를 참조하는 경우 : 문맥에 따라 다른 의미를 가질 수있다. 함수 리터럴을 &quot;분리&quot;하고 &quot;원본&quot;을 &lt;code&gt;this&lt;/code&gt; (내부 멤버 함수가 실행중인 인스턴스), &lt;code&gt;this@&lt;/code&gt; 뒤에 포함 클래스 이름을 언급하십시오. 따라서 Car 멤버 함수 내부에 수신자가있는 함수 리터럴 안에 있다면 &lt;code&gt;this@Car&lt;/code&gt; 사용 하십시오 .</target>
        </trans-unit>
        <trans-unit id="d76861f103960eff4ae0c7430fef1ebd5d3e542c" translate="yes" xml:space="preserve">
          <source>Inside an inner class, accessing the superclass of the outer class is done with the &lt;em&gt;super&lt;/em&gt; keyword qualified with the outer class name: &lt;code&gt;super@Outer&lt;/code&gt;:</source>
          <target state="translated">내부 클래스 내에서 외부 클래스의 수퍼 클래스에 액세스하는 것은 외부 클래스 이름으로 &lt;em&gt;super&lt;/em&gt; 키워드를 사용하여 수행됩니다 : &lt;code&gt;super@Outer&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="8ccb5c0d6d5858f7a6cc2ca5c66201a3c3cecf82" translate="yes" xml:space="preserve">
          <source>Inside enum entries, defining a nested type that is not an &lt;code&gt;inner class&lt;/code&gt; has been deprecated due to issues in the initialization logic. This causes a warning in Kotlin 1.2 and will become an error in Kotlin 1.3.</source>
          <target state="translated">내부 열거 형 항목이 아닌 &lt;code&gt;inner class&lt;/code&gt; 가 아닌 중첩 형식을 정의 하면 초기화 논리의 문제로 인해 더 이상 사용되지 않습니다. 이로 인해 Kotlin 1.2에서 경고가 발생하고 Kotlin 1.3에서 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="d5019da5c150ca59c7fa4dd453ea0a06cf96e080" translate="yes" xml:space="preserve">
          <source>Inside the &lt;code&gt;apply&lt;/code&gt; block, &lt;code&gt;this&lt;/code&gt; refers to &lt;code&gt;maybeNull&lt;/code&gt;. There's an implicit &lt;code&gt;this&lt;/code&gt; in front of &lt;code&gt;memberPropertyA&lt;/code&gt;, &lt;code&gt;memberPropertyB&lt;/code&gt;, and &lt;code&gt;memberFunctionA&lt;/code&gt; (unless these don't exist on &lt;code&gt;maybeNull&lt;/code&gt;, in which case they'll be looked for in the containing scopes). Afterwards, &lt;code&gt;memberFunctionB()&lt;/code&gt; is also invoked on &lt;code&gt;maybeNull&lt;/code&gt;.</source>
          <target state="translated">(가) 내부 &lt;code&gt;apply&lt;/code&gt; 블록을 &lt;code&gt;this&lt;/code&gt; 을 의미 &lt;code&gt;maybeNull&lt;/code&gt; . 암시 적있어 &lt;code&gt;this&lt;/code&gt; 앞에 &lt;code&gt;memberPropertyA&lt;/code&gt; , &lt;code&gt;memberPropertyB&lt;/code&gt; 및 &lt;code&gt;memberFunctionA&lt;/code&gt; (이되지 않는 존재하지 않는 &lt;code&gt;maybeNull&lt;/code&gt; 이 경우 그들이 포함하는 범위에서 찾았다됩니다). 이후 &lt;code&gt;memberFunctionB()&lt;/code&gt; 또한 &lt;code&gt;maybeNull&lt;/code&gt; 에서 호출됩니다 .</target>
        </trans-unit>
        <trans-unit id="f13d8be73f140532f836309395f0554a59c9c6f7" translate="yes" xml:space="preserve">
          <source>Inside the body of the function literal, the receiver object passed to a call becomes an &lt;em&gt;implicit&lt;/em&gt;&lt;em&gt;this&lt;/em&gt;, so that you can access the members of that receiver object without any additional qualifiers, or access the receiver object using a &lt;a href=&quot;this-expressions&quot;&gt;&lt;code&gt;this&lt;/code&gt; expression&lt;/a&gt;.</source>
          <target state="translated">함수 리터럴의 몸 내부의 호출에 전달 된 수신기 객체가 될 &lt;em&gt;암시 &lt;/em&gt;&lt;em&gt;이&lt;/em&gt; , 그래서 당신이 사용하는 추가 규정 또는 액세스하지 않고 수신기 객체를 그 수신기 객체의 멤버에 액세스 할 수있는 &lt;a href=&quot;this-expressions&quot;&gt; &lt;code&gt;this&lt;/code&gt; 표현&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="2558cc93d05f62b7942210cca1e0fecc8bdce932" translate="yes" xml:space="preserve">
          <source>Inside the class that declares a lateinit property, you can check if it has been initialized:</source>
          <target state="translated">lateinit 속성을 선언하는 클래스 내에서 초기화되었는지 확인할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="987506c0627eacba63113c8eade53536a31e1484" translate="yes" xml:space="preserve">
          <source>Inside the file, the documentation for the module as a whole and for individual packages is introduced by the corresponding first-level headings. The text of the heading must be &quot;Module &lt;code&gt;&amp;lt;module name&amp;gt;&lt;/code&gt;&quot; for the module, and &quot;Package &lt;code&gt;&amp;lt;package qualified name&amp;gt;&lt;/code&gt;&quot; for a package.</source>
          <target state="translated">파일 내에서 모듈 전체 및 개별 패키지에 대한 설명서는 해당하는 첫 번째 수준 제목으로 소개됩니다. 표제의 텍스트는 모듈의 경우 &quot;모듈 &lt;code&gt;&amp;lt;module name&amp;gt;&lt;/code&gt; &quot;이고 패키지의 경우 &quot;패키지 &lt;code&gt;&amp;lt;package qualified name&amp;gt;&lt;/code&gt; &quot; 이어야 합니다.</target>
        </trans-unit>
        <trans-unit id="493e88f297e12412d7ac95bb437b962fd0497829" translate="yes" xml:space="preserve">
          <source>Inside the lambda of a scope function, the context object is available by a short reference instead of its actual name. Each scope function uses one of two ways to access the context object: as a lambda &lt;a href=&quot;lambdas#function-literals-with-receiver&quot;&gt;receiver&lt;/a&gt; (&lt;code&gt;this&lt;/code&gt;) or as a lambda argument (&lt;code&gt;it&lt;/code&gt;). Both provide the same capabilities, so we'll describe the pros and cons of each for different cases and provide recommendations on their use.</source>
          <target state="translated">범위 함수의 람다 내에서 컨텍스트 오브젝트는 실제 이름 대신 짧은 참조로 사용 가능합니다. 각 범위 함수는 컨텍스트 객체에 액세스하는 두 가지 방법 중 하나를 사용합니다. 람다 &lt;a href=&quot;lambdas#function-literals-with-receiver&quot;&gt;수신기&lt;/a&gt; ( &lt;code&gt;this&lt;/code&gt; ) 또는 람다 인수 ( &lt;code&gt;it&lt;/code&gt; ). 둘 다 동일한 기능을 제공하므로 서로 다른 경우에 대한 각각의 장단점을 설명하고 사용에 대한 권장 사항을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="5003ad2518c8a72a35acc2813b3f299786173c02" translate="yes" xml:space="preserve">
          <source>Inspect Generated Kotlin APIs from a C library</source>
          <target state="translated">C 라이브러리에서 생성 된 Kotlin API 검사</target>
        </trans-unit>
        <trans-unit id="40cd793a9f0552fd84c4436f73c844d1482e9756" translate="yes" xml:space="preserve">
          <source>Inspect the contents of &lt;code&gt;dist/klib/platform/$target&lt;/code&gt; of the distribution for the details.</source>
          <target state="translated">세부 사항은 분배 의 &lt;code&gt;dist/klib/platform/$target&lt;/code&gt; 의 내용을 검사 하십시오.</target>
        </trans-unit>
        <trans-unit id="125c70324902d1ea37a08feb6e548d2fa859e9e8" translate="yes" xml:space="preserve">
          <source>Inspecting Generated Kotlin APIs for a C library</source>
          <target state="translated">C 라이브러리에 대해 생성 된 Kotlin API 검사</target>
        </trans-unit>
        <trans-unit id="bc318e2b8cd3f066b53b59698e603a8b1ca8d81c" translate="yes" xml:space="preserve">
          <source>Install custom unhandled exception hook. Returns old hook, or null if it was not specified. Hook is invoked whenever there's uncaught exception reaching boundaries of the Kotlin world, i.e. top level main(), or when Objective-C to Kotlin call not marked with @Throws throws an exception. Hook must be a frozen lambda, so that it could be called from any thread/worker. Hook is invoked once, and is cleared afterwards, so that memory leak detection works as expected even with custom exception hooks.</source>
          <target state="translated">처리되지 않은 사용자 지정 예외 후크를 설치하십시오. 이전 후크를 반환하거나 지정되지 않은 경우 null을 반환합니다. Kotlin 세계의 경계에 도달하지 않은 예외 (예 : 최상위 main ()) 또는 @Throws로 표시되지 않은 Objective-C에서 Kotlin 호출로 예외가 발생하면 후크가 호출됩니다. 후크는 고정 된 람다이어야하므로 모든 스레드 / 작업자에서 호출 할 수 있습니다. 후크가 한 번 호출 된 후 나중에 지워 지므로 사용자 정의 예외 후크에서도 메모리 누수 감지가 예상대로 작동합니다.</target>
        </trans-unit>
        <trans-unit id="61dc4e9bf861172198001de007eee7dfc119f627" translate="yes" xml:space="preserve">
          <source>Install libgit2 and prepare stubs for the git library:</source>
          <target state="translated">libgit2를 설치하고 git 라이브러리를위한 스텁을 준비하십시오 :</target>
        </trans-unit>
        <trans-unit id="55178375f2d34a4d0b5f0a6c687d2b1b982ae90c" translate="yes" xml:space="preserve">
          <source>Install the &lt;a href=&quot;https://chrome.google.com/webstore/detail/jetbrains-ide-support/hmhgeddbohgjknpmjagkdomcpobmllji?hl=en&quot;&gt;JetBrains Chrome Extension&lt;/a&gt; which allows debugging inside IntelliJ IDEA via Chrome. This is useful for any type of web application developed with IntelliJ IDEA, not just Kotlin.</source>
          <target state="translated">&lt;a href=&quot;https://chrome.google.com/webstore/detail/jetbrains-ide-support/hmhgeddbohgjknpmjagkdomcpobmllji?hl=en&quot;&gt;Chrome&lt;/a&gt; 을 통해 IntelliJ IDEA 내에서 디버깅 할 수 있는 JetBrains Chrome 확장 프로그램 을 설치하십시오 . 이것은 Kotlin뿐만 아니라 IntelliJ IDEA로 개발 된 모든 유형의 웹 응용 프로그램에 유용합니다.</target>
        </trans-unit>
        <trans-unit id="fdaed5952d98f86231a297a2212142ac7c035122" translate="yes" xml:space="preserve">
          <source>Installing EduTools plugin</source>
          <target state="translated">EduTools 플러그인 설치</target>
        </trans-unit>
        <trans-unit id="2a79a656994e8f8c151cea0c7b39c2c9e4d16ed5" translate="yes" xml:space="preserve">
          <source>Instance Checks</source>
          <target state="translated">인스턴스 확인</target>
        </trans-unit>
        <trans-unit id="9e1218ddd72144e647203114e5a8e7ec310019cb" translate="yes" xml:space="preserve">
          <source>Instance fields</source>
          <target state="translated">인스턴스 필드</target>
        </trans-unit>
        <trans-unit id="808164c9992eeb307ee53ea9dae39f6fb259b6e5" translate="yes" xml:space="preserve">
          <source>Instance required to make a call to the member, or an outer class instance for an inner class constructor.</source>
          <target state="translated">멤버를 호출하는 데 필요한 인스턴스 또는 내부 클래스 생성자를위한 외부 클래스 인스턴스</target>
        </trans-unit>
        <trans-unit id="a15783fb8d36e7147f368f4e99e9d406c5062f79" translate="yes" xml:space="preserve">
          <source>Instantiating a function type</source>
          <target state="translated">함수 타입 인스턴스화</target>
        </trans-unit>
        <trans-unit id="4d2cc7618aade0b4e22b2f6e46628e00aba0ed39" translate="yes" xml:space="preserve">
          <source>Instead of calling the method &lt;code&gt;matches&lt;/code&gt; directly we are storing a reference to it. Such reference is bound to its receiver. It can be called directly (like in the example above) or used whenever an expression of function type is expected:</source>
          <target state="translated">메소드 &lt;code&gt;matches&lt;/code&gt; 직접 호출하는 대신 참조를 저장합니다. 이러한 참조는 수신기에 바인딩됩니다. 함수 유형의 표현식이 필요할 때마다 직접 호출하거나 (위의 예와 같이) 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8213790556130c398f868064e28de372b2469df8" translate="yes" xml:space="preserve">
          <source>Instead of creating a function object for the parameter and generating a call, the compiler could emit the following code:</source>
          <target state="translated">매개 변수에 대한 함수 객체를 만들고 호출을 생성하는 대신 컴파일러는 다음 코드를 생성 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f83cef13eec16cda3d2cf44a7d9356f601633a76" translate="yes" xml:space="preserve">
          <source>Instead of threads Kotlin/Native runtime offers the concept of workers: concurrently executed control flow streams with an associated request queue. Workers are very similar to the actors in the Actor Model. A worker can exchange Kotlin objects with another worker, so that at any moment each mutable object is owned by a single worker, but ownership can be transferred. See section &lt;a href=&quot;#transfer&quot;&gt;Object transfer and freezing&lt;/a&gt;.</source>
          <target state="translated">스레드 대신 Kotlin / Native 런타임은 작업자의 개념을 제공합니다. 연관된 요청 큐와 함께 동시에 실행 된 제어 흐름 스트림. 워커는 액터 모델의 액터와 매우 유사합니다. 작업자는 Kotlin 개체를 다른 작업자와 교환 할 수 있으므로 언제든지 각 변경 가능한 개체를 단일 작업자가 소유하지만 소유권을 양도 할 수 있습니다. &lt;a href=&quot;#transfer&quot;&gt;개체 전송 및 고정&lt;/a&gt; 섹션을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="72f70be3d9872cba860894ac5cf17293ed0d78f8" translate="yes" xml:space="preserve">
          <source>Instructs compiler to generate or omit wildcards for type arguments corresponding to parameters with declaration-site variance, for example such as &lt;code&gt;Collection&amp;lt;out T&amp;gt;&lt;/code&gt; has.</source>
          <target state="translated">&lt;code&gt;Collection&amp;lt;out T&amp;gt;&lt;/code&gt; - out T&amp;gt; 와 같이 선언 사이트 차이가있는 매개 변수에 해당하는 형식 인수에 대해 와일드 카드를 생성하거나 생략하도록 컴파일러에 지시 합니다.</target>
        </trans-unit>
        <trans-unit id="783a81e7c87c37045741ac6ac177384c0af024d5" translate="yes" xml:space="preserve">
          <source>Instructs compiler to generate wildcard for annotated type arguments corresponding to parameters with declaration-site variance.</source>
          <target state="translated">선언 사이트 편차가있는 매개 변수에 해당하는 주석이 달린 형식 인수에 대해 와일드 카드를 생성하도록 컴파일러에 지시합니다.</target>
        </trans-unit>
        <trans-unit id="2008818ef3a5b5313d7106b4d54dde4c0275e9fe" translate="yes" xml:space="preserve">
          <source>Instructs the Kotlin compiler not to generate getters/setters for this property and expose it as a field.</source>
          <target state="translated">Kotlin 컴파일러에게이 속성에 대한 getter / setter를 생성하지 않고 필드로 노출하지 않도록 지시합니다.</target>
        </trans-unit>
        <trans-unit id="13386323cf0532c0c864d57e3f5e6f155f3a611f" translate="yes" xml:space="preserve">
          <source>Instructs the Kotlin compiler to generate a multifile class with top-level functions and properties declared in this file as one of its parts. Name of the corresponding multifile class is provided by the &lt;a href=&quot;-jvm-name/index#kotlin.jvm.JvmName&quot;&gt;JvmName&lt;/a&gt; annotation.</source>
          <target state="translated">Kotlin 컴파일러가이 파일에서 일부로 선언 된 최상위 함수 및 속성을 가진 다중 파일 클래스를 생성하도록 지시합니다. 해당 멀티 파일 클래스의 이름은 &lt;a href=&quot;-jvm-name/index#kotlin.jvm.JvmName&quot;&gt;JvmName&lt;/a&gt; 주석으로 제공됩니다 .</target>
        </trans-unit>
        <trans-unit id="c90ad955a31d769d0ca4882df53d8563d188c893" translate="yes" xml:space="preserve">
          <source>Instructs the Kotlin compiler to generate a multifile class with top-level functions and properties declared in this file as one of its parts. Name of the corresponding multifile class is provided by the &lt;a href=&quot;../-jvm-name/index#kotlin.jvm.JvmName&quot;&gt;JvmName&lt;/a&gt; annotation.</source>
          <target state="translated">Kotlin 컴파일러가이 파일에서 일부로 선언 된 최상위 함수 및 속성을 가진 다중 파일 클래스를 생성하도록 지시합니다. 해당 멀티 파일 클래스의 이름은 &lt;a href=&quot;../-jvm-name/index#kotlin.jvm.JvmName&quot;&gt;JvmName&lt;/a&gt; 주석으로 제공됩니다 .</target>
        </trans-unit>
        <trans-unit id="8b0c8be222fd671f12f20bd767b02c4381772bb8" translate="yes" xml:space="preserve">
          <source>Instructs the Kotlin compiler to generate a multifile class with top-level functions and properties declared in this file as one of its parts. Name of the corresponding multifile class is provided by the &lt;a href=&quot;../../kotlin.jvm/-jvm-name/index#kotlin.jvm.JvmName&quot;&gt;JvmName&lt;/a&gt; annotation.</source>
          <target state="translated">Kotlin 컴파일러가이 파일에서 일부로 선언 된 최상위 함수 및 속성을 가진 다중 파일 클래스를 생성하도록 지시합니다. 해당 멀티 파일 클래스의 이름은 &lt;a href=&quot;../../kotlin.jvm/-jvm-name/index#kotlin.jvm.JvmName&quot;&gt;JvmName&lt;/a&gt; 주석으로 제공됩니다 .</target>
        </trans-unit>
        <trans-unit id="7818697c4ce6725112184b56cee9c62bbd312790" translate="yes" xml:space="preserve">
          <source>Instructs the Kotlin compiler to generate a multifile class with top-level functions and properties declared in this file as one of its parts. Name of the corresponding multifile class is provided by the &lt;a href=&quot;../kotlin.jvm/-jvm-name/index#kotlin.jvm.JvmName&quot;&gt;JvmName&lt;/a&gt; annotation.</source>
          <target state="translated">Kotlin 컴파일러가이 파일에서 일부로 선언 된 최상위 함수 및 속성을 가진 다중 파일 클래스를 생성하도록 지시합니다. 해당 멀티 파일 클래스의 이름은 &lt;a href=&quot;../kotlin.jvm/-jvm-name/index#kotlin.jvm.JvmName&quot;&gt;JvmName&lt;/a&gt; 주석으로 제공됩니다 .</target>
        </trans-unit>
        <trans-unit id="b493b4c87b9464cb2f6602a1607cbc49417f03a7" translate="yes" xml:space="preserve">
          <source>Instructs the Kotlin compiler to generate overloads for this function that substitute default parameter values.</source>
          <target state="translated">기본 매개 변수 값을 대체하는이 함수에 대한 과부하를 생성하도록 Kotlin 컴파일러에 지시합니다.</target>
        </trans-unit>
        <trans-unit id="b7b71d6677358cf2e0528038c668cb35b0db79e9" translate="yes" xml:space="preserve">
          <source>Instructs the Kotlin compiler to treat annotated Java class as pure implementation of given Kotlin interface. &quot;Pure&quot; means here that each type parameter of class becomes non-platform type argument of that interface.</source>
          <target state="translated">주석이 달린 Java 클래스를 주어진 Kotlin 인터페이스의 순수한 구현으로 취급하도록 Kotlin 컴파일러에 지시합니다. &quot;순수&quot;는 클래스의 각 유형 매개 변수가 해당 인터페이스의 비 플랫폼 유형 인수가됨을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="5c89edcac2811a6a9e8072517cae7f3cbfd5049d" translate="yes" xml:space="preserve">
          <source>Int</source>
          <target state="translated">Int</target>
        </trans-unit>
        <trans-unit id="691e0102b6c4ff1f7d6b4b79971b501f00d71a45" translate="yes" xml:space="preserve">
          <source>Int16Array</source>
          <target state="translated">Int16Array</target>
        </trans-unit>
        <trans-unit id="5c193dd46f10dac764d5258087bf039ad767fbce" translate="yes" xml:space="preserve">
          <source>Int32Array</source>
          <target state="translated">Int32Array</target>
        </trans-unit>
        <trans-unit id="e088a2144c05ba06fd761a7dbefbb84d2fc79069" translate="yes" xml:space="preserve">
          <source>Int8Array</source>
          <target state="translated">Int8Array</target>
        </trans-unit>
        <trans-unit id="4e1eee767ff111b716b2cc9473b02ef4802f7fa3" translate="yes" xml:space="preserve">
          <source>IntArray</source>
          <target state="translated">IntArray</target>
        </trans-unit>
        <trans-unit id="80050b51df21784d163dd20b4b73efde68f88f12" translate="yes" xml:space="preserve">
          <source>IntIterator</source>
          <target state="translated">IntIterator</target>
        </trans-unit>
        <trans-unit id="5808b7bdff6fe2202d34d31f55aa02c48c8f9d57" translate="yes" xml:space="preserve">
          <source>IntProgression</source>
          <target state="translated">IntProgression</target>
        </trans-unit>
        <trans-unit id="1ecd34c101b616e04032d5f18915a529dbf2c1ba" translate="yes" xml:space="preserve">
          <source>IntRange</source>
          <target state="translated">IntRange</target>
        </trans-unit>
        <trans-unit id="122a70b702fe4ea6640b0afbf0db142a8ee86964" translate="yes" xml:space="preserve">
          <source>IntVar</source>
          <target state="translated">IntVar</target>
        </trans-unit>
        <trans-unit id="3d2bffbceb8bff9b98f810d1689ed67697bea8bf" translate="yes" xml:space="preserve">
          <source>IntVarOf</source>
          <target state="translated">IntVarOf</target>
        </trans-unit>
        <trans-unit id="876569ad85ebaf17d9149dea5706aba22e882fe8" translate="yes" xml:space="preserve">
          <source>Integer types</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dee1ac1dc651dc2435d67e71a4478aae5437b7bf" translate="yes" xml:space="preserve">
          <source>Integer types in Kotlin have a &lt;em&gt;limited size&lt;/em&gt;, as opposed to the arbitrarily large integers in Python. The limit depends on the type, which decides how many bits the number occupies in memory:</source>
          <target state="translated">Kotlin의 정수 유형 은 Python의 임의로 큰 정수와 달리 &lt;em&gt;크기&lt;/em&gt; 가 &lt;em&gt;제한되어 있습니다&lt;/em&gt; . 제한은 유형에 따라 달라지며, 숫자는 메모리에서 숫자가 차지하는 비트 수를 결정합니다.</target>
        </trans-unit>
        <trans-unit id="cda60a10cf7788b96a2f3e8c4df843ff16bf37d4" translate="yes" xml:space="preserve">
          <source>Integral type ranges (&lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.ranges/-int-range/index&quot;&gt;&lt;code&gt;IntRange&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.ranges/-long-range/index&quot;&gt;&lt;code&gt;LongRange&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.ranges/-char-range/index&quot;&gt;&lt;code&gt;CharRange&lt;/code&gt;&lt;/a&gt;) have an extra feature: they can be iterated over. These ranges are also &lt;a href=&quot;https://en.wikipedia.org/wiki/Arithmetic_progression&quot;&gt;progressions&lt;/a&gt; of the corresponding integral types. Such ranges are generally used for iteration in the &lt;code&gt;for&lt;/code&gt; loops.</source>
          <target state="translated">통합 유형 범위 ( &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.ranges/-int-range/index&quot;&gt; &lt;code&gt;IntRange&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.ranges/-long-range/index&quot;&gt; &lt;code&gt;LongRange&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.ranges/-char-range/index&quot;&gt; &lt;code&gt;CharRange&lt;/code&gt; &lt;/a&gt; )에는 추가 기능이 있습니다. 반복 될 수 있습니다. 이 범위는 해당 정수 유형의 &lt;a href=&quot;https://en.wikipedia.org/wiki/Arithmetic_progression&quot;&gt;진행률&lt;/a&gt; 입니다. 이러한 범위는 일반적으로 &lt;code&gt;for&lt;/code&gt; 루프 에서 반복에 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="8489966f59e24770658292f5a494ac85bfb4f6e0" translate="yes" xml:space="preserve">
          <source>IntelliJ IDEA can run your scratches automatically. To get the execution results once you stop typing for a short time, switch on the &lt;strong&gt;Interactive mode&lt;/strong&gt;.</source>
          <target state="translated">IntelliJ IDEA는 스크래치를 자동으로 실행할 수 있습니다. 짧은 시간 동안 입력을 중지 한 후에 실행 결과를 얻으려면 &lt;strong&gt;대화식 모드를&lt;/strong&gt; 켜십시오 .</target>
        </trans-unit>
        <trans-unit id="11066aac7596078ae46263d8a457c412baa42d01" translate="yes" xml:space="preserve">
          <source>IntelliJ IDEA will add the corresponding entries for us in the &lt;a href=&quot;#maven-configuration&quot;&gt;Maven configuration&lt;/a&gt;.</source>
          <target state="translated">IntelliJ IDEA는 &lt;a href=&quot;#maven-configuration&quot;&gt;Maven 구성&lt;/a&gt; 에서 해당 항목을 추가합니다 .</target>
        </trans-unit>
        <trans-unit id="54d05b8bf6f20e0d324256cf774765900389821b" translate="yes" xml:space="preserve">
          <source>Interact with the DOM</source>
          <target state="translated">DOM과 상호 작용</target>
        </trans-unit>
        <trans-unit id="2c419294377dd8ca37e7cb76b4dea91ed19ea8dc" translate="yes" xml:space="preserve">
          <source>Interacting with the DOM</source>
          <target state="translated">DOM과의 상호 작용</target>
        </trans-unit>
        <trans-unit id="0d798c0b1cd4a6d135dc1e4671cde5f33dab863b" translate="yes" xml:space="preserve">
          <source>Interactive mode</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b02084f4df61f4f1999048df4a4f737cbeb8d5d5" translate="yes" xml:space="preserve">
          <source>Intercept continuation with &lt;a href=&quot;../-continuation-interceptor/index&quot;&gt;ContinuationInterceptor&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;../-continuation-interceptor/index&quot;&gt;ContinuationInterceptor로&lt;/a&gt; 인터셉트 계속 .</target>
        </trans-unit>
        <trans-unit id="653ee20081a2ed0c0dfdeafb8d4cc56b1706495b" translate="yes" xml:space="preserve">
          <source>Intercept continuation with &lt;a href=&quot;../kotlin.coroutines.experimental/-continuation-interceptor/index&quot;&gt;ContinuationInterceptor&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;../kotlin.coroutines.experimental/-continuation-interceptor/index&quot;&gt;ContinuationInterceptor로&lt;/a&gt; 인터셉트 계속 .</target>
        </trans-unit>
        <trans-unit id="ef76b9eb4630422886c9e0fac2f1db0f2f6f1af1" translate="yes" xml:space="preserve">
          <source>Interception of delegated property binding</source>
          <target state="translated">위임 된 속성 바인딩 차단</target>
        </trans-unit>
        <trans-unit id="fc7a4e9264f9fe99aec05e3498611be00e954e41" translate="yes" xml:space="preserve">
          <source>Intercepts this continuation with &lt;a href=&quot;../kotlin.coroutines/-continuation-interceptor/index&quot;&gt;ContinuationInterceptor&lt;/a&gt;.</source>
          <target state="translated">이 연속을 &lt;a href=&quot;../kotlin.coroutines/-continuation-interceptor/index&quot;&gt;ContinuationInterceptor로&lt;/a&gt; 차단합니다 .</target>
        </trans-unit>
        <trans-unit id="16bd3eae0558639cfe5dccb9e5a929f401a38bef" translate="yes" xml:space="preserve">
          <source>Interface implementation layout</source>
          <target state="translated">인터페이스 구현 레이아웃</target>
        </trans-unit>
        <trans-unit id="b4d21bf63ded1f81b33de5ff71ef6ec0031cdd1f" translate="yes" xml:space="preserve">
          <source>Interface representing a continuation after a suspension point that returns a value of type &lt;code&gt;T&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;T&lt;/code&gt; 유형의 값을 리턴하는 서스펜션 지점 이후의 연속을 나타내는 인터페이스 입니다.</target>
        </trans-unit>
        <trans-unit id="3d559a197ac3fd74c061414f5d71be30830c373e" translate="yes" xml:space="preserve">
          <source>Interface representing a continuation after a suspension point that returns value of type &lt;code&gt;T&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;T&lt;/code&gt; 유형의 값을 리턴하는 서스펜션 지점 이후의 연속을 나타내는 인터페이스 입니다.</target>
        </trans-unit>
        <trans-unit id="b356313f979923fc829adb909098ed26a5a01aff" translate="yes" xml:space="preserve">
          <source>Interfaces</source>
          <target state="translated">Interfaces</target>
        </trans-unit>
        <trans-unit id="3fb0788052e6b21a9e30969754a6a4b19102a8cb" translate="yes" xml:space="preserve">
          <source>Interfaces &lt;em&gt;A&lt;/em&gt; and &lt;em&gt;B&lt;/em&gt; both declare functions &lt;em&gt;foo()&lt;/em&gt; and &lt;em&gt;bar()&lt;/em&gt;. Both of them implement &lt;em&gt;foo()&lt;/em&gt;, but only &lt;em&gt;B&lt;/em&gt; implements &lt;em&gt;bar()&lt;/em&gt; (&lt;em&gt;bar()&lt;/em&gt; is not marked abstract in &lt;em&gt;A&lt;/em&gt;, because this is the default for interfaces, if the function has no body). Now, if we derive a concrete class &lt;em&gt;C&lt;/em&gt; from &lt;em&gt;A&lt;/em&gt;, we, obviously, have to override &lt;em&gt;bar()&lt;/em&gt; and provide an implementation.</source>
          <target state="translated">인터페이스 &lt;em&gt;A&lt;/em&gt; 와 &lt;em&gt;B는&lt;/em&gt; 모두 &lt;em&gt;foo ()&lt;/em&gt; 및 &lt;em&gt;bar ()&lt;/em&gt; 함수를 선언합니다 . 둘 다 &lt;em&gt;foo ()를&lt;/em&gt; 구현 하지만 &lt;em&gt;B&lt;/em&gt; 만 구현합니다. &lt;em&gt;bar ()&lt;/em&gt; ( &lt;em&gt;bar ()&lt;/em&gt; 는 &lt;em&gt;A&lt;/em&gt; 에서 abstract로 표시되지 않습니다 . 함수에 본문이 없으면 인터페이스의 기본값이므로). 이제 &lt;em&gt;A&lt;/em&gt; 에서 구체적인 클래스 &lt;em&gt;C&lt;/em&gt; 를 파생 시키면 &lt;em&gt;bar ()&lt;/em&gt; 를 재정의 하고 구현을 제공해야합니다.&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="99ffdc8085488e57490fe414d8c6f2ac4c1599ac" translate="yes" xml:space="preserve">
          <source>Interfaces Inheritance</source>
          <target state="translated">인터페이스 상속</target>
        </trans-unit>
        <trans-unit id="8b075e134839d5d81cca3ebe6834964746dbfa9f" translate="yes" xml:space="preserve">
          <source>Interfaces in Kotlin are very similar to Java 8. They can contain declarations of abstract methods, as well as method implementations. What makes them different from abstract classes is that interfaces cannot store state. They can have properties but these need to be abstract or to provide accessor implementations.</source>
          <target state="translated">Kotlin의 인터페이스는 Java 8과 매우 유사합니다. 여기에는 메소드 구현뿐만 아니라 추상 메소드 선언도 포함될 수 있습니다. 그것들을 추상 클래스와 다른 점은 인터페이스가 상태를 저장할 수 없다는 것입니다. 속성을 가질 수 있지만 이들은 추상적이거나 접근 자 구현을 제공해야합니다.</target>
        </trans-unit>
        <trans-unit id="f3a19a0ac9dc5495efba84238a1c889b8a1af7e4" translate="yes" xml:space="preserve">
          <source>Interop with Java</source>
          <target state="translated">Java와의 Interop</target>
        </trans-unit>
        <trans-unit id="c644acaf1f3c1a0ed7a1256f251846c1b5938545" translate="yes" xml:space="preserve">
          <source>InteropStubs</source>
          <target state="translated">InteropStubs</target>
        </trans-unit>
        <trans-unit id="e8ee8f70e7d8b9c0f444242c7791f8de975f2a89" translate="yes" xml:space="preserve">
          <source>Interoperability</source>
          <target state="translated">Interoperability</target>
        </trans-unit>
        <trans-unit id="68de227c33695f7eee1af76e54576c5f473dbabb" translate="yes" xml:space="preserve">
          <source>Interoperability With Java Reflection</source>
          <target state="translated">Java 리플렉션과의 상호 운용성</target>
        </trans-unit>
        <trans-unit id="768631baf54d445fa8bf1b363fe5b7347532e0f6" translate="yes" xml:space="preserve">
          <source>Interoperability with Swift/Objective-C is provided too and covered in a separate document &lt;a href=&quot;objc_interop&quot;&gt;OBJC_INTEROP.md&lt;/a&gt;.</source>
          <target state="translated">Swift / Objective-C와의 상호 운용성도 제공되며 별도의 문서 &lt;a href=&quot;objc_interop&quot;&gt;OBJC_INTEROP.md에서 다루고&lt;/a&gt; 있습니다.</target>
        </trans-unit>
        <trans-unit id="cf0f2c7977d4a0d28911368671a5b929d3d0eeba" translate="yes" xml:space="preserve">
          <source>Introducing an expression as a variable in local scope: &lt;code&gt;let&lt;/code&gt;</source>
          <target state="translated">로컬 범위에서 변수로 표현식 소개 : &lt;code&gt;let&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="2473e96bc614a911821242119918a241a41836d6" translate="yes" xml:space="preserve">
          <source>Introduction</source>
          <target state="translated">Introduction</target>
        </trans-unit>
        <trans-unit id="32255fd1a8ee65ebb05876eff1fd292d27126703" translate="yes" xml:space="preserve">
          <source>Introduction to Kotlin (in Russian)</source>
          <target state="translated">코 틀린 소개 (러시아어)</target>
        </trans-unit>
        <trans-unit id="8907e06f66221d3c7deda7eaa03a2cc4d7313211" translate="yes" xml:space="preserve">
          <source>Introduction to Kotlin Programming</source>
          <target state="translated">코 틀린 프로그래밍 소개</target>
        </trans-unit>
        <trans-unit id="1a733ca17cc418ac2040451ede20832965697fc4" translate="yes" xml:space="preserve">
          <source>InvalidMutabilityException</source>
          <target state="translated">InvalidMutabilityException</target>
        </trans-unit>
        <trans-unit id="ed8bc42e69c9abe4619cbcab39f65339c9a9ce60" translate="yes" xml:space="preserve">
          <source>Inverts the bits in this value.</source>
          <target state="translated">이 값의 비트를 반전시킵니다.</target>
        </trans-unit>
        <trans-unit id="555df15449eba01e6d316f12f10d25ead6974375" translate="yes" xml:space="preserve">
          <source>Inverts the bits including the sign bit in this value.</source>
          <target state="translated">이 값에서 부호 비트를 포함하는 비트를 반전시킵니다.</target>
        </trans-unit>
        <trans-unit id="1808969803eb296cd6d4f6a8c06b19cec81c8416" translate="yes" xml:space="preserve">
          <source>Invocation of &lt;a href=&quot;../kotlin.coroutines/-continuation/resume-with&quot;&gt;Continuation.resumeWith&lt;/a&gt; resumes coroutine directly in the invoker's thread without going through the &lt;a href=&quot;../kotlin.coroutines/-continuation-interceptor/index&quot;&gt;ContinuationInterceptor&lt;/a&gt; that might be present in the coroutine's &lt;a href=&quot;../kotlin.coroutines/-coroutine-context/index&quot;&gt;CoroutineContext&lt;/a&gt;. It is the invoker's responsibility to ensure that a proper invocation context is established. &lt;a href=&quot;intercepted#kotlin.coroutines.intrinsics%24intercepted%28kotlin.coroutines.Continuation%28%28kotlin.coroutines.intrinsics.intercepted.T%29%29%29&quot;&gt;Continuation.intercepted&lt;/a&gt; can be used to acquire the intercepted continuation.</source>
          <target state="translated">의 호출 &lt;a href=&quot;../kotlin.coroutines/-continuation/resume-with&quot;&gt;Continuation.resumeWith은&lt;/a&gt; 관통하지 않고 호출자의 스레드에서 직접 코 루틴을 재개 &lt;a href=&quot;../kotlin.coroutines/-continuation-interceptor/index&quot;&gt;ContinuationInterceptor&lt;/a&gt; 코 루틴의에있을 수 &lt;a href=&quot;../kotlin.coroutines/-coroutine-context/index&quot;&gt;CoroutineContext&lt;/a&gt; . 적절한 호출 컨텍스트가 설정되도록하는 것은 호출자의 책임입니다. &lt;a href=&quot;intercepted#kotlin.coroutines.intrinsics%24intercepted%28kotlin.coroutines.Continuation%28%28kotlin.coroutines.intrinsics.intercepted.T%29%29%29&quot;&gt;Continuation.intercepted는&lt;/a&gt; 가로 챈 지속을 취득 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a142e8aa439986e2d57c987fdc039b4c2ce8b67d" translate="yes" xml:space="preserve">
          <source>InvocationKind</source>
          <target state="translated">InvocationKind</target>
        </trans-unit>
        <trans-unit id="32a85866515d2c40342d72243d3af2e2ade61880" translate="yes" xml:space="preserve">
          <source>Invoke operator</source>
          <target state="translated">연산자 호출</target>
        </trans-unit>
        <trans-unit id="90d36cdc449e51ffdeb986b93d9cc3791424dd45" translate="yes" xml:space="preserve">
          <source>Invoked for the continuation instance returned by &lt;a href=&quot;intercept-continuation&quot;&gt;interceptContinuation&lt;/a&gt; when the original continuation completes and will not be used anymore. This function is invoked only if &lt;a href=&quot;intercept-continuation&quot;&gt;interceptContinuation&lt;/a&gt; had returned a different continuation instance from the one it was invoked with.</source>
          <target state="translated">원래 연속이 완료되어 더 이상 사용되지 않을 때 &lt;a href=&quot;intercept-continuation&quot;&gt;interceptContinuation에&lt;/a&gt; 의해 리턴 된 연속 인스턴스에 대해 호출됩니다 . 이 함수는 &lt;a href=&quot;intercept-continuation&quot;&gt;interceptContinuation&lt;/a&gt; 이 호출 된 것과 다른 연속 인스턴스를 리턴 한 경우에만 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="e7b262710ce446d5dceec2a721a656e3054eebf5" translate="yes" xml:space="preserve">
          <source>Invoking &lt;code&gt;call()&lt;/code&gt; on a function object will call the function. If it is a member function, the first parameter must be the &lt;em&gt;receiver&lt;/em&gt; (the object on which the function is to be invoked, in this case &lt;code&gt;person&lt;/code&gt;), and the remaining parameters must be the ordinary function parameters (in this case &lt;code&gt;&quot;Anne&quot;&lt;/code&gt;).</source>
          <target state="translated">호출 &lt;code&gt;call()&lt;/code&gt; 함수 객체에하면 함수를 호출합니다. 멤버 함수 인 경우 첫 번째 매개 변수는 &lt;em&gt;수신자&lt;/em&gt; (이 경우 &lt;code&gt;person&lt;/code&gt; 을 호출 할 오브젝트 )이고 나머지 매개 변수는 일반 함수 매개 변수 (이 경우 &lt;code&gt;&quot;Anne&quot;&lt;/code&gt; ) 여야합니다. .</target>
        </trans-unit>
        <trans-unit id="e517c0efd966757777074a55cf84552ef188ca9a" translate="yes" xml:space="preserve">
          <source>Invoking &lt;code&gt;findViewById()&lt;/code&gt; can be slow, especially in case of huge view hierarchies, so Android Extensions tries to minimize &lt;code&gt;findViewById()&lt;/code&gt; calls by caching views in containers.</source>
          <target state="translated">특히 대규모 뷰 계층 구조의 경우 &lt;code&gt;findViewById()&lt;/code&gt; 호출 이 느려질 수 있으므로 Android Extensions는 컨테이너에서 뷰를 캐싱하여 &lt;code&gt;findViewById()&lt;/code&gt; 호출 을 최소화하려고합니다 .</target>
        </trans-unit>
        <trans-unit id="55b7cc54c31bd895727aeb7e2e5dfcfeaf500f67" translate="yes" xml:space="preserve">
          <source>Invoking a function type instance</source>
          <target state="translated">함수형 인스턴스 호출</target>
        </trans-unit>
        <trans-unit id="609d1188a5fb6f3c57a44ee5ee27b2fb07938bf1" translate="yes" xml:space="preserve">
          <source>Invoking functions on other collections</source>
          <target state="translated">다른 컬렉션에서 함수 호출</target>
        </trans-unit>
        <trans-unit id="39f649540ce7c567f8fc21179741df12bdec413a" translate="yes" xml:space="preserve">
          <source>Is Kotlin an object-oriented language or a functional one?</source>
          <target state="translated">코 틀린은 객체 지향 언어입니까, 기능 언어입니까?</target>
        </trans-unit>
        <trans-unit id="0396150c49da7aa331143384cade7b9761b9c77b" translate="yes" xml:space="preserve">
          <source>Is Kotlin compatible with the Java programming language?</source>
          <target state="translated">Kotlin은 Java 프로그래밍 언어와 호환됩니까?</target>
        </trans-unit>
        <trans-unit id="d651f0b2ee6f868c27d5b6dae520cfb850abc9e7" translate="yes" xml:space="preserve">
          <source>Is Kotlin free?</source>
          <target state="translated">코 틀린은 무료입니까?</target>
        </trans-unit>
        <trans-unit id="4096c8e1086b327150a7292e4d2afe3394a12f6e" translate="yes" xml:space="preserve">
          <source>Is Kotlin hard?</source>
          <target state="translated">코 틀린은 단단합니까?</target>
        </trans-unit>
        <trans-unit id="9edc452dd78ce29f04fd4cdc3ccb57260c61debd" translate="yes" xml:space="preserve">
          <source>Is Kotlin on Social Media?</source>
          <target state="translated">코 틀린은 소셜 미디어에 있습니까?</target>
        </trans-unit>
        <trans-unit id="06373ad2bc61a9e4042f42be3c932a4374d09d55" translate="yes" xml:space="preserve">
          <source>Is extension function</source>
          <target state="translated">확장 기능</target>
        </trans-unit>
        <trans-unit id="84f7edacad77f3efea0c1f9a95023335afe8e98e" translate="yes" xml:space="preserve">
          <source>Is there a Kotlin conference?</source>
          <target state="translated">코 틀린 회의가 있습니까?</target>
        </trans-unit>
        <trans-unit id="23fb12980d63818dd24d249914c5dbde1e4eab5d" translate="yes" xml:space="preserve">
          <source>Isn't it what we wanted from the very beginning?</source>
          <target state="translated">우리가 처음부터 원하는 것이 아닌가?</target>
        </trans-unit>
        <trans-unit id="651e4641fbeb110db3b7fdfb2bb5a04a7dfe7d1b" translate="yes" xml:space="preserve">
          <source>Isolating declarations in a separate JavaScript object</source>
          <target state="translated">별도의 JavaScript 객체에서 선언 분리</target>
        </trans-unit>
        <trans-unit id="ec40e8e2417f63763bc4005b1f45f89c4b9bd620" translate="yes" xml:space="preserve">
          <source>It also works with meta-annotations:</source>
          <target state="translated">메타 주석과 함께 작동합니다.</target>
        </trans-unit>
        <trans-unit id="6f49ae3f8f0dbf679bfc3c5ff95bf21f8e30ee20" translate="yes" xml:space="preserve">
          <source>It can be demonstrated by a simple example that creates coroutines in the &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-global-scope/index.html&quot;&gt;GlobalScope&lt;/a&gt;:</source>
          <target state="translated">&lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-global-scope/index.html&quot;&gt;GlobalScope&lt;/a&gt; 에서 코 루틴을 생성하는 간단한 예제로 설명 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="c7f79c6fa89f2be4d0900a1df15f6e4c9cd6d6d8" translate="yes" xml:space="preserve">
          <source>It can of course be done as a single expression: &lt;code&gt;val x = javaFunctionThatYouKnowReturnsNonNull()!!&lt;/code&gt;.</source>
          <target state="translated">물론 단일 표현식으로 수행 할 수 있습니다 : &lt;code&gt;val x = javaFunctionThatYouKnowReturnsNonNull()!!&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b4869b700b07f0d7aa2566a42cedd6c00ff40027" translate="yes" xml:space="preserve">
          <source>It demonstrates several new techniques. One is using &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/run-blocking.html&quot;&gt;runBlocking&lt;/a&gt; with an explicitly specified context, and the other one is using &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/with-context.html&quot;&gt;withContext&lt;/a&gt; function to change a context of a coroutine while still staying in the same coroutine as you can see in the output below:</source>
          <target state="translated">몇 가지 새로운 기술을 보여줍니다. 하나는 명시 적으로 지정된 컨텍스트와 함께 &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/run-blocking.html&quot;&gt;runBlocking&lt;/a&gt; 을 사용 하고 다른 하나는 &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/with-context.html&quot;&gt;withContext&lt;/a&gt; 함수를 사용하여 아래 출력에서 ​​볼 수있는 것과 동일한 코 루틴에 머물면서 코 루틴의 컨텍스트를 변경합니다.</target>
        </trans-unit>
        <trans-unit id="df6b25cff4a7799af9dc4369b6ce738113d68ee2" translate="yes" xml:space="preserve">
          <source>It does not matter (for correctness) what context the actor itself is executed in. An actor is a coroutine and a coroutine is executed sequentially, so confinement of the state to the specific coroutine works as a solution to the problem of shared mutable state. Indeed, actors may modify their own private state, but can only affect each other through messages (avoiding the need for any locks).</source>
          <target state="translated">액터 자체가 어떤 컨텍스트에서 실행되는지는 (정확성을 위해) 중요하지 않습니다. 액터는 코 루틴이고 코 루틴은 순차적으로 실행되므로 특정 코 루틴에 대한 상태의 제한은 공유 가능한 가변 상태의 문제에 대한 해결책으로 작동합니다. 실제로, 액터는 자신의 개인 상태를 수정할 수 있지만 메시지를 통해서만 서로에게 영향을 줄 수 있습니다 (잠금이 필요하지 않음).</target>
        </trans-unit>
        <trans-unit id="838f4ba272421d5995e2a80726c6cbb738d51748" translate="yes" xml:space="preserve">
          <source>It expects the targets to provide platform-specific implementations for &lt;code&gt;writeLogMessage&lt;/code&gt;, and the common code can now use this declaration without any consideration of how it is implemented.</source>
          <target state="translated">대상은 &lt;code&gt;writeLogMessage&lt;/code&gt; 에 플랫폼 별 구현을 제공 할 것으로 예상 되며, 공통 코드는 구현 방법을 고려하지 않고도이 선언을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="acca4b75fdfdc287f94d60288ba8cbf8ea940d89" translate="yes" xml:space="preserve">
          <source>It is also convenient to use when you have a callable reference instead of the lambda:</source>
          <target state="translated">람다 대신 호출 가능한 참조가있을 때 사용하는 것이 편리합니다.</target>
        </trans-unit>
        <trans-unit id="db36d25fe18e1fa8b4a072e0b9e5e699d53ac00e" translate="yes" xml:space="preserve">
          <source>It is also possible to configure all Kotlin compilation tasks in the project:</source>
          <target state="translated">프로젝트에서 모든 Kotlin 컴파일 작업을 구성 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="4e799686fc388ae642c64e9044143db835d23770" translate="yes" xml:space="preserve">
          <source>It is also possible to debug Kotlin applications using the standard Chrome debugger. Just make sure that you do generate source maps.</source>
          <target state="translated">표준 Chrome 디버거를 사용하여 Kotlin 응용 프로그램을 디버깅 할 수도 있습니다. 소스 맵을 생성해야합니다.</target>
        </trans-unit>
        <trans-unit id="2d484974349c030ade989fbea0475cbaae9e9d98" translate="yes" xml:space="preserve">
          <source>It is also possible to iterate over numbers with an arbitrary step (not necessarily 1). This is done via the &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.ranges/step&quot;&gt;&lt;code&gt;step&lt;/code&gt;&lt;/a&gt; function.</source>
          <target state="translated">임의의 단계 (필수 1은 아님)로 숫자를 반복 할 수도 있습니다. 이것은 &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.ranges/step&quot;&gt; &lt;code&gt;step&lt;/code&gt; &lt;/a&gt; 기능을 통해 수행됩니다 .</target>
        </trans-unit>
        <trans-unit id="dc446105af35ae94e82863937d04520fa631bab7" translate="yes" xml:space="preserve">
          <source>It is convenient to import all widget properties for a specific layout in one go:</source>
          <target state="translated">특정 레이아웃에 대한 모든 위젯 속성을 한 번에 가져 오는 것이 편리합니다.</target>
        </trans-unit>
        <trans-unit id="ea87fa24d13265d437721a500dc610021a2b6ae7" translate="yes" xml:space="preserve">
          <source>It is created by attaching &lt;code&gt;keySelector: (T) -&amp;gt; K&lt;/code&gt; function to a source of elements. To get an instance of &lt;a href=&quot;index&quot;&gt;Grouping&lt;/a&gt; use one of &lt;code&gt;groupingBy&lt;/code&gt; extension functions:</source>
          <target state="translated">&lt;code&gt;keySelector: (T) -&amp;gt; K&lt;/code&gt; 함수를 요소 소스 에 첨부하여 작성됩니다 . &lt;a href=&quot;index&quot;&gt;그룹화&lt;/a&gt; 인스턴스를 가져 오려면 &lt;code&gt;groupingBy&lt;/code&gt; 확장 함수 중 하나를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="9817b3326fc94d2d632dd03bcb277b7bc5e546ba" translate="yes" xml:space="preserve">
          <source>It is easy to demonstrate it in action:</source>
          <target state="translated">실제로 시연하는 것은 쉽습니다.</target>
        </trans-unit>
        <trans-unit id="5057879a755e254fb21862c60fef7113f875d675" translate="yes" xml:space="preserve">
          <source>It is easy to include a compiled Kotlin code into existing projects written in C, C++, Swift, Objective-C, and other languages. It is also easy to use existing native code, static or dynamic &lt;a href=&quot;native/c_interop&quot;&gt;C libraries&lt;/a&gt;, Swift/Objective-C &lt;a href=&quot;native/objc_interop&quot;&gt;frameworks&lt;/a&gt;, graphical engines, and anything else directly from Kotlin/Native.</source>
          <target state="translated">컴파일 된 Kotlin 코드를 C, C ++, Swift, Objective-C 및 기타 언어로 작성된 기존 프로젝트에 쉽게 포함시킬 수 있습니다. 또한 기존 네이티브 코드, 정적 또는 동적 &lt;a href=&quot;native/c_interop&quot;&gt;C 라이브러리&lt;/a&gt; , Swift / Objective-C &lt;a href=&quot;native/objc_interop&quot;&gt;프레임 워크&lt;/a&gt; , 그래픽 엔진 및 Kotlin / Native에서 직접 사용하는 모든 것을 쉽게 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="5f37ac7cf663ce39ab7cecdf53e288f77e8f878b" translate="yes" xml:space="preserve">
          <source>It is easy to use the generated wrapper classes for C &lt;code&gt;struct&lt;/code&gt; and &lt;code&gt;union&lt;/code&gt; types from Kotlin. Thanks to the generated properties, it feels natural to use them in Kotlin code. The only question, so far, is how do we create a new instance on those classes. As we see from the declarations of &lt;code&gt;MyStruct&lt;/code&gt; and &lt;code&gt;MyUnion&lt;/code&gt;, their constructors require a &lt;code&gt;NativePtr&lt;/code&gt;. Of course, we are not willing to deal with pointers manually. Instead, we can use Kotlin API to have those objects instantiated for us.</source>
          <target state="translated">Kotlin의 C &lt;code&gt;struct&lt;/code&gt; 및 &lt;code&gt;union&lt;/code&gt; 유형에 대해 생성 된 래퍼 클래스를 사용하는 것은 쉽습니다 . 생성 된 특성 덕분에 Kotlin 코드에서 자연스럽게 사용할 수 있습니다. 지금까지 유일한 질문은 이러한 클래스에서 새 인스턴스를 작성하는 방법입니다. &lt;code&gt;MyStruct&lt;/code&gt; 와 &lt;code&gt;MyUnion&lt;/code&gt; 의 선언에서 알 수 있듯이 생성자는 &lt;code&gt;NativePtr&lt;/code&gt; 이 필요합니다 . 물론, 우리는 포인터를 수동으로 다루려고하지 않습니다. 대신 Kotlin API를 사용하여 해당 객체를 인스턴스화 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="13a7c2154690aa37b95c233923686a0683d02a9e" translate="yes" xml:space="preserve">
          <source>It is equivalent to this Java code:</source>
          <target state="translated">이 Java 코드와 같습니다.</target>
        </trans-unit>
        <trans-unit id="fd011ac428fa7a3101febe89637cd71887a4e771" translate="yes" xml:space="preserve">
          <source>It is forbidden for inline classes to participate in a class hierarchy. This means that inline classes cannot extend other classes and must be &lt;em&gt;final&lt;/em&gt;.</source>
          <target state="translated">인라인 클래스가 클래스 계층에 참여하는 것은 금지되어 있습니다. 즉, 인라인 클래스는 다른 클래스를 확장 할 수 없으며 &lt;em&gt;최종&lt;/em&gt; 클래스 여야합니다 .</target>
        </trans-unit>
        <trans-unit id="baf0c1eedc3c7d76ed7d17e6f83833365d1074e5" translate="yes" xml:space="preserve">
          <source>It is important to note that some of the &lt;a href=&quot;#supported-platforms&quot;&gt;Kotlin/Native targets&lt;/a&gt; may only be built with an appropriate host machine:</source>
          <target state="translated">&lt;a href=&quot;#supported-platforms&quot;&gt;Kotlin / Native 대상&lt;/a&gt; 중 일부 는 적절한 호스트 시스템으로 만 구축 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="417f8643742c5b4b13e710785eaf864b3ada4be9" translate="yes" xml:space="preserve">
          <source>It is important to understand that just like in the case of &lt;code&gt;callAnything()&lt;/code&gt;, the &lt;code&gt;dataTable()&lt;/code&gt; function must exist at runtime. In our case, we need to make sure that the corresponding script file for our plugin is included:</source>
          <target state="translated">그것은 단지의 경우 같은 것을 이해하는 것이 중요합니다 &lt;code&gt;callAnything()&lt;/code&gt; 의 &lt;code&gt;dataTable()&lt;/code&gt; 함수는 런타임에 존재해야합니다. 우리의 경우 플러그인에 해당하는 스크립트 파일이 포함되어 있는지 확인해야합니다.</target>
        </trans-unit>
        <trans-unit id="0e863e2f2b3f4c7cb9be7530e2969137eb812edc" translate="yes" xml:space="preserve">
          <source>It is not recommended to publish variants grouped by the product flavor in case they have different dependencies, as those will be merged into one dependencies list.</source>
          <target state="translated">종속 항목이 하나 일 경우 하나의 종속성 목록으로 병합되므로 변형이 다른 경우 제품 버전별로 그룹화 된 변형을 게시하지 않는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="41a0e8e8363c715bede252f00decd03608d5ae6b" translate="yes" xml:space="preserve">
          <source>It is not required to match directories and packages: source files can be placed arbitrarily in the file system.</source>
          <target state="translated">디렉토리 및 패키지와 일치 할 필요는 없습니다. 소스 파일은 파일 시스템에 임의로 배치 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ed10861129de21214d3c19646f1725bf54132b36" translate="yes" xml:space="preserve">
          <source>It is now possible to enumerate the values of an enum class in a generic way.</source>
          <target state="translated">이제 열거 형 클래스의 값을 일반적인 방식으로 열거 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e7a4a5a763a24f82bedd348e3c81f2b59dad3138" translate="yes" xml:space="preserve">
          <source>It is platform independent. Whether we targeting JVM, JavaScript or any other platform, the code we write is the same. Under the covers the compiler takes care of adapting it to each platform.</source>
          <target state="translated">플랫폼 독립적입니다. JVM, JavaScript 또는 기타 플랫폼을 대상으로하더라도 작성하는 코드는 동일합니다. 커버 아래에서 컴파일러는 각 플랫폼에 맞게 컴파일러를 관리합니다.</target>
        </trans-unit>
        <trans-unit id="4d947185f89d323fe7c7abf6d8cbb01ea4b530eb" translate="yes" xml:space="preserve">
          <source>It is possible for a class to implement a function type as if it were an interface. It must then supply an operator function called &lt;code&gt;invoke&lt;/code&gt; with the given signature, and instances of that class may then be assigned to a variable of that function type:</source>
          <target state="translated">클래스가 인터페이스 인 것처럼 함수 유형을 구현할 수 있습니다. 그런 다음 주어진 서명으로 &lt;code&gt;invoke&lt;/code&gt; 라는 연산자 함수를 제공해야하며 해당 클래스의 인스턴스를 해당 함수 유형의 변수에 지정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="05ec15ebc6d7af617a86a57248adcf19a55ca53f" translate="yes" xml:space="preserve">
          <source>It is possible to annotate type arguments of generic types to provide nullability information for them as well. For example, consider these annotations on a Java declaration:</source>
          <target state="translated">제네릭 형식의 형식 인수에 주석을 달아 nullable 정보도 제공 할 수 있습니다. 예를 들어, Java 선언에서 다음 주석을 고려하십시오.</target>
        </trans-unit>
        <trans-unit id="a4db969f6c44a5e65473207ba72459c76a3f1c8a" translate="yes" xml:space="preserve">
          <source>It is possible to configure the language settings of all source sets at once:</source>
          <target state="translated">모든 소스 세트의 언어 설정을 한 번에 구성 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8ee4c90445d9b9d795928bb3dfbba324ab54fe64" translate="yes" xml:space="preserve">
          <source>It is possible to create a scope-stable pointer of C representation of &lt;code&gt;CValues&amp;lt;T&amp;gt;&lt;/code&gt; instance using the &lt;code&gt;CValues&amp;lt;T&amp;gt;.ptr&lt;/code&gt; extension property, available under &lt;code&gt;memScoped { ... }&lt;/code&gt;. It allows using the APIs which require C pointers with a lifetime bound to a certain &lt;code&gt;MemScope&lt;/code&gt;. For example:</source>
          <target state="translated">&lt;code&gt;memScoped { ... }&lt;/code&gt; 에서 사용 가능한 &lt;code&gt;CValues&amp;lt;T&amp;gt;.ptr&lt;/code&gt; 확장 등록 정보를 사용하여 &lt;code&gt;CValues&amp;lt;T&amp;gt;&lt;/code&gt; 인스턴스 의 C 표현에 대한 범위 안정적인 포인터를 작성할 수 있습니다 . 수명이 특정 &lt;code&gt;MemScope&lt;/code&gt; 에 바인딩 된 C 포인터가 필요한 API를 사용할 수 있습니다 . 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="e9091ebea40cd5ed5eeeecc5f5fcdcb74a99a77f" translate="yes" xml:space="preserve">
          <source>It is possible to declare contracts for your own functions, but this feature is &lt;strong&gt;experimental,&lt;/strong&gt; as the current syntax is in a state of early prototype and will most probably be changed. Also, please note, that currently the Kotlin compiler does not verify contracts, so it's a programmer's responsibility to write correct and sound contracts.</source>
          <target state="translated">자신의 함수에 대한 계약을 선언하는 것이 가능하지만 현재 구문이 초기 프로토 타입 상태이며 변경 될 가능성 이 있으므로이 기능은 &lt;strong&gt;실험적&lt;/strong&gt; 입니다. 또한 현재 Kotlin 컴파일러는 계약을 확인하지 않으므로 정확하고 건전한 계약을 작성하는 것은 프로그래머의 책임입니다.</target>
        </trans-unit>
        <trans-unit id="dc3778d4014e6f71dce4d7d20c0e012498a2087a" translate="yes" xml:space="preserve">
          <source>It is possible to filter headers by globs. The &lt;code&gt;headerFilter&lt;/code&gt; property value from the &lt;code&gt;.def&lt;/code&gt; file is treated as a space-separated list of globs. If the included header matches any of the globs, then the declarations from this header are included into the bindings.</source>
          <target state="translated">글롭으로 헤더를 필터링 할 수 있습니다. &lt;code&gt;.def&lt;/code&gt; 파일 의 &lt;code&gt;headerFilter&lt;/code&gt; 속성 값은 공백으로 구분 된 glob 목록으로 처리됩니다. 포함 된 헤더가 glob와 일치하면이 헤더의 선언이 바인딩에 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="402a77d3239dcd76fb899799d8112b0ad86dfc4e" translate="yes" xml:space="preserve">
          <source>It is possible to have more than one target for a single platform in a multiplatform library. For example, these targets may provide the same API and differ in the libraries they cooperate with at runtime, like testing frameworks or logging solutions.</source>
          <target state="translated">다중 플랫폼 라이브러리에서 단일 플랫폼에 대해 둘 이상의 대상을 가질 수 있습니다. 예를 들어, 이러한 대상은 동일한 API를 제공 할 수 있으며 테스트 프레임 워크 또는 로깅 솔루션과 같이 런타임시 협력하는 라이브러리가 다를 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2e301a8ab019737ffb1879efcfc2dbdf711dcf6a" translate="yes" xml:space="preserve">
          <source>It is possible to specify which build types will be used to create binaries and which won't. In the following example only debug executable is created.</source>
          <target state="translated">바이너리를 생성하는 데 사용될 빌드 유형과 그렇지 않은 빌드 유형을 지정할 수 있습니다. 다음 예제에서는 디버그 실행 파일 만 작성됩니다.</target>
        </trans-unit>
        <trans-unit id="c4c1947233d08bc7cc11e65c450d05edf9570b44" translate="yes" xml:space="preserve">
          <source>It is quite a common situation to have a list of keys and want to build a map by associating each of these keys with some value. It was possible to do it before with the &lt;code&gt;associate { it to getValue(it) }&lt;/code&gt; function, but now we&amp;rsquo;re introducing a more efficient and easy to explore alternative: &lt;code&gt;keys.associateWith { getValue(it) }&lt;/code&gt;.</source>
          <target state="translated">키 목록을 갖고 이러한 키를 각각의 값과 연관시켜 맵을 작성하는 것은 매우 일반적인 상황입니다. &lt;code&gt;associate { it to getValue(it) }&lt;/code&gt; 함수 를 사용하여 이전에 수행 할 수 있었지만 이제보다 효율적이고 탐색하기 쉬운 대안을 제공합니다. &lt;code&gt;keys.associateWith { getValue(it) }&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="cb237bed1931cb077bff53fe7955788594878ed8" translate="yes" xml:space="preserve">
          <source>It is safe to treat a &lt;code&gt;Consumer&amp;lt;Fruit&amp;gt;&lt;/code&gt; as a &lt;code&gt;Consumer&amp;lt;Apple&amp;gt;&lt;/code&gt; - you are then restricted to only adding &lt;code&gt;Apple&lt;/code&gt; instances to it, but that's okay, because it is capable of receiving any &lt;code&gt;Fruit&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Consumer&amp;lt;Fruit&amp;gt;&lt;/code&gt; 를 &lt;code&gt;Consumer&amp;lt;Apple&amp;gt;&lt;/code&gt; 으로 취급하는 것이 안전합니다. 그러면 &lt;code&gt;Apple&lt;/code&gt; 인스턴스 만 추가 할 수 있지만 &lt;code&gt;Fruit&lt;/code&gt; 을받을 수 있기 때문에 괜찮습니다 .</target>
        </trans-unit>
        <trans-unit id="dc95825b1857af449f9e7a03e1be3bb43d0ddb3a" translate="yes" xml:space="preserve">
          <source>It is safe to treat a &lt;code&gt;Producer&amp;lt;Apple&amp;gt;&lt;/code&gt; as if it were a &lt;code&gt;Producer&amp;lt;Fruit&amp;gt;&lt;/code&gt; - the only thing it will ever produce is &lt;code&gt;Apple&lt;/code&gt; instances, but that's okay, because an &lt;code&gt;Apple&lt;/code&gt; is a &lt;code&gt;Fruit&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Producer&amp;lt;Apple&amp;gt;&lt;/code&gt; 을 &lt;code&gt;Producer&amp;lt;Fruit&amp;gt;&lt;/code&gt; &amp;gt; 인 것처럼 취급하는 것이 안전합니다. &lt;code&gt;Apple&lt;/code&gt; 인스턴스 는 Apple 인스턴스 뿐이지 만 &lt;code&gt;Apple&lt;/code&gt; 은 &lt;code&gt;Fruit&lt;/code&gt; 이기 때문에 괜찮습니다 .</target>
        </trans-unit>
        <trans-unit id="1cb7a9be64c1b10976e2826c53f2565e3ab27c33" translate="yes" xml:space="preserve">
          <source>It is the same as the hashCode of &lt;a href=&quot;../-map/entries#kotlin.collections.Map%24entries&quot;&gt;entries&lt;/a&gt; set.</source>
          <target state="translated">&lt;a href=&quot;../-map/entries#kotlin.collections.Map%24entries&quot;&gt;항목&lt;/a&gt; 세트 의 hashCode와 동일 합니다 .</target>
        </trans-unit>
        <trans-unit id="638b2a44297b2347a2a9b3d378c007753c4381ba" translate="yes" xml:space="preserve">
          <source>It is the time to try using C Functions from our Kotlin program. Let's call the &lt;code&gt;accept_fun&lt;/code&gt; function and pass the C function pointer to a Kotlin lambda:</source>
          <target state="translated">Kotlin 프로그램에서 C 함수를 사용해보십시오. &lt;code&gt;accept_fun&lt;/code&gt; 함수를 호출하고 C 함수 포인터를 Kotlin 람다에 전달합니다 :</target>
        </trans-unit>
        <trans-unit id="d8fa5339a1950bfcc4e526f49360c54a4a63bc2d" translate="yes" xml:space="preserve">
          <source>It is very convenient to declare a type parameter T as &lt;em&gt;out&lt;/em&gt; and avoid trouble with subtyping on the use site, but some classes &lt;strong&gt;can't&lt;/strong&gt; actually be restricted to only return &lt;code&gt;T&lt;/code&gt;'s! A good example of this is Array:</source>
          <target state="translated">으로 T 매개 변수 유형을 선언하는 것이 매우 편리 &lt;em&gt;밖으로&lt;/em&gt; 사용하는 사이트에 하위 유형와 회피 문제가 있지만, 일부 클래스는 &lt;strong&gt;할 수없는&lt;/strong&gt; 사실만을 반환에 제한 &lt;code&gt;T&lt;/code&gt; 의를! 이에 대한 좋은 예는 Array입니다.</target>
        </trans-unit>
        <trans-unit id="b163cb494d8f7133d17c75969b6f58ad44cf2144" translate="yes" xml:space="preserve">
          <source>It launches 100K coroutines and, after a second, each coroutine prints a dot. Now, try that with threads. What would happen? (Most likely your code will produce some sort of out-of-memory error)</source>
          <target state="translated">100K 코 루틴을 시작하고 1 초 후에 각 코 루틴이 점을 인쇄합니다. 이제 스레드로 시도하십시오. 무슨 일이 일어날 지? (아마도 코드에서 일종의 메모리 부족 오류가 발생할 수 있습니다)</target>
        </trans-unit>
        <trans-unit id="efa9aff9b6f6c29df2d20508228006677fa18621" translate="yes" xml:space="preserve">
          <source>It leads to the following signature seen in Kotlin:</source>
          <target state="translated">코 틀린에서 볼 수있는 다음과 같은 서명으로 이어진다</target>
        </trans-unit>
        <trans-unit id="50a8da20f5180842f95e2e885ec1433b6eb6b732" translate="yes" xml:space="preserve">
          <source>It may be helpful only if declaration seems to be inconvenient to use from Java without wildcard.</source>
          <target state="translated">선언이 와일드 카드없이 Java에서 사용하기 불편한 경우에만 도움이 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8ead6eaf5a09cdd5203f3d7332c148b0e2afab55" translate="yes" xml:space="preserve">
          <source>It may be helpful only if declaration seems to be inconvenient to use from Java.</source>
          <target state="translated">선언이 Java에서 사용하기 불편한 경우에만 도움이 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="92fc36943474eb17749f18ce6facbefadc2bd75a" translate="yes" xml:space="preserve">
          <source>It may seem a logical next step to remove this obscurity by switching the defaults in IntelliJ IDEA and make formatting consistent with the Kotlin Coding Conventions. But this would mean that all the existing Kotlin projects will have a new code style enabled the moment the Kotlin plugin is installed. Not really the expected result for plugin update, right?</source>
          <target state="translated">IntelliJ IDEA에서 기본값을 전환하고 Kotlin Coding Conventions와 일치하는 형식을 지정하여 이러한 모호성을 제거하는 것이 논리적으로 다음 단계로 보일 수 있습니다. 그러나 이것은 기존의 모든 Kotlin 프로젝트가 Kotlin 플러그인이 설치되는 순간 새로운 코드 스타일을 사용할 수 있음을 의미합니다. 플러그인 업데이트에 대한 예상 결과가 맞지 않습니까?</target>
        </trans-unit>
        <trans-unit id="5a4d0a01a307589d4ada06d8aac41c245c2a1232" translate="yes" xml:space="preserve">
          <source>It means that, by the time of the base class constructor execution, the properties declared or overridden in the derived class are not yet initialized. If any of those properties are used in the base class initialization logic (either directly or indirectly, through another overridden &lt;em&gt;open&lt;/em&gt; member implementation), it may lead to incorrect behavior or a runtime failure. When designing a base class, you should therefore avoid using &lt;em&gt;open&lt;/em&gt; members in the constructors, property initializers, and &lt;em&gt;init&lt;/em&gt; blocks.</source>
          <target state="translated">이는 기본 클래스 생성자 실행시 파생 클래스에서 선언되거나 재정의 된 속성이 아직 초기화되지 않았 음을 의미합니다. 이러한 속성 중 하나라도 기본 클래스 초기화 로직에서 사용되는 경우 (직접적으로 또는 다른 재정의 된 &lt;em&gt;오픈&lt;/em&gt; 멤버 구현을 통해 간접적으로 ) 잘못된 동작 또는 런타임 오류가 발생할 수 있습니다. 따라서 기본 클래스를 디자인 할 때는 생성자, 속성 이니셜 라이저 및 &lt;em&gt;init&lt;/em&gt; 블록 에서 &lt;em&gt;열린&lt;/em&gt; 멤버를 사용하지 않아야합니다 .&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="797f38dacaae5d59a26c62d2dd822a0488289854" translate="yes" xml:space="preserve">
          <source>It might be temping to use JVM's &lt;code&gt;java.util.Scanner&lt;/code&gt; class to parse less structured input formats. Kotlin is designed to interoperate well with JVM libraries, so that their use feels quite natural in Kotlin. However, beware that &lt;code&gt;java.util.Scanner&lt;/code&gt; is extremely slow. So slow, in fact, that parsing 10&lt;sup&gt;5&lt;/sup&gt; or more integers with it might not fit into a typical 2 second time-limit, which a simple Kotlin's &lt;code&gt;split(&quot; &quot;).map { it.toInt() }&lt;/code&gt; would handle.</source>
          <target state="translated">덜 구조화 된 입력 형식을 구문 분석 하기 위해 JVM의 &lt;code&gt;java.util.Scanner&lt;/code&gt; 클래스 를 사용하는 것이 좋습니다 . Kotlin은 JVM 라이브러리와 잘 호환되도록 설계되어 Kotlin에서 사용이 매우 자연 스럽습니다. 그러나 &lt;code&gt;java.util.Scanner&lt;/code&gt; 가 매우 느리다는 점에 유의하십시오 . 실제로 10 &lt;sup&gt;5&lt;/sup&gt; 개 이상의 정수 를 구문 분석 하는 것은 일반적인 Kotlin의 &lt;code&gt;split(&quot; &quot;).map { it.toInt() }&lt;/code&gt; 가 처리 하는 일반적인 2 초 시간 제한에 맞지 않을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4dcefeb4f7398e3e9107786806cb210122661b33" translate="yes" xml:space="preserve">
          <source>It prints &quot;sending&quot; &lt;em&gt;five&lt;/em&gt; times using a buffered channel with capacity of &lt;em&gt;four&lt;/em&gt;:</source>
          <target state="translated">용량이 &lt;em&gt;4 인&lt;/em&gt; 버퍼링 된 채널을 사용하여 &quot;송신&quot;을 &lt;em&gt;5&lt;/em&gt; 번 인쇄합니다 .&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="22cac1fe7a5de098526c35e5a30637b070cd91b6" translate="yes" xml:space="preserve">
          <source>It prints following lines:</source>
          <target state="translated">다음 줄을 인쇄합니다.</target>
        </trans-unit>
        <trans-unit id="c7f4b533e837bd7e46a9ce1a0a22fbfcd4d17d31" translate="yes" xml:space="preserve">
          <source>It produces something like that when running in &lt;a href=&quot;#debugging-coroutines-and-threads&quot;&gt;debug mode&lt;/a&gt;:</source>
          <target state="translated">&lt;a href=&quot;#debugging-coroutines-and-threads&quot;&gt;디버그 모드&lt;/a&gt; 에서 실행할 때와 같은 것을 생성 합니다 .</target>
        </trans-unit>
        <trans-unit id="438255e8d8df7e6af7b2286b9eb0a1ff8f4ea247" translate="yes" xml:space="preserve">
          <source>It produces something like this:</source>
          <target state="translated">다음과 같이 생성됩니다.</target>
        </trans-unit>
        <trans-unit id="fb781104064af1d8629d3a388a507c72839c91db" translate="yes" xml:space="preserve">
          <source>It produces the following output (maybe in different order):</source>
          <target state="translated">다음과 같은 출력을 생성합니다 (아마 다른 순서로).</target>
        </trans-unit>
        <trans-unit id="c9f7c3047939db3a0d1c9e3a0026fbe61df824db" translate="yes" xml:space="preserve">
          <source>It produces the following output:</source>
          <target state="translated">다음과 같은 출력을 생성합니다.</target>
        </trans-unit>
        <trans-unit id="17589c30d4bd3d4e252acd3e2fde1d3c719a5224" translate="yes" xml:space="preserve">
          <source>It returns a composition of two functions passed to it: &lt;code&gt;compose(f, g) = f(g(*))&lt;/code&gt;. Now, you can apply it to callable references:</source>
          <target state="translated">전달 된 두 함수의 구성을 리턴합니다. &lt;code&gt;compose(f, g) = f(g(*))&lt;/code&gt; . 이제 호출 가능한 참조에 적용 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="adaa459203490bc09b0dd6700bcf5aacd3687f3b" translate="yes" xml:space="preserve">
          <source>It takes two &lt;code&gt;Int&lt;/code&gt; parameters and returns a &lt;code&gt;Double&lt;/code&gt;, so its type is &lt;code&gt;(Int, Int) -&amp;gt; Double&lt;/code&gt;. We can reference the function itself by prefixing its name with &lt;code&gt;::&lt;/code&gt;, and we can assign it to a variable (whose type would normally be inferred, but we show the type signature for demonstration):</source>
          <target state="translated">두 개의 &lt;code&gt;Int&lt;/code&gt; 매개 변수를 사용하고 &lt;code&gt;Double&lt;/code&gt; 을 반환 하므로 유형은 &lt;code&gt;(Int, Int) -&amp;gt; Double&lt;/code&gt; 입니다. 이름 앞에 &lt;code&gt;::&lt;/code&gt; 접두사를 붙여 함수 자체를 참조 할 수 있으며 변수에 변수를 할당 할 수 있습니다 (유형은 일반적으로 유추되지만 데모를 위해 형식 서명을 표시 함).</target>
        </trans-unit>
        <trans-unit id="c85187abd273afe2d39456db809770ff8d17b7cc" translate="yes" xml:space="preserve">
          <source>It will produce a platform-specific shared object (.so on Linux, .dylib on macOS, and .dll on Windows targets) and a C language header, allowing the use of all public APIs available in your Kotlin/Native program from C/C++ code. See &lt;code&gt;samples/python_extension&lt;/code&gt; for an example of using such a shared object to provide a bridge between Python and Kotlin/Native.</source>
          <target state="translated">플랫폼 별 공유 객체 (Linux에서는 .so, macOS에서는 .dylib, Windows에서는 .dll)와 C 언어 헤더를 생성하여 C /에서 Kotlin / Native 프로그램에서 사용할 수있는 모든 공용 API를 사용할 수 있습니다. C ++ 코드. 이러한 공유 객체를 사용하여 Python과 Kotlin / Native 간의 브리지를 제공하는 예제는 &lt;code&gt;samples/python_extension&lt;/code&gt; 을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="9b575c19d946e336100c7ed068ca562177833082" translate="yes" xml:space="preserve">
          <source>It will produce a platform-specific static object (.a library format) and a C language header, allowing you to use all the public APIs available in your Kotlin/Native program from C/C++ code.</source>
          <target state="translated">플랫폼 별 정적 객체 (. 라이브러리 형식)와 C 언어 헤더를 생성하여 C / C ++ 코드에서 Kotlin / Native 프로그램에서 사용할 수있는 모든 공용 API를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7d20f5ce9372886e3a18510e89bf62db3fa25cfc" translate="yes" xml:space="preserve">
          <source>It&amp;rsquo;s extremely easy to start using Kotlin for Android development. In this tutorial we&amp;rsquo;ll follow the warming up process with Android Studio. If you're using Intellij IDEA with Android, the process is almost the same.</source>
          <target state="translated">안드로이드 개발을 위해 Kotlin을 사용하는 것은 매우 쉽습니다. 이 튜토리얼에서는 Android Studio의 워밍업 프로세스를 따릅니다. Android에서 Intellij IDEA를 사용하는 경우 프로세스는 거의 동일합니다.</target>
        </trans-unit>
        <trans-unit id="0d25598a290d255bee23e0efee2aa27e246b4f17" translate="yes" xml:space="preserve">
          <source>It's allowed to pass the same array in the &lt;a href=&quot;copy-into#kotlin.collections%24copyInto%28kotlin.Array%28%28kotlin.collections.copyInto.T%29%29%2C+kotlin.Array%28%28kotlin.collections.copyInto.T%29%29%2C+kotlin.Int%2C+kotlin.Int%2C+kotlin.Int%29%2Fdestination&quot;&gt;destination&lt;/a&gt; and even specify the subrange so that it overlaps with the destination range.</source>
          <target state="translated">&lt;a href=&quot;copy-into#kotlin.collections%24copyInto%28kotlin.Array%28%28kotlin.collections.copyInto.T%29%29%2C+kotlin.Array%28%28kotlin.collections.copyInto.T%29%29%2C+kotlin.Int%2C+kotlin.Int%2C+kotlin.Int%29%2Fdestination&quot;&gt;대상&lt;/a&gt; 에서 동일한 배열을 전달 하고 대상 범위와 겹치도록 하위 범위를 지정할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="ccc637fca146e7aa9091977f4ab6a14a8ec874b0" translate="yes" xml:space="preserve">
          <source>It's allowed to pass the same array in the &lt;a href=&quot;copy-into#kotlin.collections%24copyInto%28kotlin.UIntArray%2C+kotlin.UIntArray%2C+kotlin.Int%2C+kotlin.Int%2C+kotlin.Int%29%2Fdestination&quot;&gt;destination&lt;/a&gt; and even specify the subrange so that it overlaps with the destination range.</source>
          <target state="translated">&lt;a href=&quot;copy-into#kotlin.collections%24copyInto%28kotlin.UIntArray%2C+kotlin.UIntArray%2C+kotlin.Int%2C+kotlin.Int%2C+kotlin.Int%29%2Fdestination&quot;&gt;대상&lt;/a&gt; 에서 동일한 배열을 전달 하고 대상 범위와 겹치도록 하위 범위를 지정할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="031250b72b284d8b276f90bf0d49fd6078c2857d" translate="yes" xml:space="preserve">
          <source>It's always possible to explicitly set the IntelliJ IDEA code style as the correct code style for the project. To do so please switch to the &lt;em&gt;Project&lt;/em&gt; scheme in &lt;code&gt;Settings &amp;rarr; Editor &amp;rarr; Code Style &amp;rarr; Kotlin&lt;/code&gt; and select &lt;em&gt;&quot;Kotlin obsolete IntelliJ IDEA codestyle&quot;&lt;/em&gt; in the &lt;em&gt;&quot;Use defaults from:&quot;&lt;/em&gt; on the &lt;em&gt;Load&lt;/em&gt; tab.</source>
          <target state="translated">IntelliJ IDEA 코드 스타일을 프로젝트의 올바른 코드 스타일로 명시 적으로 설정할 수 있습니다. 받는 사람 그렇게하십시오 스위치를 수행 &lt;em&gt;프로젝트&lt;/em&gt; 의 계획 &lt;code&gt;Settings &amp;rarr; Editor &amp;rarr; Code Style &amp;rarr; Kotlin&lt;/code&gt; 선택 &lt;em&gt;&quot;코 틀린 쓸모하게 IntelliJ IDEA의 codestyle을&quot;&lt;/em&gt; 에 &lt;em&gt;&quot;에서 기본값 사용 :&quot;&lt;/em&gt; 온 &lt;em&gt;로드&lt;/em&gt; 탭을 선택합니다.</target>
        </trans-unit>
        <trans-unit id="6e80a1e74b8c8e47694ccc45eb2685d70fcb822d" translate="yes" xml:space="preserve">
          <source>It's currently not possible to pass &lt;em&gt;null&lt;/em&gt; to a method that is declared as varargs.</source>
          <target state="translated">현재 varargs로 선언 된 메서드에는 &lt;em&gt;null&lt;/em&gt; 을 전달할 수 없습니다 .</target>
        </trans-unit>
        <trans-unit id="acfee84980c04ef0fe85e54f28d399f66e64abaa" translate="yes" xml:space="preserve">
          <source>It's fine to inherit from both &lt;code&gt;A&lt;/code&gt; and &lt;code&gt;B&lt;/code&gt;, and we have no problems with &lt;code&gt;a()&lt;/code&gt; and &lt;code&gt;b()&lt;/code&gt; since &lt;code&gt;C&lt;/code&gt; inherits only one implementation of each of these functions. But for &lt;code&gt;f()&lt;/code&gt; we have two implementations inherited by &lt;code&gt;C&lt;/code&gt;, and thus we have to override &lt;code&gt;f()&lt;/code&gt; in &lt;code&gt;C&lt;/code&gt; and provide our own implementation that eliminates the ambiguity.</source>
          <target state="translated">그것의 모두 상속 미세 와 &lt;code&gt;B&lt;/code&gt; , 그리고 우리는 아무런 문제가 없다 &lt;code&gt;a()&lt;/code&gt; 와 &lt;code&gt;b()&lt;/code&gt; 이후 &lt;code&gt;C&lt;/code&gt; 의 상속이 각각의 기능의 하나의 구현. 그러나 대한 &lt;code&gt;f()&lt;/code&gt; 우리는 상속이 구현이 &lt;code&gt;C&lt;/code&gt; 를 , 따라서 우리는 오버라이드 (override) 할 필요가 &lt;code&gt;f()&lt;/code&gt; 에 &lt;code&gt;C&lt;/code&gt; 와 우리 자신의 구현을 제거해 그 모호성을 제공합니다. &lt;code&gt;A&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="442e1f9409803560cb8db1e8e932691b852b50ed" translate="yes" xml:space="preserve">
          <source>It's important to close a stream when you're done with it; otherwise, your program will leak a file handle. See the next section for how do do this nicely.</source>
          <target state="translated">작업이 끝나면 스트림을 닫는 것이 중요합니다. 그렇지 않으면 프로그램이 파일 핸들을 누출시킵니다. 이 작업을 잘 수행하는 방법은 다음 섹션을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="9346c60b395e4bb0937fa0abc8c38e87d658e069" translate="yes" xml:space="preserve">
          <source>It's important to make sure that the &lt;em&gt;Include Kotlin support&lt;/em&gt; checkbox is ticked. For now we can leave the default settings in the next step of the wizard. We then proceed to select the &lt;em&gt;Empty Activity&lt;/em&gt; option and click &lt;em&gt;Next&lt;/em&gt;, finally pressing &lt;em&gt;Finish&lt;/em&gt;.</source>
          <target state="translated">&lt;em&gt;Kotlin 지원 포함&lt;/em&gt; 확인란이 선택되어 있는지 확인해야합니다 . 지금은 마법사의 다음 단계에서 기본 설정을 그대로 둘 수 있습니다. 그런 다음 &lt;em&gt;Empty Activity&lt;/em&gt; 옵션 을 선택하고 &lt;em&gt;Next를&lt;/em&gt; 클릭 하고 마지막으로 &lt;em&gt;Finish를&lt;/em&gt; 누릅니다 .</target>
        </trans-unit>
        <trans-unit id="3f80b2897a86bf69ce94fa9c91efda88ddaabb97" translate="yes" xml:space="preserve">
          <source>It's important to understand that this is now a native application, and no runtime or virtual machine is required. We can now run the compiled binary from the console:</source>
          <target state="translated">이것이 이제는 기본 애플리케이션이며 런타임 또는 가상 머신이 필요하지 않음을 이해해야합니다. 이제 콘솔에서 컴파일 된 바이너리를 실행할 수 있습니다 :</target>
        </trans-unit>
        <trans-unit id="451aaccdf6c2eb6d6c44303ffdea63bce2a3d7a2" translate="yes" xml:space="preserve">
          <source>It's not recommended to apply Kotlin plugins with &lt;code&gt;apply&lt;/code&gt; in Gradle Kotlin DSL. The details are provided &lt;a href=&quot;#using-gradle-kotlin-dsl&quot;&gt;below&lt;/a&gt;.</source>
          <target state="translated">과 코 틀린 플러그인을 적용하지 않는 것이 좋습니다 &lt;code&gt;apply&lt;/code&gt; Gradle을 코 틀린 DSL에. 자세한 내용은 &lt;a href=&quot;#using-gradle-kotlin-dsl&quot;&gt;아래&lt;/a&gt; 에 제공 됩니다 .</target>
        </trans-unit>
        <trans-unit id="903ee30ab34cc6304b069dd5e5dba6a6e65093d1" translate="yes" xml:space="preserve">
          <source>It's often the case that we need to copy an object altering &lt;em&gt;some&lt;/em&gt; of its properties, but keeping the rest unchanged. This is what &lt;code&gt;copy()&lt;/code&gt; function is generated for. For the &lt;code&gt;User&lt;/code&gt; class above, its implementation would be as follows:</source>
          <target state="translated">&lt;em&gt;일부&lt;/em&gt; 속성을 변경 하지만 나머지는 변경하지 않고 객체를 복사해야하는 경우가 종종 있습니다. 이것이 &lt;code&gt;copy()&lt;/code&gt; 함수가 생성되는 것입니다. 위 의 &lt;code&gt;User&lt;/code&gt; 클래스의 경우 구현은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="f5bc060842af3a7b6e0d01c24d0becf2bb7a201f" translate="yes" xml:space="preserve">
          <source>It's possible to declare a cinterop dependency for a component:</source>
          <target state="translated">구성 요소에 대한 cinterop 종속성을 선언 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2884706f64f3c6fe7682c1d6d6493a0cd7c7c71d" translate="yes" xml:space="preserve">
          <source>It's possible to depend on a Kotlin/Native library published earlier in a maven repo. The plugin relies on Gradle's &lt;a href=&quot;https://github.com/gradle/gradle/blob/master/subprojects/docs/src/docs/design/gradle-module-metadata-specification.md&quot;&gt;metadata&lt;/a&gt; support so the corresponding feature must be enabled. Add the following line in your &lt;code&gt;settings.gradle&lt;/code&gt;:</source>
          <target state="translated">이전에 maven 저장소에 게시 된 Kotlin / Native 라이브러리에 의존 할 수 있습니다. 플러그인은 Gradle의 &lt;a href=&quot;https://github.com/gradle/gradle/blob/master/subprojects/docs/src/docs/design/gradle-module-metadata-specification.md&quot;&gt;메타 데이터&lt;/a&gt; 지원 에 의존 하므로 해당 기능을 활성화해야합니다. &lt;code&gt;settings.gradle&lt;/code&gt; 에 다음 줄을 추가하십시오 .</target>
        </trans-unit>
        <trans-unit id="268bb3f4ba30e1a5b60f8f81ac29d4c03ccdf710" translate="yes" xml:space="preserve">
          <source>It's recommended to propagate the experimental status to the API that depends on unsigned types by annotating it with this annotation.</source>
          <target state="translated">이 주석으로 주석을 달아서 서명되지 않은 유형에 의존하는 API에 실험 상태를 전파하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="d7daa3cad985a04d515f5a0b14e8155b1a6fab3e" translate="yes" xml:space="preserve">
          <source>It's up to you to decide if your clients have to explicitly opt-in into usage of your API, but bear in mind that unsigned types are an experimental feature, so API which uses them can be suddenly broken due to changes in language.</source>
          <target state="translated">클라이언트가 API 사용을 명시 적으로 선택해야하는지 여부를 결정해야하지만 서명되지 않은 유형은 실험적인 기능이므로 언어 ​​변경으로 인해이를 사용하는 API가 갑자기 중단 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9fa67b0c21d7b8170095650619f367328af7593f" translate="yes" xml:space="preserve">
          <source>It's useful to shorten long generic types. For instance, it's often tempting to shrink collection types:</source>
          <target state="translated">긴 제네릭 형식을 줄이는 것이 좋습니다. 예를 들어 컬렉션 유형을 축소하려는 경향이 있습니다.</target>
        </trans-unit>
        <trans-unit id="d50dbfd39b435235eb76a4c86249fda694136067" translate="yes" xml:space="preserve">
          <source>It's very common that a lambda expression has only one parameter.</source>
          <target state="translated">람다 식에 매개 변수가 하나만있는 것이 일반적입니다.</target>
        </trans-unit>
        <trans-unit id="497cb9444d2d1993508a971a9e38bf60f29788e9" translate="yes" xml:space="preserve">
          <source>ItemArrayLike</source>
          <target state="translated">ItemArrayLike</target>
        </trans-unit>
        <trans-unit id="08ca6a3da933ca6826a2f4d3fcc919af71d7e380" translate="yes" xml:space="preserve">
          <source>Iterable</source>
          <target state="translated">Iterable</target>
        </trans-unit>
        <trans-unit id="dc8802d44941c46da0da729594bb50e6d441ce2d" translate="yes" xml:space="preserve">
          <source>Iterable.groupingBy</source>
          <target state="translated">Iterable.groupingBy</target>
        </trans-unit>
        <trans-unit id="380a211ab0a9e218f328f8421df21a0f64a31d3e" translate="yes" xml:space="preserve">
          <source>Iterates through each line of this reader, calls &lt;a href=&quot;for-each-line#kotlin.io%24forEachLine%28java.io.Reader%2C+kotlin.Function1%28%28kotlin.String%2C+kotlin.Unit%29%29%29%2Faction&quot;&gt;action&lt;/a&gt; for each line read and closes the &lt;a href=&quot;http://docs.oracle.com/javase/8/docs/api/java/io/Reader.html&quot;&gt;Reader&lt;/a&gt; when it's completed.</source>
          <target state="translated">이 판독기의 각 라인을 반복하고, 읽은 각 라인에 대해 &lt;a href=&quot;for-each-line#kotlin.io%24forEachLine%28java.io.Reader%2C+kotlin.Function1%28%28kotlin.String%2C+kotlin.Unit%29%29%29%2Faction&quot;&gt;조치&lt;/a&gt; 를 호출 하고 완료되면 &lt;a href=&quot;http://docs.oracle.com/javase/8/docs/api/java/io/Reader.html&quot;&gt;판독기를&lt;/a&gt; 닫습니다 .</target>
        </trans-unit>
        <trans-unit id="df79ba3f92580a38aac3b295d97ec6467bf9c601" translate="yes" xml:space="preserve">
          <source>Iterating over a collection:</source>
          <target state="translated">컬렉션을 반복 :</target>
        </trans-unit>
        <trans-unit id="cd542426f011094d421bd238597459f01a78a773" translate="yes" xml:space="preserve">
          <source>Iterating over a range:</source>
          <target state="translated">범위에서 반복 :</target>
        </trans-unit>
        <trans-unit id="bae8809b2429231a50c28ba87cecc038aac88855" translate="yes" xml:space="preserve">
          <source>Iterator</source>
          <target state="translated">Iterator</target>
        </trans-unit>
        <trans-unit id="003d5d89ff75536e7c8fe75998f6c431dc6a6bfb" translate="yes" xml:space="preserve">
          <source>Iterator for characters of the given char sequence.</source>
          <target state="translated">주어진 문자 순서의 문자에 대한 반복자입니다.</target>
        </trans-unit>
        <trans-unit id="909a5f0dfd8c3a4ef79cd1458e2b5fb136ad7fae" translate="yes" xml:space="preserve">
          <source>Iterators</source>
          <target state="translated">Iterators</target>
        </trans-unit>
        <trans-unit id="506c9ecd5cb52c951984866e4ca884bba6f6ea5f" translate="yes" xml:space="preserve">
          <source>Iterators can be obtained for inheritors of the &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/-iterable/index&quot;&gt;&lt;code&gt;Iterable&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/a&gt; interface, including &lt;code&gt;Set&lt;/code&gt; and &lt;code&gt;List&lt;/code&gt;, by calling the &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/-iterable/iterator&quot;&gt;&lt;code&gt;iterator()&lt;/code&gt;&lt;/a&gt; function. Once you obtain an iterator, it points to the first element of a collection; calling the &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/-iterator/next&quot;&gt;&lt;code&gt;next()&lt;/code&gt;&lt;/a&gt; function returns this element and moves the iterator position to the following element if it exists. Once the iterator passes through the last element, it can no longer be used for retrieving elements; neither can it be reset to any previous position. To iterate through the collection again, create a new iterator.</source>
          <target state="translated">Iterator &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/-iterable/iterator&quot;&gt; &lt;code&gt;iterator()&lt;/code&gt; &lt;/a&gt; 함수를 호출 하여 &lt;code&gt;Set&lt;/code&gt; 및 &lt;code&gt;List&lt;/code&gt; 를 포함한 &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/-iterable/index&quot;&gt; &lt;code&gt;Iterable&amp;lt;T&amp;gt;&lt;/code&gt; &lt;/a&gt; 인터페이스 의 상속자에 대해 반복자를 얻을 수 있습니다 . 반복자를 얻은 후에는 컬렉션의 첫 번째 요소를 가리 킵니다. &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/-iterator/next&quot;&gt; &lt;code&gt;next()&lt;/code&gt; &lt;/a&gt; 함수를 호출하면 이 요소가 반환되고 이터레이터 위치가 있으면 다음 요소로 이동합니다. 반복자가 마지막 요소를 통과하면 더 이상 요소를 검색하는 데 사용할 수 없습니다. 이전 위치로 재설정 할 수도 없습니다. 콜렉션을 다시 반복하려면 새 반복자를 작성하십시오.</target>
        </trans-unit>
        <trans-unit id="bc0b40497b63bea004394bd2f67e443f08b6588f" translate="yes" xml:space="preserve">
          <source>JAR file for the Android project, from the &lt;code&gt;androidMain&lt;/code&gt; source set</source>
          <target state="translated">&lt;code&gt;androidMain&lt;/code&gt; 소스 세트 의 Android 프로젝트에 대한 JAR 파일</target>
        </trans-unit>
        <trans-unit id="1c094e3ab7a1c494d642222b6728398ff3000b42" translate="yes" xml:space="preserve">
          <source>JPA support</source>
          <target state="translated">JPA 지원</target>
        </trans-unit>
        <trans-unit id="95f92b2f0cb530542d16d90a6c2af59e20759430" translate="yes" xml:space="preserve">
          <source>JS</source>
          <target state="translated">JS</target>
        </trans-unit>
        <trans-unit id="2ef44ba04cb41365765eba178e5fb528ee006a1b" translate="yes" xml:space="preserve">
          <source>JS:</source>
          <target state="translated">JS:</target>
        </trans-unit>
        <trans-unit id="031a4e76f0b39d0df073d934da5fc48da8d737e5" translate="yes" xml:space="preserve">
          <source>JSON</source>
          <target state="translated">JSON</target>
        </trans-unit>
        <trans-unit id="8262ef9c2c68924dbec9b88761bde41ad5ef98f3" translate="yes" xml:space="preserve">
          <source>JSR-305 (&lt;code&gt;javax.annotation&lt;/code&gt;, more details below)</source>
          <target state="translated">JSR-305 ( &lt;code&gt;javax.annotation&lt;/code&gt; , 자세한 내용은 아래 참조)</target>
        </trans-unit>
        <trans-unit id="5188151af5277b4d83b75fa70a7e55c37a18f211" translate="yes" xml:space="preserve">
          <source>JSR-305 Support</source>
          <target state="translated">JSR-305 지원</target>
        </trans-unit>
        <trans-unit id="bb63c86538bf1c2ee7cd6190cf88dd1f44d85eff" translate="yes" xml:space="preserve">
          <source>JVM</source>
          <target state="translated">JVM</target>
        </trans-unit>
        <trans-unit id="04a7d3f3683303c17ad132f382f6d0c911d30883" translate="yes" xml:space="preserve">
          <source>JVM 6</source>
          <target state="translated">JVM 6</target>
        </trans-unit>
        <trans-unit id="3430f69443094c1010f905be31e657db1bc9cecc" translate="yes" xml:space="preserve">
          <source>JVM Backend</source>
          <target state="translated">JVM 백엔드</target>
        </trans-unit>
        <trans-unit id="8a60d58cc6c328ec0b68627b45e8de68d5004fb4" translate="yes" xml:space="preserve">
          <source>JVM backend</source>
          <target state="translated">JVM 백엔드</target>
        </trans-unit>
        <trans-unit id="1e479037f37f3056da4dd3f4b8476891324342ba" translate="yes" xml:space="preserve">
          <source>JVM:</source>
          <target state="translated">JVM:</target>
        </trans-unit>
        <trans-unit id="4aa2729d3292a207da300462e1c7fb9e07fee8d1" translate="yes" xml:space="preserve">
          <source>Jar file</source>
          <target state="translated">항아리 파일</target>
        </trans-unit>
        <trans-unit id="c32dbe67bb4cda6c969b9b214ff6e46a25b2a0f2" translate="yes" xml:space="preserve">
          <source>Java 7's try with resources</source>
          <target state="translated">Java 7의 리소스를 사용해보십시오</target>
        </trans-unit>
        <trans-unit id="ac187b2b88eb97c8a6d1b499783f3187c6ec8c0b" translate="yes" xml:space="preserve">
          <source>Java 8 bytecode support</source>
          <target state="translated">Java 8 바이트 코드 지원</target>
        </trans-unit>
        <trans-unit id="072e6f9a3196506ae761b516738d856e34828cc7" translate="yes" xml:space="preserve">
          <source>Java 8 standard library support</source>
          <target state="translated">Java 8 표준 라이브러리 지원</target>
        </trans-unit>
        <trans-unit id="01579d0353cd60180076cc09ff0d55781e923e55" translate="yes" xml:space="preserve">
          <source>Java Annotations</source>
          <target state="translated">자바 주석</target>
        </trans-unit>
        <trans-unit id="d04e5ac8f8fe9912f7302d2d4689867b318a2094" translate="yes" xml:space="preserve">
          <source>Java Arrays</source>
          <target state="translated">자바 배열</target>
        </trans-unit>
        <trans-unit id="860970d26c3938762fa2e2c7b7194b61a0231169" translate="yes" xml:space="preserve">
          <source>Java EE Http servlets can be used from Kotlin much like any other Java library or framework. We'll see how to make a simple controller that returns &quot;Hello, World!&quot;.</source>
          <target state="translated">Java EE Http 서블릿은 다른 Java 라이브러리 또는 프레임 워크와 마찬가지로 Kotlin에서 사용할 수 있습니다. &quot;Hello, World!&quot;를 반환하는 간단한 컨트롤러를 만드는 방법을 살펴 보겠습니다.</target>
        </trans-unit>
        <trans-unit id="98c55e3f9693daef863846ba04beb7a87639d58b" translate="yes" xml:space="preserve">
          <source>Java Interoperability</source>
          <target state="translated">자바 상호 운용성</target>
        </trans-unit>
        <trans-unit id="ab55871eec7aba9e50581782c94506d7b076be92" translate="yes" xml:space="preserve">
          <source>Java Reflection</source>
          <target state="translated">자바 리플렉션</target>
        </trans-unit>
        <trans-unit id="8b7c04d9bb7da5a0513e73469be371a892a0ddec" translate="yes" xml:space="preserve">
          <source>Java Support in JVM Targets</source>
          <target state="translated">JVM 대상에서 Java 지원</target>
        </trans-unit>
        <trans-unit id="027f8a4631110b77b693f662b6d14564e95f3ad5" translate="yes" xml:space="preserve">
          <source>Java Varargs</source>
          <target state="translated">자바 Varargs</target>
        </trans-unit>
        <trans-unit id="746c982d879f15c37e1edb8014f7e0a7a57db534" translate="yes" xml:space="preserve">
          <source>Java annotations are 100% compatible with Kotlin:</source>
          <target state="translated">Java 주석은 Kotlin과 100 % 호환됩니다.</target>
        </trans-unit>
        <trans-unit id="85a2157de6f31be86d225df11c21c07e4164424b" translate="yes" xml:space="preserve">
          <source>Java classes sometimes use a method declaration for the indices with a variable number of arguments (varargs):</source>
          <target state="translated">Java 클래스는 때때로 가변 개수의 인수 (varargs)와 함께 색인에 메소드 선언을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="695cb4693d8f07873088e0e2ca1954a3e6b1dec0" translate="yes" xml:space="preserve">
          <source>Java compiler options</source>
          <target state="translated">자바 컴파일러 옵션</target>
        </trans-unit>
        <trans-unit id="53d9a40a89e185b3910817fb0920db3433576443" translate="yes" xml:space="preserve">
          <source>Java generics in Kotlin</source>
          <target state="translated">코 틀린의 자바 제네릭</target>
        </trans-unit>
        <trans-unit id="8de44c9537e6dbc55b9f15952d2d0c0a403f924d" translate="yes" xml:space="preserve">
          <source>Java interoperation:</source>
          <target state="translated">자바 상호 운용 :</target>
        </trans-unit>
        <trans-unit id="e832e4cfea4d9817c729a744a89f9449a5f1d1ee" translate="yes" xml:space="preserve">
          <source>Java only got support for function types and lambda expressions a few years ago. Previously, Java worked around this by using an interface to define a function signature and allowing an inline, anonymous definition of a class that implements the interface. This is also available in Kotlin, partly for compatibility with Java libraries and partly because it can be handy for specifying event handlers (in particular if there is more than one event type that must be listened for by the same listener object). Consider an interface or a (possibly abstract) class, as well a function that takes an instance of it:</source>
          <target state="translated">Java는 몇 년 전에 함수 유형과 람다 식만 지원했습니다. 이전에 Java는 인터페이스를 사용하여 함수 서명을 정의하고 인터페이스를 구현하는 클래스의 인라인 익명 정의를 허용하여이 문제를 해결했습니다. Kotlin에서도 부분적으로 Java 라이브러리와의 호환성을 위해 사용 가능하며, 특히 동일한 리스너 객체가 수신해야하는 이벤트 유형이 둘 이상인 경우 이벤트 핸들러를 지정하는 데 편리 할 수 ​​있기 때문에이 기능을 사용할 수 있습니다. 인터페이스 또는 (아마도 추상적 인) 클래스와 그 인스턴스를 취하는 함수를 고려하십시오.</target>
        </trans-unit>
        <trans-unit id="1915d97968b458264a2f2dbd19e10237488a0c18" translate="yes" xml:space="preserve">
          <source>Java reflection works on Kotlin classes and vice versa. As mentioned above, you can use &lt;code&gt;instance::class.java&lt;/code&gt;, &lt;code&gt;ClassName::class.java&lt;/code&gt; or &lt;code&gt;instance.javaClass&lt;/code&gt; to enter Java reflection through &lt;code&gt;java.lang.Class&lt;/code&gt;.</source>
          <target state="translated">Java 리플렉션은 Kotlin 클래스에서 작동하며 그 반대도 마찬가지입니다. 위에서 언급 한 것처럼 &lt;code&gt;instance::class.java&lt;/code&gt; , &lt;code&gt;ClassName::class.java&lt;/code&gt; 또는 &lt;code&gt;instance.javaClass&lt;/code&gt; 를 사용하여 &lt;code&gt;java.lang.Class&lt;/code&gt; 를 통해 Java 리플렉션을 입력 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="604557100ea734a8e508b4cfcd3fd0b6ae0fffe3" translate="yes" xml:space="preserve">
          <source>Java types which have nullability annotations are represented not as platform types, but as actual nullable or non-null Kotlin types. The compiler supports several flavors of nullability annotations, including:</source>
          <target state="translated">널 입력 가능 어노테이션이있는 Java 유형은 플랫폼 유형이 아니라 실제 널 입력 가능 또는 널이 아닌 Kotlin 유형으로 표시됩니다. 컴파일러는 다음을 포함하여 여러 가지 널 입력 가능 주석을 지원합니다.</target>
        </trans-unit>
        <trans-unit id="dc024086aaa20e53d67ca09758f8c4d13c64cb3c" translate="yes" xml:space="preserve">
          <source>Java's arrays are mapped as mentioned &lt;a href=&quot;java-interop#java-arrays&quot;&gt;below&lt;/a&gt;:</source>
          <target state="translated">Java의 배열은 &lt;a href=&quot;java-interop#java-arrays&quot;&gt;다음&lt;/a&gt; 과 같이 매핑됩니다 .</target>
        </trans-unit>
        <trans-unit id="a52c0cfe5cac6860cf184e57dfda94c4e4aab7eb" translate="yes" xml:space="preserve">
          <source>Java's boxed primitive types are mapped to nullable Kotlin types:</source>
          <target state="translated">Java의 박스형 기본 유형은 nullable Kotlin 유형에 매핑됩니다.</target>
        </trans-unit>
        <trans-unit id="a93aa77d99dfed9f4e64393e47b4458e7232bba4" translate="yes" xml:space="preserve">
          <source>Java's raw types are converted into star projections,</source>
          <target state="translated">Java의 원시 유형은 별 투영법으로 변환됩니다.</target>
        </trans-unit>
        <trans-unit id="4b08bd53dd6ccc40659e0ead9c100bf1e91b5ac6" translate="yes" xml:space="preserve">
          <source>Java's wildcards are converted into type projections,</source>
          <target state="translated">Java의 와일드 카드는 유형 투영으로 변환됩니다.</target>
        </trans-unit>
        <trans-unit id="b7e0008cfda3632a9ce80870d8378b5ff1ce2de5" translate="yes" xml:space="preserve">
          <source>Java-default method calls</source>
          <target state="translated">자바 기본 메소드 호출</target>
        </trans-unit>
        <trans-unit id="28658a9e65ac1fce8b895da9099268ad9257b5a4" translate="yes" xml:space="preserve">
          <source>Java-style reflection</source>
          <target state="translated">자바 스타일 반영</target>
        </trans-unit>
        <trans-unit id="d3d2902f267714c4d2888df7a9cb53494548b955" translate="yes" xml:space="preserve">
          <source>Java2Kotlin converter</source>
          <target state="translated">Java2Kotlin 변환기</target>
        </trans-unit>
        <trans-unit id="ee620923ff5fc510555dc37083a135ee93b5404b" translate="yes" xml:space="preserve">
          <source>JavaScript</source>
          <target state="translated">JavaScript</target>
        </trans-unit>
        <trans-unit id="cb598ee02a2a4ba66a8b8c49bee0bba3cd995db7" translate="yes" xml:space="preserve">
          <source>JavaScript Backend</source>
          <target state="translated">자바 스크립트 백엔드</target>
        </trans-unit>
        <trans-unit id="7ceba75ee976f8baf2462d625f66425dd948bcef" translate="yes" xml:space="preserve">
          <source>JavaScript DCE</source>
          <target state="translated">자바 스크립트 DCE</target>
        </trans-unit>
        <trans-unit id="b3f888694954b41c7c2070331437408d8501d710" translate="yes" xml:space="preserve">
          <source>JavaScript Modules</source>
          <target state="translated">자바 스크립트 모듈</target>
        </trans-unit>
        <trans-unit id="8c784f817b830f35e8d38eb1b5afb3d6e6b36d02" translate="yes" xml:space="preserve">
          <source>JavaScript Reflection</source>
          <target state="translated">자바 스크립트 리플렉션</target>
        </trans-unit>
        <trans-unit id="6427edfd3be2acf2cb18120ef89fe67414e7fe92" translate="yes" xml:space="preserve">
          <source>JavaScript backend</source>
          <target state="translated">자바 스크립트 백엔드</target>
        </trans-unit>
        <trans-unit id="21bc6187f833ae0234195b5bb7f032fa9c9eddf3" translate="yes" xml:space="preserve">
          <source>JavaScript backend now generates more statically checkable code, which is friendlier to JS code processing tools, like minifiers, optimisers, linters, etc.</source>
          <target state="translated">JavaScript 백엔드는 이제 더 정적으로 확인할 수있는 코드를 생성하는데,이 코드는 축소 기, 최적화 기, 린터 등과 같은 JS 코드 처리 도구에 더 친숙합니다.</target>
        </trans-unit>
        <trans-unit id="18040e1d6c0077c2a62cb7d49ff581501d95859d" translate="yes" xml:space="preserve">
          <source>JavaScript does not have concept of packages (namespaces). They are usually emulated by nested objects. The compiler turns references to &lt;code&gt;external&lt;/code&gt; declarations either to plain unprefixed names (in case of &lt;em&gt;plain&lt;/em&gt; modules) or to plain imports. However, if a JavaScript library provides its declarations in packages, you won't be satisfied with this. You can tell the compiler to generate additional prefix before references to &lt;code&gt;external&lt;/code&gt; declarations using the &lt;code&gt;@JsQualifier(...)&lt;/code&gt; annotation.</source>
          <target state="translated">JavaScript에는 패키지 (네임 스페이스) 개념이 없습니다. 일반적으로 중첩 된 객체에 의해 에뮬레이트됩니다. 컴파일러는 &lt;code&gt;external&lt;/code&gt; 선언에 대한 참조를 접두사가없는 일반 이름 ( &lt;em&gt;일반&lt;/em&gt; 모듈의 경우 ) 또는 일반 가져 오기로 바꿉니다 . 그러나 JavaScript 라이브러리가 선언을 패키지로 제공하면 이에 만족하지 않습니다. &lt;code&gt;@JsQualifier(...)&lt;/code&gt; 주석을 사용하여 &lt;code&gt;external&lt;/code&gt; 선언에 대한 참조 전에 추가 접두사를 생성하도록 컴파일러에 지시 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="95802660178652b3cea0422eb5403bb445448c4c" translate="yes" xml:space="preserve">
          <source>JavaScript does not have the concept of interfaces. When a function expects its parameter to support &lt;code&gt;foo&lt;/code&gt; and &lt;code&gt;bar&lt;/code&gt; methods, you just pass objects that actually have these methods. You can use interfaces to express this for statically-typed Kotlin, for example:</source>
          <target state="translated">JavaScript에는 인터페이스 개념이 없습니다. 함수가 해당 매개 변수가 &lt;code&gt;foo&lt;/code&gt; 및 &lt;code&gt;bar&lt;/code&gt; 메서드 를 지원할 것으로 예상하면 실제로 이러한 메서드가있는 객체를 전달하면됩니다. 정적으로 형식화 된 Kotlin에 대해 인터페이스를 사용하여이를 표현할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="fffb2c94a89ef37f4ff800dd4f2f3274e7b4c9bf" translate="yes" xml:space="preserve">
          <source>JetBrains develops and maintains several tools specifically for the React community: &lt;a href=&quot;https://github.com/JetBrains/kotlin-wrappers&quot;&gt;React bindings&lt;/a&gt; as well as &lt;a href=&quot;https://github.com/JetBrains/create-react-kotlin-app&quot;&gt;Create React Kotlin App&lt;/a&gt;. The latter helps you start building React apps with Kotlin with no build configuration.</source>
          <target state="translated">JetBrains는 React 커뮤니티를 위해 특별히 다음과 같은 몇 가지 도구를 개발하고 유지 관리합니다. &lt;a href=&quot;https://github.com/JetBrains/kotlin-wrappers&quot;&gt;React 바인딩&lt;/a&gt; 및 &lt;a href=&quot;https://github.com/JetBrains/create-react-kotlin-app&quot;&gt;React Kotlin App 작성&lt;/a&gt; . 후자는 빌드 구성없이 Kotlin으로 React 앱을 빌드하는 데 도움이됩니다.</target>
        </trans-unit>
        <trans-unit id="0afbb0e9a99e99277b2f49549fedbc94a32802c2" translate="yes" xml:space="preserve">
          <source>Job in the context</source>
          <target state="translated">맥락에서의 직업</target>
        </trans-unit>
        <trans-unit id="4f050b9ce8a72499f6d4325b437a4f8f851d64df" translate="yes" xml:space="preserve">
          <source>Join us to continue exploring the C language types and their representation in Kotlin/Native in the related tutorials:</source>
          <target state="translated">관련 학습서에서 Kotlin / Native의 C 언어 유형 및 해당 표현을 계속 탐색하려면 우리와 함께하십시오.</target>
        </trans-unit>
        <trans-unit id="560f658735b552460323d7d08486e67939d8b69b" translate="yes" xml:space="preserve">
          <source>Joining a course</source>
          <target state="translated">코스 참여</target>
        </trans-unit>
        <trans-unit id="e14bf41ef01fdef5cf6b52dd5564ec2b2886f811" translate="yes" xml:space="preserve">
          <source>Joshua Bloch calls those objects you only &lt;strong&gt;read&lt;/strong&gt; from &lt;strong&gt;Producers&lt;/strong&gt;, and those you only &lt;strong&gt;write&lt;/strong&gt; to &lt;strong&gt;Consumers&lt;/strong&gt;. He recommends: &quot;&lt;em&gt;For maximum flexibility, use wildcard types on input parameters that represent producers or consumers&lt;/em&gt;&quot;, and proposes the following mnemonic:</source>
          <target state="translated">여호수아 블로흐 그 당신은 개체를 호출 &lt;strong&gt;읽기&lt;/strong&gt; 에서 &lt;strong&gt;생산자&lt;/strong&gt; 는 만하고 &lt;strong&gt;쓰기&lt;/strong&gt; 에 &lt;strong&gt;소비자&lt;/strong&gt; . &quot; &lt;em&gt;유연성을 극대화하려면 생산자 또는 소비자를 나타내는 입력 매개 변수에 와일드 카드 유형을 사용&lt;/em&gt; 하고 다음 니모닉을 제안합니다.</target>
        </trans-unit>
        <trans-unit id="aaaf7cda9e752b334875dd3fb12220ae53318575" translate="yes" xml:space="preserve">
          <source>JsArray</source>
          <target state="translated">JsArray</target>
        </trans-unit>
        <trans-unit id="5cf2add42044a4a104180a92b4649ba344349b36" translate="yes" xml:space="preserve">
          <source>JsClass</source>
          <target state="translated">JsClass</target>
        </trans-unit>
        <trans-unit id="680d5016d394bd1910f8e79c1f48e1099ec8a45e" translate="yes" xml:space="preserve">
          <source>JsModule</source>
          <target state="translated">JsModule</target>
        </trans-unit>
        <trans-unit id="bb2ba9a64ec3ce618d8658d2bac2ab5b52799c41" translate="yes" xml:space="preserve">
          <source>JsName</source>
          <target state="translated">JsName</target>
        </trans-unit>
        <trans-unit id="285e217de7a6a19bb6ff3224730d97a2ffb8669c" translate="yes" xml:space="preserve">
          <source>JsNonModule</source>
          <target state="translated">JsNonModule</target>
        </trans-unit>
        <trans-unit id="4431c8a7c0e95318d4df4acc2fb68414f204013b" translate="yes" xml:space="preserve">
          <source>JsQualifier</source>
          <target state="translated">JsQualifier</target>
        </trans-unit>
        <trans-unit id="5e2ef85ac474ea70113e00f2d535adfcd131ef41" translate="yes" xml:space="preserve">
          <source>JsValue</source>
          <target state="translated">JsValue</target>
        </trans-unit>
        <trans-unit id="0e8b29f774aacb41aea9f3a3e3922bc27a5b2f86" translate="yes" xml:space="preserve">
          <source>Json</source>
          <target state="translated">Json</target>
        </trans-unit>
        <trans-unit id="ee67901393cc367dccd6b7380bc834e3173528f8" translate="yes" xml:space="preserve">
          <source>Jumping between threads</source>
          <target state="translated">스레드 간 점프</target>
        </trans-unit>
        <trans-unit id="35e8c2b0fe924d03188fa9d13f85d320bcb98681" translate="yes" xml:space="preserve">
          <source>Just add the plugin JAR file to the compiler plugin classpath and specify the list of sam-with-receiver annotations:</source>
          <target state="translated">플러그인 JAR 파일을 컴파일러 플러그인 클래스 경로에 추가하고 sam-with-receiver 주석 목록을 지정하십시오.</target>
        </trans-unit>
        <trans-unit id="23faffb10dc95518c4b08d2ccd86868a15d724ef" translate="yes" xml:space="preserve">
          <source>Just as in Java 8, Kotlin now allows to use underscores in numeric literals to separate groups of digits:</source>
          <target state="translated">Java 8에서와 마찬가지로 Kotlin은 이제 숫자 리터럴에서 밑줄을 사용하여 숫자 그룹을 구분할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1d8e794cae8b9d9de103c8c7346fbf29e3d8b66f" translate="yes" xml:space="preserve">
          <source>Just like Java 8, Kotlin supports SAM conversions. This means that Kotlin function literals can be automatically converted into implementations of Java interfaces with a single non-default method, as long as the parameter types of the interface method match the parameter types of the Kotlin function.</source>
          <target state="translated">Java 8과 마찬가지로 Kotlin은 SAM 변환을 지원합니다. 이는 인터페이스 메소드의 매개 변수 유형이 Kotlin 함수의 매개 변수 유형과 일치하는 경우 기본이 아닌 단일 메소드를 사용하여 Kotlin 함수 리터럴이 Java 인터페이스 구현으로 자동 변환 될 수 있음을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="949a51b86664f4131dce0e0c1b95750468898210" translate="yes" xml:space="preserve">
          <source>Just like Java and JavaScript, Kotlin supports end-of-line and block comments.</source>
          <target state="translated">Java 및 JavaScript와 마찬가지로 Kotlin은 라인 끝 및 블록 주석을 지원합니다.</target>
        </trans-unit>
        <trans-unit id="470dca02756a771de4224b1f3a4e099fc973e2f5" translate="yes" xml:space="preserve">
          <source>Just like Java's anonymous inner classes, code in object expressions can access variables from the enclosing scope. (Unlike Java, this is not restricted to final or effectively final variables.)</source>
          <target state="translated">Java의 익명 내부 클래스와 마찬가지로 객체 표현식의 코드는 둘러싸는 범위에서 변수에 액세스 할 수 있습니다. Java와 달리 이는 최종 변수 또는 사실상 최종 변수로 제한되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="52bd785fc290723ed0a2f51dcda0df34f29bb395" translate="yes" xml:space="preserve">
          <source>Just like in Java, a special case is the &lt;code&gt;value&lt;/code&gt; parameter; its value can be specified without an explicit name:</source>
          <target state="translated">Java와 마찬가지로 특별한 경우는 &lt;code&gt;value&lt;/code&gt; 매개 변수입니다. 명시적인 이름없이 값을 지정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="56e17eda787fc8a6435c74f86b6d7baef2f4cc5c" translate="yes" xml:space="preserve">
          <source>Just like in Java, enum classes in Kotlin have synthetic methods allowing to list the defined enum constants and to get an enum constant by its name. The signatures of these methods are as follows (assuming the name of the enum class is &lt;code&gt;EnumClass&lt;/code&gt;):</source>
          <target state="translated">Java와 마찬가지로 Kotlin의 열거 형 클래스에는 정의 된 열거 형 상수를 나열하고 이름별로 열거 형 상수를 얻을 수있는 합성 메서드가 있습니다. 이러한 메소드의 서명은 다음과 같습니다 (enum 클래스의 이름이 &lt;code&gt;EnumClass&lt;/code&gt; 라고 가정 ).</target>
        </trans-unit>
        <trans-unit id="9137e7255bdeb308d1bb811a9d7f200fe163b672" translate="yes" xml:space="preserve">
          <source>Just like regular members of the companion object, they can be called using only the class name as the qualifier:</source>
          <target state="translated">컴패니언 객체의 일반 멤버와 마찬가지로 클래스 이름 만 한정자로 사용하여 호출 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0848ea7d6dc0355eb57cb3d83744477db1fa4d97" translate="yes" xml:space="preserve">
          <source>Just like with JavaDoc, KDoc comments start with &lt;code&gt;/**&lt;/code&gt; and end with &lt;code&gt;*/&lt;/code&gt;. Every line of the comment may begin with an asterisk, which is not considered part of the contents of the comment.</source>
          <target state="translated">JavaDoc과 마찬가지로 KDoc 주석은 &lt;code&gt;/**&lt;/code&gt; 로 시작 하고 &lt;code&gt;*/&lt;/code&gt; 로 끝납니다 . 주석의 모든 줄은 별표로 시작할 수 있으며, 주석 내용의 일부로 간주되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="d4d2de8b4148383d16c153caa1ed915e8e3e98f8" translate="yes" xml:space="preserve">
          <source>JvmDefault</source>
          <target state="translated">JvmDefault</target>
        </trans-unit>
        <trans-unit id="692baf8c605cdd872f8ac1b51f0db35d878fa6ec" translate="yes" xml:space="preserve">
          <source>JvmField</source>
          <target state="translated">JvmField</target>
        </trans-unit>
        <trans-unit id="8cafb887c2be5267183d19409f4ac9f885353c0a" translate="yes" xml:space="preserve">
          <source>JvmMultifileClass</source>
          <target state="translated">JvmMultifileClass</target>
        </trans-unit>
        <trans-unit id="2033eae859b01f53e2d78af856c5c34461b71b90" translate="yes" xml:space="preserve">
          <source>JvmName</source>
          <target state="translated">JvmName</target>
        </trans-unit>
        <trans-unit id="311d71c3b3f54390c29adff749b3edbb6a494b4a" translate="yes" xml:space="preserve">
          <source>JvmOverloads</source>
          <target state="translated">JvmOverloads</target>
        </trans-unit>
        <trans-unit id="747778441d808007d459844a0415514317ff72b7" translate="yes" xml:space="preserve">
          <source>JvmStatic</source>
          <target state="translated">JvmStatic</target>
        </trans-unit>
        <trans-unit id="6bc8e12710c62fe36d0378462ee3b1c664cd3300" translate="yes" xml:space="preserve">
          <source>JvmSuppressWildcards</source>
          <target state="translated">JvmSuppressWildcards</target>
        </trans-unit>
        <trans-unit id="a351df29143ba3c04cf22dc294f311273bb9b60f" translate="yes" xml:space="preserve">
          <source>JvmSynthetic</source>
          <target state="translated">JvmSynthetic</target>
        </trans-unit>
        <trans-unit id="85e086e57dc0c9b8c2d108ccec8876b36768e9b7" translate="yes" xml:space="preserve">
          <source>JvmWildcard</source>
          <target state="translated">JvmWildcard</target>
        </trans-unit>
        <trans-unit id="269b4c8f67d4bef3fb8e55e7c16a561a21d1145a" translate="yes" xml:space="preserve">
          <source>KAnnotatedElement</source>
          <target state="translated">KAnnotatedElement</target>
        </trans-unit>
        <trans-unit id="2380c006605522b5d08a2ee817a1eaa70c3eee66" translate="yes" xml:space="preserve">
          <source>KCallable</source>
          <target state="translated">KCallable</target>
        </trans-unit>
        <trans-unit id="638ba738d7801f4caebfacfc6daada8a29efaa3c" translate="yes" xml:space="preserve">
          <source>KClass</source>
          <target state="translated">KClass</target>
        </trans-unit>
        <trans-unit id="fab281a5b19ac7d1db397f74e48d5b9b12cc8340" translate="yes" xml:space="preserve">
          <source>KClass.cast</source>
          <target state="translated">KClass.cast</target>
        </trans-unit>
        <trans-unit id="acf5de634c6435ff94d10fad8e77c31d4afdb216" translate="yes" xml:space="preserve">
          <source>KClass.isInstance</source>
          <target state="translated">KClass.isInstance</target>
        </trans-unit>
        <trans-unit id="0eb6eed766c7bf5a996d5d184bea9e1688094497" translate="yes" xml:space="preserve">
          <source>KClass.safeCast</source>
          <target state="translated">KClass.safeCast</target>
        </trans-unit>
        <trans-unit id="64fa1008f290c0ccc3cc7c6ea0be14a5730d8c96" translate="yes" xml:space="preserve">
          <source>KClassifier</source>
          <target state="translated">KClassifier</target>
        </trans-unit>
        <trans-unit id="79b222c243d152a61ff297964121af433061592b" translate="yes" xml:space="preserve">
          <source>KClassifier.createType</source>
          <target state="translated">KClassifier.createType</target>
        </trans-unit>
        <trans-unit id="20cb65ed76161cb0b2be5e7c93b9d81ef134450b" translate="yes" xml:space="preserve">
          <source>KDeclarationContainer</source>
          <target state="translated">KDeclarationContainer</target>
        </trans-unit>
        <trans-unit id="7bf1a6c1fa5dce180803fdb8c3400d5e981f7201" translate="yes" xml:space="preserve">
          <source>KDoc Syntax</source>
          <target state="translated">KDoc 구문</target>
        </trans-unit>
        <trans-unit id="7d4c77574d0b857a214718597dca35a72ce59ec3" translate="yes" xml:space="preserve">
          <source>KDoc currently supports the following block tags:</source>
          <target state="translated">KDoc은 현재 다음 블록 태그를 지원합니다.</target>
        </trans-unit>
        <trans-unit id="fae5be3a00cdb97c4b5aa9435d19be927a5665ba" translate="yes" xml:space="preserve">
          <source>KDoc does not support the &lt;code&gt;@deprecated&lt;/code&gt; tag. Instead, please use the &lt;code&gt;@Deprecated&lt;/code&gt; annotation.</source>
          <target state="translated">KDoc은 &lt;code&gt;@deprecated&lt;/code&gt; 태그를 지원하지 않습니다 . 대신 &lt;code&gt;@Deprecated&lt;/code&gt; 주석을 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="343a3fd44d3f90b682e5b8542c76a1c8f0dc43bf" translate="yes" xml:space="preserve">
          <source>KDoc syntax</source>
          <target state="translated">KDoc 구문</target>
        </trans-unit>
        <trans-unit id="cf7f75d8adb5a4855b94e1806ea4b9da20753a2a" translate="yes" xml:space="preserve">
          <source>KFunction</source>
          <target state="translated">KFunction</target>
        </trans-unit>
        <trans-unit id="351228c4e54d9346ab6c9f3124cf8905349ef3f6" translate="yes" xml:space="preserve">
          <source>KMutableProperty</source>
          <target state="translated">KMutableProperty</target>
        </trans-unit>
        <trans-unit id="b8079b1b2c0efc81f1810eda68de2b7cfe28211b" translate="yes" xml:space="preserve">
          <source>KMutableProperty0</source>
          <target state="translated">KMutableProperty0</target>
        </trans-unit>
        <trans-unit id="ee64a1ab548503607558b0ae24255a9fb8d1bf97" translate="yes" xml:space="preserve">
          <source>KMutableProperty1</source>
          <target state="translated">KMutableProperty1</target>
        </trans-unit>
        <trans-unit id="b5a2a8a013bdb0ae3b43fd0eedfa92a1c579f8b7" translate="yes" xml:space="preserve">
          <source>KMutableProperty2</source>
          <target state="translated">KMutableProperty2</target>
        </trans-unit>
        <trans-unit id="3b161212f1754e4e1f54c5dee3fdb112a6efcc79" translate="yes" xml:space="preserve">
          <source>KParameter</source>
          <target state="translated">KParameter</target>
        </trans-unit>
        <trans-unit id="47dc03443aa940939b9abccc2588997b2fd72705" translate="yes" xml:space="preserve">
          <source>KProperty</source>
          <target state="translated">KProperty</target>
        </trans-unit>
        <trans-unit id="7c65965ff00632a4a27df6d2ccf39af470a5196a" translate="yes" xml:space="preserve">
          <source>KProperty0</source>
          <target state="translated">KProperty0</target>
        </trans-unit>
        <trans-unit id="8baedb2820a644b389145928c1658d83b9918bc5" translate="yes" xml:space="preserve">
          <source>KProperty1</source>
          <target state="translated">KProperty1</target>
        </trans-unit>
        <trans-unit id="8bf91abab2e2266a64dcd908bc6e070ddbaf118e" translate="yes" xml:space="preserve">
          <source>KProperty1.getDelegate</source>
          <target state="translated">KProperty1.getDelegate</target>
        </trans-unit>
        <trans-unit id="d8609e0c5b369de4819d2e07e76fd6ed37986905" translate="yes" xml:space="preserve">
          <source>KProperty2</source>
          <target state="translated">KProperty2</target>
        </trans-unit>
        <trans-unit id="fd138efe2eefe64c683fdbac01b4ebe15e42c11f" translate="yes" xml:space="preserve">
          <source>KProperty2.getDelegate</source>
          <target state="translated">KProperty2.getDelegate</target>
        </trans-unit>
        <trans-unit id="cddedd34830292c250dc6df0c7292dd170403bdb" translate="yes" xml:space="preserve">
          <source>KType</source>
          <target state="translated">KType</target>
        </trans-unit>
        <trans-unit id="f3764cdd111b81b5f82e469014413398559a3a69" translate="yes" xml:space="preserve">
          <source>KTypeParameter</source>
          <target state="translated">KTypeParameter</target>
        </trans-unit>
        <trans-unit id="a52a8fe183ee882846ec18218986d60cbd8b9caa" translate="yes" xml:space="preserve">
          <source>KTypeParameter.variance</source>
          <target state="translated">KTypeParameter.variance</target>
        </trans-unit>
        <trans-unit id="541ac7b02574ef282f5fea0a7caa24f963767d58" translate="yes" xml:space="preserve">
          <source>KTypeProjection</source>
          <target state="translated">KTypeProjection</target>
        </trans-unit>
        <trans-unit id="453bbaf5b6df4218f396acb7d784d58647332cd3" translate="yes" xml:space="preserve">
          <source>KVariance</source>
          <target state="translated">KVariance</target>
        </trans-unit>
        <trans-unit id="540dc0ef81ec2a035fa8eb530610a94d10ceaf33" translate="yes" xml:space="preserve">
          <source>KVisibility</source>
          <target state="translated">KVisibility</target>
        </trans-unit>
        <trans-unit id="89ee95ab7caa6f00ebf6ba552593878d5c2b4d1a" translate="yes" xml:space="preserve">
          <source>Kapt can generate Kotlin sources. Just write the generated Kotlin source files to the directory specified by &lt;code&gt;processingEnv.options[&quot;kapt.kotlin.generated&quot;]&lt;/code&gt;, and these files will be compiled together with the main sources.</source>
          <target state="translated">Kapt은 Kotlin 소스를 생성 할 수 있습니다. 생성 된 Kotlin 소스 파일을 &lt;code&gt;processingEnv.options[&quot;kapt.kotlin.generated&quot;]&lt;/code&gt; 로 지정된 디렉토리에 쓰면 이 파일들이 기본 소스와 함께 컴파일됩니다.</target>
        </trans-unit>
        <trans-unit id="115c000133ca0eeaa296737859925189dceee8bb" translate="yes" xml:space="preserve">
          <source>Kapt compiler plugin is available in the binary distribution of the Kotlin compiler.</source>
          <target state="translated">Kapt 컴파일러 플러그인은 Kotlin 컴파일러의 바이너리 배포판에서 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d2790ed7723277b25aa2209903904a8c31657160" translate="yes" xml:space="preserve">
          <source>Kapt uses Java compiler to run annotation processors.</source>
          <target state="translated">Kapt는 Java 컴파일러를 사용하여 주석 프로세서를 실행합니다.</target>
        </trans-unit>
        <trans-unit id="ec688ce3d89067940f46fd29a7ea54660b831823" translate="yes" xml:space="preserve">
          <source>Keep in mind that this is just syntactic sugar - you're not actually modifying the class or its instances. Therefore, you have to import an extension function/property wherever you want to use it (since it isn't carried along with the instances of the class). For the same reason, you can not override extension members - you can reimplement them for subtypes, but the resolution happens at compile-time based on the static type of the expression you're invoking it on. So if you declare an extension function for &lt;code&gt;Vehicle&lt;/code&gt;, and one with the same name and signature for its subclass &lt;code&gt;Car&lt;/code&gt;, and you do the following, it's the extension function on &lt;code&gt;Vehicle&lt;/code&gt; that will be called, even though &lt;code&gt;v&lt;/code&gt; is really a &lt;code&gt;Car&lt;/code&gt;:</source>
          <target state="translated">이것은 구문상의 설탕 일뿐입니다. 실제로 클래스 나 인스턴스를 수정하지는 않습니다. 따라서 클래스의 인스턴스와 함께 제공되지 않으므로 확장 기능 / 속성을 사용하려는 곳마다 가져와야합니다. 같은 이유로 확장 멤버를 재정의 할 수 없습니다. 하위 멤버에 대해 확장 멤버를 다시 구현할 수 있지만 호출하는 식의 정적 형식에 따라 컴파일 타임에 해결이 이루어집니다. 따라서 &lt;code&gt;Vehicle&lt;/code&gt; 에 대한 확장 함수 와 서브 클래스 &lt;code&gt;Car&lt;/code&gt; 에 대한 동일한 이름 및 서명을 가진 확장 함수를 선언 하고 다음을 수행하는 경우 &lt;code&gt;v&lt;/code&gt; 가 실제로 &lt;code&gt;Car&lt;/code&gt; 인 경우에도 호출 되는 &lt;code&gt;Vehicle&lt;/code&gt; 의 확장 함수입니다 .</target>
        </trans-unit>
        <trans-unit id="18218cc9fd8c5aa995704dae391402dc208f9851" translate="yes" xml:space="preserve">
          <source>Keep the language modern over the years.</source>
          <target state="translated">수년간 언어를 현대적으로 유지하십시오.</target>
        </trans-unit>
        <trans-unit id="428b07e8e32e536ccaf4d9521cd95cadbf7fb10f" translate="yes" xml:space="preserve">
          <source>Keepsafe's App Lock app has also been &lt;a href=&quot;https://medium.com/keepsafe-engineering/lessons-from-converting-an-app-to-100-kotlin-68984a05dcb6&quot;&gt;converted to 100% Kotlin&lt;/a&gt;, leading to a 30% decrease in source line count and 10% decrease in method count.</source>
          <target state="translated">Keepsafe의 App Lock 앱도 &lt;a href=&quot;https://medium.com/keepsafe-engineering/lessons-from-converting-an-app-to-100-kotlin-68984a05dcb6&quot;&gt;100 % Kotlin&lt;/a&gt; 으로 변환 되어 소스 라인 수가 30 % 감소하고 분석법 수가 10 % 감소했습니다.</target>
        </trans-unit>
        <trans-unit id="c67dd20ee842986086a0a915ddc2a279490130ed" translate="yes" xml:space="preserve">
          <source>Key</source>
          <target state="translated">Key</target>
        </trans-unit>
        <trans-unit id="4529f1f2ec7b60606af93bf0af48f282ccf9e92f" translate="yes" xml:space="preserve">
          <source>Key for the elements of &lt;a href=&quot;index&quot;&gt;CoroutineContext&lt;/a&gt;. &lt;a href=&quot;-key#E&quot;&gt;E&lt;/a&gt; is a type of element with this key.</source>
          <target state="translated">&lt;a href=&quot;index&quot;&gt;CoroutineContext&lt;/a&gt; 요소의 키입니다 . &lt;a href=&quot;-key#E&quot;&gt;E&lt;/a&gt; 는이 키가있는 요소 유형입니다.</target>
        </trans-unit>
        <trans-unit id="14a72bb7f1422b3f859b664b3562ae101c3c66b5" translate="yes" xml:space="preserve">
          <source>Key for the elements of &lt;a href=&quot;index&quot;&gt;CoroutineContext&lt;/a&gt;. &lt;a href=&quot;-key#E&quot;&gt;E&lt;/a&gt; is a type of element with this key. Keys in the context are compared &lt;em&gt;by reference&lt;/em&gt;.</source>
          <target state="translated">&lt;a href=&quot;index&quot;&gt;CoroutineContext&lt;/a&gt; 요소의 키입니다 . &lt;a href=&quot;-key#E&quot;&gt;E&lt;/a&gt; 는이 키가있는 요소 유형입니다. 컨텍스트의 키는 &lt;em&gt;참조&lt;/em&gt; 로 비교 &lt;em&gt;됩니다&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="7dea00f8bb18a0d2f420e398a89ddb4931a962cc" translate="yes" xml:space="preserve">
          <source>KeyboardEventInit</source>
          <target state="translated">KeyboardEventInit</target>
        </trans-unit>
        <trans-unit id="12698e3202bea6e77c14cc7645aefe1f40b4a95b" translate="yes" xml:space="preserve">
          <source>Keywords and Operators</source>
          <target state="translated">키워드 및 연산자</target>
        </trans-unit>
        <trans-unit id="e00ac23f2ac2ff73ad4f3c4b263d6c5bbfb80190" translate="yes" xml:space="preserve">
          <source>Kind</source>
          <target state="translated">Kind</target>
        </trans-unit>
        <trans-unit id="6d7060b8f0b142e9cc5d99251ae9bfc8344b5cdb" translate="yes" xml:space="preserve">
          <source>Kind of a module generated by compiler</source>
          <target state="translated">컴파일러에 의해 생성 된 모듈의 종류</target>
        </trans-unit>
        <trans-unit id="1d34a603bd791899c80e1dbe11daaee6bb135493" translate="yes" xml:space="preserve">
          <source>Kind of this parameter.</source>
          <target state="translated">이 매개 변수의 종류</target>
        </trans-unit>
        <trans-unit id="b295237940a339c9b3b99ec9fc0619f9bc3cd8b9" translate="yes" xml:space="preserve">
          <source>Kind represents a particular position of the parameter declaration in the source code, such as an instance, an extension receiver parameter or a value parameter.</source>
          <target state="translated">Kind는 소스 코드에서 매개 변수 선언의 특정 위치 (예 : 확장 수신자 매개 변수 또는 값 매개 변수)를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="b05203cf89b60eb36609a1a8b7f3cafe0927486a" translate="yes" xml:space="preserve">
          <source>Known issues</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7205eb983ba710302eb6c62f19abead98485f315" translate="yes" xml:space="preserve">
          <source>Koans</source>
          <target state="translated">Koans</target>
        </trans-unit>
        <trans-unit id="cff7933a49bb6d767f24e765c4887a762a5f9c00" translate="yes" xml:space="preserve">
          <source>Konan_js_getProperty</source>
          <target state="translated">Konan_js_getProperty</target>
        </trans-unit>
        <trans-unit id="4b97a1cc4cde2d848838f0605a552d5704eea24b" translate="yes" xml:space="preserve">
          <source>Kotlin</source>
          <target state="translated">Kotlin</target>
        </trans-unit>
        <trans-unit id="ce2c3a212ddf8e8e1152459e5ba603b0e8d0abe9" translate="yes" xml:space="preserve">
          <source>Kotlin 1.1 introduced coroutines, a new way of writing asynchronous, non-blocking code (and much more). In this tutorial we will go through some basics of using Kotlin coroutines with the help of the &lt;code&gt;kotlinx.coroutines&lt;/code&gt; library, which is a collection of helpers and wrappers for existing Java libraries.</source>
          <target state="translated">Kotlin 1.1은 비동기 비 차단 코드를 작성하는 새로운 방법 인 코 루틴을 도입했습니다. 이 학습서에서는 기존 Java 라이브러리에 대한 헬퍼 및 랩퍼 콜렉션 인 &lt;code&gt;kotlinx.coroutines&lt;/code&gt; 라이브러리 의 도움으로 Kotlin 코 루틴을 사용하는 몇 가지 기본 사항을 살펴 봅니다 .</target>
        </trans-unit>
        <trans-unit id="63575fcf9f53cf161b23b5a5120b649f923aec04" translate="yes" xml:space="preserve">
          <source>Kotlin 1.1 removes some of the restrictions on sealed and data classes that were present in Kotlin 1.0. Now you can define subclasses of a top-level sealed class on the top level in the same file, and not just as nested classes of the sealed class. Data classes can now extend other classes. This can be used to define a hierarchy of expression classes nicely and cleanly:</source>
          <target state="translated">Kotlin 1.1은 Kotlin 1.0에 존재하는 봉인 및 데이터 클래스에 대한 일부 제한을 제거합니다. 이제 봉인 클래스의 중첩 클래스뿐만 아니라 동일한 파일에서 최상위 수준 봉인 클래스의 하위 클래스를 정의 할 수 있습니다. 데이터 클래스는 이제 다른 클래스를 확장 할 수 있습니다. 이를 통해 표현 클래스의 계층 구조를 훌륭하고 명확하게 정의 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4b689f1de0358fa8de1c1a96775c0c0ab1538fa5" translate="yes" xml:space="preserve">
          <source>Kotlin 1.2 introduces a set of functions for operating with &lt;code&gt;BigInteger&lt;/code&gt; and &lt;code&gt;BigDecimal&lt;/code&gt; and creating them from other numeric types. These are:</source>
          <target state="translated">Kotlin 1.2에는 &lt;code&gt;BigInteger&lt;/code&gt; 및 &lt;code&gt;BigDecimal&lt;/code&gt; 과 함께 작동하고 다른 숫자 유형에서 작성하기 위한 함수 세트가 도입되었습니다 . 이것들은:</target>
        </trans-unit>
        <trans-unit id="f18db78c63aaf770b997189868cab88ccb0ebc9f" translate="yes" xml:space="preserve">
          <source>Kotlin 1.3 continues to evolve and improve scripting API, introducing some experimental support for scripts customization, such as adding external properties, providing static or dynamic dependencies, and so on.</source>
          <target state="translated">Kotlin 1.3은 스크립팅 API를 지속적으로 개선하고 개선하여 외부 속성 추가, 정적 또는 동적 종속성 제공 등과 같은 스크립트 사용자 지정에 대한 실험적인 지원을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="88e2adace5bac1e48c0adc9ef2ac271c679c842b" translate="yes" xml:space="preserve">
          <source>Kotlin 1.3 continues to improve and polish the Native target. See the &lt;a href=&quot;native-overview&quot;&gt;Kotlin/Native overview&lt;/a&gt; for details.</source>
          <target state="translated">Kotlin 1.3은 기본 목표를 지속적으로 개선하고 개선합니다. 자세한 내용은 &lt;a href=&quot;native-overview&quot;&gt;Kotlin / Native 개요&lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="fb394a79550e8145ec468f60617c81e553701477" translate="yes" xml:space="preserve">
          <source>Kotlin 1.3 introduced a simpler form of &lt;code&gt;main&lt;/code&gt; which takes no parameters. Now &amp;ldquo;Hello, World&amp;rdquo; in Kotlin is 19 characters shorter!</source>
          <target state="translated">Kotlin 1.3은 매개 변수를 사용하지 않는 간단한 형식의 &lt;code&gt;main&lt;/code&gt; 을 도입했습니다 . 이제 Kotlin의 &quot;Hello, World&quot;는 19 자 더 짧습니다!</target>
        </trans-unit>
        <trans-unit id="bfa732fa62960ffc201f7ae614e12c53ef901915" translate="yes" xml:space="preserve">
          <source>Kotlin 1.3 introduces a new kind of declaration &amp;mdash; &lt;code&gt;inline class&lt;/code&gt;. Inline classes can be viewed as a restricted version of the usual classes, in particular, inline classes must have exactly one property:</source>
          <target state="translated">Kotlin 1.3에는 새로운 종류의 선언 인 &lt;code&gt;inline class&lt;/code&gt; 도입되었습니다 . 인라인 클래스는 일반 클래스의 제한된 버전으로 볼 수 있습니다. 특히 인라인 클래스에는 정확히 하나의 속성이 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="32e23fcaa9e8679e7038c793f0f15c69e36b0fe8" translate="yes" xml:space="preserve">
          <source>Kotlin 1.3 introduces callable references on suspend-functions and support of Coroutines in the Reflection API.</source>
          <target state="translated">Kotlin 1.3은 Reflection API에서 일시 중단 기능과 Coroutines 지원에 대한 호출 가능한 참조를 소개합니다.</target>
        </trans-unit>
        <trans-unit id="99e7bed5b89ef9affe2aabaa02c6b466182d4674" translate="yes" xml:space="preserve">
          <source>Kotlin 1.3 introduces support for runnable Kotlin &lt;em&gt;scratch files&lt;/em&gt;. &lt;em&gt;Scratch file&lt;/em&gt; is a kotlin script file with a .kts extension which you can run and get evaluation results directly in the editor.</source>
          <target state="translated">Kotlin 1.3은 실행 가능한 Kotlin &lt;em&gt;스크래치 파일을&lt;/em&gt; 지원 &lt;em&gt;합니다&lt;/em&gt; . &lt;em&gt;스크래치 파일&lt;/em&gt; 은 편집기에서 직접 평가 결과를 얻을 수있는 .kts 확장자를 가진 kotlin 스크립트 파일입니다.</target>
        </trans-unit>
        <trans-unit id="62694aae6035c5ad4972f2e14bf03a63310cd91a" translate="yes" xml:space="preserve">
          <source>Kotlin 1.3 introduces support for the &lt;a href=&quot;coding-conventions&quot;&gt;recommended code style&lt;/a&gt; in the IDE. Check out &lt;a href=&quot;code-style-migration-guide&quot;&gt;this page&lt;/a&gt; for the migration guidelines.</source>
          <target state="translated">Kotlin 1.3 은 IDE에서 &lt;a href=&quot;coding-conventions&quot;&gt;권장 코드 스타일&lt;/a&gt; 을 지원합니다 . 마이그레이션 지침은 &lt;a href=&quot;code-style-migration-guide&quot;&gt;이 페이지&lt;/a&gt; 를 확인하십시오 .</target>
        </trans-unit>
        <trans-unit id="dae614ce706dcca5f69b1c3253fcc5bc2a15bada" translate="yes" xml:space="preserve">
          <source>Kotlin 1.3 introduces unsigned integer types:</source>
          <target state="translated">Kotlin 1.3에는 부호없는 정수 유형이 도입되었습니다.</target>
        </trans-unit>
        <trans-unit id="29c35fc143ca98d825aae2e4d6224d719799d607" translate="yes" xml:space="preserve">
          <source>Kotlin 1.3 relaxes this limitation and adds support for functions with bigger arity:</source>
          <target state="translated">Kotlin 1.3은이 제한을 완화하고 더 큰 arity 기능을 지원합니다.</target>
        </trans-unit>
        <trans-unit id="efe980e61f0d5167fc83d8f145a3ab77bfa2773d" translate="yes" xml:space="preserve">
          <source>Kotlin &lt;code&gt;object Object&lt;/code&gt; is accessible as &lt;code&gt;kotlin.root.example.Object&lt;/code&gt;. There is the &lt;code&gt;_instance&lt;/code&gt; function to get the only instance of the object.</source>
          <target state="translated">Kotlin &lt;code&gt;object Object&lt;/code&gt; 는 &lt;code&gt;kotlin.root.example.Object&lt;/code&gt; 로 액세스 할 수 있습니다 . 있다 &lt;code&gt;_instance&lt;/code&gt; 의 개체의 유일한 인스턴스를 얻을 수있는 기능.</target>
        </trans-unit>
        <trans-unit id="0c1eb8d6dc73bce62ae72ba95f8c60b359816283" translate="yes" xml:space="preserve">
          <source>Kotlin Android Extensions</source>
          <target state="translated">코 틀린 안드로이드 확장</target>
        </trans-unit>
        <trans-unit id="7ffa31859972ce0a8778bfbe6687b81f154ab790" translate="yes" xml:space="preserve">
          <source>Kotlin Coding Conventions and IntelliJ IDEA formatter</source>
          <target state="translated">코 틀린 코딩 규약 및 IntelliJ IDEA 포맷터</target>
        </trans-unit>
        <trans-unit id="d072d7cbb3d097a577aaa31d4b14236492b51583" translate="yes" xml:space="preserve">
          <source>Kotlin Collections Overview</source>
          <target state="translated">코 틀린 컬렉션 개요</target>
        </trans-unit>
        <trans-unit id="e053b5d9a8bf9415ef3c2e418563c34aaf8713f7" translate="yes" xml:space="preserve">
          <source>Kotlin Define</source>
          <target state="translated">코 틀린 정의</target>
        </trans-unit>
        <trans-unit id="f0cb9aff4685505b6e4d1a7786d44dbe9c5c78a7" translate="yes" xml:space="preserve">
          <source>Kotlin Educational Plugin</source>
          <target state="translated">코 틀린 교육용 플러그인</target>
        </trans-unit>
        <trans-unit id="d2c2322d0e9d4d8a96800bd4df5ea6b0ed7d65ca" translate="yes" xml:space="preserve">
          <source>Kotlin Evolution</source>
          <target state="translated">코 틀린 진화</target>
        </trans-unit>
        <trans-unit id="5cd6704a0bf9c9ca5663fc3e713188fc0c5a8b1c" translate="yes" xml:space="preserve">
          <source>Kotlin Examples</source>
          <target state="translated">코 틀린 예제</target>
        </trans-unit>
        <trans-unit id="37cd15476fbbf200875db0672669c456999520ce" translate="yes" xml:space="preserve">
          <source>Kotlin Gradle plugin 1.3.41 works with Android Gradle Plugin 3.0 and later.</source>
          <target state="translated">Kotlin Gradle 플러그인 1.3.41은 Android Gradle 플러그인 3.0 이상에서 작동합니다.</target>
        </trans-unit>
        <trans-unit id="4cd0aaf87578a00cb3abace9012077865b35012d" translate="yes" xml:space="preserve">
          <source>Kotlin JavaScript Overview</source>
          <target state="translated">코 틀린 JavaScript 개요</target>
        </trans-unit>
        <trans-unit id="59567d5d08261cc25efe7ed7644a3eac45c8cd4f" translate="yes" xml:space="preserve">
          <source>Kotlin JavaScript wrappers for the &lt;a href=&quot;https://fetch.spec.whatwg.org&quot;&gt;W3C fetch API&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;https://fetch.spec.whatwg.org&quot;&gt;W3C 페치 API&lt;/a&gt; 용 Kotlin JavaScript 랩퍼 .</target>
        </trans-unit>
        <trans-unit id="89d3498431602c2625879d1556695e73607eefba" translate="yes" xml:space="preserve">
          <source>Kotlin JavaScript wrappers for the &lt;a href=&quot;https://www.w3.org/TR/FileAPI/&quot;&gt;W3C file API&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;https://www.w3.org/TR/FileAPI/&quot;&gt;W3C 파일 API&lt;/a&gt; 용 Kotlin JavaScript 래퍼 .</target>
        </trans-unit>
        <trans-unit id="87540457cfa4e684d01ade1be4ff2d537b4f72fb" translate="yes" xml:space="preserve">
          <source>Kotlin JavaScript wrappers for the &lt;a href=&quot;https://www.w3.org/TR/XMLHttpRequest/&quot;&gt;XMLHttpRequest API&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;https://www.w3.org/TR/XMLHttpRequest/&quot;&gt;XMLHttpRequest API&lt;/a&gt; 용 Kotlin JavaScript 래퍼입니다 .</target>
        </trans-unit>
        <trans-unit id="e6596f2dab21e4e3036fba3783d7f4c0fbb0bb5f" translate="yes" xml:space="preserve">
          <source>Kotlin JavaScript wrappers for the &lt;a href=&quot;https://www.w3.org/TR/navigation-timing/&quot;&gt;Navigation Timing API&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;https://www.w3.org/TR/navigation-timing/&quot;&gt;Navigation Timing API&lt;/a&gt; 용 Kotlin JavaScript 래퍼 .</target>
        </trans-unit>
        <trans-unit id="449720a2299361e4c4ce93870004ed0025bd08d4" translate="yes" xml:space="preserve">
          <source>Kotlin JavaScript wrappers for the &lt;a href=&quot;https://www.w3.org/TR/notifications/&quot;&gt;Web Notifications API&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;https://www.w3.org/TR/notifications/&quot;&gt;웹 알림 API&lt;/a&gt; 용 Kotlin JavaScript 래퍼 .</target>
        </trans-unit>
        <trans-unit id="273f94ff92211232696d0bb0cccbbaefd99d6ca2" translate="yes" xml:space="preserve">
          <source>Kotlin JavaScript wrappers for the &lt;a href=&quot;https://www.w3.org/TR/workers/&quot;&gt;Web Workers API&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;https://www.w3.org/TR/workers/&quot;&gt;Web Workers API&lt;/a&gt; 용 Kotlin JavaScript 래퍼 .</target>
        </trans-unit>
        <trans-unit id="60b8cb21a679faec431a00498befc15353dcf7ae" translate="yes" xml:space="preserve">
          <source>Kotlin JavaScript wrappers for the DOM API.</source>
          <target state="translated">DOM API를위한 Kotlin JavaScript 래퍼.</target>
        </trans-unit>
        <trans-unit id="510e862b2092dfc113c9c6425e75519b326f41d7" translate="yes" xml:space="preserve">
          <source>Kotlin JavaScript wrappers for the DOM CSS API.</source>
          <target state="translated">DOM CSS API 용 Kotlin JavaScript 래퍼.</target>
        </trans-unit>
        <trans-unit id="f801c6554f4b1898140dcdff66b0ae475172001f" translate="yes" xml:space="preserve">
          <source>Kotlin JavaScript wrappers for the DOM SVG API.</source>
          <target state="translated">DOM SVG API 용 Kotlin JavaScript 래퍼.</target>
        </trans-unit>
        <trans-unit id="ac97493032ddcd8ea7ab49e6704871e5d4e02a32" translate="yes" xml:space="preserve">
          <source>Kotlin JavaScript wrappers for the DOM URL API.</source>
          <target state="translated">DOM URL API 용 Kotlin JavaScript 래퍼.</target>
        </trans-unit>
        <trans-unit id="632516fede4eb8d78a61753d5a6b557583fae63f" translate="yes" xml:space="preserve">
          <source>Kotlin JavaScript wrappers for the DOM events API.</source>
          <target state="translated">DOM 이벤트 API 용 Kotlin JavaScript 래퍼.</target>
        </trans-unit>
        <trans-unit id="9961d958d00f28d74f54365fb789a0a4c6ef0a4a" translate="yes" xml:space="preserve">
          <source>Kotlin JavaScript wrappers for the DOM parsing API.</source>
          <target state="translated">DOM 파싱 API를위한 Kotlin JavaScript 래퍼.</target>
        </trans-unit>
        <trans-unit id="1124adb3f39b71dbc17459b09b1abc27195f61e8" translate="yes" xml:space="preserve">
          <source>Kotlin JavaScript wrappers for the WebGL API.</source>
          <target state="translated">WebGL API 용 Kotlin JavaScript 랩퍼.</target>
        </trans-unit>
        <trans-unit id="c722e55da392cbca2ad7039aefd4506956b7b45a" translate="yes" xml:space="preserve">
          <source>Kotlin Koans</source>
          <target state="translated">코 틀린 코안</target>
        </trans-unit>
        <trans-unit id="8d8f55606ab1553a327fba954030ef9e92582959" translate="yes" xml:space="preserve">
          <source>Kotlin Koans are a series of exercises to get you familiar with the Kotlin Syntax. Each exercise is created as a failing unit test and your job is to make it pass. You can work with Kotlin Koans in one of following two ways:</source>
          <target state="translated">Kotlin Koans는 Kotlin 구문에 익숙해지는 일련의 연습입니다. 각 운동은 실패한 단위 테스트로 작성되며 귀하의 임무는 통과하는 것입니다. Kotlin Koans와 함께 다음 두 가지 방법 중 하나로 작업 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6c868382257c277087bdd2ca5e011f6e8a06d6f5" translate="yes" xml:space="preserve">
          <source>Kotlin Multiplatform projects require Gradle version 4.7 and above, older Gradle versions are not supported.</source>
          <target state="translated">Kotlin Multiplatform 프로젝트에는 Gradle 버전 4.7 이상이 필요하며 이전 Gradle 버전은 지원되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="5beef88265abf70b994272f6614d166413737387" translate="yes" xml:space="preserve">
          <source>Kotlin Multiplatform projects support the Android platform by providing the &lt;code&gt;android&lt;/code&gt; preset. Creating an Android target requires that one of the Android Gradle plugins, like &lt;code&gt;com.android.application&lt;/code&gt; or &lt;code&gt;com.android.library&lt;/code&gt; is manually applied to the project. Only one Android target may be created per Gradle subproject:</source>
          <target state="translated">코 틀린 멀티 프로젝트는 제공함으로써 안드로이드 플랫폼을 지원하는 &lt;code&gt;android&lt;/code&gt; 프리셋을. Android 대상을 만들려면 &lt;code&gt;com.android.application&lt;/code&gt; 또는 &lt;code&gt;com.android.library&lt;/code&gt; 와 같은 Android Gradle 플러그인 중 하나가 프로젝트에 수동으로 적용되어야합니다. Gradle 하위 프로젝트 당 하나의 Android 대상 만 만들 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="dc3e3dd997f7c2c71d9a81f4cdb39cd90d645230" translate="yes" xml:space="preserve">
          <source>Kotlin Numbers and NSNumber</source>
          <target state="translated">코 틀린 숫자와 NSNumber</target>
        </trans-unit>
        <trans-unit id="eb93d433c30733afdb11f2126d70c53184c02256" translate="yes" xml:space="preserve">
          <source>Kotlin Programming: The Big Nerd Ranch Guide</source>
          <target state="translated">코 틀린 프로그래밍 : The Big Nerd Ranch Guide</target>
        </trans-unit>
        <trans-unit id="7be628ef89900aa7e06bf8cc0824f551fbf7c2e0" translate="yes" xml:space="preserve">
          <source>Kotlin Scripting APIs</source>
          <target state="translated">코 틀린 스크립팅 API</target>
        </trans-unit>
        <trans-unit id="011d36adfc33756acd805d34ad317cbce9bd6e81" translate="yes" xml:space="preserve">
          <source>Kotlin Scripts (*.kts)</source>
          <target state="translated">코 틀린 스크립트 (* .kts)</target>
        </trans-unit>
        <trans-unit id="ede3b405bdfcccaf670f3a431d8f9e4a2a31a89a" translate="yes" xml:space="preserve">
          <source>Kotlin Standard Library</source>
          <target state="translated">코 틀린 표준 라이브러리</target>
        </trans-unit>
        <trans-unit id="f1cf27226d5b75bef32541fe78ffcb393aaf20fa" translate="yes" xml:space="preserve">
          <source>Kotlin allows us to provide implementations for a predefined set of operators on our types. These operators have fixed symbolic representation (like &lt;code&gt;+&lt;/code&gt; or &lt;code&gt;*&lt;/code&gt;) and fixed &lt;a href=&quot;https://kotlinlang.org/docs/reference/grammar.html#expressions&quot;&gt;precedence&lt;/a&gt;. To implement an operator, we provide a &lt;a href=&quot;functions#member-functions&quot;&gt;member function&lt;/a&gt; or an &lt;a href=&quot;extensions&quot;&gt;extension function&lt;/a&gt; with a fixed name, for the corresponding type, i.e. left-hand side type for binary operations and argument type for unary ones. Functions that overload operators need to be marked with the &lt;code&gt;operator&lt;/code&gt; modifier.</source>
          <target state="translated">Kotlin을 통해 유형에 대해 사전 정의 된 연산자 세트에 대한 구현을 제공 할 수 있습니다. 이 연산자는 고정 된 기호 표시 ( &lt;code&gt;+&lt;/code&gt; 또는 &lt;code&gt;*&lt;/code&gt; )와 고정 된 &lt;a href=&quot;https://kotlinlang.org/docs/reference/grammar.html#expressions&quot;&gt;우선 순위를 갖습니다&lt;/a&gt; . 연산자를 구현 하기 위해 해당 유형에 대해 고정 이름을 가진 &lt;a href=&quot;functions#member-functions&quot;&gt;멤버 함수&lt;/a&gt; 또는 &lt;a href=&quot;extensions&quot;&gt;확장 함수&lt;/a&gt; 를 제공합니다. 연산자를 과부하시키는 기능은 &lt;code&gt;operator&lt;/code&gt; 수정 자로 표시해야합니다 .</target>
        </trans-unit>
        <trans-unit id="b851c189b290bdaf55745756936a76cc50344467" translate="yes" xml:space="preserve">
          <source>Kotlin allows you to compile your Kotlin projects to JavaScript modules for popular module systems. Here is the list of available options:</source>
          <target state="translated">Kotlin을 사용하면 Kotlin 프로젝트를 널리 사용되는 모듈 시스템 용 JavaScript 모듈로 컴파일 할 수 있습니다. 사용 가능한 옵션 목록은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="9b5fdfaaf9a73290e0eaf81fbe25051b78fa8542" translate="yes" xml:space="preserve">
          <source>Kotlin allows you to enforce symbol visibility (which Python only does via underscore conventions) via &lt;em&gt;visibility modifiers&lt;/em&gt;, which can be placed on symbol declarations. If you don't supply a visibility modifier, you get the default visibility level, which is &lt;em&gt;public&lt;/em&gt;.</source>
          <target state="translated">Kotlin을 사용하면 &lt;em&gt;가시성 수정자를&lt;/em&gt; 통해 기호 가시성 (Python이 밑줄 규칙을 통해서만 수행함)을 적용 할 수 있습니다. &lt;em&gt;가시성 수정자는&lt;/em&gt; 기호 선언에 배치 할 수 있습니다. 가시성 수정자를 제공하지 않으면 기본 가시성 수준 인 &lt;em&gt;public이 표시&lt;/em&gt; 됩니다.</target>
        </trans-unit>
        <trans-unit id="abf47a509d1576212045a5d60665d20e7353bdcd" translate="yes" xml:space="preserve">
          <source>Kotlin also has specialized classes to represent arrays of primitive types without boxing overhead: &lt;code&gt;ByteArray&lt;/code&gt;, &lt;code&gt;ShortArray&lt;/code&gt;, &lt;code&gt;IntArray&lt;/code&gt; and so on. These classes have no inheritance relation to the &lt;code&gt;Array&lt;/code&gt; class, but they have the same set of methods and properties. Each of them also has a corresponding factory function:</source>
          <target state="translated">Kotlin은 또한 &lt;code&gt;ByteArray&lt;/code&gt; , &lt;code&gt;ShortArray&lt;/code&gt; , &lt;code&gt;IntArray&lt;/code&gt; 등의 복싱 오버 헤드없이 기본 유형의 배열을 나타내는 특수화 된 클래스를 가지고 있습니다 . 이 클래스는 &lt;code&gt;Array&lt;/code&gt; 클래스와 상속 관계가 없지만 동일한 메서드 및 속성 집합이 있습니다. 그들 각각은 또한 해당 팩토리 기능을 가지고 있습니다 :</target>
        </trans-unit>
        <trans-unit id="7c8be75b3b89d72e9e8ecc5a19439af68c79c8b1" translate="yes" xml:space="preserve">
          <source>Kotlin also supports a conventional notation for floating-point numbers:</source>
          <target state="translated">Kotlin은 부동 소수점 숫자에 대한 일반적인 표기법도 지원합니다.</target>
        </trans-unit>
        <trans-unit id="fdbc9c499ba317d1129cfbc92871c8a9261e88e6" translate="yes" xml:space="preserve">
          <source>Kotlin and Continuous Integration with TeamCity</source>
          <target state="translated">Kotlin과 TeamCity와의 지속적인 통합</target>
        </trans-unit>
        <trans-unit id="1c08b7274c4d1ababf7790a5bd9928dd47f39d9b" translate="yes" xml:space="preserve">
          <source>Kotlin and OSGi</source>
          <target state="translated">코 틀린과 OSGi</target>
        </trans-unit>
        <trans-unit id="b68da677f694a6554746e03538ca7213a7ff25e8" translate="yes" xml:space="preserve">
          <source>Kotlin and Swift both define nullability as part of the type specification, while Objc defines nullability on methods and properties of a type. As such, the following:</source>
          <target state="translated">Kotlin과 Swift는 모두 형식 지정의 일부로 Null 허용 여부를 정의하고 Objc는 유형의 메서드와 속성에 대한 Null 허용 여부를 정의합니다. 따라서 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="fab22e5d648c157aabeded51b75888d84156c11e" translate="yes" xml:space="preserve">
          <source>Kotlin applications can be deployed into any host that supports Java Web applications, including Amazon Web Services, Google Cloud Platform and more.</source>
          <target state="translated">Kotlin 애플리케이션은 Amazon Web Services, Google Cloud Platform 등을 포함한 Java 웹 애플리케이션을 지원하는 모든 호스트에 배포 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e02f5529b0cc0cc0f331270b870a1119276c7c49" translate="yes" xml:space="preserve">
          <source>Kotlin as a statically typed programming language plays well for writing Gradle build scripts. Thanks to the static type inference, the Kotlin compiler detects errors earlier and shows important compilation error messages and warnings. Both an IDE and the compiler can use the information about types to infer the available functions and properties in a given scope.</source>
          <target state="translated">정적 유형의 프로그래밍 언어 인 Kotlin은 Gradle 빌드 스크립트 작성에 적합합니다. 정적 형식 유추 덕분에 Kotlin 컴파일러는 오류를 미리 감지하고 중요한 컴파일 오류 메시지와 경고를 표시합니다. IDE와 컴파일러 모두 유형에 대한 정보를 사용하여 주어진 범위에서 사용 가능한 함수와 속성을 유추 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6b0d896d7d9bc79daab4d58d21e623cb98946df3" translate="yes" xml:space="preserve">
          <source>Kotlin can also be used as a scripting language. A script is a Kotlin source file (.kts) with top level executable code.</source>
          <target state="translated">Kotlin은 스크립팅 언어로도 사용할 수 있습니다. 스크립트는 최상위 실행 코드가있는 Kotlin 소스 파일 (.kts)입니다.</target>
        </trans-unit>
        <trans-unit id="c3ea6432cc5a54843d5885315d7e06f428855633" translate="yes" xml:space="preserve">
          <source>Kotlin can be compiled for several different platforms. In this document, we assume that the target platform is the Java virtual machine, which grants some extra capabilities - in particular, your code will be compiled to Java bytecode and will therefore be interoperable with the large ecosystem of Java libraries.</source>
          <target state="translated">Kotlin은 여러 플랫폼에 맞게 컴파일 할 수 있습니다. 이 문서에서는 대상 플랫폼이 Java 가상 머신으로 가정하여 추가 기능을 제공합니다. 특히 코드가 Java 바이트 코드로 컴파일되므로 대규모 Java 라이브러리 에코 시스템과 상호 운용 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="fb59a20f7c43ef0e90a9a5fe239e22f7fac4ccd8" translate="yes" xml:space="preserve">
          <source>Kotlin can be used for any kind of development, be it server-side, client-side web and Android. With Kotlin/Native currently in the works, support for other platforms such as embedded systems, macOS and iOS is coming. People are using Kotlin for mobile and server-side applications, client-side with JavaScript or JavaFX, and data science, just to name a few possibilities.</source>
          <target state="translated">Kotlin은 서버 측, 클라이언트 측 웹 및 Android 등 모든 종류의 개발에 사용할 수 있습니다. Kotlin / Native가 현재 작업 중이므로 임베디드 시스템, macOS 및 iOS와 같은 다른 플랫폼에 대한 지원이 제공됩니다. 사람들은 Kotlin을 모바일 및 서버 측 응용 프로그램, JavaScript 또는 JavaFX를 사용하는 클라이언트 측 및 데이터 과학에 사용하고 있습니다.</target>
        </trans-unit>
        <trans-unit id="521266653280c8e4a255fb437cafa5ed253cdca4" translate="yes" xml:space="preserve">
          <source>Kotlin can be used together with existing third-party libraries and frameworks, such as jQuery or React. To access third-party frameworks with a strongly-typed API, you can convert TypeScript definitions from the &lt;a href=&quot;http://definitelytyped.org/&quot;&gt;Definitely Typed&lt;/a&gt; type definitions repository to Kotlin using the &lt;a href=&quot;https://github.com/kotlin/ts2kt&quot;&gt;ts2kt&lt;/a&gt; tool. Alternatively, you can use the &lt;a href=&quot;dynamic-type&quot;&gt;dynamic type&lt;/a&gt; to access any framework without strong typing.</source>
          <target state="translated">Kotlin은 기존의 타사 라이브러리 및 jQuery 또는 React와 같은 프레임 워크와 함께 사용할 수 있습니다. 강력한 형식의 API를 사용하여 타사 프레임 워크에 액세스하려면 &lt;a href=&quot;https://github.com/kotlin/ts2kt&quot;&gt;ts2kt&lt;/a&gt; 도구를 사용하여 TypeScript 정의를 &lt;a href=&quot;http://definitelytyped.org/&quot;&gt;Definitely Typed&lt;/a&gt; 형식 정의 리포지토리에서 Kotlin으로 변환 할 수 있습니다 . 또는 &lt;a href=&quot;dynamic-type&quot;&gt;동적 유형&lt;/a&gt; 을 사용하여 강력한 타이핑없이 모든 프레임 워크에 액세스 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="7c790b4c961dea3d891274def8258c901571e23a" translate="yes" xml:space="preserve">
          <source>Kotlin can get quite close to the compactness of Python's &lt;code&gt;list&lt;/code&gt;/&lt;code&gt;dict&lt;/code&gt;/&lt;code&gt;set&lt;/code&gt; comprehensions. Assuming that &lt;code&gt;people&lt;/code&gt; is a collection of &lt;code&gt;Person&lt;/code&gt; objects with a &lt;code&gt;name&lt;/code&gt; property:</source>
          <target state="translated">코 틀린은 파이썬의 &lt;code&gt;list&lt;/code&gt; / &lt;code&gt;dict&lt;/code&gt; / &lt;code&gt;set&lt;/code&gt; comprehensions 의 압축에 매우 가깝습니다 . &lt;code&gt;people&lt;/code&gt; 이 &lt;code&gt;name&lt;/code&gt; 속성을 가진 &lt;code&gt;Person&lt;/code&gt; 객체 의 모음 이라고 가정합니다 .</target>
        </trans-unit>
        <trans-unit id="88373e20528c6bc39fe448071ad8e0db31e3a229" translate="yes" xml:space="preserve">
          <source>Kotlin can't distinguish between numeric types at run time (except for &lt;code&gt;kotlin.Long&lt;/code&gt;), i.e. the following code works:</source>
          <target state="translated">Kotlin은 런타임에 숫자 유형을 구분할 수 없습니다 ( &lt;code&gt;kotlin.Long&lt;/code&gt; 제외 ). 예를 들어 다음 코드가 작동합니다.</target>
        </trans-unit>
        <trans-unit id="6add9a81cfef0c10e828238aa1031be87d4fbdd7" translate="yes" xml:space="preserve">
          <source>Kotlin cares a lot about stability and backward compatibility of code: Kotlin compatibility policy says that &quot;breaking changes&quot; (e.g., a change which makes the code that used to compile fine, not compile anymore) can be introduced only in the major releases (1.2, 1.3, etc.).</source>
          <target state="translated">Kotlin은 코드의 안정성과 이전 버전과의 호환성에 대해 많은 관심을 갖고 있습니다. Kotlin 호환성 정책에 따르면 &quot;최신 변경 사항&quot;(예 : 더 이상 컴파일하지 않고 컴파일에 사용 된 코드를 변경하는 변경)은 주요 릴리스 (1.2)에서만 도입 될 수 있습니다. , 1.3 등).</target>
        </trans-unit>
        <trans-unit id="7c15ccd2ee8e753a90a11ef141acc11bda9b7db8" translate="yes" xml:space="preserve">
          <source>Kotlin classes and interfaces can be subclassed by Swift/Objective-C classes and protocols.</source>
          <target state="translated">코 틀린 클래스와 인터페이스는 Swift / Objective-C 클래스와 프로토콜에 의해 서브 클래 싱 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="21d314ecbc0aafe901079bc4583e826c76990ca2" translate="yes" xml:space="preserve">
          <source>Kotlin classes have a &lt;code&gt;KotlinBase&lt;/code&gt; base class in Objective-C, the class extends the &lt;code&gt;NSObject&lt;/code&gt; class there. We also have wrappers for collections and exceptions. Most of the collection types are mapped to similar collection types from the other side:</source>
          <target state="translated">Kotlin 클래스에는 Objective-C에 &lt;code&gt;KotlinBase&lt;/code&gt; 기본 클래스 가 있으며이 클래스는 &lt;code&gt;NSObject&lt;/code&gt; 클래스를 확장합니다 . 컬렉션과 예외에 대한 래퍼도 있습니다. 대부분의 컬렉션 유형은 다른 쪽에서 비슷한 컬렉션 유형으로 매핑됩니다.</target>
        </trans-unit>
        <trans-unit id="8a8b117cc96a073696a10569a9a03f3366586d14" translate="yes" xml:space="preserve">
          <source>Kotlin code can be easily called from Java. For example, instances of a Kotlin class can be seamlessly created and operated in Java methods. However, there are certain differences between Java and Kotlin that require attention when integrating Kotlin code into Java. On this page, we'll describe the ways to tailor the interop of your Kotlin code with its Java clients.</source>
          <target state="translated">Kotlin 코드는 Java에서 쉽게 호출 할 수 있습니다. 예를 들어, Kotlin 클래스의 인스턴스는 Java 메소드에서 원활하게 작성하고 운영 할 수 있습니다. 그러나 Kotlin 코드를 Java에 통합 할 때주의를 기울여야하는 Java와 Kotlin의 특정 차이점이 있습니다. 이 페이지에서는 Kotlin 코드와 Java 클라이언트의 상호 운용성을 조정하는 방법에 대해 설명합니다.</target>
        </trans-unit>
        <trans-unit id="82a1593c6b9e1c8836da6d1fc4eb0ee62fff00f0" translate="yes" xml:space="preserve">
          <source>Kotlin collections (i.e. &lt;code&gt;List&lt;/code&gt;, &lt;code&gt;Set&lt;/code&gt;, &lt;code&gt;Map&lt;/code&gt;, etc) are not mapped to any specific JavaScript type.</source>
          <target state="translated">Kotlin 컬렉션 (예 : &lt;code&gt;List&lt;/code&gt; , &lt;code&gt;Set&lt;/code&gt; , &lt;code&gt;Map&lt;/code&gt; 등)은 특정 JavaScript 유형에 매핑되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="89a478aadf91b074b0da52969af13f23d22bc823" translate="yes" xml:space="preserve">
          <source>Kotlin collections are converted to Swift/Objective-C collections as described in the table above. Swift/Objective-C collections are mapped to Kotlin in the same way, except for &lt;code&gt;NSMutableSet&lt;/code&gt; and &lt;code&gt;NSMutableDictionary&lt;/code&gt;. &lt;code&gt;NSMutableSet&lt;/code&gt; isn't converted to a Kotlin &lt;code&gt;MutableSet&lt;/code&gt;. To pass an object for Kotlin &lt;code&gt;MutableSet&lt;/code&gt;, you can create this kind of Kotlin collection explicitly by either creating it in Kotlin with e.g. &lt;code&gt;mutableSetOf()&lt;/code&gt;, or using the &lt;code&gt;KotlinMutableSet&lt;/code&gt; class in Swift (or &lt;code&gt;${prefix}MutableSet&lt;/code&gt; in Objective-C, where &lt;code&gt;prefix&lt;/code&gt; is the framework names prefix). The same holds for &lt;code&gt;MutableMap&lt;/code&gt;.</source>
          <target state="translated">Kotlin 콜렉션은 위 표에 설명 된대로 Swift / Objective-C 콜렉션으로 변환됩니다. Swift / Objective-C 콜렉션은 &lt;code&gt;NSMutableSet&lt;/code&gt; 및 &lt;code&gt;NSMutableDictionary&lt;/code&gt; 를 제외하고 동일한 방식으로 Kotlin에 맵핑됩니다 . &lt;code&gt;NSMutableSet&lt;/code&gt; 은 Kotlin &lt;code&gt;MutableSet&lt;/code&gt; 로 변환되지 않습니다 . 코 틀린에 대한 객체 전달하려면 &lt;code&gt;MutableSet&lt;/code&gt; 을 , 당신은 예와 코 틀린에 그것을 만드는 중 하나에 의해 명시 적으로 코 틀린 수집의이 종류를 만들 수 있습니다 &lt;code&gt;mutableSetOf()&lt;/code&gt; , 또는 사용 &lt;code&gt;KotlinMutableSet&lt;/code&gt; 의 스위프트 (또는에서 클래스를 &lt;code&gt;${prefix}MutableSet&lt;/code&gt; 오브젝티브 C에 &lt;code&gt;prefix&lt;/code&gt; 프레임 워크 이름 접두사입니다). 동일은을 위해 보유하고 &lt;code&gt;MutableMap&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b92ab48756ee9ee4eecd8b48a584a882c8254f38" translate="yes" xml:space="preserve">
          <source>Kotlin collections contain functions for commonly used &lt;em&gt;aggregate operations&lt;/em&gt; &amp;ndash; operations that return a single value based on the collection content. Most of them are well known and work the same way as they do in other languages:</source>
          <target state="translated">Kotlin 컬렉션에는 일반적으로 사용되는 &lt;em&gt;집계 작업 (&lt;/em&gt; 컬렉션 내용에 따라 단일 값을 반환하는 작업)을 위한 함수가 포함되어 있습니다. 대부분은 잘 알려져 있으며 다른 언어에서와 같은 방식으로 작동합니다.</target>
        </trans-unit>
        <trans-unit id="6f6ae7c2ed581955837fb7fe33d78ac601409b90" translate="yes" xml:space="preserve">
          <source>Kotlin collections provide a set of functions for retrieving single elements from collections. Functions described on this page apply to both lists and sets.</source>
          <target state="translated">Kotlin 모음은 모음에서 단일 요소를 검색하기위한 일련의 기능을 제공합니다. 이 페이지에 설명 된 기능은 목록과 세트 모두에 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="ba542c391d818d9d92362b069b9bf7f9bd8bf71d" translate="yes" xml:space="preserve">
          <source>Kotlin community is open, helpful, and welcoming. Don't hesitate to join and ask on any platform you like:</source>
          <target state="translated">코 틀린 커뮤니티는 개방적이고 도움이되고 환영하는 분위기입니다. 주저하지 말고 원하는 플랫폼에 가입하십시오.</target>
        </trans-unit>
        <trans-unit id="4e7553781e500e3864ae344f47e5a7328b499d62" translate="yes" xml:space="preserve">
          <source>Kotlin compiler generates normal JavaScript classes, functions and properties you can freely use from JavaScript code. Nevertheless, there are some subtle things you should remember.</source>
          <target state="translated">Kotlin 컴파일러는 JavaScript 코드에서 자유롭게 사용할 수있는 일반 JavaScript 클래스, 함수 및 속성을 생성합니다. 그럼에도 불구하고 기억해야 할 미묘한 것들이 있습니다.</target>
        </trans-unit>
        <trans-unit id="6a4e8f76fdd58bb0af9bcb56f7360e7af41cc619" translate="yes" xml:space="preserve">
          <source>Kotlin compiler produces byte-code, thus there really is no difference in terms of look and feel of Kotlin applications versus those written in Java.</source>
          <target state="translated">Kotlin 컴파일러는 바이트 코드를 생성하므로 Kotlin 응용 프로그램의 모양과 느낌과 Java로 작성된 것과의 차이점은 실제로 없습니다.</target>
        </trans-unit>
        <trans-unit id="254a81c2b10749e0ebcc71c56165e699f0faa1e8" translate="yes" xml:space="preserve">
          <source>Kotlin compiler specifics</source>
          <target state="translated">코 틀린 컴파일러 사양</target>
        </trans-unit>
        <trans-unit id="9aad08d33b38b295c66376049aa54dafe55e242e" translate="yes" xml:space="preserve">
          <source>Kotlin compiler would generate the following output</source>
          <target state="translated">Kotlin 컴파일러는 다음과 같은 출력을 생성합니다</target>
        </trans-unit>
        <trans-unit id="4e6a12781a358b0632ea318dc28241e7061cc96f" translate="yes" xml:space="preserve">
          <source>Kotlin constructors are imported as initializers to Swift/Objective-C.</source>
          <target state="translated">Kotlin 생성자는 초기화 자로 Swift / Objective-C로 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="fd097194728e7a8d4e414220f1c3adc66a1135aa" translate="yes" xml:space="preserve">
          <source>Kotlin documentation is a good place to start, check out these links to get your feet wet:</source>
          <target state="translated">Kotlin 설명서는 시작하기에 좋은 장소입니다. 발을 젖게하려면 다음 링크를 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="22a04b6935ed8f621d145360c7aea12d3366842f" translate="yes" xml:space="preserve">
          <source>Kotlin does not have Python's &lt;em&gt;resource managers&lt;/em&gt; or Java's &lt;em&gt;try-with-resources&lt;/em&gt;, but thanks to extension functions, there's &lt;code&gt;use&lt;/code&gt;:</source>
          <target state="translated">Kotlin에는 Python의 &lt;em&gt;리소스 관리자&lt;/em&gt; 또는 Java의 &lt;em&gt;try-with-resources&lt;/em&gt; 가 없지만 확장 기능 덕분에 다음과 같은 &lt;code&gt;use&lt;/code&gt; 가 있습니다 .</target>
        </trans-unit>
        <trans-unit id="8da11f04c1c3d7dbbef032228e63afa6f04d63f3" translate="yes" xml:space="preserve">
          <source>Kotlin does not have checked &lt;a href=&quot;exceptions&quot;&gt;exceptions&lt;/a&gt;</source>
          <target state="translated">코 틀린은 &lt;a href=&quot;exceptions&quot;&gt;예외를&lt;/a&gt; 확인하지 않았습니다</target>
        </trans-unit>
        <trans-unit id="58e8fc7ba9fc6ab7f17a343e98ca51e5a850e480" translate="yes" xml:space="preserve">
          <source>Kotlin does not have checked exceptions. There are many reasons for this, but we will provide a simple example.</source>
          <target state="translated">코 틀린은 예외를 확인하지 않았습니다. 여기에는 여러 가지 이유가 있지만 간단한 예를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="7ea8df84918172c874d6ce26a2d2ac8d56eff8a7" translate="yes" xml:space="preserve">
          <source>Kotlin does not implement lazy initialization of top-level properties in JavaScript.</source>
          <target state="translated">Kotlin은 JavaScript에서 최상위 속성의 지연 초기화를 구현하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="1c19ec6ca29946106579b7774a9f16c5845ebbc2" translate="yes" xml:space="preserve">
          <source>Kotlin ensures type safety of operations involving &lt;a href=&quot;generics&quot;&gt;generics&lt;/a&gt; at compile time, while, at runtime, instances of generic types hold no information about their actual type arguments. For example, &lt;code&gt;List&amp;lt;Foo&amp;gt;&lt;/code&gt; is erased to just &lt;code&gt;List&amp;lt;*&amp;gt;&lt;/code&gt;. In general, there is no way to check whether an instance belongs to a generic type with certain type arguments at runtime.</source>
          <target state="translated">Kotlin은 컴파일 타임에 &lt;a href=&quot;generics&quot;&gt;제네릭&lt;/a&gt; 과 관련된 연산의 형식 안전성을 보장 하는 반면 런타임에 제네릭 형식의 인스턴스에는 실제 형식 인수에 대한 정보가 없습니다. 예를 들어 &lt;code&gt;List&amp;lt;Foo&amp;gt;&lt;/code&gt; 는 &lt;code&gt;List&amp;lt;*&amp;gt;&lt;/code&gt; 로만 지워집니다 . 일반적으로 인스턴스가 런타임에 특정 형식 인수를 사용하여 제네릭 형식에 속하는지 확인할 수있는 방법이 없습니다.</target>
        </trans-unit>
        <trans-unit id="bbcaf4c7dfc1607eaa4b2ffde25fea37b6fff50b" translate="yes" xml:space="preserve">
          <source>Kotlin exposes its package structure to JavaScript, so unless you define your declarations in the root package, you have to use fully-qualified names in JavaScript. For example:</source>
          <target state="translated">Kotlin은 패키지 구조를 JavaScript에 공개하므로 루트 패키지에 선언을 정의하지 않으면 JavaScript에서 정규화 된 이름을 사용해야합니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="6bd032e19c9c721a60ec9014384d50331ee1d338" translate="yes" xml:space="preserve">
          <source>Kotlin fixes a series of issues that Java suffers from:</source>
          <target state="translated">Kotlin은 Java로 인해 발생하는 일련의 문제를 해결합니다.</target>
        </trans-unit>
        <trans-unit id="2e70b9b4257b183b5c7e10570483451ad725fc8a" translate="yes" xml:space="preserve">
          <source>Kotlin follows the Java naming conventions. In particular:</source>
          <target state="translated">Kotlin은 Java 명명 규칙을 따릅니다. 특히:</target>
        </trans-unit>
        <trans-unit id="0548deb8694e8bfa87792c4e732edf938085eb1e" translate="yes" xml:space="preserve">
          <source>Kotlin for Android Case Studies</source>
          <target state="translated">Android 사례 연구를위한 Kotlin</target>
        </trans-unit>
        <trans-unit id="c1441b497e656bddb290de8de9224360e00ecbdf" translate="yes" xml:space="preserve">
          <source>Kotlin for Android Developers</source>
          <target state="translated">안드로이드 개발자를위한 코 틀린</target>
        </trans-unit>
        <trans-unit id="7b2f1c8edda5c1d58bf2a573a1626581c631617c" translate="yes" xml:space="preserve">
          <source>Kotlin for Java Developers</source>
          <target state="translated">Java 개발자를위한 Kotlin</target>
        </trans-unit>
        <trans-unit id="fe6b04ae909883df5d80ca51aec87a07bb290e41" translate="yes" xml:space="preserve">
          <source>Kotlin function-typed objects (e.g. lambdas) are converted to Swift functions / Objective-C blocks. However there is a difference in how types of parameters and return values are mapped when translating a function and a function type. In the latter case primitive types are mapped to their boxed representation. Kotlin &lt;code&gt;Unit&lt;/code&gt; return value is represented as a corresponding &lt;code&gt;Unit&lt;/code&gt; singleton in Swift/Objective-C. The value of this singleton can be retrieved in the same way as it is for any other Kotlin &lt;code&gt;object&lt;/code&gt; (see singletons in the table above). To sum the things up:</source>
          <target state="translated">Kotlin 함수 유형 객체 (예 : 람다)는 Swift 함수 / Objective-C 블록으로 변환됩니다. 그러나 함수와 함수 유형을 변환 할 때 매개 변수 유형과 반환 값이 매핑되는 방식에 차이가 있습니다. 후자의 경우 기본 유형이 상자 표시로 맵핑됩니다. 코 틀린 &lt;code&gt;Unit&lt;/code&gt; 반환 값은 Swift / Objective-C에서 해당 &lt;code&gt;Unit&lt;/code&gt; 싱글 톤 으로 표시됩니다 . 이 싱글 톤의 값은 다른 Kotlin &lt;code&gt;object&lt;/code&gt; 와 동일한 방식으로 검색 할 수 있습니다 (위의 싱글 톤 참조). 정리하면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="6377c81eb40cd3205e240b814a78f31b9c3b2c4e" translate="yes" xml:space="preserve">
          <source>Kotlin functions are &lt;a href=&quot;https://en.wikipedia.org/wiki/First-class_function&quot;&gt;&lt;em&gt;first-class&lt;/em&gt;&lt;/a&gt;, which means that they can be stored in variables and data structures, passed as arguments to and returned from other &lt;a href=&quot;#higher-order-functions&quot;&gt;higher-order functions&lt;/a&gt;. You can operate with functions in any way that is possible for other non-function values.</source>
          <target state="translated">Kotlin 함수는 &lt;a href=&quot;https://en.wikipedia.org/wiki/First-class_function&quot;&gt;&lt;em&gt;일류&lt;/em&gt;&lt;/a&gt; 이므로 변수 및 데이터 구조에 저장하고 인수로 전달하여 다른 &lt;a href=&quot;#higher-order-functions&quot;&gt;고차 함수&lt;/a&gt; 에서 반환 할 수 있습니다 . 다른 비 기능적 값에 대해 가능한 방식으로 기능으로 조작 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="06212cca9855d4bc50a6216a937f6da059a9c0cc" translate="yes" xml:space="preserve">
          <source>Kotlin generate JavaScript code that is compatible with Asynchronous Module Definition (AMD), CommonJS and Universal Model Definition (UMD).</source>
          <target state="translated">Kotlin은 AMD (Asynchronous Module Definition), CommonJS 및 UMD (Universal Model Definition)와 호환되는 JavaScript 코드를 생성합니다.</target>
        </trans-unit>
        <trans-unit id="7e3d5465bac3e356284fe278ce3583ae2129ce4a" translate="yes" xml:space="preserve">
          <source>Kotlin handles numbers in a way close to Java, but not exactly the same. For example, there are no implicit widening conversions for numbers, and literals are slightly different in some cases.</source>
          <target state="translated">Kotlin은 Java와 비슷한 방식으로 숫자를 처리하지만 정확히 동일하지는 않습니다. 예를 들어, 숫자에 대한 암시 적 확장 변환은 없으며 경우에 따라 리터럴이 약간 다릅니다.</target>
        </trans-unit>
        <trans-unit id="a419931ca3da367222b771f7660e3ff6428af9ed" translate="yes" xml:space="preserve">
          <source>Kotlin has a rather small runtime file size: the library is approximately 964KB (as of 1.3.41). This means Kotlin adds just a little to .apk file size.</source>
          <target state="translated">Kotlin은 런타임 파일 크기가 다소 작습니다. 라이브러리는 약 964KB입니다 (1.3.41 기준). 이것은 Kotlin이 .apk 파일 크기에 약간을 추가한다는 것을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="1a3e60d485f88e60187d3caa5025c740961ab3aa" translate="yes" xml:space="preserve">
          <source>Kotlin has an extensive standard library that can be used in your applications. Configure the following dependency in the pom file:</source>
          <target state="translated">Kotlin에는 응용 프로그램에서 사용할 수있는 광범위한 표준 라이브러리가 있습니다. pom 파일에서 다음 종속성을 구성하십시오.</target>
        </trans-unit>
        <trans-unit id="ab1e60d19725004dca25a2263f17ef1cdb84890e" translate="yes" xml:space="preserve">
          <source>Kotlin has been successfully adopted by major companies, and a few of them have shared their experiences:</source>
          <target state="translated">Kotlin은 주요 회사에서 성공적으로 채택되었으며 그 중 일부는 다음과 같은 경험을 공유했습니다.</target>
        </trans-unit>
        <trans-unit id="3ed9d85f3169bc5321f12531a1c541d127d00550" translate="yes" xml:space="preserve">
          <source>Kotlin has both object-oriented and functional constructs. You can use it in both OO and FP styles, or mix elements of the two. With first-class support for features such as higher-order functions, function types and lambdas, Kotlin is a great choice if you&amp;rsquo;re doing or exploring functional programming.</source>
          <target state="translated">Kotlin은 객체 지향 및 기능적 구성을 모두 가지고 있습니다. OO 및 FP 스타일 모두에서 사용하거나 두 가지 요소를 혼합하여 사용할 수 있습니다. 고차 함수, 함수 유형 및 람다와 같은 기능을 일류 지원하는 Kotlin은 함수형 프로그래밍을 수행하거나 탐색 할 때 탁월한 선택입니다.</target>
        </trans-unit>
        <trans-unit id="d0b80a6eafa346308b4f2ffbb72d503567999d28" translate="yes" xml:space="preserve">
          <source>Kotlin has classes and their members &lt;code&gt;final&lt;/code&gt; by default, which makes it inconvenient to use frameworks and libraries such as Spring AOP that require classes to be &lt;code&gt;open&lt;/code&gt;. The &lt;em&gt;all-open&lt;/em&gt; compiler plugin adapts Kotlin to the requirements of those frameworks and makes classes annotated with a specific annotation and their members open without the explicit &lt;code&gt;open&lt;/code&gt; keyword.</source>
          <target state="translated">Kotlin은 기본적으로 클래스와 멤버를 &lt;code&gt;final&lt;/code&gt; 으로 가지고 있으므로 클래스를 &lt;code&gt;open&lt;/code&gt; 하는 Spring AOP와 같은 프레임 워크와 라이브러리를 사용하는 것이 불편합니다 . &lt;em&gt;모든 오픈&lt;/em&gt; 컴파일러 플러그인은 그 프레임 워크의 요구 사항에 코 틀린 적응하고 특정 주석을 주석 수업을하고 자신의 회원은 명시하지 않고 열 &lt;code&gt;open&lt;/code&gt; 키워드.</target>
        </trans-unit>
        <trans-unit id="b816faaaa048d52b55167846f58533c82dcf332c" translate="yes" xml:space="preserve">
          <source>Kotlin has got its own reflection library (&lt;code&gt;kotlin-reflect.jar&lt;/code&gt; must be included in your build). When targeting the JVM, you can also use the Java reflection facilities. Note that the Kotlin reflection isn't quite feature-complete yet - in particular, you can't use it to inspect built-in classes like &lt;code&gt;String&lt;/code&gt;.</source>
          <target state="translated">Kotlin은 자체 리플렉션 라이브러리를 가지고 있습니다 ( &lt;code&gt;kotlin-reflect.jar&lt;/code&gt; 는 빌드에 포함되어야합니다). JVM을 대상으로 할 때 Java 리플렉션 기능을 사용할 수도 있습니다. Kotlin 리플렉션은 아직 완전히 완성되지 않았으므로 특히 &lt;code&gt;String&lt;/code&gt; 과 같은 내장 클래스를 검사하는 데 사용할 수 없습니다 .</target>
        </trans-unit>
        <trans-unit id="89599a2b8afb959091521970edd698c7f8696cca" translate="yes" xml:space="preserve">
          <source>Kotlin has inherited Java's fidgety (but very flexible) way of doing I/O, but with some simplifying extra features. We won't get into all of it here, so for starters, this is how to iterate through all the lines of a file (you'll need &lt;code&gt;import java.io.File&lt;/code&gt;):</source>
          <target state="translated">Kotlin은 Java의 fidgety (그러나 매우 융통성있는) I / O 방식을 물려 받았지만 몇 가지 간단한 기능을 추가했습니다. 우리는 여기에 모든 것을 넣지 않을 것이므로 우선 초보자를 위해 파일의 모든 줄을 반복하는 방법입니다 ( &lt;code&gt;import java.io.File&lt;/code&gt; 이 필요합니다 ).</target>
        </trans-unit>
        <trans-unit id="789ece85cba2d7c5232dc414bc11dc159641da4f" translate="yes" xml:space="preserve">
          <source>Kotlin has inherited Java's fidgety array system, so primitive types have got their own array types and conversion functions, while any other type uses the generic &lt;code&gt;Array&lt;/code&gt; type, to which you can convert with &lt;code&gt;.toTypedArray()&lt;/code&gt;.</source>
          <target state="translated">Kotlin은 Java의 fidgety 배열 시스템을 상속 받았으므로 기본 유형에는 자체 배열 유형 및 변환 함수가 있으며 다른 유형은 일반 &lt;code&gt;Array&lt;/code&gt; 유형을 사용하며 &lt;code&gt;.toTypedArray()&lt;/code&gt; 로 변환 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="2e626b593df468862004f3cb251d2e1710f0e139" translate="yes" xml:space="preserve">
          <source>Kotlin has no concept of checked exceptions, all Kotlin exceptions are unchecked. Swift has only checked errors. So if Swift or Objective-C code calls a Kotlin method which throws an exception to be handled, then the Kotlin method should be marked with a &lt;code&gt;@Throws&lt;/code&gt; annotation. In this case all Kotlin exceptions (except for instances of &lt;code&gt;Error&lt;/code&gt;, &lt;code&gt;RuntimeException&lt;/code&gt; and subclasses) are translated into a Swift error/&lt;code&gt;NSError&lt;/code&gt;.</source>
          <target state="translated">Kotlin에는 확인 된 예외 개념이 없으며 모든 Kotlin 예외는 선택되지 않습니다. Swift는 오류를 확인했습니다. 따라서 Swift 또는 Objective-C 코드가 처리 할 예외를 발생시키는 Kotlin 메소드를 호출하면 Kotlin 메소드에 &lt;code&gt;@Throws&lt;/code&gt; 주석 이 표시되어야합니다 . 이 경우 모든 Kotlin 예외 ( &lt;code&gt;Error&lt;/code&gt; , &lt;code&gt;RuntimeException&lt;/code&gt; 및 서브 클래스 제외)는 Swift error / &lt;code&gt;NSError&lt;/code&gt; 로 변환됩니다 .</target>
        </trans-unit>
        <trans-unit id="178ebff753223a76976f1b5505609a06e7a0941e" translate="yes" xml:space="preserve">
          <source>Kotlin has now the option of generating Java 8 bytecode (&lt;code&gt;-jvm-target 1.8&lt;/code&gt; command line option or the corresponding options in Ant/Maven/Gradle). For now this doesn't change the semantics of the bytecode (in particular, default methods in interfaces and lambdas are generated exactly as in Kotlin 1.0), but we plan to make further use of this later.</source>
          <target state="translated">Kotlin은 이제 Java 8 바이트 코드 ( &lt;code&gt;-jvm-target 1.8&lt;/code&gt; 명령 행 옵션 또는 Ant / Maven / Gradle의 해당 옵션)를 생성 할 수 있습니다. 지금은 바이트 코드의 의미를 변경하지 않지만 (특히 인터페이스와 람다의 기본 메소드는 Kotlin 1.0에서와 동일하게 생성됩니다) 나중에이를 더 많이 사용할 계획입니다.</target>
        </trans-unit>
        <trans-unit id="1b256a14cb898b1876ca682918ab4726ae689547" translate="yes" xml:space="preserve">
          <source>Kotlin has proper &lt;a href=&quot;lambdas#function-types&quot;&gt;function types&lt;/a&gt;, as opposed to Java's SAM-conversions</source>
          <target state="translated">Kotlin은 Java의 SAM 변환과 달리 적절한 &lt;a href=&quot;lambdas#function-types&quot;&gt;함수 유형을&lt;/a&gt; 가지고 있습니다 .</target>
        </trans-unit>
        <trans-unit id="21d65ae753898818d1cd1395d2b3d50ce49c4d34" translate="yes" xml:space="preserve">
          <source>Kotlin has three structural jump expressions:</source>
          <target state="translated">코 틀린에는 세 가지 구조적 점프 표현이 있습니다.</target>
        </trans-unit>
        <trans-unit id="8fab1b92010786ac4e42e500d9dbd613684af3aa" translate="yes" xml:space="preserve">
          <source>Kotlin has two types of string literals: escaped strings that may have escaped characters in them and raw strings that can contain newlines and arbitrary text. An escaped string is very much like a Java string:</source>
          <target state="translated">Kotlin에는 두 가지 유형의 문자열 리터럴이 있습니다. 이스케이프 된 문자가 포함 된 이스케이프 된 문자열과 줄 바꿈 및 임의의 텍스트를 포함 할 수있는 원시 문자열입니다. 이스케이프 된 문자열은 Java 문자열과 매우 유사합니다.</target>
        </trans-unit>
        <trans-unit id="7c53d6c43db7159858e1b06d40910057344f857d" translate="yes" xml:space="preserve">
          <source>Kotlin in Action</source>
          <target state="translated">코 틀린의 행동</target>
        </trans-unit>
        <trans-unit id="897dddb8bded8aacac7c4f7f6865ba43edeed083" translate="yes" xml:space="preserve">
          <source>Kotlin introduces following types for unsigned integers:</source>
          <target state="translated">Kotlin은 부호없는 정수에 대해 다음 유형을 소개합니다.</target>
        </trans-unit>
        <trans-unit id="1162e3ef7e5343b47c0a5de3586b0dd6d01591ce" translate="yes" xml:space="preserve">
          <source>Kotlin is a compiled, statically typed language, which might provide some initial hurdles for people who are used to the interpreted, dynamically typed Python. This document aims to explain a substantial portion of Kotlin's syntax and concepts in terms of how they compare to corresponding concepts in Python.</source>
          <target state="translated">코 틀린 (Kotlin)은 정적으로 형식화 된 컴파일 된 언어로, 해석되고 동적으로 형식화 된 파이썬에 익숙한 사람들에게 약간의 초기 장애를 제공 할 수 있습니다. 이 문서는 Kotlin의 구문과 개념 중 상당 부분을 Python의 해당 개념과 비교하는 방식으로 설명합니다.</target>
        </trans-unit>
        <trans-unit id="640ddadf7e88f55374061d5998c2bee5a53626f4" translate="yes" xml:space="preserve">
          <source>Kotlin is a great fit for developing Android applications, bringing all of the advantages of a modern language to the Android platform without introducing any new restrictions:</source>
          <target state="translated">Kotlin은 Android 애플리케이션 개발에 매우 ​​적합하며 새로운 제한을 도입하지 않고도 현대 언어의 모든 장점을 Android 플랫폼에 제공합니다.</target>
        </trans-unit>
        <trans-unit id="b1f1b3f12f705373f46ad38b06f457675f0bb145" translate="yes" xml:space="preserve">
          <source>Kotlin is a great fit for developing server-side applications, allowing you to write concise and expressive code while maintaining full compatibility with existing Java-based technology stacks and a smooth learning curve:</source>
          <target state="translated">Kotlin은 서버 측 애플리케이션 개발에 적합하여 간결하고 표현력있는 코드를 작성하는 동시에 기존 Java 기반 기술 스택과의 완벽한 호환성과 원활한 학습 곡선을 유지할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="942fb98d86e153b0e83fe0d61de04cbccacbe8f7" translate="yes" xml:space="preserve">
          <source>Kotlin is a pragmatic and unopinionated language, supporting both imperative and function programming styles without pushing the developer towards either one. We can implement the function &lt;code&gt;f&lt;/code&gt; in functional style, using such Kotlin features as &lt;a href=&quot;../reference/functions#tail-recursive-functions&quot;&gt;tail recursion&lt;/a&gt;:</source>
          <target state="translated">코 틀린 (Kotlin)은 실용적이면서도 비언어적 인 언어로, 개발자를 어느쪽으로 든 강요하지 않고 명령형 및 함수형 프로그래밍 스타일을 모두 지원합니다. &lt;a href=&quot;../reference/functions#tail-recursive-functions&quot;&gt;꼬리 재귀&lt;/a&gt; 와 같은 Kotlin 기능을 사용하여 함수 &lt;code&gt;f&lt;/code&gt; 를 함수 스타일로 구현할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="f033af0ab747811276c086c79a9bfc947c92c7d6" translate="yes" xml:space="preserve">
          <source>Kotlin is an OSS statically typed programming language that targets the JVM, Android, JavaScript and Native. It&amp;rsquo;s developed by &lt;a href=&quot;http://www.jetbrains.com&quot;&gt;JetBrains&lt;/a&gt;. The project started in 2010 and was open source from very early on. The first official 1.0 release was in February 2016.</source>
          <target state="translated">Kotlin은 JVM, Android, JavaScript 및 Native를 대상으로하는 OSS 정적 유형의 프로그래밍 언어입니다. &lt;a href=&quot;http://www.jetbrains.com&quot;&gt;JetBrains에&lt;/a&gt; 의해 개발되었습니다 . 이 프로젝트는 2010 년에 시작되었으며 초기부터 오픈 소스였습니다. 최초의 공식 1.0 릴리스는 2016 년 2 월입니다.</target>
        </trans-unit>
        <trans-unit id="d9537d803964341dc28f1f4951da5b348b7b611e" translate="yes" xml:space="preserve">
          <source>Kotlin is compatible with CommonJS, AMD and UMD, &lt;a href=&quot;../tutorials/javascript/working-with-modules/working-with-modules&quot;&gt;making interaction with different&lt;/a&gt; module systems straightforward.</source>
          <target state="translated">Kotlin은 CommonJS, AMD 및 UMD와 호환되므로 &lt;a href=&quot;../tutorials/javascript/working-with-modules/working-with-modules&quot;&gt;다른&lt;/a&gt; 모듈 시스템 과 쉽게 상호 작용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2c3ca5bc7aa971f25976aff86462ee8c65c9cb7e" translate="yes" xml:space="preserve">
          <source>Kotlin is designed to be a pragmatic tool for programmers. When it comes to language evolution, its pragmatic nature is captured by the following principles:</source>
          <target state="translated">Kotlin은 프로그래머를위한 실용적인 도구로 설계되었습니다. 언어 진화와 관련하여 실용적인 특성은 다음과 같은 원칙에 의해 포착됩니다.</target>
        </trans-unit>
        <trans-unit id="93c08e581c43a4ec4822d841d4ddc6b6324821eb" translate="yes" xml:space="preserve">
          <source>Kotlin is designed to be easy to learn for people who already know Java. A quick overview of differences is given on &lt;a href=&quot;../reference/comparison-to-java&quot;&gt;the official comparison page&lt;/a&gt;. A short introduction to the basic syntax of Kotlin for software developers can be found directly in the reference section of the web site starting from &lt;a href=&quot;../reference/basic-syntax&quot;&gt;basic syntax&lt;/a&gt;.</source>
          <target state="translated">Kotlin은 Java를 이미 알고있는 사람들이 쉽게 배울 수 있도록 설계되었습니다. 차이점에 대한 빠른 개요 &lt;a href=&quot;../reference/comparison-to-java&quot;&gt;는 공식 비교 페이지에서 제공&lt;/a&gt; 됩니다. 소프트웨어 개발자를위한 코 틀린의 기본 구문에 대한 짧은 소개가 시작 웹 사이트의 참조 섹션에서 직접 확인할 수 있습니다 &lt;a href=&quot;../reference/basic-syntax&quot;&gt;기본 구문&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="76527281e23251ab9b22562a01f9e2381d26e878" translate="yes" xml:space="preserve">
          <source>Kotlin is designed with Java Interoperability in mind. Existing Java code can be called from Kotlin in a natural way, and Kotlin code can be used from Java rather smoothly as well. In this section we describe some details about calling Java code from Kotlin.</source>
          <target state="translated">Kotlin은 Java 상호 운용성을 염두에두고 설계되었습니다. 기존 Java 코드는 자연스러운 방식으로 Kotlin에서 호출 할 수 있으며 Kotlin 코드는 Java에서도 원활하게 사용할 수 있습니다. 이 섹션에서는 Kotlin에서 Java 코드 호출에 대한 세부 사항을 설명합니다.</target>
        </trans-unit>
        <trans-unit id="b1117330525358e715dea7a8875981cd28a616bf" translate="yes" xml:space="preserve">
          <source>Kotlin is distributed with &lt;code&gt;kotlin.js&lt;/code&gt; standard library as a single file, which is itself compiled as an UMD module, so you can use it with any module system described above. Also it is available on NPM as &lt;a href=&quot;https://www.npmjs.com/package/kotlin&quot;&gt;&lt;code&gt;kotlin&lt;/code&gt; package&lt;/a&gt;</source>
          <target state="translated">Kotlin은 &lt;code&gt;kotlin.js&lt;/code&gt; 표준 라이브러리와 함께 단일 파일로 배포되며 ,이 파일은 자체적으로 UMD 모듈로 컴파일되므로 위에서 설명한 모든 모듈 시스템과 함께 사용할 수 있습니다. 또한 NPM에서 &lt;a href=&quot;https://www.npmjs.com/package/kotlin&quot;&gt; &lt;code&gt;kotlin&lt;/code&gt; &lt;/a&gt; 패키지 로 제공 됩니다.</target>
        </trans-unit>
        <trans-unit id="0bb12b617173b78ae2213fea703120a48dac83b8" translate="yes" xml:space="preserve">
          <source>Kotlin is inspired by existing languages such as Java, C#, JavaScript, Scala and Groovy. We've tried to ensure that Kotlin is easy to learn, so that people can easily jump on board, reading and writing Kotlin in a matter of days. Learning idiomatic Kotlin and using some more of its advanced features can take a little longer, but overall it is not a complicated language.</source>
          <target state="translated">Kotlin은 Java, C #, JavaScript, Scala 및 Groovy와 같은 기존 언어에서 영감을 얻었습니다. 우리는 Kotlin이 배우기 쉽도록 노력하여 사람들이 며칠 만에 Kotlin을 쉽게 읽고 쓸 수 있습니다. 관용적 코 틀린을 배우고 더 많은 고급 기능을 사용하는 데는 시간이 조금 더 걸릴 수 있지만 전반적으로 복잡한 언어는 아닙니다.</target>
        </trans-unit>
        <trans-unit id="62c8094d2f49ea185993571453009f8f90b8b387" translate="yes" xml:space="preserve">
          <source>Kotlin is more concise. Rough estimates indicate approximately a 40% cut in the number of lines of code. It&amp;rsquo;s also more type-safe, e.g. support for non-nullable types makes applications less prone to NPE&amp;rsquo;s. Other features including smart casting, higher-order functions, extension functions and lambdas with receivers provide the ability to write expressive code as well as facilitating creation of DSL.</source>
          <target state="translated">코 틀린이 더 간결합니다. 대략적인 추정치에 따르면 코드 줄 수가 약 40 % 줄었습니다. 또한 형식이 더 안전합니다. 예를 들어 널 입력 불가능 유형을 지원하면 응용 프로그램이 NPE에 덜 취약합니다. 스마트 캐스팅, 고차 함수, 확장 기능 및 수신기가있는 람다를 포함한 다른 기능은 표현 코드를 작성하는 기능을 제공 할뿐만 아니라 DSL 작성을 용이하게합니다.</target>
        </trans-unit>
        <trans-unit id="8a6891160d562ed8798489fdde041cf7382a9267" translate="yes" xml:space="preserve">
          <source>Kotlin is primarily developed by a team of engineers at JetBrains (current team size is 50+). The lead language designer is &lt;a href=&quot;https://twitter.com/abreslav&quot;&gt;Andrey Breslav&lt;/a&gt;. In addition to the core team, there are also over 250 external contributors on GitHub.</source>
          <target state="translated">Kotlin은 주로 JetBrains (현재 팀 규모는 50+)의 엔지니어 팀에 의해 개발되었습니다. 주요 언어 디자이너는 &lt;a href=&quot;https://twitter.com/abreslav&quot;&gt;Andrey Breslav&lt;/a&gt; 입니다. 핵심 팀 외에도 GitHub에는 250 명 이상의 외부 기고자가 있습니다.</target>
        </trans-unit>
        <trans-unit id="e252e4cd43e2222ef996694efabbf2a368b1568c" translate="yes" xml:space="preserve">
          <source>Kotlin is supported by all major Java IDEs including &lt;a href=&quot;../tutorials/getting-started&quot;&gt;IntelliJ IDEA&lt;/a&gt;, &lt;a href=&quot;../tutorials/kotlin-android&quot;&gt;Android Studio&lt;/a&gt;, &lt;a href=&quot;../tutorials/getting-started-eclipse&quot;&gt;Eclipse&lt;/a&gt; and &lt;a href=&quot;http://plugins.netbeans.org/plugin/68590/kotlin&quot;&gt;NetBeans&lt;/a&gt;. In addition, a &lt;a href=&quot;../tutorials/command-line&quot;&gt;command line compiler&lt;/a&gt; is available and provides straightforward support for compiling and running applications.</source>
          <target state="translated">Kotlin은 &lt;a href=&quot;../tutorials/getting-started&quot;&gt;IntelliJ IDEA&lt;/a&gt; , &lt;a href=&quot;../tutorials/kotlin-android&quot;&gt;Android Studio&lt;/a&gt; , &lt;a href=&quot;../tutorials/getting-started-eclipse&quot;&gt;Eclipse&lt;/a&gt; 및 &lt;a href=&quot;http://plugins.netbeans.org/plugin/68590/kotlin&quot;&gt;NetBeans를&lt;/a&gt; 포함한 모든 주요 Java IDE에서 지원됩니다 . 또한 &lt;a href=&quot;../tutorials/command-line&quot;&gt;명령 줄 컴파일러&lt;/a&gt; 를 사용할 수 있으며 응용 프로그램을 컴파일하고 실행하기위한 간단한 지원을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="38b8eb152c426ee3fe939706153705b8354595aa" translate="yes" xml:space="preserve">
          <source>Kotlin is well covered in online courses, check out recommended courses here:</source>
          <target state="translated">Kotlin은 온라인 과정을 잘 다루고 있습니다. 여기에서 권장 과정을 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="47b75c21f1512e55023917a6b77552862460e120" translate="yes" xml:space="preserve">
          <source>Kotlin lets you easily create ranges of values using the &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.ranges/range-to&quot;&gt;&lt;code&gt;rangeTo()&lt;/code&gt;&lt;/a&gt; function from the &lt;code&gt;kotlin.ranges&lt;/code&gt; package and its operator form &lt;code&gt;..&lt;/code&gt;. Usually, &lt;code&gt;rangeTo()&lt;/code&gt; is complemented by &lt;code&gt;in&lt;/code&gt; or &lt;code&gt;!in&lt;/code&gt; functions.</source>
          <target state="translated">코 틀린은 쉽게 사용 값 범위 만들 수 &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.ranges/range-to&quot;&gt; &lt;code&gt;rangeTo()&lt;/code&gt; &lt;/a&gt; 로부터 기능 &lt;code&gt;kotlin.ranges&lt;/code&gt; 의 패키지와 연산자 형태 &lt;code&gt;..&lt;/code&gt; . 일반적으로 &lt;code&gt;rangeTo()&lt;/code&gt; 는 &lt;code&gt;in&lt;/code&gt; 또는 &lt;code&gt;!in&lt;/code&gt; 함수로 보완됩니다 .</target>
        </trans-unit>
        <trans-unit id="ceee386e40b3b46c69160d750c22ce62d0c3f184" translate="yes" xml:space="preserve">
          <source>Kotlin lets you manipulate collections independently of the exact type of objects stored in them. In other words, you add a &lt;code&gt;String&lt;/code&gt; to a list of &lt;code&gt;String&lt;/code&gt;s the same way as you would do with &lt;code&gt;Int&lt;/code&gt;s or a user-defined class. So, the Kotlin Standard Library offers generic interfaces, classes, and functions for creating, populating, and managing collections of any type.</source>
          <target state="translated">Kotlin을 사용하면 컬렉션에 저장된 정확한 유형의 개체와 독립적으로 컬렉션을 조작 할 수 있습니다. 즉, 당신은 추가 &lt;code&gt;String&lt;/code&gt; 의 목록에 &lt;code&gt;String&lt;/code&gt; 당신이 할 것 같은의 같은 방식으로 &lt;code&gt;Int&lt;/code&gt; 의 또는 사용자 정의 클래스입니다. 따라서 Kotlin 표준 라이브러리는 모든 유형의 콜렉션을 작성, 채우기 및 관리하기위한 일반 인터페이스, 클래스 및 함수를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="8bb9f52709d9b5cdac5f51755d862ecbca9c415c" translate="yes" xml:space="preserve">
          <source>Kotlin metadata</source>
          <target state="translated">코 틀린 메타 데이터</target>
        </trans-unit>
        <trans-unit id="0e7ef1544d45f6a307acf242d3ddb29c611697ae" translate="yes" xml:space="preserve">
          <source>Kotlin modules can be used in Swift/Objective-C code if compiled into a framework (see &quot;Targets and output kinds&quot; section in &lt;a href=&quot;gradle_plugin#targets-and-output-kinds&quot;&gt;Gradle plugin documentation&lt;/a&gt;). See &lt;a href=&quot;https://github.com/JetBrains/kotlin-native/tree/master/samples/calculator&quot;&gt;calculator sample&lt;/a&gt; for an example.</source>
          <target state="translated">Kotlin 모듈은 프레임 워크로 컴파일 된 경우 Swift / Objective-C 코드에서 사용될 수 있습니다 ( &lt;a href=&quot;gradle_plugin#targets-and-output-kinds&quot;&gt;Gradle 플러그인 설명서의&lt;/a&gt; &quot;대상 및 출력 종류&quot;섹션 참조 ). &lt;a href=&quot;https://github.com/JetBrains/kotlin-native/tree/master/samples/calculator&quot;&gt;예제&lt;/a&gt; 는 계산기 샘플 을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="a0c9d0d836710fc155aae7ff2099c119f8b8ff3b" translate="yes" xml:space="preserve">
          <source>Kotlin now integrates with the &lt;a href=&quot;https://docs.oracle.com/javase/8/docs/api/javax/script/package-summary.html&quot;&gt;javax.script API&lt;/a&gt; (JSR-223). The API allows to evaluate snippets of code at runtime:</source>
          <target state="translated">Kotlin은 이제 &lt;a href=&quot;https://docs.oracle.com/javase/8/docs/api/javax/script/package-summary.html&quot;&gt;javax.script API&lt;/a&gt; (JSR-223) 와 통합됩니다 . API를 사용하면 런타임시 코드 스 니펫을 평가할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5917b5d1de587466aad2c24c7e35497e2343f72e" translate="yes" xml:space="preserve">
          <source>Kotlin now supports storing parameter names in the bytecode. This can be enabled using the &lt;code&gt;-java-parameters&lt;/code&gt; command line option.</source>
          <target state="translated">Kotlin은 이제 바이트 코드에 매개 변수 이름 저장을 지원합니다. &lt;code&gt;-java-parameters&lt;/code&gt; 명령 행 옵션을 사용하여 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="900f5e70ca199686eb62d660ad48f2ce1610ab30" translate="yes" xml:space="preserve">
          <source>Kotlin numeric types, except for &lt;code&gt;kotlin.Long&lt;/code&gt; are mapped to JavaScript Number.</source>
          <target state="translated">&lt;code&gt;kotlin.Long&lt;/code&gt; 을 제외한 Kotlin 숫자 유형 은 JavaScript 숫자에 매핑됩니다.</target>
        </trans-unit>
        <trans-unit id="fa0f528e5b1ad066646e40d867c682edc345e3d1" translate="yes" xml:space="preserve">
          <source>Kotlin objects could be pinned, i.e. their position in memory is guaranteed to be stable until unpinned, and pointers to such objects inner data could be passed to the C functions. For example</source>
          <target state="translated">Kotlin 객체는 고정 될 수 있습니다. 즉, 메모리에서 해당 위치는 고정되지 않을 때까지 안정적으로 유지되며 이러한 객체 내부 데이터에 대한 포인터는 C 함수로 전달 될 수 있습니다. 예를 들어</target>
        </trans-unit>
        <trans-unit id="23971a8580dfc32441ac3140ce5ff12ac8ef11bf" translate="yes" xml:space="preserve">
          <source>Kotlin plugin 1.3.21 or higher should be installed in the IDE. This can be verified via &lt;em&gt;Language &amp;amp; Frameworks | Kotlin Updates&lt;/em&gt; section in the &lt;em&gt;Settings&lt;/em&gt; (or &lt;em&gt;Preferences&lt;/em&gt;) of the IDE.</source>
          <target state="translated">Kotlin 플러그인 1.3.21 이상이 IDE에 설치되어 있어야합니다. &lt;em&gt;언어 및 프레임 워크&lt;/em&gt; 를 통해 확인할 수 있습니다. &lt;em&gt;| &lt;/em&gt;IDE 의 &lt;em&gt;설정&lt;/em&gt; (또는 &lt;em&gt;환경 설정&lt;/em&gt; )의 &lt;em&gt;Kotlin 업데이트&lt;/em&gt; 섹션</target>
        </trans-unit>
        <trans-unit id="446a5a46278f3d1273d1c8d81bcdc944823353d2" translate="yes" xml:space="preserve">
          <source>Kotlin plugin for IntelliJ IDEA supports &lt;a href=&quot;https://www.jetbrains.com/help/idea/scratches.html&quot;&gt;scratches&lt;/a&gt;. Scratches let you create code drafts in the same IDE window with your project and run them on the fly. Scratches are not tied to projects; you can access and run all your scratches from any IntelliJ IDEA window on your OS.</source>
          <target state="translated">IntelliJ IDEA 용 Kotlin 플러그인은 &lt;a href=&quot;https://www.jetbrains.com/help/idea/scratches.html&quot;&gt;스크래치를&lt;/a&gt; 지원합니다 . 스크래치를 사용하면 프로젝트와 동일한 IDE 창에서 코드 드래프트를 작성하여 즉시 실행할 수 있습니다. 흠집은 프로젝트와 관련이 없습니다. OS의 IntelliJ IDEA 창에서 모든 스크래치에 액세스하고 실행할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="bf764bc84647534de5f2a7804f4aa2d9d548f9f9" translate="yes" xml:space="preserve">
          <source>Kotlin preserves lazy object initialization in JavaScript.</source>
          <target state="translated">Kotlin은 JavaScript에서 게으른 객체 초기화를 유지합니다.</target>
        </trans-unit>
        <trans-unit id="69aede4d1ffe657e5907011bd8394bcc0601690e" translate="yes" xml:space="preserve">
          <source>Kotlin preserves overflow semantics for &lt;code&gt;kotlin.Int&lt;/code&gt;, &lt;code&gt;kotlin.Byte&lt;/code&gt;, &lt;code&gt;kotlin.Short&lt;/code&gt;, &lt;code&gt;kotlin.Char&lt;/code&gt; and &lt;code&gt;kotlin.Long&lt;/code&gt;.</source>
          <target state="translated">Kotlin은 &lt;code&gt;kotlin.Int&lt;/code&gt; , &lt;code&gt;kotlin.Byte&lt;/code&gt; , &lt;code&gt;kotlin.Short&lt;/code&gt; , &lt;code&gt;kotlin.Char&lt;/code&gt; 및 &lt;code&gt;kotlin.Long&lt;/code&gt; 에 대한 오버 플로우 의미를 유지합니다 .</target>
        </trans-unit>
        <trans-unit id="2849a08507ed289fb75d76677103722db661daba" translate="yes" xml:space="preserve">
          <source>Kotlin primitive type boxes are mapped to special Swift/Objective-C classes. For example, &lt;code&gt;kotlin.Int&lt;/code&gt; box is represented as &lt;code&gt;KotlinInt&lt;/code&gt; class instance in Swift (or &lt;code&gt;${prefix}Int&lt;/code&gt; instance in Objective-C, where &lt;code&gt;prefix&lt;/code&gt; is the framework names prefix). These classes are derived from &lt;code&gt;NSNumber&lt;/code&gt;, so the instances are proper &lt;code&gt;NSNumber&lt;/code&gt;s supporting all corresponding operations.</source>
          <target state="translated">Kotlin 기본 유형 상자는 특수 Swift / Objective-C 클래스에 매핑됩니다. 예를 들어, &lt;code&gt;kotlin.Int&lt;/code&gt; 상자는 Swift에서 &lt;code&gt;KotlinInt&lt;/code&gt; 클래스 인스턴스 (또는 Objective-C의 &lt;code&gt;${prefix}Int&lt;/code&gt; 인스턴스 (여기서 &lt;code&gt;prefix&lt;/code&gt; 는 프레임 워크 이름 접두어 임))로 표시됩니다. 이 클래스는 &lt;code&gt;NSNumber&lt;/code&gt; 에서 파생 되므로 인스턴스는 해당 하는 모든 작업을 지원하는 적절한 &lt;code&gt;NSNumber&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="56d4abf280a1b7394ae7fdfbb57bfe9eaca646d5" translate="yes" xml:space="preserve">
          <source>Kotlin properties declared in a named object or a companion object will have static backing fields either in that named object or in the class containing the companion object.</source>
          <target state="translated">명명 된 객체 또는 컴패니언 객체에 선언 된 Kotlin 속성에는 해당 명명 된 객체 또는 컴패니언 객체를 포함하는 클래스에 정적 백업 필드가 있습니다.</target>
        </trans-unit>
        <trans-unit id="cf2e0c6a8a702a4b4cb47d5f81663fe43b024e43" translate="yes" xml:space="preserve">
          <source>Kotlin provides a series of compiler options that are accessible in IntelliJ IDEA also. In addition to the one we've just seen for generating source maps, we also have the ability to set</source>
          <target state="translated">Kotlin은 IntelliJ IDEA에서도 액세스 할 수있는 일련의 컴파일러 옵션을 제공합니다. 방금 소스 맵을 생성하기 위해 본 것 외에도 설정할 수있는 기능이 있습니다</target>
        </trans-unit>
        <trans-unit id="0a113f99eec74b4131a54c5b784be8df823aef27" translate="yes" xml:space="preserve">
          <source>Kotlin provides a variety of functions to execute a block of code in the context of a given object: &lt;code&gt;let&lt;/code&gt;, &lt;code&gt;run&lt;/code&gt;, &lt;code&gt;with&lt;/code&gt;, &lt;code&gt;apply&lt;/code&gt;, and &lt;code&gt;also&lt;/code&gt;. For the guidance on choosing the right scope function for your case, refer to &lt;a href=&quot;scope-functions&quot;&gt;Scope Functions&lt;/a&gt;.</source>
          <target state="translated">: 코 틀린는 주어진 객체의 컨텍스트에서 코드 블록을 실행하는 다양한 기능을 제공 &lt;code&gt;let&lt;/code&gt; , &lt;code&gt;run&lt;/code&gt; , &lt;code&gt;with&lt;/code&gt; , &lt;code&gt;apply&lt;/code&gt; , 및 &lt;code&gt;also&lt;/code&gt; . 귀하의 경우에 적합한 범위의 기능을 선택에 대한 지침을 참조 &lt;a href=&quot;scope-functions&quot;&gt;스코프 기능&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="9bdbfc816d9da34f310288932621f6005bd4a635" translate="yes" xml:space="preserve">
          <source>Kotlin provides so called &lt;strong&gt;star-projection&lt;/strong&gt; syntax for this:</source>
          <target state="translated">코 틀린은 이를 위해 &lt;strong&gt;스타 프로젝션&lt;/strong&gt; 구문을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="45eae3e9e04c057fe2a9ce2b00c2b1626952c923" translate="yes" xml:space="preserve">
          <source>Kotlin provides the ability to target JavaScript. It does so by transpiling Kotlin to JavaScript. The current implementation targets ECMAScript 5.1 but there are plans to eventually target ECMAScript 2015 as well.</source>
          <target state="translated">Kotlin은 JavaScript를 대상으로하는 기능을 제공합니다. Kotlin을 JavaScript로 변환하여 그렇게합니다. 현재 구현은 ECMAScript 5.1을 대상으로하지만 결국 ECMAScript 2015를 대상으로 할 계획도 있습니다.</target>
        </trans-unit>
        <trans-unit id="1d361e832e7fbd8cbfa474feeaaf4e3060965e0c" translate="yes" xml:space="preserve">
          <source>Kotlin provides the following built-in types representing numbers (this is close to Java):</source>
          <target state="translated">Kotlin은 숫자를 나타내는 다음과 같은 내장 유형을 제공합니다 (이것은 Java에 가깝습니다).</target>
        </trans-unit>
        <trans-unit id="bcb1ec23fd44ea30c0c43e5be53b38271d9f8878" translate="yes" xml:space="preserve">
          <source>Kotlin provides three tasks for Ant:</source>
          <target state="translated">Kotlin은 Ant에 대한 세 가지 작업을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="d32683bae75ae112d7b7ae383176964359ce8293" translate="yes" xml:space="preserve">
          <source>Kotlin requires that every member property is initialized during instance construction. Sometimes, a class is intended to be used in such a way that the constructor doesn't have enough information to initialize all properties (such as when making a builder class or when using property-based dependency injection). In order to not have to make those properties nullable, you can use a &lt;em&gt;late-initialized property&lt;/em&gt;:</source>
          <target state="translated">Kotlin은 인스턴스 생성 중에 모든 멤버 속성을 초기화해야합니다. 때때로 클래스는 생성자가 모든 속성을 초기화하기에 충분한 정보를 갖지 않는 방식으로 사용되기도합니다 (빌더 클래스를 만들 때 또는 속성 기반 종속성 주입을 사용할 때). 이러한 속성을 nullable로 만들지 않으려면 &lt;em&gt;초기화&lt;/em&gt; 가 &lt;em&gt;늦은 속성을&lt;/em&gt; 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="b6c82522c1d0ee2c933047e31fffeca6f833ef7e" translate="yes" xml:space="preserve">
          <source>Kotlin scripts in &lt;code&gt;build.gradle.kts&lt;/code&gt; files</source>
          <target state="translated">&lt;code&gt;build.gradle.kts&lt;/code&gt; 파일의 Kotlin 스크립트</target>
        </trans-unit>
        <trans-unit id="120e9cfe3ecde2244c4b2038cf0d5e11c76827a7" translate="yes" xml:space="preserve">
          <source>Kotlin singleton (made with an &lt;code&gt;object&lt;/code&gt; declaration, including &lt;code&gt;companion object&lt;/code&gt;) is imported to Swift/Objective-C as a class with a single instance. The instance is available through the factory method, i.e. as &lt;code&gt;[MySingleton mySingleton]&lt;/code&gt; in Objective-C and &lt;code&gt;MySingleton()&lt;/code&gt; in Swift.</source>
          <target state="translated">(AN로 만든 코 틀린 싱글 &lt;code&gt;object&lt;/code&gt; 를 포함 선언, &lt;code&gt;companion object&lt;/code&gt; ) 단일 인스턴스와 클래스로 스위프트 / 오브젝티브 C로 가져옵니다. 인스턴스는 팩토리 메소드를 통해 사용할 수 있습니다 (예 : Objective-C의 &lt;code&gt;[MySingleton mySingleton]&lt;/code&gt; 및 Swift의 &lt;code&gt;MySingleton()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="bea729ea75b1b1e606f056a5012e91fb52a83a74" translate="yes" xml:space="preserve">
          <source>Kotlin singletons</source>
          <target state="translated">코 틀린 싱글 톤</target>
        </trans-unit>
        <trans-unit id="a2394b4a95a3420db31c70572b58364d6b98a0c6" translate="yes" xml:space="preserve">
          <source>Kotlin source file or directory to compile</source>
          <target state="translated">Kotlin 소스 파일 또는 컴파일 할 디렉토리</target>
        </trans-unit>
        <trans-unit id="e2f631b0ebe5da9da1b87daae220f0696369b117" translate="yes" xml:space="preserve">
          <source>Kotlin source sets may be connected with the &lt;em&gt;'depends on'&lt;/em&gt; relation, so that if a source set &lt;code&gt;foo&lt;/code&gt; depends on a source set &lt;code&gt;bar&lt;/code&gt; then:</source>
          <target state="translated">Kotlin 소스 세트는 &lt;em&gt;'depends on'&lt;/em&gt; 관계 와 연결될 수 있으므로 소스 세트 &lt;code&gt;foo&lt;/code&gt; 가 소스 세트 &lt;code&gt;bar&lt;/code&gt; 에 의존 하는 경우 :</target>
        </trans-unit>
        <trans-unit id="3806de1d34a4bca588a5784ceb856faa4c1b15c6" translate="yes" xml:space="preserve">
          <source>Kotlin sources can be mixed with Java sources in the same folder, or in different folders. The default convention is using different folders:</source>
          <target state="translated">Kotlin 소스는 동일한 폴더 또는 다른 폴더에서 Java 소스와 혼합 될 수 있습니다. 기본 규칙은 다른 폴더를 사용하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="742632ac6e0e85caf1c4f062cccebafab2dafb01" translate="yes" xml:space="preserve">
          <source>Kotlin standard library artifacts and split packages</source>
          <target state="translated">Kotlin 표준 라이브러리 아티팩트 및 분할 패키지</target>
        </trans-unit>
        <trans-unit id="e4a28ec1a46419f171d723ee46383588cd9c1cbc" translate="yes" xml:space="preserve">
          <source>Kotlin supports a style of functional programming known as &lt;a href=&quot;https://en.wikipedia.org/wiki/Tail_call&quot;&gt;tail recursion&lt;/a&gt;. This allows some algorithms that would normally be written using loops to instead be written using a recursive function, but without the risk of stack overflow. When a function is marked with the &lt;code&gt;tailrec&lt;/code&gt; modifier and meets the required form, the compiler optimises out the recursion, leaving behind a fast and efficient loop based version instead:</source>
          <target state="translated">Kotlin은 &lt;a href=&quot;https://en.wikipedia.org/wiki/Tail_call&quot;&gt;테일 재귀&lt;/a&gt; 라고하는 기능 프로그래밍 스타일을 지원합니다 . 이것은 일반적으로 루프를 사용하여 작성되는 일부 알고리즘이 재귀 함수를 사용하여 작성되지만 스택 오버 플로우의 위험이 없도록합니다. 함수가 &lt;code&gt;tailrec&lt;/code&gt; 수정 자로 표시되고 필요한 양식을 충족하면 컴파일러는 재귀를 최적화하여 대신 빠르고 효율적인 루프 기반 버전을 남깁니다.</target>
        </trans-unit>
        <trans-unit id="f764f32b8a5f60d7b0c651002320db85fd7d539f" translate="yes" xml:space="preserve">
          <source>Kotlin supports annonation processing via the &lt;em&gt;Kotlin annotation processing tool&lt;/em&gt;(&lt;code&gt;kapt&lt;/code&gt;). Usage of kapt with Gradle is described on the &lt;a href=&quot;kapt&quot;&gt;kapt page&lt;/a&gt;.</source>
          <target state="translated">Kotlin은 &lt;em&gt;Kotlin 주석 처리 도구&lt;/em&gt; ( &lt;code&gt;kapt&lt;/code&gt; ) 를 통한 음음 처리를 지원합니다 . Gradle과의 kapt 사용법은 kapt &lt;a href=&quot;kapt&quot;&gt;페이지&lt;/a&gt; 에 설명되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="92bcfac7403d3cddfb4464119a784d92d81f9f9d" translate="yes" xml:space="preserve">
          <source>Kotlin supports local functions, i.e. a function inside another function:</source>
          <target state="translated">Kotlin은 로컬 함수, 즉 다른 함수 내부의 함수를 지원합니다.</target>
        </trans-unit>
        <trans-unit id="282b26637b1a5ff71051d95d88177e34b6cefc30" translate="yes" xml:space="preserve">
          <source>Kotlin supports single-parent class inheritance - so each class (except the root class &lt;code&gt;Any&lt;/code&gt;) has got exactly one parent class, called a &lt;em&gt;superclass&lt;/em&gt;. Kotlin wants you to think through your class design to make sure that it's actually safe to &lt;em&gt;subclass&lt;/em&gt; it, so classes are &lt;em&gt;closed&lt;/em&gt; by default and can't be inherited from unless you explicitly declare the class to be &lt;em&gt;open&lt;/em&gt; or &lt;em&gt;abstract&lt;/em&gt;. You can then subclass from that class by declaring a new class which mentions its parent class after a colon:</source>
          <target state="translated">Kotlin은 단일 부모 클래스 상속을 지원하므로 각 클래스 (루트 클래스 &lt;code&gt;Any&lt;/code&gt; 제외 )에는 &lt;em&gt;수퍼 클래스&lt;/em&gt; 라고하는 하나의 부모 클래스가 있습니다. Kotlin은 클래스 디자인을 통해 실제로 &lt;em&gt;서브 클래 싱&lt;/em&gt; 하는 것이 안전한지 확인 하기를 원하므로 클래스가 기본적으로 &lt;em&gt;닫히고&lt;/em&gt; 클래스를 &lt;em&gt;open&lt;/em&gt; 또는 &lt;em&gt;abstract&lt;/em&gt; 라고 명시 적으로 선언하지 않으면 클래스를 상속받을 수 없습니다 . 그런 다음 콜론 뒤에 부모 클래스를 언급하는 새 클래스를 선언하여 해당 클래스에서 서브 클래 싱 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c701dab67e42733a07778c8e90d14a14d6115e0e" translate="yes" xml:space="preserve">
          <source>Kotlin supports the following operators and special symbols:</source>
          <target state="translated">Kotlin은 다음 연산자와 특수 기호를 지원합니다.</target>
        </trans-unit>
        <trans-unit id="4887c0a9ca610838532432bde155538452979c8b" translate="yes" xml:space="preserve">
          <source>Kotlin supports the standard set of arithmetical operations over numbers, which are declared as members of appropriate classes (but the compiler optimizes the calls down to the corresponding instructions). See &lt;a href=&quot;operator-overloading&quot;&gt;Operator overloading&lt;/a&gt;.</source>
          <target state="translated">Kotlin은 적절한 클래스의 멤버로 선언 된 숫자에 대한 표준 산술 연산 세트를 지원합니다 (하지만 컴파일러는 해당 명령어에 대한 호출을 최적화합니다). &lt;a href=&quot;operator-overloading&quot;&gt;연산자 과부하를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="c8bfc686b943f3ad415464d9f2987e93b995ca8c" translate="yes" xml:space="preserve">
          <source>Kotlin supports traditional &lt;em&gt;break&lt;/em&gt; and &lt;em&gt;continue&lt;/em&gt; operators in loops. See &lt;a href=&quot;returns&quot;&gt;Returns and jumps&lt;/a&gt;.</source>
          <target state="translated">코 틀린은 기존의 지원 &lt;em&gt;중단을&lt;/em&gt; 하고 &lt;em&gt;계속&lt;/em&gt; 루프 연산자를. &lt;a href=&quot;returns&quot;&gt;리턴 및 점프를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="d836a05da6a45d7708b37e3a93892db605af05e1" translate="yes" xml:space="preserve">
          <source>Kotlin targets a wide range of the Java versions, including Java 6 and Java 7, where default methods in the interfaces are not allowed. For your convenience, the Kotlin compiler works around that limitation, but this workaround isn't compatible with the &lt;code&gt;default&lt;/code&gt; methods, introduced in Java 8.</source>
          <target state="translated">Kotlin은 인터페이스의 기본 메소드가 허용되지 않는 Java 6 및 Java 7을 포함한 광범위한 Java 버전을 대상으로합니다. 편의상 Kotlin 컴파일러는 이러한 제한을 해결하지만이 해결 방법은 Java 8에 도입 된 &lt;code&gt;default&lt;/code&gt; 방법 과 호환되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="7a3c3013cf9e37dd556eb25470f92f220350c10a" translate="yes" xml:space="preserve">
          <source>Kotlin to JavaScript</source>
          <target state="translated">코 틀린에서 JavaScript로</target>
        </trans-unit>
        <trans-unit id="09a30aded79f08fdd22e3766d5057679b6cb51d6" translate="yes" xml:space="preserve">
          <source>Kotlin treats some Java types specially. Such types are not loaded from Java &quot;as is&quot;, but are &lt;em&gt;mapped&lt;/em&gt; to corresponding Kotlin types. The mapping only matters at compile time, the runtime representation remains unchanged. Java's primitive types are mapped to corresponding Kotlin types (keeping &lt;a href=&quot;#null-safety-and-platform-types&quot;&gt;platform types&lt;/a&gt; in mind):</source>
          <target state="translated">Kotlin은 일부 Java 유형을 특별히 처리합니다. 이러한 유형은 Java에서 &quot;있는 그대로&quot;로드되지 않지만 해당 Kotlin 유형에 &lt;em&gt;매핑&lt;/em&gt; 됩니다. 매핑은 컴파일 타임에만 중요하며 런타임 표현은 변경되지 않습니다. Java의 기본 유형은 해당 Kotlin 유형에 매핑됩니다 ( &lt;a href=&quot;#null-safety-and-platform-types&quot;&gt;플랫폼 유형&lt;/a&gt; 을 염두에 두십시오).</target>
        </trans-unit>
        <trans-unit id="768f1e9cdea1a9d60e4596098790dc6c5c883f4f" translate="yes" xml:space="preserve">
          <source>Kotlin turns the function pointer return type into a nullable &lt;code&gt;CPointer&amp;lt;CFunction&amp;lt;..&amp;gt;&lt;/code&gt; object. There is the need to explicitly check for &lt;code&gt;null&lt;/code&gt; first. We use &lt;a href=&quot;../../reference/null-safety&quot;&gt;elvis operator&lt;/a&gt; for that. The &lt;code&gt;cinterop&lt;/code&gt; tool helps us to turn a C function pointer into an easy to call object in Kotlin. This is what we did on the last line.</source>
          <target state="translated">Kotlin은 함수 포인터 리턴 유형을 널 입력 가능 &lt;code&gt;CPointer&amp;lt;CFunction&amp;lt;..&amp;gt;&lt;/code&gt; 오브젝트로 변환합니다. &lt;code&gt;null&lt;/code&gt; 을 명시 적으로 먼저 확인해야합니다 . 우리는이를 위해 &lt;a href=&quot;../../reference/null-safety&quot;&gt;elvis 연산자&lt;/a&gt; 를 사용합니다. &lt;code&gt;cinterop&lt;/code&gt; 의 도구는 우리가 코 틀린에 개체를 호출하기 쉬운로 C 함수 포인터를 설정하는 데 도움이됩니다. 이것이 우리가 마지막 줄에서 한 일입니다.</target>
        </trans-unit>
        <trans-unit id="db8f21bde482b5a130cf00596109ec23d3d336d2" translate="yes" xml:space="preserve">
          <source>Kotlin uses a family of function types like &lt;code&gt;(Int) -&amp;gt; String&lt;/code&gt; for declarations that deal with functions: &lt;code&gt;val onClick: () -&amp;gt; Unit = ...&lt;/code&gt;.</source>
          <target state="translated">코 틀린 같은 기능 유형의 가족 사용 &lt;code&gt;(Int) -&amp;gt; String&lt;/code&gt; 선언에 대한 그 기능 거래 : &lt;code&gt;val onClick: () -&amp;gt; Unit = ...&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="bb4aa710f2c72b83ee921d5d3e539487fd005073" translate="yes" xml:space="preserve">
          <source>Kotlin uses the &lt;code&gt;libnative_&lt;/code&gt; prefix for all declarations in the created &lt;code&gt;libnative_api.h&lt;/code&gt; file. Let's present the mapping of the types in a more readable way:</source>
          <target state="translated">Kotlin은 만들어진 &lt;code&gt;libnative_api.h&lt;/code&gt; 파일 의 모든 선언에 &lt;code&gt;libnative_&lt;/code&gt; 접두사를 사용 합니다. 보다 읽기 쉬운 방식으로 타입의 매핑을 제시해 봅시다 :</target>
        </trans-unit>
        <trans-unit id="b58121b32bf1a1498b7715228a497191716fd48d" translate="yes" xml:space="preserve">
          <source>Kotlin was designed for easy interoperation with Java platform. It sees Java classes as Kotlin classes, and Java sees Kotlin classes as Java classes. However, JavaScript is a dynamically-typed language, which means it does not check types in compile-time. You can freely talk to JavaScript from Kotlin via &lt;a href=&quot;dynamic-type&quot;&gt;dynamic&lt;/a&gt; types, but if you want the full power of Kotlin type system, you can create Kotlin headers for JavaScript libraries.</source>
          <target state="translated">Kotlin은 Java 플랫폼과 쉽게 상호 운용되도록 설계되었습니다. Java 클래스는 Kotlin 클래스로, Java는 Kotlin 클래스를 Java 클래스로 간주합니다. 그러나 JavaScript는 동적 형식 언어이므로 컴파일 타임에 형식을 확인하지 않습니다. &lt;a href=&quot;dynamic-type&quot;&gt;동적&lt;/a&gt; 유형을 통해 Kotlin에서 JavaScript와 자유롭게 대화 할 수 있지만 Kotlin 유형 시스템의 모든 기능을 원한다면 JavaScript 라이브러리 용 Kotlin 헤더를 작성할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="487d5ff42a3055fc2a4cb28f3d53d445d59f1865" translate="yes" xml:space="preserve">
          <source>Kotlin will allow you to declare this property without initializing it, and you can set the property value at some point after construction (either directly or via a function). It is the responsibility of the class itself as well as its users to take care not to read the property before it has been set, and Kotlin allows you to write code that reads &lt;code&gt;name&lt;/code&gt; as if it were an ordinary, non-nullable property. However, the compiler is unable to enforce correct usage, so if the property is read before it has been set, an &lt;code&gt;UninitializedPropertyAccessException&lt;/code&gt; will be thrown at runtime.</source>
          <target state="translated">Kotlin은이 속성을 초기화하지 않고 선언 할 수 있으며 생성 후 어느 시점에서 (직접 또는 함수를 통해) 속성 값을 설정할 수 있습니다. 클래스 자체와 속성을 설정하기 전에 속성을 읽지 않도록주의하는 것은 클래스 자체의 책임이며 Kotlin에서는 &lt;code&gt;name&lt;/code&gt; 을 일반 null이 아닌 속성처럼 읽는 코드를 작성할 수 있습니다 . 그러나 컴파일러에서 올바른 사용법을 적용 할 수 없으므로 속성을 설정하기 전에 속성을 읽으면 런타임에 &lt;code&gt;UninitializedPropertyAccessException&lt;/code&gt; 이 발생합니다.</target>
        </trans-unit>
        <trans-unit id="b3a556e28261e02ebafecde169f3b3513ca13075" translate="yes" xml:space="preserve">
          <source>Kotlin works quite smoothly with Spring Boot and many of the steps found on the &lt;a href=&quot;https://spring.io/guides&quot;&gt;Spring Guides&lt;/a&gt; for creating a RESTful service can be followed verbatim for Kotlin. There are some minor differences however when it comes to defining the Gradle configuration and the project layout structure, as well as the initialization code.</source>
          <target state="translated">Kotlin은 Spring Boot와 매우 원활하게 작동 하며 RESTful 서비스를 만들기위한 &lt;a href=&quot;https://spring.io/guides&quot;&gt;Spring Guides&lt;/a&gt; 에있는 많은 단계 를 Kotlin에 대해 그대로 사용할 수 있습니다. 그러나 Gradle 구성 및 프로젝트 레이아웃 구조 및 초기화 코드를 정의 할 때 약간의 차이가 있습니다.</target>
        </trans-unit>
        <trans-unit id="43ea688f8664ba8f8dabcebd91046161c6146f3c" translate="yes" xml:space="preserve">
          <source>Kotlin works with different &lt;a href=&quot;build-tools&quot;&gt;build tools&lt;/a&gt;, so if we're using a standard tool such as Ant, Maven or Gradle, the process for setting up a Kotlin project is no different to any other language or library that integrates with these tools. Where there are some minor requirements and differences is when using JBS, which is the internal build system that IntelliJ IDEA uses, which is also supported on TeamCity.</source>
          <target state="translated">Kotlin은 다른 &lt;a href=&quot;build-tools&quot;&gt;빌드 도구&lt;/a&gt; 와 함께 작동 하므로 Ant, Maven 또는 Gradle과 같은 표준 도구를 사용하는 경우 Kotlin 프로젝트를 설정하는 프로세스는 이러한 도구와 통합되는 다른 언어 나 라이브러리와 다르지 않습니다. 사소한 요구 사항과 차이점이있는 경우 JBS (IntelliJ IDEA에서 사용하는 내부 빌드 시스템)를 사용할 때 TeamCity에서도 지원됩니다.</target>
        </trans-unit>
        <trans-unit id="457e307b979be376836ec99d4487123ba8ace79f" translate="yes" xml:space="preserve">
          <source>Kotlin's approach to working with asynchronous code is using coroutines, which is the idea of suspendable computations, i.e. the idea that a function can suspend its execution at some point and resume later on.</source>
          <target state="translated">Kotlin의 비동기 코드 작업 방식은 코 루틴을 사용하는 것으로, 이는 일시 중단 가능한 계산, 즉 함수가 특정 시점에서 실행을 일시 중단했다가 나중에 다시 시작할 수 있다는 아이디어입니다.</target>
        </trans-unit>
        <trans-unit id="b5ab858d5d3418daf57f2ff97756dc06bfcd23b9" translate="yes" xml:space="preserve">
          <source>Kotlin's documentation generation tool is called &lt;a href=&quot;https://github.com/Kotlin/dokka&quot;&gt;Dokka&lt;/a&gt;. See the &lt;a href=&quot;https://github.com/Kotlin/dokka/blob/master/README.md&quot;&gt;Dokka README&lt;/a&gt; for usage instructions.</source>
          <target state="translated">Kotlin의 문서 생성 도구를 &lt;a href=&quot;https://github.com/Kotlin/dokka&quot;&gt;Dokka&lt;/a&gt; 라고 합니다. 사용법에 대해서는 &lt;a href=&quot;https://github.com/Kotlin/dokka/blob/master/README.md&quot;&gt;Dokka README&lt;/a&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="3af1e3ba09d170fd30c3af38c47add3814785926" translate="yes" xml:space="preserve">
          <source>Kotlin's documentation syntax is called &lt;em&gt;KDoc&lt;/em&gt;. A KDoc block is placed above the construct it describes, and begins with &lt;code&gt;/**&lt;/code&gt; and ends with &lt;code&gt;*/&lt;/code&gt; (possibly on one line; if not, each intermediate lines should start with an aligned asterisk). The first block of text is the summary; then, you can use &lt;em&gt;block tags&lt;/em&gt; to provide information about specific parts of the construct. Some block tags are &lt;code&gt;@param&lt;/code&gt; for function parameters and generic type parameters, and &lt;code&gt;@return&lt;/code&gt; for the return value. You can link to identifiers inside brackets. All the text outside of links and block tag names is in Markdown format.</source>
          <target state="translated">Kotlin의 문서 구문을 &lt;em&gt;KDoc&lt;/em&gt; 이라고 &lt;em&gt;합니다&lt;/em&gt; . KDoc 블록은 설명하는 구문 위에 위치하며 &lt;code&gt;/**&lt;/code&gt; 로 시작하고 &lt;code&gt;*/&lt;/code&gt; 로 끝납니다 (한 줄에있을 수 있습니다. 그렇지 않은 경우 각 중간 줄은 정렬 된 별표로 시작해야합니다). 첫 번째 텍스트 블록은 요약입니다. 그런 다음 &lt;em&gt;블록 태그&lt;/em&gt; 를 사용 하여 구성의 특정 부분에 대한 정보를 제공 할 수 있습니다 . 일부 블록 태그는 함수 매개 변수 및 일반 형식 매개 변수의 경우 &lt;code&gt;@param&lt;/code&gt; 이고 &lt;code&gt;@return&lt;/code&gt; 경우 @return 입니다. 괄호 안의 식별자에 연결할 수 있습니다. 링크 및 블록 태그 이름 외부의 모든 텍스트는 마크 다운 형식입니다.</target>
        </trans-unit>
        <trans-unit id="053760c0ead482ee5ae43f8e0bead527a31d7dd2" translate="yes" xml:space="preserve">
          <source>Kotlin's generics are a little different from Java's (see &lt;a href=&quot;generics&quot;&gt;Generics&lt;/a&gt;). When importing Java types to Kotlin we perform some conversions:</source>
          <target state="translated">Kotlin의 제네릭은 Java와 약간 다릅니다 ( &lt;a href=&quot;generics&quot;&gt;Generics&lt;/a&gt; 참조 ). Java 유형을 Kotlin으로 가져올 때 몇 가지 변환을 수행합니다.</target>
        </trans-unit>
        <trans-unit id="9ce324f37629b9d5fdf6ee64821674d4e61b9c46" translate="yes" xml:space="preserve">
          <source>Kotlin's loops are similar to Python's. &lt;code&gt;for&lt;/code&gt; iterates over anything that is &lt;em&gt;iterable&lt;/em&gt; (anything that has an &lt;code&gt;iterator()&lt;/code&gt; function that provides an &lt;code&gt;Iterator&lt;/code&gt; object), or anything that is itself an iterator:</source>
          <target state="translated">Kotlin의 루프는 Python과 유사합니다. &lt;code&gt;for&lt;/code&gt; 무엇이든을 반복하다 &lt;em&gt;반복자&lt;/em&gt; (AN이 아무것도 &lt;code&gt;iterator()&lt;/code&gt; 제공 기능 &lt;code&gt;Iterator&lt;/code&gt; 자체의 반복자, 또는 어떤 개체) :</target>
        </trans-unit>
        <trans-unit id="ba05695800cb8016bdf03b211c131a78afee8e93" translate="yes" xml:space="preserve">
          <source>Kotlin's object model is substantially different from Python's. Most importantly, classes are &lt;em&gt;not&lt;/em&gt; dynamically modifiable at runtime! (There are some limited exceptions to this, but you generally shouldn't do it. However, it &lt;em&gt;is&lt;/em&gt; possible to dynamically &lt;em&gt;inspect&lt;/em&gt; classes and objects at runtime with a feature called &lt;em&gt;reflection&lt;/em&gt; - this can be useful, but should be judiciously used.) All properties (attributes) and functions that might ever be needed on a class must be declared either directly in the class body or as &lt;a href=&quot;extension-functionsproperties&quot;&gt;&lt;em&gt;extension functions&lt;/em&gt;&lt;/a&gt;, so you should think carefully through your class design.</source>
          <target state="translated">코 틀린의 객체 모델은 파이썬과 실질적으로 다릅니다. 가장 중요한 점 은 런타임에 클래스를 동적으로 수정할 수 &lt;em&gt;없다는 것입니다&lt;/em&gt; ! (이이 일부 제한 예외,하지만 당신은 일반적으로 그것을하지 말아야하지만,. &lt;em&gt;입니다&lt;/em&gt; 동적으로 할 수 &lt;em&gt;검사&lt;/em&gt; 클래스와 기능이라고하여 런타임에 객체 &lt;em&gt;반사&lt;/em&gt; -.이 유용 할 수 있지만 신중하게 사용되어야한다) 모든 클래스에서 필요할 수있는 속성 (속성) 및 함수는 클래스 본문에서 직접 또는 &lt;a href=&quot;extension-functionsproperties&quot;&gt;&lt;em&gt;확장 함수&lt;/em&gt;&lt;/a&gt; 로 선언해야 하므로 클래스 디자인을 신중하게 고려해야합니다.</target>
        </trans-unit>
        <trans-unit id="970540431e074be00582837c3e83cd1ca1a5ee04" translate="yes" xml:space="preserve">
          <source>Kotlin's type system is aimed at eliminating the danger of null references from code, also known as the &lt;a href=&quot;http://en.wikipedia.org/wiki/Tony_Hoare#Apologies_and_retractions&quot;&gt;The Billion Dollar Mistake&lt;/a&gt;.</source>
          <target state="translated">Kotlin의 유형 시스템은 &lt;a href=&quot;http://en.wikipedia.org/wiki/Tony_Hoare#Apologies_and_retractions&quot;&gt;The Billion Dollar Mistake&lt;/a&gt; 라고도하는 코드에서 null 참조의 위험을 제거하기위한 것 입니다.</target>
        </trans-unit>
        <trans-unit id="6ae5912eae484ffd44f09a774b363dbba8158106" translate="yes" xml:space="preserve">
          <source>Kotlin's type system is aimed to eliminate &lt;code&gt;NullPointerException&lt;/code&gt;'s from our code. The only possible causes of NPE's may be:</source>
          <target state="translated">Kotlin의 형식 시스템은 코드에서 &lt;code&gt;NullPointerException&lt;/code&gt; 을 제거하는 것을 목표로 합니다. NPE의 유일한 원인은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="0b21dfbe494a9eaaf724f5a9592dd235fdd14650" translate="yes" xml:space="preserve">
          <source>Kotlin, as a language, provides only minimal low-level APIs in its standard library to enable various other libraries to utilize coroutines. Unlike many other languages with similar capabilities, &lt;code&gt;async&lt;/code&gt; and &lt;code&gt;await&lt;/code&gt; are not keywords in Kotlin and are not even part of its standard library. Moreover, Kotlin's concept of &lt;em&gt;suspending function&lt;/em&gt; provides a safer and less error-prone abstraction for asynchronous operations than futures and promises.</source>
          <target state="translated">Kotlin은 언어로서 표준 라이브러리에서 최소한의 저수준 API 만 제공하여 다양한 다른 라이브러리가 코 루틴을 활용할 수 있도록합니다. 비슷한 기능을 가진 다른 많은 언어와 달리 &lt;code&gt;async&lt;/code&gt; 및 &lt;code&gt;await&lt;/code&gt; 는 Kotlin의 키워드가 아니며 표준 라이브러리의 일부도 아닙니다. 또한 Kotlin의 &lt;em&gt;일시 중단 기능&lt;/em&gt; 개념은 미래와 약속보다 비동기 작업에 대해 안전하고 오류가 발생하기 쉬운 추상화를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="1aefdadaf18a27e16e25f47128252ff2aeb47fe6" translate="yes" xml:space="preserve">
          <source>Kotlin, similar to C# and Gosu, provides the ability to extend a class with new functionality without having to inherit from the class or use any type of design pattern such as Decorator. This is done via special declarations called &lt;em&gt;extensions&lt;/em&gt;. Kotlin supports &lt;em&gt;extension functions&lt;/em&gt; and &lt;em&gt;extension properties&lt;/em&gt;.</source>
          <target state="translated">C # 및 Gosu와 유사한 Kotlin은 클래스에서 상속하거나 Decorator와 같은 모든 유형의 디자인 패턴을 사용하지 않고도 새로운 기능으로 클래스를 확장 할 수 있습니다. 이는 &lt;em&gt;extensions&lt;/em&gt; 라는 특수 선언을 통해 수행됩니다 . Kotlin은 &lt;em&gt;확장 기능&lt;/em&gt; 및 &lt;em&gt;확장 속성을&lt;/em&gt; 지원 &lt;em&gt;합니다&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="66f1754b6d5c7a12dce00bd5e634c25ddb75bf52" translate="yes" xml:space="preserve">
          <source>Kotlin/JS</source>
          <target state="translated">Kotlin/JS</target>
        </trans-unit>
        <trans-unit id="44cbff389316ebfe00ceb67daf169189d44ae420" translate="yes" xml:space="preserve">
          <source>Kotlin/JVM</source>
          <target state="translated">Kotlin/JVM</target>
        </trans-unit>
        <trans-unit id="59ce5e2461e87e30bf83a0eb1faafe214139a6af" translate="yes" xml:space="preserve">
          <source>Kotlin/Native</source>
          <target state="translated">Kotlin/Native</target>
        </trans-unit>
        <trans-unit id="ba24fc19201f933494d7dd5a5c0dfc8e159aaf9b" translate="yes" xml:space="preserve">
          <source>Kotlin/Native &lt;a href=&quot;native/platform_libs&quot;&gt;libraries&lt;/a&gt; help to share Kotlin code between projects. POSIX, gzip, OpenGL, Metal, Foundation, and many other popular libraries and Apple frameworks are pre-imported and included as Kotlin/Native libraries into the compiler package.</source>
          <target state="translated">Kotlin / 네이티브 &lt;a href=&quot;native/platform_libs&quot;&gt;라이브러리&lt;/a&gt; 는 프로젝트간에 Kotlin 코드를 공유하는 데 도움이됩니다. POSIX, gzip, OpenGL, Metal, Foundation 및 기타 많은 인기있는 라이브러리 및 Apple 프레임 워크가 사전 가져 오기되어 Kotlin / Native 라이브러리로 컴파일러 패키지에 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="87f61b22867c181628a95e8886f5b445415a504e" translate="yes" xml:space="preserve">
          <source>Kotlin/Native Gradle plugin</source>
          <target state="translated">Kotlin / Native Gradle 플러그인</target>
        </trans-unit>
        <trans-unit id="df149e18227e20b3ab9482b52698611b0a6fc13c" translate="yes" xml:space="preserve">
          <source>Kotlin/Native Runtime Declarations</source>
          <target state="translated">코 틀린 / 네이티브 런타임 선언</target>
        </trans-unit>
        <trans-unit id="491c504edd0672427d971480838eef4206234894" translate="yes" xml:space="preserve">
          <source>Kotlin/Native also has tight integration with Apple technologies. The &lt;a href=&quot;apple-framework&quot;&gt;Kotlin/Native as an Apple Framework&lt;/a&gt; tutorial explains how to compile Kotlin code into a framework for Swift and Objective-C.</source>
          <target state="translated">Kotlin / Native는 Apple 기술과 긴밀하게 통합되어 있습니다. &lt;a href=&quot;apple-framework&quot;&gt;애플 프레임 워크로 코 틀린 / 기본&lt;/a&gt; 튜토리얼은 스위프트와 목표 - C를위한 프레임 워크로 코 틀린 코드를 컴파일하는 방법을 설명합니다.</target>
        </trans-unit>
        <trans-unit id="1d512deb7d342683898c6350ed1a11736984886b" translate="yes" xml:space="preserve">
          <source>Kotlin/Native also has tight integration with Objective-C and Swift. It is covered in the &lt;a href=&quot;apple-framework&quot;&gt;Kotlin/Native as an Apple Framework&lt;/a&gt; tutorial.</source>
          <target state="translated">Kotlin / Native는 Objective-C 및 Swift와 긴밀하게 통합되어 있습니다. &lt;a href=&quot;apple-framework&quot;&gt;Kotlin / Native에서 Apple Framework&lt;/a&gt; 튜토리얼 로 다루고 있습니다.</target>
        </trans-unit>
        <trans-unit id="08982dde24268c672ff4e00ffc1e0aa78c3c7edf" translate="yes" xml:space="preserve">
          <source>Kotlin/Native as a Dynamic Library</source>
          <target state="translated">다이나믹 라이브러리로서의 Kotlin / Native</target>
        </trans-unit>
        <trans-unit id="9337f3778507f31504f20c46b400d4ffe737a776" translate="yes" xml:space="preserve">
          <source>Kotlin/Native as an Apple Framework</source>
          <target state="translated">애플 프레임 워크로서 Kotlin / Native</target>
        </trans-unit>
        <trans-unit id="5920643ed2bd803efde8c74d41d4425c7caa2ab6" translate="yes" xml:space="preserve">
          <source>Kotlin/Native can be used for many &lt;a href=&quot;basic-kotlin-native-app&quot;&gt;targets&lt;/a&gt; and applications, including, but not limited to macOS, Windows, Linux, and &lt;a href=&quot;mpp-ios-android&quot;&gt;iOS&lt;/a&gt;.</source>
          <target state="translated">Kotlin / Native는 macOS, Windows, Linux 및 &lt;a href=&quot;mpp-ios-android&quot;&gt;iOS를&lt;/a&gt; 포함하되 이에 국한되지 않는 많은 &lt;a href=&quot;basic-kotlin-native-app&quot;&gt;대상&lt;/a&gt; 및 응용 프로그램에 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="5a86ebad61bd5c0feb7bd99b7af759453735031a" translate="yes" xml:space="preserve">
          <source>Kotlin/Native comes with the &lt;code&gt;cinterop&lt;/code&gt; tool, the tool generates bindings between the C language and Kotlin. It uses a &lt;code&gt;.def&lt;/code&gt; file to specify a C library to import. More details are discussed in the &lt;a href=&quot;../../reference/native/c_interop&quot;&gt;Interop with C Libraries&lt;/a&gt; tutorial.</source>
          <target state="translated">Kotlin / Native는 &lt;code&gt;cinterop&lt;/code&gt; 도구 와 함께 제공 되며이 도구는 C 언어와 Kotlin 간의 바인딩을 생성합니다. 그것은 사용 &lt;code&gt;.def&lt;/code&gt; 수입에 C 라이브러리를 지정하는 파일을. 자세한 내용은 &lt;a href=&quot;../../reference/native/c_interop&quot;&gt;Interop with C Libraries&lt;/a&gt; 자습서에서 설명합니다.</target>
        </trans-unit>
        <trans-unit id="c8a9d6995d5deeb05943192825e878fac0954ca5" translate="yes" xml:space="preserve">
          <source>Kotlin/Native comes with the &lt;code&gt;cinterop&lt;/code&gt; tool; the tool generates bindings between the C language and Kotlin. It uses a &lt;code&gt;.def&lt;/code&gt; file to specify a C library to import. More details on this are in the &lt;a href=&quot;../../reference/native/c_interop&quot;&gt;Interop with C Libraries&lt;/a&gt; tutorial.</source>
          <target state="translated">Kotlin / Native는 &lt;code&gt;cinterop&lt;/code&gt; 도구 와 함께 제공됩니다 . 이 도구는 C 언어와 Kotlin 간의 바인딩을 생성합니다. 그것은 사용 &lt;code&gt;.def&lt;/code&gt; 수입에 C 라이브러리를 지정하는 파일을. 이에 대한 자세한 내용은 &lt;a href=&quot;../../reference/native/c_interop&quot;&gt;Interop with C Libraries&lt;/a&gt; 자습서에 있습니다.</target>
        </trans-unit>
        <trans-unit id="f608852356bc7f03f212743cacdba0d3e22a135a" translate="yes" xml:space="preserve">
          <source>Kotlin/Native comes with the &lt;code&gt;cinterop&lt;/code&gt; tool; the tool generates bindings between the C language and Kotlin. It uses a &lt;code&gt;.def&lt;/code&gt; file to specify a C library to import. More details on this are in the &lt;a href=&quot;../../reference/native/c_interop&quot;&gt;Interop with C Libraries&lt;/a&gt; tutorial. The quickest way to try out C API mapping is to have all C declarations in the &lt;code&gt;interop.def&lt;/code&gt; file, without creating any &lt;code&gt;.h&lt;/code&gt; of &lt;code&gt;.c&lt;/code&gt; files at all. Then place the C declarations in a &lt;code&gt;interop.def&lt;/code&gt; file after the special &lt;code&gt;---&lt;/code&gt; separator line:</source>
          <target state="translated">Kotlin / Native는 &lt;code&gt;cinterop&lt;/code&gt; 도구 와 함께 제공됩니다 . 이 도구는 C 언어와 Kotlin 간의 바인딩을 생성합니다. 그것은 사용 &lt;code&gt;.def&lt;/code&gt; 수입에 C 라이브러리를 지정하는 파일을. 이에 대한 자세한 내용은 &lt;a href=&quot;../../reference/native/c_interop&quot;&gt;Interop with C Libraries&lt;/a&gt; 자습서에 있습니다. C의 API 매핑을 시도하는 가장 빠른 방법은 모든 C 선언하는 것입니다 &lt;code&gt;interop.def&lt;/code&gt; 의 어떤 생성하지 않고, 파일을 &lt;code&gt;.h&lt;/code&gt; 의 &lt;code&gt;.c&lt;/code&gt; 인 모든에서 파일을. 그런 다음 특수 &lt;code&gt;---&lt;/code&gt; 구분 기호 행 다음에 &lt;code&gt;interop.def&lt;/code&gt; 파일 에 C 선언을 배치하십시오 .</target>
        </trans-unit>
        <trans-unit id="02527cf62d35559073254c9faa21884b055d8fe5" translate="yes" xml:space="preserve">
          <source>Kotlin/Native compiler can produce a dynamic library out of the Kotlin code we have. A dynamic library often comes with a header file, a &lt;code&gt;.h&lt;/code&gt; file, which we will use to call compiled code from C.</source>
          <target state="translated">Kotlin / Native 컴파일러는 우리가 보유한 Kotlin 코드에서 동적 라이브러리를 생성 할 수 있습니다. 동적 라이브러리는 헤더 파일 인 &lt;code&gt;.h&lt;/code&gt; 파일 과 함께 제공 되며 C에서 컴파일 된 코드를 호출하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="aa4881e31bc09168e1508d74717ea87e97808663" translate="yes" xml:space="preserve">
          <source>Kotlin/Native compiler can produce a framework for macOS and iOS out of the Kotlin code. The created framework contains all declarations and binaries needed to use it with Objective-C and Swift. The best way to understand the techniques is to try it for ourselves. Let's create a tiny Kotlin library first and use it from an Objective-C program.</source>
          <target state="translated">Kotlin / Native 컴파일러는 Kotlin 코드에서 macOS 및 iOS 용 프레임 워크를 생성 할 수 있습니다. 작성된 프레임 워크에는 Objective-C 및 Swift와 함께 사용하는 데 필요한 모든 선언 및 이진이 포함되어 있습니다. 기술을 이해하는 가장 좋은 방법은 직접 시도해 보는 것입니다. 작은 Kotlin 라이브러리를 먼저 만들어 Objective-C 프로그램에서 사용하겠습니다.</target>
        </trans-unit>
        <trans-unit id="4e70e70db2bb73d6cf1636bc883f8b53e7b6e7cb" translate="yes" xml:space="preserve">
          <source>Kotlin/Native for Native</source>
          <target state="translated">코 틀린 / 네이티브 네이티브</target>
        </trans-unit>
        <trans-unit id="7c2c0a3630334c277a8dc79b0ff364b848f6cdc2" translate="yes" xml:space="preserve">
          <source>Kotlin/Native has bidirectional interop with Objective-C and Swift languages. Kotlin objects integrate with Objective-C/Swift reference counting. Unused Kotlin objects are automatically removed. The &lt;a href=&quot;https://github.com/JetBrains/kotlin-native/blob/master/OBJC_INTEROP.md&quot;&gt;Objective-C Interop&lt;/a&gt; article contains more information on the interop implementation details. Of course, it is possible to import an existing framework and use it from Kotlin. Kotlin/Native comes with a good set of pre-imported system frameworks.</source>
          <target state="translated">Kotlin / Native는 Objective-C 및 Swift 언어와 양방향 상호 운용성이 있습니다. Kotlin 객체는 Objective-C / Swift 참조 카운팅과 통합됩니다. 사용하지 않은 Kotlin 개체는 자동으로 제거됩니다. &lt;a href=&quot;https://github.com/JetBrains/kotlin-native/blob/master/OBJC_INTEROP.md&quot;&gt;목표 - C 상호 운용성의&lt;/a&gt; 기사는 상호 운용성 구현 세부 사항에 대한 자세한 정보가 포함되어 있습니다. 물론 기존 프레임 워크를 가져와 Kotlin에서 사용할 수 있습니다. Kotlin / Native는 사전에 가져온 시스템 프레임 워크를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="fb79704d30655deeda4430e028a0903e865692a2" translate="yes" xml:space="preserve">
          <source>Kotlin/Native has garbage collection, but it does not help us deal with Kotlin objects from the C language. Kotlin/Native has interop with Objective-C and Swift and integrates with their reference counters. The &lt;a href=&quot;../../reference/native/objc_interop&quot;&gt;Objective-C Interop&lt;/a&gt; documentation article contains more details on it. Also, there is the tutorial &lt;a href=&quot;apple-framework&quot;&gt;Kotlin/Native as an Apple Framework&lt;/a&gt;.</source>
          <target state="translated">Kotlin / Native에는 가비지 콜렉션이 있지만 C 언어의 Kotlin 오브젝트를 처리하는 데 도움이되지 않습니다. Kotlin / Native는 Objective-C 및 Swift와 상호 운용되며 참조 카운터와 통합됩니다. &lt;a href=&quot;../../reference/native/objc_interop&quot;&gt;목표 - C 상호 운용성의&lt;/a&gt; 문서 문서에서는에 대한 자세한 내용이 포함되어 있습니다. 또한 &lt;a href=&quot;apple-framework&quot;&gt;Kotlin / Native&lt;/a&gt; 튜토리얼 이 Apple Framework로 제공 됩니다.</target>
        </trans-unit>
        <trans-unit id="c4bedc3bea01878b4fcc1d82e743d0490ea2316b" translate="yes" xml:space="preserve">
          <source>Kotlin/Native implements strict mutability checks, ensuring the important invariant that the object is either immutable or accessible from the single thread at that moment in time (&lt;code&gt;mutable XOR global&lt;/code&gt;).</source>
          <target state="translated">Kotlin / Native는 엄격한 변경 가능성 검사를 구현하여 해당 시점에서 단일 스레드에서 객체를 변경할 수 없거나 액세스 할 수 있다는 중요한 불변성을 보장합니다 ( &lt;code&gt;mutable XOR global&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="36a59900f037725e245ca430f51e42774fdb92b1" translate="yes" xml:space="preserve">
          <source>Kotlin/Native interop with Swift and Objective-C is covered in the &lt;a href=&quot;../../reference/native/objc_interop&quot;&gt;documentation&lt;/a&gt; article. Also, the same topic is covered in the &lt;a href=&quot;apple-framework&quot;&gt;Kotlin/Native as an Apple Framework&lt;/a&gt; tutorial.</source>
          <target state="translated">Swift 및 Objective-C와의 Kotlin / Native interop은 &lt;a href=&quot;../../reference/native/objc_interop&quot;&gt;문서&lt;/a&gt; 기사 에서 다룹니다 . 또한 &lt;a href=&quot;apple-framework&quot;&gt;Kotlin / Native에서 Apple Framework&lt;/a&gt; 튜토리얼 과 동일한 주제를 다룹니다 .</target>
        </trans-unit>
        <trans-unit id="9fbae7a065c905b4b51aef1c8da31351fd4627d4" translate="yes" xml:space="preserve">
          <source>Kotlin/Native interoperability</source>
          <target state="translated">코 틀린 / 네이티브 상호 운용성</target>
        </trans-unit>
        <trans-unit id="1610b5a5d3e7a47921adb6d92cccbad92bdc99b6" translate="yes" xml:space="preserve">
          <source>Kotlin/Native interoperability with Swift/Objective-C</source>
          <target state="translated">Swift / Objective-C와의 Kotlin / Native 상호 운용성</target>
        </trans-unit>
        <trans-unit id="d8be23859d14973d71698ea0e5cefbc7c40946a7" translate="yes" xml:space="preserve">
          <source>Kotlin/Native is a technology for compiling Kotlin code to native binaries, which can run without a virtual machine. It is an &lt;a href=&quot;https://llvm.org/&quot;&gt;LLVM&lt;/a&gt; based backend for the Kotlin compiler and native implementation of the Kotlin standard library.</source>
          <target state="translated">Kotlin / Native는 Kotlin 코드를 가상 머신없이 실행할 수있는 네이티브 바이너리로 컴파일하는 기술입니다. 그것은이다 &lt;a href=&quot;https://llvm.org/&quot;&gt;LLVM&lt;/a&gt; 코 틀린 컴파일러와 코 틀린 표준 라이브러리의 기본 구현을위한 백엔드를 기반으로.</target>
        </trans-unit>
        <trans-unit id="f0c84f3b6f232babbc963e394f0dc8678a4ccc49" translate="yes" xml:space="preserve">
          <source>Kotlin/Native is currently &lt;a href=&quot;https://blog.jetbrains.com/kotlin/tag/native/&quot;&gt;in the works&lt;/a&gt;. It compiles Kotlin to native code that can run without a VM. There is a Technology Preview released but it is not production-ready yet, and doesn&amp;rsquo;t yet target all the platforms that we plan to support for 1.0. For more information check out the &lt;a href=&quot;https://blog.jetbrains.com/kotlin/2017/04/kotlinnative-tech-preview-kotlin-without-a-vm/&quot;&gt;blog post announcing Kotlin/Native&lt;/a&gt;.</source>
          <target state="translated">Kotlin / Native는 현재 &lt;a href=&quot;https://blog.jetbrains.com/kotlin/tag/native/&quot;&gt;작업 중&lt;/a&gt; 입니다. Kotlin을 VM없이 실행할 수있는 기본 코드로 컴파일합니다. Technology Preview가 릴리스되었지만 아직 프로덕션 준비가되지 않았으며 1.0을 지원할 모든 플랫폼을 아직 대상으로하지 않습니다. 자세한 내용은 &lt;a href=&quot;https://blog.jetbrains.com/kotlin/2017/04/kotlinnative-tech-preview-kotlin-without-a-vm/&quot;&gt;Kotlin / Native를 알리는 블로그 게시물을&lt;/a&gt; 확인하십시오 .</target>
        </trans-unit>
        <trans-unit id="2e6e839c9eb016aad26e87b63395598581d37d86" translate="yes" xml:space="preserve">
          <source>Kotlin/Native is primarily designed to allow compilation for platforms where &lt;em&gt;virtual machines&lt;/em&gt; are not desirable or possible, for example, embedded devices or iOS. It solves the situations when a developer needs to produce a self-contained program that does not require an additional runtime or virtual machine.</source>
          <target state="translated">Kotlin / Native는 주로 임베디드 장치 또는 iOS와 같이 &lt;em&gt;가상 머신&lt;/em&gt; 이 바람직하지 않거나 불가능한 플랫폼에 대한 컴파일을 허용하도록 설계되었습니다 . 개발자가 추가 런타임 또는 가상 머신을 요구하지 않는 자체 포함 된 프로그램을 생성해야하는 상황을 해결합니다.</target>
        </trans-unit>
        <trans-unit id="0a635a513919c15b75bf38827975739bea97d9aa" translate="yes" xml:space="preserve">
          <source>Kotlin/Native libraries</source>
          <target state="translated">코 틀린 / 네이티브 도서관</target>
        </trans-unit>
        <trans-unit id="e52aa2cf9fdcb60b58b2f9cbee9d5268ded14cfd" translate="yes" xml:space="preserve">
          <source>Kotlin/Native libraries are zip files containing a predefined directory structure, with the following layout:</source>
          <target state="translated">Kotlin / Native 라이브러리는 사전 정의 된 디렉토리 구조를 포함하는 zip 파일이며 다음과 같은 레이아웃을 갖습니다.</target>
        </trans-unit>
        <trans-unit id="0c6f4cb92f825877d15d4e0409193ad150464dfb" translate="yes" xml:space="preserve">
          <source>Kotlin/Native plugin requires a newer version of Gradle, let's patch the &lt;code&gt;gradle/wrapper/gradle-wrapper.properties&lt;/code&gt; and use the following &lt;code&gt;distrubutionUrl&lt;/code&gt;:</source>
          <target state="translated">Kotlin / Native 플러그인에는 최신 버전의 Gradle이 필요합니다. &lt;code&gt;gradle/wrapper/gradle-wrapper.properties&lt;/code&gt; 를 패치 하고 다음 &lt;code&gt;distrubutionUrl&lt;/code&gt; 을 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="bc9ab4e314800dbff8307a948abe9a382ccbda9f" translate="yes" xml:space="preserve">
          <source>Kotlin/Native provides bi-directional interoperability with Objective-C/Swift. Objective-C frameworks and libraries can be used in Kotlin code. Kotlin modules can be used in Swift/Objective-C code too. Besides that, Kotlin/Native has &lt;a href=&quot;https://github.com/JetBrains/kotlin-native/blob/master/INTEROP.md&quot;&gt;C Interop&lt;/a&gt;. There is also the &lt;a href=&quot;dynamic-libraries&quot;&gt;Kotlin/Native as a Dynamic Library&lt;/a&gt; tutorial for more information.</source>
          <target state="translated">Kotlin / Native는 Objective-C / Swift와 양방향 상호 운용성을 제공합니다. Kotlin 코드에서 Objective-C 프레임 워크 및 라이브러리를 사용할 수 있습니다. Kotlin 모듈은 Swift / Objective-C 코드에서도 사용할 수 있습니다. 그 외에도 Kotlin / Native에는 &lt;a href=&quot;https://github.com/JetBrains/kotlin-native/blob/master/INTEROP.md&quot;&gt;C Interop이&lt;/a&gt; 있습니다. 자세한 내용 은 &lt;a href=&quot;dynamic-libraries&quot;&gt;Kotlin / Native as a Dynamic Library&lt;/a&gt; 자습서도 있습니다.</target>
        </trans-unit>
        <trans-unit id="c6b2dc69e2661f2073dd575f2affbfbd48e1816c" translate="yes" xml:space="preserve">
          <source>Kotlin/Native provides bidirectional interoperability with Objective-C. Objective-C frameworks and libraries can be used in Kotlin code if properly imported to the build (system frameworks are imported by default). See e.g. &quot;Using cinterop&quot; in &lt;a href=&quot;gradle_plugin#using-cinterop&quot;&gt;Gradle plugin documentation&lt;/a&gt;. A Swift library can be used in Kotlin code if its API is exported to Objective-C with &lt;code&gt;@objc&lt;/code&gt;. Pure Swift modules are not yet supported.</source>
          <target state="translated">Kotlin / Native는 Objective-C와 양방향 상호 운용성을 제공합니다. 빌드로 올바르게 가져온 경우 Objective-C 프레임 워크 및 라이브러리를 Kotlin 코드에서 사용할 수 있습니다 (기본적으로 시스템 프레임 워크를 가져옵니다). &lt;a href=&quot;gradle_plugin#using-cinterop&quot;&gt;Gradle 플러그인 설명서의&lt;/a&gt; &quot;cinterop 사용&quot;을 참조하십시오 . API가 &lt;code&gt;@objc&lt;/code&gt; 를 사용 하여 Objective-C로 내보내지면 Kotlin 코드에서 Swift 라이브러리를 사용할 수 있습니다 . Pure Swift 모듈은 아직 지원되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="b1c01f6b8c6b07e3bae6f070059599f6036610db" translate="yes" xml:space="preserve">
          <source>Kotlin/Native provides us with the ability to consume standard C libraries, opening up an entire ecosystem of functionality that exists for pretty much anything we could need. In fact, Kotlin/Native already ships with a set of prebuilt &lt;a href=&quot;https://github.com/JetBrains/kotlin-native/blob/master/PLATFORM_LIBS.md&quot;&gt;platform libraries&lt;/a&gt; which provide some additional common functionality to that of the standard library.</source>
          <target state="translated">Kotlin / Native는 표준 C 라이브러리를 사용할 수있는 기능을 제공하여 필요한 거의 모든 기능이 포함 된 전체 기능 에코 시스템을 개방합니다. 실제로 Kotlin / Native는 이미 표준 라이브러리와 공통된 기능을 추가로 제공하는 사전 빌드 된 &lt;a href=&quot;https://github.com/JetBrains/kotlin-native/blob/master/PLATFORM_LIBS.md&quot;&gt;플랫폼 라이브러리&lt;/a&gt; 세트 를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="d5389b5d85aa38736c73eb5aa9a313b033cc4d19" translate="yes" xml:space="preserve">
          <source>Kotlin/Native runtime doesn't encourage a classical thread-oriented concurrency model with mutually exclusive code blocks and conditional variables, as this model is known to be error-prone and unreliable. Instead, we suggest a collection of alternative approaches, allowing you to use hardware concurrency and implement blocking IO. Those approaches are as follows, and they will be elaborated on in further sections:</source>
          <target state="translated">Kotlin / Native 런타임은 상호 배타적 인 코드 블록과 조건 변수를 가진 고전적인 스레드 지향 동시성 모델을 권장하지 않습니다.이 모델은 오류가 발생하기 쉽고 신뢰할 수 없습니다. 대신, 하드웨어 동시성을 사용하고 블로킹 IO를 구현할 수있는 대체 접근 방식 모음을 제안합니다. 이러한 접근 방식은 다음과 같으며 추가 섹션에서 자세히 설명합니다.</target>
        </trans-unit>
        <trans-unit id="ac06a1726ed52d913d8c1eb5dbb2c82e723e185d" translate="yes" xml:space="preserve">
          <source>Kotlin/Native sources and examples</source>
          <target state="translated">코 틀린 / 네이티브 소스 및 예제</target>
        </trans-unit>
        <trans-unit id="c4fa13c8ae49679dc61a192fdfe13c1f15f778dd" translate="yes" xml:space="preserve">
          <source>Kotlin/Native sources and examples (.tgz)</source>
          <target state="translated">Kotlin / 기본 소스 및 예 (.tgz)</target>
        </trans-unit>
        <trans-unit id="950455929874daa5e49199f24231f9f317130873" translate="yes" xml:space="preserve">
          <source>Kotlin/Native sources and examples (.zip)</source>
          <target state="translated">Kotlin / 기본 소스 및 예 (.zip)</target>
        </trans-unit>
        <trans-unit id="120d75c1b3c3fba55f52d619ebc338f3dea2b2f3" translate="yes" xml:space="preserve">
          <source>Kotlin/Native supports C interop too. Check out the &lt;a href=&quot;dynamic-libraries&quot;&gt;Kotlin/Native as a Dynamic Library&lt;/a&gt; tutorial for that, or have a look at the &lt;a href=&quot;../../reference/native/c_interop&quot;&gt;C Interop&lt;/a&gt; documentation article</source>
          <target state="translated">Kotlin / Native는 C interop도 지원합니다. 이를위한 &lt;a href=&quot;dynamic-libraries&quot;&gt;Kotlin / Native를 동적 라이브러리&lt;/a&gt; 학습서로 확인하거나 &lt;a href=&quot;../../reference/native/c_interop&quot;&gt;C Interop&lt;/a&gt; 문서 기사를보십시오.</target>
        </trans-unit>
        <trans-unit id="8011eb11da7ebe065e7322454c19657ef14fbebd" translate="yes" xml:space="preserve">
          <source>Kotlin/Native supports the following platforms:</source>
          <target state="translated">Kotlin / Native는 다음 플랫폼을 지원합니다.</target>
        </trans-unit>
        <trans-unit id="ab1b874667f8863029a4700ab21570b44d78ad0e" translate="yes" xml:space="preserve">
          <source>Kotlin/Native supports two-way interoperability with the Native world. On the one hand, the compiler creates:</source>
          <target state="translated">Kotlin / Native는 기본 세계와 양방향 상호 운용성을 지원합니다. 한편으로 컴파일러는 다음을 생성합니다.</target>
        </trans-unit>
        <trans-unit id="6804afabbebdb0087394548cd2a9146eb760288b" translate="yes" xml:space="preserve">
          <source>Kotlin/Native target presets (see the &lt;a href=&quot;#using-kotlinnative-targets&quot;&gt;notes&lt;/a&gt; below):</source>
          <target state="translated">코 틀린 / 네이티브 대상 사전 설정 ( 아래 &lt;a href=&quot;#using-kotlinnative-targets&quot;&gt;참고&lt;/a&gt; 참조) :</target>
        </trans-unit>
        <trans-unit id="48119a00acf039b3da2d7a8a891256a947a47f3e" translate="yes" xml:space="preserve">
          <source>Kotlin/Native targets do not require additional test dependencies, and the &lt;code&gt;kotlin.test&lt;/code&gt; API implementations are built-in.</source>
          <target state="translated">Kotlin / Native 대상에는 추가 테스트 종속성이 필요하지 않으며 &lt;code&gt;kotlin.test&lt;/code&gt; API 구현이 내장되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="5a2754b26e3f7ed0f09f6ac7ae0bd6b529fb311d" translate="yes" xml:space="preserve">
          <source>Kotlin/Native uses the &lt;a href=&quot;https://gradle.org&quot;&gt;Gradle&lt;/a&gt; build system through the &lt;a href=&quot;../../reference/building-mpp-with-gradle&quot;&gt;kotlin-multiplatform&lt;/a&gt; plugin. We'll look at how to configure a Gradle build below. For some corner cases, a Kotlin/Native compiler can still be obtained manually (not recommended) from the &lt;a href=&quot;https://github.com/JetBrains/kotlin/releases&quot;&gt;Kotlin releases page on GitHub&lt;/a&gt;. In the tutorial, we are focusing on using the Gradle builds.</source>
          <target state="translated">Kotlin / Native는 &lt;a href=&quot;../../reference/building-mpp-with-gradle&quot;&gt;kotlin-multiplatform&lt;/a&gt; 플러그인을 통해 &lt;a href=&quot;https://gradle.org&quot;&gt;Gradle&lt;/a&gt; 빌드 시스템을 사용합니다 . 아래에서 Gradle 빌드를 구성하는 방법을 살펴 보겠습니다. 일부 경우에는 &lt;a href=&quot;https://github.com/JetBrains/kotlin/releases&quot;&gt;GitHub&lt;/a&gt; 의 Kotlin 릴리스 페이지에서 Kotlin / Native 컴파일러를 수동으로 얻을 수 있습니다 (권장되지 않음) . 이 튜토리얼에서는 Gradle 빌드 사용에 중점을 둡니다.</target>
        </trans-unit>
        <trans-unit id="8a3c5258f5b49cfb85ed7f0dcaee614a131a77c3" translate="yes" xml:space="preserve">
          <source>Kotlin:</source>
          <target state="translated">Kotlin:</target>
        </trans-unit>
        <trans-unit id="b43ff6724657fd16732a9b1a55f67abda3312ad7" translate="yes" xml:space="preserve">
          <source>KotlinConf Spinner app</source>
          <target state="translated">KotlinConf Spinner 앱</target>
        </trans-unit>
        <trans-unit id="b1cd61d796dd3aa3454e388dffcf47f0812af913" translate="yes" xml:space="preserve">
          <source>KotlinConf app</source>
          <target state="translated">KotlinConf 앱</target>
        </trans-unit>
        <trans-unit id="6047c8afd00f076fe5dfb352137d01b27268ea83" translate="yes" xml:space="preserve">
          <source>KotlinNullPointerException</source>
          <target state="translated">KotlinNullPointerException</target>
        </trans-unit>
        <trans-unit id="ee7e86f4510f7d7092cbe3960fdb6815985528a4" translate="yes" xml:space="preserve">
          <source>KotlinReflectionNotSupportedError</source>
          <target state="translated">KotlinReflectionNotSupportedError</target>
        </trans-unit>
        <trans-unit id="4b1b0c248352273cdb7b000d38d1c480106dbb58" translate="yes" xml:space="preserve">
          <source>KotlinVersion</source>
          <target state="translated">KotlinVersion</target>
        </trans-unit>
        <trans-unit id="399d4d156e1a5773fbf3b4b0cfd04b6e517c9fca" translate="yes" xml:space="preserve">
          <source>KtFunction</source>
          <target state="translated">KtFunction</target>
        </trans-unit>
        <trans-unit id="57da6543f61562be137bdbd9c9e157724aeffda4" translate="yes" xml:space="preserve">
          <source>LEFT_TO_RIGHT</source>
          <target state="translated">LEFT_TO_RIGHT</target>
        </trans-unit>
        <trans-unit id="a75ecccfbf31bd489981a90341d7e832ee10f3c8" translate="yes" xml:space="preserve">
          <source>LEFT_TO_RIGHT_EMBEDDING</source>
          <target state="translated">LEFT_TO_RIGHT_EMBEDDING</target>
        </trans-unit>
        <trans-unit id="51859752bb5b0316e072d757734043db04448fc4" translate="yes" xml:space="preserve">
          <source>LEFT_TO_RIGHT_OVERRIDE</source>
          <target state="translated">LEFT_TO_RIGHT_OVERRIDE</target>
        </trans-unit>
        <trans-unit id="758213c577cf41a86fde124f3b88be88d415048d" translate="yes" xml:space="preserve">
          <source>LETTER_NUMBER</source>
          <target state="translated">LETTER_NUMBER</target>
        </trans-unit>
        <trans-unit id="e8e9a4d54a1399696ec25a431fcc0c615fbc2e7a" translate="yes" xml:space="preserve">
          <source>LINE_SEPARATOR</source>
          <target state="translated">LINE_SEPARATOR</target>
        </trans-unit>
        <trans-unit id="e84f54372586b1a789f2b6cf056c7a1173be8141" translate="yes" xml:space="preserve">
          <source>LINUX</source>
          <target state="translated">LINUX</target>
        </trans-unit>
        <trans-unit id="7ec99800d18c128a406891a50a13ae7030c97a75" translate="yes" xml:space="preserve">
          <source>LITERAL</source>
          <target state="translated">LITERAL</target>
        </trans-unit>
        <trans-unit id="e893e5d306bb8ac993e8000a6af037f4725105be" translate="yes" xml:space="preserve">
          <source>LOCAL_VARIABLE</source>
          <target state="translated">LOCAL_VARIABLE</target>
        </trans-unit>
        <trans-unit id="99de6ad7c4876501b047c66fac1fc218394c8386" translate="yes" xml:space="preserve">
          <source>LOWERCASE_LETTER</source>
          <target state="translated">LOWERCASE_LETTER</target>
        </trans-unit>
        <trans-unit id="ebb1178c70d79da7a0d8f3efa343b4f1b5b8c8bd" translate="yes" xml:space="preserve">
          <source>Lambda Expressions and Anonymous Functions</source>
          <target state="translated">람다 식 및 익명 함수</target>
        </trans-unit>
        <trans-unit id="41d636c884bc5c4615a06b36835ca61116f4c96a" translate="yes" xml:space="preserve">
          <source>Lambda expression syntax</source>
          <target state="translated">람다 식 구문</target>
        </trans-unit>
        <trans-unit id="0b86dab2bd78e474cfa2ccedae83439dde48687c" translate="yes" xml:space="preserve">
          <source>Lambda expressions and anonymous functions are 'function literals', i.e. functions that are not declared, but passed immediately as an expression. Consider the following example:</source>
          <target state="translated">Lambda 표현식과 익명 함수는 '함수 리터럴'입니다. 즉 선언되지 않았지만 즉시 표현식으로 전달되는 함수입니다. 다음 예제를 고려하십시오.</target>
        </trans-unit>
        <trans-unit id="5688b8dc62f61bfb17ef962f1f3970299059391c" translate="yes" xml:space="preserve">
          <source>Lambda expressions and anonymous functions are collectively called &lt;em&gt;function literals&lt;/em&gt;.</source>
          <target state="translated">Lambda 표현식과 익명 함수를 통칭하여 &lt;em&gt;함수 리터럴&lt;/em&gt; 이라고 &lt;em&gt;합니다&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="7575b2907cada2fd0b97a753d13dd1b9c1b841f5" translate="yes" xml:space="preserve">
          <source>Lambda expressions can be used as function literals with receiver when the receiver type can be inferred from context. One of the most important examples of their usage is &lt;a href=&quot;type-safe-builders&quot;&gt;type-safe builders&lt;/a&gt;:</source>
          <target state="translated">수신자 유형이 컨텍스트에서 유추 될 수있는 경우 수신자가있는 함수 리터럴로 Lambda 표현식을 사용할 수 있습니다. 사용법의 가장 중요한 예 중 하나는 &lt;a href=&quot;type-safe-builders&quot;&gt;유형 안전 빌더입니다&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="ad3d3ff2619991da585042e4417d2462b7beccf2" translate="yes" xml:space="preserve">
          <source>Lambda formatting</source>
          <target state="translated">람다 형식</target>
        </trans-unit>
        <trans-unit id="13d6fc1369e9172c884961d85e8a1601ad741c0d" translate="yes" xml:space="preserve">
          <source>Lambda parameters</source>
          <target state="translated">람다 매개 변수</target>
        </trans-unit>
        <trans-unit id="b220e56144b93a1600b71766a84e029644f0540d" translate="yes" xml:space="preserve">
          <source>Lambda result</source>
          <target state="translated">람다 결과</target>
        </trans-unit>
        <trans-unit id="ba9dfe5041cd205445df5b843e8a9dc628256415" translate="yes" xml:space="preserve">
          <source>Lambdas</source>
          <target state="translated">Lambdas</target>
        </trans-unit>
        <trans-unit id="49ddf0eb799de42693040dadaac202ba4004f236" translate="yes" xml:space="preserve">
          <source>Language settings</source>
          <target state="translated">언어 설정</target>
        </trans-unit>
        <trans-unit id="1ff5129754f331271a9a3fac5165d942c8cc5ff1" translate="yes" xml:space="preserve">
          <source>Language settings of a source set affect how the sources are analyzed in the IDE. Due to the current limitations, in a Gradle build, only the language settings of the compilation's default source set are used and are applied to all of the sources participating in the compilation.</source>
          <target state="translated">소스 세트의 언어 설정은 IDE에서 소스를 분석하는 방법에 영향을줍니다. 현재 제한 사항으로 인해 Gradle 빌드에서는 컴파일 기본 소스 세트의 언어 설정 만 사용되며 컴파일에 참여하는 모든 소스에 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="d6774da675388cdd08014c6406478bff14597287" translate="yes" xml:space="preserve">
          <source>Late-Initialized Properties and Variables</source>
          <target state="translated">늦은 초기 속성 및 변수</target>
        </trans-unit>
        <trans-unit id="99322069c074a7f591d86eb26eeac43fa69f34bd" translate="yes" xml:space="preserve">
          <source>Lateinit</source>
          <target state="translated">Lateinit</target>
        </trans-unit>
        <trans-unit id="f84a3ef3e20f72377a42e84bdb45e09bb7b7843f" translate="yes" xml:space="preserve">
          <source>Lateinit top-level properties and local variables</source>
          <target state="translated">Lateinit 최상위 특성 및 로컬 변수</target>
        </trans-unit>
        <trans-unit id="b3bb9d6cae3f462e729059bd666f0ea34bc0ea80" translate="yes" xml:space="preserve">
          <source>Lazily started async</source>
          <target state="translated">게으른 비동기 시작</target>
        </trans-unit>
        <trans-unit id="84e98cf97551805d46a1030b73cb47aa40988008" translate="yes" xml:space="preserve">
          <source>Lazy</source>
          <target state="translated">Lazy</target>
        </trans-unit>
        <trans-unit id="be5e08be6cf0006ff0c341fef7d3f6b41fb802ed" translate="yes" xml:space="preserve">
          <source>Lazy property</source>
          <target state="translated">게으른 속성</target>
        </trans-unit>
        <trans-unit id="54579fdbee70b6cb28a03b9cca5ce503dbf0fab9" translate="yes" xml:space="preserve">
          <source>LazyThreadSafetyMode</source>
          <target state="translated">LazyThreadSafetyMode</target>
        </trans-unit>
        <trans-unit id="aca4dc328f8e03ba7e98c1efbf5068f7d83287c3" translate="yes" xml:space="preserve">
          <source>Learn Kotlin</source>
          <target state="translated">코 틀린 배우기</target>
        </trans-unit>
        <trans-unit id="b28b1c4866b45b6c232187eb0f49c55bd90b8a14" translate="yes" xml:space="preserve">
          <source>Learning Kotlin</source>
          <target state="translated">코 틀린 학습</target>
        </trans-unit>
        <trans-unit id="23f50e0c99ce18545a5c0af46eb7b9685859fd37" translate="yes" xml:space="preserve">
          <source>Learning Kotlin with EduTools plugin</source>
          <target state="translated">EduTools 플러그인으로 Kotlin 학습</target>
        </trans-unit>
        <trans-unit id="e19a030656541f97ece0fe153ca0f1966796261d" translate="yes" xml:space="preserve">
          <source>Leave other options with their default values and click &lt;strong&gt;Finish&lt;/strong&gt;.</source>
          <target state="translated">다른 옵션은 기본값으로두고 &lt;strong&gt;Finish를&lt;/strong&gt; 클릭하십시오 .</target>
        </trans-unit>
        <trans-unit id="b8d43e4d61d6a5ac38163dd5c6fce699c5294311" translate="yes" xml:space="preserve">
          <source>Let us have two producers of strings: &lt;code&gt;fizz&lt;/code&gt; and &lt;code&gt;buzz&lt;/code&gt;. The &lt;code&gt;fizz&lt;/code&gt; produces &quot;Fizz&quot; string every 300 ms:</source>
          <target state="translated">&lt;code&gt;fizz&lt;/code&gt; 와 &lt;code&gt;buzz&lt;/code&gt; 의 두 문자열 제작자를 보자 . 이 &lt;code&gt;fizz&lt;/code&gt; 는 300 ms마다 &quot;Fizz&quot;문자열을 생성합니다.</target>
        </trans-unit>
        <trans-unit id="97c13d20ca41b326b3be0985ea83f77551576d93" translate="yes" xml:space="preserve">
          <source>Let us launch a hundred coroutines all doing the same action thousand times. We'll also measure their completion time for further comparisons:</source>
          <target state="translated">모두 같은 행동을 천 번 수행하는 백 코 루틴을 시작합시다. 또한 추가 비교를 위해 완료 시간을 측정합니다.</target>
        </trans-unit>
        <trans-unit id="00337a32763192378fa8ed88a3475bc09950f868" translate="yes" xml:space="preserve">
          <source>Let us put our knowledge about contexts, children and jobs together. Assume that our application has an object with a lifecycle, but that object is not a coroutine. For example, we are writing an Android application and launch various coroutines in the context of an Android activity to perform asynchronous operations to fetch and update data, do animations, etc. All of these coroutines must be cancelled when activity is destroyed to avoid memory leaks. We, of course, can manipulate contexts and jobs manually to tie activity's and coroutines lifecycles, but &lt;code&gt;kotlinx.coroutines&lt;/code&gt; provides an abstraction that encapsulates that: &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-coroutine-scope/index.html&quot;&gt;CoroutineScope&lt;/a&gt;. You should be already familiar with coroutine scope as all coroutine builders are declared as extensions on it.</source>
          <target state="translated">상황, 아동 및 직업에 대한 지식을 함께합시다. 애플리케이션에 수명주기가있는 객체가 있지만 해당 객체가 코 루틴이 아니라고 가정합니다. 예를 들어, Android 애플리케이션을 작성하고 Android 활동의 컨텍스트에서 다양한 코 루틴을 시작하여 데이터를 가져오고 업데이트하기위한 비동기 작업을 수행하고 애니메이션을 수행하는 등의 작업을 수행해야합니다. 메모리 누수를 피하기 위해 이러한 코 루틴은 활동이 파괴 될 때 취소해야합니다. . 물론 활동과 코 루틴 라이프 사이클을 묶기 위해 컨텍스트와 작업을 수동으로 조작 할 수 있지만 &lt;code&gt;kotlinx.coroutines&lt;/code&gt; 는 다음을 캡슐화하는 추상화를 제공합니다. &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-coroutine-scope/index.html&quot;&gt;CoroutineScope&lt;/a&gt; . 모든 코 루틴 빌더는 확장으로 선언되므로 코 루틴 범위에 대해 이미 알고 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="f17004be77e3f7094989ac66ca7a6fcece2d7637" translate="yes" xml:space="preserve">
          <source>Let us run it all seven times:</source>
          <target state="translated">우리가 일곱 번 모두 실행하자</target>
        </trans-unit>
        <trans-unit id="887399487cb35f46c356a942974d9aca65f7d75b" translate="yes" xml:space="preserve">
          <source>Let us start a dozen of them with a random delay.</source>
          <target state="translated">무작위 지연으로 12 개를 시작하겠습니다.</target>
        </trans-unit>
        <trans-unit id="413db7e1244403c1e2eef1bc015d6f2b29e5c10d" translate="yes" xml:space="preserve">
          <source>Let us take &lt;a href=&quot;#concurrent-using-async&quot;&gt;Concurrent using async&lt;/a&gt; example and extract a function that concurrently performs &lt;code&gt;doSomethingUsefulOne&lt;/code&gt; and &lt;code&gt;doSomethingUsefulTwo&lt;/code&gt; and returns the sum of their results. Because &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/async.html&quot;&gt;async&lt;/a&gt; coroutines builder is defined as extension on &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/coroutine-scope.html&quot;&gt;CoroutineScope&lt;/a&gt; we need to have it in the scope and that is what &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/coroutine-scope.html&quot;&gt;coroutineScope&lt;/a&gt; function provides:</source>
          <target state="translated">&lt;a href=&quot;#concurrent-using-async&quot;&gt;비동기&lt;/a&gt; 예제를 사용하여 Concurrent를 가져 와서 &lt;code&gt;doSomethingUsefulOne&lt;/code&gt; 과 &lt;code&gt;doSomethingUsefulTwo&lt;/code&gt; 를 동시에 수행 하고 결과의 합계를 반환 하는 함수를 추출 합시다 . 때문에 &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/async.html&quot;&gt;비동기&lt;/a&gt; 에 대한 확장으로 정의 빌더 코 루틴 &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/coroutine-scope.html&quot;&gt;CoroutineScope&lt;/a&gt; 우리는 범위에 있고 그 무엇을 필요 &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/coroutine-scope.html&quot;&gt;coroutineScope의&lt;/a&gt; 기능을 제공합니다 :</target>
        </trans-unit>
        <trans-unit id="4952c7e38d872a3739e9ba60b2855b8019e8b9ca" translate="yes" xml:space="preserve">
          <source>Let us write a channel producer function that consumes a channel of deferred string values, waits for each received deferred value, but only until the next deferred value comes over or the channel is closed. This example puts together &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.channels/on-receive-or-null.html&quot;&gt;onReceiveOrNull&lt;/a&gt; and &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-deferred/on-await.html&quot;&gt;onAwait&lt;/a&gt; clauses in the same &lt;code&gt;select&lt;/code&gt;:</source>
          <target state="translated">지연된 문자열 값의 채널을 소비하고 수신 된 각 지연된 값을 대기하지만 다음 지연된 값이 도달하거나 채널이 닫힐 때까지만 채널 생성기 함수를 작성해 봅시다. 이 예제는 &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.channels/on-receive-or-null.html&quot;&gt;onReceiveOrNull&lt;/a&gt; 및 &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-deferred/on-await.html&quot;&gt;onAwait&lt;/a&gt; 절을 동일한 &lt;code&gt;select&lt;/code&gt; 에 넣습니다 .</target>
        </trans-unit>
        <trans-unit id="4731fc0f08644e9fc8c26a8f5800aec92b69f2ee" translate="yes" xml:space="preserve">
          <source>Let us write an example of producer of integers that sends its values to a &lt;code&gt;side&lt;/code&gt; channel when the consumers on its primary channel cannot keep up with it:</source>
          <target state="translated">기본 채널의 소비자가 따라갈 수없는 경우 값을 &lt;code&gt;side&lt;/code&gt; 채널 로 보내는 정수 생산자의 예를 작성해 보겠습니다 .</target>
        </trans-unit>
        <trans-unit id="9ad40ae1c76d7921aa80d947aae7e4174122ffe9" translate="yes" xml:space="preserve">
          <source>Let's also make sure that our coroutines actually run in parallel. If we add a 1-second &lt;code&gt;delay()&lt;/code&gt; to each of the &lt;code&gt;async&lt;/code&gt;'s, the resulting program won't run for 1'000'000 seconds (over 11,5 days):</source>
          <target state="translated">코 루틴이 실제로 병렬로 실행되는지 확인합시다. 각 &lt;code&gt;async&lt;/code&gt; 1 초 &lt;code&gt;delay()&lt;/code&gt; 을 추가 하면 결과 프로그램은 1,000,000 초 (11,5 일 이상) 동안 실행되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="d5f68d829cd771ce134770e031cf5bf3966ac35a" translate="yes" xml:space="preserve">
          <source>Let's assume in the code above that &lt;code&gt;preparePost&lt;/code&gt; is a long-running process and consequently would block the user interface. What we can do is launch it in a separate thread. This would then allow us to avoid the UI from blocking. This is a very common technique, but has a series of drawbacks:</source>
          <target state="translated">위의 코드에서 &lt;code&gt;preparePost&lt;/code&gt; 는 오래 실행되는 프로세스이며 결과적으로 사용자 인터페이스를 차단 한다고 가정합니다 . 우리가 할 수있는 일은 별도의 스레드에서 시작하는 것입니다. 그러면 UI가 차단되는 것을 피할 수 있습니다. 이것은 매우 일반적인 기술이지만 몇 가지 단점이 있습니다.</target>
        </trans-unit>
        <trans-unit id="0b36e6d9aeacb6946bbe6f44c31eebe2f8d34c7f" translate="yes" xml:space="preserve">
          <source>Let's call the framework from Objective-C. For that we create the &lt;code&gt;main.m&lt;/code&gt; file with the following content:</source>
          <target state="translated">Objective-C에서 프레임 워크를 호출 해 봅시다. 이를 위해 다음 내용으로 &lt;code&gt;main.m&lt;/code&gt; 파일을 만듭니다 .</target>
        </trans-unit>
        <trans-unit id="de2db89a9bd54d886863702055b65232c802ea65" translate="yes" xml:space="preserve">
          <source>Let's check out the C API of our Kotlin library.`</source>
          <target state="translated">Kotlin 라이브러리의 C API를 확인하십시오 .`</target>
        </trans-unit>
        <trans-unit id="ccdc7274b76228eb418fb01b25e4e0b2b1a04fe1" translate="yes" xml:space="preserve">
          <source>Let's click on the &lt;code&gt;App&lt;/code&gt; run configuration to get our project running either on a real Android Device or on the emulator.</source>
          <target state="translated">&lt;code&gt;App&lt;/code&gt; 실행 구성을 클릭 하여 실제 Android 기기 또는 에뮬레이터에서 프로젝트를 실행하십시오.</target>
        </trans-unit>
        <trans-unit id="1f650b1ab54a0b4e48ce9f7def949cc9e4127516" translate="yes" xml:space="preserve">
          <source>Let's click the &lt;em&gt;Run&lt;/em&gt; button in Xcode, and we'll see our application running</source>
          <target state="translated">Xcode 에서 &lt;em&gt;Run&lt;/em&gt; 버튼을 클릭하면 응용 프로그램이 실행되는 것을 볼 수 있습니다</target>
        </trans-unit>
        <trans-unit id="735664d189535b1add7a525bb222b33a786f953e" translate="yes" xml:space="preserve">
          <source>Let's create a &lt;code&gt;src/nativeMain/kotlin/hello.kt&lt;/code&gt; stub file with the following content to see how C primitive type declarations are visible from Kotlin:</source>
          <target state="translated">하자가 생성 &lt;code&gt;src/nativeMain/kotlin/hello.kt&lt;/code&gt; C 원시 형 선언은 코 틀린에서 볼 수 있습니다 방법을 보려면 다음과 같은 내용으로 스텁 파일 :</target>
        </trans-unit>
        <trans-unit id="10159fd0817061a10325f96cf0c251b77597ee1f" translate="yes" xml:space="preserve">
          <source>Let's create a &lt;code&gt;src/nativeMain/kotlin/hello.kt&lt;/code&gt; stub file with the following content to see how our C declarations are visible from Kotlin:</source>
          <target state="translated">Kotlin에서 C 선언이 어떻게 보이는지 확인하기 위해 다음 내용으로 &lt;code&gt;src/nativeMain/kotlin/hello.kt&lt;/code&gt; 스텁 파일을 만들어 보겠습니다 .</target>
        </trans-unit>
        <trans-unit id="a7acdfe9286fc908f1acf3c36443211f26fc104a" translate="yes" xml:space="preserve">
          <source>Let's create a million coroutines again, keeping their &lt;code&gt;Deferred&lt;/code&gt; objects. Now there's no need in the atomic counter, as we can just return the numbers to be added from our coroutines:</source>
          <target state="translated">&lt;code&gt;Deferred&lt;/code&gt; 객체를 유지하면서 백만 개의 코 루틴을 다시 만들어 봅시다 . 이제 우리는 코 루틴에서 추가 할 숫자를 반환 할 수 있으므로 원자 카운터에는 필요하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="996aed5293f16fb62ea0b0ffc195f181e0ae218e" translate="yes" xml:space="preserve">
          <source>Let's create the class &lt;code&gt;Base64Test&lt;/code&gt; in &lt;code&gt;commonTest/kotlin/jetbrains/base64&lt;/code&gt; folder and write the basic tests for Base64.</source>
          <target state="translated">하자는 클래스 생성 &lt;code&gt;Base64Test&lt;/code&gt; 에 &lt;code&gt;commonTest/kotlin/jetbrains/base64&lt;/code&gt; 폴더를 Base64로에 대한 기본 테스트를 작성.</target>
        </trans-unit>
        <trans-unit id="bbdbbcfe4f2f14866b323983f8f8272c8a107004" translate="yes" xml:space="preserve">
          <source>Let's denote a function f(x) in such a way: we add 1 to x, then, while there is at least one trailing zero in the resulting number, we remove that zero.</source>
          <target state="translated">이런 식으로 함수 f (x)를 표시해 봅시다. x에 1을 더한 다음 결과 숫자에 적어도 하나의 후행 0이있는 동안 해당 0을 제거합니다.</target>
        </trans-unit>
        <trans-unit id="b41c2ae19915325ca1208b1c0d9b4b01df9a8df1" translate="yes" xml:space="preserve">
          <source>Let's dig a little into what it means. The biggest merit of coroutines is that they can &lt;em&gt;suspend&lt;/em&gt; without blocking a thread. The compiler has to emit some special code to make this possible, so we have to mark functions that &lt;em&gt;may suspend&lt;/em&gt; explicitly in the code. We use the &lt;code&gt;suspend&lt;/code&gt; modifier for it:</source>
          <target state="translated">그것이 무엇을 의미하는지 조금 파헤쳐 봅시다. 코 루틴의 가장 큰 장점은 실을 막지 않고 &lt;em&gt;중단&lt;/em&gt; 할 수 있다는 것 입니다. 컴파일러는이를 가능하게하기 위해 특수 코드를 생성해야하므로 코드에서 명시 적으로 &lt;em&gt;일시 중단 될 수있는&lt;/em&gt; 함수를 표시 해야합니다. 우리는 사용 &lt;code&gt;suspend&lt;/code&gt; 그것에 대한 수정 :</target>
        </trans-unit>
        <trans-unit id="b909fa7b179bbce71ededd8361a6bf68ecb8e547" translate="yes" xml:space="preserve">
          <source>Let's extract the block of code inside &lt;code&gt;launch { ... }&lt;/code&gt; into a separate function. When you perform &quot;Extract function&quot; refactoring on this code you get a new function with &lt;code&gt;suspend&lt;/code&gt; modifier. That is your first &lt;em&gt;suspending function&lt;/em&gt;. Suspending functions can be used inside coroutines just like regular functions, but their additional feature is that they can, in turn, use other suspending functions, like &lt;code&gt;delay&lt;/code&gt; in this example, to &lt;em&gt;suspend&lt;/em&gt; execution of a coroutine.</source>
          <target state="translated">&lt;code&gt;launch { ... }&lt;/code&gt; 안의 코드 블록을 별도의 함수로 추출해 봅시다 . 이 코드에서 &quot;추출 기능&quot;리팩토링을 수행하면 &lt;code&gt;suspend&lt;/code&gt; 수정자를 사용 하여 새로운 기능을 얻게 됩니다. 이것이 첫 번째 &lt;em&gt;일시 중단 기능&lt;/em&gt; 입니다. 서 스펜 딩 함수는 일반 함수처럼 코 루틴 내에서 사용할 수 있지만 추가 기능은 이 예제의 &lt;code&gt;delay&lt;/code&gt; 과 같은 다른 서 스펜 딩 함수를 사용 하여 코 루틴 실행 을 &lt;em&gt;일시 중단&lt;/em&gt; 할 수 있다는 것입니다.</target>
        </trans-unit>
        <trans-unit id="e7122eef62315ddd178e19521346dcd7b3d4f4ef" translate="yes" xml:space="preserve">
          <source>Let's first create a project folder. All the paths in this tutorial will be relative to this folder. Sometimes the missing directories will have to be created before new files are added.</source>
          <target state="translated">먼저 프로젝트 폴더를 만들어 봅시다. 이 자습서의 모든 경로는이 폴더를 기준으로합니다. 때때로 새 파일을 추가하기 전에 누락 된 디렉토리를 작성해야합니다.</target>
        </trans-unit>
        <trans-unit id="8cb38e1408559447345a86b525296d1eabcbbd05" translate="yes" xml:space="preserve">
          <source>Let's get straight to the point - type this into a file with the extension &lt;code&gt;.kt&lt;/code&gt;:</source>
          <target state="translated">이것을 &lt;code&gt;.kt&lt;/code&gt; 확장자를 가진 파일로 바로 입력 해 봅시다 :</target>
        </trans-unit>
        <trans-unit id="bd86f7e49e4cf62602c569422996655dedc19452" translate="yes" xml:space="preserve">
          <source>Let's include the dependency from the &lt;code&gt;SharedCode&lt;/code&gt; project to the Android project. We need to patch the &lt;code&gt;app/build.gradle&lt;/code&gt; file and include the following line into the &lt;code&gt;dependencies { .. }&lt;/code&gt; block:</source>
          <target state="translated">&lt;code&gt;SharedCode&lt;/code&gt; 프로젝트에서 Android 프로젝트 로의 종속성을 포함시킵니다 . &lt;code&gt;app/build.gradle&lt;/code&gt; 파일 을 패치하고 다음 행을 &lt;code&gt;dependencies { .. }&lt;/code&gt; 블록에 포함시켜야합니다 .</target>
        </trans-unit>
        <trans-unit id="3031affd63f3a34c70e027c9fb0083b3841cbbd1" translate="yes" xml:space="preserve">
          <source>Let's look at &lt;code&gt;async&lt;/code&gt;/&lt;code&gt;await&lt;/code&gt; which is implemented in an external library, &lt;a href=&quot;https://github.com/kotlin/kotlinx.coroutines&quot;&gt;kotlinx.coroutines&lt;/a&gt;:</source>
          <target state="translated">에서 살펴 보자 &lt;code&gt;async&lt;/code&gt; / &lt;code&gt;await&lt;/code&gt; 를 외부 라이브러리에서 구현되는, &lt;a href=&quot;https://github.com/kotlin/kotlinx.coroutines&quot;&gt;kotlinx.coroutines&lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="957a84aa6afafd513ebe49ba72fc204fd5a6b335" translate="yes" xml:space="preserve">
          <source>Let's look at a full program that uses &lt;code&gt;launch&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;launch&lt;/code&gt; 를 사용하는 전체 프로그램을 살펴 보겠습니다 .</target>
        </trans-unit>
        <trans-unit id="4e571fdb95d6ede65232f8b540598b12acfcf120" translate="yes" xml:space="preserve">
          <source>Let's look over it to spot what has changed. In Java you annotated the field, binding it with the corresponding view:</source>
          <target state="translated">무엇이 바뀌 었는지 찾아 보도록하겠습니다. Java에서는 필드에 주석을 달고 해당 뷰와 바인딩합니다.</target>
        </trans-unit>
        <trans-unit id="1fb40ced67af4648c46e396667df192d29c4d5c8" translate="yes" xml:space="preserve">
          <source>Let's make sure we can run the application on the iPhone emulator or device.</source>
          <target state="translated">iPhone 에뮬레이터 또는 장치에서 응용 프로그램을 실행할 수 있는지 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="4c1369d1fff2907e87dbe0e51a95a4a2b1d68308" translate="yes" xml:space="preserve">
          <source>Let's move the sources file into the &lt;code&gt;src/nativeMain/kotlin&lt;/code&gt; folder under the project. That is the default path, where sources are located, when the &lt;a href=&quot;../../reference/building-mpp-with-gradle&quot;&gt;kotlin-multiplatform&lt;/a&gt; plugin is used. We use the following block to instruct configure the project to generate a dynamic or shared library for us:</source>
          <target state="translated">소스 파일을 프로젝트 아래의 &lt;code&gt;src/nativeMain/kotlin&lt;/code&gt; 폴더로 옮깁니다 . 이것이 &lt;a href=&quot;../../reference/building-mpp-with-gradle&quot;&gt;kotlin-multiplatform&lt;/a&gt; 플러그인이 사용될 때 소스가있는 기본 경로 입니다. 다음 블록을 사용하여 프로젝트가 동적 또는 공유 라이브러리를 생성하도록 구성합니다.</target>
        </trans-unit>
        <trans-unit id="684a72371b803184f7a1d16df5fdf49dd7a6a0de" translate="yes" xml:space="preserve">
          <source>Let's move the sources file into the &lt;code&gt;src/nativeMain/kotlin&lt;/code&gt; folder under the project. This is the default path, for where sources are located, when the &lt;a href=&quot;../../reference/building-mpp-with-gradle&quot;&gt;kotlin-multiplatform&lt;/a&gt; plugin is used. We use the following block to instruct and configure the project to generate a dynamic or shared library for us:</source>
          <target state="translated">소스 파일을 프로젝트 아래의 &lt;code&gt;src/nativeMain/kotlin&lt;/code&gt; 폴더로 옮깁니다 . &lt;a href=&quot;../../reference/building-mpp-with-gradle&quot;&gt;kotlin-multiplatform&lt;/a&gt; 플러그인을 사용할 때 소스가있는 기본 경로 입니다. 다음 블록을 사용하여 프로젝트가 동적 또는 공유 라이브러리를 생성하도록 지시하고 구성합니다.</target>
        </trans-unit>
        <trans-unit id="a942f64f48ea1ece8880513eaa81ddefeb619b0a" translate="yes" xml:space="preserve">
          <source>Let's replace &lt;code&gt;testSolution()&lt;/code&gt; function content with the following:</source>
          <target state="translated">의 교체하자 &lt;code&gt;testSolution()&lt;/code&gt; 는 다음과 기능의 콘텐츠를 :</target>
        </trans-unit>
        <trans-unit id="4a173594d073c26a036c43463ffde9097189a153" translate="yes" xml:space="preserve">
          <source>Let's run a lot of them</source>
          <target state="translated">그들을 많이 봅시다</target>
        </trans-unit>
        <trans-unit id="4b01757c4af3890b2686d482b6ad16159167a6f9" translate="yes" xml:space="preserve">
          <source>Let's run the &lt;code&gt;linkNative&lt;/code&gt; Gradle task to build the library &lt;a href=&quot;basic-kotlin-native-app#run-in-ide&quot;&gt;in the IDE&lt;/a&gt; or by calling the following console command:</source>
          <target state="translated">&lt;code&gt;linkNative&lt;/code&gt; Gradle 태스크를 실행하여 &lt;a href=&quot;basic-kotlin-native-app#run-in-ide&quot;&gt;IDE&lt;/a&gt; 에서 라이브러리를 빌드 하거나 다음 콘솔 명령을 호출하십시오.</target>
        </trans-unit>
        <trans-unit id="ced335cd9fa401cb82913f0326e2577c06919225" translate="yes" xml:space="preserve">
          <source>Let's say that you're writing a simple ORM. Your database library represents a row as instances of a class &lt;code&gt;Entity&lt;/code&gt;, with functions like &lt;code&gt;getString(&quot;name&quot;)&lt;/code&gt; and &lt;code&gt;getLong(&quot;age&quot;)&lt;/code&gt; for getting typed values from the given columns. We could create a typed wrapper class like this:</source>
          <target state="translated">간단한 ORM을 작성한다고 가정 해 봅시다. 데이터베이스 라이브러리는 주어진 열에서 유형이 지정된 값을 가져 오기위한 &lt;code&gt;getString(&quot;name&quot;)&lt;/code&gt; 및 &lt;code&gt;getLong(&quot;age&quot;)&lt;/code&gt; 과 같은 함수를 사용하여 &lt;code&gt;Entity&lt;/code&gt; 클래스의 인스턴스로 행을 나타냅니다 . 다음과 같이 유형이 지정된 래퍼 클래스를 만들 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a18f6d560df8733728d2795ff272c64a409b9516" translate="yes" xml:space="preserve">
          <source>Let's say we need to return two things from a function. For example, a result object and a status of some sort. A compact way of doing this in Kotlin is to declare a &lt;a href=&quot;data-classes&quot;&gt;&lt;em&gt;data class&lt;/em&gt;&lt;/a&gt; and return its instance:</source>
          <target state="translated">함수에서 두 가지를 반환해야한다고 가정 해 봅시다. 예를 들어 결과 개체와 일종의 상태가 있습니다. Kotlin에서이를 수행하는 간단한 방법은 &lt;a href=&quot;data-classes&quot;&gt;&lt;em&gt;데이터 클래스&lt;/em&gt;&lt;/a&gt; 를 선언하고 해당 인스턴스를 반환하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="8eba6223ee182cc016df2825ffe27a1806c3d5dd" translate="yes" xml:space="preserve">
          <source>Let's see how &lt;code&gt;class&lt;/code&gt; and &lt;code&gt;object&lt;/code&gt; are mapped to Objective-C and Swift. The generated &lt;code&gt;&amp;lt;Framework&amp;gt;/Headers/Demo.h&lt;/code&gt; file contains the exact definitions for &lt;code&gt;Class&lt;/code&gt;, &lt;code&gt;Interface&lt;/code&gt;, and &lt;code&gt;Object&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;class&lt;/code&gt; 와 &lt;code&gt;object&lt;/code&gt; 가 Objective-C와 Swift에 어떻게 매핑 되는지 봅시다 . 생성 된 &lt;code&gt;&amp;lt;Framework&amp;gt;/Headers/Demo.h&lt;/code&gt; 파일에는 &lt;code&gt;Class&lt;/code&gt; , &lt;code&gt;Interface&lt;/code&gt; 및 &lt;code&gt;Object&lt;/code&gt; 에 대한 정확한 정의가 포함됩니다 .</target>
        </trans-unit>
        <trans-unit id="2abb7f43d07915bd385a08f6f8eca1904f202535" translate="yes" xml:space="preserve">
          <source>Let's see now &lt;code&gt;CValue&amp;lt;T&amp;gt;&lt;/code&gt; is turned to a pointer first:</source>
          <target state="translated">이제 &lt;code&gt;CValue&amp;lt;T&amp;gt;&lt;/code&gt; 가 먼저 포인터로 바뀝니다 .</target>
        </trans-unit>
        <trans-unit id="0da8a1853bc3aa9296a82e748b06afcd60c8ff39" translate="yes" xml:space="preserve">
          <source>Let's summarize what we have in the table:</source>
          <target state="translated">표에있는 내용을 요약 해 보겠습니다.</target>
        </trans-unit>
        <trans-unit id="29489a663f002abc7aabbc10da61ddf3922c9137" translate="yes" xml:space="preserve">
          <source>Let's switch back to the Android Studio and execute the &lt;code&gt;build&lt;/code&gt; target of the &lt;code&gt;SharedCode&lt;/code&gt; project from the &lt;em&gt;Gradle&lt;/em&gt; tool window. The task looks for environment variables set by the Xcode build and copies the right variant of the framework into the &lt;code&gt;SharedCode/build/xcode-frameworks&lt;/code&gt; folder. We then include the framework from that folder into the build</source>
          <target state="translated">Android Studio로 다시 전환 하고 &lt;em&gt;Gradle&lt;/em&gt; 도구 창 에서 &lt;code&gt;SharedCode&lt;/code&gt; 프로젝트 의 &lt;code&gt;build&lt;/code&gt; 대상을 실행하겠습니다 . 이 작업은 Xcode 빌드에서 설정 한 환경 변수를 찾고 올바른 프레임 워크 변형을 &lt;code&gt;SharedCode/build/xcode-frameworks&lt;/code&gt; 폴더에 복사합니다. 그런 다음 해당 폴더의 프레임 워크를 빌드에 포함시킵니다.&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="aa5c06386e1b74a742a7f7576c52eff2fd2031ee" translate="yes" xml:space="preserve">
          <source>Let's take a look at Kotlin runtime declarations first:</source>
          <target state="translated">Kotlin 런타임 선언을 먼저 살펴 보겠습니다.</target>
        </trans-unit>
        <trans-unit id="0d3a04db62b13c25688a0e50c618e3bec15eb02a" translate="yes" xml:space="preserve">
          <source>Let's take a look at a concrete example.</source>
          <target state="translated">구체적인 예를 살펴 보겠습니다.</target>
        </trans-unit>
        <trans-unit id="d83be9a947c4ef371bac95dfdb52ba3f51a09f86" translate="yes" xml:space="preserve">
          <source>Let's take a look at the &lt;code&gt;kotlin.root.example&lt;/code&gt; field, it mimics the package structure of our Kotlin code with a &lt;code&gt;kotlin.root.&lt;/code&gt; prefix.</source>
          <target state="translated">&lt;code&gt;kotlin.root.example&lt;/code&gt; 필드를 살펴보면 Kotlin 코드의 패키지 구조와 &lt;code&gt;kotlin.root.&lt;/code&gt; 모방합니다 . 접두사.</target>
        </trans-unit>
        <trans-unit id="7a1c41eab269c88a145c3bcd2eacac0f706a1202" translate="yes" xml:space="preserve">
          <source>Let's take a look at the difference between &lt;code&gt;Iterable&lt;/code&gt; and &lt;code&gt;Sequence&lt;/code&gt; with an example.</source>
          <target state="translated">&lt;code&gt;Iterable&lt;/code&gt; 과 &lt;code&gt;Sequence&lt;/code&gt; 의 차이점을 예로 들어 보겠습니다.</target>
        </trans-unit>
        <trans-unit id="683ff410a92468b732cdb32c98685fb25b7caa78" translate="yes" xml:space="preserve">
          <source>Let's take a look at the generated functions that take our &lt;code&gt;MyStruct&lt;/code&gt; and &lt;code&gt;MyUnion&lt;/code&gt; as parameters. We see that by-value parameters are represented as &lt;code&gt;kotlinx.cinterop.CValue&amp;lt;T&amp;gt;&lt;/code&gt;. And for typed pointer parameters we see &lt;code&gt;kotlinx.cinterop.CValuesRef&amp;lt;T&amp;gt;&lt;/code&gt;. Kotlin provides us with an API to deal with both types easily, let's try it and see.</source>
          <target state="translated">&lt;code&gt;MyStruct&lt;/code&gt; 와 &lt;code&gt;MyUnion&lt;/code&gt; 을 매개 변수 로 사용하는 생성 된 함수를 살펴 보겠습니다 . &lt;code&gt;kotlinx.cinterop.CValue&amp;lt;T&amp;gt;&lt;/code&gt; 매개 변수는 kotlinx.cinterop.CValue &amp;lt;T&amp;gt; 로 표시됩니다 . 그리고 입력 된 포인터 매개 변수의 경우 &lt;code&gt;kotlinx.cinterop.CValuesRef&amp;lt;T&amp;gt;&lt;/code&gt; 됩니다. Kotlin은 두 가지 유형을 쉽게 처리 할 수있는 API를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="640f277dd088f13964789f8075c590d21d6b9dfc" translate="yes" xml:space="preserve">
          <source>Let's take pipelines to the extreme with an example that generates prime numbers using a pipeline of coroutines. We start with an infinite sequence of numbers.</source>
          <target state="translated">코 루틴 파이프 라인을 사용하여 소수를 생성하는 예제를 통해 파이프 라인을 최대한 활용 해 봅시다. 우리는 무한한 숫자 시퀀스로 시작합니다.</target>
        </trans-unit>
        <trans-unit id="3a85f4e1e0328af1a77f3960a6412ca2106e30f9" translate="yes" xml:space="preserve">
          <source>Let's try the same with coroutines:</source>
          <target state="translated">코 루틴으로 동일하게 시도하십시오.</target>
        </trans-unit>
        <trans-unit id="7edcd7d839fe1e0dfdcd3a0fe161ec6c231e6fb0" translate="yes" xml:space="preserve">
          <source>Let's try to use the API from Kotlin. Let's call &lt;code&gt;pass_string&lt;/code&gt; first:</source>
          <target state="translated">Kotlin의 API를 사용해 봅시다. 먼저 &lt;code&gt;pass_string&lt;/code&gt; 을 호출 해 봅시다 :</target>
        </trans-unit>
        <trans-unit id="0627f0965e7ec33cbf1e065c2d05108d4f888350" translate="yes" xml:space="preserve">
          <source>Let's update the Gradle scripts now to implement that and configure our IDE.</source>
          <target state="translated">이를 구현하고 IDE를 구성하기 위해 Gradle 스크립트를 지금 업데이트하십시오.</target>
        </trans-unit>
        <trans-unit id="cd1102ed7118f5a51e4a3d98942ad07717eaabd4" translate="yes" xml:space="preserve">
          <source>Let's use it with channel &lt;code&gt;a&lt;/code&gt; that produces &quot;Hello&quot; string four times and channel &lt;code&gt;b&lt;/code&gt; that produces &quot;World&quot; four times:</source>
          <target state="translated">의 채널을 함께 사용하자 에 &quot;Hello&quot;문자열을 네 번 채널 생성 &lt;code&gt;b&lt;/code&gt; 네 번 &quot;세계&quot;를 생성합니다 &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="9dbe6646e8e9a0c1dd5558c986bbdc08c0c317a1" translate="yes" xml:space="preserve">
          <source>Let's walk through the interfaces and their implementations.</source>
          <target state="translated">인터페이스와 해당 구현을 살펴 보겠습니다.</target>
        </trans-unit>
        <trans-unit id="83d65fd8bdf3a04f906b52d7b1ba67e299c6332e" translate="yes" xml:space="preserve">
          <source>Let's walk through the mechanisms of implementing type-safe builders in Kotlin. First of all, we need to define the model we want to build, in this case we need to model HTML tags. It is easily done with a bunch of classes. For example, &lt;code&gt;HTML&lt;/code&gt; is a class that describes the &lt;code&gt;&amp;lt;html&amp;gt;&lt;/code&gt; tag, i.e. it defines children like &lt;code&gt;&amp;lt;head&amp;gt;&lt;/code&gt; and &lt;code&gt;&amp;lt;body&amp;gt;&lt;/code&gt;. (See its declaration &lt;a href=&quot;#full-definition-of-the-comexamplehtml-package&quot;&gt;below&lt;/a&gt;.)</source>
          <target state="translated">Kotlin에서 형식 안전 빌더를 구현하는 메커니즘을 살펴 보겠습니다. 우선, 빌드하려는 모델을 정의해야합니다.이 경우 HTML 태그를 모델링해야합니다. 많은 클래스로 쉽게 수행됩니다. 예를 들어 &lt;code&gt;HTML&lt;/code&gt; 은 &lt;code&gt;&amp;lt;html&amp;gt;&lt;/code&gt; 태그 를 설명하는 클래스입니다 . 즉 &lt;code&gt;&amp;lt;head&amp;gt;&lt;/code&gt; 및 &lt;code&gt;&amp;lt;body&amp;gt;&lt;/code&gt; 와 같은 자식을 정의합니다 . ( &lt;a href=&quot;#full-definition-of-the-comexamplehtml-package&quot;&gt;아래&lt;/a&gt; 선언 참조 )</target>
        </trans-unit>
        <trans-unit id="7c7f5d049fad2569721d446c4a811f9bd5da5393" translate="yes" xml:space="preserve">
          <source>Level</source>
          <target state="translated">Level</target>
        </trans-unit>
        <trans-unit id="27c968e6692b41bf6e1a241b870dc41ff1a51b17" translate="yes" xml:space="preserve">
          <source>Libraries</source>
          <target state="translated">Libraries</target>
        </trans-unit>
        <trans-unit id="74fbbbbc56ff7a0c7c22c830abedb5e3565e5058" translate="yes" xml:space="preserve">
          <source>Library authors can use the @Deprecated and @Experimental annotations to control the evolution of their API surface. Note that @Deprecated(level=HIDDEN) can be used to preserve binary compatibility even for declarations removed from the API.</source>
          <target state="translated">라이브러리 작성자는 @Deprecated 및 @Experimental 주석을 사용하여 API 표면의 진화를 제어 할 수 있습니다. @Deprecated (level = HIDDEN)를 사용하여 API에서 제거 된 선언의 경우에도 이진 호환성을 유지할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0405ca8057bdd26aa8a71ed5b78eaef11cd20a80" translate="yes" xml:space="preserve">
          <source>Library code should always specify return types of public/protected functions and properties explicitly thus never relying on type inference for public API. Subtle changes in type inference may cause return types to change inadvertently, leading to binary compatibility issues.</source>
          <target state="translated">라이브러리 코드는 항상 반환 유형의 공개 / 보호 함수 및 속성을 명시 적으로 지정해야하므로 공개 API의 유형 유추에 의존하지 않습니다. 형식 유추의 미묘한 변경으로 인해 반환 형식이 실수로 변경되어 이진 호환성 문제가 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2fc01b5cc1b2ec00feddd7cb533ccfb023b55321" translate="yes" xml:space="preserve">
          <source>Library search sequence</source>
          <target state="translated">도서관 검색 순서</target>
        </trans-unit>
        <trans-unit id="141acdd651d31f900ce141517e6e5b768c6f9865" translate="yes" xml:space="preserve">
          <source>Library support for the Kotlin annotation facility.</source>
          <target state="translated">Kotlin 주석 기능에 대한 라이브러리 지원</target>
        </trans-unit>
        <trans-unit id="ec793eb7fd1d6c9106d97e622f4fcbf89e666960" translate="yes" xml:space="preserve">
          <source>Licensed under the Apache License, Version 2.0.</source>
          <target state="translated">Apache 라이센스, 버전 2.0에 따라 라이센스가 부여되었습니다.</target>
        </trans-unit>
        <trans-unit id="8ca0dc8586d3cb640a4422d4f36e3b18f79a2fc2" translate="yes" xml:space="preserve">
          <source>Like Java's, Kotlin's generics are not retained at runtime, i.e. objects do not carry information about actual type arguments passed to their constructors, i.e. &lt;code&gt;ArrayList&amp;lt;Integer&amp;gt;()&lt;/code&gt; is indistinguishable from &lt;code&gt;ArrayList&amp;lt;Character&amp;gt;()&lt;/code&gt;. This makes it impossible to perform &lt;em&gt;is&lt;/em&gt;-checks that take generics into account. Kotlin only allows &lt;em&gt;is&lt;/em&gt;-checks for star-projected generic types:</source>
          <target state="translated">Java와 마찬가지로 Kotlin의 제네릭은 런타임에 유지되지 않습니다. 즉 객체는 생성자에 전달 된 실제 유형 인수에 대한 정보를 전달하지 않습니다. 즉 &lt;code&gt;ArrayList&amp;lt;Integer&amp;gt;()&lt;/code&gt; 는 &lt;code&gt;ArrayList&amp;lt;Character&amp;gt;()&lt;/code&gt; 구별 할 수 없습니다 . 이것은 불가능 수행하기가 만드는 &lt;em&gt;것입니다&lt;/em&gt; 계정으로 제네릭을 -checks. 단지 수 있습니다 코 틀린은 &lt;em&gt;이다&lt;/em&gt; 스타 투영 일반적인 유형의 -checks :</target>
        </trans-unit>
        <trans-unit id="134fca0c09908f36860692b90dc834d35d2666e9" translate="yes" xml:space="preserve">
          <source>Like in Python, functions in Kotlin are first-class values - they can be assigned to variables and passed around as parameters. The type a function is a &lt;em&gt;function type&lt;/em&gt;, which is indicated with a parenthesized parameter type list and an arrow to the return type. Consider this function:</source>
          <target state="translated">Python과 마찬가지로 Kotlin의 함수는 일류 값입니다. 변수에 할당하고 매개 변수로 전달할 수 있습니다. &lt;em&gt;함수 유형&lt;/em&gt; 은 &lt;em&gt;함수 유형&lt;/em&gt; 이며 괄호로 묶은 매개 변수 유형 목록과 리턴 유형에 대한 화살표로 표시됩니다. 이 기능을 고려하십시오.</target>
        </trans-unit>
        <trans-unit id="4ddd56354c9749dcb1f4e69de6ab93bcbbe060ca" translate="yes" xml:space="preserve">
          <source>Like in Python, statements may be terminated by a semicolon, but it's discouraged. There is no line continuation character; instead, a line is automatically joined with one or more of the subsequent lines if that's the only way to make the code parse correctly. In practice, that means that a statement continues on the next line if we're inside an open parenthesis (like in Python), or if the line ends with a &quot;dangling operator&quot; (unlike in Python) or the following line doesn't parse unless it's joined to the previous one (also unlike in Python). Note that this is pretty much &lt;a href=&quot;https://stackoverflow.com/questions/2846283/what-are-the-rules-for-javascripts-automatic-semicolon-insertion-asi#2846298&quot;&gt;the opposite of JavaScript&lt;/a&gt;, which generally will keep joining lines as long as the resulting code still parses. Thus, the following is two expressions in Kotlin and in Python (because &lt;code&gt;+&lt;/code&gt; can be unary, so the second line parses on its own), but one in JavaScript:</source>
          <target state="translated">파이썬에서와 같이 문장은 세미콜론으로 끝날 수 있지만 권장하지 않습니다. 줄 연속 문자가 없습니다. 대신 코드가 올바르게 구문 분석 할 수있는 유일한 방법 인 경우 하나 이상의 후속 행과 함께 행이 자동으로 결합됩니다. 실제로 이것은 파이썬에서와 같이 열린 괄호 안에 있거나 줄이 &quot;댕글 링 연산자&quot;(파이썬 에서와는 달리)로 끝나거나 다음 줄이 그렇지 않으면 다음 줄에서 계속됩니다. 이전과 결합되지 않은 경우 구문 분석하십시오 (Python과 달리). 이것은 &lt;a href=&quot;https://stackoverflow.com/questions/2846283/what-are-the-rules-for-javascripts-automatic-semicolon-insertion-asi#2846298&quot;&gt;JavaScript&lt;/a&gt; 와 반대입니다 . 결과 코드가 여전히 구문 분석되는 한 일반적으로 줄을 계속 연결합니다. 따라서 다음은 Kotlin과 Python에서 두 가지 표현입니다 ( &lt;code&gt;+&lt;/code&gt; 단항 일 수 있으므로 두 번째 줄은 자체적으로 구문 분석되지만 JavaScript에서는 하나입니다.</target>
        </trans-unit>
        <trans-unit id="36d262d6365f0d350e9446c742577b066fb40895" translate="yes" xml:space="preserve">
          <source>Like in Python, you can write &lt;em&gt;lambda expressions&lt;/em&gt;: unnamed function declarations with a very compact syntax, which evaluate to callable function objects. In Kotlin, lambdas can contain multiple statements, which make them useful for &lt;a href=&quot;functional-programming#receivers&quot;&gt;more complex tasks&lt;/a&gt; than the single-expression lambdas of Python. The last statement must be an expression, whose result will become the return value of the lambda (unless &lt;code&gt;Unit&lt;/code&gt; is the return type of the variable/parameter that the lambda expression is assigned to, in which case the lambda has no return value). A lambda expression is enclosed in curly braces, and begins by listing its parameter names and possibly their types (unless the types can be inferred from context):</source>
          <target state="translated">파이썬에서와 같이 &lt;em&gt;람다 식을&lt;/em&gt; 작성할 수 있습니다 . 호출 가능한 함수 객체로 평가되는 매우 간단한 구문으로 명명되지 않은 함수 선언입니다. Kotlin에서 람다는 여러 명령문을 포함 할 수 있으므로 단일 표현식 람다보다 &lt;a href=&quot;functional-programming#receivers&quot;&gt;복잡한 작업에&lt;/a&gt; 유용합니다 . 마지막 명령문은 표현식이어야하며 결과는 람다의 리턴 값이됩니다 ( &lt;code&gt;Unit&lt;/code&gt; 가 람다 표현식이 지정된 변수 / 매개 변수의 리턴 유형이 아닌 경우 람다는 리턴 값이 없음). 람다 식은 중괄호로 묶고 매개 변수 이름과 가능한 형식을 나열하여 시작합니다 (형식이 컨텍스트에서 유추되지 않는 한).</target>
        </trans-unit>
        <trans-unit id="4ee83e74db24116986fa00ee2921b9703634e255" translate="yes" xml:space="preserve">
          <source>Like numbers, characters are boxed when a nullable reference is needed. Identity is not preserved by the boxing operation.</source>
          <target state="translated">숫자와 마찬가지로 널 입력 가능 참조가 필요할 때 문자가 상자로 표시됩니다. 복싱 작업으로 ID가 유지되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="dc3b674f534270e494afa035103eb57b636704df" translate="yes" xml:space="preserve">
          <source>Likewise, if a multiplatform library is published in the experimental &lt;a href=&quot;#experimental-metadata-publishing-mode&quot;&gt;Gradle metadata publishing mode&lt;/a&gt; and the project is set up to consume the metadata as well, then it is enough to specify a dependency only once, for the common source set. Otherwise, each platform-specific source set should be provided with a corresponding platform module of the library, in addition to the common module, as shown above.</source>
          <target state="translated">마찬가지로 멀티 플랫폼 라이브러리가 실험적인 &lt;a href=&quot;#experimental-metadata-publishing-mode&quot;&gt;Gradle 메타 데이터 게시 모드로 게시&lt;/a&gt; 되고 프로젝트가 메타 데이터도 사용하도록 설정된 경우 공통 소스 세트에 대해 종속성을 한 번만 지정하면 충분합니다. 그렇지 않은 경우, 각 플랫폼 별 소스 세트에는 위에 표시된대로 공통 모듈 외에 라이브러리의 해당 플랫폼 모듈이 제공되어야합니다.</target>
        </trans-unit>
        <trans-unit id="a7c04c64ed3f2a9374590c76c50d3b7f1b18e3da" translate="yes" xml:space="preserve">
          <source>Limitations</source>
          <target state="translated">Limitations</target>
        </trans-unit>
        <trans-unit id="f8233d6f380a149df94d518228f2e14afd396052" translate="yes" xml:space="preserve">
          <source>Linear search</source>
          <target state="translated">선형 검색</target>
        </trans-unit>
        <trans-unit id="b867f8dc43342a216856620ba5a0d8c96b534757" translate="yes" xml:space="preserve">
          <source>Link the library into the application</source>
          <target state="translated">라이브러리를 응용 프로그램에 연결</target>
        </trans-unit>
        <trans-unit id="0084b300581a4369f50268c2c401f96431ea7f31" translate="yes" xml:space="preserve">
          <source>LinkStyle</source>
          <target state="translated">LinkStyle</target>
        </trans-unit>
        <trans-unit id="07410b317023eeb58eba0c065fa4e8416575a68f" translate="yes" xml:space="preserve">
          <source>LinkedHashMap</source>
          <target state="translated">LinkedHashMap</target>
        </trans-unit>
        <trans-unit id="9e6a957a7c69081b233af13d7e01702499988584" translate="yes" xml:space="preserve">
          <source>LinkedHashSet</source>
          <target state="translated">LinkedHashSet</target>
        </trans-unit>
        <trans-unit id="778915b1ca69b860077b72be4fd2810162ac2e59" translate="yes" xml:space="preserve">
          <source>Linking to Elements</source>
          <target state="translated">요소에 연결</target>
        </trans-unit>
        <trans-unit id="ff0484f6287dafcb08eb0a886ac73a7153824af7" translate="yes" xml:space="preserve">
          <source>Linux (x86_64, arm32, MIPS, MIPS little endian, Raspberry Pi)</source>
          <target state="translated">Linux (x86_64, arm32, MIPS, MIPS 리틀 엔디안, 라즈베리 파이)</target>
        </trans-unit>
        <trans-unit id="430e92ad771f5c7d80b45e64d2d47aa39cd97e1b" translate="yes" xml:space="preserve">
          <source>Linux MIPS targets (&lt;code&gt;linuxMips32&lt;/code&gt; and &lt;code&gt;linuxMipsel32&lt;/code&gt;) require a Linux host. Other Linux targets can be built on any supported host;</source>
          <target state="translated">Linux MIPS 대상 ( &lt;code&gt;linuxMips32&lt;/code&gt; 및 &lt;code&gt;linuxMipsel32&lt;/code&gt; )에는 Linux 호스트가 필요합니다. 지원되는 모든 호스트에 다른 Linux 대상을 구축 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="bfb299cccd6e6b52b05aad6a92f9e230c0c907cf" translate="yes" xml:space="preserve">
          <source>Linux: &lt;code&gt;libnative_api.h&lt;/code&gt; and &lt;code&gt;libnative.so&lt;/code&gt;</source>
          <target state="translated">Linux : &lt;code&gt;libnative_api.h&lt;/code&gt; 및 &lt;code&gt;libnative.so&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="a1fffaaafb7cc996685bceb829c053cc4f7de43d" translate="yes" xml:space="preserve">
          <source>List</source>
          <target state="translated">List</target>
        </trans-unit>
        <trans-unit id="1cf922153258f477bc71540c57fe2b01a501cd22" translate="yes" xml:space="preserve">
          <source>List Specific Operations</source>
          <target state="translated">특정 작업 목록</target>
        </trans-unit>
        <trans-unit id="a159771f6ea4355d13f8450d01c0373e1562c782" translate="yes" xml:space="preserve">
          <source>List elements (including nulls) can duplicate: a list can contain any number of equal objects or occurrences of a single object. Two lists are considered equal if they have the same sizes and &lt;a href=&quot;equality#structural-equality&quot;&gt;structurally equal&lt;/a&gt; elements at the same positions.</source>
          <target state="translated">목록 요소 (널 포함)는 복제 할 수 있습니다. 목록은 동일한 수의 동일한 객체 또는 단일 객체의 발생을 포함 할 수 있습니다. 동일한 위치에 동일한 크기와 &lt;a href=&quot;equality#structural-equality&quot;&gt;구조적으로 동일한&lt;/a&gt; 요소 가있는 경우 두 목록은 동일한 것으로 간주됩니다 .</target>
        </trans-unit>
        <trans-unit id="06c25d6b7dd57683933b41c5deaf09d2d0ac5990" translate="yes" xml:space="preserve">
          <source>List iterators</source>
          <target state="translated">반복자 목록</target>
        </trans-unit>
        <trans-unit id="18c411381841a95d683318d92c209a2833825015" translate="yes" xml:space="preserve">
          <source>List write operations</source>
          <target state="translated">쓰기 작업 목록</target>
        </trans-unit>
        <trans-unit id="7c5f57edf1aaa5196cbc6ba79770c80aef15f3e5" translate="yes" xml:space="preserve">
          <source>List.listIterator</source>
          <target state="translated">List.listIterator</target>
        </trans-unit>
        <trans-unit id="48fb7de1e7f4ec62a77ab4aa73ec82916ebe8c3e" translate="yes" xml:space="preserve">
          <source>ListIterator</source>
          <target state="translated">ListIterator</target>
        </trans-unit>
        <trans-unit id="a204aa282b7f9617db30e92246b8efaf427d19cd" translate="yes" xml:space="preserve">
          <source>Lists also offer a function to replace an element at a given position - &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/-mutable-list/set&quot;&gt;&lt;code&gt;set()&lt;/code&gt;&lt;/a&gt; and its operator form &lt;code&gt;[]&lt;/code&gt;. &lt;code&gt;set()&lt;/code&gt; doesn't change the indexes of other elements.</source>
          <target state="translated">리스트는 또한 주어진 위치에서 요소를 대체하는 함수를 제공합니다. &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/-mutable-list/set&quot;&gt; &lt;code&gt;set()&lt;/code&gt; &lt;/a&gt; 과 연산자 형태 &lt;code&gt;[]&lt;/code&gt; . &lt;code&gt;set()&lt;/code&gt; 은 다른 요소의 인덱스를 변경하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="290d0482de491a9f1d45c4e717b747b40f336dfe" translate="yes" xml:space="preserve">
          <source>Lists and sets also provide operations for updating elements. They are described in &lt;a href=&quot;list-operations&quot;&gt;List Specific Operations&lt;/a&gt; and &lt;a href=&quot;map-operations&quot;&gt;Map Specific Operations&lt;/a&gt;. For sets, updating doesn't make sense since it's actually removing an element and adding another one.</source>
          <target state="translated">목록과 집합은 또한 요소 업데이트를위한 작업을 제공합니다. 이에 대해서는 &lt;a href=&quot;list-operations&quot;&gt;List Specific Operations&lt;/a&gt; 및 &lt;a href=&quot;map-operations&quot;&gt;Map Specific Operations에&lt;/a&gt; 설명되어 있습니다. 세트의 경우 업데이트는 실제로 요소를 제거하고 다른 요소를 추가하기 때문에 의미가 없습니다.</target>
        </trans-unit>
        <trans-unit id="f70b0e65f09114560be2730b53b6dbbae2e2bd80" translate="yes" xml:space="preserve">
          <source>Lists support all common operations for element retrieval: &lt;code&gt;elementAt()&lt;/code&gt;, &lt;code&gt;first()&lt;/code&gt;, &lt;code&gt;last()&lt;/code&gt;, and others listed in &lt;a href=&quot;collection-elements&quot;&gt;Retrieving Single Elements&lt;/a&gt;. What is specific for lists is index access to the elements, so the simplest way to read an element is retrieving it by index. That is done with the &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/-list/get&quot;&gt;&lt;code&gt;get()&lt;/code&gt;&lt;/a&gt; function with the index passed in the argument or the shorthand &lt;code&gt;[index]&lt;/code&gt; syntax.</source>
          <target state="translated">리스트는 &lt;code&gt;elementAt()&lt;/code&gt; , &lt;code&gt;first()&lt;/code&gt; , &lt;code&gt;last()&lt;/code&gt; 및 &lt;a href=&quot;collection-elements&quot;&gt;단일 요소 검색에&lt;/a&gt; 나열된 기타 요소 검색에 대한 모든 공통 조작을 지원합니다 . 목록에 특정한 것은 요소에 대한 인덱스 액세스이므로 요소를 읽는 가장 간단한 방법은 인덱스로 요소를 검색하는 것입니다. 인수 또는 속기 &lt;code&gt;[index]&lt;/code&gt; 구문으로 전달 된 색인으로 &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/-list/get&quot;&gt; &lt;code&gt;get()&lt;/code&gt; &lt;/a&gt; 함수를 사용하여 수행됩니다 .</target>
        </trans-unit>
        <trans-unit id="1b8cc7b0ac11bf88cf97ed5fc81444ae44893988" translate="yes" xml:space="preserve">
          <source>Literal Constants</source>
          <target state="translated">리터럴 상수</target>
        </trans-unit>
        <trans-unit id="c7ba7dcf662374aafe652b03d75cb8f6024519d9" translate="yes" xml:space="preserve">
          <source>Literals</source>
          <target state="translated">Literals</target>
        </trans-unit>
        <trans-unit id="a354c605a19a501459267f5d2d15e3813a2622ea" translate="yes" xml:space="preserve">
          <source>Local Delegated Properties (since 1.1)</source>
          <target state="translated">로컬 위임 속성 (1.1 이후)</target>
        </trans-unit>
        <trans-unit id="f5689c7ad8ad393161f3aa4e09dcfcbe8dae0b7c" translate="yes" xml:space="preserve">
          <source>Local Functions</source>
          <target state="translated">지역 기능</target>
        </trans-unit>
        <trans-unit id="d7250510c8081d4daaa6df727eb914db9c33da3c" translate="yes" xml:space="preserve">
          <source>Local annotation classes</source>
          <target state="translated">지역 주석 클래스</target>
        </trans-unit>
        <trans-unit id="69ebd822a58983be422bb598dba3c478ccd777d9" translate="yes" xml:space="preserve">
          <source>Local declarations</source>
          <target state="translated">지역 선언</target>
        </trans-unit>
        <trans-unit id="a1899e5981d8e839cbbac5a4b6b87631ee259818" translate="yes" xml:space="preserve">
          <source>Local delegated properties</source>
          <target state="translated">로컬 위임 속성</target>
        </trans-unit>
        <trans-unit id="bcdcbb7562bc0be9df365ffa539169787154eb55" translate="yes" xml:space="preserve">
          <source>Local function can access local variables of outer functions (i.e. the closure), so in the case above, the &lt;em&gt;visited&lt;/em&gt; can be a local variable:</source>
          <target state="translated">로컬 함수는 외부 함수의 로컬 변수 (예 : 클로저)에 액세스 할 수 있으므로 위의 경우 &lt;em&gt;방문한&lt;/em&gt; 로컬 변수가 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7a8cbb48d88b807f7bfba9d309d29524b5f02383" translate="yes" xml:space="preserve">
          <source>Local variable</source>
          <target state="translated">지역 변수</target>
        </trans-unit>
        <trans-unit id="e41667e2ac3ba5cde0fdffb1b6bacda9d66718d9" translate="yes" xml:space="preserve">
          <source>Local variables are typically declared and initialized at the same time, in which case the type of the variable is &lt;em&gt;inferred&lt;/em&gt; to be the type of the expression you initialize it with:</source>
          <target state="translated">지역 변수는 일반적으로 선언하고 변수의 타입이되는 경우에 같은 시간에 초기화 &lt;em&gt;유추&lt;/em&gt; 당신이 초기화 식의 유형으로 :</target>
        </trans-unit>
        <trans-unit id="ac8a58b4422a8352e1dd6a3c1ee5296717d9a865" translate="yes" xml:space="preserve">
          <source>Local variables, functions and classes can not have visibility modifiers.</source>
          <target state="translated">지역 변수, 함수 및 클래스는 가시성 수정자를 가질 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="a78aea5b0abb85e3e611fbf1ec8a29dd64f3f7a3" translate="yes" xml:space="preserve">
          <source>LocaleOptions</source>
          <target state="translated">LocaleOptions</target>
        </trans-unit>
        <trans-unit id="d219c68101f532de10add2cf42fb9dbeca73d3be" translate="yes" xml:space="preserve">
          <source>Location</source>
          <target state="translated">Location</target>
        </trans-unit>
        <trans-unit id="4a56ee9bffd6aa6b4bd69f9a8fcf34ef4736447e" translate="yes" xml:space="preserve">
          <source>Locks are used to ensure that only a single thread can initialize the &lt;a href=&quot;../-lazy/index&quot;&gt;Lazy&lt;/a&gt; instance.</source>
          <target state="translated">잠금은 단일 스레드 만 &lt;a href=&quot;../-lazy/index&quot;&gt;Lazy&lt;/a&gt; 인스턴스를 초기화 할 수 있도록하는 데 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="0003a9c1d32ac7d8fddd983e062e51e3d0daa934" translate="yes" xml:space="preserve">
          <source>Logarithms: &lt;code&gt;log&lt;/code&gt;, &lt;code&gt;log2&lt;/code&gt;, &lt;code&gt;log10&lt;/code&gt;, &lt;code&gt;ln&lt;/code&gt;, &lt;code&gt;ln1p&lt;/code&gt;;</source>
          <target state="translated">로그 : &lt;code&gt;log&lt;/code&gt; , &lt;code&gt;log2&lt;/code&gt; , &lt;code&gt;log10&lt;/code&gt; , &lt;code&gt;ln&lt;/code&gt; , &lt;code&gt;ln1p&lt;/code&gt; ;</target>
        </trans-unit>
        <trans-unit id="3496a775372b202cf19086b7723a8ba07a1c1c15" translate="yes" xml:space="preserve">
          <source>Logos can be downloaded &lt;a href=&quot;https://resources.jetbrains.com/storage/products/kotlin/docs/kotlin_logos.zip&quot;&gt;here&lt;/a&gt;. When using the logos, please follow simple rules in the &lt;code&gt;guidelines.pdf&lt;/code&gt; inside the archive and &lt;a href=&quot;https://kotlinlang.org/foundation/guidelines.html&quot;&gt;Kotlin brand usage guidelines&lt;/a&gt;.</source>
          <target state="translated">로고는 &lt;a href=&quot;https://resources.jetbrains.com/storage/products/kotlin/docs/kotlin_logos.zip&quot;&gt;여기에서&lt;/a&gt; 다운로드 할 수 있습니다 . 로고를 사용하는 경우 아카이브 및 &lt;a href=&quot;https://kotlinlang.org/foundation/guidelines.html&quot;&gt;Kotlin 브랜드 사용 가이드 &lt;/a&gt; &lt;code&gt;guidelines.pdf&lt;/code&gt; 안에있는 Guidelines.pdf의 간단한 규칙을 따르십시오 .</target>
        </trans-unit>
        <trans-unit id="3171584f38872fa4d8f17811d91544f7756eaffd" translate="yes" xml:space="preserve">
          <source>Lombok (&lt;code&gt;lombok.NonNull&lt;/code&gt;).</source>
          <target state="translated">롬복 ( &lt;code&gt;lombok.NonNull&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="11eda67f9b15a760342f8e98a3fc78d8d3ea9945" translate="yes" xml:space="preserve">
          <source>Long</source>
          <target state="translated">Long</target>
        </trans-unit>
        <trans-unit id="28da0e058738129fbcd7e6f45b76bc71f8a53660" translate="yes" xml:space="preserve">
          <source>LongArray</source>
          <target state="translated">LongArray</target>
        </trans-unit>
        <trans-unit id="4fccaadf63b5fc52428c158f51d57e23e947d24e" translate="yes" xml:space="preserve">
          <source>LongIterator</source>
          <target state="translated">LongIterator</target>
        </trans-unit>
        <trans-unit id="5845d554e07454310db9770fb728d9756ce6dae1" translate="yes" xml:space="preserve">
          <source>LongProgression</source>
          <target state="translated">LongProgression</target>
        </trans-unit>
        <trans-unit id="4fb8ec4ef48e7913a58002b0e63b73c29bff9f39" translate="yes" xml:space="preserve">
          <source>LongRange</source>
          <target state="translated">LongRange</target>
        </trans-unit>
        <trans-unit id="0b1c8c87dc520b4e01071e91d1f6a9ceb7e0e408" translate="yes" xml:space="preserve">
          <source>LongVar</source>
          <target state="translated">LongVar</target>
        </trans-unit>
        <trans-unit id="181cf892b1895d898b9744877c740407129f49dc" translate="yes" xml:space="preserve">
          <source>LongVarOf</source>
          <target state="translated">LongVarOf</target>
        </trans-unit>
        <trans-unit id="fd6299f672ee9cc3b8def57411eb0d0d9a44147d" translate="yes" xml:space="preserve">
          <source>Longs are tagged by a capital &lt;code&gt;L&lt;/code&gt;: &lt;code&gt;123L&lt;/code&gt;</source>
          <target state="translated">Long은 대문자 &lt;code&gt;L&lt;/code&gt; : &lt;code&gt;123L&lt;/code&gt; 로 태그됩니다</target>
        </trans-unit>
        <trans-unit id="3e38e907fc0523189431e466a50de278a09267fc" translate="yes" xml:space="preserve">
          <source>Looking for more APIs? It is easy to create a &lt;a href=&quot;../multiplatform-library&quot;&gt;multiplatform library&lt;/a&gt; and share it!</source>
          <target state="translated">더 많은 API를 찾고 계십니까? &lt;a href=&quot;../multiplatform-library&quot;&gt;멀티 플랫폼 라이브러리&lt;/a&gt; 를 작성 하고 공유 하기가 쉽습니다 !</target>
        </trans-unit>
        <trans-unit id="0c661eae6b65f74e27c40369060777e2f1a666bd" translate="yes" xml:space="preserve">
          <source>Looks up a function &lt;code&gt;inc()&lt;/code&gt; with the &lt;code&gt;operator&lt;/code&gt; modifier and no parameters, applicable to the receiver of type &lt;code&gt;T&lt;/code&gt;;</source>
          <target state="translated">&lt;code&gt;T&lt;/code&gt; 유형의 수신자에게 적용 가능한 매개 변수없이 &lt;code&gt;operator&lt;/code&gt; 수정자를 사용하여 &lt;code&gt;inc()&lt;/code&gt; 함수를 찾습니다 .</target>
        </trans-unit>
        <trans-unit id="06f3cb08bca38254cb72407f33d24848ac5110e5" translate="yes" xml:space="preserve">
          <source>Looks up a function &lt;code&gt;unaryPlus()&lt;/code&gt; with the &lt;code&gt;operator&lt;/code&gt; modifier and no parameters for the receiver &lt;code&gt;T&lt;/code&gt;, i.e. a member function or an extension function;</source>
          <target state="translated">함수 보인다 &lt;code&gt;unaryPlus()&lt;/code&gt; 와 &lt;code&gt;operator&lt;/code&gt; 개질제 및 수신기에 대한 매개 변수 &lt;code&gt;T&lt;/code&gt; , 즉 멤버 함수 또는 신장 기능;</target>
        </trans-unit>
        <trans-unit id="02720f9d38bf4f35e84ed5228689898bee176418" translate="yes" xml:space="preserve">
          <source>Loops</source>
          <target state="translated">Loops</target>
        </trans-unit>
        <trans-unit id="4c2bd8b7625ef46e049dcc97f3e97069511fe26a" translate="yes" xml:space="preserve">
          <source>Loops on ranges</source>
          <target state="translated">범위의 루프</target>
        </trans-unit>
        <trans-unit id="60369ad7d8b48a14f3d191172cf41bcfb71741f2" translate="yes" xml:space="preserve">
          <source>Low-level building blocks for libraries that provide coroutine-based APIs.</source>
          <target state="translated">코 루틴 기반 API를 제공하는 라이브러리의 저수준 빌딩 블록.</target>
        </trans-unit>
        <trans-unit id="33c64772edef0388f14ce1b4adb0c6c1bb1aa8e4" translate="yes" xml:space="preserve">
          <source>Luckily, Kotlin has got &lt;em&gt;reified type parameters&lt;/em&gt;, which alleviates some of these problems. By writing &lt;code&gt;reified&lt;/code&gt; in front of a generic type parameter, it does become available at runtime, and you'll get to write &lt;code&gt;T::class&lt;/code&gt; to get the &lt;a href=&quot;member-references-and-reflection#obtaining-member-references-from-a-class-reference&quot;&gt;class metadata&lt;/a&gt;. You can only do this in inline functions (because an inline function will be compiled into its callsite, where the type information &lt;em&gt;is&lt;/em&gt; available at runtime), but it still goes a long way. For example, you can make an inline wrapper function for a big function that has got a less elegant signature.</source>
          <target state="translated">운좋게도 Kotlin은 &lt;em&gt;형식 매개 변수를 수정&lt;/em&gt; 하여 이러한 문제 중 일부를 완화했습니다. 제네릭 형식 매개 변수 앞에 &lt;code&gt;reified&lt;/code&gt; 를 작성 하면 런타임에 사용할 수 있게되고 &lt;a href=&quot;member-references-and-reflection#obtaining-member-references-from-a-class-reference&quot;&gt;클래스 메타 데이터&lt;/a&gt; 를 가져 오기 위해 &lt;code&gt;T::class&lt;/code&gt; 를 작성하게 됩니다. 인라인 함수에서만이 작업을 수행 할 수 있습니다 (인라인 함수는 런타임에 유형 정보 &lt;em&gt;를&lt;/em&gt; 사용할 수 있는 콜 사이트로 컴파일되기 때문에 ). 예를 들어, 덜 우아한 서명을 가진 큰 함수에 대해 인라인 랩퍼 함수를 ​​작성할 수 있습니다.&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="2dc6e5580de3bf07607e19a673cd1f05b259b2bd" translate="yes" xml:space="preserve">
          <source>MACOSX</source>
          <target state="translated">MACOSX</target>
        </trans-unit>
        <trans-unit id="c8341a27b6d81ce4872ef2e5c74c71c1fa656185" translate="yes" xml:space="preserve">
          <source>MATH_SYMBOL</source>
          <target state="translated">MATH_SYMBOL</target>
        </trans-unit>
        <trans-unit id="ccd2cb474249294edd8d61576efe0ac7d7c17d4c" translate="yes" xml:space="preserve">
          <source>MAX_CODE_POINT</source>
          <target state="translated">MAX_CODE_POINT</target>
        </trans-unit>
        <trans-unit id="1a9fd1b3912908145111964e328d77ecf366fc06" translate="yes" xml:space="preserve">
          <source>MAX_COMPONENT_VALUE</source>
          <target state="translated">MAX_COMPONENT_VALUE</target>
        </trans-unit>
        <trans-unit id="6a3f20e248cb8672ba053480b2e5604ed15471fb" translate="yes" xml:space="preserve">
          <source>MAX_HIGH_SURROGATE</source>
          <target state="translated">MAX_HIGH_SURROGATE</target>
        </trans-unit>
        <trans-unit id="93b95c89e3f09a5c822039fdb274e4e9543f7b4d" translate="yes" xml:space="preserve">
          <source>MAX_LOW_SURROGATE</source>
          <target state="translated">MAX_LOW_SURROGATE</target>
        </trans-unit>
        <trans-unit id="723df4d178ea35581b90fb4dff97fa4d9e1295a6" translate="yes" xml:space="preserve">
          <source>MAX_RADIX</source>
          <target state="translated">MAX_RADIX</target>
        </trans-unit>
        <trans-unit id="e1273ad446270c0c9cf3fd5cad44848e8250ffba" translate="yes" xml:space="preserve">
          <source>MAX_SURROGATE</source>
          <target state="translated">MAX_SURROGATE</target>
        </trans-unit>
        <trans-unit id="24fdbf54e8bc77709b6bd7478c1804e90d84d0ca" translate="yes" xml:space="preserve">
          <source>MAX_VALUE</source>
          <target state="translated">MAX_VALUE</target>
        </trans-unit>
        <trans-unit id="030147a88935a9397a9625c627fb1af71a30209e" translate="yes" xml:space="preserve">
          <source>MF</source>
          <target state="translated">MF</target>
        </trans-unit>
        <trans-unit id="c93eded712b6299da78db6d4eb86c71d455d7389" translate="yes" xml:space="preserve">
          <source>MIN_CODE_POINT</source>
          <target state="translated">MIN_CODE_POINT</target>
        </trans-unit>
        <trans-unit id="a8865ad11853a6b46e09f6d1cdddfd073f7d4851" translate="yes" xml:space="preserve">
          <source>MIN_HIGH_SURROGATE</source>
          <target state="translated">MIN_HIGH_SURROGATE</target>
        </trans-unit>
        <trans-unit id="bd2ef64ddf3863a50e14b7b72bf632b54603d300" translate="yes" xml:space="preserve">
          <source>MIN_LOW_SURROGATE</source>
          <target state="translated">MIN_LOW_SURROGATE</target>
        </trans-unit>
        <trans-unit id="91631ed7ebe4f66d93a855f168fd993a18bbb9ae" translate="yes" xml:space="preserve">
          <source>MIN_RADIX</source>
          <target state="translated">MIN_RADIX</target>
        </trans-unit>
        <trans-unit id="ff3ed914be4d85796f20ffe750d11ae41f0c093d" translate="yes" xml:space="preserve">
          <source>MIN_SUPPLEMENTARY_CODE_POINT</source>
          <target state="translated">MIN_SUPPLEMENTARY_CODE_POINT</target>
        </trans-unit>
        <trans-unit id="5aa1c9c7ed6ef1169c3e694d2e0558e797993672" translate="yes" xml:space="preserve">
          <source>MIN_SURROGATE</source>
          <target state="translated">MIN_SURROGATE</target>
        </trans-unit>
        <trans-unit id="ac7a7603646aca67877b81e10b36687c24f7d10a" translate="yes" xml:space="preserve">
          <source>MIN_VALUE</source>
          <target state="translated">MIN_VALUE</target>
        </trans-unit>
        <trans-unit id="9028a909c025cf9d16590fd055950504b793f600" translate="yes" xml:space="preserve">
          <source>MIPS32</source>
          <target state="translated">MIPS32</target>
        </trans-unit>
        <trans-unit id="ac1d1ed5dec64feab585fa1220864d5680a5811e" translate="yes" xml:space="preserve">
          <source>MIPSEL32</source>
          <target state="translated">MIPSEL32</target>
        </trans-unit>
        <trans-unit id="7b5afc2e6529ad3bd8e57a7791978e690003bcdd" translate="yes" xml:space="preserve">
          <source>MODIFIER_LETTER</source>
          <target state="translated">MODIFIER_LETTER</target>
        </trans-unit>
        <trans-unit id="8f6a3829c268c3a50caa5a3744901aba89c88358" translate="yes" xml:space="preserve">
          <source>MODIFIER_SYMBOL</source>
          <target state="translated">MODIFIER_SYMBOL</target>
        </trans-unit>
        <trans-unit id="84757851065b4eb5ddf781037790225276f37d3e" translate="yes" xml:space="preserve">
          <source>MULTILINE</source>
          <target state="translated">MULTILINE</target>
        </trans-unit>
        <trans-unit id="37a6f811775e72996553c62c5ef2ab8e4e658bea" translate="yes" xml:space="preserve">
          <source>MacOS (x86_64)</source>
          <target state="translated">맥 OS (x86_64)</target>
        </trans-unit>
        <trans-unit id="07a4d61f0acbbb95318a8a2d2e1f3a3b76934273" translate="yes" xml:space="preserve">
          <source>MacPorts</source>
          <target state="translated">MacPorts</target>
        </trans-unit>
        <trans-unit id="899bd694d29ace1be956ab35177075021977560b" translate="yes" xml:space="preserve">
          <source>Macros</source>
          <target state="translated">Macros</target>
        </trans-unit>
        <trans-unit id="c22d87ecdb73737e3e9e79d9b2b16c5c79a06654" translate="yes" xml:space="preserve">
          <source>Make sure its return type is &lt;code&gt;Unit&lt;/code&gt;, and report an error otherwise,</source>
          <target state="translated">반환 유형이 &lt;code&gt;Unit&lt;/code&gt; 인지 확인하고 그렇지 않으면 오류를보고하십시오.</target>
        </trans-unit>
        <trans-unit id="2fba991ad8d6b5e98b20f4c1f0a7d640d19bbf4f" translate="yes" xml:space="preserve">
          <source>Make sure that you have CocoaPods &lt;a href=&quot;https://guides.cocoapods.org/using/getting-started.html#installation&quot;&gt;installed&lt;/a&gt;. We recommend using CocoaPods 1.6.1 or later.</source>
          <target state="translated">CocoaPods가 &lt;a href=&quot;https://guides.cocoapods.org/using/getting-started.html#installation&quot;&gt;설치되어&lt;/a&gt; 있는지 확인하십시오 . CocoaPods 1.6.1 이상을 사용하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="872ea4c8c9e3e67462cf45519bbed3ec439a01dd" translate="yes" xml:space="preserve">
          <source>Make sure that you load the &lt;code&gt;kotlin.js&lt;/code&gt; runtime first, and then your application.</source>
          <target state="translated">먼저 &lt;code&gt;kotlin.js&lt;/code&gt; 런타임 을로드 한 다음 애플리케이션 을로드하십시오 .</target>
        </trans-unit>
        <trans-unit id="eb5ad277768300cd65b74ec021eb800da7b06237" translate="yes" xml:space="preserve">
          <source>Make updating to new versions comfortable for the users.</source>
          <target state="translated">사용자에게 편안한 새 버전으로 업데이트하십시오.</target>
        </trans-unit>
        <trans-unit id="f677748d219b353836ae9469d4c8eb0bcdf46ffb" translate="yes" xml:space="preserve">
          <source>Makes Kotlin method in Objective-C class accessible through Objective-C dispatch to be used as action sent by control in UIKit or AppKit.</source>
          <target state="translated">Objective-C 디스패치를 ​​통해 Objective-C 클래스의 Kotlin 메소드에 액세스하여 UIKit 또는 AppKit의 제어에 의해 전송 된 조치로 사용되도록합니다.</target>
        </trans-unit>
        <trans-unit id="09f808d1435cc07cd95f3ecbee1a2efed0c87454" translate="yes" xml:space="preserve">
          <source>Makes Kotlin property in Objective-C class settable through Objective-C dispatch to be used as IB outlet.</source>
          <target state="translated">Objective-C 디스패치를 ​​통해 Objective-C 클래스의 Kotlin 속성을 IB 콘센트로 사용할 수 있도록 설정합니다.</target>
        </trans-unit>
        <trans-unit id="79cbb2384899cfe766ce2633e3ff22d2f36982b6" translate="yes" xml:space="preserve">
          <source>Makes Kotlin subclass of Objective-C class visible for runtime lookup after Kotlin &lt;code&gt;main&lt;/code&gt; function gets invoked.</source>
          <target state="translated">Kotlin &lt;code&gt;main&lt;/code&gt; 함수가 호출 된 후 런타임 조회에 Objective-C 클래스의 Kotlin 서브 클래스를 표시합니다 .</target>
        </trans-unit>
        <trans-unit id="c05c0a0b46c6d81aa3deae4e473b3f5b195d9dae" translate="yes" xml:space="preserve">
          <source>Makes top level function available from C/C++ code with the given name.</source>
          <target state="translated">주어진 이름으로 C / C ++ 코드에서 최상위 레벨 기능을 사용할 수있게합니다.</target>
        </trans-unit>
        <trans-unit id="3dc9b78fb75740d031749aa0e1f6c2f20915be09" translate="yes" xml:space="preserve">
          <source>Making computation code cancellable</source>
          <target state="translated">계산 코드를 취소 가능하게 만들기</target>
        </trans-unit>
        <trans-unit id="d26e8b17246e39f5acbd44ce84cfe44e4708e7bc" translate="yes" xml:space="preserve">
          <source>Making frequent null checks is annoying, so if you have to allow for the possibility of nulls, there are several very useful operators in Kotlin to ease working with values that might be null, as described below.</source>
          <target state="translated">빈번한 null 검사는 성가신 일이므로 null 가능성을 허용 해야하는 경우 Kotlin에는 아래에 설명 된 것처럼 null 일 수있는 값을 쉽게 사용할 수있는 몇 가지 매우 유용한 연산자가 있습니다.</target>
        </trans-unit>
        <trans-unit id="f35727fd1febb5955e04a96a85cfbf28b11e18a0" translate="yes" xml:space="preserve">
          <source>Malformed byte sequences are replaced by the replacement char &lt;code&gt;\uFFFD&lt;/code&gt;.</source>
          <target state="translated">잘못된 바이트 시퀀스는 교체 char &lt;code&gt;\uFFFD&lt;/code&gt; 로 대체됩니다 .</target>
        </trans-unit>
        <trans-unit id="b2aee73bd2e79677bed872d3980e254bec42f2c5" translate="yes" xml:space="preserve">
          <source>Managing dependencies</source>
          <target state="translated">의존성 관리</target>
        </trans-unit>
        <trans-unit id="f45216dfe5658802d5da85dd6691495f1dd5ee41" translate="yes" xml:space="preserve">
          <source>Managing sources</source>
          <target state="translated">소스 관리</target>
        </trans-unit>
        <trans-unit id="b0426429a44f47228605bdec162f6e1798c46d34" translate="yes" xml:space="preserve">
          <source>Managing targets</source>
          <target state="translated">대상 관리</target>
        </trans-unit>
        <trans-unit id="dc1586db5c7b55a74cd10223f2e3a7fe8bf95caa" translate="yes" xml:space="preserve">
          <source>Mangling</source>
          <target state="translated">Mangling</target>
        </trans-unit>
        <trans-unit id="76f58e9ae1ecc3bcd5734ccddd0e7976cd032c5b" translate="yes" xml:space="preserve">
          <source>Manual Configuration</source>
          <target state="translated">수동 구성</target>
        </trans-unit>
        <trans-unit id="724adbdc3ff0031b5c79ad867a79546b920a65f6" translate="yes" xml:space="preserve">
          <source>Manual Install</source>
          <target state="translated">수동 설치</target>
        </trans-unit>
        <trans-unit id="65a73e4ea7721ba692baf916576f5d262d09eb6e" translate="yes" xml:space="preserve">
          <source>Many modern IDEs support Kotlin and help in writing idiomatic Kotlin code:</source>
          <target state="translated">많은 최신 IDE가 Kotlin을 지원하고 관용적 인 Kotlin 코드 작성을 도와줍니다.</target>
        </trans-unit>
        <trans-unit id="564f728d4accd1cab1faa6abd0808aa411a7afbc" translate="yes" xml:space="preserve">
          <source>Many of the options can also be configured through properties:</source>
          <target state="translated">속성을 통해 많은 옵션을 구성 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="ab478f3efc840eebab919dff1b9512286f70c10c" translate="yes" xml:space="preserve">
          <source>Map</source>
          <target state="translated">Map</target>
        </trans-unit>
        <trans-unit id="1a3e682ff2754ef0b1db9651d934d18042efd51a" translate="yes" xml:space="preserve">
          <source>Map Specific Operations</source>
          <target state="translated">특정 작업지도</target>
        </trans-unit>
        <trans-unit id="8a55ba4dc9c56793f4d86eafccdf893ff4dfc510" translate="yes" xml:space="preserve">
          <source>Map nullable value if not null</source>
          <target state="translated">널이 아닌 경우 널 입력 가능 값 맵핑</target>
        </trans-unit>
        <trans-unit id="154baeb185088267d2e04dd13fb49c8faf1731b4" translate="yes" xml:space="preserve">
          <source>Map write operations</source>
          <target state="translated">지도 쓰기 작업</target>
        </trans-unit>
        <trans-unit id="7c78455b5524d54dd5717439fdd75a3564e3b05c" translate="yes" xml:space="preserve">
          <source>Map.getValue()</source>
          <target state="translated">Map.getValue()</target>
        </trans-unit>
        <trans-unit id="ab6d914f12b0209ae12f1eaa021fab679f71fbd9" translate="yes" xml:space="preserve">
          <source>Map.minus(key)</source>
          <target state="translated">Map.minus(key)</target>
        </trans-unit>
        <trans-unit id="a1e3b9de38695948c83390c6219ada2b49d0eb03" translate="yes" xml:space="preserve">
          <source>Map.toMap() and Map.toMutableMap()</source>
          <target state="translated">Map.toMap () 및 Map.toMutableMap ()</target>
        </trans-unit>
        <trans-unit id="f5503e0acfd60752001069a9088cb22064b114de" translate="yes" xml:space="preserve">
          <source>Mapped types</source>
          <target state="translated">매핑 된 유형</target>
        </trans-unit>
        <trans-unit id="def2eba59562958fa4a005f8070d692ef8502312" translate="yes" xml:space="preserve">
          <source>Mapping</source>
          <target state="translated">Mapping</target>
        </trans-unit>
        <trans-unit id="ae3c45c6220c54a755f63c613acc1f9b440f728e" translate="yes" xml:space="preserve">
          <source>Mapping Function Pointer Types from C</source>
          <target state="translated">C에서 함수 포인터 유형 매핑</target>
        </trans-unit>
        <trans-unit id="3629da3c88dfc6308c1eb31a6616f2493b1b3a4a" translate="yes" xml:space="preserve">
          <source>Mapping Function Pointers from C</source>
          <target state="translated">C에서 함수 포인터 매핑</target>
        </trans-unit>
        <trans-unit id="1ab023f41f65f5d65722a6148006ad3ade089fb2" translate="yes" xml:space="preserve">
          <source>Mapping Primitive Data Types from C</source>
          <target state="translated">C에서 기본 데이터 유형 매핑</target>
        </trans-unit>
        <trans-unit id="d6b4467553c4b4c986cbd21872e97a3c8e8ea762" translate="yes" xml:space="preserve">
          <source>Mapping Strings from C</source>
          <target state="translated">C에서 문자열 매핑</target>
        </trans-unit>
        <trans-unit id="76a029f685d2ba76aaeecfdb2224f273ebee328a" translate="yes" xml:space="preserve">
          <source>Mapping Struct and Union C types</source>
          <target state="translated">구조 및 유니온 C 유형 매핑</target>
        </trans-unit>
        <trans-unit id="565e074c9f98132ef0f9b4a1395ca391399b5fc8" translate="yes" xml:space="preserve">
          <source>Mapping Struct and Union Types from C</source>
          <target state="translated">C에서 구조 및 결합 유형 매핑</target>
        </trans-unit>
        <trans-unit id="1cbcdd98d1b5744757244f463b7f939b4869f3e4" translate="yes" xml:space="preserve">
          <source>Mappings</source>
          <target state="translated">Mappings</target>
        </trans-unit>
        <trans-unit id="4811d5bdec38d0b9bed7265f0e3355c78194b1ff" translate="yes" xml:space="preserve">
          <source>Marker interface indicating that the &lt;a href=&quot;-list/index#kotlin.collections.List&quot;&gt;List&lt;/a&gt; implementation supports fast indexed access.</source>
          <target state="translated">&lt;a href=&quot;-list/index#kotlin.collections.List&quot;&gt;List&lt;/a&gt; 구현이 빠른 인덱스 액세스를 지원함을 나타내는 마커 인터페이스 .</target>
        </trans-unit>
        <trans-unit id="79f92c6a2f9b55de94523a0137df26f32b271fc3" translate="yes" xml:space="preserve">
          <source>Marker interface indicating that the &lt;a href=&quot;../../kotlin.collections/-list/index#kotlin.collections.List&quot;&gt;List&lt;/a&gt; implementation supports fast indexed access.</source>
          <target state="translated">&lt;a href=&quot;../../kotlin.collections/-list/index#kotlin.collections.List&quot;&gt;List&lt;/a&gt; 구현이 빠른 인덱스 액세스를 지원함을 나타내는 마커 인터페이스 .</target>
        </trans-unit>
        <trans-unit id="deb9ed7bb61b8698d73e57af565358059241e0bd" translate="yes" xml:space="preserve">
          <source>Marking API elements</source>
          <target state="translated">마킹 API 요소</target>
        </trans-unit>
        <trans-unit id="39acae63028d11938c7d9a75f3ad9099e5f79972" translate="yes" xml:space="preserve">
          <source>Marking experimental API</source>
          <target state="translated">실험용 API 마킹</target>
        </trans-unit>
        <trans-unit id="72ca39cc361248a73db4aa376ff098d3162e32bf" translate="yes" xml:space="preserve">
          <source>Marking rules: an implicit receiver is considered marked with @Ann if</source>
          <target state="translated">표시 규칙 : 암시 적 수신자는 @Ann으로 표시된 것으로 간주됩니다.</target>
        </trans-unit>
        <trans-unit id="33d0711db8fea3ba5bf0ebfba79cfe0cf8264458" translate="yes" xml:space="preserve">
          <source>Marks a top level variable with a backing field or an object as immutable. It is possible to share such object between multiple threads, but it becomes deeply frozen, so no changes can be made to its state or the state of objects it refers to.</source>
          <target state="translated">백킹 필드 또는 객체가있는 최상위 변수를 변경할 수없는 것으로 표시합니다. 이러한 스레드를 여러 스레드간에 공유 할 수는 있지만 완전히 고정되므로 상태 또는 참조하는 오브젝트의 상태를 변경할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="9c86911fdb83bb1e6cafe3509aa437cd672c34a9" translate="yes" xml:space="preserve">
          <source>Marks a top level variable with a backing field or an object as thread local. The object remains mutable and it is possible to change its state, but every thread will have a distinct copy of this object, so changes in one thread are not reflected in another.</source>
          <target state="translated">백킹 필드 또는 객체를 스레드 로컬로 사용하여 최상위 변수를 표시합니다. 객체는 변경 가능 상태를 유지하고 상태를 변경할 수 있지만 모든 스레드는이 객체의 고유 한 복사본을 가지므로 한 스레드의 변경 사항은 다른 스레드에 반영되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="6ec4d266890af2cb0a6aa9e1810055ba658008f8" translate="yes" xml:space="preserve">
          <source>Marks an expected annotation class that it isn't required to have actual counterparts in all platforms.</source>
          <target state="translated">예상되는 주석 클래스를 표시하여 모든 플랫폼에서 실제로 대응할 필요는 없습니다.</target>
        </trans-unit>
        <trans-unit id="5c6f17834ff35593c5226191e98557d99d755e77" translate="yes" xml:space="preserve">
          <source>Marks coroutine context element that intercepts coroutine continuations. The coroutines framework uses &lt;a href=&quot;-continuation-interceptor/-key&quot;&gt;ContinuationInterceptor.Key&lt;/a&gt; to retrieve the interceptor and intercepts all coroutine continuations with &lt;a href=&quot;-continuation-interceptor/intercept-continuation&quot;&gt;interceptContinuation&lt;/a&gt; invocations.</source>
          <target state="translated">코 루틴 연속을 가로채는 코 루틴 컨텍스트 요소를 표시합니다. 코 루틴 프레임 워크는 &lt;a href=&quot;-continuation-interceptor/-key&quot;&gt;ContinuationInterceptor.Key&lt;/a&gt; 를 사용 하여 인터셉터를 검색하고 &lt;a href=&quot;-continuation-interceptor/intercept-continuation&quot;&gt;interceptContinuation&lt;/a&gt; 호출로 모든 코 루틴 연속을 인터셉트 합니다.</target>
        </trans-unit>
        <trans-unit id="292a3151e7a72885408caf9ee437ad5d8673be4a" translate="yes" xml:space="preserve">
          <source>Marks coroutine context element that intercepts coroutine continuations. The coroutines framework uses &lt;a href=&quot;-key&quot;&gt;ContinuationInterceptor.Key&lt;/a&gt; to retrieve the interceptor and intercepts all coroutine continuations with &lt;a href=&quot;intercept-continuation&quot;&gt;interceptContinuation&lt;/a&gt; invocations.</source>
          <target state="translated">코 루틴 연속을 가로채는 코 루틴 컨텍스트 요소를 표시합니다. 코 루틴 프레임 워크는 &lt;a href=&quot;-key&quot;&gt;ContinuationInterceptor.Key&lt;/a&gt; 를 사용 하여 인터셉터를 검색하고 &lt;a href=&quot;intercept-continuation&quot;&gt;interceptContinuation&lt;/a&gt; 호출로 모든 코 루틴 연속을 인터셉트 합니다.</target>
        </trans-unit>
        <trans-unit id="5be31e799227d8931dded0eeace958d0a3e43418" translate="yes" xml:space="preserve">
          <source>Marks coroutine context element that intercepts coroutine continuations. The coroutines framework uses &lt;a href=&quot;../../kotlin.coroutines.experimental/-continuation-interceptor/-key&quot;&gt;ContinuationInterceptor.Key&lt;/a&gt; to retrieve the interceptor and intercepts all coroutine continuations with &lt;a href=&quot;../../kotlin.coroutines.experimental/-continuation-interceptor/intercept-continuation&quot;&gt;interceptContinuation&lt;/a&gt; invocations.</source>
          <target state="translated">코 루틴 연속을 가로채는 코 루틴 컨텍스트 요소를 표시합니다. 코 루틴 프레임 워크는 &lt;a href=&quot;../../kotlin.coroutines.experimental/-continuation-interceptor/-key&quot;&gt;ContinuationInterceptor.Key&lt;/a&gt; 를 사용 하여 인터셉터를 검색하고 &lt;a href=&quot;../../kotlin.coroutines.experimental/-continuation-interceptor/intercept-continuation&quot;&gt;interceptContinuation&lt;/a&gt; 호출로 모든 코 루틴 연속을 인터셉트 합니다.</target>
        </trans-unit>
        <trans-unit id="589152c67b668bc3a0e5e851927c4f25196aa066" translate="yes" xml:space="preserve">
          <source>Marks coroutine context element that intercepts coroutine continuations. The coroutines framework uses &lt;a href=&quot;../../kotlin.coroutines/-continuation-interceptor/-key&quot;&gt;ContinuationInterceptor.Key&lt;/a&gt; to retrieve the interceptor and intercepts all coroutine continuations with &lt;a href=&quot;../../kotlin.coroutines/-continuation-interceptor/intercept-continuation&quot;&gt;interceptContinuation&lt;/a&gt; invocations.</source>
          <target state="translated">코 루틴 연속을 가로채는 코 루틴 컨텍스트 요소를 표시합니다. 코 루틴 프레임 워크는 &lt;a href=&quot;../../kotlin.coroutines/-continuation-interceptor/-key&quot;&gt;ContinuationInterceptor.Key&lt;/a&gt; 를 사용 하여 인터셉터를 검색하고 &lt;a href=&quot;../../kotlin.coroutines/-continuation-interceptor/intercept-continuation&quot;&gt;interceptContinuation&lt;/a&gt; 호출로 모든 코 루틴 연속을 인터셉트 합니다.</target>
        </trans-unit>
        <trans-unit id="2df77c28828a089a19fdffaa1789ccacc76664f7" translate="yes" xml:space="preserve">
          <source>Marks the API that is dependent on the experimental unsigned types, including those types themselves.</source>
          <target state="translated">실험 자체의 서명되지 않은 유형 (종종 자체 포함)에 종속 된 API를 표시합니다.</target>
        </trans-unit>
        <trans-unit id="73273d6a95cad7e50a139041438fbf00005e8089" translate="yes" xml:space="preserve">
          <source>Marks the JVM backing field of the annotated property as &lt;code&gt;transient&lt;/code&gt;, meaning that it is not part of the default serialized form of the object.</source>
          <target state="translated">어노테이션이있는 특성의 JVM 백업 필드를 &lt;code&gt;transient&lt;/code&gt; 로 표시 합니다. 이는 오브젝트의 기본 직렬화 된 양식의 일부가 아님을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="fd02a709ebd5dfcba6e63db7078d9717fce347a3" translate="yes" xml:space="preserve">
          <source>Marks the JVM backing field of the annotated property as &lt;code&gt;volatile&lt;/code&gt;, meaning that writes to this field are immediately made visible to other threads.</source>
          <target state="translated">어노테이션이있는 특성의 JVM 백업 필드를 &lt;code&gt;volatile&lt;/code&gt; 로 표시합니다. 즉,이 필드에 대한 쓰기가 다른 스레드에 즉시 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="1c403a59019182391a8ff7eb648d56329fc1e05f" translate="yes" xml:space="preserve">
          <source>Marks the JVM method generated from the annotated function as &lt;code&gt;strictfp&lt;/code&gt;, meaning that the precision of floating point operations performed inside the method needs to be restricted in order to achieve better portability.</source>
          <target state="translated">어노테이션이있는 함수에서 생성 된 JVM 메소드를 &lt;code&gt;strictfp&lt;/code&gt; 로 표시합니다. 즉, 더 나은 이식성을 달성하려면 메소드 내에서 수행되는 부동 소수점 연산의 정밀도를 제한해야합니다.</target>
        </trans-unit>
        <trans-unit id="58ecb1a8fc60ff73e8fc37346fd83ecb47a77bf8" translate="yes" xml:space="preserve">
          <source>Marks the JVM method generated from the annotated function as &lt;code&gt;synchronized&lt;/code&gt;, meaning that the method will be protected from concurrent execution by multiple threads by the monitor of the instance (or, for static methods, the class) on which the method is defined.</source>
          <target state="translated">어노테이션이있는 함수에서 생성 된 JVM 메소드를 &lt;code&gt;synchronized&lt;/code&gt; 된 것으로 표시합니다. 즉, 메소드가 정의 된 인스턴스 (또는 정적 메소드의 경우)의 모니터에 의해 메소드가 여러 스레드에 의해 동시 실행되지 않도록 보호됩니다.</target>
        </trans-unit>
        <trans-unit id="fb96fdd73420dc05c701eb6e0838bd95d38438a9" translate="yes" xml:space="preserve">
          <source>Marks the annotated declaration as deprecated.</source>
          <target state="translated">주석이 달린 선언을 더 이상 사용되지 않는 것으로 표시합니다.</target>
        </trans-unit>
        <trans-unit id="849bb03707fb20c75be09bfab7269367951a2e2c" translate="yes" xml:space="preserve">
          <source>MatchGroup</source>
          <target state="translated">MatchGroup</target>
        </trans-unit>
        <trans-unit id="dca62bbed6a25edcb571ec2b8d04d93aa72d3b21" translate="yes" xml:space="preserve">
          <source>MatchGroupCollection</source>
          <target state="translated">MatchGroupCollection</target>
        </trans-unit>
        <trans-unit id="40ee7a3cd8703b1f6d5c39fe97ef7bdbddff913a" translate="yes" xml:space="preserve">
          <source>MatchNamedGroupCollection</source>
          <target state="translated">MatchNamedGroupCollection</target>
        </trans-unit>
        <trans-unit id="e5e10479d7e48ed2ed4d8e1de8fc8b3e40fd01eb" translate="yes" xml:space="preserve">
          <source>MatchResult</source>
          <target state="translated">MatchResult</target>
        </trans-unit>
        <trans-unit id="3edf0df49942da6d11a1a217e4d3af4a5a8e64f2" translate="yes" xml:space="preserve">
          <source>Math</source>
          <target state="translated">Math</target>
        </trans-unit>
        <trans-unit id="386de788c6f8f526adcdfcc95893611a4f0f2a05" translate="yes" xml:space="preserve">
          <source>Math operations in kotlin-stdlib</source>
          <target state="translated">kotlin-stdlib의 수학 연산</target>
        </trans-unit>
        <trans-unit id="0ada0ff6418289ab78ea96388455f7b6c8654ca4" translate="yes" xml:space="preserve">
          <source>Mathematical functions and constants.</source>
          <target state="translated">수학 함수와 상수.</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
