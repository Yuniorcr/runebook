<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="kotlin">
    <body>
      <group id="kotlin">
        <trans-unit id="6af37177e65c1a71744a7cb984d51ba2f07f5140" translate="yes" xml:space="preserve">
          <source>Maven</source>
          <target state="translated">Maven</target>
        </trans-unit>
        <trans-unit id="b522db69b358e8fce0593518fbe3b0d7db36d2d4" translate="yes" xml:space="preserve">
          <source>Maven configuration</source>
          <target state="translated">메이븐 구성</target>
        </trans-unit>
        <trans-unit id="71edee9db1ff5b8ff75c1bfdc3477115c9cadb2f" translate="yes" xml:space="preserve">
          <source>Max value</source>
          <target state="translated">최대 값</target>
        </trans-unit>
        <trans-unit id="6f26174801b4fb329b7b4754a956851117212509" translate="yes" xml:space="preserve">
          <source>Maximum value a version component can have, a constant value 255.</source>
          <target state="translated">버전 구성 요소가 가질 수있는 최대 값, 상수 값 255</target>
        </trans-unit>
        <trans-unit id="258389887a049fd789e8d5c0611eb448fb932cc4" translate="yes" xml:space="preserve">
          <source>MediaDeviceInfo</source>
          <target state="translated">MediaDeviceInfo</target>
        </trans-unit>
        <trans-unit id="6134c6977e97c143c3e4282792a6fe2d4e4a8d3d" translate="yes" xml:space="preserve">
          <source>MediaDeviceKind</source>
          <target state="translated">MediaDeviceKind</target>
        </trans-unit>
        <trans-unit id="5e9d9c4423f0ac299fce82e9517c3425a061ddb4" translate="yes" xml:space="preserve">
          <source>MediaError</source>
          <target state="translated">MediaError</target>
        </trans-unit>
        <trans-unit id="f30d349fe509ab2452d9ff5db776c749eb21115d" translate="yes" xml:space="preserve">
          <source>MediaList</source>
          <target state="translated">MediaList</target>
        </trans-unit>
        <trans-unit id="5264b922a464ea5a9f88144f8b72f9626c1db269" translate="yes" xml:space="preserve">
          <source>MediaQueryListEventInit</source>
          <target state="translated">MediaQueryListEventInit</target>
        </trans-unit>
        <trans-unit id="70dcd56d399d2e12aa2533dd163497d5ff6362fd" translate="yes" xml:space="preserve">
          <source>MediaStreamConstraints</source>
          <target state="translated">MediaStreamConstraints</target>
        </trans-unit>
        <trans-unit id="c74168a0d6b99bbcdaff6005366c94dc042ddd9e" translate="yes" xml:space="preserve">
          <source>MediaStreamTrackEventInit</source>
          <target state="translated">MediaStreamTrackEventInit</target>
        </trans-unit>
        <trans-unit id="f6268479064052c02a6fe8b1b48bf8011df3d770" translate="yes" xml:space="preserve">
          <source>MediaStreamTrackState</source>
          <target state="translated">MediaStreamTrackState</target>
        </trans-unit>
        <trans-unit id="10f95ad72ba533133d954c473a07f3f67fdac829" translate="yes" xml:space="preserve">
          <source>MediaTrackCapabilities</source>
          <target state="translated">MediaTrackCapabilities</target>
        </trans-unit>
        <trans-unit id="bb47b7b2d8ef429be15b6e0dad452a4f8b48f974" translate="yes" xml:space="preserve">
          <source>MediaTrackConstraintSet</source>
          <target state="translated">MediaTrackConstraintSet</target>
        </trans-unit>
        <trans-unit id="8054e6c6485f93790f303ed390e1cba5c2743911" translate="yes" xml:space="preserve">
          <source>MediaTrackConstraints</source>
          <target state="translated">MediaTrackConstraints</target>
        </trans-unit>
        <trans-unit id="43ae2bb87ab91212c29f9b3badd22fa54472dcc6" translate="yes" xml:space="preserve">
          <source>MediaTrackSettings</source>
          <target state="translated">MediaTrackSettings</target>
        </trans-unit>
        <trans-unit id="7e941f3e34c1287f6e0e3fa6973fe4daf92e6bf1" translate="yes" xml:space="preserve">
          <source>MediaTrackSupportedConstraints</source>
          <target state="translated">MediaTrackSupportedConstraints</target>
        </trans-unit>
        <trans-unit id="0821090b6a2b08e3c2088bad74f0cd7597a2e61c" translate="yes" xml:space="preserve">
          <source>MemScope</source>
          <target state="translated">MemScope</target>
        </trans-unit>
        <trans-unit id="13754495aca84346deb594b0d23bc4d086989ee4" translate="yes" xml:space="preserve">
          <source>Member Functions</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2675e87b859fb2d5772f0ea8bf6c203afefdde62" translate="yes" xml:space="preserve">
          <source>Member function names should use &lt;code&gt;lowerCamelCase&lt;/code&gt; instead of &lt;code&gt;snake_case&lt;/code&gt;.</source>
          <target state="translated">멤버 함수 이름은 &lt;code&gt;snake_case&lt;/code&gt; 대신 &lt;code&gt;lowerCamelCase&lt;/code&gt; 를 사용해야 합니다.</target>
        </trans-unit>
        <trans-unit id="b217f7514e4e69fd38aa7c54a821e91e41f619c3" translate="yes" xml:space="preserve">
          <source>Member functions</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d58072c4501a38b0ae1c8099bd6324750503224c" translate="yes" xml:space="preserve">
          <source>Member functions are called with dot notation:</source>
          <target state="translated">멤버 함수는 점 표기법으로 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="90302bd1ef8edadba09a04d671c6ada71d5d8a46" translate="yes" xml:space="preserve">
          <source>Member functions define operations that are essential for a collection type. For example, &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/-collection/index&quot;&gt;&lt;code&gt;Collection&lt;/code&gt;&lt;/a&gt; contains the function &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/-collection/is-empty&quot;&gt;&lt;code&gt;isEmpty()&lt;/code&gt;&lt;/a&gt; for checking its emptiness; &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/-list/index&quot;&gt;&lt;code&gt;List&lt;/code&gt;&lt;/a&gt; contains &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/-list/get&quot;&gt;&lt;code&gt;get()&lt;/code&gt;&lt;/a&gt; for index access to elements, and so on.</source>
          <target state="translated">멤버 함수는 컬렉션 유형에 필수적인 작업을 정의합니다. 예를 들어 &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/-collection/index&quot;&gt; &lt;code&gt;Collection&lt;/code&gt; &lt;/a&gt; 에는 공허 성을 확인하기위한 &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/-collection/is-empty&quot;&gt; &lt;code&gt;isEmpty()&lt;/code&gt; &lt;/a&gt; 함수가 포함되어 있습니다 . &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/-list/index&quot;&gt; &lt;code&gt;List&lt;/code&gt; &lt;/a&gt; 에는 요소에 대한 인덱스 액세스 등을위한 &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/-list/get&quot;&gt; &lt;code&gt;get()&lt;/code&gt; &lt;/a&gt; 포함되어 있습니다 .</target>
        </trans-unit>
        <trans-unit id="a569ddca50a19b2205ceb3e1f59db2a7ba968aef" translate="yes" xml:space="preserve">
          <source>Member properties and member functions inside a generic class may for the most part use the class' generic type parameters as if they were ordinary types, without having to redeclare them. It is also possible to make functions that take more generic parameters than the class does, and to make generic functions inside nongeneric classes, and to make generic top-level functions (which is what we'll do in the next example). Note the different placement of the generic type parameter in generic function declarations:</source>
          <target state="translated">제네릭 클래스 내의 멤버 속성 및 멤버 함수는 대부분 클래스의 제네릭 형식 매개 변수를 다시 선언하지 않고도 일반 형식처럼 사용할 수 있습니다. 클래스보다 더 일반적인 매개 변수를 사용하는 함수를 만들고 제네릭이 아닌 클래스 내에서 제네릭 함수를 만들고 제네릭 최상위 함수를 만들 수도 있습니다 (다음 예에서 수행 할 작업). 제네릭 함수 선언에서 제네릭 형식 매개 변수의 다른 배치에 유의하십시오.</target>
        </trans-unit>
        <trans-unit id="74971806b05c2768bdffa67bcc7b89b958d7edea" translate="yes" xml:space="preserve">
          <source>Member references and reflection</source>
          <target state="translated">회원 참조 및 반영</target>
        </trans-unit>
        <trans-unit id="1cb449c1126609b4b41e1d87f65f0d7cd19b49b9" translate="yes" xml:space="preserve">
          <source>Members</source>
          <target state="translated">Members</target>
        </trans-unit>
        <trans-unit id="2fd5b3fb4a679664c9a47a448257d9fa802a22f3" translate="yes" xml:space="preserve">
          <source>Members of Objective-C categories and Swift extensions are imported to Kotlin as extensions. That's why these declarations can't be overridden in Kotlin. And the extension initializers aren't available as Kotlin constructors.</source>
          <target state="translated">Objective-C 카테고리의 멤버 및 Swift 확장은 Kotlin에 확장으로 가져옵니다. 그렇기 때문에 Kotlin에서는 이러한 선언을 무시할 수 없습니다. 그리고 확장 초기화는 Kotlin 생성자로 사용할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="c590aa47cb148126a7aed2e0252e6e56de2e1fb5" translate="yes" xml:space="preserve">
          <source>Members of the companion object can be called by using simply the class name as the qualifier:</source>
          <target state="translated">클래스 이름을 한정자로 간단히 사용하여 컴패니언 객체의 멤버를 호출 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b61b70edbe3a97caa2ecb5ac100b7aca209a1cba" translate="yes" xml:space="preserve">
          <source>Memory allocation</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2a2bb3d6a7f5790d759cba72823f3811d734fe09" translate="yes" xml:space="preserve">
          <source>MessageChannel</source>
          <target state="translated">MessageChannel</target>
        </trans-unit>
        <trans-unit id="ccca7aad0aa3bbb87c9ea30bfca4cd685ee282a6" translate="yes" xml:space="preserve">
          <source>MessageEventInit</source>
          <target state="translated">MessageEventInit</target>
        </trans-unit>
        <trans-unit id="da50feb28afa8ee6b84decde6712247ff2db1356" translate="yes" xml:space="preserve">
          <source>Metacharacters or escape sequences in the input sequence will be given no special meaning.</source>
          <target state="translated">입력 시퀀스의 메타 문자 또는 이스케이프 시퀀스에는 특별한 의미가 없습니다.</target>
        </trans-unit>
        <trans-unit id="251edc0eb5a820646bda4e103f0f007fd55321f3" translate="yes" xml:space="preserve">
          <source>Metadata</source>
          <target state="translated">Metadata</target>
        </trans-unit>
        <trans-unit id="00c97618202a4d85cdcf254062dd76c688bb9937" translate="yes" xml:space="preserve">
          <source>Metadata in a custom format. The format may be different (or even absent) for different kinds.</source>
          <target state="translated">사용자 정의 형식의 메타 데이터. 형식은 종류에 따라 다를 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="88306943fea7e76f9cd57cae0ea6d8b32d2e8434" translate="yes" xml:space="preserve">
          <source>Method</source>
          <target state="translated">Method</target>
        </trans-unit>
        <trans-unit id="6ef376dbda2a9dfd9fe8fb9172d6ea36380a325e" translate="yes" xml:space="preserve">
          <source>Method call formatting</source>
          <target state="translated">메소드 호출 형식</target>
        </trans-unit>
        <trans-unit id="3643c572e5a5065b656aa6b5fce445bafca060de" translate="yes" xml:space="preserve">
          <source>Method declarations</source>
          <target state="translated">메소드 선언</target>
        </trans-unit>
        <trans-unit id="6c23f25a80838dd8e19f20f6fec8854933be69db" translate="yes" xml:space="preserve">
          <source>Method names translation</source>
          <target state="translated">분석법 이름 번역</target>
        </trans-unit>
        <trans-unit id="88533fb91c329fcc07daac7abd293e3d2ef386bf" translate="yes" xml:space="preserve">
          <source>Methods &lt;code&gt;wait()&lt;/code&gt; and &lt;code&gt;notify()&lt;/code&gt; are not available on references of type &lt;code&gt;Any&lt;/code&gt;. Their usage is generally discouraged in favor of &lt;code&gt;java.util.concurrent&lt;/code&gt;. If you really need to call these methods, you can cast to &lt;code&gt;java.lang.Object&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;Any&lt;/code&gt; 유형의 참조에는 &lt;code&gt;wait()&lt;/code&gt; 및 &lt;code&gt;notify()&lt;/code&gt; 메소드를 사용할 수 없습니다 . 일반적으로 &lt;code&gt;java.util.concurrent&lt;/code&gt; 사용을 권장하지 않습니다 . 이러한 메소드를 호출해야하는 경우 &lt;code&gt;java.lang.Object&lt;/code&gt; 로 캐스트 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="04764bae2f3b42e32503d658246fd786e62d1716" translate="yes" xml:space="preserve">
          <source>Methods defined in &lt;code&gt;MyList&amp;lt;T&amp;gt;&lt;/code&gt; use &lt;code&gt;T&lt;/code&gt; as platform, i.e. it's possible to perform unsafe operation in Kotlin:</source>
          <target state="translated">&lt;code&gt;MyList&amp;lt;T&amp;gt;&lt;/code&gt; 정의 된 메소드 는 &lt;code&gt;T&lt;/code&gt; 를 플랫폼으로 사용 합니다. 즉 Kotlin에서 안전하지 않은 조작을 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2362d4b5d61680189ee786359c95c772832ea599" translate="yes" xml:space="preserve">
          <source>Methods defined in &lt;code&gt;MyPureList&amp;lt;T&amp;gt;&lt;/code&gt; overriding methods in &lt;code&gt;MutableList&lt;/code&gt; use &lt;code&gt;T&lt;/code&gt; as non-platform types:</source>
          <target state="translated">정의 방법 &lt;code&gt;MyPureList&amp;lt;T&amp;gt;&lt;/code&gt; 에서 재정의 방법 &lt;code&gt;MutableList&lt;/code&gt; 의 사용 &lt;code&gt;T&lt;/code&gt; 비 플랫폼 유형으로서 :</target>
        </trans-unit>
        <trans-unit id="1643049f5673b4e1c5eb74d112c9611cf055d3c5" translate="yes" xml:space="preserve">
          <source>Methods returning void</source>
          <target state="translated">void를 돌려주는 메소드</target>
        </trans-unit>
        <trans-unit id="a8027f1188b3014c0f8995cd7120023b72397d3d" translate="yes" xml:space="preserve">
          <source>Methods that follow the Java conventions for getters and setters (no-argument methods with names starting with &lt;code&gt;get&lt;/code&gt; and single-argument methods with names starting with &lt;code&gt;set&lt;/code&gt;) are represented as properties in Kotlin. &lt;code&gt;Boolean&lt;/code&gt; accessor methods (where the name of the getter starts with &lt;code&gt;is&lt;/code&gt; and the name of the setter starts with &lt;code&gt;set&lt;/code&gt;) are represented as properties which have the same name as the getter method.</source>
          <target state="translated">getter 및 setter에 대한 Java 규칙을 따르는 메소드 ( &lt;code&gt;get&lt;/code&gt; 로 시작하는 이름을 가진 인수가없는 메소드 및 &lt;code&gt;set&lt;/code&gt; 로 시작하는 이름을 가진 단일 인수 메소드 )는 Kotlin의 특성으로 표시됩니다. &lt;code&gt;Boolean&lt;/code&gt; 액세서 메소드 (게터의 이름으로 시작 &lt;code&gt;is&lt;/code&gt; 과 함께 시작 세터의 이름 &lt;code&gt;set&lt;/code&gt; ) 게터 방법과 동일한 이름을 속성으로서 표현된다.</target>
        </trans-unit>
        <trans-unit id="2474109210e0ea672543f6c977728ae54b8f124d" translate="yes" xml:space="preserve">
          <source>Migrate the code with the help of the tooling</source>
          <target state="translated">툴링을 사용하여 코드 마이그레이션</target>
        </trans-unit>
        <trans-unit id="708b9cf32b4bb9e8e85c01bf95c0ef78c92becb6" translate="yes" xml:space="preserve">
          <source>Migrating from Java</source>
          <target state="translated">Java에서 마이그레이션</target>
        </trans-unit>
        <trans-unit id="f44d82dafb548c8ad9d6490ef0e69cd3d1ba217d" translate="yes" xml:space="preserve">
          <source>Migration to a new code style</source>
          <target state="translated">새로운 코드 스타일로 마이그레이션</target>
        </trans-unit>
        <trans-unit id="d0a1c8e409ae53cb281e66770ad717b9178d43ce" translate="yes" xml:space="preserve">
          <source>Migration to a new code style discussion</source>
          <target state="translated">새로운 코드 스타일 토론으로 마이그레이션</target>
        </trans-unit>
        <trans-unit id="1bd7ccbde8d3077fec1f549017e747393223a900" translate="yes" xml:space="preserve">
          <source>MimeType</source>
          <target state="translated">MimeType</target>
        </trans-unit>
        <trans-unit id="ed52d3a5f9993b67e83d292332a8f9a1d86ebf44" translate="yes" xml:space="preserve">
          <source>MimeTypeArray</source>
          <target state="translated">MimeTypeArray</target>
        </trans-unit>
        <trans-unit id="98f205e04abca4bbe7595051d07e6eb3a4abe953" translate="yes" xml:space="preserve">
          <source>Min value</source>
          <target state="translated">최소값</target>
        </trans-unit>
        <trans-unit id="222d1f694d764125a7a7a5786d11a04234b0be8d" translate="yes" xml:space="preserve">
          <source>Missing errors in class constructor&amp;rsquo;s &lt;code&gt;@get:&lt;/code&gt; annotations</source>
          <target state="translated">클래스 생성자의 &lt;code&gt;@get:&lt;/code&gt; 에서 누락 된 오류 : 주석</target>
        </trans-unit>
        <trans-unit id="47e4750870ece5e5c348eda89bdc8e3fbb4c6cff" translate="yes" xml:space="preserve">
          <source>Missing getter-targeted annotations on annotation constructor parameters</source>
          <target state="translated">주석 생성자 매개 변수에 게터 대상 주석이 누락되었습니다.</target>
        </trans-unit>
        <trans-unit id="52b91c038ffc21a08d48959a44ba1c6fddb114f2" translate="yes" xml:space="preserve">
          <source>Mixed Java and Kotlin</source>
          <target state="translated">자바와 코 틀린 혼합</target>
        </trans-unit>
        <trans-unit id="86c40367cc1e1c53a8c10c73ada1f29fd66c1405" translate="yes" xml:space="preserve">
          <source>Mixing Java and Kotlin in one project</source>
          <target state="translated">하나의 프로젝트에서 Java와 Kotlin 혼합</target>
        </trans-unit>
        <trans-unit id="404ab93e44ed76b5232ab6931dd26299f542e43d" translate="yes" xml:space="preserve">
          <source>Modern debuggers provide several ways to set a breakpoint, see below for a tool-by-tool breakdown:</source>
          <target state="translated">최신 디버거는 중단 점을 설정하는 여러 가지 방법을 제공합니다. 도구 별 분석은 아래를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="5ba6ee64964304bc6c3c5424baba2b34cd73ea5d" translate="yes" xml:space="preserve">
          <source>Modifier Keywords</source>
          <target state="translated">수정 자 키워드</target>
        </trans-unit>
        <trans-unit id="3a7ea294bf33134dce4b142b8b7182de29b978b2" translate="yes" xml:space="preserve">
          <source>Modifiers</source>
          <target state="translated">Modifiers</target>
        </trans-unit>
        <trans-unit id="42cd86d0e702bd27bcb835a0b162fb95197132a2" translate="yes" xml:space="preserve">
          <source>Modifies the value of the property.</source>
          <target state="translated">속성 값을 수정합니다.</target>
        </trans-unit>
        <trans-unit id="723a9a05eb17a0ec38db3b56d4b0ea18be0358a6" translate="yes" xml:space="preserve">
          <source>Module and Package Documentation</source>
          <target state="translated">모듈 및 패키지 설명서</target>
        </trans-unit>
        <trans-unit id="ec446b6ebb15f053c4868dce62c242283cf04673" translate="yes" xml:space="preserve">
          <source>Module-wide markers</source>
          <target state="translated">모듈 전체 마커</target>
        </trans-unit>
        <trans-unit id="738fa33a16ad3f30c737fafc42459e4a03f30470" translate="yes" xml:space="preserve">
          <source>Module-wide use</source>
          <target state="translated">모듈 전체 사용</target>
        </trans-unit>
        <trans-unit id="04e9462c0ff02bb9032b92abd45881a3c7e15fb7" translate="yes" xml:space="preserve">
          <source>Modules</source>
          <target state="translated">Modules</target>
        </trans-unit>
        <trans-unit id="d62ac0bf808c354dcb97b6778e8aaae4635a7c9f" translate="yes" xml:space="preserve">
          <source>More details and advanced use-cases are presented in the</source>
          <target state="translated">자세한 내용과 고급 사용 사례는</target>
        </trans-unit>
        <trans-unit id="91aa2ec21d9f2bac781876761e04b45d52ef74fe" translate="yes" xml:space="preserve">
          <source>More documentation on the types mapping can be found in the &lt;a href=&quot;../../reference/native/objc_interop&quot;&gt;Objective-C Interop&lt;/a&gt; article.</source>
          <target state="translated">유형 맵핑에 대한 자세한 문서는 &lt;a href=&quot;../../reference/native/objc_interop&quot;&gt;Objective-C Interop&lt;/a&gt; 기사 에서 찾을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="b5c09addc98121bf0f9aad66c228b38f1430aecf" translate="yes" xml:space="preserve">
          <source>More information about all other types mapping details can be found in the &lt;a href=&quot;../../reference/native/objc_interop&quot;&gt;Objective-C Interop&lt;/a&gt; documentation article</source>
          <target state="translated">다른 모든 유형 맵핑 세부 사항에 대한 자세한 정보는 &lt;a href=&quot;../../reference/native/objc_interop&quot;&gt;Objective-C Interop&lt;/a&gt; 문서 기사 에서 찾을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b061f32f9ec8d43b64e344ed5485c4d9f7caf378" translate="yes" xml:space="preserve">
          <source>More tips and tricks</source>
          <target state="translated">더 많은 팁과 요령</target>
        </trans-unit>
        <trans-unit id="e9792383929cbb7b1909aa88012c0f218c0c51f8" translate="yes" xml:space="preserve">
          <source>Most built-in types are comparable:</source>
          <target state="translated">대부분의 내장 유형은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="f9f0f6eb5ddb49db8f8ae5d8eb9cab0176d9ace5" translate="yes" xml:space="preserve">
          <source>Most of the functionality of signed types are supported for unsigned counterparts too:</source>
          <target state="translated">서명 된 유형의 기능은 대부분 서명되지 않은 상대방에 대해서도 지원됩니다.</target>
        </trans-unit>
        <trans-unit id="cb91c080f7b68ae6a8bbb2b702b1059a13b12c96" translate="yes" xml:space="preserve">
          <source>Most of the operators that are recognized by Kotlin's syntax have predefined textual names and are available for implementation in your classes, just like you can do with Python's double-underscore operator names. For example, the binary &lt;code&gt;+&lt;/code&gt; operator is called &lt;code&gt;plus&lt;/code&gt;. Similarly to the infix example, if you do this inside a &lt;code&gt;Person&lt;/code&gt; class that has got a &lt;code&gt;name&lt;/code&gt; property:</source>
          <target state="translated">Kotlin의 구문으로 인식되는 대부분의 연산자는 미리 정의 된 텍스트 이름을 가지며 파이썬의 이중 밑줄 연산자 이름으로 수행 할 수있는 것처럼 클래스에서 구현할 수 있습니다. 예를 들어 이진 &lt;code&gt;+&lt;/code&gt; 연산자는 &lt;code&gt;plus&lt;/code&gt; 라고 합니다. 마찬가지로 중위 예, 당신은 내부에서이 작업을 수행 할 경우 &lt;code&gt;Person&lt;/code&gt; 가지고 클래스 &lt;code&gt;name&lt;/code&gt; 속성을 :</target>
        </trans-unit>
        <trans-unit id="3edbae2a158aaf025c7463b2890fdba1f30e0552" translate="yes" xml:space="preserve">
          <source>Most of the time we define extensions on the top level, i.e. directly under packages:</source>
          <target state="translated">대부분의 경우 확장 프로그램을 최상위 수준에서 정의합니다 (예 : 패키지 바로 아래).</target>
        </trans-unit>
        <trans-unit id="d6a06199cc127e571d3588aef63c79108675eabc" translate="yes" xml:space="preserve">
          <source>Motivation</source>
          <target state="translated">Motivation</target>
        </trans-unit>
        <trans-unit id="e5f579f208747beb161cf00d47a3a0c086f81dbe" translate="yes" xml:space="preserve">
          <source>MouseEventInit</source>
          <target state="translated">MouseEventInit</target>
        </trans-unit>
        <trans-unit id="19754c53e87ae21affdf187e21540a29ec7c1fa2" translate="yes" xml:space="preserve">
          <source>Much like we reference an input element, we can access other elements on the page, casting them to the appropriate types.</source>
          <target state="translated">입력 요소를 참조하는 것처럼 페이지의 다른 요소에 액세스하여 적절한 유형으로 캐스트 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="85e61eaa48d6be8dae51bf80212b85c25bd2b301" translate="yes" xml:space="preserve">
          <source>Much the same way as regular properties, the properties declared in the primary constructor can be mutable (&lt;em&gt;var&lt;/em&gt;) or read-only (&lt;em&gt;val&lt;/em&gt;).</source>
          <target state="translated">일반 속성과 같은 방식으로 기본 생성자에 선언 된 속성은 변경 가능 ( &lt;em&gt;var&lt;/em&gt; ) 또는 읽기 전용 ( &lt;em&gt;val&lt;/em&gt; ) 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="bf10a69dc3111e2f0b70a7a3b5fcde0eb5de58f0" translate="yes" xml:space="preserve">
          <source>Multiplatform &lt;code&gt;Random&lt;/code&gt;</source>
          <target state="translated">멀티 플랫폼 &lt;code&gt;Random&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="4d27d69385dad1ecc38485d70b593ff3be6501e1" translate="yes" xml:space="preserve">
          <source>Multiplatform Gradle Project</source>
          <target state="translated">멀티 플랫폼 Gradle 프로젝트</target>
        </trans-unit>
        <trans-unit id="b476304566bdb2c8284f4c5fabc7060e30563d1f" translate="yes" xml:space="preserve">
          <source>Multiplatform Kotlin Library</source>
          <target state="translated">멀티 플랫폼 코 틀린 라이브러리</target>
        </trans-unit>
        <trans-unit id="594342484b7fa8723561cd74a56adf5ed5eecd56" translate="yes" xml:space="preserve">
          <source>Multiplatform Kotlin library</source>
          <target state="translated">멀티 플랫폼 코 틀린 라이브러리</target>
        </trans-unit>
        <trans-unit id="abdd2b4ca66085ea36500996c307f3c54d5bee0a" translate="yes" xml:space="preserve">
          <source>Multiplatform Libraries</source>
          <target state="translated">멀티 플랫폼 라이브러리</target>
        </trans-unit>
        <trans-unit id="49bdb75dde412727c37ad9cfdc25f84b9800e1ee" translate="yes" xml:space="preserve">
          <source>Multiplatform Programming</source>
          <target state="translated">멀티 플랫폼 프로그래밍</target>
        </trans-unit>
        <trans-unit id="8831ff8afbd886576a6d26e7a38c2a2945370e5f" translate="yes" xml:space="preserve">
          <source>Multiplatform Project: iOS and Android</source>
          <target state="translated">멀티 플랫폼 프로젝트 : iOS 및 Android</target>
        </trans-unit>
        <trans-unit id="5cff52171a748c24fbdfa2675a9193d1e17c8b90" translate="yes" xml:space="preserve">
          <source>Multiplatform Projects</source>
          <target state="translated">멀티 플랫폼 프로젝트</target>
        </trans-unit>
        <trans-unit id="30ece0cd52430a4d7a64233600e1721dbcbbe2bf" translate="yes" xml:space="preserve">
          <source>Multiplatform Projects (experimental)</source>
          <target state="translated">멀티 플랫폼 프로젝트 (실험)</target>
        </trans-unit>
        <trans-unit id="dce33eff96bb2026a847a2a553a328f131ebdfe5" translate="yes" xml:space="preserve">
          <source>Multiplatform projects</source>
          <target state="translated">멀티 플랫폼 프로젝트</target>
        </trans-unit>
        <trans-unit id="48104e942ea0eb10a48e224f17bd6af63a0f01ad" translate="yes" xml:space="preserve">
          <source>Multiplatform projects are a new &lt;strong&gt;experimental&lt;/strong&gt; feature in Kotlin 1.2, allowing you to reuse code between target platforms supported by Kotlin &amp;ndash; JVM, JavaScript and (in the future) Native. In a multiplatform project, you have three kinds of modules:</source>
          <target state="translated">멀티 플랫폼 프로젝트는 Kotlin 1.2 의 새로운 &lt;strong&gt;실험&lt;/strong&gt; 기능으로, Kotlin이 지원하는 대상 플랫폼 (JVM, JavaScript 및 기본)간에 코드를 재사용 할 수 있습니다. 멀티 플랫폼 프로젝트에는 세 가지 종류의 모듈이 있습니다.</target>
        </trans-unit>
        <trans-unit id="56c55ee3ca3b8c8dc0a5fe577d6b3cbe7b6bf668" translate="yes" xml:space="preserve">
          <source>Multiplatform projects are an experimental feature in Kotlin 1.2 and 1.3. All of the language and tooling features described in this document are subject to change in future Kotlin versions.</source>
          <target state="translated">멀티 플랫폼 프로젝트는 Kotlin 1.2 및 1.3의 실험 기능입니다. 이 문서에 설명 된 모든 언어 및 툴링 기능은 향후 Kotlin 버전에서 변경 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a47f8ee1f56229364d475a5b4995314b84d9fc4e" translate="yes" xml:space="preserve">
          <source>Multiple coroutines may receive from the same channel, distributing work between themselves. Let us start with a producer coroutine that is periodically producing integers (ten numbers per second):</source>
          <target state="translated">여러 코 루틴이 동일한 채널에서 수신되어 서로간에 작업을 분산시킬 수 있습니다. 주기적으로 정수 (초당 10 개의 숫자)를 생성하는 생산자 코 루틴으로 시작하겠습니다.</target>
        </trans-unit>
        <trans-unit id="264744e655406950142eec2a53dc539eed8a5fd7" translate="yes" xml:space="preserve">
          <source>Multiple coroutines may send to the same channel. For example, let us have a channel of strings, and a suspending function that repeatedly sends a specified string to this channel with a specified delay:</source>
          <target state="translated">여러 코 루틴이 동일한 채널로 보낼 수 있습니다. 예를 들어, 문자열 채널과 지정된 지연 시간을두고 지정된 문자열을이 채널에 반복적으로 전송하는 서 스펜 딩 함수가 있습니다.</target>
        </trans-unit>
        <trans-unit id="9d79d3118202ae1d668fb56014f9cb20b36159e5" translate="yes" xml:space="preserve">
          <source>Multiplies this value by the other value.</source>
          <target state="translated">이 값에 다른 값을 곱합니다.</target>
        </trans-unit>
        <trans-unit id="f342e79f479c63b3a6f1a4035901daea4fbf30b9" translate="yes" xml:space="preserve">
          <source>MustBeDocumented</source>
          <target state="translated">MustBeDocumented</target>
        </trans-unit>
        <trans-unit id="07b00606431523d4ebea7077981984b607d973e8" translate="yes" xml:space="preserve">
          <source>Mutable closure variables</source>
          <target state="translated">가변 폐쇄 변수</target>
        </trans-unit>
        <trans-unit id="e427611262df2a9a50ee135e0fceaecfa0c80c7f" translate="yes" xml:space="preserve">
          <source>Mutable concurrently accessible data buffer. Could be accessed from several workers simulteniously.</source>
          <target state="translated">동시에 액세스 가능한 가변 데이터 버퍼 여러 근로자가 동시에 액세스 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="46fb0a3dd2497d28351f3b643be68bf38c4dcf04" translate="yes" xml:space="preserve">
          <source>Mutable iterators</source>
          <target state="translated">가변 이터레이터</target>
        </trans-unit>
        <trans-unit id="9b7b2307fe92cd7c012fa39281f7b175b249dd6e" translate="yes" xml:space="preserve">
          <source>MutableCollection</source>
          <target state="translated">MutableCollection</target>
        </trans-unit>
        <trans-unit id="42724994b4f6f408170a142d4bb3a6bfa7198849" translate="yes" xml:space="preserve">
          <source>MutableCollection.iterator</source>
          <target state="translated">MutableCollection.iterator</target>
        </trans-unit>
        <trans-unit id="1a5033d42eefb58adbea823fa5255b0aed1d662e" translate="yes" xml:space="preserve">
          <source>MutableData</source>
          <target state="translated">MutableData</target>
        </trans-unit>
        <trans-unit id="5e9e097c14385f745d368faabbd3854a67b05b46" translate="yes" xml:space="preserve">
          <source>MutableEntry</source>
          <target state="translated">MutableEntry</target>
        </trans-unit>
        <trans-unit id="8a4f4102af09300cf876f9a6460618caaa96575a" translate="yes" xml:space="preserve">
          <source>MutableIterable</source>
          <target state="translated">MutableIterable</target>
        </trans-unit>
        <trans-unit id="a652e5941b9ff793ccc9e659b88bf1a8f5227c3a" translate="yes" xml:space="preserve">
          <source>MutableIterator</source>
          <target state="translated">MutableIterator</target>
        </trans-unit>
        <trans-unit id="49e02d16b11d601b6e4902190c5bca350a9202fc" translate="yes" xml:space="preserve">
          <source>MutableList</source>
          <target state="translated">MutableList</target>
        </trans-unit>
        <trans-unit id="4c650d57f6075cf5940d694638ac9e4ec8e77bc6" translate="yes" xml:space="preserve">
          <source>MutableListIterator</source>
          <target state="translated">MutableListIterator</target>
        </trans-unit>
        <trans-unit id="f20ff48f1ceb7119a78b4b13a251cf2c7628b7ac" translate="yes" xml:space="preserve">
          <source>MutableMap</source>
          <target state="translated">MutableMap</target>
        </trans-unit>
        <trans-unit id="c0a289c1f11c0248072d86bca1271c7246850c9c" translate="yes" xml:space="preserve">
          <source>MutableSet</source>
          <target state="translated">MutableSet</target>
        </trans-unit>
        <trans-unit id="0b5d551add97f7ca81d05d95c5a9f114421d02ad" translate="yes" xml:space="preserve">
          <source>Mutating the backing field of a read-only property by assigning &lt;code&gt;field = ...&lt;/code&gt; in the custom getter has been deprecated, with a warning in Kotlin 1.2 and an error in Kotlin 1.3.</source>
          <target state="translated">Kotlin 1.2의 경고와 Kotlin 1.3의 오류와 함께 사용자 정의 getter에서 &lt;code&gt;field = ...&lt;/code&gt; 를 지정하여 읽기 전용 속성의 지원 필드를 제거하는 것은 더 이상 사용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="d9e09542ba7562ba06b3618d585343bb16717cc0" translate="yes" xml:space="preserve">
          <source>MutationObserver</source>
          <target state="translated">MutationObserver</target>
        </trans-unit>
        <trans-unit id="bf760ce86085d0556b58a1fb2886ad6300cf25c9" translate="yes" xml:space="preserve">
          <source>MutationObserverInit</source>
          <target state="translated">MutationObserverInit</target>
        </trans-unit>
        <trans-unit id="902e161ec72b34937173fb6ae6f1167c6c4b933a" translate="yes" xml:space="preserve">
          <source>MutationRecord</source>
          <target state="translated">MutationRecord</target>
        </trans-unit>
        <trans-unit id="bd89464f515bc7c1945f885ef807721ee91c256b" translate="yes" xml:space="preserve">
          <source>Mutual exclusion</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f2a0cc7430b6ab201c123d93595f5409656e44aa" translate="yes" xml:space="preserve">
          <source>Mutual exclusion solution to the problem is to protect all modifications of the shared state with a &lt;em&gt;critical section&lt;/em&gt; that is never executed concurrently. In a blocking world you'd typically use &lt;code&gt;synchronized&lt;/code&gt; or &lt;code&gt;ReentrantLock&lt;/code&gt; for that. Coroutine's alternative is called &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.sync/-mutex/index.html&quot;&gt;Mutex&lt;/a&gt;. It has &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.sync/-mutex/lock.html&quot;&gt;lock&lt;/a&gt; and &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.sync/-mutex/unlock.html&quot;&gt;unlock&lt;/a&gt; functions to delimit a critical section. The key difference is that &lt;code&gt;Mutex.lock()&lt;/code&gt; is a suspending function. It does not block a thread.</source>
          <target state="translated">문제에 대한 상호 배제 솔루션 은 동시에 실행되지 않는 &lt;em&gt;중요한 섹션으로&lt;/em&gt; 공유 상태의 모든 수정을 보호하는 것입니다 . 블로킹 세계에서는 일반적으로 &lt;code&gt;synchronized&lt;/code&gt; 또는 &lt;code&gt;ReentrantLock&lt;/code&gt; 을 사용합니다. 코 루틴의 대안은 &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.sync/-mutex/index.html&quot;&gt;Mutex&lt;/a&gt; 라고 합니다. 그것은이 &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.sync/-mutex/lock.html&quot;&gt;잠금&lt;/a&gt; 및 &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.sync/-mutex/unlock.html&quot;&gt;잠금 해제&lt;/a&gt; 중요한 부분을 구분하는 기능을. 주요 차이점은 &lt;code&gt;Mutex.lock()&lt;/code&gt; 이 일시 중단 함수라는 것입니다. 스레드를 차단하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="e6a87480ef216b736cda78776d20937ae965a5a1" translate="yes" xml:space="preserve">
          <source>My first coroutine</source>
          <target state="translated">내 첫 코 루틴</target>
        </trans-unit>
        <trans-unit id="08d2e98e6754af941484848930ccbaddfefe13d6" translate="yes" xml:space="preserve">
          <source>N/A</source>
          <target state="translated">N/A</target>
        </trans-unit>
        <trans-unit id="ac5af3d78fb9a248a0c8878049fa45cb722c5609" translate="yes" xml:space="preserve">
          <source>NEGATIVE_INFINITY</source>
          <target state="translated">NEGATIVE_INFINITY</target>
        </trans-unit>
        <trans-unit id="0654a028e5aea48c8fbb09871b8f397a186c883b" translate="yes" xml:space="preserve">
          <source>NONE</source>
          <target state="translated">NONE</target>
        </trans-unit>
        <trans-unit id="19b5db1284eda5fe55423cf6ff666bbd91d48790" translate="yes" xml:space="preserve">
          <source>NONSPACING_MARK</source>
          <target state="translated">NONSPACING_MARK</target>
        </trans-unit>
        <trans-unit id="a711913b07f219db3720165b1cc42ba33ab84d07" translate="yes" xml:space="preserve">
          <source>NON_SPACING_MARK</source>
          <target state="translated">NON_SPACING_MARK</target>
        </trans-unit>
        <trans-unit id="b12d9f3adce16f3c42e185c9323b0f2c05d0d02a" translate="yes" xml:space="preserve">
          <source>NOTE: Octal literals are not supported.</source>
          <target state="translated">참고 : 8 진 리터럴은 지원되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="c820cc676951d2a6935d55d3c748ef2d4229e0ef" translate="yes" xml:space="preserve">
          <source>NSArray</source>
          <target state="translated">NSArray</target>
        </trans-unit>
        <trans-unit id="850a25e67ede967c8226916d9435ee3fa9fe30c0" translate="yes" xml:space="preserve">
          <source>NSDictionary</source>
          <target state="translated">NSDictionary</target>
        </trans-unit>
        <trans-unit id="88142d93bc155af7430eda23b521adf5177befb3" translate="yes" xml:space="preserve">
          <source>NSMutableArray</source>
          <target state="translated">NSMutableArray</target>
        </trans-unit>
        <trans-unit id="093cc39541f1d88e9c8d7815809e04abdc468222" translate="yes" xml:space="preserve">
          <source>NSMutableDictionary</source>
          <target state="translated">NSMutableDictionary</target>
        </trans-unit>
        <trans-unit id="6f353d0803276b29f669e8e00d5912e0735d118f" translate="yes" xml:space="preserve">
          <source>NSMutableString</source>
          <target state="translated">NSMutableString</target>
        </trans-unit>
        <trans-unit id="21b6f3d1ecc982003af64b405b1aec1eeffcbd63" translate="yes" xml:space="preserve">
          <source>NSNumber</source>
          <target state="translated">NSNumber</target>
        </trans-unit>
        <trans-unit id="6049050154f9c68876906ec983b62a8beb7bfd87" translate="yes" xml:space="preserve">
          <source>NSSet</source>
          <target state="translated">NSSet</target>
        </trans-unit>
        <trans-unit id="f7fd9c68f804acda665d2ab082217bb1583318f2" translate="yes" xml:space="preserve">
          <source>NaN</source>
          <target state="translated">NaN</target>
        </trans-unit>
        <trans-unit id="709a23220f2c3d64d1e1d6d18c4d5280f8d82fca" translate="yes" xml:space="preserve">
          <source>Name</source>
          <target state="translated">Name</target>
        </trans-unit>
        <trans-unit id="ed2a70884b6ea61a0ea998c7fe86ebc6c43c39e1" translate="yes" xml:space="preserve">
          <source>Name of the module being compiled</source>
          <target state="translated">컴파일중인 모듈의 이름</target>
        </trans-unit>
        <trans-unit id="4efab9c724a7839dff5f1e0118b1a9b242fe8997" translate="yes" xml:space="preserve">
          <source>Name of this parameter as it was declared in the source code, or &lt;code&gt;null&lt;/code&gt; if the parameter has no name or its name is not available at runtime. Examples of nameless parameters include &lt;code&gt;this&lt;/code&gt; instance for member functions, extension receiver for extension functions or properties, parameters of Java methods compiled without the debug information, and others.</source>
          <target state="translated">소스 코드에서 선언 된이 매개 변수의 이름이거나, 매개 변수에 이름이 없거나 런타임에 해당 이름을 사용할 수없는 경우 &lt;code&gt;null&lt;/code&gt; 입니다. 이름없는 매개 변수의 예는 &lt;code&gt;this&lt;/code&gt; 멤버 함수, 확장 기능이나 특성, 디버그 정보없이 컴파일 된 Java 메소드의 매개 변수 및 다른 사람에 대한 확장 수신기의 인스턴스를.</target>
        </trans-unit>
        <trans-unit id="9e0268761f1a46defda13527e24a738481491b83" translate="yes" xml:space="preserve">
          <source>Name translation</source>
          <target state="translated">이름 번역</target>
        </trans-unit>
        <trans-unit id="80a1546459fb296b75e903b673f8cc0ad0b7638a" translate="yes" xml:space="preserve">
          <source>Named Arguments</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f2ab34573e168918bf72dc73ec10c4b5b1ba3f14" translate="yes" xml:space="preserve">
          <source>Named arguments</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7eee412e511b81f184e8fdcdd0d16df4490ee091" translate="yes" xml:space="preserve">
          <source>NamedNodeMap</source>
          <target state="translated">NamedNodeMap</target>
        </trans-unit>
        <trans-unit id="89ed0927522265d199caf008b2d935b4dc13e4ec" translate="yes" xml:space="preserve">
          <source>Namely, &lt;code&gt;Grouping&lt;/code&gt; supports the following operations:</source>
          <target state="translated">즉, &lt;code&gt;Grouping&lt;/code&gt; 는 다음 작업을 지원합니다.</target>
        </trans-unit>
        <trans-unit id="ce7873d11ca1350ea35c4e7edcc86d0f3faedfbb" translate="yes" xml:space="preserve">
          <source>Names for backing properties</source>
          <target state="translated">지지 속성의 이름</target>
        </trans-unit>
        <trans-unit id="d5e90b6eaa5ac7d68bfe0de19720901740a9662f" translate="yes" xml:space="preserve">
          <source>Names for test methods</source>
          <target state="translated">테스트 방법의 이름</target>
        </trans-unit>
        <trans-unit id="1bbe1b5bbc9b48ae056a0ba828b7773769b4e6a7" translate="yes" xml:space="preserve">
          <source>Names in links are resolved using the same rules as if the name was used inside the element being documented. In particular, this means that if you have imported a name into the current file, you don't need to fully qualify it when you use it in a KDoc comment.</source>
          <target state="translated">링크의 이름은 이름이 문서화되는 요소 내부에서 사용 된 것과 동일한 규칙을 사용하여 해결됩니다. 즉, 현재 파일로 이름을 가져온 경우 KDoc 주석에서 이름을 사용할 때 이름을 완전히 규정 할 필요가 없습니다.</target>
        </trans-unit>
        <trans-unit id="c5380f68245bbc672ad92afb09b8fb6715ad3ca6" translate="yes" xml:space="preserve">
          <source>Names of classes and objects start with an upper case letter and use camel humps:</source>
          <target state="translated">클래스와 객체의 이름은 대문자로 시작하고 낙타 혹을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="fc15464a07c43531a73eacebb7c301c643be9755" translate="yes" xml:space="preserve">
          <source>Names of constants (properties marked with &lt;code&gt;const&lt;/code&gt;, or top-level or object &lt;code&gt;val&lt;/code&gt; properties with no custom &lt;code&gt;get&lt;/code&gt; function that hold deeply immutable data) should use uppercase underscore-separated names:</source>
          <target state="translated">상수의 이름 ( &lt;code&gt;const&lt;/code&gt; 로 표시되는 속성 또는 변경이 불가능한 데이터를 보유하는 사용자 지정 &lt;code&gt;get&lt;/code&gt; 함수가 없는 최상위 또는 객체 &lt;code&gt;val&lt;/code&gt; 속성 )은 밑줄로 구분 된 대문자를 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="ed152e23d368497078b7ae5dc12a67a09aef9537" translate="yes" xml:space="preserve">
          <source>Names of functions, properties and local variables start with a lower case letter and use camel humps and no underscores:</source>
          <target state="translated">함수, 속성 및 지역 변수의 이름은 소문자로 시작하고 낙타 혹을 사용하고 밑줄을 사용하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="2fe2ff19a7f565c3d30edceae570abf2351b799b" translate="yes" xml:space="preserve">
          <source>Names of packages are always lower case and do not use underscores (&lt;code&gt;org.example.myproject&lt;/code&gt;). Using multi-word names is generally discouraged, but if you do need to use multiple words, you can either simply concatenate them together or use camel humps (&lt;code&gt;org.example.myProject&lt;/code&gt;).</source>
          <target state="translated">패키지 이름은 항상 소문자이며 밑줄 ( &lt;code&gt;org.example.myproject&lt;/code&gt; )을 사용하지 마십시오 . 여러 단어로 된 이름을 사용하는 것은 일반적으로 권장되지 않지만 여러 단어를 사용해야하는 경우 간단히 단어를 연결하거나 낙타 혹 ( &lt;code&gt;org.example.myProject&lt;/code&gt; )을 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="7f7adf5dd484e8eda6819e4b4ab1a277a17337ee" translate="yes" xml:space="preserve">
          <source>Names of properties holding references to singleton objects can use the same naming style as &lt;code&gt;object&lt;/code&gt; declarations:</source>
          <target state="translated">싱글 톤 객체에 대한 참조를 보유한 속성의 이름은 &lt;code&gt;object&lt;/code&gt; 선언 과 동일한 이름 지정 스타일을 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="2dd1c430f56a1096d7535c6bff1f0b002bb217ee" translate="yes" xml:space="preserve">
          <source>Names of top-level or object properties which hold objects with behavior or mutable data should use regular camel-hump names:</source>
          <target state="translated">동작 또는 변경 가능한 데이터가있는 객체를 보유하는 최상위 또는 객체 속성의 이름은 일반적인 낙타 혹 이름을 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="a821637ed465037f50fb45146c7157533ce303ab" translate="yes" xml:space="preserve">
          <source>Naming coroutines for debugging</source>
          <target state="translated">디버깅을위한 명명 코 루틴</target>
        </trans-unit>
        <trans-unit id="b8f89bc873847bc6acb441471008e2ef77f271a2" translate="yes" xml:space="preserve">
          <source>Naming rules</source>
          <target state="translated">명명 규칙</target>
        </trans-unit>
        <trans-unit id="4fc6e7f740abb8af896ebedebf941a3f8d7076b5" translate="yes" xml:space="preserve">
          <source>Native</source>
          <target state="translated">Native</target>
        </trans-unit>
        <trans-unit id="712b0ca62af66efef9be01024a01163935118cd1" translate="yes" xml:space="preserve">
          <source>NativeFreeablePlacement</source>
          <target state="translated">NativeFreeablePlacement</target>
        </trans-unit>
        <trans-unit id="8c2ed68939229f0bed6cd8b6f2cb9306658a5c17" translate="yes" xml:space="preserve">
          <source>NativePlacement</source>
          <target state="translated">NativePlacement</target>
        </trans-unit>
        <trans-unit id="f6500269f9c3fb94b4438bc913d694314febde22" translate="yes" xml:space="preserve">
          <source>NativePointed</source>
          <target state="translated">NativePointed</target>
        </trans-unit>
        <trans-unit id="82e059ceb59aa7b7713c457045493d8d28dcc3f4" translate="yes" xml:space="preserve">
          <source>NativePtr</source>
          <target state="translated">NativePtr</target>
        </trans-unit>
        <trans-unit id="f504a9f397b7b30ca39f0ef1407b932940292f78" translate="yes" xml:space="preserve">
          <source>Natural order</source>
          <target state="translated">자연 질서</target>
        </trans-unit>
        <trans-unit id="c8e6f949b8ada118fdafbdc6ee8783d697f007cb" translate="yes" xml:space="preserve">
          <source>Navigator</source>
          <target state="translated">Navigator</target>
        </trans-unit>
        <trans-unit id="e7b5edc7e8cb311a0b039335c594c9a957eb3175" translate="yes" xml:space="preserve">
          <source>NavigatorConcurrentHardware</source>
          <target state="translated">NavigatorConcurrentHardware</target>
        </trans-unit>
        <trans-unit id="c539be135337dd03c6301959fad0ce1bee475889" translate="yes" xml:space="preserve">
          <source>NavigatorContentUtils</source>
          <target state="translated">NavigatorContentUtils</target>
        </trans-unit>
        <trans-unit id="00b43738cf147df0c752dcea119b953d47ded336" translate="yes" xml:space="preserve">
          <source>NavigatorCookies</source>
          <target state="translated">NavigatorCookies</target>
        </trans-unit>
        <trans-unit id="ca09397d83fa076ca8fa71c95007223165d66fb5" translate="yes" xml:space="preserve">
          <source>NavigatorID</source>
          <target state="translated">NavigatorID</target>
        </trans-unit>
        <trans-unit id="1c556456dba6623478e38282faadace5b5f02feb" translate="yes" xml:space="preserve">
          <source>NavigatorLanguage</source>
          <target state="translated">NavigatorLanguage</target>
        </trans-unit>
        <trans-unit id="b3ab2a10f83370ceafad9f996d8048d28d1a1363" translate="yes" xml:space="preserve">
          <source>NavigatorOnLine</source>
          <target state="translated">NavigatorOnLine</target>
        </trans-unit>
        <trans-unit id="e94d6507f620430ae9754053564c70782f33c7c9" translate="yes" xml:space="preserve">
          <source>NavigatorPlugins</source>
          <target state="translated">NavigatorPlugins</target>
        </trans-unit>
        <trans-unit id="e7f4b2c609e0e06e378710e78e2e3f9dbec6df11" translate="yes" xml:space="preserve">
          <source>Negative values show that it's less than the argument.</source>
          <target state="translated">음수 값은 인수보다 작음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="789280e01339d5a915f0345cf138b9b4fb941c8e" translate="yes" xml:space="preserve">
          <source>Nested and Inner Classes</source>
          <target state="translated">중첩 및 내부 클래스</target>
        </trans-unit>
        <trans-unit id="ee69ace2d0864bd815e214e20536f1f61364fc0f" translate="yes" xml:space="preserve">
          <source>Nested classifiers in enum entries</source>
          <target state="translated">열거 형 항목의 중첩 분류 자</target>
        </trans-unit>
        <trans-unit id="40c58381d790a3e7eec655ca2a16667d8a074dd3" translate="yes" xml:space="preserve">
          <source>Nested declarations in annotation classes</source>
          <target state="translated">주석 클래스의 중첩 선언</target>
        </trans-unit>
        <trans-unit id="d053911ed6d5cc20ee675fd6a4520e78c20b1efb" translate="yes" xml:space="preserve">
          <source>Neutral bidirectional character type &quot;B&quot; in the Unicode specification.</source>
          <target state="translated">Unicode 사양의 중립 쌍방향 문자 타입 &quot;B&quot;</target>
        </trans-unit>
        <trans-unit id="8fd58ea9d9361ae87799e3e0adb497216a8850cd" translate="yes" xml:space="preserve">
          <source>Neutral bidirectional character type &quot;ON&quot; in the Unicode specification.</source>
          <target state="translated">Unicode 사양의 중립 쌍방향 문자 타입 「ON」</target>
        </trans-unit>
        <trans-unit id="cc8492cfce3dced2f8758c8c41b89e84144de788" translate="yes" xml:space="preserve">
          <source>Neutral bidirectional character type &quot;S&quot; in the Unicode specification.</source>
          <target state="translated">Unicode 사양의 중립 쌍방향 문자 타입 &quot;S&quot;</target>
        </trans-unit>
        <trans-unit id="61ee633fcd6ff884b460c34fd4f698e42b8d1f57" translate="yes" xml:space="preserve">
          <source>Neutral bidirectional character type &quot;WS&quot; in the Unicode specification.</source>
          <target state="translated">Unicode 사양의 중립 쌍방향 문자 타입 「WS」</target>
        </trans-unit>
        <trans-unit id="9ac5f98640f23386ec33233fa4af214ae29bb68c" translate="yes" xml:space="preserve">
          <source>Never equal to null: for any non-null value &lt;code&gt;x&lt;/code&gt;, &lt;code&gt;x.equals(null)&lt;/code&gt; should return false.</source>
          <target state="translated">null 이외의 값 : null 이외의 값 &lt;code&gt;x&lt;/code&gt; 의 경우 , &lt;code&gt;x.equals(null)&lt;/code&gt; 는 false를 돌려 줍니다 .</target>
        </trans-unit>
        <trans-unit id="c8ca579cfa2a0bc063bd07e3a4d9c7f65e8e3087" translate="yes" xml:space="preserve">
          <source>Never put a space after &lt;code&gt;(&lt;/code&gt;, &lt;code&gt;[&lt;/code&gt;, or before &lt;code&gt;]&lt;/code&gt;, &lt;code&gt;)&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;(&lt;/code&gt; , &lt;code&gt;[&lt;/code&gt; 또는 앞 &lt;code&gt;]&lt;/code&gt; , &lt;code&gt;)&lt;/code&gt; 뒤에 공백을 두지 마십시오 .</target>
        </trans-unit>
        <trans-unit id="9294e60ab9df0dbecb3a72a47335eee294748f65" translate="yes" xml:space="preserve">
          <source>Never put a space around &lt;code&gt;.&lt;/code&gt; or &lt;code&gt;?.&lt;/code&gt;: &lt;code&gt;foo.bar().filter { it &amp;gt; 2 }.joinToString()&lt;/code&gt;, &lt;code&gt;foo?.bar()&lt;/code&gt;</source>
          <target state="translated">주위에 공간을 두지 마십시오 &lt;code&gt;.&lt;/code&gt; 또는 &lt;code&gt;?.&lt;/code&gt; : &lt;code&gt;foo.bar().filter { it &amp;gt; 2 }.joinToString()&lt;/code&gt; , &lt;code&gt;foo?.bar()&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="845d99d67846936e2a2ecffc0c1f73a93b077848" translate="yes" xml:space="preserve">
          <source>New extensions for &lt;code&gt;Iterable&amp;lt;T&amp;gt;&lt;/code&gt;, &lt;code&gt;Sequence&amp;lt;T&amp;gt;&lt;/code&gt;, and &lt;code&gt;CharSequence&lt;/code&gt; cover such use cases as buffering or batch processing (&lt;code&gt;chunked&lt;/code&gt;), sliding window and computing sliding average (&lt;code&gt;windowed&lt;/code&gt;) , and processing pairs of subsequent items (&lt;code&gt;zipWithNext&lt;/code&gt;):</source>
          <target state="translated">&lt;code&gt;Iterable&amp;lt;T&amp;gt;&lt;/code&gt; , &lt;code&gt;Sequence&amp;lt;T&amp;gt;&lt;/code&gt; 및 &lt;code&gt;CharSequence&lt;/code&gt; 의 새로운 확장 기능은 버퍼링 또는 일괄 처리 ( &lt;code&gt;chunked&lt;/code&gt; 처리 ), 슬라이딩 창 및 슬라이딩 평균 계산 ( &lt;code&gt;windowed&lt;/code&gt; ) 및 후속 항목 쌍 처리 ( &lt;code&gt;zipWithNext&lt;/code&gt; ) 와 같은 사용 사례를 다룹니다 .</target>
        </trans-unit>
        <trans-unit id="e22e233ab95d5952f18b874d9870e1b80280d15d" translate="yes" xml:space="preserve">
          <source>New functions were added for converting &lt;code&gt;Double&lt;/code&gt; and &lt;code&gt;Float&lt;/code&gt; to and from their bit representations:</source>
          <target state="translated">&lt;code&gt;Double&lt;/code&gt; 과 &lt;code&gt;Float&lt;/code&gt; 를 비트 표현으로 또는 비트 표현으로 변환하기위한 새로운 기능이 추가되었습니다 .</target>
        </trans-unit>
        <trans-unit id="28dcc6d65c266a50c3f667c9e5ea8aa135aa58a6" translate="yes" xml:space="preserve">
          <source>New to Kotlin? Take a look at the &lt;a href=&quot;basic-syntax&quot;&gt;Getting Started&lt;/a&gt; page.</source>
          <target state="translated">코 틀린을 처음 사용하십니까? &lt;a href=&quot;basic-syntax&quot;&gt;시작하기&lt;/a&gt; 페이지를 살펴보십시오 .</target>
        </trans-unit>
        <trans-unit id="3f170caead65df254d786032a409a6f6d204bca6" translate="yes" xml:space="preserve">
          <source>Next Steps</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5079a9846101e11db84a1abb592a9473e268055f" translate="yes" xml:space="preserve">
          <source>Next open a new terminal and install Kotlin with:</source>
          <target state="translated">다음으로 새 터미널을 열고 Kotlin을 다음과 같이 설치하십시오.</target>
        </trans-unit>
        <trans-unit id="2f460c75911314c0c9543c3367959a31445cb463" translate="yes" xml:space="preserve">
          <source>Next, let's include the following line of code into the &lt;code&gt;MainActivity&lt;/code&gt; class from the &lt;code&gt;/app/src/main/java/&amp;lt;package&amp;gt;/MainActivity.kt&lt;/code&gt; file, to the end of the &lt;code&gt;onCreate&lt;/code&gt; method:</source>
          <target state="translated">다음으로 &lt;code&gt;/app/src/main/java/&amp;lt;package&amp;gt;/MainActivity.kt&lt;/code&gt; 파일에서 &lt;code&gt;onCreate&lt;/code&gt; 메소드 의 끝까지 &lt;code&gt;MainActivity&lt;/code&gt; 클래스에 다음 코드 행을 포함시킵니다 .</target>
        </trans-unit>
        <trans-unit id="61e1f7fc790c5246a6e519f4f67f422c4a517358" translate="yes" xml:space="preserve">
          <source>Next, we need to create the &lt;code&gt;SharedCode/build.gradle&lt;/code&gt; file with the following content:</source>
          <target state="translated">다음 내용으로 &lt;code&gt;SharedCode/build.gradle&lt;/code&gt; 파일 을 만들어야합니다 .</target>
        </trans-unit>
        <trans-unit id="fba44f74cfbe24d927a6f2e32c74f105a6d9ca00" translate="yes" xml:space="preserve">
          <source>Next: Annotations &amp;rarr;</source>
          <target state="translated">다음 : 주석 &amp;rarr;</target>
        </trans-unit>
        <trans-unit id="00ef744e43f0f9ea134186c2ef008876b94cfb5d" translate="yes" xml:space="preserve">
          <source>Next: Classes &amp;rarr;</source>
          <target state="translated">다음 : 수업 &amp;rarr;</target>
        </trans-unit>
        <trans-unit id="c8735b85302131b9db681cecd1fb40aa277a0558" translate="yes" xml:space="preserve">
          <source>Next: Collections &amp;rarr;</source>
          <target state="translated">다음 : 모음 &amp;rarr;</target>
        </trans-unit>
        <trans-unit id="07999039cc4614cf9d9c83d8a64e7926f8829364" translate="yes" xml:space="preserve">
          <source>Next: Compiling and running &amp;rarr;</source>
          <target state="translated">다음 : 컴파일 및 실행 &amp;rarr;</target>
        </trans-unit>
        <trans-unit id="f20d28acc929c74946791930cf9c56d2978b64a8" translate="yes" xml:space="preserve">
          <source>Next: Conditionals &amp;rarr;</source>
          <target state="translated">다음 : 조건부 &amp;rarr;</target>
        </trans-unit>
        <trans-unit id="840074b0ba8fd90b4e90aa33d45718551b373169" translate="yes" xml:space="preserve">
          <source>Next: Declaring variables &amp;rarr;</source>
          <target state="translated">다음 : 변수 선언 &amp;rarr;</target>
        </trans-unit>
        <trans-unit id="cce5126b0175141ca7a8267a7936ebe65fe68d5f" translate="yes" xml:space="preserve">
          <source>Next: Documentation &amp;rarr;</source>
          <target state="translated">다음 : 설명서 &amp;rarr;</target>
        </trans-unit>
        <trans-unit id="fa55701df6604b3cecc0d604af09a04554d557b6" translate="yes" xml:space="preserve">
          <source>Next: Exceptions &amp;rarr;</source>
          <target state="translated">다음 : 예외 &amp;rarr;</target>
        </trans-unit>
        <trans-unit id="6b6aa34eef4e603a14fc427c78ce11728dd25836" translate="yes" xml:space="preserve">
          <source>Next: Extension functions/properties &amp;rarr;</source>
          <target state="translated">다음 : 확장 기능 / 속성 &amp;rarr;</target>
        </trans-unit>
        <trans-unit id="085547cea36d9036af28992fd35c78130fafdd20" translate="yes" xml:space="preserve">
          <source>Next: File I/O &amp;rarr;</source>
          <target state="translated">다음 : 파일 I / O &amp;rarr;</target>
        </trans-unit>
        <trans-unit id="1ad7d1fc04a3f8f5bb3171b2738d368b2e7962ea" translate="yes" xml:space="preserve">
          <source>Next: Functional programming &amp;rarr;</source>
          <target state="translated">다음 : 기능 프로그래밍 &amp;rarr;</target>
        </trans-unit>
        <trans-unit id="4ca230bdec76005c5c8ecf036e517045996d632a" translate="yes" xml:space="preserve">
          <source>Next: Functions &amp;rarr;</source>
          <target state="translated">다음 : 기능 &amp;rarr;</target>
        </trans-unit>
        <trans-unit id="ee174e846c5088dfbb38266ba627304b28a4e778" translate="yes" xml:space="preserve">
          <source>Next: Generics &amp;rarr;</source>
          <target state="translated">다음 : 제네릭 &amp;rarr;</target>
        </trans-unit>
        <trans-unit id="1fc3a42a52feb37755a354083cafdc34a3336119" translate="yes" xml:space="preserve">
          <source>Next: Hello World &amp;rarr;</source>
          <target state="translated">다음 : Hello World &amp;rarr;</target>
        </trans-unit>
        <trans-unit id="3e18f658842ac7800584f5830d0086c6615ba81e" translate="yes" xml:space="preserve">
          <source>Next: Inheritance &amp;rarr;</source>
          <target state="translated">다음 : 상속 &amp;rarr;</target>
        </trans-unit>
        <trans-unit id="e300f7cf6a03c09bab1b47c326855a60fe6e07fb" translate="yes" xml:space="preserve">
          <source>Next: Loops &amp;rarr;</source>
          <target state="translated">다음 : 루프 &amp;rarr;</target>
        </trans-unit>
        <trans-unit id="42aae1e29d68a1d88913d08cee33e89180a579d7" translate="yes" xml:space="preserve">
          <source>Next: Member references and reflection &amp;rarr;</source>
          <target state="translated">다음 : 회원 참조 및 반영 &amp;rarr;</target>
        </trans-unit>
        <trans-unit id="47130dd2717d7971c3c94623669be8f3f6e6f3ff" translate="yes" xml:space="preserve">
          <source>Next: Null safety &amp;rarr;</source>
          <target state="translated">다음 : Null 안전 &amp;rarr;</target>
        </trans-unit>
        <trans-unit id="86e91a1d2169b2b6d5f0e4158807082816cf024d" translate="yes" xml:space="preserve">
          <source>Next: Objects and companion objects &amp;rarr;</source>
          <target state="translated">다음 : 객체 및 컴패니언 객체 &amp;rarr;</target>
        </trans-unit>
        <trans-unit id="6bfa5e253a9933523c52548db5718fffcec08ff4" translate="yes" xml:space="preserve">
          <source>Next: Packages and imports &amp;rarr;</source>
          <target state="translated">다음 : 패키지 및 수입품 &amp;rarr;</target>
        </trans-unit>
        <trans-unit id="61b315e1a975491d53d3e93505ae2e73a35eccf9" translate="yes" xml:space="preserve">
          <source>Next: Primitive data types and their limitations &amp;rarr;</source>
          <target state="translated">다음 : 기본 데이터 유형 및 제한 사항 &amp;rarr;</target>
        </trans-unit>
        <trans-unit id="a8e3f58e4df0923f458764df8d805bc1daaebc52" translate="yes" xml:space="preserve">
          <source>Next: Scoped resource usage &amp;rarr;</source>
          <target state="translated">다음 : 범위 지정된 자원 사용 &amp;rarr;</target>
        </trans-unit>
        <trans-unit id="d22ef24051b74c0f8f3a98dbd34b162df22e8d8a" translate="yes" xml:space="preserve">
          <source>Next: Strings &amp;rarr;</source>
          <target state="translated">다음 : 문자열 &amp;rarr;</target>
        </trans-unit>
        <trans-unit id="df94caa7ffe6e8dba6f94ac077da12da6df4dd88" translate="yes" xml:space="preserve">
          <source>Next: Visibility modifiers &amp;rarr;</source>
          <target state="translated">다음 : 가시성 수정 자 &amp;rarr;</target>
        </trans-unit>
        <trans-unit id="dd6dd817ee9557c6ebd9ce223abe7e65e35724c3" translate="yes" xml:space="preserve">
          <source>Nice utility functions</source>
          <target state="translated">좋은 유틸리티 기능</target>
        </trans-unit>
        <trans-unit id="816c52fd2bdd94a63cd0944823a6c0aa9384c103" translate="yes" xml:space="preserve">
          <source>No</source>
          <target state="translated">No</target>
        </trans-unit>
        <trans-unit id="fc6d6d07a9da4b1cf8d3f863c9932b05d0b9d378" translate="yes" xml:space="preserve">
          <source>No &lt;code&gt;EXPRESSION&lt;/code&gt; and &lt;code&gt;FILE&lt;/code&gt; among &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.annotation/-annotation-target/index&quot;&gt;targets&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.annotation/-annotation-target/index&quot;&gt;대상&lt;/a&gt; 간에 &lt;code&gt;EXPRESSION&lt;/code&gt; 및 &lt;code&gt;FILE&lt;/code&gt; 이 없습니다.</target>
        </trans-unit>
        <trans-unit id="d50a5c00dba30dbb17216b740546f411fd49910a" translate="yes" xml:space="preserve">
          <source>No custom getter</source>
          <target state="translated">맞춤 게터 없음</target>
        </trans-unit>
        <trans-unit id="c2792086f80dff691fc70c60e9944bd70ee578bb" translate="yes" xml:space="preserve">
          <source>No locks are used to synchronize an access to the &lt;a href=&quot;../-lazy/index&quot;&gt;Lazy&lt;/a&gt; instance value; if the instance is accessed from multiple threads, its behavior is undefined.</source>
          <target state="translated">&lt;a href=&quot;../-lazy/index&quot;&gt;Lazy&lt;/a&gt; 인스턴스 값에 대한 액세스를 동기화하는 데 잠금이 사용되지 않습니다 . 여러 스레드에서 인스턴스에 액세스하면 해당 동작이 정의되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="1576fb8454236b0d4fa99182ffbcc64b6805f9d7" translate="yes" xml:space="preserve">
          <source>No need to mark the Application class as &lt;em&gt;open&lt;/em&gt; since we are using the &lt;em&gt;kotlin-spring&lt;/em&gt; Gradle plugin which does that automatically.</source>
          <target state="translated">우리가 자동으로 하는 &lt;em&gt;kotlin-spring&lt;/em&gt; Gradle 플러그인을 사용하기 때문에 Application 클래스를 &lt;em&gt;열린&lt;/em&gt; 것으로 표시 할 필요가 없습니다 .&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="1ea178000db803133ca4ed5bf0f26cf40a2ac141" translate="yes" xml:space="preserve">
          <source>No parameters.</source>
          <target state="translated">매개 변수가 없습니다.</target>
        </trans-unit>
        <trans-unit id="a39dbb3db1c73d98fb6e9bf0a6cc7fe2780640aa" translate="yes" xml:space="preserve">
          <source>No raw types</source>
          <target state="translated">원시 유형 없음</target>
        </trans-unit>
        <trans-unit id="4512f94421443be3bb6fe68bb037823683ccfd0a" translate="yes" xml:space="preserve">
          <source>No-arg compiler plugin</source>
          <target state="translated">인수없는 컴파일러 플러그인</target>
        </trans-unit>
        <trans-unit id="ec11a5bdeaa38cafa1809cd0b1418fa7f8f3cfef" translate="yes" xml:space="preserve">
          <source>No. Kotlin lets you choose between generating Java 6 and Java 8 compatible bytecode. More optimal byte code may be generated for higher versions of the platform.</source>
          <target state="translated">Kotlin을 사용하면 Java 6 및 Java 8 호환 바이트 코드 생성 중에서 선택할 수 있습니다. 더 높은 버전의 플랫폼에 대해 더 최적의 바이트 코드가 생성 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ce3234172e6888dbe6cf68e5d69aca93bdbdb6aa" translate="yes" xml:space="preserve">
          <source>No: called without the context object</source>
          <target state="translated">아니오 : 컨텍스트 객체없이 호출</target>
        </trans-unit>
        <trans-unit id="44924246111ca028f4b377861fa8b1a56b2f8f3f" translate="yes" xml:space="preserve">
          <source>No: takes the context object as an argument.</source>
          <target state="translated">아니오 : 컨텍스트 오브젝트를 인수로 사용합니다.</target>
        </trans-unit>
        <trans-unit id="23a71e363ee25bc12526201fd5e1559555edeab5" translate="yes" xml:space="preserve">
          <source>NoSuchElementException</source>
          <target state="translated">NoSuchElementException</target>
        </trans-unit>
        <trans-unit id="9a296716d89fec45e837ec162f0a3cdfae0666f6" translate="yes" xml:space="preserve">
          <source>NoSuchFileException</source>
          <target state="translated">NoSuchFileException</target>
        </trans-unit>
        <trans-unit id="8e965431f22047ddfc939473709e81428fafe4f0" translate="yes" xml:space="preserve">
          <source>NoSuchPropertyException</source>
          <target state="translated">NoSuchPropertyException</target>
        </trans-unit>
        <trans-unit id="dd82911bf9c2f7cf6fe3c3a3a0486e6fd4980949" translate="yes" xml:space="preserve">
          <source>NoWhenBranchMatchedException</source>
          <target state="translated">NoWhenBranchMatchedException</target>
        </trans-unit>
        <trans-unit id="6d1452836a5e358d27de613d82985d8f206e4345" translate="yes" xml:space="preserve">
          <source>NodeFilter</source>
          <target state="translated">NodeFilter</target>
        </trans-unit>
        <trans-unit id="749f705e68c34826a7cc3dffa5cbbe3e73f820de" translate="yes" xml:space="preserve">
          <source>NodeIterator</source>
          <target state="translated">NodeIterator</target>
        </trans-unit>
        <trans-unit id="05a2a8746fe10231011b4d6850be527a41c1c732" translate="yes" xml:space="preserve">
          <source>NodeList</source>
          <target state="translated">NodeList</target>
        </trans-unit>
        <trans-unit id="683af661ab161f85e9822c648db026a9cf30dda6" translate="yes" xml:space="preserve">
          <source>Non-constant vararg annotation parameters</source>
          <target state="translated">불변의 vararg 주석 매개 변수</target>
        </trans-unit>
        <trans-unit id="dc9767217a1c7b0bf421fbdc439c549407505217" translate="yes" xml:space="preserve">
          <source>Non-existent type correction</source>
          <target state="translated">존재하지 않는 유형 수정</target>
        </trans-unit>
        <trans-unit id="4faaccd91d30b37f731dad2f02cd8a91e9099b87" translate="yes" xml:space="preserve">
          <source>Non-local returns</source>
          <target state="translated">로컬이 아닌 반품</target>
        </trans-unit>
        <trans-unit id="92dc2c3bbe1e4d97caf60f89e03fd837acb72669" translate="yes" xml:space="preserve">
          <source>Non-private fields</source>
          <target state="translated">비공개 필드</target>
        </trans-unit>
        <trans-unit id="f8f526d37ae54edc0292fa3b9fb52e0ef28cf4f3" translate="yes" xml:space="preserve">
          <source>Non-propagating use</source>
          <target state="translated">전파하지 않는 사용</target>
        </trans-unit>
        <trans-unit id="806c74a6dd444e7b581fe8d0651c3b583f7e4a35" translate="yes" xml:space="preserve">
          <source>NonDocumentTypeChildNode</source>
          <target state="translated">NonDocumentTypeChildNode</target>
        </trans-unit>
        <trans-unit id="928c9a9956e3637b60b5e9617db297b95e7290fd" translate="yes" xml:space="preserve">
          <source>NonElementParentNode</source>
          <target state="translated">NonElementParentNode</target>
        </trans-unit>
        <trans-unit id="d75dfc52cb45227dc75a26a76fe24ef6aeb82f70" translate="yes" xml:space="preserve">
          <source>Normal functions (not marked as inline) cannot have reified parameters. A type that does not have a run-time representation (e.g. a non-reified type parameter or a fictitious type like &lt;code&gt;Nothing&lt;/code&gt;) cannot be used as an argument for a reified type parameter.</source>
          <target state="translated">일반 기능 (인라인으로 표시되지 않음)에는 매개 변수를 수정할 수 없습니다. 런타임 표현이없는 유형 (예 : 비 유형 유형 매개 변수 또는 &lt;code&gt;Nothing&lt;/code&gt; 과 같은 가상 유형 )은 유형 유형 매개 변수의 인수로 사용할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="49a45a50e6244c47619f28727155a0cbe41bd131" translate="yes" xml:space="preserve">
          <source>Normal methods can be overridden using the &lt;code&gt;override&lt;/code&gt; Kotlin keyword. In this case the overriding method must have the same parameter names as the overridden one.</source>
          <target state="translated">&lt;code&gt;override&lt;/code&gt; Kotlin 키워드를 사용하여 일반적인 방법을 재정의 할 수 있습니다 . 이 경우 대체 메소드는 대체 메소드와 동일한 매개 변수 이름을 가져야합니다.</target>
        </trans-unit>
        <trans-unit id="a916e7bdcd294dc74af71b748cdce7d82df98e31" translate="yes" xml:space="preserve">
          <source>Normally, if you write a Kotlin function with default parameter values, it will be visible in Java only as a full signature, with all parameters present. If you wish to expose multiple overloads to Java callers, you can use the &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.jvm/-jvm-overloads/index&quot;&gt;&lt;code&gt;@JvmOverloads&lt;/code&gt;&lt;/a&gt; annotation.</source>
          <target state="translated">일반적으로 기본 매개 변수 값으로 Kotlin 함수를 작성하면 모든 매개 변수가있는 Java에서만 전체 서명으로 표시됩니다. 여러 &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.jvm/-jvm-overloads/index&quot;&gt; &lt;code&gt;@JvmOverloads&lt;/code&gt; &lt;/a&gt; 을 Java 호출자에게 노출하려면 @JvmOverloads 주석을 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="6a89db40e0b8cfbd047b44012190c470a3ee8af7" translate="yes" xml:space="preserve">
          <source>Normally, properties declared as having a non-null type must be initialized in the constructor. However, fairly often this is not convenient. For example, properties can be initialized through dependency injection, or in the setup method of a unit test. In this case, you cannot supply a non-null initializer in the constructor, but you still want to avoid null checks when referencing the property inside the body of a class.</source>
          <target state="translated">일반적으로 null이 아닌 유형으로 선언 된 속성은 생성자에서 초기화해야합니다. 그러나 이것은 종종 편리하지 않습니다. 예를 들어, 속성은 의존성 주입을 통해 또는 단위 테스트의 설정 방법으로 초기화 될 수 있습니다. 이 경우 생성자에 null이 아닌 이니셜 라이저를 제공 할 수 없지만 클래스 본문 내에서 속성을 참조 할 때 null 검사를 피하려고합니다.</target>
        </trans-unit>
        <trans-unit id="a967d31a488ea79d5210d74fd176b0b854f6d231" translate="yes" xml:space="preserve">
          <source>Not only classes can have type parameters. Functions can, too. Type parameters are placed &lt;strong&gt;before&lt;/strong&gt; the name of the function:</source>
          <target state="translated">클래스 만이 타입 파라미터를 가질 수있는 것은 아닙니다. 기능도 가능합니다. 유형 매개 변수는 함수 이름 &lt;strong&gt;앞에&lt;/strong&gt; 배치 됩니다.</target>
        </trans-unit>
        <trans-unit id="2efce3f5aa2c271d194d1082031602e01c017249" translate="yes" xml:space="preserve">
          <source>Not use any members that take a star-projected type as a parameter</source>
          <target state="translated">별 투영 된 유형을 매개 변수로 사용하는 멤버를 사용하지 마십시오</target>
        </trans-unit>
        <trans-unit id="68b62df2b207d9543eb97cef507795cf7a5eb731" translate="yes" xml:space="preserve">
          <source>Not-null assertion operator</source>
          <target state="translated">널이 아닌 어설 션 연산자</target>
        </trans-unit>
        <trans-unit id="8850b3bd61499741c05bd500ea7929ed489941ca" translate="yes" xml:space="preserve">
          <source>NotImplementedError</source>
          <target state="translated">NotImplementedError</target>
        </trans-unit>
        <trans-unit id="0525b1fa9e28d14aa40cc8644228138fdab333ad" translate="yes" xml:space="preserve">
          <source>Notation for Platform Types</source>
          <target state="translated">플랫폼 유형 표기법</target>
        </trans-unit>
        <trans-unit id="346c210a245c6f4ac5e207e281e87f32eaf27522" translate="yes" xml:space="preserve">
          <source>Note how &lt;a href=&quot;../reference/properties#late-initialized-properties-and-variables&quot;&gt;the lateinit modifier&lt;/a&gt; allows to declare a non-null type initialized after the object is created (after the constructor call). Without &lt;code&gt;lateinit&lt;/code&gt; you'd have to declare a &lt;a href=&quot;../reference/null-safety&quot;&gt;nullable type&lt;/a&gt; and add additional nullability checks.</source>
          <target state="translated">&lt;a href=&quot;../reference/properties#late-initialized-properties-and-variables&quot;&gt;lateinit 수정자가&lt;/a&gt; 오브젝트를 작성한 후 (생성자 호출 후) 초기화 된 널이 아닌 유형을 선언하는 방법 에 유의하십시오 . &lt;code&gt;lateinit&lt;/code&gt; 가 없으면 &lt;a href=&quot;../reference/null-safety&quot;&gt;널 입력 가능 유형&lt;/a&gt; 을 선언 하고 추가 널 입력 가능 점검을 추가해야합니다.</target>
        </trans-unit>
        <trans-unit id="ece9aff9cfec4f422a4dd193e67bb220717aeb47" translate="yes" xml:space="preserve">
          <source>Note how easily one may forget the corresponding context element and then still safely access thread local. To avoid such situations, it is recommended to use &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/java.lang.-thread-local/ensure-present.html&quot;&gt;ensurePresent&lt;/a&gt; method and fail-fast on improper usages.</source>
          <target state="translated">해당 컨텍스트 요소를 잊어 버린 다음 여전히 안전하게 로컬 스레드에 액세스 할 수 있습니다. 이러한 상황을 피하려면, 부적절한 사용에 대해 &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/java.lang.-thread-local/ensure-present.html&quot;&gt;verifyPresent&lt;/a&gt; 방법 을 사용 하고 페일 패스트하는 것이 좋습니다 .</target>
        </trans-unit>
        <trans-unit id="27e144234fbe29431367eab42a112f44ba9e6e90" translate="yes" xml:space="preserve">
          <source>Note on visibility</source>
          <target state="translated">가시성에 대한 참고 사항</target>
        </trans-unit>
        <trans-unit id="f7e11b4556b13f0f82fdc5bafcd108c64e182fe4" translate="yes" xml:space="preserve">
          <source>Note that &lt;a href=&quot;android-plugin&quot;&gt;Kotlin Android Extensions&lt;/a&gt; plugin (automatically bundled into the Kotlin plugin in Android Studio) solves the same issue: replacing &lt;code&gt;findViewById&lt;/code&gt; with a concise and straightforward code. Consider using it unless you're already using ButterKnife and don't want to migrate.</source>
          <target state="translated">하는 것으로 &lt;a href=&quot;android-plugin&quot;&gt;코 틀린 안드로이드 확장&lt;/a&gt; (자동 안드로이드 스튜디오에서 코 틀린 플러그인에 번들) 플러그인이 같은 문제를 해결 : 교체 &lt;code&gt;findViewById&lt;/code&gt; 를을 간결하고 간단한 코드. ButterKnife를 이미 사용 중이 지 않고 마이그레이션하고 싶지 않다면 사용을 고려하십시오.</target>
        </trans-unit>
        <trans-unit id="b10bef8aca468769cab7ca0f31c1ca35bfeef062" translate="yes" xml:space="preserve">
          <source>Note that &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.channels/on-receive-or-null.html&quot;&gt;onReceiveOrNull&lt;/a&gt; is an extension function defined only for channels with non-nullable elements so that there is no accidental confusion between a closed channel and a null value.</source>
          <target state="translated">참고 &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.channels/on-receive-or-null.html&quot;&gt;onReceiveOrNull는&lt;/a&gt; 폐쇄 채널 및 널 (null) 값 사이의 우발적 인 혼란이 없도록 단지 비 - 널 요소 채널에 대해 정의 된 확장 기능이다.</target>
        </trans-unit>
        <trans-unit id="23cd4a64981ce83f9769929d7af16453dd2385a0" translate="yes" xml:space="preserve">
          <source>Note that &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.channels/ticker.html&quot;&gt;ticker&lt;/a&gt; is aware of possible consumer pauses and, by default, adjusts next produced element delay if a pause occurs, trying to maintain a fixed rate of produced elements.</source>
          <target state="translated">그 주 &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.channels/ticker.html&quot;&gt;시세는&lt;/a&gt; 생산 요소의 고정 금리를 유지하기 위해 노력하고, 기본, 일시 정지가 발생하면 다음 요소 지연을 생산가 조정하여 가능한 소비자 일시 정지를 인식하고.</target>
        </trans-unit>
        <trans-unit id="e4f574aa6b81a2a53d14300616da27a08406bc5d" translate="yes" xml:space="preserve">
          <source>Note that &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/is-active.html&quot;&gt;isActive&lt;/a&gt; in &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-coroutine-scope/index.html&quot;&gt;CoroutineScope&lt;/a&gt; is just a convenient shortcut for &lt;code&gt;coroutineContext[Job]?.isActive == true&lt;/code&gt;.</source>
          <target state="translated">참고 &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/is-active.html&quot;&gt;이 isActive&lt;/a&gt; 에서 &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-coroutine-scope/index.html&quot;&gt;CoroutineScope는&lt;/a&gt; 단지 편리한 단축키이다 &lt;code&gt;coroutineContext[Job]?.isActive == true&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="643f0957c5be70b41f4b5877b3662ee68c79f859" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;-&lt;/code&gt; is an &lt;em&gt;invalid&lt;/em&gt; symbol in Java, meaning that it's impossible to call functions which accept inline classes from Java.</source>
          <target state="translated">참고 그 &lt;code&gt;-&lt;/code&gt; 입니다 &lt;em&gt;무효&lt;/em&gt; 가 자바에서 인라인 클래스를 받아 함수를 호출하는 것은 불가능하다는 의미에서 자바의 상징.</target>
        </trans-unit>
        <trans-unit id="326418c4e5742c7d5633cf6eb21a36a9bd5007fa" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;associate()&lt;/code&gt; produces short-living &lt;code&gt;Pair&lt;/code&gt; objects which may affect the performance. Thus, &lt;code&gt;associate()&lt;/code&gt; should be used when the performance isn't critical or it's more preferable than other options.</source>
          <target state="translated">connect &lt;code&gt;associate()&lt;/code&gt; 는 성능에 영향을 줄 수 있는 수명이 짧은 &lt;code&gt;Pair&lt;/code&gt; 객체를 생성 합니다. 따라서 성능이 중요하지 않거나 다른 옵션보다 선호되는 경우 &lt;code&gt;associate()&lt;/code&gt; 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="4712744d1c59fe11b666d701399f2acdde076310" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;external&lt;/code&gt; modifier is inherited by nested declarations, i.e. in &lt;code&gt;Node&lt;/code&gt; class we do not put &lt;code&gt;external&lt;/code&gt; before member functions and properties.</source>
          <target state="translated">참고 &lt;code&gt;external&lt;/code&gt; 수정이 중첩 된 선언, 즉 상속 &lt;code&gt;Node&lt;/code&gt; 클래스는 우리는 넣지 마십시오 &lt;code&gt;external&lt;/code&gt; 멤버 함수와 속성 전에.</target>
        </trans-unit>
        <trans-unit id="7c2abf53e89201db42a6d7da34bd24e5d79ffb90" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;jQuery&lt;/code&gt; needs to be included in the corresponding HTML:</source>
          <target state="translated">하는 것으로 &lt;code&gt;jQuery&lt;/code&gt; 를가 해당 HTML에 포함되어야합니다 :</target>
        </trans-unit>
        <trans-unit id="a130b307700ca7edccdf73fda8c49be967259f51" translate="yes" xml:space="preserve">
          <source>Note that &lt;em&gt;null&lt;/em&gt; cannot be cast to &lt;code&gt;String&lt;/code&gt; as this type is not &lt;a href=&quot;null-safety&quot;&gt;nullable&lt;/a&gt;, i.e. if &lt;code&gt;y&lt;/code&gt; is null, the code above throws an exception. In order to match Java cast semantics we have to have nullable type at cast right hand side, like:</source>
          <target state="translated">참고 &lt;em&gt;널 (null)이&lt;/em&gt; 캐스트 할 수없는 &lt;code&gt;String&lt;/code&gt; 이 유형으로는하지 &lt;a href=&quot;null-safety&quot;&gt;Null을 허용&lt;/a&gt; 하는 경우 즉, &lt;code&gt;y&lt;/code&gt; 는 null의 경우, 위의 코드에서 예외가 발생합니다. Java 캐스트 시맨틱을 일치 시키려면 다음과 같이 캐스트 오른쪽에 널 입력 가능 유형이 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="3b25bca041a3db971a025c2e5df5df075febfd74" translate="yes" xml:space="preserve">
          <source>Note that KDoc does not have any syntax for resolving overloaded members in links. Since the Kotlin documentation generation tool puts the documentation for all overloads of a function on the same page, identifying a specific overloaded function is not required for the link to work.</source>
          <target state="translated">KDoc에는 링크에서 오버로드 된 멤버를 해결하기위한 구문이 없습니다. Kotlin 문서 생성 도구는 기능의 모든 과부하에 대한 문서를 동일한 페이지에 배치하므로 링크가 작동하기 위해 특정 오버로드 된 기능을 식별 할 필요는 없습니다.</target>
        </trans-unit>
        <trans-unit id="378fb47127c89ebfae61cf028d6a1d9ec0aaa851" translate="yes" xml:space="preserve">
          <source>Note that Kapt does not support multiple rounds for the generated Kotlin files.</source>
          <target state="translated">Kapt는 생성 된 Kotlin 파일에 대해 여러 라운드를 지원하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="f3383898decca7a9f7b6deb5d495a2e5e68df372" translate="yes" xml:space="preserve">
          <source>Note that Kotlin compiler does not apply such mangling to &lt;code&gt;external&lt;/code&gt; declarations, so you don't have to use &lt;code&gt;@JsName&lt;/code&gt; on them. Another case worth noticing is inheriting non-external classes from external classes. In this case any overridden functions won't be mangled as well.</source>
          <target state="translated">Kotlin 컴파일러는 이러한 선언 을 &lt;code&gt;external&lt;/code&gt; 선언에 적용 하지 않으므로 &lt;code&gt;@JsName&lt;/code&gt; 을 사용할 필요가 없습니다 . 주목할만한 또 다른 경우는 외부 클래스에서 비 외부 클래스를 상속하는 것입니다. 이 경우 재정의 된 함수는 엉망이되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="123a11d8fa5ed53f8ac07b91892dff993cf556e9" translate="yes" xml:space="preserve">
          <source>Note that Kotlin does not have a &lt;em&gt;new&lt;/em&gt; keyword.</source>
          <target state="translated">Kotlin에는 &lt;em&gt;새로운&lt;/em&gt; 키워드 가 없습니다 .</target>
        </trans-unit>
        <trans-unit id="24cefba751ca3442834b1d28297766c4dedb14f5" translate="yes" xml:space="preserve">
          <source>Note that SAM conversions only work for interfaces, not for abstract classes, even if those also have just a single abstract method.</source>
          <target state="translated">SAM 변환은 추상 클래스가 아닌 추상 클래스가 아닌 인터페이스에 대해서만 작동합니다.</target>
        </trans-unit>
        <trans-unit id="50497e29cee31d617bb240dff5362b9731a558da" translate="yes" xml:space="preserve">
          <source>Note that a &lt;code&gt;for&lt;/code&gt; loop always implicitly declares a new read-only variable (in this example, &lt;code&gt;name&lt;/code&gt;) - if the outer scope already contains a variable with the same name, it will be shadowed by the unrelated loop variable. For the same reason, the final value of the loop variable is not accessible after the loop.</source>
          <target state="translated">&amp;bull; 그래도 참고 &lt;code&gt;for&lt;/code&gt; 루프가 항상 암시 적으로 (이 예에서는, 새로운 읽기 전용 변수 선언 &lt;code&gt;name&lt;/code&gt; ) - 외부 범위가 이미 같은 이름의 변수를 포함하는 경우, 그것은 관련없는 루프 변수에 의해 그림자가 될 것입니다. 같은 이유로 루프 후 루프 변수의 최종 값에 액세스 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="f345c0305c039a5c5d92b2679df3ab69307a3616" translate="yes" xml:space="preserve">
          <source>Note that a Kotlin class reference is not the same as a Java class reference. To obtain a Java class reference, use the &lt;code&gt;.java&lt;/code&gt; property on a &lt;code&gt;KClass&lt;/code&gt; instance.</source>
          <target state="translated">Kotlin 클래스 참조는 Java 클래스 참조와 동일하지 않습니다. Java 클래스 참조를 얻으려면 &lt;code&gt;KClass&lt;/code&gt; 인스턴스 에서 &lt;code&gt;.java&lt;/code&gt; 속성을 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="0206a8d998dc749c92f53c56e6d927b2e3bb8c96" translate="yes" xml:space="preserve">
          <source>Note that a boxed primitive type used as a type parameter is mapped to a platform type: for example, &lt;code&gt;List&amp;lt;java.lang.Integer&amp;gt;&lt;/code&gt; becomes a &lt;code&gt;List&amp;lt;Int!&amp;gt;&lt;/code&gt; in Kotlin.</source>
          <target state="translated">형식 매개 변수로 사용되는 박스형 기본 형식은 플랫폼 형식에 매핑됩니다. 예를 들어 &lt;code&gt;List&amp;lt;java.lang.Integer&amp;gt;&lt;/code&gt; 는 Kotlin에서 &lt;code&gt;List&amp;lt;Int!&amp;gt;&lt;/code&gt; 됩니다.</target>
        </trans-unit>
        <trans-unit id="cda0f8a2d7cf131c070c968ead3e02616cc75710" translate="yes" xml:space="preserve">
          <source>Note that a file marked with the &lt;code&gt;@JsQualifier(...)&lt;/code&gt; annotation can't contain non-&lt;code&gt;external&lt;/code&gt; declarations.</source>
          <target state="translated">&lt;code&gt;@JsQualifier(...)&lt;/code&gt; 주석으로 표시된 파일 은 비 &lt;code&gt;external&lt;/code&gt; 선언을 포함 할 수 없습니다 .</target>
        </trans-unit>
        <trans-unit id="406525d21e4a3c81c722c7741ff866f95a0130cf" translate="yes" xml:space="preserve">
          <source>Note that a function type with no receiver is inferred by default, even if a variable is initialized with a reference to an extension function. To alter that, specify the variable type explicitly.</source>
          <target state="translated">확장 함수를 참조하여 변수를 초기화하더라도 수신기가없는 함수 유형이 기본적으로 유추됩니다. 이를 변경하려면 변수 유형을 명시 적으로 지정하십시오.</target>
        </trans-unit>
        <trans-unit id="b53df8b9afb9e806e949a0d6af036fa85a8a9db9" translate="yes" xml:space="preserve">
          <source>Note that a module referenced by a dependency declared for &lt;code&gt;commonMain&lt;/code&gt; or &lt;code&gt;commonTest&lt;/code&gt; source set must be published using the &lt;code&gt;kotlin-multiplatform&lt;/code&gt; plugin. If you want to use libraries published by the &lt;code&gt;kotlin-platform-native&lt;/code&gt; plugin, you need to declare a separate source set for common native sources.</source>
          <target state="translated">&lt;code&gt;commonMain&lt;/code&gt; 또는 &lt;code&gt;commonTest&lt;/code&gt; 소스 세트에 선언 된 종속성이 참조하는 모듈 은 &lt;code&gt;kotlin-multiplatform&lt;/code&gt; 플러그인을 사용하여 공개해야합니다 . &lt;code&gt;kotlin-platform-native&lt;/code&gt; 플러그인에서 공개 한 라이브러리를 사용하려면 공통 기본 소스에 대해 별도의 소스 세트를 선언해야합니다.</target>
        </trans-unit>
        <trans-unit id="07dbd163eca990505b14bc6390f514e8f9d894c6" translate="yes" xml:space="preserve">
          <source>Note that a read-only variable is not a constant per se: it can be initialized with the value of a variable (so its value doesn't need to be known at compile-time), and if it is declared inside a construct that is repeatedly invoked (such as a function or a loop), it can take on a different value on each invocation. Also, while the read-only variable may not be reassigned while it is in scope, it can still refer to an object which is in itself mutable (such as a list).</source>
          <target state="translated">읽기 전용 변수는 그 자체가 상수가 아닙니다. 변수의 값으로 초기화 할 수 있으므로 (컴파일 타임에 값을 알 필요가 없습니다.) 함수 또는 루프와 같이 반복적으로 호출되면 호출마다 다른 값을 취할 수 있습니다. 또한 읽기 전용 변수는 범위 내에있는 동안 재 할당되지 않을 수 있지만 여전히 변경 가능한 개체 (예 : 목록)를 참조 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="89edad7d707ce970adc3246bd03659328accf5e4" translate="yes" xml:space="preserve">
          <source>Note that all classes in this tutorial are in the &lt;code&gt;org.jetbrains.kotlin.demo&lt;/code&gt; package.</source>
          <target state="translated">이 학습서의 모든 클래스는 &lt;code&gt;org.jetbrains.kotlin.demo&lt;/code&gt; 패키지에 있습니다.</target>
        </trans-unit>
        <trans-unit id="e339722ad427ded0a06508490a0f24fc47b54f2b" translate="yes" xml:space="preserve">
          <source>Note that altering a mutable collection doesn't require it to be a &lt;a href=&quot;basic-syntax#defining-variables&quot;&gt;&lt;code&gt;var&lt;/code&gt;&lt;/a&gt;: write operations modify the same mutable collection object, so the reference doesn't change. Although, if you try to reassign a &lt;code&gt;val&lt;/code&gt; collection, you'll get a compilation error.</source>
          <target state="translated">변경 가능한 컬렉션을 변경한다고해서 &lt;a href=&quot;basic-syntax#defining-variables&quot;&gt; &lt;code&gt;var&lt;/code&gt; &lt;/a&gt; 가 될 필요는 없습니다 . 쓰기 작업은 동일한 변경 가능한 컬렉션 개체를 수정하므로 참조는 변경되지 않습니다. &lt;code&gt;val&lt;/code&gt; 컬렉션 을 다시 할당하려고 하면 컴파일 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="402c9cc77c78831d6ef7a6f5b12edeefd76b9797" translate="yes" xml:space="preserve">
          <source>Note that an &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.channels/actor.html&quot;&gt;actor&lt;/a&gt; coroutine builder is a dual of &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.channels/produce.html&quot;&gt;produce&lt;/a&gt; coroutine builder. An actor is associated with the channel that it receives messages from, while a producer is associated with the channel that it sends elements to.</source>
          <target state="translated">있습니다 &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.channels/actor.html&quot;&gt;배우&lt;/a&gt; 코 루틴 빌더의 듀얼입니다 &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.channels/produce.html&quot;&gt;생산&lt;/a&gt; 코 루틴 빌더. 액터는 메시지를받는 채널과 관련이있는 반면 프로듀서는 요소를 보내는 채널과 연결됩니다.</target>
        </trans-unit>
        <trans-unit id="3f7eda5be515629fb292c86295db20e329d1452f" translate="yes" xml:space="preserve">
          <source>Note that an order of &lt;a href=&quot;compare-by-descending#kotlin.comparisons%24compareByDescending%28kotlin.Comparator%28%28kotlin.comparisons.compareByDescending.K%29%29%2C+kotlin.Function1%28%28kotlin.comparisons.compareByDescending.T%2C+kotlin.comparisons.compareByDescending.K%29%29%29%2Fcomparator&quot;&gt;comparator&lt;/a&gt; is reversed by this wrapper.</source>
          <target state="translated">이 랩퍼는 &lt;a href=&quot;compare-by-descending#kotlin.comparisons%24compareByDescending%28kotlin.Comparator%28%28kotlin.comparisons.compareByDescending.K%29%29%2C+kotlin.Function1%28%28kotlin.comparisons.compareByDescending.T%2C+kotlin.comparisons.compareByDescending.K%29%29%29%2Fcomparator&quot;&gt;비교기&lt;/a&gt; 순서를 반대로합니다.</target>
        </trans-unit>
        <trans-unit id="e5cfcc2bcacb2464eb49e0f0ddd2d5c9c0f5de73" translate="yes" xml:space="preserve">
          <source>Note that anonymous function parameters are always passed inside the parentheses. The shorthand syntax allowing to leave the function outside the parentheses works only for lambda expressions.</source>
          <target state="translated">익명 함수 매개 변수는 항상 괄호 안에 전달됩니다. 함수를 괄호 밖에 둘 수있는 속기 구문은 람다 식에만 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="9217d029286f8cd07e91756805e90b92b90c8d04" translate="yes" xml:space="preserve">
          <source>Note that anonymous objects can be used as types only in local and private declarations. If you use an anonymous object as a return type of a public function or the type of a public property, the actual type of that function or property will be the declared supertype of the anonymous object, or &lt;code&gt;Any&lt;/code&gt; if you didn't declare any supertype. Members added in the anonymous object will not be accessible.</source>
          <target state="translated">익명 객체는 로컬 및 개인 선언에서만 유형으로 사용할 수 있습니다. 익명 객체를 공용 함수의 반환 유형 또는 공용 속성의 유형으로 사용하는 경우 해당 함수 또는 속성의 실제 유형은 익명 객체의 선언 된 수퍼 타입이거나, 수퍼 타입을 선언하지 않은 경우 &lt;code&gt;Any&lt;/code&gt; 입니다. . 익명 개체에 추가 된 멤버는 액세스 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="58e17f85bfcb71bf347b7f266c8bad279b3e8c99" translate="yes" xml:space="preserve">
          <source>Note that another regular expression constructed from the same pattern string may have different &lt;a href=&quot;options#kotlin.text.Regex%24options&quot;&gt;options&lt;/a&gt; and may match strings differently.</source>
          <target state="translated">동일한 패턴 문자열로 구성된 다른 정규식은 다른 &lt;a href=&quot;options#kotlin.text.Regex%24options&quot;&gt;옵션을&lt;/a&gt; 가질 수 있으며 문자열을 다르게 일치시킬 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0e1195c36b54acff13f3bf0d0c44bfdb9ba62965" translate="yes" xml:space="preserve">
          <source>Note that blank lines do not affect the detected indent level.</source>
          <target state="translated">빈 줄은 감지 된 들여 쓰기 수준에 영향을주지 않습니다.</target>
        </trans-unit>
        <trans-unit id="901eb90b706fa87b74726ae4ca585fc8ee1df3bd" translate="yes" xml:space="preserve">
          <source>Note that both the target platform and the name matter: if a target was created as &lt;code&gt;jvm('jvm6')&lt;/code&gt;, using &lt;code&gt;jvm()&lt;/code&gt; will create a separate target (with the default name &lt;code&gt;jvm&lt;/code&gt;). If the preset function used to create the target under that name was different, an error is reported.</source>
          <target state="translated">목표는 다음과 같이 생성 된 경우 : 대상 플랫폼과 이름없이 모두 유의 &lt;code&gt;jvm('jvm6')&lt;/code&gt; 사용하여 &lt;code&gt;jvm()&lt;/code&gt; (기본 이름을 가진 별도의 목표 만듭니다 &lt;code&gt;jvm&lt;/code&gt; ). 해당 이름으로 대상을 작성하는 데 사용 된 사전 설정 기능이 다른 경우 오류가보고됩니다.</target>
        </trans-unit>
        <trans-unit id="20a8a158a1c056ad5cea3eaeda038189df025fb8" translate="yes" xml:space="preserve">
          <source>Note that boxing of numbers does not necessarily preserve identity:</source>
          <target state="translated">숫자를 복싱한다고해서 반드시 정체성이 보존되는 것은 아닙니다.</target>
        </trans-unit>
        <trans-unit id="18f0c3bd108e4fca3d9b4ad0c92853cb37af67e8" translate="yes" xml:space="preserve">
          <source>Note that cancelling a producer coroutine closes its channel, thus eventually terminating iteration over the channel that processor coroutines are doing.</source>
          <target state="translated">생산자 코 루틴을 취소하면 채널이 닫히고 결국 프로세서 코 루틴이 수행중인 채널에 대한 반복이 종료됩니다.</target>
        </trans-unit>
        <trans-unit id="a4257481b27fd911ec2dc62a1694406a02635294" translate="yes" xml:space="preserve">
          <source>Note that changing type from unsigned type to signed counterpart (and vice versa) is a &lt;em&gt;binary incompatible&lt;/em&gt; change</source>
          <target state="translated">서명되지 않은 유형에서 서명 된 상대방으로 유형을 변경 하면 그와도 &lt;em&gt;호환되지 않습니다.&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="fb531691886575d5d0b4f4f27624c19223bae127" translate="yes" xml:space="preserve">
          <source>Note that characters are not numbers in Kotlin.</source>
          <target state="translated">Kotlin의 문자는 숫자가 아닙니다.</target>
        </trans-unit>
        <trans-unit id="224781b538ad44d496b4eb9848adbb611bc7607f" translate="yes" xml:space="preserve">
          <source>Note that classes which extend subclasses of a sealed class (indirect inheritors) can be placed anywhere, not necessarily in the same file.</source>
          <target state="translated">봉인 클래스 (간접 상속자)의 서브 클래스를 확장하는 클래스는 반드시 동일한 파일에있을 필요는 없습니다.</target>
        </trans-unit>
        <trans-unit id="b01c476864e020a6b3bdf6a577c404757a04f763" translate="yes" xml:space="preserve">
          <source>Note that code in initializer blocks effectively becomes part of the primary constructor. Delegation to the primary constructor happens as the first statement of a secondary constructor, so the code in all initializer blocks is executed before the secondary constructor body. Even if the class has no primary constructor, the delegation still happens implicitly, and the initializer blocks are still executed:</source>
          <target state="translated">이니셜 라이저 블록의 코드는 효과적으로 기본 생성자의 일부가됩니다. 기본 생성자에 대한 위임은 보조 생성자의 첫 번째 문으로 발생하므로 모든 초기화 블록의 코드는 보조 생성자 본문보다 먼저 실행됩니다. 클래스에 기본 생성자가없는 경우에도 위임은 여전히 ​​암시 적으로 발생하며 초기화 블록은 계속 실행됩니다.</target>
        </trans-unit>
        <trans-unit id="40662d03b687698fb7e2efe397dfb49179bd8a28" translate="yes" xml:space="preserve">
          <source>Note that coroutines are currently considered an &lt;strong&gt;experimental feature&lt;/strong&gt;, meaning that the Kotlin team is not committing to supporting the backwards compatibility of this feature after the final 1.1 release.</source>
          <target state="translated">코 루틴은 현재 &lt;strong&gt;실험적인 기능으로&lt;/strong&gt; 간주됩니다. 즉, Kotlin 팀은 최종 1.1 릴리스 이후이 기능의 이전 버전과의 호환성을 지원하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="abdd0e9fc4f6072582fff7f11143b17405eee64f" translate="yes" xml:space="preserve">
          <source>Note that despite the fact that the right-hand side of &lt;em&gt;as?&lt;/em&gt; is a non-null type &lt;code&gt;String&lt;/code&gt; the result of the cast is nullable.</source>
          <target state="translated">오른쪽의 오른쪽에도 불구하고 &lt;em&gt;? &lt;/em&gt;널이 아닌 유형의 &lt;code&gt;String&lt;/code&gt; 이며 캐스트 결과는 널 입력 가능합니다.</target>
        </trans-unit>
        <trans-unit id="984acf59abb99e6edf5501246d83e1bc7951b21e" translate="yes" xml:space="preserve">
          <source>Note that even if &lt;a href=&quot;is-marked-nullable#kotlin.reflect.KType%24isMarkedNullable&quot;&gt;isMarkedNullable&lt;/a&gt; is false, values of the type can still be &lt;code&gt;null&lt;/code&gt;. This may happen if it is a type of the type parameter with a nullable upper bound:</source>
          <target state="translated">&lt;a href=&quot;is-marked-nullable#kotlin.reflect.KType%24isMarkedNullable&quot;&gt;isMarkedNullable&lt;/a&gt; 이 false 인 경우에도 유형 값은 여전히 &lt;code&gt;null&lt;/code&gt; 일 수 있습니다 . 널 입력 가능한 상한이있는 유형 매개 변수의 유형 인 경우 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f9717ca7605239239d9b446b8d8baf568533a62a" translate="yes" xml:space="preserve">
          <source>Note that even if you initialize a variable with a reference to an extension function, the inferred function type will have no receiver (it will have an additional parameter accepting a receiver object). To have a function type with receiver instead, specify the type explicitly:</source>
          <target state="translated">확장 함수를 참조하여 변수를 초기화하더라도 유추 함수 유형에는 수신자가 없습니다 (수신자 객체를 허용하는 추가 매개 변수가 있음). 수신자 대신 함수 유형을 가지려면 유형을 명시 적으로 지정하십시오.</target>
        </trans-unit>
        <trans-unit id="e1859932d9a0b691a9fc9411f62e5506be7f8a66" translate="yes" xml:space="preserve">
          <source>Note that even though this is a read-only property due to declaring it with &lt;code&gt;val&lt;/code&gt; (in which case you may not provide a setter), its value can still change since it reads from a mutable property - you just can't assign to the property. Also, note that the property type is inferred from the return value of the getter.</source>
          <target state="translated">&lt;code&gt;val&lt;/code&gt; 로 선언하여 읽기 전용 속성이지만 (이 경우 setter를 제공하지 않을 수 있음) 변경 가능한 속성에서 읽으므로 값이 계속 변경 될 수 있습니다. 특성. 또한 속성 유형은 getter의 반환 값에서 유추됩니다.</target>
        </trans-unit>
        <trans-unit id="fd6bde9af50a41c1d5f97ea7b48311cc0527806c" translate="yes" xml:space="preserve">
          <source>Note that exceptions are somewhat discouraged in Kotlin except when interacting with Java code. Instead of throwing exceptions in your own code, consider using special return types like &lt;a href=&quot;https://arrow-kt.io/docs/datatypes/option/&quot;&gt;Option&lt;/a&gt; or &lt;a href=&quot;https://arrow-kt.io/docs/datatypes/either/&quot;&gt;Either&lt;/a&gt; from the &lt;a href=&quot;https://arrow-kt.io/&quot;&gt;Arrow library&lt;/a&gt;.</source>
          <target state="translated">Java 코드와 상호 작용할 때를 제외하고 Kotlin에서는 예외가 다소 권장되지 않습니다. 자신의 코드에서 예외를 throw하는 대신 &lt;a href=&quot;https://arrow-kt.io/&quot;&gt;Arrow 라이브러리&lt;/a&gt; 에서 &lt;a href=&quot;https://arrow-kt.io/docs/datatypes/option/&quot;&gt;Option&lt;/a&gt; 또는 &lt;a href=&quot;https://arrow-kt.io/docs/datatypes/either/&quot;&gt;Either&lt;/a&gt; 와 같은 특수 반환 유형을 사용 하십시오 .</target>
        </trans-unit>
        <trans-unit id="33e073ab069310793fb905b91ca3476dc4caf23c" translate="yes" xml:space="preserve">
          <source>Note that expected declarations are not restricted to interfaces and interface members. In this example, the expected class has a constructor and can be created directly from common code. You can apply the &lt;code&gt;expect&lt;/code&gt; modifier to other declarations as well, including top-level declarations and annotations:</source>
          <target state="translated">예상되는 선언은 인터페이스 및 인터페이스 멤버로 제한되지 않습니다. 이 예제에서 예상되는 클래스에는 생성자가 있으며 공통 코드에서 직접 작성할 수 있습니다. 최상위 레벨 선언 및 주석을 포함 하여 &lt;code&gt;expect&lt;/code&gt; 수정자를 다른 선언 에도 적용 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="45215a2c612cfc18ca0212e4816f62d8f14fe5b3" translate="yes" xml:space="preserve">
          <source>Note that extensions can be defined with a nullable receiver type. Such extensions can be called on an object variable even if its value is null, and can check for &lt;code&gt;this == null&lt;/code&gt; inside the body. This is what allows you to call toString() in Kotlin without checking for null: the check happens inside the extension function.</source>
          <target state="translated">확장은 널 입력 가능 리시버 유형으로 정의 될 수 있습니다. 이러한 확장은 값이 null 인 경우에도 객체 변수에서 호출 될 수 있으며 본문 내 &lt;code&gt;this == null&lt;/code&gt; 확인할 수 있습니다 . 이것은 null을 확인하지 않고 Kotlin에서 toString ()을 호출 할 수있게하는 것입니다. 확인은 확장 함수 내에서 발생합니다.</target>
        </trans-unit>
        <trans-unit id="519b88833afa591c638bec3f6bbeb8adf1aa4ab7" translate="yes" xml:space="preserve">
          <source>Note that for a top level &lt;strong&gt;extension&lt;/strong&gt; property, the delegate is the same for all extension receivers, so the actual &lt;a href=&quot;get-delegate#kotlin.reflect.KProperty1%24getDelegate%28kotlin.reflect.KProperty1.T%29%2Freceiver&quot;&gt;receiver&lt;/a&gt; instance passed in is not going to make any difference, it must only be a value of &lt;a href=&quot;index#T&quot;&gt;T&lt;/a&gt;.</source>
          <target state="translated">최상위 &lt;strong&gt;확장&lt;/strong&gt; 속성의 경우 델리게이트는 모든 확장 수신기에 대해 동일하므로 전달 된 실제 &lt;a href=&quot;get-delegate#kotlin.reflect.KProperty1%24getDelegate%28kotlin.reflect.KProperty1.T%29%2Freceiver&quot;&gt;수신기&lt;/a&gt; 인스턴스는 아무런 차이가 없으며 &lt;a href=&quot;index#T&quot;&gt;T&lt;/a&gt; 값만 있어야합니다 .</target>
        </trans-unit>
        <trans-unit id="c0ed19157d69e7092350d01754dff2c913099ef4" translate="yes" xml:space="preserve">
          <source>Note that for the IDE to correctly analyze the dependencies of the common sources, the common source sets need to have corresponding dependencies on the Kotlin metadata packages in addition to the platform-specific artifact dependencies of the platform-specific source sets. Usually, an artifact with a suffix &lt;code&gt;-common&lt;/code&gt; (as in &lt;code&gt;kotlin-stdlib-common&lt;/code&gt;) or &lt;code&gt;-metadata&lt;/code&gt; is required when using a published library (unless it is published with Gradle metadata, as described below).</source>
          <target state="translated">IDE가 공통 소스의 종속성을 올바르게 분석하려면 공통 소스 세트에는 플랫폼 별 소스 세트의 플랫폼 별 아티팩트 종속성 외에도 Kotlin 메타 데이터 패키지에 해당하는 종속성이 있어야합니다. 일반적으로 아티팩트 접미사 &lt;code&gt;-common&lt;/code&gt; (같이 &lt;code&gt;kotlin-stdlib-common&lt;/code&gt; ) 또는 &lt;code&gt;-metadata&lt;/code&gt; 가 게시 된 라이브러리를 사용하는 경우 (이 메타 데이터로 Gradle을 발행하지 않는 한 후술하는 바와 같이) 필요하다.</target>
        </trans-unit>
        <trans-unit id="ef903749bbe41c983b27f632974567077577929e" translate="yes" xml:space="preserve">
          <source>Note that for the purpose of this tutorial, we've done a line by line literal translation. Obviously we could write this in a more Kotlin idiomatic way.</source>
          <target state="translated">이 튜토리얼의 목적 상, 라인 단위 리터럴 변환을 수행했습니다. 분명히 우리는 이것을 더 Kotlin 관용적 방식으로 쓸 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2712e3816fc9fe0e5aede4e3fca67cc623f69a68" translate="yes" xml:space="preserve">
          <source>Note that if a class has got a primary constructor, it is no longer possible to create an instance of it without supplying any parameters (unless one of the secondary constructors is parameterless).</source>
          <target state="translated">클래스에 기본 생성자가 있으면 보조 생성자 중 하나가 매개 변수가없는 한 매개 변수를 제공하지 않고 더 이상 해당 인스턴스를 만들 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="3b1296c9d04a31b1fde17dffa086ef1b8acdb6c3" translate="yes" xml:space="preserve">
          <source>Note that if a library consumer defines variants that are missing in the library, they need to provide &lt;a href=&quot;https://developer.android.com/studio/build/dependencies#resolve_matching_errors&quot;&gt;matching fallbacks&lt;/a&gt;. For example, if a library does not have or does not publish a &lt;code&gt;staging&lt;/code&gt; build type, it will be necessary to provide a fallback for the consumers who have such a build type, specifying at least one of the build types that the library publishes:</source>
          <target state="translated">라이브러리 소비자가 라이브러리에서 누락 된 변형을 정의하는 경우 &lt;a href=&quot;https://developer.android.com/studio/build/dependencies#resolve_matching_errors&quot;&gt;일치하는 대체&lt;/a&gt; 를 제공해야 합니다 . 예를 들어, 라이브러리에 &lt;code&gt;staging&lt;/code&gt; 빌드 유형 이 없거나 공개되지 않은 경우 라이브러리가 공개하는 빌드 유형 중 하나 이상을 지정하여 해당 빌드 유형을 가진 소비자에게 폴백을 제공해야합니다.</target>
        </trans-unit>
        <trans-unit id="6c82c92fd55806c5e9d8d4f7e9db855fd43d5a7a" translate="yes" xml:space="preserve">
          <source>Note that if an inline function has no inlinable function parameters and no &lt;a href=&quot;#reified-type-parameters&quot;&gt;reified type parameters&lt;/a&gt;, the compiler will issue a warning, since inlining such functions is very unlikely to be beneficial (you can suppress the warning if you are sure the inlining is needed using the annotation &lt;code&gt;@Suppress(&quot;NOTHING_TO_INLINE&quot;)&lt;/code&gt;).</source>
          <target state="translated">인라인 함수에 inlinable 함수 매개 변수가없고 &lt;a href=&quot;#reified-type-parameters&quot;&gt;reified type 매개&lt;/a&gt; 변수가없는 경우 해당 함수를 인라인하는 것이 도움이되지 않기 때문에 컴파일러에서 경고를 발행합니다. 주석 &lt;code&gt;@Suppress(&quot;NOTHING_TO_INLINE&quot;)&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="ac1401dfe931b50e5500ce4b2ebac5d2aaf6e00c" translate="yes" xml:space="preserve">
          <source>Note that if an interface with &lt;code&gt;@JvmDefault&lt;/code&gt; methods is used as a &lt;a href=&quot;delegation&quot;&gt;delegate&lt;/a&gt;, the default method implementations are called even if the actual delegate type provides its own implementations.</source>
          <target state="translated">와 인터페이스하는 경우주의 &lt;code&gt;@JvmDefault&lt;/code&gt; 의 방법이 사용된다 &lt;a href=&quot;delegation&quot;&gt;위임&lt;/a&gt; , 기본 메소드 구현은 실제 대리자 형식은 자신의 구현을 제공하는 경우에도이라고합니다.</target>
        </trans-unit>
        <trans-unit id="5c363669dd6ed31274f54972ddb75e1fa04284aa" translate="yes" xml:space="preserve">
          <source>Note that if the &lt;code&gt;comparator&lt;/code&gt; considers any two keys of this map equal, only the value associated with the last of them gets into the resulting map.</source>
          <target state="translated">경우 생성하는 것으로 &lt;code&gt;comparator&lt;/code&gt; 동일이지도의 두 개의 키를 고려, 이들의 마지막과 관련된 값만 결과지도로 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="169507f367051a5b585a09223134ff4c0faab6be" translate="yes" xml:space="preserve">
          <source>Note that if the natural sorting order of keys considers any two keys of this map equal (this could happen if the equality of keys according to &lt;a href=&quot;../kotlin/-comparable/compare-to#kotlin.Comparable%24compareTo%28kotlin.Comparable.T%29&quot;&gt;Comparable.compareTo&lt;/a&gt; is inconsistent with the equality according to &lt;a href=&quot;../kotlin/-any/equals#kotlin.Any%24equals%28kotlin.Any%29&quot;&gt;Any.equals&lt;/a&gt;), only the value associated with the last of them gets into the resulting map.</source>
          <target state="translated">키의 자연 정렬 순서가이 맵의 두 키를 동일하게 간주하는 경우 ( &lt;a href=&quot;../kotlin/-comparable/compare-to#kotlin.Comparable%24compareTo%28kotlin.Comparable.T%29&quot;&gt;Comparable.compareTo&lt;/a&gt; 에 따른 키 의 동등성이 &lt;a href=&quot;../kotlin/-any/equals#kotlin.Any%24equals%28kotlin.Any%29&quot;&gt;Any.equals&lt;/a&gt; 에 따른 동등성과 일치하지 않는 경우 발생할 수 있음 ) 마지막 값과 연관된 값만 그들 중 하나는 결과지도에 들어갑니다.</target>
        </trans-unit>
        <trans-unit id="fdeead972a4f0dc85a954b4ef35d091c4109a874" translate="yes" xml:space="preserve">
          <source>Note that if the type of the result is known from the context, the type argument can be omitted as usual due to the type inference.</source>
          <target state="translated">결과의 유형이 컨텍스트에서 알려진 경우 유형 유추로 인해 유형 인수를 평소처럼 생략 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3df7a58b11ae9c7f677f019b7e29ec36da986c3e" translate="yes" xml:space="preserve">
          <source>Note that if this function fails, then partial copying may have taken place.</source>
          <target state="translated">이 기능이 실패하면 부분 복사가 수행되었을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e537ff121d99004384d6b13ae0784e74c296eabf" translate="yes" xml:space="preserve">
          <source>Note that if we have called &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-deferred/await.html&quot;&gt;await&lt;/a&gt; in &lt;code&gt;println&lt;/code&gt; and omitted &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-job/start.html&quot;&gt;start&lt;/a&gt; on individual coroutines, then we would have got the sequential behaviour as &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-deferred/await.html&quot;&gt;await&lt;/a&gt; starts the coroutine execution and waits for the execution to finish, which is not the intended use-case for laziness. The use-case for &lt;code&gt;async(start = CoroutineStart.LAZY)&lt;/code&gt; is a replacement for the standard &lt;code&gt;lazy&lt;/code&gt; function in cases when computation of the value involves suspending functions.</source>
          <target state="translated">&lt;code&gt;println&lt;/code&gt; 에서 &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-deferred/await.html&quot;&gt;await&lt;/a&gt; 를 호출 하고 개별 코 루틴에서 &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-job/start.html&quot;&gt;start&lt;/a&gt; 를 생략 하면 &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-deferred/await.html&quot;&gt;await&lt;/a&gt; 가 코 루틴 실행을 시작하고 실행이 완료 될 때까지 기다리는 것처럼 순차적 인 동작을하게 됩니다. 게으름에 대한 의도 된 사용 사례는 아닙니다. &lt;code&gt;async(start = CoroutineStart.LAZY)&lt;/code&gt; 의 사용 사례는 값 계산에 함수 중단이 포함되는 경우 표준 &lt;code&gt;lazy&lt;/code&gt; 함수를 대체 합니다.</target>
        </trans-unit>
        <trans-unit id="1e82a73f61c52b17d7e3c65e8e99e11241b677f8" translate="yes" xml:space="preserve">
          <source>Note that if you are using multi-project build, you should apply plugin to the main project that is an entry point to your application.</source>
          <target state="translated">다중 프로젝트 빌드를 사용하는 경우 애플리케이션의 진입 점 인 기본 프로젝트에 플러그인을 적용해야합니다.</target>
        </trans-unit>
        <trans-unit id="e39d91f028c6c4bc3b768c071107ff617a7a7685" translate="yes" xml:space="preserve">
          <source>Note that if you use the project template generated by the &lt;a href=&quot;http://start.spring.io/#!language=kotlin&quot;&gt;start.spring.io&lt;/a&gt; service, the &lt;code&gt;kotlin-spring&lt;/code&gt; plugin will be enabled by default.</source>
          <target state="translated">&lt;a href=&quot;http://start.spring.io/#!language=kotlin&quot;&gt;start.spring.io&lt;/a&gt; 서비스에서 생성 한 프로젝트 템플릿을 사용하면 &lt;code&gt;kotlin-spring&lt;/code&gt; 플러그인이 기본적으로 활성화됩니다.</target>
        </trans-unit>
        <trans-unit id="261071b80b92f5599125de0c5212f010938aeec4" translate="yes" xml:space="preserve">
          <source>Note that if your function has parameters, its name will be mangled, so the mangled name should be used in the keep directive.</source>
          <target state="translated">함수에 매개 변수가 있으면 해당 이름이 맹 글링되므로 맹 글링 된 이름을 keep 지시문에 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="4c99e0a3c39d8997895800da0e15222c8aa2ad3b" translate="yes" xml:space="preserve">
          <source>Note that in Kotlin/JS Float range is wider than &quot;single format&quot; bit layout can represent, so some Float values may overflow, underflow or loose their accuracy after conversion to bits and back.</source>
          <target state="translated">Kotlin / JS Float 범위는 &quot;단일 형식&quot;비트 레이아웃이 표시 할 수있는 것보다 넓으므로 일부 Float 값은 비트로 또는 그 반대로 변환 한 후 오버플로, 언더 플로 또는 정확도가 떨어질 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="88d47ad6334c013775aba391a38df6074a6dc3f4" translate="yes" xml:space="preserve">
          <source>Note that in competitive programming it is customary to give variables shorter names than it is typical in industrial programming practice, since the code is to be written just once and not supported thereafter. However, these names are usually still mnemonic &amp;mdash; &lt;code&gt;a&lt;/code&gt; for arrays, &lt;code&gt;i&lt;/code&gt;, &lt;code&gt;j&lt;/code&gt;, etc for indices, &lt;code&gt;r&lt;/code&gt;, and &lt;code&gt;c&lt;/code&gt; for row and column numbers in tables, &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; for coordinates, etc. It is easier to keep the same names for input data as it is given in the problem statement. However, more complex problems require more code which leads to using longer self-explanatory variable and function names.</source>
          <target state="translated">경쟁 프로그래밍에서는 코드가 한 번만 작성되고 이후에 지원되지 않기 때문에 산업 프로그래밍 실습에서 일반적인 것보다 짧은 이름을 변수에 제공하는 것이 일반적입니다. 그러나, 이러한 이름은 여전히 보통 니모닉이다 - 어레이가 &lt;code&gt;i&lt;/code&gt; , &lt;code&gt;j&lt;/code&gt; 는 등이 지표에 대한 &lt;code&gt;r&lt;/code&gt; 및 &lt;code&gt;c&lt;/code&gt; 테이블의 행 및 열 번호에 대한 &lt;code&gt;x&lt;/code&gt; 및 &lt;code&gt;y&lt;/code&gt; 등의 좌표계, 동일한 이름을 유지하기 쉽다 문제점 설명에 제공된대로 입력 데이터. 그러나보다 복잡한 문제에는 더 많은 코드가 필요하므로 더 긴 설명이 필요없는 변수 및 함수 이름이 사용됩니다. &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="24fc67264648157b787a9e1d8a1aee247379a870" translate="yes" xml:space="preserve">
          <source>Note that in many cases there's no need to use custom interoperability library creation mechanisms described below, as for APIs available on the platform standardized bindings called &lt;a href=&quot;platform_libs&quot;&gt;platform libraries&lt;/a&gt; could be used. For example, POSIX on Linux/macOS platforms, Win32 on Windows platform, or Apple frameworks on macOS/iOS are available this way.</source>
          <target state="translated">&lt;a href=&quot;platform_libs&quot;&gt;플랫폼 라이브러리&lt;/a&gt; 라고하는 플랫폼 표준화 된 바인딩에서 사용 가능한 API를 사용할 수 있기 때문에 많은 경우 아래에 설명 된 사용자 지정 상호 운용성 라이브러리 생성 메커니즘을 사용할 필요가 없습니다 . 예를 들어 Linux / macOS 플랫폼의 POSIX, Windows 플랫폼의 Win32 또는 macOS / iOS의 Apple 프레임 워크를이 방법으로 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4c3031faf8b33ed043c9d69fe73ae60488938a50" translate="yes" xml:space="preserve">
          <source>Note that in most cases using &lt;a href=&quot;#string-templates&quot;&gt;string templates&lt;/a&gt; or raw strings is preferable to string concatenation.</source>
          <target state="translated">대부분의 경우 문자열 연결보다 &lt;a href=&quot;#string-templates&quot;&gt;문자열 템플릿&lt;/a&gt; 또는 원시 문자열을 사용하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="6addd273834de7f83ab126536995cca9dd6643b2" translate="yes" xml:space="preserve">
          <source>Note that incremental annotation processing requires &lt;a href=&quot;using-gradle#incremental-compilation&quot;&gt;incremental compilation&lt;/a&gt; to be enabled as well.</source>
          <target state="translated">증분 주석 처리에는 &lt;a href=&quot;using-gradle#incremental-compilation&quot;&gt;증분 컴파일&lt;/a&gt; 도 활성화되어야합니다.</target>
        </trans-unit>
        <trans-unit id="6b7588c134bcd5e8f4a5da82d120b4047c151b76" translate="yes" xml:space="preserve">
          <source>Note that infix functions always require both the receiver and the parameter to be specified. When you're calling a method on the current receiver using the infix notation, you need to use &lt;code&gt;this&lt;/code&gt; explicitly; unlike regular method calls, it cannot be omitted. This is required to ensure unambiguous parsing.</source>
          <target state="translated">삽입 기능을 사용하려면 항상 수신자와 매개 변수를 모두 지정해야합니다. 접두사 표기법을 사용하여 현재 수신자에서 메소드를 호출 할 때 &lt;code&gt;this&lt;/code&gt; 명시 적으로 사용해야 합니다 . 일반 메소드 호출과 달리 생략 할 수 없습니다. 모호하지 않은 구문 분석을 보장하기 위해 필요합니다.</target>
        </trans-unit>
        <trans-unit id="ad1d05af6c1aa655f7d3f68b893652c8d8011b1f" translate="yes" xml:space="preserve">
          <source>Note that instead of declaring lambdas in xml like in the following example, you can can bind actions directly in the code:</source>
          <target state="translated">다음 예제와 같이 xml에서 람다를 선언하는 대신 코드에서 직접 액션을 바인딩 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2de64757cb014df0ce60c045d22eb608329bdbb9" translate="yes" xml:space="preserve">
          <source>Note that it is not recommended to call either &lt;a href=&quot;../kotlin.coroutines.experimental/-continuation/resume&quot;&gt;Continuation.resume&lt;/a&gt; nor &lt;a href=&quot;../kotlin.coroutines.experimental/-continuation/resume-with-exception&quot;&gt;Continuation.resumeWithException&lt;/a&gt; functions synchronously in the same stackframe where suspension function is run. Use &lt;a href=&quot;../kotlin.coroutines.experimental/suspend-coroutine&quot;&gt;suspendCoroutine&lt;/a&gt; as a safer way to obtain current continuation instance.</source>
          <target state="translated">서스펜션 함수가 실행되는 동일한 스택 프레임에서 &lt;a href=&quot;../kotlin.coroutines.experimental/-continuation/resume&quot;&gt;Continuation.resume&lt;/a&gt; 및 &lt;a href=&quot;../kotlin.coroutines.experimental/-continuation/resume-with-exception&quot;&gt;Continuation.resumeWithException&lt;/a&gt; 함수를 동 기적 으로 호출하는 것은 권장되지 않습니다 . 현재 연속 인스턴스를 얻는보다 안전한 방법으로 &lt;a href=&quot;../kotlin.coroutines.experimental/suspend-coroutine&quot;&gt;suspendCoroutine&lt;/a&gt; 을 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="9d6ffb0207257e6147b3a7dc3f05f4b2eb90ba26" translate="yes" xml:space="preserve">
          <source>Note that it is not recommended to call either &lt;a href=&quot;../kotlin.coroutines/resume&quot;&gt;Continuation.resume&lt;/a&gt; nor &lt;a href=&quot;../kotlin.coroutines/resume-with-exception&quot;&gt;Continuation.resumeWithException&lt;/a&gt; functions synchronously in the same stackframe where suspension function is run. Use &lt;a href=&quot;../kotlin.coroutines/suspend-coroutine&quot;&gt;suspendCoroutine&lt;/a&gt; as a safer way to obtain current continuation instance.</source>
          <target state="translated">서스펜션 함수가 실행되는 동일한 스택 프레임에서 &lt;a href=&quot;../kotlin.coroutines/resume&quot;&gt;Continuation.resume&lt;/a&gt; 및 &lt;a href=&quot;../kotlin.coroutines/resume-with-exception&quot;&gt;Continuation.resumeWithException&lt;/a&gt; 함수를 동 기적 으로 호출하는 것은 권장되지 않습니다 . 현재 연속 인스턴스를 얻는보다 안전한 방법으로 &lt;a href=&quot;../kotlin.coroutines/suspend-coroutine&quot;&gt;suspendCoroutine&lt;/a&gt; 을 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="ef6ff08c8afdc4c88bfce216a4201b44bef8d337" translate="yes" xml:space="preserve">
          <source>Note that it's still possible to call the members of the outer receiver, but to do that you have to specify this receiver explicitly:</source>
          <target state="translated">외부 수신자의 멤버를 호출 할 수는 있지만이 수신자를 명시 적으로 지정해야합니다.</target>
        </trans-unit>
        <trans-unit id="1a8a5665bc44d5cdbf2531c3d2423dcbe7d87681" translate="yes" xml:space="preserve">
          <source>Note that parameters of the primary constructor can be used in the initializer blocks. They can also be used in property initializers declared in the class body:</source>
          <target state="translated">기본 생성자의 매개 변수는 이니셜 라이저 블록에서 사용할 수 있습니다. 클래스 본문에 선언 된 속성 이니셜 라이저에서도 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c0c4053dbcf27c46808a2ab0e8b3303b9f7cbf9a" translate="yes" xml:space="preserve">
          <source>Note that set operations are supported by &lt;code&gt;List&lt;/code&gt; as well. However, the result of set operations on lists is still a &lt;code&gt;Set&lt;/code&gt;, so all the duplicate elements are removed.</source>
          <target state="translated">Set 작업은 &lt;code&gt;List&lt;/code&gt; 에서도 지원됩니다 . 그러나 목록에 대한 set 작업의 결과는 여전히 &lt;code&gt;Set&lt;/code&gt; 이므로 모든 중복 요소가 제거됩니다.</target>
        </trans-unit>
        <trans-unit id="ecba1bd96686456eab8e7e25340f9f56c1cd293b" translate="yes" xml:space="preserve">
          <source>Note that since Kotlin 1.1 you can declare a delegated property inside a function or code block, it shouldn't necessarily be a member of a class. Below you can find &lt;a href=&quot;delegated-properties#local-delegated-properties-since-11&quot;&gt;the example&lt;/a&gt;.</source>
          <target state="translated">Kotlin 1.1 이후로 함수 또는 코드 블록 내에 위임 속성을 선언 할 수 있으므로 반드시 클래스의 멤버 일 필요는 없습니다. 아래 &lt;a href=&quot;delegated-properties#local-delegated-properties-since-11&quot;&gt;에서 예제를&lt;/a&gt; 찾을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="8f27fe847dccbaf44c3e83c0485bdf6be308f0d6" translate="yes" xml:space="preserve">
          <source>Note that smart casts do not work when the compiler cannot guarantee that the variable cannot change between the check and the usage. More specifically, smart casts are applicable according to the following rules:</source>
          <target state="translated">컴파일러가 변수가 확인과 사용간에 변경 될 수 있음을 보증 할 수없는 경우 스마트 캐스트가 작동하지 않습니다. 보다 구체적으로, 스마트 캐스트는 다음 규칙에 따라 적용 가능합니다.</target>
        </trans-unit>
        <trans-unit id="1c295c01c9e6a32796148120ae2cf2ae77c47235" translate="yes" xml:space="preserve">
          <source>Note that some Java visibilities such as package-private and protected (which also gives access to items from the same package) cannot be represented in Kotlin, so there's no &lt;a href=&quot;index#kotlin.reflect.KVisibility&quot;&gt;KVisibility&lt;/a&gt; value corresponding to them.</source>
          <target state="translated">Kotlin에서는 package-private 및 protected (같은 패키지의 항목에 대한 액세스도 제공)와 같은 일부 Java 가시성을 Kotlin에 표시 할 수 없으므로 이에 대응하는 &lt;a href=&quot;index#kotlin.reflect.KVisibility&quot;&gt;KVisibility&lt;/a&gt; 값 이 없습니다 .</target>
        </trans-unit>
        <trans-unit id="a13526efa441f113eff7267561f09b5212747a9d" translate="yes" xml:space="preserve">
          <source>Note that some inline functions may call the lambdas passed to them as parameters not directly from the function body, but from another execution context, such as a local object or a nested function. In such cases, non-local control flow is also not allowed in the lambdas. To indicate that, the lambda parameter needs to be marked with the &lt;code&gt;crossinline&lt;/code&gt; modifier:</source>
          <target state="translated">일부 인라인 함수는 함수 본문에서 직접가 아니라 로컬 객체 또는 중첩 함수와 같은 다른 실행 컨텍스트에서 매개 변수로 전달 된 람다를 호출 할 수 있습니다. 이러한 경우 람다에서는 로컬이 아닌 제어 흐름도 허용되지 않습니다. 람다 매개 변수는 &lt;code&gt;crossinline&lt;/code&gt; 수정 자로 표시해야합니다 .</target>
        </trans-unit>
        <trans-unit id="c7e376b19704536e280b87471b9d2f1935ff22e7" translate="yes" xml:space="preserve">
          <source>Note that some of the Kotlin/Native targets require an &lt;a href=&quot;#using-kotlinnative-targets&quot;&gt;appropriate host machine&lt;/a&gt; to build on.</source>
          <target state="translated">일부 Kotlin / Native 대상에는 빌드 할 &lt;a href=&quot;#using-kotlinnative-targets&quot;&gt;적절한 호스트 시스템&lt;/a&gt; 이 필요합니다 .</target>
        </trans-unit>
        <trans-unit id="36013172d7bed76a773c2a3e7f523422dd3a224f" translate="yes" xml:space="preserve">
          <source>Note that sometimes channels may produce executions that look unfair due to the nature of the executor that is being used. See &lt;a href=&quot;https://github.com/Kotlin/kotlinx.coroutines/issues/111&quot;&gt;this issue&lt;/a&gt; for details.</source>
          <target state="translated">때때로 사용중인 실행 프로그램의 특성으로 인해 채널이 불공정하게 보이는 실행을 생성 할 수 있습니다. 자세한 내용은 &lt;a href=&quot;https://github.com/Kotlin/kotlinx.coroutines/issues/111&quot;&gt;이 문제&lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="1c3b5c2f9f97ede3b692c00928df156ad477b585" translate="yes" xml:space="preserve">
          <source>Note that the &lt;a href=&quot;../-string/index#kotlin.String&quot;&gt;String&lt;/a&gt; implementation of this interface in Kotlin/JS has unspecified behavior if the &lt;a href=&quot;get#kotlin.CharSequence%24get%28kotlin.Int%29%2Findex&quot;&gt;index&lt;/a&gt; is out of its bounds.</source>
          <target state="translated">Kotlin / JS에서이 인터페이스 의 &lt;a href=&quot;../-string/index#kotlin.String&quot;&gt;문자열&lt;/a&gt; 구현은 &lt;a href=&quot;get#kotlin.CharSequence%24get%28kotlin.Int%29%2Findex&quot;&gt;색인&lt;/a&gt; 이 범위를 벗어난 경우 지정되지 않은 동작을 합니다.</target>
        </trans-unit>
        <trans-unit id="656f0ee95d7b273c3b267aed0322b60e181f19cb" translate="yes" xml:space="preserve">
          <source>Note that the &lt;a href=&quot;../../kotlin/-string/index#kotlin.String&quot;&gt;String&lt;/a&gt; implementation of this interface in Kotlin/JS has unspecified behavior if the &lt;a href=&quot;../../kotlin/-char-sequence/get#kotlin.CharSequence%24get%28kotlin.Int%29%2Findex&quot;&gt;index&lt;/a&gt; is out of its bounds.</source>
          <target state="translated">Kotlin / JS에서이 인터페이스 의 &lt;a href=&quot;../../kotlin/-string/index#kotlin.String&quot;&gt;문자열&lt;/a&gt; 구현은 &lt;a href=&quot;../../kotlin/-char-sequence/get#kotlin.CharSequence%24get%28kotlin.Int%29%2Findex&quot;&gt;색인&lt;/a&gt; 이 범위를 벗어난 경우 지정되지 않은 동작을 합니다.</target>
        </trans-unit>
        <trans-unit id="86d97d17b217564ee55541f4e63de5ad16ee2c54" translate="yes" xml:space="preserve">
          <source>Note that the &lt;code&gt;@DslMarker&lt;/code&gt; annotation is available only since Kotlin 1.1.</source>
          <target state="translated">있습니다 &lt;code&gt;@DslMarker&lt;/code&gt; 의 주석 만 코 틀린 1.1부터 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e7b3f809dbbb0b87e0e79d9712336f436e1ff493" translate="yes" xml:space="preserve">
          <source>Note that the &lt;code&gt;componentN()&lt;/code&gt; functions need to be marked with the &lt;code&gt;operator&lt;/code&gt; keyword to allow using them in a destructuring declaration.</source>
          <target state="translated">&lt;code&gt;componentN()&lt;/code&gt; 선언 (destructuring declaration)에서 사용 하려면 componentN () 함수에 &lt;code&gt;operator&lt;/code&gt; 키워드를 표시해야합니다 .</target>
        </trans-unit>
        <trans-unit id="d942ddfab9f982a7bff6988ad53e1b8f734657f3" translate="yes" xml:space="preserve">
          <source>Note that the &lt;code&gt;kotlin-multiplaform&lt;/code&gt; plugin doesn't create any production binaries by default. The only binary available by default is a debug executable allowing one to run tests from the &lt;code&gt;test&lt;/code&gt; compilation.</source>
          <target state="translated">있습니다 &lt;code&gt;kotlin-multiplaform&lt;/code&gt; 플러그인은 기본적으로 모든 생산 바이너리를 만들지 않습니다. 기본적으로 사용 가능한 바이너리는 &lt;code&gt;test&lt;/code&gt; 컴파일 에서 테스트를 실행할 수있는 디버그 실행 파일 입니다.</target>
        </trans-unit>
        <trans-unit id="c656240136213ce9805ea2877dde6b34a8442c1b" translate="yes" xml:space="preserve">
          <source>Note that the &lt;code&gt;provideDelegate&lt;/code&gt; method affects only the creation of the auxiliary property and doesn't affect the code generated for getter or setter.</source>
          <target state="translated">있습니다 &lt;code&gt;provideDelegate&lt;/code&gt; 의 방법은 보조 건물의 생성에 영향을 미치고 게터 또는 세터에 대해 생성 된 코드에 영향을주지 않습니다.</target>
        </trans-unit>
        <trans-unit id="eaabc3c1b973d9e58d5da5690136b6ca64e5f983" translate="yes" xml:space="preserve">
          <source>Note that the &lt;code&gt;rem&lt;/code&gt; operator is supported since Kotlin 1.1. Kotlin 1.0 uses the &lt;code&gt;mod&lt;/code&gt; operator, which is deprecated in Kotlin 1.1.</source>
          <target state="translated">있습니다 &lt;code&gt;rem&lt;/code&gt; 운영자가 코 틀린 1.1부터 지원됩니다. Kotlin 1.0은 &lt;code&gt;mod&lt;/code&gt; 연산자를 사용하며 이는 Kotlin 1.1에서 더 이상 사용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="72e01dcbd71cc06e15070eae50092b4b7e9eed02" translate="yes" xml:space="preserve">
          <source>Note that the &lt;code&gt;to&lt;/code&gt; notation creates a short-living &lt;code&gt;Pair&lt;/code&gt; object, so it's recommended that you use it only if performance isn't critical. To avoid excessive memory usage, use alternative ways. For example, you can create a mutable map and populate it using the write operations. The &lt;a href=&quot;scope-functions#apply&quot;&gt;&lt;code&gt;apply()&lt;/code&gt;&lt;/a&gt; function can help to keep the initialization fluent here.</source>
          <target state="translated">참고는 것을 &lt;code&gt;to&lt;/code&gt; 표기 짧은 - 생활 생성 &lt;code&gt;Pair&lt;/code&gt; 가 성능이 중요하지 않은 경우에만 사용하는 것이 좋습니다 그래서 개체를. 과도한 메모리 사용을 피하려면 다른 방법을 사용하십시오. 예를 들어, 변경 가능한 맵을 작성하고 쓰기 조작을 사용하여 채울 수 있습니다. &lt;a href=&quot;scope-functions#apply&quot;&gt; &lt;code&gt;apply()&lt;/code&gt; &lt;/a&gt; 함수는 여기에 초기화 유창하게 유지하는 데 도움이 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ae0cdfd1c642695da1e12ec7f632f89942b6add0" translate="yes" xml:space="preserve">
          <source>Note that the char sequence passed to the &lt;a href=&quot;chunked#kotlin.text%24chunked%28kotlin.CharSequence%2C+kotlin.Int%2C+kotlin.Function1%28%28kotlin.CharSequence%2C+kotlin.text.chunked.R%29%29%29%2Ftransform&quot;&gt;transform&lt;/a&gt; function is ephemeral and is valid only inside that function. You should not store it or allow it to escape in some way, unless you made a snapshot of it. The last char sequence may have less characters than the given &lt;a href=&quot;chunked#kotlin.text%24chunked%28kotlin.CharSequence%2C+kotlin.Int%2C+kotlin.Function1%28%28kotlin.CharSequence%2C+kotlin.text.chunked.R%29%29%29%2Fsize&quot;&gt;size&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;chunked#kotlin.text%24chunked%28kotlin.CharSequence%2C+kotlin.Int%2C+kotlin.Function1%28%28kotlin.CharSequence%2C+kotlin.text.chunked.R%29%29%29%2Ftransform&quot;&gt;변환&lt;/a&gt; 함수에 전달 된 문자 시퀀스 는 임시적이며 해당 함수 내에서만 유효합니다. 스냅 샷을 만들지 않는 한 보관하거나 어떤 식 으로든 탈출해서는 안됩니다. 마지막 문자 순서는 주어진 &lt;a href=&quot;chunked#kotlin.text%24chunked%28kotlin.CharSequence%2C+kotlin.Int%2C+kotlin.Function1%28%28kotlin.CharSequence%2C+kotlin.text.chunked.R%29%29%29%2Fsize&quot;&gt;크기&lt;/a&gt; 보다 적은 문자를 가질 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="691b0c57806763a4b2bdecce9c41e605803c5ebe" translate="yes" xml:space="preserve">
          <source>Note that the char sequence passed to the &lt;a href=&quot;chunked-sequence#kotlin.text%24chunkedSequence%28kotlin.CharSequence%2C+kotlin.Int%2C+kotlin.Function1%28%28kotlin.CharSequence%2C+kotlin.text.chunkedSequence.R%29%29%29%2Ftransform&quot;&gt;transform&lt;/a&gt; function is ephemeral and is valid only inside that function. You should not store it or allow it to escape in some way, unless you made a snapshot of it. The last char sequence may have less characters than the given &lt;a href=&quot;chunked-sequence#kotlin.text%24chunkedSequence%28kotlin.CharSequence%2C+kotlin.Int%2C+kotlin.Function1%28%28kotlin.CharSequence%2C+kotlin.text.chunkedSequence.R%29%29%29%2Fsize&quot;&gt;size&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;chunked-sequence#kotlin.text%24chunkedSequence%28kotlin.CharSequence%2C+kotlin.Int%2C+kotlin.Function1%28%28kotlin.CharSequence%2C+kotlin.text.chunkedSequence.R%29%29%29%2Ftransform&quot;&gt;변환&lt;/a&gt; 함수에 전달 된 문자 시퀀스 는 임시적이며 해당 함수 내에서만 유효합니다. 스냅 샷을 만들지 않는 한 보관하거나 어떤 식 으로든 탈출해서는 안됩니다. 마지막 문자 순서는 주어진 &lt;a href=&quot;chunked-sequence#kotlin.text%24chunkedSequence%28kotlin.CharSequence%2C+kotlin.Int%2C+kotlin.Function1%28%28kotlin.CharSequence%2C+kotlin.text.chunkedSequence.R%29%29%29%2Fsize&quot;&gt;크기&lt;/a&gt; 보다 적은 문자를 가질 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="1754418c79853b8c6ec574fcc023dbf40a7d737e" translate="yes" xml:space="preserve">
          <source>Note that the char sequence passed to the &lt;a href=&quot;windowed#kotlin.text%24windowed%28kotlin.CharSequence%2C+kotlin.Int%2C+kotlin.Int%2C+kotlin.Boolean%2C+kotlin.Function1%28%28kotlin.CharSequence%2C+kotlin.text.windowed.R%29%29%29%2Ftransform&quot;&gt;transform&lt;/a&gt; function is ephemeral and is valid only inside that function. You should not store it or allow it to escape in some way, unless you made a snapshot of it. Several last char sequences may have less characters than the given &lt;a href=&quot;windowed#kotlin.text%24windowed%28kotlin.CharSequence%2C+kotlin.Int%2C+kotlin.Int%2C+kotlin.Boolean%2C+kotlin.Function1%28%28kotlin.CharSequence%2C+kotlin.text.windowed.R%29%29%29%2Fsize&quot;&gt;size&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;windowed#kotlin.text%24windowed%28kotlin.CharSequence%2C+kotlin.Int%2C+kotlin.Int%2C+kotlin.Boolean%2C+kotlin.Function1%28%28kotlin.CharSequence%2C+kotlin.text.windowed.R%29%29%29%2Ftransform&quot;&gt;변환&lt;/a&gt; 함수에 전달 된 문자 시퀀스 는 임시적이며 해당 함수 내에서만 유효합니다. 스냅 샷을 만들지 않는 한 보관하거나 어떤 식 으로든 탈출해서는 안됩니다. 여러 마지막 문자 시퀀스는 주어진 &lt;a href=&quot;windowed#kotlin.text%24windowed%28kotlin.CharSequence%2C+kotlin.Int%2C+kotlin.Int%2C+kotlin.Boolean%2C+kotlin.Function1%28%28kotlin.CharSequence%2C+kotlin.text.windowed.R%29%29%29%2Fsize&quot;&gt;크기&lt;/a&gt; 보다 적은 문자를 가질 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="266d21f640d721c4dd41a4ded8abb4f2b56ec11c" translate="yes" xml:space="preserve">
          <source>Note that the char sequence passed to the &lt;a href=&quot;windowed-sequence#kotlin.text%24windowedSequence%28kotlin.CharSequence%2C+kotlin.Int%2C+kotlin.Int%2C+kotlin.Boolean%2C+kotlin.Function1%28%28kotlin.CharSequence%2C+kotlin.text.windowedSequence.R%29%29%29%2Ftransform&quot;&gt;transform&lt;/a&gt; function is ephemeral and is valid only inside that function. You should not store it or allow it to escape in some way, unless you made a snapshot of it. Several last char sequences may have less characters than the given &lt;a href=&quot;windowed-sequence#kotlin.text%24windowedSequence%28kotlin.CharSequence%2C+kotlin.Int%2C+kotlin.Int%2C+kotlin.Boolean%2C+kotlin.Function1%28%28kotlin.CharSequence%2C+kotlin.text.windowedSequence.R%29%29%29%2Fsize&quot;&gt;size&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;windowed-sequence#kotlin.text%24windowedSequence%28kotlin.CharSequence%2C+kotlin.Int%2C+kotlin.Int%2C+kotlin.Boolean%2C+kotlin.Function1%28%28kotlin.CharSequence%2C+kotlin.text.windowedSequence.R%29%29%29%2Ftransform&quot;&gt;변환&lt;/a&gt; 함수에 전달 된 문자 시퀀스 는 임시적이며 해당 함수 내에서만 유효합니다. 스냅 샷을 만들지 않는 한 보관하거나 어떤 식 으로든 탈출해서는 안됩니다. 여러 마지막 문자 시퀀스는 주어진 &lt;a href=&quot;windowed-sequence#kotlin.text%24windowedSequence%28kotlin.CharSequence%2C+kotlin.Int%2C+kotlin.Int%2C+kotlin.Boolean%2C+kotlin.Function1%28%28kotlin.CharSequence%2C+kotlin.text.windowedSequence.R%29%29%29%2Fsize&quot;&gt;크기&lt;/a&gt; 보다 적은 문자를 가질 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="eeca19ffbd81bf7218d5ce25611e87d001f58db2" translate="yes" xml:space="preserve">
          <source>Note that the compiler only uses the properties defined inside the primary constructor for the automatically generated functions. To exclude a property from the generated implementations, declare it inside the class body:</source>
          <target state="translated">컴파일러는 자동 생성 된 함수에 기본 생성자 내에 정의 된 속성 만 사용합니다. 생성 된 구현에서 특성을 제외하려면 클래스 본문 내에 특성을 선언하십시오.</target>
        </trans-unit>
        <trans-unit id="29a5989520a2bf8fd601f2d782fa7b5f4d18221d" translate="yes" xml:space="preserve">
          <source>Note that the content of &lt;code&gt;platform.posix&lt;/code&gt; is NOT identical on different platforms, in the same way as different &lt;code&gt;POSIX&lt;/code&gt; implementations are a little different.</source>
          <target state="translated">다른 &lt;code&gt;POSIX&lt;/code&gt; 구현이 약간 다른 것과 마찬가지로 &lt;code&gt;platform.posix&lt;/code&gt; 의 내용은 다른 플랫폼에서 동일하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="6e0ba2d2cb4d8f4a9dbc1b85a017969941095acd" translate="yes" xml:space="preserve">
          <source>Note that the databinding expression language uses the same syntax for referring to properties as Kotlin: &lt;code&gt;data.imageUrl&lt;/code&gt;. In Kotlin you can write &lt;code&gt;v.prop&lt;/code&gt; instead of &lt;code&gt;v.getProp()&lt;/code&gt; even if &lt;code&gt;getProp()&lt;/code&gt; is a Java method. Similarly, instead of calling a setter directly, you may use an assignment:</source>
          <target state="translated">참고 데이터 바인딩 표현 언어는 코 틀린와 같은 속성을 참조 동일한 구문을 사용 : &lt;code&gt;data.imageUrl&lt;/code&gt; . Kotlin에서는 &lt;code&gt;getProp()&lt;/code&gt; 가 Java 메소드 인 경우에도 &lt;code&gt;v.getProp()&lt;/code&gt; 대신 &lt;code&gt;v.prop&lt;/code&gt; 를 작성할 수 있습니다 . 마찬가지로 setter를 직접 호출하는 대신 할당을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e38cb3723f44256fc4af27d394f0da73badd7310" translate="yes" xml:space="preserve">
          <source>Note that the first build isn't incremental in any case.</source>
          <target state="translated">첫 번째 빌드는 어떤 경우에도 증분되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="3539b1a59eaf5408904eb51b677999543b8a5f8e" translate="yes" xml:space="preserve">
          <source>Note that the list passed to the &lt;a href=&quot;chunked#kotlin.collections%24chunked%28kotlin.collections.Iterable%28%28kotlin.collections.chunked.T%29%29%2C+kotlin.Int%2C+kotlin.Function1%28%28kotlin.collections.List%28%28kotlin.collections.chunked.T%29%29%2C+kotlin.collections.chunked.R%29%29%29%2Ftransform&quot;&gt;transform&lt;/a&gt; function is ephemeral and is valid only inside that function. You should not store it or allow it to escape in some way, unless you made a snapshot of it. The last list may have less elements than the given &lt;a href=&quot;chunked#kotlin.collections%24chunked%28kotlin.collections.Iterable%28%28kotlin.collections.chunked.T%29%29%2C+kotlin.Int%2C+kotlin.Function1%28%28kotlin.collections.List%28%28kotlin.collections.chunked.T%29%29%2C+kotlin.collections.chunked.R%29%29%29%2Fsize&quot;&gt;size&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;chunked#kotlin.collections%24chunked%28kotlin.collections.Iterable%28%28kotlin.collections.chunked.T%29%29%2C+kotlin.Int%2C+kotlin.Function1%28%28kotlin.collections.List%28%28kotlin.collections.chunked.T%29%29%2C+kotlin.collections.chunked.R%29%29%29%2Ftransform&quot;&gt;변환&lt;/a&gt; 함수에 전달 된 목록 은 일시적이며 해당 함수 내에서만 유효합니다. 스냅 샷을 만들지 않는 한 보관하거나 어떤 식 으로든 탈출해서는 안됩니다. 마지막 목록은 주어진 &lt;a href=&quot;chunked#kotlin.collections%24chunked%28kotlin.collections.Iterable%28%28kotlin.collections.chunked.T%29%29%2C+kotlin.Int%2C+kotlin.Function1%28%28kotlin.collections.List%28%28kotlin.collections.chunked.T%29%29%2C+kotlin.collections.chunked.R%29%29%29%2Fsize&quot;&gt;크기&lt;/a&gt; 보다 적은 요소를 가질 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="7d6ec3f60ea3d3f0e1450f4fd127d92b3dabc464" translate="yes" xml:space="preserve">
          <source>Note that the list passed to the &lt;a href=&quot;chunked#kotlin.sequences%24chunked%28kotlin.sequences.Sequence%28%28kotlin.sequences.chunked.T%29%29%2C+kotlin.Int%2C+kotlin.Function1%28%28kotlin.collections.List%28%28kotlin.sequences.chunked.T%29%29%2C+kotlin.sequences.chunked.R%29%29%29%2Ftransform&quot;&gt;transform&lt;/a&gt; function is ephemeral and is valid only inside that function. You should not store it or allow it to escape in some way, unless you made a snapshot of it. The last list may have less elements than the given &lt;a href=&quot;chunked#kotlin.sequences%24chunked%28kotlin.sequences.Sequence%28%28kotlin.sequences.chunked.T%29%29%2C+kotlin.Int%2C+kotlin.Function1%28%28kotlin.collections.List%28%28kotlin.sequences.chunked.T%29%29%2C+kotlin.sequences.chunked.R%29%29%29%2Fsize&quot;&gt;size&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;chunked#kotlin.sequences%24chunked%28kotlin.sequences.Sequence%28%28kotlin.sequences.chunked.T%29%29%2C+kotlin.Int%2C+kotlin.Function1%28%28kotlin.collections.List%28%28kotlin.sequences.chunked.T%29%29%2C+kotlin.sequences.chunked.R%29%29%29%2Ftransform&quot;&gt;변환&lt;/a&gt; 함수에 전달 된 목록 은 일시적이며 해당 함수 내에서만 유효합니다. 스냅 샷을 만들지 않는 한 보관하거나 어떤 식 으로든 탈출해서는 안됩니다. 마지막 목록은 주어진 &lt;a href=&quot;chunked#kotlin.sequences%24chunked%28kotlin.sequences.Sequence%28%28kotlin.sequences.chunked.T%29%29%2C+kotlin.Int%2C+kotlin.Function1%28%28kotlin.collections.List%28%28kotlin.sequences.chunked.T%29%29%2C+kotlin.sequences.chunked.R%29%29%29%2Fsize&quot;&gt;크기&lt;/a&gt; 보다 적은 요소를 가질 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="a0c9e1743347f1aa8d11316573c39fab1f4d2b86" translate="yes" xml:space="preserve">
          <source>Note that the list passed to the &lt;a href=&quot;windowed#kotlin.collections%24windowed%28kotlin.collections.Iterable%28%28kotlin.collections.windowed.T%29%29%2C+kotlin.Int%2C+kotlin.Int%2C+kotlin.Boolean%2C+kotlin.Function1%28%28kotlin.collections.List%28%28kotlin.collections.windowed.T%29%29%2C+kotlin.collections.windowed.R%29%29%29%2Ftransform&quot;&gt;transform&lt;/a&gt; function is ephemeral and is valid only inside that function. You should not store it or allow it to escape in some way, unless you made a snapshot of it. Several last lists may have less elements than the given &lt;a href=&quot;windowed#kotlin.collections%24windowed%28kotlin.collections.Iterable%28%28kotlin.collections.windowed.T%29%29%2C+kotlin.Int%2C+kotlin.Int%2C+kotlin.Boolean%2C+kotlin.Function1%28%28kotlin.collections.List%28%28kotlin.collections.windowed.T%29%29%2C+kotlin.collections.windowed.R%29%29%29%2Fsize&quot;&gt;size&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;windowed#kotlin.collections%24windowed%28kotlin.collections.Iterable%28%28kotlin.collections.windowed.T%29%29%2C+kotlin.Int%2C+kotlin.Int%2C+kotlin.Boolean%2C+kotlin.Function1%28%28kotlin.collections.List%28%28kotlin.collections.windowed.T%29%29%2C+kotlin.collections.windowed.R%29%29%29%2Ftransform&quot;&gt;변환&lt;/a&gt; 함수에 전달 된 목록 은 일시적이며 해당 함수 내에서만 유효합니다. 스냅 샷을 만들지 않는 한 보관하거나 어떤 식 으로든 탈출해서는 안됩니다. 몇 개의 마지막 목록은 주어진 &lt;a href=&quot;windowed#kotlin.collections%24windowed%28kotlin.collections.Iterable%28%28kotlin.collections.windowed.T%29%29%2C+kotlin.Int%2C+kotlin.Int%2C+kotlin.Boolean%2C+kotlin.Function1%28%28kotlin.collections.List%28%28kotlin.collections.windowed.T%29%29%2C+kotlin.collections.windowed.R%29%29%29%2Fsize&quot;&gt;크기&lt;/a&gt; 보다 적은 요소를 가질 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="b9a01e230c14a996ac73932af98798f763d520bb" translate="yes" xml:space="preserve">
          <source>Note that the list passed to the &lt;a href=&quot;windowed#kotlin.sequences%24windowed%28kotlin.sequences.Sequence%28%28kotlin.sequences.windowed.T%29%29%2C+kotlin.Int%2C+kotlin.Int%2C+kotlin.Boolean%2C+kotlin.Function1%28%28kotlin.collections.List%28%28kotlin.sequences.windowed.T%29%29%2C+kotlin.sequences.windowed.R%29%29%29%2Ftransform&quot;&gt;transform&lt;/a&gt; function is ephemeral and is valid only inside that function. You should not store it or allow it to escape in some way, unless you made a snapshot of it. Several last lists may have less elements than the given &lt;a href=&quot;windowed#kotlin.sequences%24windowed%28kotlin.sequences.Sequence%28%28kotlin.sequences.windowed.T%29%29%2C+kotlin.Int%2C+kotlin.Int%2C+kotlin.Boolean%2C+kotlin.Function1%28%28kotlin.collections.List%28%28kotlin.sequences.windowed.T%29%29%2C+kotlin.sequences.windowed.R%29%29%29%2Fsize&quot;&gt;size&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;windowed#kotlin.sequences%24windowed%28kotlin.sequences.Sequence%28%28kotlin.sequences.windowed.T%29%29%2C+kotlin.Int%2C+kotlin.Int%2C+kotlin.Boolean%2C+kotlin.Function1%28%28kotlin.collections.List%28%28kotlin.sequences.windowed.T%29%29%2C+kotlin.sequences.windowed.R%29%29%29%2Ftransform&quot;&gt;변환&lt;/a&gt; 함수에 전달 된 목록 은 일시적이며 해당 함수 내에서만 유효합니다. 스냅 샷을 만들지 않는 한 보관하거나 어떤 식 으로든 탈출해서는 안됩니다. 몇 개의 마지막 목록은 주어진 &lt;a href=&quot;windowed#kotlin.sequences%24windowed%28kotlin.sequences.Sequence%28%28kotlin.sequences.windowed.T%29%29%2C+kotlin.Int%2C+kotlin.Int%2C+kotlin.Boolean%2C+kotlin.Function1%28%28kotlin.collections.List%28%28kotlin.sequences.windowed.T%29%29%2C+kotlin.sequences.windowed.R%29%29%29%2Fsize&quot;&gt;크기&lt;/a&gt; 보다 적은 요소를 가질 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="d6259e89a9a4c0b547dbd66ff1bea24b671ef991" translate="yes" xml:space="preserve">
          <source>Note that the module metadata published by Gradle 5.3 and above cannot be read by Gradle versions older than 5.3.</source>
          <target state="translated">Gradle 5.3 이상에서 게시 한 모듈 메타 데이터는 5.3 이전의 Gradle 버전에서는 읽을 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="289248f23bcb06f8e447242c0fc575e0c1a20430" translate="yes" xml:space="preserve">
          <source>Note that the named argument syntax cannot be used when calling Java functions, because Java bytecode does not always preserve names of function parameters.</source>
          <target state="translated">Java 바이트 코드가 항상 함수 매개 변수의 이름을 보존하지는 않으므로 Java 함수를 호출 할 때 이름 지정된 인수 구문을 사용할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="7b39b5b0c66187e76139e4031731bcf6a323f589" translate="yes" xml:space="preserve">
          <source>Note that the operation is not guaranteed to be atomic if the map is being modified concurrently.</source>
          <target state="translated">맵이 동시에 수정되는 경우 조작이 원 자성으로 보장되지는 않습니다.</target>
        </trans-unit>
        <trans-unit id="f1adf6c7e534562475c3f5e5643436265ce9a453" translate="yes" xml:space="preserve">
          <source>Note that the opposite reversed translation is not implemented yet: Swift/Objective-C error-throwing methods aren't imported to Kotlin as exception-throwing.</source>
          <target state="translated">반대의 역변환은 아직 구현되지 않았습니다. Swift / Objective-C 오류 발생 메소드는 예외 발생으로 Kotlin에 가져 오지 않습니다.</target>
        </trans-unit>
        <trans-unit id="13e4f5805154eec53798d94ef883500f35ad56a4" translate="yes" xml:space="preserve">
          <source>Note that the other uses of curly braces in Kotlin, such as in function and class definitions and after &lt;code&gt;if&lt;/code&gt;/&lt;code&gt;else&lt;/code&gt;/&lt;code&gt;for&lt;/code&gt;/&lt;code&gt;while&lt;/code&gt; statements, are not lambda expressions (so it is &lt;em&gt;not&lt;/em&gt; the case that &lt;code&gt;if&lt;/code&gt; is a function that conditionally executes a lambda function).</source>
          <target state="translated">참고로 이러한 기능 클래스 정의에서와 같이 이후 코 틀린에 중괄호의 다른 용도 &lt;code&gt;if&lt;/code&gt; / &lt;code&gt;else&lt;/code&gt; / &lt;code&gt;for&lt;/code&gt; / &lt;code&gt;while&lt;/code&gt; 그것이 있도록 문 (람다 표현하지 &lt;em&gt;아니&lt;/em&gt; 하는 경우, &lt;code&gt;if&lt;/code&gt; 함수 조건부 람다 실행 그 함수).</target>
        </trans-unit>
        <trans-unit id="29cdb0fff079bd2313b913b84a243b2ced642967" translate="yes" xml:space="preserve">
          <source>Note that the returned instance uses itself to synchronize on. Do not synchronize from external code on the returned instance as it may cause accidental deadlock. Also this behavior can be changed in the future.</source>
          <target state="translated">반환 된 인스턴스는 자체를 사용하여 동기화합니다. 반환 된 인스턴스의 외부 코드와 동기화하지 않으면 교착 상태가 발생할 수 있습니다. 또한이 동작은 나중에 변경 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="99bb4d1e09ed7e1f3f7c48bd69bd7281f7032077" translate="yes" xml:space="preserve">
          <source>Note that the source sequence and the array being added are iterated only when an &lt;code&gt;iterator&lt;/code&gt; is requested from the resulting sequence. Changing any of them between successive calls to &lt;code&gt;iterator&lt;/code&gt; may affect the result.</source>
          <target state="translated">소스 시퀀스와 추가되는 배열 은 결과 시퀀스에서 &lt;code&gt;iterator&lt;/code&gt; 가 요청 된 경우에만 반복됩니다 . &lt;code&gt;iterator&lt;/code&gt; 연속 호출 사이에서 변경 하면 결과에 영향을 줄 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4bc2850950af5238d132e57cd0616b073acff952" translate="yes" xml:space="preserve">
          <source>Note that the source sequence and the array being subtracted are iterated only when an &lt;code&gt;iterator&lt;/code&gt; is requested from the resulting sequence. Changing any of them between successive calls to &lt;code&gt;iterator&lt;/code&gt; may affect the result.</source>
          <target state="translated">소스 시퀀스와 빼는 배열 은 결과 시퀀스에서 &lt;code&gt;iterator&lt;/code&gt; 가 요청 된 경우에만 반복됩니다 . &lt;code&gt;iterator&lt;/code&gt; 연속 호출 사이에서 변경 하면 결과에 영향을 줄 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8cd8b63a074395eb7bac096117fd2d1a65ca128f" translate="yes" xml:space="preserve">
          <source>Note that the source sequence and the collection being added are iterated only when an &lt;code&gt;iterator&lt;/code&gt; is requested from the resulting sequence. Changing any of them between successive calls to &lt;code&gt;iterator&lt;/code&gt; may affect the result.</source>
          <target state="translated">소스 시퀀스와 추가되는 컬렉션은 &lt;code&gt;iterator&lt;/code&gt; 가 결과 시퀀스에서 요청 된 경우에만 반복됩니다 . &lt;code&gt;iterator&lt;/code&gt; 연속 호출 사이에서 변경 하면 결과에 영향을 줄 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="230e838a21a0d86d33ae636264aea12d232d60bc" translate="yes" xml:space="preserve">
          <source>Note that the source sequence and the collection being subtracted are iterated only when an &lt;code&gt;iterator&lt;/code&gt; is requested from the resulting sequence. Changing any of them between successive calls to &lt;code&gt;iterator&lt;/code&gt; may affect the result.</source>
          <target state="translated">소스 시퀀스와 빼는 콜렉션 은 결과 시퀀스에서 &lt;code&gt;iterator&lt;/code&gt; 가 요청 된 경우에만 반복됩니다 . &lt;code&gt;iterator&lt;/code&gt; 연속 호출 사이에서 변경 하면 결과에 영향을 줄 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1d7a2c8875e7a4328f4bc1cb1a337451636c5765" translate="yes" xml:space="preserve">
          <source>Note that the source sequence and the sequence being added are iterated only when an &lt;code&gt;iterator&lt;/code&gt; is requested from the resulting sequence. Changing any of them between successive calls to &lt;code&gt;iterator&lt;/code&gt; may affect the result.</source>
          <target state="translated">소스 시퀀스와 추가되는 시퀀스는 &lt;code&gt;iterator&lt;/code&gt; 가 결과 시퀀스에서 요청 된 경우에만 반복됩니다 . &lt;code&gt;iterator&lt;/code&gt; 연속 호출 사이에서 변경 하면 결과에 영향을 줄 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9b6c8e7b439f69f32239265aaaa738e3fcea0362" translate="yes" xml:space="preserve">
          <source>Note that the source sequence and the sequence being subtracted are iterated only when an &lt;code&gt;iterator&lt;/code&gt; is requested from the resulting sequence. Changing any of them between successive calls to &lt;code&gt;iterator&lt;/code&gt; may affect the result.</source>
          <target state="translated">소스 시퀀스와 빼는 시퀀스는 결과 시퀀스에서 &lt;code&gt;iterator&lt;/code&gt; 가 요청 된 경우에만 반복됩니다 . &lt;code&gt;iterator&lt;/code&gt; 연속 호출 사이에서 변경 하면 결과에 영향을 줄 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="be4783ce40fed5c138c67544445542f050cb0f80" translate="yes" xml:space="preserve">
          <source>Note that the syntax &lt;code&gt;this::prop&lt;/code&gt; to refer a &lt;a href=&quot;reflection#bound-function-and-property-references-since-11&quot;&gt;bound callable reference&lt;/a&gt; in the code directly is available only since Kotlin 1.1.</source>
          <target state="translated">코드에서 직접 &lt;a href=&quot;reflection#bound-function-and-property-references-since-11&quot;&gt;호출 가능한 참조&lt;/a&gt; 를 참조하기위한 &lt;code&gt;this::prop&lt;/code&gt; 구문 은 Kotlin 1.1 이후에만 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2949a431bbdf8be1e322b0911e16815ddc68d4b3" translate="yes" xml:space="preserve">
          <source>Note that the terms &quot;subclass&quot; and &quot;superclass&quot; can span multiple levels of inheritance - &lt;code&gt;Car&lt;/code&gt; is a subclass of &lt;code&gt;Any&lt;/code&gt;, and &lt;code&gt;Any&lt;/code&gt; is the superclass of everything. If we want to restrict ourselves to one level of inheritance, we will say &quot;direct subclass&quot; or &quot;direct superclass&quot;.</source>
          <target state="translated">&quot;서브 클래스&quot;및 &quot;슈퍼 클래스&quot;라는 용어는 여러 수준의 상속을 포괄 할 수 있습니다. &lt;code&gt;Car&lt;/code&gt; 는 &lt;code&gt;Any&lt;/code&gt; 의 서브 클래스 이고 &lt;code&gt;Any&lt;/code&gt; 는 모든 것의 슈퍼 클래스입니다. 우리가 하나의 상속 레벨로 제한하고 싶다면 &quot;직접 서브 클래스&quot;또는 &quot;직접 슈퍼 클래스&quot;라고합니다.</target>
        </trans-unit>
        <trans-unit id="6f04df739b130f057070e51840257477306e9abb" translate="yes" xml:space="preserve">
          <source>Note that the trailing newline of each line is stripped. You can also call &lt;code&gt;readLines()&lt;/code&gt; on a file object to get a list of all the lines, or &lt;code&gt;useLines()&lt;/code&gt; to supply a function that will be called on every line. If you simply want the entire file contents as one string or byte array, call &lt;code&gt;readText()&lt;/code&gt; or &lt;code&gt;readBytes()&lt;/code&gt;, respectively.</source>
          <target state="translated">각 줄의 마지막 줄 바꿈이 제거됩니다. 파일 객체에서 &lt;code&gt;readLines()&lt;/code&gt; 를 호출 하여 모든 줄의 목록을 얻거나 &lt;code&gt;useLines()&lt;/code&gt; 를 사용하여 모든 줄에서 호출 될 함수를 제공 할 수도 있습니다. 전체 파일 내용을 하나의 문자열 또는 바이트 배열로 사용 &lt;code&gt;readText()&lt;/code&gt; 또는 &lt;code&gt;readBytes()&lt;/code&gt; 를 각각 호출 하십시오 .</target>
        </trans-unit>
        <trans-unit id="3233b123410bb0637d15ef36074b9c50ad6be8ca" translate="yes" xml:space="preserve">
          <source>Note that the type of a property must be explicitly specified. As opposed to Python, declaring a property directly inside the class does not create a class-level property, but an instance-level one: every instance of &lt;code&gt;Person&lt;/code&gt; will have &lt;em&gt;its own&lt;/em&gt;&lt;code&gt;name&lt;/code&gt; and &lt;code&gt;age&lt;/code&gt;. Their values will start out in every instance as &lt;code&gt;&quot;Anne&quot;&lt;/code&gt; and &lt;code&gt;32&lt;/code&gt;, respectively, but the value in each instance can be modified independently of the others:</source>
          <target state="translated">속성 유형을 명시 적으로 지정해야합니다. 클래스 수준의 속성을 생성하지 않는 클래스 내부에 직접 속성을 선언, 파이썬에 반대하지만, 인스턴스 레벨의 하나로서 :의 모든 인스턴스 &lt;code&gt;Person&lt;/code&gt; 이됩니다 &lt;em&gt;자신의 &lt;/em&gt; &lt;code&gt;name&lt;/code&gt; 과 &lt;code&gt;age&lt;/code&gt; . 해당 값은 모든 인스턴스 에서 각각 &lt;code&gt;&quot;Anne&quot;&lt;/code&gt; 및 &lt;code&gt;32&lt;/code&gt; 로 시작 하지만 각 인스턴스의 값은 다른 인스턴스와 독립적으로 수정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f7f16b8fd146ff06d4c86373cb61d32bd374065c" translate="yes" xml:space="preserve">
          <source>Note that the type systems of TypeScript and Kotlin do not match exactly, so you may need to edit the generated headers in case you encounter difficulties with using the APIs from Kotlin.</source>
          <target state="translated">TypeScript와 Kotlin의 유형 시스템이 정확히 일치하지 않으므로 Kotlin의 API를 사용하는 데 어려움이있는 경우 생성 된 헤더를 편집해야 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="b0f31d7eb5e41ba2d64378a5f837d7e8fe985ed7" translate="yes" xml:space="preserve">
          <source>Note that the use of local returns in previous three examples is similar to the use of &lt;em&gt;continue&lt;/em&gt; in regular loops. There is no direct equivalent for &lt;em&gt;break&lt;/em&gt;, but it can be simulated by adding another nesting lambda and non-locally returning from it:</source>
          <target state="translated">이전 세 예제에서 로컬 리턴을 사용하는 것은 일반 루프에서 &lt;em&gt;continue&lt;/em&gt; 를 사용하는 것과 유사합니다 . &lt;em&gt;break&lt;/em&gt; 와 직접적으로 동일한 것은 없지만 다른 중첩 람다를 추가하고 로컬에서 로컬로 반환하여 시뮬레이션 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c4baab91a6183da58c03d16fdff1a5962cf6d45a" translate="yes" xml:space="preserve">
          <source>Note that there must be no space between &lt;code&gt;continue&lt;/code&gt;/&lt;code&gt;break&lt;/code&gt; and &lt;code&gt;@&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;continue&lt;/code&gt; / &lt;code&gt;break&lt;/code&gt; 와 &lt;code&gt;@&lt;/code&gt; 사이에는 공백이 없어야합니다 .</target>
        </trans-unit>
        <trans-unit id="9d4ed672615deb4b3ea8e8cf90856dae61208644" translate="yes" xml:space="preserve">
          <source>Note that there's no point in optimizing your code when comparing to &lt;code&gt;null&lt;/code&gt; explicitly: &lt;code&gt;a == null&lt;/code&gt; will be automatically translated to &lt;code&gt;a === null&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;null&lt;/code&gt; 과 명시 적으로 비교할 때 코드를 최적화 할 필요는 없습니다 . &lt;code&gt;a == null&lt;/code&gt; 은 자동으로 &lt;code&gt;a === null&lt;/code&gt; 변환됩니다 .</target>
        </trans-unit>
        <trans-unit id="29bbb70efdb2913fbd8c12ace3a60040ce02ee39" translate="yes" xml:space="preserve">
          <source>Note that these &lt;code&gt;xxxAsync&lt;/code&gt; functions are &lt;strong&gt;not&lt;/strong&gt;&lt;em&gt;suspending&lt;/em&gt; functions. They can be used from anywhere. However, their use always implies asynchronous (here meaning &lt;em&gt;concurrent&lt;/em&gt;) execution of their action with the invoking code.</source>
          <target state="translated">이 &lt;code&gt;xxxAsync&lt;/code&gt; 함수는 함수를 &lt;em&gt;일시 중단 &lt;/em&gt;&lt;strong&gt;하지 않습니다&lt;/strong&gt; . 어디에서나 사용할 수 있습니다. 그러나 그것들의 사용은 항상 호출 코드로 그들의 액션의 비동기 (여기서는 &lt;em&gt;동시를&lt;/em&gt; 의미 함 ) 실행을 의미 &lt;em&gt;합니다&lt;/em&gt; .&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="d091dbc112d0275a030bcbf9509f2a82ef36aedb" translate="yes" xml:space="preserve">
          <source>Note that this Comparator does not take locale into account, and will result in an unsatisfactory ordering for certain locales.</source>
          <target state="translated">이 비교기는 로케일을 고려하지 않으므로 특정 로케일에 대한 순서가 만족스럽지 않습니다.</target>
        </trans-unit>
        <trans-unit id="bf9957e9675cc2706846aa1653497d6600b98d94" translate="yes" xml:space="preserve">
          <source>Note that this example also uses &lt;code&gt;use&lt;/code&gt; function from the Kotlin standard library to release threads that are created with &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/new-single-thread-context.html&quot;&gt;newSingleThreadContext&lt;/a&gt; when they are no longer needed.</source>
          <target state="translated">이 예제는 Kotlin 표준 라이브러리의 &lt;code&gt;use&lt;/code&gt; 함수를 사용 하여 더 이상 필요하지 않은 &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/new-single-thread-context.html&quot;&gt;newSingleThreadContext&lt;/a&gt; 로 작성된 스레드를 해제 합니다.</target>
        </trans-unit>
        <trans-unit id="f0cc5e3b07875e2d5bb6712ec59bb2224c29a52e" translate="yes" xml:space="preserve">
          <source>Note that this only works where &lt;code&gt;b&lt;/code&gt; is immutable (i.e. a local variable which is not modified between the check and the usage or a member &lt;em&gt;val&lt;/em&gt; which has a backing field and is not overridable), because otherwise it might happen that &lt;code&gt;b&lt;/code&gt; changes to &lt;em&gt;null&lt;/em&gt; after the check.</source>
          <target state="translated">여기서 참고이 경우에만 작동 &lt;code&gt;b&lt;/code&gt; 는 불변이다 (즉, 검사 및 사용 또는 구성원 사이에 수정되지 않은 지역 변수 &lt;em&gt;val에&lt;/em&gt; 역행 필드가하고 재정의되지 않습니다) 그렇지 않으면이 일어날 수 있기 때문에, &lt;code&gt;b&lt;/code&gt; 변경 &lt;em&gt;널 (null)을&lt;/em&gt; 한 후 수표.</target>
        </trans-unit>
        <trans-unit id="02cb3aecbee6ce81505199ced32233815d499b61" translate="yes" xml:space="preserve">
          <source>Note that this part of the &lt;code&gt;.def&lt;/code&gt; file is treated as part of the header file, so functions with the body should be declared as &lt;code&gt;static&lt;/code&gt;. The declarations are parsed after including the files from the &lt;code&gt;headers&lt;/code&gt; list.</source>
          <target state="translated">&lt;code&gt;.def&lt;/code&gt; 파일 의이 부분은 헤더 파일의 일부로 취급되므로 본문이있는 함수는 &lt;code&gt;static&lt;/code&gt; 으로 선언해야합니다 . &lt;code&gt;headers&lt;/code&gt; 목록 의 파일을 포함시킨 후 선언이 구문 분석 됩니다.</target>
        </trans-unit>
        <trans-unit id="632fe2c8e3130a19688049106ee9e7cf2e3fa004" translate="yes" xml:space="preserve">
          <source>Note that this way of applying the Kotlin/JS plugin requires adding the following code to Gradle settings file (&lt;code&gt;settings.gradle&lt;/code&gt;):</source>
          <target state="translated">Kotlin / JS 플러그인을 적용하려면 Gradle 설정 파일 ( &lt;code&gt;settings.gradle&lt;/code&gt; )에 다음 코드를 추가해야합니다 .</target>
        </trans-unit>
        <trans-unit id="5d89b0ac97e4e72ec3a56a39219f1c2ad6cf8c5b" translate="yes" xml:space="preserve">
          <source>Note that we do not use &lt;code&gt;val&lt;/code&gt; in front of &lt;code&gt;maxSpeed&lt;/code&gt; in &lt;code&gt;Car&lt;/code&gt; - doing so would have introduced a distinct property in &lt;code&gt;Car&lt;/code&gt; that would have &lt;em&gt;shadowed&lt;/em&gt; the one inherited from &lt;code&gt;MotorVehicle&lt;/code&gt;. As written, it's just a constructor parameter that we pass on to the superconstructor.</source>
          <target state="translated">우리는 &lt;code&gt;Car&lt;/code&gt; 에서 &lt;code&gt;maxSpeed&lt;/code&gt; 앞에 &lt;code&gt;val&lt;/code&gt; 을 사용하지 않습니다. 그렇게하면 &lt;code&gt;MotorVehicle&lt;/code&gt; 에서 상속 된 것을 &lt;em&gt;섀도 잉&lt;/em&gt; 할 독특한 속성이 &lt;code&gt;Car&lt;/code&gt; 에 도입 되었을 것 입니다. 작성된 것처럼, 그것은 우리가 슈퍼 컨스트럭터에 전달하는 생성자 매개 변수 일뿐입니다.&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="32efdf9e14f64cdc5ac4ce116b4cf7f1f66b160c" translate="yes" xml:space="preserve">
          <source>Note that when the LazyThreadSafetyMode.SYNCHRONIZED mode is specified the returned instance uses itself to synchronize on. Do not synchronize from external code on the returned instance as it may cause accidental deadlock. Also this behavior can be changed in the future.</source>
          <target state="translated">LazyThreadSafetyMode.SYNCHRONIZED 모드가 지정되면 반환 된 인스턴스 자체가 동기화를 위해 사용됩니다. 반환 된 인스턴스의 외부 코드와 동기화하지 않으면 교착 상태가 발생할 수 있습니다. 또한이 동작은 나중에 변경 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d89d8b71e027e7e428c09aada677d55add6a81f5" translate="yes" xml:space="preserve">
          <source>Note that while &lt;code&gt;File()&lt;/code&gt; does create a &quot;file object&quot;, it doesn't actually open the file - the file object is just a reference to the file path; opening the file is a separate action. The preceding functions open and close the file automatically, whereas other functions separately open and close the file. For example, if you're parsing binary data and you don't want to read the entire file at once, you must create an &lt;em&gt;input stream&lt;/em&gt; (for binary data) or an &lt;em&gt;input stream reader&lt;/em&gt; (for strings) - the example below will read 16 bytes:</source>
          <target state="translated">반면 있습니다 &lt;code&gt;File()&lt;/code&gt; 에 &quot;파일 객체&quot;를 만들 않으며, 실제로 파일을 열지 않습니다 - 파일 객체가 파일 경로 단지 참조입니다; 파일을 여는 것은 별도의 작업입니다. 앞의 기능은 파일을 자동으로 열고 닫는 반면 다른 기능은 파일을 개별적으로 열고 닫습니다. 예를 들어, 이진 데이터를 구문 분석하고 전체 파일을 한 번에 읽지 않으려면 &lt;em&gt;입력 스트림&lt;/em&gt; (이진 데이터) 또는 &lt;em&gt;입력 스트림 판독기&lt;/em&gt; (문자열)를 만들어야합니다. 아래 예는 16 바이트 :</target>
        </trans-unit>
        <trans-unit id="14f5320c56ff81654d679ede920646b9dc75066a" translate="yes" xml:space="preserve">
          <source>Note that with Gradle Kotlin DSL, you should get the task from the project's &lt;code&gt;tasks&lt;/code&gt; first.</source>
          <target state="translated">Gradle Kotlin DSL을 사용하면 먼저 프로젝트 작업에서 작업을 가져와야 &lt;code&gt;tasks&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c40d9fcf3b6b2afa85b538678b5ccf141165484f" translate="yes" xml:space="preserve">
          <source>Note that you can build the same pipeline using &lt;a href=&quot;../../../api/latest/jvm/stdlib/kotlin.sequences/iterator&quot;&gt;&lt;code&gt;iterator&lt;/code&gt;&lt;/a&gt; coroutine builder from the standard library. Replace &lt;code&gt;produce&lt;/code&gt; with &lt;code&gt;iterator&lt;/code&gt;, &lt;code&gt;send&lt;/code&gt; with &lt;code&gt;yield&lt;/code&gt;, &lt;code&gt;receive&lt;/code&gt; with &lt;code&gt;next&lt;/code&gt;, &lt;code&gt;ReceiveChannel&lt;/code&gt; with &lt;code&gt;Iterator&lt;/code&gt;, and get rid of the coroutine scope. You will not need &lt;code&gt;runBlocking&lt;/code&gt; either. However, the benefit of a pipeline that uses channels as shown above is that it can actually use multiple CPU cores if you run it in &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-dispatchers/-default.html&quot;&gt;Dispatchers.Default&lt;/a&gt; context.</source>
          <target state="translated">표준 라이브러리에서 &lt;a href=&quot;../../../api/latest/jvm/stdlib/kotlin.sequences/iterator&quot;&gt; &lt;code&gt;iterator&lt;/code&gt; &lt;/a&gt; 코 루틴 빌더를 사용하여 동일한 파이프 라인을 빌드 할 수 있습니다 . 교체 &lt;code&gt;produce&lt;/code&gt; 함께 &lt;code&gt;iterator&lt;/code&gt; , &lt;code&gt;send&lt;/code&gt; 와 &lt;code&gt;yield&lt;/code&gt; , &lt;code&gt;receive&lt;/code&gt; 와 &lt;code&gt;next&lt;/code&gt; , &lt;code&gt;ReceiveChannel&lt;/code&gt; 와 &lt;code&gt;Iterator&lt;/code&gt; 와 코 루틴 범위 제거하기. &lt;code&gt;runBlocking&lt;/code&gt; 도 필요하지 않습니다 . 그러나 위에 표시된대로 채널을 사용하는 파이프 라인의 이점은 &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-dispatchers/-default.html&quot;&gt;Dispatchers.Default&lt;/a&gt; 컨텍스트 에서 실행하면 실제로 여러 개의 CPU 코어를 사용할 수 있다는 것 입니다.</target>
        </trans-unit>
        <trans-unit id="fb9e894663a37dff3bfdff25d326ba2089261968" translate="yes" xml:space="preserve">
          <source>Note that you can open folders in the Source tab and see sources of libraries you are using in your project, including Kotlin standard library (&lt;code&gt;kotlin.js&lt;/code&gt;). This, however, requires that libraries are compiled with source maps enabled, as well as sources embedded into source maps. So the good practice is: if you share a library for Kotlin/JS, please, include source map into distribution.</source>
          <target state="translated">소스 탭에서 폴더를 열고 Kotlin 표준 라이브러리 ( &lt;code&gt;kotlin.js&lt;/code&gt; )를 포함하여 프로젝트에서 사용중인 라이브러리의 소스를 볼 수 있습니다 . 그러나이를 위해서는 소스 맵에 포함 된 소스뿐만 아니라 소스 맵을 사용하여 라이브러리를 컴파일해야합니다. Kotlin / JS 용 라이브러리를 공유하는 경우 소스 맵을 배포에 포함 시키십시오.</target>
        </trans-unit>
        <trans-unit id="f3d310ef82c3c4cf7ec6ba7c31c24dfd55f8f136" translate="yes" xml:space="preserve">
          <source>Note that you can use the &lt;em&gt;override&lt;/em&gt; keyword as part of the property declaration in a primary constructor.</source>
          <target state="translated">기본 생성자에서 속성 선언의 일부로 &lt;em&gt;override&lt;/em&gt; 키워드를 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="49136291f4ccdd63f93ac650ad3552f2ac330a1e" translate="yes" xml:space="preserve">
          <source>Note that you can't extend a non-external class by external classes.</source>
          <target state="translated">외부 클래스가 아닌 외부 클래스를 확장 할 수는 없습니다.</target>
        </trans-unit>
        <trans-unit id="3e28231afdd7ac958845e417ade6744d2f5c90c1" translate="yes" xml:space="preserve">
          <source>Note that you need to turn on the &lt;a href=&quot;#enabling-experimental-features&quot;&gt;experimental flag&lt;/a&gt; to use &lt;code&gt;LayoutContainer&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;LayoutContainer&lt;/code&gt; 를 사용 하려면 &lt;a href=&quot;#enabling-experimental-features&quot;&gt;실험용 플래그&lt;/a&gt; 를 켜야 합니다.</target>
        </trans-unit>
        <trans-unit id="7606870a12c3125873b69f0dbf82ae21f8b6f6b5" translate="yes" xml:space="preserve">
          <source>Note that, as described in &lt;a href=&quot;classes#secondary-constructors&quot;&gt;Secondary Constructors&lt;/a&gt;, if a class has default values for all constructor parameters, a public no-argument constructor will be generated for it. This works even if the &lt;code&gt;@JvmOverloads&lt;/code&gt; annotation is not specified.</source>
          <target state="translated">&lt;a href=&quot;classes#secondary-constructors&quot;&gt;보조 생성자에&lt;/a&gt; 설명 된대로 클래스에 모든 생성자 매개 변수에 대한 기본값이 있으면 인수가없는 공용 생성자가 생성됩니다. &lt;code&gt;@JvmOverloads&lt;/code&gt; 주석이 지정되지 않은 경우에도 작동 합니다.</target>
        </trans-unit>
        <trans-unit id="bcfd3d4bc13c4d196d89ced424f8f78ed6df819a" translate="yes" xml:space="preserve">
          <source>Note that, even though the members of companion objects look like static members in other languages, at runtime those are still instance members of real objects, and can, for example, implement interfaces:</source>
          <target state="translated">컴패니언 객체의 멤버는 다른 언어의 정적 멤버처럼 보이지만 런타임시 여전히 실제 객체의 인스턴스 멤버이며 예를 들어 인터페이스를 구현할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="63673aeff981591d75550c2f1b2c84d22a058b57" translate="yes" xml:space="preserve">
          <source>Note that, if the Java class only has a setter, it will not be visible as a property in Kotlin, because Kotlin does not support set-only properties at this time.</source>
          <target state="translated">Java 클래스에 세터 만있는 경우 Kotlin은 현재 설정 전용 특성을 지원하지 않으므로 Kotlin에서 특성으로 표시되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="4ff451e50da6bbf10519c4f38e0ec36c818d0c89" translate="yes" xml:space="preserve">
          <source>Note that, since &lt;em&gt;throw&lt;/em&gt; and &lt;em&gt;return&lt;/em&gt; are expressions in Kotlin, they can also be used on the right hand side of the elvis operator. This can be very handy, for example, for checking function arguments:</source>
          <target state="translated">이후, 그 참고 &lt;em&gt;던져&lt;/em&gt; 및 &lt;em&gt;반환&lt;/em&gt; 코 틀린의 표현을, 그들은 또한 엘비스 연산자의 오른쪽에 사용할 수 있습니다. 예를 들어 함수 인수를 확인하는 데 매우 유용 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ff2652dcfc51e4dc3d549eb0a81df9a68d2667cc" translate="yes" xml:space="preserve">
          <source>Note that, since extensions do not actually insert members into classes, there's no efficient way for an extension property to have a &lt;a href=&quot;properties#backing-fields&quot;&gt;backing field&lt;/a&gt;. This is why &lt;strong&gt;initializers are not allowed for extension properties&lt;/strong&gt;. Their behavior can only be defined by explicitly providing getters/setters.</source>
          <target state="translated">확장은 실제로 멤버를 클래스에 삽입하지 않으므로 확장 속성에 &lt;a href=&quot;properties#backing-fields&quot;&gt;보조 필드&lt;/a&gt; 가있는 효율적인 방법은 없습니다 . 이 때문에 &lt;strong&gt;초기화 프로그램은 확장 속성을 사용할 수 없습니다&lt;/strong&gt; . 그들의 행동은 게터 / 세터를 명시 적으로 제공해야만 정의 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="410e3cbb9102efe17f7c84d061da15f92debf764" translate="yes" xml:space="preserve">
          <source>Note the &lt;code&gt;@NotNull&lt;/code&gt; annotations on &lt;code&gt;String&lt;/code&gt; type arguments. Without them, we get platform types in the type arguments:</source>
          <target state="translated">&lt;code&gt;String&lt;/code&gt; 유형 인수 에 &lt;code&gt;@NotNull&lt;/code&gt; 주석을 적어 둡니다 . 그것들이 없으면, 우리는 타입 인자에서 플랫폼 타입을 얻는다 :</target>
        </trans-unit>
        <trans-unit id="c5849a883ad401340758801d94c3c8fe5489e593" translate="yes" xml:space="preserve">
          <source>Note the difference between declaring two parameters and declaring a destructuring pair instead of a parameter:</source>
          <target state="translated">두 개의 매개 변수 선언과 매개 변수 대신 파괴 쌍 선언의 차이점에 유의하십시오.</target>
        </trans-unit>
        <trans-unit id="fe84360ef08152f70a600e469dd1daf46f251b07" translate="yes" xml:space="preserve">
          <source>Note the use of &lt;code&gt;private&lt;/code&gt;&lt;a href=&quot;../reference/visibility-modifiers&quot;&gt;visibility modifier&lt;/a&gt; here. While the concept of visibility modifier is not relevant for competitive programming at all, it allows you to place multiple solution files based on the same template without getting an error for conflicting public declarations in the same package.</source>
          <target state="translated">여기 에서 &lt;code&gt;private&lt;/code&gt; &lt;a href=&quot;../reference/visibility-modifiers&quot;&gt;가시성 수정자를 사용&lt;/a&gt; 하십시오. 가시성 수정 자의 개념은 경쟁 프로그래밍과 전혀 관련이 없지만 동일한 패키지에서 공개 선언 충돌에 대한 오류없이 동일한 템플릿을 기반으로 여러 솔루션 파일을 배치 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="32363778a2d483af8b5e294fa0d257703c3636de" translate="yes" xml:space="preserve">
          <source>Note the use of Kotlin's &lt;a href=&quot;../reference/null-safety#the--operator&quot;&gt;null-assertion operator&lt;/a&gt;&lt;code&gt;!!&lt;/code&gt; after the &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.io/read-line&quot;&gt;readLine()&lt;/a&gt; function call. Kotlin's &lt;code&gt;readLine()&lt;/code&gt; function is defined to return a &lt;a href=&quot;../reference/null-safety#nullable-types-and-non-null-types&quot;&gt;nullable type&lt;/a&gt;&lt;code&gt;String?&lt;/code&gt; and returns &lt;code&gt;null&lt;/code&gt; on the end of the input, which explicitly forces the developer to handle the case of missing input.</source>
          <target state="translated">Kotlin의 &lt;a href=&quot;../reference/null-safety#the--operator&quot;&gt;널 어설 션 연산자&lt;/a&gt; 사용에 유의하십시오 &lt;code&gt;!!&lt;/code&gt; &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.io/read-line&quot;&gt;readLine ()&lt;/a&gt; 함수 호출 후 Kotlin의 &lt;code&gt;readLine()&lt;/code&gt; 함수는 &lt;a href=&quot;../reference/null-safety#nullable-types-and-non-null-types&quot;&gt;nullable 유형 &lt;/a&gt; &lt;code&gt;String?&lt;/code&gt; 을 반환하도록 정의되어 있습니까? 입력이 끝날 때 &lt;code&gt;null&lt;/code&gt; 을 반환 하여 개발자가 입력이 누락 된 경우를 명시 적으로 처리하도록합니다.</target>
        </trans-unit>
        <trans-unit id="ac2f2aad869d626d4d52fe790ab55573fcf5e8e3" translate="yes" xml:space="preserve">
          <source>Note, Kotlin/Native object references do not support multi-threaded access. Hosting the returned &lt;code&gt;libnative_ExportedSymbols*&lt;/code&gt; pointer per thread might be necessary.</source>
          <target state="translated">Kotlin / Native 객체 참조는 다중 스레드 액세스를 지원하지 않습니다. 스레드 당 리턴 된 &lt;code&gt;libnative_ExportedSymbols*&lt;/code&gt; 포인터를 호스팅 해야합니다.</target>
        </trans-unit>
        <trans-unit id="2b78a1550dcdacf66568124ca1b7e49361c24581" translate="yes" xml:space="preserve">
          <source>Note, here we use the &lt;code&gt;$SRCROOT/../..&lt;/code&gt; as the path to the root of our Gradle project. It can depend on the way the Xcode project was created. Also, we use the generated &lt;code&gt;SharedCode/build/xcode-frameworks/gradlew&lt;/code&gt; script, the &lt;code&gt;packForXCode&lt;/code&gt; task generates it. We assumed that the Gradle build is executed at least once, before opening the Xcode project on a fresh machine</source>
          <target state="translated">여기서는 &lt;code&gt;$SRCROOT/../..&lt;/code&gt; 를 Gradle 프로젝트의 루트 경로로 사용합니다. Xcode 프로젝트가 생성 된 방식에 따라 달라질 수 있습니다. 또한 생성 된 &lt;code&gt;SharedCode/build/xcode-frameworks/gradlew&lt;/code&gt; 스크립트를 사용하며 &lt;code&gt;packForXCode&lt;/code&gt; 태스크가이를 생성합니다. 새로운 머신에서 Xcode 프로젝트를 열기 전에 Gradle 빌드가 적어도 한 번 실행되는 것으로 가정했습니다.</target>
        </trans-unit>
        <trans-unit id="e681d434ce2d0ba5fe65e1c3eb9e64a72c2114ad" translate="yes" xml:space="preserve">
          <source>Note, how both first &lt;code&gt;async&lt;/code&gt; and awaiting parent are cancelled on the one child failure:</source>
          <target state="translated">하나의 자식 실패에서 첫 번째 &lt;code&gt;async&lt;/code&gt; 및 대기중인 부모가 모두 취소되는 방법에 유의하십시오 .</target>
        </trans-unit>
        <trans-unit id="fa14e718dbed55afbde738f5e7d1fbd2fe0275f6" translate="yes" xml:space="preserve">
          <source>Note, however, that members overridden in this way do not get called from the members of the delegate object, which can only access its own implementations of the interface members:</source>
          <target state="translated">그러나이 방법으로 재정의 된 멤버는 대리자 개체의 멤버에서 호출되지 않으며, 인터페이스 멤버의 자체 구현에만 액세스 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9016aa7ea4f2b1fc5592a3d2b46f69f0ff3c825e" translate="yes" xml:space="preserve">
          <source>Note, that an exception thrown by &lt;a href=&quot;recover#kotlin%24recover%28kotlin.Result%28%28kotlin.recover.T%29%29%2C+kotlin.Function1%28%28kotlin.Throwable%2C+kotlin.recover.R%29%29%29%2Ftransform&quot;&gt;transform&lt;/a&gt; function is rethrown by this function. See &lt;a href=&quot;recover-catching&quot;&gt;recoverCatching&lt;/a&gt; for an alternative that encapsulates exceptions.</source>
          <target state="translated">&lt;a href=&quot;recover#kotlin%24recover%28kotlin.Result%28%28kotlin.recover.T%29%29%2C+kotlin.Function1%28%28kotlin.Throwable%2C+kotlin.recover.R%29%29%29%2Ftransform&quot;&gt;변환&lt;/a&gt; 함수에 의해 발생 된 예외 는이 함수에 의해 다시 발생 합니다. 예외를 캡슐화하는 대안 은 &lt;a href=&quot;recover-catching&quot;&gt;recoverCatching&lt;/a&gt; 을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="ab4261a565eea01ddcb4378ad59c0c58898851cf" translate="yes" xml:space="preserve">
          <source>Note, that for some cases cycle collection need to be done to ensure that dead cycles do not affect reachability of passed object graph.</source>
          <target state="translated">경우에 따라 사용 불능주기가 전달 된 객체 그래프의 도달 가능성에 영향을 미치지 않도록주기 수집을 수행해야합니다.</target>
        </trans-unit>
        <trans-unit id="b6259b2eebc86f15dafec32912cdde080c4e1580" translate="yes" xml:space="preserve">
          <source>Note, that the generated bindings are generally platform-specific, so if you are developing for multiple targets, the bindings need to be regenerated.</source>
          <target state="translated">생성 된 바인딩은 일반적으로 플랫폼별로 다르므로 여러 대상을 위해 개발하는 경우 바인딩을 재생성해야합니다.</target>
        </trans-unit>
        <trans-unit id="fe80340489c5eb8bbb1e5235c463cea51b0d96bc" translate="yes" xml:space="preserve">
          <source>Note, the task may not work &lt;a href=&quot;https://github.com/gradle/gradle/issues/6330&quot;&gt;correctly&lt;/a&gt; if you use Gradle older than 4.10. In this tutorial we have already &lt;a href=&quot;#gradle-upgrade&quot;&gt;upgraded it to 4.7&lt;/a&gt;.</source>
          <target state="translated">4.10보다 오래된 Gradle을 사용하면 작업이 &lt;a href=&quot;https://github.com/gradle/gradle/issues/6330&quot;&gt;올바르게&lt;/a&gt; 작동하지 않을 수 있습니다. 이 학습서에서는 이미 &lt;a href=&quot;#gradle-upgrade&quot;&gt;4.7로 업그레이드했습니다&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="cdfb7f6c960fbbb54ec2a22474d762eebb5eb578" translate="yes" xml:space="preserve">
          <source>Note, the way Kotlin/Native exports symbols is subject to change without notice.</source>
          <target state="translated">Kotlin / Native 내보내기 기호는 예고없이 변경 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a421385920384e5f4a176ab3c70967301467e475" translate="yes" xml:space="preserve">
          <source>Note, this mechanism currently works only on Java version 1.7+. Limitation on JS and Native is temporary and will be fixed in the future.</source>
          <target state="translated">이 메커니즘은 현재 Java 버전 1.7 이상에서만 작동합니다. JS 및 Native에 대한 제한은 일시적이며 향후 수정 될 예정입니다.</target>
        </trans-unit>
        <trans-unit id="12618a61ea26af57372d00837c08269ccff8b13d" translate="yes" xml:space="preserve">
          <source>Note, we use the extension property &lt;code&gt;ptr&lt;/code&gt; which comes from a &lt;code&gt;memScoped&lt;/code&gt; lambda receiver type, to turn &lt;code&gt;MyStruct&lt;/code&gt; and &lt;code&gt;MyUnion&lt;/code&gt; instances into native pointers.</source>
          <target state="translated">&lt;code&gt;memScoped&lt;/code&gt; 람다 수신기 유형 에서 제공되는 확장 속성 &lt;code&gt;ptr&lt;/code&gt; 을 사용하여 &lt;code&gt;MyStruct&lt;/code&gt; 및 &lt;code&gt;MyUnion&lt;/code&gt; 인스턴스를 기본 포인터로 변환합니다.</target>
        </trans-unit>
        <trans-unit id="928235a3ea58117b013d6814e6ae398b8d106eb5" translate="yes" xml:space="preserve">
          <source>Note: &lt;a href=&quot;implies#kotlin.contracts.SimpleEffect%24implies%28kotlin.Boolean%29%2FbooleanExpression&quot;&gt;booleanExpression&lt;/a&gt; can accept only a subset of boolean expressions, where a function parameter or receiver (&lt;code&gt;this&lt;/code&gt;) undergoes</source>
          <target state="translated">참고 : &lt;a href=&quot;implies#kotlin.contracts.SimpleEffect%24implies%28kotlin.Boolean%29%2FbooleanExpression&quot;&gt;booleanExpression&lt;/a&gt; 은 함수 매개 변수 또는 수신자 ( &lt;code&gt;this&lt;/code&gt; )가 발생하는 부울 표현식의 서브 세트 만 승인 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="6981f24296bbc00cf0e0f8db9ec6624b3daecbcc" translate="yes" xml:space="preserve">
          <source>Note: &lt;code&gt;Any&lt;/code&gt; is not &lt;code&gt;java.lang.Object&lt;/code&gt;; in particular, it does not have any members other than &lt;code&gt;equals()&lt;/code&gt;, &lt;code&gt;hashCode()&lt;/code&gt; and &lt;code&gt;toString()&lt;/code&gt;. Please consult the &lt;a href=&quot;java-interop#object-methods&quot;&gt;Java interoperability&lt;/a&gt; section for more details.</source>
          <target state="translated">주 : &lt;code&gt;Any&lt;/code&gt; 는 &lt;code&gt;java.lang.Object&lt;/code&gt; 가 아닙니다 . 특히 &lt;code&gt;equals()&lt;/code&gt; , &lt;code&gt;hashCode()&lt;/code&gt; 및 &lt;code&gt;toString()&lt;/code&gt; 이외의 멤버는 없습니다 . 자세한 내용 은 &lt;a href=&quot;java-interop#object-methods&quot;&gt;Java 상호 운용성&lt;/a&gt; 섹션을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="7cea38b31131e5f3bc473b1806a7dadc1df3f76c" translate="yes" xml:space="preserve">
          <source>Note: Before 1.3.40, both test and product executables were represented by the same binary type. Thus to access the default test binary created by the plugin, the following line was used:</source>
          <target state="translated">참고 : 1.3.40 이전에는 테스트 및 제품 실행 파일이 모두 동일한 이진 유형으로 표시되었습니다. 따라서 플러그인으로 작성된 기본 테스트 바이너리에 액세스하기 위해 다음 행이 사용되었습니다.</target>
        </trans-unit>
        <trans-unit id="fb3a30630df8eec859177fc75c5dd700ee60baec" translate="yes" xml:space="preserve">
          <source>Note: For Spring you can use the &lt;code&gt;kotlin-spring&lt;/code&gt; compiler plugin (&lt;a href=&quot;compiler-plugins#spring-support&quot;&gt;see below&lt;/a&gt;).</source>
          <target state="translated">참고 : Spring의 경우 &lt;code&gt;kotlin-spring&lt;/code&gt; 컴파일러 플러그인을 사용할 수 있습니다 ( &lt;a href=&quot;compiler-plugins#spring-support&quot;&gt;아래 참조&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="d6a0dc39a4a138257b96c621b751cc052081b76a" translate="yes" xml:space="preserve">
          <source>Note: This above code will work properly only on JDK7+ that supports &lt;code&gt;suppressed&lt;/code&gt; exceptions</source>
          <target state="translated">참고 :이 위의 코드는 &lt;code&gt;suppressed&lt;/code&gt; 예외 를 지원 하는 JDK7 +에서만 올바르게 작동합니다.</target>
        </trans-unit>
        <trans-unit id="484cdded81040d7cac731a5df3e0b2162661d2db" translate="yes" xml:space="preserve">
          <source>Note: creating a source set does not link it to any target. Some source sets are &lt;a href=&quot;#default-project-layout&quot;&gt;predefined&lt;/a&gt; and thus compiled by default. However, custom source sets always need to be explicitly directed to the compilations. See: &lt;a href=&quot;#connecting-source-sets&quot;&gt;Connecting source sets&lt;/a&gt;.</source>
          <target state="translated">참고 : 소스 세트를 작성해도 해당 소스 세트가 링크되지 않습니다. 일부 소스 세트는 &lt;a href=&quot;#default-project-layout&quot;&gt;사전 정의&lt;/a&gt; 되어 기본적으로 컴파일됩니다. 그러나 사용자 정의 소스 세트는 항상 컴파일로 명시 적으로 지정되어야합니다. &lt;a href=&quot;#connecting-source-sets&quot;&gt;소스 세트 연결을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="3d3cb30c99fb08c5217d1cecd77b25e0a37cf168" translate="yes" xml:space="preserve">
          <source>Note: due to the current technical limitations, the IDE does not correctly recognize these annotations on type arguments in compiled Java libraries that are used as dependencies.</source>
          <target state="translated">참고 : 현재 기술적 인 한계로 인해 IDE는 종속성으로 사용되는 컴파일 된 Java 라이브러리의 유형 인수에 대한 이러한 주석을 올바르게 인식하지 못합니다.</target>
        </trans-unit>
        <trans-unit id="43526e690a06b94dffa5d82ef9ea46b38220defe" translate="yes" xml:space="preserve">
          <source>Note: runtime lookup can be forced even when the class is referenced statically from Objective-C source code by adding &lt;code&gt;__attribute__((objc_runtime_visible))&lt;/code&gt; to its &lt;code&gt;@interface&lt;/code&gt;.</source>
          <target state="translated">참고 : 클래스가 &lt;code&gt;@interface&lt;/code&gt; 에 &lt;code&gt;__attribute__((objc_runtime_visible))&lt;/code&gt; 을 추가하여 클래스가 Objective-C 소스 코드에서 정적으로 참조되는 경우에도 런타임 조회를 강제 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="961c619d9fb3964975b4b9e69245c681552524a7" translate="yes" xml:space="preserve">
          <source>Note: static and shared libraries has suffixes &lt;code&gt;static&lt;/code&gt; and &lt;code&gt;shared&lt;/code&gt; respectively, e.g. &lt;code&gt;fooDebugStatic&lt;/code&gt; or &lt;code&gt;barReleaseShared&lt;/code&gt;</source>
          <target state="translated">참고 : 정적 라이브러리와 공유 라이브러리에는 각각 &lt;code&gt;static&lt;/code&gt; 및 &lt;code&gt;shared&lt;/code&gt; 접미어가 있습니다 (예 : &lt;code&gt;fooDebugStatic&lt;/code&gt; 또는 &lt;code&gt;barReleaseShared&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="0ba0ca9c0ff727e2f159f9a318e2b4838c970baa" translate="yes" xml:space="preserve">
          <source>Note: the &lt;code&gt;lib&lt;/code&gt; directory which contains &lt;code&gt;kotlin.js&lt;/code&gt; and other library files is only created in IntelliJ IDEA-based projects and is controlled by the &lt;em&gt;Copy library runtime files&lt;/em&gt; flag in the Kotlin &lt;a href=&quot;https://www.jetbrains.com/help/idea/facets.html&quot;&gt;facet settings&lt;/a&gt;. In a Maven or Gradle build (including multiplatform projects), no library files are copied by default to the compilation output directory. See the corresponding tutorials for the instructions on how to achieve the same with those build systems.</source>
          <target state="translated">참고 : &lt;code&gt;kotlin.js&lt;/code&gt; 및 기타 라이브러리 파일이 포함 된 &lt;code&gt;lib&lt;/code&gt; 디렉토리 는 IntelliJ IDEA 기반 프로젝트에서만 작성되며 Kotlin &lt;a href=&quot;https://www.jetbrains.com/help/idea/facets.html&quot;&gt;패싯 설정&lt;/a&gt; 의 &lt;em&gt;라이브러리 런타임 파일 복사&lt;/em&gt; 플래그에 의해 제어됩니다 . Maven 또는 Gradle 빌드 (멀티 플랫폼 프로젝트 포함)에서 라이브러리 파일은 기본적으로 컴파일 출력 디렉토리에 복사되지 않습니다. 해당 빌드 시스템으로이를 달성하는 방법에 대한 지시 사항은 해당 학습서를 참조하십시오.&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="7a0e64e270b153ff90968e1ff6456ea22567f491" translate="yes" xml:space="preserve">
          <source>Note: the built-in JSR-305 annotations &lt;a href=&quot;https://aalmiray.github.io/jsr-305/apidocs/javax/annotation/Nonnull.html&quot;&gt;&lt;code&gt;@Nonnull&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;https://aalmiray.github.io/jsr-305/apidocs/javax/annotation/Nullable.html&quot;&gt;&lt;code&gt;@Nullable&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;https://aalmiray.github.io/jsr-305/apidocs/javax/annotation/CheckForNull.html&quot;&gt;&lt;code&gt;@CheckForNull&lt;/code&gt;&lt;/a&gt; are always enabled and affect the types of the annotated declarations in Kotlin, regardless of compiler configuration with the &lt;code&gt;-Xjsr305&lt;/code&gt; flag.</source>
          <target state="translated">참고 : 내장 JSR-305 어노테이션 &lt;a href=&quot;https://aalmiray.github.io/jsr-305/apidocs/javax/annotation/Nonnull.html&quot;&gt; &lt;code&gt;@Nonnull&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;https://aalmiray.github.io/jsr-305/apidocs/javax/annotation/Nullable.html&quot;&gt; &lt;code&gt;@Nullable&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;https://aalmiray.github.io/jsr-305/apidocs/javax/annotation/CheckForNull.html&quot;&gt; &lt;code&gt;@CheckForNull&lt;/code&gt; &lt;/a&gt; 은 항상 사용 가능하며 &lt;code&gt;-Xjsr305&lt;/code&gt; 플래그를 사용한 컴파일러 구성에 관계없이 Kotlin의 어노테이션이있는 선언 유형에 영향을줍니다 .</target>
        </trans-unit>
        <trans-unit id="70ea34d1da722222e140a53cf5465f6882b21617" translate="yes" xml:space="preserve">
          <source>Note: the migration status of a nullability annotation is not inherited by its type qualifier nicknames but is applied to its usages in default type qualifiers.</source>
          <target state="translated">참고 : Null 허용 주석의 마이그레이션 상태는 형식 한정자 닉네임으로 상속되지 않지만 기본 형식 한정자의 사용법에 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="c0edc7da32b33f24605529da7af1e0f20a415a52" translate="yes" xml:space="preserve">
          <source>Note: the static members of these Java types are not directly accessible on the &lt;a href=&quot;object-declarations#companion-objects&quot;&gt;companion objects&lt;/a&gt; of the Kotlin types. To call them, use the full qualified names of the Java types, e.g. &lt;code&gt;java.lang.Integer.toHexString(foo)&lt;/code&gt;.</source>
          <target state="translated">참고 : 이러한 Java 유형의 정적 멤버 는 Kotlin 유형 의 &lt;a href=&quot;object-declarations#companion-objects&quot;&gt;컴패니언 오브젝트&lt;/a&gt; 에서 직접 액세스 할 수 없습니다 . 이를 호출하려면 Java 유형의 완전한 이름 &lt;code&gt;java.lang.Integer.toHexString(foo)&lt;/code&gt; 예 : java.lang.Integer.toHexString (foo))을 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="58d630dc0f3f2c164372b5befca4a458dbf430dc" translate="yes" xml:space="preserve">
          <source>Note: the types in this example only take place with the strict mode enabled, otherwise, the platform types remain. See the &lt;a href=&quot;#undermigration-annotation-since-1160&quot;&gt;&lt;code&gt;@UnderMigration&lt;/code&gt; annotation&lt;/a&gt; and &lt;a href=&quot;#compiler-configuration&quot;&gt;Compiler configuration&lt;/a&gt; sections.</source>
          <target state="translated">참고 :이 예제의 유형은 엄격 모드가 활성화 된 경우에만 발생하며, 그렇지 않으면 플랫폼 유형이 유지됩니다. &lt;a href=&quot;#undermigration-annotation-since-1160&quot;&gt; &lt;code&gt;@UnderMigration&lt;/code&gt; 주석&lt;/a&gt; 및 &lt;a href=&quot;#compiler-configuration&quot;&gt;컴파일러 구성&lt;/a&gt; 섹션을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="1897db2fc3536b91b9cf29ef737cb27b1a12735f" translate="yes" xml:space="preserve">
          <source>Note: this annotation is experimental, see &lt;a href=&quot;../-experimental-multiplatform/index&quot;&gt;ExperimentalMultiplatform&lt;/a&gt; on how to opt-in for it.</source>
          <target state="translated">참고 :이 주석은 실험용 입니다. 옵트 인 방법에 대해서는 &lt;a href=&quot;../-experimental-multiplatform/index&quot;&gt;ExperimentalMultiplatform&lt;/a&gt; 을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="0b4255d1b07a5ecec5778c495ae7e465e074b5b4" translate="yes" xml:space="preserve">
          <source>Note: this annotation is experimental, see &lt;a href=&quot;../../kotlin.experimental/-experimental-type-inference/index&quot;&gt;ExperimentalTypeInference&lt;/a&gt; on how to opt-in for it.</source>
          <target state="translated">참고 :이 주석은 실험용 입니다. 옵트 인 방법에 대해서는 &lt;a href=&quot;../../kotlin.experimental/-experimental-type-inference/index&quot;&gt;ExperimentalTypeInference&lt;/a&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="357bf8828e4f466867f5aa8f9b5bb6f1a07b487b" translate="yes" xml:space="preserve">
          <source>Note: to use a visible top-level declaration from another package, you should still &lt;a href=&quot;packages#imports&quot;&gt;import&lt;/a&gt; it.</source>
          <target state="translated">참고 : 다른 패키지에서 보이는 최상위 선언을 사용하려면 여전히 &lt;a href=&quot;packages#imports&quot;&gt;가져와야&lt;/a&gt; 합니다.</target>
        </trans-unit>
        <trans-unit id="4f0d56c46129caef4c0e06f3c8334481a847bd34" translate="yes" xml:space="preserve">
          <source>Note: unlike Java, arrays in Kotlin are invariant. This means that Kotlin does not let us assign an &lt;code&gt;Array&amp;lt;String&amp;gt;&lt;/code&gt; to an &lt;code&gt;Array&amp;lt;Any&amp;gt;&lt;/code&gt;, which prevents a possible runtime failure (but you can use &lt;code&gt;Array&amp;lt;out Any&amp;gt;&lt;/code&gt;, see &lt;a href=&quot;generics#type-projections&quot;&gt;Type Projections&lt;/a&gt;).</source>
          <target state="translated">참고 : Java와 달리 Kotlin의 배열은 변하지 않습니다. 이것은 Kotlin이 &lt;code&gt;Array&amp;lt;String&amp;gt;&lt;/code&gt; 을 &lt;code&gt;Array&amp;lt;Any&amp;gt;&lt;/code&gt; 할당 하지 못하게하여 런타임 실패 가능성을 방지합니다 (그러나 &lt;code&gt;Array&amp;lt;out Any&amp;gt;&lt;/code&gt; 사용할 수 있습니다 ( &lt;a href=&quot;generics#type-projections&quot;&gt;Type Projections&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="70440046a3dc2e079f23ee1c57dfa76669b732aa" translate="yes" xml:space="preserve">
          <source>Notes</source>
          <target state="translated">Notes</target>
        </trans-unit>
        <trans-unit id="4481948392a8846400c954e77f58d76cdaa73963" translate="yes" xml:space="preserve">
          <source>Nothing</source>
          <target state="translated">Nothing</target>
        </trans-unit>
        <trans-unit id="79090fccdb94d09e1c560c62dc8ff6d888bc7489" translate="yes" xml:space="preserve">
          <source>Nothing has no instances. You can use Nothing to represent &quot;a value that never exists&quot;: for example, if a function has the return type of Nothing, it means that it never returns (always throws an exception).</source>
          <target state="translated">인스턴스가 없습니다. Nothing을 사용하여 &quot;존재하지 않는 값&quot;을 나타낼 수 있습니다. 예를 들어 함수에 반환 유형이 Nothing 인 경우 반환되지 않는 것을 의미합니다 (항상 예외가 발생 함).</target>
        </trans-unit>
        <trans-unit id="a531e5857d96a6fe172e33a54636fa2c5e7837a4" translate="yes" xml:space="preserve">
          <source>Notice that the implementation on &lt;em&gt;every&lt;/em&gt; platform can encode byte arrays to a string. If we want we can provide a more efficient implementation for this method, for example, let's specialize it on the JVM:</source>
          <target state="translated">&lt;em&gt;모든&lt;/em&gt; 플랫폼 에서 구현하면 바이트 배열을 문자열로 인코딩 할 수 있습니다. 예를 들어,이 메소드에 대해보다 효율적인 구현을 제공 할 수 있도록하려면 JVM에서 특수화하십시오.</target>
        </trans-unit>
        <trans-unit id="ac46cd6bf2ec7e9d90f5e3709af6c843ffd8a6af" translate="yes" xml:space="preserve">
          <source>NotificationAction</source>
          <target state="translated">NotificationAction</target>
        </trans-unit>
        <trans-unit id="f541255e0e0d091ef01be7d639674756d30f41bc" translate="yes" xml:space="preserve">
          <source>NotificationDirection</source>
          <target state="translated">NotificationDirection</target>
        </trans-unit>
        <trans-unit id="596349e0f504aa4e6ec1f31115a62914042449e8" translate="yes" xml:space="preserve">
          <source>NotificationEventInit</source>
          <target state="translated">NotificationEventInit</target>
        </trans-unit>
        <trans-unit id="2a1a4c24d8e083b47b4ff678b4cd0997219c060e" translate="yes" xml:space="preserve">
          <source>NotificationOptions</source>
          <target state="translated">NotificationOptions</target>
        </trans-unit>
        <trans-unit id="93c639dc73db96edc66ede2299276f652971fac6" translate="yes" xml:space="preserve">
          <source>NotificationPermission</source>
          <target state="translated">NotificationPermission</target>
        </trans-unit>
        <trans-unit id="94e838061a82a5ce0b113db3557cf9f9730866ea" translate="yes" xml:space="preserve">
          <source>Now check it with the command &lt;code&gt;./gradlew publishToMavenLocal&lt;/code&gt; and you should see a successful build. That's it, our library is now successfully published and any Kotlin project can depend on it, whether it is another common library, JVM, JS, or Native application.</source>
          <target state="translated">이제 &lt;code&gt;./gradlew publishToMavenLocal&lt;/code&gt; 명령 으로 확인하면 성공적인 빌드가 표시됩니다. 이제 라이브러리가 성공적으로 게시되었으며 다른 일반적인 라이브러리, JVM, JS 또는 기본 응용 프로그램인지 여부에 관계없이 모든 Kotlin 프로젝트에 의존 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4c6fdd021c50c395969a31c37923d25d734b30ed" translate="yes" xml:space="preserve">
          <source>Now compile the program linking with the library we have just created:</source>
          <target state="translated">이제 방금 만든 라이브러리와 연결하는 프로그램을 컴파일하십시오.</target>
        </trans-unit>
        <trans-unit id="7fd938355a267ec17f411c8d98d04708e4180da6" translate="yes" xml:space="preserve">
          <source>Now it is time to provide an &lt;code&gt;actual&lt;/code&gt; implementation of &lt;code&gt;Base64Factory&lt;/code&gt; for every platform.</source>
          <target state="translated">이제 모든 플랫폼에 대해 &lt;code&gt;Base64Factory&lt;/code&gt; 의 &lt;code&gt;actual&lt;/code&gt; 구현 을 제공 할 차례 입니다.</target>
        </trans-unit>
        <trans-unit id="ef159996af2b9215562c38a942c2f8905195f55d" translate="yes" xml:space="preserve">
          <source>Now it is time to refresh the Gradle project again in Android Studio. Click &lt;em&gt;Sync Now&lt;/em&gt; on the yellow stripe or use the &lt;em&gt;Gradle&lt;/em&gt; tool window and click the &lt;code&gt;Refresh&lt;/code&gt; action in the context menu on the root Gradle project. The &lt;code&gt;:SharedCode&lt;/code&gt; project should be recognized by the IDE now.</source>
          <target state="translated">이제 Android Studio에서 Gradle 프로젝트를 다시 새로 고칠 차례입니다. 노란색 줄무늬에서 &lt;em&gt;지금 동기화를&lt;/em&gt; 클릭 하거나 &lt;em&gt;Gradle&lt;/em&gt; 도구 창을 사용 하고 루트 Gradle 프로젝트의 상황에 맞는 메뉴에서 &lt;code&gt;Refresh&lt;/code&gt; 작업을 클릭하십시오 . &lt;code&gt;:SharedCode&lt;/code&gt; 의 프로젝트는 이제 IDE에 의해 인식되어야한다.</target>
        </trans-unit>
        <trans-unit id="9eb8c10ce256de217fd7408c5d0fa2be1c81f16b" translate="yes" xml:space="preserve">
          <source>Now it is time to see how to use &lt;code&gt;cValue&lt;/code&gt; and pass by-value parameters:</source>
          <target state="translated">이제 &lt;code&gt;cValue&lt;/code&gt; 를 사용 하고 값을 기준으로 매개 변수를 전달 하는 방법을 살펴볼 차례입니다 .</target>
        </trans-unit>
        <trans-unit id="f62049422e34abdef8fb40e736ddaa894413b1d4" translate="yes" xml:space="preserve">
          <source>Now it prints something sensible: &lt;code&gt;1784293664&lt;/code&gt;, because all coroutines complete.</source>
          <target state="translated">이제 모든 코 루틴이 완료 &lt;code&gt;1784293664&lt;/code&gt; 합리적인 것을 인쇄합니다 .</target>
        </trans-unit>
        <trans-unit id="9c3c5f110103dcae6c7a1c5048ae4801a489102c" translate="yes" xml:space="preserve">
          <source>Now it's time to add the task description. Click the &lt;strong&gt;Edit&lt;/strong&gt; icon at the top of &lt;strong&gt;Task Description&lt;/strong&gt; panel to switch to the editing mode:</source>
          <target state="translated">이제 작업 설명을 추가 할 차례입니다. &lt;strong&gt;작업 설명&lt;/strong&gt; 패널 상단의 &lt;strong&gt;편집&lt;/strong&gt; 아이콘을 클릭하여 편집 모드로 전환하십시오.&lt;strong&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="f21a6f3ded0ce3ad0d37be7f610a6bcde3237278" translate="yes" xml:space="preserve">
          <source>Now let us launch five processors and let them work for almost a second. See what happens:</source>
          <target state="translated">이제 5 개의 프로세서를 시작하고 거의 1 초 동안 작동하도록하겠습니다. 어떻게되는지보십시오 :</target>
        </trans-unit>
        <trans-unit id="3a85707fc6ed973d97aee272da025f72a2062245" translate="yes" xml:space="preserve">
          <source>Now let's check out the contents of the library:</source>
          <target state="translated">이제 라이브러리의 내용을 확인하십시오 :</target>
        </trans-unit>
        <trans-unit id="06f1756ff063bdd720deb57bebdc098cbb1f3682" translate="yes" xml:space="preserve">
          <source>Now let's open the project in IntelliJ IDEA. For that we click on the File | Open&amp;hellip; and select our &lt;code&gt;build.gradle.kts&lt;/code&gt;&lt;code&gt;build.gradle&lt;/code&gt; project file.</source>
          <target state="translated">이제 IntelliJ IDEA에서 프로젝트를 엽니 다. 이를 위해 File | &amp;hellip;를 열고 &lt;code&gt;build.gradle.kts&lt;/code&gt; &lt;code&gt;build.gradle&lt;/code&gt; 프로젝트 파일을 선택 하십시오.</target>
        </trans-unit>
        <trans-unit id="62863dbb3bcee301c0e208573e6e92993330cf1e" translate="yes" xml:space="preserve">
          <source>Now let's see how it works in practice:</source>
          <target state="translated">이제 실제로 어떻게 작동하는지 봅시다 :</target>
        </trans-unit>
        <trans-unit id="316006c9bf1b6b4efc24b9287e973de18a0cd5b2" translate="yes" xml:space="preserve">
          <source>Now let's write the same with sequences:</source>
          <target state="translated">이제 시퀀스로 동일하게 작성해 봅시다 :</target>
        </trans-unit>
        <trans-unit id="a94f1a0ca142aa8eb48c8af48afa3350f83b1400" translate="yes" xml:space="preserve">
          <source>Now need to create an empty &lt;code&gt;settings.gradle.kts&lt;/code&gt;&lt;code&gt;settings.gradle&lt;/code&gt; file in the project root directory.</source>
          <target state="translated">이제 프로젝트 루트 디렉토리에 빈 &lt;code&gt;settings.gradle.kts&lt;/code&gt; &lt;code&gt;settings.gradle&lt;/code&gt; 파일 을 만들어야합니다 .</target>
        </trans-unit>
        <trans-unit id="6c9080cd76ec0143ae2c7fdafc332586543b3c8a" translate="yes" xml:space="preserve">
          <source>Now the application is ready to run. The easiest way is to click the green &lt;strong&gt;Run&lt;/strong&gt; icon in the gutter and select &lt;strong&gt;Run 'AppKt'&lt;/strong&gt;.</source>
          <target state="translated">이제 응용 프로그램을 실행할 준비가되었습니다. 가장 쉬운 방법은 거터에서 녹색 &lt;strong&gt;실행&lt;/strong&gt; 아이콘 을 클릭하고 &lt;strong&gt;'AppKt'실행을&lt;/strong&gt; 선택하는 것 입니다.</target>
        </trans-unit>
        <trans-unit id="a4dea9f6780cb4b1fb116abe461c884b2fc3e6f5" translate="yes" xml:space="preserve">
          <source>Now the classic &lt;code&gt;maven-publish&lt;/code&gt; Gradle &lt;a href=&quot;https://docs.gradle.org/current/userguide/publishing_maven.html&quot;&gt;plugin&lt;/a&gt; can be used. Don't forget to specify the group and version of your library along with the plugin in &lt;code&gt;build.gradle&lt;/code&gt;:</source>
          <target state="translated">이제 고전적인 &lt;code&gt;maven-publish&lt;/code&gt; Gradle &lt;a href=&quot;https://docs.gradle.org/current/userguide/publishing_maven.html&quot;&gt;플러그인을&lt;/a&gt; 사용할 수 있습니다. &lt;code&gt;build.gradle&lt;/code&gt; 의 플러그인과 함께 라이브러리의 그룹과 버전을 지정하는 것을 잊지 마십시오 .</target>
        </trans-unit>
        <trans-unit id="c36da2f63965003675ecd4f90e9e76c88deea8db" translate="yes" xml:space="preserve">
          <source>Now the main function awaits for the first of them to complete and counts the number of deferred values that are still active. Note that we've used here the fact that &lt;code&gt;select&lt;/code&gt; expression is a Kotlin DSL, so we can provide clauses for it using an arbitrary code. In this case we iterate over a list of deferred values to provide &lt;code&gt;onAwait&lt;/code&gt; clause for each deferred value.</source>
          <target state="translated">이제 주 함수는 첫 번째 함수가 완료되기를 기다리고 여전히 활성화 된 지연된 값의 수를 계산합니다. 여기서는 &lt;code&gt;select&lt;/code&gt; 표현식이 Kotlin DSL 이라는 사실을 사용 했으므로 임의 코드를 사용하여 절을 제공 할 수 있습니다. 이 경우 지연된 값 목록을 반복 하여 각 지연된 값에 대해 &lt;code&gt;onAwait&lt;/code&gt; 절 을 제공 합니다.</target>
        </trans-unit>
        <trans-unit id="fafa6b7e1e97bd8d0310f07c3ffc916e9bc52c4e" translate="yes" xml:space="preserve">
          <source>Now the result is still the same, but the code of the main coroutine is not tied to the duration of the background job in any way. Much better.</source>
          <target state="translated">이제 결과는 여전히 동일하지만 메인 코 루틴 코드는 백그라운드 작업의 지속 시간과 관련이 없습니다. 훨씬 낫다.</target>
        </trans-unit>
        <trans-unit id="68e76914b57b2c484d2fcdeac9dacb63ea15843e" translate="yes" xml:space="preserve">
          <source>Now we are ready to &lt;a href=&quot;basic-kotlin-native-app#open-in-ide&quot;&gt;open the project in IntelliJ IDEA&lt;/a&gt; and to see how to fix the example project. While doing that, we'll examine how C functions are mapped into Kotlin/Native declarations.</source>
          <target state="translated">이제 &lt;a href=&quot;basic-kotlin-native-app#open-in-ide&quot;&gt;IntelliJ IDEA에서 프로젝트&lt;/a&gt; 를 열고 예제 프로젝트를 수정하는 방법을 볼 준비가되었습니다 . 그렇게하는 동안 C 함수가 Kotlin / Native 선언에 어떻게 매핑되는지 살펴 보겠습니다.</target>
        </trans-unit>
        <trans-unit id="0cc37329b152a7d48d832f02d3782a3273c9a922" translate="yes" xml:space="preserve">
          <source>Now we are ready to &lt;a href=&quot;basic-kotlin-native-app#open-in-ide&quot;&gt;open the project in IntelliJ IDEA&lt;/a&gt; and to see how to fix the example project. While doing that, we'll examine how C primitive types are mapped into Kotlin/Native.</source>
          <target state="translated">이제 &lt;a href=&quot;basic-kotlin-native-app#open-in-ide&quot;&gt;IntelliJ IDEA에서 프로젝트&lt;/a&gt; 를 열고 예제 프로젝트를 수정하는 방법을 볼 준비가되었습니다 . 그렇게하는 동안 C 프리미티브 유형이 Kotlin / Native에 어떻게 매핑되는지 살펴 보겠습니다.</target>
        </trans-unit>
        <trans-unit id="280651c06a20fde5cc37b475316ca2430a0a1d40" translate="yes" xml:space="preserve">
          <source>Now we are ready to &lt;a href=&quot;basic-kotlin-native-app#open-in-ide&quot;&gt;open the project in IntelliJ IDEA&lt;/a&gt; and to see how to fix the example project. While doing this, we'll examine how C functions are mapped into Kotlin/Native declarations.</source>
          <target state="translated">이제 &lt;a href=&quot;basic-kotlin-native-app#open-in-ide&quot;&gt;IntelliJ IDEA에서 프로젝트&lt;/a&gt; 를 열고 예제 프로젝트를 수정하는 방법을 볼 준비가되었습니다 . 이 과정에서 C 함수가 Kotlin / 네이티브 선언에 어떻게 매핑되는지 살펴 보겠습니다.</target>
        </trans-unit>
        <trans-unit id="8514872c5f66d71d839c86ef7b8ede3a7f8b037f" translate="yes" xml:space="preserve">
          <source>Now we are ready to compile our &lt;code&gt;main.c&lt;/code&gt; into an executable. We include the generated &lt;code&gt;libnative.lib&lt;/code&gt; into the build command and start:</source>
          <target state="translated">이제 &lt;code&gt;main.c&lt;/code&gt; 를 실행 파일로 컴파일 할 준비가되었습니다 . 생성 된 &lt;code&gt;libnative.lib&lt;/code&gt; 를 빌드 명령에 포함시키고 시작합니다 :</target>
        </trans-unit>
        <trans-unit id="bd615a740472938a27e61f3e5ad1d8c088398a62" translate="yes" xml:space="preserve">
          <source>Now we build our pipeline by starting a stream of numbers from 2, taking a prime number from the current channel, and launching new pipeline stage for each prime number found:</source>
          <target state="translated">이제 2에서 숫자 스트림을 시작하고 현재 채널에서 소수를 취하고 발견 된 각 소수에 대해 새로운 파이프 라인 단계를 시작하여 파이프 라인을 빌드합니다.</target>
        </trans-unit>
        <trans-unit id="b09d5a8ac24e62ac515e5408d015b6449705f5ff" translate="yes" xml:space="preserve">
          <source>Now we have implementations on all the platforms and it is time to move to testing of our library.</source>
          <target state="translated">이제 모든 플랫폼에서 구현되었으며 라이브러리 테스트로 넘어갈 차례입니다.</target>
        </trans-unit>
        <trans-unit id="6fc43d604b99f2dfefc014ae5ff71405690d454a" translate="yes" xml:space="preserve">
          <source>Now we have learned how to use C declarations in our code, we are ready to try it out on a real example. Let's fix our code and see how it runs by calling the &lt;code&gt;runDebugExecutableNative&lt;/code&gt; Gradle task &lt;a href=&quot;basic-kotlin-native-app#run-in-ide&quot;&gt;in the IDE&lt;/a&gt; or by using the following console command:</source>
          <target state="translated">이제 코드에서 C 선언을 사용하는 방법을 배웠으므로 실제 예제에서이를 사용할 수 있습니다. &lt;a href=&quot;basic-kotlin-native-app#run-in-ide&quot;&gt;IDE에서 &lt;/a&gt; &lt;code&gt;runDebugExecutableNative&lt;/code&gt; Gradle 태스크 를 호출 하거나 다음 콘솔 명령을 사용하여 코드를 수정하고 실행 방법을 살펴 보겠습니다 .</target>
        </trans-unit>
        <trans-unit id="dcdaca8bf7117a3b069ebd97d9d500bbee893084" translate="yes" xml:space="preserve">
          <source>Now we have our library and Kotlin stubs, we can consume them from our application. To keep things simple, in this tutorial we're going to convert one of the simplest &lt;code&gt;libcurl&lt;/code&gt; examples over to Kotlin.</source>
          <target state="translated">이제 라이브러리와 Kotlin 스텁이 있으며 응용 프로그램에서 사용할 수 있습니다. 일을 단순하게 유지하기 위해이 튜토리얼에서는 가장 간단한 &lt;code&gt;libcurl&lt;/code&gt; 예제 중 하나 를 Kotlin 으로 변환 합니다.</target>
        </trans-unit>
        <trans-unit id="56a410308bdaa182b925a6dff7fc3ba66711f037" translate="yes" xml:space="preserve">
          <source>Now we have the &lt;code&gt;TextView&lt;/code&gt; that will show us the text created by the shared code function &lt;code&gt;createApplicationScreenMessage()&lt;/code&gt;. It shows &lt;code&gt;Kotlin Rocks on Android&lt;/code&gt;. Let's see how it works.</source>
          <target state="translated">이제 공유 코드 함수 &lt;code&gt;createApplicationScreenMessage()&lt;/code&gt; 작성된 텍스트를 표시 하는 &lt;code&gt;TextView&lt;/code&gt; 가 있습니다 . &lt;code&gt;Kotlin Rocks on Android&lt;/code&gt; 보여줍니다 . 그것이 어떻게 작동하는지 봅시다.</target>
        </trans-unit>
        <trans-unit id="ff70a609caee6a29932d7e21240cf4b92c28370c" translate="yes" xml:space="preserve">
          <source>Now we need to define the classes and interfaces we want to implement. Create the file &lt;code&gt;Base64.kt&lt;/code&gt; in the &lt;code&gt;commonMain/kotlin/jetbrains/base64&lt;/code&gt; folder. Core primitive will be the &lt;code&gt;Base64Encoder&lt;/code&gt; interface which knows how to convert bytes to bytes in &lt;code&gt;Base64&lt;/code&gt; format:</source>
          <target state="translated">이제 구현하려는 클래스와 인터페이스를 정의해야합니다. 파일 만들기 &lt;code&gt;Base64.kt&lt;/code&gt; 에서 &lt;code&gt;commonMain/kotlin/jetbrains/base64&lt;/code&gt; 폴더를. 핵심 프리미티브는 &lt;code&gt;Base64&lt;/code&gt; 형식의 바이트를 바이트로 변환하는 방법을 알고 있는 &lt;code&gt;Base64Encoder&lt;/code&gt; 인터페이스 입니다.</target>
        </trans-unit>
        <trans-unit id="6ca6511b451c4bb08b2161576b6d00b309bd636f" translate="yes" xml:space="preserve">
          <source>Now we need to explain to Xcode, where to look for frameworks. We need to add the &lt;em&gt;relative&lt;/em&gt; path &lt;code&gt;$(SRCROOT)/../../SharedCode/build/xcode-frameworks&lt;/code&gt; into the &lt;em&gt;Search Paths | Framework Search Paths&lt;/em&gt; section. Open the &lt;em&gt;Build Settings&lt;/em&gt; tab again, pick the &lt;em&gt;All&lt;/em&gt; sub-tab below, and type the &lt;em&gt;Framework Search Paths&lt;/em&gt; into the search field to easily find the option. Xcode will then show the substituted path in the UI for it.</source>
          <target state="translated">이제 Xcode에 프레임 워크를 찾을 위치를 설명해야합니다. 우리는 추가 할 필요가 &lt;em&gt;상대&lt;/em&gt; 경로 &lt;code&gt;$(SRCROOT)/../../SharedCode/build/xcode-frameworks&lt;/code&gt; 에 &lt;em&gt;검색 경로 | 프레임 워크 검색 경로&lt;/em&gt; 섹션. &lt;em&gt;빌드 설정&lt;/em&gt; 탭을 다시 열고 아래 의 &lt;em&gt;모두&lt;/em&gt; 하위 탭 을 선택한 다음 검색 필드에 &lt;em&gt;프레임 워크 검색 경로&lt;/em&gt; 를 입력 하여 옵션을 쉽게 찾으십시오. 그러면 Xcode는 UI에 대체 경로를 표시합니다.</target>
        </trans-unit>
        <trans-unit id="bbdba5d4735168e3785e68f7843040b781bf6309" translate="yes" xml:space="preserve">
          <source>Now when we call &lt;code&gt;workload()&lt;/code&gt; from a coroutine, the compiler knows that it may suspend and will prepare accordingly:</source>
          <target state="translated">이제 코 루틴에서 &lt;code&gt;workload()&lt;/code&gt; 를 호출 하면 컴파일러는 중단 될 수 있음을 알고 다음에 따라 준비합니다.</target>
        </trans-unit>
        <trans-unit id="1d24cd9e38cbefb079dd50a49d7d7f03311c7bf3" translate="yes" xml:space="preserve">
          <source>Now you are ready to create a new Kotlin project.</source>
          <target state="translated">이제 새로운 Kotlin 프로젝트를 만들 준비가되었습니다.</target>
        </trans-unit>
        <trans-unit id="290dbe288d985515eeabffa880759f9b6702dbd0" translate="yes" xml:space="preserve">
          <source>Now you can declare a dependency on a Kotlin/Native library in the traditional &lt;code&gt;group:artifact:version&lt;/code&gt; notation:</source>
          <target state="translated">이제 전통적인 &lt;code&gt;group:artifact:version&lt;/code&gt; 표기법 으로 Kotlin / Native 라이브러리에 대한 종속성을 선언 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="21f7ffde9424834101062b3a3b4388e5becd0386" translate="yes" xml:space="preserve">
          <source>Now you can publish the artifacts with the standard Gradle &lt;code&gt;publish&lt;/code&gt; task:</source>
          <target state="translated">이제 표준 Gradle &lt;code&gt;publish&lt;/code&gt; 작업으로 이슈를 게시 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="1f0e0a97af9c78bc7052cbc7558b0c5721564a3e" translate="yes" xml:space="preserve">
          <source>Now you can use this class from JavaScript in the following way:</source>
          <target state="translated">이제 JavaScript에서이 클래스를 다음과 같은 방식으로 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d5043215278e17616ae1356fe9712ab2361ec4d2" translate="yes" xml:space="preserve">
          <source>Now you have the new project created with the following folder structure:</source>
          <target state="translated">이제 다음 폴더 구조로 새 프로젝트를 작성했습니다.</target>
        </trans-unit>
        <trans-unit id="3e24bac49840414b90995c5cbd33ee7b86539a1d" translate="yes" xml:space="preserve">
          <source>Now you're ready to start learning. Read the first task description and the exercise code. You will find a placeholder in the exercise code which you need to complete to solve the task:</source>
          <target state="translated">이제 학습을 시작할 준비가되었습니다. 첫 번째 작업 설명과 운동 코드를 읽으십시오. 작업 코드에서 작업을 수행하기 위해 완료해야하는 자리 표시자를 찾을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5cb44051b734fae4af55ffe5224978dec7c87251" translate="yes" xml:space="preserve">
          <source>Now, &lt;code&gt;callStatic()&lt;/code&gt; is static in Java, while &lt;code&gt;callNonStatic()&lt;/code&gt; is not:</source>
          <target state="translated">이제 &lt;code&gt;callStatic()&lt;/code&gt; 은 Java에서 정적이며 &lt;code&gt;callNonStatic()&lt;/code&gt; 은 그렇지 않습니다.</target>
        </trans-unit>
        <trans-unit id="a13d0fb128d24db7d3bb5f2f36926ba1c128f4f2" translate="yes" xml:space="preserve">
          <source>Now, &lt;em&gt;this&lt;/em&gt; can be omitted, as usual, and we get something that looks very much like a builder already:</source>
          <target state="translated">이제 &lt;em&gt;이는&lt;/em&gt; 평소와 같이, 생략, 우리는 뭔가를 얻을 수 매우 이미 빌더과 같다 :</target>
        </trans-unit>
        <trans-unit id="f0a82c0a40d22072db820930c190224b73ea978f" translate="yes" xml:space="preserve">
          <source>Now, all is left is to write the main function that reads the input and implements the rest of the algorithm that the problem statement asks for &amp;mdash; to compute the number of different integers that are produced while repeatedly applying function &lt;code&gt;f&lt;/code&gt; to the initial number &lt;code&gt;n&lt;/code&gt; that is given in the standard input.</source>
          <target state="translated">반복 함수 적용하는 동안 생성되는 다른 정수 숫자 계산하기 - 이제 남은 모든 입력 및 구현을 문제 문을 요청하는 알고리즘의 나머지 판독 메인 함수 작성한다 &lt;code&gt;f&lt;/code&gt; 초기 개수 &lt;code&gt;n&lt;/code&gt; 그 표준 입력으로 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="fb6047e18f4bc8d11bc30e4fd65fb8d503da1662" translate="yes" xml:space="preserve">
          <source>Now, if you call a method or access a property on &lt;code&gt;a&lt;/code&gt;, it's guaranteed not to cause an NPE, so you can safely say:</source>
          <target state="translated">당신이 방법 또는 액세스에게의 속성 호출하는 경우 이제 &lt;code&gt;a&lt;/code&gt; 안전하게 말할 수 있도록, NPE의 원인이 될 수 보장된다 :</target>
        </trans-unit>
        <trans-unit id="20f3d5cd33eec60a8a8002b141a9b28a6b9b7682" translate="yes" xml:space="preserve">
          <source>Now, if you do:</source>
          <target state="translated">지금, 당신이 할 경우 :</target>
        </trans-unit>
        <trans-unit id="f71ccd18f05da02b03c8a2c32b3e5cdf31e2366b" translate="yes" xml:space="preserve">
          <source>Now, if you open DevTools, you should see both JavaScript and Kotlin files in Sources tab, as shown in the picture below.</source>
          <target state="translated">이제 DevTools를 열면 아래 그림과 같이 소스 탭에 JavaScript 및 Kotlin 파일이 모두 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="a83d9e77f9456d18d8a05fd327f1e236de7060bd" translate="yes" xml:space="preserve">
          <source>Now, if you rebuild the project, you should see both &lt;code&gt;.js&lt;/code&gt; and &lt;code&gt;.js.map&lt;/code&gt; files generated.</source>
          <target state="translated">이제 프로젝트를 다시 빌드하면 &lt;code&gt;.js&lt;/code&gt; 및 &lt;code&gt;.js.map&lt;/code&gt; 파일이 모두 생성됩니다.</target>
        </trans-unit>
        <trans-unit id="76f6cc5aafdabd68e55d4250b74b32cd977c308a" translate="yes" xml:space="preserve">
          <source>Now, it returns only from the lambda expression. Oftentimes it is more convenient to use implicit labels: such a label has the same name as the function to which the lambda is passed.</source>
          <target state="translated">이제 람다 식에서 만 반환됩니다. 암시 적 레이블을 사용하는 것이 더 편리한 경우가 종종 있습니다. 이러한 레이블은 람다가 전달되는 함수와 이름이 같습니다.</target>
        </trans-unit>
        <trans-unit id="94f815aeffcc5ac17241b513b6e20a9f1cdaea31" translate="yes" xml:space="preserve">
          <source>Now, let us see what happens if we launch a couple of coroutines sending strings (in this example we launch them in the context of the main thread as main coroutine's children):</source>
          <target state="translated">이제 문자열을 보내는 두 개의 코 루틴을 시작하면 어떻게되는지 살펴 보자 (이 예에서는 메인 스레드의 컨텍스트에서 메인 코 루틴의 자식으로 시작 함).</target>
        </trans-unit>
        <trans-unit id="71d025254fd20926043d356611276f9c88403338" translate="yes" xml:space="preserve">
          <source>Now, let's make sure that coroutines are really cheaper than threads. How about starting a million of them? Let's try starting a million threads first:</source>
          <target state="translated">이제 코 루틴이 스레드보다 실제로 저렴하다는 것을 확인하십시오. 백만 개를 시작하는 것은 어떻습니까? 먼저 백만 개의 스레드를 시작해 봅시다.</target>
        </trans-unit>
        <trans-unit id="16dd7a2ec4c182b0f69f31fe9543eb28189fc230" translate="yes" xml:space="preserve">
          <source>Now, let's recall why we can say something like this in the code:</source>
          <target state="translated">이제 코드에서 이와 같이 말할 수있는 이유를 생각해 봅시다.</target>
        </trans-unit>
        <trans-unit id="544d487017d11ee4001cb80b112987fd1c122959" translate="yes" xml:space="preserve">
          <source>Now, let's say we want to extract our &lt;em&gt;workload&lt;/em&gt; (which is &quot;wait 1 second and return a number&quot;) into a separate function:</source>
          <target state="translated">이제 &lt;em&gt;워크로드&lt;/em&gt; ( &quot;1 초 기다렸다가 숫자 반환&quot;)를 별도의 함수 로 추출한다고 가정 해 보겠습니다 .</target>
        </trans-unit>
        <trans-unit id="c750281f584acadba2af58cffcc8c1305b106c0d" translate="yes" xml:space="preserve">
          <source>Now, the type parameter of &lt;code&gt;to&lt;/code&gt; must be a supertype of that of &lt;code&gt;from&lt;/code&gt;. This time, we're losing the ability to call &lt;code&gt;get()&lt;/code&gt; on &lt;code&gt;to&lt;/code&gt;.</source>
          <target state="translated">이제 &lt;code&gt;to&lt;/code&gt; 의 유형 매개 변수 는 &lt;code&gt;from&lt;/code&gt; 의 유형 매개 변수 여야합니다 . 이 시간, 우리는 호출 할 수있는 기능 잃고 &lt;code&gt;get()&lt;/code&gt; 에 &lt;code&gt;to&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="841ea7e84248eb13447bb49e5c5c6dbc24123f33" translate="yes" xml:space="preserve">
          <source>Now, we can launch coroutines in the scope of this &lt;code&gt;Activity&lt;/code&gt; without having to explicitly specify their context. For the demo, we launch ten coroutines that delay for a different time:</source>
          <target state="translated">이제 컨텍스트를 명시 적으로 지정하지 않고도이 &lt;code&gt;Activity&lt;/code&gt; 범위에서 코 루틴을 시작할 수 있습니다 . 데모를 위해 다른 시간 동안 지연되는 10 개의 코 루틴을 시작합니다.</target>
        </trans-unit>
        <trans-unit id="b7b794f9844126d9635b31ec7a7259faff61ea34" translate="yes" xml:space="preserve">
          <source>Now, we can qualify a &lt;em&gt;break&lt;/em&gt; or a &lt;em&gt;continue&lt;/em&gt; with a label:</source>
          <target state="translated">이제 레이블을 사용하여 &lt;em&gt;휴식을 취&lt;/em&gt; 하거나 &lt;em&gt;계속할&lt;/em&gt; 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="4009ace22d0b31f5461708301ff321a7b41e34f1" translate="yes" xml:space="preserve">
          <source>Now, we need to create the implementation file (and missing directories) for Android in the &lt;code&gt;SharedCode/src/androidMain/kotlin/actual.kt&lt;/code&gt;:</source>
          <target state="translated">이제 &lt;code&gt;SharedCode/src/androidMain/kotlin/actual.kt&lt;/code&gt; 에서 Android 용 구현 파일 (및 누락 된 디렉토리)을 만들어야합니다 .</target>
        </trans-unit>
        <trans-unit id="cc32792e1ffb6994d09d3ccc5850fcde297ab5b1" translate="yes" xml:space="preserve">
          <source>Now, whenever anyone reads &lt;code&gt;p.name&lt;/code&gt;, &lt;code&gt;getValue()&lt;/code&gt; will be invoked with &lt;code&gt;p&lt;/code&gt; as &lt;code&gt;thisRef&lt;/code&gt; and metadata about the &lt;code&gt;name&lt;/code&gt; property as &lt;code&gt;property&lt;/code&gt;. Since &lt;code&gt;thisRef&lt;/code&gt; is a &lt;code&gt;DbModel&lt;/code&gt;, this delegated property can only be used inside &lt;code&gt;DbModel&lt;/code&gt; and its subclasses.</source>
          <target state="translated">사람이 읽을 때마다 지금 &lt;code&gt;p.name&lt;/code&gt; , &lt;code&gt;getValue()&lt;/code&gt; 호출한다 &lt;code&gt;p&lt;/code&gt; 로 &lt;code&gt;thisRef&lt;/code&gt; [정보와 메타 데이터 &lt;code&gt;name&lt;/code&gt; 과 재산 &lt;code&gt;property&lt;/code&gt; . 이후 &lt;code&gt;thisRef&lt;/code&gt; 는 A는 &lt;code&gt;DbModel&lt;/code&gt; 이 위임 속성은 내부에 사용될 수있다 &lt;code&gt;DbModel&lt;/code&gt; 와 그 서브.</target>
        </trans-unit>
        <trans-unit id="1ddfae4b18596b2854071f83733087767ffb2d01" translate="yes" xml:space="preserve">
          <source>Now, you can do:</source>
          <target state="translated">이제 할 수있는 일 :</target>
        </trans-unit>
        <trans-unit id="c62d757ce7f75d3f121e4c4fec1867b7958bd009" translate="yes" xml:space="preserve">
          <source>Now, you can no longer say &lt;code&gt;val mv = MotorVehicle(100, 4)&lt;/code&gt;.</source>
          <target state="translated">이제 더 이상 &lt;code&gt;val mv = MotorVehicle(100, 4)&lt;/code&gt; 라고 말할 수 없습니다 .</target>
        </trans-unit>
        <trans-unit id="6c97d282b328adc12f3e5a556471451c0554c8b2" translate="yes" xml:space="preserve">
          <source>Now, you can say &lt;code&gt;loadFromDb&amp;lt;Exercise&amp;gt;(&quot;x01234567&quot;)&lt;/code&gt; to load an object from the &lt;code&gt;Exercise&lt;/code&gt; database table.</source>
          <target state="translated">이제 &lt;code&gt;loadFromDb&amp;lt;Exercise&amp;gt;(&quot;x01234567&quot;)&lt;/code&gt; &lt;code&gt;Exercise&lt;/code&gt; 데이터베이스 테이블 에서 객체를로드 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="93baa80c955acf188a4912f62d9bfabe1e89cde4" translate="yes" xml:space="preserve">
          <source>Now, you can treat a bowl of &lt;code&gt;T&lt;/code&gt; as a producer of any superclass of &lt;code&gt;T&lt;/code&gt;, and as a consumer of any subclass of &lt;code&gt;T&lt;/code&gt;:</source>
          <target state="translated">지금, 당신은 한 그릇에 처리 할 수 &lt;code&gt;T&lt;/code&gt; 을 의 슈퍼 클래스의 프로듀서로 &lt;code&gt;T&lt;/code&gt; , 그리고 하위 클래스의 소비자로 &lt;code&gt;T&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="cb06774e37de315de0f5603f0b4fd0176b0b42a0" translate="yes" xml:space="preserve">
          <source>Now, you may not create a &lt;code&gt;TreeNode&lt;/code&gt; of a type that is not a subclass/implementor of &lt;code&gt;Vehicle&lt;/code&gt;. Inside the class, whenever you've got a value of type &lt;code&gt;T&lt;/code&gt;, you may access all the public members of &lt;code&gt;Vehicle&lt;/code&gt; on it.</source>
          <target state="translated">이제 &lt;code&gt;Vehicle&lt;/code&gt; 의 서브 클래스 / 구현자가 아닌 유형 의 &lt;code&gt;TreeNode&lt;/code&gt; 를 만들 수 없습니다 . 수업 내에서 &lt;code&gt;T&lt;/code&gt; 유형의 값을 얻을 때마다 &lt;code&gt;Vehicle&lt;/code&gt; 의 모든 공개 멤버에 액세스 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="e66b62de2c45ca7a1dafaa470efed27db40c8abf" translate="yes" xml:space="preserve">
          <source>Null Safety</source>
          <target state="translated">널 안전</target>
        </trans-unit>
        <trans-unit id="961437d22902a2f7dfd53365cc313f4a8b919ec9" translate="yes" xml:space="preserve">
          <source>Null references are &lt;a href=&quot;null-safety&quot;&gt;controlled by the type system&lt;/a&gt;.</source>
          <target state="translated">널 참조는 &lt;a href=&quot;null-safety&quot;&gt;유형 시스템에 의해 제어됩니다&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="a2b2542f64eaa222fbfda6a1a4f6d0850cf59a88" translate="yes" xml:space="preserve">
          <source>Null safety</source>
          <target state="translated">널 안전</target>
        </trans-unit>
        <trans-unit id="39f94d225bc04bec959b32c61b7c0b099f1b3de4" translate="yes" xml:space="preserve">
          <source>Null safety is enforced as usual, so a variable of type &lt;code&gt;ContentKind&lt;/code&gt; can not be null, unlike in Java.</source>
          <target state="translated">Null 안전은 평소처럼 적용되므로 Java와 달리 &lt;code&gt;ContentKind&lt;/code&gt; 유형의 변수는 null 일 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="c768f27b8cd368aac53b3bf7b3466119f4aeaaad" translate="yes" xml:space="preserve">
          <source>Null-Safety and Platform Types</source>
          <target state="translated">널 안전 및 플랫폼 유형</target>
        </trans-unit>
        <trans-unit id="7b2e605360643dd896eff359d1535b4e4db34c3d" translate="yes" xml:space="preserve">
          <source>Null-safety</source>
          <target state="translated">Null-safety</target>
        </trans-unit>
        <trans-unit id="e96a81e5fc6aa1615fc78a379fdad68b748bc26c" translate="yes" xml:space="preserve">
          <source>NullPointerException</source>
          <target state="translated">NullPointerException</target>
        </trans-unit>
        <trans-unit id="7cfd44db910fd8b20253bc74265b31aeaf45384c" translate="yes" xml:space="preserve">
          <source>Nullability</source>
          <target state="translated">Nullability</target>
        </trans-unit>
        <trans-unit id="13c99d5e49300b52aefe21f12764921df1d1f93f" translate="yes" xml:space="preserve">
          <source>Nullability annotations</source>
          <target state="translated">무효 성 주석</target>
        </trans-unit>
        <trans-unit id="e5e6784edcd14305d294e06ecb03d642a0a57873" translate="yes" xml:space="preserve">
          <source>Nullability assertions on access to Java types annotated with &lt;code&gt;@NotNull&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;@NotNull&lt;/code&gt; 로 주석이 달린 Java 유형에 액세스 할 때 Nullability 어설 션</target>
        </trans-unit>
        <trans-unit id="1e5389deab4b42bc503c62cbba549bbb26b00be1" translate="yes" xml:space="preserve">
          <source>Nullable Receiver</source>
          <target state="translated">널 입력 가능 수신기</target>
        </trans-unit>
        <trans-unit id="ea692fde5fad8fec43d27ab3923928d9c3e4f762" translate="yes" xml:space="preserve">
          <source>Nullable types and Non-Null Types</source>
          <target state="translated">널 입력 가능 유형 및 널이 아닌 유형</target>
        </trans-unit>
        <trans-unit id="b7baa1d40c4ea29afc9098732bffee2a861a6c44" translate="yes" xml:space="preserve">
          <source>Number</source>
          <target state="translated">Number</target>
        </trans-unit>
        <trans-unit id="2e1ee95668fd5f69d1925d4acd4d52b859469b82" translate="yes" xml:space="preserve">
          <source>NumberFormatException</source>
          <target state="translated">NumberFormatException</target>
        </trans-unit>
        <trans-unit id="7e53821f70ae16079c4a6a64c52a91fae645bc5f" translate="yes" xml:space="preserve">
          <source>Numbers</source>
          <target state="translated">Numbers</target>
        </trans-unit>
        <trans-unit id="b7b3deb2440db7b27508e61ad6b6526ba91d78a1" translate="yes" xml:space="preserve">
          <source>Numbers are compared with the ends of this range according to IEEE-754.</source>
          <target state="translated">IEEE-754에 따라이 범위의 끝과 숫자를 비교합니다.</target>
        </trans-unit>
        <trans-unit id="b1c2afbaeee52797fa3a437d9c480e4a05cf0193" translate="yes" xml:space="preserve">
          <source>Numeric types use the traditional numerical order: &lt;code&gt;1&lt;/code&gt; is greater than &lt;code&gt;0&lt;/code&gt;; &lt;code&gt;-3.4f&lt;/code&gt; is greater than &lt;code&gt;-5f&lt;/code&gt;, an so on.</source>
          <target state="translated">숫자 유형은 전통적인 숫자 순서를 사용합니다. &lt;code&gt;1&lt;/code&gt; 은 &lt;code&gt;0&lt;/code&gt; 보다 큽니다 . &lt;code&gt;-3.4f&lt;/code&gt; 는 -5f 보다 &lt;code&gt;-5f&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="132a0e722f57154d901e124e4cb8e8bc570f7174" translate="yes" xml:space="preserve">
          <source>Numerous use cases are covered by just the default source sets and don't require custom source sets.</source>
          <target state="translated">수많은 유스 케이스는 기본 소스 세트 만 다루며 사용자 정의 소스 세트가 필요하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="f5bd86a2929ff840c45d76159d984c1239906a9d" translate="yes" xml:space="preserve">
          <source>OSGi</source>
          <target state="translated">OSGi</target>
        </trans-unit>
        <trans-unit id="802bfbdcec1e0873ee0e4b3f43f68d3022244543" translate="yes" xml:space="preserve">
          <source>OTHER_LETTER</source>
          <target state="translated">OTHER_LETTER</target>
        </trans-unit>
        <trans-unit id="c526c1a55d3a7d1197fc54064f8aa775a085df54" translate="yes" xml:space="preserve">
          <source>OTHER_NEUTRALS</source>
          <target state="translated">OTHER_NEUTRALS</target>
        </trans-unit>
        <trans-unit id="0528be3a553ee55304545e3df532c16619f9a75f" translate="yes" xml:space="preserve">
          <source>OTHER_NUMBER</source>
          <target state="translated">OTHER_NUMBER</target>
        </trans-unit>
        <trans-unit id="a79f18b5ad7c3bc6ad0e1685c0b9f1d91e9ea75c" translate="yes" xml:space="preserve">
          <source>OTHER_PUNCTUATION</source>
          <target state="translated">OTHER_PUNCTUATION</target>
        </trans-unit>
        <trans-unit id="5dcd7535199ae15a813d866ef04e762cfaa07f6c" translate="yes" xml:space="preserve">
          <source>OTHER_SYMBOL</source>
          <target state="translated">OTHER_SYMBOL</target>
        </trans-unit>
        <trans-unit id="5d84eb9e92dc661a577d3adfba33f1d74c56b13f" translate="yes" xml:space="preserve">
          <source>OUT</source>
          <target state="translated">OUT</target>
        </trans-unit>
        <trans-unit id="91920f1b8433472c27ea07aeaf636cc60ba181dc" translate="yes" xml:space="preserve">
          <source>ObjCAction</source>
          <target state="translated">ObjCAction</target>
        </trans-unit>
        <trans-unit id="e75d1b861d64404390b1044e805e449a8200ca83" translate="yes" xml:space="preserve">
          <source>ObjCBlockVar</source>
          <target state="translated">ObjCBlockVar</target>
        </trans-unit>
        <trans-unit id="e9af1c5fc6d5face32a12e24e19f7721bddde5b0" translate="yes" xml:space="preserve">
          <source>ObjCClass</source>
          <target state="translated">ObjCClass</target>
        </trans-unit>
        <trans-unit id="f25e8c7f51c9fbd76d5d3f0065c1777ea9957679" translate="yes" xml:space="preserve">
          <source>ObjCClassOf</source>
          <target state="translated">ObjCClassOf</target>
        </trans-unit>
        <trans-unit id="f6a51cb987439b8eee022689cce7766c56796d55" translate="yes" xml:space="preserve">
          <source>ObjCConstructor</source>
          <target state="translated">ObjCConstructor</target>
        </trans-unit>
        <trans-unit id="174b16a8130fefe11ed27381abeeb2de5f620114" translate="yes" xml:space="preserve">
          <source>ObjCFactory</source>
          <target state="translated">ObjCFactory</target>
        </trans-unit>
        <trans-unit id="b26295bcadcc4d23542076fe5cb26969093b0b48" translate="yes" xml:space="preserve">
          <source>ObjCMethod</source>
          <target state="translated">ObjCMethod</target>
        </trans-unit>
        <trans-unit id="07d9267ddaf9a5ade080cb2ba3e61a2c1db5834c" translate="yes" xml:space="preserve">
          <source>ObjCNotImplementedVar</source>
          <target state="translated">ObjCNotImplementedVar</target>
        </trans-unit>
        <trans-unit id="88fce822e198e83b3ad7f5c732a4ec9995f176b3" translate="yes" xml:space="preserve">
          <source>ObjCObject</source>
          <target state="translated">ObjCObject</target>
        </trans-unit>
        <trans-unit id="c3946e9e7a5b7a873393f4068d626ccc17017e1d" translate="yes" xml:space="preserve">
          <source>ObjCObjectBase</source>
          <target state="translated">ObjCObjectBase</target>
        </trans-unit>
        <trans-unit id="f2b935ffe4e074cda5d9854c568bff792bd27525" translate="yes" xml:space="preserve">
          <source>ObjCObjectBaseMeta</source>
          <target state="translated">ObjCObjectBaseMeta</target>
        </trans-unit>
        <trans-unit id="968b48c24c631a6e3656fa344166e2e696dac30a" translate="yes" xml:space="preserve">
          <source>ObjCObjectMeta</source>
          <target state="translated">ObjCObjectMeta</target>
        </trans-unit>
        <trans-unit id="877c2fba97f85ebcbe0815d3dd7f9aa9abf27eb2" translate="yes" xml:space="preserve">
          <source>ObjCObjectVar</source>
          <target state="translated">ObjCObjectVar</target>
        </trans-unit>
        <trans-unit id="380d9e7d32a5ea9a8f4a45d77367a2bd6224641f" translate="yes" xml:space="preserve">
          <source>ObjCOutlet</source>
          <target state="translated">ObjCOutlet</target>
        </trans-unit>
        <trans-unit id="7ddeec08c37b0e1684597f07f64a856e9d5996d5" translate="yes" xml:space="preserve">
          <source>ObjCStringVarOf</source>
          <target state="translated">ObjCStringVarOf</target>
        </trans-unit>
        <trans-unit id="2883f191bc5ebfdc16c0813eff659b35363ea69b" translate="yes" xml:space="preserve">
          <source>Object</source>
          <target state="translated">Object</target>
        </trans-unit>
        <trans-unit id="9cf5c3411eb513b108884e51c19ba17172ea9665" translate="yes" xml:space="preserve">
          <source>Object Declarations</source>
          <target state="translated">객체 선언</target>
        </trans-unit>
        <trans-unit id="7c97f9bd791112ffa2e31c34e5efe261bd493bd5" translate="yes" xml:space="preserve">
          <source>Object Expressions and Declarations</source>
          <target state="translated">객체 표현과 선언</target>
        </trans-unit>
        <trans-unit id="f0e2a5cc2614159a14f8d24f77aff8cedbb91395" translate="yes" xml:space="preserve">
          <source>Object Methods</source>
          <target state="translated">객체 방법</target>
        </trans-unit>
        <trans-unit id="da5029a017fab6364fe3776821fcb6e385dc5dee" translate="yes" xml:space="preserve">
          <source>Object Transfer Basics.</source>
          <target state="translated">객체 전송 기본.</target>
        </trans-unit>
        <trans-unit id="720b937cd9168a2afdad295cde0f6e29e57ba3f8" translate="yes" xml:space="preserve">
          <source>Object configuration and computing the result: &lt;code&gt;run&lt;/code&gt;</source>
          <target state="translated">객체 구성 및 결과 계산 : &lt;code&gt;run&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="1602dbe04f927f110613a2ff025fac15d0ab85e1" translate="yes" xml:space="preserve">
          <source>Object configuration: &lt;code&gt;apply&lt;/code&gt;</source>
          <target state="translated">객체 구성 : &lt;code&gt;apply&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="a447624065dc9ff0a50d2837d5bc597740342d7d" translate="yes" xml:space="preserve">
          <source>Object declaration's initialization is thread-safe.</source>
          <target state="translated">객체 선언의 초기화는 스레드로부터 안전합니다.</target>
        </trans-unit>
        <trans-unit id="628c7c8804cdd6233ca4db93a682c55cf0920e38" translate="yes" xml:space="preserve">
          <source>Object declarations</source>
          <target state="translated">객체 선언</target>
        </trans-unit>
        <trans-unit id="cae8f3bd29605b55880171db0511493e6eb7c132" translate="yes" xml:space="preserve">
          <source>Object describing the current platform program executes upon.</source>
          <target state="translated">현재 플랫폼 프로그램을 설명하는 객체가 실행됩니다.</target>
        </trans-unit>
        <trans-unit id="652916453e90e519555e6ab21189e4862e16ddc5" translate="yes" xml:space="preserve">
          <source>Object expressions</source>
          <target state="translated">객체 표현</target>
        </trans-unit>
        <trans-unit id="a5005a7247de5e6b7399fc2c0fe58f85332088cd" translate="yes" xml:space="preserve">
          <source>Object pinning</source>
          <target state="translated">객체 고정</target>
        </trans-unit>
        <trans-unit id="bd34180a1517f8541977dbe1575129ec09ee4ed0" translate="yes" xml:space="preserve">
          <source>Object reference</source>
          <target state="translated">객체 참조</target>
        </trans-unit>
        <trans-unit id="c74457d6502afea678cde0191acb0c28174b3019" translate="yes" xml:space="preserve">
          <source>Object subgraph detachment</source>
          <target state="translated">객체 서브 그래프 분리</target>
        </trans-unit>
        <trans-unit id="9e612181ece96085e9c01a6c4c75420948e3db15" translate="yes" xml:space="preserve">
          <source>Object subgraph freezing</source>
          <target state="translated">객체 서브 그래프 동결</target>
        </trans-unit>
        <trans-unit id="f714255fe9b4b0abd289766d10b307beefd8bdca" translate="yes" xml:space="preserve">
          <source>Object subgraph ownership transfer</source>
          <target state="translated">오브젝트 서브 그래프 소유권 이전</target>
        </trans-unit>
        <trans-unit id="f7e1ff28ab70fc23071798b8c0343f8a27fa8277" translate="yes" xml:space="preserve">
          <source>Object transfer and freezing</source>
          <target state="translated">물체 이동 및 동결</target>
        </trans-unit>
        <trans-unit id="9cf4af30df052d80876381f9ec0e05811ecd3d08" translate="yes" xml:space="preserve">
          <source>Objective-C</source>
          <target state="translated">Objective-C</target>
        </trans-unit>
        <trans-unit id="f624b8a4ac060c545ced78fe5b569d299005d811" translate="yes" xml:space="preserve">
          <source>Objective-C allows generics to be declared covariant or contravariant. Swift has no support for variance. Generic classes coming from Objective-C can be force-cast as needed.</source>
          <target state="translated">Objective-C를 사용하면 제네릭을 공변량 또는 공변량으로 선언 할 수 있습니다. 스위프트는 분산을 지원하지 않습니다. Objective-C에서 제공되는 일반 클래스는 필요에 따라 강제 전송 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c34ace6f5a2b6e2147c689be6867500eabe88ca9" translate="yes" xml:space="preserve">
          <source>Objective-C and Swift use reference counting. Kotlin/Native has its own garbage collection too. Kotlin/Native garbage collection is integrated with Objective-C/Swift reference counting. We do not need to use anything special to control the lifetime of Kotlin/Native instances from Swift or Objective-C.</source>
          <target state="translated">Objective-C 및 Swift는 참조 계산을 사용합니다. Kotlin / Native에는 자체 가비지 콜렉션도 있습니다. Kotlin / Native 가비지 콜렉션은 Objective-C / Swift 참조 계산과 통합됩니다. Swift 또는 Objective-C에서 Kotlin / Native 인스턴스의 수명을 제어하기 위해 특별한 것을 사용할 필요는 없습니다.</target>
        </trans-unit>
        <trans-unit id="42d9bdb0193a26ed15d57450ee6f73bec2393ce7" translate="yes" xml:space="preserve">
          <source>Objective-C classes are imported into Kotlin with their original names. Protocols are imported as interfaces with &lt;code&gt;Protocol&lt;/code&gt; name suffix, i.e. &lt;code&gt;@protocol Foo&lt;/code&gt; -&amp;gt; &lt;code&gt;interface FooProtocol&lt;/code&gt;. These classes and interfaces are placed into a package &lt;a href=&quot;#usage&quot;&gt;specified in build configuration&lt;/a&gt; (&lt;code&gt;platform.*&lt;/code&gt; packages for preconfigured system frameworks).</source>
          <target state="translated">Objective-C 클래스는 원래 이름으로 Kotlin으로 가져옵니다. 프로토콜은 &lt;code&gt;Protocol&lt;/code&gt; 이름 접미사 (예 : &lt;code&gt;@protocol Foo&lt;/code&gt; &lt;code&gt;interface FooProtocol&lt;/code&gt; &amp;gt; interface FooProtocol)가있는 인터페이스로 가져옵니다 . 이러한 클래스와 인터페이스는 &lt;a href=&quot;#usage&quot;&gt;빌드 구성에 지정된&lt;/a&gt; 패키지 ( 사전 구성된 시스템 프레임 워크 용 &lt;code&gt;platform.*&lt;/code&gt; 패키지)에 배치됩니다.</target>
        </trans-unit>
        <trans-unit id="e28ecca8c4c63098937f693b564f06106597a69f" translate="yes" xml:space="preserve">
          <source>Objective-C generics do not support all features of either Kotlin or Swift, so there will be some information lost in the translation.</source>
          <target state="translated">Objective-C 제네릭은 Kotlin 또는 Swift의 모든 기능을 지원하지 않으므로 번역에서 일부 정보가 손실 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="edc50c4e6d2116d2eefbad12ba8e08e873a18c54" translate="yes" xml:space="preserve">
          <source>Objective-C supports &quot;lightweight generics&quot; defined on classes, with a relatively limited feature set. Swift can import generics defined on classes to help provide additional type information to the compiler.</source>
          <target state="translated">Objective-C는 클래스에 정의 된 &quot;가벼운 제네릭&quot;을 지원하며 기능이 상대적으로 제한되어 있습니다. Swift는 클래스에 정의 된 제네릭을 가져와 컴파일러에 추가 유형 정보를 제공 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="872324a80a8df1d396c94677f04ea994d1ae3329" translate="yes" xml:space="preserve">
          <source>Objects and companion objects</source>
          <target state="translated">객체 및 컴패니언 객체</target>
        </trans-unit>
        <trans-unit id="baa64e9ea92fa8d9f0990d9b1a5bc22ee025b445" translate="yes" xml:space="preserve">
          <source>Objects can be passed between threads in one of two possible modes.</source>
          <target state="translated">두 가지 가능한 모드 중 하나로 스레드간에 객체를 전달할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c92258fa87a7fd87bfb0eac39b2cad3876c1531d" translate="yes" xml:space="preserve">
          <source>Observable</source>
          <target state="translated">Observable</target>
        </trans-unit>
        <trans-unit id="53d6bf00994a7a961b92ecd0048f0ecd77a13ddf" translate="yes" xml:space="preserve">
          <source>ObservableProperty</source>
          <target state="translated">ObservableProperty</target>
        </trans-unit>
        <trans-unit id="1145800f1de30eba6d1df3a4fd2cc70c1f07f939" translate="yes" xml:space="preserve">
          <source>Obtain the Kotlin/Native compiler</source>
          <target state="translated">코 틀린 / 네이티브 컴파일러 얻기</target>
        </trans-unit>
        <trans-unit id="cdf71ecbbe212f441c04603a28909072a535e232" translate="yes" xml:space="preserve">
          <source>Obtaining member references from a class reference</source>
          <target state="translated">클래스 레퍼런스에서 멤버 레퍼런스 얻기</target>
        </trans-unit>
        <trans-unit id="df8298dcee7334200280003820f9875dbf3c187b" translate="yes" xml:space="preserve">
          <source>Obtaining the Compiler</source>
          <target state="translated">컴파일러 구하기</target>
        </trans-unit>
        <trans-unit id="b10db2a36e46741d4da85b74ece4b6f72fb9bfd8" translate="yes" xml:space="preserve">
          <source>Obtains a &lt;code&gt;KClass&lt;/code&gt; instance for the given constructor reference.</source>
          <target state="translated">지정된 생성자 참조 의 &lt;code&gt;KClass&lt;/code&gt; 인스턴스를 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="9910159f8fee624aa4548124f031d4745a86c889" translate="yes" xml:space="preserve">
          <source>Obtains a constructor reference for the given &lt;code&gt;KClass&lt;/code&gt;.</source>
          <target state="translated">지정된 &lt;code&gt;KClass&lt;/code&gt; 의 생성자 참조를 가져 옵니다 .</target>
        </trans-unit>
        <trans-unit id="0219b4a8ea1da937bc70be9c1ab95184f21fc8c4" translate="yes" xml:space="preserve">
          <source>Obtains the current continuation instance inside suspend functions and either suspends currently running coroutine or returns result immediately without suspension.</source>
          <target state="translated">일시 중단 함수 내에서 현재 연속 인스턴스를 가져오고 현재 실행중인 코 루틴을 일시 중단하거나 일시 중단없이 즉시 결과를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="646fc575bcb6c35847d73d3b2dd2cc5db56f01df" translate="yes" xml:space="preserve">
          <source>Obtains the current continuation instance inside suspend functions and suspends currently running coroutine.</source>
          <target state="translated">일시 중단 함수 내에서 현재 연속 인스턴스를 가져오고 현재 실행중인 코 루틴을 일시 중단합니다.</target>
        </trans-unit>
        <trans-unit id="dedd1425a40b177d169a6eb17080f5f8210d2fe7" translate="yes" xml:space="preserve">
          <source>Obtains the current continuation instance inside suspend functions and suspends the currently running coroutine.</source>
          <target state="translated">일시 중단 함수 내에서 현재 연속 인스턴스를 가져오고 현재 실행중인 코 루틴을 일시 중단합니다.</target>
        </trans-unit>
        <trans-unit id="0e481b647fccdeaa073311d1f3e53a76a5713079" translate="yes" xml:space="preserve">
          <source>Of course, there are use cases, where we need to pass a struct as a value to one call, and then, to pass the same struct as a reference to another call. This is possible in Kotlin/Native too. A &lt;code&gt;NativePlacement&lt;/code&gt; will be needed here.</source>
          <target state="translated">물론, 한 호출에 값으로 구조체를 전달한 다음 다른 호출에 대한 참조와 동일한 구조체를 전달해야하는 사용 사례가 있습니다. 이것은 Kotlin / Native에서도 가능합니다. &lt;code&gt;NativePlacement&lt;/code&gt; 는 여기에 필요합니다.</target>
        </trans-unit>
        <trans-unit id="31883564163ba418ee2d22f8e75f951da14db61c" translate="yes" xml:space="preserve">
          <source>Of course, this function makes sense for any &lt;code&gt;MutableList&amp;lt;T&amp;gt;&lt;/code&gt;, and we can make it generic:</source>
          <target state="translated">물론이 함수는 모든 &lt;code&gt;MutableList&amp;lt;T&amp;gt;&lt;/code&gt; 대해 의미 가 있으며 일반적인 것으로 만들 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="01fad7001a3bd3884c94e7702bc3df04daa71091" translate="yes" xml:space="preserve">
          <source>Of course, you can use both &lt;code&gt;kotlin-allopen&lt;/code&gt; and &lt;code&gt;kotlin-spring&lt;/code&gt; in the same project.</source>
          <target state="translated">물론 동일한 프로젝트에서 &lt;code&gt;kotlin-allopen&lt;/code&gt; 과 &lt;code&gt;kotlin-spring&lt;/code&gt; 을 모두 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="42c11258f0fc4616029dfe363fc90cedc10dac00" translate="yes" xml:space="preserve">
          <source>Often C APIs allow passing some user data to callbacks. Such data is usually provided by the user when configuring the callback. It is passed to some C function (or written to the struct) as e.g. &lt;code&gt;void*&lt;/code&gt;. However, references to Kotlin objects can't be directly passed to C. So they require wrapping before configuring the callback and then unwrapping in the callback itself, to safely swim from Kotlin to Kotlin through the C world. Such wrapping is possible with &lt;code&gt;StableRef&lt;/code&gt; class.</source>
          <target state="translated">C API를 사용하면 일부 사용자 데이터를 콜백에 전달할 수 있습니다. 이러한 데이터는 일반적으로 콜백을 구성 할 때 사용자가 제공합니다. 예를 들어 &lt;code&gt;void*&lt;/code&gt; 와 같이 일부 C 함수에 전달되거나 구조체에 기록됩니다 . 그러나 Kotlin 객체에 대한 참조는 C로 직접 전달 될 수 없습니다. 따라서 콜백을 구성하기 전에 랩핑 한 다음 콜백 자체에서 언 랩핑하여 C 월드를 통해 Kotlin에서 Kotlin으로 안전하게 수영해야합니다. 이러한 랩핑은 &lt;code&gt;StableRef&lt;/code&gt; 클래스 로 가능합니다 .</target>
        </trans-unit>
        <trans-unit id="242f4c07d8050ddde5e50538c080e4ec4486413c" translate="yes" xml:space="preserve">
          <source>Often it's necessary to specify target-specific linker options for a Kotlin/Native binary using an interop. It can be done using the &lt;code&gt;target&lt;/code&gt; script block:</source>
          <target state="translated">interop을 사용하여 Kotlin / Native 바이너리에 대한 대상별 링커 옵션을 지정해야하는 경우가 종종 있습니다. &lt;code&gt;target&lt;/code&gt; 스크립트 블록을 사용하여 수행 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="954df0a6263002ad270cb3cbc1c777c4a6fac8a1" translate="yes" xml:space="preserve">
          <source>Often it's necessary to specify target-specific linker options for a binary which uses a native library. It can by done using the &lt;code&gt;linkerOpts&lt;/code&gt; property of the binary. See the &lt;a href=&quot;#configuring-binaries&quot;&gt;Configuring binaries&lt;/a&gt; section for details.</source>
          <target state="translated">기본 라이브러리를 사용하는 바이너리에 대상별 링커 옵션을 지정해야하는 경우가 종종 있습니다. 바이너리 의 &lt;code&gt;linkerOpts&lt;/code&gt; 속성을 사용하여 수행 할 수 있습니다 . 자세한 내용은 &lt;a href=&quot;#configuring-binaries&quot;&gt;바이너리 구성&lt;/a&gt; 섹션을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="17450dcb9110eb38f3fe2d512c09098b5921aef0" translate="yes" xml:space="preserve">
          <source>Older compilers reject binaries that rely on new features (e.g. a 1.0 compiler rejects binaries that use coroutines).</source>
          <target state="translated">이전 컴파일러는 새로운 기능에 의존하는 바이너리를 거부합니다 (예 : 1.0 컴파일러는 코 루틴을 사용하는 바이너리를 거부합니다).</target>
        </trans-unit>
        <trans-unit id="622d524446394c09abc4f2559c91821dbd352982" translate="yes" xml:space="preserve">
          <source>Omit semicolons whenever possible.</source>
          <target state="translated">가능하면 세미콜론을 생략하십시오.</target>
        </trans-unit>
        <trans-unit id="902eb259efe55ed5caa3e21ba3397c994cd51091" translate="yes" xml:space="preserve">
          <source>On Apple platforms &lt;code&gt;objc&lt;/code&gt; library is provided for interoperability with &lt;a href=&quot;https://en.wikipedia.org/wiki/Objective-C&quot;&gt;Objective-C&lt;/a&gt;.</source>
          <target state="translated">Apple 플랫폼에서 &lt;code&gt;objc&lt;/code&gt; 라이브러리는 &lt;a href=&quot;https://en.wikipedia.org/wiki/Objective-C&quot;&gt;Objective-C&lt;/a&gt; 와의 상호 운용성을 위해 제공됩니다 .</target>
        </trans-unit>
        <trans-unit id="3a12a3cf1289b0209f29a4a3a5bf9dabfcdb8788" translate="yes" xml:space="preserve">
          <source>On GitHub</source>
          <target state="translated">GitHub에서</target>
        </trans-unit>
        <trans-unit id="c0ab16d7d10cfcca8fa016bc8b366c04e76c5016" translate="yes" xml:space="preserve">
          <source>On JVM it is possible to redefine global exception handler for all coroutines by registering &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-coroutine-exception-handler/index.html&quot;&gt;CoroutineExceptionHandler&lt;/a&gt; via &lt;a href=&quot;https://docs.oracle.com/javase/8/docs/api/java/util/ServiceLoader.html&quot;&gt;&lt;code&gt;ServiceLoader&lt;/code&gt;&lt;/a&gt;. Global exception handler is similar to &lt;a href=&quot;https://docs.oracle.com/javase/8/docs/api/java/lang/Thread.html#setDefaultUncaughtExceptionHandler(java.lang.Thread.UncaughtExceptionHandler)&quot;&gt;&lt;code&gt;Thread.defaultUncaughtExceptionHandler&lt;/code&gt;&lt;/a&gt; which is used when no more specific handlers are registered. On Android, &lt;code&gt;uncaughtExceptionPreHandler&lt;/code&gt; is installed as a global coroutine exception handler.</source>
          <target state="translated">JVM에서는 &lt;a href=&quot;https://docs.oracle.com/javase/8/docs/api/java/util/ServiceLoader.html&quot;&gt; &lt;code&gt;ServiceLoader&lt;/code&gt; &lt;/a&gt; 를 통해 &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-coroutine-exception-handler/index.html&quot;&gt;CoroutineExceptionHandler&lt;/a&gt; 를 등록하여 모든 코 루틴에 대한 전역 예외 핸들러를 재정의 할 수 있습니다 . 전역 예외 처리기는 더 이상 특정 처리기가 등록되지 않은 경우 사용되는 &lt;a href=&quot;https://docs.oracle.com/javase/8/docs/api/java/lang/Thread.html#setDefaultUncaughtExceptionHandler(java.lang.Thread.UncaughtExceptionHandler)&quot;&gt; &lt;code&gt;Thread.defaultUncaughtExceptionHandler&lt;/code&gt; &lt;/a&gt; 와 유사합니다 . Android에서 &lt;code&gt;uncaughtExceptionPreHandler&lt;/code&gt; 는 글로벌 코 루틴 예외 핸들러로 설치됩니다.</target>
        </trans-unit>
        <trans-unit id="d634a94c081c286c31c7efa035cd25a12a05ea49" translate="yes" xml:space="preserve">
          <source>On JVM this generator is thread-safe, its methods can be invoked from multiple threads.</source>
          <target state="translated">JVM에서이 생성기는 스레드로부터 안전하며 여러 스레드에서 메소드를 호출 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="82b7124cbe78a1bd0ee0229af53226a5b9d9303c" translate="yes" xml:space="preserve">
          <source>On Linux we call a similar command:</source>
          <target state="translated">Linux에서는 비슷한 명령을 호출합니다.</target>
        </trans-unit>
        <trans-unit id="f32995a2978fac4fc27ca1ef6f69f7fd0261ff6b" translate="yes" xml:space="preserve">
          <source>On Windows, Dynamic libraries are included either via a generated static library wrapper or with manual code, which deals with the &lt;a href=&quot;https://msdn.microsoft.com/en-us/library/windows/desktop/ms684175.aspx&quot;&gt;LoadLibrary&lt;/a&gt; or similar Win32API functions. We will follow the first option and generate the static wrapper library for the &lt;code&gt;libnative.dll&lt;/code&gt; on our own.</source>
          <target state="translated">Windows에서 동적 라이브러리는 생성 된 정적 라이브러리 랩퍼 또는 &lt;a href=&quot;https://msdn.microsoft.com/en-us/library/windows/desktop/ms684175.aspx&quot;&gt;LoadLibrary&lt;/a&gt; 또는 유사한 Win32API 함수 를 처리하는 수동 코드와 함께 포함 됩니다. 첫 번째 옵션을 따르고 &lt;code&gt;libnative.dll&lt;/code&gt; 에 대한 정적 래퍼 라이브러리를 생성합니다 .</target>
        </trans-unit>
        <trans-unit id="d7653dc191105be976f3e4142a119bd4841c071b" translate="yes" xml:space="preserve">
          <source>On compiling, Gradle will produce the output of our application, which is by default placed under the &lt;code&gt;build/classes/main&lt;/code&gt; directory. This can be overridden using &lt;a href=&quot;#configuring-compiler-options&quot;&gt;the compiler options&lt;/a&gt;.</source>
          <target state="translated">컴파일시 Gradle은 기본적으로 &lt;code&gt;build/classes/main&lt;/code&gt; 디렉토리 아래에있는 애플리케이션의 출력을 생성합니다 . 이것은 &lt;a href=&quot;#configuring-compiler-options&quot;&gt;컴파일러 옵션을&lt;/a&gt; 사용 하여 무시할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="c14acaa8726202e56fd6764b8d4c4f4bf976a344" translate="yes" xml:space="preserve">
          <source>On compiling, Maven will produce the following output</source>
          <target state="translated">컴파일시 Maven은 다음과 같은 출력을 생성합니다.</target>
        </trans-unit>
        <trans-unit id="2882a4f2583407f0619da2020ec98bec3d44466d" translate="yes" xml:space="preserve">
          <source>On macOS 10.13 with Xcode, we compile the C code and link it with the dynamic library with the following command:</source>
          <target state="translated">Xcode가 포함 된 macOS 10.13에서는 C 코드를 컴파일하고 다음 명령을 사용하여 동적 라이브러리와 연결합니다.</target>
        </trans-unit>
        <trans-unit id="fb4ddd201d36fd87940a13588d6e11985482252b" translate="yes" xml:space="preserve">
          <source>On the JVM side, the main build tools include &lt;a href=&quot;using-gradle&quot;&gt;Gradle&lt;/a&gt;, &lt;a href=&quot;using-maven&quot;&gt;Maven&lt;/a&gt;, &lt;a href=&quot;using-ant&quot;&gt;Ant&lt;/a&gt;, and &lt;a href=&quot;http://beust.com/kobalt/home/index.html&quot;&gt;Kobalt&lt;/a&gt;. There are also some build tools available that target client-side JavaScript.</source>
          <target state="translated">JVM 측면에서 기본 빌드 도구에는 &lt;a href=&quot;using-gradle&quot;&gt;Gradle&lt;/a&gt; , &lt;a href=&quot;using-maven&quot;&gt;Maven&lt;/a&gt; , &lt;a href=&quot;using-ant&quot;&gt;Ant&lt;/a&gt; 및 &lt;a href=&quot;http://beust.com/kobalt/home/index.html&quot;&gt;Kobalt가&lt;/a&gt; 있습니다. 클라이언트 측 JavaScript를 대상으로하는 빌드 도구도 있습니다.</target>
        </trans-unit>
        <trans-unit id="8a846654c5fb7b58771a6c8aa68e2bb8f0431b17" translate="yes" xml:space="preserve">
          <source>On the JVM, if the generated class needs to have a parameterless constructor, default values for all properties have to be specified (see &lt;a href=&quot;classes#constructors&quot;&gt;Constructors&lt;/a&gt;).</source>
          <target state="translated">JVM에서 생성 된 클래스에 매개 변수가없는 생성자가 필요한 경우 모든 특성의 기본값을 지정해야합니다 ( &lt;a href=&quot;classes#constructors&quot;&gt;생성자&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="22f3441381be355a57b0344800020b03a2e7fba9" translate="yes" xml:space="preserve">
          <source>On the JVM, non-nullable values of this type are represented as values of the primitive type &lt;code&gt;char&lt;/code&gt;.</source>
          <target state="translated">JVM에서이 유형의 널 입력 불가능 값은 기본 유형 &lt;code&gt;char&lt;/code&gt; 값으로 표시됩니다 .</target>
        </trans-unit>
        <trans-unit id="c36ad8bfe3e9b420b17609f7d80f8fe5d46e556b" translate="yes" xml:space="preserve">
          <source>On the JVM, one could provide an implementation that writes the log to the standard output:</source>
          <target state="translated">JVM에서 표준 출력에 로그를 작성하는 구현을 제공 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="37c721a8e1ab899d231ec42baf253266e008d200" translate="yes" xml:space="preserve">
          <source>On the JVM, the &lt;a href=&quot;basic-types#arrays&quot;&gt;array types&lt;/a&gt; (&lt;code&gt;Array&amp;lt;Foo&amp;gt;&lt;/code&gt;) retain the information about the erased type of their elements, and the type casts to an array type are partially checked: the nullability and actual type arguments of the elements type are still erased. For example, the cast &lt;code&gt;foo as Array&amp;lt;List&amp;lt;String&amp;gt;?&amp;gt;&lt;/code&gt; will succeed if &lt;code&gt;foo&lt;/code&gt; is an array holding any &lt;code&gt;List&amp;lt;*&amp;gt;&lt;/code&gt;, nullable or not.</source>
          <target state="translated">JVM에서 &lt;a href=&quot;basic-types#arrays&quot;&gt;배열 유형&lt;/a&gt; ( &lt;code&gt;Array&amp;lt;Foo&amp;gt;&lt;/code&gt; )은 요소의 지워진 유형에 대한 정보를 보유하고 배열 유형에 대한 유형 캐스트는 부분적으로 점검됩니다. 요소 유형의 널 입력 가능 여부 및 실제 유형 인수는 여전히 지워집니다. 예를 들어, &lt;code&gt;foo&lt;/code&gt; 가 &lt;code&gt;List&amp;lt;*&amp;gt;&lt;/code&gt; 보유한 배열 인 null 가능 여부를 나타내는 &lt;code&gt;foo as Array&amp;lt;List&amp;lt;String&amp;gt;?&amp;gt;&lt;/code&gt; 캐스트 foo 는 성공합니다 .</target>
        </trans-unit>
        <trans-unit id="5506431e2bb120557c874e7652f1a65950568290" translate="yes" xml:space="preserve">
          <source>On the Java platform, numbers are physically stored as JVM primitive types, unless we need a nullable number reference (e.g. &lt;code&gt;Int?&lt;/code&gt;) or generics are involved. In the latter cases numbers are boxed.</source>
          <target state="translated">Java 플랫폼에서는 널 입력 가능 숫자 참조 (예 : &lt;code&gt;Int?&lt;/code&gt; )가 필요하거나 제네릭이 포함 되지 않는 한 숫자는 실제로 JVM 기본 유형으로 저장됩니다 . 후자의 경우 숫자가 박스로 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="fc1cc156e617b185ed0f40e773e41bff1f85a104" translate="yes" xml:space="preserve">
          <source>On the Java platform, standard library contains extensions for reflection classes that provide a mapping to and from Java reflection objects (see package &lt;code&gt;kotlin.reflect.jvm&lt;/code&gt;). For example, to find a backing field or a Java method that serves as a getter for a Kotlin property, you can say something like this:</source>
          <target state="translated">Java 플랫폼에서 표준 라이브러리에는 Java 리플렉션 객체와의 매핑을 제공하는 리플렉션 클래스의 확장이 포함되어 있습니다 (package &lt;code&gt;kotlin.reflect.jvm&lt;/code&gt; 참조 ). 예를 들어 Kotlin 속성의 getter 역할을하는 지원 필드 나 Java 메서드를 찾으려면 다음과 같이 말할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2a19f51c47052a4b52d4d3a45688012ff83885d4" translate="yes" xml:space="preserve">
          <source>On the Java platform, the runtime component required for using the reflection features is distributed as a separate JAR file (&lt;code&gt;kotlin-reflect.jar&lt;/code&gt;). This is done to reduce the required size of the runtime library for applications that do not use reflection features. If you do use reflection, please make sure that the .jar file is added to the classpath of your project.</source>
          <target state="translated">Java 플랫폼에서 리플렉션 기능을 사용하는 데 필요한 런타임 구성 요소는 별도의 JAR 파일 ( &lt;code&gt;kotlin-reflect.jar&lt;/code&gt; ) 로 분배 됩니다. 리플렉션 기능을 사용하지 않는 응용 프로그램에 필요한 런타임 라이브러리 크기를 줄이기 위해 수행됩니다. 리플렉션을 사용하는 경우 .jar 파일이 프로젝트의 클래스 경로에 추가되어 있는지 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="5d535cc279349339edec2b28152e5485a7cce0a0" translate="yes" xml:space="preserve">
          <source>On the JavaScript platform this code will be compiled &quot;as is&quot;: &lt;code&gt;dyn.whatever(1)&lt;/code&gt; in Kotlin becomes &lt;code&gt;dyn.whatever(1)&lt;/code&gt; in the generated JavaScript code.</source>
          <target state="translated">&quot;있는 그대로&quot;이 코드는 컴파일 될 자바 스크립트 플랫폼 : &lt;code&gt;dyn.whatever(1)&lt;/code&gt; 코 틀린에이된다 &lt;code&gt;dyn.whatever(1)&lt;/code&gt; 생성 된 자바 스크립트 코드입니다.</target>
        </trans-unit>
        <trans-unit id="7710454ff099464789e309cce04c505a88cd2a29" translate="yes" xml:space="preserve">
          <source>On the generic Native platform we don't have the luxury to use someone else's implementation, so we will have to write one ourselves. I won't explain the implementation details here, but it's pretty straightforward and follows Base64 format description without any optimizations:</source>
          <target state="translated">일반 네이티브 플랫폼에서는 다른 사람의 구현을 사용할 수있는 사치가 없으므로 직접 작성해야합니다. 여기에 구현 세부 사항을 설명하지는 않지만 매우 간단하며 최적화없이 Base64 형식 설명을 따릅니다.</target>
        </trans-unit>
        <trans-unit id="dc341284a94c1ff306b2072d23ec90c8ced7deca" translate="yes" xml:space="preserve">
          <source>On the one hand, to achieve this, the compiler has to provide certain ABI stability guarantees under the constraints of separate compilation. This is why every change in the language is examined from the point of view of binary compatibility.</source>
          <target state="translated">한편으로,이를 달성하기 위해 컴파일러는 별도의 컴파일 제약 조건 하에서 특정 ABI 안정성 보장을 제공해야합니다. 이진 호환성의 관점에서 언어의 모든 변경 사항을 검사하는 이유입니다.</target>
        </trans-unit>
        <trans-unit id="000c75f582537e6c16176741f98b45d2d110bbb3" translate="yes" xml:space="preserve">
          <source>On the other hand, Kotlin/Native supports interoperability to use existing libraries directly from Kotlin/Native:</source>
          <target state="translated">반면 Kotlin / Native는 Kotlin / Native에서 직접 기존 라이브러리를 사용할 수있는 상호 운용성을 지원합니다.</target>
        </trans-unit>
        <trans-unit id="60f0f1b25c5dff1f04424f892492e20e71e1b66d" translate="yes" xml:space="preserve">
          <source>On the other hand, a lot depends on the library authors being careful about which changes are safe to make. Thus it's very important that library authors understand how source changes affect compatibility and follow certain best practices to keep both APIs and ABIs of their libraries stable. Here are some assumptions that we make when considering language changes from the library evolution standpoint:</source>
          <target state="translated">반면에, 많은 변경 사항이 안전한지 라이브러리 작성자가주의를 기울여야합니다. 따라서 라이브러리 작성자는 소스 변경이 호환성에 미치는 영향을 이해하고 라이브러리의 API 및 ABI를 모두 안정적으로 유지하기 위해 특정 모범 사례를 따르는 것이 중요합니다. 다음은 라이브러리 진화 관점에서 언어 변경을 고려할 때 가정 한 내용입니다.</target>
        </trans-unit>
        <trans-unit id="24a6b58cfe3e05a456f0e657a9154e03adab1e36" translate="yes" xml:space="preserve">
          <source>On the other hand, if we don't need wildcards where they are generated, we can use &lt;code&gt;@JvmSuppressWildcards&lt;/code&gt;:</source>
          <target state="translated">반면에 생성 된 와일드 카드가 필요없는 경우 &lt;code&gt;@JvmSuppressWildcards&lt;/code&gt; 를 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="9fe83b5bff0a5d4a34dc3a1fd60b88652cfd8998" translate="yes" xml:space="preserve">
          <source>On the other hand, infix function call's precedence is higher than that of the boolean operators &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; and &lt;code&gt;||&lt;/code&gt;, &lt;code&gt;is&lt;/code&gt;- and &lt;code&gt;in&lt;/code&gt;-checks, and some other operators. These expressions are equivalent as well:</source>
          <target state="translated">반면에, infix 함수 호출의 우선 순위는 부울 연산자 &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; 및 &lt;code&gt;||&lt;/code&gt; 의 우선 순위보다 높습니다. , &lt;code&gt;is&lt;/code&gt; - &lt;code&gt;in&lt;/code&gt; - in- checks 및 일부 다른 연산자입니다. 이 표현들도 동일합니다 :</target>
        </trans-unit>
        <trans-unit id="4b4a432df45f297429fbc3cee76b5f8d7f65a8e2" translate="yes" xml:space="preserve">
          <source>On the other hand, it preserves equality:</source>
          <target state="translated">반면에 평등을 유지합니다.</target>
        </trans-unit>
        <trans-unit id="7e3c3918cd7bead7b21ab07c18b704638f85c9a4" translate="yes" xml:space="preserve">
          <source>On the other hand, the platform libs in the distribution are merely just wrappers and bindings to the native libraries. That means the native libraries themselves (&lt;code&gt;.so&lt;/code&gt;, &lt;code&gt;.a&lt;/code&gt;, &lt;code&gt;.dylib&lt;/code&gt;, &lt;code&gt;.dll&lt;/code&gt; etc) should be installed on the machine.</source>
          <target state="translated">다른 한편으로, 배포판의 플랫폼 라이브러리는 단지 래퍼 일 뿐이며 네이티브 라이브러리에 대한 바인딩 일뿐입니다. 즉, 기본 라이브러리 자체 ( &lt;code&gt;.so&lt;/code&gt; , &lt;code&gt;.a&lt;/code&gt; , &lt;code&gt;.dylib&lt;/code&gt; , &lt;code&gt;.dll&lt;/code&gt; 등)가 시스템에 설치되어 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="a4bdeb370dbf1cefb8a423a42914a31fcb4ec6d9" translate="yes" xml:space="preserve">
          <source>On the other side, by default, a dispatcher for the outer &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-coroutine-scope/index.html&quot;&gt;CoroutineScope&lt;/a&gt; is inherited. The default dispatcher for &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/run-blocking.html&quot;&gt;runBlocking&lt;/a&gt; coroutine, in particular, is confined to the invoker thread, so inheriting it has the effect of confining execution to this thread with a predictable FIFO scheduling.</source>
          <target state="translated">한편, 기본적으로 외부 &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-coroutine-scope/index.html&quot;&gt;CoroutineScope에&lt;/a&gt; 대한 디스패처 가 상속됩니다. 특히 &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/run-blocking.html&quot;&gt;runBlocking&lt;/a&gt; 코 루틴 의 기본 디스패처 는 호출자 스레드로 제한되므로이를 상속하면 예측 가능한 FIFO 스케줄링으로이 스레드에 대한 실행을 제한하는 효과가 있습니다.</target>
        </trans-unit>
        <trans-unit id="0097b825a22364e0ed5d52b543c2c2d7417ac42f" translate="yes" xml:space="preserve">
          <source>OnErrorAction</source>
          <target state="translated">OnErrorAction</target>
        </trans-unit>
        <trans-unit id="af3390fd9bdb1b1f1af829e06104c3364aeb4907" translate="yes" xml:space="preserve">
          <source>Once a worker is started with the &lt;code&gt;Worker.start&lt;/code&gt; function call, it can be addressed with its own unique integer worker id. Other workers, or non-worker concurrency primitives, such as OS threads, can send a message to the worker with the &lt;code&gt;execute&lt;/code&gt; call.</source>
          <target state="translated">&lt;code&gt;Worker.start&lt;/code&gt; 함수 호출 로 워커를 시작하면 고유 한 정수 워커 ID로 주소를 지정할 수 있습니다. 다른 작업자 또는 OS 스레드와 같은 비 작업 동시성 프리미티브는 &lt;code&gt;execute&lt;/code&gt; 호출 을 통해 작업자에게 메시지를 보낼 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="df99b41ffc8e8869530eb6fc788d462a8f350ad0" translate="yes" xml:space="preserve">
          <source>Once that's done, we simply right-click on our &lt;code&gt;index.html&lt;/code&gt; file and select the Debug option. This launches Chrome and then stops at the breakpoint defined in our code inside IntelliJ IDEA, from where we can evaluate expressions, step through code, etc.</source>
          <target state="translated">완료되면 &lt;code&gt;index.html&lt;/code&gt; 파일을 마우스 오른쪽 버튼으로 클릭 하고 디버그 옵션을 선택하십시오. Chrome을 시작한 다음 IntelliJ IDEA 내부의 코드에 정의 된 중단 점에서 중지합니다. 여기서 표현식을 평가하고 코드를 통과하는 등의 작업을 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3775c8ff21ba04eef02e13e8e82e7fea59a82c9d" translate="yes" xml:space="preserve">
          <source>Once the IDE has finished creating the new project, we should be left with the following layout</source>
          <target state="translated">IDE가 새 프로젝트 생성을 마치면 다음 레이아웃을 유지해야합니다.</target>
        </trans-unit>
        <trans-unit id="d9769c12f9ad9598db953dee152f3b5b5ad3daf0" translate="yes" xml:space="preserve">
          <source>Once the code is ready, select a fragment you want a learner to fill in, invoke &lt;strong&gt;Add Answer Placeholder&lt;/strong&gt; command from the right-click menu and add the placeholder text and some hints to help the learner find the right solution:</source>
          <target state="translated">코드가 준비되면 학습자가 채울 조각을 선택 하고 마우스 오른쪽 버튼 메뉴에서 &lt;strong&gt;응답 자리 표시 자 추가&lt;/strong&gt; 명령을 호출 하고 자리 표시 자 텍스트와 힌트를 추가하여 학습자가 올바른 솔루션을 찾는 데 도움을줍니다.</target>
        </trans-unit>
        <trans-unit id="46c1b63ed4fbeaebfc1fd631405807b64e959941" translate="yes" xml:space="preserve">
          <source>Once the dependency is included, we can access the different interfaces provided to generate DOM. The code below will add a new &lt;code&gt;span&lt;/code&gt; tag with the text &lt;code&gt;Hello&lt;/code&gt; inside a &lt;code&gt;div&lt;/code&gt; on the &lt;code&gt;window.load&lt;/code&gt; event.</source>
          <target state="translated">종속성이 포함되면 DOM을 생성하기 위해 제공된 다른 인터페이스에 액세스 할 수 있습니다. 아래 코드 는 &lt;code&gt;window.load&lt;/code&gt; 이벤트 의 &lt;code&gt;div&lt;/code&gt; 안에 &lt;code&gt;Hello&lt;/code&gt; 텍스트 가 포함 된 새 &lt;code&gt;span&lt;/code&gt; 태그를 추가합니다 .</target>
        </trans-unit>
        <trans-unit id="5f0142e56236eba7d0f9779ea0961db259aa8e0d" translate="yes" xml:space="preserve">
          <source>Once the file is created, add the &lt;code&gt;main&lt;/code&gt; function which is the entry point to a Kotlin application. IntelliJ IDEA offers a template to do this quickly. Just type &lt;em&gt;main&lt;/em&gt; and press tab.</source>
          <target state="translated">파일이 작성되면 Kotlin 애플리케이션의 진입 점 인 &lt;code&gt;main&lt;/code&gt; 기능을 추가하십시오 . IntelliJ IDEA는이를 신속하게 수행 할 수있는 템플릿을 제공합니다. &lt;em&gt;main을&lt;/em&gt; 입력 하고 tab을 누르십시오.</target>
        </trans-unit>
        <trans-unit id="c73312381dcc07c6b7a625ba7ed9e57ac7440a0f" translate="yes" xml:space="preserve">
          <source>Once the plugin is installed and Eclipse is restarted, make sure the plugin is installed correctly: open the &lt;strong&gt;Kotlin perspective&lt;/strong&gt; in the menu &lt;strong&gt;Window | Open Perspective | Other&amp;hellip;&lt;/strong&gt;</source>
          <target state="translated">플러그인이 설치되고 Eclipse가 다시 시작되면 플러그인이 올바르게 설치되었는지 확인하십시오 . 메뉴 &lt;strong&gt;창&lt;/strong&gt; 에서 &lt;strong&gt;Kotlin Perspective를여십시오. &lt;/strong&gt;&lt;strong&gt;열린 관점 | 다른&amp;hellip;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="0796366ca4be24e6c9cb8aea2efb2652251fe7de" translate="yes" xml:space="preserve">
          <source>Once we do that, we can then invoke the corresponding extensions, which are properties named after the views in the XML file. For example, for this view:</source>
          <target state="translated">그렇게하면 XML 파일의 뷰 이름을 딴 속성 인 해당 확장을 호출 할 수 있습니다. 예를 들어,이보기의 경우 :</target>
        </trans-unit>
        <trans-unit id="1c271397461aeb676abb2a2efff251e0af0e8c64" translate="yes" xml:space="preserve">
          <source>Once we have the build script defined with the correct dependencies, we can now create a controller</source>
          <target state="translated">올바른 의존성으로 빌드 스크립트를 정의했으면 이제 컨트롤러를 만들 수 있습니다</target>
        </trans-unit>
        <trans-unit id="a08b600d20b04c79c7a79b722bf898a01cce7fce" translate="yes" xml:space="preserve">
          <source>Once we have the definition file ready, we can create project files and open the project in an IDE.</source>
          <target state="translated">정의 파일이 준비되면 프로젝트 파일을 생성하고 IDE에서 프로젝트를 열 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d8045dca300b9f4677fd2c5dc7702ace1a03cfe2" translate="yes" xml:space="preserve">
          <source>Once we have the file generated, we can simply include it in our project and use it:</source>
          <target state="translated">파일이 생성되면 간단히 프로젝트에 파일을 포함하고 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="bd56b1bd7445724ec0021ec14943c2a384d08186" translate="yes" xml:space="preserve">
          <source>Once we run the application (using this previous run configuration), and on successful deployment, we should be able to navigate to the browser with the correct url and see the response:</source>
          <target state="translated">애플리케이션을 실행하고 (이 이전 실행 구성을 사용하여) 성공적으로 배치되면 올바른 URL로 브라우저를 탐색하고 응답을 볼 수 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="1b6604db47f0dce985d7de59d4f23c0c4c5c9cca" translate="yes" xml:space="preserve">
          <source>Once you complete the steps, Android Studio creates a project. The project already contains all the code and resources for building an application that can run on your Android device or an emulator.</source>
          <target state="translated">단계를 완료하면 Android Studio가 프로젝트를 생성합니다. 프로젝트에는 이미 Android 장치 또는 에뮬레이터에서 실행할 수있는 응용 프로그램을 빌드하기위한 모든 코드와 리소스가 포함되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="07c62572d32f4ddef7a4fab02344f0c5993a4073" translate="yes" xml:space="preserve">
          <source>Once you have IntelliJ IDEA installed, it's time to create your first Kotlin application.</source>
          <target state="translated">IntelliJ IDEA를 설치했으면 이제 첫 번째 Kotlin 응용 프로그램을 만들어야합니다.</target>
        </trans-unit>
        <trans-unit id="57c7fbdcf305fcf640a6242dec4553b583c17b02" translate="yes" xml:space="preserve">
          <source>Once you have a source file, add the &lt;code&gt;main&lt;/code&gt; function - the entry point to a Kotlin application. You can simply type &lt;code&gt;main&lt;/code&gt; and invoke code completion by hitting &lt;code&gt;Ctrl + Space&lt;/code&gt;.</source>
          <target state="translated">소스 파일이 있으면 &lt;code&gt;main&lt;/code&gt; 기능인 Kotlin 응용 프로그램의 진입 점을 추가하십시오 . &lt;code&gt;Ctrl + Space&lt;/code&gt; 누르면 &lt;code&gt;main&lt;/code&gt; 을 입력 하고 코드 완성을 호출 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="17939f0df56f8a8f1b07cbf026fcbc6c284de9b6" translate="yes" xml:space="preserve">
          <source>Once your experimental API graduates and is released in its final state, remove its marker annotation from declarations so that the clients can use it without restriction. However, you should leave the marker classes in modules so that the existing client code remains compatible. To let the API users update their modules accordingly (remove the markers from their code and recompile), mark the annotations as &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin/-deprecated/index&quot;&gt;&lt;code&gt;@Deprecated&lt;/code&gt;&lt;/a&gt; and provide the explanation in its message.</source>
          <target state="translated">실험용 API가 졸업하고 최종 상태로 출시되면 클라이언트가 제한없이 사용할 수 있도록 선언에서 마커 주석을 제거하십시오. 그러나 기존 클라이언트 코드가 호환되도록 마커 클래스를 모듈에 그대로 두어야합니다. API 사용자가 그에 따라 모듈을 업데이트하도록하려면 (코드에서 마커를 제거하고 다시 컴파일) 주석을 &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin/-deprecated/index&quot;&gt; &lt;code&gt;@Deprecated&lt;/code&gt; &lt;/a&gt; 로 표시 하고 메시지에 설명을 제공하십시오.</target>
        </trans-unit>
        <trans-unit id="0e2971b85ea49c26dcec5b2c744d22a818808e11" translate="yes" xml:space="preserve">
          <source>One can think of a coroutine as a light-weight thread. Like threads, coroutines can run in parallel, wait for each other and communicate. The biggest difference is that coroutines are very cheap, almost free: we can create thousands of them, and pay very little in terms of performance. True threads, on the other hand, are expensive to start and keep around. A thousand threads can be a serious challenge for a modern machine.</source>
          <target state="translated">코 루틴을 가벼운 실로 생각할 수 있습니다. 스레드와 마찬가지로 코 루틴은 병렬로 실행되고 서로 기다렸다가 통신 할 수 있습니다. 가장 큰 차이점은 코 루틴이 매우 저렴하고 거의 무료라는 것입니다. 반면에 진정한 스레드는 시작하고 유지하는 데 비용이 많이 듭니다. 현대의 기계에는 천개의 스레드가 심각한 도전이 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ef394220529220df8824f487b3f420bc848dae8f" translate="yes" xml:space="preserve">
          <source>One common use case is storing the values of properties in a map. This comes up often in applications like parsing JSON or doing other &amp;ldquo;dynamic&amp;rdquo; things. In this case, you can use the map instance itself as the delegate for a delegated property.</source>
          <target state="translated">일반적인 유스 케이스는 특성 값을 맵에 저장하는 것입니다. 이는 JSON 구문 분석이나 다른 &quot;동적&quot;작업과 같은 응용 프로그램에서 자주 나타납니다. 이 경우 맵 인스턴스 자체를 위임 된 속성의 대리자로 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="295aff355ebc55ee584427ed710ab76e9197e01b" translate="yes" xml:space="preserve">
          <source>One element still represent one byte in the output data. This is the only way to create ImmutableBlob for now.</source>
          <target state="translated">하나의 요소는 여전히 출력 데이터에서 1 바이트를 나타냅니다. 지금은 ImmutableBlob을 만드는 유일한 방법입니다.</target>
        </trans-unit>
        <trans-unit id="69552c7e67db21fed3933e5341eb7f8d6f1878a7" translate="yes" xml:space="preserve">
          <source>One has to remember that those definitions are given only for pure Kotlin. Compatibility of Kotlin code from the other languages perspective (e.g. from Java) is out of the scope of this document.</source>
          <target state="translated">이러한 정의는 순수한 Kotlin에 대해서만 제공된다는 것을 기억해야합니다. 다른 언어 관점 (예 : Java)에서의 Kotlin 코드 호환성은이 문서에서 다루지 않습니다.</target>
        </trans-unit>
        <trans-unit id="10295bca22700ae68c4bd22afa199c59a7bf9d2d" translate="yes" xml:space="preserve">
          <source>One might think that static typing would make it very impractical to make collection classes or any other class that needs to contain members whose types vary with each usage. Generics to the rescue: they allow you to specify a &quot;placeholder&quot; type in a class or function that must be filled in whenever the class or function is used. For example, a node in a linked list needs to contain data of some type that is not known when we write the class, so we introduce a &lt;em&gt;generic type parameter&lt;/em&gt;&lt;code&gt;T&lt;/code&gt; (they are conventionally given single-letter names):</source>
          <target state="translated">정적 타이핑은 콜렉션 클래스 또는 각 사용법에 따라 유형이 다른 멤버를 포함해야하는 다른 클래스를 작성하는 것이 매우 비현실적이라고 생각할 수 있습니다. 구조의 제네릭 : 클래스 또는 함수를 사용할 때마다 채워야하는 클래스 또는 함수에 &quot;자리 표시 자&quot;유형을 지정할 수 있습니다. 예를 들어, 링크 된 목록의 노드는 클래스를 작성할 때 알려지지 않은 일부 유형의 데이터를 포함해야하므로 &lt;em&gt;일반 유형 매개 변수 &lt;/em&gt; &lt;code&gt;T&lt;/code&gt; 를 도입합니다 ( &lt;em&gt;일반적으로&lt;/em&gt; 단일 문자 이름이 제공됨).</target>
        </trans-unit>
        <trans-unit id="d91389670b253297bf40dd8c299f98764e30e6fa" translate="yes" xml:space="preserve">
          <source>One more way to create a sequence is by building it with a function that calculates its elements. To build a sequence based on a function, call &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.sequences/generate-sequence&quot;&gt;&lt;code&gt;generateSequence()&lt;/code&gt;&lt;/a&gt; with this function as an argument. Optionally, you can specify the first element as an explicit value or a result of a function call. The sequence generation stops when the provided function returns &lt;code&gt;null&lt;/code&gt;. So, the sequence in the example below is infinite.</source>
          <target state="translated">시퀀스를 만드는 또 다른 방법은 요소를 계산하는 함수로 시퀀스를 작성하는 것입니다. 함수를 기반으로 시퀀스를 작성하려면 이 함수를 인수로 사용하여 &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.sequences/generate-sequence&quot;&gt; &lt;code&gt;generateSequence()&lt;/code&gt; &lt;/a&gt; 를 호출하십시오 . 선택적으로 첫 번째 요소를 명시 적 값 또는 함수 호출의 결과로 지정할 수 있습니다. 제공된 함수가 &lt;code&gt;null&lt;/code&gt; 을 반환하면 시퀀스 생성이 중지됩니다 . 따라서 아래 예의 순서는 무한합니다.</target>
        </trans-unit>
        <trans-unit id="fafa0cfeaea1b82981c57e5ae33aa6c2ac893b23" translate="yes" xml:space="preserve">
          <source>One of the benefits however of coroutines is that when it comes to the developer, writing non-blocking code is essentially the same as writing blocking code. The programming model in itself doesn't really change.</source>
          <target state="translated">그러나 코 루틴의 장점 중 하나는 개발자에게있어 비 차단 코드를 작성하는 것은 본질적으로 차단 코드를 작성하는 것과 동일하다는 것입니다. 프로그래밍 모델 자체는 실제로 변하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="265251dce76905646b45b6f600aaf0f8ecf9a59f" translate="yes" xml:space="preserve">
          <source>One of the key capabilities of Kotlin's multiplatform code is a way for common code to depend on platform-specific declarations. In other languages, this can often be accomplished by building a set of interfaces in the common code and implementing these interfaces in platform-specific modules. However, this approach is not ideal in cases when you have a library on one of the platforms that implements the functionality you need, and you'd like to use the API of this library directly without extra wrappers. Also, it requires common declarations to be expressed as interfaces, which doesn't cover all possible cases.</source>
          <target state="translated">Kotlin의 다중 플랫폼 코드의 주요 기능 중 하나는 공통 코드가 플랫폼 별 선언에 의존하는 방법입니다. 다른 언어로, 이것은 공통 코드로 인터페이스 세트를 빌드하고 이러한 인터페이스를 플랫폼 별 모듈로 구현하여 수행 할 수 있습니다. 그러나이 기능은 필요한 기능을 구현하는 플랫폼 중 하나에 라이브러리가 있고 추가 랩퍼없이이 라이브러리의 API를 직접 사용하려는 경우에는 이상적이지 않습니다. 또한 공통 선언을 인터페이스로 표현해야하며 가능한 모든 경우를 다루지는 않습니다.</target>
        </trans-unit>
        <trans-unit id="dc2f355daff82042213227d21be547e3dba71d34" translate="yes" xml:space="preserve">
          <source>One of the most common pitfalls in many programming languages, including Java, is that accessing a member of a null reference will result in a null reference exception. In Java this would be the equivalent of a &lt;code&gt;NullPointerException&lt;/code&gt; or NPE for short.</source>
          <target state="translated">Java를 포함한 많은 프로그래밍 언어에서 가장 일반적인 함정 중 하나는 널 참조의 멤버에 액세스하면 널 참조 예외가 발생한다는 것입니다. Java에서 이것은 &lt;code&gt;NullPointerException&lt;/code&gt; 또는 NPE 와 동일 합니다.</target>
        </trans-unit>
        <trans-unit id="e6f92c8a67f2d507591085679c40b475519d2dde" translate="yes" xml:space="preserve">
          <source>One of the most tricky parts of Java's type system is wildcard types (see &lt;a href=&quot;http://www.angelikalanger.com/GenericsFAQ/JavaGenericsFAQ.html&quot;&gt;Java Generics FAQ&lt;/a&gt;). And Kotlin doesn't have any. Instead, it has two other things: declaration-site variance and type projections.</source>
          <target state="translated">Java 유형 시스템에서 가장 까다로운 부분 중 하나는 와일드 카드 유형입니다 ( &lt;a href=&quot;http://www.angelikalanger.com/GenericsFAQ/JavaGenericsFAQ.html&quot;&gt;Java Generics FAQ&lt;/a&gt; 참조 ). 그리고 Kotlin에는 없습니다. 대신 선언 사이트 분산과 형식 투영의 두 가지가 있습니다.</target>
        </trans-unit>
        <trans-unit id="38d02ab09e44aff951d70a40c329956aa2b8b363" translate="yes" xml:space="preserve">
          <source>One of the possible use cases of &lt;code&gt;provideDelegate&lt;/code&gt; is to check property consistency when the property is created, not only in its getter or setter.</source>
          <target state="translated">&lt;code&gt;provideDelegate&lt;/code&gt; 의 가능한 사용 사례 중 하나는 getter 또는 setter뿐만 아니라 속성을 만들 때 속성 일관성을 확인하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="8d4385a0374e1c5c7b6c1f784715b203768aadd3" translate="yes" xml:space="preserve">
          <source>One of the solutions would have been to report each exception separately, but then &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-deferred/await.html&quot;&gt;Deferred.await&lt;/a&gt; should have had the same mechanism to avoid behavioural inconsistency and this would cause implementation details of a coroutines (whether it had delegated parts of its work to its children or not) to leak to its exception handler.</source>
          <target state="translated">해결책 중 하나는 각 예외를 개별적으로보고하는 것이었지만 &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-deferred/await.html&quot;&gt;Deferred.await&lt;/a&gt; 는 동작 불일치를 피하기 위해 동일한 메커니즘을 가져야했으며 이는 코 루틴의 구현 세부 사항을 유발합니다 (작업의 일부를 하위 또는 하위에 위임했는지 여부) 예외 처리기로 누출되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="4682051378a5cd9287062ccfaa20c54f71557242" translate="yes" xml:space="preserve">
          <source>One other difference between lambda expressions and anonymous functions is the behavior of &lt;a href=&quot;inline-functions#non-local-returns&quot;&gt;non-local returns&lt;/a&gt;. A &lt;em&gt;return&lt;/em&gt; statement without a label always returns from the function declared with the &lt;em&gt;fun&lt;/em&gt; keyword. This means that a &lt;em&gt;return&lt;/em&gt; inside a lambda expression will return from the enclosing function, whereas a &lt;em&gt;return&lt;/em&gt; inside an anonymous function will return from the anonymous function itself.</source>
          <target state="translated">람다 식과 익명 함수의 또 다른 차이점은 &lt;a href=&quot;inline-functions#non-local-returns&quot;&gt;로컬&lt;/a&gt; 이 아닌 반환 동작입니다 . &lt;em&gt;반환&lt;/em&gt; 레이블이없는 문은 항상 함수의 반환은 선언 &lt;em&gt;재미있는&lt;/em&gt; 키워드. 것이 수단이 &lt;em&gt;복귀&lt;/em&gt; 반면 람다 식 내부가 클로징 함수로부터 반환 &lt;em&gt;창&lt;/em&gt; 익명 함수 내부 익명 함수 자체에서 복귀한다.</target>
        </trans-unit>
        <trans-unit id="f184b36bfb713e43fbfa93f50dceca8dadfd2966" translate="yes" xml:space="preserve">
          <source>One other thing to be discussed here is how we add text to tag bodies. In the example above we say something like:</source>
          <target state="translated">여기서 논의 할 또 다른 사항은 태그 본문에 텍스트를 추가하는 방법입니다. 위의 예에서 우리는 다음과 같이 말합니다.</target>
        </trans-unit>
        <trans-unit id="298f631b7015e52a7102aa3f6251e37e068b1948" translate="yes" xml:space="preserve">
          <source>One thing missing from the lambda expression syntax presented above is the ability to specify the return type of the function. In most cases, this is unnecessary because the return type can be inferred automatically. However, if you do need to specify it explicitly, you can use an alternative syntax: an &lt;em&gt;anonymous function&lt;/em&gt;.</source>
          <target state="translated">위에 제시된 람다 식 구문에서 누락 된 한 가지는 함수의 반환 유형을 지정하는 기능입니다. 대부분의 경우 반환 유형을 자동으로 유추 할 수 있으므로 불필요합니다. 그러나 명시 적으로 지정해야하는 경우 대체 구문 인 &lt;em&gt;익명 함수를&lt;/em&gt; 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="642728af0fb0800824d7dd9f4eab6562d33e66c6" translate="yes" xml:space="preserve">
          <source>Online Courses</source>
          <target state="translated">온라인 코스</target>
        </trans-unit>
        <trans-unit id="a56fd70563b4d9f0bebcf1cf95d7aaace3e6c084" translate="yes" xml:space="preserve">
          <source>Only &lt;code&gt;EXECUTABLE&lt;/code&gt; and &lt;code&gt;KLIBRARY&lt;/code&gt; binaries are published currently.</source>
          <target state="translated">&lt;code&gt;EXECUTABLE&lt;/code&gt; 및 &lt;code&gt;KLIBRARY&lt;/code&gt; 바이너리 만 현재 공개됩니다.</target>
        </trans-unit>
        <trans-unit id="da7677e45b190380bd45a6a9f12fa569b7b050cd" translate="yes" xml:space="preserve">
          <source>Only imports and declarations can exist at the top level of a Kotlin file. Therefore, &quot;running&quot; an individual file only makes sense if it contains an &lt;em&gt;entry point&lt;/em&gt;, which must be a function called &lt;code&gt;main&lt;/code&gt; with one argument called &lt;code&gt;args&lt;/code&gt; of the type &quot;array of strings&quot;. &lt;code&gt;args&lt;/code&gt; will contain the command-line arguments that the program is invoked with, similarly to &lt;code&gt;sys.argv&lt;/code&gt; in Python; it can be omitted if your program does not need to accept command-line arguments and you are using Kotlin 1.3:</source>
          <target state="translated">Kotlin 파일의 최상위 레벨에는 가져 오기 및 선언 만 존재할 수 있습니다. 따라서 개별 파일을 &quot;실행&quot;하는 것은 &lt;em&gt;진입 점이&lt;/em&gt; 포함 된 경우에만 의미 가 있으며, &quot;문자열 배열&quot;유형의 &lt;code&gt;args&lt;/code&gt; 라는 인수가있는 &lt;code&gt;main&lt;/code&gt; 이라는 함수 여야합니다 . &lt;code&gt;args&lt;/code&gt; 는 파이썬의 &lt;code&gt;sys.argv&lt;/code&gt; 와 유사하게 프로그램이 호출되는 명령 행 인수를 포함합니다 . 프로그램이 명령 행 인수를 승인 할 필요가없고 Kotlin 1.3을 사용중인 경우 생략 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d5acf06992dbc80a4d90b07667e54904a5303d8d" translate="yes" xml:space="preserve">
          <source>Only one parameter may be marked as &lt;code&gt;vararg&lt;/code&gt;. If a &lt;code&gt;vararg&lt;/code&gt; parameter is not the last one in the list, values for the following parameters can be passed using the named argument syntax, or, if the parameter has a function type, by passing a lambda outside parentheses.</source>
          <target state="translated">하나의 매개 변수 만 &lt;code&gt;vararg&lt;/code&gt; 로 표시 될 수 있습니다 . 경우 &lt;code&gt;vararg&lt;/code&gt; 파라미터는 상기 목록의 마지막 아니다 파라미터 람다 외부 괄호를 전달하여, 기능 타입을 갖는 경우, 다음과 같은 매개 변수의 값은 지정된 인자 구문을 사용하여 전달하거나 할 수있다.</target>
        </trans-unit>
        <trans-unit id="62ae003ddbe718dd1517100f12cc23341d88734f" translate="yes" xml:space="preserve">
          <source>Only the property &lt;code&gt;name&lt;/code&gt; will be used inside the &lt;code&gt;toString()&lt;/code&gt;, &lt;code&gt;equals()&lt;/code&gt;, &lt;code&gt;hashCode()&lt;/code&gt;, and &lt;code&gt;copy()&lt;/code&gt; implementations, and there will only be one component function &lt;code&gt;component1()&lt;/code&gt;. While two &lt;code&gt;Person&lt;/code&gt; objects can have different ages, they will be treated as equal.</source>
          <target state="translated">&lt;code&gt;toString()&lt;/code&gt; , &lt;code&gt;equals()&lt;/code&gt; , &lt;code&gt;hashCode()&lt;/code&gt; 및 &lt;code&gt;copy()&lt;/code&gt; 구현 내 에서는 속성 &lt;code&gt;name&lt;/code&gt; 만 사용되며 구성 요소 함수 &lt;code&gt;component1()&lt;/code&gt; 은 하나만 있습니다 . 두 &lt;code&gt;Person&lt;/code&gt; 객체는 연령이 다를 수 있지만 동일하게 취급됩니다.</target>
        </trans-unit>
        <trans-unit id="0991ef404e96f10fd9f12b53834c650d31c927f7" translate="yes" xml:space="preserve">
          <source>Only the top-level functions can have a contract for now.</source>
          <target state="translated">현재 최상위 기능 만 계약을 체결 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="44fceaa53bcd4e0959ad0f0959b849cd53bad4d8" translate="yes" xml:space="preserve">
          <source>Open &lt;code&gt;Task.kt&lt;/code&gt; file to write the code you want for the exercise:</source>
          <target state="translated">&lt;code&gt;Task.kt&lt;/code&gt; 파일을 열어 운동에 필요한 코드를 작성하십시오.</target>
        </trans-unit>
        <trans-unit id="7314b40c316a1f266ab17c79c1dbaa5efa312fc4" translate="yes" xml:space="preserve">
          <source>Open Android Studio and click &lt;strong&gt;Start a new Android Studio project&lt;/strong&gt; on the welcome screen or &lt;strong&gt;File | New | New project&lt;/strong&gt;.</source>
          <target state="translated">Android Studio를 열고 &lt;strong&gt;시작&lt;/strong&gt; 화면 또는 &lt;strong&gt;파일 | 새로운 | 새로운 프로젝트&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="91d2d6c25074dfcfb7cab43ab30e7f03b9fd3e52" translate="yes" xml:space="preserve">
          <source>Opening the Project in IDE</source>
          <target state="translated">IDE에서 프로젝트 열기</target>
        </trans-unit>
        <trans-unit id="066186e62ea684ac1212e026a26d571f981c4d5a" translate="yes" xml:space="preserve">
          <source>Operating system family program executes upon.</source>
          <target state="translated">운영 체제 제품군 프로그램이 실행됩니다.</target>
        </trans-unit>
        <trans-unit id="c791730b00e42caba4395b78632bfee149a435dc" translate="yes" xml:space="preserve">
          <source>Operating system family.</source>
          <target state="translated">운영 체제 제품군.</target>
        </trans-unit>
        <trans-unit id="a1fdaa6b2a846c8fcf18d414bf8c61db610eda6a" translate="yes" xml:space="preserve">
          <source>Operations</source>
          <target state="translated">Operations</target>
        </trans-unit>
        <trans-unit id="81a400d5fba1ee0821e50ecd6c5fe68fa3817f28" translate="yes" xml:space="preserve">
          <source>Operations described on these pages return their results without affecting the original collection. For example, a filtering operation produces a &lt;em&gt;new collection&lt;/em&gt; that contains all the elements matching the filtering predicate. Results of such operations should be either stored in variables, or used in some other way, for example, passed in other functions.</source>
          <target state="translated">이 페이지에 설명 된 작업은 원본 컬렉션에 영향을주지 않고 결과를 반환합니다. 예를 들어, 필터링 조작은 필터링 술어와 일치하는 모든 요소를 ​​포함 하는 &lt;em&gt;새 콜렉션&lt;/em&gt; 을 생성합니다 . 이러한 연산의 결과는 변수에 저장되거나 다른 방법으로 전달되어야합니다 (예 : 다른 함수에 전달).</target>
        </trans-unit>
        <trans-unit id="9bf7c09224d4e5f03f06eb1166a0d0d5843b1570" translate="yes" xml:space="preserve">
          <source>Operator overloading</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e90414358dbfff0a68e4eb5d68a16978cf197d5a" translate="yes" xml:space="preserve">
          <source>Operators</source>
          <target state="translated">Operators</target>
        </trans-unit>
        <trans-unit id="0caa6abe0a90ca66988bc7871ced1b5719175a43" translate="yes" xml:space="preserve">
          <source>Operators and Special Symbols</source>
          <target state="translated">연산자 및 특수 기호</target>
        </trans-unit>
        <trans-unit id="391a1d9fef3c27917074b6cfe64302d4a7548eb3" translate="yes" xml:space="preserve">
          <source>Operators and conversions for BigInteger and BigDecimal</source>
          <target state="translated">BigInteger 및 BigDecimal의 연산자 및 변환</target>
        </trans-unit>
        <trans-unit id="3a15cb4802d6a2f5087bc78f9d683b8a1c586e0c" translate="yes" xml:space="preserve">
          <source>OptionalExpectation</source>
          <target state="translated">OptionalExpectation</target>
        </trans-unit>
        <trans-unit id="a6a5dca52b1cba88b3d7679218fb5b6d2dfb1487" translate="yes" xml:space="preserve">
          <source>Optionally, a &lt;code&gt;mode&lt;/code&gt; parameter equal to &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.channels/-ticker-mode/-f-i-x-e-d_-d-e-l-a-y.html&quot;&gt;TickerMode.FIXED_DELAY&lt;/a&gt; can be specified to maintain a fixed delay between elements.</source>
          <target state="translated">선택적으로 요소 간 고정 지연을 유지하기 위해 &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.channels/-ticker-mode/-f-i-x-e-d_-d-e-l-a-y.html&quot;&gt;TickerMode.FIXED_DELAY와&lt;/a&gt; 같은 &lt;code&gt;mode&lt;/code&gt; 매개 변수를 지정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="81e695612c6b558fba4d69087c222c3508c30997" translate="yes" xml:space="preserve">
          <source>Options for compiler plugins</source>
          <target state="translated">컴파일러 플러그인 옵션</target>
        </trans-unit>
        <trans-unit id="d99a34cf6e89392af307d2da71942e282bd91e96" translate="yes" xml:space="preserve">
          <source>Options passed to the C compiler (used to analyze headers, such as preprocessor definitions) and the linker (used to link final executables) can be passed in the definition file as &lt;code&gt;compilerOpts&lt;/code&gt; and &lt;code&gt;linkerOpts&lt;/code&gt; respectively. For example</source>
          <target state="translated">C 컴파일러 (전 처리기 정의와 같은 헤더를 분석하는 데 사용됨) 및 링커 (최종 실행 파일을 연결하는 데 사용됨)에 전달 된 옵션은 각각 정의 파일에서 &lt;code&gt;compilerOpts&lt;/code&gt; 및 &lt;code&gt;linkerOpts&lt;/code&gt; 로 전달 될 수 있습니다 . 예를 들어</target>
        </trans-unit>
        <trans-unit id="bfefe272fa75c738fdc90c4c14d8bf8da5c74e2c" translate="yes" xml:space="preserve">
          <source>Or alternatively, even shorter:</source>
          <target state="translated">또는 더 짧게 :</target>
        </trans-unit>
        <trans-unit id="532bd8eaed87cda55870df17e6d9de316d9f4893" translate="yes" xml:space="preserve">
          <source>Or an entire package, which will bring in all the symbols from that package:</source>
          <target state="translated">또는 전체 패키지. 해당 패키지의 모든 기호를 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="84941468d72b41cd1e72e93f8755c37167fcb75c" translate="yes" xml:space="preserve">
          <source>Or commandline arguments: &lt;code&gt;-Xembed-bitcode&lt;/code&gt; (for release) and &lt;code&gt;-Xembed-bitcode-marker&lt;/code&gt; (debug)</source>
          <target state="translated">또는 명령 줄 인수 : &lt;code&gt;-Xembed-bitcode&lt;/code&gt; (릴리스) 및 &lt;code&gt;-Xembed-bitcode-marker&lt;/code&gt; (디버그)</target>
        </trans-unit>
        <trans-unit id="4a6904cf48807fd990ed6c31cef633f6c1c024ac" translate="yes" xml:space="preserve">
          <source>Or using the Gradle plugins DSL:</source>
          <target state="translated">또는 Gradle 플러그인 DSL을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="2a931f4319a05ea77891d9060114221f91b89607" translate="yes" xml:space="preserve">
          <source>Or you can fill in the right answer with the &lt;strong&gt;Bulb&lt;/strong&gt; icon:</source>
          <target state="translated">또는 &lt;strong&gt;전구&lt;/strong&gt; 아이콘으로 정답을 채울 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="00fcdda14949d42c1610edfba9ca80d41d59564f" translate="yes" xml:space="preserve">
          <source>Or:</source>
          <target state="translated">Or:</target>
        </trans-unit>
        <trans-unit id="d3ed86c1334d74f0ae883f47feef902d83b9d8c6" translate="yes" xml:space="preserve">
          <source>Ordering</source>
          <target state="translated">Ordering</target>
        </trans-unit>
        <trans-unit id="5f3c0a024546767e98619d4c704f350b22156152" translate="yes" xml:space="preserve">
          <source>Ordinary named value parameter.</source>
          <target state="translated">일반적인 명명 된 값 매개 변수.</target>
        </trans-unit>
        <trans-unit id="4869781b0f55f4c1037bf2910220d1e6f2a7ce09" translate="yes" xml:space="preserve">
          <source>OsFamily</source>
          <target state="translated">OsFamily</target>
        </trans-unit>
        <trans-unit id="959184f53e7b6600b042795548ffeee55d75c4c1" translate="yes" xml:space="preserve">
          <source>Other CI Server</source>
          <target state="translated">다른 CI 서버</target>
        </trans-unit>
        <trans-unit id="b22c85b9254408bacf27f231cb8b5205551c3cad" translate="yes" xml:space="preserve">
          <source>Other Language Features</source>
          <target state="translated">다른 언어 기능</target>
        </trans-unit>
        <trans-unit id="b9e470b1de14eca892c5fa77e2ebfe8529930c48" translate="yes" xml:space="preserve">
          <source>Other citations of this sort:</source>
          <target state="translated">이런 종류의 다른 인용 :</target>
        </trans-unit>
        <trans-unit id="1f6194122ceb6cecad3809ca5a924ada067e2d97" translate="yes" xml:space="preserve">
          <source>Other collection operations are declared as extension functions. These are filtering, transformation, ordering, and other collection processing functions.</source>
          <target state="translated">다른 수집 작업은 확장 함수로 선언됩니다. 이들은 필터링, 변환, 순서 및 기타 수집 처리 기능입니다.</target>
        </trans-unit>
        <trans-unit id="126d7a1bf7e54d2a4bf4a9c0419a29fe417ffdb3" translate="yes" xml:space="preserve">
          <source>Other issues caused by external Java code.</source>
          <target state="translated">외부 Java 코드로 인한 기타 문제</target>
        </trans-unit>
        <trans-unit id="16cfd92afd47d77c945ee46ac4fb8ac72dfa3d58" translate="yes" xml:space="preserve">
          <source>Other language features</source>
          <target state="translated">다른 언어 기능</target>
        </trans-unit>
        <trans-unit id="d2503fbe45c5caffb865ef91cb9bcd7c9e6bde78" translate="yes" xml:space="preserve">
          <source>Other supported cases include acquiring a Java getter/setter method or a backing field for a Kotlin property, a &lt;code&gt;KProperty&lt;/code&gt; for a Java field, a Java method or constructor for a &lt;code&gt;KFunction&lt;/code&gt; and vice versa.</source>
          <target state="translated">기타 지원 코 틀린 경우는 등록하는 자바 게터 / 세터 법 배면 필드를 획득하는 것을 포함하는 &lt;code&gt;KProperty&lt;/code&gt; 자바 필드 들면위한 자바 메소드 또는 생성자 &lt;code&gt;KFunction&lt;/code&gt; 반대로 그 반대.</target>
        </trans-unit>
        <trans-unit id="8d5454be13e8e63af0393432029da696ce74c13c" translate="yes" xml:space="preserve">
          <source>Otherwise, the return value of the &lt;a href=&quot;suspend-coroutine-or-return#kotlin.coroutines.experimental.intrinsics%24suspendCoroutineOrReturn%28kotlin.Function1%28%28kotlin.coroutines.experimental.Continuation%28%28kotlin.coroutines.experimental.intrinsics.suspendCoroutineOrReturn.T%29%29%2C+kotlin.Any%29%29%29%2Fblock&quot;&gt;block&lt;/a&gt; must have a type assignable to &lt;a href=&quot;suspend-coroutine-or-return#T&quot;&gt;T&lt;/a&gt; and represents the result of this suspend function. It means that the execution was not suspended and the &lt;a href=&quot;../kotlin.coroutines.experimental/-continuation/index&quot;&gt;Continuation&lt;/a&gt; provided to the &lt;a href=&quot;suspend-coroutine-or-return#kotlin.coroutines.experimental.intrinsics%24suspendCoroutineOrReturn%28kotlin.Function1%28%28kotlin.coroutines.experimental.Continuation%28%28kotlin.coroutines.experimental.intrinsics.suspendCoroutineOrReturn.T%29%29%2C+kotlin.Any%29%29%29%2Fblock&quot;&gt;block&lt;/a&gt; shall not be invoked. As the result type of the &lt;a href=&quot;suspend-coroutine-or-return#kotlin.coroutines.experimental.intrinsics%24suspendCoroutineOrReturn%28kotlin.Function1%28%28kotlin.coroutines.experimental.Continuation%28%28kotlin.coroutines.experimental.intrinsics.suspendCoroutineOrReturn.T%29%29%2C+kotlin.Any%29%29%29%2Fblock&quot;&gt;block&lt;/a&gt; is declared as &lt;code&gt;Any?&lt;/code&gt; and cannot be correctly type-checked, its proper return type remains on the conscience of the suspend function's author.</source>
          <target state="translated">그렇지 않으면 &lt;a href=&quot;suspend-coroutine-or-return#kotlin.coroutines.experimental.intrinsics%24suspendCoroutineOrReturn%28kotlin.Function1%28%28kotlin.coroutines.experimental.Continuation%28%28kotlin.coroutines.experimental.intrinsics.suspendCoroutineOrReturn.T%29%29%2C+kotlin.Any%29%29%29%2Fblock&quot;&gt;블록&lt;/a&gt; 의 반환 값에 &lt;a href=&quot;suspend-coroutine-or-return#T&quot;&gt;T에&lt;/a&gt; 할당 할 수있는 유형이 있어야하며이 일시 중단 기능의 결과를 나타냅니다. 실행이 일시 중단되지 않았 으며 &lt;a href=&quot;suspend-coroutine-or-return#kotlin.coroutines.experimental.intrinsics%24suspendCoroutineOrReturn%28kotlin.Function1%28%28kotlin.coroutines.experimental.Continuation%28%28kotlin.coroutines.experimental.intrinsics.suspendCoroutineOrReturn.T%29%29%2C+kotlin.Any%29%29%29%2Fblock&quot;&gt;블록에&lt;/a&gt; 제공된 &lt;a href=&quot;../kotlin.coroutines.experimental/-continuation/index&quot;&gt;연속&lt;/a&gt; 이 호출되지 않음을 의미합니다. 의 결과 유형으로 &lt;a href=&quot;suspend-coroutine-or-return#kotlin.coroutines.experimental.intrinsics%24suspendCoroutineOrReturn%28kotlin.Function1%28%28kotlin.coroutines.experimental.Continuation%28%28kotlin.coroutines.experimental.intrinsics.suspendCoroutineOrReturn.T%29%29%2C+kotlin.Any%29%29%29%2Fblock&quot;&gt;블록&lt;/a&gt; 으로 선언 된 &lt;code&gt;Any?&lt;/code&gt; 올바르게 유형을 확인할 수없는 경우 올바른 반환 유형은 일시 중단 기능 작성자의 양심에 남아 있습니다.</target>
        </trans-unit>
        <trans-unit id="0de4f3d3a643debaa8825b8903404f8fc938727d" translate="yes" xml:space="preserve">
          <source>Otherwise, the return value of the &lt;a href=&quot;suspend-coroutine-unintercepted-or-return#kotlin.coroutines.intrinsics%24suspendCoroutineUninterceptedOrReturn%28kotlin.Function1%28%28kotlin.coroutines.Continuation%28%28kotlin.coroutines.intrinsics.suspendCoroutineUninterceptedOrReturn.T%29%29%2C+kotlin.Any%29%29%29%2Fblock&quot;&gt;block&lt;/a&gt; must have a type assignable to &lt;a href=&quot;suspend-coroutine-unintercepted-or-return#T&quot;&gt;T&lt;/a&gt; and represents the result of this suspend function. It means that the execution was not suspended and the &lt;a href=&quot;../kotlin.coroutines/-continuation/index&quot;&gt;Continuation&lt;/a&gt; provided to the &lt;a href=&quot;suspend-coroutine-unintercepted-or-return#kotlin.coroutines.intrinsics%24suspendCoroutineUninterceptedOrReturn%28kotlin.Function1%28%28kotlin.coroutines.Continuation%28%28kotlin.coroutines.intrinsics.suspendCoroutineUninterceptedOrReturn.T%29%29%2C+kotlin.Any%29%29%29%2Fblock&quot;&gt;block&lt;/a&gt; shall not be invoked. As the result type of the &lt;a href=&quot;suspend-coroutine-unintercepted-or-return#kotlin.coroutines.intrinsics%24suspendCoroutineUninterceptedOrReturn%28kotlin.Function1%28%28kotlin.coroutines.Continuation%28%28kotlin.coroutines.intrinsics.suspendCoroutineUninterceptedOrReturn.T%29%29%2C+kotlin.Any%29%29%29%2Fblock&quot;&gt;block&lt;/a&gt; is declared as &lt;code&gt;Any?&lt;/code&gt; and cannot be correctly type-checked, its proper return type remains on the conscience of the suspend function's author.</source>
          <target state="translated">그렇지 않으면 &lt;a href=&quot;suspend-coroutine-unintercepted-or-return#kotlin.coroutines.intrinsics%24suspendCoroutineUninterceptedOrReturn%28kotlin.Function1%28%28kotlin.coroutines.Continuation%28%28kotlin.coroutines.intrinsics.suspendCoroutineUninterceptedOrReturn.T%29%29%2C+kotlin.Any%29%29%29%2Fblock&quot;&gt;블록&lt;/a&gt; 의 반환 값에 &lt;a href=&quot;suspend-coroutine-unintercepted-or-return#T&quot;&gt;T에&lt;/a&gt; 할당 할 수있는 유형이 있어야하며이 일시 중단 기능의 결과를 나타냅니다. 실행이 일시 중단되지 않았 으며 &lt;a href=&quot;suspend-coroutine-unintercepted-or-return#kotlin.coroutines.intrinsics%24suspendCoroutineUninterceptedOrReturn%28kotlin.Function1%28%28kotlin.coroutines.Continuation%28%28kotlin.coroutines.intrinsics.suspendCoroutineUninterceptedOrReturn.T%29%29%2C+kotlin.Any%29%29%29%2Fblock&quot;&gt;블록에&lt;/a&gt; 제공된 &lt;a href=&quot;../kotlin.coroutines/-continuation/index&quot;&gt;연속&lt;/a&gt; 이 호출되지 않음을 의미합니다. 의 결과 유형으로 &lt;a href=&quot;suspend-coroutine-unintercepted-or-return#kotlin.coroutines.intrinsics%24suspendCoroutineUninterceptedOrReturn%28kotlin.Function1%28%28kotlin.coroutines.Continuation%28%28kotlin.coroutines.intrinsics.suspendCoroutineUninterceptedOrReturn.T%29%29%2C+kotlin.Any%29%29%29%2Fblock&quot;&gt;블록&lt;/a&gt; 으로 선언 된 &lt;code&gt;Any?&lt;/code&gt; 올바르게 유형을 확인할 수없는 경우 올바른 반환 유형은 일시 중단 기능 작성자의 양심에 남아 있습니다.</target>
        </trans-unit>
        <trans-unit id="80332318434bec9b581b702805f0a6036697bbb7" translate="yes" xml:space="preserve">
          <source>Otherwise, the structural equality is used, which disagrees with the standard so that &lt;code&gt;NaN&lt;/code&gt; is equal to itself, and &lt;code&gt;-0.0&lt;/code&gt; is not equal to &lt;code&gt;0.0&lt;/code&gt;.</source>
          <target state="translated">그렇지 않으면, 구조적 평등이 사용되는데, 이는 &lt;code&gt;NaN&lt;/code&gt; 이 그 자체와 같고 &lt;code&gt;-0.0&lt;/code&gt; 이 &lt;code&gt;0.0&lt;/code&gt; 과 같지 않도록 표준에 동의하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="cb380427bcdf9e2288105dd3444ff34884f91949" translate="yes" xml:space="preserve">
          <source>Otherwise, try to generate code for &lt;code&gt;a = a + b&lt;/code&gt; (this includes a type check: the type of &lt;code&gt;a + b&lt;/code&gt; must be a subtype of &lt;code&gt;a&lt;/code&gt;).</source>
          <target state="translated">그렇지 않으면 &lt;code&gt;a = a + b&lt;/code&gt; 대한 코드를 생성하십시오 (유형 검사 포함 : &lt;code&gt;a + b&lt;/code&gt; 의 유형은 &lt;code&gt;a&lt;/code&gt; 의 하위 유형이어야 함 ).</target>
        </trans-unit>
        <trans-unit id="c4519fbda5213ca8ee3068e92e2d8eeb9a0128d9" translate="yes" xml:space="preserve">
          <source>Our &lt;code&gt;build.gradle&lt;/code&gt; file should look like the following</source>
          <target state="translated">우리 &lt;code&gt;build.gradle&lt;/code&gt; 의 파일은 다음과 같아야합니다</target>
        </trans-unit>
        <trans-unit id="adbbd30ddb3bdecc114802621e11ef40e9d64175" translate="yes" xml:space="preserve">
          <source>Our &lt;code&gt;workload()&lt;/code&gt; function can be called from a coroutine (or another suspending function), but &lt;em&gt;can not&lt;/em&gt; be called from outside a coroutine. Naturally, &lt;code&gt;delay()&lt;/code&gt; and &lt;code&gt;await()&lt;/code&gt; that we used above are themselves declared as &lt;code&gt;suspend&lt;/code&gt;, and this is why we had to put them inside &lt;code&gt;runBlocking {}&lt;/code&gt;, &lt;code&gt;launch {}&lt;/code&gt; or &lt;code&gt;async {}&lt;/code&gt;.</source>
          <target state="translated">우리의 &lt;code&gt;workload()&lt;/code&gt; 함수는 코 루틴 (또는 다른 일시 중단 함수)에서 호출 &lt;em&gt;할 수&lt;/em&gt; 있지만 코 루틴 외부에서는 호출 &lt;em&gt;할 수 없습니다&lt;/em&gt; . 당연히, 위에서 사용한 &lt;code&gt;delay()&lt;/code&gt; 와 &lt;code&gt;await()&lt;/code&gt; 는 스스로 &lt;code&gt;suspend&lt;/code&gt; 로 선언 되었기 때문에 &lt;code&gt;runBlocking {}&lt;/code&gt; , &lt;code&gt;launch {}&lt;/code&gt; 또는 &lt;code&gt;async {}&lt;/code&gt; 안에 넣어야했습니다 .</target>
        </trans-unit>
        <trans-unit id="7460360fa1bf50529b473bc85864ff382d98b93c" translate="yes" xml:space="preserve">
          <source>Our JS implementation will be very similar to the JVM one. We create a file &lt;code&gt;Base64.kt&lt;/code&gt; in &lt;code&gt;jsMain/kotlin/jetbrains/base64&lt;/code&gt; and provide an implementation which delegates to NodeJS &lt;code&gt;Buffer&lt;/code&gt; API:</source>
          <target state="translated">JS 구현은 JVM과 매우 유사합니다. 우리는 파일 생성 &lt;code&gt;Base64.kt&lt;/code&gt; 에서 &lt;code&gt;jsMain/kotlin/jetbrains/base64&lt;/code&gt; 및 구현을 제공하는 NodeJS 대의원 &lt;code&gt;Buffer&lt;/code&gt; API :</target>
        </trans-unit>
        <trans-unit id="0ab5b1cc96e82694a219ee123e8bd14970db091a" translate="yes" xml:space="preserve">
          <source>Our Library Functions</source>
          <target state="translated">우리 도서관 기능</target>
        </trans-unit>
        <trans-unit id="0625d1616b84e58f7d2be19de1e6f136e6542f1c" translate="yes" xml:space="preserve">
          <source>Our code to call functions with pointers will look like this:</source>
          <target state="translated">포인터로 함수를 호출하는 코드는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="82b08dc063f75e99580fde46838e1e3a9e711f19" translate="yes" xml:space="preserve">
          <source>Our factory is marked with the &lt;code&gt;expect&lt;/code&gt; keyword. &lt;code&gt;expect&lt;/code&gt; is a mechanism to define a requirement, which every platform should provide in order for the common part to work properly. So on each platform we should provide the &lt;code&gt;actual&lt;/code&gt;&lt;code&gt;Base64Factory&lt;/code&gt; which knows how to create the platform-specific encoder. You can read more about platform specific declarations &lt;a href=&quot;../reference/platform-specific-declarations&quot;&gt;here&lt;/a&gt;.</source>
          <target state="translated">우리 공장에는 &lt;code&gt;expect&lt;/code&gt; 키워드 가 표시되어 있습니다. &lt;code&gt;expect&lt;/code&gt; 는 공통 부품이 제대로 작동하기 위해 모든 플랫폼이 제공해야하는 요구 사항을 정의하는 메커니즘입니다. 따라서 각 플랫폼 에서 플랫폼 별 인코더를 만드는 방법을 알고 있는 &lt;code&gt;actual&lt;/code&gt; &lt;code&gt;Base64Factory&lt;/code&gt; 를 제공해야합니다 . 플랫폼 별 선언에 대한 자세한 내용은 &lt;a href=&quot;../reference/platform-specific-declarations&quot;&gt;여기를 참조하십시오&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="9618079b890493b724f82c893c8117a26cd9973f" translate="yes" xml:space="preserve">
          <source>Our first application is simply going to print some text on the standard output. In our case, this text is &quot;Hello Kotlin/Native&quot;. We can open up our favorite IDE or editor and write the following code in a file named &lt;code&gt;hello.kt&lt;/code&gt;:</source>
          <target state="translated">우리의 첫 번째 응용 프로그램은 단순히 표준 출력에 텍스트를 인쇄하는 것입니다. 이 경우이 텍스트는 &quot;Hello Kotlin / Native&quot;입니다. 자주 사용하는 IDE 또는 편집기를 열고 &lt;code&gt;hello.kt&lt;/code&gt; 파일에 다음 코드를 작성할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="94bfc3111bbdf55e54097cc4c8b45667119c21af" translate="yes" xml:space="preserve">
          <source>Our first multiplatform library is almost ready. The last step is to publish it, so other projects can then depend on our library. To make the publishing mechanism work, you should enable the experimental Gradle feature in &lt;code&gt;settings.gradle&lt;/code&gt;:</source>
          <target state="translated">첫 번째 멀티 플랫폼 라이브러리가 거의 준비되었습니다. 마지막 단계는이를 게시하는 것이므로 다른 프로젝트는 라이브러리에 의존 할 수 있습니다. 게시 메커니즘을 작동 시키려면 &lt;code&gt;settings.gradle&lt;/code&gt; 에서 실험적 Gradle 기능을 활성화해야합니다 .</target>
        </trans-unit>
        <trans-unit id="95dbdf808fd430fab749c0243fcb9f04f2b77f95" translate="yes" xml:space="preserve">
          <source>Our goal is to build a small multiplatform library to demonstrate the ability to share the code between the platforms and its benefits. In order to have a small implementation to focus on the multiplatform machinery, we will write a library which converts raw data (strings and byte arrays) to the &lt;a href=&quot;https://en.wikipedia.org/wiki/Base64&quot;&gt;Base64&lt;/a&gt; format which can be used on JVM, JS, and any available K/N platform. On JVM implementation will be using &lt;a href=&quot;https://docs.oracle.com/javase/8/docs/api/java/util/Base64.html&quot;&gt;&lt;code&gt;java.util.Base64&lt;/code&gt;&lt;/a&gt; which is known to be extremely efficient because JVM is aware of this particular class and compiles it in a special way. On JS we will be using the native &lt;a href=&quot;https://nodejs.org/docs/latest/api/buffer.html&quot;&gt;Buffer&lt;/a&gt; API and on Kotlin/Native we will write our own implementation. We will cover this functionality with common tests and then publish the resulting library to Maven.</source>
          <target state="translated">우리의 목표는 작은 멀티 플랫폼 라이브러리를 구축하여 플랫폼과 코드간에 코드를 공유하는 기능을 보여주는 것입니다. 멀티 플랫폼 기계에 중점을 둔 작은 구현을 위해 원시 데이터 (문자열 및 바이트 배열)를 &lt;a href=&quot;https://en.wikipedia.org/wiki/Base64&quot;&gt;Base64&lt;/a&gt; 형식으로 변환하는 라이브러리를 작성하여 JVM, JS 및 사용 가능한 K / N 플랫폼에서 사용할 수 있습니다. JVM 구현 에서는 JVM이이 특정 클래스를 인식하고 특수한 방식으로 컴파일하기 때문에 매우 효율적인 것으로 알려진 &lt;a href=&quot;https://docs.oracle.com/javase/8/docs/api/java/util/Base64.html&quot;&gt; &lt;code&gt;java.util.Base64&lt;/code&gt; &lt;/a&gt; 를 사용 합니다. JS에서는 네이티브 &lt;a href=&quot;https://nodejs.org/docs/latest/api/buffer.html&quot;&gt;버퍼&lt;/a&gt; API를 사용하고 Kotlin / Native에서는 자체 구현을 작성합니다. 이 기능을 일반적인 테스트로 다루고 결과 라이브러리를 Maven에 게시합니다.</target>
        </trans-unit>
        <trans-unit id="28e418729eb2ef55e18bb9c364e7664f07141956" translate="yes" xml:space="preserve">
          <source>Our goal of this tutorial is to demonstrate the ability to share code within Kotlin and the benefits it provides. While what we'll be looking at is a simplified application, what is shown here can be applied to real world applications, independent of their size or complexity.</source>
          <target state="translated">이 튜토리얼의 목표는 Kotlin 내에서 코드를 공유하는 기능과 그 이점을 설명하는 것입니다. 우리가 살펴볼 것은 간단한 응용 프로그램이지만 여기에 표시된 내용은 크기 나 복잡성에 관계없이 실제 응용 프로그램에 적용 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4e88e8917a2f0fd2340eeca26b8e09a5c15c5c1b" translate="yes" xml:space="preserve">
          <source>OutOfMemoryError</source>
          <target state="translated">OutOfMemoryError</target>
        </trans-unit>
        <trans-unit id="2ea2bd35ad59a2939c5dcd7aeb754e6a11bc0c9c" translate="yes" xml:space="preserve">
          <source>Output file path</source>
          <target state="translated">출력 파일 경로</target>
        </trans-unit>
        <trans-unit id="4e314e13bdbb2fd6cd6b6a8ef78fddfab3a9b341" translate="yes" xml:space="preserve">
          <source>Output kinds</source>
          <target state="translated">출력 종류</target>
        </trans-unit>
        <trans-unit id="8d54e195aea506e4a8eb397299d73595ce957ff6" translate="yes" xml:space="preserve">
          <source>Output kinds (e.g. executable, library, framework etc)</source>
          <target state="translated">출력 종류 (예 : 실행 파일, 라이브러리, 프레임 워크 등)</target>
        </trans-unit>
        <trans-unit id="691402679267af452a6063a6c55ee9c23954ac22" translate="yes" xml:space="preserve">
          <source>Output kinds can also be specified using a special property:</source>
          <target state="translated">특수 속성을 사용하여 출력 종류를 지정할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="4172d77e28118d4345ad2b9c32b7c79ad5281e26" translate="yes" xml:space="preserve">
          <source>Overall, multiplatform is not about compiling all code for all platforms. This model has its obvious limitations, and we understand that modern applications need access to unique features of the platforms they are running on. Kotlin doesn't limit you to the common subset of all APIs in the world. Every component can share as much code as needed with others but can access platform APIs at any time through the &lt;a href=&quot;platform-specific-declarations&quot;&gt;&lt;code&gt;expect&lt;/code&gt;/&lt;code&gt;actual&lt;/code&gt; mechanism&lt;/a&gt; provided by the language.</source>
          <target state="translated">전반적으로 멀티 플랫폼은 모든 플랫폼의 모든 코드를 컴파일하는 것이 아닙니다. 이 모델에는 명백한 한계가 있으며, 최신 애플리케이션은 실행중인 플랫폼의 고유 한 기능에 액세스해야한다는 것을 알고 있습니다. Kotlin은 전 세계 모든 API의 공통 하위 집합으로 제한하지 않습니다. 모든 구성 요소는 다른 구성 요소와 필요한만큼 많은 코드를 공유 할 수 있지만 언어에서 제공 하는 &lt;a href=&quot;platform-specific-declarations&quot;&gt; &lt;code&gt;expect&lt;/code&gt; / &lt;code&gt;actual&lt;/code&gt; 메커니즘을&lt;/a&gt; 통해 언제든지 플랫폼 API에 액세스 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7985f98f2e4e8de528bf2f20b91d10b65fb5b978" translate="yes" xml:space="preserve">
          <source>OverconstrainedErrorEventInit</source>
          <target state="translated">OverconstrainedErrorEventInit</target>
        </trans-unit>
        <trans-unit id="c952d0b1979fee4876fed3b2bae9f5ed565aaabe" translate="yes" xml:space="preserve">
          <source>Overload layout</source>
          <target state="translated">과부하 레이아웃</target>
        </trans-unit>
        <trans-unit id="3e7d88ee10c3c15b721eb8187cd87f4643715ad2" translate="yes" xml:space="preserve">
          <source>Overloaded functions and properties provided by the same library should do essentially the same thing. Changes in type inference may result in more precise static types to be known at call sites causing changes in overload resolution.</source>
          <target state="translated">동일한 라이브러리에서 제공하는 오버로드 된 함수 및 속성은 기본적으로 동일한 기능을 수행해야합니다. 유형 유추의 변경으로 인해 호출 사이트에서보다 정확한 정적 유형을 알 수있어 과부하 해결이 변경 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="cb2f163ccc20cb7388203cf1edbc6860b44ea0f0" translate="yes" xml:space="preserve">
          <source>Overloading</source>
          <target state="translated">Overloading</target>
        </trans-unit>
        <trans-unit id="e6b45b9a5e179e49e414143db015c18fc536c9e5" translate="yes" xml:space="preserve">
          <source>Overloads generation</source>
          <target state="translated">과부하 생성</target>
        </trans-unit>
        <trans-unit id="da5b2097ee60b501632c6242ff39b9bd62ccc1fa" translate="yes" xml:space="preserve">
          <source>OverrideInit</source>
          <target state="translated">OverrideInit</target>
        </trans-unit>
        <trans-unit id="945393d320ad2e84b266063f79c1d098c79b4bbb" translate="yes" xml:space="preserve">
          <source>Overrides &lt;a href=&quot;../-abstract-mutable-list/remove-range&quot;&gt;AbstractMutableList.removeRange&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;../-abstract-mutable-list/remove-range&quot;&gt;AbstractMutableList.removeRange을 (를)&lt;/a&gt; 재정의 함</target>
        </trans-unit>
        <trans-unit id="0412fb2e7e855fc5b71c429e7e8296c4512d1ddd" translate="yes" xml:space="preserve">
          <source>Overrides &lt;a href=&quot;../-collection/contains&quot;&gt;Collection.contains&lt;/a&gt;</source>
          <target state="translated">오버라이드 (override) &lt;a href=&quot;../-collection/contains&quot;&gt;Collection.contains&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="e14d55c91b7965c1d6d631c1d07de9fa97080766" translate="yes" xml:space="preserve">
          <source>Overrides &lt;a href=&quot;../-collection/contains-all&quot;&gt;Collection.containsAll&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;../-collection/contains-all&quot;&gt;Collection.containsAll을 (를)&lt;/a&gt; 재정의 함</target>
        </trans-unit>
        <trans-unit id="2ad0612dea8eaabf434ce52e7c783f5c48e2fddd" translate="yes" xml:space="preserve">
          <source>Overrides &lt;a href=&quot;../-collection/is-empty&quot;&gt;Collection.isEmpty&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;../-collection/is-empty&quot;&gt;Collection.isEmpty을 (를)&lt;/a&gt; 재정의 함</target>
        </trans-unit>
        <trans-unit id="d8395525fedec5005642af530ca89906f16d5c31" translate="yes" xml:space="preserve">
          <source>Overrides &lt;a href=&quot;../-collection/size&quot;&gt;Collection.size&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;../-collection/size&quot;&gt;Collection.size을 (를)&lt;/a&gt; 재정의 함</target>
        </trans-unit>
        <trans-unit id="c1bc61ce06e0fb2fbb1ac1456d5615e48f2ac19c" translate="yes" xml:space="preserve">
          <source>Overrides &lt;a href=&quot;../-comparable/compare-to&quot;&gt;Comparable.compareTo&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;../-comparable/compare-to&quot;&gt;Comparable.compareTo을 (를)&lt;/a&gt; 재정의 함</target>
        </trans-unit>
        <trans-unit id="1459fd426ebdbfd085b335b7740dd0d1604898aa" translate="yes" xml:space="preserve">
          <source>Overrides &lt;a href=&quot;../-hash-map/create-entry-set&quot;&gt;HashMap.createEntrySet&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;../-hash-map/create-entry-set&quot;&gt;HashMap.createEntrySet을 (를)&lt;/a&gt; 재정의 함</target>
        </trans-unit>
        <trans-unit id="505ce4c5312a657ad2db2ad4fea4db1bac36448a" translate="yes" xml:space="preserve">
          <source>Overrides &lt;a href=&quot;../-list/contains-all&quot;&gt;List.containsAll&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;../-list/contains-all&quot;&gt;List.containsAll을 (를)&lt;/a&gt; 재정의 함</target>
        </trans-unit>
        <trans-unit id="28eb9265deb1aca2369498234fa6e7ab3b001351" translate="yes" xml:space="preserve">
          <source>Overrides &lt;a href=&quot;../-list/is-empty&quot;&gt;List.isEmpty&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;../-list/is-empty&quot;&gt;List.isEmpty을 (를)&lt;/a&gt; 재정의 함</target>
        </trans-unit>
        <trans-unit id="c04e861e843e37f9b39e84afa025cedf23f0ed4f" translate="yes" xml:space="preserve">
          <source>Overrides &lt;a href=&quot;../-map/contains-key&quot;&gt;Map.containsKey&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;../-map/contains-key&quot;&gt;Map.containsKey을 (를)&lt;/a&gt; 재정의 함</target>
        </trans-unit>
        <trans-unit id="e53018f590dae1ff51f24c1f87b670d484b8f15a" translate="yes" xml:space="preserve">
          <source>Overrides &lt;a href=&quot;../-map/contains-value&quot;&gt;Map.containsValue&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;../-map/contains-value&quot;&gt;Map.containsValue을 (를)&lt;/a&gt; 재정의 함</target>
        </trans-unit>
        <trans-unit id="cfe3ee98c24d2eafcfa0a1b7987dfb17585cc22b" translate="yes" xml:space="preserve">
          <source>Overrides &lt;a href=&quot;../-map/get&quot;&gt;Map.get&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;../-map/get&quot;&gt;Map.get을&lt;/a&gt; 대체 합니다.</target>
        </trans-unit>
        <trans-unit id="f7c1b304b14830a9f0f416fe6b1b545a7f67fb53" translate="yes" xml:space="preserve">
          <source>Overrides &lt;a href=&quot;../-map/is-empty&quot;&gt;Map.isEmpty&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;../-map/is-empty&quot;&gt;Map.isEmpty을 (를)&lt;/a&gt; 재정의 함</target>
        </trans-unit>
        <trans-unit id="7c9545ba01bf1ee531740e0b11ca9b68428d91ec" translate="yes" xml:space="preserve">
          <source>Overrides &lt;a href=&quot;../-map/size&quot;&gt;Map.size&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;../-map/size&quot;&gt;Map.size를&lt;/a&gt; 재정의</target>
        </trans-unit>
        <trans-unit id="3810cd8fb4b8df070f0c23138c79569b47ec271b" translate="yes" xml:space="preserve">
          <source>Overrides &lt;a href=&quot;../-mutable-collection/iterator&quot;&gt;MutableCollection.iterator&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;../-mutable-collection/iterator&quot;&gt;MutableCollection.iterator을 (를)&lt;/a&gt; 재정의 함</target>
        </trans-unit>
        <trans-unit id="a16c6d97eeab4cc2591210ac7d932680db232505" translate="yes" xml:space="preserve">
          <source>Overrides &lt;a href=&quot;../-mutable-list/add-all&quot;&gt;MutableList.addAll&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;../-mutable-list/add-all&quot;&gt;MutableList.addAll을 (를)&lt;/a&gt; 재정의 함</target>
        </trans-unit>
        <trans-unit id="ada0d5a0992424195238c6fd7c187d4766c440c7" translate="yes" xml:space="preserve">
          <source>Overrides &lt;a href=&quot;../-mutable-list/remove&quot;&gt;MutableList.remove&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;../-mutable-list/remove&quot;&gt;MutableList.remove을 (를)&lt;/a&gt; 재정의 함</target>
        </trans-unit>
        <trans-unit id="bc669baa4972bad392b7374e99e00a2abfded1a1" translate="yes" xml:space="preserve">
          <source>Overrides &lt;a href=&quot;../-mutable-map/entries&quot;&gt;MutableMap.entries&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;../-mutable-map/entries&quot;&gt;MutableMap.entries을 (를)&lt;/a&gt; 재정의 함</target>
        </trans-unit>
        <trans-unit id="c79ad03c13d000b71f177595ec492a2c28395c7c" translate="yes" xml:space="preserve">
          <source>Overrides &lt;a href=&quot;../-mutable-map/keys&quot;&gt;MutableMap.keys&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;../-mutable-map/keys&quot;&gt;MutableMap.keys을 (를)&lt;/a&gt; 재정의 함</target>
        </trans-unit>
        <trans-unit id="5b4898ab832f11850009ac41b011794ef75cd869" translate="yes" xml:space="preserve">
          <source>Overrides &lt;a href=&quot;../-mutable-map/put-all&quot;&gt;MutableMap.putAll&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;../-mutable-map/put-all&quot;&gt;MutableMap.putAll을 (를)&lt;/a&gt; 재정의 함</target>
        </trans-unit>
        <trans-unit id="cec29412680bec28164c0fe1f70dd087fad233d4" translate="yes" xml:space="preserve">
          <source>Overrides &lt;a href=&quot;../-mutable-map/values&quot;&gt;MutableMap.values&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;../-mutable-map/values&quot;&gt;MutableMap.values를&lt;/a&gt; 재정의 합니다.</target>
        </trans-unit>
        <trans-unit id="ed46cf9a43917b66a54752db98f6e6b09e0df162" translate="yes" xml:space="preserve">
          <source>Overrides &lt;a href=&quot;../-mutable-set/add&quot;&gt;MutableSet.add&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;../-mutable-set/add&quot;&gt;MutableSet.add을 (를)&lt;/a&gt; 재정의 함</target>
        </trans-unit>
        <trans-unit id="dcf426c10d6d909d196a9b9f3bb5c61847249c1e" translate="yes" xml:space="preserve">
          <source>Overrides &lt;a href=&quot;../-mutable-set/add-all&quot;&gt;MutableSet.addAll&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;../-mutable-set/add-all&quot;&gt;MutableSet.addAll을 (를)&lt;/a&gt; 재정의 함</target>
        </trans-unit>
        <trans-unit id="c002bcae05fefbc9d774039c0200e1713b4fb644" translate="yes" xml:space="preserve">
          <source>Overrides &lt;a href=&quot;../-mutable-set/clear&quot;&gt;MutableSet.clear&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;../-mutable-set/clear&quot;&gt;MutableSet.clear을 (를)&lt;/a&gt; 재정의 함</target>
        </trans-unit>
        <trans-unit id="e205316a797cc598058f2ad91e62f19dc98b0380" translate="yes" xml:space="preserve">
          <source>Overrides &lt;a href=&quot;../-mutable-set/iterator&quot;&gt;MutableSet.iterator&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;../-mutable-set/iterator&quot;&gt;MutableSet.iterator을 (를)&lt;/a&gt; 재정의 함</target>
        </trans-unit>
        <trans-unit id="6eefd798285aa9425a8b6f34535ea9d116cd7648" translate="yes" xml:space="preserve">
          <source>Overrides &lt;a href=&quot;../-mutable-set/remove&quot;&gt;MutableSet.remove&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;../-mutable-set/remove&quot;&gt;MutableSet.remove을 (를)&lt;/a&gt; 재정의 함</target>
        </trans-unit>
        <trans-unit id="f5451bba7280c8ab2b1022ec4b8e432dddb2d0bb" translate="yes" xml:space="preserve">
          <source>Overrides &lt;a href=&quot;../-mutable-set/remove-all&quot;&gt;MutableSet.removeAll&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;../-mutable-set/remove-all&quot;&gt;MutableSet.removeAll을 (를)&lt;/a&gt; 재정의 함</target>
        </trans-unit>
        <trans-unit id="13a378d256016ef3849bfd324183fff8ada7718f" translate="yes" xml:space="preserve">
          <source>Overrides &lt;a href=&quot;../-mutable-set/retain-all&quot;&gt;MutableSet.retainAll&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;../-mutable-set/retain-all&quot;&gt;MutableSet.retainAll을 (를)&lt;/a&gt; 재정의 함</target>
        </trans-unit>
        <trans-unit id="d5ffc92d2081ab9845fc58c54bbc6bf33bdd927b" translate="yes" xml:space="preserve">
          <source>Overrides &lt;a href=&quot;../-set/contains&quot;&gt;Set.contains&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;../-set/contains&quot;&gt;Set.contains을 (를)&lt;/a&gt; 재정의 함</target>
        </trans-unit>
        <trans-unit id="33d8d25ed831ccbd1a9c6a50b579b3e39a486849" translate="yes" xml:space="preserve">
          <source>Overrides &lt;a href=&quot;../-set/contains-all&quot;&gt;Set.containsAll&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;../-set/contains-all&quot;&gt;Set.containsAll을 (를)&lt;/a&gt; 재정의 함</target>
        </trans-unit>
        <trans-unit id="3ad60553efc9175c88ee2751fcb3da2043c4d1c8" translate="yes" xml:space="preserve">
          <source>Overrides &lt;a href=&quot;../-set/is-empty&quot;&gt;Set.isEmpty&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;../-set/is-empty&quot;&gt;Set.isEmpty을 (를)&lt;/a&gt; 재정의 함</target>
        </trans-unit>
        <trans-unit id="4661e6d5d55bf62af3f8308493e1657e6b0acdc7" translate="yes" xml:space="preserve">
          <source>Overrides &lt;a href=&quot;../-set/size&quot;&gt;Set.size&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;../-set/size&quot;&gt;Set.size을 (를)&lt;/a&gt; 재정의 함</target>
        </trans-unit>
        <trans-unit id="c6135137749f44ab01770866a1a5ad05ffe9fd2a" translate="yes" xml:space="preserve">
          <source>Overriding</source>
          <target state="translated">Overriding</target>
        </trans-unit>
        <trans-unit id="af9d2c60b74a53b5cbb456ba0c99630df9bb378f" translate="yes" xml:space="preserve">
          <source>Overriding Methods</source>
          <target state="translated">재정의 방법</target>
        </trans-unit>
        <trans-unit id="7b07f68f7f2b7a58542addc9fbcb507ada81c4d7" translate="yes" xml:space="preserve">
          <source>Overriding Properties</source>
          <target state="translated">속성 재정의</target>
        </trans-unit>
        <trans-unit id="fde9d61f62ecf5fdc44c2db7338a8f6a77860c34" translate="yes" xml:space="preserve">
          <source>Overriding Rules</source>
          <target state="translated">재정의 규칙</target>
        </trans-unit>
        <trans-unit id="df0d0d85b110978af70f5bd1f72ba4d032e833dd" translate="yes" xml:space="preserve">
          <source>Overriding a member of an interface implemented by delegation</source>
          <target state="translated">위임으로 구현 된 인터페이스 멤버 재정의</target>
        </trans-unit>
        <trans-unit id="18feeb4f63051a8c733b4345362ff0a45e9ffcb1" translate="yes" xml:space="preserve">
          <source>Overriding methods always use the same default parameter values as the base method. When overriding a method with default parameter values, the default parameter values must be omitted from the signature:</source>
          <target state="translated">재정의 메소드는 항상 기본 메소드와 동일한 기본 매개 변수 값을 사용합니다. 기본 매개 변수 값으로 메소드를 대체하는 경우 서명에서 기본 매개 변수 값을 생략해야합니다.</target>
        </trans-unit>
        <trans-unit id="00e581c34738ebec4dc6d1e8b2a8c45ac0c758a8" translate="yes" xml:space="preserve">
          <source>Overriding properties works in a similar way to overriding methods; properties declared on a superclass that are then redeclared on a derived class must be prefaced with &lt;em&gt;override&lt;/em&gt;, and they must have a compatible type. Each declared property can be overridden by a property with an initializer or by a property with a getter method.</source>
          <target state="translated">속성 재정의는 메서드 재정의와 비슷한 방식으로 작동합니다. 파생 클래스에서 다시 선언 된 수퍼 클래스에서 선언 된 속성은 &lt;em&gt;override&lt;/em&gt; 로 시작 해야하며 호환되는 유형이어야합니다. 선언 된 각 속성은 이니셜 라이저가있는 속성이나 getter 메서드가있는 속성으로 재정의 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0efc2e6be4c23b9a513d7ce0dcff8ed80e8912e7" translate="yes" xml:space="preserve">
          <source>Overview</source>
          <target state="translated">Overview</target>
        </trans-unit>
        <trans-unit id="c7a86015f3f4daeacc41d303c97f2340f4320e19" translate="yes" xml:space="preserve">
          <source>PARAGRAPH_SEPARATOR</source>
          <target state="translated">PARAGRAPH_SEPARATOR</target>
        </trans-unit>
        <trans-unit id="fa7ff6fb00a7ace8d98cf880a492dc6c5ffc8ca7" translate="yes" xml:space="preserve">
          <source>PI</source>
          <target state="translated">PI</target>
        </trans-unit>
        <trans-unit id="090d50c51374f7c58b2081f1b3c850d6b151f3fb" translate="yes" xml:space="preserve">
          <source>PLEASE NOTE THAT THIS ANNOTATION MAY GO AWAY IN UPCOMING RELEASES.</source>
          <target state="translated">이 발표는 다가오는 릴리스에서 사라질 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ac606dbad42d1c4714aa6a9bf09911a8e876ff06" translate="yes" xml:space="preserve">
          <source>POP_DIRECTIONAL_FORMAT</source>
          <target state="translated">POP_DIRECTIONAL_FORMAT</target>
        </trans-unit>
        <trans-unit id="8f1690cac270605877b569090a52e1dedb1b3cb7" translate="yes" xml:space="preserve">
          <source>POSITIVE_INFINITY</source>
          <target state="translated">POSITIVE_INFINITY</target>
        </trans-unit>
        <trans-unit id="990bb56af7a024a4883a4f48eec334c61fe2cdba" translate="yes" xml:space="preserve">
          <source>POSIX bindings</source>
          <target state="translated">POSIX 바인딩</target>
        </trans-unit>
        <trans-unit id="b0b7ba4666a92774e0d1afe02f2e20982b307a35" translate="yes" xml:space="preserve">
          <source>PRIVATE</source>
          <target state="translated">PRIVATE</target>
        </trans-unit>
        <trans-unit id="ef502b9eaf7d1ece878343d111c2927f242ad5cc" translate="yes" xml:space="preserve">
          <source>PRIVATE_USE</source>
          <target state="translated">PRIVATE_USE</target>
        </trans-unit>
        <trans-unit id="270be4f67efbcd132dfcd88a1e60b5ca9c489764" translate="yes" xml:space="preserve">
          <source>PROPERTY</source>
          <target state="translated">PROPERTY</target>
        </trans-unit>
        <trans-unit id="d3ec62f1035daa7ed06a217fced23ccea0d00c91" translate="yes" xml:space="preserve">
          <source>PROPERTY_GETTER</source>
          <target state="translated">PROPERTY_GETTER</target>
        </trans-unit>
        <trans-unit id="d707324b9f9cc3ad9cba4772ed64b65d98a95c24" translate="yes" xml:space="preserve">
          <source>PROPERTY_SETTER</source>
          <target state="translated">PROPERTY_SETTER</target>
        </trans-unit>
        <trans-unit id="a2b61061be5708d1feb96030d399b2c2f58cdefe" translate="yes" xml:space="preserve">
          <source>PROTECTED</source>
          <target state="translated">PROTECTED</target>
        </trans-unit>
        <trans-unit id="d1785ca28c3a4d29a6edef1520c544b838a93db3" translate="yes" xml:space="preserve">
          <source>PUBLIC</source>
          <target state="translated">PUBLIC</target>
        </trans-unit>
        <trans-unit id="08453087a04e6d708ae6af6c0c3c47e6d23edde0" translate="yes" xml:space="preserve">
          <source>PUBLICATION</source>
          <target state="translated">PUBLICATION</target>
        </trans-unit>
        <trans-unit id="1acf69c571fbafbcee4b870789cee7bcbb8486b2" translate="yes" xml:space="preserve">
          <source>Package kotlin</source>
          <target state="translated">패키지 코 틀린</target>
        </trans-unit>
        <trans-unit id="cd7a851443ec94bf83404471697b71d0df66e2f0" translate="yes" xml:space="preserve">
          <source>Package kotlin.annotation</source>
          <target state="translated">kotlin.annotation 패키지</target>
        </trans-unit>
        <trans-unit id="0b0b6b8914efd82619b518a2e5ab82c69a446aa1" translate="yes" xml:space="preserve">
          <source>Package kotlin.browser</source>
          <target state="translated">kotlin.browser 패키지</target>
        </trans-unit>
        <trans-unit id="f98ef1feb55ed4b2f2b8510f8947795d64200c33" translate="yes" xml:space="preserve">
          <source>Package kotlin.collections</source>
          <target state="translated">패키지 kotlin.collections</target>
        </trans-unit>
        <trans-unit id="e37cb9e9d8bcbc20421c89f1d4a3cf51da43105b" translate="yes" xml:space="preserve">
          <source>Package kotlin.comparisons</source>
          <target state="translated">패키지 kotlin.comparisons</target>
        </trans-unit>
        <trans-unit id="71cef1b3291b82944ac44b05ce5cb8d1b3119eba" translate="yes" xml:space="preserve">
          <source>Package kotlin.concurrent</source>
          <target state="translated">kotlin.concurrent 패키지</target>
        </trans-unit>
        <trans-unit id="e4f18ea6cc68a4324d9fe077bf0a3961984d1554" translate="yes" xml:space="preserve">
          <source>Package kotlin.contracts</source>
          <target state="translated">kotlin.contracts 패키지</target>
        </trans-unit>
        <trans-unit id="c3f0584f99e1bff3d1686d68159a6bff59169eb7" translate="yes" xml:space="preserve">
          <source>Package kotlin.coroutines</source>
          <target state="translated">패키지 kotlin.coroutines</target>
        </trans-unit>
        <trans-unit id="13aad27c51400614c352d03e9f66e8f5a41652d7" translate="yes" xml:space="preserve">
          <source>Package kotlin.coroutines.experimental</source>
          <target state="translated">패키지 kotlin.coroutines.experimental</target>
        </trans-unit>
        <trans-unit id="033de5e0946bf28aaac381c847cffe4d782bd722" translate="yes" xml:space="preserve">
          <source>Package kotlin.coroutines.experimental.intrinsics</source>
          <target state="translated">패키지 kotlin.coroutines.experimental.intrinsics</target>
        </trans-unit>
        <trans-unit id="87133af8c88889df654f8f71db6e286dd608d5fa" translate="yes" xml:space="preserve">
          <source>Package kotlin.coroutines.intrinsics</source>
          <target state="translated">kotlin.coroutines.intrinsics 패키지</target>
        </trans-unit>
        <trans-unit id="c3ca4a3850ac6d9e19b6ae38b8c180f32a27e07d" translate="yes" xml:space="preserve">
          <source>Package kotlin.dom</source>
          <target state="translated">kotlin.dom 패키지</target>
        </trans-unit>
        <trans-unit id="63e7d0f241ae2c6d73d5113efe433fd6b16bfc09" translate="yes" xml:space="preserve">
          <source>Package kotlin.experimental</source>
          <target state="translated">패키지 kotlin.experimental</target>
        </trans-unit>
        <trans-unit id="4d1d32e94e7e305e7e74c66f1a8d27388a6f7269" translate="yes" xml:space="preserve">
          <source>Package kotlin.io</source>
          <target state="translated">패키지 kotlin.io</target>
        </trans-unit>
        <trans-unit id="9148e6520fffdc9c48b55a2794c808085a9f0cd6" translate="yes" xml:space="preserve">
          <source>Package kotlin.js</source>
          <target state="translated">kotlin.js 패키지</target>
        </trans-unit>
        <trans-unit id="b067f7df3bfc6bf39daa5b6a3cf9419ebcbd8775" translate="yes" xml:space="preserve">
          <source>Package kotlin.jvm</source>
          <target state="translated">kotlin.jvm 패키지</target>
        </trans-unit>
        <trans-unit id="1c4631b1ff0fc35addd0ed5763af022f852b0ee0" translate="yes" xml:space="preserve">
          <source>Package kotlin.math</source>
          <target state="translated">kotlin.math 패키지</target>
        </trans-unit>
        <trans-unit id="380f686b8b67135abd2a9fbcd860a050f035ba1e" translate="yes" xml:space="preserve">
          <source>Package kotlin.native</source>
          <target state="translated">kotlin.native 패키지</target>
        </trans-unit>
        <trans-unit id="067cec4056c78d5de990524297dbd7e14e26acb8" translate="yes" xml:space="preserve">
          <source>Package kotlin.native.concurrent</source>
          <target state="translated">kotlin.native.concurrent 패키지</target>
        </trans-unit>
        <trans-unit id="a8c824bf1148ae3f803dbb32696043852e7097aa" translate="yes" xml:space="preserve">
          <source>Package kotlin.native.ref</source>
          <target state="translated">패키지 kotlin.native.ref</target>
        </trans-unit>
        <trans-unit id="c301d459bbf6656d24ab507e636602bd17a0c738" translate="yes" xml:space="preserve">
          <source>Package kotlin.properties</source>
          <target state="translated">kotlin.properties 패키지</target>
        </trans-unit>
        <trans-unit id="bb07a784b727441a9b1b60cbd2404284b4fae5d4" translate="yes" xml:space="preserve">
          <source>Package kotlin.random</source>
          <target state="translated">kotlin.random 패키지</target>
        </trans-unit>
        <trans-unit id="6c6f61724e126196b76789c3a20a34174e6a544b" translate="yes" xml:space="preserve">
          <source>Package kotlin.ranges</source>
          <target state="translated">패키지 kotlin.ranges</target>
        </trans-unit>
        <trans-unit id="5e3cb5f6f9234dfe542737aa5e1111a067757cfd" translate="yes" xml:space="preserve">
          <source>Package kotlin.reflect</source>
          <target state="translated">패키지 kotlin.reflect</target>
        </trans-unit>
        <trans-unit id="76b85e57e328f6322d2f156ebec00bc356e55083" translate="yes" xml:space="preserve">
          <source>Package kotlin.reflect.full</source>
          <target state="translated">kotlin.reflect.full 패키지</target>
        </trans-unit>
        <trans-unit id="bc16787d08622bd2dc2bddfe3c63c9cf72fae338" translate="yes" xml:space="preserve">
          <source>Package kotlin.reflect.jvm</source>
          <target state="translated">kotlin.reflect.jvm 패키지</target>
        </trans-unit>
        <trans-unit id="5e7391e934d90c3cbc1c67d3786a56ce6d538586" translate="yes" xml:space="preserve">
          <source>Package kotlin.sequences</source>
          <target state="translated">패키지 kotlin.sequences</target>
        </trans-unit>
        <trans-unit id="0d739b0c687d296660761c625d582a76e2f6c5ab" translate="yes" xml:space="preserve">
          <source>Package kotlin.streams</source>
          <target state="translated">kotlin.streams 패키지</target>
        </trans-unit>
        <trans-unit id="35f5ba85dbc3f020cb30371add30a2922d4e9ae5" translate="yes" xml:space="preserve">
          <source>Package kotlin.system</source>
          <target state="translated">kotlin.system 패키지</target>
        </trans-unit>
        <trans-unit id="d85232ffe7c1124903c6ca95ad8427074d72f56f" translate="yes" xml:space="preserve">
          <source>Package kotlin.text</source>
          <target state="translated">kotlin.text 패키지</target>
        </trans-unit>
        <trans-unit id="a42fef5b118b647e415749814e18ff6ec658922e" translate="yes" xml:space="preserve">
          <source>Package kotlinx.cinterop</source>
          <target state="translated">kotlinx.cinterop 패키지</target>
        </trans-unit>
        <trans-unit id="8c8cfe52d8daa0836a022131cbee708a414b763f" translate="yes" xml:space="preserve">
          <source>Package kotlinx.cinterop.internal</source>
          <target state="translated">패키지 kotlinx.cinterop.internal</target>
        </trans-unit>
        <trans-unit id="ebaf6054eaa0e0044893bf6544f260a83b0424b5" translate="yes" xml:space="preserve">
          <source>Package kotlinx.wasm.jsinterop</source>
          <target state="translated">kotlinx.wasm.jsinterop 패키지</target>
        </trans-unit>
        <trans-unit id="caec6c3341b515b8b418beabf7e2a33258bb17c6" translate="yes" xml:space="preserve">
          <source>Package names customarily contain only lowercase letters (no underscores) and the separating dots.</source>
          <target state="translated">패키지 이름에는 일반적으로 소문자 (밑줄 없음)와 분리 점만 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="1997cd46b56d4233defaefae294513a03aaa5170" translate="yes" xml:space="preserve">
          <source>Package names customarily correspond to the directory structure - note that the source file name should &lt;em&gt;not&lt;/em&gt; be a part of the package name (so if you follow this, file-level symbol names must be unique within an entire directory, not just within a file). However, this correspondence is not required, so if you're going to do interop with Java code and all your package names must start with the same prefix, e.g. &lt;code&gt;org.khanacademy&lt;/code&gt;, you might be relieved to learn that you don't need to put all your code inside &lt;code&gt;org/khanacademy&lt;/code&gt; (which is what Java would have forced you to do) - instead, you could start out with a directory called e.g. &lt;code&gt;content&lt;/code&gt;, and the files inside it could declare that they belong to the package &lt;code&gt;org.khanacademy.content&lt;/code&gt;. However, if you have a mixed project with both Kotlin and Java code, the convention is to use the Java-style package directories for Kotlin code too.</source>
          <target state="translated">패키지 이름은 일반적으로 디렉토리 구조에 해당합니다. 소스 파일 이름은 패키지 이름의 일부 가 &lt;em&gt;아니&lt;/em&gt; 어야합니다 (따라서 파일 레벨 기호 이름은 파일 만이 아니라 전체 디렉토리 내에서 고유해야 함) . 그러나이 통신이 필요하지 않으므로 Java 코드와 상호 &lt;code&gt;org.khanacademy&lt;/code&gt; 을 수행하고 모든 패키지 이름이 동일한 접두어로 시작 해야하는 경우 ( 예 : org.khanacademy) , 필요하지 않다는 사실을 알게 될 것입니다 모든 코드를 &lt;code&gt;org/khanacademy&lt;/code&gt; (Java가 강제로 수행 한 것) 안에 넣으십시오 -대신에 &lt;code&gt;content&lt;/code&gt; 라는 디렉토리로 시작할 수 있으며 그 안에있는 파일은 패키지에 속한다고 선언 할 수 있습니다 &lt;code&gt;org.khanacademy.content&lt;/code&gt; . 그러나 Kotlin과 Java 코드가 혼합 된 프로젝트 인 경우 Kotlin 코드에 Java 스타일 패키지 디렉토리를 사용하는 것이 관례입니다.</target>
        </trans-unit>
        <trans-unit id="aaa78bc5394b57af9de0e50cdfd169280ce28bd0" translate="yes" xml:space="preserve">
          <source>Package specification should be at the top of the source file:</source>
          <target state="translated">패키지 사양은 소스 파일의 맨 위에 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="2b3dada27bfad5ff51da937fccac0bdd7dc89386" translate="yes" xml:space="preserve">
          <source>Package structure</source>
          <target state="translated">패키지 구조</target>
        </trans-unit>
        <trans-unit id="7057dbd64229d83d6ca51bbfe7c0c59bf7d92332" translate="yes" xml:space="preserve">
          <source>Package-level default nullability is also supported:</source>
          <target state="translated">패키지 레벨 기본 널 입력 가능도 지원됩니다.</target>
        </trans-unit>
        <trans-unit id="c52d65263eedea9fdaa00300b3ce188059fefc64" translate="yes" xml:space="preserve">
          <source>Package-level documentation can be provided in a separate Markdown file.</source>
          <target state="translated">패키지 레벨 문서는 별도의 Markdown 파일로 제공 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1b1501997eed23c21b32688fb7a28bc3e490834e" translate="yes" xml:space="preserve">
          <source>Package-level functions</source>
          <target state="translated">패키지 레벨 기능</target>
        </trans-unit>
        <trans-unit id="0a999012ffb87b3edac99adbdfc498b12831a1e2" translate="yes" xml:space="preserve">
          <source>Packages</source>
          <target state="translated">Packages</target>
        </trans-unit>
        <trans-unit id="af5cf28c492734cbbda868ac8554c7074b2c5f93" translate="yes" xml:space="preserve">
          <source>Packages and imports</source>
          <target state="translated">패키지 및 수입</target>
        </trans-unit>
        <trans-unit id="ebda79463818f2e1578e5acabbc0ad173c9872fe" translate="yes" xml:space="preserve">
          <source>Pads the string to the specified &lt;a href=&quot;../../kotlin.text/pad-end#kotlin.text%24padEnd%28kotlin.String%2C+kotlin.Int%2C+kotlin.Char%29%2Flength&quot;&gt;length&lt;/a&gt; at the end with the specified character or space.</source>
          <target state="translated">지정된 문자 나 공백으로 끝에 문자열을 지정된 &lt;a href=&quot;../../kotlin.text/pad-end#kotlin.text%24padEnd%28kotlin.String%2C+kotlin.Int%2C+kotlin.Char%29%2Flength&quot;&gt;길이&lt;/a&gt; 로 채 웁니다.</target>
        </trans-unit>
        <trans-unit id="767af9725b3d4c9fe548e4663f41a118fa6618d4" translate="yes" xml:space="preserve">
          <source>Pads the string to the specified &lt;a href=&quot;../../kotlin.text/pad-start#kotlin.text%24padStart%28kotlin.String%2C+kotlin.Int%2C+kotlin.Char%29%2Flength&quot;&gt;length&lt;/a&gt; at the beginning with the specified character or space.</source>
          <target state="translated">지정된 문자 나 공백으로 시작 부분에서 지정된 &lt;a href=&quot;../../kotlin.text/pad-start#kotlin.text%24padStart%28kotlin.String%2C+kotlin.Int%2C+kotlin.Char%29%2Flength&quot;&gt;길이&lt;/a&gt; 로 문자열을 채 웁니다 .</target>
        </trans-unit>
        <trans-unit id="9775fcfa1dfc8830c5f2709b3a7edd29275c524d" translate="yes" xml:space="preserve">
          <source>Pads the string to the specified &lt;a href=&quot;pad-end#kotlin.text%24padEnd%28kotlin.String%2C+kotlin.Int%2C+kotlin.Char%29%2Flength&quot;&gt;length&lt;/a&gt; at the end with the specified character or space.</source>
          <target state="translated">지정된 문자 나 공백으로 끝에 문자열을 지정된 &lt;a href=&quot;pad-end#kotlin.text%24padEnd%28kotlin.String%2C+kotlin.Int%2C+kotlin.Char%29%2Flength&quot;&gt;길이&lt;/a&gt; 로 채 웁니다.</target>
        </trans-unit>
        <trans-unit id="33bae32d321b0a79faa5343f57ebe7de7553943a" translate="yes" xml:space="preserve">
          <source>Pads the string to the specified &lt;a href=&quot;pad-start#kotlin.text%24padStart%28kotlin.String%2C+kotlin.Int%2C+kotlin.Char%29%2Flength&quot;&gt;length&lt;/a&gt; at the beginning with the specified character or space.</source>
          <target state="translated">지정된 문자 나 공백으로 시작 부분에서 지정된 &lt;a href=&quot;pad-start#kotlin.text%24padStart%28kotlin.String%2C+kotlin.Int%2C+kotlin.Char%29%2Flength&quot;&gt;길이&lt;/a&gt; 로 문자열을 채 웁니다 .</target>
        </trans-unit>
        <trans-unit id="5ea1680b49ef979617b212c8216d0d6bb5ae052a" translate="yes" xml:space="preserve">
          <source>PageTransitionEventInit</source>
          <target state="translated">PageTransitionEventInit</target>
        </trans-unit>
        <trans-unit id="2537f88ac2f56246c757a78fd250fe571c25bb72" translate="yes" xml:space="preserve">
          <source>Pair</source>
          <target state="translated">Pair</target>
        </trans-unit>
        <trans-unit id="78ee15380355e435a919e49f0511d53edfaf1824" translate="yes" xml:space="preserve">
          <source>Parameter names in the bytecode</source>
          <target state="translated">바이트 코드의 매개 변수 이름</target>
        </trans-unit>
        <trans-unit id="01d96306f74636eb4b351ade766a2344184143f9" translate="yes" xml:space="preserve">
          <source>ParameterName</source>
          <target state="translated">ParameterName</target>
        </trans-unit>
        <trans-unit id="5e3bb0ac99a7fedf581a36f6d24c3ac15104d602" translate="yes" xml:space="preserve">
          <source>Parameterless &lt;code&gt;main&lt;/code&gt;</source>
          <target state="translated">매개 변수없는 &lt;code&gt;main&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="a975eea30db9fa05003e3b5097688bd49ec7e01b" translate="yes" xml:space="preserve">
          <source>Parameters</source>
          <target state="translated">Parameters</target>
        </trans-unit>
        <trans-unit id="6007e884de03062ce98684d67d70e4363c749a71" translate="yes" xml:space="preserve">
          <source>Parameters required to make a call to this callable. If this callable requires a &lt;code&gt;this&lt;/code&gt; instance or an extension receiver parameter, they come first in the list in that order.</source>
          <target state="translated">이 호출을 호출하는 데 필요한 매개 변수. 이 콜 러블에 &lt;code&gt;this&lt;/code&gt; 인스턴스 또는 확장 수신자 매개 변수 가 필요한 경우 , 순서대로 목록에서 맨 앞에 옵니다.</target>
        </trans-unit>
        <trans-unit id="f5496d18f32dc79533fd367651808a9138a4d742" translate="yes" xml:space="preserve">
          <source>ParentNode</source>
          <target state="translated">ParentNode</target>
        </trans-unit>
        <trans-unit id="9a4a33cbe10dd7250f2202d387f7bf2828634043" translate="yes" xml:space="preserve">
          <source>Parental responsibilities</source>
          <target state="translated">부모의 책임</target>
        </trans-unit>
        <trans-unit id="c3cc6a8da3b5889ae78a89bccdb3931e409a93df" translate="yes" xml:space="preserve">
          <source>Parentheses are translated to calls to &lt;code&gt;invoke&lt;/code&gt; with appropriate number of arguments.</source>
          <target state="translated">괄호는 적절한 수의 인수 로 호출하기위한 &lt;code&gt;invoke&lt;/code&gt; 로 변환됩니다 .</target>
        </trans-unit>
        <trans-unit id="3b7f40c00b71d845b696c035abe99affb5e55e29" translate="yes" xml:space="preserve">
          <source>Parses the string as a &lt;a href=&quot;../-long/index#kotlin.Long&quot;&gt;Long&lt;/a&gt; number and returns the result or &lt;code&gt;null&lt;/code&gt; if the string is not a valid representation of a number.</source>
          <target state="translated">문자열을 &lt;a href=&quot;../-long/index#kotlin.Long&quot;&gt;Long&lt;/a&gt; 숫자 로 구문 분석하고 결과를 리턴하거나 문자열이 유효한 숫자 표현이 아닌 경우 &lt;code&gt;null&lt;/code&gt; 리턴합니다 .</target>
        </trans-unit>
        <trans-unit id="77e9ea428cbac46623806a26e06a724d80dd803a" translate="yes" xml:space="preserve">
          <source>Parses the string as a &lt;a href=&quot;../-short/index#kotlin.Short&quot;&gt;Short&lt;/a&gt; number and returns the result or &lt;code&gt;null&lt;/code&gt; if the string is not a valid representation of a number.</source>
          <target state="translated">문자열을 &lt;a href=&quot;../-short/index#kotlin.Short&quot;&gt;짧은&lt;/a&gt; 숫자 로 구문 분석하고 결과가 리턴되거나 문자열이 숫자의 유효한 표현이 아닌 경우 &lt;code&gt;null&lt;/code&gt; 리턴합니다 .</target>
        </trans-unit>
        <trans-unit id="3460dc9977c3211b2a7212ebddcc3de19130d09f" translate="yes" xml:space="preserve">
          <source>Parses the string as a &lt;a href=&quot;../-u-long/index&quot;&gt;ULong&lt;/a&gt; number and returns the result.</source>
          <target state="translated">문자열을 &lt;a href=&quot;../-u-long/index&quot;&gt;ULong&lt;/a&gt; 숫자 로 구문 분석하고 결과를 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="e9566c12a33fe4f91d3368cf5c55f5b83e3844f3" translate="yes" xml:space="preserve">
          <source>Parses the string as a &lt;a href=&quot;../-u-short/index&quot;&gt;UShort&lt;/a&gt; number and returns the result.</source>
          <target state="translated">문자열을 &lt;a href=&quot;../-u-short/index&quot;&gt;UShort&lt;/a&gt; 번호 로 구문 분석하고 결과를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="03fcee6f1bc05077ccafc1ad6f1c9dc53e972374" translate="yes" xml:space="preserve">
          <source>Parses the string as a &lt;a href=&quot;../kotlin/-double/index#kotlin.Double&quot;&gt;Double&lt;/a&gt; number and returns the result or &lt;code&gt;null&lt;/code&gt; if the string is not a valid representation of a number.</source>
          <target state="translated">문자열을 &lt;a href=&quot;../kotlin/-double/index#kotlin.Double&quot;&gt;Double&lt;/a&gt; 숫자 로 구문 분석하여 결과를 반환하거나 문자열이 유효한 숫자 표현이 아닌 경우 &lt;code&gt;null&lt;/code&gt; 을 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="5e57d89119057c3c3cefa6d5760b7304e4a55a29" translate="yes" xml:space="preserve">
          <source>Parses the string as a &lt;a href=&quot;../kotlin/-double/index#kotlin.Double&quot;&gt;Double&lt;/a&gt; number and returns the result.</source>
          <target state="translated">문자열을 &lt;a href=&quot;../kotlin/-double/index#kotlin.Double&quot;&gt;Double&lt;/a&gt; 숫자 로 구문 분석하고 결과를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="e017592a7860cb2ba99a028eb4332791a37cb61b" translate="yes" xml:space="preserve">
          <source>Parses the string as a &lt;a href=&quot;../kotlin/-float/index#kotlin.Float&quot;&gt;Float&lt;/a&gt; number and returns the result or &lt;code&gt;null&lt;/code&gt; if the string is not a valid representation of a number.</source>
          <target state="translated">문자열을 &lt;a href=&quot;../kotlin/-float/index#kotlin.Float&quot;&gt;Float&lt;/a&gt; 숫자 로 구문 분석하고 결과를 반환하거나 문자열이 유효한 숫자 표현이 아닌 경우 &lt;code&gt;null&lt;/code&gt; 을 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="9fd243710f5d1156a68a9fda79cfcc500a1e3a94" translate="yes" xml:space="preserve">
          <source>Parses the string as a &lt;a href=&quot;../kotlin/-float/index#kotlin.Float&quot;&gt;Float&lt;/a&gt; number and returns the result.</source>
          <target state="translated">문자열을 &lt;a href=&quot;../kotlin/-float/index#kotlin.Float&quot;&gt;Float&lt;/a&gt; 숫자 로 구문 분석하고 결과를 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="c4e20fa41c3f4a8ec2470fa7691ce6fd58d6695a" translate="yes" xml:space="preserve">
          <source>Parses the string as a &lt;a href=&quot;../kotlin/-long/index#kotlin.Long&quot;&gt;Long&lt;/a&gt; number and returns the result or &lt;code&gt;null&lt;/code&gt; if the string is not a valid representation of a number.</source>
          <target state="translated">문자열을 &lt;a href=&quot;../kotlin/-long/index#kotlin.Long&quot;&gt;Long&lt;/a&gt; 숫자 로 구문 분석하고 결과를 리턴하거나 문자열이 유효한 숫자 표현이 아닌 경우 &lt;code&gt;null&lt;/code&gt; 리턴합니다 .</target>
        </trans-unit>
        <trans-unit id="b21c687bfab2a9fa2bd8c0d5151e491628e0808a" translate="yes" xml:space="preserve">
          <source>Parses the string as a &lt;a href=&quot;../kotlin/-long/index#kotlin.Long&quot;&gt;Long&lt;/a&gt; number and returns the result.</source>
          <target state="translated">문자열을 &lt;a href=&quot;../kotlin/-long/index#kotlin.Long&quot;&gt;Long&lt;/a&gt; 숫자 로 구문 분석하고 결과를 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="e00e74116039154e2eaf85ad6860873f49bc8901" translate="yes" xml:space="preserve">
          <source>Parses the string as a &lt;a href=&quot;../kotlin/-short/index#kotlin.Short&quot;&gt;Short&lt;/a&gt; number and returns the result or &lt;code&gt;null&lt;/code&gt; if the string is not a valid representation of a number.</source>
          <target state="translated">문자열을 &lt;a href=&quot;../kotlin/-short/index#kotlin.Short&quot;&gt;짧은&lt;/a&gt; 숫자 로 구문 분석하고 결과가 리턴되거나 문자열이 숫자의 유효한 표현이 아닌 경우 &lt;code&gt;null&lt;/code&gt; 리턴합니다 .</target>
        </trans-unit>
        <trans-unit id="11636b3a2888c265e9bd1e696d846d41be6f72ed" translate="yes" xml:space="preserve">
          <source>Parses the string as a &lt;a href=&quot;../kotlin/-short/index#kotlin.Short&quot;&gt;Short&lt;/a&gt; number and returns the result.</source>
          <target state="translated">문자열을 &lt;a href=&quot;../kotlin/-short/index#kotlin.Short&quot;&gt;짧은&lt;/a&gt; 숫자 로 구문 분석하고 결과를 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="808c021e120df742b13d46ab170e5daa6e2439af" translate="yes" xml:space="preserve">
          <source>Parses the string as a &lt;a href=&quot;../kotlin/-u-long/index&quot;&gt;ULong&lt;/a&gt; number and returns the result.</source>
          <target state="translated">문자열을 &lt;a href=&quot;../kotlin/-u-long/index&quot;&gt;ULong&lt;/a&gt; 숫자 로 구문 분석하고 결과를 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="9ce207a9488f5cb14e26985fa84c2e79075ef623" translate="yes" xml:space="preserve">
          <source>Parses the string as a &lt;a href=&quot;../kotlin/-u-short/index&quot;&gt;UShort&lt;/a&gt; number and returns the result.</source>
          <target state="translated">문자열을 &lt;a href=&quot;../kotlin/-u-short/index&quot;&gt;UShort&lt;/a&gt; 번호 로 구문 분석하고 결과를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="9cd24a4116bc75a4a236890965ad69b9f9889741" translate="yes" xml:space="preserve">
          <source>Parses the string as a &lt;a href=&quot;http://docs.oracle.com/javase/8/docs/api/java/math/BigDecimal.html&quot;&gt;java.math.BigDecimal&lt;/a&gt; number and returns the result or &lt;code&gt;null&lt;/code&gt; if the string is not a valid representation of a number.</source>
          <target state="translated">문자열을 &lt;a href=&quot;http://docs.oracle.com/javase/8/docs/api/java/math/BigDecimal.html&quot;&gt;java.math.BigDecimal&lt;/a&gt; 숫자 로 구문 분석하고 결과가 리턴되거나 문자열이 유효한 숫자 표현이 아닌 경우 &lt;code&gt;null&lt;/code&gt; 리턴합니다 .</target>
        </trans-unit>
        <trans-unit id="56aa3e835c346e617edd83fb98e8496ea6101b8b" translate="yes" xml:space="preserve">
          <source>Parses the string as a &lt;a href=&quot;http://docs.oracle.com/javase/8/docs/api/java/math/BigDecimal.html&quot;&gt;java.math.BigDecimal&lt;/a&gt; number and returns the result.</source>
          <target state="translated">문자열을 &lt;a href=&quot;http://docs.oracle.com/javase/8/docs/api/java/math/BigDecimal.html&quot;&gt;java.math.BigDecimal&lt;/a&gt; 숫자 로 구문 분석하고 결과를 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="729c13559a5f0954494982664b3cc0f0def880c2" translate="yes" xml:space="preserve">
          <source>Parses the string as a &lt;a href=&quot;http://docs.oracle.com/javase/8/docs/api/java/math/BigInteger.html&quot;&gt;java.math.BigInteger&lt;/a&gt; number and returns the result or &lt;code&gt;null&lt;/code&gt; if the string is not a valid representation of a number.</source>
          <target state="translated">문자열을 &lt;a href=&quot;http://docs.oracle.com/javase/8/docs/api/java/math/BigInteger.html&quot;&gt;java.math.BigInteger&lt;/a&gt; 숫자 로 구문 분석하고 결과가 리턴되거나 문자열이 유효한 숫자 표현이 아닌 경우 &lt;code&gt;null&lt;/code&gt; 리턴합니다 .</target>
        </trans-unit>
        <trans-unit id="ac452fd9440a9fd52c2a0c6af54d266f05d9d9ad" translate="yes" xml:space="preserve">
          <source>Parses the string as a &lt;a href=&quot;http://docs.oracle.com/javase/8/docs/api/java/math/BigInteger.html&quot;&gt;java.math.BigInteger&lt;/a&gt; number and returns the result.</source>
          <target state="translated">문자열을 &lt;a href=&quot;http://docs.oracle.com/javase/8/docs/api/java/math/BigInteger.html&quot;&gt;java.math.BigInteger&lt;/a&gt; 숫자 로 구문 분석하고 결과를 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="c00f10809b689be6b7ca4208ac2acc3fd70ee29d" translate="yes" xml:space="preserve">
          <source>Parses the string as a signed &lt;a href=&quot;../-byte/index#kotlin.Byte&quot;&gt;Byte&lt;/a&gt; number and returns the result or &lt;code&gt;null&lt;/code&gt; if the string is not a valid representation of a number.</source>
          <target state="translated">문자열을 부호있는 &lt;a href=&quot;../-byte/index#kotlin.Byte&quot;&gt;바이트&lt;/a&gt; 숫자 로 구문 분석하고 결과 가 문자열을 유효한 숫자 표현이 아닌 경우 &lt;code&gt;null&lt;/code&gt; 리턴합니다 .</target>
        </trans-unit>
        <trans-unit id="1069310e66e412772969b19fcb962b6a8b050fe6" translate="yes" xml:space="preserve">
          <source>Parses the string as a signed &lt;a href=&quot;../-u-byte/index&quot;&gt;UByte&lt;/a&gt; number and returns the result.</source>
          <target state="translated">문자열을 부호있는 &lt;a href=&quot;../-u-byte/index&quot;&gt;UByte&lt;/a&gt; 숫자 로 구문 분석하고 결과를 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="3327b35f87a717b64d0f7b88020c519964110940" translate="yes" xml:space="preserve">
          <source>Parses the string as a signed &lt;a href=&quot;../kotlin/-byte/index#kotlin.Byte&quot;&gt;Byte&lt;/a&gt; number and returns the result or &lt;code&gt;null&lt;/code&gt; if the string is not a valid representation of a number.</source>
          <target state="translated">문자열을 부호있는 &lt;a href=&quot;../kotlin/-byte/index#kotlin.Byte&quot;&gt;바이트&lt;/a&gt; 숫자 로 구문 분석하고 결과 가 문자열을 유효한 숫자 표현이 아닌 경우 &lt;code&gt;null&lt;/code&gt; 리턴합니다 .</target>
        </trans-unit>
        <trans-unit id="cdabe40b91498659cc5d402374e06ae3dbae6d16" translate="yes" xml:space="preserve">
          <source>Parses the string as a signed &lt;a href=&quot;../kotlin/-byte/index#kotlin.Byte&quot;&gt;Byte&lt;/a&gt; number and returns the result.</source>
          <target state="translated">문자열을 부호있는 &lt;a href=&quot;../kotlin/-byte/index#kotlin.Byte&quot;&gt;바이트&lt;/a&gt; 번호 로 구문 분석하고 결과를 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="632dd483fc309a795c56e1b319d5db7e54bc42d9" translate="yes" xml:space="preserve">
          <source>Parses the string as a signed &lt;a href=&quot;../kotlin/-u-byte/index&quot;&gt;UByte&lt;/a&gt; number and returns the result.</source>
          <target state="translated">문자열을 부호있는 &lt;a href=&quot;../kotlin/-u-byte/index&quot;&gt;UByte&lt;/a&gt; 숫자 로 구문 분석하고 결과를 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="92127503e18a7587ff052448b8982e878082d94d" translate="yes" xml:space="preserve">
          <source>Parses the string as an &lt;a href=&quot;../-int/index#kotlin.Int&quot;&gt;Int&lt;/a&gt; number and returns the result or &lt;code&gt;null&lt;/code&gt; if the string is not a valid representation of a number.</source>
          <target state="translated">문자열을 &lt;a href=&quot;../-int/index#kotlin.Int&quot;&gt;Int&lt;/a&gt; 숫자 로 구문 분석하고 결과가 리턴되거나 문자열이 숫자의 유효한 표현이 아닌 경우 &lt;code&gt;null&lt;/code&gt; 리턴합니다 .</target>
        </trans-unit>
        <trans-unit id="44d8eaf46733313d1ce7354e6d56a9fe33ef724f" translate="yes" xml:space="preserve">
          <source>Parses the string as an &lt;a href=&quot;../-u-byte/index&quot;&gt;UByte&lt;/a&gt; number and returns the result or &lt;code&gt;null&lt;/code&gt; if the string is not a valid representation of a number.</source>
          <target state="translated">문자열을 &lt;a href=&quot;../-u-byte/index&quot;&gt;UByte&lt;/a&gt; 숫자 로 구문 분석하고 결과가 리턴되거나 문자열이 숫자의 유효한 표현이 아닌 경우 &lt;code&gt;null&lt;/code&gt; 리턴합니다 .</target>
        </trans-unit>
        <trans-unit id="8b85204dceef6f104ee570ddea87ef90930852cf" translate="yes" xml:space="preserve">
          <source>Parses the string as an &lt;a href=&quot;../-u-int/index&quot;&gt;UInt&lt;/a&gt; number and returns the result or &lt;code&gt;null&lt;/code&gt; if the string is not a valid representation of a number.</source>
          <target state="translated">문자열을 &lt;a href=&quot;../-u-int/index&quot;&gt;UInt&lt;/a&gt; 숫자 로 구문 분석하고 결과가 리턴되거나 문자열이 숫자의 유효한 표현이 아닌 경우 &lt;code&gt;null&lt;/code&gt; 리턴합니다 .</target>
        </trans-unit>
        <trans-unit id="50635bca1100c5a749ef6f79a67b0b536da17e5a" translate="yes" xml:space="preserve">
          <source>Parses the string as an &lt;a href=&quot;../-u-int/index&quot;&gt;UInt&lt;/a&gt; number and returns the result.</source>
          <target state="translated">문자열을 &lt;a href=&quot;../-u-int/index&quot;&gt;UInt&lt;/a&gt; 숫자 로 구문 분석하고 결과를 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="099658faf2cf9e52112f13e7e0da51b61a87b74c" translate="yes" xml:space="preserve">
          <source>Parses the string as an &lt;a href=&quot;../-u-long/index&quot;&gt;ULong&lt;/a&gt; number and returns the result or &lt;code&gt;null&lt;/code&gt; if the string is not a valid representation of a number.</source>
          <target state="translated">문자열을 &lt;a href=&quot;../-u-long/index&quot;&gt;ULong&lt;/a&gt; 숫자 로 구문 분석하고 결과가 리턴되거나 문자열이 유효한 숫자 표현이 아닌 경우 &lt;code&gt;null&lt;/code&gt; 리턴합니다 .</target>
        </trans-unit>
        <trans-unit id="28a499686be5b8df212203a6a5db135523deaad1" translate="yes" xml:space="preserve">
          <source>Parses the string as an &lt;a href=&quot;../-u-short/index&quot;&gt;UShort&lt;/a&gt; number and returns the result or &lt;code&gt;null&lt;/code&gt; if the string is not a valid representation of a number.</source>
          <target state="translated">문자열을 &lt;a href=&quot;../-u-short/index&quot;&gt;UShort&lt;/a&gt; 숫자 로 구문 분석하고 결과가 반환되거나 문자열이 유효한 숫자 표현이 아닌 경우 &lt;code&gt;null&lt;/code&gt; 리턴합니다 .</target>
        </trans-unit>
        <trans-unit id="fc99fc355875545058ca7792361749550f63798f" translate="yes" xml:space="preserve">
          <source>Parses the string as an &lt;a href=&quot;../kotlin/-int/index#kotlin.Int&quot;&gt;Int&lt;/a&gt; number and returns the result or &lt;code&gt;null&lt;/code&gt; if the string is not a valid representation of a number.</source>
          <target state="translated">문자열을 &lt;a href=&quot;../kotlin/-int/index#kotlin.Int&quot;&gt;Int&lt;/a&gt; 숫자 로 구문 분석하고 결과가 리턴되거나 문자열이 숫자의 유효한 표현이 아닌 경우 &lt;code&gt;null&lt;/code&gt; 리턴합니다 .</target>
        </trans-unit>
        <trans-unit id="ba4b749f733fa1903c7ab78a01fb542dcb149b45" translate="yes" xml:space="preserve">
          <source>Parses the string as an &lt;a href=&quot;../kotlin/-int/index#kotlin.Int&quot;&gt;Int&lt;/a&gt; number and returns the result.</source>
          <target state="translated">문자열을 &lt;a href=&quot;../kotlin/-int/index#kotlin.Int&quot;&gt;Int&lt;/a&gt; 숫자 로 구문 분석하고 결과를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="739e3472f0ceb677cd83787ae3336ed5f607a619" translate="yes" xml:space="preserve">
          <source>Parses the string as an &lt;a href=&quot;../kotlin/-u-byte/index&quot;&gt;UByte&lt;/a&gt; number and returns the result or &lt;code&gt;null&lt;/code&gt; if the string is not a valid representation of a number.</source>
          <target state="translated">문자열을 &lt;a href=&quot;../kotlin/-u-byte/index&quot;&gt;UByte&lt;/a&gt; 숫자 로 구문 분석하고 결과가 리턴되거나 문자열이 숫자의 유효한 표현이 아닌 경우 &lt;code&gt;null&lt;/code&gt; 리턴합니다 .</target>
        </trans-unit>
        <trans-unit id="77b2098c25b9ce373ba6dec00f8aaddf3c369073" translate="yes" xml:space="preserve">
          <source>Parses the string as an &lt;a href=&quot;../kotlin/-u-int/index&quot;&gt;UInt&lt;/a&gt; number and returns the result or &lt;code&gt;null&lt;/code&gt; if the string is not a valid representation of a number.</source>
          <target state="translated">문자열을 &lt;a href=&quot;../kotlin/-u-int/index&quot;&gt;UInt&lt;/a&gt; 숫자 로 구문 분석하고 결과가 리턴되거나 문자열이 숫자의 유효한 표현이 아닌 경우 &lt;code&gt;null&lt;/code&gt; 리턴합니다 .</target>
        </trans-unit>
        <trans-unit id="03eab929beeb8fb71b308b00ae7c6efa65744c5c" translate="yes" xml:space="preserve">
          <source>Parses the string as an &lt;a href=&quot;../kotlin/-u-int/index&quot;&gt;UInt&lt;/a&gt; number and returns the result.</source>
          <target state="translated">문자열을 &lt;a href=&quot;../kotlin/-u-int/index&quot;&gt;UInt&lt;/a&gt; 숫자 로 구문 분석하고 결과를 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="b2ae9ff4eba3a1b62d14bb51901559b4c2994840" translate="yes" xml:space="preserve">
          <source>Parses the string as an &lt;a href=&quot;../kotlin/-u-long/index&quot;&gt;ULong&lt;/a&gt; number and returns the result or &lt;code&gt;null&lt;/code&gt; if the string is not a valid representation of a number.</source>
          <target state="translated">문자열을 &lt;a href=&quot;../kotlin/-u-long/index&quot;&gt;ULong&lt;/a&gt; 숫자 로 구문 분석하고 결과가 리턴되거나 문자열이 유효한 숫자 표현이 아닌 경우 &lt;code&gt;null&lt;/code&gt; 리턴합니다 .</target>
        </trans-unit>
        <trans-unit id="1183755b1a6c59c54b593ca971bed915e51407cc" translate="yes" xml:space="preserve">
          <source>Parses the string as an &lt;a href=&quot;../kotlin/-u-short/index&quot;&gt;UShort&lt;/a&gt; number and returns the result or &lt;code&gt;null&lt;/code&gt; if the string is not a valid representation of a number.</source>
          <target state="translated">문자열을 &lt;a href=&quot;../kotlin/-u-short/index&quot;&gt;UShort&lt;/a&gt; 숫자 로 구문 분석하고 결과가 반환되거나 문자열이 유효한 숫자 표현이 아닌 경우 &lt;code&gt;null&lt;/code&gt; 리턴합니다 .</target>
        </trans-unit>
        <trans-unit id="4d8d29c37cfa9d2ee47bae5429be39d9f989f27b" translate="yes" xml:space="preserve">
          <source>Partitioning</source>
          <target state="translated">Partitioning</target>
        </trans-unit>
        <trans-unit id="c75dab75d570c82239fe7c2c6c8dabcee5e46f80" translate="yes" xml:space="preserve">
          <source>Pass Kotlin function as C function pointer</source>
          <target state="translated">Kotlin 함수를 C 함수 포인터로 전달</target>
        </trans-unit>
        <trans-unit id="ae9ac58422160d0ad0eee983cca791d9a468b6ba" translate="yes" xml:space="preserve">
          <source>Pass a Kotlin string to C</source>
          <target state="translated">코 틀린 문자열을 C로 전달</target>
        </trans-unit>
        <trans-unit id="f90e12f023572526edda5a593aaa0584b13f423c" translate="yes" xml:space="preserve">
          <source>Passing Kotlin Function as C Function Pointer</source>
          <target state="translated">Kotlin 함수를 C 함수 포인터로 전달</target>
        </trans-unit>
        <trans-unit id="7585c346e264607bad89b635100a35c36a66834a" translate="yes" xml:space="preserve">
          <source>Passing Kotlin string to C</source>
          <target state="translated">코 틀린 문자열을 C로 전달</target>
        </trans-unit>
        <trans-unit id="0b7f3f3974a64e350e65c342a4d718ece533af30" translate="yes" xml:space="preserve">
          <source>Passing a Kotlin string to C is easy, thanks to the fact that we have &lt;code&gt;String.cstr&lt;/code&gt;&lt;a href=&quot;../../reference/extensions#extension-properties&quot;&gt;extension property&lt;/a&gt; in Kotlin for it. There is also &lt;code&gt;String.wcstr&lt;/code&gt; for cases where we need UTF-16 wide characters.</source>
          <target state="translated">Kotlin에 &lt;code&gt;String.cstr&lt;/code&gt; &lt;a href=&quot;../../reference/extensions#extension-properties&quot;&gt;확장 속성&lt;/a&gt; 이 있기 때문에 Kotlin 문자열을 C로 전달하는 것은 쉽습니다 . UTF-16 와이드 문자가 필요한 경우 &lt;code&gt;String.wcstr&lt;/code&gt; 도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="304a061cb8ed9f8aa67f451b3f515400a41c3804" translate="yes" xml:space="preserve">
          <source>Passing a lambda to the last parameter</source>
          <target state="translated">마지막 매개 변수에 람다 전달</target>
        </trans-unit>
        <trans-unit id="c1e4d32fb03a360e8f74a53d64c38b50bc21b2dc" translate="yes" xml:space="preserve">
          <source>Passing and receiving structs by value</source>
          <target state="translated">값으로 구조체 전달 및 수신</target>
        </trans-unit>
        <trans-unit id="0d14aaea7d3a92a48681954df970dc56b82a0dd9" translate="yes" xml:space="preserve">
          <source>Passing pointers to bindings</source>
          <target state="translated">바인딩에 대한 포인터 전달</target>
        </trans-unit>
        <trans-unit id="fcb96d8edb91ae75b64ef7828f16be5780218320" translate="yes" xml:space="preserve">
          <source>Passing raw compiler arguments</source>
          <target state="translated">원시 컴파일러 인수 전달</target>
        </trans-unit>
        <trans-unit id="13a5d719b2faedd726058a84f3e9eb0b6139a416" translate="yes" xml:space="preserve">
          <source>Passing single element to vararg in named form</source>
          <target state="translated">명명 된 형식으로 단일 요소를 vararg에 전달</target>
        </trans-unit>
        <trans-unit id="0c67af8f12dbf77b99536e4d73820164109f829b" translate="yes" xml:space="preserve">
          <source>Passing user data to callbacks</source>
          <target state="translated">콜백에 사용자 데이터 전달</target>
        </trans-unit>
        <trans-unit id="c9ea761624069fe5b9a0e6e90deff94d704140b4" translate="yes" xml:space="preserve">
          <source>Path to JDK home directory to include into classpath, if differs from default JAVA_HOME</source>
          <target state="translated">기본 JAVA_HOME과 다른 경우 클래스 경로에 포함 할 JDK 홈 디렉토리의 경로</target>
        </trans-unit>
        <trans-unit id="f5e4fcf5033305d3fdfb9539698b3863c2f8d442" translate="yes" xml:space="preserve">
          <source>Path2D</source>
          <target state="translated">Path2D</target>
        </trans-unit>
        <trans-unit id="78a42d3766ebfbfee5049adb3d4ca41e9f6416e1" translate="yes" xml:space="preserve">
          <source>Paths to Kotlin libraries</source>
          <target state="translated">코 틀린 도서관으로가는 길</target>
        </trans-unit>
        <trans-unit id="ad6b0ffca55dac1102315c8d5a7682cc7c224b28" translate="yes" xml:space="preserve">
          <source>PerformanceNavigation</source>
          <target state="translated">PerformanceNavigation</target>
        </trans-unit>
        <trans-unit id="c239be2f9d93dc0ca884a5a073e42f4ad6b6e9a2" translate="yes" xml:space="preserve">
          <source>PerformanceTiming</source>
          <target state="translated">PerformanceTiming</target>
        </trans-unit>
        <trans-unit id="9706f87615fbda5b6b52e22687f6aba443000410" translate="yes" xml:space="preserve">
          <source>Performs a bitwise AND operation between the two values.</source>
          <target state="translated">두 값 사이에 비트 AND 연산을 수행합니다.</target>
        </trans-unit>
        <trans-unit id="453b3283ac8b85b200cf999c3286bac224a17bf8" translate="yes" xml:space="preserve">
          <source>Performs a bitwise OR operation between the two values.</source>
          <target state="translated">두 값 사이에 비트 단위 OR 연산을 수행합니다.</target>
        </trans-unit>
        <trans-unit id="d6132130bbc5d03b4d898a22fb564f21209a6d16" translate="yes" xml:space="preserve">
          <source>Performs a bitwise XOR operation between the two values.</source>
          <target state="translated">두 값 사이에 비트 XOR 연산을 수행합니다.</target>
        </trans-unit>
        <trans-unit id="2726daaa8d5cb24f28a5d0601822288498f6860b" translate="yes" xml:space="preserve">
          <source>Performs a logical &lt;code&gt;and&lt;/code&gt; operation between this Boolean and the &lt;a href=&quot;and#kotlin.Boolean%24and%28kotlin.Boolean%29%2Fother&quot;&gt;other&lt;/a&gt; one. Unlike the &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; operator, this function does not perform short-circuit evaluation. Both &lt;code&gt;this&lt;/code&gt; and &lt;a href=&quot;and#kotlin.Boolean%24and%28kotlin.Boolean%29%2Fother&quot;&gt;other&lt;/a&gt; will always be evaluated.</source>
          <target state="translated">이 부울과 &lt;a href=&quot;and#kotlin.Boolean%24and%28kotlin.Boolean%29%2Fother&quot;&gt;다른&lt;/a&gt; 부울 사이에 논리 &lt;code&gt;and&lt;/code&gt; 연산을 수행합니다 . &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; 연산자 와 달리이 기능은 단락 평가를 수행하지 않습니다. 모두 &lt;code&gt;this&lt;/code&gt; 와 &lt;a href=&quot;and#kotlin.Boolean%24and%28kotlin.Boolean%29%2Fother&quot;&gt;다른 하나는&lt;/a&gt; 항상 평가됩니다.</target>
        </trans-unit>
        <trans-unit id="ad41cc2ec99ee6284221d89c3a72499ca80a0d5f" translate="yes" xml:space="preserve">
          <source>Performs a logical &lt;code&gt;or&lt;/code&gt; operation between this Boolean and the &lt;a href=&quot;or#kotlin.Boolean%24or%28kotlin.Boolean%29%2Fother&quot;&gt;other&lt;/a&gt; one. Unlike the &lt;code&gt;||&lt;/code&gt; operator, this function does not perform short-circuit evaluation. Both &lt;code&gt;this&lt;/code&gt; and &lt;a href=&quot;or#kotlin.Boolean%24or%28kotlin.Boolean%29%2Fother&quot;&gt;other&lt;/a&gt; will always be evaluated.</source>
          <target state="translated">이 부울과 &lt;a href=&quot;or#kotlin.Boolean%24or%28kotlin.Boolean%29%2Fother&quot;&gt;다른&lt;/a&gt; 부울 사이에 논리 &lt;code&gt;or&lt;/code&gt; 연산을 수행합니다 . &lt;code&gt;||&lt;/code&gt; 와 달리 이 기능은 단락 평가를 수행하지 않습니다. 모두 &lt;code&gt;this&lt;/code&gt; 와 &lt;a href=&quot;or#kotlin.Boolean%24or%28kotlin.Boolean%29%2Fother&quot;&gt;다른 하나는&lt;/a&gt; 항상 평가됩니다.</target>
        </trans-unit>
        <trans-unit id="d8e5bacffc830263b6de1881a8720dc0d3cb5b95" translate="yes" xml:space="preserve">
          <source>Performs a logical &lt;code&gt;xor&lt;/code&gt; operation between this Boolean and the &lt;a href=&quot;xor#kotlin.Boolean%24xor%28kotlin.Boolean%29%2Fother&quot;&gt;other&lt;/a&gt; one.</source>
          <target state="translated">이 부울과 &lt;a href=&quot;xor#kotlin.Boolean%24xor%28kotlin.Boolean%29%2Fother&quot;&gt;다른&lt;/a&gt; 부울 사이에 논리 &lt;code&gt;xor&lt;/code&gt; 연산을 수행합니다 .</target>
        </trans-unit>
        <trans-unit id="f15a7a5b346eb278931840866891b41c56053f06" translate="yes" xml:space="preserve">
          <source>Performs a logical and + not operations over corresponding bits of this and &lt;a href=&quot;and-not#kotlin.native.BitSet%24andNot%28kotlin.native.BitSet%29%2Fanother&quot;&gt;another&lt;/a&gt; BitSets. The result is saved in this BitSet.</source>
          <target state="translated">이 비트 비트와 &lt;a href=&quot;and-not#kotlin.native.BitSet%24andNot%28kotlin.native.BitSet%29%2Fanother&quot;&gt;다른&lt;/a&gt; 비트 세트의 해당 비트에 대해 논리 및 + 비 연산을 수행합니다 . 결과는이 BitSet에 저장됩니다.</target>
        </trans-unit>
        <trans-unit id="248264ee3ec26747cef66641b0ab9e9cc36bfb95" translate="yes" xml:space="preserve">
          <source>Performs a logical and operation over corresponding bits of this and &lt;a href=&quot;and#kotlin.native.BitSet%24and%28kotlin.native.BitSet%29%2Fanother&quot;&gt;another&lt;/a&gt; BitSets. The result is saved in this BitSet.</source>
          <target state="translated">이 비트 비트와 &lt;a href=&quot;and#kotlin.native.BitSet%24and%28kotlin.native.BitSet%29%2Fanother&quot;&gt;다른&lt;/a&gt; 비트 세트의 해당 비트에 대해 논리 및 연산을 수행합니다 . 결과는이 BitSet에 저장됩니다.</target>
        </trans-unit>
        <trans-unit id="39156b45f208fe04edcebcf2a0e15108c2b5ecbe" translate="yes" xml:space="preserve">
          <source>Performs a logical or operation over corresponding bits of this and &lt;a href=&quot;or#kotlin.native.BitSet%24or%28kotlin.native.BitSet%29%2Fanother&quot;&gt;another&lt;/a&gt; BitSets. The result is saved in this BitSet.</source>
          <target state="translated">이 비트 비트와 &lt;a href=&quot;or#kotlin.native.BitSet%24or%28kotlin.native.BitSet%29%2Fanother&quot;&gt;다른&lt;/a&gt; 비트 세트의 해당 비트에 대해 논리 또는 연산을 수행합니다 . 결과는이 BitSet에 저장됩니다.</target>
        </trans-unit>
        <trans-unit id="89952362ca0f0ea4e127ac7e85a2c86c496c4d34" translate="yes" xml:space="preserve">
          <source>Performs a logical xor operation over corresponding bits of this and &lt;a href=&quot;xor#kotlin.native.BitSet%24xor%28kotlin.native.BitSet%29%2Fanother&quot;&gt;another&lt;/a&gt; BitSets. The result is saved in this BitSet.</source>
          <target state="translated">이 비트 비트와 &lt;a href=&quot;xor#kotlin.native.BitSet%24xor%28kotlin.native.BitSet%29%2Fanother&quot;&gt;다른&lt;/a&gt; 비트 세트의 해당 비트에 대해 논리 xor 연산을 수행합니다 . 결과는이 BitSet에 저장됩니다.</target>
        </trans-unit>
        <trans-unit id="8778d29dc0dc7d3574ea0e3286cb3d5caa4e81c8" translate="yes" xml:space="preserve">
          <source>Performs the given &lt;a href=&quot;../../kotlin.collections/for-each#kotlin.collections%24forEach%28kotlin.Array%28%28kotlin.collections.forEach.T%29%29%2C+kotlin.Function1%28%28kotlin.collections.forEach.T%2C+kotlin.Unit%29%29%29%2Faction&quot;&gt;action&lt;/a&gt; on each element.</source>
          <target state="translated">각 요소에 대해 주어진 &lt;a href=&quot;../../kotlin.collections/for-each#kotlin.collections%24forEach%28kotlin.Array%28%28kotlin.collections.forEach.T%29%29%2C+kotlin.Function1%28%28kotlin.collections.forEach.T%2C+kotlin.Unit%29%29%29%2Faction&quot;&gt;작업&lt;/a&gt; 을 수행합니다 .</target>
        </trans-unit>
        <trans-unit id="354429514682e691beedeceba088207f7f86e08b" translate="yes" xml:space="preserve">
          <source>Performs the given &lt;a href=&quot;../../kotlin.collections/for-each#kotlin.collections%24forEach%28kotlin.BooleanArray%2C+kotlin.Function1%28%28kotlin.Boolean%2C+kotlin.Unit%29%29%29%2Faction&quot;&gt;action&lt;/a&gt; on each element.</source>
          <target state="translated">각 요소에 대해 주어진 &lt;a href=&quot;../../kotlin.collections/for-each#kotlin.collections%24forEach%28kotlin.BooleanArray%2C+kotlin.Function1%28%28kotlin.Boolean%2C+kotlin.Unit%29%29%29%2Faction&quot;&gt;작업&lt;/a&gt; 을 수행합니다 .</target>
        </trans-unit>
        <trans-unit id="902b222a85bfa2ce3e8bfb951d9b4dc9446d6839" translate="yes" xml:space="preserve">
          <source>Performs the given &lt;a href=&quot;../../kotlin.collections/for-each#kotlin.collections%24forEach%28kotlin.ByteArray%2C+kotlin.Function1%28%28kotlin.Byte%2C+kotlin.Unit%29%29%29%2Faction&quot;&gt;action&lt;/a&gt; on each element.</source>
          <target state="translated">각 요소에 대해 주어진 &lt;a href=&quot;../../kotlin.collections/for-each#kotlin.collections%24forEach%28kotlin.ByteArray%2C+kotlin.Function1%28%28kotlin.Byte%2C+kotlin.Unit%29%29%29%2Faction&quot;&gt;작업&lt;/a&gt; 을 수행합니다 .</target>
        </trans-unit>
        <trans-unit id="3a1029b825870c14a4decbb21d6805858ed0f320" translate="yes" xml:space="preserve">
          <source>Performs the given &lt;a href=&quot;../../kotlin.collections/for-each#kotlin.collections%24forEach%28kotlin.CharArray%2C+kotlin.Function1%28%28kotlin.Char%2C+kotlin.Unit%29%29%29%2Faction&quot;&gt;action&lt;/a&gt; on each element.</source>
          <target state="translated">각 요소에 대해 주어진 &lt;a href=&quot;../../kotlin.collections/for-each#kotlin.collections%24forEach%28kotlin.CharArray%2C+kotlin.Function1%28%28kotlin.Char%2C+kotlin.Unit%29%29%29%2Faction&quot;&gt;작업&lt;/a&gt; 을 수행합니다 .</target>
        </trans-unit>
        <trans-unit id="132e431f819fe0a59343199d4c78f179f89ce62a" translate="yes" xml:space="preserve">
          <source>Performs the given &lt;a href=&quot;../../kotlin.collections/for-each#kotlin.collections%24forEach%28kotlin.DoubleArray%2C+kotlin.Function1%28%28kotlin.Double%2C+kotlin.Unit%29%29%29%2Faction&quot;&gt;action&lt;/a&gt; on each element.</source>
          <target state="translated">각 요소에 대해 주어진 &lt;a href=&quot;../../kotlin.collections/for-each#kotlin.collections%24forEach%28kotlin.DoubleArray%2C+kotlin.Function1%28%28kotlin.Double%2C+kotlin.Unit%29%29%29%2Faction&quot;&gt;작업&lt;/a&gt; 을 수행합니다 .</target>
        </trans-unit>
        <trans-unit id="ff4a1baf61ef7e535c3fc6836d76a4d846af6cf5" translate="yes" xml:space="preserve">
          <source>Performs the given &lt;a href=&quot;../../kotlin.collections/for-each#kotlin.collections%24forEach%28kotlin.FloatArray%2C+kotlin.Function1%28%28kotlin.Float%2C+kotlin.Unit%29%29%29%2Faction&quot;&gt;action&lt;/a&gt; on each element.</source>
          <target state="translated">각 요소에 대해 주어진 &lt;a href=&quot;../../kotlin.collections/for-each#kotlin.collections%24forEach%28kotlin.FloatArray%2C+kotlin.Function1%28%28kotlin.Float%2C+kotlin.Unit%29%29%29%2Faction&quot;&gt;작업&lt;/a&gt; 을 수행합니다 .</target>
        </trans-unit>
        <trans-unit id="bb54c2b7efc5373c1cf68583371d345a5f50c012" translate="yes" xml:space="preserve">
          <source>Performs the given &lt;a href=&quot;../../kotlin.collections/for-each#kotlin.collections%24forEach%28kotlin.IntArray%2C+kotlin.Function1%28%28kotlin.Int%2C+kotlin.Unit%29%29%29%2Faction&quot;&gt;action&lt;/a&gt; on each element.</source>
          <target state="translated">각 요소에 대해 주어진 &lt;a href=&quot;../../kotlin.collections/for-each#kotlin.collections%24forEach%28kotlin.IntArray%2C+kotlin.Function1%28%28kotlin.Int%2C+kotlin.Unit%29%29%29%2Faction&quot;&gt;작업&lt;/a&gt; 을 수행합니다 .</target>
        </trans-unit>
        <trans-unit id="a7b1ee7f732b88eb7700c41ce99b3e032c7ced05" translate="yes" xml:space="preserve">
          <source>Performs the given &lt;a href=&quot;../../kotlin.collections/for-each#kotlin.collections%24forEach%28kotlin.LongArray%2C+kotlin.Function1%28%28kotlin.Long%2C+kotlin.Unit%29%29%29%2Faction&quot;&gt;action&lt;/a&gt; on each element.</source>
          <target state="translated">각 요소에 대해 주어진 &lt;a href=&quot;../../kotlin.collections/for-each#kotlin.collections%24forEach%28kotlin.LongArray%2C+kotlin.Function1%28%28kotlin.Long%2C+kotlin.Unit%29%29%29%2Faction&quot;&gt;작업&lt;/a&gt; 을 수행합니다 .</target>
        </trans-unit>
        <trans-unit id="769e73f068d119cc23fb2e7269a6869a219a4c2f" translate="yes" xml:space="preserve">
          <source>Performs the given &lt;a href=&quot;../../kotlin.collections/for-each#kotlin.collections%24forEach%28kotlin.ShortArray%2C+kotlin.Function1%28%28kotlin.Short%2C+kotlin.Unit%29%29%29%2Faction&quot;&gt;action&lt;/a&gt; on each element.</source>
          <target state="translated">각 요소에 대해 주어진 &lt;a href=&quot;../../kotlin.collections/for-each#kotlin.collections%24forEach%28kotlin.ShortArray%2C+kotlin.Function1%28%28kotlin.Short%2C+kotlin.Unit%29%29%29%2Faction&quot;&gt;작업&lt;/a&gt; 을 수행합니다 .</target>
        </trans-unit>
        <trans-unit id="315872fa4cb4bee637685098226a83214f60bbca" translate="yes" xml:space="preserve">
          <source>Performs the given &lt;a href=&quot;../../kotlin.collections/for-each#kotlin.collections%24forEach%28kotlin.UByteArray%2C+kotlin.Function1%28%28kotlin.UByte%2C+kotlin.Unit%29%29%29%2Faction&quot;&gt;action&lt;/a&gt; on each element.</source>
          <target state="translated">각 요소에 대해 주어진 &lt;a href=&quot;../../kotlin.collections/for-each#kotlin.collections%24forEach%28kotlin.UByteArray%2C+kotlin.Function1%28%28kotlin.UByte%2C+kotlin.Unit%29%29%29%2Faction&quot;&gt;작업&lt;/a&gt; 을 수행합니다 .</target>
        </trans-unit>
        <trans-unit id="be7773eeb96c7f44ff812a4c6c54cebfddc1c39a" translate="yes" xml:space="preserve">
          <source>Performs the given &lt;a href=&quot;../../kotlin.collections/for-each#kotlin.collections%24forEach%28kotlin.UIntArray%2C+kotlin.Function1%28%28kotlin.UInt%2C+kotlin.Unit%29%29%29%2Faction&quot;&gt;action&lt;/a&gt; on each element.</source>
          <target state="translated">각 요소에 대해 주어진 &lt;a href=&quot;../../kotlin.collections/for-each#kotlin.collections%24forEach%28kotlin.UIntArray%2C+kotlin.Function1%28%28kotlin.UInt%2C+kotlin.Unit%29%29%29%2Faction&quot;&gt;작업&lt;/a&gt; 을 수행합니다 .</target>
        </trans-unit>
        <trans-unit id="9d3c644080133080d00a82ec64258b3304250cb1" translate="yes" xml:space="preserve">
          <source>Performs the given &lt;a href=&quot;../../kotlin.collections/for-each#kotlin.collections%24forEach%28kotlin.ULongArray%2C+kotlin.Function1%28%28kotlin.ULong%2C+kotlin.Unit%29%29%29%2Faction&quot;&gt;action&lt;/a&gt; on each element.</source>
          <target state="translated">각 요소에 대해 주어진 &lt;a href=&quot;../../kotlin.collections/for-each#kotlin.collections%24forEach%28kotlin.ULongArray%2C+kotlin.Function1%28%28kotlin.ULong%2C+kotlin.Unit%29%29%29%2Faction&quot;&gt;작업&lt;/a&gt; 을 수행합니다 .</target>
        </trans-unit>
        <trans-unit id="343918dc2653e9b26cd6c78fe46e177a55191bd0" translate="yes" xml:space="preserve">
          <source>Performs the given &lt;a href=&quot;../../kotlin.collections/for-each#kotlin.collections%24forEach%28kotlin.UShortArray%2C+kotlin.Function1%28%28kotlin.UShort%2C+kotlin.Unit%29%29%29%2Faction&quot;&gt;action&lt;/a&gt; on each element.</source>
          <target state="translated">각 요소에 대해 주어진 &lt;a href=&quot;../../kotlin.collections/for-each#kotlin.collections%24forEach%28kotlin.UShortArray%2C+kotlin.Function1%28%28kotlin.UShort%2C+kotlin.Unit%29%29%29%2Faction&quot;&gt;작업&lt;/a&gt; 을 수행합니다 .</target>
        </trans-unit>
        <trans-unit id="60c3854730411666aadc2a5786a5566b6e293813" translate="yes" xml:space="preserve">
          <source>Performs the given &lt;a href=&quot;../../kotlin.collections/for-each#kotlin.collections%24forEach%28kotlin.collections.Iterable%28%28kotlin.collections.forEach.T%29%29%2C+kotlin.Function1%28%28kotlin.collections.forEach.T%2C+kotlin.Unit%29%29%29%2Faction&quot;&gt;action&lt;/a&gt; on each element.</source>
          <target state="translated">각 요소에 대해 주어진 &lt;a href=&quot;../../kotlin.collections/for-each#kotlin.collections%24forEach%28kotlin.collections.Iterable%28%28kotlin.collections.forEach.T%29%29%2C+kotlin.Function1%28%28kotlin.collections.forEach.T%2C+kotlin.Unit%29%29%29%2Faction&quot;&gt;작업&lt;/a&gt; 을 수행합니다 .</target>
        </trans-unit>
        <trans-unit id="156a178c7e2fa943631d6411cce4305751cb118d" translate="yes" xml:space="preserve">
          <source>Performs the given &lt;a href=&quot;../../kotlin.collections/for-each-indexed#kotlin.collections%24forEachIndexed%28kotlin.Array%28%28kotlin.collections.forEachIndexed.T%29%29%2C+kotlin.Function2%28%28kotlin.Int%2C+kotlin.collections.forEachIndexed.T%2C+kotlin.Unit%29%29%29%2Faction&quot;&gt;action&lt;/a&gt; on each element, providing sequential index with the element.</source>
          <target state="translated">요소와 함께 순차적 색인을 제공하여 각 요소에 대해 지정된 &lt;a href=&quot;../../kotlin.collections/for-each-indexed#kotlin.collections%24forEachIndexed%28kotlin.Array%28%28kotlin.collections.forEachIndexed.T%29%29%2C+kotlin.Function2%28%28kotlin.Int%2C+kotlin.collections.forEachIndexed.T%2C+kotlin.Unit%29%29%29%2Faction&quot;&gt;조치&lt;/a&gt; 를 수행합니다 .</target>
        </trans-unit>
        <trans-unit id="fb9edc2371f5689293ab517c3018d2216eee1bfa" translate="yes" xml:space="preserve">
          <source>Performs the given &lt;a href=&quot;../../kotlin.collections/for-each-indexed#kotlin.collections%24forEachIndexed%28kotlin.BooleanArray%2C+kotlin.Function2%28%28kotlin.Int%2C+kotlin.Boolean%2C+kotlin.Unit%29%29%29%2Faction&quot;&gt;action&lt;/a&gt; on each element, providing sequential index with the element.</source>
          <target state="translated">요소와 함께 순차적 색인을 제공하여 각 요소에 대해 지정된 &lt;a href=&quot;../../kotlin.collections/for-each-indexed#kotlin.collections%24forEachIndexed%28kotlin.BooleanArray%2C+kotlin.Function2%28%28kotlin.Int%2C+kotlin.Boolean%2C+kotlin.Unit%29%29%29%2Faction&quot;&gt;조치&lt;/a&gt; 를 수행합니다 .</target>
        </trans-unit>
        <trans-unit id="cccffefe6af8ebe6cc83f72c2165e58f69acf3bb" translate="yes" xml:space="preserve">
          <source>Performs the given &lt;a href=&quot;../../kotlin.collections/for-each-indexed#kotlin.collections%24forEachIndexed%28kotlin.ByteArray%2C+kotlin.Function2%28%28kotlin.Int%2C+kotlin.Byte%2C+kotlin.Unit%29%29%29%2Faction&quot;&gt;action&lt;/a&gt; on each element, providing sequential index with the element.</source>
          <target state="translated">요소와 함께 순차적 색인을 제공하여 각 요소에 대해 지정된 &lt;a href=&quot;../../kotlin.collections/for-each-indexed#kotlin.collections%24forEachIndexed%28kotlin.ByteArray%2C+kotlin.Function2%28%28kotlin.Int%2C+kotlin.Byte%2C+kotlin.Unit%29%29%29%2Faction&quot;&gt;조치&lt;/a&gt; 를 수행합니다 .</target>
        </trans-unit>
        <trans-unit id="1b26e4703dad1494d851f19e309b30697e57ae82" translate="yes" xml:space="preserve">
          <source>Performs the given &lt;a href=&quot;../../kotlin.collections/for-each-indexed#kotlin.collections%24forEachIndexed%28kotlin.CharArray%2C+kotlin.Function2%28%28kotlin.Int%2C+kotlin.Char%2C+kotlin.Unit%29%29%29%2Faction&quot;&gt;action&lt;/a&gt; on each element, providing sequential index with the element.</source>
          <target state="translated">요소와 함께 순차적 색인을 제공하여 각 요소에 대해 지정된 &lt;a href=&quot;../../kotlin.collections/for-each-indexed#kotlin.collections%24forEachIndexed%28kotlin.CharArray%2C+kotlin.Function2%28%28kotlin.Int%2C+kotlin.Char%2C+kotlin.Unit%29%29%29%2Faction&quot;&gt;조치&lt;/a&gt; 를 수행합니다 .</target>
        </trans-unit>
        <trans-unit id="2432517ffef532827d34978f4ef21e42155112dc" translate="yes" xml:space="preserve">
          <source>Performs the given &lt;a href=&quot;../../kotlin.collections/for-each-indexed#kotlin.collections%24forEachIndexed%28kotlin.DoubleArray%2C+kotlin.Function2%28%28kotlin.Int%2C+kotlin.Double%2C+kotlin.Unit%29%29%29%2Faction&quot;&gt;action&lt;/a&gt; on each element, providing sequential index with the element.</source>
          <target state="translated">요소와 함께 순차적 색인을 제공하여 각 요소에 대해 지정된 &lt;a href=&quot;../../kotlin.collections/for-each-indexed#kotlin.collections%24forEachIndexed%28kotlin.DoubleArray%2C+kotlin.Function2%28%28kotlin.Int%2C+kotlin.Double%2C+kotlin.Unit%29%29%29%2Faction&quot;&gt;조치&lt;/a&gt; 를 수행합니다 .</target>
        </trans-unit>
        <trans-unit id="34760498c33bbec4d94a6070c40416c9f57789ac" translate="yes" xml:space="preserve">
          <source>Performs the given &lt;a href=&quot;../../kotlin.collections/for-each-indexed#kotlin.collections%24forEachIndexed%28kotlin.FloatArray%2C+kotlin.Function2%28%28kotlin.Int%2C+kotlin.Float%2C+kotlin.Unit%29%29%29%2Faction&quot;&gt;action&lt;/a&gt; on each element, providing sequential index with the element.</source>
          <target state="translated">요소와 함께 순차적 색인을 제공하여 각 요소에 대해 지정된 &lt;a href=&quot;../../kotlin.collections/for-each-indexed#kotlin.collections%24forEachIndexed%28kotlin.FloatArray%2C+kotlin.Function2%28%28kotlin.Int%2C+kotlin.Float%2C+kotlin.Unit%29%29%29%2Faction&quot;&gt;조치&lt;/a&gt; 를 수행합니다 .</target>
        </trans-unit>
        <trans-unit id="436163486ef4aa6a8403d929f381de1ed09ad5c8" translate="yes" xml:space="preserve">
          <source>Performs the given &lt;a href=&quot;../../kotlin.collections/for-each-indexed#kotlin.collections%24forEachIndexed%28kotlin.IntArray%2C+kotlin.Function2%28%28kotlin.Int%2C+%2C+kotlin.Unit%29%29%29%2Faction&quot;&gt;action&lt;/a&gt; on each element, providing sequential index with the element.</source>
          <target state="translated">요소와 함께 순차적 색인을 제공하여 각 요소에 대해 지정된 &lt;a href=&quot;../../kotlin.collections/for-each-indexed#kotlin.collections%24forEachIndexed%28kotlin.IntArray%2C+kotlin.Function2%28%28kotlin.Int%2C+%2C+kotlin.Unit%29%29%29%2Faction&quot;&gt;조치&lt;/a&gt; 를 수행합니다 .</target>
        </trans-unit>
        <trans-unit id="bcc9e3cfaea470e3580c1c4bb6b1f240a35a554e" translate="yes" xml:space="preserve">
          <source>Performs the given &lt;a href=&quot;../../kotlin.collections/for-each-indexed#kotlin.collections%24forEachIndexed%28kotlin.LongArray%2C+kotlin.Function2%28%28kotlin.Int%2C+kotlin.Long%2C+kotlin.Unit%29%29%29%2Faction&quot;&gt;action&lt;/a&gt; on each element, providing sequential index with the element.</source>
          <target state="translated">요소와 함께 순차적 색인을 제공하여 각 요소에 대해 지정된 &lt;a href=&quot;../../kotlin.collections/for-each-indexed#kotlin.collections%24forEachIndexed%28kotlin.LongArray%2C+kotlin.Function2%28%28kotlin.Int%2C+kotlin.Long%2C+kotlin.Unit%29%29%29%2Faction&quot;&gt;조치&lt;/a&gt; 를 수행합니다 .</target>
        </trans-unit>
        <trans-unit id="ff4766a4cba0adbc0664e324d1c59a412892576a" translate="yes" xml:space="preserve">
          <source>Performs the given &lt;a href=&quot;../../kotlin.collections/for-each-indexed#kotlin.collections%24forEachIndexed%28kotlin.ShortArray%2C+kotlin.Function2%28%28kotlin.Int%2C+kotlin.Short%2C+kotlin.Unit%29%29%29%2Faction&quot;&gt;action&lt;/a&gt; on each element, providing sequential index with the element.</source>
          <target state="translated">요소와 함께 순차적 색인을 제공하여 각 요소에 대해 지정된 &lt;a href=&quot;../../kotlin.collections/for-each-indexed#kotlin.collections%24forEachIndexed%28kotlin.ShortArray%2C+kotlin.Function2%28%28kotlin.Int%2C+kotlin.Short%2C+kotlin.Unit%29%29%29%2Faction&quot;&gt;조치&lt;/a&gt; 를 수행합니다 .</target>
        </trans-unit>
        <trans-unit id="6628be7f64b97fd70255215773475a4a595013a0" translate="yes" xml:space="preserve">
          <source>Performs the given &lt;a href=&quot;../../kotlin.collections/for-each-indexed#kotlin.collections%24forEachIndexed%28kotlin.UByteArray%2C+kotlin.Function2%28%28kotlin.Int%2C+kotlin.UByte%2C+kotlin.Unit%29%29%29%2Faction&quot;&gt;action&lt;/a&gt; on each element, providing sequential index with the element.</source>
          <target state="translated">요소와 함께 순차적 색인을 제공하여 각 요소에 대해 지정된 &lt;a href=&quot;../../kotlin.collections/for-each-indexed#kotlin.collections%24forEachIndexed%28kotlin.UByteArray%2C+kotlin.Function2%28%28kotlin.Int%2C+kotlin.UByte%2C+kotlin.Unit%29%29%29%2Faction&quot;&gt;조치&lt;/a&gt; 를 수행합니다 .</target>
        </trans-unit>
        <trans-unit id="7c75ed24cd0bba9c7f121610cb68dd4ad6d27485" translate="yes" xml:space="preserve">
          <source>Performs the given &lt;a href=&quot;../../kotlin.collections/for-each-indexed#kotlin.collections%24forEachIndexed%28kotlin.UIntArray%2C+kotlin.Function2%28%28kotlin.Int%2C+kotlin.UInt%2C+kotlin.Unit%29%29%29%2Faction&quot;&gt;action&lt;/a&gt; on each element, providing sequential index with the element.</source>
          <target state="translated">요소와 함께 순차적 색인을 제공하여 각 요소에 대해 지정된 &lt;a href=&quot;../../kotlin.collections/for-each-indexed#kotlin.collections%24forEachIndexed%28kotlin.UIntArray%2C+kotlin.Function2%28%28kotlin.Int%2C+kotlin.UInt%2C+kotlin.Unit%29%29%29%2Faction&quot;&gt;조치&lt;/a&gt; 를 수행합니다 .</target>
        </trans-unit>
        <trans-unit id="fc3ae4f7b218e21e390940d489b5aaad31231608" translate="yes" xml:space="preserve">
          <source>Performs the given &lt;a href=&quot;../../kotlin.collections/for-each-indexed#kotlin.collections%24forEachIndexed%28kotlin.ULongArray%2C+kotlin.Function2%28%28kotlin.Int%2C+kotlin.ULong%2C+kotlin.Unit%29%29%29%2Faction&quot;&gt;action&lt;/a&gt; on each element, providing sequential index with the element.</source>
          <target state="translated">요소와 함께 순차적 색인을 제공하여 각 요소에 대해 지정된 &lt;a href=&quot;../../kotlin.collections/for-each-indexed#kotlin.collections%24forEachIndexed%28kotlin.ULongArray%2C+kotlin.Function2%28%28kotlin.Int%2C+kotlin.ULong%2C+kotlin.Unit%29%29%29%2Faction&quot;&gt;조치&lt;/a&gt; 를 수행합니다 .</target>
        </trans-unit>
        <trans-unit id="a8c1524a85fc3b689fcfa6b2f1e64351adedd584" translate="yes" xml:space="preserve">
          <source>Performs the given &lt;a href=&quot;../../kotlin.collections/for-each-indexed#kotlin.collections%24forEachIndexed%28kotlin.UShortArray%2C+kotlin.Function2%28%28kotlin.Int%2C+kotlin.UShort%2C+kotlin.Unit%29%29%29%2Faction&quot;&gt;action&lt;/a&gt; on each element, providing sequential index with the element.</source>
          <target state="translated">요소와 함께 순차적 색인을 제공하여 각 요소에 대해 지정된 &lt;a href=&quot;../../kotlin.collections/for-each-indexed#kotlin.collections%24forEachIndexed%28kotlin.UShortArray%2C+kotlin.Function2%28%28kotlin.Int%2C+kotlin.UShort%2C+kotlin.Unit%29%29%29%2Faction&quot;&gt;조치&lt;/a&gt; 를 수행합니다 .</target>
        </trans-unit>
        <trans-unit id="8d63f486ca4249c62fd4fe22e2b76611a0fea4ee" translate="yes" xml:space="preserve">
          <source>Performs the given &lt;a href=&quot;../../kotlin.collections/for-each-indexed#kotlin.collections%24forEachIndexed%28kotlin.collections.Iterable%28%28kotlin.collections.forEachIndexed.T%29%29%2C+kotlin.Function2%28%28kotlin.Int%2C+kotlin.collections.forEachIndexed.T%2C+kotlin.Unit%29%29%29%2Faction&quot;&gt;action&lt;/a&gt; on each element, providing sequential index with the element.</source>
          <target state="translated">요소와 함께 순차적 색인을 제공하여 각 요소에 대해 지정된 &lt;a href=&quot;../../kotlin.collections/for-each-indexed#kotlin.collections%24forEachIndexed%28kotlin.collections.Iterable%28%28kotlin.collections.forEachIndexed.T%29%29%2C+kotlin.Function2%28%28kotlin.Int%2C+kotlin.collections.forEachIndexed.T%2C+kotlin.Unit%29%29%29%2Faction&quot;&gt;조치&lt;/a&gt; 를 수행합니다 .</target>
        </trans-unit>
        <trans-unit id="9bb69c054b7cc08bfa79083dfdb96baed031f4ce" translate="yes" xml:space="preserve">
          <source>Performs the given &lt;a href=&quot;../../kotlin.collections/on-each#kotlin.collections%24onEach%28kotlin.collections.onEach.C%2C+kotlin.Function1%28%28kotlin.collections.onEach.T%2C+kotlin.Unit%29%29%29%2Faction&quot;&gt;action&lt;/a&gt; on each element and returns the collection itself afterwards.</source>
          <target state="translated">각 요소에 대해 지정된 &lt;a href=&quot;../../kotlin.collections/on-each#kotlin.collections%24onEach%28kotlin.collections.onEach.C%2C+kotlin.Function1%28%28kotlin.collections.onEach.T%2C+kotlin.Unit%29%29%29%2Faction&quot;&gt;작업&lt;/a&gt; 을 수행하고 나중에 컬렉션 자체를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="0e5ae0e9e37604365a59cffd9ebd8b0458d25c60" translate="yes" xml:space="preserve">
          <source>Performs the given &lt;a href=&quot;../../kotlin.text/for-each#kotlin.text%24forEach%28kotlin.CharSequence%2C+kotlin.Function1%28%28kotlin.Char%2C+kotlin.Unit%29%29%29%2Faction&quot;&gt;action&lt;/a&gt; on each character.</source>
          <target state="translated">각 캐릭터에 대해 주어진 &lt;a href=&quot;../../kotlin.text/for-each#kotlin.text%24forEach%28kotlin.CharSequence%2C+kotlin.Function1%28%28kotlin.Char%2C+kotlin.Unit%29%29%29%2Faction&quot;&gt;동작&lt;/a&gt; 을 수행합니다 .</target>
        </trans-unit>
        <trans-unit id="df20894630de9dca9b041239dba3714304624d44" translate="yes" xml:space="preserve">
          <source>Performs the given &lt;a href=&quot;../../kotlin.text/for-each-indexed#kotlin.text%24forEachIndexed%28kotlin.CharSequence%2C+kotlin.Function2%28%28kotlin.Int%2C+kotlin.Char%2C+kotlin.Unit%29%29%29%2Faction&quot;&gt;action&lt;/a&gt; on each character, providing sequential index with the character.</source>
          <target state="translated">각 문자에 대해 지정된 &lt;a href=&quot;../../kotlin.text/for-each-indexed#kotlin.text%24forEachIndexed%28kotlin.CharSequence%2C+kotlin.Function2%28%28kotlin.Int%2C+kotlin.Char%2C+kotlin.Unit%29%29%29%2Faction&quot;&gt;조치&lt;/a&gt; 를 수행하여 문자와 함께 순차적 색인을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="9c39c510f61f6934c4d4717c38fda9525b7f9e71" translate="yes" xml:space="preserve">
          <source>Performs the given &lt;a href=&quot;../../kotlin.text/on-each#kotlin.text%24onEach%28kotlin.text.onEach.S%2C+kotlin.Function1%28%28kotlin.Char%2C+kotlin.Unit%29%29%29%2Faction&quot;&gt;action&lt;/a&gt; on each character and returns the char sequence itself afterwards.</source>
          <target state="translated">각 문자에 대해 지정된 &lt;a href=&quot;../../kotlin.text/on-each#kotlin.text%24onEach%28kotlin.text.onEach.S%2C+kotlin.Function1%28%28kotlin.Char%2C+kotlin.Unit%29%29%29%2Faction&quot;&gt;동작&lt;/a&gt; 을 수행 한 후 문자 시퀀스 자체를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="89821f6d1cc426bf722b8dc4cde256a1620cb225" translate="yes" xml:space="preserve">
          <source>Performs the given &lt;a href=&quot;../for-each#kotlin.collections%24forEach%28kotlin.collections.Iterable%28%28kotlin.collections.forEach.T%29%29%2C+kotlin.Function1%28%28kotlin.collections.forEach.T%2C+kotlin.Unit%29%29%29%2Faction&quot;&gt;action&lt;/a&gt; on each element.</source>
          <target state="translated">각 요소에 대해 주어진 &lt;a href=&quot;../for-each#kotlin.collections%24forEach%28kotlin.collections.Iterable%28%28kotlin.collections.forEach.T%29%29%2C+kotlin.Function1%28%28kotlin.collections.forEach.T%2C+kotlin.Unit%29%29%29%2Faction&quot;&gt;작업&lt;/a&gt; 을 수행합니다 .</target>
        </trans-unit>
        <trans-unit id="4e210d2ff57fa0fcccace8b4e8d2d4e17d2b1534" translate="yes" xml:space="preserve">
          <source>Performs the given &lt;a href=&quot;../for-each#kotlin.collections%24forEach%28kotlin.collections.Iterator%28%28kotlin.collections.forEach.T%29%29%2C+kotlin.Function1%28%28kotlin.collections.forEach.T%2C+kotlin.Unit%29%29%29%2Foperation&quot;&gt;operation&lt;/a&gt; on each element of this &lt;a href=&quot;../-iterator/index#kotlin.collections.Iterator&quot;&gt;Iterator&lt;/a&gt;.</source>
          <target state="translated">이 &lt;a href=&quot;../-iterator/index#kotlin.collections.Iterator&quot;&gt;반복자의&lt;/a&gt; 각 요소에 대해 지정된 &lt;a href=&quot;../for-each#kotlin.collections%24forEach%28kotlin.collections.Iterator%28%28kotlin.collections.forEach.T%29%29%2C+kotlin.Function1%28%28kotlin.collections.forEach.T%2C+kotlin.Unit%29%29%29%2Foperation&quot;&gt;작업&lt;/a&gt; 을 수행합니다 .</target>
        </trans-unit>
        <trans-unit id="6a050e79c3140ce79cd41930bd591ab179061a6a" translate="yes" xml:space="preserve">
          <source>Performs the given &lt;a href=&quot;../for-each#kotlin.collections%24forEach%28kotlin.collections.Iterator%28%28kotlin.collections.forEach.T%29%29%2C+kotlin.Function1%28%28kotlin.collections.forEach.T%2C+kotlin.Unit%29%29%29%2Foperation&quot;&gt;operation&lt;/a&gt; on each element of this &lt;a href=&quot;index#kotlin.collections.Iterator&quot;&gt;Iterator&lt;/a&gt;.</source>
          <target state="translated">이 &lt;a href=&quot;index#kotlin.collections.Iterator&quot;&gt;반복자의&lt;/a&gt; 각 요소에 대해 지정된 &lt;a href=&quot;../for-each#kotlin.collections%24forEach%28kotlin.collections.Iterator%28%28kotlin.collections.forEach.T%29%29%2C+kotlin.Function1%28%28kotlin.collections.forEach.T%2C+kotlin.Unit%29%29%29%2Foperation&quot;&gt;작업&lt;/a&gt; 을 수행합니다 .</target>
        </trans-unit>
        <trans-unit id="508a343134493917d3257ce3b73078bbdb0e7f64" translate="yes" xml:space="preserve">
          <source>Performs the given &lt;a href=&quot;../for-each#kotlin.collections%24forEach%28kotlin.collections.Map%28%28kotlin.collections.forEach.K%2C+kotlin.collections.forEach.V%29%29%2C+kotlin.Function1%28%28kotlin.collections.Map.Entry%28%28kotlin.collections.forEach.K%2C+kotlin.collections.forEach.V%29%29%2C+kotlin.Unit%29%29%29%2Faction&quot;&gt;action&lt;/a&gt; on each entry.</source>
          <target state="translated">각 항목에 대해 주어진 &lt;a href=&quot;../for-each#kotlin.collections%24forEach%28kotlin.collections.Map%28%28kotlin.collections.forEach.K%2C+kotlin.collections.forEach.V%29%29%2C+kotlin.Function1%28%28kotlin.collections.Map.Entry%28%28kotlin.collections.forEach.K%2C+kotlin.collections.forEach.V%29%29%2C+kotlin.Unit%29%29%29%2Faction&quot;&gt;작업&lt;/a&gt; 을 수행합니다 .</target>
        </trans-unit>
        <trans-unit id="7bf498ae32274e7f17b67341cf2d07b308f50bb4" translate="yes" xml:space="preserve">
          <source>Performs the given &lt;a href=&quot;../for-each#kotlin.sequences%24forEach%28kotlin.sequences.Sequence%28%28kotlin.sequences.forEach.T%29%29%2C+kotlin.Function1%28%28kotlin.sequences.forEach.T%2C+kotlin.Unit%29%29%29%2Faction&quot;&gt;action&lt;/a&gt; on each element.</source>
          <target state="translated">각 요소에 대해 주어진 &lt;a href=&quot;../for-each#kotlin.sequences%24forEach%28kotlin.sequences.Sequence%28%28kotlin.sequences.forEach.T%29%29%2C+kotlin.Function1%28%28kotlin.sequences.forEach.T%2C+kotlin.Unit%29%29%29%2Faction&quot;&gt;작업&lt;/a&gt; 을 수행합니다 .</target>
        </trans-unit>
        <trans-unit id="f6e8aced5304e72e8ba36a5362b2d10c41f72428" translate="yes" xml:space="preserve">
          <source>Performs the given &lt;a href=&quot;../for-each#kotlin.text%24forEach%28kotlin.CharSequence%2C+kotlin.Function1%28%28kotlin.Char%2C+kotlin.Unit%29%29%29%2Faction&quot;&gt;action&lt;/a&gt; on each character.</source>
          <target state="translated">각 캐릭터에 대해 주어진 &lt;a href=&quot;../for-each#kotlin.text%24forEach%28kotlin.CharSequence%2C+kotlin.Function1%28%28kotlin.Char%2C+kotlin.Unit%29%29%29%2Faction&quot;&gt;동작&lt;/a&gt; 을 수행합니다 .</target>
        </trans-unit>
        <trans-unit id="6184ad680ff62a8a1a5f1c8545e1700ca1b43884" translate="yes" xml:space="preserve">
          <source>Performs the given &lt;a href=&quot;../for-each-indexed#kotlin.collections%24forEachIndexed%28kotlin.collections.Iterable%28%28kotlin.collections.forEachIndexed.T%29%29%2C+kotlin.Function2%28%28kotlin.Int%2C+kotlin.collections.forEachIndexed.T%2C+kotlin.Unit%29%29%29%2Faction&quot;&gt;action&lt;/a&gt; on each element, providing sequential index with the element.</source>
          <target state="translated">요소와 함께 순차적 색인을 제공하여 각 요소에 대해 지정된 &lt;a href=&quot;../for-each-indexed#kotlin.collections%24forEachIndexed%28kotlin.collections.Iterable%28%28kotlin.collections.forEachIndexed.T%29%29%2C+kotlin.Function2%28%28kotlin.Int%2C+kotlin.collections.forEachIndexed.T%2C+kotlin.Unit%29%29%29%2Faction&quot;&gt;조치&lt;/a&gt; 를 수행합니다 .</target>
        </trans-unit>
        <trans-unit id="4ffe16b2047dd6b905902ecb7cd8c68c1882f05d" translate="yes" xml:space="preserve">
          <source>Performs the given &lt;a href=&quot;../for-each-indexed#kotlin.sequences%24forEachIndexed%28kotlin.sequences.Sequence%28%28kotlin.sequences.forEachIndexed.T%29%29%2C+kotlin.Function2%28%28kotlin.Int%2C+kotlin.sequences.forEachIndexed.T%2C+kotlin.Unit%29%29%29%2Faction&quot;&gt;action&lt;/a&gt; on each element, providing sequential index with the element.</source>
          <target state="translated">요소와 함께 순차적 색인을 제공하여 각 요소에 대해 지정된 &lt;a href=&quot;../for-each-indexed#kotlin.sequences%24forEachIndexed%28kotlin.sequences.Sequence%28%28kotlin.sequences.forEachIndexed.T%29%29%2C+kotlin.Function2%28%28kotlin.Int%2C+kotlin.sequences.forEachIndexed.T%2C+kotlin.Unit%29%29%29%2Faction&quot;&gt;조치&lt;/a&gt; 를 수행합니다 .</target>
        </trans-unit>
        <trans-unit id="c398757f124a04f252a4f84eb4bc0ea90ee0e1c6" translate="yes" xml:space="preserve">
          <source>Performs the given &lt;a href=&quot;../for-each-indexed#kotlin.text%24forEachIndexed%28kotlin.CharSequence%2C+kotlin.Function2%28%28kotlin.Int%2C+kotlin.Char%2C+kotlin.Unit%29%29%29%2Faction&quot;&gt;action&lt;/a&gt; on each character, providing sequential index with the character.</source>
          <target state="translated">각 문자에 대해 지정된 &lt;a href=&quot;../for-each-indexed#kotlin.text%24forEachIndexed%28kotlin.CharSequence%2C+kotlin.Function2%28%28kotlin.Int%2C+kotlin.Char%2C+kotlin.Unit%29%29%29%2Faction&quot;&gt;조치&lt;/a&gt; 를 수행하여 문자와 함께 순차적 색인을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="4cf6ab376a8e39291fbabff216f6baa19f10110e" translate="yes" xml:space="preserve">
          <source>Performs the given &lt;a href=&quot;../on-each#kotlin.collections%24onEach%28kotlin.collections.onEach.C%2C+kotlin.Function1%28%28kotlin.collections.onEach.T%2C+kotlin.Unit%29%29%29%2Faction&quot;&gt;action&lt;/a&gt; on each element and returns the collection itself afterwards.</source>
          <target state="translated">각 요소에 대해 지정된 &lt;a href=&quot;../on-each#kotlin.collections%24onEach%28kotlin.collections.onEach.C%2C+kotlin.Function1%28%28kotlin.collections.onEach.T%2C+kotlin.Unit%29%29%29%2Faction&quot;&gt;작업&lt;/a&gt; 을 수행하고 나중에 컬렉션 자체를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="e26d4f16f359e801f3511fe82a5c09dea69f579a" translate="yes" xml:space="preserve">
          <source>Performs the given &lt;a href=&quot;../on-each#kotlin.collections%24onEach%28kotlin.collections.onEach.M%2C+kotlin.Function1%28%28kotlin.collections.Map.Entry%28%28kotlin.collections.onEach.K%2C+kotlin.collections.onEach.V%29%29%2C+kotlin.Unit%29%29%29%2Faction&quot;&gt;action&lt;/a&gt; on each entry and returns the map itself afterwards.</source>
          <target state="translated">각 항목에 대해 지정된 &lt;a href=&quot;../on-each#kotlin.collections%24onEach%28kotlin.collections.onEach.M%2C+kotlin.Function1%28%28kotlin.collections.Map.Entry%28%28kotlin.collections.onEach.K%2C+kotlin.collections.onEach.V%29%29%2C+kotlin.Unit%29%29%29%2Faction&quot;&gt;작업&lt;/a&gt; 을 수행 한 후지 도 자체를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="631fdcf8194c5e79e1a4409f3a3f4c7539d32a0e" translate="yes" xml:space="preserve">
          <source>Performs the given &lt;a href=&quot;../on-each#kotlin.text%24onEach%28kotlin.text.onEach.S%2C+kotlin.Function1%28%28kotlin.Char%2C+kotlin.Unit%29%29%29%2Faction&quot;&gt;action&lt;/a&gt; on each character and returns the char sequence itself afterwards.</source>
          <target state="translated">각 문자에 대해 지정된 &lt;a href=&quot;../on-each#kotlin.text%24onEach%28kotlin.text.onEach.S%2C+kotlin.Function1%28%28kotlin.Char%2C+kotlin.Unit%29%29%29%2Faction&quot;&gt;동작&lt;/a&gt; 을 수행 한 후 문자 시퀀스 자체를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="5113d7c5fc0a6d8bba9b090f482e4648076619ba" translate="yes" xml:space="preserve">
          <source>Performs the given &lt;a href=&quot;../on-failure#kotlin%24onFailure%28kotlin.Result%28%28kotlin.onFailure.T%29%29%2C+kotlin.Function1%28%28kotlin.Throwable%2C+kotlin.Unit%29%29%29%2Faction&quot;&gt;action&lt;/a&gt; on encapsulated exception if this instance represents &lt;a href=&quot;is-failure&quot;&gt;failure&lt;/a&gt;. Returns the original &lt;code&gt;Result&lt;/code&gt; unchanged.</source>
          <target state="translated">이 인스턴스가 &lt;a href=&quot;is-failure&quot;&gt;실패&lt;/a&gt; 를 나타내는 경우, 캡슐화 된 예외에 대해 지정된 &lt;a href=&quot;../on-failure#kotlin%24onFailure%28kotlin.Result%28%28kotlin.onFailure.T%29%29%2C+kotlin.Function1%28%28kotlin.Throwable%2C+kotlin.Unit%29%29%29%2Faction&quot;&gt;조치&lt;/a&gt; 를 수행합니다 . 원래 &lt;code&gt;Result&lt;/code&gt; 변경하지 않고 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="f2481f64f700561b8b558fa47b71f60a5d75e5c2" translate="yes" xml:space="preserve">
          <source>Performs the given &lt;a href=&quot;../on-success#kotlin%24onSuccess%28kotlin.Result%28%28kotlin.onSuccess.T%29%29%2C+kotlin.Function1%28%28kotlin.onSuccess.T%2C+kotlin.Unit%29%29%29%2Faction&quot;&gt;action&lt;/a&gt; on encapsulated value if this instance represents &lt;a href=&quot;is-success&quot;&gt;success&lt;/a&gt;. Returns the original &lt;code&gt;Result&lt;/code&gt; unchanged.</source>
          <target state="translated">이 인스턴스가 &lt;a href=&quot;is-success&quot;&gt;성공을&lt;/a&gt; 나타내는 경우, 캡슐화 된 값에 대해 지정된 &lt;a href=&quot;../on-success#kotlin%24onSuccess%28kotlin.Result%28%28kotlin.onSuccess.T%29%29%2C+kotlin.Function1%28%28kotlin.onSuccess.T%2C+kotlin.Unit%29%29%29%2Faction&quot;&gt;동작&lt;/a&gt; 을 수행합니다 . 원래 &lt;code&gt;Result&lt;/code&gt; 변경하지 않고 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="cefe0cdb2472abe9bb2db7d20ff5ae01ad642a92" translate="yes" xml:space="preserve">
          <source>Performs the given &lt;a href=&quot;for-each#kotlin.collections%24forEach%28kotlin.Array%28%28kotlin.collections.forEach.T%29%29%2C+kotlin.Function1%28%28kotlin.collections.forEach.T%2C+kotlin.Unit%29%29%29%2Faction&quot;&gt;action&lt;/a&gt; on each element.</source>
          <target state="translated">각 요소에 대해 주어진 &lt;a href=&quot;for-each#kotlin.collections%24forEach%28kotlin.Array%28%28kotlin.collections.forEach.T%29%29%2C+kotlin.Function1%28%28kotlin.collections.forEach.T%2C+kotlin.Unit%29%29%29%2Faction&quot;&gt;작업&lt;/a&gt; 을 수행합니다 .</target>
        </trans-unit>
        <trans-unit id="74cfdb87e8c93e5d2dbc176b9e82eb5119e13838" translate="yes" xml:space="preserve">
          <source>Performs the given &lt;a href=&quot;for-each#kotlin.collections%24forEach%28kotlin.collections.Iterator%28%28kotlin.collections.forEach.T%29%29%2C+kotlin.Function1%28%28kotlin.collections.forEach.T%2C+kotlin.Unit%29%29%29%2Foperation&quot;&gt;operation&lt;/a&gt; on each element of this &lt;a href=&quot;-iterator/index#kotlin.collections.Iterator&quot;&gt;Iterator&lt;/a&gt;.</source>
          <target state="translated">이 &lt;a href=&quot;-iterator/index#kotlin.collections.Iterator&quot;&gt;반복자의&lt;/a&gt; 각 요소에 대해 지정된 &lt;a href=&quot;for-each#kotlin.collections%24forEach%28kotlin.collections.Iterator%28%28kotlin.collections.forEach.T%29%29%2C+kotlin.Function1%28%28kotlin.collections.forEach.T%2C+kotlin.Unit%29%29%29%2Foperation&quot;&gt;작업&lt;/a&gt; 을 수행합니다 .</target>
        </trans-unit>
        <trans-unit id="cdf31e1a626bd0a40a6edad4167805ec6579b18c" translate="yes" xml:space="preserve">
          <source>Performs the given &lt;a href=&quot;for-each#kotlin.collections%24forEach%28kotlin.collections.Map%28%28kotlin.collections.forEach.K%2C+kotlin.collections.forEach.V%29%29%2C+kotlin.Function1%28%28kotlin.collections.Map.Entry%28%28kotlin.collections.forEach.K%2C+kotlin.collections.forEach.V%29%29%2C+kotlin.Unit%29%29%29%2Faction&quot;&gt;action&lt;/a&gt; on each entry.</source>
          <target state="translated">각 항목에 대해 주어진 &lt;a href=&quot;for-each#kotlin.collections%24forEach%28kotlin.collections.Map%28%28kotlin.collections.forEach.K%2C+kotlin.collections.forEach.V%29%29%2C+kotlin.Function1%28%28kotlin.collections.Map.Entry%28%28kotlin.collections.forEach.K%2C+kotlin.collections.forEach.V%29%29%2C+kotlin.Unit%29%29%29%2Faction&quot;&gt;작업&lt;/a&gt; 을 수행합니다 .</target>
        </trans-unit>
        <trans-unit id="09672fbc97176d09fe72c4f3a1054557676675e0" translate="yes" xml:space="preserve">
          <source>Performs the given &lt;a href=&quot;for-each#kotlin.sequences%24forEach%28kotlin.sequences.Sequence%28%28kotlin.sequences.forEach.T%29%29%2C+kotlin.Function1%28%28kotlin.sequences.forEach.T%2C+kotlin.Unit%29%29%29%2Faction&quot;&gt;action&lt;/a&gt; on each element.</source>
          <target state="translated">각 요소에 대해 주어진 &lt;a href=&quot;for-each#kotlin.sequences%24forEach%28kotlin.sequences.Sequence%28%28kotlin.sequences.forEach.T%29%29%2C+kotlin.Function1%28%28kotlin.sequences.forEach.T%2C+kotlin.Unit%29%29%29%2Faction&quot;&gt;작업&lt;/a&gt; 을 수행합니다 .</target>
        </trans-unit>
        <trans-unit id="c42b8f4b18bfd5f61c52144605ca972edf9ee166" translate="yes" xml:space="preserve">
          <source>Performs the given &lt;a href=&quot;for-each#kotlin.text%24forEach%28kotlin.CharSequence%2C+kotlin.Function1%28%28kotlin.Char%2C+kotlin.Unit%29%29%29%2Faction&quot;&gt;action&lt;/a&gt; on each character.</source>
          <target state="translated">각 캐릭터에 대해 주어진 &lt;a href=&quot;for-each#kotlin.text%24forEach%28kotlin.CharSequence%2C+kotlin.Function1%28%28kotlin.Char%2C+kotlin.Unit%29%29%29%2Faction&quot;&gt;동작&lt;/a&gt; 을 수행합니다 .</target>
        </trans-unit>
        <trans-unit id="d6ca50a33d9ab0eaef78344b9b0e985ffdc01270" translate="yes" xml:space="preserve">
          <source>Performs the given &lt;a href=&quot;for-each-indexed#kotlin.collections%24forEachIndexed%28kotlin.Array%28%28kotlin.collections.forEachIndexed.T%29%29%2C+kotlin.Function2%28%28kotlin.Int%2C+kotlin.collections.forEachIndexed.T%2C+kotlin.Unit%29%29%29%2Faction&quot;&gt;action&lt;/a&gt; on each element, providing sequential index with the element.</source>
          <target state="translated">요소와 함께 순차적 색인을 제공하여 각 요소에 대해 지정된 &lt;a href=&quot;for-each-indexed#kotlin.collections%24forEachIndexed%28kotlin.Array%28%28kotlin.collections.forEachIndexed.T%29%29%2C+kotlin.Function2%28%28kotlin.Int%2C+kotlin.collections.forEachIndexed.T%2C+kotlin.Unit%29%29%29%2Faction&quot;&gt;조치&lt;/a&gt; 를 수행합니다 .</target>
        </trans-unit>
        <trans-unit id="67883b089471a47542ce82cc71c8d658a4654dbf" translate="yes" xml:space="preserve">
          <source>Performs the given &lt;a href=&quot;for-each-indexed#kotlin.sequences%24forEachIndexed%28kotlin.sequences.Sequence%28%28kotlin.sequences.forEachIndexed.T%29%29%2C+kotlin.Function2%28%28kotlin.Int%2C+kotlin.sequences.forEachIndexed.T%2C+kotlin.Unit%29%29%29%2Faction&quot;&gt;action&lt;/a&gt; on each element, providing sequential index with the element.</source>
          <target state="translated">요소와 함께 순차적 색인을 제공하여 각 요소에 대해 지정된 &lt;a href=&quot;for-each-indexed#kotlin.sequences%24forEachIndexed%28kotlin.sequences.Sequence%28%28kotlin.sequences.forEachIndexed.T%29%29%2C+kotlin.Function2%28%28kotlin.Int%2C+kotlin.sequences.forEachIndexed.T%2C+kotlin.Unit%29%29%29%2Faction&quot;&gt;조치&lt;/a&gt; 를 수행합니다 .</target>
        </trans-unit>
        <trans-unit id="eeafadabb6804f8c23d35fa4b28517fcceea85f4" translate="yes" xml:space="preserve">
          <source>Performs the given &lt;a href=&quot;for-each-indexed#kotlin.text%24forEachIndexed%28kotlin.CharSequence%2C+kotlin.Function2%28%28kotlin.Int%2C+kotlin.Char%2C+kotlin.Unit%29%29%29%2Faction&quot;&gt;action&lt;/a&gt; on each character, providing sequential index with the character.</source>
          <target state="translated">각 문자에 대해 지정된 &lt;a href=&quot;for-each-indexed#kotlin.text%24forEachIndexed%28kotlin.CharSequence%2C+kotlin.Function2%28%28kotlin.Int%2C+kotlin.Char%2C+kotlin.Unit%29%29%29%2Faction&quot;&gt;조치&lt;/a&gt; 를 수행하여 문자와 함께 순차적 색인을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="a1d1b6a88dfe42c618a5b1ca25fc0d5d894063de" translate="yes" xml:space="preserve">
          <source>Performs the given &lt;a href=&quot;on-each#kotlin.collections%24onEach%28kotlin.collections.onEach.C%2C+kotlin.Function1%28%28kotlin.collections.onEach.T%2C+kotlin.Unit%29%29%29%2Faction&quot;&gt;action&lt;/a&gt; on each element and returns the collection itself afterwards.</source>
          <target state="translated">각 요소에 대해 지정된 &lt;a href=&quot;on-each#kotlin.collections%24onEach%28kotlin.collections.onEach.C%2C+kotlin.Function1%28%28kotlin.collections.onEach.T%2C+kotlin.Unit%29%29%29%2Faction&quot;&gt;작업&lt;/a&gt; 을 수행하고 나중에 컬렉션 자체를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="374017948a2d0fcd87819b8874959606012dabaf" translate="yes" xml:space="preserve">
          <source>Performs the given &lt;a href=&quot;on-each#kotlin.collections%24onEach%28kotlin.collections.onEach.M%2C+kotlin.Function1%28%28kotlin.collections.Map.Entry%28%28kotlin.collections.onEach.K%2C+kotlin.collections.onEach.V%29%29%2C+kotlin.Unit%29%29%29%2Faction&quot;&gt;action&lt;/a&gt; on each entry and returns the map itself afterwards.</source>
          <target state="translated">각 항목에 대해 지정된 &lt;a href=&quot;on-each#kotlin.collections%24onEach%28kotlin.collections.onEach.M%2C+kotlin.Function1%28%28kotlin.collections.Map.Entry%28%28kotlin.collections.onEach.K%2C+kotlin.collections.onEach.V%29%29%2C+kotlin.Unit%29%29%29%2Faction&quot;&gt;작업&lt;/a&gt; 을 수행 한 후지 도 자체를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="bef24848056c83d4896d0c344a733cfe72650d07" translate="yes" xml:space="preserve">
          <source>Performs the given &lt;a href=&quot;on-each#kotlin.text%24onEach%28kotlin.text.onEach.S%2C+kotlin.Function1%28%28kotlin.Char%2C+kotlin.Unit%29%29%29%2Faction&quot;&gt;action&lt;/a&gt; on each character and returns the char sequence itself afterwards.</source>
          <target state="translated">각 문자에 대해 지정된 &lt;a href=&quot;on-each#kotlin.text%24onEach%28kotlin.text.onEach.S%2C+kotlin.Function1%28%28kotlin.Char%2C+kotlin.Unit%29%29%29%2Faction&quot;&gt;동작&lt;/a&gt; 을 수행 한 후 문자 시퀀스 자체를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="ae5dd943a998bf0632072e1a8c0d1cad78ad3f17" translate="yes" xml:space="preserve">
          <source>Performs the given &lt;a href=&quot;on-failure#kotlin%24onFailure%28kotlin.Result%28%28kotlin.onFailure.T%29%29%2C+kotlin.Function1%28%28kotlin.Throwable%2C+kotlin.Unit%29%29%29%2Faction&quot;&gt;action&lt;/a&gt; on encapsulated exception if this instance represents &lt;a href=&quot;-result/is-failure&quot;&gt;failure&lt;/a&gt;. Returns the original &lt;code&gt;Result&lt;/code&gt; unchanged.</source>
          <target state="translated">이 인스턴스가 &lt;a href=&quot;-result/is-failure&quot;&gt;실패&lt;/a&gt; 를 나타내는 경우, 캡슐화 된 예외에 대해 지정된 &lt;a href=&quot;on-failure#kotlin%24onFailure%28kotlin.Result%28%28kotlin.onFailure.T%29%29%2C+kotlin.Function1%28%28kotlin.Throwable%2C+kotlin.Unit%29%29%29%2Faction&quot;&gt;조치&lt;/a&gt; 를 수행합니다 . 원래 &lt;code&gt;Result&lt;/code&gt; 변경하지 않고 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="67384b74c028474cb5ed6795583a3caee43626b0" translate="yes" xml:space="preserve">
          <source>Performs the given &lt;a href=&quot;on-success#kotlin%24onSuccess%28kotlin.Result%28%28kotlin.onSuccess.T%29%29%2C+kotlin.Function1%28%28kotlin.onSuccess.T%2C+kotlin.Unit%29%29%29%2Faction&quot;&gt;action&lt;/a&gt; on encapsulated value if this instance represents &lt;a href=&quot;-result/is-success&quot;&gt;success&lt;/a&gt;. Returns the original &lt;code&gt;Result&lt;/code&gt; unchanged.</source>
          <target state="translated">이 인스턴스가 &lt;a href=&quot;-result/is-success&quot;&gt;성공을&lt;/a&gt; 나타내는 경우, 캡슐화 된 값에 대해 지정된 &lt;a href=&quot;on-success#kotlin%24onSuccess%28kotlin.Result%28%28kotlin.onSuccess.T%29%29%2C+kotlin.Function1%28%28kotlin.onSuccess.T%2C+kotlin.Unit%29%29%29%2Faction&quot;&gt;동작&lt;/a&gt; 을 수행합니다 . 원래 &lt;code&gt;Result&lt;/code&gt; 변경하지 않고 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="f2055702950dd7647317e43a271427aab2f0320c" translate="yes" xml:space="preserve">
          <source>Performs type cast of the &lt;a href=&quot;-c-pointer/index&quot;&gt;CPointer&lt;/a&gt; from the given raw pointer.</source>
          <target state="translated">지정된 raw 포인터에서 &lt;a href=&quot;-c-pointer/index&quot;&gt;CPointer&lt;/a&gt; 의 유형 캐스트를 수행합니다 .</target>
        </trans-unit>
        <trans-unit id="dff1870d6c391af7bfc6f9c31b9fd3e1f22424a0" translate="yes" xml:space="preserve">
          <source>Performs type cast of the native pointer to given interop type, including null values.</source>
          <target state="translated">null 값을 포함하여 지정된 interop 유형에 대한 기본 포인터의 유형 캐스트를 수행합니다.</target>
        </trans-unit>
        <trans-unit id="70b3460333090074f460006fbc3c29cbd8b8ed4c" translate="yes" xml:space="preserve">
          <source>Permits whitespace and comments in pattern.</source>
          <target state="translated">공백과 주석을 패턴으로 허용합니다.</target>
        </trans-unit>
        <trans-unit id="af78c38398b139be2b3b2642ea9cb205e18abd10" translate="yes" xml:space="preserve">
          <source>Persistent context for the coroutine. It is an indexed set of &lt;a href=&quot;-coroutine-context/-element/index&quot;&gt;Element&lt;/a&gt; instances. An indexed set is a mix between a set and a map. Every element in this set has a unique &lt;a href=&quot;-coroutine-context/-key&quot;&gt;Key&lt;/a&gt;.</source>
          <target state="translated">코 루틴에 대한 지속적인 컨텍스트. 인덱스 된 &lt;a href=&quot;-coroutine-context/-element/index&quot;&gt;요소&lt;/a&gt; 인스턴스 세트입니다 . 인덱싱 된 집합은 집합과지도를 혼합 한 것입니다. 이 세트의 모든 요소에는 고유 한 &lt;a href=&quot;-coroutine-context/-key&quot;&gt;Key가&lt;/a&gt; 있습니다.</target>
        </trans-unit>
        <trans-unit id="c157c340f43a865245c7fc93858e3d651e03db02" translate="yes" xml:space="preserve">
          <source>Persistent context for the coroutine. It is an indexed set of &lt;a href=&quot;-coroutine-context/-element/index&quot;&gt;Element&lt;/a&gt; instances. An indexed set is a mix between a set and a map. Every element in this set has a unique &lt;a href=&quot;-coroutine-context/-key&quot;&gt;Key&lt;/a&gt;. Keys are compared &lt;em&gt;by reference&lt;/em&gt;.</source>
          <target state="translated">코 루틴에 대한 지속적인 컨텍스트. 인덱스 된 &lt;a href=&quot;-coroutine-context/-element/index&quot;&gt;요소&lt;/a&gt; 인스턴스 세트입니다 . 인덱싱 된 집합은 집합과지도를 혼합 한 것입니다. 이 세트의 모든 요소에는 고유 한 &lt;a href=&quot;-coroutine-context/-key&quot;&gt;Key가&lt;/a&gt; 있습니다. 키는 &lt;em&gt;참조&lt;/em&gt; 로 비교 &lt;em&gt;됩니다&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="b967bafef068480743eba427623473373d559d2d" translate="yes" xml:space="preserve">
          <source>Persistent context for the coroutine. It is an indexed set of &lt;a href=&quot;-element/index&quot;&gt;Element&lt;/a&gt; instances. An indexed set is a mix between a set and a map. Every element in this set has a unique &lt;a href=&quot;-key&quot;&gt;Key&lt;/a&gt;.</source>
          <target state="translated">코 루틴에 대한 지속적인 컨텍스트. 인덱스 된 &lt;a href=&quot;-element/index&quot;&gt;요소&lt;/a&gt; 인스턴스 세트입니다 . 인덱싱 된 집합은 집합과지도를 혼합 한 것입니다. 이 세트의 모든 요소에는 고유 한 &lt;a href=&quot;-key&quot;&gt;Key가&lt;/a&gt; 있습니다.</target>
        </trans-unit>
        <trans-unit id="c764f72e9b533c3e92099663bd3155a39c117cff" translate="yes" xml:space="preserve">
          <source>Persistent context for the coroutine. It is an indexed set of &lt;a href=&quot;-element/index&quot;&gt;Element&lt;/a&gt; instances. An indexed set is a mix between a set and a map. Every element in this set has a unique &lt;a href=&quot;-key&quot;&gt;Key&lt;/a&gt;. Keys are compared &lt;em&gt;by reference&lt;/em&gt;.</source>
          <target state="translated">코 루틴에 대한 지속적인 컨텍스트. 인덱스 된 &lt;a href=&quot;-element/index&quot;&gt;요소&lt;/a&gt; 인스턴스 세트입니다 . 인덱싱 된 집합은 집합과지도를 혼합 한 것입니다. 이 세트의 모든 요소에는 고유 한 &lt;a href=&quot;-key&quot;&gt;Key가&lt;/a&gt; 있습니다. 키는 &lt;em&gt;참조&lt;/em&gt; 로 비교 &lt;em&gt;됩니다&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="95451dcb8e009499e098e6e7a96b268f1fac141a" translate="yes" xml:space="preserve">
          <source>Persistent context for the coroutine. It is an indexed set of &lt;a href=&quot;../../kotlin.coroutines.experimental/-coroutine-context/-element/index&quot;&gt;Element&lt;/a&gt; instances. An indexed set is a mix between a set and a map. Every element in this set has a unique &lt;a href=&quot;../../kotlin.coroutines.experimental/-coroutine-context/-key&quot;&gt;Key&lt;/a&gt;. Keys are compared &lt;em&gt;by reference&lt;/em&gt;.</source>
          <target state="translated">코 루틴에 대한 지속적인 컨텍스트. 인덱스 된 &lt;a href=&quot;../../kotlin.coroutines.experimental/-coroutine-context/-element/index&quot;&gt;요소&lt;/a&gt; 인스턴스 세트입니다 . 인덱싱 된 집합은 집합과지도를 혼합 한 것입니다. 이 세트의 모든 요소에는 고유 한 &lt;a href=&quot;../../kotlin.coroutines.experimental/-coroutine-context/-key&quot;&gt;Key가&lt;/a&gt; 있습니다. 키는 &lt;em&gt;참조&lt;/em&gt; 로 비교 &lt;em&gt;됩니다&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="846500d1d4ad3ba3a25965623df48239e4855082" translate="yes" xml:space="preserve">
          <source>Persistent context for the coroutine. It is an indexed set of &lt;a href=&quot;../../kotlin.coroutines/-coroutine-context/-element/index&quot;&gt;Element&lt;/a&gt; instances. An indexed set is a mix between a set and a map. Every element in this set has a unique &lt;a href=&quot;../../kotlin.coroutines/-coroutine-context/-key&quot;&gt;Key&lt;/a&gt;.</source>
          <target state="translated">코 루틴에 대한 지속적인 컨텍스트. 인덱스 된 &lt;a href=&quot;../../kotlin.coroutines/-coroutine-context/-element/index&quot;&gt;요소&lt;/a&gt; 인스턴스 세트입니다 . 인덱싱 된 집합은 집합과지도를 혼합 한 것입니다. 이 세트의 모든 요소에는 고유 한 &lt;a href=&quot;../../kotlin.coroutines/-coroutine-context/-key&quot;&gt;Key가&lt;/a&gt; 있습니다.</target>
        </trans-unit>
        <trans-unit id="f9312169efb2796a0b1da9edb152b101f2300da1" translate="yes" xml:space="preserve">
          <source>Pinned</source>
          <target state="translated">Pinned</target>
        </trans-unit>
        <trans-unit id="0c0360a84d9cf873ea3ea1f65f0f811d87230d3d" translate="yes" xml:space="preserve">
          <source>Pinterest has successfully &lt;a href=&quot;https://www.youtube.com/watch?v=mDpnc45WwlI&quot;&gt;introduced Kotlin into their application&lt;/a&gt;, used by 150M people every month.</source>
          <target state="translated">Pinterest는 매월 1 억 5 천만 명의 사람들이 사용하는 &lt;a href=&quot;https://www.youtube.com/watch?v=mDpnc45WwlI&quot;&gt;Kotlin을 그들의 응용 프로그램에&lt;/a&gt; 성공적으로 도입 했습니다.</target>
        </trans-unit>
        <trans-unit id="c5df1e14fdba13b1a3f9690f736bcb2aac132e72" translate="yes" xml:space="preserve">
          <source>Pipelines</source>
          <target state="translated">Pipelines</target>
        </trans-unit>
        <trans-unit id="b2ee7fbd6f51756380013f5fd4950677fa0c81fb" translate="yes" xml:space="preserve">
          <source>Place all annotations before modifiers:</source>
          <target state="translated">수정 자 앞에 모든 주석을 배치하십시오.</target>
        </trans-unit>
        <trans-unit id="3982eb75527059bbd6d192e34d8368da66120228" translate="yes" xml:space="preserve">
          <source>Placing multiple declarations (classes, top-level functions or properties) in the same Kotlin source file is encouraged as long as these declarations are closely related to each other semantically and the file size remains reasonable (not exceeding a few hundred lines).</source>
          <target state="translated">동일한 Kotlin 소스 파일에 여러 선언 (클래스, 최상위 함수 또는 속성)을 배치하면 이러한 선언이 의미 적으로 서로 밀접하게 관련되어 있고 파일 크기가 합리적으로 유지되는 한 (수백 줄을 초과하지 않는 한) 권장됩니다.</target>
        </trans-unit>
        <trans-unit id="b62ff09be9581c8e92bedbae8f703577022a386d" translate="yes" xml:space="preserve">
          <source>Plain. Don't compile for any module system. As usual, you can access a module by its name in the global scope. This option is used by default.</source>
          <target state="translated">평원. 모듈 시스템을 위해 컴파일하지 마십시오. 평소와 같이 전역 범위에서 이름으로 모듈에 액세스 할 수 있습니다. 이 옵션은 기본적으로 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="afb64e7d9920cfa61ac4bcb4a97a95361d70c9d4" translate="yes" xml:space="preserve">
          <source>Plan job for further execution in the worker. Execute is a two-phase operation:</source>
          <target state="translated">작업자의 추가 실행을위한 작업을 계획하십시오. 실행은 2 단계 작업입니다.</target>
        </trans-unit>
        <trans-unit id="123a7f2fcc9ae7cbbbd7c7627a483853a9708dab" translate="yes" xml:space="preserve">
          <source>Platform</source>
          <target state="translated">Platform</target>
        </trans-unit>
        <trans-unit id="f5f2f02ee59dd5f7278fa52e9803b778e1810bf6" translate="yes" xml:space="preserve">
          <source>Platform libraries</source>
          <target state="translated">플랫폼 라이브러리</target>
        </trans-unit>
        <trans-unit id="27daeb6136375e35b7aae078a456f0409455061d" translate="yes" xml:space="preserve">
          <source>Platform types</source>
          <target state="translated">플랫폼 유형</target>
        </trans-unit>
        <trans-unit id="c86d5ba4c85d5fb0c76ddc4c4b75a80c8e2b5bf7" translate="yes" xml:space="preserve">
          <source>Platform types are &lt;em&gt;non-denotable&lt;/em&gt;, meaning that one can not write them down explicitly in the language. When a platform value is assigned to a Kotlin variable, we can rely on type inference (the variable will have an inferred platform type then, as &lt;code&gt;item&lt;/code&gt; has in the example above), or we can choose the type that we expect (both nullable and non-null types are allowed):</source>
          <target state="translated">플랫폼 유형은 &lt;em&gt;비 denotable&lt;/em&gt; 하나의 언어로 명시 적으로 아래로 쓸 수 있다는 것을 의미한다. 플랫폼 값이 Kotlin 변수에 할당되면 유형 유추에 의존 하거나 (위 예제의 &lt;code&gt;item&lt;/code&gt; 에서 와 같이 변수에 유추 된 플랫폼 유형 이 있음) 예상되는 유형을 선택할 수 있습니다 (널링 가능 및 널이 아닌 유형이 허용됨) :</target>
        </trans-unit>
        <trans-unit id="2de932b8a9245d1f54a9aad41804f55891736690" translate="yes" xml:space="preserve">
          <source>Platform-Specific Declarations</source>
          <target state="translated">플랫폼 별 선언</target>
        </trans-unit>
        <trans-unit id="5e25183c13ab998897981474ea6c1e9585cc156e" translate="yes" xml:space="preserve">
          <source>Platform-specific implementations</source>
          <target state="translated">플랫폼 별 구현</target>
        </trans-unit>
        <trans-unit id="a68eb230823a2defe94e6d3f9718ef2ec069c259" translate="yes" xml:space="preserve">
          <source>Playground</source>
          <target state="translated">Playground</target>
        </trans-unit>
        <trans-unit id="bbdb65085dee03f9522e3e5f0025eed4f5359814" translate="yes" xml:space="preserve">
          <source>Please note that kapt is still not supported for IntelliJ IDEA&amp;rsquo;s own build system. Launch the build from the &amp;ldquo;Maven Projects&amp;rdquo; toolbar whenever you want to re-run the annotation processing.</source>
          <target state="translated">kapt는 여전히 IntelliJ IDEA의 자체 빌드 시스템에서 지원되지 않습니다. 주석 처리를 다시 실행할 때마다&amp;ldquo;Maven Projects&amp;rdquo;도구 모음에서 빌드를 시작하십시오.</target>
        </trans-unit>
        <trans-unit id="a652f9a1cbf6bc63cb39a996bce3be974d2d22bc" translate="yes" xml:space="preserve">
          <source>Please note that not all target platforms have reached this level of stability (but Kotlin/JVM has).</source>
          <target state="translated">모든 대상 플랫폼이이 수준의 안정성에 도달 한 것은 아닙니다 (그러나 Kotlin / JVM은).</target>
        </trans-unit>
        <trans-unit id="47b2ec614eb50f3bdffe58d7ff2b3bc3913ac575" translate="yes" xml:space="preserve">
          <source>Please note, that scripting is an experimental feature, meaning that no compatibility guarantees on the API are given.</source>
          <target state="translated">스크립팅은 실험적인 기능이므로 API에 대한 호환성 보장이 제공되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="6aca781c3a79a3e72414af74477414b1309db482" translate="yes" xml:space="preserve">
          <source>Please read below about how to apply the &lt;em&gt;kapt&lt;/em&gt; plugin to your Gradle/Maven build.</source>
          <target state="translated">&lt;em&gt;kapt&lt;/em&gt; 플러그인을 Gradle / Maven 빌드 에 적용하는 방법에 대해서는 아래를 읽으 &lt;em&gt;십시오&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="df850d65431ff850dff9db645cfb9959b6fb5f52" translate="yes" xml:space="preserve">
          <source>Please refer to the &quot;Using in Gradle&quot; section above for the detailed information about how all-open annotations work.</source>
          <target state="translated">완전히 열린 주석의 작동 방식에 대한 자세한 내용은 위의 &quot;Gradle에서 사용&quot;섹션을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="d7f29bab7062ae491aa74823e07cdd75e6cd1ef2" translate="yes" xml:space="preserve">
          <source>Please see the section on exceptions in the &lt;a href=&quot;java-interop&quot;&gt;Java Interoperability section&lt;/a&gt; for information about Java interoperability.</source>
          <target state="translated">&lt;a href=&quot;java-interop&quot;&gt;Java 상호 운용성에&lt;/a&gt; 대한 정보는 Java 상호 운용성 섹션의 예외 섹션을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="8ccb2526b5c6a9379dd851edd6f41998ad27d981" translate="yes" xml:space="preserve">
          <source>Please, note, that even though kotlinx.serialization now ships with the Kotlin Compiler distribution, it is still considered to be an experimental feature.</source>
          <target state="translated">kotlinx.serialization이 이제 Kotlin Compiler 배포판과 함께 제공되지만 여전히 실험적인 기능으로 간주됩니다.</target>
        </trans-unit>
        <trans-unit id="8dc208f8ebe86aa9ee6a37d49d48058be5364bff" translate="yes" xml:space="preserve">
          <source>Plugin</source>
          <target state="translated">Plugin</target>
        </trans-unit>
        <trans-unit id="5579f3d6a54a5df8a540f8a3cba8e5401b9749b2" translate="yes" xml:space="preserve">
          <source>Plugin and Versions</source>
          <target state="translated">플러그인 및 버전</target>
        </trans-unit>
        <trans-unit id="60a1d5098c3c7592cf00aad9670f4365516e6abe" translate="yes" xml:space="preserve">
          <source>PluginArray</source>
          <target state="translated">PluginArray</target>
        </trans-unit>
        <trans-unit id="bc5de071a8adc9ea913c6f9e5f0005a2d40cc14d" translate="yes" xml:space="preserve">
          <source>Pointer</source>
          <target state="translated">Pointer</target>
        </trans-unit>
        <trans-unit id="d9fb370b0a40e2e2f19446936bcadb07206247ac" translate="yes" xml:space="preserve">
          <source>Pointer types</source>
          <target state="translated">포인터 타입</target>
        </trans-unit>
        <trans-unit id="7cf6219682a4407547b2c28d17b1d8dd2d5fdfa2" translate="yes" xml:space="preserve">
          <source>PointerEventInit</source>
          <target state="translated">PointerEventInit</target>
        </trans-unit>
        <trans-unit id="62d38aba74e2d8a777d33dbe646ae8fc7a0f65ff" translate="yes" xml:space="preserve">
          <source>Pointers and arrays are mapped to &lt;code&gt;CPointer&amp;lt;T&amp;gt;?&lt;/code&gt;.</source>
          <target state="translated">포인터와 배열이 &lt;code&gt;CPointer&amp;lt;T&amp;gt;?&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="989fc91d044783d05d714e433d3e90dca9bdf4da" translate="yes" xml:space="preserve">
          <source>Polymorphism</source>
          <target state="translated">Polymorphism</target>
        </trans-unit>
        <trans-unit id="2ad1ac7a525966a8b45094077f33bbdc05886ea0" translate="yes" xml:space="preserve">
          <source>Polymorphism is the ability to treat objects with similar traits in a common way. In Python, this is achieved via &lt;em&gt;ducktyping&lt;/em&gt;: if &lt;code&gt;x&lt;/code&gt; refers to some object, you can call &lt;code&gt;x.quack()&lt;/code&gt; as long as the object happens to have the function &lt;code&gt;quack()&lt;/code&gt; - nothing else needs to be known (or rather, assumed) about the object. That's very flexible, but also risky: if &lt;code&gt;x&lt;/code&gt; is a parameter, every caller of your function must be aware that the object they pass to it must have &lt;code&gt;quack()&lt;/code&gt;, and if someone gets it wrong, the program blows up at runtime.</source>
          <target state="translated">다형성은 비슷한 특성을 가진 물체를 일반적인 방식으로 처리하는 능력입니다. 파이썬에서 이것은 &lt;em&gt;ducktyping&lt;/em&gt; 을 통해 달성됩니다 : &lt;code&gt;x&lt;/code&gt; 가 일부 객체를 참조 하면 객체가 &lt;code&gt;quack()&lt;/code&gt; 함수를 갖는 한 &lt;code&gt;x.quack()&lt;/code&gt; 을 호출 할 수 있습니다 -다른 것을 알 필요가 없습니다 (또는 가정) 개체에 대해. 그것은 매우 유연하지만 위험합니다. &lt;code&gt;x&lt;/code&gt; 가 매개 변수 인 경우 함수의 모든 호출자는 전달하는 객체에 &lt;code&gt;quack()&lt;/code&gt; 가 있어야 하고 누군가가 잘못하면 런타임에 프로그램이 종료 된다는 것을 알고 있어야 합니다.</target>
        </trans-unit>
        <trans-unit id="287d62a455423043d5956c1c3dc80d61f37fed02" translate="yes" xml:space="preserve">
          <source>Pop quiz: if &lt;code&gt;Apple&lt;/code&gt; is a subtype of &lt;code&gt;Fruit&lt;/code&gt;, and &lt;code&gt;Bowl&lt;/code&gt; is a generic container class, is &lt;code&gt;Bowl&amp;lt;Apple&amp;gt;&lt;/code&gt; a subtype of &lt;code&gt;Bowl&amp;lt;Fruit&amp;gt;&lt;/code&gt;? The answer is - perhaps surprisingly - &lt;em&gt;no&lt;/em&gt;. The reason is that if it were a subtype, we would be able to break the type system like this:</source>
          <target state="translated">팝 퀴즈 : &lt;code&gt;Apple&lt;/code&gt; 이 &lt;code&gt;Fruit&lt;/code&gt; 의 하위 유형 이고 &lt;code&gt;Bowl&lt;/code&gt; 이 일반 컨테이너 클래스 인 경우 &lt;code&gt;Bowl&amp;lt;Apple&amp;gt;&lt;/code&gt; 은 &lt;code&gt;Bowl&amp;lt;Fruit&amp;gt;&lt;/code&gt; 의 하위 유형 입니까? 대답은 놀랍게도 &lt;em&gt;아닙니다&lt;/em&gt; . 그 이유는 그것이 하위 유형이라면 다음과 같이 유형 시스템을 깰 수 있기 때문입니다.</target>
        </trans-unit>
        <trans-unit id="a76679a620591482e0464dddad4f14c8c7fd9339" translate="yes" xml:space="preserve">
          <source>PopStateEventInit</source>
          <target state="translated">PopStateEventInit</target>
        </trans-unit>
        <trans-unit id="04a8da25b5f1b7ae8b0f0e1a4c823bc62e314fee" translate="yes" xml:space="preserve">
          <source>Popular native libraries</source>
          <target state="translated">인기있는 네이티브 라이브러리</target>
        </trans-unit>
        <trans-unit id="f06a7327f16a4e64c4c9f5157a5438dac01e49c3" translate="yes" xml:space="preserve">
          <source>Populates and returns the &lt;a href=&quot;../../kotlin.collections/associate-by-to#kotlin.collections%24associateByTo%28kotlin.Array%28%28kotlin.collections.associateByTo.T%29%29%2C+kotlin.collections.associateByTo.M%2C+kotlin.Function1%28%28kotlin.collections.associateByTo.T%2C+kotlin.collections.associateByTo.K%29%29%29%2Fdestination&quot;&gt;destination&lt;/a&gt; mutable map with key-value pairs, where key is provided by the &lt;a href=&quot;../../kotlin.collections/associate-by-to#kotlin.collections%24associateByTo%28kotlin.Array%28%28kotlin.collections.associateByTo.T%29%29%2C+kotlin.collections.associateByTo.M%2C+kotlin.Function1%28%28kotlin.collections.associateByTo.T%2C+kotlin.collections.associateByTo.K%29%29%29%2FkeySelector&quot;&gt;keySelector&lt;/a&gt; function applied to each element of the given array and value is the element itself.</source>
          <target state="translated">키-값 쌍을 사용 하여 &lt;a href=&quot;../../kotlin.collections/associate-by-to#kotlin.collections%24associateByTo%28kotlin.Array%28%28kotlin.collections.associateByTo.T%29%29%2C+kotlin.collections.associateByTo.M%2C+kotlin.Function1%28%28kotlin.collections.associateByTo.T%2C+kotlin.collections.associateByTo.K%29%29%29%2Fdestination&quot;&gt;대상&lt;/a&gt; 변경 가능 맵을 채우고 리턴합니다 . 여기서 키는 주어진 배열의 각 요소에 적용된 &lt;a href=&quot;../../kotlin.collections/associate-by-to#kotlin.collections%24associateByTo%28kotlin.Array%28%28kotlin.collections.associateByTo.T%29%29%2C+kotlin.collections.associateByTo.M%2C+kotlin.Function1%28%28kotlin.collections.associateByTo.T%2C+kotlin.collections.associateByTo.K%29%29%29%2FkeySelector&quot;&gt;keySelector&lt;/a&gt; 함수에 의해 제공되며 value는 요소 자체입니다.</target>
        </trans-unit>
        <trans-unit id="cc815fb8f30b9d67defc8672639f11b7cd964deb" translate="yes" xml:space="preserve">
          <source>Populates and returns the &lt;a href=&quot;../../kotlin.collections/associate-by-to#kotlin.collections%24associateByTo%28kotlin.Array%28%28kotlin.collections.associateByTo.T%29%29%2C+kotlin.collections.associateByTo.M%2C+kotlin.Function1%28%28kotlin.collections.associateByTo.T%2C+kotlin.collections.associateByTo.K%29%29%2C+kotlin.Function1%28%28kotlin.collections.associateByTo.T%2C+kotlin.collections.associateByTo.V%29%29%29%2Fdestination&quot;&gt;destination&lt;/a&gt; mutable map with key-value pairs, where key is provided by the &lt;a href=&quot;../../kotlin.collections/associate-by-to#kotlin.collections%24associateByTo%28kotlin.Array%28%28kotlin.collections.associateByTo.T%29%29%2C+kotlin.collections.associateByTo.M%2C+kotlin.Function1%28%28kotlin.collections.associateByTo.T%2C+kotlin.collections.associateByTo.K%29%29%2C+kotlin.Function1%28%28kotlin.collections.associateByTo.T%2C+kotlin.collections.associateByTo.V%29%29%29%2FkeySelector&quot;&gt;keySelector&lt;/a&gt; function and and value is provided by the &lt;a href=&quot;../../kotlin.collections/associate-by-to#kotlin.collections%24associateByTo%28kotlin.Array%28%28kotlin.collections.associateByTo.T%29%29%2C+kotlin.collections.associateByTo.M%2C+kotlin.Function1%28%28kotlin.collections.associateByTo.T%2C+kotlin.collections.associateByTo.K%29%29%2C+kotlin.Function1%28%28kotlin.collections.associateByTo.T%2C+kotlin.collections.associateByTo.V%29%29%29%2FvalueTransform&quot;&gt;valueTransform&lt;/a&gt; function applied to elements of the given array.</source>
          <target state="translated">채우고 되돌 &lt;a href=&quot;../../kotlin.collections/associate-by-to#kotlin.collections%24associateByTo%28kotlin.Array%28%28kotlin.collections.associateByTo.T%29%29%2C+kotlin.collections.associateByTo.M%2C+kotlin.Function1%28%28kotlin.collections.associateByTo.T%2C+kotlin.collections.associateByTo.K%29%29%2C+kotlin.Function1%28%28kotlin.collections.associateByTo.T%2C+kotlin.collections.associateByTo.V%29%29%29%2Fdestination&quot;&gt;대상&lt;/a&gt; 키에 의해 제공되는 키 - 값 쌍으로 변경할지도 &lt;a href=&quot;../../kotlin.collections/associate-by-to#kotlin.collections%24associateByTo%28kotlin.Array%28%28kotlin.collections.associateByTo.T%29%29%2C+kotlin.collections.associateByTo.M%2C+kotlin.Function1%28%28kotlin.collections.associateByTo.T%2C+kotlin.collections.associateByTo.K%29%29%2C+kotlin.Function1%28%28kotlin.collections.associateByTo.T%2C+kotlin.collections.associateByTo.V%29%29%29%2FkeySelector&quot;&gt;KeySelector에의&lt;/a&gt; 기능 및 값에 의해 제공된다 &lt;a href=&quot;../../kotlin.collections/associate-by-to#kotlin.collections%24associateByTo%28kotlin.Array%28%28kotlin.collections.associateByTo.T%29%29%2C+kotlin.collections.associateByTo.M%2C+kotlin.Function1%28%28kotlin.collections.associateByTo.T%2C+kotlin.collections.associateByTo.K%29%29%2C+kotlin.Function1%28%28kotlin.collections.associateByTo.T%2C+kotlin.collections.associateByTo.V%29%29%29%2FvalueTransform&quot;&gt;valueTransform의&lt;/a&gt; 함수는 주어진 배열의 요소에 적용 하였다.</target>
        </trans-unit>
        <trans-unit id="e54027fe3b0c04647bd612e2d3001a28dfddab19" translate="yes" xml:space="preserve">
          <source>Populates and returns the &lt;a href=&quot;../../kotlin.collections/associate-by-to#kotlin.collections%24associateByTo%28kotlin.BooleanArray%2C+kotlin.collections.associateByTo.M%2C+kotlin.Function1%28%28kotlin.Boolean%2C+kotlin.collections.associateByTo.K%29%29%29%2Fdestination&quot;&gt;destination&lt;/a&gt; mutable map with key-value pairs, where key is provided by the &lt;a href=&quot;../../kotlin.collections/associate-by-to#kotlin.collections%24associateByTo%28kotlin.BooleanArray%2C+kotlin.collections.associateByTo.M%2C+kotlin.Function1%28%28kotlin.Boolean%2C+kotlin.collections.associateByTo.K%29%29%29%2FkeySelector&quot;&gt;keySelector&lt;/a&gt; function applied to each element of the given array and value is the element itself.</source>
          <target state="translated">키-값 쌍을 사용 하여 &lt;a href=&quot;../../kotlin.collections/associate-by-to#kotlin.collections%24associateByTo%28kotlin.BooleanArray%2C+kotlin.collections.associateByTo.M%2C+kotlin.Function1%28%28kotlin.Boolean%2C+kotlin.collections.associateByTo.K%29%29%29%2Fdestination&quot;&gt;대상&lt;/a&gt; 변경 가능 맵을 채우고 리턴합니다 . 여기서 키는 주어진 배열의 각 요소에 적용된 &lt;a href=&quot;../../kotlin.collections/associate-by-to#kotlin.collections%24associateByTo%28kotlin.BooleanArray%2C+kotlin.collections.associateByTo.M%2C+kotlin.Function1%28%28kotlin.Boolean%2C+kotlin.collections.associateByTo.K%29%29%29%2FkeySelector&quot;&gt;keySelector&lt;/a&gt; 함수에 의해 제공되며 value는 요소 자체입니다.</target>
        </trans-unit>
        <trans-unit id="8c294042ba1c08bbdf5f2ca919aef74b3ad73e01" translate="yes" xml:space="preserve">
          <source>Populates and returns the &lt;a href=&quot;../../kotlin.collections/associate-by-to#kotlin.collections%24associateByTo%28kotlin.BooleanArray%2C+kotlin.collections.associateByTo.M%2C+kotlin.Function1%28%28kotlin.Boolean%2C+kotlin.collections.associateByTo.K%29%29%2C+kotlin.Function1%28%28kotlin.Boolean%2C+kotlin.collections.associateByTo.V%29%29%29%2Fdestination&quot;&gt;destination&lt;/a&gt; mutable map with key-value pairs, where key is provided by the &lt;a href=&quot;../../kotlin.collections/associate-by-to#kotlin.collections%24associateByTo%28kotlin.BooleanArray%2C+kotlin.collections.associateByTo.M%2C+kotlin.Function1%28%28kotlin.Boolean%2C+kotlin.collections.associateByTo.K%29%29%2C+kotlin.Function1%28%28kotlin.Boolean%2C+kotlin.collections.associateByTo.V%29%29%29%2FkeySelector&quot;&gt;keySelector&lt;/a&gt; function and and value is provided by the &lt;a href=&quot;../../kotlin.collections/associate-by-to#kotlin.collections%24associateByTo%28kotlin.BooleanArray%2C+kotlin.collections.associateByTo.M%2C+kotlin.Function1%28%28kotlin.Boolean%2C+kotlin.collections.associateByTo.K%29%29%2C+kotlin.Function1%28%28kotlin.Boolean%2C+kotlin.collections.associateByTo.V%29%29%29%2FvalueTransform&quot;&gt;valueTransform&lt;/a&gt; function applied to elements of the given array.</source>
          <target state="translated">채우고 되돌 &lt;a href=&quot;../../kotlin.collections/associate-by-to#kotlin.collections%24associateByTo%28kotlin.BooleanArray%2C+kotlin.collections.associateByTo.M%2C+kotlin.Function1%28%28kotlin.Boolean%2C+kotlin.collections.associateByTo.K%29%29%2C+kotlin.Function1%28%28kotlin.Boolean%2C+kotlin.collections.associateByTo.V%29%29%29%2Fdestination&quot;&gt;대상&lt;/a&gt; 키에 의해 제공되는 키 - 값 쌍으로 변경할지도 &lt;a href=&quot;../../kotlin.collections/associate-by-to#kotlin.collections%24associateByTo%28kotlin.BooleanArray%2C+kotlin.collections.associateByTo.M%2C+kotlin.Function1%28%28kotlin.Boolean%2C+kotlin.collections.associateByTo.K%29%29%2C+kotlin.Function1%28%28kotlin.Boolean%2C+kotlin.collections.associateByTo.V%29%29%29%2FkeySelector&quot;&gt;KeySelector에의&lt;/a&gt; 기능 및 값에 의해 제공된다 &lt;a href=&quot;../../kotlin.collections/associate-by-to#kotlin.collections%24associateByTo%28kotlin.BooleanArray%2C+kotlin.collections.associateByTo.M%2C+kotlin.Function1%28%28kotlin.Boolean%2C+kotlin.collections.associateByTo.K%29%29%2C+kotlin.Function1%28%28kotlin.Boolean%2C+kotlin.collections.associateByTo.V%29%29%29%2FvalueTransform&quot;&gt;valueTransform의&lt;/a&gt; 함수는 주어진 배열의 요소에 적용 하였다.</target>
        </trans-unit>
        <trans-unit id="628dc0da6494de25d6ba457f2f80c91e78b5b864" translate="yes" xml:space="preserve">
          <source>Populates and returns the &lt;a href=&quot;../../kotlin.collections/associate-by-to#kotlin.collections%24associateByTo%28kotlin.ByteArray%2C+kotlin.collections.associateByTo.M%2C+kotlin.Function1%28%28kotlin.Byte%2C+kotlin.collections.associateByTo.K%29%29%29%2Fdestination&quot;&gt;destination&lt;/a&gt; mutable map with key-value pairs, where key is provided by the &lt;a href=&quot;../../kotlin.collections/associate-by-to#kotlin.collections%24associateByTo%28kotlin.ByteArray%2C+kotlin.collections.associateByTo.M%2C+kotlin.Function1%28%28kotlin.Byte%2C+kotlin.collections.associateByTo.K%29%29%29%2FkeySelector&quot;&gt;keySelector&lt;/a&gt; function applied to each element of the given array and value is the element itself.</source>
          <target state="translated">키-값 쌍을 사용 하여 &lt;a href=&quot;../../kotlin.collections/associate-by-to#kotlin.collections%24associateByTo%28kotlin.ByteArray%2C+kotlin.collections.associateByTo.M%2C+kotlin.Function1%28%28kotlin.Byte%2C+kotlin.collections.associateByTo.K%29%29%29%2Fdestination&quot;&gt;대상&lt;/a&gt; 변경 가능 맵을 채우고 리턴합니다 . 여기서 키는 주어진 배열의 각 요소에 적용된 &lt;a href=&quot;../../kotlin.collections/associate-by-to#kotlin.collections%24associateByTo%28kotlin.ByteArray%2C+kotlin.collections.associateByTo.M%2C+kotlin.Function1%28%28kotlin.Byte%2C+kotlin.collections.associateByTo.K%29%29%29%2FkeySelector&quot;&gt;keySelector&lt;/a&gt; 함수에 의해 제공되며 value는 요소 자체입니다.</target>
        </trans-unit>
        <trans-unit id="8cd2dcf8a0a402b667ea907412305ccf1cbf6066" translate="yes" xml:space="preserve">
          <source>Populates and returns the &lt;a href=&quot;../../kotlin.collections/associate-by-to#kotlin.collections%24associateByTo%28kotlin.ByteArray%2C+kotlin.collections.associateByTo.M%2C+kotlin.Function1%28%28kotlin.Byte%2C+kotlin.collections.associateByTo.K%29%29%2C+kotlin.Function1%28%28kotlin.Byte%2C+kotlin.collections.associateByTo.V%29%29%29%2Fdestination&quot;&gt;destination&lt;/a&gt; mutable map with key-value pairs, where key is provided by the &lt;a href=&quot;../../kotlin.collections/associate-by-to#kotlin.collections%24associateByTo%28kotlin.ByteArray%2C+kotlin.collections.associateByTo.M%2C+kotlin.Function1%28%28kotlin.Byte%2C+kotlin.collections.associateByTo.K%29%29%2C+kotlin.Function1%28%28kotlin.Byte%2C+kotlin.collections.associateByTo.V%29%29%29%2FkeySelector&quot;&gt;keySelector&lt;/a&gt; function and and value is provided by the &lt;a href=&quot;../../kotlin.collections/associate-by-to#kotlin.collections%24associateByTo%28kotlin.ByteArray%2C+kotlin.collections.associateByTo.M%2C+kotlin.Function1%28%28kotlin.Byte%2C+kotlin.collections.associateByTo.K%29%29%2C+kotlin.Function1%28%28kotlin.Byte%2C+kotlin.collections.associateByTo.V%29%29%29%2FvalueTransform&quot;&gt;valueTransform&lt;/a&gt; function applied to elements of the given array.</source>
          <target state="translated">채우고 되돌 &lt;a href=&quot;../../kotlin.collections/associate-by-to#kotlin.collections%24associateByTo%28kotlin.ByteArray%2C+kotlin.collections.associateByTo.M%2C+kotlin.Function1%28%28kotlin.Byte%2C+kotlin.collections.associateByTo.K%29%29%2C+kotlin.Function1%28%28kotlin.Byte%2C+kotlin.collections.associateByTo.V%29%29%29%2Fdestination&quot;&gt;대상&lt;/a&gt; 키에 의해 제공되는 키 - 값 쌍으로 변경할지도 &lt;a href=&quot;../../kotlin.collections/associate-by-to#kotlin.collections%24associateByTo%28kotlin.ByteArray%2C+kotlin.collections.associateByTo.M%2C+kotlin.Function1%28%28kotlin.Byte%2C+kotlin.collections.associateByTo.K%29%29%2C+kotlin.Function1%28%28kotlin.Byte%2C+kotlin.collections.associateByTo.V%29%29%29%2FkeySelector&quot;&gt;KeySelector에의&lt;/a&gt; 기능 및 값에 의해 제공된다 &lt;a href=&quot;../../kotlin.collections/associate-by-to#kotlin.collections%24associateByTo%28kotlin.ByteArray%2C+kotlin.collections.associateByTo.M%2C+kotlin.Function1%28%28kotlin.Byte%2C+kotlin.collections.associateByTo.K%29%29%2C+kotlin.Function1%28%28kotlin.Byte%2C+kotlin.collections.associateByTo.V%29%29%29%2FvalueTransform&quot;&gt;valueTransform의&lt;/a&gt; 함수는 주어진 배열의 요소에 적용 하였다.</target>
        </trans-unit>
        <trans-unit id="f23a8e6acd4ac41b4190d6db10e68e05825c24e2" translate="yes" xml:space="preserve">
          <source>Populates and returns the &lt;a href=&quot;../../kotlin.collections/associate-by-to#kotlin.collections%24associateByTo%28kotlin.CharArray%2C+kotlin.collections.associateByTo.M%2C+kotlin.Function1%28%28kotlin.Char%2C+kotlin.collections.associateByTo.K%29%29%29%2Fdestination&quot;&gt;destination&lt;/a&gt; mutable map with key-value pairs, where key is provided by the &lt;a href=&quot;../../kotlin.collections/associate-by-to#kotlin.collections%24associateByTo%28kotlin.CharArray%2C+kotlin.collections.associateByTo.M%2C+kotlin.Function1%28%28kotlin.Char%2C+kotlin.collections.associateByTo.K%29%29%29%2FkeySelector&quot;&gt;keySelector&lt;/a&gt; function applied to each element of the given array and value is the element itself.</source>
          <target state="translated">키-값 쌍을 사용 하여 &lt;a href=&quot;../../kotlin.collections/associate-by-to#kotlin.collections%24associateByTo%28kotlin.CharArray%2C+kotlin.collections.associateByTo.M%2C+kotlin.Function1%28%28kotlin.Char%2C+kotlin.collections.associateByTo.K%29%29%29%2Fdestination&quot;&gt;대상&lt;/a&gt; 변경 가능 맵을 채우고 리턴합니다 . 여기서 키는 주어진 배열의 각 요소에 적용된 &lt;a href=&quot;../../kotlin.collections/associate-by-to#kotlin.collections%24associateByTo%28kotlin.CharArray%2C+kotlin.collections.associateByTo.M%2C+kotlin.Function1%28%28kotlin.Char%2C+kotlin.collections.associateByTo.K%29%29%29%2FkeySelector&quot;&gt;keySelector&lt;/a&gt; 함수에 의해 제공되며 value는 요소 자체입니다.</target>
        </trans-unit>
        <trans-unit id="b8bf455ab69f63a4c886ade4aaa383957ceadbbb" translate="yes" xml:space="preserve">
          <source>Populates and returns the &lt;a href=&quot;../../kotlin.collections/associate-by-to#kotlin.collections%24associateByTo%28kotlin.CharArray%2C+kotlin.collections.associateByTo.M%2C+kotlin.Function1%28%28kotlin.Char%2C+kotlin.collections.associateByTo.K%29%29%2C+kotlin.Function1%28%28kotlin.Char%2C+kotlin.collections.associateByTo.V%29%29%29%2Fdestination&quot;&gt;destination&lt;/a&gt; mutable map with key-value pairs, where key is provided by the &lt;a href=&quot;../../kotlin.collections/associate-by-to#kotlin.collections%24associateByTo%28kotlin.CharArray%2C+kotlin.collections.associateByTo.M%2C+kotlin.Function1%28%28kotlin.Char%2C+kotlin.collections.associateByTo.K%29%29%2C+kotlin.Function1%28%28kotlin.Char%2C+kotlin.collections.associateByTo.V%29%29%29%2FkeySelector&quot;&gt;keySelector&lt;/a&gt; function and and value is provided by the &lt;a href=&quot;../../kotlin.collections/associate-by-to#kotlin.collections%24associateByTo%28kotlin.CharArray%2C+kotlin.collections.associateByTo.M%2C+kotlin.Function1%28%28kotlin.Char%2C+kotlin.collections.associateByTo.K%29%29%2C+kotlin.Function1%28%28kotlin.Char%2C+kotlin.collections.associateByTo.V%29%29%29%2FvalueTransform&quot;&gt;valueTransform&lt;/a&gt; function applied to elements of the given array.</source>
          <target state="translated">채우고 되돌 &lt;a href=&quot;../../kotlin.collections/associate-by-to#kotlin.collections%24associateByTo%28kotlin.CharArray%2C+kotlin.collections.associateByTo.M%2C+kotlin.Function1%28%28kotlin.Char%2C+kotlin.collections.associateByTo.K%29%29%2C+kotlin.Function1%28%28kotlin.Char%2C+kotlin.collections.associateByTo.V%29%29%29%2Fdestination&quot;&gt;대상&lt;/a&gt; 키에 의해 제공되는 키 - 값 쌍으로 변경할지도 &lt;a href=&quot;../../kotlin.collections/associate-by-to#kotlin.collections%24associateByTo%28kotlin.CharArray%2C+kotlin.collections.associateByTo.M%2C+kotlin.Function1%28%28kotlin.Char%2C+kotlin.collections.associateByTo.K%29%29%2C+kotlin.Function1%28%28kotlin.Char%2C+kotlin.collections.associateByTo.V%29%29%29%2FkeySelector&quot;&gt;KeySelector에의&lt;/a&gt; 기능 및 값에 의해 제공된다 &lt;a href=&quot;../../kotlin.collections/associate-by-to#kotlin.collections%24associateByTo%28kotlin.CharArray%2C+kotlin.collections.associateByTo.M%2C+kotlin.Function1%28%28kotlin.Char%2C+kotlin.collections.associateByTo.K%29%29%2C+kotlin.Function1%28%28kotlin.Char%2C+kotlin.collections.associateByTo.V%29%29%29%2FvalueTransform&quot;&gt;valueTransform의&lt;/a&gt; 함수는 주어진 배열의 요소에 적용 하였다.</target>
        </trans-unit>
        <trans-unit id="835ba668c69cdc57c88721d2e320413b3efebdf5" translate="yes" xml:space="preserve">
          <source>Populates and returns the &lt;a href=&quot;../../kotlin.collections/associate-by-to#kotlin.collections%24associateByTo%28kotlin.DoubleArray%2C+kotlin.collections.associateByTo.M%2C+kotlin.Function1%28%28kotlin.Double%2C+kotlin.collections.associateByTo.K%29%29%29%2Fdestination&quot;&gt;destination&lt;/a&gt; mutable map with key-value pairs, where key is provided by the &lt;a href=&quot;../../kotlin.collections/associate-by-to#kotlin.collections%24associateByTo%28kotlin.DoubleArray%2C+kotlin.collections.associateByTo.M%2C+kotlin.Function1%28%28kotlin.Double%2C+kotlin.collections.associateByTo.K%29%29%29%2FkeySelector&quot;&gt;keySelector&lt;/a&gt; function applied to each element of the given array and value is the element itself.</source>
          <target state="translated">키-값 쌍을 사용 하여 &lt;a href=&quot;../../kotlin.collections/associate-by-to#kotlin.collections%24associateByTo%28kotlin.DoubleArray%2C+kotlin.collections.associateByTo.M%2C+kotlin.Function1%28%28kotlin.Double%2C+kotlin.collections.associateByTo.K%29%29%29%2Fdestination&quot;&gt;대상&lt;/a&gt; 변경 가능 맵을 채우고 리턴합니다 . 여기서 키는 주어진 배열의 각 요소에 적용된 &lt;a href=&quot;../../kotlin.collections/associate-by-to#kotlin.collections%24associateByTo%28kotlin.DoubleArray%2C+kotlin.collections.associateByTo.M%2C+kotlin.Function1%28%28kotlin.Double%2C+kotlin.collections.associateByTo.K%29%29%29%2FkeySelector&quot;&gt;keySelector&lt;/a&gt; 함수에 의해 제공되며 value는 요소 자체입니다.</target>
        </trans-unit>
        <trans-unit id="c2f2bfb6d6c1fee4d8e3438233d80e7a7a05d1bc" translate="yes" xml:space="preserve">
          <source>Populates and returns the &lt;a href=&quot;../../kotlin.collections/associate-by-to#kotlin.collections%24associateByTo%28kotlin.DoubleArray%2C+kotlin.collections.associateByTo.M%2C+kotlin.Function1%28%28kotlin.Double%2C+kotlin.collections.associateByTo.K%29%29%2C+kotlin.Function1%28%28kotlin.Double%2C+kotlin.collections.associateByTo.V%29%29%29%2Fdestination&quot;&gt;destination&lt;/a&gt; mutable map with key-value pairs, where key is provided by the &lt;a href=&quot;../../kotlin.collections/associate-by-to#kotlin.collections%24associateByTo%28kotlin.DoubleArray%2C+kotlin.collections.associateByTo.M%2C+kotlin.Function1%28%28kotlin.Double%2C+kotlin.collections.associateByTo.K%29%29%2C+kotlin.Function1%28%28kotlin.Double%2C+kotlin.collections.associateByTo.V%29%29%29%2FkeySelector&quot;&gt;keySelector&lt;/a&gt; function and and value is provided by the &lt;a href=&quot;../../kotlin.collections/associate-by-to#kotlin.collections%24associateByTo%28kotlin.DoubleArray%2C+kotlin.collections.associateByTo.M%2C+kotlin.Function1%28%28kotlin.Double%2C+kotlin.collections.associateByTo.K%29%29%2C+kotlin.Function1%28%28kotlin.Double%2C+kotlin.collections.associateByTo.V%29%29%29%2FvalueTransform&quot;&gt;valueTransform&lt;/a&gt; function applied to elements of the given array.</source>
          <target state="translated">채우고 되돌 &lt;a href=&quot;../../kotlin.collections/associate-by-to#kotlin.collections%24associateByTo%28kotlin.DoubleArray%2C+kotlin.collections.associateByTo.M%2C+kotlin.Function1%28%28kotlin.Double%2C+kotlin.collections.associateByTo.K%29%29%2C+kotlin.Function1%28%28kotlin.Double%2C+kotlin.collections.associateByTo.V%29%29%29%2Fdestination&quot;&gt;대상&lt;/a&gt; 키에 의해 제공되는 키 - 값 쌍으로 변경할지도 &lt;a href=&quot;../../kotlin.collections/associate-by-to#kotlin.collections%24associateByTo%28kotlin.DoubleArray%2C+kotlin.collections.associateByTo.M%2C+kotlin.Function1%28%28kotlin.Double%2C+kotlin.collections.associateByTo.K%29%29%2C+kotlin.Function1%28%28kotlin.Double%2C+kotlin.collections.associateByTo.V%29%29%29%2FkeySelector&quot;&gt;KeySelector에의&lt;/a&gt; 기능 및 값에 의해 제공된다 &lt;a href=&quot;../../kotlin.collections/associate-by-to#kotlin.collections%24associateByTo%28kotlin.DoubleArray%2C+kotlin.collections.associateByTo.M%2C+kotlin.Function1%28%28kotlin.Double%2C+kotlin.collections.associateByTo.K%29%29%2C+kotlin.Function1%28%28kotlin.Double%2C+kotlin.collections.associateByTo.V%29%29%29%2FvalueTransform&quot;&gt;valueTransform의&lt;/a&gt; 함수는 주어진 배열의 요소에 적용 하였다.</target>
        </trans-unit>
        <trans-unit id="965dd1a49d764dd96f8546692b284b466f37668d" translate="yes" xml:space="preserve">
          <source>Populates and returns the &lt;a href=&quot;../../kotlin.collections/associate-by-to#kotlin.collections%24associateByTo%28kotlin.FloatArray%2C+kotlin.collections.associateByTo.M%2C+kotlin.Function1%28%28kotlin.Float%2C+kotlin.collections.associateByTo.K%29%29%29%2Fdestination&quot;&gt;destination&lt;/a&gt; mutable map with key-value pairs, where key is provided by the &lt;a href=&quot;../../kotlin.collections/associate-by-to#kotlin.collections%24associateByTo%28kotlin.FloatArray%2C+kotlin.collections.associateByTo.M%2C+kotlin.Function1%28%28kotlin.Float%2C+kotlin.collections.associateByTo.K%29%29%29%2FkeySelector&quot;&gt;keySelector&lt;/a&gt; function applied to each element of the given array and value is the element itself.</source>
          <target state="translated">키-값 쌍을 사용 하여 &lt;a href=&quot;../../kotlin.collections/associate-by-to#kotlin.collections%24associateByTo%28kotlin.FloatArray%2C+kotlin.collections.associateByTo.M%2C+kotlin.Function1%28%28kotlin.Float%2C+kotlin.collections.associateByTo.K%29%29%29%2Fdestination&quot;&gt;대상&lt;/a&gt; 변경 가능 맵을 채우고 리턴합니다 . 여기서 키는 주어진 배열의 각 요소에 적용된 &lt;a href=&quot;../../kotlin.collections/associate-by-to#kotlin.collections%24associateByTo%28kotlin.FloatArray%2C+kotlin.collections.associateByTo.M%2C+kotlin.Function1%28%28kotlin.Float%2C+kotlin.collections.associateByTo.K%29%29%29%2FkeySelector&quot;&gt;keySelector&lt;/a&gt; 함수에 의해 제공되며 value는 요소 자체입니다.</target>
        </trans-unit>
        <trans-unit id="a24d7c2e18ecb007b00d96f3b5e8e1b1dfc4165e" translate="yes" xml:space="preserve">
          <source>Populates and returns the &lt;a href=&quot;../../kotlin.collections/associate-by-to#kotlin.collections%24associateByTo%28kotlin.FloatArray%2C+kotlin.collections.associateByTo.M%2C+kotlin.Function1%28%28kotlin.Float%2C+kotlin.collections.associateByTo.K%29%29%2C+kotlin.Function1%28%28kotlin.Float%2C+kotlin.collections.associateByTo.V%29%29%29%2Fdestination&quot;&gt;destination&lt;/a&gt; mutable map with key-value pairs, where key is provided by the &lt;a href=&quot;../../kotlin.collections/associate-by-to#kotlin.collections%24associateByTo%28kotlin.FloatArray%2C+kotlin.collections.associateByTo.M%2C+kotlin.Function1%28%28kotlin.Float%2C+kotlin.collections.associateByTo.K%29%29%2C+kotlin.Function1%28%28kotlin.Float%2C+kotlin.collections.associateByTo.V%29%29%29%2FkeySelector&quot;&gt;keySelector&lt;/a&gt; function and and value is provided by the &lt;a href=&quot;../../kotlin.collections/associate-by-to#kotlin.collections%24associateByTo%28kotlin.FloatArray%2C+kotlin.collections.associateByTo.M%2C+kotlin.Function1%28%28kotlin.Float%2C+kotlin.collections.associateByTo.K%29%29%2C+kotlin.Function1%28%28kotlin.Float%2C+kotlin.collections.associateByTo.V%29%29%29%2FvalueTransform&quot;&gt;valueTransform&lt;/a&gt; function applied to elements of the given array.</source>
          <target state="translated">채우고 되돌 &lt;a href=&quot;../../kotlin.collections/associate-by-to#kotlin.collections%24associateByTo%28kotlin.FloatArray%2C+kotlin.collections.associateByTo.M%2C+kotlin.Function1%28%28kotlin.Float%2C+kotlin.collections.associateByTo.K%29%29%2C+kotlin.Function1%28%28kotlin.Float%2C+kotlin.collections.associateByTo.V%29%29%29%2Fdestination&quot;&gt;대상&lt;/a&gt; 키에 의해 제공되는 키 - 값 쌍으로 변경할지도 &lt;a href=&quot;../../kotlin.collections/associate-by-to#kotlin.collections%24associateByTo%28kotlin.FloatArray%2C+kotlin.collections.associateByTo.M%2C+kotlin.Function1%28%28kotlin.Float%2C+kotlin.collections.associateByTo.K%29%29%2C+kotlin.Function1%28%28kotlin.Float%2C+kotlin.collections.associateByTo.V%29%29%29%2FkeySelector&quot;&gt;KeySelector에의&lt;/a&gt; 기능 및 값에 의해 제공된다 &lt;a href=&quot;../../kotlin.collections/associate-by-to#kotlin.collections%24associateByTo%28kotlin.FloatArray%2C+kotlin.collections.associateByTo.M%2C+kotlin.Function1%28%28kotlin.Float%2C+kotlin.collections.associateByTo.K%29%29%2C+kotlin.Function1%28%28kotlin.Float%2C+kotlin.collections.associateByTo.V%29%29%29%2FvalueTransform&quot;&gt;valueTransform의&lt;/a&gt; 함수는 주어진 배열의 요소에 적용 하였다.</target>
        </trans-unit>
        <trans-unit id="810e63afdaa4a01c8713ae8f7c4e623e24cde602" translate="yes" xml:space="preserve">
          <source>Populates and returns the &lt;a href=&quot;../../kotlin.collections/associate-by-to#kotlin.collections%24associateByTo%28kotlin.IntArray%2C+kotlin.collections.associateByTo.M%2C+kotlin.Function1%28%28kotlin.Int%2C+kotlin.collections.associateByTo.K%29%29%29%2Fdestination&quot;&gt;destination&lt;/a&gt; mutable map with key-value pairs, where key is provided by the &lt;a href=&quot;../../kotlin.collections/associate-by-to#kotlin.collections%24associateByTo%28kotlin.IntArray%2C+kotlin.collections.associateByTo.M%2C+kotlin.Function1%28%28kotlin.Int%2C+kotlin.collections.associateByTo.K%29%29%29%2FkeySelector&quot;&gt;keySelector&lt;/a&gt; function applied to each element of the given array and value is the element itself.</source>
          <target state="translated">키-값 쌍을 사용 하여 &lt;a href=&quot;../../kotlin.collections/associate-by-to#kotlin.collections%24associateByTo%28kotlin.IntArray%2C+kotlin.collections.associateByTo.M%2C+kotlin.Function1%28%28kotlin.Int%2C+kotlin.collections.associateByTo.K%29%29%29%2Fdestination&quot;&gt;대상&lt;/a&gt; 변경 가능 맵을 채우고 리턴합니다 . 여기서 키는 주어진 배열의 각 요소에 적용된 &lt;a href=&quot;../../kotlin.collections/associate-by-to#kotlin.collections%24associateByTo%28kotlin.IntArray%2C+kotlin.collections.associateByTo.M%2C+kotlin.Function1%28%28kotlin.Int%2C+kotlin.collections.associateByTo.K%29%29%29%2FkeySelector&quot;&gt;keySelector&lt;/a&gt; 함수에 의해 제공되며 value는 요소 자체입니다.</target>
        </trans-unit>
        <trans-unit id="35c88ac7832af61b09df102f495469d5c47c19bf" translate="yes" xml:space="preserve">
          <source>Populates and returns the &lt;a href=&quot;../../kotlin.collections/associate-by-to#kotlin.collections%24associateByTo%28kotlin.IntArray%2C+kotlin.collections.associateByTo.M%2C+kotlin.Function1%28%28kotlin.Int%2C+kotlin.collections.associateByTo.K%29%29%2C+kotlin.Function1%28%28kotlin.Int%2C+kotlin.collections.associateByTo.V%29%29%29%2Fdestination&quot;&gt;destination&lt;/a&gt; mutable map with key-value pairs, where key is provided by the &lt;a href=&quot;../../kotlin.collections/associate-by-to#kotlin.collections%24associateByTo%28kotlin.IntArray%2C+kotlin.collections.associateByTo.M%2C+kotlin.Function1%28%28kotlin.Int%2C+kotlin.collections.associateByTo.K%29%29%2C+kotlin.Function1%28%28kotlin.Int%2C+kotlin.collections.associateByTo.V%29%29%29%2FkeySelector&quot;&gt;keySelector&lt;/a&gt; function and and value is provided by the &lt;a href=&quot;../../kotlin.collections/associate-by-to#kotlin.collections%24associateByTo%28kotlin.IntArray%2C+kotlin.collections.associateByTo.M%2C+kotlin.Function1%28%28kotlin.Int%2C+kotlin.collections.associateByTo.K%29%29%2C+kotlin.Function1%28%28kotlin.Int%2C+kotlin.collections.associateByTo.V%29%29%29%2FvalueTransform&quot;&gt;valueTransform&lt;/a&gt; function applied to elements of the given array.</source>
          <target state="translated">채우고 되돌 &lt;a href=&quot;../../kotlin.collections/associate-by-to#kotlin.collections%24associateByTo%28kotlin.IntArray%2C+kotlin.collections.associateByTo.M%2C+kotlin.Function1%28%28kotlin.Int%2C+kotlin.collections.associateByTo.K%29%29%2C+kotlin.Function1%28%28kotlin.Int%2C+kotlin.collections.associateByTo.V%29%29%29%2Fdestination&quot;&gt;대상&lt;/a&gt; 키에 의해 제공되는 키 - 값 쌍으로 변경할지도 &lt;a href=&quot;../../kotlin.collections/associate-by-to#kotlin.collections%24associateByTo%28kotlin.IntArray%2C+kotlin.collections.associateByTo.M%2C+kotlin.Function1%28%28kotlin.Int%2C+kotlin.collections.associateByTo.K%29%29%2C+kotlin.Function1%28%28kotlin.Int%2C+kotlin.collections.associateByTo.V%29%29%29%2FkeySelector&quot;&gt;KeySelector에의&lt;/a&gt; 기능 및 값에 의해 제공된다 &lt;a href=&quot;../../kotlin.collections/associate-by-to#kotlin.collections%24associateByTo%28kotlin.IntArray%2C+kotlin.collections.associateByTo.M%2C+kotlin.Function1%28%28kotlin.Int%2C+kotlin.collections.associateByTo.K%29%29%2C+kotlin.Function1%28%28kotlin.Int%2C+kotlin.collections.associateByTo.V%29%29%29%2FvalueTransform&quot;&gt;valueTransform의&lt;/a&gt; 함수는 주어진 배열의 요소에 적용 하였다.</target>
        </trans-unit>
        <trans-unit id="f11152cde12e6d1614eef0deb533061d2b1bf59d" translate="yes" xml:space="preserve">
          <source>Populates and returns the &lt;a href=&quot;../../kotlin.collections/associate-by-to#kotlin.collections%24associateByTo%28kotlin.LongArray%2C+kotlin.collections.associateByTo.M%2C+kotlin.Function1%28%28kotlin.Long%2C+kotlin.collections.associateByTo.K%29%29%29%2Fdestination&quot;&gt;destination&lt;/a&gt; mutable map with key-value pairs, where key is provided by the &lt;a href=&quot;../../kotlin.collections/associate-by-to#kotlin.collections%24associateByTo%28kotlin.LongArray%2C+kotlin.collections.associateByTo.M%2C+kotlin.Function1%28%28kotlin.Long%2C+kotlin.collections.associateByTo.K%29%29%29%2FkeySelector&quot;&gt;keySelector&lt;/a&gt; function applied to each element of the given array and value is the element itself.</source>
          <target state="translated">키-값 쌍을 사용 하여 &lt;a href=&quot;../../kotlin.collections/associate-by-to#kotlin.collections%24associateByTo%28kotlin.LongArray%2C+kotlin.collections.associateByTo.M%2C+kotlin.Function1%28%28kotlin.Long%2C+kotlin.collections.associateByTo.K%29%29%29%2Fdestination&quot;&gt;대상&lt;/a&gt; 변경 가능 맵을 채우고 리턴합니다 . 여기서 키는 주어진 배열의 각 요소에 적용된 &lt;a href=&quot;../../kotlin.collections/associate-by-to#kotlin.collections%24associateByTo%28kotlin.LongArray%2C+kotlin.collections.associateByTo.M%2C+kotlin.Function1%28%28kotlin.Long%2C+kotlin.collections.associateByTo.K%29%29%29%2FkeySelector&quot;&gt;keySelector&lt;/a&gt; 함수에 의해 제공되며 value는 요소 자체입니다.</target>
        </trans-unit>
        <trans-unit id="d56d43a15229b8df5a4b882555e6345dcbf17540" translate="yes" xml:space="preserve">
          <source>Populates and returns the &lt;a href=&quot;../../kotlin.collections/associate-by-to#kotlin.collections%24associateByTo%28kotlin.LongArray%2C+kotlin.collections.associateByTo.M%2C+kotlin.Function1%28%28kotlin.Long%2C+kotlin.collections.associateByTo.K%29%29%2C+kotlin.Function1%28%28kotlin.Long%2C+kotlin.collections.associateByTo.V%29%29%29%2Fdestination&quot;&gt;destination&lt;/a&gt; mutable map with key-value pairs, where key is provided by the &lt;a href=&quot;../../kotlin.collections/associate-by-to#kotlin.collections%24associateByTo%28kotlin.LongArray%2C+kotlin.collections.associateByTo.M%2C+kotlin.Function1%28%28kotlin.Long%2C+kotlin.collections.associateByTo.K%29%29%2C+kotlin.Function1%28%28kotlin.Long%2C+kotlin.collections.associateByTo.V%29%29%29%2FkeySelector&quot;&gt;keySelector&lt;/a&gt; function and and value is provided by the &lt;a href=&quot;../../kotlin.collections/associate-by-to#kotlin.collections%24associateByTo%28kotlin.LongArray%2C+kotlin.collections.associateByTo.M%2C+kotlin.Function1%28%28kotlin.Long%2C+kotlin.collections.associateByTo.K%29%29%2C+kotlin.Function1%28%28kotlin.Long%2C+kotlin.collections.associateByTo.V%29%29%29%2FvalueTransform&quot;&gt;valueTransform&lt;/a&gt; function applied to elements of the given array.</source>
          <target state="translated">채우고 되돌 &lt;a href=&quot;../../kotlin.collections/associate-by-to#kotlin.collections%24associateByTo%28kotlin.LongArray%2C+kotlin.collections.associateByTo.M%2C+kotlin.Function1%28%28kotlin.Long%2C+kotlin.collections.associateByTo.K%29%29%2C+kotlin.Function1%28%28kotlin.Long%2C+kotlin.collections.associateByTo.V%29%29%29%2Fdestination&quot;&gt;대상&lt;/a&gt; 키에 의해 제공되는 키 - 값 쌍으로 변경할지도 &lt;a href=&quot;../../kotlin.collections/associate-by-to#kotlin.collections%24associateByTo%28kotlin.LongArray%2C+kotlin.collections.associateByTo.M%2C+kotlin.Function1%28%28kotlin.Long%2C+kotlin.collections.associateByTo.K%29%29%2C+kotlin.Function1%28%28kotlin.Long%2C+kotlin.collections.associateByTo.V%29%29%29%2FkeySelector&quot;&gt;KeySelector에의&lt;/a&gt; 기능 및 값에 의해 제공된다 &lt;a href=&quot;../../kotlin.collections/associate-by-to#kotlin.collections%24associateByTo%28kotlin.LongArray%2C+kotlin.collections.associateByTo.M%2C+kotlin.Function1%28%28kotlin.Long%2C+kotlin.collections.associateByTo.K%29%29%2C+kotlin.Function1%28%28kotlin.Long%2C+kotlin.collections.associateByTo.V%29%29%29%2FvalueTransform&quot;&gt;valueTransform의&lt;/a&gt; 함수는 주어진 배열의 요소에 적용 하였다.</target>
        </trans-unit>
        <trans-unit id="3dc35e1acead28c9cc9a024f3cba7e8852a7fa41" translate="yes" xml:space="preserve">
          <source>Populates and returns the &lt;a href=&quot;../../kotlin.collections/associate-by-to#kotlin.collections%24associateByTo%28kotlin.ShortArray%2C+kotlin.collections.associateByTo.M%2C+kotlin.Function1%28%28kotlin.Short%2C+kotlin.collections.associateByTo.K%29%29%29%2Fdestination&quot;&gt;destination&lt;/a&gt; mutable map with key-value pairs, where key is provided by the &lt;a href=&quot;../../kotlin.collections/associate-by-to#kotlin.collections%24associateByTo%28kotlin.ShortArray%2C+kotlin.collections.associateByTo.M%2C+kotlin.Function1%28%28kotlin.Short%2C+kotlin.collections.associateByTo.K%29%29%29%2FkeySelector&quot;&gt;keySelector&lt;/a&gt; function applied to each element of the given array and value is the element itself.</source>
          <target state="translated">키-값 쌍을 사용 하여 &lt;a href=&quot;../../kotlin.collections/associate-by-to#kotlin.collections%24associateByTo%28kotlin.ShortArray%2C+kotlin.collections.associateByTo.M%2C+kotlin.Function1%28%28kotlin.Short%2C+kotlin.collections.associateByTo.K%29%29%29%2Fdestination&quot;&gt;대상&lt;/a&gt; 변경 가능 맵을 채우고 리턴합니다 . 여기서 키는 주어진 배열의 각 요소에 적용된 &lt;a href=&quot;../../kotlin.collections/associate-by-to#kotlin.collections%24associateByTo%28kotlin.ShortArray%2C+kotlin.collections.associateByTo.M%2C+kotlin.Function1%28%28kotlin.Short%2C+kotlin.collections.associateByTo.K%29%29%29%2FkeySelector&quot;&gt;keySelector&lt;/a&gt; 함수에 의해 제공되며 value는 요소 자체입니다.</target>
        </trans-unit>
        <trans-unit id="535abd01da7044a27ccb1df593ed3fbe5c5398c9" translate="yes" xml:space="preserve">
          <source>Populates and returns the &lt;a href=&quot;../../kotlin.collections/associate-by-to#kotlin.collections%24associateByTo%28kotlin.ShortArray%2C+kotlin.collections.associateByTo.M%2C+kotlin.Function1%28%28kotlin.Short%2C+kotlin.collections.associateByTo.K%29%29%2C+kotlin.Function1%28%28kotlin.Short%2C+kotlin.collections.associateByTo.V%29%29%29%2Fdestination&quot;&gt;destination&lt;/a&gt; mutable map with key-value pairs, where key is provided by the &lt;a href=&quot;../../kotlin.collections/associate-by-to#kotlin.collections%24associateByTo%28kotlin.ShortArray%2C+kotlin.collections.associateByTo.M%2C+kotlin.Function1%28%28kotlin.Short%2C+kotlin.collections.associateByTo.K%29%29%2C+kotlin.Function1%28%28kotlin.Short%2C+kotlin.collections.associateByTo.V%29%29%29%2FkeySelector&quot;&gt;keySelector&lt;/a&gt; function and and value is provided by the &lt;a href=&quot;../../kotlin.collections/associate-by-to#kotlin.collections%24associateByTo%28kotlin.ShortArray%2C+kotlin.collections.associateByTo.M%2C+kotlin.Function1%28%28kotlin.Short%2C+kotlin.collections.associateByTo.K%29%29%2C+kotlin.Function1%28%28kotlin.Short%2C+kotlin.collections.associateByTo.V%29%29%29%2FvalueTransform&quot;&gt;valueTransform&lt;/a&gt; function applied to elements of the given array.</source>
          <target state="translated">채우고 되돌 &lt;a href=&quot;../../kotlin.collections/associate-by-to#kotlin.collections%24associateByTo%28kotlin.ShortArray%2C+kotlin.collections.associateByTo.M%2C+kotlin.Function1%28%28kotlin.Short%2C+kotlin.collections.associateByTo.K%29%29%2C+kotlin.Function1%28%28kotlin.Short%2C+kotlin.collections.associateByTo.V%29%29%29%2Fdestination&quot;&gt;대상&lt;/a&gt; 키에 의해 제공되는 키 - 값 쌍으로 변경할지도 &lt;a href=&quot;../../kotlin.collections/associate-by-to#kotlin.collections%24associateByTo%28kotlin.ShortArray%2C+kotlin.collections.associateByTo.M%2C+kotlin.Function1%28%28kotlin.Short%2C+kotlin.collections.associateByTo.K%29%29%2C+kotlin.Function1%28%28kotlin.Short%2C+kotlin.collections.associateByTo.V%29%29%29%2FkeySelector&quot;&gt;KeySelector에의&lt;/a&gt; 기능 및 값에 의해 제공된다 &lt;a href=&quot;../../kotlin.collections/associate-by-to#kotlin.collections%24associateByTo%28kotlin.ShortArray%2C+kotlin.collections.associateByTo.M%2C+kotlin.Function1%28%28kotlin.Short%2C+kotlin.collections.associateByTo.K%29%29%2C+kotlin.Function1%28%28kotlin.Short%2C+kotlin.collections.associateByTo.V%29%29%29%2FvalueTransform&quot;&gt;valueTransform의&lt;/a&gt; 함수는 주어진 배열의 요소에 적용 하였다.</target>
        </trans-unit>
        <trans-unit id="ea599f76b5cb805b8c6d077b4b51e064dc95e582" translate="yes" xml:space="preserve">
          <source>Populates and returns the &lt;a href=&quot;../../kotlin.collections/associate-by-to#kotlin.collections%24associateByTo%28kotlin.collections.Iterable%28%28kotlin.collections.associateByTo.T%29%29%2C+kotlin.collections.associateByTo.M%2C+kotlin.Function1%28%28kotlin.collections.associateByTo.T%2C+kotlin.collections.associateByTo.K%29%29%29%2Fdestination&quot;&gt;destination&lt;/a&gt; mutable map with key-value pairs, where key is provided by the &lt;a href=&quot;../../kotlin.collections/associate-by-to#kotlin.collections%24associateByTo%28kotlin.collections.Iterable%28%28kotlin.collections.associateByTo.T%29%29%2C+kotlin.collections.associateByTo.M%2C+kotlin.Function1%28%28kotlin.collections.associateByTo.T%2C+kotlin.collections.associateByTo.K%29%29%29%2FkeySelector&quot;&gt;keySelector&lt;/a&gt; function applied to each element of the given collection and value is the element itself.</source>
          <target state="translated">키-값 쌍을 사용 하여 &lt;a href=&quot;../../kotlin.collections/associate-by-to#kotlin.collections%24associateByTo%28kotlin.collections.Iterable%28%28kotlin.collections.associateByTo.T%29%29%2C+kotlin.collections.associateByTo.M%2C+kotlin.Function1%28%28kotlin.collections.associateByTo.T%2C+kotlin.collections.associateByTo.K%29%29%29%2Fdestination&quot;&gt;대상&lt;/a&gt; 변경 가능 맵을 채우고 리턴합니다 . 여기서 키는 주어진 콜렉션의 각 요소에 적용된 &lt;a href=&quot;../../kotlin.collections/associate-by-to#kotlin.collections%24associateByTo%28kotlin.collections.Iterable%28%28kotlin.collections.associateByTo.T%29%29%2C+kotlin.collections.associateByTo.M%2C+kotlin.Function1%28%28kotlin.collections.associateByTo.T%2C+kotlin.collections.associateByTo.K%29%29%29%2FkeySelector&quot;&gt;keySelector&lt;/a&gt; 함수에 의해 제공되며 value는 요소 자체입니다.</target>
        </trans-unit>
        <trans-unit id="14fe9f45c4659166e5d5b6a9351d07a47b0ba4d2" translate="yes" xml:space="preserve">
          <source>Populates and returns the &lt;a href=&quot;../../kotlin.collections/associate-by-to#kotlin.collections%24associateByTo%28kotlin.collections.Iterable%28%28kotlin.collections.associateByTo.T%29%29%2C+kotlin.collections.associateByTo.M%2C+kotlin.Function1%28%28kotlin.collections.associateByTo.T%2C+kotlin.collections.associateByTo.K%29%29%2C+kotlin.Function1%28%28kotlin.collections.associateByTo.T%2C+kotlin.collections.associateByTo.V%29%29%29%2Fdestination&quot;&gt;destination&lt;/a&gt; mutable map with key-value pairs, where key is provided by the &lt;a href=&quot;../../kotlin.collections/associate-by-to#kotlin.collections%24associateByTo%28kotlin.collections.Iterable%28%28kotlin.collections.associateByTo.T%29%29%2C+kotlin.collections.associateByTo.M%2C+kotlin.Function1%28%28kotlin.collections.associateByTo.T%2C+kotlin.collections.associateByTo.K%29%29%2C+kotlin.Function1%28%28kotlin.collections.associateByTo.T%2C+kotlin.collections.associateByTo.V%29%29%29%2FkeySelector&quot;&gt;keySelector&lt;/a&gt; function and and value is provided by the &lt;a href=&quot;../../kotlin.collections/associate-by-to#kotlin.collections%24associateByTo%28kotlin.collections.Iterable%28%28kotlin.collections.associateByTo.T%29%29%2C+kotlin.collections.associateByTo.M%2C+kotlin.Function1%28%28kotlin.collections.associateByTo.T%2C+kotlin.collections.associateByTo.K%29%29%2C+kotlin.Function1%28%28kotlin.collections.associateByTo.T%2C+kotlin.collections.associateByTo.V%29%29%29%2FvalueTransform&quot;&gt;valueTransform&lt;/a&gt; function applied to elements of the given collection.</source>
          <target state="translated">채우고 되돌 &lt;a href=&quot;../../kotlin.collections/associate-by-to#kotlin.collections%24associateByTo%28kotlin.collections.Iterable%28%28kotlin.collections.associateByTo.T%29%29%2C+kotlin.collections.associateByTo.M%2C+kotlin.Function1%28%28kotlin.collections.associateByTo.T%2C+kotlin.collections.associateByTo.K%29%29%2C+kotlin.Function1%28%28kotlin.collections.associateByTo.T%2C+kotlin.collections.associateByTo.V%29%29%29%2Fdestination&quot;&gt;대상&lt;/a&gt; 키에 의해 제공되는 키 - 값 쌍으로 변경할지도 &lt;a href=&quot;../../kotlin.collections/associate-by-to#kotlin.collections%24associateByTo%28kotlin.collections.Iterable%28%28kotlin.collections.associateByTo.T%29%29%2C+kotlin.collections.associateByTo.M%2C+kotlin.Function1%28%28kotlin.collections.associateByTo.T%2C+kotlin.collections.associateByTo.K%29%29%2C+kotlin.Function1%28%28kotlin.collections.associateByTo.T%2C+kotlin.collections.associateByTo.V%29%29%29%2FkeySelector&quot;&gt;KeySelector에의&lt;/a&gt; 기능 및 값에 의해 제공된다 &lt;a href=&quot;../../kotlin.collections/associate-by-to#kotlin.collections%24associateByTo%28kotlin.collections.Iterable%28%28kotlin.collections.associateByTo.T%29%29%2C+kotlin.collections.associateByTo.M%2C+kotlin.Function1%28%28kotlin.collections.associateByTo.T%2C+kotlin.collections.associateByTo.K%29%29%2C+kotlin.Function1%28%28kotlin.collections.associateByTo.T%2C+kotlin.collections.associateByTo.V%29%29%29%2FvalueTransform&quot;&gt;valueTransform의&lt;/a&gt; 함수는 주어진 컬렉션의 요소에 적용.</target>
        </trans-unit>
        <trans-unit id="7ac9d5cdf9e117969ee6fd10d283bd039df69bdb" translate="yes" xml:space="preserve">
          <source>Populates and returns the &lt;a href=&quot;../../kotlin.collections/associate-to#kotlin.collections%24associateTo%28kotlin.Array%28%28kotlin.collections.associateTo.T%29%29%2C+kotlin.collections.associateTo.M%2C+kotlin.Function1%28%28kotlin.collections.associateTo.T%2C+kotlin.Pair%28%28kotlin.collections.associateTo.K%2C+kotlin.collections.associateTo.V%29%29%29%29%29%2Fdestination&quot;&gt;destination&lt;/a&gt; mutable map with key-value pairs provided by &lt;a href=&quot;../../kotlin.collections/associate-to#kotlin.collections%24associateTo%28kotlin.Array%28%28kotlin.collections.associateTo.T%29%29%2C+kotlin.collections.associateTo.M%2C+kotlin.Function1%28%28kotlin.collections.associateTo.T%2C+kotlin.Pair%28%28kotlin.collections.associateTo.K%2C+kotlin.collections.associateTo.V%29%29%29%29%29%2Ftransform&quot;&gt;transform&lt;/a&gt; function applied to each element of the given array.</source>
          <target state="translated">지정된 배열의 각 요소에 적용된 &lt;a href=&quot;../../kotlin.collections/associate-to#kotlin.collections%24associateTo%28kotlin.Array%28%28kotlin.collections.associateTo.T%29%29%2C+kotlin.collections.associateTo.M%2C+kotlin.Function1%28%28kotlin.collections.associateTo.T%2C+kotlin.Pair%28%28kotlin.collections.associateTo.K%2C+kotlin.collections.associateTo.V%29%29%29%29%29%2Ftransform&quot;&gt;변환&lt;/a&gt; 함수에 의해 제공된 키-값 쌍을 사용 하여 &lt;a href=&quot;../../kotlin.collections/associate-to#kotlin.collections%24associateTo%28kotlin.Array%28%28kotlin.collections.associateTo.T%29%29%2C+kotlin.collections.associateTo.M%2C+kotlin.Function1%28%28kotlin.collections.associateTo.T%2C+kotlin.Pair%28%28kotlin.collections.associateTo.K%2C+kotlin.collections.associateTo.V%29%29%29%29%29%2Fdestination&quot;&gt;대상&lt;/a&gt; 변경 가능 맵을 채우고 리턴합니다 .</target>
        </trans-unit>
        <trans-unit id="7c8d8cb3a696eed3506a74fa2814b5821e1d267c" translate="yes" xml:space="preserve">
          <source>Populates and returns the &lt;a href=&quot;../../kotlin.collections/associate-to#kotlin.collections%24associateTo%28kotlin.BooleanArray%2C+kotlin.collections.associateTo.M%2C+kotlin.Function1%28%28kotlin.Boolean%2C+kotlin.Pair%28%28kotlin.collections.associateTo.K%2C+kotlin.collections.associateTo.V%29%29%29%29%29%2Fdestination&quot;&gt;destination&lt;/a&gt; mutable map with key-value pairs provided by &lt;a href=&quot;../../kotlin.collections/associate-to#kotlin.collections%24associateTo%28kotlin.BooleanArray%2C+kotlin.collections.associateTo.M%2C+kotlin.Function1%28%28kotlin.Boolean%2C+kotlin.Pair%28%28kotlin.collections.associateTo.K%2C+kotlin.collections.associateTo.V%29%29%29%29%29%2Ftransform&quot;&gt;transform&lt;/a&gt; function applied to each element of the given array.</source>
          <target state="translated">지정된 배열의 각 요소에 적용된 &lt;a href=&quot;../../kotlin.collections/associate-to#kotlin.collections%24associateTo%28kotlin.BooleanArray%2C+kotlin.collections.associateTo.M%2C+kotlin.Function1%28%28kotlin.Boolean%2C+kotlin.Pair%28%28kotlin.collections.associateTo.K%2C+kotlin.collections.associateTo.V%29%29%29%29%29%2Ftransform&quot;&gt;변환&lt;/a&gt; 함수에 의해 제공된 키-값 쌍을 사용 하여 &lt;a href=&quot;../../kotlin.collections/associate-to#kotlin.collections%24associateTo%28kotlin.BooleanArray%2C+kotlin.collections.associateTo.M%2C+kotlin.Function1%28%28kotlin.Boolean%2C+kotlin.Pair%28%28kotlin.collections.associateTo.K%2C+kotlin.collections.associateTo.V%29%29%29%29%29%2Fdestination&quot;&gt;대상&lt;/a&gt; 변경 가능 맵을 채우고 리턴합니다 .</target>
        </trans-unit>
        <trans-unit id="f0953fc7300bc0f59efa7e327d197bb5dea25408" translate="yes" xml:space="preserve">
          <source>Populates and returns the &lt;a href=&quot;../../kotlin.collections/associate-to#kotlin.collections%24associateTo%28kotlin.ByteArray%2C+kotlin.collections.associateTo.M%2C+kotlin.Function1%28%28kotlin.Byte%2C+kotlin.Pair%28%28kotlin.collections.associateTo.K%2C+kotlin.collections.associateTo.V%29%29%29%29%29%2Fdestination&quot;&gt;destination&lt;/a&gt; mutable map with key-value pairs provided by &lt;a href=&quot;../../kotlin.collections/associate-to#kotlin.collections%24associateTo%28kotlin.ByteArray%2C+kotlin.collections.associateTo.M%2C+kotlin.Function1%28%28kotlin.Byte%2C+kotlin.Pair%28%28kotlin.collections.associateTo.K%2C+kotlin.collections.associateTo.V%29%29%29%29%29%2Ftransform&quot;&gt;transform&lt;/a&gt; function applied to each element of the given array.</source>
          <target state="translated">지정된 배열의 각 요소에 적용된 &lt;a href=&quot;../../kotlin.collections/associate-to#kotlin.collections%24associateTo%28kotlin.ByteArray%2C+kotlin.collections.associateTo.M%2C+kotlin.Function1%28%28kotlin.Byte%2C+kotlin.Pair%28%28kotlin.collections.associateTo.K%2C+kotlin.collections.associateTo.V%29%29%29%29%29%2Ftransform&quot;&gt;변환&lt;/a&gt; 함수에 의해 제공된 키-값 쌍을 사용 하여 &lt;a href=&quot;../../kotlin.collections/associate-to#kotlin.collections%24associateTo%28kotlin.ByteArray%2C+kotlin.collections.associateTo.M%2C+kotlin.Function1%28%28kotlin.Byte%2C+kotlin.Pair%28%28kotlin.collections.associateTo.K%2C+kotlin.collections.associateTo.V%29%29%29%29%29%2Fdestination&quot;&gt;대상&lt;/a&gt; 변경 가능 맵을 채우고 리턴합니다 .</target>
        </trans-unit>
        <trans-unit id="29a42a62c585a0490da15590546a063f932573b5" translate="yes" xml:space="preserve">
          <source>Populates and returns the &lt;a href=&quot;../../kotlin.collections/associate-to#kotlin.collections%24associateTo%28kotlin.CharArray%2C+kotlin.collections.associateTo.M%2C+kotlin.Function1%28%28kotlin.Char%2C+kotlin.Pair%28%28kotlin.collections.associateTo.K%2C+kotlin.collections.associateTo.V%29%29%29%29%29%2Fdestination&quot;&gt;destination&lt;/a&gt; mutable map with key-value pairs provided by &lt;a href=&quot;../../kotlin.collections/associate-to#kotlin.collections%24associateTo%28kotlin.CharArray%2C+kotlin.collections.associateTo.M%2C+kotlin.Function1%28%28kotlin.Char%2C+kotlin.Pair%28%28kotlin.collections.associateTo.K%2C+kotlin.collections.associateTo.V%29%29%29%29%29%2Ftransform&quot;&gt;transform&lt;/a&gt; function applied to each element of the given array.</source>
          <target state="translated">지정된 배열의 각 요소에 적용된 &lt;a href=&quot;../../kotlin.collections/associate-to#kotlin.collections%24associateTo%28kotlin.CharArray%2C+kotlin.collections.associateTo.M%2C+kotlin.Function1%28%28kotlin.Char%2C+kotlin.Pair%28%28kotlin.collections.associateTo.K%2C+kotlin.collections.associateTo.V%29%29%29%29%29%2Ftransform&quot;&gt;변환&lt;/a&gt; 함수에 의해 제공된 키-값 쌍을 사용 하여 &lt;a href=&quot;../../kotlin.collections/associate-to#kotlin.collections%24associateTo%28kotlin.CharArray%2C+kotlin.collections.associateTo.M%2C+kotlin.Function1%28%28kotlin.Char%2C+kotlin.Pair%28%28kotlin.collections.associateTo.K%2C+kotlin.collections.associateTo.V%29%29%29%29%29%2Fdestination&quot;&gt;대상&lt;/a&gt; 변경 가능 맵을 채우고 리턴합니다 .</target>
        </trans-unit>
        <trans-unit id="b0ef08dea16529021d40ba7da3d084fdd66caec9" translate="yes" xml:space="preserve">
          <source>Populates and returns the &lt;a href=&quot;../../kotlin.collections/associate-to#kotlin.collections%24associateTo%28kotlin.DoubleArray%2C+kotlin.collections.associateTo.M%2C+kotlin.Function1%28%28kotlin.Double%2C+kotlin.Pair%28%28kotlin.collections.associateTo.K%2C+kotlin.collections.associateTo.V%29%29%29%29%29%2Fdestination&quot;&gt;destination&lt;/a&gt; mutable map with key-value pairs provided by &lt;a href=&quot;../../kotlin.collections/associate-to#kotlin.collections%24associateTo%28kotlin.DoubleArray%2C+kotlin.collections.associateTo.M%2C+kotlin.Function1%28%28kotlin.Double%2C+kotlin.Pair%28%28kotlin.collections.associateTo.K%2C+kotlin.collections.associateTo.V%29%29%29%29%29%2Ftransform&quot;&gt;transform&lt;/a&gt; function applied to each element of the given array.</source>
          <target state="translated">지정된 배열의 각 요소에 적용된 &lt;a href=&quot;../../kotlin.collections/associate-to#kotlin.collections%24associateTo%28kotlin.DoubleArray%2C+kotlin.collections.associateTo.M%2C+kotlin.Function1%28%28kotlin.Double%2C+kotlin.Pair%28%28kotlin.collections.associateTo.K%2C+kotlin.collections.associateTo.V%29%29%29%29%29%2Ftransform&quot;&gt;변환&lt;/a&gt; 함수에 의해 제공된 키-값 쌍을 사용 하여 &lt;a href=&quot;../../kotlin.collections/associate-to#kotlin.collections%24associateTo%28kotlin.DoubleArray%2C+kotlin.collections.associateTo.M%2C+kotlin.Function1%28%28kotlin.Double%2C+kotlin.Pair%28%28kotlin.collections.associateTo.K%2C+kotlin.collections.associateTo.V%29%29%29%29%29%2Fdestination&quot;&gt;대상&lt;/a&gt; 변경 가능 맵을 채우고 리턴합니다 .</target>
        </trans-unit>
        <trans-unit id="36fb4f2a7d3248986574e0c1dd6562a07512eaa9" translate="yes" xml:space="preserve">
          <source>Populates and returns the &lt;a href=&quot;../../kotlin.collections/associate-to#kotlin.collections%24associateTo%28kotlin.FloatArray%2C+kotlin.collections.associateTo.M%2C+kotlin.Function1%28%28kotlin.Float%2C+kotlin.Pair%28%28kotlin.collections.associateTo.K%2C+kotlin.collections.associateTo.V%29%29%29%29%29%2Fdestination&quot;&gt;destination&lt;/a&gt; mutable map with key-value pairs provided by &lt;a href=&quot;../../kotlin.collections/associate-to#kotlin.collections%24associateTo%28kotlin.FloatArray%2C+kotlin.collections.associateTo.M%2C+kotlin.Function1%28%28kotlin.Float%2C+kotlin.Pair%28%28kotlin.collections.associateTo.K%2C+kotlin.collections.associateTo.V%29%29%29%29%29%2Ftransform&quot;&gt;transform&lt;/a&gt; function applied to each element of the given array.</source>
          <target state="translated">지정된 배열의 각 요소에 적용된 &lt;a href=&quot;../../kotlin.collections/associate-to#kotlin.collections%24associateTo%28kotlin.FloatArray%2C+kotlin.collections.associateTo.M%2C+kotlin.Function1%28%28kotlin.Float%2C+kotlin.Pair%28%28kotlin.collections.associateTo.K%2C+kotlin.collections.associateTo.V%29%29%29%29%29%2Ftransform&quot;&gt;변환&lt;/a&gt; 함수에 의해 제공된 키-값 쌍을 사용 하여 &lt;a href=&quot;../../kotlin.collections/associate-to#kotlin.collections%24associateTo%28kotlin.FloatArray%2C+kotlin.collections.associateTo.M%2C+kotlin.Function1%28%28kotlin.Float%2C+kotlin.Pair%28%28kotlin.collections.associateTo.K%2C+kotlin.collections.associateTo.V%29%29%29%29%29%2Fdestination&quot;&gt;대상&lt;/a&gt; 변경 가능 맵을 채우고 리턴합니다 .</target>
        </trans-unit>
        <trans-unit id="005885692fbf56a60dc05bd53733c4891b99cfee" translate="yes" xml:space="preserve">
          <source>Populates and returns the &lt;a href=&quot;../../kotlin.collections/associate-to#kotlin.collections%24associateTo%28kotlin.IntArray%2C+kotlin.collections.associateTo.M%2C+kotlin.Function1%28%28kotlin.Int%2C+kotlin.Pair%28%28kotlin.collections.associateTo.K%2C+kotlin.collections.associateTo.V%29%29%29%29%29%2Fdestination&quot;&gt;destination&lt;/a&gt; mutable map with key-value pairs provided by &lt;a href=&quot;../../kotlin.collections/associate-to#kotlin.collections%24associateTo%28kotlin.IntArray%2C+kotlin.collections.associateTo.M%2C+kotlin.Function1%28%28kotlin.Int%2C+kotlin.Pair%28%28kotlin.collections.associateTo.K%2C+kotlin.collections.associateTo.V%29%29%29%29%29%2Ftransform&quot;&gt;transform&lt;/a&gt; function applied to each element of the given array.</source>
          <target state="translated">지정된 배열의 각 요소에 적용된 &lt;a href=&quot;../../kotlin.collections/associate-to#kotlin.collections%24associateTo%28kotlin.IntArray%2C+kotlin.collections.associateTo.M%2C+kotlin.Function1%28%28kotlin.Int%2C+kotlin.Pair%28%28kotlin.collections.associateTo.K%2C+kotlin.collections.associateTo.V%29%29%29%29%29%2Ftransform&quot;&gt;변환&lt;/a&gt; 함수에 의해 제공된 키-값 쌍을 사용 하여 &lt;a href=&quot;../../kotlin.collections/associate-to#kotlin.collections%24associateTo%28kotlin.IntArray%2C+kotlin.collections.associateTo.M%2C+kotlin.Function1%28%28kotlin.Int%2C+kotlin.Pair%28%28kotlin.collections.associateTo.K%2C+kotlin.collections.associateTo.V%29%29%29%29%29%2Fdestination&quot;&gt;대상&lt;/a&gt; 변경 가능 맵을 채우고 리턴합니다 .</target>
        </trans-unit>
        <trans-unit id="275b012ceb78f86357f9b74a9be9f065ced07569" translate="yes" xml:space="preserve">
          <source>Populates and returns the &lt;a href=&quot;../../kotlin.collections/associate-to#kotlin.collections%24associateTo%28kotlin.LongArray%2C+kotlin.collections.associateTo.M%2C+kotlin.Function1%28%28kotlin.Long%2C+kotlin.Pair%28%28kotlin.collections.associateTo.K%2C+kotlin.collections.associateTo.V%29%29%29%29%29%2Fdestination&quot;&gt;destination&lt;/a&gt; mutable map with key-value pairs provided by &lt;a href=&quot;../../kotlin.collections/associate-to#kotlin.collections%24associateTo%28kotlin.LongArray%2C+kotlin.collections.associateTo.M%2C+kotlin.Function1%28%28kotlin.Long%2C+kotlin.Pair%28%28kotlin.collections.associateTo.K%2C+kotlin.collections.associateTo.V%29%29%29%29%29%2Ftransform&quot;&gt;transform&lt;/a&gt; function applied to each element of the given array.</source>
          <target state="translated">지정된 배열의 각 요소에 적용된 &lt;a href=&quot;../../kotlin.collections/associate-to#kotlin.collections%24associateTo%28kotlin.LongArray%2C+kotlin.collections.associateTo.M%2C+kotlin.Function1%28%28kotlin.Long%2C+kotlin.Pair%28%28kotlin.collections.associateTo.K%2C+kotlin.collections.associateTo.V%29%29%29%29%29%2Ftransform&quot;&gt;변환&lt;/a&gt; 함수에 의해 제공된 키-값 쌍을 사용 하여 &lt;a href=&quot;../../kotlin.collections/associate-to#kotlin.collections%24associateTo%28kotlin.LongArray%2C+kotlin.collections.associateTo.M%2C+kotlin.Function1%28%28kotlin.Long%2C+kotlin.Pair%28%28kotlin.collections.associateTo.K%2C+kotlin.collections.associateTo.V%29%29%29%29%29%2Fdestination&quot;&gt;대상&lt;/a&gt; 변경 가능 맵을 채우고 리턴합니다 .</target>
        </trans-unit>
        <trans-unit id="1c9f9ade92bd594c318865244d8674cf43c6e5eb" translate="yes" xml:space="preserve">
          <source>Populates and returns the &lt;a href=&quot;../../kotlin.collections/associate-to#kotlin.collections%24associateTo%28kotlin.ShortArray%2C+kotlin.collections.associateTo.M%2C+kotlin.Function1%28%28kotlin.Short%2C+kotlin.Pair%28%28kotlin.collections.associateTo.K%2C+kotlin.collections.associateTo.V%29%29%29%29%29%2Fdestination&quot;&gt;destination&lt;/a&gt; mutable map with key-value pairs provided by &lt;a href=&quot;../../kotlin.collections/associate-to#kotlin.collections%24associateTo%28kotlin.ShortArray%2C+kotlin.collections.associateTo.M%2C+kotlin.Function1%28%28kotlin.Short%2C+kotlin.Pair%28%28kotlin.collections.associateTo.K%2C+kotlin.collections.associateTo.V%29%29%29%29%29%2Ftransform&quot;&gt;transform&lt;/a&gt; function applied to each element of the given array.</source>
          <target state="translated">지정된 배열의 각 요소에 적용된 &lt;a href=&quot;../../kotlin.collections/associate-to#kotlin.collections%24associateTo%28kotlin.ShortArray%2C+kotlin.collections.associateTo.M%2C+kotlin.Function1%28%28kotlin.Short%2C+kotlin.Pair%28%28kotlin.collections.associateTo.K%2C+kotlin.collections.associateTo.V%29%29%29%29%29%2Ftransform&quot;&gt;변환&lt;/a&gt; 함수에 의해 제공된 키-값 쌍을 사용 하여 &lt;a href=&quot;../../kotlin.collections/associate-to#kotlin.collections%24associateTo%28kotlin.ShortArray%2C+kotlin.collections.associateTo.M%2C+kotlin.Function1%28%28kotlin.Short%2C+kotlin.Pair%28%28kotlin.collections.associateTo.K%2C+kotlin.collections.associateTo.V%29%29%29%29%29%2Fdestination&quot;&gt;대상&lt;/a&gt; 변경 가능 맵을 채우고 리턴합니다 .</target>
        </trans-unit>
        <trans-unit id="222709cb6cec955540f6eec31b21dbcaa138e8ad" translate="yes" xml:space="preserve">
          <source>Populates and returns the &lt;a href=&quot;../../kotlin.collections/associate-to#kotlin.collections%24associateTo%28kotlin.collections.Iterable%28%28kotlin.collections.associateTo.T%29%29%2C+kotlin.collections.associateTo.M%2C+kotlin.Function1%28%28kotlin.collections.associateTo.T%2C+kotlin.Pair%28%28kotlin.collections.associateTo.K%2C+kotlin.collections.associateTo.V%29%29%29%29%29%2Fdestination&quot;&gt;destination&lt;/a&gt; mutable map with key-value pairs provided by &lt;a href=&quot;../../kotlin.collections/associate-to#kotlin.collections%24associateTo%28kotlin.collections.Iterable%28%28kotlin.collections.associateTo.T%29%29%2C+kotlin.collections.associateTo.M%2C+kotlin.Function1%28%28kotlin.collections.associateTo.T%2C+kotlin.Pair%28%28kotlin.collections.associateTo.K%2C+kotlin.collections.associateTo.V%29%29%29%29%29%2Ftransform&quot;&gt;transform&lt;/a&gt; function applied to each element of the given collection.</source>
          <target state="translated">지정된 컬렉션의 각 요소에 적용된 &lt;a href=&quot;../../kotlin.collections/associate-to#kotlin.collections%24associateTo%28kotlin.collections.Iterable%28%28kotlin.collections.associateTo.T%29%29%2C+kotlin.collections.associateTo.M%2C+kotlin.Function1%28%28kotlin.collections.associateTo.T%2C+kotlin.Pair%28%28kotlin.collections.associateTo.K%2C+kotlin.collections.associateTo.V%29%29%29%29%29%2Ftransform&quot;&gt;변환&lt;/a&gt; 함수에 의해 제공된 키-값 쌍을 사용 하여 &lt;a href=&quot;../../kotlin.collections/associate-to#kotlin.collections%24associateTo%28kotlin.collections.Iterable%28%28kotlin.collections.associateTo.T%29%29%2C+kotlin.collections.associateTo.M%2C+kotlin.Function1%28%28kotlin.collections.associateTo.T%2C+kotlin.Pair%28%28kotlin.collections.associateTo.K%2C+kotlin.collections.associateTo.V%29%29%29%29%29%2Fdestination&quot;&gt;대상&lt;/a&gt; 가변 맵을 채우고 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="4b3cec0c265cbd53d7684ed54291063de6524e65" translate="yes" xml:space="preserve">
          <source>Populates and returns the &lt;a href=&quot;../../kotlin.collections/associate-with-to#kotlin.collections%24associateWithTo%28kotlin.collections.Iterable%28%28kotlin.collections.associateWithTo.K%29%29%2C+kotlin.collections.associateWithTo.M%2C+kotlin.Function1%28%28kotlin.collections.associateWithTo.K%2C+kotlin.collections.associateWithTo.V%29%29%29%2Fdestination&quot;&gt;destination&lt;/a&gt; mutable map with key-value pairs for each element of the given collection, where key is the element itself and value is provided by the &lt;a href=&quot;../../kotlin.collections/associate-with-to#kotlin.collections%24associateWithTo%28kotlin.collections.Iterable%28%28kotlin.collections.associateWithTo.K%29%29%2C+kotlin.collections.associateWithTo.M%2C+kotlin.Function1%28%28kotlin.collections.associateWithTo.K%2C+kotlin.collections.associateWithTo.V%29%29%29%2FvalueSelector&quot;&gt;valueSelector&lt;/a&gt; function applied to that key.</source>
          <target state="translated">주어진 컬렉션의 각 요소에 대해 키-값 쌍을 사용 하여 &lt;a href=&quot;../../kotlin.collections/associate-with-to#kotlin.collections%24associateWithTo%28kotlin.collections.Iterable%28%28kotlin.collections.associateWithTo.K%29%29%2C+kotlin.collections.associateWithTo.M%2C+kotlin.Function1%28%28kotlin.collections.associateWithTo.K%2C+kotlin.collections.associateWithTo.V%29%29%29%2Fdestination&quot;&gt;대상&lt;/a&gt; 변경 가능 맵을 &lt;a href=&quot;../../kotlin.collections/associate-with-to#kotlin.collections%24associateWithTo%28kotlin.collections.Iterable%28%28kotlin.collections.associateWithTo.K%29%29%2C+kotlin.collections.associateWithTo.M%2C+kotlin.Function1%28%28kotlin.collections.associateWithTo.K%2C+kotlin.collections.associateWithTo.V%29%29%29%2FvalueSelector&quot;&gt;채우고 리턴&lt;/a&gt; 합니다. 여기서 key는 요소 자체이며 값은 해당 키에 적용된 valueSelector 함수에 의해 제공됩니다 .</target>
        </trans-unit>
        <trans-unit id="0ee2ea86d75e05bf19ed43f94f8f29fa928a470a" translate="yes" xml:space="preserve">
          <source>Populates and returns the &lt;a href=&quot;../../kotlin.collections/to-map#kotlin.collections%24toMap%28kotlin.Array%28%28kotlin.Pair%28%28kotlin.collections.toMap.K%2C+kotlin.collections.toMap.V%29%29%29%29%2C+kotlin.collections.toMap.M%29%2Fdestination&quot;&gt;destination&lt;/a&gt; mutable map with key-value pairs from the given array of pairs.</source>
          <target state="translated">주어진 쌍의 배열에서 키-값 쌍을 사용 하여 &lt;a href=&quot;../../kotlin.collections/to-map#kotlin.collections%24toMap%28kotlin.Array%28%28kotlin.Pair%28%28kotlin.collections.toMap.K%2C+kotlin.collections.toMap.V%29%29%29%29%2C+kotlin.collections.toMap.M%29%2Fdestination&quot;&gt;대상&lt;/a&gt; 변경 가능 맵을 채우고 리턴합니다 .</target>
        </trans-unit>
        <trans-unit id="1433bc5917111a026fbb4cb78b8d5db17b5bb675" translate="yes" xml:space="preserve">
          <source>Populates and returns the &lt;a href=&quot;../../kotlin.collections/to-map#kotlin.collections%24toMap%28kotlin.sequences.Sequence%28%28kotlin.Pair%28%28kotlin.collections.toMap.K%2C+kotlin.collections.toMap.V%29%29%29%29%2C+kotlin.collections.toMap.M%29%2Fdestination&quot;&gt;destination&lt;/a&gt; mutable map with key-value pairs from the given sequence of pairs.</source>
          <target state="translated">주어진 쌍의 시퀀스에서 키-값 쌍을 사용 하여 &lt;a href=&quot;../../kotlin.collections/to-map#kotlin.collections%24toMap%28kotlin.sequences.Sequence%28%28kotlin.Pair%28%28kotlin.collections.toMap.K%2C+kotlin.collections.toMap.V%29%29%29%29%2C+kotlin.collections.toMap.M%29%2Fdestination&quot;&gt;대상&lt;/a&gt; 가변 맵을 채우고 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="b50c3513993561d08e0ce6fdd6676f47133115dc" translate="yes" xml:space="preserve">
          <source>Populates and returns the &lt;a href=&quot;../../kotlin.text/associate-by-to#kotlin.text%24associateByTo%28kotlin.CharSequence%2C+kotlin.text.associateByTo.M%2C+kotlin.Function1%28%28kotlin.Char%2C+kotlin.text.associateByTo.K%29%29%29%2Fdestination&quot;&gt;destination&lt;/a&gt; mutable map with key-value pairs, where key is provided by the &lt;a href=&quot;../../kotlin.text/associate-by-to#kotlin.text%24associateByTo%28kotlin.CharSequence%2C+kotlin.text.associateByTo.M%2C+kotlin.Function1%28%28kotlin.Char%2C+kotlin.text.associateByTo.K%29%29%29%2FkeySelector&quot;&gt;keySelector&lt;/a&gt; function applied to each character of the given char sequence and value is the character itself.</source>
          <target state="translated">키-값 쌍을 사용 하여 &lt;a href=&quot;../../kotlin.text/associate-by-to#kotlin.text%24associateByTo%28kotlin.CharSequence%2C+kotlin.text.associateByTo.M%2C+kotlin.Function1%28%28kotlin.Char%2C+kotlin.text.associateByTo.K%29%29%29%2Fdestination&quot;&gt;대상&lt;/a&gt; 변경 가능 맵을 채우고 리턴합니다 . 여기서 키는 주어진 문자 시퀀스의 각 문자에 적용되는 &lt;a href=&quot;../../kotlin.text/associate-by-to#kotlin.text%24associateByTo%28kotlin.CharSequence%2C+kotlin.text.associateByTo.M%2C+kotlin.Function1%28%28kotlin.Char%2C+kotlin.text.associateByTo.K%29%29%29%2FkeySelector&quot;&gt;keySelector&lt;/a&gt; 함수에 의해 제공되며 value는 문자 자체입니다.</target>
        </trans-unit>
        <trans-unit id="3bf8950467eebfb02b6d12bdd9a08c3e11df4dd8" translate="yes" xml:space="preserve">
          <source>Populates and returns the &lt;a href=&quot;../../kotlin.text/associate-by-to#kotlin.text%24associateByTo%28kotlin.CharSequence%2C+kotlin.text.associateByTo.M%2C+kotlin.Function1%28%28kotlin.Char%2C+kotlin.text.associateByTo.K%29%29%2C+kotlin.Function1%28%28kotlin.Char%2C+kotlin.text.associateByTo.V%29%29%29%2Fdestination&quot;&gt;destination&lt;/a&gt; mutable map with key-value pairs, where key is provided by the &lt;a href=&quot;../../kotlin.text/associate-by-to#kotlin.text%24associateByTo%28kotlin.CharSequence%2C+kotlin.text.associateByTo.M%2C+kotlin.Function1%28%28kotlin.Char%2C+kotlin.text.associateByTo.K%29%29%2C+kotlin.Function1%28%28kotlin.Char%2C+kotlin.text.associateByTo.V%29%29%29%2FkeySelector&quot;&gt;keySelector&lt;/a&gt; function and and value is provided by the &lt;a href=&quot;../../kotlin.text/associate-by-to#kotlin.text%24associateByTo%28kotlin.CharSequence%2C+kotlin.text.associateByTo.M%2C+kotlin.Function1%28%28kotlin.Char%2C+kotlin.text.associateByTo.K%29%29%2C+kotlin.Function1%28%28kotlin.Char%2C+kotlin.text.associateByTo.V%29%29%29%2FvalueTransform&quot;&gt;valueTransform&lt;/a&gt; function applied to characters of the given char sequence.</source>
          <target state="translated">채우고 되돌 &lt;a href=&quot;../../kotlin.text/associate-by-to#kotlin.text%24associateByTo%28kotlin.CharSequence%2C+kotlin.text.associateByTo.M%2C+kotlin.Function1%28%28kotlin.Char%2C+kotlin.text.associateByTo.K%29%29%2C+kotlin.Function1%28%28kotlin.Char%2C+kotlin.text.associateByTo.V%29%29%29%2Fdestination&quot;&gt;대상&lt;/a&gt; 키에 의해 제공되는 키 - 값 쌍으로 변경할지도 &lt;a href=&quot;../../kotlin.text/associate-by-to#kotlin.text%24associateByTo%28kotlin.CharSequence%2C+kotlin.text.associateByTo.M%2C+kotlin.Function1%28%28kotlin.Char%2C+kotlin.text.associateByTo.K%29%29%2C+kotlin.Function1%28%28kotlin.Char%2C+kotlin.text.associateByTo.V%29%29%29%2FkeySelector&quot;&gt;KeySelector에의&lt;/a&gt; 기능 및 값에 의해 제공된다 &lt;a href=&quot;../../kotlin.text/associate-by-to#kotlin.text%24associateByTo%28kotlin.CharSequence%2C+kotlin.text.associateByTo.M%2C+kotlin.Function1%28%28kotlin.Char%2C+kotlin.text.associateByTo.K%29%29%2C+kotlin.Function1%28%28kotlin.Char%2C+kotlin.text.associateByTo.V%29%29%29%2FvalueTransform&quot;&gt;valueTransform의&lt;/a&gt; 기능은 주어진 문자 시퀀스의 문자에 적용.</target>
        </trans-unit>
        <trans-unit id="b64885bdd2b7c51d1bd993d8ebca0c3aea40777e" translate="yes" xml:space="preserve">
          <source>Populates and returns the &lt;a href=&quot;../../kotlin.text/associate-to#kotlin.text%24associateTo%28kotlin.CharSequence%2C+kotlin.text.associateTo.M%2C+kotlin.Function1%28%28kotlin.Char%2C+kotlin.Pair%28%28kotlin.text.associateTo.K%2C+kotlin.text.associateTo.V%29%29%29%29%29%2Fdestination&quot;&gt;destination&lt;/a&gt; mutable map with key-value pairs provided by &lt;a href=&quot;../../kotlin.text/associate-to#kotlin.text%24associateTo%28kotlin.CharSequence%2C+kotlin.text.associateTo.M%2C+kotlin.Function1%28%28kotlin.Char%2C+kotlin.Pair%28%28kotlin.text.associateTo.K%2C+kotlin.text.associateTo.V%29%29%29%29%29%2Ftransform&quot;&gt;transform&lt;/a&gt; function applied to each character of the given char sequence.</source>
          <target state="translated">주어진 문자 시퀀스의 각 문자에 적용된 &lt;a href=&quot;../../kotlin.text/associate-to#kotlin.text%24associateTo%28kotlin.CharSequence%2C+kotlin.text.associateTo.M%2C+kotlin.Function1%28%28kotlin.Char%2C+kotlin.Pair%28%28kotlin.text.associateTo.K%2C+kotlin.text.associateTo.V%29%29%29%29%29%2Ftransform&quot;&gt;변환&lt;/a&gt; 함수에 의해 제공된 키-값 쌍을 사용 하여 &lt;a href=&quot;../../kotlin.text/associate-to#kotlin.text%24associateTo%28kotlin.CharSequence%2C+kotlin.text.associateTo.M%2C+kotlin.Function1%28%28kotlin.Char%2C+kotlin.Pair%28%28kotlin.text.associateTo.K%2C+kotlin.text.associateTo.V%29%29%29%29%29%2Fdestination&quot;&gt;대상&lt;/a&gt; 변경 가능 맵을 채우고 리턴합니다 .</target>
        </trans-unit>
        <trans-unit id="08049c8715ed54b355404482e75d57c1492f8b46" translate="yes" xml:space="preserve">
          <source>Populates and returns the &lt;a href=&quot;../../kotlin.text/associate-with-to#kotlin.text%24associateWithTo%28kotlin.CharSequence%2C+kotlin.text.associateWithTo.M%2C+kotlin.Function1%28%28kotlin.Char%2C+kotlin.text.associateWithTo.V%29%29%29%2Fdestination&quot;&gt;destination&lt;/a&gt; mutable map with key-value pairs for each character of the given char sequence, where key is the character itself and value is provided by the &lt;a href=&quot;../../kotlin.text/associate-with-to#kotlin.text%24associateWithTo%28kotlin.CharSequence%2C+kotlin.text.associateWithTo.M%2C+kotlin.Function1%28%28kotlin.Char%2C+kotlin.text.associateWithTo.V%29%29%29%2FvalueSelector&quot;&gt;valueSelector&lt;/a&gt; function applied to that key.</source>
          <target state="translated">주어진 문자 시퀀스의 각 문자에 대한 키-값 쌍을 사용 하여 &lt;a href=&quot;../../kotlin.text/associate-with-to#kotlin.text%24associateWithTo%28kotlin.CharSequence%2C+kotlin.text.associateWithTo.M%2C+kotlin.Function1%28%28kotlin.Char%2C+kotlin.text.associateWithTo.V%29%29%29%2Fdestination&quot;&gt;대상&lt;/a&gt; 변경 가능 맵을 &lt;a href=&quot;../../kotlin.text/associate-with-to#kotlin.text%24associateWithTo%28kotlin.CharSequence%2C+kotlin.text.associateWithTo.M%2C+kotlin.Function1%28%28kotlin.Char%2C+kotlin.text.associateWithTo.V%29%29%29%2FvalueSelector&quot;&gt;채우고 리턴&lt;/a&gt; 합니다. 여기서, 키는 문자 자체이며 값은 해당 키에 적용된 valueSelector 함수에 의해 제공됩니다 .</target>
        </trans-unit>
        <trans-unit id="3bfa88beba28fa899e7efabef398d0df9fc527f6" translate="yes" xml:space="preserve">
          <source>Populates and returns the &lt;a href=&quot;../associate-by-to#kotlin.collections%24associateByTo%28kotlin.collections.Iterable%28%28kotlin.collections.associateByTo.T%29%29%2C+kotlin.collections.associateByTo.M%2C+kotlin.Function1%28%28kotlin.collections.associateByTo.T%2C+kotlin.collections.associateByTo.K%29%29%29%2Fdestination&quot;&gt;destination&lt;/a&gt; mutable map with key-value pairs, where key is provided by the &lt;a href=&quot;../associate-by-to#kotlin.collections%24associateByTo%28kotlin.collections.Iterable%28%28kotlin.collections.associateByTo.T%29%29%2C+kotlin.collections.associateByTo.M%2C+kotlin.Function1%28%28kotlin.collections.associateByTo.T%2C+kotlin.collections.associateByTo.K%29%29%29%2FkeySelector&quot;&gt;keySelector&lt;/a&gt; function applied to each element of the given collection and value is the element itself.</source>
          <target state="translated">키-값 쌍을 사용 하여 &lt;a href=&quot;../associate-by-to#kotlin.collections%24associateByTo%28kotlin.collections.Iterable%28%28kotlin.collections.associateByTo.T%29%29%2C+kotlin.collections.associateByTo.M%2C+kotlin.Function1%28%28kotlin.collections.associateByTo.T%2C+kotlin.collections.associateByTo.K%29%29%29%2Fdestination&quot;&gt;대상&lt;/a&gt; 변경 가능 맵을 채우고 리턴합니다 . 여기서 키는 주어진 콜렉션의 각 요소에 적용된 &lt;a href=&quot;../associate-by-to#kotlin.collections%24associateByTo%28kotlin.collections.Iterable%28%28kotlin.collections.associateByTo.T%29%29%2C+kotlin.collections.associateByTo.M%2C+kotlin.Function1%28%28kotlin.collections.associateByTo.T%2C+kotlin.collections.associateByTo.K%29%29%29%2FkeySelector&quot;&gt;keySelector&lt;/a&gt; 함수에 의해 제공되며 value는 요소 자체입니다.</target>
        </trans-unit>
        <trans-unit id="63884c2ba8ab3783e9195e5db339c72987632cfb" translate="yes" xml:space="preserve">
          <source>Populates and returns the &lt;a href=&quot;../associate-by-to#kotlin.collections%24associateByTo%28kotlin.collections.Iterable%28%28kotlin.collections.associateByTo.T%29%29%2C+kotlin.collections.associateByTo.M%2C+kotlin.Function1%28%28kotlin.collections.associateByTo.T%2C+kotlin.collections.associateByTo.K%29%29%2C+kotlin.Function1%28%28kotlin.collections.associateByTo.T%2C+kotlin.collections.associateByTo.V%29%29%29%2Fdestination&quot;&gt;destination&lt;/a&gt; mutable map with key-value pairs, where key is provided by the &lt;a href=&quot;../associate-by-to#kotlin.collections%24associateByTo%28kotlin.collections.Iterable%28%28kotlin.collections.associateByTo.T%29%29%2C+kotlin.collections.associateByTo.M%2C+kotlin.Function1%28%28kotlin.collections.associateByTo.T%2C+kotlin.collections.associateByTo.K%29%29%2C+kotlin.Function1%28%28kotlin.collections.associateByTo.T%2C+kotlin.collections.associateByTo.V%29%29%29%2FkeySelector&quot;&gt;keySelector&lt;/a&gt; function and and value is provided by the &lt;a href=&quot;../associate-by-to#kotlin.collections%24associateByTo%28kotlin.collections.Iterable%28%28kotlin.collections.associateByTo.T%29%29%2C+kotlin.collections.associateByTo.M%2C+kotlin.Function1%28%28kotlin.collections.associateByTo.T%2C+kotlin.collections.associateByTo.K%29%29%2C+kotlin.Function1%28%28kotlin.collections.associateByTo.T%2C+kotlin.collections.associateByTo.V%29%29%29%2FvalueTransform&quot;&gt;valueTransform&lt;/a&gt; function applied to elements of the given collection.</source>
          <target state="translated">채우고 되돌 &lt;a href=&quot;../associate-by-to#kotlin.collections%24associateByTo%28kotlin.collections.Iterable%28%28kotlin.collections.associateByTo.T%29%29%2C+kotlin.collections.associateByTo.M%2C+kotlin.Function1%28%28kotlin.collections.associateByTo.T%2C+kotlin.collections.associateByTo.K%29%29%2C+kotlin.Function1%28%28kotlin.collections.associateByTo.T%2C+kotlin.collections.associateByTo.V%29%29%29%2Fdestination&quot;&gt;대상&lt;/a&gt; 키에 의해 제공되는 키 - 값 쌍으로 변경할지도 &lt;a href=&quot;../associate-by-to#kotlin.collections%24associateByTo%28kotlin.collections.Iterable%28%28kotlin.collections.associateByTo.T%29%29%2C+kotlin.collections.associateByTo.M%2C+kotlin.Function1%28%28kotlin.collections.associateByTo.T%2C+kotlin.collections.associateByTo.K%29%29%2C+kotlin.Function1%28%28kotlin.collections.associateByTo.T%2C+kotlin.collections.associateByTo.V%29%29%29%2FkeySelector&quot;&gt;KeySelector에의&lt;/a&gt; 기능 및 값에 의해 제공된다 &lt;a href=&quot;../associate-by-to#kotlin.collections%24associateByTo%28kotlin.collections.Iterable%28%28kotlin.collections.associateByTo.T%29%29%2C+kotlin.collections.associateByTo.M%2C+kotlin.Function1%28%28kotlin.collections.associateByTo.T%2C+kotlin.collections.associateByTo.K%29%29%2C+kotlin.Function1%28%28kotlin.collections.associateByTo.T%2C+kotlin.collections.associateByTo.V%29%29%29%2FvalueTransform&quot;&gt;valueTransform의&lt;/a&gt; 함수는 주어진 컬렉션의 요소에 적용.</target>
        </trans-unit>
        <trans-unit id="d3212e9a08afda08c72e954fe852b843a188ea5c" translate="yes" xml:space="preserve">
          <source>Populates and returns the &lt;a href=&quot;../associate-by-to#kotlin.sequences%24associateByTo%28kotlin.sequences.Sequence%28%28kotlin.sequences.associateByTo.T%29%29%2C+kotlin.sequences.associateByTo.M%2C+kotlin.Function1%28%28kotlin.sequences.associateByTo.T%2C+kotlin.sequences.associateByTo.K%29%29%29%2Fdestination&quot;&gt;destination&lt;/a&gt; mutable map with key-value pairs, where key is provided by the &lt;a href=&quot;../associate-by-to#kotlin.sequences%24associateByTo%28kotlin.sequences.Sequence%28%28kotlin.sequences.associateByTo.T%29%29%2C+kotlin.sequences.associateByTo.M%2C+kotlin.Function1%28%28kotlin.sequences.associateByTo.T%2C+kotlin.sequences.associateByTo.K%29%29%29%2FkeySelector&quot;&gt;keySelector&lt;/a&gt; function applied to each element of the given sequence and value is the element itself.</source>
          <target state="translated">키-값 쌍을 사용 하여 &lt;a href=&quot;../associate-by-to#kotlin.sequences%24associateByTo%28kotlin.sequences.Sequence%28%28kotlin.sequences.associateByTo.T%29%29%2C+kotlin.sequences.associateByTo.M%2C+kotlin.Function1%28%28kotlin.sequences.associateByTo.T%2C+kotlin.sequences.associateByTo.K%29%29%29%2Fdestination&quot;&gt;대상&lt;/a&gt; 변경 가능 맵을 채우고 리턴합니다 . 여기서 키는 주어진 시퀀스의 각 요소에 적용된 &lt;a href=&quot;../associate-by-to#kotlin.sequences%24associateByTo%28kotlin.sequences.Sequence%28%28kotlin.sequences.associateByTo.T%29%29%2C+kotlin.sequences.associateByTo.M%2C+kotlin.Function1%28%28kotlin.sequences.associateByTo.T%2C+kotlin.sequences.associateByTo.K%29%29%29%2FkeySelector&quot;&gt;keySelector&lt;/a&gt; 함수에 의해 제공되며 value는 요소 자체입니다.</target>
        </trans-unit>
        <trans-unit id="5b8b8c943c1609879d7a1f57b5dc9813bf21326e" translate="yes" xml:space="preserve">
          <source>Populates and returns the &lt;a href=&quot;../associate-by-to#kotlin.sequences%24associateByTo%28kotlin.sequences.Sequence%28%28kotlin.sequences.associateByTo.T%29%29%2C+kotlin.sequences.associateByTo.M%2C+kotlin.Function1%28%28kotlin.sequences.associateByTo.T%2C+kotlin.sequences.associateByTo.K%29%29%2C+kotlin.Function1%28%28kotlin.sequences.associateByTo.T%2C+kotlin.sequences.associateByTo.V%29%29%29%2Fdestination&quot;&gt;destination&lt;/a&gt; mutable map with key-value pairs, where key is provided by the &lt;a href=&quot;../associate-by-to#kotlin.sequences%24associateByTo%28kotlin.sequences.Sequence%28%28kotlin.sequences.associateByTo.T%29%29%2C+kotlin.sequences.associateByTo.M%2C+kotlin.Function1%28%28kotlin.sequences.associateByTo.T%2C+kotlin.sequences.associateByTo.K%29%29%2C+kotlin.Function1%28%28kotlin.sequences.associateByTo.T%2C+kotlin.sequences.associateByTo.V%29%29%29%2FkeySelector&quot;&gt;keySelector&lt;/a&gt; function and and value is provided by the &lt;a href=&quot;../associate-by-to#kotlin.sequences%24associateByTo%28kotlin.sequences.Sequence%28%28kotlin.sequences.associateByTo.T%29%29%2C+kotlin.sequences.associateByTo.M%2C+kotlin.Function1%28%28kotlin.sequences.associateByTo.T%2C+kotlin.sequences.associateByTo.K%29%29%2C+kotlin.Function1%28%28kotlin.sequences.associateByTo.T%2C+kotlin.sequences.associateByTo.V%29%29%29%2FvalueTransform&quot;&gt;valueTransform&lt;/a&gt; function applied to elements of the given sequence.</source>
          <target state="translated">채우고 되돌 &lt;a href=&quot;../associate-by-to#kotlin.sequences%24associateByTo%28kotlin.sequences.Sequence%28%28kotlin.sequences.associateByTo.T%29%29%2C+kotlin.sequences.associateByTo.M%2C+kotlin.Function1%28%28kotlin.sequences.associateByTo.T%2C+kotlin.sequences.associateByTo.K%29%29%2C+kotlin.Function1%28%28kotlin.sequences.associateByTo.T%2C+kotlin.sequences.associateByTo.V%29%29%29%2Fdestination&quot;&gt;대상&lt;/a&gt; 키에 의해 제공되는 키 - 값 쌍으로 변경할지도 &lt;a href=&quot;../associate-by-to#kotlin.sequences%24associateByTo%28kotlin.sequences.Sequence%28%28kotlin.sequences.associateByTo.T%29%29%2C+kotlin.sequences.associateByTo.M%2C+kotlin.Function1%28%28kotlin.sequences.associateByTo.T%2C+kotlin.sequences.associateByTo.K%29%29%2C+kotlin.Function1%28%28kotlin.sequences.associateByTo.T%2C+kotlin.sequences.associateByTo.V%29%29%29%2FkeySelector&quot;&gt;KeySelector에의&lt;/a&gt; 기능 및 값에 의해 제공된다 &lt;a href=&quot;../associate-by-to#kotlin.sequences%24associateByTo%28kotlin.sequences.Sequence%28%28kotlin.sequences.associateByTo.T%29%29%2C+kotlin.sequences.associateByTo.M%2C+kotlin.Function1%28%28kotlin.sequences.associateByTo.T%2C+kotlin.sequences.associateByTo.K%29%29%2C+kotlin.Function1%28%28kotlin.sequences.associateByTo.T%2C+kotlin.sequences.associateByTo.V%29%29%29%2FvalueTransform&quot;&gt;valueTransform의&lt;/a&gt; 함수는 주어진 시퀀스의 요소에 적용 하였다.</target>
        </trans-unit>
        <trans-unit id="5384339a5d0735aa683d1c5076e43862b74c65d6" translate="yes" xml:space="preserve">
          <source>Populates and returns the &lt;a href=&quot;../associate-by-to#kotlin.text%24associateByTo%28kotlin.CharSequence%2C+kotlin.text.associateByTo.M%2C+kotlin.Function1%28%28kotlin.Char%2C+kotlin.text.associateByTo.K%29%29%29%2Fdestination&quot;&gt;destination&lt;/a&gt; mutable map with key-value pairs, where key is provided by the &lt;a href=&quot;../associate-by-to#kotlin.text%24associateByTo%28kotlin.CharSequence%2C+kotlin.text.associateByTo.M%2C+kotlin.Function1%28%28kotlin.Char%2C+kotlin.text.associateByTo.K%29%29%29%2FkeySelector&quot;&gt;keySelector&lt;/a&gt; function applied to each character of the given char sequence and value is the character itself.</source>
          <target state="translated">키-값 쌍을 사용 하여 &lt;a href=&quot;../associate-by-to#kotlin.text%24associateByTo%28kotlin.CharSequence%2C+kotlin.text.associateByTo.M%2C+kotlin.Function1%28%28kotlin.Char%2C+kotlin.text.associateByTo.K%29%29%29%2Fdestination&quot;&gt;대상&lt;/a&gt; 변경 가능 맵을 채우고 리턴합니다 . 여기서 키는 주어진 문자 시퀀스의 각 문자에 적용되는 &lt;a href=&quot;../associate-by-to#kotlin.text%24associateByTo%28kotlin.CharSequence%2C+kotlin.text.associateByTo.M%2C+kotlin.Function1%28%28kotlin.Char%2C+kotlin.text.associateByTo.K%29%29%29%2FkeySelector&quot;&gt;keySelector&lt;/a&gt; 함수에 의해 제공되며 value는 문자 자체입니다.</target>
        </trans-unit>
        <trans-unit id="7ae55e124d3d56ba20ffaff33842d9c8916eaea8" translate="yes" xml:space="preserve">
          <source>Populates and returns the &lt;a href=&quot;../associate-by-to#kotlin.text%24associateByTo%28kotlin.CharSequence%2C+kotlin.text.associateByTo.M%2C+kotlin.Function1%28%28kotlin.Char%2C+kotlin.text.associateByTo.K%29%29%2C+kotlin.Function1%28%28kotlin.Char%2C+kotlin.text.associateByTo.V%29%29%29%2Fdestination&quot;&gt;destination&lt;/a&gt; mutable map with key-value pairs, where key is provided by the &lt;a href=&quot;../associate-by-to#kotlin.text%24associateByTo%28kotlin.CharSequence%2C+kotlin.text.associateByTo.M%2C+kotlin.Function1%28%28kotlin.Char%2C+kotlin.text.associateByTo.K%29%29%2C+kotlin.Function1%28%28kotlin.Char%2C+kotlin.text.associateByTo.V%29%29%29%2FkeySelector&quot;&gt;keySelector&lt;/a&gt; function and and value is provided by the &lt;a href=&quot;../associate-by-to#kotlin.text%24associateByTo%28kotlin.CharSequence%2C+kotlin.text.associateByTo.M%2C+kotlin.Function1%28%28kotlin.Char%2C+kotlin.text.associateByTo.K%29%29%2C+kotlin.Function1%28%28kotlin.Char%2C+kotlin.text.associateByTo.V%29%29%29%2FvalueTransform&quot;&gt;valueTransform&lt;/a&gt; function applied to characters of the given char sequence.</source>
          <target state="translated">채우고 되돌 &lt;a href=&quot;../associate-by-to#kotlin.text%24associateByTo%28kotlin.CharSequence%2C+kotlin.text.associateByTo.M%2C+kotlin.Function1%28%28kotlin.Char%2C+kotlin.text.associateByTo.K%29%29%2C+kotlin.Function1%28%28kotlin.Char%2C+kotlin.text.associateByTo.V%29%29%29%2Fdestination&quot;&gt;대상&lt;/a&gt; 키에 의해 제공되는 키 - 값 쌍으로 변경할지도 &lt;a href=&quot;../associate-by-to#kotlin.text%24associateByTo%28kotlin.CharSequence%2C+kotlin.text.associateByTo.M%2C+kotlin.Function1%28%28kotlin.Char%2C+kotlin.text.associateByTo.K%29%29%2C+kotlin.Function1%28%28kotlin.Char%2C+kotlin.text.associateByTo.V%29%29%29%2FkeySelector&quot;&gt;KeySelector에의&lt;/a&gt; 기능 및 값에 의해 제공된다 &lt;a href=&quot;../associate-by-to#kotlin.text%24associateByTo%28kotlin.CharSequence%2C+kotlin.text.associateByTo.M%2C+kotlin.Function1%28%28kotlin.Char%2C+kotlin.text.associateByTo.K%29%29%2C+kotlin.Function1%28%28kotlin.Char%2C+kotlin.text.associateByTo.V%29%29%29%2FvalueTransform&quot;&gt;valueTransform의&lt;/a&gt; 기능은 주어진 문자 시퀀스의 문자에 적용.</target>
        </trans-unit>
        <trans-unit id="392dcb695a938cce9be34e7a8e590802b145da17" translate="yes" xml:space="preserve">
          <source>Populates and returns the &lt;a href=&quot;../associate-to#kotlin.collections%24associateTo%28kotlin.collections.Iterable%28%28kotlin.collections.associateTo.T%29%29%2C+kotlin.collections.associateTo.M%2C+kotlin.Function1%28%28kotlin.collections.associateTo.T%2C+kotlin.Pair%28%28kotlin.collections.associateTo.K%2C+kotlin.collections.associateTo.V%29%29%29%29%29%2Fdestination&quot;&gt;destination&lt;/a&gt; mutable map with key-value pairs provided by &lt;a href=&quot;../associate-to#kotlin.collections%24associateTo%28kotlin.collections.Iterable%28%28kotlin.collections.associateTo.T%29%29%2C+kotlin.collections.associateTo.M%2C+kotlin.Function1%28%28kotlin.collections.associateTo.T%2C+kotlin.Pair%28%28kotlin.collections.associateTo.K%2C+kotlin.collections.associateTo.V%29%29%29%29%29%2Ftransform&quot;&gt;transform&lt;/a&gt; function applied to each element of the given collection.</source>
          <target state="translated">지정된 컬렉션의 각 요소에 적용된 &lt;a href=&quot;../associate-to#kotlin.collections%24associateTo%28kotlin.collections.Iterable%28%28kotlin.collections.associateTo.T%29%29%2C+kotlin.collections.associateTo.M%2C+kotlin.Function1%28%28kotlin.collections.associateTo.T%2C+kotlin.Pair%28%28kotlin.collections.associateTo.K%2C+kotlin.collections.associateTo.V%29%29%29%29%29%2Ftransform&quot;&gt;변환&lt;/a&gt; 함수에 의해 제공된 키-값 쌍을 사용 하여 &lt;a href=&quot;../associate-to#kotlin.collections%24associateTo%28kotlin.collections.Iterable%28%28kotlin.collections.associateTo.T%29%29%2C+kotlin.collections.associateTo.M%2C+kotlin.Function1%28%28kotlin.collections.associateTo.T%2C+kotlin.Pair%28%28kotlin.collections.associateTo.K%2C+kotlin.collections.associateTo.V%29%29%29%29%29%2Fdestination&quot;&gt;대상&lt;/a&gt; 가변 맵을 채우고 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="a4fce5a30ada9c031d14ecb70ab4a7a990af509a" translate="yes" xml:space="preserve">
          <source>Populates and returns the &lt;a href=&quot;../associate-to#kotlin.sequences%24associateTo%28kotlin.sequences.Sequence%28%28kotlin.sequences.associateTo.T%29%29%2C+kotlin.sequences.associateTo.M%2C+kotlin.Function1%28%28kotlin.sequences.associateTo.T%2C+kotlin.Pair%28%28kotlin.sequences.associateTo.K%2C+kotlin.sequences.associateTo.V%29%29%29%29%29%2Fdestination&quot;&gt;destination&lt;/a&gt; mutable map with key-value pairs provided by &lt;a href=&quot;../associate-to#kotlin.sequences%24associateTo%28kotlin.sequences.Sequence%28%28kotlin.sequences.associateTo.T%29%29%2C+kotlin.sequences.associateTo.M%2C+kotlin.Function1%28%28kotlin.sequences.associateTo.T%2C+kotlin.Pair%28%28kotlin.sequences.associateTo.K%2C+kotlin.sequences.associateTo.V%29%29%29%29%29%2Ftransform&quot;&gt;transform&lt;/a&gt; function applied to each element of the given sequence.</source>
          <target state="translated">주어진 시퀀스의 각 요소에 적용된 &lt;a href=&quot;../associate-to#kotlin.sequences%24associateTo%28kotlin.sequences.Sequence%28%28kotlin.sequences.associateTo.T%29%29%2C+kotlin.sequences.associateTo.M%2C+kotlin.Function1%28%28kotlin.sequences.associateTo.T%2C+kotlin.Pair%28%28kotlin.sequences.associateTo.K%2C+kotlin.sequences.associateTo.V%29%29%29%29%29%2Ftransform&quot;&gt;변환&lt;/a&gt; 함수에 의해 제공된 키-값 쌍을 사용 하여 &lt;a href=&quot;../associate-to#kotlin.sequences%24associateTo%28kotlin.sequences.Sequence%28%28kotlin.sequences.associateTo.T%29%29%2C+kotlin.sequences.associateTo.M%2C+kotlin.Function1%28%28kotlin.sequences.associateTo.T%2C+kotlin.Pair%28%28kotlin.sequences.associateTo.K%2C+kotlin.sequences.associateTo.V%29%29%29%29%29%2Fdestination&quot;&gt;대상&lt;/a&gt; 변경 가능 맵을 채우고 리턴합니다 .</target>
        </trans-unit>
        <trans-unit id="881cea2c519af687517a4c634a7b9732436c1136" translate="yes" xml:space="preserve">
          <source>Populates and returns the &lt;a href=&quot;../associate-to#kotlin.text%24associateTo%28kotlin.CharSequence%2C+kotlin.text.associateTo.M%2C+kotlin.Function1%28%28kotlin.Char%2C+kotlin.Pair%28%28kotlin.text.associateTo.K%2C+kotlin.text.associateTo.V%29%29%29%29%29%2Fdestination&quot;&gt;destination&lt;/a&gt; mutable map with key-value pairs provided by &lt;a href=&quot;../associate-to#kotlin.text%24associateTo%28kotlin.CharSequence%2C+kotlin.text.associateTo.M%2C+kotlin.Function1%28%28kotlin.Char%2C+kotlin.Pair%28%28kotlin.text.associateTo.K%2C+kotlin.text.associateTo.V%29%29%29%29%29%2Ftransform&quot;&gt;transform&lt;/a&gt; function applied to each character of the given char sequence.</source>
          <target state="translated">주어진 문자 시퀀스의 각 문자에 적용된 &lt;a href=&quot;../associate-to#kotlin.text%24associateTo%28kotlin.CharSequence%2C+kotlin.text.associateTo.M%2C+kotlin.Function1%28%28kotlin.Char%2C+kotlin.Pair%28%28kotlin.text.associateTo.K%2C+kotlin.text.associateTo.V%29%29%29%29%29%2Ftransform&quot;&gt;변환&lt;/a&gt; 함수에 의해 제공된 키-값 쌍을 사용 하여 &lt;a href=&quot;../associate-to#kotlin.text%24associateTo%28kotlin.CharSequence%2C+kotlin.text.associateTo.M%2C+kotlin.Function1%28%28kotlin.Char%2C+kotlin.Pair%28%28kotlin.text.associateTo.K%2C+kotlin.text.associateTo.V%29%29%29%29%29%2Fdestination&quot;&gt;대상&lt;/a&gt; 변경 가능 맵을 채우고 리턴합니다 .</target>
        </trans-unit>
        <trans-unit id="da35771039c5ede750defdd998bce46defbc8a67" translate="yes" xml:space="preserve">
          <source>Populates and returns the &lt;a href=&quot;../associate-with-to#kotlin.collections%24associateWithTo%28kotlin.collections.Iterable%28%28kotlin.collections.associateWithTo.K%29%29%2C+kotlin.collections.associateWithTo.M%2C+kotlin.Function1%28%28kotlin.collections.associateWithTo.K%2C+kotlin.collections.associateWithTo.V%29%29%29%2Fdestination&quot;&gt;destination&lt;/a&gt; mutable map with key-value pairs for each element of the given collection, where key is the element itself and value is provided by the &lt;a href=&quot;../associate-with-to#kotlin.collections%24associateWithTo%28kotlin.collections.Iterable%28%28kotlin.collections.associateWithTo.K%29%29%2C+kotlin.collections.associateWithTo.M%2C+kotlin.Function1%28%28kotlin.collections.associateWithTo.K%2C+kotlin.collections.associateWithTo.V%29%29%29%2FvalueSelector&quot;&gt;valueSelector&lt;/a&gt; function applied to that key.</source>
          <target state="translated">주어진 컬렉션의 각 요소에 대해 키-값 쌍을 사용 하여 &lt;a href=&quot;../associate-with-to#kotlin.collections%24associateWithTo%28kotlin.collections.Iterable%28%28kotlin.collections.associateWithTo.K%29%29%2C+kotlin.collections.associateWithTo.M%2C+kotlin.Function1%28%28kotlin.collections.associateWithTo.K%2C+kotlin.collections.associateWithTo.V%29%29%29%2Fdestination&quot;&gt;대상&lt;/a&gt; 변경 가능 맵을 &lt;a href=&quot;../associate-with-to#kotlin.collections%24associateWithTo%28kotlin.collections.Iterable%28%28kotlin.collections.associateWithTo.K%29%29%2C+kotlin.collections.associateWithTo.M%2C+kotlin.Function1%28%28kotlin.collections.associateWithTo.K%2C+kotlin.collections.associateWithTo.V%29%29%29%2FvalueSelector&quot;&gt;채우고 리턴&lt;/a&gt; 합니다. 여기서 key는 요소 자체이며 값은 해당 키에 적용된 valueSelector 함수에 의해 제공됩니다 .</target>
        </trans-unit>
        <trans-unit id="1bd8c37c5ec1a10d6a6cf183b7489e4a31e66cd2" translate="yes" xml:space="preserve">
          <source>Populates and returns the &lt;a href=&quot;../associate-with-to#kotlin.sequences%24associateWithTo%28kotlin.sequences.Sequence%28%28kotlin.sequences.associateWithTo.K%29%29%2C+kotlin.sequences.associateWithTo.M%2C+kotlin.Function1%28%28kotlin.sequences.associateWithTo.K%2C+kotlin.sequences.associateWithTo.V%29%29%29%2Fdestination&quot;&gt;destination&lt;/a&gt; mutable map with key-value pairs for each element of the given sequence, where key is the element itself and value is provided by the &lt;a href=&quot;../associate-with-to#kotlin.sequences%24associateWithTo%28kotlin.sequences.Sequence%28%28kotlin.sequences.associateWithTo.K%29%29%2C+kotlin.sequences.associateWithTo.M%2C+kotlin.Function1%28%28kotlin.sequences.associateWithTo.K%2C+kotlin.sequences.associateWithTo.V%29%29%29%2FvalueSelector&quot;&gt;valueSelector&lt;/a&gt; function applied to that key.</source>
          <target state="translated">주어진 시퀀스의 각 요소에 대한 키-값 쌍을 사용 하여 &lt;a href=&quot;../associate-with-to#kotlin.sequences%24associateWithTo%28kotlin.sequences.Sequence%28%28kotlin.sequences.associateWithTo.K%29%29%2C+kotlin.sequences.associateWithTo.M%2C+kotlin.Function1%28%28kotlin.sequences.associateWithTo.K%2C+kotlin.sequences.associateWithTo.V%29%29%29%2Fdestination&quot;&gt;대상&lt;/a&gt; 변경 가능 맵을 &lt;a href=&quot;../associate-with-to#kotlin.sequences%24associateWithTo%28kotlin.sequences.Sequence%28%28kotlin.sequences.associateWithTo.K%29%29%2C+kotlin.sequences.associateWithTo.M%2C+kotlin.Function1%28%28kotlin.sequences.associateWithTo.K%2C+kotlin.sequences.associateWithTo.V%29%29%29%2FvalueSelector&quot;&gt;채우고 리턴&lt;/a&gt; 합니다. 여기서 key는 요소 자체이며 값은 해당 키에 적용된 valueSelector 함수에 의해 제공됩니다 .</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
