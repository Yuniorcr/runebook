<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="kotlin">
    <body>
      <group id="kotlin">
        <trans-unit id="5ac343906b9635efc6bc3ea707e0886b7e34f40a" translate="yes" xml:space="preserve">
          <source>The last element of the progression is calculated to find the maximum value not greater than the end value for a positive step or the minimum value not less than the end value for a negative step such that &lt;code&gt;(last - first) % step == 0&lt;/code&gt;.</source>
          <target state="translated">진행의 마지막 요소는 음 단계되도록 덜 최종 값 이상의 포지티브 단계 또는 최소 값의 최종 값보다 크지 않은 최대 값을 찾기 위해 계산 &lt;code&gt;(last - first) % step == 0&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="01b3b5a6efe68e4716a891433d6bbbed0351ca8d" translate="yes" xml:space="preserve">
          <source>The last line is invoking the function itself and passing as argument &lt;code&gt;kotlin&lt;/code&gt;, which refers to the standard library. This can be obtained in one of two ways:</source>
          <target state="translated">마지막 줄은 함수 자체를 호출 하고 표준 라이브러리를 참조하는 &lt;code&gt;kotlin&lt;/code&gt; 인수로 전달 합니다. 이것은 두 가지 방법 중 하나로 얻을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="538d53f2bc70104b650857f7bb5ca32765c9300b" translate="yes" xml:space="preserve">
          <source>The last list in the resulting list may have less elements than the given &lt;a href=&quot;chunked#kotlin.collections%24chunked%28kotlin.collections.Iterable%28%28kotlin.collections.chunked.T%29%29%2C+kotlin.Int%29%2Fsize&quot;&gt;size&lt;/a&gt;.</source>
          <target state="translated">결과 목록의 마지막 목록은 주어진 &lt;a href=&quot;chunked#kotlin.collections%24chunked%28kotlin.collections.Iterable%28%28kotlin.collections.chunked.T%29%29%2C+kotlin.Int%29%2Fsize&quot;&gt;크기&lt;/a&gt; 보다 적은 요소를 가질 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="df81eba7c4b794145b48baa6539e2f2979a8d58f" translate="yes" xml:space="preserve">
          <source>The last list in the resulting sequence may have less elements than the given &lt;a href=&quot;chunked#kotlin.sequences%24chunked%28kotlin.sequences.Sequence%28%28kotlin.sequences.chunked.T%29%29%2C+kotlin.Int%29%2Fsize&quot;&gt;size&lt;/a&gt;.</source>
          <target state="translated">결과 시퀀스의 마지막 목록은 주어진 &lt;a href=&quot;chunked#kotlin.sequences%24chunked%28kotlin.sequences.Sequence%28%28kotlin.sequences.chunked.T%29%29%2C+kotlin.Int%29%2Fsize&quot;&gt;크기&lt;/a&gt; 보다 적은 요소를 가질 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="19dcc0ec6fdfe1941cf804b7c1eaf5c5297a4c82" translate="yes" xml:space="preserve">
          <source>The last string in the resulting list may have less characters than the given &lt;a href=&quot;chunked#kotlin.text%24chunked%28kotlin.CharSequence%2C+kotlin.Int%29%2Fsize&quot;&gt;size&lt;/a&gt;.</source>
          <target state="translated">결과 목록의 마지막 문자열은 주어진 &lt;a href=&quot;chunked#kotlin.text%24chunked%28kotlin.CharSequence%2C+kotlin.Int%29%2Fsize&quot;&gt;크기&lt;/a&gt; 보다 적은 문자를 가질 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="5264566740d059c5fcc7247f9b4782bf04dc775d" translate="yes" xml:space="preserve">
          <source>The last string in the resulting sequence may have less characters than the given &lt;a href=&quot;chunked-sequence#kotlin.text%24chunkedSequence%28kotlin.CharSequence%2C+kotlin.Int%29%2Fsize&quot;&gt;size&lt;/a&gt;.</source>
          <target state="translated">결과 시퀀스의 마지막 문자열은 주어진 &lt;a href=&quot;chunked-sequence#kotlin.text%24chunkedSequence%28kotlin.CharSequence%2C+kotlin.Int%29%2Fsize&quot;&gt;크기&lt;/a&gt; 보다 적은 문자를 가질 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="34c76d76568703e916e3116e8326427af7debc51" translate="yes" xml:space="preserve">
          <source>The lastIndex is a read/write integer property of regular expressions that specifies the index at which to start the next match.</source>
          <target state="translated">lastIndex는 다음 일치를 시작할 인덱스를 지정하는 정규식의 읽기 / 쓰기 정수 속성입니다.</target>
        </trans-unit>
        <trans-unit id="9d0eba273c11a973f53f6330c745e78d9f5b9345" translate="yes" xml:space="preserve">
          <source>The latter is called &lt;strong&gt;contravariance&lt;/strong&gt;, and you can only call methods that take String as an argument on &lt;code&gt;List&amp;lt;? super String&amp;gt;&lt;/code&gt; (e.g., you can call &lt;code&gt;add(String)&lt;/code&gt; or &lt;code&gt;set(int, String)&lt;/code&gt;), while if you call something that returns &lt;code&gt;T&lt;/code&gt; in &lt;code&gt;List&amp;lt;T&amp;gt;&lt;/code&gt;, you don't get a &lt;code&gt;String&lt;/code&gt;, but an &lt;code&gt;Object&lt;/code&gt;.</source>
          <target state="translated">후자를 &quot; &lt;strong&gt;contravariance&quot;&lt;/strong&gt; 라고하며 , String을 인수로 사용하는 메소드 만 &lt;code&gt;List&amp;lt;? super String&amp;gt;&lt;/code&gt; (예를 들어, &lt;code&gt;add(String)&lt;/code&gt; 또는 &lt;code&gt;set(int, String)&lt;/code&gt; 을 호출 할 수 있음 ) 반면 &lt;code&gt;List&amp;lt;T&amp;gt;&lt;/code&gt; 에서 &lt;code&gt;T&lt;/code&gt; 를 반환하는 것을 호출 하면 &lt;code&gt;String&lt;/code&gt; 이 아니라 &lt;code&gt;Object&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="86eeb4f1664e3df8b781582839802549edf89327" translate="yes" xml:space="preserve">
          <source>The layout of a Kotlin multiplatform project is constructed out of the following building blocks:</source>
          <target state="translated">Kotlin 멀티 플랫폼 프로젝트의 레이아웃은 다음 빌딩 블록으로 구성됩니다.</target>
        </trans-unit>
        <trans-unit id="dc4b69a6e38939f4509626db77c33dd8c679086f" translate="yes" xml:space="preserve">
          <source>The least significant 16 bits of the resulting &lt;code&gt;Int&lt;/code&gt; value are the same as the bits of this &lt;code&gt;Short&lt;/code&gt; value, whereas the most significant 16 bits are filled with the sign bit of this value.</source>
          <target state="translated">결과 &lt;code&gt;Int&lt;/code&gt; 값 의 최하위 16 비트는 이 &lt;code&gt;Short&lt;/code&gt; 값 의 비트와 동일 하지만 최상위 16 비트는이 값의 부호 비트로 채워집니다.</target>
        </trans-unit>
        <trans-unit id="4f0f34d38c4a4771a59f6d35fcaf5f32f9d5a113" translate="yes" xml:space="preserve">
          <source>The least significant 16 bits of the resulting &lt;code&gt;Int&lt;/code&gt; value are the same as the bits of this &lt;code&gt;UShort&lt;/code&gt; value, whereas the most significant 16 bits are filled with zeros.</source>
          <target state="translated">결과 &lt;code&gt;Int&lt;/code&gt; 값 의 최하위 16 비트는 이 &lt;code&gt;UShort&lt;/code&gt; 값 의 비트와 동일 하지만 최상위 16 비트는 0으로 채워집니다.</target>
        </trans-unit>
        <trans-unit id="db7d64a40964cbcc91041fe9c6abd3a6f883ba7c" translate="yes" xml:space="preserve">
          <source>The least significant 16 bits of the resulting &lt;code&gt;Long&lt;/code&gt; value are the same as the bits of this &lt;code&gt;Short&lt;/code&gt; value, whereas the most significant 48 bits are filled with the sign bit of this value.</source>
          <target state="translated">결과 &lt;code&gt;Long&lt;/code&gt; 값 의 최하위 16 비트는 이 &lt;code&gt;Short&lt;/code&gt; 값 의 비트와 동일 하지만 최상위 48 비트는이 값의 부호 비트로 채워집니다.</target>
        </trans-unit>
        <trans-unit id="96755580626f22c0780c08fafc24e52c9efd9ea9" translate="yes" xml:space="preserve">
          <source>The least significant 16 bits of the resulting &lt;code&gt;Long&lt;/code&gt; value are the same as the bits of this &lt;code&gt;UShort&lt;/code&gt; value, whereas the most significant 48 bits are filled with zeros.</source>
          <target state="translated">결과 &lt;code&gt;Long&lt;/code&gt; 값 의 최하위 16 비트는 이 &lt;code&gt;UShort&lt;/code&gt; 값 의 비트와 동일 하지만 최상위 48 비트는 0으로 채워집니다.</target>
        </trans-unit>
        <trans-unit id="805e1d578ae5895787cd7c80c9a6f84d9875cbdf" translate="yes" xml:space="preserve">
          <source>The least significant 16 bits of the resulting &lt;code&gt;UInt&lt;/code&gt; value are the same as the bits of this &lt;code&gt;Short&lt;/code&gt; value, whereas the most significant 16 bits are filled with the sign bit of this value.</source>
          <target state="translated">결과 &lt;code&gt;UInt&lt;/code&gt; 값 의 최하위 16 비트는 이 &lt;code&gt;Short&lt;/code&gt; 값 의 비트와 동일 하지만 최상위 16 비트는이 값의 부호 비트로 채워집니다.</target>
        </trans-unit>
        <trans-unit id="e2d7f90749fa8a275417e31e2a951b621f7bdd7e" translate="yes" xml:space="preserve">
          <source>The least significant 16 bits of the resulting &lt;code&gt;UInt&lt;/code&gt; value are the same as the bits of this &lt;code&gt;UShort&lt;/code&gt; value, whereas the most significant 16 bits are filled with zeros.</source>
          <target state="translated">결과 &lt;code&gt;UInt&lt;/code&gt; 값 의 최하위 16 비트는 이 &lt;code&gt;UShort&lt;/code&gt; 값 의 비트와 동일 하지만 최상위 16 비트는 0으로 채워집니다.</target>
        </trans-unit>
        <trans-unit id="382a5532019e821cafc1c9ca21454b43f1f91a60" translate="yes" xml:space="preserve">
          <source>The least significant 16 bits of the resulting &lt;code&gt;ULong&lt;/code&gt; value are the same as the bits of this &lt;code&gt;Short&lt;/code&gt; value, whereas the most significant 48 bits are filled with the sign bit of this value.</source>
          <target state="translated">결과 &lt;code&gt;ULong&lt;/code&gt; 값 의 최하위 16 비트는 이 &lt;code&gt;Short&lt;/code&gt; 값 의 비트와 동일 하지만 최상위 48 비트는이 값의 부호 비트로 채워집니다.</target>
        </trans-unit>
        <trans-unit id="98d7b8a419dc2e1a1e55aeb89fee5123de4a6b5e" translate="yes" xml:space="preserve">
          <source>The least significant 16 bits of the resulting &lt;code&gt;ULong&lt;/code&gt; value are the same as the bits of this &lt;code&gt;UShort&lt;/code&gt; value, whereas the most significant 48 bits are filled with zeros.</source>
          <target state="translated">결과 &lt;code&gt;ULong&lt;/code&gt; 값 의 최하위 16 비트는 이 &lt;code&gt;UShort&lt;/code&gt; 값 의 비트와 동일 하지만 최상위 48 비트는 0으로 채워집니다.</target>
        </trans-unit>
        <trans-unit id="b511f5bcb1b166f6a21672ecd3a364142d43ef6e" translate="yes" xml:space="preserve">
          <source>The least significant 32 bits of the resulting &lt;code&gt;Long&lt;/code&gt; value are the same as the bits of this &lt;code&gt;Int&lt;/code&gt; value, whereas the most significant 32 bits are filled with the sign bit of this value.</source>
          <target state="translated">결과 &lt;code&gt;Long&lt;/code&gt; 값 의 최하위 32 비트는 이 &lt;code&gt;Int&lt;/code&gt; 값 의 비트와 동일 하지만 최상위 32 비트는이 값의 부호 비트로 채워집니다.</target>
        </trans-unit>
        <trans-unit id="8552752324805690a09e930c3347d0b3b76fb45a" translate="yes" xml:space="preserve">
          <source>The least significant 32 bits of the resulting &lt;code&gt;Long&lt;/code&gt; value are the same as the bits of this &lt;code&gt;UInt&lt;/code&gt; value, whereas the most significant 32 bits are filled with zeros.</source>
          <target state="translated">결과 &lt;code&gt;Long&lt;/code&gt; 값 의 최하위 32 비트는 이 &lt;code&gt;UInt&lt;/code&gt; 값 의 비트와 동일 하지만 최상위 32 비트는 0으로 채워집니다.</target>
        </trans-unit>
        <trans-unit id="13513c5d8d4b778bf7d2d02871ec67b342f92eb3" translate="yes" xml:space="preserve">
          <source>The least significant 32 bits of the resulting &lt;code&gt;ULong&lt;/code&gt; value are the same as the bits of this &lt;code&gt;Int&lt;/code&gt; value, whereas the most significant 32 bits are filled with the sign bit of this value.</source>
          <target state="translated">결과 &lt;code&gt;ULong&lt;/code&gt; 값 의 최하위 32 비트는 이 &lt;code&gt;Int&lt;/code&gt; 값 의 비트와 동일 하지만 최상위 32 비트는이 값의 부호 비트로 채워집니다.</target>
        </trans-unit>
        <trans-unit id="098196788f072e1b90241673f7cd1c8d4ddc487e" translate="yes" xml:space="preserve">
          <source>The least significant 32 bits of the resulting &lt;code&gt;ULong&lt;/code&gt; value are the same as the bits of this &lt;code&gt;UInt&lt;/code&gt; value, whereas the most significant 32 bits are filled with zeros.</source>
          <target state="translated">결과 &lt;code&gt;ULong&lt;/code&gt; 값 의 최하위 32 비트는 이 &lt;code&gt;UInt&lt;/code&gt; 값 의 비트와 동일 하지만 최상위 32 비트는 0으로 채워집니다.</target>
        </trans-unit>
        <trans-unit id="1e95934eab4e475329950f2eb8e7a3a03516b89c" translate="yes" xml:space="preserve">
          <source>The least significant 8 bits of the resulting &lt;code&gt;Char&lt;/code&gt; code are the same as the bits of this &lt;code&gt;Byte&lt;/code&gt; value, whereas the most significant 8 bits are filled with the sign bit of this value.</source>
          <target state="translated">결과 &lt;code&gt;Char&lt;/code&gt; 코드 의 최하위 8 비트는 이 &lt;code&gt;Byte&lt;/code&gt; 값 의 비트와 동일 하지만 최상위 8 비트는이 값의 부호 비트로 채워집니다.</target>
        </trans-unit>
        <trans-unit id="1ccfa3d5b3f0d4c2cadb8ddee394a5e74b7f3fb0" translate="yes" xml:space="preserve">
          <source>The least significant 8 bits of the resulting &lt;code&gt;Int&lt;/code&gt; value are the same as the bits of this &lt;code&gt;Byte&lt;/code&gt; value, whereas the most significant 24 bits are filled with the sign bit of this value.</source>
          <target state="translated">결과 &lt;code&gt;Int&lt;/code&gt; 값 의 최하위 8 비트는 이 &lt;code&gt;Byte&lt;/code&gt; 값 의 비트와 동일 하지만 최상위 24 비트는이 값의 부호 비트로 채워집니다.</target>
        </trans-unit>
        <trans-unit id="682e9bb2df532a75f2a73fb4a8682c3fe53c3f6f" translate="yes" xml:space="preserve">
          <source>The least significant 8 bits of the resulting &lt;code&gt;Int&lt;/code&gt; value are the same as the bits of this &lt;code&gt;UByte&lt;/code&gt; value, whereas the most significant 24 bits are filled with zeros.</source>
          <target state="translated">결과 &lt;code&gt;Int&lt;/code&gt; 값 의 최하위 8 비트는 이 &lt;code&gt;UByte&lt;/code&gt; 값 의 비트와 동일 하지만 최상위 24 비트는 0으로 채워집니다.</target>
        </trans-unit>
        <trans-unit id="740b8988c3d828c3ba10680439510f32d7f08bd4" translate="yes" xml:space="preserve">
          <source>The least significant 8 bits of the resulting &lt;code&gt;Long&lt;/code&gt; value are the same as the bits of this &lt;code&gt;Byte&lt;/code&gt; value, whereas the most significant 56 bits are filled with the sign bit of this value.</source>
          <target state="translated">결과 &lt;code&gt;Long&lt;/code&gt; 값 의 최하위 8 비트는 이 &lt;code&gt;Byte&lt;/code&gt; 값 의 비트와 동일 하지만 최상위 56 비트는이 값의 부호 비트로 채워집니다.</target>
        </trans-unit>
        <trans-unit id="f2986e4bdb9623eb7b0be806904f6c45008e66a1" translate="yes" xml:space="preserve">
          <source>The least significant 8 bits of the resulting &lt;code&gt;Long&lt;/code&gt; value are the same as the bits of this &lt;code&gt;UByte&lt;/code&gt; value, whereas the most significant 56 bits are filled with zeros.</source>
          <target state="translated">결과 &lt;code&gt;Long&lt;/code&gt; 값 의 최하위 8 비트는 이 &lt;code&gt;UByte&lt;/code&gt; 값 의 비트와 동일 하지만 최상위 56 비트는 0으로 채워집니다.</target>
        </trans-unit>
        <trans-unit id="da411f42fa8b3bbe7fd6d9ed1a7edbedcead90c8" translate="yes" xml:space="preserve">
          <source>The least significant 8 bits of the resulting &lt;code&gt;Short&lt;/code&gt; value are the same as the bits of this &lt;code&gt;Byte&lt;/code&gt; value, whereas the most significant 8 bits are filled with the sign bit of this value.</source>
          <target state="translated">결과 &lt;code&gt;Short&lt;/code&gt; 값 의 최하위 8 비트는 이 &lt;code&gt;Byte&lt;/code&gt; 값 의 비트와 동일 하지만 최상위 8 비트는이 값의 부호 비트로 채워집니다.</target>
        </trans-unit>
        <trans-unit id="dbca88370b969aea0b645fa67d458151bf144ef3" translate="yes" xml:space="preserve">
          <source>The least significant 8 bits of the resulting &lt;code&gt;Short&lt;/code&gt; value are the same as the bits of this &lt;code&gt;UByte&lt;/code&gt; value, whereas the most significant 8 bits are filled with zeros.</source>
          <target state="translated">결과 &lt;code&gt;Short&lt;/code&gt; 값 의 최하위 8 비트는 이 &lt;code&gt;UByte&lt;/code&gt; 값 의 비트와 동일 하지만 최상위 8 비트는 0으로 채워집니다.</target>
        </trans-unit>
        <trans-unit id="0705f7403c9d4340ca48e777c703d467c71d6c8f" translate="yes" xml:space="preserve">
          <source>The least significant 8 bits of the resulting &lt;code&gt;UInt&lt;/code&gt; value are the same as the bits of this &lt;code&gt;Byte&lt;/code&gt; value, whereas the most significant 24 bits are filled with the sign bit of this value.</source>
          <target state="translated">결과 &lt;code&gt;UInt&lt;/code&gt; 값 의 최하위 8 비트는 이 &lt;code&gt;Byte&lt;/code&gt; 값 의 비트와 동일 하지만 최상위 24 비트는이 값의 부호 비트로 채워집니다.</target>
        </trans-unit>
        <trans-unit id="e35a3b71a791931b3596ab2bd1edb46d9365dda1" translate="yes" xml:space="preserve">
          <source>The least significant 8 bits of the resulting &lt;code&gt;UInt&lt;/code&gt; value are the same as the bits of this &lt;code&gt;UByte&lt;/code&gt; value, whereas the most significant 24 bits are filled with zeros.</source>
          <target state="translated">결과 &lt;code&gt;UInt&lt;/code&gt; 값 의 최하위 8 비트는 이 &lt;code&gt;UByte&lt;/code&gt; 값 의 비트와 동일 하지만 최상위 24 비트는 0으로 채워집니다.</target>
        </trans-unit>
        <trans-unit id="fbe359060636f5088c741be0b327d7d46254bbcd" translate="yes" xml:space="preserve">
          <source>The least significant 8 bits of the resulting &lt;code&gt;ULong&lt;/code&gt; value are the same as the bits of this &lt;code&gt;Byte&lt;/code&gt; value, whereas the most significant 56 bits are filled with the sign bit of this value.</source>
          <target state="translated">결과 &lt;code&gt;ULong&lt;/code&gt; 값 의 최하위 8 비트는 이 &lt;code&gt;Byte&lt;/code&gt; 값 의 비트와 동일 하지만 최상위 56 비트는이 값의 부호 비트로 채워집니다.</target>
        </trans-unit>
        <trans-unit id="9d9c37d2ab226e9ed58e44937eac9a5c2afe8841" translate="yes" xml:space="preserve">
          <source>The least significant 8 bits of the resulting &lt;code&gt;ULong&lt;/code&gt; value are the same as the bits of this &lt;code&gt;UByte&lt;/code&gt; value, whereas the most significant 56 bits are filled with zeros.</source>
          <target state="translated">결과 &lt;code&gt;ULong&lt;/code&gt; 값 의 최하위 8 비트는 이 &lt;code&gt;UByte&lt;/code&gt; 값 의 비트와 동일 하지만 최상위 56 비트는 0으로 채워집니다.</target>
        </trans-unit>
        <trans-unit id="573a497b93bab09d8947aa89f58fd5f36237628f" translate="yes" xml:space="preserve">
          <source>The least significant 8 bits of the resulting &lt;code&gt;UShort&lt;/code&gt; value are the same as the bits of this &lt;code&gt;Byte&lt;/code&gt; value, whereas the most significant 8 bits are filled with the sign bit of this value.</source>
          <target state="translated">결과 &lt;code&gt;UShort&lt;/code&gt; 값 의 최하위 8 비트는 이 &lt;code&gt;Byte&lt;/code&gt; 값 의 비트와 동일 하지만 최상위 8 비트는이 값의 부호 비트로 채워집니다.</target>
        </trans-unit>
        <trans-unit id="d49f6edce25857427bee05e2a6463c8f203f6aab" translate="yes" xml:space="preserve">
          <source>The least significant 8 bits of the resulting &lt;code&gt;UShort&lt;/code&gt; value are the same as the bits of this &lt;code&gt;UByte&lt;/code&gt; value, whereas the most significant 8 bits are filled with zeros.</source>
          <target state="translated">결과 &lt;code&gt;UShort&lt;/code&gt; 값 의 최하위 8 비트는 이 &lt;code&gt;UByte&lt;/code&gt; 값 의 비트와 동일 하지만 최상위 8 비트는 0으로 채워집니다.</target>
        </trans-unit>
        <trans-unit id="1511f8695777128c7450dc6f9cc52fbdbfc512c7" translate="yes" xml:space="preserve">
          <source>The less obvious cases that belong to the &quot;grey area&quot; include handling corner cases differently, throwing an exception of a different type than before, changing behavior observable only through reflection, changes in undocumented/undefined behavior, renaming binary artifacts, etc. Sometimes such changes are very important and affect migration experience dramatically, sometimes they are insignificant.</source>
          <target state="translated">&quot;회색 영역&quot;에 속하는 덜 명백한 경우에는 코너 케이스를 다르게 처리하고, 이전과 다른 유형의 예외를 던지거나, 리플렉션을 통해서만 관찰 가능한 동작 변경, 문서화되지 않은 / 정의되지 않은 동작의 변경, 이진 아티팩트 이름 바꾸기 등이 있습니다. 변경은 매우 중요하며 마이그레이션 환경에 큰 영향을 미치며 때로는 중요하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="dd894256ff253457e13d98fae75ab576481e876c" translate="yes" xml:space="preserve">
          <source>The library format</source>
          <target state="translated">라이브러리 형식</target>
        </trans-unit>
        <trans-unit id="c48fdef888f67d5a66f513cae58be8d045c058e0" translate="yes" xml:space="preserve">
          <source>The library has been created in the current directory:</source>
          <target state="translated">라이브러리는 현재 디렉토리에 작성되었습니다.</target>
        </trans-unit>
        <trans-unit id="cff219119dad603b83453d082db1d0aa5cce3800" translate="yes" xml:space="preserve">
          <source>The lines returned do not include terminating line separators.</source>
          <target state="translated">반환 된 줄에는 종료 줄 구분 기호가 포함되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="ecc031fda17a51efc3a0c6e7f3483a236bf69e52" translate="yes" xml:space="preserve">
          <source>The list of immediate supertypes of this class, in the order they are listed in the source code.</source>
          <target state="translated">이 클래스의 직속 슈퍼 타입 목록은 소스 코드에 나열된 순서대로 나열됩니다.</target>
        </trans-unit>
        <trans-unit id="e7cfcc4e5ebb2fa63d0c44bdcf02351c03c9e8d4" translate="yes" xml:space="preserve">
          <source>The list of the immediate subclasses if this class is a sealed class, or an empty list otherwise.</source>
          <target state="translated">이 클래스가 봉인 된 클래스 인 경우 직접 서브 클래스의 목록이거나 그렇지 않은 경우 빈 목록입니다.</target>
        </trans-unit>
        <trans-unit id="af028a3423820dfb61266857373312e6321072a9" translate="yes" xml:space="preserve">
          <source>The list of type parameters of this callable.</source>
          <target state="translated">이 호출 가능의 유형 매개 변수 목록입니다.</target>
        </trans-unit>
        <trans-unit id="3983145b3c17efebd4ca1c3dd6839e784929aaa8" translate="yes" xml:space="preserve">
          <source>The list of type parameters of this class. This list does &lt;em&gt;not&lt;/em&gt; include type parameters of outer classes.</source>
          <target state="translated">이 클래스의 타입 파라미터의리스트입니다. 이 목록에는 외부 클래스의 유형 매개 변수가 포함 되지 &lt;em&gt;않습니다&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="7dd6f3d5d8e8c83c9d11a7ed45e7362cc872b1a5" translate="yes" xml:space="preserve">
          <source>The locking in this example is fine-grained, so it pays the price. However, it is a good choice for some situations where you absolutely must modify some shared state periodically, but there is no natural thread that this state is confined to.</source>
          <target state="translated">이 예제의 잠금은 세밀하게 구성되어 있으므로 가격을 지불합니다. 그러나 일부 공유 상태를 주기적으로 절대적으로 수정해야하지만이 상태가 제한되는 자연스러운 스레드는없는 일부 상황에 적합합니다.</target>
        </trans-unit>
        <trans-unit id="993a245cc6dcc5a6d2356a7f7d1259d26b6ea137" translate="yes" xml:space="preserve">
          <source>The loop variable(s), if any, must be declared outside of the &lt;code&gt;while&lt;/code&gt; loop, and are therefore available for inspection afterwards, at which point they will contain the value(s) that made the loop condition false.</source>
          <target state="translated">루프 변수 (있는 경우)는 &lt;code&gt;while&lt;/code&gt; 루프 외부에서 선언해야하며 이후에 검사에 사용할 수 있으며이 시점에서 루프 조건을 거짓으로 만든 값이 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="f10abe77e5b16e3b7aa73cabd19e9ac919e5868d" translate="yes" xml:space="preserve">
          <source>The main code is straightforward:</source>
          <target state="translated">기본 코드는 간단합니다.</target>
        </trans-unit>
        <trans-unit id="21b17843ae6bab256e1f2d7c26e40966048480db" translate="yes" xml:space="preserve">
          <source>The main code starts and connects the whole pipeline:</source>
          <target state="translated">기본 코드는 전체 파이프 라인을 시작하고 연결합니다.</target>
        </trans-unit>
        <trans-unit id="1415e580114f63d99c0e8622a1104c3c733c68ba" translate="yes" xml:space="preserve">
          <source>The main disadvantage of changing the code style in an existing project is that the blame/annotate VCS feature will point to irrelevant commits more often. While each VCS has some kind of way to deal with this problem (&lt;a href=&quot;https://www.jetbrains.com/help/idea/investigate-changes.html&quot;&gt;&quot;Annotate Previous Revision&quot;&lt;/a&gt; can be used in IntelliJ IDEA), it's important to decide if a new style is worth all the effort. The practice of separating reformatting commits from meaningful changes can help a lot with later investigations.</source>
          <target state="translated">기존 프로젝트에서 코드 스타일을 변경하는 주된 단점은 VCS 기능에 대한 책임 / 주석이 관련없는 커밋을 더 자주 지적한다는 것입니다. 각 VCS에는이 문제를 처리 할 수있는 방법이 있지만 ( &lt;a href=&quot;https://www.jetbrains.com/help/idea/investigate-changes.html&quot;&gt;&quot;&lt;/a&gt; IntelliJ IDEA에서 &quot;주석 수정 주석 &quot;을 사용할 수 있음) 새로운 스타일이 모든 노력에 가치가 있는지 여부를 결정하는 것이 중요합니다. 재 포맷 커밋을 의미있는 변경과 분리하면 나중에 조사 할 때 많은 도움이 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f0255c27371bb337a0275ae99c66e66aefbb2cf2" translate="yes" xml:space="preserve">
          <source>The main function just launches a coroutine to print results of &lt;code&gt;switchMapDeferreds&lt;/code&gt; and sends some test data to it:</source>
          <target state="translated">메인 함수는 코 루틴을 시작하여 &lt;code&gt;switchMapDeferreds&lt;/code&gt; 의 결과를 인쇄 하고 테스트 데이터를 보냅니다.</target>
        </trans-unit>
        <trans-unit id="c0a11bc5688f898de97456dfcb543cf05d79b8a1" translate="yes" xml:space="preserve">
          <source>The main thread (that runs the &lt;code&gt;main()&lt;/code&gt; function) must wait until our coroutine completes, otherwise the program ends before &lt;code&gt;Hello&lt;/code&gt; is printed.</source>
          <target state="translated">메인 스레드 ( &lt;code&gt;main()&lt;/code&gt; 함수 를 실행하는 )는 코 루틴이 완료 될 때까지 기다려야합니다. 그렇지 않으면 &lt;code&gt;Hello&lt;/code&gt; 가 인쇄 되기 전에 프로그램이 종료됩니다 .</target>
        </trans-unit>
        <trans-unit id="2c831066dd6087f2516b15d01bfb68e39b9bcf05" translate="yes" xml:space="preserve">
          <source>The maximum number of substrings to return. Zero by default means no limit is set.</source>
          <target state="translated">반환 할 최대 부분 문자열 수입니다. 기본적으로 0은 제한이 설정되지 않았 음을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="4e76f165176d7e28c6b59c285a7ee8af5a71fc72" translate="yes" xml:space="preserve">
          <source>The maximum radix available for conversion to and from strings.</source>
          <target state="translated">문자열로 /에서 변환 할 수있는 최대 기수입니다.</target>
        </trans-unit>
        <trans-unit id="38f9246447f2685e9dd36b4c8d7e0bf7ff2fb023" translate="yes" xml:space="preserve">
          <source>The maximum value in the range (inclusive).</source>
          <target state="translated">범위 내 최대 값입니다 (포함).</target>
        </trans-unit>
        <trans-unit id="cc9397547e8b9fc8e2131246f8cce9b80a975147" translate="yes" xml:space="preserve">
          <source>The maximum value of a Unicode code point. Kotlin/Native specific.</source>
          <target state="translated">유니 코드 코드 포인트의 최대 값 코 틀린 / 네이티브 전용.</target>
        </trans-unit>
        <trans-unit id="af496c450bf387c2b7d7ee0dc32c766b9f1b66c1" translate="yes" xml:space="preserve">
          <source>The maximum value of a Unicode high-surrogate code unit.</source>
          <target state="translated">유니 코드 상위 대리 코드 단위의 최대 값입니다.</target>
        </trans-unit>
        <trans-unit id="68f9d655dde4db0c3b71fc09c97d0f87e103d52b" translate="yes" xml:space="preserve">
          <source>The maximum value of a Unicode low-surrogate code unit.</source>
          <target state="translated">유니 코드 낮은 대리 코드 단위의 최대 값입니다.</target>
        </trans-unit>
        <trans-unit id="0cb5887284a08dd04202e0863d133d8ed431392d" translate="yes" xml:space="preserve">
          <source>The maximum value of a Unicode surrogate code unit.</source>
          <target state="translated">유니 코드 대리 코드 단위의 최대 값입니다.</target>
        </trans-unit>
        <trans-unit id="ea009c16dc0030623058aff99eec7f7c7973366c" translate="yes" xml:space="preserve">
          <source>The maximum value of a character code unit.</source>
          <target state="translated">문자 코드 단위의 최대 값입니다.</target>
        </trans-unit>
        <trans-unit id="dce9edb79f3aca5450e6dfb555e231182e2c5340" translate="yes" xml:space="preserve">
          <source>The meaning of a visibility modifier depends on whether it's applied to a top-level declaration or to a declaration inside a class. For top-level declarations:</source>
          <target state="translated">가시성 수정 자의 의미는 최상위 선언에 적용되는지 또는 클래스 내부의 선언에 적용되는지에 따라 다릅니다. 최상위 선언의 경우 :</target>
        </trans-unit>
        <trans-unit id="2f5715d8d7aab68289e0b8a47e46f1764f30f76e" translate="yes" xml:space="preserve">
          <source>The message explaining the deprecation and recommending an alternative API to use.</source>
          <target state="translated">지원 중단을 설명하고 사용할 대체 API를 권장하는 메시지입니다.</target>
        </trans-unit>
        <trans-unit id="1d7af1b2ed876762350f57904a38e801662ebbf4" translate="yes" xml:space="preserve">
          <source>The meta-runner for Kotlin is available on &lt;a href=&quot;https://github.com/jonnyzzz/Kotlin.TeamCity&quot;&gt;GitHub&lt;/a&gt;. If using TeamCity 9 or above, we can now simply import that meta-runner from the TeamCity user interface</source>
          <target state="translated">Kotlin의 메타 러너는 &lt;a href=&quot;https://github.com/jonnyzzz/Kotlin.TeamCity&quot;&gt;GitHub에서&lt;/a&gt; 사용할 수 있습니다 . TeamCity 9 이상을 사용하는 경우 TeamCity 사용자 인터페이스에서 해당 메타 러너를 간단히 가져올 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="cbb5d37dc4d790a9dba2a103cd7fc2ea1af9db2f" translate="yes" xml:space="preserve">
          <source>The minimum radix available for conversion to and from strings.</source>
          <target state="translated">문자열로 /에서 변환 할 수있는 최소 기수입니다.</target>
        </trans-unit>
        <trans-unit id="3eb6b21e0f2a2eb117e5ca90292e6def24614862" translate="yes" xml:space="preserve">
          <source>The minimum value in the range.</source>
          <target state="translated">범위의 최소값입니다.</target>
        </trans-unit>
        <trans-unit id="480df25e783a3ddb0c5eabcc07d40b9a21fd328e" translate="yes" xml:space="preserve">
          <source>The minimum value of a Unicode code point. Kotlin/Native specific.</source>
          <target state="translated">유니 코드 코드 포인트의 최소값입니다. 코 틀린 / 네이티브 전용.</target>
        </trans-unit>
        <trans-unit id="c11b4b4a4cfd50662da801109ced72e7ef8083ad" translate="yes" xml:space="preserve">
          <source>The minimum value of a Unicode high-surrogate code unit.</source>
          <target state="translated">유니 코드 상위 대리 코드 단위의 최소값입니다.</target>
        </trans-unit>
        <trans-unit id="7a57e546e08f3cd66a3ed8cebd57f37a4137a78d" translate="yes" xml:space="preserve">
          <source>The minimum value of a Unicode low-surrogate code unit.</source>
          <target state="translated">유니 코드 낮은 대리 코드 단위의 최소값입니다.</target>
        </trans-unit>
        <trans-unit id="47b523f1a39e9c9f7bda17fc85b300ab3e0da311" translate="yes" xml:space="preserve">
          <source>The minimum value of a Unicode surrogate code unit.</source>
          <target state="translated">유니 코드 대리 코드 단위의 최소값입니다.</target>
        </trans-unit>
        <trans-unit id="e3fc4d1ab4988e695801daf57bd33d3f470c3668" translate="yes" xml:space="preserve">
          <source>The minimum value of a character code unit.</source>
          <target state="translated">문자 코드 단위의 최소값입니다.</target>
        </trans-unit>
        <trans-unit id="d80a9d6c0ddeb1216ece2df4cc2d7d63382408e4" translate="yes" xml:space="preserve">
          <source>The minimum value of a supplementary code point, &lt;code&gt;\u0x10000&lt;/code&gt;. Kotlin/Native specific.</source>
          <target state="translated">보조 코드 포인트의 최소값, &lt;code&gt;\u0x10000&lt;/code&gt; . 코 틀린 / 네이티브 전용.</target>
        </trans-unit>
        <trans-unit id="39042f06ab046e1bfc15de4ecf52d5a28eec3294" translate="yes" xml:space="preserve">
          <source>The modifier can be used on &lt;code&gt;var&lt;/code&gt; properties declared inside the body of a class (not in the primary constructor, and only when the property does not have a custom getter or setter) and, since Kotlin 1.2, for top-level properties and local variables. The type of the property or variable must be non-null, and it must not be a primitive type.</source>
          <target state="translated">이 수정자는 클래스 본문 내부에 선언 된 &lt;code&gt;var&lt;/code&gt; 속성 (기본 생성자가 아닌 속성에 사용자 지정 getter 또는 setter가없는 경우에만) 및 Kotlin 1.2부터 최상위 속성 및 로컬 변수에 사용할 수 있습니다. . 특성 또는 변수의 유형은 널이 아니어야하며 기본 유형이 아니어야합니다.</target>
        </trans-unit>
        <trans-unit id="bb919d11f95900a1425b0a32e4257389d1fc669f" translate="yes" xml:space="preserve">
          <source>The most &quot;natural&quot; placement is in the object &lt;code&gt;nativeHeap&lt;/code&gt;. It corresponds to allocating native memory with &lt;code&gt;malloc&lt;/code&gt; and provides an additional &lt;code&gt;.free()&lt;/code&gt; operation to free allocated memory:</source>
          <target state="translated">가장 자연스러운 위치는 &lt;code&gt;nativeHeap&lt;/code&gt; 객체에 있습니다 . &lt;code&gt;malloc&lt;/code&gt; 에 기본 메모리를 할당하는 것에 해당하며 할당 된 메모리를 해제하기 위해 추가 &lt;code&gt;.free()&lt;/code&gt; 작업을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="0d14eba091c54d0c22e0562741651e98077e032c" translate="yes" xml:space="preserve">
          <source>The most basic reflection feature is getting the runtime reference to a Kotlin class. To obtain the reference to a statically known Kotlin class, you can use the &lt;em&gt;class literal&lt;/em&gt; syntax:</source>
          <target state="translated">가장 기본적인 리플렉션 기능은 Kotlin 클래스에 대한 런타임 참조를 얻는 것입니다. 정적으로 알려진 Kotlin 클래스에 대한 참조를 얻으려면 &lt;em&gt;클래스 리터럴&lt;/em&gt; 구문을 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="ae0dbb4ff6b4fc6cc9b694111494978916ff6daf" translate="yes" xml:space="preserve">
          <source>The most basic usage of enum classes is implementing type-safe enums:</source>
          <target state="translated">열거 형 클래스의 가장 기본적인 사용법은 형식 안전 열거 형을 구현하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="564a165b2993e039b868e117559d08b7cdc98e88" translate="yes" xml:space="preserve">
          <source>The most common kind of properties simply reads from (and maybe writes to) a backing field. On the other hand, with custom getters and setters one can implement any behaviour of a property. Somewhere in between, there are certain common patterns of how a property may work. A few examples: lazy values, reading from a map by a given key, accessing a database, notifying listener on access, etc.</source>
          <target state="translated">가장 일반적인 종류의 속성은 단순히 지원 필드에서 읽거나 쓸 수 있습니다. 반면에 커스텀 게터와 세터를 사용하면 속성의 모든 동작을 구현할 수 있습니다. 그 사이 어딘가에는 속성이 작동하는 방식에 대한 일반적인 패턴이 있습니다. 몇 가지 예 : 게으른 값, 주어진 키로 맵에서 읽기, 데이터베이스에 액세스, 리스너에게 액세스에 알리기 등</target>
        </trans-unit>
        <trans-unit id="d5cbdfb8e81de653dd867a75b87523ff1d242141" translate="yes" xml:space="preserve">
          <source>The most common type of constraint is an &lt;strong&gt;upper bound&lt;/strong&gt; that corresponds to Java's &lt;em&gt;extends&lt;/em&gt; keyword:</source>
          <target state="translated">가장 일반적인 제약 유형은 Java의 &lt;em&gt;extends&lt;/em&gt; 키워드에 해당 하는 &lt;strong&gt;상한&lt;/strong&gt; 입니다 .&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="368d747cfcb5fb4e353c85a7469dfacbb5453495" translate="yes" xml:space="preserve">
          <source>The most common way to create a collection is with the standard library functions &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/list-of&quot;&gt;&lt;code&gt;listOf&amp;lt;T&amp;gt;()&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/set-of&quot;&gt;&lt;code&gt;setOf&amp;lt;T&amp;gt;()&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/mutable-list-of&quot;&gt;&lt;code&gt;mutableListOf&amp;lt;T&amp;gt;()&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/mutable-set-of&quot;&gt;&lt;code&gt;mutableSetOf&amp;lt;T&amp;gt;()&lt;/code&gt;&lt;/a&gt;. If you provide a comma-separated list of collection elements as arguments, the compiler detects the element type automatically. When creating empty collections, specify the type explicitly.</source>
          <target state="translated">컬렉션을 만드는 가장 일반적인 방법은 표준 라이브러리 함수 &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/list-of&quot;&gt; &lt;code&gt;listOf&amp;lt;T&amp;gt;()&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/set-of&quot;&gt; &lt;code&gt;setOf&amp;lt;T&amp;gt;()&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/mutable-list-of&quot;&gt; &lt;code&gt;mutableListOf&amp;lt;T&amp;gt;()&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/mutable-set-of&quot;&gt; &lt;code&gt;mutableSetOf&amp;lt;T&amp;gt;()&lt;/code&gt; &lt;/a&gt; 입니다. 쉼표로 구분 된 컬렉션 요소 목록을 인수로 제공하면 컴파일러는 요소 유형을 자동으로 감지합니다. 빈 모음을 만들 때는 유형을 명시 적으로 지정하십시오.</target>
        </trans-unit>
        <trans-unit id="b853cf446ccffab0ecfd031a6ec9cd9f7555703c" translate="yes" xml:space="preserve">
          <source>The most notable change is in the continuation indentation policy. There's a nice idea to use the double indent for showing that a multi-line expression hasn't ended on the previous line. This is a very simple and general rule, but several Kotlin constructions look a bit awkward when they are formatted this way. In Kotlin Coding Conventions it's recommended to use a single indent in cases where the long continuation indent has been forced before</source>
          <target state="translated">가장 눈에 띄는 변화는 연속 들여 쓰기 정책입니다. 여러 줄로 된 표현식이 이전 줄에서 끝나지 않았 음을 보여주기 위해 이중 들여 쓰기를 사용하는 것이 좋습니다. 이것은 매우 간단하고 일반적인 규칙이지만 여러 Kotlin 구조는 이러한 방식으로 형식이 지정되면 약간 어색해 보입니다. Kotlin Coding Conventions에서는 이전에 긴 연속 들여 쓰기를 강요 한 경우 단일 들여 쓰기를 사용하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="e8c58687aab400a3400843ec6513c56c72bdb694" translate="yes" xml:space="preserve">
          <source>The most obvious practical reason to cancel execution of a coroutine is because its execution time has exceeded some timeout. While you can manually track the reference to the corresponding &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-job/index.html&quot;&gt;Job&lt;/a&gt; and launch a separate coroutine to cancel the tracked one after delay, there is a ready to use &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/with-timeout.html&quot;&gt;withTimeout&lt;/a&gt; function that does it. Look at the following example:</source>
          <target state="translated">코 루틴 실행을 취소하는 가장 확실한 실제 이유는 실행 시간이 시간 초과를 초과했기 때문입니다. 해당 &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-job/index.html&quot;&gt;작업에&lt;/a&gt; 대한 참조를 수동으로 추적하고 별도의 코 루틴을 실행하여 지연된 후 추적 된 것을 취소 할 수는 있지만이를 수행 할 수있는 &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/with-timeout.html&quot;&gt;with timeout&lt;/a&gt; 기능이 있습니다. 다음 예를보십시오.</target>
        </trans-unit>
        <trans-unit id="d08f23af81c5dad7c4dca8d8027b602b0ab864b4" translate="yes" xml:space="preserve">
          <source>The most peculiar feature of &lt;code&gt;dynamic&lt;/code&gt; is that we are allowed to call &lt;strong&gt;any&lt;/strong&gt; property or function with any parameters on a &lt;code&gt;dynamic&lt;/code&gt; variable:</source>
          <target state="translated">의 가장 독특한 기능 &lt;code&gt;dynamic&lt;/code&gt; 우리가 전화를 허용한다는 것입니다 &lt;strong&gt;어떤&lt;/strong&gt; A의 매개 변수와 속성이나 기능 &lt;code&gt;dynamic&lt;/code&gt; 변수를 :</target>
        </trans-unit>
        <trans-unit id="3c05df95cb8e9db1a4f2601246ac944d5c8bd276" translate="yes" xml:space="preserve">
          <source>The multiplatform projects and multiplatform libraries are discussed in the &lt;a href=&quot;../../reference/multiplatform&quot;&gt;documentation&lt;/a&gt; too.</source>
          <target state="translated">멀티 플랫폼 프로젝트 및 멀티 플랫폼 라이브러리는 &lt;a href=&quot;../../reference/multiplatform&quot;&gt;문서&lt;/a&gt; 에서도 설명합니다 .</target>
        </trans-unit>
        <trans-unit id="6595e5fe1547363b463835d421622aad398ae9cc" translate="yes" xml:space="preserve">
          <source>The name contains the following parts (some of them may be empty):</source>
          <target state="translated">이름에는 다음과 같은 부분이 포함됩니다 (일부는 비어있을 수 있음).</target>
        </trans-unit>
        <trans-unit id="705b141c8de1d697224950845ea5a1b7afb58d54" translate="yes" xml:space="preserve">
          <source>The name of a class is usually a noun or a noun phrase explaining what the class &lt;em&gt;is&lt;/em&gt;: &lt;code&gt;List&lt;/code&gt;, &lt;code&gt;PersonReader&lt;/code&gt;.</source>
          <target state="translated">클래스의 이름은 일반적으로 클래스가 무엇인지 설명하는 명사 또는 명사구 &lt;em&gt;입니다&lt;/em&gt; . &lt;code&gt;List&lt;/code&gt; , &lt;code&gt;PersonReader&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2218455df585d83e3681475aae4631f54b57ae59" translate="yes" xml:space="preserve">
          <source>The name of a class used by itself (not as a qualifier to another name) acts as a reference to the companion object of the class (whether named or not):</source>
          <target state="translated">다른 이름의 한정자가 아닌 자체적으로 사용되는 클래스 이름은 클래스의 동반 객체에 대한 참조 역할을합니다 (이름 지정 여부에 관계없이).</target>
        </trans-unit>
        <trans-unit id="07fe46086dbe239fd375c49037bb37bff00ee0c4" translate="yes" xml:space="preserve">
          <source>The name of a method is usually a verb or a verb phrase saying what the method &lt;em&gt;does&lt;/em&gt;: &lt;code&gt;close&lt;/code&gt;, &lt;code&gt;readPersons&lt;/code&gt;. The name should also suggest if the method is mutating the object or returning a new one. For instance &lt;code&gt;sort&lt;/code&gt; is sorting a collection in place, while &lt;code&gt;sorted&lt;/code&gt; is returning a sorted copy of the collection.</source>
          <target state="translated">방법의 이름은 일반적으로 동사 또는 방법은 무엇을 말하는 동사 구문입니다 &lt;em&gt;않습니다&lt;/em&gt; : &lt;code&gt;close&lt;/code&gt; , &lt;code&gt;readPersons&lt;/code&gt; . 이름은 또한 메소드가 오브젝트를 변경하거나 새 오브젝트를 리턴하는지 제안해야합니다. 예를 들어 &lt;code&gt;sort&lt;/code&gt; 는 컬렉션을 제자리에 정렬하는 반면 &lt;code&gt;sorted&lt;/code&gt; 는 컬렉션의 정렬 된 복사본을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="07c434a5d635392f2cc52f562338d62b0cd9ae9a" translate="yes" xml:space="preserve">
          <source>The name of the companion object can be omitted, in which case the name &lt;code&gt;Companion&lt;/code&gt; will be used:</source>
          <target state="translated">컴패니언 객체의 이름은 생략 할 수 있으며,이 경우 &lt;code&gt;Companion&lt;/code&gt; 이름 이 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="ba35193d0490ae1490a81583acf93693abaa382e" translate="yes" xml:space="preserve">
          <source>The name of the file should describe what the code in the file does. Therefore, you should avoid using meaningless words such as &quot;Util&quot; in file names.</source>
          <target state="translated">파일 이름은 파일의 코드가 수행하는 작업을 설명해야합니다. 따라서 파일 이름에 &quot;Util&quot;과 같은 의미없는 단어를 사용하지 않아야합니다.</target>
        </trans-unit>
        <trans-unit id="3aecf5d5ce4130f99667312567cec868e0f727ee" translate="yes" xml:space="preserve">
          <source>The name of the generated Java class can be changed using the &lt;code&gt;@JvmName&lt;/code&gt; annotation:</source>
          <target state="translated">생성 된 Java 클래스의 이름은 &lt;code&gt;@JvmName&lt;/code&gt; 주석을 사용하여 변경할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="c5f1bfd2676f7023c48bd8f681608f158236c940" translate="yes" xml:space="preserve">
          <source>The name of the target (if specified) or the project</source>
          <target state="translated">대상 (지정된 경우) 또는 프로젝트의 이름</target>
        </trans-unit>
        <trans-unit id="cbba3c187c456ab45b79f8154b1183097b8b2546" translate="yes" xml:space="preserve">
          <source>The name of this callable as it was declared in the source code. If the callable has no name, a special invented name is created. Nameless callables include:</source>
          <target state="translated">소스 코드에서 선언 된이 호출 가능의 이름입니다. 호출 가능한 이름이 없으면 특별한 발명 된 이름이 만들어집니다. 이름없는 콜 러블은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="688bb052b4a717479ab8663cafb721fc37d4378a" translate="yes" xml:space="preserve">
          <source>The name of this type parameter as it was declared in the source code.</source>
          <target state="translated">소스 코드에서 선언 된이 유형 매개 변수의 이름입니다.</target>
        </trans-unit>
        <trans-unit id="25f073ea1bd96da303a6eb4e8f3418d2fb774887" translate="yes" xml:space="preserve">
          <source>The names of Kotlin classes and interfaces are prefixed when imported to Objective-C. The prefix is derived from the framework name.</source>
          <target state="translated">Kotlin 클래스 및 인터페이스 이름은 Objective-C로 가져올 때 접두사가 붙습니다. 접두사는 프레임 워크 이름에서 파생됩니다.</target>
        </trans-unit>
        <trans-unit id="69675486a4053839ac9b38d8b7b0c3ec7c01c08b" translate="yes" xml:space="preserve">
          <source>The names of the tasks in Android Projects contain the &lt;a href=&quot;https://developer.android.com/studio/build/build-variants.html&quot;&gt;build variant&lt;/a&gt; names and follow the pattern &lt;code&gt;compile&amp;lt;BuildVariant&amp;gt;Kotlin&lt;/code&gt;, for example, &lt;code&gt;compileDebugKotlin&lt;/code&gt;, &lt;code&gt;compileReleaseUnitTestKotlin&lt;/code&gt;.</source>
          <target state="translated">Android 프로젝트의 태스크 이름에는 &lt;a href=&quot;https://developer.android.com/studio/build/build-variants.html&quot;&gt;빌드 변형&lt;/a&gt; 이름이 포함되어 있으며 &lt;code&gt;compile&amp;lt;BuildVariant&amp;gt;Kotlin&lt;/code&gt; 패턴 ( 예 : &lt;code&gt;compileDebugKotlin&lt;/code&gt; , &lt;code&gt;compileReleaseUnitTestKotlin&lt;/code&gt; )을 따릅니다 .</target>
        </trans-unit>
        <trans-unit id="b01e22b1729a53f5c38e9b03b567bbe208d510c5" translate="yes" xml:space="preserve">
          <source>The names of these tasks were created from the formula: &lt;code&gt;run[Debug|Release]Executable&amp;lt;target name&amp;gt;&lt;/code&gt;, where &lt;code&gt;target name&lt;/code&gt; is the capitalized target name that we specified in the &lt;code&gt;build.gradle.kts&lt;/code&gt;&lt;code&gt;build.gradle&lt;/code&gt; file out of our build, &lt;code&gt;&quot;native&quot;&lt;/code&gt; in our case. Let's run the task in the IDE. For that, let's open the Gradle Tool Window and find the task in the list:</source>
          <target state="translated">이러한 작업의 이름은 다음 공식에서 작성되었습니다. &lt;code&gt;run[Debug|Release]Executable&amp;lt;target name&amp;gt;&lt;/code&gt; 여기서 &lt;code&gt;target name&lt;/code&gt; 은 빌드 에서 &lt;code&gt;build.gradle.kts&lt;/code&gt; &lt;code&gt;build.gradle&lt;/code&gt; 파일에 지정한 대문자로 된 대상 이름입니다 . 우리의 경우 &lt;code&gt;&quot;native&quot;&lt;/code&gt; . IDE에서 작업을 실행 해 봅시다. 이를 위해 Gradle Tool 창을 열고 목록에서 작업을 찾으십시오.</target>
        </trans-unit>
        <trans-unit id="f0aa5ea5557fedda4c5d2598dc5dd22d0363ac01" translate="yes" xml:space="preserve">
          <source>The names should make it clear what the purpose of the entity is, so it's best to avoid using meaningless words (&lt;code&gt;Manager&lt;/code&gt;, &lt;code&gt;Wrapper&lt;/code&gt; etc.) in names.</source>
          <target state="translated">이름은 엔티티의 목적이 무엇인지 명확히해야하므로 이름에 의미없는 단어 ( &lt;code&gt;Manager&lt;/code&gt; , &lt;code&gt;Wrapper&lt;/code&gt; 등)를 사용하지 않는 것이 가장 좋습니다 .</target>
        </trans-unit>
        <trans-unit id="73a31785499746e1755c5fd02e03d5e8b58c34d0" translate="yes" xml:space="preserve">
          <source>The native memory can be allocated using the &lt;code&gt;NativePlacement&lt;/code&gt; interface, e.g.</source>
          <target state="translated">네이티브 메모리는 &lt;code&gt;NativePlacement&lt;/code&gt; 인터페이스를 사용하여 할당 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="183994f4ebd6d698ee09d0ba15ca6b6ca68c9e19" translate="yes" xml:space="preserve">
          <source>The next lines are about providing linker and compiler options, which can vary depending on different target platforms. In our case, we are defining it for macOS (the &lt;code&gt;.osx&lt;/code&gt; suffix) and Linux (the &lt;code&gt;.linux&lt;/code&gt; suffix). Parameters without a suffix is also possible (e.g. &lt;code&gt;linkerOpts=&lt;/code&gt;) and will be applied to all platforms.</source>
          <target state="translated">다음 행은 링커 및 컴파일러 옵션을 제공하는 방법으로, 대상 플랫폼에 따라 달라질 수 있습니다. 우리의 경우, 우리는 맥 OS 위해를 정의합니다 ( &lt;code&gt;.osx&lt;/code&gt; 접미사)와 리눅스합니다 ( &lt;code&gt;.linux&lt;/code&gt; 접미사). 접미사가없는 매개 변수 (예 : &lt;code&gt;linkerOpts=&lt;/code&gt; ) 도 가능 하며 모든 플랫폼에 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="5a6c6de321d2f0ef15a3d35472d5a5225a93083f" translate="yes" xml:space="preserve">
          <source>The next part of the &lt;code&gt;&amp;lt;Framework&amp;gt;/Headers/Demo.h&lt;/code&gt; contains number type mappings between Kotlin/Native and &lt;code&gt;NSNumber&lt;/code&gt;. We have the base class called &lt;code&gt;DemoNumber&lt;/code&gt; in Objective-C and &lt;code&gt;KotlinNumber&lt;/code&gt; in Swift. It extends &lt;code&gt;NSNumber&lt;/code&gt;. There are also child classes per Kotlin number type:</source>
          <target state="translated">&lt;code&gt;&amp;lt;Framework&amp;gt;/Headers/Demo.h&lt;/code&gt; 의 다음 부분 에는 Kotlin / Native와 &lt;code&gt;NSNumber&lt;/code&gt; 사이의 숫자 유형 매핑이 포함되어 있습니다 . Objective-C에 &lt;code&gt;DemoNumber&lt;/code&gt; 라는 기본 클래스 와 Swift에 &lt;code&gt;KotlinNumber&lt;/code&gt; 가 있습니다. &lt;code&gt;NSNumber&lt;/code&gt; 를 확장 합니다. Kotlin 숫자 유형마다 하위 클래스가 있습니다.</target>
        </trans-unit>
        <trans-unit id="cfe4a47831305057cc6388a57b9e77a3a7e3a7a8" translate="yes" xml:space="preserve">
          <source>The next part of the &lt;code&gt;libnative_api.h&lt;/code&gt; file contains definitions of the types that are used in the library:</source>
          <target state="translated">&lt;code&gt;libnative_api.h&lt;/code&gt; 파일 의 다음 부분 에는 라이브러리에서 사용되는 유형의 정의가 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="dc72aec2231c401cec520bbf86ad2595019584f0" translate="yes" xml:space="preserve">
          <source>The next step is going to prompt us on the Kotlin runtime library. By default the plugin selects the one that is associated to the currently installed version. Unless we want to create a different one, we can click Finish at this point after entering the project name and location.</source>
          <target state="translated">다음 단계는 Kotlin 런타임 라이브러리에 대한 프롬프트입니다. 기본적으로 플러그인은 현재 설치된 버전과 관련된 플러그인을 선택합니다. 다른 것을 작성하지 않으려면 프로젝트 이름과 위치를 입력 한 후이 시점에서 Finish를 클릭하십시오.</target>
        </trans-unit>
        <trans-unit id="93716c2cabdff509bf9835ed635452819990ca4f" translate="yes" xml:space="preserve">
          <source>The next step is to call a C function pointer from a C pointer that we have from the &lt;code&gt;supply_fun()&lt;/code&gt; call:</source>
          <target state="translated">다음 단계는 &lt;code&gt;supply_fun()&lt;/code&gt; 호출 에서 가지고있는 C 포인터에서 C 함수 포인터를 호출하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="4c075c67c98b72698b50bde83417679cfcaad540" translate="yes" xml:space="preserve">
          <source>The next step is to compile our application. We already covered the basics of compiling a Kotlin/Native application from the command line in the &lt;a href=&quot;basic-kotlin-native-app&quot;&gt;A Basic Kotlin/Native application&lt;/a&gt; tutorial. The only difference in this case is that the &lt;code&gt;cinterop&lt;/code&gt; generated part is implicitly included into the build: Let's call the following command:</source>
          <target state="translated">다음 단계는 애플리케이션을 컴파일하는 것입니다. 우리는 이미 &lt;a href=&quot;basic-kotlin-native-app&quot;&gt;기본 Kotlin / Native 애플리케이션&lt;/a&gt; 튜토리얼 의 커맨드 라인에서 Kotlin / Native 애플리케이션을 컴파일하는 기본 사항을 다루었습니다 . 이 경우의 유일한 차이점은 &lt;code&gt;cinterop&lt;/code&gt; 생성 파트가 빌드에 내재적으로 포함 된다는 것입니다 . 다음 명령을 호출하십시오.</target>
        </trans-unit>
        <trans-unit id="29eb1a88978e11cb19e6153185329a8fdd184b9c" translate="yes" xml:space="preserve">
          <source>The next step is to create Greeting Data class that has two properties: &lt;em&gt;id&lt;/em&gt; and a &lt;em&gt;content&lt;/em&gt;</source>
          <target state="translated">다음 단계는 &lt;em&gt;id&lt;/em&gt; 와 &lt;em&gt;content&lt;/em&gt; 라는 두 가지 속성이있는 Greeting Data 클래스를 만드는 것입니다.&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="f2ba2b214cfaccb2ec50010bfe1a0d121ee2cd4b" translate="yes" xml:space="preserve">
          <source>The next step is to create a Run Configuration in IntelliJ IDEA under Tomcat / Local which deploys the WAR and starts up Tomcat.</source>
          <target state="translated">다음 단계는 Tomcat / Local 아래 IntelliJ IDEA에서 Run Configuration을 생성하여 WAR을 배포하고 Tomcat을 시작하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="27ce517e143c3dea9eb55849f860e4c5596ec3f9" translate="yes" xml:space="preserve">
          <source>The next step is to decide which modules to configure (if the project has more than one module) and whether you want to add the runtime library to the project or use those provided by the current Kotlin plugin.</source>
          <target state="translated">다음 단계는 구성 할 모듈 (프로젝트에 둘 이상의 모듈이있는 경우) 및 런타임 라이브러리를 프로젝트에 추가할지 또는 현재 Kotlin 플러그인에서 제공 한 모듈을 사용할지 여부를 결정하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="22779d3ccc120e4892af96a829245aa095780550" translate="yes" xml:space="preserve">
          <source>The non-abstract subclasses should represent the (complete) C data type and thus specify size and alignment. Each such subclass must have a companion object which is a &lt;a href=&quot;-type/index&quot;&gt;Type&lt;/a&gt;.</source>
          <target state="translated">비추 상 서브 클래스는 (완전한) C 데이터 유형을 나타내므로 크기와 정렬을 지정해야합니다. 이러한 각 서브 클래스는 &lt;a href=&quot;-type/index&quot;&gt;Type 인&lt;/a&gt; 도우미 객체를 가져야합니다 .</target>
        </trans-unit>
        <trans-unit id="fc28129df689ae65c9fd83a31b9aa03dac9e8ced" translate="yes" xml:space="preserve">
          <source>The non-breaking space character</source>
          <target state="translated">비 공백 공백 문자</target>
        </trans-unit>
        <trans-unit id="e8f00eeeaaa301ab094d387f05d45fa33541dead" translate="yes" xml:space="preserve">
          <source>The nullable version &lt;code&gt;Nothing?&lt;/code&gt; will be used by the compiler when something is initialized with null and there is no other type information. In &lt;code&gt;val x = null&lt;/code&gt;, the type of &lt;code&gt;x&lt;/code&gt; will be &lt;code&gt;Nothing?&lt;/code&gt;. This type does not have the &quot;never returns normally&quot; semantics; instead, the compiler knows that the value will always be null.</source>
          <target state="translated">nullable 버전이 &lt;code&gt;Nothing?&lt;/code&gt; 무언가가 null로 초기화되고 다른 유형 정보가 없을 때 컴파일러가 사용합니다. 에서 &lt;code&gt;val x = null&lt;/code&gt; 의 종류 &lt;code&gt;x&lt;/code&gt; 것 &lt;code&gt;Nothing?&lt;/code&gt; . 이 유형에는 &quot;정상적으로 리턴하지 않음&quot;의미가 없습니다. 대신 컴파일러는 값이 항상 null임을 알고 있습니다.</target>
        </trans-unit>
        <trans-unit id="77363aca1573dd5dba20e28ad666c9c7fd83436a" translate="yes" xml:space="preserve">
          <source>The number is converted to a string and then the string is converted to a &lt;a href=&quot;http://docs.oracle.com/javase/8/docs/api/java/math/BigDecimal.html&quot;&gt;BigDecimal&lt;/a&gt;.</source>
          <target state="translated">숫자는 문자열로 변환 된 다음 문자열은 &lt;a href=&quot;http://docs.oracle.com/javase/8/docs/api/java/math/BigDecimal.html&quot;&gt;BigDecimal로 변환&lt;/a&gt; 됩니다.</target>
        </trans-unit>
        <trans-unit id="bc9979a04405cfcd09395aa075f56f352dfb5b1c" translate="yes" xml:space="preserve">
          <source>The number of bits used to represent a Char in a binary form.</source>
          <target state="translated">Char를 이진 형식으로 나타내는 데 사용되는 비트 수입니다.</target>
        </trans-unit>
        <trans-unit id="a5aabbd23fb87b74097e1ccd4055f0b183ecbf87" translate="yes" xml:space="preserve">
          <source>The number of bits used to represent an instance of Byte in a binary form.</source>
          <target state="translated">Byte 인스턴스를 이진 형식으로 나타내는 데 사용되는 비트 수입니다.</target>
        </trans-unit>
        <trans-unit id="0f9c3201d4f3bb80740106fd705fe9901bfc9490" translate="yes" xml:space="preserve">
          <source>The number of bits used to represent an instance of Int in a binary form.</source>
          <target state="translated">Int 인스턴스를 이진 형식으로 나타내는 데 사용되는 비트 수입니다.</target>
        </trans-unit>
        <trans-unit id="881c588a79332a9f90d40c26e737596c51909376" translate="yes" xml:space="preserve">
          <source>The number of bits used to represent an instance of Long in a binary form.</source>
          <target state="translated">Long 인스턴스를 이진 형식으로 나타내는 데 사용되는 비트 수입니다.</target>
        </trans-unit>
        <trans-unit id="3a2fa986a400a5de2289aa09e08c447c811e1ab0" translate="yes" xml:space="preserve">
          <source>The number of bits used to represent an instance of Short in a binary form.</source>
          <target state="translated">이진 형식으로 Short 인스턴스를 나타내는 데 사용되는 비트 수입니다.</target>
        </trans-unit>
        <trans-unit id="b557b6ad22e0d4a32e6ecf5e7c42a83086397f62" translate="yes" xml:space="preserve">
          <source>The number of bits used to represent an instance of UByte in a binary form.</source>
          <target state="translated">이진 형식으로 UByte 인스턴스를 나타내는 데 사용되는 비트 수입니다.</target>
        </trans-unit>
        <trans-unit id="04a46c8fcf471f6f7a2489fd5541b67d79b2dbba" translate="yes" xml:space="preserve">
          <source>The number of bits used to represent an instance of UInt in a binary form.</source>
          <target state="translated">이진 형식으로 UInt 인스턴스를 나타내는 데 사용되는 비트 수입니다.</target>
        </trans-unit>
        <trans-unit id="970f51f6cf41ca82dcda9c5384dd1584581a3241" translate="yes" xml:space="preserve">
          <source>The number of bits used to represent an instance of ULong in a binary form.</source>
          <target state="translated">ULong 인스턴스를 이진 형식으로 나타내는 데 사용되는 비트 수입니다.</target>
        </trans-unit>
        <trans-unit id="f405dad940dd8a9ba9986616021e6669d81ef332" translate="yes" xml:space="preserve">
          <source>The number of bits used to represent an instance of UShort in a binary form.</source>
          <target state="translated">UShort 인스턴스를 이진 형식으로 나타내는 데 사용되는 비트 수입니다.</target>
        </trans-unit>
        <trans-unit id="7fca3ee96d6d11e61b4e40ce8aef39bbd3166f00" translate="yes" xml:space="preserve">
          <source>The number of bytes used to represent a Char in a binary form.</source>
          <target state="translated">Char를 이진 형식으로 나타내는 데 사용되는 바이트 수입니다.</target>
        </trans-unit>
        <trans-unit id="d455af0205d71a29c80b7797e96f36f72c818b20" translate="yes" xml:space="preserve">
          <source>The number of bytes used to represent an instance of Byte in a binary form.</source>
          <target state="translated">바이트 인스턴스를 이진 형식으로 나타내는 데 사용되는 바이트 수입니다.</target>
        </trans-unit>
        <trans-unit id="012737f61c97912b11277e0542ab793fcecbd8f6" translate="yes" xml:space="preserve">
          <source>The number of bytes used to represent an instance of Int in a binary form.</source>
          <target state="translated">Int 인스턴스를 이진 형식으로 나타내는 데 사용되는 바이트 수입니다.</target>
        </trans-unit>
        <trans-unit id="ac50dee558bf2179b63147e5d4abcf881946deb1" translate="yes" xml:space="preserve">
          <source>The number of bytes used to represent an instance of Long in a binary form.</source>
          <target state="translated">Long 인스턴스를 이진 형식으로 나타내는 데 사용되는 바이트 수입니다.</target>
        </trans-unit>
        <trans-unit id="d47711ab000d6ab309cdde940a4d6cc83958bbb7" translate="yes" xml:space="preserve">
          <source>The number of bytes used to represent an instance of Short in a binary form.</source>
          <target state="translated">이진 형식으로 Short 인스턴스를 나타내는 데 사용되는 바이트 수입니다.</target>
        </trans-unit>
        <trans-unit id="5da103d9bfe814cb16e570a63e8fffdec6abede9" translate="yes" xml:space="preserve">
          <source>The number of bytes used to represent an instance of UByte in a binary form.</source>
          <target state="translated">이진 형식으로 UByte 인스턴스를 나타내는 데 사용되는 바이트 수입니다.</target>
        </trans-unit>
        <trans-unit id="7aa018571731f4dfc20dc2f2b40bc661649fe4df" translate="yes" xml:space="preserve">
          <source>The number of bytes used to represent an instance of UInt in a binary form.</source>
          <target state="translated">이진 형식으로 UInt 인스턴스를 나타내는 데 사용되는 바이트 수입니다.</target>
        </trans-unit>
        <trans-unit id="c4d88684784d0b5692fee9bc8fbbdcbfde1bb159" translate="yes" xml:space="preserve">
          <source>The number of bytes used to represent an instance of ULong in a binary form.</source>
          <target state="translated">ULong 인스턴스를 이진 형식으로 나타내는 데 사용되는 바이트 수입니다.</target>
        </trans-unit>
        <trans-unit id="de97fd8a16a598b6d753acf6fc495d892600d39e" translate="yes" xml:space="preserve">
          <source>The number of bytes used to represent an instance of UShort in a binary form.</source>
          <target state="translated">UShort 인스턴스를 이진 형식으로 나타내는 데 사용되는 바이트 수입니다.</target>
        </trans-unit>
        <trans-unit id="802421b7bac6f95ce971296bce66f238a1ca7ee6" translate="yes" xml:space="preserve">
          <source>The official docs also have a very cool example with a &lt;a href=&quot;../../reference/type-safe-builders&quot;&gt; DSL for constructing HTML documents&lt;/a&gt;.</source>
          <target state="translated">공식 문서는 &lt;a href=&quot;../../reference/type-safe-builders&quot;&gt;HTML 문서를 구성하기위한 DSL&lt;/a&gt; 과 함께 아주 멋진 예를 가지고 있습니다 .</target>
        </trans-unit>
        <trans-unit id="9824ffa4fbac1aa2ba4df2857cc7d27ae42fbdf3" translate="yes" xml:space="preserve">
          <source>The only target for which it is not available is &lt;a href=&quot;https://en.wikipedia.org/wiki/WebAssembly&quot;&gt;WebAssembly&lt;/a&gt;.</source>
          <target state="translated">사용할 수없는 대상은 &lt;a href=&quot;https://en.wikipedia.org/wiki/WebAssembly&quot;&gt;WebAssembly&lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="20601b96604d0e7211b7510d021f94ac0577f4a7" translate="yes" xml:space="preserve">
          <source>The only thing left to do is compile our application (Build|Build Project), and once the JavaScript files have been generated, we can open the &lt;code&gt;index.html&lt;/code&gt; file in the browser and see the result in the console debug window.</source>
          <target state="translated">남은 것은 애플리케이션 (Build | Build Project)을 컴파일하는 것입니다. JavaScript 파일이 생성되면 브라우저에서 &lt;code&gt;index.html&lt;/code&gt; 파일을 열고 콘솔 디버그 창에서 결과를 볼 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="940b1bdb9d47159d1535cf808141916fc2b5f10e" translate="yes" xml:space="preserve">
          <source>The operation doesn't preserve copied file attributes such as creation/modification date, permissions, etc.</source>
          <target state="translated">작업은 생성 / 수정 날짜, 권한 등과 같은 복사 된 파일 속성을 유지하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="b9a452f893e9486c5fbe89e3c1a52b0da8c35684" translate="yes" xml:space="preserve">
          <source>The operation is &lt;em&gt;intermediate&lt;/em&gt; and &lt;em&gt;stateful&lt;/em&gt;.</source>
          <target state="translated">작업은 &lt;em&gt;중간 &lt;/em&gt;&lt;em&gt;상태&lt;/em&gt; 이며 &lt;em&gt;상태 저장&lt;/em&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="64f2d6f436a63697c12d9826dd0b449a2c8ece4d" translate="yes" xml:space="preserve">
          <source>The operation is &lt;em&gt;intermediate&lt;/em&gt; and &lt;em&gt;stateless&lt;/em&gt;.</source>
          <target state="translated">작업은 &lt;em&gt;중간 &lt;/em&gt;&lt;em&gt;상태&lt;/em&gt; 이며 &lt;em&gt;상태 비 저장&lt;/em&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="2f74c9f051d5d0a5178895ef9787aac4f50f4820" translate="yes" xml:space="preserve">
          <source>The operation is &lt;em&gt;intermediate&lt;/em&gt; for this sequence and &lt;em&gt;terminal&lt;/em&gt; and &lt;em&gt;stateful&lt;/em&gt; for the &lt;a href=&quot;minus#kotlin.sequences%24minus%28kotlin.sequences.Sequence%28%28kotlin.sequences.minus.T%29%29%2C+kotlin.sequences.Sequence%28%28kotlin.sequences.minus.T%29%29%29%2Felements&quot;&gt;elements&lt;/a&gt; sequence.</source>
          <target state="translated">동작은 &lt;em&gt;중간&lt;/em&gt; 이 순서 및 &lt;em&gt;단말기&lt;/em&gt; 및 &lt;em&gt;상태&lt;/em&gt; 용 &lt;a href=&quot;minus#kotlin.sequences%24minus%28kotlin.sequences.Sequence%28%28kotlin.sequences.minus.T%29%29%2C+kotlin.sequences.Sequence%28%28kotlin.sequences.minus.T%29%29%29%2Felements&quot;&gt;소자&lt;/a&gt; 시퀀스.</target>
        </trans-unit>
        <trans-unit id="f90173c5f7dc2e732f31878b5387f1009c2ad309" translate="yes" xml:space="preserve">
          <source>The operation is &lt;em&gt;terminal&lt;/em&gt;.</source>
          <target state="translated">작업은 &lt;em&gt;터미널&lt;/em&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="24cec715dc71cea63c8c77aa342afd935860c2d6" translate="yes" xml:space="preserve">
          <source>The operations on floating point numbers discussed in this section are:</source>
          <target state="translated">이 섹션에서 설명한 부동 소수점 숫자에 대한 작업은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="c81054e9fa59c990a7f0009d1471af7d0d80d085" translate="yes" xml:space="preserve">
          <source>The operator &lt;code&gt;plus&lt;/code&gt; provides a way to add key-value pair(s) to a read-only map producing a new map, however there was not a simple way to do the opposite: to remove a key from the map you have to resort to less straightforward ways to like &lt;code&gt;Map.filter()&lt;/code&gt; or &lt;code&gt;Map.filterKeys()&lt;/code&gt;. Now the operator &lt;code&gt;minus&lt;/code&gt; fills this gap. There are 4 overloads available: for removing a single key, a collection of keys, a sequence of keys and an array of keys.</source>
          <target state="translated">연산자 &lt;code&gt;plus&lt;/code&gt; 는 키-값 쌍을 읽기 전용 맵에 추가하여 새 맵을 생성하는 방법을 제공하지만 그 반대의 간단한 방법은 없었습니다. 맵에서 키를 제거하는 방법 &lt;code&gt;Map.filter()&lt;/code&gt; 또는 &lt;code&gt;Map.filterKeys()&lt;/code&gt; 와 같은 간단한 방법 . 이제 연산자 &lt;code&gt;minus&lt;/code&gt; 가이 간격을 채 웁니다. 단일 키, 키 모음, 일련의 키 및 키 배열을 제거하기위한 4 가지 오버로드가 있습니다.</target>
        </trans-unit>
        <trans-unit id="a3dfe13bda3af06c0e25457985a11e6db0a3ea90" translate="yes" xml:space="preserve">
          <source>The order of elements is an important aspect of certain collection types. For example, two lists of the same elements are not equal if their elements are ordered differently.</source>
          <target state="translated">요소의 순서는 특정 컬렉션 유형의 중요한 측면입니다. 예를 들어, 요소가 다르게 정렬 된 경우 동일한 요소의 두 목록이 동일하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="97cb339b9434116a61ea466562966c5cfa7e6e7a" translate="yes" xml:space="preserve">
          <source>The order of operations execution is different as well: &lt;code&gt;Sequence&lt;/code&gt; performs all the processing steps one-by-one for every single element. In turn, &lt;code&gt;Iterable&lt;/code&gt; completes each step for the whole collection and then proceeds to the next step.</source>
          <target state="translated">작업 실행 순서도 다릅니다. &lt;code&gt;Sequence&lt;/code&gt; 는 모든 단일 요소에 대해 모든 처리 단계를 하나씩 수행합니다. 차례로, &lt;code&gt;Iterable&lt;/code&gt; 전체 컬렉션의 각 단계를 완료 한 후 다음 단계로 진행된다.</target>
        </trans-unit>
        <trans-unit id="b74ff8ee45b0b8f3cea227a5cb8b0ca2512e0fa1" translate="yes" xml:space="preserve">
          <source>The output is:</source>
          <target state="translated">출력은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="21b2e4b0974b9e68e9c52fc5e687c75f3f109501" translate="yes" xml:space="preserve">
          <source>The output it produces with &lt;code&gt;-Dkotlinx.coroutines.debug&lt;/code&gt; JVM option is similar to:</source>
          <target state="translated">&lt;code&gt;-Dkotlinx.coroutines.debug&lt;/code&gt; JVM 옵션으로 생성되는 출력 은 다음과 유사합니다.</target>
        </trans-unit>
        <trans-unit id="335f16bba6cd2578184d6190d9013ac4ec39e185" translate="yes" xml:space="preserve">
          <source>The output of a config script with &lt;code&gt;--libs&lt;/code&gt; will be passed as a &lt;code&gt;-linkedArgs&lt;/code&gt;&lt;code&gt;kotlinc&lt;/code&gt; flag value (quoted) when compiling.</source>
          <target state="translated">&lt;code&gt;--libs&lt;/code&gt; 를 사용하는 구성 스크립트의 출력은 컴파일 할 때 &lt;code&gt;-linkedArgs&lt;/code&gt; &lt;code&gt;kotlinc&lt;/code&gt; 플래그 값 (인용) 으로 전달됩니다 .</target>
        </trans-unit>
        <trans-unit id="a335f7db5ad6c9bad17c284454dcaeefbd6be278" translate="yes" xml:space="preserve">
          <source>The output of this code is (with &lt;a href=&quot;https://github.com/Kotlin/kotlinx.coroutines/blob/master/docs/coroutine-context-and-dispatchers.md#debugging-coroutines-and-threads&quot;&gt;debug&lt;/a&gt;):</source>
          <target state="translated">이 코드의 출력은 (함께 &lt;a href=&quot;https://github.com/Kotlin/kotlinx.coroutines/blob/master/docs/coroutine-context-and-dispatchers.md#debugging-coroutines-and-threads&quot;&gt;디버그&lt;/a&gt; ) :</target>
        </trans-unit>
        <trans-unit id="d91d0dd8fa3a619861392f5c074fea2d8db4eaf2" translate="yes" xml:space="preserve">
          <source>The output of this code is:</source>
          <target state="translated">이 코드의 출력은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="647a971dfd3700d13cfdc057be9aa0bc71494501" translate="yes" xml:space="preserve">
          <source>The output of this code shows that the &lt;code&gt;filter()&lt;/code&gt; and &lt;code&gt;map()&lt;/code&gt; functions are called only when building the result list. So, you first see the line of text &lt;code&gt;&amp;ldquo;Lengths of..&amp;rdquo;&lt;/code&gt; and then the sequence processing starts. Note that for elements left after filtering, the map executes before filtering the next element. When the result size reaches 4, the processing stops because it's the largest possible size that &lt;code&gt;take(4)&lt;/code&gt; can return.</source>
          <target state="translated">이 코드의 결과는 &lt;code&gt;filter()&lt;/code&gt; 및 &lt;code&gt;map()&lt;/code&gt; 함수가 결과 목록을 작성할 때만 호출 됨을 보여줍니다 . 먼저, &lt;code&gt;&amp;ldquo;Lengths of..&amp;rdquo;&lt;/code&gt; 텍스트 줄이 나타난 다음 시퀀스 처리가 시작됩니다. 필터링 후 남은 요소의 경우 다음 요소를 필터링하기 전에 맵이 실행됩니다. 결과 크기가 4에 도달하면 &lt;code&gt;take(4)&lt;/code&gt; 가 리턴 할 수 있는 최대 크기이므로 처리가 중지됩니다 .</target>
        </trans-unit>
        <trans-unit id="4914ca42a65eab132541007ef394cf246de086f7" translate="yes" xml:space="preserve">
          <source>The output of this code with &lt;code&gt;-Dkotlinx.coroutines.debug&lt;/code&gt; JVM option is:</source>
          <target state="translated">&lt;code&gt;-Dkotlinx.coroutines.debug&lt;/code&gt; JVM 옵션 을 사용한 이 코드의 출력은 다음과 같습니다 .</target>
        </trans-unit>
        <trans-unit id="fdcf4102afb246d995583e41d5abf443dc9b24d6" translate="yes" xml:space="preserve">
          <source>The output of this example is:</source>
          <target state="translated">이 예제의 결과는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="d7f56deac4aeaab1be47a9075fd39d0cd515a13f" translate="yes" xml:space="preserve">
          <source>The output of this is a blank page that prints &lt;code&gt;Hello JavaScript!&lt;/code&gt; to the console.</source>
          <target state="translated">이 결과는 &lt;code&gt;Hello JavaScript!&lt;/code&gt; 를 인쇄하는 빈 페이지입니다 ! 콘솔에.</target>
        </trans-unit>
        <trans-unit id="c7adcbeb9a00e6f9f8d55d348527ceb949cebeb0" translate="yes" xml:space="preserve">
          <source>The output should be:</source>
          <target state="translated">출력은 다음과 같아야합니다.</target>
        </trans-unit>
        <trans-unit id="0b8e02788f842ec131e59334f158260f8f72ffc7" translate="yes" xml:space="preserve">
          <source>The output will be similar to the the following one, albeit the processor ids that receive each specific integer may be different:</source>
          <target state="translated">각 특정 정수를받는 프로세서 ID는 다를 수 있지만 출력은 다음과 비슷합니다.</target>
        </trans-unit>
        <trans-unit id="b56500d82b30990e46ae5220b62e1c3f4e225003" translate="yes" xml:space="preserve">
          <source>The overriding constructor must have the same parameter names and types as the overridden one.</source>
          <target state="translated">재정의 생성자는 재정의 생성자와 동일한 매개 변수 이름과 유형을 가져야합니다.</target>
        </trans-unit>
        <trans-unit id="d0fd3de86e4826ba8c7cde26e87523bae54839bc" translate="yes" xml:space="preserve">
          <source>The packages from platform libraries are available by default. No special link flags need to be specified to use them. &lt;code&gt;Kotlin/Native&lt;/code&gt; compiler automatically detects which of the platform libraries have been accessed and automatically links the needed libraries.</source>
          <target state="translated">플랫폼 라이브러리의 패키지는 기본적으로 사용 가능합니다. 특별한 링크 플래그를 지정하지 않아도 사용할 수 있습니다. &lt;code&gt;Kotlin/Native&lt;/code&gt; 컴파일러는 액세스 한 플랫폼 라이브러리를 자동으로 감지하여 필요한 라이브러리를 자동으로 연결합니다.</target>
        </trans-unit>
        <trans-unit id="f9eac82235030e7e86a0bff236552f847d9867dd" translate="yes" xml:space="preserve">
          <source>The parameter is declared in a member function and one of the corresponding parameters in the super functions is optional.</source>
          <target state="translated">매개 변수는 멤버 함수에서 선언되며 수퍼 함수의 해당 매개 변수 중 하나는 선택 사항입니다.</target>
        </trans-unit>
        <trans-unit id="1a311c087dc5f415abb270981ad04ec98ba47164" translate="yes" xml:space="preserve">
          <source>The parameter must not &lt;a href=&quot;#variable-number-of-arguments-varargs&quot;&gt;accept variable number of arguments&lt;/a&gt; and must have no &lt;a href=&quot;#default-arguments&quot;&gt;default value&lt;/a&gt;.</source>
          <target state="translated">이 매개 변수는 &lt;a href=&quot;#variable-number-of-arguments-varargs&quot;&gt;가변 개수의 인수를 허용&lt;/a&gt; 하지 않아야하며 &lt;a href=&quot;#default-arguments&quot;&gt;기본값&lt;/a&gt; 이 없어야 합니다 .</target>
        </trans-unit>
        <trans-unit id="85604054f8838d2bde0848abdc31a44140b69283" translate="yes" xml:space="preserve">
          <source>The parameter of &lt;code&gt;@JsName&lt;/code&gt; is required to be a constant string literal which is a valid identifier. The compiler will report an error on any attempt to pass non-identifier string to &lt;code&gt;@JsName&lt;/code&gt;. The following example produces a compile-time error:</source>
          <target state="translated">&lt;code&gt;@JsName&lt;/code&gt; 의 매개 변수 는 유효한 식별자 인 상수 문자열 리터럴이어야합니다. 컴파일러는 식별자가 아닌 문자열을 &lt;code&gt;@JsName&lt;/code&gt; 에 전달하려는 시도에서 오류를보고합니다 . 다음 예제는 컴파일 타임 오류를 생성합니다.</target>
        </trans-unit>
        <trans-unit id="d09d94c8171c7316821713755fce66dc3c85e74a" translate="yes" xml:space="preserve">
          <source>The parameter of &lt;code&gt;js&lt;/code&gt; is required to be a string constant. So, the following code is incorrect:</source>
          <target state="translated">&lt;code&gt;js&lt;/code&gt; 의 매개 변수 는 문자열 상수 여야합니다. 따라서 다음 코드는 올바르지 않습니다.</target>
        </trans-unit>
        <trans-unit id="64419b25b7715086a3a5cdbe138547b81a0a98a1" translate="yes" xml:space="preserve">
          <source>The parameter type of a function-typed parameter (the user is passing a function that can handle any &lt;code&gt;Fruit&lt;/code&gt;, and it will be given an &lt;code&gt;Apple&lt;/code&gt;)</source>
          <target state="translated">함수 형식의 매개 변수의 매개 변수 유형 (사용자는 처리 할 수있는 기능을 전달하고 &lt;code&gt;Fruit&lt;/code&gt; 하고는 주어질 것이다 &lt;code&gt;Apple&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="6ef05f581070101fa2afecc255e98671537cdea0" translate="yes" xml:space="preserve">
          <source>The parameters and the return type are specified in the same way as for regular functions, except that the parameter types can be omitted if they can be inferred from context:</source>
          <target state="translated">매개 변수 및 리턴 유형은 컨텍스트에서 유추 할 수있는 경우 매개 변수 유형을 생략 할 수 있다는 점을 제외하고 일반 함수와 동일한 방식으로 지정됩니다.</target>
        </trans-unit>
        <trans-unit id="d2818a5f4b17e0f3d50df0846a19518863e09067" translate="yes" xml:space="preserve">
          <source>The parameters of &lt;code&gt;provideDelegate&lt;/code&gt; are the same as for &lt;code&gt;getValue&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;provideDelegate&lt;/code&gt; 의 매개 변수는 &lt;code&gt;getValue&lt;/code&gt; 와 동일합니다 .</target>
        </trans-unit>
        <trans-unit id="87e2c98795ae2a97eb179a3bb9ccc1f2e2c982d8" translate="yes" xml:space="preserve">
          <source>The passed type must satisfy all conditions of the &lt;code&gt;where&lt;/code&gt; clause simultaneously. In the above example, the &lt;code&gt;T&lt;/code&gt; type must implement &lt;em&gt;both&lt;/em&gt;&lt;code&gt;CharSequence&lt;/code&gt; and &lt;code&gt;Comparable&lt;/code&gt;.</source>
          <target state="translated">전달 된 유형은 &lt;code&gt;where&lt;/code&gt; 절의 모든 조건을 동시에 만족해야합니다 . 위 예제에서 &lt;code&gt;T&lt;/code&gt; 유형은 &lt;code&gt;CharSequence&lt;/code&gt; 및 &lt;code&gt;Comparable&lt;/code&gt; 을&lt;em&gt;모두&lt;/em&gt; 구현해야합니다 .</target>
        </trans-unit>
        <trans-unit id="0f70942d020a14104380fd6e7920e316921b42c6" translate="yes" xml:space="preserve">
          <source>The path refers to the default output location that IntelliJ IDEA uses when we compile the application. Below we'll see how to change this.</source>
          <target state="translated">경로는 응용 프로그램을 컴파일 할 때 IntelliJ IDEA가 사용하는 기본 출력 위치를 나타냅니다. 아래에서이를 변경하는 방법을 살펴 보겠습니다.</target>
        </trans-unit>
        <trans-unit id="38dc6771af81ffcbac99f06b8c7fb1ebccf80f9d" translate="yes" xml:space="preserve">
          <source>The pattern string of this regular expression.</source>
          <target state="translated">이 정규식의 패턴 문자열입니다.</target>
        </trans-unit>
        <trans-unit id="1144f4eed1bc15fed420102b18cb1c4e49c25335" translate="yes" xml:space="preserve">
          <source>The pattern where a coroutine is producing a sequence of elements is quite common. This is a part of &lt;em&gt;producer-consumer&lt;/em&gt; pattern that is often found in concurrent code. You could abstract such a producer into a function that takes channel as its parameter, but this goes contrary to common sense that results must be returned from functions.</source>
          <target state="translated">코 루틴이 일련의 요소를 생성하는 패턴은 매우 일반적입니다. 이것은 종종 동시 코드에서 발견되는 &lt;em&gt;생산자-소비자&lt;/em&gt; 패턴 의 일부입니다 . 그러한 생산자를 채널을 매개 변수로 사용하는 함수로 추상화 할 수는 있지만 결과는 함수에서 반환되어야한다는 상식과 상반됩니다.</target>
        </trans-unit>
        <trans-unit id="0452bcbdd609690466ea082ea5af90749aa8dcc5" translate="yes" xml:space="preserve">
          <source>The placeholder &lt;code&gt;&amp;lt;...&amp;gt;&lt;/code&gt; should be replaced with one of the plugin names that can be found in further sections.</source>
          <target state="translated">플레이스 홀더 &lt;code&gt;&amp;lt;...&amp;gt;&lt;/code&gt; 는 추가 섹션에서 찾을 수있는 플러그인 이름 중 하나로 바꿔야합니다.</target>
        </trans-unit>
        <trans-unit id="02d885dcfef73f7197c98c6f94fc980ae42855f5" translate="yes" xml:space="preserve">
          <source>The plugin allows you to customize the pom generated for the publication with the &lt;code&gt;pom&lt;/code&gt; code block available for every component:</source>
          <target state="translated">플러그인을 사용하면 모든 컴포넌트에 사용 가능한 &lt;code&gt;pom&lt;/code&gt; 코드 블록을 사용 하여 발행물에 대해 생성 된 pom을 사용자 정의 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="73896d94724b0c15c533e7832f50fc2c5d439771" translate="yes" xml:space="preserve">
          <source>The plugin allows you to declare dependencies on files and other projects using traditional Gradle's mechanism of configurations. The plugin supports Kotlin multiplatform projects allowing you to declare the &lt;code&gt;expectedBy&lt;/code&gt; dependencies</source>
          <target state="translated">플러그인을 사용하면 전통적인 Gradle의 구성 메커니즘을 사용하여 파일 및 기타 프로젝트에 대한 종속성을 선언 할 수 있습니다. 이 플러그인은 Kotlin 멀티 플랫폼 프로젝트를 지원하므로 &lt;code&gt;expectedBy&lt;/code&gt; 종속성 을 선언 할 수 있습니다</target>
        </trans-unit>
        <trans-unit id="e2b8c11954d8c4f9f34c307b3e3ea0e12583e5af" translate="yes" xml:space="preserve">
          <source>The plugin builds a test executable for all the targets specified for the &lt;code&gt;test&lt;/code&gt; component. If the current host platform is included in this list the test running tasks are also created. To run tests, execute the standard lifecycle &lt;code&gt;check&lt;/code&gt; task:</source>
          <target state="translated">플러그인은 &lt;code&gt;test&lt;/code&gt; 구성 요소에 지정된 모든 대상에 대해 테스트 실행 파일을 빌드합니다 . 현재 호스트 플랫폼이이 목록에 포함되어 있으면 테스트 실행 작업도 생성됩니다. 테스트를 실행하려면 표준 수명주기 &lt;code&gt;check&lt;/code&gt; 작업을 실행하십시오 .</target>
        </trans-unit>
        <trans-unit id="cbd612ac393a456f8773735c05ddbd5f91419396" translate="yes" xml:space="preserve">
          <source>The plugin creates a compilation task for each combination of the target, output kind, and build type. The tasks have the following naming convention:</source>
          <target state="translated">플러그인은 대상, 출력 종류 및 빌드 유형의 각 조합에 대한 컴파일 작업을 만듭니다. 작업에는 다음과 같은 명명 규칙이 있습니다.</target>
        </trans-unit>
        <trans-unit id="b7797d4ea1281347f08b98f3d1593b5740b623cc" translate="yes" xml:space="preserve">
          <source>The plugin is shipped with a customized version of the &lt;code&gt;kotlinx.serialization&lt;/code&gt; plugin. To use it you don't have to add new buildscript dependencies, just apply the plugins and add a dependency on the serialization library:</source>
          <target state="translated">플러그인은 사용자 정의 된 &lt;code&gt;kotlinx.serialization&lt;/code&gt; 플러그인 버전과 함께 제공됩니다 . 그것을 사용하려면 새로운 빌드 스크립트 의존성을 추가 할 필요가 없으며 플러그인을 적용하고 직렬화 라이브러리에 의존성을 추가하십시오.</target>
        </trans-unit>
        <trans-unit id="a5b5cad9084adc7ffa681b4e8b7b6b009920bbab" translate="yes" xml:space="preserve">
          <source>The plugin option format is: &lt;code&gt;-P plugin:&amp;lt;plugin id&amp;gt;:&amp;lt;key&amp;gt;=&amp;lt;value&amp;gt;&lt;/code&gt;. Options can be repeated.</source>
          <target state="translated">플러그인 옵션 형식은 &lt;code&gt;-P plugin:&amp;lt;plugin id&amp;gt;:&amp;lt;key&amp;gt;=&amp;lt;value&amp;gt;&lt;/code&gt; 입니다. 옵션을 반복 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4b96dd9cca135b083ee411ceef82d46edf74c104" translate="yes" xml:space="preserve">
          <source>The plugin specifies the following annotations: &lt;a href=&quot;http://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/stereotype/Component.html&quot;&gt;&lt;code&gt;@Component&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;http://docs.spring.io/spring/docs/current/javadoc-api/org/springframework/scheduling/annotation/Async.html&quot;&gt;&lt;code&gt;@Async&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;http://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/transaction/annotation/Transactional.html&quot;&gt;&lt;code&gt;@Transactional&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;http://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/cache/annotation/Cacheable.html&quot;&gt;&lt;code&gt;@Cacheable&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;https://docs.spring.io/spring-boot/docs/current/api/org/springframework/boot/test/context/SpringBootTest.html&quot;&gt;&lt;code&gt;@SpringBootTest&lt;/code&gt;&lt;/a&gt;. Thanks to meta-annotations support classes annotated with &lt;a href=&quot;https://docs.spring.io/spring/docs/current/javadoc-api/org/springframework/context/annotation/Configuration.html&quot;&gt;&lt;code&gt;@Configuration&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/stereotype/Controller.html&quot;&gt;&lt;code&gt;@Controller&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;https://docs.spring.io/spring/docs/current/javadoc-api/org/springframework/web/bind/annotation/RestController.html&quot;&gt;&lt;code&gt;@RestController&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;https://docs.spring.io/spring/docs/current/javadoc-api/org/springframework/stereotype/Service.html&quot;&gt;&lt;code&gt;@Service&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/stereotype/Repository.html&quot;&gt;&lt;code&gt;@Repository&lt;/code&gt;&lt;/a&gt; are automatically opened since these annotations are meta-annotated with &lt;a href=&quot;http://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/stereotype/Component.html&quot;&gt;&lt;code&gt;@Component&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">플러그인은 &lt;a href=&quot;http://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/stereotype/Component.html&quot;&gt; &lt;code&gt;@Component&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;http://docs.spring.io/spring/docs/current/javadoc-api/org/springframework/scheduling/annotation/Async.html&quot;&gt; &lt;code&gt;@Async&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;http://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/transaction/annotation/Transactional.html&quot;&gt; &lt;code&gt;@Transactional&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;http://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/cache/annotation/Cacheable.html&quot;&gt; &lt;code&gt;@Cacheable&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;https://docs.spring.io/spring-boot/docs/current/api/org/springframework/boot/test/context/SpringBootTest.html&quot;&gt; &lt;code&gt;@SpringBootTest&lt;/code&gt; &lt;/a&gt; 주석을 지정합니다 . 메타 주석 덕분에 &lt;a href=&quot;https://docs.spring.io/spring/docs/current/javadoc-api/org/springframework/context/annotation/Configuration.html&quot;&gt; &lt;code&gt;@Configuration&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/stereotype/Controller.html&quot;&gt; &lt;code&gt;@Controller&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;https://docs.spring.io/spring/docs/current/javadoc-api/org/springframework/web/bind/annotation/RestController.html&quot;&gt; &lt;code&gt;@RestController&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;https://docs.spring.io/spring/docs/current/javadoc-api/org/springframework/stereotype/Service.html&quot;&gt; &lt;code&gt;@Service&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/stereotype/Repository.html&quot;&gt; &lt;code&gt;@Repository&lt;/code&gt; &lt;/a&gt; 로 주석이 달린 클래스 가 주석이 &lt;a href=&quot;http://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/stereotype/Component.html&quot;&gt; &lt;code&gt;@Component&lt;/code&gt; &lt;/a&gt; 로 메타 주석이기 때문에 자동으로 열립니다 .</target>
        </trans-unit>
        <trans-unit id="422a0ed13a769b30fb09b25e92467921db8dd51b" translate="yes" xml:space="preserve">
          <source>The plugin uses the same notation as the compiler. By default, test component uses the same targets as specified for the main one.</source>
          <target state="translated">플러그인은 컴파일러와 동일한 표기법을 사용합니다. 기본적으로 테스트 구성 요소는 기본 구성 요소에 지정된 것과 동일한 대상을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="1f3c2f2fca540697d8f63e00a5a21435f0484957" translate="yes" xml:space="preserve">
          <source>The podspec generated includes a path to an output framework and script phases which automate building this framework during a build process of an Xcode project. Some fields of the podspec file can be configured using the &lt;code&gt;kotlin.cocoapods { ... }&lt;/code&gt; code block.</source>
          <target state="translated">생성 된 podspec에는 출력 프레임 워크에 대한 경로와 Xcode 프로젝트의 빌드 프로세스 중에이 프레임 워크 빌드를 자동화하는 스크립트 단계가 포함됩니다. podlin 파일의 일부 필드는 &lt;code&gt;kotlin.cocoapods { ... }&lt;/code&gt; 코드 블록을 사용하여 구성 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="4f2f6c39a4cfc0d578583a59ccc054d34affa473" translate="yes" xml:space="preserve">
          <source>The pointer with an opaque type.</source>
          <target state="translated">불투명 한 타입의 포인터.</target>
        </trans-unit>
        <trans-unit id="cac38148225622f1c3ccca3dceed3d6a499e0217" translate="yes" xml:space="preserve">
          <source>The possible values of &lt;a href=&quot;returns#kotlin.contracts.ContractBuilder%24returns%28kotlin.Any%29%2Fvalue&quot;&gt;value&lt;/a&gt; are limited to &lt;code&gt;true&lt;/code&gt;, &lt;code&gt;false&lt;/code&gt; or &lt;code&gt;null&lt;/code&gt;.</source>
          <target state="translated">가능한 value &lt;a href=&quot;returns#kotlin.contracts.ContractBuilder%24returns%28kotlin.Any%29%2Fvalue&quot;&gt;값&lt;/a&gt; 은 &lt;code&gt;true&lt;/code&gt; , &lt;code&gt;false&lt;/code&gt; 또는 &lt;code&gt;null&lt;/code&gt; 로 제한됩니다 .</target>
        </trans-unit>
        <trans-unit id="db453765e0a754bcf108983d99d14a9cceb4e257" translate="yes" xml:space="preserve">
          <source>The predicates in &lt;code&gt;filter()&lt;/code&gt; can only check the values of the elements. If you want to use element positions in the filter, use &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/filter-indexed&quot;&gt;&lt;code&gt;filterIndexed()&lt;/code&gt;&lt;/a&gt;. It takes a predicate with two arguments: the index and the value of an element.</source>
          <target state="translated">&lt;code&gt;filter()&lt;/code&gt; 의 술어 는 요소의 값만 확인할 수 있습니다. 필터에서 요소 위치를 사용하려면 &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/filter-indexed&quot;&gt; &lt;code&gt;filterIndexed()&lt;/code&gt; &lt;/a&gt; . 인덱스와 요소의 값이라는 두 개의 인수가있는 술어를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="273bc9daf88463decafd479d30c651cc98374847" translate="yes" xml:space="preserve">
          <source>The prepared project sources can be directly downloaded from &lt;a href=&quot;https://github.com/kotlin/web-site-samples/archive/mpp-kn-app-groovy-macos.zip&quot;&gt;GitHub&lt;/a&gt;. &lt;a href=&quot;https://github.com/kotlin/web-site-samples/archive/mpp-kn-app-groovy-linux.zip&quot;&gt;GitHub&lt;/a&gt;. &lt;a href=&quot;https://github.com/kotlin/web-site-samples/archive/mpp-kn-app-groovy-windows.zip&quot;&gt;GitHub&lt;/a&gt;. &lt;a href=&quot;https://github.com/kotlin/web-site-samples/archive/mpp-kn-app-kotlin-macos.zip&quot;&gt;GitHub&lt;/a&gt;. &lt;a href=&quot;https://github.com/kotlin/web-site-samples/archive/mpp-kn-app-kotlin-linux.zip&quot;&gt;GitHub&lt;/a&gt;. &lt;a href=&quot;https://github.com/kotlin/web-site-samples/archive/mpp-kn-app-kotlin-windows.zip&quot;&gt;GitHub&lt;/a&gt;.</source>
          <target state="translated">준비된 프로젝트 소스는 &lt;a href=&quot;https://github.com/kotlin/web-site-samples/archive/mpp-kn-app-groovy-macos.zip&quot;&gt;GitHub&lt;/a&gt; 에서 직접 다운로드 할 수 있습니다 . &lt;a href=&quot;https://github.com/kotlin/web-site-samples/archive/mpp-kn-app-groovy-linux.zip&quot;&gt;GitHub의&lt;/a&gt; . &lt;a href=&quot;https://github.com/kotlin/web-site-samples/archive/mpp-kn-app-groovy-windows.zip&quot;&gt;GitHub의&lt;/a&gt; . &lt;a href=&quot;https://github.com/kotlin/web-site-samples/archive/mpp-kn-app-kotlin-macos.zip&quot;&gt;GitHub의&lt;/a&gt; . &lt;a href=&quot;https://github.com/kotlin/web-site-samples/archive/mpp-kn-app-kotlin-linux.zip&quot;&gt;GitHub의&lt;/a&gt; . &lt;a href=&quot;https://github.com/kotlin/web-site-samples/archive/mpp-kn-app-kotlin-windows.zip&quot;&gt;GitHub의&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="1cda211d823296d73d5059839d0f82ff49bb5da0" translate="yes" xml:space="preserve">
          <source>The prepared project sources can be directly downloaded from &lt;a href=&quot;https://github.com/kotlin/web-site-samples/archive/mpp-kn-framework-groovy-macos-mac.zip&quot;&gt;GitHub&lt;/a&gt;. &lt;a href=&quot;https://github.com/kotlin/web-site-samples/archive/mpp-kn-framework-kotlin-macos-mac.zip&quot;&gt;GitHub&lt;/a&gt;.</source>
          <target state="translated">준비된 프로젝트 소스는 &lt;a href=&quot;https://github.com/kotlin/web-site-samples/archive/mpp-kn-framework-groovy-macos-mac.zip&quot;&gt;GitHub&lt;/a&gt; 에서 직접 다운로드 할 수 있습니다 . &lt;a href=&quot;https://github.com/kotlin/web-site-samples/archive/mpp-kn-framework-kotlin-macos-mac.zip&quot;&gt;GitHub의&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="83fad008770a134699f224ecf517dfb249b17b87" translate="yes" xml:space="preserve">
          <source>The prepared project sources can be directly downloaded from &lt;a href=&quot;https://github.com/kotlin/web-site-samples/archive/mpp-kn-shared-lib-groovy-linux.zip&quot;&gt;GitHub&lt;/a&gt;. &lt;a href=&quot;https://github.com/kotlin/web-site-samples/archive/mpp-kn-shared-lib-groovy-macos.zip&quot;&gt;GitHub&lt;/a&gt;. &lt;a href=&quot;https://github.com/kotlin/web-site-samples/archive/mpp-kn-shared-lib-groovy-windows.zip&quot;&gt;GitHub&lt;/a&gt;. &lt;a href=&quot;https://github.com/kotlin/web-site-samples/archive/mpp-kn-shared-lib-kotlin-linux.zip&quot;&gt;GitHub&lt;/a&gt;. &lt;a href=&quot;https://github.com/kotlin/web-site-samples/archive/mpp-kn-shared-lib-kotlin-macos.zip&quot;&gt;GitHub&lt;/a&gt;. &lt;a href=&quot;https://github.com/kotlin/web-site-samples/archive/mpp-kn-shared-lib-kotlin-windows.zip&quot;&gt;GitHub&lt;/a&gt;.</source>
          <target state="translated">준비된 프로젝트 소스는 &lt;a href=&quot;https://github.com/kotlin/web-site-samples/archive/mpp-kn-shared-lib-groovy-linux.zip&quot;&gt;GitHub&lt;/a&gt; 에서 직접 다운로드 할 수 있습니다 . &lt;a href=&quot;https://github.com/kotlin/web-site-samples/archive/mpp-kn-shared-lib-groovy-macos.zip&quot;&gt;GitHub의&lt;/a&gt; . &lt;a href=&quot;https://github.com/kotlin/web-site-samples/archive/mpp-kn-shared-lib-groovy-windows.zip&quot;&gt;GitHub의&lt;/a&gt; . &lt;a href=&quot;https://github.com/kotlin/web-site-samples/archive/mpp-kn-shared-lib-kotlin-linux.zip&quot;&gt;GitHub의&lt;/a&gt; . &lt;a href=&quot;https://github.com/kotlin/web-site-samples/archive/mpp-kn-shared-lib-kotlin-macos.zip&quot;&gt;GitHub의&lt;/a&gt; . &lt;a href=&quot;https://github.com/kotlin/web-site-samples/archive/mpp-kn-shared-lib-kotlin-windows.zip&quot;&gt;GitHub의&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="47fbf2be0cf9555e26f724c9cc904699b4e6d2c6" translate="yes" xml:space="preserve">
          <source>The prepared project sources can be downloaded directly from &lt;a href=&quot;https://github.com/kotlin/web-site-samples/archive/mpp-kn-app-groovy-macos-c.zip&quot;&gt;GitHub&lt;/a&gt;. &lt;a href=&quot;https://github.com/kotlin/web-site-samples/archive/mpp-kn-app-groovy-linux-c.zip&quot;&gt;GitHub&lt;/a&gt;. &lt;a href=&quot;https://github.com/kotlin/web-site-samples/archive/mpp-kn-app-groovy-windows-c.zip&quot;&gt;GitHub&lt;/a&gt;. &lt;a href=&quot;https://github.com/kotlin/web-site-samples/archive/mpp-kn-app-kotlin-macos-c.zip&quot;&gt;GitHub&lt;/a&gt;. &lt;a href=&quot;https://github.com/kotlin/web-site-samples/archive/mpp-kn-app-kotlin-linux-c.zip&quot;&gt;GitHub&lt;/a&gt;. &lt;a href=&quot;https://github.com/kotlin/web-site-samples/archive/mpp-kn-app-kotlin-windows-c.zip&quot;&gt;GitHub&lt;/a&gt;.</source>
          <target state="translated">준비된 프로젝트 소스는 &lt;a href=&quot;https://github.com/kotlin/web-site-samples/archive/mpp-kn-app-groovy-macos-c.zip&quot;&gt;GitHub&lt;/a&gt; 에서 직접 다운로드 할 수 있습니다 . &lt;a href=&quot;https://github.com/kotlin/web-site-samples/archive/mpp-kn-app-groovy-linux-c.zip&quot;&gt;GitHub의&lt;/a&gt; . &lt;a href=&quot;https://github.com/kotlin/web-site-samples/archive/mpp-kn-app-groovy-windows-c.zip&quot;&gt;GitHub의&lt;/a&gt; . &lt;a href=&quot;https://github.com/kotlin/web-site-samples/archive/mpp-kn-app-kotlin-macos-c.zip&quot;&gt;GitHub의&lt;/a&gt; . &lt;a href=&quot;https://github.com/kotlin/web-site-samples/archive/mpp-kn-app-kotlin-linux-c.zip&quot;&gt;GitHub의&lt;/a&gt; . &lt;a href=&quot;https://github.com/kotlin/web-site-samples/archive/mpp-kn-app-kotlin-windows-c.zip&quot;&gt;GitHub의&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="0b884226386a575e859d8ba59646588a18cff524" translate="yes" xml:space="preserve">
          <source>The preset functions return an existing target if there is one. This can be used to configure an existing target:</source>
          <target state="translated">사전 설정 기능은 기존 대상이있는 경우 기존 대상을 반환합니다. 기존 대상을 구성하는 데 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="94b4a93f08efae43f49ccc9068c6ccc45a749339" translate="yes" xml:space="preserve">
          <source>The primary constructor cannot contain any code. Initialization code can be placed in &lt;strong&gt;initializer blocks&lt;/strong&gt;, which are prefixed with the &lt;em&gt;init&lt;/em&gt; keyword.</source>
          <target state="translated">기본 생성자는 코드를 포함 할 수 없습니다. 초기화 코드는 &lt;strong&gt;이니셜 라이저 블록에&lt;/strong&gt; 배치 될 수 있으며, &lt;strong&gt;초기화 블록&lt;/strong&gt; 은 &lt;em&gt;init&lt;/em&gt; 키워드 가 접두어로 붙습니다 .</target>
        </trans-unit>
        <trans-unit id="9fdf36149a4f79a1bb95fdb86a615c52def92e79" translate="yes" xml:space="preserve">
          <source>The primary constructor needs to have at least one parameter;</source>
          <target state="translated">기본 생성자에는 하나 이상의 매개 변수가 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="da3ee8bb58d5e5b4db4f578cf06329f7adf39108" translate="yes" xml:space="preserve">
          <source>The principles of Keeping the Language Modern and Comfortable Updates suggest that incompatible changes are sometimes necessary, but they should be introduced carefully. Our goal is to make the users aware of upcoming changes well in advance to let them migrate their code comfortably.</source>
          <target state="translated">언어를 현대적이고 편안한 업데이트로 유지하는 원칙에 따르면 호환되지 않는 변경이 필요할 수도 있지만 신중하게 소개해야합니다. 우리의 목표는 사용자에게 향후 변경 사항을 미리 알리고 코드를 편안하게 마이그레이션 할 수 있도록하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="8a9400005c3bca2486ac5d4f71c851ac612c4135" translate="yes" xml:space="preserve">
          <source>The problem</source>
          <target state="translated">문제</target>
        </trans-unit>
        <trans-unit id="9c66b2fe04efcfddbeb39708f916ac0b213e981b" translate="yes" xml:space="preserve">
          <source>The problem is that in Kotlin we can say &lt;code&gt;unboxBase(boxDerived(&quot;s&quot;))&lt;/code&gt;, but in Java that would be impossible, because in Java the class &lt;code&gt;Box&lt;/code&gt; is &lt;em&gt;invariant&lt;/em&gt; in its parameter &lt;code&gt;T&lt;/code&gt;, and thus &lt;code&gt;Box&amp;lt;Derived&amp;gt;&lt;/code&gt; is not a subtype of &lt;code&gt;Box&amp;lt;Base&amp;gt;&lt;/code&gt;. To make it work in Java we'd have to define &lt;code&gt;unboxBase&lt;/code&gt; as follows:</source>
          <target state="translated">문제는 코 틀린에 우리가 말할 수 있다는 것입니다 &lt;code&gt;unboxBase(boxDerived(&quot;s&quot;))&lt;/code&gt; 하지만, 자바 클래스 때문에 자바 즉, 불가능하다 &lt;code&gt;Box&lt;/code&gt; 입니다 &lt;em&gt;불변&lt;/em&gt; 의 매개 변수 &lt;code&gt;T&lt;/code&gt; 따라서, 그리고 &lt;code&gt;Box&amp;lt;Derived&amp;gt;&lt;/code&gt; 서브 타입 아니다 의 &lt;code&gt;Box&amp;lt;Base&amp;gt;&lt;/code&gt; . Java에서 작동하게하려면 다음과 같이 &lt;code&gt;unboxBase&lt;/code&gt; 를 정의 해야 합니다.</target>
        </trans-unit>
        <trans-unit id="d0d37636a32f4cdf2f104260760bfa7761da1ecf" translate="yes" xml:space="preserve">
          <source>The process of building and running the Kotlin application in Android Studio is exactly the same as with Java.</source>
          <target state="translated">Android Studio에서 Kotlin 애플리케이션을 빌드하고 실행하는 프로세스는 Java와 정확히 동일합니다.</target>
        </trans-unit>
        <trans-unit id="5333ca5a84bee1fa54c6c2c65a4ed24b1d5a7d39" translate="yes" xml:space="preserve">
          <source>The programming model and APIs remain the same. We can continue to use loops, exception handling, etc. and there's no need to learn a complete set of new APIs</source>
          <target state="translated">프로그래밍 모델과 API는 동일하게 유지됩니다. 루프, 예외 처리 등을 계속 사용할 수 있으며 완전한 새로운 API 세트를 배울 필요가 없습니다.</target>
        </trans-unit>
        <trans-unit id="cbc23b45ec695a38d5e9af2e658da812853cfa4f" translate="yes" xml:space="preserve">
          <source>The progression starts with the &lt;a href=&quot;from-closed-range#kotlin.ranges.CharProgression.Companion%24fromClosedRange%28kotlin.Char%2C+kotlin.Char%2C+kotlin.Int%29%2FrangeStart&quot;&gt;rangeStart&lt;/a&gt; value and goes toward the &lt;a href=&quot;from-closed-range#kotlin.ranges.CharProgression.Companion%24fromClosedRange%28kotlin.Char%2C+kotlin.Char%2C+kotlin.Int%29%2FrangeEnd&quot;&gt;rangeEnd&lt;/a&gt; value not excluding it, with the specified &lt;a href=&quot;from-closed-range#kotlin.ranges.CharProgression.Companion%24fromClosedRange%28kotlin.Char%2C+kotlin.Char%2C+kotlin.Int%29%2Fstep&quot;&gt;step&lt;/a&gt;. In order to go backwards the &lt;a href=&quot;from-closed-range#kotlin.ranges.CharProgression.Companion%24fromClosedRange%28kotlin.Char%2C+kotlin.Char%2C+kotlin.Int%29%2Fstep&quot;&gt;step&lt;/a&gt; must be negative.</source>
          <target state="translated">진행은 &lt;a href=&quot;from-closed-range#kotlin.ranges.CharProgression.Companion%24fromClosedRange%28kotlin.Char%2C+kotlin.Char%2C+kotlin.Int%29%2FrangeStart&quot;&gt;rangeStart&lt;/a&gt; 값으로 시작 하여 지정된 &lt;a href=&quot;from-closed-range#kotlin.ranges.CharProgression.Companion%24fromClosedRange%28kotlin.Char%2C+kotlin.Char%2C+kotlin.Int%29%2Fstep&quot;&gt;step을&lt;/a&gt; 제외 하고 &lt;a href=&quot;from-closed-range#kotlin.ranges.CharProgression.Companion%24fromClosedRange%28kotlin.Char%2C+kotlin.Char%2C+kotlin.Int%29%2FrangeEnd&quot;&gt;rangeEnd&lt;/a&gt; 값을 제외하고 진행 합니다. 뒤로 가려면 &lt;a href=&quot;from-closed-range#kotlin.ranges.CharProgression.Companion%24fromClosedRange%28kotlin.Char%2C+kotlin.Char%2C+kotlin.Int%29%2Fstep&quot;&gt;단계&lt;/a&gt; 가 음수 여야합니다.</target>
        </trans-unit>
        <trans-unit id="8d272fe15b8cfff505d8d535e47fe9213e3e4bb4" translate="yes" xml:space="preserve">
          <source>The progression starts with the &lt;a href=&quot;from-closed-range#kotlin.ranges.IntProgression.Companion%24fromClosedRange%28kotlin.Int%2C+kotlin.Int%2C+kotlin.Int%29%2FrangeStart&quot;&gt;rangeStart&lt;/a&gt; value and goes toward the &lt;a href=&quot;from-closed-range#kotlin.ranges.IntProgression.Companion%24fromClosedRange%28kotlin.Int%2C+kotlin.Int%2C+kotlin.Int%29%2FrangeEnd&quot;&gt;rangeEnd&lt;/a&gt; value not excluding it, with the specified &lt;a href=&quot;from-closed-range#kotlin.ranges.IntProgression.Companion%24fromClosedRange%28kotlin.Int%2C+kotlin.Int%2C+kotlin.Int%29%2Fstep&quot;&gt;step&lt;/a&gt;. In order to go backwards the &lt;a href=&quot;from-closed-range#kotlin.ranges.IntProgression.Companion%24fromClosedRange%28kotlin.Int%2C+kotlin.Int%2C+kotlin.Int%29%2Fstep&quot;&gt;step&lt;/a&gt; must be negative.</source>
          <target state="translated">진행은 &lt;a href=&quot;from-closed-range#kotlin.ranges.IntProgression.Companion%24fromClosedRange%28kotlin.Int%2C+kotlin.Int%2C+kotlin.Int%29%2FrangeStart&quot;&gt;rangeStart&lt;/a&gt; 값으로 시작 하여 지정된 &lt;a href=&quot;from-closed-range#kotlin.ranges.IntProgression.Companion%24fromClosedRange%28kotlin.Int%2C+kotlin.Int%2C+kotlin.Int%29%2Fstep&quot;&gt;step을&lt;/a&gt; 제외 하고 &lt;a href=&quot;from-closed-range#kotlin.ranges.IntProgression.Companion%24fromClosedRange%28kotlin.Int%2C+kotlin.Int%2C+kotlin.Int%29%2FrangeEnd&quot;&gt;rangeEnd&lt;/a&gt; 값을 제외하고 진행 합니다. 뒤로 가려면 &lt;a href=&quot;from-closed-range#kotlin.ranges.IntProgression.Companion%24fromClosedRange%28kotlin.Int%2C+kotlin.Int%2C+kotlin.Int%29%2Fstep&quot;&gt;단계&lt;/a&gt; 가 음수 여야합니다.</target>
        </trans-unit>
        <trans-unit id="84ee7e5946067792bd4d0c03b228099a9bd9d9cd" translate="yes" xml:space="preserve">
          <source>The progression starts with the &lt;a href=&quot;from-closed-range#kotlin.ranges.LongProgression.Companion%24fromClosedRange%28kotlin.Long%2C+kotlin.Long%2C+kotlin.Long%29%2FrangeStart&quot;&gt;rangeStart&lt;/a&gt; value and goes toward the &lt;a href=&quot;from-closed-range#kotlin.ranges.LongProgression.Companion%24fromClosedRange%28kotlin.Long%2C+kotlin.Long%2C+kotlin.Long%29%2FrangeEnd&quot;&gt;rangeEnd&lt;/a&gt; value not excluding it, with the specified &lt;a href=&quot;from-closed-range#kotlin.ranges.LongProgression.Companion%24fromClosedRange%28kotlin.Long%2C+kotlin.Long%2C+kotlin.Long%29%2Fstep&quot;&gt;step&lt;/a&gt;. In order to go backwards the &lt;a href=&quot;from-closed-range#kotlin.ranges.LongProgression.Companion%24fromClosedRange%28kotlin.Long%2C+kotlin.Long%2C+kotlin.Long%29%2Fstep&quot;&gt;step&lt;/a&gt; must be negative.</source>
          <target state="translated">진행은 &lt;a href=&quot;from-closed-range#kotlin.ranges.LongProgression.Companion%24fromClosedRange%28kotlin.Long%2C+kotlin.Long%2C+kotlin.Long%29%2FrangeStart&quot;&gt;rangeStart&lt;/a&gt; 값으로 시작 하여 지정된 &lt;a href=&quot;from-closed-range#kotlin.ranges.LongProgression.Companion%24fromClosedRange%28kotlin.Long%2C+kotlin.Long%2C+kotlin.Long%29%2Fstep&quot;&gt;step을&lt;/a&gt; 제외 하고 &lt;a href=&quot;from-closed-range#kotlin.ranges.LongProgression.Companion%24fromClosedRange%28kotlin.Long%2C+kotlin.Long%2C+kotlin.Long%29%2FrangeEnd&quot;&gt;rangeEnd&lt;/a&gt; 값을 제외하고 진행 합니다. 뒤로 가려면 &lt;a href=&quot;from-closed-range#kotlin.ranges.LongProgression.Companion%24fromClosedRange%28kotlin.Long%2C+kotlin.Long%2C+kotlin.Long%29%2Fstep&quot;&gt;단계&lt;/a&gt; 가 음수 여야합니다.</target>
        </trans-unit>
        <trans-unit id="8d8b7627f24846e9a31abff3ae25964002a498bf" translate="yes" xml:space="preserve">
          <source>The progression starts with the &lt;a href=&quot;from-closed-range#kotlin.ranges.UIntProgression.Companion%24fromClosedRange%28kotlin.UInt%2C+kotlin.UInt%2C+kotlin.Int%29%2FrangeStart&quot;&gt;rangeStart&lt;/a&gt; value and goes toward the &lt;a href=&quot;from-closed-range#kotlin.ranges.UIntProgression.Companion%24fromClosedRange%28kotlin.UInt%2C+kotlin.UInt%2C+kotlin.Int%29%2FrangeEnd&quot;&gt;rangeEnd&lt;/a&gt; value not excluding it, with the specified &lt;a href=&quot;from-closed-range#kotlin.ranges.UIntProgression.Companion%24fromClosedRange%28kotlin.UInt%2C+kotlin.UInt%2C+kotlin.Int%29%2Fstep&quot;&gt;step&lt;/a&gt;. In order to go backwards the &lt;a href=&quot;from-closed-range#kotlin.ranges.UIntProgression.Companion%24fromClosedRange%28kotlin.UInt%2C+kotlin.UInt%2C+kotlin.Int%29%2Fstep&quot;&gt;step&lt;/a&gt; must be negative.</source>
          <target state="translated">진행은 &lt;a href=&quot;from-closed-range#kotlin.ranges.UIntProgression.Companion%24fromClosedRange%28kotlin.UInt%2C+kotlin.UInt%2C+kotlin.Int%29%2FrangeStart&quot;&gt;rangeStart&lt;/a&gt; 값으로 시작 하여 지정된 &lt;a href=&quot;from-closed-range#kotlin.ranges.UIntProgression.Companion%24fromClosedRange%28kotlin.UInt%2C+kotlin.UInt%2C+kotlin.Int%29%2Fstep&quot;&gt;step을&lt;/a&gt; 제외 하고 &lt;a href=&quot;from-closed-range#kotlin.ranges.UIntProgression.Companion%24fromClosedRange%28kotlin.UInt%2C+kotlin.UInt%2C+kotlin.Int%29%2FrangeEnd&quot;&gt;rangeEnd&lt;/a&gt; 값을 제외하고 진행 합니다. 뒤로 가려면 &lt;a href=&quot;from-closed-range#kotlin.ranges.UIntProgression.Companion%24fromClosedRange%28kotlin.UInt%2C+kotlin.UInt%2C+kotlin.Int%29%2Fstep&quot;&gt;단계&lt;/a&gt; 가 음수 여야합니다.</target>
        </trans-unit>
        <trans-unit id="bc7d38b12995812c4efea617bb206ec4460e9ccc" translate="yes" xml:space="preserve">
          <source>The progression starts with the &lt;a href=&quot;from-closed-range#kotlin.ranges.ULongProgression.Companion%24fromClosedRange%28kotlin.ULong%2C+kotlin.ULong%2C+kotlin.Long%29%2FrangeStart&quot;&gt;rangeStart&lt;/a&gt; value and goes toward the &lt;a href=&quot;from-closed-range#kotlin.ranges.ULongProgression.Companion%24fromClosedRange%28kotlin.ULong%2C+kotlin.ULong%2C+kotlin.Long%29%2FrangeEnd&quot;&gt;rangeEnd&lt;/a&gt; value not excluding it, with the specified &lt;a href=&quot;from-closed-range#kotlin.ranges.ULongProgression.Companion%24fromClosedRange%28kotlin.ULong%2C+kotlin.ULong%2C+kotlin.Long%29%2Fstep&quot;&gt;step&lt;/a&gt;. In order to go backwards the &lt;a href=&quot;from-closed-range#kotlin.ranges.ULongProgression.Companion%24fromClosedRange%28kotlin.ULong%2C+kotlin.ULong%2C+kotlin.Long%29%2Fstep&quot;&gt;step&lt;/a&gt; must be negative.</source>
          <target state="translated">진행은 &lt;a href=&quot;from-closed-range#kotlin.ranges.ULongProgression.Companion%24fromClosedRange%28kotlin.ULong%2C+kotlin.ULong%2C+kotlin.Long%29%2FrangeStart&quot;&gt;rangeStart&lt;/a&gt; 값으로 시작 하여 지정된 &lt;a href=&quot;from-closed-range#kotlin.ranges.ULongProgression.Companion%24fromClosedRange%28kotlin.ULong%2C+kotlin.ULong%2C+kotlin.Long%29%2Fstep&quot;&gt;step을&lt;/a&gt; 제외 하고 &lt;a href=&quot;from-closed-range#kotlin.ranges.ULongProgression.Companion%24fromClosedRange%28kotlin.ULong%2C+kotlin.ULong%2C+kotlin.Long%29%2FrangeEnd&quot;&gt;rangeEnd&lt;/a&gt; 값을 제외하고 진행 합니다. 뒤로 가려면 &lt;a href=&quot;from-closed-range#kotlin.ranges.ULongProgression.Companion%24fromClosedRange%28kotlin.ULong%2C+kotlin.ULong%2C+kotlin.Long%29%2Fstep&quot;&gt;단계&lt;/a&gt; 가 음수 여야합니다.</target>
        </trans-unit>
        <trans-unit id="f35887cf67bb91d63b75657011139a4b8f31176b" translate="yes" xml:space="preserve">
          <source>The project file configures the C interop as an additional step of the build. Let's move the &lt;code&gt;interop.def&lt;/code&gt; file to the &lt;code&gt;src/nativeInterop/cinterop&lt;/code&gt; directory. Gradle recommends using conventions instead of configurations, for example, the source files are expected to be in the &lt;code&gt;src/nativeMain/kotlin&lt;/code&gt; folder. By default, all the symbols from C are imported to the &lt;code&gt;interop&lt;/code&gt; package, we may want to import the whole package in our &lt;code&gt;.kt&lt;/code&gt; files. Check out the &lt;a href=&quot;../../reference/building-mpp-with-gradle&quot;&gt;kotlin-multiplatform&lt;/a&gt; plugin documentation to learn about all the different ways you could configure it.</source>
          <target state="translated">프로젝트 파일은 C interop을 빌드의 추가 단계로 구성합니다. &lt;code&gt;interop.def&lt;/code&gt; 파일을 &lt;code&gt;src/nativeInterop/cinterop&lt;/code&gt; 디렉토리 로 이동하십시오 . Gradle은 구성 대신 규칙을 사용하는 것이 좋습니다. 예를 들어 소스 파일은 &lt;code&gt;src/nativeMain/kotlin&lt;/code&gt; 폴더에 있어야 합니다. 기본적으로 C의 모든 심볼을 &lt;code&gt;interop&lt;/code&gt; 패키지로 가져옵니다. 전체 패키지를 &lt;code&gt;.kt&lt;/code&gt; 파일 로 가져 오는 것이 좋습니다 . &lt;a href=&quot;../../reference/building-mpp-with-gradle&quot;&gt;kotlin-multiplatform&lt;/a&gt; 플러그인 문서를 확인하여 구성 할 수있는 모든 다른 방법에 대해 알아보십시오.</target>
        </trans-unit>
        <trans-unit id="04a29f21fc01df00a35820fecf66f137da298242" translate="yes" xml:space="preserve">
          <source>The project is ready. The next step is to open it in IntelliJ IDEA. For advanced build scenarios, it is recommended to refer to the &lt;a href=&quot;../../reference/building-mpp-with-gradle#setting-up-a-multiplatform-project&quot;&gt;more detailed&lt;/a&gt; documentation.</source>
          <target state="translated">프로젝트가 준비되었습니다. 다음 단계는 IntelliJ IDEA에서 여는 것입니다. 고급 빌드 시나리오의 경우 &lt;a href=&quot;../../reference/building-mpp-with-gradle#setting-up-a-multiplatform-project&quot;&gt;자세한&lt;/a&gt; 문서 를 참조하는 것이 좋습니다 .</target>
        </trans-unit>
        <trans-unit id="b358195ade68af7da060ed2c5bd98eb5f625c0a9" translate="yes" xml:space="preserve">
          <source>The project source roots</source>
          <target state="translated">프로젝트 소스 루트</target>
        </trans-unit>
        <trans-unit id="6b692a2a5504099d52b9ee1d8cd9e82682b0438b" translate="yes" xml:space="preserve">
          <source>The project structure looks like this:</source>
          <target state="translated">프로젝트 구조는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="85001da371d8ff3d4160eee8edd3719f9a8a82c8" translate="yes" xml:space="preserve">
          <source>The project's source files are unchanged.</source>
          <target state="translated">프로젝트의 소스 파일은 변경되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="fe6d1020447b5badd7227ed9268d67a33471daca" translate="yes" xml:space="preserve">
          <source>The property that can be used as a placeholder for statements and values that are defined in JavaScript.</source>
          <target state="translated">JavaScript로 정의 된 명령문 및 값의 플레이스 홀더로 사용할 수있는 특성입니다.</target>
        </trans-unit>
        <trans-unit id="fe5ea5ce74d05b50ab08ac3eaf5980cd10f01114" translate="yes" xml:space="preserve">
          <source>The property which this accessor is originated from.</source>
          <target state="translated">이 접근자가 시작된 속성입니다.</target>
        </trans-unit>
        <trans-unit id="f478ed7d5b12b6f5e34c37814b287211378258c6" translate="yes" xml:space="preserve">
          <source>The provisions of the &lt;a href=&quot;kotlin-evolution&quot;&gt;Kotlin evolution policy&lt;/a&gt; fully apply only to components that have reached Full Stability (FS). From that point on incompatible changes have to be approved by the Language Committee.</source>
          <target state="translated">&lt;a href=&quot;kotlin-evolution&quot;&gt;Kotlin 진화 정책&lt;/a&gt; 의 조항은 전체 안정성 (FS)에 도달 한 구성 요소에만 완전히 적용됩니다. 그 시점부터 언어위원회는 호환되지 않는 변경 사항을 승인해야합니다.</target>
        </trans-unit>
        <trans-unit id="4e0268d689de7d5f78e70c6cb1e82a66dc683856" translate="yes" xml:space="preserve">
          <source>The publication of this target is handled by the Kotlin plugin and doesn't require the steps that are specific to the Java plugin, such as manually creating a publication and configuring it as &lt;code&gt;from(components.java)&lt;/code&gt;.</source>
          <target state="translated">이 대상의 공개는 Kotlin 플러그인에 의해 처리되며 공개를 수동으로 작성하고 &lt;code&gt;from(components.java)&lt;/code&gt; 로 구성하는 것과 같이 Java 플러그인에 특정한 단계가 필요하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="38341133c8abc06ea8b313769f8407419006fee4" translate="yes" xml:space="preserve">
          <source>The purpose of this code is to write out some text in the console. In order to use this from the browser, load it, preferably from inside an HTML page:</source>
          <target state="translated">이 코드의 목적은 콘솔에서 일부 텍스트를 작성하는 것입니다. 브라우저에서 이것을 사용하려면 HTML 페이지 내부에서로드하십시오.</target>
        </trans-unit>
        <trans-unit id="dc84bc4a3671f7fd39fcbdb5d811a4f7dfb04fdc" translate="yes" xml:space="preserve">
          <source>The quickest way to try out C API mapping is to have all C declarations in the &lt;code&gt;interop.def&lt;/code&gt; file, without creating any &lt;code&gt;.h&lt;/code&gt; of &lt;code&gt;.c&lt;/code&gt; files at all. Then place the C declarations in a &lt;code&gt;.def&lt;/code&gt; file after the special &lt;code&gt;---&lt;/code&gt; separator line:</source>
          <target state="translated">C의 API 매핑을 시도하는 가장 빠른 방법은 모든 C 선언하는 것입니다 &lt;code&gt;interop.def&lt;/code&gt; 의 어떤 생성하지 않고, 파일을 &lt;code&gt;.h&lt;/code&gt; 의 &lt;code&gt;.c&lt;/code&gt; 인 모든에서 파일을. 그런 다음 특수 &lt;code&gt;---&lt;/code&gt; 구분 기호 줄 뒤에 &lt;code&gt;.def&lt;/code&gt; 파일 에 C 선언을 배치하십시오 .</target>
        </trans-unit>
        <trans-unit id="086ba4582c0f9ff5d704a53067f7ea26f2bef36a" translate="yes" xml:space="preserve">
          <source>The range of indices in the input string where group was captured.</source>
          <target state="translated">그룹이 캡처 된 입력 문자열의 인덱스 범위입니다.</target>
        </trans-unit>
        <trans-unit id="d16563c64c4aedfc780b010fa9c5624f673175d2" translate="yes" xml:space="preserve">
          <source>The range of indices in the original string where match was captured.</source>
          <target state="translated">일치가 캡처 된 원래 문자열의 인덱스 범위입니다.</target>
        </trans-unit>
        <trans-unit id="199d1e88f27ba9b05b8adc73d8d822df0cadd36a" translate="yes" xml:space="preserve">
          <source>The read-only collection types are &lt;a href=&quot;generics#variance&quot;&gt;covariant&lt;/a&gt;. This means that, if a &lt;code&gt;Rectangle&lt;/code&gt; class inherits from &lt;code&gt;Shape&lt;/code&gt;, you can use a &lt;code&gt;List&amp;lt;Rectangle&amp;gt;&lt;/code&gt; anywhere the &lt;code&gt;List&amp;lt;Shape&amp;gt;&lt;/code&gt; is required. In other words, the collection types have the same subtyping relationship as the element types. Maps are covariant on the value type, but not on the key type.</source>
          <target state="translated">읽기 전용 콜렉션 유형은 &lt;a href=&quot;generics#variance&quot;&gt;공변량&lt;/a&gt; 입니다. 즉, &lt;code&gt;Rectangle&lt;/code&gt; 클래스가 &lt;code&gt;Shape&lt;/code&gt; 에서 상속되는 경우 &lt;code&gt;List&amp;lt;Shape&amp;gt;&lt;/code&gt; 이 필요한 곳이면 &lt;code&gt;List&amp;lt;Rectangle&amp;gt;&lt;/code&gt; 사용할 수 있습니다 . 즉, 컬렉션 유형은 요소 유형과 동일한 하위 유형 관계를 갖습니다. 지도는 값 유형에 대해 공변량이지만 키 유형에는 없습니다.</target>
        </trans-unit>
        <trans-unit id="2ddb83b3e5eaf3228b8ed04e27d5be844d1ede7b" translate="yes" xml:space="preserve">
          <source>The reason we're seeing the actual output is because the call &lt;code&gt;curl_easy_perform&lt;/code&gt; prints the result to the standard output. We could hide this using &lt;code&gt;curl_easy_setopt&lt;/code&gt;.</source>
          <target state="translated">실제 출력을 보는 이유는 &lt;code&gt;curl_easy_perform&lt;/code&gt; 호출 이 결과를 표준 출력에 인쇄 하기 때문 입니다. &lt;code&gt;curl_easy_setopt&lt;/code&gt; 를 사용하여 이것을 숨길 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="58ca5ea2bf2b7e6112a4ed6c521b74a4fb8e1b96" translate="yes" xml:space="preserve">
          <source>The reference is a value of type &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.reflect/-k-class/index&quot;&gt;KClass&lt;/a&gt;.</source>
          <target state="translated">참조는 &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.reflect/-k-class/index&quot;&gt;KClass&lt;/a&gt; 유형의 값입니다 .</target>
        </trans-unit>
        <trans-unit id="225d32a1d2d879830740b8e0770ecbbb02de2cc7" translate="yes" xml:space="preserve">
          <source>The referenced value. Gets the value or sets the new value. If new value is not null, and &lt;code&gt;this&lt;/code&gt; is frozen - it must be frozen or permanent object.</source>
          <target state="translated">참조 된 값. 값을 가져 오거나 새 값을 설정합니다. 새 값이 null이 아닌 경우 및 &lt;code&gt;this&lt;/code&gt; 냉동 - 그것은 냉동 또는 고정 된 물체해야합니다.</target>
        </trans-unit>
        <trans-unit id="9e1c9e946585f6c5b784f91adc26c58c91e5a3c2" translate="yes" xml:space="preserve">
          <source>The referenced value. Gets the value or sets the new value. If new value is not null, it must be frozen or permanent object.</source>
          <target state="translated">참조 된 값. 값을 가져 오거나 새 값을 설정합니다. 새 값이 null이 아닌 경우 고정되거나 영구 객체 여야합니다.</target>
        </trans-unit>
        <trans-unit id="04f24df5fbabe6af37ab1161e95151a96c9196e9" translate="yes" xml:space="preserve">
          <source>The repositories where the library will be published are added via the &lt;code&gt;repositories&lt;/code&gt; block in the &lt;code&gt;publishing { ... }&lt;/code&gt; DSL, as explained in &lt;a href=&quot;https://docs.gradle.org/current/userguide/publishing_maven.html#publishing_maven:repositories&quot;&gt;Maven Publish Plugin. Repositories&lt;/a&gt;.</source>
          <target state="translated">라이브러리가 게시 될 &lt;code&gt;repositories&lt;/code&gt; 는 &lt;a href=&quot;https://docs.gradle.org/current/userguide/publishing_maven.html#publishing_maven:repositories&quot;&gt;Maven Publish Plugin에&lt;/a&gt; 설명 된대로 &lt;code&gt;publishing { ... }&lt;/code&gt; DSL 의 리포지토리 블록을 통해 추가됩니다 . 리포지토리 .</target>
        </trans-unit>
        <trans-unit id="7ffbb195d8e128e52d788e2edb39be54dd761c55" translate="yes" xml:space="preserve">
          <source>The rest of the procedure works in exactly the same way as in Java.</source>
          <target state="translated">나머지 절차는 Java에서와 동일한 방식으로 작동합니다.</target>
        </trans-unit>
        <trans-unit id="81a9c69ffb22a2342532cf8251cc7d0415b9dbb2" translate="yes" xml:space="preserve">
          <source>The result is an object which represents a reference to the property (the &quot;Platonic ideal&quot; property, not a property on a particular instance). There's a type hierarchy for property objects: the base interface is &lt;code&gt;KProperty&lt;/code&gt;, which lets you get metadata about the property, such as its name and type. If you want to use the property object to read or modify the property's value in an object, you need to use a subinterface that specifies what kind of property it is. Immutable properties typically are &lt;code&gt;KProperty1&amp;lt;R, V&amp;gt;&lt;/code&gt;, and mutable properties typically are &lt;code&gt;KMutableProperty1&amp;lt;R, V&amp;gt;&lt;/code&gt;. Both of these are generic interfaces, with &lt;code&gt;R&lt;/code&gt; being the receiver type (the type on which the property is declared, in this case &lt;code&gt;Person&lt;/code&gt;) and &lt;code&gt;V&lt;/code&gt; being the type of the property's value.</source>
          <target state="translated">결과는 속성 (특정 인스턴스의 속성이 아닌 &quot;Platonic ideal&quot;속성)에 대한 참조를 나타내는 객체입니다. 속성 객체에 대한 유형 계층이 있습니다. 기본 인터페이스는 &lt;code&gt;KProperty&lt;/code&gt; 이며, 속성 및 속성과 같은 속성에 대한 메타 데이터를 가져올 수 있습니다. 속성 개체를 사용하여 개체의 속성 값을 읽거나 수정하려면 속성의 종류를 지정하는 하위 인터페이스를 사용해야합니다. 불변 속성은 일반적으로 &lt;code&gt;KProperty1&amp;lt;R, V&amp;gt;&lt;/code&gt; 이며, 불변 속성은 일반적으로 &lt;code&gt;KMutableProperty1&amp;lt;R, V&amp;gt;&lt;/code&gt; 입니다. 둘 다 일반 인터페이스이며 &lt;code&gt;R&lt;/code&gt; 은 수신자 유형 (속성이 선언 된 유형 (이 경우 &lt;code&gt;Person&lt;/code&gt; ) 임)) 및 &lt;code&gt;V&lt;/code&gt; 는 속성 값의 유형입니다.</target>
        </trans-unit>
        <trans-unit id="1a8aae926c8fa4cd902ab72788ba84f110e52d36" translate="yes" xml:space="preserve">
          <source>The result is computed as &lt;code&gt;r = this - (q * divisor)&lt;/code&gt; where &lt;code&gt;q&lt;/code&gt; is the quotient of division rounded to the nearest integer, &lt;code&gt;q = round(this / other)&lt;/code&gt;.</source>
          <target state="translated">결과는 &lt;code&gt;r = this - (q * divisor)&lt;/code&gt; 로 계산됩니다. 여기서 &lt;code&gt;q&lt;/code&gt; 는 가장 가까운 정수로 반올림 한 몫의 정수입니다. &lt;code&gt;q = round(this / other)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8346187656aa601c46c1b882160101b5d70d1783" translate="yes" xml:space="preserve">
          <source>The result is going to be:</source>
          <target state="translated">결과는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="f757614cb2200a5a31db5b9a50190e9f1a783287" translate="yes" xml:space="preserve">
          <source>The result is the same, but this code uses only non-blocking &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/delay.html&quot;&gt;delay&lt;/a&gt;. The main thread invoking &lt;code&gt;runBlocking&lt;/code&gt;&lt;em&gt;blocks&lt;/em&gt; until the coroutine inside &lt;code&gt;runBlocking&lt;/code&gt; completes.</source>
          <target state="translated">결과는 동일하지만이 코드는 비 블로킹 &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/delay.html&quot;&gt;지연&lt;/a&gt; 만 사용합니다 . 호출 메인 스레드 &lt;code&gt;runBlocking&lt;/code&gt; &lt;em&gt;블록&lt;/em&gt; 내부의 코 루틴까지 &lt;code&gt;runBlocking&lt;/code&gt; 의 완료.</target>
        </trans-unit>
        <trans-unit id="80513416e38e21b1cd6b19983bdbc1cd0f8dbc1d" translate="yes" xml:space="preserve">
          <source>The result of &lt;code&gt;minus&lt;/code&gt; contains the elements of the original collection &lt;em&gt;except&lt;/em&gt; the elements from the second operand. If it's an element, &lt;code&gt;minus&lt;/code&gt; removes its &lt;em&gt;first&lt;/em&gt; occurrence; if it's a collection, &lt;em&gt;all&lt;/em&gt; occurrences of its elements are removed.</source>
          <target state="translated">&lt;code&gt;minus&lt;/code&gt; 결과 에는 두 번째 피연산자의 요소를 &lt;em&gt;제외하고&lt;/em&gt; 원래 컬렉션 의 요소가 포함됩니다. 요소 인 경우 &lt;code&gt;minus&lt;/code&gt; 하면 &lt;em&gt;첫 번째&lt;/em&gt; 항목이 제거됩니다 . 이 콜렉션의 경우, &lt;em&gt;모든&lt;/em&gt; 요소의 발생이 제거됩니다.</target>
        </trans-unit>
        <trans-unit id="9f4386a5cc0897ae566404e34449e10c9271784f" translate="yes" xml:space="preserve">
          <source>The result of &lt;code&gt;plus&lt;/code&gt; contains the elements from the original collection &lt;em&gt;and&lt;/em&gt; from the second operand.</source>
          <target state="translated">&lt;code&gt;plus&lt;/code&gt; 결과 에는 원래 컬렉션 &lt;em&gt;과&lt;/em&gt; 두 번째 피연산자 의 요소가 포함 됩니다.</target>
        </trans-unit>
        <trans-unit id="ff8add7f5e14fd024c26ef191ab483a18b621fed" translate="yes" xml:space="preserve">
          <source>The result of the future computation. Blocks execution until the future is ready. Second attempt to get will result in an error.</source>
          <target state="translated">미래 계산의 결과. 미래가 준비 될 때까지 실행을 차단합니다. 두 번째로 시도하면 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="b0a33939298c1573b79334a09954b9afb450d438" translate="yes" xml:space="preserve">
          <source>The result of this code is quite interesting, so we'll analyze it in mode detail:</source>
          <target state="translated">이 코드의 결과는 매우 흥미 롭기 때문에 모드를 자세히 분석 할 것입니다.</target>
        </trans-unit>
        <trans-unit id="a92982b6e3242403fa82d0db42fdb4534028b312" translate="yes" xml:space="preserve">
          <source>The result of this code is:</source>
          <target state="translated">이 코드의 결과는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="ee6868c39ff4d2539255b06db5a2381813300a75" translate="yes" xml:space="preserve">
          <source>The result of this code:</source>
          <target state="translated">이 코드의 결과는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="4844d20ae5c2024023a55c2b6b3214cb6ce72593" translate="yes" xml:space="preserve">
          <source>The resulting &lt;a href=&quot;http://docs.oracle.com/javase/8/docs/api/java/util/SortedMap.html&quot;&gt;SortedMap&lt;/a&gt; determines the equality and order of keys according to their natural sorting order.</source>
          <target state="translated">결과 &lt;a href=&quot;http://docs.oracle.com/javase/8/docs/api/java/util/SortedMap.html&quot;&gt;SortedMap&lt;/a&gt; 은 자연 정렬 순서에 따라 키의 동등성과 순서를 결정합니다.</target>
        </trans-unit>
        <trans-unit id="8f890bef6e41ea49023cd4e145c9ac8e02777347" translate="yes" xml:space="preserve">
          <source>The resulting &lt;code&gt;Byte&lt;/code&gt; value has the same binary representation as this &lt;code&gt;UByte&lt;/code&gt; value.</source>
          <target state="translated">결과 &lt;code&gt;Byte&lt;/code&gt; 값은이 &lt;code&gt;UByte&lt;/code&gt; 값 과 동일한 이진 표현을 갖습니다 .</target>
        </trans-unit>
        <trans-unit id="bcc21fce83c8a76fb70c4188dec066655dc99e5f" translate="yes" xml:space="preserve">
          <source>The resulting &lt;code&gt;Byte&lt;/code&gt; value is equal to &lt;code&gt;this.toInt().toByte()&lt;/code&gt;.</source>
          <target state="translated">결과 &lt;code&gt;Byte&lt;/code&gt; 값은 &lt;code&gt;this.toInt().toByte()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="500fd389152dfac3d3a3bdf516db69049b6112d1" translate="yes" xml:space="preserve">
          <source>The resulting &lt;code&gt;Byte&lt;/code&gt; value is represented by the least significant 8 bits of this &lt;code&gt;Int&lt;/code&gt; value.</source>
          <target state="translated">결과 &lt;code&gt;Byte&lt;/code&gt; 값은이 &lt;code&gt;Int&lt;/code&gt; 값 의 최하위 8 비트로 표시됩니다 .</target>
        </trans-unit>
        <trans-unit id="f5d708d0dd756dc92bd87189470b9a3b0f187bad" translate="yes" xml:space="preserve">
          <source>The resulting &lt;code&gt;Byte&lt;/code&gt; value is represented by the least significant 8 bits of this &lt;code&gt;Long&lt;/code&gt; value.</source>
          <target state="translated">결과 &lt;code&gt;Byte&lt;/code&gt; 값은이 &lt;code&gt;Long&lt;/code&gt; 값 의 최하위 8 비트로 표시됩니다 .</target>
        </trans-unit>
        <trans-unit id="f1c617d1ad1ce5e0250376516d3fc7acee8c76a7" translate="yes" xml:space="preserve">
          <source>The resulting &lt;code&gt;Byte&lt;/code&gt; value is represented by the least significant 8 bits of this &lt;code&gt;Short&lt;/code&gt; value.</source>
          <target state="translated">결과 &lt;code&gt;Byte&lt;/code&gt; 값은이 &lt;code&gt;Short&lt;/code&gt; 값 의 최하위 8 비트로 표시됩니다 .</target>
        </trans-unit>
        <trans-unit id="3c0aa6565c5cc7948d96b6aa45e671f5d970085c" translate="yes" xml:space="preserve">
          <source>The resulting &lt;code&gt;Byte&lt;/code&gt; value is represented by the least significant 8 bits of this &lt;code&gt;UInt&lt;/code&gt; value. Note that the resulting &lt;code&gt;Byte&lt;/code&gt; value may be negative.</source>
          <target state="translated">결과 &lt;code&gt;Byte&lt;/code&gt; 값은이 &lt;code&gt;UInt&lt;/code&gt; 값 의 최하위 8 비트로 표시됩니다 . 결과 &lt;code&gt;Byte&lt;/code&gt; 값은 음수 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="dd46bb58530a520cf29001659a58a32130329b50" translate="yes" xml:space="preserve">
          <source>The resulting &lt;code&gt;Byte&lt;/code&gt; value is represented by the least significant 8 bits of this &lt;code&gt;ULong&lt;/code&gt; value. Note that the resulting &lt;code&gt;Byte&lt;/code&gt; value may be negative.</source>
          <target state="translated">결과 &lt;code&gt;Byte&lt;/code&gt; 값은이 &lt;code&gt;ULong&lt;/code&gt; 값 의 최하위 8 비트로 표시됩니다 . 결과 &lt;code&gt;Byte&lt;/code&gt; 값은 음수 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f0796ad9fb92ce12d111b3b2e535fa3a4138ff67" translate="yes" xml:space="preserve">
          <source>The resulting &lt;code&gt;Byte&lt;/code&gt; value is represented by the least significant 8 bits of this &lt;code&gt;UShort&lt;/code&gt; value. Note that the resulting &lt;code&gt;Byte&lt;/code&gt; value may be negative.</source>
          <target state="translated">결과 &lt;code&gt;Byte&lt;/code&gt; 값은이 &lt;code&gt;UShort&lt;/code&gt; 값 의 최하위 8 비트로 표시됩니다 . 결과 &lt;code&gt;Byte&lt;/code&gt; 값은 음수 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1dcececb10dcdcffc92e35f3fc84338088990b5d" translate="yes" xml:space="preserve">
          <source>The resulting &lt;code&gt;Char&lt;/code&gt; code is equal to this value reinterpreted as an unsigned number, i.e. it has the same binary representation as this &lt;code&gt;Short&lt;/code&gt;.</source>
          <target state="translated">결과 &lt;code&gt;Char&lt;/code&gt; 코드는 부호없는 숫자로 재 해석 된이 값과 같습니다. 즉,이 &lt;code&gt;Short&lt;/code&gt; 와 동일한 이진 표현이 있습니다.</target>
        </trans-unit>
        <trans-unit id="7d3990133293f18f718906ea26c50d316e7978f0" translate="yes" xml:space="preserve">
          <source>The resulting &lt;code&gt;Char&lt;/code&gt; code is represented by the least significant 16 bits of this &lt;code&gt;Int&lt;/code&gt; value.</source>
          <target state="translated">결과 &lt;code&gt;Char&lt;/code&gt; 코드는이 &lt;code&gt;Int&lt;/code&gt; 값 의 최하위 16 비트로 표시됩니다 .</target>
        </trans-unit>
        <trans-unit id="8e5f25cf2555e851681e56711455629d8b96cc85" translate="yes" xml:space="preserve">
          <source>The resulting &lt;code&gt;Char&lt;/code&gt; code is represented by the least significant 16 bits of this &lt;code&gt;Long&lt;/code&gt; value.</source>
          <target state="translated">결과 &lt;code&gt;Char&lt;/code&gt; 코드는이 &lt;code&gt;Long&lt;/code&gt; 값 의 최하위 16 비트로 표시됩니다 .</target>
        </trans-unit>
        <trans-unit id="7c93c7f205f664c42eb53e198c38febdd8681e8c" translate="yes" xml:space="preserve">
          <source>The resulting &lt;code&gt;Char&lt;/code&gt; value is equal to &lt;code&gt;this.toInt().toChar()&lt;/code&gt;.</source>
          <target state="translated">결과 &lt;code&gt;Char&lt;/code&gt; 값은 &lt;code&gt;this.toInt().toChar()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="fb0bee6e823fc7a039aaeeb4e2cf6ccadd56cad2" translate="yes" xml:space="preserve">
          <source>The resulting &lt;code&gt;Double&lt;/code&gt; value represents the same numerical value as this &lt;code&gt;Byte&lt;/code&gt;.</source>
          <target state="translated">결과 &lt;code&gt;Double&lt;/code&gt; 값은이 &lt;code&gt;Byte&lt;/code&gt; 와 동일한 숫자 값을 나타냅니다 .</target>
        </trans-unit>
        <trans-unit id="ec044076f69f3a9e4c8c326707b213be48dbdf4c" translate="yes" xml:space="preserve">
          <source>The resulting &lt;code&gt;Double&lt;/code&gt; value represents the same numerical value as this &lt;code&gt;Float&lt;/code&gt;.</source>
          <target state="translated">결과 &lt;code&gt;Double&lt;/code&gt; 값은이 &lt;code&gt;Float&lt;/code&gt; 와 동일한 숫자 값을 나타냅니다 .</target>
        </trans-unit>
        <trans-unit id="413cc395d49c3c9b688aa7288d432c1583480097" translate="yes" xml:space="preserve">
          <source>The resulting &lt;code&gt;Double&lt;/code&gt; value represents the same numerical value as this &lt;code&gt;Int&lt;/code&gt;.</source>
          <target state="translated">결과 &lt;code&gt;Double&lt;/code&gt; 값은이 &lt;code&gt;Int&lt;/code&gt; 와 동일한 숫자 값을 나타냅니다 .</target>
        </trans-unit>
        <trans-unit id="e04c116c448cef44fd49f1d1da49c8be72cf833e" translate="yes" xml:space="preserve">
          <source>The resulting &lt;code&gt;Double&lt;/code&gt; value represents the same numerical value as this &lt;code&gt;Short&lt;/code&gt;.</source>
          <target state="translated">결과 &lt;code&gt;Double&lt;/code&gt; 값은이 &lt;code&gt;Short&lt;/code&gt; 와 동일한 숫자 값을 나타냅니다 .</target>
        </trans-unit>
        <trans-unit id="624ad9cad2fadf7c5df7034160380cba9b36827a" translate="yes" xml:space="preserve">
          <source>The resulting &lt;code&gt;Double&lt;/code&gt; value represents the same numerical value as this &lt;code&gt;UByte&lt;/code&gt;.</source>
          <target state="translated">결과 &lt;code&gt;Double&lt;/code&gt; 값은이 &lt;code&gt;UByte&lt;/code&gt; 와 동일한 숫자 값을 나타냅니다 .</target>
        </trans-unit>
        <trans-unit id="e233d00009204b3d8e16f6c4faaeb29b610dd152" translate="yes" xml:space="preserve">
          <source>The resulting &lt;code&gt;Double&lt;/code&gt; value represents the same numerical value as this &lt;code&gt;UInt&lt;/code&gt;.</source>
          <target state="translated">결과 &lt;code&gt;Double&lt;/code&gt; 값은이 &lt;code&gt;UInt&lt;/code&gt; 와 동일한 숫자 값을 나타냅니다 .</target>
        </trans-unit>
        <trans-unit id="be9fd1536c9016ec165d93e9e044c6403df23d59" translate="yes" xml:space="preserve">
          <source>The resulting &lt;code&gt;Double&lt;/code&gt; value represents the same numerical value as this &lt;code&gt;UShort&lt;/code&gt;.</source>
          <target state="translated">결과 &lt;code&gt;Double&lt;/code&gt; 값은이 &lt;code&gt;UShort&lt;/code&gt; 와 동일한 숫자 값을 나타냅니다 .</target>
        </trans-unit>
        <trans-unit id="ae244f9a05312104462c229a2e3a4a4de64be4e1" translate="yes" xml:space="preserve">
          <source>The resulting &lt;code&gt;Float&lt;/code&gt; value represents the same numerical value as this &lt;code&gt;Byte&lt;/code&gt;.</source>
          <target state="translated">결과 &lt;code&gt;Float&lt;/code&gt; 값은이 &lt;code&gt;Byte&lt;/code&gt; 와 동일한 숫자 값을 나타냅니다 .</target>
        </trans-unit>
        <trans-unit id="f8088fd36ea4c2c1efeb80cfa5d2e317eb476320" translate="yes" xml:space="preserve">
          <source>The resulting &lt;code&gt;Float&lt;/code&gt; value represents the same numerical value as this &lt;code&gt;Short&lt;/code&gt;.</source>
          <target state="translated">결과 &lt;code&gt;Float&lt;/code&gt; 값은이 &lt;code&gt;Short&lt;/code&gt; 와 동일한 숫자 값을 나타냅니다 .</target>
        </trans-unit>
        <trans-unit id="f353ad75e4345f7f3c16a80f19361bddd53a4f67" translate="yes" xml:space="preserve">
          <source>The resulting &lt;code&gt;Float&lt;/code&gt; value represents the same numerical value as this &lt;code&gt;UByte&lt;/code&gt;.</source>
          <target state="translated">결과 &lt;code&gt;Float&lt;/code&gt; 값은이 &lt;code&gt;UByte&lt;/code&gt; 와 동일한 숫자 값을 나타냅니다 .</target>
        </trans-unit>
        <trans-unit id="abac5ba157cb93c8f101ff3e6ab497cfac17749a" translate="yes" xml:space="preserve">
          <source>The resulting &lt;code&gt;Float&lt;/code&gt; value represents the same numerical value as this &lt;code&gt;UShort&lt;/code&gt;.</source>
          <target state="translated">결과 &lt;code&gt;Float&lt;/code&gt; 값은이 &lt;code&gt;UShort&lt;/code&gt; 와 동일한 숫자 값을 나타냅니다 .</target>
        </trans-unit>
        <trans-unit id="9d03c1143daecc3b8a141860933f0a92adb18b37" translate="yes" xml:space="preserve">
          <source>The resulting &lt;code&gt;Int&lt;/code&gt; value has the same binary representation as this &lt;code&gt;UInt&lt;/code&gt; value.</source>
          <target state="translated">결과 &lt;code&gt;Int&lt;/code&gt; 값은이 &lt;code&gt;UInt&lt;/code&gt; 값 과 동일한 이진 표현을 갖습니다 .</target>
        </trans-unit>
        <trans-unit id="6ff94aee825d38ae08d93f2ca58819f2a03d9747" translate="yes" xml:space="preserve">
          <source>The resulting &lt;code&gt;Int&lt;/code&gt; value is represented by the least significant 32 bits of this &lt;code&gt;Long&lt;/code&gt; value.</source>
          <target state="translated">결과 &lt;code&gt;Int&lt;/code&gt; 값은이 &lt;code&gt;Long&lt;/code&gt; 값 의 최하위 32 비트로 표시됩니다 .</target>
        </trans-unit>
        <trans-unit id="7a5d4e0dea3c1513f10c80d1128e159e3a009787" translate="yes" xml:space="preserve">
          <source>The resulting &lt;code&gt;Int&lt;/code&gt; value is represented by the least significant 32 bits of this &lt;code&gt;ULong&lt;/code&gt; value. Note that the resulting &lt;code&gt;Int&lt;/code&gt; value may be negative.</source>
          <target state="translated">결과 &lt;code&gt;Int&lt;/code&gt; 값은이 &lt;code&gt;ULong&lt;/code&gt; 값 의 최하위 32 비트로 표시됩니다 . 결과적인 &lt;code&gt;Int&lt;/code&gt; 값은 음수 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="134cc45d29d5c0611e6038571857feed8853b0ee" translate="yes" xml:space="preserve">
          <source>The resulting &lt;code&gt;Int&lt;/code&gt; value represents the same numerical value as this &lt;code&gt;Byte&lt;/code&gt;.</source>
          <target state="translated">결과 &lt;code&gt;Int&lt;/code&gt; 값은이 &lt;code&gt;Byte&lt;/code&gt; 와 동일한 숫자 값을 나타냅니다 .</target>
        </trans-unit>
        <trans-unit id="a8d60bc3ef88b39460060b7f8165763da80802bc" translate="yes" xml:space="preserve">
          <source>The resulting &lt;code&gt;Int&lt;/code&gt; value represents the same numerical value as this &lt;code&gt;Short&lt;/code&gt;.</source>
          <target state="translated">결과 &lt;code&gt;Int&lt;/code&gt; 값은이 &lt;code&gt;Short&lt;/code&gt; 와 동일한 숫자 값을 나타냅니다 .</target>
        </trans-unit>
        <trans-unit id="12aaa5ec83610d73b4b2fc195902417a297ddd61" translate="yes" xml:space="preserve">
          <source>The resulting &lt;code&gt;Int&lt;/code&gt; value represents the same numerical value as this &lt;code&gt;UByte&lt;/code&gt;.</source>
          <target state="translated">결과 &lt;code&gt;Int&lt;/code&gt; 값은이 &lt;code&gt;UByte&lt;/code&gt; 와 동일한 숫자 값을 나타냅니다 .</target>
        </trans-unit>
        <trans-unit id="b30712342fda907bc49df4d10c136bbeeaaf708b" translate="yes" xml:space="preserve">
          <source>The resulting &lt;code&gt;Int&lt;/code&gt; value represents the same numerical value as this &lt;code&gt;UShort&lt;/code&gt;.</source>
          <target state="translated">결과 &lt;code&gt;Int&lt;/code&gt; 값은이 &lt;code&gt;UShort&lt;/code&gt; 와 동일한 숫자 값을 나타냅니다 .</target>
        </trans-unit>
        <trans-unit id="25bcbeae5576ececd431ec0f451a2c7cf6bf73b4" translate="yes" xml:space="preserve">
          <source>The resulting &lt;code&gt;Long&lt;/code&gt; value has the same binary representation as this &lt;code&gt;ULong&lt;/code&gt; value.</source>
          <target state="translated">결과 &lt;code&gt;Long&lt;/code&gt; 값은이 &lt;code&gt;ULong&lt;/code&gt; 값 과 동일한 이진 표현을 갖습니다 .</target>
        </trans-unit>
        <trans-unit id="e6a0efc4ac5c4b05735980342faa240209bf9353" translate="yes" xml:space="preserve">
          <source>The resulting &lt;code&gt;Long&lt;/code&gt; value represents the same numerical value as this &lt;code&gt;Byte&lt;/code&gt;.</source>
          <target state="translated">결과 &lt;code&gt;Long&lt;/code&gt; 값은이 &lt;code&gt;Byte&lt;/code&gt; 와 동일한 숫자 값을 나타냅니다 .</target>
        </trans-unit>
        <trans-unit id="a30381cf3452bf71d4466b6a6a9c5a35e959654a" translate="yes" xml:space="preserve">
          <source>The resulting &lt;code&gt;Long&lt;/code&gt; value represents the same numerical value as this &lt;code&gt;Int&lt;/code&gt;.</source>
          <target state="translated">결과 &lt;code&gt;Long&lt;/code&gt; 값은이 &lt;code&gt;Int&lt;/code&gt; 와 동일한 숫자 값을 나타냅니다 .</target>
        </trans-unit>
        <trans-unit id="7692c28294ebe4518a8808f192338ab899b5aeec" translate="yes" xml:space="preserve">
          <source>The resulting &lt;code&gt;Long&lt;/code&gt; value represents the same numerical value as this &lt;code&gt;Short&lt;/code&gt;.</source>
          <target state="translated">결과 &lt;code&gt;Long&lt;/code&gt; 값은이 &lt;code&gt;Short&lt;/code&gt; 와 동일한 숫자 값을 나타냅니다 .</target>
        </trans-unit>
        <trans-unit id="60b7e7e3ba10c2b92827e84db685cc040e179ed1" translate="yes" xml:space="preserve">
          <source>The resulting &lt;code&gt;Long&lt;/code&gt; value represents the same numerical value as this &lt;code&gt;UByte&lt;/code&gt;.</source>
          <target state="translated">결과 &lt;code&gt;Long&lt;/code&gt; 값은이 &lt;code&gt;UByte&lt;/code&gt; 와 동일한 숫자 값을 나타냅니다 .</target>
        </trans-unit>
        <trans-unit id="a95d7e6a557f4530d701aed1a8410d9b6e793205" translate="yes" xml:space="preserve">
          <source>The resulting &lt;code&gt;Long&lt;/code&gt; value represents the same numerical value as this &lt;code&gt;UInt&lt;/code&gt;.</source>
          <target state="translated">결과 &lt;code&gt;Long&lt;/code&gt; 값은이 &lt;code&gt;UInt&lt;/code&gt; 와 동일한 숫자 값을 나타냅니다 .</target>
        </trans-unit>
        <trans-unit id="e900373f53d6267fd01ecf92bb2c5cb1fed9a7b7" translate="yes" xml:space="preserve">
          <source>The resulting &lt;code&gt;Long&lt;/code&gt; value represents the same numerical value as this &lt;code&gt;UShort&lt;/code&gt;.</source>
          <target state="translated">결과 &lt;code&gt;Long&lt;/code&gt; 값은이 &lt;code&gt;UShort&lt;/code&gt; 와 동일한 숫자 값을 나타냅니다 .</target>
        </trans-unit>
        <trans-unit id="3866529acc183dc8b682af92a84909ec65bd5749" translate="yes" xml:space="preserve">
          <source>The resulting &lt;code&gt;Short&lt;/code&gt; value has the same binary representation as this &lt;code&gt;UShort&lt;/code&gt; value.</source>
          <target state="translated">결과 &lt;code&gt;Short&lt;/code&gt; 값은이 &lt;code&gt;UShort&lt;/code&gt; 값 과 동일한 이진 표현을 갖습니다 .</target>
        </trans-unit>
        <trans-unit id="5ccfa5aff935ee9326f2b407c585467d126768e7" translate="yes" xml:space="preserve">
          <source>The resulting &lt;code&gt;Short&lt;/code&gt; value is equal to &lt;code&gt;this.toInt().toShort()&lt;/code&gt;.</source>
          <target state="translated">결과 &lt;code&gt;Short&lt;/code&gt; 값은 &lt;code&gt;this.toInt().toShort()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="fb338e05b22f496cc978d6bf212ddabde5dd17a4" translate="yes" xml:space="preserve">
          <source>The resulting &lt;code&gt;Short&lt;/code&gt; value is represented by the least significant 16 bits of this &lt;code&gt;Int&lt;/code&gt; value.</source>
          <target state="translated">결과 &lt;code&gt;Short&lt;/code&gt; 값은이 &lt;code&gt;Int&lt;/code&gt; 값 의 최하위 16 비트로 표시됩니다 .</target>
        </trans-unit>
        <trans-unit id="27367d77acd56c6a1050bc0a49a57fcf2061de96" translate="yes" xml:space="preserve">
          <source>The resulting &lt;code&gt;Short&lt;/code&gt; value is represented by the least significant 16 bits of this &lt;code&gt;Long&lt;/code&gt; value.</source>
          <target state="translated">결과 &lt;code&gt;Short&lt;/code&gt; 값은이 &lt;code&gt;Long&lt;/code&gt; 값 의 최하위 16 비트로 표시됩니다 .</target>
        </trans-unit>
        <trans-unit id="0bc0fbdc70644d6d748c478656fa78e912cc16e6" translate="yes" xml:space="preserve">
          <source>The resulting &lt;code&gt;Short&lt;/code&gt; value is represented by the least significant 16 bits of this &lt;code&gt;UInt&lt;/code&gt; value. Note that the resulting &lt;code&gt;Short&lt;/code&gt; value may be negative.</source>
          <target state="translated">결과 &lt;code&gt;Short&lt;/code&gt; 값은이 &lt;code&gt;UInt&lt;/code&gt; 값 의 최하위 16 비트로 표시됩니다 . 결과 &lt;code&gt;Short&lt;/code&gt; 값은 음수 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="bb9494a50b8985a2d74ddd24ec83038bdcd4606a" translate="yes" xml:space="preserve">
          <source>The resulting &lt;code&gt;Short&lt;/code&gt; value is represented by the least significant 16 bits of this &lt;code&gt;ULong&lt;/code&gt; value. Note that the resulting &lt;code&gt;Short&lt;/code&gt; value may be negative.</source>
          <target state="translated">결과 &lt;code&gt;Short&lt;/code&gt; 값은이 &lt;code&gt;ULong&lt;/code&gt; 값 의 최하위 16 비트로 표시됩니다 . 결과 &lt;code&gt;Short&lt;/code&gt; 값은 음수 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1fbe35f845af4aa0feff1d9060ab35a7c6fe3476" translate="yes" xml:space="preserve">
          <source>The resulting &lt;code&gt;Short&lt;/code&gt; value represents the same numerical value as this &lt;code&gt;Byte&lt;/code&gt;.</source>
          <target state="translated">결과 &lt;code&gt;Short&lt;/code&gt; 값은이 &lt;code&gt;Byte&lt;/code&gt; 와 동일한 숫자 값을 나타냅니다 .</target>
        </trans-unit>
        <trans-unit id="62163dcead131c0bf0933b1342f420db3bc4bb8d" translate="yes" xml:space="preserve">
          <source>The resulting &lt;code&gt;Short&lt;/code&gt; value represents the same numerical value as this &lt;code&gt;UByte&lt;/code&gt;.</source>
          <target state="translated">결과 &lt;code&gt;Short&lt;/code&gt; 값은이 &lt;code&gt;UByte&lt;/code&gt; 와 동일한 숫자 값을 나타냅니다 .</target>
        </trans-unit>
        <trans-unit id="26c6a5634d9e1d8b962bb6788ae67bc866b78e45" translate="yes" xml:space="preserve">
          <source>The resulting &lt;code&gt;UByte&lt;/code&gt; value has the same binary representation as this &lt;code&gt;Byte&lt;/code&gt; value.</source>
          <target state="translated">결과 &lt;code&gt;UByte&lt;/code&gt; 값은이 &lt;code&gt;Byte&lt;/code&gt; 값 과 동일한 이진 표현을 갖습니다.</target>
        </trans-unit>
        <trans-unit id="11d5b691a4a978c7af952b604f7d065d5eac1305" translate="yes" xml:space="preserve">
          <source>The resulting &lt;code&gt;UByte&lt;/code&gt; value is represented by the least significant 8 bits of this &lt;code&gt;Int&lt;/code&gt; value.</source>
          <target state="translated">결과 &lt;code&gt;UByte&lt;/code&gt; 값은이 &lt;code&gt;Int&lt;/code&gt; 값 의 최하위 8 비트로 표시됩니다 .</target>
        </trans-unit>
        <trans-unit id="5226c83d79204652c28eff49e7528cb1e99fe2d6" translate="yes" xml:space="preserve">
          <source>The resulting &lt;code&gt;UByte&lt;/code&gt; value is represented by the least significant 8 bits of this &lt;code&gt;Long&lt;/code&gt; value.</source>
          <target state="translated">결과 &lt;code&gt;UByte&lt;/code&gt; 값은이 &lt;code&gt;Long&lt;/code&gt; 값 의 최하위 8 비트로 표시됩니다 .</target>
        </trans-unit>
        <trans-unit id="726d8e3bdd3b093a08a44094c2cae4da994770da" translate="yes" xml:space="preserve">
          <source>The resulting &lt;code&gt;UByte&lt;/code&gt; value is represented by the least significant 8 bits of this &lt;code&gt;Short&lt;/code&gt; value.</source>
          <target state="translated">결과 &lt;code&gt;UByte&lt;/code&gt; 값은이 &lt;code&gt;Short&lt;/code&gt; 값 의 최하위 8 비트로 표시됩니다 .</target>
        </trans-unit>
        <trans-unit id="1dfb49e88d21be6bcb0f49bf822a5aaa6937a983" translate="yes" xml:space="preserve">
          <source>The resulting &lt;code&gt;UByte&lt;/code&gt; value is represented by the least significant 8 bits of this &lt;code&gt;UInt&lt;/code&gt; value.</source>
          <target state="translated">결과 &lt;code&gt;UByte&lt;/code&gt; 값은이 &lt;code&gt;UInt&lt;/code&gt; 값 의 최하위 8 비트로 표시됩니다 .</target>
        </trans-unit>
        <trans-unit id="2686cc59be2588fb1dc986c8db1acdab514c552c" translate="yes" xml:space="preserve">
          <source>The resulting &lt;code&gt;UByte&lt;/code&gt; value is represented by the least significant 8 bits of this &lt;code&gt;ULong&lt;/code&gt; value.</source>
          <target state="translated">결과 &lt;code&gt;UByte&lt;/code&gt; 값은이 &lt;code&gt;ULong&lt;/code&gt; 값 의 최하위 8 비트로 표시됩니다 .</target>
        </trans-unit>
        <trans-unit id="a5d21503bfa5cb9b99c854c368f0b66239678aba" translate="yes" xml:space="preserve">
          <source>The resulting &lt;code&gt;UByte&lt;/code&gt; value is represented by the least significant 8 bits of this &lt;code&gt;UShort&lt;/code&gt; value.</source>
          <target state="translated">결과 &lt;code&gt;UByte&lt;/code&gt; 값은이 &lt;code&gt;UShort&lt;/code&gt; 값 의 최하위 8 비트로 표시됩니다 .</target>
        </trans-unit>
        <trans-unit id="4f3fe5211f1aea05bea1a841d6d73788aeeb2998" translate="yes" xml:space="preserve">
          <source>The resulting &lt;code&gt;UInt&lt;/code&gt; value has the same binary representation as this &lt;code&gt;Int&lt;/code&gt; value.</source>
          <target state="translated">결과 &lt;code&gt;UInt&lt;/code&gt; 값은이 &lt;code&gt;Int&lt;/code&gt; 값 과 동일한 이진 표현을 갖습니다.</target>
        </trans-unit>
        <trans-unit id="66a1e76fd131680ad5406468e22ad3973f35ff4e" translate="yes" xml:space="preserve">
          <source>The resulting &lt;code&gt;UInt&lt;/code&gt; value is represented by the least significant 32 bits of this &lt;code&gt;Long&lt;/code&gt; value.</source>
          <target state="translated">결과 &lt;code&gt;UInt&lt;/code&gt; 값은이 &lt;code&gt;Long&lt;/code&gt; 값 의 최하위 32 비트로 표시됩니다 .</target>
        </trans-unit>
        <trans-unit id="bc935cba2a00e8cc63899ff18d12438a89739380" translate="yes" xml:space="preserve">
          <source>The resulting &lt;code&gt;UInt&lt;/code&gt; value is represented by the least significant 32 bits of this &lt;code&gt;ULong&lt;/code&gt; value.</source>
          <target state="translated">결과 &lt;code&gt;UInt&lt;/code&gt; 값은이 &lt;code&gt;ULong&lt;/code&gt; 값 의 최하위 32 비트로 표시됩니다 .</target>
        </trans-unit>
        <trans-unit id="9d9ba2608012da37a52b5b9b7da96f6d67796334" translate="yes" xml:space="preserve">
          <source>The resulting &lt;code&gt;UInt&lt;/code&gt; value represents the same numerical value as this &lt;code&gt;UByte&lt;/code&gt;.</source>
          <target state="translated">결과 &lt;code&gt;UInt&lt;/code&gt; 값은이 &lt;code&gt;UByte&lt;/code&gt; 와 동일한 숫자 값을 나타냅니다 .</target>
        </trans-unit>
        <trans-unit id="9ab12c98c1ea5502db93ef496727f7d48f4edc12" translate="yes" xml:space="preserve">
          <source>The resulting &lt;code&gt;UInt&lt;/code&gt; value represents the same numerical value as this &lt;code&gt;UShort&lt;/code&gt;.</source>
          <target state="translated">결과 &lt;code&gt;UInt&lt;/code&gt; 값은이 &lt;code&gt;UShort&lt;/code&gt; 와 동일한 숫자 값을 나타냅니다 .</target>
        </trans-unit>
        <trans-unit id="e00a9f9829597db51c5f5f105c5c613e61839318" translate="yes" xml:space="preserve">
          <source>The resulting &lt;code&gt;ULong&lt;/code&gt; value has the same binary representation as this &lt;code&gt;Long&lt;/code&gt; value.</source>
          <target state="translated">결과 &lt;code&gt;ULong&lt;/code&gt; 값은이 &lt;code&gt;Long&lt;/code&gt; 값 과 동일한 이진 표현을 갖습니다.</target>
        </trans-unit>
        <trans-unit id="a5fe358a0a132b3d4ac886ee0067825836c972c3" translate="yes" xml:space="preserve">
          <source>The resulting &lt;code&gt;ULong&lt;/code&gt; value represents the same numerical value as this &lt;code&gt;UByte&lt;/code&gt;.</source>
          <target state="translated">결과 &lt;code&gt;ULong&lt;/code&gt; 값은이 &lt;code&gt;UByte&lt;/code&gt; 와 동일한 숫자 값을 나타냅니다 .</target>
        </trans-unit>
        <trans-unit id="1e225f6484184e1fd9b9a789c6be2168c16944f8" translate="yes" xml:space="preserve">
          <source>The resulting &lt;code&gt;ULong&lt;/code&gt; value represents the same numerical value as this &lt;code&gt;UInt&lt;/code&gt;.</source>
          <target state="translated">결과 &lt;code&gt;ULong&lt;/code&gt; 값은이 &lt;code&gt;UInt&lt;/code&gt; 와 동일한 숫자 값을 나타냅니다 .</target>
        </trans-unit>
        <trans-unit id="951d01157187c8755e4bb93be0ec662d70035ced" translate="yes" xml:space="preserve">
          <source>The resulting &lt;code&gt;ULong&lt;/code&gt; value represents the same numerical value as this &lt;code&gt;UShort&lt;/code&gt;.</source>
          <target state="translated">결과 &lt;code&gt;ULong&lt;/code&gt; 값은이 &lt;code&gt;UShort&lt;/code&gt; 와 동일한 숫자 값을 나타냅니다 .</target>
        </trans-unit>
        <trans-unit id="76c0754fefaa89b43d0e48e2d3b2efa1a3c37cac" translate="yes" xml:space="preserve">
          <source>The resulting &lt;code&gt;UShort&lt;/code&gt; value has the same binary representation as this &lt;code&gt;Short&lt;/code&gt; value.</source>
          <target state="translated">결과 &lt;code&gt;UShort&lt;/code&gt; 값은이 &lt;code&gt;Short&lt;/code&gt; 값 과 동일한 이진 표현을 갖습니다.</target>
        </trans-unit>
        <trans-unit id="ed25489ad27c7ad2fa4a9e9ed8a17e177ed921a7" translate="yes" xml:space="preserve">
          <source>The resulting &lt;code&gt;UShort&lt;/code&gt; value is represented by the least significant 16 bits of this &lt;code&gt;Int&lt;/code&gt; value.</source>
          <target state="translated">결과 &lt;code&gt;UShort&lt;/code&gt; 값은이 &lt;code&gt;Int&lt;/code&gt; 값 의 최하위 16 비트로 표시됩니다 .</target>
        </trans-unit>
        <trans-unit id="f42954d6785f3d5db6ef1809c504748ad3c8598b" translate="yes" xml:space="preserve">
          <source>The resulting &lt;code&gt;UShort&lt;/code&gt; value is represented by the least significant 16 bits of this &lt;code&gt;Long&lt;/code&gt; value.</source>
          <target state="translated">결과 &lt;code&gt;UShort&lt;/code&gt; 값은이 &lt;code&gt;Long&lt;/code&gt; 값 의 최하위 16 비트로 표시됩니다 .</target>
        </trans-unit>
        <trans-unit id="1457c7b3fcc5ff173b3ad803474b4e660273fb3a" translate="yes" xml:space="preserve">
          <source>The resulting &lt;code&gt;UShort&lt;/code&gt; value is represented by the least significant 16 bits of this &lt;code&gt;UInt&lt;/code&gt; value.</source>
          <target state="translated">결과 &lt;code&gt;UShort&lt;/code&gt; 값은이 &lt;code&gt;UInt&lt;/code&gt; 값 의 최하위 16 비트로 표시됩니다 .</target>
        </trans-unit>
        <trans-unit id="f4cfae00353cb363d45d034bd2773a412889ab06" translate="yes" xml:space="preserve">
          <source>The resulting &lt;code&gt;UShort&lt;/code&gt; value is represented by the least significant 16 bits of this &lt;code&gt;ULong&lt;/code&gt; value.</source>
          <target state="translated">결과 &lt;code&gt;UShort&lt;/code&gt; 값은이 &lt;code&gt;ULong&lt;/code&gt; 값 의 최하위 16 비트로 표시됩니다 .</target>
        </trans-unit>
        <trans-unit id="fd44eb3bc0245bda18586fe624c6aa7f2130c655" translate="yes" xml:space="preserve">
          <source>The resulting &lt;code&gt;UShort&lt;/code&gt; value represents the same numerical value as this &lt;code&gt;UByte&lt;/code&gt;.</source>
          <target state="translated">결과 &lt;code&gt;UShort&lt;/code&gt; 값은이 &lt;code&gt;UByte&lt;/code&gt; 와 동일한 숫자 값을 나타냅니다 .</target>
        </trans-unit>
        <trans-unit id="26ad7d1c46a7946f361222464d3fd9f54190f2e7" translate="yes" xml:space="preserve">
          <source>The resulting value is the closest &lt;code&gt;Double&lt;/code&gt; to this &lt;code&gt;Long&lt;/code&gt; value. In case when this &lt;code&gt;Long&lt;/code&gt; value is exactly between two &lt;code&gt;Double&lt;/code&gt;s, the one with zero at least significant bit of mantissa is selected.</source>
          <target state="translated">결과 값은 이 &lt;code&gt;Long&lt;/code&gt; 값에 가장 가까운 &lt;code&gt;Double&lt;/code&gt; 입니다. 이 &lt;code&gt;Long&lt;/code&gt; 값이 정확히 두 &lt;code&gt;Double&lt;/code&gt; 사이에 있는 경우 최소 유효 비트 비트가 0 인 값이 선택됩니다.</target>
        </trans-unit>
        <trans-unit id="492c13f0924f52f27eadd038e36be9a70c7d0f23" translate="yes" xml:space="preserve">
          <source>The resulting value is the closest &lt;code&gt;Double&lt;/code&gt; to this &lt;code&gt;ULong&lt;/code&gt; value. In case when this &lt;code&gt;ULong&lt;/code&gt; value is exactly between two &lt;code&gt;Double&lt;/code&gt;s, the one with zero at least significant bit of mantissa is selected.</source>
          <target state="translated">결과 값은 이 &lt;code&gt;ULong&lt;/code&gt; 값에 가장 가까운 &lt;code&gt;Double&lt;/code&gt; 입니다. 이 &lt;code&gt;ULong&lt;/code&gt; 값이 정확히 두 &lt;code&gt;Double&lt;/code&gt; 사이에 있는 경우, 적어도 유의 한 가수 비트가 0 인 값이 선택됩니다.</target>
        </trans-unit>
        <trans-unit id="fc0e588cba1b5e32b36bbd725d91a005e8eca137" translate="yes" xml:space="preserve">
          <source>The resulting value is the closest &lt;code&gt;Float&lt;/code&gt; to this &lt;code&gt;Double&lt;/code&gt; value. In case when this &lt;code&gt;Double&lt;/code&gt; value is exactly between two &lt;code&gt;Float&lt;/code&gt;s, the one with zero at least significant bit of mantissa is selected.</source>
          <target state="translated">결과 값은 이 &lt;code&gt;Double&lt;/code&gt; 값에 가장 가까운 &lt;code&gt;Float&lt;/code&gt; 입니다. 이 &lt;code&gt;Double&lt;/code&gt; 값이 정확히 두 &lt;code&gt;Float&lt;/code&gt; 사이 인 경우, 적어도 가수 비트가 0 인 값이 선택됩니다.</target>
        </trans-unit>
        <trans-unit id="1a94a9e0d2914f4ed72b19cd967f6325996af0de" translate="yes" xml:space="preserve">
          <source>The resulting value is the closest &lt;code&gt;Float&lt;/code&gt; to this &lt;code&gt;Int&lt;/code&gt; value. In case when this &lt;code&gt;Int&lt;/code&gt; value is exactly between two &lt;code&gt;Float&lt;/code&gt;s, the one with zero at least significant bit of mantissa is selected.</source>
          <target state="translated">결과 값은 이 &lt;code&gt;Int&lt;/code&gt; 값에 가장 가까운 &lt;code&gt;Float&lt;/code&gt; 입니다. 이 &lt;code&gt;Int&lt;/code&gt; 값이 정확히 두 &lt;code&gt;Float&lt;/code&gt; 사이 인 경우, 적어도 가수 비트가 0 인 값이 선택됩니다.</target>
        </trans-unit>
        <trans-unit id="4c34f885e332b614efeb077bdc9dc7f566d719ac" translate="yes" xml:space="preserve">
          <source>The resulting value is the closest &lt;code&gt;Float&lt;/code&gt; to this &lt;code&gt;Long&lt;/code&gt; value. In case when this &lt;code&gt;Long&lt;/code&gt; value is exactly between two &lt;code&gt;Float&lt;/code&gt;s, the one with zero at least significant bit of mantissa is selected.</source>
          <target state="translated">결과 값은 이 &lt;code&gt;Long&lt;/code&gt; 값에 가장 가까운 &lt;code&gt;Float&lt;/code&gt; 입니다. 이 &lt;code&gt;Long&lt;/code&gt; 값이 정확히 두 &lt;code&gt;Float&lt;/code&gt; 사이 인 경우, 적어도 가수 비트가 0 인 값이 선택됩니다.</target>
        </trans-unit>
        <trans-unit id="56778d0fa4ef4bd39c3c6c8e27df252ff267b86a" translate="yes" xml:space="preserve">
          <source>The resulting value is the closest &lt;code&gt;Float&lt;/code&gt; to this &lt;code&gt;UInt&lt;/code&gt; value. In case when this &lt;code&gt;UInt&lt;/code&gt; value is exactly between two &lt;code&gt;Float&lt;/code&gt;s, the one with zero at least significant bit of mantissa is selected.</source>
          <target state="translated">결과 값은 이 &lt;code&gt;UInt&lt;/code&gt; 값에 가장 가까운 &lt;code&gt;Float&lt;/code&gt; 입니다. 이 &lt;code&gt;UInt&lt;/code&gt; 값이 정확히 두 &lt;code&gt;Float&lt;/code&gt; 사이 인 경우, 적어도 가수 비트가 0 인 값이 선택됩니다.</target>
        </trans-unit>
        <trans-unit id="498957909e2b3c5b2a70150c6779dc9db0eb20c7" translate="yes" xml:space="preserve">
          <source>The resulting value is the closest &lt;code&gt;Float&lt;/code&gt; to this &lt;code&gt;ULong&lt;/code&gt; value. In case when this &lt;code&gt;ULong&lt;/code&gt; value is exactly between two &lt;code&gt;Float&lt;/code&gt;s, the one with zero at least significant bit of mantissa is selected.</source>
          <target state="translated">결과 값은 이 &lt;code&gt;ULong&lt;/code&gt; 값에 가장 가까운 &lt;code&gt;Float&lt;/code&gt; 입니다. 이 &lt;code&gt;ULong&lt;/code&gt; 값이 정확히 2 개의 &lt;code&gt;Float&lt;/code&gt; 사이 인 경우, 적어도 유의 한 가수 비트가 0 인 값이 선택됩니다.</target>
        </trans-unit>
        <trans-unit id="65d14c2cdb6c9b143338a902f9c4de4c9b45f92f" translate="yes" xml:space="preserve">
          <source>The return type inference for anonymous functions works just like for normal functions: the return type is inferred automatically for anonymous functions with an expression body and has to be specified explicitly (or is assumed to be &lt;code&gt;Unit&lt;/code&gt;) for anonymous functions with a block body.</source>
          <target state="translated">익명 함수에 대한 리턴 유형 유추는 일반 함수와 동일하게 작동합니다. 리턴 유형은 표현식 본문이있는 익명 함수에 대해 자동으로 추론 되며 블록 본문이있는 익명 함수에 대해 명시 적으로 지정되거나 &lt;code&gt;Unit&lt;/code&gt; 으로 간주되어야합니다 .</target>
        </trans-unit>
        <trans-unit id="dbab78ef44eaefb4e469bd1e51f4e8661d634cea" translate="yes" xml:space="preserve">
          <source>The return type of a function-typed return type (the user expects the returned function to return &lt;code&gt;Fruit&lt;/code&gt;, so it's okay if it really returns &lt;code&gt;Apple&lt;/code&gt;)</source>
          <target state="translated">함수 타입 리턴 타입의 리턴 타입 (사용자는 리턴 된 함수가 &lt;code&gt;Fruit&lt;/code&gt; 을 리턴 할 것으로 예상 하므로 실제로 &lt;code&gt;Apple&lt;/code&gt; 을 리턴해도 괜찮습니다 )</target>
        </trans-unit>
        <trans-unit id="d8362d946ac99a87abd0521089565682c0510f07" translate="yes" xml:space="preserve">
          <source>The return type of a lambda expression is inferred from the type of the last expression inside it (or from the function type of the variable/parameter that the lambda expression is assigned to). If a lambda expression is passed as a function parameter (which is the ordinary use) or assigned to a variable with a declared type, Kotlin can infer the parameter types too, and you only need to specify their names:</source>
          <target state="translated">람다 식의 반환 형식은 그 안에있는 마지막 식의 형식 (또는 람다식이 할당 된 변수 / 매개 변수의 함수 형식)에서 유추됩니다. 람다식이 함수 매개 변수 (일반적인 용도)로 전달되거나 선언 된 유형의 변수에 지정된 경우 Kotlin은 매개 변수 유형도 유추 할 수 있으며 해당 이름 만 지정하면됩니다.</target>
        </trans-unit>
        <trans-unit id="d7c260eb93497371636dc4de8fdb8ef84ac32045" translate="yes" xml:space="preserve">
          <source>The return value of &lt;code&gt;apply&lt;/code&gt; and &lt;code&gt;also&lt;/code&gt; is the context object itself. Hence, they can be included into call chains as &lt;em&gt;side steps&lt;/em&gt;: you can continue chaining function calls on the same object after them.</source>
          <target state="translated">의 반환 값 &lt;code&gt;apply&lt;/code&gt; 하고 &lt;code&gt;also&lt;/code&gt; 상황에 맞는 객체 자체입니다. 따라서 이러한 &lt;em&gt;단계는&lt;/em&gt; 호출 &lt;em&gt;단계에 부가 단계&lt;/em&gt; 로 포함될 수 있습니다 . 함수 호출은 이후에 동일한 객체에서 함수 호출을 계속 연결할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6d324367f598aa028770dca0838f66177648fed1" translate="yes" xml:space="preserve">
          <source>The return value.</source>
          <target state="translated">반환 값</target>
        </trans-unit>
        <trans-unit id="046b6584c1bbd3a7a64857edece72cc830dec917" translate="yes" xml:space="preserve">
          <source>The returned instance uses the specified &lt;a href=&quot;lazy#kotlin%24lazy%28kotlin.Any%2C+kotlin.Function0%28%28kotlin.lazy.T%29%29%29%2Flock&quot;&gt;lock&lt;/a&gt; object to synchronize on. When the &lt;a href=&quot;lazy#kotlin%24lazy%28kotlin.Any%2C+kotlin.Function0%28%28kotlin.lazy.T%29%29%29%2Flock&quot;&gt;lock&lt;/a&gt; is not specified the instance uses itself to synchronize on, in this case do not synchronize from external code on the returned instance as it may cause accidental deadlock. Also this behavior can be changed in the future.</source>
          <target state="translated">리턴 된 인스턴스는 지정된 &lt;a href=&quot;lazy#kotlin%24lazy%28kotlin.Any%2C+kotlin.Function0%28%28kotlin.lazy.T%29%29%29%2Flock&quot;&gt;잠금&lt;/a&gt; 오브젝트를 사용하여 동기화합니다. 하면 &lt;a href=&quot;lazy#kotlin%24lazy%28kotlin.Any%2C+kotlin.Function0%28%28kotlin.lazy.T%29%29%29%2Flock&quot;&gt;잠금이&lt;/a&gt; 이 경우 자체에 동기화 할 수있는 인스턴스 용도를 지정하지 않은 것이 실수로 교착 상태가 발생할 수 있으므로 반환 된 인스턴스의 외부 코드에서 동기화하지 않습니다. 또한이 동작은 나중에 변경 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="97bfc2ca377533226a66b10393317b0a2f994fba" translate="yes" xml:space="preserve">
          <source>The returned list is empty if this char sequence contains less than two characters.</source>
          <target state="translated">이 문자 순서에 2 자 미만이 포함되어 있으면 리턴 된 목록이 비어 있습니다.</target>
        </trans-unit>
        <trans-unit id="d158c2273db93047119908af61efbbba35bd76f3" translate="yes" xml:space="preserve">
          <source>The returned list is empty if this collection contains less than two elements.</source>
          <target state="translated">이 컬렉션에 요소가 2 개 미만인 경우 반환 된 목록이 비어 있습니다.</target>
        </trans-unit>
        <trans-unit id="29bbad5c305945f97c70cd75ffccab450111f2ea" translate="yes" xml:space="preserve">
          <source>The returned map is serializable (JVM).</source>
          <target state="translated">리턴 된 맵은 직렬화 가능 (JVM)입니다.</target>
        </trans-unit>
        <trans-unit id="ec4d25dd41a10ce08bae955efed7031764938b43" translate="yes" xml:space="preserve">
          <source>The returned map is serializable.</source>
          <target state="translated">반환 된 맵은 직렬화 가능합니다.</target>
        </trans-unit>
        <trans-unit id="6f1137c5bd275e0d050f73fe1ffb45e6bc0fef52" translate="yes" xml:space="preserve">
          <source>The returned map preserves the entry iteration order of the keys produced from the original array.</source>
          <target state="translated">반환 된 맵은 원래 배열에서 생성 된 키의 항목 반복 순서를 유지합니다.</target>
        </trans-unit>
        <trans-unit id="aab8c4af63582433af11da060d436e3782362d9a" translate="yes" xml:space="preserve">
          <source>The returned map preserves the entry iteration order of the keys produced from the original char sequence.</source>
          <target state="translated">리턴 된 맵은 원래 문자 시퀀스에서 생성 된 키의 항목 반복 순서를 유지합니다.</target>
        </trans-unit>
        <trans-unit id="16f1a5aa5ffd50a8f9547783402bf7757df5025f" translate="yes" xml:space="preserve">
          <source>The returned map preserves the entry iteration order of the keys produced from the original collection.</source>
          <target state="translated">리턴 된 맵은 원래 콜렉션에서 생성 된 키의 항목 반복 순서를 유지합니다.</target>
        </trans-unit>
        <trans-unit id="19c068ac54b988c0d6076dddd8c2dbf4092708f6" translate="yes" xml:space="preserve">
          <source>The returned map preserves the entry iteration order of the keys produced from the original sequence.</source>
          <target state="translated">반환 된 맵은 원래 시퀀스에서 생성 된 키의 항목 반복 순서를 유지합니다.</target>
        </trans-unit>
        <trans-unit id="f54f229a0ee8d8720d828fe3e27b2d2a6ca940bc" translate="yes" xml:space="preserve">
          <source>The returned map preserves the entry iteration order of the original array.</source>
          <target state="translated">반환 된 맵은 원래 배열의 항목 반복 순서를 유지합니다.</target>
        </trans-unit>
        <trans-unit id="918c726186d31885a03be5dd5847d194f356551f" translate="yes" xml:space="preserve">
          <source>The returned map preserves the entry iteration order of the original array. If any of two pairs would have the same key the last one gets added to the map.</source>
          <target state="translated">반환 된 맵은 원래 배열의 항목 반복 순서를 유지합니다. 두 쌍 중 하나가 동일한 키를 가지면 마지막 키가 맵에 추가됩니다.</target>
        </trans-unit>
        <trans-unit id="1331dc1f7dcbe48a5148654c3f9a9dd17b60c885" translate="yes" xml:space="preserve">
          <source>The returned map preserves the entry iteration order of the original char sequence.</source>
          <target state="translated">리턴 된 맵은 원래 문자 시퀀스의 항목 반복 순서를 유지합니다.</target>
        </trans-unit>
        <trans-unit id="566ed3a9dcb7ca74d4f2c70c6fdf84ac896debb5" translate="yes" xml:space="preserve">
          <source>The returned map preserves the entry iteration order of the original collection.</source>
          <target state="translated">반환 된 맵은 원본 컬렉션의 항목 반복 순서를 유지합니다.</target>
        </trans-unit>
        <trans-unit id="2e469a2caf818c0835cee9e0a1babf1e2e3c07a5" translate="yes" xml:space="preserve">
          <source>The returned map preserves the entry iteration order of the original collection. If any of two pairs would have the same key the last one gets added to the map.</source>
          <target state="translated">반환 된 맵은 원본 컬렉션의 항목 반복 순서를 유지합니다. 두 쌍 중 하나가 동일한 키를 가지면 마지막 키가 맵에 추가됩니다.</target>
        </trans-unit>
        <trans-unit id="4c19d30d5fb69c54a255c5b1e548f2fa56d3aefb" translate="yes" xml:space="preserve">
          <source>The returned map preserves the entry iteration order of the original map.</source>
          <target state="translated">반환 된 맵은 원래 맵의 항목 반복 순서를 유지합니다.</target>
        </trans-unit>
        <trans-unit id="f87204408405ad88a40594eff8f4867029a89b59" translate="yes" xml:space="preserve">
          <source>The returned map preserves the entry iteration order of the original map. The &lt;a href=&quot;plus#kotlin.collections%24plus%28kotlin.collections.Map%28%28kotlin.collections.plus.K%2C+kotlin.collections.plus.V%29%29%2C+kotlin.Pair%28%28kotlin.collections.plus.K%2C+kotlin.collections.plus.V%29%29%29%2Fpair&quot;&gt;pair&lt;/a&gt; is iterated in the end if it has a unique key.</source>
          <target state="translated">반환 된 맵은 원래 맵의 항목 반복 순서를 유지합니다. &lt;a href=&quot;plus#kotlin.collections%24plus%28kotlin.collections.Map%28%28kotlin.collections.plus.K%2C+kotlin.collections.plus.V%29%29%2C+kotlin.Pair%28%28kotlin.collections.plus.K%2C+kotlin.collections.plus.V%29%29%29%2Fpair&quot;&gt;쌍&lt;/a&gt; 은 고유 키가있는 경우 결국 반복된다.</target>
        </trans-unit>
        <trans-unit id="8ff3f66b8173f81182161d671f67a90a7b9f8d74" translate="yes" xml:space="preserve">
          <source>The returned map preserves the entry iteration order of the original map. Those &lt;a href=&quot;plus#kotlin.collections%24plus%28kotlin.collections.Map%28%28kotlin.collections.plus.K%2C+kotlin.collections.plus.V%29%29%2C+kotlin.Array%28%28kotlin.Pair%28%28kotlin.collections.plus.K%2C+kotlin.collections.plus.V%29%29%29%29%29%2Fpairs&quot;&gt;pairs&lt;/a&gt; with unique keys are iterated in the end in the order of &lt;a href=&quot;plus#kotlin.collections%24plus%28kotlin.collections.Map%28%28kotlin.collections.plus.K%2C+kotlin.collections.plus.V%29%29%2C+kotlin.Array%28%28kotlin.Pair%28%28kotlin.collections.plus.K%2C+kotlin.collections.plus.V%29%29%29%29%29%2Fpairs&quot;&gt;pairs&lt;/a&gt; array.</source>
          <target state="translated">반환 된 맵은 원래 맵의 항목 반복 순서를 유지합니다. 고유 키를 가진 해당 &lt;a href=&quot;plus#kotlin.collections%24plus%28kotlin.collections.Map%28%28kotlin.collections.plus.K%2C+kotlin.collections.plus.V%29%29%2C+kotlin.Array%28%28kotlin.Pair%28%28kotlin.collections.plus.K%2C+kotlin.collections.plus.V%29%29%29%29%29%2Fpairs&quot;&gt;쌍&lt;/a&gt; 은 &lt;a href=&quot;plus#kotlin.collections%24plus%28kotlin.collections.Map%28%28kotlin.collections.plus.K%2C+kotlin.collections.plus.V%29%29%2C+kotlin.Array%28%28kotlin.Pair%28%28kotlin.collections.plus.K%2C+kotlin.collections.plus.V%29%29%29%29%29%2Fpairs&quot;&gt;쌍&lt;/a&gt; 배열 순서로 결국 반복됩니다 .</target>
        </trans-unit>
        <trans-unit id="4c15bc5f538aa94ff9d36f2c463553e37bffffa8" translate="yes" xml:space="preserve">
          <source>The returned map preserves the entry iteration order of the original map. Those &lt;a href=&quot;plus#kotlin.collections%24plus%28kotlin.collections.Map%28%28kotlin.collections.plus.K%2C+kotlin.collections.plus.V%29%29%2C+kotlin.collections.Iterable%28%28kotlin.Pair%28%28kotlin.collections.plus.K%2C+kotlin.collections.plus.V%29%29%29%29%29%2Fpairs&quot;&gt;pairs&lt;/a&gt; with unique keys are iterated in the end in the order of &lt;a href=&quot;plus#kotlin.collections%24plus%28kotlin.collections.Map%28%28kotlin.collections.plus.K%2C+kotlin.collections.plus.V%29%29%2C+kotlin.collections.Iterable%28%28kotlin.Pair%28%28kotlin.collections.plus.K%2C+kotlin.collections.plus.V%29%29%29%29%29%2Fpairs&quot;&gt;pairs&lt;/a&gt; collection.</source>
          <target state="translated">반환 된 맵은 원래 맵의 항목 반복 순서를 유지합니다. 그 &lt;a href=&quot;plus#kotlin.collections%24plus%28kotlin.collections.Map%28%28kotlin.collections.plus.K%2C+kotlin.collections.plus.V%29%29%2C+kotlin.collections.Iterable%28%28kotlin.Pair%28%28kotlin.collections.plus.K%2C+kotlin.collections.plus.V%29%29%29%29%29%2Fpairs&quot;&gt;쌍&lt;/a&gt; 고유 키와 함께의 순서로 결국 반복되는 &lt;a href=&quot;plus#kotlin.collections%24plus%28kotlin.collections.Map%28%28kotlin.collections.plus.K%2C+kotlin.collections.plus.V%29%29%2C+kotlin.collections.Iterable%28%28kotlin.Pair%28%28kotlin.collections.plus.K%2C+kotlin.collections.plus.V%29%29%29%29%29%2Fpairs&quot;&gt;쌍&lt;/a&gt; 모음입니다.</target>
        </trans-unit>
        <trans-unit id="41524b28b32f1890886788ed586175d793500478" translate="yes" xml:space="preserve">
          <source>The returned map preserves the entry iteration order of the original map. Those &lt;a href=&quot;plus#kotlin.collections%24plus%28kotlin.collections.Map%28%28kotlin.collections.plus.K%2C+kotlin.collections.plus.V%29%29%2C+kotlin.sequences.Sequence%28%28kotlin.Pair%28%28kotlin.collections.plus.K%2C+kotlin.collections.plus.V%29%29%29%29%29%2Fpairs&quot;&gt;pairs&lt;/a&gt; with unique keys are iterated in the end in the order of &lt;a href=&quot;plus#kotlin.collections%24plus%28kotlin.collections.Map%28%28kotlin.collections.plus.K%2C+kotlin.collections.plus.V%29%29%2C+kotlin.sequences.Sequence%28%28kotlin.Pair%28%28kotlin.collections.plus.K%2C+kotlin.collections.plus.V%29%29%29%29%29%2Fpairs&quot;&gt;pairs&lt;/a&gt; sequence.</source>
          <target state="translated">반환 된 맵은 원래 맵의 항목 반복 순서를 유지합니다. 그 &lt;a href=&quot;plus#kotlin.collections%24plus%28kotlin.collections.Map%28%28kotlin.collections.plus.K%2C+kotlin.collections.plus.V%29%29%2C+kotlin.sequences.Sequence%28%28kotlin.Pair%28%28kotlin.collections.plus.K%2C+kotlin.collections.plus.V%29%29%29%29%29%2Fpairs&quot;&gt;쌍&lt;/a&gt; 고유 키와 함께의 순서로 결국 반복되는 &lt;a href=&quot;plus#kotlin.collections%24plus%28kotlin.collections.Map%28%28kotlin.collections.plus.K%2C+kotlin.collections.plus.V%29%29%2C+kotlin.sequences.Sequence%28%28kotlin.Pair%28%28kotlin.collections.plus.K%2C+kotlin.collections.plus.V%29%29%29%29%29%2Fpairs&quot;&gt;쌍의&lt;/a&gt; 순서.</target>
        </trans-unit>
        <trans-unit id="af1ab049b7a80d37b426b5189d29b3d33630f886" translate="yes" xml:space="preserve">
          <source>The returned map preserves the entry iteration order of the original map. Those entries of another &lt;a href=&quot;plus#kotlin.collections%24plus%28kotlin.collections.Map%28%28kotlin.collections.plus.K%2C+kotlin.collections.plus.V%29%29%2C+kotlin.collections.Map%28%28kotlin.collections.plus.K%2C+kotlin.collections.plus.V%29%29%29%2Fmap&quot;&gt;map&lt;/a&gt; that are missing in this map are iterated in the end in the order of that &lt;a href=&quot;plus#kotlin.collections%24plus%28kotlin.collections.Map%28%28kotlin.collections.plus.K%2C+kotlin.collections.plus.V%29%29%2C+kotlin.collections.Map%28%28kotlin.collections.plus.K%2C+kotlin.collections.plus.V%29%29%29%2Fmap&quot;&gt;map&lt;/a&gt;.</source>
          <target state="translated">반환 된 맵은 원래 맵의 항목 반복 순서를 유지합니다. 이 맵에서 누락 된 다른 &lt;a href=&quot;plus#kotlin.collections%24plus%28kotlin.collections.Map%28%28kotlin.collections.plus.K%2C+kotlin.collections.plus.V%29%29%2C+kotlin.collections.Map%28%28kotlin.collections.plus.K%2C+kotlin.collections.plus.V%29%29%29%2Fmap&quot;&gt;맵의&lt;/a&gt; 항목은 해당 &lt;a href=&quot;plus#kotlin.collections%24plus%28kotlin.collections.Map%28%28kotlin.collections.plus.K%2C+kotlin.collections.plus.V%29%29%2C+kotlin.collections.Map%28%28kotlin.collections.plus.K%2C+kotlin.collections.plus.V%29%29%29%2Fmap&quot;&gt;맵&lt;/a&gt; 순서대로 끝까지 반복 됩니다 .</target>
        </trans-unit>
        <trans-unit id="048dcd341f30e50bd04dda11327a4ef88e0d2612" translate="yes" xml:space="preserve">
          <source>The returned map preserves the entry iteration order of the original sequence.</source>
          <target state="translated">리턴 된 맵은 원래 순서의 항목 반복 순서를 유지합니다.</target>
        </trans-unit>
        <trans-unit id="bba2889b44a4cec09a40249a683767a797d71e14" translate="yes" xml:space="preserve">
          <source>The returned map preserves the entry iteration order of the original sequence. If any of two pairs would have the same key the last one gets added to the map.</source>
          <target state="translated">리턴 된 맵은 원래 순서의 항목 반복 순서를 유지합니다. 두 쌍 중 하나가 동일한 키를 가지면 마지막 키가 맵에 추가됩니다.</target>
        </trans-unit>
        <trans-unit id="b48dc5da4ba5d84bf8f51570f1be30c9067ca36a" translate="yes" xml:space="preserve">
          <source>The returned map preserves the entry iteration order.</source>
          <target state="translated">리턴 된 맵은 항목 반복 순서를 유지합니다.</target>
        </trans-unit>
        <trans-unit id="d70c61d5fb5764eefc41a239b3b607225317f588" translate="yes" xml:space="preserve">
          <source>The returned sequence is constrained to be iterated only once.</source>
          <target state="translated">반환 된 시퀀스는 한 번만 반복되도록 제한됩니다.</target>
        </trans-unit>
        <trans-unit id="a79b9e6a21565ad6033f2ab5027e737873a51569" translate="yes" xml:space="preserve">
          <source>The returned sequence is empty if this sequence contains less than two elements.</source>
          <target state="translated">이 시퀀스에 요소가 2 개 미만인 경우 반환 된 시퀀스가 ​​비어 있습니다.</target>
        </trans-unit>
        <trans-unit id="7927ae1e5106eaeb7bb0b0dc1138826c33d1919c" translate="yes" xml:space="preserve">
          <source>The returned set preserves the element iteration order of the original array.</source>
          <target state="translated">반환 된 집합은 원래 배열의 요소 반복 순서를 유지합니다.</target>
        </trans-unit>
        <trans-unit id="8e820b287237249236a403161f0b70ed17d391a2" translate="yes" xml:space="preserve">
          <source>The returned set preserves the element iteration order of the original array. Those elements of the &lt;a href=&quot;union#kotlin.collections%24union%28kotlin.Array%28%28kotlin.collections.union.T%29%29%2C+kotlin.collections.Iterable%28%28kotlin.collections.union.T%29%29%29%2Fother&quot;&gt;other&lt;/a&gt; collection that are unique are iterated in the end in the order of the &lt;a href=&quot;union#kotlin.collections%24union%28kotlin.Array%28%28kotlin.collections.union.T%29%29%2C+kotlin.collections.Iterable%28%28kotlin.collections.union.T%29%29%29%2Fother&quot;&gt;other&lt;/a&gt; collection.</source>
          <target state="translated">반환 된 집합은 원래 배열의 요소 반복 순서를 유지합니다. 의 그 요소 &lt;a href=&quot;union#kotlin.collections%24union%28kotlin.Array%28%28kotlin.collections.union.T%29%29%2C+kotlin.collections.Iterable%28%28kotlin.collections.union.T%29%29%29%2Fother&quot;&gt;다른&lt;/a&gt; 고유 한 컬렉션의 순서로 결국 반복되는 &lt;a href=&quot;union#kotlin.collections%24union%28kotlin.Array%28%28kotlin.collections.union.T%29%29%2C+kotlin.collections.Iterable%28%28kotlin.collections.union.T%29%29%29%2Fother&quot;&gt;다른&lt;/a&gt; 모음입니다.</target>
        </trans-unit>
        <trans-unit id="b2b309c05bb0df5183017b60bb11949ef16cec12" translate="yes" xml:space="preserve">
          <source>The returned set preserves the element iteration order of the original char sequence.</source>
          <target state="translated">리턴 된 세트는 원래 문자 순서의 요소 반복 순서를 유지합니다.</target>
        </trans-unit>
        <trans-unit id="77b699621c7e191100bcd082c9accf071cd60f08" translate="yes" xml:space="preserve">
          <source>The returned set preserves the element iteration order of the original collection.</source>
          <target state="translated">반환 된 집합은 원본 컬렉션의 요소 반복 순서를 유지합니다.</target>
        </trans-unit>
        <trans-unit id="ed96aca660cbd3c3aee98cb1f013ac3448395f47" translate="yes" xml:space="preserve">
          <source>The returned set preserves the element iteration order of the original collection. Those elements of the &lt;a href=&quot;union#kotlin.collections%24union%28kotlin.collections.Iterable%28%28kotlin.collections.union.T%29%29%2C+kotlin.collections.Iterable%28%28kotlin.collections.union.T%29%29%29%2Fother&quot;&gt;other&lt;/a&gt; collection that are unique are iterated in the end in the order of the &lt;a href=&quot;union#kotlin.collections%24union%28kotlin.collections.Iterable%28%28kotlin.collections.union.T%29%29%2C+kotlin.collections.Iterable%28%28kotlin.collections.union.T%29%29%29%2Fother&quot;&gt;other&lt;/a&gt; collection.</source>
          <target state="translated">반환 된 집합은 원본 컬렉션의 요소 반복 순서를 유지합니다. 의 그 요소 &lt;a href=&quot;union#kotlin.collections%24union%28kotlin.collections.Iterable%28%28kotlin.collections.union.T%29%29%2C+kotlin.collections.Iterable%28%28kotlin.collections.union.T%29%29%29%2Fother&quot;&gt;다른&lt;/a&gt; 고유 한 컬렉션의 순서로 결국 반복되는 &lt;a href=&quot;union#kotlin.collections%24union%28kotlin.collections.Iterable%28%28kotlin.collections.union.T%29%29%2C+kotlin.collections.Iterable%28%28kotlin.collections.union.T%29%29%29%2Fother&quot;&gt;다른&lt;/a&gt; 모음입니다.</target>
        </trans-unit>
        <trans-unit id="b556a6977dd4e71f20e303d7d9385040d75f0ac7" translate="yes" xml:space="preserve">
          <source>The returned set preserves the element iteration order of the original sequence.</source>
          <target state="translated">리턴 된 세트는 원래 순서의 요소 반복 순서를 유지합니다.</target>
        </trans-unit>
        <trans-unit id="eddbfc5096c56b9aafbe04f2e54352a74a62ad62" translate="yes" xml:space="preserve">
          <source>The returned set preserves the element iteration order of the original set.</source>
          <target state="translated">리턴 된 세트는 원래 세트의 요소 반복 순서를 유지합니다.</target>
        </trans-unit>
        <trans-unit id="4e9b4d20ac671bfe117e4f28b0081ad091c327b5" translate="yes" xml:space="preserve">
          <source>The returned set preserves the element iteration order.</source>
          <target state="translated">리턴 된 세트는 요소 반복 순서를 유지합니다.</target>
        </trans-unit>
        <trans-unit id="7c0e13333db8789388b9d52adff49d100d5cf6ca" translate="yes" xml:space="preserve">
          <source>The returned value is &lt;code&gt;y&lt;/code&gt; such that &lt;code&gt;sinh(y) == x&lt;/code&gt;.</source>
          <target state="translated">리턴 값은 &lt;code&gt;y&lt;/code&gt; 되도록 &lt;code&gt;sinh(y) == x&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f0a819fc71728e449a1fa0a52b2d805fcb67dfe6" translate="yes" xml:space="preserve">
          <source>The returned value is &lt;code&gt;y&lt;/code&gt; such that &lt;code&gt;tanh(y) == x&lt;/code&gt;.</source>
          <target state="translated">리턴 값은 &lt;code&gt;y&lt;/code&gt; 되도록 &lt;code&gt;tanh(y) == x&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="38db1bb7310932e868d4c70216856f90e11179f2" translate="yes" xml:space="preserve">
          <source>The returned value is positive &lt;code&gt;y&lt;/code&gt; such that &lt;code&gt;cosh(y) == x&lt;/code&gt;.</source>
          <target state="translated">반환 값은 양수 &lt;code&gt;y&lt;/code&gt; 이므로 &lt;code&gt;cosh(y) == x&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="92462ffebca930d13f4cb4aaee4b7842f4ea14de" translate="yes" xml:space="preserve">
          <source>The returned value of a &lt;em&gt;try&lt;/em&gt;-expression is either the last expression in the &lt;em&gt;try&lt;/em&gt; block or the last expression in the &lt;em&gt;catch&lt;/em&gt; block (or blocks). Contents of the &lt;em&gt;finally&lt;/em&gt; block do not affect the result of the expression.</source>
          <target state="translated">&lt;em&gt;try&lt;/em&gt; -expression 의 리턴 값은 &lt;em&gt;try&lt;/em&gt; 블록의 마지막 표현식 이거나 &lt;em&gt;catch&lt;/em&gt; 블록 (또는 블록) 의 마지막 표현식입니다 . &lt;em&gt;finally&lt;/em&gt; 블록의 내용은 표현식 결과에 영향을 미치지 않습니다.</target>
        </trans-unit>
        <trans-unit id="261319d8fec52739ec6c832665ae3f7dbd0e5025" translate="yes" xml:space="preserve">
          <source>The root of the Kotlin class hierarchy. Every Kotlin class has &lt;a href=&quot;-any/index#kotlin.Any&quot;&gt;Any&lt;/a&gt; as a superclass.</source>
          <target state="translated">Kotlin 클래스 계층의 루트 모든 Kotlin 클래스에는 &lt;a href=&quot;-any/index#kotlin.Any&quot;&gt;Any&lt;/a&gt; 가 수퍼 클래스로 있습니다.</target>
        </trans-unit>
        <trans-unit id="a55ae833319a2f8e509e5aee918452e19eb747a8" translate="yes" xml:space="preserve">
          <source>The root of the Kotlin class hierarchy. Every Kotlin class has &lt;a href=&quot;index#kotlin.Any&quot;&gt;Any&lt;/a&gt; as a superclass.</source>
          <target state="translated">Kotlin 클래스 계층의 루트 모든 Kotlin 클래스에는 &lt;a href=&quot;index#kotlin.Any&quot;&gt;Any&lt;/a&gt; 가 수퍼 클래스로 있습니다.</target>
        </trans-unit>
        <trans-unit id="98512a74a1640b8252b93eb9be999aab21267c59" translate="yes" xml:space="preserve">
          <source>The runner will set the value for the property system.path.macro.KOTLIN.BUNDLED to the correct one based on the path settings from the IntelliJ IDEA project. However this value needs to be defined in TeamCity (and can be set to any value). Therefore we need to define it as a system variable.</source>
          <target state="translated">러너는 system.path.macro.KOTLIN.BUNDLED 속성의 값을 IntelliJ IDEA 프로젝트의 경로 설정에 따라 올바른 값으로 설정합니다. 그러나이 값은 TeamCity에서 정의해야하며 임의의 값으로 설정할 수 있습니다. 따라서 시스템 변수로 정의해야합니다.</target>
        </trans-unit>
        <trans-unit id="578262526068b614504d1b18d76cf8dea19e1504" translate="yes" xml:space="preserve">
          <source>The same is available for maps with the functions &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/map-of&quot;&gt;&lt;code&gt;mapOf()&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/mutable-map-of&quot;&gt;&lt;code&gt;mutableMapOf()&lt;/code&gt;&lt;/a&gt;. The map's keys and values are passed as &lt;code&gt;Pair&lt;/code&gt; objects (usually created with &lt;code&gt;to&lt;/code&gt; infix function).</source>
          <target state="translated">&lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/map-of&quot;&gt; &lt;code&gt;mapOf()&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/mutable-map-of&quot;&gt; &lt;code&gt;mutableMapOf()&lt;/code&gt; &lt;/a&gt; 함수가있는 맵에서도 동일하게 사용할 수 있습니다 . 지도의 키와 값은 &lt;code&gt;Pair&lt;/code&gt; 객체 로 전달됩니다 (보통 함수를 사용 &lt;code&gt;to&lt;/code&gt; 생성 ).</target>
        </trans-unit>
        <trans-unit id="25f5c97c541192ff226fb77118f20b9141f29a81" translate="yes" xml:space="preserve">
          <source>The same rules are used by the Kotlin/Native compiler to generate the &lt;code&gt;.h&lt;/code&gt; file for all platforms.</source>
          <target state="translated">Kotlin / Native 컴파일러 는 모든 플랫폼에 대해 &lt;code&gt;.h&lt;/code&gt; 파일 을 생성하기 위해 동일한 규칙을 사용 합니다.</target>
        </trans-unit>
        <trans-unit id="dac2ac98305c82e23b60095cae0d9b066592bfa3" translate="yes" xml:space="preserve">
          <source>The same set of functions (but without constants) is also available for &lt;code&gt;Float&lt;/code&gt; arguments.</source>
          <target state="translated">&lt;code&gt;Float&lt;/code&gt; 인수 에도 동일한 함수 세트 (상수는 없음)를 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="afd6887219148439be70535c83e0ab200b27625e" translate="yes" xml:space="preserve">
          <source>The same syntax can be used to annotate the entire file. To do this, put an annotation with the target &lt;code&gt;file&lt;/code&gt; at the top level of a file, before the package directive or before all imports if the file is in the default package:</source>
          <target state="translated">동일한 구문을 사용하여 전체 파일에 주석을 달 수 있습니다. 이렇게하려면 , 파일이 기본 패키지에있는 경우, 파일의 최상위 레벨, 패키지 지시문 앞 또는 모든 가져 오기 전에 대상 &lt;code&gt;file&lt;/code&gt; 에 주석을 추가하십시오 .</target>
        </trans-unit>
        <trans-unit id="2ae227fcecaec9d7de3afec1996267608672f87b" translate="yes" xml:space="preserve">
          <source>The same syntax with omitted type arguments can be used for casts that do not take type arguments into account: &lt;code&gt;list as ArrayList&lt;/code&gt;.</source>
          <target state="translated">형식 인수를 고려하지 않은 캐스트에 대해서는 형식 인수가 생략 된 동일한 구문을 사용할 수 있습니다. &lt;code&gt;list as ArrayList&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="998fefac425fa7727b709de3b80c938ce507ca90" translate="yes" xml:space="preserve">
          <source>The same trick applies when we need to have a property &lt;code&gt;x&lt;/code&gt; alongside with a function &lt;code&gt;getX()&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;getX()&lt;/code&gt; 함수와 함께 &lt;code&gt;x&lt;/code&gt; 속성이 필요한 경우에도 동일한 트릭이 적용됩니다 .</target>
        </trans-unit>
        <trans-unit id="7028478d43f0e9046e167eadedccdd38efaac612" translate="yes" xml:space="preserve">
          <source>The same type parameter can be used in both covariant and contravariant projections (because it's the generic classes that are being projected, not the type parameter):</source>
          <target state="translated">공변량 및 반 변량 예측에 동일한 유형 매개 변수를 사용할 수 있습니다 (유형 매개 변수가 아닌 투영되는 일반 클래스이므로).</target>
        </trans-unit>
        <trans-unit id="e34374077b9198e942d005d02c16935775597fa6" translate="yes" xml:space="preserve">
          <source>The scale of the result is the same as the scale of &lt;code&gt;this&lt;/code&gt; (divident), and for rounding the &lt;a href=&quot;http://docs.oracle.com/javase/8/docs/api/java/math/RoundingMode.html#HALF_EVEN&quot;&gt;RoundingMode.HALF_EVEN&lt;/a&gt; rounding mode is used.</source>
          <target state="translated">결과의 스케일의 스케일과 동일하다 &lt;code&gt;this&lt;/code&gt; (divident) 및 라운딩 &lt;a href=&quot;http://docs.oracle.com/javase/8/docs/api/java/math/RoundingMode.html#HALF_EVEN&quot;&gt;RoundingMode.HALF_EVEN&lt;/a&gt; 라운딩 모드를 사용한다.</target>
        </trans-unit>
        <trans-unit id="f22bffdb314393bc05bae9820f09e84c2f28f7a7" translate="yes" xml:space="preserve">
          <source>The scope for yielding values of a &lt;a href=&quot;-sequence/index&quot;&gt;Sequence&lt;/a&gt; or an &lt;a href=&quot;../kotlin.collections/-iterator/index#kotlin.collections.Iterator&quot;&gt;Iterator&lt;/a&gt;, provides &lt;a href=&quot;-sequence-scope/yield&quot;&gt;yield&lt;/a&gt; and &lt;a href=&quot;-sequence-scope/yield-all&quot;&gt;yieldAll&lt;/a&gt; suspension functions.</source>
          <target state="translated">&lt;a href=&quot;-sequence/index&quot;&gt;Sequence&lt;/a&gt; 또는 &lt;a href=&quot;../kotlin.collections/-iterator/index#kotlin.collections.Iterator&quot;&gt;Iterator의&lt;/a&gt; 값을 산출하는 범위 는 &lt;a href=&quot;-sequence-scope/yield&quot;&gt;yield&lt;/a&gt; 및 &lt;a href=&quot;-sequence-scope/yield-all&quot;&gt;yieldAll&lt;/a&gt; 서스펜션 함수를 제공 합니다.</target>
        </trans-unit>
        <trans-unit id="4a3f3df589995633decc0a7530a1bb032d855ae5" translate="yes" xml:space="preserve">
          <source>The scope for yielding values of a &lt;a href=&quot;../-sequence/index&quot;&gt;Sequence&lt;/a&gt; or an &lt;a href=&quot;../../kotlin.collections/-iterator/index#kotlin.collections.Iterator&quot;&gt;Iterator&lt;/a&gt;, provides &lt;a href=&quot;yield&quot;&gt;yield&lt;/a&gt; and &lt;a href=&quot;yield-all&quot;&gt;yieldAll&lt;/a&gt; suspension functions.</source>
          <target state="translated">&lt;a href=&quot;../-sequence/index&quot;&gt;Sequence&lt;/a&gt; 또는 &lt;a href=&quot;../../kotlin.collections/-iterator/index#kotlin.collections.Iterator&quot;&gt;Iterator의&lt;/a&gt; 값을 산출하는 범위 는 &lt;a href=&quot;yield&quot;&gt;yield&lt;/a&gt; 및 &lt;a href=&quot;yield-all&quot;&gt;yieldAll&lt;/a&gt; 서스펜션 함수를 제공 합니다.</target>
        </trans-unit>
        <trans-unit id="a36f2feb54110b2ee9d15c70833427be6cae37ba" translate="yes" xml:space="preserve">
          <source>The scope for yielding values of a &lt;a href=&quot;../../kotlin.sequences/-sequence/index&quot;&gt;Sequence&lt;/a&gt; or an &lt;a href=&quot;../../kotlin.collections/-iterator/index#kotlin.collections.Iterator&quot;&gt;Iterator&lt;/a&gt;, provides &lt;a href=&quot;../../kotlin.sequences/-sequence-scope/yield&quot;&gt;yield&lt;/a&gt; and &lt;a href=&quot;../../kotlin.sequences/-sequence-scope/yield-all&quot;&gt;yieldAll&lt;/a&gt; suspension functions.</source>
          <target state="translated">&lt;a href=&quot;../../kotlin.sequences/-sequence/index&quot;&gt;Sequence&lt;/a&gt; 또는 &lt;a href=&quot;../../kotlin.collections/-iterator/index#kotlin.collections.Iterator&quot;&gt;Iterator의&lt;/a&gt; 값을 산출하는 범위 는 &lt;a href=&quot;../../kotlin.sequences/-sequence-scope/yield&quot;&gt;yield&lt;/a&gt; 및 &lt;a href=&quot;../../kotlin.sequences/-sequence-scope/yield-all&quot;&gt;yieldAll&lt;/a&gt; 서스펜션 함수를 제공 합니다.</target>
        </trans-unit>
        <trans-unit id="f47c36946d42e828300cda7cb035fe509918aa59" translate="yes" xml:space="preserve">
          <source>The scope functions differ by the result they return:</source>
          <target state="translated">범위 함수는 반환 결과에 따라 다릅니다.</target>
        </trans-unit>
        <trans-unit id="8f4977d6e6dad61eba46e51272eff7452a6f78a7" translate="yes" xml:space="preserve">
          <source>The scope functions do not introduce any new technical capabilities, but they can make your code more concise and readable.</source>
          <target state="translated">스코프 함수는 새로운 기술 기능을 도입하지 않지만 코드를보다 간결하고 읽기 쉽게 만들 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5f41bf24b11179244ce6543e55a837627d8700cb" translate="yes" xml:space="preserve">
          <source>The second line is the &lt;code&gt;headerFilter&lt;/code&gt;. This is used to denote what exactly we want included. In C, when one file references another file with the &lt;code&gt;#include&lt;/code&gt; directive, all the headers are also included. Sometimes this may not be needed, and we can use this parameter, &lt;a href=&quot;https://en.wikipedia.org/wiki/Glob_(programming)&quot;&gt;using glob patterns&lt;/a&gt;, to fine tune things. Note, that &lt;code&gt;headerFilter&lt;/code&gt; is an optional argument and mostly only used when the library we're using is being installed as a system library, and we do not want to fetch external dependencies (such as system &lt;code&gt;stdint.h&lt;/code&gt; header) into our interop library. It may be important for both optimizing the library size and fixing potential conflicts between the system and the Kotlin/Native provided compilation environment.</source>
          <target state="translated">두 번째 줄은 &lt;code&gt;headerFilter&lt;/code&gt; 입니다. 이것은 정확히 우리가 포함하고 싶은 것을 나타내는 데 사용됩니다. C에서 한 파일이 &lt;code&gt;#include&lt;/code&gt; 지시문으로 다른 파일을 참조 하면 모든 헤더도 포함됩니다. 때때로 이것은 필요하지 않을 수 있으며, &lt;a href=&quot;https://en.wikipedia.org/wiki/Glob_(programming)&quot;&gt;glob 패턴을&lt;/a&gt; 사용하여이 매개 변수를 사용하여 사물을 미세 조정할 수 있습니다. 참고 것을 &lt;code&gt;headerFilter&lt;/code&gt; 는 선택적 인수이며, 대부분은 단지 우리가 사용하고있는 라이브러리가 시스템 라이브러리로 설치하는 경우에 사용, 우리는 (예 : 시스템과 같은 외부 종속성을 가져하지 않으 &lt;code&gt;stdint.h&lt;/code&gt; 의 우리의 상호 운용성 라이브러리에 헤더를). 라이브러리 크기를 최적화하고 시스템과 Kotlin / Native 제공 컴파일 환경 간의 잠재적 충돌을 수정하는 것이 중요 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="840619ade32a5f33b95550212b369e6072d8ca9d" translate="yes" xml:space="preserve">
          <source>The second list contains the second elements.</source>
          <target state="translated">두 번째 목록에는 두 번째 요소가 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="61c6cf9e9e7f1d565d89fe5986da63f4fbcd432b" translate="yes" xml:space="preserve">
          <source>The second observation, is that &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.channels/on-receive-or-null.html&quot;&gt;onReceiveOrNull&lt;/a&gt; gets immediately selected when the channel is already closed.</source>
          <target state="translated">두 번째 관찰 은 채널이 이미 닫혀 있으면 &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.channels/on-receive-or-null.html&quot;&gt;onReceiveOrNull&lt;/a&gt; 이 즉시 선택 된다는 것 입니다.</target>
        </trans-unit>
        <trans-unit id="90bb330cf5e09011380c337ab5bbdf9ebc55c7f5" translate="yes" xml:space="preserve">
          <source>The second step is to configure the framework search path of the produced binary. It is also known as &lt;code&gt;rpath&lt;/code&gt; or &lt;a href=&quot;https://en.wikipedia.org/wiki/Rpath&quot;&gt;run-time search path&lt;/a&gt;. The binary uses the path to look for the required frameworks. We do not recommend installing additional frameworks to the OS if it is not needed. We should understand the layout of our future application, for example, we may have the &lt;code&gt;Frameworks&lt;/code&gt; folder under the application bundle with all the frameworks we use. The &lt;code&gt;@rpath&lt;/code&gt; parameter can be configured in Xcode. We need to open the &lt;em&gt;project&lt;/em&gt; configuration and find the &lt;code&gt;Runpath Search Paths&lt;/code&gt; section. Here we specify the relative path to the compiled framework.</source>
          <target state="translated">두 번째 단계는 생성 된 바이너리의 프레임 워크 검색 경로를 구성하는 것입니다. &lt;code&gt;rpath&lt;/code&gt; 또는 &lt;a href=&quot;https://en.wikipedia.org/wiki/Rpath&quot;&gt;런타임 검색 경로&lt;/a&gt; 라고도 합니다 . 바이너리는 경로를 사용하여 필요한 프레임 워크를 찾습니다. 필요하지 않은 경우 추가 프레임 워크를 OS에 설치하지 않는 것이 좋습니다. 예를 들어, 향후 응용 프로그램의 레이아웃을 이해해야합니다. 예를 들어, 사용하는 모든 프레임 워크와 함께 응용 프로그램 번들 아래에 &lt;code&gt;Frameworks&lt;/code&gt; 폴더 가있을 수 있습니다. &lt;code&gt;@rpath&lt;/code&gt; 의 파라미터 엑스 코드로 구성 될 수있다. &lt;em&gt;프로젝트&lt;/em&gt; 구성 을 열고 &lt;code&gt;Runpath Search Paths&lt;/code&gt; 섹션을 찾아야합니다 . 여기서는 컴파일 된 프레임 워크의 상대 경로를 지정합니다.</target>
        </trans-unit>
        <trans-unit id="654406bf07807fb9a1c468fda5253d223f604a77" translate="yes" xml:space="preserve">
          <source>The second step is to then include the framework path into the &lt;code&gt;Framework Search Paths&lt;/code&gt; block of the &lt;code&gt;Build Settings&lt;/code&gt; section of the &lt;em&gt;target&lt;/em&gt; configuration page. It is possible to use &lt;code&gt;$(PROJECT_DIR)&lt;/code&gt; macro to simplify the setup.</source>
          <target state="translated">두 번째 단계는 &lt;em&gt;대상&lt;/em&gt; 구성 페이지 의 &lt;code&gt;Build Settings&lt;/code&gt; 섹션에있는 &lt;code&gt;Framework Search Paths&lt;/code&gt; 블록에 프레임 워크 경로를 포함시키는 것 입니다. 사용할 수 있습니다 &lt;code&gt;$(PROJECT_DIR)&lt;/code&gt; 설정을 단순화하기 위해 매크로를.&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="18e3a3f25c81d64436deec2668dbca688024cd76" translate="yes" xml:space="preserve">
          <source>The second way is using typed getters. These getters allow one to access a binary of a certain type by its name prefix and build type.</source>
          <target state="translated">두 번째 방법은 형식화 된 게터를 사용하는 것입니다. 이 게터를 사용하면 이름 접두사 및 빌드 유형으로 특정 유형의 이진 파일에 액세스 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="827737115fbde8c1114cdac2570a8c2c25e8999d" translate="yes" xml:space="preserve">
          <source>The sequence can be iterated multiple times, each time starting with &lt;a href=&quot;generate-sequence#kotlin.sequences%24generateSequence%28kotlin.sequences.generateSequence.T%2C+kotlin.Function1%28%28kotlin.sequences.generateSequence.T%2C+kotlin.sequences.generateSequence.T%29%29%29%2Fseed&quot;&gt;seed&lt;/a&gt;.</source>
          <target state="translated">순서는 &lt;a href=&quot;generate-sequence#kotlin.sequences%24generateSequence%28kotlin.sequences.generateSequence.T%2C+kotlin.Function1%28%28kotlin.sequences.generateSequence.T%2C+kotlin.sequences.generateSequence.T%29%29%29%2Fseed&quot;&gt;seed로&lt;/a&gt; 시작할 때마다 여러 번 반복 될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="0eda5b13d201be08982eef0e6ce47fb43644a540" translate="yes" xml:space="preserve">
          <source>The sequence can be iterated multiple times.</source>
          <target state="translated">시퀀스는 여러 번 반복 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0a85208253c6224f238363151292bff48ddafdf4" translate="yes" xml:space="preserve">
          <source>The sequence can be potentially infinite.</source>
          <target state="translated">순서는 잠재적으로 무한 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0e5675a51efa9f06e75cacd0d5cc4fa5944cc8f4" translate="yes" xml:space="preserve">
          <source>The sequence of values returned by the given iterator can be potentially infinite.</source>
          <target state="translated">주어진 반복자가 반환 한 값의 시퀀스는 잠재적으로 무한 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7d79c1f34f116fdb6c923fac302558f761c71524" translate="yes" xml:space="preserve">
          <source>The sequence operations can be classified into the following groups regarding their state requirements:</source>
          <target state="translated">시퀀스 작업은 상태 요구 사항과 관련하여 다음 그룹으로 분류 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="30c4d2821891f6cd1d6f9f4ff92091f8670df4f6" translate="yes" xml:space="preserve">
          <source>The sequence processing goes like this:</source>
          <target state="translated">시퀀스 처리는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="037cfea620d6aaba99a768d063c28b857dfd0b60" translate="yes" xml:space="preserve">
          <source>The sequence produces values until it encounters first &lt;code&gt;null&lt;/code&gt; value. If &lt;a href=&quot;generate-sequence#kotlin.sequences%24generateSequence%28kotlin.Function0%28%28kotlin.sequences.generateSequence.T%29%29%2C+kotlin.Function1%28%28kotlin.sequences.generateSequence.T%2C+kotlin.sequences.generateSequence.T%29%29%29%2FseedFunction&quot;&gt;seedFunction&lt;/a&gt; returns &lt;code&gt;null&lt;/code&gt;, an empty sequence is produced.</source>
          <target state="translated">시퀀스는 첫 번째 &lt;code&gt;null&lt;/code&gt; 값 이 발생할 때까지 값을 생성합니다 . 경우 &lt;a href=&quot;generate-sequence#kotlin.sequences%24generateSequence%28kotlin.Function0%28%28kotlin.sequences.generateSequence.T%29%29%2C+kotlin.Function1%28%28kotlin.sequences.generateSequence.T%2C+kotlin.sequences.generateSequence.T%29%29%29%2FseedFunction&quot;&gt;seedFunction의&lt;/a&gt; 반환 &lt;code&gt;null&lt;/code&gt; , 빈 시퀀스를 생성한다.</target>
        </trans-unit>
        <trans-unit id="6f1a48a2bbbc690466820f3b0f0b43bc4de3e6e5" translate="yes" xml:space="preserve">
          <source>The sequence produces values until it encounters first &lt;code&gt;null&lt;/code&gt; value. If &lt;a href=&quot;generate-sequence#kotlin.sequences%24generateSequence%28kotlin.sequences.generateSequence.T%2C+kotlin.Function1%28%28kotlin.sequences.generateSequence.T%2C+kotlin.sequences.generateSequence.T%29%29%29%2Fseed&quot;&gt;seed&lt;/a&gt; is &lt;code&gt;null&lt;/code&gt;, an empty sequence is produced.</source>
          <target state="translated">시퀀스는 첫 번째 &lt;code&gt;null&lt;/code&gt; 값 이 발생할 때까지 값을 생성합니다 . 경우 &lt;a href=&quot;generate-sequence#kotlin.sequences%24generateSequence%28kotlin.sequences.generateSequence.T%2C+kotlin.Function1%28%28kotlin.sequences.generateSequence.T%2C+kotlin.sequences.generateSequence.T%29%29%29%2Fseed&quot;&gt;씨앗&lt;/a&gt; 이다 &lt;code&gt;null&lt;/code&gt; 빈 시퀀스가 생성된다.</target>
        </trans-unit>
        <trans-unit id="5a3082b192dc0701c42da2f86e13f788df24a0f1" translate="yes" xml:space="preserve">
          <source>The set of all possible types that can be substituted for a given type parameter may be restricted by &lt;strong&gt;generic constraints&lt;/strong&gt;.</source>
          <target state="translated">주어진 형식 매개 변수로 대체 할 수있는 모든 가능한 형식 집합은 &lt;strong&gt;일반 제약 조건에&lt;/strong&gt; 의해 제한 될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="bf0dd762f332fcd86a0727fbb8e23b4a1bb32f29" translate="yes" xml:space="preserve">
          <source>The set of options that were used to create this regular expression.</source>
          <target state="translated">이 정규 표현식을 작성하는 데 사용 된 옵션 세트.</target>
        </trans-unit>
        <trans-unit id="459759855b3639a06e88e0e2596d7493a847d411" translate="yes" xml:space="preserve">
          <source>The set of target platforms is defined by a multiplatform library author, and they should provide all of the platform-specific implementations for the library. Adding new targets for a multiplatform library at the consumer's side is not supported.</source>
          <target state="translated">대상 플랫폼 세트는 다중 플랫폼 라이브러리 작성자가 정의하며 라이브러리에 대한 모든 플랫폼 별 구현을 제공해야합니다. 소비자 측에서 멀티 플랫폼 라이브러리에 대한 새 대상 추가는 지원되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="488655893b603c994560325ea4e7b1458229763b" translate="yes" xml:space="preserve">
          <source>The setter of this mutable property, used to change the value of the property.</source>
          <target state="translated">속성 값을 변경하는 데 사용되는이 가변 속성의 setter입니다.</target>
        </trans-unit>
        <trans-unit id="67fe2f456972c4ac12399f4f27262af0c978820f" translate="yes" xml:space="preserve">
          <source>The signature of &lt;code&gt;greet()&lt;/code&gt; is &lt;code&gt;KFunction2&amp;lt;Person, String, String&amp;gt;&lt;/code&gt; because it's a function on &lt;code&gt;Person&lt;/code&gt; that takes a &lt;code&gt;String&lt;/code&gt; and returns a &lt;code&gt;String&lt;/code&gt;.</source>
          <target state="translated">의 서명 &lt;code&gt;greet()&lt;/code&gt; 입니다 &lt;code&gt;KFunction2&amp;lt;Person, String, String&amp;gt;&lt;/code&gt; 이 켜져 함수이기 때문에 &lt;code&gt;Person&lt;/code&gt; 소요 &lt;code&gt;String&lt;/code&gt; 과 리턴 &lt;code&gt;String&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3e351be319f91b0a3ca4911e8fb9da8a9528097a" translate="yes" xml:space="preserve">
          <source>The signature of a member function or an &lt;a href=&quot;extension-functionsproperties&quot;&gt;extension function&lt;/a&gt; begins with a &lt;em&gt;receiver&lt;/em&gt;: the type upon which the function can be invoked. For example, the signature of &lt;code&gt;toString()&lt;/code&gt; is &lt;code&gt;Any.() -&amp;gt; String&lt;/code&gt; - it can be called on any non-null object (the receiver), it takes no parameters, and it returns a &lt;code&gt;String&lt;/code&gt;. It is possible to write a lambda function with such a signature - this is called a &lt;em&gt;function literal with receiver&lt;/em&gt;, and is extremely useful for building DSLs.</source>
          <target state="translated">멤버 함수 또는 &lt;a href=&quot;extension-functionsproperties&quot;&gt;확장 함수&lt;/a&gt; 의 서명은 &lt;em&gt;수신자 (&lt;/em&gt; 함수를 호출 할 수있는 유형)로 시작합니다 . 예를 들어 &lt;code&gt;toString()&lt;/code&gt; 의 서명 은 &lt;code&gt;Any.() -&amp;gt; String&lt;/code&gt; -null이 아닌 객체 (수신자)에서 호출 할 수 있으며 매개 변수를 사용하지 않고 &lt;code&gt;String&lt;/code&gt; 을 반환합니다 . 이러한 서명으로 람다 함수를 작성할 수 있습니다.이를 &lt;em&gt;수신자와 함께 함수 리터럴&lt;/em&gt; 이라고하며 DSL을 작성하는 데 매우 유용합니다.</target>
        </trans-unit>
        <trans-unit id="aadf52185468aa82855f792813cb9471782e9fa0" translate="yes" xml:space="preserve">
          <source>The signature of the overriding function must exactly match the overridden one, except that the return type in the overriding function may be a subtype of the return type of the overridden function.</source>
          <target state="translated">재정의 함수의 반환 유형이 재정의 된 함수의 반환 유형의 하위 유형일 수 있다는 점을 제외하고 재정의 함수의 서명은 재정의 된 서명과 정확히 일치해야합니다.</target>
        </trans-unit>
        <trans-unit id="0290c571ea3c6c1d4ef5f1279658ebad7901a082" translate="yes" xml:space="preserve">
          <source>The simple name of the class as it was declared in the source code, or &lt;code&gt;null&lt;/code&gt; if the class has no name (if, for example, it is an anonymous object literal).</source>
          <target state="translated">소스 코드에서 선언 된 클래스의 단순 이름이거나 클래스에 이름이없는 경우 &lt;code&gt;null&lt;/code&gt; 입니다 (예 : 익명의 객체 리터럴 인 경우).</target>
        </trans-unit>
        <trans-unit id="4a78d65e883965ba15ad1eec8e7ccc645ad6c9f8" translate="yes" xml:space="preserve">
          <source>The simplest version doesn't require any additional parameters and creates one binary for each build type. Currently there a two build types available: &lt;code&gt;DEBUG&lt;/code&gt; (produces a not optimized binary with a debug information) and &lt;code&gt;RELEASE&lt;/code&gt; (produces an optimized binary without debug information). Consequently the following snippet creates two executable binaries: debug and release.</source>
          <target state="translated">가장 간단한 버전은 추가 매개 변수가 필요하지 않으며 각 빌드 유형마다 하나의 바이너리를 만듭니다. 현재 두 가지 빌드 유형이 있습니다. &lt;code&gt;DEBUG&lt;/code&gt; (디버그 정보가있는 최적화되지 않은 이진 파일을 생성 함 ) 및 &lt;code&gt;RELEASE&lt;/code&gt; (디버그 정보가없는 최적화 된 이진 파일을 생성 함). 결과적으로 다음 스 니펫은 디버그 및 릴리스라는 두 개의 실행 가능 바이너리를 작성합니다.</target>
        </trans-unit>
        <trans-unit id="0e7b9b0dd8fa90a8e9f2b4ea99f92d60e815b8b9" translate="yes" xml:space="preserve">
          <source>The single immutable C value. It is self-contained and doesn't depend on native memory.</source>
          <target state="translated">불변의 단일 C 값 자체 포함되어 있으며 기본 메모리에 의존하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="d8e685c40e1d41520bbfb52a9a2cf6ce5cf4d2b1" translate="yes" xml:space="preserve">
          <source>The single-parent rule often becomes too limiting, as you'll often find commonalities between classes in different branches of a class hierarchy. These commonalities can be expressed in &lt;em&gt;interfaces&lt;/em&gt;.</source>
          <target state="translated">단일 부모 규칙은 클래스 계층 구조의 서로 다른 브랜치에서 클래스 사이에 공통점이 있기 때문에 종종 너무 제한됩니다. 이러한 공통성은 &lt;em&gt;인터페이스&lt;/em&gt; 로 표현 될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="ad2d029e0bf9000bbb670b32b9cfbfdfb5c64ee2" translate="yes" xml:space="preserve">
          <source>The solution is a &lt;em&gt;delegated property&lt;/em&gt;, which allows you to specify the behavior of getting and setting a property (somewhat similar to implementing &lt;code&gt;__getattribute__()&lt;/code&gt; and &lt;code&gt;__setattribute__()&lt;/code&gt; in Python, but for one property at a time).</source>
          <target state="translated">해결책은 &lt;em&gt;위임 된 속성으로&lt;/em&gt; , &lt;em&gt;속성&lt;/em&gt; 을 가져오고 설정하는 동작을 지정할 수 있습니다 &lt;code&gt;__setattribute__()&lt;/code&gt; 파이썬에서 &lt;code&gt;__getattribute__()&lt;/code&gt; 및 __setattribute __ () 구현과 비슷 하지만 한 번에 하나의 속성).</target>
        </trans-unit>
        <trans-unit id="02ba30e8a0350e3498389f6bdcc51b4d923322f5" translate="yes" xml:space="preserve">
          <source>The solution is to mark the targets with a custom attribute, which is taken into account by Gradle during dependency resolution. This, however, must be done on both the library author and the consumer sides, and it's the library author's responsibility to communicate the attribute and its possible values to the consumers.</source>
          <target state="translated">해결책은 대상을 사용자 지정 특성으로 표시하는 것입니다.이 특성은 종속성 해결 중에 Gradle에서 고려됩니다. 그러나 이것은 라이브러리 작성자와 소비자 측 모두에서 수행되어야하며 속성과 가능한 값을 소비자에게 전달하는 것은 라이브러리 작성자의 책임입니다.</target>
        </trans-unit>
        <trans-unit id="4ce364ecc8aca93a0b9f937690067d3d1f6fcb4e" translate="yes" xml:space="preserve">
          <source>The sort is &lt;em&gt;stable&lt;/em&gt;. It means that equal elements preserve their order relative to each other after sorting.</source>
          <target state="translated">정렬이 &lt;em&gt;안정적&lt;/em&gt; 입니다. 즉, 동일한 요소가 정렬 후 서로에 대한 순서를 유지합니다.</target>
        </trans-unit>
        <trans-unit id="563e0866ee26fde4dae779a523cc71b4cbb6977d" translate="yes" xml:space="preserve">
          <source>The source set names are case-sensitive. When referring to a default source set by its name, make sure the name prefix matches a target's name, for example, a source set &lt;code&gt;iosX64Main&lt;/code&gt; for a target &lt;code&gt;iosX64&lt;/code&gt;.</source>
          <target state="translated">소스 세트 이름은 대소 문자를 구분합니다. 이름으로 기본 소스 세트를 참조 할 때 이름 &lt;code&gt;iosX64Main&lt;/code&gt; 두부가 대상의 이름과 일치하는지 확인하십시오 (예 : 대상 &lt;code&gt;iosX64&lt;/code&gt; 의 소스 세트 iosX64Main) .</target>
        </trans-unit>
        <trans-unit id="11b3468dd6e9b05386099434c4ca46b0c2547522" translate="yes" xml:space="preserve">
          <source>The source sets DSL can be used to define these connections between the source sets:</source>
          <target state="translated">소스 세트 DSL을 사용하여 소스 세트 간의 이러한 연결을 정의 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5ee1552c884a6b1c888ad99542230488f493bca7" translate="yes" xml:space="preserve">
          <source>The source sets are configured within a &lt;code&gt;sourceSets { ... }&lt;/code&gt; block of the &lt;code&gt;kotlin { ... }&lt;/code&gt; extension:</source>
          <target state="translated">소스 세트는 &lt;code&gt;kotlin { ... }&lt;/code&gt; 확장자 의 &lt;code&gt;sourceSets { ... }&lt;/code&gt; 블록 내에 구성됩니다 .</target>
        </trans-unit>
        <trans-unit id="d4cf592997fcfc68c560b9248ead3349afe2d7c1" translate="yes" xml:space="preserve">
          <source>The specification of the requirements to the delegated object can be found &lt;a href=&quot;delegated-properties#property-delegate-requirements&quot;&gt;below&lt;/a&gt;.</source>
          <target state="translated">위임 된 객체에 대한 요구 사항의 사양은 &lt;a href=&quot;delegated-properties#property-delegate-requirements&quot;&gt;아래에서&lt;/a&gt; 확인할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="63949c8dfec16ede4c20d9d3cd58cdaf9f88fafe" translate="yes" xml:space="preserve">
          <source>The standard JavaDoc generation plugin (&lt;code&gt;maven-javadoc-plugin&lt;/code&gt;) does not support Kotlin code. To generate documentation for Kotlin projects, use &lt;a href=&quot;https://github.com/Kotlin/dokka&quot;&gt;Dokka&lt;/a&gt;; please refer to the &lt;a href=&quot;https://github.com/Kotlin/dokka/blob/master/README.md#using-the-maven-plugin&quot;&gt;Dokka README&lt;/a&gt; for configuration instructions. Dokka supports mixed-language projects and can generate output in multiple formats, including standard JavaDoc.</source>
          <target state="translated">표준 JavaDoc 생성 플러그인 ( &lt;code&gt;maven-javadoc-plugin&lt;/code&gt; )은 Kotlin 코드를 지원하지 않습니다. Kotlin 프로젝트에 대한 문서를 생성하려면 &lt;a href=&quot;https://github.com/Kotlin/dokka&quot;&gt;Dokka를&lt;/a&gt; 사용하십시오 . 구성 지침 은 &lt;a href=&quot;https://github.com/Kotlin/dokka/blob/master/README.md#using-the-maven-plugin&quot;&gt;Dokka README&lt;/a&gt; 를 참조하십시오 . Dokka는 혼합 언어 프로젝트를 지원하며 표준 JavaDoc을 포함하여 여러 형식으로 출력을 생성 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="bb8d32cf58d6a52257e9ed55a0d5c90647cf240f" translate="yes" xml:space="preserve">
          <source>The standard library contains a group of extension functions that let you filter collections in a single call. These functions leave the original collection unchanged, so they are available for both &lt;a href=&quot;collections-overview#collection-types&quot;&gt;mutable and read-only&lt;/a&gt; collections. To operate the filtering result, you should assign it to a variable or chain the functions after filtering.</source>
          <target state="translated">표준 라이브러리에는 단일 호출에서 모음을 필터링 할 수있는 확장 기능 그룹이 포함되어 있습니다. 이러한 함수는 원본 컬렉션을 변경하지 않고 &lt;a href=&quot;collections-overview#collection-types&quot;&gt;변경 가능하고 읽기 전용&lt;/a&gt; 컬렉션 에 모두 사용할 수 있습니다 . 필터링 결과를 조작하려면 필터링 후 결과를 변수에 지정하거나 함수를 연결해야합니다.</target>
        </trans-unit>
        <trans-unit id="64cd7cca211b28854215461360962734eb107f4c" translate="yes" xml:space="preserve">
          <source>The standard library defines a function named &lt;a href=&quot;../../../api/latest/jvm/stdlib/kotlin.js/as-dynamic&quot;&gt;&lt;code&gt;asDynamic()&lt;/code&gt;&lt;/a&gt; which casts a value to the dynamic type. Given our previous example where we used jQuery to work with DOM elements, we can now combine this with &lt;code&gt;asDynamic()&lt;/code&gt; to then invoke &lt;code&gt;dataTable()&lt;/code&gt; on the result:</source>
          <target state="translated">표준 라이브러리는 값을 동적 유형으로 캐스팅하는 &lt;a href=&quot;../../../api/latest/jvm/stdlib/kotlin.js/as-dynamic&quot;&gt; &lt;code&gt;asDynamic()&lt;/code&gt; &lt;/a&gt; 이라는 함수를 정의합니다 . jQuery를 사용하여 DOM 요소로 작업 한 이전 예를 &lt;code&gt;asDynamic()&lt;/code&gt; 이제이를 asDynamic () 과 결합 하여 결과에서 &lt;code&gt;dataTable()&lt;/code&gt; 을 호출 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2f92a5708c1e21664731222bd701621446c56d87" translate="yes" xml:space="preserve">
          <source>The standard library now provides a set of functions for element-by-element operations on arrays: comparison (&lt;code&gt;contentEquals&lt;/code&gt; and &lt;code&gt;contentDeepEquals&lt;/code&gt;), hash code calculation (&lt;code&gt;contentHashCode&lt;/code&gt; and &lt;code&gt;contentDeepHashCode&lt;/code&gt;), and conversion to a string (&lt;code&gt;contentToString&lt;/code&gt; and &lt;code&gt;contentDeepToString&lt;/code&gt;). They're supported both for the JVM (where they act as aliases for the corresponding functions in &lt;code&gt;java.util.Arrays&lt;/code&gt;) and for JS (where the implementation is provided in the Kotlin standard library).</source>
          <target state="translated">표준 라이브러리는 이제 비교 ( &lt;code&gt;contentEquals&lt;/code&gt; 및 &lt;code&gt;contentDeepEquals&lt;/code&gt; ), 해시 코드 계산 ( &lt;code&gt;contentHashCode&lt;/code&gt; 및 &lt;code&gt;contentDeepHashCode&lt;/code&gt; ) 및 문자열로 변환 ( &lt;code&gt;contentToString&lt;/code&gt; 및 &lt;code&gt;contentDeepToString&lt;/code&gt; )에 대한 요소 별 조작을위한 함수 세트를 제공합니다 . JVM ( &lt;code&gt;java.util.Arrays&lt;/code&gt; 의 해당 함수에 대한 별명으로 작동 ) 및 JS (구현이 Kotlin 표준 라이브러리에서 제공되는 경우) 모두에서 지원됩니다.</target>
        </trans-unit>
        <trans-unit id="4cd1337efd07a01ae50fb56677c92729c05a2ca9" translate="yes" xml:space="preserve">
          <source>The standard library provides &lt;code&gt;Pair&lt;/code&gt; and &lt;code&gt;Triple&lt;/code&gt;. In most cases, though, named data classes are a better design choice, because they make the code more readable by providing meaningful names for properties.</source>
          <target state="translated">표준 라이브러리는 &lt;code&gt;Pair&lt;/code&gt; and &lt;code&gt;Triple&lt;/code&gt; 을 제공합니다 . 그러나 대부분의 경우 명명 된 데이터 클래스는 속성에 의미있는 이름을 제공하여 코드를 더 읽기 쉽게하기 때문에 더 나은 디자인 선택입니다.</target>
        </trans-unit>
        <trans-unit id="0fa7bf33e28a4e2133f3eb85b822f13a5861e747" translate="yes" xml:space="preserve">
          <source>The standard library provides us with a series of wrappers around DOM as well as functions to work with JavaScript, using static typing. What happens however when we want to use a library such as jQuery? Kotlin does not have its own &quot;header&quot; files for all the different libraries available on the JavaScript ecosystem however, TypeScript does. The &lt;a href=&quot;https://github.com/DefinitelyTyped/DefinitelyTyped/&quot;&gt;Definitely Typed repository&lt;/a&gt; provides us with a very large selection of header files.</source>
          <target state="translated">표준 라이브러리는 정적 타이핑을 사용하여 JavaScript를 다루는 함수뿐만 아니라 DOM에 대한 일련의 래퍼를 제공합니다. 그러나 jQuery와 같은 라이브러리를 사용하려면 어떻게됩니까? Kotlin에는 JavaScript 생태계에서 사용 가능한 모든 다른 라이브러리에 대한 자체 &quot;헤더&quot;파일이 없지만 TypeScript에는 있습니다. &lt;a href=&quot;https://github.com/DefinitelyTyped/DefinitelyTyped/&quot;&gt;확실히 입력 된 저장소는&lt;/a&gt; 헤더 파일의 매우 큰 선택을 우리에게 제공한다.</target>
        </trans-unit>
        <trans-unit id="5b02aa301d08018505c67b11eafce33e20430963" translate="yes" xml:space="preserve">
          <source>The standard library uses coroutines to support &lt;em&gt;lazily generated sequences&lt;/em&gt; with &lt;code&gt;yield&lt;/code&gt; and &lt;code&gt;yieldAll&lt;/code&gt; functions. In such a sequence, the block of code that returns sequence elements is suspended after each element has been retrieved, and resumed when the next element is requested. Here's an example:</source>
          <target state="translated">표준 라이브러리는 코 루틴을 사용 하여 &lt;code&gt;yield&lt;/code&gt; 및 &lt;code&gt;yieldAll&lt;/code&gt; 함수로 &lt;em&gt;느리게 생성 된 시퀀스&lt;/em&gt; 를 지원 합니다. 이러한 시퀀스에서 시퀀스 요소를 반환하는 코드 블록은 각 요소가 검색된 후 일시 중단되고 다음 요소가 요청되면 다시 시작됩니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="bd81d65292e2ed27e6a7bd7b3f70e04e3c6f5969" translate="yes" xml:space="preserve">
          <source>The status value in &lt;code&gt;@UnderMigration(status = ...)&lt;/code&gt; specifies how the compiler treats inappropriate usages of the annotated types in Kotlin (e.g. using a &lt;code&gt;@MyNullable&lt;/code&gt;-annotated type value as non-null):</source>
          <target state="translated">&lt;code&gt;@UnderMigration(status = ...)&lt;/code&gt; 의 상태 값 은 컴파일러가 Kotlin에서 어노테이션이있는 유형의 부적절한 사용법을 처리하는 방법을 지정합니다 (예 : &lt;code&gt;@MyNullable&lt;/code&gt; -어노테이션이있는 유형 값을 널이 아닌 것으로 사용).</target>
        </trans-unit>
        <trans-unit id="4dfa4a2af58e962d2e78195bb041069a8bfddba3" translate="yes" xml:space="preserve">
          <source>The step of the progression.</source>
          <target state="translated">진행의 단계.</target>
        </trans-unit>
        <trans-unit id="e2561323722fd466eed7e84734bba0e2d9a0a20e" translate="yes" xml:space="preserve">
          <source>The step value must be positive. If you need to count downwards, use the inclusive &lt;code&gt;downTo&lt;/code&gt;:</source>
          <target state="translated">단계 값은 양수 여야합니다. 아래로 계산해야하는 경우 포괄적 인 &lt;code&gt;downTo&lt;/code&gt; 를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="ba5dcc36cf4e926283f2cf38c8b5b4a8a22b74ac" translate="yes" xml:space="preserve">
          <source>The subclass &lt;em&gt;inherits&lt;/em&gt; all members that exist in its superclass - both those that are directly defined in the superclass and the ones that the superclass itself has inherited. In this example, &lt;code&gt;Car&lt;/code&gt; contains the following members:</source>
          <target state="translated">서브 클래스 &lt;em&gt;는&lt;/em&gt; 수퍼 클래스에 존재하는 모든 멤버 (수퍼 클래스에 직접 정의 된 멤버와 수퍼 클래스 자체가 상속 한 멤버)를 모두 상속합니다. 이 예에서 &lt;code&gt;Car&lt;/code&gt; 는 다음 멤버를 포함합니다.</target>
        </trans-unit>
        <trans-unit id="9587208b56b71c873bb976ba7dd19e63565c1783" translate="yes" xml:space="preserve">
          <source>The substring from the input string captured by this match.</source>
          <target state="translated">이 일치에 의해 캡처 된 입력 문자열의 하위 문자열입니다.</target>
        </trans-unit>
        <trans-unit id="ef9d4de4ce3f425feef1d92bfbe702742ff76fe2" translate="yes" xml:space="preserve">
          <source>The syntax is: &lt;code&gt;val/var &amp;lt;property name&amp;gt;: &amp;lt;Type&amp;gt; by &amp;lt;expression&amp;gt;&lt;/code&gt;. The expression after &lt;em&gt;by&lt;/em&gt; is the &lt;em&gt;delegate&lt;/em&gt;, because &lt;code&gt;get()&lt;/code&gt; (and &lt;code&gt;set()&lt;/code&gt;) corresponding to the property will be delegated to its &lt;code&gt;getValue()&lt;/code&gt; and &lt;code&gt;setValue()&lt;/code&gt; methods. Property delegates don&amp;rsquo;t have to implement any interface, but they have to provide a &lt;code&gt;getValue()&lt;/code&gt; function (and &lt;code&gt;setValue()&lt;/code&gt; &amp;mdash; for &lt;em&gt;var&lt;/em&gt;s). For example:</source>
          <target state="translated">구문은 &lt;code&gt;val/var &amp;lt;property name&amp;gt;: &amp;lt;Type&amp;gt; by &amp;lt;expression&amp;gt;&lt;/code&gt; 입니다. 속성에 해당하는 &lt;code&gt;get()&lt;/code&gt; (및 &lt;code&gt;set()&lt;/code&gt; )이 &lt;code&gt;getValue()&lt;/code&gt; 및 &lt;code&gt;setValue()&lt;/code&gt; 메소드에 &lt;em&gt;위임&lt;/em&gt; 되기 때문에 &lt;em&gt;by by&lt;/em&gt; 뒤의 표현식 은 &lt;em&gt;delegate&lt;/em&gt; 입니다. 부동산 대표는 인터페이스를 구현할 필요는 없지만, 그들은 제공해야 &lt;code&gt;getValue()&lt;/code&gt; 함수를 (와 &lt;code&gt;setValue()&lt;/code&gt; - 대한 &lt;em&gt;VAR&lt;/em&gt; 들). 예를 들면 다음과 같습니다.&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="7f8b0e5f27ed7447035e9e8912fa4868135e5b36" translate="yes" xml:space="preserve">
          <source>The table below shows how Kotlin concepts are mapped to Swift/Objective-C and vice versa.</source>
          <target state="translated">아래 표는 Kotlin 개념이 Swift / Objective-C에 매핑되고 그 반대의 방법을 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="27aee67b81ecee081c926fb6403fc250a2669b58" translate="yes" xml:space="preserve">
          <source>The targets created from presets are added to the &lt;code&gt;kotlin.targets&lt;/code&gt; domain object collection, which can be used to access them by their names or configure all targets:</source>
          <target state="translated">사전 설정에서 생성 된 대상이 &lt;code&gt;kotlin.targets&lt;/code&gt; 도메인 객체 컬렉션에 추가되어 이름으로 액세스하거나 모든 대상을 구성하는 데 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ea834ff7223c20a4c037e26a9eaa3ee2e490ee75" translate="yes" xml:space="preserve">
          <source>The terminology is that &lt;code&gt;var&lt;/code&gt; declares a &lt;em&gt;mutable&lt;/em&gt; variable, and that &lt;code&gt;val&lt;/code&gt; declares a &lt;em&gt;read-only&lt;/em&gt; or &lt;em&gt;assign-once&lt;/em&gt; variable - so both kinds are called &lt;em&gt;variables&lt;/em&gt;.</source>
          <target state="translated">용어는 &lt;code&gt;var&lt;/code&gt; 가 &lt;em&gt;가변&lt;/em&gt; 변수를 선언하고 &lt;code&gt;val&lt;/code&gt; 이 &lt;em&gt;읽기 전용&lt;/em&gt; 또는 &lt;em&gt;한 번만 할당&lt;/em&gt; 변수를 선언 하므로 두 종류를 모두 &lt;em&gt;변수&lt;/em&gt; 라고 &lt;em&gt;합니다&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="d2c1a93ffe9401881d7e0f5a7066475d9434f33d" translate="yes" xml:space="preserve">
          <source>The the &lt;a href=&quot;https://github.com/ilmat192/kotlin-native-serialization-sample&quot;&gt;example project&lt;/a&gt; for details.</source>
          <target state="translated">자세한 내용 은 &lt;a href=&quot;https://github.com/ilmat192/kotlin-native-serialization-sample&quot;&gt;예제 프로젝트&lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="db0d4a97f9fddd6cc7f4a4e559ab92c9b243b3dc" translate="yes" xml:space="preserve">
          <source>The third option is for NPE-lovers: the not-null assertion operator (&lt;code&gt;!!&lt;/code&gt;) converts any value to a non-null type and throws an exception if the value is null. We can write &lt;code&gt;b!!&lt;/code&gt;, and this will return a non-null value of &lt;code&gt;b&lt;/code&gt; (e.g., a &lt;code&gt;String&lt;/code&gt; in our example) or throw an NPE if &lt;code&gt;b&lt;/code&gt; is null:</source>
          <target state="translated">세 번째 옵션은 NPE 애호가를위한 것입니다. Null이 아닌 어설 션 연산자 ( &lt;code&gt;!!&lt;/code&gt; )는 모든 값을 Null이 아닌 유형으로 변환하고 값이 null 인 경우 예외를 throw합니다. 우리는 &lt;code&gt;b!!&lt;/code&gt; 를 쓸 수있다 !! 이 경우 null이 아닌 값 &lt;code&gt;b&lt;/code&gt; (예 : &lt;code&gt;String&lt;/code&gt; 가 반환 되거나 &lt;code&gt;b&lt;/code&gt; 가 null 인 경우 NPE가 발생합니다 .</target>
        </trans-unit>
        <trans-unit id="328eee564065ef14869693e4097fdfb0bb1e1ca4" translate="yes" xml:space="preserve">
          <source>The three targets are created with the preset functions &lt;code&gt;jvm()&lt;/code&gt;, &lt;code&gt;js()&lt;/code&gt;, and &lt;code&gt;mingwX64()&lt;/code&gt; that provide some &lt;a href=&quot;#default-project-layout&quot;&gt;default configuration&lt;/a&gt;. There are presets for each of the &lt;a href=&quot;#supported-platforms&quot;&gt;supported platforms&lt;/a&gt;.</source>
          <target state="translated">세 가지 대상은 &lt;a href=&quot;#default-project-layout&quot;&gt;기본 구성&lt;/a&gt; 을 제공 하는 사전 설정 함수 &lt;code&gt;jvm()&lt;/code&gt; , &lt;code&gt;js()&lt;/code&gt; 및 &lt;code&gt;mingwX64()&lt;/code&gt; 됩니다. &lt;a href=&quot;#supported-platforms&quot;&gt;지원되는&lt;/a&gt; 각 플랫폼에 대한 사전 설정이 있습니다 .</target>
        </trans-unit>
        <trans-unit id="3871e9aa2f804023caa55782736ddd2a4dee3be1" translate="yes" xml:space="preserve">
          <source>The two characters are the same (as compared by the == operator)</source>
          <target state="translated">두 문자는 동일합니다 (== 연산자와 비교하여)</target>
        </trans-unit>
        <trans-unit id="43727256131e4c09e21487921129d951e5403bce" translate="yes" xml:space="preserve">
          <source>The type &lt;a href=&quot;exceptions#the-nothing-type&quot;&gt;&lt;code&gt;Nothing&lt;/code&gt;&lt;/a&gt; is special, because it has no natural counterpart in Java. Indeed, every Java reference type, including &lt;code&gt;java.lang.Void&lt;/code&gt;, accepts &lt;code&gt;null&lt;/code&gt; as a value, and &lt;code&gt;Nothing&lt;/code&gt; doesn't accept even that. So, this type cannot be accurately represented in the Java world. This is why Kotlin generates a raw type where an argument of type &lt;code&gt;Nothing&lt;/code&gt; is used:</source>
          <target state="translated">&lt;a href=&quot;exceptions#the-nothing-type&quot;&gt; &lt;code&gt;Nothing&lt;/code&gt; &lt;/a&gt; 유형 은 Java에서 자연스럽게 대응되지 않기 때문에 특별합니다. 실제로 &lt;code&gt;java.lang.Void&lt;/code&gt; 를 포함한 모든 Java 참조 유형 은 &lt;code&gt;null&lt;/code&gt; 을 값으로 허용 하며 &lt;code&gt;Nothing&lt;/code&gt; 조차도 허용하지 않습니다. 따라서이 유형은 Java 세계에서 정확하게 표현 될 수 없습니다. 이것이 Kotlin이 &lt;code&gt;Nothing&lt;/code&gt; 유형의 인수 가 사용되는 원시 유형을 생성하는 이유 입니다.</target>
        </trans-unit>
        <trans-unit id="5840d7b86dbf1ab10e5032023a9859ef434e1278" translate="yes" xml:space="preserve">
          <source>The type &lt;code&gt;Boolean&lt;/code&gt; represents booleans, and has two values: &lt;em&gt;true&lt;/em&gt; and &lt;em&gt;false&lt;/em&gt;.</source>
          <target state="translated">&lt;code&gt;Boolean&lt;/code&gt; 유형은 부울을 나타내며 &lt;em&gt;true&lt;/em&gt; 및 &lt;em&gt;false의&lt;/em&gt; 두 값이 있습니다.</target>
        </trans-unit>
        <trans-unit id="fdef02e2cbe116b674c3a5cab83d13e4789bcc49" translate="yes" xml:space="preserve">
          <source>The type argument &lt;code&gt;T&lt;/code&gt; of &lt;code&gt;CPointer&amp;lt;T&amp;gt;&lt;/code&gt; must be one of the &quot;lvalue&quot; types described above, e.g., the C type &lt;code&gt;struct S*&lt;/code&gt; is mapped to &lt;code&gt;CPointer&amp;lt;S&amp;gt;&lt;/code&gt;, &lt;code&gt;int8_t*&lt;/code&gt; is mapped to &lt;code&gt;CPointer&amp;lt;int_8tVar&amp;gt;&lt;/code&gt;, and &lt;code&gt;char**&lt;/code&gt; is mapped to &lt;code&gt;CPointer&amp;lt;CPointerVar&amp;lt;ByteVar&amp;gt;&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;CPointer&amp;lt;T&amp;gt;&lt;/code&gt; 의 type 인수 &lt;code&gt;T&lt;/code&gt; 는 위에서 설명한 &quot;lvalue&quot;유형 중 하나 여야합니다. 예를 들어 C type &lt;code&gt;struct S*&lt;/code&gt; 는 &lt;code&gt;CPointer&amp;lt;S&amp;gt;&lt;/code&gt; 에 매핑되고 &lt;code&gt;CPointer&amp;lt;int_8tVar&amp;gt;&lt;/code&gt; &lt;code&gt;int8_t*&lt;/code&gt; 는 CPointer &amp;lt;int_8tVar&amp;gt;에 매핑 되고 &lt;code&gt;char**&lt;/code&gt; 는 &lt;code&gt;CPointer&amp;lt;CPointerVar&amp;lt;ByteVar&amp;gt;&amp;gt;&lt;/code&gt; 매핑됩니다 .</target>
        </trans-unit>
        <trans-unit id="304e12f8621867e9197c2891cfb5db65d05e542f" translate="yes" xml:space="preserve">
          <source>The type arguments of generic function calls are also only checked at compile time. Inside the function bodies, the type parameters cannot be used for type checks, and type casts to type parameters (&lt;code&gt;foo as T&lt;/code&gt;) are unchecked. However, &lt;a href=&quot;inline-functions#reified-type-parameters&quot;&gt;reified type parameters&lt;/a&gt; of inline functions are substituted by the actual type arguments in the inlined function body at the call sites and thus can be used for type checks and casts, with the same restrictions for instances of generic types as described above.</source>
          <target state="translated">일반 함수 호출의 유형 인수는 컴파일시에만 확인됩니다. 함수 본문 내에서 형식 매개 변수는 형식 검사에 사용할 수 없으며 형식 매개 변수에 대한 형식 캐스트 ( &lt;code&gt;foo as T&lt;/code&gt; )는 선택되지 않습니다. 그러나 인라인 함수의 &lt;a href=&quot;inline-functions#reified-type-parameters&quot;&gt;구체화 된 유형 매개 변수&lt;/a&gt; 는 호출 사이트에서 인라인 된 함수 본문의 실제 유형 인수로 대체되므로 위에서 설명한 일반 유형의 인스턴스에 대한 동일한 제한 사항으로 유형 검사 및 캐스트에 사용될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6d035411fbfdc1232561efb8b45fef51b9b3f1fe" translate="yes" xml:space="preserve">
          <source>The type of &lt;code&gt;safeDivide&lt;/code&gt; is &lt;code&gt;(Int, Int) -&amp;gt; Double&lt;/code&gt;. Note that unlike function type declarations, the parameter list of a lambda expression must not be enclosed in parentheses.</source>
          <target state="translated">&lt;code&gt;safeDivide&lt;/code&gt; 의 유형 은 &lt;code&gt;(Int, Int) -&amp;gt; Double&lt;/code&gt; 입니다. 함수 유형 선언과 달리 람다 식의 매개 변수 목록은 괄호로 묶어서는 안됩니다.</target>
        </trans-unit>
        <trans-unit id="c50d2b6bc67063abeddc4b2628733da7784a58f0" translate="yes" xml:space="preserve">
          <source>The type of a property, and the types that are used for the parameters and the return type of a function, must be &quot;at least as visible&quot; as the property/function itself. For example, a public function can't take a private type as a parameter.</source>
          <target state="translated">속성의 유형과 매개 변수에 사용되는 유형 및 함수의 반환 유형은 속성 / 함수 자체만큼 &quot;적어도 가시적&quot;이어야합니다. 예를 들어, 공용 함수는 전용 유형을 매개 변수로 사용할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="8de1071b6667ea170a2315b344096736147854e4" translate="yes" xml:space="preserve">
          <source>The type of the &lt;code&gt;throw&lt;/code&gt; expression is the special type &lt;code&gt;Nothing&lt;/code&gt;. The type has no values and is used to mark code locations that can never be reached. In your own code, you can use &lt;code&gt;Nothing&lt;/code&gt; to mark a function that never returns:</source>
          <target state="translated">&lt;code&gt;throw&lt;/code&gt; 표현식 의 유형은 특수 유형 &lt;code&gt;Nothing&lt;/code&gt; 입니다. 이 유형에는 값이 없으며 도달 할 수없는 코드 위치를 표시하는 데 사용됩니다. 자체 코드에서 &lt;code&gt;Nothing&lt;/code&gt; 을 사용 하여 절대 반환하지 않는 함수를 표시 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="23c18621bf7101376cb4104c69faad184a7d75d0" translate="yes" xml:space="preserve">
          <source>The type of these expressions is the &lt;a href=&quot;exceptions#the-nothing-type&quot;&gt;Nothing type&lt;/a&gt;.</source>
          <target state="translated">이러한 표현식의 유형은 &lt;a href=&quot;exceptions#the-nothing-type&quot;&gt;Nothing 유형&lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="28dfc8e3403b9f6de19da78b037825e3337aa674" translate="yes" xml:space="preserve">
          <source>The type of values returned by this callable.</source>
          <target state="translated">이 호출 가능 객체가 반환 한 값의 유형입니다.</target>
        </trans-unit>
        <trans-unit id="724404b217f8e33affca4710ff6d760dfbd8b8e9" translate="yes" xml:space="preserve">
          <source>The type safety checks that Kotlin performs for generic declaration usages are only done at compile time. At runtime, the instances of generic types do not hold any information about their actual type arguments. The type information is said to be &lt;em&gt;erased&lt;/em&gt;. For example, the instances of &lt;code&gt;Foo&amp;lt;Bar&amp;gt;&lt;/code&gt; and &lt;code&gt;Foo&amp;lt;Baz?&amp;gt;&lt;/code&gt; are erased to just &lt;code&gt;Foo&amp;lt;*&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">Kotlin이 일반 선언 사용에 대해 수행하는 형식 안전 검사는 컴파일 타임에만 수행됩니다. 런타임시 일반 유형의 인스턴스는 실제 유형 인수에 대한 정보를 보유하지 않습니다. 유형 정보가 &lt;em&gt;지워&lt;/em&gt; 졌다고합니다 . 예를 들어 &lt;code&gt;Foo&amp;lt;Bar&amp;gt;&lt;/code&gt; 및 &lt;code&gt;Foo&amp;lt;Baz?&amp;gt;&lt;/code&gt; 인스턴스는 &lt;code&gt;Foo&amp;lt;*&amp;gt;&lt;/code&gt; 로 지워집니다 .</target>
        </trans-unit>
        <trans-unit id="bd9368e467f6513ce687f28529e6a3ccfb31bd57" translate="yes" xml:space="preserve">
          <source>The type specified after a colon is the &lt;strong&gt;upper bound&lt;/strong&gt;: only a subtype of &lt;code&gt;Comparable&amp;lt;T&amp;gt;&lt;/code&gt; may be substituted for &lt;code&gt;T&lt;/code&gt;. For example:</source>
          <target state="translated">콜론 이후 지정된 유형 인 &lt;strong&gt;상한&lt;/strong&gt; 의 서브 타입 : &lt;code&gt;Comparable&amp;lt;T&amp;gt;&lt;/code&gt; 치환 될 수 &lt;code&gt;T&lt;/code&gt; . 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="195a81820ffdceacb4b4779278f03f44e25e239e" translate="yes" xml:space="preserve">
          <source>The type specified in the projection, or &lt;code&gt;null&lt;/code&gt; if this is a star projection.</source>
          <target state="translated">투영에 지정된 유형이거나 별 투영 인 경우 &lt;code&gt;null&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="e184ade95bbad48da746688d8668a604f12d3467" translate="yes" xml:space="preserve">
          <source>The type with only one value: the &lt;code&gt;Unit&lt;/code&gt; object.</source>
          <target state="translated">단 하나의 값을 가진 유형 : &lt;code&gt;Unit&lt;/code&gt; 객체.</target>
        </trans-unit>
        <trans-unit id="19328e2c828d83e68c896264bdfa85a39aa786f7" translate="yes" xml:space="preserve">
          <source>The type with only one value: the &lt;code&gt;Unit&lt;/code&gt; object. This type corresponds to the &lt;code&gt;void&lt;/code&gt; type in Java.</source>
          <target state="translated">단 하나의 값을 가진 유형 : &lt;code&gt;Unit&lt;/code&gt; 객체. 이 유형 은 Java 의 &lt;code&gt;void&lt;/code&gt; 유형에 해당합니다 .</target>
        </trans-unit>
        <trans-unit id="7008246671a61ed2da63a9b1d753eac75888ec6a" translate="yes" xml:space="preserve">
          <source>The types inside the angle brackets are called &lt;em&gt;generic type parameters&lt;/em&gt;, which we will cover later. In short, it's a useful technique to make a class that is tied to another class (such as a container class, which is tied to its element class) applicable to many different classes.</source>
          <target state="translated">꺾쇠 괄호 안의 &lt;em&gt;유형을 일반 유형 매개 변수&lt;/em&gt; 라고하며 , 나중에 다루겠습니다. 즉, 다른 클래스 (예 : 요소 클래스에 연결된 컨테이너 클래스)에 연결된 클래스를 여러 클래스에 적용 할 수있는 유용한 기술입니다.</target>
        </trans-unit>
        <trans-unit id="3b16b6543fccfa319ed1bb173131c9217c5b8ccc" translate="yes" xml:space="preserve">
          <source>The usage from C is straightforward and uncomplicated. We create a &lt;code&gt;main.c&lt;/code&gt; file with the following code:</source>
          <target state="translated">C의 사용법은 간단하고 복잡하지 않습니다. 다음 코드를 사용하여 &lt;code&gt;main.c&lt;/code&gt; 파일을 만듭니다 .</target>
        </trans-unit>
        <trans-unit id="eda63df3b0cc777042c5e16e6a7e9e820a7f02bd" translate="yes" xml:space="preserve">
          <source>The usage is pretty similar to all-open.</source>
          <target state="translated">사용법은 모두 열기와 매우 유사합니다.</target>
        </trans-unit>
        <trans-unit id="d4460c6a02beaa088565d93296bf84c132fa91dd" translate="yes" xml:space="preserve">
          <source>The usage is the same to all-open and no-arg, except the fact that sam-with-receiver does not have any built-in presets, and you need to specify your own list of special-treated annotations.</source>
          <target state="translated">sam-with-receiver에 내장 된 사전 설정이없고 고유 한 특수 처리 된 주석 목록을 지정해야한다는 점을 제외하면 사용법은 모두 열기 및 인수 없음과 동일합니다.</target>
        </trans-unit>
        <trans-unit id="79d6496f32a4f62877c61deb0bd17640fe23059a" translate="yes" xml:space="preserve">
          <source>The use cases of different functions overlap, so that you can choose the functions based on the specific conventions used in your project or team.</source>
          <target state="translated">서로 다른 기능의 사용 사례가 겹치므로 프로젝트 또는 팀에서 사용되는 특정 규칙에 따라 기능을 선택할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="882548c8ded53fae119e86e0601fc1f2361824a2" translate="yes" xml:space="preserve">
          <source>The use-site variance specified in the projection, or &lt;code&gt;null&lt;/code&gt; if this is a star projection.</source>
          <target state="translated">투영에 지정된 사용 사이트 차이 또는 별 투영 인 경우 &lt;code&gt;null&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="f6253f8d51fcab2be72d37974c28482731bda531" translate="yes" xml:space="preserve">
          <source>The value being held by this class.</source>
          <target state="translated">이 클래스가 보유하고있는 가치.</target>
        </trans-unit>
        <trans-unit id="3c6df952c69c83c655c026cd3cab96c052641127" translate="yes" xml:space="preserve">
          <source>The value must be positive and &lt;a href=&quot;../../kotlin/-int/-m-a-x_-v-a-l-u-e#kotlin.Int.Companion%24MAX_VALUE&quot;&gt;Int.MAX_VALUE&lt;/a&gt; is used to specify an unlimited depth.</source>
          <target state="translated">값은 양수 여야하며 &lt;a href=&quot;../../kotlin/-int/-m-a-x_-v-a-l-u-e#kotlin.Int.Companion%24MAX_VALUE&quot;&gt;Int.MAX_VALUE&lt;/a&gt; 를 사용하여 무제한 깊이를 지정합니다.</target>
        </trans-unit>
        <trans-unit id="239f4ace7ed276249b435b6f6174eb7de8fef7a5" translate="yes" xml:space="preserve">
          <source>The value of captured group.</source>
          <target state="translated">캡처 한 그룹의 가치.</target>
        </trans-unit>
        <trans-unit id="af704602dd7474776e5b688f4b067018b5e41c89" translate="yes" xml:space="preserve">
          <source>The value of this variable.</source>
          <target state="translated">이 변수의 값.</target>
        </trans-unit>
        <trans-unit id="3aabcc212c1608210121013dee11f396d22f4fca" translate="yes" xml:space="preserve">
          <source>The variable containing a &lt;a href=&quot;-c-opaque-pointer&quot;&gt;COpaquePointer&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;-c-opaque-pointer&quot;&gt;COpaquePointer를&lt;/a&gt; 포함하는 변수 입니다.</target>
        </trans-unit>
        <trans-unit id="e9b853cf2301d69ed0ca13dfc9180094e7f3e288" translate="yes" xml:space="preserve">
          <source>The version of the bytecode interface (naming conventions, signatures) of the class file annotated with this annotation.</source>
          <target state="translated">이 주석으로 주석이 달린 클래스 파일의 바이트 코드 인터페이스 버전 (이름 지정 규칙, 서명).</target>
        </trans-unit>
        <trans-unit id="1abfb175c8f11a4b2665f4fbd6b2ed384b7a75ef" translate="yes" xml:space="preserve">
          <source>The version of the metadata provided in the arguments of this annotation.</source>
          <target state="translated">이 주석의 인수에 제공된 메타 데이터의 버전입니다.</target>
        </trans-unit>
        <trans-unit id="b210bbe6f64c596cb275d652b699dc315a1fc8bc" translate="yes" xml:space="preserve">
          <source>The very first part contains the standard C/C++ header and footer:</source>
          <target state="translated">첫 번째 부분에는 표준 C / C ++ 헤더 및 바닥 글이 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="13204b21b51f8144497368ed89b8d47c465b75a3" translate="yes" xml:space="preserve">
          <source>The visibility level only affects the &lt;em&gt;lexical visibility&lt;/em&gt; of the &lt;em&gt;symbol&lt;/em&gt; - i.e., where the compiler allows you to type out the symbol. It does not affect where &lt;em&gt;instances&lt;/em&gt; are used: for example, a public top-level function may well return an instance of a private class, as long as the return type doesn't mention the private class name but is instead a public base class of the private class (possibly &lt;code&gt;Any&lt;/code&gt;) or a public interface that the private class implements. When you &lt;a href=&quot;inheritance#subclassing&quot;&gt;subclass&lt;/a&gt; a class, its private members are also inherited by the subclass, but are not directly accessible there - however, if you call an inherited public function that happens to access a private member, that's fine.</source>
          <target state="translated">가시성 수준 은 &lt;em&gt;기호&lt;/em&gt; 의 &lt;em&gt;어휘 적 가시성&lt;/em&gt; 에만 영향을 미칩니다. 즉, 컴파일러에서 기호를 입력 할 수 있습니다. &lt;em&gt;인스턴스&lt;/em&gt; 가 사용되는 위치에는 영향을 미치지 않습니다 . 예를 들어, 공개 최상위 함수는 반환 유형이 개인 클래스 이름을 언급하지 않고 대신에 공개 기본 클래스 인 경우 개인 클래스의 인스턴스를 반환 할 수 있습니다. 개인 클래스 (아마도 &lt;code&gt;Any&lt;/code&gt; ) 또는 개인 클래스가 구현하는 공용 인터페이스 &lt;a href=&quot;inheritance#subclassing&quot;&gt;클래스&lt;/a&gt; 를 서브 클래 싱 할 때 , 그 프라이빗 멤버도 서브 클래스에 의해 상속되지만 직접 액세스 할 수는 없습니다. 그러나 프라이빗 멤버에 접근하는 상속 된 퍼블릭 함수를 호출하면 좋습니다.&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="be08405fa49b795ce8dcbbade59f22553916f972" translate="yes" xml:space="preserve">
          <source>The way in which we'd use this from JavaScript would be to call &lt;code&gt;dataTable()&lt;/code&gt; on the corresponding &lt;code&gt;&amp;lt;table&amp;gt;&lt;/code&gt; element</source>
          <target state="translated">JavaScript에서 이것을 사용하는 방법 은 해당 &lt;code&gt;&amp;lt;table&amp;gt;&lt;/code&gt; 요소 에서 &lt;code&gt;dataTable()&lt;/code&gt; 을 호출 하는 것입니다</target>
        </trans-unit>
        <trans-unit id="df6c92cd4ac7021995eb7f605c7d7406310257be" translate="yes" xml:space="preserve">
          <source>The way to refer to the context object</source>
          <target state="translated">컨텍스트 객체를 참조하는 방법</target>
        </trans-unit>
        <trans-unit id="db21ceeaa7842bb619c97af30e1e09b94faa6e61" translate="yes" xml:space="preserve">
          <source>The web site has a bunch of &lt;a href=&quot;https://kotlinlang.org/community/&quot;&gt;online resources&lt;/a&gt;, including &lt;a href=&quot;https://kotlin.link&quot;&gt;Kotlin Digests&lt;/a&gt; by community members, a &lt;a href=&quot;http://www.kotlinweekly.net&quot;&gt;newsletter&lt;/a&gt;, a &lt;a href=&quot;https://talkingkotlin.com&quot;&gt;podcast&lt;/a&gt; and more.</source>
          <target state="translated">이 웹 사이트에는 커뮤니티 구성원의 &lt;a href=&quot;https://kotlin.link&quot;&gt;코 틀린 다이제스트&lt;/a&gt; , &lt;a href=&quot;http://www.kotlinweekly.net&quot;&gt;뉴스 레터&lt;/a&gt; , &lt;a href=&quot;https://talkingkotlin.com&quot;&gt;팟 캐스트&lt;/a&gt; 등을 포함한 다양한 &lt;a href=&quot;https://kotlinlang.org/community/&quot;&gt;온라인 리소스가&lt;/a&gt; 있습니다.</target>
        </trans-unit>
        <trans-unit id="ffaad4042bec05249e2007ea2e2a7c01e5b1b264" translate="yes" xml:space="preserve">
          <source>Then add the respective dependencies using the &lt;code&gt;kapt&lt;/code&gt; configuration in your &lt;code&gt;dependencies&lt;/code&gt; block:</source>
          <target state="translated">그런 다음 &lt;code&gt;dependencies&lt;/code&gt; 블록 에서 &lt;code&gt;kapt&lt;/code&gt; 구성을 사용하여 해당 종속성을 추가하십시오 .</target>
        </trans-unit>
        <trans-unit id="3d3dd4715a6e839facb3a4bc6c2872f8802ec4b8" translate="yes" xml:space="preserve">
          <source>Then follow the wizard steps. You'll have a &lt;code&gt;build.gradle&lt;/code&gt; file created with Kotlin configured according to &lt;a href=&quot;../../reference/using-gradle&quot;&gt;this document&lt;/a&gt;. Make sure it's configured for Kotlin 1.3 or higher.</source>
          <target state="translated">그런 다음 마법사 단계를 따르십시오. 당신은해야합니다 &lt;code&gt;build.gradle&lt;/code&gt; 의 코 틀린로 만든 파일에 따라 구성 &lt;a href=&quot;../../reference/using-gradle&quot;&gt;이 문서&lt;/a&gt; . Kotlin 1.3 이상으로 구성되어 있는지 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="9ed3e436c4ee364169e1bdacb724480b6ae120b2" translate="yes" xml:space="preserve">
          <source>Then follow the wizard steps. You'll have a &lt;code&gt;pom.xml&lt;/code&gt; file created with Kotlin configured according to &lt;a href=&quot;../../reference/using-maven&quot;&gt;this document&lt;/a&gt;. Make sure it's configured for Kotlin 1.3 or higher.</source>
          <target state="translated">그런 다음 마법사 단계를 따르십시오. 당신은해야합니다 &lt;code&gt;pom.xml&lt;/code&gt; 코 틀린로 만든 파일에 따라 구성 &lt;a href=&quot;../../reference/using-maven&quot;&gt;이 문서&lt;/a&gt; . Kotlin 1.3 이상으로 구성되어 있는지 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="10cfe3c1803900b3459055c1fdedb21ced35e4cd" translate="yes" xml:space="preserve">
          <source>Then run the &lt;code&gt;cinterop&lt;/code&gt; tool with something like this (note that for host libraries that are not included in the sysroot search paths, headers may be needed):</source>
          <target state="translated">그런 다음 다음 과 같이 &lt;code&gt;cinterop&lt;/code&gt; 도구를 실행하십시오 (sysroot 검색 경로에 포함되지 않은 호스트 라이브러리의 경우 헤더가 필요할 수 있음).</target>
        </trans-unit>
        <trans-unit id="5581239ffa3d854f1837127435e240d49f122ba5" translate="yes" xml:space="preserve">
          <source>Then specify the list of SAM-with-receiver annotations:</source>
          <target state="translated">그런 다음 수신자가있는 SAM 주석 목록을 지정하십시오.</target>
        </trans-unit>
        <trans-unit id="9b78fa9ef8a36ffde61cb8bc4f298109afadcbee" translate="yes" xml:space="preserve">
          <source>Then specify the list of annotations that will make classes open:</source>
          <target state="translated">그런 다음 클래스를 여는 주석 목록을 지정하십시오.</target>
        </trans-unit>
        <trans-unit id="fd73374c27e0a874f2f41c35f033bfc599a82d6b" translate="yes" xml:space="preserve">
          <source>Then specify the list of no-arg annotations:</source>
          <target state="translated">그런 다음 인수없는 주석 목록을 지정하십시오.</target>
        </trans-unit>
        <trans-unit id="0ef92249fe5f505a551a8b463644321da779af43" translate="yes" xml:space="preserve">
          <source>Then we can have several processor coroutines. In this example, they just print their id and received number:</source>
          <target state="translated">그런 다음 여러 프로세서 코 루틴을 가질 수 있습니다. 이 예에서는 ID와 수신 번호 만 인쇄합니다.</target>
        </trans-unit>
        <trans-unit id="490b87ea6044ef60c21b2e7783571a7d77df8b12" translate="yes" xml:space="preserve">
          <source>Then we define a function that launches an actor using an &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.channels/actor.html&quot;&gt;actor&lt;/a&gt; coroutine builder:</source>
          <target state="translated">그런 다음 &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.channels/actor.html&quot;&gt;액터&lt;/a&gt; 코 루틴 빌더를 사용하여 액터 를 시작하는 함수를 정의합니다 .</target>
        </trans-unit>
        <trans-unit id="843feae1b1434f20428d159db5d3289af1525e9c" translate="yes" xml:space="preserve">
          <source>Then, for each &lt;a href=&quot;https://developer.android.com/studio/build/build-variants#sourcesets&quot;&gt;Android source set&lt;/a&gt; compiled by the variants, a Kotlin source set is created under that source set name prepended by the target name, like Kotlin source set &lt;code&gt;androidDebug&lt;/code&gt; for an Android source set &lt;code&gt;debug&lt;/code&gt; and the Kotlin target named &lt;code&gt;android&lt;/code&gt;. These Kotlin source sets are added to the variants compilations accordingly.</source>
          <target state="translated">그런 다음 변형에 의해 컴파일 된 각 &lt;a href=&quot;https://developer.android.com/studio/build/build-variants#sourcesets&quot;&gt;Android 소스 세트&lt;/a&gt; 에 대해 Kotlin 소스 세트는 Android 소스 세트 &lt;code&gt;debug&lt;/code&gt; Kotlin 소스 세트 &lt;code&gt;androidDebug&lt;/code&gt; 및 &lt;code&gt;android&lt;/code&gt; 라는 Kotlin 타겟과 같이 대상 이름이 앞에 붙은 해당 소스 세트 이름 아래에 작성됩니다 . 이러한 Kotlin 소스 세트는 그에 따라 변형 컴파일에 추가됩니다.</target>
        </trans-unit>
        <trans-unit id="68562aa9b0f180cb0bf47fd690042cd2286c6294" translate="yes" xml:space="preserve">
          <source>Then, it would be perfectly safe to store a reference to an instance of &lt;code&gt;Source&amp;lt;String&amp;gt;&lt;/code&gt; in a variable of type &lt;code&gt;Source&amp;lt;Object&amp;gt;&lt;/code&gt; &amp;ndash; there are no consumer-methods to call. But Java does not know this, and still prohibits it:</source>
          <target state="translated">그런 다음 &lt;code&gt;Source&amp;lt;Object&amp;gt;&lt;/code&gt; 유형의 변수에 &lt;code&gt;Source&amp;lt;String&amp;gt;&lt;/code&gt; 인스턴스에 대한 참조를 저장하는 것이 안전합니다 . 호출 할 소비자 메소드는 없습니다. 그러나 Java는 이것을 알지 못하고 여전히 금지합니다.</target>
        </trans-unit>
        <trans-unit id="d673d7a939528ccf7977db751d0c7bd0f923bb89" translate="yes" xml:space="preserve">
          <source>Then, once a target is added, default compilations are created for it:</source>
          <target state="translated">그런 다음 대상이 추가되면 기본 컴파일이 작성됩니다.</target>
        </trans-unit>
        <trans-unit id="a7b51b664e8983298e6dc346e7c7dc0b18863813" translate="yes" xml:space="preserve">
          <source>Then, some time later the deprecation level is raised to &lt;a href=&quot;../-deprecation-level/-e-r-r-o-r#kotlin.DeprecationLevel.ERROR&quot;&gt;DeprecationLevel.ERROR&lt;/a&gt;, so that no new Kotlin code can be compiled using the deprecated API.</source>
          <target state="translated">그런 다음 얼마 후 사용 중단 레벨이 &lt;a href=&quot;../-deprecation-level/-e-r-r-o-r#kotlin.DeprecationLevel.ERROR&quot;&gt;DeprecationLevel.ERROR&lt;/a&gt; 로 높아져 사용 중단 된 API를 사용하여 새로운 Kotlin 코드를 컴파일 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="b6377e7d0f06e408f80f03d549dd08ce8d9b969c" translate="yes" xml:space="preserve">
          <source>Then, the only thing we want to ensure is that &lt;code&gt;copy()&lt;/code&gt; does not do any bad things. We want to prohibit it from &lt;strong&gt;writing&lt;/strong&gt; to &lt;code&gt;from&lt;/code&gt;, and we can:</source>
          <target state="translated">그렇다면 우리가 원하는 유일한 것은 &lt;code&gt;copy()&lt;/code&gt; 가 나쁜 일을하지 않는다는 것입니다. 우리는에서 그것을 금지 할 &lt;strong&gt;쓰기&lt;/strong&gt; 로 &lt;code&gt;from&lt;/code&gt; , 우리는 할 수 있습니다</target>
        </trans-unit>
        <trans-unit id="2e04f4cdf39ff6bfe2fd15e1cdcb551eff15e642" translate="yes" xml:space="preserve">
          <source>There are a few courses available for Kotlin, including a &lt;a href=&quot;https://www.pluralsight.com/courses/kotlin-getting-started&quot;&gt;Pluralsight Kotlin Course&lt;/a&gt; by Kevin Jones, an &lt;a href=&quot;http://shop.oreilly.com/product/0636920052982.do&quot;&gt;O&amp;rsquo;Reilly Course&lt;/a&gt; by Hadi Hariri and an &lt;a href=&quot;http://petersommerhoff.com/dev/kotlin/kotlin-beginner-tutorial/&quot;&gt;Udemy Kotlin Course&lt;/a&gt; by Peter Sommerhoff.</source>
          <target state="translated">Kevin Jones 의 &lt;a href=&quot;https://www.pluralsight.com/courses/kotlin-getting-started&quot;&gt;복수형 Kotlin 코스&lt;/a&gt; , Hadi Hariri 의 &lt;a href=&quot;http://shop.oreilly.com/product/0636920052982.do&quot;&gt;O'Reilly 코스&lt;/a&gt; 및 Peter Sommerhoff 의 &lt;a href=&quot;http://petersommerhoff.com/dev/kotlin/kotlin-beginner-tutorial/&quot;&gt;Udemy Kotlin 코스&lt;/a&gt; 를 포함하여 Kotlin에 사용할 수있는 몇 가지 코스가 있습니다 .</target>
        </trans-unit>
        <trans-unit id="7aeb1151dcad680105c7a075482911c8fc7a00f6" translate="yes" xml:space="preserve">
          <source>There are a lot of built-in extension functions/properties in Kotlin - for example, &lt;code&gt;map()&lt;/code&gt;, &lt;code&gt;filter()&lt;/code&gt;, and the rest of the framework for processing collections in a functional manner is built using extension functions.</source>
          <target state="translated">Kotlin에는 내장 확장 기능 / 속성이 많이 &lt;code&gt;map()&lt;/code&gt; 예 : map () , &lt;code&gt;filter()&lt;/code&gt; . 기능 방식으로 컬렉션을 처리하기위한 나머지 프레임 워크는 확장 기능을 사용하여 작성됩니다.</target>
        </trans-unit>
        <trans-unit id="24f819fcebc7b01f0f49b06a15eca941aac602cd" translate="yes" xml:space="preserve">
          <source>There are already &lt;a href=&quot;https://kotlinlang.org/docs/books.html&quot;&gt;a number of books&lt;/a&gt; available for Kotlin, including &lt;a href=&quot;https://www.manning.com/books/kotlin-in-action&quot;&gt;Kotlin in Action&lt;/a&gt; which is by Kotlin team members Dmitry Jemerov and Svetlana Isakova, &lt;a href=&quot;https://leanpub.com/kotlin-for-android-developers&quot;&gt;Kotlin for Android Developers&lt;/a&gt; targeted at Android developers.</source>
          <target state="translated">Kotlin 팀원 인 Dmitry Jemerov와 &lt;a href=&quot;https://leanpub.com/kotlin-for-android-developers&quot;&gt;Android 개발자를&lt;/a&gt; 대상으로 하는 Android 개발자를위한 Kotlin Svetlana Isakova가 제공하는 Kotlin &lt;a href=&quot;https://www.manning.com/books/kotlin-in-action&quot;&gt;in Action&lt;/a&gt; 을 포함하여 Kotlin에 사용할 수 &lt;a href=&quot;https://kotlinlang.org/docs/books.html&quot;&gt;있는 많은 책&lt;/a&gt; 이 이미 있습니다 .</target>
        </trans-unit>
        <trans-unit id="cafdda410a7a8fb3e86649e5eeda1f41cb52882f" translate="yes" xml:space="preserve">
          <source>There are also functions for creating collections without any elements: &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/empty-list&quot;&gt;&lt;code&gt;emptyList()&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/empty-set&quot;&gt;&lt;code&gt;emptySet()&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/empty-map&quot;&gt;&lt;code&gt;emptyMap()&lt;/code&gt;&lt;/a&gt;. When creating empty collections, you should specify the type of elements that the collection will hold.</source>
          <target state="translated">&lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/empty-list&quot;&gt; &lt;code&gt;emptyList()&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/empty-set&quot;&gt; &lt;code&gt;emptySet()&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/empty-map&quot;&gt; &lt;code&gt;emptyMap()&lt;/code&gt; &lt;/a&gt; 요소없이 컬렉션을 생성하는 함수도 있습니다 . 빈 모음을 만들 때는 모음에 보유 할 요소 유형을 지정해야합니다.</target>
        </trans-unit>
        <trans-unit id="843241bb0f5eb80f440f0b1b3622ce9c95598c3b" translate="yes" xml:space="preserve">
          <source>There are also functions for retrieving the smallest and the largest elements by certain selector function or custom &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin/-comparator/index&quot;&gt;&lt;code&gt;Comparator&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">특정 선택기 기능 또는 사용자 지정 &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin/-comparator/index&quot;&gt; &lt;code&gt;Comparator&lt;/code&gt; &lt;/a&gt; 가장 작은 요소와 가장 큰 요소를 검색하는 기능도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="4888d99de496e5f2812e2d42599de7f621ae0a73" translate="yes" xml:space="preserve">
          <source>There are also functions that narrow the element type by filtering elements of a given type:</source>
          <target state="translated">주어진 유형의 요소를 필터링하여 요소 유형을 좁히는 함수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="22fc645d90366ef3cbd36340e10852155ba93121" translate="yes" xml:space="preserve">
          <source>There are also many recordings of &lt;a href=&quot;http://kotlinlang.org/community/talks.html&quot;&gt;Kotlin talks&lt;/a&gt; available on YouTube and Vimeo.</source>
          <target state="translated">YouTube와 Vimeo에서 사용 가능한 &lt;a href=&quot;http://kotlinlang.org/community/talks.html&quot;&gt;Kotlin 대화&lt;/a&gt; 에 대한 많은 녹음 자료도 있습니다.</target>
        </trans-unit>
        <trans-unit id="e4606566df8d7d15d5ed6bd46e8178f7ee899fb7" translate="yes" xml:space="preserve">
          <source>There are also more specific types:</source>
          <target state="translated">더 구체적인 유형도 있습니다.</target>
        </trans-unit>
        <trans-unit id="06489c1e98a1df08c22af1c2c8a1f880cc0522a9" translate="yes" xml:space="preserve">
          <source>There are also some tools available to convert between Kotlin and C strings manually:</source>
          <target state="translated">Kotlin과 C 문자열을 수동으로 변환하는 데 사용할 수있는 몇 가지 도구가 있습니다.</target>
        </trans-unit>
        <trans-unit id="5da1b83a877bec99a63204ac23c3a863bcc7d2fe" translate="yes" xml:space="preserve">
          <source>There are also the following type qualifiers in the C language: &lt;code&gt;const&lt;/code&gt;, &lt;code&gt;volatile&lt;/code&gt;, &lt;code&gt;restruct&lt;/code&gt;, &lt;code&gt;atomic&lt;/code&gt;.</source>
          <target state="translated">C 언어에는 &lt;code&gt;const&lt;/code&gt; , &lt;code&gt;volatile&lt;/code&gt; , &lt;code&gt;restruct&lt;/code&gt; , &lt;code&gt;atomic&lt;/code&gt; 유형 한정자가 있습니다 .</target>
        </trans-unit>
        <trans-unit id="d1856539b37f6f362e28eec082e8282bf62fdd7b" translate="yes" xml:space="preserve">
          <source>There are also two specific ways for filtering maps: by keys and by values. For each way, there is a function: &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/filter-keys&quot;&gt;&lt;code&gt;filterKeys()&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/filter-values&quot;&gt;&lt;code&gt;filterValues()&lt;/code&gt;&lt;/a&gt;. Both return a new map of entries which match the given predicate. The predicate for &lt;code&gt;filterKeys()&lt;/code&gt; checks only the element keys, the one for &lt;code&gt;filterValues()&lt;/code&gt; checks only values.</source>
          <target state="translated">키를 필터링하고 값을 기준으로 맵을 필터링하는 두 가지 방법이 있습니다. 각 방법에는 &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/filter-keys&quot;&gt; &lt;code&gt;filterKeys()&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/filter-values&quot;&gt; &lt;code&gt;filterValues()&lt;/code&gt; &lt;/a&gt; 함수가 있습니다. 둘 다 주어진 술어와 일치하는 새로운 항목 맵을 리턴합니다. 의 술어 &lt;code&gt;filterKeys()&lt;/code&gt; 검사 만 요소 키에 대한 하나 &lt;code&gt;filterValues()&lt;/code&gt; 를 체크 값만.</target>
        </trans-unit>
        <trans-unit id="250044abbac1d0cc39bffb2b00e37419c1aa5fa8" translate="yes" xml:space="preserve">
          <source>There are also useful aliases for retrieving the first and the last element of the collection: &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/first&quot;&gt;&lt;code&gt;first()&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/last&quot;&gt;&lt;code&gt;last()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">컬렉션의 &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/first&quot;&gt; &lt;code&gt;first()&lt;/code&gt; &lt;/a&gt; 요소와 마지막 요소 인 first () 및 &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/last&quot;&gt; &lt;code&gt;last()&lt;/code&gt; &lt;/a&gt; 를 검색하는 데 유용한 별칭도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="f989069ff2a0fc8bbd7269050d48a2e9c89946af" translate="yes" xml:space="preserve">
          <source>There are certain common kinds of properties, that, though we can implement them manually every time we need them, would be very nice to implement once and for all, and put into a library. Examples include:</source>
          <target state="translated">일반적인 종류의 속성이 있지만 필요할 때마다 수동으로 구현할 수 있지만 한 번에 구현하고 라이브러리에 넣는 것이 매우 좋습니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="e9d07a2b7a0e6a37bb57f8fc3823505798a41626" translate="yes" xml:space="preserve">
          <source>There are certain rules that define write operations on maps:</source>
          <target state="translated">맵에서 쓰기 조작을 정의하는 특정 규칙이 있습니다.</target>
        </trans-unit>
        <trans-unit id="2a3a36051a175f99aacc43b0a72a065674774e2a" translate="yes" xml:space="preserve">
          <source>There are couple of observations to make out of it.</source>
          <target state="translated">그것을 확인하기 위해 몇 가지 관찰이 있습니다.</target>
        </trans-unit>
        <trans-unit id="fd050ce9dc8260feb80b7e8ad7e70f3ec42e69f1" translate="yes" xml:space="preserve">
          <source>There are exactly four instances of this class, named &lt;code&gt;ContentKind.TOPIC&lt;/code&gt;, and so on. Instances of this class can be compared to each other with &lt;code&gt;==&lt;/code&gt; and &lt;code&gt;!=&lt;/code&gt;, and you can get all the allowable values with &lt;code&gt;ContentKind.values()&lt;/code&gt;. You can also tack on more information to each instance if you need:</source>
          <target state="translated">이 클래스에는 정확히 &lt;code&gt;ContentKind.TOPIC&lt;/code&gt; 등 네 개의 인스턴스가 있습니다. 이 클래스의 인스턴스는 &lt;code&gt;==&lt;/code&gt; 및 &lt;code&gt;!=&lt;/code&gt; 로 서로 비교할 수 있으며 &lt;code&gt;ContentKind.values()&lt;/code&gt; 사용하여 허용 가능한 모든 값을 얻을 수 있습니다 . 필요한 경우 각 인스턴스에 대한 자세한 정보를 확인할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="f927ac2e11471dbf3b5e6b2ee718ccfcd881bb02" translate="yes" xml:space="preserve">
          <source>There are many approaches to this problem, and in Kotlin we take a very flexible one by providing &lt;a href=&quot;https://en.wikipedia.org/wiki/Coroutine&quot;&gt;Coroutine&lt;/a&gt; support at the language level and delegating most of the functionality to libraries, much in line with Kotlin's philosophy.</source>
          <target state="translated">이 문제에 대한 많은 접근 방식이 있으며 Kotlin 에서는 언어 수준에서 &lt;a href=&quot;https://en.wikipedia.org/wiki/Coroutine&quot;&gt;Coroutine&lt;/a&gt; 지원을 제공 하고 대부분의 기능을 Kotlin의 철학에 따라 라이브러리에 위임 함으로써 매우 유연한 방법 을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="a0366ee935c5394b522c3fe877f29b4f014a964b" translate="yes" xml:space="preserve">
          <source>There are many more platform libraries available for host and cross-compilation targets. &lt;code&gt;Kotlin/Native&lt;/code&gt; distribution provides access to &lt;code&gt;OpenGL&lt;/code&gt;, &lt;code&gt;zlib&lt;/code&gt; and other popular native libraries on applicable platforms.</source>
          <target state="translated">호스트 및 크로스 컴파일 대상에 사용할 수있는 더 많은 플랫폼 라이브러리가 있습니다. &lt;code&gt;Kotlin/Native&lt;/code&gt; 배포는 해당 플랫폼 에서 &lt;code&gt;OpenGL&lt;/code&gt; , &lt;code&gt;zlib&lt;/code&gt; 및 기타 인기있는 기본 라이브러리에 대한 액세스를 제공 합니다.</target>
        </trans-unit>
        <trans-unit id="ef27dee02c48c1f5d014bbb6297ef36468bd6491" translate="yes" xml:space="preserve">
          <source>There are multiple ways to compile Kotlin to JavaScript. The recommended approach is to use Gradle; if desired, you can also build JavaScript projects directly from IntelliJ IDEA, use Maven, or compile the code manually from the command line. To learn more about how to compile to JavaScript please see the corresponding tutorials:</source>
          <target state="translated">Kotlin을 JavaScript로 컴파일하는 방법에는 여러 가지가 있습니다. 권장되는 접근 방식은 Gradle을 사용하는 것입니다. 원하는 경우 IntelliJ IDEA에서 직접 JavaScript 프로젝트를 빌드하거나 Maven을 사용하거나 명령 줄에서 코드를 수동으로 컴파일 할 수도 있습니다. JavaScript로 컴파일하는 방법에 대한 자세한 내용은 해당 자습서를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="655afcf98b929642faf68faf52cca26e671f04f6" translate="yes" xml:space="preserve">
          <source>There are no &lt;code&gt;**kwargs&lt;/code&gt; in Kotlin, but you can define optional parameters with default values, and you may choose to name some or all of the parameters when you call the function (whether they've got default values or not). A parameter with a default value must still specify its type explicitly. Like in Python, the named arguments can be reordered at will at the call site:</source>
          <target state="translated">Kotlin 에는 &lt;code&gt;**kwargs&lt;/code&gt; 가 없지만 기본값을 사용하여 선택적 매개 변수를 정의 할 수 있으며 함수를 호출 할 때 매개 변수의 일부 또는 전체 이름을 지정할 수 있습니다 (기본값이 있는지 여부). 기본값을 가진 매개 변수는 여전히 유형을 명시 적으로 지정해야합니다. 파이썬에서와 같이 명명 된 인수는 호출 사이트에서 마음대로 재정렬 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="577ed2c21e3c8a21c4f57421503fea8126403589" translate="yes" xml:space="preserve">
          <source>There are no automatic conversions to boolean and thus no concept of truthy and falsy: checks for zero, empty, or null must be done explicitly with &lt;code&gt;==&lt;/code&gt; or &lt;code&gt;!=&lt;/code&gt;. Most collection types have an &lt;code&gt;isEmpty()&lt;/code&gt; and an &lt;code&gt;isNotEmpty()&lt;/code&gt; function.</source>
          <target state="translated">부울로 자동 변환되지 않으므로 진리와 거짓 개념이 없습니다. 0, 비어 있거나 널에 대한 검사는 &lt;code&gt;==&lt;/code&gt; 또는 &lt;code&gt;!=&lt;/code&gt; 명시 적으로 수행해야합니다 . 대부분의 컬렉션 유형에는 &lt;code&gt;isEmpty()&lt;/code&gt; 및 &lt;code&gt;isNotEmpty()&lt;/code&gt; 함수가 있습니다.</target>
        </trans-unit>
        <trans-unit id="0173c0164165dfc2326b31145c73366a6b9e4caf" translate="yes" xml:space="preserve">
          <source>There are now separate versions of the standard library supporting the new JDK APIs added in Java 7 and 8. If you need access to the new APIs, use &lt;code&gt;kotlin-stdlib-jre7&lt;/code&gt; and &lt;code&gt;kotlin-stdlib-jre8&lt;/code&gt; maven artifacts instead of the standard &lt;code&gt;kotlin-stdlib&lt;/code&gt;. These artifacts are tiny extensions on top of &lt;code&gt;kotlin-stdlib&lt;/code&gt; and they bring it to your project as a transitive dependency.</source>
          <target state="translated">이제 Java 7 및 8에 추가 된 새로운 JDK API를 지원하는 별도의 표준 라이브러리 버전이 있습니다. 새 API에 액세스해야하는 경우 표준 &lt;code&gt;kotlin-stdlib&lt;/code&gt; 대신 &lt;code&gt;kotlin-stdlib-jre7&lt;/code&gt; 및 &lt;code&gt;kotlin-stdlib-jre8&lt;/code&gt; maven 아티팩트를 사용하십시오. stdlib . 이 아티팩트는 &lt;code&gt;kotlin-stdlib&lt;/code&gt; 의 작은 확장 이며 프로젝트에 전 이적 종속성으로 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="4f69b73bfcd710307d7869f79c049d0bc960833d" translate="yes" xml:space="preserve">
          <source>There are several ways to obtain an instance of a function type:</source>
          <target state="translated">함수 유형의 인스턴스를 얻는 방법에는 여러 가지가 있습니다.</target>
        </trans-unit>
        <trans-unit id="bfb4470f4c8ab69e441c59ca19feae2c36a172f6" translate="yes" xml:space="preserve">
          <source>There are several ways to override the default setting:</source>
          <target state="translated">기본 설정을 재정의하는 몇 가지 방법이 있습니다.</target>
        </trans-unit>
        <trans-unit id="3ea08a710ccd5abee84ca77d28377d406d442756" translate="yes" xml:space="preserve">
          <source>There are some limitations:</source>
          <target state="translated">몇 가지 제한 사항이 있습니다.</target>
        </trans-unit>
        <trans-unit id="060bb5e1464bf104cc44e53612c8d8eb0e6d472c" translate="yes" xml:space="preserve">
          <source>There are target presets that one can apply using the preset functions, as shown above, for the following target platforms:</source>
          <target state="translated">다음과 같은 대상 플랫폼에 대해 사전 설정 기능을 사용하여 적용 할 수있는 대상 사전 설정이 있습니다.</target>
        </trans-unit>
        <trans-unit id="7df642de78432a3520c5b5afd68e2c605c1c315a" translate="yes" xml:space="preserve">
          <source>There are the following kinds of literal constants for integral values:</source>
          <target state="translated">정수 값에는 다음과 같은 종류의 리터럴 상수가 있습니다.</target>
        </trans-unit>
        <trans-unit id="f4373b7b309c5120a0c7bdb4b6efb5a4594f35b5" translate="yes" xml:space="preserve">
          <source>There are three coroutines. The main coroutine (#1) &amp;ndash; &lt;code&gt;runBlocking&lt;/code&gt; one, and two coroutines computing deferred values &lt;code&gt;a&lt;/code&gt; (#2) and &lt;code&gt;b&lt;/code&gt; (#3). They are all executing in the context of &lt;code&gt;runBlocking&lt;/code&gt; and are confined to the main thread. The output of this code is:</source>
          <target state="translated">코 루틴은 세 가지가 있습니다. 주 코 루틴 (# 1) &amp;ndash; &lt;code&gt;runBlocking&lt;/code&gt; 1 및 두 코 루틴 계산 지연 값 &lt;code&gt;a&lt;/code&gt; (# 2) 및 &lt;code&gt;b&lt;/code&gt; (# 3). 이들은 모두 &lt;code&gt;runBlocking&lt;/code&gt; 컨텍스트에서 실행되며 기본 스레드로 제한됩니다. 이 코드의 출력은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="f684c90b5c1cc2b45ec708952abe326e96395793" translate="yes" xml:space="preserve">
          <source>There are too many companies using Kotlin to list, but some more visible companies that have publicly declared usage of Kotlin, be this via blog posts, GitHub repositories or talks include &lt;a href=&quot;https://medium.com/square-corner-blog/square-open-source-loves-kotlin-c57c21710a17&quot;&gt;Square&lt;/a&gt;, &lt;a href=&quot;https://www.youtube.com/watch?v=mDpnc45WwlI&quot;&gt;Pinterest&lt;/a&gt;, &lt;a href=&quot;https://m.signalvnoise.com/how-we-made-basecamp-3s-android-app-100-kotlin-35e4e1c0ef12&quot;&gt;Basecamp&lt;/a&gt; or &lt;a href=&quot;https://docs.corda.net/releases/release-M9.2/further-notes-on-kotlin.html&quot;&gt;Corda&lt;/a&gt;.</source>
          <target state="translated">Kotlin을 사용하여 상장하기에는 너무 많은 회사가 있지만 공개적으로 Kotlin의 사용을 선언 한 더 눈에 띄는 회사는 블로그 게시물, GitHub 리포지토리 또는 대화를 통해 &lt;a href=&quot;https://medium.com/square-corner-blog/square-open-source-loves-kotlin-c57c21710a17&quot;&gt;Square&lt;/a&gt; , &lt;a href=&quot;https://www.youtube.com/watch?v=mDpnc45WwlI&quot;&gt;Pinterest&lt;/a&gt; , &lt;a href=&quot;https://m.signalvnoise.com/how-we-made-basecamp-3s-android-app-100-kotlin-35e4e1c0ef12&quot;&gt;Basecamp&lt;/a&gt; 또는 &lt;a href=&quot;https://docs.corda.net/releases/release-M9.2/further-notes-on-kotlin.html&quot;&gt;Corda를 포함&lt;/a&gt; 합니다.</target>
        </trans-unit>
        <trans-unit id="26ea8b64f47f54b93f794f79bdbd7ea265251dad" translate="yes" xml:space="preserve">
          <source>There are two approaches to making computation code cancellable. The first one is to periodically invoke a suspending function that checks for cancellation. There is a &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/yield.html&quot;&gt;yield&lt;/a&gt; function that is a good choice for that purpose. The other one is to explicitly check the cancellation status. Let us try the latter approach.</source>
          <target state="translated">계산 코드를 취소 할 수있는 방법에는 두 가지가 있습니다. 첫 번째는 취소를 확인하는 일시 중단 기능을 주기적으로 호출하는 것입니다. 이 &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/yield.html&quot;&gt;항복&lt;/a&gt; 목적을위한 좋은 선택이다 기능. 다른 하나는 취소 상태를 명시 적으로 확인하는 것입니다. 후자의 접근법을 시도해 봅시다.</target>
        </trans-unit>
        <trans-unit id="cdb0e62ebdac6496d2a6cecaea4c9ddd6a113e2b" translate="yes" xml:space="preserve">
          <source>There are two functions for which the compiler gives same name in JavaScript, you can mark one with &lt;code&gt;@JsName(...)&lt;/code&gt; to prevent the compiler from reporting error.</source>
          <target state="translated">컴파일러에서 JavaScript로 동일한 이름을 제공하는 두 가지 함수 가 있습니다. 컴파일러에서 오류를보고하지 않도록 &lt;code&gt;@JsName(...)&lt;/code&gt; 으로 표시 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="538a207adbe54f7fe71914302d366f642c584d32" translate="yes" xml:space="preserve">
          <source>There are two possible ways to opt-in for unsigned types: with marking your API as experimental too, or without doing that.</source>
          <target state="translated">서명되지 않은 유형을 선택하는 두 가지 방법이 있습니다. API를 실험용으로 표시하거나 수행하지 않는 것입니다.</target>
        </trans-unit>
        <trans-unit id="86b3923915c4ddd4dd399b02f1d436b8dc853f8d" translate="yes" xml:space="preserve">
          <source>There can be different modes of stability depending of how quickly a component is evolving:</source>
          <target state="translated">구성 요소가 얼마나 빠르게 발전하고 있는지에 따라 다양한 안정성 모드가있을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0b3f1a4d9ad65e8f5f359abf2fed82920c3beef2" translate="yes" xml:space="preserve">
          <source>There have been many approaches to solving this problem, including:</source>
          <target state="translated">이 문제를 해결하기위한 많은 방법이 있습니다.</target>
        </trans-unit>
        <trans-unit id="c4dc29b34f77a8368125ef8d384ca8b6bfbe8472" translate="yes" xml:space="preserve">
          <source>There is a &lt;code&gt;kotlin.root.example.Clazz&lt;/code&gt; field that represents the &lt;code&gt;Clazz&lt;/code&gt; from Kotlin. The &lt;code&gt;Clazz#memberFunction&lt;/code&gt; is accessible with the &lt;code&gt;memberFunction&lt;/code&gt; field. The only difference is that the &lt;code&gt;memberFunction&lt;/code&gt; accepts a &lt;code&gt;this&lt;/code&gt; reference as the first parameter. The C language does not support objects, and this is the reason to pass a &lt;code&gt;this&lt;/code&gt; pointer explicitly.</source>
          <target state="translated">있다 &lt;code&gt;kotlin.root.example.Clazz&lt;/code&gt; 의 나타내는 필드 &lt;code&gt;Clazz&lt;/code&gt; 코 틀린에서가. &lt;code&gt;Clazz#memberFunction&lt;/code&gt; 에 액세스 할 수 &lt;code&gt;memberFunction&lt;/code&gt; 의 필드. 유일한 차이점은 &lt;code&gt;memberFunction&lt;/code&gt; &lt;code&gt;this&lt;/code&gt; 참조를 첫 번째 매개 변수로 승인 한다는 것 입니다. C 언어는 개체를 지원하지 않으며, 이것은 전달하는 이유는 &lt;code&gt;this&lt;/code&gt; 명시 적으로 포인터를.</target>
        </trans-unit>
        <trans-unit id="725365acc046d2774e785fd58198ecf73c6aec56" translate="yes" xml:space="preserve">
          <source>There is a better solution. We can use structured concurrency in our code. Instead of launching coroutines in the &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-global-scope/index.html&quot;&gt;GlobalScope&lt;/a&gt;, just like we usually do with threads (threads are always global), we can launch coroutines in the specific scope of the operation we are performing.</source>
          <target state="translated">더 나은 해결책이 있습니다. 코드에서 구조적 동시성을 사용할 수 있습니다. &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-global-scope/index.html&quot;&gt;GlobalScope&lt;/a&gt; 에서 코 루틴을 시작하는 대신 , 일반적으로 스레드를 사용하는 것처럼 (스레드는 항상 글로벌 임) 수행중인 특정 작업 범위에서 코 루틴을 시작할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f4b1300b6ec8e15e33a7b0dfe89c4e2e11e628f0" translate="yes" xml:space="preserve">
          <source>There is a bunch of new extensions on the String class to convert it to a number without throwing an exception on invalid number: &lt;code&gt;String.toIntOrNull(): Int?&lt;/code&gt;, &lt;code&gt;String.toDoubleOrNull(): Double?&lt;/code&gt; etc.</source>
          <target state="translated">String 클래스에는 유효하지 않은 숫자에 대한 예외를 발생시키지 않고 숫자로 변환하는 새로운 확장 기능이 많이 있습니다. &lt;code&gt;String.toIntOrNull(): Int?&lt;/code&gt; , &lt;code&gt;String.toDoubleOrNull(): Double?&lt;/code&gt; 기타</target>
        </trans-unit>
        <trans-unit id="7e33e2bb2c0c45c94e894d38130281f13150c4a3" translate="yes" xml:space="preserve">
          <source>There is a constructor in the &lt;code&gt;Clazz&lt;/code&gt; field (aka &lt;code&gt;kotlin.root.example.Clazz.Clazz&lt;/code&gt;), which is the constructor function to create an instance of the &lt;code&gt;Clazz&lt;/code&gt;.</source>
          <target state="translated">에서 생성자가 &lt;code&gt;Clazz&lt;/code&gt; 필드 (일명 &lt;code&gt;kotlin.root.example.Clazz.Clazz&lt;/code&gt; 의 인스턴스를 생성하는 생성자 함수이다) &lt;code&gt;Clazz&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b8e6c9d338e18c01513c4cf42dbec9a1ab61f7aa" translate="yes" xml:space="preserve">
          <source>There is a convenient coroutine builder named &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.channels/produce.html&quot;&gt;produce&lt;/a&gt; that makes it easy to do it right on producer side, and an extension function &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.channels/consume-each.html&quot;&gt;consumeEach&lt;/a&gt;, that replaces a &lt;code&gt;for&lt;/code&gt; loop on the consumer side:</source>
          <target state="translated">편리한 코 루틴 빌더의 이름이 &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.channels/produce.html&quot;&gt;생산&lt;/a&gt; 쉽게 바로 생산자 측에서 그것을 할 수 있습니다, 그리고 확장 기능 &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.channels/consume-each.html&quot;&gt;consumeEach&lt;/a&gt; A와 교체, &lt;code&gt;for&lt;/code&gt; 소비자 측 루프 :</target>
        </trans-unit>
        <trans-unit id="2dc05473a597a891dd992cdcf3cb31ec48971266" translate="yes" xml:space="preserve">
          <source>There is a laziness option to &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/async.html&quot;&gt;async&lt;/a&gt; using an optional &lt;code&gt;start&lt;/code&gt; parameter with a value of &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-coroutine-start/-l-a-z-y.html&quot;&gt;CoroutineStart.LAZY&lt;/a&gt;. It starts coroutine only when its result is needed by some &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-deferred/await.html&quot;&gt;await&lt;/a&gt; or if a &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-job/start.html&quot;&gt;start&lt;/a&gt; function is invoked. Run the following example:</source>
          <target state="translated">&lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-coroutine-start/-l-a-z-y.html&quot;&gt;CoroutineStart.LAZY&lt;/a&gt; 값을 갖는 선택적 &lt;code&gt;start&lt;/code&gt; 매개 변수를 사용하여 &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/async.html&quot;&gt;비동기&lt;/a&gt; 하는 게으름 옵션이 있습니다 . 일부 &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-deferred/await.html&quot;&gt;대기자&lt;/a&gt; 가 결과를 필요로 하거나 &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-job/start.html&quot;&gt;시작&lt;/a&gt; 함수가 호출 된 경우 에만 코 루틴을 시작 합니다. 다음 예제를 실행하십시오.</target>
        </trans-unit>
        <trans-unit id="64fbf3e4d33c3845151425fcbae0bd95c1ac7ffc" translate="yes" xml:space="preserve">
          <source>There is a nice piece of syntactic sugar that lets you do this: &lt;em&gt;extension functions&lt;/em&gt; and &lt;em&gt;extension properties&lt;/em&gt;. They look like regular member functions/properties, but they are defined outside of any class - yet they reference the class name and can use &lt;code&gt;this&lt;/code&gt;. However, they can only use visible members of the class (typically just the public ones). Behind the scenes, they get compiled down to regular functions that take the target instance as a parameter.</source>
          <target state="translated">이를 수행 할 수있는 멋진 구문 설탕 조각이 있습니다 : &lt;em&gt;확장 함수&lt;/em&gt; 및 &lt;em&gt;확장 속성&lt;/em&gt; . 일반 멤버 함수 / 속성처럼 보이지만 클래스 외부에서 정의되어 있지만 클래스 이름을 참조하여 &lt;code&gt;this&lt;/code&gt; 사용할 수 있습니다 . 그러나 클래스의 보이는 멤버 만 (일반적으로 공개 멤버 만) 사용할 수 있습니다. 배후에서 대상 인스턴스를 매개 변수로 사용하는 일반 함수로 컴파일됩니다.</target>
        </trans-unit>
        <trans-unit id="56a1a93e9823bbcbe462dd3f2561922740df0cc6" translate="yes" xml:space="preserve">
          <source>There is also &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.sync/with-lock.html&quot;&gt;withLock&lt;/a&gt; extension function that conveniently represents &lt;code&gt;mutex.lock(); try { ... } finally { mutex.unlock() }&lt;/code&gt; pattern:</source>
          <target state="translated">&lt;code&gt;mutex.lock(); try { ... } finally { mutex.unlock() }&lt;/code&gt; 을 편리하게 나타내는 &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.sync/with-lock.html&quot;&gt;withLock&lt;/a&gt; 확장 함수 도 있습니다 . {...} 마지막으로 {mutex.unlock ()} 패턴을 시도하십시오 .</target>
        </trans-unit>
        <trans-unit id="5482d8805716b35d94ddb1402c557dc6720d3835" translate="yes" xml:space="preserve">
          <source>There is also a pair of functions that take a predicate and search for elements matching it:</source>
          <target state="translated">술어를 가져 와서 일치하는 요소를 검색하는 함수 쌍도 있습니다.</target>
        </trans-unit>
        <trans-unit id="40c042439b9082c369e4da946808b3cddd767bd9" translate="yes" xml:space="preserve">
          <source>There is an &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.channels/actor.html&quot;&gt;actor&lt;/a&gt; coroutine builder that conveniently combines actor's mailbox channel into its scope to receive messages from and combines the send channel into the resulting job object, so that a single reference to the actor can be carried around as its handle.</source>
          <target state="translated">액터의 우편함 채널을 범위로 편리하게 결합하여 송신 채널을 결과 작업 오브젝트로부터 수신하고 결합하여 액터에 대한 단일 참조를 처리 할 수 있는 &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.channels/actor.html&quot;&gt;액터&lt;/a&gt; 코 루틴 빌더가 있습니다.</target>
        </trans-unit>
        <trans-unit id="b44464d4de5fbd249cc21009c9fb2f52893bbcce" translate="yes" xml:space="preserve">
          <source>There is an optimization that removes redundant arrays creation in such cases, which prevents performance degradation. The single-argument form produces warnings in Kotlin 1.2 and is to be dropped in Kotlin 1.3.</source>
          <target state="translated">이러한 경우 중복 어레이 생성을 제거하여 성능 저하를 방지하는 최적화가 있습니다. 단일 인수 형식은 Kotlin 1.2에서 경고를 생성하며 Kotlin 1.3에서 삭제됩니다.</target>
        </trans-unit>
        <trans-unit id="6a4b4c7df274b19d3bf5dccee93fd3962d578245" translate="yes" xml:space="preserve">
          <source>There is an option to publish variants grouped by the product flavor, so that the outputs of the different build types are placed in a single module, with the build type becoming a classifier for the artifacts (the release build type is still published with no classifier). This mode is disabled by default and can be enabled as follows:</source>
          <target state="translated">제품 플레이버별로 그룹화 된 변형을 게시 할 수있는 옵션이 있으므로 빌드 유형이 아티팩트의 분류자가되는 빌드 유형이 서로 다른 빌드 유형의 출력이 단일 모듈에 배치됩니다 (릴리스 빌드 유형은 분류자가없는 상태로 여전히 공개됨) ). 이 모드는 기본적으로 비활성화되어 있으며 다음과 같이 활성화 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6a3b908fffabfbd0bb64797382bd07626137ec3f" translate="yes" xml:space="preserve">
          <source>There is common misconception that making a variable &lt;code&gt;volatile&lt;/code&gt; solves concurrency problem. Let us try it:</source>
          <target state="translated">변수를 &lt;code&gt;volatile&lt;/code&gt; 만드는 것이 동시성 문제를 해결 한다는 일반적인 오해가 있습니다. 시도해 보자.</target>
        </trans-unit>
        <trans-unit id="5eb09ee69535cf6dda53683554e0ee16259161ba" translate="yes" xml:space="preserve">
          <source>There is no dedicated type in C language for strings. A developer knows from a method signature or the documentation, whether a given &lt;code&gt;char *&lt;/code&gt; means a C string in the context. Strings in the C language are null-terminated, a trailing zero character &lt;code&gt;\0&lt;/code&gt; is added at the end of a bytes sequence to mark a string termination. Usually, &lt;a href=&quot;https://en.wikipedia.org/wiki/UTF-8&quot;&gt;UTF-8 encoded strings&lt;/a&gt; are used. The UTF-8 encoding uses variable width characters, and it is backward compatible with &lt;a href=&quot;https://en.wikipedia.org/wiki/ASCII&quot;&gt;ASCII&lt;/a&gt;. Kotlin/Native uses UTF-8 character encoding by default.</source>
          <target state="translated">문자열에 대한 C 언어에는 전용 유형이 없습니다. 개발자는 주어진 &lt;code&gt;char *&lt;/code&gt; 가 컨텍스트에서 C 문자열을 의미 하는지 여부를 메소드 서명 또는 문서에서 알고 있습니다 . C 언어의 문자열은 null로 끝나고 문자열 시퀀스를 표시하기 위해 바이트 시퀀스의 끝에 후행 0 문자 &lt;code&gt;\0&lt;/code&gt; 이 추가됩니다. 일반적으로 &lt;a href=&quot;https://en.wikipedia.org/wiki/UTF-8&quot;&gt;UTF-8로 인코딩 된 문자열&lt;/a&gt; 이 사용됩니다. UTF-8 인코딩은 가변 너비 문자를 사용하며 &lt;a href=&quot;https://en.wikipedia.org/wiki/ASCII&quot;&gt;ASCII&lt;/a&gt; 와 역 호환됩니다 . Kotlin / Native는 기본적으로 UTF-8 문자 인코딩을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="50408f344ff56fd13407ed98b66fe0baaa2ef0c5" translate="yes" xml:space="preserve">
          <source>There is no longer an exception when running this code:</source>
          <target state="translated">이 코드를 실행할 때 더 이상 예외가 없습니다.</target>
        </trans-unit>
        <trans-unit id="edef4e6315a2b596a0ca3836f2b3be1feee84974" translate="yes" xml:space="preserve">
          <source>There is no meaning attached to values in this class, it can be used for any purpose. Pair exhibits value semantics, i.e. two pairs are equal if both components are equal.</source>
          <target state="translated">이 클래스의 값에 첨부 된 의미는 없으며 어떤 목적으로도 사용할 수 있습니다. 쌍은 값 의미를 나타냅니다. 즉 두 구성 요소가 모두 같으면 두 쌍이 같습니다.</target>
        </trans-unit>
        <trans-unit id="0049a565ebb0e6780625b95d2507e4c5901c80a7" translate="yes" xml:space="preserve">
          <source>There is no meaning attached to values in this class, it can be used for any purpose. Triple exhibits value semantics, i.e. two triples are equal if all three components are equal. An example of decomposing it into values:</source>
          <target state="translated">이 클래스의 값에 첨부 된 의미는 없으며 어떤 목적으로도 사용할 수 있습니다. 트리플은 가치 의미론을 나타냅니다. 즉, 세 구성 요소가 모두 같으면 두 트리플이 같습니다. 값으로 분해하는 예 :</target>
        </trans-unit>
        <trans-unit id="1dd7b0fcce3d3026dd4903ea1dcae2ace7aba63b" translate="yes" xml:space="preserve">
          <source>There is no namespaces support in C, so the Kotlin/Native compiler generates long names to avoid any possible clashes with other symbols in the existing native project.</source>
          <target state="translated">C에서는 네임 스페이스가 지원되지 않으므로 Kotlin / Native 컴파일러는 기존 기본 프로젝트의 다른 기호와 충돌을 피하기 위해 긴 이름을 생성합니다.</target>
        </trans-unit>
        <trans-unit id="8859e68bee06f71aa7ff22831dc050e526d2f13b" translate="yes" xml:space="preserve">
          <source>There is no need to handle the case of misformatted input in competitive programming. In competitive programming, an input format is always precisely specified and the actual input cannot deviate from the input specification in the problem statement. That's what the null-assertion operator &lt;code&gt;!!&lt;/code&gt; essentially does &amp;mdash; it asserts that the input string is present and throws an exception otherwise. Likewise, the &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.text/to-int&quot;&gt;String.toInt()&lt;/a&gt; function throws an exception if the input string is not an integer.</source>
          <target state="translated">경쟁 프로그래밍에서 형식이 잘못된 입력의 경우를 처리 할 필요가 없습니다. 경쟁 프로그래밍에서 입력 형식은 항상 정확하게 지정되며 실제 입력은 문제 설명의 입력 사양에서 벗어날 수 없습니다. 이것이 널 어설 션 연산자입니다 &lt;code&gt;!!&lt;/code&gt; 본질적으로-입력 문자열이 존재한다고 주장하고 그렇지 않으면 예외가 발생합니다. 마찬가지로 입력 문자열이 정수가 아닌 경우 &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.text/to-int&quot;&gt;String.toInt ()&lt;/a&gt; 함수는 예외를 발생시킵니다.</target>
        </trans-unit>
        <trans-unit id="e914e64115449100ebfd64599edfd2968cff02a7" translate="yes" xml:space="preserve">
          <source>There is now a large number of &lt;a href=&quot;building-mpp-with-gradle#supported-platforms&quot;&gt;preset platform configurations&lt;/a&gt; for different supported platforms.</source>
          <target state="translated">현재 지원되는 플랫폼마다 다양한 &lt;a href=&quot;building-mpp-with-gradle#supported-platforms&quot;&gt;사전 설정 플랫폼 구성&lt;/a&gt; 이 있습니다.</target>
        </trans-unit>
        <trans-unit id="9b648b3a77b4b2e5fa4527e728e2d5fe0ae2a410" translate="yes" xml:space="preserve">
          <source>There is one important semantic difference between object expressions and object declarations:</source>
          <target state="translated">객체 표현과 객체 선언 사이에는 중요한 의미 론적 차이가 있습니다.</target>
        </trans-unit>
        <trans-unit id="8fd6b73de53838cea1717936197f551e12e9d247" translate="yes" xml:space="preserve">
          <source>There is one more way to search elements in lists &amp;ndash; &lt;a href=&quot;https://en.wikipedia.org/wiki/Binary_search_algorithm&quot;&gt;binary search&lt;/a&gt;. It works significantly faster than other built-in search functions but &lt;em&gt;requires the list to be &lt;a href=&quot;collection-ordering&quot;&gt;sorted&lt;/a&gt;&lt;/em&gt; in ascending order according to a certain ordering: natural or another one provided in the function parameter. Otherwise, the result is undefined.</source>
          <target state="translated">목록에서 요소를 검색하는 또 다른 방법 인 &lt;a href=&quot;https://en.wikipedia.org/wiki/Binary_search_algorithm&quot;&gt;이진 검색이&lt;/a&gt; 있습니다. 다른 내장 검색 기능보다 훨씬 빠르지 만 특정 순서에 따라 &lt;em&gt;목록을&lt;a href=&quot;collection-ordering&quot;&gt;&lt;/a&gt;&lt;/em&gt; 오름차순으로 &lt;em&gt;정렬&lt;/em&gt;&lt;em&gt; 해야합니다 (&lt;/em&gt; 자연 또는 함수 매개 변수에 제공된 다른 순서). 그렇지 않으면 결과가 정의되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="c4497244354ad07743aea06bad3f15a18c72b5c2" translate="yes" xml:space="preserve">
          <source>There is still something to be desired for practical usage of coroutines. When we use &lt;code&gt;GlobalScope.launch&lt;/code&gt;, we create a top-level coroutine. Even though it is light-weight, it still consumes some memory resources while it runs. If we forget to keep a reference to the newly launched coroutine it still runs. What if the code in the coroutine hangs (for example, we erroneously delay for too long), what if we launched too many coroutines and ran out of memory? Having to manually keep references to all the launched coroutines and &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-job/join.html&quot;&gt;join&lt;/a&gt; them is error-prone.</source>
          <target state="translated">코 루틴의 실제 사용을 위해 여전히 바람직한 것이 있습니다. &lt;code&gt;GlobalScope.launch&lt;/code&gt; 를 사용하면 최상위 코 루틴을 만듭니다. 가볍지 만 실행하는 동안 여전히 일부 메모리 리소스를 사용합니다. 새로 출시 된 코 루틴에 대한 참조를 유지하지 않으면 여전히 실행됩니다. 코 루틴의 코드가 멈 추면 (예를 들어, 너무 오래 지연되는 경우) 코 루틴을 너무 많이 시작하고 메모리가 부족하면 어떻게합니까? 실행 된 모든 코 루틴에 대한 참조를 수동으로 유지하고 &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-job/join.html&quot;&gt;결합&lt;/a&gt; 해야하는 것은 오류가 발생하기 쉽습니다.</target>
        </trans-unit>
        <trans-unit id="98631247ce5d35bfa57c2de9453651ac4adc252b" translate="yes" xml:space="preserve">
          <source>There may be zero or more &lt;em&gt;catch&lt;/em&gt; blocks. &lt;em&gt;finally&lt;/em&gt; block may be omitted. However at least one &lt;em&gt;catch&lt;/em&gt; or &lt;em&gt;finally&lt;/em&gt; block should be present.</source>
          <target state="translated">&lt;em&gt;캐치&lt;/em&gt; 블록 이 0 개 이상있을 수 있습니다 . &lt;em&gt;마지막으로&lt;/em&gt; 블록은 생략 될 수 있습니다. 그러나 적어도 하나의 &lt;em&gt;catch&lt;/em&gt; 또는 &lt;em&gt;finally&lt;/em&gt; 블록이 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="f116d6d19440fd947335171cc03cdab27f6adc4e" translate="yes" xml:space="preserve">
          <source>There will be a property named &lt;code&gt;hello&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;hello&lt;/code&gt; 라는 속성이 있습니다 :</target>
        </trans-unit>
        <trans-unit id="def4b70b1b61bdf7178a471139f991f3029fb44c" translate="yes" xml:space="preserve">
          <source>There will only ever be one instance of this class, and the instance (which is created the first time it is accessed, in a thread-safe manner) has got the same name as the class:</source>
          <target state="translated">이 클래스의 인스턴스는 하나 뿐이며 인스턴스 (스레드에 안전한 방식으로 처음 액세스 할 때 생성됨)는 클래스와 동일한 이름을 갖습니다.</target>
        </trans-unit>
        <trans-unit id="6f9f7587a2e090ad5e29fbff32347947646d8531" translate="yes" xml:space="preserve">
          <source>There's a little bit of runtime overhead associated with lambda functions: they are really objects, so they must be instantiated, and (like other functions) calling them takes a little bit of time too. If we use the &lt;code&gt;inline&lt;/code&gt; keyword on a function, we tell the compiler to &lt;em&gt;inline&lt;/em&gt; both the function and its lambda parameters (if any) - that is, the compiler will copy the code of the function (and its lambda parameters) into &lt;em&gt;every&lt;/em&gt; callsite, thus eliminating the overhead of both the lambda instantiation and the calling of the function and the lambdas. This will happen unconditionally, unlike in C and C++, where &lt;code&gt;inline&lt;/code&gt; is more of a hint to the compiler. This will cause the size of the compiled code to grow, but it may be worth it for certain small but frequently-called functions.</source>
          <target state="translated">람다 함수와 관련된 런타임 오버 헤드가 약간 있습니다. 실제로는 객체이므로 인스턴스화해야하며 (다른 함수와 마찬가지로) 호출하는 데 약간의 시간이 걸립니다. 함수에 &lt;code&gt;inline&lt;/code&gt; 키워드를 사용하면 컴파일러에 함수와 해당 람다 매개 변수 (있는 경우)를 모두 &lt;em&gt;인라인&lt;/em&gt; 하도록 지시 합니다. 즉, 컴파일러는 함수 코드 (및 람다 매개 변수)를 &lt;em&gt;모든&lt;/em&gt; 호출 사이트에 복사합니다. 따라서 람다 인스턴스화와 함수 호출 및 람다 모두의 오버 헤드를 제거합니다. &lt;code&gt;inline&lt;/code&gt; C 및 C ++과 달리 무조건적으로 발생합니다.컴파일러에 대한 힌트입니다. 이로 인해 컴파일 된 코드의 크기가 커지지 만 작지만 자주 호출되는 특정 기능에는 유용 ​​할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1db5770d8b83e30706aed362d9428bb0d8466fab" translate="yes" xml:space="preserve">
          <source>There's a vast collection of functional programming-style operations available in the &lt;a href=&quot;../../../api/latest/jvm/stdlib/kotlin.collections/index&quot;&gt;&lt;code&gt;kotlin.collections&lt;/code&gt; package&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;../../../api/latest/jvm/stdlib/kotlin.collections/index&quot;&gt; &lt;code&gt;kotlin.collections&lt;/code&gt; 패키지&lt;/a&gt; 에는 다양한 기능적 프로그래밍 스타일 작업 모음이 있습니다 .</target>
        </trans-unit>
        <trans-unit id="202786b020b9056a1534a505736791f80248ba7e" translate="yes" xml:space="preserve">
          <source>There's no 64 bit integer number in JavaScript, so &lt;code&gt;kotlin.Long&lt;/code&gt; is not mapped to any JavaScript object, it's emulated by a Kotlin class.</source>
          <target state="translated">JavaScript에는 64 비트 정수 가 없으므로 &lt;code&gt;kotlin.Long&lt;/code&gt; 은 JavaScript 객체에 매핑되지 않으며 Kotlin 클래스에 의해 에뮬레이트됩니다.</target>
        </trans-unit>
        <trans-unit id="9178e1d163a2f07f63e80e90e8b72e40666cb6be" translate="yes" xml:space="preserve">
          <source>There's no such syntax in Kotlin. However, in Kotlin we have &lt;code&gt;companion&lt;/code&gt; objects. Kotlin treats companion objects of &lt;code&gt;external&lt;/code&gt; class in a special way: instead of expecting an object, it assumes members of companion objects to be members of the class itself. To describe &lt;code&gt;MyClass&lt;/code&gt; from the example above, you can write:</source>
          <target state="translated">코 틀린에는 그러한 구문이 없습니다. 그러나 Kotlin에는 &lt;code&gt;companion&lt;/code&gt; 개체가 있습니다. Kotlin은 &lt;code&gt;external&lt;/code&gt; 클래스 의 컴패니언 객체를 특별한 방식으로 처리합니다. 객체를 기대하는 대신 컴패니언 객체의 멤버를 클래스 자체의 멤버로 가정합니다. 위 예제에서 &lt;code&gt;MyClass&lt;/code&gt; 를 설명하기 위해 다음과 같이 작성할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="918d499d192390404b8163b61ae9ad18a046a4a8" translate="yes" xml:space="preserve">
          <source>There's two forms of using &lt;code&gt;definedExternally&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;definedExternally&lt;/code&gt; 를 사용하는 데는 두 가지 형태가 있습니다 .</target>
        </trans-unit>
        <trans-unit id="1d27760789bc7d15f7cae3944fffbd1ed1e60b2e" translate="yes" xml:space="preserve">
          <source>Therefore if the &lt;a href=&quot;write#kotlin.concurrent%24write%28java.util.concurrent.locks.ReentrantReadWriteLock%2C+kotlin.Function0%28%28kotlin.concurrent.write.T%29%29%29%2Faction&quot;&gt;action&lt;/a&gt; inside write lock has been initiated by checking some condition, the condition must be rechecked inside the &lt;a href=&quot;write#kotlin.concurrent%24write%28java.util.concurrent.locks.ReentrantReadWriteLock%2C+kotlin.Function0%28%28kotlin.concurrent.write.T%29%29%29%2Faction&quot;&gt;action&lt;/a&gt; to avoid possible races.</source>
          <target state="translated">따라서 일부 조건을 확인하여 쓰기 잠금 내부 의 &lt;a href=&quot;write#kotlin.concurrent%24write%28java.util.concurrent.locks.ReentrantReadWriteLock%2C+kotlin.Function0%28%28kotlin.concurrent.write.T%29%29%29%2Faction&quot;&gt;작업을&lt;/a&gt; 시작한 경우 가능한 경쟁을 피하기 위해 &lt;a href=&quot;write#kotlin.concurrent%24write%28java.util.concurrent.locks.ReentrantReadWriteLock%2C+kotlin.Function0%28%28kotlin.concurrent.write.T%29%29%29%2Faction&quot;&gt;작업&lt;/a&gt; 내에서 조건을 다시 확인해야합니다 .</target>
        </trans-unit>
        <trans-unit id="0f17bb5adc41c5c7eefa8d167c2c05552954588a" translate="yes" xml:space="preserve">
          <source>Therefore, the two following snippets are equivalent:</source>
          <target state="translated">따라서 다음 두 스 니펫은 동일합니다.</target>
        </trans-unit>
        <trans-unit id="b2fcfe97b28b6d55545bf13f39eacf58d2cbb997" translate="yes" xml:space="preserve">
          <source>Therefore, there is no general way to check whether an instance of a generic type was created with certain type arguments at runtime, and the compiler &lt;a href=&quot;typecasts#type-erasure-and-generic-type-checks&quot;&gt;prohibits such &lt;em&gt;is&lt;/em&gt;-checks&lt;/a&gt;.</source>
          <target state="translated">따라서 런타임에 제네릭 형식의 인스턴스가 특정 형식 인수를 사용하여 만들어 졌는지 여부를 확인하는 일반적인 방법은 없으며 컴파일러 &lt;a href=&quot;typecasts#type-erasure-and-generic-type-checks&quot;&gt;&lt;em&gt;는&lt;/em&gt;&lt;/a&gt; -checks를 금지&lt;em&gt;&lt;/em&gt; 합니다.</target>
        </trans-unit>
        <trans-unit id="ba4578c0908f499a877e6e75a3e1e8fb6ca14fec" translate="yes" xml:space="preserve">
          <source>These &lt;a href=&quot;typecasts#unchecked-casts&quot;&gt;unchecked casts&lt;/a&gt; can be used when type safety is implied by the high-level program logic but cannot be inferred directly by the compiler. The compiler issues a warning on unchecked casts, and at runtime, only the non-generic part is checked (equivalent to &lt;code&gt;foo as List&amp;lt;*&amp;gt;&lt;/code&gt;).</source>
          <target state="translated">이러한 &lt;a href=&quot;typecasts#unchecked-casts&quot;&gt;검사되지 않은 캐스트&lt;/a&gt; 는 유형 안전이 고급 프로그램 논리에 의해 암시되지만 컴파일러가 직접 유추 할 수없는 경우에 사용할 수 있습니다. 컴파일러는 검사되지 않은 캐스트에 대해 경고를 발행하고 런타임에 제네릭이 아닌 부분 만 검사합니다 ( &lt;code&gt;foo as List&amp;lt;*&amp;gt;&lt;/code&gt; 와 동일 ).</target>
        </trans-unit>
        <trans-unit id="dd3d3ea77431105543bdd1015eeb929086add1c8" translate="yes" xml:space="preserve">
          <source>These abstract classes can be used as base classes when implementing Kotlin collection classes. For implementing read-only collections there are &lt;code&gt;AbstractCollection&lt;/code&gt;, &lt;code&gt;AbstractList&lt;/code&gt;, &lt;code&gt;AbstractSet&lt;/code&gt; and &lt;code&gt;AbstractMap&lt;/code&gt;, and for mutable collections there are &lt;code&gt;AbstractMutableCollection&lt;/code&gt;, &lt;code&gt;AbstractMutableList&lt;/code&gt;, &lt;code&gt;AbstractMutableSet&lt;/code&gt; and &lt;code&gt;AbstractMutableMap&lt;/code&gt;. On JVM these abstract mutable collections inherit most of their functionality from JDK's abstract collections.</source>
          <target state="translated">Kotlin 컬렉션 클래스를 구현할 때 이러한 추상 클래스를 기본 클래스로 사용할 수 있습니다. 읽기 전용 컬렉션을 구현하기 위해 &lt;code&gt;AbstractCollection&lt;/code&gt; , &lt;code&gt;AbstractList&lt;/code&gt; , &lt;code&gt;AbstractSet&lt;/code&gt; 및 &lt;code&gt;AbstractMap&lt;/code&gt; 이 있으며 변경 가능한 컬렉션에는 &lt;code&gt;AbstractMutableCollection&lt;/code&gt; , &lt;code&gt;AbstractMutableList&lt;/code&gt; , &lt;code&gt;AbstractMutableSet&lt;/code&gt; 및 &lt;code&gt;AbstractMutableMap&lt;/code&gt; 이 있습니다. JVM에서 이러한 추상 가변 콜렉션은 JDK의 추상 콜렉션에서 대부분의 기능을 상속합니다.</target>
        </trans-unit>
        <trans-unit id="aae55c4083a74f1ac27e26d5124083a7a6b3b4cb" translate="yes" xml:space="preserve">
          <source>These are the &lt;a href=&quot;#default-project-layout&quot;&gt;default source set names&lt;/a&gt; for the production and test sources for the targets configured above. The source sets &lt;code&gt;commonMain&lt;/code&gt; and &lt;code&gt;commonTest&lt;/code&gt; are included into production and test compilations, respectively, of all targets. Note that the dependencies for common source sets &lt;code&gt;commonMain&lt;/code&gt; and &lt;code&gt;commonTest&lt;/code&gt; are the common artifacts, and the platform libraries go to the source sets of the specific targets.</source>
          <target state="translated">이들은입니다 &lt;a href=&quot;#default-project-layout&quot;&gt;기본 소스 세트 이름&lt;/a&gt; 위의 구성 대상에 대한 생산 및 테스트 소스. &lt;code&gt;commonMain&lt;/code&gt; 및 &lt;code&gt;commonTest&lt;/code&gt; 소스 세트 는 모든 대상의 프로덕션 및 테스트 컴파일에 각각 포함됩니다. 공통 소스 세트 &lt;code&gt;commonMain&lt;/code&gt; 및 &lt;code&gt;commonTest&lt;/code&gt; 에 대한 종속성 은 공통 아티팩트이며 플랫폼 라이브러리는 특정 대상의 소스 세트로 이동합니다.</target>
        </trans-unit>
        <trans-unit id="6c67dd2d501b6f7860e7b47d523d2ae61bab43e4" translate="yes" xml:space="preserve">
          <source>These are three general-purpose extension functions applicable to any receiver.</source>
          <target state="translated">이는 모든 수신기에 적용 가능한 3 가지 범용 확장 기능입니다.</target>
        </trans-unit>
        <trans-unit id="4a99a063b2c797ffc59fde5538599b9e6760c083" translate="yes" xml:space="preserve">
          <source>These considerations lead to the following rules. A covariant type parameter &lt;code&gt;T&lt;/code&gt; (which the user of an object might think is &lt;code&gt;Fruit&lt;/code&gt;, while the object in reality is tied to &lt;code&gt;Apple&lt;/code&gt;) may be used as:</source>
          <target state="translated">이러한 고려 사항은 다음 규칙으로 이어집니다. 공변량 유형 매개 변수 &lt;code&gt;T&lt;/code&gt; (객체의 사용자가 &lt;code&gt;Fruit&lt;/code&gt; 라고 생각할 수 있지만 실제로는 객체가 &lt;code&gt;Apple&lt;/code&gt; 에 연결되어 있다고 생각할 수 있음)는 다음과 같이 사용될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e8a12f370f83960d4f7413fab1b904c1e1f23ab2" translate="yes" xml:space="preserve">
          <source>These declarations look clear. All &lt;code&gt;char *&lt;/code&gt; pointers are turned into &lt;code&gt;str: CValuesRef&amp;lt;ByteVar&amp;gt;?&lt;/code&gt; for parameters and to &lt;code&gt;CPointer&amp;lt;ByteVar&amp;gt;?&lt;/code&gt; in return types. Kotlin turns &lt;code&gt;char&lt;/code&gt; type into &lt;code&gt;kotlin.Byte&lt;/code&gt; type, as it is usually an 8-bit signed value.</source>
          <target state="translated">이 선언은 분명해 보인다. 모든 &lt;code&gt;char *&lt;/code&gt; 포인터는 &lt;code&gt;str: CValuesRef&amp;lt;ByteVar&amp;gt;?&lt;/code&gt; 매개 변수 및 &lt;code&gt;CPointer&amp;lt;ByteVar&amp;gt;?&lt;/code&gt; 반환 형식으로. Kotlin은 &lt;code&gt;char&lt;/code&gt; 유형을 &lt;code&gt;kotlin.Byte&lt;/code&gt; 유형으로 변환 합니다. 일반적으로 8 비트 부호있는 값입니다.</target>
        </trans-unit>
        <trans-unit id="53e4257de1ac9420719572d5eaf311fafd22b5c2" translate="yes" xml:space="preserve">
          <source>These features are not considered production ready yet, so you need to turn on the &lt;em&gt;experimental mode&lt;/em&gt; in &lt;code&gt;build.gradle&lt;/code&gt; in order to use them:</source>
          <target state="translated">이러한 기능은 아직 프로덕션 준비 상태로 간주되지 않으므로 &lt;code&gt;build.gradle&lt;/code&gt; 에서 &lt;em&gt;실험 모드&lt;/em&gt; 를 켜야 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e6b05d8f5b89932c0c2ddc8328889d3567a05266" translate="yes" xml:space="preserve">
          <source>These functions can also be used for converting collections to other types, for example, build a set from a list or vice versa.</source>
          <target state="translated">이 함수는 컬렉션을 다른 형식으로 변환하는데도 사용할 수 있습니다 (예 : 목록에서 집합을 빌드하거나 그 반대로).</target>
        </trans-unit>
        <trans-unit id="d5e9c8cae28543e16ef49eb2054cfc4937ef3fcf" translate="yes" xml:space="preserve">
          <source>These functions can be used for easy copying of maps:</source>
          <target state="translated">이 기능을 사용하면 맵을 쉽게 복사 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2a7f12885b59bbc14ccabadd6389a34cf6ff8eb2" translate="yes" xml:space="preserve">
          <source>These functions can be used to find the lowest and greatest of two or three given values, where values are primitive numbers or &lt;code&gt;Comparable&lt;/code&gt; objects. There is also an overload of each function that take an additional &lt;code&gt;Comparator&lt;/code&gt; instance, if you want to compare objects that are not comparable themselves.</source>
          <target state="translated">이 함수는 두 개 또는 세 개의 주어진 값 중 가장 작은 값과 가장 큰 값을 찾는 데 사용할 수 있습니다. 여기서 값은 기본 숫자 또는 &lt;code&gt;Comparable&lt;/code&gt; 객체입니다. 자체 비교할 수없는 객체를 비교하려는 경우 추가 &lt;code&gt;Comparator&lt;/code&gt; 인스턴스 를 사용하는 각 함수의 오버로드도 있습니다.</target>
        </trans-unit>
        <trans-unit id="8f7f5c9e85694705edbe3da3b621cafe8f2795f3" translate="yes" xml:space="preserve">
          <source>These functions deal with Kotlin/Native objects. Call the &lt;code&gt;DisposeStablePointer&lt;/code&gt; to release a Kotlin object and &lt;code&gt;DisposeString&lt;/code&gt; to release a Kotlin String, which has the &lt;code&gt;char*&lt;/code&gt; type in C. It is possible to use the &lt;code&gt;IsInstance&lt;/code&gt; function to check if a Kotlin type or a &lt;code&gt;libnative_KNativePtr&lt;/code&gt; is an instance of another type. The actual set of operations generated depends on the actual usages.</source>
          <target state="translated">이 함수는 Kotlin / Native 객체를 처리합니다. 통화 &lt;code&gt;DisposeStablePointer&lt;/code&gt; 코 틀린 객체와 해제 &lt;code&gt;DisposeString&lt;/code&gt; 가 갖는 코 틀린 문자열 해제 &lt;code&gt;char*&lt;/code&gt; 사용하는 것이 가능하다 C.에 입력 &lt;code&gt;IsInstance&lt;/code&gt; 의 코 틀린 종류 나 있는지 확인하는 기능을 &lt;code&gt;libnative_KNativePtr&lt;/code&gt; 는 다른 유형의 인스턴스이다. 생성되는 실제 작업 세트는 실제 사용법에 따라 다릅니다.</target>
        </trans-unit>
        <trans-unit id="ebcfd0ed6c7e90830065d9ee1e014161378d5e50" translate="yes" xml:space="preserve">
          <source>These include &lt;a href=&quot;reflection#bound-function-and-property-references-since-11&quot;&gt;bound callable references&lt;/a&gt; that point to a member of a particular instance: &lt;code&gt;foo::toString&lt;/code&gt;.</source>
          <target state="translated">여기에는 특정 인스턴스의 멤버를 가리키는 &lt;a href=&quot;reflection#bound-function-and-property-references-since-11&quot;&gt;바인딩 된 호출 가능 참조&lt;/a&gt; 가 포함됩니다 ( &lt;code&gt;foo::toString&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="341a2ef673574a4668acee83662de92778d835b1" translate="yes" xml:space="preserve">
          <source>These operators only work with the function &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin/-any/equals&quot;&gt;&lt;code&gt;equals(other: Any?): Boolean&lt;/code&gt;&lt;/a&gt;, which can be overridden to provide custom equality check implementation. Any other function with the same name (like &lt;code&gt;equals(other: Foo)&lt;/code&gt;) will not be called.</source>
          <target state="translated">이 연산자는 &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin/-any/equals&quot;&gt; &lt;code&gt;equals(other: Any?): Boolean&lt;/code&gt; &lt;/a&gt; 함수에서만 작동하며, 사용자 정의 동등 검사 구현을 제공하기 위해 재정의 할 수 있습니다. &lt;code&gt;equals(other: Foo)&lt;/code&gt; 같은 이름을 가진 다른 함수는 호출되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="04c64c9fdc4ddbb026d14664db7dfcf575773eab" translate="yes" xml:space="preserve">
          <source>These options have nearly the same effect as clang's &lt;code&gt;-fembed-bitcode&lt;/code&gt;/&lt;code&gt;-fembed-bitcode-marker&lt;/code&gt; and swiftc's &lt;code&gt;-embed-bitcode&lt;/code&gt;/&lt;code&gt;-embed-bitcode-marker&lt;/code&gt;.</source>
          <target state="translated">이러한 옵션은 clang의 &lt;code&gt;-fembed-bitcode&lt;/code&gt; / &lt;code&gt;-fembed-bitcode-marker&lt;/code&gt; 및 swiftc의 &lt;code&gt;-embed-bitcode&lt;/code&gt; / &lt;code&gt;-embed-bitcode-marker&lt;/code&gt; 와 거의 동일한 효과를 갖습니다 .</target>
        </trans-unit>
        <trans-unit id="42a0b78cb4e25be9e1f6ef7cf3d39eb3e781050e" translate="yes" xml:space="preserve">
          <source>These tasks are defined in the &lt;em&gt;kotlin-ant.jar&lt;/em&gt; library which is located in the &lt;em&gt;lib&lt;/em&gt; folder for the &lt;a href=&quot;https://github.com/JetBrains/kotlin/releases/tag/v1.3.41&quot;&gt;Kotlin Compiler&lt;/a&gt; Ant version 1.8.2+ is required.</source>
          <target state="translated">이러한 작업은 &lt;a href=&quot;https://github.com/JetBrains/kotlin/releases/tag/v1.3.41&quot;&gt;Kotlin Compiler&lt;/a&gt; Ant 버전 1.8.2+ 의 &lt;em&gt;lib&lt;/em&gt; 폴더 에있는 &lt;em&gt;kotlin-ant.jar&lt;/em&gt; 라이브러리에 정의되어 있습니다 .&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="1d0ae43a71338a23e33d7f8aec6b35c87860e63a" translate="yes" xml:space="preserve">
          <source>These transformations can also be applied to &lt;code&gt;Sequence&amp;lt;T&amp;gt;&lt;/code&gt;, which is similar to Python's generators and allows for lazy evaluation. If you have a huge list and you want to process it lazily, you can call &lt;code&gt;asSequence()&lt;/code&gt; on it.</source>
          <target state="translated">이러한 변환은 &lt;code&gt;Sequence&amp;lt;T&amp;gt;&lt;/code&gt; 에도 적용 할 수 있으며 , 이는 Python의 생성기와 유사하며 지연 평가를 허용합니다. 거대한 목록이 있고 지연 처리하려면 &lt;code&gt;asSequence()&lt;/code&gt; 를 호출 하면됩니다.</target>
        </trans-unit>
        <trans-unit id="03f364964cb20dc479a4f5003a2a44d235abdb7a" translate="yes" xml:space="preserve">
          <source>These two functions can not be defined side-by-side, because their JVM signatures are the same: &lt;code&gt;filterValid(Ljava/util/List;)Ljava/util/List;&lt;/code&gt;. If we really want them to have the same name in Kotlin, we can annotate one (or both) of them with &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.jvm/-jvm-name/index&quot;&gt;&lt;code&gt;@JvmName&lt;/code&gt;&lt;/a&gt; and specify a different name as an argument:</source>
          <target state="translated">이 두 함수는 JVM 서명이 동일하므로 나란히 정의 할 수 없습니다. &lt;code&gt;filterValid(Ljava/util/List;)Ljava/util/List;&lt;/code&gt; . Kotlin에서 실제로 동일한 이름을 갖기를 원한다면 &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.jvm/-jvm-name/index&quot;&gt; &lt;code&gt;@JvmName&lt;/code&gt; &lt;/a&gt; 으로 그들 중 하나 (또는 ​​둘 다)에 주석을 달고 다른 이름을 인수로 지정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="921fb3d0fcc9e0673ab266d259447beb1dbfed2e" translate="yes" xml:space="preserve">
          <source>These two options let you choose the proper function depending on what you do next in your code.</source>
          <target state="translated">이 두 가지 옵션을 사용하면 코드에서 다음에 수행 할 작업에 따라 적절한 기능을 선택할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5dbdf5173288dba5a705ae6e593e7cbdf4691ea2" translate="yes" xml:space="preserve">
          <source>These types are used to map boxed Kotlin number types into Objective-C and Swift. In Swift, we may simply call the constructor to create an instance, e.g. &lt;code&gt;KotlinLong(value: 42)&lt;/code&gt;.</source>
          <target state="translated">이 유형은 박스형 Kotlin 숫자 유형을 Objective-C 및 Swift에 맵핑하는 데 사용됩니다. Swift에서 생성자를 호출하여 인스턴스를 생성 할 수 있습니다 &lt;code&gt;KotlinLong(value: 42)&lt;/code&gt; 예 : KotlinLong (value : 42)) .</target>
        </trans-unit>
        <trans-unit id="c780ae4d91e6b3d59d657bd21738eface7e6d706" translate="yes" xml:space="preserve">
          <source>These types have a special notation that corresponds to the signatures of the functions, i.e. their parameters and return values:</source>
          <target state="translated">이 유형에는 함수의 시그니처, 즉 매개 변수 및 리턴 값에 해당하는 특수 표기법이 있습니다.</target>
        </trans-unit>
        <trans-unit id="49301d7c0ca361c41d110b3bca3a6ef2c53c1486" translate="yes" xml:space="preserve">
          <source>They also can be used in return statements of functions returning the context object.</source>
          <target state="translated">컨텍스트 객체를 반환하는 함수의 return 문에도 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6e6ad519d848a011249fae6e51a09e8caed4ec20" translate="yes" xml:space="preserve">
          <source>They can't be passed as reified type arguments.</source>
          <target state="translated">그것들은 refined type 인수로 전달 될 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="9f968b20031a0c4e81acc38a3f23bdedaba5b962" translate="yes" xml:space="preserve">
          <source>They can't be used in class literal expressions (i.e. &lt;code&gt;I::class&lt;/code&gt;).</source>
          <target state="translated">클래스 리터럴 표현식 (예 : &lt;code&gt;I::class&lt;/code&gt; ) 에는 사용할 수 없습니다 .</target>
        </trans-unit>
        <trans-unit id="2f0701452411de1234771e67765d254ade0b6df7" translate="yes" xml:space="preserve">
          <source>They can't be used on the right hand side of &lt;code&gt;is&lt;/code&gt; checks.</source>
          <target state="translated">이들은 오른쪽에 이용 될 수는 &lt;code&gt;is&lt;/code&gt; 검사한다.</target>
        </trans-unit>
        <trans-unit id="398723a13324bec77451c1ae01057e1ef7af3705" translate="yes" xml:space="preserve">
          <source>They must be member functions or &lt;a href=&quot;extensions&quot;&gt;extension functions&lt;/a&gt;;</source>
          <target state="translated">멤버 함수 또는 &lt;a href=&quot;extensions&quot;&gt;확장 함수&lt;/a&gt; 여야합니다 .</target>
        </trans-unit>
        <trans-unit id="d532a698fc6a89ca0085db59fd5aa194790955a6" translate="yes" xml:space="preserve">
          <source>They must have a single parameter;</source>
          <target state="translated">그것들은 단일 파라미터를 가져야합니다;</target>
        </trans-unit>
        <trans-unit id="4df440c5a2dac5df94e2c6decf7738ac3f8470ab" translate="yes" xml:space="preserve">
          <source>Third value.</source>
          <target state="translated">세번째 가치.</target>
        </trans-unit>
        <trans-unit id="65054a6c60d19f99f3ba82de08ae0a53fc9c01d3" translate="yes" xml:space="preserve">
          <source>This API can be used to group a collection by key and fold each group simultaneously. For example, it can be used to count the number of words starting with each letter:</source>
          <target state="translated">이 API를 사용하여 키별로 모음을 그룹화하고 각 그룹을 동시에 접을 수 있습니다. 예를 들어, 각 문자로 시작하는 단어 수를 계산하는 데 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c5e92a8ba9a486d6b6f5f3bfcee1ee9e16e21ffe" translate="yes" xml:space="preserve">
          <source>This Expression</source>
          <target state="translated">이 표현</target>
        </trans-unit>
        <trans-unit id="39d8e7ef05f8d1193ddfe60ed385361228082346" translate="yes" xml:space="preserve">
          <source>This allows the Java Persistence API (JPA) to instantiate a class although it doesn't have the zero-parameter constructor from Kotlin or Java point of view (see the description of &lt;code&gt;kotlin-jpa&lt;/code&gt; plugin &lt;a href=&quot;compiler-plugins#jpa-support&quot;&gt;below&lt;/a&gt;).</source>
          <target state="translated">이것은 Java Persistence API (JPA)가 Kotlin 또는 Java 관점에서 0 매개 변수 생성자를 갖지 않지만 클래스를 인스턴스화 할 수있게합니다 ( &lt;a href=&quot;compiler-plugins#jpa-support&quot;&gt;아래&lt;/a&gt; 의 &lt;code&gt;kotlin-jpa&lt;/code&gt; 플러그인 설명 참조 ).</target>
        </trans-unit>
        <trans-unit id="262a7c17763f126ac70f16b74664e0c2732654ca" translate="yes" xml:space="preserve">
          <source>This allows the user code to not pass an extra &lt;a href=&quot;-coroutine-context/index&quot;&gt;CoroutineContext&lt;/a&gt; parameter in basic coroutine builders like &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.experimental/launch.html&quot;&gt;launch&lt;/a&gt; and &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.experimental/async.html&quot;&gt;async&lt;/a&gt;, but still provide easy access to coroutine context.</source>
          <target state="translated">이를 통해 사용자 코드 는 &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.experimental/launch.html&quot;&gt;launch&lt;/a&gt; 및 &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.experimental/async.html&quot;&gt;async&lt;/a&gt; 와 같은 기본 코 루틴 빌더에서 추가 &lt;a href=&quot;-coroutine-context/index&quot;&gt;CoroutineContext&lt;/a&gt; 매개 변수를 전달하지 않아도 코 루틴 컨텍스트에 쉽게 액세스 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="eb2da247bb9f320229aba7d44d4da4813d52b5e8" translate="yes" xml:space="preserve">
          <source>This allows us to write:</source>
          <target state="translated">이를 통해 다음과 같이 쓸 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2943eee5e149bda0a3b90788c4e427a3f77fb555" translate="yes" xml:space="preserve">
          <source>This also a reason why, in these examples, &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-coroutine-exception-handler/index.html&quot;&gt;CoroutineExceptionHandler&lt;/a&gt; is always installed to a coroutine that is created in &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-global-scope/index.html&quot;&gt;GlobalScope&lt;/a&gt;. It does not make sense to install an exception handler to a coroutine that is launched in the scope of the main &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/run-blocking.html&quot;&gt;runBlocking&lt;/a&gt;, since the main coroutine is going to be always cancelled when its child completes with exception despite the installed handler.</source>
          <target state="translated">이 예제에서 &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-coroutine-exception-handler/index.html&quot;&gt;CoroutineExceptionHandler&lt;/a&gt; 가 항상 &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-global-scope/index.html&quot;&gt;GlobalScope&lt;/a&gt; 에서 작성된 코 루틴에 설치 되는 이유이기도 합니다. 메인 &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/run-blocking.html&quot;&gt;runBlocking&lt;/a&gt; 범위에서 실행되는 코 루틴에 예외 핸들러를 설치하는 것은 의미가 없습니다 . 메인 핸들러는 설치된 핸들러에도 불구하고 자식이 예외로 완료되면 항상 취소되기 때문입니다.</target>
        </trans-unit>
        <trans-unit id="369f2b1361dad7365016272a8691f3b6c2f5f7b0" translate="yes" xml:space="preserve">
          <source>This also works in &lt;a href=&quot;multi-declarations&quot;&gt;destructuring declarations&lt;/a&gt;:</source>
          <target state="translated">이것은 &lt;a href=&quot;multi-declarations&quot;&gt;선언&lt;/a&gt; 을 파괴하는 데 에도 효과적입니다 .</target>
        </trans-unit>
        <trans-unit id="7624b3ac5961056978ec90a7581d578f33bbbb61" translate="yes" xml:space="preserve">
          <source>This annotation indicates what exceptions should be declared by a function when compiled to a JVM method.</source>
          <target state="translated">이 주석은 JVM 메소드로 컴파일 될 때 함수가 선언해야하는 예외를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="3b67d7593eb58defe040aee620d9f9dc5b7b870b" translate="yes" xml:space="preserve">
          <source>This annotation indicates what exceptions should be declared by a function when compiled to a platform method.</source>
          <target state="translated">이 주석은 플랫폼 메소드로 컴파일 될 때 함수가 선언해야하는 예외를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="53852272acd887d2ace151213b2a79c6186dd5ad" translate="yes" xml:space="preserve">
          <source>This annotation is intended for &lt;em&gt;rare cases&lt;/em&gt; when API designer needs to hide Kotlin-specific target from Java API while keeping it a part of Kotlin API so the resulting API is idiomatic for both languages.</source>
          <target state="translated">이 주석은위한 것입니다 &lt;em&gt;드문 경우&lt;/em&gt; 결과 API는 두 언어에 대한 관용적 그래서 자바 API에서 숨기기 코 틀린 특정 대상에 대한 API 디자이너의 요구가 코 틀린의 API의 일부를 유지하면서 때.</target>
        </trans-unit>
        <trans-unit id="f7ff9954f76ed995dd9da4bc5f1699538f3cd9e5" translate="yes" xml:space="preserve">
          <source>This annotation is only applicable to &lt;code&gt;expect&lt;/code&gt; annotation classes in multi-platform projects and marks that class as &quot;optional&quot;. Optional expected class is allowed to have no corresponding actual class on the platform. Optional annotations can only be used to annotate something, not as types in signatures. If an optional annotation has no corresponding actual class on a platform, the annotation entries where it's used are simply erased when compiling code on that platform.</source>
          <target state="translated">이 주석은 다중 플랫폼 프로젝트에서 주석 클래스 를 &lt;code&gt;expect&lt;/code&gt; 할 때만 해당 클래스를 &quot;선택&quot;으로 표시합니다. 선택적 예상 클래스는 플랫폼에서 해당하는 실제 클래스를 가질 수 없습니다. 선택적 주석은 서명의 유형이 아닌 무언가에 주석을 달기 위해서만 사용할 수 있습니다. 선택적 주석에 플랫폼에서 해당하는 실제 클래스가없는 경우 해당 플랫폼에서 코드를 컴파일 할 때 주석이 사용 된 주석 항목이 지워집니다.</target>
        </trans-unit>
        <trans-unit id="c1b9122ad4cc089c09a766a63290941217a27add" translate="yes" xml:space="preserve">
          <source>This annotation is present on any class file produced by the Kotlin compiler and is read by the compiler and reflection. Parameters have very short JVM names on purpose: these names appear in all generated class files, and we'd like to reduce their size.</source>
          <target state="translated">이 주석은 Kotlin 컴파일러가 생성 한 클래스 파일에 있으며 컴파일러와 리플렉션에서 읽습니다. 매개 변수는 의도적으로 매우 짧은 JVM 이름을 갖습니다.이 이름은 생성 된 모든 클래스 파일에 나타나며 크기를 줄이려고합니다.</target>
        </trans-unit>
        <trans-unit id="08e24e4cbc4d173492beb5ffd4d4ddb94a113383" translate="yes" xml:space="preserve">
          <source>This annotation marks the standard library API that is considered experimental and is not subject to the &lt;a href=&quot;../../../../../../docs/reference/evolution/components-stability&quot;&gt;general compatibility guarantees&lt;/a&gt; given for the standard library: the behavior of such API may be changed or the API may be removed completely in any further release.</source>
          <target state="translated">이 주석은 실험적인 것으로 간주되는 표준 라이브러리 API를 표시하며 표준 라이브러리에 대해 제공되는 &lt;a href=&quot;../../../../../../docs/reference/evolution/components-stability&quot;&gt;일반적인 호환성 보증&lt;/a&gt; 대상이 아닙니다 . 이러한 API의 동작이 변경되거나 추가 릴리스에서 API가 완전히 제거 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="400bdfa2156af296817e663103c3f69c483eb8d7" translate="yes" xml:space="preserve">
          <source>This annotation marks the standard library API that is considered experimental and is not subject to the &lt;a href=&quot;../../../../../docs/reference/evolution/components-stability&quot;&gt;general compatibility guarantees&lt;/a&gt; given for the standard library: the behavior of such API may be changed or the API may be removed completely in any further release.</source>
          <target state="translated">이 주석은 실험적인 것으로 간주되는 표준 라이브러리 API를 표시하며 표준 라이브러리에 대해 제공되는 &lt;a href=&quot;../../../../../docs/reference/evolution/components-stability&quot;&gt;일반적인 호환성 보증&lt;/a&gt; 대상이 아닙니다 . 이러한 API의 동작이 변경되거나 추가 릴리스에서 API가 완전히 제거 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4a3b2ae9c5594175372b79e16080724e6e8baa3b" translate="yes" xml:space="preserve">
          <source>This approach requires a series of changes in how we program, in particular</source>
          <target state="translated">이 접근법은 특히 프로그래밍 방식에 대한 일련의 변경이 필요합니다.</target>
        </trans-unit>
        <trans-unit id="caabd1756e7a5fe69a248020021b58534dfbff4d" translate="yes" xml:space="preserve">
          <source>This behavior is correct but it can be very inconvenient for some libraries. So it is possible to specify in the &lt;code&gt;.def&lt;/code&gt; file which of the included headers are to be imported. The separate declarations from other headers can also be imported in case of direct dependencies.</source>
          <target state="translated">이 동작은 정확하지만 일부 라이브러리에서는 매우 불편할 수 있습니다. 따라서 포함 된 헤더 중 가져올 헤더를 &lt;code&gt;.def&lt;/code&gt; 파일 에 지정할 수 있습니다. 직접 종속성의 경우 다른 헤더에서 별도의 선언을 가져올 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="c6b0989aa993ac0e544c959f288dcd6e31817be1" translate="yes" xml:space="preserve">
          <source>This behavior is similar to &lt;a href=&quot;extensions&quot;&gt;extension functions&lt;/a&gt;, which also allow you to access the members of the receiver object inside the body of the function.</source>
          <target state="translated">이 동작은 &lt;a href=&quot;extensions&quot;&gt;확장 함수&lt;/a&gt; 와 유사하며 함수 본문 내에서 수신자 오브젝트의 멤버에 액세스 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="e20a24097999574b06c858b7503368f6bbdeb55a" translate="yes" xml:space="preserve">
          <source>This callback method should call one of these two methods:</source>
          <target state="translated">이 콜백 메소드는 다음 두 메소드 중 하나를 호출해야합니다.</target>
        </trans-unit>
        <trans-unit id="216d2a3ecca96db5ee19a6d39eef11e98c9f0bf5" translate="yes" xml:space="preserve">
          <source>This can be effectively combined with other idioms, leading to shorter code. E.g. with the &lt;em&gt;when&lt;/em&gt;-expression:</source>
          <target state="translated">이것은 다른 관용구와 효과적으로 결합되어 코드가 더 짧아집니다. 예를 들어 &lt;em&gt;when&lt;/em&gt; -expression 과 함께 :</target>
        </trans-unit>
        <trans-unit id="a3b4ad6a40906907f86d5ceb0160f0fc35e4272e" translate="yes" xml:space="preserve">
          <source>This can be useful for creating &lt;a href=&quot;../kotlin.collections/-map/index#kotlin.collections.Map&quot;&gt;Map&lt;/a&gt; literals with less noise, for example:</source>
          <target state="translated">노이즈가 적은 &lt;a href=&quot;../kotlin.collections/-map/index#kotlin.collections.Map&quot;&gt;맵&lt;/a&gt; 리터럴 을 만드는 데 유용합니다 . 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="7e1ff87841658b954b989c8097e33f6cc0f4c4fa" translate="yes" xml:space="preserve">
          <source>This check is only available for the properties that are lexically accessible, i.e. declared in the same type or in one of the outer types, or at top level in the same file.</source>
          <target state="translated">이 검사는 사 전적으로 액세스 가능한 속성, 즉 동일한 유형 또는 외부 유형 중 하나 또는 동일한 파일에서 최상위 수준으로 선언 된 속성에 대해서만 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b8e6d8ea08a6d2f26902035e61567b7b01f67c89" translate="yes" xml:space="preserve">
          <source>This class cannot be either co- or contravariant in &lt;code&gt;T&lt;/code&gt;. And this imposes certain inflexibilities. Consider the following function:</source>
          <target state="translated">이 클래스는 &lt;code&gt;T&lt;/code&gt; 의 공변량 또는 반 변형 일 수 없습니다 . 그리고 이것은 특정 융통성을 부과합니다. 다음 기능을 고려하십시오.</target>
        </trans-unit>
        <trans-unit id="cfa1db139b7b160a14b6c47d1a1495d378da6d44" translate="yes" xml:space="preserve">
          <source>This class is experimental itself and can only be used with the compiler argument &lt;code&gt;-Xuse-experimental=kotlin.Experimental&lt;/code&gt;.</source>
          <target state="translated">이 클래스는 실험적이며 컴파일러 인수 &lt;code&gt;-Xuse-experimental=kotlin.Experimental&lt;/code&gt; 과 함께 만 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="f5fdf32c20c754f3849efeb2ffb6fd9fe85ddd31" translate="yes" xml:space="preserve">
          <source>This class is intended to help implementing read-only lists so it doesn't support concurrent modification tracking.</source>
          <target state="translated">이 클래스는 읽기 전용 목록을 구현하는 데 도움을주기 위해 동시 수정 추적을 지원하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="3649d86d1c264225e25ee01e6d003c299727a7d0" translate="yes" xml:space="preserve">
          <source>This class is intended to help implementing read-only sets so it doesn't support concurrent modification tracking.</source>
          <target state="translated">이 클래스는 읽기 전용 세트를 구현하는 데 도움을주기 위해 동시 수정 추적을 지원하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="d10d84799d8bbf78fb0535ad9184c4c6ada6aa07" translate="yes" xml:space="preserve">
          <source>This class is intended to implement different file traversal methods. It allows to iterate through all files inside a given directory.</source>
          <target state="translated">이 클래스는 다른 파일 순회 메소드를 구현하기위한 것입니다. 주어진 디렉토리 내의 모든 파일을 반복 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="322e62ea251e48658a034c9b427e81ba230bb5e9" translate="yes" xml:space="preserve">
          <source>This class provides a way to create a stable handle to any Kotlin object. After &lt;a href=&quot;-stable-ref/as-c-pointer&quot;&gt;converting to CPointer&lt;/a&gt; it can be safely passed to native code e.g. to be received in a Kotlin callback.</source>
          <target state="translated">이 클래스는 Kotlin 객체에 대한 안정적인 핸들을 만드는 방법을 제공합니다. &lt;a href=&quot;-stable-ref/as-c-pointer&quot;&gt;CPointer로 변환&lt;/a&gt; 한 후에 는 코 틀린 콜백에서 수신하기 위해 네이티브 코드로 안전하게 전달 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a36e06591e999a4c0d4c4171fd2c0675fb1b16fc" translate="yes" xml:space="preserve">
          <source>This class provides a way to create a stable handle to any Kotlin object. After &lt;a href=&quot;../../kotlinx.cinterop/-stable-ref/as-c-pointer&quot;&gt;converting to CPointer&lt;/a&gt; it can be safely passed to native code e.g. to be received in a Kotlin callback.</source>
          <target state="translated">이 클래스는 Kotlin 객체에 대한 안정적인 핸들을 만드는 방법을 제공합니다. &lt;a href=&quot;../../kotlinx.cinterop/-stable-ref/as-c-pointer&quot;&gt;CPointer로 변환&lt;/a&gt; 한 후에 는 코 틀린 콜백에서 수신하기 위해 네이티브 코드로 안전하게 전달 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f9ba51153ea7889b4c1f1704d375fc98842fa90a" translate="yes" xml:space="preserve">
          <source>This class provides a way to create a stable handle to any Kotlin object. After &lt;a href=&quot;as-c-pointer&quot;&gt;converting to CPointer&lt;/a&gt; it can be safely passed to native code e.g. to be received in a Kotlin callback.</source>
          <target state="translated">이 클래스는 Kotlin 객체에 대한 안정적인 핸들을 만드는 방법을 제공합니다. &lt;a href=&quot;as-c-pointer&quot;&gt;CPointer로 변환&lt;/a&gt; 한 후에 는 코 틀린 콜백에서 수신하기 위해 네이티브 코드로 안전하게 전달 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3de458f3166219b6408ccb11d5d011e7dedd5974" translate="yes" xml:space="preserve">
          <source>This code calculates the fixpoint of cosine, which is a mathematical constant. It simply calls Math.cos repeatedly starting at 1.0 until the result doesn't change any more, yielding a result of 0.7390851332151611 for the specified &lt;code&gt;eps&lt;/code&gt; precision. The resulting code is equivalent to this more traditional style:</source>
          <target state="translated">이 코드는 수학 상수 인 코사인의 고정 점을 계산합니다. 결과가 더 이상 변경되지 않을 때까지 1.0부터 반복적으로 Math.cos를 호출하여 지정된 &lt;code&gt;eps&lt;/code&gt; 정밀도에 대해 0.7390851332151611의 결과를 생성합니다 . 결과 코드는 이보다 전통적인 스타일과 동일합니다.</target>
        </trans-unit>
        <trans-unit id="1c9fb24eb61454c344b8e7f5093f2e83751a14fd" translate="yes" xml:space="preserve">
          <source>This code specifies an action to be performed on the &quot;hello&quot; button click. Note that with lambdas this code looks rather concise written directly in Kotlin:</source>
          <target state="translated">이 코드는 &quot;hello&quot;버튼 클릭시 수행 할 동작을 지정합니다. 람다의 경우이 코드는 Kotlin에서 직접 작성된 다소 간결하게 보입니다.</target>
        </trans-unit>
        <trans-unit id="f097f6de0cc3b7d0fc741d38a1eac67ae2fca6f2" translate="yes" xml:space="preserve">
          <source>This code will launch a long-running operation without blocking the main thread. The &lt;code&gt;preparePost&lt;/code&gt; is what's called a &lt;code&gt;suspendable function&lt;/code&gt;, thus the keyword &lt;code&gt;suspend&lt;/code&gt; prefixing it. What this means as stated above, is that the function will execute, pause execution and resume at some point in time.</source>
          <target state="translated">이 코드는 메인 스레드를 차단하지 않고 장기 실행 작업을 시작합니다. &lt;code&gt;preparePost&lt;/code&gt; 는 불리는 무슨이다 &lt;code&gt;suspendable function&lt;/code&gt; 따라서 키워드가 &lt;code&gt;suspend&lt;/code&gt; 붙임. 위에서 언급 한 바와 같이이 기능은 특정 시점에서 함수가 실행, 실행 일시 중지 및 재개됩니다.</target>
        </trans-unit>
        <trans-unit id="940a39107db356b9719bbf9342038d41ba48b8c2" translate="yes" xml:space="preserve">
          <source>This code works slower, but we still don't get &quot;Counter = 100000&quot; at the end, because volatile variables guarantee linearizable (this is a technical term for &quot;atomic&quot;) reads and writes to the corresponding variable, but do not provide atomicity of larger actions (increment in our case).</source>
          <target state="translated">이 코드는 느리게 작동하지만 휘발성 변수는 선형화 가능 ( &quot;원자&quot;의 기술적 용어 임) 읽기와 쓰기를 보장하지만 원 자성을 제공하지 않기 때문에 끝에 &quot;카운터 = 100000&quot;을 얻지 못합니다. 더 큰 행동 (우리의 경우 증가).</target>
        </trans-unit>
        <trans-unit id="19e35196b450d82e8abc869e0b8d2aedd7f24d49" translate="yes" xml:space="preserve">
          <source>This code works very slowly, because it does &lt;em&gt;fine-grained&lt;/em&gt; thread-confinement. Each individual increment switches from multi-threaded &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-dispatchers/-default.html&quot;&gt;Dispatchers.Default&lt;/a&gt; context to the single-threaded context using &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/with-context.html&quot;&gt;withContext(counterContext)&lt;/a&gt; block.</source>
          <target state="translated">이 코드는 &lt;em&gt;세분화 된&lt;/em&gt; 스레드 조합을 수행하기 때문에 매우 느리게 작동합니다 . 각 개별 증분은 다중 스레드 &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-dispatchers/-default.html&quot;&gt;디스패처&lt;/a&gt; 에서 &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/with-context.html&quot;&gt;withContext (counterContext)&lt;/a&gt; 블록을 사용하여 기본 스레드를 단일 스레드 컨텍스트로 전환 합니다.</target>
        </trans-unit>
        <trans-unit id="d15be2d04edeeec0e153a44e5ef98d0f0d439b37" translate="yes" xml:space="preserve">
          <source>This collection has size of &lt;code&gt;groupCount + 1&lt;/code&gt; where &lt;code&gt;groupCount&lt;/code&gt; is the count of groups in the regular expression. Groups are indexed from 1 to &lt;code&gt;groupCount&lt;/code&gt; and group with the index 0 corresponds to the entire match.</source>
          <target state="translated">이 컬렉션의 크기는 &lt;code&gt;groupCount + 1&lt;/code&gt; 여기서 &lt;code&gt;groupCount&lt;/code&gt; 는 정규식의 그룹 수입니다. 그룹은 1에서 &lt;code&gt;groupCount&lt;/code&gt; 로 색인화되며 색인이 0 인 그룹은 전체 일치 항목에 해당합니다.</target>
        </trans-unit>
        <trans-unit id="c28fcaf55859958d617c24c43acf5fe9a19ed1ae" translate="yes" xml:space="preserve">
          <source>This command will produce a &lt;code&gt;png.klib&lt;/code&gt; compiled library and &lt;code&gt;png-build/kotlin&lt;/code&gt; directory containing Kotlin source code for the library.</source>
          <target state="translated">이 명령은 &lt;code&gt;png.klib&lt;/code&gt; 컴파일 라이브러리와 라이브러리의 Kotlin 소스 코드를 포함하는 &lt;code&gt;png-build/kotlin&lt;/code&gt; 디렉토리를 생성합니다.</target>
        </trans-unit>
        <trans-unit id="31a6ce4f29e9c4d59e89de3b53b3a11728189b63" translate="yes" xml:space="preserve">
          <source>This contract specifies that:</source>
          <target state="translated">이 계약은 다음을 지정합니다.</target>
        </trans-unit>
        <trans-unit id="d6dc362cdb3af439d7414c31776e978f9f9881cd" translate="yes" xml:space="preserve">
          <source>This convention, along with &lt;a href=&quot;#passing-a-lambda-to-the-last-parameter&quot;&gt;passing a lambda expression outside parentheses&lt;/a&gt;, allows for &lt;a href=&quot;http://msdn.microsoft.com/en-us/library/bb308959.aspx&quot;&gt;LINQ-style&lt;/a&gt; code:</source>
          <target state="translated">이 규칙은 &lt;a href=&quot;#passing-a-lambda-to-the-last-parameter&quot;&gt;괄호 외부에 람다 식&lt;/a&gt; 을 전달하는 것과 함께 &lt;a href=&quot;http://msdn.microsoft.com/en-us/library/bb308959.aspx&quot;&gt;LINQ 스타일&lt;/a&gt; 코드를 허용 합니다.</target>
        </trans-unit>
        <trans-unit id="78e5afd48b07123042fcce6bdde782478e4769ee" translate="yes" xml:space="preserve">
          <source>This could be an issue for Java-interoperability, so Kotlin 1.3 introduces the &lt;code&gt;@JvmDefault&lt;/code&gt; annotation. Methods, annotated with this annotation will be generated as &lt;code&gt;default&lt;/code&gt; methods for JVM:</source>
          <target state="translated">이것은 Java 상호 운용성에 문제가 될 수 있으므로 Kotlin 1.3에는 &lt;code&gt;@JvmDefault&lt;/code&gt; 주석이 도입되었습니다 . 이 주석으로 주석이 달린 메소드는 JVM의 &lt;code&gt;default&lt;/code&gt; 메소드 로 생성됩니다 .</target>
        </trans-unit>
        <trans-unit id="b179e178b1137230407a1019e7d8b4984a1d071b" translate="yes" xml:space="preserve">
          <source>This creates the &lt;code&gt;kotlin&lt;/code&gt; extension at the top level. You can then access it in the build script for:</source>
          <target state="translated">이것은 최상위 레벨에서 &lt;code&gt;kotlin&lt;/code&gt; 확장을 만듭니다 . 그런 다음 빌드 스크립트에서 다음에 액세스 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="91b0596f729477e16cacda10e4665e91b4d05e3b" translate="yes" xml:space="preserve">
          <source>This document covers some details of Kotlin/Native interoperability with Swift/Objective-C.</source>
          <target state="translated">이 문서는 Swift / Objective-C와의 Kotlin / Native 상호 운용성에 대한 세부 사항을 다룹니다.</target>
        </trans-unit>
        <trans-unit id="50a7c9e10c5c72d9392130bc3068411c0b41a1c1" translate="yes" xml:space="preserve">
          <source>This document explains the structure of &lt;a href=&quot;multiplatform&quot;&gt;Kotlin multiplatform projects&lt;/a&gt; and describes how those are configured and built using Gradle.</source>
          <target state="translated">이 문서는 &lt;a href=&quot;multiplatform&quot;&gt;Kotlin 멀티 플랫폼 프로젝트&lt;/a&gt; 의 구조 와 Gradle을 사용하여 구성 및 빌드되는 방법을 설명합니다.</target>
        </trans-unit>
        <trans-unit id="21394d0363d5df965c799770727e7adbc3c6c279" translate="yes" xml:space="preserve">
          <source>This effect is specified in the &lt;code&gt;contract { }&lt;/code&gt; block by attaching a boolean expression to another &lt;a href=&quot;-simple-effect/index&quot;&gt;SimpleEffect&lt;/a&gt; effect with the function &lt;a href=&quot;-simple-effect/implies&quot;&gt;SimpleEffect.implies&lt;/a&gt;.</source>
          <target state="translated">이 효과는에 지정된 &lt;code&gt;contract { }&lt;/code&gt; 다른 부울 표현식을 부착하여 블록 &lt;a href=&quot;-simple-effect/index&quot;&gt;SimpleEffect의&lt;/a&gt; 기능과 효과 &lt;a href=&quot;-simple-effect/implies&quot;&gt;SimpleEffect.implies&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="6e955cd6c26356181a1bb5fce56a8a7425848e09" translate="yes" xml:space="preserve">
          <source>This example can be also rewritten in a more idiomatic way, using &lt;code&gt;runBlocking&lt;/code&gt; to wrap the execution of the main function:</source>
          <target state="translated">이 예제는 &lt;code&gt;runBlocking&lt;/code&gt; 을 사용 하여 주 함수의 실행을 래핑 하여보다 관용적 인 방식으로 다시 작성할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="fea137e1d1b8bae0357ac3e28f43d2dbd0615f21" translate="yes" xml:space="preserve">
          <source>This example completes in less than a second for me, but it prints some arbitrary number, because some coroutines don't finish before &lt;code&gt;main()&lt;/code&gt; prints the result. Let's fix that.</source>
          <target state="translated">이 예제는 1 초 안에 완료되지만 &lt;code&gt;main()&lt;/code&gt; 이 결과를 인쇄 하기 전에 일부 코 루틴이 끝나지 않기 때문에 임의의 숫자를 인쇄합니다. 고쳐 봅시다.</target>
        </trans-unit>
        <trans-unit id="3176985b1c6580c82570c99ec00af4e47e3fca5d" translate="yes" xml:space="preserve">
          <source>This example uses the utility function &lt;code&gt;startActivity&lt;/code&gt; creating an intent with no data and starting a new activity, which comes from the &lt;a href=&quot;https://github.com/Kotlin/anko&quot;&gt;Anko&lt;/a&gt; library. To pass some data, you can say &lt;code&gt;startActivity&amp;lt;OtherActivity&amp;gt;(&quot;KEY&quot; to &quot;VALUE&quot;)&lt;/code&gt;.</source>
          <target state="translated">이 예제는 &lt;code&gt;startActivity&lt;/code&gt; 유틸리티 함수를 사용하여 데이터가없는 인 텐트를 작성하고 &lt;a href=&quot;https://github.com/Kotlin/anko&quot;&gt;Anko&lt;/a&gt; 라이브러리 에서 제공되는 새 활동을 시작합니다 . 일부 데이터를 전달하기 위해 &lt;code&gt;startActivity&amp;lt;OtherActivity&amp;gt;(&quot;KEY&quot; to &quot;VALUE&quot;)&lt;/code&gt; 라고 말할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="6017ffad0436bb8b6025573c2ab986b658552870" translate="yes" xml:space="preserve">
          <source>This example will print &quot;c&quot;, because the extension function being called depends only on the declared type of the parameter &lt;code&gt;c&lt;/code&gt;, which is the &lt;code&gt;C&lt;/code&gt; class.</source>
          <target state="translated">호출되는 확장 기능은 매개 변수의 선언 형에 의존하기 때문에이 예제는 &quot;C&quot;를 출력합니다 &lt;code&gt;c&lt;/code&gt; 는 IS, &lt;code&gt;C&lt;/code&gt; 의 클래스입니다.</target>
        </trans-unit>
        <trans-unit id="133008c5d984069ce6a34613c275871c4f01bd7c" translate="yes" xml:space="preserve">
          <source>This extension allows to use instances of Lazy for property delegation: &lt;code&gt;val property: String by lazy { initializer }&lt;/code&gt;</source>
          <target state="translated">이 확장을 사용하면 속성 위임에 Lazy 인스턴스를 사용할 수 있습니다. &lt;code&gt;val property: String by lazy { initializer }&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="8d46e174deee6bd3f88e10604b91fb9b63428622" translate="yes" xml:space="preserve">
          <source>This extension is chosen only for invocation with old-named parameters. Replace parameter names with the same as those of &lt;a href=&quot;../kotlin/-char-sequence/sub-sequence#kotlin.CharSequence%24subSequence%28kotlin.Int%2C+kotlin.Int%29&quot;&gt;CharSequence.subSequence&lt;/a&gt;.</source>
          <target state="translated">이 확장은 이전 이름의 매개 변수를 사용한 호출에만 선택됩니다. 매개 변수 이름을 &lt;a href=&quot;../kotlin/-char-sequence/sub-sequence#kotlin.CharSequence%24subSequence%28kotlin.Int%2C+kotlin.Int%29&quot;&gt;CharSequence.subSequence&lt;/a&gt; 와 동일하게 바꾸십시오 .</target>
        </trans-unit>
        <trans-unit id="04d1f02c756f7e0904c6b3ffc69c7b6618cd5516" translate="yes" xml:space="preserve">
          <source>This extension on &lt;code&gt;Map&lt;/code&gt; returns an existing value corresponding to the given key or throws an exception, mentioning which key was not found. If the map was produced with &lt;code&gt;withDefault&lt;/code&gt;, this function will return the default value instead of throwing an exception.</source>
          <target state="translated">&lt;code&gt;Map&lt;/code&gt; 의이 확장 은 주어진 키에 해당하는 기존 값을 반환하거나 찾을 수없는 키를 언급하여 예외를 발생시킵니다. &lt;code&gt;withDefault&lt;/code&gt; 로 맵을 생성 한 경우이 함수는 예외를 발생시키는 대신 기본값을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="179023ec810ea92c988e87fc2b985af8aad37762" translate="yes" xml:space="preserve">
          <source>This feature is available since Kotlin 1.3.40.</source>
          <target state="translated">이 기능은 Kotlin 1.3.40부터 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="291f1aee064b4993bae1bca7498ed1b391616e9f" translate="yes" xml:space="preserve">
          <source>This function can be implemented to produce more precise result for &lt;a href=&quot;expm1#kotlin.math%24expm1%28kotlin.Double%29%2Fx&quot;&gt;x&lt;/a&gt; near zero.</source>
          <target state="translated">이 함수는 &lt;a href=&quot;expm1#kotlin.math%24expm1%28kotlin.Double%29%2Fx&quot;&gt;x가&lt;/a&gt; 0에 가까울수록 더 정확한 결과를 생성하도록 구현 될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="3b2cb2dc1fab6dcfdc4a04073763dbc01b226107" translate="yes" xml:space="preserve">
          <source>This function can be implemented to produce more precise result for &lt;a href=&quot;ln1p#kotlin.math%24ln1p%28kotlin.Double%29%2Fx&quot;&gt;x&lt;/a&gt; near zero.</source>
          <target state="translated">이 함수는 &lt;a href=&quot;ln1p#kotlin.math%24ln1p%28kotlin.Double%29%2Fx&quot;&gt;x가&lt;/a&gt; 0에 가까울수록 더 정확한 결과를 생성하도록 구현 될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="8ea77ed3f5037a0baac9478b8da01da4e51178e3" translate="yes" xml:space="preserve">
          <source>This function can be implemented to produce more precise result for &lt;a href=&quot;ln1p#kotlin.math%24ln1p%28kotlin.Float%29%2Fx&quot;&gt;x&lt;/a&gt; near zero.</source>
          <target state="translated">이 함수는 &lt;a href=&quot;ln1p#kotlin.math%24ln1p%28kotlin.Float%29%2Fx&quot;&gt;x가&lt;/a&gt; 0에 가까울수록 더 정확한 결과를 생성하도록 구현 될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="15d8b3c4e3fae3fdf6c4d98c18ebe217e09dc09b" translate="yes" xml:space="preserve">
          <source>This function ensures that if we see such an object during freezing attempt - freeze fails and &lt;a href=&quot;-freezing-exception/index&quot;&gt;FreezingException&lt;/a&gt; is thrown.</source>
          <target state="translated">이 함수는 동결 시도 중에 이러한 객체를 볼 경우 동결이 실패하고 &lt;a href=&quot;-freezing-exception/index&quot;&gt;FreezingException&lt;/a&gt; 이 발생하도록합니다.</target>
        </trans-unit>
        <trans-unit id="b1cc74a9da98228f1c9d06844410d709b18bb49c" translate="yes" xml:space="preserve">
          <source>This function ensures that if we see such an object during freezing attempt - freeze fails and &lt;a href=&quot;../../kotlin.native.concurrent/-freezing-exception/index&quot;&gt;FreezingException&lt;/a&gt; is thrown.</source>
          <target state="translated">이 함수는 동결 시도 중에 이러한 객체를 볼 경우 동결이 실패하고 &lt;a href=&quot;../../kotlin.native.concurrent/-freezing-exception/index&quot;&gt;FreezingException&lt;/a&gt; 이 발생하도록합니다.</target>
        </trans-unit>
        <trans-unit id="8266b16f93bf335043fb8a8f2352b33ede13a56f" translate="yes" xml:space="preserve">
          <source>This function is &lt;em&gt;unchecked&lt;/em&gt;. Repeated invocation of any resume function on the resulting continuation corrupts the state machine of the coroutine and may result in arbitrary behaviour or exception.</source>
          <target state="translated">이 기능은 &lt;em&gt;선택되어&lt;/em&gt; 있지 않습니다 . 결과 연속에서 재개 기능을 반복적으로 호출하면 코 루틴의 상태 시스템이 손상되어 임의의 동작이나 예외가 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="655c266532fc9da4c9f83fafc0352f21cfdf4913" translate="yes" xml:space="preserve">
          <source>This function is designed to be used from inside of &lt;a href=&quot;suspend-coroutine-unintercepted-or-return&quot;&gt;suspendCoroutineUninterceptedOrReturn&lt;/a&gt; to resume the execution of the suspended coroutine using a reference to the suspending function.</source>
          <target state="translated">이 함수는 &lt;a href=&quot;suspend-coroutine-unintercepted-or-return&quot;&gt;suspendCoroutineUninterceptedOrReturn&lt;/a&gt; 내부에서 사용하여 일시 중단 함수에 대한 참조를 사용하여 일시 중단 된 코 루틴 실행을 재개 하도록 설계되었습니다 .</target>
        </trans-unit>
        <trans-unit id="a73c80e70840d67f98f7e02bc949060c1aff0a7a" translate="yes" xml:space="preserve">
          <source>This function is shorthand for &lt;code&gt;fold(onSuccess = { null }, onFailure = { it })&lt;/code&gt; (see &lt;a href=&quot;../../kotlin.collections/fold&quot;&gt;fold&lt;/a&gt;).</source>
          <target state="translated">이 기능에 대한 속기 &lt;code&gt;fold(onSuccess = { null }, onFailure = { it })&lt;/code&gt; (참조 : &lt;a href=&quot;../../kotlin.collections/fold&quot;&gt;배&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="6bebf395da4954e0241f8b8cedacdd2c2c071a5d" translate="yes" xml:space="preserve">
          <source>This function is shorthand for &lt;code&gt;getOrElse { defaultValue }&lt;/code&gt; (see &lt;a href=&quot;../kotlin.collections/get-or-else&quot;&gt;getOrElse&lt;/a&gt;).</source>
          <target state="translated">이 기능에 대한 속기 &lt;code&gt;getOrElse { defaultValue }&lt;/code&gt; (참조 &lt;a href=&quot;../kotlin.collections/get-or-else&quot;&gt;getOrElse을&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="036653325111157e1e020b5f2e95ce39aee0befd" translate="yes" xml:space="preserve">
          <source>This function is shorthand for &lt;code&gt;getOrElse { null }&lt;/code&gt; (see &lt;a href=&quot;../../kotlin.collections/get-or-else&quot;&gt;getOrElse&lt;/a&gt;) or &lt;code&gt;fold(onSuccess = { it }, onFailure = { null })&lt;/code&gt; (see &lt;a href=&quot;../../kotlin.collections/fold&quot;&gt;fold&lt;/a&gt;).</source>
          <target state="translated">이 함수는 &lt;code&gt;getOrElse { null }&lt;/code&gt; ( &lt;a href=&quot;../../kotlin.collections/get-or-else&quot;&gt;getOrElse&lt;/a&gt; 참조 ) 또는 &lt;code&gt;fold(onSuccess = { it }, onFailure = { null })&lt;/code&gt; ( &lt;a href=&quot;../../kotlin.collections/fold&quot;&gt;fold&lt;/a&gt; 참조 )의 약어입니다 .</target>
        </trans-unit>
        <trans-unit id="0cd6600313d79bdb9ccb1177f047f415c30785ec" translate="yes" xml:space="preserve">
          <source>This function is shorthand for &lt;code&gt;getOrElse { throw it }&lt;/code&gt; (see &lt;a href=&quot;../kotlin.collections/get-or-else&quot;&gt;getOrElse&lt;/a&gt;).</source>
          <target state="translated">이 기능에 대한 속기 &lt;code&gt;getOrElse { throw it }&lt;/code&gt; (참조 &lt;a href=&quot;../kotlin.collections/get-or-else&quot;&gt;getOrElse을&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="2764ff2fd2235b064886b62fb3ea52722744061e" translate="yes" xml:space="preserve">
          <source>This function is supposed to copy items from one array to another. Let's try to apply it in practice:</source>
          <target state="translated">이 함수는 한 배열에서 다른 배열로 항목을 복사합니다. 실제로 적용 해 봅시다 :</target>
        </trans-unit>
        <trans-unit id="e946cda58e67ec0857646809f4c7cd966c6aa3b4" translate="yes" xml:space="preserve">
          <source>This function may simply return original &lt;a href=&quot;intercept-continuation#kotlin.coroutines.ContinuationInterceptor%24interceptContinuation%28kotlin.coroutines.Continuation%28%28kotlin.coroutines.ContinuationInterceptor.interceptContinuation.T%29%29%29%2Fcontinuation&quot;&gt;continuation&lt;/a&gt; if it does not want to intercept this particular continuation.</source>
          <target state="translated">이 함수는 이 특정 연속을 가로 채지 않으려는 경우 원래 &lt;a href=&quot;intercept-continuation#kotlin.coroutines.ContinuationInterceptor%24interceptContinuation%28kotlin.coroutines.Continuation%28%28kotlin.coroutines.ContinuationInterceptor.interceptContinuation.T%29%29%29%2Fcontinuation&quot;&gt;연속을&lt;/a&gt; 단순히 반환 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="e37e9fc156176e563d05b6de34d613400e3a03e7" translate="yes" xml:space="preserve">
          <source>This function returns unintercepted continuation. Invocation of &lt;code&gt;resume(Unit)&lt;/code&gt; starts coroutine immediately in the invoker's call stack without going through the ContinuationInterceptor that might be present in the completion's CoroutineContext. It is the invoker's responsibility to ensure that a proper invocation context is established. Note that &lt;a href=&quot;create-coroutine-unintercepted#kotlin.coroutines.intrinsics%24createCoroutineUnintercepted%28kotlin.coroutines.SuspendFunction0%28%28kotlin.coroutines.intrinsics.createCoroutineUnintercepted.T%29%29%2C+kotlin.coroutines.Continuation%28%28kotlin.coroutines.intrinsics.createCoroutineUnintercepted.T%29%29%29%2Fcompletion&quot;&gt;completion&lt;/a&gt; of this function may get invoked in an arbitrary context.</source>
          <target state="translated">이 함수는 인터셉트되지 않은 연속을 반환합니다. 의 호출 &lt;code&gt;resume(Unit)&lt;/code&gt; 시작은 완성의 CoroutineContext에있을 수있는 ContinuationInterceptor 거치지 않고 호출자의 호출 스택에서 바로 코 루틴. 적절한 호출 컨텍스트가 설정되도록하는 것은 호출자의 책임입니다. 참고 &lt;a href=&quot;create-coroutine-unintercepted#kotlin.coroutines.intrinsics%24createCoroutineUnintercepted%28kotlin.coroutines.SuspendFunction0%28%28kotlin.coroutines.intrinsics.createCoroutineUnintercepted.T%29%29%2C+kotlin.coroutines.Continuation%28%28kotlin.coroutines.intrinsics.createCoroutineUnintercepted.T%29%29%29%2Fcompletion&quot;&gt;완성&lt;/a&gt; 이 기능은 임의의 컨텍스트에서 호출받을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="83c7cfd05c8eea06ab4db27704a1d5249d155e3e" translate="yes" xml:space="preserve">
          <source>This function returns unintercepted continuation. Invocation of &lt;code&gt;resume(Unit)&lt;/code&gt; starts coroutine immediately in the invoker's call stack without going through the ContinuationInterceptor that might be present in the completion's CoroutineContext. It is the invoker's responsibility to ensure that a proper invocation context is established. Note that &lt;a href=&quot;create-coroutine-unintercepted#kotlin.coroutines.intrinsics%24createCoroutineUnintercepted%28kotlin.coroutines.SuspendFunction1%28%28kotlin.coroutines.intrinsics.createCoroutineUnintercepted.R%2C+kotlin.coroutines.intrinsics.createCoroutineUnintercepted.T%29%29%2C+kotlin.coroutines.intrinsics.createCoroutineUnintercepted.R%2C+kotlin.coroutines.Continuation%28%28kotlin.coroutines.intrinsics.createCoroutineUnintercepted.T%29%29%29%2Fcompletion&quot;&gt;completion&lt;/a&gt; of this function may get invoked in an arbitrary context.</source>
          <target state="translated">이 함수는 인터셉트되지 않은 연속을 반환합니다. 의 호출 &lt;code&gt;resume(Unit)&lt;/code&gt; 시작은 완성의 CoroutineContext에있을 수있는 ContinuationInterceptor 거치지 않고 호출자의 호출 스택에서 바로 코 루틴. 적절한 호출 컨텍스트가 설정되도록하는 것은 호출자의 책임입니다. 참고 &lt;a href=&quot;create-coroutine-unintercepted#kotlin.coroutines.intrinsics%24createCoroutineUnintercepted%28kotlin.coroutines.SuspendFunction1%28%28kotlin.coroutines.intrinsics.createCoroutineUnintercepted.R%2C+kotlin.coroutines.intrinsics.createCoroutineUnintercepted.T%29%29%2C+kotlin.coroutines.intrinsics.createCoroutineUnintercepted.R%2C+kotlin.coroutines.Continuation%28%28kotlin.coroutines.intrinsics.createCoroutineUnintercepted.T%29%29%29%2Fcompletion&quot;&gt;완성&lt;/a&gt; 이 기능은 임의의 컨텍스트에서 호출받을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c273643758adbf26e0358f1c22929439c83656d2" translate="yes" xml:space="preserve">
          <source>This function shall be used on the immediate result of &lt;a href=&quot;create-coroutine-unintercepted#kotlin.coroutines.intrinsics%24createCoroutineUnintercepted%28kotlin.coroutines.SuspendFunction0%28%28kotlin.coroutines.intrinsics.createCoroutineUnintercepted.T%29%29%2C+kotlin.coroutines.Continuation%28%28kotlin.coroutines.intrinsics.createCoroutineUnintercepted.T%29%29%29&quot;&gt;createCoroutineUnintercepted&lt;/a&gt; or &lt;a href=&quot;suspend-coroutine-unintercepted-or-return&quot;&gt;suspendCoroutineUninterceptedOrReturn&lt;/a&gt;, in which case it checks for &lt;a href=&quot;../kotlin.coroutines/-continuation-interceptor/index&quot;&gt;ContinuationInterceptor&lt;/a&gt; in the continuation's &lt;a href=&quot;../kotlin.coroutines/-continuation/context&quot;&gt;context&lt;/a&gt;, invokes &lt;a href=&quot;../kotlin.coroutines/-continuation-interceptor/intercept-continuation&quot;&gt;ContinuationInterceptor.interceptContinuation&lt;/a&gt;, caches and returns the result.</source>
          <target state="translated">이 기능의 즉각적인 결과를 사용한다 &lt;a href=&quot;create-coroutine-unintercepted#kotlin.coroutines.intrinsics%24createCoroutineUnintercepted%28kotlin.coroutines.SuspendFunction0%28%28kotlin.coroutines.intrinsics.createCoroutineUnintercepted.T%29%29%2C+kotlin.coroutines.Continuation%28%28kotlin.coroutines.intrinsics.createCoroutineUnintercepted.T%29%29%29&quot;&gt;createCoroutineUnintercepted&lt;/a&gt; 또는 &lt;a href=&quot;suspend-coroutine-unintercepted-or-return&quot;&gt;suspendCoroutineUninterceptedOrReturn&lt;/a&gt; 경우에 그 수표, &lt;a href=&quot;../kotlin.coroutines/-continuation-interceptor/index&quot;&gt;ContinuationInterceptor&lt;/a&gt; 계속 년대 &lt;a href=&quot;../kotlin.coroutines/-continuation/context&quot;&gt;상황&lt;/a&gt; , 호출 &lt;a href=&quot;../kotlin.coroutines/-continuation-interceptor/intercept-continuation&quot;&gt;ContinuationInterceptor.interceptContinuation&lt;/a&gt; , 캐시를하고 결과를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="2b0e3ac4cd4df41a67feb4ab61ba294bec022bac" translate="yes" xml:space="preserve">
          <source>This function takes one parameter named &lt;code&gt;init&lt;/code&gt;, which is itself a function. The type of the function is &lt;code&gt;HTML.() -&amp;gt; Unit&lt;/code&gt;, which is a &lt;em&gt;function type with receiver&lt;/em&gt;. This means that we need to pass an instance of type &lt;code&gt;HTML&lt;/code&gt; (a &lt;em&gt;receiver&lt;/em&gt;) to the function, and we can call members of that instance inside the function. The receiver can be accessed through the &lt;em&gt;this&lt;/em&gt; keyword:</source>
          <target state="translated">이 함수는 &lt;code&gt;init&lt;/code&gt; 라는 하나의 매개 변수를 가져옵니다 . 함수의 유형은 &lt;code&gt;HTML.() -&amp;gt; Unit&lt;/code&gt; 이며, 이는 &lt;em&gt;수신기&lt;/em&gt; 가있는 &lt;em&gt;함수 유형입니다&lt;/em&gt; . 즉, &lt;code&gt;HTML&lt;/code&gt; 유형 의 &lt;em&gt;수신자&lt;/em&gt; ( &lt;em&gt;수신자&lt;/em&gt; )를 함수 에 전달해야 하며 함수 내에서 해당 인스턴스의 멤버를 호출 할 수 있습니다. 수신자는 &lt;em&gt;다음&lt;/em&gt; 키워드를 통해 액세스 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="675aeac2a918c6d6c8b4beafdddac2cf6431511b" translate="yes" xml:space="preserve">
          <source>This illustrates several important points:</source>
          <target state="translated">이것은 몇 가지 중요한 사항을 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="42ded97c96158badfa6b51ddc24bd9a63c6cca70" translate="yes" xml:space="preserve">
          <source>This implementation doesn't provide a way to manage capacity, as backing JS array is resizeable itself. There is no speed advantage to pre-allocating array sizes in JavaScript, so this implementation does not include any of the capacity and &quot;growth increment&quot; concepts.</source>
          <target state="translated">이 구현은 백업 JS 배열 자체의 크기를 조정할 수 있으므로 용량을 관리하는 방법을 제공하지 않습니다. JavaScript에서 배열 크기를 사전 할당하는 것에는 속도 이점이 없으므로이 구현에는 용량 및 &quot;증가 증분&quot;개념이 포함되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="691ede82b3af6046b7651a9c02f4605eaa3ba130" translate="yes" xml:space="preserve">
          <source>This implementation makes no guarantees regarding the order of enumeration of &lt;a href=&quot;../-abstract-mutable-map/keys#kotlin.collections.AbstractMutableMap%24keys&quot;&gt;keys&lt;/a&gt;, &lt;a href=&quot;../-abstract-mutable-map/values#kotlin.collections.AbstractMutableMap%24values&quot;&gt;values&lt;/a&gt; and &lt;a href=&quot;entries#kotlin.collections.HashMap%24entries&quot;&gt;entries&lt;/a&gt; collections.</source>
          <target state="translated">이 구현은 , &lt;a href=&quot;../-abstract-mutable-map/keys#kotlin.collections.AbstractMutableMap%24keys&quot;&gt;키&lt;/a&gt; 의 열거 순서 , &lt;a href=&quot;../-abstract-mutable-map/values#kotlin.collections.AbstractMutableMap%24values&quot;&gt;값&lt;/a&gt; 및 &lt;a href=&quot;entries#kotlin.collections.HashMap%24entries&quot;&gt;엔트리&lt;/a&gt; 컬렉션에 대해서는 보증하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="8ddc3e7d274cee12068e4ad892df6635b0d1615a" translate="yes" xml:space="preserve">
          <source>This implementation preserves the insertion order of elements during the iteration.</source>
          <target state="translated">이 구현은 반복 동안 요소의 삽입 순서를 유지합니다.</target>
        </trans-unit>
        <trans-unit id="1edd274f6c90be7cfea12d2c044bc4232b280a23" translate="yes" xml:space="preserve">
          <source>This implicit default value is used when the original map doesn't contain a value for the key specified and a value is obtained with &lt;a href=&quot;get-value&quot;&gt;Map.getValue&lt;/a&gt; function, for example when properties are delegated to the map.</source>
          <target state="translated">이 암시 적 기본값은 원래 맵에 지정된 키 값이 &lt;a href=&quot;get-value&quot;&gt;없고 Map.getValue&lt;/a&gt; 함수 를 사용하여 값을 가져 오는 경우 (예 : 속성이 맵에 위임 될 때) 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="410788a84e729541585bfe744595e36fe672b2b8" translate="yes" xml:space="preserve">
          <source>This implies a different way to approach problems and quite a significant shift from what we're using to when writing synchronous code. One benefit as opposed to Futures is that given its ported to so many platforms, generally we can find a consistent API experience no matter what we use it, be it C#, Java, JavaScript, or any other language where Rx is available.</source>
          <target state="translated">이것은 문제에 접근하는 다른 방법과 동기 코드를 작성할 때 우리가 사용하는 것에서 상당한 변화를 의미합니다. 선물과 반대되는 이점 중 하나는 많은 플랫폼으로 포팅되어 있기 때문에 일반적으로 C #, Java, JavaScript 또는 Rx를 사용할 수있는 다른 언어에 관계없이 일관된 API 경험을 찾을 수 있다는 것입니다.</target>
        </trans-unit>
        <trans-unit id="b300e1ecd05ef9cda9c0ccf69cc9b5755628a6bd" translate="yes" xml:space="preserve">
          <source>This imposes certain risks of binary incompatibility caused by changes in the module that declares an inline function in case the calling module is not re-compiled after the change.</source>
          <target state="translated">이는 변경 후 호출 모듈이 재 컴파일되지 않은 경우 인라인 함수를 선언하는 모듈의 변경으로 인한 이진 비 호환성 위험을 초래합니다.</target>
        </trans-unit>
        <trans-unit id="1c39f73f8778c781fa84c78bdda94d474dac7b9e" translate="yes" xml:space="preserve">
          <source>This in principle feels like a much more elegant solution, but once again has several issues:</source>
          <target state="translated">이것은 원칙적으로 훨씬 더 우아한 솔루션처럼 느껴지지만 다시 한 번 몇 가지 문제가 있습니다.</target>
        </trans-unit>
        <trans-unit id="2dca6747771b3b10d5fd08415bf950f46bdea92f" translate="yes" xml:space="preserve">
          <source>This interface is implemented by floating point ranges returned by &lt;a href=&quot;../range-to&quot;&gt;Float.rangeTo&lt;/a&gt; and &lt;a href=&quot;../range-to&quot;&gt;Double.rangeTo&lt;/a&gt; operators to achieve IEEE-754 comparison order instead of total order of floating point numbers.</source>
          <target state="translated">이 인터페이스는 &lt;a href=&quot;../range-to&quot;&gt;Float.rangeTo&lt;/a&gt; 및 &lt;a href=&quot;../range-to&quot;&gt;Double.rangeTo&lt;/a&gt; 연산자가 반환 한 부동 소수점 범위에 의해 구현되어 총 부동 소수점 수 대신 IEEE-754 비교 순서를 달성합니다.</target>
        </trans-unit>
        <trans-unit id="b9b5668de562d41a3eb7fb59a1bae495ad743bbf" translate="yes" xml:space="preserve">
          <source>This interface is likely to be handled by compiler magic and shouldn't be subtyped by arbitrary classes.</source>
          <target state="translated">이 인터페이스는 컴파일러 매직에 의해 처리 될 수 있으며 임의의 클래스에 의해 서브 타입 화되어서는 안됩니다.</target>
        </trans-unit>
        <trans-unit id="60e87d87b4ef52673d6b6accbe785d16a04f37c9" translate="yes" xml:space="preserve">
          <source>This is a guide on core features of &lt;code&gt;kotlinx.coroutines&lt;/code&gt; with a series of examples, divided up into different topics.</source>
          <target state="translated">이 안내서는 여러 주제로 나뉘어 진 일련의 예제가있는 &lt;code&gt;kotlinx.coroutines&lt;/code&gt; 의 핵심 기능에 대한 안내서입니다 .</target>
        </trans-unit>
        <trans-unit id="c933ba19b81dc6ad55a2c69193b755c303d2100a" translate="yes" xml:space="preserve">
          <source>This is a little better, but we have no or little help from the powerful code completion of the IDE. It would be so much better if we could say:</source>
          <target state="translated">이것은 조금 나아지지만 IDE의 강력한 코드 완성에서 도움이 거의 또는 전혀 없습니다. 우리가 말할 수 있다면 훨씬 좋을 것입니다.</target>
        </trans-unit>
        <trans-unit id="da401b98d9be6d7ebaac9172cbd4241fbf6ba27c" translate="yes" xml:space="preserve">
          <source>This is also a way to write unit tests for suspending functions:</source>
          <target state="translated">이것은 또한 일시 중단 함수에 대한 단위 테스트를 작성하는 방법입니다.</target>
        </trans-unit>
        <trans-unit id="64ed768079e9d5cbdb933e9c19824b5132acfb30" translate="yes" xml:space="preserve">
          <source>This is an experimental API. Given a class for a compiled Kotlin lambda or a function expression, returns a &lt;a href=&quot;../-k-function/index#kotlin.reflect.KFunction&quot;&gt;KFunction&lt;/a&gt; instance providing introspection capabilities for that lambda or function expression and its parameters. Not all features are currently supported, in particular KCallable.call and KCallable.callBy will fail at the moment.</source>
          <target state="translated">이것은 실험적인 API입니다. 컴파일 된 Kotlin 람다 또는 함수 표현식에 대한 클래스가 주어지면 해당 람다 또는 함수 표현식 및 해당 매개 변수에 대한 내성 기능을 제공 하는 &lt;a href=&quot;../-k-function/index#kotlin.reflect.KFunction&quot;&gt;KFunction&lt;/a&gt; 인스턴스를 리턴합니다 . 현재 모든 기능이 지원되는 것은 아니며, 특히 KCallable.call 및 KCallable.callBy는 현재 실패합니다.</target>
        </trans-unit>
        <trans-unit id="109dcae61144497c38fcb7128f4fde954a0b0dab" translate="yes" xml:space="preserve">
          <source>This is an experimental API. Given a class for a compiled Kotlin lambda or a function expression, returns a &lt;a href=&quot;../kotlin.reflect/-k-function/index#kotlin.reflect.KFunction&quot;&gt;KFunction&lt;/a&gt; instance providing introspection capabilities for that lambda or function expression and its parameters. Not all features are currently supported, in particular KCallable.call and KCallable.callBy will fail at the moment.</source>
          <target state="translated">이것은 실험적인 API입니다. 컴파일 된 Kotlin 람다 또는 함수 표현식에 대한 클래스가 주어지면 해당 람다 또는 함수 표현식 및 해당 매개 변수에 대한 내성 기능을 제공 하는 &lt;a href=&quot;../kotlin.reflect/-k-function/index#kotlin.reflect.KFunction&quot;&gt;KFunction&lt;/a&gt; 인스턴스를 리턴합니다 . 현재 모든 기능이 지원되는 것은 아니며, 특히 KCallable.call 및 KCallable.callBy는 현재 실패합니다.</target>
        </trans-unit>
        <trans-unit id="1275ac7243b73ff90c0cce870f1cace4805d6b9b" translate="yes" xml:space="preserve">
          <source>This is an experimental API. Given a class for a compiled Kotlin lambda or a function expression, returns a &lt;a href=&quot;index#kotlin.reflect.KFunction&quot;&gt;KFunction&lt;/a&gt; instance providing introspection capabilities for that lambda or function expression and its parameters. Not all features are currently supported, in particular KCallable.call and KCallable.callBy will fail at the moment.</source>
          <target state="translated">이것은 실험적인 API입니다. 컴파일 된 Kotlin 람다 또는 함수 표현식에 대한 클래스가 주어지면 해당 람다 또는 함수 표현식 및 해당 매개 변수에 대한 내성 기능을 제공 하는 &lt;a href=&quot;index#kotlin.reflect.KFunction&quot;&gt;KFunction&lt;/a&gt; 인스턴스를 리턴합니다 . 현재 모든 기능이 지원되는 것은 아니며, 특히 KCallable.call 및 KCallable.callBy는 현재 실패합니다.</target>
        </trans-unit>
        <trans-unit id="bbf054c69a799b1f208427023936248eccf48ba6" translate="yes" xml:space="preserve">
          <source>This is because we are not inside any coroutine. We can use delay if we wrap it into &lt;code&gt;runBlocking {}&lt;/code&gt; that starts a coroutine and waits until it's done:</source>
          <target state="translated">우리는 코 루틴 안에 있지 않기 때문입니다. 코 루틴을 시작하고 완료 될 때까지 기다리는 &lt;code&gt;runBlocking {}&lt;/code&gt; 에 지연을 감쌀 경우 지연을 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="89a3c5e95e199bf51561c58886a8d92c513c9cea" translate="yes" xml:space="preserve">
          <source>This is called an &lt;em&gt;object declaration&lt;/em&gt;, and it always has a name following the &lt;em&gt;object&lt;/em&gt; keyword. Just like a variable declaration, an object declaration is not an expression, and cannot be used on the right hand side of an assignment statement.</source>
          <target state="translated">이를 &lt;em&gt;객체 선언&lt;/em&gt; 이라고하며 항상 &lt;em&gt;객체&lt;/em&gt; 키워드 뒤에 이름이 있습니다. 변수 선언과 마찬가지로 객체 선언은 표현식이 아니며 대입 문의 오른쪽에서 사용할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="0f25f0b9ab280fe3c292330ad8e1771dad21395c" translate="yes" xml:space="preserve">
          <source>This is completely legitimate Kotlin code. You can play with this code online (modify it and run in the browser) &lt;a href=&quot;https://play.kotlinlang.org/byExample/09_Kotlin_JS/06_HtmlBuilder&quot;&gt;here&lt;/a&gt;.</source>
          <target state="translated">이것은 완전히 합법적 인 Kotlin 코드입니다. 당신은 (그것을 수정하고 브라우저에서 실행) 온라인이 코드를 재생할 수 있습니다 &lt;a href=&quot;https://play.kotlinlang.org/byExample/09_Kotlin_JS/06_HtmlBuilder&quot;&gt;여기에&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="0e75165bd6c0c435e57a13f622ac0560e9f8aea5" translate="yes" xml:space="preserve">
          <source>This is equivalent to</source>
          <target state="translated">이것은</target>
        </trans-unit>
        <trans-unit id="f1b5d12f5c0ad6b8f02b5702175b995f5f4555de" translate="yes" xml:space="preserve">
          <source>This is how the package &lt;code&gt;com.example.html&lt;/code&gt; is defined (only the elements used in the example above). It builds an HTML tree. It makes heavy use of &lt;a href=&quot;extensions&quot;&gt;extension functions&lt;/a&gt; and &lt;a href=&quot;lambdas#function-literals-with-receiver&quot;&gt;lambdas with receiver&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;com.example.html&lt;/code&gt; 패키지 가 정의 된 방식입니다 (위 예에서 사용 된 요소 만). HTML 트리를 빌드합니다. &lt;a href=&quot;lambdas#function-literals-with-receiver&quot;&gt;리시버와 함께 &lt;/a&gt;&lt;a href=&quot;extensions&quot;&gt;확장 기능&lt;/a&gt; 과 람다를 많이 사용 합니다.</target>
        </trans-unit>
        <trans-unit id="eb4b287b1edf1ba23dd84510aa2e475b62f2bf92" translate="yes" xml:space="preserve">
          <source>This is how the same function looks without the standard library functions:</source>
          <target state="translated">표준 라이브러리 함수없이 동일한 함수가 보이는 방식입니다.</target>
        </trans-unit>
        <trans-unit id="be45b011252e2fb8cf7402a94a29a95e7994751a" translate="yes" xml:space="preserve">
          <source>This is not applicable when you compile your Kotlin module to JavaScript module (see &lt;a href=&quot;js-modules&quot;&gt;JavaScript Modules&lt;/a&gt; for more information on this). In this case there won't be a wrapper object, instead, declarations will be exposed as a JavaScript module of a corresponding kind. For example, in case of CommonJS you should write:</source>
          <target state="translated">Kotlin 모듈을 JavaScript 모듈로 컴파일 할 때는 적용 할 수 없습니다 ( 자세한 내용 은 &lt;a href=&quot;js-modules&quot;&gt;JavaScript 모듈&lt;/a&gt; 참조 ). 이 경우 래퍼 객체가 없으므로 선언이 해당 종류의 JavaScript 모듈로 노출됩니다. 예를 들어, CommonJS의 경우 다음을 작성해야합니다.</target>
        </trans-unit>
        <trans-unit id="16ae8412e011bd154f0f6ed0d14afcc433a50b3b" translate="yes" xml:space="preserve">
          <source>This is not required when using Kotlin Gradle plugin 1.1.1 and above with the &lt;a href=&quot;https://docs.gradle.org/current/userguide/plugins.html#sec:plugins_block&quot;&gt;Gradle plugins DSL&lt;/a&gt;, and with &lt;a href=&quot;https://github.com/gradle/kotlin-dsl&quot;&gt;Gradle Kotlin DSL&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;https://docs.gradle.org/current/userguide/plugins.html#sec:plugins_block&quot;&gt;Gradle 플러그인 DSL&lt;/a&gt; 및 &lt;a href=&quot;https://github.com/gradle/kotlin-dsl&quot;&gt;Gradle Kotlin DSL&lt;/a&gt; 과 함께 Kotlin Gradle 플러그인 1.1.1 이상을 사용할 때는 필요하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="04267f944435e1968a98920e69ed6ee93ce59d4b" translate="yes" xml:space="preserve">
          <source>This is one expression in all three languages:</source>
          <target state="translated">이것은 세 언어 모두에서 하나의 표현입니다.</target>
        </trans-unit>
        <trans-unit id="6b9969b7447679a0aefde827887c1e2aff85957c" translate="yes" xml:space="preserve">
          <source>This is one expression in both Kotlin (because the first line doesn't parse on its own) and JavaScript, and doesn't parse in Python:</source>
          <target state="translated">이것은 Kotlin (첫 번째 줄은 자체적으로 구문 분석하지 않기 때문에)과 JavaScript 모두에서 하나의 표현이며 Python에서는 구문 분석하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="0e08018d2743eaf233d0fdb2fc751af52fc3dee8" translate="yes" xml:space="preserve">
          <source>This is only the beginning and a small example of Kotlin code sharing between iOS and Android (and other platforms) with Kotlin, Kotlin/Native and Kotlin multiplatform projects. The same approach works for real applications, independent of their size or complexity.</source>
          <target state="translated">이것은 Kotlin, Kotlin / Native 및 Kotlin 멀티 플랫폼 프로젝트에서 iOS와 Android (및 기타 플랫폼)간에 Kotlin 코드 공유의 시작이자 작은 예일뿐입니다. 크기 나 복잡성에 관계없이 동일한 응용 프로그램이 실제 응용 프로그램에 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="556b42ba8780522a3f90da067d375baba3a8ad1d" translate="yes" xml:space="preserve">
          <source>This is particularly important for Android developers, since the compiler can now correctly analyze generic &lt;code&gt;findViewById&lt;/code&gt; calls in Android API level 26:</source>
          <target state="translated">컴파일러는 이제 Android API 레벨 26에서 일반 &lt;code&gt;findViewById&lt;/code&gt; 호출을 올바르게 분석 할 수 있으므로 이는 Android 개발자에게 특히 중요합니다 .</target>
        </trans-unit>
        <trans-unit id="995a44882385c48d93df496a6a80eaaa6c26f44a" translate="yes" xml:space="preserve">
          <source>This is provided only for convenience; you don't have to extend this interface as long as your property delegate has methods with the same signatures.</source>
          <target state="translated">이것은 편의상 제공됩니다. 속성 대리자가 동일한 서명을 가진 메서드를 가지고 있다면이 인터페이스를 확장 할 필요가 없습니다.</target>
        </trans-unit>
        <trans-unit id="64b2fb3aa48fe9872cab0264ea29aacf2838772b" translate="yes" xml:space="preserve">
          <source>This is the JS code generated for the Kotlin code above (the &lt;code&gt;main&lt;/code&gt; function). Let's have a closer look at it.</source>
          <target state="translated">위의 Kotlin 코드에 대해 생성 된 JS 코드입니다 ( &lt;code&gt;main&lt;/code&gt; 기능). 자세히 살펴 봅시다.</target>
        </trans-unit>
        <trans-unit id="61af108c05fdc7b4a1413c5ee9cd9367a036a611" translate="yes" xml:space="preserve">
          <source>This is the fastest solution for this particular problem. It works for plain counters, collections, queues and other standard data structures and basic operations on them. However, it does not easily scale to complex state or to complex operations that do not have ready-to-use thread-safe implementations.</source>
          <target state="translated">이것이이 특정 문제에 대한 가장 빠른 해결책입니다. 일반 카운터, 수집, 대기열 및 기타 표준 데이터 구조 및 기본 작업에 사용됩니다. 그러나 즉시 사용 가능한 스레드 안전 구현이없는 복잡한 상태 또는 복잡한 작업으로 쉽게 확장 할 수는 없습니다.</target>
        </trans-unit>
        <trans-unit id="fa369ec473906917e945918ae4ca55d8b5858ee4" translate="yes" xml:space="preserve">
          <source>This is the last tutorial in the series. The first tutorial of the series is &lt;a href=&quot;mapping-primitive-data-types-from-c&quot;&gt;Mapping Primitive Data Types from C&lt;/a&gt;. There are also &lt;a href=&quot;mapping-struct-union-types-from-c&quot;&gt;Mapping Struct and Union Types from C&lt;/a&gt; and &lt;a href=&quot;mapping-function-pointers-from-c&quot;&gt;Mapping Function Pointers from C&lt;/a&gt; tutorials.</source>
          <target state="translated">이 시리즈의 마지막 튜토리얼입니다. 이 시리즈의 첫 번째 튜토리얼은 &lt;a href=&quot;mapping-primitive-data-types-from-c&quot;&gt;C의 기본 데이터 유형 매핑&lt;/a&gt; 입니다. 도 있습니다 &lt;a href=&quot;mapping-struct-union-types-from-c&quot;&gt;C에서 매핑 구조체 및 연합 유형&lt;/a&gt; 및 &lt;a href=&quot;mapping-function-pointers-from-c&quot;&gt;C의에서 매핑 함수 포인터&lt;/a&gt; 자습서.</target>
        </trans-unit>
        <trans-unit id="db342e5eb9179bc09fc429165b10a1574cb68d62" translate="yes" xml:space="preserve">
          <source>This is the main feature of inline classes, which inspired the name &quot;inline&quot;: data of the class is &quot;inlined&quot; into its usages (similar to how content of &lt;a href=&quot;inline-functions&quot;&gt;inline functions&lt;/a&gt; is inlined to call sites).</source>
          <target state="translated">이것은 인라인 클래스의 주요 기능으로, &quot;인라인&quot;이라는 이름에서 영감을 얻었습니다. 클래스의 데이터는 사용법에 &quot;인라인&quot;되어 있습니다 ( &lt;a href=&quot;inline-functions&quot;&gt;인라인 함수의&lt;/a&gt; 내용이 인라인 사이트를 호출 하는 방식과 유사 ).</target>
        </trans-unit>
        <trans-unit id="e191f2b52800fbe76b7db487772b3a907bdf44b0" translate="yes" xml:space="preserve">
          <source>This is the second post in the series. The very first tutorial of the series is &lt;a href=&quot;mapping-primitive-data-types-from-c&quot;&gt;Mapping Primitive Data Types from C&lt;/a&gt;. There are also the &lt;a href=&quot;mapping-function-pointers-from-c&quot;&gt;Mapping Function Pointers from C&lt;/a&gt; and &lt;a href=&quot;mapping-strings-from-c&quot;&gt;Mapping Strings from C&lt;/a&gt; tutorials.</source>
          <target state="translated">이 시리즈의 두 번째 게시물입니다. 이 시리즈의 첫 번째 튜토리얼은 &lt;a href=&quot;mapping-primitive-data-types-from-c&quot;&gt;C의 기본 데이터 유형 매핑&lt;/a&gt; 입니다. &lt;a href=&quot;mapping-function-pointers-from-c&quot;&gt;C&lt;/a&gt; 의 Mapping Function Pointer 와 &lt;a href=&quot;mapping-strings-from-c&quot;&gt;C&lt;/a&gt; 자습서의 Mapping Strings도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="9d714ceb3667c2a2d840d8a543c7e66ce3d058a3" translate="yes" xml:space="preserve">
          <source>This is the third post in the series. The very first tutorial is &lt;a href=&quot;mapping-primitive-data-types-from-c&quot;&gt;Mapping Primitive Data Types from C&lt;/a&gt;. There are also &lt;a href=&quot;mapping-struct-union-types-from-c&quot;&gt;Mapping Struct and Union Types from C&lt;/a&gt; and &lt;a href=&quot;mapping-strings-from-c&quot;&gt;Mapping Strings from C&lt;/a&gt; tutorials.</source>
          <target state="translated">이 시리즈의 세 번째 게시물입니다. 첫 번째 튜토리얼은 &lt;a href=&quot;mapping-primitive-data-types-from-c&quot;&gt;C의 기본 데이터 유형 매핑&lt;/a&gt; 입니다. 도 있습니다 &lt;a href=&quot;mapping-struct-union-types-from-c&quot;&gt;C에서 매핑 구조체 및 연합 유형&lt;/a&gt; 및 &lt;a href=&quot;mapping-strings-from-c&quot;&gt;C의에서 매핑 문자열&lt;/a&gt; 자습서.</target>
        </trans-unit>
        <trans-unit id="f2ad8f555f0fd0b81fe583ef82f57587da754391" translate="yes" xml:space="preserve">
          <source>This is twice as fast, because we have concurrent execution of two coroutines. Note that concurrency with coroutines is always explicit.</source>
          <target state="translated">우리는 두 개의 코 루틴을 동시에 실행하기 때문에 두 배 빠릅니다. 코 루틴과의 동시성은 항상 명시 적입니다.</target>
        </trans-unit>
        <trans-unit id="92b4fd5ae8a5154b1a5e18bb911000880c41554c" translate="yes" xml:space="preserve">
          <source>This lets Android Studio know that the kotlin directory is a source root, so when the project model is loaded into the IDE it will be properly recognized. Alternatively, you can put Kotlin classes in the Java source directory, typically located in &lt;code&gt;src/main/java&lt;/code&gt;.</source>
          <target state="translated">이를 통해 Android Studio는 kotlin 디렉토리가 소스 루트임을 알 수 있으므로 프로젝트 모델이 IDE에로드 될 때 올바르게 인식됩니다. 또는 Kotlin 클래스를 Java 소스 디렉토리 (일반적으로 &lt;code&gt;src/main/java&lt;/code&gt; 에 있음)에 넣을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="736ca34cfc08c91c8fd20715eb24479a73c79bdf" translate="yes" xml:space="preserve">
          <source>This library is published to Bintray JCenter repository, so let us add it:</source>
          <target state="translated">이 라이브러리는 Bintray JCenter 리포지토리에 게시되므로 다음과 같이 추가하십시오.</target>
        </trans-unit>
        <trans-unit id="898c5a35f84b96626909c79797c0f501c038d6e4" translate="yes" xml:space="preserve">
          <source>This list has size of &lt;code&gt;groupCount + 1&lt;/code&gt; where &lt;code&gt;groupCount&lt;/code&gt; is the count of groups in the regular expression. Groups are indexed from 1 to &lt;code&gt;groupCount&lt;/code&gt; and group with the index 0 corresponds to the entire match.</source>
          <target state="translated">이 목록의 크기는 &lt;code&gt;groupCount + 1&lt;/code&gt; 여기서 &lt;code&gt;groupCount&lt;/code&gt; 는 정규식의 그룹 수입니다. 그룹은 1에서 &lt;code&gt;groupCount&lt;/code&gt; 로 색인화되며 색인이 0 인 그룹은 전체 일치 항목에 해당합니다.</target>
        </trans-unit>
        <trans-unit id="4bdb3ec74f6932b33fd8d2d9d59b4f6dd5cdc88a" translate="yes" xml:space="preserve">
          <source>This marker distinguishes the experimental contract declaration API and is used to opt-in for that feature when declaring contracts of user functions.</source>
          <target state="translated">이 마커는 실험 계약 선언 API를 구별하며 사용자 기능 계약을 선언 할 때 해당 기능을 옵트 인하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="180f1cb299276ef1bdc5f464e18d2794e7d742af" translate="yes" xml:space="preserve">
          <source>This may be useful in the following cases:</source>
          <target state="translated">다음과 같은 경우에 유용 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="13bd4b9a1ff3829dff4d0473f506ce883108b5a3" translate="yes" xml:space="preserve">
          <source>This means that there's a library in the classpath which does not depend on the Kotlin standard library as a Gradle/Maven dependency, but is distributed in the same artifact with it (i.e. has it &lt;em&gt;bundled&lt;/em&gt;). Such a library may cause issues because standard build tools do not consider it an instance of the Kotlin standard library, thus it's not subject to the dependency version resolution mechanisms, and you can end up with several versions of the same library in the classpath. Consider contacting the authors of such a library and suggesting to use the Gradle/Maven dependency instead.</source>
          <target state="translated">이것은 클래스 경로에 Grat / Maven 의존성으로 Kotlin 표준 라이브러리에 의존하지 않지만 같은 아티팩트로 배포되는 라이브러리가 있음을 의미합니다 (즉, &lt;em&gt;번들로 묶음&lt;/em&gt; ). 이러한 라이브러리는 표준 빌드 도구가 Kotlin 표준 라이브러리의 인스턴스로 간주하지 않기 때문에 문제를 일으킬 수 있으므로 종속성 버전 확인 메커니즘이 적용되지 않으므로 클래스 경로에서 동일한 라이브러리의 여러 버전으로 끝날 수 있습니다. 이러한 라이브러리의 작성자에게 연락하여 Gradle / Maven 종속성을 대신 사용하도록 제안하십시오.</target>
        </trans-unit>
        <trans-unit id="6cde525aeab8f8f490a4ed99ff83215b05165a70" translate="yes" xml:space="preserve">
          <source>This means that you have a dependency on libraries of different versions, for example the 1.1 standard library and the 1.0 reflection library. To prevent subtle errors at runtime, we recommend you to use the same version of all Kotlin libraries. In this case, consider adding an explicit dependency on the 1.1 reflection library.</source>
          <target state="translated">즉, 1.1 표준 라이브러리 및 1.0 리플렉션 라이브러리와 같이 다른 버전의 라이브러리에 종속됩니다. 런타임시 미묘한 오류를 방지하려면 동일한 버전의 모든 Kotlin 라이브러리를 사용하는 것이 좋습니다. 이 경우 1.1 리플렉션 라이브러리에 명시 적 종속성을 추가하십시오.</target>
        </trans-unit>
        <trans-unit id="17a60d9a927ab40397189c8d1b96e5f7c53d044e" translate="yes" xml:space="preserve">
          <source>This means that you're using the Kotlin compiler 1.1 against the standard or reflection library of version 1.0. This can be handled in different ways:</source>
          <target state="translated">이것은 버전 1.0의 표준 또는 리플렉션 라이브러리에 대해 Kotlin 컴파일러 1.1을 사용하고 있음을 의미합니다. 다른 방법으로 처리 할 수 ​​있습니다.</target>
        </trans-unit>
        <trans-unit id="77369f21aef42d741a8e7d6c6dac5c006f439aba" translate="yes" xml:space="preserve">
          <source>This means you can call &lt;code&gt;myFunWithOptionalArgs&lt;/code&gt; with one required argument and two optional arguments (their default values are calculated by some JavaScript code).</source>
          <target state="translated">즉 , 하나의 필수 인수와 두 개의 선택적 인수를 사용하여 &lt;code&gt;myFunWithOptionalArgs&lt;/code&gt; 를 호출 할 수 있습니다 (기본값은 일부 JavaScript 코드로 계산 됨).</target>
        </trans-unit>
        <trans-unit id="448a85fa82c5ef71170374be3303b1bc78bb209c" translate="yes" xml:space="preserve">
          <source>This meta-annotation determines that an annotation is a part of public API and therefore should be included in the generated documentation for the element to which the annotation is applied.</source>
          <target state="translated">이 메타 주석은 주석이 퍼블릭 API의 일부임을 결정하므로 주석이 적용되는 요소에 대해 생성 된 문서에 포함되어야합니다.</target>
        </trans-unit>
        <trans-unit id="5c594f1e41ee531a1ebc1db1a8ef8742f5fcd14a" translate="yes" xml:space="preserve">
          <source>This meta-annotation determines that an annotation is applicable twice or more on a single code element</source>
          <target state="translated">이 메타 주석은 단일 코드 요소에 주석이 두 번 이상 적용될 수 있음을 결정합니다.</target>
        </trans-unit>
        <trans-unit id="71d0203916dcd2ae084a69342802dae5c434f881" translate="yes" xml:space="preserve">
          <source>This meta-annotation determines whether an annotation is stored in binary output and visible for reflection. By default, both are true.</source>
          <target state="translated">이 메타 주석은 주석이 이진 출력으로 저장되고 반영 될 수 있는지 여부를 결정합니다. 기본적으로 둘 다 true입니다.</target>
        </trans-unit>
        <trans-unit id="a36fadd37607b67a90a001f3c5a13ec3d8698650" translate="yes" xml:space="preserve">
          <source>This meta-annotation indicates the kinds of code elements which are possible targets of an annotation.</source>
          <target state="translated">이 메타 주석은 주석의 대상이 될 수있는 코드 요소의 종류를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="5733089c709664ede5e39a2892f4d97391a8d9f0" translate="yes" xml:space="preserve">
          <source>This method accepts values of &lt;a href=&quot;../kotlin/-short/index#kotlin.Short&quot;&gt;Short&lt;/a&gt; type in range &lt;code&gt;0x00..0xff&lt;/code&gt;, other values are prohibited.</source>
          <target state="translated">이 방법은 &lt;code&gt;0x00..0xff&lt;/code&gt; 범위 의 &lt;a href=&quot;../kotlin/-short/index#kotlin.Short&quot;&gt;Short&lt;/a&gt; 유형 값을 허용 하며 다른 값은 금지됩니다.</target>
        </trans-unit>
        <trans-unit id="a75948e2d8c32738a31fd96217f7586ee79f04f4" translate="yes" xml:space="preserve">
          <source>This method allows to use destructuring declarations when working with maps, for example:</source>
          <target state="translated">이 방법을 사용하면 맵 작업시 다음과 같은 구조적 선언을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5a64298e1d3ab705d641d81b81fea403c6aa3318" translate="yes" xml:space="preserve">
          <source>This method allows to use the &lt;code&gt;x in map&lt;/code&gt; syntax for checking whether an object is contained in the map.</source>
          <target state="translated">이 방법을 사용하면 객체가지도에 포함되어 있는지 확인하기 위해 &lt;code&gt;x in map&lt;/code&gt; 구문 에서 x 를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="96f4999c28f30d3489635a82f469652d71846c62" translate="yes" xml:space="preserve">
          <source>This method guarantees not to put the value into the map if the key is already there, but the &lt;a href=&quot;get-or-put#kotlin.collections%24getOrPut%28java.util.concurrent.ConcurrentMap%28%28kotlin.collections.getOrPut.K%2C+kotlin.collections.getOrPut.V%29%29%2C+kotlin.collections.getOrPut.K%2C+kotlin.Function0%28%28kotlin.collections.getOrPut.V%29%29%29%2FdefaultValue&quot;&gt;defaultValue&lt;/a&gt; function may be invoked even if the key is already in the map.</source>
          <target state="translated">이 메소드는 키가 이미있는 경우 값을 맵에 넣지 않도록하지만 키가 이미 맵에 있어도 &lt;a href=&quot;get-or-put#kotlin.collections%24getOrPut%28java.util.concurrent.ConcurrentMap%28%28kotlin.collections.getOrPut.K%2C+kotlin.collections.getOrPut.V%29%29%2C+kotlin.collections.getOrPut.K%2C+kotlin.Function0%28%28kotlin.collections.getOrPut.V%29%29%29%2FdefaultValue&quot;&gt;defaultValue&lt;/a&gt; 함수가 호출 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="083648bbf3b66e12f1c5e5fd3afa3ff2914dd084" translate="yes" xml:space="preserve">
          <source>This method is not recommended on huge files.</source>
          <target state="translated">이 방법은 대용량 파일에는 권장되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="ecd5e6ce22de7239fac178cb06d85481149c22bf" translate="yes" xml:space="preserve">
          <source>This method is not recommended on huge files. It has an internal limitation of 2 GB byte array size.</source>
          <target state="translated">이 방법은 대용량 파일에는 권장되지 않습니다. 내부 제한은 2GB 바이트 배열입니다.</target>
        </trans-unit>
        <trans-unit id="ecfd9cc7f27ed3b4efbb7dd03aebaf75912a636e" translate="yes" xml:space="preserve">
          <source>This method is not recommended on huge files. It has an internal limitation of 2 GB file size.</source>
          <target state="translated">이 방법은 대용량 파일에는 권장되지 않습니다. 파일 크기는 2GB로 제한됩니다.</target>
        </trans-unit>
        <trans-unit id="43901fb40d645ef2b68c677a55d2f926ea8ed530" translate="yes" xml:space="preserve">
          <source>This method is redeclared as abstract, because it's not implemented in the base class, so it must be always overridden in the concrete mutable collection implementation.</source>
          <target state="translated">이 메소드는 기본 클래스에서 구현되지 않기 때문에 추상으로 다시 선언되므로, 구체적으로 변경 가능한 콜렉션 구현에서 항상 재정의해야합니다.</target>
        </trans-unit>
        <trans-unit id="f25f95428ac465fef329ee7b3944fdbec35af43f" translate="yes" xml:space="preserve">
          <source>This mode should not be used unless the &lt;a href=&quot;../-lazy/index&quot;&gt;Lazy&lt;/a&gt; instance is guaranteed never to be initialized from more than one thread.</source>
          <target state="translated">&lt;a href=&quot;../-lazy/index&quot;&gt;Lazy&lt;/a&gt; 인스턴스가 둘 이상의 스레드에서 초기화되지 않도록 보장되지 않는 한이 모드를 사용해서는 안됩니다 .</target>
        </trans-unit>
        <trans-unit id="6446cf4cb49ffcb2caf4afcf619d26541516a151" translate="yes" xml:space="preserve">
          <source>This name can be used to access the binary:</source>
          <target state="translated">이 이름은 바이너리에 액세스하는 데 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="acb387fd4daeff721899d12634f06c3c11719a1e" translate="yes" xml:space="preserve">
          <source>This now works much faster and produces correct result.</source>
          <target state="translated">이제 훨씬 빠르게 작동하고 올바른 결과를 생성합니다.</target>
        </trans-unit>
        <trans-unit id="08d7f6ce5ec74ffd1dae5f3e2a4e554fa93562ae" translate="yes" xml:space="preserve">
          <source>This page contains the current coding style for the Kotlin language.</source>
          <target state="translated">이 페이지에는 코 틀린 언어의 현재 코딩 스타일이 포함되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="3b0d3b6a365feefc5bf2639481a27bf15df77f32" translate="yes" xml:space="preserve">
          <source>This plugin only works for Kotlin files so it is recommended to keep Kotlin and Java files separate (in case if the same project contains Java files). As with targeting the JVM, if not using the default convention, you should specify the source folder using &lt;em&gt;sourceSets&lt;/em&gt;:</source>
          <target state="translated">이 플러그인은 Kotlin 파일에서만 작동하므로 Kotlin과 Java 파일을 동일한 프로젝트에 Java 파일이 포함 된 경우 별도로 보관하는 것이 좋습니다. JVM을 대상으로하는 것처럼 기본 규칙을 사용하지 않는 경우 &lt;em&gt;sourceSets를&lt;/em&gt; 사용하여 소스 폴더를 지정해야합니다 .</target>
        </trans-unit>
        <trans-unit id="2d1dbfb5aeb4d13de4e43c69f4da833e8295308f" translate="yes" xml:space="preserve">
          <source>This podspec file can be referenced from a &lt;a href=&quot;https://guides.cocoapods.org/using/the-podfile.html&quot;&gt;Podfile&lt;/a&gt; of an Xcode project. After that the framework built from the Kotlin/Native module can be used from this Xcode project. If necessary, this framework is automatically rebuilt during Xcode build process.</source>
          <target state="translated">이 podspec 파일은 Xcode 프로젝트 의 &lt;a href=&quot;https://guides.cocoapods.org/using/the-podfile.html&quot;&gt;Podfile&lt;/a&gt; 에서 참조 할 수 있습니다 . 그 후 Kotlin / Native 모듈로 빌드 된 프레임 워크를이 Xcode 프로젝트에서 사용할 수 있습니다. 필요한 경우이 프레임 워크는 Xcode 빌드 프로세스 중에 자동으로 다시 빌드됩니다.</target>
        </trans-unit>
        <trans-unit id="30a2879d5d48273acab2ab3a9f22c1edf08032e3" translate="yes" xml:space="preserve">
          <source>This prints</source>
          <target state="translated">이것은 인쇄</target>
        </trans-unit>
        <trans-unit id="345205710c1209079bdf05b4d146f25fe0a01f36" translate="yes" xml:space="preserve">
          <source>This prints:</source>
          <target state="translated">인쇄합니다 :</target>
        </trans-unit>
        <trans-unit id="cda4b457c77664242055b4741cc46d64c55f08a1" translate="yes" xml:space="preserve">
          <source>This programming style with async functions is provided here only for illustration, because it is a popular style in other programming languages. Using this style with Kotlin coroutines is &lt;strong&gt;strongly discouraged&lt;/strong&gt; for the reasons that are explained below.</source>
          <target state="translated">비동기 함수가있는이 프로그래밍 스타일은 다른 프로그래밍 언어에서 널리 사용되는 스타일이기 때문에 여기에서는 설명을 위해서만 제공됩니다. Kotlin 코 루틴과 함께이 스타일을 사용 &lt;strong&gt;하는 것은&lt;/strong&gt; 아래 설명 된 이유로 &lt;strong&gt;권장하지 않습니다&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="77b890076daadde689d1ec3897dcc482dac8e326" translate="yes" xml:space="preserve">
          <source>This property can be used in two cases:</source>
          <target state="translated">이 속성은 두 가지 경우에 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ff03394cef9f3232cd16286e35c99b97f61a20fd" translate="yes" xml:space="preserve">
          <source>This property can't be used from normal code.</source>
          <target state="translated">이 속성은 일반 코드에서 사용할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="aec1ca1351fa183afc05654031c5fff3d664e375" translate="yes" xml:space="preserve">
          <source>This protocol is designed for comfortable updates as no project can be blocked from updating its dependencies even if it's using a slightly outdated compiler.</source>
          <target state="translated">이 프로토콜은 프로젝트가 약간 오래된 컴파일러를 사용하더라도 종속성 업데이트를 차단할 수 없으므로 편리한 업데이트를 위해 설계되었습니다.</target>
        </trans-unit>
        <trans-unit id="98a9e8bab8deee99e0e21fcb3247e8a1511740b5" translate="yes" xml:space="preserve">
          <source>This publication does not include any artifacts and only references the other publications as its variants. However, it may need the sources and documentation artifacts if that is required by the repository. In that case, add those artifacts by using &lt;a href=&quot;https://docs.gradle.org/current/javadoc/org/gradle/api/publish/maven/MavenPublication.html#artifact-java.lang.Object-&quot;&gt;&lt;code&gt;artifact(...)&lt;/code&gt;&lt;/a&gt; in the publication's scope, which is accessed as shown above.</source>
          <target state="translated">이 발행물에는 아티팩트가 포함되어 있지 않으며 다른 발행물을 해당 변형으로 만 참조합니다. 그러나 저장소에 필요한 경우 소스 및 문서 아티팩트가 필요할 수 있습니다. 이 경우 게시 범위에서 &lt;a href=&quot;https://docs.gradle.org/current/javadoc/org/gradle/api/publish/maven/MavenPublication.html#artifact-java.lang.Object-&quot;&gt; &lt;code&gt;artifact(...)&lt;/code&gt; &lt;/a&gt; 를 사용하여 위의 아티팩트를 추가하십시오 . 위의 그림과 같이 액세스됩니다.</target>
        </trans-unit>
        <trans-unit id="e2515924de7501ee2f4c68fc0b725aaaf061557d" translate="yes" xml:space="preserve">
          <source>This quickly gets unwieldy, so you will typically &lt;em&gt;import&lt;/em&gt; the symbols you need. You can import a specific symbol:</source>
          <target state="translated">이것은 다루기 어려워 지므로 일반적으로 필요한 기호를 &lt;em&gt;가져옵니다&lt;/em&gt; . 특정 심볼을 가져올 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b4727911dc96369eca10addebc256163a4abb387" translate="yes" xml:space="preserve">
          <source>This requires that the consumer's Gradle build can read Gradle module metadata, either using Gradle 5.3+ or explicitly enabling it by &lt;code&gt;enableFeaturePreview(&quot;GRADLE_METADATA&quot;)&lt;/code&gt; in &lt;code&gt;settings.gradle&lt;/code&gt;.</source>
          <target state="translated">이렇게하여 수 있도록 명시 적으로 Gradle을을 사용하여 5.3+ 또는 중, 소비자의 Gradle을 빌드 Gradle을 모듈 메타 데이터를 읽을 수 있어야 &lt;code&gt;enableFeaturePreview(&quot;GRADLE_METADATA&quot;)&lt;/code&gt; 에 &lt;code&gt;settings.gradle&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e3811c08a3b736bc78dff85189aa76ac7adf599c" translate="yes" xml:space="preserve">
          <source>This returns &lt;code&gt;b.length&lt;/code&gt; if &lt;code&gt;b&lt;/code&gt; is not null, and &lt;em&gt;null&lt;/em&gt; otherwise. The type of this expression is &lt;code&gt;Int?&lt;/code&gt;.</source>
          <target state="translated">이 반환 &lt;code&gt;b.length&lt;/code&gt; 경우 &lt;code&gt;b&lt;/code&gt; 는 null이되지 않고 &lt;em&gt;널 (null)&lt;/em&gt; 이 없습니다. 이 표현의 타입은 &lt;code&gt;Int?&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="752e46575723521dd2b0e2f3643820dd84459a5c" translate="yes" xml:space="preserve">
          <source>This runs a 1'000'000 threads each of which adds to a common counter. My patience runs out before this program completes on my machine (definitely over a minute).</source>
          <target state="translated">이것은 공통 카운터에 추가되는 1'000'000 스레드를 실행합니다. 이 프로그램이 컴퓨터에서 완료되기 전에 인내심이 없어집니다 (분당).</target>
        </trans-unit>
        <trans-unit id="86208ae33ef90a5dcb8c41ac6a075a89ce88f8d7" translate="yes" xml:space="preserve">
          <source>This section covers basic coroutine concepts.</source>
          <target state="translated">이 섹션은 기본적인 코 루틴 개념을 다룹니다.</target>
        </trans-unit>
        <trans-unit id="75d5f867c8b73c01b71e379315dc5e2a4c6f94a7" translate="yes" xml:space="preserve">
          <source>This section covers coroutine cancellation and timeouts.</source>
          <target state="translated">이 섹션에서는 코 루틴 취소 및 타임 아웃에 대해 설명합니다.</target>
        </trans-unit>
        <trans-unit id="7fd839d8f63682d12541a453824eb6d8c7ab4f81" translate="yes" xml:space="preserve">
          <source>This section covers exception handling and cancellation on exceptions. We already know that cancelled coroutine throws &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-cancellation-exception/index.html&quot;&gt;CancellationException&lt;/a&gt; in suspension points and that it is ignored by coroutines machinery. But what happens if an exception is thrown during cancellation or multiple children of the same coroutine throw an exception?</source>
          <target state="translated">이 섹션에서는 예외 처리 및 예외 취소에 대해 설명합니다. 우리는 이미 취소 된 코 루틴 이 서스펜션 포인트에서 &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-cancellation-exception/index.html&quot;&gt;CancellationException&lt;/a&gt; 을 던지고 코 루틴 기계에 의해 무시된다는 것을 이미 알고 있습니다. 그러나 취소 중에 예외가 발생하거나 동일한 코 루틴의 여러 자녀가 ​​예외를 throw하면 어떻게됩니까?</target>
        </trans-unit>
        <trans-unit id="dd1323da1dc057b96f757b1081629bfe17cfb809" translate="yes" xml:space="preserve">
          <source>This section covers various approaches to composition of suspending functions.</source>
          <target state="translated">이 섹션은 서 스펜 딩 기능의 구성에 대한 다양한 접근법을 다룹니다.</target>
        </trans-unit>
        <trans-unit id="c0b801aac5ae1a9b9aa65ed84d940a1ebfabf5c1" translate="yes" xml:space="preserve">
          <source>This self-contained jar file can be passed directly to a JRE to run your application:</source>
          <target state="translated">이 자체 포함 된 jar 파일은 JRE로 직접 전달되어 애플리케이션을 실행할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3eff95c0ad7329dd98bdd50eb833ef0910fc787b" translate="yes" xml:space="preserve">
          <source>This simplified example ensures that the JVM, JS, and Kotlin metadata publications are only uploaded when &lt;code&gt;-PisLinux=true&lt;/code&gt; is passed to the build in the command line:</source>
          <target state="translated">이 간단한 예제는 JVM, JS 및 Kotlin 메타 데이터 게시가 명령 행에서 &lt;code&gt;-PisLinux=true&lt;/code&gt; 가 빌드로 전달 될 때만 업로드 되도록합니다.</target>
        </trans-unit>
        <trans-unit id="41a51abdee059894e1c3bfb1c72642c3da8b751d" translate="yes" xml:space="preserve">
          <source>This starts a new coroutine. By default, coroutines are run on a shared pool of threads. Threads still exist in a program based on coroutines, but one thread can run many coroutines, so there's no need for too many threads.</source>
          <target state="translated">새로운 코 루틴이 시작됩니다. 기본적으로 코 루틴은 공유 스레드 풀에서 실행됩니다. 스레드는 여전히 코 루틴 기반 프로그램에 존재하지만 하나의 스레드는 많은 코 루틴을 실행할 수 있으므로 너무 많은 스레드가 필요하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="76c41d50702d4202e91d08f7ef8c0739fa6d0823" translate="yes" xml:space="preserve">
          <source>This syntax is called a &lt;em&gt;destructuring declaration&lt;/em&gt;. A destructuring declaration creates multiple variables at once. We have declared two new variables: &lt;code&gt;name&lt;/code&gt; and &lt;code&gt;age&lt;/code&gt;, and can use them independently:</source>
          <target state="translated">이 구문을 &lt;em&gt;파괴 선언&lt;/em&gt; 이라고합니다 . 파괴 선언은 한 번에 여러 변수를 만듭니다. 우리는 &lt;code&gt;name&lt;/code&gt; 과 &lt;code&gt;age&lt;/code&gt; 라는 두 가지 새로운 변수를 선언 했고 , 그것들을 독립적으로 사용할 수 있습니다 :</target>
        </trans-unit>
        <trans-unit id="530a8c17c6739ef629eabdb94246db16d43922c7" translate="yes" xml:space="preserve">
          <source>This table says that when the compiler processes, for example, an expression &lt;code&gt;+a&lt;/code&gt;, it performs the following steps:</source>
          <target state="translated">이 테이블은 컴파일러가 예를 들어 &lt;code&gt;+a&lt;/code&gt; 식을 처리 할 때 다음 단계를 수행 한다고 말합니다 .</target>
        </trans-unit>
        <trans-unit id="cca6caa135016bb5fe36c582797dd2583e1f3082" translate="yes" xml:space="preserve">
          <source>This takes about 10 seconds on my machine, so yes, coroutines do run in parallel.</source>
          <target state="translated">내 컴퓨터에서 약 10 초가 걸리므로 코 루틴이 병렬로 실행됩니다.</target>
        </trans-unit>
        <trans-unit id="215ff0a6c5e99998fdfa92a79eaf70ff28fc615e" translate="yes" xml:space="preserve">
          <source>This task copies both dependencies runtime files and the compilation output to the &lt;code&gt;web&lt;/code&gt; directory.</source>
          <target state="translated">이 태스크는 종속성 런타임 파일과 컴파일 결과를 &lt;code&gt;web&lt;/code&gt; 디렉토리에 복사합니다 .</target>
        </trans-unit>
        <trans-unit id="1a26679828d6c6d2c31183443afd2cce0f1abe38" translate="yes" xml:space="preserve">
          <source>This test will be automatically executed on the JVM target in addition to the common part.</source>
          <target state="translated">이 테스트는 공통 부분 외에 JVM 대상에서 자동으로 실행됩니다.</target>
        </trans-unit>
        <trans-unit id="422dc05df4ea784a9b658e3b358ccefed13a0844" translate="yes" xml:space="preserve">
          <source>This time we take a returned &lt;code&gt;char *&lt;/code&gt; from the &lt;code&gt;return_string&lt;/code&gt; function and turn it into a Kotlin string. For that we do the following in Kotlin:</source>
          <target state="translated">이번에 는 &lt;code&gt;return_string&lt;/code&gt; 함수 에서 반환 된 &lt;code&gt;char *&lt;/code&gt; 를 가져와 Kotlin 문자열로 바꿉니다. 이를 위해 Kotlin에서 다음을 수행합니다.</target>
        </trans-unit>
        <trans-unit id="1bc095b457022b841cd86dbdae9f7dd06a0233ca" translate="yes" xml:space="preserve">
          <source>This time we will ask a C function to write us a C string to a given buffer. The function is called &lt;code&gt;copy_string&lt;/code&gt;. It takes a pointer to the location writing characters and the allowed buffer size. The function returns something to indicate if it has succeeded or failed. Let's assume &lt;code&gt;0&lt;/code&gt; means it succeeded, and the supplied buffer was big enough:</source>
          <target state="translated">이번에는 C 함수에게 주어진 버퍼에 C 문자열을 쓰도록 요청할 것입니다. 이 함수를 &lt;code&gt;copy_string&lt;/code&gt; 이라고 합니다 . 문자를 쓰는 위치와 허용되는 버퍼 크기에 대한 포인터가 필요합니다. 이 함수는 성공 또는 실패 여부를 나타내는 것을 반환합니다. &lt;code&gt;0&lt;/code&gt; 이 성공을 의미하고 제공된 버퍼가 충분히 크다고 가정 해 봅시다 .</target>
        </trans-unit>
        <trans-unit id="95eb5f454522f97d35d22eb89071211f56ea5b5c" translate="yes" xml:space="preserve">
          <source>This tutorial describes how to use Kotlin Android Extensions to improve support for Android development.</source>
          <target state="translated">이 학습서는 Kotlin Android 확장을 사용하여 Android 개발 지원을 개선하는 방법을 설명합니다.</target>
        </trans-unit>
        <trans-unit id="54b32f69d1a441fb0920f9a2c8eb9ed0a6588065" translate="yes" xml:space="preserve">
          <source>This tutorial describes how to use in Kotlin popular Android frameworks and libraries that rely on annotation processing.</source>
          <target state="translated">이 튜토리얼에서는 주석 처리에 의존하는 Kotlin의 인기있는 Android 프레임 워크 및 라이브러리에서 사용하는 방법에 대해 설명합니다.</target>
        </trans-unit>
        <trans-unit id="98dac163941bb963709918b2eba82c9b82af15ef" translate="yes" xml:space="preserve">
          <source>This tutorial explains the basic usage of Kotlin for competitive programming.</source>
          <target state="translated">이 튜토리얼은 경쟁력있는 프로그래밍을위한 Kotlin의 기본 사용법을 설명합니다.</target>
        </trans-unit>
        <trans-unit id="d0f7acc9fd5623b0666fe34b54ba37696a87ee9a" translate="yes" xml:space="preserve">
          <source>This tutorial explains the different approaches to asynchronous programming</source>
          <target state="translated">이 튜토리얼은 비동기 프로그래밍에 대한 다양한 접근 방식을 설명합니다</target>
        </trans-unit>
        <trans-unit id="b37aa099eaa69fb3a0a9c2ea81dc57defd40be24" translate="yes" xml:space="preserve">
          <source>This tutorial is designed both for competitive programmers that did not use Kotlin before and for Kotlin developers that did not participate in any competitive programming events before. It assumes the corresponding programming skills.</source>
          <target state="translated">이 튜토리얼은 이전에 Kotlin을 사용하지 않은 경쟁 프로그래머와 이전에 경쟁 프로그래밍 이벤트에 참여하지 않은 Kotlin 개발자를 위해 설계되었습니다. 해당 프로그래밍 기술을 가정합니다.</target>
        </trans-unit>
        <trans-unit id="6ab5e488d7caf8012aa22bda0a09bdd7f98d9861" translate="yes" xml:space="preserve">
          <source>This tutorial shows how to debug a Kotlin/JS project build by Gradle. If you are using Maven or IDEA, the recipes would be similar.</source>
          <target state="translated">이 튜토리얼은 Gradle의 Kotlin / JS 프로젝트 빌드를 디버깅하는 방법을 보여줍니다. Maven 또는 IDEA를 사용하는 경우 레시피는 비슷합니다.</target>
        </trans-unit>
        <trans-unit id="f9acc149373601d8ab69e64887e6e309b360247b" translate="yes" xml:space="preserve">
          <source>This tutorial shows the ways to run Kotlin code snippets in a lightweight manner without creating or modifying the whole project.</source>
          <target state="translated">이 튜토리얼은 전체 프로젝트를 만들거나 수정하지 않고 간단한 방식으로 Kotlin 코드 스 니펫을 실행하는 방법을 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="b741e974e2ef9e2aadef771ec4ed4af6da26b1ed" translate="yes" xml:space="preserve">
          <source>This tutorial walks us through creating a Hello World application using the command line compiler.</source>
          <target state="translated">이 튜토리얼은 명령 행 컴파일러를 사용하여 Hello World 애플리케이션을 작성하는 과정을 안내합니다.</target>
        </trans-unit>
        <trans-unit id="9ef69a04e24828e3b4f1be864d64b99505227e64" translate="yes" xml:space="preserve">
          <source>This tutorial walks us through creating a Kotlin JavaScript library using the command line compiler.</source>
          <target state="translated">이 튜토리얼은 명령 행 컴파일러를 사용하여 Kotlin JavaScript 라이브러리를 작성하는 과정을 안내합니다.</target>
        </trans-unit>
        <trans-unit id="7cbf690e869df1155e9df8254a2e24065f3c7742" translate="yes" xml:space="preserve">
          <source>This tutorial walks us through creating a simple Kotlin application for Android.</source>
          <target state="translated">이 튜토리얼은 Android 용 간단한 Kotlin 응용 프로그램을 만드는 과정을 안내합니다.</target>
        </trans-unit>
        <trans-unit id="262f778d62fb1c6728a7e17683a48adb22e2c354" translate="yes" xml:space="preserve">
          <source>This tutorial walks us through setting up a project using coroutines, and writing code that uses them.</source>
          <target state="translated">이 튜토리얼은 코 루틴을 사용하여 프로젝트를 설정하고이를 사용하는 코드를 작성하는 과정을 안내합니다.</target>
        </trans-unit>
        <trans-unit id="b761f80d7daf0f57c426b6c2c8f5551348835c06" translate="yes" xml:space="preserve">
          <source>This tutorial walks us through the process of creating a simple REST controller with Spring Boot</source>
          <target state="translated">이 튜토리얼은 Spring Boot로 간단한 REST 컨트롤러를 만드는 과정을 안내합니다.</target>
        </trans-unit>
        <trans-unit id="d3c06d78974760f747dc344799aadb31e636411d" translate="yes" xml:space="preserve">
          <source>This tutorial walks us through the process of creating a simple controller using HttpServlet to display Hello World.</source>
          <target state="translated">이 튜토리얼은 HttpServlet을 사용하여 Hello World를 표시하는 간단한 컨트롤러를 만드는 프로세스를 안내합니다.</target>
        </trans-unit>
        <trans-unit id="917a46d0d52ec8a68291cefda5c1868408d5366b" translate="yes" xml:space="preserve">
          <source>This tutorial walks us through the process of using Java and Kotlin in a single IntelliJ IDEA project.</source>
          <target state="translated">이 튜토리얼에서는 단일 IntelliJ IDEA 프로젝트에서 Java 및 Kotlin을 사용하는 프로세스를 안내합니다.</target>
        </trans-unit>
        <trans-unit id="5c37cdc48efb7900f24478fb914764b4ad25e974" translate="yes" xml:space="preserve">
          <source>This tutorial walks you through a series of exercises to get familiar with Kotlin.</source>
          <target state="translated">이 튜토리얼은 Kotlin에 익숙해 지도록 일련의 연습을 안내합니다.</target>
        </trans-unit>
        <trans-unit id="fed85180abcbc65ba4b2af3d5f5d2d524508a6b7" translate="yes" xml:space="preserve">
          <source>This tutorial walks you through creating a simple Hello World application using IntelliJ IDEA.</source>
          <target state="translated">이 자습서는 IntelliJ IDEA를 사용하여 간단한 Hello World 응용 프로그램을 만드는 과정을 안내합니다.</target>
        </trans-unit>
        <trans-unit id="3a3a5550c3979eb75d3c935292c9198b690dcdbe" translate="yes" xml:space="preserve">
          <source>This tutorial walks you through the interactive learning with a set of Kotlin programming tasks.</source>
          <target state="translated">이 튜토리얼은 일련의 Kotlin 프로그래밍 작업을 통해 대화식 학습을 안내합니다.</target>
        </trans-unit>
        <trans-unit id="1922851cbe5cc3d86c3c73d15c6f4bdffb8c9675" translate="yes" xml:space="preserve">
          <source>This tutorial will walk you through creating a simple Kotlin course with a set of programming tasks and integrated tests.</source>
          <target state="translated">이 튜토리얼은 일련의 프로그래밍 작업과 통합 테스트로 간단한 Kotlin 코스를 만드는 과정을 안내합니다.</target>
        </trans-unit>
        <trans-unit id="c6030bef069b6977eab83078442b66dedd7712ad" translate="yes" xml:space="preserve">
          <source>This tutorials walks us through creating a simple Hello World application using Eclipse IDE</source>
          <target state="translated">이 튜토리얼은 Eclipse IDE를 사용하여 간단한 Hello World 애플리케이션을 작성하는 과정을 안내합니다.</target>
        </trans-unit>
        <trans-unit id="1cba3a52b4e9e49248914c3506dd87812401b394" translate="yes" xml:space="preserve">
          <source>This type is used as a receiver type of the lambda function passed to the &lt;a href=&quot;../contract&quot;&gt;contract&lt;/a&gt; function.</source>
          <target state="translated">이 유형은 &lt;a href=&quot;../contract&quot;&gt;계약&lt;/a&gt; 함수에 전달 된 람다 함수의 수신자 유형으로 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="d42addf558756322234c05ff9ff53ebc28a290b0" translate="yes" xml:space="preserve">
          <source>This value is used as a return value of &lt;a href=&quot;suspend-coroutine-or-return&quot;&gt;suspendCoroutineOrReturn&lt;/a&gt;&lt;code&gt;block&lt;/code&gt; argument to state that the execution was suspended and will not return any result immediately.</source>
          <target state="translated">이 값은 &lt;a href=&quot;suspend-coroutine-or-return&quot;&gt;suspendCoroutineOrReturn &lt;/a&gt; &lt;code&gt;block&lt;/code&gt; 인수 의 반환 값으로 사용되어 실행이 일시 중단되었으며 결과를 즉시 반환하지 않음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="f268b965a48f4655e5367448b4016e6f76edf6f0" translate="yes" xml:space="preserve">
          <source>This value is used as a return value of &lt;a href=&quot;suspend-coroutine-unintercepted-or-return&quot;&gt;suspendCoroutineUninterceptedOrReturn&lt;/a&gt;&lt;code&gt;block&lt;/code&gt; argument to state that the execution was suspended and will not return any result immediately.</source>
          <target state="translated">이 값은 &lt;a href=&quot;suspend-coroutine-unintercepted-or-return&quot;&gt;suspendCoroutineUninterceptedOrReturn &lt;/a&gt; &lt;code&gt;block&lt;/code&gt; 인수 의 반환 값으로 사용되어 실행이 일시 중단되었으며 결과를 즉시 반환하지 않음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="6e8f43b127da8dc0c4ddf32ba0afa9420b6890c9" translate="yes" xml:space="preserve">
          <source>This value needs to be smaller than &lt;a href=&quot;range-to#kotlin.ranges%24rangeTo%28kotlin.ranges.rangeTo.T%2C+kotlin.ranges.rangeTo.T%29%2Fthat&quot;&gt;that&lt;/a&gt; value, otherwise the returned range will be empty.</source>
          <target state="translated">이 값은 &lt;a href=&quot;range-to#kotlin.ranges%24rangeTo%28kotlin.ranges.rangeTo.T%2C+kotlin.ranges.rangeTo.T%29%2Fthat&quot;&gt;해당&lt;/a&gt; 값 보다 작아야 합니다 . 그렇지 않으면 반환 된 범위가 비어 있습니다.</target>
        </trans-unit>
        <trans-unit id="9a4e95d6779047f36ef44cebc8fe10ec0e5dbd2f" translate="yes" xml:space="preserve">
          <source>This way any value of type &lt;code&gt;CPointer&amp;lt;ByteVar&amp;gt;&lt;/code&gt; can be passed as an argument of &lt;code&gt;const char*&lt;/code&gt; type. If a Kotlin string should be passed, code like this could be used:</source>
          <target state="translated">이런 식으로 &lt;code&gt;CPointer&amp;lt;ByteVar&amp;gt;&lt;/code&gt; 유형의 값 을 &lt;code&gt;const char*&lt;/code&gt; 유형 의 인수로 전달할 수 있습니다 . Kotlin 문자열을 전달해야하는 경우 다음과 같은 코드를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="98a5e105dc56eeee056d102244e8a0f5fed4f0c6" translate="yes" xml:space="preserve">
          <source>This way, if something goes wrong inside the code of &lt;code&gt;concurrentSum&lt;/code&gt; function and it throws an exception, all the coroutines that were launched in its scope are cancelled.</source>
          <target state="translated">이런 식으로, &lt;code&gt;concurrentSum&lt;/code&gt; 함수 의 코드 내에서 문제 가 발생하여 예외가 발생하면 해당 범위에서 시작된 모든 코 루틴이 취소됩니다.</target>
        </trans-unit>
        <trans-unit id="f17f9d1f7410fbad939ec9e37eb14f1a6139cb16" translate="yes" xml:space="preserve">
          <source>This will apply the Gradle &lt;code&gt;java&lt;/code&gt; plugin and configure the target to cooperate with it. Note that just applying the Java plugin without specifying &lt;code&gt;withJava()&lt;/code&gt; in a JVM target will have no effect on the target.</source>
          <target state="translated">Gradle &lt;code&gt;java&lt;/code&gt; 플러그인 을 적용하고 대상과 협력하도록 구성합니다. JVM 대상에서 &lt;code&gt;withJava()&lt;/code&gt; 를 지정하지 않고 Java 플러그인을 적용해도 대상에는 영향을 미치지 않습니다.</target>
        </trans-unit>
        <trans-unit id="5e9c760291236659fa80c3cad20690354472cf0c" translate="yes" xml:space="preserve">
          <source>This will assign &lt;code&gt;x&lt;/code&gt; to &lt;code&gt;z&lt;/code&gt; if &lt;code&gt;x&lt;/code&gt; is non-null, but if it is null, the entire function that contains this expression will stop and return &lt;code&gt;y&lt;/code&gt; (this works because &lt;code&gt;return&lt;/code&gt; is also an expression, and if it is evaluated, it evaluates its argument and then makes the containing function return the result).</source>
          <target state="translated">&lt;code&gt;x&lt;/code&gt; 가 널이 아닌 경우 &lt;code&gt;x&lt;/code&gt; 에 &lt;code&gt;z&lt;/code&gt; 를 할당 하지만, 널이 아닌 경우이 표현식을 포함하는 전체 함수는 중지하고 &lt;code&gt;y&lt;/code&gt; 를 리턴합니다 ( &lt;code&gt;return&lt;/code&gt; 도 표현식 이기 때문에 작동 하며, 평가되는 경우에는이를 평가합니다). 인수를 포함하고 포함 함수가 결과를 리턴하게합니다.</target>
        </trans-unit>
        <trans-unit id="e3c6e68d7f248b58990253f88430e5ca4c4c8e2b" translate="yes" xml:space="preserve">
          <source>This will automatically implement all the interface members of &lt;code&gt;PowerSource&lt;/code&gt; in &lt;code&gt;MotorVehicle&lt;/code&gt; by invoking the same member on &lt;code&gt;engine&lt;/code&gt;. This only works for properties that are declared in the constructor.</source>
          <target state="translated">&lt;code&gt;engine&lt;/code&gt; 에서 동일한 멤버를 호출하여 &lt;code&gt;MotorVehicle&lt;/code&gt; 에서 &lt;code&gt;PowerSource&lt;/code&gt; 의 모든 인터페이스 멤버를 자동으로 구현합니다 . 생성자에서 선언 된 속성에만 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="e4c10956ebfa0383ee2f1e029c8feb69cf8fc5ac" translate="yes" xml:space="preserve">
          <source>This will raise a &lt;code&gt;ClassCastException&lt;/code&gt; if the object is not actually an instance of &lt;code&gt;Person&lt;/code&gt; or any of its subclasses. If you're not sure what &lt;code&gt;x&lt;/code&gt; is, but you're happy to get null if it's not a &lt;code&gt;Person&lt;/code&gt;, you can use &lt;code&gt;as?&lt;/code&gt;, which will return null if the cast fails. Note that the resulting type is &lt;code&gt;Person?&lt;/code&gt;:</source>
          <target state="translated">이것은 올릴 것이다 &lt;code&gt;ClassCastException&lt;/code&gt; 이 객체가 실제의 인스턴스가 아닌 경우 &lt;code&gt;Person&lt;/code&gt; 또는 그 서브 클래스의. &lt;code&gt;x&lt;/code&gt; 가 무엇인지 확실 하지 않지만 &lt;code&gt;Person&lt;/code&gt; 이 아닌 경우 null을 얻는 것이 행복하다면 다음 &lt;code&gt;as?&lt;/code&gt; 사용할 수 있습니까? 캐스트에 실패하면 null을 반환합니다. 결과 유형은 &lt;code&gt;Person?&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="fa6b2b95ad5f670c5af166fa09cb0ec4fc6be37b" translate="yes" xml:space="preserve">
          <source>This works also for &lt;em&gt;var&lt;/em&gt;&amp;rsquo;s properties if you use a &lt;code&gt;MutableMap&lt;/code&gt; instead of read-only &lt;code&gt;Map&lt;/code&gt;:</source>
          <target state="translated">읽기 전용 &lt;code&gt;Map&lt;/code&gt; 대신 &lt;code&gt;MutableMap&lt;/code&gt; 을 사용하는 경우 &lt;em&gt;var&lt;/em&gt; 의 속성 에도 작동합니다 .</target>
        </trans-unit>
        <trans-unit id="dfbae76eefb17a295e772659a5df1b063a9b20dc" translate="yes" xml:space="preserve">
          <source>Those class names are always getting in the way. We can use static imports and get this:</source>
          <target state="translated">그 클래스 이름은 항상 방해가되고 있습니다. 정적 가져 오기를 사용하여 다음을 얻을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="840686b21fe85a3d03fcebd9f6fe5d67ee5b8f5f" translate="yes" xml:space="preserve">
          <source>Though reflection may not be needed in many cases, we can still use it with a reified type parameter:</source>
          <target state="translated">대부분의 경우 리플렉션이 필요하지 않을 수도 있지만, reified type 매개 변수와 함께 계속 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="db9c8e28b5db7e794581721a97a55d403ef96db4" translate="yes" xml:space="preserve">
          <source>Thread confinement coarse-grained</source>
          <target state="translated">스레드 감금 거친</target>
        </trans-unit>
        <trans-unit id="58c8dc7270e76e9fe5dcba1621b0a309ea2a0ff5" translate="yes" xml:space="preserve">
          <source>Thread confinement fine-grained</source>
          <target state="translated">세밀한 스레드 감금</target>
        </trans-unit>
        <trans-unit id="07c0a8bbcccb40629ed6cd8852b0c2af35dea6b2" translate="yes" xml:space="preserve">
          <source>Thread-local data</source>
          <target state="translated">스레드 로컬 데이터</target>
        </trans-unit>
        <trans-unit id="b51d97d48189b14ee90ab80ab5f1002db2ed52a4" translate="yes" xml:space="preserve">
          <source>Thread-safe data structures</source>
          <target state="translated">스레드 안전 데이터 구조</target>
        </trans-unit>
        <trans-unit id="8a77bfd3db44e0aeb0a80c2f055eea2ff97f89d4" translate="yes" xml:space="preserve">
          <source>ThreadLocal</source>
          <target state="translated">ThreadLocal</target>
        </trans-unit>
        <trans-unit id="5541d0b76d127f6a3c54bbc247ffcc1b6c2bbc25" translate="yes" xml:space="preserve">
          <source>Threading</source>
          <target state="translated">Threading</target>
        </trans-unit>
        <trans-unit id="54fc24f5a7668604be098318c177c182e63b5fa7" translate="yes" xml:space="preserve">
          <source>Threads are by far probably the most well-known approach to avoid applications from blocking.</source>
          <target state="translated">스레드는 아마도 응용 프로그램의 차단을 피하는 가장 잘 알려진 방법 일 것입니다.</target>
        </trans-unit>
        <trans-unit id="c8cb6272d819adb1d7ec29aee37d20ed2b2cd093" translate="yes" xml:space="preserve">
          <source>Threads aren't always available. Some platforms, such as JavaScript do not even support threads</source>
          <target state="translated">스레드를 항상 사용할 수있는 것은 아닙니다. JavaScript와 같은 일부 플랫폼은 스레드를 지원하지 않습니다</target>
        </trans-unit>
        <trans-unit id="100ffacab3bbb22c877b7db046d6811ab68a4092" translate="yes" xml:space="preserve">
          <source>Threads aren't cheap. Threads require context switches which are costly.</source>
          <target state="translated">실은 싸지 않습니다. 스레드에는 비용이 많이 드는 컨텍스트 스위치가 필요합니다.</target>
        </trans-unit>
        <trans-unit id="ed5d4b963a60e738f823f980aab2e771fb9e0b19" translate="yes" xml:space="preserve">
          <source>Threads aren't easy. Debugging threads, avoiding race conditions are common problems we suffer in multi-threaded programming.</source>
          <target state="translated">스레드는 쉽지 않습니다. 경쟁 조건을 피하면서 스레드 디버깅은 멀티 스레드 프로그래밍에서 흔히 발생하는 문제입니다.</target>
        </trans-unit>
        <trans-unit id="dada4feb2387f68301b5e37c631ce74cff4d977a" translate="yes" xml:space="preserve">
          <source>Threads aren't infinite. The number of threads that can be launched is limited by the underlying operating system. In server-side applications, this could cause a major bottleneck.</source>
          <target state="translated">스레드는 무한하지 않습니다. 시작할 수있는 스레드 수는 기본 운영 체제에 따라 제한됩니다. 서버 측 응용 프로그램에서는 이로 인해 심각한 병목 현상이 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8abf11297f412ee4fff55514bb434f634e293565" translate="yes" xml:space="preserve">
          <source>Throwable</source>
          <target state="translated">Throwable</target>
        </trans-unit>
        <trans-unit id="eac1fd32ab840fc388b25886124b82f77d7d2760" translate="yes" xml:space="preserve">
          <source>Throwing and catching</source>
          <target state="translated">던지고 잡기</target>
        </trans-unit>
        <trans-unit id="f9f4b0f30b3f06e61b21febef173645d29891305" translate="yes" xml:space="preserve">
          <source>Throws</source>
          <target state="translated">Throws</target>
        </trans-unit>
        <trans-unit id="b1b2da4ce29be6e42fd3a3a1d87f8fd7bd99c3f3" translate="yes" xml:space="preserve">
          <source>Throws an &lt;a href=&quot;-assertion-error/index#kotlin.AssertionError&quot;&gt;AssertionError&lt;/a&gt; calculated by &lt;a href=&quot;assert#kotlin%24assert%28kotlin.Boolean%2C+kotlin.Function0%28%28kotlin.Any%29%29%29%2FlazyMessage&quot;&gt;lazyMessage&lt;/a&gt; if the &lt;a href=&quot;assert#kotlin%24assert%28kotlin.Boolean%2C+kotlin.Function0%28%28kotlin.Any%29%29%29%2Fvalue&quot;&gt;value&lt;/a&gt; is false and runtime assertions have been enabled during compilation.</source>
          <target state="translated">예외 &lt;a href=&quot;-assertion-error/index#kotlin.AssertionError&quot;&gt;AssertionError를&lt;/a&gt; 하여 계산 &lt;a href=&quot;assert#kotlin%24assert%28kotlin.Boolean%2C+kotlin.Function0%28%28kotlin.Any%29%29%29%2FlazyMessage&quot;&gt;lazyMessage을&lt;/a&gt; 경우 &lt;a href=&quot;assert#kotlin%24assert%28kotlin.Boolean%2C+kotlin.Function0%28%28kotlin.Any%29%29%29%2Fvalue&quot;&gt;값은&lt;/a&gt; false입니다 및 런타임 주장이 컴파일시 사용할 수있다.</target>
        </trans-unit>
        <trans-unit id="21712a0494f28f6a46c5535db142ea2522d8b30e" translate="yes" xml:space="preserve">
          <source>Throws an &lt;a href=&quot;-assertion-error/index#kotlin.AssertionError&quot;&gt;AssertionError&lt;/a&gt; calculated by &lt;a href=&quot;assert#kotlin%24assert%28kotlin.Boolean%2C+kotlin.Function0%28%28kotlin.Any%29%29%29%2FlazyMessage&quot;&gt;lazyMessage&lt;/a&gt; if the &lt;a href=&quot;assert#kotlin%24assert%28kotlin.Boolean%2C+kotlin.Function0%28%28kotlin.Any%29%29%29%2Fvalue&quot;&gt;value&lt;/a&gt; is false and runtime assertions have been enabled on the JVM using the &lt;em&gt;-ea&lt;/em&gt; JVM option.</source>
          <target state="translated">예외 &lt;a href=&quot;-assertion-error/index#kotlin.AssertionError&quot;&gt;AssertionError를&lt;/a&gt; 하여 계산 &lt;a href=&quot;assert#kotlin%24assert%28kotlin.Boolean%2C+kotlin.Function0%28%28kotlin.Any%29%29%29%2FlazyMessage&quot;&gt;lazyMessage을&lt;/a&gt; 경우 &lt;a href=&quot;assert#kotlin%24assert%28kotlin.Boolean%2C+kotlin.Function0%28%28kotlin.Any%29%29%29%2Fvalue&quot;&gt;값이&lt;/a&gt; 거짓이며, 런타임 주장이 사용하는 JVM에서 활성화 된 &lt;em&gt;-ea&lt;/em&gt; JVM 옵션을.</target>
        </trans-unit>
        <trans-unit id="b187627b0474be6a63105d8fbe200f08b14f46f0" translate="yes" xml:space="preserve">
          <source>Throws an &lt;a href=&quot;-assertion-error/index#kotlin.AssertionError&quot;&gt;AssertionError&lt;/a&gt; if the &lt;a href=&quot;assert#kotlin%24assert%28kotlin.Boolean%29%2Fvalue&quot;&gt;value&lt;/a&gt; is false and runtime assertions have been enabled during compilation.</source>
          <target state="translated">예외 &lt;a href=&quot;-assertion-error/index#kotlin.AssertionError&quot;&gt;않고 AssertionError를&lt;/a&gt; 경우 &lt;a href=&quot;assert#kotlin%24assert%28kotlin.Boolean%29%2Fvalue&quot;&gt;값은&lt;/a&gt; false입니다 및 런타임 주장이 컴파일시 사용할 수있다.</target>
        </trans-unit>
        <trans-unit id="d8d5a9cbb5d90075a851ac67a508560060d907ea" translate="yes" xml:space="preserve">
          <source>Throws an &lt;a href=&quot;-assertion-error/index#kotlin.AssertionError&quot;&gt;AssertionError&lt;/a&gt; if the &lt;a href=&quot;assert#kotlin%24assert%28kotlin.Boolean%29%2Fvalue&quot;&gt;value&lt;/a&gt; is false and runtime assertions have been enabled on the JVM using the &lt;em&gt;-ea&lt;/em&gt; JVM option.</source>
          <target state="translated">예외 &lt;a href=&quot;-assertion-error/index#kotlin.AssertionError&quot;&gt;않고 AssertionError를&lt;/a&gt; 경우 &lt;a href=&quot;assert#kotlin%24assert%28kotlin.Boolean%29%2Fvalue&quot;&gt;값이&lt;/a&gt; 거짓이며, 런타임 주장이 사용하는 JVM에서 활성화 된 &lt;em&gt;-ea&lt;/em&gt; JVM 옵션을.</target>
        </trans-unit>
        <trans-unit id="6495db8a536c8d755d3c31cd2f1405c6a5089dde" translate="yes" xml:space="preserve">
          <source>Throws an &lt;a href=&quot;-illegal-argument-exception/index#kotlin.IllegalArgumentException&quot;&gt;IllegalArgumentException&lt;/a&gt; if the &lt;a href=&quot;require#kotlin%24require%28kotlin.Boolean%29%2Fvalue&quot;&gt;value&lt;/a&gt; is false.</source>
          <target state="translated">예외 &lt;a href=&quot;-illegal-argument-exception/index#kotlin.IllegalArgumentException&quot;&gt;, IllegalArgumentException를&lt;/a&gt; 경우 &lt;a href=&quot;require#kotlin%24require%28kotlin.Boolean%29%2Fvalue&quot;&gt;값은&lt;/a&gt; false입니다.</target>
        </trans-unit>
        <trans-unit id="452d882ee13cc2478203bd62e2127715d9c6ce3d" translate="yes" xml:space="preserve">
          <source>Throws an &lt;a href=&quot;-illegal-argument-exception/index#kotlin.IllegalArgumentException&quot;&gt;IllegalArgumentException&lt;/a&gt; if the &lt;a href=&quot;require-not-null#kotlin%24requireNotNull%28kotlin.requireNotNull.T%29%2Fvalue&quot;&gt;value&lt;/a&gt; is null. Otherwise returns the not null value.</source>
          <target state="translated">&lt;a href=&quot;require-not-null#kotlin%24requireNotNull%28kotlin.requireNotNull.T%29%2Fvalue&quot;&gt;값&lt;/a&gt; 이 null 인 경우 &lt;a href=&quot;-illegal-argument-exception/index#kotlin.IllegalArgumentException&quot;&gt;IllegalArgumentException을&lt;/a&gt; throw합니다 . 그렇지 않으면 null이 아닌 값을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="d30f2afa782c5c47e8fd1fd37da6b472b4245324" translate="yes" xml:space="preserve">
          <source>Throws an &lt;a href=&quot;-illegal-argument-exception/index#kotlin.IllegalArgumentException&quot;&gt;IllegalArgumentException&lt;/a&gt; with the result of calling &lt;a href=&quot;require#kotlin%24require%28kotlin.Boolean%2C+kotlin.Function0%28%28kotlin.Any%29%29%29%2FlazyMessage&quot;&gt;lazyMessage&lt;/a&gt; if the &lt;a href=&quot;require#kotlin%24require%28kotlin.Boolean%2C+kotlin.Function0%28%28kotlin.Any%29%29%29%2Fvalue&quot;&gt;value&lt;/a&gt; is false.</source>
          <target state="translated">예외 &lt;a href=&quot;-illegal-argument-exception/index#kotlin.IllegalArgumentException&quot;&gt;는 IllegalArgumentException&lt;/a&gt; 호출의 결과 &lt;a href=&quot;require#kotlin%24require%28kotlin.Boolean%2C+kotlin.Function0%28%28kotlin.Any%29%29%29%2FlazyMessage&quot;&gt;lazyMessage을&lt;/a&gt; 경우 &lt;a href=&quot;require#kotlin%24require%28kotlin.Boolean%2C+kotlin.Function0%28%28kotlin.Any%29%29%29%2Fvalue&quot;&gt;값이&lt;/a&gt; 거짓입니다.</target>
        </trans-unit>
        <trans-unit id="e3e3dc9398319dc7d021d329ec499047c0ffa229" translate="yes" xml:space="preserve">
          <source>Throws an &lt;a href=&quot;-illegal-argument-exception/index#kotlin.IllegalArgumentException&quot;&gt;IllegalArgumentException&lt;/a&gt; with the result of calling &lt;a href=&quot;require-not-null#kotlin%24requireNotNull%28kotlin.requireNotNull.T%2C+kotlin.Function0%28%28kotlin.Any%29%29%29%2FlazyMessage&quot;&gt;lazyMessage&lt;/a&gt; if the &lt;a href=&quot;require-not-null#kotlin%24requireNotNull%28kotlin.requireNotNull.T%2C+kotlin.Function0%28%28kotlin.Any%29%29%29%2Fvalue&quot;&gt;value&lt;/a&gt; is null. Otherwise returns the not null value.</source>
          <target state="translated">예외 &lt;a href=&quot;-illegal-argument-exception/index#kotlin.IllegalArgumentException&quot;&gt;는 IllegalArgumentException&lt;/a&gt; 호출의 결과 &lt;a href=&quot;require-not-null#kotlin%24requireNotNull%28kotlin.requireNotNull.T%2C+kotlin.Function0%28%28kotlin.Any%29%29%29%2FlazyMessage&quot;&gt;lazyMessage을&lt;/a&gt; 경우 &lt;a href=&quot;require-not-null#kotlin%24requireNotNull%28kotlin.requireNotNull.T%2C+kotlin.Function0%28%28kotlin.Any%29%29%29%2Fvalue&quot;&gt;값이&lt;/a&gt; 널 (null)입니다. 그렇지 않으면 null이 아닌 값을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="cde80ff370e1f63acd5ebfbb8e922a017c83fe9e" translate="yes" xml:space="preserve">
          <source>Throws an &lt;a href=&quot;-illegal-state-exception/index#kotlin.IllegalStateException&quot;&gt;IllegalStateException&lt;/a&gt; if the &lt;a href=&quot;check#kotlin%24check%28kotlin.Boolean%29%2Fvalue&quot;&gt;value&lt;/a&gt; is false.</source>
          <target state="translated">예외 &lt;a href=&quot;-illegal-state-exception/index#kotlin.IllegalStateException&quot;&gt;IllegalStateException이를&lt;/a&gt; 경우 &lt;a href=&quot;check#kotlin%24check%28kotlin.Boolean%29%2Fvalue&quot;&gt;값은&lt;/a&gt; false입니다.</target>
        </trans-unit>
        <trans-unit id="402cd2d9df6a156fba6fc0cc6697b5d76b649c05" translate="yes" xml:space="preserve">
          <source>Throws an &lt;a href=&quot;-illegal-state-exception/index#kotlin.IllegalStateException&quot;&gt;IllegalStateException&lt;/a&gt; if the &lt;a href=&quot;check-not-null#kotlin%24checkNotNull%28kotlin.checkNotNull.T%29%2Fvalue&quot;&gt;value&lt;/a&gt; is null. Otherwise returns the not null value.</source>
          <target state="translated">예외 &lt;a href=&quot;-illegal-state-exception/index#kotlin.IllegalStateException&quot;&gt;IllegalStateException이를&lt;/a&gt; 경우 &lt;a href=&quot;check-not-null#kotlin%24checkNotNull%28kotlin.checkNotNull.T%29%2Fvalue&quot;&gt;값이&lt;/a&gt; null입니다. 그렇지 않으면 null이 아닌 값을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="7f113c02962407d7507fe9485b4da7237a47f7c4" translate="yes" xml:space="preserve">
          <source>Throws an &lt;a href=&quot;-illegal-state-exception/index#kotlin.IllegalStateException&quot;&gt;IllegalStateException&lt;/a&gt; with the given &lt;a href=&quot;error#kotlin%24error%28kotlin.Any%29%2Fmessage&quot;&gt;message&lt;/a&gt;.</source>
          <target state="translated">예외 &lt;a href=&quot;-illegal-state-exception/index#kotlin.IllegalStateException&quot;&gt;IllegalStateException이&lt;/a&gt; 주어진와 &lt;a href=&quot;error#kotlin%24error%28kotlin.Any%29%2Fmessage&quot;&gt;메시지를&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="a87a5cbfe4f8dd0bce93da8e99fc5031d54a4b66" translate="yes" xml:space="preserve">
          <source>Throws an &lt;a href=&quot;-illegal-state-exception/index#kotlin.IllegalStateException&quot;&gt;IllegalStateException&lt;/a&gt; with the result of calling &lt;a href=&quot;check#kotlin%24check%28kotlin.Boolean%2C+kotlin.Function0%28%28kotlin.Any%29%29%29%2FlazyMessage&quot;&gt;lazyMessage&lt;/a&gt; if the &lt;a href=&quot;check#kotlin%24check%28kotlin.Boolean%2C+kotlin.Function0%28%28kotlin.Any%29%29%29%2Fvalue&quot;&gt;value&lt;/a&gt; is false.</source>
          <target state="translated">예외 &lt;a href=&quot;-illegal-state-exception/index#kotlin.IllegalStateException&quot;&gt;IllegalStateException이&lt;/a&gt; 호출의 결과 &lt;a href=&quot;check#kotlin%24check%28kotlin.Boolean%2C+kotlin.Function0%28%28kotlin.Any%29%29%29%2FlazyMessage&quot;&gt;lazyMessage을&lt;/a&gt; 경우 &lt;a href=&quot;check#kotlin%24check%28kotlin.Boolean%2C+kotlin.Function0%28%28kotlin.Any%29%29%29%2Fvalue&quot;&gt;값이&lt;/a&gt; 거짓입니다.</target>
        </trans-unit>
        <trans-unit id="a52512f1adf6d29a59645748fabb172d879e3685" translate="yes" xml:space="preserve">
          <source>Throws an &lt;a href=&quot;-illegal-state-exception/index#kotlin.IllegalStateException&quot;&gt;IllegalStateException&lt;/a&gt; with the result of calling &lt;a href=&quot;check-not-null#kotlin%24checkNotNull%28kotlin.checkNotNull.T%2C+kotlin.Function0%28%28kotlin.Any%29%29%29%2FlazyMessage&quot;&gt;lazyMessage&lt;/a&gt; if the &lt;a href=&quot;check-not-null#kotlin%24checkNotNull%28kotlin.checkNotNull.T%2C+kotlin.Function0%28%28kotlin.Any%29%29%29%2Fvalue&quot;&gt;value&lt;/a&gt; is null. Otherwise returns the not null value.</source>
          <target state="translated">예외 &lt;a href=&quot;-illegal-state-exception/index#kotlin.IllegalStateException&quot;&gt;IllegalStateException이&lt;/a&gt; 호출의 결과 &lt;a href=&quot;check-not-null#kotlin%24checkNotNull%28kotlin.checkNotNull.T%2C+kotlin.Function0%28%28kotlin.Any%29%29%29%2FlazyMessage&quot;&gt;lazyMessage을&lt;/a&gt; 경우 생성 &lt;a href=&quot;check-not-null#kotlin%24checkNotNull%28kotlin.checkNotNull.T%2C+kotlin.Function0%28%28kotlin.Any%29%29%29%2Fvalue&quot;&gt;값이&lt;/a&gt; 널 (null)이다. 그렇지 않으면 null이 아닌 값을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="4fb093191144e508e969bd08f6b07ef13c7da6e0" translate="yes" xml:space="preserve">
          <source>Throws an exception if the sequence is constrained to be iterated once and &lt;code&gt;iterator&lt;/code&gt; is invoked the second time.</source>
          <target state="translated">시퀀스가 한 번 반복되도록 제한되고 두 번째로 &lt;code&gt;iterator&lt;/code&gt; 가 호출 되면 예외 가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="802eb217aa06b1ddcf50385d8b88823ead2d004a" translate="yes" xml:space="preserve">
          <source>Throws an exception since enum constants cannot be cloned. This method prevents enum classes from inheriting from &lt;code&gt;Cloneable&lt;/code&gt;.</source>
          <target state="translated">열거 형 상수를 복제 할 수 없으므로 예외가 발생합니다. 이 메서드는 열거 형 클래스가 &lt;code&gt;Cloneable&lt;/code&gt; 로부터 상속되지 않도록 합니다.</target>
        </trans-unit>
        <trans-unit id="abf5b40e0b4f0a5382568a99833124d4e1e46035" translate="yes" xml:space="preserve">
          <source>Thus, if the layout filename is &lt;code&gt;activity_main.xml&lt;/code&gt;, we'd import &lt;code&gt;kotlinx.android.synthetic.main.activity_main.*&lt;/code&gt;.</source>
          <target state="translated">따라서 레이아웃 파일 이름이 &lt;code&gt;activity_main.xml&lt;/code&gt; 인 경우 &lt;code&gt;kotlinx.android.synthetic.main.activity_main.*&lt;/code&gt; 를 가져옵니다 .</target>
        </trans-unit>
        <trans-unit id="97edcc8b1307ff786c44c31ec2579356e7a22d17" translate="yes" xml:space="preserve">
          <source>Thus, if you want an NPE, you can have it, but you have to ask for it explicitly, and it does not appear out of the blue.</source>
          <target state="translated">따라서 NPE를 원할 경우 NPE를 가질 수는 있지만 명시 적으로 요청해야하며 파란색으로 표시되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="dd3fb291d3a706316d022aff145e9de544011b65" translate="yes" xml:space="preserve">
          <source>Thus, single quotes can not be used to form string literals.</source>
          <target state="translated">따라서 작은 따옴표를 사용하여 문자열 리터럴을 구성 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="3018655a2f36aad6ef9ad9471b91d569410cec76" translate="yes" xml:space="preserve">
          <source>Thus, you can create something resource manager-like by creating a class that implements &lt;code&gt;Closeable&lt;/code&gt;, does its setup work in &lt;code&gt;init&lt;/code&gt;, and does its cleanup work in &lt;code&gt;close()&lt;/code&gt;.</source>
          <target state="translated">따라서 &lt;code&gt;Closeable&lt;/code&gt; 을 구현 하고 설정이 &lt;code&gt;init&lt;/code&gt; 에서 작동하며 정리가 &lt;code&gt;close()&lt;/code&gt; 에서 작동 하는 클래스를 작성하여 자원 관리자와 같은 것을 작성할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="6f717771b6bc333649ebdd74853decf5175f1649" translate="yes" xml:space="preserve">
          <source>Ticker channel is a special rendezvous channel that produces &lt;code&gt;Unit&lt;/code&gt; every time given delay passes since last consumption from this channel. Though it may seem to be useless standalone, it is a useful building block to create complex time-based &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.channels/produce.html&quot;&gt;produce&lt;/a&gt; pipelines and operators that do windowing and other time-dependent processing. Ticker channel can be used in &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.selects/select.html&quot;&gt;select&lt;/a&gt; to perform &quot;on tick&quot; action.</source>
          <target state="translated">티커 채널은 이 채널에서 마지막으로 소비 된 이후 지연 시간이 주어질 때마다 &lt;code&gt;Unit&lt;/code&gt; 를 생성하는 특수한 랑데부 채널입니다 . 쓸모없는 독립형처럼 보일 수도 있지만, 윈도 잉 및 기타 시간 종속 처리를 수행 &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.channels/produce.html&quot;&gt;하는&lt;/a&gt; 복잡한 시간 기반 생산 파이프 라인 및 운영자 를 생성하는 데 유용한 빌딩 블록 입니다. 티커 채널은 &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.selects/select.html&quot;&gt;선택시&lt;/a&gt; &quot;틱시&quot;작업을 수행 하는 데 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="709221186863e6ea184e824b11c1140ada1e2ad5" translate="yes" xml:space="preserve">
          <source>Ticker channels</source>
          <target state="translated">티커 채널</target>
        </trans-unit>
        <trans-unit id="6e9104aba3fe18e4dd8562ba5f52cb92ded067dc" translate="yes" xml:space="preserve">
          <source>TimeRanges</source>
          <target state="translated">TimeRanges</target>
        </trans-unit>
        <trans-unit id="d4c45de0fe64ac43c72a798c67faaadadfaa1b90" translate="yes" xml:space="preserve">
          <source>Timeout</source>
          <target state="translated">Timeout</target>
        </trans-unit>
        <trans-unit id="799c2191675c2bb6c5c783e298421617f1390ce2" translate="yes" xml:space="preserve">
          <source>To &lt;a href=&quot;https://blog.jetbrains.com/kotlin/2017/01/kotlin-1-1-whats-coming-in-the-standard-library/&quot;&gt;prepare for Java 9 support&lt;/a&gt;, the extension functions and properties in the &lt;code&gt;kotlin-reflect.jar&lt;/code&gt; library have been moved to the package &lt;code&gt;kotlin.reflect.full&lt;/code&gt;. The names in the old package (&lt;code&gt;kotlin.reflect&lt;/code&gt;) are deprecated and will be removed in Kotlin 1.2. Note that the core reflection interfaces (such as &lt;code&gt;KClass&lt;/code&gt;) are part of the Kotlin standard library, not &lt;code&gt;kotlin-reflect&lt;/code&gt;, and are not affected by the move.</source>
          <target state="translated">하기 위해 &lt;a href=&quot;https://blog.jetbrains.com/kotlin/2017/01/kotlin-1-1-whats-coming-in-the-standard-library/&quot;&gt;자바 (9) 지원을위한 준비&lt;/a&gt; 의의 확장 기능 및 특성 &lt;code&gt;kotlin-reflect.jar&lt;/code&gt; 라이브러리는 패키지로 이동되었습니다 &lt;code&gt;kotlin.reflect.full&lt;/code&gt; . 이전 패키지 ( &lt;code&gt;kotlin.reflect&lt;/code&gt; ) 의 이름 은 더 이상 사용되지 않으며 Kotlin 1.2에서 제거됩니다. 핵심 반사 인터페이스 (예 : &lt;code&gt;KClass&lt;/code&gt; )는 &lt;code&gt;kotlin-reflect&lt;/code&gt; 가 아닌 Kotlin 표준 라이브러리의 일부이며 이동의 영향을받지 않습니다.</target>
        </trans-unit>
        <trans-unit id="05823a5d5a74d4953764cdf3ac4c6b3fb68f1e64" translate="yes" xml:space="preserve">
          <source>To Use</source>
          <target state="translated">쓰다</target>
        </trans-unit>
        <trans-unit id="9d9e0e01bc3681e891f7f867582c90865280f877" translate="yes" xml:space="preserve">
          <source>To accept and propagate the experimental status to your whole module, compile the module with the argument &lt;code&gt;-Xexperimental=org.mylibrary.ExperimentalMarker&lt;/code&gt;. In this case, &lt;em&gt;every declaration&lt;/em&gt; in the module becomes experimental. The use of the module requires the acceptance of its experimental status as well.</source>
          <target state="translated">실험 상태를 수락하여 전체 모듈에 전파하려면 인수 &lt;code&gt;-Xexperimental=org.mylibrary.ExperimentalMarker&lt;/code&gt; 로 모듈을 컴파일하십시오 . 이 경우 모듈의 &lt;em&gt;모든 선언&lt;/em&gt; 은 실험적입니다. 모듈을 사용하려면 실험 상태도 수용해야합니다.</target>
        </trans-unit>
        <trans-unit id="c0b5cb313d227acb944e950971366b62de8d6de6" translate="yes" xml:space="preserve">
          <source>To accept the experimental status without propagation, compile the module with the argument &lt;code&gt;-Xuse-experimental&lt;/code&gt;, specifying the fully qualified name of the experimental API marker you use: &lt;code&gt;-Xuse-experimental=org.mylibrary.ExperimentalMarker&lt;/code&gt;. Compiling with this argument has the same effect as if every declaration in the module had the annotation&lt;code&gt;@UseExperimental(ExperimentalMarker::class)&lt;/code&gt;.</source>
          <target state="translated">전파하지 않고 실험 상태를 승인하려면 사용하는 실험 API 마커의 완전한 이름을 지정하여 &lt;code&gt;-Xuse-experimental&lt;/code&gt; 인수로 모듈을 컴파일하십시오 . &lt;code&gt;-Xuse-experimental=org.mylibrary.ExperimentalMarker&lt;/code&gt; . 이 인수로 컴파일하면 모듈의 모든 선언에 &lt;code&gt;@UseExperimental(ExperimentalMarker::class)&lt;/code&gt; 주석이있는 것과 같은 효과가 있습니다.</target>
        </trans-unit>
        <trans-unit id="9903a558b00c4bc82f88c2dfad1d5c92c9e2ae3f" translate="yes" xml:space="preserve">
          <source>To accept the usage of multiple experimental APIs on the module level, add one of the described arguments for each experimental API marker used in your module.</source>
          <target state="translated">모듈 레벨에서 여러 실험 API의 사용을 승인하려면 모듈에 사용 된 각 실험 API 마커에 대해 설명 된 인수 중 하나를 추가하십시오.</target>
        </trans-unit>
        <trans-unit id="d162c0174f5af87401e6b5d45d66155192832d80" translate="yes" xml:space="preserve">
          <source>To access &lt;em&gt;this&lt;/em&gt; from an outer scope (a &lt;a href=&quot;classes&quot;&gt;class&lt;/a&gt;, or &lt;a href=&quot;extensions&quot;&gt;extension function&lt;/a&gt;, or labeled &lt;a href=&quot;lambdas#function-literals-with-receiver&quot;&gt;function literal with receiver&lt;/a&gt;) we write &lt;code&gt;this@label&lt;/code&gt; where &lt;code&gt;@label&lt;/code&gt; is a &lt;a href=&quot;returns&quot;&gt;label&lt;/a&gt; on the scope &lt;em&gt;this&lt;/em&gt; is meant to be from:</source>
          <target state="translated">액세스하려면 &lt;em&gt;이&lt;/em&gt; 외부 범위 (A에서 &lt;a href=&quot;classes&quot;&gt;클래스&lt;/a&gt; , 또는 &lt;a href=&quot;extensions&quot;&gt;확장 기능&lt;/a&gt; , 또는 표시된 &lt;a href=&quot;lambdas#function-literals-with-receiver&quot;&gt;수신기 기능 리터럴은&lt;/a&gt; ) 우리는 기록 &lt;code&gt;this@label&lt;/code&gt; &lt;code&gt;@label&lt;/code&gt; 는 A는 &lt;a href=&quot;returns&quot;&gt;라벨&lt;/a&gt; 범위에 대한 &lt;em&gt;이가&lt;/em&gt; 보낸 것으로 의미를 :</target>
        </trans-unit>
        <trans-unit id="5db6557812d02b15eefb7397c674770717b897fd" translate="yes" xml:space="preserve">
          <source>To access a property that is a member of a class, we qualify it:</source>
          <target state="translated">클래스 멤버 인 속성에 액세스하려면 다음과 같이 자격을 갖습니다.</target>
        </trans-unit>
        <trans-unit id="81410d36157afd9871ba5225faca2642fb141190" translate="yes" xml:space="preserve">
          <source>To access properties as first-class objects in Kotlin, we can also use the &lt;code&gt;::&lt;/code&gt; operator:</source>
          <target state="translated">Kotlin에서 일류 객체로 속성에 액세스하기 위해 &lt;code&gt;::&lt;/code&gt; 연산자를 사용할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="58a760c627562db97cdca1a84e7db3c27c2f629c" translate="yes" xml:space="preserve">
          <source>To access static members of a Java type that is &lt;a href=&quot;#mapped-types&quot;&gt;mapped&lt;/a&gt; to a Kotlin type, use the full qualified name of the Java type: &lt;code&gt;java.lang.Integer.bitCount(foo)&lt;/code&gt;.</source>
          <target state="translated">Kotlin 유형에 &lt;a href=&quot;#mapped-types&quot;&gt;맵핑&lt;/a&gt; 된 Java 유형의 정적 멤버에 액세스하려면 Java 유형 의 완전한 이름 인 &lt;code&gt;java.lang.Integer.bitCount(foo)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7529d2d95d23cbd6b23debe45e1e3095efe982cc" translate="yes" xml:space="preserve">
          <source>To achieve &lt;code&gt;mutable XOR global&lt;/code&gt; invariant, all globally visible state (currently, &lt;code&gt;object&lt;/code&gt; singletons and enums) are automatically frozen. If object freezing is not desired, a &lt;code&gt;kotlin.native.ThreadLocal&lt;/code&gt; annotation can be used, which will make the object state thread local, and so, mutable (but the changed state is not visible to other threads).</source>
          <target state="translated">&lt;code&gt;mutable XOR global&lt;/code&gt; 불변 값 을 달성하기 위해 모든 전역 적으로 볼 수있는 상태 (현재 &lt;code&gt;object&lt;/code&gt; 싱글 톤 및 열거 형)가 자동으로 고정됩니다. 객체 동결이 필요하지 않은 경우, &lt;code&gt;kotlin.native.ThreadLocal&lt;/code&gt; 주석을 사용하여 객체 상태 스레드를 로컬로 만들 수 있으므로 변경할 수 있습니다 (그러나 변경된 상태는 다른 스레드에 표시되지 않음).</target>
        </trans-unit>
        <trans-unit id="1019a589281c0c646b20946b4cd19b5c15e8fdaa" translate="yes" xml:space="preserve">
          <source>To activate DCE tool, add the following line to &lt;code&gt;build.gradle&lt;/code&gt;:</source>
          <target state="translated">DCE 도구를 활성화하려면 &lt;code&gt;build.gradle&lt;/code&gt; 에 다음 줄을 추가하십시오 .</target>
        </trans-unit>
        <trans-unit id="a7881622441c034d7bab9ec188cf250853bf301a" translate="yes" xml:space="preserve">
          <source>To add a dependency to a source set, use a &lt;code&gt;dependencies { ... }&lt;/code&gt; block of the source sets DSL. Four kinds of dependencies are supported:</source>
          <target state="translated">소스 세트에 종속성을 추가하려면 소스 세트 DSL의 &lt;code&gt;dependencies { ... }&lt;/code&gt; 블록을 사용하십시오. 네 가지 종류의 종속성이 지원됩니다.</target>
        </trans-unit>
        <trans-unit id="1a499912e7035afeaf92f7261767aa556ac8c3f9" translate="yes" xml:space="preserve">
          <source>To add a new key-value pair to a mutable map, use &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/-mutable-map/put&quot;&gt;&lt;code&gt;put()&lt;/code&gt;&lt;/a&gt;. When a new entry is put into a &lt;code&gt;LinkedHashMap&lt;/code&gt; (the default map implementation), it is added so that it comes last when iterating the map. In sorted maps, the positions of new elements are defined by the order of their keys.</source>
          <target state="translated">변경 가능한 맵에 새 키-값 쌍을 추가하려면 &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/-mutable-map/put&quot;&gt; &lt;code&gt;put()&lt;/code&gt; &lt;/a&gt; . 새 항목을 &lt;code&gt;LinkedHashMap&lt;/code&gt; (기본 맵 구현)에 넣으면 맵을 반복 할 때 마지막에 오도록 추가됩니다. 정렬 된 맵에서 새 요소의 위치는 키 순서에 따라 정의됩니다.</target>
        </trans-unit>
        <trans-unit id="f2454f68b2510146a6d3830da5c71ddda2db8b87" translate="yes" xml:space="preserve">
          <source>To add a single element to a list or a set, use the &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/-mutable-list/add&quot;&gt;&lt;code&gt;add()&lt;/code&gt;&lt;/a&gt; function. The specified object is appended to the end of the collection.</source>
          <target state="translated">단일 요소를 목록 또는 세트에 &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/-mutable-list/add&quot;&gt; &lt;code&gt;add()&lt;/code&gt; &lt;/a&gt; 하려면 add () 함수를 사용하십시오 . 지정된 개체가 컬렉션 끝에 추가됩니다.</target>
        </trans-unit>
        <trans-unit id="7cc1110c5b9a5333f0f0fec5eb2e00b218df46d2" translate="yes" xml:space="preserve">
          <source>To add elements to a specific position in a list, use &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/-mutable-list/add&quot;&gt;&lt;code&gt;add()&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/add-all&quot;&gt;&lt;code&gt;addAll()&lt;/code&gt;&lt;/a&gt; providing the position for element insertion as an additional argument. All elements that come after the position shift to the right.</source>
          <target state="translated">목록의 특정 위치에 요소를 추가하려면 add &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/-mutable-list/add&quot;&gt; &lt;code&gt;add()&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/add-all&quot;&gt; &lt;code&gt;addAll()&lt;/code&gt; &lt;/a&gt; 을 사용하여 요소 삽입 위치를 추가 인수로 제공하십시오. 위치 뒤에 오는 모든 요소는 오른쪽으로 이동합니다.</target>
        </trans-unit>
        <trans-unit id="8035a3b6b37b3480851f2821e2b47d2393940de4" translate="yes" xml:space="preserve">
          <source>To add multiple entries at a time, use &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/put-all&quot;&gt;&lt;code&gt;putAll()&lt;/code&gt;&lt;/a&gt;. Its argument can be a &lt;code&gt;Map&lt;/code&gt; or a group of &lt;code&gt;Pair&lt;/code&gt;s: &lt;code&gt;Iterable&lt;/code&gt;, &lt;code&gt;Sequence&lt;/code&gt;, or &lt;code&gt;Array&lt;/code&gt;.</source>
          <target state="translated">한 번에 여러 항목을 추가하려면 &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/put-all&quot;&gt; &lt;code&gt;putAll()&lt;/code&gt; &lt;/a&gt; . 인수는 &lt;code&gt;Map&lt;/code&gt; 또는 &lt;code&gt;Pair&lt;/code&gt; 의 그룹 ( &lt;code&gt;Iterable&lt;/code&gt; , &lt;code&gt;Sequence&lt;/code&gt; 또는 &lt;code&gt;Array&lt;/code&gt; )일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6aac6c02c5c8182c376328758ec65c08ad1e19d6" translate="yes" xml:space="preserve">
          <source>To add the Kotlin support to your Eclipse IDE, install the &lt;em&gt;Kotlin Plugin for Eclipse&lt;/em&gt;. We recommend installing the Kotlin plugin from &lt;a href=&quot;http://marketplace.eclipse.org/content/kotlin-plugin-eclipse&quot;&gt;Eclipse Marketplace&lt;/a&gt;. One option is to drag this button into a running Eclipse window:</source>
          <target state="translated">Kotlin 지원을 Eclipse IDE에 추가하려면 &lt;em&gt;Kotlin Plugin for Eclipse를&lt;/em&gt; 설치하십시오 . &lt;a href=&quot;http://marketplace.eclipse.org/content/kotlin-plugin-eclipse&quot;&gt;Eclipse Marketplace&lt;/a&gt; 에서 Kotlin 플러그인을 설치하는 것이 좋습니다 . 한 가지 옵션은이 버튼을 실행중인 Eclipse 창으로 끌어 오는 것입니다.</target>
        </trans-unit>
        <trans-unit id="11458a551629eb8e637b1b4f455d800a9c36a1f1" translate="yes" xml:space="preserve">
          <source>To address this problem, in Kotlin 1.1 a special mechanism to control receiver scope was introduced.</source>
          <target state="translated">이 문제를 해결하기 위해 Kotlin 1.1에서는 수신기 범위를 제어하는 ​​특수 메커니즘이 도입되었습니다.</target>
        </trans-unit>
        <trans-unit id="93364070d4707402d500a207978499a9a901b72c" translate="yes" xml:space="preserve">
          <source>To allow nulls, we can declare a variable as nullable string, written &lt;code&gt;String?&lt;/code&gt;:</source>
          <target state="translated">null을 허용하기 위해 변수를 nullable 문자열로 선언하면 &lt;code&gt;String?&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="f2b28f33c9dfafdc6b47099300c488e134702926" translate="yes" xml:space="preserve">
          <source>To annotate the receiver parameter of an extension function, use the following syntax:</source>
          <target state="translated">확장 함수의 수신자 매개 변수에 주석을 달려면 다음 구문을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="27d0b2adae39bd08addf9e085ed30cd88ae2eee6" translate="yes" xml:space="preserve">
          <source>To apply a function to elements in the reverse order, use functions &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/reduce-right&quot;&gt;&lt;code&gt;reduceRight()&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/fold-right&quot;&gt;&lt;code&gt;foldRight()&lt;/code&gt;&lt;/a&gt;. They work in a way similar to &lt;code&gt;fold()&lt;/code&gt; and &lt;code&gt;reduce()&lt;/code&gt; but start from the last element and then continue to previous. Note that when folding or reducing right, the operation arguments change their order: first goes the element, and then the accumulated value.</source>
          <target state="translated">요소에 역순으로 함수를 적용하려면 &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/reduce-right&quot;&gt; &lt;code&gt;reduceRight()&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/fold-right&quot;&gt; &lt;code&gt;foldRight()&lt;/code&gt; &lt;/a&gt; 함수를 사용하십시오 . 그것들은 &lt;code&gt;fold()&lt;/code&gt; 및 &lt;code&gt;reduce()&lt;/code&gt; 와 비슷한 방식으로 작동 하지만 마지막 요소에서 시작하여 이전으로 계속합니다. 오른쪽으로 접거나 줄이면 연산 인수가 순서를 변경합니다. 먼저 요소로 이동 한 다음 누적 값으로 이동합니다.</target>
        </trans-unit>
        <trans-unit id="2a59cafd76f62ee4d0be26a47e36b2b9add63e94" translate="yes" xml:space="preserve">
          <source>To apply the &lt;code&gt;kotlin-multiplatform&lt;/code&gt; plugin, just add the following snippet into your build script:</source>
          <target state="translated">&lt;code&gt;kotlin-multiplatform&lt;/code&gt; 플러그인 을 적용하려면 빌드 스크립트에 다음 스 니펫을 추가하십시오.</target>
        </trans-unit>
        <trans-unit id="93d5ab42155015ed266c58696481bdeab9ce4844" translate="yes" xml:space="preserve">
          <source>To avoid ambiguous results when strings in &lt;a href=&quot;find-any-of#kotlin.text%24findAnyOf%28kotlin.CharSequence%2C+kotlin.collections.Collection%28%28kotlin.String%29%29%2C+kotlin.Int%2C+kotlin.Boolean%29%2Fstrings&quot;&gt;strings&lt;/a&gt; have characters in common, this method proceeds from the beginning to the end of this string, and finds at each position the first element in &lt;a href=&quot;find-any-of#kotlin.text%24findAnyOf%28kotlin.CharSequence%2C+kotlin.collections.Collection%28%28kotlin.String%29%29%2C+kotlin.Int%2C+kotlin.Boolean%29%2Fstrings&quot;&gt;strings&lt;/a&gt; that matches this string at that position.</source>
          <target state="translated">문자열 때 모호한 결과를 방지하기 위해 &lt;a href=&quot;find-any-of#kotlin.text%24findAnyOf%28kotlin.CharSequence%2C+kotlin.collections.Collection%28%28kotlin.String%29%29%2C+kotlin.Int%2C+kotlin.Boolean%29%2Fstrings&quot;&gt;문자열이&lt;/a&gt; 공통의 문자를 가지고,이 방법은 각 위치에서의 첫 번째 요소 문자열의 처음부터 끝까지 진행하고, 발견 &lt;a href=&quot;find-any-of#kotlin.text%24findAnyOf%28kotlin.CharSequence%2C+kotlin.collections.Collection%28%28kotlin.String%29%29%2C+kotlin.Int%2C+kotlin.Boolean%29%2Fstrings&quot;&gt;문자열&lt;/a&gt; 그 위치에서이 문자열을 일치합니다.</target>
        </trans-unit>
        <trans-unit id="d0112a7d95b0f1e5eac2132ba1ef497e36b55c4f" translate="yes" xml:space="preserve">
          <source>To avoid ambiguous results when strings in &lt;a href=&quot;find-last-any-of#kotlin.text%24findLastAnyOf%28kotlin.CharSequence%2C+kotlin.collections.Collection%28%28kotlin.String%29%29%2C+kotlin.Int%2C+kotlin.Boolean%29%2Fstrings&quot;&gt;strings&lt;/a&gt; have characters in common, this method proceeds from the end toward the beginning of this string, and finds at each position the first element in &lt;a href=&quot;find-last-any-of#kotlin.text%24findLastAnyOf%28kotlin.CharSequence%2C+kotlin.collections.Collection%28%28kotlin.String%29%29%2C+kotlin.Int%2C+kotlin.Boolean%29%2Fstrings&quot;&gt;strings&lt;/a&gt; that matches this string at that position.</source>
          <target state="translated">문자열 때 모호한 결과를 방지하기 위해 &lt;a href=&quot;find-last-any-of#kotlin.text%24findLastAnyOf%28kotlin.CharSequence%2C+kotlin.collections.Collection%28%28kotlin.String%29%29%2C+kotlin.Int%2C+kotlin.Boolean%29%2Fstrings&quot;&gt;문자열이&lt;/a&gt; 공통의 문자를 가지고,이 방법은 각 위치에서의 첫 번째 요소 문자열의 시작을 향한 끝에서 진행하고, 발견 &lt;a href=&quot;find-last-any-of#kotlin.text%24findLastAnyOf%28kotlin.CharSequence%2C+kotlin.collections.Collection%28%28kotlin.String%29%29%2C+kotlin.Int%2C+kotlin.Boolean%29%2Fstrings&quot;&gt;문자열&lt;/a&gt; 그 위치에서이 문자열을 일치합니다.</target>
        </trans-unit>
        <trans-unit id="4027c8136b6286dfe349c3bde29fd950bfe158c1" translate="yes" xml:space="preserve">
          <source>To avoid ambiguous results when strings in &lt;a href=&quot;index-of-any#kotlin.text%24indexOfAny%28kotlin.CharSequence%2C+kotlin.collections.Collection%28%28kotlin.String%29%29%2C+kotlin.Int%2C+kotlin.Boolean%29%2Fstrings&quot;&gt;strings&lt;/a&gt; have characters in common, this method proceeds from the beginning to the end of this string, and finds at each position the first element in &lt;a href=&quot;index-of-any#kotlin.text%24indexOfAny%28kotlin.CharSequence%2C+kotlin.collections.Collection%28%28kotlin.String%29%29%2C+kotlin.Int%2C+kotlin.Boolean%29%2Fstrings&quot;&gt;strings&lt;/a&gt; that matches this string at that position.</source>
          <target state="translated">문자열 때 모호한 결과를 방지하기 위해 &lt;a href=&quot;index-of-any#kotlin.text%24indexOfAny%28kotlin.CharSequence%2C+kotlin.collections.Collection%28%28kotlin.String%29%29%2C+kotlin.Int%2C+kotlin.Boolean%29%2Fstrings&quot;&gt;문자열이&lt;/a&gt; 공통의 문자를 가지고,이 방법은 각 위치에서의 첫 번째 요소 문자열의 처음부터 끝까지 진행하고, 발견 &lt;a href=&quot;index-of-any#kotlin.text%24indexOfAny%28kotlin.CharSequence%2C+kotlin.collections.Collection%28%28kotlin.String%29%29%2C+kotlin.Int%2C+kotlin.Boolean%29%2Fstrings&quot;&gt;문자열&lt;/a&gt; 그 위치에서이 문자열을 일치합니다.</target>
        </trans-unit>
        <trans-unit id="31bfe127214639414101a9ca7c2a589e0f9d8655" translate="yes" xml:space="preserve">
          <source>To avoid ambiguous results when strings in &lt;a href=&quot;last-index-of-any#kotlin.text%24lastIndexOfAny%28kotlin.CharSequence%2C+kotlin.collections.Collection%28%28kotlin.String%29%29%2C+kotlin.Int%2C+kotlin.Boolean%29%2Fstrings&quot;&gt;strings&lt;/a&gt; have characters in common, this method proceeds from the end toward the beginning of this string, and finds at each position the first element in &lt;a href=&quot;last-index-of-any#kotlin.text%24lastIndexOfAny%28kotlin.CharSequence%2C+kotlin.collections.Collection%28%28kotlin.String%29%29%2C+kotlin.Int%2C+kotlin.Boolean%29%2Fstrings&quot;&gt;strings&lt;/a&gt; that matches this string at that position.</source>
          <target state="translated">문자열 때 모호한 결과를 방지하기 위해 &lt;a href=&quot;last-index-of-any#kotlin.text%24lastIndexOfAny%28kotlin.CharSequence%2C+kotlin.collections.Collection%28%28kotlin.String%29%29%2C+kotlin.Int%2C+kotlin.Boolean%29%2Fstrings&quot;&gt;문자열이&lt;/a&gt; 공통의 문자를 가지고,이 방법은 각 위치에서의 첫 번째 요소 문자열의 시작을 향한 끝에서 진행하고, 발견 &lt;a href=&quot;last-index-of-any#kotlin.text%24lastIndexOfAny%28kotlin.CharSequence%2C+kotlin.collections.Collection%28%28kotlin.String%29%29%2C+kotlin.Int%2C+kotlin.Boolean%29%2Fstrings&quot;&gt;문자열&lt;/a&gt; 그 위치에서이 문자열을 일치합니다.</target>
        </trans-unit>
        <trans-unit id="6276ae19b8071911e89a3dcb94d020bccd844c9c" translate="yes" xml:space="preserve">
          <source>To avoid ambiguous results when strings in &lt;a href=&quot;split#kotlin.text%24split%28kotlin.CharSequence%2C+kotlin.Array%28%28kotlin.String%29%29%2C+kotlin.Boolean%2C+kotlin.Int%29%2Fdelimiters&quot;&gt;delimiters&lt;/a&gt; have characters in common, this method proceeds from the beginning to the end of this string, and matches at each position the first element in &lt;a href=&quot;split#kotlin.text%24split%28kotlin.CharSequence%2C+kotlin.Array%28%28kotlin.String%29%29%2C+kotlin.Boolean%2C+kotlin.Int%29%2Fdelimiters&quot;&gt;delimiters&lt;/a&gt; that is equal to a delimiter in this instance at that position.</source>
          <target state="translated">&lt;a href=&quot;split#kotlin.text%24split%28kotlin.CharSequence%2C+kotlin.Array%28%28kotlin.String%29%29%2C+kotlin.Boolean%2C+kotlin.Int%29%2Fdelimiters&quot;&gt;구분 기호의&lt;/a&gt; 문자열에 공통 문자 가 있을 때 모호한 결과를 피하기 위해이 방법은이 문자열의 처음부터 끝까지 진행되며 각 위치 에서 해당 위치의이 인스턴스에서 구분 기호와 동일한 &lt;a href=&quot;split#kotlin.text%24split%28kotlin.CharSequence%2C+kotlin.Array%28%28kotlin.String%29%29%2C+kotlin.Boolean%2C+kotlin.Int%29%2Fdelimiters&quot;&gt;구분 기호&lt;/a&gt; 의 첫 번째 요소와 일치 합니다.</target>
        </trans-unit>
        <trans-unit id="35cbc5daa3fa4744579892d02b514b4f1f8fe190" translate="yes" xml:space="preserve">
          <source>To avoid ambiguous results when strings in &lt;a href=&quot;split-to-sequence#kotlin.text%24splitToSequence%28kotlin.CharSequence%2C+kotlin.Array%28%28kotlin.String%29%29%2C+kotlin.Boolean%2C+kotlin.Int%29%2Fdelimiters&quot;&gt;delimiters&lt;/a&gt; have characters in common, this method proceeds from the beginning to the end of this string, and finds at each position the first element in &lt;a href=&quot;split-to-sequence#kotlin.text%24splitToSequence%28kotlin.CharSequence%2C+kotlin.Array%28%28kotlin.String%29%29%2C+kotlin.Boolean%2C+kotlin.Int%29%2Fdelimiters&quot;&gt;delimiters&lt;/a&gt; that matches this string at that position.</source>
          <target state="translated">&lt;a href=&quot;split-to-sequence#kotlin.text%24splitToSequence%28kotlin.CharSequence%2C+kotlin.Array%28%28kotlin.String%29%29%2C+kotlin.Boolean%2C+kotlin.Int%29%2Fdelimiters&quot;&gt;구분 기호의&lt;/a&gt; 문자열에 공통 문자 가 있을 때 모호한 결과를 피하기 위해이 방법은이 문자열의 처음부터 끝까지 진행하며 각 위치 에서 해당 위치에서이 문자열과 일치 하는 &lt;a href=&quot;split-to-sequence#kotlin.text%24splitToSequence%28kotlin.CharSequence%2C+kotlin.Array%28%28kotlin.String%29%29%2C+kotlin.Boolean%2C+kotlin.Int%29%2Fdelimiters&quot;&gt;구분 기호&lt;/a&gt; 의 첫 번째 요소를 찾습니다 .</target>
        </trans-unit>
        <trans-unit id="4098083aa9fa1edbe4454946791bd3716c2341fe" translate="yes" xml:space="preserve">
          <source>To avoid an exception being thrown, one can use a &lt;em&gt;safe&lt;/em&gt; cast operator &lt;em&gt;as?&lt;/em&gt; that returns &lt;em&gt;null&lt;/em&gt; on failure:</source>
          <target state="translated">예외가 발생하지 않도록 &lt;em&gt;안전한&lt;/em&gt; 캐스트 연산자를 다음 &lt;em&gt;과 같이&lt;/em&gt; 사용할 수 &lt;em&gt;있습니까? &lt;/em&gt;실패시 &lt;em&gt;null&lt;/em&gt; 을 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="9e17e4153a46063a7e951557055076fb55b29173" translate="yes" xml:space="preserve">
          <source>To avoid exceptions when retrieving element with non-existing positions, use safe variations of &lt;code&gt;elementAt()&lt;/code&gt;:</source>
          <target state="translated">존재하지 않는 위치를 가진 요소를 검색 할 때 예외를 피하려면 &lt;code&gt;elementAt()&lt;/code&gt; 의 안전한 변형을 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="7274268313d792eeb0ea9bf91f3d9337f0c66bb3" translate="yes" xml:space="preserve">
          <source>To avoid unchecked casts, you can redesign the program structure: in the example above, there could be interfaces &lt;code&gt;DictionaryReader&amp;lt;T&amp;gt;&lt;/code&gt; and &lt;code&gt;DictionaryWriter&amp;lt;T&amp;gt;&lt;/code&gt; with type-safe implementations for different types. You can introduce reasonable abstractions to move unchecked casts from calling code to the implementation details. Proper use of &lt;a href=&quot;generics#variance&quot;&gt;generic variance&lt;/a&gt; can also help.</source>
          <target state="translated">확인되지 않은 캐스트를 피하기 위해 프로그램 구조를 다시 디자인 할 수 있습니다. 위의 예에서, 다양한 유형에 대해 유형 안전 구현을 가진 &lt;code&gt;DictionaryReader&amp;lt;T&amp;gt;&lt;/code&gt; 및 &lt;code&gt;DictionaryWriter&amp;lt;T&amp;gt;&lt;/code&gt; 인터페이스가있을 수 있습니다 . 확인되지 않은 캐스트를 호출 코드에서 구현 세부 사항으로 이동하기 위해 합리적인 추상화를 도입 할 수 있습니다. &lt;a href=&quot;generics#variance&quot;&gt;일반 분산을&lt;/a&gt; 올바르게 사용하면 도움이 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="86fda07e220a1d9d0906bbd1a8bf6f784d8a05be" translate="yes" xml:space="preserve">
          <source>To be eligible for the &lt;code&gt;tailrec&lt;/code&gt; modifier, a function must call itself as the last operation it performs. You cannot use tail recursion when there is more code after the recursive call, and you cannot use it within try/catch/finally blocks. Currently tail recursion is only supported in the JVM backend.</source>
          <target state="translated">&lt;code&gt;tailrec&lt;/code&gt; 수정자를 사용할 수 있으려면 함수가 마지막으로 수행 할 때 자신을 호출해야합니다. 재귀 호출 후 더 많은 코드가 있으면 테일 재귀를 사용할 수 없으며 try / catch / finally 블록 내에서 사용할 수 없습니다. 현재 테일 재귀는 JVM 백엔드에서만 지원됩니다.</target>
        </trans-unit>
        <trans-unit id="e77c612cc0ad3329a96be3d4bc330a4270facd79" translate="yes" xml:space="preserve">
          <source>To be fair, you'd get the same output in Python, but the mechanism would be different: both instances would start out without any attributes of their own (&lt;code&gt;age&lt;/code&gt; and &lt;code&gt;name&lt;/code&gt; would be attributes on the class), and the first printing would access the class attribute; only the assignment would cause an &lt;code&gt;age&lt;/code&gt; attribute to appear on &lt;code&gt;a&lt;/code&gt;. In Kotlin, there are no class properties in this example, and each instance starts out with both properties. If you need a class-level property, see the section on &lt;a href=&quot;objects-and-companion-objects#companion-objects&quot;&gt;companion objects&lt;/a&gt;.</source>
          <target state="translated">공평하게 말하면 파이썬에서 동일한 결과를 얻을 수 있지만 메커니즘은 다릅니다. 두 인스턴스는 자체 속성 ( &lt;code&gt;age&lt;/code&gt; 및 &lt;code&gt;name&lt;/code&gt; 이 클래스 의 속성이 됨)없이 시작되고 첫 번째 인쇄에 액세스합니다 클래스 속성; 할당 만 &lt;code&gt;age&lt;/code&gt; 속성이에 표시되도록 &lt;code&gt;a&lt;/code&gt; . Kotlin에는이 예제에 클래스 속성이 없으며 각 인스턴스는 두 속성으로 시작합니다. 클래스 수준 속성이 필요한 경우 &lt;a href=&quot;objects-and-companion-objects#companion-objects&quot;&gt;컴패니언 객체&lt;/a&gt; 섹션을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="d5cad0364e908d8aa1ff84ca1d9136f4ad0e8a7e" translate="yes" xml:space="preserve">
          <source>To break a collection onto parts of a given size, use the &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/chunked&quot;&gt;&lt;code&gt;chunked()&lt;/code&gt;&lt;/a&gt; function. &lt;code&gt;chunked()&lt;/code&gt; takes a single argument &amp;ndash; the size of the chunk &amp;ndash; and returns a &lt;code&gt;List&lt;/code&gt; of &lt;code&gt;List&lt;/code&gt;s of the given size. The first chunk starts from the first element and contains the &lt;code&gt;size&lt;/code&gt; elements, the second chunk holds the next &lt;code&gt;size&lt;/code&gt; elements, and so on. The last chunk may have a smaller size.</source>
          <target state="translated">주어진 크기의 부분으로 모음을 나누려면 &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/chunked&quot;&gt; &lt;code&gt;chunked()&lt;/code&gt; &lt;/a&gt; 함수를 사용하십시오 . &lt;code&gt;chunked()&lt;/code&gt; 는 하나의 인수 (청크 크기)를 사용하여 주어진 크기 의 &lt;code&gt;List&lt;/code&gt; &lt;code&gt;List&lt;/code&gt; 을 반환합니다 . 첫 번째 청크는 첫 번째 요소에서 시작하여 &lt;code&gt;size&lt;/code&gt; 요소를 포함하고 두 번째 청크는 다음 &lt;code&gt;size&lt;/code&gt; 요소를 보유합니다 . 마지막 청크는 더 작은 크기를 가질 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c901a4737d7c3f04fc344e06625faf76eec8e9d6" translate="yes" xml:space="preserve">
          <source>To build a custom string representation, you can specify its parameters in function arguments &lt;code&gt;separator&lt;/code&gt;, &lt;code&gt;prefix&lt;/code&gt;, and &lt;code&gt;postfix&lt;/code&gt;. The resulting string will start with the &lt;code&gt;prefix&lt;/code&gt; and end with the &lt;code&gt;postfix&lt;/code&gt;. The &lt;code&gt;separator&lt;/code&gt; will come after each element except the last.</source>
          <target state="translated">사용자 정의 문자열 표현을 작성하려면 함수 인수 &lt;code&gt;separator&lt;/code&gt; , &lt;code&gt;prefix&lt;/code&gt; 및 &lt;code&gt;postfix&lt;/code&gt; 에서 해당 매개 변수를 지정할 수 있습니다 . 결과 문자열은 &lt;code&gt;prefix&lt;/code&gt; 시작 하고 &lt;code&gt;postfix&lt;/code&gt; 로 끝납니다 . &lt;code&gt;separator&lt;/code&gt; 마지막 제외한 각 요소에 들어오는 것이다.</target>
        </trans-unit>
        <trans-unit id="2719279869fab416ee4cd752ab3460ef98055407" translate="yes" xml:space="preserve">
          <source>To build and run your application on an emulator:</source>
          <target state="translated">에뮬레이터에서 응용 프로그램을 빌드하고 실행하려면</target>
        </trans-unit>
        <trans-unit id="7150222f1a1fb391342d63f455f2076e7800770e" translate="yes" xml:space="preserve">
          <source>To build two-element windows, there is a separate function - &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/zip-with-next&quot;&gt;&lt;code&gt;zipWithNext()&lt;/code&gt;&lt;/a&gt;. It creates pairs of adjacent elements of the receiver collection. Note that &lt;code&gt;zipWithNext()&lt;/code&gt; doesn't break the collection into pairs; it creates a &lt;code&gt;Pair&lt;/code&gt; for &lt;em&gt;each&lt;/em&gt; element except the last one, so its result on &lt;code&gt;[1, 2, 3, 4]&lt;/code&gt; is &lt;code&gt;[[1, 2], [2, 3], [3, 4]]&lt;/code&gt;, not &lt;code&gt;[[1, 2&lt;/code&gt;], &lt;code&gt;[3, 4]]&lt;/code&gt;. &lt;code&gt;zipWithNext()&lt;/code&gt; can be called with a transformation function as well; it should take two elements of the receiver collection as arguments.</source>
          <target state="translated">요소가 두 개인 창을 만들려면 별도의 함수 인 &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/zip-with-next&quot;&gt; &lt;code&gt;zipWithNext()&lt;/code&gt; &lt;/a&gt; 있습니다. 수신자 콜렉션의 인접한 요소 쌍을 작성합니다. 참고 &lt;code&gt;zipWithNext()&lt;/code&gt; 쌍으로 수집을 중단하지 않는다; 이것은 생성 &lt;code&gt;Pair&lt;/code&gt; 위한 &lt;em&gt;각각&lt;/em&gt; 의 그 결과, 그래서 최종 제외한 요소 &lt;code&gt;[1, 2, 3, 4]&lt;/code&gt; 이다 &lt;code&gt;[[1, 2], [2, 3], [3, 4]]&lt;/code&gt; 이 아닌 &lt;code&gt;[[1, 2&lt;/code&gt; ], &lt;code&gt;[3, 4]]&lt;/code&gt; . &lt;code&gt;zipWithNext()&lt;/code&gt; 는 변환 함수로도 호출 할 수 있습니다. 수신자 콜렉션의 두 요소를 인수로 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="8c83a6b42d390ab9398eaec7a8e407e01581218b" translate="yes" xml:space="preserve">
          <source>To call &lt;code&gt;fold&lt;/code&gt;, we need to pass it an &lt;a href=&quot;#instantiating-a-function-type&quot;&gt;instance of the function type&lt;/a&gt; as an argument, and lambda expressions (&lt;a href=&quot;#lambda-expressions-and-anonymous-functions&quot;&gt;described in more detail below&lt;/a&gt;) are widely used for this purpose at higher-order function call sites:</source>
          <target state="translated">&lt;code&gt;fold&lt;/code&gt; 를 호출하려면 &lt;a href=&quot;#instantiating-a-function-type&quot;&gt;함수 유형&lt;/a&gt; 의 인스턴스를 인수 로 전달해야 하며 람다 표현식 ( &lt;a href=&quot;#lambda-expressions-and-anonymous-functions&quot;&gt;아래에 자세히 설명 됨&lt;/a&gt; )은이 목적을 위해 고차 함수 호출 사이트에서 널리 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="6580f39324c16c3fdd14fd9204c4e7b2dbc24353" translate="yes" xml:space="preserve">
          <source>To call a generic function, specify the type arguments at the call site &lt;strong&gt;after&lt;/strong&gt; the name of the function:</source>
          <target state="translated">일반 함수를 호출하려면 함수 이름 &lt;strong&gt;뒤에&lt;/strong&gt; 호출 사이트에서 유형 인수를 지정하십시오 .</target>
        </trans-unit>
        <trans-unit id="567fc2cf862c0915604df53cff04863a317488f7" translate="yes" xml:space="preserve">
          <source>To catch an exception, use the &lt;em&gt;try&lt;/em&gt;-expression:</source>
          <target state="translated">예외를 포착하려면 &lt;em&gt;try&lt;/em&gt; -expression을 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="f8d7572362421bb5d6d9129ee1f644a5743bf60f" translate="yes" xml:space="preserve">
          <source>To change the names of generated accessor methods for properties without explicitly implemented getters and setters, you can use &lt;code&gt;@get:JvmName&lt;/code&gt; and &lt;code&gt;@set:JvmName&lt;/code&gt;:</source>
          <target state="translated">명시 적으로 구현 된 getter 및 setter없이 속성에 대해 생성 된 접근 자 메서드의 이름을 변경하려면 &lt;code&gt;@get:JvmName&lt;/code&gt; 및 &lt;code&gt;@set:JvmName&lt;/code&gt; 을 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="5fbf41ce5d5e2bab70a3b18ea06244281f42ad35" translate="yes" xml:space="preserve">
          <source>To check that your code passes your own test click the &lt;strong&gt;Check&lt;/strong&gt; icon at the top of &lt;strong&gt;Task Description&lt;/strong&gt; panel. If your code and test are correct, you will see the &lt;strong&gt;&quot;Congratulations!&quot;&lt;/strong&gt; text:</source>
          <target state="translated">코드가 자체 테스트를 통과했는지 확인하려면 &lt;strong&gt;작업 설명&lt;/strong&gt; 패널 상단의 &lt;strong&gt;확인&lt;/strong&gt; 아이콘을 클릭하십시오 . 코드와 테스트가 정확하면 &lt;strong&gt;&quot;축하합니다!&quot; &lt;/strong&gt;본문:&lt;strong&gt;&lt;/strong&gt;&lt;strong&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="beef2a5f5b84a735eaf6763f186616f2da608682" translate="yes" xml:space="preserve">
          <source>To check the presence of an element in a collection, use the &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/contains&quot;&gt;&lt;code&gt;contains()&lt;/code&gt;&lt;/a&gt; function. It returns &lt;code&gt;true&lt;/code&gt; if there is a collection element that &lt;code&gt;equals()&lt;/code&gt; the function argument. You can call &lt;code&gt;contains()&lt;/code&gt; in the operator form with the &lt;code&gt;in&lt;/code&gt; keyword.</source>
          <target state="translated">컬렉션에 요소가 있는지 확인하려면 &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/contains&quot;&gt; &lt;code&gt;contains()&lt;/code&gt; &lt;/a&gt; 함수를 사용하십시오 . 함수 인수 &lt;code&gt;equals()&lt;/code&gt; 컬렉션 요소가 있으면 &lt;code&gt;true&lt;/code&gt; 를 반환 합니다 . &lt;code&gt;in&lt;/code&gt; 키워드를 사용하여 연산자 형식으로 &lt;code&gt;contains()&lt;/code&gt; 를 호출 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="bacf79d368ab6b699d2fdae207996c835a00695c" translate="yes" xml:space="preserve">
          <source>To check the presence of multiple instances together at once, call &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/contains-all&quot;&gt;&lt;code&gt;containsAll()&lt;/code&gt;&lt;/a&gt; with a collection of these instances as an argument.</source>
          <target state="translated">한 번에 여러 인스턴스가 있는지 확인하려면 이러한 인스턴스 컬렉션을 인수로하여 &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/contains-all&quot;&gt; &lt;code&gt;containsAll()&lt;/code&gt; &lt;/a&gt; 을 호출하십시오 .</target>
        </trans-unit>
        <trans-unit id="bf01294073385c1601c163965354f1918a41a878" translate="yes" xml:space="preserve">
          <source>To check the stability status of different components of Kotlin (Kotlin/JVM, JS, Native, various libraries, etc), please consult &lt;a href=&quot;components-stability&quot;&gt;this link&lt;/a&gt;.</source>
          <target state="translated">Kotlin의 다른 구성 요소 (Kotlin / JVM, JS, Native, 다양한 라이브러리 등)의 안정성 상태를 확인하려면 &lt;a href=&quot;components-stability&quot;&gt;이 링크&lt;/a&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="ff347228167cf9fc3db7b8ec20d8d867ef76b338" translate="yes" xml:space="preserve">
          <source>To check whether a &lt;code&gt;lateinit var&lt;/code&gt; has already been initialized, use &lt;code&gt;.isInitialized&lt;/code&gt; on the &lt;a href=&quot;reflection#property-references&quot;&gt;reference to that property&lt;/a&gt;:</source>
          <target state="translated">&lt;code&gt;lateinit var&lt;/code&gt; 가 이미 초기화 되었는지 확인하려면 &lt;a href=&quot;reflection#property-references&quot;&gt;해당 속성&lt;/a&gt; 에 대한 참조에서 &lt;code&gt;.isInitialized&lt;/code&gt; 를 사용 하십시오 .</target>
        </trans-unit>
        <trans-unit id="06e9d17e9ea9b86a000058cf4db743b9a4f8896c" translate="yes" xml:space="preserve">
          <source>To clearly separate the class header and body when the class header is long, either put a blank line following the class header (as in the example above), or put the opening curly brace on a separate line:</source>
          <target state="translated">클래스 헤더가 길 때 클래스 헤더와 본문을 명확하게 분리하려면 클래스 헤더 다음에 빈 줄을 추가하거나 (위의 예와 같이) 여는 중괄호를 별도의 줄에 넣으십시오.</target>
        </trans-unit>
        <trans-unit id="3e043d9080f48d9f8a9db312581f08dbc6b9e5fd" translate="yes" xml:space="preserve">
          <source>To collect all source sets participating in a compilation, including those added via the depends-on relation, one can use the property &lt;code&gt;allKotlinSourceSets&lt;/code&gt;.</source>
          <target state="translated">의존 관계를 통해 추가 된 것을 포함하여 컴파일에 참여하는 모든 소스 세트를 수집하기 위해 &lt;code&gt;allKotlinSourceSets&lt;/code&gt; 속성을 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="803e7c1c7144d14a645ff4c12ca8fcfcbdd5adbe" translate="yes" xml:space="preserve">
          <source>To compile mixed code applications Kotlin compiler should be invoked before Java compiler. In maven terms that means kotlin-maven-plugin should be run before maven-compiler-plugin using the following method, making sure that the kotlin plugin is above the maven-compiler-plugin in your pom.xml file:</source>
          <target state="translated">혼합 코드 애플리케이션을 컴파일하려면 Java 컴파일러 전에 Kotlin 컴파일러를 호출해야합니다. 즉, kotlin 플러그인이 pom.xml 파일의 maven-compiler-plugin 위에 있는지 확인하여 다음 방법을 사용하여 kotlin-maven-plugin을 maven-compiler-plugin보다 먼저 실행해야합니다.</target>
        </trans-unit>
        <trans-unit id="72988880fd1eb858d05ee3ce13bbc13e7e1bb020" translate="yes" xml:space="preserve">
          <source>To compile source code, specify the source directories in the</source>
          <target state="translated">소스 코드를 컴파일하려면</target>
        </trans-unit>
        <trans-unit id="37fdd621985c6aff13221b4e4aea16cc07ab8ee0" translate="yes" xml:space="preserve">
          <source>To configure DCE on the main source set, you can use the &lt;code&gt;runDceKotlinJs&lt;/code&gt; task (and corresponding &lt;code&gt;runDce&amp;lt;sourceSetName&amp;gt;KotlinJs&lt;/code&gt; for other source sets).</source>
          <target state="translated">기본 소스 세트에서 DCE를 구성하기 위해 &lt;code&gt;runDceKotlinJs&lt;/code&gt; 태스크 (및 다른 소스 세트에 해당하는 &lt;code&gt;runDce&amp;lt;sourceSetName&amp;gt;KotlinJs&lt;/code&gt; )를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0fbb0879e62b32ffc14d1dc5aabab44fdf51b7ee" translate="yes" xml:space="preserve">
          <source>To configure a single task, use its name. Examples:</source>
          <target state="translated">단일 작업을 구성하려면 해당 이름을 사용하십시오. 예 :</target>
        </trans-unit>
        <trans-unit id="68df6e8c753963392486043995598199a7116aa3" translate="yes" xml:space="preserve">
          <source>To configure the IntelliJ formatter according to this style guide, please install Kotlin plugin version 1.2.20 or newer, go to Settings | Editor | Code Style | Kotlin, click on &quot;Set from&amp;hellip;&quot; link in the upper right corner, and select &quot;Predefined style / Kotlin style guide&quot; from the menu.</source>
          <target state="translated">이 스타일 가이드에 따라 IntelliJ 포맷터를 구성하려면 Kotlin 플러그인 버전 1.2.20 이상을 설치하고 설정 | 편집자 | 코드 스타일 | Kotlin의 오른쪽 상단 모서리에있는 &quot;Set from&amp;hellip;&quot;링크를 클릭하고 메뉴에서 &quot;Predefined style / Kotlin style guide&quot;를 선택하십시오.</target>
        </trans-unit>
        <trans-unit id="a84aa42a71bde94030fd28b49274ed212410ae73" translate="yes" xml:space="preserve">
          <source>To convert a Kotlin function to a pointer to a C function, &lt;code&gt;staticCFunction(::kotlinFunction)&lt;/code&gt; can be used. It is also able to provide the lambda instead of a function reference. The function or lambda must not capture any values.</source>
          <target state="translated">Kotlin 함수를 C 함수의 포인터로 변환하기 위해 &lt;code&gt;staticCFunction(::kotlinFunction)&lt;/code&gt; 사용할 수 있습니다. 함수 참조 대신 람다를 제공 할 수도 있습니다. 함수 또는 람다는 어떤 값도 캡처하지 않아야합니다.</target>
        </trans-unit>
        <trans-unit id="3c44f554793ee378fe115edb9d2b77ef0a09d12f" translate="yes" xml:space="preserve">
          <source>To convert a file we simply provide the input file, and optionally an output directory. The command below will convert the file &lt;code&gt;jquery.d.ts&lt;/code&gt; in the current folder, which we've previously downloaded from the &lt;a href=&quot;https://github.com/DefinitelyTyped/DefinitelyTyped/blob/types/jquery/jquery.d.ts&quot;&gt;Definitely Typed repository&lt;/a&gt; to the output folder &lt;code&gt;headers&lt;/code&gt;:</source>
          <target state="translated">파일을 변환하기 위해 단순히 입력 파일과 선택적으로 출력 디렉토리를 제공합니다. 아래 명령 은 이전에 &lt;a href=&quot;https://github.com/DefinitelyTyped/DefinitelyTyped/blob/types/jquery/jquery.d.ts&quot;&gt;Definitely Typed 리포지토리&lt;/a&gt; 에서 다운로드 한 현재 폴더의 &lt;code&gt;jquery.d.ts&lt;/code&gt; 파일 을 출력 폴더 &lt;code&gt;headers&lt;/code&gt; 변환합니다 .</target>
        </trans-unit>
        <trans-unit id="033c0e927137582a697794f54285b85aeb454fd5" translate="yes" xml:space="preserve">
          <source>To cover these (and other) cases, Kotlin supports &lt;em&gt;delegated properties&lt;/em&gt;:</source>
          <target state="translated">이러한 (및 기타) 사례를 다루기 위해 Kotlin은 &lt;em&gt;위임 속성을&lt;/em&gt; 지원 &lt;em&gt;합니다&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="9d0229fd8c1088f563b4cf4e10d12c4379d2f726" translate="yes" xml:space="preserve">
          <source>To create a Kotlin scratch, click &lt;strong&gt;File | New | Scratch file&lt;/strong&gt; and select the &lt;strong&gt;Kotlin&lt;/strong&gt; type.</source>
          <target state="translated">Kotlin 스크래치를 작성하려면 &lt;strong&gt;파일 | 새로운 | 파일을 스크래치&lt;/strong&gt; 하고 &lt;strong&gt;Kotlin&lt;/strong&gt; 유형을 선택하십시오 .</target>
        </trans-unit>
        <trans-unit id="6469e95270452943ecc23557177165ada17e0d19" translate="yes" xml:space="preserve">
          <source>To create a collection with the same elements as an existing collection, you can use copying operations. Collection copying operations from the standard library create &lt;em&gt;shallow&lt;/em&gt; copy collections with references to the same elements. Thus, a change made to a collection element reflects in all its copies.</source>
          <target state="translated">기존 컬렉션과 동일한 요소로 컬렉션을 만들려면 복사 작업을 사용할 수 있습니다. 표준 라이브러리에서 수집 복사 작업 을 수행하면 동일한 요소에 대한 참조가있는 &lt;em&gt;단순&lt;/em&gt; 복사 수집이 생성 됩니다. 따라서 컬렉션 요소에 대한 변경 사항은 모든 복사본에 반영됩니다.</target>
        </trans-unit>
        <trans-unit id="c93eeedd365f43d9e2553f0db590167b463ec502" translate="yes" xml:space="preserve">
          <source>To create a concrete type collection, such as an &lt;code&gt;ArrayList&lt;/code&gt; or &lt;code&gt;LinkedList&lt;/code&gt;, you can use the available constructors for these types. Similar constructors are available for implementations of &lt;code&gt;Set&lt;/code&gt; and &lt;code&gt;Map&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;ArrayList&lt;/code&gt; 또는 &lt;code&gt;LinkedList&lt;/code&gt; 와 같은 구체적인 유형 컬렉션을 만들려면 이러한 유형에 사용 가능한 생성자를 사용할 수 있습니다. &lt;code&gt;Set&lt;/code&gt; 및 &lt;code&gt;Map&lt;/code&gt; 구현에 유사한 생성자를 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="10c83d8ce189917b93f0dd12f924ce0343c0f0cd" translate="yes" xml:space="preserve">
          <source>To create a course, go to &lt;strong&gt;Create New Course&lt;/strong&gt; from the &lt;strong&gt;Welcome Screen&lt;/strong&gt; or in the &lt;strong&gt;File Menu&lt;/strong&gt;, fill in the title, author and description:</source>
          <target state="translated">과정을 만들려면 갈 &lt;strong&gt;새로운 코스를 만들기&lt;/strong&gt; 로부터 &lt;strong&gt;시작 화면&lt;/strong&gt; 또는에서 &lt;strong&gt;파일 메뉴&lt;/strong&gt; , 제목, 저자 및 설명에 채우기 :</target>
        </trans-unit>
        <trans-unit id="b19b96489e64fb428b07b0d9e5f6b20ffaee0c76" translate="yes" xml:space="preserve">
          <source>To create a finite sequence with &lt;code&gt;generateSequence()&lt;/code&gt;, provide a function that returns &lt;code&gt;null&lt;/code&gt; after the last element you need.</source>
          <target state="translated">&lt;code&gt;generateSequence()&lt;/code&gt; 를 사용하여 유한 시퀀스를 작성하려면 필요한 마지막 요소 다음에 &lt;code&gt;null&lt;/code&gt; 을 리턴하는 함수를 제공하십시오 .</target>
        </trans-unit>
        <trans-unit id="47b61d43a27903512a35c90e596534948c2b1dbf" translate="yes" xml:space="preserve">
          <source>To create a progression for iterating in reverse order, use &lt;code&gt;downTo&lt;/code&gt; instead of &lt;code&gt;..&lt;/code&gt; when defining the range for it.</source>
          <target state="translated">역순으로 반복 진행을 만들려면 범위를 정의 할 때 &lt;code&gt;..&lt;/code&gt; 대신 &lt;code&gt;downTo&lt;/code&gt; 를 사용 하십시오.</target>
        </trans-unit>
        <trans-unit id="b47410847599f97a1134fa9ef445378b7a480550" translate="yes" xml:space="preserve">
          <source>To create a range for your class, call the &lt;code&gt;rangeTo()&lt;/code&gt; function on the range start value and provide the end value as an argument. &lt;code&gt;rangeTo()&lt;/code&gt; is often called in its operator form &lt;code&gt;..&lt;/code&gt;.</source>
          <target state="translated">클래스의 범위를 만들려면 범위 시작 값 에서 &lt;code&gt;rangeTo()&lt;/code&gt; 함수를 호출 하고 끝 값을 인수로 제공하십시오. &lt;code&gt;rangeTo()&lt;/code&gt; 종종 운영자 형태라고 &lt;code&gt;..&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ef350d13303167462d244e7352097ce6871c0d66" translate="yes" xml:space="preserve">
          <source>To create a self-contained Jar file containing the code from your module along with dependencies, include the following under &lt;code&gt;build-&amp;gt;plugins&lt;/code&gt; in your Maven pom.xml file, where &lt;code&gt;main.class&lt;/code&gt; is defined as a property and points to the main Kotlin or Java class:</source>
          <target state="translated">종속성과 함께 모듈의 코드를 포함하는 자체 포함 된 Jar 파일을 작성하려면 Maven pom.xml 파일의 &lt;code&gt;build-&amp;gt;plugins&lt;/code&gt; 아래에 다음을 포함 하십시오. 여기서 &lt;code&gt;main.class&lt;/code&gt; 는 특성으로 정의되며 기본 Kotlin 또는 자바 클래스 :</target>
        </trans-unit>
        <trans-unit id="250688e8e0fbdc724cfa4d689a087f5e676490f2" translate="yes" xml:space="preserve">
          <source>To create a sequence, call the &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.sequences/sequence-of&quot;&gt;&lt;code&gt;sequenceOf()&lt;/code&gt;&lt;/a&gt; function listing the elements as its arguments.</source>
          <target state="translated">시퀀스를 만들려면 요소를 인수로 나열하는 &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.sequences/sequence-of&quot;&gt; &lt;code&gt;sequenceOf()&lt;/code&gt; &lt;/a&gt; 함수를 호출하십시오 .</target>
        </trans-unit>
        <trans-unit id="ab5e0caabe6ba677095c9c30bc71be0a60a8ea76" translate="yes" xml:space="preserve">
          <source>To create a small Jar file containing just the code from your module, include the following under &lt;code&gt;build-&amp;gt;plugins&lt;/code&gt; in your Maven pom.xml file, where &lt;code&gt;main.class&lt;/code&gt; is defined as a property and points to the main Kotlin or Java class:</source>
          <target state="translated">모듈의 코드 만 포함하는 작은 Jar 파일을 만들려면 Maven pom.xml 파일의 &lt;code&gt;build-&amp;gt;plugins&lt;/code&gt; 아래에 다음을 포함 하십시오. 여기서 &lt;code&gt;main.class&lt;/code&gt; 는 속성으로 정의되며 기본 Kotlin 또는 Java 클래스를 가리 킵니다.</target>
        </trans-unit>
        <trans-unit id="e35af751d291871272ac5bf8d4ceb5925a4c895b" translate="yes" xml:space="preserve">
          <source>To create a target, use one of the preset functions, which are named according to the target platforms and optionally accept the target name and a configuring code block:</source>
          <target state="translated">대상을 작성하려면 대상 플랫폼에 따라 이름이 지정된 사전 설정 기능 중 하나를 사용하고 선택적으로 대상 이름과 구성 코드 블록을 승인하십시오.</target>
        </trans-unit>
        <trans-unit id="59c179a1054538f29e6f5790e866a02248610385" translate="yes" xml:space="preserve">
          <source>To create an array, we can use a library function &lt;code&gt;arrayOf()&lt;/code&gt; and pass the item values to it, so that &lt;code&gt;arrayOf(1, 2, 3)&lt;/code&gt; creates an array &lt;code&gt;[1, 2, 3]&lt;/code&gt;. Alternatively, the &lt;code&gt;arrayOfNulls()&lt;/code&gt; library function can be used to create an array of a given size filled with null elements.</source>
          <target state="translated">배열을 만들려면 &lt;code&gt;arrayOf()&lt;/code&gt; 라이브러리 함수를 사용 하고 항목 값을 전달하여 &lt;code&gt;arrayOf(1, 2, 3)&lt;/code&gt; 이 배열 &lt;code&gt;[1, 2, 3]&lt;/code&gt; 있습니다. 또는 &lt;code&gt;arrayOfNulls()&lt;/code&gt; 라이브러리 함수를 사용하여 널 요소로 채워진 주어진 크기의 배열을 작성할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9cc39e6db177eed985da184429e7d653e4d3e03b" translate="yes" xml:space="preserve">
          <source>To create an instance of &lt;a href=&quot;index&quot;&gt;Lazy&lt;/a&gt; use the &lt;a href=&quot;../lazy#kotlin%24lazy%28kotlin.Function0%28%28kotlin.lazy.T%29%29%29&quot;&gt;lazy&lt;/a&gt; function.</source>
          <target state="translated">&lt;a href=&quot;index&quot;&gt;Lazy&lt;/a&gt; 인스턴스를 만들려면 &lt;a href=&quot;../lazy#kotlin%24lazy%28kotlin.Function0%28%28kotlin.lazy.T%29%29%29&quot;&gt;lazy&lt;/a&gt; 함수를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="392ca62c20eb8ea21287252327b80e948e15e7f9" translate="yes" xml:space="preserve">
          <source>To create an instance of a class, we call the constructor as if it were a regular function:</source>
          <target state="translated">클래스의 인스턴스를 만들려면 생성자를 일반 함수 인 것처럼 호출합니다.</target>
        </trans-unit>
        <trans-unit id="5ececdd9ea1ec767cefb32bd8a4972a7f3db2e63" translate="yes" xml:space="preserve">
          <source>To create an object of an anonymous class that inherits from some type (or types), we write:</source>
          <target state="translated">어떤 유형에서 상속되는 익명 클래스의 객체를 만들려면 다음과 같이 작성하십시오.</target>
        </trans-unit>
        <trans-unit id="66ccf1c80c7d0872003cb95567afdbb598a15cac" translate="yes" xml:space="preserve">
          <source>To create bindings for a new library, start by creating a &lt;code&gt;.def&lt;/code&gt; file. Structurally it's a simple property file, which looks like this:</source>
          <target state="translated">새 라이브러리에 대한 바인딩을 작성하려면 먼저 &lt;code&gt;.def&lt;/code&gt; 파일 을 작성 하십시오. 구조적으로 이것은 다음과 같은 간단한 속성 파일입니다.</target>
        </trans-unit>
        <trans-unit id="53cb83a01be7750f4f13800e35fa2fb65a7ce331" translate="yes" xml:space="preserve">
          <source>To create or access several targets from multiple presets dynamically, you can use the &lt;code&gt;targetFromPreset&lt;/code&gt; function which accepts a preset (those are contained in the &lt;code&gt;kotlin.presets&lt;/code&gt; domain object collection) and, optionally, a target name and a configuration code block.</source>
          <target state="translated">여러 사전 설정에서 여러 대상을 동적으로 작성하거나 액세스하려면 사전 설정 ( &lt;code&gt;kotlin.presets&lt;/code&gt; 도메인 오브젝트 콜렉션에 포함됨 ) 및 선택적으로 대상 이름 및 구성 코드 블록 을 허용하는 &lt;code&gt;targetFromPreset&lt;/code&gt; 함수를 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="84204f67cf463ce0040ab94f394e112f27f7a64e" translate="yes" xml:space="preserve">
          <source>To create such channel use a factory method &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.channels/ticker.html&quot;&gt;ticker&lt;/a&gt;. To indicate that no further elements are needed use &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.channels/-receive-channel/cancel.html&quot;&gt;ReceiveChannel.cancel&lt;/a&gt; method on it.</source>
          <target state="translated">이러한 채널을 만들려면 팩토리 메소드 &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.channels/ticker.html&quot;&gt;시세를 사용하십시오&lt;/a&gt; . 추가 요소가 필요하지 않음을 나타내려면 &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.channels/-receive-channel/cancel.html&quot;&gt;ReceiveChannel.cancel&lt;/a&gt; 메소드를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="9e26d13b3d6d463e1b2fd03afc335d058a5d4673" translate="yes" xml:space="preserve">
          <source>To debug Kotlin in Google Chrome, you should use DevTools. Please, read the &lt;a href=&quot;https://developer.chrome.com/devtools&quot;&gt;official documentation&lt;/a&gt; to learn how to open and use DevTools.</source>
          <target state="translated">Chrome에서 Kotlin을 디버깅하려면 DevTools를 사용해야합니다. DevTools를 열고 사용하는 방법을 배우 려면 &lt;a href=&quot;https://developer.chrome.com/devtools&quot;&gt;공식 문서&lt;/a&gt; 를 읽으십시오 .</target>
        </trans-unit>
        <trans-unit id="e817cf98143421063f9dd49cbdf248b7b2518117" translate="yes" xml:space="preserve">
          <source>To debug Kotlin sources in the browser, you should tell the compiler to generate source map file. Add following lines to the Gradle configuration:</source>
          <target state="translated">브라우저에서 Kotlin 소스를 디버그하려면 소스 맵 파일을 생성하도록 컴파일러에 지시해야합니다. Gradle 구성에 다음 줄을 추가하십시오.</target>
        </trans-unit>
        <trans-unit id="f1c61d767cd604eae6780df09aa030d9d280b98c" translate="yes" xml:space="preserve">
          <source>To declare a function that is implemented in native (C or C++) code, you need to mark it with the &lt;code&gt;external&lt;/code&gt; modifier:</source>
          <target state="translated">네이티브 (C 또는 C ++) 코드로 구현 된 함수를 선언하려면 &lt;code&gt;external&lt;/code&gt; 수정 자로 이를 표시해야합니다 .</target>
        </trans-unit>
        <trans-unit id="17984c774c9009532146abdfe4c1f92691dab870" translate="yes" xml:space="preserve">
          <source>To declare a sealed class, you put the &lt;code&gt;sealed&lt;/code&gt; modifier before the name of the class. A sealed class can have subclasses, but all of them must be declared in the same file as the sealed class itself. (Before Kotlin 1.1, the rules were even more strict: classes had to be nested inside the declaration of the sealed class).</source>
          <target state="translated">봉인 된 클래스를 선언하려면 클래스 이름 앞에 &lt;code&gt;sealed&lt;/code&gt; 수정자를 넣습니다 . 봉인 된 클래스에는 서브 클래스가있을 수 있지만 모두 봉인 된 클래스 자체와 동일한 파일에 선언되어야합니다. (Kotlin 1.1 이전에는 규칙이 더욱 엄격했습니다. 클래스는 봉인 된 클래스의 선언 안에 중첩되어야했습니다).</target>
        </trans-unit>
        <trans-unit id="c97ee402b691c80817117f378bd0349e4a8da26c" translate="yes" xml:space="preserve">
          <source>To declare an explicit supertype, we place the type after a colon in the class header:</source>
          <target state="translated">명시적인 슈퍼 타입을 선언하기 위해 클래스 헤더에서 콜론 뒤에 타입을 배치합니다.</target>
        </trans-unit>
        <trans-unit id="48ff93d55fe3658449347e35151be6b572c8736d" translate="yes" xml:space="preserve">
          <source>To declare an extension function, we need to prefix its name with a &lt;em&gt;receiver type&lt;/em&gt;, i.e. the type being extended. The following adds a &lt;code&gt;swap&lt;/code&gt; function to &lt;code&gt;MutableList&amp;lt;Int&amp;gt;&lt;/code&gt;:</source>
          <target state="translated">확장 함수를 선언하려면 이름 앞에 &lt;em&gt;리시버 유형&lt;/em&gt; , 즉 확장되는 &lt;em&gt;유형&lt;/em&gt; 을 접두어로 붙여야합니다 . 다음 은 &lt;code&gt;MutableList&amp;lt;Int&amp;gt;&lt;/code&gt; &lt;code&gt;swap&lt;/code&gt; 함수를 추가합니다 .</target>
        </trans-unit>
        <trans-unit id="f1b32c095491287535a8ffbd23d718a4ec1e28de" translate="yes" xml:space="preserve">
          <source>To define a custom order for the collection sorting, you can provide your own &lt;code&gt;Comparator&lt;/code&gt;. To do this, call the &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/sorted-with&quot;&gt;&lt;code&gt;sortedWith()&lt;/code&gt;&lt;/a&gt; function passing in your &lt;code&gt;Comparator&lt;/code&gt;. With this function, sorting strings by their length looks like this:</source>
          <target state="translated">콜렉션 정렬에 대한 사용자 정의 순서를 정의하기 위해 고유 한 &lt;code&gt;Comparator&lt;/code&gt; 를 제공 할 수 있습니다 . 이렇게하려면 &lt;code&gt;Comparator&lt;/code&gt; 에 전달 된 &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/sorted-with&quot;&gt; &lt;code&gt;sortedWith()&lt;/code&gt; &lt;/a&gt; 함수를 호출하십시오 . 이 함수를 사용하면 문자열을 길이별로 정렬하면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="76c4ad66d01d81d2c13dd0f6fd9cbde76bdd69dd" translate="yes" xml:space="preserve">
          <source>To define a custom progression step, use the &lt;code&gt;step&lt;/code&gt; function on a range.</source>
          <target state="translated">사용자 정의 진행 단계를 정의하려면 범위 에서 &lt;code&gt;step&lt;/code&gt; 함수를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="e3c595e055a9ae116f425f8291258d8dc6632df5" translate="yes" xml:space="preserve">
          <source>To define a natural order for a user-defined type, make the type an inheritor of &lt;code&gt;Comparable&lt;/code&gt;. This requires implementing the &lt;code&gt;compareTo()&lt;/code&gt; function. &lt;code&gt;compareTo()&lt;/code&gt; must take another object of the same type as an argument and return an integer value showing which object is greater:</source>
          <target state="translated">사용자 정의 형식의 자연스러운 순서를 정의하려면 형식을 &lt;code&gt;Comparable&lt;/code&gt; 의 상속자로 만드십시오 . &lt;code&gt;compareTo()&lt;/code&gt; 함수를 구현해야 합니다. &lt;code&gt;compareTo()&lt;/code&gt; 는 인수와 동일한 유형의 다른 객체를 가져 와서 더 큰 객체를 나타내는 정수 값을 반환해야합니다.</target>
        </trans-unit>
        <trans-unit id="e9143cabd73a5291d802c769a81ee627bbb5733e" translate="yes" xml:space="preserve">
          <source>To denote the current &lt;em&gt;receiver&lt;/em&gt;, we use &lt;em&gt;this&lt;/em&gt; expressions:</source>
          <target state="translated">현재 &lt;em&gt;수신자&lt;/em&gt; 를 나타 내기 위해 &lt;em&gt;다음&lt;/em&gt; 표현식 을 사용 &lt;em&gt;합니다&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="370aeed576ab8358f729a92b8f556723486b4edb" translate="yes" xml:space="preserve">
          <source>To deploy Kotlin applications on &lt;a href=&quot;https://www.heroku.com&quot;&gt;Heroku&lt;/a&gt;, you can follow the &lt;a href=&quot;https://devcenter.heroku.com/articles/getting-started-with-kotlin&quot;&gt;official Heroku tutorial&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;https://www.heroku.com&quot;&gt;Heroku&lt;/a&gt; 에 Kotlin 응용 프로그램을 배포하려면 &lt;a href=&quot;https://devcenter.heroku.com/articles/getting-started-with-kotlin&quot;&gt;공식 Heroku 튜토리얼을&lt;/a&gt; 따르십시오 .</target>
        </trans-unit>
        <trans-unit id="771653f64e2b72ee994da136292e2bfcc37a8770" translate="yes" xml:space="preserve">
          <source>To disable the caching for all Kotlin tasks, set the system property flag &lt;code&gt;kotlin.caching.enabled&lt;/code&gt; to &lt;code&gt;false&lt;/code&gt; (run the build with the argument &lt;code&gt;-Dkotlin.caching.enabled=false&lt;/code&gt;).</source>
          <target state="translated">모든 Kotlin 태스크에 대한 캐싱을 사용하지 않으려면 시스템 특성 플래그 &lt;code&gt;kotlin.caching.enabled&lt;/code&gt; 를 &lt;code&gt;false&lt;/code&gt; 로 설정하십시오 (인수 &lt;code&gt;-Dkotlin.caching.enabled=false&lt;/code&gt; 로 빌드를 실행하십시오 ).</target>
        </trans-unit>
        <trans-unit id="5fb61a8c9c6d11d2594861df1a6ec31dd25d8561" translate="yes" xml:space="preserve">
          <source>To eliminate the risk of such incompatibility being introduced by a change in &lt;strong&gt;non&lt;/strong&gt;-public API of a module, the public API inline functions are not allowed to use non-public-API declarations, i.e. &lt;code&gt;private&lt;/code&gt; and &lt;code&gt;internal&lt;/code&gt; declarations and their parts, in their bodies.</source>
          <target state="translated">이러한 호환성이의 변화에 의해 도입되는 위험 제거하기 위해 &lt;strong&gt;비&lt;/strong&gt; 모듈의 -public API를 공개 API의 인라인 함수는 비공개-API 선언, 즉 사용 할 수 없습니다 &lt;code&gt;private&lt;/code&gt; 및 &lt;code&gt;internal&lt;/code&gt; 몸에, 선언과 그 부품 .</target>
        </trans-unit>
        <trans-unit id="2defcf6d3a2e2a6242b791d65c0bc5e944e6db59" translate="yes" xml:space="preserve">
          <source>To enable Kotlin OSGi support you need to include &lt;code&gt;kotlin-osgi-bundle&lt;/code&gt; instead of regular Kotlin libraries. It is recommended to remove &lt;code&gt;kotlin-runtime&lt;/code&gt;, &lt;code&gt;kotlin-stdlib&lt;/code&gt; and &lt;code&gt;kotlin-reflect&lt;/code&gt; dependencies as &lt;code&gt;kotlin-osgi-bundle&lt;/code&gt; already contains all of them. You also should pay attention in case when external Kotlin libraries are included. Most regular Kotlin dependencies are not OSGi-ready, so you shouldn't use them and should remove them from your project.</source>
          <target state="translated">Kotlin OSGi 지원을 활성화하려면 일반 Kotlin 라이브러리 대신 &lt;code&gt;kotlin-osgi-bundle&lt;/code&gt; 을 포함해야합니다 . &lt;code&gt;kotlin-osgi-bundle&lt;/code&gt; 에 이미 모든 것이 포함되어 있으므로 &lt;code&gt;kotlin-runtime&lt;/code&gt; , &lt;code&gt;kotlin-stdlib&lt;/code&gt; 및 &lt;code&gt;kotlin-reflect&lt;/code&gt; 종속성 을 제거하는 것이 좋습니다 . 외부 Kotlin 라이브러리가 포함 된 경우에도주의해야합니다. 대부분의 일반적인 Kotlin 종속성은 OSGi를 지원하지 않으므로이를 사용해서는 안되며 프로젝트에서 제거해야합니다.</target>
        </trans-unit>
        <trans-unit id="6eb3341f99fe9ebb8d9323c290933247870fe5f7" translate="yes" xml:space="preserve">
          <source>To enable incremental annotation processing, add this line to your &lt;code&gt;gradle.properties&lt;/code&gt; file:</source>
          <target state="translated">증분 주석 처리를 사용하려면 &lt;code&gt;gradle.properties&lt;/code&gt; 파일에 다음 행을 추가 하십시오.</target>
        </trans-unit>
        <trans-unit id="6dbd033e65a082aad28e5c2fcd37b8daf6829885" translate="yes" xml:space="preserve">
          <source>To enable this behavior you need to have &lt;code&gt;kotlin-stdlib-jdk7&lt;/code&gt; in your dependencies.</source>
          <target state="translated">이 동작을 사용하려면 종속성에 &lt;code&gt;kotlin-stdlib-jdk7&lt;/code&gt; 이 있어야 합니다.</target>
        </trans-unit>
        <trans-unit id="1b92d03d7ab798afc0052aefc2671aaf31759d48" translate="yes" xml:space="preserve">
          <source>To enable this, inline functions support &lt;em&gt;reified type parameters&lt;/em&gt;, so we can write something like this:</source>
          <target state="translated">이를 가능하게하기 위해 인라인 함수는 &lt;em&gt;reified type parameters를&lt;/em&gt; 지원 하므로 다음과 같이 작성할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="eda2f16c079bedddcf43889e299a4aeef442f108" translate="yes" xml:space="preserve">
          <source>To ensure consistency and meaningful behavior of the generated code, data classes have to fulfill the following requirements:</source>
          <target state="translated">생성 된 코드의 일관성과 의미있는 동작을 보장하기 위해 데이터 클래스는 다음 요구 사항을 충족해야합니다.</target>
        </trans-unit>
        <trans-unit id="1915a0468ec60c04f19505bbcc82c60fb33083b3" translate="yes" xml:space="preserve">
          <source>To evaluate each particular expression in a scratch, run it with &lt;strong&gt;Use REPL&lt;/strong&gt; selected. The scratch will be executed the same way as in &lt;a href=&quot;#repl&quot;&gt;REPL&lt;/a&gt;: the code lines will run subsequently, providing results of each call. You can later refer to the results by the names &lt;code&gt;res*&lt;/code&gt; shown in the corresponding lines.</source>
          <target state="translated">스크래치로 각 특정 표현식을 평가하려면 &lt;strong&gt;Use REPL을&lt;/strong&gt; 선택한 상태 에서 실행 &lt;strong&gt;하십시오&lt;/strong&gt; . 스크래치는 &lt;a href=&quot;#repl&quot;&gt;REPL&lt;/a&gt; 과 같은 방식으로 실행됩니다. 코드 라인은 이후에 실행되어 각 호출의 결과를 제공합니다. 나중에 해당 줄에 표시된 &lt;code&gt;res*&lt;/code&gt; 라는 이름으로 결과를 참조 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="94918723afeacff1efa16ca8ab355a3ef8c400e9" translate="yes" xml:space="preserve">
          <source>To exclude default Kotlin libraries that comes as transitive dependencies you can use the following approach:</source>
          <target state="translated">전이 의존성으로 제공되는 기본 Kotlin 라이브러리를 제외하려면 다음 접근법을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="dfe13659cc9bfcece191e4b8535987313b947937" translate="yes" xml:space="preserve">
          <source>To exclude the standard library from external libraries (notice that &quot;star exclusion&quot; works in Maven 3 only):</source>
          <target state="translated">외부 라이브러리에서 표준 라이브러리를 제외하려면 ( &quot;스타 제외&quot;는 Maven 3에서만 작동합니다.)</target>
        </trans-unit>
        <trans-unit id="07af8a09aee36adfe68b2b0a1b6017022afe11a3" translate="yes" xml:space="preserve">
          <source>To facilitate this, Kotlin, as a statically typed programming language, uses a family of &lt;a href=&quot;#function-types&quot;&gt;function types&lt;/a&gt; to represent functions and provides a set of specialized language constructs, such as &lt;a href=&quot;#lambda-expressions-and-anonymous-functions&quot;&gt;lambda expressions&lt;/a&gt;.</source>
          <target state="translated">이를 용이하게하기 위해 Kotlin은 정적으로 유형이 지정된 프로그래밍 언어로서 &lt;a href=&quot;#function-types&quot;&gt;함수 유형&lt;/a&gt; 을 사용하여 함수 를 나타내고 &lt;a href=&quot;#lambda-expressions-and-anonymous-functions&quot;&gt;람다 식과&lt;/a&gt; 같은 특수 언어 구조 세트를 제공합니다 .</target>
        </trans-unit>
        <trans-unit id="6f3dc2eba2ee9bd47ab354f073c6c2fcb6b42573" translate="yes" xml:space="preserve">
          <source>To filter collections by negative conditions, use &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/filter-not&quot;&gt;&lt;code&gt;filterNot()&lt;/code&gt;&lt;/a&gt;. It returns a list of elements for which the predicate yields &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">부정적인 조건으로 콜렉션을 필터링하려면 &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/filter-not&quot;&gt; &lt;code&gt;filterNot()&lt;/code&gt; &lt;/a&gt; 사용 하십시오 . 술어가 &lt;code&gt;false&lt;/code&gt; 를 산출하는 요소의리스트를 돌려줍니다 .</target>
        </trans-unit>
        <trans-unit id="70215058b180f374e26cdfcf334f5153e68b392f" translate="yes" xml:space="preserve">
          <source>To find an intersection between two collections (elements present in both of them), use &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/intersect&quot;&gt;&lt;code&gt;intersect()&lt;/code&gt;&lt;/a&gt;. To find collection elements not present in another collection, use &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/subtract&quot;&gt;&lt;code&gt;subtract()&lt;/code&gt;&lt;/a&gt;. Both these functions can be called in the infix form as well, for example, &lt;code&gt;a intersect b&lt;/code&gt;.</source>
          <target state="translated">두 컬렉션 (둘 다에있는 요소) 사이의 교차점을 찾으려면 &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/intersect&quot;&gt; &lt;code&gt;intersect()&lt;/code&gt; &lt;/a&gt; . 다른 컬렉션에없는 컬렉션 요소를 찾으려면 &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/subtract&quot;&gt; &lt;code&gt;subtract()&lt;/code&gt; &lt;/a&gt; . 이 두 함수는 모두 예를 들어 &lt;code&gt;a intersect b&lt;/code&gt; 와 같이 삽입 형식으로 호출 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="9c38d615ff41226343f4fd39898bb931c04a0136" translate="yes" xml:space="preserve">
          <source>To find out how to start using Kotlin for JavaScript, please refer to the &lt;a href=&quot;../tutorials/javascript/kotlin-to-javascript/kotlin-to-javascript&quot;&gt;tutorials&lt;/a&gt;.</source>
          <target state="translated">JavaScript에 Kotlin을 사용하는 방법을 알아 보려면 &lt;a href=&quot;../tutorials/javascript/kotlin-to-javascript/kotlin-to-javascript&quot;&gt;학습서&lt;/a&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="e1b3025669d14b930eb88a22f129712b45d175de" translate="yes" xml:space="preserve">
          <source>To fix this, we have to declare objects of type &lt;code&gt;Source&amp;lt;? extends Object&amp;gt;&lt;/code&gt;, which is sort of meaningless, because we can call all the same methods on such a variable as before, so there's no value added by the more complex type. But the compiler does not know that.</source>
          <target state="translated">이 문제를 해결하려면 &lt;code&gt;Source&amp;lt;? extends Object&amp;gt;&lt;/code&gt; 유형의 객체를 선언해야합니다 . 우리는 이전과 같은 변수에 대해 동일한 메소드를 모두 호출 할 수 있으므로 더 복잡한 유형에 의해 추가 된 값이 없기 때문에 의미가없는 Object&amp;gt;를 확장 합니다. 그러나 컴파일러는 그것을 모른다.</target>
        </trans-unit>
        <trans-unit id="1c3ed2671d90a6fccce18fdda0d98b5b6f90b98a" translate="yes" xml:space="preserve">
          <source>To generate documentation for Kotlin projects, use &lt;a href=&quot;https://github.com/Kotlin/dokka&quot;&gt;Dokka&lt;/a&gt;; please refer to the &lt;a href=&quot;https://github.com/Kotlin/dokka/blob/master/README.md#using-the-gradle-plugin&quot;&gt;Dokka README&lt;/a&gt; for configuration instructions. Dokka supports mixed-language projects and can generate output in multiple formats, including standard JavaDoc.</source>
          <target state="translated">Kotlin 프로젝트에 대한 문서를 생성하려면 &lt;a href=&quot;https://github.com/Kotlin/dokka&quot;&gt;Dokka를&lt;/a&gt; 사용하십시오 . 구성 지침 은 &lt;a href=&quot;https://github.com/Kotlin/dokka/blob/master/README.md#using-the-gradle-plugin&quot;&gt;Dokka README&lt;/a&gt; 를 참조하십시오 . Dokka는 혼합 언어 프로젝트를 지원하며 표준 JavaDoc을 포함하여 여러 형식으로 출력을 생성 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4da5847f3384d7a88c1adee061594df4e30b80fc" translate="yes" xml:space="preserve">
          <source>To get a seeded instance of random generator use &lt;a href=&quot;index&quot;&gt;Random&lt;/a&gt; function.</source>
          <target state="translated">랜덤 생성기의 시드 인스턴스를 얻으려면 &lt;a href=&quot;index&quot;&gt;랜덤&lt;/a&gt; 함수를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="004366928e90c7cdc731785eae1ab45f89c2dc1a" translate="yes" xml:space="preserve">
          <source>To get started, install a recent version of IntelliJ IDEA. Kotlin is bundled with IntelliJ IDEA starting from version 15. You can download the free &lt;a href=&quot;http://www.jetbrains.com/idea/download/index.html&quot;&gt;Community Edition&lt;/a&gt; from &lt;a href=&quot;http://www.jetbrains.com&quot;&gt;JetBrains&lt;/a&gt;.</source>
          <target state="translated">시작하려면 최신 버전의 IntelliJ IDEA를 설치하십시오. Kotlin은 버전 15부터 IntelliJ IDEA와 번들로 제공됩니다 . &lt;a href=&quot;http://www.jetbrains.com&quot;&gt;JetBrains&lt;/a&gt; 에서 무료 &lt;a href=&quot;http://www.jetbrains.com/idea/download/index.html&quot;&gt;Community Edition&lt;/a&gt; 을 다운로드 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="94da0b750a9691183cd3aef14a71ddcee794f57c" translate="yes" xml:space="preserve">
          <source>To get the Kotlin class corresponding to a Java class, use the &lt;code&gt;.kotlin&lt;/code&gt; extension property:</source>
          <target state="translated">Java 클래스에 해당하는 Kotlin 클래스를 가져 오려면 &lt;code&gt;.kotlin&lt;/code&gt; 확장 등록 정보를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="03f3657fbd7420151d7cbee074c2f638231666dd" translate="yes" xml:space="preserve">
          <source>To get the pointer, &lt;code&gt;.cstr&lt;/code&gt; should be allocated in native memory, e.g.</source>
          <target state="translated">포인터를 얻으려면 &lt;code&gt;.cstr&lt;/code&gt; 을 기본 메모리에 할당해야합니다.</target>
        </trans-unit>
        <trans-unit id="99f419fbdc788d8ad3548e218e2e9d1a31e1f757" translate="yes" xml:space="preserve">
          <source>To get the specified number of elements starting from the first, use the &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/take&quot;&gt;&lt;code&gt;take()&lt;/code&gt;&lt;/a&gt; function. For getting the last elements, use &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/take-last&quot;&gt;&lt;code&gt;takeLast()&lt;/code&gt;&lt;/a&gt;. When called with a number larger than the collection size, both functions return the whole collection.</source>
          <target state="translated">처음부터 지정된 수의 요소를 가져 오려면 &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/take&quot;&gt; &lt;code&gt;take()&lt;/code&gt; &lt;/a&gt; 함수를 사용하십시오 . 마지막 요소를 얻으려면 &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/take-last&quot;&gt; &lt;code&gt;takeLast()&lt;/code&gt; &lt;/a&gt; 사용 하십시오 . 컬렉션 크기보다 큰 숫자로 호출하면 두 함수가 전체 컬렉션을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="7c882c6a497d3655af358c59177443fd4abbe265" translate="yes" xml:space="preserve">
          <source>To handle this case, you can mark the property with the &lt;code&gt;lateinit&lt;/code&gt; modifier:</source>
          <target state="translated">이 경우를 처리하기 위해 &lt;code&gt;lateinit&lt;/code&gt; 수정자를 사용 하여 특성을 표시 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="f184ea8aba5991e48a265c7b37cae24a3a756b30" translate="yes" xml:space="preserve">
          <source>To have a dependency-injected implementation generated for the type, annotate it with &lt;code&gt;@Component&lt;/code&gt;. The generated class will have the name of this type prepended with Dagger, like &lt;code&gt;DaggerCoffeeShop&lt;/code&gt; below:</source>
          <target state="translated">유형에 대해 의존성 주입 구현을 생성하려면 &lt;code&gt;@Component&lt;/code&gt; 로 주석을 답니다 . 생성 된 클래스의 이름은 아래 &lt;code&gt;DaggerCoffeeShop&lt;/code&gt; 과 같이 Dagger가 앞에 붙습니다 .</target>
        </trans-unit>
        <trans-unit id="3ecd027b7452270691e59717236b30ee0ecf96d4" translate="yes" xml:space="preserve">
          <source>To help removing deprecated API gradually, the property &lt;a href=&quot;level#kotlin.Deprecated%24level&quot;&gt;level&lt;/a&gt; could be used. Usually a gradual phase-out goes through the &quot;warning&quot;, then &quot;error&quot;, then &quot;hidden&quot; or &quot;removed&quot; stages:</source>
          <target state="translated">더 이상 사용되지 않는 API를 점진적으로 제거하기 위해 특성 &lt;a href=&quot;level#kotlin.Deprecated%24level&quot;&gt;레벨&lt;/a&gt; 을 사용할 수 있습니다. 일반적으로 점진적인 단계적 종료는 &quot;경고&quot;, &quot;오류&quot;, &quot;숨김&quot;또는 &quot;제거&quot;단계를 거칩니다.</target>
        </trans-unit>
        <trans-unit id="bc69b946016a4baffee197957d550f5dda1d3fad" translate="yes" xml:space="preserve">
          <source>To help you choose the right scope function for your case, we'll describe them in detail and provide usage recommendations. Technically, functions are interchangeable in many cases, so the examples show the conventions that define the common usage style.</source>
          <target state="translated">귀하의 사례에 적합한 스코프 기능을 선택하는 데 도움을 드리기 위해 해당 기능을 자세히 설명하고 사용 권장 사항을 제공합니다. 기술적으로 함수는 여러 경우에 상호 교환이 가능하므로 예제는 일반적인 사용 스타일을 정의하는 규칙을 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="2dc9569e913e0a78f05976a0042b79260268c830" translate="yes" xml:space="preserve">
          <source>To help you choose the right scope function for your purpose, we provide the table of key differences between them.</source>
          <target state="translated">목적에 맞는 올바른 스코프 기능을 선택할 수 있도록 주요 차이점 표를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="3bc65688182a6a956a218fa3a16959313490f82c" translate="yes" xml:space="preserve">
          <source>To import a Kotlin/Native module in an existing Xcode project:</source>
          <target state="translated">기존 Xcode 프로젝트에서 Kotlin / Native 모듈을 가져 오려면 :</target>
        </trans-unit>
        <trans-unit id="2c68721c967bf9f85180daa4363543c530c2e36a" translate="yes" xml:space="preserve">
          <source>To import this module in Kotlin, you have to write two Kotlin source files:</source>
          <target state="translated">Kotlin에서이 모듈을 가져 오려면 두 개의 Kotlin 소스 파일을 작성해야합니다.</target>
        </trans-unit>
        <trans-unit id="6c82d374c6d84bb2e142c6de52f1cf3dcc0306ae" translate="yes" xml:space="preserve">
          <source>To improve the behavior in such cases, Kotlin 1.3 introduces experimental mechanism called &lt;em&gt;contracts&lt;/em&gt;.</source>
          <target state="translated">이러한 경우 동작을 개선하기 위해 Kotlin 1.3에는 &lt;em&gt;계약&lt;/em&gt; 이라는 실험 메커니즘이 도입되었습니다 .</target>
        </trans-unit>
        <trans-unit id="2d833a47bb81067eedcf42dfefd225e6c4221741" translate="yes" xml:space="preserve">
          <source>To improve the speed of builds that use kapt, you can enable the &lt;a href=&quot;https://guides.gradle.org/using-the-worker-api/&quot;&gt;Gradle worker API&lt;/a&gt; for kapt tasks. Using the worker API lets Gradle run independent annotation processing tasks from a single project in parallel, which in some cases significantly decreases the execution time. However, running kapt with Gradle worker API enabled can result in increased memory consumption due to parallel execution.</source>
          <target state="translated">kapt를 사용하는 빌드 속도를 향상시키기 위해 &lt;a href=&quot;https://guides.gradle.org/using-the-worker-api/&quot;&gt;Gradle worker API&lt;/a&gt; 를 kapt 작업에 사용할 수 있습니다. 작업자 API를 사용하면 Gradle이 단일 프로젝트에서 독립적 인 주석 처리 작업을 병렬로 실행할 수 있으므로 경우에 따라 실행 시간이 크게 단축됩니다. 그러나 Gradle worker API가 활성화 된 상태에서 kapt를 실행하면 병렬 실행으로 인해 메모리 소비가 증가 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="068fdab62a2284b03b98013c61f3a69a95e920c0" translate="yes" xml:space="preserve">
          <source>To improve the times of incremental builds with kapt, it can use the Gradle &lt;a href=&quot;https://docs.gradle.org/current/userguide/java_plugin.html#sec:java_compile_avoidance&quot;&gt;compile avoidance&lt;/a&gt;. With compile avoidance enabled, Gradle can skip annotation processing when rebuilding a project. Particularly, annotation processing is skipped when:</source>
          <target state="translated">kapt를 사용한 증분 빌드 시간을 향상시키기 위해 Gradle &lt;a href=&quot;https://docs.gradle.org/current/userguide/java_plugin.html#sec:java_compile_avoidance&quot;&gt;컴파일 방지를&lt;/a&gt; 사용할 수 있습니다 . 컴파일 회피를 사용하면 Gradle은 프로젝트를 다시 빌드 할 때 주석 처리를 건너 뛸 수 있습니다. 특히 다음과 같은 경우 주석 처리를 건너 뜁니다.</target>
        </trans-unit>
        <trans-unit id="ccaf04d3ae02444add2457f45cff16183d2e8aae" translate="yes" xml:space="preserve">
          <source>To include &lt;code&gt;kotlin-osgi-bundle&lt;/code&gt; to a gradle project:</source>
          <target state="translated">&lt;code&gt;kotlin-osgi-bundle&lt;/code&gt; 을 gradle 프로젝트에 포함 시키 려면 :</target>
        </trans-unit>
        <trans-unit id="9a00cb17d9820854213a41158d7418355d4b5911" translate="yes" xml:space="preserve">
          <source>To include Java sources in the compilations of a JVM target, or to apply a Gradle plugin that requires the &lt;code&gt;java&lt;/code&gt; plugin to work, you need to explicitly enable Java support for the target:</source>
          <target state="translated">JVM 대상 컴파일에 Java 소스를 포함 시키거나 &lt;code&gt;java&lt;/code&gt; 플러그인이 작동해야하는 Gradle 플러그인을 적용하려면 대상에 대한 Java 지원을 명시 적으로 활성화해야합니다.</target>
        </trans-unit>
        <trans-unit id="7860a6aaa1b42e9447caa0f0a8321e9d88a64124" translate="yes" xml:space="preserve">
          <source>To include the Kotlin OSGi bundle to a Maven project:</source>
          <target state="translated">Kotlin OSGi 번들을 Maven 프로젝트에 포함 시키려면 다음을 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="077956d227f2aa6078ddf39bc8e4e3d8b94732b8" translate="yes" xml:space="preserve">
          <source>To inspect the bookkeeping details of the library</source>
          <target state="translated">라이브러리의 부기 세부 정보를 검사하려면</target>
        </trans-unit>
        <trans-unit id="8c24292aeea43558882c36e9ecc631d06e7467b2" translate="yes" xml:space="preserve">
          <source>To install the library to the default location use</source>
          <target state="translated">라이브러리를 기본 위치에 설치하려면</target>
        </trans-unit>
        <trans-unit id="24f6533d6772f8462ed0f43822595fdca8aa6a25" translate="yes" xml:space="preserve">
          <source>To iterate a number range which does not include its end element, use the &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.ranges/until&quot;&gt;&lt;code&gt;until&lt;/code&gt;&lt;/a&gt; function:</source>
          <target state="translated">끝 요소를 포함하지 않는 숫자 범위를 반복하려면 &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.ranges/until&quot;&gt; &lt;code&gt;until&lt;/code&gt; &lt;/a&gt; 함수를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="b66d0a5358d7d3838074096ed7a34f595b79a041" translate="yes" xml:space="preserve">
          <source>To iterate numbers in reverse order, use the &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.ranges/down-to&quot;&gt;&lt;code&gt;downTo&lt;/code&gt;&lt;/a&gt; function instead of &lt;code&gt;..&lt;/code&gt;.</source>
          <target state="translated">숫자를 역순으로 반복하려면 &lt;code&gt;..&lt;/code&gt; 대신 &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.ranges/down-to&quot;&gt; &lt;code&gt;downTo&lt;/code&gt; &lt;/a&gt; 함수를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="4de33c40021cd7f879768e42f24ff227ac1b5363" translate="yes" xml:space="preserve">
          <source>To iterate over a range of numbers, use a &lt;a href=&quot;ranges&quot;&gt;range expression&lt;/a&gt;:</source>
          <target state="translated">숫자 범위를 반복하려면 &lt;a href=&quot;ranges&quot;&gt;범위 표현식을&lt;/a&gt; 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="85b39f1ed38fbcb7ba7bf0ac158a30f9c142955c" translate="yes" xml:space="preserve">
          <source>To link to a library use the &lt;code&gt;-library &amp;lt;name&amp;gt;&lt;/code&gt; or &lt;code&gt;-l &amp;lt;name&amp;gt;&lt;/code&gt; flag. For example:</source>
          <target state="translated">라이브러리에 링크하려면 &lt;code&gt;-library &amp;lt;name&amp;gt;&lt;/code&gt; 또는 &lt;code&gt;-l &amp;lt;name&amp;gt;&lt;/code&gt; 플래그를 사용하십시오. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="5d43d923015e08ab71364c00b4d2a9fc351e1604" translate="yes" xml:space="preserve">
          <source>To link to another element (class, method, property or parameter), simply put its name in square brackets:</source>
          <target state="translated">다른 요소 (클래스, 메서드, 속성 또는 매개 변수)에 연결하려면 해당 이름을 대괄호로 묶습니다.</target>
        </trans-unit>
        <trans-unit id="04523bc3328b0c5397fbfdee046da0685d0fae03" translate="yes" xml:space="preserve">
          <source>To list library contents:</source>
          <target state="translated">라이브러리 내용을 나열하려면</target>
        </trans-unit>
        <trans-unit id="94d09a96d064da30ca57cf8cdc79fa8ea3d9ad9e" translate="yes" xml:space="preserve">
          <source>To maintain indentation in multiline strings, use &lt;code&gt;trimIndent&lt;/code&gt; when the resulting string does not require any internal indentation, or &lt;code&gt;trimMargin&lt;/code&gt; when internal indentation is required:</source>
          <target state="translated">여러 줄 문자열에서 들여 쓰기를 사용 유지하기 위해 &lt;code&gt;trimIndent&lt;/code&gt; 을 결과 문자열은 내부 들여 쓰기를 요구하거나하지 않는 경우 &lt;code&gt;trimMargin&lt;/code&gt; 를 내부 들여 쓰기가 필요한 경우 :</target>
        </trans-unit>
        <trans-unit id="e12b1be94182f1503207932a398c53d947b434c0" translate="yes" xml:space="preserve">
          <source>To make Kotlin APIs work in Java we generate &lt;code&gt;Box&amp;lt;Super&amp;gt;&lt;/code&gt; as &lt;code&gt;Box&amp;lt;? extends Super&amp;gt;&lt;/code&gt; for covariantly defined &lt;code&gt;Box&lt;/code&gt; (or &lt;code&gt;Foo&amp;lt;? super Bar&amp;gt;&lt;/code&gt; for contravariantly defined &lt;code&gt;Foo&lt;/code&gt;) when it appears &lt;em&gt;as a parameter&lt;/em&gt;. When it's a return value, we don't generate wildcards, because otherwise Java clients will have to deal with them (and it's against the common Java coding style). Therefore, the functions from our example are actually translated as follows:</source>
          <target state="translated">Kotlin API를 Java에서 작동하게하려면 &lt;code&gt;Box&amp;lt;Super&amp;gt;&lt;/code&gt; 를 &lt;code&gt;Box&amp;lt;? extends Super&amp;gt;&lt;/code&gt; covariantly 정의에 대한 &lt;code&gt;Box&lt;/code&gt; (또는 &lt;code&gt;Foo&amp;lt;? super Bar&amp;gt;&lt;/code&gt; contravariantly 정의에 대한 &lt;code&gt;Foo&lt;/code&gt; )가 나타날 때 &lt;em&gt;매개 변수로&lt;/em&gt; . 반환 값일 때는 와일드 카드를 생성하지 않습니다. 그렇지 않으면 Java 클라이언트가 처리해야합니다 (그리고 일반적인 Java 코딩 스타일에 위배됩니다). 따라서이 예제의 함수는 실제로 다음과 같이 변환됩니다.</target>
        </trans-unit>
        <trans-unit id="1aa213848d1f87a73fda0915bb91fbde0ccc8072" translate="yes" xml:space="preserve">
          <source>To make reading the input in competitive programming tasks like this more concise, you can have the following list of helper input-reading functions:</source>
          <target state="translated">이와 같이 경쟁력있는 프로그래밍 작업에서 입력을보다 간결하게 작성하려면 다음과 같은 도우미 입력 판독 기능 목록을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9375e20c00ff62d1ddedd02075c0f25b2cc018c0" translate="yes" xml:space="preserve">
          <source>To make the compiler do this, we need to mark the &lt;code&gt;lock()&lt;/code&gt; function with the &lt;code&gt;inline&lt;/code&gt; modifier:</source>
          <target state="translated">컴파일러에서이를 수행하려면 &lt;code&gt;lock()&lt;/code&gt; 함수를 &lt;code&gt;inline&lt;/code&gt; 수정 자로 표시해야합니다 .</target>
        </trans-unit>
        <trans-unit id="27c1b74df654000c9e62d4a18ccabc7efde139c9" translate="yes" xml:space="preserve">
          <source>To make the compiler start controlling scopes we only have to annotate the types of all receivers used in the DSL with the same marker annotation. For instance, for HTML Builders we declare an annotation &lt;code&gt;@HTMLTagMarker&lt;/code&gt;:</source>
          <target state="translated">컴파일러가 범위 제어를 시작하게하려면 DSL에 사용 된 모든 수신기 유형에 동일한 표식 주석을 달기 만하면됩니다. 예를 들어 HTML 빌더의 경우 &lt;code&gt;@HTMLTagMarker&lt;/code&gt; 주석을 선언합니다 .</target>
        </trans-unit>
        <trans-unit id="28e2c451a4401d778b575e3ce27ab0a72af2a6e7" translate="yes" xml:space="preserve">
          <source>To make the library complete we should write some tests, but we have three independent implementations and it is a waste of time to write duplicate tests for each one. The good thing about common code is that it can be covered with common tests, which later are compiled and executed on &lt;em&gt;every&lt;/em&gt; platform. All the bits for testing are already generated by the project Wizard.</source>
          <target state="translated">라이브러리를 완성하려면 몇 가지 테스트를 작성해야하지만 3 개의 독립적 인 구현이 있으며 각 테스트마다 중복 테스트를 작성하는 것은 시간 낭비입니다. 공통 코드에 대한 좋은 점은 공통 테스트로 다룰 수 있다는 것입니다.이 테스트는 나중에 &lt;em&gt;모든&lt;/em&gt; 플랫폼 에서 컴파일되고 실행됩니다 . 테스트를위한 모든 비트는 이미 프로젝트 마법사에 의해 생성되었습니다.</target>
        </trans-unit>
        <trans-unit id="942a849d5ea3976160d1c1dbff01132e386b6a13" translate="yes" xml:space="preserve">
          <source>To make this work, we should</source>
          <target state="translated">이 작업을 수행하려면</target>
        </trans-unit>
        <trans-unit id="c619d626cb3800fca0e85916c367e7240cf3f525" translate="yes" xml:space="preserve">
          <source>To make unsigned integers easier to use, Kotlin provides an ability to tag an integer literal with a suffix indicating a specific unsigned type (similarly to Float/Long):</source>
          <target state="translated">부호없는 정수를보다 쉽게 ​​사용할 수 있도록 Kotlin은 부호없는 특정 유형 (Float / Long과 유사)을 나타내는 접미어로 정수 리터럴에 태그를 지정하는 기능을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="c98bfc3140cd7bdf91e45deb511c924efadd9a92" translate="yes" xml:space="preserve">
          <source>To make your builds faster, you can enable incremental compilation for Maven (supported since Kotlin 1.1.2). In order to do that, define the &lt;code&gt;kotlin.compiler.incremental&lt;/code&gt; property:</source>
          <target state="translated">보다 빠른 빌드를 위해 Maven에 대한 증분 컴파일을 활성화 할 수 있습니다 (Kotlin 1.1.2부터 지원). 그렇게하려면 &lt;code&gt;kotlin.compiler.incremental&lt;/code&gt; 속성을 정의하십시오 .</target>
        </trans-unit>
        <trans-unit id="2895b62f37c528355f502b2144c9b302d5145a42" translate="yes" xml:space="preserve">
          <source>To manually compile the application call the &lt;a href=&quot;https://github.com/JetBrains/kotlin/releases&quot;&gt;downloaded&lt;/a&gt; compiler and generate a &lt;code&gt;hello.kexe&lt;/code&gt; (Linux and macOS) or &lt;code&gt;hello.exe&lt;/code&gt; (Windows) binary file:</source>
          <target state="translated">애플리케이션을 수동으로 컴파일하려면 &lt;a href=&quot;https://github.com/JetBrains/kotlin/releases&quot;&gt;다운로드 한&lt;/a&gt; 컴파일러를 호출하고 &lt;code&gt;hello.kexe&lt;/code&gt; (Linux 및 macOS) 또는 &lt;code&gt;hello.exe&lt;/code&gt; (Windows) 이진 파일을 생성하십시오.</target>
        </trans-unit>
        <trans-unit id="b4f6cb9f672ef57783a6ef29cd59db4418575608" translate="yes" xml:space="preserve">
          <source>To mark an API element as experimental, annotate its declaration with your experimental marker annotation:</source>
          <target state="translated">API 요소를 실험으로 표시하려면 실험 마커 주석으로 선언에 주석을 답니다.</target>
        </trans-unit>
        <trans-unit id="cb122bda7a14229a5d1edd9ff546275f891b9d77" translate="yes" xml:space="preserve">
          <source>To merge two collections into one, use the &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/union&quot;&gt;&lt;code&gt;union()&lt;/code&gt;&lt;/a&gt; function. It can be used in the infix form &lt;code&gt;a union b&lt;/code&gt;. Note that for ordered collections the order of the operands is important: in the resulting collection, the elements of the first operand go before the elements of the second.</source>
          <target state="translated">두 컬렉션을 하나로 병합하려면 &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/union&quot;&gt; &lt;code&gt;union()&lt;/code&gt; &lt;/a&gt; 함수를 사용하십시오 . 접두사 형태 &lt;code&gt;a union b&lt;/code&gt; 로 사용될 수 있습니다 . 정렬 된 컬렉션의 경우 피연산자의 순서가 중요합니다. 결과 컬렉션에서는 첫 번째 피연산자의 요소가 두 번째 피연산자의 요소보다 우선합니다.</target>
        </trans-unit>
        <trans-unit id="44d5c2b36c84b91934a121e2f5ace6e150a12f1e" translate="yes" xml:space="preserve">
          <source>To mitigate such issues, functions using inline classes are &lt;em&gt;mangled&lt;/em&gt; by adding some stable hashcode to the function name. Therefore, &lt;code&gt;fun compute(x: UInt)&lt;/code&gt; will be represented as &lt;code&gt;public final void compute-&amp;lt;hashcode&amp;gt;(int x)&lt;/code&gt;, which solves the clash problem.</source>
          <target state="translated">이러한 문제를 완화하기 위해 인라인 클래스를 사용 하는 함수는 함수 이름에 안정적인 해시 코드를 추가하여 &lt;em&gt;엉망&lt;/em&gt; 입니다. 따라서 &lt;code&gt;fun compute(x: UInt)&lt;/code&gt; 는 &lt;code&gt;public final void compute-&amp;lt;hashcode&amp;gt;(int x)&lt;/code&gt; 로 표시되어 충돌 문제를 해결합니다.</target>
        </trans-unit>
        <trans-unit id="214eeb66f4dd4d1fbd2d9b25b399283f63731ef6" translate="yes" xml:space="preserve">
          <source>To mitigate this problem for the users of such bytecode processing tools, we&amp;rsquo;ve added a command-line option (&lt;code&gt;-Xnormalize-constructor-calls=MODE&lt;/code&gt;) that tells the compiler to generate more Java-like bytecode for such constructs. Here &lt;code&gt;MODE&lt;/code&gt; is one of:</source>
          <target state="translated">이러한 바이트 코드 처리 도구 사용자에게이 문제를 완화하기 위해 컴파일러에 이러한 구문에 대해 더 많은 Java와 유사한 바이트 코드를 생성하도록 지시 하는 명령 행 옵션 ( &lt;code&gt;-Xnormalize-constructor-calls=MODE&lt;/code&gt; )을 추가했습니다. 여기서 &lt;code&gt;MODE&lt;/code&gt; 는 다음 중 하나입니다.</target>
        </trans-unit>
        <trans-unit id="d6aa0bdd277639961899c3f20d2977a244b12631" translate="yes" xml:space="preserve">
          <source>To mitigate this, when defining your generic classes, if the generic type should &lt;em&gt;never&lt;/em&gt; be null, provide a non-null type constraint:</source>
          <target state="translated">이를 완화하려면 일반 클래스를 정의 할 때 일반 유형이 널 이 &lt;em&gt;아니&lt;/em&gt; 어야하는 경우 널이 아닌 유형 제한 조건을 제공하십시오.</target>
        </trans-unit>
        <trans-unit id="c1476847da392c83fd72508f4713555cdba4a150" translate="yes" xml:space="preserve">
          <source>To open the list of available courses, go to &lt;strong&gt;Browse Courses&lt;/strong&gt; on the &lt;strong&gt;Welcome Screen&lt;/strong&gt; or in the &lt;strong&gt;File Menu&lt;/strong&gt;. You can start with the &lt;a href=&quot;koans&quot;&gt;Kotlin Koans&lt;/a&gt;, a series of exercises created to get you familiar with the Kotlin Syntax:</source>
          <target state="translated">가능한 과목의 목록을 열려면 이동 &lt;strong&gt;과정 검색&lt;/strong&gt; 켜기 &lt;strong&gt;시작 화면&lt;/strong&gt; 또는에서 &lt;strong&gt;파일 메뉴&lt;/strong&gt; . Kotlin 구문에 익숙해 지도록 작성된 일련의 연습 인 &lt;a href=&quot;koans&quot;&gt;Kotlin Koans로&lt;/a&gt; 시작할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="5c9c6ae81e15d7660d42f1ec133505c23d5897c2" translate="yes" xml:space="preserve">
          <source>To overcome this restriction an &lt;code&gt;internal&lt;/code&gt; declaration can be annotated with the &lt;code&gt;@PublishedApi&lt;/code&gt; annotation:</source>
          <target state="translated">이 제한을 극복하기 위해 &lt;code&gt;@PublishedApi&lt;/code&gt; 주석으로 &lt;code&gt;internal&lt;/code&gt; 선언에 주석을 달 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="a53373994c3982c9e9e8b4ff82c6886cee600271" translate="yes" xml:space="preserve">
          <source>To override &lt;code&gt;clone()&lt;/code&gt;, your class needs to extend &lt;code&gt;kotlin.Cloneable&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;clone()&lt;/code&gt; 을 재정의하려면 클래스가 &lt;code&gt;kotlin.Cloneable&lt;/code&gt; 을 확장해야합니다 .</target>
        </trans-unit>
        <trans-unit id="5e5ef664ee32f352aa2bb27af09f15aaa52406f6" translate="yes" xml:space="preserve">
          <source>To override &lt;code&gt;finalize()&lt;/code&gt;, all you need to do is simply declare it, without using the &lt;em&gt;override&lt;/em&gt; keyword:</source>
          <target state="translated">무시하려면 &lt;code&gt;finalize()&lt;/code&gt; 사용하지 않고, 당신이 할 필요가 단순히 선언되는 &lt;em&gt;재정의&lt;/em&gt; 키워드 :</target>
        </trans-unit>
        <trans-unit id="8b0eb1602de9391e417352c211eac3143269f17a" translate="yes" xml:space="preserve">
          <source>To override different methods with clashing Kotlin signatures, you can add a &lt;code&gt;@Suppress(&quot;CONFLICTING_OVERLOADS&quot;)&lt;/code&gt; annotation to the class.</source>
          <target state="translated">Kotlin 서명 충돌로 다른 메소드를 대체 하기 위해 클래스에 &lt;code&gt;@Suppress(&quot;CONFLICTING_OVERLOADS&quot;)&lt;/code&gt; 주석을 추가 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="91bf99aec76b5996287fb77c5aef5099beb9bbf4" translate="yes" xml:space="preserve">
          <source>To pass an array of primitive values you can do the following in Kotlin:</source>
          <target state="translated">기본 값의 배열을 전달하려면 Kotlin에서 다음을 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="1e5025ef1a23d09437b26030660587370537de7f" translate="yes" xml:space="preserve">
          <source>To pass custom raw compiler arguments, you can use &lt;code&gt;&amp;lt;compilerarg&amp;gt;&lt;/code&gt; elements with either &lt;code&gt;value&lt;/code&gt; or &lt;code&gt;line&lt;/code&gt; attributes. This can be done within the &lt;code&gt;&amp;lt;kotlinc&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;kotlin2js&amp;gt;&lt;/code&gt;, and &lt;code&gt;&amp;lt;withKotlin&amp;gt;&lt;/code&gt; task elements, as follows:</source>
          <target state="translated">사용자 정의 원시 컴파일러 인수를 전달하기 위해 &lt;code&gt;&amp;lt;compilerarg&amp;gt;&lt;/code&gt; 요소를 &lt;code&gt;value&lt;/code&gt; 또는 &lt;code&gt;line&lt;/code&gt; 속성 과 함께 사용할 수 있습니다 . &lt;code&gt;&amp;lt;kotlinc&amp;gt;&lt;/code&gt; , &lt;code&gt;&amp;lt;kotlin2js&amp;gt;&lt;/code&gt; 및 &lt;code&gt;&amp;lt;withKotlin&amp;gt;&lt;/code&gt; 태스크 요소 내에서 다음과 같이 수행 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="a66e06df579b1b23b91b1d16d9167a525f0b07ab" translate="yes" xml:space="preserve">
          <source>To perform a certain operation only for non-null values, you can use the safe call operator together with &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin/let&quot;&gt;&lt;code&gt;let&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">null이 아닌 값에 대해서만 특정 작업을 수행하려면 &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin/let&quot;&gt; &lt;code&gt;let&lt;/code&gt; &lt;/a&gt; 과 함께 safe call 연산자를 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="ad4b6b2d80d98efbdc1e78464bd70bae937149d2" translate="yes" xml:space="preserve">
          <source>To perform operations on all keys or all values of a map, you can retrieve them from the properties &lt;code&gt;keys&lt;/code&gt; and &lt;code&gt;values&lt;/code&gt; accordingly. &lt;code&gt;keys&lt;/code&gt; is a set of all map keys and &lt;code&gt;values&lt;/code&gt; is a collection of all map values.</source>
          <target state="translated">맵의 모든 키 또는 모든 값에 대해 작업을 수행하려면 그에 따라 속성 &lt;code&gt;keys&lt;/code&gt; 와 &lt;code&gt;values&lt;/code&gt; 에서 검색 할 수 있습니다 . &lt;code&gt;keys&lt;/code&gt; 는 모든 맵 키 세트이며 &lt;code&gt;values&lt;/code&gt; 은 모든 맵 값의 모음입니다.</target>
        </trans-unit>
        <trans-unit id="f51b0c422406c4232c8e54b63e979d8283484a9e" translate="yes" xml:space="preserve">
          <source>To prevent spoiling the global object, Kotlin creates an object that contains all Kotlin declarations from the current module. So if you name your module as &lt;code&gt;myModule&lt;/code&gt;, all declarations are available to JavaScript via &lt;code&gt;myModule&lt;/code&gt; object. For example:</source>
          <target state="translated">전역 객체의 손상을 막기 위해 Kotlin은 현재 모듈의 모든 Kotlin 선언을 포함하는 객체를 만듭니다. 따라서 모듈 이름을 &lt;code&gt;myModule&lt;/code&gt; 로 지정 하면 모든 선언을 &lt;code&gt;myModule&lt;/code&gt; 객체 를 통해 JavaScript에 사용할 수 있습니다 . 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="bf0b70dea8387f3ebfae5a605f2eb84fae8ef787" translate="yes" xml:space="preserve">
          <source>To produce a library with the Kotlin/Native compiler use the &lt;code&gt;-produce library&lt;/code&gt; or &lt;code&gt;-p library&lt;/code&gt; flag. For example:</source>
          <target state="translated">Kotlin / Native 컴파일러로 라이브러리를 생성하려면 &lt;code&gt;-produce library&lt;/code&gt; 또는 &lt;code&gt;-p library&lt;/code&gt; 플래그를 사용하십시오. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="ffef4a8cd2a1229b2f11fc8babdeb98ccaf8e0db" translate="yes" xml:space="preserve">
          <source>To produce binaries with the Kotlin/Native compiler it's sufficient to use the &lt;code&gt;-g&lt;/code&gt; option on the command line.</source>
          <target state="translated">Kotlin / Native 컴파일러로 바이너리를 생성하려면 명령 행 에서 &lt;code&gt;-g&lt;/code&gt; 옵션 을 사용하면 충분합니다 .</target>
        </trans-unit>
        <trans-unit id="1d3463a205e94a6afcbfd6330cbb565e26b9762f" translate="yes" xml:space="preserve">
          <source>To provide a custom equals check implementation, override the &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin/-any/equals&quot;&gt;&lt;code&gt;equals(other: Any?): Boolean&lt;/code&gt;&lt;/a&gt; function. Functions with the same name and other signatures, like &lt;code&gt;equals(other: Foo)&lt;/code&gt;, don't affect equality checks with the operators &lt;code&gt;==&lt;/code&gt; and &lt;code&gt;!=&lt;/code&gt;.</source>
          <target state="translated">커스텀 equals check 구현을 제공하려면 &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin/-any/equals&quot;&gt; &lt;code&gt;equals(other: Any?): Boolean&lt;/code&gt; &lt;/a&gt; 함수를 재정의하십시오 . &lt;code&gt;equals(other: Foo)&lt;/code&gt; 와 같은 이름과 다른 서명을 가진 함수는 &lt;code&gt;==&lt;/code&gt; 및 &lt;code&gt;!=&lt;/code&gt; 연산자를 사용한 동등성 검사에 영향을 미치지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="6e836b4f2fc16da476cc12a9d2050e81e112acff" translate="yes" xml:space="preserve">
          <source>To provide access to user's native operating system services, &lt;code&gt;Kotlin/Native&lt;/code&gt; distribution includes a set of prebuilt libraries specific to each target. We call them &lt;strong&gt;Platform Libraries&lt;/strong&gt;.</source>
          <target state="translated">사용자의 기본 운영 체제 서비스에 대한 액세스를 제공하기 위해 &lt;code&gt;Kotlin/Native&lt;/code&gt; 배포에는 각 대상에 고유 한 사전 빌드 된 라이브러리 세트가 포함됩니다. 우리는 그들을 &lt;strong&gt;플랫폼 라이브러리&lt;/strong&gt; 라고 부릅니다 .</target>
        </trans-unit>
        <trans-unit id="31bd1e7079e9e4ecee7632836be44ddf7d329d26" translate="yes" xml:space="preserve">
          <source>To publish an Android library as a part of a multiplatform library, one needs to &lt;a href=&quot;#publishing-a-multiplatform-library&quot;&gt;setup publishing for the library&lt;/a&gt; and provide additional configuration for the Android library target.</source>
          <target state="translated">멀티 플랫폼 라이브러리의 일부로 Android 라이브러리를 공개하려면 라이브러리에 대한 &lt;a href=&quot;#publishing-a-multiplatform-library&quot;&gt;공개&lt;/a&gt; 를 설정 하고 Android 라이브러리 대상에 대한 추가 구성을 제공해야합니다.</target>
        </trans-unit>
        <trans-unit id="d256a0c22e6d267c506acee2d9aeb1788f5b9b28" translate="yes" xml:space="preserve">
          <source>To refer to the object, we use its name directly:</source>
          <target state="translated">객체를 참조하기 위해 이름을 직접 사용합니다.</target>
        </trans-unit>
        <trans-unit id="6b8089bed090bdadd847bf36cd42b8f6183969d2" translate="yes" xml:space="preserve">
          <source>To remove an element at a specific position from a list, use the &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/-mutable-list/remove-at&quot;&gt;&lt;code&gt;removeAt()&lt;/code&gt;&lt;/a&gt; function providing the position as an argument. All indices of elements that come after the element being removed will decrease by one.</source>
          <target state="translated">목록에서 특정 위치의 요소를 제거하려면 위치를 인수로 제공하는 &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/-mutable-list/remove-at&quot;&gt; &lt;code&gt;removeAt()&lt;/code&gt; &lt;/a&gt; 함수를 사용하십시오 . 요소를 제거한 후 나오는 요소의 모든 인덱스는 1 씩 줄어 듭니다.</target>
        </trans-unit>
        <trans-unit id="521b7c2bcc6979fed176a9238d544430e53c8f9c" translate="yes" xml:space="preserve">
          <source>To remove an element from a mutable collection, use the &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/remove&quot;&gt;&lt;code&gt;remove()&lt;/code&gt;&lt;/a&gt; function. &lt;code&gt;remove()&lt;/code&gt; accepts the element value and removes one occurrence of this value.</source>
          <target state="translated">변경 가능한 컬렉션에서 요소를 제거하려면 remove &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/remove&quot;&gt; &lt;code&gt;remove()&lt;/code&gt; &lt;/a&gt; 함수를 사용하십시오 . &lt;code&gt;remove()&lt;/code&gt; 는 요소 값을 승인하고이 값의 한 항목을 제거합니다.</target>
        </trans-unit>
        <trans-unit id="3a5e20b686847f8b478f6ecb4aea9aa4a6082939" translate="yes" xml:space="preserve">
          <source>To remove an entry from a mutable map, use the &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/-mutable-map/remove&quot;&gt;&lt;code&gt;remove()&lt;/code&gt;&lt;/a&gt; function. When calling &lt;code&gt;remove()&lt;/code&gt;, you can pass either a key or a whole key-value-pair. If you specify both the key and value, the element with this key will be removed only if its value matches the second argument.</source>
          <target state="translated">변경 가능한 맵에서 항목을 제거하려면 remove &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/-mutable-map/remove&quot;&gt; &lt;code&gt;remove()&lt;/code&gt; &lt;/a&gt; 함수를 사용하십시오 . &lt;code&gt;remove()&lt;/code&gt; 호출 할 때 키 또는 전체 키-값 쌍을 전달할 수 있습니다. 키와 값을 모두 지정하면이 키가있는 요소는 해당 값이 두 번째 인수와 일치하는 경우에만 제거됩니다.</target>
        </trans-unit>
        <trans-unit id="0521fbcd6fb6f9d94e609424eadc7933044f924e" translate="yes" xml:space="preserve">
          <source>To remove the library from the default repository use</source>
          <target state="translated">기본 저장소에서 라이브러리를 제거하려면</target>
        </trans-unit>
        <trans-unit id="31c3d88842fee1685ad0d679c0db8a0fc174ec11" translate="yes" xml:space="preserve">
          <source>To remove the warning you have to opt in to the usage of experimental features by passing the argument &lt;code&gt;-XXLanguage:+InlineClasses&lt;/code&gt; to &lt;code&gt;kotlinc&lt;/code&gt;.</source>
          <target state="translated">인수 전달하여 당신이 실험 기능을 사용하도록 선택해야하는 경고를 제거하려면 &lt;code&gt;-XXLanguage:+InlineClasses&lt;/code&gt; 에 &lt;code&gt;kotlinc&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d3f08203a0ddf6e6bc4f31d19032cdb3e04aee85" translate="yes" xml:space="preserve">
          <source>To remove the warnings, add the compiler argument &lt;code&gt;-Xuse-experimental=kotlin.Experimental&lt;/code&gt;.</source>
          <target state="translated">경고를 제거하려면 컴파일러 인수 &lt;code&gt;-Xuse-experimental=kotlin.Experimental&lt;/code&gt; 을 추가하십시오 .</target>
        </trans-unit>
        <trans-unit id="d469d435bb3a113c1dd1088e7025b64a6a0198e5" translate="yes" xml:space="preserve">
          <source>To represent body of an external function. In most cases Kotlin does not require to provide bodies of external functions and properties, but if for some reason you want to (for example, due to limitation of your coding style guides), you should use &lt;code&gt;definedExternally&lt;/code&gt;.</source>
          <target state="translated">외부 함수의 본문을 나타냅니다. 대부분의 경우 Kotlin은 외부 함수 및 속성 본문을 제공 할 필요는 없지만 어떤 이유로 코딩 스타일 가이드의 제한으로 인해 원하는 경우 &lt;code&gt;definedExternally&lt;/code&gt; 를 사용해야합니다 .</target>
        </trans-unit>
        <trans-unit id="19ce750db4ac36bdd72cdcddab7ef744528c90ce" translate="yes" xml:space="preserve">
          <source>To represent value of default argument.</source>
          <target state="translated">기본 인수의 값을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="69457a99de832ac1adcb88dba9125bcc6ced4562" translate="yes" xml:space="preserve">
          <source>To retrieve the Java class of an object, use the &lt;code&gt;java&lt;/code&gt; extension property on a &lt;a href=&quot;reflection#class-references&quot;&gt;class reference&lt;/a&gt;:</source>
          <target state="translated">객체의 Java 클래스를 검색하려면 &lt;a href=&quot;reflection#class-references&quot;&gt;클래스 참조&lt;/a&gt; 에서 &lt;code&gt;java&lt;/code&gt; 확장 등록 정보를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="cab4ab009a9095119ec865716a0422fa20f520ff" translate="yes" xml:space="preserve">
          <source>To return to the pre-1.2 behavior, pass the flag &lt;code&gt;-Xno-exception-on-explicit-equals-for-boxed-null&lt;/code&gt; to the compiler.</source>
          <target state="translated">1.2 이전 동작으로 돌아가려면 &lt;code&gt;-Xno-exception-on-explicit-equals-for-boxed-null&lt;/code&gt; 플래그 를 컴파일러에 전달하십시오.</target>
        </trans-unit>
        <trans-unit id="5e0d2974dcfaa7063fb542a18d0b57f9a9db0a83" translate="yes" xml:space="preserve">
          <source>To run REPL in IntelliJ IDEA, open &lt;strong&gt;Tools | Kotlin | Kotlin REPL&lt;/strong&gt;.</source>
          <target state="translated">IntelliJ IDEA에서 REPL을 실행하려면 &lt;strong&gt;도구 | 코 틀린 | 코 틀린 REPL&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="c80c0585cded44d08003b71c290d1079d4069543" translate="yes" xml:space="preserve">
          <source>To run REPL in the OS command line, open &lt;strong&gt;/bin/kotlinc-jvm&lt;/strong&gt; from the directory of standalone Kotlin compiler.</source>
          <target state="translated">OS 명령 행에서 REPL을 실행하려면 독립형 Kotlin 컴파일러 디렉토리에서 &lt;strong&gt;/ bin / kotlinc-jvm을여십시오&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="7fd27594c6ae21992652c27028d51d29604dfae3" translate="yes" xml:space="preserve">
          <source>To run a script, we just pass the &lt;code&gt;-script&lt;/code&gt; option to the compiler with the corresponding script file.</source>
          <target state="translated">스크립트를 실행하려면 해당 스크립트 파일과 함께 &lt;code&gt;-script&lt;/code&gt; 옵션을 컴파일러에 전달하면 됩니다.</target>
        </trans-unit>
        <trans-unit id="e2cae558670745cc7ac9e88ece3ef0ebf63a7483" translate="yes" xml:space="preserve">
          <source>To run kapt with compile avoidance:</source>
          <target state="translated">컴파일 방지로 kapt를 실행하려면 :</target>
        </trans-unit>
        <trans-unit id="58d7a0df7bd3a304f110999cd04f5328dff8bc19" translate="yes" xml:space="preserve">
          <source>To run the application, right-click somewhere in the main file and select &lt;strong&gt;Run As | Kotlin Application&lt;/strong&gt;.</source>
          <target state="translated">응용 프로그램을 실행하려면 기본 파일에서 마우스 오른쪽 버튼을 클릭하고 &lt;strong&gt;Run As | 코 틀린 응용 프로그램&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="2e4d15311fa7cd994c8e9ce22c145ce856d694db" translate="yes" xml:space="preserve">
          <source>To save your course as a zip file, go to &lt;strong&gt;Course Creator -&amp;gt; Generate Course Archive&lt;/strong&gt; action. The generated archive can be opened via the &lt;strong&gt;Browse Courses&lt;/strong&gt; available from the &lt;strong&gt;Welcome Screen&lt;/strong&gt; and in the &lt;strong&gt;File Menu&lt;/strong&gt; with the &lt;strong&gt;Import Course&lt;/strong&gt; icon:</source>
          <target state="translated">코스를 zip 파일로 저장하려면 &lt;strong&gt;코스 생성기-&amp;gt; 코스 아카이브 생성&lt;/strong&gt; 액션으로 이동하십시오. 생성 된 아카이브는을 통해 열 수 있습니다 &lt;strong&gt;찾아보기 코스&lt;/strong&gt; 로부터 가능한 &lt;strong&gt;시작 화면&lt;/strong&gt; 과의 &lt;strong&gt;파일 메뉴&lt;/strong&gt; 로 &lt;strong&gt;가져 오기 과정&lt;/strong&gt; 아이콘 :</target>
        </trans-unit>
        <trans-unit id="36a621d8894a43c60f62b88c51e7aa345450af8d" translate="yes" xml:space="preserve">
          <source>To search an element in a sorted list, call the &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/binary-search&quot;&gt;&lt;code&gt;binarySearch()&lt;/code&gt;&lt;/a&gt; function passing the value as an argument. If such an element exists, the function returns its index; otherwise, it returns &lt;code&gt;(-insertionPoint - 1)&lt;/code&gt; where &lt;code&gt;insertionPoint&lt;/code&gt; is the index where this element should be inserted so that the list remains sorted. If there is more than one element with the given value, the search can return any of their indices.</source>
          <target state="translated">정렬 된 목록에서 요소를 검색하려면 값을 인수로 전달하는 &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/binary-search&quot;&gt; &lt;code&gt;binarySearch()&lt;/code&gt; &lt;/a&gt; 함수를 호출하십시오 . 이러한 요소가 존재하면 함수는 해당 인덱스를 리턴합니다. 그렇지 않으면 &lt;code&gt;(-insertionPoint - 1)&lt;/code&gt; 리턴합니다. 여기서 &lt;code&gt;insertionPoint&lt;/code&gt; 는 목록이 정렬 된 상태로 유지되도록이 요소를 삽입해야하는 색인입니다. 주어진 값을 가진 요소가 두 개 이상인 경우 검색은 색인을 반환 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="680ca05ae718e68cfb1629f08e49b399fcda4d93" translate="yes" xml:space="preserve">
          <source>To see the full Gradle script check out the source of the project on GitHub.</source>
          <target state="translated">전체 Gradle 스크립트를 보려면 GitHub에서 프로젝트 소스를 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="06d76d8df652a0954c4314eb6cd119fb4f22f648" translate="yes" xml:space="preserve">
          <source>To select module system when compiling via Gradle, you should set &lt;code&gt;moduleKind&lt;/code&gt; property, i.e.</source>
          <target state="translated">Gradle을 통해 컴파일 할 때 모듈 시스템을 선택하려면 &lt;code&gt;moduleKind&lt;/code&gt; 속성을 설정해야합니다.</target>
        </trans-unit>
        <trans-unit id="16681c84550456d5ff8bc73b03434df79d115f43" translate="yes" xml:space="preserve">
          <source>To select module system when compiling via Maven, you should set &lt;code&gt;moduleKind&lt;/code&gt; configuration property, i.e. your &lt;code&gt;pom.xml&lt;/code&gt; should look like this:</source>
          <target state="translated">Maven을 통해 컴파일 할 때 모듈 시스템을 선택하려면 &lt;code&gt;moduleKind&lt;/code&gt; 구성 속성을 설정해야 합니다. 즉, &lt;code&gt;pom.xml&lt;/code&gt; 은 다음과 같아야합니다.</target>
        </trans-unit>
        <trans-unit id="5dfb90c4357595726b2e826922df2d26c2c78269" translate="yes" xml:space="preserve">
          <source>To setup a multiplatform project from scratch in a Gradle project, first apply the &lt;code&gt;kotlin-multiplatform&lt;/code&gt; plugin to the project by adding the following to the beginning of the &lt;code&gt;build.gradle&lt;/code&gt; file:</source>
          <target state="translated">Gradle 프로젝트에서 멀티 플랫폼 프로젝트를 처음부터 새로 설정하려면 먼저 &lt;code&gt;build.gradle&lt;/code&gt; 파일 의 시작 부분에 다음을 추가하여 &lt;code&gt;kotlin-multiplatform&lt;/code&gt; 플러그인을 프로젝트에 적용 하십시오.</target>
        </trans-unit>
        <trans-unit id="c7e47d17458659905c4f2f62bdab7488ae50c7a1" translate="yes" xml:space="preserve">
          <source>To skip automatic conversion and ensure raw pointers are used in the bindings, a &lt;code&gt;noStringConversion&lt;/code&gt; statement in the &lt;code&gt;.def&lt;/code&gt; file could be used, i.e.</source>
          <target state="translated">자동 변환을 건너 뛰고 바인딩에 원시 포인터가 사용되도록 하려면 &lt;code&gt;.def&lt;/code&gt; 파일 의 &lt;code&gt;noStringConversion&lt;/code&gt; 문을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="db6bb94ddd68466610ca12cc204d3d3c6bd7dd12" translate="yes" xml:space="preserve">
          <source>To solve such issues, Kotlin introduces a special kind of class called an &lt;code&gt;inline class&lt;/code&gt;, which is declared by placing an &lt;code&gt;inline&lt;/code&gt; modifier before the name of the class:</source>
          <target state="translated">이러한 문제를 해결하기 위해 Kotlin은 &lt;code&gt;inline class&lt;/code&gt; 라는 특수한 클래스를 도입했습니다 . 클래스는 클래스 이름 앞에 &lt;code&gt;inline&lt;/code&gt; 수정자를 배치하여 선언됩니다 .</target>
        </trans-unit>
        <trans-unit id="c6edca763e12c6292a414b20b65eaba5f53f467b" translate="yes" xml:space="preserve">
          <source>To specify a visibility of the primary constructor of a class, use the following syntax (note that you need to add an explicit &lt;em&gt;constructor&lt;/em&gt; keyword):</source>
          <target state="translated">클래스의 기본 생성자의 가시성을 지정하려면 다음 구문을 사용하십시오 (명시 적 &lt;em&gt;생성자&lt;/em&gt; 키워드 를 추가해야 함 ).</target>
        </trans-unit>
        <trans-unit id="419bcc45449c9e2a7d1fb4c22599e33f123b758a" translate="yes" xml:space="preserve">
          <source>To specify additional compilation options, use the &lt;code&gt;kotlinOptions&lt;/code&gt; property of a Kotlin compilation task.</source>
          <target state="translated">추가 컴파일 옵션을 지정하려면 Kotlin 컴파일 작업 의 &lt;code&gt;kotlinOptions&lt;/code&gt; 속성을 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="0ac203e68342bc2b26ca6bd486204285a11e36be" translate="yes" xml:space="preserve">
          <source>To specify that a function type is &lt;a href=&quot;null-safety#nullable-types-and-non-null-types&quot;&gt;nullable&lt;/a&gt;, use parentheses: &lt;code&gt;((Int, Int) -&amp;gt; Int)?&lt;/code&gt;.</source>
          <target state="translated">함수 유형이 &lt;a href=&quot;null-safety#nullable-types-and-non-null-types&quot;&gt;널 입력 가능&lt;/a&gt; 하도록 지정하려면 괄호를 사용하십시오. &lt;code&gt;((Int, Int) -&amp;gt; Int)?&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e57f72b9d262e6ee5d6ce2e784cc4119575a7e41" translate="yes" xml:space="preserve">
          <source>To start executing the created coroutine, invoke &lt;code&gt;resume(Unit)&lt;/code&gt; on the returned &lt;a href=&quot;-continuation/index&quot;&gt;Continuation&lt;/a&gt; instance. The &lt;a href=&quot;create-coroutine#kotlin.coroutines%24createCoroutine%28kotlin.coroutines.SuspendFunction0%28%28kotlin.coroutines.createCoroutine.T%29%29%2C+kotlin.coroutines.Continuation%28%28kotlin.coroutines.createCoroutine.T%29%29%29%2Fcompletion&quot;&gt;completion&lt;/a&gt; continuation is invoked when the coroutine completes with a result or an exception. Subsequent invocation of any resume function on the resulting continuation will produce an &lt;a href=&quot;../kotlin/-illegal-state-exception/index#kotlin.IllegalStateException&quot;&gt;IllegalStateException&lt;/a&gt;.</source>
          <target state="translated">생성 된 코 루틴을 실행하려면 반환 된 &lt;a href=&quot;-continuation/index&quot;&gt;Continuation&lt;/a&gt; 인스턴스 에서 &lt;code&gt;resume(Unit)&lt;/code&gt; 을 호출 하십시오 . &lt;a href=&quot;create-coroutine#kotlin.coroutines%24createCoroutine%28kotlin.coroutines.SuspendFunction0%28%28kotlin.coroutines.createCoroutine.T%29%29%2C+kotlin.coroutines.Continuation%28%28kotlin.coroutines.createCoroutine.T%29%29%29%2Fcompletion&quot;&gt;완료&lt;/a&gt; 코 루틴은 결과 또는 예외로 완료 될 때 연속 호출된다. 결과 연속에서 재개 함수를 계속 호출하면 &lt;a href=&quot;../kotlin/-illegal-state-exception/index#kotlin.IllegalStateException&quot;&gt;IllegalStateException&lt;/a&gt; 이 발생 합니다 .</target>
        </trans-unit>
        <trans-unit id="29211ac1a181cd4bb3901bb410d7de3d38f88156" translate="yes" xml:space="preserve">
          <source>To start executing the created coroutine, invoke &lt;code&gt;resume(Unit)&lt;/code&gt; on the returned &lt;a href=&quot;-continuation/index&quot;&gt;Continuation&lt;/a&gt; instance. The &lt;a href=&quot;create-coroutine#kotlin.coroutines%24createCoroutine%28kotlin.coroutines.SuspendFunction1%28%28kotlin.coroutines.createCoroutine.R%2C+kotlin.coroutines.createCoroutine.T%29%29%2C+kotlin.coroutines.createCoroutine.R%2C+kotlin.coroutines.Continuation%28%28kotlin.coroutines.createCoroutine.T%29%29%29%2Fcompletion&quot;&gt;completion&lt;/a&gt; continuation is invoked when the coroutine completes with a result or an exception. Subsequent invocation of any resume function on the resulting continuation will produce an &lt;a href=&quot;../kotlin/-illegal-state-exception/index#kotlin.IllegalStateException&quot;&gt;IllegalStateException&lt;/a&gt;.</source>
          <target state="translated">생성 된 코 루틴을 실행하려면 반환 된 &lt;a href=&quot;-continuation/index&quot;&gt;Continuation&lt;/a&gt; 인스턴스 에서 &lt;code&gt;resume(Unit)&lt;/code&gt; 을 호출 하십시오 . &lt;a href=&quot;create-coroutine#kotlin.coroutines%24createCoroutine%28kotlin.coroutines.SuspendFunction1%28%28kotlin.coroutines.createCoroutine.R%2C+kotlin.coroutines.createCoroutine.T%29%29%2C+kotlin.coroutines.createCoroutine.R%2C+kotlin.coroutines.Continuation%28%28kotlin.coroutines.createCoroutine.T%29%29%29%2Fcompletion&quot;&gt;완료&lt;/a&gt; 코 루틴은 결과 또는 예외로 완료 될 때 연속 호출된다. 결과 연속에서 재개 함수를 계속 호출하면 &lt;a href=&quot;../kotlin/-illegal-state-exception/index#kotlin.IllegalStateException&quot;&gt;IllegalStateException&lt;/a&gt; 이 발생 합니다 .</target>
        </trans-unit>
        <trans-unit id="b715c677cb96aa31e520707c8bf7a084527dde6c" translate="yes" xml:space="preserve">
          <source>To start executing the created coroutine, invoke &lt;code&gt;resume(Unit)&lt;/code&gt; on the returned &lt;a href=&quot;-continuation/index&quot;&gt;Continuation&lt;/a&gt; instance. The &lt;a href=&quot;create-coroutine#kotlin.coroutines.experimental%24createCoroutine%28kotlin.coroutines.SuspendFunction0%28%28kotlin.coroutines.experimental.createCoroutine.T%29%29%2C+kotlin.coroutines.experimental.Continuation%28%28kotlin.coroutines.experimental.createCoroutine.T%29%29%29%2Fcompletion&quot;&gt;completion&lt;/a&gt; continuation is invoked when coroutine completes with result or exception. Repeated invocation of any resume function on the resulting continuation produces &lt;a href=&quot;../kotlin/-illegal-state-exception/index#kotlin.IllegalStateException&quot;&gt;IllegalStateException&lt;/a&gt;.</source>
          <target state="translated">생성 된 코 루틴을 실행하려면 반환 된 &lt;a href=&quot;-continuation/index&quot;&gt;Continuation&lt;/a&gt; 인스턴스 에서 &lt;code&gt;resume(Unit)&lt;/code&gt; 을 호출 하십시오 . &lt;a href=&quot;create-coroutine#kotlin.coroutines.experimental%24createCoroutine%28kotlin.coroutines.SuspendFunction0%28%28kotlin.coroutines.experimental.createCoroutine.T%29%29%2C+kotlin.coroutines.experimental.Continuation%28%28kotlin.coroutines.experimental.createCoroutine.T%29%29%29%2Fcompletion&quot;&gt;완료&lt;/a&gt; 코 루틴은 결과 또는 예외로 완료 될 때 연속이 호출된다. 결과 연속에서 재개 함수를 반복적으로 호출하면 &lt;a href=&quot;../kotlin/-illegal-state-exception/index#kotlin.IllegalStateException&quot;&gt;IllegalStateException&lt;/a&gt; 이 발생 합니다 .</target>
        </trans-unit>
        <trans-unit id="7ae9d4ba7899cbe4180b0d690d30390847f2291f" translate="yes" xml:space="preserve">
          <source>To start executing the created coroutine, invoke &lt;code&gt;resume(Unit)&lt;/code&gt; on the returned &lt;a href=&quot;-continuation/index&quot;&gt;Continuation&lt;/a&gt; instance. The &lt;a href=&quot;create-coroutine#kotlin.coroutines.experimental%24createCoroutine%28kotlin.coroutines.SuspendFunction1%28%28kotlin.coroutines.experimental.createCoroutine.R%2C+kotlin.coroutines.experimental.createCoroutine.T%29%29%2C+kotlin.coroutines.experimental.createCoroutine.R%2C+kotlin.coroutines.experimental.Continuation%28%28kotlin.coroutines.experimental.createCoroutine.T%29%29%29%2Fcompletion&quot;&gt;completion&lt;/a&gt; continuation is invoked when coroutine completes with result or exception. Repeated invocation of any resume function on the resulting continuation produces &lt;a href=&quot;../kotlin/-illegal-state-exception/index#kotlin.IllegalStateException&quot;&gt;IllegalStateException&lt;/a&gt;.</source>
          <target state="translated">생성 된 코 루틴을 실행하려면 반환 된 &lt;a href=&quot;-continuation/index&quot;&gt;Continuation&lt;/a&gt; 인스턴스 에서 &lt;code&gt;resume(Unit)&lt;/code&gt; 을 호출 하십시오 . &lt;a href=&quot;create-coroutine#kotlin.coroutines.experimental%24createCoroutine%28kotlin.coroutines.SuspendFunction1%28%28kotlin.coroutines.experimental.createCoroutine.R%2C+kotlin.coroutines.experimental.createCoroutine.T%29%29%2C+kotlin.coroutines.experimental.createCoroutine.R%2C+kotlin.coroutines.experimental.Continuation%28%28kotlin.coroutines.experimental.createCoroutine.T%29%29%29%2Fcompletion&quot;&gt;완료&lt;/a&gt; 코 루틴은 결과 또는 예외로 완료 될 때 연속이 호출된다. 결과 연속에서 재개 함수를 반복적으로 호출하면 &lt;a href=&quot;../kotlin/-illegal-state-exception/index#kotlin.IllegalStateException&quot;&gt;IllegalStateException&lt;/a&gt; 이 발생 합니다 .</target>
        </trans-unit>
        <trans-unit id="dfc6df82451691b1971099e0817380884cac3aec" translate="yes" xml:space="preserve">
          <source>To start executing the created coroutine, invoke &lt;code&gt;resume(Unit)&lt;/code&gt; on the returned Continuation instance. The &lt;a href=&quot;create-coroutine-unchecked#kotlin.coroutines.experimental.intrinsics%24createCoroutineUnchecked%28kotlin.coroutines.SuspendFunction0%28%28kotlin.coroutines.experimental.intrinsics.createCoroutineUnchecked.T%29%29%2C+kotlin.coroutines.experimental.Continuation%28%28kotlin.coroutines.experimental.intrinsics.createCoroutineUnchecked.T%29%29%29%2Fcompletion&quot;&gt;completion&lt;/a&gt; continuation is invoked when coroutine completes with result or exception.</source>
          <target state="translated">생성 된 코 루틴을 실행하려면 반환 된 Continuation 인스턴스에서 &lt;code&gt;resume(Unit)&lt;/code&gt; 을 호출 하십시오. &lt;a href=&quot;create-coroutine-unchecked#kotlin.coroutines.experimental.intrinsics%24createCoroutineUnchecked%28kotlin.coroutines.SuspendFunction0%28%28kotlin.coroutines.experimental.intrinsics.createCoroutineUnchecked.T%29%29%2C+kotlin.coroutines.experimental.Continuation%28%28kotlin.coroutines.experimental.intrinsics.createCoroutineUnchecked.T%29%29%29%2Fcompletion&quot;&gt;완료&lt;/a&gt; 코 루틴은 결과 또는 예외로 완료 될 때 연속이 호출된다.</target>
        </trans-unit>
        <trans-unit id="e102b42121057a6878b15b2e0b7a9abdd7059c88" translate="yes" xml:space="preserve">
          <source>To start executing the created coroutine, invoke &lt;code&gt;resume(Unit)&lt;/code&gt; on the returned Continuation instance. The &lt;a href=&quot;create-coroutine-unchecked#kotlin.coroutines.experimental.intrinsics%24createCoroutineUnchecked%28kotlin.coroutines.SuspendFunction1%28%28kotlin.coroutines.experimental.intrinsics.createCoroutineUnchecked.R%2C+kotlin.coroutines.experimental.intrinsics.createCoroutineUnchecked.T%29%29%2C+kotlin.coroutines.experimental.intrinsics.createCoroutineUnchecked.R%2C+kotlin.coroutines.experimental.Continuation%28%28kotlin.coroutines.experimental.intrinsics.createCoroutineUnchecked.T%29%29%29%2Fcompletion&quot;&gt;completion&lt;/a&gt; continuation is invoked when coroutine completes with result or exception.</source>
          <target state="translated">생성 된 코 루틴을 실행하려면 반환 된 Continuation 인스턴스에서 &lt;code&gt;resume(Unit)&lt;/code&gt; 을 호출 하십시오. &lt;a href=&quot;create-coroutine-unchecked#kotlin.coroutines.experimental.intrinsics%24createCoroutineUnchecked%28kotlin.coroutines.SuspendFunction1%28%28kotlin.coroutines.experimental.intrinsics.createCoroutineUnchecked.R%2C+kotlin.coroutines.experimental.intrinsics.createCoroutineUnchecked.T%29%29%2C+kotlin.coroutines.experimental.intrinsics.createCoroutineUnchecked.R%2C+kotlin.coroutines.experimental.Continuation%28%28kotlin.coroutines.experimental.intrinsics.createCoroutineUnchecked.T%29%29%29%2Fcompletion&quot;&gt;완료&lt;/a&gt; 코 루틴은 결과 또는 예외로 완료 될 때 연속이 호출된다.</target>
        </trans-unit>
        <trans-unit id="a74d51560d5c774d1a56f8d84a208e43206f3604" translate="yes" xml:space="preserve">
          <source>To start executing the created coroutine, invoke &lt;code&gt;resume(Unit)&lt;/code&gt; on the returned Continuation instance. The &lt;a href=&quot;create-coroutine-unintercepted#kotlin.coroutines.intrinsics%24createCoroutineUnintercepted%28kotlin.coroutines.SuspendFunction0%28%28kotlin.coroutines.intrinsics.createCoroutineUnintercepted.T%29%29%2C+kotlin.coroutines.Continuation%28%28kotlin.coroutines.intrinsics.createCoroutineUnintercepted.T%29%29%29%2Fcompletion&quot;&gt;completion&lt;/a&gt; continuation is invoked when coroutine completes with result or exception.</source>
          <target state="translated">생성 된 코 루틴을 실행하려면 반환 된 Continuation 인스턴스에서 &lt;code&gt;resume(Unit)&lt;/code&gt; 을 호출 하십시오. &lt;a href=&quot;create-coroutine-unintercepted#kotlin.coroutines.intrinsics%24createCoroutineUnintercepted%28kotlin.coroutines.SuspendFunction0%28%28kotlin.coroutines.intrinsics.createCoroutineUnintercepted.T%29%29%2C+kotlin.coroutines.Continuation%28%28kotlin.coroutines.intrinsics.createCoroutineUnintercepted.T%29%29%29%2Fcompletion&quot;&gt;완료&lt;/a&gt; 코 루틴은 결과 또는 예외로 완료 될 때 연속이 호출된다.</target>
        </trans-unit>
        <trans-unit id="aa80d28b000c404e7e7471739dc834ced4e443ec" translate="yes" xml:space="preserve">
          <source>To start executing the created coroutine, invoke &lt;code&gt;resume(Unit)&lt;/code&gt; on the returned Continuation instance. The &lt;a href=&quot;create-coroutine-unintercepted#kotlin.coroutines.intrinsics%24createCoroutineUnintercepted%28kotlin.coroutines.SuspendFunction1%28%28kotlin.coroutines.intrinsics.createCoroutineUnintercepted.R%2C+kotlin.coroutines.intrinsics.createCoroutineUnintercepted.T%29%29%2C+kotlin.coroutines.intrinsics.createCoroutineUnintercepted.R%2C+kotlin.coroutines.Continuation%28%28kotlin.coroutines.intrinsics.createCoroutineUnintercepted.T%29%29%29%2Fcompletion&quot;&gt;completion&lt;/a&gt; continuation is invoked when coroutine completes with result or exception.</source>
          <target state="translated">생성 된 코 루틴을 실행하려면 반환 된 Continuation 인스턴스에서 &lt;code&gt;resume(Unit)&lt;/code&gt; 을 호출 하십시오. &lt;a href=&quot;create-coroutine-unintercepted#kotlin.coroutines.intrinsics%24createCoroutineUnintercepted%28kotlin.coroutines.SuspendFunction1%28%28kotlin.coroutines.intrinsics.createCoroutineUnintercepted.R%2C+kotlin.coroutines.intrinsics.createCoroutineUnintercepted.T%29%29%2C+kotlin.coroutines.intrinsics.createCoroutineUnintercepted.R%2C+kotlin.coroutines.Continuation%28%28kotlin.coroutines.intrinsics.createCoroutineUnintercepted.T%29%29%29%2Fcompletion&quot;&gt;완료&lt;/a&gt; 코 루틴은 결과 또는 예외로 완료 될 때 연속이 호출된다.</target>
        </trans-unit>
        <trans-unit id="e2482fe90c75c3748aeac1be942111f81e932b33" translate="yes" xml:space="preserve">
          <source>To start the course, go to &lt;strong&gt;View -&amp;gt; Tool Windows -&amp;gt; Project&lt;/strong&gt;. You will find a course plan, the list of lessons. Every lesson has a set of tasks and code exercises you need to solve. Start with the very first one:</source>
          <target state="translated">과정을 시작하려면 &lt;strong&gt;보기-&amp;gt; 도구 창-&amp;gt; 프로젝트로 이동하십시오&lt;/strong&gt; . 코스 계획, 수업 목록을 찾을 수 있습니다. 모든 수업에는 해결해야 할 일련의 작업과 코드 연습이 있습니다. 첫 번째로 시작하십시오.</target>
        </trans-unit>
        <trans-unit id="5f3ceec14c1433cf322f7865c09a18312ccb1945" translate="yes" xml:space="preserve">
          <source>To start with, we'll need a Microsoft Visual C++ compiler installed that supports a x64_64 target. The easiest way to do this is to have a version of Microsoft Visual Studio installed on a Windows machine.</source>
          <target state="translated">우선 x64_64 대상을 지원하는 Microsoft Visual C ++ 컴파일러가 설치되어 있어야합니다. 가장 쉬운 방법은 Windows 컴퓨터에 Microsoft Visual Studio 버전을 설치하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="66185b084e5432ac45a03abd883161f880e5f11e" translate="yes" xml:space="preserve">
          <source>To switch to the old behavior, pass the fallback flag &lt;code&gt;-Xno-receiver-assertions&lt;/code&gt; to the compiler.</source>
          <target state="translated">이전 동작으로 전환하려면 폴백 플래그 &lt;code&gt;-Xno-receiver-assertions&lt;/code&gt; 를 컴파일러에 전달하십시오.</target>
        </trans-unit>
        <trans-unit id="cc3b8fe9e3a75acdfca2d542f5fc3f0b9c8e0c32" translate="yes" xml:space="preserve">
          <source>To switch to the old smart casts behavior, pass the fallback flag &lt;code&gt;-Xlegacy-smart-cast-after-try&lt;/code&gt; as the compiler argument. It will become deprecated in Kotlin 1.3.</source>
          <target state="translated">이전 스마트 캐스트 동작으로 전환하려면 폴백 플래그 &lt;code&gt;-Xlegacy-smart-cast-after-try&lt;/code&gt; 를 컴파일러 인수로 전달하십시오. Kotlin 1.3에서는 더 이상 사용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="3ee56f12e381a099c59880a6823066a60e9d50df" translate="yes" xml:space="preserve">
          <source>To take all the elements except a given number of first or last elements, call the &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/drop&quot;&gt;&lt;code&gt;drop()&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/drop-last&quot;&gt;&lt;code&gt;dropLast()&lt;/code&gt;&lt;/a&gt; functions respectively.</source>
          <target state="translated">지정된 수의 첫 번째 또는 마지막 요소를 제외한 모든 요소를 ​​가져 오려면 &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/drop&quot;&gt; &lt;code&gt;drop()&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/drop-last&quot;&gt; &lt;code&gt;dropLast()&lt;/code&gt; &lt;/a&gt; 함수를 각각 호출하십시오 .</target>
        </trans-unit>
        <trans-unit id="ca844ba87cff8c023079c9be62782b3a3fde8a97" translate="yes" xml:space="preserve">
          <source>To target the JVM, apply the Kotlin JVM plugin. Starting with Kotlin 1.1.1, the plugin can be applied using the &lt;a href=&quot;https://docs.gradle.org/current/userguide/plugins.html#sec:plugins_block&quot;&gt;Gradle plugins DSL&lt;/a&gt;:</source>
          <target state="translated">JVM을 대상으로하려면 Kotlin JVM 플러그인을 적용하십시오. Kotlin 1.1.1부터 &lt;a href=&quot;https://docs.gradle.org/current/userguide/plugins.html#sec:plugins_block&quot;&gt;Gradle 플러그인 DSL을&lt;/a&gt; 사용하여 플러그인을 적용 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="089288f0ea4e442474ea533e687f95ceb53b919e" translate="yes" xml:space="preserve">
          <source>To tell Kotlin that a certain declaration is written in pure JavaScript, you should mark it with &lt;code&gt;external&lt;/code&gt; modifier. When the compiler sees such a declaration, it assumes that the implementation for the corresponding class, function or property is provided by the developer, and therefore does not try to generate any JavaScript code from the declaration. This means that you should omit bodies of &lt;code&gt;external&lt;/code&gt; declarations. For example:</source>
          <target state="translated">Kotlin에게 특정 선언이 순수 JavaScript로 작성되었음을 알리려면 &lt;code&gt;external&lt;/code&gt; 수정 자로 표시해야합니다 . 컴파일러는 이러한 선언을 볼 때 해당 클래스, 함수 또는 속성에 대한 구현이 개발자가 제공한다고 가정하므로 선언에서 JavaScript 코드를 생성하려고 시도하지 않습니다. 이것은 &lt;code&gt;external&lt;/code&gt; 선언의 본문을 생략해야 함을 의미합니다 . 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="13b684242eb1261a088744c1edd0d98430ef5246" translate="yes" xml:space="preserve">
          <source>To tell Kotlin that an &lt;code&gt;external&lt;/code&gt; class, package, function or property is a JavaScript module, you can use &lt;code&gt;@JsModule&lt;/code&gt; annotation. Consider you have the following CommonJS module called &quot;hello&quot;:</source>
          <target state="translated">Kotlin에 &lt;code&gt;external&lt;/code&gt; 클래스, 패키지, 함수 또는 속성이 JavaScript 모듈 &lt;code&gt;@JsModule&lt;/code&gt; 위해 @JsModule 주석을 사용할 수 있습니다 . &quot;hello&quot;라는 다음 CommonJS 모듈이 있다고 가정하십시오.</target>
        </trans-unit>
        <trans-unit id="9709dd3d7713138256dbb958ab241135af68f988" translate="yes" xml:space="preserve">
          <source>To test it, we'll use a simple async function that resolves to a specified string after a specified time:</source>
          <target state="translated">이를 테스트하기 위해 지정된 시간 후에 지정된 문자열로 해석되는 간단한 비동기 함수를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="1b99a15ae02c59db4c41dbf465be5149eb5f7541" translate="yes" xml:space="preserve">
          <source>To throw an exception object, use the &lt;em&gt;throw&lt;/em&gt;-expression:</source>
          <target state="translated">예외 객체를 던질하기 위해 사용 &lt;em&gt;던져&lt;/em&gt; -expression를 :</target>
        </trans-unit>
        <trans-unit id="374704e123399146f9a10acdf418e1645171dca5" translate="yes" xml:space="preserve">
          <source>To unwrap the reference:</source>
          <target state="translated">참조를 풀려면</target>
        </trans-unit>
        <trans-unit id="a91c18bfe059c0da75a37ebc4ffaf3efe0d2e769" translate="yes" xml:space="preserve">
          <source>To unzip a list of pairs, call &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/unzip&quot;&gt;&lt;code&gt;unzip()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">쌍의 목록을 압축 해제하려면 unzip &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/unzip&quot;&gt; &lt;code&gt;unzip()&lt;/code&gt; &lt;/a&gt; 호출하십시오 .</target>
        </trans-unit>
        <trans-unit id="d8bf5ffe82f149520490d0887cef3348767dda39" translate="yes" xml:space="preserve">
          <source>To use a property, we simply refer to it by name, as if it were a field in Java:</source>
          <target state="translated">속성을 사용하려면 Java의 필드 인 것처럼 이름으로 간단히 참조하면됩니다.</target>
        </trans-unit>
        <trans-unit id="213ffc2b7aa1496be9528a577f9f8df930989d35" translate="yes" xml:space="preserve">
          <source>To use an EAP build instead, we need to specify its version in &lt;code&gt;ext.kotlin_version&lt;/code&gt; and add the corresponding repository to the &lt;code&gt;buildscript&lt;/code&gt; section (usually EAP builds are located on &lt;a href=&quot;https://bintray.com/kotlin&quot;&gt;Bintray&lt;/a&gt;)</source>
          <target state="translated">대신 EAP 빌드를 사용하려면, 우리는 그것의 버전을 지정해야 &lt;code&gt;ext.kotlin_version&lt;/code&gt; 과에 해당 저장소를 추가 &lt;code&gt;buildscript&lt;/code&gt; 의 부분 (일반적으로 EAP가에있는 빌드 &lt;a href=&quot;https://bintray.com/kotlin&quot;&gt;Bintray&lt;/a&gt; )</target>
        </trans-unit>
        <trans-unit id="95905a2dc80cd98916ed0f8c91572f9ae392d28e" translate="yes" xml:space="preserve">
          <source>To use an experimental API in all functions and classes in a file, add the file-level annotation &lt;code&gt;@file:UseExperimental&lt;/code&gt; to the top of the file before the package specification and imports.</source>
          <target state="translated">파일의 모든 함수와 클래스에서 실험용 API를 사용하려면 파일 사양 주석 &lt;code&gt;@file:UseExperimental&lt;/code&gt; 을 패키지 사양 및 가져 오기 전에 파일 맨 위에 추가하십시오 .</target>
        </trans-unit>
        <trans-unit id="905c85d4c4dbeeb5849e639296b6ff9051d12bf0" translate="yes" xml:space="preserve">
          <source>To use classes or functions from a project in the scratch, import them into the scratch file as usual with the &lt;code&gt;import&lt;/code&gt; statement. Then write your code and run it with the appropriate module selected in &lt;strong&gt;Use classpath of module&lt;/strong&gt; list. To rebuild the module automatically before running the scratch, select &lt;strong&gt;Make before Run&lt;/strong&gt;.</source>
          <target state="translated">스크래치에서 프로젝트의 클래스 또는 함수를 사용하려면 &lt;code&gt;import&lt;/code&gt; 문을 사용하여 평소와 같이 스크래치 파일로 가져 오십시오 . 그런 다음 코드를 작성하고 &lt;strong&gt;모듈&lt;/strong&gt; 목록의 &lt;strong&gt;클래스 경로 사용&lt;/strong&gt; 에서 선택한 적절한 모듈로 실행 하십시오. 스크래치를 실행하기 전에 모듈을 자동으로 다시 빌드하려면 실행 전에 작성을 선택 &lt;strong&gt;하십시오&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="7e6f898d3fd804cbaaa8f5e41eecb4b87b3f095b" translate="yes" xml:space="preserve">
          <source>To use it with Kotlin configure annotation processing dependency using &lt;code&gt;kapt&lt;/code&gt;:</source>
          <target state="translated">Kotlin과 함께 사용하려면 &lt;code&gt;kapt&lt;/code&gt; 를 사용하여 주석 처리 종속성을 구성하십시오 .</target>
        </trans-unit>
        <trans-unit id="a24de3bc480fd74ef920d5e8c2200b8ea53a9381" translate="yes" xml:space="preserve">
          <source>To use such an extension outside its declaring package, we need to import it at the call site:</source>
          <target state="translated">이러한 확장을 선언 패키지 외부에서 사용하려면 호출 사이트에서 가져와야합니다.</target>
        </trans-unit>
        <trans-unit id="f45da6c5e75b429df6c944cb1a348aa71eac1487" translate="yes" xml:space="preserve">
          <source>To use the Gradle worker API for parallel execution of kapt tasks, add this line to your &lt;code&gt;gradle.properties&lt;/code&gt; file:</source>
          <target state="translated">kapt 작업의 병렬 실행에 Gradle worker API를 사용하려면 &lt;code&gt;gradle.properties&lt;/code&gt; 파일에 다음 행을 추가 하십시오.</target>
        </trans-unit>
        <trans-unit id="f4b36ae1fba60b209f3facc66006c1d59e359e4b" translate="yes" xml:space="preserve">
          <source>To use the library just</source>
          <target state="translated">라이브러리를 사용하려면</target>
        </trans-unit>
        <trans-unit id="f8b6262cd9dc8c43d7c667ac936a5f2566f2a0e4" translate="yes" xml:space="preserve">
          <source>To use these dependencies from a Kotlin code, import a package &lt;code&gt;cocoapods.&amp;lt;library-name&amp;gt;&lt;/code&gt;. In the example above, it's &lt;code&gt;cocoapods.AFNetworking&lt;/code&gt;.</source>
          <target state="translated">Kotlin 코드에서 이러한 종속성을 사용하려면 &lt;code&gt;cocoapods.&amp;lt;library-name&amp;gt;&lt;/code&gt; 패키지를 가져 오십시오 . 위의 예에서 &lt;code&gt;cocoapods.AFNetworking&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="29ce373f521a913b58c57c24b3da2c509d708a6c" translate="yes" xml:space="preserve">
          <source>To verify that your code is formatted according to the style guide, go to the inspection settings and enable the &quot;Kotlin | Style issues | File is not formatted according to project settings&quot; inspection. Additional inspections that verify other issues described in the style guide (such as naming conventions) are enabled by default.</source>
          <target state="translated">스타일 가이드에 따라 코드 형식이 지정되었는지 확인하려면 검사 설정으로 이동하여 &quot;Kotlin | 스타일 문제 | 파일이 프로젝트 설정에 따라 형식이 지정되지 않았습니다&quot;검사를 활성화하십시오. 스타일 가이드에 설명 된 다른 문제 (예 : 명명 규칙)를 확인하는 추가 검사는 기본적으로 활성화되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="b6747c485a8043bd5cfaa965ac1719dda893a066" translate="yes" xml:space="preserve">
          <source>To wrap the reference:</source>
          <target state="translated">참조를 래핑하려면 다음을 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="4fc60ef5d69079c451ea67854c51808d9ec41c01" translate="yes" xml:space="preserve">
          <source>Tooling</source>
          <target state="translated">Tooling</target>
        </trans-unit>
        <trans-unit id="4fa8cc860c52b268dc6a3adcde7305e9415db5bb" translate="yes" xml:space="preserve">
          <source>Tools</source>
          <target state="translated">Tools</target>
        </trans-unit>
        <trans-unit id="a2b342afe760f02175e18eb57be53d77e5b4d945" translate="yes" xml:space="preserve">
          <source>Tools for Android Development</source>
          <target state="translated">안드로이드 개발 도구</target>
        </trans-unit>
        <trans-unit id="933c173dc4997663d3dd2b639f726f17d399abb1" translate="yes" xml:space="preserve">
          <source>Top level/global variables of non-primitive types are by default accessible in the main thread (i.e., the thread which initialized &lt;em&gt;Kotlin/Native&lt;/em&gt; runtime first) only. Access from another thread will lead to an &lt;code&gt;IncorrectDereferenceException&lt;/code&gt; being thrown. To make such variables accessible in other threads, you can use either the &lt;code&gt;@ThreadLocal&lt;/code&gt; annotation, and mark the value thread local or &lt;code&gt;@SharedImmutable&lt;/code&gt;, which will make the value frozen and accessible from other threads.</source>
          <target state="translated">기본이 아닌 유형의 최상위 레벨 / 글로벌 변수는 기본적으로 메인 스레드 (즉, &lt;em&gt;Kotlin / Native&lt;/em&gt; 런타임을 먼저 초기화 한 스레드 )에서만 액세스 할 수 있습니다 . 다른 스레드에서 액세스하면 &lt;code&gt;IncorrectDereferenceException&lt;/code&gt; 이 발생합니다. 이러한 변수를 다른 스레드에서 액세스 할 수 있도록하려면 &lt;code&gt;@ThreadLocal&lt;/code&gt; 주석을 사용 하고 값 스레드를 로컬 또는 &lt;code&gt;@SharedImmutable&lt;/code&gt; 로 표시하면 다른 스레드에서 값을 고정하고 액세스 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d10164060fa5359f1cc0440621a4aa0561a65a4b" translate="yes" xml:space="preserve">
          <source>Top-level Kotlin functions and properties are accessible as members of special classes. Each Kotlin file is translated into such a class. E.g.</source>
          <target state="translated">최상위 클래스 Kotlin 함수 및 속성은 특수 클래스의 멤버로 액세스 할 수 있습니다. 각 Kotlin 파일은 이러한 클래스로 변환됩니다. 예 :</target>
        </trans-unit>
        <trans-unit id="2b1be77aa458090db17874852b17692b274f4c30" translate="yes" xml:space="preserve">
          <source>Top-level functions and properties</source>
          <target state="translated">최상위 기능 및 속성</target>
        </trans-unit>
        <trans-unit id="73a9d7257a50c4b586e17a750a9b120479406586" translate="yes" xml:space="preserve">
          <source>Top-level variables:</source>
          <target state="translated">최상위 변수 :</target>
        </trans-unit>
        <trans-unit id="093982a5b38ce32bb690b5df5afe9cfb58db39b3" translate="yes" xml:space="preserve">
          <source>Top-level, or member of an &lt;a href=&quot;object-declarations#object-declarations&quot;&gt;&lt;em&gt;object&lt;/em&gt; declaration&lt;/a&gt; or &lt;a href=&quot;object-declarations#companion-objects&quot;&gt;a &lt;em&gt;companion object&lt;/em&gt;&lt;/a&gt;.</source>
          <target state="translated">의 최상위 또는 멤버 &lt;a href=&quot;object-declarations#object-declarations&quot;&gt;&lt;em&gt;객체&lt;/em&gt; 선언&lt;/a&gt; 또는 &lt;a href=&quot;object-declarations#companion-objects&quot;&gt;&lt;em&gt;동반자 객체&lt;/em&gt;&lt;/a&gt; .&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="e3f139abb7a549a1210b36f7dbf89215ad6c9902" translate="yes" xml:space="preserve">
          <source>Touch</source>
          <target state="translated">Touch</target>
        </trans-unit>
        <trans-unit id="86c192cdf813e67ab4284db18cce6c47a873de77" translate="yes" xml:space="preserve">
          <source>TrackEventInit</source>
          <target state="translated">TrackEventInit</target>
        </trans-unit>
        <trans-unit id="24c733cfc9ff52310bfeff0739e9d84bd974f090" translate="yes" xml:space="preserve">
          <source>Training Partners</source>
          <target state="translated">교육 파트너</target>
        </trans-unit>
        <trans-unit id="62000f6d60c7b6da6e48acb50b9e4d2454c263e3" translate="yes" xml:space="preserve">
          <source>TransferMode</source>
          <target state="translated">TransferMode</target>
        </trans-unit>
        <trans-unit id="d685ad7c59aeb1945ef867b52857539b62c1b81c" translate="yes" xml:space="preserve">
          <source>Transformations</source>
          <target state="translated">Transformations</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
