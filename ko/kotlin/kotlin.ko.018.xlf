<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="kotlin">
    <body>
      <group id="kotlin">
        <trans-unit id="4c32ac23bf57e6bef05946a26b1a0eabf8256266" translate="yes" xml:space="preserve">
          <source>Select expression (experimental)</source>
          <target state="translated">표현 선택 (실험)</target>
        </trans-unit>
        <trans-unit id="48956f92abeebca2ff71b62a0891686768c01f08" translate="yes" xml:space="preserve">
          <source>Select expression has &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.channels/-send-channel/on-send.html&quot;&gt;onSend&lt;/a&gt; clause that can be used for a great good in combination with a biased nature of selection.</source>
          <target state="translated">선택 표현식에는 선택 특성의 바이어스 특성과 함께 사용할 수있는 &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.channels/-send-channel/on-send.html&quot;&gt;onSend&lt;/a&gt; 절이 있습니다.</target>
        </trans-unit>
        <trans-unit id="b520be71b3c104ce563b6c593fde42be010adf49" translate="yes" xml:space="preserve">
          <source>Select expression makes it possible to await multiple suspending functions simultaneously and &lt;em&gt;select&lt;/em&gt; the first one that becomes available.</source>
          <target state="translated">Select expression을 사용하면 여러 개의 일시 중단 기능을 동시에 대기하고 사용 가능한 첫 번째 기능을 &lt;em&gt;선택할&lt;/em&gt; 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8175e32b759e37e1a5d84ee3e91065f0c422b7eb" translate="yes" xml:space="preserve">
          <source>Select expressions are an experimental feature of &lt;code&gt;kotlinx.coroutines&lt;/code&gt;. Their API is expected to evolve in the upcoming updates of the &lt;code&gt;kotlinx.coroutines&lt;/code&gt; library with potentially breaking changes.</source>
          <target state="translated">선택 표현식은 &lt;code&gt;kotlinx.coroutines&lt;/code&gt; 의 실험 기능입니다 . 그들의 API는 &lt;code&gt;kotlinx.coroutines&lt;/code&gt; 라이브러리 의 향후 업데이트에서 잠재적으로 변경 사항이 변경 되어 발전 할 것으로 예상 됩니다.</target>
        </trans-unit>
        <trans-unit id="42302b9a2abf4e35a9075aa892e7301f57141bf5" translate="yes" xml:space="preserve">
          <source>Selected documentation pages:</source>
          <target state="translated">선택된 문서 페이지 :</target>
        </trans-unit>
        <trans-unit id="02edbb0885c1f54bd5c812f1f6c21dd73b7b7752" translate="yes" xml:space="preserve">
          <source>Selecting deferred values</source>
          <target state="translated">지연된 값 선택</target>
        </trans-unit>
        <trans-unit id="47d00ff46b20191dc1fea60073556feeb9737b6b" translate="yes" xml:space="preserve">
          <source>Selecting from channels</source>
          <target state="translated">채널에서 선택</target>
        </trans-unit>
        <trans-unit id="aab3b9d16e09699ff2d802b15b20b5ecc4f06393" translate="yes" xml:space="preserve">
          <source>Selecting library headers</source>
          <target state="translated">라이브러리 헤더 선택</target>
        </trans-unit>
        <trans-unit id="fe050710fc31fb212b9d58e03ffb5ddf9227ff92" translate="yes" xml:space="preserve">
          <source>Selecting on close</source>
          <target state="translated">닫을 때 선택</target>
        </trans-unit>
        <trans-unit id="c21c0093c98c3f86a84809d41128aa9f9d516de1" translate="yes" xml:space="preserve">
          <source>Selecting to send</source>
          <target state="translated">보내도록 선택</target>
        </trans-unit>
        <trans-unit id="c5d699ecb491cd74b07cd5d34e15b6457dcd4d77" translate="yes" xml:space="preserve">
          <source>SelectionMode</source>
          <target state="translated">SelectionMode</target>
        </trans-unit>
        <trans-unit id="e224d8a043bad355e811a889ebdd19946f0af63a" translate="yes" xml:space="preserve">
          <source>Self-contained Jar file</source>
          <target state="translated">자체 포함 된 Jar 파일</target>
        </trans-unit>
        <trans-unit id="deaa9959eee189b886b9fe0c02af7f02ee90f04a" translate="yes" xml:space="preserve">
          <source>Semantic difference between object expressions and declarations</source>
          <target state="translated">객체 표현과 선언의 의미 상 차이점</target>
        </trans-unit>
        <trans-unit id="1158dc6391ca1c282b0274da233e5b47974ab44c" translate="yes" xml:space="preserve">
          <source>Semicolons</source>
          <target state="translated">Semicolons</target>
        </trans-unit>
        <trans-unit id="5782c9162c716def6df9bf7e94748ad8c4334b5a" translate="yes" xml:space="preserve">
          <source>Send and receive operations to channels are &lt;em&gt;fair&lt;/em&gt; with respect to the order of their invocation from multiple coroutines. They are served in first-in first-out order, e.g. the first coroutine to invoke &lt;code&gt;receive&lt;/code&gt; gets the element. In the following example two coroutines &quot;ping&quot; and &quot;pong&quot; are receiving the &quot;ball&quot; object from the shared &quot;table&quot; channel.</source>
          <target state="translated">여러 코 루틴의 호출 순서와 관련 하여 채널로의 송신 및 수신 조작은 &lt;em&gt;공정&lt;/em&gt; 합니다. 그들은 선입 선출 순서로 제공됩니다. 예를 들어 &lt;code&gt;receive&lt;/code&gt; 를 호출하는 첫 번째 코 루틴 이 요소를 가져옵니다. 다음 예에서 두 개의 코 루틴 &quot;ping&quot;및 &quot;pong&quot;은 공유 &quot;table&quot;채널에서 &quot;ball&quot;객체를 수신합니다.</target>
        </trans-unit>
        <trans-unit id="e54a83f10e5af4bee27d8c0ebfe4ed0592366f8d" translate="yes" xml:space="preserve">
          <source>Separate interfaces for read-only and mutable collections</source>
          <target state="translated">읽기 전용 및 변경 가능한 컬렉션을위한 별도의 인터페이스</target>
        </trans-unit>
        <trans-unit id="5c8f4e0e1a2281faf562976c2410f76c3d8fbc95" translate="yes" xml:space="preserve">
          <source>Sequence</source>
          <target state="translated">Sequence</target>
        </trans-unit>
        <trans-unit id="e5883c1a54bb1e68289417fbad3062b1a700027a" translate="yes" xml:space="preserve">
          <source>Sequence operations</source>
          <target state="translated">시퀀스 작업</target>
        </trans-unit>
        <trans-unit id="c48d275d17f30d5b803ff437ae7b3ef803c29872" translate="yes" xml:space="preserve">
          <source>Sequence operations, like &lt;a href=&quot;../map&quot;&gt;Sequence.map&lt;/a&gt;, &lt;a href=&quot;../filter&quot;&gt;Sequence.filter&lt;/a&gt; etc, generally preserve that property of a sequence, and again it's documented for an operation if it doesn't.</source>
          <target state="translated">시퀀스 작업은 같은 &lt;a href=&quot;../map&quot;&gt;Sequence.map&lt;/a&gt; , &lt;a href=&quot;../filter&quot;&gt;Sequence.filter&lt;/a&gt; 등, 일반적으로 일련의 속성을 보존되어 있지 않으면 다시는 작업에 문서화.</target>
        </trans-unit>
        <trans-unit id="64e6557fa694e5bc4d5214113f8e64a03eff042b" translate="yes" xml:space="preserve">
          <source>Sequence processing example</source>
          <target state="translated">시퀀스 처리 예</target>
        </trans-unit>
        <trans-unit id="17d31f0a79810867402ac04dc581a512a3e7b8e1" translate="yes" xml:space="preserve">
          <source>Sequence.groupingBy</source>
          <target state="translated">Sequence.groupingBy</target>
        </trans-unit>
        <trans-unit id="01f90824cbb43798e728c150fb0e61a7bc14e304" translate="yes" xml:space="preserve">
          <source>SequenceBuilder</source>
          <target state="translated">SequenceBuilder</target>
        </trans-unit>
        <trans-unit id="1ba425c731fb567f4a419699f797f9b17fbee2da" translate="yes" xml:space="preserve">
          <source>SequenceScope</source>
          <target state="translated">SequenceScope</target>
        </trans-unit>
        <trans-unit id="b5fb636023abb67d347041d398442118f79ea091" translate="yes" xml:space="preserve">
          <source>Sequences</source>
          <target state="translated">Sequences</target>
        </trans-unit>
        <trans-unit id="dd81a16031599be93f6dd81ca5d6238d53a6744e" translate="yes" xml:space="preserve">
          <source>Sequences can be iterated multiple times, however some sequence implementations might constrain themselves to be iterated only once. That is mentioned specifically in their documentation (e.g. &lt;a href=&quot;../generate-sequence&quot;&gt;generateSequence&lt;/a&gt; overload). The latter sequences throw an exception on an attempt to iterate them the second time.</source>
          <target state="translated">시퀀스는 여러 번 반복 될 수 있지만 일부 시퀀스 구현은 한 번만 반복되도록 제한 할 수 있습니다. 이는 해당 문서에서 구체적으로 언급됩니다 (예 : &lt;a href=&quot;../generate-sequence&quot;&gt;generateSequence&lt;/a&gt; 과부하). 후자의 시퀀스는 두 번째 반복을 시도 할 때 예외가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="324bddccf0babf837f3e319e5e20b79516c0238f" translate="yes" xml:space="preserve">
          <source>Sequences can be iterated multiple times, however some sequence implementations might constrain themselves to be iterated only once. That is mentioned specifically in their documentation (e.g. &lt;a href=&quot;generate-sequence&quot;&gt;kotlin.sequences.generateSequence&lt;/a&gt; overload). The latter sequences throw an exception on an attempt to iterate them the second time.</source>
          <target state="translated">시퀀스는 여러 번 반복 될 수 있지만 일부 시퀀스 구현은 한 번만 반복되도록 제한 할 수 있습니다. 이는 설명서에 구체적으로 언급되어 있습니다 (예 : &lt;a href=&quot;generate-sequence&quot;&gt;kotlin.sequences.generateSequence&lt;/a&gt; 과부하). 후자의 시퀀스는 두 번째 반복을 시도 할 때 예외가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="7d6e9c12f8fb2b461fa680aec22b49a6b437317d" translate="yes" xml:space="preserve">
          <source>Sequences can be iterated multiple times; however some sequence implementations might constrain themselves to be iterated only once. That is mentioned specifically in their documentation.</source>
          <target state="translated">시퀀스는 여러 번 반복 될 수 있습니다. 그러나 일부 시퀀스 구현은 한 번만 반복되도록 제한 할 수 있습니다. 그것은 그들의 문서에 구체적으로 언급되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="633b854023bf60ecd3352dd58f1b60cddc507889" translate="yes" xml:space="preserve">
          <source>Sequential by default</source>
          <target state="translated">기본적으로 순차적</target>
        </trans-unit>
        <trans-unit id="89282363da677473acdbf45f0831bde9f4d3b6c4" translate="yes" xml:space="preserve">
          <source>Serialization</source>
          <target state="translated">Serialization</target>
        </trans-unit>
        <trans-unit id="f1f612371c661be3166a24f9dc10446222583cd3" translate="yes" xml:space="preserve">
          <source>Serialization plugin</source>
          <target state="translated">직렬화 플러그인</target>
        </trans-unit>
        <trans-unit id="8271ef44e36a997c2ae658d1924bd9cf6db40226" translate="yes" xml:space="preserve">
          <source>ServiceWorkerMessageEventInit</source>
          <target state="translated">ServiceWorkerMessageEventInit</target>
        </trans-unit>
        <trans-unit id="4413f0ab2dcf4624fe4b65b9e4d2332c78716f39" translate="yes" xml:space="preserve">
          <source>ServiceWorkerState</source>
          <target state="translated">ServiceWorkerState</target>
        </trans-unit>
        <trans-unit id="448ab73ba1c21e671e218fb91f2644c834f0c16f" translate="yes" xml:space="preserve">
          <source>Set</source>
          <target state="translated">Set</target>
        </trans-unit>
        <trans-unit id="40113801b18ce319e5c44850e1e658e055ba2004" translate="yes" xml:space="preserve">
          <source>Set Specific Operations</source>
          <target state="translated">특정 작업 설정</target>
        </trans-unit>
        <trans-unit id="43fa638b38fa3057dbf85563525061705d9f06b0" translate="yes" xml:space="preserve">
          <source>Set a callback &lt;a href=&quot;on-fail#kotlin.io.FileTreeWalk%24onFail%28kotlin.Function2%28%28java.io.File%2C+java.io.IOException%2C+kotlin.Unit%29%29%29%2Ffunction&quot;&gt;function&lt;/a&gt;, that is called on a directory when it's impossible to get its file list.</source>
          <target state="translated">파일 목록을 가져올 수없는 경우 디렉토리에서 호출 되는 콜백 &lt;a href=&quot;on-fail#kotlin.io.FileTreeWalk%24onFail%28kotlin.Function2%28%28java.io.File%2C+java.io.IOException%2C+kotlin.Unit%29%29%29%2Ffunction&quot;&gt;함수를&lt;/a&gt; 설정 하십시오.</target>
        </trans-unit>
        <trans-unit id="b061e7ff7dc8605bd1d5a2dec3d93d192c52d826" translate="yes" xml:space="preserve">
          <source>Set the bit specified to the specified value.</source>
          <target state="translated">지정된 비트를 지정된 값으로 설정하십시오.</target>
        </trans-unit>
        <trans-unit id="38b610e97dc4a86ed3152f5aad53acad8003c57f" translate="yes" xml:space="preserve">
          <source>Set up an IDE</source>
          <target state="translated">IDE 설정</target>
        </trans-unit>
        <trans-unit id="9090f4dac9398caea18d500c177ae5d9eaaf87eb" translate="yes" xml:space="preserve">
          <source>Sets &lt;a href=&quot;../-char/index#kotlin.Char&quot;&gt;Char&lt;/a&gt; out of the &lt;a href=&quot;index#kotlin.ByteArray&quot;&gt;ByteArray&lt;/a&gt; byte buffer at specified index &lt;a href=&quot;../../kotlin.native/set-char-at#kotlin.native%24setCharAt%28kotlin.ByteArray%2C+kotlin.Int%2C+kotlin.Char%29%2Findex&quot;&gt;index&lt;/a&gt;</source>
          <target state="translated">지정된 인덱스 &lt;a href=&quot;../../kotlin.native/set-char-at#kotlin.native%24setCharAt%28kotlin.ByteArray%2C+kotlin.Int%2C+kotlin.Char%29%2Findex&quot;&gt;인덱스&lt;/a&gt; 에서 &lt;a href=&quot;index#kotlin.ByteArray&quot;&gt;ByteArray&lt;/a&gt; 바이트 버퍼에서 &lt;a href=&quot;../-char/index#kotlin.Char&quot;&gt;Char&lt;/a&gt; 를 설정 합니다.</target>
        </trans-unit>
        <trans-unit id="edcc200bc12273c6272fafd06f2a5c60428e5419" translate="yes" xml:space="preserve">
          <source>Sets &lt;a href=&quot;../-double/index#kotlin.Double&quot;&gt;Double&lt;/a&gt; out of the &lt;a href=&quot;index#kotlin.ByteArray&quot;&gt;ByteArray&lt;/a&gt; byte buffer at specified index &lt;a href=&quot;../../kotlin.native/set-double-at#kotlin.native%24setDoubleAt%28kotlin.ByteArray%2C+kotlin.Int%2C+kotlin.Double%29%2Findex&quot;&gt;index&lt;/a&gt;</source>
          <target state="translated">지정된 인덱스 &lt;a href=&quot;../../kotlin.native/set-double-at#kotlin.native%24setDoubleAt%28kotlin.ByteArray%2C+kotlin.Int%2C+kotlin.Double%29%2Findex&quot;&gt;인덱스&lt;/a&gt; 에서 &lt;a href=&quot;index#kotlin.ByteArray&quot;&gt;ByteArray&lt;/a&gt; 바이트 버퍼에서 &lt;a href=&quot;../-double/index#kotlin.Double&quot;&gt;Double&lt;/a&gt; 을 설정 합니다.</target>
        </trans-unit>
        <trans-unit id="da515a45bf6a7b48f76d31bfdfc07e81c5e5b397" translate="yes" xml:space="preserve">
          <source>Sets &lt;a href=&quot;../-float/index#kotlin.Float&quot;&gt;Float&lt;/a&gt; out of the &lt;a href=&quot;index#kotlin.ByteArray&quot;&gt;ByteArray&lt;/a&gt; byte buffer at specified index &lt;a href=&quot;../../kotlin.native/set-float-at#kotlin.native%24setFloatAt%28kotlin.ByteArray%2C+kotlin.Int%2C+kotlin.Float%29%2Findex&quot;&gt;index&lt;/a&gt;</source>
          <target state="translated">지정된 인덱스 &lt;a href=&quot;../../kotlin.native/set-float-at#kotlin.native%24setFloatAt%28kotlin.ByteArray%2C+kotlin.Int%2C+kotlin.Float%29%2Findex&quot;&gt;인덱스&lt;/a&gt; 에서 &lt;a href=&quot;index#kotlin.ByteArray&quot;&gt;ByteArray&lt;/a&gt; 바이트 버퍼에서 &lt;a href=&quot;../-float/index#kotlin.Float&quot;&gt;Float&lt;/a&gt; 를 설정 합니다.</target>
        </trans-unit>
        <trans-unit id="6243aa097ace2f119715a9e02308e904fd46fa09" translate="yes" xml:space="preserve">
          <source>Sets &lt;a href=&quot;../-int/index#kotlin.Int&quot;&gt;Int&lt;/a&gt; out of the &lt;a href=&quot;index#kotlin.ByteArray&quot;&gt;ByteArray&lt;/a&gt; byte buffer at specified index &lt;a href=&quot;../../kotlin.native/set-int-at#kotlin.native%24setIntAt%28kotlin.ByteArray%2C+kotlin.Int%2C+kotlin.Int%29%2Findex&quot;&gt;index&lt;/a&gt;</source>
          <target state="translated">지정된 인덱스 &lt;a href=&quot;../../kotlin.native/set-int-at#kotlin.native%24setIntAt%28kotlin.ByteArray%2C+kotlin.Int%2C+kotlin.Int%29%2Findex&quot;&gt;인덱스&lt;/a&gt; 에서 &lt;a href=&quot;index#kotlin.ByteArray&quot;&gt;ByteArray&lt;/a&gt; 바이트 버퍼에서 &lt;a href=&quot;../-int/index#kotlin.Int&quot;&gt;Int&lt;/a&gt; 를 설정 합니다.</target>
        </trans-unit>
        <trans-unit id="7e9fead8a733ff6e2f7c6229ab156b0be3c7aad8" translate="yes" xml:space="preserve">
          <source>Sets &lt;a href=&quot;../-long/index#kotlin.Long&quot;&gt;Long&lt;/a&gt; out of the &lt;a href=&quot;index#kotlin.ByteArray&quot;&gt;ByteArray&lt;/a&gt; byte buffer at specified index &lt;a href=&quot;../../kotlin.native/set-long-at#kotlin.native%24setLongAt%28kotlin.ByteArray%2C+kotlin.Int%2C+kotlin.Long%29%2Findex&quot;&gt;index&lt;/a&gt;</source>
          <target state="translated">지정된 인덱스 &lt;a href=&quot;../../kotlin.native/set-long-at#kotlin.native%24setLongAt%28kotlin.ByteArray%2C+kotlin.Int%2C+kotlin.Long%29%2Findex&quot;&gt;인덱스&lt;/a&gt; 에서 &lt;a href=&quot;index#kotlin.ByteArray&quot;&gt;ByteArray&lt;/a&gt; 바이트 버퍼 의 &lt;a href=&quot;../-long/index#kotlin.Long&quot;&gt;Long&lt;/a&gt; 을 설정 합니다.</target>
        </trans-unit>
        <trans-unit id="cd6198304f168018790866f8d5de90bd850068be" translate="yes" xml:space="preserve">
          <source>Sets &lt;a href=&quot;../-short/index#kotlin.Short&quot;&gt;Short&lt;/a&gt; out of the &lt;a href=&quot;index#kotlin.ByteArray&quot;&gt;ByteArray&lt;/a&gt; byte buffer at specified index &lt;a href=&quot;../../kotlin.native/set-short-at#kotlin.native%24setShortAt%28kotlin.ByteArray%2C+kotlin.Int%2C+kotlin.Short%29%2Findex&quot;&gt;index&lt;/a&gt;</source>
          <target state="translated">설정 &lt;a href=&quot;../-short/index#kotlin.Short&quot;&gt;짧은&lt;/a&gt; 의 아웃 &lt;a href=&quot;index#kotlin.ByteArray&quot;&gt;된 ByteArray&lt;/a&gt; 지정된 인덱스에서 바이트 버퍼 &lt;a href=&quot;../../kotlin.native/set-short-at#kotlin.native%24setShortAt%28kotlin.ByteArray%2C+kotlin.Int%2C+kotlin.Short%29%2Findex&quot;&gt;인덱스&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="043a131ab8bde8809b5efb8cc71bececd6f0b920" translate="yes" xml:space="preserve">
          <source>Sets &lt;a href=&quot;../kotlin/-char/index#kotlin.Char&quot;&gt;Char&lt;/a&gt; out of the &lt;a href=&quot;../kotlin/-byte-array/index#kotlin.ByteArray&quot;&gt;ByteArray&lt;/a&gt; byte buffer at specified index &lt;a href=&quot;set-char-at#kotlin.native%24setCharAt%28kotlin.ByteArray%2C+kotlin.Int%2C+kotlin.Char%29%2Findex&quot;&gt;index&lt;/a&gt;</source>
          <target state="translated">지정된 인덱스 &lt;a href=&quot;set-char-at#kotlin.native%24setCharAt%28kotlin.ByteArray%2C+kotlin.Int%2C+kotlin.Char%29%2Findex&quot;&gt;인덱스&lt;/a&gt; 에서 &lt;a href=&quot;../kotlin/-byte-array/index#kotlin.ByteArray&quot;&gt;ByteArray&lt;/a&gt; 바이트 버퍼에서 &lt;a href=&quot;../kotlin/-char/index#kotlin.Char&quot;&gt;Char&lt;/a&gt; 를 설정 합니다.</target>
        </trans-unit>
        <trans-unit id="165ab1c79e9f7280a7ff5a7178cd42f19ee49e12" translate="yes" xml:space="preserve">
          <source>Sets &lt;a href=&quot;../kotlin/-double/index#kotlin.Double&quot;&gt;Double&lt;/a&gt; out of the &lt;a href=&quot;../kotlin/-byte-array/index#kotlin.ByteArray&quot;&gt;ByteArray&lt;/a&gt; byte buffer at specified index &lt;a href=&quot;set-double-at#kotlin.native%24setDoubleAt%28kotlin.ByteArray%2C+kotlin.Int%2C+kotlin.Double%29%2Findex&quot;&gt;index&lt;/a&gt;</source>
          <target state="translated">지정된 인덱스 &lt;a href=&quot;set-double-at#kotlin.native%24setDoubleAt%28kotlin.ByteArray%2C+kotlin.Int%2C+kotlin.Double%29%2Findex&quot;&gt;인덱스&lt;/a&gt; 에서 &lt;a href=&quot;../kotlin/-byte-array/index#kotlin.ByteArray&quot;&gt;ByteArray&lt;/a&gt; 바이트 버퍼에서 &lt;a href=&quot;../kotlin/-double/index#kotlin.Double&quot;&gt;Double&lt;/a&gt; 을 설정 합니다.</target>
        </trans-unit>
        <trans-unit id="66b277295ea869aa45f112638839d6a36ddd88a7" translate="yes" xml:space="preserve">
          <source>Sets &lt;a href=&quot;../kotlin/-float/index#kotlin.Float&quot;&gt;Float&lt;/a&gt; out of the &lt;a href=&quot;../kotlin/-byte-array/index#kotlin.ByteArray&quot;&gt;ByteArray&lt;/a&gt; byte buffer at specified index &lt;a href=&quot;set-float-at#kotlin.native%24setFloatAt%28kotlin.ByteArray%2C+kotlin.Int%2C+kotlin.Float%29%2Findex&quot;&gt;index&lt;/a&gt;</source>
          <target state="translated">지정된 인덱스 &lt;a href=&quot;set-float-at#kotlin.native%24setFloatAt%28kotlin.ByteArray%2C+kotlin.Int%2C+kotlin.Float%29%2Findex&quot;&gt;인덱스&lt;/a&gt; 에서 &lt;a href=&quot;../kotlin/-byte-array/index#kotlin.ByteArray&quot;&gt;ByteArray&lt;/a&gt; 바이트 버퍼에서 &lt;a href=&quot;../kotlin/-float/index#kotlin.Float&quot;&gt;Float&lt;/a&gt; 를 설정 합니다.</target>
        </trans-unit>
        <trans-unit id="eeddfac7038244af25d78ade965c0d83befca8e5" translate="yes" xml:space="preserve">
          <source>Sets &lt;a href=&quot;../kotlin/-int/index#kotlin.Int&quot;&gt;Int&lt;/a&gt; out of the &lt;a href=&quot;../kotlin/-byte-array/index#kotlin.ByteArray&quot;&gt;ByteArray&lt;/a&gt; byte buffer at specified index &lt;a href=&quot;set-int-at#kotlin.native%24setIntAt%28kotlin.ByteArray%2C+kotlin.Int%2C+kotlin.Int%29%2Findex&quot;&gt;index&lt;/a&gt;</source>
          <target state="translated">지정된 인덱스 &lt;a href=&quot;set-int-at#kotlin.native%24setIntAt%28kotlin.ByteArray%2C+kotlin.Int%2C+kotlin.Int%29%2Findex&quot;&gt;인덱스&lt;/a&gt; 에서 &lt;a href=&quot;../kotlin/-byte-array/index#kotlin.ByteArray&quot;&gt;ByteArray&lt;/a&gt; 바이트 버퍼에서 &lt;a href=&quot;../kotlin/-int/index#kotlin.Int&quot;&gt;Int&lt;/a&gt; 를 설정 합니다.</target>
        </trans-unit>
        <trans-unit id="2a5595b9f2b46318a666585b89bac1d7a504ef30" translate="yes" xml:space="preserve">
          <source>Sets &lt;a href=&quot;../kotlin/-long/index#kotlin.Long&quot;&gt;Long&lt;/a&gt; out of the &lt;a href=&quot;../kotlin/-byte-array/index#kotlin.ByteArray&quot;&gt;ByteArray&lt;/a&gt; byte buffer at specified index &lt;a href=&quot;set-long-at#kotlin.native%24setLongAt%28kotlin.ByteArray%2C+kotlin.Int%2C+kotlin.Long%29%2Findex&quot;&gt;index&lt;/a&gt;</source>
          <target state="translated">지정된 인덱스 &lt;a href=&quot;set-long-at#kotlin.native%24setLongAt%28kotlin.ByteArray%2C+kotlin.Int%2C+kotlin.Long%29%2Findex&quot;&gt;인덱스&lt;/a&gt; 에서 &lt;a href=&quot;../kotlin/-byte-array/index#kotlin.ByteArray&quot;&gt;ByteArray&lt;/a&gt; 바이트 버퍼 의 &lt;a href=&quot;../kotlin/-long/index#kotlin.Long&quot;&gt;Long&lt;/a&gt; 을 설정 합니다.</target>
        </trans-unit>
        <trans-unit id="61468958fc1d048054f7da161eb41f9a095e74ff" translate="yes" xml:space="preserve">
          <source>Sets &lt;a href=&quot;../kotlin/-short/index#kotlin.Short&quot;&gt;Short&lt;/a&gt; out of the &lt;a href=&quot;../kotlin/-byte-array/index#kotlin.ByteArray&quot;&gt;ByteArray&lt;/a&gt; byte buffer at specified index &lt;a href=&quot;set-short-at#kotlin.native%24setShortAt%28kotlin.ByteArray%2C+kotlin.Int%2C+kotlin.Short%29%2Findex&quot;&gt;index&lt;/a&gt;</source>
          <target state="translated">설정 &lt;a href=&quot;../kotlin/-short/index#kotlin.Short&quot;&gt;짧은&lt;/a&gt; 의 아웃 &lt;a href=&quot;../kotlin/-byte-array/index#kotlin.ByteArray&quot;&gt;된 ByteArray&lt;/a&gt; 지정된 인덱스에서 바이트 버퍼 &lt;a href=&quot;set-short-at#kotlin.native%24setShortAt%28kotlin.ByteArray%2C+kotlin.Int%2C+kotlin.Short%29%2Findex&quot;&gt;인덱스&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="d1af430d4c7c33f49b906ac16225b3535913e1cd" translate="yes" xml:space="preserve">
          <source>Sets &lt;code&gt;ACC_SYNTHETIC&lt;/code&gt; flag on the annotated target in the Java bytecode.</source>
          <target state="translated">Java 바이트 코드의 주석이 달린 대상에 &lt;code&gt;ACC_SYNTHETIC&lt;/code&gt; 플래그를 설정 합니다.</target>
        </trans-unit>
        <trans-unit id="d34e821a8392e5cf541ba4b173e3093815cd886a" translate="yes" xml:space="preserve">
          <source>Sets UByte out of the &lt;a href=&quot;../kotlin/-byte-array/index#kotlin.ByteArray&quot;&gt;ByteArray&lt;/a&gt; byte buffer at specified index &lt;a href=&quot;set-u-byte-at#kotlin.native%24setUByteAt%28kotlin.ByteArray%2C+kotlin.Int%2C+kotlin.UByte%29%2Findex&quot;&gt;index&lt;/a&gt;</source>
          <target state="translated">지정된 인덱스 &lt;a href=&quot;set-u-byte-at#kotlin.native%24setUByteAt%28kotlin.ByteArray%2C+kotlin.Int%2C+kotlin.UByte%29%2Findex&quot;&gt;인덱스&lt;/a&gt; 에서 &lt;a href=&quot;../kotlin/-byte-array/index#kotlin.ByteArray&quot;&gt;ByteArray&lt;/a&gt; 바이트 버퍼에서 UByte를 설정 합니다.</target>
        </trans-unit>
        <trans-unit id="4a5da7cc264882bdd0383657b09985b2b48c35af" translate="yes" xml:space="preserve">
          <source>Sets UByte out of the &lt;a href=&quot;index#kotlin.ByteArray&quot;&gt;ByteArray&lt;/a&gt; byte buffer at specified index &lt;a href=&quot;../../kotlin.native/set-u-byte-at#kotlin.native%24setUByteAt%28kotlin.ByteArray%2C+kotlin.Int%2C+kotlin.UByte%29%2Findex&quot;&gt;index&lt;/a&gt;</source>
          <target state="translated">지정된 인덱스 &lt;a href=&quot;../../kotlin.native/set-u-byte-at#kotlin.native%24setUByteAt%28kotlin.ByteArray%2C+kotlin.Int%2C+kotlin.UByte%29%2Findex&quot;&gt;인덱스&lt;/a&gt; 에서 &lt;a href=&quot;index#kotlin.ByteArray&quot;&gt;ByteArray&lt;/a&gt; 바이트 버퍼에서 UByte를 설정 합니다.</target>
        </trans-unit>
        <trans-unit id="5752ba22649c586941889dd2a62fae9914f91863" translate="yes" xml:space="preserve">
          <source>Sets UInt out of the &lt;a href=&quot;../kotlin/-byte-array/index#kotlin.ByteArray&quot;&gt;ByteArray&lt;/a&gt; byte buffer at specified index &lt;a href=&quot;set-u-int-at#kotlin.native%24setUIntAt%28kotlin.ByteArray%2C+kotlin.Int%2C+kotlin.UInt%29%2Findex&quot;&gt;index&lt;/a&gt;</source>
          <target state="translated">지정된 인덱스 &lt;a href=&quot;set-u-int-at#kotlin.native%24setUIntAt%28kotlin.ByteArray%2C+kotlin.Int%2C+kotlin.UInt%29%2Findex&quot;&gt;인덱스&lt;/a&gt; 에서 &lt;a href=&quot;../kotlin/-byte-array/index#kotlin.ByteArray&quot;&gt;ByteArray&lt;/a&gt; 바이트 버퍼에서 UInt를 설정 합니다.</target>
        </trans-unit>
        <trans-unit id="3cdc755ff5323ee1cc48907c601573c3854d5185" translate="yes" xml:space="preserve">
          <source>Sets UInt out of the &lt;a href=&quot;index#kotlin.ByteArray&quot;&gt;ByteArray&lt;/a&gt; byte buffer at specified index &lt;a href=&quot;../../kotlin.native/set-u-int-at#kotlin.native%24setUIntAt%28kotlin.ByteArray%2C+kotlin.Int%2C+kotlin.UInt%29%2Findex&quot;&gt;index&lt;/a&gt;</source>
          <target state="translated">지정된 인덱스 &lt;a href=&quot;../../kotlin.native/set-u-int-at#kotlin.native%24setUIntAt%28kotlin.ByteArray%2C+kotlin.Int%2C+kotlin.UInt%29%2Findex&quot;&gt;인덱스&lt;/a&gt; 에서 &lt;a href=&quot;index#kotlin.ByteArray&quot;&gt;ByteArray&lt;/a&gt; 바이트 버퍼에서 UInt를 설정 합니다.</target>
        </trans-unit>
        <trans-unit id="75425820919865f6e0a6f27b614d44e86b6f6faf" translate="yes" xml:space="preserve">
          <source>Sets ULong out of the &lt;a href=&quot;../kotlin/-byte-array/index#kotlin.ByteArray&quot;&gt;ByteArray&lt;/a&gt; byte buffer at specified index &lt;a href=&quot;set-u-long-at#kotlin.native%24setULongAt%28kotlin.ByteArray%2C+kotlin.Int%2C+kotlin.ULong%29%2Findex&quot;&gt;index&lt;/a&gt;</source>
          <target state="translated">지정된 인덱스 &lt;a href=&quot;set-u-long-at#kotlin.native%24setULongAt%28kotlin.ByteArray%2C+kotlin.Int%2C+kotlin.ULong%29%2Findex&quot;&gt;인덱스&lt;/a&gt; 에서 &lt;a href=&quot;../kotlin/-byte-array/index#kotlin.ByteArray&quot;&gt;ByteArray&lt;/a&gt; 바이트 버퍼에서 ULong을 설정 합니다.</target>
        </trans-unit>
        <trans-unit id="bb90a94951e0937badd2c5a974e39954d8e1c0fa" translate="yes" xml:space="preserve">
          <source>Sets ULong out of the &lt;a href=&quot;index#kotlin.ByteArray&quot;&gt;ByteArray&lt;/a&gt; byte buffer at specified index &lt;a href=&quot;../../kotlin.native/set-u-long-at#kotlin.native%24setULongAt%28kotlin.ByteArray%2C+kotlin.Int%2C+kotlin.ULong%29%2Findex&quot;&gt;index&lt;/a&gt;</source>
          <target state="translated">지정된 인덱스 &lt;a href=&quot;../../kotlin.native/set-u-long-at#kotlin.native%24setULongAt%28kotlin.ByteArray%2C+kotlin.Int%2C+kotlin.ULong%29%2Findex&quot;&gt;인덱스&lt;/a&gt; 에서 &lt;a href=&quot;index#kotlin.ByteArray&quot;&gt;ByteArray&lt;/a&gt; 바이트 버퍼에서 ULong을 설정 합니다.</target>
        </trans-unit>
        <trans-unit id="7f67e637b58367e0b58957c4447941673cd92e71" translate="yes" xml:space="preserve">
          <source>Sets UShort out of the &lt;a href=&quot;../kotlin/-byte-array/index#kotlin.ByteArray&quot;&gt;ByteArray&lt;/a&gt; byte buffer at specified index &lt;a href=&quot;set-u-short-at#kotlin.native%24setUShortAt%28kotlin.ByteArray%2C+kotlin.Int%2C+kotlin.UShort%29%2Findex&quot;&gt;index&lt;/a&gt;</source>
          <target state="translated">지정된 인덱스 &lt;a href=&quot;set-u-short-at#kotlin.native%24setUShortAt%28kotlin.ByteArray%2C+kotlin.Int%2C+kotlin.UShort%29%2Findex&quot;&gt;인덱스&lt;/a&gt; 에서 &lt;a href=&quot;../kotlin/-byte-array/index#kotlin.ByteArray&quot;&gt;ByteArray&lt;/a&gt; 바이트 버퍼에서 UShort를 설정 합니다.</target>
        </trans-unit>
        <trans-unit id="728922f760b44c69e0b00d27282cd57c2b6e1fca" translate="yes" xml:space="preserve">
          <source>Sets UShort out of the &lt;a href=&quot;index#kotlin.ByteArray&quot;&gt;ByteArray&lt;/a&gt; byte buffer at specified index &lt;a href=&quot;../../kotlin.native/set-u-short-at#kotlin.native%24setUShortAt%28kotlin.ByteArray%2C+kotlin.Int%2C+kotlin.UShort%29%2Findex&quot;&gt;index&lt;/a&gt;</source>
          <target state="translated">지정된 인덱스 &lt;a href=&quot;../../kotlin.native/set-u-short-at#kotlin.native%24setUShortAt%28kotlin.ByteArray%2C+kotlin.Int%2C+kotlin.UShort%29%2Findex&quot;&gt;인덱스&lt;/a&gt; 에서 &lt;a href=&quot;index#kotlin.ByteArray&quot;&gt;ByteArray&lt;/a&gt; 바이트 버퍼에서 UShort를 설정 합니다.</target>
        </trans-unit>
        <trans-unit id="2900fbda2209cd97da96efa3c37d34a717e8828a" translate="yes" xml:space="preserve">
          <source>Sets a callback &lt;a href=&quot;on-leave#kotlin.io.FileTreeWalk%24onLeave%28kotlin.Function1%28%28java.io.File%2C+kotlin.Unit%29%29%29%2Ffunction&quot;&gt;function&lt;/a&gt;, that is called on any left directory after its files are visited and after it is visited itself.</source>
          <target state="translated">콜백 &lt;a href=&quot;on-leave#kotlin.io.FileTreeWalk%24onLeave%28kotlin.Function1%28%28java.io.File%2C+kotlin.Unit%29%29%29%2Ffunction&quot;&gt;함수를&lt;/a&gt; 설정 합니다 . 즉, 파일을 방문한 후 방문한 후 왼쪽 디렉토리에서 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="b4931c0365ff304a815c6963d0bd7edb11b7c94c" translate="yes" xml:space="preserve">
          <source>Sets a predicate &lt;a href=&quot;on-enter#kotlin.io.FileTreeWalk%24onEnter%28kotlin.Function1%28%28java.io.File%2C+kotlin.Boolean%29%29%29%2Ffunction&quot;&gt;function&lt;/a&gt;, that is called on any entered directory before its files are visited and before it is visited itself.</source>
          <target state="translated">파일을 방문하기 전과 방문하기 전에 입력 한 디렉토리에서 호출 되는 술어 &lt;a href=&quot;on-enter#kotlin.io.FileTreeWalk%24onEnter%28kotlin.Function1%28%28java.io.File%2C+kotlin.Boolean%29%29%29%2Ffunction&quot;&gt;함수를&lt;/a&gt; 설정 합니다.</target>
        </trans-unit>
        <trans-unit id="307c3b08228d209c4b76f0067076574f4a4d01fe" translate="yes" xml:space="preserve">
          <source>Sets all bits in the BitSet to &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">BitSet의 모든 비트를 &lt;code&gt;false&lt;/code&gt; 로 설정합니다 .</target>
        </trans-unit>
        <trans-unit id="18c1c389ab129422cb72a224859d0ea272965e3c" translate="yes" xml:space="preserve">
          <source>Sets the array element at the specified &lt;a href=&quot;set#kotlin.Array%24set%28kotlin.Int%2C+kotlin.Array.T%29%2Findex&quot;&gt;index&lt;/a&gt; to the specified &lt;a href=&quot;set#kotlin.Array%24set%28kotlin.Int%2C+kotlin.Array.T%29%2Fvalue&quot;&gt;value&lt;/a&gt;. This method can be called using the index operator.</source>
          <target state="translated">지정된 &lt;a href=&quot;set#kotlin.Array%24set%28kotlin.Int%2C+kotlin.Array.T%29%2Findex&quot;&gt;인덱스&lt;/a&gt; 의 배열 요소를 지정된 &lt;a href=&quot;set#kotlin.Array%24set%28kotlin.Int%2C+kotlin.Array.T%29%2Fvalue&quot;&gt;값으로 설정&lt;/a&gt; 합니다. 이 메소드는 인덱스 연산자를 사용하여 호출 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9d82a173af7eab575c81214cafeae19267b32c70" translate="yes" xml:space="preserve">
          <source>Sets the bits from the range specified to the specified value.</source>
          <target state="translated">지정된 범위에서 지정된 값으로 비트를 설정합니다.</target>
        </trans-unit>
        <trans-unit id="9899dc3d49007fa7979991a572ef97990d1ed640" translate="yes" xml:space="preserve">
          <source>Sets the bits with indices between &lt;a href=&quot;set#kotlin.native.BitSet%24set%28kotlin.Int%2C+kotlin.Int%2C+kotlin.Boolean%29%2Ffrom&quot;&gt;from&lt;/a&gt; (inclusive) and &lt;a href=&quot;set#kotlin.native.BitSet%24set%28kotlin.Int%2C+kotlin.Int%2C+kotlin.Boolean%29%2Fto&quot;&gt;to&lt;/a&gt; (exclusive) to the specified value.</source>
          <target state="translated">사이 세트 인덱스와 비트 &lt;a href=&quot;set#kotlin.native.BitSet%24set%28kotlin.Int%2C+kotlin.Int%2C+kotlin.Boolean%29%2Ffrom&quot;&gt;로부터&lt;/a&gt; (포함) 및 &lt;a href=&quot;set#kotlin.native.BitSet%24set%28kotlin.Int%2C+kotlin.Int%2C+kotlin.Boolean%29%2Fto&quot;&gt;에&lt;/a&gt; 지정된 값 (배타적).</target>
        </trans-unit>
        <trans-unit id="29eedbac3d423a05f8d6c883690bdaab95095996" translate="yes" xml:space="preserve">
          <source>Sets the character at the specified &lt;a href=&quot;../set#kotlin.text%24set%28kotlin.text.StringBuilder%2C+kotlin.Int%2C+kotlin.Char%29%2Findex&quot;&gt;index&lt;/a&gt; to the specified &lt;a href=&quot;../set#kotlin.text%24set%28kotlin.text.StringBuilder%2C+kotlin.Int%2C+kotlin.Char%29%2Fvalue&quot;&gt;value&lt;/a&gt;.</source>
          <target state="translated">지정된 &lt;a href=&quot;../set#kotlin.text%24set%28kotlin.text.StringBuilder%2C+kotlin.Int%2C+kotlin.Char%29%2Findex&quot;&gt;색인&lt;/a&gt; 의 문자를 지정된 &lt;a href=&quot;../set#kotlin.text%24set%28kotlin.text.StringBuilder%2C+kotlin.Int%2C+kotlin.Char%29%2Fvalue&quot;&gt;값으로 설정&lt;/a&gt; 합니다.</target>
        </trans-unit>
        <trans-unit id="bb0b8fa0b347b9b16fd63e06b5bd3a87260d83b6" translate="yes" xml:space="preserve">
          <source>Sets the character at the specified &lt;a href=&quot;set#kotlin.text%24set%28java.lang.StringBuilder%2C+kotlin.Int%2C+kotlin.Char%29%2Findex&quot;&gt;index&lt;/a&gt; to the specified &lt;a href=&quot;set#kotlin.text%24set%28java.lang.StringBuilder%2C+kotlin.Int%2C+kotlin.Char%29%2Fvalue&quot;&gt;value&lt;/a&gt;.</source>
          <target state="translated">지정된 &lt;a href=&quot;set#kotlin.text%24set%28java.lang.StringBuilder%2C+kotlin.Int%2C+kotlin.Char%29%2Findex&quot;&gt;색인&lt;/a&gt; 의 문자를 지정된 &lt;a href=&quot;set#kotlin.text%24set%28java.lang.StringBuilder%2C+kotlin.Int%2C+kotlin.Char%29%2Fvalue&quot;&gt;값으로 설정&lt;/a&gt; 합니다.</target>
        </trans-unit>
        <trans-unit id="80c69316a95fe7e772cb32ac7444e561620116af" translate="yes" xml:space="preserve">
          <source>Sets the character at the specified &lt;a href=&quot;set#kotlin.text%24set%28kotlin.text.StringBuilder%2C+kotlin.Int%2C+kotlin.Char%29%2Findex&quot;&gt;index&lt;/a&gt; to the specified &lt;a href=&quot;set#kotlin.text%24set%28kotlin.text.StringBuilder%2C+kotlin.Int%2C+kotlin.Char%29%2Fvalue&quot;&gt;value&lt;/a&gt;.</source>
          <target state="translated">지정된 &lt;a href=&quot;set#kotlin.text%24set%28kotlin.text.StringBuilder%2C+kotlin.Int%2C+kotlin.Char%29%2Findex&quot;&gt;색인&lt;/a&gt; 의 문자를 지정된 &lt;a href=&quot;set#kotlin.text%24set%28kotlin.text.StringBuilder%2C+kotlin.Int%2C+kotlin.Char%29%2Fvalue&quot;&gt;값으로 설정&lt;/a&gt; 합니다.</target>
        </trans-unit>
        <trans-unit id="185823a70e02396c0095a3ef140632cd0481c79c" translate="yes" xml:space="preserve">
          <source>Sets the content of this file as &lt;a href=&quot;write-text#kotlin.io%24writeText%28java.io.File%2C+kotlin.String%2C+java.nio.charset.Charset%29%2Ftext&quot;&gt;text&lt;/a&gt; encoded using UTF-8 or specified &lt;a href=&quot;write-text#kotlin.io%24writeText%28java.io.File%2C+kotlin.String%2C+java.nio.charset.Charset%29%2Fcharset&quot;&gt;charset&lt;/a&gt;. If this file exists, it becomes overwritten.</source>
          <target state="translated">이 파일의 내용을 UTF-8 또는 지정된 &lt;a href=&quot;write-text#kotlin.io%24writeText%28java.io.File%2C+kotlin.String%2C+java.nio.charset.Charset%29%2Fcharset&quot;&gt;문자 세트를&lt;/a&gt; 사용하여 인코딩 된 &lt;a href=&quot;write-text#kotlin.io%24writeText%28java.io.File%2C+kotlin.String%2C+java.nio.charset.Charset%29%2Ftext&quot;&gt;텍스트&lt;/a&gt; 로 설정합니다 . 이 파일이 있으면 덮어 씁니다.</target>
        </trans-unit>
        <trans-unit id="9941f1f77af3ee35fb2ffb4e3a7bcfed1b02697f" translate="yes" xml:space="preserve">
          <source>Sets the content of this file as an &lt;a href=&quot;write-bytes#kotlin.io%24writeBytes%28java.io.File%2C+kotlin.ByteArray%29%2Farray&quot;&gt;array&lt;/a&gt; of bytes. If this file already exists, it becomes overwritten.</source>
          <target state="translated">이 파일의 내용 을 바이트 &lt;a href=&quot;write-bytes#kotlin.io%24writeBytes%28java.io.File%2C+kotlin.ByteArray%29%2Farray&quot;&gt;배열&lt;/a&gt; 로 설정합니다. 이 파일이 이미 있으면 덮어 씁니다.</target>
        </trans-unit>
        <trans-unit id="77e69f5b00ef9d6b815b0ece296a85d9aa969669" translate="yes" xml:space="preserve">
          <source>Sets the element at the given &lt;a href=&quot;set#kotlin.BooleanArray%24set%28kotlin.Int%2C+kotlin.Boolean%29%2Findex&quot;&gt;index&lt;/a&gt; to the given &lt;a href=&quot;set#kotlin.BooleanArray%24set%28kotlin.Int%2C+kotlin.Boolean%29%2Fvalue&quot;&gt;value&lt;/a&gt;. This method can be called using the index operator.</source>
          <target state="translated">지정된 &lt;a href=&quot;set#kotlin.BooleanArray%24set%28kotlin.Int%2C+kotlin.Boolean%29%2Findex&quot;&gt;인덱스&lt;/a&gt; 의 요소를 지정된 &lt;a href=&quot;set#kotlin.BooleanArray%24set%28kotlin.Int%2C+kotlin.Boolean%29%2Fvalue&quot;&gt;값으로 설정&lt;/a&gt; 합니다. 이 메소드는 인덱스 연산자를 사용하여 호출 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4baf2dc9994143edc877b925018d335cd4836753" translate="yes" xml:space="preserve">
          <source>Sets the element at the given &lt;a href=&quot;set#kotlin.ByteArray%24set%28kotlin.Int%2C+kotlin.Byte%29%2Findex&quot;&gt;index&lt;/a&gt; to the given &lt;a href=&quot;set#kotlin.ByteArray%24set%28kotlin.Int%2C+kotlin.Byte%29%2Fvalue&quot;&gt;value&lt;/a&gt;. This method can be called using the index operator.</source>
          <target state="translated">지정된 &lt;a href=&quot;set#kotlin.ByteArray%24set%28kotlin.Int%2C+kotlin.Byte%29%2Findex&quot;&gt;인덱스&lt;/a&gt; 의 요소를 지정된 &lt;a href=&quot;set#kotlin.ByteArray%24set%28kotlin.Int%2C+kotlin.Byte%29%2Fvalue&quot;&gt;값으로 설정&lt;/a&gt; 합니다. 이 메소드는 인덱스 연산자를 사용하여 호출 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4f10456289ed125c34024c96a9f3fced96e1084a" translate="yes" xml:space="preserve">
          <source>Sets the element at the given &lt;a href=&quot;set#kotlin.CharArray%24set%28kotlin.Int%2C+kotlin.Char%29%2Findex&quot;&gt;index&lt;/a&gt; to the given &lt;a href=&quot;set#kotlin.CharArray%24set%28kotlin.Int%2C+kotlin.Char%29%2Fvalue&quot;&gt;value&lt;/a&gt;. This method can be called using the index operator.</source>
          <target state="translated">지정된 &lt;a href=&quot;set#kotlin.CharArray%24set%28kotlin.Int%2C+kotlin.Char%29%2Findex&quot;&gt;인덱스&lt;/a&gt; 의 요소를 지정된 &lt;a href=&quot;set#kotlin.CharArray%24set%28kotlin.Int%2C+kotlin.Char%29%2Fvalue&quot;&gt;값으로 설정&lt;/a&gt; 합니다. 이 메소드는 인덱스 연산자를 사용하여 호출 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9061b224d8142ce983f37941237124f97fb7de8c" translate="yes" xml:space="preserve">
          <source>Sets the element at the given &lt;a href=&quot;set#kotlin.DoubleArray%24set%28kotlin.Int%2C+kotlin.Double%29%2Findex&quot;&gt;index&lt;/a&gt; to the given &lt;a href=&quot;set#kotlin.DoubleArray%24set%28kotlin.Int%2C+kotlin.Double%29%2Fvalue&quot;&gt;value&lt;/a&gt;. This method can be called using the index operator.</source>
          <target state="translated">지정된 &lt;a href=&quot;set#kotlin.DoubleArray%24set%28kotlin.Int%2C+kotlin.Double%29%2Findex&quot;&gt;인덱스&lt;/a&gt; 의 요소를 지정된 &lt;a href=&quot;set#kotlin.DoubleArray%24set%28kotlin.Int%2C+kotlin.Double%29%2Fvalue&quot;&gt;값으로 설정&lt;/a&gt; 합니다. 이 메소드는 인덱스 연산자를 사용하여 호출 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ec29a002b4c8ae3cba11729f4f8d9d60c8ea931e" translate="yes" xml:space="preserve">
          <source>Sets the element at the given &lt;a href=&quot;set#kotlin.FloatArray%24set%28kotlin.Int%2C+kotlin.Float%29%2Findex&quot;&gt;index&lt;/a&gt; to the given &lt;a href=&quot;set#kotlin.FloatArray%24set%28kotlin.Int%2C+kotlin.Float%29%2Fvalue&quot;&gt;value&lt;/a&gt;. This method can be called using the index operator.</source>
          <target state="translated">지정된 &lt;a href=&quot;set#kotlin.FloatArray%24set%28kotlin.Int%2C+kotlin.Float%29%2Findex&quot;&gt;인덱스&lt;/a&gt; 의 요소를 지정된 &lt;a href=&quot;set#kotlin.FloatArray%24set%28kotlin.Int%2C+kotlin.Float%29%2Fvalue&quot;&gt;값으로 설정&lt;/a&gt; 합니다. 이 메소드는 인덱스 연산자를 사용하여 호출 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6e8d5814f499c6b4da621128bc725e00fe86459f" translate="yes" xml:space="preserve">
          <source>Sets the element at the given &lt;a href=&quot;set#kotlin.IntArray%24set%28kotlin.Int%2C+kotlin.Int%29%2Findex&quot;&gt;index&lt;/a&gt; to the given &lt;a href=&quot;set#kotlin.IntArray%24set%28kotlin.Int%2C+kotlin.Int%29%2Fvalue&quot;&gt;value&lt;/a&gt;. This method can be called using the index operator.</source>
          <target state="translated">지정된 &lt;a href=&quot;set#kotlin.IntArray%24set%28kotlin.Int%2C+kotlin.Int%29%2Findex&quot;&gt;인덱스&lt;/a&gt; 의 요소를 지정된 &lt;a href=&quot;set#kotlin.IntArray%24set%28kotlin.Int%2C+kotlin.Int%29%2Fvalue&quot;&gt;값으로 설정&lt;/a&gt; 합니다. 이 메소드는 인덱스 연산자를 사용하여 호출 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="54f288bc8477e9a77bca52d3a82f8f513baf826b" translate="yes" xml:space="preserve">
          <source>Sets the element at the given &lt;a href=&quot;set#kotlin.LongArray%24set%28kotlin.Int%2C+kotlin.Long%29%2Findex&quot;&gt;index&lt;/a&gt; to the given &lt;a href=&quot;set#kotlin.LongArray%24set%28kotlin.Int%2C+kotlin.Long%29%2Fvalue&quot;&gt;value&lt;/a&gt;. This method can be called using the index operator.</source>
          <target state="translated">지정된 &lt;a href=&quot;set#kotlin.LongArray%24set%28kotlin.Int%2C+kotlin.Long%29%2Findex&quot;&gt;인덱스&lt;/a&gt; 의 요소를 지정된 &lt;a href=&quot;set#kotlin.LongArray%24set%28kotlin.Int%2C+kotlin.Long%29%2Fvalue&quot;&gt;값으로 설정&lt;/a&gt; 합니다. 이 메소드는 인덱스 연산자를 사용하여 호출 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="bba404ae951c063d7104d314046303877f1e90e3" translate="yes" xml:space="preserve">
          <source>Sets the element at the given &lt;a href=&quot;set#kotlin.ShortArray%24set%28kotlin.Int%2C+kotlin.Short%29%2Findex&quot;&gt;index&lt;/a&gt; to the given &lt;a href=&quot;set#kotlin.ShortArray%24set%28kotlin.Int%2C+kotlin.Short%29%2Fvalue&quot;&gt;value&lt;/a&gt;. This method can be called using the index operator.</source>
          <target state="translated">지정된 &lt;a href=&quot;set#kotlin.ShortArray%24set%28kotlin.Int%2C+kotlin.Short%29%2Findex&quot;&gt;인덱스&lt;/a&gt; 의 요소를 지정된 &lt;a href=&quot;set#kotlin.ShortArray%24set%28kotlin.Int%2C+kotlin.Short%29%2Fvalue&quot;&gt;값으로 설정&lt;/a&gt; 합니다. 이 메소드는 인덱스 연산자를 사용하여 호출 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2276370231d8bc10f6cfe6b1e5980d4b15dde8de" translate="yes" xml:space="preserve">
          <source>Sets the element at the given &lt;a href=&quot;set#kotlin.UByteArray%24set%28kotlin.Int%2C+kotlin.UByte%29%2Findex&quot;&gt;index&lt;/a&gt; to the given &lt;a href=&quot;set#kotlin.UByteArray%24set%28kotlin.Int%2C+kotlin.UByte%29%2Fvalue&quot;&gt;value&lt;/a&gt;. This method can be called using the index operator.</source>
          <target state="translated">지정된 &lt;a href=&quot;set#kotlin.UByteArray%24set%28kotlin.Int%2C+kotlin.UByte%29%2Findex&quot;&gt;인덱스&lt;/a&gt; 의 요소를 지정된 &lt;a href=&quot;set#kotlin.UByteArray%24set%28kotlin.Int%2C+kotlin.UByte%29%2Fvalue&quot;&gt;값으로 설정&lt;/a&gt; 합니다. 이 메소드는 인덱스 연산자를 사용하여 호출 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="242acce212e00f9853c222dc79085c2d4bf25a88" translate="yes" xml:space="preserve">
          <source>Sets the element at the given &lt;a href=&quot;set#kotlin.UIntArray%24set%28kotlin.Int%2C+kotlin.UInt%29%2Findex&quot;&gt;index&lt;/a&gt; to the given &lt;a href=&quot;set#kotlin.UIntArray%24set%28kotlin.Int%2C+kotlin.UInt%29%2Fvalue&quot;&gt;value&lt;/a&gt;. This method can be called using the index operator.</source>
          <target state="translated">지정된 &lt;a href=&quot;set#kotlin.UIntArray%24set%28kotlin.Int%2C+kotlin.UInt%29%2Findex&quot;&gt;인덱스&lt;/a&gt; 의 요소를 지정된 &lt;a href=&quot;set#kotlin.UIntArray%24set%28kotlin.Int%2C+kotlin.UInt%29%2Fvalue&quot;&gt;값으로 설정&lt;/a&gt; 합니다. 이 메소드는 인덱스 연산자를 사용하여 호출 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9c8d086faad98cba0d4d2474417843e8c2654c33" translate="yes" xml:space="preserve">
          <source>Sets the element at the given &lt;a href=&quot;set#kotlin.ULongArray%24set%28kotlin.Int%2C+kotlin.ULong%29%2Findex&quot;&gt;index&lt;/a&gt; to the given &lt;a href=&quot;set#kotlin.ULongArray%24set%28kotlin.Int%2C+kotlin.ULong%29%2Fvalue&quot;&gt;value&lt;/a&gt;. This method can be called using the index operator.</source>
          <target state="translated">지정된 &lt;a href=&quot;set#kotlin.ULongArray%24set%28kotlin.Int%2C+kotlin.ULong%29%2Findex&quot;&gt;인덱스&lt;/a&gt; 의 요소를 지정된 &lt;a href=&quot;set#kotlin.ULongArray%24set%28kotlin.Int%2C+kotlin.ULong%29%2Fvalue&quot;&gt;값으로 설정&lt;/a&gt; 합니다. 이 메소드는 인덱스 연산자를 사용하여 호출 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="83d722d43b55121439e406624afd6b4f5e5e2bf2" translate="yes" xml:space="preserve">
          <source>Sets the element at the given &lt;a href=&quot;set#kotlin.UShortArray%24set%28kotlin.Int%2C+kotlin.UShort%29%2Findex&quot;&gt;index&lt;/a&gt; to the given &lt;a href=&quot;set#kotlin.UShortArray%24set%28kotlin.Int%2C+kotlin.UShort%29%2Fvalue&quot;&gt;value&lt;/a&gt;. This method can be called using the index operator.</source>
          <target state="translated">지정된 &lt;a href=&quot;set#kotlin.UShortArray%24set%28kotlin.Int%2C+kotlin.UShort%29%2Findex&quot;&gt;인덱스&lt;/a&gt; 의 요소를 지정된 &lt;a href=&quot;set#kotlin.UShortArray%24set%28kotlin.Int%2C+kotlin.UShort%29%2Fvalue&quot;&gt;값으로 설정&lt;/a&gt; 합니다. 이 메소드는 인덱스 연산자를 사용하여 호출 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="cdbfa1a2b3fcbca7289df75f3d9da6a49af783aa" translate="yes" xml:space="preserve">
          <source>Sets the maximum &lt;a href=&quot;max-depth#kotlin.io.FileTreeWalk%24maxDepth%28kotlin.Int%29%2Fdepth&quot;&gt;depth&lt;/a&gt; of a directory tree to traverse. By default there is no limit.</source>
          <target state="translated">트래버스 할 디렉토리 트리 의 최대 &lt;a href=&quot;max-depth#kotlin.io.FileTreeWalk%24maxDepth%28kotlin.Int%29%2Fdepth&quot;&gt;깊이&lt;/a&gt; 를 설정합니다 . 기본적으로 제한이 없습니다.</target>
        </trans-unit>
        <trans-unit id="7f557c804ed296d322f4a5e5bfe00660a8f6e3a4" translate="yes" xml:space="preserve">
          <source>Sets the next value in the iteration, called from the &lt;a href=&quot;compute-next&quot;&gt;computeNext&lt;/a&gt; function</source>
          <target state="translated">&lt;a href=&quot;compute-next&quot;&gt;computeNext&lt;/a&gt; 함수 에서 호출 된 반복의 다음 값을 설정합니다.</target>
        </trans-unit>
        <trans-unit id="4250580fbd524d1fd8d6ec08be759b582c4fb702" translate="yes" xml:space="preserve">
          <source>Sets the state to done so that the iteration terminates.</source>
          <target state="translated">반복이 종료되도록 상태를 완료로 설정합니다.</target>
        </trans-unit>
        <trans-unit id="612c0835d62f2410d2f8de6e6d5fc77a9b31d932" translate="yes" xml:space="preserve">
          <source>Sets the value of the property for the given object.</source>
          <target state="translated">주어진 객체의 속성 값을 설정합니다.</target>
        </trans-unit>
        <trans-unit id="9c35e499a0854cb5e1b033a2aea56399d4cfd894" translate="yes" xml:space="preserve">
          <source>Setter</source>
          <target state="translated">Setter</target>
        </trans-unit>
        <trans-unit id="da16c3cc3bfdcae6d86bd6879d30abd5784e4921" translate="yes" xml:space="preserve">
          <source>Setter of the property is a &lt;code&gt;set&lt;/code&gt; method declared alongside the property.</source>
          <target state="translated">속성의 Setter는 속성 과 함께 선언 된 &lt;code&gt;set&lt;/code&gt; 메서드입니다.</target>
        </trans-unit>
        <trans-unit id="795e6d53d5731fd7b921da0b1d365fac3636f285" translate="yes" xml:space="preserve">
          <source>Setters and getters</source>
          <target state="translated">세터와 게터</target>
        </trans-unit>
        <trans-unit id="d099d87160d087f60ade9cb21fa5440ff2125280" translate="yes" xml:space="preserve">
          <source>Setting Up the Local Environment</source>
          <target state="translated">로컬 환경 설정</target>
        </trans-unit>
        <trans-unit id="c44f26d2bfdb853b861ef2282603dadd2c943781" translate="yes" xml:space="preserve">
          <source>Setting this in a Gradle DSL:</source>
          <target state="translated">Gradle DSL에서 이것을 설정 :</target>
        </trans-unit>
        <trans-unit id="1d9561629ffffcf08f870d78c8cba9699aaf1728" translate="yes" xml:space="preserve">
          <source>Setting up Framework Dependency in Xcode</source>
          <target state="translated">Xcode에서 프레임 워크 종속성 설정</target>
        </trans-unit>
        <trans-unit id="601eff2654656e13db208f79616084dab833fb1f" translate="yes" xml:space="preserve">
          <source>Setting up Targets</source>
          <target state="translated">대상 설정</target>
        </trans-unit>
        <trans-unit id="f27242b25e228df6b15975fcf5c1aed13839ea95" translate="yes" xml:space="preserve">
          <source>Setting up Xcode</source>
          <target state="translated">Xcode 설정</target>
        </trans-unit>
        <trans-unit id="729b164a15e1528ee04709ca227eb8126e79e0e9" translate="yes" xml:space="preserve">
          <source>Setting up a Multiplatform Project</source>
          <target state="translated">멀티 플랫폼 프로젝트 설정</target>
        </trans-unit>
        <trans-unit id="4b75b737e7019beac88da840b9c4fa621cc15e9b" translate="yes" xml:space="preserve">
          <source>Setting up a project</source>
          <target state="translated">프로젝트 설정</target>
        </trans-unit>
        <trans-unit id="dfe5b993bb5b873cf296bfd1dec95400d302bb2f" translate="yes" xml:space="preserve">
          <source>Setting up the environment</source>
          <target state="translated">환경 설정</target>
        </trans-unit>
        <trans-unit id="c676a8afec5bd640eea3d16f369b18ff86f79446" translate="yes" xml:space="preserve">
          <source>Setting up the local environment</source>
          <target state="translated">로컬 환경 설정</target>
        </trans-unit>
        <trans-unit id="c7f73bb54d928922c3838bb789ee9fb8a5b1eb37" translate="yes" xml:space="preserve">
          <source>Settings</source>
          <target state="translated">Settings</target>
        </trans-unit>
        <trans-unit id="89a5ab56adeb4ad20f46a74711635d7a3b3c6f17" translate="yes" xml:space="preserve">
          <source>Setup Kotlin Compilation Step</source>
          <target state="translated">Kotlin 컴파일 단계 설정</target>
        </trans-unit>
        <trans-unit id="f7fd968c0a5ce680afda4eb915e615fd82b3a5d5" translate="yes" xml:space="preserve">
          <source>Setup Kotlin Compiler Fetching Step</source>
          <target state="translated">Kotlin 컴파일러 페치 단계 설정</target>
        </trans-unit>
        <trans-unit id="1cd15bb14bf553822a7d00ea242fd63abf35e644" translate="yes" xml:space="preserve">
          <source>Setup for the whole project: Open File -&amp;gt; Settings, select &quot;Build, Execution, Deployment&quot; -&amp;gt; &quot;Compiler&quot; -&amp;gt; &quot;Kotlin compiler&quot;. Choose appropriate module system in &quot;Module kind&quot; field.</source>
          <target state="translated">전체 프로젝트 설정 : 파일-&amp;gt; 설정을 열고 &quot;빌드, 실행, 배포&quot;-&amp;gt; &quot;컴파일러&quot;-&amp;gt; &quot;Kotlin 컴파일러&quot;를 선택하십시오. &quot;모듈 종류&quot;필드에서 적절한 모듈 시스템을 선택하십시오.</target>
        </trans-unit>
        <trans-unit id="f0f08df8a582b1b5aaacc0eb420e8df1267b5d20" translate="yes" xml:space="preserve">
          <source>Setup per module: Open File -&amp;gt; Project Structure&amp;hellip;, find your module in Modules and select &quot;Kotlin&quot; facet under it. Choose appropriate module system in &quot;Module kind&quot; field.</source>
          <target state="translated">모듈 당 설정 : 파일-&amp;gt; 프로젝트 구조&amp;hellip;를 열고 모듈에서 모듈을 찾은 다음 &quot;Kotlin&quot;패싯을 선택하십시오. &quot;모듈 종류&quot;필드에서 적절한 모듈 시스템을 선택하십시오.</target>
        </trans-unit>
        <trans-unit id="e85ac6caafc3dc694f3d37ae03f6e0e397a05a87" translate="yes" xml:space="preserve">
          <source>Seven-bit ASCII, a.k.a. ISO646-US, a.k.a. the Basic Latin block of the Unicode character set.</source>
          <target state="translated">7 비트 ASCII, 일명 ISO646-US, 일명 유니 코드 문자 집합의 기본 라틴 블록.</target>
        </trans-unit>
        <trans-unit id="7b29b4dba7f56bc1e20beeabf8e2e4afde6e1578" translate="yes" xml:space="preserve">
          <source>Several examples</source>
          <target state="translated">몇 가지 예</target>
        </trans-unit>
        <trans-unit id="6b48a6c117f5beb6359de584b0c0262c2f5ac127" translate="yes" xml:space="preserve">
          <source>Several last lists may have less elements than the given &lt;a href=&quot;windowed#kotlin.collections%24windowed%28kotlin.collections.Iterable%28%28kotlin.collections.windowed.T%29%29%2C+kotlin.Int%2C+kotlin.Int%2C+kotlin.Boolean%29%2Fsize&quot;&gt;size&lt;/a&gt;.</source>
          <target state="translated">몇 개의 마지막 목록은 주어진 &lt;a href=&quot;windowed#kotlin.collections%24windowed%28kotlin.collections.Iterable%28%28kotlin.collections.windowed.T%29%29%2C+kotlin.Int%2C+kotlin.Int%2C+kotlin.Boolean%29%2Fsize&quot;&gt;크기&lt;/a&gt; 보다 적은 요소를 가질 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="3dc2911d06598db01df02e69e45148f8fafc2630" translate="yes" xml:space="preserve">
          <source>Several last lists may have less elements than the given &lt;a href=&quot;windowed#kotlin.sequences%24windowed%28kotlin.sequences.Sequence%28%28kotlin.sequences.windowed.T%29%29%2C+kotlin.Int%2C+kotlin.Int%2C+kotlin.Boolean%29%2Fsize&quot;&gt;size&lt;/a&gt;.</source>
          <target state="translated">몇 개의 마지막 목록은 주어진 &lt;a href=&quot;windowed#kotlin.sequences%24windowed%28kotlin.sequences.Sequence%28%28kotlin.sequences.windowed.T%29%29%2C+kotlin.Int%2C+kotlin.Int%2C+kotlin.Boolean%29%2Fsize&quot;&gt;크기&lt;/a&gt; 보다 적은 요소를 가질 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="6876468af6c5e87e9f6d208540b74e1e7a8befa7" translate="yes" xml:space="preserve">
          <source>Several last strings may have less characters than the given &lt;a href=&quot;windowed#kotlin.text%24windowed%28kotlin.CharSequence%2C+kotlin.Int%2C+kotlin.Int%2C+kotlin.Boolean%29%2Fsize&quot;&gt;size&lt;/a&gt;.</source>
          <target state="translated">몇몇 마지막 문자열은 주어진 &lt;a href=&quot;windowed#kotlin.text%24windowed%28kotlin.CharSequence%2C+kotlin.Int%2C+kotlin.Int%2C+kotlin.Boolean%29%2Fsize&quot;&gt;크기&lt;/a&gt; 보다 적은 문자를 가질 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="ebb92729220424707666ea7db0750140ac89ed3f" translate="yes" xml:space="preserve">
          <source>Several last strings may have less characters than the given &lt;a href=&quot;windowed-sequence#kotlin.text%24windowedSequence%28kotlin.CharSequence%2C+kotlin.Int%2C+kotlin.Int%2C+kotlin.Boolean%29%2Fsize&quot;&gt;size&lt;/a&gt;.</source>
          <target state="translated">몇몇 마지막 문자열은 주어진 &lt;a href=&quot;windowed-sequence#kotlin.text%24windowedSequence%28kotlin.CharSequence%2C+kotlin.Int%2C+kotlin.Int%2C+kotlin.Boolean%29%2Fsize&quot;&gt;크기&lt;/a&gt; 보다 적은 문자를 가질 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="813a34b3a59a3ac492c103196888e0f76e842e38" translate="yes" xml:space="preserve">
          <source>Severity of the diagnostic that should be reported on usages of experimental API which did not explicitly accept the experimental aspect of that API either by using &lt;a href=&quot;../-use-experimental/index&quot;&gt;UseExperimental&lt;/a&gt; or by being annotated with the corresponding marker annotation.</source>
          <target state="translated">&lt;a href=&quot;../-use-experimental/index&quot;&gt;UseExperimental&lt;/a&gt; 을 사용 하거나 해당 마커 주석으로 주석을 달아 API의 실험적 측면을 명시 적으로 수용하지 않은 실험적 API 사용에 대해보고해야 할 진단의 심각도 .</target>
        </trans-unit>
        <trans-unit id="d1099b140c2cdd7a815583675ff5a73a0c8b9ec7" translate="yes" xml:space="preserve">
          <source>Severity of the diagnostic that should be reported on usages of experimental API which did not explicitly accept the experimental aspect of that API either by using &lt;a href=&quot;../../-use-experimental/index&quot;&gt;UseExperimental&lt;/a&gt; or by being annotated with the corresponding marker annotation.</source>
          <target state="translated">&lt;a href=&quot;../../-use-experimental/index&quot;&gt;UseExperimental&lt;/a&gt; 을 사용 하거나 해당 마커 주석으로 주석을 달아 API의 실험적 측면을 명시 적으로 수용하지 않은 실험적 API 사용에 대해보고해야 할 진단의 심각도 .</target>
        </trans-unit>
        <trans-unit id="836b05c7633a1e30ae532de9ebb894d7f73b61c8" translate="yes" xml:space="preserve">
          <source>ShadowAnimation</source>
          <target state="translated">ShadowAnimation</target>
        </trans-unit>
        <trans-unit id="c52b8fac4d1546004d36036314634bdacdd53b08" translate="yes" xml:space="preserve">
          <source>ShadowRootInit</source>
          <target state="translated">ShadowRootInit</target>
        </trans-unit>
        <trans-unit id="a309f22f502741e5b5409272ba7d0d45e894ec55" translate="yes" xml:space="preserve">
          <source>ShadowRootMode</source>
          <target state="translated">ShadowRootMode</target>
        </trans-unit>
        <trans-unit id="db79c07cf0a0cefafe30ccd1fc8c954e9f3aad6e" translate="yes" xml:space="preserve">
          <source>Shared Mutable State and Concurrency</source>
          <target state="translated">공유 가변 상태 및 동시성</target>
        </trans-unit>
        <trans-unit id="5aa53b857601ecf23027dcc72fd5e23b6e4d90ca" translate="yes" xml:space="preserve">
          <source>Shared mutable state and concurrency</source>
          <target state="translated">공유 가능한 변경 가능한 상태 및 동시성</target>
        </trans-unit>
        <trans-unit id="5ef7f5e4f7f5fcb21c29e25a4231957e0c1d6ca3" translate="yes" xml:space="preserve">
          <source>SharedImmutable</source>
          <target state="translated">SharedImmutable</target>
        </trans-unit>
        <trans-unit id="c7977120bf6bcc880df4fe01f7ce83934ed43158" translate="yes" xml:space="preserve">
          <source>Sharing Code between Platforms</source>
          <target state="translated">플랫폼 간 코드 공유</target>
        </trans-unit>
        <trans-unit id="dbe8ea8f6f902897a352043f04fbfba2b7660deb" translate="yes" xml:space="preserve">
          <source>Sharing Kotlin code between iOS and Android</source>
          <target state="translated">iOS와 Android간에 Kotlin 코드 공유</target>
        </trans-unit>
        <trans-unit id="3f04d40398ebd1f6a2cabd19b6ba50ea2f6b3801" translate="yes" xml:space="preserve">
          <source>Sharing Kotlin library between JVM, JS and Native worlds</source>
          <target state="translated">JVM, JS 및 기본 세계간에 Kotlin 라이브러리 공유</target>
        </trans-unit>
        <trans-unit id="297325326f8f9abbd333d90d941d1753331ba09a" translate="yes" xml:space="preserve">
          <source>Sharing code between mobile platforms is one of the major Kotlin Multiplatform use cases, and it is now possible to build mobile applications with parts of the code, such as business logic, connectivity, and more, shared between Android and iOS.</source>
          <target state="translated">모바일 플랫폼간에 코드를 공유하는 것이 Kotlin Multiplatform의 주요 사용 사례 중 하나이며 이제는 비즈니스 로직, 연결성 등의 일부 코드를 사용하여 Android와 iOS간에 공유되는 모바일 애플리케이션을 빌드 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="051c4d62ebae6a7b7b80ef891d89eb1bf6a2550d" translate="yes" xml:space="preserve">
          <source>Sharing code between platforms is a powerful technique, but it may be hard to accomplish without rich APIs that we have in Android, JVM, or iOS platforms. Multiplatform libraries can be used to fix that. They bring rich APIs directly in the common Kotlin code. There are several examples of such libraries:</source>
          <target state="translated">플랫폼 간 코드 공유는 강력한 기술이지만 Android, JVM 또는 iOS 플랫폼에서 보유한 풍부한 API가 없으면 달성하기 어려울 수 있습니다. 이를 해결하기 위해 멀티 플랫폼 라이브러리를 사용할 수 있습니다. 일반적인 Kotlin 코드에서 풍부한 API를 직접 가져옵니다. 이러한 라이브러리에는 몇 가지 예가 있습니다.</target>
        </trans-unit>
        <trans-unit id="1de7f8359460e124966f478d8ff0b1101ad84358" translate="yes" xml:space="preserve">
          <source>Shifts this value left by the &lt;a href=&quot;shl#kotlin%24shl%28java.math.BigInteger%2C+kotlin.Int%29%2Fn&quot;&gt;n&lt;/a&gt; number of bits.</source>
          <target state="translated">이 값을 &lt;a href=&quot;shl#kotlin%24shl%28java.math.BigInteger%2C+kotlin.Int%29%2Fn&quot;&gt;n&lt;/a&gt; 비트 수만큼 왼쪽으로 이동합니다 .</target>
        </trans-unit>
        <trans-unit id="fa89bbf50fa31925246bd02a77f7c8660177c18c" translate="yes" xml:space="preserve">
          <source>Shifts this value left by the &lt;a href=&quot;shl#kotlin.Int%24shl%28kotlin.Int%29%2FbitCount&quot;&gt;bitCount&lt;/a&gt; number of bits.</source>
          <target state="translated">이 값을 &lt;a href=&quot;shl#kotlin.Int%24shl%28kotlin.Int%29%2FbitCount&quot;&gt;bitCount&lt;/a&gt; 비트 수만큼 왼쪽으로 이동합니다 .</target>
        </trans-unit>
        <trans-unit id="91a11dfe9061ef195b8867f7a99bdfcb07185b19" translate="yes" xml:space="preserve">
          <source>Shifts this value left by the &lt;a href=&quot;shl#kotlin.Long%24shl%28kotlin.Int%29%2FbitCount&quot;&gt;bitCount&lt;/a&gt; number of bits.</source>
          <target state="translated">이 값을 &lt;a href=&quot;shl#kotlin.Long%24shl%28kotlin.Int%29%2FbitCount&quot;&gt;bitCount&lt;/a&gt; 비트 수만큼 왼쪽으로 이동합니다 .</target>
        </trans-unit>
        <trans-unit id="55ad8fceb560e16ef264e86683f6269f57215026" translate="yes" xml:space="preserve">
          <source>Shifts this value left by the &lt;a href=&quot;shl#kotlin.UInt%24shl%28kotlin.Int%29%2FbitCount&quot;&gt;bitCount&lt;/a&gt; number of bits.</source>
          <target state="translated">이 값을 &lt;a href=&quot;shl#kotlin.UInt%24shl%28kotlin.Int%29%2FbitCount&quot;&gt;bitCount&lt;/a&gt; 비트 수만큼 왼쪽으로 이동합니다 .</target>
        </trans-unit>
        <trans-unit id="c5f970689157bbb4098e02ad8befbb51472db7a6" translate="yes" xml:space="preserve">
          <source>Shifts this value left by the &lt;a href=&quot;shl#kotlin.ULong%24shl%28kotlin.Int%29%2FbitCount&quot;&gt;bitCount&lt;/a&gt; number of bits.</source>
          <target state="translated">이 값을 &lt;a href=&quot;shl#kotlin.ULong%24shl%28kotlin.Int%29%2FbitCount&quot;&gt;bitCount&lt;/a&gt; 비트 수만큼 왼쪽으로 이동합니다 .</target>
        </trans-unit>
        <trans-unit id="561765590bf462448174dfa2c676fabfb9613e7b" translate="yes" xml:space="preserve">
          <source>Shifts this value right by the &lt;a href=&quot;shr#kotlin%24shr%28java.math.BigInteger%2C+kotlin.Int%29%2Fn&quot;&gt;n&lt;/a&gt; number of bits, filling the leftmost bits with copies of the sign bit.</source>
          <target state="translated">이 값을 &lt;a href=&quot;shr#kotlin%24shr%28java.math.BigInteger%2C+kotlin.Int%29%2Fn&quot;&gt;n&lt;/a&gt; 비트 수만큼 오른쪽으로 이동 하여 부호 비트의 사본으로 가장 왼쪽 비트를 채 웁니다.</target>
        </trans-unit>
        <trans-unit id="cc68bba5cb4fdf70f538ef2cd32e3d9ca3a6f230" translate="yes" xml:space="preserve">
          <source>Shifts this value right by the &lt;a href=&quot;shr#kotlin.Int%24shr%28kotlin.Int%29%2FbitCount&quot;&gt;bitCount&lt;/a&gt; number of bits, filling the leftmost bits with copies of the sign bit.</source>
          <target state="translated">&lt;a href=&quot;shr#kotlin.Int%24shr%28kotlin.Int%29%2FbitCount&quot;&gt;bitCount&lt;/a&gt; 비트 수만큼 이 값을 오른쪽으로 이동하여 부호 비트의 사본으로 가장 왼쪽 비트를 채 웁니다.</target>
        </trans-unit>
        <trans-unit id="a3c9d6c2dfd7c1b329f5c2e52f9e86c783409844" translate="yes" xml:space="preserve">
          <source>Shifts this value right by the &lt;a href=&quot;shr#kotlin.Long%24shr%28kotlin.Int%29%2FbitCount&quot;&gt;bitCount&lt;/a&gt; number of bits, filling the leftmost bits with copies of the sign bit.</source>
          <target state="translated">&lt;a href=&quot;shr#kotlin.Long%24shr%28kotlin.Int%29%2FbitCount&quot;&gt;bitCount&lt;/a&gt; 비트 수만큼 이 값을 오른쪽으로 이동하여 부호 비트의 사본으로 가장 왼쪽 비트를 채 웁니다.</target>
        </trans-unit>
        <trans-unit id="205604884176d4ce45ddfadcf924ca5e75925d36" translate="yes" xml:space="preserve">
          <source>Shifts this value right by the &lt;a href=&quot;shr#kotlin.UInt%24shr%28kotlin.Int%29%2FbitCount&quot;&gt;bitCount&lt;/a&gt; number of bits, filling the leftmost bits with zeros.</source>
          <target state="translated">이 값을 &lt;a href=&quot;shr#kotlin.UInt%24shr%28kotlin.Int%29%2FbitCount&quot;&gt;bitCount&lt;/a&gt; 비트 수만큼 오른쪽으로 이동 하여 가장 왼쪽 비트를 0으로 채 웁니다.</target>
        </trans-unit>
        <trans-unit id="975363933f601796162b5dcd9c49eefffe3d4646" translate="yes" xml:space="preserve">
          <source>Shifts this value right by the &lt;a href=&quot;shr#kotlin.ULong%24shr%28kotlin.Int%29%2FbitCount&quot;&gt;bitCount&lt;/a&gt; number of bits, filling the leftmost bits with zeros.</source>
          <target state="translated">이 값을 &lt;a href=&quot;shr#kotlin.ULong%24shr%28kotlin.Int%29%2FbitCount&quot;&gt;bitCount&lt;/a&gt; 비트 수만큼 오른쪽으로 이동 하여 가장 왼쪽 비트를 0으로 채 웁니다.</target>
        </trans-unit>
        <trans-unit id="1320613fcb4e3ad05b5a1fb529d5aa02782a35b6" translate="yes" xml:space="preserve">
          <source>Shifts this value right by the &lt;a href=&quot;ushr#kotlin.Int%24ushr%28kotlin.Int%29%2FbitCount&quot;&gt;bitCount&lt;/a&gt; number of bits, filling the leftmost bits with zeros.</source>
          <target state="translated">이 값을 &lt;a href=&quot;ushr#kotlin.Int%24ushr%28kotlin.Int%29%2FbitCount&quot;&gt;bitCount&lt;/a&gt; 비트 수만큼 오른쪽으로 이동 하여 가장 왼쪽 비트를 0으로 채 웁니다.</target>
        </trans-unit>
        <trans-unit id="de121cd2bd1ef2196f936dbff0fb5367f384adab" translate="yes" xml:space="preserve">
          <source>Shifts this value right by the &lt;a href=&quot;ushr#kotlin.Long%24ushr%28kotlin.Int%29%2FbitCount&quot;&gt;bitCount&lt;/a&gt; number of bits, filling the leftmost bits with zeros.</source>
          <target state="translated">이 값을 &lt;a href=&quot;ushr#kotlin.Long%24ushr%28kotlin.Int%29%2FbitCount&quot;&gt;bitCount&lt;/a&gt; 비트 수만큼 오른쪽으로 이동 하여 가장 왼쪽 비트를 0으로 채 웁니다.</target>
        </trans-unit>
        <trans-unit id="0fe7d82f25a3015040a206e54f9c1d3a9717c4c4" translate="yes" xml:space="preserve">
          <source>Short</source>
          <target state="translated">Short</target>
        </trans-unit>
        <trans-unit id="f1be0a77e24659d844b1d829e319473c64b3d92c" translate="yes" xml:space="preserve">
          <source>Short comments can be placed on a single line:</source>
          <target state="translated">한 줄에 간단한 설명을 넣을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="bb95645acf79d381a75848afbb852798210eb222" translate="yes" xml:space="preserve">
          <source>ShortArray</source>
          <target state="translated">ShortArray</target>
        </trans-unit>
        <trans-unit id="6908df3352349f003ba7c1e2bdfd0ab1d663f541" translate="yes" xml:space="preserve">
          <source>ShortIterator</source>
          <target state="translated">ShortIterator</target>
        </trans-unit>
        <trans-unit id="daaa8e58fde19c5641d9f419edefbe96acf6a0fc" translate="yes" xml:space="preserve">
          <source>ShortVar</source>
          <target state="translated">ShortVar</target>
        </trans-unit>
        <trans-unit id="a18072aa811b8ffe818664ff6ba45b9d51d7c523" translate="yes" xml:space="preserve">
          <source>ShortVarOf</source>
          <target state="translated">ShortVarOf</target>
        </trans-unit>
        <trans-unit id="240898f9447d350a1c2443d35798203546e2999e" translate="yes" xml:space="preserve">
          <source>Shorter syntax for properties</source>
          <target state="translated">속성에 대한 짧은 구문</target>
        </trans-unit>
        <trans-unit id="af61674ca511f597dfdc94a24bcd892cf0f59c64" translate="yes" xml:space="preserve">
          <source>Should compiler generated code call the main function</source>
          <target state="translated">컴파일러에서 코드를 생성하여 주 함수를 호출해야합니다</target>
        </trans-unit>
        <trans-unit id="ad81adfa3e182e6e5c1f09169b9e8963d98edb1b" translate="yes" xml:space="preserve">
          <source>Sign and absolute value:</source>
          <target state="translated">부호와 절대 값 :</target>
        </trans-unit>
        <trans-unit id="9902ec5a921b75c5ce68e37cd519601a31d13da9" translate="yes" xml:space="preserve">
          <source>Signals that the annotated annotation class is a marker of an experimental API.</source>
          <target state="translated">주석이 달린 주석 클래스가 실험적인 API의 마커임을 알립니다.</target>
        </trans-unit>
        <trans-unit id="a0215479e9dd9a267a38a1be46680da42a198173" translate="yes" xml:space="preserve">
          <source>Signed, unsigned integral, and floating point types are mapped to their Kotlin counterpart with the same width.</source>
          <target state="translated">부호있는, 부호없는 정수 및 부동 소수점 유형은 동일한 너비를 가진 Kotlin 대응 항목에 매핑됩니다.</target>
        </trans-unit>
        <trans-unit id="9fe5273a06659605c10cb83e488938ef900a3591" translate="yes" xml:space="preserve">
          <source>Signifies that the annotated functional type represents an extension function.</source>
          <target state="translated">주석이 달린 기능 유형이 확장 기능을 나타냄을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="9fcc4d0c21be05b877e2736e1dd7b56ceaaa4a1d" translate="yes" xml:space="preserve">
          <source>Similar to the &lt;code&gt;Array&lt;/code&gt; constructor, there are now functions that create &lt;code&gt;List&lt;/code&gt; and &lt;code&gt;MutableList&lt;/code&gt; instances and initialize each element by calling a lambda:</source>
          <target state="translated">&lt;code&gt;Array&lt;/code&gt; 생성자 와 유사하게 이제 &lt;code&gt;List&lt;/code&gt; 및 &lt;code&gt;MutableList&lt;/code&gt; 인스턴스 를 만들고 람다를 호출하여 각 요소를 초기화 하는 함수가 있습니다 .</target>
        </trans-unit>
        <trans-unit id="b696a41cbfc5d18be8eef6a404f46e79ece8b58f" translate="yes" xml:space="preserve">
          <source>Similar to when we're using &lt;a href=&quot;../getting-started-idea/getting-started-with-intellij-idea&quot;&gt;IntelliJ IDEA build system&lt;/a&gt; or the command line, we can have the compiler output JavaScript to comply with a specific module system such as AMD, CommonJS or UMD.</source>
          <target state="translated">&lt;a href=&quot;../getting-started-idea/getting-started-with-intellij-idea&quot;&gt;IntelliJ IDEA 빌드 시스템&lt;/a&gt; 또는 명령 줄을 사용하는 경우와 유사하게 컴파일러에서 JavaScript, JavaScript, CommonJS 또는 UMD와 같은 특정 모듈 시스템을 준수하도록 출력 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c343ad89de5e3d2bda211b8f922e99f913bab352" translate="yes" xml:space="preserve">
          <source>Similarly to functions, Kotlin supports extension properties:</source>
          <target state="translated">함수와 마찬가지로 Kotlin은 확장 속성을 지원합니다.</target>
        </trans-unit>
        <trans-unit id="4167cd56e3b5dcc5788a4fd7f543f645c15d01ed" translate="yes" xml:space="preserve">
          <source>Similarly, a library consumer may need to provide matching fallbacks for custom product flavors if some are missing in the library publications.</source>
          <target state="translated">마찬가지로, 라이브러리 소비자는 라이브러리 서적에 일부가 누락 된 경우 사용자 정의 제품 특징에 대해 일치하는 대체를 제공해야 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="f536b6acdc9043c4a42d4d23229b44e979722a18" translate="yes" xml:space="preserve">
          <source>Similarly, when we assign to &lt;code&gt;p&lt;/code&gt;, the &lt;code&gt;setValue()&lt;/code&gt; function is called. The first two parameters are the same, and the third holds the value being assigned:</source>
          <target state="translated">마찬가지로 &lt;code&gt;p&lt;/code&gt; 에 할당 하면 &lt;code&gt;setValue()&lt;/code&gt; 함수가 호출됩니다. 처음 두 매개 변수는 동일하며 세 번째 매개 변수는 지정되는 값을 보유합니다.</target>
        </trans-unit>
        <trans-unit id="3b895209bc0a4e4dfafeeb7fada6b857d595d852" translate="yes" xml:space="preserve">
          <source>Similarly, when you already have the type arguments of an instance checked statically (at compile time), you can make an &lt;em&gt;is&lt;/em&gt;-check or a cast that involves the non-generic part of the type. Note that angle brackets are omitted in this case:</source>
          <target state="translated">마찬가지로 인스턴스의 유형 인수가 이미 컴파일 타임에 정적으로 검사 된 경우 &lt;em&gt;is-&lt;/em&gt; check 또는 유형의 제네릭이 아닌 부분을 포함하는 캐스트를 만들 수 있습니다 . 이 경우 꺾쇠 괄호는 생략됩니다.</target>
        </trans-unit>
        <trans-unit id="373dea533a0d49a9c6fb1be2d9e503372df28cc1" translate="yes" xml:space="preserve">
          <source>Simple example</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9fe6625e7fa70a75f441e66f48bbb12c8a2bda69" translate="yes" xml:space="preserve">
          <source>Simple example: Reachable Numbers problem</source>
          <target state="translated">간단한 예 : 도달 가능한 숫자 문제</target>
        </trans-unit>
        <trans-unit id="460e0cbdf7f85b57fb0b9092f75f48e34791ec3e" translate="yes" xml:space="preserve">
          <source>Simple type</source>
          <target state="translated">단순 타입</target>
        </trans-unit>
        <trans-unit id="bf9fd8196e53917d432912e26e9c5f145f971f1d" translate="yes" xml:space="preserve">
          <source>SimpleEffect</source>
          <target state="translated">SimpleEffect</target>
        </trans-unit>
        <trans-unit id="1f88a84a3c3cc88b9e388323628cb3bfb002e0ea" translate="yes" xml:space="preserve">
          <source>Since 1.1, data classes may extend other classes (see &lt;a href=&quot;sealed-classes&quot;&gt;Sealed classes&lt;/a&gt; for examples).</source>
          <target state="translated">1.1 이후로, 데이터 클래스는 다른 클래스를 확장 할 수 있습니다 ( 예는 &lt;a href=&quot;sealed-classes&quot;&gt;봉인 클래스&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="c45af68c04ba0b57547d05c578aa8eba167797e0" translate="yes" xml:space="preserve">
          <source>Since 1.3.0 Kotlin has an experimental support for scripts customization, such as adding external properties, providing static or dynamic dependencies, and so on. Customizations are defined by so-called &lt;em&gt;Script definitions&lt;/em&gt; - annotated kotlin classes with appropriate support code. The script filename extension is used to select appropriate definition.</source>
          <target state="translated">1.3.0부터 Kotlin은 외부 속성 추가, 정적 또는 동적 종속성 제공 등과 같은 스크립트 사용자 지정을 실험적으로 지원합니다. 사용자 정의는 소위 &lt;em&gt;스크립트 정의&lt;/em&gt; -적절한 지원 코드가있는 주석이 달린 kotlin 클래스로 &lt;em&gt;정의&lt;/em&gt; 됩니다. 스크립트 파일 이름 확장자는 적절한 정의를 선택하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="ae33bc2ca6c920991b37acb69fe39030237d1fda" translate="yes" xml:space="preserve">
          <source>Since 1.3.40, a separate Gradle plugin for Kotlin/Native is deprecated in favor of the &lt;code&gt;kotlin-multiplatform&lt;/code&gt; plugin. This plugin provides an IDE support along with support of the new multiplatform project model introduced in Kotlin 1.3.0. Below you can find a short list of differences between &lt;code&gt;kotlin-platform-native&lt;/code&gt; and &lt;code&gt;kotlin-muliplatform&lt;/code&gt; plugins. For more information see the &lt;code&gt;kotlin-muliplatform&lt;/code&gt;&lt;a href=&quot;../building-mpp-with-gradle&quot;&gt;documentation page&lt;/a&gt;. For &lt;code&gt;kotlin-platform-native&lt;/code&gt; reference see the &lt;a href=&quot;#kotlin-platform-native-reference&quot;&gt;corresponding section&lt;/a&gt;.</source>
          <target state="translated">1.3.40부터 Kotlin / Native 용 별도의 Gradle 플러그인은 &lt;code&gt;kotlin-multiplatform&lt;/code&gt; 플러그인 을 위해 더 이상 사용되지 않습니다 . 이 플러그인은 Kotlin 1.3.0에 도입 된 새로운 멀티 플랫폼 프로젝트 모델의 지원과 함께 IDE 지원을 제공합니다. 아래에서 &lt;code&gt;kotlin-platform-native&lt;/code&gt; 및 &lt;code&gt;kotlin-muliplatform&lt;/code&gt; 플러그인 의 짧은 차이점 목록을 찾을 수 있습니다. 자세한 정보는 &lt;code&gt;kotlin-muliplatform&lt;/code&gt; &lt;a href=&quot;../building-mpp-with-gradle&quot;&gt;문서 페이지를 참조하십시오&lt;/a&gt; . 들어 &lt;code&gt;kotlin-platform-native&lt;/code&gt; 참고 문헌 참조 &lt;a href=&quot;#kotlin-platform-native-reference&quot;&gt;해당 섹션&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="3f3503e86bffe0abaebb38725b3349da076c53cf" translate="yes" xml:space="preserve">
          <source>Since 1.3.40, test executables are represented by a separate binary type and have their own getter. To access the default test binary, use:</source>
          <target state="translated">1.3.40부터 테스트 실행 파일은 별도의 이진 형식으로 표시되며 자체 게터가 있습니다. 기본 테스트 바이너리에 액세스하려면 다음을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="74d2423e1b8ad654b09fa01e578cbe247dd6909a" translate="yes" xml:space="preserve">
          <source>Since Java has no way of marking methods for which it makes sense to use the operator syntax, Kotlin allows using any Java methods with the right name and signature as operator overloads and other conventions (&lt;code&gt;invoke()&lt;/code&gt; etc.) Calling Java methods using the infix call syntax is not allowed.</source>
          <target state="translated">Java는 연산자 구문을 사용하는 것이 의미가있는 메소드를 표시하는 방법이 없기 때문에 Kotlin은 올바른 이름과 서명이있는 Java 메소드를 연산자 과부하 및 기타 규칙 ( &lt;code&gt;invoke()&lt;/code&gt; 등)으로 사용할 수 있습니다. 호출 구문은 허용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="b8398b1189e7866368709036da6ebf170a442288" translate="yes" xml:space="preserve">
          <source>Since Kotlin 1.1, it's possible to access the constants in an enum class in a generic way, using the &lt;code&gt;enumValues&amp;lt;T&amp;gt;()&lt;/code&gt; and &lt;code&gt;enumValueOf&amp;lt;T&amp;gt;()&lt;/code&gt; functions:</source>
          <target state="translated">Kotlin 1.1부터 &lt;code&gt;enumValues&amp;lt;T&amp;gt;()&lt;/code&gt; 및 &lt;code&gt;enumValueOf&amp;lt;T&amp;gt;()&lt;/code&gt; 함수를 사용하여 일반적인 방식으로 열거 형 클래스의 상수에 액세스 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="330983e4399baf0a2c9af16e30f769877d9bd0ed" translate="yes" xml:space="preserve">
          <source>Since Kotlin 1.1, you can omit the property type if it can be inferred from the getter:</source>
          <target state="translated">Kotlin 1.1 이후, getter에서 유추 할 수있는 속성 유형을 생략 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="da701a88d5b6b6cb5f3f3cc5c091da6b746b52c6" translate="yes" xml:space="preserve">
          <source>Since Kotlin 1.1.50, &lt;a href=&quot;https://github.com/Kotlin/KEEP/blob/41091f1cc7045142181d8c89645059f4a15cc91a/proposals/jsr-305-custom-nullability-qualifiers.md&quot;&gt;custom nullability qualifiers (KEEP-79)&lt;/a&gt; are also supported (see below).</source>
          <target state="translated">Kotlin 1.1.50부터 &lt;a href=&quot;https://github.com/Kotlin/KEEP/blob/41091f1cc7045142181d8c89645059f4a15cc91a/proposals/jsr-305-custom-nullability-qualifiers.md&quot;&gt;사용자 지정 nullability 한정자 (KEEP-79)&lt;/a&gt; 도 지원됩니다 (아래 참조).</target>
        </trans-unit>
        <trans-unit id="9ae7b7121257ecc4190400d88c65896582898044" translate="yes" xml:space="preserve">
          <source>Since Kotlin 1.2, explicitly specifying &lt;code&gt;this&lt;/code&gt; as the receiver is not necessary: &lt;code&gt;this::foo&lt;/code&gt; and &lt;code&gt;::foo&lt;/code&gt; are equivalent.</source>
          <target state="translated">코 틀린 1.2 이후, 명시 적으로 지정 &lt;code&gt;this&lt;/code&gt; 수신기로 할 필요가 없습니다 : &lt;code&gt;this::foo&lt;/code&gt; 와 &lt;code&gt;::foo&lt;/code&gt; 는은 동일합니다.</target>
        </trans-unit>
        <trans-unit id="8c4391f4af9d2a0c13ee2de02e3def8882dce4b0" translate="yes" xml:space="preserve">
          <source>Since Kotlin 1.3 use &lt;a href=&quot;../../kotlin.sequences/-sequence-scope/index&quot;&gt;kotlin.sequences.SequenceScope&lt;/a&gt; instead.</source>
          <target state="translated">Kotlin 1.3부터 &lt;a href=&quot;../../kotlin.sequences/-sequence-scope/index&quot;&gt;kotlin.sequences.SequenceScope를&lt;/a&gt; 대신 사용 하십시오 .</target>
        </trans-unit>
        <trans-unit id="e80b0e98aee610d55a5c374cdbbf839bc8868cd2" translate="yes" xml:space="preserve">
          <source>Since Kotlin 1.3 use &lt;a href=&quot;../kotlin.sequences/iterator&quot;&gt;kotlin.sequences.iterator&lt;/a&gt; instead.</source>
          <target state="translated">Kotlin 1.3부터 &lt;a href=&quot;../kotlin.sequences/iterator&quot;&gt;kotlin.sequences.iterator를&lt;/a&gt; 대신 사용 하십시오 .</target>
        </trans-unit>
        <trans-unit id="88ab4850745a2ab5ce313b43d12c199319889b1c" translate="yes" xml:space="preserve">
          <source>Since Kotlin 1.3 use &lt;a href=&quot;../kotlin.sequences/sequence&quot;&gt;kotlin.sequences.sequence&lt;/a&gt; instead.</source>
          <target state="translated">Kotlin 1.3부터 &lt;a href=&quot;../kotlin.sequences/sequence&quot;&gt;kotlin.sequences.sequence를&lt;/a&gt; 대신 사용 하십시오 .</target>
        </trans-unit>
        <trans-unit id="405b74df55c0598869424e3cb858793a687c40ea" translate="yes" xml:space="preserve">
          <source>Since Kotlin 1.3, it is possible to capture &lt;em&gt;when&lt;/em&gt; subject in a variable using following syntax:</source>
          <target state="translated">Kotlin 1.3부터는 다음 구문을 사용하여 변수에 주제가 &lt;em&gt;있을 때&lt;/em&gt; 캡처 &lt;em&gt;할&lt;/em&gt; 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="efcc6bedd3b914eb31e0f75f655ecbdfda75ad9b" translate="yes" xml:space="preserve">
          <source>Since Kotlin/Native provides &lt;a href=&quot;native/c_interop&quot;&gt;interoperability with native languages&lt;/a&gt;, there is a DSL allowing one to configure this feature for a specific compilation.</source>
          <target state="translated">Kotlin / Native는 &lt;a href=&quot;native/c_interop&quot;&gt;모국어와의 상호 운용성을&lt;/a&gt; 제공 하기 때문에 특정 컴파일에 대해이 기능을 구성 할 수있는 DSL이 있습니다.</target>
        </trans-unit>
        <trans-unit id="8a7b2ebad239fb7a910fd79eab4f3372b29c79ee" translate="yes" xml:space="preserve">
          <source>Since all the dependencies required for Kotlin are defined in the Gradle file, nothing else needs to be configured specifically for Kotlin to run correctly.</source>
          <target state="translated">Kotlin에 필요한 모든 종속성은 Gradle 파일에 정의되어 있으므로 Kotlin이 올바르게 실행되도록 특별히 구성 할 필요는 없습니다.</target>
        </trans-unit>
        <trans-unit id="8de791302c96952201846f400a6083331bbe72a8" translate="yes" xml:space="preserve">
          <source>Since an anonymous class has no name, it can't be used as a return type - if you do return an anonymous object, the function's return type must be &lt;code&gt;Any&lt;/code&gt;.</source>
          <target state="translated">익명 클래스에는 이름이 없으므로 반환 유형으로 사용할 수 없습니다. 익명 객체를 반환하는 경우 함수의 반환 유형은 &lt;code&gt;Any&lt;/code&gt; 이어야합니다 .</target>
        </trans-unit>
        <trans-unit id="1d293ea0c045033de8d8bd3af73aa0ea0b91a963" translate="yes" xml:space="preserve">
          <source>Since binaries compiled this way depend on the Kotlin runtime you should make sure the latter is present in the classpath whenever your compiled library is used.</source>
          <target state="translated">이 방법으로 컴파일 된 바이너리는 Kotlin 런타임에 따라 다르므로 컴파일 된 라이브러리를 사용할 때마다 클래스 경로에 해당 바이너리가 있는지 확인해야합니다.</target>
        </trans-unit>
        <trans-unit id="622c73b5fb8d14a132011c0334d390f1a510313f" translate="yes" xml:space="preserve">
          <source>Since cancellation is just an exception, all resources are closed in the usual way. You can wrap the code with timeout in a &lt;code&gt;try {...} catch (e: TimeoutCancellationException) {...}&lt;/code&gt; block if you need to do some additional action specifically on any kind of timeout or use the &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/with-timeout-or-null.html&quot;&gt;withTimeoutOrNull&lt;/a&gt; function that is similar to &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/with-timeout.html&quot;&gt;withTimeout&lt;/a&gt; but returns &lt;code&gt;null&lt;/code&gt; on timeout instead of throwing an exception:</source>
          <target state="translated">취소는 예외 일 뿐이므로 모든 리소스는 일반적인 방식으로 닫힙니다. 시간 종료에 대해 특별히 추가 조치를 수행하거나 &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/with-timeout-or-null.html&quot;&gt;withTimeoutOrNull&lt;/a&gt; 함수를 사용하려는 경우 &lt;code&gt;try {...} catch (e: TimeoutCancellationException) {...}&lt;/code&gt; 블록 에서 시간 종료로 코드를 랩핑 할 수 있습니다 . &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/with-timeout.html&quot;&gt;withTimeout&lt;/a&gt; 이지만 예외를 throw하는 대신 시간 초과시 &lt;code&gt;null&lt;/code&gt; 을 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="4e125d582c3c9f675a15d0038927e92dc5fb9b46" translate="yes" xml:space="preserve">
          <source>Since data classes automatically declare &lt;code&gt;componentN()&lt;/code&gt; functions, destructuring declarations work here.</source>
          <target state="translated">데이터 클래스가 &lt;code&gt;componentN()&lt;/code&gt; 함수를 자동으로 선언하므로 여기에서 구조화 선언이 작동합니다.</target>
        </trans-unit>
        <trans-unit id="ab91ad24a43e16b80819fa3c7ccb13e2c89d3927" translate="yes" xml:space="preserve">
          <source>Since each enum is an instance of the enum class, they can be initialized as:</source>
          <target state="translated">각 열거 형은 열거 형 클래스의 인스턴스이므로 다음과 같이 초기화 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="fccccbd7e91cba8ebb5a9e0230afa4e091b0cd00" translate="yes" xml:space="preserve">
          <source>Since inline classes are compiled to their underlying type, it may lead to various obscure errors, for example unexpected platform signature clashes:</source>
          <target state="translated">인라인 클래스는 기본 유형으로 컴파일되므로 예기치 않은 플랫폼 서명 충돌과 같은 다양한 모호한 오류가 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="90493c5a0e006c2eb80d1e75cd9d689e0f1392ea" translate="yes" xml:space="preserve">
          <source>Since the arrays are also mapped to &lt;code&gt;CPointer&amp;lt;T&amp;gt;&lt;/code&gt;, it supports the &lt;code&gt;[]&lt;/code&gt; operator for accessing values by index:</source>
          <target state="translated">배열도 &lt;code&gt;CPointer&amp;lt;T&amp;gt;&lt;/code&gt; 매핑 되므로 인덱스로 값에 액세스하기위한 &lt;code&gt;[]&lt;/code&gt; 연산자를 지원합니다 .</target>
        </trans-unit>
        <trans-unit id="4d7b853892431a18d65c0d328c4b6e037836cf2e" translate="yes" xml:space="preserve">
          <source>Since the available operators are hardcoded into the formal Kotlin syntax, you can not invent new operators, and overriding an operator does not affect its &lt;a href=&quot;https://kotlinlang.org/docs/reference/grammar.html#precedence&quot;&gt;precedence&lt;/a&gt;.</source>
          <target state="translated">사용 가능한 연산자는 공식 Kotlin 구문으로 하드 코딩되므로 새 연산자를 발명 할 수 없으며 연산자를 재정의해도 &lt;a href=&quot;https://kotlinlang.org/docs/reference/grammar.html#precedence&quot;&gt;우선 순위에&lt;/a&gt; 영향을 미치지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="fd0b229f654576b966a8840a049ffa6b928881c9" translate="yes" xml:space="preserve">
          <source>Since the entire anonymous function is self-executing, it will execute as soon as the code is loaded. Its argument will be the object &lt;code&gt;kotlin&lt;/code&gt; from &lt;code&gt;kotlin.js&lt;/code&gt;.</source>
          <target state="translated">전체 익명 함수는 자체 실행되므로 코드가로드되는 즉시 실행됩니다. 그 인수는 &lt;code&gt;kotlin&lt;/code&gt; .js 의 &lt;code&gt;kotlin.js&lt;/code&gt; 객체 입니다.</target>
        </trans-unit>
        <trans-unit id="99fc39de8ebf0847b1a608d5ecfdb8c433717d90" translate="yes" xml:space="preserve">
          <source>Since the order of parameters for an annotation written in Java is not defined, you can't use a regular function call syntax for passing the arguments. Instead, you need to use the named argument syntax:</source>
          <target state="translated">Java로 작성된 주석의 매개 변수 순서가 정의되어 있지 않으므로 인수를 전달하기 위해 일반 함수 호출 구문을 사용할 수 없습니다. 대신 명명 된 인수 구문을 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="1d3e6156826d803abef978e9ca301cc858a7854d" translate="yes" xml:space="preserve">
          <source>Since the parameter types are not encoded as generic type parameters in &lt;code&gt;KFunction&amp;lt;V&amp;gt;&lt;/code&gt;, you won't get compile-time type validation of the parameters you pass. In order to encode the parameter types, use one of the subinterfaces &lt;code&gt;KFunction1&amp;lt;A, V&amp;gt;&lt;/code&gt;, &lt;code&gt;KFunction2&amp;lt;A, B, V&amp;gt;&lt;/code&gt;, &lt;code&gt;KFunction3&amp;lt;A, B, C, V&amp;gt;&lt;/code&gt;, and so on, depending on how many parameters the function has got. Keep in mind that if you are referencing a member function, the first generic type parameter is the receiver type. For example, &lt;code&gt;KFunction3&amp;lt;A, B, C, V&amp;gt;&lt;/code&gt; may reference either an ordinary function that takes &lt;code&gt;A&lt;/code&gt;, &lt;code&gt;B&lt;/code&gt;, and &lt;code&gt;C&lt;/code&gt; as parameters and returns &lt;code&gt;V&lt;/code&gt;, or it may reference a member function on &lt;code&gt;A&lt;/code&gt; that takes &lt;code&gt;B&lt;/code&gt; and &lt;code&gt;C&lt;/code&gt; as parameters and returns &lt;code&gt;V&lt;/code&gt;. When you use any of these types, you can call the function through its reference as if the reference were a function, e.g. &lt;code&gt;function(a, b)&lt;/code&gt;, and this call will be type-safe.</source>
          <target state="translated">매개 변수 유형은 &lt;code&gt;KFunction&amp;lt;V&amp;gt;&lt;/code&gt; 에서 일반 유형 매개 변수로 인코딩되지 않으므로 전달한 매개 변수의 컴파일 타임 유형 유효성 검증을 얻지 못합니다. 매개 변수 유형을 인코딩하려면 매개 변수 수에 따라 서브 인터페이스 &lt;code&gt;KFunction1&amp;lt;A, V&amp;gt;&lt;/code&gt; , &lt;code&gt;KFunction2&amp;lt;A, B, V&amp;gt;&lt;/code&gt; , &lt;code&gt;KFunction3&amp;lt;A, B, C, V&amp;gt;&lt;/code&gt; 등 중 하나를 사용하십시오. 기능이 있습니다. 멤버 함수를 참조하는 경우 첫 번째 일반 유형 매개 변수는 수신자 유형입니다. 예를 들어 &lt;code&gt;KFunction3&amp;lt;A, B, C, V&amp;gt;&lt;/code&gt; 는 &lt;code&gt;A&lt;/code&gt; , &lt;code&gt;B&lt;/code&gt; 및 &lt;code&gt;C&lt;/code&gt; 를 매개 변수로 사용하고 &lt;code&gt;V&lt;/code&gt; 를 반환 하는 일반 함수를 참조 할 수 있습니다.또는 그것의 멤버 함수를 참조 할 수있다 얻어 &lt;code&gt;B&lt;/code&gt; 및 &lt;code&gt;C&lt;/code&gt; 를 매개로 복귀 &lt;code&gt;V&lt;/code&gt; 를 . 이러한 유형을 사용하는 경우 참조가 &lt;code&gt;function(a, b)&lt;/code&gt; 예 : function (a, b)) 인 것처럼 참조를 통해 함수를 호출 할 수 있으며이 호출은 유형 안전합니다. &lt;code&gt;A&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="c8d2c0eaa40e46a8c6ea31321656b62533073742" translate="yes" xml:space="preserve">
          <source>Since version 1.1.4, Kotlin/JS includes a dead code elimination (DCE) tool. This tool allows to strip out unused properties, functions and classes from the generated JS. There are several ways you get unused declarations:</source>
          <target state="translated">버전 1.1.4부터 Kotlin / JS에는 데드 코드 제거 (DCE) 도구가 포함되어 있습니다. 이 도구를 사용하면 생성 된 JS에서 사용하지 않는 속성, 함수 및 클래스를 제거 할 수 있습니다. 사용하지 않는 선언을 얻는 방법에는 여러 가지가 있습니다.</target>
        </trans-unit>
        <trans-unit id="eb32719a3bf81b439295cec580621456d2ecbd8a" translate="yes" xml:space="preserve">
          <source>Since we'll be using the &lt;a href=&quot;https://github.com/Kotlin/kotlinx.coroutines&quot;&gt;&lt;code&gt;kotlinx.coroutines&lt;/code&gt;&lt;/a&gt;, let's add its recent version to our dependencies:</source>
          <target state="translated">&lt;a href=&quot;https://github.com/Kotlin/kotlinx.coroutines&quot;&gt; &lt;code&gt;kotlinx.coroutines&lt;/code&gt; 를&lt;/a&gt; 사용할 것이므로 최신 버전을 종속 항목에 추가해 보겠습니다.</target>
        </trans-unit>
        <trans-unit id="1a9dce84a0725c0b6c49a8e9dd94e932d53babd3" translate="yes" xml:space="preserve">
          <source>Since you can't modify built-in or third-party classes, you can't directly add functions or properties to them. If you can achieve what you want by only using the public members of a class, you can of course just write a function that takes an instance of the class as a parameter - but sometimes, you'd really like to be able to say &lt;code&gt;x.foo(y)&lt;/code&gt; instead of &lt;code&gt;foo(x, y)&lt;/code&gt;, especially if you want to make a chain of such calls or property lookups: &lt;code&gt;x.foo(y).bar().baz&lt;/code&gt; instead of &lt;code&gt;getBaz(bar(foo(x, y)))&lt;/code&gt;.</source>
          <target state="translated">내장 또는 타사 클래스를 수정할 수 없으므로 함수 나 속성을 직접 추가 할 수 없습니다. 클래스의 공용 멤버 만 사용하여 원하는 것을 얻을 수 있다면 클래스의 인스턴스를 매개 변수로 사용하는 함수를 작성할 수는 있지만 때로는 &lt;code&gt;x.foo(y)&lt;/code&gt; 를 말할 수 있기를 원합니다. &lt;code&gt;foo(x, y)&lt;/code&gt; y) 대신 .foo (y) , 특히 이러한 호출 또는 속성 조회 체인을 만들려는 경우 &lt;code&gt;getBaz(bar(foo(x, y)))&lt;/code&gt; 대신 &lt;code&gt;x.foo(y).bar().baz&lt;/code&gt; , y))) .</target>
        </trans-unit>
        <trans-unit id="06def0138f09b8c0f949f07f4920634afdd6f7fb" translate="yes" xml:space="preserve">
          <source>SinceKotlin</source>
          <target state="translated">SinceKotlin</target>
        </trans-unit>
        <trans-unit id="c2499363e6a7b206721dbe6071ddba0631ff7592" translate="yes" xml:space="preserve">
          <source>Single-Expression functions</source>
          <target state="translated">단일 표현 함수</target>
        </trans-unit>
        <trans-unit id="948bf8711c54b33e1c9d4a741ca29c920e235551" translate="yes" xml:space="preserve">
          <source>Single-expression functions</source>
          <target state="translated">단일 표현 함수</target>
        </trans-unit>
        <trans-unit id="f4952f106d9d3b4bccd6d238d2f11b71e55ecb4c" translate="yes" xml:space="preserve">
          <source>Singletons</source>
          <target state="translated">Singletons</target>
        </trans-unit>
        <trans-unit id="ee6a091ca276835c16a3bfeac72a4361f88e2bf7" translate="yes" xml:space="preserve">
          <source>Sixteen-bit UCS Transformation Format, big-endian byte order.</source>
          <target state="translated">16 비트 UCS 변환 형식, 빅 엔디안 바이트 순서.</target>
        </trans-unit>
        <trans-unit id="ee23d2f192966423edfb5a719af0092090fdca64" translate="yes" xml:space="preserve">
          <source>Sixteen-bit UCS Transformation Format, byte order identified by an optional byte-order mark.</source>
          <target state="translated">16 비트 UCS 변환 형식, 선택적 바이트 순서 표시로 식별되는 바이트 순서.</target>
        </trans-unit>
        <trans-unit id="ecc2e39f3a6f9988d872a59c8d23128ff9edbcfe" translate="yes" xml:space="preserve">
          <source>Sixteen-bit UCS Transformation Format, little-endian byte order.</source>
          <target state="translated">16 비트 UCS 변환 형식, 리틀 엔디안 바이트 순서.</target>
        </trans-unit>
        <trans-unit id="f85dd4da6fcf55c2051ab8017fddbb6a18773e03" translate="yes" xml:space="preserve">
          <source>Skip reachibility check, can lead to mysterious crashes in an application. USE UNSAFE MODE ONLY IF ABSOLUTELY SURE WHAT YOU'RE DOING!!!</source>
          <target state="translated">접근성 검사를 건너 뛰고 응용 프로그램에서 신비한 충돌이 발생할 수 있습니다. 안전하고 확실하게 작동하는 경우에만 안전 모드를 사용하십시오 !!!</target>
        </trans-unit>
        <trans-unit id="71b8e40a5867a69e273ec4b85f91eb799854cf9c" translate="yes" xml:space="preserve">
          <source>Skip this file and go to the next.</source>
          <target state="translated">이 파일을 건너 뛰고 다음 파일로 이동하십시오.</target>
        </trans-unit>
        <trans-unit id="430b38bf6daa7f9164b164b2ffd540b5a3afe2fd" translate="yes" xml:space="preserve">
          <source>Slack</source>
          <target state="translated">Slack</target>
        </trans-unit>
        <trans-unit id="0c8525a31f225d6db84222cdc68f43cb8c6c18bf" translate="yes" xml:space="preserve">
          <source>Slice</source>
          <target state="translated">Slice</target>
        </trans-unit>
        <trans-unit id="d4ba32e18a522523616ead4e04bba098b836f870" translate="yes" xml:space="preserve">
          <source>Slotable</source>
          <target state="translated">Slotable</target>
        </trans-unit>
        <trans-unit id="10fbb462857c0cba8ce2d0a30fb30be71bb9c668" translate="yes" xml:space="preserve">
          <source>Smaller changes</source>
          <target state="translated">작은 변화</target>
        </trans-unit>
        <trans-unit id="1962b7c27bd3945eb2943949ba4b088ed50789a2" translate="yes" xml:space="preserve">
          <source>Smart Casts</source>
          <target state="translated">스마트 캐스트</target>
        </trans-unit>
        <trans-unit id="5d5e5c19860062429de60b61bb54ca023fa3667c" translate="yes" xml:space="preserve">
          <source>Smart cast improvements</source>
          <target state="translated">스마트 캐스트 개선</target>
        </trans-unit>
        <trans-unit id="bcb3cbb48cb2ad564dda01b8a4d33886b1b4cae4" translate="yes" xml:space="preserve">
          <source>Smart casts</source>
          <target state="translated">스마트 캐스트</target>
        </trans-unit>
        <trans-unit id="31522d97ace96f0c56defc6bbe0845e755f1d98b" translate="yes" xml:space="preserve">
          <source>Smartcasts on local delegated properties</source>
          <target state="translated">로컬 위임 속성의 스마트 캐스트</target>
        </trans-unit>
        <trans-unit id="a633eaa449ddacea57394a3e6ff86e18a93dfbee" translate="yes" xml:space="preserve">
          <source>So basically, we just put a string inside a tag body, but there is this little &lt;code&gt;+&lt;/code&gt; in front of it, so it is a function call that invokes a prefix &lt;code&gt;unaryPlus()&lt;/code&gt; operation. That operation is actually defined by an extension function &lt;code&gt;unaryPlus()&lt;/code&gt; that is a member of the &lt;code&gt;TagWithText&lt;/code&gt; abstract class (a parent of &lt;code&gt;Title&lt;/code&gt;):</source>
          <target state="translated">따라서 기본적으로 태그 본문 안에 문자열을 넣지 만 앞에 작은 &lt;code&gt;+&lt;/code&gt; 가 있으므로 &lt;code&gt;unaryPlus()&lt;/code&gt; 접두사 접두사를 호출하는 함수 호출입니다 . 이 작업은 실제로 &lt;code&gt;TagWithText&lt;/code&gt; 추상 클래스 ( &lt;code&gt;Title&lt;/code&gt; 의 부모)의 멤버 인 확장 함수 &lt;code&gt;unaryPlus()&lt;/code&gt; 의해 정의됩니다 .</target>
        </trans-unit>
        <trans-unit id="932e80ae659a0de90bc0dc75a6b10c120ab6dbb8" translate="yes" xml:space="preserve">
          <source>So equality would have been lost silently all over the place, not to mention identity.</source>
          <target state="translated">따라서 동일성을 언급하지 않고 평등이 모든 곳에서 조용히 사라 졌을 것입니다.</target>
        </trans-unit>
        <trans-unit id="e96dd13ef1773945f266699aea438682e7ab3594" translate="yes" xml:space="preserve">
          <source>So in combination with the top level variable declared above, it can allow looking at the same memory from different threads and building traditional concurrent structures with platform-specific synchronization primitives.</source>
          <target state="translated">따라서 위에서 선언 한 최상위 변수와 함께 다른 스레드에서 동일한 메모리를보고 플랫폼 별 동기화 프리미티브를 사용하여 기존의 동시 구조를 구축 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="bc0acbaacdf27c7a450d9d610b6d7359119efc69" translate="yes" xml:space="preserve">
          <source>So is the following. The difference between &lt;code&gt;+&lt;/code&gt; and &lt;code&gt;.&lt;/code&gt; is that &lt;code&gt;+&lt;/code&gt; can be a unary operator, but &lt;code&gt;.&lt;/code&gt; can't, so the only way to get the second line to parse is to join it with the preceding line:</source>
          <target state="translated">다음과 같습니다. 차이 &lt;code&gt;+&lt;/code&gt; 와 &lt;code&gt;.&lt;/code&gt; 이다 &lt;code&gt;+&lt;/code&gt; 는 단항 연산자 될 수 있지만 &lt;code&gt;.&lt;/code&gt; 할 수 없으므로 두 번째 줄을 구문 분석하는 유일한 방법은 이전 줄과 결합하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="4f0ac44318d35bdb0434bf4bda34bcf67e8a08bc" translate="yes" xml:space="preserve">
          <source>So let us see what happens:</source>
          <target state="translated">어떻게되는지 보자.</target>
        </trans-unit>
        <trans-unit id="b40f56bc16e78af71c3cc44cb5713393fe2d93cd" translate="yes" xml:space="preserve">
          <source>So you can freely use destructuring declarations in &lt;em&gt;for&lt;/em&gt;-loops with maps (as well as collections of data class instances etc).</source>
          <target state="translated">따라서 &lt;em&gt;for&lt;/em&gt; 루프에서 맵 (및 데이터 클래스 인스턴스 모음 등)과 함께 구조적 선언을 자유롭게 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="a8703e28503d05aec067966bd9d7e146f04d7ce9" translate="yes" xml:space="preserve">
          <source>So you can import all synthetic properties for the &lt;code&gt;free/res/layout/activity_free.xml&lt;/code&gt; layout by adding this import:</source>
          <target state="translated">따라서이 가져 오기를 추가하여 &lt;code&gt;free/res/layout/activity_free.xml&lt;/code&gt; 레이아웃에 대한 모든 합성 특성을 가져올 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c3cd48eda4cfceda7505a2a71bde8fd157927016" translate="yes" xml:space="preserve">
          <source>So you can solve tasks:</source>
          <target state="translated">따라서 작업을 해결할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2048afe6ef578a9b8c02d8c1f2dc71ba4cc5e26a" translate="yes" xml:space="preserve">
          <source>So, Java prohibits such things in order to guarantee run-time safety. But this has some implications. For example, consider the &lt;code&gt;addAll()&lt;/code&gt; method from &lt;code&gt;Collection&lt;/code&gt; interface. What's the signature of this method? Intuitively, we'd put it this way:</source>
          <target state="translated">따라서 Java는 런타임 안전성을 보장하기 위해 이러한 것들을 금지합니다. 그러나 이것은 약간의 의미가 있습니다. 예를 들어 &lt;code&gt;Collection&lt;/code&gt; 인터페이스 의 &lt;code&gt;addAll()&lt;/code&gt; 메소드를 고려하십시오 . 이 방법의 서명은 무엇입니까? 직관적으로, 우리는 이것을 이런 식으로 넣었습니다.</target>
        </trans-unit>
        <trans-unit id="a5ea33aab863f2ed16d025b58cd153fccbe69f68" translate="yes" xml:space="preserve">
          <source>So, first the resulting program prints &lt;code&gt;Start&lt;/code&gt;, then it runs a coroutine through &lt;code&gt;launch {}&lt;/code&gt;, then it runs another one through &lt;code&gt;runBlocking {}&lt;/code&gt; and blocks until it's done, then prints &lt;code&gt;Stop&lt;/code&gt;. Meanwhile the first coroutine completes and prints &lt;code&gt;Hello&lt;/code&gt;. Just like threads, we told you :)</source>
          <target state="translated">따라서 결과 프로그램은 먼저 &lt;code&gt;Start&lt;/code&gt; 를 인쇄 한 다음 &lt;code&gt;launch {}&lt;/code&gt; 을 통해 코 루틴을 실행 한 다음 &lt;code&gt;runBlocking {}&lt;/code&gt; 을 통해 다른 코 루틴을 실행 하고 완료 될 때까지 차단 한 다음 &lt;code&gt;Stop&lt;/code&gt; 을 인쇄합니다 . 한편 첫 번째 코 루틴은 &lt;code&gt;Hello&lt;/code&gt; 를 완성하고 인쇄합니다 . 실처럼, 우리는 당신에게 말했다 :)</target>
        </trans-unit>
        <trans-unit id="4790cb680e369e2465f78a22145ef3881f0b2cc4" translate="yes" xml:space="preserve">
          <source>So, here the two coroutines are defined but not executed as in the previous example, but the control is given to the programmer on when exactly to start the execution by calling &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-job/start.html&quot;&gt;start&lt;/a&gt;. We first start &lt;code&gt;one&lt;/code&gt;, then start &lt;code&gt;two&lt;/code&gt;, and then await for the individual coroutines to finish.</source>
          <target state="translated">그래서, 여기에 두 개의 코 루틴이 정의되어 있지만 앞의 예에서와 같이 실행되지하지만 컨트롤이 정확하게 호출하여 실행을 시작할 때 프로그래머에게 주어집니다있다 &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-job/start.html&quot;&gt;시작&lt;/a&gt; . 먼저 &lt;code&gt;one&lt;/code&gt; 를 시작한 다음 &lt;code&gt;two&lt;/code&gt; 를 시작한 다음 개별 코 루틴이 완료되기를 기다립니다.</target>
        </trans-unit>
        <trans-unit id="f87bb15bb23744f645dc6cdce384f45a5dda4f5f" translate="yes" xml:space="preserve">
          <source>So, how do we start a coroutine? Let's use the &lt;code&gt;launch {}&lt;/code&gt; function:</source>
          <target state="translated">그렇다면 어떻게 코 루틴을 시작합니까? &lt;code&gt;launch {}&lt;/code&gt; 함수를 사용하자 :</target>
        </trans-unit>
        <trans-unit id="4e4f67678565baec8708cd041dbe11b31af3f570" translate="yes" xml:space="preserve">
          <source>So, now our functions are very simple:</source>
          <target state="translated">이제 우리의 기능은 매우 간단합니다.</target>
        </trans-unit>
        <trans-unit id="5e798efb8bbb72d38198a7facef7f3b574f4636e" translate="yes" xml:space="preserve">
          <source>So, the coroutine that had inherited context of &lt;code&gt;runBlocking {...}&lt;/code&gt; continues to execute in the &lt;code&gt;main&lt;/code&gt; thread, while the unconfined one had resumed in the default executor thread that &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/delay.html&quot;&gt;delay&lt;/a&gt; function is using.</source>
          <target state="translated">따라서 &lt;code&gt;runBlocking {...}&lt;/code&gt; 의 컨텍스트를 상속 한 코 루틴 은 &lt;code&gt;main&lt;/code&gt; 스레드 에서 계속 실행되는 반면 &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/delay.html&quot;&gt;지연&lt;/a&gt; 되지 않은 스레드는 지연 함수가 사용 하는 기본 실행기 스레드에서 다시 시작되었습니다 .</target>
        </trans-unit>
        <trans-unit id="7d211dfac10e36035423c9708a4f5505bb9c9ba2" translate="yes" xml:space="preserve">
          <source>So, the sequences let you avoid building results of intermediate steps, therefore improving the performance of the whole collection processing chain. However, the lazy nature of sequences adds some overhead which may be significant when processing smaller collections or doing simpler computations. Hence, you should consider both &lt;code&gt;Sequence&lt;/code&gt; and &lt;code&gt;Iterable&lt;/code&gt; and decide which one is better for your case.</source>
          <target state="translated">따라서 시퀀스를 사용하면 중간 단계의 결과를 작성하지 않아도되므로 전체 콜렉션 처리 체인의 성능이 향상됩니다. 그러나, 시퀀스의 게으른 특성은 약간의 오버 헤드를 추가하여 더 작은 콜렉션을 처리하거나 더 간단한 계산을 수행 할 때 중요 할 수 있습니다. 따라서 &lt;code&gt;Sequence&lt;/code&gt; 와 &lt;code&gt;Iterable&lt;/code&gt; 을 모두 고려 하고 어느 것이 더 적합한 지 결정해야합니다.</target>
        </trans-unit>
        <trans-unit id="d916356003ce204bc3a393ee9e159e33d7cd9b65" translate="yes" xml:space="preserve">
          <source>So, what does this call do? Let's look at the body of &lt;code&gt;html&lt;/code&gt; function as defined above. It creates a new instance of &lt;code&gt;HTML&lt;/code&gt;, then it initializes it by calling the function that is passed as an argument (in our example this boils down to calling &lt;code&gt;head&lt;/code&gt; and &lt;code&gt;body&lt;/code&gt; on the &lt;code&gt;HTML&lt;/code&gt; instance), and then it returns this instance. This is exactly what a builder should do.</source>
          <target state="translated">이 전화는 무엇을합니까? 위에서 정의한대로 &lt;code&gt;html&lt;/code&gt; 함수 의 본문을 보자 . 새 &lt;code&gt;HTML&lt;/code&gt; 인스턴스를 만든 다음 인수로 전달 된 함수를 호출하여 초기화합니다 (이 예제 에서는 &lt;code&gt;HTML&lt;/code&gt; 인스턴스 에서 &lt;code&gt;head&lt;/code&gt; 및 &lt;code&gt;body&lt;/code&gt; 호출로 귀결 됨 ).이 인스턴스를 반환합니다. 이것이 바로 빌더가해야 할 일입니다.</target>
        </trans-unit>
        <trans-unit id="52f3768098539882e0119dbb283e6497243cf386" translate="yes" xml:space="preserve">
          <source>So, what the prefix &lt;code&gt;+&lt;/code&gt; does here is wrapping a string into an instance of &lt;code&gt;TextElement&lt;/code&gt; and adding it to the &lt;code&gt;children&lt;/code&gt; collection, so that it becomes a proper part of the tag tree.</source>
          <target state="translated">따라서 접두사 &lt;code&gt;+&lt;/code&gt; 에서 수행하는 작업은 문자열을 &lt;code&gt;TextElement&lt;/code&gt; 의 인스턴스에 래핑 하고 &lt;code&gt;children&lt;/code&gt; 컬렉션에 추가 하여 태그 트리의 적절한 부분이되도록하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="12b3ed6e021fd91320b5ceebbd0e6bd9c0002703" translate="yes" xml:space="preserve">
          <source>Soft Keywords</source>
          <target state="translated">소프트 키워드</target>
        </trans-unit>
        <trans-unit id="718385fd0c419503c70f82a093c83a84b1b25a04" translate="yes" xml:space="preserve">
          <source>Some Java issues addressed in Kotlin</source>
          <target state="translated">Kotlin에서 해결 된 일부 Java 문제</target>
        </trans-unit>
        <trans-unit id="1ee1ea35caa4a9087e54f63c24f82f4afae23440" translate="yes" xml:space="preserve">
          <source>Some JavaScript libraries export packages (namespaces) instead of functions and classes. In terms of JavaScript, it's an object that has members that &lt;em&gt;are&lt;/em&gt; classes, functions and properties. Importing these packages as Kotlin objects often looks unnatural. The compiler allows to map imported JavaScript packages to Kotlin packages, using the following notation:</source>
          <target state="translated">일부 JavaScript 라이브러리는 함수 및 클래스 대신 패키지 (네임 스페이스)를 내 보냅니다. 자바 스크립트의 측면에서, 그것은 회원이있는 객체의 &lt;em&gt;수 있습니다&lt;/em&gt; 클래스, 함수와 속성을. Kotlin 객체로 이러한 패키지를 가져 오는 것은 종종 부 자연스럽게 보입니다. 컴파일러는 다음 표기법을 사용하여 가져온 JavaScript 패키지를 Kotlin 패키지에 매핑 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b8c228912efad39ab27850e7078c0b0220142ce8" translate="yes" xml:space="preserve">
          <source>Some annotation processors (such as &lt;code&gt;AutoFactory&lt;/code&gt;) rely on precise types in declaration signatures. By default, Kapt replaces every unknown type (including types for the generated classes) to &lt;code&gt;NonExistentClass&lt;/code&gt;, but you can change this behavior. Add the additional flag to the &lt;code&gt;build.gradle&lt;/code&gt; file to enable error type inferring in stubs:</source>
          <target state="translated">&lt;code&gt;AutoFactory&lt;/code&gt; 와 같은 일부 주석 프로세서 는 선언 서명의 정확한 유형에 의존합니다. 기본적으로 Kapt는 알 수없는 모든 유형 (생성 된 클래스의 유형 포함)을 &lt;code&gt;NonExistentClass&lt;/code&gt; 로 대체 하지만이 동작을 변경할 수 있습니다. 스텁에서 오류 유형을 유추 할 수 있도록 &lt;code&gt;build.gradle&lt;/code&gt; 파일에 추가 플래그를 추가하십시오 .</target>
        </trans-unit>
        <trans-unit id="e9b0112a5ded4d6fc76de7c8757792375d1ef8b3" translate="yes" xml:space="preserve">
          <source>Some data inconsistency with regard to initialization, such as when:</source>
          <target state="translated">다음과 같은 초기화와 관련하여 일부 데이터 불일치 :</target>
        </trans-unit>
        <trans-unit id="2ec82937de14be8e97ca0c1e28319cd1f629f0ec" translate="yes" xml:space="preserve">
          <source>Some examples of what definitely isn't an incompatible change include</source>
          <target state="translated">호환되지 않는 변경이 아닌 것의 일부 예는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="cb68483f5d41b2d8412528579f8201778d125468" translate="yes" xml:space="preserve">
          <source>Some libraries have proper &lt;code&gt;module.modulemap&lt;/code&gt; or &lt;code&gt;module.map&lt;/code&gt; files in its headers. For example, macOS and iOS system libraries and frameworks do. The &lt;a href=&quot;https://clang.llvm.org/docs/Modules.html#module-map-language&quot;&gt;module map file&lt;/a&gt; describes the correspondence between header files and modules. When the module maps are available, the headers from the modules that are not included directly can be filtered out using the experimental &lt;code&gt;excludeDependentModules&lt;/code&gt; option of the &lt;code&gt;.def&lt;/code&gt; file:</source>
          <target state="translated">일부 라이브러리에는 헤더에 적절한 &lt;code&gt;module.modulemap&lt;/code&gt; 또는 &lt;code&gt;module.map&lt;/code&gt; 파일이 있습니다. 예를 들어, macOS 및 iOS 시스템 라이브러리 및 프레임 워크가 있습니다. &lt;a href=&quot;https://clang.llvm.org/docs/Modules.html#module-map-language&quot;&gt;모듈 맵 파일&lt;/a&gt; 헤더 파일과 모듈 간의 대응 관계를 설명합니다. 모듈 맵을 사용할 수있는 경우 직접 포함되지 않은 모듈의 헤더 는 &lt;code&gt;.def&lt;/code&gt; 파일 의 실험적인 &lt;code&gt;excludeDependentModules&lt;/code&gt; 옵션을 사용하여 필터링 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="ecbe5afd16b78f70120a5b12f258298956ff8d44" translate="yes" xml:space="preserve">
          <source>Some non-primitive built-in classes are also mapped:</source>
          <target state="translated">기본이 아닌 내장 클래스도 매핑됩니다.</target>
        </trans-unit>
        <trans-unit id="8dee9b7120e2be75fc0bee01d923884834726ceb" translate="yes" xml:space="preserve">
          <source>Some of the Gradle built-in dependencies, like &lt;code&gt;gradleApi()&lt;/code&gt;, &lt;code&gt;localGroovy()&lt;/code&gt;, or &lt;code&gt;gradleTestKit()&lt;/code&gt; are not available in the source sets dependency DSL. You can, however, add them within the top-level dependency block, as shown above.</source>
          <target state="translated">&lt;code&gt;gradleApi()&lt;/code&gt; , &lt;code&gt;localGroovy()&lt;/code&gt; 또는 &lt;code&gt;gradleTestKit()&lt;/code&gt; 과 같은 Gradle 내장 종속성 중 일부는 소스 세트 종속성 DSL에서 사용할 수 없습니다. 그러나 위에 표시된 것처럼 최상위 종속성 블록 내에 추가 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ca33e1fd8c377d86f53c24cb8d991d157f4d2294" translate="yes" xml:space="preserve">
          <source>Some of the Kotlin keywords are valid identifiers in Java: &lt;em&gt;in&lt;/em&gt;, &lt;em&gt;object&lt;/em&gt;, &lt;em&gt;is&lt;/em&gt;, etc. If a Java library uses a Kotlin keyword for a method, you can still call the method escaping it with the backtick (`) character:</source>
          <target state="translated">Kotlin 키워드 중 일부는 Java에서 유효한 식별자입니다 : &lt;em&gt;in&lt;/em&gt; , &lt;em&gt;object&lt;/em&gt; , &lt;em&gt;is&lt;/em&gt; 등. Java 라이브러리가 메소드에 Kotlin 키워드를 사용하는 경우 여전히 백틱 (`) 문자로 이스케이프 처리하는 메소드를 호출 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6cec025139e5801ae5f90249c852e460ef019361" translate="yes" xml:space="preserve">
          <source>Some source sets are created and configured by default: &lt;code&gt;commonMain&lt;/code&gt;, &lt;code&gt;commonTest&lt;/code&gt;, and the default source sets for the compilations. See &lt;a href=&quot;#default-project-layout&quot;&gt;Default Project Layout&lt;/a&gt;.</source>
          <target state="translated">일부 소스 세트는 기본적으로 작성되고 구성됩니다 ( &lt;code&gt;commonMain&lt;/code&gt; , &lt;code&gt;commonTest&lt;/code&gt; 및 컴파일의 기본 소스 세트). &lt;a href=&quot;#default-project-layout&quot;&gt;기본 프로젝트 레이아웃을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="46849402d48ce8fa8cf59b2eca7dbd26570c373a" translate="yes" xml:space="preserve">
          <source>Some superclasses are very useful as a grouping mechanism for related classes and for providing shared functions, but are so general that they're not useful on their own. &lt;code&gt;MotorVehicle&lt;/code&gt; seems to fit this description. Such a class should be declared &lt;em&gt;abstract&lt;/em&gt;, which will prevent the class from being instantiated directly:</source>
          <target state="translated">일부 수퍼 클래스는 관련 클래스 및 공유 함수를 제공하기위한 그룹화 메커니즘으로 매우 유용하지만 너무 일반적으로 자체적으로 유용하지 않습니다. &lt;code&gt;MotorVehicle&lt;/code&gt; 이이 설명에 맞는 것 같습니다. 이러한 클래스는 &lt;em&gt;abstract&lt;/em&gt; 로 선언되어야하며, 클래스가 직접 인스턴스화되지 않도록합니다.</target>
        </trans-unit>
        <trans-unit id="a997931671767da7af31a971af570dea73db8ed8" translate="yes" xml:space="preserve">
          <source>Some targets may require additional configuration. For Android and iOS examples, see the &lt;a href=&quot;../tutorials/native/mpp-ios-android&quot;&gt;Multiplatform Project: iOS and Android&lt;/a&gt; tutorial.</source>
          <target state="translated">일부 대상은 추가 구성이 필요할 수 있습니다. Android 및 iOS 예제는 &lt;a href=&quot;../tutorials/native/mpp-ios-android&quot;&gt;멀티 플랫폼 프로젝트 : iOS 및 Android&lt;/a&gt; 학습서를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="63a9fbfe36ca16d1efe57c704a5a06f039c3e063" translate="yes" xml:space="preserve">
          <source>Sometimes it is beneficial to use &lt;a href=&quot;inline-functions&quot;&gt;inline functions&lt;/a&gt;, which provide flexible control flow, for higher-order functions.</source>
          <target state="translated">때로는 고차 함수에 유연한 제어 흐름을 제공 하는 &lt;a href=&quot;inline-functions&quot;&gt;인라인 함수&lt;/a&gt; 를 사용하는 것이 유리 합니다.</target>
        </trans-unit>
        <trans-unit id="b3c9f6d381eb6e20cbdde2643da759944b133d98" translate="yes" xml:space="preserve">
          <source>Sometimes it is convenient to &lt;em&gt;destructure&lt;/em&gt; an object into a number of variables, for example:</source>
          <target state="translated">때로는 객체를 여러 변수로 &lt;em&gt;구조화&lt;/em&gt; 하는 것이 편리합니다 . 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="302d682a26f0a7a9291ca67783bee5bced9328f3" translate="yes" xml:space="preserve">
          <source>Sometimes it is convenient to have an ability to pass some thread-local data, but, for coroutines, which are not bound to any particular thread, it is hard to achieve it manually without writing a lot of boilerplate.</source>
          <target state="translated">때로는 일부 스레드 로컬 데이터를 전달하는 것이 편리하지만 특정 스레드에 바인딩되지 않은 코 루틴의 경우 많은 상용구를 작성하지 않고 수동으로 달성하기가 어렵습니다.</target>
        </trans-unit>
        <trans-unit id="043a7ce5b4e61465c0bfadb7f717902673e4e6dd" translate="yes" xml:space="preserve">
          <source>Sometimes it is more convenient to ship a static library with your product, rather than assume it is available within the user's environment. To include a static library into &lt;code&gt;.klib&lt;/code&gt; use &lt;code&gt;staticLibrary&lt;/code&gt; and &lt;code&gt;libraryPaths&lt;/code&gt; clauses. For example:</source>
          <target state="translated">때로는 사용자 환경에서 사용할 수 있다고 가정하지 않고 정적 라이브러리를 제품과 함께 제공하는 것이 더 편리합니다. &lt;code&gt;.klib&lt;/code&gt; 에 정적 라이브러리를 포함 시키 려면 &lt;code&gt;staticLibrary&lt;/code&gt; 및 &lt;code&gt;libraryPaths&lt;/code&gt; 절을 사용하십시오. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="bda56f559bfdf285376cfe98c118c1fc0d45e476" translate="yes" xml:space="preserve">
          <source>Sometimes it is necessary for business logic to create a wrapper around some type. However, it introduces runtime overhead due to additional heap allocations. Moreover, if the wrapped type is primitive, the performance hit is terrible, because primitive types are usually heavily optimized by the runtime, while their wrappers don't get any special treatment.</source>
          <target state="translated">때로는 비즈니스 로직이 특정 유형의 랩퍼를 작성해야합니다. 그러나 추가 힙 할당으로 인해 런타임 오버 헤드가 발생합니다. 또한 랩핑 된 유형이 기본 유형 인 경우 기본 유형은 일반적으로 런타임에 의해 크게 최적화되는 반면 래퍼는 특별한 처리를받지 않기 때문에 성능이 저하됩니다.</target>
        </trans-unit>
        <trans-unit id="a1c252c20c0ca0a66522a4f37c8be9e2e7e0683f" translate="yes" xml:space="preserve">
          <source>Sometimes it is required to add custom C declarations to the library before generating bindings (e.g., for &lt;a href=&quot;#macros&quot;&gt;macros&lt;/a&gt;). Instead of creating an additional header file with these declarations, you can include them directly to the end of the &lt;code&gt;.def&lt;/code&gt; file, after a separating line, containing only the separator sequence &lt;code&gt;---&lt;/code&gt;:</source>
          <target state="translated">바인딩을 생성하기 전에 라이브러리에 사용자 정의 C 선언을 추가해야하는 경우가 있습니다 (예 : &lt;a href=&quot;#macros&quot;&gt;매크로&lt;/a&gt; ). 이러한 선언으로 추가 헤더 파일을 작성하는 대신 구분 기호 시퀀스 &lt;code&gt;---&lt;/code&gt; : 만 포함하는 구분 행 뒤에 &lt;code&gt;.def&lt;/code&gt; 파일 의 끝에 직접 포함시킬 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="56ecfc8da440116471986a5f61a75f0ea7b94e9a" translate="yes" xml:space="preserve">
          <source>Sometimes it is required to override initializers, e.g. when subclassing &lt;code&gt;UIViewController&lt;/code&gt;. Initializers imported as Kotlin constructors can be overridden by Kotlin constructors marked with the &lt;code&gt;@OverrideInit&lt;/code&gt; annotation:</source>
          <target state="translated">&lt;code&gt;UIViewController&lt;/code&gt; 를 서브 클래 싱 할 때와 같이 이니셜 라이저를 재정의해야하는 경우가 있습니다 . Kotlin 생성자로 가져온 이니셜 라이저는 &lt;code&gt;@OverrideInit&lt;/code&gt; 주석으로 표시된 Kotlin 생성자가 재정의 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="efdaae37e7bf4722447db8e7626c18f363241541" translate="yes" xml:space="preserve">
          <source>Sometimes the C libraries have function parameters or struct fields of a platform-dependent type, e.g. &lt;code&gt;long&lt;/code&gt; or &lt;code&gt;size_t&lt;/code&gt;. Kotlin itself doesn't provide neither implicit integer casts nor C-style integer casts (e.g. &lt;code&gt;(size_t) intValue&lt;/code&gt;), so to make writing portable code in such cases easier, the &lt;code&gt;convert&lt;/code&gt; method is provided:</source>
          <target state="translated">때때로 C 라이브러리에는 플랫폼 또는 유형 (예 : &lt;code&gt;long&lt;/code&gt; 또는 &lt;code&gt;size_t&lt;/code&gt; )의 함수 매개 변수 또는 구조체 필드가 있습니다. Kotlin 자체는 암시 적 정수 캐스트 나 C 스타일 정수 캐스트 (예 : &lt;code&gt;(size_t) intValue&lt;/code&gt; )를 제공하지 않으므로 이러한 경우 이식 가능한 코드를보다 쉽게 ​​작성하기 위해 &lt;code&gt;convert&lt;/code&gt; 메소드가 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="c6d7d45f9a4bb2f105945868e1e4262dd631e65e" translate="yes" xml:space="preserve">
          <source>Sometimes we have a named function in Kotlin, for which we need a different JVM name in the byte code. The most prominent example happens due to &lt;em&gt;type erasure&lt;/em&gt;:</source>
          <target state="translated">때때로 Kotlin에 명명 된 함수가 있는데,이를 위해 바이트 코드에 다른 JVM 이름이 필요합니다. 가장 두드러진 예는 &lt;em&gt;유형 삭제&lt;/em&gt; 로 인해 발생합니다 .</target>
        </trans-unit>
        <trans-unit id="57bc7ebf1e9198008144108c9c1119ef8c7efcd8" translate="yes" xml:space="preserve">
          <source>Sometimes we need to access a type passed to us as a parameter:</source>
          <target state="translated">때때로 우리는 매개 변수로 전달 된 타입에 접근해야합니다 :</target>
        </trans-unit>
        <trans-unit id="d5900485f21e94ff8c4ddb23a5e9d44345914137" translate="yes" xml:space="preserve">
          <source>Sometimes we need to create an object of a slight modification of some class, without explicitly declaring a new subclass for it. Java handles this case with &lt;em&gt;anonymous inner classes&lt;/em&gt;. Kotlin slightly generalizes this concept with &lt;em&gt;object expressions&lt;/em&gt; and &lt;em&gt;object declarations&lt;/em&gt;.</source>
          <target state="translated">때로는 새로운 하위 클래스를 명시 적으로 선언하지 않고 일부 클래스를 약간 수정 한 객체를 만들어야 할 때가 있습니다. Java는 &lt;em&gt;익명의 내부 클래스&lt;/em&gt; 로이 경우를 처리합니다 . Kotlin은이 개념을 &lt;em&gt;객체 표현식&lt;/em&gt; 과 &lt;em&gt;객체 선언으로&lt;/em&gt; 약간 일반화합니다 .</target>
        </trans-unit>
        <trans-unit id="c43bb60fb115adf5865cb0fa15a4f5e0748287e9" translate="yes" xml:space="preserve">
          <source>Sometimes we need to define multiple elements for coroutine context. We can use &lt;code&gt;+&lt;/code&gt; operator for that. For example, we can launch a coroutine with an explicitly specified dispatcher and an explicitly specified name at the same time:</source>
          <target state="translated">때로는 코 루틴 컨텍스트를 위해 여러 요소를 정의해야합니다. 이를 위해 &lt;code&gt;+&lt;/code&gt; 연산자를 사용할 수 있습니다 . 예를 들어, 명시 적으로 지정된 디스패처와 명시 적으로 지정된 이름을 가진 코 루틴을 동시에 시작할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1310e09600b521eea851206fd94e82f8d190d5a5" translate="yes" xml:space="preserve">
          <source>Sometimes you are going to use a Kotlin declaration directly from JavaScript, and it's being stripped out by DCE. You may want to keep this declaration. To do so, you can use the following syntax in &lt;code&gt;build.gradle&lt;/code&gt;:</source>
          <target state="translated">때로는 JavaScript에서 직접 Kotlin 선언을 사용하려고하는데 DCE에 의해 제거됩니다. 이 선언을 유지하고 싶을 수도 있습니다. 그렇게하려면 &lt;code&gt;build.gradle&lt;/code&gt; 에서 다음 구문을 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="701d6ffd47aa414cf9e4b9070e6ac69d9f907851" translate="yes" xml:space="preserve">
          <source>Sometimes you may need to quickly write and execute some code outside of a project or an application. This may be useful, for example, when learning Kotlin or evaluating expressions. Let's have a look through two handy ways to quickly run Kotlin code:</source>
          <target state="translated">때로는 프로젝트 나 응용 프로그램 외부에서 일부 코드를 빠르게 작성하고 실행해야 할 수도 있습니다. 예를 들어 Kotlin을 배우거나 표현을 평가할 때 유용 할 수 있습니다. Kotlin 코드를 빠르게 실행하는 두 가지 편리한 방법을 살펴 보겠습니다.</target>
        </trans-unit>
        <trans-unit id="b4425ac713740daf889b7cc088cbeb587776a728" translate="yes" xml:space="preserve">
          <source>Sometimes you need to call a Kotlin method with a parameter of type &lt;code&gt;KClass&lt;/code&gt;. There is no automatic conversion from &lt;code&gt;Class&lt;/code&gt; to &lt;code&gt;KClass&lt;/code&gt;, so you have to do it manually by invoking the equivalent of the &lt;code&gt;Class&amp;lt;T&amp;gt;.kotlin&lt;/code&gt; extension property:</source>
          <target state="translated">때로는 &lt;code&gt;KClass&lt;/code&gt; 유형의 매개 변수를 사용하여 Kotlin 메소드를 호출해야합니다 . &lt;code&gt;Class&lt;/code&gt; 에서 &lt;code&gt;KClass&lt;/code&gt; 로의 자동 변환은 없으므로 &lt;code&gt;Class&amp;lt;T&amp;gt;.kotlin&lt;/code&gt; 확장 등록 정보 와 동등한 기능을 호출하여 수동으로 수행해야합니다 .</target>
        </trans-unit>
        <trans-unit id="f7c6d9e07fb190279efd213b27af8a596256a8b2" translate="yes" xml:space="preserve">
          <source>Sometimes you want to say that you know nothing about the type argument, but still want to use it in a safe way. The safe way here is to define such a projection of the generic type, that every concrete instantiation of that generic type would be a subtype of that projection.</source>
          <target state="translated">때로는 타입 인수에 대해 아무것도 모른다고 말하고 싶지만 여전히 안전한 방식으로 사용하고 싶습니다. 여기서 안전한 방법은 제네릭 형식의 투영을 정의하여 해당 제네릭 형식의 모든 구체적인 인스턴스화가 해당 투영의 하위 유형이되도록하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="46f170a2459c0e42a18d65de64835d7772e9f851" translate="yes" xml:space="preserve">
          <source>Sometimes, you're in a situation where you have a value &lt;code&gt;x&lt;/code&gt; that you know is not null, but the compiler doesn't realize it. This can legitimately happen when you're interacting with Java code, but if it happens because your code's logic is more complicated than the compiler's ability to reason about it, you should probably restructure your code. If you can't convince the compiler, you can resort to saying &lt;code&gt;x!!&lt;/code&gt; to form an expression that produces the value of &lt;code&gt;x&lt;/code&gt;, but whose type is non-nullable:</source>
          <target state="translated">때때로, 당신은 당신이 알고있는 &lt;code&gt;x&lt;/code&gt; 값 이 null이 아닌 상황에 처해 있지만 컴파일러는 그것을 인식하지 못합니다. 이는 Java 코드와 상호 작용할 때 합법적으로 발생할 수 있지만 코드 논리가 컴파일러의 추론 능력보다 복잡하기 때문에 발생하는 경우 코드를 재구성해야합니다. 컴파일러를 설득 할 수 없다면 &lt;code&gt;x!!&lt;/code&gt; 라고 말할 수 있습니다 ! &lt;code&gt;x&lt;/code&gt; 값을 생성 하지만 유형이 널 입력 불가능한 표현식을 작성하려면 다음을 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="378e9e163b7eecefadb4415cae533096e336c4ab" translate="yes" xml:space="preserve">
          <source>Sorting</source>
          <target state="translated">Sorting</target>
        </trans-unit>
        <trans-unit id="921e7c9357933042c013290bc34dab79354742a1" translate="yes" xml:space="preserve">
          <source>Sorts a range in the array in-place with the given &lt;a href=&quot;../../kotlin.collections/sort-with#kotlin.collections%24sortWith%28kotlin.Array%28%28kotlin.collections.sortWith.T%29%29%2C+java.util.Comparator%28%28kotlin.collections.sortWith.T%29%29%2C+kotlin.Int%2C+kotlin.Int%29%2Fcomparator&quot;&gt;comparator&lt;/a&gt;.</source>
          <target state="translated">지정된 &lt;a href=&quot;../../kotlin.collections/sort-with#kotlin.collections%24sortWith%28kotlin.Array%28%28kotlin.collections.sortWith.T%29%29%2C+java.util.Comparator%28%28kotlin.collections.sortWith.T%29%29%2C+kotlin.Int%2C+kotlin.Int%29%2Fcomparator&quot;&gt;comparator&lt;/a&gt; 를 사용하여 배열의 범위를 내부 정렬합니다 .</target>
        </trans-unit>
        <trans-unit id="7a20d1597d8301c3cc3bcec0a63b03857c779e81" translate="yes" xml:space="preserve">
          <source>Sorts a range in the array in-place with the given &lt;a href=&quot;sort-with#kotlin.collections%24sortWith%28kotlin.Array%28%28kotlin.collections.sortWith.T%29%29%2C+java.util.Comparator%28%28kotlin.collections.sortWith.T%29%29%2C+kotlin.Int%2C+kotlin.Int%29%2Fcomparator&quot;&gt;comparator&lt;/a&gt;.</source>
          <target state="translated">지정된 &lt;a href=&quot;sort-with#kotlin.collections%24sortWith%28kotlin.Array%28%28kotlin.collections.sortWith.T%29%29%2C+java.util.Comparator%28%28kotlin.collections.sortWith.T%29%29%2C+kotlin.Int%2C+kotlin.Int%29%2Fcomparator&quot;&gt;comparator&lt;/a&gt; 를 사용하여 배열의 범위를 내부 정렬합니다 .</target>
        </trans-unit>
        <trans-unit id="1d1e6b1aadd9cf85696a8efae6efd2f282221c3e" translate="yes" xml:space="preserve">
          <source>Sorts a range in the array in-place.</source>
          <target state="translated">배열의 범위를 내부에서 정렬합니다.</target>
        </trans-unit>
        <trans-unit id="10a2c137539a5db660667fa6576c28cd26e36ac6" translate="yes" xml:space="preserve">
          <source>Sorts elements in the array in-place according to natural sort order of the value returned by specified &lt;a href=&quot;../../kotlin.collections/sort-by#kotlin.collections%24sortBy%28kotlin.Array%28%28kotlin.collections.sortBy.T%29%29%2C+kotlin.Function1%28%28kotlin.collections.sortBy.T%2C+kotlin.collections.sortBy.R%29%29%29%2Fselector&quot;&gt;selector&lt;/a&gt; function.</source>
          <target state="translated">지정된 &lt;a href=&quot;../../kotlin.collections/sort-by#kotlin.collections%24sortBy%28kotlin.Array%28%28kotlin.collections.sortBy.T%29%29%2C+kotlin.Function1%28%28kotlin.collections.sortBy.T%2C+kotlin.collections.sortBy.R%29%29%29%2Fselector&quot;&gt;선택기&lt;/a&gt; 함수에서 반환 한 값의 자연 정렬 순서에 따라 배열의 요소를 내부에서 정렬합니다 .</target>
        </trans-unit>
        <trans-unit id="07efbdad7d4d4a2414ba73adc668adade052ada0" translate="yes" xml:space="preserve">
          <source>Sorts elements in the array in-place according to natural sort order of the value returned by specified &lt;a href=&quot;sort-by#kotlin.collections%24sortBy%28kotlin.Array%28%28kotlin.collections.sortBy.T%29%29%2C+kotlin.Function1%28%28kotlin.collections.sortBy.T%2C+kotlin.collections.sortBy.R%29%29%29%2Fselector&quot;&gt;selector&lt;/a&gt; function.</source>
          <target state="translated">지정된 &lt;a href=&quot;sort-by#kotlin.collections%24sortBy%28kotlin.Array%28%28kotlin.collections.sortBy.T%29%29%2C+kotlin.Function1%28%28kotlin.collections.sortBy.T%2C+kotlin.collections.sortBy.R%29%29%29%2Fselector&quot;&gt;선택기&lt;/a&gt; 함수에서 반환 한 값의 자연 정렬 순서에 따라 배열의 요소를 내부에서 정렬합니다 .</target>
        </trans-unit>
        <trans-unit id="bf0d525765ea180a93133271ef548eaa25ac7135" translate="yes" xml:space="preserve">
          <source>Sorts elements in the array in-place descending according to natural sort order of the value returned by specified &lt;a href=&quot;../../kotlin.collections/sort-by-descending#kotlin.collections%24sortByDescending%28kotlin.Array%28%28kotlin.collections.sortByDescending.T%29%29%2C+kotlin.Function1%28%28kotlin.collections.sortByDescending.T%2C+kotlin.collections.sortByDescending.R%29%29%29%2Fselector&quot;&gt;selector&lt;/a&gt; function.</source>
          <target state="translated">지정된 &lt;a href=&quot;../../kotlin.collections/sort-by-descending#kotlin.collections%24sortByDescending%28kotlin.Array%28%28kotlin.collections.sortByDescending.T%29%29%2C+kotlin.Function1%28%28kotlin.collections.sortByDescending.T%2C+kotlin.collections.sortByDescending.R%29%29%29%2Fselector&quot;&gt;선택기&lt;/a&gt; 함수에서 반환 한 값의 자연 정렬 순서에 따라 배열 내 요소를 내림차순으로 정렬 합니다.</target>
        </trans-unit>
        <trans-unit id="fa27ec6d7341fe4cf77ef645e820323c332516f4" translate="yes" xml:space="preserve">
          <source>Sorts elements in the array in-place descending according to natural sort order of the value returned by specified &lt;a href=&quot;sort-by-descending#kotlin.collections%24sortByDescending%28kotlin.Array%28%28kotlin.collections.sortByDescending.T%29%29%2C+kotlin.Function1%28%28kotlin.collections.sortByDescending.T%2C+kotlin.collections.sortByDescending.R%29%29%29%2Fselector&quot;&gt;selector&lt;/a&gt; function.</source>
          <target state="translated">지정된 &lt;a href=&quot;sort-by-descending#kotlin.collections%24sortByDescending%28kotlin.Array%28%28kotlin.collections.sortByDescending.T%29%29%2C+kotlin.Function1%28%28kotlin.collections.sortByDescending.T%2C+kotlin.collections.sortByDescending.R%29%29%29%2Fselector&quot;&gt;선택기&lt;/a&gt; 함수에서 반환 한 값의 자연 정렬 순서에 따라 배열 내 요소를 내림차순으로 정렬 합니다.</target>
        </trans-unit>
        <trans-unit id="80685ba332e950eb83904d1f4115777122edba8d" translate="yes" xml:space="preserve">
          <source>Sorts elements in the array in-place descending according to their natural sort order.</source>
          <target state="translated">배열의 요소를 원래 정렬 순서에 따라 내림차순으로 정렬합니다.</target>
        </trans-unit>
        <trans-unit id="3fa32beeb828e11e44487567ba158313d97575ec" translate="yes" xml:space="preserve">
          <source>Sorts elements in the list in-place according to natural sort order of the value returned by specified &lt;a href=&quot;../sort-by#kotlin.collections%24sortBy%28kotlin.collections.MutableList%28%28kotlin.collections.sortBy.T%29%29%2C+kotlin.Function1%28%28kotlin.collections.sortBy.T%2C+kotlin.collections.sortBy.R%29%29%29%2Fselector&quot;&gt;selector&lt;/a&gt; function.</source>
          <target state="translated">지정된 &lt;a href=&quot;../sort-by#kotlin.collections%24sortBy%28kotlin.collections.MutableList%28%28kotlin.collections.sortBy.T%29%29%2C+kotlin.Function1%28%28kotlin.collections.sortBy.T%2C+kotlin.collections.sortBy.R%29%29%29%2Fselector&quot;&gt;선택기&lt;/a&gt; 함수에서 반환 한 값의 자연 정렬 순서에 따라 목록의 요소를 내부에서 정렬합니다 .</target>
        </trans-unit>
        <trans-unit id="a6a7a1bbadcee0fdc07b873d422460bcfcf63439" translate="yes" xml:space="preserve">
          <source>Sorts elements in the list in-place according to natural sort order of the value returned by specified &lt;a href=&quot;sort-by#kotlin.collections%24sortBy%28kotlin.collections.MutableList%28%28kotlin.collections.sortBy.T%29%29%2C+kotlin.Function1%28%28kotlin.collections.sortBy.T%2C+kotlin.collections.sortBy.R%29%29%29%2Fselector&quot;&gt;selector&lt;/a&gt; function.</source>
          <target state="translated">지정된 &lt;a href=&quot;sort-by#kotlin.collections%24sortBy%28kotlin.collections.MutableList%28%28kotlin.collections.sortBy.T%29%29%2C+kotlin.Function1%28%28kotlin.collections.sortBy.T%2C+kotlin.collections.sortBy.R%29%29%29%2Fselector&quot;&gt;선택기&lt;/a&gt; 함수에서 반환 한 값의 자연 정렬 순서에 따라 목록의 요소를 내부에서 정렬합니다 .</target>
        </trans-unit>
        <trans-unit id="016acc76aaf4b67ee4196bd0e6dd698c603f8a7f" translate="yes" xml:space="preserve">
          <source>Sorts elements in the list in-place according to the order specified with &lt;a href=&quot;../sort-with#kotlin.collections%24sortWith%28kotlin.collections.MutableList%28%28kotlin.collections.sortWith.T%29%29%2C+java.util.Comparator%28%28kotlin.collections.sortWith.T%29%29%29%2Fcomparator&quot;&gt;comparator&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;../sort-with#kotlin.collections%24sortWith%28kotlin.collections.MutableList%28%28kotlin.collections.sortWith.T%29%29%2C+java.util.Comparator%28%28kotlin.collections.sortWith.T%29%29%29%2Fcomparator&quot;&gt;comparator로&lt;/a&gt; 지정된 순서에 따라 목록의 요소를 적절하게 정렬합니다 .</target>
        </trans-unit>
        <trans-unit id="3bd3e4d90292d259ee01f75c87c74c625704e409" translate="yes" xml:space="preserve">
          <source>Sorts elements in the list in-place according to the order specified with &lt;a href=&quot;sort-with#kotlin.collections%24sortWith%28kotlin.collections.MutableList%28%28kotlin.collections.sortWith.T%29%29%2C+java.util.Comparator%28%28kotlin.collections.sortWith.T%29%29%29%2Fcomparator&quot;&gt;comparator&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;sort-with#kotlin.collections%24sortWith%28kotlin.collections.MutableList%28%28kotlin.collections.sortWith.T%29%29%2C+java.util.Comparator%28%28kotlin.collections.sortWith.T%29%29%29%2Fcomparator&quot;&gt;comparator로&lt;/a&gt; 지정된 순서에 따라 목록의 요소를 적절하게 정렬합니다 .</target>
        </trans-unit>
        <trans-unit id="a27a30d98060067ccc92da7c7b7abd9184f7e85d" translate="yes" xml:space="preserve">
          <source>Sorts elements in the list in-place according to the order specified with &lt;a href=&quot;sort-with#kotlin.collections%24sortWith%28kotlin.collections.MutableList%28%28kotlin.collections.sortWith.T%29%29%2C+kotlin.Comparator%28%28kotlin.collections.sortWith.T%29%29%29%2Fcomparator&quot;&gt;comparator&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;sort-with#kotlin.collections%24sortWith%28kotlin.collections.MutableList%28%28kotlin.collections.sortWith.T%29%29%2C+kotlin.Comparator%28%28kotlin.collections.sortWith.T%29%29%29%2Fcomparator&quot;&gt;comparator로&lt;/a&gt; 지정된 순서에 따라 목록의 요소를 적절하게 정렬합니다 .</target>
        </trans-unit>
        <trans-unit id="08c50e4dcb5f1e790b3908c92dfd681b51af4fd6" translate="yes" xml:space="preserve">
          <source>Sorts elements in the list in-place according to their natural sort order.</source>
          <target state="translated">자연스러운 정렬 순서에 따라 목록의 요소를 내부에서 정렬합니다.</target>
        </trans-unit>
        <trans-unit id="518d2bf6df28c01bc5ce865b286b09bcb6bd8f57" translate="yes" xml:space="preserve">
          <source>Sorts elements in the list in-place descending according to natural sort order of the value returned by specified &lt;a href=&quot;../sort-by-descending#kotlin.collections%24sortByDescending%28kotlin.collections.MutableList%28%28kotlin.collections.sortByDescending.T%29%29%2C+kotlin.Function1%28%28kotlin.collections.sortByDescending.T%2C+kotlin.collections.sortByDescending.R%29%29%29%2Fselector&quot;&gt;selector&lt;/a&gt; function.</source>
          <target state="translated">지정된 &lt;a href=&quot;../sort-by-descending#kotlin.collections%24sortByDescending%28kotlin.collections.MutableList%28%28kotlin.collections.sortByDescending.T%29%29%2C+kotlin.Function1%28%28kotlin.collections.sortByDescending.T%2C+kotlin.collections.sortByDescending.R%29%29%29%2Fselector&quot;&gt;선택기&lt;/a&gt; 함수가 반환 한 값의 자연 정렬 순서에 따라 목록의 요소를 내림차순으로 정렬 합니다.</target>
        </trans-unit>
        <trans-unit id="a90b16f5917d7428e33805718ad4902f7d836c1f" translate="yes" xml:space="preserve">
          <source>Sorts elements in the list in-place descending according to natural sort order of the value returned by specified &lt;a href=&quot;sort-by-descending#kotlin.collections%24sortByDescending%28kotlin.collections.MutableList%28%28kotlin.collections.sortByDescending.T%29%29%2C+kotlin.Function1%28%28kotlin.collections.sortByDescending.T%2C+kotlin.collections.sortByDescending.R%29%29%29%2Fselector&quot;&gt;selector&lt;/a&gt; function.</source>
          <target state="translated">지정된 &lt;a href=&quot;sort-by-descending#kotlin.collections%24sortByDescending%28kotlin.collections.MutableList%28%28kotlin.collections.sortByDescending.T%29%29%2C+kotlin.Function1%28%28kotlin.collections.sortByDescending.T%2C+kotlin.collections.sortByDescending.R%29%29%29%2Fselector&quot;&gt;선택기&lt;/a&gt; 함수가 반환 한 값의 자연 정렬 순서에 따라 목록의 요소를 내림차순으로 정렬 합니다.</target>
        </trans-unit>
        <trans-unit id="8d80c7611560449691efd4fd1165c90dfada93cf" translate="yes" xml:space="preserve">
          <source>Sorts elements in the list in-place descending according to their natural sort order.</source>
          <target state="translated">목록의 요소를 원래 정렬 순서에 따라 내림차순으로 정렬합니다.</target>
        </trans-unit>
        <trans-unit id="286952b1c23000c7e96cb265d1597ee4be034d09" translate="yes" xml:space="preserve">
          <source>Sorts the array in-place according to the natural order of its elements.</source>
          <target state="translated">요소의 자연 순서에 따라 적절한 위치에 배열을 정렬합니다.</target>
        </trans-unit>
        <trans-unit id="d8747f2faabc6c9d8057fc49ebee4065869ad5f8" translate="yes" xml:space="preserve">
          <source>Sorts the array in-place according to the order specified by the given &lt;a href=&quot;../../kotlin.collections/sort#kotlin.collections%24sort%28kotlin.Array%28%28kotlin.collections.sort.T%29%29%2C+kotlin.Function2%28%28kotlin.collections.sort.T%2C+%2C+kotlin.Int%29%29%29%2Fcomparison&quot;&gt;comparison&lt;/a&gt; function.</source>
          <target state="translated">주어진 &lt;a href=&quot;../../kotlin.collections/sort#kotlin.collections%24sort%28kotlin.Array%28%28kotlin.collections.sort.T%29%29%2C+kotlin.Function2%28%28kotlin.collections.sort.T%2C+%2C+kotlin.Int%29%29%29%2Fcomparison&quot;&gt;비교&lt;/a&gt; 함수에 의해 지정된 순서에 따라 배열을 적절하게 정렬합니다 .</target>
        </trans-unit>
        <trans-unit id="d1839449662e167b67669a9432e7e5b8cda47aee" translate="yes" xml:space="preserve">
          <source>Sorts the array in-place according to the order specified by the given &lt;a href=&quot;../../kotlin.collections/sort#kotlin.collections%24sort%28kotlin.ByteArray%2C+kotlin.Function2%28%28kotlin.Byte%2C+%2C+kotlin.Int%29%29%29%2Fcomparison&quot;&gt;comparison&lt;/a&gt; function.</source>
          <target state="translated">주어진 &lt;a href=&quot;../../kotlin.collections/sort#kotlin.collections%24sort%28kotlin.ByteArray%2C+kotlin.Function2%28%28kotlin.Byte%2C+%2C+kotlin.Int%29%29%29%2Fcomparison&quot;&gt;비교&lt;/a&gt; 함수에 의해 지정된 순서에 따라 배열을 적절하게 정렬합니다 .</target>
        </trans-unit>
        <trans-unit id="7d1ba7dd62c04c8e2b5a71936a2028b1fc09c095" translate="yes" xml:space="preserve">
          <source>Sorts the array in-place according to the order specified by the given &lt;a href=&quot;../../kotlin.collections/sort#kotlin.collections%24sort%28kotlin.CharArray%2C+kotlin.Function2%28%28kotlin.Char%2C+%2C+kotlin.Int%29%29%29%2Fcomparison&quot;&gt;comparison&lt;/a&gt; function.</source>
          <target state="translated">주어진 &lt;a href=&quot;../../kotlin.collections/sort#kotlin.collections%24sort%28kotlin.CharArray%2C+kotlin.Function2%28%28kotlin.Char%2C+%2C+kotlin.Int%29%29%29%2Fcomparison&quot;&gt;비교&lt;/a&gt; 함수에 의해 지정된 순서에 따라 배열을 적절하게 정렬합니다 .</target>
        </trans-unit>
        <trans-unit id="0768dfe6e47561708ff3dcc3e7544aaeba456f69" translate="yes" xml:space="preserve">
          <source>Sorts the array in-place according to the order specified by the given &lt;a href=&quot;../../kotlin.collections/sort#kotlin.collections%24sort%28kotlin.DoubleArray%2C+kotlin.Function2%28%28kotlin.Double%2C+%2C+kotlin.Int%29%29%29%2Fcomparison&quot;&gt;comparison&lt;/a&gt; function.</source>
          <target state="translated">주어진 &lt;a href=&quot;../../kotlin.collections/sort#kotlin.collections%24sort%28kotlin.DoubleArray%2C+kotlin.Function2%28%28kotlin.Double%2C+%2C+kotlin.Int%29%29%29%2Fcomparison&quot;&gt;비교&lt;/a&gt; 함수에 의해 지정된 순서에 따라 배열을 적절하게 정렬합니다 .</target>
        </trans-unit>
        <trans-unit id="c50febead4efd17d0d1e1a05393ce1b4d81939d6" translate="yes" xml:space="preserve">
          <source>Sorts the array in-place according to the order specified by the given &lt;a href=&quot;../../kotlin.collections/sort#kotlin.collections%24sort%28kotlin.FloatArray%2C+kotlin.Function2%28%28kotlin.Float%2C+%2C+kotlin.Int%29%29%29%2Fcomparison&quot;&gt;comparison&lt;/a&gt; function.</source>
          <target state="translated">주어진 &lt;a href=&quot;../../kotlin.collections/sort#kotlin.collections%24sort%28kotlin.FloatArray%2C+kotlin.Function2%28%28kotlin.Float%2C+%2C+kotlin.Int%29%29%29%2Fcomparison&quot;&gt;비교&lt;/a&gt; 함수에 의해 지정된 순서에 따라 배열을 적절하게 정렬합니다 .</target>
        </trans-unit>
        <trans-unit id="614045354e7f88dacd9beea842f592073eab2474" translate="yes" xml:space="preserve">
          <source>Sorts the array in-place according to the order specified by the given &lt;a href=&quot;../../kotlin.collections/sort#kotlin.collections%24sort%28kotlin.IntArray%2C+kotlin.Function2%28%28kotlin.Int%2C+%2C+%29%29%29%2Fcomparison&quot;&gt;comparison&lt;/a&gt; function.</source>
          <target state="translated">주어진 &lt;a href=&quot;../../kotlin.collections/sort#kotlin.collections%24sort%28kotlin.IntArray%2C+kotlin.Function2%28%28kotlin.Int%2C+%2C+%29%29%29%2Fcomparison&quot;&gt;비교&lt;/a&gt; 함수에 의해 지정된 순서에 따라 배열을 적절하게 정렬합니다 .</target>
        </trans-unit>
        <trans-unit id="92757cae315a994755e0f14f54db5ba3c6d0198c" translate="yes" xml:space="preserve">
          <source>Sorts the array in-place according to the order specified by the given &lt;a href=&quot;../../kotlin.collections/sort#kotlin.collections%24sort%28kotlin.LongArray%2C+kotlin.Function2%28%28kotlin.Long%2C+%2C+kotlin.Int%29%29%29%2Fcomparison&quot;&gt;comparison&lt;/a&gt; function.</source>
          <target state="translated">주어진 &lt;a href=&quot;../../kotlin.collections/sort#kotlin.collections%24sort%28kotlin.LongArray%2C+kotlin.Function2%28%28kotlin.Long%2C+%2C+kotlin.Int%29%29%29%2Fcomparison&quot;&gt;비교&lt;/a&gt; 함수에 의해 지정된 순서에 따라 배열을 적절하게 정렬합니다 .</target>
        </trans-unit>
        <trans-unit id="66732bd072b25ed9a6c879f731965bd5869d1d8e" translate="yes" xml:space="preserve">
          <source>Sorts the array in-place according to the order specified by the given &lt;a href=&quot;../../kotlin.collections/sort#kotlin.collections%24sort%28kotlin.ShortArray%2C+kotlin.Function2%28%28kotlin.Short%2C+%2C+kotlin.Int%29%29%29%2Fcomparison&quot;&gt;comparison&lt;/a&gt; function.</source>
          <target state="translated">주어진 &lt;a href=&quot;../../kotlin.collections/sort#kotlin.collections%24sort%28kotlin.ShortArray%2C+kotlin.Function2%28%28kotlin.Short%2C+%2C+kotlin.Int%29%29%29%2Fcomparison&quot;&gt;비교&lt;/a&gt; 함수에 의해 지정된 순서에 따라 배열을 적절하게 정렬합니다 .</target>
        </trans-unit>
        <trans-unit id="026d2b0c0155084b25c8a6103dc14e9f42617ceb" translate="yes" xml:space="preserve">
          <source>Sorts the array in-place according to the order specified by the given &lt;a href=&quot;../../kotlin.collections/sort-with#kotlin.collections%24sortWith%28kotlin.Array%28%28kotlin.collections.sortWith.T%29%29%2C+java.util.Comparator%28%28kotlin.collections.sortWith.T%29%29%29%2Fcomparator&quot;&gt;comparator&lt;/a&gt;.</source>
          <target state="translated">지정된 &lt;a href=&quot;../../kotlin.collections/sort-with#kotlin.collections%24sortWith%28kotlin.Array%28%28kotlin.collections.sortWith.T%29%29%2C+java.util.Comparator%28%28kotlin.collections.sortWith.T%29%29%29%2Fcomparator&quot;&gt;comparator에&lt;/a&gt; 의해 지정된 순서에 따라 적절한 위치에 배열을 정렬합니다 .</target>
        </trans-unit>
        <trans-unit id="6ceaa28ff8b5e20a64c1dd76210809e53340579a" translate="yes" xml:space="preserve">
          <source>Sorts the array in-place according to the order specified by the given &lt;a href=&quot;sort#kotlin.collections%24sort%28kotlin.Array%28%28kotlin.collections.sort.T%29%29%2C+kotlin.Function2%28%28kotlin.collections.sort.T%2C+%2C+kotlin.Int%29%29%29%2Fcomparison&quot;&gt;comparison&lt;/a&gt; function.</source>
          <target state="translated">주어진 &lt;a href=&quot;sort#kotlin.collections%24sort%28kotlin.Array%28%28kotlin.collections.sort.T%29%29%2C+kotlin.Function2%28%28kotlin.collections.sort.T%2C+%2C+kotlin.Int%29%29%29%2Fcomparison&quot;&gt;비교&lt;/a&gt; 함수에 의해 지정된 순서에 따라 배열을 적절하게 정렬합니다 .</target>
        </trans-unit>
        <trans-unit id="dbb39b6e7209d703010d1dea803d9e9f184dfb3a" translate="yes" xml:space="preserve">
          <source>Sorts the array in-place according to the order specified by the given &lt;a href=&quot;sort#kotlin.collections%24sort%28kotlin.ByteArray%2C+kotlin.Function2%28%28kotlin.Byte%2C+%2C+kotlin.Int%29%29%29%2Fcomparison&quot;&gt;comparison&lt;/a&gt; function.</source>
          <target state="translated">주어진 &lt;a href=&quot;sort#kotlin.collections%24sort%28kotlin.ByteArray%2C+kotlin.Function2%28%28kotlin.Byte%2C+%2C+kotlin.Int%29%29%29%2Fcomparison&quot;&gt;비교&lt;/a&gt; 함수에 의해 지정된 순서에 따라 배열을 적절하게 정렬합니다 .</target>
        </trans-unit>
        <trans-unit id="0fa5aed9839230cbb9bbcaa97445de61b613d5ee" translate="yes" xml:space="preserve">
          <source>Sorts the array in-place according to the order specified by the given &lt;a href=&quot;sort-with#kotlin.collections%24sortWith%28kotlin.Array%28%28kotlin.collections.sortWith.T%29%29%2C+java.util.Comparator%28%28kotlin.collections.sortWith.T%29%29%29%2Fcomparator&quot;&gt;comparator&lt;/a&gt;.</source>
          <target state="translated">지정된 &lt;a href=&quot;sort-with#kotlin.collections%24sortWith%28kotlin.Array%28%28kotlin.collections.sortWith.T%29%29%2C+java.util.Comparator%28%28kotlin.collections.sortWith.T%29%29%29%2Fcomparator&quot;&gt;comparator에&lt;/a&gt; 의해 지정된 순서에 따라 적절한 위치에 배열을 정렬합니다 .</target>
        </trans-unit>
        <trans-unit id="ae101b411aaa730dbbdac995beae34b884882ebe" translate="yes" xml:space="preserve">
          <source>Sorts the array in-place according to the order specified by the given &lt;a href=&quot;sort-with#kotlin.collections%24sortWith%28kotlin.Array%28%28kotlin.collections.sortWith.T%29%29%2C+kotlin.Comparator%28%28kotlin.collections.sortWith.T%29%29%29%2Fcomparator&quot;&gt;comparator&lt;/a&gt;.</source>
          <target state="translated">지정된 &lt;a href=&quot;sort-with#kotlin.collections%24sortWith%28kotlin.Array%28%28kotlin.collections.sortWith.T%29%29%2C+kotlin.Comparator%28%28kotlin.collections.sortWith.T%29%29%29%2Fcomparator&quot;&gt;comparator에&lt;/a&gt; 의해 지정된 순서에 따라 적절한 위치에 배열을 정렬합니다 .</target>
        </trans-unit>
        <trans-unit id="4770f48b5aef319d4b83ff34a0f71504fb9289b9" translate="yes" xml:space="preserve">
          <source>Sorts the array in-place.</source>
          <target state="translated">배열을 제자리에 정렬합니다.</target>
        </trans-unit>
        <trans-unit id="7ca4493ee7745c260d2545e5a7bcb290392c92d7" translate="yes" xml:space="preserve">
          <source>Source and binary compatibility may have different modes for the same component, e.g. the source language can reach full stability before the binary format stabilizes, or vice versa.</source>
          <target state="translated">소스 및 이진 호환성은 동일한 구성 요소에 대해 서로 다른 모드를 가질 수 있습니다. 예를 들어, 소스 언어는 이진 형식이 안정화되기 전에 전체 안정성에 도달하거나 그 반대도 가능합니다.</target>
        </trans-unit>
        <trans-unit id="2dcfc2bd4a05ff58d81210efcb67bf27a9d1018d" translate="yes" xml:space="preserve">
          <source>Source code organization</source>
          <target state="translated">소스 코드 조직</target>
        </trans-unit>
        <trans-unit id="91b779a28949d8daf60f28816366c445cff3b975" translate="yes" xml:space="preserve">
          <source>Source file names</source>
          <target state="translated">소스 파일 이름</target>
        </trans-unit>
        <trans-unit id="b8b646a7bd4b1ccfe7716e24991769415bb7ad29" translate="yes" xml:space="preserve">
          <source>Source file organization</source>
          <target state="translated">소스 파일 구성</target>
        </trans-unit>
        <trans-unit id="ba5b3110bc5e4b2e8ea36f406acb0d11147c336c" translate="yes" xml:space="preserve">
          <source>Source management</source>
          <target state="translated">소스 관리</target>
        </trans-unit>
        <trans-unit id="83330f3a77279d034f4be00739a614f19c8cd41b" translate="yes" xml:space="preserve">
          <source>Source management in the &lt;code&gt;kotlin.platform.native&lt;/code&gt; plugin is uniform with other Kotlin plugins and is based on source sets. A source set is a group of Kotlin/Native source which may contain both common and platform-specific code. The plugin provides a top-level script block &lt;code&gt;sourceSets&lt;/code&gt; allowing you to configure source sets. Also it creates the default source sets &lt;code&gt;main&lt;/code&gt; and &lt;code&gt;test&lt;/code&gt; (for production and test code respectively).</source>
          <target state="translated">&lt;code&gt;kotlin.platform.native&lt;/code&gt; 플러그인의 소스 관리는 다른 Kotlin 플러그인과 동일하며 소스 세트를 기반으로합니다. 소스 세트는 공통 코드와 플랫폼 별 코드를 모두 포함 할 수있는 Kotlin / Native 소스 그룹입니다. 플러그인은 소스 세트를 구성 할 수있는 최상위 스크립트 블록 &lt;code&gt;sourceSets&lt;/code&gt; 제공 합니다. 또한 기본 소스 세트 &lt;code&gt;main&lt;/code&gt; 및 &lt;code&gt;test&lt;/code&gt; (각각 프로덕션 및 테스트 코드 용)를 작성합니다.</target>
        </trans-unit>
        <trans-unit id="708a466fe6dad98c570f231d1548d606e08ba67c" translate="yes" xml:space="preserve">
          <source>Source sets can now be shared between an arbitrary subset of platforms (for example, in a module that targets JS, Android and iOS, you can have a source set that is shared only between Android and iOS).</source>
          <target state="translated">소스 세트는 이제 임의 플랫폼 하위 세트간에 공유 할 수 있습니다 (예 : JS, Android 및 iOS를 대상으로하는 모듈에서는 Android와 iOS간에 만 공유되는 소스 세트를 가질 수 있음).</target>
        </trans-unit>
        <trans-unit id="2feb63b3ff19c42a8edc6ffc039220ef18a5c33f" translate="yes" xml:space="preserve">
          <source>Source: source-incompatible change stops code that used to compile fine (without errors or warnings) from compiling anymore</source>
          <target state="translated">출처 : 소스 비 호환 변경으로 더 이상 오류나 경고없이 컴파일하는 데 사용한 코드가 더 이상 컴파일되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="44f1fc4c183f95acabbc53da2abac4d4f1206e1e" translate="yes" xml:space="preserve">
          <source>Special Cases:</source>
          <target state="translated">특수한 상황들:</target>
        </trans-unit>
        <trans-unit id="3e47d59ad303a035e3cd65578d432eefaa1b80ed" translate="yes" xml:space="preserve">
          <source>Special Identifiers</source>
          <target state="translated">특수 식별자</target>
        </trans-unit>
        <trans-unit id="da9712bd56acfa78d3913a233d114cc9c2158cd7" translate="yes" xml:space="preserve">
          <source>Special case:</source>
          <target state="translated">특별한 상황:</target>
        </trans-unit>
        <trans-unit id="56064f3962c04c365c47471ff7513622d3ab0964" translate="yes" xml:space="preserve">
          <source>Special cases:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c50a4829b036375e75f919f98b4f3fb6147ea678" translate="yes" xml:space="preserve">
          <source>Special cases: - &lt;code&gt;acos(x)&lt;/code&gt; is &lt;code&gt;NaN&lt;/code&gt;, when &lt;code&gt;abs(x) &amp;gt; 1&lt;/code&gt; or x is &lt;code&gt;NaN&lt;/code&gt;</source>
          <target state="translated">특별한 경우 : - &lt;code&gt;acos(x)&lt;/code&gt; 있다 &lt;code&gt;NaN&lt;/code&gt; 의 , &lt;code&gt;abs(x) &amp;gt; 1&lt;/code&gt; 또는 x가 &lt;code&gt;NaN&lt;/code&gt; 의</target>
        </trans-unit>
        <trans-unit id="87ab084bbfabe196612e1b63be02ed62abd6f7a4" translate="yes" xml:space="preserve">
          <source>Special cases: - &lt;code&gt;asin(x)&lt;/code&gt; is &lt;code&gt;NaN&lt;/code&gt;, when &lt;code&gt;abs(x) &amp;gt; 1&lt;/code&gt; or x is &lt;code&gt;NaN&lt;/code&gt;</source>
          <target state="translated">특별한 경우 : - &lt;code&gt;asin(x)&lt;/code&gt; 이다 &lt;code&gt;NaN&lt;/code&gt; 의 경우, &lt;code&gt;abs(x) &amp;gt; 1&lt;/code&gt; 또는 x가 &lt;code&gt;NaN&lt;/code&gt; 의</target>
        </trans-unit>
        <trans-unit id="80224f054ccac92a6dba14551f00788e44fb6cea" translate="yes" xml:space="preserve">
          <source>Special cases: - &lt;code&gt;x.IEEErem(y)&lt;/code&gt; is &lt;code&gt;NaN&lt;/code&gt;, when &lt;code&gt;x&lt;/code&gt; is &lt;code&gt;NaN&lt;/code&gt; or &lt;code&gt;y&lt;/code&gt; is &lt;code&gt;NaN&lt;/code&gt; or &lt;code&gt;x&lt;/code&gt; is &lt;code&gt;+Inf|-Inf&lt;/code&gt; or &lt;code&gt;y&lt;/code&gt; is zero. - &lt;code&gt;x.IEEErem(y) == x&lt;/code&gt; when &lt;code&gt;x&lt;/code&gt; is finite and &lt;code&gt;y&lt;/code&gt; is infinite.</source>
          <target state="translated">특수한 경우 : &lt;code&gt;x&lt;/code&gt; 가 &lt;code&gt;NaN&lt;/code&gt; 이거나 &lt;code&gt;y&lt;/code&gt; 가 &lt;code&gt;NaN&lt;/code&gt; 이거나 &lt;code&gt;x&lt;/code&gt; 가 &lt;code&gt;+Inf|-Inf&lt;/code&gt; 이거나 &lt;code&gt;y&lt;/code&gt; 가 0 일 때 &lt;code&gt;x.IEEErem(y)&lt;/code&gt; 는 &lt;code&gt;NaN&lt;/code&gt; 입니다. - &lt;code&gt;x.IEEErem(y) == x&lt;/code&gt; 때 &lt;code&gt;x&lt;/code&gt; 유한이고 &lt;code&gt;y&lt;/code&gt; 무한하다.</target>
        </trans-unit>
        <trans-unit id="396f015dcc0a4c9a33dfce58b73cb0338669c047" translate="yes" xml:space="preserve">
          <source>Specialized classes</source>
          <target state="translated">전문화 된 수업</target>
        </trans-unit>
        <trans-unit id="80214f6fe7568d1fe2eee4a6a25be91492189547" translate="yes" xml:space="preserve">
          <source>Specific return type. The return type moves away from the actual data that we need and instead returns a new type &lt;code&gt;Promise&lt;/code&gt; which has to be introspected.</source>
          <target state="translated">특정 반품 유형 반환 유형은 필요한 실제 데이터에서 멀어지고 대신 검사해야 할 새 유형 &lt;code&gt;Promise&lt;/code&gt; 를 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="10be766e1422f005154bcf107bfdb65683d40144" translate="yes" xml:space="preserve">
          <source>Specifies a code fragment that can be used to replace a deprecated function, property or class. Tools such as IDEs can automatically apply the replacements specified through this annotation.</source>
          <target state="translated">더 이상 사용되지 않는 함수, 속성 또는 클래스를 바꾸는 데 사용할 수있는 코드 조각을 지정합니다. IDE와 같은 도구는이 주석을 통해 지정된 대체를 자동으로 적용 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f6bde6daa244f6b004cb3386a82fc9dfe647f4b6" translate="yes" xml:space="preserve">
          <source>Specifies how a &lt;a href=&quot;-lazy/index&quot;&gt;Lazy&lt;/a&gt; instance synchronizes initialization among multiple threads.</source>
          <target state="translated">&lt;a href=&quot;-lazy/index&quot;&gt;지연&lt;/a&gt; 인스턴스가 여러 스레드간에 초기화를 동기화 하는 방법을 지정합니다 .</target>
        </trans-unit>
        <trans-unit id="7a34891c3f008a377113c6728bb426ade078566a" translate="yes" xml:space="preserve">
          <source>Specifies how a &lt;a href=&quot;../-lazy/index&quot;&gt;Lazy&lt;/a&gt; instance synchronizes initialization among multiple threads.</source>
          <target state="translated">&lt;a href=&quot;../-lazy/index&quot;&gt;지연&lt;/a&gt; 인스턴스가 여러 스레드간에 초기화를 동기화 하는 방법을 지정합니다 .</target>
        </trans-unit>
        <trans-unit id="c4f0b89f9b2bcd589a457d848fb7af8fa36d078a" translate="yes" xml:space="preserve">
          <source>Specifies how many times a function invokes its function parameter in place.</source>
          <target state="translated">함수가 함수 매개 변수를 호출하는 횟수를 지정합니다.</target>
        </trans-unit>
        <trans-unit id="e23535d6faf71a1a72da5d8b0c47cb4ff5c68bd4" translate="yes" xml:space="preserve">
          <source>Specifies how the deprecated element usages are reported in code. See the &lt;a href=&quot;../-deprecation-level/index#kotlin.DeprecationLevel&quot;&gt;DeprecationLevel&lt;/a&gt; enum for the possible values.</source>
          <target state="translated">더 이상 사용되지 않는 요소 사용법이 코드로보고되는 방식을 지정합니다. 가능한 값 은 &lt;a href=&quot;../-deprecation-level/index#kotlin.DeprecationLevel&quot;&gt;DeprecationLevel&lt;/a&gt; 열거를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="1273973520fb373ff0923e2955fc0a8aa51d89ca" translate="yes" xml:space="preserve">
          <source>Specifies that a JVM default method should be generated for non-abstract Kotlin interface member.</source>
          <target state="translated">비추 상 Kotlin 인터페이스 멤버에 대해 JVM 기본 메소드를 생성하도록 지정합니다.</target>
        </trans-unit>
        <trans-unit id="1b608a06a3ef3e2f1977895180f9d7cd6dab326f" translate="yes" xml:space="preserve">
          <source>Specifies that a warning should be reported on incorrect usages of this experimental API.</source>
          <target state="translated">이 실험 API의 잘못된 사용법에 대해 경고가보고되도록 지정합니다.</target>
        </trans-unit>
        <trans-unit id="9ad2d2ca6b5a6cc26f2cb4f5defb3fa422218068" translate="yes" xml:space="preserve">
          <source>Specifies that an additional static method needs to be generated from this element if it's a function. If this element is a property, additional static getter/setter methods should be generated.</source>
          <target state="translated">이 요소가 함수 인 경우 추가 정적 메소드를 생성해야 함을 지정합니다. 이 요소가 속성이면 추가 정적 getter / setter 메서드가 생성되어야합니다.</target>
        </trans-unit>
        <trans-unit id="41dca1654db714e11bbcbe786e5e6118d5a8481b" translate="yes" xml:space="preserve">
          <source>Specifies that an error should be reported on incorrect usages of this experimental API.</source>
          <target state="translated">이 실험용 API를 잘못 사용하면 오류가보고되도록 지정합니다.</target>
        </trans-unit>
        <trans-unit id="b8fb6a1c5d45c4db1467991d5c234e6ab817a1e3" translate="yes" xml:space="preserve">
          <source>Specifies that the function parameter &lt;a href=&quot;calls-in-place#kotlin.contracts.ContractBuilder%24callsInPlace%28kotlin.Function%28%28kotlin.contracts.ContractBuilder.callsInPlace.R%29%29%2C+kotlin.contracts.InvocationKind%29%2Flambda&quot;&gt;lambda&lt;/a&gt; is invoked in place.</source>
          <target state="translated">함수 매개 변수 &lt;a href=&quot;calls-in-place#kotlin.contracts.ContractBuilder%24callsInPlace%28kotlin.Function%28%28kotlin.contracts.ContractBuilder.callsInPlace.R%29%29%2C+kotlin.contracts.InvocationKind%29%2Flambda&quot;&gt;lambda&lt;/a&gt; 가 호출 되도록 지정합니다 .</target>
        </trans-unit>
        <trans-unit id="9dbed9849f2069fc0d07922505e1643863d85c42" translate="yes" xml:space="preserve">
          <source>Specifies that this effect, when observed, guarantees &lt;a href=&quot;implies#kotlin.contracts.SimpleEffect%24implies%28kotlin.Boolean%29%2FbooleanExpression&quot;&gt;booleanExpression&lt;/a&gt; to be true.</source>
          <target state="translated">이 효과가 관찰되면 &lt;a href=&quot;implies#kotlin.contracts.SimpleEffect%24implies%28kotlin.Boolean%29%2FbooleanExpression&quot;&gt;booleanExpression&lt;/a&gt; 이 true가되도록 지정합니다.</target>
        </trans-unit>
        <trans-unit id="d54eb0bc950c7ef72bd2aa203d75cecf873009a2" translate="yes" xml:space="preserve">
          <source>Specifies the author of the element being documented.</source>
          <target state="translated">문서화되는 요소의 작성자를 지정합니다.</target>
        </trans-unit>
        <trans-unit id="7439a2699ea30bac21819e499a0c348bf4db5a53" translate="yes" xml:space="preserve">
          <source>Specifies the contract of a function.</source>
          <target state="translated">함수 계약을 지정합니다.</target>
        </trans-unit>
        <trans-unit id="668aabdaa85311d5948645d77876f75a16affd74" translate="yes" xml:space="preserve">
          <source>Specifies the first version of Kotlin where a declaration has appeared. Using the declaration and specifying an older API version (via the &lt;code&gt;-api-version&lt;/code&gt; command line option) will result in an error.</source>
          <target state="translated">선언이 나타난 Kotlin의 첫 번째 버전을 지정합니다. 선언을 사용하고 &lt;code&gt;-api-version&lt;/code&gt; 명령 행 옵션을 통해 이전 API 버전을 지정 하면 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="2e19852d4c7f63b915b4f0748c65b97fb769383f" translate="yes" xml:space="preserve">
          <source>Specifies the name for the Java class or method which is generated from this element.</source>
          <target state="translated">이 요소에서 생성 된 Java 클래스 또는 메소드의 이름을 지정합니다.</target>
        </trans-unit>
        <trans-unit id="a687435bfccbdd96f3fa9d60bae94e072182829e" translate="yes" xml:space="preserve">
          <source>Specifies the version of the software in which the element being documented was introduced.</source>
          <target state="translated">문서화되는 요소가 도입 된 소프트웨어의 버전을 지정합니다.</target>
        </trans-unit>
        <trans-unit id="2ecfae74b60c500bf98eff24ffe25a09c3d987a3" translate="yes" xml:space="preserve">
          <source>Specifying compiler options</source>
          <target state="translated">컴파일러 옵션 지정</target>
        </trans-unit>
        <trans-unit id="b480fdbc738e688b220525f44187624b8dee5660" translate="yes" xml:space="preserve">
          <source>Specifying the type explicitly</source>
          <target state="translated">유형을 명시 적으로 지정</target>
        </trans-unit>
        <trans-unit id="746ebe7b30c04844a0a6acb84ceeeab7bfb3222b" translate="yes" xml:space="preserve">
          <source>Splits the &lt;a href=&quot;split#kotlin.text.Regex%24split%28kotlin.CharSequence%2C+kotlin.Int%29%2Finput&quot;&gt;input&lt;/a&gt; CharSequence around matches of this regular expression.</source>
          <target state="translated">이 정규 표현식과 일치 하는 &lt;a href=&quot;split#kotlin.text.Regex%24split%28kotlin.CharSequence%2C+kotlin.Int%29%2Finput&quot;&gt;입력&lt;/a&gt; CharSequence를 분할합니다 .</target>
        </trans-unit>
        <trans-unit id="889fa2d0788d1531abe076f806167d469446a8f8" translate="yes" xml:space="preserve">
          <source>Splits the original array into pair of lists, where &lt;em&gt;first&lt;/em&gt; list contains elements for which &lt;a href=&quot;../../kotlin.collections/partition#kotlin.collections%24partition%28kotlin.Array%28%28kotlin.collections.partition.T%29%29%2C+kotlin.Function1%28%28kotlin.collections.partition.T%2C+kotlin.Boolean%29%29%29%2Fpredicate&quot;&gt;predicate&lt;/a&gt; yielded &lt;code&gt;true&lt;/code&gt;, while &lt;em&gt;second&lt;/em&gt; list contains elements for which &lt;a href=&quot;../../kotlin.collections/partition#kotlin.collections%24partition%28kotlin.Array%28%28kotlin.collections.partition.T%29%29%2C+kotlin.Function1%28%28kotlin.collections.partition.T%2C+kotlin.Boolean%29%29%29%2Fpredicate&quot;&gt;predicate&lt;/a&gt; yielded &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">원래 배열을 목록 쌍으로 분할합니다. 여기서 &lt;em&gt;첫 번째&lt;/em&gt; 목록에는 &lt;a href=&quot;../../kotlin.collections/partition#kotlin.collections%24partition%28kotlin.Array%28%28kotlin.collections.partition.T%29%29%2C+kotlin.Function1%28%28kotlin.collections.partition.T%2C+kotlin.Boolean%29%29%29%2Fpredicate&quot;&gt;술어가 &lt;/a&gt; &lt;code&gt;true&lt;/code&gt; 를 생성 한 요소가 포함 되고 &lt;em&gt;두 번째&lt;/em&gt; 목록에는 &lt;a href=&quot;../../kotlin.collections/partition#kotlin.collections%24partition%28kotlin.Array%28%28kotlin.collections.partition.T%29%29%2C+kotlin.Function1%28%28kotlin.collections.partition.T%2C+kotlin.Boolean%29%29%29%2Fpredicate&quot;&gt;술어가 &lt;/a&gt; &lt;code&gt;false&lt;/code&gt; 를 산출 한 요소가 포함 됩니다.</target>
        </trans-unit>
        <trans-unit id="f8c682ed4a61277f6e6fef2ed839395919a64a6f" translate="yes" xml:space="preserve">
          <source>Splits the original array into pair of lists, where &lt;em&gt;first&lt;/em&gt; list contains elements for which &lt;a href=&quot;../../kotlin.collections/partition#kotlin.collections%24partition%28kotlin.BooleanArray%2C+kotlin.Function1%28%28kotlin.Boolean%2C+%29%29%29%2Fpredicate&quot;&gt;predicate&lt;/a&gt; yielded &lt;code&gt;true&lt;/code&gt;, while &lt;em&gt;second&lt;/em&gt; list contains elements for which &lt;a href=&quot;../../kotlin.collections/partition#kotlin.collections%24partition%28kotlin.BooleanArray%2C+kotlin.Function1%28%28kotlin.Boolean%2C+%29%29%29%2Fpredicate&quot;&gt;predicate&lt;/a&gt; yielded &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">원래 배열을 목록 쌍으로 분할합니다. 여기서 &lt;em&gt;첫 번째&lt;/em&gt; 목록에는 &lt;a href=&quot;../../kotlin.collections/partition#kotlin.collections%24partition%28kotlin.BooleanArray%2C+kotlin.Function1%28%28kotlin.Boolean%2C+%29%29%29%2Fpredicate&quot;&gt;술어가 &lt;/a&gt; &lt;code&gt;true&lt;/code&gt; 를 생성 한 요소가 포함 되고 &lt;em&gt;두 번째&lt;/em&gt; 목록에는 &lt;a href=&quot;../../kotlin.collections/partition#kotlin.collections%24partition%28kotlin.BooleanArray%2C+kotlin.Function1%28%28kotlin.Boolean%2C+%29%29%29%2Fpredicate&quot;&gt;술어가 &lt;/a&gt; &lt;code&gt;false&lt;/code&gt; 를 산출 한 요소가 포함 됩니다.</target>
        </trans-unit>
        <trans-unit id="6057dd4ee229b6bb485f8071e494d337b4c9c199" translate="yes" xml:space="preserve">
          <source>Splits the original array into pair of lists, where &lt;em&gt;first&lt;/em&gt; list contains elements for which &lt;a href=&quot;../../kotlin.collections/partition#kotlin.collections%24partition%28kotlin.ByteArray%2C+kotlin.Function1%28%28kotlin.Byte%2C+kotlin.Boolean%29%29%29%2Fpredicate&quot;&gt;predicate&lt;/a&gt; yielded &lt;code&gt;true&lt;/code&gt;, while &lt;em&gt;second&lt;/em&gt; list contains elements for which &lt;a href=&quot;../../kotlin.collections/partition#kotlin.collections%24partition%28kotlin.ByteArray%2C+kotlin.Function1%28%28kotlin.Byte%2C+kotlin.Boolean%29%29%29%2Fpredicate&quot;&gt;predicate&lt;/a&gt; yielded &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">원래 배열을 목록 쌍으로 분할합니다. 여기서 &lt;em&gt;첫 번째&lt;/em&gt; 목록에는 &lt;a href=&quot;../../kotlin.collections/partition#kotlin.collections%24partition%28kotlin.ByteArray%2C+kotlin.Function1%28%28kotlin.Byte%2C+kotlin.Boolean%29%29%29%2Fpredicate&quot;&gt;술어가 &lt;/a&gt; &lt;code&gt;true&lt;/code&gt; 를 생성 한 요소가 포함 되고 &lt;em&gt;두 번째&lt;/em&gt; 목록에는 &lt;a href=&quot;../../kotlin.collections/partition#kotlin.collections%24partition%28kotlin.ByteArray%2C+kotlin.Function1%28%28kotlin.Byte%2C+kotlin.Boolean%29%29%29%2Fpredicate&quot;&gt;술어가 &lt;/a&gt; &lt;code&gt;false&lt;/code&gt; 를 산출 한 요소가 포함 됩니다.</target>
        </trans-unit>
        <trans-unit id="36e78b5dbb516213087cd4a2cc82f8f5c89f375e" translate="yes" xml:space="preserve">
          <source>Splits the original array into pair of lists, where &lt;em&gt;first&lt;/em&gt; list contains elements for which &lt;a href=&quot;../../kotlin.collections/partition#kotlin.collections%24partition%28kotlin.CharArray%2C+kotlin.Function1%28%28kotlin.Char%2C+kotlin.Boolean%29%29%29%2Fpredicate&quot;&gt;predicate&lt;/a&gt; yielded &lt;code&gt;true&lt;/code&gt;, while &lt;em&gt;second&lt;/em&gt; list contains elements for which &lt;a href=&quot;../../kotlin.collections/partition#kotlin.collections%24partition%28kotlin.CharArray%2C+kotlin.Function1%28%28kotlin.Char%2C+kotlin.Boolean%29%29%29%2Fpredicate&quot;&gt;predicate&lt;/a&gt; yielded &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">원래 배열을 목록 쌍으로 분할합니다. 여기서 &lt;em&gt;첫 번째&lt;/em&gt; 목록에는 &lt;a href=&quot;../../kotlin.collections/partition#kotlin.collections%24partition%28kotlin.CharArray%2C+kotlin.Function1%28%28kotlin.Char%2C+kotlin.Boolean%29%29%29%2Fpredicate&quot;&gt;술어가 &lt;/a&gt; &lt;code&gt;true&lt;/code&gt; 를 생성 한 요소가 포함 되고 &lt;em&gt;두 번째&lt;/em&gt; 목록에는 &lt;a href=&quot;../../kotlin.collections/partition#kotlin.collections%24partition%28kotlin.CharArray%2C+kotlin.Function1%28%28kotlin.Char%2C+kotlin.Boolean%29%29%29%2Fpredicate&quot;&gt;술어가 &lt;/a&gt; &lt;code&gt;false&lt;/code&gt; 를 산출 한 요소가 포함 됩니다.</target>
        </trans-unit>
        <trans-unit id="188c266d70ce2d849ff0de3b5932cdf9da587e53" translate="yes" xml:space="preserve">
          <source>Splits the original array into pair of lists, where &lt;em&gt;first&lt;/em&gt; list contains elements for which &lt;a href=&quot;../../kotlin.collections/partition#kotlin.collections%24partition%28kotlin.DoubleArray%2C+kotlin.Function1%28%28kotlin.Double%2C+kotlin.Boolean%29%29%29%2Fpredicate&quot;&gt;predicate&lt;/a&gt; yielded &lt;code&gt;true&lt;/code&gt;, while &lt;em&gt;second&lt;/em&gt; list contains elements for which &lt;a href=&quot;../../kotlin.collections/partition#kotlin.collections%24partition%28kotlin.DoubleArray%2C+kotlin.Function1%28%28kotlin.Double%2C+kotlin.Boolean%29%29%29%2Fpredicate&quot;&gt;predicate&lt;/a&gt; yielded &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">원래 배열을 목록 쌍으로 분할합니다. 여기서 &lt;em&gt;첫 번째&lt;/em&gt; 목록에는 &lt;a href=&quot;../../kotlin.collections/partition#kotlin.collections%24partition%28kotlin.DoubleArray%2C+kotlin.Function1%28%28kotlin.Double%2C+kotlin.Boolean%29%29%29%2Fpredicate&quot;&gt;술어가 &lt;/a&gt; &lt;code&gt;true&lt;/code&gt; 를 생성 한 요소가 포함 되고 &lt;em&gt;두 번째&lt;/em&gt; 목록에는 &lt;a href=&quot;../../kotlin.collections/partition#kotlin.collections%24partition%28kotlin.DoubleArray%2C+kotlin.Function1%28%28kotlin.Double%2C+kotlin.Boolean%29%29%29%2Fpredicate&quot;&gt;술어가 &lt;/a&gt; &lt;code&gt;false&lt;/code&gt; 를 산출 한 요소가 포함 됩니다.</target>
        </trans-unit>
        <trans-unit id="2ff97334e8cd4ed34e1a92b3b104f2b5bdaf4fbb" translate="yes" xml:space="preserve">
          <source>Splits the original array into pair of lists, where &lt;em&gt;first&lt;/em&gt; list contains elements for which &lt;a href=&quot;../../kotlin.collections/partition#kotlin.collections%24partition%28kotlin.FloatArray%2C+kotlin.Function1%28%28kotlin.Float%2C+kotlin.Boolean%29%29%29%2Fpredicate&quot;&gt;predicate&lt;/a&gt; yielded &lt;code&gt;true&lt;/code&gt;, while &lt;em&gt;second&lt;/em&gt; list contains elements for which &lt;a href=&quot;../../kotlin.collections/partition#kotlin.collections%24partition%28kotlin.FloatArray%2C+kotlin.Function1%28%28kotlin.Float%2C+kotlin.Boolean%29%29%29%2Fpredicate&quot;&gt;predicate&lt;/a&gt; yielded &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">원래 배열을 목록 쌍으로 분할합니다. 여기서 &lt;em&gt;첫 번째&lt;/em&gt; 목록에는 &lt;a href=&quot;../../kotlin.collections/partition#kotlin.collections%24partition%28kotlin.FloatArray%2C+kotlin.Function1%28%28kotlin.Float%2C+kotlin.Boolean%29%29%29%2Fpredicate&quot;&gt;술어가 &lt;/a&gt; &lt;code&gt;true&lt;/code&gt; 를 생성 한 요소가 포함 되고 &lt;em&gt;두 번째&lt;/em&gt; 목록에는 &lt;a href=&quot;../../kotlin.collections/partition#kotlin.collections%24partition%28kotlin.FloatArray%2C+kotlin.Function1%28%28kotlin.Float%2C+kotlin.Boolean%29%29%29%2Fpredicate&quot;&gt;술어가 &lt;/a&gt; &lt;code&gt;false&lt;/code&gt; 를 산출 한 요소가 포함 됩니다.</target>
        </trans-unit>
        <trans-unit id="33204572ae494c8da3e3225aed2c1e38da7a21ec" translate="yes" xml:space="preserve">
          <source>Splits the original array into pair of lists, where &lt;em&gt;first&lt;/em&gt; list contains elements for which &lt;a href=&quot;../../kotlin.collections/partition#kotlin.collections%24partition%28kotlin.IntArray%2C+kotlin.Function1%28%28kotlin.Int%2C+kotlin.Boolean%29%29%29%2Fpredicate&quot;&gt;predicate&lt;/a&gt; yielded &lt;code&gt;true&lt;/code&gt;, while &lt;em&gt;second&lt;/em&gt; list contains elements for which &lt;a href=&quot;../../kotlin.collections/partition#kotlin.collections%24partition%28kotlin.IntArray%2C+kotlin.Function1%28%28kotlin.Int%2C+kotlin.Boolean%29%29%29%2Fpredicate&quot;&gt;predicate&lt;/a&gt; yielded &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">원래 배열을 목록 쌍으로 분할합니다. 여기서 &lt;em&gt;첫 번째&lt;/em&gt; 목록에는 &lt;a href=&quot;../../kotlin.collections/partition#kotlin.collections%24partition%28kotlin.IntArray%2C+kotlin.Function1%28%28kotlin.Int%2C+kotlin.Boolean%29%29%29%2Fpredicate&quot;&gt;술어가 &lt;/a&gt; &lt;code&gt;true&lt;/code&gt; 를 생성 한 요소가 포함 되고 &lt;em&gt;두 번째&lt;/em&gt; 목록에는 &lt;a href=&quot;../../kotlin.collections/partition#kotlin.collections%24partition%28kotlin.IntArray%2C+kotlin.Function1%28%28kotlin.Int%2C+kotlin.Boolean%29%29%29%2Fpredicate&quot;&gt;술어가 &lt;/a&gt; &lt;code&gt;false&lt;/code&gt; 를 산출 한 요소가 포함 됩니다.</target>
        </trans-unit>
        <trans-unit id="79b98ebd0576ac1d5b9a0ddfe5682da001dd4f39" translate="yes" xml:space="preserve">
          <source>Splits the original array into pair of lists, where &lt;em&gt;first&lt;/em&gt; list contains elements for which &lt;a href=&quot;../../kotlin.collections/partition#kotlin.collections%24partition%28kotlin.LongArray%2C+kotlin.Function1%28%28kotlin.Long%2C+kotlin.Boolean%29%29%29%2Fpredicate&quot;&gt;predicate&lt;/a&gt; yielded &lt;code&gt;true&lt;/code&gt;, while &lt;em&gt;second&lt;/em&gt; list contains elements for which &lt;a href=&quot;../../kotlin.collections/partition#kotlin.collections%24partition%28kotlin.LongArray%2C+kotlin.Function1%28%28kotlin.Long%2C+kotlin.Boolean%29%29%29%2Fpredicate&quot;&gt;predicate&lt;/a&gt; yielded &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">원래 배열을 목록 쌍으로 분할합니다. 여기서 &lt;em&gt;첫 번째&lt;/em&gt; 목록에는 &lt;a href=&quot;../../kotlin.collections/partition#kotlin.collections%24partition%28kotlin.LongArray%2C+kotlin.Function1%28%28kotlin.Long%2C+kotlin.Boolean%29%29%29%2Fpredicate&quot;&gt;술어가 &lt;/a&gt; &lt;code&gt;true&lt;/code&gt; 를 생성 한 요소가 포함 되고 &lt;em&gt;두 번째&lt;/em&gt; 목록에는 &lt;a href=&quot;../../kotlin.collections/partition#kotlin.collections%24partition%28kotlin.LongArray%2C+kotlin.Function1%28%28kotlin.Long%2C+kotlin.Boolean%29%29%29%2Fpredicate&quot;&gt;술어가 &lt;/a&gt; &lt;code&gt;false&lt;/code&gt; 를 산출 한 요소가 포함 됩니다.</target>
        </trans-unit>
        <trans-unit id="d84eb1d37eef2994f2317dd6d168249568c0d6e4" translate="yes" xml:space="preserve">
          <source>Splits the original array into pair of lists, where &lt;em&gt;first&lt;/em&gt; list contains elements for which &lt;a href=&quot;../../kotlin.collections/partition#kotlin.collections%24partition%28kotlin.ShortArray%2C+kotlin.Function1%28%28kotlin.Short%2C+kotlin.Boolean%29%29%29%2Fpredicate&quot;&gt;predicate&lt;/a&gt; yielded &lt;code&gt;true&lt;/code&gt;, while &lt;em&gt;second&lt;/em&gt; list contains elements for which &lt;a href=&quot;../../kotlin.collections/partition#kotlin.collections%24partition%28kotlin.ShortArray%2C+kotlin.Function1%28%28kotlin.Short%2C+kotlin.Boolean%29%29%29%2Fpredicate&quot;&gt;predicate&lt;/a&gt; yielded &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">원래 배열을 목록 쌍으로 분할합니다. 여기서 &lt;em&gt;첫 번째&lt;/em&gt; 목록에는 &lt;a href=&quot;../../kotlin.collections/partition#kotlin.collections%24partition%28kotlin.ShortArray%2C+kotlin.Function1%28%28kotlin.Short%2C+kotlin.Boolean%29%29%29%2Fpredicate&quot;&gt;술어가 &lt;/a&gt; &lt;code&gt;true&lt;/code&gt; 를 생성 한 요소가 포함 되고 &lt;em&gt;두 번째&lt;/em&gt; 목록에는 &lt;a href=&quot;../../kotlin.collections/partition#kotlin.collections%24partition%28kotlin.ShortArray%2C+kotlin.Function1%28%28kotlin.Short%2C+kotlin.Boolean%29%29%29%2Fpredicate&quot;&gt;술어가 &lt;/a&gt; &lt;code&gt;false&lt;/code&gt; 를 산출 한 요소가 포함 됩니다.</target>
        </trans-unit>
        <trans-unit id="b8083df548af87e3622d6abccfa8e78274a64c6f" translate="yes" xml:space="preserve">
          <source>Splits the original array into pair of lists, where &lt;em&gt;first&lt;/em&gt; list contains elements for which &lt;a href=&quot;partition#kotlin.collections%24partition%28kotlin.Array%28%28kotlin.collections.partition.T%29%29%2C+kotlin.Function1%28%28kotlin.collections.partition.T%2C+kotlin.Boolean%29%29%29%2Fpredicate&quot;&gt;predicate&lt;/a&gt; yielded &lt;code&gt;true&lt;/code&gt;, while &lt;em&gt;second&lt;/em&gt; list contains elements for which &lt;a href=&quot;partition#kotlin.collections%24partition%28kotlin.Array%28%28kotlin.collections.partition.T%29%29%2C+kotlin.Function1%28%28kotlin.collections.partition.T%2C+kotlin.Boolean%29%29%29%2Fpredicate&quot;&gt;predicate&lt;/a&gt; yielded &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">원래 배열을 목록 쌍으로 분할합니다. 여기서 &lt;em&gt;첫 번째&lt;/em&gt; 목록에는 &lt;a href=&quot;partition#kotlin.collections%24partition%28kotlin.Array%28%28kotlin.collections.partition.T%29%29%2C+kotlin.Function1%28%28kotlin.collections.partition.T%2C+kotlin.Boolean%29%29%29%2Fpredicate&quot;&gt;술어가 &lt;/a&gt; &lt;code&gt;true&lt;/code&gt; 를 생성 한 요소가 포함 되고 &lt;em&gt;두 번째&lt;/em&gt; 목록에는 &lt;a href=&quot;partition#kotlin.collections%24partition%28kotlin.Array%28%28kotlin.collections.partition.T%29%29%2C+kotlin.Function1%28%28kotlin.collections.partition.T%2C+kotlin.Boolean%29%29%29%2Fpredicate&quot;&gt;술어가 &lt;/a&gt; &lt;code&gt;false&lt;/code&gt; 를 산출 한 요소가 포함 됩니다.</target>
        </trans-unit>
        <trans-unit id="d546386d2e87332d743bd4386df842ed3abe71a8" translate="yes" xml:space="preserve">
          <source>Splits the original char sequence into pair of char sequences, where &lt;em&gt;first&lt;/em&gt; char sequence contains characters for which &lt;a href=&quot;../../kotlin.text/partition#kotlin.text%24partition%28kotlin.CharSequence%2C+kotlin.Function1%28%28kotlin.Char%2C+kotlin.Boolean%29%29%29%2Fpredicate&quot;&gt;predicate&lt;/a&gt; yielded &lt;code&gt;true&lt;/code&gt;, while &lt;em&gt;second&lt;/em&gt; char sequence contains characters for which &lt;a href=&quot;../../kotlin.text/partition#kotlin.text%24partition%28kotlin.CharSequence%2C+kotlin.Function1%28%28kotlin.Char%2C+kotlin.Boolean%29%29%29%2Fpredicate&quot;&gt;predicate&lt;/a&gt; yielded &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">원래 문자 시퀀스를 문자 시퀀스 쌍으로 분할합니다. 여기서 &lt;em&gt;첫 번째&lt;/em&gt; 문자 시퀀스에는 &lt;a href=&quot;../../kotlin.text/partition#kotlin.text%24partition%28kotlin.CharSequence%2C+kotlin.Function1%28%28kotlin.Char%2C+kotlin.Boolean%29%29%29%2Fpredicate&quot;&gt;술어가 &lt;/a&gt; &lt;code&gt;true&lt;/code&gt; 를 생성 하는 문자가 포함 되고 , &lt;em&gt;두 번째&lt;/em&gt; 문자 시퀀스에는 &lt;a href=&quot;../../kotlin.text/partition#kotlin.text%24partition%28kotlin.CharSequence%2C+kotlin.Function1%28%28kotlin.Char%2C+kotlin.Boolean%29%29%29%2Fpredicate&quot;&gt;술어가 &lt;/a&gt; &lt;code&gt;false&lt;/code&gt; 를 생성 하는 문자가 포함 됩니다.</target>
        </trans-unit>
        <trans-unit id="3f2108aa3476d1886c05784b517af0f46f65dcce" translate="yes" xml:space="preserve">
          <source>Splits the original char sequence into pair of char sequences, where &lt;em&gt;first&lt;/em&gt; char sequence contains characters for which &lt;a href=&quot;../partition#kotlin.text%24partition%28kotlin.CharSequence%2C+kotlin.Function1%28%28kotlin.Char%2C+kotlin.Boolean%29%29%29%2Fpredicate&quot;&gt;predicate&lt;/a&gt; yielded &lt;code&gt;true&lt;/code&gt;, while &lt;em&gt;second&lt;/em&gt; char sequence contains characters for which &lt;a href=&quot;../partition#kotlin.text%24partition%28kotlin.CharSequence%2C+kotlin.Function1%28%28kotlin.Char%2C+kotlin.Boolean%29%29%29%2Fpredicate&quot;&gt;predicate&lt;/a&gt; yielded &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">원래 문자 시퀀스를 문자 시퀀스 쌍으로 분할합니다. 여기서 &lt;em&gt;첫 번째&lt;/em&gt; 문자 시퀀스에는 &lt;a href=&quot;../partition#kotlin.text%24partition%28kotlin.CharSequence%2C+kotlin.Function1%28%28kotlin.Char%2C+kotlin.Boolean%29%29%29%2Fpredicate&quot;&gt;술어가 &lt;/a&gt; &lt;code&gt;true&lt;/code&gt; 를 생성 하는 문자가 포함 되고 , &lt;em&gt;두 번째&lt;/em&gt; 문자 시퀀스에는 &lt;a href=&quot;../partition#kotlin.text%24partition%28kotlin.CharSequence%2C+kotlin.Function1%28%28kotlin.Char%2C+kotlin.Boolean%29%29%29%2Fpredicate&quot;&gt;술어가 &lt;/a&gt; &lt;code&gt;false&lt;/code&gt; 를 생성 하는 문자가 포함 됩니다.</target>
        </trans-unit>
        <trans-unit id="98cb77a4188cc584dfebb3134ca9b48a2ac72713" translate="yes" xml:space="preserve">
          <source>Splits the original char sequence into pair of char sequences, where &lt;em&gt;first&lt;/em&gt; char sequence contains characters for which &lt;a href=&quot;partition#kotlin.text%24partition%28kotlin.CharSequence%2C+kotlin.Function1%28%28kotlin.Char%2C+kotlin.Boolean%29%29%29%2Fpredicate&quot;&gt;predicate&lt;/a&gt; yielded &lt;code&gt;true&lt;/code&gt;, while &lt;em&gt;second&lt;/em&gt; char sequence contains characters for which &lt;a href=&quot;partition#kotlin.text%24partition%28kotlin.CharSequence%2C+kotlin.Function1%28%28kotlin.Char%2C+kotlin.Boolean%29%29%29%2Fpredicate&quot;&gt;predicate&lt;/a&gt; yielded &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">원래 문자 시퀀스를 문자 시퀀스 쌍으로 분할합니다. 여기서 &lt;em&gt;첫 번째&lt;/em&gt; 문자 시퀀스에는 &lt;a href=&quot;partition#kotlin.text%24partition%28kotlin.CharSequence%2C+kotlin.Function1%28%28kotlin.Char%2C+kotlin.Boolean%29%29%29%2Fpredicate&quot;&gt;술어가 &lt;/a&gt; &lt;code&gt;true&lt;/code&gt; 를 생성 하는 문자가 포함 되고 , &lt;em&gt;두 번째&lt;/em&gt; 문자 시퀀스에는 &lt;a href=&quot;partition#kotlin.text%24partition%28kotlin.CharSequence%2C+kotlin.Function1%28%28kotlin.Char%2C+kotlin.Boolean%29%29%29%2Fpredicate&quot;&gt;술어가 &lt;/a&gt; &lt;code&gt;false&lt;/code&gt; 를 생성 하는 문자가 포함 됩니다.</target>
        </trans-unit>
        <trans-unit id="abff32a9b2f4672bf7a49c903911bd3c805f10b9" translate="yes" xml:space="preserve">
          <source>Splits the original collection into pair of lists, where &lt;em&gt;first&lt;/em&gt; list contains elements for which &lt;a href=&quot;../../kotlin.collections/partition#kotlin.collections%24partition%28kotlin.collections.Iterable%28%28kotlin.collections.partition.T%29%29%2C+kotlin.Function1%28%28kotlin.collections.partition.T%2C+kotlin.Boolean%29%29%29%2Fpredicate&quot;&gt;predicate&lt;/a&gt; yielded &lt;code&gt;true&lt;/code&gt;, while &lt;em&gt;second&lt;/em&gt; list contains elements for which &lt;a href=&quot;../../kotlin.collections/partition#kotlin.collections%24partition%28kotlin.collections.Iterable%28%28kotlin.collections.partition.T%29%29%2C+kotlin.Function1%28%28kotlin.collections.partition.T%2C+kotlin.Boolean%29%29%29%2Fpredicate&quot;&gt;predicate&lt;/a&gt; yielded &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">원래 콜렉션을 목록 쌍으로 분할합니다. &lt;em&gt;첫 번째&lt;/em&gt; 목록에는 &lt;a href=&quot;../../kotlin.collections/partition#kotlin.collections%24partition%28kotlin.collections.Iterable%28%28kotlin.collections.partition.T%29%29%2C+kotlin.Function1%28%28kotlin.collections.partition.T%2C+kotlin.Boolean%29%29%29%2Fpredicate&quot;&gt;술어가 &lt;/a&gt; &lt;code&gt;true&lt;/code&gt; 를 산출 한 요소가 포함 되고 , &lt;em&gt;두 번째&lt;/em&gt; 목록에는 &lt;a href=&quot;../../kotlin.collections/partition#kotlin.collections%24partition%28kotlin.collections.Iterable%28%28kotlin.collections.partition.T%29%29%2C+kotlin.Function1%28%28kotlin.collections.partition.T%2C+kotlin.Boolean%29%29%29%2Fpredicate&quot;&gt;술어가 &lt;/a&gt; &lt;code&gt;false&lt;/code&gt; 를 산출 한 요소가 포함 됩니다.</target>
        </trans-unit>
        <trans-unit id="51351b50d1163f62c3cb23f2fcefe72a33c2e006" translate="yes" xml:space="preserve">
          <source>Splits the original collection into pair of lists, where &lt;em&gt;first&lt;/em&gt; list contains elements for which &lt;a href=&quot;../partition#kotlin.collections%24partition%28kotlin.collections.Iterable%28%28kotlin.collections.partition.T%29%29%2C+kotlin.Function1%28%28kotlin.collections.partition.T%2C+kotlin.Boolean%29%29%29%2Fpredicate&quot;&gt;predicate&lt;/a&gt; yielded &lt;code&gt;true&lt;/code&gt;, while &lt;em&gt;second&lt;/em&gt; list contains elements for which &lt;a href=&quot;../partition#kotlin.collections%24partition%28kotlin.collections.Iterable%28%28kotlin.collections.partition.T%29%29%2C+kotlin.Function1%28%28kotlin.collections.partition.T%2C+kotlin.Boolean%29%29%29%2Fpredicate&quot;&gt;predicate&lt;/a&gt; yielded &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">원래 콜렉션을 목록 쌍으로 분할합니다. &lt;em&gt;첫 번째&lt;/em&gt; 목록에는 &lt;a href=&quot;../partition#kotlin.collections%24partition%28kotlin.collections.Iterable%28%28kotlin.collections.partition.T%29%29%2C+kotlin.Function1%28%28kotlin.collections.partition.T%2C+kotlin.Boolean%29%29%29%2Fpredicate&quot;&gt;술어가 &lt;/a&gt; &lt;code&gt;true&lt;/code&gt; 를 산출 한 요소가 포함 되고 , &lt;em&gt;두 번째&lt;/em&gt; 목록에는 &lt;a href=&quot;../partition#kotlin.collections%24partition%28kotlin.collections.Iterable%28%28kotlin.collections.partition.T%29%29%2C+kotlin.Function1%28%28kotlin.collections.partition.T%2C+kotlin.Boolean%29%29%29%2Fpredicate&quot;&gt;술어가 &lt;/a&gt; &lt;code&gt;false&lt;/code&gt; 를 산출 한 요소가 포함 됩니다.</target>
        </trans-unit>
        <trans-unit id="a6229b291af2d23e4a0f09e0825f18914ab656ef" translate="yes" xml:space="preserve">
          <source>Splits the original collection into pair of lists, where &lt;em&gt;first&lt;/em&gt; list contains elements for which &lt;a href=&quot;partition#kotlin.collections%24partition%28kotlin.collections.Iterable%28%28kotlin.collections.partition.T%29%29%2C+kotlin.Function1%28%28kotlin.collections.partition.T%2C+kotlin.Boolean%29%29%29%2Fpredicate&quot;&gt;predicate&lt;/a&gt; yielded &lt;code&gt;true&lt;/code&gt;, while &lt;em&gt;second&lt;/em&gt; list contains elements for which &lt;a href=&quot;partition#kotlin.collections%24partition%28kotlin.collections.Iterable%28%28kotlin.collections.partition.T%29%29%2C+kotlin.Function1%28%28kotlin.collections.partition.T%2C+kotlin.Boolean%29%29%29%2Fpredicate&quot;&gt;predicate&lt;/a&gt; yielded &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">원래 콜렉션을 목록 쌍으로 분할합니다. &lt;em&gt;첫 번째&lt;/em&gt; 목록에는 &lt;a href=&quot;partition#kotlin.collections%24partition%28kotlin.collections.Iterable%28%28kotlin.collections.partition.T%29%29%2C+kotlin.Function1%28%28kotlin.collections.partition.T%2C+kotlin.Boolean%29%29%29%2Fpredicate&quot;&gt;술어가 &lt;/a&gt; &lt;code&gt;true&lt;/code&gt; 를 산출 한 요소가 포함 되고 , &lt;em&gt;두 번째&lt;/em&gt; 목록에는 &lt;a href=&quot;partition#kotlin.collections%24partition%28kotlin.collections.Iterable%28%28kotlin.collections.partition.T%29%29%2C+kotlin.Function1%28%28kotlin.collections.partition.T%2C+kotlin.Boolean%29%29%29%2Fpredicate&quot;&gt;술어가 &lt;/a&gt; &lt;code&gt;false&lt;/code&gt; 를 산출 한 요소가 포함 됩니다.</target>
        </trans-unit>
        <trans-unit id="eff78228133d9c510fcf60618ab7fbbe96384888" translate="yes" xml:space="preserve">
          <source>Splits the original sequence into pair of lists, where &lt;em&gt;first&lt;/em&gt; list contains elements for which &lt;a href=&quot;../partition#kotlin.sequences%24partition%28kotlin.sequences.Sequence%28%28kotlin.sequences.partition.T%29%29%2C+kotlin.Function1%28%28kotlin.sequences.partition.T%2C+kotlin.Boolean%29%29%29%2Fpredicate&quot;&gt;predicate&lt;/a&gt; yielded &lt;code&gt;true&lt;/code&gt;, while &lt;em&gt;second&lt;/em&gt; list contains elements for which &lt;a href=&quot;../partition#kotlin.sequences%24partition%28kotlin.sequences.Sequence%28%28kotlin.sequences.partition.T%29%29%2C+kotlin.Function1%28%28kotlin.sequences.partition.T%2C+kotlin.Boolean%29%29%29%2Fpredicate&quot;&gt;predicate&lt;/a&gt; yielded &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">원래 순서를 목록 쌍으로 분할합니다. 여기서 &lt;em&gt;첫 번째&lt;/em&gt; 목록에는 &lt;a href=&quot;../partition#kotlin.sequences%24partition%28kotlin.sequences.Sequence%28%28kotlin.sequences.partition.T%29%29%2C+kotlin.Function1%28%28kotlin.sequences.partition.T%2C+kotlin.Boolean%29%29%29%2Fpredicate&quot;&gt;술어가 &lt;/a&gt; &lt;code&gt;true&lt;/code&gt; 를 생성 한 요소가 포함 되고 &lt;em&gt;두 번째&lt;/em&gt; 목록에는 &lt;a href=&quot;../partition#kotlin.sequences%24partition%28kotlin.sequences.Sequence%28%28kotlin.sequences.partition.T%29%29%2C+kotlin.Function1%28%28kotlin.sequences.partition.T%2C+kotlin.Boolean%29%29%29%2Fpredicate&quot;&gt;술어가 &lt;/a&gt; &lt;code&gt;false&lt;/code&gt; 를 산출 한 요소가 포함 됩니다.</target>
        </trans-unit>
        <trans-unit id="144bf3c5a2bc721c001b10a1ad55b094fadbc884" translate="yes" xml:space="preserve">
          <source>Splits the original sequence into pair of lists, where &lt;em&gt;first&lt;/em&gt; list contains elements for which &lt;a href=&quot;partition#kotlin.sequences%24partition%28kotlin.sequences.Sequence%28%28kotlin.sequences.partition.T%29%29%2C+kotlin.Function1%28%28kotlin.sequences.partition.T%2C+kotlin.Boolean%29%29%29%2Fpredicate&quot;&gt;predicate&lt;/a&gt; yielded &lt;code&gt;true&lt;/code&gt;, while &lt;em&gt;second&lt;/em&gt; list contains elements for which &lt;a href=&quot;partition#kotlin.sequences%24partition%28kotlin.sequences.Sequence%28%28kotlin.sequences.partition.T%29%29%2C+kotlin.Function1%28%28kotlin.sequences.partition.T%2C+kotlin.Boolean%29%29%29%2Fpredicate&quot;&gt;predicate&lt;/a&gt; yielded &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">원래 순서를 목록 쌍으로 분할합니다. 여기서 &lt;em&gt;첫 번째&lt;/em&gt; 목록에는 &lt;a href=&quot;partition#kotlin.sequences%24partition%28kotlin.sequences.Sequence%28%28kotlin.sequences.partition.T%29%29%2C+kotlin.Function1%28%28kotlin.sequences.partition.T%2C+kotlin.Boolean%29%29%29%2Fpredicate&quot;&gt;술어가 &lt;/a&gt; &lt;code&gt;true&lt;/code&gt; 를 생성 한 요소가 포함 되고 &lt;em&gt;두 번째&lt;/em&gt; 목록에는 &lt;a href=&quot;partition#kotlin.sequences%24partition%28kotlin.sequences.Sequence%28%28kotlin.sequences.partition.T%29%29%2C+kotlin.Function1%28%28kotlin.sequences.partition.T%2C+kotlin.Boolean%29%29%29%2Fpredicate&quot;&gt;술어가 &lt;/a&gt; &lt;code&gt;false&lt;/code&gt; 를 산출 한 요소가 포함 됩니다.</target>
        </trans-unit>
        <trans-unit id="fc5ba51f56d3586a3ac3ee5a06dad5c2ce9a8a65" translate="yes" xml:space="preserve">
          <source>Splits the original string into pair of strings, where &lt;em&gt;first&lt;/em&gt; string contains characters for which &lt;a href=&quot;../../kotlin.text/partition#kotlin.text%24partition%28kotlin.String%2C+kotlin.Function1%28%28kotlin.Char%2C+kotlin.Boolean%29%29%29%2Fpredicate&quot;&gt;predicate&lt;/a&gt; yielded &lt;code&gt;true&lt;/code&gt;, while &lt;em&gt;second&lt;/em&gt; string contains characters for which &lt;a href=&quot;../../kotlin.text/partition#kotlin.text%24partition%28kotlin.String%2C+kotlin.Function1%28%28kotlin.Char%2C+kotlin.Boolean%29%29%29%2Fpredicate&quot;&gt;predicate&lt;/a&gt; yielded &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">문자열의 쌍으로 원래의 문자열을 분할 &lt;em&gt;첫번째&lt;/em&gt; 문자열이있는 문자를 포함 &lt;a href=&quot;../../kotlin.text/partition#kotlin.text%24partition%28kotlin.String%2C+kotlin.Function1%28%28kotlin.Char%2C+kotlin.Boolean%29%29%29%2Fpredicate&quot;&gt;술어가&lt;/a&gt; 나왔고 &lt;code&gt;true&lt;/code&gt; 하면서, &lt;em&gt;두 번째&lt;/em&gt; 문자열이있는 문자를 포함 &lt;a href=&quot;../../kotlin.text/partition#kotlin.text%24partition%28kotlin.String%2C+kotlin.Function1%28%28kotlin.Char%2C+kotlin.Boolean%29%29%29%2Fpredicate&quot;&gt;술어&lt;/a&gt; 굴복 &lt;code&gt;false&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="46b23954fe998387aff666df8efc6520995fc7cc" translate="yes" xml:space="preserve">
          <source>Splits the original string into pair of strings, where &lt;em&gt;first&lt;/em&gt; string contains characters for which &lt;a href=&quot;partition#kotlin.text%24partition%28kotlin.String%2C+kotlin.Function1%28%28kotlin.Char%2C+kotlin.Boolean%29%29%29%2Fpredicate&quot;&gt;predicate&lt;/a&gt; yielded &lt;code&gt;true&lt;/code&gt;, while &lt;em&gt;second&lt;/em&gt; string contains characters for which &lt;a href=&quot;partition#kotlin.text%24partition%28kotlin.String%2C+kotlin.Function1%28%28kotlin.Char%2C+kotlin.Boolean%29%29%29%2Fpredicate&quot;&gt;predicate&lt;/a&gt; yielded &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">문자열의 쌍으로 원래의 문자열을 분할 &lt;em&gt;첫번째&lt;/em&gt; 문자열이있는 문자를 포함 &lt;a href=&quot;partition#kotlin.text%24partition%28kotlin.String%2C+kotlin.Function1%28%28kotlin.Char%2C+kotlin.Boolean%29%29%29%2Fpredicate&quot;&gt;술어가&lt;/a&gt; 나왔고 &lt;code&gt;true&lt;/code&gt; 하면서, &lt;em&gt;두 번째&lt;/em&gt; 문자열이있는 문자를 포함 &lt;a href=&quot;partition#kotlin.text%24partition%28kotlin.String%2C+kotlin.Function1%28%28kotlin.Char%2C+kotlin.Boolean%29%29%29%2Fpredicate&quot;&gt;술어&lt;/a&gt; 굴복 &lt;code&gt;false&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a9a50e34ca1a18e2bc366dc8b4f692ad42af93fc" translate="yes" xml:space="preserve">
          <source>Splits this char sequence around matches of the given regular expression.</source>
          <target state="translated">이 문자 순서를 주어진 정규 표현식과 일치하도록 나눕니다.</target>
        </trans-unit>
        <trans-unit id="9e611a3628d04640a979ef6c5b5e2ecc7f66cbfa" translate="yes" xml:space="preserve">
          <source>Splits this char sequence into a list of strings each not exceeding the given &lt;a href=&quot;../../kotlin.text/chunked#kotlin.text%24chunked%28kotlin.CharSequence%2C+kotlin.Int%29%2Fsize&quot;&gt;size&lt;/a&gt;.</source>
          <target state="translated">이 문자 순서를 지정된 &lt;a href=&quot;../../kotlin.text/chunked#kotlin.text%24chunked%28kotlin.CharSequence%2C+kotlin.Int%29%2Fsize&quot;&gt;크기를&lt;/a&gt; 초과하지 않는 문자열 목록으로 분할합니다 .</target>
        </trans-unit>
        <trans-unit id="ee551ba6b2c606bb6ab83b1a64bb7f625cc07a5b" translate="yes" xml:space="preserve">
          <source>Splits this char sequence into a list of strings each not exceeding the given &lt;a href=&quot;../chunked#kotlin.text%24chunked%28kotlin.CharSequence%2C+kotlin.Int%29%2Fsize&quot;&gt;size&lt;/a&gt;.</source>
          <target state="translated">이 문자 순서를 지정된 &lt;a href=&quot;../chunked#kotlin.text%24chunked%28kotlin.CharSequence%2C+kotlin.Int%29%2Fsize&quot;&gt;크기를&lt;/a&gt; 초과하지 않는 문자열 목록으로 분할합니다 .</target>
        </trans-unit>
        <trans-unit id="eb121cc6174dd89d8c08cf61906842c082aba3c6" translate="yes" xml:space="preserve">
          <source>Splits this char sequence into a list of strings each not exceeding the given &lt;a href=&quot;chunked#kotlin.text%24chunked%28kotlin.CharSequence%2C+kotlin.Int%29%2Fsize&quot;&gt;size&lt;/a&gt;.</source>
          <target state="translated">이 문자 순서를 지정된 &lt;a href=&quot;chunked#kotlin.text%24chunked%28kotlin.CharSequence%2C+kotlin.Int%29%2Fsize&quot;&gt;크기를&lt;/a&gt; 초과하지 않는 문자열 목록으로 분할합니다 .</target>
        </trans-unit>
        <trans-unit id="264b34f24f1a06b392a80cbea51e94a0fdc3938d" translate="yes" xml:space="preserve">
          <source>Splits this char sequence into a sequence of strings each not exceeding the given &lt;a href=&quot;../../kotlin.text/chunked-sequence#kotlin.text%24chunkedSequence%28kotlin.CharSequence%2C+kotlin.Int%29%2Fsize&quot;&gt;size&lt;/a&gt;.</source>
          <target state="translated">이 문자 순서를 지정된 &lt;a href=&quot;../../kotlin.text/chunked-sequence#kotlin.text%24chunkedSequence%28kotlin.CharSequence%2C+kotlin.Int%29%2Fsize&quot;&gt;크기를&lt;/a&gt; 초과하지 않는 일련의 문자열로 나눕니다 .</target>
        </trans-unit>
        <trans-unit id="e6da35fa6eec6e876ca4586b221b0baab3b5636c" translate="yes" xml:space="preserve">
          <source>Splits this char sequence into a sequence of strings each not exceeding the given &lt;a href=&quot;../chunked-sequence#kotlin.text%24chunkedSequence%28kotlin.CharSequence%2C+kotlin.Int%29%2Fsize&quot;&gt;size&lt;/a&gt;.</source>
          <target state="translated">이 문자 순서를 지정된 &lt;a href=&quot;../chunked-sequence#kotlin.text%24chunkedSequence%28kotlin.CharSequence%2C+kotlin.Int%29%2Fsize&quot;&gt;크기를&lt;/a&gt; 초과하지 않는 일련의 문자열로 나눕니다 .</target>
        </trans-unit>
        <trans-unit id="a5ecdbe41629430b5e5cfb82fc1b4ad0586b6b35" translate="yes" xml:space="preserve">
          <source>Splits this char sequence into a sequence of strings each not exceeding the given &lt;a href=&quot;chunked-sequence#kotlin.text%24chunkedSequence%28kotlin.CharSequence%2C+kotlin.Int%29%2Fsize&quot;&gt;size&lt;/a&gt;.</source>
          <target state="translated">이 문자 순서를 지정된 &lt;a href=&quot;chunked-sequence#kotlin.text%24chunkedSequence%28kotlin.CharSequence%2C+kotlin.Int%29%2Fsize&quot;&gt;크기를&lt;/a&gt; 초과하지 않는 일련의 문자열로 나눕니다 .</target>
        </trans-unit>
        <trans-unit id="5f7147b8b3ec6b68d6bd51082e0faaca2998e51d" translate="yes" xml:space="preserve">
          <source>Splits this char sequence into several char sequences each not exceeding the given &lt;a href=&quot;../../kotlin.text/chunked#kotlin.text%24chunked%28kotlin.CharSequence%2C+kotlin.Int%2C+kotlin.Function1%28%28kotlin.CharSequence%2C+kotlin.text.chunked.R%29%29%29%2Fsize&quot;&gt;size&lt;/a&gt; and applies the given &lt;a href=&quot;../../kotlin.text/chunked#kotlin.text%24chunked%28kotlin.CharSequence%2C+kotlin.Int%2C+kotlin.Function1%28%28kotlin.CharSequence%2C+kotlin.text.chunked.R%29%29%29%2Ftransform&quot;&gt;transform&lt;/a&gt; function to an each.</source>
          <target state="translated">이 문자 순서를 주어진 &lt;a href=&quot;../../kotlin.text/chunked#kotlin.text%24chunked%28kotlin.CharSequence%2C+kotlin.Int%2C+kotlin.Function1%28%28kotlin.CharSequence%2C+kotlin.text.chunked.R%29%29%29%2Fsize&quot;&gt;크기를&lt;/a&gt; 초과하지 않는 여러 문자 순서로 나누고 주어진 &lt;a href=&quot;../../kotlin.text/chunked#kotlin.text%24chunked%28kotlin.CharSequence%2C+kotlin.Int%2C+kotlin.Function1%28%28kotlin.CharSequence%2C+kotlin.text.chunked.R%29%29%29%2Ftransform&quot;&gt;변환&lt;/a&gt; 함수를 각각에 적용합니다 .</target>
        </trans-unit>
        <trans-unit id="63e385077425eafb77e9a40a51539c2d80eb2f51" translate="yes" xml:space="preserve">
          <source>Splits this char sequence into several char sequences each not exceeding the given &lt;a href=&quot;../../kotlin.text/chunked-sequence#kotlin.text%24chunkedSequence%28kotlin.CharSequence%2C+kotlin.Int%2C+kotlin.Function1%28%28kotlin.CharSequence%2C+kotlin.text.chunkedSequence.R%29%29%29%2Fsize&quot;&gt;size&lt;/a&gt; and applies the given &lt;a href=&quot;../../kotlin.text/chunked-sequence#kotlin.text%24chunkedSequence%28kotlin.CharSequence%2C+kotlin.Int%2C+kotlin.Function1%28%28kotlin.CharSequence%2C+kotlin.text.chunkedSequence.R%29%29%29%2Ftransform&quot;&gt;transform&lt;/a&gt; function to an each.</source>
          <target state="translated">이 문자 순서를 주어진 &lt;a href=&quot;../../kotlin.text/chunked-sequence#kotlin.text%24chunkedSequence%28kotlin.CharSequence%2C+kotlin.Int%2C+kotlin.Function1%28%28kotlin.CharSequence%2C+kotlin.text.chunkedSequence.R%29%29%29%2Fsize&quot;&gt;크기를&lt;/a&gt; 초과하지 않는 여러 문자 순서로 나누고 주어진 &lt;a href=&quot;../../kotlin.text/chunked-sequence#kotlin.text%24chunkedSequence%28kotlin.CharSequence%2C+kotlin.Int%2C+kotlin.Function1%28%28kotlin.CharSequence%2C+kotlin.text.chunkedSequence.R%29%29%29%2Ftransform&quot;&gt;변환&lt;/a&gt; 함수를 각각에 적용합니다 .</target>
        </trans-unit>
        <trans-unit id="581a009720af973c365e2ace4d33cf5076877aca" translate="yes" xml:space="preserve">
          <source>Splits this char sequence into several char sequences each not exceeding the given &lt;a href=&quot;../chunked#kotlin.text%24chunked%28kotlin.CharSequence%2C+kotlin.Int%2C+kotlin.Function1%28%28kotlin.CharSequence%2C+kotlin.text.chunked.R%29%29%29%2Fsize&quot;&gt;size&lt;/a&gt; and applies the given &lt;a href=&quot;../chunked#kotlin.text%24chunked%28kotlin.CharSequence%2C+kotlin.Int%2C+kotlin.Function1%28%28kotlin.CharSequence%2C+kotlin.text.chunked.R%29%29%29%2Ftransform&quot;&gt;transform&lt;/a&gt; function to an each.</source>
          <target state="translated">이 문자 순서를 주어진 &lt;a href=&quot;../chunked#kotlin.text%24chunked%28kotlin.CharSequence%2C+kotlin.Int%2C+kotlin.Function1%28%28kotlin.CharSequence%2C+kotlin.text.chunked.R%29%29%29%2Fsize&quot;&gt;크기를&lt;/a&gt; 초과하지 않는 여러 문자 순서로 나누고 주어진 &lt;a href=&quot;../chunked#kotlin.text%24chunked%28kotlin.CharSequence%2C+kotlin.Int%2C+kotlin.Function1%28%28kotlin.CharSequence%2C+kotlin.text.chunked.R%29%29%29%2Ftransform&quot;&gt;변환&lt;/a&gt; 함수를 각각에 적용합니다 .</target>
        </trans-unit>
        <trans-unit id="d717f98666285a1e90ad8965f8f7418dcc8ed232" translate="yes" xml:space="preserve">
          <source>Splits this char sequence into several char sequences each not exceeding the given &lt;a href=&quot;../chunked-sequence#kotlin.text%24chunkedSequence%28kotlin.CharSequence%2C+kotlin.Int%2C+kotlin.Function1%28%28kotlin.CharSequence%2C+kotlin.text.chunkedSequence.R%29%29%29%2Fsize&quot;&gt;size&lt;/a&gt; and applies the given &lt;a href=&quot;../chunked-sequence#kotlin.text%24chunkedSequence%28kotlin.CharSequence%2C+kotlin.Int%2C+kotlin.Function1%28%28kotlin.CharSequence%2C+kotlin.text.chunkedSequence.R%29%29%29%2Ftransform&quot;&gt;transform&lt;/a&gt; function to an each.</source>
          <target state="translated">이 문자 순서를 주어진 &lt;a href=&quot;../chunked-sequence#kotlin.text%24chunkedSequence%28kotlin.CharSequence%2C+kotlin.Int%2C+kotlin.Function1%28%28kotlin.CharSequence%2C+kotlin.text.chunkedSequence.R%29%29%29%2Fsize&quot;&gt;크기를&lt;/a&gt; 초과하지 않는 여러 문자 순서로 나누고 주어진 &lt;a href=&quot;../chunked-sequence#kotlin.text%24chunkedSequence%28kotlin.CharSequence%2C+kotlin.Int%2C+kotlin.Function1%28%28kotlin.CharSequence%2C+kotlin.text.chunkedSequence.R%29%29%29%2Ftransform&quot;&gt;변환&lt;/a&gt; 함수를 각각에 적용합니다 .</target>
        </trans-unit>
        <trans-unit id="85e376173d9c9d8eeff5141b7586fa74005ee16a" translate="yes" xml:space="preserve">
          <source>Splits this char sequence into several char sequences each not exceeding the given &lt;a href=&quot;chunked#kotlin.text%24chunked%28kotlin.CharSequence%2C+kotlin.Int%2C+kotlin.Function1%28%28kotlin.CharSequence%2C+kotlin.text.chunked.R%29%29%29%2Fsize&quot;&gt;size&lt;/a&gt; and applies the given &lt;a href=&quot;chunked#kotlin.text%24chunked%28kotlin.CharSequence%2C+kotlin.Int%2C+kotlin.Function1%28%28kotlin.CharSequence%2C+kotlin.text.chunked.R%29%29%29%2Ftransform&quot;&gt;transform&lt;/a&gt; function to an each.</source>
          <target state="translated">이 문자 순서를 주어진 &lt;a href=&quot;chunked#kotlin.text%24chunked%28kotlin.CharSequence%2C+kotlin.Int%2C+kotlin.Function1%28%28kotlin.CharSequence%2C+kotlin.text.chunked.R%29%29%29%2Fsize&quot;&gt;크기를&lt;/a&gt; 초과하지 않는 여러 문자 순서로 나누고 주어진 &lt;a href=&quot;chunked#kotlin.text%24chunked%28kotlin.CharSequence%2C+kotlin.Int%2C+kotlin.Function1%28%28kotlin.CharSequence%2C+kotlin.text.chunked.R%29%29%29%2Ftransform&quot;&gt;변환&lt;/a&gt; 함수를 각각에 적용합니다 .</target>
        </trans-unit>
        <trans-unit id="99d50e657fbe43a3b68f5a6eb982003c115c6f08" translate="yes" xml:space="preserve">
          <source>Splits this char sequence into several char sequences each not exceeding the given &lt;a href=&quot;chunked-sequence#kotlin.text%24chunkedSequence%28kotlin.CharSequence%2C+kotlin.Int%2C+kotlin.Function1%28%28kotlin.CharSequence%2C+kotlin.text.chunkedSequence.R%29%29%29%2Fsize&quot;&gt;size&lt;/a&gt; and applies the given &lt;a href=&quot;chunked-sequence#kotlin.text%24chunkedSequence%28kotlin.CharSequence%2C+kotlin.Int%2C+kotlin.Function1%28%28kotlin.CharSequence%2C+kotlin.text.chunkedSequence.R%29%29%29%2Ftransform&quot;&gt;transform&lt;/a&gt; function to an each.</source>
          <target state="translated">이 문자 순서를 주어진 &lt;a href=&quot;chunked-sequence#kotlin.text%24chunkedSequence%28kotlin.CharSequence%2C+kotlin.Int%2C+kotlin.Function1%28%28kotlin.CharSequence%2C+kotlin.text.chunkedSequence.R%29%29%29%2Fsize&quot;&gt;크기를&lt;/a&gt; 초과하지 않는 여러 문자 순서로 나누고 주어진 &lt;a href=&quot;chunked-sequence#kotlin.text%24chunkedSequence%28kotlin.CharSequence%2C+kotlin.Int%2C+kotlin.Function1%28%28kotlin.CharSequence%2C+kotlin.text.chunkedSequence.R%29%29%29%2Ftransform&quot;&gt;변환&lt;/a&gt; 함수를 각각에 적용합니다 .</target>
        </trans-unit>
        <trans-unit id="f66500e7f768a0de7bc52b6beeddc83d7cdc8834" translate="yes" xml:space="preserve">
          <source>Splits this char sequence to a list of lines delimited by any of the following character sequences: CRLF, LF or CR.</source>
          <target state="translated">이 문자 순서를 CRLF, LF 또는 CR 문자 문자로 구분 된 행 목록으로 분할합니다.</target>
        </trans-unit>
        <trans-unit id="3d5a1c5b6b30c321992d76335fa3e703f787af61" translate="yes" xml:space="preserve">
          <source>Splits this char sequence to a list of strings around occurrences of the specified &lt;a href=&quot;../../kotlin.text/split#kotlin.text%24split%28kotlin.CharSequence%2C+kotlin.Array%28%28kotlin.String%29%29%2C+kotlin.Boolean%2C+kotlin.Int%29%2Fdelimiters&quot;&gt;delimiters&lt;/a&gt;.</source>
          <target state="translated">이 문자 순서를 지정된 &lt;a href=&quot;../../kotlin.text/split#kotlin.text%24split%28kotlin.CharSequence%2C+kotlin.Array%28%28kotlin.String%29%29%2C+kotlin.Boolean%2C+kotlin.Int%29%2Fdelimiters&quot;&gt;구분 기호&lt;/a&gt; 가있는 문자열 목록으로 분할합니다 .</target>
        </trans-unit>
        <trans-unit id="8197b9ef14d350d1f531e4c5e5be27c3d5429cd4" translate="yes" xml:space="preserve">
          <source>Splits this char sequence to a list of strings around occurrences of the specified &lt;a href=&quot;../split#kotlin.text%24split%28kotlin.CharSequence%2C+kotlin.Array%28%28kotlin.String%29%29%2C+kotlin.Boolean%2C+kotlin.Int%29%2Fdelimiters&quot;&gt;delimiters&lt;/a&gt;.</source>
          <target state="translated">이 문자 순서를 지정된 &lt;a href=&quot;../split#kotlin.text%24split%28kotlin.CharSequence%2C+kotlin.Array%28%28kotlin.String%29%29%2C+kotlin.Boolean%2C+kotlin.Int%29%2Fdelimiters&quot;&gt;구분 기호&lt;/a&gt; 가있는 문자열 목록으로 분할합니다 .</target>
        </trans-unit>
        <trans-unit id="5e5d0b62ab16eee4e98080c541c6045d782f0598" translate="yes" xml:space="preserve">
          <source>Splits this char sequence to a list of strings around occurrences of the specified &lt;a href=&quot;split#kotlin.text%24split%28kotlin.CharSequence%2C+kotlin.Array%28%28kotlin.String%29%29%2C+kotlin.Boolean%2C+kotlin.Int%29%2Fdelimiters&quot;&gt;delimiters&lt;/a&gt;.</source>
          <target state="translated">이 문자 순서를 지정된 &lt;a href=&quot;split#kotlin.text%24split%28kotlin.CharSequence%2C+kotlin.Array%28%28kotlin.String%29%29%2C+kotlin.Boolean%2C+kotlin.Int%29%2Fdelimiters&quot;&gt;구분 기호&lt;/a&gt; 가있는 문자열 목록으로 분할합니다 .</target>
        </trans-unit>
        <trans-unit id="12d10ed5fb25d750ebed3fb28bbf6b83bd2c0019" translate="yes" xml:space="preserve">
          <source>Splits this char sequence to a list of strings around occurrences of the specified &lt;a href=&quot;split#kotlin.text%24split%28kotlin.CharSequence%2C+kotlin.CharArray%2C+kotlin.Boolean%2C+kotlin.Int%29%2Fdelimiters&quot;&gt;delimiters&lt;/a&gt;.</source>
          <target state="translated">이 문자 순서를 지정된 &lt;a href=&quot;split#kotlin.text%24split%28kotlin.CharSequence%2C+kotlin.CharArray%2C+kotlin.Boolean%2C+kotlin.Int%29%2Fdelimiters&quot;&gt;구분 기호&lt;/a&gt; 가있는 문자열 목록으로 분할합니다 .</target>
        </trans-unit>
        <trans-unit id="3a6716d508015c660a59f20c19d214d94cfd85f3" translate="yes" xml:space="preserve">
          <source>Splits this char sequence to a sequence of lines delimited by any of the following character sequences: CRLF, LF or CR.</source>
          <target state="translated">이 문자 순서를 CRLF, LF 또는 CR 문자 문자로 구분 된 행 순서로 분할합니다.</target>
        </trans-unit>
        <trans-unit id="e3e94c6787d54178064018c52c37bc40d4047b92" translate="yes" xml:space="preserve">
          <source>Splits this char sequence to a sequence of strings around occurrences of the specified &lt;a href=&quot;../../kotlin.text/split-to-sequence#kotlin.text%24splitToSequence%28kotlin.CharSequence%2C+kotlin.Array%28%28kotlin.String%29%29%2C+kotlin.Boolean%2C+kotlin.Int%29%2Fdelimiters&quot;&gt;delimiters&lt;/a&gt;.</source>
          <target state="translated">이 문자 순서를 지정된 &lt;a href=&quot;../../kotlin.text/split-to-sequence#kotlin.text%24splitToSequence%28kotlin.CharSequence%2C+kotlin.Array%28%28kotlin.String%29%29%2C+kotlin.Boolean%2C+kotlin.Int%29%2Fdelimiters&quot;&gt;분리 문자의&lt;/a&gt; 발생을 중심으로 일련의 문자열로 분할합니다 .</target>
        </trans-unit>
        <trans-unit id="1dc6355bd5dcf88cb7012eadeab20169c9c6450f" translate="yes" xml:space="preserve">
          <source>Splits this char sequence to a sequence of strings around occurrences of the specified &lt;a href=&quot;../split-to-sequence#kotlin.text%24splitToSequence%28kotlin.CharSequence%2C+kotlin.Array%28%28kotlin.String%29%29%2C+kotlin.Boolean%2C+kotlin.Int%29%2Fdelimiters&quot;&gt;delimiters&lt;/a&gt;.</source>
          <target state="translated">이 문자 순서를 지정된 &lt;a href=&quot;../split-to-sequence#kotlin.text%24splitToSequence%28kotlin.CharSequence%2C+kotlin.Array%28%28kotlin.String%29%29%2C+kotlin.Boolean%2C+kotlin.Int%29%2Fdelimiters&quot;&gt;분리 문자의&lt;/a&gt; 발생을 중심으로 일련의 문자열로 분할합니다 .</target>
        </trans-unit>
        <trans-unit id="2a3dd7ecd8e5aad7ae43ecd7e15b94ace9d83f6c" translate="yes" xml:space="preserve">
          <source>Splits this char sequence to a sequence of strings around occurrences of the specified &lt;a href=&quot;split-to-sequence#kotlin.text%24splitToSequence%28kotlin.CharSequence%2C+kotlin.Array%28%28kotlin.String%29%29%2C+kotlin.Boolean%2C+kotlin.Int%29%2Fdelimiters&quot;&gt;delimiters&lt;/a&gt;.</source>
          <target state="translated">이 문자 순서를 지정된 &lt;a href=&quot;split-to-sequence#kotlin.text%24splitToSequence%28kotlin.CharSequence%2C+kotlin.Array%28%28kotlin.String%29%29%2C+kotlin.Boolean%2C+kotlin.Int%29%2Fdelimiters&quot;&gt;분리 문자의&lt;/a&gt; 발생을 중심으로 일련의 문자열로 분할합니다 .</target>
        </trans-unit>
        <trans-unit id="7ffebadc04bba02e4e49a6327f15a6ca200c75ff" translate="yes" xml:space="preserve">
          <source>Splits this char sequence to a sequence of strings around occurrences of the specified &lt;a href=&quot;split-to-sequence#kotlin.text%24splitToSequence%28kotlin.CharSequence%2C+kotlin.CharArray%2C+kotlin.Boolean%2C+kotlin.Int%29%2Fdelimiters&quot;&gt;delimiters&lt;/a&gt;.</source>
          <target state="translated">이 문자 순서를 지정된 &lt;a href=&quot;split-to-sequence#kotlin.text%24splitToSequence%28kotlin.CharSequence%2C+kotlin.CharArray%2C+kotlin.Boolean%2C+kotlin.Int%29%2Fdelimiters&quot;&gt;분리 문자의&lt;/a&gt; 발생을 중심으로 일련의 문자열로 분할합니다 .</target>
        </trans-unit>
        <trans-unit id="4894892135b3d855d1f0f6d3001b4e1d6e322c67" translate="yes" xml:space="preserve">
          <source>Splits this collection into a list of lists each not exceeding the given &lt;a href=&quot;../../kotlin.collections/chunked#kotlin.collections%24chunked%28kotlin.collections.Iterable%28%28kotlin.collections.chunked.T%29%29%2C+kotlin.Int%29%2Fsize&quot;&gt;size&lt;/a&gt;.</source>
          <target state="translated">이 컬렉션을 지정된 &lt;a href=&quot;../../kotlin.collections/chunked#kotlin.collections%24chunked%28kotlin.collections.Iterable%28%28kotlin.collections.chunked.T%29%29%2C+kotlin.Int%29%2Fsize&quot;&gt;크기를&lt;/a&gt; 초과하지 않는 목록 목록으로 분할합니다 .</target>
        </trans-unit>
        <trans-unit id="8109cdc99c9d3ce75b0e6a735d1a16b951be7072" translate="yes" xml:space="preserve">
          <source>Splits this collection into a list of lists each not exceeding the given &lt;a href=&quot;../chunked#kotlin.collections%24chunked%28kotlin.collections.Iterable%28%28kotlin.collections.chunked.T%29%29%2C+kotlin.Int%29%2Fsize&quot;&gt;size&lt;/a&gt;.</source>
          <target state="translated">이 컬렉션을 지정된 &lt;a href=&quot;../chunked#kotlin.collections%24chunked%28kotlin.collections.Iterable%28%28kotlin.collections.chunked.T%29%29%2C+kotlin.Int%29%2Fsize&quot;&gt;크기를&lt;/a&gt; 초과하지 않는 목록 목록으로 분할합니다 .</target>
        </trans-unit>
        <trans-unit id="b0f2e0bbfd89fcd5462f6ead2b682ba787dadd8e" translate="yes" xml:space="preserve">
          <source>Splits this collection into a list of lists each not exceeding the given &lt;a href=&quot;chunked#kotlin.collections%24chunked%28kotlin.collections.Iterable%28%28kotlin.collections.chunked.T%29%29%2C+kotlin.Int%29%2Fsize&quot;&gt;size&lt;/a&gt;.</source>
          <target state="translated">이 컬렉션을 지정된 &lt;a href=&quot;chunked#kotlin.collections%24chunked%28kotlin.collections.Iterable%28%28kotlin.collections.chunked.T%29%29%2C+kotlin.Int%29%2Fsize&quot;&gt;크기를&lt;/a&gt; 초과하지 않는 목록 목록으로 분할합니다 .</target>
        </trans-unit>
        <trans-unit id="e21d3492a25178c7b849a9e5acc322cb20b39aca" translate="yes" xml:space="preserve">
          <source>Splits this collection into several lists each not exceeding the given &lt;a href=&quot;../../kotlin.collections/chunked#kotlin.collections%24chunked%28kotlin.collections.Iterable%28%28kotlin.collections.chunked.T%29%29%2C+kotlin.Int%2C+kotlin.Function1%28%28kotlin.collections.List%28%28kotlin.collections.chunked.T%29%29%2C+kotlin.collections.chunked.R%29%29%29%2Fsize&quot;&gt;size&lt;/a&gt; and applies the given &lt;a href=&quot;../../kotlin.collections/chunked#kotlin.collections%24chunked%28kotlin.collections.Iterable%28%28kotlin.collections.chunked.T%29%29%2C+kotlin.Int%2C+kotlin.Function1%28%28kotlin.collections.List%28%28kotlin.collections.chunked.T%29%29%2C+kotlin.collections.chunked.R%29%29%29%2Ftransform&quot;&gt;transform&lt;/a&gt; function to an each.</source>
          <target state="translated">이 컬렉션을 주어진 &lt;a href=&quot;../../kotlin.collections/chunked#kotlin.collections%24chunked%28kotlin.collections.Iterable%28%28kotlin.collections.chunked.T%29%29%2C+kotlin.Int%2C+kotlin.Function1%28%28kotlin.collections.List%28%28kotlin.collections.chunked.T%29%29%2C+kotlin.collections.chunked.R%29%29%29%2Fsize&quot;&gt;크기를&lt;/a&gt; 초과하지 않는 여러 목록으로 나누고 지정된 &lt;a href=&quot;../../kotlin.collections/chunked#kotlin.collections%24chunked%28kotlin.collections.Iterable%28%28kotlin.collections.chunked.T%29%29%2C+kotlin.Int%2C+kotlin.Function1%28%28kotlin.collections.List%28%28kotlin.collections.chunked.T%29%29%2C+kotlin.collections.chunked.R%29%29%29%2Ftransform&quot;&gt;변형&lt;/a&gt; 함수를 각각에 적용합니다 .</target>
        </trans-unit>
        <trans-unit id="a48428391f4651acfd24fee9fa33c87080c6e779" translate="yes" xml:space="preserve">
          <source>Splits this collection into several lists each not exceeding the given &lt;a href=&quot;../chunked#kotlin.collections%24chunked%28kotlin.collections.Iterable%28%28kotlin.collections.chunked.T%29%29%2C+kotlin.Int%2C+kotlin.Function1%28%28kotlin.collections.List%28%28kotlin.collections.chunked.T%29%29%2C+kotlin.collections.chunked.R%29%29%29%2Fsize&quot;&gt;size&lt;/a&gt; and applies the given &lt;a href=&quot;../chunked#kotlin.collections%24chunked%28kotlin.collections.Iterable%28%28kotlin.collections.chunked.T%29%29%2C+kotlin.Int%2C+kotlin.Function1%28%28kotlin.collections.List%28%28kotlin.collections.chunked.T%29%29%2C+kotlin.collections.chunked.R%29%29%29%2Ftransform&quot;&gt;transform&lt;/a&gt; function to an each.</source>
          <target state="translated">이 컬렉션을 주어진 &lt;a href=&quot;../chunked#kotlin.collections%24chunked%28kotlin.collections.Iterable%28%28kotlin.collections.chunked.T%29%29%2C+kotlin.Int%2C+kotlin.Function1%28%28kotlin.collections.List%28%28kotlin.collections.chunked.T%29%29%2C+kotlin.collections.chunked.R%29%29%29%2Fsize&quot;&gt;크기를&lt;/a&gt; 초과하지 않는 여러 목록으로 나누고 지정된 &lt;a href=&quot;../chunked#kotlin.collections%24chunked%28kotlin.collections.Iterable%28%28kotlin.collections.chunked.T%29%29%2C+kotlin.Int%2C+kotlin.Function1%28%28kotlin.collections.List%28%28kotlin.collections.chunked.T%29%29%2C+kotlin.collections.chunked.R%29%29%29%2Ftransform&quot;&gt;변형&lt;/a&gt; 함수를 각각에 적용합니다 .</target>
        </trans-unit>
        <trans-unit id="517737e782c5357ab242922fc5304b40e3826245" translate="yes" xml:space="preserve">
          <source>Splits this collection into several lists each not exceeding the given &lt;a href=&quot;chunked#kotlin.collections%24chunked%28kotlin.collections.Iterable%28%28kotlin.collections.chunked.T%29%29%2C+kotlin.Int%2C+kotlin.Function1%28%28kotlin.collections.List%28%28kotlin.collections.chunked.T%29%29%2C+kotlin.collections.chunked.R%29%29%29%2Fsize&quot;&gt;size&lt;/a&gt; and applies the given &lt;a href=&quot;chunked#kotlin.collections%24chunked%28kotlin.collections.Iterable%28%28kotlin.collections.chunked.T%29%29%2C+kotlin.Int%2C+kotlin.Function1%28%28kotlin.collections.List%28%28kotlin.collections.chunked.T%29%29%2C+kotlin.collections.chunked.R%29%29%29%2Ftransform&quot;&gt;transform&lt;/a&gt; function to an each.</source>
          <target state="translated">이 컬렉션을 주어진 &lt;a href=&quot;chunked#kotlin.collections%24chunked%28kotlin.collections.Iterable%28%28kotlin.collections.chunked.T%29%29%2C+kotlin.Int%2C+kotlin.Function1%28%28kotlin.collections.List%28%28kotlin.collections.chunked.T%29%29%2C+kotlin.collections.chunked.R%29%29%29%2Fsize&quot;&gt;크기를&lt;/a&gt; 초과하지 않는 여러 목록으로 나누고 지정된 &lt;a href=&quot;chunked#kotlin.collections%24chunked%28kotlin.collections.Iterable%28%28kotlin.collections.chunked.T%29%29%2C+kotlin.Int%2C+kotlin.Function1%28%28kotlin.collections.List%28%28kotlin.collections.chunked.T%29%29%2C+kotlin.collections.chunked.R%29%29%29%2Ftransform&quot;&gt;변형&lt;/a&gt; 함수를 각각에 적용합니다 .</target>
        </trans-unit>
        <trans-unit id="024d988a38905cd8d713b5b971dfe3778cfdc3d8" translate="yes" xml:space="preserve">
          <source>Splits this sequence into a sequence of lists each not exceeding the given &lt;a href=&quot;../chunked#kotlin.sequences%24chunked%28kotlin.sequences.Sequence%28%28kotlin.sequences.chunked.T%29%29%2C+kotlin.Int%29%2Fsize&quot;&gt;size&lt;/a&gt;.</source>
          <target state="translated">이 순서를 지정된 &lt;a href=&quot;../chunked#kotlin.sequences%24chunked%28kotlin.sequences.Sequence%28%28kotlin.sequences.chunked.T%29%29%2C+kotlin.Int%29%2Fsize&quot;&gt;크기를&lt;/a&gt; 초과하지 않는 일련의 목록으로 나눕니다 .</target>
        </trans-unit>
        <trans-unit id="2782bc20294974e7a1e43c016491b6c91648db8f" translate="yes" xml:space="preserve">
          <source>Splits this sequence into a sequence of lists each not exceeding the given &lt;a href=&quot;chunked#kotlin.sequences%24chunked%28kotlin.sequences.Sequence%28%28kotlin.sequences.chunked.T%29%29%2C+kotlin.Int%29%2Fsize&quot;&gt;size&lt;/a&gt;.</source>
          <target state="translated">이 순서를 지정된 &lt;a href=&quot;chunked#kotlin.sequences%24chunked%28kotlin.sequences.Sequence%28%28kotlin.sequences.chunked.T%29%29%2C+kotlin.Int%29%2Fsize&quot;&gt;크기를&lt;/a&gt; 초과하지 않는 일련의 목록으로 나눕니다 .</target>
        </trans-unit>
        <trans-unit id="d437291eabeca701471089c6dfa0b2b88f511909" translate="yes" xml:space="preserve">
          <source>Splits this sequence into several lists each not exceeding the given &lt;a href=&quot;../chunked#kotlin.sequences%24chunked%28kotlin.sequences.Sequence%28%28kotlin.sequences.chunked.T%29%29%2C+kotlin.Int%2C+kotlin.Function1%28%28kotlin.collections.List%28%28kotlin.sequences.chunked.T%29%29%2C+kotlin.sequences.chunked.R%29%29%29%2Fsize&quot;&gt;size&lt;/a&gt; and applies the given &lt;a href=&quot;../chunked#kotlin.sequences%24chunked%28kotlin.sequences.Sequence%28%28kotlin.sequences.chunked.T%29%29%2C+kotlin.Int%2C+kotlin.Function1%28%28kotlin.collections.List%28%28kotlin.sequences.chunked.T%29%29%2C+kotlin.sequences.chunked.R%29%29%29%2Ftransform&quot;&gt;transform&lt;/a&gt; function to an each.</source>
          <target state="translated">이 시퀀스를 주어진 &lt;a href=&quot;../chunked#kotlin.sequences%24chunked%28kotlin.sequences.Sequence%28%28kotlin.sequences.chunked.T%29%29%2C+kotlin.Int%2C+kotlin.Function1%28%28kotlin.collections.List%28%28kotlin.sequences.chunked.T%29%29%2C+kotlin.sequences.chunked.R%29%29%29%2Fsize&quot;&gt;크기를&lt;/a&gt; 초과하지 않는 여러 목록으로 나누고 지정된 &lt;a href=&quot;../chunked#kotlin.sequences%24chunked%28kotlin.sequences.Sequence%28%28kotlin.sequences.chunked.T%29%29%2C+kotlin.Int%2C+kotlin.Function1%28%28kotlin.collections.List%28%28kotlin.sequences.chunked.T%29%29%2C+kotlin.sequences.chunked.R%29%29%29%2Ftransform&quot;&gt;변환&lt;/a&gt; 함수를 각각에 적용합니다 .</target>
        </trans-unit>
        <trans-unit id="42d99abb4dad1bd5f52d7374981881da327ee184" translate="yes" xml:space="preserve">
          <source>Splits this sequence into several lists each not exceeding the given &lt;a href=&quot;chunked#kotlin.sequences%24chunked%28kotlin.sequences.Sequence%28%28kotlin.sequences.chunked.T%29%29%2C+kotlin.Int%2C+kotlin.Function1%28%28kotlin.collections.List%28%28kotlin.sequences.chunked.T%29%29%2C+kotlin.sequences.chunked.R%29%29%29%2Fsize&quot;&gt;size&lt;/a&gt; and applies the given &lt;a href=&quot;chunked#kotlin.sequences%24chunked%28kotlin.sequences.Sequence%28%28kotlin.sequences.chunked.T%29%29%2C+kotlin.Int%2C+kotlin.Function1%28%28kotlin.collections.List%28%28kotlin.sequences.chunked.T%29%29%2C+kotlin.sequences.chunked.R%29%29%29%2Ftransform&quot;&gt;transform&lt;/a&gt; function to an each.</source>
          <target state="translated">이 시퀀스를 주어진 &lt;a href=&quot;chunked#kotlin.sequences%24chunked%28kotlin.sequences.Sequence%28%28kotlin.sequences.chunked.T%29%29%2C+kotlin.Int%2C+kotlin.Function1%28%28kotlin.collections.List%28%28kotlin.sequences.chunked.T%29%29%2C+kotlin.sequences.chunked.R%29%29%29%2Fsize&quot;&gt;크기를&lt;/a&gt; 초과하지 않는 여러 목록으로 나누고 지정된 &lt;a href=&quot;chunked#kotlin.sequences%24chunked%28kotlin.sequences.Sequence%28%28kotlin.sequences.chunked.T%29%29%2C+kotlin.Int%2C+kotlin.Function1%28%28kotlin.collections.List%28%28kotlin.sequences.chunked.T%29%29%2C+kotlin.sequences.chunked.R%29%29%29%2Ftransform&quot;&gt;변환&lt;/a&gt; 함수를 각각에 적용합니다 .</target>
        </trans-unit>
        <trans-unit id="7c51d044b0775b9dff2cfa78b3da8cb8049bb2ff" translate="yes" xml:space="preserve">
          <source>Spring support</source>
          <target state="translated">봄 지원</target>
        </trans-unit>
        <trans-unit id="4d471041d7df92549d73db2c13c586ee2b0cec2e" translate="yes" xml:space="preserve">
          <source>Square brackets are translated to calls to &lt;code&gt;get&lt;/code&gt; and &lt;code&gt;set&lt;/code&gt; with appropriate numbers of arguments.</source>
          <target state="translated">대괄호는 적절한 수의 인수 로 &lt;code&gt;get&lt;/code&gt; 오고 &lt;code&gt;set&lt;/code&gt; 하기 위한 호출로 변환됩니다 .</target>
        </trans-unit>
        <trans-unit id="00ffdccd32ed64d431bf831e7b8e2169d330f1f8" translate="yes" xml:space="preserve">
          <source>Stability of Different Components</source>
          <target state="translated">다른 구성 요소의 안정성</target>
        </trans-unit>
        <trans-unit id="d1536eaeef57c8fe7e38a044d153592707538ced" translate="yes" xml:space="preserve">
          <source>Stable releases with versions 1.2, 1.3, etc. are usually considered to be &lt;em&gt;feature releases&lt;/em&gt; bringing major changes in the language. Normally, we publish &lt;em&gt;incremental releases&lt;/em&gt;, numbered 1.2.20, 1.2.30, etc, in between feature releases.</source>
          <target state="translated">버전 1.2, 1.3 등이 포함 된 안정적인 릴리스는 일반적으로 언어를 크게 변경하는 &lt;em&gt;기능 릴리스로&lt;/em&gt; 간주 됩니다. 일반적으로, 기능 릴리스 사이에 1.2.20, 1.2.30 등으로 번호가 매겨진 &lt;em&gt;증분 릴리스를&lt;/em&gt; 게시 합니다.</target>
        </trans-unit>
        <trans-unit id="c2b6f531a85effb53654c20ee953d94aca8bd93f" translate="yes" xml:space="preserve">
          <source>StableObjPtr</source>
          <target state="translated">StableObjPtr</target>
        </trans-unit>
        <trans-unit id="d5695f0dc6545fa97fef8f5d8d98f8ea9529cc21" translate="yes" xml:space="preserve">
          <source>StableRef</source>
          <target state="translated">StableRef</target>
        </trans-unit>
        <trans-unit id="cd6c8d56f6241b414217edc699eb83c63b345d74" translate="yes" xml:space="preserve">
          <source>Stack overflow</source>
          <target state="translated">스택 오버플로</target>
        </trans-unit>
        <trans-unit id="ed0e3d47052276129876bad97c5d9695f1d4c1e7" translate="yes" xml:space="preserve">
          <source>Standard Data Classes</source>
          <target state="translated">표준 데이터 클래스</target>
        </trans-unit>
        <trans-unit id="9905d2303d697763e7c368a3fc398e3a629682f8" translate="yes" xml:space="preserve">
          <source>Standard Delegates</source>
          <target state="translated">표준 대표</target>
        </trans-unit>
        <trans-unit id="eba63c181dd248d4b5bba8f0065bbb50178505fc" translate="yes" xml:space="preserve">
          <source>Standard Library</source>
          <target state="translated">표준 라이브러리</target>
        </trans-unit>
        <trans-unit id="fbdf47a84aa524486f1f19bc8f2b7696fa1c4c48" translate="yes" xml:space="preserve">
          <source>Standard implementations of delegates for &lt;a href=&quot;../../../../../docs/reference/delegated-properties&quot;&gt;delegated properties&lt;/a&gt; and helper functions for implementing custom delegates.</source>
          <target state="translated">&lt;a href=&quot;../../../../../docs/reference/delegated-properties&quot;&gt;위임 속성에&lt;/a&gt; 대한 표준 델리게이트 구현 및 사용자 지정 델리게이트 구현을위한 도우미 기능</target>
        </trans-unit>
        <trans-unit id="b31b91de60e88c68f139ba0e04804a05ebd424b2" translate="yes" xml:space="preserve">
          <source>Standard implementations of delegates for &lt;a href=&quot;docs/reference/delegated-properties&quot;&gt;delegated properties&lt;/a&gt; and helper functions for implementing custom delegates.</source>
          <target state="translated">&lt;a href=&quot;docs/reference/delegated-properties&quot;&gt;위임 속성에&lt;/a&gt; 대한 표준 델리게이트 구현 및 사용자 지정 델리게이트 구현을위한 도우미 기능</target>
        </trans-unit>
        <trans-unit id="360c57caedbd1d1ff38dde144677c893d6ad3792" translate="yes" xml:space="preserve">
          <source>Standard library</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ad16d6480ea3a42fd35ae681f27222eeb06b2257" translate="yes" xml:space="preserve">
          <source>Standard property delegates.</source>
          <target state="translated">표준 부동산 대표.</target>
        </trans-unit>
        <trans-unit id="f22646c78134d6ac39afe0c5ee5f9ae0df7f3bbd" translate="yes" xml:space="preserve">
          <source>Star projection, denoted by the &lt;code&gt;*&lt;/code&gt; character. For example, in the type &lt;code&gt;KClass&amp;lt;*&amp;gt;&lt;/code&gt;, &lt;code&gt;*&lt;/code&gt; is the star projection. See the &lt;a href=&quot;../../../../../../docs/reference/generics#star-projections&quot;&gt;Kotlin language documentation&lt;/a&gt; for more information.</source>
          <target state="translated">&lt;code&gt;*&lt;/code&gt; 문자 로 표시되는 별 투영 . 예를 들어 &lt;code&gt;KClass&amp;lt;*&amp;gt;&lt;/code&gt; 유형 에서 &lt;code&gt;*&lt;/code&gt; 는 별 투영입니다. 자세한 내용은 &lt;a href=&quot;../../../../../../docs/reference/generics#star-projections&quot;&gt;Kotlin 언어 설명서&lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="a77f904c776f120da6135a5ca2b0fb989dcaa559" translate="yes" xml:space="preserve">
          <source>Star-projections</source>
          <target state="translated">Star-projections</target>
        </trans-unit>
        <trans-unit id="6e5590764483cbb03fdaa9e24fc59d1a85c1288e" translate="yes" xml:space="preserve">
          <source>Start new scheduling primitive, such as thread, to accept new tasks via &lt;code&gt;execute&lt;/code&gt; interface. Typically new worker may be needed for computations offload to another core, for IO it may be better to use non-blocking IO combined with more lightweight coroutines.</source>
          <target state="translated">&lt;code&gt;execute&lt;/code&gt; 인터페이스 를 통해 새 작업을 수락하려면 스레드와 같은 새 스케줄링 기본 요소를 시작하십시오 . 일반적으로 새로운 작업자가 다른 코어로의 계산 오프로드에 필요할 수 있습니다. IO의 경우 더 가벼운 코 루틴과 결합 된 비 차단 IO를 사용하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="a0279a8f5111591a71ef0ea505d164e207decfa7" translate="yes" xml:space="preserve">
          <source>Start the &lt;a href=&quot;#running-the-android-application&quot;&gt;Android application&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;#running-the-android-application&quot;&gt;Android 애플리케이션을&lt;/a&gt; 시작하십시오.</target>
        </trans-unit>
        <trans-unit id="ffec450a13497055a66c40a0f95ad2095c4fa937" translate="yes" xml:space="preserve">
          <source>Start the &lt;a href=&quot;#running-the-ios-application&quot;&gt;iOS application&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;#running-the-ios-application&quot;&gt;iOS 애플리케이션을&lt;/a&gt; 시작하십시오</target>
        </trans-unit>
        <trans-unit id="6e0f646bfc4efa2110bf6449cf37709d3558db49" translate="yes" xml:space="preserve">
          <source>Starting from JDK 1.8, interfaces in Java can contain &lt;a href=&quot;https://docs.oracle.com/javase/tutorial/java/IandI/defaultmethods.html&quot;&gt;default methods&lt;/a&gt;. You can declare a non-abstract member of a Kotlin interface as default for the Java classes implementing it. To make a member default, mark it with the &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.jvm/-jvm-default/index&quot;&gt;&lt;code&gt;@JvmDefault&lt;/code&gt;&lt;/a&gt; annotation. Here is an example of a Kotlin interface with a default method:</source>
          <target state="translated">JDK 1.8부터 Java 인터페이스에는 &lt;a href=&quot;https://docs.oracle.com/javase/tutorial/java/IandI/defaultmethods.html&quot;&gt;기본 메소드&lt;/a&gt; 가 포함될 수 있습니다 . Kotlin 인터페이스의 비추 상 멤버를 구현하는 Java 클래스의 기본값으로 선언 할 수 있습니다. 멤버를 기본값으로 설정하려면 &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.jvm/-jvm-default/index&quot;&gt; &lt;code&gt;@JvmDefault&lt;/code&gt; &lt;/a&gt; 주석으로 표시하십시오 . 기본 메소드가있는 Kotlin 인터페이스의 예는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="cd2a24b509ce811a3267e32e8920ed8b3ac2112a" translate="yes" xml:space="preserve">
          <source>Starting from Kotlin 1.3, &lt;code&gt;@JvmStatic&lt;/code&gt; applies to functions defined in companion objects of interfaces as well. Such functions compile to static methods in interfaces. Note that static method in interfaces were introduced in Java 1.8, so be sure to use the corresponding targets.</source>
          <target state="translated">&lt;code&gt;@JvmStatic&lt;/code&gt; 은 Kotlin 1.3부터 인터페이스의 컴패니언 객체에 정의 된 함수에도 적용됩니다. 이러한 함수는 인터페이스의 정적 메소드로 컴파일됩니다. 인터페이스의 정적 메소드는 Java 1.8에서 도입되었으므로 해당 대상을 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="f2ef314e1060cb19059b7679202c90dd5f779df0" translate="yes" xml:space="preserve">
          <source>Starting from version 1.3.30, kapt supports incremental annotation processing as an experimental feature. Currently, annotation processing can be incremental only if all annotation processors being used are incremental.</source>
          <target state="translated">버전 1.3.30부터 kapt는 실험 기능으로 증분 주석 처리를 지원합니다. 현재 주석 처리는 사용중인 모든 주석 프로세서가 증분 인 경우에만 증분 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1620971e5e7fb81960f0323359f6dc556dc282b3" translate="yes" xml:space="preserve">
          <source>Starting with 1.3.30, an experimental integration with &lt;a href=&quot;https://cocoapods.org/&quot;&gt;CocoaPods&lt;/a&gt; is added to Kotlin/Native. This feature allows you to represent a Kotlin/Native Gradle-project as a CocoaPods dependency. Such a representation provides the following advantages:</source>
          <target state="translated">1.3.30 시작과 실험적인 통합 &lt;a href=&quot;https://cocoapods.org/&quot;&gt;CocoaPods는&lt;/a&gt; 코 틀린 / 기본에 추가됩니다. 이 기능을 사용하면 Kotlin / Native Gradle-project를 CocoaPods 종속성으로 나타낼 수 있습니다. 이러한 표현은 다음과 같은 장점을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="843f77eb473690d7aad6e0682c17b7993f79cc2f" translate="yes" xml:space="preserve">
          <source>Starting with Kotlin 1.1, the JavaScript target is no longer considered experimental. All language features are supported, and there are many new tools for integration with the front-end development environment. See &lt;a href=&quot;#javascript-backend&quot;&gt;below&lt;/a&gt; for a more detailed list of changes.</source>
          <target state="translated">Kotlin 1.1부터는 JavaScript 대상이 더 이상 실험적인 것으로 간주되지 않습니다. 모든 언어 기능이 지원되며 프런트 엔드 개발 환경과 통합하기위한 많은 새로운 도구가 있습니다. 자세한 변경 목록은 &lt;a href=&quot;#javascript-backend&quot;&gt;아래&lt;/a&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="41f73c0acfd31a8c403654851fe6cd652c2e3650" translate="yes" xml:space="preserve">
          <source>Starting with Kotlin 1.1.2, the dependencies with group &lt;code&gt;org.jetbrains.kotlin&lt;/code&gt; are by default resolved with the version taken from the applied plugin. You can provide the version manually using the full dependency notation:</source>
          <target state="translated">Kotlin 1.1.2부터 &lt;code&gt;org.jetbrains.kotlin&lt;/code&gt; 그룹의 종속성 은 기본적으로 적용된 플러그인에서 가져온 버전으로 해결됩니다. 전체 종속성 표기법을 사용하여 버전을 수동으로 제공 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="07b8457eb5cdf91e3e7cbfadbb3eebb80e30d3ff" translate="yes" xml:space="preserve">
          <source>Starting with Kotlin 1.2, array arguments for annotations can be passed with the new array literal syntax instead of the &lt;code&gt;arrayOf&lt;/code&gt; function:</source>
          <target state="translated">Kotlin 1.2부터는 어노테이션에 대한 배열 인수를 &lt;code&gt;arrayOf&lt;/code&gt; 함수 대신 새로운 배열 리터럴 구문으로 전달할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="12a86828fbb44a7006158c4f6ac9be7d98219035" translate="yes" xml:space="preserve">
          <source>Starting with version 1.1.50 primitive array translation utilizes JavaScript TypedArray:</source>
          <target state="translated">버전 1.1.50부터 기본 배열 변환은 JavaScript TypedArray를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="dd4c7c6c2fa2a107f57737194dfcb51c6b3fd326" translate="yes" xml:space="preserve">
          <source>Starts a coroutine with receiver type &lt;a href=&quot;start-coroutine#R&quot;&gt;R&lt;/a&gt; and result type &lt;a href=&quot;start-coroutine#T&quot;&gt;T&lt;/a&gt;. This function creates and starts a new, fresh instance of suspendable computation every time it is invoked. The &lt;a href=&quot;start-coroutine#kotlin.coroutines%24startCoroutine%28kotlin.coroutines.SuspendFunction1%28%28kotlin.coroutines.startCoroutine.R%2C+kotlin.coroutines.startCoroutine.T%29%29%2C+kotlin.coroutines.startCoroutine.R%2C+kotlin.coroutines.Continuation%28%28kotlin.coroutines.startCoroutine.T%29%29%29%2Fcompletion&quot;&gt;completion&lt;/a&gt; continuation is invoked when the coroutine completes with a result or an exception.</source>
          <target state="translated">수신자 유형 &lt;a href=&quot;start-coroutine#R&quot;&gt;R&lt;/a&gt; 및 결과 유형 &lt;a href=&quot;start-coroutine#T&quot;&gt;T&lt;/a&gt; 로 코 루틴을 시작합니다 . 이 함수는 호출 할 때마다 새로운 일시 중단 가능한 계산 인스턴스를 생성하고 시작합니다. &lt;a href=&quot;start-coroutine#kotlin.coroutines%24startCoroutine%28kotlin.coroutines.SuspendFunction1%28%28kotlin.coroutines.startCoroutine.R%2C+kotlin.coroutines.startCoroutine.T%29%29%2C+kotlin.coroutines.startCoroutine.R%2C+kotlin.coroutines.Continuation%28%28kotlin.coroutines.startCoroutine.T%29%29%29%2Fcompletion&quot;&gt;완료&lt;/a&gt; 코 루틴은 결과 또는 예외로 완료 될 때 연속 호출된다.</target>
        </trans-unit>
        <trans-unit id="14c38709fc453b41bd452218007cb35f2d68079b" translate="yes" xml:space="preserve">
          <source>Starts a coroutine without a receiver and with result type &lt;a href=&quot;start-coroutine#T&quot;&gt;T&lt;/a&gt;. This function creates and starts a new, fresh instance of suspendable computation every time it is invoked. The &lt;a href=&quot;start-coroutine#kotlin.coroutines%24startCoroutine%28kotlin.coroutines.SuspendFunction0%28%28kotlin.coroutines.startCoroutine.T%29%29%2C+kotlin.coroutines.Continuation%28%28kotlin.coroutines.startCoroutine.T%29%29%29%2Fcompletion&quot;&gt;completion&lt;/a&gt; continuation is invoked when the coroutine completes with a result or an exception.</source>
          <target state="translated">수신자없이 결과 유형 &lt;a href=&quot;start-coroutine#T&quot;&gt;T&lt;/a&gt; 로 코 루틴을 시작합니다 . 이 함수는 호출 할 때마다 새로운 일시 중단 가능한 계산 인스턴스를 생성하고 시작합니다. &lt;a href=&quot;start-coroutine#kotlin.coroutines%24startCoroutine%28kotlin.coroutines.SuspendFunction0%28%28kotlin.coroutines.startCoroutine.T%29%29%2C+kotlin.coroutines.Continuation%28%28kotlin.coroutines.startCoroutine.T%29%29%29%2Fcompletion&quot;&gt;완료&lt;/a&gt; 코 루틴은 결과 또는 예외로 완료 될 때 연속 호출된다.</target>
        </trans-unit>
        <trans-unit id="5ad5c461ffacb6e08120b54a5c5c09dc010d10cb" translate="yes" xml:space="preserve">
          <source>Starts an unintercepted coroutine with receiver type &lt;a href=&quot;start-coroutine-unintercepted-or-return#R&quot;&gt;R&lt;/a&gt; and result type &lt;a href=&quot;start-coroutine-unintercepted-or-return#T&quot;&gt;T&lt;/a&gt; and executes it until its first suspension. Returns the result of the coroutine or throws its exception if it does not suspend or &lt;a href=&quot;-c-o-r-o-u-t-i-n-e_-s-u-s-p-e-n-d-e-d&quot;&gt;COROUTINE_SUSPENDED&lt;/a&gt; if it suspends. In the latter case, the &lt;a href=&quot;start-coroutine-unintercepted-or-return#kotlin.coroutines.intrinsics%24startCoroutineUninterceptedOrReturn%28kotlin.coroutines.SuspendFunction1%28%28kotlin.coroutines.intrinsics.startCoroutineUninterceptedOrReturn.R%2C+kotlin.coroutines.intrinsics.startCoroutineUninterceptedOrReturn.T%29%29%2C+kotlin.coroutines.intrinsics.startCoroutineUninterceptedOrReturn.R%2C+kotlin.coroutines.Continuation%28%28kotlin.coroutines.intrinsics.startCoroutineUninterceptedOrReturn.T%29%29%29%2Fcompletion&quot;&gt;completion&lt;/a&gt; continuation is invoked when the coroutine completes with a result or an exception.</source>
          <target state="translated">리시버 유형 &lt;a href=&quot;start-coroutine-unintercepted-or-return#R&quot;&gt;R&lt;/a&gt; 및 결과 유형 &lt;a href=&quot;start-coroutine-unintercepted-or-return#T&quot;&gt;T를&lt;/a&gt; 사용하여 인터셉트되지 않은 코 루틴을 시작 하고 첫 번째 일시 중단까지 실행합니다. 코 루틴 결과를 반환하거나, 일시 중단되지 않은 경우 예외를 발생 시키거나 , 중단되면 &lt;a href=&quot;-c-o-r-o-u-t-i-n-e_-s-u-s-p-e-n-d-e-d&quot;&gt;COROUTINE_SUSPENDED를 throw&lt;/a&gt; 합니다. 후자의 경우, 코 루틴이 결과 또는 예외와 함께 완료 될 때 &lt;a href=&quot;start-coroutine-unintercepted-or-return#kotlin.coroutines.intrinsics%24startCoroutineUninterceptedOrReturn%28kotlin.coroutines.SuspendFunction1%28%28kotlin.coroutines.intrinsics.startCoroutineUninterceptedOrReturn.R%2C+kotlin.coroutines.intrinsics.startCoroutineUninterceptedOrReturn.T%29%29%2C+kotlin.coroutines.intrinsics.startCoroutineUninterceptedOrReturn.R%2C+kotlin.coroutines.Continuation%28%28kotlin.coroutines.intrinsics.startCoroutineUninterceptedOrReturn.T%29%29%29%2Fcompletion&quot;&gt;완료&lt;/a&gt; 계속이 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="334ec1f5ed05ab3e3f9b3bc457a00d70430e2e22" translate="yes" xml:space="preserve">
          <source>Starts an unintercepted coroutine without a receiver and with result type &lt;a href=&quot;start-coroutine-unintercepted-or-return#T&quot;&gt;T&lt;/a&gt; and executes it until its first suspension. Returns the result of the coroutine or throws its exception if it does not suspend or &lt;a href=&quot;-c-o-r-o-u-t-i-n-e_-s-u-s-p-e-n-d-e-d&quot;&gt;COROUTINE_SUSPENDED&lt;/a&gt; if it suspends. In the latter case, the &lt;a href=&quot;start-coroutine-unintercepted-or-return#kotlin.coroutines.intrinsics%24startCoroutineUninterceptedOrReturn%28kotlin.coroutines.SuspendFunction0%28%28kotlin.coroutines.intrinsics.startCoroutineUninterceptedOrReturn.T%29%29%2C+kotlin.coroutines.Continuation%28%28kotlin.coroutines.intrinsics.startCoroutineUninterceptedOrReturn.T%29%29%29%2Fcompletion&quot;&gt;completion&lt;/a&gt; continuation is invoked when the coroutine completes with a result or an exception.</source>
          <target state="translated">수신자없이 결과 유형 &lt;a href=&quot;start-coroutine-unintercepted-or-return#T&quot;&gt;T를&lt;/a&gt; 사용하여 인터셉트되지 않은 코 루틴을 시작 하고 첫 번째 일시 중단까지 실행합니다. 코 루틴 결과를 반환하거나, 일시 중단되지 않은 경우 예외를 발생 시키거나 , 중단되면 &lt;a href=&quot;-c-o-r-o-u-t-i-n-e_-s-u-s-p-e-n-d-e-d&quot;&gt;COROUTINE_SUSPENDED를 throw&lt;/a&gt; 합니다. 후자의 경우, 코 루틴이 결과 또는 예외와 함께 완료 될 때 &lt;a href=&quot;start-coroutine-unintercepted-or-return#kotlin.coroutines.intrinsics%24startCoroutineUninterceptedOrReturn%28kotlin.coroutines.SuspendFunction0%28%28kotlin.coroutines.intrinsics.startCoroutineUninterceptedOrReturn.T%29%29%2C+kotlin.coroutines.Continuation%28%28kotlin.coroutines.intrinsics.startCoroutineUninterceptedOrReturn.T%29%29%29%2Fcompletion&quot;&gt;완료&lt;/a&gt; 계속이 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="3ddb5f3024adc4fc2cb11955f22b8f2de6b0e3b1" translate="yes" xml:space="preserve">
          <source>Starts coroutine with receiver type &lt;a href=&quot;start-coroutine#R&quot;&gt;R&lt;/a&gt; and result type &lt;a href=&quot;start-coroutine#T&quot;&gt;T&lt;/a&gt;. This function creates and start a new, fresh instance of suspendable computation every time it is invoked. The &lt;a href=&quot;start-coroutine#kotlin.coroutines.experimental%24startCoroutine%28kotlin.coroutines.SuspendFunction1%28%28kotlin.coroutines.experimental.startCoroutine.R%2C+kotlin.coroutines.experimental.startCoroutine.T%29%29%2C+kotlin.coroutines.experimental.startCoroutine.R%2C+kotlin.coroutines.experimental.Continuation%28%28kotlin.coroutines.experimental.startCoroutine.T%29%29%29%2Fcompletion&quot;&gt;completion&lt;/a&gt; continuation is invoked when coroutine completes with result or exception.</source>
          <target state="translated">수신자 유형 &lt;a href=&quot;start-coroutine#R&quot;&gt;R&lt;/a&gt; 및 결과 유형 &lt;a href=&quot;start-coroutine#T&quot;&gt;T로&lt;/a&gt; 코 루틴을 시작합니다 . 이 함수는 호출 할 때마다 새롭고 새로운 일시 중단 가능한 계산 인스턴스를 생성하고 시작합니다. &lt;a href=&quot;start-coroutine#kotlin.coroutines.experimental%24startCoroutine%28kotlin.coroutines.SuspendFunction1%28%28kotlin.coroutines.experimental.startCoroutine.R%2C+kotlin.coroutines.experimental.startCoroutine.T%29%29%2C+kotlin.coroutines.experimental.startCoroutine.R%2C+kotlin.coroutines.experimental.Continuation%28%28kotlin.coroutines.experimental.startCoroutine.T%29%29%29%2Fcompletion&quot;&gt;완료&lt;/a&gt; 코 루틴은 결과 또는 예외로 완료 될 때 연속이 호출된다.</target>
        </trans-unit>
        <trans-unit id="926abb8b1e85620405b11eda69dc96cfcc1f565d" translate="yes" xml:space="preserve">
          <source>Starts coroutine without receiver and with result type &lt;a href=&quot;start-coroutine#T&quot;&gt;T&lt;/a&gt;. This function creates and start a new, fresh instance of suspendable computation every time it is invoked. The &lt;a href=&quot;start-coroutine#kotlin.coroutines.experimental%24startCoroutine%28kotlin.coroutines.SuspendFunction0%28%28kotlin.coroutines.experimental.startCoroutine.T%29%29%2C+kotlin.coroutines.experimental.Continuation%28%28kotlin.coroutines.experimental.startCoroutine.T%29%29%29%2Fcompletion&quot;&gt;completion&lt;/a&gt; continuation is invoked when coroutine completes with result or exception.</source>
          <target state="translated">수신자없이 결과 유형 &lt;a href=&quot;start-coroutine#T&quot;&gt;T로&lt;/a&gt; 코 루틴을 시작합니다 . 이 함수는 호출 할 때마다 새롭고 새로운 일시 중단 가능한 계산 인스턴스를 생성하고 시작합니다. &lt;a href=&quot;start-coroutine#kotlin.coroutines.experimental%24startCoroutine%28kotlin.coroutines.SuspendFunction0%28%28kotlin.coroutines.experimental.startCoroutine.T%29%29%2C+kotlin.coroutines.experimental.Continuation%28%28kotlin.coroutines.experimental.startCoroutine.T%29%29%29%2Fcompletion&quot;&gt;완료&lt;/a&gt; 코 루틴은 결과 또는 예외로 완료 될 때 연속이 호출된다.</target>
        </trans-unit>
        <trans-unit id="2e41ff62360a7519652b277899448ef726bd6a59" translate="yes" xml:space="preserve">
          <source>Starts unintercepted coroutine with receiver type &lt;a href=&quot;start-coroutine-unintercepted-or-return#R&quot;&gt;R&lt;/a&gt; and result type &lt;a href=&quot;start-coroutine-unintercepted-or-return#T&quot;&gt;T&lt;/a&gt; and executes it until its first suspension. Returns the result of the coroutine or throws its exception if it does not suspend or &lt;a href=&quot;-c-o-r-o-u-t-i-n-e_-s-u-s-p-e-n-d-e-d#kotlin.coroutines.experimental.intrinsics%24COROUTINE_SUSPENDED&quot;&gt;COROUTINE_SUSPENDED&lt;/a&gt; if it suspends. In the latter case, the &lt;a href=&quot;start-coroutine-unintercepted-or-return#kotlin.coroutines.experimental.intrinsics%24startCoroutineUninterceptedOrReturn%28kotlin.coroutines.SuspendFunction1%28%28kotlin.coroutines.experimental.intrinsics.startCoroutineUninterceptedOrReturn.R%2C+kotlin.coroutines.experimental.intrinsics.startCoroutineUninterceptedOrReturn.T%29%29%2C+kotlin.coroutines.experimental.intrinsics.startCoroutineUninterceptedOrReturn.R%2C+kotlin.coroutines.experimental.Continuation%28%28kotlin.coroutines.experimental.intrinsics.startCoroutineUninterceptedOrReturn.T%29%29%29%2Fcompletion&quot;&gt;completion&lt;/a&gt; continuation is invoked when coroutine completes with result or exception. This function is designed to be used from inside of &lt;a href=&quot;suspend-coroutine-or-return&quot;&gt;suspendCoroutineOrReturn&lt;/a&gt; to resume the execution of a suspended coroutine using a reference to the suspending function.</source>
          <target state="translated">리시버 유형 &lt;a href=&quot;start-coroutine-unintercepted-or-return#R&quot;&gt;R&lt;/a&gt; 및 결과 유형 &lt;a href=&quot;start-coroutine-unintercepted-or-return#T&quot;&gt;T로&lt;/a&gt; 인터셉트되지 않은 코 루틴을 시작 하고 첫 번째 일시 중단까지 실행합니다. 코 루틴 결과를 반환하거나, 일시 중단되지 않은 경우 예외를 발생 시키거나 , 중단되면 &lt;a href=&quot;-c-o-r-o-u-t-i-n-e_-s-u-s-p-e-n-d-e-d#kotlin.coroutines.experimental.intrinsics%24COROUTINE_SUSPENDED&quot;&gt;COROUTINE_SUSPENDED를 throw&lt;/a&gt; 합니다. 후자의 경우, 코 루틴이 결과 또는 예외와 함께 &lt;a href=&quot;start-coroutine-unintercepted-or-return#kotlin.coroutines.experimental.intrinsics%24startCoroutineUninterceptedOrReturn%28kotlin.coroutines.SuspendFunction1%28%28kotlin.coroutines.experimental.intrinsics.startCoroutineUninterceptedOrReturn.R%2C+kotlin.coroutines.experimental.intrinsics.startCoroutineUninterceptedOrReturn.T%29%29%2C+kotlin.coroutines.experimental.intrinsics.startCoroutineUninterceptedOrReturn.R%2C+kotlin.coroutines.experimental.Continuation%28%28kotlin.coroutines.experimental.intrinsics.startCoroutineUninterceptedOrReturn.T%29%29%29%2Fcompletion&quot;&gt;완료되면 완료&lt;/a&gt; 계속이 호출됩니다. 이 함수는 &lt;a href=&quot;suspend-coroutine-or-return&quot;&gt;suspendCoroutineOrReturn&lt;/a&gt; 내부에서 사용하여 일시 중단 함수에 대한 참조를 사용하여 일시 중단 된 코 루틴 실행을 재개 하도록 설계되었습니다 .</target>
        </trans-unit>
        <trans-unit id="2788b8cd3b5da900d1f6ab2449049c41a16ae34e" translate="yes" xml:space="preserve">
          <source>Starts unintercepted coroutine without receiver and with result type &lt;a href=&quot;start-coroutine-unintercepted-or-return#T&quot;&gt;T&lt;/a&gt; and executes it until its first suspension. Returns the result of the coroutine or throws its exception if it does not suspend or &lt;a href=&quot;-c-o-r-o-u-t-i-n-e_-s-u-s-p-e-n-d-e-d#kotlin.coroutines.experimental.intrinsics%24COROUTINE_SUSPENDED&quot;&gt;COROUTINE_SUSPENDED&lt;/a&gt; if it suspends. In the latter case, the &lt;a href=&quot;start-coroutine-unintercepted-or-return#kotlin.coroutines.experimental.intrinsics%24startCoroutineUninterceptedOrReturn%28kotlin.coroutines.SuspendFunction0%28%28kotlin.coroutines.experimental.intrinsics.startCoroutineUninterceptedOrReturn.T%29%29%2C+kotlin.coroutines.experimental.Continuation%28%28kotlin.coroutines.experimental.intrinsics.startCoroutineUninterceptedOrReturn.T%29%29%29%2Fcompletion&quot;&gt;completion&lt;/a&gt; continuation is invoked when coroutine completes with result or exception. This function is designed to be used from inside of &lt;a href=&quot;suspend-coroutine-or-return&quot;&gt;suspendCoroutineOrReturn&lt;/a&gt; to resume the execution of a suspended coroutine using a reference to the suspending function.</source>
          <target state="translated">수신기없이 결과 유형 &lt;a href=&quot;start-coroutine-unintercepted-or-return#T&quot;&gt;T를 사용&lt;/a&gt; 하여 인터셉트되지 않은 코 루틴을 시작 하고 첫 번째 일시 중단까지이를 실행합니다. 코 루틴 결과를 반환하거나, 일시 중단되지 않은 경우 예외를 발생 시키거나 , 중단되면 &lt;a href=&quot;-c-o-r-o-u-t-i-n-e_-s-u-s-p-e-n-d-e-d#kotlin.coroutines.experimental.intrinsics%24COROUTINE_SUSPENDED&quot;&gt;COROUTINE_SUSPENDED를 throw&lt;/a&gt; 합니다. 후자의 경우, 코 루틴이 결과 또는 예외와 함께 &lt;a href=&quot;start-coroutine-unintercepted-or-return#kotlin.coroutines.experimental.intrinsics%24startCoroutineUninterceptedOrReturn%28kotlin.coroutines.SuspendFunction0%28%28kotlin.coroutines.experimental.intrinsics.startCoroutineUninterceptedOrReturn.T%29%29%2C+kotlin.coroutines.experimental.Continuation%28%28kotlin.coroutines.experimental.intrinsics.startCoroutineUninterceptedOrReturn.T%29%29%29%2Fcompletion&quot;&gt;완료되면 완료&lt;/a&gt; 계속이 호출됩니다. 이 함수는 &lt;a href=&quot;suspend-coroutine-or-return&quot;&gt;suspendCoroutineOrReturn&lt;/a&gt; 내부에서 사용하여 일시 중단 함수에 대한 참조를 사용하여 일시 중단 된 코 루틴 실행을 재개 하도록 설계되었습니다 .</target>
        </trans-unit>
        <trans-unit id="a33cea1b6a9bd48cd9741eb556f78b336e49b52e" translate="yes" xml:space="preserve">
          <source>State of the future object.</source>
          <target state="translated">미래 객체의 상태.</target>
        </trans-unit>
        <trans-unit id="600b8907db339cd22478c83d4a16dd85a73015b0" translate="yes" xml:space="preserve">
          <source>Static fields</source>
          <target state="translated">정적 필드</target>
        </trans-unit>
        <trans-unit id="d15bec36fb146b0a59873196f4b808af2a0c58d9" translate="yes" xml:space="preserve">
          <source>Static members</source>
          <target state="translated">정적 멤버</target>
        </trans-unit>
        <trans-unit id="3367f809c842440e588af1b9c4ce823b40a614e7" translate="yes" xml:space="preserve">
          <source>Static members of Java classes form &quot;companion objects&quot; for these classes. We cannot pass such a &quot;companion object&quot; around as a value, but can access the members explicitly, for example:</source>
          <target state="translated">Java 클래스의 정적 멤버는이 클래스에 대한 &quot;컴패니언 오브젝트&quot;를 형성합니다. 이러한 &quot;companion 객체&quot;를 값으로 전달할 수 없지만 다음과 같이 멤버에 명시 적으로 액세스 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="749a016bf10749d6bbdfc0717392432e9f0401f6" translate="yes" xml:space="preserve">
          <source>Static methods</source>
          <target state="translated">정적 메소드</target>
        </trans-unit>
        <trans-unit id="352274d59d59b1511e7ddd7438d2c2b359144fe5" translate="yes" xml:space="preserve">
          <source>Status of different components</source>
          <target state="translated">다른 구성 요소의 상태</target>
        </trans-unit>
        <trans-unit id="f3807792854b99f68c6be94a83962b160d23fe45" translate="yes" xml:space="preserve">
          <source>Stay in the constant feedback loop with the users.</source>
          <target state="translated">사용자와 지속적인 피드백 루프를 유지하십시오.</target>
        </trans-unit>
        <trans-unit id="f94f58f50f4cb02a7cf2e081505d0705933f148e" translate="yes" xml:space="preserve">
          <source>Stepping</source>
          <target state="translated">Stepping</target>
        </trans-unit>
        <trans-unit id="2d96e356b3dfea348019e9d1d257295bebd82c9a" translate="yes" xml:space="preserve">
          <source>Stepping functions works mostly the same way as for C/C++ programs</source>
          <target state="translated">스테핑 기능은 C / C ++ 프로그램과 거의 동일한 방식으로 작동합니다.</target>
        </trans-unit>
        <trans-unit id="9e092dda4f0e27d0c7686ddd00272079e678b6e6" translate="yes" xml:space="preserve">
          <source>Storage</source>
          <target state="translated">Storage</target>
        </trans-unit>
        <trans-unit id="248e9b3aa308183a170c36806544acb1d393c459" translate="yes" xml:space="preserve">
          <source>StorageEventInit</source>
          <target state="translated">StorageEventInit</target>
        </trans-unit>
        <trans-unit id="d976f838e65f2db3d7f099767b0928393c1ede54" translate="yes" xml:space="preserve">
          <source>Store old code style in project</source>
          <target state="translated">프로젝트에 이전 코드 스타일 저장</target>
        </trans-unit>
        <trans-unit id="6afbacec45c0da97dff5ccf3dbf2645d5876c3c5" translate="yes" xml:space="preserve">
          <source>Store the initial value of &lt;code&gt;a&lt;/code&gt; to a temporary storage &lt;code&gt;a0&lt;/code&gt;;</source>
          <target state="translated">&lt;code&gt;a&lt;/code&gt; 의 초기 값을 임시 스토리지 &lt;code&gt;a0&lt;/code&gt; 에 저장하십시오 .</target>
        </trans-unit>
        <trans-unit id="1c3904cdae80dc0a8fc8d311b3ceb604faa99393" translate="yes" xml:space="preserve">
          <source>Stores the value of the property for the given object in this mutable map.</source>
          <target state="translated">지정된 객체의 속성 값을이 변경 가능한 맵에 저장합니다.</target>
        </trans-unit>
        <trans-unit id="063a13497de8628ed966341d4c8998e048faac77" translate="yes" xml:space="preserve">
          <source>Storing Properties in a Map</source>
          <target state="translated">맵에 속성 저장</target>
        </trans-unit>
        <trans-unit id="cc60d9a373cacd1f7b4d2be35acf2bfd9970e460" translate="yes" xml:space="preserve">
          <source>Strictfp</source>
          <target state="translated">Strictfp</target>
        </trans-unit>
        <trans-unit id="3df63b7acb0522da685dad5fe84b81fdd7b25264" translate="yes" xml:space="preserve">
          <source>String</source>
          <target state="translated">String</target>
        </trans-unit>
        <trans-unit id="dcadc5a0cb117211f9dc789c191b1d6c306ecd43" translate="yes" xml:space="preserve">
          <source>String Interpolation</source>
          <target state="translated">문자열 보간</target>
        </trans-unit>
        <trans-unit id="18c909570fe3d2f04f7e3e21101c4ef09a029b7b" translate="yes" xml:space="preserve">
          <source>String Literals</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3ad53eca410dfbc39bc16b33326f447092d15b4c" translate="yes" xml:space="preserve">
          <source>String Templates</source>
          <target state="translated">문자열 템플릿</target>
        </trans-unit>
        <trans-unit id="26999992a443711764128a5ebde38ee89dae6779" translate="yes" xml:space="preserve">
          <source>String literals may contain template expressions, i.e. pieces of code that are evaluated and whose results are concatenated into the string. A template expression starts with a dollar sign ($) and consists of either a simple name:</source>
          <target state="translated">문자열 리터럴에는 템플릿 표현식, 즉 평가되고 결과가 문자열로 연결된 코드 조각이 포함될 수 있습니다. 템플릿 표현식은 달러 기호 ($)로 시작하며 간단한 이름으로 구성됩니다.</target>
        </trans-unit>
        <trans-unit id="8de7744f81c5ea96546b7ddeba1d815a5f60f342" translate="yes" xml:space="preserve">
          <source>String representation</source>
          <target state="translated">문자열 표현</target>
        </trans-unit>
        <trans-unit id="4f85bffe8cf536bd27d4c8a65ebe070b04592d3f" translate="yes" xml:space="preserve">
          <source>String templates</source>
          <target state="translated">문자열 템플릿</target>
        </trans-unit>
        <trans-unit id="7436274167a247aa32b0eb69c8fa150ce90cf60e" translate="yes" xml:space="preserve">
          <source>String to number conversions</source>
          <target state="translated">문자열을 숫자로 변환</target>
        </trans-unit>
        <trans-unit id="d8722e7c9e74dd4282c8ddb6aafb6678ffcf1c49" translate="yes" xml:space="preserve">
          <source>StringBuilder</source>
          <target state="translated">StringBuilder</target>
        </trans-unit>
        <trans-unit id="3816c4beac471c733eed1d91c213f8c2b6a29262" translate="yes" xml:space="preserve">
          <source>Strings</source>
          <target state="translated">Strings</target>
        </trans-unit>
        <trans-unit id="376d2dc017ddcafe576a8bb45c3839697d243c0f" translate="yes" xml:space="preserve">
          <source>Strings are represented by the type &lt;code&gt;String&lt;/code&gt;. Strings are immutable. Elements of a string are characters that can be accessed by the indexing operation: &lt;code&gt;s[i]&lt;/code&gt;. A string can be iterated over with a &lt;em&gt;for&lt;/em&gt;-loop:</source>
          <target state="translated">문자열은 &lt;code&gt;String&lt;/code&gt; 유형으로 표시됩니다 . 문자열은 변경할 수 없습니다. 문자열의 요소는 색인 작성 조작으로 액세스 할 수있는 문자입니다 : &lt;code&gt;s[i]&lt;/code&gt; . &lt;em&gt;for&lt;/em&gt; 루프 를 사용하여 문자열을 반복 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="6f7691f2e802476360e0176ca90e2968711fe093" translate="yes" xml:space="preserve">
          <source>Strings from C and how they look in Kotlin/Native</source>
          <target state="translated">C의 문자열과 Kotlin / Native에서 어떻게 보이는지</target>
        </trans-unit>
        <trans-unit id="2684320b57a782ce0439d9845b025f4167f73160" translate="yes" xml:space="preserve">
          <source>Strong bidirectional character type &quot;AL&quot; in the Unicode specification.</source>
          <target state="translated">Unicode 사양의 강력한 쌍방향 캐릭터 타입 「AL」</target>
        </trans-unit>
        <trans-unit id="8af8df666f0e8eca9822d09b9b728f2790d43a77" translate="yes" xml:space="preserve">
          <source>Strong bidirectional character type &quot;L&quot; in the Unicode specification.</source>
          <target state="translated">Unicode 사양의 강력한 쌍방향 문자 타입 &quot;L&quot;</target>
        </trans-unit>
        <trans-unit id="277bd06a9fb3591003f711495ac46fc89282f28e" translate="yes" xml:space="preserve">
          <source>Strong bidirectional character type &quot;LRE&quot; in the Unicode specification.</source>
          <target state="translated">Unicode 사양의 강력한 쌍방향 캐릭터 타입 「LRE」</target>
        </trans-unit>
        <trans-unit id="f0a8c58716e90117a1fa5949bd4edff7bafc489d" translate="yes" xml:space="preserve">
          <source>Strong bidirectional character type &quot;LRO&quot; in the Unicode specification.</source>
          <target state="translated">Unicode 사양의 강력한 쌍방향 문자 타입 &quot;LRO&quot;</target>
        </trans-unit>
        <trans-unit id="5c434a125001d98e3d65585f819ed8840b4f8897" translate="yes" xml:space="preserve">
          <source>Strong bidirectional character type &quot;R&quot; in the Unicode specification.</source>
          <target state="translated">Unicode 사양의 강력한 쌍방향 문자 타입 &quot;R&quot;</target>
        </trans-unit>
        <trans-unit id="64ad0d6aedac34d34b627e0784d46dea64c2ff5a" translate="yes" xml:space="preserve">
          <source>Strong bidirectional character type &quot;RLE&quot; in the Unicode specification.</source>
          <target state="translated">Unicode 사양의 강력한 쌍방향 캐릭터 타입 「RLE」</target>
        </trans-unit>
        <trans-unit id="1665148f18e9a39912a6a12baccd3148269f2320" translate="yes" xml:space="preserve">
          <source>Strong bidirectional character type &quot;RLO&quot; in the Unicode specification.</source>
          <target state="translated">Unicode 사양의 강력한 쌍방향 캐릭터 타입 「RLO」</target>
        </trans-unit>
        <trans-unit id="f21f357479481b3172a23f12385bf19995dd2f48" translate="yes" xml:space="preserve">
          <source>Struct and Union types from C and how they look in Kotlin/Native</source>
          <target state="translated">C의 Struct 및 Union 유형과 Kotlin / Native의 모양</target>
        </trans-unit>
        <trans-unit id="af5b40acf56f32ead50b7b4376e35475ae8821af" translate="yes" xml:space="preserve">
          <source>Structs / unions are mapped to types having fields available via the dot notation, i.e. &lt;code&gt;someStructInstance.field1&lt;/code&gt;.</source>
          <target state="translated">Structs / union은 점 표기법을 통해 사용 가능한 필드가있는 유형 (예 : &lt;code&gt;someStructInstance.field1&lt;/code&gt; )에 맵핑 됩니다.</target>
        </trans-unit>
        <trans-unit id="024b6c74302356ab4e71438eaaf0b40da91567fc" translate="yes" xml:space="preserve">
          <source>Structural changes in the base list make the behavior of the view undefined.</source>
          <target state="translated">기본 목록의 구조적 변경으로 인해 뷰의 동작이 정의되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="72d92fad333f84fb34170c273e339309112411ea" translate="yes" xml:space="preserve">
          <source>Structural equality</source>
          <target state="translated">구조적 평등</target>
        </trans-unit>
        <trans-unit id="7d27109df9078a59c52f1f92f6addfe6d10368ae" translate="yes" xml:space="preserve">
          <source>Structural equality (a check for &lt;code&gt;equals()&lt;/code&gt;).</source>
          <target state="translated">구조적 동등성 ( &lt;code&gt;equals()&lt;/code&gt; 점검 )</target>
        </trans-unit>
        <trans-unit id="ece356b48420c60af23fc6b7ecae7a03ec149030" translate="yes" xml:space="preserve">
          <source>Structural equality comparisons are done with &lt;code&gt;==&lt;/code&gt; and &lt;code&gt;!=&lt;/code&gt;, like in Python, but it's up to each class to define what that means, by &lt;a href=&quot;inheritance#overriding&quot;&gt;overriding&lt;/a&gt;&lt;a href=&quot;classes#inherited-built-in-functions&quot;&gt;&lt;code&gt;equals()&lt;/code&gt;&lt;/a&gt; (which will be called on the left operand with the right operand as the parameter) and &lt;code&gt;hashCode()&lt;/code&gt;. Most built-in collection types implement deep equality checks for these operators and functions. Reference comparisons - checking if two variables refer to the same object (the same as &lt;code&gt;is&lt;/code&gt; in Python) - are done with &lt;code&gt;===&lt;/code&gt; and &lt;code&gt;!==&lt;/code&gt;.</source>
          <target state="translated">파이썬에서와 같이 구조 평등 비교는 &lt;code&gt;==&lt;/code&gt; 및 &lt;code&gt;!=&lt;/code&gt; 으로 수행 되지만 &lt;a href=&quot;classes#inherited-built-in-functions&quot;&gt; &lt;code&gt;equals()&lt;/code&gt; &lt;/a&gt; 를 &lt;a href=&quot;inheritance#overriding&quot;&gt;재정&lt;/a&gt; 의하여 의미를 정의하는 것은 각 클래스에 달려 있습니다 (오른쪽 피연산자를 매개 변수로 사용하여 왼쪽 피연산자에서 호출 됨) 그리고 &lt;code&gt;hashCode()&lt;/code&gt; . 대부분의 내장 컬렉션 유형은 이러한 연산자와 함수에 대해 동등성 검사를 구현합니다. 참조 비교 - 두 변수가 동일한 개체 (같은 참조하는 경우 확인 &lt;code&gt;is&lt;/code&gt; 파이썬) -으로 완료 &lt;code&gt;===&lt;/code&gt; 와 &lt;code&gt;!==&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1b70b639ef5cff3c53b813230fbda1e132ca3cce" translate="yes" xml:space="preserve">
          <source>Structural equality has nothing to do with comparison defined by the &lt;code&gt;Comparable&amp;lt;...&amp;gt;&lt;/code&gt; interface, so only a custom &lt;code&gt;equals(Any?)&lt;/code&gt; implementation may affect the behavior of the operator.</source>
          <target state="translated">구조적 평등은 &lt;code&gt;Comparable&amp;lt;...&amp;gt;&lt;/code&gt; 인터페이스에 의해 정의 된 비교와 아무 관련이 없으므로 사용자 정의 &lt;code&gt;equals(Any?)&lt;/code&gt; 구현 만 연산자의 동작에 영향을 줄 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b976e0b583b0412204edf019c0b11bd8b81727df" translate="yes" xml:space="preserve">
          <source>Structural equality is checked by the &lt;code&gt;==&lt;/code&gt; operation (and its negated counterpart &lt;code&gt;!=&lt;/code&gt;). By convention, an expression like &lt;code&gt;a == b&lt;/code&gt; is translated to:</source>
          <target state="translated">구조 평등은 &lt;code&gt;==&lt;/code&gt; 연산 (및 부정 된 대응 &lt;code&gt;!=&lt;/code&gt; ) 에 의해 점검됩니다 . 일반적으로 &lt;code&gt;a == b&lt;/code&gt; 와 같은 표현식은 다음과 같이 변환됩니다.</target>
        </trans-unit>
        <trans-unit id="660ca66913fdaa764b314de4f4d616cb2af27fc3" translate="yes" xml:space="preserve">
          <source>Structured concurrency</source>
          <target state="translated">구조적 동시성</target>
        </trans-unit>
        <trans-unit id="688fd1f0d4f70b417561f286a2459a51d7a9bf8d" translate="yes" xml:space="preserve">
          <source>Structured concurrency with async</source>
          <target state="translated">비동기를 사용한 구조적 동시성</target>
        </trans-unit>
        <trans-unit id="ce867a84f68c1d0cd7e5d2e0a575c394cc078c03" translate="yes" xml:space="preserve">
          <source>StyleSheet</source>
          <target state="translated">StyleSheet</target>
        </trans-unit>
        <trans-unit id="105633f7a20c3c4e6cfe2fcb5bc3777e06065699" translate="yes" xml:space="preserve">
          <source>StyleSheetList</source>
          <target state="translated">StyleSheetList</target>
        </trans-unit>
        <trans-unit id="4eb481e8f0e6186576b990d8a8ee65c0bcaf3bd9" translate="yes" xml:space="preserve">
          <source>Subclasses of a class that implements an interface (in this case, &lt;code&gt;Car&lt;/code&gt;) are also considered to be implementing the interface.</source>
          <target state="translated">인터페이스 (이 경우 &lt;code&gt;Car&lt;/code&gt; ) 를 구현하는 클래스의 서브 클래스도 인터페이스를 구현하는 것으로 간주됩니다.</target>
        </trans-unit>
        <trans-unit id="82494d5df2327066831b19fcbdbc11f57f406da0" translate="yes" xml:space="preserve">
          <source>Subclassing</source>
          <target state="translated">Subclassing</target>
        </trans-unit>
        <trans-unit id="5aa09d55ccae6bc284a9aaa4b931ff34243aae33" translate="yes" xml:space="preserve">
          <source>Subclassing Kotlin classes and interfaces from Swift/Objective-C</source>
          <target state="translated">Swift / Objective-C에서 Kotlin 클래스 및 인터페이스 서브 클래 싱</target>
        </trans-unit>
        <trans-unit id="4c8bffd68e11c1e09416b7275b40472abdd31b0e" translate="yes" xml:space="preserve">
          <source>Subclassing Swift/Objective-C classes and protocols from Kotlin</source>
          <target state="translated">Kotlin의 Swift / Objective-C 클래스 및 프로토콜 서브 클래 싱</target>
        </trans-unit>
        <trans-unit id="d8cfc0d2ff946e39f440d5850a833061ce441784" translate="yes" xml:space="preserve">
          <source>Subtracts the other Char value from this value resulting an Int.</source>
          <target state="translated">이 값에서 다른 Char 값을 빼고 Int.</target>
        </trans-unit>
        <trans-unit id="f8fc787359f50113256ce34acd74e7ad27c2b7de" translate="yes" xml:space="preserve">
          <source>Subtracts the other Int value from this value resulting a Char.</source>
          <target state="translated">이 값에서 다른 Int 값을 빼면 Char가됩니다.</target>
        </trans-unit>
        <trans-unit id="cd1dd0acae6df690f4f408b7810c6a68a77d2c65" translate="yes" xml:space="preserve">
          <source>Subtracts the other value from this value.</source>
          <target state="translated">이 값에서 다른 값을 뺍니다.</target>
        </trans-unit>
        <trans-unit id="d6b1220988da8e4820eca8338c62f95c8d54d502" translate="yes" xml:space="preserve">
          <source>Such &lt;em&gt;smart casts&lt;/em&gt; work for &lt;a href=&quot;control-flow#when-expression&quot;&gt;&lt;em&gt;when&lt;/em&gt;-expressions&lt;/a&gt; and &lt;a href=&quot;control-flow#while-loops&quot;&gt;&lt;em&gt;while&lt;/em&gt;-loops&lt;/a&gt; as well:</source>
          <target state="translated">이러한 &lt;em&gt;스마트 캐스트에&lt;/em&gt; 대한 작업을 &lt;a href=&quot;control-flow#when-expression&quot;&gt;&lt;em&gt;할 때&lt;/em&gt; -expressions&lt;/a&gt; 하고 &lt;a href=&quot;control-flow#while-loops&quot;&gt;&lt;em&gt;있는 동안&lt;/em&gt; -loops&lt;/a&gt; 뿐만 아니라 :</target>
        </trans-unit>
        <trans-unit id="a6ca684a14efd3b57eb8a5d3ba3348ea50581bab" translate="yes" xml:space="preserve">
          <source>Such a chain returns &lt;em&gt;null&lt;/em&gt; if any of the properties in it is null.</source>
          <target state="translated">이러한 체인은 속성이 &lt;em&gt;null 인&lt;/em&gt; 경우 &lt;em&gt;null을&lt;/em&gt; 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="7f52975c732e28d7449a1d2bd849f22d7254ffe5" translate="yes" xml:space="preserve">
          <source>Such a dependency can be included in a Podfile of an Xcode project and automatically built (and rebuilt) along with this project. As a result, importing to Xcode is simplified since there is no need to write corresponding Gradle tasks and Xcode build steps manually.</source>
          <target state="translated">이러한 종속성은 Xcode 프로젝트의 Podfile에 포함될 수 있으며이 프로젝트와 함께 자동으로 빌드 및 재 빌드 될 수 있습니다. 결과적으로 해당 Gradle 작업과 Xcode 빌드 단계를 수동으로 작성할 필요가 없으므로 Xcode로 가져 오기가 간단 해집니다.</target>
        </trans-unit>
        <trans-unit id="275498570896fad34600eda0578ce2760eeaa8db" translate="yes" xml:space="preserve">
          <source>Such annotation type should itself be annotated with both &lt;code&gt;@Nonnull&lt;/code&gt; (or its nickname) and &lt;code&gt;@TypeQualifierDefault(...)&lt;/code&gt; with one or more &lt;code&gt;ElementType&lt;/code&gt; values:</source>
          <target state="translated">이러한 주석 유형 자체 에는 하나 이상의 &lt;code&gt;ElementType&lt;/code&gt; 값이있는 &lt;code&gt;@Nonnull&lt;/code&gt; (또는 별명) 및 &lt;code&gt;@TypeQualifierDefault(...)&lt;/code&gt; 로 주석을 달아야 합니다.</target>
        </trans-unit>
        <trans-unit id="54a890751d7cb69dc2bb8082fffc6f90e74cda3e" translate="yes" xml:space="preserve">
          <source>Such common behaviours can be implemented as libraries using &lt;a href=&quot;delegated-properties&quot;&gt;&lt;em&gt;delegated properties&lt;/em&gt;&lt;/a&gt;.</source>
          <target state="translated">이러한 일반적인 동작은 &lt;a href=&quot;delegated-properties&quot;&gt;&lt;em&gt;위임 된 속성을&lt;/em&gt;&lt;/a&gt; 사용하여 라이브러리로 구현할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="71a7fa20221b612c2534c0cd56321d47af321a0e" translate="yes" xml:space="preserve">
          <source>Such objects can have supertypes:</source>
          <target state="translated">이러한 객체는 수퍼 타입을 가질 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="70d2b2ed000c8ab8416a2925902564c1eda90b74" translate="yes" xml:space="preserve">
          <source>Such properties can be used in annotations:</source>
          <target state="translated">이러한 속성은 주석에 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c1071ef3c60cf8dd3c256721ed0bebfd0d5200f8" translate="yes" xml:space="preserve">
          <source>Such returns (located in a lambda, but exiting the enclosing function) are called &lt;em&gt;non-local&lt;/em&gt; returns. We are used to this sort of construct in loops, which inline functions often enclose:</source>
          <target state="translated">이러한 리턴 (람다에 있지만 엔 클로징 함수를 종료)을 &lt;em&gt;로컬이 아닌&lt;/em&gt; 리턴 이라고 합니다. 인라인 함수는 종종 다음과 같은 루프 형태의 구성에 익숙합니다.</target>
        </trans-unit>
        <trans-unit id="10e6aa90785a792cb60500d5818fa4c115ff47c4" translate="yes" xml:space="preserve">
          <source>Such syntax is also known as &lt;em&gt;trailing lambda&lt;/em&gt;.</source>
          <target state="translated">이러한 구문은 &lt;em&gt;후미 람다&lt;/em&gt; 라고도 합니다.</target>
        </trans-unit>
        <trans-unit id="c8895d425ddb898eb0386c82032007c2c016e5af" translate="yes" xml:space="preserve">
          <source>Suffix to use for generated JavaScript files</source>
          <target state="translated">생성 된 JavaScript 파일에 사용할 접미사</target>
        </trans-unit>
        <trans-unit id="f20596f60d75184baac457dd39dfe5dbb7c92170" translate="yes" xml:space="preserve">
          <source>Suggested documentation pages:</source>
          <target state="translated">제안 된 문서 페이지 :</target>
        </trans-unit>
        <trans-unit id="12b71c3e0fe5f7c0b8d17cc03186e281412da4a8" translate="yes" xml:space="preserve">
          <source>Summary</source>
          <target state="translated">Summary</target>
        </trans-unit>
        <trans-unit id="efddb0d943663d3990ff15feb5144465e26709a1" translate="yes" xml:space="preserve">
          <source>Superclass for all platform classes representing numeric values.</source>
          <target state="translated">숫자 값을 나타내는 모든 플랫폼 클래스의 수퍼 클래스입니다.</target>
        </trans-unit>
        <trans-unit id="d57120c39b452641752cec548eba58dfe0d997dc" translate="yes" xml:space="preserve">
          <source>Supervision</source>
          <target state="translated">Supervision</target>
        </trans-unit>
        <trans-unit id="e8ca95dbcc7178511d7c5a9727cb4e64cd2491c0" translate="yes" xml:space="preserve">
          <source>Supervision job</source>
          <target state="translated">감독직</target>
        </trans-unit>
        <trans-unit id="b540bbae2b6598d9471d4e821a9a3c9f224811ce" translate="yes" xml:space="preserve">
          <source>Supervision scope</source>
          <target state="translated">감독 범위</target>
        </trans-unit>
        <trans-unit id="44228bb9b805267096502663a9f60eebe9337369" translate="yes" xml:space="preserve">
          <source>Support for ::foo as a shorthand for this::foo</source>
          <target state="translated">이를위한 약칭으로 :: foo 지원 :: foo</target>
        </trans-unit>
        <trans-unit id="34c6c2ddc426343eed559ce47d4c777df69eba0c" translate="yes" xml:space="preserve">
          <source>Supported platforms</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9794d24ec85271049a86498f820c37d015564882" translate="yes" xml:space="preserve">
          <source>Supported types</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="93c79b3f7d0d1a76067ccba45bb58d73cfe3316b" translate="yes" xml:space="preserve">
          <source>Suppose there is a Java method that accepts an int array of indices:</source>
          <target state="translated">int 배열을 수용하는 Java 메소드가 있다고 가정하십시오.</target>
        </trans-unit>
        <trans-unit id="0ca1c820ac8164eb818371a319e5876b522328ee" translate="yes" xml:space="preserve">
          <source>Suppose we have a generic interface &lt;code&gt;Source&amp;lt;T&amp;gt;&lt;/code&gt; that does not have any methods that take &lt;code&gt;T&lt;/code&gt; as a parameter, only methods that return &lt;code&gt;T&lt;/code&gt;:</source>
          <target state="translated">우리는 일반적인 인터페이스를 가지고 있다고 가정 &lt;code&gt;Source&amp;lt;T&amp;gt;&lt;/code&gt; 걸릴 어떤 방법이없는 그 &lt;code&gt;T&lt;/code&gt; 를 매개 변수로, 메소드 만 반환하는 &lt;code&gt;T&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="d81855372fef77a8319ba3320877e631faefc705" translate="yes" xml:space="preserve">
          <source>Suppress</source>
          <target state="translated">Suppress</target>
        </trans-unit>
        <trans-unit id="f4bf603e39de5fe14652ee5e4d5bffe13ebca851" translate="yes" xml:space="preserve">
          <source>Suppresses all compilation warnings</source>
          <target state="translated">모든 컴파일 경고를 억제합니다</target>
        </trans-unit>
        <trans-unit id="c08ada99a3ce33d336392fa9e2fcc77dd914f220" translate="yes" xml:space="preserve">
          <source>Suppresses errors about variance conflict</source>
          <target state="translated">분산 충돌에 대한 오류를 억제합니다</target>
        </trans-unit>
        <trans-unit id="826a3782b77dd21352e84fb444cfe49b2d3d41ba" translate="yes" xml:space="preserve">
          <source>Suppresses the given compilation warnings in the annotated element.</source>
          <target state="translated">주석이 달린 요소에서 주어진 컴파일 경고를 억제합니다.</target>
        </trans-unit>
        <trans-unit id="52d7c5ec374713f5f37d91138c052ccbb60ec732" translate="yes" xml:space="preserve">
          <source>Suspend functions are only allowed to be called from a coroutine or another suspend function</source>
          <target state="translated">일시 중단 기능은 코 루틴 또는 다른 일시 중단 기능에서만 호출 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ac8b279c6a3c1f3871f1125cc1498ab1f6a88def" translate="yes" xml:space="preserve">
          <source>SuspendFunction</source>
          <target state="translated">SuspendFunction</target>
        </trans-unit>
        <trans-unit id="ec4005f130005e7ee3fe9eb28e0b27154a02ee0d" translate="yes" xml:space="preserve">
          <source>Suspending functions</source>
          <target state="translated">서 스펜 딩 기능</target>
        </trans-unit>
        <trans-unit id="d52d9b4f1f762df95c3f2692f128dbd79352b8e8" translate="yes" xml:space="preserve">
          <source>Svetlana Isakova</source>
          <target state="translated">스베틀라나 이사 코바</target>
        </trans-unit>
        <trans-unit id="e1b1187bdbb9c730f8014294b12fac3d0e7be01a" translate="yes" xml:space="preserve">
          <source>Swapping two variables</source>
          <target state="translated">두 변수 교환</target>
        </trans-unit>
        <trans-unit id="112ab020698e5fc0f4baecd7821a512d8c419a69" translate="yes" xml:space="preserve">
          <source>Swift</source>
          <target state="translated">Swift</target>
        </trans-unit>
        <trans-unit id="11e426a93e6bdc30eee83310a54fe55623d59394" translate="yes" xml:space="preserve">
          <source>Swift/Objective-C classes and protocols can be subclassed with a Kotlin &lt;code&gt;final&lt;/code&gt; class. Non-&lt;code&gt;final&lt;/code&gt; Kotlin classes inheriting Swift/Objective-C types aren't supported yet, so it is not possible to declare a complex class hierarchy inheriting Swift/Objective-C types.</source>
          <target state="translated">Swift / Objective-C 클래스 및 프로토콜은 Kotlin &lt;code&gt;final&lt;/code&gt; 클래스 로 서브 클래 싱 될 수 있습니다 . Swift / Objective-C 유형을 상속하는 비 &lt;code&gt;final&lt;/code&gt; Kotlin 클래스는 아직 지원되지 않으므로 Swift / Objective-C 유형을 상속하는 복잡한 클래스 계층 구조를 선언 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="f62b613e64a0b39b8f91de500961ddd372e2c85a" translate="yes" xml:space="preserve">
          <source>Swift/Objective-C initializers are imported to Kotlin as constructors and factory methods named &lt;code&gt;create&lt;/code&gt;. The latter happens with initializers declared in the Objective-C category or as a Swift extension, because Kotlin has no concept of extension constructors.</source>
          <target state="translated">Swift / Objective-C 이니셜 라이저는 생성자 및 &lt;code&gt;create&lt;/code&gt; 라는 팩토리 메소드로 Kotlin에 가져옵니다 . 후자는 Objective-C 카테고리에서 선언 된 이니셜 라이저 또는 Swift 확장으로 발생합니다. Kotlin에는 확장 생성자 개념이 없기 때문입니다.</target>
        </trans-unit>
        <trans-unit id="9d575759176a53333f2c52896d12c38987eec991" translate="yes" xml:space="preserve">
          <source>Swift/Objective-C interop</source>
          <target state="translated">스위프트 / Objective-C interop</target>
        </trans-unit>
        <trans-unit id="99720ddc441c1bfb4d0affa1772914ca5ac04545" translate="yes" xml:space="preserve">
          <source>Switch over a channel of deferred values</source>
          <target state="translated">지연된 값의 채널로 전환</target>
        </trans-unit>
        <trans-unit id="13fd4750b81466d157a12fc10d9a852e2caf99fa" translate="yes" xml:space="preserve">
          <source>Switch to the default formatting and make it consistent with Kotlin Coding Conventions in Kotlin 1.4</source>
          <target state="translated">기본 형식으로 전환하고 Kotlin 1.4의 Kotlin 코딩 규칙과 일치하도록</target>
        </trans-unit>
        <trans-unit id="61aa80a32f7f719d3326e90ee95ac7477fe0603f" translate="yes" xml:space="preserve">
          <source>Switching to the Kotlin Coding Conventions code style can be done in &lt;code&gt;Settings &amp;rarr; Editor &amp;rarr; Code Style &amp;rarr; Kotlin&lt;/code&gt; dialog. Switch scheme to &lt;em&gt;Project&lt;/em&gt; and activate &lt;code&gt;Set from... &amp;rarr; Predefined Style &amp;rarr; Kotlin Style Guide&lt;/code&gt;.</source>
          <target state="translated">Kotlin Coding Conventions 코드 스타일로 전환하려면 &lt;code&gt;Settings &amp;rarr; Editor &amp;rarr; Code Style &amp;rarr; Kotlin&lt;/code&gt; 대화 상자 에서 수행 할 수 있습니다 . 구성표를 &lt;em&gt;프로젝트로&lt;/em&gt; 전환 하고 다음 &lt;code&gt;Set from... &amp;rarr; Predefined Style &amp;rarr; Kotlin Style Guide&lt;/code&gt; 활성화 하십시오 .</target>
        </trans-unit>
        <trans-unit id="ce89d26b5b915bdbefeba3e3c1002ad16cf04461" translate="yes" xml:space="preserve">
          <source>SymbolName</source>
          <target state="translated">SymbolName</target>
        </trans-unit>
        <trans-unit id="1c380083ceced1c7e8bbc5bd15ca13f7adc39f96" translate="yes" xml:space="preserve">
          <source>Symmetric: for any non-null values &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt;, &lt;code&gt;x.equals(y)&lt;/code&gt; should return true if and only if &lt;code&gt;y.equals(x)&lt;/code&gt; returns true.</source>
          <target state="translated">대칭은 : null 이외의 값에 &lt;code&gt;x&lt;/code&gt; 와 &lt;code&gt;y&lt;/code&gt; , &lt;code&gt;x.equals(y)&lt;/code&gt; 경우에만, true를 돌려 &lt;code&gt;y.equals(x)&lt;/code&gt; true를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="c195e4374c85d74cc43f4f08a33d51e3c51b4cfd" translate="yes" xml:space="preserve">
          <source>Synchronized</source>
          <target state="translated">Synchronized</target>
        </trans-unit>
        <trans-unit id="60526f7fe57071fddf6bf31004eca244e13fd625" translate="yes" xml:space="preserve">
          <source>Synthetic targets become inaccessible for Java sources at compile time while still being accessible for Kotlin sources. Marking target as synthetic is a binary compatible change, already compiled Java code will be able to access such target.</source>
          <target state="translated">컴파일 타임에 Java 소스에 대해 합성 대상에 액세스 할 수없고 Kotlin 소스에 계속 액세스 할 수 있습니다. 대상을 합성으로 표시하는 것은 이진 호환 변경이며 이미 컴파일 된 Java 코드는 이러한 대상에 액세스 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8426ac9483ef9329287d13cda6dbc5c5b8457b87" translate="yes" xml:space="preserve">
          <source>System-related utility functions.</source>
          <target state="translated">시스템 관련 유틸리티 기능.</target>
        </trans-unit>
        <trans-unit id="7acd3724fef694b5c77a8242b8933516bfe3f06a" translate="yes" xml:space="preserve">
          <source>TERMINATE</source>
          <target state="translated">TERMINATE</target>
        </trans-unit>
        <trans-unit id="c2024afdc51720a7b9f26bd798eeb6515dee141f" translate="yes" xml:space="preserve">
          <source>THROWN</source>
          <target state="translated">THROWN</target>
        </trans-unit>
        <trans-unit id="aec59fbfc2f6181875490fd78c020230f3b1b1f7" translate="yes" xml:space="preserve">
          <source>TITLECASE_LETTER</source>
          <target state="translated">TITLECASE_LETTER</target>
        </trans-unit>
        <trans-unit id="b698c11e84460ed5999bfeb5cbf25b865c238f3c" translate="yes" xml:space="preserve">
          <source>TODO</source>
          <target state="translated">TODO</target>
        </trans-unit>
        <trans-unit id="3a36be7757d53df34ffbc16215cd6f9cfdd93b80" translate="yes" xml:space="preserve">
          <source>TODO: changing symbol name breaks the binary compatibility, so it should probably be allowed on &lt;code&gt;internal&lt;/code&gt; and &lt;code&gt;private&lt;/code&gt; functions only.</source>
          <target state="translated">TODO : 기호 이름을 변경하면 이진 호환성이 손상되므로 &lt;code&gt;internal&lt;/code&gt; 및 &lt;code&gt;private&lt;/code&gt; 함수에서만 허용되어야 합니다.</target>
        </trans-unit>
        <trans-unit id="f3830d7277fcff42c992ea836b9ff28598687e08" translate="yes" xml:space="preserve">
          <source>TODO: consider providing an adapter instead of subtyping &lt;a href=&quot;../-c-values/index&quot;&gt;CValues&lt;/a&gt;.</source>
          <target state="translated">TODO : &lt;a href=&quot;../-c-values/index&quot;&gt;CValues를 서브 타이핑&lt;/a&gt; 하는 대신 어댑터를 제공하는 것을 고려 하십시오 .</target>
        </trans-unit>
        <trans-unit id="40b96366fe4fb7eb04dbdc7b2c5d704e03c38057" translate="yes" xml:space="preserve">
          <source>TODO: the behavior of &lt;a href=&quot;../../kotlin/-any/equals#kotlin.Any%24equals%28kotlin.Any%29&quot;&gt;equals&lt;/a&gt;, &lt;a href=&quot;../../kotlin/-any/hash-code#kotlin.Any%24hashCode%28%29&quot;&gt;hashCode&lt;/a&gt; and &lt;a href=&quot;../../kotlin/-any/to-string#kotlin.Any%24toString%28%29&quot;&gt;toString&lt;/a&gt; differs on Native and JVM backends.</source>
          <target state="translated">TODO : &lt;a href=&quot;../../kotlin/-any/equals#kotlin.Any%24equals%28kotlin.Any%29&quot;&gt;equals&lt;/a&gt; , &lt;a href=&quot;../../kotlin/-any/hash-code#kotlin.Any%24hashCode%28%29&quot;&gt;hashCode&lt;/a&gt; 및 &lt;a href=&quot;../../kotlin/-any/to-string#kotlin.Any%24toString%28%29&quot;&gt;toString&lt;/a&gt; 동작은 Native 및 JVM 백엔드에서 다릅니다.</target>
        </trans-unit>
        <trans-unit id="aa57ca5da1542535d6e595c72a1049dfaa72214c" translate="yes" xml:space="preserve">
          <source>TOP_DOWN</source>
          <target state="translated">TOP_DOWN</target>
        </trans-unit>
        <trans-unit id="6e9816a8e9d0388eecdb52866188c04e75e4b1b3" translate="yes" xml:space="preserve">
          <source>TYPE</source>
          <target state="translated">TYPE</target>
        </trans-unit>
        <trans-unit id="4f8e3ef2be07081eed30f4f241b8f6079253452d" translate="yes" xml:space="preserve">
          <source>TYPEALIAS</source>
          <target state="translated">TYPEALIAS</target>
        </trans-unit>
        <trans-unit id="74c2ff3e02a8146aa670c1188095f748d0498a87" translate="yes" xml:space="preserve">
          <source>TYPE_PARAMETER</source>
          <target state="translated">TYPE_PARAMETER</target>
        </trans-unit>
        <trans-unit id="9730d4326a7b8a0d13c2be3b7fe29b80ad152bf6" translate="yes" xml:space="preserve">
          <source>Table of Contents</source>
          <target state="translated">목차</target>
        </trans-unit>
        <trans-unit id="1a428989bd13dceabd89b698d9fa38eb8a0d175c" translate="yes" xml:space="preserve">
          <source>Table of contents</source>
          <target state="translated">목차</target>
        </trans-unit>
        <trans-unit id="321de0ab2873c1406451b4e621fed413b6b2ab1e" translate="yes" xml:space="preserve">
          <source>Tail recursive functions</source>
          <target state="translated">꼬리 재귀 함수</target>
        </trans-unit>
        <trans-unit id="20fa48deb639df41368610d6983f2e95bc62d9b3" translate="yes" xml:space="preserve">
          <source>Take a look at the behavior of the following code:</source>
          <target state="translated">다음 코드의 동작을 살펴보십시오.</target>
        </trans-unit>
        <trans-unit id="a34ab8557ec6518d7eec439be4e5bcf534a63994" translate="yes" xml:space="preserve">
          <source>Take and drop</source>
          <target state="translated">가져다 놓기</target>
        </trans-unit>
        <trans-unit id="1bbdcf12e57848561b81b3650e41362a19702c6a" translate="yes" xml:space="preserve">
          <source>Take for instance the following code</source>
          <target state="translated">다음 코드를 예로 들어 보겠습니다.</target>
        </trans-unit>
        <trans-unit id="ffc4d467faa7814fe0541133e507fd8deafa41f3" translate="yes" xml:space="preserve">
          <source>Taking the above into account, given the following code (module name is &lt;code&gt;ConsoleOutput&lt;/code&gt;)</source>
          <target state="translated">다음 코드를 고려하여 위의 내용을 고려하십시오 (모듈 이름은 &lt;code&gt;ConsoleOutput&lt;/code&gt; 입니다 )</target>
        </trans-unit>
        <trans-unit id="61ad50a9b9189cc3cf1874568e35e7901ff4c982" translate="yes" xml:space="preserve">
          <source>Target</source>
          <target state="translated">Target</target>
        </trans-unit>
        <trans-unit id="e9c2cc44a1648fab93dfd7f8478951978cee81a6" translate="yes" xml:space="preserve">
          <source>Target Platforms</source>
          <target state="translated">대상 플랫폼</target>
        </trans-unit>
        <trans-unit id="2c6651b7aa08a8550dea113571107b0c864ada23" translate="yes" xml:space="preserve">
          <source>Target platform/device</source>
          <target state="translated">대상 플랫폼 / 장치</target>
        </trans-unit>
        <trans-unit id="77c4c4b87221968bd3a3894fe9c81710e28b33b7" translate="yes" xml:space="preserve">
          <source>Target version of the generated JVM bytecode</source>
          <target state="translated">생성 된 JVM 바이트 코드의 대상 버전</target>
        </trans-unit>
        <trans-unit id="b55ed86e9766080d6e500a070b6fef6b1986cd3f" translate="yes" xml:space="preserve">
          <source>Target version of the generated JVM bytecode (1.6, 1.8, 9, 10, 11 or 12), default is 1.6</source>
          <target state="translated">생성 된 JVM 바이트 코드 (1.6, 1.8, 9, 10, 11 또는 12)의 대상 버전이며 기본값은 1.6입니다.</target>
        </trans-unit>
        <trans-unit id="b9f79302140e02579ecf20feab5f4ed0599b5178" translate="yes" xml:space="preserve">
          <source>Target-specific options, only applicable to the certain target can be specified as well, such as</source>
          <target state="translated">특정 대상에만 적용 할 수있는 대상별 옵션도 지정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="fbb726beab60fbd5d494b96dfab27818ba4ef792" translate="yes" xml:space="preserve">
          <source>Targeting Android</source>
          <target state="translated">Android 타겟팅</target>
        </trans-unit>
        <trans-unit id="61435c5519fdf6e83f5be2de5ba7d3189d1e59db" translate="yes" xml:space="preserve">
          <source>Targeting JVM with Kotlin and Java source</source>
          <target state="translated">Kotlin 및 Java 소스를 사용하여 JVM 타겟팅</target>
        </trans-unit>
        <trans-unit id="eed4cc7b25a381102c782f5eee23b1557b5da0f0" translate="yes" xml:space="preserve">
          <source>Targeting JVM with Kotlin-only source</source>
          <target state="translated">Kotlin 전용 소스로 JVM 타겟팅</target>
        </trans-unit>
        <trans-unit id="6be3f820f9efacb8a325c313968a6aa3ca133310" translate="yes" xml:space="preserve">
          <source>Targeting JVM with Kotlin-only source and multiple roots</source>
          <target state="translated">Kotlin 전용 소스 및 다중 루트를 사용하여 대상 JVM</target>
        </trans-unit>
        <trans-unit id="2426095a82998267d53648372ee8cb2c93e603c9" translate="yes" xml:space="preserve">
          <source>Targeting JavaScript</source>
          <target state="translated">자바 스크립트 타겟팅</target>
        </trans-unit>
        <trans-unit id="7e517a21f1ce2b40c420e67981cb82c90d901d12" translate="yes" xml:space="preserve">
          <source>Targeting JavaScript with Prefix, PostFix and sourcemap options</source>
          <target state="translated">접두사, PostFix 및 소스 맵 옵션으로 JavaScript 타겟팅</target>
        </trans-unit>
        <trans-unit id="af5e0c13bd0213a07d67ab13adf84941ec88763a" translate="yes" xml:space="preserve">
          <source>Targeting JavaScript with single source folder</source>
          <target state="translated">단일 소스 폴더로 JavaScript 타겟팅</target>
        </trans-unit>
        <trans-unit id="f36e6891c319487c20f8187b941dcf72379e553c" translate="yes" xml:space="preserve">
          <source>Targeting JavaScript with single source folder and metaInfo option</source>
          <target state="translated">단일 소스 폴더 및 metaInfo 옵션을 사용하여 JavaScript 타겟팅</target>
        </trans-unit>
        <trans-unit id="9057192fad6052cc02e53869d22c36d08b376824" translate="yes" xml:space="preserve">
          <source>Targeting the JVM</source>
          <target state="translated">JVM 타겟팅</target>
        </trans-unit>
        <trans-unit id="52408046d668e5c8da292f381cd0a5534e2e8a07" translate="yes" xml:space="preserve">
          <source>Targets (e.g. Linux/x64 or iOS/arm64 etc)</source>
          <target state="translated">대상 (예 : Linux / x64 또는 iOS / arm64 등)</target>
        </trans-unit>
        <trans-unit id="837e53257b3eec566bea2e67012cd4dadfb5bb32" translate="yes" xml:space="preserve">
          <source>Targets and output kinds</source>
          <target state="translated">목표 및 출력 종류</target>
        </trans-unit>
        <trans-unit id="816c9fefceb8b2eba75d842698c8c325c361d2dc" translate="yes" xml:space="preserve">
          <source>Targets can be specified by setting a corresponding component property:</source>
          <target state="translated">해당 구성 요소 특성을 설정하여 대상을 지정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ccd64eb3b2ae68576bc374a9f76f6dafc19a16b7" translate="yes" xml:space="preserve">
          <source>Teaching Kotlin with EduTools plugin</source>
          <target state="translated">EduTools 플러그인으로 Kotlin 교육</target>
        </trans-unit>
        <trans-unit id="107721a9ab514d4563cc6535734a7356bb7e6b23" translate="yes" xml:space="preserve">
          <source>Technically, there is no difference between &lt;code&gt;struct&lt;/code&gt; and &lt;code&gt;union&lt;/code&gt; types on the Kotlin side. We should note, that &lt;code&gt;a&lt;/code&gt;, &lt;code&gt;b&lt;/code&gt;, and &lt;code&gt;c&lt;/code&gt; properties of &lt;code&gt;MyUnion&lt;/code&gt; class in Kotlin use the same memory location to read/write their value just like &lt;code&gt;union&lt;/code&gt; does in C language.</source>
          <target state="translated">기술적으로 Kotlin 측의 &lt;code&gt;struct&lt;/code&gt; 유형 과 &lt;code&gt;union&lt;/code&gt; 유형 에는 차이가 없습니다 . 우리는 것을주의해야한다 &lt;code&gt;a&lt;/code&gt; , &lt;code&gt;b&lt;/code&gt; 및 &lt;code&gt;c&lt;/code&gt; 속성 &lt;code&gt;MyUnion&lt;/code&gt; 의 코 틀린의 클래스는 읽기 /처럼 자신의 가치 쓰기 같은 메모리 위치를 사용 &lt;code&gt;union&lt;/code&gt; C 언어로 수행합니다.</target>
        </trans-unit>
        <trans-unit id="1d53818b29193f314641d3739f638d9be2e9e5f4" translate="yes" xml:space="preserve">
          <source>Templates are supported both inside raw strings and inside escaped strings. If you need to represent a literal &lt;code&gt;$&lt;/code&gt; character in a raw string (which doesn't support backslash escaping), you can use the following syntax:</source>
          <target state="translated">원시 문자열 내부와 이스케이프 된 문자열 내부 모두에서 템플릿이 지원됩니다. 백 슬래시 이스케이프를 지원하지 않는 원시 문자열에서 리터럴 &lt;code&gt;$&lt;/code&gt; 문자 를 나타내야하는 경우 다음 구문을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8761082f68b3e6705f4c38bb348056fcdd9cb6dd" translate="yes" xml:space="preserve">
          <source>Terminate the evaluation of the function.</source>
          <target state="translated">기능 평가를 종료하십시오.</target>
        </trans-unit>
        <trans-unit id="bd3961165a74d22116abf8cd7dfd89e1e128faab" translate="yes" xml:space="preserve">
          <source>Terminates the currently running process.</source>
          <target state="translated">현재 실행중인 프로세스를 종료합니다.</target>
        </trans-unit>
        <trans-unit id="4640b3677ae305cdd783f2fb2cb28eef6cd34e00" translate="yes" xml:space="preserve">
          <source>Ternary-operator &lt;code&gt;a ? b : c&lt;/code&gt;</source>
          <target state="translated">삼항 연산자 &lt;code&gt;a ? b : c&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="0820b32b206b7352858e8903a838ed14319acdfd" translate="yes" xml:space="preserve">
          <source>Testing</source>
          <target state="translated">Testing</target>
        </trans-unit>
        <trans-unit id="d3b8064c2d7f14d3be517a2dd8d759b095d75329" translate="yes" xml:space="preserve">
          <source>Testing predicates</source>
          <target state="translated">테스트 술어</target>
        </trans-unit>
        <trans-unit id="082fdf5c87614574580fe601c26048e8b6285351" translate="yes" xml:space="preserve">
          <source>TexImageSource</source>
          <target state="translated">TexImageSource</target>
        </trans-unit>
        <trans-unit id="06d4a26dfeb6fe515c1bd30f6921c66e729ad5b4" translate="yes" xml:space="preserve">
          <source>TextMetrics</source>
          <target state="translated">TextMetrics</target>
        </trans-unit>
        <trans-unit id="0c0a3e3c79ed645faf27df5d40c7372e38f10e27" translate="yes" xml:space="preserve">
          <source>TextTrackCueList</source>
          <target state="translated">TextTrackCueList</target>
        </trans-unit>
        <trans-unit id="86fb1c4a335a80c40bdf3e5b1a2aadd5059a2ca7" translate="yes" xml:space="preserve">
          <source>TextTrackKind</source>
          <target state="translated">TextTrackKind</target>
        </trans-unit>
        <trans-unit id="12de6f114f3e1a86a095e86dfa5c8b68ba37ba4b" translate="yes" xml:space="preserve">
          <source>TextTrackMode</source>
          <target state="translated">TextTrackMode</target>
        </trans-unit>
        <trans-unit id="7878af5e1d970e3132e8a0a88487c501b01c97e2" translate="yes" xml:space="preserve">
          <source>That gives you a way to express queries via C#-like LINQ syntax, use lambdas to write much simpler code for asynchronous computations, and more. Read all the details &lt;a href=&quot;https://agrosner.gitbooks.io/dbflow/content/KotlinSupport.html&quot;&gt;here&lt;/a&gt;.</source>
          <target state="translated">따라서 C #과 같은 LINQ 구문을 통해 쿼리를 표현하고 람다를 사용하여 비동기 계산을위한 훨씬 간단한 코드를 작성하는 등의 방법을 제공합니다. &lt;a href=&quot;https://agrosner.gitbooks.io/dbflow/content/KotlinSupport.html&quot;&gt;여기에서&lt;/a&gt; 모든 세부 사항을 읽으 십시오 .</target>
        </trans-unit>
        <trans-unit id="0edd9421fb5e5aa8cfee7f829a8302f1e02b82ec" translate="yes" xml:space="preserve">
          <source>That is because &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/delay.html&quot;&gt;delay&lt;/a&gt; is a special &lt;em&gt;suspending function&lt;/em&gt; that does not block a thread, but &lt;em&gt;suspends&lt;/em&gt; coroutine and it can be only used from a coroutine.</source>
          <target state="translated">&lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/delay.html&quot;&gt;지연&lt;/a&gt; 은 스레드를 차단하지 않고 코 루틴을 &lt;em&gt;일시 중단&lt;/em&gt; 하는 특수 서 &lt;em&gt;스펜 딩 기능&lt;/em&gt; 이기 때문에 코 루틴에서만 사용할 수 있기 때문입니다.&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="5f1552ede00e5eac7ce32f87adbb1ebbd118c506" translate="yes" xml:space="preserve">
          <source>That is the common part. The code to generate the final message. It &lt;code&gt;expect&lt;/code&gt;s the platform to provide the platform name from the &lt;code&gt;expect fun platformName(): String&lt;/code&gt; function. We will use the &lt;code&gt;createApplicationScreenMessage&lt;/code&gt; from both Android and iOS applications.</source>
          <target state="translated">이것이 일반적인 부분입니다. 최종 메시지를 생성하는 코드입니다. 그것은 &lt;code&gt;expect&lt;/code&gt; (가)에서 플랫폼 이름 제공 할 수있는 플랫폼이야 &lt;code&gt;expect fun platformName(): String&lt;/code&gt; 함수를. Android 및 iOS 애플리케이션 모두 에서 &lt;code&gt;createApplicationScreenMessage&lt;/code&gt; 를 사용합니다 .</target>
        </trans-unit>
        <trans-unit id="2bc4829125d0242560af4ed1db4d6bbd3c58404a" translate="yes" xml:space="preserve">
          <source>That was easy, but maybe we'd want to do lazy-loading so that we won't spend time on extracting the fields that won't be used (especially if some of them contain a lot of data in a format that it is time-consuming to parse), and maybe we'd like support for default values. While we could implement that logic in a &lt;code&gt;get()&lt;/code&gt; block, it would need to be duplicated in every property. Alternatively, we could implement the logic in a separate &lt;code&gt;StringProperty&lt;/code&gt; class (note that this simple example is not thread-safe):</source>
          <target state="translated">쉬운 일이지만 사용하지 않을 필드를 추출하는 데 시간을 소비하지 않도록 지연 로딩을 원할 수도 있습니다 (특히 일부 필드에 많은 형식의 데이터가있는 경우) 구문 분석하는 데 시간이 오래 걸리고 기본값을 지원하고 싶을 수도 있습니다. &lt;code&gt;get()&lt;/code&gt; 블록 에서 해당 논리를 구현할 수는 있지만 모든 속성에서 복제해야합니다. 또는 별도의 &lt;code&gt;StringProperty&lt;/code&gt; 클래스 에서 논리를 구현할 수 있습니다 (이 간단한 예제는 스레드로부터 안전하지 않습니다).</target>
        </trans-unit>
        <trans-unit id="7c754aa21a3405ebaf37834b83155abdf27ac763" translate="yes" xml:space="preserve">
          <source>That will force the Objc header to mark &lt;code&gt;myVal&lt;/code&gt; as non-null.</source>
          <target state="translated">그러면 Objc 헤더가 &lt;code&gt;myVal&lt;/code&gt; 을 null이 아닌 것으로 표시 합니다.</target>
        </trans-unit>
        <trans-unit id="0f4622a697b62b60beae07bb6cb2be3136a91e3c" translate="yes" xml:space="preserve">
          <source>That's all! Note that &lt;code&gt;kapt&lt;/code&gt; takes care of your Java files as well, so you don't need to keep the &lt;code&gt;annotationProcessor&lt;/code&gt; dependency.</source>
          <target state="translated">그게 다야! 참고 &lt;code&gt;kapt&lt;/code&gt; 은 당신이 계속 필요가 없습니다뿐만 아니라, 자바 파일을 담당 &lt;code&gt;annotationProcessor&lt;/code&gt; 의 의존성을.</target>
        </trans-unit>
        <trans-unit id="24349cf6cc7cf7f9b384531cea8b8f5b11489c77" translate="yes" xml:space="preserve">
          <source>That's how you add the plugin in Gradle:</source>
          <target state="translated">Gradle에서 플러그인을 추가하는 방법입니다.</target>
        </trans-unit>
        <trans-unit id="736d96c876d3629aa01920322b964b507fdb9a3c" translate="yes" xml:space="preserve">
          <source>That's it, we are good to go and write code under &lt;code&gt;src/main/kotlin&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;src/main/kotlin&lt;/code&gt; 아래에 코드를 작성하는 것이 좋습니다 .</target>
        </trans-unit>
        <trans-unit id="b79f3592a2bc46aa2f1d8a2fe0f2f1a3ad0a665d" translate="yes" xml:space="preserve">
          <source>That's why the actual signature of &lt;code&gt;addAll()&lt;/code&gt; is the following:</source>
          <target state="translated">그래서 &lt;code&gt;addAll()&lt;/code&gt; 의 실제 서명은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="5cebaf2e4c811fba9f733598c7e0ab2cbbdabb01" translate="yes" xml:space="preserve">
          <source>That's why we have the following migration plan instead:</source>
          <target state="translated">따라서 다음과 같은 마이그레이션 계획이 있습니다.</target>
        </trans-unit>
        <trans-unit id="ed972239c05a1ce2160c2bcfca2e4a8ef0e2db12" translate="yes" xml:space="preserve">
          <source>The &quot;ping&quot; coroutine is started first, so it is the first one to receive the ball. Even though &quot;ping&quot; coroutine immediately starts receiving the ball again after sending it back to the table, the ball gets received by the &quot;pong&quot; coroutine, because it was already waiting for it:</source>
          <target state="translated">&quot;핑&quot;코 루틴이 먼저 시작되므로 볼을 처음으로받습니다. &quot;핑&quot;코 루틴이 공을 테이블로 다시 보낸 후 즉시 다시 공을 받기 시작하지만, &quot;퐁&quot;코 루틴이 이미 공을 기다리고 있기 때문에 공을받습니다.</target>
        </trans-unit>
        <trans-unit id="c7440a8c30ab97822c9d77fe495203fe0ef8e721" translate="yes" xml:space="preserve">
          <source>The &amp;ldquo;manual&amp;rdquo; workaround is to store the values of sub-expressions with control flow in variables, instead of evaluating them directly inside the call arguments. It&amp;rsquo;s similar to &lt;code&gt;-Xnormalize-constructor-calls=enable&lt;/code&gt;.</source>
          <target state="translated">&quot;수동&quot;해결 방법은 제어 흐름이있는 하위 표현식의 값을 호출 인수 내에서 직접 평가하는 대신 변수로 저장하는 것입니다. &lt;code&gt;-Xnormalize-constructor-calls=enable&lt;/code&gt; 과 유사합니다 .</target>
        </trans-unit>
        <trans-unit id="b2dac38fb13b33ed15d5a221ea9b31acee5a3f83" translate="yes" xml:space="preserve">
          <source>The (complete) C data type.</source>
          <target state="translated">(완료된) C 데이터 유형입니다.</target>
        </trans-unit>
        <trans-unit id="d40e2aa06e1f3081a9ba55e866548f768b24f0de" translate="yes" xml:space="preserve">
          <source>The (possibly empty) sequence of immutable C values. It is self-contained and doesn't depend on native memory.</source>
          <target state="translated">불변의 C 값의 (비어있는) 순서. 자체 포함되어 있으며 기본 메모리에 의존하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="7b6a69c655f68801070a7ea7a1009ee4bf0a261f" translate="yes" xml:space="preserve">
          <source>The 64-bit Android Native target require a Linux or macOS host. The 32-bit Android Native target can be built on any supported host.</source>
          <target state="translated">64 비트 Android Native 대상에는 Linux 또는 macOS 호스트가 필요합니다. 지원되는 모든 호스트에서 32 비트 Android Native 대상을 빌드 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="025e0471d3315a226930949e631a17bb911bf9c2" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#configuring-source-sets&quot;&gt;source sets&lt;/a&gt; and their &lt;a href=&quot;#adding-dependencies&quot;&gt;dependencies&lt;/a&gt; are then configured as follows:</source>
          <target state="translated">그런 다음 &lt;a href=&quot;#configuring-source-sets&quot;&gt;소스 세트&lt;/a&gt; 와 해당 &lt;a href=&quot;#adding-dependencies&quot;&gt;종속성&lt;/a&gt; 은 다음과 같이 구성됩니다.</target>
        </trans-unit>
        <trans-unit id="587688423378c35c59750f8053e3e7120acd7a77" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;-c-pointed/index&quot;&gt;CPointed&lt;/a&gt; without any specified interpretation.</source>
          <target state="translated">&lt;a href=&quot;-c-pointed/index&quot;&gt;CPointed&lt;/a&gt; 어떤 지정된 해석하지 않고.</target>
        </trans-unit>
        <trans-unit id="d6d7555b1e73df12c61cc2d2ea015a73f43aed2f" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;../-c-pointed/index&quot;&gt;CPointed&lt;/a&gt; without any specified interpretation.</source>
          <target state="translated">&lt;a href=&quot;../-c-pointed/index&quot;&gt;CPointed&lt;/a&gt; 어떤 지정된 해석하지 않고.</target>
        </trans-unit>
        <trans-unit id="e54545b48334a1124feb75af3b7057b37b313a69" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/minus-assign&quot;&gt;&lt;code&gt;minusAssign&lt;/code&gt;&lt;/a&gt; (&lt;code&gt;-=&lt;/code&gt;) operator is also available for mutable maps.</source>
          <target state="translated">&lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/minus-assign&quot;&gt; &lt;code&gt;minusAssign&lt;/code&gt; &lt;/a&gt; ( &lt;code&gt;-=&lt;/code&gt; ) 연산자는 가변지도를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4ff365b4410b0b6619038682a29eefb850097313" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin/-dsl-marker/index&quot;&gt;&lt;code&gt;@DslMarker&lt;/code&gt;&lt;/a&gt; annotation allows to restrict the use of receivers from outer scopes in a DSL context. Consider the canonical &lt;a href=&quot;type-safe-builders&quot;&gt;HTML builder example&lt;/a&gt;:</source>
          <target state="translated">&lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin/-dsl-marker/index&quot;&gt; &lt;code&gt;@DslMarker&lt;/code&gt; 의&lt;/a&gt; 주석은 DSL 문맥에서 외부 범위에서 수신기의 사용을 제한 할 수 있습니다. 표준 &lt;a href=&quot;type-safe-builders&quot;&gt;HTML 빌더 예제를&lt;/a&gt; 고려하십시오 .</target>
        </trans-unit>
        <trans-unit id="0ed846a235f919618387ac6874100bd335e7cf20" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;../../reference/native/c_interop&quot;&gt;C Interop documentation&lt;/a&gt; documentation covers more advanced scenarios of the interop.</source>
          <target state="translated">&lt;a href=&quot;../../reference/native/c_interop&quot;&gt;C Interop를 문서의&lt;/a&gt; 문서는 상호 운용성의 고급 시나리오를 다룹니다.</target>
        </trans-unit>
        <trans-unit id="1b6d8c3337d9451276257f3dd3c6b569bd207944" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;../tutorials/httpservlets&quot;&gt;Creating Web Applications with Http Servlets&lt;/a&gt; and &lt;a href=&quot;../tutorials/spring-boot-restful&quot;&gt;Creating a RESTful Web Service with Spring Boot&lt;/a&gt; tutorials show you how you can build and run very small Web applications in Kotlin.</source>
          <target state="translated">&lt;a href=&quot;../tutorials/httpservlets&quot;&gt;HTTP를 서블릿과 웹 응용 프로그램 생성&lt;/a&gt; 및 &lt;a href=&quot;../tutorials/spring-boot-restful&quot;&gt;봄 부트와 RESTful 웹 서비스를 만들기&lt;/a&gt; 튜토리얼 구축하고 코 틀린에 아주 작은 웹 응용 프로그램을 실행할 수있는 방법을 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="370b9ddcfe0daa7a4e64218bc3548eec2e892b70" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;building-mpp-with-gradle#adding-dependencies&quot;&gt;dependencies configuration&lt;/a&gt; has been changed; dependencies are now specified separately for each source root.</source>
          <target state="translated">&lt;a href=&quot;building-mpp-with-gradle#adding-dependencies&quot;&gt;종속성 구성이&lt;/a&gt; 변경되었다; 종속성은 이제 각 소스 루트에 대해 별도로 지정됩니다.</target>
        </trans-unit>
        <trans-unit id="269230aa3731ce52c181b4cdd4ea09cfe0397b67" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;down-to#kotlin.ranges%24downTo%28kotlin.Int%2C+kotlin.Byte%29%2Fto&quot;&gt;to&lt;/a&gt; value should be less than or equal to &lt;code&gt;this&lt;/code&gt; value. If the &lt;a href=&quot;down-to#kotlin.ranges%24downTo%28kotlin.Int%2C+kotlin.Byte%29%2Fto&quot;&gt;to&lt;/a&gt; value is greater than &lt;code&gt;this&lt;/code&gt; value the returned progression is empty.</source>
          <target state="translated">&lt;a href=&quot;down-to#kotlin.ranges%24downTo%28kotlin.Int%2C+kotlin.Byte%29%2Fto&quot;&gt;에&lt;/a&gt; 값 미만 또는 동일해야 &lt;code&gt;this&lt;/code&gt; 값. 경우 &lt;a href=&quot;down-to#kotlin.ranges%24downTo%28kotlin.Int%2C+kotlin.Byte%29%2Fto&quot;&gt;에&lt;/a&gt; 값이보다 큰 경우 &lt;code&gt;this&lt;/code&gt; 값을 돌려 진행은 비어 있습니다.</target>
        </trans-unit>
        <trans-unit id="742e049bae3776c4fe6fe85ca2d3d815ec2c3864" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;group-by-to#kotlin.sequences%24groupByTo%28kotlin.sequences.Sequence%28%28kotlin.sequences.groupByTo.T%29%29%2C+kotlin.sequences.groupByTo.M%2C+kotlin.Function1%28%28kotlin.sequences.groupByTo.T%2C+kotlin.sequences.groupByTo.K%29%29%29%2Fdestination&quot;&gt;destination&lt;/a&gt; map.</source>
          <target state="translated">&lt;a href=&quot;group-by-to#kotlin.sequences%24groupByTo%28kotlin.sequences.Sequence%28%28kotlin.sequences.groupByTo.T%29%29%2C+kotlin.sequences.groupByTo.M%2C+kotlin.Function1%28%28kotlin.sequences.groupByTo.T%2C+kotlin.sequences.groupByTo.K%29%29%29%2Fdestination&quot;&gt;대상&lt;/a&gt; 지도.</target>
        </trans-unit>
        <trans-unit id="c384276c1494f8a4d389142695a22613ee5962a0" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;group-by-to#kotlin.sequences%24groupByTo%28kotlin.sequences.Sequence%28%28kotlin.sequences.groupByTo.T%29%29%2C+kotlin.sequences.groupByTo.M%2C+kotlin.Function1%28%28kotlin.sequences.groupByTo.T%2C+kotlin.sequences.groupByTo.K%29%29%2C+kotlin.Function1%28%28kotlin.sequences.groupByTo.T%2C+kotlin.sequences.groupByTo.V%29%29%29%2Fdestination&quot;&gt;destination&lt;/a&gt; map.</source>
          <target state="translated">&lt;a href=&quot;group-by-to#kotlin.sequences%24groupByTo%28kotlin.sequences.Sequence%28%28kotlin.sequences.groupByTo.T%29%29%2C+kotlin.sequences.groupByTo.M%2C+kotlin.Function1%28%28kotlin.sequences.groupByTo.T%2C+kotlin.sequences.groupByTo.K%29%29%2C+kotlin.Function1%28%28kotlin.sequences.groupByTo.T%2C+kotlin.sequences.groupByTo.V%29%29%29%2Fdestination&quot;&gt;대상&lt;/a&gt; 지도.</target>
        </trans-unit>
        <trans-unit id="c60c5bfb4e99d5eeb15d99db1ac41367610d72e8" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;http://www.github.com/kotlin/kotlinx.html&quot;&gt;kotlinx.html library&lt;/a&gt; provides the ability to generate DOM using statically typed HTML builders. The library is available when targeting the JVM as well as JavaScript. To use the library we need to include the corresponding dependency. In the case of Gradle this would be</source>
          <target state="translated">&lt;a href=&quot;http://www.github.com/kotlin/kotlinx.html&quot;&gt;kotlinx.html 라이브러리는&lt;/a&gt; 정적으로 입력 된 HTML 빌더를 사용하여 DOM을 생성 할 수있는 기능을 제공합니다. 라이브러리는 JavaScript뿐만 아니라 JVM을 대상으로 할 때 사용할 수 있습니다. 라이브러리를 사용하려면 해당 종속성을 포함해야합니다. Gradle의 경우 이것은</target>
        </trans-unit>
        <trans-unit id="11ff0e8cd4fdb0fd27629f6a7e687a0b18080e1a" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;https://aalmiray.github.io/jsr-305/apidocs/javax/annotation/Nonnull.html&quot;&gt;&lt;code&gt;@Nonnull&lt;/code&gt;&lt;/a&gt; annotation defined in &lt;a href=&quot;https://jcp.org/en/jsr/detail?id=305&quot;&gt;JSR-305&lt;/a&gt; is supported for denoting nullability of Java types.</source>
          <target state="translated">&lt;a href=&quot;https://aalmiray.github.io/jsr-305/apidocs/javax/annotation/Nonnull.html&quot;&gt; &lt;code&gt;@Nonnull&lt;/code&gt; &lt;/a&gt; 에 정의 된 주석 &lt;a href=&quot;https://jcp.org/en/jsr/detail?id=305&quot;&gt;JSR-305은&lt;/a&gt; Java 유형의 Null 허용 여부를 나타내는 지원됩니다.</target>
        </trans-unit>
        <trans-unit id="a931a42af218b74ddfa5646228c068094e9e0035" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;https://developer.android.com/topic/libraries/data-binding/index.html&quot;&gt;Data Binding Library&lt;/a&gt; allows you to bind your application data to the layouts in a concise way.</source>
          <target state="translated">&lt;a href=&quot;https://developer.android.com/topic/libraries/data-binding/index.html&quot;&gt;데이터 바인딩 라이브러리&lt;/a&gt; 는 간결한 방식의 레이아웃에 응용 프로그램 데이터를 바인딩 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a2b7c849d9b50965b814a88b2bb1cbbfb44ead82" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;https://en.wikipedia.org/wiki/Delegation_pattern&quot;&gt;Delegation pattern&lt;/a&gt; has proven to be a good alternative to implementation inheritance, and Kotlin supports it natively requiring zero boilerplate code. A class &lt;code&gt;Derived&lt;/code&gt; can implement an interface &lt;code&gt;Base&lt;/code&gt; by delegating all of its public members to a specified object:</source>
          <target state="translated">&lt;a href=&quot;https://en.wikipedia.org/wiki/Delegation_pattern&quot;&gt;위임 패턴을&lt;/a&gt; 구현 상속에 좋은 대안이 될 입증하고 있으며, 코 틀린은 기본적으로 제로 상용구 코드를 필요로 지원합니다. &lt;code&gt;Derived&lt;/code&gt; 클래스 는 모든 공용 멤버를 지정된 객체에 위임 하여 인터페이스 &lt;code&gt;Base&lt;/code&gt; 를 구현할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="89d682e482c895868a37ff624bc3eb18d04bf269" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;https://github.com/JetBrains/kotlin-native/blob/master/INTEROP.md&quot;&gt;C Interop documentation&lt;/a&gt; documentation covers more advanced scenarios of the interop</source>
          <target state="translated">&lt;a href=&quot;https://github.com/JetBrains/kotlin-native/blob/master/INTEROP.md&quot;&gt;C Interop를 문서의&lt;/a&gt; 문서는 상호 운용성의 고급 시나리오를 커버</target>
        </trans-unit>
        <trans-unit id="1238852d879c2d710110f6784edd1cb93433787e" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;https://github.com/JetBrains/kotlin-native/blob/master/INTEROP.md&quot;&gt;C Interop documentation&lt;/a&gt; documentation covers more advanced scenarios of the interop.</source>
          <target state="translated">&lt;a href=&quot;https://github.com/JetBrains/kotlin-native/blob/master/INTEROP.md&quot;&gt;C Interop를 문서의&lt;/a&gt; 문서는 상호 운용성의 고급 시나리오를 다룹니다.</target>
        </trans-unit>
        <trans-unit id="ed3b8b8f640f1bc7c5c2be4b375d8acbd62a9be8" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.channels/-receive-channel/on-receive.html&quot;&gt;onReceive&lt;/a&gt; clause in &lt;code&gt;select&lt;/code&gt; fails when the channel is closed causing the corresponding &lt;code&gt;select&lt;/code&gt; to throw an exception. We can use &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.channels/on-receive-or-null.html&quot;&gt;onReceiveOrNull&lt;/a&gt; clause to perform a specific action when the channel is closed. The following example also shows that &lt;code&gt;select&lt;/code&gt; is an expression that returns the result of its selected clause:</source>
          <target state="translated">채널이 닫히면 &lt;code&gt;select&lt;/code&gt; 의 &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.channels/-receive-channel/on-receive.html&quot;&gt;onReceive&lt;/a&gt; 절이 실패하여 해당 &lt;code&gt;select&lt;/code&gt; 에서 예외가 발생합니다. 채널이 닫힐 때 &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.channels/on-receive-or-null.html&quot;&gt;onReceiveOrNull&lt;/a&gt; 절을 사용하여 특정 작업을 수행 할 수 있습니다 . 다음 예제는 또한 &lt;code&gt;select&lt;/code&gt; 가 선택된 절의 결과를 리턴하는 표현식임을 보여줍니다 .</target>
        </trans-unit>
        <trans-unit id="567140fae1a9d885e6f93737a3b69b522b5149e8" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-dispatchers/-unconfined.html&quot;&gt;Dispatchers.Unconfined&lt;/a&gt; coroutine dispatcher starts coroutine in the caller thread, but only until the first suspension point. After suspension it resumes in the thread that is fully determined by the suspending function that was invoked. Unconfined dispatcher is appropriate when coroutine does not consume CPU time nor updates any shared data (like UI) that is confined to a specific thread.</source>
          <target state="translated">는 &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-dispatchers/-unconfined.html&quot;&gt;Dispatchers.Unconfined&lt;/a&gt; 코 루틴 운영자 시작 호출자 스레드 코 루틴, 오직 첫 번째 정지 지점까지. 서스펜션 후 호출 된 일시 중단 기능에 의해 완전히 판별 된 스레드에서 재개됩니다. 제한되지 않은 디스패처는 코 루틴이 CPU 시간을 소비하지 않거나 특정 스레드에 국한된 공유 데이터 (예 : UI)를 업데이트하지 않는 경우에 적합합니다.</target>
        </trans-unit>
        <trans-unit id="97cb445124dce985503ca787c74149658f56ba41" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;https://kotlinlang.org/api/latest/kotlin.test/index.html&quot;&gt;&lt;code&gt;kotlin.test&lt;/code&gt; API&lt;/a&gt; is availble for multiplatform tests. Add the &lt;code&gt;kotlin-test-common&lt;/code&gt; and &lt;code&gt;kotlin-test-annotations-common&lt;/code&gt; dependencies to &lt;code&gt;commonTest&lt;/code&gt; to use the assertion functions like &lt;code&gt;kotlin.test.assertTrue(...)&lt;/code&gt;</source>
          <target state="translated">&lt;a href=&quot;https://kotlinlang.org/api/latest/kotlin.test/index.html&quot;&gt; &lt;code&gt;kotlin.test&lt;/code&gt; API는&lt;/a&gt; 멀티 플랫폼 테스트를위한 availble을합니다. &lt;code&gt;kotlin.test.assertTrue(...)&lt;/code&gt; 와 같은 어설 션 함수를 사용 하려면 &lt;code&gt;kotlin-test-common&lt;/code&gt; 및 &lt;code&gt;kotlin-test-annotations-common&lt;/code&gt; 종속성을 &lt;code&gt;commonTest&lt;/code&gt; 에 추가하십시오 .</target>
        </trans-unit>
        <trans-unit id="bf9a347ca7004344d61319e9e4d5bb8c2e75274c" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;https://ktor.io/&quot;&gt;Ktor framework&lt;/a&gt; is suitable for building asynchronous servers and clients in connected systems.</source>
          <target state="translated">&lt;a href=&quot;https://ktor.io/&quot;&gt;Ktor 프레임 워크는&lt;/a&gt; 연결된 시스템에서 비동기 서버와 클라이언트를 구축하기위한 적합합니다.</target>
        </trans-unit>
        <trans-unit id="0194a3aa4b12c9468ece4f08b6ba21815b0e08f0" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;index&quot;&gt;CPointed&lt;/a&gt; without any specified interpretation.</source>
          <target state="translated">&lt;a href=&quot;index&quot;&gt;CPointed&lt;/a&gt; 어떤 지정된 해석하지 않고.</target>
        </trans-unit>
        <trans-unit id="f1f6321a990fb305c59adcbabf8e3830cf1b87ed" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;lazy#kotlin%24lazy%28kotlin.Any%2C+kotlin.Function0%28%28kotlin.lazy.T%29%29%29%2Flock&quot;&gt;lock&lt;/a&gt; parameter is ignored.</source>
          <target state="translated">&lt;a href=&quot;lazy#kotlin%24lazy%28kotlin.Any%2C+kotlin.Function0%28%28kotlin.lazy.T%29%29%29%2Flock&quot;&gt;잠금&lt;/a&gt; 매개 변수는 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="ad29d28adce666b3b0aa95e3d086ef2150c731fc" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;lazy#kotlin%24lazy%28kotlin.LazyThreadSafetyMode%2C+kotlin.Function0%28%28kotlin.lazy.T%29%29%29%2Fmode&quot;&gt;mode&lt;/a&gt; parameter is ignored.</source>
          <target state="translated">&lt;a href=&quot;lazy#kotlin%24lazy%28kotlin.LazyThreadSafetyMode%2C+kotlin.Function0%28%28kotlin.lazy.T%29%29%29%2Fmode&quot;&gt;모드&lt;/a&gt; 매개 변수는 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="65f4a08157a599a0434e41b121c5f82c757d8345" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;minus#kotlin.collections%24minus%28kotlin.collections.Iterable%28%28kotlin.collections.minus.T%29%29%2C+kotlin.Array%28%28kotlin.collections.minus.T%29%29%29%2Felements&quot;&gt;elements&lt;/a&gt; array may be converted to a &lt;a href=&quot;-hash-set/index#kotlin.collections.HashSet&quot;&gt;HashSet&lt;/a&gt; to speed up the operation, thus the elements are required to have a correct and stable implementation of &lt;code&gt;hashCode()&lt;/code&gt; that doesn't change between successive invocations.</source>
          <target state="translated">&lt;a href=&quot;minus#kotlin.collections%24minus%28kotlin.collections.Iterable%28%28kotlin.collections.minus.T%29%29%2C+kotlin.Array%28%28kotlin.collections.minus.T%29%29%29%2Felements&quot;&gt;소자&lt;/a&gt; 어레이는 전환 될 수있다 &lt;a href=&quot;-hash-set/index#kotlin.collections.HashSet&quot;&gt;HashSet에&lt;/a&gt; 따라서 소자의 정확하고 안정적인 구현이 요구되고, 동작 속도를 &lt;code&gt;hashCode()&lt;/code&gt; 연속 호출 사이에서 변경되지 않는다.</target>
        </trans-unit>
        <trans-unit id="e24be1e2b6e9366f0d91d73c1522fb4cc61453ad" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;minus#kotlin.collections%24minus%28kotlin.collections.Iterable%28%28kotlin.collections.minus.T%29%29%2C+kotlin.collections.Iterable%28%28kotlin.collections.minus.T%29%29%29%2Felements&quot;&gt;elements&lt;/a&gt; collection may be converted to a &lt;a href=&quot;-hash-set/index#kotlin.collections.HashSet&quot;&gt;HashSet&lt;/a&gt; to speed up the operation, thus the elements are required to have a correct and stable implementation of &lt;code&gt;hashCode()&lt;/code&gt; that doesn't change between successive invocations.</source>
          <target state="translated">&lt;a href=&quot;minus#kotlin.collections%24minus%28kotlin.collections.Iterable%28%28kotlin.collections.minus.T%29%29%2C+kotlin.collections.Iterable%28%28kotlin.collections.minus.T%29%29%29%2Felements&quot;&gt;요소&lt;/a&gt; 컬렉션은 전환 될 수있다 &lt;a href=&quot;-hash-set/index#kotlin.collections.HashSet&quot;&gt;HashSet에&lt;/a&gt; 따라서 소자의 정확하고 안정적인 구현이 요구되고, 동작 속도를 &lt;code&gt;hashCode()&lt;/code&gt; 연속 호출 사이에서 변경되지 않는다.</target>
        </trans-unit>
        <trans-unit id="88eac69a24417f0a5acd408bdb0ac168d5ab84f8" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;minus#kotlin.collections%24minus%28kotlin.collections.Iterable%28%28kotlin.collections.minus.T%29%29%2C+kotlin.sequences.Sequence%28%28kotlin.collections.minus.T%29%29%29%2Felements&quot;&gt;elements&lt;/a&gt; sequence may be converted to a &lt;a href=&quot;-hash-set/index#kotlin.collections.HashSet&quot;&gt;HashSet&lt;/a&gt; to speed up the operation, thus the elements are required to have a correct and stable implementation of &lt;code&gt;hashCode()&lt;/code&gt; that doesn't change between successive invocations.</source>
          <target state="translated">&lt;a href=&quot;minus#kotlin.collections%24minus%28kotlin.collections.Iterable%28%28kotlin.collections.minus.T%29%29%2C+kotlin.sequences.Sequence%28%28kotlin.collections.minus.T%29%29%29%2Felements&quot;&gt;요소&lt;/a&gt; 서열은 전환 될 수있다 &lt;a href=&quot;-hash-set/index#kotlin.collections.HashSet&quot;&gt;HashSet에&lt;/a&gt; 따라서 소자의 정확하고 안정적인 구현이 요구되고, 동작 속도를 &lt;code&gt;hashCode()&lt;/code&gt; 연속 호출 사이에서 변경되지 않는다.</target>
        </trans-unit>
        <trans-unit id="4fdc1e3b9cc58343e5c4eb08ebf24ea334f18ce1" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;minus#kotlin.collections%24minus%28kotlin.collections.Set%28%28kotlin.collections.minus.T%29%29%2C+kotlin.Array%28%28kotlin.collections.minus.T%29%29%29%2Felements&quot;&gt;elements&lt;/a&gt; array may be converted to a &lt;a href=&quot;-hash-set/index#kotlin.collections.HashSet&quot;&gt;HashSet&lt;/a&gt; to speed up the operation, thus the elements are required to have a correct and stable implementation of &lt;code&gt;hashCode()&lt;/code&gt; that doesn't change between successive invocations.</source>
          <target state="translated">&lt;a href=&quot;minus#kotlin.collections%24minus%28kotlin.collections.Set%28%28kotlin.collections.minus.T%29%29%2C+kotlin.Array%28%28kotlin.collections.minus.T%29%29%29%2Felements&quot;&gt;소자&lt;/a&gt; 어레이는 전환 될 수있다 &lt;a href=&quot;-hash-set/index#kotlin.collections.HashSet&quot;&gt;HashSet에&lt;/a&gt; 따라서 소자의 정확하고 안정적인 구현이 요구되고, 동작 속도를 &lt;code&gt;hashCode()&lt;/code&gt; 연속 호출 사이에서 변경되지 않는다.</target>
        </trans-unit>
        <trans-unit id="00e3673225dc7616b276e346639c286afc0812ee" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;minus#kotlin.collections%24minus%28kotlin.collections.Set%28%28kotlin.collections.minus.T%29%29%2C+kotlin.collections.Iterable%28%28kotlin.collections.minus.T%29%29%29%2Felements&quot;&gt;elements&lt;/a&gt; collection may be converted to a &lt;a href=&quot;-hash-set/index#kotlin.collections.HashSet&quot;&gt;HashSet&lt;/a&gt; to speed up the operation, thus the elements are required to have a correct and stable implementation of &lt;code&gt;hashCode()&lt;/code&gt; that doesn't change between successive invocations.</source>
          <target state="translated">&lt;a href=&quot;minus#kotlin.collections%24minus%28kotlin.collections.Set%28%28kotlin.collections.minus.T%29%29%2C+kotlin.collections.Iterable%28%28kotlin.collections.minus.T%29%29%29%2Felements&quot;&gt;요소&lt;/a&gt; 컬렉션은 전환 될 수있다 &lt;a href=&quot;-hash-set/index#kotlin.collections.HashSet&quot;&gt;HashSet에&lt;/a&gt; 따라서 소자의 정확하고 안정적인 구현이 요구되고, 동작 속도를 &lt;code&gt;hashCode()&lt;/code&gt; 연속 호출 사이에서 변경되지 않는다.</target>
        </trans-unit>
        <trans-unit id="9bfb6c345d49b612f19ff9859dc63476feb3110d" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;minus#kotlin.collections%24minus%28kotlin.collections.Set%28%28kotlin.collections.minus.T%29%29%2C+kotlin.sequences.Sequence%28%28kotlin.collections.minus.T%29%29%29%2Felements&quot;&gt;elements&lt;/a&gt; sequence may be converted to a &lt;a href=&quot;-hash-set/index#kotlin.collections.HashSet&quot;&gt;HashSet&lt;/a&gt; to speed up the operation, thus the elements are required to have a correct and stable implementation of &lt;code&gt;hashCode()&lt;/code&gt; that doesn't change between successive invocations.</source>
          <target state="translated">&lt;a href=&quot;minus#kotlin.collections%24minus%28kotlin.collections.Set%28%28kotlin.collections.minus.T%29%29%2C+kotlin.sequences.Sequence%28%28kotlin.collections.minus.T%29%29%29%2Felements&quot;&gt;요소&lt;/a&gt; 서열은 전환 될 수있다 &lt;a href=&quot;-hash-set/index#kotlin.collections.HashSet&quot;&gt;HashSet에&lt;/a&gt; 따라서 소자의 정확하고 안정적인 구현이 요구되고, 동작 속도를 &lt;code&gt;hashCode()&lt;/code&gt; 연속 호출 사이에서 변경되지 않는다.</target>
        </trans-unit>
        <trans-unit id="150ad09de77efcf5d7cfbcf006b9f6b89c68e678" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;minus#kotlin.sequences%24minus%28kotlin.sequences.Sequence%28%28kotlin.sequences.minus.T%29%29%2C+kotlin.Array%28%28kotlin.sequences.minus.T%29%29%29%2Felements&quot;&gt;elements&lt;/a&gt; array may be converted to a &lt;a href=&quot;../kotlin.collections/-hash-set/index#kotlin.collections.HashSet&quot;&gt;HashSet&lt;/a&gt; to speed up the operation, thus the elements are required to have a correct and stable implementation of &lt;code&gt;hashCode()&lt;/code&gt; that doesn't change between successive invocations.</source>
          <target state="translated">&lt;a href=&quot;minus#kotlin.sequences%24minus%28kotlin.sequences.Sequence%28%28kotlin.sequences.minus.T%29%29%2C+kotlin.Array%28%28kotlin.sequences.minus.T%29%29%29%2Felements&quot;&gt;소자&lt;/a&gt; 어레이는 전환 될 수있다 &lt;a href=&quot;../kotlin.collections/-hash-set/index#kotlin.collections.HashSet&quot;&gt;HashSet에&lt;/a&gt; 따라서 소자의 정확하고 안정적인 구현이 요구되고, 동작 속도를 &lt;code&gt;hashCode()&lt;/code&gt; 연속 호출 사이에서 변경되지 않는다.</target>
        </trans-unit>
        <trans-unit id="16822a8d7e6589a06d4a74f594278b5199a4c0ac" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;minus#kotlin.sequences%24minus%28kotlin.sequences.Sequence%28%28kotlin.sequences.minus.T%29%29%2C+kotlin.collections.Iterable%28%28kotlin.sequences.minus.T%29%29%29%2Felements&quot;&gt;elements&lt;/a&gt; collection may be converted to a &lt;a href=&quot;../kotlin.collections/-hash-set/index#kotlin.collections.HashSet&quot;&gt;HashSet&lt;/a&gt; to speed up the operation, thus the elements are required to have a correct and stable implementation of &lt;code&gt;hashCode()&lt;/code&gt; that doesn't change between successive invocations.</source>
          <target state="translated">&lt;a href=&quot;minus#kotlin.sequences%24minus%28kotlin.sequences.Sequence%28%28kotlin.sequences.minus.T%29%29%2C+kotlin.collections.Iterable%28%28kotlin.sequences.minus.T%29%29%29%2Felements&quot;&gt;요소&lt;/a&gt; 컬렉션은 전환 될 수있다 &lt;a href=&quot;../kotlin.collections/-hash-set/index#kotlin.collections.HashSet&quot;&gt;HashSet에&lt;/a&gt; 따라서 소자의 정확하고 안정적인 구현이 요구되고, 동작 속도를 &lt;code&gt;hashCode()&lt;/code&gt; 연속 호출 사이에서 변경되지 않는다.</target>
        </trans-unit>
        <trans-unit id="7730285cb3f44afdb3b127e9800e2d48488fce25" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;minus#kotlin.sequences%24minus%28kotlin.sequences.Sequence%28%28kotlin.sequences.minus.T%29%29%2C+kotlin.sequences.Sequence%28%28kotlin.sequences.minus.T%29%29%29%2Felements&quot;&gt;elements&lt;/a&gt; sequence may be converted to a &lt;a href=&quot;../kotlin.collections/-hash-set/index#kotlin.collections.HashSet&quot;&gt;HashSet&lt;/a&gt; to speed up the operation, thus the elements are required to have a correct and stable implementation of &lt;code&gt;hashCode()&lt;/code&gt; that doesn't change between successive invocations.</source>
          <target state="translated">&lt;a href=&quot;minus#kotlin.sequences%24minus%28kotlin.sequences.Sequence%28%28kotlin.sequences.minus.T%29%29%2C+kotlin.sequences.Sequence%28%28kotlin.sequences.minus.T%29%29%29%2Felements&quot;&gt;요소&lt;/a&gt; 서열은 전환 될 수있다 &lt;a href=&quot;../kotlin.collections/-hash-set/index#kotlin.collections.HashSet&quot;&gt;HashSet에&lt;/a&gt; 따라서 소자의 정확하고 안정적인 구현이 요구되고, 동작 속도를 &lt;code&gt;hashCode()&lt;/code&gt; 연속 호출 사이에서 변경되지 않는다.</target>
        </trans-unit>
        <trans-unit id="6783ca375fba676e08fc3ee05e0ed3a5ef692c42" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;range#kotlin.text.MatchGroup%24range&quot;&gt;range&lt;/a&gt; property is available on JVM only.</source>
          <target state="translated">&lt;a href=&quot;range#kotlin.text.MatchGroup%24range&quot;&gt;범위&lt;/a&gt; 속성은 JVM에 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="42745a5a4bae1983528b804b1ebebed6b02c4c55" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;replace#kotlin.text%24replace%28kotlin.CharSequence%2C+kotlin.text.Regex%2C+kotlin.String%29%2Freplacement&quot;&gt;replacement&lt;/a&gt; can consist of any combination of literal text and $-substitutions. To treat the replacement string literally escape it with the &lt;a href=&quot;-regex/escape-replacement#kotlin.text.Regex.Companion%24escapeReplacement%28kotlin.String%29&quot;&gt;kotlin.text.Regex.Companion.escapeReplacement&lt;/a&gt; method.</source>
          <target state="translated">&lt;a href=&quot;replace#kotlin.text%24replace%28kotlin.CharSequence%2C+kotlin.text.Regex%2C+kotlin.String%29%2Freplacement&quot;&gt;대체&lt;/a&gt; 문자 텍스트와 $ -substitutions의 조합으로 구성 할 수 있습니다. 대체 문자열을 처리하려면 &lt;a href=&quot;-regex/escape-replacement#kotlin.text.Regex.Companion%24escapeReplacement%28kotlin.String%29&quot;&gt;kotlin.text.Regex.Companion.escapeReplacement&lt;/a&gt; 메소드 를 사용하여 대체 문자열을 이스케이프 처리하십시오 .</target>
        </trans-unit>
        <trans-unit id="95e9b2afeb8d6a526b5a01ab6cb37a3b2fbd3c86" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;!!&lt;/code&gt; Operator</source>
          <target state="translated">&lt;code&gt;!!&lt;/code&gt; 운영자</target>
        </trans-unit>
        <trans-unit id="22f7ccf0243674cea2ac7171ac3600509d7e8e7d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;-d&lt;/code&gt; option indicates what we want the output of the compiler to be called and may be either a directory name for class files or a &lt;em&gt;.jar&lt;/em&gt; file name. The &lt;code&gt;-include-runtime&lt;/code&gt; option makes the resulting &lt;em&gt;.jar&lt;/em&gt; file self-contained and runnable by including the Kotlin runtime library in it. If you want to see all available options run</source>
          <target state="translated">&lt;code&gt;-d&lt;/code&gt; 옵션은 우리가 컴파일러의 출력을 호출하고, 클래스 파일에 대한 디렉토리 이름 또는이 될 수 있습니다 원하는 것을 나타냅니다 &lt;em&gt;의 .jar&lt;/em&gt; 파일 이름. &lt;code&gt;-include-runtime&lt;/code&gt; 옵션은 결과 수 &lt;em&gt;의 .jar&lt;/em&gt; 파일 자체에 포함 된과의 코 틀린 런타임 라이브러리를 포함하여 실행 가능합니다. 사용 가능한 모든 옵션을 보려면</target>
        </trans-unit>
        <trans-unit id="c711aceaf8b8e464d66e1fd318914f03bac4786f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;-meta-info&lt;/code&gt; option indicates that an additional JS file with binary meta-information about compiled kotlin code will be created.</source>
          <target state="translated">&lt;code&gt;-meta-info&lt;/code&gt; 옵션은 컴파일 코 틀린 코드에 대한 이진 메타 정보를 추가 JS 파일이 생성된다는 것을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="dc6b8236cb90f6f8fe4324f1a0dc0ef9b906294c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;.def&lt;/code&gt; file supports several options for adjusting the generated bindings.</source>
          <target state="translated">&lt;code&gt;.def&lt;/code&gt; 파일이 생성 된 바인딩을 조정하기위한 몇 가지 옵션을 지원합니다.</target>
        </trans-unit>
        <trans-unit id="73f8a4adb6a430053e582f21a1ecd992b4948729" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;.pointed&lt;/code&gt; property for &lt;code&gt;CPointer&amp;lt;T&amp;gt;&lt;/code&gt; returns the lvalue of type &lt;code&gt;T&lt;/code&gt;, pointed by this pointer. The reverse operation is &lt;code&gt;.ptr&lt;/code&gt;: it takes the lvalue and returns the pointer to it.</source>
          <target state="translated">&lt;code&gt;CPointer&amp;lt;T&amp;gt;&lt;/code&gt; 의 &lt;code&gt;.pointed&lt;/code&gt; 속성은 이 포인터가 가리키는 &lt;code&gt;T&lt;/code&gt; 유형의 lvalue를 반환합니다 . 역 연산은 &lt;code&gt;.ptr&lt;/code&gt; 입니다 . lvalue를 가져 와서 포인터를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="6d8b85d101ff4f2f1b24686adcfb710c9930ca1c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;==&lt;/code&gt; operation is special: it is translated to a complex expression that screens for &lt;code&gt;null&lt;/code&gt;'s. &lt;code&gt;null == null&lt;/code&gt; is always true, and &lt;code&gt;x == null&lt;/code&gt; for a non-null &lt;code&gt;x&lt;/code&gt; is always false and won't invoke &lt;code&gt;x.equals()&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;==&lt;/code&gt; 의 작업은 특별하다 : 그것은 복잡한 표현 그에 대한 화면으로 변환된다 &lt;code&gt;null&lt;/code&gt; '의. &lt;code&gt;null == null&lt;/code&gt; 항상 true이고, &lt;code&gt;x == null&lt;/code&gt; null이 아닌에 대한 &lt;code&gt;x&lt;/code&gt; 항상 false입니다하지 않습니다 호출 &lt;code&gt;x.equals()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6bbc4d74ec596791bf71057157cc072f9f40333d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;@BindView&lt;/code&gt; annotation is defined to be applied to the fields only, but the Kotlin compiler understands that and annotates the corresponding field under the hood when you apply the annotation to the whole property.</source>
          <target state="translated">&lt;code&gt;@BindView&lt;/code&gt; 의 주석 만 필드에 적용되는 정의하지만, 코 틀린 컴파일러는 그것을 이해하고 전체 속성에 주석을 적용 할 때 후드 아래에 해당 필드에 주석된다.</target>
        </trans-unit>
        <trans-unit id="1df3c0a179e9e6af77acfff08df64cc5248d7f9d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;@JvmDefault&lt;/code&gt; annotation is experimental in Kotlin 1.3. Its name and behavior may change, leading to future incompatibility.</source>
          <target state="translated">&lt;code&gt;@JvmDefault&lt;/code&gt; 의 주석 코 틀린 1.3 실험이다. 이름과 동작이 변경되어 나중에 호환되지 않을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="23f0d6b7e361daa5f829cff80c17a1080ce0221f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;@UnderMigration&lt;/code&gt; annotation (provided in a separate artifact &lt;code&gt;kotlin-annotations-jvm&lt;/code&gt;) can be used by library maintainers to define the migration status for the nullability type qualifiers.</source>
          <target state="translated">&lt;code&gt;@UnderMigration&lt;/code&gt; 의 (별도의 이슈에 제공된 주석 &lt;code&gt;kotlin-annotations-jvm&lt;/code&gt; ) Null 허용 형 한정자에 대한 이전 상태를 정의하는 라이브러리 관리자들에 의해 사용될 수있다.</target>
        </trans-unit>
        <trans-unit id="bb1328f13d2922d7a316403f81e7c018a9247b4a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;CValuesRef&amp;lt;T&amp;gt;&lt;/code&gt; representation of pointer parameters is designed to support C array literals without explicit native memory allocation. To construct the immutable self-contained sequence of C values, the following methods are provided:</source>
          <target state="translated">포인터 매개 변수 의 &lt;code&gt;CValuesRef&amp;lt;T&amp;gt;&lt;/code&gt; 표현은 명시 적 기본 메모리 할당없이 C 배열 리터럴을 지원하도록 설계되었습니다. 불변의 자체 포함 된 C 값 시퀀스를 구성하기 위해 다음 방법이 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="a1a03d0c25bc5cefc6e2a073c0dfa2fd3a424a42" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Closeable.use&lt;/code&gt; function calls &lt;code&gt;Throwable.addSuppressed&lt;/code&gt; when an exception is thrown during closing the resource after some other exception.</source>
          <target state="translated">&lt;code&gt;Closeable.use&lt;/code&gt; 의 함수 호출은 &lt;code&gt;Throwable.addSuppressed&lt;/code&gt; 예외가 다른 예외 후 자원을 닫는 동안 발생하는 경우.</target>
        </trans-unit>
        <trans-unit id="a0327626fcb95882f9434dd6a1485603acf809a0" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;MyStruct&lt;/code&gt; and &lt;code&gt;MyUnion&lt;/code&gt; classes have the pointer to the native memory underneath. The memory will be released when a &lt;code&gt;memScoped&lt;/code&gt; function ends, which is equal to the end of its &lt;code&gt;block&lt;/code&gt;. Be careful to make sure that a pointer is not used outside of the &lt;code&gt;memScoped&lt;/code&gt; call. We may use &lt;code&gt;Arena()&lt;/code&gt; or &lt;code&gt;nativeHeap&lt;/code&gt; for pointers that should be available longer, or are cached inside a C library.</source>
          <target state="translated">&lt;code&gt;MyStruct&lt;/code&gt; 및 &lt;code&gt;MyUnion&lt;/code&gt; 클래스는 기본 메모리 아래에 포인터를 가지고있다. 메모리는 &lt;code&gt;memScoped&lt;/code&gt; 함수가 종료 될 때 해제 되며 이는 &lt;code&gt;block&lt;/code&gt; 의 끝과 같습니다 . &lt;code&gt;memScoped&lt;/code&gt; 호출 외부에서 포인터를 사용하지 않도록주의하십시오 . 우리는 사용할 수 있습니다 &lt;code&gt;Arena()&lt;/code&gt; 또는 &lt;code&gt;nativeHeap&lt;/code&gt; 를 더 이상 사용할 수 있어야 또는 C 라이브러리 내부 캐시 대한 포인터.</target>
        </trans-unit>
        <trans-unit id="e1e663158ad35ab7b0074a2786efe149637f58ae" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;SharedCode/build.gradle&lt;/code&gt; file uses the &lt;code&gt;kotlin-multiplatform&lt;/code&gt; plugin to implement what we need. In the file, we define several targets &lt;code&gt;common&lt;/code&gt;, &lt;code&gt;android&lt;/code&gt;, and &lt;code&gt;iOS&lt;/code&gt;. Each target has its own platform. The &lt;code&gt;common&lt;/code&gt; target contains the Kotlin common code which is included into every platform compilation. It is allowed to have &lt;code&gt;expect&lt;/code&gt; declarations. Other targets provide &lt;code&gt;actual&lt;/code&gt; implementations for all &lt;code&gt;expect&lt;/code&gt;-actions from the &lt;code&gt;common&lt;/code&gt; target. The more detailed explanation of the multiplatform projects can be found on the &lt;a href=&quot;../../reference/building-mpp-with-gradle&quot;&gt;Multiplatform Projects&lt;/a&gt; documentation page.</source>
          <target state="translated">&lt;code&gt;SharedCode/build.gradle&lt;/code&gt; 의 파일은 사용 &lt;code&gt;kotlin-multiplatform&lt;/code&gt; 우리가 필요로하는 것을 구현하는 플러그인. 이 파일에서 &lt;code&gt;common&lt;/code&gt; , &lt;code&gt;android&lt;/code&gt; 및 &lt;code&gt;iOS&lt;/code&gt; 여러 대상을 정의 합니다. 각 대상에는 고유 한 플랫폼이 있습니다. &lt;code&gt;common&lt;/code&gt; 목표는 모든 플랫폼 컴파일에 포함되어있는 코 틀린 공통 코드가 포함되어 있습니다. 선언 을 &lt;code&gt;expect&lt;/code&gt; 수 있습니다 . 다른 목표 는 &lt;code&gt;common&lt;/code&gt; 목표 의 모든 &lt;code&gt;expect&lt;/code&gt; 조치에 대한 &lt;code&gt;actual&lt;/code&gt; 구현을 제공합니다 . 멀티 플랫폼 프로젝트에 대한 자세한 설명은 멀티 &lt;a href=&quot;../../reference/building-mpp-with-gradle&quot;&gt;플랫폼 프로젝트&lt;/a&gt; 문서 페이지 에서 찾을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="ef805264d2ba0e69f1525612b2097c56c9b79a21" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;SharedCode&lt;/code&gt; build generates iOS frameworks for use with the Xcode project. All frameworks are in the &lt;code&gt;SharedCode/build/bin&lt;/code&gt; folder. It creates a &lt;em&gt;debug&lt;/em&gt; and &lt;em&gt;release&lt;/em&gt; version for every framework target. The frameworks are in the following paths:</source>
          <target state="translated">&lt;code&gt;SharedCode&lt;/code&gt; 의 빌드는 Xcode 프로젝트에 사용하기 위해 아이폰 OS 프레임 워크를 생성합니다. 모든 프레임 워크는 &lt;code&gt;SharedCode/build/bin&lt;/code&gt; 폴더에 있습니다. 모든 프레임 워크 대상에 대한 &lt;em&gt;디버그&lt;/em&gt; 및 &lt;em&gt;릴리스&lt;/em&gt; 버전을 작성합니다 . 프레임 워크는 다음 경로에 있습니다.</target>
        </trans-unit>
        <trans-unit id="49918eac55ef5c9d9df4be1f8508374502fa5919" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;SharedCode&lt;/code&gt; sub-project should generate several artifacts for us:</source>
          <target state="translated">&lt;code&gt;SharedCode&lt;/code&gt; 의 하위 프로젝트는 우리에게 여러 아티팩트를 생성한다 :</target>
        </trans-unit>
        <trans-unit id="738861947c8af30bd4668ff2083f0544a8963e87" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;String&lt;/code&gt; class represents character strings. All string literals in Kotlin programs, such as &lt;code&gt;&quot;abc&quot;&lt;/code&gt;, are implemented as instances of this class.</source>
          <target state="translated">&lt;code&gt;String&lt;/code&gt; 클래스는 캐릭터 라인을 나타냅니다. &lt;code&gt;&quot;abc&quot;&lt;/code&gt; 와 같은 Kotlin 프로그램의 모든 문자열 리터럴 은이 클래스의 인스턴스로 구현됩니다.</target>
        </trans-unit>
        <trans-unit id="1109231b443cf6e05eb0d002d1e6b58cba8574e8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;TimeoutCancellationException&lt;/code&gt; that is thrown by &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/with-timeout.html&quot;&gt;withTimeout&lt;/a&gt; is a subclass of &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-cancellation-exception/index.html&quot;&gt;CancellationException&lt;/a&gt;. We have not seen its stack trace printed on the console before. That is because inside a cancelled coroutine &lt;code&gt;CancellationException&lt;/code&gt; is considered to be a normal reason for coroutine completion. However, in this example we have used &lt;code&gt;withTimeout&lt;/code&gt; right inside the &lt;code&gt;main&lt;/code&gt; function.</source>
          <target state="translated">&lt;code&gt;TimeoutCancellationException&lt;/code&gt; 에 의해 발생합니다 &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/with-timeout.html&quot;&gt;withTimeout는&lt;/a&gt; 의 서브 클래스입니다 &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-cancellation-exception/index.html&quot;&gt;CancellationException&lt;/a&gt; . 콘솔에 스택 추적이 인쇄 된 것을 본 적이 없습니다. 취소 된 코 루틴 내부 &lt;code&gt;CancellationException&lt;/code&gt; 이 코 루틴 완료의 일반적인 이유로 간주되기 때문입니다. 그러나이 예제 에서는 &lt;code&gt;main&lt;/code&gt; 함수 내에서 &lt;code&gt;withTimeout&lt;/code&gt; 을 사용 했습니다 .</target>
        </trans-unit>
        <trans-unit id="678b280d532baa9bcd8fba06428fcb263e6a4bcd" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Unit&lt;/code&gt; return type declaration is also optional. The above code is equivalent to:</source>
          <target state="translated">&lt;code&gt;Unit&lt;/code&gt; 반환 형식 선언은 선택 사항입니다. 위 코드는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="bb48ced54ff1266406f8ddf62204246a87b046d9" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;array.copyInto(targetArray, targetOffset, startIndex, endIndex)&lt;/code&gt; functions for the existing array types, including the unsigned arrays, make it easier to implement array-based containers in pure Kotlin.</source>
          <target state="translated">&lt;code&gt;array.copyInto(targetArray, targetOffset, startIndex, endIndex)&lt;/code&gt; 서명되지 않은 배열을 포함하여 기존 배열 유형에 대한 기능은 쉽게 순수 코 틀린에 배열 기반 컨테이너를 구현 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a6d3c63b724a00a7b22c190a90ba3fb846402424" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;catch&lt;/code&gt; blocks are tried in order until an exception type is found that matches the thrown exception (it doesn't need to be an exact match; the thrown exception's class can be a subclass of the declared one), and at most one &lt;code&gt;catch&lt;/code&gt; block will be executed. If no match is found, the exception bubbles out of the &lt;code&gt;try&lt;/code&gt;/&lt;code&gt;catch&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;catch&lt;/code&gt; 블록은 예외 유형이 일치가 발생한 예외 발견 될 때까지 순서대로 시도됩니다 (이 정확히 일치 할 필요는 없습니다; throw 된 예외의 클래스의 서브 클래스가 될 수있는 하나의 선언), 대부분 하나의 &lt;code&gt;catch&lt;/code&gt; 블록 실행됩니다. 일치하는 것이 없으면 &lt;code&gt;try&lt;/code&gt; / &lt;code&gt;catch&lt;/code&gt; 에서 예외가 발생합니다 .</target>
        </trans-unit>
        <trans-unit id="c0fef9a879817509a3ced8499c0b86da8348957d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;component1()&lt;/code&gt; and &lt;code&gt;component2()&lt;/code&gt; functions are another example of the &lt;em&gt;principle of conventions&lt;/em&gt; widely used in Kotlin (see operators like &lt;code&gt;+&lt;/code&gt; and &lt;code&gt;*&lt;/code&gt;, &lt;em&gt;for&lt;/em&gt;-loops etc.). Anything can be on the right-hand side of a destructuring declaration, as long as the required number of component functions can be called on it. And, of course, there can be &lt;code&gt;component3()&lt;/code&gt; and &lt;code&gt;component4()&lt;/code&gt; and so on.</source>
          <target state="translated">&lt;code&gt;component1()&lt;/code&gt; 및 &lt;code&gt;component2()&lt;/code&gt; 함수의 다른 예이다 &lt;em&gt;규칙의 원리&lt;/em&gt; (같은 연산자 참조 널리 코 틀린에 사용 &lt;code&gt;+&lt;/code&gt; 및 &lt;code&gt;*&lt;/code&gt; , &lt;em&gt;대&lt;/em&gt; -loops 등). 필요한 수의 구성 요소 함수를 호출 할 수있는 한, 어떤 것이라도 파괴 선언의 오른쪽에있을 수 있습니다. 물론 &lt;code&gt;component3()&lt;/code&gt; 및 &lt;code&gt;component4()&lt;/code&gt; 등 이있을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="c908c6361f3f878795986cf1aacec3df19a47af2" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;componentN()&lt;/code&gt; operator functions are not called for the components that are skipped in this way.</source>
          <target state="translated">&lt;code&gt;componentN()&lt;/code&gt; 연산자 기능은 이러한 방식으로 스킵되는 성분을 요구하지 않는다.</target>
        </trans-unit>
        <trans-unit id="7d4ca598e9322020fabb7ed0f0cf080beed5a640" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;dynamic&lt;/code&gt; type basically turns off Kotlin's type checker:</source>
          <target state="translated">&lt;code&gt;dynamic&lt;/code&gt; 유형은 기본적으로 코 틀린의 형태 검사기 해제합니다 :</target>
        </trans-unit>
        <trans-unit id="51e19e38be808ad0fddd91d78f8820fc196fada7" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;external&lt;/code&gt; modifier</source>
          <target state="translated">&lt;code&gt;external&lt;/code&gt; 개질제</target>
        </trans-unit>
        <trans-unit id="6672d0616428f2de367eecabae3ac9b311e7f971" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;external&lt;/code&gt; modifier is only allowed on package-level declarations. You can't declare an &lt;code&gt;external&lt;/code&gt; member of a non-&lt;code&gt;external&lt;/code&gt; class.</source>
          <target state="translated">&lt;code&gt;external&lt;/code&gt; 수정은 패키지 수준의 선언에 허용됩니다. 당신은 선언 할 수 없습니다 &lt;code&gt;external&lt;/code&gt; 비의 멤버 &lt;code&gt;external&lt;/code&gt; 클래스를.</target>
        </trans-unit>
        <trans-unit id="3b6dae5981e61870a0a711096ca1cc69db0e7e4d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;field&lt;/code&gt; identifier can only be used in the accessors of the property.</source>
          <target state="translated">&lt;code&gt;field&lt;/code&gt; 식별자 만이 건물의 접근에 사용될 수있다.</target>
        </trans-unit>
        <trans-unit id="a8755ff22ac11729e9e1bb025cf0c2f08d13b24b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;finally&lt;/code&gt; block (if any) is executed at the end, no matter what the outcome is: either after the try block completes successfully, or after a catch block is executed (even if another exception is thrown by the catch block), or if no matching catch is found.</source>
          <target state="translated">은 &lt;code&gt;finally&lt;/code&gt; 끝에서 실행됩니다 (있는 경우) 차단, 아무리 결과가 무엇 : 중 하나를 성공적으로 try 블록이 완료된 후, 또는 catch 블록이 (다른 예외가 catch 블록에 의해 발생되는 경우에도) 실행 된 후, 또는 경우 일치하는 캐치를 찾을 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="6e147b02bdfa0081a311ca1a27d8c44534b54856" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;head&lt;/code&gt; and &lt;code&gt;body&lt;/code&gt; functions in the &lt;code&gt;HTML&lt;/code&gt; class are defined similarly to &lt;code&gt;html&lt;/code&gt;. The only difference is that they add the built instances to the &lt;code&gt;children&lt;/code&gt; collection of the enclosing &lt;code&gt;HTML&lt;/code&gt; instance:</source>
          <target state="translated">&lt;code&gt;HTML&lt;/code&gt; 클래스 의 &lt;code&gt;head&lt;/code&gt; 및 &lt;code&gt;body&lt;/code&gt; 함수는 &lt;code&gt;html&lt;/code&gt; 과 유사하게 정의됩니다 . 유일한 차이점은 빌드 된 인스턴스를 둘러싸는 &lt;code&gt;HTML&lt;/code&gt; 인스턴스 의 &lt;code&gt;children&lt;/code&gt; 컬렉션에 추가한다는 것입니다 .</target>
        </trans-unit>
        <trans-unit id="770f5ab17d8a9531f1b79df0e83aa540310bf343" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;import&lt;/code&gt; keyword is not restricted to importing classes; you can also use it to import other declarations:</source>
          <target state="translated">&lt;code&gt;import&lt;/code&gt; 키워드는 클래스를 가져 오기에 제한되지 않는다; 다른 선언을 가져 오기 위해 사용할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="41a9e375e0ec0d5188379910e6d4cc759d4c0ed4" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;inc()&lt;/code&gt; and &lt;code&gt;dec()&lt;/code&gt; functions must return a value, which will be assigned to the variable on which the &lt;code&gt;++&lt;/code&gt; or &lt;code&gt;--&lt;/code&gt; operation was used. They shouldn't mutate the object on which the &lt;code&gt;inc&lt;/code&gt; or &lt;code&gt;dec&lt;/code&gt; was invoked.</source>
          <target state="translated">&lt;code&gt;inc()&lt;/code&gt; 및 &lt;code&gt;dec()&lt;/code&gt; 함수가되는 변수에 할당 될 값을 반환해야 &lt;code&gt;++&lt;/code&gt; 또는 &lt;code&gt;--&lt;/code&gt; 연산이 사용되었다. &lt;code&gt;inc&lt;/code&gt; 또는 &lt;code&gt;dec&lt;/code&gt; 가 호출 된 객체를 변경해서는 안됩니다 .</target>
        </trans-unit>
        <trans-unit id="2a8bc7470da685195a735f122f1c7a64a5a63c8b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;inline&lt;/code&gt; modifier affects both the function itself and the lambdas passed to it: all of those will be inlined into the call site.</source>
          <target state="translated">&lt;code&gt;inline&lt;/code&gt; 함수 자체와 전달 된 람다 모두에 영향을 미칩니다 수정 : 그 모두는 호출 사이트에 인라인됩니다.</target>
        </trans-unit>
        <trans-unit id="4c1794e25137b28059a2347a21857b9a05912426" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;inline&lt;/code&gt; modifier can be used on accessors of properties that don't have a backing field. You can annotate individual property accessors:</source>
          <target state="translated">&lt;code&gt;inline&lt;/code&gt; 수정은 백업 필드가없는 속성의 접근에 사용할 수 있습니다. 개별 속성 접근 자에 주석을 달 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2e8761b1965ac33697b654aacb6b2483099da851" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;internal&lt;/code&gt; visibility modifier means that the member is visible within the same module. More specifically, a module is a set of Kotlin files compiled together:</source>
          <target state="translated">&lt;code&gt;internal&lt;/code&gt; 멤버가 동일한 모듈 내 보이는 가시성 수정 방법. 보다 구체적으로, 모듈은 함께 컴파일 된 Kotlin 파일 세트입니다.</target>
        </trans-unit>
        <trans-unit id="5524830c2792b87628c40ec57ff6cb705892ec15" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;interop.def&lt;/code&gt; file is enough to compile and run the application or open it in an IDE. Now it is time to create project files, open the project in &lt;a href=&quot;https://jetbrains.com/idea&quot;&gt;IntelliJ IDEA&lt;/a&gt; and run it.</source>
          <target state="translated">&lt;code&gt;interop.def&lt;/code&gt; 파일을 컴파일하고 응용 프로그램을 실행하거나 IDE에서 엽니 충분하다. 이제 프로젝트 파일을 생성하고 &lt;a href=&quot;https://jetbrains.com/idea&quot;&gt;IntelliJ IDEA&lt;/a&gt; 에서 프로젝트를 열고 실행해야합니다.</target>
        </trans-unit>
        <trans-unit id="44ba6fd4ed404417523557c04ecd859c9b045fe5" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;kotlin-multiplatform&lt;/code&gt; plugin also uses configurations under the hood but it also provides a &lt;code&gt;dependencies&lt;/code&gt; block for each source set allowing configuring dependencies of this sources set:</source>
          <target state="translated">&lt;code&gt;kotlin-multiplatform&lt;/code&gt; 플러그인은 후드 아래 구성을 사용하지만 그것은 또한 제공 &lt;code&gt;dependencies&lt;/code&gt; 설정이 소스의 구성 종속성을 허용하는 각 소스 세트에 대한 차단 :</target>
        </trans-unit>
        <trans-unit id="adb02342d7ce602f18e1bc8edea76f179234a358" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;kotlin.js&lt;/code&gt; file should be referenced first as it is used by our application</source>
          <target state="translated">&lt;code&gt;kotlin.js&lt;/code&gt; 이 우리의 응용 프로그램에서 사용되는 파일을 먼저 참조해야한다</target>
        </trans-unit>
        <trans-unit id="d33f6d3213f1661b13836e07ebfe17d21d08c317" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;kotlin.text.Regex&lt;/code&gt; class has become &lt;code&gt;Serializable&lt;/code&gt; and can now be used in serializable hierarchies.</source>
          <target state="translated">&lt;code&gt;kotlin.text.Regex&lt;/code&gt; 의 클래스가되었다 &lt;code&gt;Serializable&lt;/code&gt; 지금 직렬화 계층에서 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3bdd0dba3711de41e882257acdc9d6c6d0be76b9" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;lateinit&lt;/code&gt; modifier can now be used on top-level properties and local variables. The latter can be used, for example, when a lambda passed as a constructor argument to one object refers to another object which has to be defined later:</source>
          <target state="translated">&lt;code&gt;lateinit&lt;/code&gt; 개질제 해주기 최상위 특성 및 로컬 변수를 사용할 수있다. 후자는 예를 들어 한 객체에 생성자 인수로 전달 된 람다는 나중에 정의해야하는 다른 객체를 참조 할 때 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="43331c82f7829c2da5f8833182cec47167e9b99d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;libnative&lt;/code&gt; is used as the library name, the generated header file name prefix. It is also prefixes all declarations in the header file.</source>
          <target state="translated">&lt;code&gt;libnative&lt;/code&gt; 은 라이브러리 이름, 생성 된 헤더 파일 이름 접두어로 사용됩니다. 또한 헤더 파일의 모든 선언 앞에 붙습니다.</target>
        </trans-unit>
        <trans-unit id="bbfbe4356895f41e445e2fe6cf1eee9c6b52bcaf" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;libnative_ExportedSymbols&lt;/code&gt; structure contains several helper functions:</source>
          <target state="translated">&lt;code&gt;libnative_ExportedSymbols&lt;/code&gt; 의 구조는 여러 도우미 기능이 포함되어 있습니다</target>
        </trans-unit>
        <trans-unit id="31fcc81919bad97de24dff6463d9620cad90a047" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;log&lt;/code&gt; function prints the name of the thread in square brackets and you can see, that it is the &lt;code&gt;main&lt;/code&gt; thread, but the identifier of the currently executing coroutine is appended to it. This identifier is consecutively assigned to all created coroutines when debugging mode is turned on.</source>
          <target state="translated">&lt;code&gt;log&lt;/code&gt; 는 것을, 기능은 대괄호 스레드의 이름을 인쇄하고 당신이 볼 수있는 &lt;code&gt;main&lt;/code&gt; 스레드하지만, 현재 실행중인 코 루틴의 식별자가 추가됩니다. 이 식별자는 디버깅 모드가 켜져있을 때 생성 된 모든 코 루틴에 연속적으로 할당됩니다.</target>
        </trans-unit>
        <trans-unit id="3230b15e19fadbbe8582fc37fac536f21d903134" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;memoizedFoo&lt;/code&gt; variable will be computed on the first access only. If &lt;code&gt;someCondition&lt;/code&gt; fails, the variable won't be computed at all.</source>
          <target state="translated">&lt;code&gt;memoizedFoo&lt;/code&gt; 의 변수는 제 1 액세스에서만 연산한다. 경우 &lt;code&gt;someCondition&lt;/code&gt; 이 실패 변수는 전혀 계산되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="33d6683731510016eab36ef3fe8c81b5c054cb1c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;metaInfo&lt;/code&gt; option is useful, if you want to distribute the result of translation as a Kotlin/JavaScript library. If &lt;code&gt;metaInfo&lt;/code&gt; was set to &lt;code&gt;true&lt;/code&gt;, then during compilation additional JS file with binary metadata will be created. This file should be distributed together with the result of translation:</source>
          <target state="translated">&lt;code&gt;metaInfo&lt;/code&gt; 당신이 코 틀린 / 자바 스크립트 라이브러리로 변환의 결과를 배포 할 경우 옵션은 유용합니다. &lt;code&gt;metaInfo&lt;/code&gt; 가 &lt;code&gt;true&lt;/code&gt; 로 설정된 경우 컴파일 중에 이진 메타 데이터가있는 추가 JS 파일이 작성됩니다. 이 파일은 번역 결과와 함께 배포되어야합니다.</target>
        </trans-unit>
        <trans-unit id="ef6518091f136fea33cc33006301200c71352567" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;mod&lt;/code&gt; operator is now deprecated, and &lt;code&gt;rem&lt;/code&gt; is used instead. See &lt;a href=&quot;https://youtrack.jetbrains.com/issue/KT-14650&quot;&gt;this issue&lt;/a&gt; for motivation.</source>
          <target state="translated">이제 &lt;code&gt;mod&lt;/code&gt; 연산자가 더 이상 사용되지 않으며 대신 &lt;code&gt;rem&lt;/code&gt; 이 사용됩니다. 동기 부여에 대해서는 &lt;a href=&quot;https://youtrack.jetbrains.com/issue/KT-14650&quot;&gt;이 문제&lt;/a&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="8110b7b8d3687de9aeddaa2e0ee4cc0fcd8589ef" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;provideDelegate&lt;/code&gt; method is called for each property during the creation of the &lt;code&gt;MyUI&lt;/code&gt; instance, and it performs the necessary validation right away.</source>
          <target state="translated">&lt;code&gt;provideDelegate&lt;/code&gt; 의 방법은 생성 동안 각 속성이라고 &lt;code&gt;MyUI&lt;/code&gt; 의 경우, 그것은 즉시 필요한 검증을 수행한다.</target>
        </trans-unit>
        <trans-unit id="553371a8f2ee3223a5555190c34ffafc9965ea1c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;provideDelegate&lt;/code&gt; method will be called for each property during the creation of a &lt;code&gt;MyUI&lt;/code&gt; instance, and it can perform the necessary validation right away.</source>
          <target state="translated">&lt;code&gt;provideDelegate&lt;/code&gt; 의 방법은 생성시 각 속성에 대해 호출됩니다 &lt;code&gt;MyUI&lt;/code&gt; 의 예, 그것은 바로 필요한 유효성 검사를 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3ced8435cd27ad8472273c2b70edbb4e6fae0033" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;strict&lt;/code&gt;, &lt;code&gt;warn&lt;/code&gt; and &lt;code&gt;ignore&lt;/code&gt; values have the same meaning as those of &lt;code&gt;MigrationStatus&lt;/code&gt;, and only the &lt;code&gt;strict&lt;/code&gt; mode affects the types in the annotated declarations as they are seen in Kotlin.</source>
          <target state="translated">&lt;code&gt;strict&lt;/code&gt; , &lt;code&gt;warn&lt;/code&gt; 및 &lt;code&gt;ignore&lt;/code&gt; 값과 동일한 의미가 &lt;code&gt;MigrationStatus&lt;/code&gt; 을 , 만 &lt;code&gt;strict&lt;/code&gt; 모드가 코 틀린에 볼 수 있습니다로 주석 선언의 종류에 영향을 미칩니다.</target>
        </trans-unit>
        <trans-unit id="b73370969f5202ffabe72c59e5b9b17674a895a5" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;toast&lt;/code&gt; function is defined in the &lt;a href=&quot;https://github.com/Kotlin/anko&quot;&gt;Anko&lt;/a&gt; library.</source>
          <target state="translated">&lt;code&gt;toast&lt;/code&gt; 기능은에 정의되어 &lt;a href=&quot;https://github.com/Kotlin/anko&quot;&gt;안코의&lt;/a&gt; 라이브러리입니다.</target>
        </trans-unit>
        <trans-unit id="28d1165f482266ce4727ebc682f071fdd99069b9" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;typedef struct { .. } TYPE_NAME&lt;/code&gt; syntax is used in C language to declare a structure. &lt;a href=&quot;https://stackoverflow.com/questions/1675351/typedef-struct-vs-struct-definitions&quot;&gt;The thread&lt;/a&gt; provides more explanations of that pattern.</source>
          <target state="translated">&lt;code&gt;typedef struct { .. } TYPE_NAME&lt;/code&gt; 구문 구조를 선언하는 C 언어로 사용된다. &lt;a href=&quot;https://stackoverflow.com/questions/1675351/typedef-struct-vs-struct-definitions&quot;&gt;스레드&lt;/a&gt; 는 해당 패턴에 대한 자세한 설명을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="98db59501bac8408cab0fac3a9f3341579e6d212" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;valueOf()&lt;/code&gt; method throws an &lt;code&gt;IllegalArgumentException&lt;/code&gt; if the specified name does not match any of the enum constants defined in the class.</source>
          <target state="translated">&lt;code&gt;valueOf()&lt;/code&gt; 메소드가 발생 &lt;code&gt;IllegalArgumentException&lt;/code&gt; 지정된 이름이 클래스에 정의 된 열거 형 상수 일치하지 않는 경우.</target>
        </trans-unit>
        <trans-unit id="3e338c07817ae57fb7dbab7add74e2021cf2d7f2" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;version&lt;/code&gt; should be literal in this block, and it cannot be applied from another build script.</source>
          <target state="translated">&lt;code&gt;version&lt;/code&gt; 이 블록에서 문자 그대로해야하고, 그것은 또 다른 빌드 스크립트에서 적용 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="271e23dc79ae024533b3813b505d0f8c07b0807d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;while&lt;/code&gt; loop is similar to Python (but keep in mind that the condition must be an actual boolean expression, as there's no concept of truthy or falsy values).</source>
          <target state="translated">&lt;code&gt;while&lt;/code&gt; 루프 (truthy 또는 falsy 값의 개념이 없습니다로하지만, 조건이 실제 부울 식이어야 것을 명심) 파이썬과 유사하다.</target>
        </trans-unit>
        <trans-unit id="223ff8adc648a88f8fddcdbfcf941801bfcdb1cf" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;New Project&lt;/em&gt; wizard in IntelliJ IDEA can be used to start a new Kotlin/Native project with just one click. Check out the &lt;em&gt;Kotlin&lt;/em&gt; section and select the &lt;em&gt;Native | Gradle&lt;/em&gt; option to generate the project. For a better understanding and to explain what's happening, in this tutorial we'll create the project manually.</source>
          <target state="translated">IntelliJ IDEA 의 &lt;em&gt;새 프로젝트&lt;/em&gt; 마법사를 사용하면 한 번의 클릭으로 새로운 Kotlin / Native 프로젝트를 시작할 수 있습니다. &lt;em&gt;Kotlin&lt;/em&gt; 섹션을 확인 하고 &lt;em&gt;Native | &lt;/em&gt;프로젝트를 생성하는 &lt;em&gt;Gradle&lt;/em&gt; 옵션. 더 나은 이해와 진행 상황을 설명하기 위해이 자습서에서는 프로젝트를 수동으로 만듭니다.</target>
        </trans-unit>
        <trans-unit id="7d53f956418818285247311dbf9f12e622bd802b" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;by&lt;/em&gt;-clause in the supertype list for &lt;code&gt;Derived&lt;/code&gt; indicates that &lt;code&gt;b&lt;/code&gt; will be stored internally in objects of &lt;code&gt;Derived&lt;/code&gt; and the compiler will generate all the methods of &lt;code&gt;Base&lt;/code&gt; that forward to &lt;code&gt;b&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Derived&lt;/code&gt; 에 대한 수퍼 타입 ​​목록 의 &lt;em&gt;by-&lt;/em&gt; clause는 &lt;code&gt;b&lt;/code&gt; 가 &lt;code&gt;Derived&lt;/code&gt; 의 오브젝트에 내부적으로 저장 되고 컴파일러가 &lt;code&gt;b&lt;/code&gt; 로 전달하는 &lt;code&gt;Base&lt;/code&gt; 의 모든 메소드를 생성 함을 나타냅니다 .</target>
        </trans-unit>
        <trans-unit id="213b555bea1db5677fa1e760ddedf7cc9bc757bb" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;else&lt;/em&gt; branch is evaluated if none of the other branch conditions are satisfied. If &lt;em&gt;when&lt;/em&gt; is used as an expression, the &lt;em&gt;else&lt;/em&gt; branch is mandatory, unless the compiler can prove that all possible cases are covered with branch conditions (as, for example, with &lt;a href=&quot;enum-classes&quot;&gt;&lt;em&gt;enum&lt;/em&gt; class&lt;/a&gt; entries and &lt;a href=&quot;sealed-classes&quot;&gt;&lt;em&gt;sealed&lt;/em&gt; class&lt;/a&gt; subtypes).</source>
          <target state="translated">&lt;em&gt;또&lt;/em&gt; 다른 가지 조건 중 어느 것도 충족되지 않은 경우 분기 평가된다. &lt;em&gt;when&lt;/em&gt; 가 표현식으로 사용될 경우 컴파일러가 가능한 모든 케이스가 분기 조건 (예 : &lt;a href=&quot;enum-classes&quot;&gt;&lt;em&gt;enum&lt;/em&gt;&lt;/a&gt; 클래스 항목 및 &lt;a href=&quot;sealed-classes&quot;&gt;&lt;em&gt;봉인&lt;/em&gt;&lt;/a&gt; 클래스 하위 유형) 으로 덮여 있음을 증명할 수없는 경우 &lt;em&gt;else&lt;/em&gt; 분기는 필수 입니다.&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="61bf16ef28ea6d5682c3a6e4f7b1d1fca409774d" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;is&lt;/em&gt; operator checks if an expression is an instance of a type. If an immutable local variable or property is checked for a specific type, there's no need to cast it explicitly:</source>
          <target state="translated">는 &lt;em&gt;인&lt;/em&gt; 표현이 유형의 인스턴스의 경우 운전자 검사한다. 변경 불가능한 지역 변수 또는 속성이 특정 유형에 대해 검사되는 경우 명시 적으로 캐스트 할 필요가 없습니다.</target>
        </trans-unit>
        <trans-unit id="f6350fa23a8337c14451639e9dda41ba02fbc154" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;kotlin-maven-plugin&lt;/em&gt; compiles Kotlin sources and modules. Currently only Maven v3 is supported.</source>
          <target state="translated">&lt;em&gt;코 틀린-받는다는 - 플러그인&lt;/em&gt; 컴파일 코 틀린 소스와 모듈. 현재 Maven v3 만 지원됩니다.</target>
        </trans-unit>
        <trans-unit id="ac3430431502d340786bc5ac5f5a79619bd1b1b8" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;mapping&lt;/em&gt; transformation creates a collection from the results of a function on the elements of another collection. The basic mapping function is &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/map&quot;&gt;&lt;code&gt;map()&lt;/code&gt;&lt;/a&gt;. It applies the given lambda function to each subsequent element and returns the list of the lambda results. The order of results is the same as the original order of elements. To apply a transformation that additionally uses the element index as an argument, use &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/map-indexed&quot;&gt;&lt;code&gt;mapIndexed()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;em&gt;맵핑&lt;/em&gt; 변환은 다른 집합의 요소의 기능의 결과로부터 집합을 생성한다. 기본 매핑 함수는 &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/map&quot;&gt; &lt;code&gt;map()&lt;/code&gt; &lt;/a&gt; 입니다. 주어진 람다 함수를 각 후속 요소에 적용하고 람다 결과 목록을 반환합니다. 결과 순서는 원래 요소 순서와 같습니다. 요소 인덱스를 추가로 인수로 사용하는 변환을 적용하려면 &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/map-indexed&quot;&gt; &lt;code&gt;mapIndexed()&lt;/code&gt; &lt;/a&gt; 사용 하십시오 .</target>
        </trans-unit>
        <trans-unit id="7f10d769163cad6919d11542a05d27b21373fb57" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;no-arg&lt;/em&gt; compiler plugin generates an additional zero-argument constructor for classes with a specific annotation.</source>
          <target state="translated">는 &lt;em&gt;인수 없음의&lt;/em&gt; 컴파일러 플러그인은 특정 주석을 가진 클래스에 대한 추가 제로 인수 생성자를 생성하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="c23eadbd5827ce2bda3043305cafb8fee54b97d1" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;override&lt;/em&gt; modifier is required for &lt;code&gt;Derived.v()&lt;/code&gt;. If it were missing, the compiler would complain. If there is no &lt;em&gt;open&lt;/em&gt; modifier on a function, like &lt;code&gt;Base.nv()&lt;/code&gt;, declaring a method with the same signature in a subclass is illegal, either with &lt;em&gt;override&lt;/em&gt; or without it. The &lt;em&gt;open&lt;/em&gt; modifier has no effect when added on members of a final class (i.e.. a class with no &lt;em&gt;open&lt;/em&gt; modifier).</source>
          <target state="translated">&lt;em&gt;재정의&lt;/em&gt; 수정이 필요 &lt;code&gt;Derived.v()&lt;/code&gt; . 누락 된 경우 컴파일러가 불평합니다. 함수에 &lt;code&gt;Base.nv()&lt;/code&gt; 와 같은 &lt;em&gt;열린&lt;/em&gt; 수정자가 없는 경우 , 서브 클래스에서 동일한 서명을 가진 메소드를 &lt;em&gt;재정의&lt;/em&gt; 하거나 사용하지 않고 선언하는 것은 유효 하지 않습니다. &lt;em&gt;열린&lt;/em&gt; 최종 클래스 (예. 아니오 클래스의 멤버에 추가 할 때 수정이 적용되지 않습니다 &lt;em&gt;열어&lt;/em&gt; 수정).&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="7a6efa4e40ec720cdbba584f5f17332e3c02e6f0" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;primitive data types&lt;/em&gt; are the most fundamental types in Kotlin; all other types are built up of these types and arrays thereof. Their representation is very efficient (both in terms of memory and CPU time), as they map to small byte groups that are directly manipulatable by the CPU.</source>
          <target state="translated">&lt;em&gt;기본 데이터 타입은&lt;/em&gt; 코 틀린 가장 기본적인 종류; 다른 모든 유형은 이러한 유형과 그 배열로 구성됩니다. CPU에서 직접 조작 할 수있는 작은 바이트 그룹에 매핑되므로 메모리와 CPU 시간 측면에서 매우 효율적으로 표현됩니다.</target>
        </trans-unit>
        <trans-unit id="487cd135e968638b95e9f2832e5094575fc75a4e" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;return&lt;/em&gt;-expression returns from the nearest enclosing function, i.e. &lt;code&gt;foo&lt;/code&gt;. (Note that such non-local returns are supported only for lambda expressions passed to &lt;a href=&quot;inline-functions&quot;&gt;inline functions&lt;/a&gt;.) If we need to return from a lambda expression, we have to label it and qualify the &lt;em&gt;return&lt;/em&gt;:</source>
          <target state="translated">&lt;em&gt;반환&lt;/em&gt; 가장 가까운 바깥 쪽 함수의 -expression 반환, 즉 &lt;code&gt;foo&lt;/code&gt; 는 . (로컬이 아닌 리턴은 &lt;a href=&quot;inline-functions&quot;&gt;인라인 함수에&lt;/a&gt; 전달 된 람다 표현식에만 지원됩니다 .) 람다 표현식에서 리턴해야하는 경우 레이블을 지정하고 &lt;em&gt;리턴을 규정&lt;/em&gt; 해야합니다 .</target>
        </trans-unit>
        <trans-unit id="cafe8afb40f89fdcda59dc51de02a6061deac76b" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;sam-with-receiver&lt;/em&gt; compiler plugin makes the first parameter of the annotated Java &quot;single abstract method&quot; (SAM) interface method a receiver in Kotlin. This conversion only works when the SAM interface is passed as a Kotlin lambda, both for SAM adapters and SAM constructors (see the &lt;a href=&quot;java-interop#sam-conversions&quot;&gt;documentation&lt;/a&gt; for more details).</source>
          <target state="translated">&lt;em&gt;SAM-와 수신기&lt;/em&gt; 컴파일러 플러그인은 주석 자바 &quot;하나의 추상적 인 방법&quot;(SAM) 인터페이스 메서드의 첫 번째 매개 변수 코 틀린에 수신기를한다. 이 변환은 SAM 인터페이스가 SAM 어댑터 및 SAM 생성자 모두에 대해 Kotlin 람다로 전달 될 때만 작동합니다 (자세한 내용은 &lt;a href=&quot;java-interop#sam-conversions&quot;&gt;설명서&lt;/a&gt; 참조).</target>
        </trans-unit>
        <trans-unit id="2b5aab8f26eb6a59834e5185db5f935d540467ca" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;this&lt;/em&gt; keyword inside an extension function corresponds to the receiver object (the one that is passed before the dot). Now, we can call such a function on any &lt;code&gt;MutableList&amp;lt;Int&amp;gt;&lt;/code&gt;:</source>
          <target state="translated">확장 함수 내부 의 &lt;em&gt;this&lt;/em&gt; 키워드는 수신자 객체 (점 앞에 전달 된 객체)에 해당합니다. 이제 모든 &lt;code&gt;MutableList&amp;lt;Int&amp;gt;&lt;/code&gt; 에서 이러한 함수를 호출 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="64ff96f8d5986618b0177325f56f06db0b6ef27e" translate="yes" xml:space="preserve">
          <source>The &lt;strong&gt;cinterop&lt;/strong&gt; tool produces &lt;code&gt;.klib&lt;/code&gt; wrappers for native libraries as its main output. For example, using the simple &lt;code&gt;libgit2.def&lt;/code&gt; native library definition file provided in your Kotlin/Native distribution</source>
          <target state="translated">&lt;strong&gt;cinterop의&lt;/strong&gt; 도구 생산 &lt;code&gt;.klib&lt;/code&gt; 주요 출력으로 네이티브 라이브러리에 대해 래퍼를. 예를 들어 Kotlin / Native 배포에 제공된 간단한 &lt;code&gt;libgit2.def&lt;/code&gt; 기본 라이브러리 정의 파일 사용</target>
        </trans-unit>
        <trans-unit id="3afe66cbf747b6ceb2175d27e523f7de3f8680c5" translate="yes" xml:space="preserve">
          <source>The &lt;strong&gt;klib&lt;/strong&gt; library management utility allows you to inspect and install the libraries.</source>
          <target state="translated">&lt;strong&gt;klib의&lt;/strong&gt; 라이브러리 관리 유틸리티를 사용하면 검사하고 라이브러리를 설치할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4754f312fedbc815f86ed89afbc9edf502f5ba2a" translate="yes" xml:space="preserve">
          <source>The &lt;strong&gt;out&lt;/strong&gt; modifier is called a &lt;strong&gt;variance annotation&lt;/strong&gt;, and since it is provided at the type parameter declaration site, we talk about &lt;strong&gt;declaration-site variance&lt;/strong&gt;. This is in contrast with Java's &lt;strong&gt;use-site variance&lt;/strong&gt; where wildcards in the type usages make the types covariant.</source>
          <target state="translated">&lt;strong&gt;아웃&lt;/strong&gt; 수정은이라고 &lt;strong&gt;분산 주석을&lt;/strong&gt; , 그리고 그것은 형식 매개 변수 선언 사이트에서 제공되기 때문에, 우리는 이야기 &lt;strong&gt;선언 사이트 분산&lt;/strong&gt; . 이는 유형 사용에서 와일드 카드가 유형을 공변량으로 만드는 Java의 &lt;strong&gt;사용 사이트 차이&lt;/strong&gt; 와 대조적입니다 .</target>
        </trans-unit>
        <trans-unit id="e4cdeee14d0ede31e2c00aaa982268d6ad103b09" translate="yes" xml:space="preserve">
          <source>The &lt;strong&gt;wildcard type argument&lt;/strong&gt;&lt;code&gt;? extends E&lt;/code&gt; indicates that this method accepts a collection of objects of &lt;code&gt;E&lt;/code&gt;&lt;em&gt;or some subtype of&lt;/em&gt;&lt;code&gt;E&lt;/code&gt;, not just &lt;code&gt;E&lt;/code&gt; itself. This means that we can safely &lt;strong&gt;read&lt;/strong&gt;&lt;code&gt;E&lt;/code&gt;'s from items (elements of this collection are instances of a subclass of E), but &lt;strong&gt;cannot write&lt;/strong&gt; to it since we do not know what objects comply to that unknown subtype of &lt;code&gt;E&lt;/code&gt;. In return for this limitation, we have the desired behaviour: &lt;code&gt;Collection&amp;lt;String&amp;gt;&lt;/code&gt;&lt;em&gt;is&lt;/em&gt; a subtype of &lt;code&gt;Collection&amp;lt;? extends Object&amp;gt;&lt;/code&gt;. In &quot;clever words&quot;, the wildcard with an &lt;strong&gt;extends&lt;/strong&gt;-bound (&lt;strong&gt;upper&lt;/strong&gt; bound) makes the type &lt;strong&gt;covariant&lt;/strong&gt;.</source>
          <target state="translated">&lt;strong&gt;와일드 카드 형식 인수 &lt;/strong&gt; &lt;code&gt;? extends E&lt;/code&gt; 이 방법의 개체의 컬렉션 받아들이는 것을 나타냅니다 &lt;code&gt;E&lt;/code&gt; &lt;em&gt;또는 일부 하위 유형 &lt;/em&gt; &lt;code&gt;E&lt;/code&gt; 를 , 그냥 &lt;code&gt;E&lt;/code&gt; 자체를. 즉 , 항목에서 &lt;code&gt;E&lt;/code&gt; 를 안전하게 &lt;strong&gt;읽을&lt;/strong&gt; 수 있지만 (이 컬렉션의 요소는 E의 하위 클래스 인스턴스 임) 알 수없는 &lt;code&gt;E&lt;/code&gt; 의 하위 유형을 준수하는 개체가 무엇인지 알 &lt;strong&gt;수 없으므로 쓸 수 없습니다&lt;/strong&gt; . 이 제한에 대한 대가로, 원하는 동작이 있습니다 : &lt;code&gt;Collection&amp;lt;String&amp;gt;&lt;/code&gt; &lt;em&gt;은 &lt;/em&gt; &lt;code&gt;Collection&amp;lt;? extends Object&amp;gt;&lt;/code&gt; 의 하위 유형 입니까? Object&amp;gt;를 확장합니다 . &quot;영리한 단어&quot;에서 &lt;strong&gt;확장&lt;/strong&gt; 범위가 있는 와일드 카드 ( &lt;strong&gt;위&lt;/strong&gt;&lt;strong&gt;&lt;/strong&gt;&lt;em&gt;&lt;/em&gt;&lt;strong&gt;&lt;/strong&gt;&lt;strong&gt;&lt;/strong&gt;bound) 유형을 &lt;strong&gt;공변량으로&lt;/strong&gt; 만듭니다 .</target>
        </trans-unit>
        <trans-unit id="1a90eeb87b3e982cfd1ef4a4b65cfd6c27586462" translate="yes" xml:space="preserve">
          <source>The Android world has many popular frameworks simplifying development. You can use the same frameworks if you develop in Kotlin, often as easily as you'd do that in Java. This tutorial provides examples and highlights the differences in settings.</source>
          <target state="translated">Android 세계에는 개발을 단순화하는 인기있는 프레임 워크가 많이 있습니다. Kotlin에서 개발하는 경우 Java에서와 마찬가지로 쉽게 동일한 프레임 워크를 사용할 수 있습니다. 이 학습서는 예제를 제공하고 설정의 차이점을 강조합니다.</target>
        </trans-unit>
        <trans-unit id="d41ba3261445c389f8874772f5879ab48af811af" translate="yes" xml:space="preserve">
          <source>The C data variable containing the pointer to &lt;code&gt;T&lt;/code&gt;.</source>
          <target state="translated">포인터 함유 C 데이터 변수 &lt;code&gt;T&lt;/code&gt; 를 .</target>
        </trans-unit>
        <trans-unit id="05360f394dd3e60e07e614be2588088eb89e3b72" translate="yes" xml:space="preserve">
          <source>The C data variable located in memory.</source>
          <target state="translated">메모리에있는 C 데이터 변수</target>
        </trans-unit>
        <trans-unit id="cf919179eecf4647d490ce563cdd6bff132af96d" translate="yes" xml:space="preserve">
          <source>The C function.</source>
          <target state="translated">C 함수.</target>
        </trans-unit>
        <trans-unit id="d36502dcbc1bebedd6773776218e3117a26820bc" translate="yes" xml:space="preserve">
          <source>The C primitive-typed variable located in memory.</source>
          <target state="translated">메모리에있는 C 기본 유형 변수입니다.</target>
        </trans-unit>
        <trans-unit id="639b72b8a51545cc688d8100df8871c5e14d7a1a" translate="yes" xml:space="preserve">
          <source>The C struct-typed variable located in memory.</source>
          <target state="translated">메모리에있는 C 구조체 유형 변수입니다.</target>
        </trans-unit>
        <trans-unit id="c4b0fbfe88d7c41e706fcbcc447e39c33c492192" translate="yes" xml:space="preserve">
          <source>The CocoaPods plugin also allows using CocoaPods libraries without manual configuring cinterop parameters (see the &lt;a href=&quot;../building-mpp-with-gradle#cinterop-support&quot;&gt;corresponding section&lt;/a&gt; of the multiplatform plugin documentation). The &lt;code&gt;cocoapods { ... }&lt;/code&gt; code block allows you to add dependencies on CocoaPods libraries.</source>
          <target state="translated">CocoaPods 플러그인을 사용하면 cinterop 매개 변수를 수동으로 구성하지 않고도 CocoaPods 라이브러리를 사용할 수 있습니다 ( 멀티 플랫폼 플러그인 문서 의 &lt;a href=&quot;../building-mpp-with-gradle#cinterop-support&quot;&gt;해당 섹션&lt;/a&gt; 참조 ). &lt;code&gt;cocoapods { ... }&lt;/code&gt; 코드 블록은 CocoaPods 라이브러리에 종속성을 추가 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8779fd3a2cac48558378b86549bbda66333c4276" translate="yes" xml:space="preserve">
          <source>The CocoaPods support is implemented in a separate Gradle plugin: &lt;code&gt;org.jetbrains.kotlin.native.cocoapods&lt;/code&gt;.</source>
          <target state="translated">CocoaPods 지원은 별도의 Gradle 플러그인 &lt;code&gt;org.jetbrains.kotlin.native.cocoapods&lt;/code&gt; 에서 구현됩니다 .</target>
        </trans-unit>
        <trans-unit id="24a56079ca4afabfa7a909e10193add3dd7a492a" translate="yes" xml:space="preserve">
          <source>The DOM also provides us a way to retrieve a specific element by ID, name, class name, tag name and so on. All returned elements are of type &lt;code&gt;NodeList&lt;/code&gt;, and to access members we need to cast them to the specific type of element. The code below shows how we could access an input element on the page:</source>
          <target state="translated">DOM은 또한 ID, 이름, 클래스 이름, 태그 이름 등으로 특정 요소를 검색하는 방법을 제공합니다. 반환 된 모든 요소는 &lt;code&gt;NodeList&lt;/code&gt; 유형 이며 멤버에 액세스하려면 특정 유형의 요소로 캐스트해야합니다. 아래 코드는 페이지의 입력 요소에 액세스하는 방법을 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="325910eae4ee7077ed16505d94cb7161a53ff4ff" translate="yes" xml:space="preserve">
          <source>The Entry Point</source>
          <target state="translated">진입 점</target>
        </trans-unit>
        <trans-unit id="c1f2de3caa83760aa037581086bf37c054caebbb" translate="yes" xml:space="preserve">
          <source>The Gradle file is pretty much standard for Spring Boot. The only differences are the structure layout for source folders for Kotlin, the required Kotlin dependencies and the &lt;a href=&quot;../reference/compiler-plugins#kotlin-spring-compiler-plugi&quot;&gt;&lt;em&gt;kotlin-spring&lt;/em&gt;&lt;/a&gt; Gradle plugin (CGLIB proxies used for example for &lt;code&gt;@Configuration&lt;/code&gt; and &lt;code&gt;@Bean&lt;/code&gt; processing require &lt;code&gt;open&lt;/code&gt; classes).</source>
          <target state="translated">Gradle 파일은 Spring Boot의 표준입니다. 유일한 차이점은 Kotlin의 소스 폴더, 필요한 Kotlin 종속성 및 &lt;a href=&quot;../reference/compiler-plugins#kotlin-spring-compiler-plugi&quot;&gt;&lt;em&gt;kotlin-spring&lt;/em&gt;&lt;/a&gt; Gradle 플러그인 의 구조 레이아웃입니다 (예 : &lt;code&gt;@Configuration&lt;/code&gt; 및 &lt;code&gt;@Bean&lt;/code&gt; 처리에 사용되는 CGLIB 프록시 에는 &lt;code&gt;open&lt;/code&gt; 클래스가 필요함 ).</target>
        </trans-unit>
        <trans-unit id="af4ea41e06d67df72de18198c84923c5e721e071" translate="yes" xml:space="preserve">
          <source>The Gradle plugin provides a separate task that creates a universal framework for iOS targets from several regular ones. The example below shows how to use this task. Note that the fat framework must have the same base name as the initial frameworks.</source>
          <target state="translated">Gradle 플러그인은 여러 일반 대상에서 iOS 대상에 대한 범용 프레임 워크를 작성하는 별도의 태스크를 제공합니다. 아래 예는이 작업을 사용하는 방법을 보여줍니다. 팻 프레임 워크는 초기 프레임 워크와 기본 이름이 같아야합니다.</target>
        </trans-unit>
        <trans-unit id="c9686505fe7f54579b832493ec5b1983b12000c6" translate="yes" xml:space="preserve">
          <source>The JS typed arrays support that translates Kotlin primitive arrays, such as &lt;code&gt;IntArray&lt;/code&gt;, &lt;code&gt;DoubleArray&lt;/code&gt;, into &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Typed_arrays&quot;&gt;JavaScript typed arrays&lt;/a&gt;, that was previously an opt-in feature, has been enabled by default.</source>
          <target state="translated">JS 유형 배열은 &lt;code&gt;IntArray&lt;/code&gt; , &lt;code&gt;DoubleArray&lt;/code&gt; 와 같은 Kotlin 기본 배열 을 이전에 옵트 인 기능인 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Typed_arrays&quot;&gt;JavaScript 유형 배열&lt;/a&gt; 로 변환 하는 기능을 기본적으로 활성화했습니다.</target>
        </trans-unit>
        <trans-unit id="37ed5aeb9956cf68199e058567f26ab71cd7268f" translate="yes" xml:space="preserve">
          <source>The JSR-305 checks can be configured by adding the &lt;code&gt;-Xjsr305&lt;/code&gt; compiler flag with the following options (and their combination):</source>
          <target state="translated">JSR-305 검사는 &lt;code&gt;-Xjsr305&lt;/code&gt; 컴파일러 플래그를 다음 옵션 (및 그 조합)과 함께 추가하여 구성 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="8614662835decc941fb88cef784012c8f902a438" translate="yes" xml:space="preserve">
          <source>The Kotlin Android Extensions plugin allows us to obtain the same experience we have with some of these libraries, without having to add any extra code.</source>
          <target state="translated">Kotlin Android Extensions 플러그인을 사용하면 추가 코드를 추가하지 않고도 이러한 라이브러리 중 일부와 동일한 경험을 얻을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b801cd7f041e6d90c21e7238c859980046339a8a" translate="yes" xml:space="preserve">
          <source>The Kotlin Gradle plugin supports incremental compilation. Incremental compilation tracks changes of source files between builds so only files affected by these changes would be compiled.</source>
          <target state="translated">Kotlin Gradle 플러그인은 증분 컴파일을 지원합니다. 증분 컴파일은 빌드간에 소스 파일의 변경을 추적하므로 이러한 변경의 영향을받는 파일 만 컴파일됩니다.</target>
        </trans-unit>
        <trans-unit id="11818c172874b525f41c4774ffd3a8d06183ee2a" translate="yes" xml:space="preserve">
          <source>The Kotlin Maven Plugin needs to be referenced to compile the sources:</source>
          <target state="translated">소스를 컴파일하려면 Kotlin Maven 플러그인을 참조해야합니다.</target>
        </trans-unit>
        <trans-unit id="e701f1b663fc8e1d541e7d7bed4b022ef1cd48e3" translate="yes" xml:space="preserve">
          <source>The Kotlin Standard Library provides a comprehensive set of tools for managing &lt;em&gt;collections&lt;/em&gt; &amp;ndash; groups of a variable number of items (possibly zero) that share significance to the problem being solved and are operated upon commonly.</source>
          <target state="translated">코 틀린 표준 라이브러리 (Kotlin Standard Library)는 &lt;em&gt;수집&lt;/em&gt; 을 관리하기위한 포괄적 인 도구 세트를 제공 합니다.이 문제는 해결해야 할 문제의 중요성을 공유하고 일반적으로 운영되는 다양한 수의 항목 그룹 (아마도 0)입니다.</target>
        </trans-unit>
        <trans-unit id="8a031299bd7c193b637e92a822d8538f69af9b3a" translate="yes" xml:space="preserve">
          <source>The Kotlin Standard Library provides implementations for basic collection types: sets, lists, and maps. A pair of interfaces represent each collection type:</source>
          <target state="translated">Kotlin 표준 라이브러리는 기본 컬렉션 유형 (세트, 목록 및 맵)에 대한 구현을 제공합니다. 한 쌍의 인터페이스는 각 컬렉션 유형을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="3f614163c9f0e1a9b558eccd140b5d89bbaff4cb" translate="yes" xml:space="preserve">
          <source>The Kotlin Standard Library provides living essentials for everyday work with Kotlin. These include:</source>
          <target state="translated">코 틀린 표준 라이브러리는 코 틀린과 일상적인 작업에 필요한 생활 필수품을 제공합니다. 여기에는 다음이 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="33a29a3734d935aaab60c852c81fd82eccf705fa" translate="yes" xml:space="preserve">
          <source>The Kotlin code is turned into very similar looking code in Swift. There are some small differences, though. In Kotlin any &lt;code&gt;object&lt;/code&gt; has only one instance. Kotlin &lt;code&gt;object Object&lt;/code&gt; now has a constructor in Swift, and we use the &lt;code&gt;Object()&lt;/code&gt; syntax to access the only instance of it. The instance is always the same in Swift, so that &lt;code&gt;Object() === Object()&lt;/code&gt; is true. Methods and property names are translated as-is. Kotlin &lt;code&gt;String&lt;/code&gt; is turned into Swift &lt;code&gt;String&lt;/code&gt; too. Swift hides &lt;code&gt;NSNumber*&lt;/code&gt; boxing from us too. We pass Swift closure to Kotlin and call a Kotlin lambda function from Swift too.</source>
          <target state="translated">코 틀린 코드는 스위프트에서 매우 유사한 코드로 바뀌었다. 그래도 약간의 차이가 있습니다. Kotlin에서는 모든 &lt;code&gt;object&lt;/code&gt; 인스턴스가 하나만 있습니다. Kotlin &lt;code&gt;object Object&lt;/code&gt; 이제 Swift에 생성자를 가지며 &lt;code&gt;Object()&lt;/code&gt; 구문을 사용하여 유일한 인스턴스에 액세스합니다. Swift에서 인스턴스는 항상 동일하므로 &lt;code&gt;Object() === Object()&lt;/code&gt; 가 true입니다. 메서드와 속성 이름은있는 그대로 번역됩니다. Kotlin &lt;code&gt;String&lt;/code&gt; 도 Swift &lt;code&gt;String&lt;/code&gt; 으로 바뀝니다 . Swift는 &lt;code&gt;NSNumber*&lt;/code&gt; 권투도 숨 깁니다 . 우리는 Swift 클로저를 Kotlin으로 전달하고 Swift에서 Kotlin 람다 함수를 호출합니다.</target>
        </trans-unit>
        <trans-unit id="a82d7ab28c8dc762af0699f165239106b9d7ca89" translate="yes" xml:space="preserve">
          <source>The Kotlin collections package contains extension functions for popular operations on sets: finding intersections, merging, or subtracting collections from each other.</source>
          <target state="translated">Kotlin 컬렉션 패키지에는 교차점 찾기, 병합 또는 서로 빼기 모음의 인기있는 작업을위한 확장 기능이 포함되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="5352e834912895fb7e864dc749c6a67a63a5c1bd" translate="yes" xml:space="preserve">
          <source>The Kotlin collections package provides functions for sorting collections in natural, custom, and even random orders. On this page, we'll describe sorting functions that apply to &lt;a href=&quot;collections-overview#collection-types&quot;&gt;read-only&lt;/a&gt; collections. These functions return their result as a new collection containing the elements of the original collection in the requested order. To learn about functions for sorting &lt;a href=&quot;collections-overview#collection-types&quot;&gt;mutable&lt;/a&gt; collections in place, see the &lt;a href=&quot;list-operations#sorting&quot;&gt;List Specific Operations&lt;/a&gt;.</source>
          <target state="translated">Kotlin 컬렉션 패키지는 컬렉션을 자연스럽고, 맞춤이며, 임의 순서로 정렬하는 기능을 제공합니다. 이 페이지에서는 &lt;a href=&quot;collections-overview#collection-types&quot;&gt;읽기 전용&lt;/a&gt; 컬렉션에 적용되는 정렬 기능에 대해 설명합니다 . 이 함수는 요청 된 순서로 원래 컬렉션의 요소를 포함하는 새 컬렉션으로 결과를 반환합니다. &lt;a href=&quot;collections-overview#collection-types&quot;&gt;변경 가능한&lt;/a&gt; 컬렉션을 적절하게 정렬하는 기능에 대해 배우려면 &lt;a href=&quot;list-operations#sorting&quot;&gt;목록 특정 작업을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="606ec4093466ccf8ac7dfb28ac45fda128eb6073" translate="yes" xml:space="preserve">
          <source>The Kotlin compiler can now use information from type casts in type inference. If you&amp;rsquo;re calling a generic method that returns a type parameter &lt;code&gt;T&lt;/code&gt; and casting the return value to a specific type &lt;code&gt;Foo&lt;/code&gt;, the compiler now understands that &lt;code&gt;T&lt;/code&gt; for this call needs to be bound to the type &lt;code&gt;Foo&lt;/code&gt;.</source>
          <target state="translated">코 틀린 컴파일러는 이제 타입 추론에서 타입 캐스트의 정보를 사용할 수 있습니다. 형식 매개 변수 &lt;code&gt;T&lt;/code&gt; 를 반환 하고 반환 값을 특정 형식 &lt;code&gt;Foo&lt;/code&gt; 로 캐스팅 하는 제네릭 메서드를 호출하는 경우 이제 컴파일러 는이 호출의 &lt;code&gt;T&lt;/code&gt; 가 &lt;code&gt;Foo&lt;/code&gt; 형식에 바인딩되어야 함을 이해합니다 .</target>
        </trans-unit>
        <trans-unit id="3ccc8c3cdb40fba2c36169a3fed32ce41fa13cee" translate="yes" xml:space="preserve">
          <source>The Kotlin compiler does extensive static analysis to provide warnings and reduce boilerplate. One of the most notable features is smartcasts &amp;mdash; with the ability to perform a cast automatically based on the performed type checks:</source>
          <target state="translated">Kotlin 컴파일러는 광범위한 정적 분석을 수행하여 경고를 제공하고 상용구를 줄입니다. 가장 주목할만한 기능 중 하나는 스마트 캐스트입니다. 수행 된 유형 검사에 따라 자동으로 캐스트를 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9b9028d4b3725e4248715dfa8cff6060191e14fa" translate="yes" xml:space="preserve">
          <source>The Kotlin compiler provides all the necessary information about &lt;code&gt;prop&lt;/code&gt; in the arguments: the first argument &lt;code&gt;this&lt;/code&gt; refers to an instance of the outer class &lt;code&gt;C&lt;/code&gt; and &lt;code&gt;this::prop&lt;/code&gt; is a reflection object of the &lt;code&gt;KProperty&lt;/code&gt; type describing &lt;code&gt;prop&lt;/code&gt; itself.</source>
          <target state="translated">코 틀린 컴파일러에 대한 모든 필요한 정보를 제공 &lt;code&gt;prop&lt;/code&gt; 인수하여 : 첫번째 인수 &lt;code&gt;this&lt;/code&gt; 외부 클래스의 인스턴스를 지칭 &lt;code&gt;C&lt;/code&gt; 및 &lt;code&gt;this::prop&lt;/code&gt; 의 반사 목적 &lt;code&gt;KProperty&lt;/code&gt; 의 기술 유형 &lt;code&gt;prop&lt;/code&gt; 자체.</target>
        </trans-unit>
        <trans-unit id="d8f9b6bf737be7b0aa49748489bb11aedc0ed8e0" translate="yes" xml:space="preserve">
          <source>The Kotlin compiler tries to comply with the following goals:</source>
          <target state="translated">Kotlin 컴파일러는 다음 목표를 준수하려고합니다.</target>
        </trans-unit>
        <trans-unit id="84694c64245d13b803ebc2f9a85d6bc26cef8561" translate="yes" xml:space="preserve">
          <source>The Kotlin compiler will prefer using underlying types instead of wrappers to produce the most performant and optimized code. However, sometimes it is necessary to keep wrappers around. As a rule of thumb, inline classes are boxed whenever they are used as another type.</source>
          <target state="translated">Kotlin 컴파일러는 래퍼 대신 기본 유형을 사용하여 성능이 뛰어나고 최적화 된 코드를 생성하는 것을 선호합니다. 그러나 때때로 랩퍼를 유지해야합니다. 일반적으로 인라인 클래스는 다른 유형으로 사용될 때마다 상자로 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="b1defae0fa9dbdfd545ce26ab8cc2b793d3d11fe" translate="yes" xml:space="preserve">
          <source>The Kotlin compiler will use this restriction to aggressively optimize runtime representation of inline classes and substitute their instances with the value of the underlying property where possible removing constructor calls, GC pressure, and enabling other optimizations:</source>
          <target state="translated">Kotlin 컴파일러는이 제한 사항을 사용하여 인라인 클래스의 런타임 표현을 적극적으로 최적화하고 생성자 호출, GC 압력을 제거하고 다른 최적화를 가능하게하는 기본 속성 값으로 인스턴스를 대체합니다.</target>
        </trans-unit>
        <trans-unit id="421148b46361ca016988f110ea6a768864eebc2b" translate="yes" xml:space="preserve">
          <source>The Kotlin plugin also bundles a Java to Kotlin converter (&lt;em&gt;J2K&lt;/em&gt;) that automatically converts Java files to Kotlin. To use J2K on a file, click &lt;strong&gt;Convert Java File to Kotlin File&lt;/strong&gt; in its context menu or in the &lt;strong&gt;Code&lt;/strong&gt; menu of IntelliJ IDEA.</source>
          <target state="translated">Kotlin 플러그인은 Java 파일을 Kotlin으로 자동 변환 하는 Java to Kotlin 변환기 ( &lt;em&gt;J2K&lt;/em&gt; ) 도 번들로 제공합니다 . 파일에서 J2K를 사용하려면 컨텍스트 메뉴 또는 IntelliJ IDEA 의 &lt;strong&gt;코드&lt;/strong&gt; 메뉴 에서 &lt;strong&gt;Java 파일을 Kotlin 파일&lt;/strong&gt; 로 &lt;strong&gt;변환을&lt;/strong&gt; 클릭 &lt;strong&gt;하십시오&lt;/strong&gt; .&lt;strong&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="8d656f515ef009525fec5de5fd6f927dce6dbed0" translate="yes" xml:space="preserve">
          <source>The Kotlin plugin supports &lt;a href=&quot;https://guides.gradle.org/using-build-cache/&quot;&gt;Gradle Build Cache&lt;/a&gt; (Gradle version 4.3 and above is required; caching is disabled with lower versions).</source>
          <target state="translated">Kotlin 플러그인은 &lt;a href=&quot;https://guides.gradle.org/using-build-cache/&quot;&gt;Gradle Build Cache를&lt;/a&gt; 지원합니다 (Gradle 버전 4.3 이상이 필요합니다. 캐싱은 하위 버전에서 비활성화 됨).</target>
        </trans-unit>
        <trans-unit id="4e886321a88f27f1211fc7e6327218f1b649f0a9" translate="yes" xml:space="preserve">
          <source>The Kotlin sources are arranged into &lt;a href=&quot;#configuring-source-sets&quot;&gt;source sets&lt;/a&gt;. In addition to Kotlin source files and resources, each source set may have its own dependencies. Source sets form a hierarchy that is built with the &lt;em&gt;&quot;depends on&quot;&lt;/em&gt; relation. A source set by itself is platform agnostic, but it may contain platform-specific code and dependencies if it's only compiled for a single platform.</source>
          <target state="translated">Kotlin 소스는 &lt;a href=&quot;#configuring-source-sets&quot;&gt;소스 세트&lt;/a&gt; 로 정렬됩니다 . Kotlin 소스 파일 및 리소스 외에도 각 소스 세트에는 고유 한 종속성이있을 수 있습니다. 소스 세트는 &lt;em&gt;&quot;종속&quot;&lt;/em&gt; 관계로 빌드 된 계층을 형성합니다 . 소스 세트 자체는 플랫폼에 구애받지 않지만 단일 플랫폼 용으로 컴파일 된 경우에는 플랫폼 별 코드와 종속성이 포함될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="16279f302f8a88f25bf841c70c273ae22857462c" translate="yes" xml:space="preserve">
          <source>The Kotlin standard library &lt;code&gt;kotlin-stdlib&lt;/code&gt; targets Java 6 and above. There are extended versions of the standard library that add support for some of the features of JDK 7 and JDK 8. To use these versions, add one of the following dependencies instead of &lt;code&gt;kotlin-stdlib&lt;/code&gt;:</source>
          <target state="translated">Kotlin 표준 라이브러리 &lt;code&gt;kotlin-stdlib&lt;/code&gt; 는 Java 6 이상을 대상으로합니다. JDK 7 및 JDK 8의 일부 기능에 대한 지원을 추가하는 확장 된 표준 라이브러리 버전이 있습니다.이 버전을 사용하려면 &lt;code&gt;kotlin-stdlib&lt;/code&gt; 대신 다음 종속성 중 하나를 추가하십시오 .</target>
        </trans-unit>
        <trans-unit id="e19faba3d18413b5a548d796d002602d1f6b7b0d" translate="yes" xml:space="preserve">
          <source>The Kotlin standard library contains extension functions for retrieving parts of a collection. These functions provide a variety of ways to select elements for the result collection: listing their positions explicitly, specifying the result size, and others.</source>
          <target state="translated">Kotlin 표준 라이브러리에는 콜렉션의 일부를 검색하기위한 확장 기능이 있습니다. 이 함수는 결과 수집을위한 요소를 선택하는 다양한 방법을 제공합니다. 위치를 명시 적으로 나열하고 결과 크기를 지정하는 등의 방법입니다.</target>
        </trans-unit>
        <trans-unit id="aee8a9e1bcfd6364e58b2c53a697014bcd222ec2" translate="yes" xml:space="preserve">
          <source>The Kotlin standard library contains several functions whose sole purpose is to execute a block of code within the context of an object. When you call such a function on an object with a &lt;a href=&quot;lambdas&quot;&gt;lambda expression&lt;/a&gt; provided, it forms a temporary scope. In this scope, you can access the object without its name. Such functions are called &lt;em&gt;scope functions&lt;/em&gt;. There are five of them: &lt;code&gt;let&lt;/code&gt;, &lt;code&gt;run&lt;/code&gt;, &lt;code&gt;with&lt;/code&gt;, &lt;code&gt;apply&lt;/code&gt;, and &lt;code&gt;also&lt;/code&gt;.</source>
          <target state="translated">Kotlin 표준 라이브러리에는 객체 컨텍스트 내에서 코드 블록을 실행하는 것이 유일한 목적인 여러 함수가 포함되어 있습니다. &lt;a href=&quot;lambdas&quot;&gt;람다식이&lt;/a&gt; 제공된 객체에서 이러한 함수를 호출 하면 임시 범위가 형성됩니다. 이 범위에서 이름없이 개체에 액세스 할 수 있습니다. 이러한 기능을 &lt;em&gt;범위 기능&lt;/em&gt; 이라고 &lt;em&gt;합니다&lt;/em&gt; . &lt;code&gt;let&lt;/code&gt; , &lt;code&gt;run&lt;/code&gt; , &lt;code&gt;with&lt;/code&gt; , &lt;code&gt;apply&lt;/code&gt; 및 &lt;code&gt;also&lt;/code&gt; 중 다섯 가지가 있습니다 .</target>
        </trans-unit>
        <trans-unit id="41ab82952f2d2fb6d715a1d54dee47f369b23a5d" translate="yes" xml:space="preserve">
          <source>The Kotlin standard library is available on &lt;a href=&quot;https://www.npmjs.com/&quot;&gt;npm&lt;/a&gt; and we can simply include it in our &lt;code&gt;package.json&lt;/code&gt; as a dependency.</source>
          <target state="translated">Kotlin 표준 라이브러리는 &lt;a href=&quot;https://www.npmjs.com/&quot;&gt;npm에서&lt;/a&gt; 사용할 수 있으며이를 &lt;code&gt;package.json&lt;/code&gt; 에 종속성으로 간단히 포함 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="aa008c18e28c0e852d10e5f6a39e59c2d9ab879a" translate="yes" xml:space="preserve">
          <source>The Kotlin standard library is now fully compatible with the Java 9 module system, which forbids split packages (multiple jar files declaring classes in the same package). In order to support that, new artifacts &lt;code&gt;kotlin-stdlib-jdk7&lt;/code&gt; and &lt;code&gt;kotlin-stdlib-jdk8&lt;/code&gt; are introduced, which replace the old &lt;code&gt;kotlin-stdlib-jre7&lt;/code&gt; and &lt;code&gt;kotlin-stdlib-jre8&lt;/code&gt;.</source>
          <target state="translated">Kotlin 표준 라이브러리는 이제 Java 9 모듈 시스템과 완벽하게 호환되므로 분할 패키지 (같은 패키지의 클래스를 선언하는 여러 jar 파일)를 금지합니다. 그를 지원하기 위해, 새로운 유물 &lt;code&gt;kotlin-stdlib-jdk7&lt;/code&gt; 과 &lt;code&gt;kotlin-stdlib-jdk8&lt;/code&gt; 이전 대체하는 소개 &lt;code&gt;kotlin-stdlib-jre7&lt;/code&gt; 과 &lt;code&gt;kotlin-stdlib-jre8&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="870dd777a08235fb630e1002ab11ba8d4d93e900" translate="yes" xml:space="preserve">
          <source>The Kotlin standard library offers a broad variety of functions for performing operations on collections. This includes simple operations, such as getting or adding elements, as well as more complex ones including search, sorting, filtering, transformations, and so on.</source>
          <target state="translated">Kotlin 표준 라이브러리는 컬렉션에서 작업을 수행하기위한 다양한 기능을 제공합니다. 여기에는 요소 가져 오기 또는 추가와 같은 간단한 작업뿐만 아니라 검색, 정렬, 필터링, 변환 등을 포함한보다 복잡한 작업이 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="7504a2da20208970eadd23d20d879fda0292513a" translate="yes" xml:space="preserve">
          <source>The Kotlin standard library provides a series of wrappers around the JavaScript API for interacting with documents. The main component we'd usually access is the variable &lt;code&gt;document&lt;/code&gt;. Given we have access to this, we can simply read and write to the corresponding properties. For instance, to set the background of the page we can do</source>
          <target state="translated">Kotlin 표준 라이브러리는 문서와 상호 작용하기 위해 JavaScript API를 중심으로 일련의 래퍼를 제공합니다. 우리가 일반적으로 액세스하는 주요 구성 요소는 변수 &lt;code&gt;document&lt;/code&gt; 입니다. 이에 액세스 할 수 있으면 해당 속성을 읽고 쓸 수 있습니다. 예를 들어 페이지의 배경을 설정하려면</target>
        </trans-unit>
        <trans-unit id="d4672fe3591cd8e490f322d7264f5d7b48dbb930" translate="yes" xml:space="preserve">
          <source>The Kotlin standard library provides a set of extension functions for collection &lt;em&gt;transformations&lt;/em&gt;. These functions build new collections from existing ones based on the transformation rules provided. In this page, we'll give an overview of the available collection transformation functions.</source>
          <target state="translated">Kotlin 표준 라이브러리는 콜렉션 &lt;em&gt;변환을&lt;/em&gt; 위한 확장 기능 세트를 제공합니다 . 이 함수는 제공된 변환 규칙을 기반으로 기존 컬렉션에서 새 컬렉션을 만듭니다. 이 페이지에서는 사용 가능한 컬렉션 변환 기능에 대한 개요를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="0d403b1b6b6cec3fc85d2c8444ad4595fd15211b" translate="yes" xml:space="preserve">
          <source>The Kotlin standard library provides developers with a mechanism for creating and using &lt;em&gt;experimental&lt;/em&gt; APIs. This mechanism lets library authors inform users that certain components of their API, such as classes or functions, are unstable and are likely to change in the future. Such changes may require rewriting and recompiling the client code. To prevent potential compatibility issues, the compiler warns users of the experimental status of such APIs and may require them to give their explicit consent to use the API.</source>
          <target state="translated">Kotlin 표준 라이브러리는 개발자에게 &lt;em&gt;실험적인&lt;/em&gt; API 를 만들고 사용하기위한 메커니즘을 제공합니다 . 이 메커니즘을 통해 라이브러리 작성자는 클래스 또는 함수와 같은 API의 특정 구성 요소가 불안정하고 향후 변경 될 수 있음을 사용자에게 알릴 수 있습니다. 이러한 변경으로 인해 클라이언트 코드를 다시 작성하고 다시 컴파일해야 할 수 있습니다. 잠재적 인 호환성 문제를 방지하기 위해 컴파일러는 사용자에게 이러한 API의 실험 상태를 경고하고 API 사용에 대한 명시 적 동의를 요구할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="25b12f54730219e6bd01543d34c7f6d86941696e" translate="yes" xml:space="preserve">
          <source>The Kotlin standard library provides extension functions for grouping collection elements. The basic function &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/group-by&quot;&gt;&lt;code&gt;groupBy()&lt;/code&gt;&lt;/a&gt; takes a lambda function and returns a &lt;code&gt;Map&lt;/code&gt;. In this map, each key is the lambda result and the corresponding value is the &lt;code&gt;List&lt;/code&gt; of elements on which this result is returned. This function can be used, for example, to group a list of &lt;code&gt;String&lt;/code&gt;s by their first letter.</source>
          <target state="translated">Kotlin 표준 라이브러리는 컬렉션 요소를 그룹화하기위한 확장 기능을 제공합니다. 기본 함수 &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/group-by&quot;&gt; &lt;code&gt;groupBy()&lt;/code&gt; &lt;/a&gt; 는 람다 함수를 사용하여 &lt;code&gt;Map&lt;/code&gt; 을 반환합니다 . 이 맵에서 각 키는 람다 결과이고 해당 값은 이 결과가 리턴되는 요소 &lt;code&gt;List&lt;/code&gt; 입니다. 예를 들어,이 함수를 사용 하여 첫 번째 문자 로 &lt;code&gt;String&lt;/code&gt; 목록을 그룹화 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="d49763e3623bb841ba6b661af00bff69df48a815" translate="yes" xml:space="preserve">
          <source>The Kotlin standard library provides factory methods for several useful kinds of delegates.</source>
          <target state="translated">Kotlin 표준 라이브러리는 여러 유용한 종류의 델리게이트에 대한 팩토리 메소드를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="d4752902cbbab973b31545d271408bf4e6b55c29" translate="yes" xml:space="preserve">
          <source>The Kotlin team offers a set of tools for Android development that goes beyond the standard language features:</source>
          <target state="translated">Kotlin 팀은 표준 언어 기능을 능가하는 Android 개발 도구 세트를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="3835dcf5cfa983896474e2202e8aad1e87118beb" translate="yes" xml:space="preserve">
          <source>The Kotlin visibilities are mapped to Java in the following way:</source>
          <target state="translated">Kotlin 가시성은 다음과 같은 방식으로 Java에 맵핑됩니다.</target>
        </trans-unit>
        <trans-unit id="6d899757cb2398280c10acb19695bbcab979ce63" translate="yes" xml:space="preserve">
          <source>The Kotlin/Native compiler is available for macOS, Linux, and Windows. It supports different targets including iOS (arm32, arm64, simulator x86_64), Windows (mingw32 and x86_64), Linux (x86_64, arm64, MIPS), macOS (x86_64), Raspberry PI, SMT32, WASM. For the full list of targets we can refer to the &lt;a href=&quot;../../reference/native-overview&quot;&gt;Kotlin/Native overview&lt;/a&gt;. While cross-platform compilation is possible (i.e., using one platform to compile for another), in this first tutorial we are only compiling for the operating system we're running on.</source>
          <target state="translated">Kotlin / Native 컴파일러는 macOS, Linux 및 Windows에서 사용할 수 있습니다. iOS (arm32, arm64, 시뮬레이터 x86_64), Windows (mingw32 및 x86_64), Linux (x86_64, arm64, MIPS), macOS (x86_64), Raspberry PI, SMT32, WASM 등 다양한 대상을 지원합니다. 전체 대상 목록은 &lt;a href=&quot;../../reference/native-overview&quot;&gt;Kotlin / Native 개요를&lt;/a&gt; 참조하십시오 . 플랫폼 간 컴파일이 가능하지만 (예를 들어, 한 플랫폼을 사용하여 다른 플랫폼을 위해 컴파일)이 첫 번째 자습서에서는 실행중인 운영 체제에 대해서만 컴파일하고 있습니다.</target>
        </trans-unit>
        <trans-unit id="81130cfc1e83adbcab9e6da86955c53516b100d6" translate="yes" xml:space="preserve">
          <source>The Language Committee makes final decisions on what incompatible changes will be made and what exact measures should be taken to make user updates comfortable. In doing so, it relies on a set of guidelines available &lt;a href=&quot;https://kotlinlang.org/foundation/language-committee-guidelines.html&quot;&gt;here&lt;/a&gt;.</source>
          <target state="translated">언어위원회는 호환되지 않는 변경 사항과 사용자 업데이트를 편하게하기 위해 어떤 조치를 취해야하는지에 대한 최종 결정을 내립니다. 그렇게 할 때 &lt;a href=&quot;https://kotlinlang.org/foundation/language-committee-guidelines.html&quot;&gt;여기&lt;/a&gt; 에있는 일련의 지침에 의존 합니다 .</target>
        </trans-unit>
        <trans-unit id="ef80e6d685a55893a99e950f4ed7fce2a86a1387" translate="yes" xml:space="preserve">
          <source>The Maven coordinates can be altered and additional artifact files may be added to the publications within the &lt;code&gt;targets { ... }&lt;/code&gt; block or the &lt;code&gt;publishing { ... }&lt;/code&gt; DSL:</source>
          <target state="translated">Maven 좌표를 변경하고 &lt;code&gt;targets { ... }&lt;/code&gt; 블록 또는 &lt;code&gt;publishing { ... }&lt;/code&gt; DSL 내의 게시에 추가 아티팩트 파일을 추가 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="cc27fb0be25fb775df8eea4ef2ba6465502161d0" translate="yes" xml:space="preserve">
          <source>The Nothing type</source>
          <target state="translated">아무것도없는 타입</target>
        </trans-unit>
        <trans-unit id="8cc0334fa925283a3687c8c8309944d9801a3bf7" translate="yes" xml:space="preserve">
          <source>The REPL command line interface opens. You can enter any valid Kotlin code and see the result. Results are printed as variables with auto-generated names like &lt;code&gt;res*&lt;/code&gt;. You can later use such variables in the code you run in REPL.</source>
          <target state="translated">REPL 명령 행 인터페이스가 열립니다. 유효한 Kotlin 코드를 입력하고 결과를 볼 수 있습니다. 결과는 &lt;code&gt;res*&lt;/code&gt; 와 같이 자동 생성 된 이름을 가진 변수로 인쇄됩니다 . 나중에 REPL에서 실행하는 코드에서 이러한 변수를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2b7ee6e00ac4369b5da7230befe3c113bdc4222a" translate="yes" xml:space="preserve">
          <source>The above code compiles. However, it will produce a runtime error if the object is not properly initialised before use or if &lt;code&gt;callAnything()&lt;/code&gt; is not defined at runtime.</source>
          <target state="translated">위의 코드는 컴파일됩니다. 그러나 사용하기 전에 객체가 올바르게 초기화되지 않았거나 런타임에 &lt;code&gt;callAnything()&lt;/code&gt; 이 정의되어 있지 않으면 런타임 오류가 발생 합니다.</target>
        </trans-unit>
        <trans-unit id="f67cd69d25bde43de96336b3847aa293b8518b9e" translate="yes" xml:space="preserve">
          <source>The above code indicates that the function is defined externally. The &lt;code&gt;@JsName(&quot;$&quot;)&lt;/code&gt; annotation allows us to map the name at runtime to &lt;code&gt;$&lt;/code&gt;. For more details on external declarations, please refer to the &lt;a href=&quot;../../reference/js-interop#external-modifier&quot;&gt;JavaScript interop documentation&lt;/a&gt;.</source>
          <target state="translated">위의 코드는 함수가 외부에서 정의되었음을 나타냅니다. &lt;code&gt;@JsName(&quot;$&quot;)&lt;/code&gt; 주석은 우리가 런타임에 이름을 매핑 할 수 있습니다 &lt;code&gt;$&lt;/code&gt; . 외부 선언에 대한 자세한 내용은 &lt;a href=&quot;../../reference/js-interop#external-modifier&quot;&gt;JavaScript interop 설명서&lt;/a&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="5749a0f0fe8aac855f406af86fe841d365cd7cde" translate="yes" xml:space="preserve">
          <source>The above could also be a oneliner - and note that the compiler knows that because the &lt;code&gt;throw&lt;/code&gt; will prevent &lt;code&gt;y&lt;/code&gt; from coming into existence if &lt;code&gt;x&lt;/code&gt; is null, &lt;code&gt;y&lt;/code&gt; must be non-null if we reach the line below. Contrast this with &lt;code&gt;x?.importantFunction()&lt;/code&gt;, which is a no-op if &lt;code&gt;x&lt;/code&gt; is null.</source>
          <target state="translated">위의 내용은 oneliner 일 수도 있습니다. 컴파일러는 &lt;code&gt;x&lt;/code&gt; 가 null 인 경우 &lt;code&gt;throw&lt;/code&gt; 로 인해 &lt;code&gt;y&lt;/code&gt; 가 존재 하지 못하게 되므로 아래 줄에 도달하면 &lt;code&gt;y&lt;/code&gt; 가 null 이 아니어야합니다. 이것을 &lt;code&gt;x?.importantFunction()&lt;/code&gt; 과 대조하십시오 . &lt;code&gt;x&lt;/code&gt; 가 null 이면 no-op 입니다.</target>
        </trans-unit>
        <trans-unit id="a87217033eafba44229106ab25d3816102c24f78" translate="yes" xml:space="preserve">
          <source>The above is preferable to:</source>
          <target state="translated">위의 사항은 다음보다 바람직합니다.</target>
        </trans-unit>
        <trans-unit id="83d32caa4c432fbb23e6f884577d8ac97faf56a2" translate="yes" xml:space="preserve">
          <source>The affected type parameter or type is &lt;em&gt;contravariant&lt;/em&gt;. Denoted by the &lt;code&gt;in&lt;/code&gt; modifier in the source code.</source>
          <target state="translated">영향을받는 유형 매개 변수 또는 유형은 &lt;em&gt;반 변형&lt;/em&gt; 입니다. 에 의해 표시 &lt;code&gt;in&lt;/code&gt; 소스 코드의 수정.</target>
        </trans-unit>
        <trans-unit id="c340d256f4b2e039e4cb98547a639c6b4f11b7ba" translate="yes" xml:space="preserve">
          <source>The affected type parameter or type is &lt;em&gt;covariant&lt;/em&gt;. Denoted by the &lt;code&gt;out&lt;/code&gt; modifier in the source code.</source>
          <target state="translated">영향을받는 유형 매개 변수 또는 유형은 &lt;em&gt;공변량&lt;/em&gt; 입니다. 에 의해 표시 &lt;code&gt;out&lt;/code&gt; 소스 코드의 수정.</target>
        </trans-unit>
        <trans-unit id="dff58c2fdf74d3cdbb35c54ab0e0155e83797493" translate="yes" xml:space="preserve">
          <source>The affected type parameter or type is &lt;em&gt;invariant&lt;/em&gt;, which means it has no variance applied to it.</source>
          <target state="translated">영향을받는 유형 매개 변수 또는 유형이 &lt;em&gt;변하지&lt;/em&gt; 않습니다. 즉, 분산이 적용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="e638916d7acda84432e87e4a36d2e48c0c286bc5" translate="yes" xml:space="preserve">
          <source>The annotation also works for constructors, static methods, and so on. It can't be used on abstract methods, including methods defined in interfaces.</source>
          <target state="translated">주석은 생성자, 정적 메서드 등에서도 작동합니다. 인터페이스에 정의 된 메소드를 포함한 추상 메소드에는 사용할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="718f26b180ad67d2a1e20d6b7d4406049d2961a3" translate="yes" xml:space="preserve">
          <source>The annotation can be used on top-level external declarations (classes, properties, functions) and files. In case of file (which can't be &lt;code&gt;external&lt;/code&gt;) the following rule applies: all the declarations in the file must be &lt;code&gt;external&lt;/code&gt;. By applying &lt;code&gt;@JsModule(...)&lt;/code&gt; on a file you tell the compiler to import a JavaScript object that contain all the declarations from the file.</source>
          <target state="translated">주석은 최상위 외부 선언 (클래스, 속성, 함수) 및 파일에서 사용할 수 있습니다. 파일 ( &lt;code&gt;external&lt;/code&gt; 수 없음 )의 경우 다음 규칙이 적용됩니다. 파일의 모든 선언은 &lt;code&gt;external&lt;/code&gt; 이어야합니다 . 파일에 &lt;code&gt;@JsModule(...)&lt;/code&gt; 을 적용 하면 파일에서 모든 선언이 포함 된 JavaScript 객체를 가져 오도록 컴파일러에 지시합니다.</target>
        </trans-unit>
        <trans-unit id="993a0bc9861bdf8ea351a5eb1dd7c588f24a97de" translate="yes" xml:space="preserve">
          <source>The annotations for marking and using experimental APIs (&lt;code&gt;@Experimental&lt;/code&gt; and &lt;code&gt;@UseExperimental&lt;/code&gt;) are &lt;em&gt;experimental&lt;/em&gt; in Kotlin 1.3. See details &lt;a href=&quot;#experimental-status-of-experimental-api-markers&quot;&gt;below&lt;/a&gt;.</source>
          <target state="translated">실험적 API ( &lt;code&gt;@Experimental&lt;/code&gt; 및 &lt;code&gt;@UseExperimental&lt;/code&gt; ) 를 표시하고 사용하기위한 주석은 Kotlin 1.3에서 &lt;em&gt;실험적&lt;/em&gt; 입니다. 세부 사항을 참조하십시오 &lt;a href=&quot;#experimental-status-of-experimental-api-markers&quot;&gt;아래를&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="ecb7079c4ed4f36ab04fb8b963913758bd291799" translate="yes" xml:space="preserve">
          <source>The anonymous function syntax allows you to specify the receiver type of a function literal directly. This can be useful if you need to declare a variable of a function type with receiver, and to use it later.</source>
          <target state="translated">익명 함수 구문을 사용하면 함수 리터럴의 수신자 유형을 직접 지정할 수 있습니다. 리시버로 함수 타입의 변수를 선언하고 나중에 사용해야 할 때 유용 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e99a96b83211ab5edf0514b0e8d206e232457fc5" translate="yes" xml:space="preserve">
          <source>The application we're going to create will simply show &lt;code&gt;Kotlin Rocks on Android&lt;/code&gt; on Android and &lt;code&gt;Kotlin Rocks on iOS &amp;lt;version&amp;gt;&lt;/code&gt; on iOS. The idea is to share the code that generates this message.</source>
          <target state="translated">우리가 만들 응용 프로그램은 Android의 Android에서는 &lt;code&gt;Kotlin Rocks on iOS &amp;lt;version&amp;gt;&lt;/code&gt; 에서는 &lt;code&gt;Kotlin Rocks on Android&lt;/code&gt; 표시 합니다. 이 메시지를 생성하는 코드를 공유하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="c116b8d3b85f1f036748497d93f617762a69f1eb" translate="yes" xml:space="preserve">
          <source>The array literal syntax is constrained to annotation arguments.</source>
          <target state="translated">배열 리터럴 구문은 주석 인수로 제한됩니다.</target>
        </trans-unit>
        <trans-unit id="e6585b22e37432101f079b3e68122b140a6c8d0b" translate="yes" xml:space="preserve">
          <source>The arrow notation is right-associative, &lt;code&gt;(Int) -&amp;gt; (Int) -&amp;gt; Unit&lt;/code&gt; is equivalent to the previous example, but not to &lt;code&gt;((Int) -&amp;gt; (Int)) -&amp;gt; Unit&lt;/code&gt;.</source>
          <target state="translated">화살표 표기법은 오른쪽 연관이며, &lt;code&gt;(Int) -&amp;gt; (Int) -&amp;gt; Unit&lt;/code&gt; 은 이전 예제와 동일하지만 &lt;code&gt;((Int) -&amp;gt; (Int)) -&amp;gt; Unit&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="eff75fbb6c3dbfe907753b9474216f02d469cd66" translate="yes" xml:space="preserve">
          <source>The author strongly recommends that you use an IDE with Kotlin support, as the static typing allows an IDE to do reliable navigation and code completion. I recommend &lt;a href=&quot;https://www.jetbrains.com/idea/&quot;&gt;IntelliJ IDEA&lt;/a&gt;, which is built by the same company that created Kotlin. The Community Edition is free; see &lt;a href=&quot;../getting-started&quot;&gt;instructions for getting started&lt;/a&gt; (it comes bundled with Kotlin, and you can run your program from the IDE).</source>
          <target state="translated">정적 타이핑을 사용하면 IDE에서 안정적인 탐색 및 코드 완성을 수행 할 수 있으므로 저자는 Kotlin을 지원하는 IDE를 사용하는 것이 좋습니다. Kotlin을 만든 회사에서 만든 &lt;a href=&quot;https://www.jetbrains.com/idea/&quot;&gt;IntelliJ IDEA를&lt;/a&gt; 권장 합니다. Community Edition은 무료입니다. &lt;a href=&quot;../getting-started&quot;&gt;시작 지침을&lt;/a&gt; 참조하십시오 (Kotlin과 함께 제공되며 IDE에서 프로그램을 실행할 수 있습니다).</target>
        </trans-unit>
        <trans-unit id="031b37e00f6cc7d0005e366d6305ce9ae5158eb7" translate="yes" xml:space="preserve">
          <source>The available options for persistence include direct JDBC access, JPA, as well as using NoSQL databases through their Java drivers. For JPA, the &lt;a href=&quot;compiler-plugins#jpa-support&quot;&gt;kotlin-jpa compiler plugin&lt;/a&gt; adapts Kotlin-compiled classes to the requirements of the framework.</source>
          <target state="translated">지속성에 사용 가능한 옵션에는 직접 JDBC 액세스, JPA 및 Java 드라이버를 통한 NoSQL 데이터베이스 사용이 포함됩니다. JPA의 경우, &lt;a href=&quot;compiler-plugins#jpa-support&quot;&gt;kotlin-jpa 컴파일러 플러그인&lt;/a&gt; 은 Kotlin으로 컴파일 된 클래스를 프레임 워크의 요구 사항에 맞게 조정합니다.</target>
        </trans-unit>
        <trans-unit id="f64d03b5ac4e40dff196fed46f6ad483b559e0ca" translate="yes" xml:space="preserve">
          <source>The base class for all errors and exceptions. Only instances of this class can be thrown or caught.</source>
          <target state="translated">모든 오류 및 예외의 기본 클래스입니다. 이 클래스의 인스턴스 만 던지거나 잡을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9567e5bd74f98cde043ce2604d36c00a7448fbca" translate="yes" xml:space="preserve">
          <source>The base exception class is &lt;code&gt;Throwable&lt;/code&gt; (but it is more common to extend its subclass &lt;code&gt;Exception&lt;/code&gt;), and there are a ton of built-in exception classes. If you don't find one that match your needs, you can create your own by inheriting from an existing exception class.</source>
          <target state="translated">기본 예외 클래스는 &lt;code&gt;Throwable&lt;/code&gt; 이지만 (하위 클래스 &lt;code&gt;Exception&lt;/code&gt; 확장하는 것이 더 일반적 임), 많은 내장 예외 클래스가 있습니다. 필요에 맞는 것을 찾지 못하면 기존 예외 클래스에서 상속하여 직접 만들 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d9ecc0f2cf4982d26aff3dd399995b9e266ca38f" translate="yes" xml:space="preserve">
          <source>The basic association function &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/associate-with&quot;&gt;&lt;code&gt;associateWith()&lt;/code&gt;&lt;/a&gt; creates a &lt;code&gt;Map&lt;/code&gt; in which the elements of the original collection are keys, and values are produced from them by the given transformation function. If two elements are equal, only the last one remains in the map.</source>
          <target state="translated">기본 연관 함수 ( &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/associate-with&quot;&gt; &lt;code&gt;associateWith()&lt;/code&gt; &lt;/a&gt; 는 원래 컬렉션의 요소가 키이고 지정된 변환 함수에 의해 값이 생성되는 &lt;code&gt;Map&lt;/code&gt; 을 만듭니다 . 두 요소가 같으면 마지막 요소 만 맵에 남아 있습니다.</target>
        </trans-unit>
        <trans-unit id="8747487378c0fd48a48984cf8a26dd2308ffac09" translate="yes" xml:space="preserve">
          <source>The basic filtering function is &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/filter&quot;&gt;&lt;code&gt;filter()&lt;/code&gt;&lt;/a&gt;. When called with a predicate, &lt;code&gt;filter()&lt;/code&gt; returns the collection elements that match it. For both &lt;code&gt;List&lt;/code&gt; and &lt;code&gt;Set&lt;/code&gt;, the resulting collection is a &lt;code&gt;List&lt;/code&gt;, for &lt;code&gt;Map&lt;/code&gt; it's a &lt;code&gt;Map&lt;/code&gt; as well.</source>
          <target state="translated">기본 필터링 함수는 &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/filter&quot;&gt; &lt;code&gt;filter()&lt;/code&gt; &lt;/a&gt; 입니다. 술어와 함께 호출되면 &lt;code&gt;filter()&lt;/code&gt; 는 일치하는 콜렉션 요소를 리턴합니다. &lt;code&gt;List&lt;/code&gt; 및 &lt;code&gt;Set&lt;/code&gt; 모두 결과 컬렉션은 &lt;code&gt;List&lt;/code&gt; 이며 &lt;code&gt;Map&lt;/code&gt; 의 경우 &lt;code&gt;Map&lt;/code&gt; 이기도합니다.</target>
        </trans-unit>
        <trans-unit id="699437afba4c1eb6f2aa1a305318c9d9571a4fe8" translate="yes" xml:space="preserve">
          <source>The basic functions &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/sorted&quot;&gt;&lt;code&gt;sorted()&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/sorted-descending&quot;&gt;&lt;code&gt;sortedDescending()&lt;/code&gt;&lt;/a&gt; return elements of a collection sorted into ascending and descending sequence according to their natural order. These functions apply to collections of &lt;code&gt;Comparable&lt;/code&gt; elements.</source>
          <target state="translated">기본 함수 &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/sorted&quot;&gt; &lt;code&gt;sorted()&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/sorted-descending&quot;&gt; &lt;code&gt;sortedDescending()&lt;/code&gt; &lt;/a&gt; 은 자연 순서에 따라 오름차순 및 내림차순으로 정렬 된 컬렉션의 요소를 반환합니다. 이러한 기능은 &lt;code&gt;Comparable&lt;/code&gt; 요소의 모음에 적용됩니다 .</target>
        </trans-unit>
        <trans-unit id="176655605bee6eae4892bd4ec703e94408b0c3f3" translate="yes" xml:space="preserve">
          <source>The best place to start is &lt;a href=&quot;https://kotlinlang.org&quot;&gt;this website&lt;/a&gt;. From there you can download the compiler, &lt;a href=&quot;https://play.kotlinlang.org&quot;&gt;try it online&lt;/a&gt; as well as get access to resources, &lt;a href=&quot;index&quot;&gt;reference documentation&lt;/a&gt; and &lt;a href=&quot;../tutorials/index&quot;&gt;tutorials&lt;/a&gt;.</source>
          <target state="translated">시작하기 가장 좋은 곳은 &lt;a href=&quot;https://kotlinlang.org&quot;&gt;이 웹 사이트&lt;/a&gt; 입니다. 여기에서 컴파일러를 다운로드하고 &lt;a href=&quot;https://play.kotlinlang.org&quot;&gt;온라인&lt;/a&gt; 으로 시도 할 수있을 뿐만 아니라 리소스, &lt;a href=&quot;index&quot;&gt;참조 설명서&lt;/a&gt; 및 &lt;a href=&quot;../tutorials/index&quot;&gt;자습서에&lt;/a&gt; 액세스 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="a00b10508469a6652d6e476b8749625b68deb8ad" translate="yes" xml:space="preserve">
          <source>The best way to see what C data types are visible in Kotlin is to try it</source>
          <target state="translated">Kotlin에서 C 데이터 유형을 볼 수있는 가장 좋은 방법은 시도하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="8cccc62dffea928c706df5dfd73f9995b0b8212a" translate="yes" xml:space="preserve">
          <source>The best way to understand the mapping between C and Kotlin languages is to try it out on a small example. We will create a small library headers for that. First, we need to create a &lt;code&gt;lib.h&lt;/code&gt; file with the following declaration of functions that deal with the C strings:</source>
          <target state="translated">C와 Kotlin 언어 간의 매핑을 이해하는 가장 좋은 방법은 간단한 예를 통해 시험해 보는 것입니다. 이를 위해 작은 라이브러리 헤더를 만들 것입니다. 먼저 C 문자열을 처리하는 다음 함수 선언으로 &lt;code&gt;lib.h&lt;/code&gt; 파일 을 만들어야합니다 .</target>
        </trans-unit>
        <trans-unit id="ffd6c6681f86404c6d10fd90b4e30255a8c338ed" translate="yes" xml:space="preserve">
          <source>The best way to understand the mapping between Kotlin and C is to try a tiny example. We declare a function that accepts a function pointer as a parameter and another function that returns a function pointer.</source>
          <target state="translated">Kotlin과 C의 매핑을 이해하는 가장 좋은 방법은 작은 예를 시도하는 것입니다. 함수 포인터를 매개 변수로 받아들이는 함수와 함수 포인터를 반환하는 다른 함수를 선언합니다.</target>
        </trans-unit>
        <trans-unit id="6537550691113ba29bcd420ea4633f14458a70b1" translate="yes" xml:space="preserve">
          <source>The best way to understand the mapping between Kotlin and C is to try a tiny example. We will declare a struct and a union in the C language, to see how they are mapped into Kotlin.</source>
          <target state="translated">Kotlin과 C의 매핑을 이해하는 가장 좋은 방법은 작은 예를 시도하는 것입니다. 우리는 C 언어로 구조체와 공용체를 선언하여 코 틀린에 어떻게 매핑되는지 확인합니다.</target>
        </trans-unit>
        <trans-unit id="4232ac266b4561b99b9bc10fa2be9171a24a3226" translate="yes" xml:space="preserve">
          <source>The best way to understand these techniques is to try them out. Let's create a first tiny Kotlin library and use it from a C program.</source>
          <target state="translated">이러한 기술을 이해하는 가장 좋은 방법은 시험해 보는 것입니다. 첫 번째 작은 Kotlin 라이브러리를 만들어 C 프로그램에서 사용하겠습니다.</target>
        </trans-unit>
        <trans-unit id="eaa47ef7640a883ac2445b67958ca2668d316a2e" translate="yes" xml:space="preserve">
          <source>The best way to use the Kotlin/Native compiler is with a build system. It helps by downloading and caching the Kotlin/Native compiler binaries and libraries with transitive dependencies, and running the compiler and tests. It caches the compilation results too. A build system can also be used by an IDE to understand the project layout.</source>
          <target state="translated">Kotlin / Native 컴파일러를 사용하는 가장 좋은 방법은 빌드 시스템을 사용하는 것입니다. 전이 의존성이있는 Kotlin / Native 컴파일러 바이너리 및 라이브러리를 다운로드 및 캐싱하고 컴파일러 및 테스트를 실행하면 도움이됩니다. 컴파일 결과도 캐시합니다. IDE에서 빌드 시스템을 사용하여 프로젝트 레이아웃을 이해할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="9af9e08ad353ac6ed57e0041c23dca829fbff7c4" translate="yes" xml:space="preserve">
          <source>The binaries DSL allows not only creating binaries but also accessing already created ones to configure them or get their properties (e.g. path to an output file). The &lt;code&gt;binaries&lt;/code&gt; collection implements the &lt;a href=&quot;https://docs.gradle.org/current/javadoc/org/gradle/api/DomainObjectSet.html&quot;&gt;&lt;code&gt;DomainObjectSet&lt;/code&gt;&lt;/a&gt; interface and provides methods like &lt;code&gt;all&lt;/code&gt; or &lt;code&gt;matching&lt;/code&gt; allowing configuring groups of elements.</source>
          <target state="translated">바이너리 DSL을 사용하면 바이너리를 생성 할뿐만 아니라 이미 생성 된 바이너리에 액세스하여이를 구성하거나 속성 (예 : 출력 파일 경로)을 얻을 수 있습니다. &lt;code&gt;binaries&lt;/code&gt; 컬렉션 구현 &lt;a href=&quot;https://docs.gradle.org/current/javadoc/org/gradle/api/DomainObjectSet.html&quot;&gt; &lt;code&gt;DomainObjectSet&lt;/code&gt; 의&lt;/a&gt; 인터페이스와 같은 방법을 제공하는 &lt;code&gt;all&lt;/code&gt; 또는 &lt;code&gt;matching&lt;/code&gt; 요소의 그룹을 구성 가능하게한다.</target>
        </trans-unit>
        <trans-unit id="bc8bcc38381183bfcc94707aa9b37df0e52f23b1" translate="yes" xml:space="preserve">
          <source>The binary files are created in the &lt;code&gt;build/bin/native/debugExecutable&lt;/code&gt; or &lt;code&gt;build/bin/native/releaseExecutable&lt;/code&gt; folders respectively. The file has a &lt;code&gt;.kexe&lt;/code&gt; extension on Linux and macOS and an &lt;code&gt;.exe&lt;/code&gt; extension on Windows. Use the following command to instruct the build to produce binaries:</source>
          <target state="translated">이진 파일은 각각 &lt;code&gt;build/bin/native/debugExecutable&lt;/code&gt; 또는 &lt;code&gt;build/bin/native/releaseExecutable&lt;/code&gt; 폴더에 생성됩니다. 파일은 Linux 및 macOS에서 확장자 가 &lt;code&gt;.kexe&lt;/code&gt; 이고 Windows에서 확장자 가 &lt;code&gt;.exe&lt;/code&gt; 입니다. 바이너리를 생성하도록 빌드에 지시하려면 다음 명령을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="54650137fcf92a797ec9822a89e0e51a3d74473c" translate="yes" xml:space="preserve">
          <source>The block after &lt;code&gt;tree(&quot;root&quot;)&lt;/code&gt; is the first function literal with receiver, which will be passed to &lt;code&gt;tree()&lt;/code&gt; as the &lt;code&gt;initialize&lt;/code&gt; parameter. According to the parameter list of &lt;code&gt;tree()&lt;/code&gt;, the receiver is of type &lt;code&gt;TreeNode&lt;/code&gt;, and therefore, &lt;code&gt;tree()&lt;/code&gt; can call &lt;code&gt;initialize()&lt;/code&gt; on &lt;code&gt;root&lt;/code&gt;. &lt;code&gt;root&lt;/code&gt; then becomes &lt;code&gt;this&lt;/code&gt; inside the scope of that lambda expression, so when we call &lt;code&gt;node(&quot;math&quot;)&lt;/code&gt;, it implicitly says &lt;code&gt;this.node(&quot;math&quot;)&lt;/code&gt;, where &lt;code&gt;this&lt;/code&gt; refers to the same &lt;code&gt;TreeNode&lt;/code&gt; as &lt;code&gt;root&lt;/code&gt;. The next block is passed to &lt;code&gt;TreeNode.node()&lt;/code&gt;, and is invoked on the first child of the &lt;code&gt;root&lt;/code&gt; node, namely &lt;code&gt;math&lt;/code&gt;, and inside it, &lt;code&gt;this&lt;/code&gt; will refer to &lt;code&gt;math&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;tree(&quot;root&quot;)&lt;/code&gt; 뒤의 블록 은 수신자가있는 첫 번째 함수 리터럴이며 , &lt;code&gt;initialize&lt;/code&gt; 매개 변수 로 &lt;code&gt;tree()&lt;/code&gt; 전달됩니다 . &lt;code&gt;tree()&lt;/code&gt; 의 매개 변수 목록에 따르면 수신자는 &lt;code&gt;TreeNode&lt;/code&gt; 유형 이므로 &lt;code&gt;tree()&lt;/code&gt; 는 &lt;code&gt;root&lt;/code&gt; 에서 &lt;code&gt;initialize()&lt;/code&gt; 를 호출 할 수 있습니다 . &lt;code&gt;root&lt;/code&gt; 다음이된다 &lt;code&gt;this&lt;/code&gt; 그 람다 식의 범위 내에서, 그래서 우리는 호출 할 때 &lt;code&gt;node(&quot;math&quot;)&lt;/code&gt; , 그것은 암시 적으로 말한다 &lt;code&gt;this.node(&quot;math&quot;)&lt;/code&gt; , &lt;code&gt;this&lt;/code&gt; 같은를 의미 &lt;code&gt;TreeNode&lt;/code&gt; 를 같은 &lt;code&gt;root&lt;/code&gt; . 다음 블록에 전달됩니다 &lt;code&gt;TreeNode.node()&lt;/code&gt; 과의 첫 번째 자식에 호출 &lt;code&gt;root&lt;/code&gt; 노드, 즉 &lt;code&gt;math&lt;/code&gt; , 그리고 그 안에, &lt;code&gt;this&lt;/code&gt; 참조됩니다 &lt;code&gt;math&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="299004dba6c7ef441e08541633a7bed7d65922cd" translate="yes" xml:space="preserve">
          <source>The body can be a block.</source>
          <target state="translated">몸은 블록이 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d17dad4981064bd9e13820de989411c6afec8c62" translate="yes" xml:space="preserve">
          <source>The body of an object expression may access, and possibly modify, the local variables of the containing scope.</source>
          <target state="translated">객체 표현식의 본문은 포함하는 범위의 로컬 변수에 액세스하고 가능하면 수정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6eb082a62156761cbe45120602d0be4ff5a5d1b2" translate="yes" xml:space="preserve">
          <source>The box classes used for capturing mutable closure variables in lambdas no longer have volatile fields. This change improves performance, but can lead to new race conditions in some rare usage scenarios. If you're affected by this, you need to provide your own synchronization for accessing the variables.</source>
          <target state="translated">람다에서 가변 클로저 변수를 캡처하는 데 사용되는 박스 클래스에는 더 이상 휘발성 필드가 없습니다. 이 변경으로 성능이 향상되지만 드문 사용 시나리오에서 새로운 경쟁 조건이 발생할 수 있습니다. 이에 영향을받는 경우 변수에 액세스하기위한 고유 한 동기화를 제공해야합니다.</target>
        </trans-unit>
        <trans-unit id="0bb1979f4fa500a54eb079957dc97f38da2dd0fd" translate="yes" xml:space="preserve">
          <source>The build generates the following files under the &lt;code&gt;build/bin/native/debugShared&lt;/code&gt; folder, depending on the host OS:</source>
          <target state="translated">빌드 는 호스트 OS에 따라 &lt;code&gt;build/bin/native/debugShared&lt;/code&gt; 폴더 아래에 다음 파일을 생성합니다 .</target>
        </trans-unit>
        <trans-unit id="8d7f1cfca83f4be43b98d7bc6f3dc13e77358eda" translate="yes" xml:space="preserve">
          <source>The call to &lt;code&gt;C().foo(1)&lt;/code&gt; will print &quot;extension&quot;.</source>
          <target state="translated">&lt;code&gt;C().foo(1)&lt;/code&gt; 대한 호출 은 &quot;extension&quot;을 인쇄합니다.</target>
        </trans-unit>
        <trans-unit id="5986952e4227de9affa4abe69a35c446c0bfc14d" translate="yes" xml:space="preserve">
          <source>The call to &lt;code&gt;execute&lt;/code&gt; uses a function passed as its second parameter to produce an object subgraph (i.e. set of mutually referring objects) which is then passed as a whole to that worker, it is then no longer available to the thread that initiated the request. This property is checked if the first parameter is &lt;code&gt;TransferMode.SAFE&lt;/code&gt; by graph traversal and is just assumed to be true, if it is &lt;code&gt;TransferMode.UNSAFE&lt;/code&gt;. The last parameter to &lt;code&gt;execute&lt;/code&gt; is a special Kotlin lambda, which is not allowed to capture any state, and is actually invoked in the target worker's context. Once processed, the result is transferred to whatever consumes it in the future, and it is attached to the object graph of that worker/thread.</source>
          <target state="translated">&lt;code&gt;execute&lt;/code&gt; 호출 은 두 번째 매개 변수로 전달 된 함수를 사용하여 오브젝트 서브 그래프 (즉, 상호 참조 오브젝트 세트)를 생성 한 다음 해당 워커에 전체적으로 전달하여 요청을 시작한 스레드에서 더 이상 사용할 수 없게합니다. 첫 번째 변수 인 경우이 속성 판정 &lt;code&gt;TransferMode.SAFE&lt;/code&gt; 이 그래프 순회로하고 있는지 바로 진정한 것으로 가정 &lt;code&gt;TransferMode.UNSAFE&lt;/code&gt; 이 . 마지막으로 &lt;code&gt;execute&lt;/code&gt; 매개 변수 는 특수 Kotlin 람다이며, 상태를 캡처 할 수 없으며 실제로 대상 작업자의 컨텍스트에서 호출됩니다. 일단 처리되면 결과는 나중에 소비되는 모든 항목으로 전송되고 해당 작업자 / 스레드의 개체 그래프에 첨부됩니다.</target>
        </trans-unit>
        <trans-unit id="cf4d64ccc981a36348dc5e3486734b7a527c1cd6" translate="yes" xml:space="preserve">
          <source>The callback which is called after the change of the property is made. The value of the property has already been changed when this callback is invoked.</source>
          <target state="translated">속성 변경 후 호출되는 콜백이 작성됩니다. 이 콜백이 호출 될 때 속성 값이 이미 변경되었습니다.</target>
        </trans-unit>
        <trans-unit id="f46a88a879fdbb85f0bd5182483f8be3f20e50d2" translate="yes" xml:space="preserve">
          <source>The callback which is called before a change to the property value is attempted. The value of the property hasn't been changed yet, when this callback is invoked. If the callback returns &lt;code&gt;true&lt;/code&gt; the value of the property is being set to the new value, and if the callback returns &lt;code&gt;false&lt;/code&gt; the new value is discarded and the property remains its old value.</source>
          <target state="translated">속성 값을 변경하기 전에 호출되는 콜백입니다. 이 콜백이 호출 될 때 속성 값이 아직 변경되지 않았습니다. 콜백이 &lt;code&gt;true&lt;/code&gt; 를 반환 하면 속성 값이 새 값으로 설정되고 콜백이 &lt;code&gt;false&lt;/code&gt; 를 반환 하면 새 값이 삭제되고 속성은 이전 값으로 유지됩니다.</target>
        </trans-unit>
        <trans-unit id="e3032cd7941afef1fb6a2120a573d1232d288d72" translate="yes" xml:space="preserve">
          <source>The calls that affect inference are either members of the receiver type of an annotated function parameter or extensions for that type. The extensions must be themselves annotated with &lt;code&gt;@BuilderInference&lt;/code&gt;.</source>
          <target state="translated">추론에 영향을 미치는 호출은 어노테이션이있는 함수 매개 변수의 수신자 유형 또는 해당 유형의 확장입니다. 확장명은 반드시 &lt;code&gt;@BuilderInference&lt;/code&gt; 로 주석을 달아야 합니다.</target>
        </trans-unit>
        <trans-unit id="5833c1f716afd68e76f6ee63506f61a1ac4d8150" translate="yes" xml:space="preserve">
          <source>The changes in dependencies are &lt;a href=&quot;https://en.wikipedia.org/wiki/Application_binary_interface&quot;&gt;ABI&lt;/a&gt; compatible. For example, the only changes are in method bodies.</source>
          <target state="translated">종속성 변경은 &lt;a href=&quot;https://en.wikipedia.org/wiki/Application_binary_interface&quot;&gt;ABI&lt;/a&gt; 와 호환됩니다. 예를 들어, 메소드 본문에서만 변경 사항이 있습니다.</target>
        </trans-unit>
        <trans-unit id="ca6d3d47c03bc25dbb852207c0d849513ed5fbaf" translate="yes" xml:space="preserve">
          <source>The channels shown so far had no buffer. Unbuffered channels transfer elements when sender and receiver meet each other (aka rendezvous). If send is invoked first, then it is suspended until receive is invoked, if receive is invoked first, it is suspended until send is invoked.</source>
          <target state="translated">지금까지 표시된 채널에는 버퍼가 없습니다. 송신자와 수신자가 서로 만날 때 버퍼되지 않은 채널 전송 요소 (일명 랑데부). send가 먼저 호출되면 receive가 호출 될 때까지 일시 중단되고 receive가 먼저 호출되면 send가 호출 될 때까지 일시 중단됩니다.</target>
        </trans-unit>
        <trans-unit id="fa768c5c4432c77d50de790cda1c8c687dccf1cc" translate="yes" xml:space="preserve">
          <source>The character &quot; &amp;ndash; quotation mark</source>
          <target state="translated">문자 &quot;&amp;ndash; 인용 부호</target>
        </trans-unit>
        <trans-unit id="10c860623b3bfd4256ce034a4fa10ecca2e8d17c" translate="yes" xml:space="preserve">
          <source>The character $ &amp;ndash; dollar sign</source>
          <target state="translated">문자 $ &amp;ndash; 달러 기호</target>
        </trans-unit>
        <trans-unit id="bb0b9f77aa3a2b1b235948227a9bb6e95724f73c" translate="yes" xml:space="preserve">
          <source>The character &amp;Dagger;</source>
          <target state="translated">캐릭터 &amp;Dagger;</target>
        </trans-unit>
        <trans-unit id="97d065e0957f914068e24066c8bc53313cb9196a" translate="yes" xml:space="preserve">
          <source>The character &amp;Prime;</source>
          <target state="translated">캐릭터 &quot;</target>
        </trans-unit>
        <trans-unit id="697b0963155a10d5f080f157c0e1d9c9aacc9b21" translate="yes" xml:space="preserve">
          <source>The character &amp;amp; &amp;ndash; ampersand</source>
          <target state="translated">캐릭터 &amp;amp; &amp;ndash; 앰퍼샌드</target>
        </trans-unit>
        <trans-unit id="094872d2798a25e27adaff380803676c236be373" translate="yes" xml:space="preserve">
          <source>The character &amp;asymp;</source>
          <target state="translated">캐릭터 &amp;asymp;</target>
        </trans-unit>
        <trans-unit id="41d60c0526caa8463741bd966759bf19026cb739" translate="yes" xml:space="preserve">
          <source>The character &amp;bdquo;</source>
          <target state="translated">캐릭터 &quot;</target>
        </trans-unit>
        <trans-unit id="fff1f1e9d607e97e90b4bc028bb0cc7f10c48e01" translate="yes" xml:space="preserve">
          <source>The character &amp;bull;</source>
          <target state="translated">캐릭터 &amp;bull;</target>
        </trans-unit>
        <trans-unit id="143c3fcec665ebddc83c2753db67d88e2fbaf38a" translate="yes" xml:space="preserve">
          <source>The character &amp;cent;</source>
          <target state="translated">캐릭터 &amp;cent;</target>
        </trans-unit>
        <trans-unit id="ee171eaf967121aa215c85e62d2ec509ebb04257" translate="yes" xml:space="preserve">
          <source>The character &amp;copy;</source>
          <target state="translated">캐릭터 &amp;copy;</target>
        </trans-unit>
        <trans-unit id="314c38bf0716b200771c1a885fab69a9b65b99c6" translate="yes" xml:space="preserve">
          <source>The character &amp;dagger;</source>
          <target state="translated">캐릭터 &amp;dagger;</target>
        </trans-unit>
        <trans-unit id="6f9bd3084db43833f63880cca5d946309a97ca39" translate="yes" xml:space="preserve">
          <source>The character &amp;deg;</source>
          <target state="translated">문자 &amp;deg;</target>
        </trans-unit>
        <trans-unit id="0e423b28ce34d3cf18fda3a07cf0dfa515d8890e" translate="yes" xml:space="preserve">
          <source>The character &amp;euro;</source>
          <target state="translated">캐릭터 &amp;euro;</target>
        </trans-unit>
        <trans-unit id="b1449855c21d4fd06c0d5e74b5a2a7a14edf968a" translate="yes" xml:space="preserve">
          <source>The character &amp;frac12;</source>
          <target state="translated">캐릭터 &amp;frac12;</target>
        </trans-unit>
        <trans-unit id="1fa4a09afc8d4c4f53c306db471f300c4497957c" translate="yes" xml:space="preserve">
          <source>The character &amp;ge;</source>
          <target state="translated">문자 &amp;ge;</target>
        </trans-unit>
        <trans-unit id="3dfbeeaef1c98d8a22709ebef333428072939a42" translate="yes" xml:space="preserve">
          <source>The character &amp;gt; &amp;ndash; greater-than sign</source>
          <target state="translated">문자&amp;gt; &amp;ndash;보다 큼 부호</target>
        </trans-unit>
        <trans-unit id="6eb5e1e14a002081da7d716b380be22cde00b939" translate="yes" xml:space="preserve">
          <source>The character &amp;hellip;</source>
          <target state="translated">캐릭터 &amp;hellip;</target>
        </trans-unit>
        <trans-unit id="a01873a887462b6593c2f5f42a550b38052e578a" translate="yes" xml:space="preserve">
          <source>The character &amp;laquo;</source>
          <target state="translated">캐릭터 &quot;</target>
        </trans-unit>
        <trans-unit id="e667dca130564a78a41110f6cbd1264a713d8dd2" translate="yes" xml:space="preserve">
          <source>The character &amp;ldquo;</source>
          <target state="translated">캐릭터 &quot;</target>
        </trans-unit>
        <trans-unit id="950de0de2afce4fa96ad4f62ca4dab286d3d82a8" translate="yes" xml:space="preserve">
          <source>The character &amp;le;</source>
          <target state="translated">문자 &amp;le;</target>
        </trans-unit>
        <trans-unit id="9023ce61724bbabe84554211f1682a5b7d26a59b" translate="yes" xml:space="preserve">
          <source>The character &amp;lsquo;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e9f2776cd83195ab61d81c705eb53d1d3649fd0e" translate="yes" xml:space="preserve">
          <source>The character &amp;lt; &amp;ndash; less-than sign</source>
          <target state="translated">문자 &amp;lt;&amp;ndash;보다 작은 부호</target>
        </trans-unit>
        <trans-unit id="7e613a75a280526a06a5c3a8cccd7722979dfc79" translate="yes" xml:space="preserve">
          <source>The character &amp;mdash;</source>
          <target state="translated">캐릭터 -</target>
        </trans-unit>
        <trans-unit id="257dd2718c3d554488c288a2e9f88456100a73ef" translate="yes" xml:space="preserve">
          <source>The character &amp;middot;</source>
          <target state="translated">캐릭터 &amp;middot;</target>
        </trans-unit>
        <trans-unit id="b00154ce5f2758f6abb5e4356e419ba3e2aed105" translate="yes" xml:space="preserve">
          <source>The character &amp;ndash;</source>
          <target state="translated">캐릭터 -</target>
        </trans-unit>
        <trans-unit id="aad571a2b53620d99840a4d55bce3f5907371d75" translate="yes" xml:space="preserve">
          <source>The character &amp;ne;</source>
          <target state="translated">문자 &amp;ne;</target>
        </trans-unit>
        <trans-unit id="a360453c2e244288bd242eeb7641ad601e593f75" translate="yes" xml:space="preserve">
          <source>The character &amp;para;</source>
          <target state="translated">캐릭터 &amp;para;</target>
        </trans-unit>
        <trans-unit id="1c97c4311adda721fa170a84ab8496cb5535afa3" translate="yes" xml:space="preserve">
          <source>The character &amp;plusmn;</source>
          <target state="translated">문자 &amp;plusmn;</target>
        </trans-unit>
        <trans-unit id="55144636deb97ada56b2d29a7bb655a9f22ea932" translate="yes" xml:space="preserve">
          <source>The character &amp;pound;</source>
          <target state="translated">캐릭터 &amp;pound;</target>
        </trans-unit>
        <trans-unit id="09c581b6f45120a7ecac89f6de96696cea52b01c" translate="yes" xml:space="preserve">
          <source>The character &amp;prime;</source>
          <target state="translated">캐릭터 '</target>
        </trans-unit>
        <trans-unit id="c49eacef46814486b9678b461b5fad7053d65453" translate="yes" xml:space="preserve">
          <source>The character &amp;raquo;</source>
          <target state="translated">캐릭터 &quot;</target>
        </trans-unit>
        <trans-unit id="b94a5614ad8379d659840f63e74a095d51d6a7c0" translate="yes" xml:space="preserve">
          <source>The character &amp;rdquo;</source>
          <target state="translated">캐릭터 &quot;</target>
        </trans-unit>
        <trans-unit id="be87e8e3080722678155d4e087ea1bf466788605" translate="yes" xml:space="preserve">
          <source>The character &amp;reg;</source>
          <target state="translated">캐릭터 &amp;reg;</target>
        </trans-unit>
        <trans-unit id="e6daa833ce04c765a61d1650a1e4e3d75924ca44" translate="yes" xml:space="preserve">
          <source>The character &amp;rsquo;</source>
          <target state="translated">캐릭터 '</target>
        </trans-unit>
        <trans-unit id="43ad6d82b90d71d375e73e1b9402ca5934e45166" translate="yes" xml:space="preserve">
          <source>The character &amp;sbquo;</source>
          <target state="translated">캐릭터 ,</target>
        </trans-unit>
        <trans-unit id="4139cb770ca9a15c26a42368989f1dc39e1910da" translate="yes" xml:space="preserve">
          <source>The character &amp;sect;</source>
          <target state="translated">캐릭터 &amp;sect;</target>
        </trans-unit>
        <trans-unit id="98e7fc24f032b2c1437d0f55811d67ee1de7b88e" translate="yes" xml:space="preserve">
          <source>The character &amp;times;</source>
          <target state="translated">캐릭터 &amp;times;</target>
        </trans-unit>
        <trans-unit id="f6467d07a9719c1073ddb29614f3d2a5ac72dfb3" translate="yes" xml:space="preserve">
          <source>The character &amp;trade;</source>
          <target state="translated">캐릭터 &amp;trade;</target>
        </trans-unit>
        <trans-unit id="1789ee1227acc918fbc63737b2058bf75be81287" translate="yes" xml:space="preserve">
          <source>The class can also declare &lt;strong&gt;secondary constructors&lt;/strong&gt;, which are prefixed with &lt;em&gt;constructor&lt;/em&gt;:</source>
          <target state="translated">클래스는 &lt;strong&gt;2 차 생성자를&lt;/strong&gt; 선언 할 수 있으며 , &lt;em&gt;생성자&lt;/em&gt; 앞에 접두사가 붙습니다 .</target>
        </trans-unit>
        <trans-unit id="bc78b13ff48b9fc50475495610ff41f558bf6256" translate="yes" xml:space="preserve">
          <source>The class declaration consists of the class name, the class header (specifying its type parameters, the primary constructor etc.) and the class body, surrounded by curly braces. Both the header and the body are optional; if the class has no body, curly braces can be omitted.</source>
          <target state="translated">클래스 선언은 클래스 이름, 클래스 헤더 (유형 매개 변수 지정, 기본 생성자 등) 및 중괄호로 묶인 클래스 본문으로 구성됩니다. 헤더와 본문은 모두 선택 사항입니다. 클래스에 본문이 없으면 중괄호를 생략 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="20fb66c6dd38ed7ad8f3ab7df8f07a3ccc7c3a1d" translate="yes" xml:space="preserve">
          <source>The class file with a kind not listed here is treated as a non-Kotlin file.</source>
          <target state="translated">여기에 나열되지 않은 종류의 클래스 파일은 코 틀린이 아닌 파일로 취급됩니다.</target>
        </trans-unit>
        <trans-unit id="8d923d6e9fe47217a8cbe28cd4bc0054618db9f2" translate="yes" xml:space="preserve">
          <source>The code above uses a &lt;a href=&quot;reflection#bound-class-references-since-11&quot;&gt;bound class reference&lt;/a&gt;, which is supported since Kotlin 1.1. You can also use the &lt;code&gt;javaClass&lt;/code&gt; extension property:</source>
          <target state="translated">위의 코드는 &lt;a href=&quot;reflection#bound-class-references-since-11&quot;&gt;바운드 클래스 참조를&lt;/a&gt; 사용하며 , Kotlin 1.1부터 지원됩니다. &lt;code&gt;javaClass&lt;/code&gt; 확장 등록 정보를 사용할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="2a037143482eba48d7a06126430f1e3e039ee172" translate="yes" xml:space="preserve">
          <source>The code in question is from the &lt;a href=&quot;https://curl.haxx.se/libcurl/c/simple.html&quot;&gt;simple&lt;/a&gt; example (comments removed for brevity)</source>
          <target state="translated">문제의 코드는 &lt;a href=&quot;https://curl.haxx.se/libcurl/c/simple.html&quot;&gt;간단한&lt;/a&gt; 예 에서 나온 것입니다.</target>
        </trans-unit>
        <trans-unit id="02b7f3091db5cc1f6df8785c890e5a0df1e43276" translate="yes" xml:space="preserve">
          <source>The code in the &lt;code&gt;hello.kt&lt;/code&gt; file may look like this:</source>
          <target state="translated">&lt;code&gt;hello.kt&lt;/code&gt; 파일 의 코드 는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="8051836ca1f9bfcf8f55044dce46370d2274f4e3" translate="yes" xml:space="preserve">
          <source>The code in the final &lt;code&gt;hello.kt&lt;/code&gt; file may look like this:</source>
          <target state="translated">최종 &lt;code&gt;hello.kt&lt;/code&gt; 파일 의 코드 는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="53a9cf6b4f40ef47e2031c236bc499f1385bb27e" translate="yes" xml:space="preserve">
          <source>The code is full of Objective-C attributes, which are intended to help the use of the framework from both Objective-C and Swift languages. &lt;code&gt;DemoClazz&lt;/code&gt;, &lt;code&gt;DemoInterface&lt;/code&gt;, and &lt;code&gt;DemoObject&lt;/code&gt; are created for &lt;code&gt;Clazz&lt;/code&gt;, &lt;code&gt;Interface&lt;/code&gt;, and &lt;code&gt;Object&lt;/code&gt; respectively. The &lt;code&gt;Interface&lt;/code&gt; is turned into &lt;code&gt;@protocol&lt;/code&gt;, both a &lt;code&gt;class&lt;/code&gt; and an &lt;code&gt;object&lt;/code&gt; are represented as &lt;code&gt;@interface&lt;/code&gt;. The &lt;code&gt;Demo&lt;/code&gt; prefix comes from the &lt;code&gt;-output&lt;/code&gt; parameter of the &lt;code&gt;kotlinc-native&lt;/code&gt; compiler and the framework name. We see here that the nullable return type &lt;code&gt;ULong?&lt;/code&gt; is turned into &lt;code&gt;DemoLong*&lt;/code&gt; in Objective-C.</source>
          <target state="translated">이 코드는 Objective-C 및 Swift 언어의 프레임 워크 사용을 돕기 위해 Objective-C 속성으로 가득합니다. &lt;code&gt;DemoClazz&lt;/code&gt; 는 , &lt;code&gt;DemoInterface&lt;/code&gt; 및 &lt;code&gt;DemoObject&lt;/code&gt; 가 만들어집니다 &lt;code&gt;Clazz&lt;/code&gt; , &lt;code&gt;Interface&lt;/code&gt; 및 &lt;code&gt;Object&lt;/code&gt; 각각. &lt;code&gt;Interface&lt;/code&gt; 로 전환되는 &lt;code&gt;@protocol&lt;/code&gt; 둘 다를, &lt;code&gt;class&lt;/code&gt; 및 &lt;code&gt;object&lt;/code&gt; 로 표현된다 &lt;code&gt;@interface&lt;/code&gt; . &lt;code&gt;Demo&lt;/code&gt; 접두사는에서 온다 &lt;code&gt;-output&lt;/code&gt; 의 매개 변수 &lt;code&gt;kotlinc-native&lt;/code&gt; 컴파일러와 프레임 워크의 이름입니다. 여기서는 nullable 반환 유형이 &lt;code&gt;ULong?&lt;/code&gt; Objective-C에서 &lt;code&gt;DemoLong*&lt;/code&gt; 으로 바뀝니다 .</target>
        </trans-unit>
        <trans-unit id="bb3f232ccbe55c8a64749007e2a52df82753b753" translate="yes" xml:space="preserve">
          <source>The code is still written as if we were writing synchronous code, top-down, without the need of any special syntax, beyond the use of a function called &lt;code&gt;launch&lt;/code&gt; which essentially kicks-off the coroutine (covered in other tutorials).</source>
          <target state="translated">코드는 우리가 동기식 코드를 작성하는 것처럼 작성됩니다. 특별한 구문이 필요하지 않고 본질적으로 코 루틴을 &lt;code&gt;launch&lt;/code&gt; 하는 함수 (다른 튜토리얼에서 다루어 짐)를 사용하는 것 외에도 특별한 구문이 필요하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="a467b8b9b7ee4d493e257af4cbf437bbbbde6f1c" translate="yes" xml:space="preserve">
          <source>The code or data pointed by the value of this variable.</source>
          <target state="translated">이 변수의 값이 가리키는 코드 또는 데이터입니다.</target>
        </trans-unit>
        <trans-unit id="02020b547b7971154705decbe3b4487f3a320a20" translate="yes" xml:space="preserve">
          <source>The code reads as follows. We have the &lt;code&gt;libnative_ExportedSymbols&lt;/code&gt; structure, which defines all the functions that Kotlin/Native and our library provides us. It uses nested anonymous structures heavily to mimic packages. The &lt;code&gt;libnative_&lt;/code&gt; prefix comes from the library name.</source>
          <target state="translated">코드는 다음과 같이 읽습니다. Kotlin / Native와 라이브러리가 제공하는 모든 함수를 정의 하는 &lt;code&gt;libnative_ExportedSymbols&lt;/code&gt; 구조가 있습니다. 패키지를 모방하기 위해 중첩 된 익명 구조를 많이 사용합니다. &lt;code&gt;libnative_&lt;/code&gt; 접두사는 라이브러리 이름에서 비롯됩니다.</target>
        </trans-unit>
        <trans-unit id="38d106af82f35f678ad2690b0baa41429ea7b73f" translate="yes" xml:space="preserve">
          <source>The code uses anonymous structure declarations. The code &lt;code&gt;struct { .. } foo&lt;/code&gt; declares a field in the outer struct of that anonymous structure type, the type with no name.</source>
          <target state="translated">이 코드는 익명 구조 선언을 사용합니다. 코드 &lt;code&gt;struct { .. } foo&lt;/code&gt; 는 익명 구조 유형의 외부 구조에서 이름이없는 유형의 필드를 선언합니다.</target>
        </trans-unit>
        <trans-unit id="5a75d5c9d164b0af6fa981261ed056bb33166b99" translate="yes" xml:space="preserve">
          <source>The collection interfaces and related functions are located in the kotlin.collections package. Let's get an overview of its contents.</source>
          <target state="translated">수집 인터페이스 및 관련 기능은 kotlin.collections 패키지에 있습니다. 내용에 대한 개요를 살펴 보겠습니다.</target>
        </trans-unit>
        <trans-unit id="8eb00e1a99072f02da7c9734f0160d0f6d88090d" translate="yes" xml:space="preserve">
          <source>The command produces the &lt;code&gt;main.exe&lt;/code&gt; file, which we can run.</source>
          <target state="translated">이 명령은 우리가 실행할 수 있는 &lt;code&gt;main.exe&lt;/code&gt; 파일을 생성합니다 .</target>
        </trans-unit>
        <trans-unit id="c3c76c63d39731dfbcdc20b108a998ffa2cab356" translate="yes" xml:space="preserve">
          <source>The common base class of all enum classes. See the &lt;a href=&quot;../../../../../../docs/reference/enum-classes&quot;&gt;Kotlin language documentation&lt;/a&gt; for more information on enum classes.</source>
          <target state="translated">모든 열거 형 클래스의 공통 기본 클래스입니다. 열거 형 클래스에 대한 자세한 내용은 &lt;a href=&quot;../../../../../../docs/reference/enum-classes&quot;&gt;Kotlin 언어 설명서&lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="b0aedfb3fef921fc9d29c01593b4d03896cda204" translate="yes" xml:space="preserve">
          <source>The common base class of all enum classes. See the &lt;a href=&quot;../../../../../docs/reference/enum-classes&quot;&gt;Kotlin language documentation&lt;/a&gt; for more information on enum classes.</source>
          <target state="translated">모든 열거 형 클래스의 공통 기본 클래스입니다. 열거 형 클래스에 대한 자세한 내용은 &lt;a href=&quot;../../../../../docs/reference/enum-classes&quot;&gt;Kotlin 언어 설명서&lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="81167d80c8bd1494ae8b5c6e43cfe5f3d98e0f63" translate="yes" xml:space="preserve">
          <source>The common code is &lt;code&gt;&quot;Kotlin Rocks on ${platformName()}&quot;&lt;/code&gt;, where &lt;code&gt;platformName()&lt;/code&gt; is a function that is declared using the &lt;code&gt;expect&lt;/code&gt; keyword. The &lt;code&gt;actual&lt;/code&gt; implementation will be specific to the platform.</source>
          <target state="translated">공통 코드는 &lt;code&gt;&quot;Kotlin Rocks on ${platformName()}&quot;&lt;/code&gt; . 여기서 &lt;code&gt;platformName()&lt;/code&gt; 은 &lt;code&gt;expect&lt;/code&gt; 키워드를 사용하여 선언 된 함수입니다 . &lt;code&gt;actual&lt;/code&gt; 구현은 플랫폼에 특정한 될 것입니다.</target>
        </trans-unit>
        <trans-unit id="26e2504fa6bfc493ea02066bb2b03d45d4bc4811" translate="yes" xml:space="preserve">
          <source>The common source sets cannot include Java sources.</source>
          <target state="translated">공통 소스 세트는 Java 소스를 포함 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="95ec79a350a2b7276da32a4ea5b29db260f72d85" translate="yes" xml:space="preserve">
          <source>The common supertype for all callable references is &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.reflect/-k-callable/index&quot;&gt;&lt;code&gt;KCallable&amp;lt;out R&amp;gt;&lt;/code&gt;&lt;/a&gt;, where &lt;code&gt;R&lt;/code&gt; is the return value type, which is the property type for properties, and the constructed type for constructors.</source>
          <target state="translated">호출 가능한 모든 참조의 공통 수퍼 타입은 &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.reflect/-k-callable/index&quot;&gt; &lt;code&gt;KCallable&amp;lt;out R&amp;gt;&lt;/code&gt; &lt;/a&gt; . 여기서 &lt;code&gt;R&lt;/code&gt; 은 리턴 값 유형이며, 이는 특성의 특성 유형이고 생성자의 생성 된 유형입니다.</target>
        </trans-unit>
        <trans-unit id="b490df5b9d3260a0f0b5037a5c6848fe5e1088c0" translate="yes" xml:space="preserve">
          <source>The companion object &lt;a href=&quot;-default/index&quot;&gt;Random.Default&lt;/a&gt; is the default instance of &lt;a href=&quot;index&quot;&gt;Random&lt;/a&gt;.</source>
          <target state="translated">컴패니언 객체 &lt;a href=&quot;-default/index&quot;&gt;Random.Default&lt;/a&gt; 는 &lt;a href=&quot;index&quot;&gt;Random&lt;/a&gt; 의 기본 인스턴스입니다 .</target>
        </trans-unit>
        <trans-unit id="d53a914136005ae6f435321f1dcd61b723a192c1" translate="yes" xml:space="preserve">
          <source>The companion object is a singleton, and its members can be accessed directly via the name of the containing class (although you can also insert the name of the companion object if you want to be explicit about accessing the companion object):</source>
          <target state="translated">컴패니언 객체는 싱글 톤이며 포함하는 클래스의 이름을 통해 멤버에 직접 액세스 할 수 있습니다 (컴패니언 객체에 액세스하는 것에 대해 명시 적으로 표시하려는 경우 컴패니언 객체의 이름을 삽입 할 수도 있음).</target>
        </trans-unit>
        <trans-unit id="1e2216eb9ae725f1d6c56e917607f0c9488b74a1" translate="yes" xml:space="preserve">
          <source>The compiler automatically derives the following members from all properties declared in the primary constructor:</source>
          <target state="translated">컴파일러는 기본 생성자에 선언 된 모든 속성에서 다음 멤버를 자동으로 파생시킵니다.</target>
        </trans-unit>
        <trans-unit id="6577ea37c1117c7a1d89eaf0755007d75c98ca87" translate="yes" xml:space="preserve">
          <source>The compiler can infer the function types for variables if there is enough information:</source>
          <target state="translated">충분한 정보가있는 경우 컴파일러는 변수의 함수 유형을 유추 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6c9d4888e9777e469bf8f8415875e00d70265bbb" translate="yes" xml:space="preserve">
          <source>The compiler ensures that every expected declaration has actual declarations in all platform modules that implement the corresponding common module, and reports an error if any actual declarations are missing. The IDE provides tools that help you create the missing actual declarations.</source>
          <target state="translated">컴파일러는 모든 예상 선언에 해당 공통 모듈을 구현하는 모든 플랫폼 모듈에서 실제 선언이 있는지 확인하고 실제 선언이 누락 된 경우 오류를보고합니다. IDE는 누락 된 실제 선언을 만드는 데 도움이되는 도구를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="1bc9fa0ea96f6adbeae3b32244221538e36f7db6" translate="yes" xml:space="preserve">
          <source>The compiler generates an executable called &lt;code&gt;a.out&lt;/code&gt;. We need to run it to see in action the Kotlin code being executed from C library. On Linux, we'll need to include &lt;code&gt;.&lt;/code&gt; into the &lt;code&gt;LD_LIBRARY_PATH&lt;/code&gt; to let the application know to load the &lt;code&gt;libnative.so&lt;/code&gt; library from the current folder.</source>
          <target state="translated">컴파일러는 &lt;code&gt;a.out&lt;/code&gt; 이라는 실행 파일을 생성합니다 . C 라이브러리에서 실행되는 Kotlin 코드를 실제로 보려면이를 실행해야합니다. Linux에서는을 포함해야합니다 &lt;code&gt;.&lt;/code&gt; 에 &lt;code&gt;LD_LIBRARY_PATH&lt;/code&gt; 부하에 응용 프로그램 알려 &lt;code&gt;libnative.so&lt;/code&gt; 의 현재 폴더에서 라이브러리를.</target>
        </trans-unit>
        <trans-unit id="9c32f1ebf038bdf8cbaba8702b89e98ca18e811a" translate="yes" xml:space="preserve">
          <source>The compiler is smart enough to know a cast to be safe if a negative check leads to a return:</source>
          <target state="translated">컴파일러는 음수 검사가 반환으로 이어질 경우 캐스트가 안전하다는 것을 알기에 충분히 똑똑합니다.</target>
        </trans-unit>
        <trans-unit id="6c760f17f753a0cd7195aa08e67eb2dc50e9752a" translate="yes" xml:space="preserve">
          <source>The compiler now inlines values of &lt;code&gt;const val&lt;/code&gt; properties into the locations where they are used.</source>
          <target state="translated">컴파일러는 &lt;code&gt;const val&lt;/code&gt; 속성의 값을 사용 된 위치에 인라인합니다 .</target>
        </trans-unit>
        <trans-unit id="4ba2b709c858d08263f181dafb3aabf655fd192d" translate="yes" xml:space="preserve">
          <source>The compiler now provides an option to treat all warnings as errors. Use &lt;code&gt;-Werror&lt;/code&gt; on the command line, or the following Gradle snippet:</source>
          <target state="translated">컴파일러는 이제 모든 경고를 오류로 처리하는 옵션을 제공합니다. 명령 행에서 &lt;code&gt;-Werror&lt;/code&gt; 를 사용 하거나 다음 Gradle 스 니펫을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="71411ab1eb04e1e2a8b1556ddf262cc1922d7424" translate="yes" xml:space="preserve">
          <source>The compiler performs the following steps for resolution of an operator in the &lt;em&gt;postfix&lt;/em&gt; form, e.g. &lt;code&gt;a++&lt;/code&gt;:</source>
          <target state="translated">컴파일러는 &lt;em&gt;접미사&lt;/em&gt; 형식으로 연산자를 해결하기 위해 다음 단계를 수행합니다 ( 예 : &lt;code&gt;a++&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ade270e63280116ba329a9222cd68e987a0137a2" translate="yes" xml:space="preserve">
          <source>The compiler produces a warning for the cast in the last line. The cast cannot be fully checked at runtime and provides no guarantee that the values in the map are &lt;code&gt;Int&lt;/code&gt;.</source>
          <target state="translated">컴파일러는 마지막 행에서 캐스트에 대한 경고를 생성합니다. 캐스트는 런타임에 완전히 확인할 수 없으며 맵의 값이 &lt;code&gt;Int&lt;/code&gt; 라는 보장을 제공하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="c187f47b8c07f5d91c0556c45f360de519c42c3f" translate="yes" xml:space="preserve">
          <source>The compiler produces the code relevant for the target module system, for example, in case of CommonJS, it will import the declaration via the &lt;code&gt;require(...)&lt;/code&gt; function.</source>
          <target state="translated">컴파일러는 대상 모듈 시스템과 관련된 코드를 생성합니다. 예를 들어 CommonJS의 경우 &lt;code&gt;require(...)&lt;/code&gt; 함수 를 통해 선언을 가져옵니다 .</target>
        </trans-unit>
        <trans-unit id="8552578d258f1326cbba27a9248961d718afcda8" translate="yes" xml:space="preserve">
          <source>The compiler tracks the information about the check you performed, and allows the call to &lt;code&gt;length&lt;/code&gt; inside the &lt;em&gt;if&lt;/em&gt;. More complex conditions are supported as well:</source>
          <target state="translated">컴파일러는 수행 한 검사에 대한 정보를 추적 하고 &lt;em&gt;if&lt;/em&gt; 내에서 호출 &lt;code&gt;length&lt;/code&gt; 허용합니다 . 더 복잡한 조건도 지원됩니다.&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="9778744271ecf22c5df54071242110d274ebb382" translate="yes" xml:space="preserve">
          <source>The compiler will allow this function to be called as e.g. &lt;code&gt;test(&quot;a&quot;, &quot;b&quot;)&lt;/code&gt; or &lt;code&gt;test(&quot;a&quot;, null)&lt;/code&gt;, but not as &lt;code&gt;test(null, &quot;b&quot;)&lt;/code&gt; or &lt;code&gt;test(null, null)&lt;/code&gt;. Calling &lt;code&gt;test(a, b)&lt;/code&gt; is only allowed if the compiler can prove that &lt;code&gt;a&lt;/code&gt; cannot possibly be null. Inside of &lt;code&gt;test&lt;/code&gt;, the compiler will not allow you to do anything with &lt;code&gt;b&lt;/code&gt; that would result in an exception if &lt;code&gt;b&lt;/code&gt; should happen to be null - so you can do &lt;code&gt;a.length&lt;/code&gt;, but not &lt;code&gt;b.length&lt;/code&gt;. However, once you're inside a conditional where you have checked that &lt;code&gt;b&lt;/code&gt; is not null, you can do it:</source>
          <target state="translated">컴파일러는이 함수를 &lt;code&gt;test(&quot;a&quot;, &quot;b&quot;)&lt;/code&gt; 또는 &lt;code&gt;test(&quot;a&quot;, null)&lt;/code&gt; 로 호출 할 수 있지만 &lt;code&gt;test(null, &quot;b&quot;)&lt;/code&gt; 또는 &lt;code&gt;test(null, null)&lt;/code&gt; 로 호출 할 수 없습니다 . 컴파일러가 &lt;code&gt;a&lt;/code&gt; 가 null 일 수 없음을 증명할 수있는 경우에만 &lt;code&gt;test(a, b)&lt;/code&gt; 호출 이 허용됩니다 . &lt;code&gt;test&lt;/code&gt; 내 에서 컴파일러는 &lt;code&gt;b&lt;/code&gt; 를 사용 하여 b 를 null 처리해야 할 경우 예외가 발생하는 &lt;code&gt;b&lt;/code&gt; 를 사용하여 작업을 수행 할 수 없도록합니다. 따라서 &lt;code&gt;a.length&lt;/code&gt; 는 할 수 있지만 &lt;code&gt;b.length&lt;/code&gt; 는 할 수 없습니다 . 그러나 &lt;code&gt;b&lt;/code&gt; 가 null이 아닌 것을 확인한 조건부 안에 들어가면 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d2b29d9a02116dffd597657f45323e8d260b605c" translate="yes" xml:space="preserve">
          <source>The compiler will generate something like this (except that &lt;code&gt;start&lt;/code&gt; won't collide with any other identifiers with the same name):</source>
          <target state="translated">컴파일러는 다음과 같은 것을 생성합니다 ( &lt;code&gt;start&lt;/code&gt; 이 동일한 이름을 가진 다른 식별자와 충돌하지 않는 경우 제외 ).</target>
        </trans-unit>
        <trans-unit id="93c0badc9698bd83e21fa61741e490ba8801596d" translate="yes" xml:space="preserve">
          <source>The compiler will not let you perform checks that can't possibly succeed because the declared type of the variable is a class that is on an unrelated branch of the class hierarchy from the class you're checking against - if the declared type of &lt;code&gt;x&lt;/code&gt; is &lt;code&gt;MotorVehicle&lt;/code&gt;, you can't check if &lt;code&gt;x&lt;/code&gt; is a &lt;code&gt;Person&lt;/code&gt;. If the right-hand side of &lt;code&gt;is&lt;/code&gt; is an interface, Kotlin will allow the type of the left-hand side to be any interface or open class, because it could be that some subclass thereof implements the interface.</source>
          <target state="translated">선언 된 변수 유형이 검사중인 클래스와 관련이없는 클래스 계층 구조의 분기에있는 클래스이므로 컴파일러는 성공할 수없는 검사를 수행 할 수 없습니다. 선언 된 &lt;code&gt;x&lt;/code&gt; 유형 이 &lt;code&gt;MotorVehicle&lt;/code&gt; , &lt;code&gt;x&lt;/code&gt; 가 &lt;code&gt;Person&lt;/code&gt; 인지 확인할 수 없습니다 . 오른쪽의 경우 &lt;code&gt;is&lt;/code&gt; 인터페이스는 그 일부 그 서브 클래스가 구현하는 인터페이스가 될 수 있기 때문에, 코 틀린는 좌측의 타입이 임의의 인터페이스 또는 개방 클래스 수 있도록한다.</target>
        </trans-unit>
        <trans-unit id="945c10a176528faf419fb001b8765fc6d7f48809" translate="yes" xml:space="preserve">
          <source>The complete list of options for the Gradle tasks is the following:</source>
          <target state="translated">Gradle 작업에 대한 전체 옵션 목록은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="cbc4e4912fffd8b8c15a7f1685ee311f7de94af5" translate="yes" xml:space="preserve">
          <source>The consumer may only need to add the attribute to a single target where the ambiguity arises.</source>
          <target state="translated">소비자는 모호성이 발생하는 단일 대상에 속성을 추가하기 만하면됩니다.</target>
        </trans-unit>
        <trans-unit id="2fa143f534ac2f4a54ee1e8593acf92219a64686" translate="yes" xml:space="preserve">
          <source>The contents of our &lt;code&gt;main.js&lt;/code&gt; would be:</source>
          <target state="translated">&lt;code&gt;main.js&lt;/code&gt; 의 내용 은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="ccc1b0f9d51d769d3aac8a2e95f9b22ce641f370" translate="yes" xml:space="preserve">
          <source>The context of the coroutine that corresponds to this continuation.</source>
          <target state="translated">이 연속에 해당하는 코 루틴의 맥락.</target>
        </trans-unit>
        <trans-unit id="347bd2f03e4af765cba7e04d72d0cecc9c6bb8cc" translate="yes" xml:space="preserve">
          <source>The contract description must be at the beginning of a function and have at least one effect.</source>
          <target state="translated">계약 설명은 기능의 시작 부분에 있어야하며 최소한 하나의 영향을 미칩니다.</target>
        </trans-unit>
        <trans-unit id="4954ad3fce80d9310d9ce43541aaf17e0123a4ea" translate="yes" xml:space="preserve">
          <source>The contravariant type parameter of a parameter of a function-typed return type (the user will call the returned function with something that can consume any &lt;code&gt;Fruit&lt;/code&gt;, so it's okay to return a function that expects to receive something that can handle &lt;code&gt;Apple&lt;/code&gt;)</source>
          <target state="translated">함수 타입의 리턴 타입 파라미터의 반 변형 타입 파라미터 (사용자는 &lt;code&gt;Fruit&lt;/code&gt; 를 소비 할 수있는 것으로 리턴 된 함수를 호출 하므로 &lt;code&gt;Apple&lt;/code&gt; 을 처리 할 수있는 무언가를받을 것으로 예상되는 함수를 반환해도됩니다 )</target>
        </trans-unit>
        <trans-unit id="fc9281a07f7c7bacfae7f8c712a66286fa4aa11c" translate="yes" xml:space="preserve">
          <source>The contravariant type parameter of a parameter type (the user is passing a consumer that can handle any &lt;code&gt;Fruit&lt;/code&gt;, and it will be given an &lt;code&gt;Apple&lt;/code&gt;)</source>
          <target state="translated">매개 변수 유형의 반 변형 유형 매개 변수 (사용자는 &lt;code&gt;Fruit&lt;/code&gt; 를 처리 할 수있는 소비자를 전달 하며 &lt;code&gt;Apple&lt;/code&gt; 에 제공됨 )</target>
        </trans-unit>
        <trans-unit id="3b2df0437d1139299375d04a6b3d749596fe34b3" translate="yes" xml:space="preserve">
          <source>The contravariant type parameter of the return type of a function-typed parameter (the user is passing a function that will return a consumer of any &lt;code&gt;Fruit&lt;/code&gt;, and the returned consumer will be given &lt;code&gt;Apple&lt;/code&gt; instances)</source>
          <target state="translated">함수 유형 매개 변수의 반환 유형에 대한 반 변형 유형 매개 변수 (사용자는 &lt;code&gt;Fruit&lt;/code&gt; 의 소비자를 반환하는 함수를 전달하고 반환 된 소비자 에게는 &lt;code&gt;Apple&lt;/code&gt; 인스턴스 가 제공됨 )</target>
        </trans-unit>
        <trans-unit id="3ed87fa7f81c4d406e21bd5206fb7068af42bc61" translate="yes" xml:space="preserve">
          <source>The convention that is followed is that each library gets its own definition file, usually named the same as the library. For more information on all the options available to &lt;code&gt;cinterop&lt;/code&gt;, see &lt;a href=&quot;../../reference/native/c_interop&quot;&gt;the Interop documentation&lt;/a&gt;</source>
          <target state="translated">따르는 규칙은 각 라이브러리가 일반적으로 라이브러리와 동일한 이름을 가진 자체 정의 파일을 가져 오는 것입니다. &lt;code&gt;cinterop&lt;/code&gt; 에 사용 가능한 모든 옵션에 대한 자세한 내용 &lt;a href=&quot;../../reference/native/c_interop&quot;&gt;은 Interop 설명서를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="d4ce8b1f45a5d6806ad09e59cc85adf7dc80106f" translate="yes" xml:space="preserve">
          <source>The coroutine context is a set of various elements. The main elements are the &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-job/index.html&quot;&gt;Job&lt;/a&gt; of the coroutine, which we've seen before, and its dispatcher, which is covered in this section.</source>
          <target state="translated">코 루틴 문맥은 다양한 요소의 집합입니다. 주요 요소는 이전에 본 코 루틴 &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-job/index.html&quot;&gt;작업&lt;/a&gt; 과이 섹션에서 다루는 디스패처입니다.</target>
        </trans-unit>
        <trans-unit id="09d67675b7aec2c1bf9665203e1b50714b4ffefe" translate="yes" xml:space="preserve">
          <source>The coroutine is started directly in the invoker's thread without going through the &lt;a href=&quot;../kotlin.coroutines/-continuation-interceptor/index&quot;&gt;ContinuationInterceptor&lt;/a&gt; that might be present in the completion's &lt;a href=&quot;../kotlin.coroutines/-coroutine-context/index&quot;&gt;CoroutineContext&lt;/a&gt;. It is the invoker's responsibility to ensure that a proper invocation context is established.</source>
          <target state="translated">코 루틴은 완료의 &lt;a href=&quot;../kotlin.coroutines/-coroutine-context/index&quot;&gt;CoroutineContext에&lt;/a&gt; 존재할 수있는 &lt;a href=&quot;../kotlin.coroutines/-continuation-interceptor/index&quot;&gt;ContinuationInterceptor&lt;/a&gt; 를 거치지 않고 호출자의 스레드에서 직접 시작됩니다 . 적절한 호출 컨텍스트가 설정되도록하는 것은 호출자의 책임입니다.</target>
        </trans-unit>
        <trans-unit id="3db3fa62931fade33326b38aff7867fe578bfdd9" translate="yes" xml:space="preserve">
          <source>The coroutine's &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-job/index.html&quot;&gt;Job&lt;/a&gt; is part of its context. The coroutine can retrieve it from its own context using &lt;code&gt;coroutineContext[Job]&lt;/code&gt; expression:</source>
          <target state="translated">코 루틴의 &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-job/index.html&quot;&gt;직업&lt;/a&gt; 은 그 맥락의 일부입니다. 코 루틴은 &lt;code&gt;coroutineContext[Job]&lt;/code&gt; 표현식을 사용하여 자체 컨텍스트에서이를 검색 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="e1d461218111d234968b7db694b9b764401c60b6" translate="yes" xml:space="preserve">
          <source>The corresponding &lt;em&gt;sourceSets&lt;/em&gt; property should be updated if not using the default convention:</source>
          <target state="translated">기본 규칙을 사용하지 않는 경우 해당 &lt;em&gt;sourceSets&lt;/em&gt; 특성을 업데이트해야합니다.</target>
        </trans-unit>
        <trans-unit id="16c7a1a50f1d32fc204564f81e6d0304f7356ed7" translate="yes" xml:space="preserve">
          <source>The covariant type parameter of a read-only property type (the user is expecting a producer of &lt;code&gt;Fruit&lt;/code&gt;, and gets a producer of &lt;code&gt;Apple&lt;/code&gt;)</source>
          <target state="translated">읽기 전용 속성 유형의 공변량 유형 매개 변수 (사용자는 &lt;code&gt;Fruit&lt;/code&gt; 의 생산자를 기대하고 &lt;code&gt;Apple&lt;/code&gt; 의 생산자를 얻습니다 )</target>
        </trans-unit>
        <trans-unit id="7d1a94c8808bc3894d49e0ec4259312cbb359362" translate="yes" xml:space="preserve">
          <source>The covariant type parameter of a return type (the user is expecting that the returned value will produce a &lt;code&gt;Fruit&lt;/code&gt;, so it's okay if it really produces an &lt;code&gt;Apple&lt;/code&gt;)</source>
          <target state="translated">리턴 유형의 공변량 유형 매개 변수 (사용자는 리턴 된 값이 &lt;code&gt;Fruit&lt;/code&gt; 을 생성 할 것으로 예상 하므로 실제로 &lt;code&gt;Apple&lt;/code&gt; 을 생성하면 괜찮습니다 )</target>
        </trans-unit>
        <trans-unit id="ec6f1c24b0cd8b11d61e4f25576ab198b6bece55" translate="yes" xml:space="preserve">
          <source>The covariant type parameter of the parameter type of a function-typed parameter (the user is passing a function that can handle any &lt;code&gt;Fruit&lt;/code&gt; producer, and it will be given an &lt;code&gt;Apple&lt;/code&gt; producer)</source>
          <target state="translated">함수 유형 매개 변수의 매개 변수 유형에 대한 공변량 유형 매개 변수 (사용자는 모든 &lt;code&gt;Fruit&lt;/code&gt; 생산자를 처리 할 수있는 함수를 전달 하며 &lt;code&gt;Apple&lt;/code&gt; 생산자 에게 제공됨 )</target>
        </trans-unit>
        <trans-unit id="bc2c5c3395341afe0bbd48554537d9a1ac25a9db" translate="yes" xml:space="preserve">
          <source>The covariant type parameter of the return type of a function-typed return type (the user expects the returned function to return something that produces &lt;code&gt;Fruit&lt;/code&gt;, so it's okay if it really produces &lt;code&gt;Apple&lt;/code&gt;)</source>
          <target state="translated">함수 타입 리턴 타입의 리턴 타입의 공변량 타입 파라미터 (사용자는 리턴 된 함수가 &lt;code&gt;Fruit&lt;/code&gt; 을 생성하는 것을 반환 할 것으로 예상 하므로 실제로 &lt;code&gt;Apple&lt;/code&gt; 을 생성한다면 괜찮습니다 )</target>
        </trans-unit>
        <trans-unit id="a39f5e4ad2c9626d5a5f458b4068b5771d3c11f9" translate="yes" xml:space="preserve">
          <source>The created &lt;code&gt;StableRef&lt;/code&gt; should eventually be manually disposed using the &lt;code&gt;.dispose()&lt;/code&gt; method to prevent memory leaks:</source>
          <target state="translated">생성 된 &lt;code&gt;StableRef&lt;/code&gt; 는 &lt;code&gt;.dispose()&lt;/code&gt; 메서드를 사용하여 수동으로 처리하여 메모리 누수를 방지해야합니다.</target>
        </trans-unit>
        <trans-unit id="7dc376ddde1c64329f76a2fdf0f77fd2f42853b6" translate="yes" xml:space="preserve">
          <source>The created iOS application is ready to run on the iOS emulator or on the iOS device. The device run may require an Apple developer account and to issue a developer certificate. Xcode does its best to guide us through the process.</source>
          <target state="translated">작성된 iOS 애플리케이션은 iOS 에뮬레이터 또는 iOS 디바이스에서 실행할 수 있습니다. 장치를 실행하려면 Apple 개발자 계정이 필요하고 개발자 인증서를 발급해야합니다. Xcode는 프로세스를 안내하기 위해 최선을 다합니다.</target>
        </trans-unit>
        <trans-unit id="e20d095cd0f1efef77b1627ffafe7b1dfa3d28bf" translate="yes" xml:space="preserve">
          <source>The curly braces around a body can be omitted if the body is a oneliner. This is discouraged unless the body goes on the same line as the condition, because it makes it easy to make this mistake, especially when one is used to Python:</source>
          <target state="translated">바디가 원 라이너 인 경우 바디 주변의 중괄호는 생략 할 수 있습니다. 신체가 조건과 같은 줄에 있지 않으면, 특히 파이썬에 익숙 할 때이 실수를 쉽게 할 수 있기 때문에 권장하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="dcfce21884a60ba71ce3d59d9e2af53e74e2e10c" translate="yes" xml:space="preserve">
          <source>The currently released version is 1.3.41, published on July 4, 2019.</source>
          <target state="translated">현재 출시 된 버전은 1.3.41이며 2019 년 7 월 4 일에 게시되었습니다.</target>
        </trans-unit>
        <trans-unit id="99a5ae4aba1310a5ec2c1c1ea8e6bbd89807b2b1" translate="yes" xml:space="preserve">
          <source>The declaration of the classifier used in this type. For example, in the type &lt;code&gt;List&amp;lt;String&amp;gt;&lt;/code&gt; the classifier would be the &lt;a href=&quot;../-k-class/index#kotlin.reflect.KClass&quot;&gt;KClass&lt;/a&gt; instance for &lt;a href=&quot;../../kotlin.collections/-list/index#kotlin.collections.List&quot;&gt;List&lt;/a&gt;.</source>
          <target state="translated">이 유형에 사용 된 분류기의 선언. 예를 들어, &lt;code&gt;List&amp;lt;String&amp;gt;&lt;/code&gt; 유형 에서 분류 &lt;a href=&quot;../-k-class/index#kotlin.reflect.KClass&quot;&gt;자는 &lt;/a&gt;&lt;a href=&quot;../../kotlin.collections/-list/index#kotlin.collections.List&quot;&gt;List&lt;/a&gt; 의 KClass 인스턴스가 됩니다.</target>
        </trans-unit>
        <trans-unit id="e4cb77989b70ae7af02cc584cc3eb602ad306980" translate="yes" xml:space="preserve">
          <source>The declarations in the new artifacts are visible under the same package names from the Kotlin point of view, but have different package names for Java. Therefore, switching to the new artifacts will not require any changes to your source code.</source>
          <target state="translated">새로운 아티팩트의 선언은 Kotlin 관점에서 동일한 패키지 이름으로 볼 수 있지만 Java의 패키지 이름은 다릅니다. 따라서 새 아티팩트로 전환하면 소스 코드를 변경할 필요가 없습니다.</target>
        </trans-unit>
        <trans-unit id="38a82a6bd4d8bda70773fac15ae91a2110030d1c" translate="yes" xml:space="preserve">
          <source>The default &lt;a href=&quot;https://www.joelonsoftware.com/2003/10/08/the-absolute-minimum-every-software-developer-absolutely-positively-must-know-about-unicode-and-character-sets-no-excuses/&quot;&gt;encoding&lt;/a&gt; is UTF-8, but you can specify it if you need something else:</source>
          <target state="translated">기본 &lt;a href=&quot;https://www.joelonsoftware.com/2003/10/08/the-absolute-minimum-every-software-developer-absolutely-positively-must-know-about-unicode-and-character-sets-no-excuses/&quot;&gt;인코딩&lt;/a&gt; 은 UTF-8이지만 다른 것이 필요한 경우 지정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7643db7f540eca7261e951018ad1bc000680e9fc" translate="yes" xml:space="preserve">
          <source>The default artifact IDs follow the pattern &lt;code&gt;&amp;lt;projectName&amp;gt;-&amp;lt;targetNameToLowerCase&amp;gt;&lt;/code&gt;, for example &lt;code&gt;sample-lib-nodejs&lt;/code&gt; for a target named &lt;code&gt;nodeJs&lt;/code&gt; in a project &lt;code&gt;sample-lib&lt;/code&gt;.</source>
          <target state="translated">기본 아티팩트 ID는 &lt;code&gt;&amp;lt;projectName&amp;gt;-&amp;lt;targetNameToLowerCase&amp;gt;&lt;/code&gt; 패턴을 따릅니다 ( 예 : 프로젝트 &lt;code&gt;sample-lib&lt;/code&gt; 에서 &lt;code&gt;nodeJs&lt;/code&gt; 라는 대상의 &lt;code&gt;sample-lib-nodejs&lt;/code&gt; ) .</target>
        </trans-unit>
        <trans-unit id="b76c41789282ed3ab00f219e4dbda9192589571a" translate="yes" xml:space="preserve">
          <source>The default dispatcher, that is used when coroutines are launched in &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-global-scope/index.html&quot;&gt;GlobalScope&lt;/a&gt;, is represented by &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-dispatchers/-default.html&quot;&gt;Dispatchers.Default&lt;/a&gt; and uses shared background pool of threads, so &lt;code&gt;launch(Dispatchers.Default) { ... }&lt;/code&gt; uses the same dispatcher as &lt;code&gt;GlobalScope.launch { ... }&lt;/code&gt;.</source>
          <target state="translated">코 루틴이 &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-global-scope/index.html&quot;&gt;GlobalScope&lt;/a&gt; 에서 시작될 때 사용되는 기본 디스패처는 &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-dispatchers/-default.html&quot;&gt;Dispatchers.Default&lt;/a&gt; 로 표시되며 공유 백그라운드 스레드 풀을 사용하므로 &lt;code&gt;launch(Dispatchers.Default) { ... }&lt;/code&gt; 는 &lt;code&gt;GlobalScope.launch { ... }&lt;/code&gt; 와 동일한 디스패처를 사용합니다 . ..} .</target>
        </trans-unit>
        <trans-unit id="034812e12bafb58c2506d45936895dac0de7b559" translate="yes" xml:space="preserve">
          <source>The default implementation is available for Java classes implementing the interface.</source>
          <target state="translated">기본 구현은 인터페이스를 구현하는 Java 클래스에 사용 가능합니다.</target>
        </trans-unit>
        <trans-unit id="eae7fdc4a8ba33e2f9213a2722bb2903c080bbc0" translate="yes" xml:space="preserve">
          <source>The default implementation of &lt;code&gt;Map&lt;/code&gt; &amp;ndash; &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/-linked-hash-map/index&quot;&gt;&lt;code&gt;LinkedHashMap&lt;/code&gt;&lt;/a&gt; &amp;ndash; preserves the order of elements insertion when iterating the map. In turn, an alternative implementation &amp;ndash; &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/-hash-map/index&quot;&gt;&lt;code&gt;HashMap&lt;/code&gt;&lt;/a&gt; &amp;ndash; says nothing about the elements order.</source>
          <target state="translated">&lt;code&gt;Map&lt;/code&gt; &amp;ndash; &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/-linked-hash-map/index&quot;&gt; &lt;code&gt;LinkedHashMap&lt;/code&gt; &lt;/a&gt; &amp;ndash; 의 기본 구현은 맵을 반복 할 때 요소 삽입 순서를 유지합니다. 또한 대체 구현 인 &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/-hash-map/index&quot;&gt; &lt;code&gt;HashMap&lt;/code&gt; &lt;/a&gt; 은 요소 순서에 대해 아무 것도 말하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="1d4f4ecafdd233f07d5e3f6afd06222be0312077" translate="yes" xml:space="preserve">
          <source>The default implementation of &lt;code&gt;Set&lt;/code&gt; &amp;ndash; &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/-linked-hash-set/index&quot;&gt;&lt;code&gt;LinkedHashSet&lt;/code&gt;&lt;/a&gt; &amp;ndash; preserves the order of elements insertion. Hence, the functions that rely on the order, such as &lt;code&gt;first()&lt;/code&gt; or &lt;code&gt;last()&lt;/code&gt;, return predictable results on such sets.</source>
          <target state="translated">&lt;code&gt;Set&lt;/code&gt; &amp;ndash; &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/-linked-hash-set/index&quot;&gt; &lt;code&gt;LinkedHashSet&lt;/code&gt; &lt;/a&gt; &amp;ndash; 의 기본 구현 은 요소 삽입 순서를 유지합니다. 따라서 순서에 의존하는 함수 &lt;code&gt;first()&lt;/code&gt; 예 : first () 또는 &lt;code&gt;last()&lt;/code&gt; 는 그러한 세트에서 예측 가능한 결과를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="bed0e18ec00404266f1579a08902984894034905" translate="yes" xml:space="preserve">
          <source>The default nullability is used when a type itself is not annotated by a nullability annotation, and the default is determined by the innermost enclosing element annotated with a type qualifier default annotation with the &lt;code&gt;ElementType&lt;/code&gt; matching the type usage.</source>
          <target state="translated">기본 널 입력 가능 여부는 유형 자체에 널 입력 가능 어노테이션이 주석 처리되지 않은 경우에 사용되며, 기본값은 유형 사용법 과 일치하는 &lt;code&gt;ElementType&lt;/code&gt; 이있는 유형 규정 자 기본 주석으로 주석 처리 된 가장 안쪽의 둘러싸는 요소에 의해 결정됩니다 .</target>
        </trans-unit>
        <trans-unit id="9d69906046e2ddf59f421f52ac090513e9b9f2a3" translate="yes" xml:space="preserve">
          <source>The default random number generator.</source>
          <target state="translated">기본 난수 생성기입니다.</target>
        </trans-unit>
        <trans-unit id="f9ef35e4ea1c850fbe5f46bb280445cc0cd754fc" translate="yes" xml:space="preserve">
          <source>The default source set &lt;code&gt;commonMain&lt;/code&gt; is added to each production (application or library) variant's compilation. The &lt;code&gt;commonTest&lt;/code&gt; source set is, similarly, added to the compilations of unit test and instrumented test variants.</source>
          <target state="translated">기본 소스 세트 &lt;code&gt;commonMain&lt;/code&gt; 이 각 프로덕션 (애플리케이션 또는 라이브러리) 변형의 컴파일에 추가됩니다. &lt;code&gt;commonTest&lt;/code&gt; 소스 세트는 유사하게, 부 검사의 컴파일에 첨가하고, 계측 시험 변종.</target>
        </trans-unit>
        <trans-unit id="c561b55e89597682ebf08bcc014c20773fedb83e" translate="yes" xml:space="preserve">
          <source>The default upper bound (if none specified) is &lt;code&gt;Any?&lt;/code&gt;. Only one upper bound can be specified inside the angle brackets. If the same type parameter needs more than one upper bound, we need a separate &lt;strong&gt;where&lt;/strong&gt;-clause:</source>
          <target state="translated">기본 상한 (지정되지 않은 경우)은 &lt;code&gt;Any?&lt;/code&gt; . 꺾쇠 괄호 안에 하나의 상한 만 지정할 수 있습니다. 동일한 유형 매개 변수에 둘 이상의 상한이 필요한 경우 별도의 &lt;strong&gt;where&lt;/strong&gt; -clause 가 필요합니다 .</target>
        </trans-unit>
        <trans-unit id="7b5f3fac0dd293e61c74032e957e6e608fec3b05" translate="yes" xml:space="preserve">
          <source>The default value is provided at the declaration of this parameter.</source>
          <target state="translated">이 값을 선언하면 기본값이 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="44653ab72c57ae2dec40031a1386b4afc98b3166" translate="yes" xml:space="preserve">
          <source>The definitions part shows how Kotlin primitive types map into C primitive types. We discussed reverse mapping in the &lt;a href=&quot;mapping-primitive-data-types-from-c&quot;&gt;Mapping Primitive Data Types from C&lt;/a&gt; tutorial.</source>
          <target state="translated">정의 부분은 Kotlin 기본 유형이 C 기본 유형으로 맵핑되는 방법을 보여줍니다. &lt;a href=&quot;mapping-primitive-data-types-from-c&quot;&gt;C&lt;/a&gt; 자습서의 기본 데이터 형식 매핑에서 리버스 매핑에 대해 설명했습니다 .</target>
        </trans-unit>
        <trans-unit id="7879370b21d5da1f44f128551f264e026a0fb9ed" translate="yes" xml:space="preserve">
          <source>The delegate class may implement one of the interfaces &lt;code&gt;ReadOnlyProperty&lt;/code&gt; and &lt;code&gt;ReadWriteProperty&lt;/code&gt; containing the required &lt;code&gt;operator&lt;/code&gt; methods. These interfaces are declared in the Kotlin standard library:</source>
          <target state="translated">델리게이트 클래스는 필수 &lt;code&gt;operator&lt;/code&gt; 메소드를 포함하는 &lt;code&gt;ReadOnlyProperty&lt;/code&gt; 및 &lt;code&gt;ReadWriteProperty&lt;/code&gt; 인터페이스 중 하나를 구현할 수 있습니다 . 이러한 인터페이스는 Kotlin 표준 라이브러리에 선언되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="42bebb3adac2ab3e00fbad0af368d0931c57bd77" translate="yes" xml:space="preserve">
          <source>The delegated property can be used like this to declare a property in &lt;code&gt;Person&lt;/code&gt; - note the use of &lt;code&gt;by&lt;/code&gt; instead of &lt;code&gt;=&lt;/code&gt;:</source>
          <target state="translated">위임 된 속성은 &lt;code&gt;Person&lt;/code&gt; 에서 속성을 선언하기 위해 다음과 같이 사용될 수 있습니다 . &lt;code&gt;=&lt;/code&gt; 대신에 &lt;code&gt;by&lt;/code&gt; 를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="973f16e5337bff9eb9481252b3daeac2f25a5f4f" translate="yes" xml:space="preserve">
          <source>The dependencies declared in this way are added in the podspec file and downloaded during the execution of &lt;code&gt;pod install&lt;/code&gt;.</source>
          <target state="translated">이러한 방식으로 선언 된 종속성은 podspec 파일에 추가되고 &lt;code&gt;pod install&lt;/code&gt; 실행 중에 다운로드됩니다 .</target>
        </trans-unit>
        <trans-unit id="8e289438644482986fe5eb08aaf9b0616f49cac1" translate="yes" xml:space="preserve">
          <source>The described mechanism for marking and using experimental APIs is itself experimental in Kotlin 1.3. This means that in future releases it may be changed in ways that make it incompatible. To make the users of annotations &lt;code&gt;@Experimental&lt;/code&gt; and &lt;code&gt;UseExperimental&lt;/code&gt; aware of their experimental status, the compiler raises warnings when compiling the code with these annotations:</source>
          <target state="translated">실험적 API를 표시하고 사용하기위한 설명 된 메커니즘은 Kotlin 1.3에서 실험적입니다. 이는 향후 릴리스에서 호환되지 않는 방식으로 변경 될 수 있음을 의미합니다. &lt;code&gt;@Experimental&lt;/code&gt; 및 &lt;code&gt;UseExperimental&lt;/code&gt; 주석 사용자가 실험 상태를 인식 하도록하기 위해 컴파일러는 다음 주석으로 코드를 컴파일 할 때 경고를 발생시킵니다.</target>
        </trans-unit>
        <trans-unit id="cf37d613f63880e424569836a2ab82c0f6bbbfbf" translate="yes" xml:space="preserve">
          <source>The design of inline classes is experimental, meaning that this feature is &lt;em&gt;moving fast&lt;/em&gt; and no compatibility guarantees are given. When using inline classes in Kotlin 1.3+, a warning will be reported, indicating that this feature is experimental.</source>
          <target state="translated">인라인 클래스의 디자인은 실험적이므로이 기능은 &lt;em&gt;빠르게 움직이고&lt;/em&gt; 호환성 보장이 제공되지 않습니다. Kotlin 1.3 이상에서 인라인 클래스를 사용하는 경우이 기능이 실험 중임을 나타내는 경고가보고됩니다.</target>
        </trans-unit>
        <trans-unit id="b65859994bf9d4a7fb5d934baaf88e39c3f04558" translate="yes" xml:space="preserve">
          <source>The design of unsigned types is experimental, meaning that this feature is moving fast and no compatibility guarantees are given. When using unsigned arithmetics in Kotlin 1.3+, warning will be reported, indicating that this feature is experimental. To remove warning, you have to opt-in for experimental usage of unsigned types.</source>
          <target state="translated">서명되지 않은 유형의 디자인은 실험적이므로이 기능은 빠르게 움직이고 호환성이 보장되지 않습니다. Kotlin 1.3+에서 부호없는 산술을 사용하는 경우이 기능이 실험 중임을 나타내는 경고가보고됩니다. 경고를 제거하려면 서명되지 않은 유형의 실험적 사용을 선택해야합니다.</target>
        </trans-unit>
        <trans-unit id="a0d2b5a6b59247ce3c2ac4eba75f43c56acf4c3d" translate="yes" xml:space="preserve">
          <source>The difference between the two functions is that &lt;code&gt;fold()&lt;/code&gt; takes an initial value and uses it as the accumulated value on the first step, whereas the first step of &lt;code&gt;reduce()&lt;/code&gt; uses the first and the second elements as operation arguments on the first step.</source>
          <target state="translated">두 함수의 차이점은 &lt;code&gt;fold()&lt;/code&gt; 는 초기 값을 가져 와서 첫 번째 단계에서 누적 된 값으로 사용하는 반면, &lt;code&gt;reduce()&lt;/code&gt; 의 첫 번째 단계 는 첫 번째 및 두 번째 요소를 첫 번째 단계에서 조작 인수로 사용한다는 것입니다.</target>
        </trans-unit>
        <trans-unit id="16d1b90dc650643e776a4004ab589d677449c331" translate="yes" xml:space="preserve">
          <source>The directories containing the source files to compile</source>
          <target state="translated">컴파일 할 소스 파일이 포함 된 디렉토리</target>
        </trans-unit>
        <trans-unit id="f28bb53a04db0fb8fa17ba4aa3c143de9bce62e3" translate="yes" xml:space="preserve">
          <source>The dynamic type is not supported in code targeting the JVM</source>
          <target state="translated">JVM을 대상으로하는 코드에서 동적 유형이 지원되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="c1e94b86df57391ab40db234f4362544f610c993" translate="yes" xml:space="preserve">
          <source>The easiest way to create a new application targeting JavaScript with Maven is to allow IntelliJ IDEA to configure the Maven project for us. Simply create a new Maven project in IntelliJ IDEA and once the project is created, add a new folder to host the Kotlin source code, removing the default Java one. The project should end up with the following structure</source>
          <target state="translated">Maven으로 JavaScript를 대상으로하는 새로운 응용 프로그램을 만드는 가장 쉬운 방법은 IntelliJ IDEA가 Maven 프로젝트를 구성 할 수 있도록하는 것입니다. IntelliJ IDEA에서 새 Maven 프로젝트를 작성하고 프로젝트가 작성되면 Kotlin 소스 코드를 호스팅 할 새 폴더를 추가하여 기본 Java 코드를 제거하십시오. 프로젝트는 다음과 같은 구조로 끝나야합니다</target>
        </trans-unit>
        <trans-unit id="171e3cf4fb89f709d12d970ce788f0d3a1e1b68e" translate="yes" xml:space="preserve">
          <source>The effect of computing the expression is:</source>
          <target state="translated">식 계산의 효과는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="0a6537bfaccb8cddd8c481ef1fab76499f34a316" translate="yes" xml:space="preserve">
          <source>The element is initialized with the speicifed &lt;a href=&quot;append-element#kotlin.dom%24appendElement%28org.w3c.dom.Element%2C+kotlin.String%2C+kotlin.Function1%28%28org.w3c.dom.Element%2C+kotlin.Unit%29%29%29%2Finit&quot;&gt;init&lt;/a&gt; function.</source>
          <target state="translated">요소는 지정된 &lt;a href=&quot;append-element#kotlin.dom%24appendElement%28org.w3c.dom.Element%2C+kotlin.String%2C+kotlin.Function1%28%28org.w3c.dom.Element%2C+kotlin.Unit%29%29%29%2Finit&quot;&gt;초기화&lt;/a&gt; 기능으로 초기화 됩니다.</target>
        </trans-unit>
        <trans-unit id="3c970d5af5c7c3d91e3eb72687259d2ce93c168c" translate="yes" xml:space="preserve">
          <source>The element is initialized with the speicifed &lt;a href=&quot;create-element#kotlin.dom%24createElement%28org.w3c.dom.Document%2C+kotlin.String%2C+kotlin.Function1%28%28org.w3c.dom.Element%2C+kotlin.Unit%29%29%29%2Finit&quot;&gt;init&lt;/a&gt; function.</source>
          <target state="translated">요소는 지정된 &lt;a href=&quot;create-element#kotlin.dom%24createElement%28org.w3c.dom.Document%2C+kotlin.String%2C+kotlin.Function1%28%28org.w3c.dom.Element%2C+kotlin.Unit%29%29%29%2Finit&quot;&gt;초기화&lt;/a&gt; 기능으로 초기화 됩니다.</target>
        </trans-unit>
        <trans-unit id="4479436b9b0ce8aa0beac7c43130aa60627f658c" translate="yes" xml:space="preserve">
          <source>The elements are appended in the order they appear in the &lt;a href=&quot;../-mutable-list/add-all#kotlin.collections.MutableList%24addAll%28kotlin.collections.Collection%28%28kotlin.collections.MutableList.E%29%29%29%2Felements&quot;&gt;elements&lt;/a&gt; collection.</source>
          <target state="translated">요소는 &lt;a href=&quot;../-mutable-list/add-all#kotlin.collections.MutableList%24addAll%28kotlin.collections.Collection%28%28kotlin.collections.MutableList.E%29%29%29%2Felements&quot;&gt;요소&lt;/a&gt; 컬렉션에 나타나는 순서대로 추가됩니다 .</target>
        </trans-unit>
        <trans-unit id="23022bf4214f0845c5b1a370815de8e19dc6515a" translate="yes" xml:space="preserve">
          <source>The elements are appended in the order they appear in the &lt;a href=&quot;add-all#kotlin.collections.MutableList%24addAll%28kotlin.collections.Collection%28%28kotlin.collections.MutableList.E%29%29%29%2Felements&quot;&gt;elements&lt;/a&gt; collection.</source>
          <target state="translated">요소는 &lt;a href=&quot;add-all#kotlin.collections.MutableList%24addAll%28kotlin.collections.Collection%28%28kotlin.collections.MutableList.E%29%29%29%2Felements&quot;&gt;요소&lt;/a&gt; 컬렉션에 나타나는 순서대로 추가됩니다 .</target>
        </trans-unit>
        <trans-unit id="daa9aa5d9ebd8b42b1bcdf3100554fd92ca03d09" translate="yes" xml:space="preserve">
          <source>The elements are compared for equality with the &lt;a href=&quot;../kotlin/-any/equals#kotlin.Any%24equals%28kotlin.Any%29&quot;&gt;equals&lt;/a&gt; function. For floating point numbers it means that &lt;code&gt;NaN&lt;/code&gt; is equal to itself and &lt;code&gt;-0.0&lt;/code&gt; is not equal to &lt;code&gt;0.0&lt;/code&gt;.</source>
          <target state="translated">요소는 &lt;a href=&quot;../kotlin/-any/equals#kotlin.Any%24equals%28kotlin.Any%29&quot;&gt;equals&lt;/a&gt; 함수 와 동일한 지 비교 됩니다. 부동 소수점 숫자의 경우 &lt;code&gt;NaN&lt;/code&gt; 이 자신과 같고 &lt;code&gt;-0.0&lt;/code&gt; 이 &lt;code&gt;0.0&lt;/code&gt; 과 같지 않음 을 의미합니다 .</target>
        </trans-unit>
        <trans-unit id="f7d4f10d9d6ff53cf3cb02a56dcf3900dc9233c7" translate="yes" xml:space="preserve">
          <source>The elements in the resulting list are in the same order as they were in the source array.</source>
          <target state="translated">결과 목록의 요소는 소스 배열의 순서와 동일합니다.</target>
        </trans-unit>
        <trans-unit id="4758b35da216c6ed38b8e3b01e9232e835ffdf62" translate="yes" xml:space="preserve">
          <source>The elements in the resulting list are in the same order as they were in the source collection.</source>
          <target state="translated">결과 목록의 요소는 소스 콜렉션에있는 순서와 동일합니다.</target>
        </trans-unit>
        <trans-unit id="925245d7080579f68b367dc0eefbb0c6350a2c59" translate="yes" xml:space="preserve">
          <source>The elements in the resulting sequence are in the same order as they were in the source sequence.</source>
          <target state="translated">결과 시퀀스의 요소는 소스 시퀀스의 순서와 동일합니다.</target>
        </trans-unit>
        <trans-unit id="62f13d9c86bbfcad668fdecca43def6919a28064" translate="yes" xml:space="preserve">
          <source>The elements of other types are compared for equality with the &lt;a href=&quot;../kotlin/-any/equals#kotlin.Any%24equals%28kotlin.Any%29&quot;&gt;equals&lt;/a&gt; function. For floating point numbers it means that &lt;code&gt;NaN&lt;/code&gt; is equal to itself and &lt;code&gt;-0.0&lt;/code&gt; is not equal to &lt;code&gt;0.0&lt;/code&gt;.</source>
          <target state="translated">다른 유형의 요소는 &lt;a href=&quot;../kotlin/-any/equals#kotlin.Any%24equals%28kotlin.Any%29&quot;&gt;equals&lt;/a&gt; 함수 와 동일한 지 비교 됩니다. 부동 소수점 숫자의 경우 &lt;code&gt;NaN&lt;/code&gt; 이 자신과 같고 &lt;code&gt;-0.0&lt;/code&gt; 이 &lt;code&gt;0.0&lt;/code&gt; 과 같지 않음 을 의미합니다 .</target>
        </trans-unit>
        <trans-unit id="bb685b2c6e5acf402eac7fe67da99cd138309729" translate="yes" xml:space="preserve">
          <source>The end index of the &lt;a href=&quot;remove-range#kotlin.text%24removeRange%28kotlin.CharSequence%2C+kotlin.ranges.IntRange%29%2Frange&quot;&gt;range&lt;/a&gt; is included in the removed part.</source>
          <target state="translated">&lt;a href=&quot;remove-range#kotlin.text%24removeRange%28kotlin.CharSequence%2C+kotlin.ranges.IntRange%29%2Frange&quot;&gt;범위&lt;/a&gt; 의 끝 인덱스가 제거 된 부품에 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="11df9d3925f0418a6e38aed874d509daf4025048" translate="yes" xml:space="preserve">
          <source>The end index of the &lt;a href=&quot;remove-range#kotlin.text%24removeRange%28kotlin.String%2C+kotlin.ranges.IntRange%29%2Frange&quot;&gt;range&lt;/a&gt; is included in the removed part.</source>
          <target state="translated">&lt;a href=&quot;remove-range#kotlin.text%24removeRange%28kotlin.String%2C+kotlin.ranges.IntRange%29%2Frange&quot;&gt;범위&lt;/a&gt; 의 끝 인덱스가 제거 된 부품에 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="88ef0ef1c8adfc13f79b17d279153b4deca66c2a" translate="yes" xml:space="preserve">
          <source>The end index of the &lt;a href=&quot;replace-range#kotlin.text%24replaceRange%28kotlin.CharSequence%2C+kotlin.ranges.IntRange%2C+kotlin.CharSequence%29%2Frange&quot;&gt;range&lt;/a&gt; is included in the part to be replaced.</source>
          <target state="translated">&lt;a href=&quot;replace-range#kotlin.text%24replaceRange%28kotlin.CharSequence%2C+kotlin.ranges.IntRange%2C+kotlin.CharSequence%29%2Frange&quot;&gt;범위&lt;/a&gt; 의 최종 지수는 교체 할 부품에 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="110043ac6542bd5ea84cfa58a2ba979b14417af8" translate="yes" xml:space="preserve">
          <source>The end index of the &lt;a href=&quot;replace-range#kotlin.text%24replaceRange%28kotlin.String%2C+kotlin.ranges.IntRange%2C+kotlin.CharSequence%29%2Frange&quot;&gt;range&lt;/a&gt; is included in the part to be replaced.</source>
          <target state="translated">&lt;a href=&quot;replace-range#kotlin.text%24replaceRange%28kotlin.String%2C+kotlin.ranges.IntRange%2C+kotlin.CharSequence%29%2Frange&quot;&gt;범위&lt;/a&gt; 의 최종 지수는 교체 할 부품에 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="d2bb3fe28b22f0be53eb5ccfae4478026ce71334" translate="yes" xml:space="preserve">
          <source>The entity which has an associated native pointer. Subtypes are supposed to represent interpretations of the pointed data or code.</source>
          <target state="translated">연결된 기본 포인터가있는 엔터티입니다. 하위 유형은 지정된 데이터 또는 코드의 해석을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="2c6bd81b6f529ef522b5222f238d9ced96f1bfdb" translate="yes" xml:space="preserve">
          <source>The enum constants also implement the &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin/-comparable/index&quot;&gt;Comparable&lt;/a&gt; interface, with the natural order being the order in which they are defined in the enum class.</source>
          <target state="translated">열거 형 상수는 &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin/-comparable/index&quot;&gt;Comparable&lt;/a&gt; 인터페이스 도 구현하며 자연 순서는 열거 형 클래스에 정의 된 순서입니다.</target>
        </trans-unit>
        <trans-unit id="1f86188b4a8b45564220a022aed934fe72f40d6e" translate="yes" xml:space="preserve">
          <source>The example above shows the difference: &lt;code&gt;fold()&lt;/code&gt; is used for calculating the sum of doubled elements. If you pass the same function to &lt;code&gt;reduce()&lt;/code&gt;, it will return another result because it uses the list's first and second elements as arguments on the first step, so the first element won't be doubled.</source>
          <target state="translated">위의 예는 차이점을 보여줍니다. &lt;code&gt;fold()&lt;/code&gt; 는 배가 된 요소의 합을 계산하는 데 사용됩니다. 동일한 함수를 &lt;code&gt;reduce()&lt;/code&gt; 에 전달하면 첫 번째 단계에서 목록의 첫 번째 요소와 두 번째 요소를 인수로 사용하므로 첫 번째 요소가 두 배가되지 않기 때문에 다른 결과가 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="b596f3f6b2203ee7818d443ce1a3eb3a2049daee" translate="yes" xml:space="preserve">
          <source>The example above will work for Android libraries with no product flavors. For a library with product flavors, the variant names also contain the flavors, like &lt;code&gt;fooBarDebug&lt;/code&gt; or &lt;code&gt;fooBazRelease&lt;/code&gt;.</source>
          <target state="translated">위 예제는 제품 버전이없는 Android 라이브러리에서 작동합니다. 제품 플레이버가있는 라이브러리의 경우 변형 이름에도 &lt;code&gt;fooBarDebug&lt;/code&gt; 또는 &lt;code&gt;fooBazRelease&lt;/code&gt; 와 같은 플레이버가 포함 됩니다.</target>
        </trans-unit>
        <trans-unit id="2034baca1648e38acba659c7ed9ab52779def3a9" translate="yes" xml:space="preserve">
          <source>The example of using &lt;code&gt;convert&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;convert&lt;/code&gt; 를 사용하는 예 :</target>
        </trans-unit>
        <trans-unit id="18829b154c907ba2a13646994ee9e04f0d08452d" translate="yes" xml:space="preserve">
          <source>The exception thrown when a character encoding or decoding error occurs.</source>
          <target state="translated">문자 인코딩 또는 디코딩 오류가 발생하면 예외가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="6d95121d07b3626cf990aefa17a36910bfcf4f29" translate="yes" xml:space="preserve">
          <source>The experimental marker for type inference augmenting annotations.</source>
          <target state="translated">타입 추론 증강 주석에 대한 실험 마커.</target>
        </trans-unit>
        <trans-unit id="deb8aac7cf53fe1202db4a3293685d56f19ee1b3" translate="yes" xml:space="preserve">
          <source>The experimental multiplatform support API marker.</source>
          <target state="translated">실험적인 멀티 플랫폼 지원 API 마커.</target>
        </trans-unit>
        <trans-unit id="0428313ba384ac9c0b8833c120ad8f95ce4ede3d" translate="yes" xml:space="preserve">
          <source>The expression &lt;code&gt;::x&lt;/code&gt; evaluates to a property object of type &lt;code&gt;KProperty&amp;lt;Int&amp;gt;&lt;/code&gt;, which allows us to read its value using &lt;code&gt;get()&lt;/code&gt; or retrieve the property name using the &lt;code&gt;name&lt;/code&gt; property. For more information, please refer to the &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.reflect/-k-property/index&quot;&gt;docs on the &lt;code&gt;KProperty&lt;/code&gt; class&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;::x&lt;/code&gt; 표현식 은 &lt;code&gt;KProperty&amp;lt;Int&amp;gt;&lt;/code&gt; 유형의 속성 객체로 평가 되므로 &lt;code&gt;get()&lt;/code&gt; 사용하여 값을 읽 거나 &lt;code&gt;name&lt;/code&gt; 속성을 사용하여 속성 이름을 검색 할 수 있습니다. 자세한 내용 &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.reflect/-k-property/index&quot;&gt;은 &lt;code&gt;KProperty&lt;/code&gt; 클래스&lt;/a&gt; 의 문서 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="788ff064b8ecef1f248204a84772fdfe4508eee7" translate="yes" xml:space="preserve">
          <source>The file is missing the &lt;code&gt;extern &quot;C&quot;&lt;/code&gt; block, which is not needed for our example, but may be necessary if we use C++ and overloaded functions. The &lt;a href=&quot;https://stackoverflow.com/questions/1041866/what-is-the-effect-of-extern-c-in-c&quot;&gt;C++ compatibility&lt;/a&gt; thread contains more details on this.</source>
          <target state="translated">이 파일에는 &lt;code&gt;extern &quot;C&quot;&lt;/code&gt; 블록이 없습니다.이 예에서는 필요하지 않지만 C ++ 및 오버로드 된 함수를 사용하는 경우 필요할 수 있습니다. &lt;a href=&quot;https://stackoverflow.com/questions/1041866/what-is-the-effect-of-extern-c-in-c&quot;&gt;C ++ 호환성&lt;/a&gt; 실이에 대한 자세한 내용이 포함되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="2828031dfb85b70cc7191c0b9ade03e3586cc60a" translate="yes" xml:space="preserve">
          <source>The file system locations for the Java sources are different from the &lt;code&gt;java&lt;/code&gt; plugin's defaults. The Java source files need to be placed in the sibling directories of the Kotlin source roots. For example, if the JVM target has the default name &lt;code&gt;jvm&lt;/code&gt;, the paths are:</source>
          <target state="translated">Java 소스의 파일 시스템 위치는 &lt;code&gt;java&lt;/code&gt; 플러그인의 기본값 과 다릅니다 . Java 소스 파일은 Kotlin 소스 루트의 형제 디렉토리에 있어야합니다. 예를 들어, JVM 대상의 기본 이름이 &lt;code&gt;jvm&lt;/code&gt; 인 경우 경로는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="a63cb5acdae60d6976d603a52addbcfa0b41167c" translate="yes" xml:space="preserve">
          <source>The file we're mostly interested in is &lt;code&gt;ConsoleOutput.js&lt;/code&gt;</source>
          <target state="translated">우리가 주로 관심있는 파일은 &lt;code&gt;ConsoleOutput.js&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="b2c228ca59fbecd7257e251a141cb2c1718c2ba0" translate="yes" xml:space="preserve">
          <source>The final code in the &lt;code&gt;hello.kt&lt;/code&gt; file may look like that:</source>
          <target state="translated">&lt;code&gt;hello.kt&lt;/code&gt; 파일 의 최종 코드 는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="994c32d45d717275b8093d1a6c05a756a3faeb93" translate="yes" xml:space="preserve">
          <source>The final code in the &lt;code&gt;hello.kt&lt;/code&gt; file may look like this:</source>
          <target state="translated">&lt;code&gt;hello.kt&lt;/code&gt; 파일 의 최종 코드 는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="845eeef01520a4662cdfbe660097ba30ecf3f4fb" translate="yes" xml:space="preserve">
          <source>The final step is to define the actual compilation of the project, which uses the standard IntelliJ IDEA Runner Type</source>
          <target state="translated">마지막 단계는 표준 IntelliJ IDEA 러너 유형을 사용하는 프로젝트의 실제 컴파일을 정의하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="64ebebb6a3a3dfec1d013df86e5fccb457a8633c" translate="yes" xml:space="preserve">
          <source>The final step is to make Xcode call our Gradle build to prepare the &lt;code&gt;SharedCode&lt;/code&gt; framework before each run. We open the &lt;em&gt;Build Phases&lt;/em&gt; tab and click &lt;code&gt;+&lt;/code&gt; to add the &lt;em&gt;New Run Script Phase&lt;/em&gt; and add the following code into it:</source>
          <target state="translated">마지막 단계는 Xcode에서 Gradle 빌드를 호출하여 각 실행 전에 &lt;code&gt;SharedCode&lt;/code&gt; 프레임 워크 를 준비하는 것 입니다. 우리는 열 &lt;em&gt;빌드 페이즈의&lt;/em&gt; 탭을 클릭 &lt;code&gt;+&lt;/code&gt; 추가하는 &lt;em&gt;새로운 스크립트 실행 단계를&lt;/em&gt; 하고 그것으로 다음 코드를 추가합니다 :</target>
        </trans-unit>
        <trans-unit id="18cac2860812daece2680c18729b8285d0c95c2d" translate="yes" xml:space="preserve">
          <source>The first &lt;code&gt;this&lt;/code&gt; refers to &lt;code&gt;maybeNull&lt;/code&gt;, the second one refers to the result of &lt;code&gt;firstFunction()&lt;/code&gt;, and &lt;code&gt;result&lt;/code&gt; will be the result of &lt;code&gt;secondFunction()&lt;/code&gt; (or null if &lt;code&gt;maybeNull&lt;/code&gt; or any of the intermediate results were null).</source>
          <target state="translated">먼저 &lt;code&gt;this&lt;/code&gt; 지칭 &lt;code&gt;maybeNull&lt;/code&gt; 는 , 상기 제 하나의 결과를 말한다 &lt;code&gt;firstFunction()&lt;/code&gt; 및 &lt;code&gt;result&lt;/code&gt; 의 결과 일 것이다 &lt;code&gt;secondFunction()&lt;/code&gt; IF (또는 널 &lt;code&gt;maybeNull&lt;/code&gt; 또는 중간 결과가 널 (NULL)이었다).</target>
        </trans-unit>
        <trans-unit id="4fdd8b62987d88f8c4db3a2a41e10fc4d1887b5c" translate="yes" xml:space="preserve">
          <source>The first argument in this example allows one to set a name prefix for the created binaries which is used to access them in the buildscript (see the &lt;a href=&quot;#accessing-binaries&quot;&gt;&quot;Accessing binaries&quot;&lt;/a&gt; section). Also this prefix is used as a default name for the binary file. For example on Windows the sample above produces files &lt;code&gt;foo.exe&lt;/code&gt; and &lt;code&gt;bar.exe&lt;/code&gt;.</source>
          <target state="translated">이 예제의 첫 번째 인수는 작성된 바이너리에 빌드 접두사에 액세스하는 데 사용되는 이름 접두사를 설정할 수있게합니다 ( &lt;a href=&quot;#accessing-binaries&quot;&gt;&quot;바이너리 액세스&quot;&lt;/a&gt; 섹션 참조). 또한이 접두사는 이진 파일의 기본 이름으로 사용됩니다. 예를 들어 Windows에서 위의 샘플은 &lt;code&gt;foo.exe&lt;/code&gt; 및 &lt;code&gt;bar.exe&lt;/code&gt; 파일을 생성합니다 .</target>
        </trans-unit>
        <trans-unit id="2fc302c51d198c918ae55a3c30c065988889b3c8" translate="yes" xml:space="preserve">
          <source>The first call in the chain usually should have a line break before it, but it's OK to omit it if the code makes more sense that way.</source>
          <target state="translated">체인의 첫 번째 호출은 일반적으로 앞에 줄 바꿈이 있어야하지만 코드가 더 의미가있는 경우 생략하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="b4e33fae8e821602ad4182a2f8cd98570f5752fb" translate="yes" xml:space="preserve">
          <source>The first element in the progression.</source>
          <target state="translated">진행의 첫 번째 요소.</target>
        </trans-unit>
        <trans-unit id="f74c962485a9f3f35870c553a197b5ef319d5a35" translate="yes" xml:space="preserve">
          <source>The first example mixes &lt;em&gt;non-blocking&lt;/em&gt;&lt;code&gt;delay(...)&lt;/code&gt; and &lt;em&gt;blocking&lt;/em&gt;&lt;code&gt;Thread.sleep(...)&lt;/code&gt; in the same code. It is easy to lose track of which one is blocking and which one is not. Let's be explicit about blocking using &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/run-blocking.html&quot;&gt;runBlocking&lt;/a&gt; coroutine builder:</source>
          <target state="translated">첫 번째 예 는 동일한 코드에서 &lt;em&gt;비 차단 &lt;/em&gt; &lt;code&gt;delay(...)&lt;/code&gt; 과 &lt;em&gt;차단 &lt;/em&gt; &lt;code&gt;Thread.sleep(...)&lt;/code&gt; 을 혼합 합니다. 어느 것이 막히고 어떤 것이 막히지 않았는지 쉽게 잃을 수 있습니다. &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/run-blocking.html&quot;&gt;runBlocking&lt;/a&gt; 코 루틴 빌더를 사용하여 차단하는 것에 대해 명시 적으로 설명하겠습니다 .</target>
        </trans-unit>
        <trans-unit id="b2d66cf460f6f78061ad6d5f7262d3436e850f41" translate="yes" xml:space="preserve">
          <source>The first extension takes a &lt;code&gt;char *&lt;/code&gt; as a UTF-8 string and turns it into a String. The second function does the same but for wide UTF-16 strings.</source>
          <target state="translated">첫 번째 확장자는 &lt;code&gt;char *&lt;/code&gt; 를 UTF-8 문자열로 사용하여 문자열로 바꿉니다. 두 번째 함수는 동일하지만 넓은 UTF-16 문자열에 대해 수행합니다.</target>
        </trans-unit>
        <trans-unit id="60455f009d759b3a711a0c86694ca0f8e3417539" translate="yes" xml:space="preserve">
          <source>The first four elements are added to the buffer and the sender suspends when trying to send the fifth one.</source>
          <target state="translated">처음 4 개의 요소가 버퍼에 추가되고 5 번째 요소를 보내려고하면 발신자가 일시 중단됩니다.</target>
        </trans-unit>
        <trans-unit id="ab32e32b6495f8ef1ecac2deb728551ecd768355" translate="yes" xml:space="preserve">
          <source>The first function is &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/flatten&quot;&gt;&lt;code&gt;flatten()&lt;/code&gt;&lt;/a&gt;. You can call it on a collection of collections, for example, a &lt;code&gt;List&lt;/code&gt; of &lt;code&gt;Set&lt;/code&gt;s. The function returns a single &lt;code&gt;List&lt;/code&gt; of all the elements of the nested collections.</source>
          <target state="translated">첫 번째 함수는 &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/flatten&quot;&gt; &lt;code&gt;flatten()&lt;/code&gt; &lt;/a&gt; 입니다. 컬렉션 모음 (예 : &lt;code&gt;List&lt;/code&gt; of &lt;code&gt;Set&lt;/code&gt; ) 에서 호출 할 수 있습니다 . 이 함수는 중첩 컬렉션의 모든 요소에 대한 단일 &lt;code&gt;List&lt;/code&gt; 를 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="bb9b81609c647210d6aacd108c4c1230b4870b5f" translate="yes" xml:space="preserve">
          <source>The first line of the input contains two integers &lt;code&gt;n&lt;/code&gt; and &lt;code&gt;k&lt;/code&gt;</source>
          <target state="translated">입력의 첫 번째 줄에는 두 개의 정수 &lt;code&gt;n&lt;/code&gt; 과 &lt;code&gt;k&lt;/code&gt; 가 있습니다.</target>
        </trans-unit>
        <trans-unit id="a973365d252e2f2156e9bff5ffce49da12fd36a5" translate="yes" xml:space="preserve">
          <source>The first list contains the first elements of each &lt;code&gt;Pair&lt;/code&gt; in the original list.</source>
          <target state="translated">첫 번째 목록에는 원본 목록에서 각 &lt;code&gt;Pair&lt;/code&gt; 의 첫 번째 요소가 포함 됩니다.</target>
        </trans-unit>
        <trans-unit id="79bda60284dc4aa80a7917505f3968fd9009f668" translate="yes" xml:space="preserve">
          <source>The first step of using an actor is to define a class of messages that an actor is going to process. Kotlin's &lt;a href=&quot;../sealed-classes&quot;&gt;sealed classes&lt;/a&gt; are well suited for that purpose. We define &lt;code&gt;CounterMsg&lt;/code&gt; sealed class with &lt;code&gt;IncCounter&lt;/code&gt; message to increment a counter and &lt;code&gt;GetCounter&lt;/code&gt; message to get its value. The later needs to send a response. A &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-completable-deferred/index.html&quot;&gt;CompletableDeferred&lt;/a&gt; communication primitive, that represents a single value that will be known (communicated) in the future, is used here for that purpose.</source>
          <target state="translated">액터를 사용하는 첫 번째 단계는 액터가 처리 할 메시지 클래스를 정의하는 것입니다. 코 틀린의 &lt;a href=&quot;../sealed-classes&quot;&gt;봉인 수업&lt;/a&gt; 은 그 목적에 매우 적합합니다. 카운터를 증가시키기 위해 &lt;code&gt;IncCounter&lt;/code&gt; 메시지와 그 값을 얻기 위해 &lt;code&gt;GetCounter&lt;/code&gt; 메시지를 사용하여 &lt;code&gt;CounterMsg&lt;/code&gt; 밀봉 클래스를 정의 합니다. 나중에 응답을 보내야합니다. &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-completable-deferred/index.html&quot;&gt;CompletableDeferred의&lt;/a&gt; 미래에 공지 (전달) 될 단일 값을 나타내는 원시 통신은, 그 목적을 위해 여기에 사용된다.</target>
        </trans-unit>
        <trans-unit id="38481ec6d5c41bf35d07d09bc7535247f80dee43" translate="yes" xml:space="preserve">
          <source>The first thing we'll need is a Kotlin file called &lt;code&gt;src/nativeMain/kotlin/hello.kt&lt;/code&gt; with the &lt;code&gt;main&lt;/code&gt; function defined in it and then proceed to translate each line</source>
          <target state="translated">가장 먼저 필요한 것은 &lt;code&gt;src/nativeMain/kotlin/hello.kt&lt;/code&gt; 라는 Kotlin 파일 입니다. 여기에 &lt;code&gt;main&lt;/code&gt; 함수가 정의되어 있고 각 줄을 번역하십시오.</target>
        </trans-unit>
        <trans-unit id="6f6aa8f820f0284bd28697b0207de3b2578af79f" translate="yes" xml:space="preserve">
          <source>The following attributes are supported:</source>
          <target state="translated">다음과 같은 속성이 지원됩니다.</target>
        </trans-unit>
        <trans-unit id="d555f20ea9bbf2028964527e2711757cec45ebd4" translate="yes" xml:space="preserve">
          <source>The following code launches a long-running coroutine in &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-global-scope/index.html&quot;&gt;GlobalScope&lt;/a&gt; that prints &quot;I'm sleeping&quot; twice a second and then returns from the main function after some delay:</source>
          <target state="translated">다음 코드는 &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-global-scope/index.html&quot;&gt;GlobalScope&lt;/a&gt; 에서 오래 실행되는 코 루틴을 시작하여 1 초에 두 번 &quot;잠자고 있습니다&quot;를 인쇄 한 다음 약간의 지연 후에 기본 기능에서 돌아옵니다.</target>
        </trans-unit>
        <trans-unit id="ead88ea1dd6b3e545d54d2d74bc4d103e0cfff51" translate="yes" xml:space="preserve">
          <source>The following commands are available.</source>
          <target state="translated">다음과 같은 명령을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="55be4cb42f91b956f18957a0a075265fb24672f6" translate="yes" xml:space="preserve">
          <source>The following example demonstrates this concept:</source>
          <target state="translated">다음 예제는이 개념을 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="40d8cb89ac87b573a486f4f8fe49663dde1297b2" translate="yes" xml:space="preserve">
          <source>The following example prints the first ten prime numbers, running the whole pipeline in the context of the main thread. Since all the coroutines are launched in the scope of the main &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/run-blocking.html&quot;&gt;runBlocking&lt;/a&gt; coroutine we don't have to keep an explicit list of all the coroutines we have started. We use &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/kotlin.coroutines.-coroutine-context/cancel-children.html&quot;&gt;cancelChildren&lt;/a&gt; extension function to cancel all the children coroutines after we have printed the first ten prime numbers.</source>
          <target state="translated">다음 예제는 메인 스레드와 관련하여 전체 파이프 라인을 실행하는 처음 10 개의 소수를 인쇄합니다. 모든 코 루틴은 기본 &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/run-blocking.html&quot;&gt;runBlocking&lt;/a&gt; 코 루틴 의 범위에서 시작되므로 시작한 모든 코 루틴의 목록을 명시 적으로 유지할 필요는 없습니다. 우리는 &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/kotlin.coroutines.-coroutine-context/cancel-children.html&quot;&gt;cancelChildren&lt;/a&gt; 확장 기능을 사용 하여 처음 10 개의 소수를 인쇄 한 후 모든 자식 코 루틴을 취소합니다.</target>
        </trans-unit>
        <trans-unit id="9f818012b8152abe166a094d93ab2ca0ec79eab1" translate="yes" xml:space="preserve">
          <source>The following example shows how to use these settings.</source>
          <target state="translated">다음 예는 이러한 설정을 사용하는 방법을 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="29c80399d536894a6ec94c527a731166260c49c2" translate="yes" xml:space="preserve">
          <source>The following example shows their use outside of coroutine:</source>
          <target state="translated">다음 예제는 코 루틴 외부에서의 사용을 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="b39c4c0b095563ff59ef483ec27836f8b662f2fa" translate="yes" xml:space="preserve">
          <source>The following examples show different possibilities of configuring the Gradle plugin:</source>
          <target state="translated">다음 예제는 Gradle 플러그인 구성의 다양한 가능성을 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="e712d7790d39e907b7ee7e8cb60e61e0c86b31e2" translate="yes" xml:space="preserve">
          <source>The following identifiers are defined by the compiler in specific contexts and can be used as regular identifiers in other contexts:</source>
          <target state="translated">다음 식별자는 특정 컨텍스트에서 컴파일러에 의해 정의되며 다른 컨텍스트에서 일반 식별자로 사용될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="bf95dedf99c3841e1d5196a0ba2d969912347f7d" translate="yes" xml:space="preserve">
          <source>The following is an example interface of the JDK implemented by &lt;code&gt;StringBuilder&lt;/code&gt; class:</source>
          <target state="translated">다음은 &lt;code&gt;StringBuilder&lt;/code&gt; 클래스로 구현 된 JDK의 인터페이스 예입니다 .</target>
        </trans-unit>
        <trans-unit id="8e29598dc88ea6b0ec70ab50aa2a4cfa741c6e7f" translate="yes" xml:space="preserve">
          <source>The following pipeline stage filters an incoming stream of numbers, removing all the numbers that are divisible by the given prime number:</source>
          <target state="translated">다음 파이프 라인 단계는 들어오는 숫자 스트림을 필터링하여 지정된 소수로 나눌 수있는 모든 숫자를 제거합니다.</target>
        </trans-unit>
        <trans-unit id="29b7ef083a5e449cb9ecea68dfa0ae64024fefca" translate="yes" xml:space="preserve">
          <source>The following podspec fields are required by CocoaPods:</source>
          <target state="translated">CocoaPod에는 다음 podspec 필드가 필요합니다.</target>
        </trans-unit>
        <trans-unit id="21b0584d86535ffda98821a37bb76687f7207959" translate="yes" xml:space="preserve">
          <source>The following sections explain in more detail the concepts mentioned so far.</source>
          <target state="translated">다음 섹션에서는 지금까지 언급 한 개념에 대해 자세히 설명합니다.</target>
        </trans-unit>
        <trans-unit id="5472a88e6462dc9e30567cf6b7a816998c79c200" translate="yes" xml:space="preserve">
          <source>The following tokens act as keywords in modifier lists of declarations and can be used as identifiers in other contexts:</source>
          <target state="translated">다음 토큰은 수정 자 선언 목록에서 키워드 역할을하며 다른 컨텍스트에서 식별자로 사용될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c62886b027ba800287b4be18a333a156fdeb309b" translate="yes" xml:space="preserve">
          <source>The following tokens act as keywords in the context when they are applicable and can be used as identifiers in other contexts:</source>
          <target state="translated">다음 토큰은 해당 컨텍스트에서 키워드 역할을하며 다른 컨텍스트에서 식별자로 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="71c4c5ec356525034ad2f877a92ba2dfdfffc609" translate="yes" xml:space="preserve">
          <source>The following tokens are always interpreted as keywords and cannot be used as identifiers:</source>
          <target state="translated">다음 토큰은 항상 키워드로 해석되며 식별자로 사용할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="0493d41eaaff9f9930d4990e582a0014dff8b09e" translate="yes" xml:space="preserve">
          <source>The following workflow is expected when interacting with the native library.</source>
          <target state="translated">기본 라이브러리와 상호 작용할 때 다음과 같은 워크 플로우가 예상됩니다.</target>
        </trans-unit>
        <trans-unit id="46d230bab2ec3e41d052e1e397afc7cc1e96642c" translate="yes" xml:space="preserve">
          <source>The fractional part, if any, is rounded down. Returns zero if this &lt;code&gt;Double&lt;/code&gt; value is &lt;code&gt;NaN&lt;/code&gt;, &lt;a href=&quot;../-int/-m-i-n_-v-a-l-u-e#kotlin.Int.Companion%24MIN_VALUE&quot;&gt;Int.MIN_VALUE&lt;/a&gt; if it's less than &lt;code&gt;Int.MIN_VALUE&lt;/code&gt;, &lt;a href=&quot;../-int/-m-a-x_-v-a-l-u-e#kotlin.Int.Companion%24MAX_VALUE&quot;&gt;Int.MAX_VALUE&lt;/a&gt; if it's bigger than &lt;code&gt;Int.MAX_VALUE&lt;/code&gt;.</source>
          <target state="translated">소수 부분은 반올림됩니다. 반환이 경우 제로 &lt;code&gt;Double&lt;/code&gt; 값이 &lt;code&gt;NaN&lt;/code&gt; 의 , &lt;a href=&quot;../-int/-m-i-n_-v-a-l-u-e#kotlin.Int.Companion%24MIN_VALUE&quot;&gt;Int.MIN_VALUE&lt;/a&gt; 미만의 경우 &lt;code&gt;Int.MIN_VALUE&lt;/code&gt; , &lt;a href=&quot;../-int/-m-a-x_-v-a-l-u-e#kotlin.Int.Companion%24MAX_VALUE&quot;&gt;Int.MAX_VALUE&lt;/a&gt; 그것보다 더 큰 경우 &lt;code&gt;Int.MAX_VALUE&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c7c04cb487d62c119eaf78735ad59d58fbbea7f7" translate="yes" xml:space="preserve">
          <source>The fractional part, if any, is rounded down. Returns zero if this &lt;code&gt;Double&lt;/code&gt; value is &lt;code&gt;NaN&lt;/code&gt;, &lt;a href=&quot;../-long/-m-i-n_-v-a-l-u-e#kotlin.Long.Companion%24MIN_VALUE&quot;&gt;Long.MIN_VALUE&lt;/a&gt; if it's less than &lt;code&gt;Long.MIN_VALUE&lt;/code&gt;, &lt;a href=&quot;../-long/-m-a-x_-v-a-l-u-e#kotlin.Long.Companion%24MAX_VALUE&quot;&gt;Long.MAX_VALUE&lt;/a&gt; if it's bigger than &lt;code&gt;Long.MAX_VALUE&lt;/code&gt;.</source>
          <target state="translated">소수 부분은 반올림됩니다. 이 &lt;code&gt;Double&lt;/code&gt; 값이 &lt;code&gt;NaN&lt;/code&gt; 인 경우 0을 , &lt;a href=&quot;../-long/-m-i-n_-v-a-l-u-e#kotlin.Long.Companion%24MIN_VALUE&quot;&gt;Long.MIN_VALUE&lt;/a&gt; 보다 작은 경우 &lt;code&gt;Long.MIN_VALUE&lt;/code&gt; , &lt;a href=&quot;../-long/-m-a-x_-v-a-l-u-e#kotlin.Long.Companion%24MAX_VALUE&quot;&gt;Long.MAX_VALUE&lt;/a&gt; 보다 큰 경우 &lt;code&gt;Long.MAX_VALUE&lt;/code&gt; 를 리턴합니다 .</target>
        </trans-unit>
        <trans-unit id="986d603361e48796a38eb31b882249f0e0fb1907" translate="yes" xml:space="preserve">
          <source>The fractional part, if any, is rounded down. Returns zero if this &lt;code&gt;Double&lt;/code&gt; value is negative or &lt;code&gt;NaN&lt;/code&gt;, &lt;a href=&quot;-u-int/-m-a-x_-v-a-l-u-e&quot;&gt;UInt.MAX_VALUE&lt;/a&gt; if it's bigger than &lt;code&gt;UInt.MAX_VALUE&lt;/code&gt;.</source>
          <target state="translated">소수 부분은 반올림됩니다. 이 &lt;code&gt;Double&lt;/code&gt; 값이 음수 이면 0을 &lt;code&gt;NaN&lt;/code&gt; 하고 &lt;a href=&quot;-u-int/-m-a-x_-v-a-l-u-e&quot;&gt;UInt.MAX_VALUE&lt;/a&gt; 보다 큰 경우 &lt;code&gt;UInt.MAX_VALUE&lt;/code&gt; 를 반환 합니다.</target>
        </trans-unit>
        <trans-unit id="db89446a546caa08c045751959e85b9b42af6661" translate="yes" xml:space="preserve">
          <source>The fractional part, if any, is rounded down. Returns zero if this &lt;code&gt;Double&lt;/code&gt; value is negative or &lt;code&gt;NaN&lt;/code&gt;, &lt;a href=&quot;-u-long/-m-a-x_-v-a-l-u-e&quot;&gt;ULong.MAX_VALUE&lt;/a&gt; if it's bigger than &lt;code&gt;ULong.MAX_VALUE&lt;/code&gt;.</source>
          <target state="translated">소수 부분은 반올림됩니다. 이 &lt;code&gt;Double&lt;/code&gt; 값이 음수 이면 0을 &lt;code&gt;NaN&lt;/code&gt; 하고 &lt;a href=&quot;-u-long/-m-a-x_-v-a-l-u-e&quot;&gt;ULong.MAX_VALUE&lt;/a&gt; 보다 큰 경우 &lt;code&gt;ULong.MAX_VALUE&lt;/code&gt; 를 반환 합니다.</target>
        </trans-unit>
        <trans-unit id="6c0d7df43097a38a432b999c674eaa178ec96a50" translate="yes" xml:space="preserve">
          <source>The fractional part, if any, is rounded down. Returns zero if this &lt;code&gt;Float&lt;/code&gt; value is &lt;code&gt;NaN&lt;/code&gt;, &lt;a href=&quot;../-int/-m-i-n_-v-a-l-u-e#kotlin.Int.Companion%24MIN_VALUE&quot;&gt;Int.MIN_VALUE&lt;/a&gt; if it's less than &lt;code&gt;Int.MIN_VALUE&lt;/code&gt;, &lt;a href=&quot;../-int/-m-a-x_-v-a-l-u-e#kotlin.Int.Companion%24MAX_VALUE&quot;&gt;Int.MAX_VALUE&lt;/a&gt; if it's bigger than &lt;code&gt;Int.MAX_VALUE&lt;/code&gt;.</source>
          <target state="translated">소수 부분은 반올림됩니다. 반환이 경우 제로 &lt;code&gt;Float&lt;/code&gt; 값이 &lt;code&gt;NaN&lt;/code&gt; 의 , &lt;a href=&quot;../-int/-m-i-n_-v-a-l-u-e#kotlin.Int.Companion%24MIN_VALUE&quot;&gt;Int.MIN_VALUE&lt;/a&gt; 그 이하의 경우 &lt;code&gt;Int.MIN_VALUE&lt;/code&gt; , &lt;a href=&quot;../-int/-m-a-x_-v-a-l-u-e#kotlin.Int.Companion%24MAX_VALUE&quot;&gt;Int.MAX_VALUE&lt;/a&gt; 그것보다 더 큰 경우 &lt;code&gt;Int.MAX_VALUE&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="234cddb40ea7edc20ba16f302fd45e435a6a6dbf" translate="yes" xml:space="preserve">
          <source>The fractional part, if any, is rounded down. Returns zero if this &lt;code&gt;Float&lt;/code&gt; value is &lt;code&gt;NaN&lt;/code&gt;, &lt;a href=&quot;../-long/-m-i-n_-v-a-l-u-e#kotlin.Long.Companion%24MIN_VALUE&quot;&gt;Long.MIN_VALUE&lt;/a&gt; if it's less than &lt;code&gt;Long.MIN_VALUE&lt;/code&gt;, &lt;a href=&quot;../-long/-m-a-x_-v-a-l-u-e#kotlin.Long.Companion%24MAX_VALUE&quot;&gt;Long.MAX_VALUE&lt;/a&gt; if it's bigger than &lt;code&gt;Long.MAX_VALUE&lt;/code&gt;.</source>
          <target state="translated">소수 부분은 반올림됩니다. 반환이 경우 제로 &lt;code&gt;Float&lt;/code&gt; 값이 &lt;code&gt;NaN&lt;/code&gt; 의 , &lt;a href=&quot;../-long/-m-i-n_-v-a-l-u-e#kotlin.Long.Companion%24MIN_VALUE&quot;&gt;Long.MIN_VALUE로부터&lt;/a&gt; 그 이하의 경우 &lt;code&gt;Long.MIN_VALUE&lt;/code&gt; 로부터 , &lt;a href=&quot;../-long/-m-a-x_-v-a-l-u-e#kotlin.Long.Companion%24MAX_VALUE&quot;&gt;로부터 Long.MAX_VALUE&lt;/a&gt; 그것보다 더 큰 경우 &lt;code&gt;Long.MAX_VALUE&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0a1bb43be34e6fb6de623932b67b670ae0006852" translate="yes" xml:space="preserve">
          <source>The fractional part, if any, is rounded down. Returns zero if this &lt;code&gt;Float&lt;/code&gt; value is negative or &lt;code&gt;NaN&lt;/code&gt;, &lt;a href=&quot;-u-int/-m-a-x_-v-a-l-u-e&quot;&gt;UInt.MAX_VALUE&lt;/a&gt; if it's bigger than &lt;code&gt;UInt.MAX_VALUE&lt;/code&gt;.</source>
          <target state="translated">소수 부분은 반올림됩니다. 이 &lt;code&gt;Float&lt;/code&gt; 값이 음수 인 경우 0을 &lt;code&gt;NaN&lt;/code&gt; 하고 &lt;a href=&quot;-u-int/-m-a-x_-v-a-l-u-e&quot;&gt;UInt.MAX_VALUE&lt;/a&gt; 보다 큰 경우 &lt;code&gt;UInt.MAX_VALUE&lt;/code&gt; 를 반환 합니다.</target>
        </trans-unit>
        <trans-unit id="1fdd0d739f0100ce802b95ab4a4c9b2532feeff0" translate="yes" xml:space="preserve">
          <source>The fractional part, if any, is rounded down. Returns zero if this &lt;code&gt;Float&lt;/code&gt; value is negative or &lt;code&gt;NaN&lt;/code&gt;, &lt;a href=&quot;-u-long/-m-a-x_-v-a-l-u-e&quot;&gt;ULong.MAX_VALUE&lt;/a&gt; if it's bigger than &lt;code&gt;ULong.MAX_VALUE&lt;/code&gt;.</source>
          <target state="translated">소수 부분은 반올림됩니다. 이 경우 0을 반환 &lt;code&gt;Float&lt;/code&gt; 값이 음수이거나 &lt;code&gt;NaN&lt;/code&gt; 의 , &lt;a href=&quot;-u-long/-m-a-x_-v-a-l-u-e&quot;&gt;ULong.MAX_VALUE&lt;/a&gt; 그것보다 더 큰 경우 &lt;code&gt;ULong.MAX_VALUE&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ea6eb6722ce134e1e96c66df47559354876af311" translate="yes" xml:space="preserve">
          <source>The framework that we compiled with Kotlin/Native has helper attributes to make it easier to use with Swift. Let's convert the previous Objective-C example into Swift. As a result, we'll have the following code in &lt;code&gt;main.swift&lt;/code&gt;:</source>
          <target state="translated">우리가 Kotlin / Native로 컴파일 한 프레임 워크에는 Swift에서 더 쉽게 사용할 수 있도록 돕는 속성이 있습니다. 이전 Objective-C 예제를 Swift로 변환 해 봅시다. 결과적으로 &lt;code&gt;main.swift&lt;/code&gt; 에 다음 코드가 생깁니다 .</target>
        </trans-unit>
        <trans-unit id="229775820ba0ca0053d7b140e68dd9b3ed428ae4" translate="yes" xml:space="preserve">
          <source>The full build script for the sample project can be found &lt;a href=&quot;https://github.com/JetBrains/kotlin-examples/tree/master/gradle/kotlin-dagger/build.gradle&quot;&gt;here&lt;/a&gt;. You can also look at the converted code for &lt;a href=&quot;https://github.com/JetBrains/kotlin-examples/tree/master/gradle/android-dagger&quot;&gt;the Android sample&lt;/a&gt;.</source>
          <target state="translated">샘플 프로젝트의 전체 빌드 스크립트는 &lt;a href=&quot;https://github.com/JetBrains/kotlin-examples/tree/master/gradle/kotlin-dagger/build.gradle&quot;&gt;여기&lt;/a&gt; 에서 찾을 수 있습니다 . 당신은 또한 &lt;a href=&quot;https://github.com/JetBrains/kotlin-examples/tree/master/gradle/android-dagger&quot;&gt;안드로이드 샘플에&lt;/a&gt; 대한 변환 된 코드를 볼 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="e62bc4cb51ca1d1cddfe4e1d3d510caa93dee388" translate="yes" xml:space="preserve">
          <source>The full list of arguments that can be used is shown when you run &lt;code&gt;kotlinc -help&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;kotlinc -help&lt;/code&gt; 를 실행할 때 사용할 수있는 전체 인수 목록이 표시됩니다 .</target>
        </trans-unit>
        <trans-unit id="02b69f589be9184eaa6e08d9fb77b12e7b2d6da2" translate="yes" xml:space="preserve">
          <source>The full list of supported use-site targets is:</source>
          <target state="translated">지원되는 사용 사이트 대상의 전체 목록은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="58018a7c2f7cccce2f2841705c78d55576a7e56f" translate="yes" xml:space="preserve">
          <source>The full syntactic form of lambda expressions is as follows:</source>
          <target state="translated">람다 식의 전체 구문 형태는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="1347221f9ac10fa3f9465e07c5ca87cc27e8a8e6" translate="yes" xml:space="preserve">
          <source>The full syntax for declaring a property is</source>
          <target state="translated">속성을 선언하는 전체 구문은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="905c760b34a0beb7b5d4d319c2f007dd8ebd0fd3" translate="yes" xml:space="preserve">
          <source>The full syntax of a read-only property declaration differs from a mutable one in two ways: it starts with &lt;code&gt;val&lt;/code&gt; instead of &lt;code&gt;var&lt;/code&gt; and does not allow a setter:</source>
          <target state="translated">읽기 전용 속성 선언의 전체 구문은 다음 두 가지면에서 변경 가능한 것과 다릅니다. &lt;code&gt;var&lt;/code&gt; 대신 &lt;code&gt;val&lt;/code&gt; 로 시작 하고 setter를 허용하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="0ee52f844a0963f3db9f0478ccd20b13916c48b9" translate="yes" xml:space="preserve">
          <source>The fully qualified dot-separated name of the class, or &lt;code&gt;null&lt;/code&gt; if the class is local or it is an anonymous object literal.</source>
          <target state="translated">정규화 된 점으로 구분 된 클래스 이름이거나 클래스가 로컬이거나 익명 객체 리터럴 인 경우 &lt;code&gt;null&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="39a40c87789f813fc496dc5468cc91805583814e" translate="yes" xml:space="preserve">
          <source>The function &lt;code&gt;libnative_symbols&lt;/code&gt; allows us to open the way from the native code to the Kotlin/Native library. This is the entry point we use. The library name is used as a prefix for the function name.</source>
          <target state="translated">&lt;code&gt;libnative_symbols&lt;/code&gt; 함수를 사용하면 원시 코드에서 Kotlin / Native 라이브러리로가는 길을 열 수 있습니다. 이것이 우리가 사용하는 진입 점입니다. 라이브러리 이름은 함수 이름의 접두사로 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="ecf68a80d3d421d1a3dac0bf6a7b99795040c5e0" translate="yes" xml:space="preserve">
          <source>The function body is delimited by curly braces - indentation is generally not significant in Kotlin, but you should of course indent your code properly for the benefit of human readers.</source>
          <target state="translated">함수 본문은 중괄호로 구분됩니다. 들여 쓰기는 일반적으로 Kotlin에서 중요하지 않지만, 인간 독자의 이익을 위해 코드를 올바르게 들여 쓰기해야합니다.</target>
        </trans-unit>
        <trans-unit id="892b57cbc7486be03e2291de2837204f537e592b" translate="yes" xml:space="preserve">
          <source>The function does upgrade from read to write lock if needed, but this upgrade is not atomic as such upgrade is not supported by &lt;a href=&quot;http://docs.oracle.com/javase/8/docs/api/java/util/concurrent/locks/ReentrantReadWriteLock.html&quot;&gt;ReentrantReadWriteLock&lt;/a&gt;. In order to do such upgrade this function first releases all read locks held by this thread, then acquires write lock, and after releasing it acquires read locks back again.</source>
          <target state="translated">이 기능은 필요한 경우 읽기에서 쓰기 잠금으로 업그레이드하지만 &lt;a href=&quot;http://docs.oracle.com/javase/8/docs/api/java/util/concurrent/locks/ReentrantReadWriteLock.html&quot;&gt;ReentrantReadWriteLock&lt;/a&gt; 은 해당 업그레이드를 지원하지 않으므로이 업그레이드는 원 자성이 아닙니다 . 이러한 업그레이드를 수행하기 위해이 기능은 먼저이 스레드가 보유한 모든 읽기 잠금을 해제 한 다음 쓰기 잠금을 획득 한 후 해제 한 후 다시 읽기 잠금을 획득합니다.</target>
        </trans-unit>
        <trans-unit id="47e9d14611b3a1f9114880a2ff853190d9e97c10" translate="yes" xml:space="preserve">
          <source>The function signature remains exactly the same. The only difference is &lt;code&gt;suspend&lt;/code&gt; being added to it. The return type however is the type we want to be returned.</source>
          <target state="translated">함수 서명은 정확히 동일하게 유지됩니다. 유일한 차이점은 &lt;code&gt;suspend&lt;/code&gt; 이 추가되는 것입니다. 그러나 반환 유형은 반환하려는 유형입니다.</target>
        </trans-unit>
        <trans-unit id="f6772ad37911fb29515e5ecad2f466bed6bdb7cd" translate="yes" xml:space="preserve">
          <source>The function type notation can optionally include names for the function parameters: &lt;code&gt;(x: Int, y: Int) -&amp;gt; Point&lt;/code&gt;. These names can be used for documenting the meaning of the parameters.</source>
          <target state="translated">함수 유형 표기법은 선택적으로 함수 매개 변수의 이름을 포함 할 수 있습니다 : &lt;code&gt;(x: Int, y: Int) -&amp;gt; Point&lt;/code&gt; . 이 이름은 매개 변수의 의미를 문서화하는 데 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5f62a960bb01edb991f086fcecfa3233b3994fce" translate="yes" xml:space="preserve">
          <source>The functions include trigonometric, hyperbolic, exponentiation and power, logarithmic, rounding, sign and absolute value.</source>
          <target state="translated">함수에는 삼각법, 쌍곡선, 지수 및 거듭 제곱, 로그, 반올림, 부호 및 절대 값이 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="332c4fb906dbcda140f018d0de201e8c1ce3d30d" translate="yes" xml:space="preserve">
          <source>The general rule is: when a type parameter &lt;code&gt;T&lt;/code&gt; of a class &lt;code&gt;C&lt;/code&gt; is declared &lt;strong&gt;out&lt;/strong&gt;, it may occur only in &lt;strong&gt;out&lt;/strong&gt;-position in the members of &lt;code&gt;C&lt;/code&gt;, but in return &lt;code&gt;C&amp;lt;Base&amp;gt;&lt;/code&gt; can safely be a supertype of &lt;code&gt;C&amp;lt;Derived&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">일반적인 규칙은 다음과 같습니다 매개 변수 유형 때 &lt;code&gt;T&lt;/code&gt; 클래스의 &lt;code&gt;C&lt;/code&gt; 가 선언 &lt;strong&gt;밖으로&lt;/strong&gt; , 그것은 단지에서 발생할 수있는 &lt;strong&gt;아웃&lt;/strong&gt; 의 구성원의 &amp;alpha; 위치 &lt;code&gt;C&lt;/code&gt; ,하지만 반환에 &lt;code&gt;C&amp;lt;Base&amp;gt;&lt;/code&gt; 안전의 슈퍼 될 수있다 &lt;code&gt;C&amp;lt;Derived&amp;gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="47a803852f9a44b2a9ede00ebab7d2f5f19ab5c5" translate="yes" xml:space="preserve">
          <source>The general rule:</source>
          <target state="translated">일반적인 규칙 :</target>
        </trans-unit>
        <trans-unit id="39d2229c00faf1c133ef862b873c7364c63bd099" translate="yes" xml:space="preserve">
          <source>The general solution that works both for threads and for coroutines is to use a thread-safe (aka synchronized, linearizable, or atomic) data structure that provides all the necessarily synchronization for the corresponding operations that needs to be performed on a shared state. In the case of a simple counter we can use &lt;code&gt;AtomicInteger&lt;/code&gt; class which has atomic &lt;code&gt;incrementAndGet&lt;/code&gt; operations:</source>
          <target state="translated">스레드와 코 루틴 모두에서 작동하는 일반적인 솔루션은 공유 상태에서 수행해야하는 해당 작업에 필요한 모든 동기화를 제공하는 스레드 안전 (일명 동기화, 선형화 또는 원자) 데이터 구조를 사용하는 것입니다. 간단한 카운터의 경우 &lt;code&gt;AtomicInteger&lt;/code&gt; 클래스를 사용하여 atomic &lt;code&gt;incrementAndGet&lt;/code&gt; 작업을 수행 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="fe194a34c4e181902ef2477861ca1a56a0c14e72" translate="yes" xml:space="preserve">
          <source>The generated constructor is synthetic so it can&amp;rsquo;t be directly called from Java or Kotlin, but it can be called using reflection.</source>
          <target state="translated">생성 된 생성자는 합성이므로 Java 또는 Kotlin에서 직접 호출 할 수 없지만 리플렉션을 사용하여 호출 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c09ea74ea1b03fd685bbe5f94354a8374db022b3" translate="yes" xml:space="preserve">
          <source>The getter of this property, used to obtain the value of the property.</source>
          <target state="translated">이 프로퍼티의 getter. 프로퍼티의 값을 취득하는데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="5599725590a9016e21ca4310f17eb7b2b01a0483" translate="yes" xml:space="preserve">
          <source>The globs are applied to the header paths relative to the appropriate include path elements, e.g. &lt;code&gt;time.h&lt;/code&gt; or &lt;code&gt;curl/curl.h&lt;/code&gt;. So if the library is usually included with &lt;code&gt;#include &amp;lt;SomeLbrary/Header.h&amp;gt;&lt;/code&gt;, then it would probably be correct to filter headers with</source>
          <target state="translated">글로브는 적절한 포함 경로 요소, 예를 들어 &lt;code&gt;time.h&lt;/code&gt; 또는 &lt;code&gt;curl/curl.h&lt;/code&gt; 와 관련하여 헤더 경로에 적용됩니다 . 따라서 라이브러리가 일반적으로 &lt;code&gt;#include &amp;lt;SomeLbrary/Header.h&amp;gt;&lt;/code&gt; 에 포함되어 있으면 헤더를 필터링하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="a57ffec5971f7b3f89d004ca095f66feb86eb296" translate="yes" xml:space="preserve">
          <source>The goal of the tutorial is to demonstrate Kotlin code re-use between Android and iOS. Let's start by manually creating the &lt;code&gt;SharedCode&lt;/code&gt; sub-project in our Gradle project. The source code from the &lt;code&gt;SharedCode&lt;/code&gt; project will be shared between platforms. We will create several new files in our project to implement that.</source>
          <target state="translated">튜토리얼의 목표는 Android와 iOS 간의 Kotlin 코드 재사용을 보여주는 것입니다. Gradle 프로젝트에서 &lt;code&gt;SharedCode&lt;/code&gt; 하위 프로젝트를 수동으로 생성하여 시작하겠습니다 . &lt;code&gt;SharedCode&lt;/code&gt; 프로젝트 의 소스 코드 는 플랫폼간에 공유됩니다. 이를 구현하기 위해 프로젝트에 여러 개의 새 파일을 작성합니다.</target>
        </trans-unit>
        <trans-unit id="068a964193217c327091688b8b7de38e4eb4f3e1" translate="yes" xml:space="preserve">
          <source>The header files merely contain function declarations for functionality that is defined at runtime. For instance, we could define a &lt;code&gt;jQuery&lt;/code&gt; function like so</source>
          <target state="translated">헤더 파일에는 런타임시 정의 된 기능에 대한 함수 선언 만 포함됩니다. 예를 들어, &lt;code&gt;jQuery&lt;/code&gt; 함수를 다음과 같이 정의 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6ce2e166fe215303244aa3044be29e2844cbf2bc" translate="yes" xml:space="preserve">
          <source>The iOS simulator requires a framework compiled for the &lt;code&gt;ios_x64&lt;/code&gt; target, the &lt;code&gt;iOS_sim&lt;/code&gt; folder in our case.</source>
          <target state="translated">iOS 시뮬레이터에는 우리의 경우 &lt;code&gt;iOS_sim&lt;/code&gt; 폴더 인 &lt;code&gt;ios_x64&lt;/code&gt; 대상을 위해 컴파일 된 프레임 워크가 필요합니다 .</target>
        </trans-unit>
        <trans-unit id="31859b6cbcfb9892316b62d967e1f5ae2235d5ef" translate="yes" xml:space="preserve">
          <source>The idea behind Rx is to move towards what's called &lt;code&gt;observable streams&lt;/code&gt; where by we now think of data as streams (infinite amounts of data) and these streams can be observed. In practical terms, Rx is simply the &lt;a href=&quot;https://en.wikipedia.org/wiki/Observer_pattern&quot;&gt;Observer Pattern&lt;/a&gt; with a series of extensions which allow us to operate on the data.</source>
          <target state="translated">Rx의 기본 개념 은 데이터를 스트림 (무한량의 데이터)으로 생각하고이 스트림을 관찰 할 수있는 관찰 &lt;code&gt;observable streams&lt;/code&gt; 이동하는 것입니다. 실제로 Rx는 단순히 데이터를 조작 할 수있는 일련의 확장 기능을 가진 &lt;a href=&quot;https://en.wikipedia.org/wiki/Observer_pattern&quot;&gt;Observer 패턴&lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="a752acd40500d4af1aa6897c4527c1276e603455" translate="yes" xml:space="preserve">
          <source>The idea behind futures or promises (there are also other terms these can be referred to depending on language/platform), is that when we make a call, we're promised that at some point it will return with an object called a Promise, which can then be operated on.</source>
          <target state="translated">선물이나 약속에 대한 아이디어 (언어 / 플랫폼에 따라 다른 용어가있을 수도 있음)는 전화를 걸 때 언젠가 약속이라는 물건으로 돌아올 것이라고 약속합니다. 그런 다음 작동 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0ec5a5ec78c5bbba1d9a9593b45aa36ac04ad75c" translate="yes" xml:space="preserve">
          <source>The idea is to make every platform show similar text: &lt;code&gt;Kotlin Rocks on Android&lt;/code&gt; and &lt;code&gt;Kotlin Rocks on iOS&lt;/code&gt;, depending on the platform. We will reuse the way we generate the message. Let's create the file (and missing directories) &lt;code&gt;SharedCode/src/commonMain/kotlin/common.kt&lt;/code&gt; with the following contents under the project root directory</source>
          <target state="translated">: 아이디어는 모든 플랫폼이 유사한 텍스트를 표시하는 것입니다 &lt;code&gt;Kotlin Rocks on Android&lt;/code&gt; 와 &lt;code&gt;Kotlin Rocks on iOS&lt;/code&gt; 플랫폼에 따라. 메시지 생성 방식을 재사용 할 것입니다. 프로젝트 루트 디렉토리 아래에 다음 내용으로 파일 (및 누락 된 디렉토리) &lt;code&gt;SharedCode/src/commonMain/kotlin/common.kt&lt;/code&gt; 를 작성해 봅시다</target>
        </trans-unit>
        <trans-unit id="82fd6cd237e491604315526b684dbfedf391a053" translate="yes" xml:space="preserve">
          <source>The implementation of the &lt;a href=&quot;-mutable-set/index#kotlin.collections.MutableSet&quot;&gt;MutableSet&lt;/a&gt; interface, backed by a &lt;a href=&quot;-hash-map/index#kotlin.collections.HashMap&quot;&gt;HashMap&lt;/a&gt; instance.</source>
          <target state="translated">&lt;a href=&quot;-hash-map/index#kotlin.collections.HashMap&quot;&gt;HashMap&lt;/a&gt; 인스턴스가 지원 하는 &lt;a href=&quot;-mutable-set/index#kotlin.collections.MutableSet&quot;&gt;MutableSet&lt;/a&gt; 인터페이스 의 구현입니다 .</target>
        </trans-unit>
        <trans-unit id="6ba732549bab36d600a33b057cb1445e14d3cdfc" translate="yes" xml:space="preserve">
          <source>The implementation of the &lt;a href=&quot;-mutable-set/index#kotlin.collections.MutableSet&quot;&gt;MutableSet&lt;/a&gt; interface, backed by a &lt;a href=&quot;-linked-hash-map/index#kotlin.collections.LinkedHashMap&quot;&gt;LinkedHashMap&lt;/a&gt; instance.</source>
          <target state="translated">&lt;a href=&quot;-linked-hash-map/index#kotlin.collections.LinkedHashMap&quot;&gt;LinkedHashMap&lt;/a&gt; 인스턴스가 지원 하는 &lt;a href=&quot;-mutable-set/index#kotlin.collections.MutableSet&quot;&gt;MutableSet&lt;/a&gt; 인터페이스 의 구현입니다 .</target>
        </trans-unit>
        <trans-unit id="e80ec37934bbec50821c43bd38cce1238a634038" translate="yes" xml:space="preserve">
          <source>The implementation of the &lt;a href=&quot;../-mutable-set/index#kotlin.collections.MutableSet&quot;&gt;MutableSet&lt;/a&gt; interface, backed by a &lt;a href=&quot;../-hash-map/index#kotlin.collections.HashMap&quot;&gt;HashMap&lt;/a&gt; instance.</source>
          <target state="translated">&lt;a href=&quot;../-hash-map/index#kotlin.collections.HashMap&quot;&gt;HashMap&lt;/a&gt; 인스턴스가 지원 하는 &lt;a href=&quot;../-mutable-set/index#kotlin.collections.MutableSet&quot;&gt;MutableSet&lt;/a&gt; 인터페이스 의 구현입니다 .</target>
        </trans-unit>
        <trans-unit id="9ab2ec2a4f2966a3555f9fce9c9ee7c196c5adc8" translate="yes" xml:space="preserve">
          <source>The implementation of the &lt;a href=&quot;../-mutable-set/index#kotlin.collections.MutableSet&quot;&gt;MutableSet&lt;/a&gt; interface, backed by a &lt;a href=&quot;../-linked-hash-map/index#kotlin.collections.LinkedHashMap&quot;&gt;LinkedHashMap&lt;/a&gt; instance.</source>
          <target state="translated">&lt;a href=&quot;../-linked-hash-map/index#kotlin.collections.LinkedHashMap&quot;&gt;LinkedHashMap&lt;/a&gt; 인스턴스가 지원 하는 &lt;a href=&quot;../-mutable-set/index#kotlin.collections.MutableSet&quot;&gt;MutableSet&lt;/a&gt; 인터페이스 의 구현입니다 .</target>
        </trans-unit>
        <trans-unit id="41ae2cd6b24e4bafa0efb17c582aa2f3dbd61174" translate="yes" xml:space="preserve">
          <source>The implementation of the &lt;a href=&quot;../../kotlin.collections/-mutable-set/index#kotlin.collections.MutableSet&quot;&gt;MutableSet&lt;/a&gt; interface, backed by a &lt;a href=&quot;../../kotlin.collections/-hash-map/index#kotlin.collections.HashMap&quot;&gt;HashMap&lt;/a&gt; instance.</source>
          <target state="translated">&lt;a href=&quot;../../kotlin.collections/-hash-map/index#kotlin.collections.HashMap&quot;&gt;HashMap&lt;/a&gt; 인스턴스가 지원 하는 &lt;a href=&quot;../../kotlin.collections/-mutable-set/index#kotlin.collections.MutableSet&quot;&gt;MutableSet&lt;/a&gt; 인터페이스 의 구현입니다 .</target>
        </trans-unit>
        <trans-unit id="b29deea1bb921913df3a5fadba5cd74a8f4acd5e" translate="yes" xml:space="preserve">
          <source>The implementation of the &lt;a href=&quot;../../kotlin.collections/-mutable-set/index#kotlin.collections.MutableSet&quot;&gt;MutableSet&lt;/a&gt; interface, backed by a &lt;a href=&quot;../../kotlin.collections/-linked-hash-map/index#kotlin.collections.LinkedHashMap&quot;&gt;LinkedHashMap&lt;/a&gt; instance.</source>
          <target state="translated">&lt;a href=&quot;../../kotlin.collections/-linked-hash-map/index#kotlin.collections.LinkedHashMap&quot;&gt;LinkedHashMap&lt;/a&gt; 인스턴스가 지원 하는 &lt;a href=&quot;../../kotlin.collections/-mutable-set/index#kotlin.collections.MutableSet&quot;&gt;MutableSet&lt;/a&gt; 인터페이스 의 구현입니다 .</target>
        </trans-unit>
        <trans-unit id="a6579034caa6bf530c44ba48e1557ccf3e4b94a3" translate="yes" xml:space="preserve">
          <source>The implementation of the &lt;a href=&quot;index#kotlin.collections.MutableSet&quot;&gt;MutableSet&lt;/a&gt; interface, backed by a &lt;a href=&quot;../-hash-map/index#kotlin.collections.HashMap&quot;&gt;HashMap&lt;/a&gt; instance.</source>
          <target state="translated">&lt;a href=&quot;../-hash-map/index#kotlin.collections.HashMap&quot;&gt;HashMap&lt;/a&gt; 인스턴스가 지원 하는 &lt;a href=&quot;index#kotlin.collections.MutableSet&quot;&gt;MutableSet&lt;/a&gt; 인터페이스 의 구현입니다 .</target>
        </trans-unit>
        <trans-unit id="a009a3a444f03e70f059b3c04a3a49cc825d720d" translate="yes" xml:space="preserve">
          <source>The implementation of the &lt;a href=&quot;index#kotlin.collections.MutableSet&quot;&gt;MutableSet&lt;/a&gt; interface, backed by a &lt;a href=&quot;../-linked-hash-map/index#kotlin.collections.LinkedHashMap&quot;&gt;LinkedHashMap&lt;/a&gt; instance.</source>
          <target state="translated">&lt;a href=&quot;../-linked-hash-map/index#kotlin.collections.LinkedHashMap&quot;&gt;LinkedHashMap&lt;/a&gt; 인스턴스가 지원 하는 &lt;a href=&quot;index#kotlin.collections.MutableSet&quot;&gt;MutableSet&lt;/a&gt; 인터페이스 의 구현입니다 .</target>
        </trans-unit>
        <trans-unit id="fa50aaadf0215e23e542746cdfa2658460833341" translate="yes" xml:space="preserve">
          <source>The implementor is required to implement &lt;a href=&quot;../-map/entries#kotlin.collections.Map%24entries&quot;&gt;entries&lt;/a&gt; property, which should return read-only set of map entries.</source>
          <target state="translated">구현자는 &lt;a href=&quot;../-map/entries#kotlin.collections.Map%24entries&quot;&gt;항목&lt;/a&gt; 속성 을 구현 해야하며, 읽기 전용 맵 항목 세트를 리턴해야합니다.</target>
        </trans-unit>
        <trans-unit id="0d9844010488cdb05175b5fbda28866913c16552" translate="yes" xml:space="preserve">
          <source>The implementor is required to implement &lt;a href=&quot;../-mutable-map/entries#kotlin.collections.MutableMap%24entries&quot;&gt;entries&lt;/a&gt; property, which should return mutable set of map entries, and &lt;a href=&quot;put#kotlin.collections.AbstractMutableMap%24put%28kotlin.collections.AbstractMutableMap.K%2C+kotlin.collections.AbstractMutableMap.V%29&quot;&gt;put&lt;/a&gt; function.</source>
          <target state="translated">구현자는 &lt;a href=&quot;../-mutable-map/entries#kotlin.collections.MutableMap%24entries&quot;&gt;항목&lt;/a&gt; 속성 을 구현 해야하며,이 속성은 변경 가능한 맵 항목 집합을 반환하고 함수를 &lt;a href=&quot;put#kotlin.collections.AbstractMutableMap%24put%28kotlin.collections.AbstractMutableMap.K%2C+kotlin.collections.AbstractMutableMap.V%29&quot;&gt;넣어야&lt;/a&gt; 합니다.</target>
        </trans-unit>
        <trans-unit id="b072b8461d749216f126589f253d2136dcee5a49" translate="yes" xml:space="preserve">
          <source>The implementor is required to implement &lt;a href=&quot;entries&quot;&gt;entries&lt;/a&gt; property, which should return mutable set of map entries, and &lt;a href=&quot;put#kotlin.collections.AbstractMutableMap%24put%28kotlin.collections.AbstractMutableMap.K%2C+kotlin.collections.AbstractMutableMap.V%29&quot;&gt;put&lt;/a&gt; function.</source>
          <target state="translated">구현자는 &lt;a href=&quot;entries&quot;&gt;항목&lt;/a&gt; 속성 을 구현 해야하며,이 속성은 변경 가능한 맵 항목 집합을 반환하고 함수를 &lt;a href=&quot;put#kotlin.collections.AbstractMutableMap%24put%28kotlin.collections.AbstractMutableMap.K%2C+kotlin.collections.AbstractMutableMap.V%29&quot;&gt;넣어야&lt;/a&gt; 합니다.</target>
        </trans-unit>
        <trans-unit id="b4d84ada0a069eb9728359000c31d5443cb7fe8c" translate="yes" xml:space="preserve">
          <source>The in-place sorting functions have similar names to the functions that apply to read-only lists, but without the &lt;code&gt;ed/d&lt;/code&gt; suffix:</source>
          <target state="translated">전체 정렬 기능은 읽기 전용 목록에 적용되지만 &lt;code&gt;ed/d&lt;/code&gt; 접미사가 없는 기능과 이름이 비슷합니다 .</target>
        </trans-unit>
        <trans-unit id="ad88781015ab91e944a6d24ed6740d21e1a613c0" translate="yes" xml:space="preserve">
          <source>The indentation in front of the accessors is due to convention; like elsewhere in Kotlin, it has no syntactic significance. The compiler can tell which accessors belong to which properties because the only legal place for an accessor is immediately after the property declaration (and there can be at most one getter and one setter) - so you can't split the property declaration and the accessor declarations. However, the order of the accessors doesn't matter.</source>
          <target state="translated">접근 자 앞의 들여 쓰기는 컨벤션 때문입니다. 코 틀린의 다른 곳과 마찬가지로 구문상의 의미는 없습니다. 접근자는 접근자가 접근 할 수있는 유일한 법적 장소가 속성 선언 바로 뒤에 있기 때문에 어떤 접근자가 어떤 속성에 속하는지 알 수 있습니다 (최대 하나의 getter와 하나의 setter가있을 수 있음). 따라서 속성 선언과 접근자를 분리 할 수 ​​없습니다 선언. 그러나 접근 자의 순서는 중요하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="a438c4c204700f052b62784ad094f3d42692c3e5" translate="yes" xml:space="preserve">
          <source>The inheritors are used in &lt;a href=&quot;-contract-builder/index&quot;&gt;ContractBuilder&lt;/a&gt; to describe the contract of a function.</source>
          <target state="translated">상속자는 함수의 계약을 설명하기 위해 &lt;a href=&quot;-contract-builder/index&quot;&gt;ContractBuilder&lt;/a&gt; 에서 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="927c0a69730a98787dc84c53359365aef174d24b" translate="yes" xml:space="preserve">
          <source>The initializer, getter and setter are optional. Property type is optional if it can be inferred from the initializer (or from the getter return type, as shown below).</source>
          <target state="translated">이니셜 라이저, 게터 및 세터는 선택 사항입니다. 이니셜 라이저 (또는 아래에 표시된 게터 리턴 유형)에서 유추 할 수있는 경우 특성 유형은 선택 사항입니다.</target>
        </trans-unit>
        <trans-unit id="73ab217fa7b8d452fbb508f24860b5983aed819b" translate="yes" xml:space="preserve">
          <source>The insertion order is preserved by maintaining a doubly-linked list of all of its entries.</source>
          <target state="translated">삽입 순서는 모든 항목의 이중 연결 목록을 유지하여 유지됩니다.</target>
        </trans-unit>
        <trans-unit id="d2ac540734122ad9d9f148278a049a69e4049649" translate="yes" xml:space="preserve">
          <source>The instance of the object declaration, or &lt;code&gt;null&lt;/code&gt; if this class is not an object declaration.</source>
          <target state="translated">객체 선언의 인스턴스. 이 클래스가 객체 선언이 아닌 경우는 &lt;code&gt;null&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="4e1a88c47519272f4d061661530035978afeff04" translate="yes" xml:space="preserve">
          <source>The interoperability tool analyses C headers and produces a &quot;natural&quot; mapping of the types, functions, and constants into the Kotlin world. The generated stubs can be imported into an IDE for the purpose of code completion and navigation.</source>
          <target state="translated">상호 운용성 도구는 C 헤더를 분석하고 유형, 함수 및 상수를 Kotlin 세계에 &quot;자연스럽게&quot;매핑합니다. 생성 된 스텁은 코드 완성 및 탐색을 위해 IDE로 가져올 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0c34ac28f0b47dc2a95569e5a72bbe09867d14d5" translate="yes" xml:space="preserve">
          <source>The kapt annotation processing tasks are not &lt;a href=&quot;https://guides.gradle.org/using-build-cache/&quot;&gt;cached in Gradle&lt;/a&gt; by default. Annotation processors run arbitrary code that may not necessarily transform the task inputs into the outputs, might access and modify the files that are not tracked by Gradle etc. To enable caching for kapt anyway, add the following lines to the build script:</source>
          <target state="translated">kapt 주석 처리 작업은 기본적으로 &lt;a href=&quot;https://guides.gradle.org/using-build-cache/&quot;&gt;Gradle&lt;/a&gt; 에 캐시 되지 않습니다 . 어노테이션 프로세서는 태스크 입력을 출력으로 변환 할 필요가없는 임의의 코드를 실행하고, Gradle 등에서 추적하지 않는 파일에 액세스하고 수정할 수 있습니다. 어쨌든 kapt에 대한 캐싱을 사용하려면 빌드 스크립트에 다음 행을 추가하십시오.</target>
        </trans-unit>
        <trans-unit id="0d265db62daefe24281a53daa642fa0260c64977" translate="yes" xml:space="preserve">
          <source>The key benefit of using sealed classes comes into play when you use them in a &lt;a href=&quot;control-flow#when-expression&quot;&gt;&lt;code&gt;when&lt;/code&gt; expression&lt;/a&gt;. If it's possible to verify that the statement covers all cases, you don't need to add an &lt;code&gt;else&lt;/code&gt; clause to the statement. However, this works only if you use &lt;code&gt;when&lt;/code&gt; as an expression (using the result) and not as a statement.</source>
          <target state="translated">봉인 된 클래스를 사용하는 경우의 주요 이점은 &lt;a href=&quot;control-flow#when-expression&quot;&gt; &lt;code&gt;when&lt;/code&gt; expression&lt;/a&gt; 에서 사용할 때 사용됩니다 . 명령문이 모든 경우에 적용되는지 확인할 수 있으면 &lt;code&gt;else&lt;/code&gt; 절을 명령문 에 추가 할 필요가 없습니다 . 그러나 이것은 표현식이 아닌 결과 (결과 사용)로 사용할 &lt;code&gt;when&lt;/code&gt; 만 사용 됩니다 .</target>
        </trans-unit>
        <trans-unit id="60878e19d1626a7113513294279d9306ebdfd3af" translate="yes" xml:space="preserve">
          <source>The key differences to the old model are:</source>
          <target state="translated">이전 모델과의 주요 차이점은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="ba83743a7b4886ce5d922ef71ed4bc654a53eba4" translate="yes" xml:space="preserve">
          <source>The key for each element is provided by the &lt;a href=&quot;-grouping/key-of&quot;&gt;Grouping.keyOf&lt;/a&gt; function.</source>
          <target state="translated">각 요소의 키는 &lt;a href=&quot;-grouping/key-of&quot;&gt;Grouping.keyOf&lt;/a&gt; 함수에 의해 제공됩니다 .</target>
        </trans-unit>
        <trans-unit id="c7780b4923a988af8ea0601856ae08a944187203" translate="yes" xml:space="preserve">
          <source>The key new feature in Kotlin 1.1 is &lt;em&gt;coroutines&lt;/em&gt;, bringing the support of &lt;code&gt;async&lt;/code&gt;/&lt;code&gt;await&lt;/code&gt;, &lt;code&gt;yield&lt;/code&gt; and similar programming patterns. The key feature of Kotlin's design is that the implementation of coroutine execution is part of the libraries, not the language, so you aren't bound to any specific programming paradigm or concurrency library.</source>
          <target state="translated">Kotlin 1.1의 주요 새로운 기능은 코 &lt;em&gt;루틴&lt;/em&gt; 으로 &lt;code&gt;async&lt;/code&gt; / &lt;code&gt;await&lt;/code&gt; , &lt;code&gt;yield&lt;/code&gt; 및 유사한 프로그래밍 패턴을 지원합니다. 코 틀린 디자인의 주요 특징은 코 루틴 실행의 구현이 언어가 아닌 라이브러리의 일부이므로 특정 프로그래밍 패러다임 또는 동시성 라이브러리에 구속되지 않는다는 것입니다.</target>
        </trans-unit>
        <trans-unit id="255ddce16ff2d3386fde18744e92b0919a0c3dcd" translate="yes" xml:space="preserve">
          <source>The key that defines &lt;em&gt;the&lt;/em&gt; context interceptor.</source>
          <target state="translated">컨텍스트 인터셉터 를 정의 &lt;em&gt;하는&lt;/em&gt; 키입니다 .</target>
        </trans-unit>
        <trans-unit id="f78236335bddfda90f254cf18135e3e283c652aa" translate="yes" xml:space="preserve">
          <source>The key to understanding why this trick works is rather simple: if you can only &lt;strong&gt;take&lt;/strong&gt; items from a collection, then using a collection of &lt;code&gt;String&lt;/code&gt;s and reading &lt;code&gt;Object&lt;/code&gt;s from it is fine. Conversely, if you can only &lt;em&gt;put&lt;/em&gt; items into the collection, it's OK to take a collection of &lt;code&gt;Object&lt;/code&gt;s and put &lt;code&gt;String&lt;/code&gt;s into it: in Java we have &lt;code&gt;List&amp;lt;? super String&amp;gt;&lt;/code&gt; a &lt;strong&gt;supertype&lt;/strong&gt; of &lt;code&gt;List&amp;lt;Object&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">이 트릭이 작동하는 이유를 이해하는 열쇠는 다소 간단합니다. 컬렉션 에서만 항목을 &lt;strong&gt;가져올&lt;/strong&gt; 수 있다면 &lt;code&gt;String&lt;/code&gt; 컬렉션을 사용하고 &lt;code&gt;Object&lt;/code&gt; 에서 그것을 읽는 것이 좋습니다. 만 할 수 있다면 반대로 &lt;em&gt;넣어&lt;/em&gt; 컬렉션에 항목을, 그것의 확인 모음 취할 &lt;code&gt;Object&lt;/code&gt; 들 넣어 &lt;code&gt;String&lt;/code&gt; 그것으로들 : 자바 우리가 가지고있는 &lt;code&gt;List&amp;lt;? super String&amp;gt;&lt;/code&gt; &lt;strong&gt;슈퍼 타입&lt;/strong&gt; 의 &lt;code&gt;List&amp;lt;Object&amp;gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d05fefa144a9bfaff0069cb495aef5fbbe9dc415" translate="yes" xml:space="preserve">
          <source>The language settings are checked for consistency between source sets depending on each other. Namely, if &lt;code&gt;foo&lt;/code&gt; depends on &lt;code&gt;bar&lt;/code&gt;:</source>
          <target state="translated">언어 설정은 서로에 따라 소스 세트 간의 일관성을 검사합니다. 즉, &lt;code&gt;foo&lt;/code&gt; 가 &lt;code&gt;bar&lt;/code&gt; 에 의존하는 경우 :</target>
        </trans-unit>
        <trans-unit id="7ae80735e57bee13b52032eac31a1a1787272a8f" translate="yes" xml:space="preserve">
          <source>The language settings for a source set can be specified as follows:</source>
          <target state="translated">소스 세트의 언어 설정은 다음과 같이 지정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="fbaea25f697b924abdcdee8361823761cf7fe6eb" translate="yes" xml:space="preserve">
          <source>The language used to document Kotlin code (the equivalent of Java's JavaDoc) is called &lt;strong&gt;KDoc&lt;/strong&gt;. In its essence, KDoc combines JavaDoc's syntax for block tags (extended to support Kotlin's specific constructs) and Markdown for inline markup.</source>
          <target state="translated">Kotlin 코드 (Java의 JavaDoc에 해당)를 문서화하는 데 사용되는 언어를 &lt;strong&gt;KDoc&lt;/strong&gt; 이라고 &lt;strong&gt;합니다&lt;/strong&gt; . 본질적으로 KDoc은 블록 태그에 대한 JavaDoc의 구문 (Kotlin의 특정 구성을 지원하도록 확장 됨)과 인라인 마크 업에 대한 Markdown을 결합합니다.</target>
        </trans-unit>
        <trans-unit id="6bd524ff724eae23548f42d94d576b7a82d79f24" translate="yes" xml:space="preserve">
          <source>The last element in the progression.</source>
          <target state="translated">진행의 마지막 요소.</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
