<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="redis">
    <body>
      <group id="redis">
        <trans-unit id="d090ece0f6a013c7b127d821779608185c9bdd43" translate="yes" xml:space="preserve">
          <source>&quot;master&quot;</source>
          <target state="translated">&quot;master&quot;</target>
        </trans-unit>
        <trans-unit id="6d0ace2f2b4d75b2aa62e7e81cf28ea7b27257b2" translate="yes" xml:space="preserve">
          <source>&quot;sentinel&quot;</source>
          <target state="translated">&quot;sentinel&quot;</target>
        </trans-unit>
        <trans-unit id="b7b37b37a23f19943025621e89ffee17065c89ed" translate="yes" xml:space="preserve">
          <source>&quot;slave&quot;</source>
          <target state="translated">&quot;slave&quot;</target>
        </trans-unit>
        <trans-unit id="d66b9359c4d9858484686c0c6a5bcc4c1dcb97a8" translate="yes" xml:space="preserve">
          <source>&amp;copy; 2009&amp;ndash;2018 Salvatore Sanfilippo</source>
          <target state="translated">&amp;copy; 2009&amp;ndash;2018 살바토레 산 필리포</target>
        </trans-unit>
        <trans-unit id="61ecfe6c066ed9ce69b42cf0699ab184e502a6d4" translate="yes" xml:space="preserve">
          <source>...continues until all replicas for this master are returned.</source>
          <target state="translated">...이 마스터의 모든 복제본이 반환 될 때까지 계속됩니다.</target>
        </trans-unit>
        <trans-unit id="cf13bcbd4a73014086e21ab38322f863e7ab7f8b" translate="yes" xml:space="preserve">
          <source>1 if at least 1 HyperLogLog internal register was altered. 0 otherwise.</source>
          <target state="translated">하나 이상의 HyperLogLog 내부 레지스터가 변경된 경우 1입니다. 그렇지 않으면 0입니다.</target>
        </trans-unit>
        <trans-unit id="298f6459896a7afbc1f87466fa10327589bc889f" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;bitfield&quot;&gt;BITFIELD&lt;/a&gt; is able to operate with multiple bit fields in the same command call. It takes a list of operations to perform, and returns an array of replies, where each array matches the corresponding operation in the list of arguments.</source>
          <target state="translated">&lt;a href=&quot;bitfield&quot;&gt;BITFIELD&lt;/a&gt; 는 동일한 명령 호출에서 여러 비트 필드로 작동 할 수 있습니다. 수행 할 연산 목록을 가져오고 응답 배열을 반환합니다. 여기서 각 배열은 인수 목록의 해당 연산과 일치합니다.</target>
        </trans-unit>
        <trans-unit id="1b7f3cd466d7da037528d2882227b821b5a2e2df" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;bitop&quot;&gt;BITOP&lt;/a&gt; is a good complement to the pattern documented in the &lt;a href=&quot;bitcount&quot;&gt;BITCOUNT&lt;/a&gt; command documentation. Different bitmaps can be combined in order to obtain a target bitmap where the population counting operation is performed.</source>
          <target state="translated">&lt;a href=&quot;bitop&quot;&gt;BITOP&lt;/a&gt; 은 &lt;a href=&quot;bitcount&quot;&gt;BITCOUNT&lt;/a&gt; 명령 문서에 문서화 된 패턴을 보완합니다 . 모집단 카운팅 연산이 수행되는 타겟 비트 맵을 얻기 위해 다른 비트 맵을 결합 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4ed9a216d74a14f4f5eef018eff2a38b5eb83d9b" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;bitop&quot;&gt;BITOP&lt;/a&gt; is a potentially slow command as it runs in O(N) time. Care should be taken when running it against long input strings.</source>
          <target state="translated">&lt;a href=&quot;bitop&quot;&gt;BITOP&lt;/a&gt; 은 O (N) 시간에 실행될 때 잠재적으로 느린 명령입니다. 긴 입력 문자열에 대해 실행할 때는주의해야합니다.</target>
        </trans-unit>
        <trans-unit id="47e5c8f772fa453430f8e2dfda323c8ba56c1212" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;blpop&quot;&gt;BLPOP&lt;/a&gt; can be used with pipelining (sending multiple commands and reading the replies in batch), however this setup makes sense almost solely when it is the last command of the pipeline.</source>
          <target state="translated">&lt;a href=&quot;blpop&quot;&gt;BLPOP&lt;/a&gt; 는 파이프 라이닝과 함께 사용할 수 있지만 (여러 명령을 보내고 일괄로 답장을 읽는) 파이프 라인의 마지막 명령 인 경우에만이 설정이 의미가 있습니다.</target>
        </trans-unit>
        <trans-unit id="2319353e1b072b97b15af4a1beffb4e2e32498aa" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;blpop&quot;&gt;BLPOP&lt;/a&gt; guarantees to return an element from the list stored at &lt;code&gt;list2&lt;/code&gt; (since it is the first non empty list when checking &lt;code&gt;list1&lt;/code&gt;, &lt;code&gt;list2&lt;/code&gt; and &lt;code&gt;list3&lt;/code&gt; in that order).</source>
          <target state="translated">&lt;a href=&quot;blpop&quot;&gt;BLPOP&lt;/a&gt; 는 &lt;code&gt;list2&lt;/code&gt; 에 저장된 목록에서 요소를 리턴합니다 ( &lt;code&gt;list1&lt;/code&gt; , &lt;code&gt;list2&lt;/code&gt; 및 &lt;code&gt;list3&lt;/code&gt; 을 순서대로 점검 할 때 비어 있지 않은 첫 번째 목록 이므로 ).</target>
        </trans-unit>
        <trans-unit id="9f9dd7463402ad47ace1ee92bce2eb9098a0cd4c" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;blpop&quot;&gt;BLPOP&lt;/a&gt; is a blocking list pop primitive. It is the blocking version of &lt;a href=&quot;lpop&quot;&gt;LPOP&lt;/a&gt; because it blocks the connection when there are no elements to pop from any of the given lists. An element is popped from the head of the first list that is non-empty, with the given keys being checked in the order that they are given.</source>
          <target state="translated">&lt;a href=&quot;blpop&quot;&gt;BLPOP&lt;/a&gt; 은 차단 목록 팝 프리미티브입니다. 주어진 목록에서 팝업 할 요소가 없을 때 연결을 차단하기 때문에 &lt;a href=&quot;lpop&quot;&gt;LPOP&lt;/a&gt; 의 차단 버전입니다 . 비어 있지 않은 첫 번째 목록의 헤드에서 요소가 팝업되고 주어진 키는 주어진 순서대로 검사됩니다.</target>
        </trans-unit>
        <trans-unit id="1b5186ef40193c51e3a6132e8e6cee5cf1ac30d2" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;brpop&quot;&gt;BRPOP&lt;/a&gt; is a blocking list pop primitive. It is the blocking version of &lt;a href=&quot;rpop&quot;&gt;RPOP&lt;/a&gt; because it blocks the connection when there are no elements to pop from any of the given lists. An element is popped from the tail of the first list that is non-empty, with the given keys being checked in the order that they are given.</source>
          <target state="translated">&lt;a href=&quot;brpop&quot;&gt;BRPOP&lt;/a&gt; 는 차단 목록 팝 프리미티브입니다. 주어진 목록에서 팝업 할 요소가 없을 때 연결을 차단하기 때문에 &lt;a href=&quot;rpop&quot;&gt;RPOP&lt;/a&gt; 의 차단 버전입니다 . 비어 있지 않은 첫 번째 목록의 꼬리에서 요소가 팝업되고 주어진 키는 주어진 순서대로 검사됩니다.</target>
        </trans-unit>
        <trans-unit id="f82e1fe35cdb39003f0819a756148b419f89ffdd" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;brpoplpush&quot;&gt;BRPOPLPUSH&lt;/a&gt; is the blocking variant of &lt;a href=&quot;rpoplpush&quot;&gt;RPOPLPUSH&lt;/a&gt;. When &lt;code&gt;source&lt;/code&gt; contains elements, this command behaves exactly like &lt;a href=&quot;rpoplpush&quot;&gt;RPOPLPUSH&lt;/a&gt;. When used inside a &lt;a href=&quot;multi&quot;&gt;MULTI&lt;/a&gt;/&lt;a href=&quot;exec&quot;&gt;EXEC&lt;/a&gt; block, this command behaves exactly like &lt;a href=&quot;rpoplpush&quot;&gt;RPOPLPUSH&lt;/a&gt;. When &lt;code&gt;source&lt;/code&gt; is empty, Redis will block the connection until another client pushes to it or until &lt;code&gt;timeout&lt;/code&gt; is reached. A &lt;code&gt;timeout&lt;/code&gt; of zero can be used to block indefinitely.</source>
          <target state="translated">&lt;a href=&quot;brpoplpush&quot;&gt;BRPOPLPUSH은&lt;/a&gt; 의 차단 변종이다 &lt;a href=&quot;rpoplpush&quot;&gt;RPOPLPUSH&lt;/a&gt; . 때 &lt;code&gt;source&lt;/code&gt; 요소를 포함,이 명령은 정확히처럼 동작 &lt;a href=&quot;rpoplpush&quot;&gt;RPOPLPUSH&lt;/a&gt; . &lt;a href=&quot;multi&quot;&gt;MULTI&lt;/a&gt; / &lt;a href=&quot;exec&quot;&gt;EXEC&lt;/a&gt; 블록 내에서 사용되는 경우이 명령은 &lt;a href=&quot;rpoplpush&quot;&gt;RPOPLPUSH&lt;/a&gt; 와 똑같이 동작합니다 . 때 &lt;code&gt;source&lt;/code&gt; 비어있는 다른 클라이언트가 그것을 밀어 때까지 또는 때까지, 레디 스 연결을 차단합니다 &lt;code&gt;timeout&lt;/code&gt; 에 도달 할 때. &lt;code&gt;timeout&lt;/code&gt; 제로 무기한 차단하는데 사용될 수있다.</target>
        </trans-unit>
        <trans-unit id="57d1c58be2dfe8693b8c49b117f3415d9a5dcc26" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;bzpopmax&quot;&gt;BZPOPMAX&lt;/a&gt; is the blocking variant of the sorted set &lt;a href=&quot;zpopmax&quot;&gt;ZPOPMAX&lt;/a&gt; primitive.</source>
          <target state="translated">&lt;a href=&quot;bzpopmax&quot;&gt;BZPOPMAX&lt;/a&gt; 는 정렬 된 세트 &lt;a href=&quot;zpopmax&quot;&gt;ZPOPMAX&lt;/a&gt; 프리미티브 의 차단 변형입니다 .</target>
        </trans-unit>
        <trans-unit id="89f44ec462a3787eaa4a4b4bb72b8ffb30247ee1" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;bzpopmin&quot;&gt;BZPOPMIN&lt;/a&gt; is the blocking variant of the sorted set &lt;a href=&quot;zpopmin&quot;&gt;ZPOPMIN&lt;/a&gt; primitive.</source>
          <target state="translated">&lt;a href=&quot;bzpopmin&quot;&gt;BZPOPMIN&lt;/a&gt; 은 정렬 된 세트 &lt;a href=&quot;zpopmin&quot;&gt;ZPOPMIN&lt;/a&gt; 프리미티브 의 차단 변형입니다 .</target>
        </trans-unit>
        <trans-unit id="5b5fc75fc0e41fd8f7844da4c69a1874efe94876" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;client-pause&quot;&gt;CLIENT PAUSE&lt;/a&gt; is a connections control command able to suspend all the Redis clients for the specified amount of time (in milliseconds).</source>
          <target state="translated">&lt;a href=&quot;client-pause&quot;&gt;CLIENT PAUSE&lt;/a&gt; 는 모든 Redis 클라이언트를 지정된 시간 (밀리 초) 동안 일시 중단 할 수있는 연결 제어 명령입니다.</target>
        </trans-unit>
        <trans-unit id="5820f212e9cdbffad80c4b3ec9e06f08a87839b9" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;cluster-failover&quot;&gt;CLUSTER FAILOVER&lt;/a&gt;, unless the &lt;strong&gt;TAKEOVER&lt;/strong&gt; option is specified, does not execute a failover synchronously, it only &lt;em&gt;schedules&lt;/em&gt; a manual failover, bypassing the failure detection stage, so to check if the failover actually happened, &lt;a href=&quot;cluster-nodes&quot;&gt;CLUSTER NODES&lt;/a&gt; or other means should be used in order to verify that the state of the cluster changes after some time the command was sent.</source>
          <target state="translated">&lt;a href=&quot;cluster-failover&quot;&gt;&lt;/a&gt;&lt;strong&gt;TAKEOVER&lt;/strong&gt; 옵션이 지정 되지 않은 경우 CLUSTER FAILOVER 는 동 기적으로 장애 조치를 실행하지 않으며 장애 감지 단계를 우회하여 수동 장애 조치 만 &lt;em&gt;예약&lt;/em&gt; 하므로 장애 조치가 실제로 발생했는지 확인하려면 &lt;a href=&quot;cluster-nodes&quot;&gt;CLUSTER NODES&lt;/a&gt; 또는 기타 수단을 사용해야합니다. 명령이 전송 된 후 클러스터 상태가 변경되는지 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="6df93f3c2cb3628be7571750bc31c359721a8a9c" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;cluster-info&quot;&gt;CLUSTER INFO&lt;/a&gt; provides &lt;a href=&quot;info&quot;&gt;INFO&lt;/a&gt; style information about Redis Cluster vital parameters. The following is a sample output, followed by the description of each field reported.</source>
          <target state="translated">&lt;a href=&quot;cluster-info&quot;&gt;CLUSTER INFO&lt;/a&gt; 는 Redis Cluster 필수 매개 변수에 대한 &lt;a href=&quot;info&quot;&gt;정보&lt;/a&gt; 스타일 정보를 제공합니다 . 다음은 샘플 출력이며보고 된 각 필드에 대한 설명입니다.</target>
        </trans-unit>
        <trans-unit id="05ab0833266a0e2d56f9bd65726d840ddd9f6d84" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;cluster-meet&quot;&gt;CLUSTER MEET&lt;/a&gt; is used in order to connect different Redis nodes with cluster support enabled, into a working cluster.</source>
          <target state="translated">&lt;a href=&quot;cluster-meet&quot;&gt;CLUSTER MEET&lt;/a&gt; 은 클러스터 지원이 활성화 된 다른 Redis 노드를 작업 클러스터에 연결하기 위해 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="2be70c2d8fbab0d9533c8651810517def1e38f87" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;cluster-nodes&quot;&gt;CLUSTER NODES&lt;/a&gt; provides all this information, that is, the current cluster configuration of the node we are contacting, in a serialization format which happens to be exactly the same as the one used by Redis Cluster itself in order to store on disk the cluster state (however the on disk cluster state has a few additional info appended at the end).</source>
          <target state="translated">&lt;a href=&quot;cluster-nodes&quot;&gt;CLUSTER NODES&lt;/a&gt; 는 디스크에 클러스터 상태를 저장하기 위해 Redis Cluster 자체에서 사용 된 것과 정확히 동일한 직렬화 형식으로이 모든 정보, 즉 현재 접속중인 노드의 현재 클러스터 구성을 제공합니다 ( 그러나 온 디스크 클러스터 상태에는 끝에 몇 가지 추가 정보가 추가됩니다.</target>
        </trans-unit>
        <trans-unit id="5a7b2b87d6fc55591b930de028a9b09209730fd9" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;cluster-setslot&quot;&gt;CLUSTER SETSLOT&lt;/a&gt; is responsible of changing the state of a hash slot in the receiving node in different ways. It can, depending on the subcommand used:</source>
          <target state="translated">&lt;a href=&quot;cluster-setslot&quot;&gt;CLUSTER SETSLOT&lt;/a&gt; 은 수신 노드의 해시 슬롯 상태를 다른 방식으로 변경합니다. 사용 된 부속 명령에 따라 다음이 가능합니다.</target>
        </trans-unit>
        <trans-unit id="080c815556a18dd5b20cfbbccaeb8a1a935316bb" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;cluster-slots&quot;&gt;CLUSTER SLOTS&lt;/a&gt; returns details about which cluster slots map to which Redis instances. The command is suitable to be used by Redis Cluster client libraries implementations in order to retrieve (or update when a redirection is received) the map associating cluster &lt;em&gt;hash slots&lt;/em&gt; with actual nodes network coordinates (composed of an IP address and a TCP port), so that when a command is received, it can be sent to what is likely the right instance for the keys specified in the command.</source>
          <target state="translated">&lt;a href=&quot;cluster-slots&quot;&gt;CLUSTER SLOTS&lt;/a&gt; 는 어떤 클러스터 슬롯이 어떤 Redis 인스턴스에 매핑되는지에 대한 세부 정보를 반환합니다. 이 명령은 Redis Cluster 클라이언트 라이브러리 구현에서 클러스터 &lt;em&gt;해시 슬롯&lt;/em&gt; 과 실제 노드 네트워크 좌표 (IP 주소 및 TCP 포트로 구성된)를 연결하는 맵을 검색 (또는 리디렉션 수신시 업데이트)하기 위해 사용하기에 적합합니다. 명령이 수신되면 명령에 지정된 키에 적합한 인스턴스로 전송 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="eea3660efa2741840d4e14948a3daf43aa7906c8" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;command&quot;&gt;COMMAND&lt;/a&gt; shows some commands as having movablekeys meaning the entire command must be parsed to discover storage or retrieval keys. You can use &lt;a href=&quot;command-getkeys&quot;&gt;COMMAND GETKEYS&lt;/a&gt; to discover key positions directly from how Redis parses the commands.</source>
          <target state="translated">&lt;a href=&quot;command&quot;&gt;COMMAND&lt;/a&gt; 는 일부 명령이 움직일 수있는 키를 가지고 있음을 나타내며, 이는 스토리지 또는 검색 키를 발견하기 위해 전체 명령을 구문 분석해야 함을 의미합니다. &lt;a href=&quot;command-getkeys&quot;&gt;명령 GETKEYS&lt;/a&gt; 를 사용 하여 Redis가 명령을 구문 분석하는 방법에서 직접 키 위치를 발견 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="489bd986cf60a756e680223a682de091c3116fb2" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;command-getkeys&quot;&gt;COMMAND GETKEYS&lt;/a&gt; is a helper command to let you find the keys from a full Redis command.</source>
          <target state="translated">&lt;a href=&quot;command-getkeys&quot;&gt;COMMAND GETKEYS&lt;/a&gt; 는 전체 Redis 명령에서 키를 찾을 수있는 도우미 명령입니다.</target>
        </trans-unit>
        <trans-unit id="681416ad79c51f0113f1b0bbdfdbc89c2034be1b" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;config-get&quot;&gt;CONFIG GET&lt;/a&gt; takes a single argument, which is a glob-style pattern. All the configuration parameters matching this parameter are reported as a list of key-value pairs. Example:</source>
          <target state="translated">&lt;a href=&quot;config-get&quot;&gt;CONFIG GET&lt;/a&gt; 은 glob-style 패턴 인 단일 인수를 취합니다. 이 매개 변수와 일치하는 모든 구성 매개 변수는 키-값 쌍의 목록으로보고됩니다. 예:</target>
        </trans-unit>
        <trans-unit id="8b942248ff5e8e632605cf7a19322b0ffb3e9835" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;debug-object&quot;&gt;DEBUG OBJECT&lt;/a&gt; is a debugging command that should not be used by clients. Check the &lt;a href=&quot;object&quot;&gt;OBJECT&lt;/a&gt; command instead.</source>
          <target state="translated">&lt;a href=&quot;debug-object&quot;&gt;DEBUG OBJECT&lt;/a&gt; 는 클라이언트가 사용해서는 안되는 디버깅 명령입니다. 대신 &lt;a href=&quot;object&quot;&gt;OBJECT&lt;/a&gt; 명령을 확인하십시오 .</target>
        </trans-unit>
        <trans-unit id="4b0f626c24491b9a0ccd5da6245ddfb0a8879f1a" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;debug-segfault&quot;&gt;DEBUG SEGFAULT&lt;/a&gt; performs an invalid memory access that crashes Redis. It is used to simulate bugs during the development.</source>
          <target state="translated">&lt;a href=&quot;debug-segfault&quot;&gt;DEBUG SEGFAULT&lt;/a&gt; 는 Redis와 충돌하는 잘못된 메모리 액세스를 수행합니다. 개발 중 버그를 시뮬레이션하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="c25cdfe60b47993881a3589eb4168954e3c90ccd" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;eval&quot;&gt;EVAL&lt;/a&gt; - keys stop after &lt;code&gt;numkeys&lt;/code&gt; count arguments</source>
          <target state="translated">&lt;a href=&quot;eval&quot;&gt;EVAL&lt;/a&gt; - &lt;code&gt;numkeys&lt;/code&gt; 가 인수를 세면 키가 멈춤</target>
        </trans-unit>
        <trans-unit id="32d306a1a945899d65731db124247cb2119ca3b4" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;eval&quot;&gt;EVAL&lt;/a&gt; and &lt;a href=&quot;evalsha&quot;&gt;EVALSHA&lt;/a&gt; are used to evaluate scripts using the Lua interpreter built into Redis starting from version 2.6.0.</source>
          <target state="translated">&lt;a href=&quot;eval&quot;&gt;EVAL&lt;/a&gt; 및 &lt;a href=&quot;evalsha&quot;&gt;EVALSHA&lt;/a&gt; 는 버전 2.6.0부터 Redis에 내장 된 Lua 인터프리터를 사용하여 스크립트를 평가하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="76dd713830729401bdb73704c6477a3b6aee8c2f" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;evalsha&quot;&gt;EVALSHA&lt;/a&gt; - keys stop after &lt;code&gt;numkeys&lt;/code&gt; count arguments</source>
          <target state="translated">&lt;a href=&quot;evalsha&quot;&gt;EVALSHA-숫자&lt;/a&gt; 키가 인수를 계산 한 후 키가 &lt;code&gt;numkeys&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="f93b232f51da9eb1b0852dab05bb4e62e22f401f" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;evalsha&quot;&gt;EVALSHA&lt;/a&gt; works exactly like &lt;a href=&quot;eval&quot;&gt;EVAL&lt;/a&gt;, but instead of having a script as the first argument it has the SHA1 digest of a script. The behavior is the following:</source>
          <target state="translated">&lt;a href=&quot;evalsha&quot;&gt;EVALSHA&lt;/a&gt; 는 &lt;a href=&quot;eval&quot;&gt;EVAL&lt;/a&gt; 과 똑같이 작동 하지만 스크립트를 첫 번째 인수로 사용하는 대신 스크립트의 SHA1 다이제스트가 있습니다. 동작은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="6cfd0087ee88c2ae24709966db61c0e7ac6c4b5d" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;expire&quot;&gt;EXPIRE&lt;/a&gt; would return 0 and not alter the timeout for a key with a timeout set.</source>
          <target state="translated">&lt;a href=&quot;expire&quot;&gt;EXPIRE&lt;/a&gt; 는 0을 반환하고 시간 초과가 설정된 키의 시간 초과를 변경하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="1705d38419159cca69bb08cf5dadf8c85b8a1f53" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;expireat&quot;&gt;EXPIREAT&lt;/a&gt; has the same effect and semantic as &lt;a href=&quot;expire&quot;&gt;EXPIRE&lt;/a&gt;, but instead of specifying the number of seconds representing the TTL (time to live), it takes an absolute &lt;a href=&quot;http://en.wikipedia.org/wiki/Unix_time&quot;&gt;Unix timestamp&lt;/a&gt; (seconds since January 1, 1970). A timestamp in the past will delete the key immediately.</source>
          <target state="translated">&lt;a href=&quot;expireat&quot;&gt;EXPIREAT&lt;/a&gt; 는 &lt;a href=&quot;expire&quot;&gt;EXPIRE&lt;/a&gt; 와 효과 및 의미가 동일 하지만 TTL (Time to Live)을 나타내는 초 수를 지정하는 대신 절대 &lt;a href=&quot;http://en.wikipedia.org/wiki/Unix_time&quot;&gt;Unix 타임 스탬프&lt;/a&gt; (1970 년 1 월 1 일 이후의 초)를 사용합니다. 과거의 타임 스탬프는 키를 즉시 삭제합니다.</target>
        </trans-unit>
        <trans-unit id="c00a508fcaefc4b21a2a57ab333e66a1842a7ec0" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;expireat&quot;&gt;EXPIREAT&lt;/a&gt; was introduced in order to convert relative timeouts to absolute timeouts for the AOF persistence mode. Of course, it can be used directly to specify that a given key should expire at a given time in the future.</source>
          <target state="translated">&lt;a href=&quot;expireat&quot;&gt;EXPIREAT&lt;/a&gt; 는 AOF 지속성 모드에서 상대 시간 초과를 절대 시간 초과로 변환하기 위해 도입되었습니다. 물론, 주어진 키가 미래에 주어진 시간에 만료되도록 지정하는 데 직접 사용될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0256948e937135d52eae78e100f423a41272e11e" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;get&quot;&gt;GET&lt;/a&gt; arity is 2 since the command only accepts one argument and always has the format &lt;code&gt;GET _key_&lt;/code&gt;.</source>
          <target state="translated">&lt;a href=&quot;get&quot;&gt;&lt;/a&gt;명령은 하나의 인수 만 허용하며 항상 &lt;code&gt;GET _key_&lt;/code&gt; 형식을 갖기 때문에 GET arity는 2 입니다.</target>
        </trans-unit>
        <trans-unit id="862f58acc6739ebcc65838489eb263ecdd265462" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;getrange&quot;&gt;GETRANGE&lt;/a&gt; allows for random access of elements. If our time series have associated time information we can easily implement a binary search to get range combining &lt;a href=&quot;getrange&quot;&gt;GETRANGE&lt;/a&gt; with the Lua scripting engine available in Redis 2.6.</source>
          <target state="translated">&lt;a href=&quot;getrange&quot;&gt;GETRANGE&lt;/a&gt; 는 요소에 무작위로 액세스 할 수 있습니다. 시계열에 시간 정보가 연결되어 있으면 &lt;a href=&quot;getrange&quot;&gt;GETRANGE&lt;/a&gt; 와 Redis 2.6의 Lua 스크립팅 엔진을 결합한 범위를 얻기 위해 이진 검색을 쉽게 구현할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="ea9de69ea3ff19d06a0fe287a311dbf94bb30a68" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;getset&quot;&gt;GETSET&lt;/a&gt; can be used together with &lt;a href=&quot;incr&quot;&gt;INCR&lt;/a&gt; for counting with atomic reset. For example: a process may call &lt;a href=&quot;incr&quot;&gt;INCR&lt;/a&gt; against the key &lt;code&gt;mycounter&lt;/code&gt; every time some event occurs, but from time to time we need to get the value of the counter and reset it to zero atomically. This can be done using &lt;code&gt;GETSET mycounter &quot;0&quot;&lt;/code&gt;:</source>
          <target state="translated">&lt;a href=&quot;getset&quot;&gt;GETSET&lt;/a&gt; 은 원자 재설정으로 계산하기 위해 &lt;a href=&quot;incr&quot;&gt;INCR&lt;/a&gt; 과 함께 사용할 수 있습니다 . 예를 들어 , 어떤 이벤트가 발생할 때마다 프로세스가 키 &lt;code&gt;mycounter&lt;/code&gt; 에 대해 &lt;a href=&quot;incr&quot;&gt;INCR&lt;/a&gt; 을 호출 할 수 있지만 때때로 카운터 값을 얻어 원자 적으로 0으로 재설정해야합니다. &lt;code&gt;GETSET mycounter &quot;0&quot;&lt;/code&gt; 을 사용하여 수행 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="2a5cb3451bd35392828ae029ba52d4629724de6e" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;hscan&quot;&gt;HSCAN&lt;/a&gt; array of elements contain two elements, a field and a value, for every returned element of the Hash.</source>
          <target state="translated">&lt;a href=&quot;hscan&quot;&gt;HSCAN&lt;/a&gt; 요소 배열에는 해시의 모든 반환 요소에 대해 필드와 값의 두 가지 요소가 있습니다.</target>
        </trans-unit>
        <trans-unit id="01babade069e95b8d557b3e99aa3e3618353028b" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;hscan&quot;&gt;HSCAN&lt;/a&gt; iterates fields of Hash types and their associated values.</source>
          <target state="translated">&lt;a href=&quot;hscan&quot;&gt;HSCAN&lt;/a&gt; 은 해시 유형의 필드와 관련 값을 반복합니다.</target>
        </trans-unit>
        <trans-unit id="80a0ce1ddcb6cc2a005d75a343289ea68fbda569" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://redis.io/topics/protocol#array-reply&quot;&gt;Array reply&lt;/a&gt; The command returns an array of integers that correspond to the specified SHA1 digest arguments. For every corresponding SHA1 digest of a script that actually exists in the script cache, an 1 is returned, otherwise 0 is returned.</source>
          <target state="translated">&lt;a href=&quot;https://redis.io/topics/protocol#array-reply&quot;&gt;배열 응답&lt;/a&gt; 명령은 지정된 SHA1 다이제스트 인수에 해당하는 정수 배열을 반환합니다. 스크립트 캐시에 실제로 존재하는 스크립트의 모든 해당 SHA1 다이제스트에 대해 1이 리턴되고 그렇지 않으면 0이 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="486ba6315bca74f915f1d94b39f49b62d9fd7125" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://redis.io/topics/protocol#array-reply&quot;&gt;Array reply&lt;/a&gt;, specifically:</source>
          <target state="translated">&lt;a href=&quot;https://redis.io/topics/protocol#array-reply&quot;&gt;&lt;/a&gt;구체적으로 배열 응답 :</target>
        </trans-unit>
        <trans-unit id="a87373c78b3d488d21433e0636b5d549779ab143" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://redis.io/topics/protocol#array-reply&quot;&gt;Array reply&lt;/a&gt;: From 0 to &lt;em&gt;count&lt;/em&gt; key names in a Redis array reply.</source>
          <target state="translated">&lt;a href=&quot;https://redis.io/topics/protocol#array-reply&quot;&gt;배열 응답&lt;/a&gt; : 0부터 Redis 배열 응답의 키 이름 을 &lt;em&gt;계산&lt;/em&gt; 합니다.</target>
        </trans-unit>
        <trans-unit id="7c52429c4d95e074b8db21a25b8a8357d1a3b806" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://redis.io/topics/protocol#array-reply&quot;&gt;Array reply&lt;/a&gt;: a list of active channels, optionally matching the specified pattern.</source>
          <target state="translated">&lt;a href=&quot;https://redis.io/topics/protocol#array-reply&quot;&gt;Array reply&lt;/a&gt; : 지정된 패턴과 선택적으로 일치하는 활성 채널 목록.</target>
        </trans-unit>
        <trans-unit id="3018dbf10bce392168033eb0d2ea6d0a4a1f46cd" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://redis.io/topics/protocol#array-reply&quot;&gt;Array reply&lt;/a&gt;: a list of channels and number of subscribers for every channel. The format is channel, count, channel, count, ..., so the list is flat. The order in which the channels are listed is the same as the order of the channels specified in the command call.</source>
          <target state="translated">&lt;a href=&quot;https://redis.io/topics/protocol#array-reply&quot;&gt;배열 응답&lt;/a&gt; : 모든 채널의 채널 목록 및 가입자 수. 형식은 channel, count, channel, count, ...이므로 목록은 단순합니다. 채널이 나열되는 순서는 명령 호출에 지정된 채널의 순서와 동일합니다.</target>
        </trans-unit>
        <trans-unit id="63975dbc5ab6e11639a6a1c05d5503519f5e2e82" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://redis.io/topics/protocol#array-reply&quot;&gt;Array reply&lt;/a&gt;: a list of subcommands and their descriptions</source>
          <target state="translated">&lt;a href=&quot;https://redis.io/topics/protocol#array-reply&quot;&gt;배열 응답&lt;/a&gt; : 부속 명령 및 설명 목록</target>
        </trans-unit>
        <trans-unit id="d268864554befa38e947a1034b4c1845060a6854" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://redis.io/topics/protocol#array-reply&quot;&gt;Array reply&lt;/a&gt;: all elements of the set.</source>
          <target state="translated">&lt;a href=&quot;https://redis.io/topics/protocol#array-reply&quot;&gt;배열 응답&lt;/a&gt; : 세트의 모든 요소.</target>
        </trans-unit>
        <trans-unit id="055fe2adb91d8fcd05f658cfb380ba41915fd3ac" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://redis.io/topics/protocol#array-reply&quot;&gt;Array reply&lt;/a&gt;: each element being the reply to each of the commands in the atomic transaction.</source>
          <target state="translated">&lt;a href=&quot;https://redis.io/topics/protocol#array-reply&quot;&gt;배열 응답&lt;/a&gt; : 각 요소는 원자 트랜잭션의 각 명령에 대한 응답입니다.</target>
        </trans-unit>
        <trans-unit id="ee5ade4e24c570073b995a53e9ece62b6f69b7e5" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://redis.io/topics/protocol#array-reply&quot;&gt;Array reply&lt;/a&gt;: list of elements in the specified range (optionally with their scores).</source>
          <target state="translated">&lt;a href=&quot;https://redis.io/topics/protocol#array-reply&quot;&gt;배열 응답&lt;/a&gt; : 지정된 범위의 요소 목록 (선택적으로 점수가 있음).</target>
        </trans-unit>
        <trans-unit id="c1eed33826c722815ff11475933335e0c3b1e741" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://redis.io/topics/protocol#array-reply&quot;&gt;Array reply&lt;/a&gt;: list of elements in the specified range (optionally with their scores, in case the &lt;code&gt;WITHSCORES&lt;/code&gt; option is given).</source>
          <target state="translated">&lt;a href=&quot;https://redis.io/topics/protocol#array-reply&quot;&gt;배열 응답&lt;/a&gt; : 지정된 범위의 요소 목록 (선택적으로 &lt;code&gt;WITHSCORES&lt;/code&gt; 옵션이 지정된 경우 점수와 함께 ).</target>
        </trans-unit>
        <trans-unit id="bdc2ce41640e157fc2c6bd8b769566856e8c384e" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://redis.io/topics/protocol#array-reply&quot;&gt;Array reply&lt;/a&gt;: list of elements in the specified range.</source>
          <target state="translated">&lt;a href=&quot;https://redis.io/topics/protocol#array-reply&quot;&gt;배열 응답&lt;/a&gt; : 지정된 범위의 요소 목록.</target>
        </trans-unit>
        <trans-unit id="65037bdac60d86ed70fd9dd0699a49b8ac55e271" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://redis.io/topics/protocol#array-reply&quot;&gt;Array reply&lt;/a&gt;: list of elements in the specified score range (optionally with their scores).</source>
          <target state="translated">&lt;a href=&quot;https://redis.io/topics/protocol#array-reply&quot;&gt;배열 응답&lt;/a&gt; : 지정된 점수 범위의 요소 목록 (선택적으로 점수 포함).</target>
        </trans-unit>
        <trans-unit id="08afc65db9b918c7e1911260eaa2c288c7ffbe41" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://redis.io/topics/protocol#array-reply&quot;&gt;Array reply&lt;/a&gt;: list of elements in the specified score range.</source>
          <target state="translated">&lt;a href=&quot;https://redis.io/topics/protocol#array-reply&quot;&gt;배열 응답&lt;/a&gt; : 지정된 점수 범위의 요소 목록.</target>
        </trans-unit>
        <trans-unit id="759a296030fa2eac4a37ddf409f6484f614a8176" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://redis.io/topics/protocol#array-reply&quot;&gt;Array reply&lt;/a&gt;: list of fields and their values stored in the hash, or an empty list when &lt;code&gt;key&lt;/code&gt; does not exist.</source>
          <target state="translated">&lt;a href=&quot;https://redis.io/topics/protocol#array-reply&quot;&gt;배열 응답&lt;/a&gt; : 해시에 저장된 필드 및 값 목록 또는 &lt;code&gt;key&lt;/code&gt; 가없는 경우 빈 목록 .</target>
        </trans-unit>
        <trans-unit id="e0db2f5dd09c16dd491b0eb27aab616d26ccd184" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://redis.io/topics/protocol#array-reply&quot;&gt;Array reply&lt;/a&gt;: list of fields in the hash, or an empty list when &lt;code&gt;key&lt;/code&gt; does not exist.</source>
          <target state="translated">&lt;a href=&quot;https://redis.io/topics/protocol#array-reply&quot;&gt;배열 응답&lt;/a&gt; : 해시의 필드 목록 또는 &lt;code&gt;key&lt;/code&gt; 가없는 경우 빈 목록 입니다.</target>
        </trans-unit>
        <trans-unit id="38f13012834a024afeeae0e85666ed89c21d7edd" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://redis.io/topics/protocol#array-reply&quot;&gt;Array reply&lt;/a&gt;: list of keys from your command.</source>
          <target state="translated">&lt;a href=&quot;https://redis.io/topics/protocol#array-reply&quot;&gt;배열 응답&lt;/a&gt; : 명령의 키 목록.</target>
        </trans-unit>
        <trans-unit id="1bba25387d3ba730e4c4ccc6c9d34566d5f80b2e" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://redis.io/topics/protocol#array-reply&quot;&gt;Array reply&lt;/a&gt;: list of keys matching &lt;code&gt;pattern&lt;/code&gt;.</source>
          <target state="translated">&lt;a href=&quot;https://redis.io/topics/protocol#array-reply&quot;&gt;배열 응답&lt;/a&gt; : &lt;code&gt;pattern&lt;/code&gt; 과 일치하는 키 목록 .</target>
        </trans-unit>
        <trans-unit id="7008901b9444e395b10b1891e0691aeed355ef1b" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://redis.io/topics/protocol#array-reply&quot;&gt;Array reply&lt;/a&gt;: list of popped elements and scores.</source>
          <target state="translated">&lt;a href=&quot;https://redis.io/topics/protocol#array-reply&quot;&gt;배열 응답&lt;/a&gt; : 팝된 요소 및 점수 목록.</target>
        </trans-unit>
        <trans-unit id="768b79d5a771e0adb62f779546145aa9ec061e9f" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://redis.io/topics/protocol#array-reply&quot;&gt;Array reply&lt;/a&gt;: list of values associated with the given fields, in the same order as they are requested.</source>
          <target state="translated">&lt;a href=&quot;https://redis.io/topics/protocol#array-reply&quot;&gt;배열 응답&lt;/a&gt; : 요청 된 순서와 동일한 순서로 주어진 필드와 연관된 값의 목록입니다.</target>
        </trans-unit>
        <trans-unit id="edba5817ff98e74e87ffd89dbc0e584b1c4a0ea8" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://redis.io/topics/protocol#array-reply&quot;&gt;Array reply&lt;/a&gt;: list of values at the specified keys.</source>
          <target state="translated">&lt;a href=&quot;https://redis.io/topics/protocol#array-reply&quot;&gt;배열 응답&lt;/a&gt; : 지정된 키의 값 목록.</target>
        </trans-unit>
        <trans-unit id="5bef410dcd9605ff27afaf5970e7a6644a6e394c" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://redis.io/topics/protocol#array-reply&quot;&gt;Array reply&lt;/a&gt;: list of values in the hash, or an empty list when &lt;code&gt;key&lt;/code&gt; does not exist.</source>
          <target state="translated">&lt;a href=&quot;https://redis.io/topics/protocol#array-reply&quot;&gt;배열 응답&lt;/a&gt; : 해시의 값 목록 또는 &lt;code&gt;key&lt;/code&gt; 가없는 경우 빈 목록 입니다.</target>
        </trans-unit>
        <trans-unit id="1d69c2de28454376870835b9ae6eb87c2b3c65ac" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://redis.io/topics/protocol#array-reply&quot;&gt;Array reply&lt;/a&gt;: list with members of the resulting set.</source>
          <target state="translated">&lt;a href=&quot;https://redis.io/topics/protocol#array-reply&quot;&gt;배열 응답&lt;/a&gt; : 결과 집합의 멤버와 함께 나열됩니다.</target>
        </trans-unit>
        <trans-unit id="f9718b402d94b04938fde9706fc952dcdcad2c30" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://redis.io/topics/protocol#array-reply&quot;&gt;Array reply&lt;/a&gt;: nested list of command details.</source>
          <target state="translated">&lt;a href=&quot;https://redis.io/topics/protocol#array-reply&quot;&gt;배열 응답&lt;/a&gt; : 명령 세부 사항의 중첩 된 목록.</target>
        </trans-unit>
        <trans-unit id="4051935ff27edd1281b2e57032213c3ff26e7915" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://redis.io/topics/protocol#array-reply&quot;&gt;Array reply&lt;/a&gt;: nested list of command details. Commands are returned in random order.</source>
          <target state="translated">&lt;a href=&quot;https://redis.io/topics/protocol#array-reply&quot;&gt;배열 응답&lt;/a&gt; : 명령 세부 사항의 중첩 된 목록. 명령은 임의의 순서로 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="80226d2ffff944a8545c6bcef5b4ec0df2c13b6e" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://redis.io/topics/protocol#array-reply&quot;&gt;Array reply&lt;/a&gt;: nested list of memory usage metrics and their values</source>
          <target state="translated">&lt;a href=&quot;https://redis.io/topics/protocol#array-reply&quot;&gt;배열 응답&lt;/a&gt; : 중첩 된 메모리 사용 메트릭 목록 및 해당 값</target>
        </trans-unit>
        <trans-unit id="99d3dfaa299e9d77033d819c520407d435f3828c" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://redis.io/topics/protocol#array-reply&quot;&gt;Array reply&lt;/a&gt;: nested list of slot ranges with IP/Port mappings.</source>
          <target state="translated">&lt;a href=&quot;https://redis.io/topics/protocol#array-reply&quot;&gt;배열 응답&lt;/a&gt; : IP / 포트 매핑이있는 중첩 된 슬롯 범위 목록.</target>
        </trans-unit>
        <trans-unit id="6c33d239309c3bcbd4633a726b256c771934af60" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://redis.io/topics/protocol#array-reply&quot;&gt;Array reply&lt;/a&gt;: specifically:</source>
          <target state="translated">&lt;a href=&quot;https://redis.io/topics/protocol#array-reply&quot;&gt;배열 응답&lt;/a&gt; : 구체적으로 :</target>
        </trans-unit>
        <trans-unit id="bd962df66dd0c06c471f01d57ba98c740e6db002" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://redis.io/topics/protocol#array-reply&quot;&gt;Array reply&lt;/a&gt;: where the first element is one of &lt;code&gt;master&lt;/code&gt;, &lt;code&gt;slave&lt;/code&gt;, &lt;code&gt;sentinel&lt;/code&gt; and the additional elements are role-specific as illustrated above.</source>
          <target state="translated">&lt;a href=&quot;https://redis.io/topics/protocol#array-reply&quot;&gt;배열 응답&lt;/a&gt; : 여기서 첫 번째 요소는 &lt;code&gt;master&lt;/code&gt; , &lt;code&gt;slave&lt;/code&gt; , &lt;code&gt;sentinel&lt;/code&gt; 중 하나이며 추가 요소는 위에서 설명한대로 역할에 따라 다릅니다.</target>
        </trans-unit>
        <trans-unit id="8f9fd296564d45c8fb370985d4f39602e3fe46f2" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://redis.io/topics/protocol#array-reply&quot;&gt;Array reply&lt;/a&gt;: without passing the &lt;code&gt;store&lt;/code&gt; option the command returns a list of sorted elements. &lt;a href=&quot;https://redis.io/topics/protocol#integer-reply&quot;&gt;Integer reply&lt;/a&gt;: when the &lt;code&gt;store&lt;/code&gt; option is specified the command returns the number of sorted elements in the destination list.</source>
          <target state="translated">&lt;a href=&quot;https://redis.io/topics/protocol#array-reply&quot;&gt;배열 응답&lt;/a&gt; : &lt;code&gt;store&lt;/code&gt; 옵션 을 전달하지 않고 명령은 정렬 된 요소 목록을 반환합니다. &lt;a href=&quot;https://redis.io/topics/protocol#integer-reply&quot;&gt;정수 응답&lt;/a&gt; : &lt;code&gt;store&lt;/code&gt; 옵션이 지정되면 명령은 대상 목록에서 정렬 된 요소 수를 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="0060692d109c5852aa6b03fa7716b694d65526b7" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://redis.io/topics/protocol#bulk-string-reply&quot;&gt;Bulk string reply&lt;/a&gt; This command returns the SHA1 digest of the script added into the script cache.</source>
          <target state="translated">&lt;a href=&quot;https://redis.io/topics/protocol#bulk-string-reply&quot;&gt;대량 문자열 응답&lt;/a&gt; 이 명령은 스크립트 캐시에 추가 된 스크립트의 SHA1 다이제스트를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="845a3428e17cdef2c02c9f357ff17ea5bbaad601" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://redis.io/topics/protocol#bulk-string-reply&quot;&gt;Bulk string reply&lt;/a&gt;, specifically:</source>
          <target state="translated">&lt;a href=&quot;https://redis.io/topics/protocol#bulk-string-reply&quot;&gt;대량 문자열 회신&lt;/a&gt; , 특히 :</target>
        </trans-unit>
        <trans-unit id="5e7fc817ca969a4aa43419d826f7c1c4eb7dd749" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://redis.io/topics/protocol#bulk-string-reply&quot;&gt;Bulk string reply&lt;/a&gt;: A map between named fields and values in the form of &lt;code&gt;&amp;lt;field&amp;gt;:&amp;lt;value&amp;gt;&lt;/code&gt; lines separated by newlines composed by the two bytes &lt;code&gt;CRLF&lt;/code&gt;.</source>
          <target state="translated">&lt;a href=&quot;https://redis.io/topics/protocol#bulk-string-reply&quot;&gt;대량 문자열 응답&lt;/a&gt; : 이름이 지정된 필드와 &lt;code&gt;&amp;lt;field&amp;gt;:&amp;lt;value&amp;gt;&lt;/code&gt; 행 형식의 값 사이의 맵 ( 2 바이트 &lt;code&gt;CRLF&lt;/code&gt; 로 구성된 줄 바꿈으로 구분) .</target>
        </trans-unit>
        <trans-unit id="a4a5567225398e5bc0068ba239e91b02d4ee7cb2" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://redis.io/topics/protocol#bulk-string-reply&quot;&gt;Bulk string reply&lt;/a&gt;: The connection name, or a null bulk reply if no name is set.</source>
          <target state="translated">&lt;a href=&quot;https://redis.io/topics/protocol#bulk-string-reply&quot;&gt;대량 문자열 회신&lt;/a&gt; : 연결 이름 또는 이름이 설정되지 않은 경우 null 대량 회신.</target>
        </trans-unit>
        <trans-unit id="25762762c8c2667fa1ae9d38c2200fef10a8714b" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://redis.io/topics/protocol#bulk-string-reply&quot;&gt;Bulk string reply&lt;/a&gt;: The serialized cluster configuration.</source>
          <target state="translated">&lt;a href=&quot;https://redis.io/topics/protocol#bulk-string-reply&quot;&gt;대량 문자열 응답&lt;/a&gt; : 직렬화 된 클러스터 구성.</target>
        </trans-unit>
        <trans-unit id="8291a50a03c48c7923ec73608ce7fc3f57608065" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://redis.io/topics/protocol#bulk-string-reply&quot;&gt;Bulk string reply&lt;/a&gt;: a unique string, formatted as follows:</source>
          <target state="translated">&lt;a href=&quot;https://redis.io/topics/protocol#bulk-string-reply&quot;&gt;대량 문자열 응답&lt;/a&gt; : 다음과 같이 형식이 지정된 고유 한 문자열입니다.</target>
        </trans-unit>
        <trans-unit id="86beafc65ba97e040d2555747da1b5b85fdfd2ed" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://redis.io/topics/protocol#bulk-string-reply&quot;&gt;Bulk string reply&lt;/a&gt;: as a collection of text lines.</source>
          <target state="translated">&lt;a href=&quot;https://redis.io/topics/protocol#bulk-string-reply&quot;&gt;대량 문자열 응답&lt;/a&gt; : 텍스트 줄 모음.</target>
        </trans-unit>
        <trans-unit id="42797546d8faff4f9aa92f89bfd2c70972447f29" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://redis.io/topics/protocol#bulk-string-reply&quot;&gt;Bulk string reply&lt;/a&gt;: the element being popped and pushed.</source>
          <target state="translated">&lt;a href=&quot;https://redis.io/topics/protocol#bulk-string-reply&quot;&gt;대량 문자열 응답&lt;/a&gt; : 팝업되고 푸시되는 요소입니다.</target>
        </trans-unit>
        <trans-unit id="d38053c5f4c5f80f17f4a7624581a88ff834bfbc" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://redis.io/topics/protocol#bulk-string-reply&quot;&gt;Bulk string reply&lt;/a&gt;: the element being popped from &lt;code&gt;source&lt;/code&gt; and pushed to &lt;code&gt;destination&lt;/code&gt;. If &lt;code&gt;timeout&lt;/code&gt; is reached, a &lt;a href=&quot;https://redis.io/topics/protocol#nil-reply&quot;&gt;Null reply&lt;/a&gt; is returned.</source>
          <target state="translated">&lt;a href=&quot;https://redis.io/topics/protocol#bulk-string-reply&quot;&gt;대량 문자열 응답&lt;/a&gt; : &lt;code&gt;source&lt;/code&gt; 에서 팝 되어 &lt;code&gt;destination&lt;/code&gt; 푸시 되는 요소 입니다 . 경우 &lt;code&gt;timeout&lt;/code&gt; 에 도달하는 &lt;a href=&quot;https://redis.io/topics/protocol#nil-reply&quot;&gt;널 응답이&lt;/a&gt; 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="285123c9cbd50d725c88fbd823aac7aec8938410" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://redis.io/topics/protocol#bulk-string-reply&quot;&gt;Bulk string reply&lt;/a&gt;: the memory allocator's internal statistics report</source>
          <target state="translated">&lt;a href=&quot;https://redis.io/topics/protocol#bulk-string-reply&quot;&gt;대량 문자열 응답&lt;/a&gt; : 메모리 할당 자의 내부 통계 보고서</target>
        </trans-unit>
        <trans-unit id="15bbcaaf54deaa53f0973715aba543e9bb36e555" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://redis.io/topics/protocol#bulk-string-reply&quot;&gt;Bulk string reply&lt;/a&gt;: the new score of &lt;code&gt;member&lt;/code&gt; (a double precision floating point number), represented as string.</source>
          <target state="translated">&lt;a href=&quot;https://redis.io/topics/protocol#bulk-string-reply&quot;&gt;대량 문자열 응답&lt;/a&gt; : 문자열 로 표시되는 &lt;code&gt;member&lt;/code&gt; 의 새로운 점수 (배정 밀도 부동 소수점 숫자)입니다.</target>
        </trans-unit>
        <trans-unit id="85742ae57c7f81e07ca0c455995ba2f2910fc525" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://redis.io/topics/protocol#bulk-string-reply&quot;&gt;Bulk string reply&lt;/a&gt;: the old value stored at &lt;code&gt;key&lt;/code&gt;, or &lt;code&gt;nil&lt;/code&gt; when &lt;code&gt;key&lt;/code&gt; did not exist.</source>
          <target state="translated">&lt;a href=&quot;https://redis.io/topics/protocol#bulk-string-reply&quot;&gt;대량 문자열 응답&lt;/a&gt; : 이전에 저장된 값 &lt;code&gt;key&lt;/code&gt; , 또는 &lt;code&gt;nil&lt;/code&gt; 때 &lt;code&gt;key&lt;/code&gt; 존재하지 않았다.</target>
        </trans-unit>
        <trans-unit id="dd8b37400f2e5614a532885ebdf5ff7e1383af0f" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://redis.io/topics/protocol#bulk-string-reply&quot;&gt;Bulk string reply&lt;/a&gt;: the random key, or &lt;code&gt;nil&lt;/code&gt; when the database is empty.</source>
          <target state="translated">&lt;a href=&quot;https://redis.io/topics/protocol#bulk-string-reply&quot;&gt;대량 문자열 응답&lt;/a&gt; : 임의의 키 또는 데이터베이스가 비어 있으면 &lt;code&gt;nil&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="55a29455c2a78416742f62adb4ee460239fd3430" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://redis.io/topics/protocol#bulk-string-reply&quot;&gt;Bulk string reply&lt;/a&gt;: the removed element, or &lt;code&gt;nil&lt;/code&gt; when &lt;code&gt;key&lt;/code&gt; does not exist.</source>
          <target state="translated">&lt;a href=&quot;https://redis.io/topics/protocol#bulk-string-reply&quot;&gt;대량 문자열 응답&lt;/a&gt; : 제거 된 요소 또는 &lt;code&gt;nil&lt;/code&gt; 때 &lt;code&gt;key&lt;/code&gt; 존재하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="947373c7837eae7cf3063950a2f1e02de9ee212d" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://redis.io/topics/protocol#bulk-string-reply&quot;&gt;Bulk string reply&lt;/a&gt;: the requested element, or &lt;code&gt;nil&lt;/code&gt; when &lt;code&gt;index&lt;/code&gt; is out of range.</source>
          <target state="translated">&lt;a href=&quot;https://redis.io/topics/protocol#bulk-string-reply&quot;&gt;대량 문자열 응답&lt;/a&gt; : 요청 된 요소 또는 &lt;code&gt;index&lt;/code&gt; 이 범위를 벗어난 경우 &lt;code&gt;nil&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="fa9f8462ea5a93855e928b9e454ce50c6c8b015e" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://redis.io/topics/protocol#bulk-string-reply&quot;&gt;Bulk string reply&lt;/a&gt;: the score of &lt;code&gt;member&lt;/code&gt; (a double precision floating point number), represented as string.</source>
          <target state="translated">&lt;a href=&quot;https://redis.io/topics/protocol#bulk-string-reply&quot;&gt;대량 문자열 응답&lt;/a&gt; : 문자열 로 표시되는 &lt;code&gt;member&lt;/code&gt; 의 점수 (배정 밀도 부동 소수점 숫자)입니다.</target>
        </trans-unit>
        <trans-unit id="b125e358844dd5fc431b939a805af62c0e066976" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://redis.io/topics/protocol#bulk-string-reply&quot;&gt;Bulk string reply&lt;/a&gt;: the serialized value.</source>
          <target state="translated">&lt;a href=&quot;https://redis.io/topics/protocol#bulk-string-reply&quot;&gt;대량 문자열 응답&lt;/a&gt; : 직렬화 된 값.</target>
        </trans-unit>
        <trans-unit id="4f284406d16a47480c00ff3f29a794af6559d4da" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://redis.io/topics/protocol#bulk-string-reply&quot;&gt;Bulk string reply&lt;/a&gt;: the value associated with &lt;code&gt;field&lt;/code&gt;, or &lt;code&gt;nil&lt;/code&gt; when &lt;code&gt;field&lt;/code&gt; is not present in the hash or &lt;code&gt;key&lt;/code&gt; does not exist.</source>
          <target state="translated">&lt;a href=&quot;https://redis.io/topics/protocol#bulk-string-reply&quot;&gt;대량 문자열 응답&lt;/a&gt; : &lt;code&gt;field&lt;/code&gt; 와 연관된 값 또는 &lt;code&gt;field&lt;/code&gt; 가 해시 또는 &lt;code&gt;key&lt;/code&gt; 존재하지 않는 경우 &lt;code&gt;nil&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="bb82d61357603bd2a57bf74faf2351a70c08ed9a" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://redis.io/topics/protocol#bulk-string-reply&quot;&gt;Bulk string reply&lt;/a&gt;: the value of &lt;code&gt;field&lt;/code&gt; after the increment.</source>
          <target state="translated">&lt;a href=&quot;https://redis.io/topics/protocol#bulk-string-reply&quot;&gt;대량 문자열 응답&lt;/a&gt; : 증분 후 &lt;code&gt;field&lt;/code&gt; 의 값입니다 .</target>
        </trans-unit>
        <trans-unit id="9b57a44119bf18997e493deb5aa780c7768245d0" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://redis.io/topics/protocol#bulk-string-reply&quot;&gt;Bulk string reply&lt;/a&gt;: the value of &lt;code&gt;key&lt;/code&gt; after the increment.</source>
          <target state="translated">&lt;a href=&quot;https://redis.io/topics/protocol#bulk-string-reply&quot;&gt;대량 문자열 응답&lt;/a&gt; : 증분 후 &lt;code&gt;key&lt;/code&gt; 값입니다 .</target>
        </trans-unit>
        <trans-unit id="af3638610829bd57d70e0e136ec5e9fe594466c6" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://redis.io/topics/protocol#bulk-string-reply&quot;&gt;Bulk string reply&lt;/a&gt;: the value of &lt;code&gt;key&lt;/code&gt;, or &lt;code&gt;nil&lt;/code&gt; when &lt;code&gt;key&lt;/code&gt; does not exist.</source>
          <target state="translated">&lt;a href=&quot;https://redis.io/topics/protocol#bulk-string-reply&quot;&gt;대량 문자열 응답&lt;/a&gt; : 값 &lt;code&gt;key&lt;/code&gt; , 또는 &lt;code&gt;nil&lt;/code&gt; 때 &lt;code&gt;key&lt;/code&gt; 존재하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="1524e15569af4c178d682ededb3b0454707b7e4e" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://redis.io/topics/protocol#bulk-string-reply&quot;&gt;Bulk string reply&lt;/a&gt;: the value of the first element, or &lt;code&gt;nil&lt;/code&gt; when &lt;code&gt;key&lt;/code&gt; does not exist.</source>
          <target state="translated">&lt;a href=&quot;https://redis.io/topics/protocol#bulk-string-reply&quot;&gt;대량 문자열 응답&lt;/a&gt; : 첫 번째 요소의 값, 또는 &lt;code&gt;nil&lt;/code&gt; 때 &lt;code&gt;key&lt;/code&gt; 존재하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="e4532d2c49323033ff7d2dfb3655ebbf78d2007b" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://redis.io/topics/protocol#bulk-string-reply&quot;&gt;Bulk string reply&lt;/a&gt;: the value of the last element, or &lt;code&gt;nil&lt;/code&gt; when &lt;code&gt;key&lt;/code&gt; does not exist.</source>
          <target state="translated">&lt;a href=&quot;https://redis.io/topics/protocol#bulk-string-reply&quot;&gt;대량 문자열 응답&lt;/a&gt; : 마지막 요소의 값, 또는 &lt;code&gt;nil&lt;/code&gt; 때 &lt;code&gt;key&lt;/code&gt; 존재하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="83c9d8c5c93abdca6de856ff75ca817401493f50" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://redis.io/topics/protocol#bulk-string-reply&quot;&gt;Bulk string reply&lt;/a&gt;: without the additional &lt;code&gt;count&lt;/code&gt; argument the command returns a Bulk Reply with the randomly selected element, or &lt;code&gt;nil&lt;/code&gt; when &lt;code&gt;key&lt;/code&gt; does not exist. &lt;a href=&quot;https://redis.io/topics/protocol#array-reply&quot;&gt;Array reply&lt;/a&gt;: when the additional &lt;code&gt;count&lt;/code&gt; argument is passed the command returns an array of elements, or an empty array when &lt;code&gt;key&lt;/code&gt; does not exist.</source>
          <target state="translated">&lt;a href=&quot;https://redis.io/topics/protocol#bulk-string-reply&quot;&gt;대량 문자열 응답&lt;/a&gt; : 추가없이 &lt;code&gt;count&lt;/code&gt; 명령이 무작위로 선택된 요소 또는과 대량 답글 반환 인수 &lt;code&gt;nil&lt;/code&gt; &lt;code&gt;key&lt;/code&gt; 존재하지 않습니다. &lt;a href=&quot;https://redis.io/topics/protocol#array-reply&quot;&gt;배열 응답&lt;/a&gt; : 추가 &lt;code&gt;count&lt;/code&gt; 인수가 전달되면 명령은 요소의 배열을 반환하거나 &lt;code&gt;key&lt;/code&gt; 가 없으면 빈 배열을 반환 합니다.</target>
        </trans-unit>
        <trans-unit id="07759ce56341d0818583a0fb86981afc6b981c29" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://redis.io/topics/protocol#integer-reply&quot;&gt;Integer reply&lt;/a&gt;, specifically:</source>
          <target state="translated">&lt;a href=&quot;https://redis.io/topics/protocol#integer-reply&quot;&gt;정수 회신&lt;/a&gt; , 특히 :</target>
        </trans-unit>
        <trans-unit id="a77fb095c0e3bb3c72b865d23eb9fa66e6d28120" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://redis.io/topics/protocol#integer-reply&quot;&gt;Integer reply&lt;/a&gt;: TTL in milliseconds, or a negative value in order to signal an error (see the description above).</source>
          <target state="translated">&lt;a href=&quot;https://redis.io/topics/protocol#integer-reply&quot;&gt;정수 응답&lt;/a&gt; : 오류를 알리기 위해 TTL (밀리 초) 또는 음수 값 (위 설명 참조).</target>
        </trans-unit>
        <trans-unit id="25c5224ccb98830f9bc39a9c0aceb209659822f3" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://redis.io/topics/protocol#integer-reply&quot;&gt;Integer reply&lt;/a&gt;: TTL in seconds, or a negative value in order to signal an error (see the description above).</source>
          <target state="translated">&lt;a href=&quot;https://redis.io/topics/protocol#integer-reply&quot;&gt;정수 응답&lt;/a&gt; : 오류를 알리기 위해 초 단위의 TTL 또는 음수 값 (위의 설명 참조).</target>
        </trans-unit>
        <trans-unit id="df46ee2db01a6626432daf13698e6f8ce41173c3" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://redis.io/topics/protocol#integer-reply&quot;&gt;Integer reply&lt;/a&gt;: The command returns the number of replicas reached by all the writes performed in the context of the current connection.</source>
          <target state="translated">&lt;a href=&quot;https://redis.io/topics/protocol#integer-reply&quot;&gt;정수 응답&lt;/a&gt; :이 명령은 현재 연결 컨텍스트에서 수행 된 모든 쓰기에 도달 한 복제본 수를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="aab4d4752a553c3968b6c9e98a5396808be0ccff" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://redis.io/topics/protocol#integer-reply&quot;&gt;Integer reply&lt;/a&gt;: The hash slot number.</source>
          <target state="translated">&lt;a href=&quot;https://redis.io/topics/protocol#integer-reply&quot;&gt;정수 응답&lt;/a&gt; : 해시 슬롯 번호.</target>
        </trans-unit>
        <trans-unit id="89319e35389a0b857d36cb542ef3abb9f6061b45" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://redis.io/topics/protocol#integer-reply&quot;&gt;Integer reply&lt;/a&gt;: The number of keys in the specified hash slot, or an error if the hash slot is invalid.</source>
          <target state="translated">&lt;a href=&quot;https://redis.io/topics/protocol#integer-reply&quot;&gt;정수 응답&lt;/a&gt; : 지정된 해시 슬롯의 키 수 또는 해시 슬롯이 유효하지 않은 경우 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="946db5d1c363df4ffc29f1f9a1aabf122be9528f" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://redis.io/topics/protocol#integer-reply&quot;&gt;Integer reply&lt;/a&gt;: The number of keys that were removed.</source>
          <target state="translated">&lt;a href=&quot;https://redis.io/topics/protocol#integer-reply&quot;&gt;정수 응답&lt;/a&gt; : 제거 된 키 수.</target>
        </trans-unit>
        <trans-unit id="cb035e5b6ce558134bf90c1ede2bd5b83f632811" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://redis.io/topics/protocol#integer-reply&quot;&gt;Integer reply&lt;/a&gt;: The number of keys that were touched.</source>
          <target state="translated">&lt;a href=&quot;https://redis.io/topics/protocol#integer-reply&quot;&gt;정수 응답&lt;/a&gt; : 터치 한 키 수.</target>
        </trans-unit>
        <trans-unit id="165a89aa6025991290c5b64bbc86bd67d32cbb50" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://redis.io/topics/protocol#integer-reply&quot;&gt;Integer reply&lt;/a&gt;: The number of keys that were unlinked.</source>
          <target state="translated">&lt;a href=&quot;https://redis.io/topics/protocol#integer-reply&quot;&gt;정수 응답&lt;/a&gt; : 연결 해제 된 키 수.</target>
        </trans-unit>
        <trans-unit id="031ec027acdadc31294febc67ac2fa44cfd616b1" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://redis.io/topics/protocol#integer-reply&quot;&gt;Integer reply&lt;/a&gt;: an UNIX time stamp.</source>
          <target state="translated">&lt;a href=&quot;https://redis.io/topics/protocol#integer-reply&quot;&gt;정수 응답&lt;/a&gt; : UNIX 타임 스탬프.</target>
        </trans-unit>
        <trans-unit id="a7fb20c3110dc33173cdfb855cc68302e434729d" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://redis.io/topics/protocol#integer-reply&quot;&gt;Integer reply&lt;/a&gt;: number of commands returned by &lt;a href=&quot;command&quot;&gt;COMMAND&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;https://redis.io/topics/protocol#integer-reply&quot;&gt;정수 응답&lt;/a&gt; : &lt;a href=&quot;command&quot;&gt;COMMAND가&lt;/a&gt; 리턴 한 명령 수</target>
        </trans-unit>
        <trans-unit id="d3985645ea6533c8ff22bd0bf4c6aaa0494190e0" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://redis.io/topics/protocol#integer-reply&quot;&gt;Integer reply&lt;/a&gt;: number of fields in the hash, or &lt;code&gt;0&lt;/code&gt; when &lt;code&gt;key&lt;/code&gt; does not exist.</source>
          <target state="translated">&lt;a href=&quot;https://redis.io/topics/protocol#integer-reply&quot;&gt;정수 응답&lt;/a&gt; : 해시의 필드 수 또는 &lt;code&gt;key&lt;/code&gt; 가없는 경우 &lt;code&gt;0&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="e5320679eebca502eaa82896b5c272af8082c5d4" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://redis.io/topics/protocol#integer-reply&quot;&gt;Integer reply&lt;/a&gt;: the bit value stored at &lt;em&gt;offset&lt;/em&gt;.</source>
          <target state="translated">&lt;a href=&quot;https://redis.io/topics/protocol#integer-reply&quot;&gt;정수 응답&lt;/a&gt; : &lt;em&gt;오프셋에&lt;/em&gt; 저장된 비트 값 .</target>
        </trans-unit>
        <trans-unit id="730ee3041b75e97424b63378eaa1ccca403b0299" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://redis.io/topics/protocol#integer-reply&quot;&gt;Integer reply&lt;/a&gt;: the cardinality (number of elements) of the set, or &lt;code&gt;0&lt;/code&gt; if &lt;code&gt;key&lt;/code&gt; does not exist.</source>
          <target state="translated">&lt;a href=&quot;https://redis.io/topics/protocol#integer-reply&quot;&gt;정수 응답&lt;/a&gt; : 세트의 카디널리티 (요소 수) 또는 &lt;code&gt;key&lt;/code&gt; 가없는 경우 &lt;code&gt;0&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="9df01f443c8d7ccdeca31cbfe67e7d6710102a58" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://redis.io/topics/protocol#integer-reply&quot;&gt;Integer reply&lt;/a&gt;: the cardinality (number of elements) of the sorted set, or &lt;code&gt;0&lt;/code&gt; if &lt;code&gt;key&lt;/code&gt; does not exist.</source>
          <target state="translated">&lt;a href=&quot;https://redis.io/topics/protocol#integer-reply&quot;&gt;정수 응답&lt;/a&gt; : 정렬 된 세트의 카디널리티 (요소 수) 또는 &lt;code&gt;key&lt;/code&gt; 가없는 경우 &lt;code&gt;0&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="d33f609110f9a248f5b18cee48af07aaadfe1e0d" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://redis.io/topics/protocol#integer-reply&quot;&gt;Integer reply&lt;/a&gt;: the length of the list after the insert operation, or &lt;code&gt;-1&lt;/code&gt; when the value &lt;code&gt;pivot&lt;/code&gt; was not found.</source>
          <target state="translated">&lt;a href=&quot;https://redis.io/topics/protocol#integer-reply&quot;&gt;정수 응답&lt;/a&gt; : 삽입 조작 후 목록의 길이 또는 값 &lt;code&gt;pivot&lt;/code&gt; 을 찾을 수없는 경우 &lt;code&gt;-1&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="24ce1afd1e33220091d8cb4d0b2c52498ebf5cb8" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://redis.io/topics/protocol#integer-reply&quot;&gt;Integer reply&lt;/a&gt;: the length of the list after the push operation.</source>
          <target state="translated">&lt;a href=&quot;https://redis.io/topics/protocol#integer-reply&quot;&gt;정수 응답&lt;/a&gt; : 푸시 조작 후 목록의 길이입니다.</target>
        </trans-unit>
        <trans-unit id="aa44d6a2e061a425b99d1f822db98d1c24616fb0" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://redis.io/topics/protocol#integer-reply&quot;&gt;Integer reply&lt;/a&gt;: the length of the list after the push operations.</source>
          <target state="translated">&lt;a href=&quot;https://redis.io/topics/protocol#integer-reply&quot;&gt;정수 응답&lt;/a&gt; : 푸시 조작 후 목록의 길이입니다.</target>
        </trans-unit>
        <trans-unit id="df9eab7d23111f94bd3556cf17f936ecd2fd185d" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://redis.io/topics/protocol#integer-reply&quot;&gt;Integer reply&lt;/a&gt;: the length of the list at &lt;code&gt;key&lt;/code&gt;.</source>
          <target state="translated">&lt;a href=&quot;https://redis.io/topics/protocol#integer-reply&quot;&gt;정수 응답&lt;/a&gt; : &lt;code&gt;key&lt;/code&gt; 의 목록 길이 .</target>
        </trans-unit>
        <trans-unit id="e16d810965780b280923c3ccacb26c6db64ae821" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://redis.io/topics/protocol#integer-reply&quot;&gt;Integer reply&lt;/a&gt;: the length of the string after it was modified by the command.</source>
          <target state="translated">&lt;a href=&quot;https://redis.io/topics/protocol#integer-reply&quot;&gt;정수 응답&lt;/a&gt; : 명령에 의해 수정 된 후의 문자열 길이.</target>
        </trans-unit>
        <trans-unit id="baebf23f1e7de2e112b0ad0540d84398daeef7c8" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://redis.io/topics/protocol#integer-reply&quot;&gt;Integer reply&lt;/a&gt;: the length of the string after the append operation.</source>
          <target state="translated">&lt;a href=&quot;https://redis.io/topics/protocol#integer-reply&quot;&gt;정수 응답&lt;/a&gt; : 추가 작업 후 문자열의 길이입니다.</target>
        </trans-unit>
        <trans-unit id="13e194e430e7a65b50120ada22b947b03158b183" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://redis.io/topics/protocol#integer-reply&quot;&gt;Integer reply&lt;/a&gt;: the length of the string at &lt;code&gt;key&lt;/code&gt;, or &lt;code&gt;0&lt;/code&gt; when &lt;code&gt;key&lt;/code&gt; does not exist.</source>
          <target state="translated">&lt;a href=&quot;https://redis.io/topics/protocol#integer-reply&quot;&gt;정수 응답&lt;/a&gt; : &lt;code&gt;key&lt;/code&gt; 의 문자열 길이 또는 &lt;code&gt;key&lt;/code&gt; 가없는 경우 &lt;code&gt;0&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="5d9698660c2db7d2df47dc712d9ebf3205e55376" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://redis.io/topics/protocol#integer-reply&quot;&gt;Integer reply&lt;/a&gt;: the memory usage in bytes</source>
          <target state="translated">&lt;a href=&quot;https://redis.io/topics/protocol#integer-reply&quot;&gt;정수 응답&lt;/a&gt; : 바이트 단위의 메모리 사용량</target>
        </trans-unit>
        <trans-unit id="9a56db16d5291b4e17cbdaeb8bab2796997fd8a8" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://redis.io/topics/protocol#integer-reply&quot;&gt;Integer reply&lt;/a&gt;: the number of active failure reports for the node.</source>
          <target state="translated">&lt;a href=&quot;https://redis.io/topics/protocol#integer-reply&quot;&gt;정수 응답&lt;/a&gt; : 노드에 대한 활성 실패 보고서 수.</target>
        </trans-unit>
        <trans-unit id="32c313e17b555e77e1a9266257601f4939b7a7b8" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://redis.io/topics/protocol#integer-reply&quot;&gt;Integer reply&lt;/a&gt;: the number of clients killed.</source>
          <target state="translated">&lt;a href=&quot;https://redis.io/topics/protocol#integer-reply&quot;&gt;정수 응답&lt;/a&gt; : 종료 된 클라이언트 수.</target>
        </trans-unit>
        <trans-unit id="0470450d5ab6cebc374249338ed2370944378fbd" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://redis.io/topics/protocol#integer-reply&quot;&gt;Integer reply&lt;/a&gt;: the number of clients that received the message.</source>
          <target state="translated">&lt;a href=&quot;https://redis.io/topics/protocol#integer-reply&quot;&gt;정수 응답&lt;/a&gt; : 메시지를받은 클라이언트 수입니다.</target>
        </trans-unit>
        <trans-unit id="efbb0ebf86774003b900e8e13dd8994e8d673ce5" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://redis.io/topics/protocol#integer-reply&quot;&gt;Integer reply&lt;/a&gt;: the number of elements in the resulting set.</source>
          <target state="translated">&lt;a href=&quot;https://redis.io/topics/protocol#integer-reply&quot;&gt;정수 응답&lt;/a&gt; : 결과 집합의 요소 수</target>
        </trans-unit>
        <trans-unit id="cc80dd9c7a9c03dd83f05317737b8db6a47aab7b" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://redis.io/topics/protocol#integer-reply&quot;&gt;Integer reply&lt;/a&gt;: the number of elements in the resulting sorted set at &lt;code&gt;destination&lt;/code&gt;.</source>
          <target state="translated">&lt;a href=&quot;https://redis.io/topics/protocol#integer-reply&quot;&gt;정수 응답&lt;/a&gt; : 결과 정렬 된 &lt;code&gt;destination&lt;/code&gt; 의 요소 수입니다 .</target>
        </trans-unit>
        <trans-unit id="4c46a6c318ca1eba536aba936805b81c6b86ed3f" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://redis.io/topics/protocol#integer-reply&quot;&gt;Integer reply&lt;/a&gt;: the number of elements in the specified score range.</source>
          <target state="translated">&lt;a href=&quot;https://redis.io/topics/protocol#integer-reply&quot;&gt;정수 응답&lt;/a&gt; : 지정된 점수 범위의 요소 수입니다.</target>
        </trans-unit>
        <trans-unit id="6102c95e14a38b64a5b11caea6bec8853932e3ad" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://redis.io/topics/protocol#integer-reply&quot;&gt;Integer reply&lt;/a&gt;: the number of elements removed.</source>
          <target state="translated">&lt;a href=&quot;https://redis.io/topics/protocol#integer-reply&quot;&gt;정수 응답&lt;/a&gt; : 제거 된 요소 수</target>
        </trans-unit>
        <trans-unit id="cbe1f1b179e296fbeb060c666b659a22da90872e" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://redis.io/topics/protocol#integer-reply&quot;&gt;Integer reply&lt;/a&gt;: the number of elements that were added to the set, not including all the elements already present into the set.</source>
          <target state="translated">&lt;a href=&quot;https://redis.io/topics/protocol#integer-reply&quot;&gt;정수 응답&lt;/a&gt; : 세트에 이미 존재하는 모든 요소를 ​​포함하지 않고 세트에 추가 된 요소 수.</target>
        </trans-unit>
        <trans-unit id="b5efc093745110558a0550df857be66582177f45" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://redis.io/topics/protocol#integer-reply&quot;&gt;Integer reply&lt;/a&gt;: the number of entries actually deleted.</source>
          <target state="translated">&lt;a href=&quot;https://redis.io/topics/protocol#integer-reply&quot;&gt;정수 응답&lt;/a&gt; : 실제로 삭제 된 항목 수입니다.</target>
        </trans-unit>
        <trans-unit id="e832fcf5757b94516db65bacd8cd26a441400850" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://redis.io/topics/protocol#integer-reply&quot;&gt;Integer reply&lt;/a&gt;: the number of entries of the stream at &lt;code&gt;key&lt;/code&gt;.</source>
          <target state="translated">&lt;a href=&quot;https://redis.io/topics/protocol#integer-reply&quot;&gt;정수 응답&lt;/a&gt; : &lt;code&gt;key&lt;/code&gt; 에서 스트림의 항목 수입니다 .</target>
        </trans-unit>
        <trans-unit id="291ab5dcd91e6798ef4d9a5a65a7dd018e6d3e39" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://redis.io/topics/protocol#integer-reply&quot;&gt;Integer reply&lt;/a&gt;: the number of fields that were removed from the hash, not including specified but non existing fields.</source>
          <target state="translated">&lt;a href=&quot;https://redis.io/topics/protocol#integer-reply&quot;&gt;정수 응답&lt;/a&gt; : 지정된 필드를 제외하고 해시에서 제거 된 필드 수입니다.</target>
        </trans-unit>
        <trans-unit id="77f7e40a02041e5db76ae97820715d75d974f786" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://redis.io/topics/protocol#integer-reply&quot;&gt;Integer reply&lt;/a&gt;: the number of members that were removed from the set, not including non existing members.</source>
          <target state="translated">&lt;a href=&quot;https://redis.io/topics/protocol#integer-reply&quot;&gt;정수 응답&lt;/a&gt; : 기존 멤버가 아닌 멤버를 제외하고 세트에서 제거 된 멤버 수입니다.</target>
        </trans-unit>
        <trans-unit id="ccd33e07b2c0561dcbd7abe58b97456e0b1ace2c" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://redis.io/topics/protocol#integer-reply&quot;&gt;Integer reply&lt;/a&gt;: the number of patterns all the clients are subscribed to.</source>
          <target state="translated">&lt;a href=&quot;https://redis.io/topics/protocol#integer-reply&quot;&gt;정수 응답&lt;/a&gt; : 모든 클라이언트가 구독 한 패턴의 수입니다.</target>
        </trans-unit>
        <trans-unit id="77d9eb64ec3170f986f37c742d2c0fc099b6dd8e" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://redis.io/topics/protocol#integer-reply&quot;&gt;Integer reply&lt;/a&gt;: the number of removed elements.</source>
          <target state="translated">&lt;a href=&quot;https://redis.io/topics/protocol#integer-reply&quot;&gt;정수 응답&lt;/a&gt; : 제거 된 요소 수</target>
        </trans-unit>
        <trans-unit id="bbdda2e39d4da814cc4e6c4b8d01710f540cc4f3" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://redis.io/topics/protocol#integer-reply&quot;&gt;Integer reply&lt;/a&gt;: the original bit value stored at &lt;em&gt;offset&lt;/em&gt;.</source>
          <target state="translated">&lt;a href=&quot;https://redis.io/topics/protocol#integer-reply&quot;&gt;정수 응답&lt;/a&gt; : &lt;em&gt;오프셋에&lt;/em&gt; 저장된 원래 비트 값 .</target>
        </trans-unit>
        <trans-unit id="3ee2fed3ff2c167a200a10b83c93876ff8b10114" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://redis.io/topics/protocol#integer-reply&quot;&gt;Integer reply&lt;/a&gt;: the string length of the value associated with &lt;code&gt;field&lt;/code&gt;, or zero when &lt;code&gt;field&lt;/code&gt; is not present in the hash or &lt;code&gt;key&lt;/code&gt; does not exist at all.</source>
          <target state="translated">&lt;a href=&quot;https://redis.io/topics/protocol#integer-reply&quot;&gt;정수 응답&lt;/a&gt; : &lt;code&gt;field&lt;/code&gt; 와 연관된 값의 문자열 길이 또는 &lt;code&gt;field&lt;/code&gt; 가 해시에 없거나 &lt;code&gt;key&lt;/code&gt; 가 전혀 없는 경우 0 입니다.</target>
        </trans-unit>
        <trans-unit id="7488f83f7eab55654f7fe9268c9aabe045a7b18e" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://redis.io/topics/protocol#integer-reply&quot;&gt;Integer reply&lt;/a&gt;: the value at &lt;code&gt;field&lt;/code&gt; after the increment operation.</source>
          <target state="translated">&lt;a href=&quot;https://redis.io/topics/protocol#integer-reply&quot;&gt;정수 응답&lt;/a&gt; : 증가 조작 후 &lt;code&gt;field&lt;/code&gt; 의 값 .</target>
        </trans-unit>
        <trans-unit id="1027bb3558c2b4ba14df5ea41d0b10ef4e2fdd02" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://redis.io/topics/protocol#integer-reply&quot;&gt;Integer reply&lt;/a&gt;: the value of &lt;code&gt;key&lt;/code&gt; after the decrement</source>
          <target state="translated">&lt;a href=&quot;https://redis.io/topics/protocol#integer-reply&quot;&gt;정수 회신&lt;/a&gt; : 감소 후 &lt;code&gt;key&lt;/code&gt; 값</target>
        </trans-unit>
        <trans-unit id="d6bd149493b8c911e4525285ffd34585893bdc1f" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://redis.io/topics/protocol#integer-reply&quot;&gt;Integer reply&lt;/a&gt;: the value of &lt;code&gt;key&lt;/code&gt; after the increment</source>
          <target state="translated">&lt;a href=&quot;https://redis.io/topics/protocol#integer-reply&quot;&gt;정수 회신&lt;/a&gt; : 증분 후 &lt;code&gt;key&lt;/code&gt; 값</target>
        </trans-unit>
        <trans-unit id="7cc7de27c999708bcbeb570ac8adac852c5d672b" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://redis.io/topics/protocol#simple-string-reply&quot;&gt;Simple string reply&lt;/a&gt; on error. On success nothing is returned since the server quits and the connection is closed.</source>
          <target state="translated">&lt;a href=&quot;https://redis.io/topics/protocol#simple-string-reply&quot;&gt;&lt;/a&gt;오류시 간단한 문자열 응답 . 성공하면 서버가 종료되고 연결이 종료 된 후 아무것도 반환되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="c9137421435e7031e78d30846bad61e19e503d47" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://redis.io/topics/protocol#simple-string-reply&quot;&gt;Simple string reply&lt;/a&gt;: &lt;code&gt;OK&lt;/code&gt; if &lt;a href=&quot;set&quot;&gt;SET&lt;/a&gt; was executed correctly. &lt;a href=&quot;https://redis.io/topics/protocol#nil-reply&quot;&gt;Null reply&lt;/a&gt;: a Null Bulk Reply is returned if the &lt;a href=&quot;set&quot;&gt;SET&lt;/a&gt; operation was not performed because the user specified the &lt;code&gt;NX&lt;/code&gt; or &lt;code&gt;XX&lt;/code&gt; option but the condition was not met.</source>
          <target state="translated">&lt;a href=&quot;https://redis.io/topics/protocol#simple-string-reply&quot;&gt;단순 문자열 응답&lt;/a&gt; : &lt;code&gt;OK&lt;/code&gt; 경우 &lt;a href=&quot;set&quot;&gt;SET가&lt;/a&gt; 제대로 실행되었다. &lt;a href=&quot;https://redis.io/topics/protocol#nil-reply&quot;&gt;널 응답&lt;/a&gt; : 사용자가 &lt;code&gt;NX&lt;/code&gt; 또는 &lt;code&gt;XX&lt;/code&gt; 옵션을 지정 했지만 조건이 충족 되지 않아 &lt;a href=&quot;set&quot;&gt;SET&lt;/a&gt; 조작이 수행되지 않은 경우 널 대량 응답이 리턴됩니다 .</target>
        </trans-unit>
        <trans-unit id="9233d17c9787c672ad4f7e3e80293e0e12d1a72f" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://redis.io/topics/protocol#simple-string-reply&quot;&gt;Simple string reply&lt;/a&gt;: &lt;code&gt;OK&lt;/code&gt; if &lt;a href=&quot;swapdb&quot;&gt;SWAPDB&lt;/a&gt; was executed correctly.</source>
          <target state="translated">&lt;a href=&quot;https://redis.io/topics/protocol#simple-string-reply&quot;&gt;단순 문자열 응답&lt;/a&gt; : &lt;code&gt;OK&lt;/code&gt; 경우 &lt;a href=&quot;swapdb&quot;&gt;SWAPDB이&lt;/a&gt; 제대로 실행되었다.</target>
        </trans-unit>
        <trans-unit id="c01fcbe216d0b2f0ff716f18544ddbcd2fc94031" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://redis.io/topics/protocol#simple-string-reply&quot;&gt;Simple string reply&lt;/a&gt;: &lt;code&gt;OK&lt;/code&gt; if the command was accepted and a manual failover is going to be attempted. An error if the operation cannot be executed, for example if we are talking with a node which is already a master.</source>
          <target state="translated">&lt;a href=&quot;https://redis.io/topics/protocol#simple-string-reply&quot;&gt;단순 문자열 응답&lt;/a&gt; : &lt;code&gt;OK&lt;/code&gt; 명령이 받아 들여졌다 및 수동 장애 조치를 시도 할 것입니다 경우. 예를 들어 이미 마스터 인 노드와 통신중인 경우 작업을 실행할 수없는 경우 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="297f4fab43e0ec2423c9dfc4730472f21ff7866d" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://redis.io/topics/protocol#simple-string-reply&quot;&gt;Simple string reply&lt;/a&gt;: &lt;code&gt;OK&lt;/code&gt; if the command was executed successfully, otherwise an error is returned.</source>
          <target state="translated">&lt;a href=&quot;https://redis.io/topics/protocol#simple-string-reply&quot;&gt;단순 문자열 응답&lt;/a&gt; : 명령이 성공적으로 실행되면 &lt;code&gt;OK&lt;/code&gt; , 그렇지 않으면 오류가 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="fea202f1970ef825dd4f2ad4d5812072c693d198" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://redis.io/topics/protocol#simple-string-reply&quot;&gt;Simple string reply&lt;/a&gt;: &lt;code&gt;OK&lt;/code&gt; if the command was successful. If the address or port specified are invalid an error is returned.</source>
          <target state="translated">&lt;a href=&quot;https://redis.io/topics/protocol#simple-string-reply&quot;&gt;단순 문자열 응답&lt;/a&gt; : 명령이 성공하면 &lt;code&gt;OK&lt;/code&gt; . 지정된 주소 또는 포트가 유효하지 않은 경우 오류가 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="c0b3a472f0028565f48745273ffdfa0dcf15fef7" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://redis.io/topics/protocol#simple-string-reply&quot;&gt;Simple string reply&lt;/a&gt;: &lt;code&gt;OK&lt;/code&gt; if the command was successful. Otherwise an error is returned.</source>
          <target state="translated">&lt;a href=&quot;https://redis.io/topics/protocol#simple-string-reply&quot;&gt;단순 문자열 응답&lt;/a&gt; : 명령이 성공하면 &lt;code&gt;OK&lt;/code&gt; . 그렇지 않으면 오류가 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="22b87078fd7c99cce816e1ce9a1ebcc7178714aa" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://redis.io/topics/protocol#simple-string-reply&quot;&gt;Simple string reply&lt;/a&gt;: &lt;code&gt;OK&lt;/code&gt; if the connection exists and has been closed</source>
          <target state="translated">&lt;a href=&quot;https://redis.io/topics/protocol#simple-string-reply&quot;&gt;간단한 문자열 응답&lt;/a&gt; : 연결이 존재하고 닫혀 있으면 &lt;code&gt;OK&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="caa068a24e4ab09fe1a9ae4419ab37a33fc39835" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://redis.io/topics/protocol#simple-string-reply&quot;&gt;Simple string reply&lt;/a&gt;: &lt;code&gt;OK&lt;/code&gt; if the connection name was successfully set.</source>
          <target state="translated">&lt;a href=&quot;https://redis.io/topics/protocol#simple-string-reply&quot;&gt;단순 문자열 응답&lt;/a&gt; : 연결 이름이 성공적으로 설정되면 &lt;code&gt;OK&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="b089a3050550664e92f327d65ddfe93413662e79" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://redis.io/topics/protocol#simple-string-reply&quot;&gt;Simple string reply&lt;/a&gt;: &lt;code&gt;OK&lt;/code&gt; or an error if the operation fails.</source>
          <target state="translated">&lt;a href=&quot;https://redis.io/topics/protocol#simple-string-reply&quot;&gt;단순 문자열 응답&lt;/a&gt; : &lt;code&gt;OK&lt;/code&gt; 또는 작업이 실패하면 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="f299cd2d528956185fa095b9e4a4352d7cf04a01" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://redis.io/topics/protocol#simple-string-reply&quot;&gt;Simple string reply&lt;/a&gt;: &lt;code&gt;OK&lt;/code&gt; when the configuration was rewritten properly. Otherwise an error is returned.</source>
          <target state="translated">&lt;a href=&quot;https://redis.io/topics/protocol#simple-string-reply&quot;&gt;단순 문자열 응답&lt;/a&gt; : &lt;code&gt;OK&lt;/code&gt; 구성이 제대로 다시 작성했다. 그렇지 않으면 오류가 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="71e5863d8fc524b70c5ad7a6bb8d8819f38867d5" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://redis.io/topics/protocol#simple-string-reply&quot;&gt;Simple string reply&lt;/a&gt;: &lt;code&gt;OK&lt;/code&gt; when the configuration was set properly. Otherwise an error is returned.</source>
          <target state="translated">&lt;a href=&quot;https://redis.io/topics/protocol#simple-string-reply&quot;&gt;간단한 문자열 응답&lt;/a&gt; : 구성이 올바르게 설정되면 &lt;code&gt;OK&lt;/code&gt; . 그렇지 않으면 오류가 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="0f05c4a622a6872881aea9067061d16e81d37284" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://redis.io/topics/protocol#simple-string-reply&quot;&gt;Simple string reply&lt;/a&gt;: &lt;code&gt;OK&lt;/code&gt;.</source>
          <target state="translated">&lt;a href=&quot;https://redis.io/topics/protocol#simple-string-reply&quot;&gt;간단한 문자열 응답&lt;/a&gt; : &lt;code&gt;OK&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ddbb0da6f2fcf04271523471ba1c71d314a0d241" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://redis.io/topics/protocol#simple-string-reply&quot;&gt;Simple string reply&lt;/a&gt;: All the subcommands return &lt;code&gt;OK&lt;/code&gt; if the command was successful. Otherwise an error is returned.</source>
          <target state="translated">&lt;a href=&quot;https://redis.io/topics/protocol#simple-string-reply&quot;&gt;단순 문자열 응답&lt;/a&gt; : 명령이 성공하면 모든 부속 명령이 &lt;code&gt;OK&lt;/code&gt; 를 리턴 합니다. 그렇지 않으면 오류가 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="e951489739af40c53bd8764f1a993d7edbf2e3c9" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://redis.io/topics/protocol#simple-string-reply&quot;&gt;Simple string reply&lt;/a&gt;: The command just returns &lt;code&gt;OK&lt;/code&gt;.</source>
          <target state="translated">&lt;a href=&quot;https://redis.io/topics/protocol#simple-string-reply&quot;&gt;단순 문자열 응답&lt;/a&gt; : 명령은 &lt;code&gt;OK&lt;/code&gt; 만 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="3203f8adedbb1ca9d14d522445cfecd10e90ec4f" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://redis.io/topics/protocol#simple-string-reply&quot;&gt;Simple string reply&lt;/a&gt;: The command returns OK on success, or &lt;code&gt;NOKEY&lt;/code&gt; if no keys were found in the source instance.</source>
          <target state="translated">&lt;a href=&quot;https://redis.io/topics/protocol#simple-string-reply&quot;&gt;단순 문자열 응답&lt;/a&gt; : 명령은 성공하면 OK를 반환 하고 소스 인스턴스에 키가 없으면 &lt;code&gt;NOKEY&lt;/code&gt; 를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="21baca8a75a2e37d445a9975cd6749634079640d" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://redis.io/topics/protocol#simple-string-reply&quot;&gt;Simple string reply&lt;/a&gt;: The command returns OK on success.</source>
          <target state="translated">&lt;a href=&quot;https://redis.io/topics/protocol#simple-string-reply&quot;&gt;단순 문자열 응답&lt;/a&gt; : 명령이 성공하면 OK를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="e52b1b5063c0ac53b0ca6553e2990dc53de1b81f" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://redis.io/topics/protocol#simple-string-reply&quot;&gt;Simple string reply&lt;/a&gt;: The command returns OK or an error if the timeout is invalid.</source>
          <target state="translated">&lt;a href=&quot;https://redis.io/topics/protocol#simple-string-reply&quot;&gt;단순 문자열 응답&lt;/a&gt; : 시간 종료가 유효하지 않은 경우 명령은 OK 또는 오류를 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="701e711fa186a01d4b7899ec3383951b3c08d778" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://redis.io/topics/protocol#simple-string-reply&quot;&gt;Simple string reply&lt;/a&gt;: The commands returns OK on success.</source>
          <target state="translated">&lt;a href=&quot;https://redis.io/topics/protocol#simple-string-reply&quot;&gt;단순 문자열 응답&lt;/a&gt; : 명령이 성공하면 OK를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="18c4bbe7b1465236f074db82dbbd64ee2984a0f8" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://redis.io/topics/protocol#simple-string-reply&quot;&gt;Simple string reply&lt;/a&gt;: always &lt;code&gt;OK&lt;/code&gt; since &lt;a href=&quot;mset&quot;&gt;MSET&lt;/a&gt; can't fail.</source>
          <target state="translated">&lt;a href=&quot;https://redis.io/topics/protocol#simple-string-reply&quot;&gt;단순 문자열 응답&lt;/a&gt; : 항상 &lt;code&gt;OK&lt;/code&gt; 이후 &lt;a href=&quot;mset&quot;&gt;MSET이&lt;/a&gt; 실패 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c987e3cf6216c6d351ff4515581a641f35117ef3" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://redis.io/topics/protocol#simple-string-reply&quot;&gt;Simple string reply&lt;/a&gt;: always &lt;code&gt;OK&lt;/code&gt;.</source>
          <target state="translated">&lt;a href=&quot;https://redis.io/topics/protocol#simple-string-reply&quot;&gt;간단한 문자열 응답&lt;/a&gt; : 항상 &lt;code&gt;OK&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="165b0e096dabb4ed30920d49027f0c9ff291c3ce" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://redis.io/topics/protocol#simple-string-reply&quot;&gt;Simple string reply&lt;/a&gt;: always OK.</source>
          <target state="translated">&lt;a href=&quot;https://redis.io/topics/protocol#simple-string-reply&quot;&gt;간단한 문자열 응답&lt;/a&gt; : 항상 OK.</target>
        </trans-unit>
        <trans-unit id="79014d2c1babae62d3575c928fe5a9f54b57bf86" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://redis.io/topics/protocol#simple-string-reply&quot;&gt;Simple string reply&lt;/a&gt;: type of &lt;code&gt;key&lt;/code&gt;, or &lt;code&gt;none&lt;/code&gt; when &lt;code&gt;key&lt;/code&gt; does not exist.</source>
          <target state="translated">&lt;a href=&quot;https://redis.io/topics/protocol#simple-string-reply&quot;&gt;단순 문자열 응답&lt;/a&gt; : &lt;code&gt;key&lt;/code&gt; 유형 또는 &lt;code&gt;key&lt;/code&gt; 가 존재하지 않는 경우 &lt;code&gt;none&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6d2cb4c98790cb25c9fb170d76ecc215497e7546" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;keys&quot;&gt;KEYS&lt;/a&gt; -- If the key argument is an empty string, the command will instead migrate all the keys that follow the &lt;a href=&quot;keys&quot;&gt;KEYS&lt;/a&gt; option (see the above section for more info).</source>
          <target state="translated">&lt;a href=&quot;keys&quot;&gt;KEYS-&lt;/a&gt; 키 인수가 빈 문자열 인 경우 명령은 대신 &lt;a href=&quot;keys&quot;&gt;KEYS&lt;/a&gt; 옵션 뒤에 오는 모든 키를 마이그레이션합니다 (자세한 내용은 위 섹션 참조).</target>
        </trans-unit>
        <trans-unit id="8146b28b81f62433a2d744f49d9906200e53444e" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;mget&quot;&gt;MGET&lt;/a&gt; arity is -2 since the command accepts at a minimum one argument, but up to an unlimited number: &lt;code&gt;MGET _key1_ [key2] [key3] ...&lt;/code&gt;.</source>
          <target state="translated">&lt;a href=&quot;mget&quot;&gt;MGET&lt;/a&gt; arity는 명령이 최소 하나의 인수를 허용하지만 최대 개수 인 &lt;code&gt;MGET _key1_ [key2] [key3] ...&lt;/code&gt; 이기 때문에 -2 입니다.</target>
        </trans-unit>
        <trans-unit id="b74d551dd48487b353459439c5810b8fa324a72f" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;migrate&quot;&gt;MIGRATE&lt;/a&gt; needs to perform I/O operations and to honor the specified timeout. When there is an I/O error during the transfer or if the timeout is reached the operation is aborted and the special error - &lt;code&gt;IOERR&lt;/code&gt; returned. When this happens the following two cases are possible:</source>
          <target state="translated">&lt;a href=&quot;migrate&quot;&gt;MIGRATE&lt;/a&gt; 는 I / O 작업을 수행하고 지정된 시간 초과를 준수 해야합니다. 전송 중에 I / O 오류가 있거나 시간 초과에 도달하면 작업이 중단되고 특수 오류 &lt;code&gt;IOERR&lt;/code&gt; 반환됩니다. 이 경우 다음 두 가지 경우가 가능합니다.</target>
        </trans-unit>
        <trans-unit id="73d6ea01d80dd40464bdbf6f46f154e17ea759e7" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;monitor&quot;&gt;MONITOR&lt;/a&gt; is a debugging command that streams back every command processed by the Redis server. It can help in understanding what is happening to the database. This command can both be used via &lt;code&gt;redis-cli&lt;/code&gt; and via &lt;code&gt;telnet&lt;/code&gt;.</source>
          <target state="translated">&lt;a href=&quot;monitor&quot;&gt;MONITOR&lt;/a&gt; 는 Redis 서버에서 처리 한 모든 명령을 다시 스트리밍하는 디버깅 명령입니다. 데이터베이스에 무슨 일이 일어나고 있는지 이해하는 데 도움이 될 수 있습니다. 이 명령은 &lt;code&gt;redis-cli&lt;/code&gt; 및 &lt;code&gt;telnet&lt;/code&gt; 을 통해 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="1817595e9bbb68cbb8aaf36ed867b47ba3126fa3" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;mset&quot;&gt;MSET&lt;/a&gt; is atomic, so all given keys are set at once. It is not possible for clients to see that some of the keys were updated while others are unchanged.</source>
          <target state="translated">&lt;a href=&quot;mset&quot;&gt;MSET&lt;/a&gt; 은 원자 적이므로 지정된 모든 키가 한 번에 설정됩니다. 클라이언트는 일부 키가 업데이트되었지만 다른 키는 변경되지 않았 음을 확인할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="cb35a7c5ec5b28a9e0afc29b6bf7c84dc2dcf622" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;msetnx&quot;&gt;MSETNX&lt;/a&gt; is atomic, so all given keys are set at once. It is not possible for clients to see that some of the keys were updated while others are unchanged.</source>
          <target state="translated">&lt;a href=&quot;msetnx&quot;&gt;MSETNX&lt;/a&gt; 는 원 자성이므로 지정된 모든 키가 한 번에 설정됩니다. 클라이언트는 일부 키가 업데이트되었지만 다른 키는 변경되지 않았 음을 확인할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="c1941a08d38c3d75df1a1db22011b076092cc7ec" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;pexpireat&quot;&gt;PEXPIREAT&lt;/a&gt; has the same effect and semantic as &lt;a href=&quot;expireat&quot;&gt;EXPIREAT&lt;/a&gt;, but the Unix time at which the key will expire is specified in milliseconds instead of seconds.</source>
          <target state="translated">&lt;a href=&quot;pexpireat&quot;&gt;PEXPIREAT&lt;/a&gt; 는 EXPIREAT 와 동일한 효과 및 의미를 &lt;a href=&quot;expireat&quot;&gt;갖지만&lt;/a&gt; 키가 만료되는 Unix 시간은 초가 아닌 밀리 초로 지정됩니다.</target>
        </trans-unit>
        <trans-unit id="4c76a182dfa7f50418514e82401ec4d30522238a" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;psetex&quot;&gt;PSETEX&lt;/a&gt; works exactly like &lt;a href=&quot;setex&quot;&gt;SETEX&lt;/a&gt; with the sole difference that the expire time is specified in milliseconds instead of seconds.</source>
          <target state="translated">&lt;a href=&quot;psetex&quot;&gt;PSETEX&lt;/a&gt; 는 만료 시간이 초가 아닌 밀리 초로 지정된다는 유일한 차이점을 &lt;a href=&quot;setex&quot;&gt;제외&lt;/a&gt; 하고는 SETEX 와 동일 하게 작동합니다 .</target>
        </trans-unit>
        <trans-unit id="74b3bd512460d9379b27d49d692678508b5e36e8" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;readonly&quot;&gt;READONLY&lt;/a&gt; tells a Redis Cluster replica node that the client is willing to read possibly stale data and is not interested in running write queries.</source>
          <target state="translated">&lt;a href=&quot;readonly&quot;&gt;READONLY&lt;/a&gt; 는 클라이언트가 오래된 데이터를 기꺼이 읽고 쓰기 쿼리 실행에 관심이 없음을 Redis 클러스터 복제본 노드에 알립니다.</target>
        </trans-unit>
        <trans-unit id="7ec5b99fb632cc347aa4c2c994ed4f7b70583c00" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;restore&quot;&gt;RESTORE&lt;/a&gt; checks the RDB version and data checksum. If they don't match an error is returned.</source>
          <target state="translated">&lt;a href=&quot;restore&quot;&gt;RESTORE&lt;/a&gt; 는 RDB 버전 및 데이터 체크섬을 확인합니다. 일치하지 않으면 오류가 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="978b3891d3cbcd2e75b7d11250ec6e96a2651a96" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;restore&quot;&gt;RESTORE&lt;/a&gt; will return a &quot;Target key name is busy&quot; error when &lt;code&gt;key&lt;/code&gt; already exists unless you use the &lt;code&gt;REPLACE&lt;/code&gt; modifier (Redis 3.0 or greater).</source>
          <target state="translated">&lt;a href=&quot;restore&quot;&gt;&lt;/a&gt; &lt;code&gt;REPLACE&lt;/code&gt; 수정 자 (Redis 3.0 이상) 를 사용하지 않으면 &lt;code&gt;key&lt;/code&gt; 이미 존재 하면 RESTORE 에서 &quot;대상 키 이름이 사용 중입니다&quot;오류를 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="607867386bd28ac7647c1164afd60ba4bbf1ee27" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;rpoplpush&quot;&gt;RPOPLPUSH&lt;/a&gt; (or &lt;a href=&quot;brpoplpush&quot;&gt;BRPOPLPUSH&lt;/a&gt; for the blocking variant) offers a way to avoid this problem: the consumer fetches the message and at the same time pushes it into a &lt;em&gt;processing&lt;/em&gt; list. It will use the &lt;a href=&quot;lrem&quot;&gt;LREM&lt;/a&gt; command in order to remove the message from the &lt;em&gt;processing&lt;/em&gt; list once the message has been processed.</source>
          <target state="translated">&lt;a href=&quot;rpoplpush&quot;&gt;RPOPLPUSH&lt;/a&gt; (또는 블로킹 변형의 경우 &lt;a href=&quot;brpoplpush&quot;&gt;BRPOPLPUSH&lt;/a&gt; )는이 문제를 피하는 방법을 제공합니다. 소비자는 메시지를 가져오고 동시에 &lt;em&gt;처리&lt;/em&gt; 목록 으로 보냅니다 . 메시지가 &lt;em&gt;처리&lt;/em&gt; 되면 &lt;em&gt;처리&lt;/em&gt; 목록 에서 메시지를 제거하기 위해 &lt;a href=&quot;lrem&quot;&gt;LREM&lt;/a&gt; 명령을 사용합니다 .&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="8e85077550aa1c37d3c9aad2ca4d607b1411203e" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;scan&quot;&gt;SCAN&lt;/a&gt; array of elements is a list of keys.</source>
          <target state="translated">&lt;a href=&quot;scan&quot;&gt;&lt;/a&gt;요소의 SCAN 배열은 키 목록입니다.</target>
        </trans-unit>
        <trans-unit id="0cdb46ca445a00b57f65dc1297a89c15d2487ed2" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;scan&quot;&gt;SCAN&lt;/a&gt; family functions do not guarantee that the number of elements returned per call are in a given range. The commands are also allowed to return zero elements, and the client should not consider the iteration complete as long as the returned cursor is not zero.</source>
          <target state="translated">&lt;a href=&quot;scan&quot;&gt;SCAN&lt;/a&gt; 제품군 기능은 호출 당 반환되는 요소 수가 지정된 범위 내에 있음을 보증하지 않습니다. 명령은 또한 제로 요소를 리턴 할 수 있으며, 클라이언트는 리턴 된 커서가 0이 아닌 한 반복 완료를 고려해서는 안됩니다.</target>
        </trans-unit>
        <trans-unit id="b5a0c19030600e5f0f42b3ad5aa1361dfd0233da" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;scan&quot;&gt;SCAN&lt;/a&gt; iterates the set of keys in the currently selected Redis database.</source>
          <target state="translated">&lt;a href=&quot;scan&quot;&gt;SCAN&lt;/a&gt; 은 현재 선택된 Redis 데이터베이스에서 키 세트를 반복합니다.</target>
        </trans-unit>
        <trans-unit id="97aa992fd62d3a4c2a98aa824313a37db5dcc019" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;scan&quot;&gt;SCAN&lt;/a&gt;, &lt;a href=&quot;sscan&quot;&gt;SSCAN&lt;/a&gt;, &lt;a href=&quot;hscan&quot;&gt;HSCAN&lt;/a&gt; and &lt;a href=&quot;zscan&quot;&gt;ZSCAN&lt;/a&gt; return a two elements multi-bulk reply, where the first element is a string representing an unsigned 64 bit number (the cursor), and the second element is a multi-bulk with an array of elements.</source>
          <target state="translated">&lt;a href=&quot;scan&quot;&gt;SCAN&lt;/a&gt; , &lt;a href=&quot;sscan&quot;&gt;SSCAN&lt;/a&gt; , &lt;a href=&quot;hscan&quot;&gt;HSCAN&lt;/a&gt; 및 &lt;a href=&quot;zscan&quot;&gt;ZSCAN&lt;/a&gt; 은 두 요소의 다중 벌크 응답을 반환합니다. 첫 번째 요소는 부호없는 64 비트 숫자 (커서)를 나타내는 문자열이고 두 번째 요소는 요소 배열이있는 다중 전구입니다.</target>
        </trans-unit>
        <trans-unit id="e1cc429647f3d3a6ed8373af387a43592fc0d84b" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;setex&quot;&gt;SETEX&lt;/a&gt; is atomic, and can be reproduced by using the previous two commands inside an &lt;a href=&quot;multi&quot;&gt;MULTI&lt;/a&gt; / &lt;a href=&quot;exec&quot;&gt;EXEC&lt;/a&gt; block. It is provided as a faster alternative to the given sequence of operations, because this operation is very common when Redis is used as a cache.</source>
          <target state="translated">&lt;a href=&quot;setex&quot;&gt;SETEX&lt;/a&gt; 는 원자 적이며 &lt;a href=&quot;multi&quot;&gt;MULTI&lt;/a&gt; / &lt;a href=&quot;exec&quot;&gt;EXEC&lt;/a&gt; 블록 내부의 이전 두 명령을 사용하여 재현 할 수 있습니다 . Redis가 캐시로 사용될 때이 작업은 매우 일반적이기 때문에 주어진 작업 순서에 대한 빠른 대안으로 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="02287c67ea11a6ca17f48473021815844fa305b7" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;setrange&quot;&gt;SETRANGE&lt;/a&gt; can be used to overwrite an existing time series.</source>
          <target state="translated">&lt;a href=&quot;setrange&quot;&gt;SETRANGE&lt;/a&gt; 를 사용하여 기존 시계열을 덮어 쓸 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ab683100370a7f48dded6ed5a04bf67278378c30" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;sort&quot;&gt;SORT&lt;/a&gt; - optional &lt;code&gt;STORE&lt;/code&gt; key, optional &lt;code&gt;BY&lt;/code&gt; weights, optional &lt;a href=&quot;get&quot;&gt;GET&lt;/a&gt; keys</source>
          <target state="translated">&lt;a href=&quot;sort&quot;&gt;SORT-&lt;/a&gt; 옵션 &lt;code&gt;STORE&lt;/code&gt; 키, 옵션 &lt;code&gt;BY&lt;/code&gt; 중량, 옵션 &lt;a href=&quot;get&quot;&gt;GET&lt;/a&gt; 키</target>
        </trans-unit>
        <trans-unit id="db52b28a5e89641f8e27484d33e354f10edf1b33" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;sscan&quot;&gt;SSCAN&lt;/a&gt; array of elements is a list of Set members.</source>
          <target state="translated">&lt;a href=&quot;sscan&quot;&gt;&lt;/a&gt;요소의 SSCAN 배열은 세트 멤버의 목록입니다.</target>
        </trans-unit>
        <trans-unit id="6a0f82e61b67b9691a5093ef110457f991bde8be" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;sscan&quot;&gt;SSCAN&lt;/a&gt; iterates elements of Sets types.</source>
          <target state="translated">&lt;a href=&quot;sscan&quot;&gt;SSCAN&lt;/a&gt; 은 세트 유형의 요소를 반복합니다.</target>
        </trans-unit>
        <trans-unit id="5d4e6a6b49a52d866feae91c3794f3e18086c5bd" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;strlen&quot;&gt;STRLEN&lt;/a&gt; can be used in order to obtain the number of samples.</source>
          <target state="translated">&lt;a href=&quot;strlen&quot;&gt;&lt;/a&gt;샘플 수를 얻기 위해 STRLEN을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b796eba8fd69116b937293d7d2d4e660bd7b1e77" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;sync&quot;&gt;SYNC&lt;/a&gt;. Enable blocking synchronous debugging of Lua scripts (saves changes to data).</source>
          <target state="translated">&lt;a href=&quot;sync&quot;&gt;SYNC&lt;/a&gt; . Lua 스크립트의 동기화 디버깅 차단 (데이터 변경 사항 저장)을 활성화합니다.</target>
        </trans-unit>
        <trans-unit id="c8528d8f751b6eb35cec6632b6943289a674f9f5" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;xadd&quot;&gt;XADD&lt;/a&gt; is the &lt;em&gt;only Redis command&lt;/em&gt; that can add data to a stream, but there are other commands, such as &lt;a href=&quot;xdel&quot;&gt;XDEL&lt;/a&gt; and &lt;a href=&quot;xtrim&quot;&gt;XTRIM&lt;/a&gt;, that are able to remove data from a stream.</source>
          <target state="translated">&lt;a href=&quot;xadd&quot;&gt;XADD&lt;/a&gt; 는 스트림에 데이터를 추가 할 수 있는 &lt;em&gt;유일한 Redis 명령&lt;/em&gt; 이지만 스트림에서 데이터를 제거 할 수 있는 다른 명령 (예 : &lt;a href=&quot;xdel&quot;&gt;XDEL&lt;/a&gt; 및 &lt;a href=&quot;xtrim&quot;&gt;XTRIM&lt;/a&gt; )이 있습니다.</target>
        </trans-unit>
        <trans-unit id="bc9cadabd9309016680c77975a8ed7b6faffec47" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;xtrim&quot;&gt;XTRIM&lt;/a&gt; trims the stream to a given number of items, evicting older items (items with lower IDs) if needed. The command is conceived to accept multiple trimming strategies, however currently only a single one is implemented, which is &lt;code&gt;MAXLEN&lt;/code&gt;, and works exactly as the &lt;code&gt;MAXLEN&lt;/code&gt; option in &lt;a href=&quot;xadd&quot;&gt;XADD&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;xtrim&quot;&gt;XTRIM&lt;/a&gt; 은 스트림을 지정된 수의 항목으로 자르고 필요한 경우 오래된 항목 (ID가 낮은 항목)을 제거합니다. 이 명령은 여러 트리밍 전략을 수용하기 위해 고안되었지만 현재는 &lt;code&gt;MAXLEN&lt;/code&gt; 인 단일 전략 만 구현 되며 &lt;a href=&quot;xadd&quot;&gt;XADD&lt;/a&gt; 의 &lt;code&gt;MAXLEN&lt;/code&gt; 옵션 과 동일하게 작동합니다 .</target>
        </trans-unit>
        <trans-unit id="cc2b34b71894079f3a4247bae9140accbfa7bd62" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;zinterstore&quot;&gt;ZINTERSTORE&lt;/a&gt; - keys stop when &lt;code&gt;WEIGHT&lt;/code&gt; or &lt;code&gt;AGGREGATE&lt;/code&gt; starts</source>
          <target state="translated">&lt;a href=&quot;zinterstore&quot;&gt;ZINTERSTORE&lt;/a&gt; - &lt;code&gt;WEIGHT&lt;/code&gt; 또는 &lt;code&gt;AGGREGATE&lt;/code&gt; 가 시작 되면 키가 중지 됩니다</target>
        </trans-unit>
        <trans-unit id="ac5676feae443e91e34d888dd2a02b5b7cec1f17" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;zscan&quot;&gt;ZSCAN&lt;/a&gt; array of elements contain two elements, a member and its associated score, for every returned element of the sorted set.</source>
          <target state="translated">&lt;a href=&quot;zscan&quot;&gt;&lt;/a&gt;요소의 ZSCAN 배열에는 정렬 된 집합의 반환 된 모든 요소에 대해 두 개의 요소 (멤버와 관련 점수)가 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="867ef6f9439bd439c0289c0f4680f9547800d607" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;zscan&quot;&gt;ZSCAN&lt;/a&gt; iterates elements of Sorted Set types and their associated scores.</source>
          <target state="translated">&lt;a href=&quot;zscan&quot;&gt;ZSCAN&lt;/a&gt; 은 정렬 된 세트 유형의 요소와 관련 점수를 반복합니다.</target>
        </trans-unit>
        <trans-unit id="e6ac10c909d551bbb985cb6f990ce82f84e1591a" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;zunionstore&quot;&gt;ZUNIONSTORE&lt;/a&gt; - keys stop when &lt;code&gt;WEIGHT&lt;/code&gt; or &lt;code&gt;AGGREGATE&lt;/code&gt; starts</source>
          <target state="translated">&lt;a href=&quot;zunionstore&quot;&gt;ZUNIONSTORE&lt;/a&gt; - &lt;code&gt;WEIGHT&lt;/code&gt; 또는 &lt;code&gt;AGGREGATE&lt;/code&gt; 가 시작 되면 키가 중지 됩니다</target>
        </trans-unit>
        <trans-unit id="d152642caa36eab07b6d0f1d23a030be20ac3dec" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;&amp;gt;= 2.4&lt;/code&gt;: Accepts multiple &lt;code&gt;field&lt;/code&gt; arguments. Redis versions older than 2.4 can only remove a field per call.</source>
          <target state="translated">&lt;code&gt;&amp;gt;= 2.4&lt;/code&gt; : 여러 &lt;code&gt;field&lt;/code&gt; 인수를 허용 합니다 . 2.4 이전의 Redis 버전은 통화 당 필드 만 제거 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1fbd658f48bf6962eab3d8b19eba6deaf712ae92" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;&amp;gt;= 2.4&lt;/code&gt;: Accepts multiple &lt;code&gt;member&lt;/code&gt; arguments. Redis versions before 2.4 are only able to add a single member per call.</source>
          <target state="translated">&lt;code&gt;&amp;gt;= 2.4&lt;/code&gt; : 여러 &lt;code&gt;member&lt;/code&gt; 인수를 허용합니다 . 2.4 이전의 Redis 버전은 통화 당 하나의 멤버 만 추가 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="14a2f58a705560c76d64b68f467a11da623ed852" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;&amp;gt;= 2.4&lt;/code&gt;: Accepts multiple &lt;code&gt;member&lt;/code&gt; arguments. Redis versions older than 2.4 can only remove a set member per call.</source>
          <target state="translated">&lt;code&gt;&amp;gt;= 2.4&lt;/code&gt; : 여러 &lt;code&gt;member&lt;/code&gt; 인수를 허용합니다 . 2.4 이전의 Redis 버전은 통화 당 설정된 멤버 만 제거 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3b5a2fa9b3bf571b1535ff4a8ce7dd03406f55c8" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;&amp;gt;= 2.4&lt;/code&gt;: Accepts multiple &lt;code&gt;value&lt;/code&gt; arguments. In Redis versions older than 2.4 it was possible to push a single value per command.</source>
          <target state="translated">&lt;code&gt;&amp;gt;= 2.4&lt;/code&gt; : 여러 &lt;code&gt;value&lt;/code&gt; 인수를 허용 합니다 . 2.4 이전의 Redis 버전에서는 명령 당 단일 값을 푸시 할 수있었습니다.</target>
        </trans-unit>
        <trans-unit id="0a29c540f40c0d75c4bc54e4bfbd92975038350c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;&amp;gt;= 2.4&lt;/code&gt;: Accepts multiple elements. In Redis versions older than 2.4 it was possible to add or update a single member per call.</source>
          <target state="translated">&lt;code&gt;&amp;gt;= 2.4&lt;/code&gt; : 여러 요소를 허용합니다. 2.4 이전의 Redis 버전에서는 통화 당 단일 멤버를 추가하거나 업데이트 할 수있었습니다.</target>
        </trans-unit>
        <trans-unit id="b67f606f8a6a351cad41342c72792edc0e89e8ab" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;&amp;gt;= 2.4&lt;/code&gt;: Accepts multiple elements. In Redis versions older than 2.4 it was possible to remove a single member per call.</source>
          <target state="translated">&lt;code&gt;&amp;gt;= 2.4&lt;/code&gt; : 여러 요소를 허용합니다. 2.4 이전의 Redis 버전에서는 통화 당 단일 멤버를 제거 할 수있었습니다.</target>
        </trans-unit>
        <trans-unit id="68b30ed3ef6cc225df5d9dc21b287aea4db630d0" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;-&lt;/code&gt; and &lt;code&gt;+&lt;/code&gt; special IDs</source>
          <target state="translated">&lt;code&gt;-&lt;/code&gt; 및 &lt;code&gt;+&lt;/code&gt; 특수 ID</target>
        </trans-unit>
        <trans-unit id="6c68c96a64ce023b34b6c30c041efc57221fd313" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;0&lt;/code&gt; if &lt;code&gt;field&lt;/code&gt; already exists in the hash and no operation was performed.</source>
          <target state="translated">&lt;code&gt;0&lt;/code&gt; &lt;code&gt;field&lt;/code&gt; 이미 해시에 존재하고 조작이 수행되지 않은 경우 0 입니다.</target>
        </trans-unit>
        <trans-unit id="3191f65635efa576cd2bc89fae56e4d1efec7123" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;0&lt;/code&gt; if &lt;code&gt;field&lt;/code&gt; already exists in the hash and the value was updated.</source>
          <target state="translated">&lt;code&gt;0&lt;/code&gt; &lt;code&gt;field&lt;/code&gt; 이미 해시에 존재하고 값이 업데이트 된 경우 0 입니다.</target>
        </trans-unit>
        <trans-unit id="f60d54a05f28427b7c458dfeea13aed8c56289b1" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;0&lt;/code&gt; if &lt;code&gt;key&lt;/code&gt; does not exist or does not have an associated timeout.</source>
          <target state="translated">&lt;code&gt;0&lt;/code&gt; &lt;code&gt;key&lt;/code&gt; 가 없거나 관련 시간 초과가없는 경우 0 입니다.</target>
        </trans-unit>
        <trans-unit id="0e90c08d49825baab6c37e159792566e7fe213b1" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;0&lt;/code&gt; if &lt;code&gt;key&lt;/code&gt; does not exist.</source>
          <target state="translated">&lt;code&gt;0&lt;/code&gt; 경우 &lt;code&gt;key&lt;/code&gt; 존재하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="725cc7114dc7226e3481e48740555b2efda8bbe2" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;0&lt;/code&gt; if &lt;code&gt;key&lt;/code&gt; was not moved.</source>
          <target state="translated">&lt;code&gt;0&lt;/code&gt; &lt;code&gt;key&lt;/code&gt; 가 이동되지 않은 경우 0</target>
        </trans-unit>
        <trans-unit id="d6992634edf02774fe46f2df3da515a7dcb33bc9" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;0&lt;/code&gt; if &lt;code&gt;newkey&lt;/code&gt; already exists.</source>
          <target state="translated">&lt;code&gt;0&lt;/code&gt; 경우 &lt;code&gt;newkey&lt;/code&gt; 는 이미 존재합니다.</target>
        </trans-unit>
        <trans-unit id="14262ac0700869ff357af1a9263d20742a687fd8" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;0&lt;/code&gt; if no key was set (at least one key already existed).</source>
          <target state="translated">&lt;code&gt;0&lt;/code&gt; 키가 설정되지 않은 경우 0 이상 (이미 하나 이상의 키가 이미 존재)</target>
        </trans-unit>
        <trans-unit id="c2861cd3b06dcac8af5ba597b6aaf182b6746c07" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;0&lt;/code&gt; if the element is not a member of &lt;code&gt;source&lt;/code&gt; and no operation was performed.</source>
          <target state="translated">&lt;code&gt;0&lt;/code&gt; 요소가 &lt;code&gt;source&lt;/code&gt; 의 구성원이 아니고 조작이 수행 되지 않은 경우 0 입니다.</target>
        </trans-unit>
        <trans-unit id="501932831346881f94c70b73cf0328c70169646f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;0&lt;/code&gt; if the element is not a member of the set, or if &lt;code&gt;key&lt;/code&gt; does not exist.</source>
          <target state="translated">&lt;code&gt;0&lt;/code&gt; 요소가 세트의 멤버가 아니거나 &lt;code&gt;key&lt;/code&gt; 가없는 경우 0 입니다.</target>
        </trans-unit>
        <trans-unit id="6407eb5e9c5935f4ed492dcb89e94f023ccdf9ba" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;0&lt;/code&gt; if the hash does not contain &lt;code&gt;field&lt;/code&gt;, or &lt;code&gt;key&lt;/code&gt; does not exist.</source>
          <target state="translated">&lt;code&gt;0&lt;/code&gt; 해시에 &lt;code&gt;field&lt;/code&gt; 가 없거나 &lt;code&gt;key&lt;/code&gt; 가없는 경우 0 입니다.</target>
        </trans-unit>
        <trans-unit id="a38cf5b0f740f8566febdf0cbf54b8a6348e5ee7" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;0&lt;/code&gt; if the key does not exist.</source>
          <target state="translated">&lt;code&gt;0&lt;/code&gt; 키가 없으면 0 입니다.</target>
        </trans-unit>
        <trans-unit id="4d32094a29f0ac2ad9de4aac6bfd6bb719d8b12a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;0&lt;/code&gt; if the key was not set</source>
          <target state="translated">&lt;code&gt;0&lt;/code&gt; 키가 설정되지 않은 경우 0</target>
        </trans-unit>
        <trans-unit id="9112bae35f4e833d9c58ae1e088d7112f88532b5" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;1&lt;/code&gt; if &lt;code&gt;field&lt;/code&gt; is a new field in the hash and &lt;code&gt;value&lt;/code&gt; was set.</source>
          <target state="translated">&lt;code&gt;1&lt;/code&gt; 만약 &lt;code&gt;field&lt;/code&gt; 해시와 새로운 필드되는 &lt;code&gt;value&lt;/code&gt; 으로 설정 하였다.</target>
        </trans-unit>
        <trans-unit id="ad304a107eee2d23e48e6c8d1661cf1988b486aa" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;1&lt;/code&gt; if &lt;code&gt;key&lt;/code&gt; was moved.</source>
          <target state="translated">&lt;code&gt;1&lt;/code&gt; &lt;code&gt;key&lt;/code&gt; 가 이동 된 경우 1</target>
        </trans-unit>
        <trans-unit id="ddcb872ed9ff94749e13ac136d245a411771aa0b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;1&lt;/code&gt; if &lt;code&gt;key&lt;/code&gt; was renamed to &lt;code&gt;newkey&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;1&lt;/code&gt; 만약 &lt;code&gt;key&lt;/code&gt; 이름이 바뀌 었습니다 &lt;code&gt;newkey&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="341d2d89bf2d4bfb6d516bebefd62ffd165f4ec3" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;1&lt;/code&gt; if the all the keys were set.</source>
          <target state="translated">&lt;code&gt;1&lt;/code&gt; 모든 키가 설정된 경우 1 입니다.</target>
        </trans-unit>
        <trans-unit id="bcdd51deb57a70d0ba07630a412d7d995a6f5301" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;1&lt;/code&gt; if the element is a member of the set.</source>
          <target state="translated">&lt;code&gt;1&lt;/code&gt; 요소가 세트의 멤버 인 경우 1 입니다.</target>
        </trans-unit>
        <trans-unit id="8012d2a9e6de3d4f6aa995d8b0eb71b27ecab804" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;1&lt;/code&gt; if the element is moved.</source>
          <target state="translated">&lt;code&gt;1&lt;/code&gt; 요소가 이동 된 경우 1 입니다.</target>
        </trans-unit>
        <trans-unit id="0d1478b0e1e73b8b91c455906d3e90df5c5e2ca6" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;1&lt;/code&gt; if the hash contains &lt;code&gt;field&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;1&lt;/code&gt; 해시에 &lt;code&gt;field&lt;/code&gt; 가 포함되어 있으면 1 입니다 .</target>
        </trans-unit>
        <trans-unit id="4964a69975cd68bffbd62012c286e3806522a2a3" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;1&lt;/code&gt; if the key exists.</source>
          <target state="translated">&lt;code&gt;1&lt;/code&gt; 키가 존재하면 1 입니다.</target>
        </trans-unit>
        <trans-unit id="5ba5ae48b6694671ffa81ecdf4e1a12b5bc46b52" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;1&lt;/code&gt; if the key was set</source>
          <target state="translated">&lt;code&gt;1&lt;/code&gt; 키가 설정된 경우 1</target>
        </trans-unit>
        <trans-unit id="3506c8ce49c5ce58781eb39cc319b37e03f3f3b1" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;1&lt;/code&gt; if the timeout was removed.</source>
          <target state="translated">&lt;code&gt;1&lt;/code&gt; 시간 초과가 제거 된 경우 1 입니다.</target>
        </trans-unit>
        <trans-unit id="39ccd17679d67dc4ecbd128f3c112d2bf236a020" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;1&lt;/code&gt; if the timeout was set.</source>
          <target state="translated">&lt;code&gt;1&lt;/code&gt; 시간 초과가 설정된 경우 1 입니다.</target>
        </trans-unit>
        <trans-unit id="dbbf79b9bf3b6f87c5d713fb0e1055cb163dd947" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;ASC&lt;/code&gt;: Sort returned items from the nearest to the farthest, relative to the center.</source>
          <target state="translated">&lt;code&gt;ASC&lt;/code&gt; : 반품을 기준으로 가장 가까운 것부터 가장 먼 것까지 정렬합니다.</target>
        </trans-unit>
        <trans-unit id="eb836fd89c30980649b496a65a6cd12d77d066b0" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;BLPOP&lt;/code&gt; inside a &lt;code&gt;MULTI&lt;/code&gt; / &lt;code&gt;EXEC&lt;/code&gt; transaction</source>
          <target state="translated">&lt;code&gt;BLPOP&lt;/code&gt; &lt;code&gt;MULTI&lt;/code&gt; / &lt;code&gt;EXEC&lt;/code&gt; 트랜잭션 내부의 BLPOP</target>
        </trans-unit>
        <trans-unit id="a5f1a178f5cdd8cdf5152e93b36fdb7a83b660dc" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;CLIENT KILL ADDR ip:port&lt;/code&gt;. This is exactly the same as the old three-arguments behavior.</source>
          <target state="translated">&lt;code&gt;CLIENT KILL ADDR ip:port&lt;/code&gt; . 이것은 이전 세 인수 동작과 동일합니다.</target>
        </trans-unit>
        <trans-unit id="602320634fef925cb5009f27adc89c96fad31e12" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;CLIENT KILL ID client-id&lt;/code&gt;. Allows to kill a client by its unique &lt;code&gt;ID&lt;/code&gt; field, which was introduced in the &lt;a href=&quot;client-list&quot;&gt;CLIENT LIST&lt;/a&gt; command starting from Redis 2.8.12.</source>
          <target state="translated">&lt;code&gt;CLIENT KILL ID client-id&lt;/code&gt; . Redis 2.8.12부터 &lt;a href=&quot;client-list&quot;&gt;CLIENT LIST&lt;/a&gt; 명령 에 도입 된 고유 &lt;code&gt;ID&lt;/code&gt; 필드로 클라이언트를 강제 종료 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="55aa9e9d040d810292c5cbe0fb9ec86006c8c89e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;CLIENT KILL SKIPME yes/no&lt;/code&gt;. By default this option is set to &lt;code&gt;yes&lt;/code&gt;, that is, the client calling the command will not get killed, however setting this option to &lt;code&gt;no&lt;/code&gt; will have the effect of also killing the client calling the command.</source>
          <target state="translated">&lt;code&gt;CLIENT KILL SKIPME yes/no&lt;/code&gt; . 기본적으로이 옵션은 &lt;code&gt;yes&lt;/code&gt; 로 설정됩니다 . 즉, 명령을 호출하는 클라이언트는 종료되지 않지만이 옵션을 &lt;code&gt;no&lt;/code&gt; 로 설정 하면 명령을 호출하는 클라이언트도 종료하는 효과가 있습니다.</target>
        </trans-unit>
        <trans-unit id="11752fd7703f3053fd849cf8479195d68449607c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;CLIENT KILL TYPE type&lt;/code&gt;, where &lt;em&gt;type&lt;/em&gt; is one of &lt;code&gt;normal&lt;/code&gt;, &lt;code&gt;master&lt;/code&gt;, &lt;code&gt;slave&lt;/code&gt; and &lt;code&gt;pubsub&lt;/code&gt; (the &lt;code&gt;master&lt;/code&gt; type is available from v3.2). This closes the connections of &lt;strong&gt;all the clients&lt;/strong&gt; in the specified class. Note that clients blocked into the &lt;a href=&quot;monitor&quot;&gt;MONITOR&lt;/a&gt; command are considered to belong to the &lt;code&gt;normal&lt;/code&gt; class.</source>
          <target state="translated">&lt;code&gt;CLIENT KILL TYPE type&lt;/code&gt; , 여기서 &lt;em&gt;type&lt;/em&gt; 은 &lt;code&gt;normal&lt;/code&gt; , &lt;code&gt;master&lt;/code&gt; , &lt;code&gt;slave&lt;/code&gt; 및 &lt;code&gt;pubsub&lt;/code&gt; 중 하나입니다 ( &lt;code&gt;master&lt;/code&gt; 유형은 v3.2에서 사용 가능함). 지정된 클래스 의 &lt;strong&gt;모든 클라이언트&lt;/strong&gt; 연결이 닫힙니다 . &lt;a href=&quot;monitor&quot;&gt;MONITOR&lt;/a&gt; 명령 으로 차단 된 클라이언트 는 &lt;code&gt;normal&lt;/code&gt; 클래스 에 속하는 것으로 간주됩니다 .</target>
        </trans-unit>
        <trans-unit id="fef0710bd872cf9a625ed7b0d01b954d4f4b4278" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;COPY&lt;/code&gt; -- Do not remove the key from the local instance.</source>
          <target state="translated">&lt;code&gt;COPY&lt;/code&gt; -로컬 인스턴스에서 키를 제거하지 마십시오.</target>
        </trans-unit>
        <trans-unit id="828b06065edba3099f79eed73ccd5e091eb0282f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;COPY&lt;/code&gt; and &lt;code&gt;REPLACE&lt;/code&gt; are available only in 3.0 and above. &lt;a href=&quot;keys&quot;&gt;KEYS&lt;/a&gt; is available starting with Redis 3.0.6.</source>
          <target state="translated">&lt;code&gt;COPY&lt;/code&gt; 와 &lt;code&gt;REPLACE&lt;/code&gt; 는 3.0 이상에서만 사용할 수 있습니다. &lt;a href=&quot;keys&quot;&gt;KEYS&lt;/a&gt; 는 Redis 3.0.6부터 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4f62ca2831b2ba2e4a09d54fcced7c7ad2005546" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;DESC&lt;/code&gt;: Sort returned items from the farthest to the nearest, relative to the center.</source>
          <target state="translated">&lt;code&gt;DESC&lt;/code&gt; : 중심을 기준으로 가장 먼 곳에서 가장 가까운 곳으로 반품 된 항목을 정렬합니다.</target>
        </trans-unit>
        <trans-unit id="2d6218812bbcf1c765cc87c431fb22bb0bce1f6e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;EX&lt;/code&gt;&lt;em&gt;seconds&lt;/em&gt; -- Set the specified expire time, in seconds.</source>
          <target state="translated">&lt;code&gt;EX&lt;/code&gt; &lt;em&gt;초&lt;/em&gt; -지정된 만료 시간을 초 단위로 설정합니다.</target>
        </trans-unit>
        <trans-unit id="b3d494972651313811f4ea2e6bc9a01e6a48e42f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;FLUSHALL ASYNC&lt;/code&gt; (Redis 4.0.0 or greater)</source>
          <target state="translated">&lt;code&gt;FLUSHALL ASYNC&lt;/code&gt; (Redis 4.0.0 이상)</target>
        </trans-unit>
        <trans-unit id="399e38e4824210c8cdff06a324d4018a9eecea21" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;FLUSHDB ASYNC&lt;/code&gt; (Redis 4.0.0 or greater)</source>
          <target state="translated">&lt;code&gt;FLUSHDB ASYNC&lt;/code&gt; (Redis 4.0.0 이상)</target>
        </trans-unit>
        <trans-unit id="f9d2f7dec2da389f490ae42cc555c3ae4e347930" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;FORCE&lt;/code&gt;: Creates the pending message entry in the PEL even if certain specified IDs are not already in the PEL assigned to a different client. However the message must be exist in the stream, otherwise the IDs of non existing messages are ignored.</source>
          <target state="translated">&lt;code&gt;FORCE&lt;/code&gt; : 지정된 특정 ID가 다른 클라이언트에 지정된 PEL에없는 경우에도 PEL에 보류중인 메시지 항목을 작성합니다. 그러나 메시지가 스트림에 존재해야합니다. 그렇지 않으면 기존 메시지가 아닌 메시지의 ID는 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="fef98736f61e1a786364eb654ce1fb11f47f4232" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;IDLE &amp;lt;ms&amp;gt;&lt;/code&gt;: Set the idle time (last time it was delivered) of the message. If IDLE is not specified, an IDLE of 0 is assumed, that is, the time count is reset because the message has now a new owner trying to process it.</source>
          <target state="translated">&lt;code&gt;IDLE &amp;lt;ms&amp;gt;&lt;/code&gt; : 메시지의 유휴 시간 (마지막으로 배달 된 시간)을 설정합니다. IDLE을 지정하지 않으면 IDLE이 0으로 가정됩니다. 즉, 메시지를 처리하려고하는 새 소유자가 있으므로 시간 계수가 재설정됩니다.</target>
        </trans-unit>
        <trans-unit id="f02fe3441db92a399bf47bc889f6610d203389df" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;IMPORTING&lt;/code&gt; subcommand: Set a hash slot in &lt;em&gt;importing&lt;/em&gt; state.</source>
          <target state="translated">&lt;code&gt;IMPORTING&lt;/code&gt; 부속 명령 : &lt;em&gt;가져 오기&lt;/em&gt; 상태 에서 해시 슬롯을 설정하십시오 .</target>
        </trans-unit>
        <trans-unit id="2e12dd8507767dd78f37c7b15b7c53df7e1f55fb" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;JUSTID&lt;/code&gt;: Return just an array of IDs of messages successfully claimed, without returning the actual message.</source>
          <target state="translated">&lt;code&gt;JUSTID&lt;/code&gt; : 실제 메시지를 반환하지 않고 성공적으로 청구 된 메시지의 ID 배열 만 반환합니다.</target>
        </trans-unit>
        <trans-unit id="5417b35857fc0642ff95207d9855306db80441f5" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;MIGRATING&lt;/code&gt; subcommand: Set a hash slot in &lt;em&gt;migrating&lt;/em&gt; state.</source>
          <target state="translated">&lt;code&gt;MIGRATING&lt;/code&gt; 부속 명령 : 해시 슬롯을 &lt;em&gt;이주&lt;/em&gt; 상태로 설정하십시오 .</target>
        </trans-unit>
        <trans-unit id="70764755b0a2c7ba46c7bf3843b05fe37082a3f0" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;NO&lt;/code&gt;. Disables scripts debug mode.</source>
          <target state="translated">&lt;code&gt;NO&lt;/code&gt; . 스크립트 디버그 모드를 비활성화합니다.</target>
        </trans-unit>
        <trans-unit id="514412efa136bf26067924d8e9e64aeaa793f898" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;NODE&lt;/code&gt; subcommand: Bind the hash slot to a different node.</source>
          <target state="translated">&lt;code&gt;NODE&lt;/code&gt; 부속 명령 : 해시 슬롯을 다른 노드에 바인드하십시오.</target>
        </trans-unit>
        <trans-unit id="cd0e3ba7650821204046fdf9c4755dd7ba904ffc" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;NX&lt;/code&gt; -- Only set the key if it does not already exist.</source>
          <target state="translated">&lt;code&gt;NX&lt;/code&gt; - 키가없는 경우에만 키를 설정하십시오.</target>
        </trans-unit>
        <trans-unit id="99882af89cf8e3e05714f50d2c0743b952d2d3c5" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;OBJECT ENCODING &amp;lt;key&amp;gt;&lt;/code&gt; returns the kind of internal representation used in order to store the value associated with a key.</source>
          <target state="translated">&lt;code&gt;OBJECT ENCODING &amp;lt;key&amp;gt;&lt;/code&gt; 는 키와 관련된 값을 저장하는 데 사용되는 내부 표현 종류를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="ed8a8556a6d1374927ff1ce94213046f672ffd9c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;OBJECT FREQ &amp;lt;key&amp;gt;&lt;/code&gt; returns the logarithmic access frequency counter of the object stored at the specified key. This subcommand is available when &lt;code&gt;maxmemory-policy&lt;/code&gt; is set to an LFU policy.</source>
          <target state="translated">&lt;code&gt;OBJECT FREQ &amp;lt;key&amp;gt;&lt;/code&gt; 는 지정된 키에 저장된 객체의 로그 액세스 빈도 카운터를 반환합니다. &lt;code&gt;maxmemory-policy&lt;/code&gt; 가 LFU 정책으로 설정된 경우이 하위 명령을 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="f3480c780052d6d5327144f1f0dc8cf03ca4c9a8" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;OBJECT HELP&lt;/code&gt; returns a succint help text.</source>
          <target state="translated">&lt;code&gt;OBJECT HELP&lt;/code&gt; 는 간결한 도움말 텍스트를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="888f9bddf5ef83f498988c713f090f957d312a9c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;OBJECT IDLETIME &amp;lt;key&amp;gt;&lt;/code&gt; returns the number of seconds since the object stored at the specified key is idle (not requested by read or write operations). While the value is returned in seconds the actual resolution of this timer is 10 seconds, but may vary in future implementations. This subcommand is available when &lt;code&gt;maxmemory-policy&lt;/code&gt; is set to an LRU policy or &lt;code&gt;noeviction&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;OBJECT IDLETIME &amp;lt;key&amp;gt;&lt;/code&gt; 는 지정된 키에 저장된 객체가 유휴 상태 (초기 또는 쓰기 작업에 의해 요청되지 않음)이므로 초 수를 반환합니다. 값이 초 단위로 반환되는 동안이 타이머의 실제 해상도는 10 초이지만 향후 구현에 따라 다를 수 있습니다. &lt;code&gt;maxmemory-policy&lt;/code&gt; 가 LRU 정책 또는 &lt;code&gt;noeviction&lt;/code&gt; 으로 설정된 경우이 하위 명령을 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="cc2fb84c1222faa39f7ea74dcd933f7cc2ace4ae" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;OBJECT REFCOUNT &amp;lt;key&amp;gt;&lt;/code&gt; returns the number of references of the value associated with the specified key. This command is mainly useful for debugging.</source>
          <target state="translated">&lt;code&gt;OBJECT REFCOUNT &amp;lt;key&amp;gt;&lt;/code&gt; 는 지정된 키와 관련된 값의 참조 수를 반환합니다. 이 명령은 주로 디버깅에 유용합니다.</target>
        </trans-unit>
        <trans-unit id="a2453b4fb0091e83c1695ab282efa77025e36e17" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;OFF&lt;/code&gt;. In this mode the server will not reply to client commands.</source>
          <target state="translated">&lt;code&gt;OFF&lt;/code&gt; . 이 모드에서 서버는 클라이언트 명령에 응답하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="ee0e7c54a09f4affa491d8d7021f3854e2d54006" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;ON&lt;/code&gt;. This is the default mode in which the server returns a reply to every command.</source>
          <target state="translated">&lt;code&gt;ON&lt;/code&gt; . 서버가 모든 명령에 대한 응답을 반환하는 기본 모드입니다.</target>
        </trans-unit>
        <trans-unit id="a6629a2a7ab460a79b8e2163eeb985a87da0ddcf" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;PX&lt;/code&gt;&lt;em&gt;milliseconds&lt;/em&gt; -- Set the specified expire time, in milliseconds.</source>
          <target state="translated">&lt;code&gt;PX&lt;/code&gt; &lt;em&gt;밀리 초&lt;/em&gt; -지정된 만료 시간을 밀리 초로 설정합니다.</target>
        </trans-unit>
        <trans-unit id="80297e99327c2c150c0093cfc256780a8b53c387" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;REPLACE&lt;/code&gt; -- Replace existing key on the remote instance.</source>
          <target state="translated">&lt;code&gt;REPLACE&lt;/code&gt; - 원격 인스턴스에서 기존 키를 바꿉니다.</target>
        </trans-unit>
        <trans-unit id="cc6115b3d47b177464bb118184086a7cc3fac61b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;RETRYCOUNT &amp;lt;count&amp;gt;&lt;/code&gt;: Set the retry counter to the specified value. This counter is incremented every time a message is delivered again. Normally &lt;a href=&quot;xclaim&quot;&gt;XCLAIM&lt;/a&gt; does not alter this counter, which is just served to clients when the XPENDING command is called: this way clients can detect anomalies, like messages that are never processed for some reason after a big number of delivery attempts.</source>
          <target state="translated">&lt;code&gt;RETRYCOUNT &amp;lt;count&amp;gt;&lt;/code&gt; : 재시도 카운터를 지정된 값으로 설정하십시오. 이 카운터는 메시지가 다시 배달 될 때마다 증가합니다. 일반적으로 &lt;a href=&quot;xclaim&quot;&gt;XCLAIM&lt;/a&gt; 은 XPENDING 명령이 호출 될 때 클라이언트에게만 제공되는이 카운터를 변경하지 않습니다.이 방법으로 클라이언트는 많은 수의 배달 시도 후 어떤 이유로 처리되지 않은 메시지와 같은 예외를 감지 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4ffbe13e1233b7e9c1174988bffadee0a3b98857" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;SKIP&lt;/code&gt;. This mode skips the reply of command immediately after it.</source>
          <target state="translated">&lt;code&gt;SKIP&lt;/code&gt; . 이 모드는 명령 직후에 응답을 건너 뜁니다.</target>
        </trans-unit>
        <trans-unit id="f1ff247a0db526f7a11f6f1afcd40dcb67292ccf" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;STABLE&lt;/code&gt; subcommand: Clear any importing / migrating state from hash slot.</source>
          <target state="translated">&lt;code&gt;STABLE&lt;/code&gt; 부속 명령 : 해시 슬롯에서 가져 오기 / 마이그레이션 상태를 지우십시오.</target>
        </trans-unit>
        <trans-unit id="3368cd450f9f6cc2baea198c405095f6d0a009a1" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;TIME &amp;lt;ms-unix-time&amp;gt;&lt;/code&gt;: This is the same as IDLE but instead of a relative amount of milliseconds, it sets the idle time to a specific Unix time (in milliseconds). This is useful in order to rewrite the AOF file generating &lt;a href=&quot;xclaim&quot;&gt;XCLAIM&lt;/a&gt; commands.</source>
          <target state="translated">&lt;code&gt;TIME &amp;lt;ms-unix-time&amp;gt;&lt;/code&gt; : IDLE과 동일하지만 상대적인 밀리 초 대신 유휴 시간을 특정 유닉스 시간 (밀리 초)으로 설정합니다. &lt;a href=&quot;xclaim&quot;&gt;XCLAIM&lt;/a&gt; 명령을 생성하는 AOF 파일을 다시 작성하는 데 유용 합니다.</target>
        </trans-unit>
        <trans-unit id="f68fc34e1d6f2a26a1a2c15ca15742080415f576" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;WITHCOORD&lt;/code&gt;: Also return the longitude,latitude coordinates of the matching items.</source>
          <target state="translated">&lt;code&gt;WITHCOORD&lt;/code&gt; : 일치하는 항목의 경도, 위도 좌표를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="72e1da1bf7742af54c060cdc9d133362fecb89c4" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;WITHDIST&lt;/code&gt;: Also return the distance of the returned items from the specified center. The distance is returned in the same unit as the unit specified as the radius argument of the command.</source>
          <target state="translated">&lt;code&gt;WITHDIST&lt;/code&gt; : 반환 된 품목의 거리를 지정된 중심에서 반환합니다. 거리는 명령의 반경 인수로 지정된 단위와 동일한 단위로 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="33ca4bb6415c9fb0f6b1095fd636200907df4c73" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;WITHHASH&lt;/code&gt;: Also return the raw geohash-encoded sorted set score of the item, in the form of a 52 bit unsigned integer. This is only useful for low level hacks or debugging and is otherwise of little interest for the general user.</source>
          <target state="translated">&lt;code&gt;WITHHASH&lt;/code&gt; : 또한 항목의 원시 지오 해시 인코딩 정렬 집합 점수를 부호없는 52 비트 정수 형식으로 반환합니다. 이것은 낮은 수준의 해킹이나 디버깅에만 유용하며 일반 사용자에게는 거의 관심이 없습니다.</target>
        </trans-unit>
        <trans-unit id="a83721d6bd94ce6aaf576b5f05c13b2637597325" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;XX&lt;/code&gt; -- Only set the key if it already exist.</source>
          <target state="translated">&lt;code&gt;XX&lt;/code&gt; - 키가 이미있는 경우에만 설정하십시오.</target>
        </trans-unit>
        <trans-unit id="e079471709a901605c3eb58f108833d504b6b11e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;YES&lt;/code&gt;. Enable non-blocking asynchronous debugging of Lua scripts (changes are discarded).</source>
          <target state="translated">&lt;code&gt;YES&lt;/code&gt; . Lua 스크립트의 비 차단 비동기 디버깅을 활성화합니다 (변경 사항은 무시 됨).</target>
        </trans-unit>
        <trans-unit id="a22f353861e10e014106fd90471171473f27d38b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;active_defrag_hits&lt;/code&gt;: Number of value reallocations performed by active the defragmentation process</source>
          <target state="translated">&lt;code&gt;active_defrag_hits&lt;/code&gt; : 조각 모음 프로세스를 활성화하여 수행 한 값 재 할당 수</target>
        </trans-unit>
        <trans-unit id="7fdfcb3c13a7acba7f324056f0c4b7810d7f027b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;active_defrag_key_hits&lt;/code&gt;: Number of keys that were actively defragmented</source>
          <target state="translated">&lt;code&gt;active_defrag_key_hits&lt;/code&gt; : 적극적으로 조각 모음 된 키 수</target>
        </trans-unit>
        <trans-unit id="f86b40e0f88f935634beee0a4d5b5a33fef34db9" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;active_defrag_key_misses&lt;/code&gt;: Number of keys that were skipped by the active defragmentation process</source>
          <target state="translated">&lt;code&gt;active_defrag_key_misses&lt;/code&gt; : 활성 조각 모음 프로세스에서 건너 뛴 키 수</target>
        </trans-unit>
        <trans-unit id="10ba93594ceb8bd562cba3fffdd70835558dc8af" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;active_defrag_misses&lt;/code&gt;: Number of aborted value reallocations started by the active defragmentation process</source>
          <target state="translated">&lt;code&gt;active_defrag_misses&lt;/code&gt; : 활성 조각 모음 프로세스에 의해 시작된 중단 된 값 재 할당 수</target>
        </trans-unit>
        <trans-unit id="4f522f6f70a7ce761d1960901b0078ee984f4d7a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;active_defrag_running&lt;/code&gt;: Flag indicating if active defragmentation is active</source>
          <target state="translated">&lt;code&gt;active_defrag_running&lt;/code&gt; : 활성 조각 모음이 활성화되어 있는지를 나타내는 플래그</target>
        </trans-unit>
        <trans-unit id="32a776559f2ca409db7316c86f8021c0bd6163b4" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;addr&lt;/code&gt;: address/port of the client</source>
          <target state="translated">&lt;code&gt;addr&lt;/code&gt; : 클라이언트의 주소 / 포트</target>
        </trans-unit>
        <trans-unit id="0b418934c029a0535c7714965414f4d0cd7d9794" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;age&lt;/code&gt;: total duration of the connection in seconds</source>
          <target state="translated">&lt;code&gt;age&lt;/code&gt; : 연결의 총 지속 시간 (초)</target>
        </trans-unit>
        <trans-unit id="cd018df00bb4d052d465c766526aefcac8623f09" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;all&lt;/code&gt;: Return all sections</source>
          <target state="translated">&lt;code&gt;all&lt;/code&gt; : 모든 섹션을 반환</target>
        </trans-unit>
        <trans-unit id="edddb993a22213f8ae5d530d19608128b3d90819" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;aof.buffer&lt;/code&gt;: The summed size in bytes of the current and rewrite AOF buffers (see &lt;a href=&quot;info&quot;&gt;INFO&lt;/a&gt;'s &lt;code&gt;aof_buffer_length&lt;/code&gt; and &lt;code&gt;aof_rewrite_buffer_length&lt;/code&gt;, respectively)</source>
          <target state="translated">&lt;code&gt;aof.buffer&lt;/code&gt; : 현재 및 재 작성 AOF 버퍼의 합계 크기 (바이트) ( 각각 &lt;a href=&quot;info&quot;&gt;INFO&lt;/a&gt; 의 &lt;code&gt;aof_buffer_length&lt;/code&gt; 및 &lt;code&gt;aof_rewrite_buffer_length&lt;/code&gt; 참조 )</target>
        </trans-unit>
        <trans-unit id="1ff4db2d3af80e789a0995ce723660c4de7d6f05" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;aof_base_size&lt;/code&gt;: AOF file size on latest startup or rewrite</source>
          <target state="translated">&lt;code&gt;aof_base_size&lt;/code&gt; : 최신 시작 또는 다시 쓰기시 AOF 파일 크기</target>
        </trans-unit>
        <trans-unit id="8632791e26fdcef3f4a9f344241b92f2afc74dd7" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;aof_buffer_length&lt;/code&gt;: Size of the AOF buffer</source>
          <target state="translated">&lt;code&gt;aof_buffer_length&lt;/code&gt; : AOF 버퍼의 크기</target>
        </trans-unit>
        <trans-unit id="97014e76a8ce9b991e26a3100de786bbc394c893" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;aof_current_rewrite_time_sec&lt;/code&gt;: Duration of the on-going AOF rewrite operation if any</source>
          <target state="translated">&lt;code&gt;aof_current_rewrite_time_sec&lt;/code&gt; : 진행중인 AOF 다시 쓰기 작업이있는 경우 지속 기간</target>
        </trans-unit>
        <trans-unit id="ac32c8b2ccb90d460c7b5861f1d179abec9ee8da" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;aof_current_size&lt;/code&gt;: AOF current file size</source>
          <target state="translated">&lt;code&gt;aof_current_size&lt;/code&gt; : AOF 현재 파일 크기</target>
        </trans-unit>
        <trans-unit id="021a62752235de2b7c632ebf2af7a48fa5178011" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;aof_delayed_fsync&lt;/code&gt;: Delayed fsync counter</source>
          <target state="translated">&lt;code&gt;aof_delayed_fsync&lt;/code&gt; : 지연된 fsync 카운터</target>
        </trans-unit>
        <trans-unit id="24fd6a9ea8f45fb36a9eeb7c56056061cbe44e14" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;aof_enabled&lt;/code&gt;: Flag indicating AOF logging is activated</source>
          <target state="translated">&lt;code&gt;aof_enabled&lt;/code&gt; : AOF 로깅이 활성화되었음을 나타내는 플래그</target>
        </trans-unit>
        <trans-unit id="1e6a012770c4c4c182917c7ed5289c5f531614fe" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;aof_last_bgrewrite_status&lt;/code&gt;: Status of the last AOF rewrite operation</source>
          <target state="translated">&lt;code&gt;aof_last_bgrewrite_status&lt;/code&gt; : 마지막 AOF 다시 쓰기 작업의 상태</target>
        </trans-unit>
        <trans-unit id="fb606e1eef2327d509f09e01f9add96e415822d3" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;aof_last_cow_size&lt;/code&gt;: The size in bytes of copy-on-write allocations during the last AOF rewrite operation</source>
          <target state="translated">&lt;code&gt;aof_last_cow_size&lt;/code&gt; : 마지막 AOF 다시 쓰기 작업 중 쓰기시 복사 할당의 크기 (바이트)</target>
        </trans-unit>
        <trans-unit id="a5d5e6a33c8ed12d83cca0b06fbee5244ee6ba41" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;aof_last_rewrite_time_sec&lt;/code&gt;: Duration of the last AOF rewrite operation in seconds</source>
          <target state="translated">&lt;code&gt;aof_last_rewrite_time_sec&lt;/code&gt; : 마지막 AOF 다시 쓰기 작업의 지속 시간 (초)</target>
        </trans-unit>
        <trans-unit id="c1db165470a23cb6ec719da8932a40f4ea09ab81" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;aof_last_write_status&lt;/code&gt;: Status of the last write operation to the AOF</source>
          <target state="translated">&lt;code&gt;aof_last_write_status&lt;/code&gt; : AOF에 대한 마지막 쓰기 작업의 상태</target>
        </trans-unit>
        <trans-unit id="cba340ede5eb173bc4558c50d221e3ab3a1765c6" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;aof_pending_bio_fsync&lt;/code&gt;: Number of fsync pending jobs in background I/O queue</source>
          <target state="translated">&lt;code&gt;aof_pending_bio_fsync&lt;/code&gt; : 백그라운드 I / O 대기열에있는 fsync 보류 작업 수</target>
        </trans-unit>
        <trans-unit id="49f338748e7ef39a92b2e18297472c8ebf2461ae" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;aof_pending_rewrite&lt;/code&gt;: Flag indicating an AOF rewrite operation will be scheduled once the on-going RDB save is complete.</source>
          <target state="translated">&lt;code&gt;aof_pending_rewrite&lt;/code&gt; : 진행중인 RDB 저장이 완료되면 AOF 다시 쓰기 작업을 나타내는 플래그가 예약됩니다.</target>
        </trans-unit>
        <trans-unit id="4b10e1836e92feeff66d3326e4c2d7f1bf8909b7" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;aof_rewrite_buffer_length&lt;/code&gt;: Size of the AOF rewrite buffer</source>
          <target state="translated">&lt;code&gt;aof_rewrite_buffer_length&lt;/code&gt; : AOF 다시 쓰기 버퍼의 크기</target>
        </trans-unit>
        <trans-unit id="90ad968000b75b18f076c4d369ff364d5516d20d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;aof_rewrite_in_progress&lt;/code&gt;: Flag indicating a AOF rewrite operation is on-going</source>
          <target state="translated">&lt;code&gt;aof_rewrite_in_progress&lt;/code&gt; : AOF 다시 쓰기 작업이 진행 중임을 나타내는 플래그</target>
        </trans-unit>
        <trans-unit id="860eb37aa85d675719b691b7665a36bac01eb96f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;aof_rewrite_scheduled&lt;/code&gt;: Flag indicating an AOF rewrite operation will be scheduled once the on-going RDB save is complete.</source>
          <target state="translated">&lt;code&gt;aof_rewrite_scheduled&lt;/code&gt; : 진행중인 RDB 저장이 완료되면 AOF 다시 쓰기 작업을 나타내는 플래그가 예약됩니다.</target>
        </trans-unit>
        <trans-unit id="8b6b438717bec11dfc97f6d4213c363347e98d05" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;arch_bits&lt;/code&gt;: Architecture (32 or 64 bits)</source>
          <target state="translated">&lt;code&gt;arch_bits&lt;/code&gt; : 아키텍처 (32 또는 64 비트)</target>
        </trans-unit>
        <trans-unit id="9c55751797332d8d9b526a675ac4969063b50b6c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;atomicvar_api&lt;/code&gt;: Atomicvar API used by Redis</source>
          <target state="translated">&lt;code&gt;atomicvar_api&lt;/code&gt; : Redis에서 사용하는 Atomicvar API</target>
        </trans-unit>
        <trans-unit id="b0f927aba00ccf6192ec1758a98f6c0004f29e02" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;base&lt;/code&gt; lib.</source>
          <target state="translated">&lt;code&gt;base&lt;/code&gt; lib.</target>
        </trans-unit>
        <trans-unit id="e0921bad9f229a9389c2e38e52f6a7f7b765b5aa" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;bitop&lt;/code&gt; lib.</source>
          <target state="translated">&lt;code&gt;bitop&lt;/code&gt; lib.</target>
        </trans-unit>
        <trans-unit id="0a1dd8d1355938beb39d0e1c2d0f73196261de7e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;blocked_clients&lt;/code&gt;: Number of clients pending on a blocking call (BLPOP, BRPOP, BRPOPLPUSH)</source>
          <target state="translated">&lt;code&gt;blocked_clients&lt;/code&gt; : 차단 호출을 보류중인 클라이언트 수 (BLPOP, BRPOP, BRPOPLPUSH)</target>
        </trans-unit>
        <trans-unit id="24c0bfc56b5937facd337558991cae6163c0423d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;changes_since_last_save&lt;/code&gt; refers to the number of operations that produced some kind of changes in the dataset since the last time either &lt;a href=&quot;save&quot;&gt;SAVE&lt;/a&gt; or &lt;a href=&quot;bgsave&quot;&gt;BGSAVE&lt;/a&gt; was called.</source>
          <target state="translated">&lt;code&gt;changes_since_last_save&lt;/code&gt; 는 마지막으로 &lt;a href=&quot;save&quot;&gt;SAVE&lt;/a&gt; 또는 &lt;a href=&quot;bgsave&quot;&gt;BGSAVE&lt;/a&gt; 가 호출 된 이후 데이터 집합에서 어떤 종류의 변경을 생성 한 작업 수를 나타냅니다 .</target>
        </trans-unit>
        <trans-unit id="eaf245ee0eff16f73b8a1a316441d2b1ea91df09" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;cjson&lt;/code&gt; lib.</source>
          <target state="translated">&lt;code&gt;cjson&lt;/code&gt; lib.</target>
        </trans-unit>
        <trans-unit id="c2392a37aedbf270d6b854bc28fc404b287a29ac" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;client_biggest_input_buf&lt;/code&gt;: biggest input buffer among current client connections</source>
          <target state="translated">&lt;code&gt;client_biggest_input_buf&lt;/code&gt; : 현재 클라이언트 연결 중 가장 큰 입력 버퍼</target>
        </trans-unit>
        <trans-unit id="9fb7b84362378176af7de8594d03749190b46118" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;client_longest_output_list&lt;/code&gt;: longest output list among current client connections</source>
          <target state="translated">&lt;code&gt;client_longest_output_list&lt;/code&gt; : 현재 클라이언트 연결 중 가장 긴 출력 목록</target>
        </trans-unit>
        <trans-unit id="ee177459def1e80b39c47454b8c28a9d42a4106c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;clients.normal&lt;/code&gt;: The total size in bytes of all clients overheads (output and query buffers, connection contexts)</source>
          <target state="translated">&lt;code&gt;clients.normal&lt;/code&gt; : 모든 클라이언트 오버 헤드 (출력 및 쿼리 버퍼, 연결 컨텍스트)의 총 크기 (바이트)</target>
        </trans-unit>
        <trans-unit id="7500227d42c34ddbac3bf8fe32d560635e9a67a4" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;clients.slaves&lt;/code&gt;: The total size in bytes of all replicas overheads (output and query buffers, connection contexts)</source>
          <target state="translated">&lt;code&gt;clients.slaves&lt;/code&gt; : 모든 복제본 오버 헤드 (출력 및 쿼리 버퍼, 연결 컨텍스트)의 총 크기 (바이트)</target>
        </trans-unit>
        <trans-unit id="fc0bb101210ccd0cc4d7b0798c1678cd18cb6bc1" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;clients&lt;/code&gt;: Client connections section</source>
          <target state="translated">&lt;code&gt;clients&lt;/code&gt; : 클라이언트 연결 섹션</target>
        </trans-unit>
        <trans-unit id="4cb155c6866c785f784b7fdb3af57862475d4bb2" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;cluster&lt;/code&gt;: Redis Cluster section</source>
          <target state="translated">&lt;code&gt;cluster&lt;/code&gt; : Redis 클러스터 섹션</target>
        </trans-unit>
        <trans-unit id="3d26c683ca3ca4ce60da0b69dd830079349a61d3" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;cluster_current_epoch&lt;/code&gt;: The local &lt;code&gt;Current Epoch&lt;/code&gt; variable. This is used in order to create unique increasing version numbers during fail overs.</source>
          <target state="translated">&lt;code&gt;cluster_current_epoch&lt;/code&gt; : 로컬 &lt;code&gt;Current Epoch&lt;/code&gt; 변수. 장애 조치 동안 고유 한 증가 버전 번호를 작성하기 위해 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="70851ccf8dd13c98bda748f4a9d9fbe7bd0bd627" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;cluster_enabled&lt;/code&gt;: Indicate Redis cluster is enabled</source>
          <target state="translated">&lt;code&gt;cluster_enabled&lt;/code&gt; : Redis 클러스터가 활성화되었음을 나타냅니다</target>
        </trans-unit>
        <trans-unit id="7c146d936ab811cc708f993ded474e0edc533322" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;cluster_known_nodes&lt;/code&gt;: The total number of known nodes in the cluster, including nodes in &lt;code&gt;HANDSHAKE&lt;/code&gt; state that may not currently be proper members of the cluster.</source>
          <target state="translated">&lt;code&gt;cluster_known_nodes&lt;/code&gt; : 현재 클러스터의 적절한 구성원이 아닐 수 있는 &lt;code&gt;HANDSHAKE&lt;/code&gt; 상태의 노드를 포함하여 클러스터에 알려진 총 노드 수입니다 .</target>
        </trans-unit>
        <trans-unit id="5874cd9f6f0e68dfeae4ccb58cfe7c53dd1c21ec" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;cluster_my_epoch&lt;/code&gt;: The &lt;code&gt;Config Epoch&lt;/code&gt; of the node we are talking with. This is the current configuration version assigned to this node.</source>
          <target state="translated">&lt;code&gt;cluster_my_epoch&lt;/code&gt; : 우리가 대화하고있는 노드 의 &lt;code&gt;Config Epoch&lt;/code&gt; . 이 노드에 지정된 현재 구성 버전입니다.</target>
        </trans-unit>
        <trans-unit id="52095d5a5d032e4fa63b850e6af56cbcfc64296f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;cluster_size&lt;/code&gt;: The number of master nodes serving at least one hash slot in the cluster.</source>
          <target state="translated">&lt;code&gt;cluster_size&lt;/code&gt; : 클러스터에서 하나 이상의 해시 슬롯을 제공하는 마스터 노드 수입니다.</target>
        </trans-unit>
        <trans-unit id="29695410813fb33d64aa2bf6c11ffbee6c1a2a97" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;cluster_slots_assigned&lt;/code&gt;: Number of slots which are associated to some node (not unbound). This number should be 16384 for the node to work properly, which means that each hash slot should be mapped to a node.</source>
          <target state="translated">&lt;code&gt;cluster_slots_assigned&lt;/code&gt; : 일부 노드와 연관된 슬롯 수입니다 (바인드되지 않음). 노드가 올바르게 작동하려면이 숫자는 16384 여야합니다. 즉, 각 해시 슬롯이 노드에 맵핑되어야합니다.</target>
        </trans-unit>
        <trans-unit id="6d0d7b50bc4f71b67fdfc41ee1614343e3c04545" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;cluster_slots_fail&lt;/code&gt;: Number of hash slots mapping to a node in &lt;code&gt;FAIL&lt;/code&gt; state. If this number is not zero the node is not able to serve queries unless &lt;code&gt;cluster-require-full-coverage&lt;/code&gt; is set to &lt;code&gt;no&lt;/code&gt; in the configuration.</source>
          <target state="translated">&lt;code&gt;cluster_slots_fail&lt;/code&gt; : &lt;code&gt;FAIL&lt;/code&gt; 상태 의 노드에 매핑되는 해시 슬롯 수입니다 . 이 숫자가 0이 아니면 구성에서 &lt;code&gt;cluster-require-full-coverage&lt;/code&gt; 가 &lt;code&gt;no&lt;/code&gt; 로 설정되어 있지 않으면 노드가 쿼리를 제공 할 수 없습니다 .</target>
        </trans-unit>
        <trans-unit id="15f48639dc5fdfa9a8fdcaacb4a0ed8c20c6a278" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;cluster_slots_ok&lt;/code&gt;: Number of hash slots mapping to a node not in &lt;code&gt;FAIL&lt;/code&gt; or &lt;code&gt;PFAIL&lt;/code&gt; state.</source>
          <target state="translated">&lt;code&gt;cluster_slots_ok&lt;/code&gt; : &lt;code&gt;FAIL&lt;/code&gt; 또는 &lt;code&gt;PFAIL&lt;/code&gt; 상태가 아닌 노드에 매핑되는 해시 슬롯 수입니다 .</target>
        </trans-unit>
        <trans-unit id="544cc9f0a6d42991bcd32498d341a3f39d2598e0" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;cluster_slots_pfail&lt;/code&gt;: Number of hash slots mapping to a node in &lt;code&gt;PFAIL&lt;/code&gt; state. Note that those hash slots still work correctly, as long as the &lt;code&gt;PFAIL&lt;/code&gt; state is not promoted to &lt;code&gt;FAIL&lt;/code&gt; by the failure detection algorithm. &lt;code&gt;PFAIL&lt;/code&gt; only means that we are currently not able to talk with the node, but may be just a transient error.</source>
          <target state="translated">&lt;code&gt;cluster_slots_pfail&lt;/code&gt; : &lt;code&gt;PFAIL&lt;/code&gt; 상태 의 노드에 매핑되는 해시 슬롯 수입니다 . &lt;code&gt;PFAIL&lt;/code&gt; 상태가 실패 감지 알고리즘에 의해 &lt;code&gt;FAIL&lt;/code&gt; 로 승격되지 않는 한 이러한 해시 슬롯은 여전히 ​​올바르게 작동합니다 . &lt;code&gt;PFAIL&lt;/code&gt; 은 현재 노드와 통신 할 수 없지만 일시적인 오류 일 수 있음을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="81a4d3335de82f0227443fdb6b88a83036adf46b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;cluster_state&lt;/code&gt;: State is &lt;code&gt;ok&lt;/code&gt; if the node is able to receive queries. &lt;code&gt;fail&lt;/code&gt; if there is at least one hash slot which is unbound (no node associated), in error state (node serving it is flagged with FAIL flag), or if the majority of masters can't be reached by this node.</source>
          <target state="translated">&lt;code&gt;cluster_state&lt;/code&gt; : 노드가 쿼리를 수신 할 수있는 경우 상태는 &lt;code&gt;ok&lt;/code&gt; 입니다. &lt;code&gt;fail&lt;/code&gt; (노드는 FAIL 플래그 네요 서빙) 오류 상태 (어떤 노드가 관련 없음) 비 결합을 갖는 적어도 하나 개의 해시 슬롯이있는 경우, 또는 마스터의 대부분이 노드가 도달 할 수없는 경우.</target>
        </trans-unit>
        <trans-unit id="9d84e9f158cef927bb08b9136f31b0e94588ce30" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;cluster_stats_messages_received&lt;/code&gt;: Number of messages received via the cluster node-to-node binary bus.</source>
          <target state="translated">&lt;code&gt;cluster_stats_messages_received&lt;/code&gt; : 클러스터 노드 간 이진 버스를 통해 수신 된 메시지 수.</target>
        </trans-unit>
        <trans-unit id="1d71cc79a3ac3f1f764845f93c6328f871b79130" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;cluster_stats_messages_sent&lt;/code&gt;: Number of messages sent via the cluster node-to-node binary bus.</source>
          <target state="translated">&lt;code&gt;cluster_stats_messages_sent&lt;/code&gt; : 클러스터 노드 간 이진 버스를 통해 전송 된 메시지 수.</target>
        </trans-unit>
        <trans-unit id="ee24d8988678d8582b8f6dab777e971152f05558" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;cmd&lt;/code&gt;: last command played</source>
          <target state="translated">&lt;code&gt;cmd&lt;/code&gt; : 마지막 명령</target>
        </trans-unit>
        <trans-unit id="a709f985301e19713f2f08223d89f4f8eea4b37a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;cmdstat_XXX&lt;/code&gt;: &lt;code&gt;calls=XXX,usec=XXX,usec_per_call=XXX&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;cmdstat_XXX&lt;/code&gt; : &lt;code&gt;calls=XXX,usec=XXX,usec_per_call=XXX&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="07111613af5fe8282dd6060ded0e6a723e3b5d02" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;cmsgpack&lt;/code&gt; lib.</source>
          <target state="translated">&lt;code&gt;cmsgpack&lt;/code&gt; lib.</target>
        </trans-unit>
        <trans-unit id="ae19fbcc7be38e64198a2ac984cfc96421cd38f8" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;commandstats&lt;/code&gt;: Redis command statistics</source>
          <target state="translated">&lt;code&gt;commandstats&lt;/code&gt; : Redis 명령 통계</target>
        </trans-unit>
        <trans-unit id="2e2aec4f159efd5319b9ac9e46f9366aa72ebdb6" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;config-epoch&lt;/code&gt;: The configuration epoch (or version) of the current node (or of the current master if the node is a replica). Each time there is a failover, a new, unique, monotonically increasing configuration epoch is created. If multiple nodes claim to serve the same hash slots, the one with higher configuration epoch wins.</source>
          <target state="translated">&lt;code&gt;config-epoch&lt;/code&gt; : 현재 노드 (또는 노드가 복제 본인 경우 현재 마스터)의 구성 에포크 (또는 버전)입니다. 장애 조치가있을 때마다 단조 증가하는 새롭고 독창적 인 구성 에포크가 생성됩니다. 여러 노드가 동일한 해시 슬롯을 제공한다고 주장하면 구성 시대가 더 높은 노드가 우선합니다.</target>
        </trans-unit>
        <trans-unit id="d6cf11fe66e5db4592e7887d282a6081f905f74a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;config_file&lt;/code&gt;: The path to the config file</source>
          <target state="translated">&lt;code&gt;config_file&lt;/code&gt; : 구성 파일의 경로</target>
        </trans-unit>
        <trans-unit id="5bd1609e184b7224682e9575d08c34e0207cdcfc" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;connected_clients&lt;/code&gt;: Number of client connections (excluding connections from replicas)</source>
          <target state="translated">&lt;code&gt;connected_clients&lt;/code&gt; : 클라이언트 연결 수 (복제본에서 연결 제외)</target>
        </trans-unit>
        <trans-unit id="7141ff50a3ecae86240ef375bf2a477b7bc9fc9e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;connected_slaves&lt;/code&gt;: Number of connected replicas</source>
          <target state="translated">&lt;code&gt;connected_slaves&lt;/code&gt; : 연결된 복제본 수</target>
        </trans-unit>
        <trans-unit id="3b1ff8869c8e738a4466372a8c8bf1e9bf4283a6" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;count &amp;gt; 0&lt;/code&gt;: Remove elements equal to &lt;code&gt;value&lt;/code&gt; moving from head to tail.</source>
          <target state="translated">&lt;code&gt;count &amp;gt; 0&lt;/code&gt; : 머리에서 꼬리로 이동 하는 &lt;code&gt;value&lt;/code&gt; 과 같은 요소를 제거합니다 .</target>
        </trans-unit>
        <trans-unit id="ba40b8d7058909d83882c013f4bc1e77afd98c42" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;count &amp;lt; 0&lt;/code&gt;: Remove elements equal to &lt;code&gt;value&lt;/code&gt; moving from tail to head.</source>
          <target state="translated">&lt;code&gt;count &amp;lt; 0&lt;/code&gt; : 꼬리에서 머리로 이동 하는 &lt;code&gt;value&lt;/code&gt; 과 같은 요소를 제거합니다 .</target>
        </trans-unit>
        <trans-unit id="c040b7d8a01d8456ce09165ab044d0015f9d0f28" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;count = 0&lt;/code&gt;: Remove all elements equal to &lt;code&gt;value&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;count = 0&lt;/code&gt; : &lt;code&gt;value&lt;/code&gt; 와 동일한 모든 요소를 ​​제거합니다 .</target>
        </trans-unit>
        <trans-unit id="fffb19a64d186de16d9f02ae1ed78be02aa565a0" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;cpu&lt;/code&gt;: CPU consumption statistics</source>
          <target state="translated">&lt;code&gt;cpu&lt;/code&gt; : CPU 소비 통계</target>
        </trans-unit>
        <trans-unit id="28e89f6000c505dd15ff4ee6498a8a5c7cf10f46" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;dataset.bytes&lt;/code&gt;: The size in bytes of the dataset, i.e. &lt;code&gt;overhead.total&lt;/code&gt; subtracted from &lt;code&gt;total.allocated&lt;/code&gt; (see &lt;a href=&quot;info&quot;&gt;INFO&lt;/a&gt;'s &lt;code&gt;used_memory_dataset&lt;/code&gt;)</source>
          <target state="translated">&lt;code&gt;dataset.bytes&lt;/code&gt; : 데이터 세트의 크기 (바이트)는, 즉 &lt;code&gt;overhead.total&lt;/code&gt; 공제에서 &lt;code&gt;total.allocated&lt;/code&gt; (참조 &lt;a href=&quot;info&quot;&gt;정보&lt;/a&gt; 의 &lt;code&gt;used_memory_dataset&lt;/code&gt; 를 )</target>
        </trans-unit>
        <trans-unit id="b1c9f5d1580b06150ed54d844305fc482f4608a0" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;dataset.percentage&lt;/code&gt;: The percentage of &lt;code&gt;dataset.bytes&lt;/code&gt; out of the net memory usage</source>
          <target state="translated">&lt;code&gt;dataset.percentage&lt;/code&gt; : 순 메모리 사용량 중 &lt;code&gt;dataset.bytes&lt;/code&gt; 의 백분율</target>
        </trans-unit>
        <trans-unit id="bac92558837e2cc0d2fca2ad2bf12fdb7afe3879" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;db&lt;/code&gt;: current database ID</source>
          <target state="translated">&lt;code&gt;db&lt;/code&gt; : 현재 데이터베이스 ID</target>
        </trans-unit>
        <trans-unit id="02ada849167913c73ba9e71998348d80cbf63a02" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;dbXXX&lt;/code&gt;: &lt;code&gt;keys=XXX,expires=XXX&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;dbXXX&lt;/code&gt; : &lt;code&gt;keys=XXX,expires=XXX&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="e70830fd3214e8c50b4d6c6ffa87dea222cf1a85" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;dbXXX&lt;/code&gt;: For each of the server's databases, the overheads of the main and expiry dictionaries (&lt;code&gt;overhead.hashtable.main&lt;/code&gt; and &lt;code&gt;overhead.hashtable.expires&lt;/code&gt;, respectively) are reported in bytes</source>
          <target state="translated">&lt;code&gt;dbXXX&lt;/code&gt; : 각 서버의 데이터베이스에 대해 기본 및 만료 사전의 &lt;code&gt;overhead.hashtable.main&lt;/code&gt; &lt;code&gt;overhead.hashtable.expires&lt;/code&gt; (각각 overhead.hashtable.main 및 overhead.hashtable.expires )가 바이트 단위로보고됩니다</target>
        </trans-unit>
        <trans-unit id="219313b81a2634eda6addfea706a4c7e8ee55c8d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;default&lt;/code&gt;: Return only the default set of sections</source>
          <target state="translated">&lt;code&gt;default&lt;/code&gt; : 기본 섹션 세트 만 반환</target>
        </trans-unit>
        <trans-unit id="a5a4f58751c4847a68fa58ac194036166b7d5435" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;events&lt;/code&gt;: file descriptor events (see below)</source>
          <target state="translated">&lt;code&gt;events&lt;/code&gt; : 파일 디스크립터 이벤트 (아래 참조)</target>
        </trans-unit>
        <trans-unit id="8566e0b3d3d91487347cb7d465fc1c5fc2616626" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;evicted_keys&lt;/code&gt;: Number of evicted keys due to &lt;code&gt;maxmemory&lt;/code&gt; limit</source>
          <target state="translated">&lt;code&gt;evicted_keys&lt;/code&gt; : 최대 &lt;code&gt;maxmemory&lt;/code&gt; 제한 으로 인한 제거 된 키 수</target>
        </trans-unit>
        <trans-unit id="3e721e3bc63db39fa41eef44ba732db22b942d1f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;executable&lt;/code&gt;: The path to the server's executable</source>
          <target state="translated">&lt;code&gt;executable&lt;/code&gt; : 서버의 실행 파일 경로</target>
        </trans-unit>
        <trans-unit id="fddae6b7c1346bcee795c85b7caa0a8eb0c07bf4" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;expired_keys&lt;/code&gt;: Total number of key expiration events</source>
          <target state="translated">&lt;code&gt;expired_keys&lt;/code&gt; : 총 키 만료 이벤트 수</target>
        </trans-unit>
        <trans-unit id="92de7381dc01164610e1cda0033a7229af5660db" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;fail&lt;/code&gt;: Node is in &lt;code&gt;FAIL&lt;/code&gt; state. It was not reachable for multiple nodes that promoted the &lt;code&gt;PFAIL&lt;/code&gt; state to &lt;code&gt;FAIL&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;fail&lt;/code&gt; : 노드가 &lt;code&gt;FAIL&lt;/code&gt; 상태입니다. &lt;code&gt;PFAIL&lt;/code&gt; 상태를 &lt;code&gt;FAIL&lt;/code&gt; 로 승격시킨 여러 노드에 도달 할 수 없습니다 .</target>
        </trans-unit>
        <trans-unit id="c35b7b08fa3b308e4d8f1822389f662520bb59fc" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;fail?&lt;/code&gt;: Node is in &lt;code&gt;PFAIL&lt;/code&gt; state. Not reachable for the node you are contacting, but still logically reachable (not in &lt;code&gt;FAIL&lt;/code&gt; state).</source>
          <target state="translated">&lt;code&gt;fail?&lt;/code&gt; : 노드가 &lt;code&gt;PFAIL&lt;/code&gt; 상태입니다. 접속중인 노드에 도달 할 수 없지만 논리적으로 도달 할 수 있습니다 ( &lt;code&gt;FAIL&lt;/code&gt; 상태가 아님).</target>
        </trans-unit>
        <trans-unit id="49776705e06dd4e253f073b1e1df4558b84d2624" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;fd&lt;/code&gt;: file descriptor corresponding to the socket</source>
          <target state="translated">&lt;code&gt;fd&lt;/code&gt; : 소켓에 해당하는 파일 디스크립터</target>
        </trans-unit>
        <trans-unit id="e4839b8d9abefec89230daa71bb34e7d4624d2a2" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;flags&lt;/code&gt;: A list of comma separated flags: &lt;code&gt;myself&lt;/code&gt;, &lt;code&gt;master&lt;/code&gt;, &lt;code&gt;slave&lt;/code&gt;, &lt;code&gt;fail?&lt;/code&gt;, &lt;code&gt;fail&lt;/code&gt;, &lt;code&gt;handshake&lt;/code&gt;, &lt;code&gt;noaddr&lt;/code&gt;, &lt;code&gt;noflags&lt;/code&gt;. Flags are explained in detail in the next section.</source>
          <target state="translated">&lt;code&gt;flags&lt;/code&gt; : 쉼표로 구분 된 플래그 목록 : &lt;code&gt;myself&lt;/code&gt; , &lt;code&gt;master&lt;/code&gt; , &lt;code&gt;slave&lt;/code&gt; , &lt;code&gt;fail?&lt;/code&gt; , &lt;code&gt;fail&lt;/code&gt; , &lt;code&gt;handshake&lt;/code&gt; , &lt;code&gt;noaddr&lt;/code&gt; , &lt;code&gt;noflags&lt;/code&gt; . 플래그는 다음 섹션에서 자세히 설명합니다.</target>
        </trans-unit>
        <trans-unit id="f3cd416356c95d4051d973688aae7ac6eba88b4c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;flags&lt;/code&gt;: client flags (see below)</source>
          <target state="translated">&lt;code&gt;flags&lt;/code&gt; : 클라이언트 플래그 (아래 참조)</target>
        </trans-unit>
        <trans-unit id="df062b203c243b317d77329f74ef9fbc95ad37d4" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;fragmentation&lt;/code&gt;: See &lt;a href=&quot;info&quot;&gt;INFO&lt;/a&gt;'s &lt;code&gt;mem_fragmentation_ratio&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;fragmentation&lt;/code&gt; : &lt;a href=&quot;info&quot;&gt;INFO&lt;/a&gt; 의 &lt;code&gt;mem_fragmentation_ratio&lt;/code&gt; 참조</target>
        </trans-unit>
        <trans-unit id="6029bff55fe0c7d9bb3ddb3ebd0310dacaf55ff4" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;gcc_version&lt;/code&gt;: Version of the GCC compiler used to compile the Redis server</source>
          <target state="translated">&lt;code&gt;gcc_version&lt;/code&gt; : Redis 서버를 컴파일하는 데 사용되는 GCC 컴파일러 버전</target>
        </trans-unit>
        <trans-unit id="23a072a24cfac677fc8764a1a8c0fe1f00743a04" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;h*llo&lt;/code&gt; matches &lt;code&gt;hllo&lt;/code&gt; and &lt;code&gt;heeeello&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;h*llo&lt;/code&gt; &lt;code&gt;hllo&lt;/code&gt; 는 hllo 및 &lt;code&gt;heeeello&lt;/code&gt; 와 일치합니다.</target>
        </trans-unit>
        <trans-unit id="a1845d4d0e238b7e6dc45ebcbe2292b346139d65" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;h*llo&lt;/code&gt; subscribes to &lt;code&gt;hllo&lt;/code&gt; and &lt;code&gt;heeeello&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;h*llo&lt;/code&gt; &lt;code&gt;hllo&lt;/code&gt; 와 &lt;code&gt;heeeello&lt;/code&gt; 를 구독합니다</target>
        </trans-unit>
        <trans-unit id="ade12d9137392f4c2bf48b6994c54aaa368233a4" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;h?llo&lt;/code&gt; matches &lt;code&gt;hello&lt;/code&gt;, &lt;code&gt;hallo&lt;/code&gt; and &lt;code&gt;hxllo&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;h?llo&lt;/code&gt; &lt;code&gt;hxllo&lt;/code&gt; 는 &lt;code&gt;hello&lt;/code&gt; , &lt;code&gt;hallo&lt;/code&gt; 및 hxllo 와 일치합니다.</target>
        </trans-unit>
        <trans-unit id="cd6496b33d0f1569be1935849893a999435152ec" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;h?llo&lt;/code&gt; subscribes to &lt;code&gt;hello&lt;/code&gt;, &lt;code&gt;hallo&lt;/code&gt; and &lt;code&gt;hxllo&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;h?llo&lt;/code&gt; &lt;code&gt;hxllo&lt;/code&gt; &lt;code&gt;hello&lt;/code&gt; , &lt;code&gt;hallo&lt;/code&gt; 및 hxllo를 구독합니다.</target>
        </trans-unit>
        <trans-unit id="dcfac43bef479b2c536e4ae578bf2a90ec0c4fab" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;h[^e]llo&lt;/code&gt; matches &lt;code&gt;hallo&lt;/code&gt;, &lt;code&gt;hbllo&lt;/code&gt;, ... but not &lt;code&gt;hello&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;h[^e]llo&lt;/code&gt; &lt;code&gt;hbllo&lt;/code&gt; 는 &lt;code&gt;hallo&lt;/code&gt; , hbllo , ... 와 일치 하지만 &lt;code&gt;hello&lt;/code&gt; 는 아닙니다</target>
        </trans-unit>
        <trans-unit id="fadd16f48704cc1c7091cdf7ff15838506d015cb" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;h[a-b]llo&lt;/code&gt; matches &lt;code&gt;hallo&lt;/code&gt; and &lt;code&gt;hbllo&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;h[a-b]llo&lt;/code&gt; &lt;code&gt;hbllo&lt;/code&gt; 는 &lt;code&gt;hallo&lt;/code&gt; 및 hbllo 와 일치</target>
        </trans-unit>
        <trans-unit id="bb5381a854a2cdc7b997de02f71efdd1649da762" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;h[ae]llo&lt;/code&gt; matches &lt;code&gt;hello&lt;/code&gt; and &lt;code&gt;hallo,&lt;/code&gt; but not &lt;code&gt;hillo&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;h[ae]llo&lt;/code&gt; 는 &lt;code&gt;hello&lt;/code&gt; 및 &lt;code&gt;hallo,&lt;/code&gt; 와 일치 하지만 &lt;code&gt;hillo&lt;/code&gt; 와는 일치 하지 않습니다</target>
        </trans-unit>
        <trans-unit id="a5e1fb9a42de209210d73ecbdbce60f787f2d93c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;h[ae]llo&lt;/code&gt; subscribes to &lt;code&gt;hello&lt;/code&gt; and &lt;code&gt;hallo,&lt;/code&gt; but not &lt;code&gt;hillo&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;h[ae]llo&lt;/code&gt; 는 &lt;code&gt;hello&lt;/code&gt; 와 &lt;code&gt;hallo,&lt;/code&gt; 구독 하지만 &lt;code&gt;hillo&lt;/code&gt; 는 구독 하지 않습니다</target>
        </trans-unit>
        <trans-unit id="772949aad53f3e2d516cf0b962fffee5490a4d57" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;handshake&lt;/code&gt;: Untrusted node, we are handshaking.</source>
          <target state="translated">&lt;code&gt;handshake&lt;/code&gt; : 신뢰할 수없는 노드, 핸드 셰이 킹 중입니다.</target>
        </trans-unit>
        <trans-unit id="814fd3f9ef97f0a61158c442ebf3374319e7d6c9" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;hz&lt;/code&gt;: The server's frequency setting</source>
          <target state="translated">&lt;code&gt;hz&lt;/code&gt; : 서버의 주파수 설정</target>
        </trans-unit>
        <trans-unit id="1022ccb50a72baa656186ea51d6417dd09b347e8" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;id&lt;/code&gt;: The node ID, a 40 characters random string generated when a node is created and never changed again (unless &lt;code&gt;CLUSTER RESET HARD&lt;/code&gt; is used).</source>
          <target state="translated">&lt;code&gt;id&lt;/code&gt; : 노드를 생성하고 다시 변경하지 않을 때 생성되는 40 자 무작위 문자열 인 노드 ID ( &lt;code&gt;CLUSTER RESET HARD&lt;/code&gt; 를 사용 하지 않는 한 ).</target>
        </trans-unit>
        <trans-unit id="6e4cf9fe6a9736c25c012bac49c2f87bfbbd0a81" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;id&lt;/code&gt;: an unique 64-bit client ID (introduced in Redis 2.8.12).</source>
          <target state="translated">&lt;code&gt;id&lt;/code&gt; : 고유 한 64 비트 클라이언트 ID (Redis 2.8.12에서 도입)</target>
        </trans-unit>
        <trans-unit id="b1bda4eb1cacc58fcc5d8afc9929ac1d35eed0e6" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;idle&lt;/code&gt;: idle time of the connection in seconds</source>
          <target state="translated">&lt;code&gt;idle&lt;/code&gt; : 초 단위의 유휴 연결 시간</target>
        </trans-unit>
        <trans-unit id="dc37fb4e2cc65425cd389de9487907efef683281" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;instantaneous_input_kbps&lt;/code&gt;: The network's read rate per second in KB/sec</source>
          <target state="translated">&lt;code&gt;instantaneous_input_kbps&lt;/code&gt; : 초당 네트워크의 읽기 속도 (KB / 초)</target>
        </trans-unit>
        <trans-unit id="c2bbc7260a608ea757aeacf6cecda5f317d1b4fb" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;instantaneous_ops_per_sec&lt;/code&gt;: Number of commands processed per second</source>
          <target state="translated">&lt;code&gt;instantaneous_ops_per_sec&lt;/code&gt; : 초당 처리되는 명령 수</target>
        </trans-unit>
        <trans-unit id="95b684cc83a0cda570839cd2a346dc1d8416b8fc" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;instantaneous_output_kbps&lt;/code&gt;: The network's write rate per second in KB/sec</source>
          <target state="translated">&lt;code&gt;instantaneous_output_kbps&lt;/code&gt; : 초당 네트워크 쓰기 속도 (KB / 초)</target>
        </trans-unit>
        <trans-unit id="1e23ab4305826d0584db18380ae54f96cfe85a06" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;ip:port&lt;/code&gt;: The node address where clients should contact the node to run queries.</source>
          <target state="translated">&lt;code&gt;ip:port&lt;/code&gt; : 클라이언트가 노드를 연결하여 쿼리를 실행해야하는 노드 주소입니다.</target>
        </trans-unit>
        <trans-unit id="291f0af420cf08324f52bee6ac610301d0a211a6" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;keys.bytes-per-key&lt;/code&gt;: The ratio between &lt;strong&gt;net memory usage&lt;/strong&gt; (&lt;code&gt;total.allocated&lt;/code&gt; minus &lt;code&gt;startup.allocated&lt;/code&gt;) and &lt;code&gt;keys.count&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;keys.bytes-per-key&lt;/code&gt; : &lt;strong&gt;순 메모리 사용량&lt;/strong&gt; ( &lt;code&gt;total.allocated&lt;/code&gt; -minus &lt;code&gt;startup.allocated&lt;/code&gt; )과 &lt;code&gt;keys.count&lt;/code&gt; 의 비율</target>
        </trans-unit>
        <trans-unit id="43dcaebeef203950604817bffeb6c8b12d81080b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;keys.count&lt;/code&gt;: The total number of keys stored across all databases in the server</source>
          <target state="translated">&lt;code&gt;keys.count&lt;/code&gt; : 서버의 모든 데이터베이스에 저장된 총 키 수</target>
        </trans-unit>
        <trans-unit id="95824ce321d4cc94f4954a02b73345e7751f8263" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;keyspace&lt;/code&gt;: Database related statistics</source>
          <target state="translated">&lt;code&gt;keyspace&lt;/code&gt; : 데이터베이스 관련 통계</target>
        </trans-unit>
        <trans-unit id="938849ce8e866deafc434a8c0bbab85368d34ec7" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;keyspace_hits&lt;/code&gt;: Number of successful lookup of keys in the main dictionary</source>
          <target state="translated">&lt;code&gt;keyspace_hits&lt;/code&gt; : 기본 사전에서 키를 성공적으로 조회 한 횟수</target>
        </trans-unit>
        <trans-unit id="5934dcbf3cf4745664c870f4876772114b7ebcad" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;keyspace_misses&lt;/code&gt;: Number of failed lookup of keys in the main dictionary</source>
          <target state="translated">&lt;code&gt;keyspace_misses&lt;/code&gt; : 기본 사전에서 실패한 키 조회 수</target>
        </trans-unit>
        <trans-unit id="b8248fad4d6ffdc71b385b094bafe2abbfbc52b7" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;latest_fork_usec&lt;/code&gt;: Duration of the latest fork operation in microseconds</source>
          <target state="translated">&lt;code&gt;latest_fork_usec&lt;/code&gt; : 마이크로 초 단위의 최신 포크 작동 기간</target>
        </trans-unit>
        <trans-unit id="21cc38e61fdb4dd462416a21e8e9e6648d07e3af" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;lazyfree_pending_objects&lt;/code&gt;: The number of objects waiting to be freed (as a result of calling &lt;a href=&quot;unlink&quot;&gt;UNLINK&lt;/a&gt;, or &lt;a href=&quot;flushdb&quot;&gt;FLUSHDB&lt;/a&gt; and &lt;a href=&quot;flushall&quot;&gt;FLUSHALL&lt;/a&gt; with the &lt;strong&gt;ASYNC&lt;/strong&gt; option)</source>
          <target state="translated">&lt;code&gt;lazyfree_pending_objects&lt;/code&gt; : 해제 대기중인 객체 수 ( &lt;strong&gt;ASYNC&lt;/strong&gt; 옵션을 사용하여 &lt;a href=&quot;unlink&quot;&gt;UNLINK&lt;/a&gt; 또는 &lt;a href=&quot;flushdb&quot;&gt;FLUSHDB&lt;/a&gt; 및 &lt;a href=&quot;flushall&quot;&gt;FLUSHALL&lt;/a&gt; 을 호출 한 결과 )&lt;strong&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="59ecbcb471bd0b1ba5e063f491468fad5e3173d2" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;link-state&lt;/code&gt;: The state of the link used for the node-to-node cluster bus. We use this link to communicate with the node. Can be &lt;code&gt;connected&lt;/code&gt; or &lt;code&gt;disconnected&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;link-state&lt;/code&gt; : 노드 간 클러스터 버스에 사용 된 링크의 상태입니다. 이 링크를 사용하여 노드와 통신합니다. &lt;code&gt;connected&lt;/code&gt; 하거나 &lt;code&gt;disconnected&lt;/code&gt; 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="fe7bdbcf85b37b69d3e6e4d866b6ad86cc562465" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;loading&lt;/code&gt;: Flag indicating if the load of a dump file is on-going</source>
          <target state="translated">&lt;code&gt;loading&lt;/code&gt; : 덤프 파일의로드가 진행 중인지를 나타내는 플래그</target>
        </trans-unit>
        <trans-unit id="b641e737c4c65b61073674e1872dba9aa112ba11" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;loading_eta_seconds&lt;/code&gt;: ETA in seconds for the load to be complete</source>
          <target state="translated">&lt;code&gt;loading_eta_seconds&lt;/code&gt; :로드가 완료되기까지의 ETA (초)</target>
        </trans-unit>
        <trans-unit id="905f0c0d04e1edb114d6944e2c3fc5d7d748d4df" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;loading_loaded_bytes&lt;/code&gt;: Number of bytes already loaded</source>
          <target state="translated">&lt;code&gt;loading_loaded_bytes&lt;/code&gt; : 이미로드 된 바이트 수</target>
        </trans-unit>
        <trans-unit id="95d85b85e583f65530a4c519f38195c7d0bf9d9b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;loading_loaded_perc&lt;/code&gt;: Same value expressed as a percentage</source>
          <target state="translated">&lt;code&gt;loading_loaded_perc&lt;/code&gt; : 백분율로 표시되는 동일한 값</target>
        </trans-unit>
        <trans-unit id="54bc84cb5d647f7d245611a75b0f4e6a47881c15" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;loading_start_time&lt;/code&gt;: Epoch-based timestamp of the start of the load operation</source>
          <target state="translated">&lt;code&gt;loading_start_time&lt;/code&gt; :로드 조작 시작의 Epoch 기반 시간 소인</target>
        </trans-unit>
        <trans-unit id="a2b99d44dac13ed28eaefad23e3acd32e473cff7" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;loading_total_bytes&lt;/code&gt;: Total file size</source>
          <target state="translated">&lt;code&gt;loading_total_bytes&lt;/code&gt; : 총 파일 크기</target>
        </trans-unit>
        <trans-unit id="3f4e8e370b36fff04729036f4d5f3c0e5b332d07" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;loglevel&lt;/code&gt; is one of:</source>
          <target state="translated">&lt;code&gt;loglevel&lt;/code&gt; 은 다음 중 하나입니다.</target>
        </trans-unit>
        <trans-unit id="1f16338d15e120aaa052f8fdb78dab343eef6dd5" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;lru_clock&lt;/code&gt;: Clock incrementing every minute, for LRU management</source>
          <target state="translated">&lt;code&gt;lru_clock&lt;/code&gt; : LRU 관리를 위해 1 분마다 증가하는 클록</target>
        </trans-unit>
        <trans-unit id="a6ed881ede82d74c70a2a4663adcf6972b5df79d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;master&lt;/code&gt;: If the node is a replica, and the master is known, the master node ID, otherwise the &quot;-&quot; character.</source>
          <target state="translated">&lt;code&gt;master&lt;/code&gt; : 노드가 복제본이고 마스터가 알려진 경우 마스터 노드 ID, 그렇지 않으면 &quot;-&quot;문자</target>
        </trans-unit>
        <trans-unit id="4cc7689c421b56db103b063a107acf3446d1e601" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;master&lt;/code&gt;: Node is a master.</source>
          <target state="translated">&lt;code&gt;master&lt;/code&gt; : 노드는 마스터입니다.</target>
        </trans-unit>
        <trans-unit id="291a8ad8ba75d794172ecb8cdc800fac2e8bea69" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;master_host&lt;/code&gt;: Host or IP address of the master</source>
          <target state="translated">&lt;code&gt;master_host&lt;/code&gt; : 마스터의 호스트 또는 IP 주소</target>
        </trans-unit>
        <trans-unit id="c7b919c2a8e9e5c48b32193b06915825f05d23ac" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;master_last_io_seconds_ago&lt;/code&gt;: Number of seconds since the last interaction with master</source>
          <target state="translated">&lt;code&gt;master_last_io_seconds_ago&lt;/code&gt; : 마스터와의 마지막 상호 작용 이후의 시간 (초)</target>
        </trans-unit>
        <trans-unit id="f0f3eb8f4200646143873fd144790f03d854f7af" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;master_link_down_since_seconds&lt;/code&gt;: Number of seconds since the link is down</source>
          <target state="translated">&lt;code&gt;master_link_down_since_seconds&lt;/code&gt; : 링크가 다운 된 이후의 시간 (초)</target>
        </trans-unit>
        <trans-unit id="90bf7bf132f33bf3b3e67cdd40fdcc917c464460" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;master_link_status&lt;/code&gt;: Status of the link (up/down)</source>
          <target state="translated">&lt;code&gt;master_link_status&lt;/code&gt; : 링크 상태 (위 / 아래)</target>
        </trans-unit>
        <trans-unit id="e58722ccd1793143cb927377948a3a1635236b9a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;master_port&lt;/code&gt;: Master listening TCP port</source>
          <target state="translated">&lt;code&gt;master_port&lt;/code&gt; : 마스터 수신 TCP 포트</target>
        </trans-unit>
        <trans-unit id="38536dd76b51abea55679752e904120abd772b27" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;master_repl_offset&lt;/code&gt;: The server's current replication offset</source>
          <target state="translated">&lt;code&gt;master_repl_offset&lt;/code&gt; : 서버의 현재 복제 오프셋</target>
        </trans-unit>
        <trans-unit id="17b1b7079ccf083e09938191385ff09c723f9080" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;master_replid2&lt;/code&gt;: The secondary replication ID, used for PSYNC after a failover.</source>
          <target state="translated">&lt;code&gt;master_replid2&lt;/code&gt; : 장애 조치 후 PSYNC에 사용되는 보조 복제 ID입니다.</target>
        </trans-unit>
        <trans-unit id="506e20f228c9d2c1dcc44dcf716be0a8e0f527df" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;master_replid&lt;/code&gt;: The replication ID of the Redis server.</source>
          <target state="translated">&lt;code&gt;master_replid&lt;/code&gt; : Redis 서버의 복제 ID입니다.</target>
        </trans-unit>
        <trans-unit id="c4bc68c43bde0af6497f05baba945f1c620a90ca" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;master_sync_in_progress&lt;/code&gt;: Indicate the master is syncing to the replica</source>
          <target state="translated">&lt;code&gt;master_sync_in_progress&lt;/code&gt; : 마스터가 복제본과 동기화 중임을 나타냅니다</target>
        </trans-unit>
        <trans-unit id="b4b673ca5ed8610fe7fa1e1ffbaedb57ca7ca77b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;master_sync_last_io_seconds_ago&lt;/code&gt;: Number of seconds since last transfer I/O during a SYNC operation</source>
          <target state="translated">&lt;code&gt;master_sync_last_io_seconds_ago&lt;/code&gt; : SYNC 작업 중 마지막 전송 I / O 이후의 시간 (초)</target>
        </trans-unit>
        <trans-unit id="0cdd4c8cc8c79eeab8100d928843441a0c312ab7" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;master_sync_left_bytes&lt;/code&gt;: Number of bytes left before syncing is complete</source>
          <target state="translated">&lt;code&gt;master_sync_left_bytes&lt;/code&gt; : 동기화가 완료되기 전에 남은 바이트 수</target>
        </trans-unit>
        <trans-unit id="bc21fdd1146fa4c4bba4073b469b7424702f89f0" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;math&lt;/code&gt; lib.</source>
          <target state="translated">&lt;code&gt;math&lt;/code&gt; 라이브러리.</target>
        </trans-unit>
        <trans-unit id="264ff63840f1fd88caa997a7ac62b59d2937b34e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;maxmemory&lt;/code&gt;: The value of the &lt;code&gt;maxmemory&lt;/code&gt; configuration directive</source>
          <target state="translated">&lt;code&gt;maxmemory&lt;/code&gt; : &lt;code&gt;maxmemory&lt;/code&gt; 구성 지시문 의 값</target>
        </trans-unit>
        <trans-unit id="817ccce83e74c3626cb40339fef4aa9b5544ef46" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;maxmemory_human&lt;/code&gt;: Human readable representation of previous value</source>
          <target state="translated">&lt;code&gt;maxmemory_human&lt;/code&gt; : 인간이 읽을 수있는 이전 값 표현</target>
        </trans-unit>
        <trans-unit id="b922c9f2d429df108e0acf7ffcf5d134393c6d70" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;maxmemory_policy&lt;/code&gt;: The value of the &lt;code&gt;maxmemory-policy&lt;/code&gt; configuration directive</source>
          <target state="translated">&lt;code&gt;maxmemory_policy&lt;/code&gt; : &lt;code&gt;maxmemory-policy&lt;/code&gt; 구성 지시문 의 값</target>
        </trans-unit>
        <trans-unit id="fad03613c207944468a711f3fbb7847b71f15d75" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;mem_allocator&lt;/code&gt;: Memory allocator, chosen at compile time</source>
          <target state="translated">&lt;code&gt;mem_allocator&lt;/code&gt; : 컴파일시에 선택된 메모리 할당 자</target>
        </trans-unit>
        <trans-unit id="8ab1c581e26ff6762ae29f013f6d0b6a17cf2cb6" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;mem_fragmentation_ratio&lt;/code&gt;: Ratio between &lt;code&gt;used_memory_rss&lt;/code&gt; and &lt;code&gt;used_memory&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;mem_fragmentation_ratio&lt;/code&gt; : &lt;code&gt;used_memory_rss&lt;/code&gt; 와 &lt;code&gt;used_memory&lt;/code&gt; 의 비율</target>
        </trans-unit>
        <trans-unit id="3edb25127130c1e1537a5ef7e8480bc9ec92b78d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;memory&lt;/code&gt;: Memory consumption related information</source>
          <target state="translated">&lt;code&gt;memory&lt;/code&gt; : 메모리 소비 관련 정보</target>
        </trans-unit>
        <trans-unit id="2d5cca8132678950ab84bf42425da3ca0507e576" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;migrate_cached_sockets&lt;/code&gt;: The number of sockets open for &lt;a href=&quot;migrate&quot;&gt;MIGRATE&lt;/a&gt; purposes</source>
          <target state="translated">&lt;code&gt;migrate_cached_sockets&lt;/code&gt; : &lt;a href=&quot;migrate&quot;&gt;마이그레이션&lt;/a&gt; 목적으로 열린 소켓 수</target>
        </trans-unit>
        <trans-unit id="3927030e50503d7ca36313f099ded40f9e7fd2a5" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;min&lt;/code&gt; and &lt;code&gt;max&lt;/code&gt; can be &lt;code&gt;-inf&lt;/code&gt; and &lt;code&gt;+inf&lt;/code&gt;, so that you are not required to know the highest or lowest score in the sorted set to get all elements from or up to a certain score.</source>
          <target state="translated">&lt;code&gt;min&lt;/code&gt; 및 &lt;code&gt;max&lt;/code&gt; 는 &lt;code&gt;-inf&lt;/code&gt; 및 &lt;code&gt;+inf&lt;/code&gt; 일 수 있으므로 정렬 된 세트에서 최고 또는 최저 점수를 알 필요가 없으므로 모든 요소를 ​​특정 점수에서 또는 최대로 얻을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9d1bf92a441476dd2b1a033b8bda44cfa256eb59" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;min_slaves_good_slaves&lt;/code&gt;: Number of replicas currently considered good</source>
          <target state="translated">&lt;code&gt;min_slaves_good_slaves&lt;/code&gt; : 현재 양호하다고 간주되는 복제본 수</target>
        </trans-unit>
        <trans-unit id="8401d9f1390c809813bc32bd3d1271ab733ce35d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;multi&lt;/code&gt;: number of commands in a MULTI/EXEC context</source>
          <target state="translated">&lt;code&gt;multi&lt;/code&gt; : MULTI / EXEC 컨텍스트의 명령 수</target>
        </trans-unit>
        <trans-unit id="2c8fa772aec46a276fd4408dcd12322cad2da9a6" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;multiplexing_api&lt;/code&gt;: Event loop mechanism used by Redis</source>
          <target state="translated">&lt;code&gt;multiplexing_api&lt;/code&gt; : Redis에서 사용하는 이벤트 루프 메커니즘</target>
        </trans-unit>
        <trans-unit id="e0c9182e4b40c08e961e899a6e20a5633a6ee0f6" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;myself&lt;/code&gt;: The node you are contacting.</source>
          <target state="translated">&lt;code&gt;myself&lt;/code&gt; : 연락하는 노드.</target>
        </trans-unit>
        <trans-unit id="6a436bf2963c1a3b8c958af7c5e07240e0e482f2" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;name&lt;/code&gt;: the name set by the client with &lt;a href=&quot;client-setname&quot;&gt;CLIENT SETNAME&lt;/a&gt;</source>
          <target state="translated">&lt;code&gt;name&lt;/code&gt; : 클라이언트가 &lt;a href=&quot;client-setname&quot;&gt;CLIENT SETNAME으로&lt;/a&gt; 설정 한 이름</target>
        </trans-unit>
        <trans-unit id="eb42588cab8a6e41d3563bac3bf5a966ddc7f241" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;noaddr&lt;/code&gt;: No address known for this node.</source>
          <target state="translated">&lt;code&gt;noaddr&lt;/code&gt; :이 노드에 알려진 주소가 없습니다.</target>
        </trans-unit>
        <trans-unit id="588a72abc4c95194bec0e3569653d6a66d738e01" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;noflags&lt;/code&gt;: No flags at all.</source>
          <target state="translated">&lt;code&gt;noflags&lt;/code&gt; : 플래그가 전혀 없습니다.</target>
        </trans-unit>
        <trans-unit id="f08264cef3e182cc26690ed1532909b6767c5de5" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;obl&lt;/code&gt;: output buffer length</source>
          <target state="translated">&lt;code&gt;obl&lt;/code&gt; : 출력 버퍼 길이</target>
        </trans-unit>
        <trans-unit id="bbbcb3aaca80773967cf9f09226457a784353779" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;oll&lt;/code&gt;: output list length (replies are queued in this list when the buffer is full)</source>
          <target state="translated">&lt;code&gt;oll&lt;/code&gt; : 출력 목록 길이 (버퍼가 가득 차면이 목록에 회신이 대기 함)</target>
        </trans-unit>
        <trans-unit id="ba0b94233ec83c276ed7965e425a12874a6f0609" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;omem&lt;/code&gt;: output buffer memory usage</source>
          <target state="translated">&lt;code&gt;omem&lt;/code&gt; : 출력 버퍼 메모리 사용량</target>
        </trans-unit>
        <trans-unit id="13338a0bc1218b82c9be0432fdb97dd49851c228" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;os&lt;/code&gt;: Operating system hosting the Redis server</source>
          <target state="translated">&lt;code&gt;os&lt;/code&gt; : Redis 서버를 호스팅하는 운영 체제</target>
        </trans-unit>
        <trans-unit id="b921821db9903f46a7da2d8e5fa5fbaa99f469d3" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;overhead.total&lt;/code&gt;: The sum of all overheads, i.e. &lt;code&gt;startup.allocated&lt;/code&gt;, &lt;code&gt;replication.backlog&lt;/code&gt;, &lt;code&gt;clients.slaves&lt;/code&gt;, &lt;code&gt;clients.normal&lt;/code&gt;, &lt;code&gt;aof.buffer&lt;/code&gt; and those of the internal data structures that are used in managing the Redis keyspace (see &lt;a href=&quot;info&quot;&gt;INFO&lt;/a&gt;'s &lt;code&gt;used_memory_overhead&lt;/code&gt;)</source>
          <target state="translated">&lt;code&gt;overhead.total&lt;/code&gt; : 모든 오버 헤드, 즉 &lt;code&gt;startup.allocated&lt;/code&gt; , &lt;code&gt;replication.backlog&lt;/code&gt; , &lt;code&gt;clients.slaves&lt;/code&gt; , &lt;code&gt;clients.normal&lt;/code&gt; , &lt;code&gt;aof.buffer&lt;/code&gt; 및 Redis 키 공간 관리에 사용되는 내부 데이터 구조의 합계 ( &lt;a href=&quot;info&quot;&gt;INFO&lt;/a&gt; 's 참조) &lt;code&gt;used_memory_overhead&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="b66f0f12b2e6c5406228c20ed2d84087eb7179ba" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;peak.allocated&lt;/code&gt;: Peak memory consumed by Redis in bytes (see &lt;a href=&quot;info&quot;&gt;INFO&lt;/a&gt;'s &lt;code&gt;used_memory&lt;/code&gt;)</source>
          <target state="translated">&lt;code&gt;peak.allocated&lt;/code&gt; : Redis가 소비 한 최대 메모리 (바이트) ( &lt;a href=&quot;info&quot;&gt;INFO&lt;/a&gt; 의 &lt;code&gt;used_memory&lt;/code&gt; 참조 )</target>
        </trans-unit>
        <trans-unit id="9104c5033ce661c1a0960c0256c747a7e1462163" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;peak.percentage&lt;/code&gt;: The percentage of &lt;code&gt;peak.allocated&lt;/code&gt; out of &lt;code&gt;total.allocated&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;peak.percentage&lt;/code&gt; :의 비율 &lt;code&gt;peak.allocated&lt;/code&gt; 밖으로 &lt;code&gt;total.allocated&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="ee46e3f9df2301d2c9d9f49311b2a6be9a794102" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;persistence&lt;/code&gt;: RDB and AOF related information</source>
          <target state="translated">&lt;code&gt;persistence&lt;/code&gt; : RDB 및 AOF 관련 정보</target>
        </trans-unit>
        <trans-unit id="340ca7ffebd56548b44ad85ca71ded648b8a9fe0" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;ping-sent&lt;/code&gt;: Milliseconds unix time at which the currently active ping was sent, or zero if there are no pending pings.</source>
          <target state="translated">&lt;code&gt;ping-sent&lt;/code&gt; : 현재 활성 핑이 전송 된 유닉스 시간 (밀리 초), 보류중인 핑이없는 경우 0</target>
        </trans-unit>
        <trans-unit id="2ce7201393232bb0529b46b4ad49ad2d100d7a0e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;pong-recv&lt;/code&gt;: Milliseconds unix time the last pong was received.</source>
          <target state="translated">&lt;code&gt;pong-recv&lt;/code&gt; : 마지막 pong을받은 시간 (밀리 초)</target>
        </trans-unit>
        <trans-unit id="bf141066fc22e3fcd741fa0973e91924088de0cc" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;process_id&lt;/code&gt;: PID of the server process</source>
          <target state="translated">&lt;code&gt;process_id&lt;/code&gt; : 서버 프로세스의 PID</target>
        </trans-unit>
        <trans-unit id="01197709a5335bdf7b938279bba3370a78eaa4e0" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;psub&lt;/code&gt;: number of pattern matching subscriptions</source>
          <target state="translated">&lt;code&gt;psub&lt;/code&gt; : 패턴 일치 구독 수</target>
        </trans-unit>
        <trans-unit id="5d9782c719f3108a6648d4a697460354d47034e0" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;pubsub_channels&lt;/code&gt;: Global number of pub/sub channels with client subscriptions</source>
          <target state="translated">&lt;code&gt;pubsub_channels&lt;/code&gt; : 클라이언트 구독이있는 글로벌 pub / sub 채널 수</target>
        </trans-unit>
        <trans-unit id="d18b3633027d3c201e4b17aacba16c5886fee7ab" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;pubsub_patterns&lt;/code&gt;: Global number of pub/sub pattern with client subscriptions</source>
          <target state="translated">&lt;code&gt;pubsub_patterns&lt;/code&gt; : 클라이언트 구독이있는 글로벌 발행 / 구독 패턴 수</target>
        </trans-unit>
        <trans-unit id="09a490885df7985f548424c575c27793c1e801cd" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;qbuf-free&lt;/code&gt;: free space of the query buffer (0 means the buffer is full)</source>
          <target state="translated">&lt;code&gt;qbuf-free&lt;/code&gt; : 쿼리 버퍼의 여유 공간 (0은 버퍼가 가득 찼음을 의미)</target>
        </trans-unit>
        <trans-unit id="e1eb072bfc64b27b4e211a82d13ebb8cf4b88ffd" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;qbuf&lt;/code&gt;: query buffer length (0 means no query pending)</source>
          <target state="translated">&lt;code&gt;qbuf&lt;/code&gt; : 쿼리 버퍼 길이 (0은 쿼리 보류가 없음을 의미)</target>
        </trans-unit>
        <trans-unit id="49c7f37dd4cd7c1eef2f06a26ec6a39e6f1f9af7" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;rdb_bgsave_in_progress&lt;/code&gt;: Flag indicating a RDB save is on-going</source>
          <target state="translated">&lt;code&gt;rdb_bgsave_in_progress&lt;/code&gt; : RDB 저장이 진행 중임을 나타내는 플래그</target>
        </trans-unit>
        <trans-unit id="0e1b0e631149e31b0f9b8d6bac185af69540b23d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;rdb_changes_since_last_save&lt;/code&gt;: Number of changes since the last dump</source>
          <target state="translated">&lt;code&gt;rdb_changes_since_last_save&lt;/code&gt; : 마지막 덤프 이후의 변경 수</target>
        </trans-unit>
        <trans-unit id="5e167b550eaa7334a4af54871fb995b0b3d14833" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;rdb_current_bgsave_time_sec&lt;/code&gt;: Duration of the on-going RDB save operation if any</source>
          <target state="translated">&lt;code&gt;rdb_current_bgsave_time_sec&lt;/code&gt; : 진행중인 RDB 저장 작업의 지속 기간</target>
        </trans-unit>
        <trans-unit id="846322c9f133b635731fc1ad09c1e21e41814e1e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;rdb_last_bgsave_status&lt;/code&gt;: Status of the last RDB save operation</source>
          <target state="translated">&lt;code&gt;rdb_last_bgsave_status&lt;/code&gt; : 마지막 RDB 저장 작업의 상태</target>
        </trans-unit>
        <trans-unit id="4ec4734db22843dfa1c0c6421831771884151288" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;rdb_last_bgsave_time_sec&lt;/code&gt;: Duration of the last RDB save operation in seconds</source>
          <target state="translated">&lt;code&gt;rdb_last_bgsave_time_sec&lt;/code&gt; : 마지막 RDB 저장 작업 지속 시간 (초)</target>
        </trans-unit>
        <trans-unit id="be124bd94d7dd238582a9b91439d97057cfe5476" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;rdb_last_cow_size&lt;/code&gt;: The size in bytes of copy-on-write allocations during the last RBD save operation</source>
          <target state="translated">&lt;code&gt;rdb_last_cow_size&lt;/code&gt; : 마지막 RBD 저장 작업 중 기록 중 복사 할당의 크기 (바이트)</target>
        </trans-unit>
        <trans-unit id="31ec0a2188669177796fd5ed7732b24095c34872" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;rdb_last_save_time&lt;/code&gt;: Epoch-based timestamp of last successful RDB save</source>
          <target state="translated">&lt;code&gt;rdb_last_save_time&lt;/code&gt; : 마지막으로 성공한 RDB 저장의 Epoch 기반 타임 스탬프</target>
        </trans-unit>
        <trans-unit id="5830999758618fbec95f0cb84ec74b9013df9939" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;redis.breakpoint and redis.debug&lt;/code&gt; function in the context of the &lt;a href=&quot;https://redis.io/topics/ldb&quot;&gt;Redis Lua debugger&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;redis.breakpoint and redis.debug&lt;/code&gt; 컨텍스트에 함수 &lt;a href=&quot;https://redis.io/topics/ldb&quot;&gt;레디 스 루아 디버거&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="f6cfa5a17847f90f659a75435f90fdf87414f735" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;redis.call()&lt;/code&gt; is similar to &lt;code&gt;redis.pcall()&lt;/code&gt;, the only difference is that if a Redis command call will result in an error, &lt;code&gt;redis.call()&lt;/code&gt; will raise a Lua error that in turn will force &lt;a href=&quot;eval&quot;&gt;EVAL&lt;/a&gt; to return an error to the command caller, while &lt;code&gt;redis.pcall&lt;/code&gt; will trap the error and return a Lua table representing the error.</source>
          <target state="translated">&lt;code&gt;redis.call()&lt;/code&gt; 유사하다 &lt;code&gt;redis.pcall()&lt;/code&gt; 유일한 차이점은 레디 스 명령 호출 오류가 발생한다면,이다 &lt;code&gt;redis.call()&lt;/code&gt; 차례로 강제하는 루아 에러 올릴 &lt;a href=&quot;eval&quot;&gt;EVAL를&lt;/a&gt; 오류를 반환을 명령 호출자에게, 동안 &lt;code&gt;redis.pcall&lt;/code&gt; 의 의지 트랩 오류 및 오류를 나타내는 루아 테이블을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="cc1c903bdb48793f0e4f48c01b73479cb762bb36" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;redis.error_reply(error_string)&lt;/code&gt; returns an error reply. This function simply returns a single field table with the &lt;code&gt;err&lt;/code&gt; field set to the specified string for you.</source>
          <target state="translated">&lt;code&gt;redis.error_reply(error_string)&lt;/code&gt; 는 오류 응답을 반환합니다. 이 함수는 단순히 &lt;code&gt;err&lt;/code&gt; 필드가 지정된 문자열로 설정된 단일 필드 테이블을 반환 합니다.</target>
        </trans-unit>
        <trans-unit id="ae82951de9075482aaf5f1ae88227fb45a6550f9" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;redis.sha1hex&lt;/code&gt; function.</source>
          <target state="translated">&lt;code&gt;redis.sha1hex&lt;/code&gt; 기능.</target>
        </trans-unit>
        <trans-unit id="9242be04d881f15c4a713681eb55c02628ce5b41" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;redis.status_reply(status_string)&lt;/code&gt; returns a status reply. This function simply returns a single field table with the &lt;code&gt;ok&lt;/code&gt; field set to the specified string for you.</source>
          <target state="translated">&lt;code&gt;redis.status_reply(status_string)&lt;/code&gt; 은 상태 응답을 반환합니다. 이 함수는 &lt;code&gt;ok&lt;/code&gt; 필드가 지정된 문자열로 설정된 단일 필드 테이블을 반환 합니다.</target>
        </trans-unit>
        <trans-unit id="95dffb65f94cfa6e4df78dc1f8106938d0a2b8e5" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;redis_build_id&lt;/code&gt;: The build id</source>
          <target state="translated">&lt;code&gt;redis_build_id&lt;/code&gt; : 빌드 ID</target>
        </trans-unit>
        <trans-unit id="4a5d613bfeccb609043a3093f50079862794e426" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;redis_git_dirty&lt;/code&gt;: Git dirty flag</source>
          <target state="translated">&lt;code&gt;redis_git_dirty&lt;/code&gt; : 힘내 더러운 플래그</target>
        </trans-unit>
        <trans-unit id="be06e01599e134053f70a0365a7a6ffe0b546351" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;redis_git_sha1&lt;/code&gt;: Git SHA1</source>
          <target state="translated">&lt;code&gt;redis_git_sha1&lt;/code&gt; : 힘내 SHA1</target>
        </trans-unit>
        <trans-unit id="f4a6779415fbc51c11e3f399963af6fe485e8883" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;redis_mode&lt;/code&gt;: The server's mode (&quot;standalone&quot;, &quot;sentinel&quot; or &quot;cluster&quot;)</source>
          <target state="translated">&lt;code&gt;redis_mode&lt;/code&gt; : 서버 모드 ( &quot;독립형&quot;, &quot;센티넬&quot;또는 &quot;클러스터&quot;)</target>
        </trans-unit>
        <trans-unit id="6d0cc6894f88d6a671c3cf47afe1c3a49b400f41" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;redis_version&lt;/code&gt;: Version of the Redis server</source>
          <target state="translated">&lt;code&gt;redis_version&lt;/code&gt; : Redis 서버의 버전</target>
        </trans-unit>
        <trans-unit id="9d5b407137e452587ef4b30cbb1dffa17cb34b01" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;rejected_connections&lt;/code&gt;: Number of connections rejected because of &lt;code&gt;maxclients&lt;/code&gt; limit</source>
          <target state="translated">&lt;code&gt;rejected_connections&lt;/code&gt; : &lt;code&gt;maxclients&lt;/code&gt; 제한으로 인해 거부 된 연결 수</target>
        </trans-unit>
        <trans-unit id="9261b493db72e9a8f282354e217ba34c5ad53405" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;repl_backlog_active&lt;/code&gt;: Flag indicating replication backlog is active</source>
          <target state="translated">&lt;code&gt;repl_backlog_active&lt;/code&gt; : 복제 백 로그가 활성화되었음을 나타내는 플래그</target>
        </trans-unit>
        <trans-unit id="f65d25f6479576d1d8b26887d1fb13af0342f5d8" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;repl_backlog_first_byte_offset&lt;/code&gt;: The master offset of the replication backlog buffer</source>
          <target state="translated">&lt;code&gt;repl_backlog_first_byte_offset&lt;/code&gt; : 복제 백 로그 버퍼의 마스터 오프셋</target>
        </trans-unit>
        <trans-unit id="bd97e1abe8b7a64c9bd426b10a483c5470f1c33c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;repl_backlog_histlen&lt;/code&gt;: Size in bytes of the data in the replication backlog buffer</source>
          <target state="translated">&lt;code&gt;repl_backlog_histlen&lt;/code&gt; : 복제 백 로그 버퍼에있는 데이터의 바이트 크기</target>
        </trans-unit>
        <trans-unit id="557cd508a8f74f5840ee1e5bbbf75af8aaba9343" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;repl_backlog_size&lt;/code&gt;: Total size in bytes of the replication backlog buffer</source>
          <target state="translated">&lt;code&gt;repl_backlog_size&lt;/code&gt; : 복제 백 로그 버퍼의 총 크기 (바이트)</target>
        </trans-unit>
        <trans-unit id="a057f81f3ebf543b442081cf23f0e823d88e17de" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;replication.backlog&lt;/code&gt;: Size in bytes of the replication backlog (see &lt;a href=&quot;info&quot;&gt;INFO&lt;/a&gt;'s &lt;code&gt;repl_backlog_size&lt;/code&gt;)</source>
          <target state="translated">&lt;code&gt;replication.backlog&lt;/code&gt; : 복제 백 로그의 크기 (바이트) ( &lt;a href=&quot;info&quot;&gt;INFO&lt;/a&gt; 의 &lt;code&gt;repl_backlog_size&lt;/code&gt; 참조 )</target>
        </trans-unit>
        <trans-unit id="f1c655643163a917b01bdcd322f040536467b197" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;replication&lt;/code&gt;: Master/replica replication information</source>
          <target state="translated">&lt;code&gt;replication&lt;/code&gt; : 마스터 / 복제본 복제 정보</target>
        </trans-unit>
        <trans-unit id="d4fda8cca4271f45584288721b06d5666e8e23f4" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;role&lt;/code&gt;: Value is &quot;master&quot; if the instance is replica of no one, or &quot;slave&quot; if the instance is a replica of some master instance. Note that a replica can be master of another replica (chained replication).</source>
          <target state="translated">&lt;code&gt;role&lt;/code&gt; : 인스턴스가 아무도의 복제본이 아닌 경우 값은 &quot;master&quot;이고 인스턴스가 일부 마스터 인스턴스의 복제 본인 경우 &quot;slave&quot;입니다. 복제본은 다른 복제본 (체인 복제)의 마스터가 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8fcb9fab53582ec8f7fcfeae342be7427032711d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;run_id&lt;/code&gt;: Random value identifying the Redis server (to be used by Sentinel and Cluster)</source>
          <target state="translated">&lt;code&gt;run_id&lt;/code&gt; : Redis 서버를 식별하는 임의의 값 (Sentinel 및 Cluster에서 사용)</target>
        </trans-unit>
        <trans-unit id="2fc99f4ec57868b8f80a7e424052d862184fb904" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;second_repl_offset&lt;/code&gt;: The offset up to which replication IDs are accepted</source>
          <target state="translated">&lt;code&gt;second_repl_offset&lt;/code&gt; : 복제 ID가 허용되는 오프셋</target>
        </trans-unit>
        <trans-unit id="b919add2279ee146a4b3e724e618e5340f0c5330" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;server&lt;/code&gt;: General information about the Redis server</source>
          <target state="translated">&lt;code&gt;server&lt;/code&gt; : Redis 서버에 대한 일반 정보</target>
        </trans-unit>
        <trans-unit id="1c3e299e02d66f7763bd03b36050606a98337677" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;slave&lt;/code&gt;: Node is a replica.</source>
          <target state="translated">&lt;code&gt;slave&lt;/code&gt; : 노드가 복제본입니다.</target>
        </trans-unit>
        <trans-unit id="66ad5502d3be0f9a00c02cbbbce0c3d7f5b53b2f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;slaveXXX&lt;/code&gt;: id, IP address, port, state, offset, lag</source>
          <target state="translated">&lt;code&gt;slaveXXX&lt;/code&gt; : 아이디, IP 주소, 포트, 상태, 오프셋, 지연</target>
        </trans-unit>
        <trans-unit id="8590a5d28341df0626cb29b0328299f2bd613561" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;slave_expires_tracked_keys&lt;/code&gt;: The number of keys tracked for expiry purposes (applicable only to writable replicas)</source>
          <target state="translated">&lt;code&gt;slave_expires_tracked_keys&lt;/code&gt; : 만료 목적으로 추적 된 키 수 (쓰기 가능한 복제본에만 적용 가능)</target>
        </trans-unit>
        <trans-unit id="b5d40a447d20543abadb672f27493ec5954585cf" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;slave_priority&lt;/code&gt;: The priority of the instance as a candidate for failover</source>
          <target state="translated">&lt;code&gt;slave_priority&lt;/code&gt; : 장애 조치의 후보 인 인스턴스의 우선 순위</target>
        </trans-unit>
        <trans-unit id="12b3222be64789eded1e9e2d87b7eebc6d362e1c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;slave_read_only&lt;/code&gt;: Flag indicating if the replica is read-only</source>
          <target state="translated">&lt;code&gt;slave_read_only&lt;/code&gt; : 복제본이 읽기 전용인지를 나타내는 플래그</target>
        </trans-unit>
        <trans-unit id="f78e6ef30c26728d64ec819ef78cee2c7eeecb35" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;slave_repl_offset&lt;/code&gt;: The replication offset of the replica instance</source>
          <target state="translated">&lt;code&gt;slave_repl_offset&lt;/code&gt; : 복제본 인스턴스의 복제 오프셋</target>
        </trans-unit>
        <trans-unit id="0dc07283433da9c75fa880f47921ded317a31db7" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;slot&lt;/code&gt;: A hash slot number or range. Starting from argument number 9, but there may be up to 16384 entries in total (limit never reached). This is the list of hash slots served by this node. If the entry is just a number, is parsed as such. If it is a range, it is in the form &lt;code&gt;start-end&lt;/code&gt;, and means that the node is responsible for all the hash slots from &lt;code&gt;start&lt;/code&gt; to &lt;code&gt;end&lt;/code&gt; including the start and end values.</source>
          <target state="translated">&lt;code&gt;slot&lt;/code&gt; : 해시 슬롯 번호 또는 범위. 인수 번호 9부터 시작하지만 총 16384 개의 항목이있을 수 있습니다 (제한에 도달하지 않음). 이 노드가 제공하는 해시 슬롯 목록입니다. 항목이 숫자 인 경우 구문 분석됩니다. 이 범위 인 경우,이 형태에 &lt;code&gt;start-end&lt;/code&gt; 및 노드로부터의 모든 해시 슬롯 담당하는 수단을 &lt;code&gt;start&lt;/code&gt; 하는 &lt;code&gt;end&lt;/code&gt; 시작과 끝 값을 포함.</target>
        </trans-unit>
        <trans-unit id="2ad93ec63621004e682aca5fc8cc051cc1f4308d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;start&lt;/code&gt; and &lt;code&gt;end&lt;/code&gt; can also be negative numbers indicating offsets from the end of the list, where &lt;code&gt;-1&lt;/code&gt; is the last element of the list, &lt;code&gt;-2&lt;/code&gt; the penultimate element and so on.</source>
          <target state="translated">&lt;code&gt;start&lt;/code&gt; 및 &lt;code&gt;end&lt;/code&gt; 는 목록의 끝에서 오프셋을 나타내는 음수 일 수도 있습니다. 여기서 &lt;code&gt;-1&lt;/code&gt; 은 목록 의 마지막 요소이고, &lt;code&gt;-2&lt;/code&gt; 는 두 번째 요소입니다.</target>
        </trans-unit>
        <trans-unit id="07ea2259c89c349346cf2cd869db8cb79d5f74c5" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;start&lt;/code&gt; and &lt;code&gt;stop&lt;/code&gt; are &lt;strong&gt;inclusive ranges&lt;/strong&gt;, so for example &lt;code&gt;ZRANGE myzset 0 1&lt;/code&gt; will return both the first and the second element of the sorted set.</source>
          <target state="translated">&lt;code&gt;start&lt;/code&gt; 및 &lt;code&gt;stop&lt;/code&gt; 은 &lt;strong&gt;포괄적 인 범위&lt;/strong&gt; 이므로 예를 들어 &lt;code&gt;ZRANGE myzset 0 1&lt;/code&gt; 은 정렬 된 집합의 첫 번째 요소와 두 번째 요소를 모두 반환합니다.</target>
        </trans-unit>
        <trans-unit id="0ae7b1554f80d3f51903f1dff8325a408a1c655f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;startup.allocated&lt;/code&gt;: Initial amount of memory consumed by Redis at startup in bytes (see &lt;a href=&quot;info&quot;&gt;INFO&lt;/a&gt;'s &lt;code&gt;used_memory_startup&lt;/code&gt;)</source>
          <target state="translated">&lt;code&gt;startup.allocated&lt;/code&gt; : Redis가 시작할 때 소비 한 초기 메모리 양 (바이트) ( &lt;a href=&quot;info&quot;&gt;INFO&lt;/a&gt; 의 &lt;code&gt;used_memory_startup&lt;/code&gt; 참조 )</target>
        </trans-unit>
        <trans-unit id="aac658ac592bbf9956f86b4bac69afd3027558df" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;stats&lt;/code&gt;: General statistics</source>
          <target state="translated">&lt;code&gt;stats&lt;/code&gt; : 일반 통계</target>
        </trans-unit>
        <trans-unit id="dc6e6dc03a40ad7a9125f38b3e026a8f3556d050" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;string&lt;/code&gt; lib.</source>
          <target state="translated">&lt;code&gt;string&lt;/code&gt; lib.</target>
        </trans-unit>
        <trans-unit id="0aa667ebb47bb2b0fe1c8159a627ad9405def74b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;struct&lt;/code&gt; lib.</source>
          <target state="translated">&lt;code&gt;struct&lt;/code&gt; lib.</target>
        </trans-unit>
        <trans-unit id="cf417ec8379e7520d81488517f3183736a01c2a4" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;sub&lt;/code&gt;: number of channel subscriptions</source>
          <target state="translated">&lt;code&gt;sub&lt;/code&gt; : 채널 구독 수</target>
        </trans-unit>
        <trans-unit id="15d05077570de6f81b3d6da791243510608db5c5" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;sync_full&lt;/code&gt;: The number of full resyncs with replicas</source>
          <target state="translated">&lt;code&gt;sync_full&lt;/code&gt; : 복제본과의 전체 재 동기화 수</target>
        </trans-unit>
        <trans-unit id="4ee5a998d34ab5cad1998f3ebf567719bea12098" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;sync_partial_err&lt;/code&gt;: The number of denied partial resync requests</source>
          <target state="translated">&lt;code&gt;sync_partial_err&lt;/code&gt; : 거부 된 부분 재 동기화 요청 수</target>
        </trans-unit>
        <trans-unit id="d56fb4657b9d596dc7d0384ee7df8b86b275cd39" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;sync_partial_ok&lt;/code&gt;: The number of accepted partial resync requests</source>
          <target state="translated">&lt;code&gt;sync_partial_ok&lt;/code&gt; : 승인 된 부분 재 동기화 요청 수</target>
        </trans-unit>
        <trans-unit id="8b77b42cf8709c944a161998b16919cbde5e9bf8" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;table&lt;/code&gt; lib.</source>
          <target state="translated">&lt;code&gt;table&lt;/code&gt; lib.</target>
        </trans-unit>
        <trans-unit id="5f4c32aa62999ab55968bad6e6e4efa2abf72e32" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;tcp_port&lt;/code&gt;: TCP/IP listen port</source>
          <target state="translated">&lt;code&gt;tcp_port&lt;/code&gt; : TCP / IP 청취 포트</target>
        </trans-unit>
        <trans-unit id="7a498bccca27f60dfda24f1e659686e8d0e830dd" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;total.allocated&lt;/code&gt;: Total number of bytes allocated by Redis using its allocator (see &lt;a href=&quot;info&quot;&gt;INFO&lt;/a&gt;'s &lt;code&gt;used_memory&lt;/code&gt;)</source>
          <target state="translated">&lt;code&gt;total.allocated&lt;/code&gt; : Redis가 할당자를 사용하여 할당 한 총 바이트 수 ( &lt;a href=&quot;info&quot;&gt;INFO&lt;/a&gt; 의 &lt;code&gt;used_memory&lt;/code&gt; 참조 )</target>
        </trans-unit>
        <trans-unit id="8732c8368635afc5fa8927a34d3dccabbdb65191" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;total_commands_processed&lt;/code&gt;: Total number of commands processed by the server</source>
          <target state="translated">&lt;code&gt;total_commands_processed&lt;/code&gt; : 서버에서 처리 한 총 명령 수</target>
        </trans-unit>
        <trans-unit id="bba102c4ab9c62037cd444acc6a549a4b9e8ad63" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;total_connections_received&lt;/code&gt;: Total number of connections accepted by the server</source>
          <target state="translated">&lt;code&gt;total_connections_received&lt;/code&gt; : 서버가 승인 한 총 연결 수</target>
        </trans-unit>
        <trans-unit id="ddb9178a813478a27e4593a26fff3a0f64d21fbd" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;total_net_input_bytes&lt;/code&gt;: The total number of bytes read from the network</source>
          <target state="translated">&lt;code&gt;total_net_input_bytes&lt;/code&gt; : 네트워크에서 읽은 총 바이트 수</target>
        </trans-unit>
        <trans-unit id="f2acfa27965fd73d49ec07d748f9b3cb6e09fbe6" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;total_net_output_bytes&lt;/code&gt;: The total number of bytes written to the network</source>
          <target state="translated">&lt;code&gt;total_net_output_bytes&lt;/code&gt; : 네트워크에 쓴 총 바이트 수</target>
        </trans-unit>
        <trans-unit id="ffbec4c806f626a60a4cfe6af281d77a37b8bc37" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;total_system_memory&lt;/code&gt;: The total amount of memory that the Redis host has</source>
          <target state="translated">&lt;code&gt;total_system_memory&lt;/code&gt; : Redis 호스트가 보유한 총 메모리 양</target>
        </trans-unit>
        <trans-unit id="31873b8d2809ee8ad0f6783fbe886c044ac76c6b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;total_system_memory_human&lt;/code&gt;: Human readable representation of previous value</source>
          <target state="translated">&lt;code&gt;total_system_memory_human&lt;/code&gt; : 인간이 읽을 수있는 이전 값 표현</target>
        </trans-unit>
        <trans-unit id="db781a30ee27c1d77274c222dc88bb433b11afbc" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;uptime_in_days&lt;/code&gt;: Same value expressed in days</source>
          <target state="translated">&lt;code&gt;uptime_in_days&lt;/code&gt; : 일 단위로 표시되는 동일한 값</target>
        </trans-unit>
        <trans-unit id="1d3efd1a0fc42457b2846dac85051e5e87a22e7f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;uptime_in_seconds&lt;/code&gt;: Number of seconds since Redis server start</source>
          <target state="translated">&lt;code&gt;uptime_in_seconds&lt;/code&gt; : Redis 서버 시작 이후의 시간 (초)</target>
        </trans-unit>
        <trans-unit id="bb5cc56d21b4b399bf28e2d4ced848cedc2a3139" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;used_cpu_sys&lt;/code&gt;: System CPU consumed by the Redis server</source>
          <target state="translated">&lt;code&gt;used_cpu_sys&lt;/code&gt; : Redis 서버가 사용하는 시스템 CPU</target>
        </trans-unit>
        <trans-unit id="1b287b02ee3142edf7304f38f36d07536453e874" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;used_cpu_sys_children&lt;/code&gt;: System CPU consumed by the background processes</source>
          <target state="translated">&lt;code&gt;used_cpu_sys_children&lt;/code&gt; : 백그라운드 프로세스가 사용하는 시스템 CPU</target>
        </trans-unit>
        <trans-unit id="0fac00be35e10304849ab0c04bb8d430ec4729f8" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;used_cpu_user&lt;/code&gt;:User CPU consumed by the Redis server</source>
          <target state="translated">&lt;code&gt;used_cpu_user&lt;/code&gt; : Redis 서버가 소비 한 사용자 CPU</target>
        </trans-unit>
        <trans-unit id="32e2bdff3caa89cf5c85a6fc4f65e29f75d7cb82" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;used_cpu_user_children&lt;/code&gt;: User CPU consumed by the background processes</source>
          <target state="translated">&lt;code&gt;used_cpu_user_children&lt;/code&gt; : 백그라운드 프로세스가 소비 한 사용자 CPU</target>
        </trans-unit>
        <trans-unit id="77ca1a3d5b20d2fe23c4fa22849f242d4c267b4d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;used_memory&lt;/code&gt;: Total number of bytes allocated by Redis using its allocator (either standard &lt;strong&gt;libc&lt;/strong&gt;, &lt;strong&gt;jemalloc&lt;/strong&gt;, or an alternative allocator such as &lt;a href=&quot;http://code.google.com/p/google-perftools/&quot;&gt;&lt;strong&gt;tcmalloc&lt;/strong&gt;&lt;/a&gt;)</source>
          <target state="translated">&lt;code&gt;used_memory&lt;/code&gt; : Redis가 할당자를 사용하여 할당 한 총 바이트 수 (표준 &lt;strong&gt;libc&lt;/strong&gt; , &lt;strong&gt;jemalloc&lt;/strong&gt; 또는 &lt;a href=&quot;http://code.google.com/p/google-perftools/&quot;&gt;&lt;strong&gt;tcmalloc&lt;/strong&gt;&lt;/a&gt; 와 같은 대체 할당 자 )</target>
        </trans-unit>
        <trans-unit id="e5edb87c5fcdf155299748be8ed3a1d847dc6cf8" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;used_memory_dataset&lt;/code&gt;: The size in bytes of the dataset (&lt;code&gt;used_memory_overhead&lt;/code&gt; subtracted from &lt;code&gt;used_memory&lt;/code&gt;)</source>
          <target state="translated">&lt;code&gt;used_memory_dataset&lt;/code&gt; : 데이터 세트의 크기 (바이트) ( &lt;code&gt;used_memory_overhead&lt;/code&gt; 에서 &lt;code&gt;used_memory&lt;/code&gt; _overhead 빼기 )</target>
        </trans-unit>
        <trans-unit id="99463f967dca2170b9430687aa7dbdadaaa6e185" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;used_memory_dataset_perc&lt;/code&gt;: The percentage of &lt;code&gt;used_memory_dataset&lt;/code&gt; out of the net memory usage (&lt;code&gt;used_memory&lt;/code&gt; minus &lt;code&gt;used_memory_startup&lt;/code&gt;)</source>
          <target state="translated">&lt;code&gt;used_memory_dataset_perc&lt;/code&gt; : 순 메모리 사용량 중 &lt;code&gt;used_memory_dataset&lt;/code&gt; 의 백분율 ( &lt;code&gt;used_memory&lt;/code&gt; 빼기 &lt;code&gt;used_memory_startup&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="7a873e6bb787aea94d53809b33b1786346d9947a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;used_memory_human&lt;/code&gt;: Human readable representation of previous value</source>
          <target state="translated">&lt;code&gt;used_memory_human&lt;/code&gt; : 인간이 읽을 수있는 이전 값 표현</target>
        </trans-unit>
        <trans-unit id="fca7c10926c6d6ae012fbedbc1f22b125c98a72d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;used_memory_lua&lt;/code&gt;: Number of bytes used by the Lua engine</source>
          <target state="translated">&lt;code&gt;used_memory_lua&lt;/code&gt; : Lua 엔진이 사용하는 바이트 수</target>
        </trans-unit>
        <trans-unit id="7d073a6daf2616a502a610857a51fabf502e5a35" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;used_memory_lua_human&lt;/code&gt;: Human readable representation of previous value</source>
          <target state="translated">&lt;code&gt;used_memory_lua_human&lt;/code&gt; : 인간이 읽을 수있는 이전 값 표현</target>
        </trans-unit>
        <trans-unit id="efb76ba4512345b95521d24d896546b1f24843e0" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;used_memory_overhead&lt;/code&gt;: The sum in bytes of all overheads that the server allocated for managing its internal data structures</source>
          <target state="translated">&lt;code&gt;used_memory_overhead&lt;/code&gt; : 서버가 내부 데이터 구조를 관리하기 위해 할당 한 모든 오버 헤드의 바이트 단위 합계</target>
        </trans-unit>
        <trans-unit id="03d2893cfc679a9464da447794034819fd2c6f44" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;used_memory_peak&lt;/code&gt;: Peak memory consumed by Redis (in bytes)</source>
          <target state="translated">&lt;code&gt;used_memory_peak&lt;/code&gt; : Redis가 소비 한 최대 메모리 (바이트)</target>
        </trans-unit>
        <trans-unit id="d6ccf6b76d558573e3c0fabfcc033f5c54af17d3" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;used_memory_peak_human&lt;/code&gt;: Human readable representation of previous value</source>
          <target state="translated">&lt;code&gt;used_memory_peak_human&lt;/code&gt; : 인간이 읽을 수있는 이전 값 표현</target>
        </trans-unit>
        <trans-unit id="95c64fa74f4f378fb6165e87d12311fdb312106a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;used_memory_peak_perc&lt;/code&gt;: The percentage of &lt;code&gt;used_memory_peak&lt;/code&gt; out of &lt;code&gt;used_memory&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;used_memory_peak_perc&lt;/code&gt; :의 비율 &lt;code&gt;used_memory_peak&lt;/code&gt; 중 &lt;code&gt;used_memory&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="3f221dda83245c669bda1e05655bd3ac2e0ab5f8" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;used_memory_rss&lt;/code&gt;: Number of bytes that Redis allocated as seen by the operating system (a.k.a resident set size). This is the number reported by tools such as &lt;code&gt;top(1)&lt;/code&gt; and &lt;code&gt;ps(1)&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;used_memory_rss&lt;/code&gt; : 운영 체제에서 볼 수 있듯이 Redis가 할당 한 바이트 수 (일명 상주 세트 크기). 이것은 &lt;code&gt;top(1)&lt;/code&gt; 및 &lt;code&gt;ps(1)&lt;/code&gt; 과 같은 도구로보고 된 숫자입니다.</target>
        </trans-unit>
        <trans-unit id="56f70f47101fda30eddf5ba143e549084227ebe8" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;used_memory_rss_human&lt;/code&gt;: Human readable representation of previous value</source>
          <target state="translated">&lt;code&gt;used_memory_rss_human&lt;/code&gt; : 인간이 읽을 수있는 이전 값 표현</target>
        </trans-unit>
        <trans-unit id="b409b28ae2a01206af36cb38e85fd023946f81d1" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;used_memory_startup&lt;/code&gt;: Initial amount of memory consumed by Redis at startup in bytes</source>
          <target state="translated">&lt;code&gt;used_memory_startup&lt;/code&gt; : 시작할 때 Redis가 소비 한 초기 메모리 양 (바이트)</target>
        </trans-unit>
        <trans-unit id="0779adce6efc8480503ae1ee70342fbc671c005f" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Note: starting with Redis 5, scripts are always replicated as effects and not sending the script verbatim. So the following section is mostly applicable to Redis version 4 or older.&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;참고 : Redis 5부터 스크립트는 항상 효과로 복제되며 스크립트를 그대로 보내지 않습니다. 따라서 다음 섹션은 대부분 Redis 버전 4 이상에 적용됩니다.&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="e19535a094281f66a7c86327ed5e3682df604f43" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Note: starting with Redis 5, the replication method described in this section (scripts effects replication) is the default and does not need to be explicitly enabled.&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;참고 : Redis 5부터이 섹션에 설명 된 복제 방법 (스크립트 효과 복제)이 기본값이며 명시 적으로 활성화 할 필요는 없습니다.&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="e13dca6da1f5cb034512c6f89e682ac5a816871f" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;admin&lt;/em&gt; - server admin command</source>
          <target state="translated">&lt;em&gt;admin-&lt;/em&gt; 서버 관리 명령</target>
        </trans-unit>
        <trans-unit id="10c2f31b9cb95d52492cefe272ee0ce7e7e96172" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;asking&lt;/em&gt; - cluster related - accept even if importing</source>
          <target state="translated">&lt;em&gt;묻기&lt;/em&gt; -클러스터 관련-가져 오기를해도 승인</target>
        </trans-unit>
        <trans-unit id="fd143e082b45bd6d7de12217c454560c80ccbc41" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;denyoom&lt;/em&gt; - reject command if currently OOM</source>
          <target state="translated">&lt;em&gt;denyoom-&lt;/em&gt; 현재 OOM 인 경우 명령 거부</target>
        </trans-unit>
        <trans-unit id="8cc88faeccf37dd9abce525d1e16c903b5653be7" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;fast&lt;/em&gt; - command operates in constant or log(N) time. Used for latency monitoring.</source>
          <target state="translated">&lt;em&gt;fast-&lt;/em&gt; 명령은 상수 또는 log (N) 시간에 작동합니다. 대기 시간 모니터링에 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="d7a26816637799c11c50ca22e1c31e62cfdc3324" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;loading&lt;/em&gt; - allow command while database is loading</source>
          <target state="translated">&lt;em&gt;loading-&lt;/em&gt; 데이터베이스가 로딩되는 동안 명령 허용</target>
        </trans-unit>
        <trans-unit id="35e295b11abb30e261e118848506ada08e20c863" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;movablekeys&lt;/em&gt; - keys have no pre-determined position. You must discover keys yourself.</source>
          <target state="translated">&lt;em&gt;움직일 수있는&lt;/em&gt; 키-키에는 미리 결정된 위치가 없습니다. 키를 직접 찾아야합니다.</target>
        </trans-unit>
        <trans-unit id="10bef8487cc510b84ad65623659536dca2bd88e2" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;noscript&lt;/em&gt; - deny this command from scripts</source>
          <target state="translated">&lt;em&gt;noscript-&lt;/em&gt; 스크립트에서이 명령을 거부</target>
        </trans-unit>
        <trans-unit id="22ad5604ab4408792b4dbb6841391c73eb5bcd3e" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;pubsub&lt;/em&gt; - pubsub-related command</source>
          <target state="translated">&lt;em&gt;pubsub&lt;/em&gt; -pubsub 관련 명령</target>
        </trans-unit>
        <trans-unit id="4657f2c9a9b6147be79ff8861078f0a1c0f21dc9" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;random&lt;/em&gt; - command has random results, dangerous for scripts</source>
          <target state="translated">&lt;em&gt;random-&lt;/em&gt; 명령에 임의의 결과가 발생하여 스크립트에 위험</target>
        </trans-unit>
        <trans-unit id="3952a7346643d82eda1f83fc8f67bd7841254782" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;readonly&lt;/em&gt; - command will never modify keys</source>
          <target state="translated">&lt;em&gt;readonly-&lt;/em&gt; 명령은 키를 수정하지 않습니다</target>
        </trans-unit>
        <trans-unit id="e5695fb2252476f28d156ffb338071b2a1d167d9" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;skip_monitor&lt;/em&gt; - do not show this command in MONITOR</source>
          <target state="translated">&lt;em&gt;skip_monitor&lt;/em&gt; -MONITOR에서이 명령을 표시하지 않습니다</target>
        </trans-unit>
        <trans-unit id="6e820b39ec4b2576d4194864a5c8cd2ba6855b08" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;sort_for_script&lt;/em&gt; - if called from script, sort output</source>
          <target state="translated">&lt;em&gt;sort_for_script-&lt;/em&gt; 스크립트에서 호출 된 경우 출력 정렬</target>
        </trans-unit>
        <trans-unit id="afaa4774ab65f2ceeccfa3570797867883f640b5" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;stale&lt;/em&gt; - allow command while replica has stale data</source>
          <target state="translated">&lt;em&gt;부실&lt;/em&gt; -복제본에 부실 데이터가있는 동안 명령 허용</target>
        </trans-unit>
        <trans-unit id="a314df10a9c4582edc32c3810d68e266cd2ff50f" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;write&lt;/em&gt; - command may result in modifications</source>
          <target state="translated">&lt;em&gt;쓰기&lt;/em&gt; -명령이 수정 될 수 있음</target>
        </trans-unit>
        <trans-unit id="42d17eeb4be4227b8e5ddf2b0e335361a9442b96" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;A note about the word slave used in this man page and command name&lt;/strong&gt;: Starting with Redis 5 this command: starting with Redis version 5, if not for backward compatibility, the Redis project no longer uses the word slave. Please use the new command &lt;a href=&quot;cluster-replicas&quot;&gt;CLUSTER REPLICAS&lt;/a&gt;. The command &lt;a href=&quot;slaveof&quot;&gt;SLAVEOF&lt;/a&gt; will continue to work for backward compatibility.</source>
          <target state="translated">&lt;strong&gt;이 매뉴얼 페이지에서 사용되는 단어 슬레이브 및 명령 이름에 대한 참고 사항&lt;/strong&gt; : Redis 5로 시작이 명령 : 이전 버전과의 호환성을 위해 Redis 버전 5로 시작하면 Redis 프로젝트는 더 이상 슬레이브라는 단어를 사용하지 않습니다. 새로운 명령 &lt;a href=&quot;cluster-replicas&quot;&gt;CLUSTER REPLICAS를&lt;/a&gt; 사용하십시오 . &lt;a href=&quot;slaveof&quot;&gt;SLAVEOF&lt;/a&gt; 명령 은 이전 버전과의 호환성을 위해 계속 작동합니다.</target>
        </trans-unit>
        <trans-unit id="22b987b44b7a5dd2e47b2e3eea2dfc49f06df3d6" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;A note about the word slave used in this man page and command name&lt;/strong&gt;: Starting with Redis 5 this command: starting with Redis version 5, if not for backward compatibility, the Redis project no longer uses the word slave. Please use the new command &lt;a href=&quot;replicaof&quot;&gt;REPLICAOF&lt;/a&gt;. The command &lt;a href=&quot;slaveof&quot;&gt;SLAVEOF&lt;/a&gt; will continue to work for backward compatibility.</source>
          <target state="translated">&lt;strong&gt;이 매뉴얼 페이지에서 사용되는 단어 슬레이브 및 명령 이름에 대한 참고 사항&lt;/strong&gt; : Redis 5로 시작이 명령 : 이전 버전과의 호환성을 위해 Redis 버전 5로 시작하면 Redis 프로젝트는 더 이상 슬레이브라는 단어를 사용하지 않습니다. 새 명령 &lt;a href=&quot;replicaof&quot;&gt;REPLICAOF를&lt;/a&gt; 사용하십시오 . &lt;a href=&quot;slaveof&quot;&gt;SLAVEOF&lt;/a&gt; 명령 은 이전 버전과의 호환성을 위해 계속 작동합니다.</target>
        </trans-unit>
        <trans-unit id="c99b58d7712fa94ddcaaec3a2960300b8a561396" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;A note about the word slave used in this man page and command name&lt;/strong&gt;: Starting with Redis 5, if not for backward compatibility, the Redis project no longer uses the word slave. Unfortunately in this command the word slave is part of the protocol, so we'll be able to remove such occurrences only when this API will be naturally deprecated.</source>
          <target state="translated">&lt;strong&gt;이 매뉴얼 페이지에서 사용되는 단어 슬레이브 및 명령 이름에 대한 참고 사항&lt;/strong&gt; : Redis 5부터는 하위 호환성을 위해 Redis 프로젝트에서 더 이상 단어 슬레이브를 사용하지 않습니다. 불행하게도이 명령에서 slave라는 단어는 프로토콜의 일부이므로이 API가 자연스럽게 사용되지 않을 때만 그러한 발생을 제거 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1b440152e5e3583cee378a3b1e711d099bafed4a" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;A note about the word slave used in this man page&lt;/strong&gt;: Starting with Redis 5, if not for backward compatibility, the Redis project no longer uses the word slave. Unfortunately in this command the word slave is part of the protocol, so we'll be able to remove such occurrences only when this API will be naturally deprecated.</source>
          <target state="translated">&lt;strong&gt;이 매뉴얼 페이지에서 사용 된 단어 슬레이브에 대한 참고 사항&lt;/strong&gt; : Redis 5부터는 하위 호환성을 위해 Redis 프로젝트에서 더 이상 단어 슬레이브를 사용하지 않습니다. 불행하게도이 명령에서 slave라는 단어는 프로토콜의 일부이므로이 API가 자연스럽게 사용되지 않을 때만 그러한 발생을 제거 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="66dc6dfb23eee314b12cd2731c54cf1fcc6f78b6" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Available since 1.0.0.&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;1.0.0부터 사용 가능합니다.&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="bafcacc0e3c7960ad2cb8f503d72f30f78ca254b" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Available since 1.0.1.&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;1.0.1부터 사용 가능합니다.&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="42ef041208b3c7f6b84ee588b6d7090649da3cde" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Available since 1.0.5.&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;1.0.5부터 사용 가능합니다.&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="2979205dcc40ec82cc62cbda6a41df44b1490b3d" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Available since 1.2.0.&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;1.2.0부터 사용 가능합니다.&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="28e1ed9a5b6011c62e872df0b23f6461d63b067c" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Available since 2.0.0.&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;2.0.0부터 사용 가능합니다.&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="2856d7513ee771916c2aaae5a59c9760f4c9ee69" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Available since 2.2.0.&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;2.2.0부터 사용 가능합니다.&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="97df2e6716f64385365f3793fe17b2b2b8c49250" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Available since 2.2.12.&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;2.2.12부터 사용 가능합니다.&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="2af9ad13d1bc44db9e41a723957913e50bb83c15" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Available since 2.2.3.&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;2.2.3부터 사용 가능합니다.&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="2604a994ca379d977a81045288fcf1fb1a12b6eb" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Available since 2.4.0.&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;2.4.0부터 사용 가능합니다.&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="4b3e52d68eec5b69a8580d7244b4cdd30126edfc" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Available since 2.6.0.&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;2.6.0부터 사용 가능합니다.&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="ad155abecba93e556fc2964349d42546bbd57c37" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Available since 2.6.9.&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;2.6.9부터 사용 가능합니다.&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="433a172e52c0f75503c2591c44f351278b8a2f1f" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Available since 2.8.0.&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;2.8.0부터 사용 가능합니다.&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="32a14135298102cba37c7a031f64183e68e7a403" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Available since 2.8.12.&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;2.8.12부터 사용 가능합니다.&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="070bc5f809a6dcd424c69365545356941c2c87e0" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Available since 2.8.13.&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;2.8.13부터 사용 가능합니다.&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="eeef4c5b6e8d514cf3970118cf5eecd9fc93d806" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Available since 2.8.7.&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;2.8.7부터 사용 가능합니다.&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="a139b314b3eeac41f2cb4b52b420d048c12b572d" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Available since 2.8.9.&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;2.8.9부터 사용 가능합니다.&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="110407b93d6631c2f87c8bcf0b09b41e5dd1585a" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Available since 2.9.50.&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;2.9.50부터 사용 가능합니다.&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="947745c28030ed2d02d2d6bf7ae0327d4548b7d5" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Available since 3.0.0.&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;3.0.0부터 사용 가능합니다.&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="000c6853ef4da627b8791fda02e7112106e57268" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Available since 3.2.0.&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;3.2.0부터 사용 가능합니다.&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="248abe6dbbd5bde7dfe7a190fa8676bdabbee407" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Available since 3.2.1.&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;3.2.1부터 사용 가능합니다.&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="7787594e7b7fa02a64ea0ac1f47edf5c68240aa7" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Available since 3.2.&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;3.2부터 사용 가능합니다.&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="76c11f357d1203d366fa5e186202643c7f75fe3f" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Available since 4.0.0.&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;4.0.0부터 사용 가능합니다.&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="fb77e7f9038cd769ce8cf62ccaacda589c6f003f" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Available since 5.0.0.&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;5.0.0부터 사용 가능합니다.&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="37ad352b4b8a994d3447d680cfa6aac8d4baddae" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;CH&lt;/strong&gt;: Modify the return value from the number of new elements added, to the total number of elements changed (CH is an abbreviation of &lt;em&gt;changed&lt;/em&gt;). Changed elements are &lt;strong&gt;new elements added&lt;/strong&gt; and elements already existing for which &lt;strong&gt;the score was updated&lt;/strong&gt;. So elements specified in the command line having the same score as they had in the past are not counted. Note: normally the return value of &lt;a href=&quot;zadd&quot;&gt;ZADD&lt;/a&gt; only counts the number of new elements added.</source>
          <target state="translated">&lt;strong&gt;CH&lt;/strong&gt; : 추가 된 새 요소 수에서 변경된 총 요소 수로 리턴 값을 수정하십시오 (CH는 &lt;em&gt;changed&lt;/em&gt; 의 약어 임 ). 변경된 요소는 &lt;strong&gt;점수가 업데이트 된 &lt;/strong&gt;&lt;strong&gt;새로운 요소&lt;/strong&gt; 와 이미 존재하는 요소 입니다. 따라서 명령 줄에 지정된 요소가 과거와 동일한 점수를 갖는 것은 계산되지 않습니다. 참고 : 일반적으로 &lt;a href=&quot;zadd&quot;&gt;ZADD&lt;/a&gt; 의 반환 값은 추가 된 새 요소의 수만 계산합니다.&lt;strong&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="df8c1ee6b8ea782dadcbe9b7a6f6ee7e14cd37c0" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;ERROR&lt;/strong&gt;: both C1 and C2 acquired the lock because of the race condition.</source>
          <target state="translated">&lt;strong&gt;오류&lt;/strong&gt; : 경쟁 조건으로 인해 C1과 C2가 잠금을 획득했습니다.</target>
        </trans-unit>
        <trans-unit id="a87aecd8a98bb8da49b78363fdf6ad6d0ad4ad9b" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;FAIL&lt;/strong&gt;: in this mode no operation is performed on overflows or underflows detected. The corresponding return value is set to NULL to signal the condition to the caller.</source>
          <target state="translated">&lt;strong&gt;FAIL&lt;/strong&gt; :이 모드에서는 오버플로 또는 언더 플로가 감지되면 아무런 작업도 수행되지 않습니다. 해당 리턴 값은 조건을 호출자에게 알리기 위해 NULL로 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="2f2e999f961e4cb70747a82c7afe1e1ac4d14dd0" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;GET&lt;/strong&gt;&lt;code&gt;&amp;lt;type&amp;gt;&lt;/code&gt;&lt;code&gt;&amp;lt;offset&amp;gt;&lt;/code&gt; -- Returns the specified bit field.</source>
          <target state="translated">&lt;strong&gt;GET &lt;/strong&gt; &lt;code&gt;&amp;lt;type&amp;gt;&lt;/code&gt; &lt;code&gt;&amp;lt;offset&amp;gt;&lt;/code&gt; -지정된 비트 필드를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="a95ec0f36765c66b1ab2481704998d8a28483766" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Hard reset only&lt;/strong&gt;: &lt;code&gt;currentEpoch&lt;/code&gt; and &lt;code&gt;configEpoch&lt;/code&gt; vars are set to 0.</source>
          <target state="translated">&lt;strong&gt;하드 리셋 만&lt;/strong&gt; : &lt;code&gt;currentEpoch&lt;/code&gt; 및 &lt;code&gt;configEpoch&lt;/code&gt; 변수는 0으로 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="a3dd45a98f533d02befd41f941271bbba011d7a2" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Hard reset only&lt;/strong&gt;: a new Node ID is generated.</source>
          <target state="translated">&lt;strong&gt;하드 리셋 만&lt;/strong&gt; : 새로운 노드 ID가 생성됩니다.</target>
        </trans-unit>
        <trans-unit id="55df25f32f77293934878d2a89f464b77726ab0c" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;INCR&lt;/strong&gt;: When this option is specified &lt;a href=&quot;zadd&quot;&gt;ZADD&lt;/a&gt; acts like &lt;a href=&quot;zincrby&quot;&gt;ZINCRBY&lt;/a&gt;. Only one score-element pair can be specified in this mode.</source>
          <target state="translated">&lt;strong&gt;INCR&lt;/strong&gt; :이 옵션이 지정 &lt;a href=&quot;zadd&quot;&gt;되면 ZADD&lt;/a&gt; 는 ZINCRBY 와 같은 &lt;a href=&quot;zincrby&quot;&gt;역할을&lt;/a&gt; 합니다. 이 모드에서는 하나의 점수 요소 쌍만 지정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="07a043543d639e8331184b587a20bbea7427d520" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;INCRBY&lt;/strong&gt;&lt;code&gt;&amp;lt;type&amp;gt;&lt;/code&gt;&lt;code&gt;&amp;lt;offset&amp;gt;&lt;/code&gt;&lt;code&gt;&amp;lt;increment&amp;gt;&lt;/code&gt; -- Increments or decrements (if a negative increment is given) the specified bit field and returns the new value.</source>
          <target state="translated">&lt;strong&gt;INCRBY &lt;/strong&gt; &lt;code&gt;&amp;lt;type&amp;gt;&lt;/code&gt; &lt;code&gt;&amp;lt;offset&amp;gt;&lt;/code&gt; &lt;code&gt;&amp;lt;increment&amp;gt;&lt;/code&gt; -지정된 비트 필드를 증가 또는 감소 (음수 증분이 주어지면)하고 새 값을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="e46a2f0474829b059fcc7d34e4ee9e4caec81736" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Important note:&lt;/strong&gt; avoid debugging Lua scripts using your Redis production server. Use a development server instead.</source>
          <target state="translated">&lt;strong&gt;중요 사항 :&lt;/strong&gt; Redis 프로덕션 서버를 사용하여 Lua 스크립트를 디버깅하지 마십시오. 대신 개발 서버를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="2ce5ee9654c6340e1e4eb82e8c83ddf58293784d" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Importing slot:&lt;/strong&gt;&lt;code&gt;[slot_number-&amp;lt;-importing_from_node_id]&lt;/code&gt;</source>
          <target state="translated">&lt;strong&gt;가져 오기 슬롯 : &lt;/strong&gt; &lt;code&gt;[slot_number-&amp;lt;-importing_from_node_id]&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="3012a85d56005df4704a75489bb8df125742014e" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Importing&lt;/strong&gt; slots are yet not part of the nodes hash slot, there is a migration in progress. The node will accept queries about these slots only if the &lt;code&gt;ASK&lt;/code&gt; command is used.</source>
          <target state="translated">&lt;strong&gt;가져 오기&lt;/strong&gt; 슬롯이 아직 노드 해시 슬롯의 일부가 아니므로 마이그레이션이 진행 중입니다. 노드는 &lt;code&gt;ASK&lt;/code&gt; 명령이 사용되는 경우에만이 슬롯에 대한 쿼리를 수락합니다 .</target>
        </trans-unit>
        <trans-unit id="6c6c8886e8352c3a3901fd75105c549ff1c8badd" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;In the above code there is a race condition&lt;/strong&gt;. If for some reason the client performs the &lt;a href=&quot;incr&quot;&gt;INCR&lt;/a&gt; command but does not perform the &lt;a href=&quot;expire&quot;&gt;EXPIRE&lt;/a&gt; the key will be leaked until we'll see the same IP address again.</source>
          <target state="translated">&lt;strong&gt;위의 코드에는 경쟁 조건이&lt;/strong&gt; 있습니다. 어떤 이유로 클라이언트가 &lt;a href=&quot;incr&quot;&gt;INCR&lt;/a&gt; 명령을 수행 하지만 &lt;a href=&quot;expire&quot;&gt;EXPIRE를&lt;/a&gt; 수행하지 않으면 동일한 IP 주소가 다시 표시 될 때까지 키가 유출됩니다.</target>
        </trans-unit>
        <trans-unit id="080ca67a419bf57eb4ca474c2ead958e0b17c394" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Lua to Redis&lt;/strong&gt; conversion table.</source>
          <target state="translated">&lt;strong&gt;루아에서 레디로&lt;/strong&gt; 변환 표.</target>
        </trans-unit>
        <trans-unit id="594305ca901fa3745571fd4ea2d83b7d124a9536" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Migrating slot:&lt;/strong&gt;&lt;code&gt;[slot_number-&amp;gt;-migrating_to_node_id]&lt;/code&gt;</source>
          <target state="translated">&lt;strong&gt;마이그레이션 슬롯 : &lt;/strong&gt; &lt;code&gt;[slot_number-&amp;gt;-migrating_to_node_id]&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="85d815f21360631a4d040aed811d832f36975a50" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Migrating&lt;/strong&gt; slots are assigned to the node, but are being migrated to some other node. The node will accept queries if all the keys in the command exist already, otherwise it will emit what is called an &lt;strong&gt;ASK redirection&lt;/strong&gt;, to force new keys creation directly in the importing node.</source>
          <target state="translated">&lt;strong&gt;마이그레이션&lt;/strong&gt; 슬롯이 노드에 할당되었지만 다른 노드로 마이그레이션되고 있습니다. 노드는 명령의 모든 키가 이미 존재하는 경우 쿼리를 수락합니다. 그렇지 않으면 가져 오기 노드에서 직접 새 키를 작성하기 위해 &lt;strong&gt;ASK 리디렉션&lt;/strong&gt; 을 생성합니다.</target>
        </trans-unit>
        <trans-unit id="4542730e02f1444f396e1eecd3fb084c50899588" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;NX&lt;/strong&gt;: Don't update already existing elements. Always add new elements.</source>
          <target state="translated">&lt;strong&gt;NX&lt;/strong&gt; : 기존 요소를 업데이트하지 않습니다. 항상 새로운 요소를 추가하십시오.</target>
        </trans-unit>
        <trans-unit id="c0e14174973d3f14160192d3ec335ea216ce5838" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Non standard return value&lt;/strong&gt;, just dumps the received commands in an infinite flow.</source>
          <target state="translated">&lt;strong&gt;비표준 반환 값&lt;/strong&gt; 은 수신 된 명령을 무한 흐름으로 덤프합니다.</target>
        </trans-unit>
        <trans-unit id="4d1b440d6bea75ebf4fddb300ea88cb48bb7d506" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note that you should not rely on the fields exact position&lt;/strong&gt;, nor on the number of fields, new fields may be added in the future. So a well behaving client should fetch the whole list, and report it to the user, for example, as a dictionary data structure. Low level clients such as C clients where the items will likely be reported back in a linear array should document that the order is undefined.</source>
          <target state="translated">&lt;strong&gt;필드의 정확한 위치&lt;/strong&gt; 나 &lt;strong&gt;필드 수에 의존해서는 안되며&lt;/strong&gt; 나중에 새 필드가 추가 될 수 있습니다. 따라서 잘 동작하는 클라이언트는 전체 목록을 가져 와서이를 사전 데이터 구조와 같이 사용자에게보고해야합니다. 항목이 선형 배열로 다시보고 될 가능성이 높은 C 클라이언트와 같은 하위 레벨 클라이언트는 주문이 정의되지 않았 음을 문서화해야합니다.</target>
        </trans-unit>
        <trans-unit id="bf38dc5f18a7403e0505cd57203e709ee2e82876" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note: starting with Redis 5 the project is no longer using the slave word. You can use &lt;code&gt;TYPE replica&lt;/code&gt; instead, however the old form is still supported for backward compatibility.&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;참고 : Redis 5부터는 프로젝트에서 더 이상 종속 어를 사용하지 않습니다. 대신 &lt;code&gt;TYPE replica&lt;/code&gt; 사용할 수 있지만 이전 형식은 여전히 ​​이전 버전과의 호환성을 위해 지원됩니다.&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="169026e4cfeed9baf12881fcf75891516330178a" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; Before Redis 3.2.0, an error is returned if source and destination names are the same.</source>
          <target state="translated">&lt;strong&gt;참고 :&lt;/strong&gt; Redis 3.2.0 이전에는 소스 및 대상 이름이 동일한 경우 오류가 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="48b058dcb40890f2ca5c1f12103c9113b5379791" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; The following pattern is discouraged in favor of &lt;a href=&quot;http://redis.io/topics/distlock&quot;&gt;the Redlock algorithm&lt;/a&gt; which is only a bit more complex to implement, but offers better guarantees and is fault tolerant.</source>
          <target state="translated">&lt;strong&gt;참고 :&lt;/strong&gt; 다음 패턴은 구현하기가 조금 더 복잡하지만 더 나은 보증을 제공하고 내결함성 이 &lt;a href=&quot;http://redis.io/topics/distlock&quot;&gt;있는 Redlock 알고리즘&lt;/a&gt; 을 사용 하지 않는 것이 좋습니다 .</target>
        </trans-unit>
        <trans-unit id="480b1ec2a7ba19faaf34095bd31fd8c13e719460" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; there is no &lt;strong&gt;GEODEL&lt;/strong&gt; command because you can use &lt;a href=&quot;zrem&quot;&gt;ZREM&lt;/a&gt; in order to remove elements. The Geo index structure is just a sorted set.</source>
          <target state="translated">&lt;strong&gt;참고 :&lt;/strong&gt; 더 없다 &lt;strong&gt;GEODEL를&lt;/strong&gt; 사용할 수 있기 때문에 명령 &lt;a href=&quot;zrem&quot;&gt;ZREM을&lt;/a&gt; 제거 요소를 위해. Geo 인덱스 구조는 정렬 된 집합입니다.</target>
        </trans-unit>
        <trans-unit id="66410825f423db9b4d7ddad345a43a6851da1c99" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: because of the high performance nature of Redis, it is possible to try a lot of passwords in parallel in very short time, so make sure to generate a strong and very long password so that this attack is infeasible.</source>
          <target state="translated">&lt;strong&gt;참고&lt;/strong&gt; : Redis의 고성능 특성으로 인해 짧은 시간에 많은 암호를 동시에 시도 할 수 있으므로 강력하고 매우 긴 암호를 생성하여이 공격을 실행할 수 없도록하십시오.</target>
        </trans-unit>
        <trans-unit id="2e7b910f0576d349936d98bea109218640bde9ec" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: this is a string operation because Redis does not have a dedicated integer type. The string stored at the key is interpreted as a base-10 &lt;strong&gt;64 bit signed integer&lt;/strong&gt; to execute the operation.</source>
          <target state="translated">&lt;strong&gt;참고&lt;/strong&gt; : Redis에는 전용 정수 유형이 없으므로 문자열 작업입니다. 키에 저장된 문자열은 기본 10 &lt;strong&gt;64 비트 부호있는 정수&lt;/strong&gt; 로 해석되어 작업을 실행합니다.</target>
        </trans-unit>
        <trans-unit id="7154ee5b1cdc329d8b78fa7fc770d684c0e65dcb" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;OVERFLOW&lt;/strong&gt;&lt;code&gt;[WRAP|SAT|FAIL]&lt;/code&gt;</source>
          <target state="translated">&lt;strong&gt;OVERFLOW&lt;/strong&gt;&lt;code&gt;[WRAP|SAT|FAIL]&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="e175dad8e0390b7908b5360d2ccd15b75eeca63a" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Please note that:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;점에 유의하시기 바랍니다:&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="6f3ee1f33563f6776e77dae5878a039952e3dce8" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Redis to Lua&lt;/strong&gt; conversion table.</source>
          <target state="translated">&lt;strong&gt;Redis에서 Lua로&lt;/strong&gt; 변환 표.</target>
        </trans-unit>
        <trans-unit id="dfe05bbd1f39f62442e2cbf4bde38def83156b1c" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;SAT&lt;/strong&gt;: uses saturation arithmetic, that is, on underflows the value is set to the minimum integer value, and on overflows to the maximum integer value. For example incrementing an &lt;code&gt;i8&lt;/code&gt; integer starting from value 120 with an increment of 10, will result into the value 127, and further increments will always keep the value at 127. The same happens on underflows, but towards the value is blocked at the most negative value.</source>
          <target state="translated">&lt;strong&gt;SAT&lt;/strong&gt; : 포화 산술을 사용합니다. 즉, 언더 플로에서 값이 최소 정수 값으로 설정되고 오버플로에서 최대 정수 값으로 오버플로됩니다. 예를 들어 , 값 120에서 시작하여 10 씩 증가하는 &lt;code&gt;i8&lt;/code&gt; 정수를 증가 시키면 값은 127이되고, 추가 증가는 항상 값을 127로 유지합니다. 언더 플로우에서도 동일하게 발생하지만 값에 대한 값은 가장 음수로 차단됩니다. 값.</target>
        </trans-unit>
        <trans-unit id="1408628eac488c273fe94ce3069837b4615f952e" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;SET&lt;/strong&gt;&lt;code&gt;&amp;lt;type&amp;gt;&lt;/code&gt;&lt;code&gt;&amp;lt;offset&amp;gt;&lt;/code&gt;&lt;code&gt;&amp;lt;value&amp;gt;&lt;/code&gt; -- Set the specified bit field and returns its old value.</source>
          <target state="translated">&lt;strong&gt;SET &lt;/strong&gt; &lt;code&gt;&amp;lt;type&amp;gt;&lt;/code&gt; &lt;code&gt;&amp;lt;offset&amp;gt;&lt;/code&gt; &lt;code&gt;&amp;lt;value&amp;gt;&lt;/code&gt; -지정된 비트 필드를 설정하고 이전 값을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="154c3e795e5c1982b62afd2e5d5d6ba3b9edff78" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;SHUTDOWN NOSAVE&lt;/strong&gt; will prevent a DB saving operation even if one or more save points are configured. (You can think of this variant as an hypothetical &lt;strong&gt;ABORT&lt;/strong&gt; command that just stops the server).</source>
          <target state="translated">&lt;strong&gt;SHUTDOWN NOSAVE&lt;/strong&gt; 는 하나 이상의 저장 지점이 구성되어 있어도 DB 저장 작업을 방지합니다. 이 변형을 서버를 중지 시키는 가상 &lt;strong&gt;ABORT&lt;/strong&gt; 명령 으로 생각할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="9e5c55a7d3de34798b279180cf9d3cd081c884b6" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;SHUTDOWN SAVE&lt;/strong&gt; will force a DB saving operation even if no save points are configured.</source>
          <target state="translated">&lt;strong&gt;SHUTDOWN SAVE&lt;/strong&gt; 는 저장 지점이 구성되지 않은 경우에도 DB 저장 작업을 수행합니다.</target>
        </trans-unit>
        <trans-unit id="4908775239d52b8a249c687e49f93d0788e39894" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;The timeout argument is interpreted as an integer value specifying the maximum number of seconds to block&lt;/strong&gt;. A timeout of zero can be used to block indefinitely.</source>
          <target state="translated">&lt;strong&gt;시간 초과 인수는 차단할 최대 시간 (초)을 지정하는 정수 값으로 해석됩니다&lt;/strong&gt; . 시간 종료 0은 무기한 차단하는 데 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="18c64c5033a261ea8682fefd1c4d266d085bb5af" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Time complexity:&lt;/strong&gt; Depends on the script that is executed.</source>
          <target state="translated">&lt;strong&gt;시간 복잡도 :&lt;/strong&gt; 실행되는 스크립트에 따라 다릅니다.</target>
        </trans-unit>
        <trans-unit id="4c297bf650da1f0e475df73b56cf1ac69d632e5d" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Time complexity:&lt;/strong&gt; For each stream mentioned: O(M) with M being the number of elements returned. If M is constant (e.g. always asking for the first 10 elements with COUNT), you can consider it O(1). On the other side when XREADGROUP blocks, XADD will pay the O(N) time in order to serve the N clients blocked on the stream getting new data.</source>
          <target state="translated">&lt;strong&gt;시간 복잡성 :&lt;/strong&gt; 언급 된 각 스트림에 대해 : O (M), M은 반환 된 요소 수입니다. M이 일정하면 (예 : 항상 COUNT로 처음 10 개의 요소를 요구하는 경우) O (1)로 간주 할 수 있습니다. 반면에 XREADGROUP이 차단되면 XADD는 새로운 데이터를받는 스트림에서 차단 된 N 개의 클라이언트에게 서비스를 제공하기 위해 O (N) 시간을 지불합니다.</target>
        </trans-unit>
        <trans-unit id="bd8b5ee7f2421c47e339ced1729fc4553418147c" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Time complexity:&lt;/strong&gt; For each stream mentioned: O(N) with N being the number of elements being returned, it menas that XREAD-ing with a fixed COUNT is O(1). Note that when the BLOCK option is used, XADD will pay O(M) time in order to serve the M clients blocked on the stream getting new data.</source>
          <target state="translated">&lt;strong&gt;시간 복잡성 :&lt;/strong&gt; 언급 된 각 스트림에 대해 : N이 반환되는 요소 수인 O (N), 고정 COUNT의 XREAD-ing은 O (1)입니다. BLOCK 옵션을 사용하면 XADD는 새 데이터를 가져 오는 스트림에서 차단 된 M 클라이언트에게 서비스를 제공하기 위해 O (M) 시간을 지불합니다.</target>
        </trans-unit>
        <trans-unit id="d1fd412d03fc2b530c2b27d7b45b0385a31cf6e5" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Time complexity:&lt;/strong&gt; O(1)</source>
          <target state="translated">&lt;strong&gt;시간 복잡도 :&lt;/strong&gt; O (1)</target>
        </trans-unit>
        <trans-unit id="55633d506fbeea6161b511b8a54465821794f5cd" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Time complexity:&lt;/strong&gt; O(1) for all the currently implemented subcommands.</source>
          <target state="translated">&lt;strong&gt;시간 복잡도 :&lt;/strong&gt; 현재 구현 된 모든 하위 명령에 대한 O (1)</target>
        </trans-unit>
        <trans-unit id="b44242f4720bce6423a8ffc796b452d96e431af2" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Time complexity:&lt;/strong&gt; O(1) for all the subcommands, with the exception of the DESTROY subcommand which takes an additional O(M) time in order to delete the M entries inside the consumer group pending entries list (PEL).</source>
          <target state="translated">&lt;strong&gt;시간 복잡도 :&lt;/strong&gt; 소비자 그룹 보류 항목 목록 (PEL) 내의 M 항목을 삭제하기 위해 추가 O (M) 시간이 걸리는 DESTROY 하위 명령을 제외한 모든 하위 명령의 O (1).</target>
        </trans-unit>
        <trans-unit id="520d8e26a668641abf11a642c0f43432b1535181" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Time complexity:&lt;/strong&gt; O(1) for each element added, so O(N) to add N elements when the command is called with multiple arguments.</source>
          <target state="translated">&lt;strong&gt;시간 복잡도 :&lt;/strong&gt; 추가 된 각 요소에 대한 O (1)이므로 명령이 여러 인수와 함께 호출 될 때 O (N)은 N 요소를 추가합니다.</target>
        </trans-unit>
        <trans-unit id="8eb838dfbc1d23415a7fe8a01586a99b88c8b560" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Time complexity:&lt;/strong&gt; O(1) for each key removed regardless of its size. Then the command does O(N) work in a different thread in order to reclaim memory, where N is the number of allocations the deleted objects where composed of.</source>
          <target state="translated">&lt;strong&gt;시간 복잡성 :&lt;/strong&gt; 크기에 관계없이 각 키의 O (1)가 제거되었습니다. 그런 다음 명령은 메모리를 회수하기 위해 다른 스레드에서 O (N)을 수행합니다. 여기서 N은 삭제 된 오브젝트가 구성된 위치의 수입니다.</target>
        </trans-unit>
        <trans-unit id="0ee729ae062b27a778521924a23715d1f5a2f8c1" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Time complexity:&lt;/strong&gt; O(1) for each message ID processed.</source>
          <target state="translated">&lt;strong&gt;시간 복잡성 :&lt;/strong&gt; 처리 된 각 메시지 ID에 대한 O (1)</target>
        </trans-unit>
        <trans-unit id="1b4eeec474e03615439c6b07161a4a898251fa48" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Time complexity:&lt;/strong&gt; O(1) for each single item to delete in the stream, regardless of the stream size.</source>
          <target state="translated">&lt;strong&gt;시간 복잡도 :&lt;/strong&gt; 스트림 크기에 관계없이 스트림에서 삭제할 각 단일 항목에 대한 O (1).</target>
        </trans-unit>
        <trans-unit id="3713a469f5558b38e0174355b7bd91512dde4739" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Time complexity:&lt;/strong&gt; O(1) for each subcommand specified</source>
          <target state="translated">&lt;strong&gt;시간 복잡도 :&lt;/strong&gt; 지정된 각 하위 명령에 대한 O (1)</target>
        </trans-unit>
        <trans-unit id="e32e66d8d957b6ef84d7d5e82b7e3681ca99b974" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Time complexity:&lt;/strong&gt; O(1) for every call. O(N) for a complete iteration, including enough command calls for the cursor to return back to 0. N is the number of elements inside the collection.</source>
          <target state="translated">&lt;strong&gt;시간 복잡도 :&lt;/strong&gt; 모든 통화에 대한 O (1). 커서가 0으로 되돌아 갈 수 있도록 충분한 명령 호출을 포함하여 전체 반복에 대한 O (N). N은 콜렉션 내부의 요소 수입니다.</target>
        </trans-unit>
        <trans-unit id="bd0e3bce04476c33f576529cb977579b2c937bb1" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Time complexity:&lt;/strong&gt; O(1) for every call. O(N) for a complete iteration, including enough command calls for the cursor to return back to 0. N is the number of elements inside the collection..</source>
          <target state="translated">&lt;strong&gt;시간 복잡도 :&lt;/strong&gt; 모든 통화에 대한 O (1). 커서가 0으로 되돌아 갈 수 있도록 충분한 명령 호출을 포함하여 완전한 반복을위한 O (N). N은 콜렉션 내부의 요소 수입니다.</target>
        </trans-unit>
        <trans-unit id="8bb7886d25c8e4f04cefc6d407e66e3510ca7843" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Time complexity:&lt;/strong&gt; O(1) for every key.</source>
          <target state="translated">&lt;strong&gt;시간 복잡도 :&lt;/strong&gt; 모든 키에 대한 O (1).</target>
        </trans-unit>
        <trans-unit id="e91064b0a93173883f68e80de9b9109a1b47c2be" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Time complexity:&lt;/strong&gt; O(1) to access the key and additional O(N*M) to serialized it, where N is the number of Redis objects composing the value and M their average size. For small string values the time complexity is thus O(1)+O(1*M) where M is small, so simply O(1).</source>
          <target state="translated">&lt;strong&gt;시간 복잡성 :&lt;/strong&gt; 키에 액세스하기위한 O (1) 및 직렬화를위한 추가 O (N * M). 여기서 N은 값을 구성하는 Redis 객체의 수이고 M은 평균 크기입니다. 작은 문자열 값의 경우 시간 복잡도는 O (1) + O (1 * M)이며 여기서 M은 작으므로 간단히 O (1)입니다.</target>
        </trans-unit>
        <trans-unit id="eb869fdd06f1e9c7503112a8348a9c6a6c3c32da" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Time complexity:&lt;/strong&gt; O(1) to add every element.</source>
          <target state="translated">&lt;strong&gt;시간 복잡성 :&lt;/strong&gt; 모든 요소를 ​​추가하는 O (1)</target>
        </trans-unit>
        <trans-unit id="000e7bfc4f0d59a7eca161f93d84ccfe59e93fba" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Time complexity:&lt;/strong&gt; O(1) to create the new key and additional O(N*M) to reconstruct the serialized value, where N is the number of Redis objects composing the value and M their average size. For small string values the time complexity is thus O(1)+O(1*M) where M is small, so simply O(1). However for sorted set values the complexity is O(N*M*log(N)) because inserting values into sorted sets is O(log(N)).</source>
          <target state="translated">&lt;strong&gt;시간 복잡성 :&lt;/strong&gt; O (1) &lt;strong&gt;:&lt;/strong&gt; 새 키를 만들고 추가 O (N * M)을 사용하여 직렬화 된 값을 재구성합니다. 여기서 N은 값을 구성하는 Redis 개체의 수이고 M은 평균 크기입니다. 작은 문자열 값의 경우 시간 복잡도는 O (1) + O (1 * M)이며 여기서 M은 작으므로 간단히 O (1)입니다. 그러나 정렬 된 세트 값의 경우 정렬 된 세트에 값을 삽입하는 것이 O (log (N))이므로 복잡도는 O (N * M * log (N))입니다.</target>
        </trans-unit>
        <trans-unit id="b9a90a5fd9bab0ece6d137f9d36c393b3e901d97" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Time complexity:&lt;/strong&gt; O(1) with a very small average constant time when called with a single key. O(N) with N being the number of keys, and much bigger constant times, when called with multiple keys.</source>
          <target state="translated">&lt;strong&gt;시간 복잡도 :&lt;/strong&gt; 단일 키로 호출 할 때 평균 상수 시간이 매우 작은 O (1). 여러 키로 호출 될 때 N은 키 수이며 훨씬 더 큰 상수 시간을 갖는 O (N).</target>
        </trans-unit>
        <trans-unit id="c45e1943b751714517205357e597c388c0f665c5" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Time complexity:&lt;/strong&gt; O(1), not counting the time taken to copy the new string in place. Usually, this string is very small so the amortized complexity is O(1). Otherwise, complexity is O(M) with M being the length of the value argument.</source>
          <target state="translated">&lt;strong&gt;시간 복잡성 :&lt;/strong&gt; O (1), 새 문자열을 복사하는 데 걸린 시간을 계산하지 않습니다. 일반적으로이 문자열은 매우 작으므로 상각 복잡도는 O (1)입니다. 그렇지 않으면 복잡도는 O (M)이며 M은 값 인수의 길이입니다.</target>
        </trans-unit>
        <trans-unit id="c4b651952550615d9e490f3dbbf7dc5130247335" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Time complexity:&lt;/strong&gt; O(1). The amortized time complexity is O(1) assuming the appended value is small and the already present value is of any size, since the dynamic string library used by Redis will double the free space available on every reallocation.</source>
          <target state="translated">&lt;strong&gt;시간 복잡도 :&lt;/strong&gt; O (1). 추가 된 값이 작고 Redis에서 사용하는 동적 문자열 라이브러리가 모든 재 할당에서 사용 가능한 여유 공간을 두 배로 늘리기 때문에 추가 된 값이 작고 이미 존재하는 값의 크기를 가정하면 상각 시간 복잡도는 O (1)입니다.</target>
        </trans-unit>
        <trans-unit id="0395357e538314afbb36cc7212c8f51962579675" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Time complexity:&lt;/strong&gt; O(M*log(N)) with N being the number of elements in the sorted set and M the number of elements to be removed.</source>
          <target state="translated">&lt;strong&gt;시간 복잡도 :&lt;/strong&gt; O (M * log (N)) : N은 정렬 된 세트의 요소 수이고 M은 제거 할 요소 수입니다.</target>
        </trans-unit>
        <trans-unit id="9067f60dde5b44b871a9347672e48a72cd2cb2ef" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Time complexity:&lt;/strong&gt; O(N)</source>
          <target state="translated">&lt;strong&gt;시간 복잡도 :&lt;/strong&gt; O (N)</target>
        </trans-unit>
        <trans-unit id="04a38332e56a66ff430f83f4bbdae1e73532033c" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Time complexity:&lt;/strong&gt; O(N) for the CHANNELS subcommand, where N is the number of active channels, and assuming constant time pattern matching (relatively short channels and patterns). O(N) for the NUMSUB subcommand, where N is the number of requested channels. O(1) for the NUMPAT subcommand.</source>
          <target state="translated">&lt;strong&gt;시간 복잡도 :&lt;/strong&gt; CHANNELS 하위 명령의 경우 O (N). 여기서 N은 활성 채널 수이며 일정한 시간 패턴 일치 (상대적으로 짧은 채널 및 패턴)를 가정합니다. NUMSUB 부속 명령의 경우 O (N). 여기서 N은 요청 된 채널 수입니다. NUMPAT 부속 명령의 경우 O (1).</target>
        </trans-unit>
        <trans-unit id="0a446809019f44c824a87ec9581f040ffb0e32cc" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Time complexity:&lt;/strong&gt; O(N) to merge N HyperLogLogs, but with high constant times.</source>
          <target state="translated">&lt;strong&gt;시간 복잡도 :&lt;/strong&gt; N HyperLogLog를 병합하기위한 O (N)이지만 높은 상수 시간.</target>
        </trans-unit>
        <trans-unit id="b8fbb556b46eccd9ee90a7247a1e35f67f98fd2e" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Time complexity:&lt;/strong&gt; O(N) when N is number of commands to look up</source>
          <target state="translated">&lt;strong&gt;시간 복잡도 :&lt;/strong&gt; N이 조회 할 명령 수인 경우 O (N)</target>
        </trans-unit>
        <trans-unit id="7959df06155f35b6ddc9b6d1feda06302841d77a" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Time complexity:&lt;/strong&gt; O(N) where N is the length of the list.</source>
          <target state="translated">&lt;strong&gt;시간 복잡도 :&lt;/strong&gt; O (N) 여기서 N은 목록의 길이입니다.</target>
        </trans-unit>
        <trans-unit id="72642eae05e7dab533b332c5cc7043121b4eb448" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Time complexity:&lt;/strong&gt; O(N) where N is the length of the list. Setting either the first or the last element of the list is O(1).</source>
          <target state="translated">&lt;strong&gt;시간 복잡도 :&lt;/strong&gt; O (N) 여기서 N은 목록의 길이입니다. 목록의 첫 번째 또는 마지막 요소를 설정하는 것은 O (1)입니다.</target>
        </trans-unit>
        <trans-unit id="54b950ebac0582811758a19da3a9877ce7ade111" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Time complexity:&lt;/strong&gt; O(N) where N is the length of the returned string. The complexity is ultimately determined by the returned length, but because creating a substring from an existing string is very cheap, it can be considered O(1) for small strings.</source>
          <target state="translated">&lt;strong&gt;시간 복잡도 :&lt;/strong&gt; O (N) 여기서 N은 반환 된 문자열의 길이입니다. 복잡성은 궁극적으로 반환 된 길이에 의해 결정되지만 기존 문자열에서 하위 문자열을 만드는 것이 매우 저렴하므로 작은 문자열의 경우 O (1)로 간주 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="164650944548afb8bc10f6f390aa97a27b1dd4ec" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Time complexity:&lt;/strong&gt; O(N) where N is the number of arguments to the command</source>
          <target state="translated">&lt;strong&gt;시간 복잡도 :&lt;/strong&gt; O (N) 여기서 N은 명령에 대한 인수의 개수입니다.</target>
        </trans-unit>
        <trans-unit id="35c9a29ad1b88311937abb15a8aa02d7b6b2071f" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Time complexity:&lt;/strong&gt; O(N) where N is the number of bytes in the key</source>
          <target state="translated">&lt;strong&gt;시간 복잡도 :&lt;/strong&gt; O (N) 여기서 N은 키의 바이트 수입니다.</target>
        </trans-unit>
        <trans-unit id="9b705627d72f2e3b0a12c1259b2f056906d3a9f6" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Time complexity:&lt;/strong&gt; O(N) where N is the number of channels to subscribe to.</source>
          <target state="translated">&lt;strong&gt;시간 복잡도 :&lt;/strong&gt; O (N) 여기서 N은 구독 할 채널 수입니다.</target>
        </trans-unit>
        <trans-unit id="2f83e12fae75f45cf5ac83c347c3bbc7ddee079d" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Time complexity:&lt;/strong&gt; O(N) where N is the number of client connections</source>
          <target state="translated">&lt;strong&gt;시간 복잡도 :&lt;/strong&gt; O (N) 여기서 N은 클라이언트 연결 수입니다.</target>
        </trans-unit>
        <trans-unit id="705360038b21dac13659c6816299b035d79d167b" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Time complexity:&lt;/strong&gt; O(N) where N is the number of clients already subscribed to a channel.</source>
          <target state="translated">&lt;strong&gt;시간 복잡도 :&lt;/strong&gt; O (N) 여기서 N은 이미 채널에 가입 한 클라이언트 수입니다.</target>
        </trans-unit>
        <trans-unit id="b2d78dda8ec936c399d001d400dd7443b9ee0c51" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Time complexity:&lt;/strong&gt; O(N) where N is the number of elements to be removed by the operation.</source>
          <target state="translated">&lt;strong&gt;시간 복잡도 :&lt;/strong&gt; O (N) 여기서 N은 작업으로 제거 할 요소 수입니다.</target>
        </trans-unit>
        <trans-unit id="0c40ac5f4e7734966548a6b28cf6b09392f66af6" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Time complexity:&lt;/strong&gt; O(N) where N is the number of elements to traverse before seeing the value pivot. This means that inserting somewhere on the left end on the list (head) can be considered O(1) and inserting somewhere on the right end (tail) is O(N).</source>
          <target state="translated">&lt;strong&gt;시간 복잡도 :&lt;/strong&gt; O (N) 여기서 N은 값 피벗을보기 전에 순회 할 요소의 수입니다. 이것은 목록 (헤드)의 왼쪽 끝에 어딘가에 삽입하는 것은 O (1)로 간주 될 수 있고 오른쪽 끝에 어딘가에 삽입하는 것은 O (N)입니다.</target>
        </trans-unit>
        <trans-unit id="dbcd7d04c52b03234566b6cffd32fc24d56f81e6" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Time complexity:&lt;/strong&gt; O(N) where N is the number of elements to traverse to get to the element at index. This makes asking for the first or the last element of the list O(1).</source>
          <target state="translated">&lt;strong&gt;시간 복잡도 :&lt;/strong&gt; O (N) 여기서 N은 인덱스에서 요소에 도달하기 위해 순회 할 요소의 수입니다. 이것은리스트 O (1)의 첫 번째 또는 마지막 요소를 요구합니다.</target>
        </trans-unit>
        <trans-unit id="42c9869d291d0c82ca12d37bfb296709124a2c13" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Time complexity:&lt;/strong&gt; O(N) where N is the number of failure reports</source>
          <target state="translated">&lt;strong&gt;시간 복잡도 :&lt;/strong&gt; O (N) 여기서 N은 실패 보고서 수</target>
        </trans-unit>
        <trans-unit id="1725653c90b57cbd60fa6e80c674ffbcb0e5a30e" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Time complexity:&lt;/strong&gt; O(N) where N is the number of fields being requested.</source>
          <target state="translated">&lt;strong&gt;시간 복잡도 :&lt;/strong&gt; O (N) 여기서 N은 요청되는 필드 수입니다.</target>
        </trans-unit>
        <trans-unit id="29cd5bade215dc7c3978dfc57c99ee8f499e6f6e" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Time complexity:&lt;/strong&gt; O(N) where N is the number of fields being set.</source>
          <target state="translated">&lt;strong&gt;시간 복잡도 :&lt;/strong&gt; O (N) 여기서 N은 설정되는 필드 수입니다.</target>
        </trans-unit>
        <trans-unit id="ac2510981dfbc42572f4253d3ef88c1e9b86a518" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Time complexity:&lt;/strong&gt; O(N) where N is the number of fields to be removed.</source>
          <target state="translated">&lt;strong&gt;시간 복잡도 :&lt;/strong&gt; O (N) 여기서 N은 제거 할 필드 수입니다.</target>
        </trans-unit>
        <trans-unit id="c4ed0ee74b36a8a8a6b25ad9938bab2af27ed2f2" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Time complexity:&lt;/strong&gt; O(N) where N is the number of keys that will be removed. When a key to remove holds a value other than a string, the individual complexity for this key is O(M) where M is the number of elements in the list, set, sorted set or hash. Removing a single key that holds a string value is O(1).</source>
          <target state="translated">&lt;strong&gt;시간 복잡도 :&lt;/strong&gt; O (N) 여기서 N은 제거 할 키 수입니다. 제거 할 키에 문자열 이외의 값이있는 경우이 키의 개별 복잡도는 O (M)입니다. 여기서 M은 목록, 세트, ​​정렬 된 세트 또는 해시의 요소 수입니다. 문자열 값을 보유하는 단일 키를 제거하는 것은 O (1)입니다.</target>
        </trans-unit>
        <trans-unit id="bbd1ae90e162108290b25dbded69c117180e0d98" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Time complexity:&lt;/strong&gt; O(N) where N is the number of keys that will be touched.</source>
          <target state="translated">&lt;strong&gt;시간 복잡도 :&lt;/strong&gt; O (N) 여기서 N은 터치 할 키 수입니다.</target>
        </trans-unit>
        <trans-unit id="fdbd2fc9b2e398ad773c3eec1b76264cf5a60db4" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Time complexity:&lt;/strong&gt; O(N) where N is the number of keys to retrieve.</source>
          <target state="translated">&lt;strong&gt;시간 복잡도 :&lt;/strong&gt; O (N) 여기서 N은 검색 할 키 수입니다.</target>
        </trans-unit>
        <trans-unit id="a706ce590717441a0ad18f33b5fc106e514382b3" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Time complexity:&lt;/strong&gt; O(N) where N is the number of keys to set.</source>
          <target state="translated">&lt;strong&gt;시간 복잡도 :&lt;/strong&gt; O (N) 여기서 N은 설정할 키 수입니다.</target>
        </trans-unit>
        <trans-unit id="8ccf4d49a4b3207dc0caa665856d880472789cd4" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Time complexity:&lt;/strong&gt; O(N) where N is the number of known nodes. The command may execute a FLUSHALL as a side effect.</source>
          <target state="translated">&lt;strong&gt;시간 복잡도 :&lt;/strong&gt; O (N) 여기서 N은 알려진 노드의 수입니다. 이 명령은 FLUSHALL을 부작용으로 실행할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b3fe05d26b4346f8090d8c22849f30a16797b0db" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Time complexity:&lt;/strong&gt; O(N) where N is the number of members to be removed.</source>
          <target state="translated">&lt;strong&gt;시간 복잡도 :&lt;/strong&gt; O (N) 여기서 N은 제거 할 멤버 수입니다.</target>
        </trans-unit>
        <trans-unit id="19a9d92a5f1801bdae13f9bb5335a5eee87a12d2" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Time complexity:&lt;/strong&gt; O(N) where N is the number of patterns the client is already subscribed to.</source>
          <target state="translated">&lt;strong&gt;시간 복잡도 :&lt;/strong&gt; O (N) 여기서 N은 클라이언트가 이미 가입 한 패턴의 수입니다.</target>
        </trans-unit>
        <trans-unit id="03c2b3882ec00e832d7bf4bd77cbcd9fdcace961" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Time complexity:&lt;/strong&gt; O(N) where N is the number of samples.</source>
          <target state="translated">&lt;strong&gt;시간 복잡도 :&lt;/strong&gt; O (N) 여기서 N은 샘플 수입니다.</target>
        </trans-unit>
        <trans-unit id="88531e925e2a262fc6e01dce7370ffcc8ffe2aa6" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Time complexity:&lt;/strong&gt; O(N) where N is the set cardinality.</source>
          <target state="translated">&lt;strong&gt;시간 복잡도 :&lt;/strong&gt; O (N) 여기서 N은 설정된 카디널리티입니다.</target>
        </trans-unit>
        <trans-unit id="109fedc3e56bcb827556611a78c19db5912e0c01" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Time complexity:&lt;/strong&gt; O(N) where N is the size of the hash.</source>
          <target state="translated">&lt;strong&gt;시간 복잡도 :&lt;/strong&gt; O (N) 여기서 N은 해시 크기입니다.</target>
        </trans-unit>
        <trans-unit id="baf0055deddfa2f324ba5f8192d8bc7ae7177c81" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Time complexity:&lt;/strong&gt; O(N) where N is the total number of Cluster nodes</source>
          <target state="translated">&lt;strong&gt;시간 복잡도 :&lt;/strong&gt; O (N) 여기서 N은 총 클러스터 노드 수입니다.</target>
        </trans-unit>
        <trans-unit id="fbc1d10e31ece6bfe12f1012df99c1c058c772dc" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Time complexity:&lt;/strong&gt; O(N) where N is the total number of Redis commands</source>
          <target state="translated">&lt;strong&gt;시간 복잡도 :&lt;/strong&gt; O (N) 여기서 N은 총 Redis 명령 수입니다.</target>
        </trans-unit>
        <trans-unit id="383099b00063b0f99b6c3494f9ebddcefbd84c6f" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Time complexity:&lt;/strong&gt; O(N) where N is the total number of elements in all given sets.</source>
          <target state="translated">&lt;strong&gt;시간 복잡도 :&lt;/strong&gt; O (N) 여기서 N은 지정된 모든 집합의 총 요소 수입니다.</target>
        </trans-unit>
        <trans-unit id="1c69bede051d8ce4bce449d586cb3cccf85a3b93" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Time complexity:&lt;/strong&gt; O(N) where N is the total number of hash slot arguments</source>
          <target state="translated">&lt;strong&gt;시간 복잡도 :&lt;/strong&gt; O (N) 여기서 N은 총 해시 슬롯 인수 수입니다.</target>
        </trans-unit>
        <trans-unit id="94b9de6b87d525f4593b39b91d061f1cfc031edb" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Time complexity:&lt;/strong&gt; O(N) with N being the length in bytes of the script body.</source>
          <target state="translated">&lt;strong&gt;시간 복잡도 :&lt;/strong&gt; O (N), N은 스크립트 본문의 길이 (바이트)입니다.</target>
        </trans-unit>
        <trans-unit id="fbd178cb887e9efcf3828efc845699fd78801bc2" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Time complexity:&lt;/strong&gt; O(N) with N being the number of elements being returned. If N is constant (e.g. always asking for the first 10 elements with COUNT), you can consider it O(1).</source>
          <target state="translated">&lt;strong&gt;시간 복잡도 :&lt;/strong&gt; O (N), N은 반환되는 요소 수입니다. N이 일정하면 (예 : 항상 COUNT로 처음 10 개의 요소를 요구하는 경우) O (1)로 간주 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ef329378762b4fc8582540e6f4f372d96643c0a5" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Time complexity:&lt;/strong&gt; O(N) with N being the number of elements returned, so asking for a small fixed number of entries per call is O(1). When the command returns just the summary it runs in O(1) time assuming the list of consumers is small, otherwise there is additional O(N) time needed to iterate every consumer.</source>
          <target state="translated">&lt;strong&gt;시간 복잡도 :&lt;/strong&gt; O (N), N은 반환 된 요소 수이므로 호출 당 고정 된 수의 항목을 요구하는 것은 O (1)입니다. 명령이 요약 만 반환하면 소비자 목록이 작다고 가정하면 O (1) 시간에 실행됩니다. 그렇지 않으면 모든 소비자를 반복하는 데 추가 O (N) 시간이 필요합니다.</target>
        </trans-unit>
        <trans-unit id="218df20463938b64222d151783fb6950614cef84" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Time complexity:&lt;/strong&gt; O(N) with N being the number of elements returned. If N is constant (e.g. always asking for the first 10 elements with COUNT), you can consider it O(1).</source>
          <target state="translated">&lt;strong&gt;시간 복잡도 :&lt;/strong&gt; O (N), N은 반환 된 요소 수입니다. N이 일정하면 (예 : 항상 COUNT로 처음 10 개의 요소를 요구하는 경우) O (1)로 간주 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="59133b1321947fe750ca1f0a99b2da85624821b7" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Time complexity:&lt;/strong&gt; O(N) with N being the number of keys in the database, under the assumption that the key names in the database and the given pattern have limited length.</source>
          <target state="translated">&lt;strong&gt;시간 복잡성 :&lt;/strong&gt; 데이터베이스의 키 이름과 주어진 패턴의 길이가 제한되어 있다는 가정하에 N은 데이터베이스의 키 수인 N (N)입니다.</target>
        </trans-unit>
        <trans-unit id="e812a95d6dc88a78e988d85e0cb241d393f6a9fc" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Time complexity:&lt;/strong&gt; O(N) with N being the number of returned items for the subcommands CONSUMERS and GROUPS. The STREAM subcommand is O(log N) with N being the number of items in the stream.</source>
          <target state="translated">&lt;strong&gt;시간 복잡도 :&lt;/strong&gt; O (N), N은 부속 명령 CONSUMERS 및 GROUPS에 대해 리턴 된 항목 수입니다. STREAM 부속 명령은 O (log N)이며 N은 스트림의 항목 수입니다.</target>
        </trans-unit>
        <trans-unit id="0811266035ec21c353438938266dc4d45fea8c09" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Time complexity:&lt;/strong&gt; O(N) with N being the number of scripts in cache</source>
          <target state="translated">&lt;strong&gt;시간 복잡도 :&lt;/strong&gt; O (N), N은 캐시의 스크립트 수</target>
        </trans-unit>
        <trans-unit id="e5c63104f4af7f67dd0af60830b19ca65f07dc0b" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Time complexity:&lt;/strong&gt; O(N) with N being the number of scripts to check (so checking a single script is an O(1) operation).</source>
          <target state="translated">&lt;strong&gt;시간 복잡도 :&lt;/strong&gt; O (N), N은 확인할 스크립트 수입니다 (따라서 단일 스크립트를 확인하는 것은 O (1) 작업 임).</target>
        </trans-unit>
        <trans-unit id="1c61928ca7fc032cf39eb98cafcca19529e956ff" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Time complexity:&lt;/strong&gt; O(N)+O(M log(M)) with N being the sum of the sizes of the input sorted sets, and M being the number of elements in the resulting sorted set.</source>
          <target state="translated">&lt;strong&gt;시간 복잡도 :&lt;/strong&gt; O (N) + O (M log (M)) : N은 입력 정렬 집합의 크기의 합이며 M은 결과 정렬 집합의 요소 수입니다.</target>
        </trans-unit>
        <trans-unit id="cb8a0bd08cfdfeed7510f4650479d4f57d5c0b6c" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Time complexity:&lt;/strong&gt; O(N), with N being the number of evicted entries. Constant times are very small however, since entries are organized in macro nodes containing multiple entries that can be released with a single deallocation.</source>
          <target state="translated">&lt;strong&gt;시간 복잡도 :&lt;/strong&gt; O (N). N은 제거 된 항목 수입니다. 그러나 항목이 단일 할당 해제로 해제 될 수있는 여러 항목을 포함하는 매크로 노드로 구성되므로 상수 시간은 매우 작습니다.</target>
        </trans-unit>
        <trans-unit id="bdc1b429e79e5573e78c3286268eb194772e69ad" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Time complexity:&lt;/strong&gt; O(N*K)+O(M*log(M)) worst case with N being the smallest input sorted set, K being the number of input sorted sets and M being the number of elements in the resulting sorted set.</source>
          <target state="translated">&lt;strong&gt;시간 복잡도 :&lt;/strong&gt; O (N * K) + O (M * log (M)) 최악의 경우 N이 가장 작은 입력 정렬 집합, K가 입력 정렬 집합 수, M이 결과 정렬 집합의 요소 수 .</target>
        </trans-unit>
        <trans-unit id="9c1deeffbcb58501a80a1b33d7e0d5e93a0d8cb4" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Time complexity:&lt;/strong&gt; O(N*M) worst case where N is the cardinality of the smallest set and M is the number of sets.</source>
          <target state="translated">&lt;strong&gt;시간 복잡도 :&lt;/strong&gt; O (N * M) 최악의 경우 N은 가장 작은 집합의 카디널리티이고 M은 집합 수입니다.</target>
        </trans-unit>
        <trans-unit id="95a8b0c4cc096c7df1535211118cb125332a33c1" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Time complexity:&lt;/strong&gt; O(N+M) where N is the number of clients subscribed to the receiving channel and M is the total number of subscribed patterns (by any client).</source>
          <target state="translated">&lt;strong&gt;시간 복잡도 :&lt;/strong&gt; O (N + M) 여기서 N은 수신 채널에 가입 한 클라이언트 수이고 M은 (모든 클라이언트에 의한) 가입 된 패턴의 총 수입니다.</target>
        </trans-unit>
        <trans-unit id="da631a41fc16e91a37f4f1640efce1d728beecf3" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Time complexity:&lt;/strong&gt; O(N+M) where N is the number of patterns the client is already subscribed and M is the number of total patterns subscribed in the system (by any client).</source>
          <target state="translated">&lt;strong&gt;시간 복잡도 :&lt;/strong&gt; O (N + M) 여기서 N은 클라이언트가 이미 가입 한 패턴의 수이고 M은 시스템에서 (모든 클라이언트가) 가입 한 총 패턴의 수입니다.</target>
        </trans-unit>
        <trans-unit id="1545563eee39efef7fdeb146aeb9455c2e173035" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Time complexity:&lt;/strong&gt; O(N+M*log(M)) where N is the number of elements in the list or set to sort, and M the number of returned elements. When the elements are not sorted, complexity is currently O(N) as there is a copy step that will be avoided in next releases.</source>
          <target state="translated">&lt;strong&gt;시간 복잡도 :&lt;/strong&gt; O (N + M * log (M)) 여기서 N은 목록에 있거나 정렬하도록 설정된 요소 수이며 M은 반환 된 요소 수입니다. 요소가 정렬되지 않은 경우 다음 릴리스에서는 피할 복사 단계가 있으므로 복잡성이 현재 O (N)입니다.</target>
        </trans-unit>
        <trans-unit id="e20974426ea75cce3c73bf120e5bd4311bbf1748" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Time complexity:&lt;/strong&gt; O(N+log(M)) where N is the number of elements inside the bounding box of the circular area delimited by center and radius and M is the number of items inside the index.</source>
          <target state="translated">&lt;strong&gt;시간 복잡도 :&lt;/strong&gt; O (N + log (M)) 여기서 N은 중심과 반지름으로 구분 된 원형 영역의 경계 상자 내부에있는 요소 수이고 M은 인덱스 내부의 항목 수입니다.</target>
        </trans-unit>
        <trans-unit id="0b1043d56167b21d4e14680e3c1b432e7de9950b" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Time complexity:&lt;/strong&gt; O(S+N) where S is the distance of start offset from HEAD for small lists, from nearest end (HEAD or TAIL) for large lists; and N is the number of elements in the specified range.</source>
          <target state="translated">&lt;strong&gt;시간 복잡도 :&lt;/strong&gt; O (S + N) 여기서 S는 작은 목록의 경우 HEAD에서 시작 오프셋의 거리, 큰 목록의 경우 가장 가까운 끝 (HEAD 또는 TAIL)에서 시작 거리입니다. N은 지정된 범위의 요소 수입니다.</target>
        </trans-unit>
        <trans-unit id="61d4a476ee392abe69dfb6f735b32eff60ec2a6b" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Time complexity:&lt;/strong&gt; O(log N) where N is the number of client connections</source>
          <target state="translated">&lt;strong&gt;시간 복잡도 :&lt;/strong&gt; O (log N) 여기서 N은 클라이언트 연결 수입니다.</target>
        </trans-unit>
        <trans-unit id="0ba9000410dc73a0148976d8f1ca327c62a7ecf4" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Time complexity:&lt;/strong&gt; O(log N) with N being the number of messages in the PEL of the consumer group.</source>
          <target state="translated">&lt;strong&gt;시간 복잡도 :&lt;/strong&gt; O (log N), N은 소비자 그룹의 PEL에있는 메시지 수입니다.</target>
        </trans-unit>
        <trans-unit id="cf252527ef63c0a8016e53161f0802202a141a2d" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Time complexity:&lt;/strong&gt; O(log(N))</source>
          <target state="translated">&lt;strong&gt;시간 복잡도 :&lt;/strong&gt; O (log (N))</target>
        </trans-unit>
        <trans-unit id="3617beac7c8f278492f8ebb0822d7866ef5b53bc" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Time complexity:&lt;/strong&gt; O(log(N)) for each item added, where N is the number of elements in the sorted set.</source>
          <target state="translated">&lt;strong&gt;시간 복잡도 :&lt;/strong&gt; 추가 된 각 항목에 대한 O (log (N)). 여기서 N은 정렬 된 집합의 요소 수입니다.</target>
        </trans-unit>
        <trans-unit id="1e9100580063c1e1be14b5cd61da6a708da5cacb" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Time complexity:&lt;/strong&gt; O(log(N)) for each member requested, where N is the number of elements in the sorted set.</source>
          <target state="translated">&lt;strong&gt;시간 복잡도 :&lt;/strong&gt; 요청 된 각 멤버에 대한 O (log (N)). 여기서 N은 정렬 된 세트의 요소 수입니다.</target>
        </trans-unit>
        <trans-unit id="c3d989bc3d0022508b657a626add9ede9b35fe13" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Time complexity:&lt;/strong&gt; O(log(N)) where N is the number of elements in the sorted set.</source>
          <target state="translated">&lt;strong&gt;시간 복잡도 :&lt;/strong&gt; O (log (N)) 여기서 N은 정렬 된 집합의 요소 수입니다.</target>
        </trans-unit>
        <trans-unit id="a01464fde23d7922cd3181b2d140cdc060c292b8" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Time complexity:&lt;/strong&gt; O(log(N)) where N is the number of requested keys</source>
          <target state="translated">&lt;strong&gt;시간 복잡도 :&lt;/strong&gt; O (log (N)) 여기서 N은 요청 된 키 수입니다.</target>
        </trans-unit>
        <trans-unit id="0b83bd68ddbd557fa31d160256ac1ba5c07dca9b" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Time complexity:&lt;/strong&gt; O(log(N)) with N being the number of elements in the sorted set.</source>
          <target state="translated">&lt;strong&gt;시간 복잡도 :&lt;/strong&gt; O (log (N)) : N은 정렬 된 집합의 요소 수입니다.</target>
        </trans-unit>
        <trans-unit id="b0ee3fe339d708213eb2152cfd0edecd6a23722f" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Time complexity:&lt;/strong&gt; O(log(N)*M) with N being the number of elements in the sorted set, and M being the number of elements popped.</source>
          <target state="translated">&lt;strong&gt;시간 복잡도 :&lt;/strong&gt; O (log (N) * M) : N은 정렬 된 집합의 요소 수이고 M은 팝된 요소 수입니다.</target>
        </trans-unit>
        <trans-unit id="c8bc61ab47c6f2e5c838fde185e75f06eaede6dd" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Time complexity:&lt;/strong&gt; O(log(N)+M) with N being the number of elements in the sorted set and M the number of elements being returned. If M is constant (e.g. always asking for the first 10 elements with LIMIT), you can consider it O(log(N)).</source>
          <target state="translated">&lt;strong&gt;시간 복잡도 :&lt;/strong&gt; O (log (N) + M) : N은 정렬 된 집합의 요소 수이고 M은 반환되는 요소 수입니다. M이 일정하면 (예 : 항상 LIMIT를 사용하여 처음 10 개 요소를 요구하는 경우) O (log (N))로 간주 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3b6424d2e3291317641637c912123d28b25281c4" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Time complexity:&lt;/strong&gt; O(log(N)+M) with N being the number of elements in the sorted set and M the number of elements removed by the operation.</source>
          <target state="translated">&lt;strong&gt;시간 복잡도 :&lt;/strong&gt; O (log (N) + M) : N은 정렬 된 집합의 요소 수이고 M은 연산에 의해 제거 된 요소 수입니다.</target>
        </trans-unit>
        <trans-unit id="09fbbe6797234161ea410530c85be0b791fc864e" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Time complexity:&lt;/strong&gt; O(log(N)+M) with N being the number of elements in the sorted set and M the number of elements returned.</source>
          <target state="translated">&lt;strong&gt;시간 복잡도 :&lt;/strong&gt; O (log (N) + M) : N은 정렬 된 집합의 요소 수이고 M은 반환 된 요소 수입니다.</target>
        </trans-unit>
        <trans-unit id="6959b6340adf97e5fa73bcc0f671fd9f65774e91" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Time complexity:&lt;/strong&gt; This command actually executes a DUMP+DEL in the source instance, and a RESTORE in the target instance. See the pages of these commands for time complexity. Also an O(N) data transfer between the two instances is performed.</source>
          <target state="translated">&lt;strong&gt;시간 복잡성 :&lt;/strong&gt; 이 명령은 실제로 소스 인스턴스에서 DUMP + DEL을 실행하고 대상 인스턴스에서 RESTORE를 실행합니다. 시간 복잡성에 대해서는이 명령의 페이지를 참조하십시오. 또한 두 인스턴스 간의 O (N) 데이터 전송이 수행됩니다.</target>
        </trans-unit>
        <trans-unit id="7dcb22d963fb6fc6a195b9cae66b88a740647add" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Time complexity:&lt;/strong&gt; Without the count argument O(1), otherwise O(N) where N is the absolute value of the passed count.</source>
          <target state="translated">&lt;strong&gt;시간 복잡도 :&lt;/strong&gt; 카운트 인수 O (1)이 없으면 O (N). 여기서 N은 전달 된 카운트의 절대 값입니다.</target>
        </trans-unit>
        <trans-unit id="147dce46528f2f7b067e233aa55436c61d0c2c06" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;WRAP&lt;/strong&gt;: wrap around, both with signed and unsigned integers. In the case of unsigned integers, wrapping is like performing the operation modulo the maximum value the integer can contain (the C standard behavior). With signed integers instead wrapping means that overflows restart towards the most negative value and underflows towards the most positive ones, so for example if an &lt;code&gt;i8&lt;/code&gt; integer is set to the value 127, incrementing it by 1 will yield &lt;code&gt;-128&lt;/code&gt;.</source>
          <target state="translated">&lt;strong&gt;랩&lt;/strong&gt; : 부호있는 정수와 부호없는 정수로 랩 어라운드합니다. 부호없는 정수의 경우 래핑은 연산 모듈로를 수행하는 것과 같이 정수에 포함될 수있는 최대 값 (C 표준 동작)과 같습니다. 부호있는 정수 대신 래핑은 오버플로가 가장 음의 값으로 다시 시작하고 가장 양의 값으로 언더 플로우되는 것을 의미합니다. 예를 들어 &lt;code&gt;i8&lt;/code&gt; 정수가 값 127로 설정되면 1 씩 증가하면 &lt;code&gt;-128&lt;/code&gt; 이 됩니다.</target>
        </trans-unit>
        <trans-unit id="b2f3c6e6f77042ca5e13377abb0968d262d33999" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Warning:&lt;/strong&gt; Newer versions of Redis Cluster will output, for each Redis instance, not just the IP and port, but also the node ID as third element of the array. In future versions there could be more elements describing the node better. In general a client implementation should just rely on the fact that certain parameters are at fixed positions as specified, but more parameters may follow and should be ignored. Similarly a client library should try if possible to cope with the fact that older versions may just have the IP and port parameter.</source>
          <target state="translated">&lt;strong&gt;경고 :&lt;/strong&gt; 각 Redis 인스턴스마다 최신 버전의 Redis Cluster가 IP 및 포트뿐만 아니라 어레이의 세 번째 요소 인 노드 ID도 출력합니다. 이후 버전에서는 노드를 더 잘 설명하는 더 많은 요소가있을 수 있습니다. 일반적으로 클라이언트 구현은 특정 매개 변수가 지정된대로 고정 된 위치에 있다는 사실에 의존해야하지만 더 많은 매개 변수가 따를 수 있으므로 무시해야합니다. 마찬가지로 클라이언트 라이브러리는 가능한 경우 이전 버전에 IP 및 포트 매개 변수 만있을 수 있다는 사실에 대처하기 위해 시도해야합니다.</target>
        </trans-unit>
        <trans-unit id="60988b111418a5e08cd285cd814fba43de4b4ca0" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Warning&lt;/strong&gt;: When setting the last possible bit (&lt;em&gt;offset&lt;/em&gt; equal to 2&lt;sup&gt;32&lt;/sup&gt; -1) and the string value stored at &lt;em&gt;key&lt;/em&gt; does not yet hold a string value, or holds a small string value, Redis needs to allocate all intermediate memory which can block the server for some time. On a 2010 MacBook Pro, setting bit number 2&lt;sup&gt;32&lt;/sup&gt; -1 (512MB allocation) takes ~300ms, setting bit number 2&lt;sup&gt;30&lt;/sup&gt; -1 (128MB allocation) takes ~80ms, setting bit number 2&lt;sup&gt;28&lt;/sup&gt; -1 (32MB allocation) takes ~30ms and setting bit number 2&lt;sup&gt;26&lt;/sup&gt; -1 (8MB allocation) takes ~8ms. Note that once this first allocation is done, subsequent calls to &lt;a href=&quot;setbit&quot;&gt;SETBIT&lt;/a&gt; for the same &lt;em&gt;key&lt;/em&gt; will not have the allocation overhead.</source>
          <target state="translated">&lt;strong&gt;경고&lt;/strong&gt; : 마지막 가능한 비트를 설정하고 ( &lt;em&gt;오프셋&lt;/em&gt; 2 &lt;sup&gt;32&lt;/sup&gt; -1) &lt;em&gt;키에&lt;/em&gt; 저장된 문자열 값이 문자열 값을 아직 보유하지 않거나 작은 문자열 값을 보유하는 경우 Redis는 모든 중간 메모리를 할당해야합니다. 한동안 서버. 에 2010 맥북 프로, 설정 비트 수를 2 &lt;sup&gt;32&lt;/sup&gt; -1 (512 메가 바이트 할당) ~ 300ms로는, 설정 비트 수를 2 소요 &lt;sup&gt;30&lt;/sup&gt; 평균 80ms가, 설정 비트 수를 2 ~ -1 (128 메가 바이트 할당)이 소요 &lt;sup&gt;(28)&lt;/sup&gt; -1 (32MB의 할당) 소요 ~ 30ms의를 및 설정 비트 수를 2 &lt;sup&gt;(26)&lt;/sup&gt; -1 (8메가바이트 할당) ~ 8ms의 걸린다. 이 첫 번째 할당이 완료되면 동일한 &lt;em&gt;키에&lt;/em&gt; 대한 후속 &lt;a href=&quot;setbit&quot;&gt;SETBIT&lt;/a&gt; 호출&lt;em&gt;&lt;/em&gt; 할당 오버 헤드가 없습니다.</target>
        </trans-unit>
        <trans-unit id="1cc9feb2e460988167276c1d1f2c4a7519bea033" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Warning&lt;/strong&gt;: When setting the last possible byte and the string value stored at &lt;em&gt;key&lt;/em&gt; does not yet hold a string value, or holds a small string value, Redis needs to allocate all intermediate memory which can block the server for some time. On a 2010 MacBook Pro, setting byte number 536870911 (512MB allocation) takes ~300ms, setting byte number 134217728 (128MB allocation) takes ~80ms, setting bit number 33554432 (32MB allocation) takes ~30ms and setting bit number 8388608 (8MB allocation) takes ~8ms. Note that once this first allocation is done, subsequent calls to &lt;a href=&quot;setrange&quot;&gt;SETRANGE&lt;/a&gt; for the same &lt;em&gt;key&lt;/em&gt; will not have the allocation overhead.</source>
          <target state="translated">&lt;strong&gt;경고&lt;/strong&gt; : 마지막 가능한 바이트를 설정하고 &lt;em&gt;키에&lt;/em&gt; 저장된 문자열 값이 문자열 값을 아직 보유하지 않거나 작은 문자열 값을 보유하는 경우 Redis는 한동안 서버를 차단할 수있는 모든 중간 메모리를 할당해야합니다. 2010 MacBook Pro에서 바이트 번호 설정 536870911 (512MB 할당)은 ~ 300ms, 바이트 번호 설정 134217728 (128MB 할당)은 ~ 80ms, 설정 비트 번호 33554432 (32MB 할당)는 ~ 30ms, 설정 비트 번호 8388608 (8MB 할당) ~ 8ms 걸립니다. 이 첫 번째 할당이 완료되면 동일한 &lt;em&gt;키에&lt;/em&gt; 대한 &lt;a href=&quot;setrange&quot;&gt;SETRANGE에&lt;/a&gt; 대한 후속 호출 에는 할당 오버 헤드가 없습니다.&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="cc795566bfbbbe6af9c65583f2a47cdaddd23f92" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Warning&lt;/strong&gt;: consider &lt;a href=&quot;keys&quot;&gt;KEYS&lt;/a&gt; as a command that should only be used in production environments with extreme care. It may ruin performance when it is executed against large databases. This command is intended for debugging and special operations, such as changing your keyspace layout. Don't use &lt;a href=&quot;keys&quot;&gt;KEYS&lt;/a&gt; in your regular application code. If you're looking for a way to find keys in a subset of your keyspace, consider using &lt;a href=&quot;scan&quot;&gt;SCAN&lt;/a&gt; or &lt;a href=&quot;https://redis.io/topics/data-types#sets&quot;&gt;sets&lt;/a&gt;.</source>
          <target state="translated">&lt;strong&gt;경고&lt;/strong&gt; : &lt;a href=&quot;keys&quot;&gt;KEYS&lt;/a&gt; 는 매우 신중하게 프로덕션 환경에서만 사용해야하는 명령으로 간주하십시오 . 큰 데이터베이스에 대해 실행될 때 성능이 저하 될 수 있습니다. 이 명령은 키 스페이스 레이아웃 변경과 같은 디버깅 및 특수 작업을위한 것입니다. 일반 응용 프로그램 코드에서 &lt;a href=&quot;keys&quot;&gt;키&lt;/a&gt; 를 사용하지 마십시오 . 키 공간의 하위 세트에서 키를 찾는 방법을 찾고 있다면 &lt;a href=&quot;scan&quot;&gt;SCAN&lt;/a&gt; 또는 &lt;a href=&quot;https://redis.io/topics/data-types#sets&quot;&gt;sets&lt;/a&gt; 사용을 고려하십시오 .</target>
        </trans-unit>
        <trans-unit id="e8bd7e5fae76f9719ccdb7cd784632dfb7da420a" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Warning&lt;/strong&gt;: this command was renamed to &lt;a href=&quot;getrange&quot;&gt;GETRANGE&lt;/a&gt;, it is called &lt;code&gt;SUBSTR&lt;/code&gt; in Redis versions &lt;code&gt;&amp;lt;= 2.0&lt;/code&gt;.</source>
          <target state="translated">&lt;strong&gt;경고&lt;/strong&gt; :이 명령은 &lt;a href=&quot;getrange&quot;&gt;GETRANGE&lt;/a&gt; 로 이름이 바뀌 었으며 Redis 버전 &lt;code&gt;&amp;lt;= 2.0&lt;/code&gt; 에서는 &lt;code&gt;SUBSTR&lt;/code&gt; 이라고 합니다.</target>
        </trans-unit>
        <trans-unit id="56894dc250c01689ce8089e2e0329a40fd8dd202" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;XX&lt;/strong&gt;: Only update elements that already exist. Never add elements.</source>
          <target state="translated">&lt;strong&gt;XX&lt;/strong&gt; : 이미 존재하는 요소 만 업데이트합니다. 요소를 추가하지 마십시오.</target>
        </trans-unit>
        <trans-unit id="8bff7d4c72f517ddfeda551b647e8e7d1217bc74" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;ft&lt;/strong&gt; for feet.</source>
          <target state="translated">&lt;strong&gt;피트&lt;/strong&gt; 피트.</target>
        </trans-unit>
        <trans-unit id="8f7d99307167d9151fd26962853701edfbb5519b" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;km&lt;/strong&gt; for kilometers.</source>
          <target state="translated">&lt;strong&gt;km&lt;/strong&gt; 킬로미터.</target>
        </trans-unit>
        <trans-unit id="39044bc6a455c022d39a0d72ae45f195d8b8c1b6" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;m&lt;/strong&gt; for meters.</source>
          <target state="translated">&lt;strong&gt;미터의&lt;/strong&gt; 경우 m입니다.</target>
        </trans-unit>
        <trans-unit id="38968a64d0a0bdede6ba3cbc6aaa2f8a596ba38b" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;mi&lt;/strong&gt; for miles.</source>
          <target state="translated">&lt;strong&gt;마일&lt;/strong&gt; 마일.</target>
        </trans-unit>
        <trans-unit id="fe6b32ebf673080ac2625dc05bc8a2f62d943f4e" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;nil&lt;/code&gt; multi-bulk when no element could be popped and the timeout expired.</source>
          <target state="translated">&lt;code&gt;nil&lt;/code&gt; 멀티 대부분은 어떤 요소가 튀어없고 시간 제한이 만료 될 수있을 때.</target>
        </trans-unit>
        <trans-unit id="f954a25307e91dd61c331fb6ced8f1d1b49d2dc9" translate="yes" xml:space="preserve">
          <source>A client can acquire the lock if the above command returns &lt;code&gt;OK&lt;/code&gt; (or retry after some time if the command returns Nil), and remove the lock just using &lt;a href=&quot;del&quot;&gt;DEL&lt;/a&gt;.</source>
          <target state="translated">클라이언트는 위의 명령이 &lt;code&gt;OK&lt;/code&gt; 를 리턴하면 잠금을 획득하고 (또는 명령이 Nil을 리턴하면 잠시 후 다시 시도) &lt;a href=&quot;del&quot;&gt;DEL을&lt;/a&gt; 사용하여 잠금을 제거 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1557c0a8f4b2cceda8fceff02fc1420f6f4eff1c" translate="yes" xml:space="preserve">
          <source>A client may use GETSET in order to atomically get the current counter value and reset it to zero.</source>
          <target state="translated">클라이언트는 현재 카운터 값을 원자 적으로 가져 와서 0으로 재설정하기 위해 GETSET을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="68a796147e39e14a8a80bf764ddfd90ce6919a38" translate="yes" xml:space="preserve">
          <source>A common pattern is to call &lt;a href=&quot;script-load&quot;&gt;SCRIPT LOAD&lt;/a&gt; to load all the scripts that will appear in a pipeline, then use &lt;a href=&quot;evalsha&quot;&gt;EVALSHA&lt;/a&gt; directly inside the pipeline without any need to check for errors resulting from the script hash not being recognized.</source>
          <target state="translated">일반적인 패턴은 &lt;a href=&quot;script-load&quot;&gt;SCRIPT LOAD&lt;/a&gt; 를 호출 하여 파이프 라인에 나타날 모든 스크립트를로드 한 다음 스크립트 해시가 인식되지 않아 발생하는 오류를 확인할 필요없이 파이프 라인 내에서 직접 &lt;a href=&quot;evalsha&quot;&gt;EVALSHA&lt;/a&gt; 를 사용하는 것 입니다.</target>
        </trans-unit>
        <trans-unit id="476c40353d34c43082faec86bb0fe02b5da4c638" translate="yes" xml:space="preserve">
          <source>A common use of &lt;a href=&quot;ltrim&quot;&gt;LTRIM&lt;/a&gt; is together with &lt;a href=&quot;lpush&quot;&gt;LPUSH&lt;/a&gt; / &lt;a href=&quot;rpush&quot;&gt;RPUSH&lt;/a&gt;. For example:</source>
          <target state="translated">&lt;a href=&quot;ltrim&quot;&gt;LTRIM&lt;/a&gt; 의 일반적인 사용은 &lt;a href=&quot;lpush&quot;&gt;LPUSH&lt;/a&gt; / &lt;a href=&quot;rpush&quot;&gt;RPUSH&lt;/a&gt; 와 함께 사용 됩니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="2ffc2830e7247029a8f3dd963d6dc9ccb6bc1e19" translate="yes" xml:space="preserve">
          <source>A consumer can be destroyed completely by using the following form:</source>
          <target state="translated">다음 형식을 사용하여 소비자를 완전히 파기 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="39aaf38b13fe32608e93e62cb065f0bce6d7d689" translate="yes" xml:space="preserve">
          <source>A does no longer known node D (see step 3), so it starts an handshake with D.</source>
          <target state="translated">A는 더 이상 노드 D를 알지 못하므로 (3 단계 참조) D와의 핸드 셰이크를 시작합니다.</target>
        </trans-unit>
        <trans-unit id="1ff437bc625fc822edf5fa54a7c14c51cb9019e8" translate="yes" xml:space="preserve">
          <source>A few more details:</source>
          <target state="translated">몇 가지 세부 사항 :</target>
        </trans-unit>
        <trans-unit id="e03e2d0aaad7167505a0638399e7a4066ed67ed8" translate="yes" xml:space="preserve">
          <source>A few remarks:</source>
          <target state="translated">몇 가지 말 :</target>
        </trans-unit>
        <trans-unit id="d21e3dd0e34aa1b90513d361d662f4d66565fe3b" translate="yes" xml:space="preserve">
          <source>A full iteration always retrieves all the elements that were present in the collection from the start to the end of a full iteration. This means that if a given element is inside the collection when an iteration is started, and is still there when an iteration terminates, then at some point &lt;a href=&quot;scan&quot;&gt;SCAN&lt;/a&gt; returned it to the user.</source>
          <target state="translated">전체 반복은 항상 전체 반복의 시작부터 끝까지 콜렉션에 존재하는 모든 요소를 ​​검색합니다. 이는 반복이 시작될 때 주어진 요소가 콜렉션 내에 있고 반복이 종료 될 때 여전히 존재하는 경우, 어느 시점에서 &lt;a href=&quot;scan&quot;&gt;SCAN&lt;/a&gt; 이 사용자에게이를 리턴 했음을 의미합니다 .</target>
        </trans-unit>
        <trans-unit id="5ea8259e546c110ba56b58d1a577aee64262f6ae" translate="yes" xml:space="preserve">
          <source>A full iteration never returns any element that was NOT present in the collection from the start to the end of a full iteration. So if an element was removed before the start of an iteration, and is never added back to the collection for all the time an iteration lasts, &lt;a href=&quot;scan&quot;&gt;SCAN&lt;/a&gt; ensures that this element will never be returned.</source>
          <target state="translated">전체 반복은 전체 반복의 시작부터 끝까지 컬렉션에없는 요소를 반환하지 않습니다. 따라서 반복이 시작되기 전에 요소가 제거되고 반복이 지속될 때까지 컬렉션에 다시 추가되지 않는 경우 &lt;a href=&quot;scan&quot;&gt;SCAN&lt;/a&gt; 은이 요소가 반환되지 않도록합니다.</target>
        </trans-unit>
        <trans-unit id="c74bd09914eb3c14414c0bb5129eab13261f0d53" translate="yes" xml:space="preserve">
          <source>A given element may be returned multiple times. It is up to the application to handle the case of duplicated elements, for example only using the returned elements in order to perform operations that are safe when re-applied multiple times.</source>
          <target state="translated">주어진 요소는 여러 번 반환 될 수 있습니다. 여러 번 다시 적용 할 때 안전한 작업을 수행하기 위해 반환 된 요소 만 사용하는 등 복제 된 요소의 경우를 처리하는 것은 응용 프로그램의 책임입니다.</target>
        </trans-unit>
        <trans-unit id="32f5993390055907ef7db78baaadce5c67d04be3" translate="yes" xml:space="preserve">
          <source>A key is passively expired simply when some client tries to access it, and the key is found to be timed out.</source>
          <target state="translated">키는 일부 클라이언트가 액세스하려고 할 때 수동적으로 만료되며 키가 시간 초과 된 것으로 확인되었습니다.</target>
        </trans-unit>
        <trans-unit id="3e57f13b09da6c6eb207460804c98b55825c2f9d" translate="yes" xml:space="preserve">
          <source>A manual failover is a special kind of failover that is usually executed when there are no actual failures, but we wish to swap the current master with one of its replicas (which is the node we send the command to), in a safe way, without any window for data loss. It works in the following way:</source>
          <target state="translated">수동 장애 조치는 일반적으로 실제 장애가 없을 때 실행되는 특수한 종류의 장애 조치이지만 현재 마스터를 복제본 (명령을 보내는 노드) 중 하나와 안전하게 교환하려고합니다. 데이터 손실에 대한 창이 없습니다. 다음과 같은 방식으로 작동합니다.</target>
        </trans-unit>
        <trans-unit id="5eb7eb4b7c9af1e8cd4b04308f1be845c7ce2454" translate="yes" xml:space="preserve">
          <source>A multi bulk reply containing two elements:</source>
          <target state="translated">두 가지 요소를 포함하는 다중 대량 응답 :</target>
        </trans-unit>
        <trans-unit id="95185c923ff66d3971c363a0323cd29e0c25489f" translate="yes" xml:space="preserve">
          <source>A node flags another node with &lt;code&gt;PFAIL&lt;/code&gt; when the node is not reachable for a time greater than the configured &lt;em&gt;node timeout&lt;/em&gt;, which is a fundamental configuration parameter of a Redis Cluster.</source>
          <target state="translated">Redis 클러스터의 기본 구성 매개 변수 인 구성된 &lt;em&gt;노드 시간 초과&lt;/em&gt; 보다 큰 시간 동안 노드에 도달 할 수없는 경우 노드는 다른 노드에 &lt;code&gt;PFAIL&lt;/code&gt; 을 표시합니다 .&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="8c45c3a601d1105d05600d28edf7cbc3726d0fee" translate="yes" xml:space="preserve">
          <source>A replica will always accept the command, assuming that:</source>
          <target state="translated">다음을 가정하면 복제본은 항상 명령을 수락합니다.</target>
        </trans-unit>
        <trans-unit id="fa3bae76123b4add6aeab64ce12d553400e1ce76" translate="yes" xml:space="preserve">
          <source>A replica with AOF enabled, reconnected with its master, performed a full resynchronization, and restarted the AOF file, triggering the initial AOF creation process. In this case not completing the AOF rewrite is dangerous because the latest dataset received from the master would be lost. The new master can actually be even a different instance (if the &lt;strong&gt;REPLICAOF&lt;/strong&gt; or &lt;strong&gt;SLAVEOF&lt;/strong&gt; command was used in order to reconfigure the replica), so it is important to finish the AOF rewrite and start with the correct data set representing the data set in memory when the server was terminated.</source>
          <target state="translated">AOF를 활성화하고 마스터와 다시 연결 한 복제본은 전체 재 동기화를 수행하고 AOF 파일을 다시 시작하여 초기 AOF 작성 프로세스를 트리거합니다. 이 경우 AOF 다시 쓰기를 완료하지 않으면 마스터에서받은 최신 데이터 세트가 손실되므로 위험합니다. 새 마스터는 실제로 다른 인스턴스 일 수도 있습니다 ( 복제본을 재구성하기 위해 &lt;strong&gt;REPLICAOF&lt;/strong&gt; 또는 &lt;strong&gt;SLAVEOF&lt;/strong&gt; 명령이 사용 된 경우). AOF 다시 쓰기를 마치고 메모리의 데이터 세트를 나타내는 올바른 데이터 세트로 시작하는 것이 중요합니다. 서버가 종료되었습니다.</target>
        </trans-unit>
        <trans-unit id="34774babccc209638e8661b505cce11cc8900748" translate="yes" xml:space="preserve">
          <source>A similar pattern where user IDs are used instead of days is described in the article called &quot;&lt;a href=&quot;http://blog.getspool.com/2011/11/29/fast-easy-realtime-metrics-using-redis-bitmaps&quot;&gt;Fast easy realtime metrics using Redis bitmaps&lt;/a&gt;&quot;.</source>
          <target state="translated">사용자 ID가 며칠 대신 사용되는 유사한 패턴은 &quot; &lt;a href=&quot;http://blog.getspool.com/2011/11/29/fast-easy-realtime-metrics-using-redis-bitmaps&quot;&gt;Redis 비트 맵을 사용하는 빠르고 쉬운 실시간 메트릭&lt;/a&gt; &quot;이라는 기사에 설명되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="3892260963af39063ee4c79a4c6f5fc7f079e501" translate="yes" xml:space="preserve">
          <source>A simple example follows:</source>
          <target state="translated">간단한 예는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="7ddef64b774f3cd5fc1e62ed561def95b846b563" translate="yes" xml:space="preserve">
          <source>A stream entry ID identifies a given entry inside a stream. The &lt;a href=&quot;xadd&quot;&gt;XADD&lt;/a&gt; command will auto-generate a unique ID for you if the ID argument specified is the &lt;code&gt;*&lt;/code&gt; character (asterisk ASCII character). However, while useful only in very rare cases, it is possible to specify a well-formed ID, so that the new entry will be added exactly with the specified ID.</source>
          <target state="translated">스트림 항목 ID는 스트림 내에서 지정된 항목을 식별합니다. &lt;a href=&quot;xadd&quot;&gt;XADD에&lt;/a&gt; 지정된 ID 인수가 있다면 명령 의지는 당신을위한 고유 ID를 자동 생성 &lt;code&gt;*&lt;/code&gt; 문자 (별표 ASCII 문자). 그러나 매우 드문 경우에만 유용하지만 올바르게 구성된 ID를 지정하여 새 항목이 지정된 ID로 정확하게 추가 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="79fd7f6eb47e05e442bf21424b70a285e07cd4c7" translate="yes" xml:space="preserve">
          <source>A three-element multi-bulk with the first element being the name of the key where a member was popped, the second element being the score of the popped member, and the third element being the popped member itself.</source>
          <target state="translated">첫 번째 요소가 멤버가 팝된 키의 이름이고, 두 번째 요소가 팝된 멤버의 점수이며, 세 번째 요소가 팝된 멤버 자체 인 3 요소 다중 벌크입니다.</target>
        </trans-unit>
        <trans-unit id="30306183666392fcaecc22c35fce7e7cb3af8d67" translate="yes" xml:space="preserve">
          <source>A timeout of 0 means to block forever.</source>
          <target state="translated">시간 초과가 0이면 영원히 차단됩니다.</target>
        </trans-unit>
        <trans-unit id="a17d8e24b3173ee841bfca950e5b33f8d2311769" translate="yes" xml:space="preserve">
          <source>A two-element multi-bulk with the first element being the name of the key where an element was popped and the second element being the value of the popped element.</source>
          <target state="translated">첫 번째 요소가 요소가 팝된 키의 이름이고 두 번째 요소가 팝된 요소의 값인 2 요소 다중 벌크입니다.</target>
        </trans-unit>
        <trans-unit id="316a7d352276951a851baa176c56bd0646785b6b" translate="yes" xml:space="preserve">
          <source>A unique progressive identifier for every slow log entry.</source>
          <target state="translated">느린 로그 항목마다 고유 한 점진적 식별자입니다.</target>
        </trans-unit>
        <trans-unit id="15e5288f998531a56ed6ca49f3cc22bfec1a3be1" translate="yes" xml:space="preserve">
          <source>A very important part of scripting is writing scripts that are pure functions. Scripts executed in a Redis instance are, by default, propagated to replicas and to the AOF file by sending the script itself -- not the resulting commands.</source>
          <target state="translated">스크립팅의 매우 중요한 부분은 순수한 기능인 스크립트를 작성하는 것입니다. Redis 인스턴스에서 실행되는 스크립트는 기본적으로 결과 명령이 아닌 스크립트 자체를 전송하여 복제본 및 AOF 파일로 전파됩니다.</target>
        </trans-unit>
        <trans-unit id="025e07020e93e25579c1a9621d736dca0c1f26de" translate="yes" xml:space="preserve">
          <source>APPEND</source>
          <target state="translated">APPEND</target>
        </trans-unit>
        <trans-unit id="909ab7e7d0327d1bb12d101958258d2a08b6daae" translate="yes" xml:space="preserve">
          <source>APPEND  key value   Append a value to a key</source>
          <target state="translated">APPEND 키 값 키에 값 추가</target>
        </trans-unit>
        <trans-unit id="4a79bd00448baad864aa37f5d6d5b74bace69207" translate="yes" xml:space="preserve">
          <source>AUTH</source>
          <target state="translated">AUTH</target>
        </trans-unit>
        <trans-unit id="ffc2673c91de7fcb166409594eaaaec1f96c75c1" translate="yes" xml:space="preserve">
          <source>AUTH  password   Authenticate to the server</source>
          <target state="translated">AUTH 비밀번호 서버에 인증</target>
        </trans-unit>
        <trans-unit id="043bd74983959c0554262d35de5c14a4ec21d462" translate="yes" xml:space="preserve">
          <source>Accessing a &lt;em&gt;non existing&lt;/em&gt; global variable generates a similar error.</source>
          <target state="translated">&lt;em&gt;존재하지 않는&lt;/em&gt; 전역 변수에 액세스하면 비슷한 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="7aba5231117223c71bfb7ad628b907a035c73c59" translate="yes" xml:space="preserve">
          <source>Accessing individual elements in the time series is not hard:</source>
          <target state="translated">시계열의 개별 요소에 액세스하는 것은 어렵지 않습니다.</target>
        </trans-unit>
        <trans-unit id="8496994d3923ed6948840c095615350a859b9bf8" translate="yes" xml:space="preserve">
          <source>Accumulate all the commands to send into the pipeline, then check for &lt;a href=&quot;eval&quot;&gt;EVAL&lt;/a&gt; commands and use the &lt;a href=&quot;script-exists&quot;&gt;SCRIPT EXISTS&lt;/a&gt; command to check if all the scripts are already defined. If not, add &lt;a href=&quot;script-load&quot;&gt;SCRIPT LOAD&lt;/a&gt; commands on top of the pipeline as required, and use &lt;a href=&quot;evalsha&quot;&gt;EVALSHA&lt;/a&gt; for all the &lt;a href=&quot;eval&quot;&gt;EVAL&lt;/a&gt; calls.</source>
          <target state="translated">파이프 라인으로 보낼 모든 명령을 누적 한 다음 &lt;a href=&quot;eval&quot;&gt;EVAL&lt;/a&gt; 명령 을 확인 하고 &lt;a href=&quot;script-exists&quot;&gt;SCRIPT EXISTS&lt;/a&gt; 명령을 사용하여 모든 스크립트가 이미 정의되어 있는지 확인하십시오. 그렇지 않은 경우 필요에 따라 파이프 라인 위에 &lt;a href=&quot;script-load&quot;&gt;SCRIPT LOAD&lt;/a&gt; 명령을 추가 하고 모든 &lt;a href=&quot;eval&quot;&gt;EVAL&lt;/a&gt; 호출에 &lt;a href=&quot;evalsha&quot;&gt;EVALSHA&lt;/a&gt; 를 사용 하십시오 .</target>
        </trans-unit>
        <trans-unit id="331fbf87d679488dd37eba43acb4cb291a720fed" translate="yes" xml:space="preserve">
          <source>Add the specified members to the set stored at &lt;code&gt;key&lt;/code&gt;. Specified members that are already a member of this set are ignored. If &lt;code&gt;key&lt;/code&gt; does not exist, a new set is created before adding the specified members.</source>
          <target state="translated">&lt;code&gt;key&lt;/code&gt; 에 저장된 세트에 지정된 멤버를 추가하십시오 . 이미이 세트의 멤버 인 지정된 멤버는 무시됩니다. 경우 &lt;code&gt;key&lt;/code&gt; 존재하지 않는, 새로운 세트가 지정된 멤버를 추가하기 전에 생성됩니다.</target>
        </trans-unit>
        <trans-unit id="6ea5ef09a89f93581e248dcc20539555e85c3a48" translate="yes" xml:space="preserve">
          <source>Additional examples</source>
          <target state="translated">추가 예</target>
        </trans-unit>
        <trans-unit id="d82c2de775c1d427f5a69cd870df943898595234" translate="yes" xml:space="preserve">
          <source>Additional information about streams</source>
          <target state="translated">스트림에 대한 추가 정보</target>
        </trans-unit>
        <trans-unit id="63f2e4028cc4ac44d53adec5078f20b4aa655ee5" translate="yes" xml:space="preserve">
          <source>Additional introspective information about the server's memory can be obtained by referring to the &lt;a href=&quot;memory-stats&quot;&gt;MEMORY STATS&lt;/a&gt; command and the &lt;a href=&quot;memory-doctor&quot;&gt;MEMORY DOCTOR&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;memory-stats&quot;&gt;MEMORY STATS&lt;/a&gt; 명령 및 &lt;a href=&quot;memory-doctor&quot;&gt;MEMORY DOCTOR&lt;/a&gt; 를 참조하여 서버 메모리에 대한 추가 내성적 인 정보를 얻을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="5c068579fdb28b0028f94bb0b4e4013c53766748" translate="yes" xml:space="preserve">
          <source>Addressing with &lt;a href=&quot;get&quot;&gt;GET&lt;/a&gt; bits outside the current string length (including the case the key does not exist at all), results in the operation to be performed like the missing part all consists of bits set to 0.</source>
          <target state="translated">현재 문자열 길이를 벗어난 &lt;a href=&quot;get&quot;&gt;GET&lt;/a&gt; 비트로 주소를 지정 하면 (키가 전혀 존재하지 않는 경우 포함) 누락 된 부분이 모두 0으로 설정된 비트로 구성된 것처럼 작업이 수행됩니다.</target>
        </trans-unit>
        <trans-unit id="049c8196ab72e0b22baf65855e45482a2e4f33a5" translate="yes" xml:space="preserve">
          <source>Addressing with &lt;a href=&quot;set&quot;&gt;SET&lt;/a&gt; or &lt;a href=&quot;incrby&quot;&gt;INCRBY&lt;/a&gt; bits outside the current string length will enlarge the string, zero-padding it, as needed, for the minimal length needed, according to the most far bit touched.</source>
          <target state="translated">현재 문자열 길이를 벗어난 &lt;a href=&quot;set&quot;&gt;SET&lt;/a&gt; 또는 &lt;a href=&quot;incrby&quot;&gt;INCRBY&lt;/a&gt; 비트로 주소를 지정 하면 가장 많이 터치 한 비트에 따라 필요한 최소 길이 동안 문자열이 0으로 채워지고 필요에 따라 채워집니다.</target>
        </trans-unit>
        <trans-unit id="46ebddce5151e5408360a67a147fb399e9415717" translate="yes" xml:space="preserve">
          <source>Adds all the element arguments to the HyperLogLog data structure stored at the variable name specified as first argument.</source>
          <target state="translated">첫 번째 인수로 지정된 변수 이름에 저장된 HyperLogLog 데이터 구조에 모든 요소 인수를 추가합니다.</target>
        </trans-unit>
        <trans-unit id="0d4e52a890415189fc8fbc4fe75cf4354f3f9990" translate="yes" xml:space="preserve">
          <source>Adds all the specified members with the specified scores to the sorted set stored at &lt;code&gt;key&lt;/code&gt;. It is possible to specify multiple score / member pairs. If a specified member is already a member of the sorted set, the score is updated and the element reinserted at the right position to ensure the correct ordering.</source>
          <target state="translated">지정된 점수를 가진 지정된 모든 멤버를 &lt;code&gt;key&lt;/code&gt; 에 저장된 정렬 된 세트에 추가합니다 . 여러 점수 / 멤버 쌍을 지정할 수 있습니다. 지정된 멤버가 이미 정렬 된 세트의 멤버 인 경우, 올바른 순서를 보장하기 위해 점수가 업데이트되고 요소가 올바른 위치에 다시 삽입됩니다.</target>
        </trans-unit>
        <trans-unit id="9ab250d73059710f6ef408c991e35ff53cf7dd2c" translate="yes" xml:space="preserve">
          <source>Adds the specified geospatial items (latitude, longitude, name) to the specified key. Data is stored into the key as a sorted set, in a way that makes it possible to later retrieve items using a query by radius with the &lt;a href=&quot;georadius&quot;&gt;GEORADIUS&lt;/a&gt; or &lt;a href=&quot;georadiusbymember&quot;&gt;GEORADIUSBYMEMBER&lt;/a&gt; commands.</source>
          <target state="translated">지정된 지리 공간 항목 (위도, 경도, 이름)을 지정된 키에 추가합니다. 데이터는 나중에 &lt;a href=&quot;georadius&quot;&gt;GEORADIUS&lt;/a&gt; 또는 &lt;a href=&quot;georadiusbymember&quot;&gt;GEORADIUSBYMEMBER&lt;/a&gt; 명령 으로 반경별로 쿼리를 사용하여 항목을 검색 할 수 있도록 정렬 된 세트로 키에 저장됩니다 .</target>
        </trans-unit>
        <trans-unit id="610e6e414b98337a7416af1551f4bb3d49943eed" translate="yes" xml:space="preserve">
          <source>After an &lt;a href=&quot;exec&quot;&gt;EXEC&lt;/a&gt; of a &lt;a href=&quot;multi&quot;&gt;MULTI&lt;/a&gt; block with multiple push operations against the same list.</source>
          <target state="translated">동일한 목록에 대해 여러 푸시 조작 이있는 &lt;a href=&quot;multi&quot;&gt;MULTI&lt;/a&gt; 블록 의 &lt;a href=&quot;exec&quot;&gt;EXEC&lt;/a&gt; 후 .</target>
        </trans-unit>
        <trans-unit id="10dc2d316de1e1727affb701a924e28e6d1b2437" translate="yes" xml:space="preserve">
          <source>After running the above script, the result is that only keys A and C will be created on replicas and AOF.</source>
          <target state="translated">위의 스크립트를 실행하면 복제본 및 AOF에 키 A와 C 만 작성됩니다.</target>
        </trans-unit>
        <trans-unit id="a9cef2c443353094dddf50e5f724e3879e4f3f90" translate="yes" xml:space="preserve">
          <source>All Redis commands must be analyzed before execution to determine which keys the command will operate on. In order for this to be true for &lt;a href=&quot;eval&quot;&gt;EVAL&lt;/a&gt;, keys must be passed explicitly. This is useful in many ways, but especially to make sure Redis Cluster can forward your request to the appropriate cluster node.</source>
          <target state="translated">명령을 실행할 키를 결정하려면 실행 전에 모든 Redis 명령을 분석해야합니다. &lt;a href=&quot;eval&quot;&gt;EVAL에&lt;/a&gt; 대해 이것이 참이 되려면 키를 명시 적으로 전달해야합니다. 이는 여러 가지면에서 유용하지만 특히 Redis 클러스터가 요청을 적절한 클러스터 노드로 전달할 수 있도록합니다.</target>
        </trans-unit>
        <trans-unit id="05778e5c96e8e267630af37ad51cc812ea0ac83f" translate="yes" xml:space="preserve">
          <source>All the additional arguments should not represent key names and can be accessed by Lua using the &lt;code&gt;ARGV&lt;/code&gt; global variable, very similarly to what happens with keys (so &lt;code&gt;ARGV[1]&lt;/code&gt;, &lt;code&gt;ARGV[2]&lt;/code&gt;, ...).</source>
          <target state="translated">모든 추가 인수는 키 이름을 &lt;code&gt;ARGV&lt;/code&gt; 는 안되며 ARGV 전역 변수를 사용하여 Lua 가 키에서 발생하는 것과 매우 유사하게 액세스 할 수 있습니다 (따라서 &lt;code&gt;ARGV[1]&lt;/code&gt; , &lt;code&gt;ARGV[2]&lt;/code&gt; , ...).</target>
        </trans-unit>
        <trans-unit id="b7c6bcbd8231e947ac1e852709cd03e1c6629d93" translate="yes" xml:space="preserve">
          <source>All the assigned / open slots are reset, so the slots-to-nodes mapping is totally cleared.</source>
          <target state="translated">할당 된 / 열린 슬롯이 모두 재설정되므로 슬롯-노드 매핑이 완전히 지워집니다.</target>
        </trans-unit>
        <trans-unit id="6ccf3242033b3edb2e3d3c30395b126ac379491e" translate="yes" xml:space="preserve">
          <source>All the configuration parameters set using &lt;a href=&quot;config-set&quot;&gt;CONFIG SET&lt;/a&gt; are immediately loaded by Redis and will take effect starting with the next command executed.</source>
          <target state="translated">&lt;a href=&quot;config-set&quot;&gt;CONFIG SET을&lt;/a&gt; 사용하여 설정 한 모든 구성 매개 변수 는 Redis에 의해 즉시로드되며 다음에 실행 된 명령부터 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="b280d4fef57685ade0a8c1183128b72be0fff2a4" translate="yes" xml:space="preserve">
          <source>All the other nodes in the cluster are forgotten.</source>
          <target state="translated">클러스터의 다른 모든 노드는 잊어 버렸습니다.</target>
        </trans-unit>
        <trans-unit id="1ec77394fcab0f40f98a08ccf1bd1a099ab3feef" translate="yes" xml:space="preserve">
          <source>All the specially encoded types are automatically converted to the general type once you perform an operation that makes it impossible for Redis to retain the space saving encoding.</source>
          <target state="translated">Redis가 공간 절약형 인코딩을 유지할 수없는 작업을 수행하면 특수하게 인코딩 된 모든 유형이 자동으로 일반 유형으로 변환됩니다.</target>
        </trans-unit>
        <trans-unit id="df39da0c50311c81c2b61ebabbda96914a971969" translate="yes" xml:space="preserve">
          <source>All the supported parameters have the same meaning of the equivalent configuration parameter used in the &lt;a href=&quot;http://github.com/antirez/redis/raw/2.8/redis.conf&quot;&gt;redis.conf&lt;/a&gt; file, with the following important differences:</source>
          <target state="translated">지원되는 모든 매개 변수는 &lt;a href=&quot;http://github.com/antirez/redis/raw/2.8/redis.conf&quot;&gt;redis.conf&lt;/a&gt; 파일에 사용 된 동등한 구성 매개 변수와 동일한 의미를 가지며 다음과 같은 중요한 차이점이 있습니다.</target>
        </trans-unit>
        <trans-unit id="59c4ef360d3e661521770b94f8bee5b5b98d0b61" translate="yes" xml:space="preserve">
          <source>Almost all modifiers can be used together. The following example will return the first 5 elements, lexicographically sorted in descending order:</source>
          <target state="translated">거의 모든 수정자를 함께 사용할 수 있습니다. 다음 예제는 처음 5 개의 요소를 사전 순으로 내림차순으로 정렬하여 반환합니다.</target>
        </trans-unit>
        <trans-unit id="91f2b1b9e9bccb6b3010f3f9f6fb64637d594f59" translate="yes" xml:space="preserve">
          <source>Also note that this behavior is specific of &lt;a href=&quot;sscan&quot;&gt;SSCAN&lt;/a&gt;, &lt;a href=&quot;hscan&quot;&gt;HSCAN&lt;/a&gt; and &lt;a href=&quot;zscan&quot;&gt;ZSCAN&lt;/a&gt;. &lt;a href=&quot;scan&quot;&gt;SCAN&lt;/a&gt; itself never shows this behavior because the key space is always represented by hash tables.</source>
          <target state="translated">또한이 동작은 &lt;a href=&quot;sscan&quot;&gt;SSCAN&lt;/a&gt; , &lt;a href=&quot;hscan&quot;&gt;HSCAN&lt;/a&gt; 및 &lt;a href=&quot;zscan&quot;&gt;ZSCAN에만 해당&lt;/a&gt; 됩니다. 키 공간은 항상 해시 테이블로 표시되므로 &lt;a href=&quot;scan&quot;&gt;SCAN&lt;/a&gt; 자체는이 동작을 보여주지 않습니다.</target>
        </trans-unit>
        <trans-unit id="80f59bf42799c4d062d02c6eed9565bd78400383" translate="yes" xml:space="preserve">
          <source>Also note with &lt;a href=&quot;mget&quot;&gt;MGET&lt;/a&gt;, the -1 value for &quot;last key position&quot; means the list of keys may have unlimited length.</source>
          <target state="translated">또한 &lt;a href=&quot;mget&quot;&gt;MGET&lt;/a&gt; 에서 &quot;마지막 키 위치&quot;의 -1 값은 키 목록의 길이가 무제한임을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="5157f46144d13fb21a63005bb60f24f4ce105e11" translate="yes" xml:space="preserve">
          <source>Also see &lt;a href=&quot;command-getkeys&quot;&gt;COMMAND GETKEYS&lt;/a&gt; for getting your Redis server tell you where keys are in any given command.</source>
          <target state="translated">또한 참조 &lt;a href=&quot;command-getkeys&quot;&gt;COMMAND GETKEYS을&lt;/a&gt; 키는 주어진 명령에 어디 레디 스 서버가 당신에게 얻기를 위해.</target>
        </trans-unit>
        <trans-unit id="04eefa213e7d217c0e7123cc1dc6c27083f06f1b" translate="yes" xml:space="preserve">
          <source>Also there are two important rules to note:</source>
          <target state="translated">또한 두 가지 중요한 규칙이 있습니다.</target>
        </trans-unit>
        <trans-unit id="253a3794bb6046fd04b2899f39397ddc5b7914e5" translate="yes" xml:space="preserve">
          <source>Also, as already mentioned, restarting a Redis instance flushes the script cache, which is not persistent. However from the point of view of the client there are only two ways to make sure a Redis instance was not restarted between two different commands.</source>
          <target state="translated">또한 이미 언급했듯이 Redis 인스턴스를 다시 시작하면 스크립트 캐시가 플러시됩니다. 그러나 클라이언트의 관점에서 Redis 인스턴스가 서로 다른 두 명령 사이에서 다시 시작되지 않도록하는 방법은 두 가지뿐입니다.</target>
        </trans-unit>
        <trans-unit id="ea8c51c6921844728fda67e56ae9ac9b762367f1" translate="yes" xml:space="preserve">
          <source>Alters the last access time of a key(s). A key is ignored if it does not exist.</source>
          <target state="translated">키의 마지막 액세스 시간을 변경합니다. 키가 없으면 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="b199d3c5e6bdd12d3e1986a0a392afea94eaf2b8" translate="yes" xml:space="preserve">
          <source>Always use plain &lt;a href=&quot;eval&quot;&gt;EVAL&lt;/a&gt; when in the context of a pipeline.</source>
          <target state="translated">파이프 라인과 관련하여 항상 일반 &lt;a href=&quot;eval&quot;&gt;EVAL을&lt;/a&gt; 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="31201176aa04df37b1e2ed06ec57bbbf2e617274" translate="yes" xml:space="preserve">
          <source>An RDB version is encoded inside the serialized value, so that different Redis versions with incompatible RDB formats will refuse to process the serialized value.</source>
          <target state="translated">RDB 버전은 직렬화 된 값 안에 인코딩되므로 호환되지 않는 RDB 형식을 가진 다른 Redis 버전은 직렬화 된 값 처리를 거부합니다.</target>
        </trans-unit>
        <trans-unit id="1eea03e66681a82857dbef8c5c7533ecccb36fa9" translate="yes" xml:space="preserve">
          <source>An additional client may monitor the &lt;em&gt;processing&lt;/em&gt; list for items that remain there for too much time, and will push those timed out items into the queue again if needed.</source>
          <target state="translated">추가 클라이언트가 &lt;em&gt;처리&lt;/em&gt; 목록에 너무 많은 시간 동안 남아있는 항목을 모니터링하고 필요한 경우 시간 초과 된 항목을 다시 큐로 푸시합니다.</target>
        </trans-unit>
        <trans-unit id="07675d1e6396e649280fe8bed0df48043817bbfd" translate="yes" xml:space="preserve">
          <source>An already known node sends a list of nodes in the gossip section that we are not aware of. If the receiving node trusts the sending node as a known node, it will process the gossip section and send an handshake to the nodes that are still not known.</source>
          <target state="translated">이미 알려진 노드는 우리가 모르는 가십 섹션의 노드 목록을 보냅니다. 수신 노드가 송신 노드를 알려진 노드로 신뢰하는 경우 가십 섹션을 처리하고 여전히 알려지지 않은 노드로 핸드 셰이크를 보냅니다.</target>
        </trans-unit>
        <trans-unit id="a452bcfbd349eeb9ee037b3cbc2821a66bfa35e2" translate="yes" xml:space="preserve">
          <source>An alternative implementation uses a single counter, but is a bit more complex to get it right without race conditions. We'll examine different variants.</source>
          <target state="translated">대체 구현은 단일 카운터를 사용하지만 경쟁 조건없이 올바르게 처리하려면 약간 더 복잡합니다. 다양한 변형을 살펴 보겠습니다.</target>
        </trans-unit>
        <trans-unit id="bff9693e7f02bacc6bf60b4b05563fd05ce6a13a" translate="yes" xml:space="preserve">
          <source>An array composed of three elements array representing the connected replicas. Every sub-array contains the replica IP, port, and the last acknowledged replication offset.</source>
          <target state="translated">연결된 복제본을 나타내는 3 개의 요소 배열로 구성된 배열입니다. 모든 하위 배열에는 복제본 IP, 포트 및 마지막으로 확인 된 복제 오프셋이 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="a4850b5a22272049075215bf5ab0daed4f790d9d" translate="yes" xml:space="preserve">
          <source>An array of master names monitored by this Sentinel instance.</source>
          <target state="translated">이 Sentinel 인스턴스가 모니터링하는 마스터 이름 배열입니다.</target>
        </trans-unit>
        <trans-unit id="fb9ff52a245be210db03256bc0b542759913e5e2" translate="yes" xml:space="preserve">
          <source>An entry is composed of a set of field-value pairs, it is basically a small dictionary. The field-value pairs are stored in the same order they are given by the user, and commands to read the stream such as &lt;a href=&quot;xrange&quot;&gt;XRANGE&lt;/a&gt; or &lt;a href=&quot;xread&quot;&gt;XREAD&lt;/a&gt; are guaranteed to return the fields and values exactly in the same order they were added by &lt;a href=&quot;xadd&quot;&gt;XADD&lt;/a&gt;.</source>
          <target state="translated">항목은 필드-값 쌍 세트로 구성되며 기본적으로 작은 사전입니다. 필드 값 쌍들은 사용자에 의해 특정되는 것과 동일한 순서로 저장되고, 명령 등의 스트림을 읽어 &lt;a href=&quot;xrange&quot;&gt;XRANGE&lt;/a&gt; 또는 &lt;a href=&quot;xread&quot;&gt;XREAD&lt;/a&gt; 들이 추가 된 순서대로 정확히 필드 및 값을 반환 보장 &lt;a href=&quot;xadd&quot;&gt;XADD&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="75d00cd00e1f2b13a890f0d28b95cf6fbe73de9c" translate="yes" xml:space="preserve">
          <source>An error is returned for out of range indexes.</source>
          <target state="translated">범위를 벗어난 인덱스에 대해서는 오류가 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="e1e52880ba8cd5516094695a791c7cb25bb9cf75" translate="yes" xml:space="preserve">
          <source>An error is returned if &lt;code&gt;source&lt;/code&gt; or &lt;code&gt;destination&lt;/code&gt; does not hold a set value.</source>
          <target state="translated">&lt;code&gt;source&lt;/code&gt; 또는 &lt;code&gt;destination&lt;/code&gt; 이 설정 값을 보유하지 않으면 오류가 리턴됩니다 .</target>
        </trans-unit>
        <trans-unit id="f347bee22b5d2cb10d2901659685fcd72a034c77" translate="yes" xml:space="preserve">
          <source>An error is returned when &lt;code&gt;key&lt;/code&gt; exists and does not hold a sorted set.</source>
          <target state="translated">&lt;code&gt;key&lt;/code&gt; 가 있고 정렬 된 세트를 보유하지 않으면 오류가 리턴됩니다 .</target>
        </trans-unit>
        <trans-unit id="e231fa35664a84f1e5009d81e7f6bba1d485eec3" translate="yes" xml:space="preserve">
          <source>An error is returned when &lt;code&gt;key&lt;/code&gt; exists but does not hold a list value.</source>
          <target state="translated">&lt;code&gt;key&lt;/code&gt; 가 있지만 목록 값을 보유하지 않으면 오류가 리턴됩니다 .</target>
        </trans-unit>
        <trans-unit id="6bdfaaedacc744e822937a491c0aa265faa0a3c9" translate="yes" xml:space="preserve">
          <source>An error is returned when &lt;code&gt;key&lt;/code&gt; exists but does not hold a sorted set.</source>
          <target state="translated">&lt;code&gt;key&lt;/code&gt; 가 있지만 정렬 된 세트를 보유하지 않으면 오류가 리턴됩니다 .</target>
        </trans-unit>
        <trans-unit id="cafd7db432cc1bfe0eb095227c59268bb7b93c9e" translate="yes" xml:space="preserve">
          <source>An error is returned when &lt;code&gt;seconds&lt;/code&gt; is invalid.</source>
          <target state="translated">&lt;code&gt;seconds&lt;/code&gt; 유효하지 않으면 오류가 리턴됩니다 .</target>
        </trans-unit>
        <trans-unit id="8e9136354e1045681dd2f7a86b9527fc481d91cd" translate="yes" xml:space="preserve">
          <source>An error is returned when the value stored at &lt;code&gt;key&lt;/code&gt; is not a set.</source>
          <target state="translated">&lt;code&gt;key&lt;/code&gt; 저장된 값 이 설정되지 않은 경우 오류가 리턴됩니다 .</target>
        </trans-unit>
        <trans-unit id="b4eb1a0965c235064ac8aba79722ddaff3491eef" translate="yes" xml:space="preserve">
          <source>An example of Sentinel output:</source>
          <target state="translated">Sentinel 출력의 예 :</target>
        </trans-unit>
        <trans-unit id="e3a2b833146840fa4cd410d9b71d1f7b478f823c" translate="yes" xml:space="preserve">
          <source>An example of output when &lt;a href=&quot;role&quot;&gt;ROLE&lt;/a&gt; is called in a master instance:</source>
          <target state="translated">마스터 인스턴스에서 &lt;a href=&quot;role&quot;&gt;ROLE&lt;/a&gt; 이 호출 될 때의 출력 예 :</target>
        </trans-unit>
        <trans-unit id="579d469e7cac2523515437d9b8d6112fe3d93c9e" translate="yes" xml:space="preserve">
          <source>An example of output when &lt;a href=&quot;role&quot;&gt;ROLE&lt;/a&gt; is called in a replica instance:</source>
          <target state="translated">복제본 인스턴스에서 &lt;a href=&quot;role&quot;&gt;ROLE&lt;/a&gt; 이 호출 될 때의 출력 예 :</target>
        </trans-unit>
        <trans-unit id="1d6f1c424d50ab94243fe38cbdfeabffd674d66c" translate="yes" xml:space="preserve">
          <source>An example of unlock script would be similar to the following:</source>
          <target state="translated">잠금 해제 스크립트의 예는 다음과 유사합니다.</target>
        </trans-unit>
        <trans-unit id="89fe7da248c22605a4e15750b1f9beb107181168" translate="yes" xml:space="preserve">
          <source>An example sampling the temperature of a sensor using fixed-size strings (using a binary format is better in real implementations).</source>
          <target state="translated">고정 크기 문자열을 사용하여 센서 온도를 샘플링하는 예 (이진 형식을 사용하는 것이 실제 구현에서 더 낫습니다).</target>
        </trans-unit>
        <trans-unit id="4eae947ad09e05cad458fca2075b30ae1b15869c" translate="yes" xml:space="preserve">
          <source>An interesting pattern using &lt;code&gt;SORT ... STORE&lt;/code&gt; consists in associating an &lt;a href=&quot;expire&quot;&gt;EXPIRE&lt;/a&gt; timeout to the resulting key so that in applications where the result of a &lt;a href=&quot;sort&quot;&gt;SORT&lt;/a&gt; operation can be cached for some time. Other clients will use the cached list instead of calling &lt;a href=&quot;sort&quot;&gt;SORT&lt;/a&gt; for every request. When the key will timeout, an updated version of the cache can be created by calling &lt;code&gt;SORT ... STORE&lt;/code&gt; again.</source>
          <target state="translated">&lt;code&gt;SORT ... STORE&lt;/code&gt; 사용하는 흥미로운 패턴 은 &lt;a href=&quot;expire&quot;&gt;EXPIRE&lt;/a&gt; 제한 시간을 결과 키 에 연관 시켜 &lt;a href=&quot;sort&quot;&gt;SORT&lt;/a&gt; 조작 결과를 한동안 캐시 할 수있는 응용 프로그램에서 구성 됩니다. 다른 클라이언트는 모든 요청 에 대해 &lt;a href=&quot;sort&quot;&gt;SORT&lt;/a&gt; 를 호출하는 대신 캐시 된 목록을 사용합니다 . 키가 시간 초과되면 &lt;code&gt;SORT ... STORE&lt;/code&gt; 다시 호출하여 업데이트 된 캐시 버전을 작성할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="c296bdf9668142740fec726611d45d470138dafa" translate="yes" xml:space="preserve">
          <source>An iteration starts when the cursor is set to 0, and terminates when the cursor returned by the server is 0. The following is an example of SCAN iteration:</source>
          <target state="translated">커서가 0으로 설정되면 반복이 시작되고 서버가 리턴 한 커서가 0이면 종료가 수행됩니다. 다음은 SCAN 반복의 예입니다.</target>
        </trans-unit>
        <trans-unit id="060444849d7b2e77c482c80d4ddc007637e5e3e9" translate="yes" xml:space="preserve">
          <source>And so for until the iteration is complete and no result is returned. See the &lt;a href=&quot;xrange&quot;&gt;XRANGE&lt;/a&gt; page about iterating for more information.</source>
          <target state="translated">그리고 반복이 완료되고 결과가 반환되지 않을 때까지. 자세한 정보는 반복에 대한 &lt;a href=&quot;xrange&quot;&gt;XRANGE&lt;/a&gt; 페이지를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="abbabebfac6efc7292e2eb1b2e18a22fb8f0b07b" translate="yes" xml:space="preserve">
          <source>And so forth.</source>
          <target state="translated">기타 등등.</target>
        </trans-unit>
        <trans-unit id="4c3a5cf2099eac6b70d3351f9f2b307f8576cbfe" translate="yes" xml:space="preserve">
          <source>And so forth. Eventually this will allow to visit all the entries in the stream. Obviously, we can start the iteration from any ID, or even from a specific time, by providing a given incomplete start ID. Moreover, we can limit the iteration to a given ID or time, by providing an end ID or incomplete ID instead of &lt;code&gt;+&lt;/code&gt;.</source>
          <target state="translated">기타 등등. 결국 이것은 스트림의 모든 항목을 방문 할 수있게합니다. 분명히, 우리는 주어진 불완전한 시작 ID를 제공함으로써 임의의 ID 또는 특정 시간에서 반복을 시작할 수 있습니다. 또한 &lt;code&gt;+&lt;/code&gt; 대신 종료 ID 또는 불완전한 ID를 제공하여 지정된 ID 또는 시간으로 반복을 제한 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="bd50a85c7e0471c36280c42d04f369b2283aaee5" translate="yes" xml:space="preserve">
          <source>And so forth. Eventually, the call will not return any item, but just an empty array, then we know that there is nothing more to fetch from our stream (and we would have to retry the operation, hence this command also supports a blocking mode).</source>
          <target state="translated">기타 등등. 결국 호출은 항목을 반환하지 않고 빈 배열 만 반환하므로 스트림에서 가져올 항목이 더 없다는 것을 알고 있습니다 (그리고 우리는 작업을 다시 시도해야 하므로이 명령은 차단 모드도 지원합니다).</target>
        </trans-unit>
        <trans-unit id="087d39ee1a0310d3323a4cfd02c6576b584cb468" translate="yes" xml:space="preserve">
          <source>Another example: if we imagine a cluster formed of the following four nodes called A, B, C and D, we may send just the following set of commands to A:</source>
          <target state="translated">또 다른 예 : A, B, C 및 D라는 다음 네 개의 노드로 구성된 클러스터를 상상하면 A에 다음 명령 세트 만 보낼 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ed0eff051adefea749add42d4d6cb2b879ab75ce" translate="yes" xml:space="preserve">
          <source>Any other ID, that is, 0 or any other valid ID or incomplete ID (just the millisecond time part), will have the effect of returning entries that are pending for the consumer sending the command. So basically if the ID is not &lt;code&gt;&amp;gt;&lt;/code&gt;, then the command will just let the client access its pending entries: delivered to it, but not yet acknowledged.</source>
          <target state="translated">다른 ID, 즉 0 또는 다른 유효한 ID 또는 불완전한 ID (밀리 초 단위)는 소비자가 명령을 보내는 동안 보류중인 항목을 반환하는 효과가 있습니다. 따라서 기본적으로 ID가 &lt;code&gt;&amp;gt;&lt;/code&gt; 가 아닌 경우 명령은 클라이언트가 보류중인 항목에 액세스하도록 허용합니다. 전달되었지만 아직 승인되지 않았습니다.</target>
        </trans-unit>
        <trans-unit id="bf48c58a252cd0f11f754a6235c3bf6580ab92b5" translate="yes" xml:space="preserve">
          <source>Anyway even assuming a single-instance locking primitive, starting with 2.6.12 it is possible to create a much simpler locking primitive, equivalent to the one discussed here, using the &lt;a href=&quot;set&quot;&gt;SET&lt;/a&gt; command to acquire the lock, and a simple Lua script to release the lock. The pattern is documented in the &lt;a href=&quot;set&quot;&gt;SET&lt;/a&gt; command page.</source>
          <target state="translated">어쨌든 2.6.12부터 단일 인스턴스 잠금 기본을 가정하더라도 &lt;a href=&quot;set&quot;&gt;SET&lt;/a&gt; 명령을 사용 하여 잠금을 획득하고 간단한 Lua 스크립트를 사용하여 자물쇠. 패턴은 &lt;a href=&quot;set&quot;&gt;SET&lt;/a&gt; 명령 페이지에 설명되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="274153f2cd2566cd42de1da9ffc1b6d3d2cf50ae" translate="yes" xml:space="preserve">
          <source>Apart from the reversed ordering, &lt;a href=&quot;zrevrange&quot;&gt;ZREVRANGE&lt;/a&gt; is similar to &lt;a href=&quot;zrange&quot;&gt;ZRANGE&lt;/a&gt;.</source>
          <target state="translated">그렇다 반전 순서에서, &lt;a href=&quot;zrevrange&quot;&gt;ZREVRANGE은&lt;/a&gt; 비슷합니다 &lt;a href=&quot;zrange&quot;&gt;ZRANGE&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="dae9346322df90f8b168ba54317fbcb22d67c378" translate="yes" xml:space="preserve">
          <source>Apart from the reversed ordering, &lt;a href=&quot;zrevrangebylex&quot;&gt;ZREVRANGEBYLEX&lt;/a&gt; is similar to &lt;a href=&quot;zrangebylex&quot;&gt;ZRANGEBYLEX&lt;/a&gt;.</source>
          <target state="translated">반전 된 순서에서 떨어져, &lt;a href=&quot;zrevrangebylex&quot;&gt;ZREVRANGEBYLEX은&lt;/a&gt; 비슷합니다 &lt;a href=&quot;zrangebylex&quot;&gt;ZRANGEBYLEX&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="a5c43ee3f0eb54ffe03d2d092f2d6166614a936e" translate="yes" xml:space="preserve">
          <source>Apart from the reversed ordering, &lt;a href=&quot;zrevrangebyscore&quot;&gt;ZREVRANGEBYSCORE&lt;/a&gt; is similar to &lt;a href=&quot;zrangebyscore&quot;&gt;ZRANGEBYSCORE&lt;/a&gt;.</source>
          <target state="translated">그렇다 반전 순서에서, &lt;a href=&quot;zrevrangebyscore&quot;&gt;ZREVRANGEBYSCORE은&lt;/a&gt; 비슷합니다 &lt;a href=&quot;zrangebyscore&quot;&gt;ZRANGEBYSCORE&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="5abab69f4dc0a66b2f4a79cd40ada74327713efb" translate="yes" xml:space="preserve">
          <source>Appendix: Redis expires</source>
          <target state="translated">부록 : Redis 만료</target>
        </trans-unit>
        <trans-unit id="9ff199315ef371177323189f4cb9355c80a5471f" translate="yes" xml:space="preserve">
          <source>Appends the specified stream entry to the stream at the specified key. If the key does not exist, as a side effect of running this command the key is created with a stream value.</source>
          <target state="translated">지정된 스트림 항목을 지정된 키의 스트림에 추가합니다. 키가 존재하지 않으면이 명령을 실행하는 부작용으로 키가 스트림 값으로 작성됩니다.</target>
        </trans-unit>
        <trans-unit id="8a442180dde4ebe00bdaaebef087550dde9ed275" translate="yes" xml:space="preserve">
          <source>As a side effect a pending message entry is created in the pending entries list (PEL) of the consumer group: it means the message was delivered to a given consumer, but it was not yet acknowledged via &lt;a href=&quot;xack&quot;&gt;XACK&lt;/a&gt;.</source>
          <target state="translated">부작용으로 보류중인 메시지 항목이 소비자 그룹의 보류중인 항목 목록 (PEL)에 작성됩니다. 이는 메시지가 지정된 소비자에게 전달되었지만 아직 &lt;a href=&quot;xack&quot;&gt;XACK을&lt;/a&gt; 통해 승인되지 않았 음을 의미 합니다.</target>
        </trans-unit>
        <trans-unit id="f8d3a747f6516b67780fd78990e06b49b5087892" translate="yes" xml:space="preserve">
          <source>As a side effect of &lt;code&gt;A&lt;/code&gt; knowing and being known by all the other nodes, it will send gossip sections in the heartbeat packets that will allow each other node to create a link with each other one, forming a full mesh in a matter of seconds, even if the cluster is large.</source>
          <target state="translated">다른 모든 노드에서 알고 알고 있는 &lt;code&gt;A&lt;/code&gt; 의 부작용 으로, 하트 비트 패킷으로 가십 섹션을 전송하여 서로의 노드가 서로 링크를 만들어 몇 초 만에 전체 메시를 형성 할 수 있습니다. 클러스터가 큰 경우에도 마찬가지입니다.</target>
        </trans-unit>
        <trans-unit id="90aa44b5c0b6d562f721575257b4845fb2c1994d" translate="yes" xml:space="preserve">
          <source>As a side effect of the command execution, if a slot among the ones specified as argument is set as &lt;code&gt;importing&lt;/code&gt;, this state gets cleared once the node assigns the (previously unbound) slot to itself.</source>
          <target state="translated">명령 실행의 부작용으로, argument로 지정된 슬롯 중 하나가 &lt;code&gt;importing&lt;/code&gt; 으로 설정된 경우, 노드가 (이전에는 언 바운드) 슬롯을 자신에게 할당하면이 상태가 해제됩니다.</target>
        </trans-unit>
        <trans-unit id="a31cef2ee08d5e8239d818737dfa96674f437698" translate="yes" xml:space="preserve">
          <source>As a side effect of the command execution, the node may go into &lt;em&gt;down&lt;/em&gt; state because not all hash slots are covered.</source>
          <target state="translated">명령 실행의 부작용으로 모든 해시 슬롯이 포함되지 않기 때문에 노드가 &lt;em&gt;다운&lt;/em&gt; 상태 가 될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="fdfda2f0f0a65c5c9350447421bdbd24d0c16cd7" translate="yes" xml:space="preserve">
          <source>As a side effect of this command the HyperLogLog internals may be updated to reflect a different estimation of the number of unique items added so far (the cardinality of the set).</source>
          <target state="translated">이 명령의 부작용으로 HyperLogLog 내부는 지금까지 추가 된 고유 항목 수 (세트의 카디널리티)의 다른 추정값을 반영하도록 업데이트 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e3b0ef422a5105dd7a168f1bd22deb9e931a8ad3" translate="yes" xml:space="preserve">
          <source>As already stated, calls to &lt;code&gt;redis.call()&lt;/code&gt; resulting in a Redis command error will stop the execution of the script and return an error, in a way that makes it obvious that the error was generated by a script:</source>
          <target state="translated">이미 언급했듯이 &lt;code&gt;redis.call()&lt;/code&gt; 호출 하면 Redis 명령 오류가 발생하여 스크립트 실행이 중지되고 오류가 스크립트에 의해 생성되었음을 알 수있는 방식으로 오류가 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="824fabdff9eac7426b269cefa6ab8cb7c6a7fa7e" translate="yes" xml:space="preserve">
          <source>As of v5.0, the optional &lt;code&gt;TYPE type&lt;/code&gt; subcommand can be used to filter the list by clients' type, where &lt;em&gt;type&lt;/em&gt; is one of &lt;code&gt;normal&lt;/code&gt;, &lt;code&gt;master&lt;/code&gt;, &lt;code&gt;replica&lt;/code&gt; and &lt;code&gt;pubsub&lt;/code&gt;. Note that clients blocked into the &lt;a href=&quot;monitor&quot;&gt;MONITOR&lt;/a&gt; command are considered to belong to the &lt;code&gt;normal&lt;/code&gt; class.</source>
          <target state="translated">v5.0부터 선택적 &lt;code&gt;TYPE type&lt;/code&gt; 부속 명령을 사용하여 클라이언트 유형별로 목록을 필터링 할 수 있습니다. 여기서 &lt;em&gt;type&lt;/em&gt; 은 &lt;code&gt;normal&lt;/code&gt; , &lt;code&gt;master&lt;/code&gt; , &lt;code&gt;replica&lt;/code&gt; 및 &lt;code&gt;pubsub&lt;/code&gt; 중 하나입니다 . &lt;a href=&quot;monitor&quot;&gt;MONITOR&lt;/a&gt; 명령 으로 차단 된 클라이언트 는 &lt;code&gt;normal&lt;/code&gt; 클래스 에 속하는 것으로 간주됩니다 .</target>
        </trans-unit>
        <trans-unit id="b20dcd69a8805b2228dfb60a21cf7d97acd5f67c" translate="yes" xml:space="preserve">
          <source>As you can see 3.333 is converted into 3, and the &lt;em&gt;bar&lt;/em&gt; string is never returned as there is a nil before.</source>
          <target state="translated">보시다시피 3.333은 3으로 변환되고 이전에 nil이 있으므로 &lt;em&gt;바&lt;/em&gt; 문자열은 반환되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="ec8e8f706055fbdba6360cfb1b417dae6427300e" translate="yes" xml:space="preserve">
          <source>As you can see &lt;strong&gt;NOT&lt;/strong&gt; is special as it only takes an input key, because it performs inversion of bits so it only makes sense as an unary operator.</source>
          <target state="translated">보시다시피 &lt;strong&gt;NOT&lt;/strong&gt; 은 비트의 반전을 수행하므로 단항 연산자로만 이해되므로 입력 키만 사용하므로 특별합니다.</target>
        </trans-unit>
        <trans-unit id="a732d9b394f216e3ee5501e430e6cf1a3865a69a" translate="yes" xml:space="preserve">
          <source>As you can see in this way removing a node is fragile, we need to send &lt;a href=&quot;cluster-forget&quot;&gt;CLUSTER FORGET&lt;/a&gt; commands to all the nodes ASAP hoping there are no gossip sections processing in the meantime. Because of this problem the command implements a ban-list with an expire time for each entry.</source>
          <target state="translated">이 방법으로 노드 제거가 깨지기 쉬운 것처럼 알 수 있듯이 그 동안 가십 섹션이 처리되지 않기를 희망하면서 &lt;a href=&quot;cluster-forget&quot;&gt;CLUSTER FORGET&lt;/a&gt; 명령을 모든 노드 에 보내야 합니다. 이 문제로 인해 명령은 각 항목에 대해 만료 시간이있는 금지 목록을 구현합니다.</target>
        </trans-unit>
        <trans-unit id="aeec0e9426a0a0a54fbf363e2b26ff697ce52419" translate="yes" xml:space="preserve">
          <source>As you can see most of the calls returned zero elements, but the last call where a COUNT of 1000 was used in order to force the command to do more scanning for that iteration.</source>
          <target state="translated">보시다시피 대부분의 호출은 0 개의 요소를 반환했지만 명령이 해당 반복에 대해 더 많은 스캔을 수행하도록하기 위해 COUNT의 1000이 사용 된 마지막 호출입니다.</target>
        </trans-unit>
        <trans-unit id="f1947772b8e632184927e0616393e7edcce03ca1" translate="yes" xml:space="preserve">
          <source>As you can see the &lt;strong&gt;SCAN return value&lt;/strong&gt; is an array of two values: the first value is the new cursor to use in the next call, the second value is an array of elements.</source>
          <target state="translated">보시다시피 &lt;strong&gt;SCAN 반환 값&lt;/strong&gt; 은 두 값의 배열입니다. 첫 번째 값은 다음 호출에서 사용할 새 커서이고 두 번째 값은 요소의 배열입니다.</target>
        </trans-unit>
        <trans-unit id="53b31465005a9966a63fe8728e23f94c240abdb1" translate="yes" xml:space="preserve">
          <source>Ask the server to close the connection. The connection is closed as soon as all pending replies have been written to the client.</source>
          <target state="translated">서버에게 연결을 닫으라고 요청하십시오. 보류중인 모든 회신이 클라이언트에 기록 되 자마자 연결이 닫힙니다.</target>
        </trans-unit>
        <trans-unit id="14070ea7474a205db9d3fb81cc4d13bc90f1f1d9" translate="yes" xml:space="preserve">
          <source>Assign itself all the hash slots of its master, and propagate the new configuration to every node which is reachable ASAP, and eventually to every other node.</source>
          <target state="translated">마스터의 모든 해시 슬롯을 자체적으로 할당하고 가능한 빨리 도달 가능한 모든 노드와 다른 모든 노드에 새 구성을 전파하십시오.</target>
        </trans-unit>
        <trans-unit id="dad88cac85a84619b71e6377f7daff4cceaf9449" translate="yes" xml:space="preserve">
          <source>Assuming &lt;code&gt;mylist&lt;/code&gt; is a list of numbers, this command will return the same list with the elements sorted from small to large. In order to sort the numbers from large to small, use the &lt;code&gt;DESC&lt;/code&gt; modifier:</source>
          <target state="translated">&lt;code&gt;mylist&lt;/code&gt; 가 숫자 목록 이라고 가정하면 이 명령은 요소를 작은 것에서 큰 것으로 정렬하여 동일한 목록을 반환합니다. 숫자를 큰 숫자에서 작은 숫자로 정렬하려면 &lt;code&gt;DESC&lt;/code&gt; 수정자를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="08f85fbfa8d38f4d4fc4368e61ca47c40b831995" translate="yes" xml:space="preserve">
          <source>At this point you add all the elements into a sorted set using this algorithm:</source>
          <target state="translated">이 시점에서이 알고리즘을 사용하여 모든 요소를 ​​정렬 된 세트에 추가합니다.</target>
        </trans-unit>
        <trans-unit id="7f922bf277a422b7aa1b3e6b1ecb1c33f7f356b4" translate="yes" xml:space="preserve">
          <source>At this point, each time you want to get a weighted random element, just compute a random number between 0 and 1 (which is like calling &lt;code&gt;rand()&lt;/code&gt; in most languages), so you can just do:</source>
          <target state="translated">이 시점에서 가중 무작위 요소를 얻으려면 0에서 1 사이의 임의의 숫자 &lt;code&gt;rand()&lt;/code&gt; 대부분의 언어에서 rand () 를 호출하는 것과 같은 ) 를 계산하면 됩니다.</target>
        </trans-unit>
        <trans-unit id="eeda06eb4e4b735e9051a2d2f05c160b9b8289f8" translate="yes" xml:space="preserve">
          <source>Atomic rewrite process</source>
          <target state="translated">원자 재 작성 과정</target>
        </trans-unit>
        <trans-unit id="f74a4fa429114feaddb20d28202c0f4085635272" translate="yes" xml:space="preserve">
          <source>Atomically returns and removes the last element (tail) of the list stored at &lt;code&gt;source&lt;/code&gt;, and pushes the element at the first element (head) of the list stored at &lt;code&gt;destination&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;source&lt;/code&gt; 에 저장된 목록의 마지막 요소 (꼬리)를 원자 적으로 반환하고 제거하고 &lt;code&gt;destination&lt;/code&gt; 에 저장된 목록의 첫 번째 요소 (머리)에 요소를 푸시 합니다 .</target>
        </trans-unit>
        <trans-unit id="f6a41c1878a1c7a7b99d6378b8645723ed06556f" translate="yes" xml:space="preserve">
          <source>Atomically sets &lt;code&gt;key&lt;/code&gt; to &lt;code&gt;value&lt;/code&gt; and returns the old value stored at &lt;code&gt;key&lt;/code&gt;. Returns an error when &lt;code&gt;key&lt;/code&gt; exists but does not hold a string value.</source>
          <target state="translated">원자 설정 &lt;code&gt;key&lt;/code&gt; 에 &lt;code&gt;value&lt;/code&gt; 과에 저장된 이전 값 리턴 &lt;code&gt;key&lt;/code&gt; . &lt;code&gt;key&lt;/code&gt; 가 있지만 문자열 값을 보유하지 않은 경우 오류를 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="8b11c68f40fb668f25d5ebde4e4f0d736514c197" translate="yes" xml:space="preserve">
          <source>Atomically transfer a key from a source Redis instance to a destination Redis instance. On success the key is deleted from the original instance and is guaranteed to exist in the target instance.</source>
          <target state="translated">소스 Redis 인스턴스에서 대상 Redis 인스턴스로 키를 원자 적으로 전송합니다. 성공하면 키가 원래 인스턴스에서 삭제되고 대상 인스턴스에 존재합니다.</target>
        </trans-unit>
        <trans-unit id="120b36c4fdcd059217cbe9ce714cea19b13fd52a" translate="yes" xml:space="preserve">
          <source>Atomicity of scripts</source>
          <target state="translated">스크립트의 원 자성</target>
        </trans-unit>
        <trans-unit id="6a7f6b699ae2620127572c6b19a3962b68ea30ba" translate="yes" xml:space="preserve">
          <source>Available libraries</source>
          <target state="translated">사용 가능한 라이브러리</target>
        </trans-unit>
        <trans-unit id="fc1c7e083bc573df54c3a610bc7a64ef713879e0" translate="yes" xml:space="preserve">
          <source>B sends node A a heartbeat packet, where node D is listed.</source>
          <target state="translated">B는 노드 A에 하트 비트 패킷을 보내며, 여기서 노드 D가 나열됩니다.</target>
        </trans-unit>
        <trans-unit id="7729f6e6ec6ba874a64709376383726e87372daa" translate="yes" xml:space="preserve">
          <source>BGREWRITEAOF</source>
          <target state="translated">BGREWRITEAOF</target>
        </trans-unit>
        <trans-unit id="458f7ff8a0210a97fe946685d4c3eaec2c4d3268" translate="yes" xml:space="preserve">
          <source>BGREWRITEAOF   Asynchronously rewrite the append-only file</source>
          <target state="translated">BGREWRITEAOF 추가 전용 파일을 비동기 적으로 다시 작성</target>
        </trans-unit>
        <trans-unit id="a27e9a0dccc378a573407c1d809762f71f913c63" translate="yes" xml:space="preserve">
          <source>BGSAVE</source>
          <target state="translated">BGSAVE</target>
        </trans-unit>
        <trans-unit id="7faf716555dfc6c9000f52854e242ef60d56665d" translate="yes" xml:space="preserve">
          <source>BGSAVE   Asynchronously save the dataset to disk</source>
          <target state="translated">BGSAVE 데이터 세트를 디스크에 비동기 적으로 저장</target>
        </trans-unit>
        <trans-unit id="aa73037de86a35867f756331811a0b553f9a4512" translate="yes" xml:space="preserve">
          <source>BITCOUNT</source>
          <target state="translated">BITCOUNT</target>
        </trans-unit>
        <trans-unit id="558065aa2007c718ef4867af43bb99fd2d71d712" translate="yes" xml:space="preserve">
          <source>BITCOUNT  key [start end]   Count set bits in a string</source>
          <target state="translated">BITCOUNT 키 [시작 끝] 문자열의 카운트 세트 비트</target>
        </trans-unit>
        <trans-unit id="4648876b3aec23fc361c9cc8f6b361de8992e75b" translate="yes" xml:space="preserve">
          <source>BITFIELD</source>
          <target state="translated">BITFIELD</target>
        </trans-unit>
        <trans-unit id="4e856b858022af2e0acd6b68544eced1b0992122" translate="yes" xml:space="preserve">
          <source>BITFIELD  key [GET type offset] [SET type offset value] [INCRBY type offset increment] [OVERFLOW WRAP|SAT|FAIL]   Perform arbitrary bitfield integer operations on strings</source>
          <target state="translated">BITFIELD 키 [GET 유형 오프셋] [SET 유형 오프셋 값] [INCRBY 유형 오프셋 증분] [OVERFLOW WRAP | SAT | FAIL] 문자열에서 임의의 비트 필드 정수 연산 수행</target>
        </trans-unit>
        <trans-unit id="a5aaf403ca55d3d64f12bde81881e9c02072728a" translate="yes" xml:space="preserve">
          <source>BITOP</source>
          <target state="translated">BITOP</target>
        </trans-unit>
        <trans-unit id="fbf06b661d51c935ecb7a0e541d91fa350da1c52" translate="yes" xml:space="preserve">
          <source>BITOP  operation destkey key [key ...]   Perform bitwise operations between strings</source>
          <target state="translated">BITOP 작업 destkey 키 [key ...] 문자열 간 비트 연산 수행</target>
        </trans-unit>
        <trans-unit id="6429405be50a33193090d8d4c0a4575b80d167fc" translate="yes" xml:space="preserve">
          <source>BITPOS</source>
          <target state="translated">BITPOS</target>
        </trans-unit>
        <trans-unit id="3eedfee8a6aaf27b486a0a74ef694737767592c5" translate="yes" xml:space="preserve">
          <source>BITPOS  key bit [start] [end]   Find first bit set or clear in a string</source>
          <target state="translated">BITPOS 키 비트 [start] [end] 문자열에서 첫 번째 비트 세트 찾기 또는 지우기</target>
        </trans-unit>
        <trans-unit id="f05499a7141cb9854f00176880caa9ac423867f3" translate="yes" xml:space="preserve">
          <source>BLPOP</source>
          <target state="translated">BLPOP</target>
        </trans-unit>
        <trans-unit id="0412d709e7cedab62c94968e19cc0014d112f86b" translate="yes" xml:space="preserve">
          <source>BLPOP  key [key ...] timeout   Remove and get the first element in a list, or block until one is available</source>
          <target state="translated">BLPOP 키 [key ...] timeout 목록에서 첫 번째 요소를 제거하여 가져 오거나 사용할 수있을 때까지 차단</target>
        </trans-unit>
        <trans-unit id="5fa06c19410e8a659911506832eca92eaf0050d6" translate="yes" xml:space="preserve">
          <source>BRPOP</source>
          <target state="translated">BRPOP</target>
        </trans-unit>
        <trans-unit id="30c26bc19b012eb7d9f5f55b03c3f9d84b9cf9c5" translate="yes" xml:space="preserve">
          <source>BRPOP  key [key ...] timeout   Remove and get the last element in a list, or block until one is available</source>
          <target state="translated">BRPOP 키 [key ...] timeout 목록에서 마지막 요소를 제거하고 가져 오거나 사용할 수있을 때까지 차단</target>
        </trans-unit>
        <trans-unit id="c32cdb6143356d21802163582eddef7653863e06" translate="yes" xml:space="preserve">
          <source>BRPOPLPUSH</source>
          <target state="translated">BRPOPLPUSH</target>
        </trans-unit>
        <trans-unit id="74721eebf76b2ddc61de86b46cc0aec39763409c" translate="yes" xml:space="preserve">
          <source>BRPOPLPUSH  source destination timeout   Pop a value from a list, push it to another list and return it; or block until one is available</source>
          <target state="translated">BRPOPLPUSH 소스 대상 시간 종료 목록에서 값을 팝하여 다른 목록으로 푸시 한 후 리턴하십시오. 또는 하나를 사용할 수있을 때까지 차단</target>
        </trans-unit>
        <trans-unit id="fe7a2ea791972d134e771e602c9bb77407df350d" translate="yes" xml:space="preserve">
          <source>BZPOPMAX</source>
          <target state="translated">BZPOPMAX</target>
        </trans-unit>
        <trans-unit id="b6758ab6d65fab9e15ff22d76094622028d82dec" translate="yes" xml:space="preserve">
          <source>BZPOPMAX  key [key ...] timeout   Remove and return the member with the highest score from one or more sorted sets, or block until one is available</source>
          <target state="translated">BZPOPMAX 키 [key ...] timeout 하나 이상의 정렬 된 세트에서 가장 높은 점수를 가진 멤버를 제거하고 리턴하거나 하나를 사용할 수있을 때까지 차단하십시오.</target>
        </trans-unit>
        <trans-unit id="cc5c70cba5a0768ab8e3b521a15ca38c10af43e5" translate="yes" xml:space="preserve">
          <source>BZPOPMIN</source>
          <target state="translated">BZPOPMIN</target>
        </trans-unit>
        <trans-unit id="34934a39c9faa59399a1c05af5d02cc1bce19590" translate="yes" xml:space="preserve">
          <source>BZPOPMIN  key [key ...] timeout   Remove and return the member with the lowest score from one or more sorted sets, or block until one is available</source>
          <target state="translated">BZPOPMIN 키 [key ...] timeout 하나 이상의 정렬 된 세트에서 점수가 가장 낮은 멤버를 제거하고 반환하거나, 사용 가능한 세트가있을 때까지 차단합니다.</target>
        </trans-unit>
        <trans-unit id="64dd60fe1a049fe6db3eb1369dec2e42bf428e21" translate="yes" xml:space="preserve">
          <source>Background</source>
          <target state="translated">Background</target>
        </trans-unit>
        <trans-unit id="baab43179123dd499c2cc2c83ab2bfdd9cbd1aec" translate="yes" xml:space="preserve">
          <source>Bandwidth and EVALSHA</source>
          <target state="translated">대역폭과 EVALSHA</target>
        </trans-unit>
        <trans-unit id="65f639d2a40570f68ed54fc56bf243ceac2035a0" translate="yes" xml:space="preserve">
          <source>Basic usage:</source>
          <target state="translated">기본 사용법 :</target>
        </trans-unit>
        <trans-unit id="12e09074a5a31051e466bb25ea4c7f7009a10585" translate="yes" xml:space="preserve">
          <source>Basically we have a counter for every IP, for every different second. But this counters are always incremented setting an expire of 10 seconds so that they'll be removed by Redis automatically when the current second is a different one.</source>
          <target state="translated">기본적으로 모든 IP, 매 초마다 카운터가 있습니다. 그러나이 카운터는 항상 10 초의 만료를 설정하여 증가하므로 현재 초가 다른 경우 Redis가 자동으로 제거합니다.</target>
        </trans-unit>
        <trans-unit id="3bc673f7ca5e59c74c138e173d60ace2cc7f15b0" translate="yes" xml:space="preserve">
          <source>Basically, the function considers the right of the string as padded with zeros if you look for clear bits and specify no range or the &lt;em&gt;start&lt;/em&gt; argument &lt;strong&gt;only&lt;/strong&gt;.</source>
          <target state="translated">기본적으로 함수는 명확한 비트를 찾고 범위를 지정하지 않거나 &lt;em&gt;시작&lt;/em&gt; 인수 &lt;strong&gt;만&lt;/strong&gt; 지정하면 문자열의 오른쪽을 0으로 채워진 것으로 간주합니다 .</target>
        </trans-unit>
        <trans-unit id="14b677b3a5e36da0c5dac8a200bd5400f84443e8" translate="yes" xml:space="preserve">
          <source>Because &lt;a href=&quot;monitor&quot;&gt;MONITOR&lt;/a&gt; streams back &lt;strong&gt;all&lt;/strong&gt; commands, its use comes at a cost. The following (totally unscientific) benchmark numbers illustrate what the cost of running &lt;a href=&quot;monitor&quot;&gt;MONITOR&lt;/a&gt; can be.</source>
          <target state="translated">&lt;a href=&quot;monitor&quot;&gt;MONITOR는 &lt;/a&gt;&lt;strong&gt;모든&lt;/strong&gt; 명령을 다시 스트리밍 하기 때문에 비용이 많이 듭니다. 다음 (전체적으로 비과학적인) 벤치 마크 숫자는 &lt;a href=&quot;monitor&quot;&gt;MONITOR&lt;/a&gt; 실행 비용이 얼마 인지 보여줍니다 .</target>
        </trans-unit>
        <trans-unit id="168e98970df56293fbc42baf15adc634cb88819b" translate="yes" xml:space="preserve">
          <source>Because Redis does not have control over how its allocations are mapped to memory pages, high &lt;code&gt;used_memory_rss&lt;/code&gt; is often the result of a spike in memory usage.</source>
          <target state="translated">Redis는 할당이 메모리 페이지에 매핑되는 방식을 제어 할 수 없으므로 높은 &lt;code&gt;used_memory_rss&lt;/code&gt; 는 종종 메모리 사용량이 급증한 결과입니다.</target>
        </trans-unit>
        <trans-unit id="5c7ae78faec3383e9f506c3f0134610891480461" translate="yes" xml:space="preserve">
          <source>Because of the &lt;a href=&quot;getset&quot;&gt;GETSET&lt;/a&gt; semantic, C4 can check if the old value stored at &lt;code&gt;key&lt;/code&gt; is still an expired timestamp. If it is, the lock was acquired.</source>
          <target state="translated">&lt;a href=&quot;getset&quot;&gt;GETSET&lt;/a&gt; 시맨틱으로 인해 C4는 &lt;code&gt;key&lt;/code&gt; 저장된 이전 값 이 여전히 만료 된 시간 소인 인지 확인할 수 있습니다 . 그렇다면 잠금을 획득 한 것입니다.</target>
        </trans-unit>
        <trans-unit id="02e8504630183a9016b44fe68aa220f28cac8de4" translate="yes" xml:space="preserve">
          <source>Because of the first &lt;em&gt;normalized&lt;/em&gt; part in every element (before the colon character), we are forcing a given comparison, however after the range is queries using &lt;a href=&quot;zrangebylex&quot;&gt;ZRANGEBYLEX&lt;/a&gt; the application can display to the user the second part of the string, after the colon.</source>
          <target state="translated">모든 요소에서 첫 번째 &lt;em&gt;정규화 된&lt;/em&gt; 부분 (콜론 문자 이전)으로 인해 주어진 비교를 수행하지만 범위가 &lt;a href=&quot;zrangebylex&quot;&gt;ZRANGEBYLEX를&lt;/a&gt; 사용 하는 쿼리 후에 는 애플리케이션이 사용자에게 콜론 다음에 문자열의 두 번째 부분을 표시 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="05dcf4c78858f10b7a1c629d42f2c28c91d50489" translate="yes" xml:space="preserve">
          <source>Because of this semantic &lt;a href=&quot;msetnx&quot;&gt;MSETNX&lt;/a&gt; can be used in order to set different keys representing different fields of an unique logic object in a way that ensures that either all the fields or none at all are set.</source>
          <target state="translated">이러한 의미 때문에 &lt;a href=&quot;msetnx&quot;&gt;MSETNX&lt;/a&gt; 를 사용하면 모든 필드를 설정하거나 전혀 설정하지 않는 방식으로 고유 논리 객체의 다른 필드를 나타내는 다른 키를 설정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5743095da9632a185291117b22aab7a1ce272b02" translate="yes" xml:space="preserve">
          <source>Because of this the &lt;strong&gt;TAKEOVER&lt;/strong&gt; option should be used with care.</source>
          <target state="translated">이 때문에 &lt;strong&gt;TAKEOVER&lt;/strong&gt; 옵션은주의해서 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="409eae8dc6d494086fe4746042f7a180a489be81" translate="yes" xml:space="preserve">
          <source>Because when a given node is part of the cluster, all the other nodes participating in the cluster knows about it, in order for a node to be completely removed from a cluster, the &lt;a href=&quot;cluster-forget&quot;&gt;CLUSTER FORGET&lt;/a&gt; command must be sent to all the remaining nodes, regardless of the fact they are masters or replicas.</source>
          <target state="translated">지정된 노드가 클러스터의 일부인 경우 클러스터에 참여하는 다른 모든 노드가 클러스터에 대해 알고 있으므로 클러스터에서 노드를 완전히 제거하려면 &lt;a href=&quot;cluster-forget&quot;&gt;CLUSTER FORGET&lt;/a&gt; 명령을 나머지 모든 노드로 보내야합니다. 사실 그들은 마스터 또는 복제본입니다.</target>
        </trans-unit>
        <trans-unit id="b69310332fe10ffd788fd56a9c44b252e49e79dc" translate="yes" xml:space="preserve">
          <source>Behavior of &lt;code&gt;BLPOP&lt;/code&gt; when multiple elements are pushed inside a list.</source>
          <target state="translated">여러 요소가 목록 내에서 푸시 될 때 &lt;code&gt;BLPOP&lt;/code&gt; 의 동작</target>
        </trans-unit>
        <trans-unit id="ece0bd32123faa73ffba96af59789eb1a4470a5d" translate="yes" xml:space="preserve">
          <source>Benchmark result &lt;strong&gt;with&lt;/strong&gt;&lt;a href=&quot;monitor&quot;&gt;MONITOR&lt;/a&gt; running (&lt;code&gt;redis-cli monitor &amp;gt; /dev/null&lt;/code&gt;):</source>
          <target state="translated">벤치 마크 결과 &lt;strong&gt;와 &lt;/strong&gt;&lt;a href=&quot;monitor&quot;&gt;모니터&lt;/a&gt; 실행 ( &lt;code&gt;redis-cli monitor &amp;gt; /dev/null&lt;/code&gt; ) :</target>
        </trans-unit>
        <trans-unit id="e3f9de77c51bcc4c2a59cae3df6e39530202793d" translate="yes" xml:space="preserve">
          <source>Benchmark result &lt;strong&gt;without&lt;/strong&gt;&lt;a href=&quot;monitor&quot;&gt;MONITOR&lt;/a&gt; running:</source>
          <target state="translated">&lt;a href=&quot;monitor&quot;&gt;MONITOR를&lt;/a&gt; 실행 &lt;strong&gt;하지 않은&lt;/strong&gt; 벤치 마크 결과 :</target>
        </trans-unit>
        <trans-unit id="a0cee838302dd7dccb0ba96b0e4f12c473f5ce1f" translate="yes" xml:space="preserve">
          <source>Bitmaps are a very space-efficient representation of certain kinds of information. One example is a Web application that needs the history of user visits, so that for instance it is possible to determine what users are good targets of beta features.</source>
          <target state="translated">비트 맵은 특정 종류의 정보를 매우 공간 효율적으로 표현한 것입니다. 예를 들어 사용자 방문 기록이 필요한 웹 응용 프로그램이 있습니다. 예를 들어 베타 기능의 대상이되는 사용자를 결정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="23c5f7ddc4fdd4c0470d5c822a63678ca6ac8364" translate="yes" xml:space="preserve">
          <source>Bits and positional offsets</source>
          <target state="translated">비트 및 위치 오프셋</target>
        </trans-unit>
        <trans-unit id="01b1462f91bf6adae4924e41a337cd3105d30fba" translate="yes" xml:space="preserve">
          <source>Blocking behavior</source>
          <target state="translated">행동 차단</target>
        </trans-unit>
        <trans-unit id="0138f8dd5046866e565b72d9550fe5224c0fb4c2" translate="yes" xml:space="preserve">
          <source>Blocking for data</source>
          <target state="translated">데이터 차단</target>
        </trans-unit>
        <trans-unit id="b9cbba32c11fb20d3cd9b4d8a8851ece3dbdac10" translate="yes" xml:space="preserve">
          <source>Blocking list operations on lists or sorted sets have a &lt;em&gt;pop&lt;/em&gt; behavior. Bascially, the element is removed from the list or sorted set in order to be returned to the client. In this scenario you want the items to be consumed in a fair way, depending on the moment clients blocked on a given key arrived. Normally Redis uses the FIFO semantics in this use cases.</source>
          <target state="translated">목록 또는 정렬 된 집합에 대한 차단 목록 작업에는 &lt;em&gt;팝&lt;/em&gt; 동작이 있습니다. 기본적으로 요소는 클라이언트에서 리턴되도록 목록 또는 정렬 된 세트에서 제거됩니다. 이 시나리오에서는 특정 키에서 클라이언트가 차단 된 순간에 따라 공정한 방식으로 품목을 소비하려고합니다. 일반적으로 Redis는이 사용 사례에서 FIFO 의미를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="83af529ff0234ebb19ae9fc92954913ed20af976" translate="yes" xml:space="preserve">
          <source>Both &lt;code&gt;start&lt;/code&gt; and &lt;code&gt;stop&lt;/code&gt; are zero-based indexes, where &lt;code&gt;0&lt;/code&gt; is the first element, &lt;code&gt;1&lt;/code&gt; is the next element and so on. They can also be negative numbers indicating offsets from the end of the sorted set, with &lt;code&gt;-1&lt;/code&gt; being the last element of the sorted set, &lt;code&gt;-2&lt;/code&gt; the penultimate element and so on.</source>
          <target state="translated">모두 &lt;code&gt;start&lt;/code&gt; 및 &lt;code&gt;stop&lt;/code&gt; 위치를 0부터 인덱스입니다 &lt;code&gt;0&lt;/code&gt; , 첫 번째 요소입니다 &lt;code&gt;1&lt;/code&gt; 다음 요소 등이다. &lt;code&gt;-1&lt;/code&gt; 은 정렬 된 세트 의 마지막 요소, &lt;code&gt;-2&lt;/code&gt; 는 두 번째 요소 등과 같이 정렬 된 세트의 끝에서 오프셋을 나타내는 음수 일 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="23a10624171d72fb4e9f07612b39ccbc04699493" translate="yes" xml:space="preserve">
          <source>Both commands were introduced in Redis 3.2.10 and Redis 4.0.0 respectively.</source>
          <target state="translated">두 명령은 각각 Redis 3.2.10 및 Redis 4.0.0에서 도입되었습니다.</target>
        </trans-unit>
        <trans-unit id="3146bb227c4234d6267f94725155f23545044b63" translate="yes" xml:space="preserve">
          <source>Both quantities are 64-bit numbers. When an ID is auto-generated, the first part is the Unix time in milliseconds of the Redis instance generating the ID. The second part is just a sequence number and is used in order to distinguish IDs generated in the same millisecond.</source>
          <target state="translated">두 수량 모두 64 비트 숫자입니다. ID가 자동 생성 될 때 첫 번째 부분은 ID를 생성하는 Redis 인스턴스의 Unix 시간 (밀리 초)입니다. 두 번째 부분은 시퀀스 번호 일 뿐이며 동일한 밀리 초 내에 생성 된 ID를 구별하기 위해 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="4a1f2ae398c91bf9d6a2b34bf5c23ed87585d341" translate="yes" xml:space="preserve">
          <source>Both representations are prefixed with a 16 bytes header, that includes a magic, an encoding / version field, and the cached cardinality estimation computed, stored in little endian format (the most significant bit is 1 if the estimation is invalid since the HyperLogLog was updated since the cardinality was computed).</source>
          <target state="translated">두 표현 모두 16 바이트 헤더가 접두어로 붙습니다. 여기에는 마술, 인코딩 / 버전 필드 및 캐시 된 카디널리티 추정이 포함되어 리틀 엔디안 형식으로 저장됩니다 (HyperLogLog가 업데이트 된 이후 추정이 유효하지 않은 경우 가장 중요한 비트는 1 임) 카디널리티가 계산 된 이후).</target>
        </trans-unit>
        <trans-unit id="c7a36cc87678ec27033bceb0e99f2d1deac9e434" translate="yes" xml:space="preserve">
          <source>Both the value already contained in the string key and the increment argument can be optionally provided in exponential notation, however the value computed after the increment is stored consistently in the same format, that is, an integer number followed (if needed) by a dot, and a variable number of digits representing the decimal part of the number. Trailing zeroes are always removed.</source>
          <target state="translated">문자열 키에 이미 포함 된 값과 증가 인수는 선택적으로 지수 표기법으로 제공 될 수 있지만, 증가 후 계산 된 값은 동일한 형식, 즉 정수가 뒤에 오는 정수 (점수) 뒤에 일관되게 저장됩니다. 및 숫자의 소수 부분을 나타내는 가변 자릿수입니다. 후행 0은 항상 제거됩니다.</target>
        </trans-unit>
        <trans-unit id="046892586ee04199d779966b3fd711b935a2c4ee" translate="yes" xml:space="preserve">
          <source>Breaking the compatibility with the past was considered but rejected, at least for Redis 4.0, so instead two read only variants of the commands were added. They are exactly like the original commands but refuse the &lt;code&gt;STORE&lt;/code&gt; and &lt;code&gt;STOREDIST&lt;/code&gt; options. The two variants are called &lt;code&gt;GEORADIUS_RO&lt;/code&gt; and &lt;code&gt;GEORADIUSBYMEMBER_RO&lt;/code&gt;, and can safely be used in replicas.</source>
          <target state="translated">적어도 Redis 4.0에서는 과거와의 호환성을 깨는 것이 고려되었지만 거부되었으므로 대신 두 가지 읽기 전용 명령이 추가되었습니다. 이들은 원래 명령과 동일하지만 &lt;code&gt;STORE&lt;/code&gt; 및 &lt;code&gt;STOREDIST&lt;/code&gt; 옵션을 거부합니다 . 두 가지 변형을 &lt;code&gt;GEORADIUS_RO&lt;/code&gt; 및 &lt;code&gt;GEORADIUSBYMEMBER_RO&lt;/code&gt; 라고 하며 복제본에서 안전하게 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="11d2a59be0a7424e67e9c632e3f055f99238638f" translate="yes" xml:space="preserve">
          <source>Bulk string reply</source>
          <target state="translated">대량 문자열 회신</target>
        </trans-unit>
        <trans-unit id="3e53e1d484c0afdd9ee478c43d641e56563db80a" translate="yes" xml:space="preserve">
          <source>But in the above case the output would be the same, since we have pending messages only for a single consumer. However what is important to keep in mind is that this operation, filtering by a specific consumer, is not inefficient even when there are many pending messages from many consumers: we have a pending entries list data structure both globally, and for every consumer, so we can very efficiently show just messages pending for a single consumer.</source>
          <target state="translated">그러나 위의 경우 단일 소비자에 대해서만 보류중인 메시지가 있기 때문에 출력은 동일합니다. 그러나 명심해야 할 중요한 점은 특정 소비자에 의해 필터링되는이 작업은 많은 소비자로부터 보류중인 메시지가 많은 경우에도 비효율적이지 않다는 것입니다. 전 세계 및 모든 소비자에 대해 보류중인 항목 목록 데이터 구조가 있으므로 단일 소비자에게 보류중인 메시지 만 매우 효율적으로 표시 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5c8217506d8ebbaa0e107de581511ee5f509b818" translate="yes" xml:space="preserve">
          <source>By default all the bytes contained in the string are examined. It is possible to specify the counting operation only in an interval passing the additional arguments &lt;em&gt;start&lt;/em&gt; and &lt;em&gt;end&lt;/em&gt;.</source>
          <target state="translated">기본적으로 문자열에 포함 된 모든 바이트가 검사됩니다. 추가 인수 &lt;em&gt;start&lt;/em&gt; 및 &lt;em&gt;end를&lt;/em&gt; 전달하는 간격으로 만 계산 작업을 지정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="9e9840a0fb9a28f465bc984e84fdef1e46818881" translate="yes" xml:space="preserve">
          <source>By default all the matching items are returned. It is possible to limit the results to the first N matching items by using the &lt;strong&gt;COUNT &lt;code&gt;&amp;lt;count&amp;gt;&lt;/code&gt;&lt;/strong&gt; option. However note that internally the command needs to perform an effort proportional to the number of items matching the specified area, so to query very large areas with a very small &lt;code&gt;COUNT&lt;/code&gt; option may be slow even if just a few results are returned. On the other hand &lt;code&gt;COUNT&lt;/code&gt; can be a very effective way to reduce bandwidth usage if normally just the first results are used.</source>
          <target state="translated">기본적으로 모든 일치하는 항목이 반환됩니다. &lt;strong&gt;COUNT &lt;code&gt;&amp;lt;count&amp;gt;&lt;/code&gt; &lt;/strong&gt; 옵션 을 사용하여 결과를 첫 번째 N 개의 일치하는 항목으로 제한 할 &lt;strong&gt;수&lt;/strong&gt; 있습니다. 그러나 내부적으로 명령은 지정된 영역과 일치하는 항목 수에 비례하여 노력을 수행해야하므로 매우 적은 수의 &lt;code&gt;COUNT&lt;/code&gt; 옵션으로 매우 큰 영역을 쿼리 하면 몇 가지 결과 만 반환 되더라도 속도가 느려질 수 있습니다. 반면에 &lt;code&gt;COUNT&lt;/code&gt; 는 일반적으로 첫 번째 결과 만 사용되는 경우 대역폭 사용량을 줄이는 매우 효과적인 방법입니다.</target>
        </trans-unit>
        <trans-unit id="1f9b368afa2761dde4363a1630f17429f8bc58b2" translate="yes" xml:space="preserve">
          <source>By default the client is unblocked as if the timeout of the command was reached, however if an additional (and optional) argument is passed, it is possible to specify the unblocking behavior, that can be &lt;strong&gt;TIMEOUT&lt;/strong&gt; (the default) or &lt;strong&gt;ERROR&lt;/strong&gt;. If &lt;strong&gt;ERROR&lt;/strong&gt; is specified, the behavior is to unblock the client returning as error the fact that the client was force-unblocked. Specifically the client will receive the following error:</source>
          <target state="translated">기본적으로 클라이언트는 명령의 시간 종료에 도달 한 것처럼 차단이 해제되지만 추가 (및 선택적) 인수가 전달되면 차단 해제 동작을 지정할 수 있습니다. &lt;strong&gt;TIMEOUT&lt;/strong&gt; (기본값) 또는 &lt;strong&gt;ERROR 일 수&lt;/strong&gt; 있습니다. 경우 &lt;strong&gt;오류가&lt;/strong&gt; 지정되면, 동작 오류로 클라이언트가 강제 차단 해제 있다는 사실을 반환 클라이언트를 차단하는 것입니다. 특히 클라이언트는 다음 오류를 수신합니다.</target>
        </trans-unit>
        <trans-unit id="91bf3b958012756b0a4a417df15abcf41ceea42c" translate="yes" xml:space="preserve">
          <source>By default the scripting engine is always set to &lt;code&gt;REPL_ALL&lt;/code&gt;. By calling this function the user can switch on/off AOF and or replicas propagation, and turn them back later at her/his wish.</source>
          <target state="translated">기본적으로 스크립팅 엔진은 항상 &lt;code&gt;REPL_ALL&lt;/code&gt; 로 설정됩니다 . 이 기능을 호출하면 사용자가 AOF 및 / 또는 복제본 전파를 켜거나 끄고 나중에 원하는대로 다시 되돌릴 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d3714f33148cc538954cff3b58af732446c5cd76" translate="yes" xml:space="preserve">
          <source>By default, &lt;a href=&quot;sort&quot;&gt;SORT&lt;/a&gt; returns the sorted elements to the client. With the &lt;code&gt;STORE&lt;/code&gt; option, the result will be stored as a list at the specified key instead of being returned to the client.</source>
          <target state="translated">기본적으로 &lt;a href=&quot;sort&quot;&gt;SORT&lt;/a&gt; 는 정렬 된 요소를 클라이언트에 반환합니다. 으로 &lt;code&gt;STORE&lt;/code&gt; 옵션, 결과 대신 클라이언트로 반환되는 지정된 키에 목록으로 저장됩니다.</target>
        </trans-unit>
        <trans-unit id="2ee8f070e37dc92ade46a57ac677a11708d8c9aa" translate="yes" xml:space="preserve">
          <source>By default, &lt;strong&gt;WRAP&lt;/strong&gt; is used if not otherwise specified.</source>
          <target state="translated">달리 지정되지 않은 경우 기본적으로 &lt;strong&gt;WRAP&lt;/strong&gt; 이 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="f7b1d35e79bbf2da51d0b5f48b7d7d355bd0c2fd" translate="yes" xml:space="preserve">
          <source>By default, all the bytes contained in the string are examined. It is possible to look for bits only in a specified interval passing the additional arguments &lt;em&gt;start&lt;/em&gt; and &lt;em&gt;end&lt;/em&gt; (it is possible to just pass &lt;em&gt;start&lt;/em&gt;, the operation will assume that the end is the last byte of the string. However there are semantic differences as explained later). The range is interpreted as a range of bytes and not a range of bits, so &lt;code&gt;start=0&lt;/code&gt; and &lt;code&gt;end=2&lt;/code&gt; means to look at the first three bytes.</source>
          <target state="translated">기본적으로 문자열에 포함 된 모든 바이트가 검사됩니다. 추가 인수 &lt;em&gt;start&lt;/em&gt; 및 &lt;em&gt;end를&lt;/em&gt; 전달하는 지정된 간격에서만 비트를 찾을 수 있습니다 ( &lt;em&gt;start&lt;/em&gt; 만 전달하는 것이 가능 합니다. 조작은 end가 문자열의 마지막 바이트라고 가정하지만 설명에 따라 의미상의 차이가 있습니다. 나중). 범위는 비트 범위가 아닌 바이트 범위로 해석되므로 &lt;code&gt;start=0&lt;/code&gt; 및 &lt;code&gt;end=2&lt;/code&gt; 는 처음 3 바이트를 보는 것을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="5529ebf0aa9355a448e5873d36ba97d16befd8bf" translate="yes" xml:space="preserve">
          <source>By default, the interval specified by &lt;code&gt;min&lt;/code&gt; and &lt;code&gt;max&lt;/code&gt; is closed (inclusive). It is possible to specify an open interval (exclusive) by prefixing the score with the character &lt;code&gt;(&lt;/code&gt;. For example:</source>
          <target state="translated">기본적으로 &lt;code&gt;min&lt;/code&gt; 및 &lt;code&gt;max&lt;/code&gt; 로 지정된 간격 은 닫힙니다 (포함). 점수 앞에 문자 &lt;code&gt;(&lt;/code&gt; )를 붙여서 열린 간격 (제외)을 지정할 수 있습니다 ( 예 :</target>
        </trans-unit>
        <trans-unit id="b8a1843f4f52d23022ae70457e87a2bbc0c8ed29" translate="yes" xml:space="preserve">
          <source>By default, the resulting score of an element is the sum of its scores in the sorted sets where it exists.</source>
          <target state="translated">기본적으로 요소의 결과 점수는 해당 요소가있는 정렬 된 세트의 점수 합계입니다.</target>
        </trans-unit>
        <trans-unit id="4665873e5c58037455475bf4706b458811098286" translate="yes" xml:space="preserve">
          <source>By default, the resulting score of an element is the sum of its scores in the sorted sets where it exists. Because intersection requires an element to be a member of every given sorted set, this results in the score of every element in the resulting sorted set to be equal to the number of input sorted sets.</source>
          <target state="translated">기본적으로 요소의 결과 점수는 해당 요소가있는 정렬 된 세트의 점수 합계입니다. 교차는 요소가 주어진 모든 정렬 된 세트의 구성원이어야하므로 결과 정렬 된 세트의 모든 요소의 점수는 입력 정렬 된 세트의 수와 같습니다.</target>
        </trans-unit>
        <trans-unit id="855731f4a53411098556da94791141678c87de9e" translate="yes" xml:space="preserve">
          <source>C1 and C2 read &lt;code&gt;lock.foo&lt;/code&gt; to check the timestamp, because they both received &lt;code&gt;0&lt;/code&gt; after executing &lt;a href=&quot;setnx&quot;&gt;SETNX&lt;/a&gt;, as the lock is still held by C3 that crashed after holding the lock.</source>
          <target state="translated">C1 및 C2는 &lt;code&gt;lock.foo&lt;/code&gt; 를 읽고 시간 소인을 확인합니다. SETNX 를 실행 한 후 잠금을 유지 한 후에 C3에 의해 잠금이 여전히 유지되어 있기 때문에 둘 다 &lt;a href=&quot;setnx&quot;&gt;SETNX&lt;/a&gt; 를 실행 한 후 &lt;code&gt;0&lt;/code&gt; 을 수신했기 때문 입니다.</target>
        </trans-unit>
        <trans-unit id="2d7ad86157ffa8a81154afc21adf4e9506f4075d" translate="yes" xml:space="preserve">
          <source>C1 sends &lt;code&gt;DEL lock.foo&lt;/code&gt;</source>
          <target state="translated">C1은 &lt;code&gt;DEL lock.foo&lt;/code&gt; 보냅니다 .foo</target>
        </trans-unit>
        <trans-unit id="59e76a6cffa5164edb0398cd905358d159247029" translate="yes" xml:space="preserve">
          <source>C1 sends &lt;code&gt;SETNX lock.foo&lt;/code&gt; and it succeeds</source>
          <target state="translated">C1이 &lt;code&gt;SETNX lock.foo&lt;/code&gt; 를 보내면 성공</target>
        </trans-unit>
        <trans-unit id="4f7c62ca261230ba7bd6b9233369caaf27e7f01d" translate="yes" xml:space="preserve">
          <source>C2 sends &lt;code&gt;DEL lock.foo&lt;/code&gt;</source>
          <target state="translated">C2는 &lt;code&gt;DEL lock.foo&lt;/code&gt; 를 보냅니다.</target>
        </trans-unit>
        <trans-unit id="193179deba47ad9e120a60484e3cc95253ac5a6a" translate="yes" xml:space="preserve">
          <source>C2 sends &lt;code&gt;SETNX lock.foo&lt;/code&gt; and it succeeds</source>
          <target state="translated">C2가 &lt;code&gt;SETNX lock.foo&lt;/code&gt; 를 보내면 성공</target>
        </trans-unit>
        <trans-unit id="151ee6de467b9561ff1e9f5ec7724e1aafaaa74e" translate="yes" xml:space="preserve">
          <source>C4 sends &lt;code&gt;GET lock.foo&lt;/code&gt; to check if the lock expired. If it is not, it will sleep for some time and retry from the start.</source>
          <target state="translated">C4는 잠금이 만료되었는지 확인하기 위해 &lt;code&gt;GET lock.foo&lt;/code&gt; 를 보냅니다 . 그렇지 않으면 일정 시간 동안 잠을 자고 처음부터 다시 시도합니다.</target>
        </trans-unit>
        <trans-unit id="80d7499d35c9d242f43ac8ad8f3d435904ce4b07" translate="yes" xml:space="preserve">
          <source>C4 sends &lt;code&gt;SETNX lock.foo&lt;/code&gt; in order to acquire the lock</source>
          <target state="translated">C4는 잠금을 획득하기 위해 &lt;code&gt;SETNX lock.foo&lt;/code&gt; 를 보냅니다.</target>
        </trans-unit>
        <trans-unit id="810aa98e90b76fd25ebaacd1fecaebbe5cca1fd8" translate="yes" xml:space="preserve">
          <source>CJSON</source>
          <target state="translated">CJSON</target>
        </trans-unit>
        <trans-unit id="289fd6dd86c78fc18484670bd5337ffc1457b23f" translate="yes" xml:space="preserve">
          <source>CLIENT</source>
          <target state="translated">CLIENT</target>
        </trans-unit>
        <trans-unit id="9a086feff67c072f67169a1a10544440c06a27bb" translate="yes" xml:space="preserve">
          <source>CLIENT GETNAME   Get the current connection name</source>
          <target state="translated">클라이언트 GETNAME 현재 연결 이름을 가져옵니다</target>
        </trans-unit>
        <trans-unit id="1f043bd4293df18cf326994e345f63d6a607a715" translate="yes" xml:space="preserve">
          <source>CLIENT ID   Returns the client ID for the current connection</source>
          <target state="translated">CLIENT ID 현재 연결에 대한 클라이언트 ID를 반환합니다</target>
        </trans-unit>
        <trans-unit id="a606744e377765ead3bebe7af7be75bec984bac6" translate="yes" xml:space="preserve">
          <source>CLIENT KILL  [ip:port] [ID client-id] [TYPE normal|master|slave|pubsub] [ADDR ip:port] [SKIPME yes/no]   Kill the connection of a client</source>
          <target state="translated">클라이언트 킬 [ip : port] [ID client-id] [TYPE normal | master | slave | pubsub] [ADDR ip : port] [SKIPME yes / no] 클라이언트 연결 끊기</target>
        </trans-unit>
        <trans-unit id="40f78df8d4251b437ca6d0591e3d79df9db9a668" translate="yes" xml:space="preserve">
          <source>CLIENT KILL and Redis Sentinel</source>
          <target state="translated">클라이언트 킬과 Redis Sentinel</target>
        </trans-unit>
        <trans-unit id="5abdfb863c66ad1708626a5caaaa3f3ae356f31e" translate="yes" xml:space="preserve">
          <source>CLIENT LIST  [TYPE normal|master|replica|pubsub]   Get the list of client connections</source>
          <target state="translated">클라이언트 목록 [TYPE normal | master | replica | pubsub] 클라이언트 연결 목록 가져 오기</target>
        </trans-unit>
        <trans-unit id="cdde82d80a6c631c41a96bc80027350e01ff9d66" translate="yes" xml:space="preserve">
          <source>CLIENT PAUSE  timeout   Stop processing commands from clients for some time</source>
          <target state="translated">CLIENT PAUSE timeout 클라이언트에서 명령 처리를 중지합니다.</target>
        </trans-unit>
        <trans-unit id="cdc920d32af4c13e5383224eaafad4a5e97a22e0" translate="yes" xml:space="preserve">
          <source>CLIENT REPLY  ON|OFF|SKIP   Instruct the server whether to reply to commands</source>
          <target state="translated">CLIP REPLY ON | OFF | SKIP 명령에 응답할지 서버에 지시합니다</target>
        </trans-unit>
        <trans-unit id="5de18cdee05387ac2edf2c59d640ef325da93c25" translate="yes" xml:space="preserve">
          <source>CLIENT SETNAME  connection-name   Set the current connection name</source>
          <target state="translated">CLIENT SETNAME connection-name 현재 연결 이름을 설정하십시오</target>
        </trans-unit>
        <trans-unit id="326b6f4d4510070631ac4ab9eaf85a825c42c2a7" translate="yes" xml:space="preserve">
          <source>CLIENT UNBLOCK  client-id [TIMEOUT|ERROR]   Unblock a client blocked in a blocking command from a different connection</source>
          <target state="translated">클라이언트 클라이언트 차단 해제 클라이언트 ID [TIMEOUT | ERROR] 다른 연결에서 차단 명령으로 차단 된 클라이언트 차단 해제</target>
        </trans-unit>
        <trans-unit id="e3b9b52696ca51803a72a1787b8689b560877e3b" translate="yes" xml:space="preserve">
          <source>CLUSTER</source>
          <target state="translated">CLUSTER</target>
        </trans-unit>
        <trans-unit id="89c0d390cdc52475692a036944dfe3e1af10aa52" translate="yes" xml:space="preserve">
          <source>CLUSTER ADDSLOTS  slot [slot ...]   Assign new hash slots to receiving node</source>
          <target state="translated">CLUSTER ADDSLOTS slot [slot ...] 수신 노드에 새 해시 슬롯 할당</target>
        </trans-unit>
        <trans-unit id="fc6a3f907637996a1389e46617de4c73581acb5f" translate="yes" xml:space="preserve">
          <source>CLUSTER COUNT-FAILURE-REPORTS  node-id   Return the number of failure reports active for a given node</source>
          <target state="translated">CLUSTER COUNT-FAILURE-REPORTS node-id 주어진 노드에 대해 활성화 된 실패 보고서 수를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="8de0ad0623c7725bc7b50d19dfafe919652d9ddd" translate="yes" xml:space="preserve">
          <source>CLUSTER COUNTKEYSINSLOT  slot   Return the number of local keys in the specified hash slot</source>
          <target state="translated">CLUSTER COUNTKEYSINSLOT slot 지정된 해시 슬롯의 로컬 키 수를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="a291825c5518befaa628dbca584ac74adfdd3dc0" translate="yes" xml:space="preserve">
          <source>CLUSTER DELSLOTS  slot [slot ...]   Set hash slots as unbound in receiving node</source>
          <target state="translated">CLUSTER DELSLOTS slot [slot ...] 수신 노드에서 해시 슬롯을 언 바운드로 설정</target>
        </trans-unit>
        <trans-unit id="9b2690b6fa91e96bd2f73d5972dcb19de160e151" translate="yes" xml:space="preserve">
          <source>CLUSTER FAILOVER  [FORCE|TAKEOVER]   Forces a replica to perform a manual failover of its master.</source>
          <target state="translated">CLUSTER FAILOVER [FORCE | TAKEOVER] 복제본이 마스터의 수동 장애 조치를 수행하도록합니다.</target>
        </trans-unit>
        <trans-unit id="e739c9ee11fd419a688da991d447a266021c6ef0" translate="yes" xml:space="preserve">
          <source>CLUSTER FORGET  node-id   Remove a node from the nodes table</source>
          <target state="translated">CLUSTER FORGET node-id 노드 테이블에서 노드를 제거합니다</target>
        </trans-unit>
        <trans-unit id="63b393dc8cc3734128967f68eb934005c0c5a24f" translate="yes" xml:space="preserve">
          <source>CLUSTER GETKEYSINSLOT  slot count   Return local key names in the specified hash slot</source>
          <target state="translated">CLUSTER GETKEYSINSLOT 슬롯 수 지정된 해시 슬롯에서 로컬 키 이름을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="96ff44fb1ff41b2047e38a9dd4b9b91ab3a48e50" translate="yes" xml:space="preserve">
          <source>CLUSTER INFO   Provides info about Redis Cluster node state</source>
          <target state="translated">CLUSTER INFO Redis 클러스터 노드 상태에 대한 정보를 제공합니다</target>
        </trans-unit>
        <trans-unit id="bceb7d0f89d15cad163cf00743841fee0d54ad57" translate="yes" xml:space="preserve">
          <source>CLUSTER KEYSLOT  key   Returns the hash slot of the specified key</source>
          <target state="translated">CLUSTER KEYSLOT 키 지정된 키의 해시 슬롯을 반환합니다</target>
        </trans-unit>
        <trans-unit id="db6dfe9195f872c1e24e77eca06229e51f545369" translate="yes" xml:space="preserve">
          <source>CLUSTER MEET  ip port   Force a node cluster to handshake with another node</source>
          <target state="translated">CLUSTER MEET ip port 노드 클러스터가 다른 노드와 핸드 셰이크하도록 강제합니다.</target>
        </trans-unit>
        <trans-unit id="45bb4b8fb75be9f6506f8df1b5feecc8fcb42818" translate="yes" xml:space="preserve">
          <source>CLUSTER NODES   Get Cluster config for the node</source>
          <target state="translated">클러스터 노드 노드에 대한 클러스터 구성 가져 오기</target>
        </trans-unit>
        <trans-unit id="cb1b81c97abbdb844bd68109bd5c641a604ec477" translate="yes" xml:space="preserve">
          <source>CLUSTER REPLICAS  node-id   List replica nodes of the specified master node</source>
          <target state="translated">CLUSTER REPLICAS node-id 지정된 마스터 노드의 복제본 노드를 나열합니다.</target>
        </trans-unit>
        <trans-unit id="0c1d4ab714df1ed96b53ecea55f9b15118926ddd" translate="yes" xml:space="preserve">
          <source>CLUSTER REPLICATE  node-id   Reconfigure a node as a replica of the specified master node</source>
          <target state="translated">CLUSTER REPLICATE node-id 노드를 지정된 마스터 노드의 복제본으로 재구성</target>
        </trans-unit>
        <trans-unit id="fdd669bf0a4695d61100d82b95672d6f0265fa98" translate="yes" xml:space="preserve">
          <source>CLUSTER RESET  [HARD|SOFT]   Reset a Redis Cluster node</source>
          <target state="translated">클러스터 재설정 [HARD | SOFT] Redis 클러스터 노드 재설정</target>
        </trans-unit>
        <trans-unit id="4452e5582d47e8dfe0990f92ac43fa0dcf4415d8" translate="yes" xml:space="preserve">
          <source>CLUSTER SAVECONFIG   Forces the node to save cluster state on disk</source>
          <target state="translated">CLUSTER SAVECONFIG 노드가 디스크에 클러스터 상태를 저장하게합니다.</target>
        </trans-unit>
        <trans-unit id="0352d198b3e3c3480eec41371b3ead5bc1188b13" translate="yes" xml:space="preserve">
          <source>CLUSTER SET-CONFIG-EPOCH  config-epoch   Set the configuration epoch in a new node</source>
          <target state="translated">CLUSTER SET-CONFIG-EPOCH config-epoch 새 노드에서 구성 에포크 설정</target>
        </trans-unit>
        <trans-unit id="717b30894068edcc566f30c183079158fcd2ebb3" translate="yes" xml:space="preserve">
          <source>CLUSTER SETSLOT  slot IMPORTING|MIGRATING|STABLE|NODE [node-id]   Bind a hash slot to a specific node</source>
          <target state="translated">CLUSTER SETSLOT 슬롯 가져 오기 | 마이 그레이팅 | 안정성 | 노드 [node-id] 특정 노드에 해시 슬롯 바인딩</target>
        </trans-unit>
        <trans-unit id="6998d43f245cd331b3038d9db49ce51e5fbe657b" translate="yes" xml:space="preserve">
          <source>CLUSTER SETSLOT &lt;code&gt;&amp;lt;slot&amp;gt;&lt;/code&gt; IMPORTING &lt;code&gt;&amp;lt;source-node-id&amp;gt;&lt;/code&gt;</source>
          <target state="translated">클러스터 SETSLOT &lt;code&gt;&amp;lt;slot&amp;gt;&lt;/code&gt; 가져 오기 &lt;code&gt;&amp;lt;source-node-id&amp;gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="df0cda76712dac386672dd77ffb08df9386d4ded" translate="yes" xml:space="preserve">
          <source>CLUSTER SETSLOT &lt;code&gt;&amp;lt;slot&amp;gt;&lt;/code&gt; MIGRATING &lt;code&gt;&amp;lt;destination-node-id&amp;gt;&lt;/code&gt;</source>
          <target state="translated">클러스터 SETSLOT &lt;code&gt;&amp;lt;slot&amp;gt;&lt;/code&gt; 마이그레이션 &lt;code&gt;&amp;lt;destination-node-id&amp;gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="e87c55a08cdeb007d9466cda6f41bd3aa8b0b08f" translate="yes" xml:space="preserve">
          <source>CLUSTER SETSLOT &lt;code&gt;&amp;lt;slot&amp;gt;&lt;/code&gt; NODE &lt;code&gt;&amp;lt;node-id&amp;gt;&lt;/code&gt;</source>
          <target state="translated">클러스터 SETSLOT &lt;code&gt;&amp;lt;slot&amp;gt;&lt;/code&gt; 노드 &lt;code&gt;&amp;lt;node-id&amp;gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="8050d05e7c830b724efadb1fb19908cbba0c3b12" translate="yes" xml:space="preserve">
          <source>CLUSTER SETSLOT &lt;code&gt;&amp;lt;slot&amp;gt;&lt;/code&gt; STABLE</source>
          <target state="translated">클러스터 셋 &lt;code&gt;&amp;lt;slot&amp;gt;&lt;/code&gt; 안정</target>
        </trans-unit>
        <trans-unit id="87d7c95e3334e2c65e594f6606b11d6fa033b8e3" translate="yes" xml:space="preserve">
          <source>CLUSTER SLAVES  node-id   List replica nodes of the specified master node</source>
          <target state="translated">CLUSTER SLAVES node-id 지정된 마스터 노드의 복제본 노드를 나열합니다.</target>
        </trans-unit>
        <trans-unit id="0b83235580afb6dcdbb5aaae9069030836332846" translate="yes" xml:space="preserve">
          <source>CLUSTER SLOTS   Get array of Cluster slot to node mappings</source>
          <target state="translated">클러스터 슬롯 클러스터 슬롯의 노드 매핑을 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="2e4854d8dd31ab3a1bd0bbce1a9b8c73da88c413" translate="yes" xml:space="preserve">
          <source>COMMAND</source>
          <target state="translated">COMMAND</target>
        </trans-unit>
        <trans-unit id="5d475d3ae2a090a5dd4fb9bcb4834f2b0f5e8e36" translate="yes" xml:space="preserve">
          <source>COMMAND   Get array of Redis command details</source>
          <target state="translated">명령 Redis 명령 세부 사항 배열 가져 오기</target>
        </trans-unit>
        <trans-unit id="243f2ac950baaf718523fe42c2f35baa4d002daa" translate="yes" xml:space="preserve">
          <source>COMMAND COUNT   Get total number of Redis commands</source>
          <target state="translated">명령 수 총 Redis 명령 수 얻기</target>
        </trans-unit>
        <trans-unit id="b5c43f716c4692946b372734d13302625935ddef" translate="yes" xml:space="preserve">
          <source>COMMAND GETKEYS   Extract keys given a full Redis command</source>
          <target state="translated">명령 키 전체 Redis 명령이 제공된 키 추출</target>
        </trans-unit>
        <trans-unit id="e4f0ee016bdc14d304548515037906095d7beb51" translate="yes" xml:space="preserve">
          <source>COMMAND INFO  command-name [command-name ...]   Get array of specific Redis command details</source>
          <target state="translated">명령 정보 command-name [command-name ...] 특정 Redis 명령 세부 정보의 배열을 가져옵니다</target>
        </trans-unit>
        <trans-unit id="2fb60054b43a25d7a958d3d19bdb1aa7809577a8" translate="yes" xml:space="preserve">
          <source>CONFIG</source>
          <target state="translated">CONFIG</target>
        </trans-unit>
        <trans-unit id="d3f495884e312ef94089cef1025f98afac649a7f" translate="yes" xml:space="preserve">
          <source>CONFIG GET  parameter   Get the value of a configuration parameter</source>
          <target state="translated">CONFIG GET 매개 변수 구성 매개 변수의 값을 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="d6c004f361be600273602c08f69569c9b929d35b" translate="yes" xml:space="preserve">
          <source>CONFIG RESETSTAT   Reset the stats returned by INFO</source>
          <target state="translated">CONFIG RESETSTAT INFO에 의해 반환 된 통계를 재설정합니다</target>
        </trans-unit>
        <trans-unit id="07fd8b85f66f97280cb2ad55982da60cacbe7682" translate="yes" xml:space="preserve">
          <source>CONFIG REWRITE   Rewrite the configuration file with the in memory configuration</source>
          <target state="translated">CONFIG REWRITE 메모리 구성으로 구성 파일을 다시 씁니다.</target>
        </trans-unit>
        <trans-unit id="d27538b14c1ebc5ce34011e7bb5ef99fff52c53d" translate="yes" xml:space="preserve">
          <source>CONFIG REWRITE is also able to rewrite the configuration file from scratch if the original one no longer exists for some reason. However if the server was started without a configuration file at all, the CONFIG REWRITE will just return an error.</source>
          <target state="translated">CONFIG REWRITE는 어떤 이유로 인해 원래 파일이 더 이상 존재하지 않으면 구성 파일을 처음부터 다시 작성할 수 있습니다. 그러나 서버가 구성 파일없이 시작된 경우 CONFIG REWRITE는 오류를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="bcdc354e91b58a18cc7f424a767e01c256e6b42b" translate="yes" xml:space="preserve">
          <source>CONFIG SET  parameter value   Set a configuration parameter to the given value</source>
          <target state="translated">CONFIG SET 매개 변수 값 구성 매개 변수를 주어진 값으로 설정</target>
        </trans-unit>
        <trans-unit id="5ba6c24ce4497d078be48b670ad16cc43d57f929" translate="yes" xml:space="preserve">
          <source>Calling &lt;a href=&quot;scan&quot;&gt;SCAN&lt;/a&gt; with a broken, negative, out of range, or otherwise invalid cursor, will result into undefined behavior but never into a crash. What will be undefined is that the guarantees about the returned elements can no longer be ensured by the &lt;a href=&quot;scan&quot;&gt;SCAN&lt;/a&gt; implementation.</source>
          <target state="translated">파손, 음수, 범위를 벗어나거나 유효하지 않은 커서로 &lt;a href=&quot;scan&quot;&gt;SCAN&lt;/a&gt; 을 호출 하면 정의되지 않은 동작이 발생하지만 결코 충돌하지는 않습니다. 정의되지 않은 것은 &lt;a href=&quot;scan&quot;&gt;SCAN&lt;/a&gt; 구현을 통해 반환 된 요소에 대한 보장을 더 이상 보장 할 수 없다는 것입니다.</target>
        </trans-unit>
        <trans-unit id="5f46be6632e20880fa3190f308734a7c2debc935" translate="yes" xml:space="preserve">
          <source>Calling SCAN with a corrupted cursor</source>
          <target state="translated">손상된 커서로 SCAN 호출</target>
        </trans-unit>
        <trans-unit id="1e0b7fe9d077c2aa9a5144f650dffdcf03fa241c" translate="yes" xml:space="preserve">
          <source>Capped streams</source>
          <target state="translated">캡핑 된 스트림</target>
        </trans-unit>
        <trans-unit id="677509e3c92011eb7431eb950f99423de593897c" translate="yes" xml:space="preserve">
          <source>Care should be taken when executing &lt;a href=&quot;evalsha&quot;&gt;EVALSHA&lt;/a&gt; in the context of a pipelined request, since even in a pipeline the order of execution of commands must be guaranteed. If &lt;a href=&quot;evalsha&quot;&gt;EVALSHA&lt;/a&gt; will return a &lt;code&gt;NOSCRIPT&lt;/code&gt; error the command can not be reissued later otherwise the order of execution is violated.</source>
          <target state="translated">파이프 라인 된 요청 컨텍스트에서 &lt;a href=&quot;evalsha&quot;&gt;EVALSHA&lt;/a&gt; 를 실행할 때는주의를 기울여야합니다 . 파이프 라인에서도 명령 실행 순서가 보장되어야하기 때문입니다. 경우 &lt;a href=&quot;evalsha&quot;&gt;EVALSHA는&lt;/a&gt; 반환하며 &lt;code&gt;NOSCRIPT&lt;/code&gt; 의 명령이 나중에 다른 실행 순서가 위반 재발행 할 수없는 오류가 발생했습니다.</target>
        </trans-unit>
        <trans-unit id="8eaf1e254fa69f8ab1d24e1e39a78203c7080474" translate="yes" xml:space="preserve">
          <source>Client IP address and port (4.0 only).</source>
          <target state="translated">클라이언트 IP 주소 및 포트 (4.0 만 해당).</target>
        </trans-unit>
        <trans-unit id="5cf75075a191bc11d161c66570997946e05f966f" translate="yes" xml:space="preserve">
          <source>Client libraries may use Redis in order to test their own hashing algorithm, generating random keys and hashing them with both their local implementation and using Redis &lt;a href=&quot;cluster-keyslot&quot;&gt;CLUSTER KEYSLOT&lt;/a&gt; command, then checking if the result is the same.</source>
          <target state="translated">클라이언트 라이브러리는 자체 해싱 알고리즘을 테스트하고 임의의 키를 생성하고 로컬 구현과 Redis &lt;a href=&quot;cluster-keyslot&quot;&gt;CLUSTER KEYSLOT&lt;/a&gt; 명령을 사용하여 해싱 한 다음 결과가 동일한 지 확인 하기 위해 Redis를 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="5993bbb849b531146b7a95269c1882c6ff8a9ed3" translate="yes" xml:space="preserve">
          <source>Client name if set via the &lt;a href=&quot;client-setname&quot;&gt;CLIENT SETNAME&lt;/a&gt; command (4.0 only).</source>
          <target state="translated">&lt;a href=&quot;client-setname&quot;&gt;CLIENT SETNAME&lt;/a&gt; 명령을 통해 설정된 클라이언트 이름 (4.0 만 해당).</target>
        </trans-unit>
        <trans-unit id="d75dc68bbdd56c9cbd58d4bbdabda84bcca2c47f" translate="yes" xml:space="preserve">
          <source>Cluster</source>
          <target state="translated">Cluster</target>
        </trans-unit>
        <trans-unit id="4a4e6b60b2ae77bbe874af6a70cdbaba6049e713" translate="yes" xml:space="preserve">
          <source>Cluster clients must be aware of key positions in commands so commands can go to matching instances, but Redis commands vary between accepting one key, multiple keys, or even multiple keys separated by other data.</source>
          <target state="translated">클러스터 클라이언트는 명령에서 키 위치를 알고 있어야 명령이 일치하는 인스턴스로 이동할 수 있지만 Redis 명령은 하나의 키 수락, 여러 키 또는 다른 데이터로 구분 된 여러 키 사이에서 다양합니다.</target>
        </trans-unit>
        <trans-unit id="e3c356fac15c94ebf5b7447ee6cfaeb09fa342b3" translate="yes" xml:space="preserve">
          <source>Command Arity</source>
          <target state="translated">사령부</target>
        </trans-unit>
        <trans-unit id="b25b9ea512e65182e9de25869fda9886e798f471" translate="yes" xml:space="preserve">
          <source>Command Name</source>
          <target state="translated">명령 이름</target>
        </trans-unit>
        <trans-unit id="72da5b475c49e9d5cba38602d80b0de205cc6bb7" translate="yes" xml:space="preserve">
          <source>Command arity &lt;em&gt;includes&lt;/em&gt; counting the command name itself.</source>
          <target state="translated">명령 arity &lt;em&gt;에는&lt;/em&gt; 명령 이름 자체의 수를 &lt;em&gt;포함&lt;/em&gt; 합니다.</target>
        </trans-unit>
        <trans-unit id="7b7be4b904754c3884cb0bf72bfeb125fc2e6d02" translate="yes" xml:space="preserve">
          <source>Command arity follows a simple pattern:</source>
          <target state="translated">명령 arity는 간단한 패턴을 따릅니다.</target>
        </trans-unit>
        <trans-unit id="da09292eaa6e23b8b1b1824949fffe53ca537116" translate="yes" xml:space="preserve">
          <source>Command flags is &lt;a href=&quot;https://redis.io/topics/protocol#array-reply&quot;&gt;Array reply&lt;/a&gt; containing one or more status replies:</source>
          <target state="translated">명령 플래그는 하나 이상의 상태 응답을 포함하는 &lt;a href=&quot;https://redis.io/topics/protocol#array-reply&quot;&gt;배열&lt;/a&gt; 응답입니다.</target>
        </trans-unit>
        <trans-unit id="d8fdc321243166f52a9f1732c47f181f168fb6cd" translate="yes" xml:space="preserve">
          <source>Command name is the command returned as a lowercase string.</source>
          <target state="translated">명령 이름은 소문자 문자열로 반환되는 명령입니다.</target>
        </trans-unit>
        <trans-unit id="c03350e2365b375b5bb4ce53303074533ba05e9e" translate="yes" xml:space="preserve">
          <source>Command options</source>
          <target state="translated">명령 옵션</target>
        </trans-unit>
        <trans-unit id="a4618f4b2f49e68da5c5eab1cb65f4e2cbae4e8c" translate="yes" xml:space="preserve">
          <source>Commands about keys already migrated are correctly processed in the context of the node which is the target of the migration, the new hash slot owner, in order to guarantee consistency.</source>
          <target state="translated">일관성을 보장하기 위해 이미 마이그레이션 된 키에 대한 명령은 마이그레이션의 대상인 새 해시 슬롯 소유자 인 노드의 컨텍스트에서 올바르게 처리됩니다.</target>
        </trans-unit>
        <trans-unit id="b7c78328ebde5dad6a0b828ac630676fb4437227" translate="yes" xml:space="preserve">
          <source>Commands about this hash slot are refused and a &lt;code&gt;MOVED&lt;/code&gt; redirection is generated as usually, but in the case the command follows an &lt;code&gt;ASKING&lt;/code&gt; command, in this case the command is executed.</source>
          <target state="translated">이 해시 슬롯에 대한 명령이 거부되고 일반적으로 &lt;code&gt;MOVED&lt;/code&gt; 리디렉션이 생성되지만 명령이 &lt;code&gt;ASKING&lt;/code&gt; 명령을 따르는 경우이 명령이 실행됩니다.</target>
        </trans-unit>
        <trans-unit id="5080f3f78852fa61575aea2ee4cbd726a5e4c31e" translate="yes" xml:space="preserve">
          <source>Commands not logged by MONITOR</source>
          <target state="translated">MONITOR에 의해 로그되지 않은 명령</target>
        </trans-unit>
        <trans-unit id="b16b78407a41c93dd4cb4577acb6af8003abc8f6" translate="yes" xml:space="preserve">
          <source>Comments and the overall structure of the original redis.conf are preserved as much as possible.</source>
          <target state="translated">원래 redis.conf의 주석과 전체 구조는 최대한 보존됩니다.</target>
        </trans-unit>
        <trans-unit id="b2729f5c12d7e85d14c701273c4956c936eacdf5" translate="yes" xml:space="preserve">
          <source>Complete list of commands currently requiring key location parsing:</source>
          <target state="translated">현재 키 위치 구문 분석이 필요한 전체 명령 목록 :</target>
        </trans-unit>
        <trans-unit id="fdc6213bb38f415f44656ea01a54b34f86489a7e" translate="yes" xml:space="preserve">
          <source>Computes the intersection of &lt;code&gt;numkeys&lt;/code&gt; sorted sets given by the specified keys, and stores the result in &lt;code&gt;destination&lt;/code&gt;. It is mandatory to provide the number of input keys (&lt;code&gt;numkeys&lt;/code&gt;) before passing the input keys and the other (optional) arguments.</source>
          <target state="translated">지정된 키에 의해 지정된 &lt;code&gt;numkeys&lt;/code&gt; 소트 세트 의 교집합을 계산하고 결과를 &lt;code&gt;destination&lt;/code&gt; 에 저장 합니다 . 입력 키와 다른 (선택적) 인수를 전달하기 전에 입력 키 ( &lt;code&gt;numkeys&lt;/code&gt; ) 를 제공해야합니다 .</target>
        </trans-unit>
        <trans-unit id="9e0628d44bd94fff2a05cbf6e7329ac8c1542b4c" translate="yes" xml:space="preserve">
          <source>Computes the union of &lt;code&gt;numkeys&lt;/code&gt; sorted sets given by the specified keys, and stores the result in &lt;code&gt;destination&lt;/code&gt;. It is mandatory to provide the number of input keys (&lt;code&gt;numkeys&lt;/code&gt;) before passing the input keys and the other (optional) arguments.</source>
          <target state="translated">지정된 키에 의해 지정된 &lt;code&gt;numkeys&lt;/code&gt; 소트 세트 의 합집합을 계산하고 결과를 &lt;code&gt;destination&lt;/code&gt; 에 저장 합니다 . 입력 키와 다른 (선택적) 인수를 전달하기 전에 입력 키 ( &lt;code&gt;numkeys&lt;/code&gt; ) 를 제공해야합니다 .</target>
        </trans-unit>
        <trans-unit id="1ac361d8a1971640b6145bcc2b23471d096806f1" translate="yes" xml:space="preserve">
          <source>Conditions where a SHUTDOWN fails</source>
          <target state="translated">SHUTDOWN이 실패하는 조건</target>
        </trans-unit>
        <trans-unit id="6512ee1541e9a6c52d5bf7cf465332e8df25ea3c" translate="yes" xml:space="preserve">
          <source>Connection</source>
          <target state="translated">Connection</target>
        </trans-unit>
        <trans-unit id="ce5886d8502f58f63f333861b5077fd91e99a286" translate="yes" xml:space="preserve">
          <source>Consistency and WAIT</source>
          <target state="translated">일관성과 WAIT</target>
        </trans-unit>
        <trans-unit id="5f2f16b6f5d5be95f9b3876b338cd86be1794d28" translate="yes" xml:space="preserve">
          <source>Consistency with range functions in various programming languages</source>
          <target state="translated">다양한 프로그래밍 언어에서 범위 기능과의 일관성</target>
        </trans-unit>
        <trans-unit id="b36b2f89bb23664788c6f3dd35338c638ba28a39" translate="yes" xml:space="preserve">
          <source>Consumer groups in 30 seconds</source>
          <target state="translated">30 초 내에 소비자 그룹</target>
        </trans-unit>
        <trans-unit id="bd58f13135bb4a18278653a136394b666aadff83" translate="yes" xml:space="preserve">
          <source>Consumers in a consumer group are auto-created every time a new consumer name is mentioned by some command. However sometimes it may be useful to remove old consumers since they are no longer used. This form returns the number of pending messages that the consumer had before it was deleted.</source>
          <target state="translated">소비자 그룹의 소비자는 일부 명령에 의해 새로운 소비자 이름이 언급 될 때마다 자동 생성됩니다. 그러나 오래된 소비자는 더 이상 사용되지 않으므로 제거하는 것이 유용 할 수 있습니다. 이 양식은 소비자가 삭제하기 전에 보유한 보류중인 메시지 수를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="e04bdc35bafea7cf8c81eec69e12b57349af7a26" translate="yes" xml:space="preserve">
          <source>Conversion between Lua and Redis data types</source>
          <target state="translated">Lua와 Redis 데이터 유형 간 변환</target>
        </trans-unit>
        <trans-unit id="c74388ea06d766117ef931f93cf1e85e7c07bf21" translate="yes" xml:space="preserve">
          <source>Cost of running &lt;a href=&quot;monitor&quot;&gt;MONITOR&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;monitor&quot;&gt;MONITOR&lt;/a&gt; 운영 비용</target>
        </trans-unit>
        <trans-unit id="e55d91fd97c87e8a34c622a7e4794ffcc51bd61d" translate="yes" xml:space="preserve">
          <source>Count argument extension</source>
          <target state="translated">카운트 인수 확장</target>
        </trans-unit>
        <trans-unit id="ed6fd4dc25ec3bdb3875f3c7192bde09b87a5801" translate="yes" xml:space="preserve">
          <source>Count the number of set bits (population counting) in a string.</source>
          <target state="translated">문자열에서 설정된 비트 수 (인구 수)를 계산합니다.</target>
        </trans-unit>
        <trans-unit id="852a7b974be96bbc7c6036398114250aedbb0dca" translate="yes" xml:space="preserve">
          <source>Create a key associated with a value that is obtained by deserializing the provided serialized value (obtained via &lt;a href=&quot;dump&quot;&gt;DUMP&lt;/a&gt;).</source>
          <target state="translated">제공된 직렬화 된 값을 직렬화 해제하여 얻은 값과 연관된 키를 작성하십시오 ( &lt;a href=&quot;dump&quot;&gt;DUMP&lt;/a&gt; 를 통해 획득 됨 ).</target>
        </trans-unit>
        <trans-unit id="1b9548967da77ce66eb092905a2179716e7c9d5d" translate="yes" xml:space="preserve">
          <source>Create a new consumer group associated with a stream.</source>
          <target state="translated">스트림과 연관된 새 이용자 그룹을 작성하십시오.</target>
        </trans-unit>
        <trans-unit id="e8db62ea4abea13f4e50ca9316893c361ba8afd9" translate="yes" xml:space="preserve">
          <source>D ends re-added in the nodes table of A.</source>
          <target state="translated">D는 A의 노드 테이블에 다시 추가됩니다.</target>
        </trans-unit>
        <trans-unit id="d6ddfbac6ec07c32e2eb043cdffc4a0b7cf14714" translate="yes" xml:space="preserve">
          <source>D is now empty, but still listed in the nodes table of A, B and C.</source>
          <target state="translated">D는 이제 비어 있지만 여전히 A, B 및 C의 노드 테이블에 나열됩니다.</target>
        </trans-unit>
        <trans-unit id="5231dbf5c92399c707fd162111bff340755773aa" translate="yes" xml:space="preserve">
          <source>DBSIZE</source>
          <target state="translated">DBSIZE</target>
        </trans-unit>
        <trans-unit id="cd67c53a53d3f0097d3c5a23561287ae0d9fb415" translate="yes" xml:space="preserve">
          <source>DBSIZE   Return the number of keys in the selected database</source>
          <target state="translated">DBSIZE 선택된 데이터베이스의 키 개수를 반환</target>
        </trans-unit>
        <trans-unit id="3f67e8f4eecf241b91f4cc8c976a487ade34d09d" translate="yes" xml:space="preserve">
          <source>DEBUG</source>
          <target state="translated">DEBUG</target>
        </trans-unit>
        <trans-unit id="64d12201fd531f0183ba8e8b6982cd30fb3885db" translate="yes" xml:space="preserve">
          <source>DEBUG OBJECT  key   Get debugging information about a key</source>
          <target state="translated">DEBUG OBJECT 키 키에 대한 디버깅 정보를 얻습니다.</target>
        </trans-unit>
        <trans-unit id="a9e1eb844a55b579a65a4c4467b589dca48f8f1a" translate="yes" xml:space="preserve">
          <source>DEBUG SEGFAULT   Make the server crash</source>
          <target state="translated">버그 디버깅 서버 충돌을 일으킴</target>
        </trans-unit>
        <trans-unit id="d05cdacee2c153d405a26e62250727ce77ea0892" translate="yes" xml:space="preserve">
          <source>DECR</source>
          <target state="translated">DECR</target>
        </trans-unit>
        <trans-unit id="60ab4c3e9133d30eaf0ded676cadb4c538c56082" translate="yes" xml:space="preserve">
          <source>DECR  key   Decrement the integer value of a key by one</source>
          <target state="translated">DECR 키 키의 정수 값을 1 씩 감소시킵니다</target>
        </trans-unit>
        <trans-unit id="dd8d57c1b1a5522fa21a54d374912c18ca797f47" translate="yes" xml:space="preserve">
          <source>DECRBY</source>
          <target state="translated">DECRBY</target>
        </trans-unit>
        <trans-unit id="8c2782a79fd11dffe9a2c86222797cdb763ac992" translate="yes" xml:space="preserve">
          <source>DECRBY  key decrement   Decrement the integer value of a key by the given number</source>
          <target state="translated">DECRBY 키 감소 주어진 숫자만큼 키의 정수 값을 감소시킵니다</target>
        </trans-unit>
        <trans-unit id="4d017cb3dcf43d965d38a31c9ad97cefabc893fb" translate="yes" xml:space="preserve">
          <source>DEL</source>
          <target state="translated">DEL</target>
        </trans-unit>
        <trans-unit id="85fb2865a5ba87d91f28447addbf73c6630fa434" translate="yes" xml:space="preserve">
          <source>DEL  key [key ...]   Delete a key</source>
          <target state="translated">DEL 키 [키 ...] 키 삭제</target>
        </trans-unit>
        <trans-unit id="f70fbda4bf2a0042e1d9cc7f61715651b43106d6" translate="yes" xml:space="preserve">
          <source>DISCARD</source>
          <target state="translated">DISCARD</target>
        </trans-unit>
        <trans-unit id="7bb67c7109691456662bb20fddb311696e25ac95" translate="yes" xml:space="preserve">
          <source>DISCARD   Discard all commands issued after MULTI</source>
          <target state="translated">취소 MULTI 이후에 발행 된 모든 명령을 폐기하십시오</target>
        </trans-unit>
        <trans-unit id="fac3a6812b938bfbdd2af221e2fba7ec856f466e" translate="yes" xml:space="preserve">
          <source>DUMP</source>
          <target state="translated">DUMP</target>
        </trans-unit>
        <trans-unit id="88b9c1225fe8ce252d48041c949b9e8d2d7b90b3" translate="yes" xml:space="preserve">
          <source>DUMP  key   Return a serialized version of the value stored at the specified key.</source>
          <target state="translated">DUMP 키 지정된 키에 저장된 값의 직렬화 된 버전을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="4220ea2836e7841048c2cdb7caf3ef474641deb4" translate="yes" xml:space="preserve">
          <source>Debugging Lua scripts</source>
          <target state="translated">루아 스크립트 디버깅</target>
        </trans-unit>
        <trans-unit id="f34ef3d0e6d55088a63bbe9a7135854f8a4a3c06" translate="yes" xml:space="preserve">
          <source>Decrements the number stored at &lt;code&gt;key&lt;/code&gt; by &lt;code&gt;decrement&lt;/code&gt;. If the key does not exist, it is set to &lt;code&gt;0&lt;/code&gt; before performing the operation. An error is returned if the key contains a value of the wrong type or contains a string that can not be represented as integer. This operation is limited to 64 bit signed integers.</source>
          <target state="translated">&lt;code&gt;key&lt;/code&gt; 에 저장된 숫자 를 &lt;code&gt;decrement&lt;/code&gt; . 키가 없으면 조작을 수행하기 전에 &lt;code&gt;0&lt;/code&gt; 으로 설정됩니다 . 키에 잘못된 유형의 값이 있거나 정수로 표현할 수없는 문자열이 포함 된 경우 오류가 리턴됩니다. 이 연산은 64 비트 부호있는 정수로 제한됩니다.</target>
        </trans-unit>
        <trans-unit id="eabc98dcb44b2f848dc2b5fd749cc1976767b1ef" translate="yes" xml:space="preserve">
          <source>Decrements the number stored at &lt;code&gt;key&lt;/code&gt; by one. If the key does not exist, it is set to &lt;code&gt;0&lt;/code&gt; before performing the operation. An error is returned if the key contains a value of the wrong type or contains a string that can not be represented as integer. This operation is limited to &lt;strong&gt;64 bit signed integers&lt;/strong&gt;.</source>
          <target state="translated">&lt;code&gt;key&lt;/code&gt; 에 저장된 숫자 를 하나씩 줄입니다. 키가 없으면 조작을 수행하기 전에 &lt;code&gt;0&lt;/code&gt; 으로 설정됩니다 . 키에 잘못된 유형의 값이 있거나 정수로 표현할 수없는 문자열이 포함 된 경우 오류가 리턴됩니다. 이 작업은 &lt;strong&gt;64 비트 부호있는 정수로&lt;/strong&gt; 제한됩니다 .</target>
        </trans-unit>
        <trans-unit id="543341d8d409be4e8e87f012a0d71ed9115a00c9" translate="yes" xml:space="preserve">
          <source>Delete all the keys found expired.</source>
          <target state="translated">만료 된 모든 키를 삭제하십시오.</target>
        </trans-unit>
        <trans-unit id="093f69205f9dd67871820195d9a0ab6b921ee71c" translate="yes" xml:space="preserve">
          <source>Delete all the keys of all the existing databases, not just the currently selected one. This command never fails.</source>
          <target state="translated">현재 선택된 데이터베이스뿐만 아니라 모든 기존 데이터베이스의 모든 키를 삭제하십시오. 이 명령은 절대 실패하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="1a8bf3d0326f070451b1d5d0c69c59a369de9555" translate="yes" xml:space="preserve">
          <source>Delete all the keys of the currently selected DB. This command never fails.</source>
          <target state="translated">현재 선택된 DB의 모든 키를 삭제하십시오. 이 명령은 절대 실패하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="80a85a3d0c778d43ae904d63695fe309c4c3c24d" translate="yes" xml:space="preserve">
          <source>Deployment is hard if we have to make sure all instances contain a given command, especially in a distributed environment.</source>
          <target state="translated">특히 분산 환경에서 모든 인스턴스에 지정된 명령이 포함되어 있는지 확인해야 배포가 어렵습니다.</target>
        </trans-unit>
        <trans-unit id="5ff30b622ac74ad50b3a17678781b111c2a76d5c" translate="yes" xml:space="preserve">
          <source>Design pattern</source>
          <target state="translated">디자인 패턴</target>
        </trans-unit>
        <trans-unit id="21a2deb58a8a8547be11baa26a8458026dc5e0be" translate="yes" xml:space="preserve">
          <source>Design pattern: Locking with &lt;code&gt;SETNX&lt;/code&gt;</source>
          <target state="translated">디자인 패턴 : &lt;code&gt;SETNX&lt;/code&gt; 로 잠금</target>
        </trans-unit>
        <trans-unit id="fa7fb27a452f3b56f97bc25556a2c1c23541060b" translate="yes" xml:space="preserve">
          <source>Destroy a consumer group.</source>
          <target state="translated">소비자 그룹을 파괴하십시오.</target>
        </trans-unit>
        <trans-unit id="2a999a830e915e0d76daa09bf5db1dee24489f35" translate="yes" xml:space="preserve">
          <source>Details on strings comparison</source>
          <target state="translated">문자열 비교에 대한 세부 사항</target>
        </trans-unit>
        <trans-unit id="b5cf1dd7b9908b60a915b47bdf1a512163a4abd6" translate="yes" xml:space="preserve">
          <source>Details on why the ban-list is needed</source>
          <target state="translated">금지 목록이 필요한 이유에 대한 세부 사항</target>
        </trans-unit>
        <trans-unit id="e861bf6485a8747057af520bff1e2bd98ca908ee" translate="yes" xml:space="preserve">
          <source>Detect timed out replicas.</source>
          <target state="translated">시간 초과 복제본을 감지합니다.</target>
        </trans-unit>
        <trans-unit id="c1a87c7e48f6afb9828d520eaa5085ecfdb87723" translate="yes" xml:space="preserve">
          <source>Differences between XREAD and XREADGROUP</source>
          <target state="translated">XREAD와 XREADGROUP의 차이점</target>
        </trans-unit>
        <trans-unit id="954c7e91bbe922ce8d0679c169669338d8457c3c" translate="yes" xml:space="preserve">
          <source>Differences in Redis prior 2.1.3</source>
          <target state="translated">2.1.3 이전 Redis의 차이점</target>
        </trans-unit>
        <trans-unit id="d60417fd68044b5a922b2a39105c16f898e592ce" translate="yes" xml:space="preserve">
          <source>Different instances may have different implementations of a command.</source>
          <target state="translated">인스턴스마다 다른 명령 구현이있을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0e666a0e590c18bbb2775c33bdd4b4b2755c4fd8" translate="yes" xml:space="preserve">
          <source>Different return values are used for different subcommands.</source>
          <target state="translated">다른 부속 명령에 다른 리턴 값이 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="8519d2a89e19a4522b7059222e7d87dd5565a1b3" translate="yes" xml:space="preserve">
          <source>Disables read queries for a connection to a Redis Cluster slave node.</source>
          <target state="translated">Redis 클러스터 슬레이브 노드에 대한 연결에 대한 읽기 쿼리를 비활성화합니다.</target>
        </trans-unit>
        <trans-unit id="3c9664e573a114e8272bfbfb19ccbd51925d8d78" translate="yes" xml:space="preserve">
          <source>Distribution of returned elements</source>
          <target state="translated">반환 된 요소의 분포</target>
        </trans-unit>
        <trans-unit id="7ccde4db71eed2460dfb04d6817e8c9f76a501f5" translate="yes" xml:space="preserve">
          <source>Due to the single-threaded nature of Redis, it is not possible to kill a client connection while it is executing a command. From the client point of view, the connection can never be closed in the middle of the execution of a command. However, the client will notice the connection has been closed only when the next command is sent (and results in network error).</source>
          <target state="translated">Redis의 단일 스레드 특성으로 인해 명령을 실행하는 동안 클라이언트 연결을 종료 할 수 없습니다. 클라이언트 관점에서 명령 실행 도중 연결을 닫을 수 없습니다. 그러나 클라이언트는 다음 명령이 전송 될 때만 연결이 닫 혔음을 알 수 있으며 네트워크 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="6781cfc8284296eb70ba05270579b9deac096a80" translate="yes" xml:space="preserve">
          <source>ECHO</source>
          <target state="translated">ECHO</target>
        </trans-unit>
        <trans-unit id="e7ec2091f33799c975a8d7a6ea9bc9b6bc50c88f" translate="yes" xml:space="preserve">
          <source>ECHO  message   Echo the given string</source>
          <target state="translated">ECHO 메시지 주어진 문자열을 에코</target>
        </trans-unit>
        <trans-unit id="225a586b70502eff079ebfff31adfbc6e0bf2d35" translate="yes" xml:space="preserve">
          <source>EVAL</source>
          <target state="translated">EVAL</target>
        </trans-unit>
        <trans-unit id="ea1523936796cac657906bcb4392d72c0f622a53" translate="yes" xml:space="preserve">
          <source>EVAL  script numkeys key [key ...] arg [arg ...]   Execute a Lua script server side</source>
          <target state="translated">EVAL 스크립트 numkeys 키 [key ...] arg [arg ...] Lua 스크립트 서버 측 실행</target>
        </trans-unit>
        <trans-unit id="8b8522c1abed78aca4ba0ae5b2f9d4375bf6841d" translate="yes" xml:space="preserve">
          <source>EVALSHA</source>
          <target state="translated">EVALSHA</target>
        </trans-unit>
        <trans-unit id="9ca231b5b5f90e450c680cb2bea30ab1800479a3" translate="yes" xml:space="preserve">
          <source>EVALSHA  sha1 numkeys key [key ...] arg [arg ...]   Execute a Lua script server side</source>
          <target state="translated">EVALSHA sha1 numkeys key [key ...] arg [arg ...] Lua 스크립트 서버 측 실행</target>
        </trans-unit>
        <trans-unit id="e29c908995e16002c05ec47ec36aaf34a1bd4b78" translate="yes" xml:space="preserve">
          <source>EVALSHA in the context of pipelining</source>
          <target state="translated">파이프 라이닝의 맥락에서 EVALSHA</target>
        </trans-unit>
        <trans-unit id="ea837e81db8c2bd7fcea29a56cd54086382f1f43" translate="yes" xml:space="preserve">
          <source>EXEC</source>
          <target state="translated">EXEC</target>
        </trans-unit>
        <trans-unit id="2b1156bdd8031e124d3a9ae093559b5a4386e538" translate="yes" xml:space="preserve">
          <source>EXEC   Execute all commands issued after MULTI</source>
          <target state="translated">EXEC MULTI 이후에 발행 된 모든 명령을 실행</target>
        </trans-unit>
        <trans-unit id="644b5806e118fe0af3936c64572a1496ddda7507" translate="yes" xml:space="preserve">
          <source>EXISTS</source>
          <target state="translated">EXISTS</target>
        </trans-unit>
        <trans-unit id="08807aa77041e8b29bbcefa207328a0789129027" translate="yes" xml:space="preserve">
          <source>EXISTS  key [key ...]   Determine if a key exists</source>
          <target state="translated">EXISTS 키 [key ...] 키가 있는지 확인</target>
        </trans-unit>
        <trans-unit id="1215753c2320bb44b6a871baac293e5bf276e781" translate="yes" xml:space="preserve">
          <source>EXPIRE</source>
          <target state="translated">EXPIRE</target>
        </trans-unit>
        <trans-unit id="436d86e478f5d801c08f118762eb43ed84923c39" translate="yes" xml:space="preserve">
          <source>EXPIRE  key seconds   Set a key's time to live in seconds</source>
          <target state="translated">EXPIRE key seconds 키의 시간을 초 단위로 설정합니다</target>
        </trans-unit>
        <trans-unit id="ce90cafacba153e381a002cc83387fcbd4d6f68f" translate="yes" xml:space="preserve">
          <source>EXPIREAT</source>
          <target state="translated">EXPIREAT</target>
        </trans-unit>
        <trans-unit id="34c23f46d63812eec7d4e21acb84ed6214c2b5cc" translate="yes" xml:space="preserve">
          <source>EXPIREAT  key timestamp   Set the expiration for a key as a UNIX timestamp</source>
          <target state="translated">EXPIREAT 키 타임 스탬프 키 만료를 UNIX 타임 스탬프로 설정</target>
        </trans-unit>
        <trans-unit id="1f423012c27396dae7aa028cc182a29eea955b66" translate="yes" xml:space="preserve">
          <source>Each failure report has a time to live of two times the &lt;em&gt;node timeout&lt;/em&gt; time.</source>
          <target state="translated">각 실패 보고서에는 &lt;em&gt;노드 시간 종료&lt;/em&gt; 시간 의 두 배가 지속됩니다.</target>
        </trans-unit>
        <trans-unit id="e89059e939f6644b3364536eb50a1abdc89a1613" translate="yes" xml:space="preserve">
          <source>Each line is composed of a succession of &lt;code&gt;property=value&lt;/code&gt; fields separated by a space character.</source>
          <target state="translated">각 줄은 공백 문자로 구분 된 일련의 &lt;code&gt;property=value&lt;/code&gt; 필드로 구성됩니다.</target>
        </trans-unit>
        <trans-unit id="4918aff92ee02999f29bacd99ab30d0a000253c7" translate="yes" xml:space="preserve">
          <source>Each line is composed of the following fields:</source>
          <target state="translated">각 줄은 다음 필드로 구성됩니다.</target>
        </trans-unit>
        <trans-unit id="853014cc58f5042914b68be7e44d86291316a8d3" translate="yes" xml:space="preserve">
          <source>Each nested result is:</source>
          <target state="translated">각 중첩 결과는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="001afdca6677847da08247ab1ec58a7506cae0eb" translate="yes" xml:space="preserve">
          <source>Each node in a Redis Cluster has its view of the current cluster configuration, given by the set of known nodes, the state of the connection we have with such nodes, their flags, properties and assigned slots, and so forth.</source>
          <target state="translated">Redis 클러스터의 각 노드는 알려진 노드 세트, 해당 노드와의 연결 상태, 플래그, 속성 및 할당 된 슬롯 등으로 현재 클러스터 구성을 볼 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4031491a0a21d3efcb1ae0e642e160153ab9452c" translate="yes" xml:space="preserve">
          <source>Each result includes all active replicas of the master instance for the listed slot range. Failed replicas are not returned.</source>
          <target state="translated">각 결과에는 나열된 슬롯 범위에 대한 마스터 인스턴스의 모든 활성 복제본이 포함됩니다. 실패한 복제본은 반환되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="39a5a1ac33abf7ccbf42de1a62abad74d800f2a8" translate="yes" xml:space="preserve">
          <source>Each subcommand is documented below. At the end you'll find a description of how live resharding is performed using this command and other related commands.</source>
          <target state="translated">각 하위 명령이 아래에 설명되어 있습니다. 마지막으로이 명령 및 기타 관련 명령을 사용하여 라이브 리 샤딩을 수행하는 방법에 대한 설명을 찾을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2d0820e2ed028ade2f8d73ff5b41f73cd289b4e1" translate="yes" xml:space="preserve">
          <source>Each top-level result contains six nested results. Each nested result is:</source>
          <target state="translated">각 최상위 결과에는 6 개의 중첩 된 결과가 포함됩니다. 각 중첩 결과는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="b5f7d21b9ba2cb092f0980b7560e9cd91a246461" translate="yes" xml:space="preserve">
          <source>Effects on the node:</source>
          <target state="translated">노드에 미치는 영향 :</target>
        </trans-unit>
        <trans-unit id="1940e8677e72b823aadf3f1babad911e272f4f7b" translate="yes" xml:space="preserve">
          <source>Elements that were not constantly present in the collection during a full iteration, may be returned or not: it is undefined.</source>
          <target state="translated">전체 반복 동안 컬렉션에 지속적으로 존재하지 않는 요소는 반환 될 수도 있고 반환되지 않을 수도 있습니다. 정의되지 않았습니다.</target>
        </trans-unit>
        <trans-unit id="fa43f0d9868a88416f82c35ed64e1745c1e56215" translate="yes" xml:space="preserve">
          <source>Elements with the same score</source>
          <target state="translated">같은 점수를 가진 요소</target>
        </trans-unit>
        <trans-unit id="127cfef1e8e010cbd37725ea8863aa38e5d50815" translate="yes" xml:space="preserve">
          <source>Emitting Redis logs from scripts</source>
          <target state="translated">스크립트에서 Redis 로그 방출</target>
        </trans-unit>
        <trans-unit id="1f733b322f80ecf7300735b8315383e95cf78665" translate="yes" xml:space="preserve">
          <source>Enables read queries for a connection to a Redis Cluster replica node.</source>
          <target state="translated">Redis 클러스터 복제본 노드에 연결하기위한 읽기 쿼리를 활성화합니다.</target>
        </trans-unit>
        <trans-unit id="6fb65c66a66392a71ca206846f2ac13ca3b45368" translate="yes" xml:space="preserve">
          <source>End slot range</source>
          <target state="translated">엔드 슬롯 범위</target>
        </trans-unit>
        <trans-unit id="73631d7f0356fdbdeaa36f8e5dbad89c6aa15dc4" translate="yes" xml:space="preserve">
          <source>Error handling</source>
          <target state="translated">오류 처리</target>
        </trans-unit>
        <trans-unit id="6ad4930b258ad43ab07d5ba00c43530ba3b62093" translate="yes" xml:space="preserve">
          <source>Evaluates a script cached on the server side by its SHA1 digest. Scripts are cached on the server side using the &lt;a href=&quot;script-load&quot;&gt;SCRIPT LOAD&lt;/a&gt; command. The command is otherwise identical to &lt;a href=&quot;eval&quot;&gt;EVAL&lt;/a&gt;.</source>
          <target state="translated">SHA1 다이제스트를 통해 서버 측에서 캐시 된 스크립트를 평가합니다. 스크립트는 &lt;a href=&quot;script-load&quot;&gt;SCRIPT LOAD&lt;/a&gt; 명령을 사용하여 서버 측에서 캐시됩니다 . 그렇지 않으면 명령은 &lt;a href=&quot;eval&quot;&gt;EVAL&lt;/a&gt; 과 동일합니다 .</target>
        </trans-unit>
        <trans-unit id="3784064b237e9150f97da5ef4677aaab4b0c6d07" translate="yes" xml:space="preserve">
          <source>Even if other clients are actively pushing new items at the end of the list.</source>
          <target state="translated">다른 고객이 목록의 끝에 새 항목을 적극적으로 푸시하더라도 마찬가지입니다.</target>
        </trans-unit>
        <trans-unit id="7dd20b200cf466b9bb17c87ac888deb51e1a343f" translate="yes" xml:space="preserve">
          <source>Even running instances will always check the computer clock, so for instance if you set a key with a time to live of 1000 seconds, and then set your computer time 2000 seconds in the future, the key will be expired immediately, instead of lasting for 1000 seconds.</source>
          <target state="translated">실행중인 인스턴스조차도 항상 컴퓨터 시계를 확인하므로, 예를 들어 시간이 1000 초인 키를 설정 한 다음 나중에 컴퓨터 시간을 2000 초로 설정하면 키가 지속되는 대신 즉시 만료됩니다 1000 초</target>
        </trans-unit>
        <trans-unit id="9ad3a7a35d62cd7230213de79ba4b1043488e12a" translate="yes" xml:space="preserve">
          <source>Eventually if all the entries in a macro-node are marked as deleted, the whole node is destroyed and the memory reclaimed. This means that if you delete a large amount of entries from a stream, for instance more than 50% of the entries appended to the stream, the memory usage per entry may increment, since what happens is that the stream will start to be fragmented. However the stream performances will remain the same.</source>
          <target state="translated">결국 매크로 노드의 모든 항목이 삭제 된 것으로 표시되면 전체 노드가 삭제되고 메모리가 회수됩니다. 이는 스트림에서 많은 양의 항목 (예 : 스트림에 추가 된 항목의 50 % 이상)을 삭제하면 스트림 조각화가 시작되기 때문에 항목 당 메모리 사용량이 증가 할 수 있음을 의미합니다. 그러나 스트림 성능은 동일하게 유지됩니다.</target>
        </trans-unit>
        <trans-unit id="792161cf042fd5babb68da92f1bbb2902dc3526e" translate="yes" xml:space="preserve">
          <source>Every Redis instance is &lt;em&gt;guaranteed&lt;/em&gt; to have all the above libraries so you can be sure that the environment for your Redis scripts is always the same.</source>
          <target state="translated">모든 Redis 인스턴스 에는 위의 모든 라이브러리 가 &lt;em&gt;보장&lt;/em&gt; 되므로 Redis 스크립트의 환경이 항상 동일하다는 것을 확신 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ff1000733402cd15305f0a4763cbc390865561a4" translate="yes" xml:space="preserve">
          <source>Every entry is composed of four (or six starting with Redis 4.0) fields:</source>
          <target state="translated">모든 항목은 4 개 (또는 Redis 4.0부터 6 개) 필드로 구성됩니다.</target>
        </trans-unit>
        <trans-unit id="c3f1325124fc7f8408e9843db0ab98baea3e119b" translate="yes" xml:space="preserve">
          <source>Every new connection starts without an assigned name.</source>
          <target state="translated">모든 새로운 연결은 지정된 이름없이 시작됩니다.</target>
        </trans-unit>
        <trans-unit id="51df853590a285fd9b12bc8e0d4650ccb232f700" translate="yes" xml:space="preserve">
          <source>Every time a node processes gossip packets from other nodes, it creates (and refreshes the TTL if needed) &lt;strong&gt;failure reports&lt;/strong&gt;, remembering that a given node said another given node is in &lt;code&gt;PFAIL&lt;/code&gt; condition.</source>
          <target state="translated">한 노드가 다른 노드에서 가십 패킷을 처리 할 때마다 지정된 노드가 다른 특정 노드가 &lt;code&gt;PFAIL&lt;/code&gt; 상태에 있다는 것을 기억하면서 &lt;strong&gt;실패 보고서를&lt;/strong&gt; 작성 (필요한 경우 TTL을 새로 고침) 합니다.</target>
        </trans-unit>
        <trans-unit id="c8f9b9897ccaf6988795d0fa2e49d6b67f29b456" translate="yes" xml:space="preserve">
          <source>Every time a user performs a page view, the application can register that in the current day the user visited the web site using the &lt;a href=&quot;setbit&quot;&gt;SETBIT&lt;/a&gt; command setting the bit corresponding to the current day.</source>
          <target state="translated">사용자가 페이지보기를 수행 할 때마다 응용 프로그램은 현재 날짜에 해당하는 비트를 설정하는 &lt;a href=&quot;setbit&quot;&gt;SETBIT&lt;/a&gt; 명령을 사용하여 현재 날짜에 사용자가 웹 사이트를 방문한 것을 등록 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="434360186a18d9c330717a5f17d631c11575acb2" translate="yes" xml:space="preserve">
          <source>Every time this script executed the resulting list will have exactly the following elements:</source>
          <target state="translated">이 스크립트가 실행될 때마다 결과 목록은 정확히 다음 요소를 갖습니다.</target>
        </trans-unit>
        <trans-unit id="0f01ed56a1e32a05e5ef96e4d779f34784af9a96" translate="yes" xml:space="preserve">
          <source>Example</source>
          <target state="translated">Example</target>
        </trans-unit>
        <trans-unit id="815030c996b00efbe374a3c45d7121d3e9fc4929" translate="yes" xml:space="preserve">
          <source>Example of zero padding:</source>
          <target state="translated">제로 패딩의 예 :</target>
        </trans-unit>
        <trans-unit id="c63737abd7347a7ae582cb9fbdf37d6c0e5b251e" translate="yes" xml:space="preserve">
          <source>Example:</source>
          <target state="translated">Example:</target>
        </trans-unit>
        <trans-unit id="eb01bf04c9a0e8a71c45816513df424f1c7ffedb" translate="yes" xml:space="preserve">
          <source>Examples</source>
          <target state="translated">Examples</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
