<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="redis">
    <body>
      <group id="redis">
        <trans-unit id="fb3447b632f6a431215776dcf254a01001a40c4f" translate="yes" xml:space="preserve">
          <source>Examples:</source>
          <target state="translated">Examples:</target>
        </trans-unit>
        <trans-unit id="c687d1b70c080536289366ba8155bc643fc72076" translate="yes" xml:space="preserve">
          <source>Exclusive intervals and infinity</source>
          <target state="translated">독점 간격과 무한대</target>
        </trans-unit>
        <trans-unit id="8e788d736a6e3a42271b3b6edc6a324f07e11667" translate="yes" xml:space="preserve">
          <source>Executed scripts are guaranteed to be in the script cache of a given execution of a Redis instance forever. This means that if an &lt;a href=&quot;eval&quot;&gt;EVAL&lt;/a&gt; is performed against a Redis instance all the subsequent &lt;a href=&quot;evalsha&quot;&gt;EVALSHA&lt;/a&gt; calls will succeed.</source>
          <target state="translated">실행 된 스크립트는 지정된 Redis 인스턴스 실행의 스크립트 캐시에 영구적으로 보장됩니다. 이는 Redis 인스턴스에 대해 &lt;a href=&quot;eval&quot;&gt;EVAL&lt;/a&gt; 이 수행 되면 모든 후속 &lt;a href=&quot;evalsha&quot;&gt;EVALSHA&lt;/a&gt; 호출이 성공 함을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="446763d77e17832a47ad829663f2f4ba29ce76f7" translate="yes" xml:space="preserve">
          <source>Executes all previously queued commands in a &lt;a href=&quot;https://redis.io/topics/transactions&quot;&gt;transaction&lt;/a&gt; and restores the connection state to normal.</source>
          <target state="translated">&lt;a href=&quot;https://redis.io/topics/transactions&quot;&gt;트랜잭션&lt;/a&gt; 에서 이전에 대기중인 모든 명령을 실행 하고 연결 상태를 정상으로 복원합니다.</target>
        </trans-unit>
        <trans-unit id="d80b1a46f6734fb75c0119610c9901aef0c08607" translate="yes" xml:space="preserve">
          <source>Executing a Lua Script with Redis 2.6 or newer.</source>
          <target state="translated">Redis 2.6 이상에서 Lua 스크립트 실행</target>
        </trans-unit>
        <trans-unit id="e1a9d983dc0912bcd36f098a1b8c4b6851a2ccbc" translate="yes" xml:space="preserve">
          <source>Expire accuracy</source>
          <target state="translated">만료 정확도</target>
        </trans-unit>
        <trans-unit id="5bbbfc0dcb3f1ea6203152c364bf711f30071354" translate="yes" xml:space="preserve">
          <source>Expires and persistence</source>
          <target state="translated">만료 및 지속성</target>
        </trans-unit>
        <trans-unit id="ceae3e065a822da58b9dd577a4a2215264628a2c" translate="yes" xml:space="preserve">
          <source>FLUSHALL</source>
          <target state="translated">FLUSHALL</target>
        </trans-unit>
        <trans-unit id="a1dc7fedbb3161c8d2db024cd3ee46e2af26f812" translate="yes" xml:space="preserve">
          <source>FLUSHALL  [ASYNC]   Remove all keys from all databases</source>
          <target state="translated">FLUSHALL [ASYNC] 모든 데이터베이스에서 모든 키 제거</target>
        </trans-unit>
        <trans-unit id="10bb3c2c2d36018ba538d533264f2171634a8d95" translate="yes" xml:space="preserve">
          <source>FLUSHDB</source>
          <target state="translated">FLUSHDB</target>
        </trans-unit>
        <trans-unit id="b40b961b1c26ac58fbd9ac2f12f0c446fb2897d9" translate="yes" xml:space="preserve">
          <source>FLUSHDB  [ASYNC]   Remove all keys from the current database</source>
          <target state="translated">FLUSHDB [ASYNC] 현재 데이터베이스에서 모든 키 제거</target>
        </trans-unit>
        <trans-unit id="a5f0b2c20a29e7587597abea3e79fa609ca01e4c" translate="yes" xml:space="preserve">
          <source>FORCE option: manual failover when the master is down</source>
          <target state="translated">FORCE 옵션 : 마스터가 다운 될 때 수동 장애 조치</target>
        </trans-unit>
        <trans-unit id="4a0878bdd16e36ba72b474afe51ae9c582fef6d5" translate="yes" xml:space="preserve">
          <source>Fetching a single entry from a stream, providing the ID of the entry to fetch two times: as start and end of the query interval.</source>
          <target state="translated">스트림에서 단일 항목을 가져 와서 조회 간격의 시작과 끝으로 두 번 페치 할 항목의 ID를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="d11485369737f36370f75a3ff43b46d72effc624" translate="yes" xml:space="preserve">
          <source>Fetching data from a stream via a consumer group, and not acknowledging such data, has the effect of creating &lt;em&gt;pending entries&lt;/em&gt;. This is well explained in the &lt;a href=&quot;xreadgroup&quot;&gt;XREADGROUP&lt;/a&gt; command, and even better in our &lt;a href=&quot;https://redis.io/topics/streams-intro&quot;&gt;introduction to Redis Streams&lt;/a&gt;. The &lt;a href=&quot;xack&quot;&gt;XACK&lt;/a&gt; command will immediately remove the pending entry from the Pending Entry List (PEL) since once a message is successfully processed, there is no longer need for the consumer group to track it and to remember the current owner of the message.</source>
          <target state="translated">소비자 그룹을 통해 스트림에서 데이터를 가져오고 이러한 데이터를 승인하지 않으면 &lt;em&gt;보류중인 항목&lt;/em&gt; 을 만드는 효과가 있습니다. 이것은 &lt;a href=&quot;xreadgroup&quot;&gt;XREADGROUP&lt;/a&gt; 명령 에 잘 설명되어 있으며 &lt;a href=&quot;https://redis.io/topics/streams-intro&quot;&gt;Redis Streams 소개에&lt;/a&gt; 더 좋습니다 . &lt;a href=&quot;xack&quot;&gt;XACK의&lt;/a&gt; 명령은 즉시 메시지가 성공적으로 처리되면 이후 보류중인 항목 목록 (PEL)에서 보류중인 항목을 제거합니다, 소비자 그룹에 더 이상 필요를 추적하고 메시지의 현재 소유자를 기억이 없다.</target>
        </trans-unit>
        <trans-unit id="13b9c9d38a4b96f103ca63910ffc56743e00fd12" translate="yes" xml:space="preserve">
          <source>Fetching single items</source>
          <target state="translated">단일 항목을 가져 오는 중</target>
        </trans-unit>
        <trans-unit id="8330be22b4e169fe5141dfbcacb82dc81724e13f" translate="yes" xml:space="preserve">
          <source>Finally it is possible to get help from the command, in case the user can't remember the exact syntax, by using the &lt;code&gt;HELP&lt;/code&gt; subcommnad:</source>
          <target state="translated">마지막으로 &lt;code&gt;HELP&lt;/code&gt; 하위 명령 을 사용하여 사용자가 정확한 구문을 기억하지 못하는 경우 명령에서 도움을받을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="5388f4a7abea666722d4311743c9d3e1d5bfc3b1" translate="yes" xml:space="preserve">
          <source>Finally it is possible to get the list of every consumer in a specific consumer group:</source>
          <target state="translated">마지막으로 특정 소비자 그룹의 모든 소비자 목록을 얻을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7cbe1b741345fc3839fb4d58149e9dd7af6c272a" translate="yes" xml:space="preserve">
          <source>Finally it is possible to pass an additional argument to the command, in order to see the messages having a specific owner:</source>
          <target state="translated">마지막으로 특정 소유자가있는 메시지를보기 위해 명령에 추가 인수를 전달할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="58b2c6378bac42febc100a9e0341d2094c29e52e" translate="yes" xml:space="preserve">
          <source>Finally it possible to set the next message to deliver using the &lt;code&gt;SETID&lt;/code&gt; subcommand. Normally the next ID is set when the consumer is created, as the last argument of &lt;code&gt;XGROUP CREATE&lt;/code&gt;. However using this form the next ID can be modified later without deleting and creating the consumer group again. For instance if you want the consumers in a consumer group to re-process all the messages in a stream, you may want to set its next ID to 0:</source>
          <target state="translated">마지막으로 &lt;code&gt;SETID&lt;/code&gt; 부속 명령을 사용하여 전달할 다음 메시지를 설정할 수 있습니다 . 일반적으로 다음 ID는 소비자가 생성 될 때 &lt;code&gt;XGROUP CREATE&lt;/code&gt; 의 마지막 인수로 설정됩니다 . 그러나이 양식을 사용하면 소비자 그룹을 삭제하거나 다시 만들지 않고 다음 ID를 나중에 수정할 수 있습니다. 예를 들어 소비자 그룹의 소비자가 스트림의 모든 메시지를 다시 처리하도록하려면 다음 ID를 0으로 설정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8081b937f79256e42e7fd856b20cf39a90419c3e" translate="yes" xml:space="preserve">
          <source>Finally to get some help if you don't remember the syntax, use the HELP subcommand:</source>
          <target state="translated">구문을 기억하지 못하는 경우 도움을 받으려면 HELP 부속 명령을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="fc63c9b0ba92886f08fc9cdd2dca430983266b7e" translate="yes" xml:space="preserve">
          <source>First Key in Argument List</source>
          <target state="translated">인수 목록의 첫 번째 키</target>
        </trans-unit>
        <trans-unit id="a8e315abf463cfb1c344b54fca5c387403cc9c5a" translate="yes" xml:space="preserve">
          <source>First replica of master for slot range</source>
          <target state="translated">슬롯 범위에 대한 마스터의 첫 번째 복제본</target>
        </trans-unit>
        <trans-unit id="5d728758adcdd5154d3be55552c1c061ef1489b2" translate="yes" xml:space="preserve">
          <source>Flags</source>
          <target state="translated">Flags</target>
        </trans-unit>
        <trans-unit id="4e0b6894626b05a7f879581f17814069cc8b9e6d" translate="yes" xml:space="preserve">
          <source>Flush the Append Only File if AOF is enabled.</source>
          <target state="translated">AOF가 활성화 된 경우 추가 전용 파일을 비 웁니다.</target>
        </trans-unit>
        <trans-unit id="3b424754326ab3315277697bc94804652181fadd" translate="yes" xml:space="preserve">
          <source>Flush the Lua scripts cache.</source>
          <target state="translated">Lua 스크립트 캐시를 비 웁니다.</target>
        </trans-unit>
        <trans-unit id="f6bb844e2e06d69091cb567be5df64888a2d1098" translate="yes" xml:space="preserve">
          <source>Flushes all previously queued commands in a &lt;a href=&quot;https://redis.io/topics/transactions&quot;&gt;transaction&lt;/a&gt; and restores the connection state to normal.</source>
          <target state="translated">&lt;a href=&quot;https://redis.io/topics/transactions&quot;&gt;트랜잭션&lt;/a&gt; 에서 이전에 대기 한 모든 명령을 플러시 하고 연결 상태를 정상으로 복원합니다.</target>
        </trans-unit>
        <trans-unit id="8c64c01f5213c6c086d3f83c900e781d98a8b4d5" translate="yes" xml:space="preserve">
          <source>Flushes all the previously watched keys for a &lt;a href=&quot;https://redis.io/topics/transactions&quot;&gt;transaction&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;https://redis.io/topics/transactions&quot;&gt;트랜잭션에&lt;/a&gt; 대해 이전에 본 모든 키를 플러시 합니다 .</target>
        </trans-unit>
        <trans-unit id="e859a22c051906372e6ed21806faadd4fdf27b1c" translate="yes" xml:space="preserve">
          <source>For Redis 2.6 what happens is that the command performing multiple pushes is executed, and &lt;em&gt;only after&lt;/em&gt; the execution of the command the blocked clients are served. Consider this sequence of commands.</source>
          <target state="translated">Redis 2.6의 경우 다중 푸시를 수행하는 명령이 실행되고 명령 실행 &lt;em&gt;후에 만&lt;/em&gt; 차단 된 클라이언트가 제공됩니다. 이 명령 순서를 고려하십시오.</target>
        </trans-unit>
        <trans-unit id="c9543ba9d8e4550fc68513216cde163b99c314dc" translate="yes" xml:space="preserve">
          <source>For a description of the &lt;code&gt;WEIGHTS&lt;/code&gt; and &lt;code&gt;AGGREGATE&lt;/code&gt; options, see &lt;a href=&quot;zunionstore&quot;&gt;ZUNIONSTORE&lt;/a&gt;.</source>
          <target state="translated">의 설명은 &lt;code&gt;WEIGHTS&lt;/code&gt; 와 &lt;code&gt;AGGREGATE&lt;/code&gt; 옵션을 참조 &lt;a href=&quot;zunionstore&quot;&gt;ZUNIONSTORE을&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="9618151d729f751e6074523159514ecdfdb57ef1" translate="yes" xml:space="preserve">
          <source>For an introduction to HyperLogLog data structure check the &lt;a href=&quot;pfcount&quot;&gt;PFCOUNT&lt;/a&gt; command page.</source>
          <target state="translated">HyperLogLog 데이터 구조에 대한 소개는 &lt;a href=&quot;pfcount&quot;&gt;PFCOUNT&lt;/a&gt; 명령 페이지를 확인 하십시오.</target>
        </trans-unit>
        <trans-unit id="6fcc6360d01cc6597619a76bd12e34dfa8c068d5" translate="yes" xml:space="preserve">
          <source>For an introduction to sorted sets, see the data types page on &lt;a href=&quot;https://redis.io/topics/data-types#sorted-sets&quot;&gt;sorted sets&lt;/a&gt;.</source>
          <target state="translated">정렬 된 세트에 대한 소개의 데이터 유형 페이지를 참조 &lt;a href=&quot;https://redis.io/topics/data-types#sorted-sets&quot;&gt;분류 세트를&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="9e36005d4ed916277f75df55af354619d0ef5d5b" translate="yes" xml:space="preserve">
          <source>For each command type, the following line is added:</source>
          <target state="translated">각 명령 유형에 대해 다음 행이 추가됩니다.</target>
        </trans-unit>
        <trans-unit id="e6d8b4b7b9b4f1b118134e1b85eed9b0b1555262" translate="yes" xml:space="preserve">
          <source>For each consumer group listed the command also shows the number of consumers known in that group and the pending messages (delivered but not yet acknowledged) in that group.</source>
          <target state="translated">나열된 각 소비자 그룹에 대해이 명령은 해당 그룹에 알려진 소비자 수와 해당 그룹에 보류중인 메시지 (전달되었지만 아직 승인되지 않은 메시지)도 표시합니다.</target>
        </trans-unit>
        <trans-unit id="2f01796f139a1dd83db65e8858f0ea9b62d77fdf" translate="yes" xml:space="preserve">
          <source>For each database, the following line is added:</source>
          <target state="translated">각 데이터베이스에 대해 다음 줄이 추가됩니다.</target>
        </trans-unit>
        <trans-unit id="0553e67e4dc3e5df5405dbaf017a41c48cd92358" translate="yes" xml:space="preserve">
          <source>For each replica, the following line is added:</source>
          <target state="translated">각 복제본에 대해 다음 줄이 추가됩니다.</target>
        </trans-unit>
        <trans-unit id="4121db15148ef3ce1e89f4557d512e7c05a4cd89" translate="yes" xml:space="preserve">
          <source>For every &lt;code&gt;field&lt;/code&gt; that does not exist in the hash, a &lt;code&gt;nil&lt;/code&gt; value is returned. Because non-existing keys are treated as empty hashes, running &lt;a href=&quot;hmget&quot;&gt;HMGET&lt;/a&gt; against a non-existing &lt;code&gt;key&lt;/code&gt; will return a list of &lt;code&gt;nil&lt;/code&gt; values.</source>
          <target state="translated">해시에 존재하지 않는 모든 &lt;code&gt;field&lt;/code&gt; 에 대해 &lt;code&gt;nil&lt;/code&gt; 값이 반환됩니다. 존재하지 않는 키를 실행, 비어있는 해시로 취급되기 때문에 &lt;a href=&quot;hmget&quot;&gt;HMGET을&lt;/a&gt; 존재하지 않는에 대한 &lt;code&gt;key&lt;/code&gt; 의 목록이 반환됩니다 &lt;code&gt;nil&lt;/code&gt; 값을.</target>
        </trans-unit>
        <trans-unit id="910c18521d782016253b4584c3c1718149e1c25d" translate="yes" xml:space="preserve">
          <source>For example a common problem when implementing Markov chains and other algorithms is to select an element at random from a set, but different elements may have different weights that change how likely it is they are picked.</source>
          <target state="translated">예를 들어 Markov 체인 및 기타 알고리즘을 구현할 때 일반적으로 발생하는 문제는 집합에서 임의의 요소를 임의로 선택하는 것이지만 요소마다 선택 될 가능성을 변경하는 가중치가 다를 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="00e8032c1c0863c866e402146d15139ddaca7eea" translate="yes" xml:space="preserve">
          <source>For example in order to take the count of all the unique search queries performed in a day, a program needs to call &lt;a href=&quot;pfadd&quot;&gt;PFADD&lt;/a&gt; every time a query is processed. The estimated number of unique queries can be retrieved with &lt;a href=&quot;pfcount&quot;&gt;PFCOUNT&lt;/a&gt; at any time.</source>
          <target state="translated">예를 들어 하루에 수행 된 모든 고유 검색 쿼리의 수를 계산하려면 쿼리가 처리 될 때마다 프로그램이 &lt;a href=&quot;pfadd&quot;&gt;PFADD&lt;/a&gt; 를 호출해야 합니다. &lt;a href=&quot;pfcount&quot;&gt;PFCOUNT를 사용&lt;/a&gt; 하여 언제든지 예상되는 고유 쿼리 수를 검색 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="862ca7fa622c308433f665edc841f44e39e5d232" translate="yes" xml:space="preserve">
          <source>For example the following command assigns slots 1 2 3 to the node receiving the command:</source>
          <target state="translated">예를 들어 다음 명령은 슬롯 1 2 3을 명령을 수신하는 노드에 할당합니다.</target>
        </trans-unit>
        <trans-unit id="b525686b0a28b28e11781b09afa87dd48c9db63b" translate="yes" xml:space="preserve">
          <source>For example the following command increments an 8 bit signed integer at bit offset 100, and gets the value of the 4 bit unsigned integer at bit offset 0:</source>
          <target state="translated">예를 들어 다음 명령은 비트 오프셋 100에서 8 비트 부호있는 정수를 증가시키고 비트 오프셋 0에서 4 비트 부호없는 정수의 값을 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="a97e5209e5c4a8fe8fdeedf84b0123aa8fa78b8b" translate="yes" xml:space="preserve">
          <source>For example the following command will trim the stream to exactly the latest 1000 items:</source>
          <target state="translated">예를 들어 다음 명령은 스트림을 정확히 최신 1000 개 항목으로 자릅니다.</target>
        </trans-unit>
        <trans-unit id="bb5422e2190f7f64ad2cf5faf5279a8730064c02" translate="yes" xml:space="preserve">
          <source>For example, &lt;code&gt;LREM list -2 &quot;hello&quot;&lt;/code&gt; will remove the last two occurrences of &lt;code&gt;&quot;hello&quot;&lt;/code&gt; in the list stored at &lt;code&gt;list&lt;/code&gt;.</source>
          <target state="translated">예를 들어, &lt;code&gt;LREM list -2 &quot;hello&quot;&lt;/code&gt; 는 list에 저장된 목록에서 &lt;code&gt;&quot;hello&quot;&lt;/code&gt; 의 마지막 두 항목을 제거 &lt;code&gt;list&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b555dc3155500027017fa2a4b40d9e13b0289813" translate="yes" xml:space="preserve">
          <source>For example, if I have two streams &lt;code&gt;mystream&lt;/code&gt; and &lt;code&gt;writers&lt;/code&gt;, and I want to read data from both the streams starting from the first element they contain, I could call &lt;a href=&quot;xread&quot;&gt;XREAD&lt;/a&gt; like in the following example.</source>
          <target state="translated">예를 들어 &lt;code&gt;mystream&lt;/code&gt; 과 &lt;code&gt;writers&lt;/code&gt; 두 개의 스트림이 있고 포함 된 첫 번째 요소에서 시작하여 두 스트림 모두에서 데이터를 읽으려면 다음 예제와 같이 &lt;a href=&quot;xread&quot;&gt;XREAD를&lt;/a&gt; 호출 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="059c3e8cce263b2945a18ac90b2637e10a8026b1" translate="yes" xml:space="preserve">
          <source>For example:</source>
          <target state="translated">예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="d36a4d27e7c4e26652f2b3ff43e697bb99cdbe49" translate="yes" xml:space="preserve">
          <source>For example: &lt;code&gt;LTRIM foobar 0 2&lt;/code&gt; will modify the list stored at &lt;code&gt;foobar&lt;/code&gt; so that only the first three elements of the list will remain.</source>
          <target state="translated">예를 들면 : &lt;code&gt;LTRIM foobar 0 2&lt;/code&gt; 는 &lt;code&gt;foobar&lt;/code&gt; 에 저장된 목록을 수정하여 목록 의 처음 세 요소 만 남게됩니다.</target>
        </trans-unit>
        <trans-unit id="aac3daaf191be281b6ccb464e390234af5058fcd" translate="yes" xml:space="preserve">
          <source>For example: consider &lt;code&gt;source&lt;/code&gt; holding the list &lt;code&gt;a,b,c&lt;/code&gt;, and &lt;code&gt;destination&lt;/code&gt; holding the list &lt;code&gt;x,y,z&lt;/code&gt;. Executing &lt;a href=&quot;rpoplpush&quot;&gt;RPOPLPUSH&lt;/a&gt; results in &lt;code&gt;source&lt;/code&gt; holding &lt;code&gt;a,b&lt;/code&gt; and &lt;code&gt;destination&lt;/code&gt; holding &lt;code&gt;c,x,y,z&lt;/code&gt;.</source>
          <target state="translated">예를 들어 : 목록 &lt;code&gt;a,b,c&lt;/code&gt; 를 보유한 &lt;code&gt;source&lt;/code&gt; 와 목록 &lt;code&gt;x,y,z&lt;/code&gt; 를 보유한 &lt;code&gt;destination&lt;/code&gt; 를 고려하십시오 . &lt;a href=&quot;rpoplpush&quot;&gt;RPOPLPUSH&lt;/a&gt; 를 실행 하면 &lt;code&gt;source&lt;/code&gt; 가 &lt;code&gt;a,b&lt;/code&gt; 를 보유 하고 &lt;code&gt;destination&lt;/code&gt; &lt;code&gt;c,x,y,z&lt;/code&gt; 를 보유 합니다.</target>
        </trans-unit>
        <trans-unit id="b9a6b3077ebbc22869bdfb44c11c89f9170d1471" translate="yes" xml:space="preserve">
          <source>For expires to work well, the computer time must be taken stable. If you move an RDB file from two computers with a big desync in their clocks, funny things may happen (like all the keys loaded to be expired at loading time).</source>
          <target state="translated">만료가 제대로 작동하려면 컴퓨터 시간이 안정되어 있어야합니다. 시계가 크게 비 동기화 된 두 컴퓨터에서 RDB 파일을 이동하면로드 된 모든 키가로드시 만료되는 것처럼 재미있는 일이 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f28bf0b4c581b256fa3b954009c5dc47ca8cc986" translate="yes" xml:space="preserve">
          <source>For further information about Redis streams please check our &lt;a href=&quot;https://redis.io/topics/streams-intro&quot;&gt;introduction to Redis Streams document&lt;/a&gt;.</source>
          <target state="translated">Redis 스트림에 대한 자세한 내용은 Redis 스트림 &lt;a href=&quot;https://redis.io/topics/streams-intro&quot;&gt;소개 문서&lt;/a&gt; 를 확인하십시오 .</target>
        </trans-unit>
        <trans-unit id="9419f194b12efba96ec9e9a8a47640ef77051d15" translate="yes" xml:space="preserve">
          <source>For instance an application with a persistent connection to Redis can be sure that if a script was sent once it is still in memory, so EVALSHA can be used against those scripts in a pipeline without the chance of an error being generated due to an unknown script (we'll see this problem in detail later).</source>
          <target state="translated">예를 들어 Redis에 지속적으로 연결된 응용 프로그램은 스크립트가 메모리에 있으면 스크립트가 전송 된 경우 알 수없는 스크립트로 인해 오류가 발생하지 않고 파이프 라인의 해당 스크립트에 대해 EVALSHA를 사용할 수 있음을 확인할 수 있습니다. (이 문제는 나중에 자세히 볼 것입니다).</target>
        </trans-unit>
        <trans-unit id="dc915bb7cfa9bbec54b9f20262e4f69d0c2936e5" translate="yes" xml:space="preserve">
          <source>For instance in the above example, the last items that we received for the stream &lt;code&gt;mystream&lt;/code&gt; has ID &lt;code&gt;1526999352406-0&lt;/code&gt;, while for the stream &lt;code&gt;writers&lt;/code&gt; has the ID &lt;code&gt;1526985685298-0&lt;/code&gt;.</source>
          <target state="translated">예를 들어, 위 예제에서 &lt;code&gt;mystream&lt;/code&gt; 스트림에 대해 마지막으로 수신 한 항목의 ID는 &lt;code&gt;1526999352406-0&lt;/code&gt; 이고 스트림 &lt;code&gt;writers&lt;/code&gt; 경우 ID가 &lt;code&gt;1526985685298-0&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="abfec42c58b79c70de1796787342d5de058e9f11" translate="yes" xml:space="preserve">
          <source>For instance what in &lt;code&gt;redis.conf&lt;/code&gt; looks like:</source>
          <target state="translated">예를 들어 &lt;code&gt;redis.conf&lt;/code&gt; 의 내용 은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="310775bb715bff8a1231237bf82d220b152e2252" translate="yes" xml:space="preserve">
          <source>For instance when Redis is used in order to implement a queue, producers and consumers of messages may want to set the name of the connection according to their role.</source>
          <target state="translated">예를 들어, 큐를 구현하기 위해 Redis를 사용하는 경우 메시지 생성자 및 소비자는 역할에 따라 연결 이름을 설정하려고 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4d1d2a650d31219d2da12b4e4c6aaa52db811850" translate="yes" xml:space="preserve">
          <source>For most commands the first key is position 1. Position 0 is always the command name itself.</source>
          <target state="translated">대부분의 명령에서 첫 번째 키는 위치 1입니다. 위치 0은 항상 명령 이름 자체입니다.</target>
        </trans-unit>
        <trans-unit id="f3b735d69f1d53bb920c323089af35c7960cd5bc" translate="yes" xml:space="preserve">
          <source>For nested data types, the optional &lt;code&gt;SAMPLES&lt;/code&gt; option can be provided, where &lt;code&gt;count&lt;/code&gt; is the number of sampled nested values. By default, this option is set to &lt;code&gt;5&lt;/code&gt;. To sample the all of the nested values, use &lt;code&gt;SAMPLES 0&lt;/code&gt;.</source>
          <target state="translated">중첩 데이터 유형의 경우 선택적 &lt;code&gt;SAMPLES&lt;/code&gt; 옵션을 제공 할 수 있습니다. 여기서 &lt;code&gt;count&lt;/code&gt; 는 샘플링 된 중첩 값의 수입니다. 기본적으로이 옵션은 &lt;code&gt;5&lt;/code&gt; 로 설정되어 있습니다. 모든 중첩 값을 샘플링하려면 &lt;code&gt;SAMPLES 0&lt;/code&gt; 을 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="29cc98c67031f5feb4c8c0734d6bcf119180ebd0" translate="yes" xml:space="preserve">
          <source>For real-time metrics and statistics involving large inputs a good approach is to use a replica (with read-only option disabled) where the bit-wise operations are performed to avoid blocking the master instance.</source>
          <target state="translated">대규모 입력이 포함 된 실시간 메트릭 및 통계의 경우 마스터 인스턴스 차단을 피하기 위해 비트 단위 작업이 수행되는 복제본 (읽기 전용 옵션이 비활성화 된 상태)을 사용하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="86c11a7ed67c320eacf7f860ba9da8b316757034" translate="yes" xml:space="preserve">
          <source>For security concerns, certain special administration commands like &lt;code&gt;CONFIG&lt;/code&gt; are not logged into the &lt;a href=&quot;monitor&quot;&gt;MONITOR&lt;/a&gt; output.</source>
          <target state="translated">보안상의 이유로 &lt;code&gt;CONFIG&lt;/code&gt; 와 같은 특정 특수 관리 명령 은 &lt;a href=&quot;monitor&quot;&gt;MONITOR&lt;/a&gt; 출력에 로그인되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="1d4a1b4aeeb486fd399846319b2294f91ddedb8b" translate="yes" xml:space="preserve">
          <source>For this reason, Redis 3.2 introduces a new command that only works when script effects replication is enabled, and is able to control the scripting replication engine. The command is called &lt;code&gt;redis.set_repl()&lt;/code&gt; and fails raising an error if called when script effects replication is disabled.</source>
          <target state="translated">이러한 이유로 Redis 3.2에는 스크립트 효과 복제가 활성화 된 경우에만 작동하고 스크립팅 복제 엔진을 제어 할 수있는 새로운 명령이 도입되었습니다. 이 명령을 &lt;code&gt;redis.set_repl()&lt;/code&gt; 이라고하며 스크립트 효과 복제가 비활성화 된 경우 호출되면 오류가 발생하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="51865baeeba9dd27720c605912d3014b8edbbb78" translate="yes" xml:space="preserve">
          <source>Forces a node to save the &lt;code&gt;nodes.conf&lt;/code&gt; configuration on disk. Before to return the command calls &lt;code&gt;fsync(2)&lt;/code&gt; in order to make sure the configuration is flushed on the computer disk.</source>
          <target state="translated">노드가 디스크에 &lt;code&gt;nodes.conf&lt;/code&gt; 구성 을 저장 하도록합니다. 명령을 리턴하기 전에 구성이 컴퓨터 디스크에서 플러시되는지 확인하기 위해 &lt;code&gt;fsync(2)&lt;/code&gt; 를 호출 하십시오.</target>
        </trans-unit>
        <trans-unit id="620cbfd5798a03238a582c36dc6180b1d68a8181" translate="yes" xml:space="preserve">
          <source>Fortunately, it's possible to avoid this issue using the following algorithm. Let's see how C4, our sane client, uses the good algorithm:</source>
          <target state="translated">다행히도 다음 알고리즘을 사용하여이 문제를 피할 수 있습니다. 제정신 클라이언트 인 C4가 어떻게 좋은 알고리즘을 사용하는지 봅시다 :</target>
        </trans-unit>
        <trans-unit id="e02d5afefc425c600d8eecdd85f79d3604e46010" translate="yes" xml:space="preserve">
          <source>From the point of view of the syntax, the commands are almost the same, however &lt;a href=&quot;xreadgroup&quot;&gt;XREADGROUP&lt;/a&gt;&lt;em&gt;requires&lt;/em&gt; a special and mandatory option:</source>
          <target state="translated">구문의 관점에서 보면 명령은 거의 동일하지만 &lt;a href=&quot;xreadgroup&quot;&gt;XREADGROUP &lt;/a&gt;&lt;em&gt;에는&lt;/em&gt; 특수하고 필수 옵션이 &lt;em&gt;필요&lt;/em&gt; 합니다.</target>
        </trans-unit>
        <trans-unit id="86f3ae974780a50a7664a8c324379a24cfdab877" translate="yes" xml:space="preserve">
          <source>Fun fact: Reddit's 2017 April fools' project &lt;a href=&quot;https://reddit.com/r/place&quot;&gt;r/place&lt;/a&gt; was &lt;a href=&quot;https://redditblog.com/2017/04/13/how-we-built-rplace/&quot;&gt;built using the Redis BITFIELD command&lt;/a&gt; in order to take an in-memory representation of the collaborative canvas.</source>
          <target state="translated">재미있는 사실 : Reddit의 2017 년 4 월 바보 프로젝트 &lt;a href=&quot;https://reddit.com/r/place&quot;&gt;r / place&lt;/a&gt; 는 &lt;a href=&quot;https://redditblog.com/2017/04/13/how-we-built-rplace/&quot;&gt;Redis BITFIELD 명령&lt;/a&gt; 을 사용 하여 협업 캔버스를 메모리 내에서 표현하기 위해 작성되었습니다.</target>
        </trans-unit>
        <trans-unit id="29ad85263278e1f788abee93dcd93c6b5f400940" translate="yes" xml:space="preserve">
          <source>GEOADD</source>
          <target state="translated">GEOADD</target>
        </trans-unit>
        <trans-unit id="fe36dd170b2d009a6fb9b3209da995c6be0a8014" translate="yes" xml:space="preserve">
          <source>GEOADD  key longitude latitude member [longitude latitude member ...]   Add one or more geospatial items in the geospatial index represented using a sorted set</source>
          <target state="translated">GEOADD 키 경도 위도 멤버 [경도 위도 멤버 ...] 정렬 된 세트를 사용하여 나타내는 지리 공간 인덱스에 하나 이상의 지리 공간 항목을 추가합니다.</target>
        </trans-unit>
        <trans-unit id="9aee98cec79ef9607b17d14a98e26344f2559e24" translate="yes" xml:space="preserve">
          <source>GEODIST</source>
          <target state="translated">GEODIST</target>
        </trans-unit>
        <trans-unit id="0a8e4fd28c6ceedcd2cf757094650298262be7f7" translate="yes" xml:space="preserve">
          <source>GEODIST  key member1 member2 [unit]   Returns the distance between two members of a geospatial index</source>
          <target state="translated">GEODIST 키 멤버 1 member2 [단위] 지리 공간 인덱스의 두 멤버 사이의 거리를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="d944f228d17ba584e232ef6b37a2330565210913" translate="yes" xml:space="preserve">
          <source>GEOHASH</source>
          <target state="translated">GEOHASH</target>
        </trans-unit>
        <trans-unit id="15d5ff901e592f20465c4a81d62cdf535660ac71" translate="yes" xml:space="preserve">
          <source>GEOHASH  key member [member ...]   Returns members of a geospatial index as standard geohash strings</source>
          <target state="translated">GEOHASH 키 멤버 [member ...] 지리 공간 인덱스의 멤버를 표준 geohash 문자열로 반환합니다.</target>
        </trans-unit>
        <trans-unit id="567f488d82e3265931365c2760b37b40e268471e" translate="yes" xml:space="preserve">
          <source>GEOPOS</source>
          <target state="translated">GEOPOS</target>
        </trans-unit>
        <trans-unit id="681795a057130a9988e5c024a1915dc60c2ecb58" translate="yes" xml:space="preserve">
          <source>GEOPOS  key member [member ...]   Returns longitude and latitude of members of a geospatial index</source>
          <target state="translated">GEOPOS 키 멤버 [member ...] 지리 공간 인덱스 멤버의 경도와 위도를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="f883ad1ea5b9628a7c035af52696e8e216f48428" translate="yes" xml:space="preserve">
          <source>GEORADIUS</source>
          <target state="translated">GEORADIUS</target>
        </trans-unit>
        <trans-unit id="78a8e700f33e02c64280e94efe97493736549c5c" translate="yes" xml:space="preserve">
          <source>GEORADIUS  key longitude latitude radius m|km|ft|mi [WITHCOORD] [WITHDIST] [WITHHASH] [COUNT count] [ASC|DESC] [STORE key] [STOREDIST key]   Query a sorted set representing a geospatial index to fetch members matching a given maximum distance from a point</source>
          <target state="translated">GEORADIUS 키 경도 위도 반경 m | km | ft | mi [WITHCOORD] [WITHDIST] [WITHHASH] [COUNT 수] [ASC | DESC] [STORE 키] [STOREDIST 키] 일치하는 멤버를 가져 오기 위해 지리 공간 인덱스를 나타내는 정렬 된 세트를 쿼리합니다. 점으로부터 주어진 최대 거리</target>
        </trans-unit>
        <trans-unit id="ae4c6b87ec31f7b6af274155550a43bc379afb42" translate="yes" xml:space="preserve">
          <source>GEORADIUSBYMEMBER</source>
          <target state="translated">GEORADIUSBYMEMBER</target>
        </trans-unit>
        <trans-unit id="cf98dab16a680969ed5a7c59dd91c064dd5ffd22" translate="yes" xml:space="preserve">
          <source>GEORADIUSBYMEMBER  key member radius m|km|ft|mi [WITHCOORD] [WITHDIST] [WITHHASH] [COUNT count] [ASC|DESC] [STORE key] [STOREDIST key]   Query a sorted set representing a geospatial index to fetch members matching a given maximum distance from a member</source>
          <target state="translated">GEORADIUSBYMEMBER 키 멤버 반경 m | km | ft | mi [WITHCOORD] [WITHDIST] [WITHHASH] [COUNT 수] [ASC | DESC] [STORE 키] [STOREDIST 키] 지리 공간 인덱스를 나타내는 정렬 된 세트를 쿼리하여 멤버로부터 주어진 최대 거리</target>
        </trans-unit>
        <trans-unit id="f030bbbd32966cde41037b98a8849c46b76e4bc1" translate="yes" xml:space="preserve">
          <source>GET</source>
          <target state="translated">GET</target>
        </trans-unit>
        <trans-unit id="7d7f9a21ff2fe871d6f138989249c29532bb7fdc" translate="yes" xml:space="preserve">
          <source>GET  key   Get the value of a key</source>
          <target state="translated">GET 키 키 값 얻기</target>
        </trans-unit>
        <trans-unit id="ef9841e66f1ceb2a8ca3c4b61209bfb1ccb07d46" translate="yes" xml:space="preserve">
          <source>GETBIT</source>
          <target state="translated">GETBIT</target>
        </trans-unit>
        <trans-unit id="c67560b598b48f8d8597f643fcac2a09acec11dd" translate="yes" xml:space="preserve">
          <source>GETBIT  key offset   Returns the bit value at offset in the string value stored at key</source>
          <target state="translated">GETBIT 키 오프셋 키에 저장된 문자열 값에서 오프셋의 비트 값을 반환합니다</target>
        </trans-unit>
        <trans-unit id="171dc01acd21b14b16885f344959333f303f7868" translate="yes" xml:space="preserve">
          <source>GETRANGE</source>
          <target state="translated">GETRANGE</target>
        </trans-unit>
        <trans-unit id="120d6e3c8bea25d9ffe941d0b9d148464db210c6" translate="yes" xml:space="preserve">
          <source>GETRANGE  key start end   Get a substring of the string stored at a key</source>
          <target state="translated">GETRANGE key start end 키에 저장된 문자열의 부분 문자열을 가져옵니다</target>
        </trans-unit>
        <trans-unit id="6a4472582074006f8a0d04a695a91bfb64d3f211" translate="yes" xml:space="preserve">
          <source>GETSET</source>
          <target state="translated">GETSET</target>
        </trans-unit>
        <trans-unit id="ea14ecdc443c7b2197bfb8f599d84d9e3ddc91a9" translate="yes" xml:space="preserve">
          <source>GETSET  key value   Set the string value of a key and return its old value</source>
          <target state="translated">GETSET 키 값 키의 문자열 값을 설정하고 이전 값을 반환</target>
        </trans-unit>
        <trans-unit id="0f33bfb55b7c38358e7fef810b5a8c3a19e508c9" translate="yes" xml:space="preserve">
          <source>Generate a new &lt;code&gt;configEpoch&lt;/code&gt; unilaterally, just taking the current greatest epoch available and incrementing it if its local configuration epoch is not already the greatest.</source>
          <target state="translated">현재 사용 가능한 가장 큰 에포크를 가져 와서 로컬 구성 에포크가 아직 크지 않은 경우 증가 &lt;code&gt;configEpoch&lt;/code&gt; 새로운 ConfigEpoch를 일방적으로 생성 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8770e1d00765da154add27070eb66b76abb639e9" translate="yes" xml:space="preserve">
          <source>Geo</source>
          <target state="translated">Geo</target>
        </trans-unit>
        <trans-unit id="00754e7ec718eca2346352874423afcfcd99de6c" translate="yes" xml:space="preserve">
          <source>Geohash string properties</source>
          <target state="translated">지오 해시 문자열 속성</target>
        </trans-unit>
        <trans-unit id="fcba9fe6c6b3ee7a7679d8a80f01c177efafb91f" translate="yes" xml:space="preserve">
          <source>Get keys from the source node with &lt;a href=&quot;cluster-getkeysinslot&quot;&gt;CLUSTER GETKEYSINSLOT&lt;/a&gt; command and move them into the destination node using the &lt;a href=&quot;migrate&quot;&gt;MIGRATE&lt;/a&gt; command.</source>
          <target state="translated">&lt;a href=&quot;cluster-getkeysinslot&quot;&gt;CLUSTER GETKEYSINSLOT&lt;/a&gt; 명령으로 소스 노드에서 키를 가져 오고 &lt;a href=&quot;migrate&quot;&gt;MIGRATE&lt;/a&gt; 명령을 사용하여 대상 노드로 키를 이동하십시오 .</target>
        </trans-unit>
        <trans-unit id="09aec2d48c2bf33e9f4de1efe0b69e4c3361c2f6" translate="yes" xml:space="preserve">
          <source>Get the value of &lt;code&gt;key&lt;/code&gt;. If the key does not exist the special value &lt;code&gt;nil&lt;/code&gt; is returned. An error is returned if the value stored at &lt;code&gt;key&lt;/code&gt; is not a string, because &lt;a href=&quot;get&quot;&gt;GET&lt;/a&gt; only handles string values.</source>
          <target state="translated">&lt;code&gt;key&lt;/code&gt; 값을 얻습니다 . 키가 존재하지 않으면 특수 값 &lt;code&gt;nil&lt;/code&gt; 이 리턴됩니다. &lt;a href=&quot;get&quot;&gt;GET&lt;/a&gt; 은 문자열 값만 처리 하므로 &lt;code&gt;key&lt;/code&gt; 에 저장된 값 이 문자열이 아닌 경우 오류가 리턴됩니다 .</target>
        </trans-unit>
        <trans-unit id="4f07c68cfde1cce4484071399ec3dcac10ef3226" translate="yes" xml:space="preserve">
          <source>Given a list of SHA1 digests as arguments this command returns an array of 1 or 0, where 1 means the specific SHA1 is recognized as a script already present in the scripting cache, while 0 means that a script with this SHA1 was never seen before (or at least never seen after the latest SCRIPT FLUSH command).</source>
          <target state="translated">SHA1 다이제스트 목록을 인수로 지정하면이 명령은 1 또는 0의 배열을 리턴합니다. 여기서 1은 특정 SHA1이 스크립팅 캐시에 이미 존재하는 스크립트로 인식되고 0은이 SHA1이 포함 된 스크립트가 이전에 본 적이 없음을 의미합니다 ( 또는 최신 SCRIPT FLUSH 명령 이후에는 본 적이 없습니다.</target>
        </trans-unit>
        <trans-unit id="5e47705fe8d80f510ddf59025f5bedac0bd2d833" translate="yes" xml:space="preserve">
          <source>Given a sorted set representing a geospatial index, populated using the &lt;a href=&quot;geoadd&quot;&gt;GEOADD&lt;/a&gt; command, it is often useful to obtain back the coordinates of specified members. When the geospatial index is populated via &lt;a href=&quot;geoadd&quot;&gt;GEOADD&lt;/a&gt; the coordinates are converted into a 52 bit geohash, so the coordinates returned may not be exactly the ones used in order to add the elements, but small errors may be introduced.</source>
          <target state="translated">&lt;a href=&quot;geoadd&quot;&gt;GEOADD&lt;/a&gt; 명령을 사용하여 채워진 지리 공간 인덱스를 나타내는 정렬 된 세트가 주어지면 종종 지정된 멤버의 좌표를 다시 얻는 것이 유용합니다. 지리 공간 인덱스가 &lt;a href=&quot;geoadd&quot;&gt;GEOADD&lt;/a&gt; 를 통해 채워 지면 좌표가 52 비트 지오 해시로 변환되므로 반환 된 좌표가 요소를 추가하기 위해 사용 된 좌표가 아닐 수 있지만 작은 오류가 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1a98977aea8887ddd5a1edb60251e403b53795ab" translate="yes" xml:space="preserve">
          <source>Given a sorted set representing a geospatial index, populated using the &lt;a href=&quot;geoadd&quot;&gt;GEOADD&lt;/a&gt; command, the command returns the distance between the two specified members in the specified unit.</source>
          <target state="translated">&lt;a href=&quot;geoadd&quot;&gt;GEOADD&lt;/a&gt; 명령을 사용하여 채워진 지리 공간 색인을 나타내는 정렬 된 세트가 제공 되면 명령은 지정된 단위로 지정된 두 멤버 사이의 거리를 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="f45f257965d0c26e93bb5789953aca2dc751ef9e" translate="yes" xml:space="preserve">
          <source>Global variables protection</source>
          <target state="translated">글로벌 변수 보호</target>
        </trans-unit>
        <trans-unit id="15d1555c45e5fc58578080840f0c6368a6d6cb11" translate="yes" xml:space="preserve">
          <source>Guarantee of termination</source>
          <target state="translated">해지 보장</target>
        </trans-unit>
        <trans-unit id="5205aa5d3ee9c438b38044d5999ac4ba4201f832" translate="yes" xml:space="preserve">
          <source>HDEL</source>
          <target state="translated">HDEL</target>
        </trans-unit>
        <trans-unit id="f0d9eb5c49197bfd6feeb0c9d7b482f5e211f201" translate="yes" xml:space="preserve">
          <source>HDEL  key field [field ...]   Delete one or more hash fields</source>
          <target state="translated">HDEL 키 필드 [field ...] 하나 이상의 해시 필드 삭제</target>
        </trans-unit>
        <trans-unit id="b48dcfbcf4eca1611582a1cc8baa82d9d2fa2960" translate="yes" xml:space="preserve">
          <source>HEXISTS</source>
          <target state="translated">HEXISTS</target>
        </trans-unit>
        <trans-unit id="a807653048c48da53e448a2b285039ef0573aae8" translate="yes" xml:space="preserve">
          <source>HEXISTS  key field   Determine if a hash field exists</source>
          <target state="translated">HEXISTS 키 필드 해시 필드가 존재하는지 확인</target>
        </trans-unit>
        <trans-unit id="2aa481a50927484124964b6f73bac3881de47ff3" translate="yes" xml:space="preserve">
          <source>HGET</source>
          <target state="translated">HGET</target>
        </trans-unit>
        <trans-unit id="53e1681d3979ea38127102b70459b3a4ea647f65" translate="yes" xml:space="preserve">
          <source>HGET  key field   Get the value of a hash field</source>
          <target state="translated">HGET 키 필드 해시 필드 값 가져 오기</target>
        </trans-unit>
        <trans-unit id="0949fe15e4d07355cc1f8bdf2d7d0a3bc27e0498" translate="yes" xml:space="preserve">
          <source>HGETALL</source>
          <target state="translated">HGETALL</target>
        </trans-unit>
        <trans-unit id="a9f2d8c36ab9a92512a3abf304cf22c78a10d32a" translate="yes" xml:space="preserve">
          <source>HGETALL  key   Get all the fields and values in a hash</source>
          <target state="translated">HGETALL 키 해시의 모든 필드와 값을 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="bec3f40ebfc071338931e9ec346c383954f688e2" translate="yes" xml:space="preserve">
          <source>HINCRBY</source>
          <target state="translated">HINCRBY</target>
        </trans-unit>
        <trans-unit id="85ba7d4ce6a861db6587eaef82d0c559a1acad5a" translate="yes" xml:space="preserve">
          <source>HINCRBY  key field increment   Increment the integer value of a hash field by the given number</source>
          <target state="translated">HINCRBY 키 필드 증분 해시 필드의 정수 값을 주어진 숫자만큼 증가시킵니다.</target>
        </trans-unit>
        <trans-unit id="a93522c3800a73e9eb332f7f840625aacdc296f3" translate="yes" xml:space="preserve">
          <source>HINCRBYFLOAT</source>
          <target state="translated">HINCRBYFLOAT</target>
        </trans-unit>
        <trans-unit id="b074f9cd10320d76be5375524c56b4c4f5083f25" translate="yes" xml:space="preserve">
          <source>HINCRBYFLOAT  key field increment   Increment the float value of a hash field by the given amount</source>
          <target state="translated">HINCRBYFLOAT 키 필드 증분 해시 필드의 부동 소수점 값을 주어진 양만큼 증가시킵니다.</target>
        </trans-unit>
        <trans-unit id="a857392e173da21b13e4d3e033f1d7d6aadde58a" translate="yes" xml:space="preserve">
          <source>HKEYS</source>
          <target state="translated">HKEYS</target>
        </trans-unit>
        <trans-unit id="4880894873a3e4a3dcf54bf74bebf960afb44a7c" translate="yes" xml:space="preserve">
          <source>HKEYS  key   Get all the fields in a hash</source>
          <target state="translated">HKEYS 키 해시의 모든 필드 가져 오기</target>
        </trans-unit>
        <trans-unit id="4d36dfb03a6ecdea21a171dc0c30adebe8d01184" translate="yes" xml:space="preserve">
          <source>HLEN</source>
          <target state="translated">HLEN</target>
        </trans-unit>
        <trans-unit id="bcfcea9d003f5af07b2bb8099e2b496b1e9e832a" translate="yes" xml:space="preserve">
          <source>HLEN  key   Get the number of fields in a hash</source>
          <target state="translated">HLEN 키 해시의 필드 수를 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="480987a6e9c4e7cd1d65f5ffad4b88a1132f2c6f" translate="yes" xml:space="preserve">
          <source>HMGET</source>
          <target state="translated">HMGET</target>
        </trans-unit>
        <trans-unit id="5b7367a8f047e6e2ad4600495794ba1f6c7d8f47" translate="yes" xml:space="preserve">
          <source>HMGET  key field [field ...]   Get the values of all the given hash fields</source>
          <target state="translated">HMGET 키 필드 [field ...] 주어진 모든 해시 필드의 값을 가져옵니다</target>
        </trans-unit>
        <trans-unit id="fb5089ab3a0516d344f9de817ed332775e142279" translate="yes" xml:space="preserve">
          <source>HMSET</source>
          <target state="translated">HMSET</target>
        </trans-unit>
        <trans-unit id="b9ce7bb49b575eba9a143cb12bd3a727345953bd" translate="yes" xml:space="preserve">
          <source>HMSET  key field value [field value ...]   Set multiple hash fields to multiple values</source>
          <target state="translated">HMSET 키 필드 값 [field value ...] 여러 해시 필드를 여러 값으로 설정</target>
        </trans-unit>
        <trans-unit id="f36a969e90bd023793807636ddb180dde5956fd7" translate="yes" xml:space="preserve">
          <source>HSCAN</source>
          <target state="translated">HSCAN</target>
        </trans-unit>
        <trans-unit id="1f717593e9570c814ba25178e664e1d1c164122d" translate="yes" xml:space="preserve">
          <source>HSCAN  key cursor [MATCH pattern] [COUNT count]   Incrementally iterate hash fields and associated values</source>
          <target state="translated">HSCAN 키 커서 [MATCH 패턴] [COUNT 수] 해시 필드 및 관련 값을 증분 반복</target>
        </trans-unit>
        <trans-unit id="00cee6cf2b7799f7538096724dbd92d41cec6aeb" translate="yes" xml:space="preserve">
          <source>HSET</source>
          <target state="translated">HSET</target>
        </trans-unit>
        <trans-unit id="665396b991835984fc7e3e34cd2fe5312ecf417d" translate="yes" xml:space="preserve">
          <source>HSET  key field value   Set the string value of a hash field</source>
          <target state="translated">HSET 키 필드 값 해시 필드의 문자열 값을 설정하십시오.</target>
        </trans-unit>
        <trans-unit id="f08f81142bc45f390db40acaf0af8de40d5f8df0" translate="yes" xml:space="preserve">
          <source>HSETNX</source>
          <target state="translated">HSETNX</target>
        </trans-unit>
        <trans-unit id="8f0805bb5892aca6c147d761f188dcc8c135168b" translate="yes" xml:space="preserve">
          <source>HSETNX  key field value   Set the value of a hash field, only if the field does not exist</source>
          <target state="translated">HSETNX 키 필드 값 필드가 존재하지 않는 경우에만 해시 필드의 값을 설정하십시오.</target>
        </trans-unit>
        <trans-unit id="653e2c00767d7da99a4ad249e0220683a0f21927" translate="yes" xml:space="preserve">
          <source>HSTRLEN</source>
          <target state="translated">HSTRLEN</target>
        </trans-unit>
        <trans-unit id="bb8103389cfdcecf46656f06573ed3513c20d29d" translate="yes" xml:space="preserve">
          <source>HSTRLEN  key field   Get the length of the value of a hash field</source>
          <target state="translated">HSTRLEN 키 필드 해시 필드 값의 길이를 가져옵니다</target>
        </trans-unit>
        <trans-unit id="75c2a102095c5cfb3745c7635997fd6d46e1ed99" translate="yes" xml:space="preserve">
          <source>HVALS</source>
          <target state="translated">HVALS</target>
        </trans-unit>
        <trans-unit id="2cf3758bf2c3fcb0cf4699e1fad2c529e7f60c18" translate="yes" xml:space="preserve">
          <source>HVALS  key   Get all the values in a hash</source>
          <target state="translated">HVALS 키 해시의 모든 값 가져 오기</target>
        </trans-unit>
        <trans-unit id="1679a916ecf39377920740d5654170e7e20f04f9" translate="yes" xml:space="preserve">
          <source>Handling deadlocks</source>
          <target state="translated">교착 상태 처리</target>
        </trans-unit>
        <trans-unit id="17348a159bc90f6828002f9fa69a3bdc1006ad33" translate="yes" xml:space="preserve">
          <source>Handling of strings with different lengths</source>
          <target state="translated">길이가 다른 문자열 처리</target>
        </trans-unit>
        <trans-unit id="5551ebd48f7eaa66477f72c449e4b2ccfc0f9609" translate="yes" xml:space="preserve">
          <source>Hashes</source>
          <target state="translated">Hashes</target>
        </trans-unit>
        <trans-unit id="abef659c43351c90fc57bd2f1f2ca21c74a56b5c" translate="yes" xml:space="preserve">
          <source>Hashes can be encoded as &lt;code&gt;ziplist&lt;/code&gt; or &lt;code&gt;hashtable&lt;/code&gt;. The &lt;code&gt;ziplist&lt;/code&gt; is a special encoding used for small hashes.</source>
          <target state="translated">해시는 &lt;code&gt;ziplist&lt;/code&gt; 또는 &lt;code&gt;hashtable&lt;/code&gt; 로 인코딩 될 수 있습니다 . &lt;code&gt;ziplist&lt;/code&gt; 는 작은 해시에 사용되는 특별한 인코딩입니다.</target>
        </trans-unit>
        <trans-unit id="a9f98aceea4b6640fde4f0db2b67c8b62670525a" translate="yes" xml:space="preserve">
          <source>Helper functions to return Redis types</source>
          <target state="translated">Redis 유형을 반환하는 도우미 함수</target>
        </trans-unit>
        <trans-unit id="71f2a2c44b12e8d025ffdb0ba44d167f2eb32dc5" translate="yes" xml:space="preserve">
          <source>Here are a few conversion examples:</source>
          <target state="translated">다음은 몇 가지 변환 예입니다.</target>
        </trans-unit>
        <trans-unit id="bd16d98ee220a06318e7c2f0edf89d89e391fb27" translate="yes" xml:space="preserve">
          <source>Here is the description of fields for Redis &amp;gt;= 2.4.</source>
          <target state="translated">다음은 Redis&amp;gt; = 2.4에 대한 필드 설명입니다.</target>
        </trans-unit>
        <trans-unit id="1953d7d107ad4ade79603b02cdb1e8adc699e514" translate="yes" xml:space="preserve">
          <source>Here is the meaning of all fields in the &lt;strong&gt;clients&lt;/strong&gt; section:</source>
          <target state="translated">&lt;strong&gt;클라이언트&lt;/strong&gt; 섹션 에있는 모든 필드의 의미는 다음과 같습니다 .</target>
        </trans-unit>
        <trans-unit id="aa545dc398491c6907d2041f2ded31d190284a9f" translate="yes" xml:space="preserve">
          <source>Here is the meaning of all fields in the &lt;strong&gt;cpu&lt;/strong&gt; section:</source>
          <target state="translated">&lt;strong&gt;CPU&lt;/strong&gt; 섹션 의 모든 필드의 의미는 다음과 같습니다 .</target>
        </trans-unit>
        <trans-unit id="d3d5c7888fb0526434ccb545db7ed9e893e48b61" translate="yes" xml:space="preserve">
          <source>Here is the meaning of all fields in the &lt;strong&gt;memory&lt;/strong&gt; section:</source>
          <target state="translated">&lt;strong&gt;메모리&lt;/strong&gt; 섹션 에있는 모든 필드의 의미는 다음과 같습니다 .</target>
        </trans-unit>
        <trans-unit id="d1e56b526c805770cba7347f8a39b9426d10e67e" translate="yes" xml:space="preserve">
          <source>Here is the meaning of all fields in the &lt;strong&gt;persistence&lt;/strong&gt; section:</source>
          <target state="translated">&lt;strong&gt;지속성&lt;/strong&gt; 섹션 에있는 모든 필드의 의미는 다음과 같습니다 .</target>
        </trans-unit>
        <trans-unit id="799881fdedd2437b9e8155aa33f7576cc6d468a1" translate="yes" xml:space="preserve">
          <source>Here is the meaning of all fields in the &lt;strong&gt;replication&lt;/strong&gt; section:</source>
          <target state="translated">&lt;strong&gt;복제&lt;/strong&gt; 섹션 에있는 모든 필드의 의미는 다음과 같습니다 .</target>
        </trans-unit>
        <trans-unit id="0d613b28b44d140ea4afd266be689c2f86ce192d" translate="yes" xml:space="preserve">
          <source>Here is the meaning of all fields in the &lt;strong&gt;server&lt;/strong&gt; section:</source>
          <target state="translated">&lt;strong&gt;서버&lt;/strong&gt; 섹션 에있는 모든 필드의 의미는 다음과 같습니다 .</target>
        </trans-unit>
        <trans-unit id="9700349259df5577664d69e8579a5af99e65c52f" translate="yes" xml:space="preserve">
          <source>Here is the meaning of all fields in the &lt;strong&gt;stats&lt;/strong&gt; section:</source>
          <target state="translated">&lt;strong&gt;통계&lt;/strong&gt; 섹션 에있는 모든 필드의 의미는 다음과 같습니다 .</target>
        </trans-unit>
        <trans-unit id="4bd3033708ea4b8a6d1fbb504db04260b3b5e786" translate="yes" xml:space="preserve">
          <source>Here is the meaning of the fields:</source>
          <target state="translated">필드의 의미는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="4d96106a2b4866d88034cf3cbc99a16013a0e36c" translate="yes" xml:space="preserve">
          <source>Hint: it is possible to switch to a different key based on the current Unix time, in this way it is possible to have just a relatively small amount of samples per key, to avoid dealing with very big keys, and to make this pattern more friendly to be distributed across many Redis instances.</source>
          <target state="translated">힌트 : 현재 Unix 시간을 기준으로 다른 키로 전환 할 수 있습니다. 이러한 방식으로 키당 비교적 적은 양의 샘플을 가질 수 있으며, 큰 키를 다루지 않고이 패턴을 더 많이 만들 수 있습니다 많은 Redis 인스턴스에 배포 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="90ccd6497400b5576aeca1bd94af74aae1e0a250" translate="yes" xml:space="preserve">
          <source>History</source>
          <target state="translated">History</target>
        </trans-unit>
        <trans-unit id="b51e386256184dc34229a5ca92a34accb7024327" translate="yes" xml:space="preserve">
          <source>How Redis expires keys</source>
          <target state="translated">Redis가 키를 만료하는 방법</target>
        </trans-unit>
        <trans-unit id="e21860bf37328b97ebb0ddd904694c78e4a7b382" translate="yes" xml:space="preserve">
          <source>How does it work?</source>
          <target state="translated">어떻게 작동합니까?</target>
        </trans-unit>
        <trans-unit id="88559343d1f8627b05ed905092ec3f856b6418a7" translate="yes" xml:space="preserve">
          <source>How expires are handled in the replication link and AOF file</source>
          <target state="translated">복제 링크 및 AOF 파일에서 만료가 처리되는 방식</target>
        </trans-unit>
        <trans-unit id="a8dbfaf95083e1d6e63da157f09e95d8c10fa20f" translate="yes" xml:space="preserve">
          <source>How multiple clients blocked on a single stream are served</source>
          <target state="translated">단일 스트림에서 차단 된 여러 클라이언트가 제공되는 방법</target>
        </trans-unit>
        <trans-unit id="d5868df09b7eeb0561970a8e423e96c9ad849dbe" translate="yes" xml:space="preserve">
          <source>How to specify intervals</source>
          <target state="translated">구간을 지정하는 방법</target>
        </trans-unit>
        <trans-unit id="7a00a1128dbff721f5566b479531909bd1900b68" translate="yes" xml:space="preserve">
          <source>However because &lt;a href=&quot;scan&quot;&gt;SCAN&lt;/a&gt; has very little state associated (just the cursor) it has the following drawbacks:</source>
          <target state="translated">그러나 &lt;a href=&quot;scan&quot;&gt;SCAN&lt;/a&gt; 에는 커서와 관련된 상태가 거의 없기 때문에 다음과 같은 단점이 있습니다.</target>
        </trans-unit>
        <trans-unit id="d5314787731edc5f7c64fb20d0e8d7d8aa980d1c" translate="yes" xml:space="preserve">
          <source>However if the offset is prefixed with a &lt;code&gt;#&lt;/code&gt; character, the specified offset is multiplied by the integer type width, so for example:</source>
          <target state="translated">그러나 오프셋에 &lt;code&gt;#&lt;/code&gt; 문자 가 접두사로 지정된 경우 지정된 오프셋에 정수 유형 너비가 곱해집니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="f5cfa667464e115c28334f27e6f622c0e6fc2a1c" translate="yes" xml:space="preserve">
          <source>However in this context the obtained queue is not &lt;em&gt;reliable&lt;/em&gt; as messages can be lost, for example in the case there is a network problem or if the consumer crashes just after the message is received but it is still to process.</source>
          <target state="translated">그러나 이러한 맥락에서 , 예를 들어 네트워크 문제가 있거나 메시지가 수신 된 직후 소비자가 충돌하지만 여전히 처리중인 경우와 같이 메시지가 유실 될 수 있으므로 획득 된 큐는 &lt;em&gt;신뢰할 수&lt;/em&gt; 없습니다 .</target>
        </trans-unit>
        <trans-unit id="32db1099030ce3f6b2493101785b95bdd63b63e3" translate="yes" xml:space="preserve">
          <source>However it returns OK to the caller ASAP, so the &lt;a href=&quot;client-pause&quot;&gt;CLIENT PAUSE&lt;/a&gt; command execution is not paused by itself.</source>
          <target state="translated">그러나 호출자에게 OK를 리턴하므로 &lt;a href=&quot;client-pause&quot;&gt;CLIENT PAUSE&lt;/a&gt; 명령 실행 자체가 일시 중지되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="5ebc54eeb70e7c4776f4ca626c28b6528713adcd" translate="yes" xml:space="preserve">
          <source>However node hash slots can be in a special state, used in order to communicate errors after a node restart (mismatch between the keys in the AOF/RDB file, and the node hash slots configuration), or when there is a resharding operation in progress. This two states are &lt;strong&gt;importing&lt;/strong&gt; and &lt;strong&gt;migrating&lt;/strong&gt;.</source>
          <target state="translated">그러나 노드 해시 슬롯은 노드를 다시 시작한 후 (AOF / RDB 파일의 키와 노드 해시 슬롯 구성간에 불일치) 오류가 발생하거나 리 샤딩 작업이 진행중인 경우 오류를 전달하기 위해 사용되는 특수 상태 일 수 있습니다. . 이 두 가지 상태는 &lt;strong&gt;가져 오기&lt;/strong&gt; 및 &lt;strong&gt;마이그레이션 중&lt;/strong&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="74506a394d8d9a9db887f0b3d8806ba4f46848f4" translate="yes" xml:space="preserve">
          <source>However note that with streams this is not a problem: stream entries are not removed from the stream when clients are served, so every client waiting will be served as soon as an &lt;a href=&quot;xadd&quot;&gt;XADD&lt;/a&gt; command provides data to the stream.</source>
          <target state="translated">그러나 스트림의 경우 이는 문제가되지 않습니다. 클라이언트가 서비스를 제공 할 때 스트림에서 스트림 항목이 제거되지 않으므로 &lt;a href=&quot;xadd&quot;&gt;XADD&lt;/a&gt; 명령이 데이터를 스트림에 제공 하는 즉시 대기중인 모든 클라이언트가 서비스됩니다 .</target>
        </trans-unit>
        <trans-unit id="5d5d9fa16c29cdab06e0b69ea5b8063d64e64fa1" translate="yes" xml:space="preserve">
          <source>However note that:</source>
          <target state="translated">그러나 다음 사항에 유의하십시오.</target>
        </trans-unit>
        <trans-unit id="c2edee6acbd228e132336d8defe53364f46f07e4" translate="yes" xml:space="preserve">
          <source>However once the data structures are bigger and are promoted to use real hash tables, the &lt;a href=&quot;scan&quot;&gt;SCAN&lt;/a&gt; family of commands will resort to the normal behavior. Note that since this special behavior of returning all the elements is true only for small aggregates, it has no effects on the command complexity or latency. However the exact limits to get converted into real hash tables are &lt;a href=&quot;https://redis.io/topics/memory-optimization&quot;&gt;user configurable&lt;/a&gt;, so the maximum number of elements you can see returned in a single call depends on how big an aggregate data type could be and still use the packed representation.</source>
          <target state="translated">그러나 데이터 구조가 더 커지고 실제 해시 테이블을 사용하도록 승격되면 &lt;a href=&quot;scan&quot;&gt;SCAN&lt;/a&gt; 명령 계열은 정상적인 동작에 의존합니다. 모든 요소를 ​​반환하는 이러한 특수한 동작은 작은 집계에만 적용되므로 명령 복잡성 또는 대기 시간에는 영향을주지 않습니다. 그러나 실제 해시 테이블로 변환되는 정확한 제한은 &lt;a href=&quot;https://redis.io/topics/memory-optimization&quot;&gt;사용자가 구성&lt;/a&gt; 할 수 있으므로 한 번의 호출로 반환 될 수있는 최대 요소 수는 집계 데이터 형식의 크기와 패킹 된 표현의 크기에 따라 다릅니다.</target>
        </trans-unit>
        <trans-unit id="b21c3d5072091035e19308ba188163eb9b4582ee" translate="yes" xml:space="preserve">
          <source>However starting with Redis 2.8.12 or greater, the command accepts the following form:</source>
          <target state="translated">그러나 Redis 2.8.12 이상으로 시작하면 명령은 다음 형식을 승인합니다.</target>
        </trans-unit>
        <trans-unit id="3d9349e56b3bf2d47d692509fd1873664bc86e71" translate="yes" xml:space="preserve">
          <source>However the command cannot simply drop the node from the internal node table of the node receiving the command, it also implements a ban-list, not allowing the same node to be added again as a side effect of processing the &lt;em&gt;gossip section&lt;/em&gt; of the heartbeat packets received from other nodes.</source>
          <target state="translated">그러나 명령은 단순히 명령을 수신하는 노드의 내부 노드 테이블에서 노드를 삭제할 수 없으며 금지 목록도 구현 하여 하트 비트 패킷 의 &lt;em&gt;가십 섹션&lt;/em&gt; 처리의 부작용으로 동일한 노드를 다시 추가 할 수 없습니다. 다른 노드에서 수신했습니다.</target>
        </trans-unit>
        <trans-unit id="77d71597c94f649040209c65345b9adb784d1ada" translate="yes" xml:space="preserve">
          <source>However the number of returned elements is reasonable, that is, in practical terms SCAN may return a maximum number of elements in the order of a few tens of elements when iterating a large collection, or may return all the elements of the collection in a single call when the iterated collection is small enough to be internally represented as an encoded data structure (this happens for small sets, hashes and sorted sets).</source>
          <target state="translated">그러나 반환 된 요소의 수는 합리적입니다. 즉, 실제 용어로 SCAN은 큰 컬렉션을 반복 할 때 수십 개의 요소 순서로 최대 수의 요소를 반환하거나 컬렉션의 모든 요소를 ​​단일로 반환 할 수 있습니다 반복 된 컬렉션이 내부적으로 인코딩 된 데이터 구조로 표현하기에 충분히 작은 경우 호출합니다 (작은 세트, 해시 및 정렬 된 세트에 대해 발생 함).</target>
        </trans-unit>
        <trans-unit id="4a9bd4d796e3f1d19b335cd4b8d1d2f3544974af" translate="yes" xml:space="preserve">
          <source>However the user can apply a transformation to the encoded string so that the first part of the element inserted in the sorted set will compare as the user requires for the specific application. For example if I want to add strings that will be compared in a case-insensitive way, but I still want to retrieve the real case when querying, I can add strings in the following way:</source>
          <target state="translated">그러나 사용자는 정렬 된 세트에 삽입 된 요소의 첫 번째 부분이 사용자가 특정 응용 프로그램에 필요한대로 비교할 수 있도록 인코딩 된 문자열에 변환을 적용 할 수 있습니다. 예를 들어 대소 문자를 구분하지 않고 비교할 문자열을 추가하고 싶지만 쿼리 할 때 실제 사례를 검색하려면 다음과 같은 방법으로 문자열을 추가 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="794f44a2bce77c8dc3d6e6888d73f15fd3089fde" translate="yes" xml:space="preserve">
          <source>However the user is still able to write commands with random behavior using the following simple trick. Imagine I want to write a Redis script that will populate a list with N random integers.</source>
          <target state="translated">그러나 사용자는 다음과 같은 간단한 트릭을 사용하여 임의의 동작으로 명령을 작성할 수 있습니다. N 개의 임의의 정수로 목록을 채울 Redis 스크립트를 작성한다고 상상해보십시오.</target>
        </trans-unit>
        <trans-unit id="fb5b52cca56c4cdd87edf1dfc660cd981c3a9505" translate="yes" xml:space="preserve">
          <source>However there is a way for the user to tune the order of magnitude of the number of returned elements per call using the &lt;strong&gt;COUNT&lt;/strong&gt; option.</source>
          <target state="translated">그러나 사용자는 &lt;strong&gt;COUNT&lt;/strong&gt; 옵션을 사용하여 호출 당 반환되는 요소 수의 크기 순서를 조정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7f8f1c30670b30342c4d809208def1afc1fbfd2c" translate="yes" xml:space="preserve">
          <source>However there is an exception to this rule, and it is when a new cluster is created from scratch. Redis Cluster &lt;em&gt;config epoch collision resolution&lt;/em&gt; algorithm can deal with new nodes all configured with the same configuration at startup, but this process is slow and should be the exception, only to make sure that whatever happens, two more nodes eventually always move away from the state of having the same configuration epoch.</source>
          <target state="translated">그러나이 규칙에는 예외가 있으며 새 클러스터가 처음부터 생성 될 때입니다. Redis Cluster &lt;em&gt;구성 에포크 충돌 해결&lt;/em&gt; 알고리즘은 시작시 동일한 구성으로 구성된 모든 새 노드를 처리 할 수 ​​있지만이 프로세스는 느리고 예외가되어야합니다. 동일한 구성 에포크가 있습니다.</target>
        </trans-unit>
        <trans-unit id="142631746a79e235cfed163ccdfe702d6be0326c" translate="yes" xml:space="preserve">
          <source>However this also means that executing slow scripts is not a good idea. It is not hard to create fast scripts, as the script overhead is very low, but if you are going to use slow scripts you should be aware that while the script is running no other client can execute commands.</source>
          <target state="translated">그러나 이것은 또한 느린 스크립트를 실행하는 것이 좋지 않다는 것을 의미합니다. 스크립트 오버 헤드가 매우 낮기 때문에 빠른 스크립트를 작성하는 것은 어렵지 않지만 느린 스크립트를 사용하려는 경우 스크립트가 실행되는 동안 다른 클라이언트가 명령을 실행할 수 없다는 것을 알아야합니다.</target>
        </trans-unit>
        <trans-unit id="0a33083c754611907b7f894af6eb43aadc3e4c17" translate="yes" xml:space="preserve">
          <source>However this is a useful feature since, sometimes, we need to execute certain commands only in the master in order to create, for example, intermediate values.</source>
          <target state="translated">그러나 이것은 때때로 중간 값과 같은 특정 값을 생성하기 위해 마스터에서만 특정 명령을 실행해야하기 때문에 유용한 기능입니다.</target>
        </trans-unit>
        <trans-unit id="d0af8abe6ce309a54e5c3abb2294351b6406b863" translate="yes" xml:space="preserve">
          <source>However this is just a best-effort attempt so it is possible to still lose a write synchronously replicated to multiple replicas.</source>
          <target state="translated">그러나 이것은 최선의 노력 일 뿐이므로 여러 복제본에 동기식으로 복제 된 쓰기를 계속 잃을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ddd90e4937b6a5514534f2c76508301017283476" translate="yes" xml:space="preserve">
          <source>However trying to execute it again results into an error since the slots are already assigned:</source>
          <target state="translated">그러나 슬롯을 이미 할당 했으므로 다시 실행하려고하면 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="8abb1412bd4f6007eadde6067935f55706c8b96f" translate="yes" xml:space="preserve">
          <source>However using &lt;strong&gt;FORCE&lt;/strong&gt; we still need the majority of masters to be available in order to authorize the failover and generate a new configuration epoch for the replica that is going to become master.</source>
          <target state="translated">그러나 &lt;strong&gt;FORCE&lt;/strong&gt; 를 사용 하면 장애 조치를 승인하고 마스터가 될 복제본에 대한 새로운 구성 에포크를 생성하기 위해 여전히 대부분의 마스터를 사용할 수 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="f7eb54420a392ba9d9fb195f48555b2f9849c4e4" translate="yes" xml:space="preserve">
          <source>However while blocking commands like &lt;a href=&quot;smembers&quot;&gt;SMEMBERS&lt;/a&gt; are able to provide all the elements that are part of a Set in a given moment, The SCAN family of commands only offer limited guarantees about the returned elements since the collection that we incrementally iterate can change during the iteration process.</source>
          <target state="translated">그러나 &lt;a href=&quot;smembers&quot;&gt;SMEMBERS&lt;/a&gt; 와 같은 명령을 차단 하면 주어진 순간에 Set의 일부인 모든 요소를 ​​제공 할 수 있지만 , SCAN 명령 계열은 반복 프로세스 중에 점진적으로 반복되는 콜렉션이 변경 될 수 있으므로 리턴 된 요소에 대해 제한된 보증 만 제공합니다. .</target>
        </trans-unit>
        <trans-unit id="8368348c7a15aab35b99bad0b61100388ed947ac" translate="yes" xml:space="preserve">
          <source>However while the replicas connected to a master will not expire keys independently (but will wait for the &lt;a href=&quot;del&quot;&gt;DEL&lt;/a&gt; coming from the master), they'll still take the full state of the expires existing in the dataset, so when a replica is elected to master it will be able to expire the keys independently, fully acting as a master.</source>
          <target state="translated">그러나 마스터에 연결된 복제본은 키를 독립적으로 만료하지 않지만 ( 마스터에서 &lt;a href=&quot;del&quot;&gt;DEL이&lt;/a&gt; 올 때까지 기다릴 것임 ) 여전히 데이터 세트에 존재하는 만료의 전체 상태를 유지하므로 복제본이 마스터로 선택 될 때 마스터 역할을하며 키를 독립적으로 만료 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e7564bd1b123b79267215f60720a7ba2c7d0f2a4" translate="yes" xml:space="preserve">
          <source>However, note that:</source>
          <target state="translated">그러나 다음 사항에 유의하십시오.</target>
        </trans-unit>
        <trans-unit id="ae8b2a13bc4ae56dbd4d97a2490048eefaa8824d" translate="yes" xml:space="preserve">
          <source>However, this behavior changes if you are looking for clear bits and specify a range with both &lt;strong&gt;start&lt;/strong&gt; and &lt;strong&gt;end&lt;/strong&gt;. If no clear bit is found in the specified range, the function returns -1 as the user specified a clear range and there are no 0 bits in that range.</source>
          <target state="translated">그러나 명확한 비트를 찾고 &lt;strong&gt;start&lt;/strong&gt; 및 &lt;strong&gt;end&lt;/strong&gt; 모두 범위를 지정하면이 동작이 변경됩니다 . 지정된 범위에서 클리어 비트가 발견되지 않으면 사용자가 클리어 범위를 지정하고 해당 범위에 0 비트가없는 경우이 함수는 -1을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="078d1434700af53deba94cb889757980e4b68051" translate="yes" xml:space="preserve">
          <source>Humans may use this command in order to check what is the hash slot, and then the associated Redis Cluster node, responsible for a given key.</source>
          <target state="translated">사용자는이 명령을 사용하여 해시 슬롯이 무엇인지 확인한 다음 지정된 키를 담당하는 관련 Redis 클러스터 노드를 확인할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d68bb5655889a7436b2eff6315d03293170f63d0" translate="yes" xml:space="preserve">
          <source>HyperLogLog</source>
          <target state="translated">HyperLogLog</target>
        </trans-unit>
        <trans-unit id="58b5c100f0d44808f0dbfcc3722f78c2d81f1aaf" translate="yes" xml:space="preserve">
          <source>HyperLogLog representation</source>
          <target state="translated">HyperLogLog 표현</target>
        </trans-unit>
        <trans-unit id="28c10e9d5a5781ed8d9e57c706ceb5a1dd97ff5f" translate="yes" xml:space="preserve">
          <source>I can start with this small Ruby program:</source>
          <target state="translated">이 작은 루비 프로그램으로 시작할 수 있습니다 :</target>
        </trans-unit>
        <trans-unit id="5188851d79e499077ff8c17718081d6a2d5d7980" translate="yes" xml:space="preserve">
          <source>IDs are guaranteed to be always incremental: If you compare the ID of the entry just inserted it will be greater than any other past ID, so entries are totally ordered inside a stream. In order to guarantee this property, if the current top ID in the stream has a time greater than the current local time of the instance, the top entry time will be used instead, and the sequence part of the ID incremented. This may happen when, for instance, the local clock jumps backward, or if after a failover the new master has a different absolute time.</source>
          <target state="translated">ID는 항상 증분으로 보장됩니다. 방금 삽입 한 항목의 ID를 비교하면 다른 과거 ID보다 커지므로 항목은 스트림 내부에서 완전히 정렬됩니다. 이 속성을 보장하기 위해 스트림의 현재 최상위 ID가 인스턴스의 현재 현지 시간보다 큰 시간을 갖는 경우 대신 상위 진입 시간이 사용되고 ID의 시퀀스 부분이 증가합니다. 예를 들어, 로컬 시계가 뒤로 이동하거나 장애 조치 후 새 마스터의 절대 시간이 다른 경우에 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c0f8745b1bebe7ddae3a87f4efc1207e5b87a40b" translate="yes" xml:space="preserve">
          <source>IDs are specified by two numbers separated by a &lt;code&gt;-&lt;/code&gt; character:</source>
          <target state="translated">ID는 &lt;code&gt;-&lt;/code&gt; 문자로 구분 된 두 개의 숫자로 지정됩니다 .</target>
        </trans-unit>
        <trans-unit id="70aab9650acd50b2b8e1776f69b86b88bbbe99e5" translate="yes" xml:space="preserve">
          <source>INCR</source>
          <target state="translated">INCR</target>
        </trans-unit>
        <trans-unit id="c59620ba3e9207aaf8fb1bf70e412a9caa358cb2" translate="yes" xml:space="preserve">
          <source>INCR  key   Increment the integer value of a key by one</source>
          <target state="translated">INCR 키 키의 정수 값을 1 씩 증가시킵니다</target>
        </trans-unit>
        <trans-unit id="af14b6096425a1f909b7628ce8491716c2d581ba" translate="yes" xml:space="preserve">
          <source>INCRBY</source>
          <target state="translated">INCRBY</target>
        </trans-unit>
        <trans-unit id="9ab1bc6a3a0563b50a9e4bcb930106db12e2ae4e" translate="yes" xml:space="preserve">
          <source>INCRBY  key increment   Increment the integer value of a key by the given amount</source>
          <target state="translated">INCRBY 키 증가 주어진 양만큼 키의 정수 값을 증가시킵니다</target>
        </trans-unit>
        <trans-unit id="769650b0192d046cb68b526ab27d41d927ea5cc8" translate="yes" xml:space="preserve">
          <source>INCRBYFLOAT</source>
          <target state="translated">INCRBYFLOAT</target>
        </trans-unit>
        <trans-unit id="2e3bba4aaf8bd64291b4999ea2633e1cde536fe3" translate="yes" xml:space="preserve">
          <source>INCRBYFLOAT  key increment   Increment the float value of a key by the given amount</source>
          <target state="translated">INCRBYFLOAT 키 증가 지정된 양만큼 키의 부동 소수점 값을 증가시킵니다</target>
        </trans-unit>
        <trans-unit id="9c9cf999829193894067bbd9e1484756ab736ac0" translate="yes" xml:space="preserve">
          <source>INFO</source>
          <target state="translated">INFO</target>
        </trans-unit>
        <trans-unit id="42089cfb2067d721afeae473b5079898e863248e" translate="yes" xml:space="preserve">
          <source>INFO  [section]   Get information and statistics about the server</source>
          <target state="translated">INFO [섹션] 서버에 대한 정보 및 통계를 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="fc967bd2cc1b3485f1ee6c3bccb3832c0009ded5" translate="yes" xml:space="preserve">
          <source>Ideally, the &lt;code&gt;used_memory_rss&lt;/code&gt; value should be only slightly higher than &lt;code&gt;used_memory&lt;/code&gt;. When rss &amp;gt;&amp;gt; used, a large difference means there is memory fragmentation (internal or external), which can be evaluated by checking &lt;code&gt;mem_fragmentation_ratio&lt;/code&gt;. When used &amp;gt;&amp;gt; rss, it means part of Redis memory has been swapped off by the operating system: expect some significant latencies.</source>
          <target state="translated">이상적으로는 &lt;code&gt;used_memory_rss&lt;/code&gt; 값은 &lt;code&gt;used_memory&lt;/code&gt; 보다 약간 더 높아야 합니다. rss &amp;gt;&amp;gt;가 사용될 때 큰 차이는 메모리 조각화 (내부 또는 외부)가 있음을 의미하며 &lt;code&gt;mem_fragmentation_ratio&lt;/code&gt; 를 확인하여 평가할 수 있습니다 . &amp;gt;&amp;gt; rss를 사용하면 운영 체제에서 Redis 메모리의 일부가 교체되었음을 의미합니다. 상당한 대기 시간이 예상됩니다.</target>
        </trans-unit>
        <trans-unit id="73b4eda93b2219c5cea27cedcc70f71581e15c99" translate="yes" xml:space="preserve">
          <source>If &lt;a href=&quot;bgrewriteaof&quot;&gt;BGREWRITEAOF&lt;/a&gt; fails, no data gets lost as the old AOF will be untouched.</source>
          <target state="translated">경우 &lt;a href=&quot;bgrewriteaof&quot;&gt;BGREWRITEAOF이&lt;/a&gt; 실패 이전 AOF는 그대로 바와 같이, 데이터가 손실되지됩니다.</target>
        </trans-unit>
        <trans-unit id="1d20f361447b1eebe4e4808ffc994e347a4065d3" translate="yes" xml:space="preserve">
          <source>If &lt;a href=&quot;setnx&quot;&gt;SETNX&lt;/a&gt; returns &lt;code&gt;0&lt;/code&gt; the key is already locked by some other client. We can either return to the caller if it's a non blocking lock, or enter a loop retrying to hold the lock until we succeed or some kind of timeout expires.</source>
          <target state="translated">&lt;a href=&quot;setnx&quot;&gt;SETNX&lt;/a&gt; 가 &lt;code&gt;0&lt;/code&gt; 을 반환 하면 다른 클라이언트에 의해 키가 이미 잠겨있는 것입니다. 비 차단 잠금 인 경우 호출자에게 돌아가거나 성공하거나 일정 시간이 초과 될 때까지 잠금을 유지하기 위해 다시 시도하는 루프를 입력 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b2860996021d578f69065139684f5cafa8d2519b" translate="yes" xml:space="preserve">
          <source>If &lt;a href=&quot;setnx&quot;&gt;SETNX&lt;/a&gt; returns &lt;code&gt;1&lt;/code&gt; the client acquired the lock, setting the &lt;code&gt;lock.foo&lt;/code&gt; key to the Unix time at which the lock should no longer be considered valid. The client will later use &lt;code&gt;DEL lock.foo&lt;/code&gt; in order to release the lock.</source>
          <target state="translated">경우 &lt;a href=&quot;setnx&quot;&gt;SETNX가&lt;/a&gt; 반환 &lt;code&gt;1&lt;/code&gt; 클라이언트가 설정 잠금을 획득 &lt;code&gt;lock.foo&lt;/code&gt; 의 잠금이 더 이상 유효한 것으로 간주되어서는 안되는 유닉스 시간에 키를 누릅니다. 클라이언트는 나중에 잠금을 해제하기 위해 &lt;code&gt;DEL lock.foo&lt;/code&gt; 를 사용 합니다.</target>
        </trans-unit>
        <trans-unit id="a5eee6810815d94e86b03260de66be0feb7ce88c" translate="yes" xml:space="preserve">
          <source>If &lt;a href=&quot;watch&quot;&gt;WATCH&lt;/a&gt; was used, &lt;a href=&quot;discard&quot;&gt;DISCARD&lt;/a&gt; unwatches all keys watched by the connection.</source>
          <target state="translated">경우 &lt;a href=&quot;watch&quot;&gt;시계가&lt;/a&gt; 사용되었다 &lt;a href=&quot;discard&quot;&gt;DISCARD는&lt;/a&gt; 연결에 의해 감시 모든 키를 unwatches.</target>
        </trans-unit>
        <trans-unit id="20ed44b2bda4227d511c46587683f47a00d993b6" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;WITHCOORD&lt;/code&gt;, &lt;code&gt;WITHDIST&lt;/code&gt; or &lt;code&gt;WITHHASH&lt;/code&gt; options are specified, the command returns an array of arrays, where each sub-array represents a single item.</source>
          <target state="translated">경우 &lt;code&gt;WITHCOORD&lt;/code&gt; , &lt;code&gt;WITHDIST&lt;/code&gt; 또는 &lt;code&gt;WITHHASH&lt;/code&gt; 옵션을 지정하는 명령은 각각의 하위 배열은 하나의 항목을 나타내는 배열의 배열을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="73dfe5f15062ceece61a6acc3449e57743eeff88" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;destination&lt;/code&gt; already exists, it is overwritten.</source>
          <target state="translated">경우 &lt;code&gt;destination&lt;/code&gt; 이미 존재, 그것은 덮어 씁니다.</target>
        </trans-unit>
        <trans-unit id="ec00a71247f51a83461ff727be4fdc2a9b8eef53" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;key&lt;/code&gt; already exists and is a string, this command appends the &lt;code&gt;value&lt;/code&gt; at the end of the string. If &lt;code&gt;key&lt;/code&gt; does not exist it is created and set as an empty string, so &lt;a href=&quot;append&quot;&gt;APPEND&lt;/a&gt; will be similar to &lt;a href=&quot;set&quot;&gt;SET&lt;/a&gt; in this special case.</source>
          <target state="translated">경우 &lt;code&gt;key&lt;/code&gt; 이미 문자열을 존재이며,이 명령은 추가 &lt;code&gt;value&lt;/code&gt; 문자열의 끝을. &lt;code&gt;key&lt;/code&gt; 가 존재하지 않으면 키 가 생성되어 빈 문자열로 설정 &lt;a href=&quot;append&quot;&gt;되므로이&lt;/a&gt; 특별한 경우 APPEND 는 &lt;a href=&quot;set&quot;&gt;SET&lt;/a&gt; 와 유사합니다 .</target>
        </trans-unit>
        <trans-unit id="f65de86e658742c07d7bc6102da39df199a9b701" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;key&lt;/code&gt; does not exist a nil bulk reply is returned.</source>
          <target state="translated">경우 &lt;code&gt;key&lt;/code&gt; 존재하지 않는 전무 대량 응답이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="bd4417fe5a7c2042f71015b09d46b92838be30fc" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;key&lt;/code&gt; does not exist, a new sorted set with the specified members as sole members is created, like if the sorted set was empty. If the key exists but does not hold a sorted set, an error is returned.</source>
          <target state="translated">경우 &lt;code&gt;key&lt;/code&gt; 존재하지 않는 소트 세트가 비어있는 경우처럼, 유일한 구성원으로 지정된 회원들과 새로운 소트 세트가 생성됩니다. 키가 있지만 정렬 된 세트를 보유하지 않으면 오류가 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="e64662be889ce64c17aaa1cc9189ce3256310f93" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;member&lt;/code&gt; does not exist in the sorted set or &lt;code&gt;key&lt;/code&gt; does not exist, &lt;a href=&quot;https://redis.io/topics/protocol#bulk-string-reply&quot;&gt;Bulk string reply&lt;/a&gt;: &lt;code&gt;nil&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;code&gt;member&lt;/code&gt; 정렬 된 세트 또는 존재하지 않는 &lt;code&gt;key&lt;/code&gt; , 존재하지 않는 &lt;a href=&quot;https://redis.io/topics/protocol#bulk-string-reply&quot;&gt;대량의 문자열 회신&lt;/a&gt; : &lt;code&gt;nil&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f23ea3c8266e3f5959aed27b93602e9cafb796f4" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;member&lt;/code&gt; does not exist in the sorted set, or &lt;code&gt;key&lt;/code&gt; does not exist, &lt;code&gt;nil&lt;/code&gt; is returned.</source>
          <target state="translated">경우 &lt;code&gt;member&lt;/code&gt; 정렬 된 세트에 존재하지 않는, 또는 &lt;code&gt;key&lt;/code&gt; 존재하지 않는, &lt;code&gt;nil&lt;/code&gt; 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="1e3e9eec1dfb85dde46f12f033df8c95cb570dc1" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;member&lt;/code&gt; exists in the sorted set, &lt;a href=&quot;https://redis.io/topics/protocol#integer-reply&quot;&gt;Integer reply&lt;/a&gt;: the rank of &lt;code&gt;member&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;member&lt;/code&gt; 가 정렬 된 세트에 존재 하면 &lt;a href=&quot;https://redis.io/topics/protocol#integer-reply&quot;&gt;정수 응답&lt;/a&gt; : &lt;code&gt;member&lt;/code&gt; 순위입니다 .</target>
        </trans-unit>
        <trans-unit id="b0602d8252b35c86b3177857f428ef2b6ebe2844" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;password&lt;/code&gt; matches the password in the configuration file, the server replies with the &lt;code&gt;OK&lt;/code&gt; status code and starts accepting commands. Otherwise, an error is returned and the clients needs to try a new password.</source>
          <target state="translated">경우 &lt;code&gt;password&lt;/code&gt; 구성 파일의 암호와 일치, 서버에 응답 &lt;code&gt;OK&lt;/code&gt; 의 상태 코드 및 시작 명령을 수용. 그렇지 않으면 오류가 리턴되고 클라이언트는 새 비밀번호를 시도해야합니다.</target>
        </trans-unit>
        <trans-unit id="d8a36f67086d264992352bae73959a976d08f592" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;source&lt;/code&gt; does not exist, the value &lt;code&gt;nil&lt;/code&gt; is returned and no operation is performed. If &lt;code&gt;source&lt;/code&gt; and &lt;code&gt;destination&lt;/code&gt; are the same, the operation is equivalent to removing the last element from the list and pushing it as first element of the list, so it can be considered as a list rotation command.</source>
          <target state="translated">경우 &lt;code&gt;source&lt;/code&gt; 존재하지 않는 값 &lt;code&gt;nil&lt;/code&gt; 반환 아무 작업이 수행되지 않습니다. 경우 &lt;code&gt;source&lt;/code&gt; 및 &lt;code&gt;destination&lt;/code&gt; 동일한 작업이 목록에서 마지막 한 요소를 제거하고리스트의 첫 번째 요소로 추진에 상당하므로이리스트 회전 명령으로 간주 될 수있다.</target>
        </trans-unit>
        <trans-unit id="5b26bcfdadbb106d42a10a68f68adf4977b43380" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;ttl&lt;/code&gt; is 0 the key is created without any expire, otherwise the specified expire time (in milliseconds) is set.</source>
          <target state="translated">경우 &lt;code&gt;ttl&lt;/code&gt; 0 어떤이 만료없이 키가 달리 지정, 작성은 시간 (밀리 초) 설정을 만료됩니다.</target>
        </trans-unit>
        <trans-unit id="2c1e9f5fc6b657f9746f093601d0e06e3be8a993" translate="yes" xml:space="preserve">
          <source>If AOF is activated, these additional fields will be added:</source>
          <target state="translated">AOF가 활성화되면 다음과 같은 추가 필드가 추가됩니다.</target>
        </trans-unit>
        <trans-unit id="52fb5f5179b2d79edc8c3b551f845f186e716372" translate="yes" xml:space="preserve">
          <source>If a Redis child is creating a snapshot on disk, the AOF rewrite is &lt;em&gt;scheduled&lt;/em&gt; but not started until the saving child producing the RDB file terminates. In this case the &lt;a href=&quot;bgrewriteaof&quot;&gt;BGREWRITEAOF&lt;/a&gt; will still return an OK code, but with an appropriate message. You can check if an AOF rewrite is scheduled looking at the &lt;a href=&quot;info&quot;&gt;INFO&lt;/a&gt; command as of Redis 2.6.</source>
          <target state="translated">Redis 하위가 디스크에서 스냅 샷을 작성하는 경우 AOF 재 작성이 &lt;em&gt;예약&lt;/em&gt; 되지만 RDB 파일을 생성하는 저장 하위가 종료 될 때까지 AOF 재 작성이 시작됩니다. 이 경우 &lt;a href=&quot;bgrewriteaof&quot;&gt;BGREWRITEAOF&lt;/a&gt; 는 여전히 OK 코드를 반환하지만 적절한 메시지가 표시됩니다. Redis 2.6 부터 &lt;a href=&quot;info&quot;&gt;INFO&lt;/a&gt; 명령을 보고 AOF 다시 쓰기가 예약되어 있는지 확인할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="7fab76e64c7a99cf5ff09d3faf8bcf4e7b29c3b9" translate="yes" xml:space="preserve">
          <source>If a Redis server is already acting as replica, the command &lt;a href=&quot;replicaof&quot;&gt;REPLICAOF&lt;/a&gt; NO ONE will turn off the replication, turning the Redis server into a MASTER. In the proper form &lt;a href=&quot;replicaof&quot;&gt;REPLICAOF&lt;/a&gt; hostname port will make the server a replica of another server listening at the specified hostname and port.</source>
          <target state="translated">Redis 서버가 이미 복제본으로 작동하는 경우 &lt;a href=&quot;replicaof&quot;&gt;REPLICAOF&lt;/a&gt; NO ONE 명령 은 복제를 끄고 Redis 서버를 MASTER로 전환합니다. 올바른 형식으로 &lt;a href=&quot;replicaof&quot;&gt;REPLICAOF&lt;/a&gt; 호스트 이름 포트는 서버를 지정된 호스트 이름 및 포트에서 수신 대기하는 다른 서버의 복제본으로 만듭니다.</target>
        </trans-unit>
        <trans-unit id="6bba5cc9a8544de84799044ff9489eaddadc2beb" translate="yes" xml:space="preserve">
          <source>If a SYNC operation is on-going, these additional fields are provided:</source>
          <target state="translated">SYNC 작업이 진행중인 경우 다음과 같은 추가 필드가 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="b39dab88e7088d47355746e00cd5a3b16aea36b7" translate="yes" xml:space="preserve">
          <source>If a cluster instance has non-contiguous slots (e.g. 1-400,900,1800-6000) then master and replica IP/Port results will be duplicated for each top-level slot range reply.</source>
          <target state="translated">클러스터 인스턴스에 비 연속 슬롯이있는 경우 (예 : 1-400,900,1800-6000) 마스터 및 복제 IP / 포트 결과는 각 최상위 슬롯 범위 응답에 대해 복제됩니다.</target>
        </trans-unit>
        <trans-unit id="59220272c64271f85f1f97cc7691835ad64c2de3" translate="yes" xml:space="preserve">
          <source>If a command accepts an unlimited number of keys, the last key position is -1.</source>
          <target state="translated">명령이 무제한의 키를 허용하면 마지막 키 위치는 -1입니다.</target>
        </trans-unit>
        <trans-unit id="140a2742270e0d194dfebacb6a9c7a4820592aff" translate="yes" xml:space="preserve">
          <source>If a command accepts one key, the first key and last key positions is 1.</source>
          <target state="translated">명령이 하나의 키를 허용하면 첫 번째 키와 마지막 키 위치는 1입니다.</target>
        </trans-unit>
        <trans-unit id="c31655fb4face26cd02e88dd6486f34dd31bb51e" translate="yes" xml:space="preserve">
          <source>If a command accepts two keys (e.g. &lt;a href=&quot;brpoplpush&quot;&gt;BRPOPLPUSH&lt;/a&gt;, &lt;a href=&quot;smove&quot;&gt;SMOVE&lt;/a&gt;, &lt;a href=&quot;rename&quot;&gt;RENAME&lt;/a&gt;, ...) then the last key position is the location of the last key in the argument list.</source>
          <target state="translated">명령이 두 개의 키 (예 : &lt;a href=&quot;brpoplpush&quot;&gt;BRPOPLPUSH&lt;/a&gt; , &lt;a href=&quot;smove&quot;&gt;SMOVE&lt;/a&gt; , &lt;a href=&quot;rename&quot;&gt;RENAME&lt;/a&gt; 등)를 허용하면 마지막 키 위치는 인수 목록에서 마지막 키의 위치입니다.</target>
        </trans-unit>
        <trans-unit id="610d9883b3ed9e5bbf61e781dfb38f2ca5532e85" translate="yes" xml:space="preserve">
          <source>If a command is received about a key that does not exists, an &lt;code&gt;ASK&lt;/code&gt; redirection is emitted by the node, asking the client to retry only that specific query into &lt;code&gt;destination-node&lt;/code&gt;. In this case the client should not update its hash slot to node mapping.</source>
          <target state="translated">존재하지 않는 키에 대한 명령이 수신되면 , 클라이언트는 해당 특정 쿼리 만 &lt;code&gt;destination-node&lt;/code&gt; 로 재 시도하도록 요청하여 &lt;code&gt;ASK&lt;/code&gt; 경로 재 지정이 노드에 의해 생성됩니다 . 이 경우 클라이언트는 해시 슬롯을 노드 매핑으로 업데이트하지 않아야합니다.</target>
        </trans-unit>
        <trans-unit id="adc3a75aac4d6b35ed7b12ce05235e4cc640c05b" translate="yes" xml:space="preserve">
          <source>If a command is received about an existing key, the command is processed as usually.</source>
          <target state="translated">기존 키에 대한 명령이 수신되면 명령이 일반적으로 처리됩니다.</target>
        </trans-unit>
        <trans-unit id="a64d2ec3bb10e34eb579070274923657d7138a2a" translate="yes" xml:space="preserve">
          <source>If a key is overwritten by &lt;a href=&quot;rename&quot;&gt;RENAME&lt;/a&gt;, like in the case of an existing key &lt;code&gt;Key_A&lt;/code&gt; that is overwritten by a call like &lt;code&gt;RENAME Key_B Key_A&lt;/code&gt;, it does not matter if the original &lt;code&gt;Key_A&lt;/code&gt; had a timeout associated or not, the new key &lt;code&gt;Key_A&lt;/code&gt; will inherit all the characteristics of &lt;code&gt;Key_B&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;RENAME Key_B Key_A&lt;/code&gt; 와 같은 호출로 덮어 쓰는 기존 키 &lt;code&gt;Key_A&lt;/code&gt; 의 경우처럼 &lt;a href=&quot;rename&quot;&gt;RENAME&lt;/a&gt; 이 키를 덮어 쓰면 원래 &lt;code&gt;Key_A&lt;/code&gt; 에 시간 초과가 발생했는지 여부는 중요하지 않습니다 . 새 키 &lt;code&gt;Key_A&lt;/code&gt; 는 모두 특성 &lt;code&gt;Key_B&lt;/code&gt; 와 .</target>
        </trans-unit>
        <trans-unit id="0360f4a1e3e37b28bbc1c81856843472bd113d44" translate="yes" xml:space="preserve">
          <source>If a key is renamed with &lt;a href=&quot;rename&quot;&gt;RENAME&lt;/a&gt;, the associated time to live is transferred to the new key name.</source>
          <target state="translated">키의 이름이 &lt;a href=&quot;rename&quot;&gt;RENAME&lt;/a&gt; 으로 바뀌면 연관된 사용 시간이 새 키 이름으로 전송됩니다.</target>
        </trans-unit>
        <trans-unit id="dba073505eef52f13e35c2d2b072e15bc497f1c3" translate="yes" xml:space="preserve">
          <source>If a load operation is on-going, these additional fields will be added:</source>
          <target state="translated">로드 조작이 진행중인 경우 다음 추가 필드가 추가됩니다.</target>
        </trans-unit>
        <trans-unit id="a8036cb18b462f0b09c70d787c53e11501cfbc97" translate="yes" xml:space="preserve">
          <source>If a node with unbound hash slots receives a heartbeat packet from another node that claims to be the owner of some of those hash slots, the association is established instantly. Moreover, if a heartbeat or update message is received with a configuration epoch greater than the node's own, the association is re-established.</source>
          <target state="translated">바인딩되지 않은 해시 슬롯이있는 노드가 다른 해시 슬롯에서 해당 해시 슬롯의 소유자라고 주장하는 하트 비트 패킷을 수신하면 연결이 즉시 설정됩니다. 또한 노드 자체보다 큰 구성 에포크가있는 하트 비트 또는 업데이트 메시지가 수신되면 연결이 다시 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="e6947348d36ca3b7d6ec64b0d3d493bff74f2cca" translate="yes" xml:space="preserve">
          <source>If a server is already a replica of some master, &lt;a href=&quot;replicaof&quot;&gt;REPLICAOF&lt;/a&gt; hostname port will stop the replication against the old server and start the synchronization against the new one, discarding the old dataset.</source>
          <target state="translated">서버가 이미 일부 마스터의 복제 &lt;a href=&quot;replicaof&quot;&gt;본인&lt;/a&gt; 경우 REPLICAOF 호스트 이름 포트는 이전 서버에 대한 복제를 중지하고 새 서버에 대한 동기화를 시작하여 이전 데이터 세트를 삭제합니다.</target>
        </trans-unit>
        <trans-unit id="8355cef42438c57bf29e119daff3edf69a2eafac" translate="yes" xml:space="preserve">
          <source>If a server is already a replica of some master, &lt;a href=&quot;slaveof&quot;&gt;SLAVEOF&lt;/a&gt; hostname port will stop the replication against the old server and start the synchronization against the new one, discarding the old dataset.</source>
          <target state="translated">서버가 이미 일부 마스터의 복제 &lt;a href=&quot;slaveof&quot;&gt;본인&lt;/a&gt; 경우 SLAVEOF 호스트 이름 포트는 이전 서버에 대한 복제를 중지하고 새 서버에 대한 동기화를 시작하여 이전 데이터 세트를 삭제합니다.</target>
        </trans-unit>
        <trans-unit id="796f8c82d2cb3bc6674d519060d62df76a47b5cf" translate="yes" xml:space="preserve">
          <source>If an AOF rewrite is already in progress the command returns an error and no AOF rewrite will be scheduled for a later time.</source>
          <target state="translated">AOF 다시 쓰기가 이미 진행 중이면 명령이 오류를 반환하고 나중에 AOF 다시 쓰기가 예약되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="aa95f2ff011f2ee3af55365c22aa9caf33f28db8" translate="yes" xml:space="preserve">
          <source>If an option already exists in the old redis.conf file, it will be rewritten at the same position (line number).</source>
          <target state="translated">이전 redis.conf 파일에 옵션이 이미 있으면 같은 위치 (행 번호)에 다시 작성됩니다.</target>
        </trans-unit>
        <trans-unit id="4658daabd5c918d6c9d2de1223a7f5eb6d9fd842" translate="yes" xml:space="preserve">
          <source>If an option was not already present, but it is set to a non-default value, it is appended at the end of the file.</source>
          <target state="translated">옵션이 아직 없지만 기본값이 아닌 값으로 설정되어 있으면 파일 끝에 추가됩니다.</target>
        </trans-unit>
        <trans-unit id="e4228aca6b611c430e003ee894c91eb30a1b6cd7" translate="yes" xml:space="preserve">
          <source>If an option was not already present, but it is set to its default value, it is not added by the rewrite process.</source>
          <target state="translated">옵션이 아직 없지만 기본값으로 설정되어 있으면 다시 쓰기 프로세스에 의해 추가되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="b63f671253761bdf3174af266654497deb63ef4b" translate="yes" xml:space="preserve">
          <source>If another client, for instance C5, was faster than C4 and acquired the lock with the &lt;a href=&quot;getset&quot;&gt;GETSET&lt;/a&gt; operation, the C4 &lt;a href=&quot;getset&quot;&gt;GETSET&lt;/a&gt; operation will return a non expired timestamp. C4 will simply restart from the first step. Note that even if C4 set the key a bit a few seconds in the future this is not a problem.</source>
          <target state="translated">다른 클라이언트 (예 : C5)가 C4보다 빠르고 &lt;a href=&quot;getset&quot;&gt;GETSET&lt;/a&gt; 조작으로 잠금을 획득 한 경우 C4 &lt;a href=&quot;getset&quot;&gt;GETSET&lt;/a&gt; 조작은 만료되지 않은 시간 소인을 리턴합니다. C4는 첫 번째 단계부터 다시 시작합니다. C4가 앞으로 몇 초 동안 키를 약간 설정하더라도 이것은 문제가되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="37cf40db32d54ae3579f3237037ff5c92145f193" translate="yes" xml:space="preserve">
          <source>If at a given time a node has another node flagged with &lt;code&gt;PFAIL&lt;/code&gt;, and at the same time collected the majority of other master nodes &lt;em&gt;failure reports&lt;/em&gt; about this node (including itself if it is a master), then it elevates the failure state of the node from &lt;code&gt;PFAIL&lt;/code&gt; to &lt;code&gt;FAIL&lt;/code&gt;, and broadcasts a message forcing all the nodes that can be reached to flag the node as &lt;code&gt;FAIL&lt;/code&gt;.</source>
          <target state="translated">주어진 시간에 노드에 &lt;code&gt;PFAIL&lt;/code&gt; 으로 플래그가 지정된 다른 노드가 있고 동시에이 노드에 대한 대부분의 다른 마스터 노드 &lt;em&gt;실패 보고서&lt;/em&gt; (마스터 인 경우 포함)를 수집하면 노드 의 실패 상태가 높아집니다 에서 &lt;code&gt;PFAIL&lt;/code&gt; 에 &lt;code&gt;FAIL&lt;/code&gt; , 브로드 캐스트 플래그로 노드에 도달 할 수있는 모든 노드 강제 메시지 &lt;code&gt;FAIL&lt;/code&gt; 을 .</target>
        </trans-unit>
        <trans-unit id="5f5470ee8997d2330c4f1d3cb52035e4a73f57ce" translate="yes" xml:space="preserve">
          <source>If count is bigger than the number of elements inside the Set, the command will only return the whole set without additional elements.</source>
          <target state="translated">개수가 세트 내의 요소 수보다 큰 경우 명령은 추가 요소없이 전체 세트 만 반환합니다.</target>
        </trans-unit>
        <trans-unit id="7166a4c2e9e0a7b189fdf30ab0234c6d47986ab4" translate="yes" xml:space="preserve">
          <source>If instead the message was already delivered to this consumer, and it is just re-fetching the same message again, then the &lt;em&gt;last delivery counter&lt;/em&gt; is updated to the current time, and the &lt;em&gt;number of deliveries&lt;/em&gt; is incremented by one. You can access those message properties using the &lt;a href=&quot;xpending&quot;&gt;XPENDING&lt;/a&gt; command.</source>
          <target state="translated">대신이 메시지가 이미이 소비자에게 배달되었고 동일한 메시지를 다시 가져 오는 경우 &lt;em&gt;마지막 배달 카운터&lt;/em&gt; 가 현재 시간으로 업데이트되고 &lt;em&gt;배달 &lt;/em&gt;&lt;em&gt;수가&lt;/em&gt; 1 씩 증가합니다. &lt;a href=&quot;xpending&quot;&gt;XPENDING&lt;/a&gt; 명령을 사용하여 해당 메시지 특성에 액세스 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="5eb7b53c8c56d77ba922276fcf8d6fc9a5555deb" translate="yes" xml:space="preserve">
          <source>If instead you want consumers to fetch the whole stream history, use zero as the starting ID for the consumer group:</source>
          <target state="translated">대신 소비자가 전체 스트림 히스토리를 가져 오도록하려면 소비자 그룹의 시작 ID로 0을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="766551fe9e9ea8009a726c50e78e04cbf000fc57" translate="yes" xml:space="preserve">
          <source>If more than 25% of keys were expired, start again from step 1.</source>
          <target state="translated">키의 25 % 이상이 만료 된 경우 1 단계부터 다시 시작하십시오.</target>
        </trans-unit>
        <trans-unit id="18ba579c412c6a80f5484abbbc6da80390ec5935" translate="yes" xml:space="preserve">
          <source>If multiple clients are blocked for the same key, the first client to be served is the one that was waiting for more time (the first that blocked for the key). Once a client is unblocked it does not retain any priority, when it blocks again with the next call to &lt;a href=&quot;blpop&quot;&gt;BLPOP&lt;/a&gt; it will be served accordingly to the number of clients already blocked for the same key, that will all be served before it (from the first to the last that blocked).</source>
          <target state="translated">동일한 키에 대해 여러 클라이언트가 차단 된 경우 가장 먼저 제공되는 클라이언트는 더 많은 시간 동안 대기 한 클라이언트입니다 (첫 번째는 키를 차단 한 클라이언트). 클라이언트가 차단 해제되면 우선 순위를 유지하지 않고 다음 번 &lt;a href=&quot;blpop&quot;&gt;BLPOP&lt;/a&gt; 호출로 다시 차단하면 동일한 키에 대해 이미 차단 된 클라이언트 수에 따라 서비스가 제공됩니다. 마지막으로 차단).</target>
        </trans-unit>
        <trans-unit id="2d45448e42846cf1223f90529d7153a4f2ea7d57" translate="yes" xml:space="preserve">
          <source>If no &lt;code&gt;pattern&lt;/code&gt; is specified, all the channels are listed, otherwise if pattern is specified only channels matching the specified glob-style pattern are listed.</source>
          <target state="translated">&lt;code&gt;pattern&lt;/code&gt; 을 지정 하지 않으면 모든 채널이 나열되고, 그렇지 않으면 패턴이 지정된 경우 지정된 glob 스타일 패턴과 일치하는 채널 만 나열됩니다.</target>
        </trans-unit>
        <trans-unit id="ea2697ae6fd039b4a66dbcb2f98b8550bd0df116" translate="yes" xml:space="preserve">
          <source>If no reset type is specified, the default is &lt;strong&gt;soft&lt;/strong&gt;.</source>
          <target state="translated">재설정 유형을 지정하지 않으면 기본값은 &lt;strong&gt;soft&lt;/strong&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="7a5e1cf1e0228d3ddab066d68bd268b73f915f6a" translate="yes" xml:space="preserve">
          <source>If none of the specified keys exist, &lt;a href=&quot;blpop&quot;&gt;BLPOP&lt;/a&gt; blocks the connection until another client performs an &lt;a href=&quot;lpush&quot;&gt;LPUSH&lt;/a&gt; or &lt;a href=&quot;rpush&quot;&gt;RPUSH&lt;/a&gt; operation against one of the keys.</source>
          <target state="translated">지정된 키가 &lt;a href=&quot;blpop&quot;&gt;없으면 BLPOP&lt;/a&gt; 는 다른 클라이언트 가 키 중 하나에 대해 &lt;a href=&quot;lpush&quot;&gt;LPUSH&lt;/a&gt; 또는 &lt;a href=&quot;rpush&quot;&gt;RPUSH&lt;/a&gt; 작업을 수행 할 때까지 연결을 차단합니다 .</target>
        </trans-unit>
        <trans-unit id="dfae9157f2f024976d442ab776949fdf1b2e1598" translate="yes" xml:space="preserve">
          <source>If one or both the members are missing, the command returns NULL.</source>
          <target state="translated">멤버 중 하나 또는 둘 다가 없으면 명령은 NULL을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="4eccea0e4c99dbf5582f258e7eec112ee8e36e5c" translate="yes" xml:space="preserve">
          <source>If persistence is enabled this commands makes sure that Redis is switched off without the lost of any data. This is not guaranteed if the client uses simply &lt;a href=&quot;save&quot;&gt;SAVE&lt;/a&gt; and then &lt;a href=&quot;quit&quot;&gt;QUIT&lt;/a&gt; because other clients may alter the DB data between the two commands.</source>
          <target state="translated">지속성이 활성화 된 경우이 명령은 데이터 손실없이 Redis가 꺼져 있는지 확인합니다. 다른 클라이언트가 두 명령 사이에서 DB 데이터를 변경할 수 있기 때문에 클라이언트가 단순히 &lt;a href=&quot;save&quot;&gt;SAVE&lt;/a&gt; 를 사용한 다음 &lt;a href=&quot;quit&quot;&gt;QUIT을&lt;/a&gt; 사용하는 경우에는 이것이 보장되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="3c4893d742c042232e8b2da1b66fa8109b95fc06" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;incr&quot;&gt;INCR&lt;/a&gt; option is specified, the return value will be &lt;a href=&quot;https://redis.io/topics/protocol#bulk-string-reply&quot;&gt;Bulk string reply&lt;/a&gt;:</source>
          <target state="translated">경우 &lt;a href=&quot;incr&quot;&gt;INCR의&lt;/a&gt; 옵션을 지정, 반환 값은 &lt;a href=&quot;https://redis.io/topics/protocol#bulk-string-reply&quot;&gt;대량 문자열 응답&lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="48c94188363158a9ff98bf015f1ddfb2076ba94d" translate="yes" xml:space="preserve">
          <source>If the &lt;strong&gt;BLOCK&lt;/strong&gt; option is not used, the command is synchronous, and can be considered somewhat related to &lt;a href=&quot;xrange&quot;&gt;XRANGE&lt;/a&gt;: it will return a range of items inside streams, however it has two fundamental differences compared to &lt;a href=&quot;xrange&quot;&gt;XRANGE&lt;/a&gt; even if we just consider the synchronous usage:</source>
          <target state="translated">는 IF &lt;strong&gt;블록&lt;/strong&gt; 옵션을 사용하지 명령은 동기이며, 다소 관련이 고려 될 수있다 &lt;a href=&quot;xrange&quot;&gt;XRANGE&lt;/a&gt; :이 스트림 내 항목의 범위를 반환합니다, 그러나 그것은에 비해 두 가지 근본적인 차이가 &lt;a href=&quot;xrange&quot;&gt;XRANGE&lt;/a&gt; 우리가 동기 사용을 고려하더라도를 :</target>
        </trans-unit>
        <trans-unit id="2a8ebc8cb8dd39729bf6fdaaa9469b8e9dd31c5f" translate="yes" xml:space="preserve">
          <source>If the &lt;strong&gt;FORCE&lt;/strong&gt; option is given, the replica does not perform any handshake with the master, that may be not reachable, but instead just starts a failover ASAP starting from point 4. This is useful when we want to start a manual failover while the master is no longer reachable.</source>
          <target state="translated">경우 &lt;strong&gt;강제&lt;/strong&gt; 옵션이 주어 복제본 마스터 어떤 핸드 셰이크를 수행하지 않습니다, 그 도달 할 수없는 수 있지만, 대신 장애 조치는 우리가 마스터하는 동안 수동 장애 조치를 시작할 때 유용 점 (4)부터 빨리 시작 더 이상 연결할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="fded77f647c95a1a86355a7eafad08fd193bd854" translate="yes" xml:space="preserve">
          <source>If the above condition happens using a Redis 2.6 server or greater, Client &lt;strong&gt;A&lt;/strong&gt; will be served with the &lt;code&gt;c&lt;/code&gt; element, because after the &lt;a href=&quot;lpush&quot;&gt;LPUSH&lt;/a&gt; command the list contains &lt;code&gt;c,b,a&lt;/code&gt;, so taking an element from the left means to return &lt;code&gt;c&lt;/code&gt;.</source>
          <target state="translated">위의 조건이 Redis 2.6 서버 이상을 사용하여 발생하는 경우 &lt;a href=&quot;lpush&quot;&gt;LPUSH&lt;/a&gt; 명령 이후에 목록에 &lt;code&gt;c,b,a&lt;/code&gt; 가 포함되어 있으므로 왼쪽에서 요소를 가져 와서 &lt;code&gt;c&lt;/code&gt; 를 반환하므로 클라이언트 &lt;strong&gt;A&lt;/strong&gt; 는 &lt;code&gt;c&lt;/code&gt; 요소 와 함께 제공됩니다 .</target>
        </trans-unit>
        <trans-unit id="dc531ff7f9715b58415dfa6813dab3cc7b073afd" translate="yes" xml:space="preserve">
          <source>If the approximated cardinality estimated by the HyperLogLog changed after executing the command, &lt;a href=&quot;pfadd&quot;&gt;PFADD&lt;/a&gt; returns 1, otherwise 0 is returned. The command automatically creates an empty HyperLogLog structure (that is, a Redis String of a specified length and with a given encoding) if the specified key does not exist.</source>
          <target state="translated">명령 실행 후 HyperLogLog에 의해 추정 된 근사 카디널리티가 변경된 경우 &lt;a href=&quot;pfadd&quot;&gt;PFADD&lt;/a&gt; 는 1을 리턴하고 그렇지 않으면 0을 리턴합니다. 지정된 키가 존재하지 않으면 명령은 빈 HyperLogLog 구조 (지정된 길이와 지정된 인코딩의 Redis 문자열)를 자동으로 만듭니다.</target>
        </trans-unit>
        <trans-unit id="2a7df869ee4ed74778e5142a4cec6fc019c36dbe" translate="yes" xml:space="preserve">
          <source>If the client is subscribed to a channel or a pattern, it will instead return a multi-bulk with a &quot;pong&quot; in the first position and an empty bulk in the second position, unless an argument is provided in which case it returns a copy of the argument.</source>
          <target state="translated">클라이언트가 채널 또는 패턴을 구독하는 경우 인수가 제공되지 않으면 사본이 반환되지 않는 한 첫 번째 위치에 &quot;퐁&quot;이 있고 두 번째 위치에 빈 벌크가있는 멀티 벌크를 대신 반환합니다. 논쟁의.</target>
        </trans-unit>
        <trans-unit id="1e3b4ecb886491d18a97620613800a70a1d78a2c" translate="yes" xml:space="preserve">
          <source>If the client tries to blocks for multiple keys, but at least one key contains elements, the returned key / element pair is the first key from left to right that has one or more elements. In this case the client is not blocked. So for instance &lt;code&gt;BLPOP key1 key2 key3 key4 0&lt;/code&gt;, assuming that both &lt;code&gt;key2&lt;/code&gt; and &lt;code&gt;key4&lt;/code&gt; are non-empty, will always return an element from &lt;code&gt;key2&lt;/code&gt;.</source>
          <target state="translated">클라이언트가 여러 키를 차단하려고하지만 하나 이상의 키에 요소가 포함 된 경우 반환 된 키 / 요소 쌍은 하나 이상의 요소가있는 왼쪽에서 오른쪽으로 첫 번째 키입니다. 이 경우 클라이언트가 차단되지 않습니다. 예를 들어 &lt;code&gt;BLPOP key1 key2 key3 key4 0&lt;/code&gt; 은 &lt;code&gt;key2&lt;/code&gt; 와 &lt;code&gt;key4&lt;/code&gt; 가 모두 비어 있지 않다고 가정 하면 항상 &lt;code&gt;key2&lt;/code&gt; 에서 요소를 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="c4c4a551c5294109d275f4efb02ba586ea39cd4b" translate="yes" xml:space="preserve">
          <source>If the command contains multiple keys, in case none exist, the behavior is the same as point 2, if all exist, it is the same as point 1, however if only a partial number of keys exist, the command emits a &lt;code&gt;TRYAGAIN&lt;/code&gt; error in order for the keys interested to finish being migrated to the target node, so that the multi keys command can be executed.</source>
          <target state="translated">명령에 여러 키가 포함 된 경우, 존재하지 않는 경우 동작은 포인트 2와 동일하고, 모두 존재하는 경우 포인트 1과 동일하지만 키의 일부만 존재하는 경우 명령은 &lt;code&gt;TRYAGAIN&lt;/code&gt; 오류를 발생시킵니다. 다중 키 명령을 실행할 수 있도록 원하는 키가 대상 노드로 마이그레이션을 완료합니다.</target>
        </trans-unit>
        <trans-unit id="b47c13f341545793a768bad91b706c8230117dd6" translate="yes" xml:space="preserve">
          <source>If the command is sent as part of a &lt;a href=&quot;multi&quot;&gt;MULTI&lt;/a&gt; transaction, the command does not block but instead just return ASAP the number of replicas that acknowledged the previous write commands.</source>
          <target state="translated">명령이 &lt;a href=&quot;multi&quot;&gt;MULTI&lt;/a&gt; 트랜잭션의 일부로 전송되면 명령은 이전 쓰기 명령을 승인 한 복제본 수를 차단하지 않고 최대한 빨리 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="b2647b206316067e60c5c58ad3dabbd5311d10db" translate="yes" xml:space="preserve">
          <source>If the command is successful the new incremented value is stored as the new value of the key (replacing the old one), and returned to the caller as a string.</source>
          <target state="translated">명령이 성공하면 새 증분 값이 키의 새 값으로 저장되고 (이전 값 대체) 호출자에게 문자열로 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="e13c77b4e4b0cd6a39fdb6c6dd3019929d6f047e" translate="yes" xml:space="preserve">
          <source>If the command succeeds the new replica will immediately try to contact its master in order to replicate from it.</source>
          <target state="translated">명령이 성공하면 새 복제본은 즉시 복제하기 위해 해당 마스터에 연결을 시도합니다.</target>
        </trans-unit>
        <trans-unit id="58e50abae2f1a6949ff81b62d232f71c48c7e358" translate="yes" xml:space="preserve">
          <source>If the current hash slot owner is the node receiving the command, but for effect of the command the slot would be assigned to a different node, the command will return an error if there are still keys for that hash slot in the node receiving the command.</source>
          <target state="translated">현재 해시 슬롯 소유자가 명령을 수신하는 노드이지만 명령의 효과로 인해 슬롯이 다른 노드에 할당되면 명령을 수신하는 노드에 해당 해시 슬롯에 대한 키가 여전히 있으면 명령이 오류를 반환합니다. .</target>
        </trans-unit>
        <trans-unit id="b16a9421e847dd28010cba3e62963f9099073a99" translate="yes" xml:space="preserve">
          <source>If the elements in the sorted set have different scores, the returned elements are unspecified.</source>
          <target state="translated">정렬 된 세트의 요소가 다른 점수를 갖는 경우 반환 된 요소는 지정되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="3481b2e7b6d800470df672a8874ad9a04f6afdca" translate="yes" xml:space="preserve">
          <source>If the instance is a replica, these additional fields are provided:</source>
          <target state="translated">인스턴스가 복제 본인 경우 다음과 같은 추가 필드가 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="a39168a871f5b0b2ac68a8345a687deba4b95089" translate="yes" xml:space="preserve">
          <source>If the link between master and replica is down, an additional field is provided:</source>
          <target state="translated">마스터와 복제본 간의 연결이 끊어지면 추가 필드가 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="5d43590cf68cfd82fc6f591b087a5f138a1a7c3f" translate="yes" xml:space="preserve">
          <source>If the message was never delivered to anyone, that is, if we are talking about a new message, then a PEL (Pending Entry List) is created.</source>
          <target state="translated">메시지가 다른 사람에게 전달되지 않은 경우, 즉 새 메시지에 대해 이야기하는 경우 PEL (Pending Entry List)이 작성됩니다.</target>
        </trans-unit>
        <trans-unit id="638ffe7f713cb2cff80e46aae12ead14d0ec33c3" translate="yes" xml:space="preserve">
          <source>If the node is a replica it is turned into an (empty) master. Its dataset is flushed, so at the end the node will be an empty master.</source>
          <target state="translated">노드가 복제 본인 경우 (빈) 마스터로 바뀝니다. 데이터 세트가 플러시되므로 결국 노드는 빈 마스터가됩니다.</target>
        </trans-unit>
        <trans-unit id="1785c288c16b021950b10d9d886a7eae6f023094" translate="yes" xml:space="preserve">
          <source>If the node receiving the command is not already a replica, but is a master, the command will only succeed, and the node will be converted into a replica, only if the following additional conditions are met:</source>
          <target state="translated">명령을 수신하는 노드가 이미 복제본이 아니라 마스터 인 경우 다음 추가 조건이 충족되는 경우에만 명령이 성공하고 노드가 복제본으로 변환됩니다.</target>
        </trans-unit>
        <trans-unit id="0d7f2602b57e25d3482f6de95a393b6a52d114e4" translate="yes" xml:space="preserve">
          <source>If the object you try to inspect is missing, a null bulk reply is returned.</source>
          <target state="translated">검사하려는 객체가 누락 된 경우 null 대량 응답이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="ed8b33783f226cf240802124131a6b3112f200a2" translate="yes" xml:space="preserve">
          <source>If the script already called write commands the only allowed command becomes &lt;code&gt;SHUTDOWN NOSAVE&lt;/code&gt; that stops the server without saving the current data set on disk (basically the server is aborted).</source>
          <target state="translated">스크립트가 이미 쓰기 명령을 호출 한 경우 허용되는 유일한 명령은 &lt;code&gt;SHUTDOWN NOSAVE&lt;/code&gt; 가되어 현재 데이터 세트를 디스크에 저장하지 않고 서버를 중지합니다 (기본적으로 서버는 중단됨).</target>
        </trans-unit>
        <trans-unit id="7d7312df2553f6628fdfae5411ba0776826d8dfb" translate="yes" xml:space="preserve">
          <source>If the script already performed write operations it can not be killed in this way because it would violate Lua script atomicity contract. In such a case only &lt;code&gt;SHUTDOWN NOSAVE&lt;/code&gt; is able to kill the script, killing the Redis process in an hard way preventing it to persist with half-written information.</source>
          <target state="translated">스크립트가 이미 쓰기 작업을 수행 한 경우 Lua 스크립트 원자 계약을 위반하므로 이런 방식으로 종료 할 수 없습니다. 이러한 경우 &lt;code&gt;SHUTDOWN NOSAVE&lt;/code&gt; 만이 스크립트를 강제 종료 할 수 있으며, Redis 프로세스를 강제 종료하면 반으로 작성된 정보로 유지되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="5aeedf1a85f8e143cfd4057ccfb92d5e01611feb" translate="yes" xml:space="preserve">
          <source>If the server does not remember a script with this SHA1 digest, a special error is returned telling the client to use &lt;a href=&quot;eval&quot;&gt;EVAL&lt;/a&gt; instead.</source>
          <target state="translated">서버가이 SHA1 다이제스트가 포함 된 스크립트를 기억하지 않으면 클라이언트에게 &lt;a href=&quot;eval&quot;&gt;EVAL을&lt;/a&gt; 대신 사용하라는 특별한 오류가 반환 됩니다.</target>
        </trans-unit>
        <trans-unit id="8c526024cc2b0adff52463eae82153b3e7035275" translate="yes" xml:space="preserve">
          <source>If the server is configured with the &lt;code&gt;min-slaves-to-write&lt;/code&gt; (or starting with Redis 5 with the &lt;code&gt;min-replicas-to-write&lt;/code&gt;) directive, an additional field is provided:</source>
          <target state="translated">서버가 &lt;code&gt;min-slaves-to-write&lt;/code&gt; (또는 &lt;code&gt;min-replicas-to-write&lt;/code&gt; 으로 Redis 5로 시작 ) 지시어로 구성된 경우 추가 필드가 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="160c785d0bbfa994844826d34af71d6ba78bcac0" translate="yes" xml:space="preserve">
          <source>If the server still remembers a script with a matching SHA1 digest, the script is executed.</source>
          <target state="translated">서버가 여전히 SHA1 다이제스트와 일치하는 스크립트를 기억하면 스크립트가 실행됩니다.</target>
        </trans-unit>
        <trans-unit id="a73ff8adff60cf3faa9396c7d82031cce8e1eee5" translate="yes" xml:space="preserve">
          <source>If the slot is in &lt;em&gt;migrating&lt;/em&gt; state, the state gets cleared when the slot is assigned to another node.</source>
          <target state="translated">슬롯이 &lt;em&gt;마이그레이션&lt;/em&gt; 상태 인 경우 슬롯이 다른 노드에 할당되면 상태가 지워집니다.</target>
        </trans-unit>
        <trans-unit id="4fb7824817ed0173726151921ede13e72a5a9bcf" translate="yes" xml:space="preserve">
          <source>If the slot was in &lt;em&gt;importing&lt;/em&gt; state in the node receiving the command, and the command assigns the slot to this node (which happens in the target node at the end of the resharding of a hash slot from one node to another), the command has the following side effects: A) the &lt;em&gt;importing&lt;/em&gt; state is cleared. B) If the node config epoch is not already the greatest of the cluster, it generates a new one and assigns the new config epoch to itself. This way its new hash slot ownership will win over any past configuration created by previous failovers or slot migrations.</source>
          <target state="translated">명령을 수신 한 노드 에서 슬롯이 &lt;em&gt;가져 오기&lt;/em&gt; 상태에 있고 명령이이 노드에 슬롯을 할당하면 (해당 슬롯에서 해시 슬롯의 리 샤딩 종료시 대상 노드에서 발생) 노드에 다른 명령이 있습니다. 다음과 같은 부작용이 있습니다. A) &lt;em&gt;가져 오기&lt;/em&gt; 상태가 해제됩니다. B) 노드 구성 에포크가 클러스터의 가장 큰 클러스터가 아닌 경우 새 클러스터를 생성하고 새 구성 에포크를 자체에 할당합니다. 이렇게하면 새로운 해시 슬롯 소유권이 이전 페일 오버 또는 슬롯 마이그레이션으로 생성 된 모든 이전 구성보다 우선합니다.</target>
        </trans-unit>
        <trans-unit id="e8cd47d9356aab972b5f2bd3e87e1b06b6cacf48" translate="yes" xml:space="preserve">
          <source>If the source set does not exist or does not contain the specified element, no operation is performed and &lt;code&gt;0&lt;/code&gt; is returned. Otherwise, the element is removed from the source set and added to the destination set. When the specified element already exists in the destination set, it is only removed from the source set.</source>
          <target state="translated">소스 세트가 존재하지 않거나 지정된 요소를 포함하지 않으면 조작이 수행되지 않고 &lt;code&gt;0&lt;/code&gt; 이 리턴됩니다. 그렇지 않으면 요소가 소스 세트에서 제거되고 대상 세트에 추가됩니다. 지정된 요소가 대상 세트에 이미 존재하면 소스 세트에서만 제거됩니다.</target>
        </trans-unit>
        <trans-unit id="da52acca0f5817a572a7d2dfec4d48663d8d1b71" translate="yes" xml:space="preserve">
          <source>If the user inserts all the elements in a sorted set with the same score (for example 0), all the elements of the sorted set are sorted lexicographically, and range queries on elements are possible using the command &lt;a href=&quot;zrangebylex&quot;&gt;ZRANGEBYLEX&lt;/a&gt; (Note: it is also possible to query sorted sets by range of scores using &lt;a href=&quot;zrangebyscore&quot;&gt;ZRANGEBYSCORE&lt;/a&gt;).</source>
          <target state="translated">사용자가 동일한 점수 (예 : 0)로 정렬 된 세트에 모든 요소를 ​​삽입하면 정렬 된 세트의 모든 요소가 사전 식으로 정렬되고 &lt;a href=&quot;zrangebylex&quot;&gt;ZRANGEBYLEX&lt;/a&gt; 명령을 사용하여 요소에 대한 범위 쿼리가 가능합니다 (참고 : &lt;a href=&quot;zrangebyscore&quot;&gt;ZRANGEBYSCORE를&lt;/a&gt; 사용하여 점수 범위별로 정렬 된 세트를 쿼리합니다 .</target>
        </trans-unit>
        <trans-unit id="bb5f5ae1336c1db943d20a454954235747a6d64e" translate="yes" xml:space="preserve">
          <source>If the user will be idle more than 60 seconds, the key will be deleted and only subsequent page views that have less than 60 seconds of difference will be recorded.</source>
          <target state="translated">사용자가 60 초 이상 유휴 상태 인 경우 키가 삭제되고 60 초 미만의 차이가있는 후속 페이지보기 만 기록됩니다.</target>
        </trans-unit>
        <trans-unit id="dca107e1698238aa60bfb450d46b8e949be6578e" translate="yes" xml:space="preserve">
          <source>If there are no keys to migrate in the source instance &lt;code&gt;NOKEY&lt;/code&gt; is returned. Because missing keys are possible in normal conditions, from expiry for example, &lt;code&gt;NOKEY&lt;/code&gt; isn't an error.</source>
          <target state="translated">소스 인스턴스에 마이그레이션 할 키가 없으면 &lt;code&gt;NOKEY&lt;/code&gt; 가 반환됩니다. 예를 들어 만료일부터 &lt;code&gt;NOKEY&lt;/code&gt; 는 정상적인 조건에서 누락 된 키가 가능하기 때문에 오류가 아닙니다.</target>
        </trans-unit>
        <trans-unit id="65645be10cc140f75bd2c8251142687f4fa78461" translate="yes" xml:space="preserve">
          <source>If we generate a configuration epoch which happens to collide with another instance, eventually our configuration epoch, or the one of another instance with our same epoch, will be moved away using the &lt;em&gt;configuration epoch collision resolution algorithm&lt;/em&gt;.</source>
          <target state="translated">다른 인스턴스와 충돌하는 구성 에포크를 생성하면 결국 구성 에포크 또는 동일한 에포크가있는 다른 인스턴스 중 하나가 &lt;em&gt;구성 에포크 충돌 해결 알고리즘을&lt;/em&gt; 사용하여 멀리 이동 &lt;em&gt;합니다&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="b6f79d56180a9ad1d3aeb8220feacf255be61da4" translate="yes" xml:space="preserve">
          <source>If we look for clear bits (the bit argument is 0) and the string only contains bit set to 1, the function returns the first bit not part of the string on the right. So if the string is three bytes set to the value &lt;code&gt;0xff&lt;/code&gt; the command &lt;code&gt;BITPOS key 0&lt;/code&gt; will return 24, since up to bit 23 all the bits are 1.</source>
          <target state="translated">클리어 비트 (비트 인수가 0)를 찾고 문자열에 1로 설정된 비트 만 포함 된 경우 함수는 오른쪽에 문자열의 일부가 아닌 첫 번째 비트를 반환합니다. 따라서 문자열이 3 바이트 값 &lt;code&gt;0xff&lt;/code&gt; 로 설정되면 &lt;code&gt;BITPOS key 0&lt;/code&gt; 명령 은 24를 반환합니다. 비트 23까지는 모든 비트가 1이기 때문입니다.</target>
        </trans-unit>
        <trans-unit id="44b33ba5659f824ae39b000fc70d2cf7d6138c7b" translate="yes" xml:space="preserve">
          <source>If we look for set bits (the bit argument is 1) and the string is empty or composed of just zero bytes, -1 is returned.</source>
          <target state="translated">비트를 설정하고 (비트 인수가 1) 문자열이 비어 있거나 0 바이트로만 구성된 경우 -1이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="2012c008377fbb50737408462ade88dce859c2ba" translate="yes" xml:space="preserve">
          <source>If you call &lt;a href=&quot;exec&quot;&gt;EXEC&lt;/a&gt; or &lt;a href=&quot;discard&quot;&gt;DISCARD&lt;/a&gt;, there's no need to manually call &lt;a href=&quot;unwatch&quot;&gt;UNWATCH&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;exec&quot;&gt;EXEC&lt;/a&gt; 또는 &lt;a href=&quot;discard&quot;&gt;DISCARD&lt;/a&gt; 를 호출하면 &lt;a href=&quot;unwatch&quot;&gt;UNWATCH&lt;/a&gt; 를 수동으로 호출 할 필요가 없습니다 .</target>
        </trans-unit>
        <trans-unit id="7adf0ee2bf057d6e4f3261ad571f6a13a6962d80" translate="yes" xml:space="preserve">
          <source>If you have a stream and multiple clients, and you want all the clients to get all the messages, you do not need a consumer group.</source>
          <target state="translated">스트림과 여러 클라이언트가 있고 모든 클라이언트가 모든 메시지를 받도록하려면 소비자 그룹이 필요하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="560057ad39d223339741232ee3fcc91b0feb1edf" translate="yes" xml:space="preserve">
          <source>If you have a stream and multiple clients, and you want the stream to be &lt;em&gt;partitioned&lt;/em&gt; or &lt;em&gt;shareded&lt;/em&gt; across your clients, so that each client will get a sub set of the messages arriving in a stream, you need a consumer group.</source>
          <target state="translated">스트림과 여러 클라이언트가 있고 스트림이 클라이언트에서 &lt;em&gt;분할&lt;/em&gt; 되거나 &lt;em&gt;공유&lt;/em&gt; 되어 각 클라이언트가 스트림에 도착하는 메시지의 하위 세트를 가져 오려면 소비자 그룹이 필요합니다.</target>
        </trans-unit>
        <trans-unit id="b31dd57013b909fbb7b7346c7faa280640e4841b" translate="yes" xml:space="preserve">
          <source>If you like science fiction, think of time flowing at infinite speed inside a &lt;a href=&quot;multi&quot;&gt;MULTI&lt;/a&gt; / &lt;a href=&quot;exec&quot;&gt;EXEC&lt;/a&gt; block...</source>
          <target state="translated">공상 과학 소설을 좋아한다면 &lt;a href=&quot;multi&quot;&gt;MULTI&lt;/a&gt; / &lt;a href=&quot;exec&quot;&gt;EXEC&lt;/a&gt; 블록 안에서 무한한 속도로 흐르는 시간을 생각해보십시오 .</target>
        </trans-unit>
        <trans-unit id="c010cb9076ea01e47bb02d7ca64129ac264912a3" translate="yes" xml:space="preserve">
          <source>If you look for an &lt;code&gt;XGET&lt;/code&gt; command you'll be disappointed because &lt;a href=&quot;xrange&quot;&gt;XRANGE&lt;/a&gt; is effectively the way to go in order to fetch a single entry from a stream. All you have to do is to specify the ID two times in the arguments of XRANGE:</source>
          <target state="translated">당신이 찾는 경우 &lt;code&gt;XGET&lt;/code&gt; 명령 때문에 실망 할 것이다 &lt;a href=&quot;xrange&quot;&gt;XRANGE이&lt;/a&gt; 효과적으로 스트림에서 하나의 항목을 가져 오기 위해 길을 가야하는 것입니다. XRANGE의 인수에서 ID를 두 번 지정하기 만하면됩니다.</target>
        </trans-unit>
        <trans-unit id="9b173c7e7e26659d2dc21433cf73d902805a206a" translate="yes" xml:space="preserve">
          <source>If you request details about non-existing commands, their return position will be nil.</source>
          <target state="translated">존재하지 않는 명령에 대한 세부 정보를 요청하면 반환 위치는 nil이됩니다.</target>
        </trans-unit>
        <trans-unit id="12acfb0048a8a9bf03f38f7e388902128cc410f3" translate="yes" xml:space="preserve">
          <source>Imagine you have a web service and you are interested in the latest N pages &lt;em&gt;recently&lt;/em&gt; visited by your users, such that each adjacent page view was not performed more than 60 seconds after the previous. Conceptually you may consider this set of page views as a &lt;em&gt;Navigation session&lt;/em&gt; of your user, that may contain interesting information about what kind of products he or she is looking for currently, so that you can recommend related products.</source>
          <target state="translated">웹 서비스가 있고 사용자가 &lt;em&gt;최근에&lt;/em&gt; 방문한 최신 N 페이지 &lt;em&gt;에&lt;/em&gt; 관심이 있다고 가정 하여 이전의 각 페이지보기가 60 초 이상 수행되지 않도록하십시오. 개념적으로이 페이지보기 세트를 사용자 의 &lt;em&gt;탐색 세션&lt;/em&gt; 으로 간주 할 수 있습니다. 여기에는 현재 찾고있는 제품 종류에 대한 흥미로운 정보가 포함되어 있으므로 관련 제품을 추천 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3fb9a33bf9d1d9a11eb463de937edd8bbe41eff8" translate="yes" xml:space="preserve">
          <source>Imagine you have elements A, B and C with weights 1, 2 and 3. You compute the sum of the weights, which is 1+2+3 = 6</source>
          <target state="translated">가중치 1, 2 및 3을 가진 요소 A, B 및 C가 있다고 가정합니다. 가중치의 합을 계산합니다. 1 + 2 + 3 = 6입니다.</target>
        </trans-unit>
        <trans-unit id="28adac3b6124834ed39c280b45702edaf27ac85d" translate="yes" xml:space="preserve">
          <source>Implement &lt;a href=&quot;wait&quot;&gt;WAIT&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;wait&quot;&gt;WAIT를&lt;/a&gt; 구현하십시오 .</target>
        </trans-unit>
        <trans-unit id="81ebe12aa11cc123fdb7f8c88133ffaff6347b23" translate="yes" xml:space="preserve">
          <source>Implementation details</source>
          <target state="translated">구현 세부 사항</target>
        </trans-unit>
        <trans-unit id="11672e7162d8cdc131bd8b02c509dcb60a9d776d" translate="yes" xml:space="preserve">
          <source>Implementation details and notes</source>
          <target state="translated">구현 세부 사항 및 참고 사항</target>
        </trans-unit>
        <trans-unit id="cc7649d9b862b15149646b67450f76a9d95f07c8" translate="yes" xml:space="preserve">
          <source>Implementation details: MEET and PING packets</source>
          <target state="translated">구현 세부 사항 : MEET 및 PING 패킷</target>
        </trans-unit>
        <trans-unit id="c5a3d437892d8fb38c145f676153ba0009f546b9" translate="yes" xml:space="preserve">
          <source>Important: &lt;strong&gt;there is no need to use the same COUNT value&lt;/strong&gt; for every iteration. The caller is free to change the count from one iteration to the other as required, as long as the cursor passed in the next call is the one obtained in the previous call to the command.</source>
          <target state="translated">중요 : 모든 반복에 &lt;strong&gt;동일한 COUNT 값을 사용할 필요는 없습니다&lt;/strong&gt; . 다음 호출에서 전달 된 커서가 명령에 대한 이전 호출에서 얻은 것이라면 호출자는 한 반복에서 다른 반복으로 카운트를 자유롭게 변경할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b6980584e557c93bab34f4259447d38dd3a9c928" translate="yes" xml:space="preserve">
          <source>Importing and migrating slots are emitted in the &lt;a href=&quot;cluster-nodes&quot;&gt;CLUSTER NODES&lt;/a&gt; output as follows:</source>
          <target state="translated">가져 오기 및 마이그레이션 슬롯은 다음과 같이 &lt;a href=&quot;cluster-nodes&quot;&gt;CLUSTER NODES&lt;/a&gt; 출력 에서 방출 됩니다.</target>
        </trans-unit>
        <trans-unit id="50ac60eae9cbac9b1534be93c64ff4eb8e05e3df" translate="yes" xml:space="preserve">
          <source>Importing and migrating slots are provided as &lt;strong&gt;additional info&lt;/strong&gt;. If the node has a given hash slot assigned, it will be also a plain number in the list of hash slots, so clients that don't have a clue about hash slots migrations can just skip this special fields.</source>
          <target state="translated">슬롯 가져 오기 및 마이그레이션은 &lt;strong&gt;추가 정보&lt;/strong&gt; 로 제공됩니다 . 노드에 지정된 해시 슬롯이 할당되어 있으면 해시 슬롯 목록에도 일반 번호가 표시되므로 해시 슬롯 마이그레이션에 대한 단서가없는 클라이언트는이 특수 필드를 건너 뛸 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e69ceca772f34d784aadd1c27595fdabe97b5262" translate="yes" xml:space="preserve">
          <source>In Redis 2.4 the expire might not be pin-point accurate, and it could be between zero to one seconds out.</source>
          <target state="translated">Redis 2.4에서 만료는 정확히 정확하지 않을 수 있으며 0 초에서 1 초 사이 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="404f7b7c02b7867c0901ee21294f6e2f5fef0d3c" translate="yes" xml:space="preserve">
          <source>In Redis 2.6 or older the command returns &lt;code&gt;-1&lt;/code&gt; if the key does not exist or if the key exist but has no associated expire.</source>
          <target state="translated">Redis 2.6 이상 에서는 키가 존재하지 않거나 키가 존재하지만 연관된 만료가없는 경우 명령은 &lt;code&gt;-1&lt;/code&gt; 을 리턴합니다 .</target>
        </trans-unit>
        <trans-unit id="8b69e0b775a7565070cf9c5f2db4bd807c015a5f" translate="yes" xml:space="preserve">
          <source>In Redis Cluster, each node keeps track of which master is serving a particular hash slot.</source>
          <target state="translated">Redis Cluster에서 각 노드는 특정 해시 슬롯을 제공하는 마스터를 추적합니다.</target>
        </trans-unit>
        <trans-unit id="d0bdbf698aa8eaf887d7877ad1c2d9ea20b7520a" translate="yes" xml:space="preserve">
          <source>In Redis versions prior &lt;strong&gt;2.1.3&lt;/strong&gt; altering a key with an expire set using a command altering its value had the effect of removing the key entirely. This semantics was needed because of limitations in the replication layer that are now fixed.</source>
          <target state="translated">&lt;strong&gt;2.1.3&lt;/strong&gt; 이전의 Redis 버전에서는 값을 변경하는 명령을 사용하여 만료 세트로 키를 변경하면 키를 완전히 제거하는 효과가있었습니다. 이 의미는 이제 수정 된 복제 계층의 제한 때문에 필요했습니다.</target>
        </trans-unit>
        <trans-unit id="34f272b3296928896a7fa9c51b4f28ffa23b9540" translate="yes" xml:space="preserve">
          <source>In future versions of Redis it is possible that we'll trigger a node garbage collection in case a given macro-node reaches a given amount of deleted entries. Currently with the usage we anticipate for this data structure, it is not a good idea to add such complexity.</source>
          <target state="translated">Redis의 이후 버전에서는 지정된 매크로 노드가 지정된 양의 삭제 된 항목에 도달 할 경우 노드 가비지 수집을 트리거 할 수 있습니다. 현재 우리는이 데이터 구조에 대한 사용법으로 이러한 복잡성을 추가하는 것은 좋지 않습니다.</target>
        </trans-unit>
        <trans-unit id="420ffa2728e82649ac426218fc502611ceb5c012" translate="yes" xml:space="preserve">
          <source>In general what you should know is that setting the &lt;code&gt;appendonly&lt;/code&gt; parameter to &lt;code&gt;yes&lt;/code&gt; will start a background process to save the initial append-only file (obtained from the in memory data set), and will append all the subsequent commands on the append-only file, thus obtaining exactly the same effect of a Redis server that started with AOF turned on since the start.</source>
          <target state="translated">일반적으로 &lt;code&gt;appendonly&lt;/code&gt; 매개 변수를 &lt;code&gt;yes&lt;/code&gt; 로 설정하면 백그라운드 프로세스가 시작되어 초기 추가 전용 파일 (메모리 데이터 세트에서 가져옴) 을 저장하고 이후의 모든 명령을 추가 전용 파일에 추가합니다. 따라서 시작 이후 AOF로 시작한 Redis 서버와 동일한 효과를 얻습니다.</target>
        </trans-unit>
        <trans-unit id="464e556758431df2768b0136fb61ecadb0a9af07" translate="yes" xml:space="preserve">
          <source>In its synchronous form, the command can get new data as long as there are more items available. However, at some point, we'll have to wait for producers of data to use &lt;a href=&quot;xadd&quot;&gt;XADD&lt;/a&gt; to push new entries inside the streams we are consuming. In order to avoid polling at a fixed or adaptive interval the command is able to block if it could not return any data, according to the specified streams and IDs, and automatically unblock once one of the requested keys accept data.</source>
          <target state="translated">동기식으로 사용 가능한 항목이 더 있으면 명령이 새 데이터를 가져올 수 있습니다. 그러나 어느 시점에서 우리는 데이터 생산자가 &lt;a href=&quot;xadd&quot;&gt;XADD&lt;/a&gt; 를 사용 하여 우리가 소비하는 스트림 내부에 새로운 항목을 푸시 할 때까지 기다려야합니다 . 고정 또는 적응 간격으로 폴링을 피하기 위해 지정된 스트림 및 ID에 따라 데이터를 반환 할 수없는 경우 명령을 차단하고 요청 된 키 중 하나가 데이터를 수락하면 자동으로 차단을 해제 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f71d43ee55e218973fa1e5cb6ebd10de6f4de1c3" translate="yes" xml:space="preserve">
          <source>In options where bytes or other quantities are specified, it is not possible to use the &lt;code&gt;redis.conf&lt;/code&gt; abbreviated form (&lt;code&gt;10k&lt;/code&gt;, &lt;code&gt;2gb&lt;/code&gt; ... and so forth), everything should be specified as a well-formed 64-bit integer, in the base unit of the configuration directive. However since Redis version 3.0 or greater, it is possible to use &lt;a href=&quot;config-set&quot;&gt;CONFIG SET&lt;/a&gt; with memory units for &lt;code&gt;maxmemory&lt;/code&gt;, client output buffers, and replication backlog size.</source>
          <target state="translated">바이트 또는 다른 수량이 지정된 옵션에서는 &lt;code&gt;redis.conf&lt;/code&gt; 약어 형식 ( &lt;code&gt;10k&lt;/code&gt; , &lt;code&gt;2gb&lt;/code&gt; ... 등) 을 사용할 수 없으며 모든 것이 올바른 형식의 64 비트 정수로 지정되어야합니다. 구성 지시문의 기본 단위. 그러나 Redis 버전 3.0 이상에서는 &lt;code&gt;maxmemory&lt;/code&gt; , 클라이언트 출력 버퍼 및 복제 백 로그 크기를 위한 메모리 단위와 함께 &lt;a href=&quot;config-set&quot;&gt;CONFIG SET&lt;/a&gt; 을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="74befe185bf5845d0b7429c8d4ecaac4587e1561" translate="yes" xml:space="preserve">
          <source>In order to avoid these problems while avoiding the bandwidth penalty, Redis implements the &lt;a href=&quot;evalsha&quot;&gt;EVALSHA&lt;/a&gt; command.</source>
          <target state="translated">대역폭 문제를 피하면서 이러한 문제를 피하기 위해 Redis는 &lt;a href=&quot;evalsha&quot;&gt;EVALSHA&lt;/a&gt; 명령을 구현합니다 .</target>
        </trans-unit>
        <trans-unit id="4e60382da8db79c78bf47f321f4d7ec3aa869b88" translate="yes" xml:space="preserve">
          <source>In order to block, the &lt;strong&gt;BLOCK&lt;/strong&gt; option is used, together with the number of milliseconds we want to block before timing out. Normally Redis blocking commands take timeouts in seconds, however this command takes a millisecond timeout, even if normally the server will have a timeout resolution near to 0.1 seconds. This time it is possible to block for a shorter time in certain use cases, and if the server internals will improve over time, it is possible that the resolution of timeouts will improve.</source>
          <target state="translated">블록하기 위해, &lt;strong&gt;블록&lt;/strong&gt; 옵션은 시간 초과하기 전에 우리가 블록에 원하는 시간 (밀리 초)과 함께 사용된다. 일반적으로 Redis 차단 명령은 초 단위로 시간 초과되지만,이 명령은 일반적으로 서버가 0.1 초에 가까운 시간 초과 해상도를 갖더라도 밀리 초 시간 초과가 걸립니다. 이번에는 특정 사용 사례에서 더 짧은 시간 동안 차단할 수 있으며 서버 내부가 시간이 지남에 따라 개선 될 경우 시간 초과 해결이 향상 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0040f93cb8c4b8bdab630ff12697ba1b0160ca64" translate="yes" xml:space="preserve">
          <source>In order to enable script effects replication, you need to issue the following Lua command before any write operated by the script:</source>
          <target state="translated">스크립트 효과 복제를 사용하려면 스크립트에서 쓰기 작업을 수행하기 전에 다음 Lua 명령을 실행해야합니다.</target>
        </trans-unit>
        <trans-unit id="013756f6d564f805aee9f75f0b5914a1c30d7b5d" translate="yes" xml:space="preserve">
          <source>In order to enable this form, the &lt;a href=&quot;keys&quot;&gt;KEYS&lt;/a&gt; option is used, and the normal &lt;em&gt;key&lt;/em&gt; argument is set to an empty string. The actual key names will be provided after the &lt;a href=&quot;keys&quot;&gt;KEYS&lt;/a&gt; argument itself, like in the following example:</source>
          <target state="translated">이 양식을 사용하기 위해 &lt;a href=&quot;keys&quot;&gt;KEYS&lt;/a&gt; 옵션이 사용되며 일반 &lt;em&gt;키&lt;/em&gt; 인수는 빈 문자열로 설정됩니다. 실제 키 이름은 다음 예제와 같이 &lt;a href=&quot;keys&quot;&gt;KEYS&lt;/a&gt; 인수 자체 뒤에 제공됩니다 .</target>
        </trans-unit>
        <trans-unit id="7e7cf3fffb86f4198755cdccfe390f7daca4376b" translate="yes" xml:space="preserve">
          <source>In order to enforce this behavior in scripts Redis does the following:</source>
          <target state="translated">스크립트에서이 동작을 시행하기 위해 Redis는 다음을 수행합니다.</target>
        </trans-unit>
        <trans-unit id="4210ec3e973c5d5ac271cc1ab7ffcffaa3f2c4da" translate="yes" xml:space="preserve">
          <source>In order to fix a broken cluster where certain slots are unassigned.</source>
          <target state="translated">특정 슬롯이 할당되지 않은 손상된 클러스터를 수정하기 위해.</target>
        </trans-unit>
        <trans-unit id="4708216948f38c6f376d2b00aef53c77bfc810bd" translate="yes" xml:space="preserve">
          <source>In order to iterate a stream, we can proceed as follows. Let's assume that we want two elements per iteration. We start fetching the first two elements, which is trivial:</source>
          <target state="translated">스트림을 반복하기 위해 다음과 같이 진행할 수 있습니다. 반복 당 2 개의 요소를 원한다고 가정 해 봅시다. 처음 두 요소를 가져 오기 시작합니다.</target>
        </trans-unit>
        <trans-unit id="93f82278196654b93d4f14013ea15fe416b7d299" translate="yes" xml:space="preserve">
          <source>In order to make it a pure function, but still be sure that every invocation of the script will result in different random elements, we can simply add an additional argument to the script that will be used in order to seed the Lua pseudo-random number generator. The new script is as follows:</source>
          <target state="translated">순수한 함수로 만들기 위해 스크립트를 호출 할 때마다 다른 임의의 요소가 생성되도록하려면 루아 의사 난수를 시드하기 위해 사용할 인수를 스크립트에 추가하면됩니다. 발전기. 새로운 스크립트는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="5e754dbb6b6073549994be57928409b8a9518fbf" translate="yes" xml:space="preserve">
          <source>In order to make sure the redis.conf file is always consistent, that is, on errors or crashes you always end with the old file, or the new one, the rewrite is performed with a single &lt;code&gt;write(2)&lt;/code&gt; call that has enough content to be at least as big as the old file. Sometimes additional padding in the form of comments is added in order to make sure the resulting file is big enough, and later the file gets truncated to remove the padding at the end.</source>
          <target state="translated">redis.conf 파일이 항상 일관성을 유지하기 위해, 즉 오류나 충돌이 발생하면 항상 이전 파일 또는 새 파일로 끝납니다. 충분한 내용 의 단일 &lt;code&gt;write(2)&lt;/code&gt; 호출로 다시 쓰기가 수행됩니다. 적어도 이전 파일만큼 커야합니다. 때로는 결과 파일이 충분히 큰지 확인하기 위해 주석 형식의 추가 패딩이 추가되고 나중에 파일이 끝에서 패딩을 제거하기 위해 잘립니다.</target>
        </trans-unit>
        <trans-unit id="45b71d9b591350682c94742bdef7ff99466f0e92" translate="yes" xml:space="preserve">
          <source>In order to make this locking algorithm more robust, a client holding a lock should always check the timeout didn't expire before unlocking the key with &lt;a href=&quot;del&quot;&gt;DEL&lt;/a&gt; because client failures can be complex, not just crashing but also blocking a lot of time against some operations and trying to issue &lt;a href=&quot;del&quot;&gt;DEL&lt;/a&gt; after a lot of time (when the LOCK is already held by another client).</source>
          <target state="translated">이 잠금 알고리즘을보다 견고하게 만들려면 잠금을 보유한 클라이언트가 &lt;a href=&quot;del&quot;&gt;DEL을 사용&lt;/a&gt; 하여 키를 잠금 해제하기 전에 항상 시간 초과가 만료되지 않았는지 확인해야 합니다. 많은 시간이 지나면 &lt;a href=&quot;del&quot;&gt;DEL&lt;/a&gt; 을 발행하려고 시도합니다 (다른 클라이언트가 이미 잠금을 보유한 경우).</target>
        </trans-unit>
        <trans-unit id="26d3078f4ebbdf0701299addb5fed6bbed540a2c" translate="yes" xml:space="preserve">
          <source>In order to obtain a correct behavior without sacrificing consistency, when a key expires, a &lt;a href=&quot;del&quot;&gt;DEL&lt;/a&gt; operation is synthesized in both the AOF file and gains all the attached replicas nodes. This way the expiration process is centralized in the master instance, and there is no chance of consistency errors.</source>
          <target state="translated">일관성을 유지하면서 올바른 동작을 얻기 위해 키가 만료되면 &lt;a href=&quot;del&quot;&gt;DEL&lt;/a&gt; 작업이 AOF 파일에서 모두 합성되고 연결된 모든 복제본 노드를 얻습니다. 이렇게하면 만료 프로세스가 마스터 인스턴스에서 중앙 집중화되며 일관성 오류가 발생할 가능성이 없습니다.</target>
        </trans-unit>
        <trans-unit id="40403839cd4ec5549ce4c8b0b88fe76bd596deee" translate="yes" xml:space="preserve">
          <source>In other words there is a one-to-one conversion between Lua and Redis types. The following table shows you all the conversions rules:</source>
          <target state="translated">즉, Lua와 Redis 유형간에 일대일 변환이 있습니다. 다음 표는 모든 변환 규칙을 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="73283192b40f30e6bf23bca973e203da21ec7a06" translate="yes" xml:space="preserve">
          <source>In practical terms, Redis databases should mainly used in order to, if needed, separate different keys belonging to the same application, and not in order to use a single Redis instance for multiple unrelated applications.</source>
          <target state="translated">실질적인 측면에서, Redis 데이터베이스는 필요한 경우 동일한 애플리케이션에 속하는 서로 다른 키를 분리하고 여러 관련없는 애플리케이션에 단일 Redis 인스턴스를 사용하기 위해 주로 사용되어야합니다.</target>
        </trans-unit>
        <trans-unit id="1cb1bb56f86e93948082da017865db052e971cd7" translate="yes" xml:space="preserve">
          <source>In the &lt;code&gt;COUNT&lt;/code&gt; option documentation, we state that sometimes this family of commands may return all the elements of a Set, Hash or Sorted Set at once in a single call, regardless of the &lt;code&gt;COUNT&lt;/code&gt; option value. The reason why this happens is that the cursor-based iterator can be implemented, and is useful, only when the aggregate data type that we are scanning is represented as an hash table. However Redis uses a &lt;a href=&quot;https://redis.io/topics/memory-optimization&quot;&gt;memory optimization&lt;/a&gt; where small aggregate data types, until they reach a given amount of items or a given max size of single elements, are represented using a compact single-allocation packed encoding. When this is the case, &lt;a href=&quot;scan&quot;&gt;SCAN&lt;/a&gt; has no meaningful cursor to return, and must iterate the whole data structure at once, so the only sane behavior it has is to return everything in a call.</source>
          <target state="translated">에서 &lt;code&gt;COUNT&lt;/code&gt; 의 옵션 문서, 우리는 명령 때로는 가족 관계없이의 단일 호출로 한 번에 설정, 해시 또는 소트 세트의 모든 요소를 반환 할 수 있습니다 상태 &lt;code&gt;COUNT&lt;/code&gt; 의 옵션 값. 이것이 발생하는 이유는 커서 기반 반복자가 구현 될 수 있고 스캔하는 집계 데이터 유형이 해시 테이블로 표시되는 경우에만 유용하기 때문입니다. 그러나 Redis는 소량의 집계 데이터 유형이 주어진 양의 항목 또는 주어진 최대 크기의 단일 요소에 도달 할 때까지 소형 단일 할당 묶음 인코딩을 사용하여 표시 되는 &lt;a href=&quot;https://redis.io/topics/memory-optimization&quot;&gt;메모리 최적화&lt;/a&gt; 를 사용합니다. 이 경우 &lt;a href=&quot;scan&quot;&gt;SCAN&lt;/a&gt; 의미있는 커서가 반환되지 않으며 전체 데이터 구조를 한 번에 반복해야하므로 호출에서 모든 것을 반환하는 것이 제정신입니다.</target>
        </trans-unit>
        <trans-unit id="8c0e05b70b67e4b92ac3373b78b09162115732be" translate="yes" xml:space="preserve">
          <source>In the above case the entry &lt;code&gt;1526985054069-0&lt;/code&gt; exists, otherwise the server would have sent us the next one. Using &lt;code&gt;COUNT&lt;/code&gt; is also the base in order to use &lt;a href=&quot;xrange&quot;&gt;XRANGE&lt;/a&gt; as an iterator.</source>
          <target state="translated">위의 경우 &lt;code&gt;1526985054069-0&lt;/code&gt; 항목 이 존재하면 서버가 다음 항목 을 전송했을 것입니다. &lt;a href=&quot;xrange&quot;&gt;XRANGE&lt;/a&gt; 를 반복자 로 사용하려면 &lt;code&gt;COUNT&lt;/code&gt; 를 사용하는 것도 기본입니다 .</target>
        </trans-unit>
        <trans-unit id="f40be215733bf9374d8b827188eeddff85363cc0" translate="yes" xml:space="preserve">
          <source>In the above example of counting days, even after 10 years the application is online we still have just &lt;code&gt;365*10&lt;/code&gt; bits of data per user, that is just 456 bytes per user. With this amount of data &lt;a href=&quot;bitcount&quot;&gt;BITCOUNT&lt;/a&gt; is still as fast as any other O(1) Redis command like &lt;a href=&quot;get&quot;&gt;GET&lt;/a&gt; or &lt;a href=&quot;incr&quot;&gt;INCR&lt;/a&gt;.</source>
          <target state="translated">위의 날짜 계산 예에서 10 년이 지난 후에도 응용 프로그램은 온라인 상태이지만 사용자 당 &lt;code&gt;365*10&lt;/code&gt; 비트의 데이터, 즉 사용자 당 456 바이트입니다. 이 데이터 양으로 &lt;a href=&quot;bitcount&quot;&gt;BITCOUNT&lt;/a&gt; 는 여전히 &lt;a href=&quot;get&quot;&gt;GET&lt;/a&gt; 또는 &lt;a href=&quot;incr&quot;&gt;INCR&lt;/a&gt; 과 같은 다른 O (1) Redis 명령만큼 빠릅니다 .</target>
        </trans-unit>
        <trans-unit id="76a0365bc0972ed4321b2f354ddf621810b8b004" translate="yes" xml:space="preserve">
          <source>In the above example we claim the message with ID &lt;code&gt;1526569498055-0&lt;/code&gt;, only if the message is idle for at least one hour without the original consumer or some other consumer making progresses (acknowledging or claiming it), and assigns the ownership to the consumer &lt;code&gt;Alice&lt;/code&gt;.</source>
          <target state="translated">위의 예에서 우리 는 메시지가 원래 소비자 또는 다른 소비자가 진행하지 않고 (확인 또는 청구하지 않고) 적어도 1 시간 동안 유휴 상태 인 경우에만 소유권이 소비자 &lt;code&gt;Alice&lt;/code&gt; 에게 할당 된 경우에만 ID가 &lt;code&gt;1526569498055-0&lt;/code&gt; 인 메시지를 청구합니다. .</target>
        </trans-unit>
        <trans-unit id="0bef89cf285951fc9b88c842b027336864d10794" translate="yes" xml:space="preserve">
          <source>In the above example you can see that the reported information are the number of elements of the stream, details about the radix tree representing the stream mostly useful for optimization and debugging tasks, the number of consumer groups associated with the stream, the last generated ID that may not be the same as the last entry ID in case some entry was deleted. Finally the full first and last entry in the stream are shown, in order to give some sense about what is the stream content.</source>
          <target state="translated">위의 예에서보고 된 정보는 스트림의 요소 수, 최적화 및 디버깅 작업에 주로 유용한 스트림을 나타내는 기수 트리에 대한 세부 정보, 스트림과 관련된 소비자 그룹 수, 마지막으로 생성 된 ID입니다. 일부 항목이 삭제 된 경우 마지막 항목 ID와 동일하지 않을 수 있습니다. 마지막으로 스트림 내용이 무엇인지 이해하기 위해 스트림의 전체 첫 번째 항목과 마지막 항목이 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="5e1f5dbd04f5dc1db0a038c0d0e6f0ff4a4acd34" translate="yes" xml:space="preserve">
          <source>In the above locking algorithm there is a problem: what happens if a client fails, crashes, or is otherwise not able to release the lock? It's possible to detect this condition because the lock key contains a UNIX timestamp. If such a timestamp is equal to the current Unix time the lock is no longer valid.</source>
          <target state="translated">위의 잠금 알고리즘에는 문제가 있습니다. 클라이언트가 실패하거나 충돌하거나 잠금을 해제 할 수없는 경우 어떻게됩니까? 잠금 키에 UNIX 타임 스탬프가 포함되어 있기 때문에이 조건을 감지 할 수 있습니다. 이러한 타임 스탬프가 현재 Unix 시간과 같으면 잠금이 더 이상 유효하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="7063c49f04f76f5d83a38b2826e82b8706b19e78" translate="yes" xml:space="preserve">
          <source>In the case of &lt;a href=&quot;mset&quot;&gt;MSET&lt;/a&gt;, keys are every other position so the step value is 2. Compare with &lt;a href=&quot;mget&quot;&gt;MGET&lt;/a&gt; above where the step value is just 1.</source>
          <target state="translated">&lt;a href=&quot;mset&quot;&gt;MSET&lt;/a&gt; 의 경우 키는 다른 모든 위치이므로 단계 값은 2입니다. 위의 &lt;a href=&quot;mget&quot;&gt;MGET&lt;/a&gt; 과 비교 하여 단계 값은 1입니다.</target>
        </trans-unit>
        <trans-unit id="51cf6b9278dbdee20c8485961f1e557cd7119742" translate="yes" xml:space="preserve">
          <source>In the context of a node that has received a &lt;code&gt;DELSLOTS&lt;/code&gt; command and has consequently removed the associations for the passed hash slots, we say those hash slots are &lt;em&gt;unbound&lt;/em&gt;. Note that the existence of unbound hash slots occurs naturally when a node has not been configured to handle them (something that can be done with the &lt;code&gt;ADDSLOTS&lt;/code&gt; command) and if it has not received any information about who owns those hash slots (something that it can learn from heartbeat or update messages).</source>
          <target state="translated">&lt;code&gt;DELSLOTS&lt;/code&gt; 명령 을 수신하여 결과적으로 전달 된 해시 슬롯에 대한 연관을 제거한 노드 와 관련하여 해당 해시 슬롯은 &lt;em&gt;바인드되지 않습니다&lt;/em&gt; . 언 바운드 해시 슬롯의 존재는 노드가 노드를 처리하도록 구성되지 않았거나 ( &lt;code&gt;ADDSLOTS&lt;/code&gt; 명령 으로 수행 할 수있는 것 ) 해시 슬롯을 소유 한 사람에 대한 정보를받지 못한 경우 자연스럽게 발생합니다. 하트 비트 또는 업데이트 메시지를 통해 학습).</target>
        </trans-unit>
        <trans-unit id="0c3893e92cc9396f13c9f99b5e7ad611d2ac46c2" translate="yes" xml:space="preserve">
          <source>In the context of a stream consumer group, this command changes the ownership of a pending message, so that the new owner is the consumer specified as the command argument. Normally this is what happens:</source>
          <target state="translated">스트림 소비자 그룹의 컨텍스트에서이 명령은 보류중인 메시지의 소유권을 변경하여 새 소유자가 명령 인수로 지정된 소비자가되도록합니다. 일반적으로 이런 일이 발생합니다.</target>
        </trans-unit>
        <trans-unit id="57bf1b4701a5c94880ee6e46bfe56ac8c7000db8" translate="yes" xml:space="preserve">
          <source>In the example above, the first call uses zero as a cursor, to start the iteration. The second call uses the cursor returned by the previous call as the first element of the reply, that is, 17.</source>
          <target state="translated">위의 예에서 첫 번째 호출은 반복을 시작하기 위해 커서로 0을 사용합니다. 두 번째 호출은 이전 호출에서 반환 된 커서를 응답의 첫 번째 요소, 즉 17로 사용합니다.</target>
        </trans-unit>
        <trans-unit id="64f37e2cb3f5829eb3ba5c3a4f7f3eea2d872acc" translate="yes" xml:space="preserve">
          <source>In the extended form we no longer see the summary information, instead there are detailed information for each message in the pending entries list. For each message four attributes are returned:</source>
          <target state="translated">확장 된 양식에서는 더 이상 요약 정보가 표시되지 않고 보류중인 항목 목록에 각 메시지에 대한 자세한 정보가 있습니다. 각 메시지마다 네 가지 속성이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="bec3c889a89e0a9bff423ca26bc6e8f597b12b82" translate="yes" xml:space="preserve">
          <source>In the following example the first call to &lt;a href=&quot;wait&quot;&gt;WAIT&lt;/a&gt; does not use a timeout and asks for the write to reach 1 replica. It returns with success. In the second attempt instead we put a timeout, and ask for the replication of the write to two replicas. Since there is a single replica available, after one second &lt;a href=&quot;wait&quot;&gt;WAIT&lt;/a&gt; unblocks and returns 1, the number of replicas reached.</source>
          <target state="translated">다음 예제에서 &lt;a href=&quot;wait&quot;&gt;WAIT에&lt;/a&gt; 대한 첫 번째 호출 은 시간 종료를 사용하지 않고 쓰기가 1 개의 복제본에 도달하도록 요청합니다. 성공으로 돌아옵니다. 두 번째 시도에서는 시간 초과를 설정하고 두 복제본에 대한 쓰기 복제를 요청합니다. 사용 가능한 단일 복제본이 있으므로 1 초 동안 &lt;a href=&quot;wait&quot;&gt;WAIT가&lt;/a&gt; 차단을 해제하고 1을 반환하면 복제본 수에 도달합니다.</target>
        </trans-unit>
        <trans-unit id="275502ca7bb30b2b024cd13d4001c3a1615096d6" translate="yes" xml:space="preserve">
          <source>In the following example we can see how floats and arrays with nils are handled:</source>
          <target state="translated">다음 예제에서는 nil이있는 float 및 배열이 처리되는 방식을 볼 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="67aa25f5afe2285456ce925944008c892a8bde6a" translate="yes" xml:space="preserve">
          <source>In the following example we'll show why the command must not just remove a given node from the nodes table, but also prevent it for being re-inserted again for some time.</source>
          <target state="translated">다음 예에서는 명령이 노드 테이블에서 지정된 노드를 제거해야 할뿐만 아니라 일정 시간 동안 다시 삽입되지 않도록하는 이유를 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="1b27ba03d8db2c5155774200622adb0e3f3e2724" translate="yes" xml:space="preserve">
          <source>In the following example you can see how the encoding changes once Redis is no longer able to use the space saving encoding.</source>
          <target state="translated">다음 예에서 Redis가 더 이상 공간 절약 인코딩을 사용할 수없는 경우 인코딩이 어떻게 변경되는지 확인할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d52481dfbaf58234ade345bdada825c509d89e9a" translate="yes" xml:space="preserve">
          <source>In the specific case of the implementation of &lt;a href=&quot;wait&quot;&gt;WAIT&lt;/a&gt;, Redis remembers, for each client, the replication offset of the produced replication stream when a given write command was executed in the context of a given client. When &lt;a href=&quot;wait&quot;&gt;WAIT&lt;/a&gt; is called Redis checks if the specified number of replicas already acknowledged this offset or a greater one.</source>
          <target state="translated">&lt;a href=&quot;wait&quot;&gt;WAIT&lt;/a&gt; 구현의 특정 경우 , Redis는 주어진 쓰기 명령이 주어진 클라이언트의 컨텍스트에서 실행될 때 생성 된 복제 스트림의 복제 오프셋을 각 클라이언트에 대해 기억합니다. &lt;a href=&quot;wait&quot;&gt;WAIT&lt;/a&gt; 가 호출 되면 Redis는 지정된 수의 복제본이 이미이 오프셋 이상을 승인했는지 확인합니다.</target>
        </trans-unit>
        <trans-unit id="903ead95cd2a4a5b9cbb852a8e750aedc79fee51" translate="yes" xml:space="preserve">
          <source>In this case, &lt;a href=&quot;xrange&quot;&gt;XRANGE&lt;/a&gt; will auto-complete the start interval with &lt;code&gt;-0&lt;/code&gt; and end interval with &lt;code&gt;-18446744073709551615&lt;/code&gt;, in order to return all the entries that were generated between a given millisecond and the end of the other specified millisecond. This also means that repeating the same millisecond two times, we get all the entries within such millisecond, because the sequence number range will be from zero to the maximum.</source>
          <target state="translated">이 경우 &lt;a href=&quot;xrange&quot;&gt;XRANGE&lt;/a&gt; 는 지정된 밀리 초와 다른 지정된 밀리 초의 끝 사이에 생성 된 모든 항목을 리턴하기 위해 시작 간격을 &lt;code&gt;-0&lt;/code&gt; 으로 , 종료 간격을 &lt;code&gt;-18446744073709551615&lt;/code&gt; 로 자동 완성합니다 . 이것은 동일한 밀리 초를 두 번 반복하면 시퀀스 번호 범위가 0에서 최대가되기 때문에 그러한 밀리 초 내에 모든 항목을 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="9a9dd8640d5d9c354f3497144f8f471bfe5130bf" translate="yes" xml:space="preserve">
          <source>In this form the command returns general information about the stream stored at the specified key.</source>
          <target state="translated">이 형식으로 명령은 지정된 키에 저장된 스트림에 대한 일반 정보를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="d9dc316159e0ab75070b1301d7b7adb86e569cda" translate="yes" xml:space="preserve">
          <source>In this form we just get as output all the consumer groups associated with the stream:</source>
          <target state="translated">이 형식에서는 스트림과 관련된 모든 소비자 그룹을 출력으로 얻습니다.</target>
        </trans-unit>
        <trans-unit id="ddaa9f098110e2f5ed979aa965f072762268f6b4" translate="yes" xml:space="preserve">
          <source>In this form, the command outputs the total number of pending messages for this consumer group, which is one, followed by the smallest and greatest ID among the pending messages, and then list every consumer in the consumer group with at least one pending message, and the number of pending messages it has.</source>
          <target state="translated">이 양식에서이 명령은이 소비자 그룹에 대해 보류중인 메시지의 총 수 (하나는 다음에 보류중인 메시지 중 가장 작고 가장 큰 ID)를 출력 한 다음 소비자 그룹의 모든 소비자를 하나 이상의 보류중인 메시지와 함께 나열합니다. 보류중인 메시지 수</target>
        </trans-unit>
        <trans-unit id="7449f50cc271410bffecdb508cde8a6a6c5d9a68" translate="yes" xml:space="preserve">
          <source>In this particular case, running a single &lt;a href=&quot;monitor&quot;&gt;MONITOR&lt;/a&gt; client can reduce the throughput by more than 50%. Running more &lt;a href=&quot;monitor&quot;&gt;MONITOR&lt;/a&gt; clients will reduce throughput even more.</source>
          <target state="translated">이 경우 단일 &lt;a href=&quot;monitor&quot;&gt;MONITOR&lt;/a&gt; 클라이언트를 실행 하면 처리량을 50 % 이상 줄일 수 있습니다. 더 많은 &lt;a href=&quot;monitor&quot;&gt;MONITOR&lt;/a&gt; 클라이언트를 실행 하면 처리량이 훨씬 줄어 듭니다.</target>
        </trans-unit>
        <trans-unit id="9499b337b96eb666a58f2a5ab4a4329e2007a622" translate="yes" xml:space="preserve">
          <source>In this replication mode, while Lua scripts are executed, Redis collects all the commands executed by the Lua scripting engine that actually modify the dataset. When the script execution finishes, the sequence of commands that the script generated are wrapped into a MULTI / EXEC transaction and are sent to replicas and AOF.</source>
          <target state="translated">이 복제 모드에서 Lua 스크립트가 실행되는 동안 Redis는 실제로 데이터 세트를 수정하는 Lua 스크립팅 엔진이 실행하는 모든 명령을 수집합니다. 스크립트 실행이 완료되면 스크립트가 생성 한 명령 시퀀스가 ​​MULTI / EXEC 트랜잭션으로 랩핑되어 복제본 및 AOF로 전송됩니다.</target>
        </trans-unit>
        <trans-unit id="ef44dcb3d65131c01d1f4f06af638521f8511b76" translate="yes" xml:space="preserve">
          <source>In this way the example consumer code will fetch only new messages, process them, and acknowledge them via &lt;a href=&quot;xack&quot;&gt;XACK&lt;/a&gt;. However the example code above is not complete, because it does not handle recovering after a crash. What will happen if we crash in the middle of processing messages, is that our messages will remain in the pending entries list, so we can access our history by giving &lt;a href=&quot;xreadgroup&quot;&gt;XREADGROUP&lt;/a&gt; initially an ID of 0, and performing the same loop. Once providing and ID of 0 the reply is an empty set of messages, we know that we processed and acknowledged all the pending messages: we can start to use &lt;code&gt;&amp;gt;&lt;/code&gt; as ID, in order to get the new messages and rejoin the consumers that are processing new things.</source>
          <target state="translated">이런 식으로 소비자 코드 예제는 새 메시지 만 가져 와서 처리하고 &lt;a href=&quot;xack&quot;&gt;XACK을&lt;/a&gt; 통해 승인합니다 . 그러나 위의 예제 코드는 충돌 후 복구를 처리하지 않기 때문에 완전하지 않습니다. 메시지 처리 중에 충돌이 발생하면 메시지가 보류중인 항목 목록에 남아 있으므로 &lt;a href=&quot;xreadgroup&quot;&gt;XREADGROUP에&lt;/a&gt; 초기에 ID 0 을 부여 하고 동일한 루프를 수행하여 기록에 액세스 할 수 있습니다 . 응답을 제공하고 ID가 0이면 빈 메시지 세트가 처리됩니다. 보류중인 모든 메시지를 처리하고 확인 했습니다. 새 메시지를 가져오고 처리중인 소비자에 다시 참여하기 위해 &lt;code&gt;&amp;gt;&lt;/code&gt; 를 ID 로 사용할 수 있습니다. 새로운 것들.</target>
        </trans-unit>
        <trans-unit id="0c6aff080ab580caca11c078c7c0fd0c074cc4b5" translate="yes" xml:space="preserve">
          <source>In this way when a node in migrating state generates an &lt;code&gt;ASK&lt;/code&gt; redirection, the client contacts the target node, sends &lt;code&gt;ASKING&lt;/code&gt;, and immediately after sends the command. This way commands about non-existing keys in the old node or keys already migrated to the target node are executed in the target node, so that:</source>
          <target state="translated">이러한 방식으로 마이그레이션 상태의 노드가 &lt;code&gt;ASK&lt;/code&gt; 경로 재 지정을 생성 하면 클라이언트는 대상 노드에 접속하여 &lt;code&gt;ASKING&lt;/code&gt; 을 보낸 후 명령을 보낸 직후에 보냅니다. 이 방법으로 기존 노드에 존재하지 않는 키 또는 대상 노드로 이미 마이그레이션 된 키에 대한 명령이 대상 노드에서 실행되므로 다음을 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8a4976fd385ad81414ef5f0b5eb1d542ebee200c" translate="yes" xml:space="preserve">
          <source>Incomplete IDs</source>
          <target state="translated">불완전한 ID</target>
        </trans-unit>
        <trans-unit id="d076531fdc3e2f8747b11778603627c7ff4c3c03" translate="yes" xml:space="preserve">
          <source>Increment the specified &lt;code&gt;field&lt;/code&gt; of a hash stored at &lt;code&gt;key&lt;/code&gt;, and representing a floating point number, by the specified &lt;code&gt;increment&lt;/code&gt;. If the increment value is negative, the result is to have the hash field value &lt;strong&gt;decremented&lt;/strong&gt; instead of incremented. If the field does not exist, it is set to &lt;code&gt;0&lt;/code&gt; before performing the operation. An error is returned if one of the following conditions occur:</source>
          <target state="translated">&lt;code&gt;key&lt;/code&gt; 에 저장되고 부동 소수점 숫자를 나타내는 해시 의 지정된 &lt;code&gt;field&lt;/code&gt; 를 지정된 &lt;code&gt;increment&lt;/code&gt; . 증분 값이 음수이면 해시 필드 값 이 증분 대신 &lt;strong&gt;감소&lt;/strong&gt; 됩니다. 필드가 존재하지 않으면 조작을 수행하기 전에 &lt;code&gt;0&lt;/code&gt; 으로 설정됩니다 . 다음 조건 중 하나가 발생하면 오류가 반환됩니다.&lt;strong&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="0b2569a3073ebcb62549ecb7ec5a99e5e6f20a57" translate="yes" xml:space="preserve">
          <source>Increment the string representing a floating point number stored at &lt;code&gt;key&lt;/code&gt; by the specified &lt;code&gt;increment&lt;/code&gt;. By using a negative &lt;code&gt;increment&lt;/code&gt; value, the result is that the value stored at the key is decremented (by the obvious properties of addition). If the key does not exist, it is set to &lt;code&gt;0&lt;/code&gt; before performing the operation. An error is returned if one of the following conditions occur:</source>
          <target state="translated">지정된 &lt;code&gt;increment&lt;/code&gt; 만큼 &lt;code&gt;key&lt;/code&gt; 에 저장된 부동 소수점 숫자를 나타내는 문자열을 증가시킵니다 . 음의 &lt;code&gt;increment&lt;/code&gt; 값 을 사용 하면 키에 저장된 값이 추가되는 명백한 속성에 따라 감소합니다. 키가 없으면 조작을 수행하기 전에 &lt;code&gt;0&lt;/code&gt; 으로 설정됩니다 . 다음 조건 중 하나가 발생하면 오류가 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="b0ab00f78f69567a82e2e724fbf2c011708c66b2" translate="yes" xml:space="preserve">
          <source>Increments the number stored at &lt;code&gt;field&lt;/code&gt; in the hash stored at &lt;code&gt;key&lt;/code&gt; by &lt;code&gt;increment&lt;/code&gt;. If &lt;code&gt;key&lt;/code&gt; does not exist, a new key holding a hash is created. If &lt;code&gt;field&lt;/code&gt; does not exist the value is set to &lt;code&gt;0&lt;/code&gt; before the operation is performed.</source>
          <target state="translated">&lt;code&gt;key&lt;/code&gt; 에 저장된 해시의 &lt;code&gt;field&lt;/code&gt; 에 저장된 숫자 를 &lt;code&gt;increment&lt;/code&gt; 만큼 증가시킵니다 . 경우 &lt;code&gt;key&lt;/code&gt; 존재하지 않는, 해시를 들고 새 키가 생성됩니다. 경우 &lt;code&gt;field&lt;/code&gt; 값이 존재하지 않음으로 설정되어 &lt;code&gt;0&lt;/code&gt; 동작이 수행되기 전에.</target>
        </trans-unit>
        <trans-unit id="05fa8f17b5cc5360627e65f0e1bfbcb74f909616" translate="yes" xml:space="preserve">
          <source>Increments the number stored at &lt;code&gt;key&lt;/code&gt; by &lt;code&gt;increment&lt;/code&gt;. If the key does not exist, it is set to &lt;code&gt;0&lt;/code&gt; before performing the operation. An error is returned if the key contains a value of the wrong type or contains a string that can not be represented as integer. This operation is limited to 64 bit signed integers.</source>
          <target state="translated">&lt;code&gt;key&lt;/code&gt; 에 저장된 숫자 를 &lt;code&gt;increment&lt;/code&gt; 만큼 증가시킵니다 . 키가 없으면 조작을 수행하기 전에 &lt;code&gt;0&lt;/code&gt; 으로 설정됩니다 . 키에 잘못된 유형의 값이 있거나 정수로 표현할 수없는 문자열이 포함 된 경우 오류가 리턴됩니다. 이 연산은 64 비트 부호있는 정수로 제한됩니다.</target>
        </trans-unit>
        <trans-unit id="f9bd9898aaa3a2048914100ede9b89ccf7adc73a" translate="yes" xml:space="preserve">
          <source>Increments the number stored at &lt;code&gt;key&lt;/code&gt; by one. If the key does not exist, it is set to &lt;code&gt;0&lt;/code&gt; before performing the operation. An error is returned if the key contains a value of the wrong type or contains a string that can not be represented as integer. This operation is limited to 64 bit signed integers.</source>
          <target state="translated">&lt;code&gt;key&lt;/code&gt; 에 저장된 숫자 를 하나씩 증가시킵니다 . 키가 없으면 조작을 수행하기 전에 &lt;code&gt;0&lt;/code&gt; 으로 설정됩니다 . 키에 잘못된 유형의 값이 있거나 정수로 표현할 수없는 문자열이 포함 된 경우 오류가 리턴됩니다. 이 연산은 64 비트 부호있는 정수로 제한됩니다.</target>
        </trans-unit>
        <trans-unit id="b3b4497f3f9f641c1f07a98ba2294810e7c1c3a5" translate="yes" xml:space="preserve">
          <source>Increments the score of &lt;code&gt;member&lt;/code&gt; in the sorted set stored at &lt;code&gt;key&lt;/code&gt; by &lt;code&gt;increment&lt;/code&gt;. If &lt;code&gt;member&lt;/code&gt; does not exist in the sorted set, it is added with &lt;code&gt;increment&lt;/code&gt; as its score (as if its previous score was &lt;code&gt;0.0&lt;/code&gt;). If &lt;code&gt;key&lt;/code&gt; does not exist, a new sorted set with the specified &lt;code&gt;member&lt;/code&gt; as its sole member is created.</source>
          <target state="translated">&lt;code&gt;key&lt;/code&gt; 에 저장된 정렬 된 세트 의 &lt;code&gt;member&lt;/code&gt; 점수를 &lt;code&gt;increment&lt;/code&gt; 만큼 증가시킵니다 . 경우 &lt;code&gt;member&lt;/code&gt; 정렬 된 세트에 존재하지 않는, 그것은과 추가 &lt;code&gt;increment&lt;/code&gt; 의 점수로 (이전 점수 인 것처럼 &lt;code&gt;0.0&lt;/code&gt; ). 경우 &lt;code&gt;key&lt;/code&gt; 존재하지 않는, 지정된 가지는 새로운 소트 세트 &lt;code&gt;member&lt;/code&gt; 의 단독 구성원으로 만들어집니다.</target>
        </trans-unit>
        <trans-unit id="b9e98de9b6972c3697024196bb1cf498f5df1583" translate="yes" xml:space="preserve">
          <source>Information about slots propagation and warnings</source>
          <target state="translated">슬롯 전파 및 경고에 대한 정보</target>
        </trans-unit>
        <trans-unit id="df92aa3b0e06eb79bf7c8f7098db769523ac9333" translate="yes" xml:space="preserve">
          <source>Insert all the specified values at the head of the list stored at &lt;code&gt;key&lt;/code&gt;. If &lt;code&gt;key&lt;/code&gt; does not exist, it is created as empty list before performing the push operations. When &lt;code&gt;key&lt;/code&gt; holds a value that is not a list, an error is returned.</source>
          <target state="translated">&lt;code&gt;key&lt;/code&gt; 에 저장된 목록의 헤드에 지정된 모든 값을 삽입하십시오 . 경우 &lt;code&gt;key&lt;/code&gt; 존재하지 않는, 그것은 푸시 작업을 수행하기 전에 빈 목록으로 작성됩니다. 때 &lt;code&gt;key&lt;/code&gt; 목록이 아닌 값을 보유하고 오류가 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="d56f1eeeec0b6889ab12fc76a629d9cf4f377993" translate="yes" xml:space="preserve">
          <source>Insert all the specified values at the tail of the list stored at &lt;code&gt;key&lt;/code&gt;. If &lt;code&gt;key&lt;/code&gt; does not exist, it is created as empty list before performing the push operation. When &lt;code&gt;key&lt;/code&gt; holds a value that is not a list, an error is returned.</source>
          <target state="translated">&lt;code&gt;key&lt;/code&gt; 에 저장된 목록의 끝에 지정된 모든 값을 삽입하십시오 . 경우 &lt;code&gt;key&lt;/code&gt; 존재하지 않는, 그것은 푸시 작업을 수행하기 전에 빈 목록으로 작성됩니다. 때 &lt;code&gt;key&lt;/code&gt; 목록이 아닌 값을 보유하고 오류가 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="41914bb38b36cf790ad6dea5c850ff4f739bdf2f" translate="yes" xml:space="preserve">
          <source>Inserts &lt;code&gt;value&lt;/code&gt; at the head of the list stored at &lt;code&gt;key&lt;/code&gt;, only if &lt;code&gt;key&lt;/code&gt; already exists and holds a list. In contrary to &lt;a href=&quot;lpush&quot;&gt;LPUSH&lt;/a&gt;, no operation will be performed when &lt;code&gt;key&lt;/code&gt; does not yet exist.</source>
          <target state="translated">&lt;code&gt;key&lt;/code&gt; 가 이미 존재하고리스트를 보유하고있는 경우에만 &lt;code&gt;key&lt;/code&gt; 에 저장된리스트의 헤드에 &lt;code&gt;value&lt;/code&gt; 을 삽입합니다 . &lt;a href=&quot;lpush&quot;&gt;LPUSH와는&lt;/a&gt; 반대로 &lt;code&gt;key&lt;/code&gt; 가 아직 없으면 작업이 수행 되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="483c4cdd37e1303cef072b494af9c173f5ba1e3a" translate="yes" xml:space="preserve">
          <source>Inserts &lt;code&gt;value&lt;/code&gt; at the tail of the list stored at &lt;code&gt;key&lt;/code&gt;, only if &lt;code&gt;key&lt;/code&gt; already exists and holds a list. In contrary to &lt;a href=&quot;rpush&quot;&gt;RPUSH&lt;/a&gt;, no operation will be performed when &lt;code&gt;key&lt;/code&gt; does not yet exist.</source>
          <target state="translated">&lt;code&gt;key&lt;/code&gt; 이미 존재하고 목록을 보유하는 경우에만 &lt;code&gt;key&lt;/code&gt; 에 저장된 목록의 끝에 &lt;code&gt;value&lt;/code&gt; 을 삽입합니다 . &lt;a href=&quot;rpush&quot;&gt;RPUSH와는&lt;/a&gt; 반대로 &lt;code&gt;key&lt;/code&gt; 가 아직 없으면 작업이 수행 되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="d817081530a979658954b262ec5b27debd913f6b" translate="yes" xml:space="preserve">
          <source>Inserts &lt;code&gt;value&lt;/code&gt; in the list stored at &lt;code&gt;key&lt;/code&gt; either before or after the reference value &lt;code&gt;pivot&lt;/code&gt;.</source>
          <target state="translated">참조 값 &lt;code&gt;pivot&lt;/code&gt; 이전 또는 이후 에 &lt;code&gt;key&lt;/code&gt; 저장된 목록에 &lt;code&gt;value&lt;/code&gt; 을 삽입합니다 .</target>
        </trans-unit>
        <trans-unit id="0b2cd21b122572712ccbe21dcfb324c039d60a6f" translate="yes" xml:space="preserve">
          <source>Instead Redis 2.4 works in a different way: clients are served &lt;em&gt;in the context&lt;/em&gt; of the push operation, so as long as &lt;code&gt;LPUSH foo a b c&lt;/code&gt; starts pushing the first element to the list, it will be delivered to the Client &lt;strong&gt;A&lt;/strong&gt;, that will receive &lt;code&gt;a&lt;/code&gt; (the first element pushed).</source>
          <target state="translated">대신 레디 스는 다른 방법으로 2.4 작품 : 클라이언트 서비스가 제공되는 &lt;em&gt;상황에서&lt;/em&gt; 로 너무 오래, 푸쉬 동작의 &lt;code&gt;LPUSH foo a b c&lt;/code&gt; 목록에 첫 번째 요소를 밀어 시작, 그것은 클라이언트에 전달됩니다 , 그 받게됩니다 &lt;code&gt;a&lt;/code&gt; ( 첫 번째 요소가 푸시되었습니다).&lt;strong&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="895d5878b1e7aebe2b652bf4030490cc648a385d" translate="yes" xml:space="preserve">
          <source>Instead of releasing the lock with &lt;a href=&quot;del&quot;&gt;DEL&lt;/a&gt;, send a script that only removes the key if the value matches.</source>
          <target state="translated">&lt;a href=&quot;del&quot;&gt;DEL로&lt;/a&gt; 잠금을 해제하는 대신 값이 일치하는 경우에만 키를 제거하는 스크립트를 보내십시오.</target>
        </trans-unit>
        <trans-unit id="e1fb6600644f1089e2f02671b1d169470ef167d3" translate="yes" xml:space="preserve">
          <source>Instead of setting a fixed string, set a non-guessable large random string, called token.</source>
          <target state="translated">고정 문자열을 설정하는 대신 토큰이라고하는 추측 할 수없는 큰 임의 문자열을 설정하십시오.</target>
        </trans-unit>
        <trans-unit id="7e8138295a5156481cc0eb58921ff5f1b45d907b" translate="yes" xml:space="preserve">
          <source>Instead, if the lock is expired because the Unix time at &lt;code&gt;lock.foo&lt;/code&gt; is older than the current Unix time, C4 tries to perform:</source>
          <target state="translated">대신 &lt;code&gt;lock.foo&lt;/code&gt; 의 Unix 시간 이 현재 Unix 시간보다 오래 되어 잠금이 만료 되면 C4는 다음을 수행하려고 시도합니다.</target>
        </trans-unit>
        <trans-unit id="9e41d77e11789212e3a04485592bea0019722472" translate="yes" xml:space="preserve">
          <source>Instruct Redis to start an &lt;a href=&quot;https://redis.io/topics/persistence#append-only-file&quot;&gt;Append Only File&lt;/a&gt; rewrite process. The rewrite will create a small optimized version of the current Append Only File.</source>
          <target state="translated">Redis에 &lt;a href=&quot;https://redis.io/topics/persistence#append-only-file&quot;&gt;Append Only File&lt;/a&gt; 다시 쓰기 프로세스 를 시작하도록 지시하십시오 . 다시 쓰면 현재 추가 전용 파일의 작은 최적화 버전이 만들어집니다.</target>
        </trans-unit>
        <trans-unit id="5d3a484e0575c563f1fd55a805b93fd40c42e60d" translate="yes" xml:space="preserve">
          <source>Integer reply</source>
          <target state="translated">정수 회신</target>
        </trans-unit>
        <trans-unit id="b78aed63c34c1be3f06c6bc59978ffe5ffe055ac" translate="yes" xml:space="preserve">
          <source>Introduction to EVAL</source>
          <target state="translated">EVAL 소개</target>
        </trans-unit>
        <trans-unit id="698c191721344bee0279a531fba2023586cfe9e4" translate="yes" xml:space="preserve">
          <source>It can also take the following values:</source>
          <target state="translated">다음 값을 사용할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="35178e7f69534d7802151005b608f5f33b33d650" translate="yes" xml:space="preserve">
          <source>It contains a 64-bit checksum that is used to make sure errors will be detected. The &lt;a href=&quot;restore&quot;&gt;RESTORE&lt;/a&gt; command makes sure to check the checksum before synthesizing a key using the serialized value.</source>
          <target state="translated">여기에는 오류가 감지되는지 확인하는 데 사용되는 64 비트 체크섬이 포함되어 있습니다. &lt;a href=&quot;restore&quot;&gt;RESTORE&lt;/a&gt; 명령은 직렬화 된 값을 사용하여 키를 합성하기 전에 체크섬을 확인해야합니다.</target>
        </trans-unit>
        <trans-unit id="d3cca1eb042dc5b5456d254387aa0bc9411f0e98" translate="yes" xml:space="preserve">
          <source>It is &lt;strong&gt;very important&lt;/strong&gt; to understand that you should use the &lt;code&gt;$&lt;/code&gt; ID only for the first call to &lt;a href=&quot;xread&quot;&gt;XREAD&lt;/a&gt;. Later the ID should be the one of the last reported item in the stream, otherwise you could miss all the entries that are added in between.</source>
          <target state="translated">&lt;a href=&quot;xread&quot;&gt;XREAD를&lt;/a&gt; 처음 호출 할 때만 &lt;code&gt;$&lt;/code&gt; ID 를 사용해야한다는 것을 이해하는 것이 &lt;strong&gt;매우 중요&lt;/strong&gt; 합니다 . 나중에 ID는 스트림에서 마지막으로보고 된 항목 중 하나 여야합니다. 그렇지 않으면 사이에 추가 된 모든 항목을 놓칠 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="80e58a0abe147b5052a4b292609ed6e990761a9f" translate="yes" xml:space="preserve">
          <source>It is also possible to &lt;code&gt;GET&lt;/code&gt; the element itself using the special pattern &lt;code&gt;#&lt;/code&gt;:</source>
          <target state="translated">특수 패턴 &lt;code&gt;#&lt;/code&gt; 을 사용하여 요소 자체 를 &lt;code&gt;GET&lt;/code&gt; 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="344f6904cadbf67817bc580b98a14096a5ecb81b" translate="yes" xml:space="preserve">
          <source>It is important to note that step 3 is the only time when a Redis Cluster node will create a new config epoch without agreement from other nodes. This only happens when a manual configuration is operated. However it is impossible that this creates a non-transient setup where two nodes have the same config epoch, since Redis Cluster uses a config epoch collision resolution algorithm.</source>
          <target state="translated">3 단계는 Redis 클러스터 노드가 다른 노드와의 합의없이 새 설정 시대를 생성 할 유일한 시간이라는 점에 유의해야합니다. 수동 구성이 작동하는 경우에만 발생합니다. 그러나 Redis Cluster는 구성 에포크 충돌 해결 알고리즘을 사용하므로 두 노드가 동일한 구성 에포크를 갖는 비 일시적 설정을 만드는 것은 불가능합니다.</target>
        </trans-unit>
        <trans-unit id="75e2007346bb90c5a30dbb62b43b72fa8d6f2346" translate="yes" xml:space="preserve">
          <source>It is important to note that the &lt;strong&gt;MATCH&lt;/strong&gt; filter is applied after elements are retrieved from the collection, just before returning data to the client. This means that if the pattern matches very little elements inside the collection, &lt;a href=&quot;scan&quot;&gt;SCAN&lt;/a&gt; will likely return no elements in most iterations. An example is shown below:</source>
          <target state="translated">것이 중요합니다 &lt;strong&gt;MATCH의&lt;/strong&gt; 요소가 바로 클라이언트에 데이터를 반환하기 전에 컬렉션에서 검색 한 후 필터가 적용됩니다. 즉, 패턴이 컬렉션 내의 매우 적은 요소와 일치하면 &lt;a href=&quot;scan&quot;&gt;SCAN&lt;/a&gt; 은 대부분의 반복에서 요소를 반환하지 않을 것입니다. 예는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="c6bd66f1e8688cc2dae7b39af1276712b3930256" translate="yes" xml:space="preserve">
          <source>It is important to understand that this command is &lt;em&gt;fans out&lt;/em&gt; to all the clients that are waiting for the same range of IDs, so every consumer will get a copy of the data, unlike to what happens when blocking list pop operations are used.</source>
          <target state="translated">이 명령은 동일한 범위의 ID를 기다리는 모든 클라이언트에 대한 &lt;em&gt;팬 아웃&lt;/em&gt; 이므로, 목록 팝 조작을 사용할 때 발생하는 것과 달리 모든 소비자가 데이터 사본을 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="c855a69b0dba328dc98ac3bd3b714e220d6e64d4" translate="yes" xml:space="preserve">
          <source>It is never repeated, so if &lt;a href=&quot;client-id&quot;&gt;CLIENT ID&lt;/a&gt; returns the same number, the caller can be sure that the underlying client did not disconnect and reconnect the connection, but it is still the same connection.</source>
          <target state="translated">반복되지 않으므로 &lt;a href=&quot;client-id&quot;&gt;CLIENT ID&lt;/a&gt; 가 동일한 번호를 리턴하면 호출자는 기본 클라이언트가 연결을 끊었다가 다시 연결하지 않았지만 여전히 동일한 연결인지 확인할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="18c6232a5064b912687168695e794e952ea903ef" translate="yes" xml:space="preserve">
          <source>It is not possible for the key to get lost in the event of a timeout, but the client calling &lt;a href=&quot;migrate&quot;&gt;MIGRATE&lt;/a&gt;, in the event of a timeout error, should check if the key is &lt;em&gt;also&lt;/em&gt; present in the target instance and act accordingly.</source>
          <target state="translated">시간 초과시 키가 유실되지는 않지만 시간 종료 오류시 &lt;a href=&quot;migrate&quot;&gt;MIGRATE를&lt;/a&gt; 호출하는 클라이언트 는 키가 대상 인스턴스 &lt;em&gt;에도&lt;/em&gt; 존재 하는지 확인 하고 그에 따라 조치해야합니다.</target>
        </trans-unit>
        <trans-unit id="7a383107db035b97cc0f3e4c5c6844b9b02c255f" translate="yes" xml:space="preserve">
          <source>It is possible for an infinite number of clients to iterate the same collection at the same time, as the full state of the iterator is in the cursor, that is obtained and returned to the client at every call. Server side no state is taken at all.</source>
          <target state="translated">반복자의 전체 상태가 커서에있을 때마다 무한한 수의 클라이언트가 동일한 콜렉션을 반복 할 수 있으며, 이는 호출 할 때마다 확보되어 클라이언트로 리턴됩니다. 서버 측 상태가 전혀 없습니다.</target>
        </trans-unit>
        <trans-unit id="a485e395caaea14094a0b8ec68e5e3e0a8915e73" translate="yes" xml:space="preserve">
          <source>It is possible to call &lt;a href=&quot;expire&quot;&gt;EXPIRE&lt;/a&gt; using as argument a key that already has an existing expire set. In this case the time to live of a key is &lt;em&gt;updated&lt;/em&gt; to the new value. There are many useful applications for this, an example is documented in the &lt;em&gt;Navigation session&lt;/em&gt; pattern section below.</source>
          <target state="translated">기존 만료 세트가 이미있는 키를 인수로 사용하여 &lt;a href=&quot;expire&quot;&gt;EXPIRE&lt;/a&gt; 를 호출 할 수 있습니다 . 이 경우 키를 사용하는 시간 이 새로운 값으로 &lt;em&gt;업데이트&lt;/em&gt; 됩니다. 이에 대한 유용한 응용 프로그램이 많이 있으며 아래 의 &lt;em&gt;탐색 세션&lt;/em&gt; 패턴 섹션 에 예제가 설명되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="a7f5fb81c26b1abadccf00465e65f7fa65dea140" translate="yes" xml:space="preserve">
          <source>It is possible to call &lt;a href=&quot;select&quot;&gt;SELECT&lt;/a&gt; inside Lua scripts like with normal clients, However one subtle aspect of the behavior changes between Redis 2.8.11 and Redis 2.8.12. Before the 2.8.12 release the database selected by the Lua script was &lt;em&gt;transferred&lt;/em&gt; to the calling script as current database. Starting from Redis 2.8.12 the database selected by the Lua script only affects the execution of the script itself, but does not modify the database selected by the client calling the script.</source>
          <target state="translated">일반적인 클라이언트와 같이 Lua 스크립트 내에서 &lt;a href=&quot;select&quot;&gt;SELECT&lt;/a&gt; 를 호출 할 수 있지만 동작의 미묘한 측면 중 하나는 Redis 2.8.11과 Redis 2.8.12 사이에서 변경됩니다. 2.8.12 릴리스 &lt;em&gt;이전&lt;/em&gt; 에 Lua 스크립트에 의해 선택된 데이터베이스는 현재 데이터베이스로서 호출 스크립트 에 &lt;em&gt;전송&lt;/em&gt; 되었습니다. Redis 2.8.12부터 Lua 스크립트에 의해 선택된 데이터베이스는 스크립트 자체의 실행에만 영향을 미치지 만 스크립트를 호출하는 클라이언트가 선택한 데이터베이스는 수정하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="0958a04d7552830b3684f48a6c436807896935c0" translate="yes" xml:space="preserve">
          <source>It is possible to call Redis commands from a Lua script using two different Lua functions:</source>
          <target state="translated">두 가지 다른 Lua 함수를 사용하여 Lua 스크립트에서 Redis 명령을 호출 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b0a209f43840d7a1f6f04e02663cf8a792cab884" translate="yes" xml:space="preserve">
          <source>It is possible to entirely remove the connection name setting it to the empty string, that is not a valid connection name since it serves to this specific purpose.</source>
          <target state="translated">연결 이름을 빈 문자열로 설정하면 연결 이름을 완전히 제거 할 수 있습니다. 이는이 특정 목적에 부합하므로 유효한 연결 이름이 아닙니다.</target>
        </trans-unit>
        <trans-unit id="db23050fd5ba19a3417f8b624df748886d949634" translate="yes" xml:space="preserve">
          <source>It is possible to get just the length of the slow log using the command &lt;strong&gt;SLOWLOG LEN&lt;/strong&gt;.</source>
          <target state="translated">&lt;strong&gt;SLOWLOG LEN&lt;/strong&gt; 명령을 사용하여 느린 로그의 길이 만 얻을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="db19130f0bd00fca33ef9a77ffc0a1ce2466b31d" translate="yes" xml:space="preserve">
          <source>It is possible to give the command in the following special form in order to make it more efficient:</source>
          <target state="translated">명령을보다 효율적으로 만들기 위해 다음 특수 양식으로 명령을 제공 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e24f1bfbfced0e2fc3e90a67dd138360e0226aa2" translate="yes" xml:space="preserve">
          <source>It is possible to limit the size of the stream to a maximum number of elements using the &lt;strong&gt;MAXLEN&lt;/strong&gt; option.</source>
          <target state="translated">&lt;strong&gt;MAXLEN&lt;/strong&gt; 옵션을 사용하여 스트림 크기를 최대 요소 수로 제한 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ee2ff105ab5c2c719dd08acac18181138935047b" translate="yes" xml:space="preserve">
          <source>It is possible to make this system more robust modifying the unlock schema as follows:</source>
          <target state="translated">다음과 같이 잠금 해제 스키마를 수정하여이 시스템을보다 강력하게 만들 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="493e108b328a9e96e14d97d5ac7db908da18cbb1" translate="yes" xml:space="preserve">
          <source>It is possible to modify the maximum time a script can be executed with millisecond precision, either via &lt;code&gt;redis.conf&lt;/code&gt; or using the CONFIG GET / CONFIG SET command. The configuration parameter affecting max execution time is called &lt;code&gt;lua-time-limit&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;redis.conf&lt;/code&gt; 또는 CONFIG GET / CONFIG SET 명령을 사용하여 밀리 초 단위로 스크립트를 실행할 수있는 최대 시간을 수정할 수 있습니다 . 최대 실행 시간에 영향을주는 구성 매개 변수를 &lt;code&gt;lua-time-limit&lt;/code&gt; 라고 합니다 .</target>
        </trans-unit>
        <trans-unit id="16570d1ed8c0ba499d85c4796bacd5587bfbf468" translate="yes" xml:space="preserve">
          <source>It is possible to only iterate elements matching a given glob-style pattern, similarly to the behavior of the &lt;a href=&quot;keys&quot;&gt;KEYS&lt;/a&gt; command that takes a pattern as only argument.</source>
          <target state="translated">패턴을 인수로만 사용하는 &lt;a href=&quot;keys&quot;&gt;KEYS&lt;/a&gt; 명령 의 동작과 유사하게 주어진 glob 스타일 패턴과 일치하는 요소 만 반복 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="4c90a5608f4fab2983bbd179b23cb40526ff6f3e" translate="yes" xml:space="preserve">
          <source>It is possible to pass the &lt;code&gt;WITHSCORES&lt;/code&gt; option in order to return the scores of the elements together with the elements. The returned list will contain &lt;code&gt;value1,score1,...,valueN,scoreN&lt;/code&gt; instead of &lt;code&gt;value1,...,valueN&lt;/code&gt;. Client libraries are free to return a more appropriate data type (suggestion: an array with (value, score) arrays/tuples).</source>
          <target state="translated">요소의 점수를 요소와 함께 리턴하기 위해 &lt;code&gt;WITHSCORES&lt;/code&gt; 옵션 을 전달할 수 있습니다 . 반환 목록에 포함 &lt;code&gt;value1,score1,...,valueN,scoreN&lt;/code&gt; 대신 &lt;code&gt;value1,...,valueN&lt;/code&gt; . 클라이언트 라이브러리는보다 적절한 데이터 유형 (추천 : (값, 점수) 배열 / 튜플이있는 배열)을 자유롭게 반환 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5fd91c3878c3497da37709cc86d8056d11e4d945" translate="yes" xml:space="preserve">
          <source>It is possible to provide multiple filters at the same time. The command will handle multiple filters via logical AND. For example:</source>
          <target state="translated">여러 개의 필터를 동시에 제공 할 수 있습니다. 이 명령은 논리 AND를 통해 여러 필터를 처리합니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="1c3121b308c1fd1777b057f001ac070f1a4f6932" translate="yes" xml:space="preserve">
          <source>It is possible to push multiple elements using a single command call just specifying multiple arguments at the end of the command. Elements are inserted one after the other to the head of the list, from the leftmost element to the rightmost element. So for instance the command &lt;code&gt;LPUSH mylist a b c&lt;/code&gt; will result into a list containing &lt;code&gt;c&lt;/code&gt; as first element, &lt;code&gt;b&lt;/code&gt; as second element and &lt;code&gt;a&lt;/code&gt; as third element.</source>
          <target state="translated">명령 끝에 여러 인수를 지정하여 단일 명령 호출을 사용하여 여러 요소를 푸시 할 수 있습니다. 요소는 맨 왼쪽 요소에서 가장 오른쪽 요소까지 목록의 머리 부분에 하나씩 삽입됩니다. 예를 들어 &lt;code&gt;LPUSH mylist a b c&lt;/code&gt; 명령 은 &lt;code&gt;c&lt;/code&gt; 를 첫 번째 요소로, &lt;code&gt;b&lt;/code&gt; 를 두 번째 요소로, &lt;code&gt;a&lt;/code&gt; 를 세 번째 요소로 포함하는 목록을 생성 합니다.</target>
        </trans-unit>
        <trans-unit id="f7c76d9bc80fdf12c410c3b35eb8ad68df167802" translate="yes" xml:space="preserve">
          <source>It is possible to push multiple elements using a single command call just specifying multiple arguments at the end of the command. Elements are inserted one after the other to the tail of the list, from the leftmost element to the rightmost element. So for instance the command &lt;code&gt;RPUSH mylist a b c&lt;/code&gt; will result into a list containing &lt;code&gt;a&lt;/code&gt; as first element, &lt;code&gt;b&lt;/code&gt; as second element and &lt;code&gt;c&lt;/code&gt; as third element.</source>
          <target state="translated">명령 끝에 여러 인수를 지정하여 단일 명령 호출을 사용하여 여러 요소를 푸시 할 수 있습니다. 요소는 맨 왼쪽 요소에서 가장 오른쪽 요소까지 목록의 꼬리 부분에 하나씩 삽입됩니다. 예를 들어, &lt;code&gt;RPUSH mylist a b c&lt;/code&gt; 명령 은 &lt;code&gt;a&lt;/code&gt; 를 첫 번째 요소로, &lt;code&gt;b&lt;/code&gt; 를 두 번째 요소로, &lt;code&gt;c&lt;/code&gt; 를 세 번째 요소로 포함 하는 목록을 생성 합니다 .</target>
        </trans-unit>
        <trans-unit id="1b01178931bb71c8630b481c710157203df1e465" translate="yes" xml:space="preserve">
          <source>It is possible to send &lt;a href=&quot;client-pause&quot;&gt;CLIENT PAUSE&lt;/a&gt; in a MULTI/EXEC block together with the &lt;code&gt;INFO replication&lt;/code&gt; command in order to get the current master offset at the time the clients are blocked. This way it is possible to wait for a specific offset in the replica side in order to make sure all the replication stream was processed.</source>
          <target state="translated">클라이언트가 차단 될 때 현재 마스터 오프셋을 얻기 위해 &lt;code&gt;INFO replication&lt;/code&gt; 명령 과 함께 MULTI / EXEC 블록에 &lt;a href=&quot;client-pause&quot;&gt;CLIENT PAUSE&lt;/a&gt; 를 보낼 수 있습니다. 이런 식으로 모든 복제 스트림이 처리되도록 복제본 측에서 특정 오프셋을 기다릴 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0ec5055f100665a2489124e5d7125126bd09824c" translate="yes" xml:space="preserve">
          <source>It is possible to specify an optional modifier to alter the behavior of the command. Specifically:</source>
          <target state="translated">명령 동작을 변경하기 위해 선택적 수정자를 지정할 수 있습니다. 구체적으로 특별히:</target>
        </trans-unit>
        <trans-unit id="45f8f96397f97e0b1f0e90886760fbff08204ef1" translate="yes" xml:space="preserve">
          <source>It is possible to switch persistence from RDB snapshotting to append-only file (and the other way around) using the &lt;a href=&quot;config-set&quot;&gt;CONFIG SET&lt;/a&gt; command. For more information about how to do that please check the &lt;a href=&quot;https://redis.io/topics/persistence&quot;&gt;persistence page&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;config-set&quot;&gt;CONFIG SET&lt;/a&gt; 명령을 사용하여 지속성을 RDB 스냅 샷에서 추가 전용 파일 (및 다른 방법으로)로 전환 할 수 있습니다 . 이를 수행하는 방법에 대한 자세한 내용은 &lt;a href=&quot;https://redis.io/topics/persistence&quot;&gt;지속성 페이지&lt;/a&gt; 를 확인 하십시오 .</target>
        </trans-unit>
        <trans-unit id="7e2a6138f902bc8b4bcfbc90caefbe979c90132a" translate="yes" xml:space="preserve">
          <source>It is possible to terminate a script that executes only read-only commands using the &lt;a href=&quot;script-kill&quot;&gt;SCRIPT KILL&lt;/a&gt; command. This does not violate the scripting semantic as no data was yet written to the dataset by the script.</source>
          <target state="translated">&lt;a href=&quot;script-kill&quot;&gt;SCRIPT KILL&lt;/a&gt; 명령을 사용하여 읽기 전용 명령 만 실행하는 스크립트를 종료 할 수 있습니다 . 아직 스크립트에 의해 데이터 세트에 데이터가 기록되지 않았기 때문에 스크립팅 시맨틱을 위반하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="e71c9ce4c62f0cde3cb804acf308d1e98fe95b09" translate="yes" xml:space="preserve">
          <source>It is possible to use &lt;a href=&quot;incr&quot;&gt;INCR&lt;/a&gt; and &lt;a href=&quot;expire&quot;&gt;EXPIRE&lt;/a&gt; together at every page view to have a counter counting only the latest N page views separated by less than the specified amount of seconds.</source>
          <target state="translated">모든 페이지보기에서 &lt;a href=&quot;incr&quot;&gt;INCR&lt;/a&gt; 과 &lt;a href=&quot;expire&quot;&gt;EXPIRE를&lt;/a&gt; 함께 사용 하면 지정된 N 초 미만으로 분리 된 최신 N 페이지보기 만 계수하는 카운터를 가질 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2dd681e578f9014910b8ac5ae0c3612f0ad14944" translate="yes" xml:space="preserve">
          <source>It is possible to use &lt;code&gt;BY&lt;/code&gt; and &lt;code&gt;GET&lt;/code&gt; options against hash fields with the following syntax:</source>
          <target state="translated">다음 구문으로 해시 필드에 대해 &lt;code&gt;BY&lt;/code&gt; 및 &lt;code&gt;GET&lt;/code&gt; 옵션 을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b7c843f5e285c955a784fb3560240c16b6f9efa9" translate="yes" xml:space="preserve">
          <source>It is possible to use them in &lt;code&gt;geohash.org&lt;/code&gt; URLs such as &lt;code&gt;http://geohash.org/&amp;lt;geohash-string&amp;gt;&lt;/code&gt;. This is an &lt;a href=&quot;http://geohash.org/sqdtr74hyu0&quot;&gt;example of such URL&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;http://geohash.org/&amp;lt;geohash-string&amp;gt;&lt;/code&gt; 과 같은 &lt;code&gt;geohash.org&lt;/code&gt; URL 에서 이들을 사용할 수 있습니다 . 이것은 &lt;a href=&quot;http://geohash.org/sqdtr74hyu0&quot;&gt;그러한 URL&lt;/a&gt; 의 예입니다 .</target>
        </trans-unit>
        <trans-unit id="b30cb831388a0a49ee8acf0fd13e74a7abc3ab8f" translate="yes" xml:space="preserve">
          <source>It is possible to write to the Redis log file from Lua scripts using the &lt;code&gt;redis.log&lt;/code&gt; function.</source>
          <target state="translated">&lt;code&gt;redis.log&lt;/code&gt; 함수를 사용하여 Lua 스크립트에서 Redis 로그 파일에 쓸 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="dee99c37f02de301ed26c2711bf105931901e4b7" translate="yes" xml:space="preserve">
          <source>It is the blocking version because it blocks the connection when there are no members to pop from any of the given sorted sets. A member with the highest score is popped from first sorted set that is non-empty, with the given keys being checked in the order that they are given.</source>
          <target state="translated">지정된 정렬 된 세트에서 팝업 할 멤버가 없을 때 연결을 차단하기 때문에 차단 버전입니다. 점수가 가장 높은 멤버는 비어 있지 않은 첫 번째 정렬 된 세트에서 팝되며 주어진 키는 주어진 순서대로 확인됩니다.</target>
        </trans-unit>
        <trans-unit id="b7063c25aabd8a7e88f52a969b68eec3fd17473b" translate="yes" xml:space="preserve">
          <source>It is the blocking version because it blocks the connection when there are no members to pop from any of the given sorted sets. A member with the lowest score is popped from first sorted set that is non-empty, with the given keys being checked in the order that they are given.</source>
          <target state="translated">지정된 정렬 된 세트에서 팝업 할 멤버가 없을 때 연결을 차단하기 때문에 차단 버전입니다. 점수가 가장 낮은 멤버는 비어 있지 않은 첫 번째 정렬 된 세트에서 팝되며 주어진 키는 주어진 순서대로 확인됩니다.</target>
        </trans-unit>
        <trans-unit id="164013c6ace79ff08b57e9e952d3d8fc12045787" translate="yes" xml:space="preserve">
          <source>It just assumes that the Earth is a sphere, since the used distance formula is the Haversine formula. This formula is only an approximation when applied to the Earth, which is not a perfect sphere. The introduced errors are not an issue when used in the context of social network sites that need to query by radius and most other applications. However in the worst case the error may be up to 0.5%, so you may want to consider other systems for error-critical applications.</source>
          <target state="translated">사용 된 거리 공식이 Haversine 공식이기 때문에 지구가 구체라고 가정합니다. 이 공식은 지구에 적용될 때의 근사치 일 뿐이며 완벽한 구는 아닙니다. 반경 및 대부분의 다른 응용 프로그램으로 쿼리해야하는 소셜 네트워크 사이트의 컨텍스트에서 사용될 때 도입 된 오류는 문제가되지 않습니다. 그러나 최악의 경우 오류가 최대 0.5 %가 될 수 있으므로 오류가 중요한 응용 프로그램에 다른 시스템을 고려할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="886b0ba44681d142ee0340c1b1c340fb49ca65a9" translate="yes" xml:space="preserve">
          <source>It starts accepting commands again from other clients, but will reply with a BUSY error to all the clients sending normal commands. The only allowed commands in this status are &lt;a href=&quot;script-kill&quot;&gt;SCRIPT KILL&lt;/a&gt; and &lt;code&gt;SHUTDOWN
NOSAVE&lt;/code&gt;.</source>
          <target state="translated">다른 클라이언트에서 명령을 다시 수락하기 시작하지만 일반 명령을 보내는 모든 클라이언트에 BUSY 오류로 응답합니다. 이 상태에서 유일하게 허용되는 명령은 &lt;a href=&quot;script-kill&quot;&gt;SCRIPT KILL&lt;/a&gt; 및 &lt;code&gt;SHUTDOWN NOSAVE&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="c9c449f7e951338dc4ce45209e7239b6180f2387" translate="yes" xml:space="preserve">
          <source>It stops processing all the pending commands from normal and pub/sub clients. However interactions with replicas will continue normally.</source>
          <target state="translated">일반 및 pub / sub 클라이언트에서 보류중인 모든 명령 처리를 중지합니다. 그러나 복제본과의 상호 작용은 정상적으로 계속됩니다.</target>
        </trans-unit>
        <trans-unit id="de49d1f951abef9774a1080b68edfd084cab6b36" translate="yes" xml:space="preserve">
          <source>It supports several other functions: &lt;code&gt;bit.tobit&lt;/code&gt;, &lt;code&gt;bit.tohex&lt;/code&gt;, &lt;code&gt;bit.bnot&lt;/code&gt;, &lt;code&gt;bit.band&lt;/code&gt;, &lt;code&gt;bit.bor&lt;/code&gt;, &lt;code&gt;bit.bxor&lt;/code&gt;, &lt;code&gt;bit.lshift&lt;/code&gt;, &lt;code&gt;bit.rshift&lt;/code&gt;, &lt;code&gt;bit.arshift&lt;/code&gt;, &lt;code&gt;bit.rol&lt;/code&gt;, &lt;code&gt;bit.ror&lt;/code&gt;, &lt;code&gt;bit.bswap&lt;/code&gt;. All available functions are documented in the &lt;a href=&quot;http://bitop.luajit.org/api.html&quot;&gt;Lua BitOp documentation&lt;/a&gt;</source>
          <target state="translated">&lt;code&gt;bit.tobit&lt;/code&gt; , &lt;code&gt;bit.tohex&lt;/code&gt; , &lt;code&gt;bit.bnot&lt;/code&gt; , &lt;code&gt;bit.band&lt;/code&gt; , &lt;code&gt;bit.bor&lt;/code&gt; , &lt;code&gt;bit.bxor&lt;/code&gt; , &lt;code&gt;bit.lshift&lt;/code&gt; , &lt;code&gt;bit.rshift&lt;/code&gt; , &lt;code&gt;bit.arshift&lt;/code&gt; , &lt;code&gt;bit.rol&lt;/code&gt; , &lt;code&gt;bit.ror&lt;/code&gt; , 기타 기능을 지원합니다. &lt;code&gt;bit.bswap&lt;/code&gt; . 사용 가능한 모든 기능은 &lt;a href=&quot;http://bitop.luajit.org/api.html&quot;&gt;Lua BitOp 설명서에 나와 있습니다.&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="aa6a033ac7293343a89e1b83064df26de033f26b" translate="yes" xml:space="preserve">
          <source>Iteratating a stream incrementally, returning just a few items at every iteration. However it is semantically much more robust than the &lt;a href=&quot;scan&quot;&gt;SCAN&lt;/a&gt; family of functions.</source>
          <target state="translated">스트림을 증분 반복하여 반복 할 때마다 몇 개의 항목 만 반환합니다. 그러나 이는 &lt;a href=&quot;scan&quot;&gt;SCAN&lt;/a&gt; 기능 군 보다 의미 상 훨씬 강력 합니다.</target>
        </trans-unit>
        <trans-unit id="3fa52c04afc758e80cafb88b8a1109903b053dfb" translate="yes" xml:space="preserve">
          <source>Iterating a stream</source>
          <target state="translated">스트림 반복</target>
        </trans-unit>
        <trans-unit id="6cb66fccc1c9fe8583ef2426d5ce548dc6f7ff69" translate="yes" xml:space="preserve">
          <source>Iterating with XREVRANGE</source>
          <target state="translated">XREVRANGE를 사용하여 반복</target>
        </trans-unit>
        <trans-unit id="4794d4e58656f4a052385045d3fd4b0331ebddea" translate="yes" xml:space="preserve">
          <source>Iteration of a Hash value.</source>
          <target state="translated">해시 값의 반복.</target>
        </trans-unit>
        <trans-unit id="ac97fd8044e211b8965191abd3e1372d4a6075d6" translate="yes" xml:space="preserve">
          <source>KEYS</source>
          <target state="translated">KEYS</target>
        </trans-unit>
        <trans-unit id="d4d3343d1b4f35172b9d4fabff52e12ab9514f83" translate="yes" xml:space="preserve">
          <source>KEYS  pattern   Find all keys matching the given pattern</source>
          <target state="translated">키 패턴 주어진 패턴과 일치하는 모든 키를 찾습니다</target>
        </trans-unit>
        <trans-unit id="8001eeb819fd035ff21dae0c64b60f000bfc9daa" translate="yes" xml:space="preserve">
          <source>Key step count allows us to find key positions in commands like &lt;a href=&quot;mset&quot;&gt;MSET&lt;/a&gt; where the format is &lt;code&gt;MSET _key1_ _val1_ [key2] [val2] [key3] [val3]...&lt;/code&gt;.</source>
          <target state="translated">키 단계 수를 통해 &lt;a href=&quot;mset&quot;&gt;MSET&lt;/a&gt; 과 같은 명령 에서 형식이 &lt;code&gt;MSET _key1_ _val1_ [key2] [val2] [key3] [val3]...&lt;/code&gt; 키 위치를 찾을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="e5651c683f14c95aa972cfdbc300d9fecfe02019" translate="yes" xml:space="preserve">
          <source>Keys</source>
          <target state="translated">Keys</target>
        </trans-unit>
        <trans-unit id="5e0969e73b8800b103eeedd8f6bcdbbbf0f4fa78" translate="yes" xml:space="preserve">
          <source>Keys are checked in the order that they are given. Let's say that the key &lt;code&gt;list1&lt;/code&gt; doesn't exist and &lt;code&gt;list2&lt;/code&gt; and &lt;code&gt;list3&lt;/code&gt; hold non-empty lists. Consider the following command:</source>
          <target state="translated">키는 주어진 순서대로 확인됩니다. 키 &lt;code&gt;list1&lt;/code&gt; 이 존재하지 않고 &lt;code&gt;list2&lt;/code&gt; 및 &lt;code&gt;list3&lt;/code&gt; 이 비어 있지 않은 목록을 보유 한다고 가정 해 봅시다 . 다음 명령을 고려하십시오.</target>
        </trans-unit>
        <trans-unit id="393be168e99116be87234133e2763b06336c48c1" translate="yes" xml:space="preserve">
          <source>Keys expiring information is stored as absolute Unix timestamps (in milliseconds in case of Redis version 2.6 or greater). This means that the time is flowing even when the Redis instance is not active.</source>
          <target state="translated">정보가 만료되는 키는 절대 Unix 타임 스탬프 (Redis 버전 2.6 이상의 경우 밀리 초)로 저장됩니다. 이는 Redis 인스턴스가 활성화되지 않은 경우에도 시간이 흐르고 있음을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="d3023dfa16df6ad208cc7d5460854b58da1edb26" translate="yes" xml:space="preserve">
          <source>Keys that do not exist are considered to be empty sets.</source>
          <target state="translated">존재하지 않는 키는 빈 세트로 간주됩니다.</target>
        </trans-unit>
        <trans-unit id="d71481abd644158f5a9fbc5c9cecdf74dc0540c6" translate="yes" xml:space="preserve">
          <source>Keys that do not exist are considered to be empty sets. With one of the keys being an empty set, the resulting set is also empty (since set intersection with an empty set always results in an empty set).</source>
          <target state="translated">존재하지 않는 키는 빈 세트로 간주됩니다. 키 중 하나가 빈 세트 인 경우 결과 세트도 비어 있습니다 (빈 세트와의 집합 교차는 항상 빈 세트가되므로).</target>
        </trans-unit>
        <trans-unit id="a78a3a71051e865654da3b71a5c55513e9449b8a" translate="yes" xml:space="preserve">
          <source>Keys with an expire</source>
          <target state="translated">만료 된 키</target>
        </trans-unit>
        <trans-unit id="7bcef127a442604057181ff7e89e6774cfcbdec1" translate="yes" xml:space="preserve">
          <source>Keyspace hits</source>
          <target state="translated">키 스페이스 적중</target>
        </trans-unit>
        <trans-unit id="0ecc36a9eabb580bee92d3334fc963c0e285c8f2" translate="yes" xml:space="preserve">
          <source>Keyspace misses</source>
          <target state="translated">키 스페이스 누락</target>
        </trans-unit>
        <trans-unit id="18937f1c4a4cfb92babe800429a63d572cde1150" translate="yes" xml:space="preserve">
          <source>Kills the currently executing Lua script, assuming no write operation was yet performed by the script.</source>
          <target state="translated">스크립트에서 아직 쓰기 작업이 수행되지 않았다고 가정하고 현재 실행중인 Lua 스크립트를 종료합니다.</target>
        </trans-unit>
        <trans-unit id="a452e11c491a60de5436b1999a469cdaa66c0c00" translate="yes" xml:space="preserve">
          <source>LASTSAVE</source>
          <target state="translated">LASTSAVE</target>
        </trans-unit>
        <trans-unit id="fb2ee42881d40ddc3d3aec1d41500b08e5d25e19" translate="yes" xml:space="preserve">
          <source>LASTSAVE   Get the UNIX time stamp of the last successful save to disk</source>
          <target state="translated">LASTSAVE 마지막으로 디스크에 성공적으로 저장 한 UNIX 타임 스탬프를 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="b9ffd63c8ba805a842d4d3d2465da47916360545" translate="yes" xml:space="preserve">
          <source>LDB can be enabled in one of two modes: asynchronous or synchronous. In asynchronous mode the server creates a forked debugging session that does not block and all changes to the data are &lt;strong&gt;rolled back&lt;/strong&gt; after the session finishes, so debugging can be restarted using the same initial state. The alternative synchronous debug mode blocks the server while the debugging session is active and retains all changes to the data set once it ends.</source>
          <target state="translated">LDB는 비동기 또는 동기 모드 중 하나에서 활성화 할 수 있습니다. 비동기 모드에서 서버는 차단되지 않는 분기 된 디버깅 세션을 작성 하고 세션이 완료된 후 데이터의 모든 변경 사항이 &lt;strong&gt;롤백&lt;/strong&gt; 되므로 동일한 초기 상태를 사용하여 디버깅을 다시 시작할 수 있습니다. 대체 동기 디버그 모드는 디버깅 세션이 활성 상태 인 동안 서버를 차단하고 데이터 세트가 종료되면 모든 변경 사항을 유지합니다.</target>
        </trans-unit>
        <trans-unit id="14d2c13614325f3af7fa95efeb5dd818bb2ab0d1" translate="yes" xml:space="preserve">
          <source>LINDEX</source>
          <target state="translated">LINDEX</target>
        </trans-unit>
        <trans-unit id="a2dedc00417f0b7b29562ddaa4e03af088097cdb" translate="yes" xml:space="preserve">
          <source>LINDEX  key index   Get an element from a list by its index</source>
          <target state="translated">LINDEX 키 인덱스 인덱스로 목록에서 요소를 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="40088c47225008784271c2935753b4ae98fd6ec7" translate="yes" xml:space="preserve">
          <source>LINSERT</source>
          <target state="translated">LINSERT</target>
        </trans-unit>
        <trans-unit id="ca09700aae0c450ed6c327c789e3e1e3fef9f931" translate="yes" xml:space="preserve">
          <source>LINSERT  key BEFORE|AFTER pivot value   Insert an element before or after another element in a list</source>
          <target state="translated">LINSERT 키 BEFORE | AFTER 피벗 값 목록에서 다른 요소 앞이나 뒤에 요소 삽입</target>
        </trans-unit>
        <trans-unit id="19ce1639e2d6248a60334eca45396c2f1f706007" translate="yes" xml:space="preserve">
          <source>LLEN</source>
          <target state="translated">LLEN</target>
        </trans-unit>
        <trans-unit id="defc92ee8b39130b63cdf033e9edada00210e4f3" translate="yes" xml:space="preserve">
          <source>LLEN  key   Get the length of a list</source>
          <target state="translated">LLEN 키 목록의 길이를 가져옵니다</target>
        </trans-unit>
        <trans-unit id="6f58be63c72a45daadb6f09041398ad98c6ac9a7" translate="yes" xml:space="preserve">
          <source>LPOP</source>
          <target state="translated">LPOP</target>
        </trans-unit>
        <trans-unit id="c0a0f50764c15280585040d66db05c7ea7d4701a" translate="yes" xml:space="preserve">
          <source>LPOP  key   Remove and get the first element in a list</source>
          <target state="translated">LPOP 키 목록에서 첫 번째 요소를 제거하고 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="4f49fc76e42ddd892d0dbf761cab7456fba6707a" translate="yes" xml:space="preserve">
          <source>LPUSH</source>
          <target state="translated">LPUSH</target>
        </trans-unit>
        <trans-unit id="a3260ebe55f682088cc638c2329d0a5d2a5f9c43" translate="yes" xml:space="preserve">
          <source>LPUSH  key value [value ...]   Prepend one or multiple values to a list</source>
          <target state="translated">LPUSH 키 값 [값 ...] 하나 이상의 값을 목록에 추가</target>
        </trans-unit>
        <trans-unit id="73023347f78efa6f33e2849831f260102f26f9dc" translate="yes" xml:space="preserve">
          <source>LPUSHX</source>
          <target state="translated">LPUSHX</target>
        </trans-unit>
        <trans-unit id="11960d83f4ba3a64c1274bec7eeaf405b1c4abbe" translate="yes" xml:space="preserve">
          <source>LPUSHX  key value   Prepend a value to a list, only if the list exists</source>
          <target state="translated">LPUSHX 키 값 목록이 존재하는 경우에만 목록에 값을 추가하십시오.</target>
        </trans-unit>
        <trans-unit id="3b47c23e3107b92100b9303bb9ab3d1a9ccc56bd" translate="yes" xml:space="preserve">
          <source>LRANGE</source>
          <target state="translated">LRANGE</target>
        </trans-unit>
        <trans-unit id="326594fa342712e825205a5b864121b10bd2f5cf" translate="yes" xml:space="preserve">
          <source>LRANGE  key start stop   Get a range of elements from a list</source>
          <target state="translated">LRANGE 키 시작 중지 목록에서 다양한 요소 가져 오기</target>
        </trans-unit>
        <trans-unit id="abfc25d80dc9a80384bd4c9697b510b323ecc45b" translate="yes" xml:space="preserve">
          <source>LREM</source>
          <target state="translated">LREM</target>
        </trans-unit>
        <trans-unit id="f0b649e2191175bc6abf8bc7b2d0b6ec6fbf904d" translate="yes" xml:space="preserve">
          <source>LREM  key count value   Remove elements from a list</source>
          <target state="translated">LREM 키 수 값 목록에서 요소 제거</target>
        </trans-unit>
        <trans-unit id="70e8f03d6f4f36a9430ac8c4d4a1515597b0b252" translate="yes" xml:space="preserve">
          <source>LSET</source>
          <target state="translated">LSET</target>
        </trans-unit>
        <trans-unit id="4f03203283df161a2d6f2abf4d29626d32823249" translate="yes" xml:space="preserve">
          <source>LSET  key index value   Set the value of an element in a list by its index</source>
          <target state="translated">LSET 키 인덱스 값 인덱스로 목록의 요소 값을 설정합니다.</target>
        </trans-unit>
        <trans-unit id="13cbd920c001e22788dd4d82cdc291c6caac4662" translate="yes" xml:space="preserve">
          <source>LTRIM</source>
          <target state="translated">LTRIM</target>
        </trans-unit>
        <trans-unit id="6c5b375830efe50dd05881b52f80e2aa747afced" translate="yes" xml:space="preserve">
          <source>LTRIM  key start stop   Trim a list to the specified range</source>
          <target state="translated">LTRIM 키 시작 중지 목록을 지정된 범위로 자릅니다.</target>
        </trans-unit>
        <trans-unit id="de6a27da313b316346ea7dcf9f866c5fcdaff765" translate="yes" xml:space="preserve">
          <source>Last Key in Argument List</source>
          <target state="translated">인수 목록의 마지막 키</target>
        </trans-unit>
        <trans-unit id="d4e1040fdde9172717ea80a7cdcb3b316461fb75" translate="yes" xml:space="preserve">
          <source>Later it will be trivial to know the number of single days the user visited the web site simply calling the &lt;a href=&quot;bitcount&quot;&gt;BITCOUNT&lt;/a&gt; command against the bitmap.</source>
          <target state="translated">나중에 비트 맵에 대해 &lt;a href=&quot;bitcount&quot;&gt;BITCOUNT&lt;/a&gt; 명령을 호출하는 사용자가 웹 사이트를 방문한 하루 수를 아는 것은 쉽지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="6167261c71ec337f0f15b900208ad184a4f7b0c9" translate="yes" xml:space="preserve">
          <source>Latest fork(2) time</source>
          <target state="translated">최신 포크 (2) 시간</target>
        </trans-unit>
        <trans-unit id="0122f9d36a5bc7edfbaa17dc0a7b017882cfb3ae" translate="yes" xml:space="preserve">
          <source>Let's assume we have four nodes, A, B, C and D. In order to end with just a three nodes cluster A, B, C we may follow these steps:</source>
          <target state="translated">4 개의 노드 A, B, C 및 D가 있다고 가정 해 봅시다. 3 개의 노드 클러스터 A, B, C로 끝나기 위해 다음 단계를 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2f5c5e27076a7756eeef955cec8a1510af3fb9c4" translate="yes" xml:space="preserve">
          <source>Licensed under the Creative Commons Attribution-ShareAlike License 4.0.</source>
          <target state="translated">Creative Commons Attribution-ShareAlike License 4.0에 따라 라이센스가 부여됩니다.</target>
        </trans-unit>
        <trans-unit id="98cf5d780c53575d17f1d32cf3823650dcaa6c52" translate="yes" xml:space="preserve">
          <source>Like &lt;a href=&quot;ttl&quot;&gt;TTL&lt;/a&gt; this command returns the remaining time to live of a key that has an expire set, with the sole difference that &lt;a href=&quot;ttl&quot;&gt;TTL&lt;/a&gt; returns the amount of remaining time in seconds while &lt;a href=&quot;pttl&quot;&gt;PTTL&lt;/a&gt; returns it in milliseconds.</source>
          <target state="translated">&lt;a href=&quot;ttl&quot;&gt;TTL&lt;/a&gt; 과 마찬가지로이 명령은 만료 세트가있는 키의 남은 시간을 반환합니다. 단, &lt;a href=&quot;ttl&quot;&gt;TTL&lt;/a&gt; 은 남은 시간을 초 단위로 반환하고 &lt;a href=&quot;pttl&quot;&gt;PTTL&lt;/a&gt; 은 밀리 초를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="199ff2ec8051414c46a22a354ba2c4bf9f64de93" translate="yes" xml:space="preserve">
          <source>Like &lt;a href=&quot;xrange&quot;&gt;XRANGE&lt;/a&gt; this command can be used in order to iterate the whole stream content, however note that in this case, the next command calls should use the ID of the last entry, with the sequence number decremneted by one. However if the sequence number is already 0, the time part of the ID should be decremented by 1, and the sequence part should be set to the maxium possible sequence number, that is, 18446744073709551615, or could be omitted at all, and the command will automatically assume it to be such a number (see &lt;a href=&quot;xrange&quot;&gt;XRANGE&lt;/a&gt; for more info about incomplete IDs).</source>
          <target state="translated">&lt;a href=&quot;xrange&quot;&gt;XRANGE&lt;/a&gt; 와 마찬가지로이 명령을 사용하여 전체 스트림 내용을 반복 할 수 있지만이 경우 다음 명령 호출은 마지막 항목의 ID를 사용하고 순서 번호는 1 씩 감소해야합니다. 그러나 시퀀스 번호가 이미 0 인 경우 ID의 시간 부분은 1 씩 감소해야하며 시퀀스 부분은 가능한 최대 시퀀스 번호, 즉 18446744073709551615로 설정되거나 전혀 생략 될 수 있습니다. 자동으로 숫자로 간주합니다 ( 불완전한 ID에 대한 자세한 내용은 &lt;a href=&quot;xrange&quot;&gt;XRANGE&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="7a5a0a2011829340fa32a8f044e479cef542a701" translate="yes" xml:space="preserve">
          <source>Like &lt;a href=&quot;xread&quot;&gt;XREAD&lt;/a&gt; the &lt;a href=&quot;xreadgroup&quot;&gt;XREADGROUP&lt;/a&gt; command can be used in a blocking way. There are no differences in this regard.</source>
          <target state="translated">마찬가지로 &lt;a href=&quot;xread&quot;&gt;XREAD &lt;/a&gt;&lt;a href=&quot;xreadgroup&quot;&gt;XREADGROUP의&lt;/a&gt; 명령은 차단 방법으로 사용할 수 있습니다. 이와 관련하여 차이점은 없습니다.</target>
        </trans-unit>
        <trans-unit id="964c6e379f4b517ab54346bbc59cea679f55f58d" translate="yes" xml:space="preserve">
          <source>Like for the &lt;a href=&quot;getrange&quot;&gt;GETRANGE&lt;/a&gt; command start and end can contain negative values in order to index bytes starting from the end of the string, where -1 is the last byte, -2 is the penultimate, and so forth.</source>
          <target state="translated">&lt;a href=&quot;getrange&quot;&gt;GETRANGE&lt;/a&gt; 명령 과 마찬가지로 start 및 end에는 문자열의 끝에서 시작하여 바이트를 인덱싱하기 위해 음수 값이 포함될 수 있습니다. 여기서 -1은 마지막 바이트이고 -2는 두 번째입니다.</target>
        </trans-unit>
        <trans-unit id="ce45b8148c6f69841bc195d50623329ea61f3da8" translate="yes" xml:space="preserve">
          <source>Lines can contain a section name (starting with a # character) or a property. All the properties are in the form of &lt;code&gt;field:value&lt;/code&gt; terminated by &lt;code&gt;\r\n&lt;/code&gt;.</source>
          <target state="translated">행은 섹션 이름 (# 문자로 시작) 또는 속성을 포함 할 수 있습니다. 모든 속성은 &lt;code&gt;\r\n&lt;/code&gt; 끝나는 &lt;code&gt;field:value&lt;/code&gt; 형식으로 되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="57c9502a7d7d48fd4a86b45fefb2b163491c3ae1" translate="yes" xml:space="preserve">
          <source>Lists</source>
          <target state="translated">Lists</target>
        </trans-unit>
        <trans-unit id="899acbf6050de7813479a962bcb80b73089f0f38" translate="yes" xml:space="preserve">
          <source>Lists can be encoded as &lt;code&gt;ziplist&lt;/code&gt; or &lt;code&gt;linkedlist&lt;/code&gt;. The &lt;code&gt;ziplist&lt;/code&gt; is the special representation that is used to save space for small lists.</source>
          <target state="translated">리스트는 &lt;code&gt;ziplist&lt;/code&gt; 또는 &lt;code&gt;linkedlist&lt;/code&gt; 로 인코딩 될 수 있습니다 . &lt;code&gt;ziplist&lt;/code&gt; 은 작은 목록에 대한 공간을 절약하기 위해 사용되는 특별한 표현이다.</target>
        </trans-unit>
        <trans-unit id="db5be7f471516f84344dd104ba9b8aa174ce8d02" translate="yes" xml:space="preserve">
          <source>Lists the currently &lt;em&gt;active channels&lt;/em&gt;. An active channel is a Pub/Sub channel with one or more subscribers (not including clients subscribed to patterns).</source>
          <target state="translated">현재 &lt;em&gt;활성화 된 채널을&lt;/em&gt; 나열합니다 . 활성 채널은 하나 이상의 가입자 (패턴에 가입 한 클라이언트는 포함하지 않음)가있는 Pub / Sub 채널입니다.</target>
        </trans-unit>
        <trans-unit id="dcea1d44bcfef24039b8c1d6348290fc06d43c9a" translate="yes" xml:space="preserve">
          <source>Load a script into the scripts cache, without executing it. After the specified command is loaded into the script cache it will be callable using &lt;a href=&quot;evalsha&quot;&gt;EVALSHA&lt;/a&gt; with the correct SHA1 digest of the script, exactly like after the first successful invocation of &lt;a href=&quot;eval&quot;&gt;EVAL&lt;/a&gt;.</source>
          <target state="translated">스크립트를 실행하지 않고 스크립트를 스크립트 캐시에로드하십시오. 지정된 명령이 스크립트 캐시에로드 된 후 &lt;a href=&quot;eval&quot;&gt;EVAL을&lt;/a&gt; 처음 성공적으로 호출 한 후와 마찬가지로 스크립트의 올바른 SHA1 다이제스트와 함께 &lt;a href=&quot;evalsha&quot;&gt;EVALSHA&lt;/a&gt; 를 사용하여 호출 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="bcd47c9d2232eb759e90bf52905602d787217e6e" translate="yes" xml:space="preserve">
          <source>Lua boolean false -&amp;gt; Redis Nil bulk reply.</source>
          <target state="translated">루아 부울 거짓-&amp;gt; Redis Nil 대량 회신.</target>
        </trans-unit>
        <trans-unit id="197815ca05866b7c30c1048b9d86321ee4ce6238" translate="yes" xml:space="preserve">
          <source>Lua boolean true -&amp;gt; Redis integer reply with value of 1.</source>
          <target state="translated">루아 부울 true-&amp;gt; Redis 정수 응답은 1 값입니다.</target>
        </trans-unit>
        <trans-unit id="02dda41ef75370280dc992551fadb03b88d21b1f" translate="yes" xml:space="preserve">
          <source>Lua does not export commands to access the system time or other external state.</source>
          <target state="translated">Lua는 시스템 시간 또는 기타 외부 상태에 액세스하기위한 명령을 내 보내지 않습니다.</target>
        </trans-unit>
        <trans-unit id="738b234f859993680828647d652f6de5655b0815" translate="yes" xml:space="preserve">
          <source>Lua has a single numerical type, Lua numbers. There is no distinction between integers and floats. So we always convert Lua numbers into integer replies, removing the decimal part of the number if any. &lt;strong&gt;If you want to return a float from Lua you should return it as a string&lt;/strong&gt;, exactly like Redis itself does (see for instance the &lt;a href=&quot;zscore&quot;&gt;ZSCORE&lt;/a&gt; command).</source>
          <target state="translated">루아는 단일 숫자 유형 인 루아 숫자를가집니다. 정수와 부동 수에는 차이가 없습니다. 따라서 항상 루아 숫자를 정수 응답으로 변환하여 숫자의 소수 부분을 제거합니다. &lt;strong&gt;Lua에서 부동 소수점을 반환하려면&lt;/strong&gt; Redis 자체와 동일하게 &lt;strong&gt;문자열로 반환해야합니다&lt;/strong&gt; (예 : &lt;a href=&quot;zscore&quot;&gt;ZSCORE&lt;/a&gt; 명령 참조).</target>
        </trans-unit>
        <trans-unit id="7c212b1d165a2bdadf01bf8c01c306a9c3e780aa" translate="yes" xml:space="preserve">
          <source>Lua number -&amp;gt; Redis integer reply (the number is converted into an integer)</source>
          <target state="translated">루아 번호-&amp;gt; Redis 정수 응답 (숫자가 정수로 변환 됨)</target>
        </trans-unit>
        <trans-unit id="0fcb79bd3680efc38fab49be15ad5a556da29a6c" translate="yes" xml:space="preserve">
          <source>Lua pseudo random number generation functions &lt;code&gt;math.random&lt;/code&gt; and &lt;code&gt;math.randomseed&lt;/code&gt; are modified in order to always have the same seed every time a new script is executed. This means that calling &lt;code&gt;math.random&lt;/code&gt; will always generate the same sequence of numbers every time a script is executed if &lt;code&gt;math.randomseed&lt;/code&gt; is not used.</source>
          <target state="translated">루아 의사 난수 생성 함수 &lt;code&gt;math.random&lt;/code&gt; 및 &lt;code&gt;math.randomseed&lt;/code&gt; 는 새 스크립트가 실행될 때마다 항상 동일한 시드를 갖도록 수정됩니다. 호출하는 것으로이 수단 &lt;code&gt;math.random&lt;/code&gt; 항상 숫자의 동일한 시퀀스를 경우 스크립트가 실행될 때마다 생성합니다 &lt;code&gt;math.randomseed&lt;/code&gt; 가 사용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="e026038d7a23da497563d39bf562be4e8b076af8" translate="yes" xml:space="preserve">
          <source>Lua scripts can return a value that is converted from the Lua type to the Redis protocol using a set of conversion rules.</source>
          <target state="translated">Lua 스크립트는 일련의 변환 규칙을 사용하여 Lua 유형에서 Redis 프로토콜로 변환 된 값을 반환 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="eec8779958c6af77259f2bed4f2206965d44330b" translate="yes" xml:space="preserve">
          <source>Lua string -&amp;gt; Redis bulk reply</source>
          <target state="translated">루아 문자열-&amp;gt; Redis 대량 회신</target>
        </trans-unit>
        <trans-unit id="0b78d29489185b7463559dbd5991d9b98e6ea241" translate="yes" xml:space="preserve">
          <source>Lua table (array) -&amp;gt; Redis multi bulk reply (truncated to the first nil inside the Lua array if any)</source>
          <target state="translated">Lua 테이블 (배열)-&amp;gt; Redis 다중 벌크 응답 (있는 경우 Lua 배열 내부의 첫 번째 nil로 잘림)</target>
        </trans-unit>
        <trans-unit id="92dffb8e404af7ee6cc40117a693313890548b7f" translate="yes" xml:space="preserve">
          <source>Lua table with a single &lt;code&gt;err&lt;/code&gt; field -&amp;gt; Redis error reply</source>
          <target state="translated">단일 &lt;code&gt;err&lt;/code&gt; 필드 가있는 Lua 테이블 -&amp;gt; Redis 오류 응답</target>
        </trans-unit>
        <trans-unit id="860f10116eaffeabf918bd97496952f6a8568b86" translate="yes" xml:space="preserve">
          <source>Lua table with a single &lt;code&gt;ok&lt;/code&gt; field -&amp;gt; Redis status reply</source>
          <target state="translated">하나와 루아 테이블 &lt;code&gt;ok&lt;/code&gt; 필드 -&amp;gt; 레디 스 상태 응답</target>
        </trans-unit>
        <trans-unit id="f4b1c471ce1efbe25d7232b293140a21b7fea826" translate="yes" xml:space="preserve">
          <source>MEMORY</source>
          <target state="translated">MEMORY</target>
        </trans-unit>
        <trans-unit id="5f530d724793deebbb2b735aad30cfb0c16904b5" translate="yes" xml:space="preserve">
          <source>MEMORY DOCTOR   Outputs memory problems report</source>
          <target state="translated">MEMORY DOCTOR 메모리 문제 보고서를 출력합니다</target>
        </trans-unit>
        <trans-unit id="f41c78df06ee10a6b220b355855965b8d5802f0d" translate="yes" xml:space="preserve">
          <source>MEMORY HELP   Show helpful text about the different subcommands</source>
          <target state="translated">MEMORY HELP 다른 하위 명령에 대한 유용한 텍스트 표시</target>
        </trans-unit>
        <trans-unit id="c46a26bce66617f3cb9ccdc83db737a6115fdc5d" translate="yes" xml:space="preserve">
          <source>MEMORY MALLOC-STATS   Show allocator internal stats</source>
          <target state="translated">메모리 MALLOC-STATS 할당 자 내부 통계 표시</target>
        </trans-unit>
        <trans-unit id="eb96d4965b5bb6522ee6573db44c8a6e1ce6edba" translate="yes" xml:space="preserve">
          <source>MEMORY PURGE   Ask the allocator to release memory</source>
          <target state="translated">메모리 제거 할당 자에게 메모리 해제를 요청하십시오.</target>
        </trans-unit>
        <trans-unit id="d3303c80cf9ee1aa6f783b72419ffa190e2a905d" translate="yes" xml:space="preserve">
          <source>MEMORY STATS   Show memory usage details</source>
          <target state="translated">메모리 통계 메모리 사용량 세부 정보 표시</target>
        </trans-unit>
        <trans-unit id="de9aed5605340cafa3f173e741e4bc7253d17f99" translate="yes" xml:space="preserve">
          <source>MEMORY USAGE  key [SAMPLES count]   Estimate the memory usage of a key</source>
          <target state="translated">MEMORY USAGE 키 [SAMPLES count] 키의 메모리 사용량을 추정하십시오.</target>
        </trans-unit>
        <trans-unit id="eb4b445b699787b561e4b67d4f6b08a7ef32cf55" translate="yes" xml:space="preserve">
          <source>MGET</source>
          <target state="translated">MGET</target>
        </trans-unit>
        <trans-unit id="ffbcf2b819692d7b52978ca1ef1e227536a082fe" translate="yes" xml:space="preserve">
          <source>MGET  key [key ...]   Get the values of all the given keys</source>
          <target state="translated">MGET 키 [key ...] 주어진 모든 키의 값을 얻습니다</target>
        </trans-unit>
        <trans-unit id="883beaf0f91aca7f9ebc4802e0bab2501cbbc8ea" translate="yes" xml:space="preserve">
          <source>MIGRATE</source>
          <target state="translated">MIGRATE</target>
        </trans-unit>
        <trans-unit id="2f0b2cdf3b3d88df6ed56ef5576fa5ec1a8aa5b1" translate="yes" xml:space="preserve">
          <source>MIGRATE  host port key|&quot;&quot; destination-db timeout [COPY] [REPLACE] [KEYS key [key ...]]   Atomically transfer a key from a Redis instance to another one.</source>
          <target state="translated">마이그레이션 호스트 포트 키 | &quot;&quot;destination-db 시간 초과 [복사] [바꾸기] [KEYS 키 [키 ...]] Redis 인스턴스에서 다른 키로 원자 적으로 키를 전송합니다.</target>
        </trans-unit>
        <trans-unit id="6da5b5979c630adef5abc39370410d7de4a1b8ef" translate="yes" xml:space="preserve">
          <source>MONITOR</source>
          <target state="translated">MONITOR</target>
        </trans-unit>
        <trans-unit id="55d4d86d6d24375e297cf38db11a4bacd4febc84" translate="yes" xml:space="preserve">
          <source>MONITOR   Listen for all requests received by the server in real time</source>
          <target state="translated">MONITOR 서버가 실시간으로 수신 한 모든 요청을 청취</target>
        </trans-unit>
        <trans-unit id="3bf08a84f15b98ce4d14b707f4a093b3cc8b853e" translate="yes" xml:space="preserve">
          <source>MOVE</source>
          <target state="translated">MOVE</target>
        </trans-unit>
        <trans-unit id="001d5d6407276cba944eda42b69684ebbbae5d55" translate="yes" xml:space="preserve">
          <source>MOVE  key db   Move a key to another database</source>
          <target state="translated">MOVE key db 키를 다른 데이터베이스로 이동</target>
        </trans-unit>
        <trans-unit id="4a4d41a590643b6020afed2c32a7fa4d49b49601" translate="yes" xml:space="preserve">
          <source>MSET</source>
          <target state="translated">MSET</target>
        </trans-unit>
        <trans-unit id="9a5861cd64b36ffe83c01382e80e50105a256980" translate="yes" xml:space="preserve">
          <source>MSET  key value [key value ...]   Set multiple keys to multiple values</source>
          <target state="translated">MSET 키 값 [key value ...] 여러 키를 여러 값으로 설정</target>
        </trans-unit>
        <trans-unit id="f7daca0dd0ee4f7979861ac9b4fb059852d07494" translate="yes" xml:space="preserve">
          <source>MSETNX</source>
          <target state="translated">MSETNX</target>
        </trans-unit>
        <trans-unit id="48498dbffef6df5e6474fe5db88a9722de54676a" translate="yes" xml:space="preserve">
          <source>MSETNX  key value [key value ...]   Set multiple keys to multiple values, only if none of the keys exist</source>
          <target state="translated">MSETNX 키 값 [key value ...] 키가없는 경우에만 여러 키를 여러 값으로 설정하십시오.</target>
        </trans-unit>
        <trans-unit id="73cadb41b45514de9061a72461b466eafd7a01b0" translate="yes" xml:space="preserve">
          <source>MULTI</source>
          <target state="translated">MULTI</target>
        </trans-unit>
        <trans-unit id="bb76d99632737ac9f4ecd1c2218ac5cae7373df0" translate="yes" xml:space="preserve">
          <source>MULTI   Mark the start of a transaction block</source>
          <target state="translated">MULTI 트랜잭션 블록의 시작을 표시합니다</target>
        </trans-unit>
        <trans-unit id="5162c1f5fa963969d600908fd5531f9515bcd0ad" translate="yes" xml:space="preserve">
          <source>Manually issue the &lt;a href=&quot;quit&quot;&gt;QUIT&lt;/a&gt; command to stop a &lt;a href=&quot;monitor&quot;&gt;MONITOR&lt;/a&gt; stream running via &lt;code&gt;telnet&lt;/code&gt;.</source>
          <target state="translated">&lt;a href=&quot;quit&quot;&gt;QUIT&lt;/a&gt; 명령을 수동으로 실행하여 &lt;code&gt;telnet&lt;/code&gt; 을 통해 실행 되는 &lt;a href=&quot;monitor&quot;&gt;MONITOR&lt;/a&gt; 스트림 을 중지하십시오 .</target>
        </trans-unit>
        <trans-unit id="195fbe53b32ee6173d85e3798809ae2267b7bfce" translate="yes" xml:space="preserve">
          <source>Marks the given keys to be watched for conditional execution of a &lt;a href=&quot;https://redis.io/topics/transactions&quot;&gt;transaction&lt;/a&gt;.</source>
          <target state="translated">주어진 키가 &lt;a href=&quot;https://redis.io/topics/transactions&quot;&gt;트랜잭션의&lt;/a&gt; 조건부 실행을 감시하도록 표시합니다 .</target>
        </trans-unit>
        <trans-unit id="c8683729a7a727945cae9baf35f4c55f1439a9ae" translate="yes" xml:space="preserve">
          <source>Marks the start of a &lt;a href=&quot;https://redis.io/topics/transactions&quot;&gt;transaction&lt;/a&gt; block. Subsequent commands will be queued for atomic execution using &lt;a href=&quot;exec&quot;&gt;EXEC&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;https://redis.io/topics/transactions&quot;&gt;트랜잭션&lt;/a&gt; 블록 의 시작을 표시합니다 . 후속 명령은 &lt;a href=&quot;exec&quot;&gt;EXEC를&lt;/a&gt; 사용하여 원자 실행을 위해 대기합니다 .</target>
        </trans-unit>
        <trans-unit id="f713e2ee906af8b74a13e92b2e0d07f7715b2d2e" translate="yes" xml:space="preserve">
          <source>Master for slot range represented as nested IP/Port array</source>
          <target state="translated">중첩 된 IP / 포트 배열로 표시되는 슬롯 범위의 마스터</target>
        </trans-unit>
        <trans-unit id="826539552e055ad1bd8dd2263cef37308d024f80" translate="yes" xml:space="preserve">
          <source>Master output</source>
          <target state="translated">마스터 출력</target>
        </trans-unit>
        <trans-unit id="3a00e4f9797b4c734ae7a585f001ffa257119f27" translate="yes" xml:space="preserve">
          <source>Meaning of the flags (field number 3):</source>
          <target state="translated">플래그의 의미 (필드 번호 3) :</target>
        </trans-unit>
        <trans-unit id="716383f923909d0c089205fcba00d4705b3601a5" translate="yes" xml:space="preserve">
          <source>Merge multiple HyperLogLog values into an unique value that will approximate the cardinality of the union of the observed Sets of the source HyperLogLog structures.</source>
          <target state="translated">여러 HyperLogLog 값을 고유 한 값으로 병합하여 관찰 된 소스 HyperLogLog 구조 세트의 합집합의 카디널리티에 근접합니다.</target>
        </trans-unit>
        <trans-unit id="d48699ea9bf170ea49610c0892198d522150833b" translate="yes" xml:space="preserve">
          <source>Migrating multiple keys with a single command call</source>
          <target state="translated">단일 명령 호출로 여러 키 마이그레이션</target>
        </trans-unit>
        <trans-unit id="1dc9fdcdad40a742a94a677f3b78a05f4ed5e6b5" translate="yes" xml:space="preserve">
          <source>Migration and importing slots are only added to the node flagged as &lt;code&gt;myself&lt;/code&gt;. This information is local to a node, for its own slots.</source>
          <target state="translated">마이그레이션 및 가져 오기 슬롯은 &lt;code&gt;myself&lt;/code&gt; 표시된 노드에만 추가됩니다 . 이 정보는 자체 슬롯에 대해 노드에 로컬입니다.</target>
        </trans-unit>
        <trans-unit id="bf4ac897fe1476ddf0632fbae3fd4061b3a77806" translate="yes" xml:space="preserve">
          <source>More details about the Redis HyperLogLog implementation can be found in &lt;a href=&quot;http://antirez.com/news/75&quot;&gt;this blog post&lt;/a&gt;. The source code of the implementation in the &lt;code&gt;hyperloglog.c&lt;/code&gt; file is also easy to read and understand, and includes a full specification for the exact encoding used for the sparse and dense representations.</source>
          <target state="translated">Redis HyperLogLog 구현에 대한 자세한 내용은 &lt;a href=&quot;http://antirez.com/news/75&quot;&gt;이 블로그 게시물&lt;/a&gt; 에서 확인할 수 있습니다 . &lt;code&gt;hyperloglog.c&lt;/code&gt; 파일 에서 구현의 소스 코드 도 읽고 이해하기 쉽고 희소하고 조밀 한 표현에 사용되는 정확한 인코딩에 대한 전체 사양을 포함합니다.</target>
        </trans-unit>
        <trans-unit id="66fbce4faebab20f5ca1d3b33c08e967f22406cb" translate="yes" xml:space="preserve">
          <source>More information about the Current Epoch and Config Epoch variables are available in the Redis Cluster specification document.</source>
          <target state="translated">현재 Epoch 및 구성 Epoch 변수에 대한 자세한 내용은 Redis Cluster 사양 문서에서 확인할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="76f5a5481231f7dff85e48d6a0993bd209662a44" translate="yes" xml:space="preserve">
          <source>Moreover &lt;a href=&quot;cluster-meet&quot;&gt;CLUSTER MEET&lt;/a&gt; does not need to be reciprocal. If I send the command to A in order to join B, I don't need to also send it to B in order to join A.</source>
          <target state="translated">또한 &lt;a href=&quot;cluster-meet&quot;&gt;CLUSTER MEET&lt;/a&gt; 은 상호적일 필요는 없습니다. B에 가입하기 위해 A로 명령을 보내면 A에 가입하기 위해 B로도 명령을 보낼 필요가 없습니다.</target>
        </trans-unit>
        <trans-unit id="8993f2e40360ac488b5303cad3bacad41d3a08f1" translate="yes" xml:space="preserve">
          <source>Moreover, as a side effect, &lt;a href=&quot;xclaim&quot;&gt;XCLAIM&lt;/a&gt; will increment the count of attempted deliveries of the message. In this way messages that cannot be processed for some reason, for instance because the consumers crash attempting to process them, will start to have a larger counter and can be detected inside the system.</source>
          <target state="translated">또한 부작용으로 &lt;a href=&quot;xclaim&quot;&gt;XCLAIM&lt;/a&gt; 은 메시지 배달 시도 횟수를 증가시킵니다. 이런 식으로 어떤 이유로 처리 할 수없는 메시지 (예 : 소비자가 메시지를 처리하려고 시도하면 충돌)는 더 큰 카운터를 갖기 시작하고 시스템 내부에서 감지 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6330fc6bbcd49c1766a676116e26172a91d38595" translate="yes" xml:space="preserve">
          <source>Moreover, if you are new to streams, we recommend to read our &lt;a href=&quot;https://redis.io/topics/streams-intro&quot;&gt;introduction to Redis Streams&lt;/a&gt;. Make sure to understand the concept of consumer group in the introduction so that following how this command works will be simpler.</source>
          <target state="translated">또한 스트림을 &lt;a href=&quot;https://redis.io/topics/streams-intro&quot;&gt;처음 사용하는 경우 Redis Streams 소개를&lt;/a&gt; 읽는 것이 좋습니다 . 소개에서 소비자 그룹의 개념을 이해해야이 명령의 작동 방식을 따르는 것이 더 간단 해집니다.</target>
        </trans-unit>
        <trans-unit id="fde66fa86f8517d887e54616bf1fb31656fc7f81" translate="yes" xml:space="preserve">
          <source>Motivations</source>
          <target state="translated">Motivations</target>
        </trans-unit>
        <trans-unit id="eaf7a15ddfb6c5c306f486c8bf293512f163a845" translate="yes" xml:space="preserve">
          <source>Movable Keys</source>
          <target state="translated">움직일 수있는 키</target>
        </trans-unit>
        <trans-unit id="f77b47b8d13d94af9785e089c536b9963ca2c823" translate="yes" xml:space="preserve">
          <source>Move &lt;code&gt;key&lt;/code&gt; from the currently selected database (see &lt;a href=&quot;select&quot;&gt;SELECT&lt;/a&gt;) to the specified destination database. When &lt;code&gt;key&lt;/code&gt; already exists in the destination database, or it does not exist in the source database, it does nothing. It is possible to use &lt;a href=&quot;move&quot;&gt;MOVE&lt;/a&gt; as a locking primitive because of this.</source>
          <target state="translated">현재 선택된 데이터베이스 ( &lt;a href=&quot;select&quot;&gt;SELECT&lt;/a&gt; 참조 )에서 지정된 대상 데이터베이스로 &lt;code&gt;key&lt;/code&gt; 를 이동 하십시오 . 때 &lt;code&gt;key&lt;/code&gt; 이미 대상 데이터베이스에 존재하거나 소스 데이터베이스에 존재하지 않는, 그것은 아무것도하지 않는다. 이 때문에 &lt;a href=&quot;move&quot;&gt;MOVE&lt;/a&gt; 를 잠금 프리미티브로 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="17c083c9f9d68a5d0169cd11d9c0c04115759b24" translate="yes" xml:space="preserve">
          <source>Move &lt;code&gt;member&lt;/code&gt; from the set at &lt;code&gt;source&lt;/code&gt; to the set at &lt;code&gt;destination&lt;/code&gt;. This operation is atomic. In every given moment the element will appear to be a member of &lt;code&gt;source&lt;/code&gt;&lt;strong&gt;or&lt;/strong&gt;&lt;code&gt;destination&lt;/code&gt; for other clients.</source>
          <target state="translated">&lt;code&gt;source&lt;/code&gt; 세트에서 &lt;code&gt;destination&lt;/code&gt; 세트로 &lt;code&gt;member&lt;/code&gt; 를 이동 하십시오 . 이 작업은 원 자성입니다. 주어진 순간마다 요소는 다른 클라이언트 의 &lt;code&gt;source&lt;/code&gt; &lt;strong&gt;또는 &lt;/strong&gt; &lt;code&gt;destination&lt;/code&gt; 의 구성원으로 나타납니다 .&lt;strong&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="95a91b78dd0ce912aadce361711a043cae9a887e" translate="yes" xml:space="preserve">
          <source>Multiple parallel iterations</source>
          <target state="translated">다중 병렬 반복</target>
        </trans-unit>
        <trans-unit id="f492964822aab7cec6aa84fefaffe8fba8b6cd36" translate="yes" xml:space="preserve">
          <source>Nested Result Array</source>
          <target state="translated">중첩 된 결과 배열</target>
        </trans-unit>
        <trans-unit id="fdc70576104b358de95d88f0255666aac631aff0" translate="yes" xml:space="preserve">
          <source>New fields are regularly added for debugging purpose. Some could be removed in the future. A version safe Redis client using this command should parse the output accordingly (i.e. handling gracefully missing fields, skipping unknown fields).</source>
          <target state="translated">디버깅을 위해 새 필드가 정기적으로 추가됩니다. 나중에 일부를 제거 할 수 있습니다. 이 명령을 사용하는 버전 안전 Redis 클라이언트는 그에 따라 출력을 구문 분석해야합니다 (예 : 정상적으로 누락 된 필드 처리, 알 수없는 필드 생략).</target>
        </trans-unit>
        <trans-unit id="861e51e24f78632f52937df883ebeed5a0766d52" translate="yes" xml:space="preserve">
          <source>New keys are always created in the target node. During a hash slot migration we'll have to move only old keys, not new ones.</source>
          <target state="translated">새 키는 항상 대상 노드에 작성됩니다. 해시 슬롯 마이그레이션 중에는 새로운 키가 아닌 이전 키만 이동해야합니다.</target>
        </trans-unit>
        <trans-unit id="97bfa87b383568ddb64d92c09cf59316bbb313bd" translate="yes" xml:space="preserve">
          <source>No repeated elements are returned.</source>
          <target state="translated">반복되는 요소가 리턴되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="75e932f04e490ddd2c64a4420d419573bd058eac" translate="yes" xml:space="preserve">
          <source>Nodes in &lt;code&gt;PFAIL&lt;/code&gt; state are provided in gossip sections of heartbeat packets.</source>
          <target state="translated">&lt;code&gt;PFAIL&lt;/code&gt; 상태의 노드 는 하트 비트 패킷의 가십 섹션에서 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="c02697f1f51c2f137246d46e8911c8e7f53e6636" translate="yes" xml:space="preserve">
          <source>Non existing elements are reported as NULL elements of the array.</source>
          <target state="translated">존재하지 않는 요소는 배열의 NULL 요소로보고됩니다.</target>
        </trans-unit>
        <trans-unit id="5dfb2fbf84cf8de01a0c2542d485d2207dc976ae" translate="yes" xml:space="preserve">
          <source>Non used lines are blanked. For instance if you used to have multiple &lt;code&gt;save&lt;/code&gt; directives, but the current configuration has fewer or none as you disabled RDB persistence, all the lines will be blanked.</source>
          <target state="translated">사용되지 않은 줄은 비워집니다. 예를 들어 , 여러 &lt;code&gt;save&lt;/code&gt; 지시문을 사용했지만 RDB 지속성을 사용하지 않도록 설정했을 때 현재 구성의 수가 적거나없는 경우 모든 행이 공백이됩니다.</target>
        </trans-unit>
        <trans-unit id="de44f50198c0734dcccb5b1c5d4825eb72c13aba" translate="yes" xml:space="preserve">
          <source>Non-blocking behavior</source>
          <target state="translated">비 차단 행동</target>
        </trans-unit>
        <trans-unit id="5cbfa62b0d0a8a33923d06127db99370a393ad0d" translate="yes" xml:space="preserve">
          <source>Non-blocking usage</source>
          <target state="translated">비 차단 사용량</target>
        </trans-unit>
        <trans-unit id="bcbbb0c35f64190eb100cd6befa838fbd5037874" translate="yes" xml:space="preserve">
          <source>Non-existent keys are treated as empty strings, so the command will return zero.</source>
          <target state="translated">존재하지 않는 키는 빈 문자열로 취급되므로 명령이 0을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="46b493cea7b65b3003ea2e423707591849b0ee78" translate="yes" xml:space="preserve">
          <source>Non-existent keys are treated as empty strings.</source>
          <target state="translated">존재하지 않는 키는 빈 문자열로 처리됩니다.</target>
        </trans-unit>
        <trans-unit id="9a60acaa61d5a344489afdd9e5311dbf8888aa00" translate="yes" xml:space="preserve">
          <source>Normally &lt;a href=&quot;zrangebyscore&quot;&gt;ZRANGEBYSCORE&lt;/a&gt; is simply used in order to get range of items where the score is the indexed integer key, however it is possible to do less obvious things with the command.</source>
          <target state="translated">일반적으로 &lt;a href=&quot;zrangebyscore&quot;&gt;ZRANGEBYSCORE&lt;/a&gt; 는 점수가 색인화 된 정수 키인 항목의 범위를 가져 오기 위해 간단히 사용되지만 명령으로 덜 명확한 일을 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4dba9f7be4e65fcc1fd8d86533e96e912932e110" translate="yes" xml:space="preserve">
          <source>Normally Redis keys are created without an associated time to live. The key will simply live forever, unless it is removed by the user in an explicit way, for instance using the &lt;a href=&quot;del&quot;&gt;DEL&lt;/a&gt; command.</source>
          <target state="translated">일반적으로 Redis 키는 관련 시간없이 생성됩니다. 키는 사용자가 &lt;a href=&quot;del&quot;&gt;DEL&lt;/a&gt; 명령을 사용하는 등의 명시적인 방법으로 제거하지 않는 한 영원히 지속 됩니다.</target>
        </trans-unit>
        <trans-unit id="488e099ce2d3130dde9348d7a491fea120dffc25" translate="yes" xml:space="preserve">
          <source>Normally Redis represents positions of elements using a variation of the Geohash technique where positions are encoded using 52 bit integers. The encoding is also different compared to the standard because the initial min and max coordinates used during the encoding and decoding process are different. This command however &lt;strong&gt;returns a standard Geohash&lt;/strong&gt; in the form of a string as described in the &lt;a href=&quot;https://en.wikipedia.org/wiki/Geohash&quot;&gt;Wikipedia article&lt;/a&gt; and compatible with the &lt;a href=&quot;http://geohash.org&quot;&gt;geohash.org&lt;/a&gt; web site.</source>
          <target state="translated">일반적으로 Redis는 위치가 52 비트 정수를 사용하여 인코딩되는 Geohash 기술의 변형을 사용하여 요소의 위치를 ​​나타냅니다. 인코딩 및 디코딩 과정에서 사용되는 초기 최소 및 최대 좌표가 다르기 때문에 인코딩은 표준과 비교하여 다릅니다. 그러나이 명령 은 &lt;a href=&quot;https://en.wikipedia.org/wiki/Geohash&quot;&gt;Wikipedia 기사에&lt;/a&gt; 설명되어 있고 &lt;a href=&quot;http://geohash.org&quot;&gt;geohash.org&lt;/a&gt; 웹 사이트 와 호환 되는 문자열 형식으로 &lt;strong&gt;표준 Geohash&lt;/strong&gt; 를 &lt;strong&gt;반환합니다&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="48fbc2c3360b2ccdab702dc73f1af3fdad88932d" translate="yes" xml:space="preserve">
          <source>Normally hash slots associated to a given node are in one of the following formats, as already explained above:</source>
          <target state="translated">주어진 노드와 연관된 해시 슬롯은 일반적으로 위에서 설명한대로 다음 형식 중 하나입니다.</target>
        </trans-unit>
        <trans-unit id="20da22f8d3c73a214f41394b1c9a9c08c0230154" translate="yes" xml:space="preserve">
          <source>Normally if there is an AOF child process performing an AOF rewrite, Redis will simply kill it and exit. However there are two conditions where it is unsafe to do so, and the &lt;strong&gt;SHUTDOWN&lt;/strong&gt; command will be refused with an error instead. This happens when:</source>
          <target state="translated">일반적으로 AOF 재 작성을 수행하는 AOF 하위 프로세스가있는 경우 Redis는 단순히 프로세스를 종료하고 종료합니다. 그러나 안전하지 않은 두 가지 조건 이 있으며 대신 오류와 함께 &lt;strong&gt;SHUTDOWN&lt;/strong&gt; 명령이 거부됩니다. 다음과 같은 경우에 발생합니다.</target>
        </trans-unit>
        <trans-unit id="f552eaf00c55408f0aa996335bcd91c4da8dcdb7" translate="yes" xml:space="preserve">
          <source>Normally replica nodes will redirect clients to the authoritative master for the hash slot involved in a given command, however clients can use replicas in order to scale reads using the &lt;a href=&quot;readonly&quot;&gt;READONLY&lt;/a&gt; command.</source>
          <target state="translated">일반적으로 복제본 노드는 지정된 명령에 포함 된 해시 슬롯에 대해 권한이있는 마스터로 클라이언트를 리디렉션하지만 클라이언트는 &lt;a href=&quot;readonly&quot;&gt;READONLY&lt;/a&gt; 명령을 사용하여 읽기를 확장하기 위해 복제본을 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="0b040d0fd81d55e920e28d6b8b43687a96fedfb9" translate="yes" xml:space="preserve">
          <source>Normally replicating scripts instead of the effects of the scripts makes sense, however not in all the cases. So starting with Redis 3.2, the scripting engine is able to, alternatively, replicate the sequence of write commands resulting from the script execution, instead of replication the script itself. See the next section for more information. In this section we'll assume that scripts are replicated by sending the whole script. Let's call this replication mode &lt;strong&gt;whole scripts replication&lt;/strong&gt;.</source>
          <target state="translated">일반적으로 스크립트의 효과 대신 스크립트를 복제하는 것이 의미가 있지만 모든 경우에 해당되는 것은 아닙니다. 따라서 Redis 3.2부터는 스크립팅 엔진이 스크립트 자체를 복제하는 대신 스크립트 실행으로 인한 일련의 쓰기 명령을 복제 할 수 있습니다. 자세한 내용은 다음 섹션을 참조하십시오. 이 섹션에서는 전체 스크립트를 전송하여 스크립트를 복제한다고 가정합니다. 이 복제 모드를 &lt;strong&gt;전체 스크립트 복제라고합니다&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="de2018dd71c22fe4b55fd2f381e3bcbd8ea7b844" translate="yes" xml:space="preserve">
          <source>Normally you may think at a Redis stream as an append-only data structure, however Redis streams are represented in memory, so we are able to also delete entries. This may be useful, for instance, in order to comply with certain privacy policies.</source>
          <target state="translated">일반적으로 Redis 스트림을 추가 전용 데이터 구조로 생각할 수 있지만 Redis 스트림은 메모리에 표시되므로 항목을 삭제할 수도 있습니다. 예를 들어 특정 개인 정보 보호 정책을 준수하는 데 유용 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="675cc42aab3b45855f7e4f48b1a8a2f9ea1abcdc" translate="yes" xml:space="preserve">
          <source>Normally you use the command like that in order to get new messages and process them. In pseudo-code:</source>
          <target state="translated">일반적으로 새 메시지를 가져 와서 처리하기 위해 이와 같은 명령을 사용합니다. 의사 코드에서 :</target>
        </trans-unit>
        <trans-unit id="92faf092f64b7750013de7ad70293bed4c22e467" translate="yes" xml:space="preserve">
          <source>Note for Lua newbies: in order to avoid using global variables in your scripts simply declare every variable you are going to use using the &lt;em&gt;local&lt;/em&gt; keyword.</source>
          <target state="translated">Lua 초보자를위한 참고 사항 : 스크립트에서 전역 변수를 사용하지 않으려면 &lt;em&gt;local&lt;/em&gt; 키워드 를 사용하여 사용할 모든 변수를 선언하면됩니다 .</target>
        </trans-unit>
        <trans-unit id="386ff54d1c33b65d55947a3bc043df349ed6b50a" translate="yes" xml:space="preserve">
          <source>Note that &lt;a href=&quot;scan&quot;&gt;SCAN&lt;/a&gt;, &lt;a href=&quot;sscan&quot;&gt;SSCAN&lt;/a&gt;, &lt;a href=&quot;hscan&quot;&gt;HSCAN&lt;/a&gt; and &lt;a href=&quot;zscan&quot;&gt;ZSCAN&lt;/a&gt; all work very similarly, so this documentation covers all the four commands. However an obvious difference is that in the case of &lt;a href=&quot;sscan&quot;&gt;SSCAN&lt;/a&gt;, &lt;a href=&quot;hscan&quot;&gt;HSCAN&lt;/a&gt; and &lt;a href=&quot;zscan&quot;&gt;ZSCAN&lt;/a&gt; the first argument is the name of the key holding the Set, Hash or Sorted Set value. The &lt;a href=&quot;scan&quot;&gt;SCAN&lt;/a&gt; command does not need any key name argument as it iterates keys in the current database, so the iterated object is the database itself.</source>
          <target state="translated">참고 &lt;a href=&quot;scan&quot;&gt;SCAN&lt;/a&gt; , &lt;a href=&quot;sscan&quot;&gt;sscan을&lt;/a&gt; , &lt;a href=&quot;hscan&quot;&gt;HSCAN&lt;/a&gt; 및 &lt;a href=&quot;zscan&quot;&gt;ZSCAN&lt;/a&gt; 매우 유사하게 모든 일을,이 문서 커버 이렇게 모두 네 개의 명령. 그러나 &lt;a href=&quot;sscan&quot;&gt;SSCAN&lt;/a&gt; , &lt;a href=&quot;hscan&quot;&gt;HSCAN&lt;/a&gt; 및 &lt;a href=&quot;zscan&quot;&gt;ZSCAN의&lt;/a&gt; 경우 첫 번째 인수는 Set, Hash 또는 Sorted Set 값을 보유하는 키의 이름이라는 것이 분명한 차이점입니다 . &lt;a href=&quot;scan&quot;&gt;SCAN&lt;/a&gt; 은 현재 데이터베이스에 키를 반복 할 때마다 반복되는 객체는 데이터베이스 자체 그래서 명령은 어떤 키 이름 인수를 필요로하지 않는다.</target>
        </trans-unit>
        <trans-unit id="b8af6b6330cf6687e8cc50e67b81c7d7beffd113" translate="yes" xml:space="preserve">
          <source>Note that &lt;a href=&quot;wait&quot;&gt;WAIT&lt;/a&gt; does not make Redis a strongly consistent store: while synchronous replication is part of a replicated state machine, it is not the only thing needed. However in the context of Sentinel or Redis Cluster failover, &lt;a href=&quot;wait&quot;&gt;WAIT&lt;/a&gt; improves the real world data safety.</source>
          <target state="translated">참고 &lt;a href=&quot;wait&quot;&gt;WAIT가&lt;/a&gt; 레디 스 강력한 일관성을 저장하지 않습니다 동기식 복제가 복제 된 상태 머신의 일부입니다 동안, 그것은 필요한 유일한 것은 아니다. 그러나 Sentinel 또는 Redis Cluster 장애 조치와 관련하여 &lt;a href=&quot;wait&quot;&gt;WAIT&lt;/a&gt; 는 실제 데이터 안전성을 향상시킵니다.</target>
        </trans-unit>
        <trans-unit id="196f50bc6a6ac776d1991175d0001fae97125b81" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;GEORADIUSBYMEMBER_RO&lt;/code&gt; is also available since Redis 3.2.10 and Redis 4.0.0 in order to provide a read-only command that can be used in replicas. See the &lt;a href=&quot;georadius&quot;&gt;GEORADIUS&lt;/a&gt; page for more information.</source>
          <target state="translated">참고 &lt;code&gt;GEORADIUSBYMEMBER_RO&lt;/code&gt; 가 복제에 사용할 수있는 읽기 전용 명령을 제공하기 위해 레디 스 3.2.10와 레디 스 4.0.0 이후도 사용할 수 있습니다. 자세한 내용은 &lt;a href=&quot;georadius&quot;&gt;GEORADIUS&lt;/a&gt; 페이지를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="7f4713a8dfe3582f9f0fc3ed836bf0396dfbd617" translate="yes" xml:space="preserve">
          <source>Note that &lt;strong&gt;TAKEOVER violates the last-failover-wins principle&lt;/strong&gt; of Redis Cluster, since the configuration epoch generated by the replica violates the normal generation of configuration epochs in several ways:</source>
          <target state="translated">복제본에서 생성 된 구성 에포크 (epoch)는 여러 가지 방법으로 일반 구성 에포크 (epoch)를 &lt;strong&gt;위반하기&lt;/strong&gt; 때문에 &lt;strong&gt;TAKEOVER&lt;/strong&gt; 는 Redis Cluster &lt;strong&gt;의 마지막 페일 오버&lt;/strong&gt; 윈 &lt;strong&gt;원칙&lt;/strong&gt; 을 위반합니다.</target>
        </trans-unit>
        <trans-unit id="b1e5f99b4ded8ce6be23a9f6f9872d3e5595ab46" translate="yes" xml:space="preserve">
          <source>Note that Redis Cluster needs to form a full mesh (each node is connected with each other node), but in order to create a cluster, there is no need to send all the &lt;a href=&quot;cluster-meet&quot;&gt;CLUSTER MEET&lt;/a&gt; commands needed to form the full mesh. What matter is to send enough &lt;a href=&quot;cluster-meet&quot;&gt;CLUSTER MEET&lt;/a&gt; messages so that each node can reach each other node through a &lt;em&gt;chain of known nodes&lt;/em&gt;. Thanks to the exchange of gossip information in heartbeat packets, the missing links will be created.</source>
          <target state="translated">Redis Cluster는 전체 메쉬를 형성해야하지만 (각 노드는 서로 연결되어 있음) 클러스터를 생성하기 위해 전체 메쉬를 형성하는 데 필요한 모든 &lt;a href=&quot;cluster-meet&quot;&gt;CLUSTER MEET&lt;/a&gt; 명령 을 보낼 필요는 없습니다 . 중요한 것은 각 노드 &lt;em&gt;가 알려진 노드 체인을&lt;/em&gt; 통해 서로 노드에 도달 할 수 있도록 충분한 &lt;a href=&quot;cluster-meet&quot;&gt;CLUSTER MEET&lt;/a&gt; 메시지 를 보내는 것 입니다. 하트 비트 패킷으로 가십 정보를 교환함으로써 누락 된 링크가 생성됩니다.&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="17fc5decb8a235b9d4881b1185aa05ef897a69aa" translate="yes" xml:space="preserve">
          <source>Note that bit positions are returned always as absolute values starting from bit zero even when &lt;em&gt;start&lt;/em&gt; and &lt;em&gt;end&lt;/em&gt; are used to specify a range.</source>
          <target state="translated">&lt;em&gt;시작&lt;/em&gt; 과 &lt;em&gt;끝&lt;/em&gt; 을 사용하여 범위를 지정 하더라도 비트 위치는 항상 비트 0부터 시작하는 절대 값으로 반환 됩니다.</target>
        </trans-unit>
        <trans-unit id="d47127e4277fb6af8f1ec3e041d7aadf84ff3fe6" translate="yes" xml:space="preserve">
          <source>Note that calling &lt;a href=&quot;expire&quot;&gt;EXPIRE&lt;/a&gt;/&lt;a href=&quot;pexpire&quot;&gt;PEXPIRE&lt;/a&gt; with a non-positive timeout or &lt;a href=&quot;expireat&quot;&gt;EXPIREAT&lt;/a&gt;/&lt;a href=&quot;pexpireat&quot;&gt;PEXPIREAT&lt;/a&gt; with a time in the past will result in the key being &lt;a href=&quot;del&quot;&gt;deleted&lt;/a&gt; rather than expired (accordingly, the emitted &lt;a href=&quot;https://redis.io/topics/notifications&quot;&gt;key event&lt;/a&gt; will be &lt;code&gt;del&lt;/code&gt;, not &lt;code&gt;expired&lt;/code&gt;).</source>
          <target state="translated">참고 전화가 &lt;a href=&quot;expire&quot;&gt;EXPIRE&lt;/a&gt; / &lt;a href=&quot;pexpire&quot;&gt;PEXPIRE&lt;/a&gt; 이 아닌 긍정적 인 타임 아웃이나와 &lt;a href=&quot;expireat&quot;&gt;EXPIREAT&lt;/a&gt; / &lt;a href=&quot;pexpireat&quot;&gt;PEXPIREAT&lt;/a&gt; 키 존재가 발생합니다 과거의 시간이 &lt;a href=&quot;del&quot;&gt;삭제&lt;/a&gt; (따라서, 방출 만료보다는 &lt;a href=&quot;https://redis.io/topics/notifications&quot;&gt;키 이벤트가&lt;/a&gt; 될 것 &lt;code&gt;del&lt;/code&gt; 하지 &lt;code&gt;expired&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="134cdffcc8cc8242a1731baa707e6b6f212bd203" translate="yes" xml:space="preserve">
          <source>Note that each &lt;code&gt;OVERFLOW&lt;/code&gt; statement only affects the &lt;a href=&quot;incrby&quot;&gt;INCRBY&lt;/a&gt; commands that follow it in the list of subcommands, up to the next &lt;code&gt;OVERFLOW&lt;/code&gt; statement.</source>
          <target state="translated">각 &lt;code&gt;OVERFLOW&lt;/code&gt; 문 은 다음 &lt;code&gt;OVERFLOW&lt;/code&gt; 문 까지 하위 명령 목록 &lt;a href=&quot;incrby&quot;&gt;에서이&lt;/a&gt; 명령을 따르는 INCRBY 명령 에만 영향을 미칩니다 .</target>
        </trans-unit>
        <trans-unit id="c59e6cb007a017cde6a0590f3fe3a6903d02fdbc" translate="yes" xml:space="preserve">
          <source>Note that for correctly implementing this pattern it is important to avoid multiple clients rebuilding the cache at the same time. Some kind of locking is needed here (for instance using &lt;a href=&quot;setnx&quot;&gt;SETNX&lt;/a&gt;).</source>
          <target state="translated">이 패턴을 올바르게 구현하려면 여러 클라이언트가 동시에 캐시를 다시 작성하지 않도록하는 것이 중요합니다. 여기서는 일종의 잠금이 필요합니다 (예 : &lt;a href=&quot;setnx&quot;&gt;SETNX&lt;/a&gt; 사용 ).</target>
        </trans-unit>
        <trans-unit id="ab5932614de576b14cea0fbf3d424f67389687d0" translate="yes" xml:space="preserve">
          <source>Note that for the same reason a Lua script or a &lt;code&gt;MULTI/EXEC&lt;/code&gt; block may push elements into a list and afterward &lt;strong&gt;delete the list&lt;/strong&gt;. In this case the blocked clients will not be served at all and will continue to be blocked as long as no data is present on the list after the execution of a single command, transaction, or script.</source>
          <target state="translated">같은 이유로 Lua 스크립트 또는 &lt;code&gt;MULTI/EXEC&lt;/code&gt; 블록이 요소를 목록으로 푸시 한 다음 목록을 &lt;strong&gt;삭제할 수&lt;/strong&gt; 있습니다. 이 경우 차단 된 클라이언트는 전혀 제공되지 않으며 단일 명령, 트랜잭션 또는 스크립트를 실행 한 후 목록에 데이터가없는 한 계속 차단됩니다.</target>
        </trans-unit>
        <trans-unit id="fcc828a00ba6196c133772751828406df7944657" translate="yes" xml:space="preserve">
          <source>Note that if a replica is added, moved, or removed from a given master node, and we ask &lt;a href=&quot;cluster-replicas&quot;&gt;CLUSTER REPLICAS&lt;/a&gt; to a node that has not yet received the configuration update, it may show stale information. However eventually (in a matter of seconds if there are no network partitions) all the nodes will agree about the set of nodes associated with a given master.</source>
          <target state="translated">지정된 마스터 노드에서 복제본을 추가, 이동 또는 제거하고 아직 구성 업데이트를받지 않은 노드에 &lt;a href=&quot;cluster-replicas&quot;&gt;CLUSTER REPLICAS&lt;/a&gt; 를 요청 하면 오래된 정보가 표시 될 수 있습니다. 그러나 결국 (네트워크 파티션이 없으면 몇 초 만에) 모든 노드는 주어진 마스터와 관련된 노드 세트에 동의합니다.</target>
        </trans-unit>
        <trans-unit id="21094e1f69e7fc1828b555fe35532f052b5ac245" translate="yes" xml:space="preserve">
          <source>Note that if a replica is added, moved, or removed from a given master node, and we ask &lt;a href=&quot;cluster-slaves&quot;&gt;CLUSTER SLAVES&lt;/a&gt; to a node that has not yet received the configuration update, it may show stale information. However eventually (in a matter of seconds if there are no network partitions) all the nodes will agree about the set of nodes associated with a given master.</source>
          <target state="translated">지정된 마스터 노드에서 복제본을 추가, 이동 또는 제거하고 아직 구성 업데이트를받지 않은 노드에 &lt;a href=&quot;cluster-slaves&quot;&gt;CLUSTER SLAVES&lt;/a&gt; 를 요청 하면 오래된 정보가 표시 될 수 있습니다. 그러나 결국 (네트워크 파티션이 없으면 몇 초 만에) 모든 노드는 주어진 마스터와 관련된 노드 세트에 동의합니다.</target>
        </trans-unit>
        <trans-unit id="92bc3cdf3318fb930ded8c852b6a00267accad1a" translate="yes" xml:space="preserve">
          <source>Note that if you have a list of numbers from 0 to 100, &lt;code&gt;LRANGE list 0 10&lt;/code&gt; will return 11 elements, that is, the rightmost item is included. This &lt;strong&gt;may or may not&lt;/strong&gt; be consistent with behavior of range-related functions in your programming language of choice (think Ruby's &lt;code&gt;Range.new&lt;/code&gt;, &lt;code&gt;Array#slice&lt;/code&gt; or Python's &lt;code&gt;range()&lt;/code&gt; function).</source>
          <target state="translated">0에서 100까지의 숫자 목록이있는 경우 &lt;code&gt;LRANGE list 0 10&lt;/code&gt; 은 11 개의 요소를 반환합니다. 즉, 가장 오른쪽 항목이 포함됩니다. 이것은 선택한 프로그래밍 언어에서 범위 관련 함수의 동작과 일치 &lt;strong&gt;하거나&lt;/strong&gt; 일치 &lt;strong&gt;하지 않을&lt;/strong&gt; 수 있습니다 (Ruby 's &lt;code&gt;Range.new&lt;/code&gt; , &lt;code&gt;Array#slice&lt;/code&gt; 또는 Python 's &lt;code&gt;range()&lt;/code&gt; 함수).</target>
        </trans-unit>
        <trans-unit id="b145f3c9b171e7c40ecd23d7161660cea0ebde1c" translate="yes" xml:space="preserve">
          <source>Note that it is valid to call this command without channels. In this case it will just return an empty list.</source>
          <target state="translated">채널없이이 명령을 호출하는 것이 유효합니다. 이 경우 빈 목록 만 반환합니다.</target>
        </trans-unit>
        <trans-unit id="7cbc0087feeeb4b8394154849c8ec33aeb518c13" translate="yes" xml:space="preserve">
          <source>Note that non-existing keys are treated like empty lists, so when &lt;code&gt;key&lt;/code&gt; does not exist, the command will always return &lt;code&gt;0&lt;/code&gt;.</source>
          <target state="translated">존재하지 않는 &lt;code&gt;key&lt;/code&gt; 는 빈 목록처럼 취급되므로 키 가 존재하지 않으면 명령은 항상 &lt;code&gt;0&lt;/code&gt; 을 반환 합니다.</target>
        </trans-unit>
        <trans-unit id="e83de8fca6610aa183e7aad22115791cd55bc9fb" translate="yes" xml:space="preserve">
          <source>Note that normally clients willing to fetch the map between Cluster hash slots and node addresses should use &lt;a href=&quot;cluster-slots&quot;&gt;CLUSTER SLOTS&lt;/a&gt; instead. &lt;a href=&quot;cluster-nodes&quot;&gt;CLUSTER NODES&lt;/a&gt;, that provides more information, should be used for administrative tasks, debugging, and configuration inspections. It is also used by &lt;code&gt;redis-trib&lt;/code&gt; in order to manage a cluster.</source>
          <target state="translated">일반적으로 클러스터 해시 슬롯과 노드 주소간에 맵을 가져 오려는 클라이언트는 대신 &lt;a href=&quot;cluster-slots&quot;&gt;CLUSTER SLOTS&lt;/a&gt; 를 사용해야 합니다. 자세한 정보를 제공하는 &lt;a href=&quot;cluster-nodes&quot;&gt;CLUSTER NODES&lt;/a&gt; 는 관리 작업, 디버깅 및 구성 검사에 사용해야합니다. 클러스터를 관리하기 위해 &lt;code&gt;redis-trib&lt;/code&gt; 에서도 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="1f6b2fdffdf326f5f641aa170f10beb1a26d5924" translate="yes" xml:space="preserve">
          <source>Note that once a node assigns a set of slots to itself, it will start propagating this information in heartbeat packet headers. However the other nodes will accept the information only if they have the slot as not already bound with another node, or if the configuration epoch of the node advertising the new hash slot, is greater than the node currently listed in the table.</source>
          <target state="translated">노드가 자신에게 슬롯 세트를 할당하면이 정보를 하트 비트 패킷 헤더에 전파하기 시작합니다. 그러나 다른 노드는 아직 다른 노드와 바인드되지 않은 슬롯이 있거나 새 해시 슬롯을 알리는 노드의 구성 에포크가 현재 표에 나열된 노드보다 큰 경우에만 정보를 승인합니다.</target>
        </trans-unit>
        <trans-unit id="34efcb15ecc544550f9bd4f238eeb1c37bfe6eb5" translate="yes" xml:space="preserve">
          <source>Note that the command implements the full hashing algorithm, including support for &lt;strong&gt;hash tags&lt;/strong&gt;, that is the special property of Redis Cluster key hashing algorithm, of hashing just what is between &lt;code&gt;{&lt;/code&gt; and &lt;code&gt;}&lt;/code&gt; if such a pattern is found inside the key name, in order to force multiple keys to be handled by the same node.</source>
          <target state="translated">이 명령은 &lt;strong&gt;해시 태그&lt;/strong&gt; 지원을 포함하여 Redis Cluster 키 해싱 알고리즘의 특수 속성 인 &lt;strong&gt;해시 태그&lt;/strong&gt; 지원을 포함하여 전체 해싱 알고리즘을 구현합니다. 이러한 패턴이 키 이름 내에 순서대로 발견되면 &lt;code&gt;{&lt;/code&gt; 와 &lt;code&gt;}&lt;/code&gt; 사이에있는 해싱입니다. 동일한 노드가 여러 키를 처리하도록합니다.</target>
        </trans-unit>
        <trans-unit id="44319adff6c7cf60df65ef2f592ee1b07d9db575" translate="yes" xml:space="preserve">
          <source>Note that the format does not have any space, so &lt;a href=&quot;cluster-nodes&quot;&gt;CLUSTER NODES&lt;/a&gt; output format is plain CSV with space as separator even when this special slots are emitted. However a complete parser for the format should be able to handle them.</source>
          <target state="translated">형식에 공백이 없으므로 &lt;a href=&quot;cluster-nodes&quot;&gt;CLUSTER NODES&lt;/a&gt; 출력 형식은이 특수 슬롯이 방출 되더라도 공백으로 구분 기호가있는 일반 CSV입니다. 그러나 형식에 대한 완전한 파서는 형식을 처리 할 수 ​​있어야합니다.</target>
        </trans-unit>
        <trans-unit id="6cf3d39f27c1b799248d5e59a73b1a5b0f086afd" translate="yes" xml:space="preserve">
          <source>Note that the maximum offset that you can set is 2&lt;sup&gt;29&lt;/sup&gt; -1 (536870911), as Redis Strings are limited to 512 megabytes. If you need to grow beyond this size, you can use multiple keys.</source>
          <target state="translated">Redis 문자열이 512MB로 제한되므로 설정할 수있는 최대 오프셋은 2 &lt;sup&gt;29&lt;/sup&gt; -1 (536870911)입니다. 이 크기 이상으로 확장해야하는 경우 여러 키를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="365b9132d09f3318597589e9536ca42a38461cb4" translate="yes" xml:space="preserve">
          <source>Note that the message is claimed only if its idle time is greater the minimum idle time we specify when calling &lt;a href=&quot;xclaim&quot;&gt;XCLAIM&lt;/a&gt;. Because as a side effect &lt;a href=&quot;xclaim&quot;&gt;XCLAIM&lt;/a&gt; will also reset the idle time (since this is a new attempt at processing the message), two consumers trying to claim a message at the same time will never both succeed: only one will successfully claim the message. This avoids that we process a given message multiple times in a trivial way (yet multiple processing is possible and unavoidable in the general case).</source>
          <target state="translated">유휴 시간이 &lt;a href=&quot;xclaim&quot;&gt;XCLAIM&lt;/a&gt; 호출시 지정하는 최소 유휴 시간보다 큰 경우에만 메시지가 청구됩니다 . 부작용으로 &lt;a href=&quot;xclaim&quot;&gt;XCLAIM&lt;/a&gt; 은 유휴 시간도 재설정하기 때문에 (메시지를 처리하려는 새로운 시도이기 때문에) 동시에 메시지를 청구하려고하는 두 명의 소비자는 둘 다 성공하지 못합니다. 한 사람 만이 메시지를 성공적으로 청구합니다. 이것은 우리가 주어진 메시지를 사소한 방식으로 여러 번 처리하는 것을 피합니다 (그러나 일반적인 경우에는 다중 처리가 가능하고 피할 수 없습니다).</target>
        </trans-unit>
        <trans-unit id="581b6da11286a19b84f5dbf7d26c9c4e1e18433c" translate="yes" xml:space="preserve">
          <source>Note that this command is not suitable when you need a guaranteed uniform distribution of the returned elements. For more information about the algorithms used for SPOP, look up both the Knuth sampling and Floyd sampling algorithms.</source>
          <target state="translated">반환 된 요소의 균일 한 분포를 보장해야하는 경우이 명령이 적합하지 않습니다. SPOP에 사용되는 알고리즘에 대한 자세한 내용은 Knuth 샘플링 및 Floyd 샘플링 알고리즘을 모두 찾아보십시오.</target>
        </trans-unit>
        <trans-unit id="7aae41763fe9b0bc6731024cb063283c77ec4608" translate="yes" xml:space="preserve">
          <source>Note that this implementation of workers is trivially scalable and reliable, because even if a message is lost the item is still in the queue and will be processed at the next iteration.</source>
          <target state="translated">이러한 작업자 구현은 메시지가 손실 되더라도 항목이 여전히 대기열에 있고 다음 반복에서 처리되기 때문에 간단하고 확장 가능합니다.</target>
        </trans-unit>
        <trans-unit id="de6800f82ca82bf510c822b7935a67d6ca2bf21c" translate="yes" xml:space="preserve">
          <source>Note that we have a race here, but it is not a problem: &lt;a href=&quot;exists&quot;&gt;EXISTS&lt;/a&gt; may return false but the key may be created by another client before we create it inside the &lt;a href=&quot;multi&quot;&gt;MULTI&lt;/a&gt; / &lt;a href=&quot;exec&quot;&gt;EXEC&lt;/a&gt; block. However this race will just miss an API call under rare conditions, so the rate limiting will still work correctly.</source>
          <target state="translated">여기에는 경쟁이 있지만 문제는 아닙니다. &lt;a href=&quot;exists&quot;&gt;EXISTS&lt;/a&gt; 는 false를 반환 할 수 있지만 &lt;a href=&quot;multi&quot;&gt;MULTI&lt;/a&gt; / &lt;a href=&quot;exec&quot;&gt;EXEC&lt;/a&gt; 블록 내에 키를 만들기 전에 다른 클라이언트가 키를 만들 수 있습니다 . 그러나이 경쟁에서는 드문 조건에서 API 호출이 누락되므로 속도 제한이 여전히 올바르게 작동합니다.</target>
        </trans-unit>
        <trans-unit id="290162572eb7adbad822a4117dca945c127babde" translate="yes" xml:space="preserve">
          <source>Note that you need a recent version of redis-cli in order to read the slow log output, since it uses some features of the protocol that were not formerly implemented in redis-cli (deeply nested multi bulk replies).</source>
          <target state="translated">느린 로그 출력을 읽으려면 최신 버전의 redis-cli가 필요합니다. 이는 이전에 redis-cli에서 구현되지 않은 프로토콜의 일부 기능 (깊게 중첩 된 다중 벌크 응답)을 사용하기 때문입니다.</target>
        </trans-unit>
        <trans-unit id="285f98e8d01e4962eff6724b78a3c6724d0931e6" translate="yes" xml:space="preserve">
          <source>Note that:</source>
          <target state="translated">참고 :</target>
        </trans-unit>
        <trans-unit id="851be398fabf2219f9c3aa64609a72f0559cc785" translate="yes" xml:space="preserve">
          <source>Note the used of &lt;a href=&quot;multi&quot;&gt;MULTI&lt;/a&gt; and &lt;a href=&quot;exec&quot;&gt;EXEC&lt;/a&gt; in order to make sure that we'll both increment and set the expire at every API call.</source>
          <target state="translated">모든 API 호출에서 만료를 설정하고 증가시킬 수 있도록 &lt;a href=&quot;multi&quot;&gt;MULTI&lt;/a&gt; 및 &lt;a href=&quot;exec&quot;&gt;EXEC&lt;/a&gt; 사용에 유의 하십시오.</target>
        </trans-unit>
        <trans-unit id="0ab5850865b49bbe39f155ec6e364488933508f0" translate="yes" xml:space="preserve">
          <source>Note this rule is not enforced in order to provide the user with opportunities to abuse the Redis single instance configuration, at the cost of writing scripts not compatible with Redis Cluster.</source>
          <target state="translated">이 규칙은 Redis 클러스터와 호환되지 않는 스크립트를 작성하는 비용으로 사용자에게 Redis 단일 인스턴스 구성을 악용 할 수있는 기회를 제공하기 위해 시행되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="9dfbcfbbaf119bccc3c44b098de0573996677b97" translate="yes" xml:space="preserve">
          <source>Note: A Redis instance that is configured for not persisting on disk (no AOF configured, nor &quot;save&quot; directive) will not dump the RDB file on &lt;a href=&quot;shutdown&quot;&gt;SHUTDOWN&lt;/a&gt;, as usually you don't want Redis instances used only for caching to block on when shutting down.</source>
          <target state="translated">참고 : 디스크에 유지되지 않도록 구성된 Redis 인스턴스 (AOF 구성 없음 또는 &quot;save&quot;지시문 없음)는 &lt;a href=&quot;shutdown&quot;&gt;SHUTDOWN에&lt;/a&gt; RDB 파일을 덤프 하지 않습니다. 일반적으로 캐싱에만 사용되는 Redis 인스턴스가 차단 될 때 원하지 않습니다 종료.</target>
        </trans-unit>
        <trans-unit id="40e3fa9c72775db4fd05d5cf7a3a493e93afca05" translate="yes" xml:space="preserve">
          <source>Note: Since the &lt;a href=&quot;set&quot;&gt;SET&lt;/a&gt; command options can replace &lt;a href=&quot;setnx&quot;&gt;SETNX&lt;/a&gt;, &lt;a href=&quot;setex&quot;&gt;SETEX&lt;/a&gt;, &lt;a href=&quot;psetex&quot;&gt;PSETEX&lt;/a&gt;, it is possible that in future versions of Redis these three commands will be deprecated and finally removed.</source>
          <target state="translated">참고 : &lt;a href=&quot;set&quot;&gt;SET&lt;/a&gt; 명령 옵션은 &lt;a href=&quot;setnx&quot;&gt;SETNX&lt;/a&gt; , &lt;a href=&quot;setex&quot;&gt;SETEX&lt;/a&gt; , &lt;a href=&quot;psetex&quot;&gt;PSETEX를&lt;/a&gt; 대체 할 수 있으므로 이후 버전의 Redis에서는이 세 명령이 더 이상 사용되지 않고 제거 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3d6762a6aa2cf0aca37a59f773d7789ef284a403" translate="yes" xml:space="preserve">
          <source>Note: an important part of this behavior is that the PRNG that Redis implements as &lt;code&gt;math.random&lt;/code&gt; and &lt;code&gt;math.randomseed&lt;/code&gt; is guaranteed to have the same output regardless of the architecture of the system running Redis. 32-bit, 64-bit, big-endian and little-endian systems will all produce the same output.</source>
          <target state="translated">참고 :이 동작의 중요한 부분은 Redis가 &lt;code&gt;math.random&lt;/code&gt; 및 &lt;code&gt;math.randomseed&lt;/code&gt; 로 구현하는 PRNG가 Redis를 실행 하는 시스템의 아키텍처와 상관없이 동일한 출력을 보장한다는 것입니다. 32 비트, 64 비트, 빅 엔디안 및 리틀 엔디안 시스템은 모두 동일한 출력을 생성합니다.</target>
        </trans-unit>
        <trans-unit id="19d14832252be8ae1106f6c63fb642cd3e9e2df4" translate="yes" xml:space="preserve">
          <source>Note: as a side effect of calling this function, it is possible that the HyperLogLog is modified, since the last 8 bytes encode the latest computed cardinality for caching purposes. So &lt;a href=&quot;pfcount&quot;&gt;PFCOUNT&lt;/a&gt; is technically a write command.</source>
          <target state="translated">참고 :이 함수 호출의 부작용으로, 마지막 8 바이트가 캐싱 목적으로 최신 계산 된 카디널리티를 인코딩하므로 HyperLogLog가 수정 될 수 있습니다. 따라서 &lt;a href=&quot;pfcount&quot;&gt;PFCOUNT&lt;/a&gt; 는 기술적으로 쓰기 명령입니다.</target>
        </trans-unit>
        <trans-unit id="ca716680732d1d3e7b5dc5d38bf23aaa2688e964" translate="yes" xml:space="preserve">
          <source>Note: as you can see Lua arrays are returned as Redis multi bulk replies, that is a Redis return type that your client library will likely convert into an Array type in your programming language.</source>
          <target state="translated">참고 : Lua 배열은 Redis 다중 벌크 응답으로 반환되며 클라이언트 라이브러리가 프로그래밍 언어에서 배열 유형으로 변환 될 수있는 Redis 반환 유형입니다.</target>
        </trans-unit>
        <trans-unit id="a094e9a0339a167054eac3028e87a3e324531dab" translate="yes" xml:space="preserve">
          <source>Note: of course as usually it is not guaranteed that the error text remains the same, however the error code will remain &lt;code&gt;-UNBLOCKED&lt;/code&gt;.</source>
          <target state="translated">참고 : 물론 일반적으로 오류 텍스트가 동일하게 유지되는 &lt;code&gt;-UNBLOCKED&lt;/code&gt; 오류 코드는 -UNBLOCKED로 유지 됩니다 .</target>
        </trans-unit>
        <trans-unit id="3ba013a44d25a035abd0e8ad87d8b610e34b72b2" translate="yes" xml:space="preserve">
          <source>Note: the command has a complexity of just O(log(N)) because it uses elements ranks (see &lt;a href=&quot;zrank&quot;&gt;ZRANK&lt;/a&gt;) to get an idea of the range. Because of this there is no need to do a work proportional to the size of the range.</source>
          <target state="translated">참고 :이 명령은 요소 순위 ( &lt;a href=&quot;zrank&quot;&gt;ZRANK&lt;/a&gt; 참조 )를 사용하여 범위에 대한 아이디어를 얻으 므로 O (log (N))의 복잡성을 갖습니다 . 이 때문에 범위의 크기에 비례하는 작업을 수행 할 필요가 없습니다.</target>
        </trans-unit>
        <trans-unit id="a4cf334aa22d4d43d68ebc7afbb42dd9e08a0e09" translate="yes" xml:space="preserve">
          <source>Note: we use the &lt;strong&gt;COUNT&lt;/strong&gt; option in the example, so that for each stream the call will return at maximum two elements per stream.</source>
          <target state="translated">참고 : 이 예에서는 &lt;strong&gt;COUNT&lt;/strong&gt; 옵션을 사용 하므로 각 스트림마다 호출이 스트림 당 최대 2 개의 요소를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="70440046a3dc2e079f23ee1c57dfa76669b732aa" translate="yes" xml:space="preserve">
          <source>Notes</source>
          <target state="translated">Notes</target>
        </trans-unit>
        <trans-unit id="5a4574a1a3d9728a0a89d6b1668d9c8dc4ec0634" translate="yes" xml:space="preserve">
          <source>Notes on published config epochs</source>
          <target state="translated">게시 된 구성 에포크에 대한 참고 사항</target>
        </trans-unit>
        <trans-unit id="9c3befe7e22c8667bc957541f49b0ee79970b588" translate="yes" xml:space="preserve">
          <source>Notes:</source>
          <target state="translated">Notes:</target>
        </trans-unit>
        <trans-unit id="20be3b7a30a9bb9f7caa52a82e339d86765a7b3b" translate="yes" xml:space="preserve">
          <source>Number of commands processed</source>
          <target state="translated">처리 된 명령 수</target>
        </trans-unit>
        <trans-unit id="6567d67fead3b983bf0dd26e46b199bad4736caf" translate="yes" xml:space="preserve">
          <source>Number of connections received</source>
          <target state="translated">수신 된 연결 수</target>
        </trans-unit>
        <trans-unit id="c0e73dd590dc420faea4c4ac9906ba30e0259e37" translate="yes" xml:space="preserve">
          <source>Number of elements returned at every SCAN call</source>
          <target state="translated">모든 SCAN 호출에서 반환되는 요소 수</target>
        </trans-unit>
        <trans-unit id="f4702f3357a94e0b51c79789087a3eb454b1e296" translate="yes" xml:space="preserve">
          <source>Number of expired keys</source>
          <target state="translated">만료 된 키 수</target>
        </trans-unit>
        <trans-unit id="8e0e833a8bbaf63a540fadb74be8461319161578" translate="yes" xml:space="preserve">
          <source>Number of rejected connections</source>
          <target state="translated">거부 된 연결 수</target>
        </trans-unit>
        <trans-unit id="828f2a22520c1086f191a7adfcf910b96f4fe93b" translate="yes" xml:space="preserve">
          <source>OBJECT</source>
          <target state="translated">OBJECT</target>
        </trans-unit>
        <trans-unit id="9d8ec388e13faad9823f64e9acce4e1451d4eabf" translate="yes" xml:space="preserve">
          <source>OBJECT  subcommand [arguments [arguments ...]]   Inspect the internals of Redis objects</source>
          <target state="translated">OBJECT 하위 명령 [arguments [arguments ...]] Redis 객체의 내부 검사</target>
        </trans-unit>
        <trans-unit id="77ba3ba2dc482ece5e336da9db6f45f553748e64" translate="yes" xml:space="preserve">
          <source>Objects can be encoded in different ways:</source>
          <target state="translated">객체는 다른 방식으로 인코딩 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="179e9e8b9188e3e0f2e120735c4089249f586f43" translate="yes" xml:space="preserve">
          <source>Obtaining the current length of the slow log</source>
          <target state="translated">느린 로그의 현재 길이 얻기</target>
        </trans-unit>
        <trans-unit id="5f6babf24c9404230c05a01781cf0ff83f2a099c" translate="yes" xml:space="preserve">
          <source>Of course it is also possible to use any other valid ID. If the specified consumer group already exists, the command returns a &lt;code&gt;-BUSYGROUP&lt;/code&gt; error. Otherwise the operation is performed and OK is returned. There are no hard limits to the number of consumer groups you can associate to a given stream.</source>
          <target state="translated">물론 다른 유효한 ID를 사용하는 것도 가능합니다. 지정된 이용자 그룹이 이미 존재하면 명령은 &lt;code&gt;-BUSYGROUP&lt;/code&gt; 오류를 리턴합니다 . 그렇지 않으면 작업이 수행되고 OK가 반환됩니다. 주어진 스트림에 연결할 수있는 소비자 그룹 수에는 제한이 없습니다.</target>
        </trans-unit>
        <trans-unit id="ff1bb1ff7a105fafca313a10f02e72dc891fbcf4" translate="yes" xml:space="preserve">
          <source>Of course this is not enough as there are expired keys that will never be accessed again. These keys should be expired anyway, so periodically Redis tests a few keys at random among keys with an expire set. All the keys that are already expired are deleted from the keyspace.</source>
          <target state="translated">물론 이것은 다시 액세스 할 수없는 만료 된 키가 있으므로 충분하지 않습니다. 이 키는 어쨌든 만료되어야하므로 정기적으로 Redis는 만료가 설정된 키 중에서 무작위로 몇 개의 키를 테스트합니다. 이미 만료 된 모든 키가 키 공간에서 삭제됩니다.</target>
        </trans-unit>
        <trans-unit id="e1291438828df902dd44c789d43575a9bce5c968" translate="yes" xml:space="preserve">
          <source>On the other hand, defining commands using a special command or via &lt;code&gt;redis.conf&lt;/code&gt; would be a problem for a few reasons:</source>
          <target state="translated">반면 특수 명령을 사용하거나 &lt;code&gt;redis.conf&lt;/code&gt; 를 통해 명령을 정의하는 것은 몇 가지 이유로 문제가 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9bcf11babeeb88215faca3f25a089c7e21ce30f5" translate="yes" xml:space="preserve">
          <source>Once a consumer &lt;em&gt;succesfully&lt;/em&gt; processes a message, it should call &lt;a href=&quot;xack&quot;&gt;XACK&lt;/a&gt; so that such message does not get processed again, and as a side effect, the PEL entry about this message is also purged, releasing memory from the Redis server.</source>
          <target state="translated">소비자 가 메시지를 &lt;em&gt;성공적으로&lt;/em&gt; 처리하면 &lt;a href=&quot;xack&quot;&gt;XACK&lt;/a&gt; 를 호출 하여 해당 메시지가 다시 처리되지 않도록하고 부작용으로이 메시지에 대한 PEL 항목도 제거되어 Redis 서버에서 메모리가 해제됩니다.</target>
        </trans-unit>
        <trans-unit id="452b455cbf1a2a31d7d4b5005050bf4551fb3def" translate="yes" xml:space="preserve">
          <source>Once a node is turned into the replica of another master node, there is no need to inform the other cluster nodes about the change: heartbeat packets exchanged between nodes will propagate the new configuration automatically.</source>
          <target state="translated">노드가 다른 마스터 노드의 복제본으로 바뀌면 다른 클러스터 노드에 변경 사항을 알리지 않아도됩니다. 노드간에 교환 된 하트 비트 패킷은 새 구성을 자동으로 전파합니다.</target>
        </trans-unit>
        <trans-unit id="24b95a3638ec064976a3c5a5f6794040d2c4ed0b" translate="yes" xml:space="preserve">
          <source>Once new data is present on one of the lists, the client returns with the name of the key unblocking it and the popped value.</source>
          <target state="translated">목록 중 하나에 새 데이터가 있으면 클라이언트는 키를 차단 해제 한 키 이름과 팝된 값을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="dd41998567cd1f4f810cbadee2b74617b57a32fa" translate="yes" xml:space="preserve">
          <source>Once the client enters the subscribed state it is not supposed to issue any other commands, except for additional &lt;a href=&quot;subscribe&quot;&gt;SUBSCRIBE&lt;/a&gt;, &lt;a href=&quot;psubscribe&quot;&gt;PSUBSCRIBE&lt;/a&gt;, &lt;a href=&quot;unsubscribe&quot;&gt;UNSUBSCRIBE&lt;/a&gt; and &lt;a href=&quot;punsubscribe&quot;&gt;PUNSUBSCRIBE&lt;/a&gt; commands.</source>
          <target state="translated">클라이언트가 가입 된 상태가되면 추가 &lt;a href=&quot;subscribe&quot;&gt;SUBSCRIBE&lt;/a&gt; , &lt;a href=&quot;psubscribe&quot;&gt;PSUBSCRIBE&lt;/a&gt; , &lt;a href=&quot;unsubscribe&quot;&gt;UNSUBSCRIBE&lt;/a&gt; 및 &lt;a href=&quot;punsubscribe&quot;&gt;PUNSUBSCRIBE&lt;/a&gt; 명령을 제외한 다른 명령을 실행하지 않아야 합니다.</target>
        </trans-unit>
        <trans-unit id="c4b215656d61ce9a1a4991539bbd4f84ece9f512" translate="yes" xml:space="preserve">
          <source>Once we get some replies, the next call will be something like:</source>
          <target state="translated">답변을 받으면 다음 전화는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="9de09a5350a4d4653c094b67b0dba8689a762e24" translate="yes" xml:space="preserve">
          <source>One client connection per line (separated by LF)</source>
          <target state="translated">회선 당 하나의 클라이언트 연결 (LF로 구분)</target>
        </trans-unit>
        <trans-unit id="81d95091e8731132a88b7f9f02a3169be5e6b187" translate="yes" xml:space="preserve">
          <source>One of the guarantees of consumer groups is that a given consumer can only see the history of messages that were delivered to it, so a message has just a single owner. However there is a special feature called &lt;em&gt;message claiming&lt;/em&gt; that allows other consumers to claim messages in case there is a non recoverable failure of some consumer. In order to implement such semantics, consumer groups require explicit acknowledgement of the messages successfully processed by the consumer, via the &lt;a href=&quot;xack&quot;&gt;XACK&lt;/a&gt; command. This is needed because the stream will track, for each consumer group, who is processing what message.</source>
          <target state="translated">소비자 그룹의 보장 중 하나는 지정된 소비자가 자신에게 배달 된 메시지의 기록 만 볼 수 있으므로 메시지에는 단일 소유자 만 있다는 것입니다. 그러나 일부 소비자가 복구 할 수없는 장애가있는 경우 다른 소비자가 &lt;em&gt;메시지를 청구&lt;/em&gt; 할 수 있도록하는 &lt;em&gt;메시지 청구&lt;/em&gt; 라는 특수 기능 이 있습니다. 이러한 의미를 구현하기 위해 소비자 그룹은 &lt;a href=&quot;xack&quot;&gt;XACK&lt;/a&gt; 명령을 통해 소비자가 성공적으로 처리 한 메시지를 명시 적으로 승인해야합니다 . 스트림은 각 메시지 그룹에서 어떤 메시지를 처리 ​​중인지 추적하기 때문에 필요합니다.</target>
        </trans-unit>
        <trans-unit id="6bf5da9c080bee3a8142586c412aa39971137eee" translate="yes" xml:space="preserve">
          <source>Options</source>
          <target state="translated">Options</target>
        </trans-unit>
        <trans-unit id="daa479a36fbba3ff638d59ae19308e8976bd5ac3" translate="yes" xml:space="preserve">
          <source>Orders of bits</source>
          <target state="translated">비트 순서</target>
        </trans-unit>
        <trans-unit id="dcfd7c36726b3d9723cbd1a8981b89247967a629" translate="yes" xml:space="preserve">
          <source>Other consumers may inspect the list of pending messages, that are stale for quite some time, using the &lt;a href=&quot;xpending&quot;&gt;XPENDING&lt;/a&gt; command. In order to continue processing such messages, they use &lt;a href=&quot;xclaim&quot;&gt;XCLAIM&lt;/a&gt; to acquire the ownership of the message and continue.</source>
          <target state="translated">다른 소비자는 &lt;a href=&quot;xpending&quot;&gt;XPENDING&lt;/a&gt; 명령을 사용하여 보류 된 메시지 목록을 검사 할 수 있습니다 . 이러한 메시지를 계속 처리하기 위해 &lt;a href=&quot;xclaim&quot;&gt;XCLAIM&lt;/a&gt; 을 사용 하여 메시지의 소유권을 획득하고 계속합니다.</target>
        </trans-unit>
        <trans-unit id="3c2a27c636dc79870e309393531406e960ec4e18" translate="yes" xml:space="preserve">
          <source>Our previous example returns just the sorted IDs. In some cases, it is more useful to get the actual objects instead of their IDs (&lt;code&gt;object_1&lt;/code&gt;, &lt;code&gt;object_2&lt;/code&gt; and &lt;code&gt;object_3&lt;/code&gt;). Retrieving external keys based on the elements in a list, set or sorted set can be done with the following command:</source>
          <target state="translated">이전 예는 정렬 된 ID 만 반환합니다. 경우에 따라 ID 대신 실제 객체 ( &lt;code&gt;object_1&lt;/code&gt; , &lt;code&gt;object_2&lt;/code&gt; 및 &lt;code&gt;object_3&lt;/code&gt; ) 를 얻는 것이 더 유용합니다 . 목록, 세트 또는 정렬 세트의 요소를 기반으로 외부 키 검색은 다음 명령으로 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e9c8427bc7498ec3380d38f116037bdd3bcddf6e" translate="yes" xml:space="preserve">
          <source>Out of range indexes will not produce an error. If &lt;code&gt;start&lt;/code&gt; is larger than the end of the list, an empty list is returned. If &lt;code&gt;stop&lt;/code&gt; is larger than the actual end of the list, Redis will treat it like the last element of the list.</source>
          <target state="translated">범위를 벗어난 인덱스는 오류를 생성하지 않습니다. 경우 &lt;code&gt;start&lt;/code&gt; 리스트의 말미보다 큰, 빈 목록이 반환됩니다. 경우 &lt;code&gt;stop&lt;/code&gt; 목록의 실제 끝보다 큰, 레디 스리스트의 마지막 요소처럼 취급합니다.</target>
        </trans-unit>
        <trans-unit id="c0a3cb19e89ec7bd7c87e53355299d0f62cc91cc" translate="yes" xml:space="preserve">
          <source>Out of range indexes will not produce an error. If &lt;code&gt;start&lt;/code&gt; is larger than the largest index in the sorted set, or &lt;code&gt;start &amp;gt;
stop&lt;/code&gt;, an empty list is returned. If &lt;code&gt;stop&lt;/code&gt; is larger than the end of the sorted set Redis will treat it like it is the last element of the sorted set.</source>
          <target state="translated">범위를 벗어난 인덱스는 오류를 생성하지 않습니다. 경우 &lt;code&gt;start&lt;/code&gt; 가장 큰 정렬 된 세트의 인덱스, 또는보다 큰 &lt;code&gt;start &amp;gt; stop&lt;/code&gt; , 빈 목록이 반환됩니다. 경우 &lt;code&gt;stop&lt;/code&gt; 정렬 된 세트의 끝보다 큰는 소트 세트의 마지막 요소처럼 레디 스 그것을 처리합니다.</target>
        </trans-unit>
        <trans-unit id="3dc054b880cd4ad0a83857995e10c362ec4b2504" translate="yes" xml:space="preserve">
          <source>Out of range indexes will not produce an error: if &lt;code&gt;start&lt;/code&gt; is larger than the end of the list, or &lt;code&gt;start &amp;gt; end&lt;/code&gt;, the result will be an empty list (which causes &lt;code&gt;key&lt;/code&gt; to be removed). If &lt;code&gt;end&lt;/code&gt; is larger than the end of the list, Redis will treat it like the last element of the list.</source>
          <target state="translated">범위를 벗어난 인덱스는 오류를 생성하지 않습니다. &lt;code&gt;start&lt;/code&gt; 가 목록의 끝보다 크거나 &lt;code&gt;start &amp;gt; end&lt;/code&gt; 인 경우 결과는 빈 목록이되어 &lt;code&gt;key&lt;/code&gt; 가 제거됩니다. 경우 &lt;code&gt;end&lt;/code&gt; 리스트의 말미보다 큰, 레디 스리스트의 마지막 요소처럼 취급합니다.</target>
        </trans-unit>
        <trans-unit id="c4e6b6c77c67abd27de260eb5ce674860a95ad42" translate="yes" xml:space="preserve">
          <source>Out-of-range indexes</source>
          <target state="translated">범위를 벗어난 인덱스</target>
        </trans-unit>
        <trans-unit id="c03f08a8f205e4568e916e3cfaa50c6a48749706" translate="yes" xml:space="preserve">
          <source>Output format</source>
          <target state="translated">출력 형식</target>
        </trans-unit>
        <trans-unit id="275395efd6e79fdbe55cb36a4ebb4892dbdd5c40" translate="yes" xml:space="preserve">
          <source>Output of the command on replicas</source>
          <target state="translated">복제본에 대한 명령 출력</target>
        </trans-unit>
        <trans-unit id="5ea9a43450142f5e1cfd51ca7b6956f8a9dbb82d" translate="yes" xml:space="preserve">
          <source>Overflow control</source>
          <target state="translated">오버 플로우 제어</target>
        </trans-unit>
        <trans-unit id="36fd64a953472994b938bbb13337305e87d9a9eb" translate="yes" xml:space="preserve">
          <source>Overwrites part of the string stored at &lt;em&gt;key&lt;/em&gt;, starting at the specified offset, for the entire length of &lt;em&gt;value&lt;/em&gt;. If the offset is larger than the current length of the string at &lt;em&gt;key&lt;/em&gt;, the string is padded with zero-bytes to make &lt;em&gt;offset&lt;/em&gt; fit. Non-existing keys are considered as empty strings, so this command will make sure it holds a string large enough to be able to set &lt;em&gt;value&lt;/em&gt; at &lt;em&gt;offset&lt;/em&gt;.</source>
          <target state="translated">&lt;em&gt;value&lt;/em&gt; 의 전체 길이에 대해 지정된 오프셋에서 시작 하여 &lt;em&gt;key에&lt;/em&gt; 저장된 문자열의 일부를 덮어 씁니다 . 오프셋이 &lt;em&gt;key&lt;/em&gt; 에서 문자열의 현재 길이보다 큰 경우 &lt;em&gt;오프셋에&lt;/em&gt; 맞도록 문자열에 0 바이트가 채워집니다 . 존재하지 않는 키는 빈 문자열로 간주되므로이 명령은 &lt;em&gt;오프셋&lt;/em&gt; 에서 &lt;em&gt;값&lt;/em&gt; 을 설정할 수있을 정도로 큰 문자열을 보유하도록합니다 .&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="34512fba1d256a361565532a3535096429399084" translate="yes" xml:space="preserve">
          <source>PERSIST</source>
          <target state="translated">PERSIST</target>
        </trans-unit>
        <trans-unit id="ae51373f050f6d2b0e0edfdd08e69fc1968bdf20" translate="yes" xml:space="preserve">
          <source>PERSIST  key   Remove the expiration from a key</source>
          <target state="translated">PERSIST 키 키에서 만료를 제거합니다</target>
        </trans-unit>
        <trans-unit id="7fa59fa06dcb2c9dc1b2b2bd46df7f33912c57b3" translate="yes" xml:space="preserve">
          <source>PEXPIRE</source>
          <target state="translated">PEXPIRE</target>
        </trans-unit>
        <trans-unit id="77a946764b4ffdf95c5ae217ca7f9cec5340bdc1" translate="yes" xml:space="preserve">
          <source>PEXPIRE  key milliseconds   Set a key's time to live in milliseconds</source>
          <target state="translated">PEXPIRE 키 밀리 초 키 시간을 밀리 초 단위로 설정</target>
        </trans-unit>
        <trans-unit id="e609e3af460df9737d7d964f8bfec75a3773bde7" translate="yes" xml:space="preserve">
          <source>PEXPIREAT</source>
          <target state="translated">PEXPIREAT</target>
        </trans-unit>
        <trans-unit id="12d0e8f2d7d7718d124f2a5d583dfa8315ee3c0c" translate="yes" xml:space="preserve">
          <source>PEXPIREAT  key milliseconds-timestamp   Set the expiration for a key as a UNIX timestamp specified in milliseconds</source>
          <target state="translated">PEXPIREAT 키 밀리 초 타임 스탬프 키 만료를 밀리 초 단위로 지정된 UNIX 타임 스탬프로 설정</target>
        </trans-unit>
        <trans-unit id="fc7a17907dc63d1312607f17460e9eb6e7871f9d" translate="yes" xml:space="preserve">
          <source>PFADD</source>
          <target state="translated">PFADD</target>
        </trans-unit>
        <trans-unit id="e4e9e83ebacf78fb8cf3124d42502528b53d06ca" translate="yes" xml:space="preserve">
          <source>PFADD  key element [element ...]   Adds the specified elements to the specified HyperLogLog.</source>
          <target state="translated">PFADD 키 요소 [element ...] 지정된 요소를 지정된 HyperLogLog에 추가합니다.</target>
        </trans-unit>
        <trans-unit id="274e92a9d4138573a0f107d2e57b9d0b46e7ac01" translate="yes" xml:space="preserve">
          <source>PFCOUNT</source>
          <target state="translated">PFCOUNT</target>
        </trans-unit>
        <trans-unit id="f81913b01d976cbaac4ade6c06f6bf299ee86214" translate="yes" xml:space="preserve">
          <source>PFCOUNT  key [key ...]   Return the approximated cardinality of the set(s) observed by the HyperLogLog at key(s).</source>
          <target state="translated">PFCOUNT 키 [키 ...] 키에서 HyperLogLog가 관찰 한 세트의 대략적인 카디널리티를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="62f6ef6fa6924abe295c8c766f2b3e89d6d074fc" translate="yes" xml:space="preserve">
          <source>PFMERGE</source>
          <target state="translated">PFMERGE</target>
        </trans-unit>
        <trans-unit id="2ad005659587e94338ccd67e31dbc3fac2cb1536" translate="yes" xml:space="preserve">
          <source>PFMERGE  destkey sourcekey [sourcekey ...]   Merge N different HyperLogLogs into a single one.</source>
          <target state="translated">PFMERGE destkey sourcekey [sourcekey ...] N 개의 서로 다른 HyperLogLog를 하나로 통합합니다.</target>
        </trans-unit>
        <trans-unit id="0b1786a083a9087f0db36b08c1ff81a58930fbc2" translate="yes" xml:space="preserve">
          <source>PING</source>
          <target state="translated">PING</target>
        </trans-unit>
        <trans-unit id="45dae0d4784e1c9ea33d8d88f448f7989ea29500" translate="yes" xml:space="preserve">
          <source>PING  [message]   Ping the server</source>
          <target state="translated">PING [메시지] 서버 Ping</target>
        </trans-unit>
        <trans-unit id="81efb783fc237efd685a1393fa9f947dd8abda5a" translate="yes" xml:space="preserve">
          <source>PSETEX</source>
          <target state="translated">PSETEX</target>
        </trans-unit>
        <trans-unit id="d7c40d1ee18ffeabe6099f89603c950454eb0276" translate="yes" xml:space="preserve">
          <source>PSETEX  key milliseconds value   Set the value and expiration in milliseconds of a key</source>
          <target state="translated">PSETEX 키 밀리 초 값 키의 값과 만료 시간을 밀리 초 단위로 설정합니다</target>
        </trans-unit>
        <trans-unit id="9e7e79c8d02bde08c4e705066bd533ffa7218538" translate="yes" xml:space="preserve">
          <source>PSUBSCRIBE</source>
          <target state="translated">PSUBSCRIBE</target>
        </trans-unit>
        <trans-unit id="71ae64e5df443252e78a1d1f929289a8311a1ef4" translate="yes" xml:space="preserve">
          <source>PSUBSCRIBE  pattern [pattern ...]   Listen for messages published to channels matching the given patterns</source>
          <target state="translated">PSUBSCRIBE pattern [pattern ...] 주어진 패턴과 일치하는 채널에 발행 된 메시지를 청취</target>
        </trans-unit>
        <trans-unit id="7b8bdca458042e425d2902f59f800419aed5c8b1" translate="yes" xml:space="preserve">
          <source>PTTL</source>
          <target state="translated">PTTL</target>
        </trans-unit>
        <trans-unit id="05bf8ee07e7053cfaf8f62c038f0255fadf89afe" translate="yes" xml:space="preserve">
          <source>PTTL  key   Get the time to live for a key in milliseconds</source>
          <target state="translated">PTTL 키 밀리 초 단위로 키의 수명을 확보하십시오</target>
        </trans-unit>
        <trans-unit id="ff0fc30c743813f924dff4b751315af42d5ab08b" translate="yes" xml:space="preserve">
          <source>PUBLISH</source>
          <target state="translated">PUBLISH</target>
        </trans-unit>
        <trans-unit id="46e845a027f7bb36580703fc200d9108559fa747" translate="yes" xml:space="preserve">
          <source>PUBLISH  channel message   Post a message to a channel</source>
          <target state="translated">PUBLISH 채널 메시지 채널에 메시지 게시</target>
        </trans-unit>
        <trans-unit id="9487f50e961af3141e0c7833372d9b2c28cfa2a4" translate="yes" xml:space="preserve">
          <source>PUBSUB</source>
          <target state="translated">PUBSUB</target>
        </trans-unit>
        <trans-unit id="acad4a3c05b50f5f04a99427d2a3cdbb983fb0b9" translate="yes" xml:space="preserve">
          <source>PUBSUB  subcommand [argument [argument ...]]   Inspect the state of the Pub/Sub subsystem</source>
          <target state="translated">PUBSUB 부속 명령 [argument [argument ...]] Pub / Sub 서브 시스템의 상태 점검</target>
        </trans-unit>
        <trans-unit id="ca024e3f958c6b7f4c7fa3671697866707cfa352" translate="yes" xml:space="preserve">
          <source>PUBSUB CHANNELS [pattern]</source>
          <target state="translated">PUBSUB 채널 [패턴]</target>
        </trans-unit>
        <trans-unit id="56e20f63e75d465369356d3ab7aa54f42d22cbb4" translate="yes" xml:space="preserve">
          <source>PUNSUBSCRIBE</source>
          <target state="translated">PUNSUBSCRIBE</target>
        </trans-unit>
        <trans-unit id="e54d89cca768ad85f7527ac0169fa1af2910b1cf" translate="yes" xml:space="preserve">
          <source>PUNSUBSCRIBE  [pattern [pattern ...]]   Stop listening for messages posted to channels matching the given patterns</source>
          <target state="translated">PUNSUBSCRIBE [pattern [pattern ...]] 주어진 패턴과 일치하는 채널에 게시 된 메시지 청취를 중지합니다</target>
        </trans-unit>
        <trans-unit id="df3251b7546bede28dd0b0e82a26302f58157038" translate="yes" xml:space="preserve">
          <source>Passing keys and arguments as additional &lt;a href=&quot;eval&quot;&gt;EVAL&lt;/a&gt; arguments is also very useful in this context as the script string remains constant and can be efficiently cached by Redis.</source>
          <target state="translated">스크립트 문자열이 일정하게 유지되고 Redis가 효율적으로 캐시 할 수 있으므로 키와 인수를 추가 &lt;a href=&quot;eval&quot;&gt;EVAL&lt;/a&gt; 인수로 전달하는 것도이 컨텍스트에서 매우 유용합니다.</target>
        </trans-unit>
        <trans-unit id="19999dd613b36fb0786e599a84893b1e8a156a95" translate="yes" xml:space="preserve">
          <source>Pattern: Circular list</source>
          <target state="translated">패턴 : 원형 목록</target>
        </trans-unit>
        <trans-unit id="4d81f3aa2a2c95fc4a2b98f51dce59a3bb00d586" translate="yes" xml:space="preserve">
          <source>Pattern: Counter</source>
          <target state="translated">패턴 : 카운터</target>
        </trans-unit>
        <trans-unit id="73ea3bc6eae64663018b769f7c415b912584ee38" translate="yes" xml:space="preserve">
          <source>Pattern: Event notification</source>
          <target state="translated">패턴 : 이벤트 알림</target>
        </trans-unit>
        <trans-unit id="9ff13cc43cfbf608a403dd95aced2e1c0f9fa96b" translate="yes" xml:space="preserve">
          <source>Pattern: Navigation session</source>
          <target state="translated">패턴 : 탐색 세션</target>
        </trans-unit>
        <trans-unit id="a7fd682d147cfd39262ca78719007b5177407a15" translate="yes" xml:space="preserve">
          <source>Pattern: Rate limiter</source>
          <target state="translated">패턴 : 속도 제한 기</target>
        </trans-unit>
        <trans-unit id="527a190ff3f82d3d4bdfebea8586b0d301a67e3d" translate="yes" xml:space="preserve">
          <source>Pattern: Rate limiter 1</source>
          <target state="translated">패턴 : 속도 제한 기 1</target>
        </trans-unit>
        <trans-unit id="d037a3f2c416c91b7789e304c06bd5786301383d" translate="yes" xml:space="preserve">
          <source>Pattern: Rate limiter 2</source>
          <target state="translated">패턴 : 속도 제한 기 2</target>
        </trans-unit>
        <trans-unit id="18e48daae4954154a5de8c81ecf51283e080aacd" translate="yes" xml:space="preserve">
          <source>Pattern: Reliable queue</source>
          <target state="translated">패턴 : 안정적인 대기열</target>
        </trans-unit>
        <trans-unit id="bc4ebd36f01622a36d608ba3197fe5c6b53d07d7" translate="yes" xml:space="preserve">
          <source>Pattern: Time series</source>
          <target state="translated">패턴 : 시계열</target>
        </trans-unit>
        <trans-unit id="6aa9774204b5b0358a99c12a75b97dace59e135d" translate="yes" xml:space="preserve">
          <source>Pattern: real time metrics using bitmaps</source>
          <target state="translated">패턴 : 비트 맵을 사용한 실시간 메트릭</target>
        </trans-unit>
        <trans-unit id="387aa2d6e23537ab60fac1801379d3a3550c02d6" translate="yes" xml:space="preserve">
          <source>Pattern: real-time metrics using bitmaps</source>
          <target state="translated">패턴 : 비트 맵을 사용한 실시간 메트릭</target>
        </trans-unit>
        <trans-unit id="d8f113cb1df36820baa76cc50b4089ad6af9aea4" translate="yes" xml:space="preserve">
          <source>Pattern: weighted random selection of an element</source>
          <target state="translated">패턴 : 요소의 가중치 무작위 선택</target>
        </trans-unit>
        <trans-unit id="4d34f7a2b0b3b6df62a051917d7e7ac2de8a38df" translate="yes" xml:space="preserve">
          <source>Patterns</source>
          <target state="translated">Patterns</target>
        </trans-unit>
        <trans-unit id="65bb2cda328eeb96caf6c6dce99ad10ccece742e" translate="yes" xml:space="preserve">
          <source>Pause the clients using &lt;a href=&quot;client-pause&quot;&gt;CLIENT PAUSE&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;client-pause&quot;&gt;CLIENT PAUSE를&lt;/a&gt; 사용하여 클라이언트 일시 중지</target>
        </trans-unit>
        <trans-unit id="172162ae29287e5e829be8811d680119905ff86b" translate="yes" xml:space="preserve">
          <source>Perform a bitwise operation between multiple keys (containing string values) and store the result in the destination key.</source>
          <target state="translated">여러 키 (문자열 값 포함)간에 비트 단위 연산을 수행하고 결과를 대상 키에 저장하십시오.</target>
        </trans-unit>
        <trans-unit id="1627d1d0d50fdeb9a3dce196f5de79d8f43842c0" translate="yes" xml:space="preserve">
          <source>Perform a blocking SAVE if at least one &lt;strong&gt;save point&lt;/strong&gt; is configured.</source>
          <target state="translated">하나 이상의 &lt;strong&gt;저장 점이&lt;/strong&gt; 구성된 경우 차단 저장을 수행하십시오 .</target>
        </trans-unit>
        <trans-unit id="c05e233359dba5b59b70fc0039c9fb4fdb4976d0" translate="yes" xml:space="preserve">
          <source>Perform a partial resynchronization after a disconnection.</source>
          <target state="translated">연결 해제 후 부분 재 동기화를 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="9d05c962f81bccc17939e7dff46bacb302dd37a2" translate="yes" xml:space="preserve">
          <source>Perform the SHA1 of the input string.</source>
          <target state="translated">입력 문자열의 SHA1을 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="0cb883fc85b1fd84aaebb7319c682c586a065641" translate="yes" xml:space="preserve">
          <source>Performance considerations</source>
          <target state="translated">성능 고려 사항</target>
        </trans-unit>
        <trans-unit id="c5453c00c8e4c4429dffd7c57ff9e409df17e57a" translate="yes" xml:space="preserve">
          <source>Performances</source>
          <target state="translated">Performances</target>
        </trans-unit>
        <trans-unit id="98a191010a72a819b496571f1515f19fc5db230c" translate="yes" xml:space="preserve">
          <source>Please check the example below and the &lt;a href=&quot;georadius&quot;&gt;GEORADIUS&lt;/a&gt; documentation for more information about the command and its options.</source>
          <target state="translated">명령 및 옵션에 대한 자세한 내용은 아래 예와 &lt;a href=&quot;georadius&quot;&gt;GEORADIUS&lt;/a&gt; 설명서를 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="2adb7fe266cd87cc96a429b9dce43b2d62d33470" translate="yes" xml:space="preserve">
          <source>Please for the specific semantics of the command refer to the documentation of &lt;a href=&quot;expire&quot;&gt;EXPIRE&lt;/a&gt;.</source>
          <target state="translated">명령의 특정 의미에 대해서는 &lt;a href=&quot;expire&quot;&gt;EXPIRE&lt;/a&gt; 문서를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="d37ebc2f4f2d1c9e1508f49167dd6105a3aa57b4" translate="yes" xml:space="preserve">
          <source>Please note depending on the version of Redis some of the fields have been added or removed. A robust client application should therefore parse the result of this command by skipping unknown properties, and gracefully handle missing fields.</source>
          <target state="translated">Redis 버전에 따라 일부 필드가 추가 또는 제거되었습니다. 따라서 강력한 클라이언트 응용 프로그램은 알 수없는 속성을 건너 뛰어이 명령의 결과를 구문 분석하고 누락 된 필드를 정상적으로 처리해야합니다.</target>
        </trans-unit>
        <trans-unit id="cf36c5202e34a4a67ab38d9f9bd7222bda763dfd" translate="yes" xml:space="preserve">
          <source>Please note that before reading this page, if you are new to streams, we recommend to read &lt;a href=&quot;https://redis.io/topics/streams-intro&quot;&gt;our introduction to Redis Streams&lt;/a&gt;.</source>
          <target state="translated">이 페이지를 읽기 전에 스트림을 &lt;a href=&quot;https://redis.io/topics/streams-intro&quot;&gt;처음 사용하는 경우 Redis Streams 소개를&lt;/a&gt; 읽는 것이 좋습니다 .</target>
        </trans-unit>
        <trans-unit id="95e0253f33057b2f70a061e11de2d3d4a685d9c7" translate="yes" xml:space="preserve">
          <source>Please refer to the &lt;a href=&quot;eval&quot;&gt;EVAL&lt;/a&gt; documentation for detailed information about Redis Lua scripting.</source>
          <target state="translated">를 참조하십시오 &lt;a href=&quot;eval&quot;&gt;EVAL의&lt;/a&gt; 레디 스 루아 스크립트에 대한 자세한 내용은 설명서를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="67fc81a1bc0292fa12fdf63856d1ae3a69b0523a" translate="yes" xml:space="preserve">
          <source>Please refer to the &lt;a href=&quot;https://redis.io/topics/persistence&quot;&gt;persistence documentation&lt;/a&gt; for detailed information.</source>
          <target state="translated">자세한 내용은 &lt;a href=&quot;https://redis.io/topics/persistence&quot;&gt;지속성 설명서&lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="7a135ffdb71c43178f876e40f960bf45f1a29237" translate="yes" xml:space="preserve">
          <source>Please see the pattern description in the &lt;a href=&quot;rpoplpush&quot;&gt;RPOPLPUSH&lt;/a&gt; documentation.</source>
          <target state="translated">&lt;a href=&quot;rpoplpush&quot;&gt;RPOPLPUSH&lt;/a&gt; 설명서 의 패턴 설명을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="aed6d393dd61d1ba31957e351636ff901b0e6fa8" translate="yes" xml:space="preserve">
          <source>Posts a message to the given channel.</source>
          <target state="translated">주어진 채널에 메시지를 게시합니다.</target>
        </trans-unit>
        <trans-unit id="f815dfb4f6f438e54dc2f0a16193e4c96d3c1109" translate="yes" xml:space="preserve">
          <source>Practically speaking, for the client it is much better to simply assume that in the context of a given connection, cached scripts are guaranteed to be there unless an administrator explicitly called the &lt;a href=&quot;script-flush&quot;&gt;SCRIPT FLUSH&lt;/a&gt; command.</source>
          <target state="translated">실제로, 클라이언트의 경우 관리자가 명시 적으로 &lt;a href=&quot;script-flush&quot;&gt;SCRIPT FLUSH&lt;/a&gt; 명령을 호출하지 않는 한 주어진 연결의 컨텍스트에서 캐시 된 스크립트가 존재한다고 가정하는 것이 훨씬 좋습니다 .</target>
        </trans-unit>
        <trans-unit id="4d21fc376a96084ebb73d4e8b35c0a4c4be845e0" translate="yes" xml:space="preserve">
          <source>Provide information on the role of a Redis instance in the context of replication, by returning if the instance is currently a &lt;code&gt;master&lt;/code&gt;, &lt;code&gt;slave&lt;/code&gt;, or &lt;code&gt;sentinel&lt;/code&gt;. The command also returns additional information about the state of the replication (if the role is master or slave) or the list of monitored master names (if the role is sentinel).</source>
          <target state="translated">인스턴스가 현재 &lt;code&gt;master&lt;/code&gt; , &lt;code&gt;slave&lt;/code&gt; 또는 &lt;code&gt;sentinel&lt;/code&gt; 인지 반환하여 복제 컨텍스트에서 Redis 인스턴스의 역할에 대한 정보를 제공하십시오 . 이 명령은 또한 복제 상태 (역할이 마스터 또는 슬레이브 인 경우) 또는 모니터링 된 마스터 이름 목록 (역할이 전송 된 경우)에 대한 추가 정보를 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="7ca91750d60fd45e80636934b3d1f1da26ffd9f9" translate="yes" xml:space="preserve">
          <source>Pub/Sub</source>
          <target state="translated">Pub/Sub</target>
        </trans-unit>
        <trans-unit id="5860c8458788e44e7636fa364548e067049a0d7b" translate="yes" xml:space="preserve">
          <source>QUIT</source>
          <target state="translated">QUIT</target>
        </trans-unit>
        <trans-unit id="7471799996c7de46c4ffa444365596fb514b6f5a" translate="yes" xml:space="preserve">
          <source>QUIT   Close the connection</source>
          <target state="translated">종료 연결을 닫습니다</target>
        </trans-unit>
        <trans-unit id="baa5d3184c0cc0ce5e007af06198524a4d26548f" translate="yes" xml:space="preserve">
          <source>Quit the server.</source>
          <target state="translated">서버를 종료하십시오.</target>
        </trans-unit>
        <trans-unit id="94386a96dc3f69665a14e74fb2942d92163c5d74" translate="yes" xml:space="preserve">
          <source>RANDOMKEY</source>
          <target state="translated">RANDOMKEY</target>
        </trans-unit>
        <trans-unit id="338552ba06825ef4f555f3d5ff79d40557c925de" translate="yes" xml:space="preserve">
          <source>RANDOMKEY   Return a random key from the keyspace</source>
          <target state="translated">RANDOMKEY 키 공간에서 임의의 키를 반환</target>
        </trans-unit>
        <trans-unit id="90a97e888676c2d0f3b14c8b4a5ca16d360880bc" translate="yes" xml:space="preserve">
          <source>READONLY</source>
          <target state="translated">READONLY</target>
        </trans-unit>
        <trans-unit id="21d1a8e094bd428debefea84e6dd96322d4c6011" translate="yes" xml:space="preserve">
          <source>READONLY   Enables read queries for a connection to a cluster replica node</source>
          <target state="translated">READONLY 클러스터 복제본 노드에 연결하기위한 읽기 쿼리를 활성화합니다.</target>
        </trans-unit>
        <trans-unit id="5305e8529d963d471cecc6faf967cedff2ea7494" translate="yes" xml:space="preserve">
          <source>READWRITE</source>
          <target state="translated">READWRITE</target>
        </trans-unit>
        <trans-unit id="2ae19352a72e6e879b7c82d353a544f20f6b355b" translate="yes" xml:space="preserve">
          <source>READWRITE   Disables read queries for a connection to a cluster replica node</source>
          <target state="translated">READWRITE 클러스터 복제본 노드 연결에 대한 읽기 쿼리를 비활성화합니다.</target>
        </trans-unit>
        <trans-unit id="4756081595ff9366e8b59c094aebf3df53a8fc98" translate="yes" xml:space="preserve">
          <source>RENAME</source>
          <target state="translated">RENAME</target>
        </trans-unit>
        <trans-unit id="434016433de8ed51fc6a3df25c58d49e8397ca2e" translate="yes" xml:space="preserve">
          <source>RENAME  key newkey   Rename a key</source>
          <target state="translated">키 이름 바꾸기 키 이름 바꾸기</target>
        </trans-unit>
        <trans-unit id="eb9b6064a90c47e23a80adefc9b43f4215668dbe" translate="yes" xml:space="preserve">
          <source>RENAMENX</source>
          <target state="translated">RENAMENX</target>
        </trans-unit>
        <trans-unit id="e1288934ac4d4000f51ff88bf791420487a34758" translate="yes" xml:space="preserve">
          <source>RENAMENX  key newkey   Rename a key, only if the new key does not exist</source>
          <target state="translated">RENAMENX key newkey 새 키가없는 경우에만 키 이름을 바꿉니다.</target>
        </trans-unit>
        <trans-unit id="12c92fcd35c554e1970345d0c852363a2bfff485" translate="yes" xml:space="preserve">
          <source>REPLICAOF</source>
          <target state="translated">REPLICAOF</target>
        </trans-unit>
        <trans-unit id="81253c78d1304948f92fc2d7488335ba2280cd3f" translate="yes" xml:space="preserve">
          <source>REPLICAOF  host port   Make the server a replica of another instance, or promote it as master.</source>
          <target state="translated">REPLICAOF 호스트 포트 서버를 다른 인스턴스의 복제본으로 만들거나 마스터로 승격하십시오.</target>
        </trans-unit>
        <trans-unit id="6a8135bcdb582d28d5425eef52faf6ac80eefb26" translate="yes" xml:space="preserve">
          <source>RESTORE</source>
          <target state="translated">RESTORE</target>
        </trans-unit>
        <trans-unit id="693be3f2ba1e3d54a77f2bd81f59053740c9352a" translate="yes" xml:space="preserve">
          <source>RESTORE  key ttl serialized-value [REPLACE]   Create a key using the provided serialized value, previously obtained using DUMP.</source>
          <target state="translated">RESTORE key ttl serialized-value [REPLACE] DUMP를 사용하여 이전에 얻은 제공된 직렬화 된 값을 사용하여 키를 만듭니다.</target>
        </trans-unit>
        <trans-unit id="1631070e7f0b44982ae66b11640654e7ec5dc4bd" translate="yes" xml:space="preserve">
          <source>ROLE</source>
          <target state="translated">ROLE</target>
        </trans-unit>
        <trans-unit id="5b2e8afa66ad35a6843b32ab5ca521321ed80e09" translate="yes" xml:space="preserve">
          <source>ROLE   Return the role of the instance in the context of replication</source>
          <target state="translated">ROLE 복제 컨텍스트에서 인스턴스의 역할을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="b7ce3009275f8c79b50c7f42dcb85f259fc1334f" translate="yes" xml:space="preserve">
          <source>RPOP</source>
          <target state="translated">RPOP</target>
        </trans-unit>
        <trans-unit id="daae95751cd7b3b0d6286ba595f17b95a4dbf14d" translate="yes" xml:space="preserve">
          <source>RPOP  key   Remove and get the last element in a list</source>
          <target state="translated">RPOP 키 목록에서 마지막 요소를 제거하고 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="5fc91e22c7eda82f26217a9a276a557189795a83" translate="yes" xml:space="preserve">
          <source>RPOPLPUSH</source>
          <target state="translated">RPOPLPUSH</target>
        </trans-unit>
        <trans-unit id="9b4f14c63b639db09e2a8cbabb9aee76bf074fd7" translate="yes" xml:space="preserve">
          <source>RPOPLPUSH  source destination   Remove the last element in a list, prepend it to another list and return it</source>
          <target state="translated">RPOPLPUSH 소스 대상 목록에서 마지막 요소를 제거하고 다른 목록 앞에 추가 한 후 리턴하십시오.</target>
        </trans-unit>
        <trans-unit id="b9d73dc860be3da3eb63b95dc888be66d34c596b" translate="yes" xml:space="preserve">
          <source>RPUSH</source>
          <target state="translated">RPUSH</target>
        </trans-unit>
        <trans-unit id="cc9293df01dd3379605fef72d334681379153757" translate="yes" xml:space="preserve">
          <source>RPUSH  key value [value ...]   Append one or multiple values to a list</source>
          <target state="translated">RPUSH 키 값 [값 ...] 하나 이상의 값을 목록에 추가</target>
        </trans-unit>
        <trans-unit id="a2fe5b491151e540de6422c6e85592df5f204dc3" translate="yes" xml:space="preserve">
          <source>RPUSHX</source>
          <target state="translated">RPUSHX</target>
        </trans-unit>
        <trans-unit id="61d6ff5cbc32d5fc0ed38bfb10b34d14916d1c00" translate="yes" xml:space="preserve">
          <source>RPUSHX  key value   Append a value to a list, only if the list exists</source>
          <target state="translated">RPUSHX 키 값 목록이 존재하는 경우에만 목록에 값을 추가</target>
        </trans-unit>
        <trans-unit id="a31a9b75b6318e8c48bf5d454b96698ee608da57" translate="yes" xml:space="preserve">
          <source>Range of integer scores that can be expressed precisely</source>
          <target state="translated">정확하게 표현할 수있는 정수 점수 범위</target>
        </trans-unit>
        <trans-unit id="df8903174eb3eac863f1253076caa8171702cb53" translate="yes" xml:space="preserve">
          <source>Range: 3900-4000</source>
          <target state="translated">사거리 : 3900-4000</target>
        </trans-unit>
        <trans-unit id="e1d33f7270a253d76d9b6fe1deb9155ecce0ca42" translate="yes" xml:space="preserve">
          <source>Read data from one or multiple streams, only returning entries with an ID greater than the last received ID reported by the caller. This command has an option to block if items are not available, in a similar fashion to &lt;a href=&quot;brpop&quot;&gt;BRPOP&lt;/a&gt; or &lt;a href=&quot;bzpopmin&quot;&gt;BZPOPMIN&lt;/a&gt; and others.</source>
          <target state="translated">하나 이상의 스트림에서 데이터를 읽고 호출자가보고 한 마지막 수신 ID보다 큰 ID를 가진 항목 만 반환합니다. 이 명령에는 &lt;a href=&quot;brpop&quot;&gt;BRPOP&lt;/a&gt; 또는 &lt;a href=&quot;bzpopmin&quot;&gt;BZPOPMIN&lt;/a&gt; 및 기타와 유사한 방식으로 항목을 사용할 수없는 경우 차단하는 옵션이 있습니다.</target>
        </trans-unit>
        <trans-unit id="58ccdcefd173a8269ea376346a634ff6e968e57b" translate="yes" xml:space="preserve">
          <source>Read only variants</source>
          <target state="translated">변형 만 읽기</target>
        </trans-unit>
        <trans-unit id="b8590ac877c85f2030d4921db5e93ead78595a0f" translate="yes" xml:space="preserve">
          <source>Read queries against a Redis Cluster slave node are disabled by default, but you can use the &lt;a href=&quot;readonly&quot;&gt;READONLY&lt;/a&gt; command to change this behavior on a per- connection basis. The &lt;a href=&quot;readwrite&quot;&gt;READWRITE&lt;/a&gt; command resets the readonly mode flag of a connection back to readwrite.</source>
          <target state="translated">Redis Cluster 슬레이브 노드에 대한 읽기 쿼리는 기본적으로 비활성화되어 있지만 &lt;a href=&quot;readonly&quot;&gt;READONLY&lt;/a&gt; 명령을 사용하여 연결 별로이 동작을 변경할 수 있습니다 . &lt;a href=&quot;readwrite&quot;&gt;READWRITE&lt;/a&gt; 명령은 READWRITE하는 연결 다시의 읽기 전용 모드 플래그를 재설정합니다.</target>
        </trans-unit>
        <trans-unit id="9ec77fdefc87d676b3e9acb9a7b04ded405da8e4" translate="yes" xml:space="preserve">
          <source>Reading application code, the complete semantics might not be clear since the application calls commands defined server side.</source>
          <target state="translated">응용 프로그램 코드를 읽으면 응용 프로그램에서 정의 된 서버 쪽 명령을 호출하므로 전체 의미가 명확하지 않을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="116cec955773e978e0eecf1499a10199d4278c99" translate="yes" xml:space="preserve">
          <source>Reading the &lt;a href=&quot;https://redis.io/topics/streams-intro&quot;&gt;Redis Streams introduction&lt;/a&gt; is highly suggested in order to understand more about the streams overall behavior and semantics.</source>
          <target state="translated">스트림 전체 동작 및 의미에 대한 자세한 내용을 이해하기 위해 &lt;a href=&quot;https://redis.io/topics/streams-intro&quot;&gt;Redis 스트림 소개를&lt;/a&gt; 읽는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="88951d0701502f598feecc55f4d3172c32a2db31" translate="yes" xml:space="preserve">
          <source>Reading the slow log</source>
          <target state="translated">느린 로그 읽기</target>
        </trans-unit>
        <trans-unit id="a87de541283ca3bc3c0a398706ee3346da0564e3" translate="yes" xml:space="preserve">
          <source>Recent versions of Redis Sentinel (Redis 2.8.12 or greater) use CLIENT KILL in order to kill clients when an instance is reconfigured, in order to force clients to perform the handshake with one Sentinel again and update its configuration.</source>
          <target state="translated">최신 버전의 Redis Sentinel (Redis 2.8.12 이상)은 CLIENT KILL을 사용하여 인스턴스가 재구성 될 때 클라이언트를 강제 종료하고 클라이언트가 Sentinel로 다시 핸드 셰이크를 수행하고 구성을 업데이트하도록합니다.</target>
        </trans-unit>
        <trans-unit id="68c1dff2ef06724a3eb5f0a503f24117784a62d1" translate="yes" xml:space="preserve">
          <source>Reconfigure clients to connect with the new master.</source>
          <target state="translated">새 마스터와 연결되도록 클라이언트를 재구성하십시오.</target>
        </trans-unit>
        <trans-unit id="24071b57a13027c01339027dcccb98218f052a8f" translate="yes" xml:space="preserve">
          <source>Redis</source>
          <target state="translated">Redis</target>
        </trans-unit>
        <trans-unit id="64fb7fd6108bc6be312c9ee1e4ae786b08c32a13" translate="yes" xml:space="preserve">
          <source>Redis 3.2 introduced an optional &lt;code&gt;count&lt;/code&gt; argument that can be passed to &lt;a href=&quot;spop&quot;&gt;SPOP&lt;/a&gt; in order to retrieve multiple elements in a single call.</source>
          <target state="translated">Redis 3.2 는 단일 호출에서 여러 요소를 검색하기 위해 &lt;a href=&quot;spop&quot;&gt;SPOP&lt;/a&gt; 에 전달할 수 있는 선택적 &lt;code&gt;count&lt;/code&gt; 인수를 도입했습니다 .</target>
        </trans-unit>
        <trans-unit id="09da59c00f13190142c29bd0fc09b7580fb99363" translate="yes" xml:space="preserve">
          <source>Redis Cluster live resharding explained</source>
          <target state="translated">Redis Cluster 라이브 리 샤딩 설명</target>
        </trans-unit>
        <trans-unit id="8be0343488efef207b0826c15486c08f81f5710d" translate="yes" xml:space="preserve">
          <source>Redis HyperLogLogs are represented using a double representation: the &lt;em&gt;sparse&lt;/em&gt; representation suitable for HLLs counting a small number of elements (resulting in a small number of registers set to non-zero value), and a &lt;em&gt;dense&lt;/em&gt; representation suitable for higher cardinalities. Redis automatically switches from the sparse to the dense representation when needed.</source>
          <target state="translated">Redis HyperLogLog는 이중 표현을 사용하여 표현됩니다. 적은 수의 요소를 계산하는 HLL에 적합한 &lt;em&gt;희소&lt;/em&gt; 표현 (0이 아닌 값으로 설정된 작은 수의 레지스터 결과)과 높은 카디널리티에 적합한 &lt;em&gt;조밀 한&lt;/em&gt; 표현입니다. Redis는 필요할 때 스파 스에서 밀도가 높은 표현으로 자동 전환됩니다.</target>
        </trans-unit>
        <trans-unit id="2e645ecd73ea1ffa136575150e55a17bbdaf4a35" translate="yes" xml:space="preserve">
          <source>Redis Nil bulk reply and Nil multi bulk reply -&amp;gt; Lua false boolean type</source>
          <target state="translated">Redis Nil 대량 회신 및 Nil 다중 대량 회신-&amp;gt; Lua false 부울 유형</target>
        </trans-unit>
        <trans-unit id="12deb2b7b17fe48280b9acc8ac6e268a2fccdfc8" translate="yes" xml:space="preserve">
          <source>Redis bulk reply -&amp;gt; Lua string</source>
          <target state="translated">Redis 대량 회신-&amp;gt; 루아 문자열</target>
        </trans-unit>
        <trans-unit id="28c992585f8b92e96ef7862e17fbc69b72429ffe" translate="yes" xml:space="preserve">
          <source>Redis commands that may return elements in random order, like &lt;a href=&quot;smembers&quot;&gt;SMEMBERS&lt;/a&gt; (because Redis Sets are &lt;em&gt;unordered&lt;/em&gt;) have a different behavior when called from Lua, and undergo a silent lexicographical sorting filter before returning data to Lua scripts. So &lt;code&gt;redis.call(&quot;smembers&quot;,KEYS[1])&lt;/code&gt; will always return the Set elements in the same order, while the same command invoked from normal clients may return different results even if the key contains exactly the same elements.</source>
          <target state="translated">&lt;a href=&quot;smembers&quot;&gt;SMEMBERS&lt;/a&gt; 와 같이 임의 순서로 요소를 리턴 할 수있는 Redis 명령 ( Radis 세트가 &lt;em&gt;정렬되지&lt;/em&gt; 않았기 때문에 )은 Lua에서 호출 될 때 동작이 다르며 데이터를 Lua 스크립트로 리턴하기 전에 자동 사전 식 정렬 필터를 거칩니다. 따라서 &lt;code&gt;redis.call(&quot;smembers&quot;,KEYS[1])&lt;/code&gt; 은 항상 동일한 순서로 Set 요소를 반환하지만, 키가 정확히 같은 요소를 포함하더라도 일반 클라이언트에서 호출 된 동일한 명령은 다른 결과를 반환 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9030a22b56473e440d80783adf7755f42e3cd798" translate="yes" xml:space="preserve">
          <source>Redis commands usually accept one key, two keys, or an unlimited number of keys.</source>
          <target state="translated">Redis 명령은 일반적으로 하나의 키, 두 개의 키 또는 무제한의 키를 허용합니다.</target>
        </trans-unit>
        <trans-unit id="4798309557a5e9b4d97ab42c59e238806f00fa04" translate="yes" xml:space="preserve">
          <source>Redis different selectable databases are a form of namespacing: all the databases are anyway persisted together in the same RDB / AOF file. However different databases can have keys having the same name, and there are commands available like &lt;a href=&quot;flushdb&quot;&gt;FLUSHDB&lt;/a&gt;, &lt;a href=&quot;swapdb&quot;&gt;SWAPDB&lt;/a&gt; or &lt;a href=&quot;randomkey&quot;&gt;RANDOMKEY&lt;/a&gt; that work on specific databases.</source>
          <target state="translated">Redis의 선택 가능한 다른 데이터베이스는 네임 스페이스의 한 형태입니다. 모든 데이터베이스는 어쨌든 동일한 RDB / AOF 파일에 함께 유지됩니다. 그러나 다른 데이터베이스에는 동일한 이름의 키가있을 수 있으며 &lt;a href=&quot;flushdb&quot;&gt;FLUSHDB&lt;/a&gt; , &lt;a href=&quot;swapdb&quot;&gt;SWAPDB&lt;/a&gt; 또는 &lt;a href=&quot;randomkey&quot;&gt;RANDOMKEY&lt;/a&gt; 와 같이 특정 데이터베이스에서 작동하는 명령이 있습니다 .</target>
        </trans-unit>
        <trans-unit id="a48311c837dbe1e0c3cec8f3114d4df2e8c16385" translate="yes" xml:space="preserve">
          <source>Redis error reply -&amp;gt; Lua table with a single &lt;code&gt;err&lt;/code&gt; field containing the error</source>
          <target state="translated">Redis 오류 응답-&amp;gt; 오류가 포함 된 단일 &lt;code&gt;err&lt;/code&gt; 필드가있는 Lua 테이블</target>
        </trans-unit>
        <trans-unit id="562ad79eb5fcdcd97d8a0283855bce99c0023855" translate="yes" xml:space="preserve">
          <source>Redis integer reply -&amp;gt; Lua number</source>
          <target state="translated">Redis 정수 응답-&amp;gt; 루아 번호</target>
        </trans-unit>
        <trans-unit id="53c0959152bcf66e99f3ab4d98ebaba488b539de" translate="yes" xml:space="preserve">
          <source>Redis is UTF-8 aware, assuming you correctly set the &lt;code&gt;!LC_COLLATE&lt;/code&gt; environment variable.</source>
          <target state="translated">&lt;code&gt;!LC_COLLATE&lt;/code&gt; 환경 변수 를 올바르게 설정했다고 가정하면 Redis는 UTF-8을 인식 합니다.</target>
        </trans-unit>
        <trans-unit id="ac11208b3186492fddcf23ffb985bed2f4b921dd" translate="yes" xml:space="preserve">
          <source>Redis is now able to delete keys in the background in a different thread without blocking the server. An &lt;code&gt;ASYNC&lt;/code&gt; option was added to &lt;a href=&quot;flushall&quot;&gt;FLUSHALL&lt;/a&gt; and &lt;a href=&quot;flushdb&quot;&gt;FLUSHDB&lt;/a&gt; in order to let the entire dataset or a single database to be freed asynchronously.</source>
          <target state="translated">Redis는 이제 서버를 차단하지 않고 백그라운드에서 다른 스레드의 키를 삭제할 수 있습니다. &lt;code&gt;ASYNC&lt;/code&gt; 의 옵션이 추가되었습니다 &lt;a href=&quot;flushall&quot;&gt;FLUSHALL&lt;/a&gt; 및 &lt;a href=&quot;flushdb&quot;&gt;FLUSHDB&lt;/a&gt; 전체 데이터 세트 또는 단일 데이터베이스를 비동기 적으로 해제 할 수 있도록하기 위해.</target>
        </trans-unit>
        <trans-unit id="f26191bd07f5d296d686b49ddf0fea28de008280" translate="yes" xml:space="preserve">
          <source>Redis is often used as a messaging server to implement processing of background jobs or other kinds of messaging tasks. A simple form of queue is often obtained pushing values into a list in the producer side, and waiting for this values in the consumer side using &lt;a href=&quot;rpop&quot;&gt;RPOP&lt;/a&gt; (using polling), or &lt;a href=&quot;brpop&quot;&gt;BRPOP&lt;/a&gt; if the client is better served by a blocking operation.</source>
          <target state="translated">Redis는 백그라운드 작업 또는 다른 종류의 메시징 작업 처리를 구현하기 위해 메시징 서버로 자주 사용됩니다. 간단한 큐 형식은 종종 값을 생산자 측의 목록으로 푸시하고 &lt;a href=&quot;rpop&quot;&gt;RPOP&lt;/a&gt; (폴링 사용) 또는 클라이언트가 블로킹 조작으로 더 나은 서비스를 제공하는 경우 &lt;a href=&quot;brpop&quot;&gt;BRPOP를&lt;/a&gt; 사용 하여 소비자 측에서이 값을 기다 립니다 .</target>
        </trans-unit>
        <trans-unit id="42a27bac8c1f348420272658d3c655887b07c3ba" translate="yes" xml:space="preserve">
          <source>Redis keys are expired in two ways: a passive way, and an active way.</source>
          <target state="translated">Redis 키는 수동 방식과 능동 방식의 두 가지 방식으로 만료됩니다.</target>
        </trans-unit>
        <trans-unit id="ea38abb16e6fc53c1055d716b8dafffc97128c14" translate="yes" xml:space="preserve">
          <source>Redis logs that a script is running too long.</source>
          <target state="translated">Redis는 스크립트가 너무 오래 실행되고 있음을 기록합니다.</target>
        </trans-unit>
        <trans-unit id="5ada15ccb812ae3dfe260cac4cea16ab388a5061" translate="yes" xml:space="preserve">
          <source>Redis multi bulk reply -&amp;gt; Lua table (may have other Redis data types nested)</source>
          <target state="translated">Redis 다중 대량 응답-&amp;gt; Lua 테이블 (다른 Redis 데이터 유형이 중첩 될 수 있음)</target>
        </trans-unit>
        <trans-unit id="cb910cc16645a1fbd760219098ebcbf7bc9f050c" translate="yes" xml:space="preserve">
          <source>Redis offers a SCRIPT command that can be used in order to control the scripting subsystem. SCRIPT currently accepts three different commands:</source>
          <target state="translated">Redis는 스크립팅 하위 시스템을 제어하는 ​​데 사용할 수있는 SCRIPT 명령을 제공합니다. SCRIPT는 현재 세 가지 명령을 허용합니다.</target>
        </trans-unit>
        <trans-unit id="0ab17f17e02f188a1bdf8cac0d6180f82fee1717" translate="yes" xml:space="preserve">
          <source>Redis return values are converted into Lua data types when Lua calls a Redis command using &lt;code&gt;call()&lt;/code&gt; or &lt;code&gt;pcall()&lt;/code&gt;. Similarly, Lua data types are converted into the Redis protocol when calling a Redis command and when a Lua script returns a value, so that scripts can control what &lt;a href=&quot;eval&quot;&gt;EVAL&lt;/a&gt; will return to the client.</source>
          <target state="translated">Lua가 &lt;code&gt;call()&lt;/code&gt; 또는 &lt;code&gt;pcall()&lt;/code&gt; 사용하여 Redis 명령을 호출 하면 Redis 반환 값이 Lua 데이터 형식으로 변환됩니다 . 마찬가지로 Lua 데이터 유형은 Redis 명령을 호출 할 때와 Lua 스크립트가 값을 반환 할 때 Redis 프로토콜로 변환되므로 스크립트는 &lt;a href=&quot;eval&quot;&gt;EVAL&lt;/a&gt; 이 클라이언트에 반환 할 항목을 제어 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="0fa967ae24b949a1700795759c8cdfe062988a8a" translate="yes" xml:space="preserve">
          <source>Redis scripts are not allowed to create global variables, in order to avoid leaking data into the Lua state. If a script needs to maintain state between calls (a pretty uncommon need) it should use Redis keys instead.</source>
          <target state="translated">Redis 스크립트는 Lua 상태로 데이터가 유출되는 것을 방지하기 위해 전역 변수를 만들 수 없습니다. 스크립트가 호출 사이에 상태를 유지해야하는 경우 (보통 드문 경우) Redis 키를 대신 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="e62135b0922f82850c893085d4cd08cc6fd7ccb4" translate="yes" xml:space="preserve">
          <source>Redis slow log overview</source>
          <target state="translated">Redis 느린 로그 개요</target>
        </trans-unit>
        <trans-unit id="add967db3e0dd55b3522bf60d87afa3192a4838a" translate="yes" xml:space="preserve">
          <source>Redis sorted sets use a &lt;em&gt;double 64-bit floating point number&lt;/em&gt; to represent the score. In all the architectures we support, this is represented as an &lt;strong&gt;IEEE 754 floating point number&lt;/strong&gt;, that is able to represent precisely integer numbers between &lt;code&gt;-(2^53)&lt;/code&gt; and &lt;code&gt;+(2^53)&lt;/code&gt; included. In more practical terms, all the integers between -9007199254740992 and 9007199254740992 are perfectly representable. Larger integers, or fractions, are internally represented in exponential form, so it is possible that you get only an approximation of the decimal number, or of the very big integer, that you set as score.</source>
          <target state="translated">Redis 정렬 세트 는 점수를 나타 내기 위해 &lt;em&gt;이중 64 비트 부동 소수점 숫자&lt;/em&gt; 를 사용합니다. 우리가 지원하는 모든 아키텍처에서, 이것은 &lt;strong&gt;IEEE 754 부동 소수점 숫자&lt;/strong&gt; 로 표시되며, 포함 된 &lt;code&gt;-(2^53)&lt;/code&gt; 과 &lt;code&gt;+(2^53)&lt;/code&gt; 사이의 정수를 정확하게 나타낼 수 있습니다. 보다 실용적인 용어로, -9007199254740992와 9007199254740992 사이의 모든 정수는 완벽하게 표현할 수 있습니다. 더 큰 정수 또는 분수는 내부적으로 지수 형식으로 표시되므로 점수로 설정 한 10 진수 또는 매우 큰 정수의 근사값 만 얻을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="738a4a620b4c28b97c15ca1b2edd5526cb23af29" translate="yes" xml:space="preserve">
          <source>Redis status reply -&amp;gt; Lua table with a single &lt;code&gt;ok&lt;/code&gt; field containing the status</source>
          <target state="translated">Redis 상태 응답-&amp;gt; 상태를 포함 하는 단일 &lt;code&gt;ok&lt;/code&gt; 필드가있는 Lua 테이블</target>
        </trans-unit>
        <trans-unit id="db935d0902ab47146d7cddc707ae23f8dbd30e13" translate="yes" xml:space="preserve">
          <source>Redis stores integers in their integer representation, so for string values that actually hold an integer, there is no overhead for storing the string representation of the integer.</source>
          <target state="translated">Redis는 정수를 정수 표현으로 저장하므로 실제로 정수를 보유하는 문자열 값의 경우 정수의 문자열 표현을 저장하기위한 오버 헤드가 없습니다.</target>
        </trans-unit>
        <trans-unit id="b6955638f080137455ca2315a3e774bacb29e670" translate="yes" xml:space="preserve">
          <source>Redis streams are represented in a way that makes them memory efficient: a radix tree is used in order to index macro-nodes that pack linearly tens of stream entries. Normally what happens when you delete an entry from a stream is that the entry is not &lt;em&gt;really&lt;/em&gt; evicted, it just gets marked as deleted.</source>
          <target state="translated">Redis 스트림은 메모리를 효율적으로 만드는 방식으로 표시됩니다. 기수 트리는 수십 개의 스트림 항목을 선형으로 묶는 매크로 노드를 인덱싱하는 데 사용됩니다. 일반적으로 스트림에서 항목을 삭제하면 &lt;em&gt;실제로&lt;/em&gt; 항목이 제거되지 않고 삭제 된 것으로 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="fa7af6984c788798f4aee1b72f3fb15136c972f4" translate="yes" xml:space="preserve">
          <source>Redis uses the same Lua interpreter to run all the commands. Also Redis guarantees that a script is executed in an atomic way: no other script or Redis command will be executed while a script is being executed. This semantic is similar to the one of &lt;a href=&quot;multi&quot;&gt;MULTI&lt;/a&gt; / &lt;a href=&quot;exec&quot;&gt;EXEC&lt;/a&gt;. From the point of view of all the other clients the effects of a script are either still not visible or already completed.</source>
          <target state="translated">Redis는 동일한 Lua 인터프리터를 사용하여 모든 명령을 실행합니다. 또한 Redis는 스크립트가 원자적인 방식으로 실행되도록 보장합니다. 스크립트가 실행되는 동안 다른 스크립트 나 Redis 명령은 실행되지 않습니다. 이 의미는 &lt;a href=&quot;multi&quot;&gt;MULTI&lt;/a&gt; / &lt;a href=&quot;exec&quot;&gt;EXEC&lt;/a&gt; 와 비슷합니다 . 다른 모든 클라이언트의 관점에서 스크립트의 효과는 여전히 보이지 않거나 이미 완료되었습니다.</target>
        </trans-unit>
        <trans-unit id="315e6feef25876fa664b37d723e94c657b1c8f6a" translate="yes" xml:space="preserve">
          <source>Redis will block the script with an error if a script calls a Redis command able to alter the data set &lt;strong&gt;after&lt;/strong&gt; a Redis &lt;em&gt;random&lt;/em&gt; command like &lt;a href=&quot;randomkey&quot;&gt;RANDOMKEY&lt;/a&gt;, &lt;a href=&quot;srandmember&quot;&gt;SRANDMEMBER&lt;/a&gt;, &lt;a href=&quot;time&quot;&gt;TIME&lt;/a&gt;. This means that if a script is read-only and does not modify the data set it is free to call those commands. Note that a &lt;em&gt;random command&lt;/em&gt; does not necessarily mean a command that uses random numbers: any non-deterministic command is considered a random command (the best example in this regard is the &lt;a href=&quot;time&quot;&gt;TIME&lt;/a&gt; command).</source>
          <target state="translated">스크립트가 &lt;a href=&quot;randomkey&quot;&gt;RANDOMKEY&lt;/a&gt; , &lt;a href=&quot;srandmember&quot;&gt;SRANDMEMBER&lt;/a&gt; , &lt;a href=&quot;time&quot;&gt;TIME&lt;/a&gt; 과 같은 Redis &lt;em&gt;임의&lt;/em&gt; 명령 &lt;strong&gt;후&lt;/strong&gt; 데이터 세트를 변경할 수있는 Redis 명령을 호출하면 Redis는 오류로 스크립트를 차단합니다 . 즉, 스크립트가 읽기 전용이고 데이터 세트를 수정하지 않으면 해당 명령을 자유롭게 호출 할 수 있습니다. &amp;bull; 그래도 참고 &lt;em&gt;임의의 명령을&lt;/em&gt; 반드시 임의의 숫자를 사용하는 명령을 의미하지 않는다 : 비 결정적 명령은 임의의 명령 간주된다 (이 점에서 가장 좋은 예는 것입니다 &lt;a href=&quot;time&quot;&gt;시간의&lt;/a&gt; 명령).&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="1d65bbb9c212a9d98ffb329def918b64ef3d8889" translate="yes" xml:space="preserve">
          <source>Refreshing expires</source>
          <target state="translated">새로 고침 만료</target>
        </trans-unit>
        <trans-unit id="26ca731c99535195e55e64ad25c62f00fdbd2a4c" translate="yes" xml:space="preserve">
          <source>Reliable queues</source>
          <target state="translated">안정적인 대기열</target>
        </trans-unit>
        <trans-unit id="ea59d67e277c60b336a409408ff4d775b8225584" translate="yes" xml:space="preserve">
          <source>Remove a specific consumer from a consumer group.</source>
          <target state="translated">소비자 그룹에서 특정 소비자를 제거합니다.</target>
        </trans-unit>
        <trans-unit id="ce4d2a865a5a06124187f3a0d8a5354cd701d61f" translate="yes" xml:space="preserve">
          <source>Remove the existing timeout on &lt;code&gt;key&lt;/code&gt;, turning the key from &lt;em&gt;volatile&lt;/em&gt; (a key with an expire set) to &lt;em&gt;persistent&lt;/em&gt; (a key that will never expire as no timeout is associated).</source>
          <target state="translated">&lt;code&gt;key&lt;/code&gt; 에서 기존 시간 초과를 제거하고 키를 &lt;em&gt;소멸성&lt;/em&gt; (만료 세트가 있는 키 )에서 &lt;em&gt;영구&lt;/em&gt; (시간 초과가 연결되지 않아 만료되지 않는 키)로 전환하십시오.</target>
        </trans-unit>
        <trans-unit id="c1d260f4e3da83fa28a692c23e66ed0cb15dd796" translate="yes" xml:space="preserve">
          <source>Remove the specified members from the set stored at &lt;code&gt;key&lt;/code&gt;. Specified members that are not a member of this set are ignored. If &lt;code&gt;key&lt;/code&gt; does not exist, it is treated as an empty set and this command returns &lt;code&gt;0&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;key&lt;/code&gt; 에 저장된 세트에서 지정된 멤버를 제거하십시오 . 이 세트의 멤버가 아닌 지정된 멤버는 무시됩니다. 경우 &lt;code&gt;key&lt;/code&gt; 존재하지 않는, 그것은 빈 세트로 취급하고이 명령을 반환 &lt;code&gt;0&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="de0b8cb5dfcd4da1251a55ebacec477902ab7fa1" translate="yes" xml:space="preserve">
          <source>Removes all elements in the sorted set stored at &lt;code&gt;key&lt;/code&gt; with a score between &lt;code&gt;min&lt;/code&gt; and &lt;code&gt;max&lt;/code&gt; (inclusive).</source>
          <target state="translated">&lt;code&gt;key&lt;/code&gt; 저장된 정렬 된 세트의 모든 요소를 &lt;code&gt;min&lt;/code&gt; 와 &lt;code&gt;max&lt;/code&gt; (포함) 사이의 점수로 제거합니다 .</target>
        </trans-unit>
        <trans-unit id="cbb3fc019bde7aa5a4f4696386c7635ab2172c17" translate="yes" xml:space="preserve">
          <source>Removes all elements in the sorted set stored at &lt;code&gt;key&lt;/code&gt; with rank between &lt;code&gt;start&lt;/code&gt; and &lt;code&gt;stop&lt;/code&gt;. Both &lt;code&gt;start&lt;/code&gt; and &lt;code&gt;stop&lt;/code&gt; are &lt;code&gt;0&lt;/code&gt; -based indexes with &lt;code&gt;0&lt;/code&gt; being the element with the lowest score. These indexes can be negative numbers, where they indicate offsets starting at the element with the highest score. For example: &lt;code&gt;-1&lt;/code&gt; is the element with the highest score, &lt;code&gt;-2&lt;/code&gt; the element with the second highest score and so forth.</source>
          <target state="translated">&lt;code&gt;start&lt;/code&gt; 와 &lt;code&gt;stop&lt;/code&gt; 사이의 순위를 가진 &lt;code&gt;key&lt;/code&gt; 저장된 정렬 된 세트의 모든 요소를 ​​제거합니다 . 모두 &lt;code&gt;start&lt;/code&gt; 및 &lt;code&gt;stop&lt;/code&gt; 되어 &lt;code&gt;0&lt;/code&gt; 과 기반 인덱스 &lt;code&gt;0&lt;/code&gt; 은 가장 낮은 점수를 가진 요소 인. 이 색인은 음수가 될 수 있으며, 여기서 가장 높은 점수를 가진 요소에서 시작하는 오프셋을 나타냅니다. 예를 들어, &lt;code&gt;-1&lt;/code&gt; 은 가장 높은 점수를 받은 요소 이고, &lt;code&gt;-2&lt;/code&gt; 는 두 번째로 높은 점수를 가진 요소 등입니다.</target>
        </trans-unit>
        <trans-unit id="da37c36034834387a9dd7fbda191a975ebb105b0" translate="yes" xml:space="preserve">
          <source>Removes and returns one or more random elements from the set value store at &lt;code&gt;key&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;key&lt;/code&gt; 의 설정 값 저장소에서 하나 이상의 임의 요소를 제거하고 리턴합니다 .</target>
        </trans-unit>
        <trans-unit id="870ac46dca2c1a6689064e1cced801af5e158f69" translate="yes" xml:space="preserve">
          <source>Removes and returns the first element of the list stored at &lt;code&gt;key&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;key&lt;/code&gt; 에 저장된 목록의 첫 번째 요소를 제거하고 리턴합니다 .</target>
        </trans-unit>
        <trans-unit id="ec2ce52901cbc45793a1c6bb41b722b9057d2bc4" translate="yes" xml:space="preserve">
          <source>Removes and returns the last element of the list stored at &lt;code&gt;key&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;key&lt;/code&gt; 에 저장된 목록의 마지막 요소를 제거하고 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="52acb45013cdb2a41dc580913c01c50bd6ebca86" translate="yes" xml:space="preserve">
          <source>Removes and returns up to &lt;code&gt;count&lt;/code&gt; members with the highest scores in the sorted set stored at &lt;code&gt;key&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;key&lt;/code&gt; 에 저장된 정렬 된 세트에서 가장 높은 점수를 가진 멤버 를 &lt;code&gt;count&lt;/code&gt; 제거합니다 .</target>
        </trans-unit>
        <trans-unit id="ac48e8c652eae033a19d95a11cb8d9dbd5e35dab" translate="yes" xml:space="preserve">
          <source>Removes and returns up to &lt;code&gt;count&lt;/code&gt; members with the lowest scores in the sorted set stored at &lt;code&gt;key&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;key&lt;/code&gt; 에 저장된 정렬 된 집합에서 가장 낮은 점수를 가진 멤버 를 &lt;code&gt;count&lt;/code&gt; 제거합니다 .</target>
        </trans-unit>
        <trans-unit id="7c6ffaff6ffe08c9f43baab9718f030d2162d111" translate="yes" xml:space="preserve">
          <source>Removes the first &lt;code&gt;count&lt;/code&gt; occurrences of elements equal to &lt;code&gt;value&lt;/code&gt; from the list stored at &lt;code&gt;key&lt;/code&gt;. The &lt;code&gt;count&lt;/code&gt; argument influences the operation in the following ways:</source>
          <target state="translated">&lt;code&gt;key&lt;/code&gt; 에 저장된 목록에서 &lt;code&gt;value&lt;/code&gt; 와 동일한 요소 의 첫 번째 발생 &lt;code&gt;count&lt;/code&gt; 제거합니다 . &lt;code&gt;count&lt;/code&gt; 인수는 다음과 같은 방법으로 작업에 영향을 미친다 :</target>
        </trans-unit>
        <trans-unit id="494ca7e2faa6bd5b36a369eb7746bb78fb3e96bc" translate="yes" xml:space="preserve">
          <source>Removes the specified entries from a stream, and returns the number of entries deleted, that may be different from the number of IDs passed to the command in case certain IDs do not exist.</source>
          <target state="translated">스트림에서 지정된 항목을 제거하고 삭제 된 항목 수를 리턴합니다. 이는 특정 ID가 존재하지 않는 경우 명령에 전달 된 ID 수와 다를 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="594397839f7156989bc1b259c19072c5484f7bdc" translate="yes" xml:space="preserve">
          <source>Removes the specified fields from the hash stored at &lt;code&gt;key&lt;/code&gt;. Specified fields that do not exist within this hash are ignored. If &lt;code&gt;key&lt;/code&gt; does not exist, it is treated as an empty hash and this command returns &lt;code&gt;0&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;key&lt;/code&gt; 에 저장된 해시에서 지정된 필드를 제거합니다 . 이 해시 내에 존재하지 않는 지정된 필드는 무시됩니다. 경우 &lt;code&gt;key&lt;/code&gt; 존재하지 않는, 그것은 하늘의 해시로 취급하고이 명령을 반환 &lt;code&gt;0&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="322e3109be94b3ac9ea4c2a44f232f96c6cd905a" translate="yes" xml:space="preserve">
          <source>Removes the specified keys. A key is ignored if it does not exist.</source>
          <target state="translated">지정된 키를 제거합니다. 키가 없으면 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="933e4f3eff042f249c190608a122f8e43bd494af" translate="yes" xml:space="preserve">
          <source>Removes the specified members from the sorted set stored at &lt;code&gt;key&lt;/code&gt;. Non existing members are ignored.</source>
          <target state="translated">&lt;code&gt;key&lt;/code&gt; 에 저장된 정렬 된 세트에서 지정된 멤버를 제거합니다 . 기존 멤버가 아닌 멤버는 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="17baa9fe7f8ed0143fa7df75975e104465db4e59" translate="yes" xml:space="preserve">
          <source>Renames &lt;code&gt;key&lt;/code&gt; to &lt;code&gt;newkey&lt;/code&gt; if &lt;code&gt;newkey&lt;/code&gt; does not yet exist. It returns an error when &lt;code&gt;key&lt;/code&gt; does not exist.</source>
          <target state="translated">&lt;code&gt;newkey&lt;/code&gt; 가 아직 없으면 &lt;code&gt;key&lt;/code&gt; 를 &lt;code&gt;newkey&lt;/code&gt; 로 이름을 바꿉니다 . &lt;code&gt;key&lt;/code&gt; 가 없으면 오류를 반환 합니다.</target>
        </trans-unit>
        <trans-unit id="0155259665636f6ceaaa0a0ebda67bb195d98a6d" translate="yes" xml:space="preserve">
          <source>Renames &lt;code&gt;key&lt;/code&gt; to &lt;code&gt;newkey&lt;/code&gt;. It returns an error when &lt;code&gt;key&lt;/code&gt; does not exist. If &lt;code&gt;newkey&lt;/code&gt; already exists it is overwritten, when this happens &lt;a href=&quot;rename&quot;&gt;RENAME&lt;/a&gt; executes an implicit &lt;a href=&quot;del&quot;&gt;DEL&lt;/a&gt; operation, so if the deleted key contains a very big value it may cause high latency even if &lt;a href=&quot;rename&quot;&gt;RENAME&lt;/a&gt; itself is usually a constant-time operation.</source>
          <target state="translated">&lt;code&gt;key&lt;/code&gt; 이름 을 &lt;code&gt;newkey&lt;/code&gt; 로 바꿉니다 . &lt;code&gt;key&lt;/code&gt; 가 없으면 오류를 반환 합니다. 경우 &lt;code&gt;newkey&lt;/code&gt; 는 이미 이러한 상황이 발생하는 경우는, 덮어 쓰기 &lt;a href=&quot;rename&quot;&gt;RENAME이&lt;/a&gt; 암시 실행 &lt;a href=&quot;del&quot;&gt;DEL의&lt;/a&gt; 삭제 된 키는 대기 시간이 긴 경우에도 발생할 수 있습니다 매우 큰 값이 포함되어 있으므로 경우, 작업을 &lt;a href=&quot;rename&quot;&gt;RENAME&lt;/a&gt; 자체가 일반적으로 일정 시간 작업입니다.</target>
        </trans-unit>
        <trans-unit id="351fb2e9d60cd91bf6510354de71fa6c06419ab4" translate="yes" xml:space="preserve">
          <source>Replicas broadcast their master's config epochs (in order to get an &lt;code&gt;UPDATE&lt;/code&gt; message if they are found to be stale), so the real config epoch of the replica (which is meaningless more or less, since they don't serve hash slots) can be only obtained checking the node flagged as &lt;code&gt;myself&lt;/code&gt;, which is the entry of the node we are asking to generate &lt;a href=&quot;cluster-nodes&quot;&gt;CLUSTER NODES&lt;/a&gt; output. The other replicas epochs reflect what they publish in heartbeat packets, which is, the configuration epoch of the masters they are currently replicating.</source>
          <target state="translated">복제본은 마스터의 구성 에포크를 브로드 캐스트하여 ( 부실한 것으로 확인 된 경우 &lt;code&gt;UPDATE&lt;/code&gt; 메시지 를 받기 위해 ) 복제본의 실제 구성 에포크 (해시 슬롯을 제공하지 않기 때문에 의미가 없습니다) &lt;code&gt;myself&lt;/code&gt; 플래그가 지정된 노드 만 검사하여 &lt;a href=&quot;cluster-nodes&quot;&gt;CLUSTER NODES&lt;/a&gt; 출력 을 생성하도록 요청한 노드의 항목입니다 . 다른 복제본 에포크는 하트 비트 패킷으로 게시 된 내용, 즉 현재 복제중인 마스터의 구성 에포크를 반영합니다.</target>
        </trans-unit>
        <trans-unit id="57ee014fca43ed90896705e17d43f35b06757596" translate="yes" xml:space="preserve">
          <source>Replicating commands instead of scripts</source>
          <target state="translated">스크립트 대신 명령 복제</target>
        </trans-unit>
        <trans-unit id="054fb8240ac6c1ab20550a9e5b79d9d4cd6d1345" translate="yes" xml:space="preserve">
          <source>Request for authentication in a password-protected Redis server. Redis can be instructed to require a password before allowing clients to execute commands. This is done using the &lt;code&gt;requirepass&lt;/code&gt; directive in the configuration file.</source>
          <target state="translated">비밀번호로 보호 된 Redis 서버에서 인증을 요청합니다. 클라이언트가 명령을 실행하기 전에 Redis에 암호를 요구하도록 지시 할 수 있습니다. 이것은 구성 파일에서 &lt;code&gt;requirepass&lt;/code&gt; 지시문을 사용하여 수행 됩니다.</target>
        </trans-unit>
        <trans-unit id="da1bb4a2fc17746f7a5baea5144086fae0563a1a" translate="yes" xml:space="preserve">
          <source>Reset a Redis Cluster node, in a more or less drastic way depending on the reset type, that can be &lt;strong&gt;hard&lt;/strong&gt; or &lt;strong&gt;soft&lt;/strong&gt;. Note that this command &lt;strong&gt;does not work for masters if they hold one or more keys&lt;/strong&gt;, in that case to completely reset a master node keys must be removed first, e.g. by using &lt;a href=&quot;flushall&quot;&gt;FLUSHALL&lt;/a&gt; first, and then &lt;a href=&quot;cluster-reset&quot;&gt;CLUSTER RESET&lt;/a&gt;.</source>
          <target state="translated">재설정 유형에 따라 Redis Cluster 노드를 다소 과감하게 재설정하십시오 . &lt;strong&gt;단단&lt;/strong&gt; 하거나 &lt;strong&gt;부드럽습니다&lt;/strong&gt; . &lt;strong&gt;마스터가 하나 이상의 키를 보유한&lt;/strong&gt; 경우이 명령 &lt;strong&gt;은 마스터에 대해 작동하지 않습니다&lt;/strong&gt; .이 경우 마스터 노드 키를 완전히 재설정하려면 먼저 &lt;a href=&quot;flushall&quot;&gt;FLUSHALL을&lt;/a&gt; 먼저 사용한 다음 &lt;a href=&quot;cluster-reset&quot;&gt;CLUSTER RESET&lt;/a&gt; 을 사용하여 마스터 노드 키를 먼저 제거해야합니다 .</target>
        </trans-unit>
        <trans-unit id="5b45f167ccc9268d6db2b2030f5f33cd642304b9" translate="yes" xml:space="preserve">
          <source>Resets the statistics reported by Redis using the &lt;a href=&quot;info&quot;&gt;INFO&lt;/a&gt; command.</source>
          <target state="translated">&lt;a href=&quot;info&quot;&gt;INFO&lt;/a&gt; 명령을 사용하여 Redis가보고 한 통계를 재설정합니다 .</target>
        </trans-unit>
        <trans-unit id="8b4926f937540a054f457674fa7da321fbd6a1f7" translate="yes" xml:space="preserve">
          <source>Resetting the slow log.</source>
          <target state="translated">느린 로그를 재설정합니다.</target>
        </trans-unit>
        <trans-unit id="401feffc58d082a7dc99bf3cdbc90af756748e94" translate="yes" xml:space="preserve">
          <source>Reshard all the hash slots from D to nodes A, B, C.</source>
          <target state="translated">D에서 노드 A, B, C로 모든 해시 슬롯을 리 샤딩하십시오.</target>
        </trans-unit>
        <trans-unit id="d71f5749e9e28d5922b96f1c26e811052165fc71" translate="yes" xml:space="preserve">
          <source>Retrieving external keys</source>
          <target state="translated">외부 키 검색</target>
        </trans-unit>
        <trans-unit id="6fc93fde5d23bf392c79a9f984537ca96d065420" translate="yes" xml:space="preserve">
          <source>Return a random key from the currently selected database.</source>
          <target state="translated">현재 선택된 데이터베이스에서 임의의 키를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="6fd47a35bf916d5d67439ea375fe4e2fb769d84c" translate="yes" xml:space="preserve">
          <source>Return the UNIX TIME of the last DB save executed with success. A client may check if a &lt;a href=&quot;bgsave&quot;&gt;BGSAVE&lt;/a&gt; command succeeded reading the &lt;a href=&quot;lastsave&quot;&gt;LASTSAVE&lt;/a&gt; value, then issuing a &lt;a href=&quot;bgsave&quot;&gt;BGSAVE&lt;/a&gt; command and checking at regular intervals every N seconds if &lt;a href=&quot;lastsave&quot;&gt;LASTSAVE&lt;/a&gt; changed.</source>
          <target state="translated">성공적으로 실행 된 마지막 DB 저장의 UNIX 시간을 반환합니다. 클라이언트는 &lt;a href=&quot;bgsave&quot;&gt;BGSAVE&lt;/a&gt; 명령이 &lt;a href=&quot;lastsave&quot;&gt;LASTSAVE&lt;/a&gt; 값을 읽는 데 성공 했는지 확인한 다음 &lt;a href=&quot;bgsave&quot;&gt;BGSAVE&lt;/a&gt; 명령 을 발행하고 &lt;a href=&quot;lastsave&quot;&gt;LASTSAVE가&lt;/a&gt; 변경된 경우 N 초마다 정기적으로 점검 합니다.</target>
        </trans-unit>
        <trans-unit id="7298f92c54146228ead6d1a31b40025056a03b02" translate="yes" xml:space="preserve">
          <source>Return the distance between two members in the geospatial index represented by the sorted set.</source>
          <target state="translated">정렬 된 세트로 표시되는 지리 공간 인덱스에서 두 멤버 사이의 거리를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="1bb126873153beb4e986e8428f3f0a902f06d1bc" translate="yes" xml:space="preserve">
          <source>Return the members of a sorted set populated with geospatial information using &lt;a href=&quot;geoadd&quot;&gt;GEOADD&lt;/a&gt;, which are within the borders of the area specified with the center location and the maximum distance from the center (the radius).</source>
          <target state="translated">&lt;a href=&quot;geoadd&quot;&gt;GEOADD를&lt;/a&gt; 사용하여 지리 공간 정보로 채워진 정렬 된 세트의 멤버를 리턴하십시오. 이 위치는 중심 위치와 중심으로부터 최대 거리 (반경)로 지정된 영역의 경계 내에 있습니다.</target>
        </trans-unit>
        <trans-unit id="a7ff116fa994743f4fb0646cce53a6396e097c89" translate="yes" xml:space="preserve">
          <source>Return the number of keys in the currently-selected database.</source>
          <target state="translated">현재 선택된 데이터베이스의 키 수를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="06398ca22b9ef82a3c94cf8b1160f8f9c766b74a" translate="yes" xml:space="preserve">
          <source>Return the position of the first bit set to 1 or 0 in a string.</source>
          <target state="translated">문자열에서 첫 번째 비트의 위치를 ​​1 또는 0으로 반환합니다.</target>
        </trans-unit>
        <trans-unit id="1d1482b5db471b056549fa1a5580198ec9701587" translate="yes" xml:space="preserve">
          <source>Return the positions (longitude,latitude) of all the specified members of the geospatial index represented by the sorted set at &lt;em&gt;key&lt;/em&gt;.</source>
          <target state="translated">&lt;em&gt;key로&lt;/em&gt; 정렬 된 세트로 표시되는 지리 공간 인덱스의 지정된 모든 멤버의 위치 (경도, 위도)를 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="0492bdeb7afe890056ed3d150bcd3cc644b0be83" translate="yes" xml:space="preserve">
          <source>Return valid &lt;a href=&quot;https://en.wikipedia.org/wiki/Geohash&quot;&gt;Geohash&lt;/a&gt; strings representing the position of one or more elements in a sorted set value representing a geospatial index (where elements were added using &lt;a href=&quot;geoadd&quot;&gt;GEOADD&lt;/a&gt;).</source>
          <target state="translated">지리 공간 인덱스 ( &lt;a href=&quot;geoadd&quot;&gt;GEOADD를&lt;/a&gt; 사용하여 요소가 추가 된 위치)를 나타내는 정렬 된 세트 값에서 하나 이상의 요소 위치를 나타내는 유효한 &lt;a href=&quot;https://en.wikipedia.org/wiki/Geohash&quot;&gt;Geohash&lt;/a&gt; 문자열을 리턴합니다 .</target>
        </trans-unit>
        <trans-unit id="232f3db04c4faa620bfbfc11fd3689a472ef9881" translate="yes" xml:space="preserve">
          <source>Return value</source>
          <target state="translated">반환 값</target>
        </trans-unit>
        <trans-unit id="864674bcd0783b3457690f475310b938e42a7db7" translate="yes" xml:space="preserve">
          <source>Returning a maximum number of entries</source>
          <target state="translated">최대 항목 수 반환</target>
        </trans-unit>
        <trans-unit id="8f278b9f0e4f851622b8ed184503714c9eb2b40b" translate="yes" xml:space="preserve">
          <source>Returning items in a specific time range. This is possible because Stream IDs are &lt;a href=&quot;https://redis.io/topics/streams-intro&quot;&gt;related to time&lt;/a&gt;.</source>
          <target state="translated">특정 시간 범위 내 품목 반품 이것은 스트림 ID가 &lt;a href=&quot;https://redis.io/topics/streams-intro&quot;&gt;시간과 관련되어&lt;/a&gt; 있기 때문에 가능합니다 .</target>
        </trans-unit>
        <trans-unit id="6fecab38b77030a1f63f2810d6747aa68c069f23" translate="yes" xml:space="preserve">
          <source>Returns &lt;a href=&quot;https://redis.io/topics/protocol#array-reply&quot;&gt;Array reply&lt;/a&gt; of details about all Redis commands.</source>
          <target state="translated">모든 Redis 명령에 대한 세부 사항의 &lt;a href=&quot;https://redis.io/topics/protocol#array-reply&quot;&gt;배열 응답&lt;/a&gt; 을 리턴 합니다.</target>
        </trans-unit>
        <trans-unit id="fc344310aece8efa4afcb637dd3fdf8dc24fa45b" translate="yes" xml:space="preserve">
          <source>Returns &lt;a href=&quot;https://redis.io/topics/protocol#array-reply&quot;&gt;Array reply&lt;/a&gt; of details about multiple Redis commands.</source>
          <target state="translated">여러 Redis 명령에 대한 세부 정보의 &lt;a href=&quot;https://redis.io/topics/protocol#array-reply&quot;&gt;배열 응답&lt;/a&gt; 을 반환 합니다.</target>
        </trans-unit>
        <trans-unit id="4a134a2f3cf379373d004a605091cb6cf69dedcb" translate="yes" xml:space="preserve">
          <source>Returns &lt;a href=&quot;https://redis.io/topics/protocol#array-reply&quot;&gt;Array reply&lt;/a&gt; of keys from a full Redis command.</source>
          <target state="translated">전체 Redis 명령에서 키의 &lt;a href=&quot;https://redis.io/topics/protocol#array-reply&quot;&gt;배열 응답&lt;/a&gt; 을 반환 합니다.</target>
        </trans-unit>
        <trans-unit id="bce4982fceed9f9a0c759decc9c92ecb37cc9be2" translate="yes" xml:space="preserve">
          <source>Returns &lt;a href=&quot;https://redis.io/topics/protocol#integer-reply&quot;&gt;Integer reply&lt;/a&gt; of number of total commands in this Redis server.</source>
          <target state="translated">이 Redis 서버의 총 명령 수에 &lt;a href=&quot;https://redis.io/topics/protocol#integer-reply&quot;&gt;대한 정수 응답&lt;/a&gt; 을 리턴 합니다.</target>
        </trans-unit>
        <trans-unit id="a915d042e7bc17cfcfeeccbd870dfc5af9c1ca16" translate="yes" xml:space="preserve">
          <source>Returns &lt;code&gt;PONG&lt;/code&gt; if no argument is provided, otherwise return a copy of the argument as a bulk. This command is often used to test if a connection is still alive, or to measure latency.</source>
          <target state="translated">반환 &lt;code&gt;PONG&lt;/code&gt; 에는 인수가 제공되지 않는 경우는 true, 그렇지 않은 경우는 대량으로 인수의 사본을 반환한다. 이 명령은 연결이 아직 활성 상태인지 테스트하거나 대기 시간을 측정하는 데 자주 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="dd1b58db010b114867573670782f464e9b034412" translate="yes" xml:space="preserve">
          <source>Returns &lt;code&gt;message&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;message&lt;/code&gt; 반환 합니다 .</target>
        </trans-unit>
        <trans-unit id="a8491e8a1858fe4a13538635b038fd1bb846df79" translate="yes" xml:space="preserve">
          <source>Returns all field names in the hash stored at &lt;code&gt;key&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;key&lt;/code&gt; 에 저장된 해시의 모든 필드 이름을 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="514836e0465ae87a7f738140eb4e2b3ae4475e1f" translate="yes" xml:space="preserve">
          <source>Returns all fields and values of the hash stored at &lt;code&gt;key&lt;/code&gt;. In the returned value, every field name is followed by its value, so the length of the reply is twice the size of the hash.</source>
          <target state="translated">&lt;code&gt;key&lt;/code&gt; 에 저장된 해시의 모든 필드와 값을 반환합니다 . 리턴 된 값에서 모든 필드 이름 뒤에 값이 오므로 응답 길이는 해시 크기의 두 배입니다.</target>
        </trans-unit>
        <trans-unit id="e9924b464875fe91e2b89cf6f97649ff9ec1b5ce" translate="yes" xml:space="preserve">
          <source>Returns all keys matching &lt;code&gt;pattern&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;pattern&lt;/code&gt; 과 일치하는 모든 키를 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="1ceba3296cc87483f6becfe1cdae897e811a1b1e" translate="yes" xml:space="preserve">
          <source>Returns all the elements in the sorted set at &lt;code&gt;key&lt;/code&gt; with a score between &lt;code&gt;max&lt;/code&gt; and &lt;code&gt;min&lt;/code&gt; (including elements with score equal to &lt;code&gt;max&lt;/code&gt; or &lt;code&gt;min&lt;/code&gt;). In contrary to the default ordering of sorted sets, for this command the elements are considered to be ordered from high to low scores.</source>
          <target state="translated">&lt;code&gt;max&lt;/code&gt; 에서 &lt;code&gt;min&lt;/code&gt; 사이의 점수를 가진 &lt;code&gt;key&lt;/code&gt; 에서 정렬 된 세트의 모든 요소를 ​​반환합니다 (점수가 &lt;code&gt;max&lt;/code&gt; 또는 &lt;code&gt;min&lt;/code&gt; 인 요소 포함 ). 정렬 된 세트의 기본 순서와 반대로이 명령의 경우 요소가 높은 점수에서 낮은 점수로 정렬 된 것으로 간주됩니다.</target>
        </trans-unit>
        <trans-unit id="6def9bec387c3e744963c6ac4b0bf7f4010504e6" translate="yes" xml:space="preserve">
          <source>Returns all the elements in the sorted set at &lt;code&gt;key&lt;/code&gt; with a score between &lt;code&gt;min&lt;/code&gt; and &lt;code&gt;max&lt;/code&gt; (including elements with score equal to &lt;code&gt;min&lt;/code&gt; or &lt;code&gt;max&lt;/code&gt;). The elements are considered to be ordered from low to high scores.</source>
          <target state="translated">&lt;code&gt;min&lt;/code&gt; 과 &lt;code&gt;max&lt;/code&gt; 사이의 점수를 가진 &lt;code&gt;key&lt;/code&gt; 에서 정렬 된 세트의 모든 요소를 ​​반환합니다 (점수가 &lt;code&gt;min&lt;/code&gt; 또는 &lt;code&gt;max&lt;/code&gt; 와 같은 요소 포함 ). 요소는 낮은 점수에서 높은 점수로 정렬 된 것으로 간주됩니다.</target>
        </trans-unit>
        <trans-unit id="1925ffaf420a57d589c1888eb5b09007e4f1d203" translate="yes" xml:space="preserve">
          <source>Returns all the members of the set value stored at &lt;code&gt;key&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;key&lt;/code&gt; 에 저장된 설정 값의 모든 멤버를 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="c11f5fe0471c6d472d362d6dbbf041c048b49125" translate="yes" xml:space="preserve">
          <source>Returns all values in the hash stored at &lt;code&gt;key&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;key&lt;/code&gt; 에 저장된 해시의 모든 값을 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="4792ce321c7a364f3dc2071cf137fcc522daf25d" translate="yes" xml:space="preserve">
          <source>Returns an integer identifying the hash slot the specified key hashes to. This command is mainly useful for debugging and testing, since it exposes via an API the underlying Redis implementation of the hashing algorithm. Example use cases for this command:</source>
          <target state="translated">지정된 키 해시가 해시 슬롯을 식별하는 정수를 반환합니다. 이 명령은 API를 통해 해시 알고리즘의 기본 Redis 구현을 노출하므로 디버깅 및 테스트에 주로 유용합니다. 이 명령의 사용 사례 예 :</target>
        </trans-unit>
        <trans-unit id="899ca03feedce83f7aa728b87a784b60bd95adf0" translate="yes" xml:space="preserve">
          <source>Returns if &lt;code&gt;field&lt;/code&gt; is an existing field in the hash stored at &lt;code&gt;key&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;field&lt;/code&gt; 가 &lt;code&gt;key&lt;/code&gt; 에 저장된 해시의 기존 필드 인지 여부를 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="5e13b7a867bbaf0e4121d5da403d54edbe4a8b1f" translate="yes" xml:space="preserve">
          <source>Returns if &lt;code&gt;key&lt;/code&gt; exists.</source>
          <target state="translated">&lt;code&gt;key&lt;/code&gt; 가 존재 하면 반환 합니다.</target>
        </trans-unit>
        <trans-unit id="163373a24e8be296b7e7c88d0c4da2f59ceca677" translate="yes" xml:space="preserve">
          <source>Returns if &lt;code&gt;member&lt;/code&gt; is a member of the set stored at &lt;code&gt;key&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;member&lt;/code&gt; 가 &lt;code&gt;key&lt;/code&gt; 에 저장된 세트의 멤버 인지 여부를 리턴합니다 .</target>
        </trans-unit>
        <trans-unit id="abd92cbd9d7d0b6e4392a36873fd8c21767b398a" translate="yes" xml:space="preserve">
          <source>Returns information about the existence of the scripts in the script cache.</source>
          <target state="translated">스크립트 캐시에 스크립트가 있는지에 대한 정보를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="13855077d7cb93a1fce1c3432c59e7e463ea29a6" translate="yes" xml:space="preserve">
          <source>Returns or stores the elements contained in the &lt;a href=&quot;https://redis.io/topics/data-types#lists&quot;&gt;list&lt;/a&gt;, &lt;a href=&quot;https://redis.io/topics/data-types#set&quot;&gt;set&lt;/a&gt; or &lt;a href=&quot;https://redis.io/topics/data-types#sorted-sets&quot;&gt;sorted set&lt;/a&gt; at &lt;code&gt;key&lt;/code&gt;. By default, sorting is numeric and elements are compared by their value interpreted as double precision floating point number. This is &lt;a href=&quot;sort&quot;&gt;SORT&lt;/a&gt; in its simplest form:</source>
          <target state="translated">반환 또는 저장 요소가 포함 &lt;a href=&quot;https://redis.io/topics/data-types#lists&quot;&gt;목록&lt;/a&gt; , &lt;a href=&quot;https://redis.io/topics/data-types#set&quot;&gt;세트&lt;/a&gt; 또는 &lt;a href=&quot;https://redis.io/topics/data-types#sorted-sets&quot;&gt;소트 세트&lt;/a&gt; 에서 &lt;code&gt;key&lt;/code&gt; . 기본적으로 정렬은 숫자이고 요소는 배정 밀도 부동 소수점 숫자로 해석 된 값으로 비교됩니다. 이것은 가장 간단한 형태의 &lt;a href=&quot;sort&quot;&gt;SORT&lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="f68574957008d127438140f50ac56b278260cf09" translate="yes" xml:space="preserve">
          <source>Returns the bit value at &lt;em&gt;offset&lt;/em&gt; in the string value stored at &lt;em&gt;key&lt;/em&gt;.</source>
          <target state="translated">&lt;em&gt;key에&lt;/em&gt; 저장된 문자열 값에서 &lt;em&gt;오프셋&lt;/em&gt; 의 비트 값을 반환합니다 .&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="e6d63c7c2388918da907438c78c891dff4a16999" translate="yes" xml:space="preserve">
          <source>Returns the element at index &lt;code&gt;index&lt;/code&gt; in the list stored at &lt;code&gt;key&lt;/code&gt;. The index is zero-based, so &lt;code&gt;0&lt;/code&gt; means the first element, &lt;code&gt;1&lt;/code&gt; the second element and so on. Negative indices can be used to designate elements starting at the tail of the list. Here, &lt;code&gt;-1&lt;/code&gt; means the last element, &lt;code&gt;-2&lt;/code&gt; means the penultimate and so forth.</source>
          <target state="translated">&lt;code&gt;key&lt;/code&gt; 에 저장된 목록 에서 인덱스 &lt;code&gt;index&lt;/code&gt; 의 요소를 리턴합니다 . 인덱스는 0부터 시작하므로 &lt;code&gt;0&lt;/code&gt; 은 첫 번째 요소, &lt;code&gt;1&lt;/code&gt; 은 두 번째 요소 등을 의미합니다. 음수 색인을 사용하여 목록의 끝에서 시작하는 요소를 지정할 수 있습니다. 여기서 &lt;code&gt;-1&lt;/code&gt; 은 마지막 요소를, &lt;code&gt;-2&lt;/code&gt; 는 두 번째 등을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="669652a24b746680e968eb8d19e304712aaafbef" translate="yes" xml:space="preserve">
          <source>Returns the length of the list stored at &lt;code&gt;key&lt;/code&gt;. If &lt;code&gt;key&lt;/code&gt; does not exist, it is interpreted as an empty list and &lt;code&gt;0&lt;/code&gt; is returned. An error is returned when the value stored at &lt;code&gt;key&lt;/code&gt; is not a list.</source>
          <target state="translated">&lt;code&gt;key&lt;/code&gt; 에 저장된 목록의 길이를 반환합니다 . 경우 &lt;code&gt;key&lt;/code&gt; 존재하지 않는, 그것은 빈 목록으로 해석되고 &lt;code&gt;0&lt;/code&gt; 이 반환됩니다. &lt;code&gt;key&lt;/code&gt; 저장된 값 이 목록이 아닌 경우 오류가 리턴됩니다 .</target>
        </trans-unit>
        <trans-unit id="b1b9de7b079dd5e1ad7bef3504c123ad01db9ecc" translate="yes" xml:space="preserve">
          <source>Returns the length of the string value stored at &lt;code&gt;key&lt;/code&gt;. An error is returned when &lt;code&gt;key&lt;/code&gt; holds a non-string value.</source>
          <target state="translated">&lt;code&gt;key&lt;/code&gt; 에 저장된 문자열 값의 길이를 반환합니다 . &lt;code&gt;key&lt;/code&gt; 가 문자열이 아닌 값을 보유 하면 오류가 리턴됩니다 .</target>
        </trans-unit>
        <trans-unit id="5ca8167d0a845062b5e1c8307dc022d4e1bbe99c" translate="yes" xml:space="preserve">
          <source>Returns the members of the set resulting from the difference between the first set and all the successive sets.</source>
          <target state="translated">첫 번째 세트와 모든 후속 세트의 차이로 인해 세트의 멤버를 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="65286cf35136f5258861b04a7983164ea5b463a3" translate="yes" xml:space="preserve">
          <source>Returns the members of the set resulting from the intersection of all the given sets.</source>
          <target state="translated">주어진 모든 세트의 교집합에서 나온 세트의 멤버를 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="473b41ab8be68badcb9ee743f59ebda61ccb6efd" translate="yes" xml:space="preserve">
          <source>Returns the members of the set resulting from the union of all the given sets.</source>
          <target state="translated">주어진 모든 집합의 합집합으로 인해 집합의 멤버를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="ae58574da7b69acb45d5608e905fbe416f5828a3" translate="yes" xml:space="preserve">
          <source>Returns the number of elements in the sorted set at &lt;code&gt;key&lt;/code&gt; with a score between &lt;code&gt;min&lt;/code&gt; and &lt;code&gt;max&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;key&lt;/code&gt; 에서 정렬 세트의 요소 수를 &lt;code&gt;min&lt;/code&gt; 과 &lt;code&gt;max&lt;/code&gt; 사이의 점수로 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="4ba5a6e2cdf681a72b81189fc73dab62a38a2630" translate="yes" xml:space="preserve">
          <source>Returns the number of entries inside a stream. If the specified key does not exist the command returns zero, as if the stream was empty. However note that unlike other Redis types, zero-length streams are possible, so you should call &lt;a href=&quot;type&quot;&gt;TYPE&lt;/a&gt; or &lt;a href=&quot;exists&quot;&gt;EXISTS&lt;/a&gt; in order to check if a key exists or not.</source>
          <target state="translated">스트림 내부의 항목 수를 반환합니다. 지정된 키가 없으면 스트림이 비어있는 것처럼 명령이 0을 리턴합니다. 그러나 다른 Redis 유형과 달리 길이가 0 인 스트림이 가능하므로 키가 있는지 여부를 확인하려면 &lt;a href=&quot;type&quot;&gt;TYPE&lt;/a&gt; 또는 &lt;a href=&quot;exists&quot;&gt;EXISTS&lt;/a&gt; 를 호출해야합니다 .</target>
        </trans-unit>
        <trans-unit id="05ec2c01f1e7966c86d566259fe9827a1ce5788e" translate="yes" xml:space="preserve">
          <source>Returns the number of fields contained in the hash stored at &lt;code&gt;key&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;key&lt;/code&gt; 에 저장된 해시에 포함 된 필드 수를 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="cba9b6e741951a2ea3575443214cf403c194bc0f" translate="yes" xml:space="preserve">
          <source>Returns the number of keys in the specified Redis Cluster hash slot. The command only queries the local data set, so contacting a node that is not serving the specified hash slot will always result in a count of zero being returned.</source>
          <target state="translated">지정된 Redis Cluster 해시 슬롯의 키 수를 반환합니다. 이 명령은 로컬 데이터 세트 만 쿼리하므로 지정된 해시 슬롯을 제공하지 않는 노드에 연결하면 항상 카운트 0이 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="567352a29cfaef33a8cd3fcbcac829c78575fb62" translate="yes" xml:space="preserve">
          <source>Returns the number of subscribers (not counting clients subscribed to patterns) for the specified channels.</source>
          <target state="translated">지정된 채널의 구독자 수 (패턴에 구독 한 클라이언트는 제외)를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="56eb7af42eb7b4bb5b7efb363837228225fedb8e" translate="yes" xml:space="preserve">
          <source>Returns the number of subscriptions to patterns (that are performed using the &lt;a href=&quot;psubscribe&quot;&gt;PSUBSCRIBE&lt;/a&gt; command). Note that this is not just the count of clients subscribed to patterns but the total number of patterns all the clients are subscribed to.</source>
          <target state="translated">패턴에 대한 구독 수를 리턴합니다 ( &lt;a href=&quot;psubscribe&quot;&gt;PSUBSCRIBE&lt;/a&gt; 명령을 사용하여 수행됨 ). 이는 패턴을 구독 한 클라이언트의 수가 아니라 모든 클라이언트가 구독 한 총 패턴 수입니다.</target>
        </trans-unit>
        <trans-unit id="029e626a83e98d1ddd2b45f2a08391faf674382c" translate="yes" xml:space="preserve">
          <source>Returns the rank of &lt;code&gt;member&lt;/code&gt; in the sorted set stored at &lt;code&gt;key&lt;/code&gt;, with the scores ordered from high to low. The rank (or index) is 0-based, which means that the member with the highest score has rank &lt;code&gt;0&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;key&lt;/code&gt; 저장된 정렬 된 세트에서 &lt;code&gt;member&lt;/code&gt; 의 순위 를 높은 순서에서 낮은 순서로 리턴합니다 . 순위 (또는 인덱스)는 0을 기준으로합니다. 즉, 가장 높은 점수를받은 멤버의 순위는 &lt;code&gt;0&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="04ac6b8e04ac2d5fa91a42abbe270ab24969dcf8" translate="yes" xml:space="preserve">
          <source>Returns the rank of &lt;code&gt;member&lt;/code&gt; in the sorted set stored at &lt;code&gt;key&lt;/code&gt;, with the scores ordered from low to high. The rank (or index) is 0-based, which means that the member with the lowest score has rank &lt;code&gt;0&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;key&lt;/code&gt; 저장된 정렬 된 세트에서 &lt;code&gt;member&lt;/code&gt; 의 순위 를 낮은 순서에서 높은 순서로 리턴합니다 . 순위 (또는 인덱스)는 0을 기준으로합니다. 즉, 점수가 가장 낮은 멤버의 순위는 &lt;code&gt;0&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="dac65708cc841972517b49f4a323aba557dd7743" translate="yes" xml:space="preserve">
          <source>Returns the remaining time to live of a key that has a timeout. This introspection capability allows a Redis client to check how many seconds a given key will continue to be part of the dataset.</source>
          <target state="translated">시간 초과가있는 키의 남은 시간을 반환합니다. 이 내부 검사 기능을 통해 Redis 클라이언트는 주어진 키가 데이터 세트의 일부로 몇 초 동안 계속 있는지 확인할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="bdaf416765952fb3c543f080075ad7115471f130" translate="yes" xml:space="preserve">
          <source>Returns the score of &lt;code&gt;member&lt;/code&gt; in the sorted set at &lt;code&gt;key&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;key&lt;/code&gt; 에서 정렬 된 세트 의 &lt;code&gt;member&lt;/code&gt; 점수를 리턴합니다 .</target>
        </trans-unit>
        <trans-unit id="0525192497ba351f01f7c69505a721186043f122" translate="yes" xml:space="preserve">
          <source>Returns the set cardinality (number of elements) of the set stored at &lt;code&gt;key&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;key&lt;/code&gt; 에 저장된 세트의 카디널리티 (요소 수)를 리턴합니다 .</target>
        </trans-unit>
        <trans-unit id="538e8ccb043255bf1866a8c948a35b08642708eb" translate="yes" xml:space="preserve">
          <source>Returns the sorted set cardinality (number of elements) of the sorted set stored at &lt;code&gt;key&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;key&lt;/code&gt; 에 저장된 정렬 된 세트의 정렬 된 세트 카디널리티 (요소 수)를 리턴합니다 .</target>
        </trans-unit>
        <trans-unit id="aed5ad61cf2dae51ecb526ffeb96e8ae6f66dd61" translate="yes" xml:space="preserve">
          <source>Returns the specified elements of the list stored at &lt;code&gt;key&lt;/code&gt;. The offsets &lt;code&gt;start&lt;/code&gt; and &lt;code&gt;stop&lt;/code&gt; are zero-based indexes, with &lt;code&gt;0&lt;/code&gt; being the first element of the list (the head of the list), &lt;code&gt;1&lt;/code&gt; being the next element and so on.</source>
          <target state="translated">&lt;code&gt;key&lt;/code&gt; 에 저장된 목록의 지정된 요소를 반환합니다 . 오프셋 &lt;code&gt;start&lt;/code&gt; 및 &lt;code&gt;stop&lt;/code&gt; 는 0 부터 시작 하는 인덱스이며 &lt;code&gt;0&lt;/code&gt; 은 목록의 첫 번째 요소 (목록의 헤드)이고 &lt;code&gt;1&lt;/code&gt; 은 다음 요소 등입니다.</target>
        </trans-unit>
        <trans-unit id="165e254b16f95c82b554bb625de96b2c2d45635e" translate="yes" xml:space="preserve">
          <source>Returns the specified range of elements in the sorted set stored at &lt;code&gt;key&lt;/code&gt;. The elements are considered to be ordered from the highest to the lowest score. Descending lexicographical order is used for elements with equal score.</source>
          <target state="translated">&lt;code&gt;key&lt;/code&gt; 에 저장된 정렬 된 세트에서 지정된 요소 범위를 리턴합니다 . 요소는 가장 높은 점수에서 가장 낮은 점수로 정렬 된 것으로 간주됩니다. 내림차순이 내림차순으로 점수가 같은 요소에 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="c5f3848ec567b8c9da3f19a86ff736fd69145ae8" translate="yes" xml:space="preserve">
          <source>Returns the specified range of elements in the sorted set stored at &lt;code&gt;key&lt;/code&gt;. The elements are considered to be ordered from the lowest to the highest score. Lexicographical order is used for elements with equal score.</source>
          <target state="translated">&lt;code&gt;key&lt;/code&gt; 에 저장된 정렬 된 세트에서 지정된 요소 범위를 리턴합니다 . 요소는 가장 낮은 점수에서 가장 높은 점수로 정렬 된 것으로 간주됩니다. 사전 순서는 점수가 같은 요소에 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="d28b315a7a61b9bf04b21fccdd6ae5bd4f8eb130" translate="yes" xml:space="preserve">
          <source>Returns the string length of the value associated with &lt;code&gt;field&lt;/code&gt; in the hash stored at &lt;code&gt;key&lt;/code&gt;. If the &lt;code&gt;key&lt;/code&gt; or the &lt;code&gt;field&lt;/code&gt; do not exist, 0 is returned.</source>
          <target state="translated">&lt;code&gt;key&lt;/code&gt; 에 저장된 해시의 &lt;code&gt;field&lt;/code&gt; 와 관련된 값의 문자열 길이를 반환합니다 . 는 IF &lt;code&gt;key&lt;/code&gt; 또는 &lt;code&gt;field&lt;/code&gt; 존재하지 않는, 0이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="ffb4e3b3a6a5708cfdef83bd04363741160ed0a4" translate="yes" xml:space="preserve">
          <source>Returns the string representation of the type of the value stored at &lt;code&gt;key&lt;/code&gt;. The different types that can be returned are: &lt;code&gt;string&lt;/code&gt;, &lt;code&gt;list&lt;/code&gt;, &lt;code&gt;set&lt;/code&gt;, &lt;code&gt;zset&lt;/code&gt; and &lt;code&gt;hash&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;key&lt;/code&gt; 에 저장된 값 유형의 문자열 표현을 리턴합니다 . 리턴 될 수있는 다른 유형은 &lt;code&gt;string&lt;/code&gt; , &lt;code&gt;list&lt;/code&gt; , &lt;code&gt;set&lt;/code&gt; , &lt;code&gt;zset&lt;/code&gt; 및 &lt;code&gt;hash&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="8a246620818088ec9a16f70b9fb4ae809aad9ad2" translate="yes" xml:space="preserve">
          <source>Returns the substring of the string value stored at &lt;code&gt;key&lt;/code&gt;, determined by the offsets &lt;code&gt;start&lt;/code&gt; and &lt;code&gt;end&lt;/code&gt; (both are inclusive). Negative offsets can be used in order to provide an offset starting from the end of the string. So -1 means the last character, -2 the penultimate and so forth.</source>
          <target state="translated">오프셋 &lt;code&gt;start&lt;/code&gt; 및 &lt;code&gt;end&lt;/code&gt; 에 따라 &lt;code&gt;key&lt;/code&gt; 에 저장된 문자열 값의 하위 문자열을 반환합니다 (둘 다 포함). 문자열 끝에서 시작하여 오프셋을 제공하기 위해 음수 오프셋을 사용할 수 있습니다. 따라서 -1은 마지막 문자, -2는 두 번째 등을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="ff8cb8f9712a465de8610b460278556869c01387" translate="yes" xml:space="preserve">
          <source>Returns the value associated with &lt;code&gt;field&lt;/code&gt; in the hash stored at &lt;code&gt;key&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;key&lt;/code&gt; 에 저장된 해시의 &lt;code&gt;field&lt;/code&gt; 와 관련된 값을 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="6e8fea73a6efe9b1e714890adedb119e477e5b94" translate="yes" xml:space="preserve">
          <source>Returns the values associated with the specified &lt;code&gt;fields&lt;/code&gt; in the hash stored at &lt;code&gt;key&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;key&lt;/code&gt; 에 저장된 해시에서 지정된 &lt;code&gt;fields&lt;/code&gt; 와 연관된 값을 리턴합니다 .</target>
        </trans-unit>
        <trans-unit id="2a3f6c24ab0b5bf50119e41442adccdd069520b2" translate="yes" xml:space="preserve">
          <source>Returns the values of all specified keys. For every key that does not hold a string value or does not exist, the special value &lt;code&gt;nil&lt;/code&gt; is returned. Because of this, the operation never fails.</source>
          <target state="translated">지정된 모든 키의 값을 돌려줍니다. 문자열 값을 보유하지 않거나 존재하지 않는 모든 키에 대해 특수 값 &lt;code&gt;nil&lt;/code&gt; 이 리턴됩니다. 이로 인해 작업이 실패하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="33fe03995fd835515d8b0c378391e0d80d6d96a2" translate="yes" xml:space="preserve">
          <source>Running the bitmap incrementally using the &lt;a href=&quot;bitcount&quot;&gt;BITCOUNT&lt;/a&gt;&lt;em&gt;start&lt;/em&gt; and &lt;em&gt;end&lt;/em&gt; optional parameters, accumulating the results client-side, and optionally caching the result into a key.</source>
          <target state="translated">&lt;a href=&quot;bitcount&quot;&gt;BITCOUNT &lt;/a&gt;&lt;em&gt;시작&lt;/em&gt; 및 &lt;em&gt;종료&lt;/em&gt; 선택적 매개 변수를 사용하여 비트 맵을 증분 실행하고 결과를 클라이언트 측에 누적하고 선택적으로 결과를 키에 캐싱합니다.</target>
        </trans-unit>
        <trans-unit id="afc896d0c818d9d81d1502addeeed94d978515cb" translate="yes" xml:space="preserve">
          <source>SADD</source>
          <target state="translated">SADD</target>
        </trans-unit>
        <trans-unit id="afe4d83e232611365cc3a02706eeee448267b671" translate="yes" xml:space="preserve">
          <source>SADD  key member [member ...]   Add one or more members to a set</source>
          <target state="translated">SADD 키 멤버 [member ...] 하나 이상의 멤버를 세트에 추가</target>
        </trans-unit>
        <trans-unit id="508156a39b09ccfe61cc81d984e9317e5e0d8eec" translate="yes" xml:space="preserve">
          <source>SAVE</source>
          <target state="translated">SAVE</target>
        </trans-unit>
        <trans-unit id="a806788f2be230df4e533ace9d23ff41f5ebd919" translate="yes" xml:space="preserve">
          <source>SAVE   Synchronously save the dataset to disk</source>
          <target state="translated">저장 데이터 세트를 디스크에 동기 저장</target>
        </trans-unit>
        <trans-unit id="65b4fd3a026ef6fa00d5747035f289ef54695f24" translate="yes" xml:space="preserve">
          <source>SAVE and NOSAVE modifiers</source>
          <target state="translated">저장 및 NOSAVE 수정 자</target>
        </trans-unit>
        <trans-unit id="c5a19955ea5dab3fd18ab68f367f98693df1b60b" translate="yes" xml:space="preserve">
          <source>SCAN</source>
          <target state="translated">SCAN</target>
        </trans-unit>
        <trans-unit id="f6a353aff0f0da25a0e7f7c1d96621ee0a75fe99" translate="yes" xml:space="preserve">
          <source>SCAN  cursor [MATCH pattern] [COUNT count]   Incrementally iterate the keys space</source>
          <target state="translated">SCAN 커서 [MATCH 패턴] [COUNT 수] 키 공간을 증분 반복</target>
        </trans-unit>
        <trans-unit id="f904e681db7d6de1d40ec70145524cd0367d1bf0" translate="yes" xml:space="preserve">
          <source>SCAN basic usage</source>
          <target state="translated">SCAN 기본 사용법</target>
        </trans-unit>
        <trans-unit id="aa3b23325236e95772d7cd2d8a5db2f2530e669f" translate="yes" xml:space="preserve">
          <source>SCAN is a cursor based iterator. This means that at every call of the command, the server returns an updated cursor that the user needs to use as the cursor argument in the next call.</source>
          <target state="translated">SCAN은 커서 기반 반복자입니다. 이는 명령이 호출 될 때마다 서버가 사용자가 다음 호출에서 커서 인수로 사용해야하는 업데이트 된 커서를 리턴 함을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="0431790b7b638b530f089a6638b4b046bf245d05" translate="yes" xml:space="preserve">
          <source>SCARD</source>
          <target state="translated">SCARD</target>
        </trans-unit>
        <trans-unit id="45b0af77625a8e40fbd9c79a72bf85a01a682a2e" translate="yes" xml:space="preserve">
          <source>SCARD  key   Get the number of members in a set</source>
          <target state="translated">SCARD 키 세트의 멤버 수를 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="46ab5a918078b88865c34d46d45763f78a5cc2a8" translate="yes" xml:space="preserve">
          <source>SCRIPT</source>
          <target state="translated">SCRIPT</target>
        </trans-unit>
        <trans-unit id="942ec0d4567f537a05d81b40e79ed670c8098df1" translate="yes" xml:space="preserve">
          <source>SCRIPT DEBUG  YES|SYNC|NO   Set the debug mode for executed scripts.</source>
          <target state="translated">SCRIPT DEBUG YES | SYNC | NO 실행 된 스크립트의 디버그 모드를 설정하십시오.</target>
        </trans-unit>
        <trans-unit id="d4f0300810cbd56a02078e94b26444e04a369df1" translate="yes" xml:space="preserve">
          <source>SCRIPT EXISTS  sha1 [sha1 ...]   Check existence of scripts in the script cache.</source>
          <target state="translated">SCRIPT EXISTS sha1 [sha1 ...] 스크립트 캐시에 스크립트가 있는지 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="155351693709972a944322985f623357a60203d8" translate="yes" xml:space="preserve">
          <source>SCRIPT FLUSH</source>
          <target state="translated">스크립트 FLUSH</target>
        </trans-unit>
        <trans-unit id="ff5ac14542c8a5c4ff717c937c92483157332c48" translate="yes" xml:space="preserve">
          <source>SCRIPT FLUSH   Remove all the scripts from the script cache.</source>
          <target state="translated">SCRIPT FLUSH 스크립트 캐시에서 모든 스크립트를 제거하십시오.</target>
        </trans-unit>
        <trans-unit id="5e2a68acdd358effce354e479fe828441291386c" translate="yes" xml:space="preserve">
          <source>SCRIPT KILL</source>
          <target state="translated">스크립트 처치</target>
        </trans-unit>
        <trans-unit id="898216faf82d0e8094a40fff1a1d11316572b3a1" translate="yes" xml:space="preserve">
          <source>SCRIPT KILL   Kill the script currently in execution.</source>
          <target state="translated">SCRIPT KILL 현재 실행중인 스크립트를 종료합니다.</target>
        </trans-unit>
        <trans-unit id="bf00a0ed4afe21cec9ac5006aa471a2c75ce80dd" translate="yes" xml:space="preserve">
          <source>SCRIPT LOAD  script   Load the specified Lua script into the script cache.</source>
          <target state="translated">SCRIPT LOAD 스크립트 지정된 Lua 스크립트를 스크립트 캐시에로드합니다.</target>
        </trans-unit>
        <trans-unit id="605e7c9dd422426230eae60c02acc7d7a5705884" translate="yes" xml:space="preserve">
          <source>SDIFF</source>
          <target state="translated">SDIFF</target>
        </trans-unit>
        <trans-unit id="18d8e0e316b86cf9a259f83877f9d4536e919048" translate="yes" xml:space="preserve">
          <source>SDIFF  key [key ...]   Subtract multiple sets</source>
          <target state="translated">SDIFF 키 [키 ...] 여러 세트 빼기</target>
        </trans-unit>
        <trans-unit id="144b2bd3509fd63bb1b369b8c7665713eb587bd9" translate="yes" xml:space="preserve">
          <source>SDIFFSTORE</source>
          <target state="translated">SDIFFSTORE</target>
        </trans-unit>
        <trans-unit id="de1820fefd3db78a9062bc31ca0bace599879b7b" translate="yes" xml:space="preserve">
          <source>SDIFFSTORE  destination key [key ...]   Subtract multiple sets and store the resulting set in a key</source>
          <target state="translated">SDIFFSTORE 대상 키 [키 ...] 여러 세트를 빼고 결과 세트를 키에 저장</target>
        </trans-unit>
        <trans-unit id="a4942c26d0735947d8a22a2fbe2735a12e381808" translate="yes" xml:space="preserve">
          <source>SELECT</source>
          <target state="translated">SELECT</target>
        </trans-unit>
        <trans-unit id="f439068c5eb4482362ce42c7382665b32a13512a" translate="yes" xml:space="preserve">
          <source>SELECT  index   Change the selected database for the current connection</source>
          <target state="translated">SELECT 인덱스 현재 연결에 대해 선택된 데이터베이스를 변경합니다</target>
        </trans-unit>
        <trans-unit id="55c5d81017a30edf1e47ba1b78c377a5e5ebfd50" translate="yes" xml:space="preserve">
          <source>SET</source>
          <target state="translated">SET</target>
        </trans-unit>
        <trans-unit id="91a720b839d692fc7a7e17565ac1e4963650fe98" translate="yes" xml:space="preserve">
          <source>SET  key value [expiration EX seconds|PX milliseconds] [NX|XX]   Set the string value of a key</source>
          <target state="translated">SET 키 값 [만료 EX 초 | PX 밀리 초] [NX | XX] 키의 문자열 값 설정</target>
        </trans-unit>
        <trans-unit id="7df70cb863a3d3a5e4a199b5d8ef3c9851ce87bf" translate="yes" xml:space="preserve">
          <source>SETBIT</source>
          <target state="translated">SETBIT</target>
        </trans-unit>
        <trans-unit id="b66f69a03f672489d4ae1d69a757435c5b63bd51" translate="yes" xml:space="preserve">
          <source>SETBIT  key offset value   Sets or clears the bit at offset in the string value stored at key</source>
          <target state="translated">SETBIT 키 오프셋 값 키에 저장된 문자열 값에서 오프셋의 비트를 설정하거나 지 웁니다.</target>
        </trans-unit>
        <trans-unit id="c92872db8021ac60dd456ca7447fb52919f32143" translate="yes" xml:space="preserve">
          <source>SETEX</source>
          <target state="translated">SETEX</target>
        </trans-unit>
        <trans-unit id="0b5df1d3ddffe0fdbb568accc5d3c3dac5121afc" translate="yes" xml:space="preserve">
          <source>SETEX  key seconds value   Set the value and expiration of a key</source>
          <target state="translated">SETEX 키 초 값 키의 값과 만료를 설정합니다</target>
        </trans-unit>
        <trans-unit id="1ace6531f1c27b916c1368f17e1a7ae87aa79f97" translate="yes" xml:space="preserve">
          <source>SETNX</source>
          <target state="translated">SETNX</target>
        </trans-unit>
        <trans-unit id="a50f293fa49f962b5d82c0bb86c82df413a498b7" translate="yes" xml:space="preserve">
          <source>SETNX  key value   Set the value of a key, only if the key does not exist</source>
          <target state="translated">SETNX 키 값 키가 존재하지 않는 경우에만 키 값을 설정하십시오.</target>
        </trans-unit>
        <trans-unit id="c1d82383232438676e2182b69bf2797640b1fcd2" translate="yes" xml:space="preserve">
          <source>SETRANGE</source>
          <target state="translated">SETRANGE</target>
        </trans-unit>
        <trans-unit id="a2132f99e69e7919051651c2b4fc7de24734eba2" translate="yes" xml:space="preserve">
          <source>SETRANGE  key offset value   Overwrite part of a string at key starting at the specified offset</source>
          <target state="translated">SETRANGE 키 오프셋 값 지정된 오프셋에서 시작하는 키에서 문자열의 일부를 덮어 씁니다.</target>
        </trans-unit>
        <trans-unit id="ec493147ec1b78adab002626ee80cc23772aded8" translate="yes" xml:space="preserve">
          <source>SHUTDOWN</source>
          <target state="translated">SHUTDOWN</target>
        </trans-unit>
        <trans-unit id="606e1ec5d1ea13b283de4e59cd16289518254c6c" translate="yes" xml:space="preserve">
          <source>SHUTDOWN  [NOSAVE|SAVE]   Synchronously save the dataset to disk and then shut down the server</source>
          <target state="translated">SHUTDOWN [NOSAVE | SAVE] 데이터 세트를 디스크에 동기식으로 저장 한 다음 서버를 종료합니다</target>
        </trans-unit>
        <trans-unit id="c340be94a16bd060ccd24ece053ed10ff4cfb1a2" translate="yes" xml:space="preserve">
          <source>SINTER</source>
          <target state="translated">SINTER</target>
        </trans-unit>
        <trans-unit id="acc6f9a5a6867145ccd5835b170277c3127f8f60" translate="yes" xml:space="preserve">
          <source>SINTER  key [key ...]   Intersect multiple sets</source>
          <target state="translated">SINTER 키 [키 ...] 여러 세트와 교차</target>
        </trans-unit>
        <trans-unit id="ae286ac2efddc7ffc6de81fb4eef82083c5d0d0a" translate="yes" xml:space="preserve">
          <source>SINTERSTORE</source>
          <target state="translated">SINTERSTORE</target>
        </trans-unit>
        <trans-unit id="3cc889bdb24445318099b6bfa98a849204bc5321" translate="yes" xml:space="preserve">
          <source>SINTERSTORE  destination key [key ...]   Intersect multiple sets and store the resulting set in a key</source>
          <target state="translated">SINTERSTORE 대상 키 [key ...] 여러 세트를 교차시키고 결과 세트를 키에 저장</target>
        </trans-unit>
        <trans-unit id="8074903f43c428dec41033b139437bb9d7e46e61" translate="yes" xml:space="preserve">
          <source>SISMEMBER</source>
          <target state="translated">SISMEMBER</target>
        </trans-unit>
        <trans-unit id="2613d73d648b1f6845f55faac8664acb5e2e9af6" translate="yes" xml:space="preserve">
          <source>SISMEMBER  key member   Determine if a given value is a member of a set</source>
          <target state="translated">SISMEMBER 키 멤버 주어진 값이 세트의 멤버인지 판별</target>
        </trans-unit>
        <trans-unit id="bb3731aa645af4f77072e934700ff033a81e173b" translate="yes" xml:space="preserve">
          <source>SLAVEOF</source>
          <target state="translated">SLAVEOF</target>
        </trans-unit>
        <trans-unit id="9bb4401fd3b09a14ad63da1fc4e0ebcc9c0ee189" translate="yes" xml:space="preserve">
          <source>SLAVEOF  host port   Make the server a replica of another instance, or promote it as master. Deprecated starting with Redis 5. Use REPLICAOF instead.</source>
          <target state="translated">SLAVEOF 호스트 포트 서버를 다른 인스턴스의 복제본으로 만들거나 마스터로 승격하십시오. Redis 5부터는 더 이상 사용되지 않습니다. 대신 REPLICAOF를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="4078b703021998b0c963d9636d85d96b1ddfa618" translate="yes" xml:space="preserve">
          <source>SLOWLOG</source>
          <target state="translated">SLOWLOG</target>
        </trans-unit>
        <trans-unit id="acfcd934ccfd2203f5ccc3e824371c24109642b8" translate="yes" xml:space="preserve">
          <source>SLOWLOG  subcommand [argument]   Manages the Redis slow queries log</source>
          <target state="translated">SLOWLOG 하위 명령 [argument] Redis 느린 쿼리 로그를 관리합니다</target>
        </trans-unit>
        <trans-unit id="e6687e28d8b75312f0ea51bc9520b394ec2a7a63" translate="yes" xml:space="preserve">
          <source>SMEMBERS</source>
          <target state="translated">SMEMBERS</target>
        </trans-unit>
        <trans-unit id="fe66421f332187f83010e275c4b51042858f5234" translate="yes" xml:space="preserve">
          <source>SMEMBERS  key   Get all the members in a set</source>
          <target state="translated">SMEMBERS 키 세트의 모든 멤버 가져 오기</target>
        </trans-unit>
        <trans-unit id="20f84dbd21a3d84899dade0a24ef5c6978f0403e" translate="yes" xml:space="preserve">
          <source>SMOVE</source>
          <target state="translated">SMOVE</target>
        </trans-unit>
        <trans-unit id="1f7888e464279456fc99ea1259b436e9ad0d4f64" translate="yes" xml:space="preserve">
          <source>SMOVE  source destination member   Move a member from one set to another</source>
          <target state="translated">SMOVE 소스 대상 멤버 한 세트에서 다른 세트로 멤버 이동</target>
        </trans-unit>
        <trans-unit id="2434fe1de87e4949f51786cc87dd6a83c095a422" translate="yes" xml:space="preserve">
          <source>SORT</source>
          <target state="translated">SORT</target>
        </trans-unit>
        <trans-unit id="8e248ec645f54a08b3eb01462adb200f94f15d79" translate="yes" xml:space="preserve">
          <source>SORT  key [BY pattern] [LIMIT offset count] [GET pattern [GET pattern ...]] [ASC|DESC] [ALPHA] [STORE destination]   Sort the elements in a list, set or sorted set</source>
          <target state="translated">SORT 키 [BY 패턴] [LIMIT 오프셋 카운트] [GET 패턴 [GET 패턴 ...]] [ASC | DESC] [ALPHA] [저장 대상] 목록, 세트 또는 정렬 된 세트에서 요소 정렬</target>
        </trans-unit>
        <trans-unit id="757f5e1ed1192585c3e7deb4986d7e204a0c8613" translate="yes" xml:space="preserve">
          <source>SPOP</source>
          <target state="translated">SPOP</target>
        </trans-unit>
        <trans-unit id="a1bcd919a884989656266471e065ce0ed9f3b014" translate="yes" xml:space="preserve">
          <source>SPOP  key [count]   Remove and return one or multiple random members from a set</source>
          <target state="translated">SPOP 키 [count] 세트에서 하나 이상의 무작위 멤버를 제거하고 리턴</target>
        </trans-unit>
        <trans-unit id="fa889adf02f632d165c3f2d12d9b5ec8d781cbb2" translate="yes" xml:space="preserve">
          <source>SRANDMEMBER</source>
          <target state="translated">SRANDMEMBER</target>
        </trans-unit>
        <trans-unit id="a3aa05de6787d8cb6b5fb2eeb41ce24756a254c7" translate="yes" xml:space="preserve">
          <source>SRANDMEMBER  key [count]   Get one or multiple random members from a set</source>
          <target state="translated">SRANDMEMBER 키 [count] 세트에서 하나 이상의 무작위 멤버를 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="a25d27e5f9def5c1d9e1a790c413156760a00937" translate="yes" xml:space="preserve">
          <source>SREM</source>
          <target state="translated">SREM</target>
        </trans-unit>
        <trans-unit id="68363946a4081440ca501f29c43f5fbe4f7eefc4" translate="yes" xml:space="preserve">
          <source>SREM  key member [member ...]   Remove one or more members from a set</source>
          <target state="translated">SREM 키 멤버 [member ...] 세트에서 하나 이상의 멤버 제거</target>
        </trans-unit>
        <trans-unit id="39f084973b61a7bea28e4e94336a3c5a0bf9fee7" translate="yes" xml:space="preserve">
          <source>SSCAN</source>
          <target state="translated">SSCAN</target>
        </trans-unit>
        <trans-unit id="9c2bba696b7b86cd88c82a287899370d9f0e3bb5" translate="yes" xml:space="preserve">
          <source>SSCAN  key cursor [MATCH pattern] [COUNT count]   Incrementally iterate Set elements</source>
          <target state="translated">SSCAN 키 커서 [MATCH 패턴] [COUNT 수] 증분 반복 설정 요소</target>
        </trans-unit>
        <trans-unit id="c89c4cb21a1d403bb307b502f69a87f9e3b3a8ab" translate="yes" xml:space="preserve">
          <source>STRLEN</source>
          <target state="translated">STRLEN</target>
        </trans-unit>
        <trans-unit id="ba1403b52701f08d29eb084587b5d84ec8dde893" translate="yes" xml:space="preserve">
          <source>STRLEN  key   Get the length of the value stored in a key</source>
          <target state="translated">STRLEN 키 키에 저장된 값의 길이를 가져옵니다</target>
        </trans-unit>
        <trans-unit id="43a6e12318adbbee03f06872c109322b0f558e29" translate="yes" xml:space="preserve">
          <source>SUBSCRIBE</source>
          <target state="translated">SUBSCRIBE</target>
        </trans-unit>
        <trans-unit id="47236795c3b9acd1da0f66ecb88ffdd913189ac5" translate="yes" xml:space="preserve">
          <source>SUBSCRIBE  channel [channel ...]   Listen for messages published to the given channels</source>
          <target state="translated">SUBSCRIBE 채널 [채널 ...] 주어진 채널에 발행 된 메시지를 청취</target>
        </trans-unit>
        <trans-unit id="a9a4bd3707fb7f204fddf46673a38114093dbb82" translate="yes" xml:space="preserve">
          <source>SUNION</source>
          <target state="translated">SUNION</target>
        </trans-unit>
        <trans-unit id="5b757c33f2f9e74b674645b6ccda3d80138ff877" translate="yes" xml:space="preserve">
          <source>SUNION  key [key ...]   Add multiple sets</source>
          <target state="translated">SUNION 키 [키 ...] 여러 세트 추가</target>
        </trans-unit>
        <trans-unit id="48b1035f133322c326cae720a6ee6ad1108226dc" translate="yes" xml:space="preserve">
          <source>SUNIONSTORE</source>
          <target state="translated">SUNIONSTORE</target>
        </trans-unit>
        <trans-unit id="be4a84a92460ba7a99f970a1bd856700c5285869" translate="yes" xml:space="preserve">
          <source>SUNIONSTORE  destination key [key ...]   Add multiple sets and store the resulting set in a key</source>
          <target state="translated">SUNIONSTORE 대상 키 [키 ...] 여러 세트를 추가하고 결과 세트를 키에 저장</target>
        </trans-unit>
        <trans-unit id="52e8b5aa51a1b6c9b46c6f4abe8b613e777665e4" translate="yes" xml:space="preserve">
          <source>SWAPDB</source>
          <target state="translated">SWAPDB</target>
        </trans-unit>
        <trans-unit id="b86537c7b961d4302819caedcc63376c729b2e03" translate="yes" xml:space="preserve">
          <source>SWAPDB  index index   Swaps two Redis databases</source>
          <target state="translated">SWAPDB 인덱스 인덱스 두 Redis 데이터베이스를 교환</target>
        </trans-unit>
        <trans-unit id="2f8d236566d2393cd3a112e7190d8837c8004cc2" translate="yes" xml:space="preserve">
          <source>SYNC</source>
          <target state="translated">SYNC</target>
        </trans-unit>
        <trans-unit id="7dade54cfe46a1450fe32e252c2fe2557e402641" translate="yes" xml:space="preserve">
          <source>SYNC   Internal command used for replication</source>
          <target state="translated">복제에 사용되는 SYNC 내부 명령</target>
        </trans-unit>
        <trans-unit id="b54491fb2810da81b1ac818eeb380198be74decd" translate="yes" xml:space="preserve">
          <source>Same result format as &lt;a href=&quot;command&quot;&gt;COMMAND&lt;/a&gt; except you can specify which commands get returned.</source>
          <target state="translated">어떤 명령이 리턴되는지 지정할 수 있다는 점을 제외하고 &lt;a href=&quot;command&quot;&gt;명령&lt;/a&gt; 과 동일한 결과 형식 .</target>
        </trans-unit>
        <trans-unit id="1cc201c6f067fb6b6182b441f2b6dc0f4b71649b" translate="yes" xml:space="preserve">
          <source>Sample Output (new version, includes IDs)</source>
          <target state="translated">샘플 출력 (새 버전, ID 포함)</target>
        </trans-unit>
        <trans-unit id="fb0cb1b1aa0fcb98cea480e75b0d7dffc839cef1" translate="yes" xml:space="preserve">
          <source>Sample Output (old version)</source>
          <target state="translated">샘플 출력 (이전 버전)</target>
        </trans-unit>
        <trans-unit id="7a614be0679e1660abb7ab566a46118d4e5207f9" translate="yes" xml:space="preserve">
          <source>Sandbox and maximum execution time</source>
          <target state="translated">샌드 박스 및 최대 실행 시간</target>
        </trans-unit>
        <trans-unit id="444bd4af75b503112dd46c6982e0bae0a08cf7c2" translate="yes" xml:space="preserve">
          <source>Save the DB in background. The OK code is immediately returned. Redis forks, the parent continues to serve the clients, the child saves the DB on disk then exits. A client may be able to check if the operation succeeded using the &lt;a href=&quot;lastsave&quot;&gt;LASTSAVE&lt;/a&gt; command.</source>
          <target state="translated">DB를 백그라운드로 저장하십시오. OK 코드가 즉시 반환됩니다. Redis 포크, 부모는 계속 클라이언트에게 서비스를 제공하고 자식은 DB를 디스크에 저장 한 다음 종료합니다. 클라이언트는 &lt;a href=&quot;lastsave&quot;&gt;LASTSAVE&lt;/a&gt; 명령을 사용하여 작업이 성공했는지 확인할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="6e73e4e94939b275e189527f28b962ac1035dc5b" translate="yes" xml:space="preserve">
          <source>Scan guarantees</source>
          <target state="translated">스캔 보증</target>
        </trans-unit>
        <trans-unit id="983987071368a426b6b0e610cd5b5142cb273380" translate="yes" xml:space="preserve">
          <source>Script cache semantics</source>
          <target state="translated">스크립트 캐시 의미</target>
        </trans-unit>
        <trans-unit id="7522becbe814d8b8cbc378f8930c8ca68bb2b8b5" translate="yes" xml:space="preserve">
          <source>Scripting</source>
          <target state="translated">Scripting</target>
        </trans-unit>
        <trans-unit id="745fe7d4baa466214b942befb3f50f3311c89d23" translate="yes" xml:space="preserve">
          <source>Scripts are also subject to a maximum execution time (five seconds by default). This default timeout is huge since a script should usually run in under a millisecond. The limit is mostly to handle accidental infinite loops created during development.</source>
          <target state="translated">스크립트에는 최대 실행 시간 (기본적으로 5 초)이 적용됩니다. 스크립트가 일반적으로 밀리 초 이내에 실행되어야하므로이 기본 시간 초과는 엄청납니다. 한계는 대부분 개발 중에 생성 된 우발적 인 무한 루프를 처리하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="aef3e907fc9586fb823b51b6f43074de8b409561" translate="yes" xml:space="preserve">
          <source>Scripts as pure functions</source>
          <target state="translated">순수한 함수로서의 스크립트</target>
        </trans-unit>
        <trans-unit id="18ec3225e4d3fe66e7449672a6973e4c283e8bfa" translate="yes" xml:space="preserve">
          <source>Scripts should never try to access the external system, like the file system or any other system call. A script should only operate on Redis data and passed arguments.</source>
          <target state="translated">스크립트는 파일 시스템이나 다른 시스템 호출과 같은 외부 시스템에 액세스하려고 시도해서는 안됩니다. 스크립트는 Redis 데이터 및 전달 된 인수에서만 작동해야합니다.</target>
        </trans-unit>
        <trans-unit id="96faa0a78d5b1890951d8f5b8b1cde571bd90423" translate="yes" xml:space="preserve">
          <source>Second replica</source>
          <target state="translated">두 번째 복제본</target>
        </trans-unit>
        <trans-unit id="b5a6bb51bed42ec84477a8c64f567145dc6b3f5b" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;flushall&quot;&gt;FLUSHALL&lt;/a&gt; for documentation.</source>
          <target state="translated">설명서는 &lt;a href=&quot;flushall&quot;&gt;FLUSHALL&lt;/a&gt; 을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="82b75cc42f6596f8de98cea0e684609b487d2473" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;incr&quot;&gt;INCR&lt;/a&gt; for extra information on increment/decrement operations.</source>
          <target state="translated">증분 / 감소 작업에 대한 추가 정보는 &lt;a href=&quot;incr&quot;&gt;INCR&lt;/a&gt; 을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="107b4f4ca6c2e49d71158688712e821a1f6afcf3" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;rpoplpush&quot;&gt;RPOPLPUSH&lt;/a&gt; for more information.</source>
          <target state="translated">자세한 정보는 &lt;a href=&quot;rpoplpush&quot;&gt;RPOPLPUSH&lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="54208184c8545cb10751d54f17912e96124fdcce" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;scan&quot;&gt;SCAN&lt;/a&gt; for &lt;a href=&quot;hscan&quot;&gt;HSCAN&lt;/a&gt; documentation.</source>
          <target state="translated">&lt;a href=&quot;hscan&quot;&gt;HSCAN&lt;/a&gt; 설명서는 &lt;a href=&quot;scan&quot;&gt;SCAN&lt;/a&gt; 을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="c7350f489b2f884299284e290b37d7bb050416da" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;scan&quot;&gt;SCAN&lt;/a&gt; for &lt;a href=&quot;sscan&quot;&gt;SSCAN&lt;/a&gt; documentation.</source>
          <target state="translated">&lt;a href=&quot;sscan&quot;&gt;SSCAN&lt;/a&gt; 설명서는 &lt;a href=&quot;scan&quot;&gt;SCAN&lt;/a&gt; 을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="23e07b46cb9a86395d17dec6e25da38c0a253bd8" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;scan&quot;&gt;SCAN&lt;/a&gt; for &lt;a href=&quot;zscan&quot;&gt;ZSCAN&lt;/a&gt; documentation.</source>
          <target state="translated">&lt;a href=&quot;zscan&quot;&gt;ZSCAN&lt;/a&gt; 설명서는 &lt;a href=&quot;scan&quot;&gt;SCAN&lt;/a&gt; 을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="cf5419ddb7be58d105f864a1bb383d4d274d8979" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;zrevrange&quot;&gt;ZREVRANGE&lt;/a&gt; when you need the elements ordered from highest to lowest score (and descending lexicographical order for elements with equal score).</source>
          <target state="translated">가장 높은 점수에서 가장 낮은 점수로 정렬 된 요소가 필요할 때 &lt;a href=&quot;zrevrange&quot;&gt;ZREVRANGE를&lt;/a&gt; 참조하십시오 (그리고 같은 점수를 가진 요소의 경우 내림차순 내림차순).</target>
        </trans-unit>
        <trans-unit id="a4157bb7f9bac5025b0c70053cd9e97522de9f5f" translate="yes" xml:space="preserve">
          <source>See also the &lt;a href=&quot;pttl&quot;&gt;PTTL&lt;/a&gt; command that returns the same information with milliseconds resolution (Only available in Redis 2.6 or greater).</source>
          <target state="translated">밀리 초 해상도로 동일한 정보를 반환 하는 &lt;a href=&quot;pttl&quot;&gt;PTTL&lt;/a&gt; 명령 도 참조하십시오 (Redis 2.6 이상에서만 사용 가능).</target>
        </trans-unit>
        <trans-unit id="3f65c6fd246f3e1cbd884a1abc8369fa9e3fec12" translate="yes" xml:space="preserve">
          <source>See the &lt;a href=&quot;blpop&quot;&gt;BLPOP documentation&lt;/a&gt; for the exact semantics, since &lt;a href=&quot;brpop&quot;&gt;BRPOP&lt;/a&gt; is identical to &lt;a href=&quot;blpop&quot;&gt;BLPOP&lt;/a&gt; with the only difference being that it pops elements from the tail of a list instead of popping from the head.</source>
          <target state="translated">참고 항목 &lt;a href=&quot;blpop&quot;&gt;BLPOP 문서를&lt;/a&gt; 하기 때문에, 정확한 의미에 대한 &lt;a href=&quot;brpop&quot;&gt;BRPOP이&lt;/a&gt; 동일 &lt;a href=&quot;blpop&quot;&gt;BLPOP&lt;/a&gt; 유일한 차이점은 대신 머리에서 터지는 목록의 꼬리에서 요소를 나올 것을 인 상태.</target>
        </trans-unit>
        <trans-unit id="98f2a156aa61e815ac476620027b033818a3853f" translate="yes" xml:space="preserve">
          <source>See the &lt;a href=&quot;blpop&quot;&gt;BLPOP documentation&lt;/a&gt; for the exact semantics, since &lt;a href=&quot;bzpopmin&quot;&gt;BZPOPMIN&lt;/a&gt; is identical to &lt;a href=&quot;blpop&quot;&gt;BLPOP&lt;/a&gt; with the only difference being the data structure being popped from.</source>
          <target state="translated">투시 &lt;a href=&quot;blpop&quot;&gt;BLPOP 서를&lt;/a&gt; 때문에, 정확한 의미론위한 &lt;a href=&quot;bzpopmin&quot;&gt;BZPOPMIN가&lt;/a&gt; 동일 &lt;a href=&quot;blpop&quot;&gt;BLPOP&lt;/a&gt; 유일한 차이점에서 팝되는 데이터 구조 인 상태.</target>
        </trans-unit>
        <trans-unit id="682db2e97701526e3ecf1f9201b3297eab6f9ec7" translate="yes" xml:space="preserve">
          <source>See the &lt;a href=&quot;bzpopmin&quot;&gt;BZPOPMIN documentation&lt;/a&gt; for the exact semantics, since &lt;a href=&quot;bzpopmax&quot;&gt;BZPOPMAX&lt;/a&gt; is identical to &lt;a href=&quot;bzpopmin&quot;&gt;BZPOPMIN&lt;/a&gt; with the only difference being that it pops members with the highest scores instead of popping the ones with the lowest scores.</source>
          <target state="translated">참고 항목 &lt;a href=&quot;bzpopmin&quot;&gt;BZPOPMIN 문서를&lt;/a&gt; 하기 때문에, 정확한 의미에 대한 &lt;a href=&quot;bzpopmax&quot;&gt;BZPOPMAX이&lt;/a&gt; 동일 &lt;a href=&quot;bzpopmin&quot;&gt;BZPOPMIN&lt;/a&gt; 유일한 차이점은 대신 가장 낮은 점수를 가진 사람 터지는의 가장 높은 점수 회원 나올 것을 인 상태.</target>
        </trans-unit>
        <trans-unit id="58bc20fb0dd298ffb8cf41a50998826b6c62ee0f" translate="yes" xml:space="preserve">
          <source>See the article called &quot;&lt;a href=&quot;http://blog.getspool.com/2011/11/29/fast-easy-realtime-metrics-using-redis-bitmaps&quot;&gt;Fast easy realtime metrics using Redis bitmaps&lt;/a&gt;&quot; for a interesting use cases.</source>
          <target state="translated">흥미로운 사용 사례는 &quot; &lt;a href=&quot;http://blog.getspool.com/2011/11/29/fast-easy-realtime-metrics-using-redis-bitmaps&quot;&gt;Redis 비트 맵을 사용하는 빠르고 쉬운 실시간 메트릭&lt;/a&gt; &quot;이라는 기사를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="2b55d9f15b0ea2d72611a684c74d755e0354f5c5" translate="yes" xml:space="preserve">
          <source>Select the Redis logical database having the specified zero-based numeric index. New connections always use the database 0.</source>
          <target state="translated">지정된 0부터 시작하는 숫자 인덱스가있는 Redis 논리 데이터베이스를 선택하십시오. 새 연결은 항상 데이터베이스 0을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="19899928b5f8951aa558a826d2465808d72a01a5" translate="yes" xml:space="preserve">
          <source>Selective replication of commands</source>
          <target state="translated">명령의 선택적 복제</target>
        </trans-unit>
        <trans-unit id="49cedc3ef8c6db0043eba553132d30f3fe261b2a" translate="yes" xml:space="preserve">
          <source>Sentinel output</source>
          <target state="translated">센티넬 출력</target>
        </trans-unit>
        <trans-unit id="23e75937982f844ac2efdda93d0cf6e15629e1a7" translate="yes" xml:space="preserve">
          <source>Serialization format</source>
          <target state="translated">직렬화 형식</target>
        </trans-unit>
        <trans-unit id="7af4afd659e0dc29f7d2d75a3f48646f5eb4ec0b" translate="yes" xml:space="preserve">
          <source>Serialize the value stored at key in a Redis-specific format and return it to the user. The returned value can be synthesized back into a Redis key using the &lt;a href=&quot;restore&quot;&gt;RESTORE&lt;/a&gt; command.</source>
          <target state="translated">키에 저장된 값을 Redis 특정 형식으로 직렬화하여 사용자에게 반환하십시오. 반환 된 값은 &lt;a href=&quot;restore&quot;&gt;RESTORE&lt;/a&gt; 명령을 사용하여 Redis 키로 다시 합성 될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="cb0cb170d106f8e8d5af1e05bbdbd3a96a7de197" translate="yes" xml:space="preserve">
          <source>Server</source>
          <target state="translated">Server</target>
        </trans-unit>
        <trans-unit id="c0ae85ee6d7ed57f6a577247b126ae67f64df433" translate="yes" xml:space="preserve">
          <source>Set &lt;code&gt;key&lt;/code&gt; to hold string &lt;code&gt;value&lt;/code&gt; if &lt;code&gt;key&lt;/code&gt; does not exist. In that case, it is equal to &lt;a href=&quot;set&quot;&gt;SET&lt;/a&gt;. When &lt;code&gt;key&lt;/code&gt; already holds a value, no operation is performed. &lt;a href=&quot;setnx&quot;&gt;SETNX&lt;/a&gt; is short for &quot;&lt;strong&gt;SET&lt;/strong&gt; if &lt;strong&gt;N&lt;/strong&gt;ot e&lt;strong&gt;X&lt;/strong&gt;ists&quot;.</source>
          <target state="translated">설정 &lt;code&gt;key&lt;/code&gt; 홀드 문자열에 &lt;code&gt;value&lt;/code&gt; 경우 &lt;code&gt;key&lt;/code&gt; 존재하지 않습니다. 이 경우 &lt;a href=&quot;set&quot;&gt;SET&lt;/a&gt; 과 같습니다 . 때 &lt;code&gt;key&lt;/code&gt; 이미 값을 보유하고, 어떤 동작이 수행되지 않는다. &lt;a href=&quot;setnx&quot;&gt;SETNX는&lt;/a&gt; &quot;에 대한 짧은 &lt;strong&gt;SET&lt;/strong&gt; 경우 &lt;strong&gt;N&lt;/strong&gt; OT 전자 &lt;strong&gt;X&lt;/strong&gt; 주의자&quot;.</target>
        </trans-unit>
        <trans-unit id="68ffd036a56e1e5a5a24f70d86f4819eb308fad6" translate="yes" xml:space="preserve">
          <source>Set &lt;code&gt;key&lt;/code&gt; to hold the string &lt;code&gt;value&lt;/code&gt; and set &lt;code&gt;key&lt;/code&gt; to timeout after a given number of seconds. This command is equivalent to executing the following commands:</source>
          <target state="translated">설정 &lt;code&gt;key&lt;/code&gt; 문자열 잡아 &lt;code&gt;value&lt;/code&gt; 및 설정 &lt;code&gt;key&lt;/code&gt; 지정된 시간 (초)이 경과하면 타임 아웃 시간을. 이 명령은 다음 명령을 실행하는 것과 같습니다.</target>
        </trans-unit>
        <trans-unit id="e17569ffaef1d28acdfd66d09de8af3c0b06dd1a" translate="yes" xml:space="preserve">
          <source>Set &lt;code&gt;key&lt;/code&gt; to hold the string &lt;code&gt;value&lt;/code&gt;. If &lt;code&gt;key&lt;/code&gt; already holds a value, it is overwritten, regardless of its type. Any previous time to live associated with the key is discarded on successful &lt;a href=&quot;set&quot;&gt;SET&lt;/a&gt; operation.</source>
          <target state="translated">문자열 &lt;code&gt;value&lt;/code&gt; 을 보유하도록 &lt;code&gt;key&lt;/code&gt; 를 설정하십시오 . &lt;code&gt;key&lt;/code&gt; 이미 값이 있으면 유형에 관계없이 덮어 씁니다. 성공적인 &lt;a href=&quot;set&quot;&gt;SET&lt;/a&gt; 조작시 키와 연관된 이전의 모든 시간은 삭제됩니다 .</target>
        </trans-unit>
        <trans-unit id="1f4c1e8e25a5de08761510d1ae33392ed98c3afb" translate="yes" xml:space="preserve">
          <source>Set a timeout on &lt;code&gt;key&lt;/code&gt;. After the timeout has expired, the key will automatically be deleted. A key with an associated timeout is often said to be &lt;em&gt;volatile&lt;/em&gt; in Redis terminology.</source>
          <target state="translated">&lt;code&gt;key&lt;/code&gt; 시간 제한을 설정하십시오 . 제한 시간이 만료되면 키가 자동으로 삭제됩니다. 관련 타임 아웃이있는 키는 종종 Redis 용어에서 &lt;em&gt;휘발성&lt;/em&gt; 이라고합니다 .</target>
        </trans-unit>
        <trans-unit id="eaec93cdacc6eb6c55472f85e73e6fb3ad082dbe" translate="yes" xml:space="preserve">
          <source>Set the consumer group &lt;em&gt;last delivered ID&lt;/em&gt; to something else.</source>
          <target state="translated">소비자 그룹 &lt;em&gt;마지막 전달 ID&lt;/em&gt; 를 다른 것으로 설정하십시오 .</target>
        </trans-unit>
        <trans-unit id="5d89ad31b7de012f12a03f34f4620f730e4db31a" translate="yes" xml:space="preserve">
          <source>Set the debug mode for subsequent scripts executed with &lt;a href=&quot;eval&quot;&gt;EVAL&lt;/a&gt;. Redis includes a complete Lua debugger, codename LDB, that can be used to make the task of writing complex scripts much simpler. In debug mode Redis acts as a remote debugging server and a client, such as &lt;code&gt;redis-cli&lt;/code&gt;, can execute scripts step by step, set breakpoints, inspect variables and more - for additional information about LDB refer to the &lt;a href=&quot;https://redis.io/topics/ldb&quot;&gt;Redis Lua debugger&lt;/a&gt; page.</source>
          <target state="translated">&lt;a href=&quot;eval&quot;&gt;EVAL로&lt;/a&gt; 실행되는 후속 스크립트에 대한 디버그 모드를 설정하십시오 . Redis에는 복잡한 스크립트를 작성하는 작업을 훨씬 간단하게 만드는 데 사용할 수있는 완전한 Lua 디버거 인 코드 명 LDB가 포함되어 있습니다. 디버그 모드에서 Redis는 원격 디버깅 서버 역할을하며 &lt;code&gt;redis-cli&lt;/code&gt; 와 같은 클라이언트는 단계별로 스크립트를 실행하고 중단 점을 설정하며 변수를 검사하는 등의 작업을 수행 할 수 있습니다. LDB에 대한 추가 정보는 &lt;a href=&quot;https://redis.io/topics/ldb&quot;&gt;Redis Lua 디버거&lt;/a&gt; 페이지를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="6550b71f96cbf89e715fc6e575e8db9958a3525f" translate="yes" xml:space="preserve">
          <source>Set the destination node slot to &lt;em&gt;importing&lt;/em&gt; state using &lt;code&gt;CLUSTER SETSLOT &amp;lt;slot&amp;gt; IMPORTING &amp;lt;source-node-id&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;CLUSTER SETSLOT &amp;lt;slot&amp;gt; IMPORTING &amp;lt;source-node-id&amp;gt;&lt;/code&gt; 사용하여 대상 노드 슬롯을 &lt;em&gt;가져 오기&lt;/em&gt; 상태로 설정하십시오 .</target>
        </trans-unit>
        <trans-unit id="84c2dc8e1aa43a852766a49a5d96696d6e7e9329" translate="yes" xml:space="preserve">
          <source>Set the source node slot to &lt;em&gt;migrating&lt;/em&gt; state using &lt;code&gt;CLUSTER SETSLOT &amp;lt;slot&amp;gt; MIGRATING &amp;lt;destination-node-id&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;CLUSTER SETSLOT &amp;lt;slot&amp;gt; MIGRATING &amp;lt;destination-node-id&amp;gt;&lt;/code&gt; 사용하여 소스 노드 슬롯을 &lt;em&gt;마이그레이션&lt;/em&gt; 상태로 설정하십시오 .</target>
        </trans-unit>
        <trans-unit id="2ab262f44dfc9e1ee8adf98c1aa64de34434fa83" translate="yes" xml:space="preserve">
          <source>Sets</source>
          <target state="translated">Sets</target>
        </trans-unit>
        <trans-unit id="d9264103cd2db8160e2072438f28377ce6a9fc7b" translate="yes" xml:space="preserve">
          <source>Sets &lt;code&gt;field&lt;/code&gt; in the hash stored at &lt;code&gt;key&lt;/code&gt; to &lt;code&gt;value&lt;/code&gt;, only if &lt;code&gt;field&lt;/code&gt; does not yet exist. If &lt;code&gt;key&lt;/code&gt; does not exist, a new key holding a hash is created. If &lt;code&gt;field&lt;/code&gt; already exists, this operation has no effect.</source>
          <target state="translated">&lt;code&gt;field&lt;/code&gt; 가 아직없는 경우에만 &lt;code&gt;key&lt;/code&gt; 에 저장된 해시의 &lt;code&gt;field&lt;/code&gt; 를 &lt;code&gt;value&lt;/code&gt; 로 설정 합니다. 경우 &lt;code&gt;key&lt;/code&gt; 존재하지 않는, 해시를 들고 새 키가 생성됩니다. 경우 &lt;code&gt;field&lt;/code&gt; 이미이 작업은 아무런 영향을 미치지 않습니다.</target>
        </trans-unit>
        <trans-unit id="4067fd3c70d6275dbeb4b012c5dce8cf613a429a" translate="yes" xml:space="preserve">
          <source>Sets &lt;code&gt;field&lt;/code&gt; in the hash stored at &lt;code&gt;key&lt;/code&gt; to &lt;code&gt;value&lt;/code&gt;. If &lt;code&gt;key&lt;/code&gt; does not exist, a new key holding a hash is created. If &lt;code&gt;field&lt;/code&gt; already exists in the hash, it is overwritten.</source>
          <target state="translated">설정 &lt;code&gt;field&lt;/code&gt; 에 저장된 해시 &lt;code&gt;key&lt;/code&gt; 에 대한 &lt;code&gt;value&lt;/code&gt; . 경우 &lt;code&gt;key&lt;/code&gt; 존재하지 않는, 해시를 들고 새 키가 생성됩니다. 경우 &lt;code&gt;field&lt;/code&gt; 이미 해시에 존재, 그것은 덮어 씁니다.</target>
        </trans-unit>
        <trans-unit id="e0c3c8b5846a6b7343db97e53a136456e18a31e2" translate="yes" xml:space="preserve">
          <source>Sets can be encoded as &lt;code&gt;intset&lt;/code&gt; or &lt;code&gt;hashtable&lt;/code&gt;. The &lt;code&gt;intset&lt;/code&gt; is a special encoding used for small sets composed solely of integers.</source>
          <target state="translated">세트는 &lt;code&gt;intset&lt;/code&gt; 또는 &lt;code&gt;hashtable&lt;/code&gt; 로 인코딩 할 수 있습니다 . &lt;code&gt;intset&lt;/code&gt; 은 전적으로 정수 구성된 작은 세트하기 위해 사용되는 특별한 인코딩된다.</target>
        </trans-unit>
        <trans-unit id="e2de8a522a3c6c1fa9f2cb3110ab55a427778354" translate="yes" xml:space="preserve">
          <source>Sets or clears the bit at &lt;em&gt;offset&lt;/em&gt; in the string value stored at &lt;em&gt;key&lt;/em&gt;.</source>
          <target state="translated">&lt;em&gt;key에&lt;/em&gt; 저장된 문자열 값 에서 &lt;em&gt;오프셋&lt;/em&gt; 의 비트를 설정하거나 지 웁니다 .&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="e97dcc6f663f896d57a6785f5e028d865ad0719f" translate="yes" xml:space="preserve">
          <source>Sets the given keys to their respective values. &lt;a href=&quot;mset&quot;&gt;MSET&lt;/a&gt; replaces existing values with new values, just as regular &lt;a href=&quot;set&quot;&gt;SET&lt;/a&gt;. See &lt;a href=&quot;msetnx&quot;&gt;MSETNX&lt;/a&gt; if you don't want to overwrite existing values.</source>
          <target state="translated">주어진 키를 각각의 값으로 설정합니다. &lt;a href=&quot;mset&quot;&gt;MSET&lt;/a&gt; 은 일반 &lt;a href=&quot;set&quot;&gt;SET&lt;/a&gt; 처럼 기존 값을 새 값으로 바꿉니다 . 기존 값을 덮어 쓰지 않으려면 &lt;a href=&quot;msetnx&quot;&gt;MSETNX를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="5a2c8ceb3bc610f26a67627aba4acc8339a9ce7d" translate="yes" xml:space="preserve">
          <source>Sets the given keys to their respective values. &lt;a href=&quot;msetnx&quot;&gt;MSETNX&lt;/a&gt; will not perform any operation at all even if just a single key already exists.</source>
          <target state="translated">주어진 키를 각각의 값으로 설정합니다. 단일 키만 이미 존재하더라도 &lt;a href=&quot;msetnx&quot;&gt;MSETNX&lt;/a&gt; 는 아무런 작업도 수행하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="8750c7a418a307afb7502f752e1bd4c1264fa761" translate="yes" xml:space="preserve">
          <source>Sets the list element at &lt;code&gt;index&lt;/code&gt; to &lt;code&gt;value&lt;/code&gt;. For more information on the &lt;code&gt;index&lt;/code&gt; argument, see &lt;a href=&quot;lindex&quot;&gt;LINDEX&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;index&lt;/code&gt; 의 list 요소 를 &lt;code&gt;value&lt;/code&gt; 로 설정합니다 . &lt;code&gt;index&lt;/code&gt; 인수 에 대한 자세한 정보는 &lt;a href=&quot;lindex&quot;&gt;LINDEX를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="3acb8a6c67905faa893fe92726100c83a3b40b2e" translate="yes" xml:space="preserve">
          <source>Sets the specified fields to their respective values in the hash stored at &lt;code&gt;key&lt;/code&gt;. This command overwrites any specified fields already existing in the hash. If &lt;code&gt;key&lt;/code&gt; does not exist, a new key holding a hash is created.</source>
          <target state="translated">&lt;code&gt;key&lt;/code&gt; 에 저장된 해시에서 지정된 필드를 해당 값으로 설정합니다 . 이 명령은 해시에 이미 존재하는 지정된 필드를 덮어 씁니다. 경우 &lt;code&gt;key&lt;/code&gt; 존재하지 않는, 해시를 들고 새 키가 생성됩니다.</target>
        </trans-unit>
        <trans-unit id="66e4a6395d06dd6c9ac9889a54defa5d69368f6e" translate="yes" xml:space="preserve">
          <source>Similarly to get just the last element added into the stream it is enough to send:</source>
          <target state="translated">마찬가지로 스트림에 마지막으로 추가 된 요소 만 가져 오려면 다음을 전송하기에 충분합니다.</target>
        </trans-unit>
        <trans-unit id="e66ca1aceaf1d95b66f61ef999386ba4322050ac" translate="yes" xml:space="preserve">
          <source>Simple string reply</source>
          <target state="translated">간단한 문자열 회신</target>
        </trans-unit>
        <trans-unit id="d1d2334a81971315130c4fe2db94eeb5d843a482" translate="yes" xml:space="preserve">
          <source>Since &lt;a href=&quot;georadius&quot;&gt;GEORADIUS&lt;/a&gt; and &lt;a href=&quot;georadiusbymember&quot;&gt;GEORADIUSBYMEMBER&lt;/a&gt; have a &lt;code&gt;STORE&lt;/code&gt; and &lt;code&gt;STOREDIST&lt;/code&gt; option they are technically flagged as writing commands in the Redis command table. For this reason read-only replicas will flag them, and Redis Cluster replicas will redirect them to the master instance even if the connection is in read only mode (See the &lt;a href=&quot;readonly&quot;&gt;READONLY&lt;/a&gt; command of Redis Cluster).</source>
          <target state="translated">이후 &lt;a href=&quot;georadius&quot;&gt;GEORADIUS&lt;/a&gt; 및 &lt;a href=&quot;georadiusbymember&quot;&gt;GEORADIUSBYMEMBER이&lt;/a&gt; 이 &lt;code&gt;STORE&lt;/code&gt; 및 &lt;code&gt;STOREDIST&lt;/code&gt; 옵션을 그들은 기술적으로 레디 스 명령 테이블에 명령을 쓰는 것으로 표시된다. 이러한 이유로 읽기 전용 복제본은이를 복제하고 연결이 읽기 전용 모드 인 경우에도 Redis Cluster 복제본은이를 복제하여 마스터 인스턴스로 리디렉션합니다 ( Redis Cluster 의 &lt;a href=&quot;readonly&quot;&gt;READONLY&lt;/a&gt; 명령 참조 ).</target>
        </trans-unit>
        <trans-unit id="97d9bd95aec04226ad20ff34e75e5087d27999bb" translate="yes" xml:space="preserve">
          <source>Since &lt;a href=&quot;wait&quot;&gt;WAIT&lt;/a&gt; returns the number of replicas reached both in case of failure and success, the client should check that the returned value is equal or greater to the replication level it demanded.</source>
          <target state="translated">&lt;a href=&quot;wait&quot;&gt;WAIT&lt;/a&gt; 는 실패와 성공시 모두 도달 한 복제본 수를 반환 하므로 클라이언트는 반환 된 값이 필요한 복제 수준 이상인지 확인해야합니다.</target>
        </trans-unit>
        <trans-unit id="d91e505ea765c9a82be96ae5534dfec641b36446" translate="yes" xml:space="preserve">
          <source>Since Redis 2.4 the AOF rewrite is automatically triggered by Redis, however the &lt;a href=&quot;bgrewriteaof&quot;&gt;BGREWRITEAOF&lt;/a&gt; command can be used to trigger a rewrite at any time.</source>
          <target state="translated">Redis 2.4부터 AOF 다시 쓰기는 Redis에 의해 자동으로 트리거되지만 &lt;a href=&quot;bgrewriteaof&quot;&gt;BGREWRITEAOF&lt;/a&gt; 명령을 사용하여 언제든지 다시 쓰기를 트리거 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="fea1afb4200834342d36841c2047774edeed20c3" translate="yes" xml:space="preserve">
          <source>Since Redis 2.6 the expire error is from 0 to 1 milliseconds.</source>
          <target state="translated">Redis 2.6부터 만료 오류는 0에서 1 밀리 초입니다.</target>
        </trans-unit>
        <trans-unit id="c0dcf1f129fbdd5b581db58c1a230256a6836c37" translate="yes" xml:space="preserve">
          <source>Since Redis 3.0.3 it is possible to specify multiple keys instead of a single one. In such a case, it returns the total number of keys existing. Note that returning 1 or 0 for a single key is just a special case of the variadic usage, so the command is completely backward compatible.</source>
          <target state="translated">Redis 3.0.3부터 단일 키 대신 여러 키를 지정할 수 있습니다. 이 경우 기존의 총 키 수를 반환합니다. 단일 키에 대해 1 또는 0을 반환하는 것은 가변성 사용의 특수한 경우이므로 명령은 이전 버전과 완전히 호환됩니다.</target>
        </trans-unit>
        <trans-unit id="f8bcf2ebedfce566d24835d3a2aba17bb7c2d1ca" translate="yes" xml:space="preserve">
          <source>Since Redis 3.0.3 the command accepts a variable number of keys and the return value is generalized:</source>
          <target state="translated">Redis 3.0.3부터 명령은 가변 개수의 키를 허용하며 리턴 값이 일반화됩니다.</target>
        </trans-unit>
        <trans-unit id="e151485b203362c942ed95e59fd38510a0f0ba0d" translate="yes" xml:space="preserve">
          <source>Since Redis 3.2.10 / 4.0.0, this command also prevents keys to be evicted or expired during the time clients are paused. This way the dataset is guaranteed to be static not just from the point of view of clients not being able to write, but also from the point of view of internal operations.</source>
          <target state="translated">Redis 3.2.10 / 4.0.0부터이 명령은 클라이언트가 일시 중지 된 시간 동안 키가 제거되거나 만료되는 것을 방지합니다. 이러한 방식으로 데이터 세트는 클라이언트가 쓸 수없는 관점뿐만 아니라 내부 작업 관점에서도 정적이되도록 보장됩니다.</target>
        </trans-unit>
        <trans-unit id="b23d8947d72fa1ab05d11117a996f014677a635b" translate="yes" xml:space="preserve">
          <source>Since in the second call the returned cursor is 0, the server signaled to the caller that the iteration finished, and the collection was completely explored. Starting an iteration with a cursor value of 0, and calling &lt;a href=&quot;scan&quot;&gt;SCAN&lt;/a&gt; until the returned cursor is 0 again is called a &lt;strong&gt;full iteration&lt;/strong&gt;.</source>
          <target state="translated">두 번째 호출에서 리턴 된 커서는 0이므로 서버는 호출자에게 반복이 완료되었음을 알리고 콜렉션이 완전히 탐색되었음을 알 렸습니다. 커서 값이 0 인 반복을 시작 하고 리턴 된 커서가 다시 0이 될 때까지 &lt;a href=&quot;scan&quot;&gt;SCAN을&lt;/a&gt; 호출하는 것을 &lt;strong&gt;전체 반복&lt;/strong&gt; 이라고합니다 .</target>
        </trans-unit>
        <trans-unit id="5ff6f2c9633e20e1d4f2fc7a23a6109e8917c9ab" translate="yes" xml:space="preserve">
          <source>Since the &lt;code&gt;increment&lt;/code&gt; argument is signed, both increment and decrement operations can be performed:</source>
          <target state="translated">이후 &lt;code&gt;increment&lt;/code&gt; 인수 서명이 모두 증가 및 감소 조작을 수행 할 수 있습니다 :</target>
        </trans-unit>
        <trans-unit id="37a6aaafe1e5adca5e6fbd58e615c9ceed7c328a" translate="yes" xml:space="preserve">
          <source>Since the currently selected database is a property of the connection, clients should track the currently selected database and re-select it on reconnection. While there is no command in order to query the selected database in the current connection, the &lt;a href=&quot;client-list&quot;&gt;CLIENT LIST&lt;/a&gt; output shows, for each client, the currently selected database.</source>
          <target state="translated">현재 선택된 데이터베이스는 연결의 속성이므로 클라이언트는 현재 선택된 데이터베이스를 추적하고 다시 연결시 다시 선택해야합니다. 현재 연결에서 선택된 데이터베이스를 조회하기위한 명령이 없지만 &lt;a href=&quot;client-list&quot;&gt;CLIENT LIST&lt;/a&gt; 출력은 각 클라이언트에 대해 현재 선택된 데이터베이스를 표시합니다.</target>
        </trans-unit>
        <trans-unit id="52b5e60090730a6d250177de9e20295f9eac7ba4" translate="yes" xml:space="preserve">
          <source>Since the introduction of partial resynchronization with replicas (PSYNC feature) Redis replicas asynchronously ping their master with the offset they already processed in the replication stream. This is used in multiple ways:</source>
          <target state="translated">복제본과 부분 재 동기화 (PSYNC 기능)가 도입 된 이후 Redis 복제본은 복제 스트림에서 이미 처리 한 오프셋으로 마스터를 ping합니다. 이것은 여러 가지 방법으로 사용됩니다 :</target>
        </trans-unit>
        <trans-unit id="22f6371320dc02af91620e9a2e69ac86d721aec2" translate="yes" xml:space="preserve">
          <source>Since there is no state server side, but the full state is captured by the cursor, the caller is free to terminate an iteration half-way without signaling this to the server in any way. An infinite number of iterations can be started and never terminated without any issue.</source>
          <target state="translated">상태 서버 측은 없지만 커서가 전체 상태를 캡처하므로 호출자는 서버에 신호를 보내지 않고 중간에 반복을 자유롭게 종료 할 수 있습니다. 무한 반복을 시작할 수 있으며 아무런 문제없이 종료되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="262e696e012026f3d4f6a8415b02d5a7c46227f9" translate="yes" xml:space="preserve">
          <source>Since these commands allow for incremental iteration, returning only a small number of elements per call, they can be used in production without the downside of commands like &lt;a href=&quot;keys&quot;&gt;KEYS&lt;/a&gt; or &lt;a href=&quot;smembers&quot;&gt;SMEMBERS&lt;/a&gt; that may block the server for a long time (even several seconds) when called against big collections of keys or elements.</source>
          <target state="translated">이러한 명령은 증분 반복을 허용하여 호출 당 적은 수의 요소 만 반환하므로 &lt;a href=&quot;keys&quot;&gt;KEYS&lt;/a&gt; 또는 &lt;a href=&quot;smembers&quot;&gt;SMEMBERS&lt;/a&gt; 와 같은 명령의 단점이 없어도 서버에서 오랜 시간 (몇 초) 동안 서버를 차단할 수 있습니다. 키 또는 요소의 큰 컬렉션.</target>
        </trans-unit>
        <trans-unit id="3c0c8d4b217b1b3c149a8290667da3e389e7ef26" translate="yes" xml:space="preserve">
          <source>Since this involves approximations, in order to avoid C is set to, like, 0.998 instead of 1, we just modify the above algorithm to make sure the last score is 1 (left as an exercise for the reader...).</source>
          <target state="translated">여기에는 근사치가 포함되므로 C가 1 대신 0.998과 같이 설정되는 것을 피하기 위해 위의 알고리즘을 수정하여 마지막 점수가 1이되도록하십시오 (독자의 연습으로 남겨 두십시오 ...).</target>
        </trans-unit>
        <trans-unit id="7872f5590df64a34d5d83302b83736d78de377e5" translate="yes" xml:space="preserve">
          <source>Since version 2.1.6, &lt;code&gt;min&lt;/code&gt; and &lt;code&gt;max&lt;/code&gt; can be exclusive, following the syntax of &lt;a href=&quot;zrangebyscore&quot;&gt;ZRANGEBYSCORE&lt;/a&gt;.</source>
          <target state="translated">버전 2.1.6부터 &lt;a href=&quot;zrangebyscore&quot;&gt;ZRANGEBYSCORE&lt;/a&gt; 구문에 따라 &lt;code&gt;min&lt;/code&gt; 및 &lt;code&gt;max&lt;/code&gt; 가 배타적 일 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="1c1d2abc7675af0239fa910c466960e644589788" translate="yes" xml:space="preserve">
          <source>Single number: 3894</source>
          <target state="translated">단일 번호 : 3894</target>
        </trans-unit>
        <trans-unit id="f4a53209e61b36ab81faa5f943fba8e855032018" translate="yes" xml:space="preserve">
          <source>Skip sorting the elements</source>
          <target state="translated">요소 정렬 건너 뛰기</target>
        </trans-unit>
        <trans-unit id="8eab09bbd450823e91103eb2aaa19c7c3697409f" translate="yes" xml:space="preserve">
          <source>So for example the command &lt;code&gt;GEORADIUS Sicily 15 37 200 km WITHCOORD WITHDIST&lt;/code&gt; will return each item in the following way:</source>
          <target state="translated">예를 들어 &lt;code&gt;GEORADIUS Sicily 15 37 200 km WITHCOORD WITHDIST&lt;/code&gt; 명령 은 다음과 같은 방식으로 각 항목을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="76d0f19de574ac1304a0b3b169f72caa92244d72" translate="yes" xml:space="preserve">
          <source>So for instance, to get all the elements from the higher ID to the lower ID one could use:</source>
          <target state="translated">예를 들어, 모든 요소를 ​​상위 ID에서 하위 ID로 가져 오려면 다음을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="605cfa3fd340ae3e5e756672779740b80a689628" translate="yes" xml:space="preserve">
          <source>So in order for a given node to accept another one into the list of nodes composing a Redis Cluster, there are only two ways:</source>
          <target state="translated">따라서 특정 노드가 Redis 클러스터를 구성하는 노드 목록에 다른 노드를 허용하려면 두 가지 방법 만 있습니다.</target>
        </trans-unit>
        <trans-unit id="2350b72b46e64aeb370c2cbfa4c601de95c3d620" translate="yes" xml:space="preserve">
          <source>So we start with a list of keys, and later continue with all the associated IDs, representing &lt;em&gt;the last ID we received for that stream&lt;/em&gt;, so that the call will serve us only greater IDs from the same stream.</source>
          <target state="translated">따라서 키 목록으로 시작한 다음 나중에 &lt;em&gt;해당 스트림에 대해 마지막으로 수신 한&lt;/em&gt; ID를 나타내는 모든 관련 ID를 계속 사용 하여 호출이 동일한 스트림의 더 큰 ID 만 제공합니다.</target>
        </trans-unit>
        <trans-unit id="46ddca2244f21f2b27c1eb6025f1e694d4b8bea0" translate="yes" xml:space="preserve">
          <source>So what the command really does is:</source>
          <target state="translated">따라서 명령이 실제로하는 일은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="f434d4f52b4b99882f1b83c63bcdd004df128d69" translate="yes" xml:space="preserve">
          <source>So, if we link node A with node B via &lt;a href=&quot;cluster-meet&quot;&gt;CLUSTER MEET&lt;/a&gt;, and B with C, A and C will find their ways to handshake and create a link.</source>
          <target state="translated">따라서 &lt;a href=&quot;cluster-meet&quot;&gt;CLUSTER MEET을&lt;/a&gt; 통해 노드 A와 노드 B를 연결 하고 C와 B를 연결하면 A와 C는 핸드 셰이크하고 링크를 만드는 방법을 찾습니다.</target>
        </trans-unit>
        <trans-unit id="60790236df4f5916ea98a7288f81aafe33a99ab5" translate="yes" xml:space="preserve">
          <source>So, using &lt;code&gt;CONFIG SET-CONFIG-EPOCH&lt;/code&gt;, when a new cluster is created, we can assign a different progressive configuration epoch to each node before joining the cluster together.</source>
          <target state="translated">따라서 &lt;code&gt;CONFIG SET-CONFIG-EPOCH&lt;/code&gt; 를 사용하여 새 클러스터를 만들 때 클러스터를 결합하기 전에 각 노드에 서로 다른 점진적 구성 에포크를 할당 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="173217936882f8d5719c8defa86bf0d23eac51fe" translate="yes" xml:space="preserve">
          <source>Some Redis commands have no predetermined key locations. For those commands, flag &lt;code&gt;movablekeys&lt;/code&gt; is added to the command flags &lt;a href=&quot;https://redis.io/topics/protocol#array-reply&quot;&gt;Array reply&lt;/a&gt;. Your Redis Cluster client needs to parse commands marked &lt;code&gt;movablekeys&lt;/code&gt; to locate all relevant key positions.</source>
          <target state="translated">일부 Redis 명령에는 미리 정해진 키 위치가 없습니다. 해당 명령의 경우 플래그 이동 가능 &lt;code&gt;movablekeys&lt;/code&gt; 가 명령 플래그 &lt;a href=&quot;https://redis.io/topics/protocol#array-reply&quot;&gt;Array reply에&lt;/a&gt; 추가됩니다 . Redis Cluster 클라이언트는 모든 관련 키 위치를 찾으 &lt;code&gt;movablekeys&lt;/code&gt; 수있는 키로 표시된 명령을 구문 분석해야합니다 .</target>
        </trans-unit>
        <trans-unit id="ddceed7fe40007b57317ba7df983076bcd185123" translate="yes" xml:space="preserve">
          <source>Some consumer A reads a message via &lt;a href=&quot;xreadgroup&quot;&gt;XREADGROUP&lt;/a&gt; from a stream, in the context of that consumer group.</source>
          <target state="translated">일부 소비자 A 는 해당 소비자 그룹과 관련하여 스트림에서 &lt;a href=&quot;xreadgroup&quot;&gt;XREADGROUP&lt;/a&gt; 을 통해 메시지를 읽습니다 .</target>
        </trans-unit>
        <trans-unit id="28d440075fc880e5ff5b66c8a65009bc3be5acfb" translate="yes" xml:space="preserve">
          <source>Sometimes it can be useful for clients to completely disable replies from the Redis server. For example when the client sends fire and forget commands or performs a mass loading of data, or in caching contexts where new data is streamed constantly. In such contexts to use server time and bandwidth in order to send back replies to clients, which are going to be ignored, is considered wasteful.</source>
          <target state="translated">클라이언트가 Redis 서버의 응답을 완전히 비활성화하는 것이 유용한 경우도 있습니다. 예를 들어, 클라이언트가 fire 및 forget 명령을 보내거나 대량의 데이터로드를 수행하거나 새로운 데이터가 지속적으로 스트리밍되는 컨텍스트를 캐싱하는 경우를 예로들 수 있습니다. 이러한 맥락에서 서버 시간과 대역폭을 사용하여 응답을 클라이언트에게 다시 보내기 위해 무시하는 것은 낭비로 간주됩니다.</target>
        </trans-unit>
        <trans-unit id="43292f17e4e5fce7b6e4920a4500928789cc3b9d" translate="yes" xml:space="preserve">
          <source>Sometimes you want to sort elements using external keys as weights to compare instead of comparing the actual elements in the list, set or sorted set. Let's say the list &lt;code&gt;mylist&lt;/code&gt; contains the elements &lt;code&gt;1&lt;/code&gt;, &lt;code&gt;2&lt;/code&gt; and &lt;code&gt;3&lt;/code&gt; representing unique IDs of objects stored in &lt;code&gt;object_1&lt;/code&gt;, &lt;code&gt;object_2&lt;/code&gt; and &lt;code&gt;object_3&lt;/code&gt;. When these objects have associated weights stored in &lt;code&gt;weight_1&lt;/code&gt;, &lt;code&gt;weight_2&lt;/code&gt; and &lt;code&gt;weight_3&lt;/code&gt;, &lt;a href=&quot;sort&quot;&gt;SORT&lt;/a&gt; can be instructed to use these weights to sort &lt;code&gt;mylist&lt;/code&gt; with the following statement:</source>
          <target state="translated">때로는 목록, 세트 또는 정렬 세트의 실제 요소를 비교하는 대신 외부 키를 가중치로 사용하여 요소를 정렬 할 때가 있습니다. &lt;code&gt;mylist&lt;/code&gt; 목록 에 &lt;code&gt;object_1&lt;/code&gt; , &lt;code&gt;object_2&lt;/code&gt; 및 &lt;code&gt;object_3&lt;/code&gt; 에 저장된 객체의 고유 ID를 나타내는 요소 &lt;code&gt;1&lt;/code&gt; , &lt;code&gt;2&lt;/code&gt; 및 &lt;code&gt;3&lt;/code&gt; 이 포함되어 있다고 가정 합니다. 이러한 객체에 &lt;code&gt;weight_1&lt;/code&gt; , &lt;code&gt;weight_2&lt;/code&gt; 및 &lt;code&gt;weight_3&lt;/code&gt; 에 저장된 관련 가중치 가있는 경우 &lt;a href=&quot;sort&quot;&gt;SORT&lt;/a&gt; 는 이러한 가중치를 사용 하여 다음 명령문으로 &lt;code&gt;mylist&lt;/code&gt; 를 정렬하도록 지시 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="b2397d818d7562914c5b062b54f97e833db314f2" translate="yes" xml:space="preserve">
          <source>Sorted Sets</source>
          <target state="translated">정렬 된 세트</target>
        </trans-unit>
        <trans-unit id="25ab5e6a0d5f2c9c6bc25d348c156dc61d5c8552" translate="yes" xml:space="preserve">
          <source>Sorted Sets can be encoded as &lt;code&gt;ziplist&lt;/code&gt; or &lt;code&gt;skiplist&lt;/code&gt; format. As for the List type small sorted sets can be specially encoded using &lt;code&gt;ziplist&lt;/code&gt;, while the &lt;code&gt;skiplist&lt;/code&gt; encoding is the one that works with sorted sets of any size.</source>
          <target state="translated">정렬 된 세트는 &lt;code&gt;ziplist&lt;/code&gt; 또는 &lt;code&gt;skiplist&lt;/code&gt; 형식 으로 인코딩 될 수 있습니다 . 목록 유형의 경우 작은 정렬 세트는 &lt;code&gt;ziplist&lt;/code&gt; 를 사용하여 특별히 인코딩 할 수있는 반면, &lt;code&gt;skiplist&lt;/code&gt; 인코딩은 모든 크기의 정렬 된 세트와 작동하는 인코딩입니다.</target>
        </trans-unit>
        <trans-unit id="86e387fe2a33fb39f76cfff98ea344b952f84a62" translate="yes" xml:space="preserve">
          <source>Sorted sets 101</source>
          <target state="translated">분류 된 세트 101</target>
        </trans-unit>
        <trans-unit id="785f83ba9125723b72d2c573196ef8beabb345a8" translate="yes" xml:space="preserve">
          <source>Sorted sets are sorted by their score in an ascending way. The same element only exists a single time, no repeated elements are permitted. The score can be modified both by &lt;a href=&quot;zadd&quot;&gt;ZADD&lt;/a&gt; that will update the element score, and as a side effect, its position on the sorted set, and by &lt;a href=&quot;zincrby&quot;&gt;ZINCRBY&lt;/a&gt; that can be used in order to update the score relatively to its previous value.</source>
          <target state="translated">정렬 된 세트는 점수에 따라 오름차순으로 정렬됩니다. 동일한 요소는 한 번만 존재하며 반복되는 요소는 허용되지 않습니다. 점수는 모두에 의해 변형 될 수 &lt;a href=&quot;zadd&quot;&gt;ZADD&lt;/a&gt; 소자 점수를 업데이트 할 것을, 및 부작용에, 및에 의해 정렬 된 세트의 위치 &lt;a href=&quot;zincrby&quot;&gt;ZINCRBY&lt;/a&gt; 위해 사용될 수있는 비교적 이전 값의 점수를 업데이트.</target>
        </trans-unit>
        <trans-unit id="2f2a07b6f7677455f1b32d657bbc8366bfa48bf3" translate="yes" xml:space="preserve">
          <source>Sorting by external keys</source>
          <target state="translated">외부 키를 기준으로 정렬</target>
        </trans-unit>
        <trans-unit id="614fb399b6728ae041f21780ab6202d98e11c79a" translate="yes" xml:space="preserve">
          <source>Special conditions not allowing the command execution</source>
          <target state="translated">명령 실행을 허용하지 않는 특수 조건</target>
        </trans-unit>
        <trans-unit id="0869a917cb9ab140bb00f5d52e7332ad6727fd9a" translate="yes" xml:space="preserve">
          <source>Special slot entries</source>
          <target state="translated">특수 슬롯 엔트리</target>
        </trans-unit>
        <trans-unit id="549c2b56d95e908566338d2fd5914a21fd08d936" translate="yes" xml:space="preserve">
          <source>Specifically if a given write is transferred to one or more replicas, it is more likely (but not guaranteed) that if the master fails, we'll be able to promote, during a failover, a replica that received the write: both Sentinel and Redis Cluster will do a best-effort attempt to promote the best replica among the set of available replicas.</source>
          <target state="translated">특히 지정된 쓰기가 하나 이상의 복제본으로 전송되는 경우 마스터가 실패하면 장애 조치 (failover) 중에 쓰기를받은 복제본 (Sentinel 및 Redis Cluster는 사용 가능한 복제 세트 중에서 최상의 복제를 촉진하기 위해 최선의 노력을 다할 것입니다.</target>
        </trans-unit>
        <trans-unit id="d526406a65071e1fec15bd4174751e7a5bc387d7" translate="yes" xml:space="preserve">
          <source>Specifically this is what Redis does 10 times per second:</source>
          <target state="translated">특히 이것은 Redis가 초당 10 회 수행하는 작업입니다.</target>
        </trans-unit>
        <trans-unit id="37ec7d989573caff7ef9f45953dba8d022709000" translate="yes" xml:space="preserve">
          <source>Specification of the behavior when count is passed</source>
          <target state="translated">카운트가 통과 될 때의 동작 지정</target>
        </trans-unit>
        <trans-unit id="14c30af049c8842dbcbd1159d5db60d5f0981029" translate="yes" xml:space="preserve">
          <source>Specifying a Stream ID as an argument</source>
          <target state="translated">스트림 ID를 인수로 지정</target>
        </trans-unit>
        <trans-unit id="1544a5bc78a2aee56854818668d14afd235ec6c9" translate="yes" xml:space="preserve">
          <source>Start slot range</source>
          <target state="translated">시작 슬롯 범위</target>
        </trans-unit>
        <trans-unit id="ee455845986f290115764586b0c8b62db6794d99" translate="yes" xml:space="preserve">
          <source>Starting from Redis version 2.6, when called with the additional &lt;code&gt;count&lt;/code&gt; argument, return an array of &lt;code&gt;count&lt;/code&gt;&lt;strong&gt;distinct elements&lt;/strong&gt; if &lt;code&gt;count&lt;/code&gt; is positive. If called with a negative &lt;code&gt;count&lt;/code&gt; the behavior changes and the command is allowed to return the &lt;strong&gt;same element multiple times&lt;/strong&gt;. In this case the number of returned elements is the absolute value of the specified &lt;code&gt;count&lt;/code&gt;.</source>
          <target state="translated">추가로 호출 될 때 레디 스 버전 2.6부터 &lt;code&gt;count&lt;/code&gt; 인수의 어레이 반환 &lt;code&gt;count&lt;/code&gt; &lt;strong&gt;고유 요소&lt;/strong&gt; 만약 &lt;code&gt;count&lt;/code&gt; 긍정적이다. 부정적인 호출하면 &lt;code&gt;count&lt;/code&gt; 동작을 변경하고 명령이 반환 할 수있다 &lt;strong&gt;동일한 요소를 여러 번&lt;/strong&gt; . 이 경우 반환 된 요소의 수는 지정된 &lt;code&gt;count&lt;/code&gt; 의 절대 값입니다 .</target>
        </trans-unit>
        <trans-unit id="83f9c28598d952311fc09fa54e334ed57a68832b" translate="yes" xml:space="preserve">
          <source>Starting with Redis 2.6.12 &lt;a href=&quot;set&quot;&gt;SET&lt;/a&gt; supports a set of options that modify its behavior:</source>
          <target state="translated">Redis 2.6.12부터 &lt;a href=&quot;set&quot;&gt;SET&lt;/a&gt; 은 동작을 수정하는 일련의 옵션을 지원합니다.</target>
        </trans-unit>
        <trans-unit id="f154b597ac1178d82fc4c50afc3e83d654688468" translate="yes" xml:space="preserve">
          <source>Starting with Redis 2.8 the return value in case of error changed:</source>
          <target state="translated">Redis 2.8부터 오류가 변경된 경우의 반환 값 :</target>
        </trans-unit>
        <trans-unit id="cb9c10a639cbbf2b71b38cd0e777ffb915ed4e8b" translate="yes" xml:space="preserve">
          <source>Starting with Redis 3.0.6 &lt;a href=&quot;migrate&quot;&gt;MIGRATE&lt;/a&gt; supports a new bulk-migration mode that uses pipelining in order to migrate multiple keys between instances without incurring in the round trip time latency and other overheads that there are when moving each key with a single &lt;a href=&quot;migrate&quot;&gt;MIGRATE&lt;/a&gt; call.</source>
          <target state="translated">Redis 3.0.6부터 &lt;a href=&quot;migrate&quot;&gt;MIGRATE&lt;/a&gt; 는 파이프 라인을 사용하여 왕복 시간 지연이 발생하지 않고 인스턴스간에 여러 키를 마이그레이션하고 단일 &lt;a href=&quot;migrate&quot;&gt;MIGRATE&lt;/a&gt; 호출 로 각 키를 이동할 때 발생하는 기타 오버 헤드를 마이그레이션하는 새로운 대량 마이그레이션 모드를 지원합니다 .</target>
        </trans-unit>
        <trans-unit id="6578980d36f8246047edd57af78a6f9934454cea" translate="yes" xml:space="preserve">
          <source>Starting with Redis 3.2, Redis has support for native Lua debugging. The Redis Lua debugger is a remote debugger consisting of a server, which is Redis itself, and a client, which is by default &lt;code&gt;redis-cli&lt;/code&gt;.</source>
          <target state="translated">Redis 3.2부터 Redis는 기본 Lua 디버깅을 지원합니다. Redis Lua 디버거는 Redis 자체 인 서버와 기본적으로 &lt;code&gt;redis-cli&lt;/code&gt; 인 클라이언트로 구성된 원격 디버거 입니다.</target>
        </trans-unit>
        <trans-unit id="5b01b9bd2a097f98e87d6033b411073bab6691f7" translate="yes" xml:space="preserve">
          <source>Starting with Redis 3.2, it is possible to select an alternative replication method. Instead of replication whole scripts, we can just replicate single write commands generated by the script. We call this &lt;strong&gt;script effects replication&lt;/strong&gt;.</source>
          <target state="translated">Redis 3.2부터는 대체 복제 방법을 선택할 수 있습니다. 전체 스크립트를 복제하는 대신 스크립트에서 생성 된 단일 쓰기 명령을 복제 할 수 있습니다. 우리는이 &lt;strong&gt;스크립트 효과를 복제&lt;/strong&gt; 라고 부릅니다 .</target>
        </trans-unit>
        <trans-unit id="1ffd355623442762e32037427cffdb34a18e3984" translate="yes" xml:space="preserve">
          <source>Step 4 does not technically need to use &lt;code&gt;SETSLOT&lt;/code&gt; in the nodes not involved in the resharding, since the configuration will eventually propagate itself, however it is a good idea to do so in order to stop nodes from pointing to the wrong node for the hash slot moved as soon as possible, resulting in less redirections to find the right node.</source>
          <target state="translated">4 단계 는 구성이 결국 자체 전파되기 때문에 리 샤딩에 관련되지 않은 노드에서 기술적으로 &lt;code&gt;SETSLOT&lt;/code&gt; 을 사용할 필요 는 없지만, 노드가 해시 슬롯에 대해 잘못된 노드를 가리 키지 않도록하기 위해 그렇게하는 것이 좋습니다. 가능한 빨리 이동하여 올바른 노드를 찾기위한 리디렉션이 줄어 듭니다.</target>
        </trans-unit>
        <trans-unit id="f75b76768d708a29fc0fb9becaf181931853bd99" translate="yes" xml:space="preserve">
          <source>Step Count</source>
          <target state="translated">걸음 수</target>
        </trans-unit>
        <trans-unit id="f7fa846d5511789adfec64aa9b8751f7351a0ca5" translate="yes" xml:space="preserve">
          <source>Stop all the clients.</source>
          <target state="translated">모든 클라이언트를 중지하십시오.</target>
        </trans-unit>
        <trans-unit id="6cb759f69a54fcb63d47af649e368c12075f71be" translate="yes" xml:space="preserve">
          <source>Storing the result of a SORT operation</source>
          <target state="translated">SORT 조작 결과 저장</target>
        </trans-unit>
        <trans-unit id="df063869e11d7a9aa132cd4a984f7b5eb870d656" translate="yes" xml:space="preserve">
          <source>Stream</source>
          <target state="translated">Stream</target>
        </trans-unit>
        <trans-unit id="61c2b2148d7f362f23210527dbc1bd6b0437b131" translate="yes" xml:space="preserve">
          <source>Stream IDs are composed of two parts, a Unix millisecond time stamp and a sequence number for entries inserted in the same millisecond. It is possible to use &lt;a href=&quot;xrange&quot;&gt;XRANGE&lt;/a&gt; specifying just the first part of the ID, the millisecond time, like in the following example:</source>
          <target state="translated">스트림 ID는 Unix 밀리 초 타임 스탬프와 동일한 밀리 초에 삽입 된 항목의 시퀀스 번호의 두 부분으로 구성됩니다. 다음 예제와 같이 ID의 첫 번째 부분 인 밀리 초 시간 만 지정 하여 &lt;a href=&quot;xrange&quot;&gt;XRANGE&lt;/a&gt; 를 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="f7e700aeb9d8c3a456c6730300f1abde75268288" translate="yes" xml:space="preserve">
          <source>Streams are not auto-deleted once they have no entries inside (for instance after an &lt;a href=&quot;xdel&quot;&gt;XDEL&lt;/a&gt; call), because the stream may have consumer groups associated with it.</source>
          <target state="translated">스트림에 소비자 그룹이있을 수 있으므로 스트림에 항목이 없으면 (예 : &lt;a href=&quot;xdel&quot;&gt;XDEL&lt;/a&gt; 호출 후) 스트림이 자동 삭제되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="3816c4beac471c733eed1d91c213f8c2b6a29262" translate="yes" xml:space="preserve">
          <source>Strings</source>
          <target state="translated">Strings</target>
        </trans-unit>
        <trans-unit id="48c2711e04347f7b6d1ddd6b4a79296a8d2830ea" translate="yes" xml:space="preserve">
          <source>Strings are compared as binary array of bytes. Because of how the ASCII character set is specified, this means that usually this also have the effect of comparing normal ASCII characters in an obvious dictionary way. However this is not true if non plain ASCII strings are used (for example utf8 strings).</source>
          <target state="translated">문자열은 이진 바이트 배열로 비교됩니다. ASCII 문자 집합이 지정되는 방식으로 인해 이는 일반적으로 일반 ASCII 문자를 명확한 사전 방식으로 비교하는 효과도 있음을 의미합니다. 그러나 일반 ASCII 문자열이 아닌 문자열 (예 : utf8 문자열)을 사용하는 경우에는 해당되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="2593368d27635cc5293b7e53f7145a56dff05dd8" translate="yes" xml:space="preserve">
          <source>Strings can be encoded as &lt;code&gt;raw&lt;/code&gt; (normal string encoding) or &lt;code&gt;int&lt;/code&gt; (strings representing integers in a 64 bit signed interval are encoded in this way in order to save space).</source>
          <target state="translated">문자열은 &lt;code&gt;raw&lt;/code&gt; (일반 문자열 인코딩) 또는 &lt;code&gt;int&lt;/code&gt; 로 인코딩 될 수 있습니다 ( 64 비트 부호있는 간격으로 정수를 나타내는 문자열은 이러한 방식으로 공간을 절약하기 위해 인코딩 됨).</target>
        </trans-unit>
        <trans-unit id="d5294ece475c0dd1b0e5c4f6f621c1e0c0bf7039" translate="yes" xml:space="preserve">
          <source>Strings with a similar prefix are nearby, but the contrary is not true, it is possible that strings with different prefixes are nearby too.</source>
          <target state="translated">접두사가 비슷한 문자열이 근처에 있지만 그 반대가 사실이 아닙니다. 접두사가 다른 문자열도 근처에있을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3f9d46e5fb83a7700b4c788a03b12a80a7e61e08" translate="yes" xml:space="preserve">
          <source>Subcommand &lt;code&gt;encoding&lt;/code&gt; returns a bulk reply.</source>
          <target state="translated">부속 명령 &lt;code&gt;encoding&lt;/code&gt; 은 대량 응답을 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="03e52fefcd721e1070e1756817dc5fb3908630a4" translate="yes" xml:space="preserve">
          <source>Subcommands &lt;code&gt;refcount&lt;/code&gt; and &lt;code&gt;idletime&lt;/code&gt; return integers.</source>
          <target state="translated">부속 명령 &lt;code&gt;refcount&lt;/code&gt; 및 &lt;code&gt;idletime&lt;/code&gt; 은 정수를 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="9cdf88a718c3f491225fa1cc2fd76602c7208ad1" translate="yes" xml:space="preserve">
          <source>Subscribes the client to the given patterns.</source>
          <target state="translated">주어진 패턴으로 클라이언트를 구독합니다.</target>
        </trans-unit>
        <trans-unit id="481c5cf231fde7f8730860922d6f3194fc5f2170" translate="yes" xml:space="preserve">
          <source>Subscribes the client to the specified channels.</source>
          <target state="translated">클라이언트를 지정된 채널에 가입시킵니다.</target>
        </trans-unit>
        <trans-unit id="4a47fd9934d349f948abbf361726590ff096c6b8" translate="yes" xml:space="preserve">
          <source>Summary form of XPENDING</source>
          <target state="translated">XPENDING의 요약 양식</target>
        </trans-unit>
        <trans-unit id="dfe7ee6f8d575326187ecdb8ea7e6fb7cbf4ec35" translate="yes" xml:space="preserve">
          <source>Supported glob-style patterns:</source>
          <target state="translated">지원되는 글로브 스타일 패턴 :</target>
        </trans-unit>
        <trans-unit id="ced890cac00d712740bdc4d39c1db48f7483c499" translate="yes" xml:space="preserve">
          <source>Supported subcommands and integer types</source>
          <target state="translated">지원되는 부속 명령 및 정수 유형</target>
        </trans-unit>
        <trans-unit id="b8398e47e81dab008569a234703960eb8bab2f11" translate="yes" xml:space="preserve">
          <source>TAKEOVER option: manual failover without cluster consensus</source>
          <target state="translated">인수 옵션 : 클러스터 합의없이 수동 장애 조치</target>
        </trans-unit>
        <trans-unit id="64269f9bd268bf28815bb69e82601cd7e806a37b" translate="yes" xml:space="preserve">
          <source>TIME</source>
          <target state="translated">TIME</target>
        </trans-unit>
        <trans-unit id="8696f7a4c64b4516c2d96434e8b7824957a37d2a" translate="yes" xml:space="preserve">
          <source>TIME   Return the current server time</source>
          <target state="translated">TIME 현재 서버 시간을 반환</target>
        </trans-unit>
        <trans-unit id="c701f5f92060225c236ac0e6b3051e03bb0ad061" translate="yes" xml:space="preserve">
          <source>TOUCH</source>
          <target state="translated">TOUCH</target>
        </trans-unit>
        <trans-unit id="ad5ae533c502772151a704d28a2bece0e0f4ca1b" translate="yes" xml:space="preserve">
          <source>TOUCH  key [key ...]   Alters the last access time of a key(s). Returns the number of existing keys specified.</source>
          <target state="translated">TOUCH 키 [key ...] 키의 마지막 액세스 시간을 변경합니다. 지정된 기존 키 수를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="878260dfb888c3312c119e6db2253c2aa207ae98" translate="yes" xml:space="preserve">
          <source>TTL</source>
          <target state="translated">TTL</target>
        </trans-unit>
        <trans-unit id="8ef7742bd419d3406904eb9723c6ce85d49c0f81" translate="yes" xml:space="preserve">
          <source>TTL  key   Get the time to live for a key</source>
          <target state="translated">TTL 키 키를위한 시간을 보내십시오</target>
        </trans-unit>
        <trans-unit id="6e9816a8e9d0388eecdb52866188c04e75e4b1b3" translate="yes" xml:space="preserve">
          <source>TYPE</source>
          <target state="translated">TYPE</target>
        </trans-unit>
        <trans-unit id="7d0cfb250d49bba162e019907ea71cfcab32d9f4" translate="yes" xml:space="preserve">
          <source>TYPE  key   Determine the type stored at key</source>
          <target state="translated">TYPE 키 키에 저장된 유형을 결정합니다</target>
        </trans-unit>
        <trans-unit id="5bbc08d2de04a7034dc9edbe2e20759367a5f82f" translate="yes" xml:space="preserve">
          <source>Taking a separated key that is incremented every time the bitmap is modified. This can be very efficient and atomic using a small Redis Lua script.</source>
          <target state="translated">비트 맵이 수정 될 때마다 증가하는 분리 된 키를 가져옵니다. 작은 Redis Lua 스크립트를 사용하면 매우 효율적이고 원자적일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8b5d4fb8b75675d300f4de7425675abc3149473f" translate="yes" xml:space="preserve">
          <source>Terminating iterations in the middle</source>
          <target state="translated">중간에서 반복 종료</target>
        </trans-unit>
        <trans-unit id="8a78f0cb0822107a63b906522f8970fb02d3906a" translate="yes" xml:space="preserve">
          <source>Test 20 random keys from the set of keys with an associated expire.</source>
          <target state="translated">관련 만료가있는 키 세트에서 임의의 키 20 개를 테스트하십시오.</target>
        </trans-unit>
        <trans-unit id="0c0c5f66ed89ad8b7f73f25128b137a4d67fcbb8" translate="yes" xml:space="preserve">
          <source>Thanks to &lt;a href=&quot;setrange&quot;&gt;SETRANGE&lt;/a&gt; and the analogous &lt;a href=&quot;getrange&quot;&gt;GETRANGE&lt;/a&gt; commands, you can use Redis strings as a linear array with O(1) random access. This is a very fast and efficient storage in many real world use cases.</source>
          <target state="translated">&lt;a href=&quot;setrange&quot;&gt;SETRANGE&lt;/a&gt; 및 유사한 &lt;a href=&quot;getrange&quot;&gt;GETRANGE&lt;/a&gt; 명령 덕분에 Redis 문자열을 O (1) 랜덤 액세스를 사용하는 선형 배열로 사용할 수 있습니다. 이것은 많은 실제 사용 사례에서 매우 빠르고 효율적인 스토리지입니다.</target>
        </trans-unit>
        <trans-unit id="733be8ce43bb740e68f58527c40732d288c9eb0b" translate="yes" xml:space="preserve">
          <source>That said, &lt;a href=&quot;setnx&quot;&gt;SETNX&lt;/a&gt; can be used, and was historically used, as a locking primitive. For example, to acquire the lock of the key &lt;code&gt;foo&lt;/code&gt;, the client could try the following:</source>
          <target state="translated">즉, &lt;a href=&quot;setnx&quot;&gt;SETNX&lt;/a&gt; 는 잠금 프리미티브로 사용할 수 있으며 역사적으로 사용되었습니다. 예를 들어, 키 &lt;code&gt;foo&lt;/code&gt; 의 잠금을 획득하기 위해 클라이언트는 다음을 시도 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="77d6d135447dbf512e1ae2af8102405447c9f874" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;append&quot;&gt;APPEND&lt;/a&gt; command can be used to create a very compact representation of a list of fixed-size samples, usually referred as &lt;em&gt;time series&lt;/em&gt;. Every time a new sample arrives we can store it using the command</source>
          <target state="translated">&lt;a href=&quot;append&quot;&gt;APPEND의&lt;/a&gt; 명령이 고정 크기 샘플에서 매우 컴팩트 표현을 생성하는 경우, 일반적으로 지칭 &lt;em&gt;시계열&lt;/em&gt; . 새로운 샘플이 도착할 때마다 다음 명령을 사용하여 저장할 수 있습니다</target>
        </trans-unit>
        <trans-unit id="af3680004f1f3af89a74cfdd597524f1d5b57aa0" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;bitop&quot;&gt;BITOP&lt;/a&gt; command supports four bitwise operations: &lt;strong&gt;AND&lt;/strong&gt;, &lt;strong&gt;OR&lt;/strong&gt;, &lt;strong&gt;XOR&lt;/strong&gt; and &lt;strong&gt;NOT&lt;/strong&gt;, thus the valid forms to call the command are:</source>
          <target state="translated">&lt;a href=&quot;bitop&quot;&gt;BITOP의&lt;/a&gt; : 명령을 사 개 비트 연산을 지원 &lt;strong&gt;AND&lt;/strong&gt; , &lt;strong&gt;OR&lt;/strong&gt; , &lt;strong&gt;XOR을&lt;/strong&gt; 하고 &lt;strong&gt;NOT&lt;/strong&gt; 명령은 전화, 따라서 유효한 형태 :</target>
        </trans-unit>
        <trans-unit id="4dd66d959585425a19858f722e901be8748f987c" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;client-getname&quot;&gt;CLIENT GETNAME&lt;/a&gt; returns the name of the current connection as set by &lt;a href=&quot;client-setname&quot;&gt;CLIENT SETNAME&lt;/a&gt;. Since every new connection starts without an associated name, if no name was assigned a null bulk reply is returned.</source>
          <target state="translated">&lt;a href=&quot;client-getname&quot;&gt;클라이언트 GETNAME는&lt;/a&gt; 에 의해 설정된 현재 연결의 이름을 반환 &lt;a href=&quot;client-setname&quot;&gt;클라이언트 SETNAME을&lt;/a&gt; . 모든 새 연결은 연관된 이름없이 시작되므로 이름이 지정되지 않은 경우 널 대량 응답이 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="77571e239b6c4924e5ae8625b133ece1b2fb165b" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;client-kill&quot;&gt;CLIENT KILL&lt;/a&gt; command closes a given client connection. Up to Redis 2.8.11 it was possible to close a connection only by client address, using the following form:</source>
          <target state="translated">&lt;a href=&quot;client-kill&quot;&gt;클라이언트 KILL의&lt;/a&gt; 명령은 주어진 클라이언트 연결을 닫습니다. Redis 2.8.11까지는 다음 형식을 사용하여 클라이언트 주소로만 연결을 닫을 수있었습니다.</target>
        </trans-unit>
        <trans-unit id="c0d7e72efd1901513aa26d76fc6efa880b0ffcd7" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;client-list&quot;&gt;CLIENT LIST&lt;/a&gt; command returns information and statistics about the client connections server in a mostly human readable format.</source>
          <target state="translated">&lt;a href=&quot;client-list&quot;&gt;클라이언트 목록&lt;/a&gt; 주로 사람이 읽을 수있는 형식으로 클라이언트 연결 서버에 대한 명령이 리턴 정보 및 통계.</target>
        </trans-unit>
        <trans-unit id="99ea497bab9ec2eb991df932e164aeadc0d98009" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;client-reply&quot;&gt;CLIENT REPLY&lt;/a&gt; command controls whether the server will reply the client's commands. The following modes are available:</source>
          <target state="translated">&lt;a href=&quot;client-reply&quot;&gt;클라이언트 REPLY의&lt;/a&gt; 명령 제어 서버는 클라이언트의 명령을 응답할지 여부를 지정합니다. 사용 가능한 모드는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="66ef05bc81ce96b58454a695580464830edc9445" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;client-setname&quot;&gt;CLIENT SETNAME&lt;/a&gt; command assigns a name to the current connection.</source>
          <target state="translated">&lt;a href=&quot;client-setname&quot;&gt;클라이언트 SETNAME의&lt;/a&gt; 명령은 현재 연결에 이름을 할당합니다.</target>
        </trans-unit>
        <trans-unit id="29ca3ac0a9d2f6b99b3b3cfed122170d73c27a26" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;cluster-setslot&quot;&gt;CLUSTER SETSLOT&lt;/a&gt; command is an important piece used by Redis Cluster in order to migrate all the keys contained in one hash slot from one node to another. This is how the migration is orchestrated, with the help of other commands as well. We'll call the node that has the current ownership of the hash slot the &lt;code&gt;source&lt;/code&gt; node, and the node where we want to migrate the &lt;code&gt;destination&lt;/code&gt; node.</source>
          <target state="translated">&lt;a href=&quot;cluster-setslot&quot;&gt;CLUSTER의 SETSLOT의&lt;/a&gt; 명령은 하나 개의 노드에서 다른 하나 개의 해시 슬롯에 포함 된 모든 키를 마이그레이션하기 위해 레디 스 클러스터에서 사용되는 중요한 부분이다. 이것은 다른 명령의 도움으로 마이그레이션이 조정되는 방식입니다. 해시 슬롯의 현재 소유권이있는 노드를 &lt;code&gt;source&lt;/code&gt; 노드 및 &lt;code&gt;destination&lt;/code&gt; 노드 를 마이그레이션하려는 노드라고 합니다.</target>
        </trans-unit>
        <trans-unit id="9969254dbf9ad62d16ce54578a579c12bed90714" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;config-get&quot;&gt;CONFIG GET&lt;/a&gt; command is used to read the configuration parameters of a running Redis server. Not all the configuration parameters are supported in Redis 2.4, while Redis 2.6 can read the whole configuration of a server using this command.</source>
          <target state="translated">&lt;a href=&quot;config-get&quot;&gt;구성 GET의&lt;/a&gt; 명령은 실행 레디 스 서버의 구성 매개 변수를 읽는 데 사용됩니다. Redis 2.4에서는 모든 구성 매개 변수가 지원되는 것은 아니지만 Redis 2.6은이 명령을 사용하여 서버의 전체 구성을 읽을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b44e010365af8a822e0e64c895b3b9356396e69b" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;config-rewrite&quot;&gt;CONFIG REWRITE&lt;/a&gt; command rewrites the &lt;code&gt;redis.conf&lt;/code&gt; file the server was started with, applying the minimal changes needed to make it reflect the configuration currently used by the server, which may be different compared to the original one because of the use of the &lt;a href=&quot;config-set&quot;&gt;CONFIG SET&lt;/a&gt; command.</source>
          <target state="translated">&lt;a href=&quot;config-rewrite&quot;&gt;CONFIG 재 작성&lt;/a&gt; 명령은 재 작성 &lt;code&gt;redis.conf&lt;/code&gt; 의 때문에 사용의 원래에 비해 다를 수는 현재 서버에서 사용하는 구성을 반영하기 위해 필요한 최소한의 변경, 적용, 서버가 시작 된 파일을 &lt;a href=&quot;config-set&quot;&gt;CONFIG SET를&lt;/a&gt; 명령.</target>
        </trans-unit>
        <trans-unit id="a94ff0d50f7b4db45f039a4dafafa3f4c9259a89" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;config-set&quot;&gt;CONFIG SET&lt;/a&gt; command is used in order to reconfigure the server at run time without the need to restart Redis. You can change both trivial parameters or switch from one to another persistence option using this command.</source>
          <target state="translated">&lt;a href=&quot;config-set&quot;&gt;CONFIG SET의&lt;/a&gt; 명령은 레디 스를 재시작 할 필요없이 실행시에 서버를 다시 구성하기 위해 사용된다. 이 명령을 사용하여 사소한 매개 변수를 모두 변경하거나 하나에서 다른 지속성 옵션으로 전환 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="166c68e394d8ab06f1a3bb76f56f32a612a6683d" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;eval&quot;&gt;EVAL&lt;/a&gt; command forces you to send the script body again and again. Redis does not need to recompile the script every time as it uses an internal caching mechanism, however paying the cost of the additional bandwidth may not be optimal in many contexts.</source>
          <target state="translated">&lt;a href=&quot;eval&quot;&gt;EVAL의&lt;/a&gt; 명령을 강제로 다시 다시 스크립트 본문을 보낼 수 있습니다. Redis는 내부 캐싱 메커니즘을 사용할 때마다 스크립트를 다시 컴파일하지 않아도되지만 추가 대역폭 비용을 지불하는 것이 많은 상황에서 최적이 아닐 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="bd6411fae08a91e9b321232ed876a3d9070cad9b" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;expire&quot;&gt;EXPIRE&lt;/a&gt; family of commands is able to associate an expire to a given key, at the cost of some additional memory used by the key. When a key has an expire set, Redis will make sure to remove the key when the specified amount of time elapsed.</source>
          <target state="translated">&lt;a href=&quot;expire&quot;&gt;EXPIRE&lt;/a&gt; 명령의 가족은 키에 의해 사용되는 몇 가지 추가 메모리의 비용으로, 주어진 키에 만료에 연결할 수 있습니다. 키에 만료 설정이 있으면 Redis는 지정된 시간이 경과하면 키를 제거합니다.</target>
        </trans-unit>
        <trans-unit id="ae44c019fde6841c16a68c04d38047f2e0f60739" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;info&quot;&gt;INFO&lt;/a&gt; command returns information and statistics about the server in a format that is simple to parse by computers and easy to read by humans.</source>
          <target state="translated">&lt;a href=&quot;info&quot;&gt;정보&lt;/a&gt; 컴퓨터에 의해 분석 간단하고 인간이 읽기 쉬운 형식으로 서버에 대한 명령이 리턴 정보 및 통계.</target>
        </trans-unit>
        <trans-unit id="34c3a5fba12b1ed2508a72f81c29ed6c56b41d88" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;memory-doctor&quot;&gt;MEMORY DOCTOR&lt;/a&gt; command reports about different memory-related issues that the Redis server experiences, and advises about possible remedies.</source>
          <target state="translated">&lt;a href=&quot;memory-doctor&quot;&gt;MEMORY 의사&lt;/a&gt; 서로 다른 메모리 관련 문제에 대한 명령 보고서는 레디 스 서버의 경험 및 가능한 해결 방법에 대해 조언 것이다.</target>
        </trans-unit>
        <trans-unit id="09f518db007c555b3fc51849cb715d5f37978149" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;memory-help&quot;&gt;MEMORY HELP&lt;/a&gt; command returns a helpful text describing the different subcommands.</source>
          <target state="translated">&lt;a href=&quot;memory-help&quot;&gt;MEMORY 도움말&lt;/a&gt; 명령은 다른 부속 명령을 설명하는 유용한 텍스트를 반환합니다.</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
