<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="dom">
    <body>
      <group id="dom">
        <trans-unit id="62af3497de478b3a592a72f79c3a04f47988257c" translate="yes" xml:space="preserve">
          <source>If no matches are found, the returned value is &lt;code&gt;null&lt;/code&gt;.</source>
          <target state="translated">일치하는 것이 없으면 반환 값은 &lt;code&gt;null&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="30427965176657d7da93bf4af87ad0225371d253" translate="yes" xml:space="preserve">
          <source>If no options are currently selected, the collection is empty and returns a &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/HTMLCollection/length&quot;&gt;&lt;code&gt;length&lt;/code&gt;&lt;/a&gt; of 0.</source>
          <target state="translated">현재 선택된 옵션이 없으면 컬렉션이 비어 있고 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/HTMLCollection/length&quot;&gt; &lt;code&gt;length&lt;/code&gt; &lt;/a&gt; 가 0을 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="41b6884f5bfc3c75441c01a27550430eb1cbd63f" translate="yes" xml:space="preserve">
          <source>If no record exists in this index for the given key.</source>
          <target state="translated">주어진 키에 대해이 색인에 레코드가없는 경우</target>
        </trans-unit>
        <trans-unit id="e443587f32b0841ebd956161ec282cd87c376a42" translate="yes" xml:space="preserve">
          <source>If no records exist in this index for the requested key range.</source>
          <target state="translated">요청 된 키 범위에 대해이 색인에 레코드가없는 경우</target>
        </trans-unit>
        <trans-unit id="891c6504f184c5c15d7c40f0daebd942e2b7cd7a" translate="yes" xml:space="preserve">
          <source>If no records match the key range then then the &lt;code&gt;result&lt;/code&gt; property of the event is set to &lt;code&gt;null&lt;/code&gt;.</source>
          <target state="translated">키 범위와 일치하는 레코드가 없으면 이벤트 의 &lt;code&gt;result&lt;/code&gt; 속성이 &lt;code&gt;null&lt;/code&gt; 로 설정됩니다 .</target>
        </trans-unit>
        <trans-unit id="819347bc9248c902b0ed6774d77afa3bd5b418b0" translate="yes" xml:space="preserve">
          <source>If no value is specified for replaceBox, we create a new ad element. The ad's new &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/div&quot;&gt;&lt;code&gt;&amp;lt;div&amp;gt;&lt;/code&gt;&lt;/a&gt; element is created and its properties established by setting its class name to &lt;code&gt;&quot;ad&quot;&lt;/code&gt;. Next, the ad title element is created, along with the body and the visibility timer; these are an &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/h2&quot;&gt;&lt;code&gt;&amp;lt;h2&amp;gt;&lt;/code&gt;&lt;/a&gt;, a &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/p&quot;&gt;&lt;code&gt;&amp;lt;p&amp;gt;&lt;/code&gt;&lt;/a&gt;, and a &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/div&quot;&gt;&lt;code&gt;&amp;lt;div&amp;gt;&lt;/code&gt;&lt;/a&gt; element, respectively. These elements are appended to the &lt;code&gt;adBox&lt;/code&gt; element.</source>
          <target state="translated">replaceBox에 값을 지정하지 않으면 새 광고 요소가 만들어집니다. 클래스 이름을 &lt;code&gt;&quot;ad&quot;&lt;/code&gt; 로 설정하여 광고의 새 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/div&quot;&gt; &lt;code&gt;&amp;lt;div&amp;gt;&lt;/code&gt; &lt;/a&gt; 요소가 생성되고 속성이 설정됩니다 . 다음으로 본문 및 공개 타이머와 함께 광고 제목 요소가 생성됩니다. 이들은 각각 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/h2&quot;&gt; &lt;code&gt;&amp;lt;h2&amp;gt;&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/p&quot;&gt; &lt;code&gt;&amp;lt;p&amp;gt;&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/div&quot;&gt; &lt;code&gt;&amp;lt;div&amp;gt;&lt;/code&gt; &lt;/a&gt; 요소입니다. 이러한 요소는 &lt;code&gt;adBox&lt;/code&gt; 요소에 추가됩니다 .</target>
        </trans-unit>
        <trans-unit id="5ea6b7f8dd1dcbedac170ff03a4c94ce45717abc" translate="yes" xml:space="preserve">
          <source>If no value is specified for the body, a default value of &lt;code&gt;null&lt;/code&gt; is used.</source>
          <target state="translated">본문에 값을 지정하지 않으면 기본값 인 &lt;code&gt;null&lt;/code&gt; 이 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="bcb74434e1aabbad703752ec66b982ba7036f5a5" translate="yes" xml:space="preserve">
          <source>If noOverwrite was true, and a record exists in this index for the given key or this index is auto-populated; or if no record exists with the given key in the index's referenced object store.</source>
          <target state="translated">noOverwrite가 true이고 주어진 키에 대해이 색인에 레코드가 존재하거나이 색인이 자동으로 채워지는 경우; 또는 인덱스의 참조 된 오브젝트 저장소에 제공된 키가있는 레코드가없는 경우.</target>
        </trans-unit>
        <trans-unit id="e2456988966b93e0904747e98b9cd8cb6d2ca5a3" translate="yes" xml:space="preserve">
          <source>If normalized, the resulting wave will have a maximum absolute peak value of 1.</source>
          <target state="translated">정규화되면 결과 파형의 최대 절대 피크 값은 1입니다.</target>
        </trans-unit>
        <trans-unit id="6e12e482e4bbeef0e1b280d070b07d2081cd516b" translate="yes" xml:space="preserve">
          <source>If not &lt;code&gt;null&lt;/code&gt;, &lt;code&gt;sdpMLineIndex&lt;/code&gt; indicates the zero-based index number of the media description (as defined in &lt;a href=&quot;https://tools.ietf.org/html/rfc4566&quot;&gt;RFC 4566&lt;/a&gt;) in the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/SDP&quot;&gt;SDP&lt;/a&gt; with which the candidate is associated.</source>
          <target state="translated">그렇지 않은 경우 &lt;code&gt;null&lt;/code&gt; , &lt;code&gt;sdpMLineIndex&lt;/code&gt; 는 (항에 미디어 정보의 제로 인덱스 번호를 나타낸다 &lt;a href=&quot;https://tools.ietf.org/html/rfc4566&quot;&gt;RFC 4566&lt;/a&gt; 에서) &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/SDP&quot;&gt;SDP&lt;/a&gt; 후보 연관된.</target>
        </trans-unit>
        <trans-unit id="7ee33bd66ebef3140ffba047848ee7ec482f8395" translate="yes" xml:space="preserve">
          <source>If not set, the default value 1 will be used.</source>
          <target state="translated">설정하지 않으면 기본값 1이 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="673e986e95c294aa14e9d3c0610fae9875f84456" translate="yes" xml:space="preserve">
          <source>If not specified in the constructor, this value will be an empty string and the &lt;code&gt;SourceBuffer&lt;/code&gt; can contain any tracks of the specified &lt;a href=&quot;type&quot;&gt;&lt;code&gt;TrackDefault.type&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">생성자에 지정되지 않은 경우이 값은 빈 문자열이되고 &lt;code&gt;SourceBuffer&lt;/code&gt; 는 지정된 &lt;a href=&quot;type&quot;&gt; &lt;code&gt;TrackDefault.type&lt;/code&gt; &lt;/a&gt; 의 모든 트랙을 포함 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="0757f832bf39081ea7ab5064fc1602123ef490de" translate="yes" xml:space="preserve">
          <source>If not specified when the request is created, it takes the default value of &lt;code&gt;follow&lt;/code&gt;.</source>
          <target state="translated">요청이 작성 될 때 지정되지 않은 경우 기본값은 &lt;code&gt;follow&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="0e7ee2dab6b475dd92fa72c0049991d455ec9876" translate="yes" xml:space="preserve">
          <source>If not, fetch the request from the network, then also open the cache created in the first block and add a clone of the request to it using &lt;a href=&quot;cache/put&quot;&gt;&lt;code&gt;Cache.put&lt;/code&gt;&lt;/a&gt; (&lt;code&gt;cache.put(event.request, response.clone())&lt;/code&gt;.)</source>
          <target state="translated">그렇지 않은 경우 네트워크에서 요청을 가져온 다음 첫 번째 블록에서 작성된 캐시를 열고 &lt;a href=&quot;cache/put&quot;&gt; &lt;code&gt;Cache.put&lt;/code&gt; &lt;/a&gt; ( &lt;code&gt;cache.put(event.request, response.clone())&lt;/code&gt; 사용하여 요청의 복제본을 추가하십시오 .)</target>
        </trans-unit>
        <trans-unit id="90a790e2cf5cfbfa96f694b234d76e150780049c" translate="yes" xml:space="preserve">
          <source>If not, open the &lt;code&gt;v1&lt;/code&gt; cache using &lt;a href=&quot;open&quot;&gt;&lt;code&gt;CacheStorage.open()&lt;/code&gt;&lt;/a&gt;, put the default network request in the cache using &lt;a href=&quot;../cache/put&quot;&gt;&lt;code&gt;Cache.put()&lt;/code&gt;&lt;/a&gt; and return a clone of the default network request using &lt;code&gt;return response.clone()&lt;/code&gt;. The last is necessary because &lt;code&gt;put()&lt;/code&gt; consumes the response body.</source>
          <target state="translated">그렇지 않은 경우 &lt;a href=&quot;open&quot;&gt; &lt;code&gt;CacheStorage.open()&lt;/code&gt; &lt;/a&gt; 사용하여 &lt;code&gt;v1&lt;/code&gt; 캐시를 열고 &lt;a href=&quot;../cache/put&quot;&gt; &lt;code&gt;Cache.put()&lt;/code&gt; &lt;/a&gt; 사용하여 기본 네트워크 요청을 캐시에 넣고 &lt;code&gt;return response.clone()&lt;/code&gt; 사용하여 기본 네트워크 요청의 복제본을 반환하십시오 . &lt;code&gt;put()&lt;/code&gt; 이 응답 본문을 소비 하기 때문에 마지막이 필요 합니다.</target>
        </trans-unit>
        <trans-unit id="07e02a06eba67509888efb6e898cf9b0bcedbd6e" translate="yes" xml:space="preserve">
          <source>If not, open the &lt;code&gt;v1&lt;/code&gt; cache using &lt;code&gt;open()&lt;/code&gt;, put the default network request in the cache using &lt;a href=&quot;../cache/put&quot;&gt;&lt;code&gt;Cache.put()&lt;/code&gt;&lt;/a&gt; and return a clone of the default network request using &lt;code&gt;return response.clone()&lt;/code&gt;. The last is necessary because &lt;code&gt;put()&lt;/code&gt; consumes the response body.</source>
          <target state="translated">그렇지 않은 경우 &lt;code&gt;open()&lt;/code&gt; 사용하여 &lt;code&gt;v1&lt;/code&gt; 캐시를 열고 &lt;a href=&quot;../cache/put&quot;&gt; &lt;code&gt;Cache.put()&lt;/code&gt; &lt;/a&gt; 사용하여 기본 네트워크 요청을 캐시에 넣고 &lt;code&gt;return response.clone()&lt;/code&gt; 사용하여 기본 네트워크 요청의 복제본을 반환하십시오 . &lt;code&gt;put()&lt;/code&gt; 이 응답 본문을 소비 하기 때문에 마지막이 필요 합니다.</target>
        </trans-unit>
        <trans-unit id="6d83aa88da97ab64afd0199340b7c276b84cef23" translate="yes" xml:space="preserve">
          <source>If not, open the &lt;code&gt;v1&lt;/code&gt; cache using &lt;code&gt;open()&lt;/code&gt;, put the default network request in the cache using &lt;a href=&quot;put&quot;&gt;&lt;code&gt;Cache.put()&lt;/code&gt;&lt;/a&gt; and return a clone of the default network request using &lt;code&gt;return response.clone()&lt;/code&gt;. Clone is needed because &lt;code&gt;put()&lt;/code&gt; consumes the response body.</source>
          <target state="translated">그렇지 않은 경우 &lt;code&gt;open()&lt;/code&gt; 사용하여 &lt;code&gt;v1&lt;/code&gt; 캐시를 열고 &lt;a href=&quot;put&quot;&gt; &lt;code&gt;Cache.put()&lt;/code&gt; &lt;/a&gt; 사용하여 기본 네트워크 요청을 캐시에 넣고 &lt;code&gt;return response.clone()&lt;/code&gt; 사용하여 기본 네트워크 요청의 복제본을 반환하십시오 . &lt;code&gt;put()&lt;/code&gt; 이 응답 본문을 소비 하기 때문에 복제가 필요합니다 .</target>
        </trans-unit>
        <trans-unit id="b232fc56252bc65472dc0eb0dc0783d4d8a07df5" translate="yes" xml:space="preserve">
          <source>If omitted, &lt;code&gt;count()&lt;/code&gt; outputs the number of times it has been called at that line.</source>
          <target state="translated">생략하면 &lt;code&gt;count()&lt;/code&gt; 는 해당 행에서 호출 된 횟수를 출력합니다.</target>
        </trans-unit>
        <trans-unit id="4f5ff69c02f06de5945a1c2edc80cc69443c01f6" translate="yes" xml:space="preserve">
          <source>If omitted, &lt;code&gt;count()&lt;/code&gt; resets the default counter to 0.</source>
          <target state="translated">생략하면 &lt;code&gt;count()&lt;/code&gt; 는 기본 카운터를 0으로 재설정합니다.</target>
        </trans-unit>
        <trans-unit id="ce8900db9c12a487fb7bffb8b2e896ec3a34d539" translate="yes" xml:space="preserve">
          <source>If on, the new created window floats below, under its own parent when the parent window is not minimized. alwaysLowered windows are often referred as pop-under windows. The alwaysLowered window can not be on top of the parent but the parent window can be minimized. In NS 6.x, the alwaysLowered window has no minimize system command icon and no restore/maximize system command.</source>
          <target state="translated">설정하면 부모 창을 최소화하지 않은 경우 새로 만든 창이 자체 부모 아래에 표시됩니다. 항상 낮은 창은 종종 팝 언더 창이라고합니다. alwaysLowered 창은 부모 위에있을 수 없지만 부모 창을 최소화 할 수 있습니다. NS 6.x에서 alwaysLowered 창에는 시스템 명령 최소화 아이콘이없고 시스템 복원 / 최대 명령이 없습니다.</target>
        </trans-unit>
        <trans-unit id="9b84813b12f564ed09e107932338337e21e57594" translate="yes" xml:space="preserve">
          <source>If on, the new window is said to be dependent of its parent window. A dependent window closes when its parent window closes. A dependent window is minimized on the Windows task bar only when its parent window is minimized. On Windows platforms, a dependent window does not show on the task bar. A dependent window also stays in front of the parent window.</source>
          <target state="translated">설정하면 새 창은 부모 창에 종속된다고합니다. 부모 창이 닫히면 종속 창이 닫힙니다. 부모 창이 최소화 된 경우에만 Windows 작업 표시 줄에서 종속 창이 최소화됩니다. Windows 플랫폼에서 작업 표시 줄에 종속 창이 표시되지 않습니다. 종속 창은 부모 창 앞에 유지됩니다.</target>
        </trans-unit>
        <trans-unit id="c1fb6e9083adda333ef3c6d186a7ec472a199a27" translate="yes" xml:space="preserve">
          <source>If on, the new window is said to be modal. The user cannot return to the main window until the modal window is closed. A typical modal window is created by the &lt;a href=&quot;alert&quot;&gt;alert() function&lt;/a&gt;.</source>
          <target state="translated">설정하면 새 창이 모달이라고합니다. 모달 창을 닫을 때까지 사용자는 기본 창으로 돌아갈 수 없습니다. 일반적인 모달 창은 &lt;a href=&quot;alert&quot;&gt;alert () 함수에&lt;/a&gt; 의해 생성됩니다 .</target>
        </trans-unit>
        <trans-unit id="97df8056330640a40aabffb2410b7a88183a50f3" translate="yes" xml:space="preserve">
          <source>If on, the new window will always be displayed on top of other browser windows, regardless of whether it is active or not.</source>
          <target state="translated">설정하면 새 창은 활성 여부에 관계없이 항상 다른 브라우저 창 위에 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="781e8ecebe1c06e51767b036f57f3fc7ea116bb1" translate="yes" xml:space="preserve">
          <source>If on, the page is loaded as window's only content, without any of the browser's interface elements. There will be no context menu defined by default and none of the standard keyboard shortcuts will work. The page is supposed to provide a user interface of its own, usually this feature is used to open XUL documents (standard dialogs like the JavaScript Console are opened this way).</source>
          <target state="translated">설정하면 브라우저의 인터페이스 요소없이 페이지가 창의 유일한 내용으로로드됩니다. 기본적으로 컨텍스트 메뉴가 정의되어 있지 않으며 표준 키보드 단축키가 작동하지 않습니다. 이 페이지는 자체 사용자 인터페이스를 제공해야하며 일반적으로이 기능은 XUL 문서를 여는 데 사용됩니다 (JavaScript 콘솔과 같은 표준 대화 상자는 이런 방식으로 열립니다).</target>
        </trans-unit>
        <trans-unit id="ad98bfc4635851a5c494597a5c58c4bdf5293cdb" translate="yes" xml:space="preserve">
          <source>If one of the following conditions is true:</source>
          <target state="translated">다음 조건 중 하나에 해당하면 :</target>
        </trans-unit>
        <trans-unit id="10059bc20cf5e5b6b0eaaf317b9c39d4bef7b92d" translate="yes" xml:space="preserve">
          <source>If permission to display notifications hasn't been granted yet, the application needs to use the &lt;a href=&quot;../notification/requestpermission&quot;&gt;&lt;code&gt;Notification.requestPermission()&lt;/code&gt;&lt;/a&gt; method to request this from the user. In its simplest form, we just include the following:</source>
          <target state="translated">알림 표시 권한이 아직 부여되지 않은 경우 응용 프로그램은 &lt;a href=&quot;../notification/requestpermission&quot;&gt; &lt;code&gt;Notification.requestPermission()&lt;/code&gt; &lt;/a&gt; 메서드를 사용 하여 사용자에게이를 요청해야합니다. 가장 간단한 형태로 다음을 포함합니다.</target>
        </trans-unit>
        <trans-unit id="82c9b451808a0ddb60d5449d6e5e08efb79a0265" translate="yes" xml:space="preserve">
          <source>If possible, you may also include the file URL of the file using both the &lt;code&gt;text/uri-list&lt;/code&gt; and/or &lt;code&gt;text/plain&lt;/code&gt; types. These types should be added last so that the more specific &lt;code&gt;application/x-moz-file&lt;/code&gt; type has higher priority.</source>
          <target state="translated">가능하면 &lt;code&gt;text/uri-list&lt;/code&gt; 및 / 또는 &lt;code&gt;text/plain&lt;/code&gt; 유형 을 모두 사용하여 파일의 파일 URL을 포함 할 수도 있습니다. 보다 구체적인 &lt;code&gt;application/x-moz-file&lt;/code&gt; 유형이 더 높은 우선 순위를 갖도록 이러한 유형을 마지막에 추가해야합니다 .</target>
        </trans-unit>
        <trans-unit id="11d445890bc7ffe3155003cb09a1109f2a60504d" translate="yes" xml:space="preserve">
          <source>If present, this &lt;a href=&quot;domstring&quot;&gt;&lt;code&gt;DOMString&lt;/code&gt;&lt;/a&gt; is a string describing the validation error from which the payer's email address&amp;mdash;as given by &lt;a href=&quot;paymentresponse/payeremail&quot;&gt;&lt;code&gt;PaymentResponse.payerEmail&lt;/code&gt;&lt;/a&gt;&amp;mdash;currently suffers. If this property is absent from the &lt;code&gt;PayerErrors&lt;/code&gt; object, the email address passed validation.</source>
          <target state="translated">존재하는 경우,이 &lt;a href=&quot;domstring&quot;&gt; &lt;code&gt;DOMString&lt;/code&gt; &lt;/a&gt; 은 &lt;a href=&quot;paymentresponse/payeremail&quot;&gt; &lt;code&gt;PaymentResponse.payerEmail&lt;/code&gt; &lt;/a&gt; 에서 제공 한 지불 인의 전자 우편 주소가 현재 겪고 있는 검증 오류를 설명하는 문자열 입니다. 이 특성이 &lt;code&gt;PayerErrors&lt;/code&gt; 오브젝트에 없으면 이메일 주소가 유효성 검증을 통과했습니다.</target>
        </trans-unit>
        <trans-unit id="3dd45e4cf02462d4d6108a75158909734a981627" translate="yes" xml:space="preserve">
          <source>If present, this string is an error message explaining why the payer's phone number (&lt;a href=&quot;paymentresponse/payerphone&quot;&gt;&lt;code&gt;PaymentResponse.payerPhone&lt;/code&gt;&lt;/a&gt;) failed validation. This property is absent if the phone number passed validation.</source>
          <target state="translated">존재하는 경우이 문자열은 지불 자의 전화 번호 ( &lt;a href=&quot;paymentresponse/payerphone&quot;&gt; &lt;code&gt;PaymentResponse.payerPhone&lt;/code&gt; &lt;/a&gt; )가 유효성 검증에 실패한 이유를 설명하는 오류 메시지 입니다. 전화 번호가 유효성 검사를 통과 한 경우이 속성이 없습니다.</target>
        </trans-unit>
        <trans-unit id="c5f7a4318b7d5cc217a600fb8f036e6e510d922c" translate="yes" xml:space="preserve">
          <source>If provided, this must be a method which is caled when an error occurs while trying to create the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/FileWriter&quot;&gt;&lt;code&gt;FileWriter&lt;/code&gt;&lt;/a&gt;. This callback receives as input a &lt;a href=&quot;../fileerror&quot;&gt;&lt;code&gt;FileError&lt;/code&gt;&lt;/a&gt; object describing the error.</source>
          <target state="translated">제공되는 경우, &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/FileWriter&quot;&gt; &lt;code&gt;FileWriter&lt;/code&gt; &lt;/a&gt; 를 작성하는 중에 오류가 발생할 때 계산되는 메소드 여야합니다 . 이 콜백 은 오류를 설명 하는 &lt;a href=&quot;../fileerror&quot;&gt; &lt;code&gt;FileError&lt;/code&gt; &lt;/a&gt; 객체를 입력으로받습니다 .</target>
        </trans-unit>
        <trans-unit id="d4bb2b985058da2efc0d3d91df476880db0435dc" translate="yes" xml:space="preserve">
          <source>If provided, this must be a method which is called when an error occurs while trying to create the &lt;a href=&quot;../file&quot;&gt;&lt;code&gt;File&lt;/code&gt;&lt;/a&gt;. This callback receives as input a &lt;a href=&quot;../fileerror&quot;&gt;&lt;code&gt;FileError&lt;/code&gt;&lt;/a&gt; object describing the error.</source>
          <target state="translated">제공되는 경우 &lt;a href=&quot;../file&quot;&gt; &lt;code&gt;File&lt;/code&gt; &lt;/a&gt; 을 작성하는 중 오류가 발생하면 호출되는 메소드 여야합니다 . 이 콜백 은 오류를 설명 하는 &lt;a href=&quot;../fileerror&quot;&gt; &lt;code&gt;FileError&lt;/code&gt; &lt;/a&gt; 객체를 입력으로받습니다 .</target>
        </trans-unit>
        <trans-unit id="3f9455402622d1806532a4d052e9477a14392631" translate="yes" xml:space="preserve">
          <source>If requested via payment options, returns the shipping address chosen by the user for the purposes of calculating shipping. This property is only populated if the constructor is called with the &lt;code&gt;requestShipping&lt;/code&gt; flag set to true. Additionally, in some browsers, the parts of the address will be redacted for privacy until the user indicates they are ready to complete the transaction (i.e., they hit &quot;Pay&quot;).</source>
          <target state="translated">결제 옵션을 통해 요청한 경우 배송료 계산을 위해 사용자가 선택한 배송지 주소를 반환합니다. 이 특성은 생성자가 &lt;code&gt;requestShipping&lt;/code&gt; 플래그가 true로 설정된 상태에서 생성 된 경우에만 채워집니다 . 또한 일부 브라우저에서는 사용자가 거래를 완료 할 준비가되었다고 표시 할 때까지 (예 : &quot;지급&quot;을 누를 때까지) 주소의 일부가 프라이버시를 위해 수정됩니다.</target>
        </trans-unit>
        <trans-unit id="38a4bab9445dd332bdc20512261008b57b4512f8" translate="yes" xml:space="preserve">
          <source>If reserving all the database objects identified in &lt;code&gt;storeNames&lt;/code&gt; takes longer than the &lt;code&gt;timeout&lt;/code&gt; interval.</source>
          <target state="translated">&lt;code&gt;storeNames&lt;/code&gt; 에서 식별 된 모든 데이터베이스 오브젝트를 예약하는 경우 &lt;code&gt;timeout&lt;/code&gt; 간격 보다 오래 걸립니다 .</target>
        </trans-unit>
        <trans-unit id="7905a651ecd1c2a4b475f1721ea4b893482f716a" translate="yes" xml:space="preserve">
          <source>If resetting the playback position to the beginning of the media actually changes the playback position (that is, it was not already at the beginning), a &lt;code&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Events/timeupdate&quot;&gt;timeupdate&lt;/a&gt;&lt;/code&gt; event is sent.</source>
          <target state="translated">재생 위치를 미디어의 시작 부분으로 재설정하면 실제로 재생 위치가 변경되는 경우 (즉, 아직 시작 위치가 아님) &lt;code&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Events/timeupdate&quot;&gt;timeupdate&lt;/a&gt;&lt;/code&gt; 이벤트가 전송됩니다.</target>
        </trans-unit>
        <trans-unit id="9103382182cb540627a2cfe55b6121004db25389" translate="yes" xml:space="preserve">
          <source>If set by the &lt;a href=&quot;https://www.w3.org/TR/presentation-api/#dfn-controller&quot;&gt;controller&lt;/a&gt;, the value of the &lt;a href=&quot;https://www.w3.org/TR/presentation-api/#dom-presentation-defaultrequest&quot;&gt;&lt;code&gt;defaultRequest&lt;/code&gt;&lt;/a&gt; attribute &lt;em&gt;SHOULD&lt;/em&gt; be used by the &lt;a href=&quot;https://www.w3.org/TR/presentation-api/#dfn-controlling-user-agent&quot;&gt;controlling user agent&lt;/a&gt; as the</source>
          <target state="translated">에 의해 설정하면 &lt;a href=&quot;https://www.w3.org/TR/presentation-api/#dfn-controller&quot;&gt;컨트롤러&lt;/a&gt; 의 값 &lt;a href=&quot;https://www.w3.org/TR/presentation-api/#dom-presentation-defaultrequest&quot;&gt; &lt;code&gt;defaultRequest&lt;/code&gt; &lt;/a&gt; 특성 &lt;em&gt;SHOULD&lt;/em&gt; 의해 사용될 &lt;a href=&quot;https://www.w3.org/TR/presentation-api/#dfn-controlling-user-agent&quot;&gt;제어 사용자 에이전트&lt;/a&gt; 는 AS</target>
        </trans-unit>
        <trans-unit id="57db2d1824f473e0120c9f7346d808ebe974ba48" translate="yes" xml:space="preserve">
          <source>If set to a value greater than the maximum available for the element, scrollTop settles itself to the maximum value.</source>
          <target state="translated">요소에 사용 가능한 최대 값보다 큰 값으로 설정하면 scrollTop이 최대 값으로 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="fb91d299881ca8a03047c046e456b9daf1e61584" translate="yes" xml:space="preserve">
          <source>If set to a value greater than the maximum that the content can be scrolled, &lt;code&gt;scrollLeft&lt;/code&gt; is set to the maximum.</source>
          <target state="translated">내용을 스크롤 할 수있는 최대 값보다 큰 값 으로 설정하면 &lt;code&gt;scrollLeft&lt;/code&gt; 가 최대 값으로 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="b396ce3d017fc9b2c19f5b6ecd02ed00a95f2d7c" translate="yes" xml:space="preserve">
          <source>If set to a value less than 0 (greater than 0 for right-to-left elements), &lt;code&gt;scrollLeft&lt;/code&gt; is set to 0.</source>
          <target state="translated">0보다 작은 값 (오른쪽에서 왼쪽 요소의 경우 0보다 큰 값) 으로 설정하면 &lt;code&gt;scrollLeft&lt;/code&gt; 가 0으로 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="f20ad3ba204c16518563a1e89e5313e670617f08" translate="yes" xml:space="preserve">
          <source>If several listeners are attached to the same element for the same event type, they are called in order in which they have been added. If during one such call, &lt;code&gt;event.stopImmediatePropagation()&lt;/code&gt; is called, no remaining listeners will be called.</source>
          <target state="translated">동일한 이벤트 유형의 동일한 요소에 여러 리스너가 첨부 된 경우 추가 된 순서대로 리스너가 호출됩니다. 이러한 호출 중 &lt;code&gt;event.stopImmediatePropagation()&lt;/code&gt; 이 호출되면 나머지 리스너가 호출되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="f1b5236ddb8c1e86cee0e6e3a47eb9b45c67ca6c" translate="yes" xml:space="preserve">
          <source>If something is wrong with the payment response's data (and there is a recoverable error), this method allows a merchant to request that the user retry the payment. The method takes an object as argument, which is used to signal to the user exactly what is wrong with the payment response so they can try to correct any issues.</source>
          <target state="translated">결제 응답 데이터에 문제가있는 경우 (및 복구 가능한 오류가있는 경우)이 방법을 사용하면 판매자가 사용자에게 결제 재 시도를 요청할 수 있습니다. 이 메소드는 객체를 인수로 사용하여 사용자에게 결제 응답에 어떤 문제가 있는지 정확하게 알려주는 데 사용되므로 문제를 해결할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9be25b915ad492818ccc0a90ff29e4909bdcbee3" translate="yes" xml:space="preserve">
          <source>If successful, a service worker registration ties the provided script URL to a &lt;em&gt;scope&lt;/em&gt;, which is subsequently used for navigation matching. You can call this method unconditionally from the controlled page. I.e., you don't need to first check whether there's an active registration.</source>
          <target state="translated">성공한 경우 서비스 워커 등록은 제공된 스크립트 URL을 &lt;em&gt;scope에 연결&lt;/em&gt; 하며,이 URL 은 탐색 일치에 사용됩니다. 제어 된 페이지에서이 메소드를 무조건 호출 할 수 있습니다. 즉, 활성 등록이 있는지 먼저 확인할 필요가 없습니다.</target>
        </trans-unit>
        <trans-unit id="9b40b913e651bc52768b8e11d27ea91344c12177" translate="yes" xml:space="preserve">
          <source>If successful, the service worker is executed in a &lt;a href=&quot;../serviceworkerglobalscope&quot;&gt;&lt;code&gt;ServiceWorkerGlobalScope&lt;/code&gt;&lt;/a&gt;; this is basically a special kind of worker context, running off the main script execution thread, with no DOM access.</source>
          <target state="translated">성공하면 서비스 워커는 &lt;a href=&quot;../serviceworkerglobalscope&quot;&gt; &lt;code&gt;ServiceWorkerGlobalScope&lt;/code&gt; &lt;/a&gt; 에서 실행됩니다 . 이것은 기본적으로 DOM 액세스없이 기본 스크립트 실행 스레드를 실행하는 특수한 종류의 작업자 컨텍스트입니다.</target>
        </trans-unit>
        <trans-unit id="f9081954b4c110a74945574cdfa52488cc159078" translate="yes" xml:space="preserve">
          <source>If such a &lt;a href=&quot;https://www.w3.org/TR/presentation-api/#idl-def-presentationconnection&quot;&gt;&lt;code&gt;PresentationConnection&lt;/code&gt;&lt;/a&gt; exists, let &lt;var&gt;E&lt;/var&gt; be that &lt;a href=&quot;https://www.w3.org/TR/presentation-api/#idl-def-presentationconnection&quot;&gt;&lt;code&gt;PresentationConnection&lt;/code&gt;&lt;/a&gt;, and run the following steps:</source>
          <target state="translated">그러한 &lt;a href=&quot;https://www.w3.org/TR/presentation-api/#idl-def-presentationconnection&quot;&gt; &lt;code&gt;PresentationConnection&lt;/code&gt; &lt;/a&gt; 이 존재 하는 경우 &lt;var&gt;E&lt;/var&gt; 를 해당 &lt;a href=&quot;https://www.w3.org/TR/presentation-api/#idl-def-presentationconnection&quot;&gt; &lt;code&gt;PresentationConnection&lt;/code&gt; &lt;/a&gt; 으로 설정하고 다음 단계를 실행하십시오.</target>
        </trans-unit>
        <trans-unit id="e045ee12cdba29edc14fdfb41ec85089ea437df5" translate="yes" xml:space="preserve">
          <source>If such a &lt;a href=&quot;https://www.w3.org/TR/presentation-api/#idl-def-presentationconnection&quot;&gt;&lt;code&gt;PresentationConnection&lt;/code&gt;&lt;/a&gt; exists, run the following steps:</source>
          <target state="translated">그러한 &lt;a href=&quot;https://www.w3.org/TR/presentation-api/#idl-def-presentationconnection&quot;&gt; &lt;code&gt;PresentationConnection&lt;/code&gt; &lt;/a&gt; 이 존재하면 다음 단계를 실행하십시오.</target>
        </trans-unit>
        <trans-unit id="7d5cc2b3dba6329bbde109de70c136061c024392" translate="yes" xml:space="preserve">
          <source>If supplied, &lt;code&gt;count()&lt;/code&gt; outputs the number of times it has been called with that label.</source>
          <target state="translated">제공된 경우 &lt;code&gt;count()&lt;/code&gt; 는 해당 레이블로 호출 된 횟수를 출력합니다.</target>
        </trans-unit>
        <trans-unit id="266e96376daac2c6e1295fb39d8130f08852f6f2" translate="yes" xml:space="preserve">
          <source>If supplied, &lt;code&gt;countReset()&lt;/code&gt; resets the count for that label to 0.</source>
          <target state="translated">제공된 경우 &lt;code&gt;countReset()&lt;/code&gt; 은 해당 레이블의 수를 0으로 재설정합니다.</target>
        </trans-unit>
        <trans-unit id="67deff97c272dd559905ecc53a9a6b1c2e4d3a21" translate="yes" xml:space="preserve">
          <source>If supported, textures can be stored in a compressed format in video memory. This allows for additional detail while limiting the added video memory necessary. Textures are uncompressed on the fly when being accessed by a shader. Note that this advantage doesn't translate to network bandwidth: while the formats are better than uncompressed data, they are in general far worse than standard image formats such as PNG and JPG.</source>
          <target state="translated">지원되는 경우 텍스처를 비디오 메모리에 압축 형식으로 저장할 수 있습니다. 이것은 추가 된 비디오 메모리를 제한하면서 추가 세부 사항을 허용합니다. 셰이더가 액세스 할 때 텍스처가 즉석에서 압축 해제됩니다. 이 장점은 네트워크 대역폭으로 변환되지 않습니다. 형식은 압축되지 않은 데이터보다 낫지 만 일반적으로 PNG 및 JPG와 같은 표준 이미지 형식보다 훨씬 나쁩니다.</target>
        </trans-unit>
        <trans-unit id="92b93ee17acdbc0845f734e081d623635e29ce30" translate="yes" xml:space="preserve">
          <source>If that sounds a little abstract open up the vertex shader and play around with the scale factor and watch how it shrinks vertices more towards the surface. Completely change the w component values for really trippy representations of space.</source>
          <target state="translated">그 소리가 약간 추상적이면 정점 셰이더를 열고 스케일 팩터로 놀면서 표면을 향하여 정점이 어떻게 축소되는지 살펴보십시오. 공간을 실제로 표현하기 위해 w 구성 요소 값을 완전히 변경하십시오.</target>
        </trans-unit>
        <trans-unit id="92d3af265bcb9d0fc118daea86fec2e567fdcc08" translate="yes" xml:space="preserve">
          <source>If that succeeds, the resulting stream is assigned as the source for a &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/video&quot;&gt;&lt;code&gt;&amp;lt;video&amp;gt;&lt;/code&gt;&lt;/a&gt; element which is referenced by the variable &lt;code&gt;previewElement&lt;/code&gt;.</source>
          <target state="translated">성공하면 결과 스트림은 변수 &lt;code&gt;previewElement&lt;/code&gt; 에 의해 참조되는 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/video&quot;&gt; &lt;code&gt;&amp;lt;video&amp;gt;&lt;/code&gt; &lt;/a&gt; 요소 의 소스로 할당됩니다 .</target>
        </trans-unit>
        <trans-unit id="552646da16e9421915901fe0d602e6a8c2986cf1" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;../datatransfer/dropeffect&quot;&gt;&lt;code&gt;dropEffect&lt;/code&gt;&lt;/a&gt; property has the value &lt;code&gt;none&lt;/code&gt; during a &lt;code&gt;&lt;code&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Events/dragend&quot;&gt;dragend&lt;/a&gt;&lt;/code&gt;&lt;/code&gt;, then the drag was cancelled. Otherwise, the effect specifies which operation was performed. The source can use this information after a move operation to remove the dragged item from the old location. The &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/DataTransfer/mozUserCancelled&quot;&gt;&lt;code&gt;mozUserCancelled&lt;/code&gt;&lt;/a&gt; property will be set to true if the user cancelled the drag (by pressing Escape), and false if the drag was cancelled for other reasons such as an invalid drop target, or if it was successful.</source>
          <target state="translated">&lt;code&gt;&lt;code&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Events/dragend&quot;&gt;dragend&lt;/a&gt;&lt;/code&gt;&lt;/code&gt; 동안 &lt;a href=&quot;../datatransfer/dropeffect&quot;&gt; &lt;code&gt;dropEffect&lt;/code&gt; &lt;/a&gt; 속성에 &lt;code&gt;none&lt;/code&gt; 값이 있으면 드래그가 취소 된 것입니다. 그렇지 않으면 효과는 수행 된 작업을 지정합니다. 소스는 이동 조작 후이 정보를 사용하여 이전 위치에서 끌어온 항목을 제거 할 수 있습니다. &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/DataTransfer/mozUserCancelled&quot;&gt; &lt;code&gt;mozUserCancelled&lt;/code&gt; 의&lt;/a&gt; 가 성공하면 속성은 사용자가 (Esc 키를 눌러) 드래그를 취소하는 경우 true로 설정하고, 거짓 드래그가 다른 이유로 취소 된 경우 등 잘못된 드롭 대상으로, 또는됩니다.</target>
        </trans-unit>
        <trans-unit id="850f709d69110a028fc27f525e30dd0912e70d18" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;../filelist&quot;&gt;&lt;code&gt;FileList&lt;/code&gt;&lt;/a&gt; object passed to &lt;code&gt;handleFiles()&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt;, we simply set the inner HTML of the block to display &quot;No files selected!&quot;. Otherwise, we start building our file list, as follows:</source>
          <target state="translated">&lt;code&gt;handleFiles()&lt;/code&gt; 전달 된 &lt;a href=&quot;../filelist&quot;&gt; &lt;code&gt;FileList&lt;/code&gt; &lt;/a&gt; 객체 가 &lt;code&gt;null&lt;/code&gt; 인 경우 블록의 내부 HTML을 설정하여 &quot;No files selected!&quot;를 표시합니다. 그렇지 않으면 다음과 같이 파일 목록을 작성하기 시작합니다.</target>
        </trans-unit>
        <trans-unit id="54e38e4fe6edbb31e95aca1c7ed3d70a2c18db85" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;../idledeadline&quot;&gt;&lt;code&gt;IdleDeadline&lt;/code&gt;&lt;/a&gt; object's &lt;a href=&quot;didtimeout&quot;&gt;&lt;code&gt;didTimeout&lt;/code&gt;&lt;/a&gt; property is true, this method returns zero.</source>
          <target state="translated">는 IF &lt;a href=&quot;../idledeadline&quot;&gt; &lt;code&gt;IdleDeadline&lt;/code&gt; 의&lt;/a&gt; 객체의 &lt;a href=&quot;didtimeout&quot;&gt; &lt;code&gt;didTimeout&lt;/code&gt; 의&lt;/a&gt; 속성이 true,이 방법 반환 제로.</target>
        </trans-unit>
        <trans-unit id="dbcb836f3eed0a7056887092176acf49e0abfdf9" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;../paymentaddress&quot;&gt;&lt;code&gt;PaymentAddress&lt;/code&gt;&lt;/a&gt; object's &lt;code&gt;addressLine&lt;/code&gt; property was determined to be valid, this property is not included in the &lt;code&gt;AddressErrors&lt;/code&gt; dictionary.</source>
          <target state="translated">는 IF &lt;a href=&quot;../paymentaddress&quot;&gt; &lt;code&gt;PaymentAddress&lt;/code&gt; 의&lt;/a&gt; 객체의 &lt;code&gt;addressLine&lt;/code&gt; 의 속성이 유효한 것으로 결정되었다,이 속성은 포함되어 있지 않습니다 &lt;code&gt;AddressErrors&lt;/code&gt; 의 사전.</target>
        </trans-unit>
        <trans-unit id="7c2af40f5ae124449fe954dd48d2226f2d44386e" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;../paymentaddress&quot;&gt;&lt;code&gt;PaymentAddress&lt;/code&gt;&lt;/a&gt; object's &lt;code&gt;country&lt;/code&gt; property was determined to be valid, this property is not included in the dictionary.</source>
          <target state="translated">는 IF &lt;a href=&quot;../paymentaddress&quot;&gt; &lt;code&gt;PaymentAddress&lt;/code&gt; 의&lt;/a&gt; 객체의 &lt;code&gt;country&lt;/code&gt; 속성이 유효한 것으로 결정되었다,이 속성은 사전에 포함되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="147001a0dd626060b5ebef5188516293700b62b1" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;../vrdisplay&quot;&gt;&lt;code&gt;VRDisplay&lt;/code&gt;&lt;/a&gt; is already presenting when &lt;code&gt;requestPresent()&lt;/code&gt; is called, the &lt;code&gt;VRDisplay&lt;/code&gt; will update the &lt;code&gt;VRLayer&lt;/code&gt; array being presented.</source>
          <target state="translated">는 IF &lt;a href=&quot;../vrdisplay&quot;&gt; &lt;code&gt;VRDisplay&lt;/code&gt; 가&lt;/a&gt; 이미 때 제시 &lt;code&gt;requestPresent()&lt;/code&gt; 호출되면 &lt;code&gt;VRDisplay&lt;/code&gt; 는 업데이트됩니다 &lt;code&gt;VRLayer&lt;/code&gt; 의 배열되게된다.</target>
        </trans-unit>
        <trans-unit id="d3806601b4e059fb4c4ca55753bcdc1ee0676736" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;attributes&quot;&gt;&lt;code&gt;attributes&lt;/code&gt;&lt;/a&gt; permission is &lt;code&gt;true&lt;/code&gt; but no &lt;code&gt;attributeFilter&lt;/code&gt; is included in the options object, all attributes' values are watched for changes.</source>
          <target state="translated">는 IF &lt;a href=&quot;attributes&quot;&gt; &lt;code&gt;attributes&lt;/code&gt; &lt;/a&gt; 권한입니다 &lt;code&gt;true&lt;/code&gt; 하지만 &lt;code&gt;attributeFilter&lt;/code&gt; 이 옵션은 객체에 포함되지 않습니다, 모든 속성 '값은 변화를 감시한다.</target>
        </trans-unit>
        <trans-unit id="cfb275930f1061739bc18098b953c6f9451d6f87" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/user_agent&quot;&gt;user agent&lt;/a&gt; is configured not to allow automatic or script-initiated playback of media, calling &lt;code&gt;play()&lt;/code&gt; will cause the returned promise to be immediately rejected with a &lt;code&gt;&quot;NotAllowedError&quot;&lt;/code&gt;. Web sites should be prepared to handle this situation. For example, a site should not present a user interface that assumes playback has begun automatically, but should instead update their UI based on whether the returned promise is resolved or rejected. See the &lt;a href=&quot;#Example&quot;&gt;example&lt;/a&gt; below for more information.</source>
          <target state="translated">&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/user_agent&quot;&gt;사용자 에이전트&lt;/a&gt; 가 자동 또는 스크립트 시작 미디어 재생을 허용하지 않도록 구성된 경우 &lt;code&gt;play()&lt;/code&gt; 를 호출 하면 &lt;code&gt;&quot;NotAllowedError&quot;&lt;/code&gt; 와 함께 반환 된 약속이 즉시 거부됩니다 . 이 상황을 처리 할 수 ​​있도록 웹 사이트를 준비해야합니다. 예를 들어, 사이트는 재생이 자동으로 시작되었다고 가정하는 사용자 인터페이스를 제공해서는 안되며 대신 반환 된 약속이 해결되는지 거부되는지에 따라 UI를 업데이트해야합니다. 자세한 내용은 아래 &lt;a href=&quot;#Example&quot;&gt;예&lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="fd594667e78a6fa64cff5b8bb1c94bc6daf6d29a" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/VRDisplay&quot;&gt;&lt;code&gt;VRDevice&lt;/code&gt;&lt;/a&gt; is presenting, this method returns an array of the &lt;a href=&quot;../vrlayerinit&quot;&gt;&lt;code&gt;VRLayerInit&lt;/code&gt;&lt;/a&gt; objects currently being presented (this will currently be one, as &lt;a href=&quot;../vrdisplaycapabilities/maxlayers&quot;&gt;&lt;code&gt;VRDisplayCapabilities.maxLayers&lt;/code&gt;&lt;/a&gt; is currently always 1). If the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/VRDisplay&quot;&gt;&lt;code&gt;VRDevice&lt;/code&gt;&lt;/a&gt; is not presenting, this method returns an empty array.</source>
          <target state="translated">경우] &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/VRDisplay&quot;&gt; &lt;code&gt;VRDevice&lt;/code&gt; 이&lt;/a&gt; 제시되며,이 방법은 어레이 반환 &lt;a href=&quot;../vrlayerinit&quot;&gt; &lt;code&gt;VRLayerInit&lt;/code&gt; 는&lt;/a&gt; (본은 한 것, 현재 표시중인 개체 &lt;a href=&quot;../vrdisplaycapabilities/maxlayers&quot;&gt; &lt;code&gt;VRDisplayCapabilities.maxLayers&lt;/code&gt; 는&lt;/a&gt; 항상 현재 1). &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/VRDisplay&quot;&gt; &lt;code&gt;VRDevice&lt;/code&gt; &lt;/a&gt; 가 존재하지 않는 경우 ,이 메소드는 빈 배열을 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="35afa1749068f2dd5a35f2a3b7200a410102be2a" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;https://www.w3.org/TR/presentation-api/#dfn-presentation-connection-state&quot;&gt;presentation connection state&lt;/a&gt; of &lt;var&gt;S&lt;/var&gt; is &lt;a href=&quot;https://www.w3.org/TR/presentation-api/#dom-presentationconnectionstate-connecting&quot;&gt;&lt;code&gt;connecting&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;https://www.w3.org/TR/presentation-api/#dom-presentationconnectionstate-connected&quot;&gt;&lt;code&gt;connected&lt;/code&gt;&lt;/a&gt;, then abort all remaining steps.</source>
          <target state="translated">상기 중간 &lt;a href=&quot;https://www.w3.org/TR/presentation-api/#dfn-presentation-connection-state&quot;&gt;표현 접속 상태&lt;/a&gt; 의 &lt;var&gt;S&lt;/var&gt; 가 되는 &lt;a href=&quot;https://www.w3.org/TR/presentation-api/#dom-presentationconnectionstate-connecting&quot;&gt; &lt;code&gt;connecting&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;https://www.w3.org/TR/presentation-api/#dom-presentationconnectionstate-connected&quot;&gt; &lt;code&gt;connected&lt;/code&gt; &lt;/a&gt; 하고 나머지 공정 중단.</target>
        </trans-unit>
        <trans-unit id="937ed090721e2ea0391316f94d0dd9b47e9984b4" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;signalingstate&quot;&gt;&lt;code&gt;signalingState&lt;/code&gt;&lt;/a&gt; is set to &lt;code&gt;&quot;closed&quot;&lt;/code&gt;, an &lt;code&gt;InvalidStateError&lt;/code&gt; is raised.</source>
          <target state="translated">경우 &lt;a href=&quot;signalingstate&quot;&gt; &lt;code&gt;signalingState&lt;/code&gt; 가&lt;/a&gt; 설정되어 &lt;code&gt;&quot;closed&quot;&lt;/code&gt; , &lt;code&gt;InvalidStateError&lt;/code&gt; 가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="bc90ccbada8465faad295c30739efd78a07f2c7c" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;signalingstate&quot;&gt;&lt;code&gt;signalingState&lt;/code&gt;&lt;/a&gt; is set to &lt;code&gt;&quot;closed&quot;&lt;/code&gt;, an &lt;code&gt;InvalidStateError&lt;/code&gt; is raised. If the &lt;a href=&quot;signalingstate&quot;&gt;&lt;code&gt;signalingState&lt;/code&gt;&lt;/a&gt; is set to &lt;code&gt;&quot;stable&quot;&lt;/code&gt;, the event &lt;code&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Events/negotiationneeded&quot;&gt;negotiationneeded&lt;/a&gt;&lt;/code&gt; is sent on the &lt;a href=&quot;../rtcpeerconnection&quot;&gt;&lt;code&gt;RTCPeerConnection&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">경우 &lt;a href=&quot;signalingstate&quot;&gt; &lt;code&gt;signalingState&lt;/code&gt; 가&lt;/a&gt; 설정되어 &lt;code&gt;&quot;closed&quot;&lt;/code&gt; , &lt;code&gt;InvalidStateError&lt;/code&gt; 가 발생합니다. 경우 &lt;a href=&quot;signalingstate&quot;&gt; &lt;code&gt;signalingState&lt;/code&gt; 가&lt;/a&gt; 설정되어 &lt;code&gt;&quot;stable&quot;&lt;/code&gt; , 이벤트 &lt;code&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Events/negotiationneeded&quot;&gt;negotiationneeded&lt;/a&gt;&lt;/code&gt; 는 온 전송 &lt;a href=&quot;../rtcpeerconnection&quot;&gt; &lt;code&gt;RTCPeerConnection&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="154467d5185149ce6030b4c343b1a8951daa09bc" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Events/icecandidate&quot;&gt;icecandidate&lt;/a&gt;&lt;/code&gt; event has a non-&lt;code&gt;null&lt;/code&gt;&lt;code&gt;candidate&lt;/code&gt; property, we create a new &lt;a href=&quot;../rtcicecandidate&quot;&gt;&lt;code&gt;RTCIceCandidate&lt;/code&gt;&lt;/a&gt; object from the &lt;code&gt;event.candidate&lt;/code&gt; string and &quot;transmit&quot; it to the receiver by calling &lt;code&gt;receiverPC.addIceCandidate()&lt;/code&gt;, providing the new &lt;code&gt;RTCIceCandidate&lt;/code&gt; as its input. If &lt;code&gt;addIceCandidate()&lt;/code&gt; fails, the &lt;code&gt;catch()&lt;/code&gt; clause outputs the error to our log box.</source>
          <target state="translated">는 IF &lt;code&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Events/icecandidate&quot;&gt;icecandidate&lt;/a&gt;&lt;/code&gt; 의 이벤트가 아닌이 &lt;code&gt;null&lt;/code&gt; &lt;code&gt;candidate&lt;/code&gt; 속성을, 우리는 새로운 만들 &lt;a href=&quot;../rtcicecandidate&quot;&gt; &lt;code&gt;RTCIceCandidate&lt;/code&gt; 의&lt;/a&gt; 로부터 객체 &lt;code&gt;event.candidate&lt;/code&gt; 의 호출하여 수신기에 문자열 &quot;전송&quot;을 &lt;code&gt;receiverPC.addIceCandidate()&lt;/code&gt; 새로운 제공 &lt;code&gt;RTCIceCandidate&lt;/code&gt; 를 입력한다. 경우 &lt;code&gt;addIceCandidate()&lt;/code&gt; 실패의 &lt;code&gt;catch()&lt;/code&gt; 절은 우리의 로그 상자에 오류를 출력합니다.</target>
        </trans-unit>
        <trans-unit id="81bb3fd68aa97085da7c77670b122abad7d92577" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Events/icecandidate&quot;&gt;icecandidate&lt;/a&gt;&lt;/code&gt; event has a non-&lt;code&gt;null&lt;/code&gt;&lt;code&gt;candidate&lt;/code&gt; property, we create a new &lt;a href=&quot;../rtcicecandidate&quot;&gt;&lt;code&gt;RTCIceCandidate&lt;/code&gt;&lt;/a&gt; object from the &lt;code&gt;event.candidate&lt;/code&gt; string and deliver it to the caller by passing that into &lt;code&gt;callerPC.addIceCandidate()&lt;/code&gt;. If &lt;code&gt;addIceCandidate()&lt;/code&gt; fails, the &lt;code&gt;catch()&lt;/code&gt; clause outputs the error to our log box.</source>
          <target state="translated">는 IF &lt;code&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Events/icecandidate&quot;&gt;icecandidate&lt;/a&gt;&lt;/code&gt; 의 이벤트가 아닌이 &lt;code&gt;null&lt;/code&gt; &lt;code&gt;candidate&lt;/code&gt; 속성을, 우리는 새로운 만들 &lt;a href=&quot;../rtcicecandidate&quot;&gt; &lt;code&gt;RTCIceCandidate&lt;/code&gt; 의&lt;/a&gt; 로부터 객체 &lt;code&gt;event.candidate&lt;/code&gt; 의 문자열과에 있음을 전달하여 발신자에게 전달할 &lt;code&gt;callerPC.addIceCandidate()&lt;/code&gt; . 경우 &lt;code&gt;addIceCandidate()&lt;/code&gt; 실패의 &lt;code&gt;catch()&lt;/code&gt; 절은 우리의 로그 상자에 오류를 출력합니다.</target>
        </trans-unit>
        <trans-unit id="61907a2193549e017737a0bc858aab7b262312fe" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Events/touchstart&quot;&gt;touchstart&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Events/touchmove&quot;&gt;touchmove&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Events/touchend&quot;&gt;touchend&lt;/a&gt;&lt;/code&gt; event is canceled during an interaction, no mouse or click events will be fired, and the resulting sequence of events would just be:</source>
          <target state="translated">경우 &lt;code&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Events/touchstart&quot;&gt;touchstart&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Events/touchmove&quot;&gt;touchmove&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Events/touchend&quot;&gt;touchend&lt;/a&gt;&lt;/code&gt; 이벤트가 상호 작용하는 동안 취소, 더 마우스 클릭 이벤트가 해고되지 않으며, 이벤트의 발생 순서는 다음과 같습니다</target>
        </trans-unit>
        <trans-unit id="da49398878425a1e4181d8a76c02744b7e35a5a6" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;KeyboardEvent&lt;/code&gt; represents the press of a dead key, the key value must be &quot;&lt;code&gt;Dead&lt;/code&gt;&quot;.</source>
          <target state="translated">&lt;code&gt;KeyboardEvent&lt;/code&gt; 가 데드 키 누름을 나타내는 경우 키 값은 &quot; &lt;code&gt;Dead&lt;/code&gt; &quot; 여야합니다 .</target>
        </trans-unit>
        <trans-unit id="c6f4df284e122bd46a3fc059bf8c646d816769ed" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;MediaStreamTrack&lt;/code&gt; represents the video input from a camera, disabling the track by setting &lt;code&gt;enabled&lt;/code&gt; to &lt;code&gt;false&lt;/code&gt; also updates device activity indicators to show that the camera is not currently recording or streaming. For example, the green &quot;in use&quot; light next to the camera in iMac and MacBook computers turns off while the track is muted in this way.</source>
          <target state="translated">&lt;code&gt;MediaStreamTrack&lt;/code&gt; 이 카메라의 비디오 입력을 나타내는 경우 &lt;code&gt;enabled&lt;/code&gt; 를 &lt;code&gt;false&lt;/code&gt; 로 설정하여 트랙을 비활성화 하면 카메라가 현재 녹화 중이거나 스트리밍 중이 아님을 나타내는 장치 활동 표시기가 업데이트됩니다. 예를 들어, iMac 및 MacBook 컴퓨터에서 카메라 옆의 녹색 &quot;사용 중&quot;표시등이 꺼지면 트랙이 음소거됩니다.</target>
        </trans-unit>
        <trans-unit id="71f5858ccbbf61914693339db15ad5e6587f7312" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;RTCIceServer&lt;/code&gt; is a TURN server, then this is the username to use during the authentication process.</source>
          <target state="translated">는 IF &lt;code&gt;RTCIceServer&lt;/code&gt; 가 턴 서버이며, 다음이 인증 과정에서 사용하는 이름입니다.</target>
        </trans-unit>
        <trans-unit id="1aa781dbb3aca3f09c671c730da73e5a0bd07502" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;RTCIceServer&lt;/code&gt; represents a TURN server, this attribute specifies what kind of &lt;code&gt;credential&lt;/code&gt; is to be used when connecting. This must be one of the values defined by the &lt;code&gt;RTCIceCredentialType&lt;/code&gt; enum. The default is &lt;code&gt;&quot;password&quot;&lt;/code&gt;.</source>
          <target state="translated">는 IF &lt;code&gt;RTCIceServer&lt;/code&gt; 가 턴 서버를 나타내는, 어떤 종류의이 속성을 지정하는 &lt;code&gt;credential&lt;/code&gt; 되고 연결할 때 사용합니다. &lt;code&gt;RTCIceCredentialType&lt;/code&gt; 열거 형으로 정의 된 값 중 하나 여야합니다 . 기본값은 &lt;code&gt;&quot;password&quot;&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="6c3416e8b9a2b178ec7ab156212f5e6c38aa09fe" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;async&lt;/code&gt; attribute is absent but the &lt;code&gt;defer&lt;/code&gt; attribute is present, then the script is executed when &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Events/DOMContentLoaded&quot;&gt;the page has finished parsing&lt;/a&gt;.</source>
          <target state="translated">경우 &lt;code&gt;async&lt;/code&gt; 속성이 존재하지만 &lt;code&gt;defer&lt;/code&gt; 속성이 존재하는 경우, 다음 스크립트가 실행되어 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Events/DOMContentLoaded&quot;&gt;페이지가 완성 된 구문 분석이있다&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="18e06d2690f2ff1420955636e525ef334bd1352a" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;async&lt;/code&gt; attribute is present, then the script will be executed asynchronously as soon as it downloads.</source>
          <target state="translated">경우 &lt;code&gt;async&lt;/code&gt; 속성이 존재, 다음 스크립트는 곧 다운로드로 비동기 적으로 실행됩니다.</target>
        </trans-unit>
        <trans-unit id="74cb74258537346ac8f16a0e8125693397340709" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;buffer&lt;/code&gt; property is set to the value &lt;code&gt;null&lt;/code&gt;, the node generates a single channel containing silence (that is, every sample is 0).</source>
          <target state="translated">는 IF &lt;code&gt;buffer&lt;/code&gt; 속성 값으로 설정된 &lt;code&gt;null&lt;/code&gt; , 노드 (즉, 모든 샘플이 0 인) 단일 채널 함유 무음을 생성한다.</target>
        </trans-unit>
        <trans-unit id="9cfa90ac41a3a175221eb921021a385e77d0e95d" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;child&lt;/code&gt; doesn't exist on the DOM of the page, the method throws the following exception:</source>
          <target state="translated">경우 &lt;code&gt;child&lt;/code&gt; 페이지의 DOM에 존재하지 않는, 방법은 다음과 같은 예외가 발생합니다 :</target>
        </trans-unit>
        <trans-unit id="1ede2751aec83cb11a0e817b77622903e4103696" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;child&lt;/code&gt; was in fact a child of &lt;code&gt;element&lt;/code&gt; and so existing on the DOM, but was removed the method throws the following exception:</source>
          <target state="translated">경우 &lt;code&gt;child&lt;/code&gt; 사실의 자식이었다 &lt;code&gt;element&lt;/code&gt; 와 DOM에 존재하는 지금,하지만 제거 방법은 다음과 같은 예외가 발생합니다 :</target>
        </trans-unit>
        <trans-unit id="e531e72a34cc8bff16b010c034f954b0db3cc7f8" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;contextType&lt;/code&gt; doesn't match a possible drawing context, &lt;code&gt;null&lt;/code&gt; is returned.</source>
          <target state="translated">는 IF &lt;code&gt;contextType&lt;/code&gt; 이 가능한 드로잉 컨텍스트를 일치하지 않는 경우, &lt;code&gt;null&lt;/code&gt; 가 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="e9c4917312544c76ca5c39bc9f9df2d97441b930" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;dependentLocality&lt;/code&gt; value was validated successfully, this property is not included in the &lt;code&gt;AddressErrors&lt;/code&gt; object.</source>
          <target state="translated">는 IF &lt;code&gt;dependentLocality&lt;/code&gt; 의 값이 성공적으로 검증 된,이 속성은 포함되어 있지 않습니다 &lt;code&gt;AddressErrors&lt;/code&gt; 의 객체입니다.</target>
        </trans-unit>
        <trans-unit id="bf7f7685bba3422c84509946e21a88cd450e99f7" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;document.write()&lt;/code&gt; call is embedded within an inlined HTML &lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt; tag, then it will not call &lt;code&gt;document.open()&lt;/code&gt;. For example:</source>
          <target state="translated">경우 &lt;code&gt;document.write()&lt;/code&gt; 호출이 인라인 HTML에 내장되어 &lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt; 태그, 다음 호출되지 않습니다 &lt;code&gt;document.open()&lt;/code&gt; . 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="10bd8299c8d3d71b7260c66277a5b70b78dfc195" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;endContainer&lt;/code&gt; is a &lt;a href=&quot;../node&quot;&gt;&lt;code&gt;Node&lt;/code&gt;&lt;/a&gt; of type &lt;a href=&quot;../text&quot;&gt;&lt;code&gt;Text&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../comment&quot;&gt;&lt;code&gt;Comment&lt;/code&gt;&lt;/a&gt;, or &lt;a href=&quot;../cdatasection&quot;&gt;&lt;code&gt;CDATASection&lt;/code&gt;&lt;/a&gt;, then the offset is the number of characters from the start of the &lt;code&gt;endContainer&lt;/code&gt; to the boundary point of the &lt;a href=&quot;../range&quot;&gt;&lt;code&gt;Range&lt;/code&gt;&lt;/a&gt;. For other &lt;a href=&quot;../node&quot;&gt;&lt;code&gt;Node&lt;/code&gt;&lt;/a&gt; types, the &lt;code&gt;endOffset&lt;/code&gt; is the number of child nodes between the start of the &lt;code&gt;endContainer&lt;/code&gt; and the boundary point of the &lt;a href=&quot;../range&quot;&gt;&lt;code&gt;Range&lt;/code&gt;&lt;/a&gt;. This property is read-only. To change the &lt;code&gt;endOffset&lt;/code&gt; of a &lt;a href=&quot;../range&quot;&gt;&lt;code&gt;Range&lt;/code&gt;&lt;/a&gt;, use one of the &lt;a href=&quot;setend&quot;&gt;&lt;code&gt;Range.setEnd&lt;/code&gt;&lt;/a&gt; methods.</source>
          <target state="translated">는 IF &lt;code&gt;endContainer&lt;/code&gt; 가 A는 &lt;a href=&quot;../node&quot;&gt; &lt;code&gt;Node&lt;/code&gt; &lt;/a&gt; 유형의 &lt;a href=&quot;../text&quot;&gt; &lt;code&gt;Text&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;../comment&quot;&gt; &lt;code&gt;Comment&lt;/code&gt; &lt;/a&gt; , 또는 &lt;a href=&quot;../cdatasection&quot;&gt; &lt;code&gt;CDATASection&lt;/code&gt; 의가&lt;/a&gt; , 그 다음 오프셋은 시작의 문자의 수입니다 &lt;code&gt;endContainer&lt;/code&gt; 의 경계 지점 &lt;a href=&quot;../range&quot;&gt; &lt;code&gt;Range&lt;/code&gt; &lt;/a&gt; . 다른 &lt;a href=&quot;../node&quot;&gt; &lt;code&gt;Node&lt;/code&gt; &lt;/a&gt; 유형의 경우 &lt;code&gt;endOffset&lt;/code&gt; 은 &lt;code&gt;endContainer&lt;/code&gt; 의 시작 과 &lt;a href=&quot;../range&quot;&gt; &lt;code&gt;Range&lt;/code&gt; &lt;/a&gt; 경계 지점 사이의 하위 노드 수입니다 . 이 속성은 읽기 전용입니다. 변화에 &lt;code&gt;endOffset&lt;/code&gt; 의 (A)의 &lt;a href=&quot;../range&quot;&gt; &lt;code&gt;Range&lt;/code&gt; &lt;/a&gt; 의 사용 하나 &lt;a href=&quot;setend&quot;&gt; &lt;code&gt;Range.setEnd&lt;/code&gt; 의&lt;/a&gt; 방법을.</target>
        </trans-unit>
        <trans-unit id="f734f0ef40676a1d239fdcb2a0ced2a420782cb4" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;endNode&lt;/code&gt; is a &lt;a href=&quot;../node&quot;&gt;&lt;code&gt;Node&lt;/code&gt;&lt;/a&gt; of type &lt;code&gt;Text&lt;/code&gt;, &lt;code&gt;Comment&lt;/code&gt;, or &lt;code&gt;CDATASection&lt;/code&gt;, then &lt;code&gt;endOffset&lt;/code&gt; is the number of characters from the start of &lt;code&gt;endNode&lt;/code&gt;. For other &lt;code&gt;Node&lt;/code&gt; types, &lt;code&gt;endOffset&lt;/code&gt; is the number of child nodes between the start of the &lt;code&gt;endNode&lt;/code&gt;.</source>
          <target state="translated">는 IF &lt;code&gt;endNode&lt;/code&gt; A는 &lt;a href=&quot;../node&quot;&gt; &lt;code&gt;Node&lt;/code&gt; &lt;/a&gt; 유형의 &lt;code&gt;Text&lt;/code&gt; , &lt;code&gt;Comment&lt;/code&gt; , 또는 &lt;code&gt;CDATASection&lt;/code&gt; 의는 다음 &lt;code&gt;endOffset&lt;/code&gt; 의는 시작의 문자의 수입니다 &lt;code&gt;endNode&lt;/code&gt; . 다른 &lt;code&gt;Node&lt;/code&gt; 유형의 경우 &lt;code&gt;endOffset&lt;/code&gt; 은 &lt;code&gt;endNode&lt;/code&gt; 시작 사이의 하위 노드 수입니다 .</target>
        </trans-unit>
        <trans-unit id="99796ccd1921a170e78e16ad12fe763f3cf03e66" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;gp&lt;/code&gt; variable has a &lt;code&gt;Gamepad&lt;/code&gt; object inside it and it can return position values (&lt;code&gt;gpPose.hasPosition&lt;/code&gt;), indicating a 6DoF controller, we modify the cube position using position and orientation values. If only the former is true, indicating a 3DoF controller, we modify the cube position using the orientation values only. If there is no gamepad connected, we don't modify the cube position at all.</source>
          <target state="translated">경우] &lt;code&gt;gp&lt;/code&gt; 변수가 갖는 &lt;code&gt;Gamepad&lt;/code&gt; 그 안에 개체하고 위치 값 (리턴 할 &lt;code&gt;gpPose.hasPosition&lt;/code&gt; 을 6DOF 컨트롤러를 나타낸다), 우리는 위치 자세 값을 사용하여 큐브의 위치를 수정. 전자가 3DoF 컨트롤러를 나타내는 경우에만 방향 값만 사용하여 큐브 위치를 수정합니다. 게임 패드가 연결되어 있지 않으면 큐브 위치를 전혀 수정하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="97ff240d2335b9f6b06fde4c774aefb08dd98d84" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;id&lt;/code&gt; value is not the empty string, it must be unique in a document.</source>
          <target state="translated">는 IF &lt;code&gt;id&lt;/code&gt; 값이 빈 문자열이 아니라,이 문서에서 고유해야합니다.</target>
        </trans-unit>
        <trans-unit id="612f9d2bfece4c6ecaca7f76a3d38f4661ce8100" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;name&lt;/code&gt; given to this method already exists in the &lt;a href=&quot;../performancetiming&quot;&gt;&lt;code&gt;PerformanceTiming&lt;/code&gt;&lt;/a&gt; interface, &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/SyntaxError&quot;&gt;&lt;code&gt;SyntaxError&lt;/code&gt;&lt;/a&gt; is thrown.</source>
          <target state="translated">는 IF &lt;code&gt;name&lt;/code&gt; 이 방법에 주어진 이미 존재 &lt;a href=&quot;../performancetiming&quot;&gt; &lt;code&gt;PerformanceTiming&lt;/code&gt; &lt;/a&gt; 인터페이스, &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/SyntaxError&quot;&gt; &lt;code&gt;SyntaxError&lt;/code&gt; &lt;/a&gt; 발생합니다.</target>
        </trans-unit>
        <trans-unit id="1474ab86baac3e51954b73a343158a03f3f8347a" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;name&lt;/code&gt; parameter is not valid. A valid name is any string including the empty string.</source>
          <target state="translated">&lt;code&gt;name&lt;/code&gt; 매개 변수가 유효하지 않은 경우 유효한 이름은 빈 문자열을 포함한 모든 문자열입니다.</target>
        </trans-unit>
        <trans-unit id="9d55fde6d71468dc4793b7632ff099a349fefe44" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;onupgradeneeded&lt;/code&gt; event exits successfully, the &lt;code&gt;onsuccess&lt;/code&gt; handler of the open database request will then be triggered.</source>
          <target state="translated">는 IF &lt;code&gt;onupgradeneeded&lt;/code&gt; 이벤트가 성공적으로 종료의 &lt;code&gt;onsuccess&lt;/code&gt; 는 오픈 데이터베이스 요청의 처리기는 트리거됩니다.</target>
        </trans-unit>
        <trans-unit id="61ddedf502327359b06114a37bb187b33abe9659" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;organization&lt;/code&gt; value was validated successfully, this property is not included in the &lt;code&gt;AddressErrors&lt;/code&gt; object.</source>
          <target state="translated">는 IF &lt;code&gt;organization&lt;/code&gt; 값이 성공적으로 검증 된,이 속성은 포함되어 있지 않습니다 &lt;code&gt;AddressErrors&lt;/code&gt; 의 객체입니다.</target>
        </trans-unit>
        <trans-unit id="34d8248f778961c2c069d5ca7381782fd60f9bc4" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;phone&lt;/code&gt; value was validated successfully, this property is not included in the &lt;code&gt;AddressErrors&lt;/code&gt; object.</source>
          <target state="translated">는 IF &lt;code&gt;phone&lt;/code&gt; 값이 성공적으로 검증 된,이 속성은 포함되어 있지 않습니다 &lt;code&gt;AddressErrors&lt;/code&gt; 의 객체입니다.</target>
        </trans-unit>
        <trans-unit id="1b00406b5ca625324a0c3f8db1abeaa0036e2914" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;playing&lt;/code&gt; variable indicates we're already playing the oscillators, we change the &lt;code&gt;playButton&lt;/code&gt;'s content to be the Unicode character &quot;right-pointing triangle&quot; (▶️) and call &lt;code&gt;stopOscillators()&lt;/code&gt; to shut down the oscillators. See &lt;a href=&quot;#Stopping_the_oscillators&quot;&gt;Stopping the oscillators&lt;/a&gt; below for that code.</source>
          <target state="translated">는 IF &lt;code&gt;playing&lt;/code&gt; 변수는 우리가 이미 발진기를 연주 나타냅니다, 우리는 변경 &lt;code&gt;playButton&lt;/code&gt; 으로 유니 코드 문자 &quot;삼각형을 오른쪽을 가리키는&quot;(▶ ️) 및 전화로의 컨텐츠를 &lt;code&gt;stopOscillators()&lt;/code&gt; 오실레이터를 종료합니다. 해당 코드는 아래 &lt;a href=&quot;#Stopping_the_oscillators&quot;&gt;발진기 중지를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="4678c1c298a943f6f4182a8b4327a1c925d47ab4" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;postalCode&lt;/code&gt; value was validated successfully, this property is not included in the &lt;code&gt;AddressErrors&lt;/code&gt; object.</source>
          <target state="translated">는 IF &lt;code&gt;postalCode&lt;/code&gt; 값이 성공적으로 검증 된,이 속성은 포함되어 있지 않습니다 &lt;code&gt;AddressErrors&lt;/code&gt; 의 객체입니다.</target>
        </trans-unit>
        <trans-unit id="98356b360d46075dafec025bd26f9aeb9d911252" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;recipient&lt;/code&gt; value was validated successfully, this property is not included in the &lt;code&gt;AddressErrors&lt;/code&gt; object.</source>
          <target state="translated">경우 &lt;code&gt;recipient&lt;/code&gt; 값이 성공적으로 검증 된,이 속성은 포함되어 있지 않습니다 &lt;code&gt;AddressErrors&lt;/code&gt; 의 객체입니다.</target>
        </trans-unit>
        <trans-unit id="55ccdba3d0edea256f566bff38489f7bdef95934" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;region&lt;/code&gt; value was validated successfully, this property is not included in the &lt;code&gt;AddressErrors&lt;/code&gt; object.</source>
          <target state="translated">는 IF &lt;code&gt;region&lt;/code&gt; 값이 성공적으로 검증 된,이 속성은 포함되어 있지 않습니다 &lt;code&gt;AddressErrors&lt;/code&gt; 의 객체입니다.</target>
        </trans-unit>
        <trans-unit id="5f21e66609609257a05fc4cfc0f857c778cbcfba" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;regionCode&lt;/code&gt; value was validated successfully, this property is not included in the &lt;code&gt;AddressErrors&lt;/code&gt; object.</source>
          <target state="translated">는 IF &lt;code&gt;regionCode&lt;/code&gt; 의 값이 성공적으로 검증 된,이 속성은 포함되어 있지 않습니다 &lt;code&gt;AddressErrors&lt;/code&gt; 의 객체입니다.</target>
        </trans-unit>
        <trans-unit id="fdcda45eb8bee31b3a8b7cc5dc6395720bb5e45d" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;sampleRate&lt;/code&gt; property is not included in the options, or the options are not specified when creating the audio context, the new context's output device's preferred sample rate is used by default.</source>
          <target state="translated">는 IF &lt;code&gt;sampleRate&lt;/code&gt; 의 속성이 옵션에 포함되지 않은, 또는 오디오 컨텍스트를 생성 할 때 옵션이 지정되지 않은, 새로운 문맥의 출력 장치의 선호 샘플 속도는 기본적으로 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="a626db748018ba8ca4fa451beb2883b26d873c38" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;sortingCode&lt;/code&gt; value was validated successfully, this property is not included in the &lt;code&gt;AddressErrors&lt;/code&gt; object.</source>
          <target state="translated">는 IF &lt;code&gt;sortingCode&lt;/code&gt; 의 값이 성공적으로 검증 된,이 속성은 포함되어 있지 않습니다 &lt;code&gt;AddressErrors&lt;/code&gt; 의 객체입니다.</target>
        </trans-unit>
        <trans-unit id="44dfc88e251bb17b6eefff65ccd790d111409c29" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;startContainer&lt;/code&gt; is a &lt;a href=&quot;../node&quot;&gt;&lt;code&gt;Node&lt;/code&gt;&lt;/a&gt; of type &lt;a href=&quot;../text&quot;&gt;&lt;code&gt;Text&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../comment&quot;&gt;&lt;code&gt;Comment&lt;/code&gt;&lt;/a&gt;, or &lt;a href=&quot;../cdatasection&quot;&gt;&lt;code&gt;CDATASection&lt;/code&gt;&lt;/a&gt;, then the offset is the number of characters from the start of the &lt;code&gt;startContainer&lt;/code&gt; to the boundary point of the &lt;a href=&quot;../range&quot;&gt;&lt;code&gt;Range&lt;/code&gt;&lt;/a&gt;. For other &lt;a href=&quot;../node&quot;&gt;&lt;code&gt;Node&lt;/code&gt;&lt;/a&gt; types, the &lt;code&gt;startOffset&lt;/code&gt; is the number of child nodes between the start of the &lt;code&gt;startContainer&lt;/code&gt; and the boundary point of the &lt;a href=&quot;../range&quot;&gt;&lt;code&gt;Range&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">는 IF &lt;code&gt;startContainer&lt;/code&gt; 가 A는 &lt;a href=&quot;../node&quot;&gt; &lt;code&gt;Node&lt;/code&gt; &lt;/a&gt; 유형의 &lt;a href=&quot;../text&quot;&gt; &lt;code&gt;Text&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;../comment&quot;&gt; &lt;code&gt;Comment&lt;/code&gt; &lt;/a&gt; , 또는 &lt;a href=&quot;../cdatasection&quot;&gt; &lt;code&gt;CDATASection&lt;/code&gt; 의가&lt;/a&gt; , 그 다음 오프셋은 시작의 문자의 수입니다 &lt;code&gt;startContainer&lt;/code&gt; 의 경계 지점 &lt;a href=&quot;../range&quot;&gt; &lt;code&gt;Range&lt;/code&gt; &lt;/a&gt; . 다른 &lt;a href=&quot;../node&quot;&gt; &lt;code&gt;Node&lt;/code&gt; &lt;/a&gt; 유형의 경우 &lt;code&gt;startOffset&lt;/code&gt; 은 &lt;code&gt;startContainer&lt;/code&gt; 의 시작 과 &lt;a href=&quot;../range&quot;&gt; &lt;code&gt;Range&lt;/code&gt; &lt;/a&gt; 경계 지점 사이의 하위 노드 수입니다 .</target>
        </trans-unit>
        <trans-unit id="8b737755b5d29d380cf499e73e1ea4a82c9bd3c4" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;startNode&lt;/code&gt; is a &lt;a href=&quot;../node&quot;&gt;&lt;code&gt;Node&lt;/code&gt;&lt;/a&gt; of type &lt;code&gt;Text&lt;/code&gt;, &lt;code&gt;Comment&lt;/code&gt;, or &lt;code&gt;CDATASection&lt;/code&gt;, then &lt;code&gt;startOffset&lt;/code&gt; is the number of characters from the start of &lt;code&gt;startNode&lt;/code&gt;. For other &lt;code&gt;Node&lt;/code&gt; types, &lt;code&gt;startOffset&lt;/code&gt; is the number of child nodes between the start of the &lt;code&gt;startNode&lt;/code&gt;.</source>
          <target state="translated">는 IF &lt;code&gt;startNode&lt;/code&gt; A는 &lt;a href=&quot;../node&quot;&gt; &lt;code&gt;Node&lt;/code&gt; &lt;/a&gt; 유형의 &lt;code&gt;Text&lt;/code&gt; , &lt;code&gt;Comment&lt;/code&gt; , 또는 &lt;code&gt;CDATASection&lt;/code&gt; 의는 다음 &lt;code&gt;startOffset&lt;/code&gt; 는 시작부터 문자 수입니다 &lt;code&gt;startNode&lt;/code&gt; . 다른 &lt;code&gt;Node&lt;/code&gt; 유형의 경우 &lt;code&gt;startOffset&lt;/code&gt; 은 &lt;code&gt;startNode&lt;/code&gt; 시작 사이의 하위 노드 수입니다 .</target>
        </trans-unit>
        <trans-unit id="85c200527f7b69ccd69fadaa893be84683753494" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;strWindowFeatures&lt;/code&gt; parameter is used and if no position features are defined, then the left and top coordinates of the new window dimension will be 22 pixels from where the most recently rendered window was. An offset is universally implemented by browser manufacturers (it is 29 pixels in IE6 SP2 with the default theme) and its purpose is to help users to notice new windows opening. If the most recently used window was maximized, then there is no offset: the new window will be maximized as well.</source>
          <target state="translated">만약 &lt;code&gt;strWindowFeatures&lt;/code&gt; 사용되는 어떠한 위치 기능이 정의되지 않은 경우, 새로운 윈도우 사이즈의 좌측 상단 좌표 값은 가장 최근에 렌더링 윈도우가 있었던 곳에서 22 개 픽셀 것이다 파라미터. 오프셋은 브라우저 제조업체에서 기본적으로 구현하며 (IE6 SP2에서는 기본 테마가 29 픽셀 임), 사용자가 새 창을 열도록하는 데 도움이됩니다. 가장 최근에 사용한 윈도우가 최대화 된 경우 오프셋이 없습니다. 새 윈도우도 최대화됩니다.</target>
        </trans-unit>
        <trans-unit id="1b04c1e3237593f02813827889a19f08e9be20ea" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;strWindowFeatures&lt;/code&gt; parameter is used and no size features are defined, then the new window dimensions will be the same as the dimensions of the most recently rendered window.</source>
          <target state="translated">는 IF &lt;code&gt;strWindowFeatures&lt;/code&gt; 의 매개 변수가 사용되는 어떠한 크기 기능이 정의되지 않으며, 다음 새 창 크기는 가장 최근에 렌더링 윈도우의 크기와 동일합니다.</target>
        </trans-unit>
        <trans-unit id="11922ccf3d56f6dc8b1dcc46f4fd38e5ef1b723e" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;strWindowName&lt;/code&gt; parameter is omitted, a new window or tab is opened. If a window with the same name already exists, the existing window is refreshed.</source>
          <target state="translated">는 IF &lt;code&gt;strWindowName&lt;/code&gt; 의 매개 변수가 생략, 새 창이나 탭이 열립니다. 같은 이름의 창이 이미 존재하면 기존 창이 새로 고쳐집니다.</target>
        </trans-unit>
        <trans-unit id="8d7d297a0426f31e01c4a5a2ee4d6d717fde579c" translate="yes" xml:space="preserve">
          <source>If the &lt;em&gt;contextType&lt;/em&gt; doesn't match a possible drawing context, &lt;code&gt;null&lt;/code&gt; is returned.</source>
          <target state="translated">는 IF &lt;em&gt;contextType이&lt;/em&gt; 가능한 드로잉 컨텍스트를 일치하지 않는 경우, &lt;code&gt;null&lt;/code&gt; 가 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="f3e63b0d4896c41e3c2830742679de562845a345" translate="yes" xml:space="preserve">
          <source>If the &lt;em&gt;reference node&lt;/em&gt; is a &lt;a href=&quot;../node&quot;&gt;&lt;code&gt;Node&lt;/code&gt;&lt;/a&gt; of type &lt;a href=&quot;../text&quot;&gt;&lt;code&gt;Text&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../comment&quot;&gt;&lt;code&gt;Comment&lt;/code&gt;&lt;/a&gt;, or &lt;a href=&quot;../cdatasection&quot;&gt;&lt;code&gt;CDATASection&lt;/code&gt;&lt;/a&gt;, then offset is the number of characters from the start of &lt;em&gt;reference node&lt;/em&gt;. For other &lt;a href=&quot;../node&quot;&gt;&lt;code&gt;Node&lt;/code&gt;&lt;/a&gt; types, offset is the number of child nodes between the start of the &lt;em&gt;reference node&lt;/em&gt;.</source>
          <target state="translated">경우 &lt;em&gt;참조 노드&lt;/em&gt; A는 &lt;a href=&quot;../node&quot;&gt; &lt;code&gt;Node&lt;/code&gt; &lt;/a&gt; 유형의 &lt;a href=&quot;../text&quot;&gt; &lt;code&gt;Text&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;../comment&quot;&gt; &lt;code&gt;Comment&lt;/code&gt; &lt;/a&gt; , 또는 &lt;a href=&quot;../cdatasection&quot;&gt; &lt;code&gt;CDATASection&lt;/code&gt; 의는&lt;/a&gt; 다음 오프셋의 시작에서 문자의 수를 &lt;em&gt;참조 노드&lt;/em&gt; . 다른 &lt;a href=&quot;../node&quot;&gt; &lt;code&gt;Node&lt;/code&gt; &lt;/a&gt; 유형의 경우 오프셋은 &lt;em&gt;참조 노드&lt;/em&gt; 시작 사이의 하위 노드 수입니다 .</target>
        </trans-unit>
        <trans-unit id="e8caedf5d5871cf4f4afbeb74025f947953855e3" translate="yes" xml:space="preserve">
          <source>If the API isn't implemented in the browser, you can use other signals to detect if you are offline including using service workers and &lt;a href=&quot;http://www.html5rocks.com/en/mobile/workingoffthegrid.html#toc-xml-http-request&quot;&gt;responses from XMLHttpRequest&lt;/a&gt;.</source>
          <target state="translated">브라우저에서 API가 구현되지 않은 경우 서비스 작업자 및 &lt;a href=&quot;http://www.html5rocks.com/en/mobile/workingoffthegrid.html#toc-xml-http-request&quot;&gt;XMLHttpRequest의 응답&lt;/a&gt; 사용을 포함하여 다른 신호를 사용하여 오프라인 상태인지 감지 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="552b0a8793b13ad735b41db4deac0b2a8b847770" translate="yes" xml:space="preserve">
          <source>If the MASK bit was set (and it should be, for client-to-server messages), read the next 4 octets (32 bits); this is the masking key. Once the payload length and masking key is decoded, you can go ahead and read that number of bytes from the socket. Let's call the data &lt;strong&gt;ENCODED&lt;/strong&gt;, and the key &lt;strong&gt;MASK&lt;/strong&gt;. To get &lt;strong&gt;DECODED&lt;/strong&gt;, loop through the octets (bytes a.k.a. characters for text data) of &lt;strong&gt;ENCODED&lt;/strong&gt; and XOR the octet with the (i modulo 4)th octet of MASK. In pseudo-code (that happens to be valid JavaScript):</source>
          <target state="translated">MASK 비트가 설정된 경우 (그리고 클라이언트-서버 메시지의 경우) 다음 4 옥텟 (32 비트)을 읽으십시오. 마스킹 키입니다. 페이로드 길이와 마스킹 키가 디코딩되면 소켓에서 해당 바이트 수를 읽을 수 있습니다. &lt;strong&gt;ENCODED&lt;/strong&gt; 데이터 와 &lt;strong&gt;MASK&lt;/strong&gt; 키를 호출합시다 . &lt;strong&gt;DECODED&lt;/strong&gt; 를 얻으려면 , &lt;strong&gt;ENCODED&lt;/strong&gt; 의 옥텟 (텍스트 데이터의 경우 바이트 문자)을 반복 하고 MASK의 (i modulo 4) 번째 옥텟으로 옥텟을 XOR하십시오. 의사 코드에서 (유효한 JavaScript 임) :</target>
        </trans-unit>
        <trans-unit id="482b2ebc47e42d28a7c48524e8f5e17b70e7d786" translate="yes" xml:space="preserve">
          <source>If the URL has an invalid syntax or if the same-origin policy is violated a &lt;a href=&quot;../domexception&quot;&gt;&lt;code&gt;DOMException&lt;/code&gt;&lt;/a&gt; of type &lt;code&gt;SECURITY_ERR&lt;/code&gt; is thrown.</source>
          <target state="translated">URL에 잘못된 구문이 있거나 동일한 출처 정책을 위반 한 경우 &lt;code&gt;SECURITY_ERR&lt;/code&gt; 유형 의 &lt;a href=&quot;../domexception&quot;&gt; &lt;code&gt;DOMException&lt;/code&gt; &lt;/a&gt; 이 발생합니다.</target>
        </trans-unit>
        <trans-unit id="9ff4e59534a6bb3f075b5729d1ec63cd3b1f877a" translate="yes" xml:space="preserve">
          <source>If the URL has an invalid syntax or if the same-origin policy is violated, a &lt;a href=&quot;../domexception&quot;&gt;&lt;code&gt;DOMException&lt;/code&gt;&lt;/a&gt; of type &lt;code&gt;SECURITY_ERR&lt;/code&gt; is thrown.</source>
          <target state="translated">URL에 유효하지 않은 구문이 있거나 동일한 원본 정책을 위반하면 &lt;code&gt;SECURITY_ERR&lt;/code&gt; 유형 의 &lt;a href=&quot;../domexception&quot;&gt; &lt;code&gt;DOMException&lt;/code&gt; &lt;/a&gt; 이 발생합니다.</target>
        </trans-unit>
        <trans-unit id="35f7e25b8818be35a85a2c19f7d791c3868e380f" translate="yes" xml:space="preserve">
          <source>If the URL of your page is &lt;code&gt;https://example.com/?name=Jonathan&amp;amp;age=18&lt;/code&gt; you could parse out the 'name' and 'age' parameters using:</source>
          <target state="translated">페이지의 URL이 &lt;code&gt;https://example.com/?name=Jonathan&amp;amp;age=18&lt;/code&gt; 인 경우 다음을 사용하여 'name'및 'age'매개 변수를 구문 분석 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f07a36af48c5ef7edc30ec764c289aa91ceea849" translate="yes" xml:space="preserve">
          <source>If the WebGL context is lost, this error is returned on the first call to &lt;code&gt;getError&lt;/code&gt;. Afterwards and until the context has been restored, it returns &lt;code&gt;gl.NO_ERROR&lt;/code&gt;.</source>
          <target state="translated">WebGL 컨텍스트가 유실되면 &lt;code&gt;getError&lt;/code&gt; 에 대한 첫 번째 호출에서이 오류가 리턴됩니다 . 이후 컨텍스트가 복원 될 때까지 &lt;code&gt;gl.NO_ERROR&lt;/code&gt; 를 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="bb5ce9b5b5a89f2e322e6f1e769e84967539a9f5" translate="yes" xml:space="preserve">
          <source>If the WebVTT file is being used for chapters (&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/track&quot;&gt;&lt;code&gt;&amp;lt;track&amp;gt;&lt;/code&gt;&lt;/a&gt;&lt;code&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Global_attributes#attr-kind&quot;&gt;kind&lt;/a&gt;&lt;/code&gt; is &lt;code&gt;chapters&lt;/code&gt;) then the file cannot have overlapping timings.</source>
          <target state="translated">WebVTT 파일이 챕터에 사용되는 경우 ( &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/track&quot;&gt; &lt;code&gt;&amp;lt;track&amp;gt;&lt;/code&gt; &lt;/a&gt; &lt;code&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Global_attributes#attr-kind&quot;&gt;kind&lt;/a&gt;&lt;/code&gt; is &lt;code&gt;chapters&lt;/code&gt; ) 파일이 겹치는 타이밍을 가질 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="152df01d5c4fa4f138c736a94f238ec447adf5ad" translate="yes" xml:space="preserve">
          <source>If the ad has transitioned to the not-intersecting state, we remove the ad from the set of visible ads. Then we have one special behavior: we look to see if &lt;a href=&quot;../intersectionobserverentry/intersectionratio&quot;&gt;&lt;code&gt;entry.ratio&lt;/code&gt;&lt;/a&gt; is 0.0; if it is, that means the element has become totally obscured. If that's the case, and the ad has been visible for at least a minute total, we call a function we'll create called &lt;code&gt;replaceAd()&lt;/code&gt; to replace the existing ad with a new one. This way, the user sees a variety of ads over time, but the ads are only replaced while they can't be seen, resulting in a smooth experience.</source>
          <target state="translated">광고가 교차하지 않는 상태로 전환 된 경우 Google은 눈에 보이는 광고 세트에서 광고를 제거합니다. 그런 다음 한 가지 특별한 동작이 있습니다. &lt;a href=&quot;../intersectionobserverentry/intersectionratio&quot;&gt; &lt;code&gt;entry.ratio&lt;/code&gt; &lt;/a&gt; 가 0.0 인지 확인합니다 . 그렇다면 요소가 완전히 가려진 것입니다. 이 경우 최소 1 분 동안 광고가 표시되면 &lt;code&gt;replaceAd()&lt;/code&gt; 라는 함수를 호출 하여 기존 광고를 새 광고로 교체합니다. 이런 식으로 사용자는 시간이 지남에 따라 다양한 광고를 볼 수 있지만 보이지 않는 동안에 만 광고가 교체되어 원활한 경험을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="f9a3ab7fad98a3343a3d7facbbba109bc2164e18" translate="yes" xml:space="preserve">
          <source>If the animation effect the fill mode is being applied to is a keyframe effect (&lt;a href=&quot;../keyframeeffect&quot;&gt;&lt;code&gt;KeyframeEffect&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;../keyframeeffect&quot;&gt;&lt;code&gt;KeyframeEffectReadOnly&lt;/code&gt;&lt;/a&gt;), &lt;code&gt;&quot;auto&quot;&lt;/code&gt; is equivalent to &lt;code&gt;&quot;none&quot;&lt;/code&gt;. Otherwise, the result is &lt;code&gt;&quot;both&quot;&lt;/code&gt;.</source>
          <target state="translated">채우기 모드가 적용되는 애니메이션 효과가 키 프레임 효과 ( &lt;a href=&quot;../keyframeeffect&quot;&gt; &lt;code&gt;KeyframeEffect&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;../keyframeeffect&quot;&gt; &lt;code&gt;KeyframeEffectReadOnly&lt;/code&gt; &lt;/a&gt; ) 인 경우 &lt;code&gt;&quot;auto&quot;&lt;/code&gt; 는 &lt;code&gt;&quot;none&quot;&lt;/code&gt; 과 같습니다 . 그렇지 않으면 결과는 &lt;code&gt;&quot;both&quot;&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="2f9c8dc5ef9cfd6f343fad0344d4fb6b6e1d5da0" translate="yes" xml:space="preserve">
          <source>If the animation lacks a &lt;a href=&quot;../animationtimeline&quot;&gt;&lt;code&gt;timeline&lt;/code&gt;&lt;/a&gt;, is inactive, or hasn't been played yet, &lt;code&gt;currentTime&lt;/code&gt;'s return value is &lt;code&gt;null&lt;/code&gt;.</source>
          <target state="translated">애니메이션에 &lt;a href=&quot;../animationtimeline&quot;&gt; &lt;code&gt;timeline&lt;/code&gt; &lt;/a&gt; 이 없거나 비활성이거나 아직 재생되지 않은 경우 &lt;code&gt;currentTime&lt;/code&gt; 의 반환 값은 &lt;code&gt;null&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="b0d7c44f734a5f453c946fbda93ef1a681b4903d" translate="yes" xml:space="preserve">
          <source>If the area of the target's bounds rectangle is zero, the returned value is 1 if &lt;a href=&quot;isintersecting&quot;&gt;&lt;code&gt;isIntersecting&lt;/code&gt;&lt;/a&gt; is &lt;code&gt;true&lt;/code&gt; or 0 if not.</source>
          <target state="translated">대상 경계 사각형의 영역이 0이면 &lt;a href=&quot;isintersecting&quot;&gt; &lt;code&gt;isIntersecting&lt;/code&gt; &lt;/a&gt; 이 &lt;code&gt;true&lt;/code&gt; 이면 반환 값은 1 이고 그렇지 않으면 0입니다.</target>
        </trans-unit>
        <trans-unit id="2c13d1b512614002f52e5a605fd5d1b354eb4de1" translate="yes" xml:space="preserve">
          <source>If the argument referenced an existing node on the DOM tree, the node will be detached from its current position and attached at the new position.</source>
          <target state="translated">인수가 DOM 트리에서 기존 노드를 참조한 경우 노드는 현재 위치에서 분리되어 새 위치에 연결됩니다.</target>
        </trans-unit>
        <trans-unit id="a5ef74beb0a39f7ac73db0a91cc9552e28ba36d4" translate="yes" xml:space="preserve">
          <source>If the array has fewer elements than the &lt;a href=&quot;fftsize&quot;&gt;&lt;code&gt;AnalyserNode.fftSize&lt;/code&gt;&lt;/a&gt;, excess elements are dropped. If it has more elements than needed, excess elements are ignored.</source>
          <target state="translated">배열에 &lt;a href=&quot;fftsize&quot;&gt; &lt;code&gt;AnalyserNode.fftSize&lt;/code&gt; &lt;/a&gt; 보다 적은 수의 요소가 있으면 초과 요소가 삭제됩니다. 필요한 것보다 많은 요소가 있으면 초과 요소는 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="d6ce299ecfa0e73c325ea6f58a82857f025cd881" translate="yes" xml:space="preserve">
          <source>If the array has fewer elements than the &lt;a href=&quot;frequencybincount&quot;&gt;&lt;code&gt;AnalyserNode.frequencyBinCount&lt;/code&gt;&lt;/a&gt;, excess elements are dropped. If it has more elements than needed, excess elements are ignored.</source>
          <target state="translated">배열에 &lt;a href=&quot;frequencybincount&quot;&gt; &lt;code&gt;AnalyserNode.frequencyBinCount&lt;/code&gt; &lt;/a&gt; 보다 적은 수의 요소가 있으면 초과 요소가 삭제됩니다. 필요한 것보다 많은 요소가 있으면 초과 요소는 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="ca057b425a4e46e8d53c7dcc26446c7f7f9b59bd" translate="yes" xml:space="preserve">
          <source>If the array's length is zero, meaning there are no tracks left in the stream, we end the call by calling &lt;code&gt;closeVideoCall()&lt;/code&gt;. This cleanly restores our app to a state in which it's ready to start or receive another call. See &lt;a href=&quot;#Ending_the_call&quot;&gt;Ending the call&lt;/a&gt; to learn how &lt;code&gt;closeVideoCall()&lt;/code&gt; works.</source>
          <target state="translated">배열의 길이가 0 인 경우 스트림에 트랙이 남아 있지 &lt;code&gt;closeVideoCall()&lt;/code&gt; 을 호출하여 호출을 종료합니다 . 이렇게하면 앱이 다른 전화를 시작하거나받을 준비가 된 상태로 깨끗하게 복원됩니다. &lt;code&gt;closeVideoCall()&lt;/code&gt; 작동 방식을 알아 보려면 &lt;a href=&quot;#Ending_the_call&quot;&gt;호출 종료를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="4627a6f4182d7b38e87c63b046b707d1c1e0d475" translate="yes" xml:space="preserve">
          <source>If the assignment can't happen because of a security violation, a &lt;a href=&quot;../domexception&quot;&gt;&lt;code&gt;DOMException&lt;/code&gt;&lt;/a&gt; of the &lt;code&gt;SECURITY_ERROR&lt;/code&gt; type is thrown. This happens if the origin of the script calling the method is different from the origin of the page originally described by the &lt;a href=&quot;../location&quot;&gt;&lt;code&gt;Location&lt;/code&gt;&lt;/a&gt; object, mostly when the script is hosted on a different domain.</source>
          <target state="translated">할당 보안 오류로 인해 발생할 수없는 경우에는 &lt;a href=&quot;../domexception&quot;&gt; &lt;code&gt;DOMException&lt;/code&gt; &lt;/a&gt; 의 &lt;code&gt;SECURITY_ERROR&lt;/code&gt; 의 유형이 발생합니다. 이는 메서드를 호출하는 스크립트의 출처가 &lt;a href=&quot;../location&quot;&gt; &lt;code&gt;Location&lt;/code&gt; &lt;/a&gt; 객체에 의해 원래 설명 된 페이지의 출처와 다른 경우에 발생 합니다. 대부분 스크립트가 다른 도메인에서 호스팅되는 경우에 발생합니다.</target>
        </trans-unit>
        <trans-unit id="fc25010fe5f7ee170af69236aa6cc4f52fc31d46" translate="yes" xml:space="preserve">
          <source>If the associated stream is errored when the lock is released, the reader will appear errored in that same way subsequently; otherwise, the reader will appear closed.</source>
          <target state="translated">잠금이 해제 될 때 관련 스트림에 오류가 발생하면 리더는 그와 같은 방식으로 오류가 표시됩니다. 그렇지 않으면 리더가 닫힌 것으로 나타납니다.</target>
        </trans-unit>
        <trans-unit id="aa51c34318d419535bdbb47de3da051b4b18cd8b" translate="yes" xml:space="preserve">
          <source>If the attribute named already exists on the element, that attribute is replaced with the new one and the replaced one is returned.</source>
          <target state="translated">이름 지정된 속성이 요소에 이미 존재하면 해당 속성이 새 속성으로 바뀌고 대체 된 속성이 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="359e7b9700e1defcab34a8b0efe3280a9c26a158" translate="yes" xml:space="preserve">
          <source>If the browser can't determine the region code, or the country doesn't use regions for postal addresses, it returns an empty string.</source>
          <target state="translated">브라우저가 지역 코드를 확인할 수 없거나 국가가 우편 주소에 지역을 사용하지 않으면 빈 문자열을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="b62a4c97f48c7619624519a944138b94c4bb0135" translate="yes" xml:space="preserve">
          <source>If the browser doesn't support &lt;code&gt;navigator.onLine&lt;/code&gt; the above example will always come out as &lt;code&gt;false&lt;/code&gt;/&lt;code&gt;undefined&lt;/code&gt;.</source>
          <target state="translated">브라우저가 &lt;code&gt;navigator.onLine&lt;/code&gt; 을 지원하지 않으면 위 예제는 항상 &lt;code&gt;false&lt;/code&gt; / &lt;code&gt;undefined&lt;/code&gt; 로 나타납니다 .</target>
        </trans-unit>
        <trans-unit id="81352ea51b05fbfd866655a6bef919be07894c26" translate="yes" xml:space="preserve">
          <source>If the browser fires both touch and mouse events because of a single user input, the browser &lt;em&gt;must &lt;/em&gt; fire a &lt;code&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Events/touchstart&quot;&gt;touchstart&lt;/a&gt;&lt;/code&gt; before any mouse events. Consequently, if an application does not want mouse events fired on a specific touch &lt;a href=&quot;../touch/target&quot;&gt;&lt;code&gt;target&lt;/code&gt;&lt;/a&gt; element, the element's touch event handlers should call &lt;a href=&quot;../event/preventdefault&quot;&gt;&lt;code&gt;preventDefault()&lt;/code&gt;&lt;/a&gt; and no additional mouse events will be dispatched.</source>
          <target state="translated">브라우저가 있기 때문에 하나의 사용자 입력을 모두 터치와 마우스 이벤트를 발생하는 경우, 브라우저는 &lt;em&gt;해야한다&lt;/em&gt; 화재 &lt;code&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Events/touchstart&quot;&gt;touchstart&lt;/a&gt;&lt;/code&gt; 을 모든 마우스 이벤트 전에. 결과적으로, 애플리케이션이 특정 터치 &lt;a href=&quot;../touch/target&quot;&gt; &lt;code&gt;target&lt;/code&gt; &lt;/a&gt; 요소 에서 마우스 이벤트가 발생하지 않게 하려면 요소의 터치 이벤트 핸들러가 &lt;a href=&quot;../event/preventdefault&quot;&gt; &lt;code&gt;preventDefault()&lt;/code&gt; &lt;/a&gt; 호출해야하며 추가 마우스 이벤트가 전달되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="484e00f2cba1d453836310121e8d9053678d4b47" translate="yes" xml:space="preserve">
          <source>If the browser is not processing a user gesture, reject.</source>
          <target state="translated">브라우저가 사용자 제스처를 처리하지 않으면 거부하십시오.</target>
        </trans-unit>
        <trans-unit id="a23126cfde0cf0f39eef6837b664f8ed878e5010" translate="yes" xml:space="preserve">
          <source>If the buffer size is not defined, which is recommended, the browser will pick one that its heuristic deems appropriate.</source>
          <target state="translated">버퍼 크기가 정의되어 있지 않은 경우 (권장되는 경우) 브라우저는 휴리스틱이 적절하다고 생각하는 것을 선택합니다.</target>
        </trans-unit>
        <trans-unit id="49f70ad3d833233ebc5a5ff55a95ed867421914c" translate="yes" xml:space="preserve">
          <source>If the button is not a descendant of a form element, then the attribute can be the ID of any form element in the same document it is related to, or the &lt;code&gt;null&lt;/code&gt; value if none matches.</source>
          <target state="translated">단추가 양식 요소의 자손이 아닌 경우 속성은 해당 문서와 관련된 동일한 양식에있는 양식 요소의 ID이거나 일치하지 않는 경우 &lt;code&gt;null&lt;/code&gt; 값일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3652bd8312c8c05387ca717f9d0229fa97662793" translate="yes" xml:space="preserve">
          <source>If the candidate is derived from another candidate, &lt;code&gt;relatedAddress&lt;/code&gt; is a &lt;a href=&quot;domstring&quot;&gt;&lt;code&gt;DOMString&lt;/code&gt;&lt;/a&gt; containing that host candidate's IP address. For host candidates, this value is &lt;code&gt;null&lt;/code&gt;.</source>
          <target state="translated">후보가 다른 후보에서 파생 된 경우 &lt;code&gt;relatedAddress&lt;/code&gt; 는 해당 호스트 후보의 IP 주소를 포함 하는 &lt;a href=&quot;domstring&quot;&gt; &lt;code&gt;DOMString&lt;/code&gt; &lt;/a&gt; 입니다. 호스트 후보의 경우이 값은 &lt;code&gt;null&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="48c0a06425572cf3cc5570d2317923d99ce9f25c" translate="yes" xml:space="preserve">
          <source>If the canvas or source rectangle width or height is zero.</source>
          <target state="translated">캔버스 또는 소스 사각형 너비 또는 높이가 0 인 경우</target>
        </trans-unit>
        <trans-unit id="d99d827b5ca95fa7f1c497bb95d77fd66e143a29" translate="yes" xml:space="preserve">
          <source>If the channel's state has changed to &quot;open&quot;, that indicates that we have finished establishing the link between the two peers. The user interface is updated correspondingly by enabling the text input box for the message to send, focusing the input box so that the user can immediately begin to type, enabling the &quot;Send&quot; and &quot;Disconnect&quot; buttons, now that they're usable, and disabling the &quot;Connect&quot; button, since it is not needed when the conneciton is open.</source>
          <target state="translated">채널 상태가 &quot;개방&quot;으로 변경된 경우 두 피어 간의 연결을 완료했음을 나타냅니다. 사용자 인터페이스는 메시지 전송을위한 텍스트 입력 상자를 활성화하고 입력 상자에 초점을 두어 사용자가 즉시 입력을 시작할 수 있도록하여 &quot;보내기&quot;및 &quot;연결 끊기&quot;버튼을 활성화하여 해당 인터페이스를 업데이트합니다. 연결이 열려있을 때는 필요하지 않으므로 &quot;연결&quot;버튼을 비활성화하십시오.</target>
        </trans-unit>
        <trans-unit id="9a4aeb7e87b1d811cc155d66e1f2d656171a465d" translate="yes" xml:space="preserve">
          <source>If the character encoding is declared in the HTTP &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Content-Type&quot;&gt;&lt;code&gt;Content-Type&lt;/code&gt;&lt;/a&gt; header, that character encoding is used. Failing that, if there is a byte order mark, the encoding indicated by the byte order mark is used. Failing that, if there is a &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/meta&quot;&gt;&lt;code&gt;&amp;lt;meta&amp;gt;&lt;/code&gt;&lt;/a&gt; element that declares the encoding within the first 1024 bytes of the file, that encoding is used. Otherwise, the file is decoded as UTF-8.</source>
          <target state="translated">문자 인코딩이 HTTP &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Content-Type&quot;&gt; &lt;code&gt;Content-Type&lt;/code&gt; &lt;/a&gt; 헤더에 선언 되면 해당 문자 인코딩이 사용됩니다. 바이트 순서 표시가 있으면 바이트 순서 표시로 표시된 인코딩이 사용되지 않는 것입니다. 파일의 처음 1024 바이트 내에 인코딩을 선언 하는 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/meta&quot;&gt; &lt;code&gt;&amp;lt;meta&amp;gt;&lt;/code&gt; &lt;/a&gt; 요소 가 있으면 해당 인코딩이 사용되지 않습니다. 그렇지 않으면 파일이 UTF-8로 디코딩됩니다.</target>
        </trans-unit>
        <trans-unit id="b5a829a9ccd2e7cbfd9e0a39766198ae8212c85d" translate="yes" xml:space="preserve">
          <source>If the checkout flow needs to know whether &lt;a href=&quot;../paymentrequest/canmakepayment&quot;&gt;&lt;code&gt;PaymentRequest.canMakePayment()&lt;/code&gt;&lt;/a&gt; will return &lt;code&gt;true&lt;/code&gt; even before all line items and their prices are known, you can instantiate &lt;code&gt;PaymentRequest&lt;/code&gt; with dummy data and pre-query &lt;code&gt;.canMakePayment()&lt;/code&gt;. If you call &lt;code&gt;.canMakePayment()&lt;/code&gt; multiple times, keep in mind that the first parameter to the &lt;code&gt;PaymentRequest&lt;/code&gt; constructor should contain the same method names and data.</source>
          <target state="translated">결제 흐름에서 모든 광고 항목 및 가격 을 알기 전에 &lt;a href=&quot;../paymentrequest/canmakepayment&quot;&gt; &lt;code&gt;PaymentRequest.canMakePayment()&lt;/code&gt; &lt;/a&gt; 가 &lt;code&gt;true&lt;/code&gt; 를 반환 하는지 여부를 알아야하는 경우 더미 데이터 및 &lt;code&gt;.canMakePayment()&lt;/code&gt; 사전 쿼리하여 &lt;code&gt;PaymentRequest&lt;/code&gt; 를 인스턴스화 할 수 있습니다 . &lt;code&gt;.canMakePayment()&lt;/code&gt; 여러 번 호출 하는 경우 &lt;code&gt;PaymentRequest&lt;/code&gt; 생성자 의 첫 번째 매개 변수 에는 동일한 메소드 이름 및 데이터가 포함되어야합니다.</target>
        </trans-unit>
        <trans-unit id="1b6551f5952a0f5a0e7912eb0c18c67e4f93b17a" translate="yes" xml:space="preserve">
          <source>If the city value was validated successfully, this property is not included in the &lt;code&gt;AddressErrors&lt;/code&gt; object.</source>
          <target state="translated">도시 값의 유효성이 검사되면이 속성은 &lt;code&gt;AddressErrors&lt;/code&gt; 개체에 포함되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="86063f0e1608a0c1ba7ad6db877cf137c5e7c2fd" translate="yes" xml:space="preserve">
          <source>If the clipboard is empty or doesn't contain text, the &lt;code&gt;&quot;cliptext&quot;&lt;/code&gt; element's contents are cleared. This happens because &lt;a href=&quot;../clipboard/readtext&quot;&gt;&lt;code&gt;readText()&lt;/code&gt;&lt;/a&gt; returns an empty string if the clipboard is empty or doesn't contain text.</source>
          <target state="translated">클립 보드가 비어 있거나 텍스트를 포함하지 않으면 &lt;code&gt;&quot;cliptext&quot;&lt;/code&gt; 요소의 내용이 지워집니다. 클립 보드가 비어 있거나 텍스트를 포함하지 않으면 &lt;a href=&quot;../clipboard/readtext&quot;&gt; &lt;code&gt;readText()&lt;/code&gt; &lt;/a&gt; 가 빈 문자열을 반환 하기 때문에 발생 합니다.</target>
        </trans-unit>
        <trans-unit id="06c294da18f8dc3701bc9bd9a8175d651ae846fe" translate="yes" xml:space="preserve">
          <source>If the code is running in a context which is receiving a presentation, the returned value is a &lt;a href=&quot;../presentationreceiver&quot;&gt;&lt;code&gt;PresentationReceiver&lt;/code&gt;&lt;/a&gt; which can then be used to communicate with the context which is the source of the presentation.</source>
          <target state="translated">코드가 프리젠 테이션을 수신하는 컨텍스트에서 실행중인 경우 리턴 된 값은 &lt;a href=&quot;../presentationreceiver&quot;&gt; &lt;code&gt;PresentationReceiver&lt;/code&gt; &lt;/a&gt; 이며 프리젠 테이션 의 소스 인 컨텍스트와 통신하는 데 사용될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="442b7e99f582081d33d8c786585eec1c027eba44" translate="yes" xml:space="preserve">
          <source>If the connection has already been negotiated (&lt;a href=&quot;signalingstate&quot;&gt;&lt;code&gt;signalingState&lt;/code&gt;&lt;/a&gt; is set to &lt;code&gt;&quot;stable&quot;&lt;/code&gt;), it is marked as needing to be negotiated again; the remote peer won't experience the change until this negotiation occurs. A &lt;code&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Events/negotiationneeded&quot;&gt;negotiationneeded&lt;/a&gt;&lt;/code&gt; event is sent to the &lt;a href=&quot;../rtcpeerconnection&quot;&gt;&lt;code&gt;RTCPeerConnection&lt;/code&gt;&lt;/a&gt; to let the local end know this negotiation must occur.</source>
          <target state="translated">연결이 이미 협상 된 경우 ( &lt;a href=&quot;signalingstate&quot;&gt; &lt;code&gt;signalingState&lt;/code&gt; &lt;/a&gt; 가 &lt;code&gt;&quot;stable&quot;&lt;/code&gt; 로 설정 됨 ) 다시 협상해야하는 것으로 표시됩니다. 이 협상이 이루어질 때까지 원격 피어는 변경을 경험하지 않습니다. &lt;code&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Events/negotiationneeded&quot;&gt;negotiationneeded&lt;/a&gt;&lt;/code&gt; 이벤트가 전송됩니다 &lt;a href=&quot;../rtcpeerconnection&quot;&gt; &lt;code&gt;RTCPeerConnection&lt;/code&gt; &lt;/a&gt; 로컬 끝이 협상이 발생해야 알 수 있도록.</target>
        </trans-unit>
        <trans-unit id="22d1c04666f0561c37db74a403bd5c3e5fde32a6" translate="yes" xml:space="preserve">
          <source>If the context is successfully initialized, the variable &lt;code&gt;gl&lt;/code&gt; is our reference to it. In this case, we set the clear color to black, and clear the context to that color (redrawing the canvas with the background color).</source>
          <target state="translated">컨텍스트가 성공적으로 초기화되면 변수 &lt;code&gt;gl&lt;/code&gt; 이 이에 대한 참조입니다. 이 경우, 맑은 색을 검은 색으로 설정하고 컨텍스트를 해당 색으로 지 웁니다 (배경색으로 캔버스를 다시 그립니다).</target>
        </trans-unit>
        <trans-unit id="3fe88502393416ea9707f74f16662ac5eed07ddd" translate="yes" xml:space="preserve">
          <source>If the current &lt;a href=&quot;document&quot;&gt;&lt;code&gt;Document&lt;/code&gt;&lt;/a&gt; is the first one loaded in the &lt;code&gt;Window&lt;/code&gt;, the time origin is the time at which the browser context was created.</source>
          <target state="translated">현재 &lt;a href=&quot;document&quot;&gt; &lt;code&gt;Document&lt;/code&gt; &lt;/a&gt; 가 &lt;code&gt;Window&lt;/code&gt; 에 처음로드 된 문서 인 경우 시간 원점은 브라우저 컨텍스트가 작성된 시간입니다.</target>
        </trans-unit>
        <trans-unit id="ed2f89c7351b507bc1079c9509d8e33f67a6fec4" translate="yes" xml:space="preserve">
          <source>If the current context is a &lt;a href=&quot;worker&quot;&gt;&lt;code&gt;worker&lt;/code&gt;&lt;/a&gt;, the &lt;a href=&quot;performanceresourcetiming/workerstart&quot;&gt;&lt;code&gt;workerStart&lt;/code&gt;&lt;/a&gt; property can be used to obtain a &lt;a href=&quot;domhighrestimestamp&quot;&gt;&lt;code&gt;DOMHighResTimeStamp&lt;/code&gt;&lt;/a&gt; when the worker was started.</source>
          <target state="translated">현재 컨텍스트가 &lt;a href=&quot;worker&quot;&gt; &lt;code&gt;worker&lt;/code&gt; &lt;/a&gt; 인 경우 &lt;a href=&quot;performanceresourcetiming/workerstart&quot;&gt; &lt;code&gt;workerStart&lt;/code&gt; &lt;/a&gt; 속성을 사용 하여 작업자가 시작되었을 때 &lt;a href=&quot;domhighrestimestamp&quot;&gt; &lt;code&gt;DOMHighResTimeStamp&lt;/code&gt; &lt;/a&gt; 를 얻을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="11cab1529b79786e6b64e0452fabcd57b27d9ad0" translate="yes" xml:space="preserve">
          <source>If the current context is not receiving a presentation, &lt;code&gt;receiver&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt;.</source>
          <target state="translated">현재 컨텍스트가 프리젠 테이션을 수신하지 않는 경우, &lt;code&gt;receiver&lt;/code&gt; 는 &lt;code&gt;null&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="ef6fc989d3c13a0e08d0a8abb319e4c2752e5bca" translate="yes" xml:space="preserve">
          <source>If the current document is not in a browsing context, the returned value is &lt;code&gt;null&lt;/code&gt;.</source>
          <target state="translated">현재 문서가 브라우징 컨텍스트에없는 경우 반환 값은 &lt;code&gt;null&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="4f471623934614be61e0084cfb07bb480d4a36bd" translate="yes" xml:space="preserve">
          <source>If the current maximum value of the progress bar is different from the current total number of enqueued tasks (&lt;code&gt;totalTaskCount&lt;/code&gt;), then we update the contents of the displayed total number of tasks (&lt;code&gt;totalTaskCountElem&lt;/code&gt;) and the maximum value of the progress bar, so that it scales properly.</source>
          <target state="translated">진행률 표시 줄의 현재 최대 값이 현재 총 대기열에있는 작업 수 ( &lt;code&gt;totalTaskCount&lt;/code&gt; )와 다른 경우 표시된 총 작업 수 ( &lt;code&gt;totalTaskCountElem&lt;/code&gt; )의 내용과 진행률 표시 줄의 최대 값이 업데이트됩니다. 제대로 확장됩니다.</target>
        </trans-unit>
        <trans-unit id="b573b138c312bfb71c4676c4429dd8b92d83d051" translate="yes" xml:space="preserve">
          <source>If the data being stored could not be deserialized by the internal structured cloning algorithm.</source>
          <target state="translated">내부 구조화 된 복제 알고리즘으로 저장중인 데이터를 직렬화 해제 할 수없는 경우</target>
        </trans-unit>
        <trans-unit id="3284f6956e080f7c12920878cb64c7e656352581" translate="yes" xml:space="preserve">
          <source>If the data being stored could not be serialized by the internal structured cloning algorithm.</source>
          <target state="translated">내부 구조화 된 복제 알고리즘으로 저장중인 데이터를 직렬화 할 수없는 경우</target>
        </trans-unit>
        <trans-unit id="0dceccc0a8c9416e8140f5c189d346516a88311d" translate="yes" xml:space="preserve">
          <source>If the database is successfully deleted, then a &lt;code&gt;success&lt;/code&gt; event is fired on the request object returned from this method, with its &lt;code&gt;result&lt;/code&gt; set to &lt;code&gt;undefined&lt;/code&gt;. If an error occurs while the database is being deleted, then an &lt;code&gt;error&lt;/code&gt; event is fired on the request object that is returned from this method.</source>
          <target state="translated">데이터베이스가 성공적으로 삭제되면 이 메소드에서 리턴 된 요청 오브젝트에서 &lt;code&gt;success&lt;/code&gt; 이벤트가 시작되고 &lt;code&gt;result&lt;/code&gt; 는 &lt;code&gt;undefined&lt;/code&gt; 로 설정됩니다 . 데이터베이스를 삭제하는 동안 오류가 발생하면 이 메소드에서 리턴 된 요청 오브젝트에서 &lt;code&gt;error&lt;/code&gt; 이벤트가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="ed030c1685430c9805bfc5c79061adcf66226bf8" translate="yes" xml:space="preserve">
          <source>If the default values of the properties are acceptable, you can optionally use the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/AudioContext/createOscillator&quot;&gt;&lt;code&gt;AudioContext.createOscillator()&lt;/code&gt;&lt;/a&gt; factory method instead.</source>
          <target state="translated">속성의 기본값이 허용되는 경우 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/AudioContext/createOscillator&quot;&gt; &lt;code&gt;AudioContext.createOscillator()&lt;/code&gt; &lt;/a&gt; 팩토리 메서드를 대신 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="3f8d806904159a10d0d9f35cc207119f1dc0c64b" translate="yes" xml:space="preserve">
          <source>If the destination is a node, &lt;code&gt;connect()&lt;/code&gt; returns a reference to the destination &lt;a href=&quot;../audionode&quot;&gt;&lt;code&gt;AudioNode&lt;/code&gt;&lt;/a&gt; object, allowing you to chain multiple &lt;code&gt;connect()&lt;/code&gt; calls. In some browsers, older implementations of this interface return &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/undefined&quot;&gt;&lt;code&gt;undefined&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">대상이 노드 인 경우 &lt;code&gt;connect()&lt;/code&gt; 는 대상 &lt;a href=&quot;../audionode&quot;&gt; &lt;code&gt;AudioNode&lt;/code&gt; &lt;/a&gt; 객체에 대한 참조를 반환하여 여러 &lt;code&gt;connect()&lt;/code&gt; 호출을 연결할 수 있습니다 . 일부 브라우저에서이 인터페이스의 이전 구현은 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/undefined&quot;&gt; &lt;code&gt;undefined&lt;/code&gt; 를&lt;/a&gt; 반환 합니다.</target>
        </trans-unit>
        <trans-unit id="2078a485ce4450b4ba91c455cc52a5971f74a576" translate="yes" xml:space="preserve">
          <source>If the destination is an &lt;code&gt;AudioParam&lt;/code&gt;, &lt;code&gt;connect()&lt;/code&gt; returns &lt;code&gt;undefined&lt;/code&gt;.</source>
          <target state="translated">대상이 &lt;code&gt;AudioParam&lt;/code&gt; 인 경우 &lt;code&gt;connect()&lt;/code&gt; 는 &lt;code&gt;undefined&lt;/code&gt; 를 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="a681242eefde57cd0b9efa4211ff24eb1624b486" translate="yes" xml:space="preserve">
          <source>If the device type cannot be detected by the browser, the value can be an empty string (&quot;&quot;). If the browser supports pointer device types other than those listed above, the value should be &lt;em&gt;vendor prefixed&lt;/em&gt; to avoid conflicting names for different types of devices.</source>
          <target state="translated">브라우저에서 장치 유형을 감지 할 수없는 경우 값은 빈 문자열 ( &quot;&quot;) 일 수 있습니다. 브라우저가 위에 나열된 것 이외의 포인터 장치 유형을 지원하는 경우, 다른 유형의 장치에 대해 이름이 충돌하지 않도록 값 &lt;em&gt;앞에 공급 업체를 붙여야&lt;/em&gt; 합니다.</target>
        </trans-unit>
        <trans-unit id="f2694d6e07b4a11ae0daee67d589f3f2aff2fc15" translate="yes" xml:space="preserve">
          <source>If the dialog is already open (i.e. if the &lt;code&gt;open&lt;/code&gt; attribute is already set on the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/dialog&quot;&gt;&lt;code&gt;&amp;lt;dialog&amp;gt;&lt;/code&gt;&lt;/a&gt; element), an &lt;code&gt;InvalidStateError&lt;/code&gt; is thrown.</source>
          <target state="translated">대화 상자가 이미 열려있는 경우 (즉 , &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/dialog&quot;&gt; &lt;code&gt;&amp;lt;dialog&amp;gt;&lt;/code&gt; &lt;/a&gt; 요소 에 이미 &lt;code&gt;open&lt;/code&gt; 속성이 설정된 경우) &lt;code&gt;InvalidStateError&lt;/code&gt; 가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="6a0802c2f531dd572220c1586f956d196c1cd3f9" translate="yes" xml:space="preserve">
          <source>If the display is not already presenting, we use the &lt;a href=&quot;../vrdisplay/requestpresent&quot;&gt;&lt;code&gt;VRDisplay.requestPresent()&lt;/code&gt;&lt;/a&gt; method to request that the browser start presenting content to the display. This takes as a parameter an array of the &lt;a href=&quot;../vrlayerinit&quot;&gt;&lt;code&gt;VRLayerInit&lt;/code&gt;&lt;/a&gt; objects representing the layers you want to present in the display.</source>
          <target state="translated">디스플레이가 아직 표시되지 않으면 &lt;a href=&quot;../vrdisplay/requestpresent&quot;&gt; &lt;code&gt;VRDisplay.requestPresent()&lt;/code&gt; &lt;/a&gt; 메서드를 사용 하여 브라우저가 디스플레이에 콘텐츠를 표시하도록 요청합니다. 디스플레이에 표시 할 레이어를 나타내는 &lt;a href=&quot;../vrlayerinit&quot;&gt; &lt;code&gt;VRLayerInit&lt;/code&gt; &lt;/a&gt; 객체 의 배열을 매개 변수로 사용 합니다.</target>
        </trans-unit>
        <trans-unit id="7c8248f941fb19868b947ed305eede768e975177" translate="yes" xml:space="preserve">
          <source>If the document already has been granted access, resolve.</source>
          <target state="translated">문서에 이미 액세스 권한이 부여 된 경우 해결하십시오.</target>
        </trans-unit>
        <trans-unit id="43d92ab2ffb73b2719f093be8bf506d045f1a857" translate="yes" xml:space="preserve">
          <source>If the document contains &lt;code&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/XML/xml:base&quot;&gt;xml:base&lt;/a&gt;&lt;/code&gt; attributes (which you shouldn't do in HTML documents), the &lt;code&gt;&lt;em&gt;element&lt;/em&gt;.baseURI&lt;/code&gt; takes the &lt;code&gt;xml:base&lt;/code&gt; attributes of element's parents into account when computing the base URL. See &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/XML/xml:base&quot;&gt;xml:base&lt;/a&gt; for details.</source>
          <target state="translated">문서가 포함 된 경우 &lt;code&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/XML/xml:base&quot;&gt;xml:base&lt;/a&gt;&lt;/code&gt; 속성을 (당신이 HTML 문서에서하지 말아야 함)의 &lt;code&gt;&lt;em&gt;element&lt;/em&gt;.baseURI&lt;/code&gt; 소요 &lt;code&gt;xml:base&lt;/code&gt; 기본 URL을 계산할 때 고려 요소의 부모의 속성. 자세한 내용은 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/XML/xml:base&quot;&gt;xml : base&lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="774b4edcc9665405008ed71d447c9c0115fd51ae" translate="yes" xml:space="preserve">
          <source>If the document has a null origin, reject.</source>
          <target state="translated">문서에 원점이없는 경우 거부하십시오.</target>
        </trans-unit>
        <trans-unit id="71677b8e55b892dc8ca7fb7741dcb9088be61a4e" translate="yes" xml:space="preserve">
          <source>If the document has just become visible, we reverse this process: first we go through &lt;code&gt;previouslyVisibleAds&lt;/code&gt; and set each one's &lt;code&gt;dataset.lastViewStarted&lt;/code&gt; to the current document's time (in milliseconds since the document was created) using the &lt;a href=&quot;../performance/now&quot;&gt;&lt;code&gt;performance.now()&lt;/code&gt;&lt;/a&gt; method. Then we set &lt;code&gt;visibleAds&lt;/code&gt; back to &lt;code&gt;previouslyVisibleAds&lt;/code&gt; and set the latter to &lt;code&gt;null&lt;/code&gt;. Now the ads are all restarted, and configured to know that they became visible at the current time, so that they will not add up the duration of time the page was tabbed away the next time they're updated.</source>
          <target state="translated">문서가 방금 표시되면이 프로세스를 반대로 진행합니다. 먼저 &lt;code&gt;previouslyVisibleAds&lt;/code&gt; 통해 각 &lt;code&gt;dataset.lastViewStarted&lt;/code&gt; 를 &lt;a href=&quot;../performance/now&quot;&gt; &lt;code&gt;performance.now()&lt;/code&gt; &lt;/a&gt; 메소드를 사용하여 현재 문서의 시간 (문서가 작성된 후 밀리 초 )으로 설정 합니다. 그런 다음 &lt;code&gt;visibleAds&lt;/code&gt; 를 &lt;code&gt;previouslyVisibleAds&lt;/code&gt; 다시 설정하고 후자를 &lt;code&gt;null&lt;/code&gt; 로 설정합니다 . 이제 광고가 모두 다시 시작되고 현재 시간에 광고가 표시되어 다음에 업데이트 할 때 페이지가 탭 아웃되는 시간을 더하지 않도록 구성되었습니다.</target>
        </trans-unit>
        <trans-unit id="ce6ae13fe44eab60c6bc9aa8f3992c39aa10f23a" translate="yes" xml:space="preserve">
          <source>If the document has no forms, the returned collection is empty, with a length of zero.</source>
          <target state="translated">문서에 양식이없는 경우 반환 된 컬렉션은 비어 있으며 길이는 0입니다.</target>
        </trans-unit>
        <trans-unit id="e5024b0850c90c5227f4dad5da48ac5a71c542f5" translate="yes" xml:space="preserve">
          <source>If the document isn't already in full-screen mode&amp;mdash;detected by looking to see if &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/DocumentOrShadowRoot/fullscreenElement&quot;&gt;&lt;code&gt;document.fullscreenElement&lt;/code&gt;&lt;/a&gt; has a value&amp;mdash;we call the video's &lt;code&gt;requestFullscreen()&lt;/code&gt; method. We don't need to do anything special if successful, but if the request fails, our promise's &lt;code&gt;catch()&lt;/code&gt; handler presents an alert with an appropriate error message.</source>
          <target state="translated">문서가 전체 화면 모드에 있지 않은 경우 ( &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/DocumentOrShadowRoot/fullscreenElement&quot;&gt; &lt;code&gt;document.fullscreenElement&lt;/code&gt; &lt;/a&gt; 에 값이 있는지 확인하여 감지 된 경우 &lt;code&gt;requestFullscreen()&lt;/code&gt; 비디오의 requestFullscreen () 메서드를 호출합니다 . 성공한 경우 특별한 작업을 수행 할 필요는 없지만 요청이 실패하면 promise의 &lt;code&gt;catch()&lt;/code&gt; 핸들러는 적절한 오류 메시지와 함께 경고를 표시합니다.</target>
        </trans-unit>
        <trans-unit id="f53dc535b27a14210405f61eb3e29719b7aa8cd6" translate="yes" xml:space="preserve">
          <source>If the document object's &lt;a href=&quot;https://www.w3.org/TR/presentation-api/#dfn-active-sandboxing-flag-set&quot;&gt;active sandboxing flag set&lt;/a&gt; has the &lt;a href=&quot;https://www.w3.org/TR/presentation-api/#sandboxed-presentation-browsing-context-flag&quot;&gt;sandboxed presentation browsing context flag&lt;/a&gt; set, then return a &lt;a href=&quot;https://www.w3.org/TR/presentation-api/#dfn-promise&quot;&gt;Promise&lt;/a&gt; rejected with a &lt;a href=&quot;https://www.w3.org/TR/presentation-api/#dfn-securityerror&quot;&gt;&lt;code&gt;SecurityError&lt;/code&gt;&lt;/a&gt; and abort these steps.</source>
          <target state="translated">문서 객체의 &lt;a href=&quot;https://www.w3.org/TR/presentation-api/#dfn-active-sandboxing-flag-set&quot;&gt;활성 샌드 박싱 플래그 세트&lt;/a&gt; 에 &lt;a href=&quot;https://www.w3.org/TR/presentation-api/#sandboxed-presentation-browsing-context-flag&quot;&gt;샌드 박스 프레젠테이션 브라우징 컨텍스트 플래그&lt;/a&gt; 세트가 있으면 &lt;a href=&quot;https://www.w3.org/TR/presentation-api/#dfn-securityerror&quot;&gt; &lt;code&gt;SecurityError&lt;/code&gt; 로&lt;/a&gt; 거부 된 &lt;a href=&quot;https://www.w3.org/TR/presentation-api/#dfn-promise&quot;&gt;약속&lt;/a&gt; 을 반환 하고이 단계를 중단합니다.</target>
        </trans-unit>
        <trans-unit id="8e254923b358c091b810b376ffab0e1a255d8743" translate="yes" xml:space="preserve">
          <source>If the document's frame is the main frame, resolve.</source>
          <target state="translated">문서의 프레임이 메인 프레임 인 경우 해결하십시오.</target>
        </trans-unit>
        <trans-unit id="cfed3ee5e1130dd2d1a79383dc3d28fae520ff96" translate="yes" xml:space="preserve">
          <source>If the drag data item is a file, a &lt;a href=&quot;../file&quot;&gt;&lt;code&gt;File&lt;/code&gt;&lt;/a&gt; object is returned; otherwise &lt;code&gt;null&lt;/code&gt; is returned.</source>
          <target state="translated">드래그 데이터 항목이 파일이면 &lt;a href=&quot;../file&quot;&gt; &lt;code&gt;File&lt;/code&gt; &lt;/a&gt; 객체가 반환됩니다. 그렇지 않으면 &lt;code&gt;null&lt;/code&gt; 이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="3c4d043f7f2a5eb85686949b69c274be996ab1ed" translate="yes" xml:space="preserve">
          <source>If the drag data item is a file.</source>
          <target state="translated">드래그 데이터 항목이 파일 인 경우</target>
        </trans-unit>
        <trans-unit id="920098d2db447efc82a006061103c436df372c7d" translate="yes" xml:space="preserve">
          <source>If the element at the specified point belongs to another document (for example, the document of an &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/iframe&quot;&gt;&lt;code&gt;&amp;lt;iframe&amp;gt;&lt;/code&gt;&lt;/a&gt;), that document's parent element is returned (the &lt;code&gt;&amp;lt;iframe&amp;gt;&lt;/code&gt; itself). If the element at the given point is anonymous or XBL generated content, such as a textbox's scroll bars, then the first non-anonymous ancestor element (for example, the textbox) is returned.</source>
          <target state="translated">지정된 지점의 요소가 다른 문서 (예 : &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/iframe&quot;&gt; &lt;code&gt;&amp;lt;iframe&amp;gt;&lt;/code&gt; &lt;/a&gt; 의 문서)에 속하는 경우 해당 문서의 상위 요소가 리턴됩니다 ( &lt;code&gt;&amp;lt;iframe&amp;gt;&lt;/code&gt; 자체). 지정된 지점의 요소가 텍스트 상자의 스크롤 막대와 같은 익명 또는 XBL 생성 컨텐츠 인 경우 첫 번째 비 익명 조상 요소 (예 : 텍스트 상자)가 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="7c3a6878c6317c033a2643ea60eefaa914664422" translate="yes" xml:space="preserve">
          <source>If the element being observed is removed from the DOM and then subsequently released by the browser's garbage collection mechanism, the &lt;code&gt;MutationObserver&lt;/code&gt; is likewise deleted.</source>
          <target state="translated">관찰되는 요소가 DOM에서 제거 된 다음 브라우저의 가비지 수집 메커니즘에 의해 해제되면 &lt;code&gt;MutationObserver&lt;/code&gt; 도 마찬가지로 삭제됩니다.</target>
        </trans-unit>
        <trans-unit id="8080ce97d3c162414e0234cfaeac7ac3820b9535" translate="yes" xml:space="preserve">
          <source>If the element can't be scrolled (e.g. it has no overflow or if the element has a property of &quot;&lt;strong&gt;non-scrollable&quot;&lt;/strong&gt;), &lt;code&gt;scrollTop&lt;/code&gt; is &lt;code&gt;0&lt;/code&gt;.</source>
          <target state="translated">요소를 스크롤 할 수없는 경우 (예 : 오버플로가 없거나 요소에 &quot; &lt;strong&gt;스크롤 불가능&lt;/strong&gt; &quot;속성이있는 경우 ) &lt;code&gt;scrollTop&lt;/code&gt; 은 &lt;code&gt;0&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="9e5a18b17e331dcc36dcc4852c51297132b9f609" translate="yes" xml:space="preserve">
          <source>If the element can't be scrolled (e.g. it has no overflow), &lt;code&gt;scrollLeft&lt;/code&gt; is set to 0.</source>
          <target state="translated">요소를 스크롤 할 수없는 경우 (예 : 오버 플로우가없는 경우) &lt;code&gt;scrollLeft&lt;/code&gt; 는 0으로 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="590fcbd8250c6d0a953f2748beda684fa985faed" translate="yes" xml:space="preserve">
          <source>If the element has already been initialized with media, the &lt;code&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Events/emptied&quot;&gt;emptied&lt;/a&gt;&lt;/code&gt; event is sent.</source>
          <target state="translated">요소가 이미 미디어로 초기화 된 경우 &lt;code&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Events/emptied&quot;&gt;emptied&lt;/a&gt;&lt;/code&gt; 이벤트가 전송됩니다.</target>
        </trans-unit>
        <trans-unit id="8305a717df89769ad215c455beb7697f22ca5cc0" translate="yes" xml:space="preserve">
          <source>If the element has no parent element, setting its &lt;code&gt;outerHTML&lt;/code&gt; property will not change it or its descendants. Many browsers will also throw an exception. For example:</source>
          <target state="translated">요소에 부모 요소가 없으면 &lt;code&gt;outerHTML&lt;/code&gt; 속성을 설정해도 해당 요소 나 그 하위 항목이 변경되지 않습니다. 많은 브라우저에서도 예외가 발생합니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="644bf1ca310a4ad622e5ac146411d4de479e7f18" translate="yes" xml:space="preserve">
          <source>If the element is already in the process of loading media, that load process is aborted and the &lt;code&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Events/abort&quot;&gt;abort&lt;/a&gt;&lt;/code&gt; event is sent.</source>
          <target state="translated">요소가 이미 매체로드 프로세스 중이면로드 프로세스가 중단되고 &lt;code&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Events/abort&quot;&gt;abort&lt;/a&gt;&lt;/code&gt; 이벤트가 전송됩니다.</target>
        </trans-unit>
        <trans-unit id="20bf64afaaefa24ed055bff1ca25537ffbc10051" translate="yes" xml:space="preserve">
          <source>If the element is hidden (for example, by setting &lt;code&gt;style.display&lt;/code&gt; on the element or one of its ancestors to &lt;code&gt;&quot;none&quot;&lt;/code&gt;), then &lt;code&gt;0&lt;/code&gt; is returned.</source>
          <target state="translated">요소가 숨겨져 있으면 (예를 들어, 요소 또는 해당 조상 중 하나에서 &lt;code&gt;&quot;none&quot;&lt;/code&gt; 으로 &lt;code&gt;style.display&lt;/code&gt; 를 설정 하여 ) &lt;code&gt;0&lt;/code&gt; 이 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="29f592507dfe087637473cd93366686fc2c1b3df" translate="yes" xml:space="preserve">
          <source>If the element is in default mode when the descendants of the element are changed in any way, the &lt;code&gt;defaultValue&lt;/code&gt; property is set to the value of the &lt;a href=&quot;node/textcontent&quot;&gt;&lt;code&gt;textContent&lt;/code&gt;&lt;/a&gt; property.</source>
          <target state="translated">요소의 하위 항목이 어떤 방식 으로든 변경 될 때 요소가 기본 모드에있는 경우 &lt;code&gt;defaultValue&lt;/code&gt; 특성은 &lt;a href=&quot;node/textcontent&quot;&gt; &lt;code&gt;textContent&lt;/code&gt; &lt;/a&gt; 특성 의 값으로 설정됩니다 .</target>
        </trans-unit>
        <trans-unit id="a7551d7938d802a5cfdd6cf1e7b97629948b9497" translate="yes" xml:space="preserve">
          <source>If the element whose contents are being replaced is a &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/template&quot;&gt;&lt;code&gt;&amp;lt;template&amp;gt;&lt;/code&gt;&lt;/a&gt; element, then the &lt;code&gt;&amp;lt;template&amp;gt;&lt;/code&gt; element's &lt;a href=&quot;../htmltemplateelement/content&quot;&gt;&lt;code&gt;content&lt;/code&gt;&lt;/a&gt; attribute is replaced with the new &lt;code&gt;DocumentFragment&lt;/code&gt; created in step 1.</source>
          <target state="translated">내용을 바꾸는 요소가 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/template&quot;&gt; &lt;code&gt;&amp;lt;template&amp;gt;&lt;/code&gt; &lt;/a&gt; 요소 인 경우 &lt;code&gt;&amp;lt;template&amp;gt;&lt;/code&gt; 요소의 &lt;a href=&quot;../htmltemplateelement/content&quot;&gt; &lt;code&gt;content&lt;/code&gt; &lt;/a&gt; 속성은 1 단계에서 만든 새 &lt;code&gt;DocumentFragment&lt;/code&gt; 로 바뀝니다 .</target>
        </trans-unit>
        <trans-unit id="4a44ba2a6822678e2a13542384ad24e9b985c0d7" translate="yes" xml:space="preserve">
          <source>If the elements in the array, or properties in the object, are themselves arrays or objects, then their elements or properties are enumerated in the row, one per column:</source>
          <target state="translated">배열의 요소 또는 객체의 속성 자체가 배열 또는 객체 인 경우 해당 요소 또는 속성은 열당 하나씩 행에 나열됩니다.</target>
        </trans-unit>
        <trans-unit id="ece0f8bed319f490c33d49190567c1a008d28f50" translate="yes" xml:space="preserve">
          <source>If the embedded origin &lt;code&gt;tracker.example&lt;/code&gt; has already obtained first-party storage access on the top-level origin &lt;code&gt;foo.example&lt;/code&gt;, and the user visits a page from &lt;code&gt;foo.example&lt;/code&gt; embedding a page from &lt;code&gt;tracker.example&lt;/code&gt; again in less than 30 days, the embedded origin will have storage access immediately when loading.</source>
          <target state="translated">임베드 된 오리진 &lt;code&gt;tracker.example&lt;/code&gt; 이 이미 최상위 오리진 &lt;code&gt;foo.example&lt;/code&gt; 에서 자사 스토리지 액세스 권한을 획득 했으며 사용자 가 30 일 이내에 &lt;code&gt;tracker.example&lt;/code&gt; 의 페이지를 다시 임베드 한 &lt;code&gt;foo.example&lt;/code&gt; 의 페이지를 방문한 경우 , 임베드 된 오리진은로드시 즉시 스토리지 액세스 권한을 갖습니다.</target>
        </trans-unit>
        <trans-unit id="ba4138345301a79b99ab47d7ab08512478dfeeec" translate="yes" xml:space="preserve">
          <source>If the encoding type label argument is invalid, then a &lt;code&gt;RangeError&lt;/code&gt; exception is thrown.</source>
          <target state="translated">인코딩 유형 레이블 인수가 유효하지 않으면 &lt;code&gt;RangeError&lt;/code&gt; 예외가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="86389fc5f4e50196c07da8cf7843eedbbae1c375" translate="yes" xml:space="preserve">
          <source>If the encoding type label argument is invalid, then a &lt;code&gt;TypeError&lt;/code&gt; exception is thrown.</source>
          <target state="translated">인코딩 유형 레이블 인수가 유효하지 않으면 &lt;code&gt;TypeError&lt;/code&gt; 예외가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="ce5ceb5b4dc34ab8a6ecdde75c314d7ca3c1a968" translate="yes" xml:space="preserve">
          <source>If the event generator script is hosted on a different domain, a new &lt;code&gt;EventSource&lt;/code&gt; object should be created that specifies both the URI and options dictionary. For example, assuming the client script is on example.com:</source>
          <target state="translated">이벤트 생성기 스크립트가 다른 도메인에서 호스팅되는 경우 URI 및 옵션 사전을 모두 지정 하는 새로운 &lt;code&gt;EventSource&lt;/code&gt; 객체를 만들어야합니다. 예를 들어 클라이언트 스크립트가 example.com에 있다고 가정합니다.</target>
        </trans-unit>
        <trans-unit id="2e23333ed89480767e6c6382f8ebd8944fcd3090" translate="yes" xml:space="preserve">
          <source>If the event's candidate property is &lt;code&gt;null&lt;/code&gt;, ICE gathering has finished.</source>
          <target state="translated">이벤트의 후보 특성이 &lt;code&gt;null&lt;/code&gt; 인 경우 ICE 수집이 완료되었습니다.</target>
        </trans-unit>
        <trans-unit id="47fdcae6f8453282ba30ceec9b5dc9b23abf3ba3" translate="yes" xml:space="preserve">
          <source>If the field set is not a descendant of a form element, then the attribute can be the ID of any form element in the same document it is related to, or the &lt;code&gt;null&lt;/code&gt; value if none matches.</source>
          <target state="translated">필드 세트가 양식 요소의 하위 항목이 아닌 경우 속성은 관련된 동일한 문서에서 양식 요소의 ID이거나 일치하지 않는 경우 &lt;code&gt;null&lt;/code&gt; 값일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4da9834c4d7f6524b67c6f43f2f7e2a8564d5a5c" translate="yes" xml:space="preserve">
          <source>If the file is named &lt;code&gt;detect.html&lt;/code&gt;, the following function can be used for detecting HTML parsing support:</source>
          <target state="translated">파일 이름이 &lt;code&gt;detect.html&lt;/code&gt; 인 경우 다음 함수를 사용하여 HTML 구문 분석 지원을 감지 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f8a76a6c10befaa2637268133d7ddf80de7d16b0" translate="yes" xml:space="preserve">
          <source>If the font face is still not loaded, the fallback font will be shown. When the font face loads, the fallback will be swaped for the downloaded font.</source>
          <target state="translated">서체가 여전히로드되지 않으면 대체 서체가 표시됩니다. 글꼴이로드되면 대체 글꼴이 다운로드 된 글꼴로 교체됩니다.</target>
        </trans-unit>
        <trans-unit id="9b999a871e8883cc43a497570b59b609eba1d7e0" translate="yes" xml:space="preserve">
          <source>If the font face still is not loaded, the fallback font will be shown and no swap will occur.</source>
          <target state="translated">서체가 여전히로드되지 않으면 대체 서체가 표시되고 스왑이 발생하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="82b04273301dfed09833c9a838f53e02f7f5af72" translate="yes" xml:space="preserve">
          <source>If the given attribute or property is being animated, contains the current animated value of the attribute or property. If the given attribute or property is not currently being animated, contains the same value as &lt;code&gt;baseVal&lt;/code&gt;.</source>
          <target state="translated">주어진 속성 또는 속성이 애니메이션되는 경우 속성 또는 속성의 현재 애니메이션 값을 포함합니다. 지정된 속성 또는 속성이 현재 애니메이션되지 않은 경우 &lt;code&gt;baseVal&lt;/code&gt; 과 동일한 값을 포함합니다 .</target>
        </trans-unit>
        <trans-unit id="a6db4a11c76a7ee07e5de28aef8642b65b9cee6e" translate="yes" xml:space="preserve">
          <source>If the given base URL or the resulting URL are not valid URLs, a &lt;a href=&quot;../domexception&quot;&gt;&lt;code&gt;DOMException&lt;/code&gt;&lt;/a&gt; of type &lt;code&gt;SYNTAX_ERROR&lt;/code&gt; is thrown.</source>
          <target state="translated">제공된 기본 URL 또는 결과 URL이 유효한 URL이 아닌 경우 &lt;code&gt;SYNTAX_ERROR&lt;/code&gt; 유형 의 &lt;a href=&quot;../domexception&quot;&gt; &lt;code&gt;DOMException&lt;/code&gt; &lt;/a&gt; 이 발생합니다.</target>
        </trans-unit>
        <trans-unit id="0f2b2316ccbbeaf806d2e863b9793f3ab6a250e8" translate="yes" xml:space="preserve">
          <source>If the given child is a &lt;a href=&quot;../documentfragment&quot;&gt;&lt;code&gt;DocumentFragment&lt;/code&gt;&lt;/a&gt;, the entire contents of the &lt;a href=&quot;../documentfragment&quot;&gt;&lt;code&gt;DocumentFragment&lt;/code&gt;&lt;/a&gt; are moved into the child list of the specified parent node.</source>
          <target state="translated">지정된 아이가있는 경우 &lt;a href=&quot;../documentfragment&quot;&gt; &lt;code&gt;DocumentFragment&lt;/code&gt; 가&lt;/a&gt; ,의 전체 내용 &lt;a href=&quot;../documentfragment&quot;&gt; &lt;code&gt;DocumentFragment&lt;/code&gt; &lt;/a&gt; 지정된 부모 노드의 자식 목록으로 이동합니다.</target>
        </trans-unit>
        <trans-unit id="ac5117ff72862f9843c6819f158d70704e0e8b36" translate="yes" xml:space="preserve">
          <source>If the header has multiple values associated with it, the array will contain all the values, in the order they were added to the Headers object:</source>
          <target state="translated">헤더에 연결된 값이 여러 개인 경우 배열은 Headers 객체에 추가 된 순서대로 모든 값을 포함합니다.</target>
        </trans-unit>
        <trans-unit id="94a786d78a3e866655c566ffb7b55371e8e56916" translate="yes" xml:space="preserve">
          <source>If the header has multiple values associated with it, the byte string will contain all the values, in the order they were added to the Headers object:</source>
          <target state="translated">헤더에 연관된 값이 여러 개인 경우 바이트 문자열에는 Headers 객체에 추가 된 순서대로 모든 값이 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="3c45af1972899b394fbdadef919607186a7b2eb1" translate="yes" xml:space="preserve">
          <source>If the height or width of the canvas is &lt;code&gt;0&lt;/code&gt;, the string &lt;code&gt;&quot;data:,&quot;&lt;/code&gt; is returned.</source>
          <target state="translated">캔버스의 높이 또는 너비가 &lt;code&gt;0&lt;/code&gt; 이면 문자열 &lt;code&gt;&quot;data:,&quot;&lt;/code&gt; 가 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="ad4e2fffd12b69a8f3c7559db75db40075b1db88" translate="yes" xml:space="preserve">
          <source>If the index with the given name does not exist in the connected database.</source>
          <target state="translated">지정된 이름의 색인이 연결된 데이터베이스에 존재하지 않는 경우</target>
        </trans-unit>
        <trans-unit id="ad518920a5e1002e600352f85bc4e3edc1f2d13e" translate="yes" xml:space="preserve">
          <source>If the initial view was a link into a &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/SVG/Element/view&quot;&gt;&lt;code&gt;&amp;lt;view&amp;gt;&lt;/code&gt;&lt;/a&gt; element, then:</source>
          <target state="translated">초기 뷰가 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/SVG/Element/view&quot;&gt; &lt;code&gt;&amp;lt;view&amp;gt;&lt;/code&gt; &lt;/a&gt; 요소 에 대한 링크 인 경우 :</target>
        </trans-unit>
        <trans-unit id="721337c6e06ac1a5e23c0ec577674adddf8d428d" translate="yes" xml:space="preserve">
          <source>If the initial view was a link into another element (i.e., other than a &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/SVG/Element/view&quot;&gt;&lt;code&gt;&amp;lt;view&amp;gt;&lt;/code&gt;&lt;/a&gt;), then:</source>
          <target state="translated">초기 뷰가 다른 요소 (예 : &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/SVG/Element/view&quot;&gt; &lt;code&gt;&amp;lt;view&amp;gt;&lt;/code&gt; &lt;/a&gt; 이외)에 대한 링크 인 경우 :</target>
        </trans-unit>
        <trans-unit id="df5f1cd17e4d23f6220fd86c6ffc7e369ce48996" translate="yes" xml:space="preserve">
          <source>If the initial view was a link into the SVG document fragment using an SVG view specification fragment identifier (i.e., #svgView(...)), then:</source>
          <target state="translated">초기보기가 SVG보기 사양 조각 식별자 (예 : #svgView (...))를 사용하여 SVG 문서 조각에 대한 링크 인 경우 :</target>
        </trans-unit>
        <trans-unit id="f4ea37f22490165c0e52a641f39be9a587814177" translate="yes" xml:space="preserve">
          <source>If the initiator is a &lt;a href=&quot;../css&quot;&gt;&lt;code&gt;CSS&lt;/code&gt;&lt;/a&gt; resource, the property returns &quot;&lt;code&gt;css&lt;/code&gt;&quot;.</source>
          <target state="translated">이니시에이터가 &lt;a href=&quot;../css&quot;&gt; &lt;code&gt;CSS&lt;/code&gt; &lt;/a&gt; 리소스 인 &lt;code&gt;css&lt;/code&gt; 속성은 &quot; css &quot;를 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="7f030af4d0dd6deea5ed265bbc5c9c1b31d1a47e" translate="yes" xml:space="preserve">
          <source>If the initiator is a &lt;a href=&quot;../element&quot;&gt;&lt;code&gt;Element&lt;/code&gt;&lt;/a&gt;, the property returns the element's &lt;a href=&quot;../node/localname&quot;&gt;&lt;code&gt;localName&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이니시에이터가 &lt;a href=&quot;../element&quot;&gt; &lt;code&gt;Element&lt;/code&gt; 인&lt;/a&gt; 경우, 속성은 요소의 &lt;a href=&quot;../node/localname&quot;&gt; &lt;code&gt;localName&lt;/code&gt; 을&lt;/a&gt; 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="6c9d5ac16de099b000d2229ce4a74b516207c882" translate="yes" xml:space="preserve">
          <source>If the initiator is a &lt;a href=&quot;../performancenavigationtiming&quot;&gt;&lt;code&gt;PerformanceNavigationTiming&lt;/code&gt;&lt;/a&gt; object, the property returns an empty string (&lt;code&gt;&quot;&quot;&lt;/code&gt;).</source>
          <target state="translated">초기자가 &lt;a href=&quot;../performancenavigationtiming&quot;&gt; &lt;code&gt;PerformanceNavigationTiming&lt;/code&gt; &lt;/a&gt; 객체 인 경우이 속성은 빈 문자열 ( &lt;code&gt;&quot;&quot;&lt;/code&gt; )을 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="902a0d8e42f2d06eb5b2e95e0c887060319780fe" translate="yes" xml:space="preserve">
          <source>If the initiator is a &lt;a href=&quot;../xmlhttprequest&quot;&gt;&lt;code&gt;XMLHttpRequest&lt;/code&gt;&lt;/a&gt; object, the property returns &quot;&lt;code&gt;xmlhttprequest&lt;/code&gt;&quot;.</source>
          <target state="translated">초기자가 &lt;a href=&quot;../xmlhttprequest&quot;&gt; &lt;code&gt;XMLHttpRequest&lt;/code&gt; &lt;/a&gt; 객체 인 &lt;code&gt;xmlhttprequest&lt;/code&gt; 속성은 &quot; xmlhttprequest &quot;를 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="5638c8f55d14655d89fbc2f9de7a47d33e6dcfdc" translate="yes" xml:space="preserve">
          <source>If the input device isn't a physical keyboard, but is instead a virtual keyboard or accessibility device, the returned value will be set by the browser to match as closely as possible to what would happen with a physical keyboard, to maximize compatibility between physical and virtual input devices.</source>
          <target state="translated">입력 장치가 물리적 키보드가 아니라 가상 키보드 또는 접근성 장치 인 경우 물리적 키보드 간 발생 가능성과 최대한 일치하도록 브라우저가 반환 값을 설정하여 물리적 장치 간의 호환성을 최대화합니다. 및 가상 입력 장치.</target>
        </trans-unit>
        <trans-unit id="42bbc614f0c64982ba785cfc2a74980fbe642888" translate="yes" xml:space="preserve">
          <source>If the input hardware cannot report the contact geometry to the browser, the height defaults to &lt;code&gt;1&lt;/code&gt;.</source>
          <target state="translated">입력 하드웨어가 접촉 형상을 브라우저에보고 할 수없는 경우 높이는 기본적으로 &lt;code&gt;1&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="a536ad0b547415216083762c8f217d6a301bd37e" translate="yes" xml:space="preserve">
          <source>If the input hardware cannot report the contact geometry to the browser, the width defaults to &lt;code&gt;1&lt;/code&gt;.</source>
          <target state="translated">입력 하드웨어가 접촉 형상을 브라우저에보고 할 수없는 경우 기본 너비는 &lt;code&gt;1&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="74cb1aa3e758fab1377f4815fa6b1077cc8586f7" translate="yes" xml:space="preserve">
          <source>If the item is a file, the &lt;code&gt;DataTransferItem.getAsFile()&lt;/code&gt; method returns the drag data item's &lt;a href=&quot;../file&quot;&gt;&lt;code&gt;File&lt;/code&gt;&lt;/a&gt; object. If the item is not a file, this method returns &lt;code&gt;null&lt;/code&gt;.</source>
          <target state="translated">항목이 파일 인 경우 &lt;code&gt;DataTransferItem.getAsFile()&lt;/code&gt; 메소드는 끌기 데이터 항목의 &lt;a href=&quot;../file&quot;&gt; &lt;code&gt;File&lt;/code&gt; &lt;/a&gt; 객체를 반환 합니다. 항목이 파일이 아닌 경우이 메소드는 &lt;code&gt;null&lt;/code&gt; 을 리턴합니다 .</target>
        </trans-unit>
        <trans-unit id="528d58d9bc1c5a537f920d2538380aaae2f76d50" translate="yes" xml:space="preserve">
          <source>If the key cannot be identified, the returned value is &lt;code&gt;&quot;Unidentified&quot;&lt;/code&gt;.</source>
          <target state="translated">키를 식별 할 수없는 경우 리턴 된 값은 &lt;code&gt;&quot;Unidentified&quot;&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="2da818d3d30eeb31464569d85224eb60cff513c7" translate="yes" xml:space="preserve">
          <source>If the key is not a modifier key, the &lt;code&gt;keypress&lt;/code&gt; event is sent.</source>
          <target state="translated">키가 수정 자 키가 아닌 경우 키 &lt;code&gt;keypress&lt;/code&gt; 이벤트가 전송됩니다.</target>
        </trans-unit>
        <trans-unit id="df119461d018d736ffa1e7804037aeb8f9cad7bc" translate="yes" xml:space="preserve">
          <source>If the key produces a character key that would result in a character being inserted into possibly an &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input&quot;&gt;&lt;code&gt;&amp;lt;input&amp;gt;&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/textarea&quot;&gt;&lt;code&gt;&amp;lt;textarea&amp;gt;&lt;/code&gt;&lt;/a&gt; or an element with &lt;a href=&quot;../htmlelement/contenteditable&quot;&gt;&lt;code&gt;HTMLElement.contentEditable&lt;/code&gt;&lt;/a&gt; set to true, the &lt;code&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Events/beforeinput&quot;&gt;beforeinput&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Events/input&quot;&gt;input&lt;/a&gt;&lt;/code&gt; event types are fired in that order. Note that some other implementations may fire &lt;code&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Events/keypress&quot;&gt;keypress&lt;/a&gt;&lt;/code&gt; event if supported. The events will be fired repeatedly while the key is held down.</source>
          <target state="translated">키가 문자를 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input&quot;&gt; &lt;code&gt;&amp;lt;input&amp;gt;&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/textarea&quot;&gt; &lt;code&gt;&amp;lt;textarea&amp;gt;&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;../htmlelement/contenteditable&quot;&gt; &lt;code&gt;HTMLElement.contentEditable&lt;/code&gt; &lt;/a&gt; 을 true로 설정 한 요소 에 삽입하는 문자 키를 생성 하면 &lt;code&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Events/beforeinput&quot;&gt;beforeinput&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Events/input&quot;&gt;input&lt;/a&gt;&lt;/code&gt; 이벤트 유형이 순서대로 실행됩니다. 지원되는 경우 일부 다른 구현에서 &lt;code&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Events/keypress&quot;&gt;keypress&lt;/a&gt;&lt;/code&gt; 이벤트 가 발생할 수 있습니다 . 키를 누르고있는 동안 이벤트가 반복해서 발생합니다.</target>
        </trans-unit>
        <trans-unit id="f0c322e9793430d8ec2aed9fd75eb983dabc21b8" translate="yes" xml:space="preserve">
          <source>If the key range is not specified or is null, then the range includes all the keys.</source>
          <target state="translated">키 범위가 지정되지 않았거나 널인 경우, 범위는 모든 키를 포함합니다.</target>
        </trans-unit>
        <trans-unit id="b11af57dec4d2c6f3a77201437ab0493ed9c243f" translate="yes" xml:space="preserve">
          <source>If the key range is not specified or is null, then the range includes all the records.</source>
          <target state="translated">키 범위가 지정되지 않았거나 널인 경우, 범위는 모든 레코드를 포함합니다.</target>
        </trans-unit>
        <trans-unit id="e6207fbf560215ae6060b14b0ffac26db2eea4a4" translate="yes" xml:space="preserve">
          <source>If the kind of drag data item is a &lt;em&gt;plain Unicode string&lt;/em&gt;.</source>
          <target state="translated">드래그 데이터 항목의 종류는 경우 &lt;em&gt;일반 유니 코드 문자열&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="fa7fc90ea5f81a5d0c3e6a368ad9f32f77108ac0" translate="yes" xml:space="preserve">
          <source>If the log was scrolled to the end when we started, we make sure it still is. Then we set &lt;code&gt;statusRefreshScheduled&lt;/code&gt; to &lt;code&gt;false&lt;/code&gt; to indicate that we've handled the refresh and that it's safe to request a new one.</source>
          <target state="translated">시작했을 때 로그가 끝까지 스크롤되면 여전히 로그인 지 확인합니다. 그런 다음 &lt;code&gt;statusRefreshScheduled&lt;/code&gt; 를 &lt;code&gt;false&lt;/code&gt; 로 설정 하여 새로 고침을 처리했으며 새로 요청하는 것이 안전하다는 것을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="7dc030d07de2795bee690695f0731fc91baabe89" translate="yes" xml:space="preserve">
          <source>If the media element's source isn't a &lt;code&gt;MediaStream&lt;/code&gt;, the output from this method isn't compatible with the spec, and if you change the source after starting capture, the output capture stream can't accept the new source data due to that incompatibility, so no &lt;a href=&quot;../mediastreamtrack&quot;&gt;&lt;code&gt;MediaStreamTrack&lt;/code&gt;&lt;/a&gt;s from the new source &lt;code&gt;MediaStream&lt;/code&gt; are added to the captured stream, resulting in output that doesn't capture the updated source.</source>
          <target state="translated">미디어 요소의 소스가 &lt;code&gt;MediaStream&lt;/code&gt; 이 아닌 경우 ,이 메소드의 출력은 스펙과 호환되지 않으며 캡처를 시작한 후 소스를 변경하면 해당 비 호환성으로 인해 출력 캡처 스트림이 새 소스 데이터를 승인 할 수 없습니다 , 그래서 &lt;a href=&quot;../mediastreamtrack&quot;&gt; &lt;code&gt;MediaStreamTrack&lt;/code&gt; &lt;/a&gt; 의 새로운 소스로부터 &lt;code&gt;MediaStream&lt;/code&gt; 업데이트 된 소스를 캡처하지 않는 출력의 결과로, 캡처 스트림에 추가되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="fd4f18aa60bd466eb3c0e62b649c7df02ca74d46" translate="yes" xml:space="preserve">
          <source>If the media is an audio file, the &lt;a href=&quot;audioconfiguration&quot;&gt;audio configuration&lt;/a&gt; must include a valid audio MIME type as &lt;code&gt;contentType&lt;/code&gt;, the number of channels, the bitrate, and the sample rate. &lt;a href=&quot;videoconfiguration&quot;&gt;Video configurations&lt;/a&gt; mush include a valid video MIME type as contentType, the bitrate, and framerate, along with the width and the height of the video file. All of these must be present, as in the examples below, or a TypeError will occur.</source>
          <target state="translated">미디어가 오디오 파일 인 경우 &lt;a href=&quot;audioconfiguration&quot;&gt;오디오 구성&lt;/a&gt; 에 유효한 오디오 MIME 유형을 &lt;code&gt;contentType&lt;/code&gt; , 채널 수, 비트 전송률 및 샘플 속도로 포함해야합니다. &lt;a href=&quot;videoconfiguration&quot;&gt;비디오 구성&lt;/a&gt; mush에는 contentType, bitrate 및 framerate와 같은 유효한 비디오 MIME 유형이 비디오 파일의 너비 및 높이와 함께 포함됩니다. 아래 예에서와 같이 이들 모두가 존재해야합니다. 그렇지 않으면 TypeError가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="81bd6986f5768dc2a6c11d48d625e1ee01adb03e" translate="yes" xml:space="preserve">
          <source>If the merchant desires to collect additional information not part of the API (e.g., additional delivery instructions), the merchant can show a page with additional &lt;code&gt;&amp;lt;input type=&quot;text&quot;&amp;gt;&lt;/code&gt; fields after the checkout.</source>
          <target state="translated">판매자가 API의 일부가 아닌 추가 정보 (예 : 추가 전달 지시 사항)를 수집하려는 경우 판매자 는 체크 아웃 후 추가 &lt;code&gt;&amp;lt;input type=&quot;text&quot;&amp;gt;&lt;/code&gt; 필드가 있는 페이지를 표시 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="c103684d9fd743cbcd40f7ef58d3f4c876f42fe9" translate="yes" xml:space="preserve">
          <source>If the method is run on another document (like an &lt;code&gt;&amp;lt;iframe&amp;gt;&lt;/code&gt;'s subdocument), the coordinates are relative to the document where the method is being called.</source>
          <target state="translated">메소드가 &lt;code&gt;&amp;lt;iframe&amp;gt;&lt;/code&gt; 의 하위 문서 와 같은 다른 문서에서 실행될 경우 좌표는 메소드가 호출되는 문서를 기준으로합니다.</target>
        </trans-unit>
        <trans-unit id="4475f2314362d6928ba75984fdb17e7b9f868e3b" translate="yes" xml:space="preserve">
          <source>If the method was unable to vibrate because of invalid parameters, it will return &lt;code&gt;false&lt;/code&gt;, else it returns &lt;code&gt;true&lt;/code&gt;. If the pattern leads to a too long vibration, it is truncated: the max length depends on the implementation.</source>
          <target state="translated">유효하지 않은 매개 변수로 인해 메소드가 진동 할 수없는 경우 &lt;code&gt;false&lt;/code&gt; 를 리턴 하고 그렇지 않으면 &lt;code&gt;true&lt;/code&gt; 를 리턴 합니다 . 패턴이 너무 긴 진동으로 이어지면 잘립니다. 최대 길이는 구현에 따라 다릅니다.</target>
        </trans-unit>
        <trans-unit id="20d4007231b404440b87846630914de42fe63edc" translate="yes" xml:space="preserve">
          <source>If the mouse button is in fact down, we get the pressed key's &lt;code&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Global_attributes#attr-dataset&quot;&gt;dataset&lt;/a&gt;&lt;/code&gt; attribute; this makes it easy to access the custom data attributes on the element. We look for a &lt;code&gt;data-pressed&lt;/code&gt; attribute; if there isn't one (which indicates that the note isn't already playing), we call &lt;code&gt;playTone()&lt;/code&gt; to start playing the note, passing in the value of the element's &lt;code&gt;data-frequency&lt;/code&gt; attribute. The returned oscillator is stored into &lt;code&gt;oscList&lt;/code&gt; for future reference, and &lt;code&gt;data-pressed&lt;/code&gt; is set to &lt;code&gt;yes&lt;/code&gt; to indicate that the note is playing so we don't start it again next time this is called.</source>
          <target state="translated">마우스 버튼이 실제로 눌려져 있으면 눌린 키의 &lt;code&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Global_attributes#attr-dataset&quot;&gt;dataset&lt;/a&gt;&lt;/code&gt; 속성을 얻습니다 . 이를 통해 요소의 사용자 정의 데이터 속성에 쉽게 액세스 할 수 있습니다. &lt;code&gt;data-pressed&lt;/code&gt; 속성을 찾습니다 . 없는 경우 (음표가 아직 재생되지 않음을 나타냄), &lt;code&gt;playTone()&lt;/code&gt; 을 호출 하여 음표 재생을 시작하고 요소의 &lt;code&gt;data-frequency&lt;/code&gt; 속성 값을 전달 합니다. 반환 된 오실레이터는 나중에 참조 할 수 &lt;code&gt;oscList&lt;/code&gt; 에 저장되며 , 다음에 호출 할 때 다시 시작하지 않도록 노트가 재생 중임을 나타 내기 위해 &lt;code&gt;data-pressed&lt;/code&gt; 가 &lt;code&gt;yes&lt;/code&gt; 로 설정됩니다 .</target>
        </trans-unit>
        <trans-unit id="41f5dae8e8ad76e798b110b2d2eedf3b035cd41f" translate="yes" xml:space="preserve">
          <source>If the new data channel is the first one added to the connection, renegotiation is started by delivering a &lt;code&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Events/negotiationneeded&quot;&gt;negotiationneeded&lt;/a&gt;&lt;/code&gt; event.</source>
          <target state="translated">새 데이터 채널이 연결에 처음 추가 된 채널 인 경우 &lt;code&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Events/negotiationneeded&quot;&gt;negotiationneeded&lt;/a&gt;&lt;/code&gt; 이벤트 를 전달하여 재협상이 시작됩니다 .</target>
        </trans-unit>
        <trans-unit id="339d3c6e2d8e43bb63542ae77fe5df6ae3d75aa4" translate="yes" xml:space="preserve">
          <source>If the new node is a document fragment, the children of the document fragment are inserted instead.</source>
          <target state="translated">새 노드가 문서 조각 인 경우 문서 조각의 자식이 대신 삽입됩니다.</target>
        </trans-unit>
        <trans-unit id="1aa2a44f7ee53ab4b00da030a6a710d8eefa1c01" translate="yes" xml:space="preserve">
          <source>If the new value of &lt;code&gt;direction&lt;/code&gt; is in fact different from the existing value, renegotiation of the connection is required, so a &lt;code&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Events/notificationneeded&quot;&gt;notificationneeded&lt;/a&gt;&lt;/code&gt; event is sent to the &lt;a href=&quot;../rtcpeerconnection&quot;&gt;&lt;code&gt;RTCPeerConnection&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">새 &lt;code&gt;direction&lt;/code&gt; 값이 실제로 기존 값과 다른 경우 연결 재협상이 필요하므로 &lt;code&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Events/notificationneeded&quot;&gt;notificationneeded&lt;/a&gt;&lt;/code&gt; 이 필요한 이벤트가 &lt;a href=&quot;../rtcpeerconnection&quot;&gt; &lt;code&gt;RTCPeerConnection&lt;/code&gt; 에&lt;/a&gt; 전송됩니다 .</target>
        </trans-unit>
        <trans-unit id="fc125eb6703e6c335bc867ab13fbf4e4c0e63a8d" translate="yes" xml:space="preserve">
          <source>If the node has no element children, then &lt;code&gt;children&lt;/code&gt; is an empty list with a &lt;code&gt;length&lt;/code&gt; of &lt;code&gt;0&lt;/code&gt;.</source>
          <target state="translated">노드에 자식 요소가없는 경우 &lt;code&gt;children&lt;/code&gt; 은 &lt;code&gt;length&lt;/code&gt; 가 &lt;code&gt;0&lt;/code&gt; 인 빈 목록입니다 .</target>
        </trans-unit>
        <trans-unit id="c11a1f8c9de98426e67d2cee172b83870a6a3d0a" translate="yes" xml:space="preserve">
          <source>If the node is a CDATA section, comment, &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/ProcessingInstruction&quot;&gt;processing instruction&lt;/a&gt;, or &lt;a href=&quot;../document/createtextnode&quot;&gt;text node&lt;/a&gt;, &lt;code&gt;textContent&lt;/code&gt; returns the text inside this node (the &lt;a href=&quot;nodevalue&quot;&gt;nodeValue&lt;/a&gt;).</source>
          <target state="translated">노드가 CDATA 섹션, 주석, &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/ProcessingInstruction&quot;&gt;처리 명령&lt;/a&gt; 또는 &lt;a href=&quot;../document/createtextnode&quot;&gt;text node 인&lt;/a&gt; 경우 &lt;code&gt;textContent&lt;/code&gt; 는이 노드 내의 텍스트 ( &lt;a href=&quot;nodevalue&quot;&gt;nodeValue&lt;/a&gt; )를 리턴합니다 .</target>
        </trans-unit>
        <trans-unit id="2a40711e4ba5795c11668d69dbfbaae16b0e8573" translate="yes" xml:space="preserve">
          <source>If the object exists, geolocation services are available. You can test for the presence of geolocation thusly:</source>
          <target state="translated">객체가 존재하면 지리적 위치 서비스를 사용할 수 있습니다. 지리적 위치가 있는지 테스트 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="892b43ba877b01e3c2ce26ad407019eb997ba43d" translate="yes" xml:space="preserve">
          <source>If the object exists, the media capabilities interface is available. You can test for the presence of mediaCapabilities object like so:</source>
          <target state="translated">오브젝트가 존재하면 매체 기능 인터페이스를 사용할 수 있습니다. 다음과 같이 mediaCapabilities 객체가 있는지 테스트 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ddb581029ad6b983bc4b932a2bb70b18e0f15783" translate="yes" xml:space="preserve">
          <source>If the object store with the given name (based on case-sensitive comparison) does not exist in the connected database.</source>
          <target state="translated">주어진 이름 (대소 문자 구분 비교 기준)의 오브젝트 저장소가 연결된 데이터베이스에 존재하지 않는 경우.</target>
        </trans-unit>
        <trans-unit id="2e83a3302f67aa5e258506554f2cf03f3b83a19d" translate="yes" xml:space="preserve">
          <source>If the offer is created successfully, we pass the blob along to the local connection's &lt;a href=&quot;../rtcpeerconnection/setlocaldescription&quot;&gt;&lt;code&gt;RTCPeerConnection.setLocalDescription()&lt;/code&gt;&lt;/a&gt; method. This configures the local end of the connection.</source>
          <target state="translated">오퍼가 성공적으로 작성되면 Blob을 로컬 연결의 &lt;a href=&quot;../rtcpeerconnection/setlocaldescription&quot;&gt; &lt;code&gt;RTCPeerConnection.setLocalDescription()&lt;/code&gt; &lt;/a&gt; 메소드로 전달합니다. 연결의 로컬 끝을 구성합니다.</target>
        </trans-unit>
        <trans-unit id="70eaa76f1b2f017f038db253d4b8d098d1bb6be2" translate="yes" xml:space="preserve">
          <source>If the operation failed for reasons unrelated to the database itself. A failure due to disk IO errors is such an example.</source>
          <target state="translated">데이터베이스 자체와 관련이없는 이유로 조작이 실패한 경우 디스크 IO 오류로 인한 오류가 그러한 예입니다.</target>
        </trans-unit>
        <trans-unit id="04fb279d0c49bab23945c27f8df5188257f5764f" translate="yes" xml:space="preserve">
          <source>If the option is a descendent of a &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/select&quot;&gt;&lt;code&gt;&amp;lt;select&amp;gt;&lt;/code&gt;&lt;/a&gt; element, then this property has the same value as the &lt;code&gt;form&lt;/code&gt; property of the corresponding &lt;a href=&quot;htmlselectelement&quot;&gt;&lt;code&gt;HTMLSelectElement&lt;/code&gt;&lt;/a&gt; object; otherwise, it is &lt;code&gt;null&lt;/code&gt;.</source>
          <target state="translated">옵션이 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/select&quot;&gt; &lt;code&gt;&amp;lt;select&amp;gt;&lt;/code&gt; &lt;/a&gt; 요소 의 자손 인 경우이 속성의 값 은 해당 &lt;a href=&quot;htmlselectelement&quot;&gt; &lt;code&gt;HTMLSelectElement&lt;/code&gt; &lt;/a&gt; 객체 의 &lt;code&gt;form&lt;/code&gt; 속성과 동일 합니다. 그렇지 않은 경우는 &lt;code&gt;null&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="83f08198b8852e745f058290978c5f6b65700fba" translate="yes" xml:space="preserve">
          <source>If the origin is not a scheme/host/port tuple (say you are trying to run it locally, i.e. via &lt;code&gt;file://&lt;/code&gt; URL), &lt;code&gt;origin&lt;/code&gt; will return the string &lt;code&gt;&quot;null&quot;&lt;/code&gt;.</source>
          <target state="translated">원점이 체계 / 호스트 / 포트 튜플이 아닌 경우 (예 &lt;code&gt;file://&lt;/code&gt; URL을 통해 로컬로 실행하려고하면 ) &lt;code&gt;origin&lt;/code&gt; 은 &lt;code&gt;&quot;null&quot;&lt;/code&gt; 문자열을 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="eee99f63de43f0b740de01d514360a3e3c958ca5" translate="yes" xml:space="preserve">
          <source>If the original node has an ID and the clone is to be placed in the same document, the ID of the clone should be modified to be unique. Name attributes may need to be modified also, depending on whether duplicate names are expected.</source>
          <target state="translated">원본 노드에 ID가 있고 복제본을 동일한 문서에 배치하려면 복제본의 ID를 고유하게 수정해야합니다. 중복 이름이 필요한지 여부에 따라 이름 속성도 수정해야 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="972bd1e68819b5923594c810f8b4e3e6a18c8425" translate="yes" xml:space="preserve">
          <source>If the parent &lt;a href=&quot;../mediasource&quot;&gt;&lt;code&gt;MediaSource&lt;/code&gt;&lt;/a&gt; is in its &lt;code&gt;&quot;ended&quot;&lt;/code&gt;&lt;a href=&quot;../mediasource/readystate&quot;&gt;&lt;code&gt;readyState&lt;/code&gt;&lt;/a&gt;, calling &lt;code&gt;changeType()&lt;/code&gt; will transition the media source to the &lt;code&gt;&quot;open&quot;&lt;/code&gt;&lt;code&gt;readyState&lt;/code&gt; and fire a simple event named &lt;code&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Events/sourceopen&quot;&gt;sourceopen&lt;/a&gt;&lt;/code&gt; at the parent media source.</source>
          <target state="translated">부모 &lt;a href=&quot;../mediasource&quot;&gt; &lt;code&gt;MediaSource&lt;/code&gt; &lt;/a&gt; 가 &lt;code&gt;&quot;ended&quot;&lt;/code&gt; &lt;a href=&quot;../mediasource/readystate&quot;&gt; &lt;code&gt;readyState&lt;/code&gt; &lt;/a&gt; 에 &lt;code&gt;changeType()&lt;/code&gt; 을 호출 하면 미디어 소스가 &lt;code&gt;&quot;open&quot;&lt;/code&gt; &lt;code&gt;readyState&lt;/code&gt; 로 전환 되고 부모 미디어 소스에서 &lt;code&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Events/sourceopen&quot;&gt;sourceopen&lt;/a&gt;&lt;/code&gt; 이라는 간단한 이벤트가 발생합니다 .</target>
        </trans-unit>
        <trans-unit id="d1080cad9ba7ff341b57f31fe3f5fea58cd5e828" translate="yes" xml:space="preserve">
          <source>If the payment handler validates the address and determines that the value of &lt;code&gt;country&lt;/code&gt; is invalid, a call to &lt;a href=&quot;../paymentrequestupdateevent/updatewith&quot;&gt;&lt;code&gt;PaymentRequestUpdateEvent.updateWith()&lt;/code&gt;&lt;/a&gt; will be made with a &lt;code&gt;details&lt;/code&gt; object containing a &lt;a href=&quot;../paymentdetailsupdate/shippingaddresserrors&quot;&gt;&lt;code&gt;shippingAddressErrors&lt;/code&gt;&lt;/a&gt; field. That field contains an &lt;a href=&quot;../addresserrors&quot;&gt;&lt;code&gt;AddressErrors&lt;/code&gt;&lt;/a&gt;-compliant object whose &lt;a href=&quot;../addresserrors/country&quot;&gt;&lt;code&gt;country&lt;/code&gt;&lt;/a&gt; property is a string indicating the validation error that occurred and, if possible, suggests how to fix it.</source>
          <target state="translated">지불 핸들러가 주소를 확인하고의 값을 결정하는 경우 &lt;code&gt;country&lt;/code&gt; 무효로 호출 &lt;a href=&quot;../paymentrequestupdateevent/updatewith&quot;&gt; &lt;code&gt;PaymentRequestUpdateEvent.updateWith()&lt;/code&gt; &lt;/a&gt; 로 이루어집니다 &lt;code&gt;details&lt;/code&gt; 포함하는 객체 &lt;a href=&quot;../paymentdetailsupdate/shippingaddresserrors&quot;&gt; &lt;code&gt;shippingAddressErrors&lt;/code&gt; 의&lt;/a&gt; 필드. 해당 필드에는 &lt;a href=&quot;../addresserrors/country&quot;&gt; &lt;code&gt;country&lt;/code&gt; &lt;/a&gt; 속성이 발생한 유효성 검사 오류를 나타내는 문자열 인 가능한 &lt;a href=&quot;../addresserrors&quot;&gt; &lt;code&gt;AddressErrors&lt;/code&gt; &lt;/a&gt; 호환 개체가 포함 되며 가능한 경우이를 수정하는 방법을 제안합니다.</target>
        </trans-unit>
        <trans-unit id="ece7d055709319a98ae103f80d660b79ff7e887d" translate="yes" xml:space="preserve">
          <source>If the position data changes (either by device movement or if more accurate geo information arrives), you can set up a callback function that is called with that updated position information. This is done using the &lt;a href=&quot;geolocation/watchposition&quot;&gt;&lt;code&gt;watchPosition()&lt;/code&gt;&lt;/a&gt; function, which has the same input parameters as &lt;a href=&quot;geolocation/getcurrentposition&quot;&gt;&lt;code&gt;getCurrentPosition()&lt;/code&gt;&lt;/a&gt;. The callback function is called multiple times, allowing the browser to either update your location as you move, or provide a more accurate location as different techniques are used to geolocate you. The error callback function, which is optional just as it is for &lt;a href=&quot;geolocation/getcurrentposition&quot;&gt;&lt;code&gt;getCurrentPosition()&lt;/code&gt;&lt;/a&gt;, can be called repeatedly.</source>
          <target state="translated">위치 데이터가 변경되는 경우 (장치 이동 또는보다 정확한 지리 정보가 도착하는 경우) 업데이트 된 위치 정보로 호출되는 콜백 기능을 설정할 수 있습니다. &lt;a href=&quot;geolocation/getcurrentposition&quot;&gt; &lt;code&gt;getCurrentPosition()&lt;/code&gt; &lt;/a&gt; 과 동일한 입력 매개 변수를 가진 &lt;a href=&quot;geolocation/watchposition&quot;&gt; &lt;code&gt;watchPosition()&lt;/code&gt; &lt;/a&gt; 함수를 사용하여 수행됩니다 . 콜백 기능은 여러 번 호출되므로 브라우저가 이동함에 따라 위치를 업데이트하거나 다른 기술을 사용하여 위치를 파악함에 따라보다 정확한 위치를 제공 할 수 있습니다. &lt;a href=&quot;geolocation/getcurrentposition&quot;&gt; &lt;code&gt;getCurrentPosition()&lt;/code&gt; &lt;/a&gt; 경우 와 마찬가지로 선택적 오류 콜백 함수를 반복해서 호출 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d48e90f87ce85801906da2d7e4c6bda4c8b39317" translate="yes" xml:space="preserve">
          <source>If the pressed key has a printed representation, the returned value is a non-empty Unicode character string containing the printable representation of the key.</source>
          <target state="translated">눌린 키에 인쇄 된 표현이있는 경우, 리턴 가능한 값은 인쇄 가능한 키의 표현을 포함하는 비어 있지 않은 유니 코드 문자열입니다.</target>
        </trans-unit>
        <trans-unit id="3ce9fa358346bc7e0ab71760bafb891312d6ba44" translate="yes" xml:space="preserve">
          <source>If the pressed key is a control or special character, the returned value is one of the &lt;a href=&quot;https://developer.mozilla.org/docs/Web/API/KeyboardEvent/key/Key_Values&quot;&gt;pre-defined key values&lt;/a&gt;.</source>
          <target state="translated">누른 키가 제어 또는 특수 문자 인 경우 리턴 값은 &lt;a href=&quot;https://developer.mozilla.org/docs/Web/API/KeyboardEvent/key/Key_Values&quot;&gt;사전 정의 된 키 값&lt;/a&gt; 중 하나입니다 .</target>
        </trans-unit>
        <trans-unit id="3cc4408f3adeed862f9606e442d4e2a83489965a" translate="yes" xml:space="preserve">
          <source>If the promise gets resolved and a user gesture event was being processed when the function was originally called, the resolve handler will run as if a user gesture was being processed, so it will be able to call APIs that require user activation.</source>
          <target state="translated">약속이 해결되고 함수가 원래 호출 될 때 사용자 제스처 이벤트가 처리되고있는 경우, 확인 핸들러는 사용자 제스처가 처리되는 것처럼 실행되므로 사용자 활성화가 필요한 API를 호출 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2027cec69ba6b9e9f3e3e51a83ca942a01011b54" translate="yes" xml:space="preserve">
          <source>If the promise gets resolved, the resolve handler will run as if a user gesture was being processed, so it will be able to call APIs that require user activation.</source>
          <target state="translated">약속이 해결되면 사용자 제스처가 처리되는 것처럼 확인 핸들러가 실행되므로 사용자 활성화가 필요한 API를 호출 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ac2f8e6cc729bbf46b715af579773d52876bcd3e" translate="yes" xml:space="preserve">
          <source>If the promise is rejected, the install fails, and the worker won&amp;rsquo;t do anything. This is ok, as you can fix your code and then try again the next time registration occurs.</source>
          <target state="translated">약속이 거부되면 설치가 실패하고 작업자는 아무것도하지 않습니다. 코드를 수정 한 후 다음에 등록 할 때 다시 시도 할 수 있으므로 괜찮습니다.</target>
        </trans-unit>
        <trans-unit id="0ae4ad494c7f8e07e1642802e461817ee83a5649" translate="yes" xml:space="preserve">
          <source>If the promise returned by &lt;code&gt;getUserMedia()&lt;/code&gt; concludes in a failure, our &lt;code&gt;handleGetUserMediaError()&lt;/code&gt; function performs.</source>
          <target state="translated">&lt;code&gt;getUserMedia()&lt;/code&gt; 의해 반환 된 약속 이 실패한 것으로 판단되면 &lt;code&gt;handleGetUserMediaError()&lt;/code&gt; 함수가 수행됩니다.</target>
        </trans-unit>
        <trans-unit id="ebf5b44b29e580ea2a2291e153b572b13e34c2f6" translate="yes" xml:space="preserve">
          <source>If the provided URL is not valid, a &lt;a href=&quot;../domexception&quot;&gt;&lt;code&gt;DOMException&lt;/code&gt;&lt;/a&gt; of the &lt;code&gt;SYNTAX_ERROR&lt;/code&gt; type is thrown.</source>
          <target state="translated">제공된 URL이 유효하지 않은 경우 &lt;code&gt;SYNTAX_ERROR&lt;/code&gt; 유형 의 &lt;a href=&quot;../domexception&quot;&gt; &lt;code&gt;DOMException&lt;/code&gt; &lt;/a&gt; 이 발생합니다.</target>
        </trans-unit>
        <trans-unit id="f1fcee47c0e6d2665926a8eac16be8c95ebaa2ee" translate="yes" xml:space="preserve">
          <source>If the provided name is not a &lt;a href=&quot;https://html.spec.whatwg.org/multipage/custom-elements.html#valid-custom-element-name&quot;&gt;valid custom element name&lt;/a&gt;, the promise rejects with a &lt;code&gt;SyntaxError&lt;/code&gt;.</source>
          <target state="translated">제공된 이름이 &lt;a href=&quot;https://html.spec.whatwg.org/multipage/custom-elements.html#valid-custom-element-name&quot;&gt;유효한 사용자 정의 요소&lt;/a&gt; 이름이 아닌 경우 약속은 &lt;code&gt;SyntaxError&lt;/code&gt; 와 함께 거부됩니다 .</target>
        </trans-unit>
        <trans-unit id="fe9a98db4951f2dd6726afa0ca84f2e174417815" translate="yes" xml:space="preserve">
          <source>If the reference node is &lt;code&gt;null&lt;/code&gt;, the specified node is added to the end of the list of children of the specified parent node.</source>
          <target state="translated">참조 노드가 &lt;code&gt;null&lt;/code&gt; 인 경우 지정된 노드는 지정된 부모 노드의 자식 목록 끝에 추가됩니다.</target>
        </trans-unit>
        <trans-unit id="acf2e311fa78b0d7bcada7aac3c4807d02d823ab" translate="yes" xml:space="preserve">
          <source>If the removed Attribute has a default value it is immediately replaced. The replacing attribute has the same namespace URI and local name, as well as the original prefix, when applicable.</source>
          <target state="translated">제거 된 속성에 기본값이 있으면 즉시 대체됩니다. 대체 속성은 적용 가능한 경우 원래 접두사와 동일한 네임 스페이스 URI 및 로컬 이름을 갖습니다.</target>
        </trans-unit>
        <trans-unit id="7fc562a0b6e22d8fe8ce6c85e1e2075e480b7593" translate="yes" xml:space="preserve">
          <source>If the request succeeds.</source>
          <target state="translated">요청이 성공한 경우</target>
        </trans-unit>
        <trans-unit id="4126c6dca65e5c94e101f03be97518ce321170af" translate="yes" xml:space="preserve">
          <source>If the requested header doesn't exist in the &lt;code&gt;Headers&lt;/code&gt; object, it returns an empty array.</source>
          <target state="translated">요청한 헤더가 &lt;code&gt;Headers&lt;/code&gt; 객체 에 없으면 빈 배열을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="0464f77cdfb670e06af1c08691d0ff125b5c6c1f" translate="yes" xml:space="preserve">
          <source>If the requested object store is not in this transaction's scope.</source>
          <target state="translated">요청 된 오브젝트 저장소가이 트랜잭션 범위에없는 경우</target>
        </trans-unit>
        <trans-unit id="2d0198d53270ee5f8bd9fb1bbaddfc70d3695f25" translate="yes" xml:space="preserve">
          <source>If the requested type is not &lt;code&gt;image/png&lt;/code&gt;, but the returned value starts with &lt;code&gt;data:image/png&lt;/code&gt;, then the requested type is not supported.</source>
          <target state="translated">요청 된 유형이 &lt;code&gt;image/png&lt;/code&gt; 가 아니지만 반환 된 값이 &lt;code&gt;data:image/png&lt;/code&gt; 로 시작하면 요청 된 유형이 지원되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="a227173f477eeff81ba0214e0b24cbff25cc2add" translate="yes" xml:space="preserve">
          <source>If the resource is fetched from a local cache, or if it is a cross-origin resource, this property returns zero.</source>
          <target state="translated">자원이 로컬 캐시에서 페치되거나 교차 출처 자원 인 경우이 특성은 0을 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="69af8e04edb9605338375d39006ccb5fcf36cfe9" translate="yes" xml:space="preserve">
          <source>If the resource is fetched over a secure connection, a &lt;a href=&quot;../domhighrestimestamp&quot;&gt;&lt;code&gt;DOMHighResTimeStamp&lt;/code&gt;&lt;/a&gt; immediately before the browser starts the handshake process to secure the current connection. If a secure connection is not used, this property returns zero.</source>
          <target state="translated">보안 연결을 통해 리소스를 가져 오는 경우 브라우저가 핸드 셰이크 프로세스를 시작하기 직전 에 &lt;a href=&quot;../domhighrestimestamp&quot;&gt; &lt;code&gt;DOMHighResTimeStamp&lt;/code&gt; &lt;/a&gt; 가 현재 연결을 보호합니다. 보안 연결을 사용하지 않으면이 속성은 0을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="88ad4c5924c1aa59e53eabc35721ce6900686e2a" translate="yes" xml:space="preserve">
          <source>If the resource is retrieved from an application cache or a local resource, it must return the size of the payload body before removing any applied content-codings.</source>
          <target state="translated">응용 프로그램 캐시 또는 로컬 자원에서 자원을 검색하는 경우 적용된 컨텐츠 코딩을 제거하기 전에 페이로드 본문의 크기를 리턴해야합니다.</target>
        </trans-unit>
        <trans-unit id="dd0a0ee1015f1743713c72ad7844f695b152b66e" translate="yes" xml:space="preserve">
          <source>If the resources isn't in the cache, it is requested from the network.</source>
          <target state="translated">리소스가 캐시에 없으면 네트워크에서 요청됩니다.</target>
        </trans-unit>
        <trans-unit id="88e953df958a87ba27e1107216732cf10b6e40ef" translate="yes" xml:space="preserve">
          <source>If the result of the algorithm is &lt;code&gt;&quot;Prohibits Mixed Security Contexts&quot;&lt;/code&gt; and the &lt;a href=&quot;https://www.w3.org/TR/presentation-api/#dfn-presentation-request-urls&quot;&gt;presentation request URL&lt;/a&gt; of &lt;var&gt;presentationRequest&lt;/var&gt; is an &lt;a href=&quot;https://www.w3.org/TR/presentation-api/#dfn-a-priori-unauthenticated-url&quot;&gt;a priori unauthenticated URL&lt;/a&gt;, then return a &lt;a href=&quot;https://www.w3.org/TR/presentation-api/#dfn-promise&quot;&gt;Promise&lt;/a&gt; rejected with a &lt;a href=&quot;https://www.w3.org/TR/presentation-api/#dfn-securityerror&quot;&gt;&lt;code&gt;SecurityError&lt;/code&gt;&lt;/a&gt; and abort these steps.</source>
          <target state="translated">알고리즘의 결과 인 경우 &lt;code&gt;&quot;Prohibits Mixed Security Contexts&quot;&lt;/code&gt; 하고 &lt;a href=&quot;https://www.w3.org/TR/presentation-api/#dfn-presentation-request-urls&quot;&gt;프리젠 테이션 요청 URL&lt;/a&gt; 의 &lt;var&gt;presentationRequest&lt;/var&gt; 이 입니다 &lt;a href=&quot;https://www.w3.org/TR/presentation-api/#dfn-a-priori-unauthenticated-url&quot;&gt;선험적 인증되지 않은 URL&lt;/a&gt; , 다음 반환 &lt;a href=&quot;https://www.w3.org/TR/presentation-api/#dfn-promise&quot;&gt;약속이&lt;/a&gt; 으로 거부 &lt;a href=&quot;https://www.w3.org/TR/presentation-api/#dfn-securityerror&quot;&gt; &lt;code&gt;SecurityError&lt;/code&gt; &lt;/a&gt; 다음 단계 중단합니다.</target>
        </trans-unit>
        <trans-unit id="553d54b63c45f4a8f7353d356bfa0c62ac9b0aeb" translate="yes" xml:space="preserve">
          <source>If the returned promise is rejected, one of the following exceptions is provided to the rejection handler:</source>
          <target state="translated">리턴 된 약속이 거부되면 다음 예외 중 하나가 거부 핸들러에 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="5df483121a201de732f5f193d0e2fb7961dd2296" translate="yes" xml:space="preserve">
          <source>If the same &lt;code&gt;MutationObserver&lt;/code&gt; is not already in use on the target, then the existing observers are left alone and the new one is added.</source>
          <target state="translated">동일한 &lt;code&gt;MutationObserver&lt;/code&gt; 가 대상에서 아직 사용 중이 아닌 경우 기존 옵저버는 그대로두고 새 옵저버가 추가됩니다.</target>
        </trans-unit>
        <trans-unit id="5d1dd5d6752805c823a56964d9a1d2d0a192965a" translate="yes" xml:space="preserve">
          <source>If the script's &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/global_object&quot;&gt;global object&lt;/a&gt; is a &lt;a href=&quot;window&quot;&gt;&lt;code&gt;Window&lt;/code&gt;&lt;/a&gt;, the time origin is determined as follows:</source>
          <target state="translated">스크립트의 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/global_object&quot;&gt;전역 객체&lt;/a&gt; 가 &lt;a href=&quot;window&quot;&gt; &lt;code&gt;Window&lt;/code&gt; &lt;/a&gt; 인 경우 시간 원점은 다음과 같이 결정됩니다.</target>
        </trans-unit>
        <trans-unit id="261f92f3456fe3fecbdf5f6073d0b039553a2e2e" translate="yes" xml:space="preserve">
          <source>If the script's global object is a &lt;a href=&quot;workerglobalscope&quot;&gt;&lt;code&gt;WorkerGlobalScope&lt;/code&gt;&lt;/a&gt; (that is, the script is running as a web worker), the time origin is the moment at which the worker was created.</source>
          <target state="translated">스크립트의 전역 객체가 &lt;a href=&quot;workerglobalscope&quot;&gt; &lt;code&gt;WorkerGlobalScope&lt;/code&gt; &lt;/a&gt; (즉, 스크립트가 웹 워커로 실행 중) 인 경우 시간 원점은 작업자가 생성 된 순간입니다.</target>
        </trans-unit>
        <trans-unit id="7bc4fd98d27a89d44707ceba4d020981d032b680" translate="yes" xml:space="preserve">
          <source>If the second byte minus 128 is between 0 and 125, this is the length of the message. If it is 126, the following 2 bytes (16-bit unsigned integer), if 127, the following 8 bytes (64-bit unsigned integer, the most significant bit MUST be 0) are the length.</source>
          <target state="translated">두 번째 바이트에서 128을 뺀 값이 0과 125 사이 인 경우 메시지 길이입니다. 126 인 경우 다음 2 바이트 (16 비트 부호없는 정수), 127 인 경우 다음 8 바이트 (64 비트 부호없는 정수, 최상위 비트는 0)가 길이입니다.</target>
        </trans-unit>
        <trans-unit id="1506ec3c3109e55c992b50e3bc4bb8cb18bcb7b2" translate="yes" xml:space="preserve">
          <source>If the selector matches an ID and this ID is erroneously used several times in the document, it returns the first matching element.</source>
          <target state="translated">선택기가 ID와 일치하고이 ID가 문서에서 여러 번 잘못 사용 된 경우 첫 번째 일치 요소를 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="62f0071f198f2aa75236fc70b18c3769d9468ff3" translate="yes" xml:space="preserve">
          <source>If the selectors specified in parameter are invalid a &lt;a href=&quot;../domexception&quot;&gt;&lt;code&gt;DOMException&lt;/code&gt;&lt;/a&gt; with a &lt;code&gt;SYNTAX_ERR&lt;/code&gt; value is raised.</source>
          <target state="translated">매개 변수에 지정된 선택기가 유효하지 않은 경우 &lt;code&gt;SYNTAX_ERR&lt;/code&gt; 값을 가진 &lt;a href=&quot;../domexception&quot;&gt; &lt;code&gt;DOMException&lt;/code&gt; &lt;/a&gt; 이 발생합니다.</target>
        </trans-unit>
        <trans-unit id="f07a7edc640e573f5da8eef1ed81ea139879d91a" translate="yes" xml:space="preserve">
          <source>If the server doesn't specify the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Content-Type&quot;&gt;&lt;code&gt;Content-Type&lt;/code&gt;&lt;/a&gt; header as &lt;code&gt;&quot;text/xml&quot;&lt;/code&gt; or &lt;code&gt;&quot;application/xml&quot;&lt;/code&gt;, you can use &lt;a href=&quot;overridemimetype&quot;&gt;&lt;code&gt;XMLHttpRequest.overrideMimeType()&lt;/code&gt;&lt;/a&gt; to force &lt;code&gt;XMLHttpRequest&lt;/code&gt; to parse it as XML anyway.</source>
          <target state="translated">서버가 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Content-Type&quot;&gt; &lt;code&gt;Content-Type&lt;/code&gt; &lt;/a&gt; 헤더를 &lt;code&gt;&quot;text/xml&quot;&lt;/code&gt; 또는 &lt;code&gt;&quot;application/xml&quot;&lt;/code&gt; 로 지정하지 않으면 &lt;a href=&quot;overridemimetype&quot;&gt; &lt;code&gt;XMLHttpRequest.overrideMimeType()&lt;/code&gt; &lt;/a&gt; 을 사용하여 XMLHttpRequest &lt;code&gt;XMLHttpRequest&lt;/code&gt; 를 XML로 구문 분석 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="d34e0a20793454ed450c90374405951a8a44ea62" translate="yes" xml:space="preserve">
          <source>If the server doesn't want to use any subprotocol, &lt;code&gt;Sec-WebSocket-Protocol&lt;/code&gt;. Sending a blank header is incorrect.</source>
          <target state="translated">서버가 하위 프로토콜을 사용하지 않으려면 &lt;code&gt;Sec-WebSocket-Protocol&lt;/code&gt; 을 사용하십시오 . 빈 머리글 보내기가 잘못되었습니다.</target>
        </trans-unit>
        <trans-unit id="a074d0876df80fe9557f8257f04788e582b0d4a2" translate="yes" xml:space="preserve">
          <source>If the server response doesn't explicitly specify a status text, &lt;code&gt;statusText&lt;/code&gt; will assume the default value &quot;OK&quot;.</source>
          <target state="translated">서버 응답이 명시 적으로 상태 텍스트를 지정하지 않으면 &lt;code&gt;statusText&lt;/code&gt; 는 기본값 &quot;OK&quot;로 가정합니다.</target>
        </trans-unit>
        <trans-unit id="027b6e08ec84d8475650273deab26f17f7df68a2" translate="yes" xml:space="preserve">
          <source>If the shader was loaded and successfully compiled, the compiled shader is returned to the caller.</source>
          <target state="translated">셰이더가로드되어 성공적으로 컴파일 된 경우 컴파일 된 셰이더가 호출자에게 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="f891387e39401d47d4961f389ee9b98e370e6f30" translate="yes" xml:space="preserve">
          <source>If the site or app has the &lt;code&gt;&quot;persistent-storage&quot;&lt;/code&gt; feature permission, it can use the &lt;a href=&quot;storagemanager/persist&quot;&gt;&lt;code&gt;StorageManager.persist()&lt;/code&gt;&lt;/a&gt; method to request that its box be made persistent. It's also possible for the user agent to decide to make the site's storage unit persistent due to usage characteristics or other metrics. The &lt;code&gt;&quot;persistent-storage&quot;&lt;/code&gt; feature's permission-related flags, algorithms, and types are all set to the standard defaults for a permission, except that the &lt;strong&gt;permission state&lt;/strong&gt; must be the same across the entire origin, and that if the permission state isn't &lt;code&gt;&quot;granted&quot;&lt;/code&gt; (meaning that for whatever reason, access to the persistent storage feature was denied), the origin's site storage unit's box mode is always &lt;code&gt;&quot;best-effort&quot;&lt;/code&gt;.</source>
          <target state="translated">사이트 또는 앱에 &lt;code&gt;&quot;persistent-storage&quot;&lt;/code&gt; 기능 권한이있는 경우 &lt;a href=&quot;storagemanager/persist&quot;&gt; &lt;code&gt;StorageManager.persist()&lt;/code&gt; &lt;/a&gt; 메소드를 사용하여 상자의 지속성을 요청할 수 있습니다. 사용자 에이전트가 사용 특성 또는 기타 메트릭으로 인해 사이트의 저장 장치를 지속하도록 결정할 수도 있습니다. &lt;code&gt;&quot;persistent-storage&quot;&lt;/code&gt; 기능의 허가 관련 플래그, 알고리즘 및 유형은 것을 제외하고, 권한에 대한 표준 기본값으로 모든 설정되어 &lt;strong&gt;허가 상태가&lt;/strong&gt; 전체의 기원에서 동일해야하며, 허가 상태는 아니라고 경우 &lt;code&gt;&quot;granted&quot;&lt;/code&gt; (어떤 이유로 든 영구 저장 기능에 대한 액세스가 거부되었음을 의미)박스 모드는 항상 &lt;code&gt;&quot;best-effort&quot;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d6511a5e1a2a68769c1c067bf11ee106387722c5" translate="yes" xml:space="preserve">
          <source>If the source of the media is a &lt;a href=&quot;../mediastream&quot;&gt;&lt;code&gt;MediaStream&lt;/code&gt;&lt;/a&gt;, this value is &lt;code&gt;true&lt;/code&gt; if the value of the stream's &lt;a href=&quot;../mediastream/active&quot;&gt;&lt;code&gt;active&lt;/code&gt;&lt;/a&gt; property is &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">미디어의 소스가있는 경우 &lt;a href=&quot;../mediastream&quot;&gt; &lt;code&gt;MediaStream&lt;/code&gt; &lt;/a&gt; ,이 값은 &lt;code&gt;true&lt;/code&gt; 스트림의 값 경우 &lt;a href=&quot;../mediastream/active&quot;&gt; &lt;code&gt;active&lt;/code&gt; &lt;/a&gt; 특성은 &lt;code&gt;false&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c3a4644597b5f032bfcb017dc906f04a3e6a400b" translate="yes" xml:space="preserve">
          <source>If the specified &lt;code&gt;selector&lt;/code&gt; matches an ID that is incorrectly used more than once in the document, the first element with that ID is returned.</source>
          <target state="translated">지정된 &lt;code&gt;selector&lt;/code&gt; 가 문서에서 두 번 이상 잘못 사용 된 ID와 일치하면 해당 ID를 가진 첫 번째 요소가 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="604168fbf6bac17953ab3c90392e9afd9a0066b4" translate="yes" xml:space="preserve">
          <source>If the specified header already exists, &lt;code&gt;append()&lt;/code&gt; will change its value to the specified value. If the specified header already exists and accepts multiple values, &lt;code&gt;append()&lt;/code&gt; will append the new value to the end of the value set:</source>
          <target state="translated">지정된 헤더가 이미 존재하면 &lt;code&gt;append()&lt;/code&gt; 는 해당 값을 지정된 값으로 변경합니다. 지정된 헤더가 이미 존재하고 여러 값을 허용하는 경우 &lt;code&gt;append()&lt;/code&gt; 는 값 세트의 끝에 새 값을 추가합니다.</target>
        </trans-unit>
        <trans-unit id="a0fc2b539365980e5c4afe513d5b82474a971851" translate="yes" xml:space="preserve">
          <source>If the specified header does not already exist, &lt;code&gt;set()&lt;/code&gt; will create it and set its value to the specified value. If the specified header does already exist and does accept multiple values, &lt;code&gt;set()&lt;/code&gt; will overwrite the existing value with the new one:</source>
          <target state="translated">지정된 헤더가 존재하지 않는 경우, &lt;code&gt;set()&lt;/code&gt; 는 헤더 를 작성하고 그 값을 지정된 값으로 설정합니다. 지정된 헤더가 이미 존재하고 여러 값을 허용하는 경우 &lt;code&gt;set()&lt;/code&gt; 은 기존 값을 새 값으로 덮어 씁니다.</target>
        </trans-unit>
        <trans-unit id="87272e15bcaa2508bc2f67930773c4a3896f989d" translate="yes" xml:space="preserve">
          <source>If the specified point is outside the visible bounds of the document or either coordinate is negative, the result is &lt;code&gt;null&lt;/code&gt;.</source>
          <target state="translated">지정된 점이 문서의 가시 범위를 벗어나거나 좌표가 음수이면 결과는 &lt;code&gt;null&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="d707534b6e9a527cd45a11d3edd6f5f02f440cff" translate="yes" xml:space="preserve">
          <source>If the specified track is already in the stream's track set, this method has no effect.</source>
          <target state="translated">지정된 트랙이 이미 스트림의 트랙 세트에 있으면이 방법은 효과가 없습니다.</target>
        </trans-unit>
        <trans-unit id="0d476936db3635d00305416d788fe40fe176db1b" translate="yes" xml:space="preserve">
          <source>If the state changes to &lt;code&gt;&quot;failed&quot;&lt;/code&gt;, a new offer is created with &lt;code&gt;iceRestart&lt;/code&gt; set to &lt;code&gt;true&lt;/code&gt;, then that offer is set as the new local description for the connection. After that, the offer is sent to the server by calling a custom function &lt;code&gt;sendOfferToServer()&lt;/code&gt;.</source>
          <target state="translated">상태가 &lt;code&gt;&quot;failed&quot;&lt;/code&gt; 변경되면 &lt;code&gt;iceRestart&lt;/code&gt; 가 &lt;code&gt;true&lt;/code&gt; 로 설정된 새 오퍼가 작성되고 해당 오퍼는 연결에 대한 새 로컬 설명으로 설정됩니다. 그런 다음 사용자 정의 함수 &lt;code&gt;sendOfferToServer()&lt;/code&gt; 호출하여 오퍼가 서버로 전송됩니다 .</target>
        </trans-unit>
        <trans-unit id="e2d4bb00728a066afd9fbc6930f6444a3eb4ce69" translate="yes" xml:space="preserve">
          <source>If the state has changed to &quot;closed&quot;, the opposite set of actions occurs: the input box and &quot;Send&quot; button are disabled, the &quot;Connect&quot; button is enabled so that the user can open a new connection if they wish to do so, and the &quot;Disconnect&quot; button is disabled, since it's not useful when no connection exists.</source>
          <target state="translated">상태가 &quot;폐쇄 됨&quot;으로 변경된 경우 반대 조치 세트가 발생합니다. 입력 상자 및 &quot;보내기&quot;단추가 비활성화되어 있으면 &quot;연결&quot;단추가 활성화되어 사용자가 원하는 경우 새 연결을 열 수 있습니다. 연결이 없으면 유용하지 않으므로 '연결 끊기'버튼이 사용 중지되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="31fae4dd9fea196d4a06676a05510ac1a4c5de23" translate="yes" xml:space="preserve">
          <source>If the stream becomes closed, the promise will be fulfilled with an object of the form &lt;code&gt;{ value: undefined, done: true }&lt;/code&gt;.</source>
          <target state="translated">스트림이 닫히면 &lt;code&gt;{ value: undefined, done: true }&lt;/code&gt; 형식의 객체로 약속이 이행됩니다 .</target>
        </trans-unit>
        <trans-unit id="89670c469f906abefda75ed9ed50cbf526ae2d1f" translate="yes" xml:space="preserve">
          <source>If the stream becomes closed, the promise will be fulfilled with an object of the form { value: undefined, done: true }.</source>
          <target state="translated">스트림이 닫히면 {value : undefined, done : true} 형식의 개체로 약속이 이행됩니다.</target>
        </trans-unit>
        <trans-unit id="566441170e8953387f5f17ff68b8ac5d1164ed03" translate="yes" xml:space="preserve">
          <source>If the stream becomes errored, the promise will be rejected with the relevant error.</source>
          <target state="translated">스트림에 오류가 발생하면 관련 오류와 함께 약속이 거부됩니다.</target>
        </trans-unit>
        <trans-unit id="2fe36e08248bf6396082621376d5acf9d2e8d2ee" translate="yes" xml:space="preserve">
          <source>If the string is empty, the browser will create a new window every time (this behaviour doesn't work when the string is replaced with NULL).</source>
          <target state="translated">문자열이 비어 있으면 브라우저는 매번 새 창을 만듭니다 (문자열이 NULL로 바뀌면이 동작이 작동하지 않습니다).</target>
        </trans-unit>
        <trans-unit id="0312db640c541921da0beb4a785a653be94cdbaf" translate="yes" xml:space="preserve">
          <source>If the style sheet is a linked style sheet, the value of its attribute is its location. For inline style sheets, the value of this attribute is &lt;code&gt;NULL&lt;/code&gt;.</source>
          <target state="translated">스타일 시트가 연결된 스타일 시트 인 경우 해당 속성 값은 해당 위치입니다. 인라인 스타일 시트의 경우이 속성의 값은 &lt;code&gt;NULL&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="25f1541f97accdfcf2a961808cbb70fc3467e056" translate="yes" xml:space="preserve">
          <source>If the sub frame doesn't have the token &lt;code&gt;allow-storage-access-by-user-activation&lt;/code&gt;, reject.</source>
          <target state="translated">서브 프레임에 토큰 &lt;code&gt;allow-storage-access-by-user-activation&lt;/code&gt; 토큰이 없으면 거부하십시오.</target>
        </trans-unit>
        <trans-unit id="52386d7b1c36cb9280d9bccb3b6735923c450b25" translate="yes" xml:space="preserve">
          <source>If the sub frame is not sandboxed, skip to step 7.</source>
          <target state="translated">서브 프레임이 샌드 박스되지 않은 경우 7 단계로 건너 뜁니다.</target>
        </trans-unit>
        <trans-unit id="6671cf3f979f917ea98fec33ed677572b43a070c" translate="yes" xml:space="preserve">
          <source>If the sub frame's origin is equal to the main frame's, resolve.</source>
          <target state="translated">서브 프레임의 원점이 메인 프레임의 원점과 같으면 해결하십시오.</target>
        </trans-unit>
        <trans-unit id="466bc6e304d2fc285f629064198042f822a1f5f6" translate="yes" xml:space="preserve">
          <source>If the sub frame's parent frame is not the top frame, reject.</source>
          <target state="translated">서브 프레임의 상위 프레임이 최상위 프레임이 아닌 경우 거부하십시오.</target>
        </trans-unit>
        <trans-unit id="cc0ffe693685e996f2472ce60213272d8606997f" translate="yes" xml:space="preserve">
          <source>If the transition is removed from its target node before the transition completes execution, the &lt;code&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Events/transitionend&quot;&gt;transitionend&lt;/a&gt;&lt;/code&gt; event won't be generated. One way this can happen is by changing the value of the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/CSS/transition-property&quot;&gt;&lt;code&gt;transition-property&lt;/code&gt;&lt;/a&gt; attribute which applies to the target. Another is if the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/CSS/display&quot;&gt;&lt;code&gt;display&lt;/code&gt;&lt;/a&gt; attribute is set to &lt;code&gt;&quot;none&quot;&lt;/code&gt;.</source>
          <target state="translated">전환이 실행을 완료하기 전에 대상 노드에서 전환이 제거되면 &lt;code&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Events/transitionend&quot;&gt;transitionend&lt;/a&gt;&lt;/code&gt; 이벤트가 생성되지 않습니다. 이것이 일어날 수있는 한 가지 방법 은 대상에 적용되는 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/CSS/transition-property&quot;&gt; &lt;code&gt;transition-property&lt;/code&gt; &lt;/a&gt; 속성 의 값을 변경하는 것입니다 . 다른 하나는 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/CSS/display&quot;&gt; &lt;code&gt;display&lt;/code&gt; &lt;/a&gt; 속성이 &lt;code&gt;&quot;none&quot;&lt;/code&gt; 으로 설정된 경우 입니다.</target>
        </trans-unit>
        <trans-unit id="a59a3addeb062afb59c0c7c031435da10f14e4dd" translate="yes" xml:space="preserve">
          <source>If the transport was closed with an error, the &lt;code&gt;RTCDataChannel&lt;/code&gt; is sent a &lt;code&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Events/NetworkError&quot;&gt;NetworkError&lt;/a&gt;&lt;/code&gt; event.</source>
          <target state="translated">전송이 오류와 함께 닫히면 &lt;code&gt;RTCDataChannel&lt;/code&gt; 에 &lt;code&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Events/NetworkError&quot;&gt;NetworkError&lt;/a&gt;&lt;/code&gt; 이벤트 가 전송 됩니다.</target>
        </trans-unit>
        <trans-unit id="1a2a8917a40ba9bd922f362c890e9e6d0cd33356" translate="yes" xml:space="preserve">
          <source>If the underlying element collection contains radio buttons, the &lt;code&gt;RadioNodeList.value&lt;/code&gt; property represents the checked radio button. On retrieving the &lt;code&gt;value&lt;/code&gt; property, the &lt;code&gt;value&lt;/code&gt; of the currently &lt;code&gt;checked&lt;/code&gt; radio button is returned as a string. If the collection does not contain any radio buttons or none of the radio buttons in the collection is in &lt;code&gt;checked&lt;/code&gt; state, the empty string is returned. On setting the &lt;code&gt;value&lt;/code&gt; property, the first radio button input element whose &lt;code&gt;value&lt;/code&gt; property is equal to the new value will be set to &lt;code&gt;checked&lt;/code&gt;.</source>
          <target state="translated">기본 요소 컬렉션에 라디오 버튼이 포함 된 경우 &lt;code&gt;RadioNodeList.value&lt;/code&gt; 속성은 선택된 라디오 버튼을 나타냅니다. &lt;code&gt;value&lt;/code&gt; 속성을 검색하면 현재 &lt;code&gt;checked&lt;/code&gt; 라디오 버튼 의 &lt;code&gt;value&lt;/code&gt; 이 문자열로 반환됩니다. 컬렉션에 라디오 버튼이 없거나 컬렉션의 라디오 버튼이 &lt;code&gt;checked&lt;/code&gt; 상태 가 아니면 빈 문자열이 반환됩니다. 설정에 &lt;code&gt;value&lt;/code&gt; 속성, 그 첫 번째 라디오 버튼 입력 요소 &lt;code&gt;value&lt;/code&gt; 속성 새로운 값과 동일한 설정 될 것이다 &lt;code&gt;checked&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="46bd3127e1708ce32cf539d0c2a7bdea2319c655" translate="yes" xml:space="preserve">
          <source>If the underlying element collection contains radio buttons, the &lt;code&gt;value&lt;/code&gt; property represents the checked radio button. On retrieving the &lt;code&gt;value&lt;/code&gt; property, the &lt;code&gt;value&lt;/code&gt; of the currently &lt;code&gt;checked&lt;/code&gt; radio button is returned as a string. If the collection does not contain any radio buttons or none of the radio buttons in the collection is in &lt;code&gt;checked&lt;/code&gt; state, the empty string is returned. On setting the &lt;code&gt;value&lt;/code&gt; property, the first radio button input element whose &lt;code&gt;value&lt;/code&gt; property is equal to the new value will be set to &lt;code&gt;checked&lt;/code&gt;.</source>
          <target state="translated">기본 요소 컬렉션에 라디오 버튼이 포함 된 경우 &lt;code&gt;value&lt;/code&gt; 속성은 선택된 라디오 버튼을 나타냅니다. &lt;code&gt;value&lt;/code&gt; 속성을 검색하면 현재 &lt;code&gt;checked&lt;/code&gt; 라디오 버튼 의 &lt;code&gt;value&lt;/code&gt; 이 문자열로 반환됩니다. 컬렉션에 라디오 버튼이 없거나 컬렉션의 라디오 버튼이 &lt;code&gt;checked&lt;/code&gt; 상태 가 아니면 빈 문자열이 반환됩니다. 설정에 &lt;code&gt;value&lt;/code&gt; 속성, 그 첫 번째 라디오 버튼 입력 요소 &lt;code&gt;value&lt;/code&gt; 속성 새로운 값과 동일한 설정 될 것이다 &lt;code&gt;checked&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d7018075337b02a24503f4a206562077a3aed93c" translate="yes" xml:space="preserve">
          <source>If the underlying index or object store does not support updating the record because it is open in the &lt;code&gt;&lt;a href=&quot;https://developer.mozilla.org/en/IndexedDB/IDBObjectStoreSync#const_read_only&quot;&gt;READ_ONLY&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;https://developer.mozilla.org/en/IndexedDB/IDBCursorSync#const_snapshot_read&quot;&gt;SNAPSHOT_READ&lt;/a&gt;&lt;/code&gt; mode, or if an index record cannot be changed because the underlying index is &lt;a href=&quot;https://developer.mozilla.org/en/IndexedDB#gloss_auto-populated&quot;&gt;auto-populated&lt;/a&gt;.</source>
          <target state="translated">기본 인덱스 또는 개체 저장소가 열려 있기 때문에 기록을 갱신 지원하지 않는 경우 &lt;code&gt;&lt;a href=&quot;https://developer.mozilla.org/en/IndexedDB/IDBObjectStoreSync#const_read_only&quot;&gt;READ_ONLY&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;https://developer.mozilla.org/en/IndexedDB/IDBCursorSync#const_snapshot_read&quot;&gt;SNAPSHOT_READ&lt;/a&gt;&lt;/code&gt; 모드 또는 기본 인덱스이기 때문에 인덱스 레코드가 변경 될 수없는 경우 &lt;a href=&quot;https://developer.mozilla.org/en/IndexedDB#gloss_auto-populated&quot;&gt;자동으로 입력&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="a944b1d975bf8ae48248590d9216cf975e1d00f4" translate="yes" xml:space="preserve">
          <source>If the underlying index or object store does not support updating the record because it is open in the &lt;code&gt;&lt;a href=&quot;https://developer.mozilla.org/en/IndexedDB/IDBObjectStoreSync#const_read_only&quot;&gt;READ_ONLY&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;https://developer.mozilla.org/en/IndexedDB/IDBCursorSync#const_snapshot_read&quot;&gt;SNAPSHOT_READ&lt;/a&gt;&lt;/code&gt; mode.</source>
          <target state="translated">기본 인덱스 또는 객체 저장소가 &lt;code&gt;&lt;a href=&quot;https://developer.mozilla.org/en/IndexedDB/IDBObjectStoreSync#const_read_only&quot;&gt;READ_ONLY&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;https://developer.mozilla.org/en/IndexedDB/IDBCursorSync#const_snapshot_read&quot;&gt;SNAPSHOT_READ&lt;/a&gt;&lt;/code&gt; 모드 에서 열려 있기 때문에 레코드 업데이트를 지원하지 않는 경우</target>
        </trans-unit>
        <trans-unit id="f43ca054c962d08ef308d27005619c9234ccde41" translate="yes" xml:space="preserve">
          <source>If the underlying object store uses &lt;a href=&quot;https://developer.mozilla.org/en/IndexedDB#gloss_in-line_key&quot;&gt;in-line keys&lt;/a&gt; and the property at the &lt;a href=&quot;https://developer.mozilla.org/en/IndexedDB#gloss_key_path&quot;&gt;key path&lt;/a&gt; does not match the key in this cursor's position.</source>
          <target state="translated">기본 개체 저장소가 &lt;a href=&quot;https://developer.mozilla.org/en/IndexedDB#gloss_in-line_key&quot;&gt;인라인 키를&lt;/a&gt; 사용 하고 &lt;a href=&quot;https://developer.mozilla.org/en/IndexedDB#gloss_key_path&quot;&gt;키 경로&lt;/a&gt; 의 속성 이이 커서 위치의 키와 일치하지 않는 경우</target>
        </trans-unit>
        <trans-unit id="bdcf6ea95d9373715153d2cf3c9509e6a8e382ae" translate="yes" xml:space="preserve">
          <source>If the user agent has the domain information in cache, &lt;a href=&quot;domainlookupstart&quot;&gt;&lt;code&gt;domainLookupStart&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;domainlookupend&quot;&gt;&lt;code&gt;domainLookupEnd&lt;/code&gt;&lt;/a&gt; represent the times when the user agent starts and ends the domain data retrieval from the cache.</source>
          <target state="translated">사용자 에이전트에 캐시에 도메인 정보가있는 경우 &lt;a href=&quot;domainlookupstart&quot;&gt; &lt;code&gt;domainLookupStart&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;domainlookupend&quot;&gt; &lt;code&gt;domainLookupEnd&lt;/code&gt; &lt;/a&gt; 는 사용자 에이전트가 캐시에서 도메인 데이터 검색을 시작하고 종료하는 시간을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="fd1ec083da336d1b62f8e9809d6dfb1bad4f7491" translate="yes" xml:space="preserve">
          <source>If the user agent is unable to &lt;a href=&quot;https://www.w3.org/TR/presentation-api/#dfn-monitor-the-list-of-available-presentation-displays&quot;&gt;monitor the list of available presentation displays&lt;/a&gt; for the entire duration of the &lt;a href=&quot;https://www.w3.org/TR/presentation-api/#dfn-controlling-browsing-context&quot;&gt;controlling browsing context&lt;/a&gt; (e.g., because the user has disabled this feature), then:</source>
          <target state="translated">사용자 에이전트가 &lt;a href=&quot;https://www.w3.org/TR/presentation-api/#dfn-controlling-browsing-context&quot;&gt;제어 브라우징 컨텍스트&lt;/a&gt; 의 전체 기간 동안 &lt;a href=&quot;https://www.w3.org/TR/presentation-api/#dfn-monitor-the-list-of-available-presentation-displays&quot;&gt;사용 가능한 프리젠 테이션 디스플레이 목록&lt;/a&gt; 을 모니터 할 수없는 경우 (예 : 사용자가이 기능을 사용하지 않도록 설정 한 경우) 다음을 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="9ecf9daa903466d73226771e875cf81ca55e43b8" translate="yes" xml:space="preserve">
          <source>If the user agent is unable to continuously &lt;a href=&quot;https://www.w3.org/TR/presentation-api/#dfn-monitor-the-list-of-available-presentation-displays&quot;&gt;monitor the list of available presentation displays&lt;/a&gt; but can find presentation displays in order to start a connection, then:</source>
          <target state="translated">사용자 에이전트가 &lt;a href=&quot;https://www.w3.org/TR/presentation-api/#dfn-monitor-the-list-of-available-presentation-displays&quot;&gt;사용 가능한 프리젠 테이션 디스플레이 목록&lt;/a&gt; 을 지속적으로 모니터 할 수 없지만 연결을 시작하기 위해 프리젠 테이션 디스플레이를 찾을 수있는 경우 다음을 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="43ba9360eeda9db498e8663496200a1e03fd308f" translate="yes" xml:space="preserve">
          <source>If the user selects just one file, it is then only necessary to consider the first file of the list.</source>
          <target state="translated">사용자가 하나의 파일 만 선택하면 목록의 첫 번째 파일 만 고려하면됩니다.</target>
        </trans-unit>
        <trans-unit id="7b34e587eb3d7e748ad2fd143e8be14701870094" translate="yes" xml:space="preserve">
          <source>If the user's finger wanders into browser UI, or the touch otherwise needs to be canceled, the &lt;code&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Events/pointercancel&quot;&gt;pointercancel&lt;/a&gt;&lt;/code&gt; event is sent, and we call the &lt;code&gt;handleCancel()&lt;/code&gt; function below.</source>
          <target state="translated">사용자의 손가락이 브라우저 UI를 방황하거나 터치를 취소 &lt;code&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Events/pointercancel&quot;&gt;pointercancel&lt;/a&gt;&lt;/code&gt; 경우 pointercancel 이벤트가 전송되고 아래 &lt;code&gt;handleCancel()&lt;/code&gt; 함수를 호출합니다 .</target>
        </trans-unit>
        <trans-unit id="9123b6f66738bd01363f84c4cc4ee7292594eee9" translate="yes" xml:space="preserve">
          <source>If the user's finger wanders into browser UI, or the touch otherwise needs to be canceled, the &lt;code&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Events/touchcancel&quot;&gt;touchcancel&lt;/a&gt;&lt;/code&gt; event is sent, and we call the &lt;code&gt;handleCancel()&lt;/code&gt; function below.</source>
          <target state="translated">사용자의 손가락이 브라우저 UI를 방황하거나 터치를 취소해야하는 경우 &lt;code&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Events/touchcancel&quot;&gt;touchcancel&lt;/a&gt;&lt;/code&gt; 이벤트가 전송되고 아래 &lt;code&gt;handleCancel()&lt;/code&gt; 함수를 호출합니다 .</target>
        </trans-unit>
        <trans-unit id="6a9f9cbe83399e245637bda5272420221c2a66de" translate="yes" xml:space="preserve">
          <source>If the value for &lt;em&gt;utfLabel&lt;/em&gt; is unknown, or is one of the two values leading to a &lt;code&gt;'replacement'&lt;/code&gt; decoding algorithm ( &quot;&lt;code&gt;iso-2022-cn&lt;/code&gt;&quot; or &quot;&lt;code&gt;iso-2022-cn-ext&lt;/code&gt;&quot;), a &lt;a href=&quot;../domexception&quot;&gt;&lt;code&gt;DOMException&lt;/code&gt;&lt;/a&gt; with the &lt;code&gt;&quot;TypeError&quot;&lt;/code&gt; value is thrown.</source>
          <target state="translated">&lt;em&gt;utfLabel&lt;/em&gt; 의 값을 알 수 없거나 &lt;code&gt;'replacement'&lt;/code&gt; 디코딩 알고리즘 ( &quot; &lt;code&gt;iso-2022-cn&lt;/code&gt; &quot;또는 &quot; &lt;code&gt;iso-2022-cn-ext&lt;/code&gt; &quot;)으로 이어지는 두 값 중 하나 인 경우 &lt;code&gt;&quot;TypeError&quot;&lt;/code&gt; 가 있는 &lt;a href=&quot;../domexception&quot;&gt; &lt;code&gt;DOMException&lt;/code&gt; &lt;/a&gt; 가치가 던져집니다.</target>
        </trans-unit>
        <trans-unit id="48ef5978d50c45d7e801d26bb61c827f2f708cbf" translate="yes" xml:space="preserve">
          <source>If the value of the &lt;a href=&quot;../audiocontextoptions/latencyhint&quot;&gt;&lt;code&gt;latencyHint&lt;/code&gt;&lt;/a&gt; property isn't valid, Chrome throws a &lt;code&gt;TypeError&lt;/code&gt; exception with the message &quot;The provided value '...' is not a valid enum value of type AudioContextLatencyCategory&quot;.</source>
          <target state="translated">&lt;a href=&quot;../audiocontextoptions/latencyhint&quot;&gt; &lt;code&gt;latencyHint&lt;/code&gt; &lt;/a&gt; 속성 값이 유효하지 않으면 Chrome은 '제공된 값'... '은 (는) AudioContextLatencyCategory 유형의 유효한 열거 형 값이 아닙니다.'라는 메시지와 함께 &lt;code&gt;TypeError&lt;/code&gt; 예외를 발생시킵니다.</target>
        </trans-unit>
        <trans-unit id="ff4e2464859c75c1810e95dd7be6fbbfccf68ff9" translate="yes" xml:space="preserve">
          <source>If the value of the parameter is invalid, a &lt;a href=&quot;../domexception&quot;&gt;&lt;code&gt;DOMException&lt;/code&gt;&lt;/a&gt; with a &lt;code&gt;NOT_SUPPORTED_ERR&lt;/code&gt; code is thrown.</source>
          <target state="translated">매개 변수 값이 유효하지 않은 경우 &lt;code&gt;NOT_SUPPORTED_ERR&lt;/code&gt; 코드가 있는 &lt;a href=&quot;../domexception&quot;&gt; &lt;code&gt;DOMException&lt;/code&gt; &lt;/a&gt; 이 발생합니다.</target>
        </trans-unit>
        <trans-unit id="d31eadbc09979099f9b59046d40f3711cb2653e0" translate="yes" xml:space="preserve">
          <source>If the value of the specified object's &lt;a href=&quot;../rtcicecandidate/candidate&quot;&gt;&lt;code&gt;candidate&lt;/code&gt;&lt;/a&gt; is an empty string (&lt;code&gt;&quot;&quot;&lt;/code&gt;), it signals that all remote candidates have been delivered (end-of-candidates).</source>
          <target state="translated">지정된 오브젝트 &lt;a href=&quot;../rtcicecandidate/candidate&quot;&gt; &lt;code&gt;candidate&lt;/code&gt; &lt;/a&gt; 의 값이 빈 문자열 ( &lt;code&gt;&quot;&quot;&lt;/code&gt; )이면 모든 원격 후보가 전달되었음을 나타냅니다 (후보자).</target>
        </trans-unit>
        <trans-unit id="cd4e6e7309a44b537c97aea48f6042adfe051a7e" translate="yes" xml:space="preserve">
          <source>If the value specified in the &lt;a href=&quot;../paymentaddress&quot;&gt;&lt;code&gt;PaymentAddress&lt;/code&gt;&lt;/a&gt; object's &lt;a href=&quot;../paymentaddress/city&quot;&gt;&lt;code&gt;city&lt;/code&gt;&lt;/a&gt; property could not be validated, this property contains a &lt;a href=&quot;../domstring&quot;&gt;&lt;code&gt;DOMString&lt;/code&gt;&lt;/a&gt; offering a human-readable explanation of the validation error and offers suggestions for correcting it.</source>
          <target state="translated">&lt;a href=&quot;../paymentaddress&quot;&gt; &lt;code&gt;PaymentAddress&lt;/code&gt; &lt;/a&gt; 오브젝트의 &lt;a href=&quot;../paymentaddress/city&quot;&gt; &lt;code&gt;city&lt;/code&gt; &lt;/a&gt; 특성에 지정된 값을 유효성 검증 할 수없는 경우,이 특성에는 사람이 읽을 수있는 유효성 검증 오류 설명을 제공하고이를 정정하기위한 제안 사항을 제공하는 &lt;a href=&quot;../domstring&quot;&gt; &lt;code&gt;DOMString&lt;/code&gt; &lt;/a&gt; 이 포함 됩니다.</target>
        </trans-unit>
        <trans-unit id="caf111c273846069b7c35ad05b8d635f0f05735f" translate="yes" xml:space="preserve">
          <source>If the value specified in the &lt;a href=&quot;../paymentaddress&quot;&gt;&lt;code&gt;PaymentAddress&lt;/code&gt;&lt;/a&gt; object's &lt;a href=&quot;../paymentaddress/dependentlocality&quot;&gt;&lt;code&gt;dependentLocality&lt;/code&gt;&lt;/a&gt; property could not be validated, this property contains a &lt;a href=&quot;../domstring&quot;&gt;&lt;code&gt;DOMString&lt;/code&gt;&lt;/a&gt; offering a human-readable explanation of the validation error and offers suggestions for correcting it.</source>
          <target state="translated">&lt;a href=&quot;../paymentaddress&quot;&gt; &lt;code&gt;PaymentAddress&lt;/code&gt; &lt;/a&gt; 오브젝트의 &lt;a href=&quot;../paymentaddress/dependentlocality&quot;&gt; &lt;code&gt;dependentLocality&lt;/code&gt; &lt;/a&gt; 특성에 지정된 값을 유효성 검증 할 수없는 경우,이 특성에는 사람이 읽을 수있는 유효성 검증 오류 설명을 제공하고이를 정정하기위한 제안 사항을 제공하는 &lt;a href=&quot;../domstring&quot;&gt; &lt;code&gt;DOMString&lt;/code&gt; &lt;/a&gt; 이 포함 됩니다.</target>
        </trans-unit>
        <trans-unit id="0986a0c232c32322ea9cf2f5332587d3ba094171" translate="yes" xml:space="preserve">
          <source>If the value specified in the &lt;a href=&quot;../paymentaddress&quot;&gt;&lt;code&gt;PaymentAddress&lt;/code&gt;&lt;/a&gt; object's &lt;a href=&quot;../paymentaddress/organization&quot;&gt;&lt;code&gt;organization&lt;/code&gt;&lt;/a&gt; property could not be validated, this property contains a &lt;a href=&quot;../domstring&quot;&gt;&lt;code&gt;DOMString&lt;/code&gt;&lt;/a&gt; offering a human-readable explanation of the validation error and offers suggestions for correcting it.</source>
          <target state="translated">&lt;a href=&quot;../paymentaddress&quot;&gt; &lt;code&gt;PaymentAddress&lt;/code&gt; &lt;/a&gt; 오브젝트의 &lt;a href=&quot;../paymentaddress/organization&quot;&gt; &lt;code&gt;organization&lt;/code&gt; &lt;/a&gt; 특성에 지정된 값을 유효성 검증 할 수없는 경우이 특성에는 인간이 읽을 수있는 유효성 검증 오류 설명을 제공하고이를 정정하기위한 제안 사항을 제공하는 &lt;a href=&quot;../domstring&quot;&gt; &lt;code&gt;DOMString&lt;/code&gt; &lt;/a&gt; 이 포함 됩니다.</target>
        </trans-unit>
        <trans-unit id="f345d1fc7b32ca24688f71ca78ffbc8712fa5d76" translate="yes" xml:space="preserve">
          <source>If the value specified in the &lt;a href=&quot;../paymentaddress&quot;&gt;&lt;code&gt;PaymentAddress&lt;/code&gt;&lt;/a&gt; object's &lt;a href=&quot;../paymentaddress/phone&quot;&gt;&lt;code&gt;phone&lt;/code&gt;&lt;/a&gt; property could not be validated, this property contains a &lt;a href=&quot;../domstring&quot;&gt;&lt;code&gt;DOMString&lt;/code&gt;&lt;/a&gt; offering a human-readable explanation of the validation error and offers suggestions for correcting it.</source>
          <target state="translated">&lt;a href=&quot;../paymentaddress&quot;&gt; &lt;code&gt;PaymentAddress&lt;/code&gt; &lt;/a&gt; 오브젝트의 &lt;a href=&quot;../paymentaddress/phone&quot;&gt; &lt;code&gt;phone&lt;/code&gt; &lt;/a&gt; 특성에 지정된 값 의 유효성을 검증 할 수없는 경우이 특성에는 사람이 읽을 수있는 유효성 검증 오류 설명을 제공하고이를 정정하기위한 제안 사항을 제공하는 &lt;a href=&quot;../domstring&quot;&gt; &lt;code&gt;DOMString&lt;/code&gt; &lt;/a&gt; 이 포함 됩니다.</target>
        </trans-unit>
        <trans-unit id="171d811683e436063b8f0b02ede2962405661a51" translate="yes" xml:space="preserve">
          <source>If the value specified in the &lt;a href=&quot;../paymentaddress&quot;&gt;&lt;code&gt;PaymentAddress&lt;/code&gt;&lt;/a&gt; object's &lt;a href=&quot;../paymentaddress/postalcode&quot;&gt;&lt;code&gt;postalCode&lt;/code&gt;&lt;/a&gt; property could not be validated, this property contains a &lt;a href=&quot;../domstring&quot;&gt;&lt;code&gt;DOMString&lt;/code&gt;&lt;/a&gt; offering a human-readable explanation of the validation error and offers suggestions for correcting it.</source>
          <target state="translated">&lt;a href=&quot;../paymentaddress&quot;&gt; &lt;code&gt;PaymentAddress&lt;/code&gt; &lt;/a&gt; 오브젝트의 &lt;a href=&quot;../paymentaddress/postalcode&quot;&gt; &lt;code&gt;postalCode&lt;/code&gt; &lt;/a&gt; 등록 정보에 지정된 값을 검증 할 수없는 경우이 등록 정보 는 사람이 읽을 수있는 검증 오류 설명을 제공하고이를 정정하기위한 제안을 제공하는 &lt;a href=&quot;../domstring&quot;&gt; &lt;code&gt;DOMString&lt;/code&gt; &lt;/a&gt; 을 포함 합니다.</target>
        </trans-unit>
        <trans-unit id="1b365062e9be38502d1718ab66821736aa4d27aa" translate="yes" xml:space="preserve">
          <source>If the value specified in the &lt;a href=&quot;../paymentaddress&quot;&gt;&lt;code&gt;PaymentAddress&lt;/code&gt;&lt;/a&gt; object's &lt;a href=&quot;../paymentaddress/recipient&quot;&gt;&lt;code&gt;recipient&lt;/code&gt;&lt;/a&gt; property could not be validated, this property contains a &lt;a href=&quot;../domstring&quot;&gt;&lt;code&gt;DOMString&lt;/code&gt;&lt;/a&gt; offering a human-readable explanation of the validation error and offers suggestions for correcting it.</source>
          <target state="translated">&lt;a href=&quot;../paymentaddress&quot;&gt; &lt;code&gt;PaymentAddress&lt;/code&gt; &lt;/a&gt; 오브젝트의 &lt;a href=&quot;../paymentaddress/recipient&quot;&gt; &lt;code&gt;recipient&lt;/code&gt; &lt;/a&gt; 특성에 지정된 값 의 유효성을 검증 할 수없는 경우이 특성에는 인간이 읽을 수있는 유효성 검증 오류 설명을 제공하고이를 정정하기위한 제안 사항을 제공하는 &lt;a href=&quot;../domstring&quot;&gt; &lt;code&gt;DOMString&lt;/code&gt; &lt;/a&gt; 이 포함 됩니다.</target>
        </trans-unit>
        <trans-unit id="005ae79e360db82f38bb35694e6a9057b9db6351" translate="yes" xml:space="preserve">
          <source>If the value specified in the &lt;a href=&quot;../paymentaddress&quot;&gt;&lt;code&gt;PaymentAddress&lt;/code&gt;&lt;/a&gt; object's &lt;a href=&quot;../paymentaddress/region&quot;&gt;&lt;code&gt;region&lt;/code&gt;&lt;/a&gt; property could not be validated, this property contains a &lt;a href=&quot;../domstring&quot;&gt;&lt;code&gt;DOMString&lt;/code&gt;&lt;/a&gt; offering a human-readable explanation of the validation error and offers suggestions for correcting it.</source>
          <target state="translated">&lt;a href=&quot;../paymentaddress&quot;&gt; &lt;code&gt;PaymentAddress&lt;/code&gt; &lt;/a&gt; 오브젝트의 &lt;a href=&quot;../paymentaddress/region&quot;&gt; &lt;code&gt;region&lt;/code&gt; &lt;/a&gt; 특성에 지정된 값을 유효성 검증 할 수없는 경우,이 특성에는 인간이 읽을 수있는 유효성 검증 오류 설명을 제공하고이를 정정하기위한 제안 사항을 제공하는 &lt;a href=&quot;../domstring&quot;&gt; &lt;code&gt;DOMString&lt;/code&gt; &lt;/a&gt; 이 포함 됩니다.</target>
        </trans-unit>
        <trans-unit id="f152458ffda49d75c274c88910297fec84415e18" translate="yes" xml:space="preserve">
          <source>If the value specified in the &lt;a href=&quot;../paymentaddress&quot;&gt;&lt;code&gt;PaymentAddress&lt;/code&gt;&lt;/a&gt; object's &lt;a href=&quot;../paymentaddress/regioncode&quot;&gt;&lt;code&gt;regionCode&lt;/code&gt;&lt;/a&gt; property could not be validated, this property contains a &lt;a href=&quot;../domstring&quot;&gt;&lt;code&gt;DOMString&lt;/code&gt;&lt;/a&gt; offering a human-readable explanation of the validation error and offers suggestions for correcting it.</source>
          <target state="translated">&lt;a href=&quot;../paymentaddress&quot;&gt; &lt;code&gt;PaymentAddress&lt;/code&gt; &lt;/a&gt; 오브젝트의 &lt;a href=&quot;../paymentaddress/regioncode&quot;&gt; &lt;code&gt;regionCode&lt;/code&gt; &lt;/a&gt; 특성에 지정된 값을 유효성 검증 할 수없는 경우,이 특성에는 인간이 읽을 수있는 유효성 검증 오류 설명을 제공하고이를 정정하기위한 제안 사항을 제공하는 &lt;a href=&quot;../domstring&quot;&gt; &lt;code&gt;DOMString&lt;/code&gt; &lt;/a&gt; 이 포함 됩니다.</target>
        </trans-unit>
        <trans-unit id="a15210b9946278c0bf7452412648a610bd6c87ef" translate="yes" xml:space="preserve">
          <source>If the value specified in the &lt;a href=&quot;../paymentaddress&quot;&gt;&lt;code&gt;PaymentAddress&lt;/code&gt;&lt;/a&gt; object's &lt;a href=&quot;../paymentaddress/sortingcode&quot;&gt;&lt;code&gt;sortingCode&lt;/code&gt;&lt;/a&gt; property could not be validated, this property contains a &lt;a href=&quot;../domstring&quot;&gt;&lt;code&gt;DOMString&lt;/code&gt;&lt;/a&gt; offering a human-readable explanation of the validation error and offers suggestions for correcting it.</source>
          <target state="translated">&lt;a href=&quot;../paymentaddress&quot;&gt; &lt;code&gt;PaymentAddress&lt;/code&gt; &lt;/a&gt; 오브젝트의 &lt;a href=&quot;../paymentaddress/sortingcode&quot;&gt; &lt;code&gt;sortingCode&lt;/code&gt; &lt;/a&gt; 특성에 지정된 값 의 유효성을 검증 할 수없는 경우이 특성에는 인간이 읽을 수있는 유효성 검증 오류 설명을 제공하고이를 정정하기위한 제안 사항을 제공하는 &lt;a href=&quot;../domstring&quot;&gt; &lt;code&gt;DOMString&lt;/code&gt; &lt;/a&gt; 이 포함 됩니다.</target>
        </trans-unit>
        <trans-unit id="8f3c857b3e1285cc8df07982d8f3d43dbfbeb06e" translate="yes" xml:space="preserve">
          <source>If the writer is active, the &lt;code&gt;abort()&lt;/code&gt; method behaves the same as that for the associated stream (&lt;a href=&quot;../writablestream/abort&quot;&gt;&lt;code&gt;WritableStream.abort()&lt;/code&gt;&lt;/a&gt;). If not, it returns a rejected promise.</source>
          <target state="translated">기록기가 활성화 된 경우 &lt;code&gt;abort()&lt;/code&gt; 메서드는 연결된 스트림 ( &lt;a href=&quot;../writablestream/abort&quot;&gt; &lt;code&gt;WritableStream.abort()&lt;/code&gt; &lt;/a&gt; ) 과 동일하게 동작합니다 . 그렇지 않으면 거부 된 약속을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="7a06bd2dee6c236f039361936f3b2e9173d62438" translate="yes" xml:space="preserve">
          <source>If the writer is active, the &lt;code&gt;abort()&lt;/code&gt; method behaves the same as that for the associated stream (&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/WriteableStream/abort&quot;&gt;&lt;code&gt;WriteableStream.abort()&lt;/code&gt;&lt;/a&gt;). If not, it returns a rejected promise.</source>
          <target state="translated">기록기가 활성화되어 있으면 &lt;code&gt;abort()&lt;/code&gt; 메서드는 연결된 스트림 ( &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/WriteableStream/abort&quot;&gt; &lt;code&gt;WriteableStream.abort()&lt;/code&gt; &lt;/a&gt; ) 과 동일하게 동작합니다 . 그렇지 않으면 거부 된 약속을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="b6ee524a9a65784f68fab67841ef31d323a2139e" translate="yes" xml:space="preserve">
          <source>If there are HTTP redirects the property returns the time immediately before the user agent starts to fetch the final resource in the redirection.</source>
          <target state="translated">HTTP 리디렉션이있는 경우이 속성은 사용자 에이전트가 리디렉션에서 최종 리소스를 가져 오기 시작하기 직전의 시간을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="ebf7560a4cee50ad8e297df5d0a3b43c0c938270" translate="yes" xml:space="preserve">
          <source>If there are HTTP redirects when fetching the resource and if any of the redirects are not from the same origin as the current document, but the timing allow check algorithm passes for each redirected resource, this property returns the starting time of the fetch that initiates the redirect; otherwise, zero is returned.</source>
          <target state="translated">리소스를 가져올 때 HTTP 리디렉션이 있고 현재 문서와 동일한 출처가 아닌 리디렉션 중 하나라도 타이밍 재 지정 알고리즘이 각 리디렉션 된 리소스에 대해 통과를 허용하는 경우이 속성은 리디렉션; 그렇지 않으면 0이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="fe82e7dcdabaa9e171f554127a4df9902ad5dae4" translate="yes" xml:space="preserve">
          <source>If there are too few &lt;code&gt;easing&lt;/code&gt; or &lt;code&gt;composite&lt;/code&gt; values, the corresponding list will be repeated as needed.</source>
          <target state="translated">&lt;code&gt;easing&lt;/code&gt; 또는 &lt;code&gt;composite&lt;/code&gt; 값 이 너무 적 으면 해당 목록이 필요에 따라 반복됩니다.</target>
        </trans-unit>
        <trans-unit id="f9f6317da545edbbcb114c319cf13dd42271eeb1" translate="yes" xml:space="preserve">
          <source>If there exists a tuple &lt;em&gt;(&lt;var&gt;A&lt;/var&gt;, &lt;var&gt;presentationUrls&lt;/var&gt;)&lt;/em&gt; in the &lt;a href=&quot;https://www.w3.org/TR/presentation-api/#dfn-set-of-availability-objects&quot;&gt;set of availability objects&lt;/a&gt;, then:</source>
          <target state="translated">튜플이 존재하는 경우 &lt;em&gt;( , &lt;var&gt;presentationUrls&lt;/var&gt; ) &lt;var&gt;A&lt;/var&gt; &lt;/em&gt; 의 &lt;a href=&quot;https://www.w3.org/TR/presentation-api/#dfn-set-of-availability-objects&quot;&gt;가용성 개체의 집합&lt;/a&gt; 다음을 :</target>
        </trans-unit>
        <trans-unit id="d52d7d91f58e4c7b1ac69cff6f1d13697b2ce25c" translate="yes" xml:space="preserve">
          <source>If there is a match and it is &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTTP/Caching#Freshness&quot;&gt;fresh&lt;/a&gt;, it will be returned from the cache.</source>
          <target state="translated">일치하는 항목이 있고 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTTP/Caching#Freshness&quot;&gt;새로 만든&lt;/a&gt; 경우 캐시에서 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="6cb46736602ef20dd723befc03d87f1b639b1bf3" translate="yes" xml:space="preserve">
          <source>If there is a match but it is stale, the browser will make a &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTTP/Conditional_requests&quot;&gt;conditional request&lt;/a&gt; to the remote server. If the server indicates that the resource has not changed, it will be returned from the cache. Otherwise the resource will be downloaded from the server and the cache will be updated.</source>
          <target state="translated">일치하는 항목이 있지만 오래된 경우 브라우저는 원격 서버에 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTTP/Conditional_requests&quot;&gt;조건부 요청&lt;/a&gt; 을합니다. 서버가 리소스가 변경되지 않았다고 표시하면 캐시에서 반환됩니다. 그렇지 않으면 서버에서 리소스가 다운로드되고 캐시가 업데이트됩니다.</target>
        </trans-unit>
        <trans-unit id="a8c184c7e27124a9a5130780d639f79aba75a6f8" translate="yes" xml:space="preserve">
          <source>If there is a match, &lt;em&gt;fresh or stale&lt;/em&gt;, if will be returned from the cache.</source>
          <target state="translated">일치하는 것이 있으면 &lt;em&gt;fresh 또는 stale&lt;/em&gt; 이면 캐시에서 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="cba01aaae6e64da528294b78bfa3ec11b04e9aa3" translate="yes" xml:space="preserve">
          <source>If there is a match, &lt;em&gt;fresh or stale&lt;/em&gt;, it will be returned from the cache.</source>
          <target state="translated">일치하는 &lt;em&gt;fresh 또는 stale&lt;/em&gt; 이 있으면 캐시에서 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="605a5f5a97f57eac7ca714d543b0e368d2d8d57d" translate="yes" xml:space="preserve">
          <source>If there is a match,&lt;em&gt; fresh or stale, &lt;/em&gt;the browser will make a &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTTP/Conditional_requests&quot;&gt;conditional request&lt;/a&gt; to the remote server. If the server indicates that the resource has not changed, it will be returned from the cache. Otherwise the resource will be downloaded from the server and the cache will be updated.</source>
          <target state="translated">일치 &lt;em&gt;하거나 새로 작성되었거나 오래되면&lt;/em&gt; 브라우저는 원격 서버에 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTTP/Conditional_requests&quot;&gt;조건부 요청&lt;/a&gt; 을합니다. 서버가 리소스가 변경되지 않았다고 표시하면 캐시에서 반환됩니다. 그렇지 않으면 서버에서 리소스가 다운로드되고 캐시가 업데이트됩니다.</target>
        </trans-unit>
        <trans-unit id="080e1a1618428d791d1462c5c8de21de435cbe82" translate="yes" xml:space="preserve">
          <source>If there is a possibility that your logic could take longer to execute than the interval time, it is recommended that you recursively call a named function using &lt;a href=&quot;settimeout&quot;&gt;&lt;code&gt;WindowOrWorkerGlobalScope.setTimeout&lt;/code&gt;&lt;/a&gt;. For example, if using &lt;code&gt;setInterval&lt;/code&gt; to poll a remote server every 5 seconds, network latency, an unresponsive server, and a host of other issues could prevent the request from completing in its allotted time. As such, you may find yourself with queued up XHR requests that won't necessarily return in order.</source>
          <target state="translated">논리가 간격 시간보다 실행하는 데 시간이 오래 걸릴 수있는 경우 &lt;a href=&quot;settimeout&quot;&gt; &lt;code&gt;WindowOrWorkerGlobalScope.setTimeout&lt;/code&gt; 을&lt;/a&gt; 사용하여 명명 된 함수를 재귀 적으로 호출하는 것이 좋습니다 . 예를 들어, &lt;code&gt;setInterval&lt;/code&gt; 을 사용하여 5 초마다 원격 서버를 폴링하면 네트워크 대기 시간, 응답하지 않는 서버 및 기타 여러 가지 문제로 인해 요청이 할당 된 시간 내에 완료되지 않을 수 있습니다. 따라서 반드시 순서대로 반환되지 않는 대기 XHR 요청이있을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f0af820cb0b573cfbaf7ee3b9f4831fdaafc986c" translate="yes" xml:space="preserve">
          <source>If there is an error linking the program or you wish to delete an existing program, then it is as simple as running &lt;a href=&quot;webglrenderingcontext/deleteprogram&quot;&gt;&lt;code&gt;WebGLRenderingContext.deleteProgram()&lt;/code&gt;&lt;/a&gt;. This frees the memory of the linked program.</source>
          <target state="translated">프로그램 연결 오류가 있거나 기존 프로그램을 삭제하려면 &lt;a href=&quot;webglrenderingcontext/deleteprogram&quot;&gt; &lt;code&gt;WebGLRenderingContext.deleteProgram()&lt;/code&gt; &lt;/a&gt; 을 실행하는 것만 큼 간단 합니다. 연결된 프로그램의 메모리를 비 웁니다.</target>
        </trans-unit>
        <trans-unit id="9c8be0dcf4d9d4b44a32556cf5870315d6cf5c40" translate="yes" xml:space="preserve">
          <source>If there is an existing service worker available, the new version is installed in the background, but not yet activated &amp;mdash; at this point it is called the &lt;em&gt;worker in waiting&lt;/em&gt;. It is only activated when there are no longer any pages loaded that are still using the old service worker. As soon as there are no more pages to be loaded, the new service worker activates (becoming the &lt;em&gt;active worker&lt;/em&gt;). Activation can happen sooner using &lt;a href=&quot;serviceworkerglobalscope/skipwaiting&quot;&gt;&lt;code&gt;ServiceWorkerGlobalScope.skipWaiting()&lt;/code&gt;&lt;/a&gt; and existing pages can be claimed by the active worker using &lt;a href=&quot;clients/claim&quot;&gt;&lt;code&gt;Clients.claim()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">사용 가능한 기존 서비스 작업자가있는 경우 새 버전이 백그라운드에 설치되었지만 아직 활성화되지 않았습니다.이 시점 &lt;em&gt;에서 대기중인 작업 자라고&lt;/em&gt; 합니다. 여전히 이전 서비스 워커를 사용중인 페이지가 더 이상로드되지 않은 경우에만 활성화됩니다. 로드 할 페이지가 더 이상 없으면 새 서비스 워커가 활성화됩니다 ( &lt;em&gt;활성 워커&lt;/em&gt; 되기 ). &lt;a href=&quot;serviceworkerglobalscope/skipwaiting&quot;&gt; &lt;code&gt;ServiceWorkerGlobalScope.skipWaiting()&lt;/code&gt; &lt;/a&gt; 사용하여 활성화를 더 빨리 수행 할 수 있으며 &lt;a href=&quot;clients/claim&quot;&gt; &lt;code&gt;Clients.claim()&lt;/code&gt; &lt;/a&gt; 사용하여 활성 작업자가 기존 페이지를 청구 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="5079274803c2f4f02634943141d2e5f9eafe543f" translate="yes" xml:space="preserve">
          <source>If there is more stream to read, you process the current chunk then run the function again.</source>
          <target state="translated">읽을 스트림이 더 있으면 현재 청크를 처리 한 다음 함수를 다시 실행하십시오.</target>
        </trans-unit>
        <trans-unit id="b213948714d53687fe3aa6a1fcf5261d9e1f1144" translate="yes" xml:space="preserve">
          <source>If there is no element with the given &lt;code&gt;id&lt;/code&gt;, this function returns &lt;code&gt;null&lt;/code&gt;. Note that the &lt;code&gt;id&lt;/code&gt; parameter is case-sensitive, so &lt;code&gt;document.getElementById(&quot;&lt;strong&gt;M&lt;/strong&gt;ain&quot;)&lt;/code&gt; will return &lt;code&gt;null&lt;/code&gt; instead of the element &lt;code&gt;&amp;lt;div id=&quot;&lt;strong&gt;m&lt;/strong&gt;ain&quot;&amp;gt;&lt;/code&gt; because &quot;M&quot; and &quot;m&quot; are different for the purposes of this method.</source>
          <target state="translated">주어진 &lt;code&gt;id&lt;/code&gt; 를 가진 요소가 없으면 이 함수는 &lt;code&gt;null&lt;/code&gt; 을 반환합니다 . 참고 &lt;code&gt;id&lt;/code&gt; 가 정수가 대소 문자를 구별 &lt;code&gt;document.getElementById(&quot;&lt;strong&gt;M&lt;/strong&gt;ain&quot;)&lt;/code&gt; 반환 &lt;code&gt;null&lt;/code&gt; 대신 요소 &lt;code&gt;&amp;lt;div id=&quot;&lt;strong&gt;m&lt;/strong&gt;ain&quot;&amp;gt;&lt;/code&gt; &quot;M&quot;및 &quot;m&quot;이 목적을위한 다르기 때문에 이 방법.</target>
        </trans-unit>
        <trans-unit id="f8bfd689eecd2fa73d797ef0f9b0516f088d8408" translate="yes" xml:space="preserve">
          <source>If there is no match, the browser will make a normal request, and will update the cache with the downloaded resource.</source>
          <target state="translated">일치하지 않으면 브라우저는 정상적인 요청을하고 다운로드 한 리소스로 캐시를 업데이트합니다.</target>
        </trans-unit>
        <trans-unit id="8c51b052363029470e7a6212722d3c2812c7a306" translate="yes" xml:space="preserve">
          <source>If there is no match, the browser will respond with a &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/504&quot;&gt;504 Gateway timeout&lt;/a&gt; status.</source>
          <target state="translated">일치하는 것이 없으면 브라우저는 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/504&quot;&gt;504 게이트웨이 시간 초과&lt;/a&gt; 상태로 응답 합니다.</target>
        </trans-unit>
        <trans-unit id="e475422af2a1953a620060324ed8d116d4e32563" translate="yes" xml:space="preserve">
          <source>If there is no more stream to read, you return out of the function.</source>
          <target state="translated">읽을 스트림이 더 이상 없으면 함수에서 나옵니다.</target>
        </trans-unit>
        <trans-unit id="0d219723115687809e2f8b1e9aae50a0a67e02b6" translate="yes" xml:space="preserve">
          <source>If there is no running timer, &lt;code&gt;timeLog()&lt;/code&gt; returns the warning:</source>
          <target state="translated">실행중인 타이머가 없으면 &lt;code&gt;timeLog()&lt;/code&gt; 가 경고를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="d924916dca84f5a1dfadad0f32a3febaa3128be6" translate="yes" xml:space="preserve">
          <source>If there isn't a preferred style sheet set defined by the author, the empty string (&quot;&quot;) is returned.</source>
          <target state="translated">작성자가 정의한 기본 스타일 시트 세트가 없으면 빈 문자열 ( &quot;&quot;)이 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="7680df971ac3fa46b266177fea3d1cc1283a98bc" translate="yes" xml:space="preserve">
          <source>If there isn't a valid image available (that is, the &lt;code&gt;width&lt;/code&gt; and &lt;code&gt;height&lt;/code&gt; are both 0), we clear the contents of the captured frame box by calling &lt;code&gt;clearphoto()&lt;/code&gt;.</source>
          <target state="translated">사용 가능한 유효한 이미지가 없으면 (즉, &lt;code&gt;width&lt;/code&gt; 와 &lt;code&gt;height&lt;/code&gt; 가 모두 0 임) &lt;code&gt;clearphoto()&lt;/code&gt; 를 호출하여 캡처 된 프레임 상자의 내용을 지 웁니다 .</target>
        </trans-unit>
        <trans-unit id="6524fd633dfcf18fbfc542e6496007f4cb0955fd" translate="yes" xml:space="preserve">
          <source>If this &lt;a href=&quot;domstring&quot;&gt;&lt;code&gt;DOMString&lt;/code&gt;&lt;/a&gt; is present in the object, the &lt;a href=&quot;paymentresponse/payername&quot;&gt;&lt;code&gt;PaymentResponse.payerName&lt;/code&gt;&lt;/a&gt; property failed validation, and this string explains what needs to be corrected. If this property is absent, the paer name is fine</source>
          <target state="translated">이 &lt;a href=&quot;domstring&quot;&gt; &lt;code&gt;DOMString&lt;/code&gt; &lt;/a&gt; 이 오브젝트에 존재하면 &lt;a href=&quot;paymentresponse/payername&quot;&gt; &lt;code&gt;PaymentResponse.payerName&lt;/code&gt; &lt;/a&gt; 특성이 유효성 검증에 실패 했으며이 문자열은 정정해야 할 사항을 설명합니다. 이 속성이 없으면 친구 이름이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="95a41f6e3f28fba23d9631f491d7b24477a7e3a2" translate="yes" xml:space="preserve">
          <source>If this animation is canceled, remove its element.</source>
          <target state="translated">이 애니메이션이 취소되면 해당 요소를 제거하십시오.</target>
        </trans-unit>
        <trans-unit id="0171c5cf4461072061bba042d1d36e25dc22a9c8" translate="yes" xml:space="preserve">
          <source>If this argument is anything else, the default value for image quality is used. The default value is &lt;code&gt;0.92&lt;/code&gt;. Other arguments are ignored.</source>
          <target state="translated">이 인수가 다른 경우 이미지 품질의 기본값이 사용됩니다. 기본값은 &lt;code&gt;0.92&lt;/code&gt; 입니다. 다른 인수는 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="ac3ffd184bbe212df5e2921c1596c7888c2eea16" translate="yes" xml:space="preserve">
          <source>If this argument's value is &lt;code&gt;on&lt;/code&gt;, &lt;code&gt;yes&lt;/code&gt;, or 1, the dialog window can be resized by the user; otherwise its size is fixed. The default value is &lt;code&gt;no&lt;/code&gt;.</source>
          <target state="translated">이 인수의 값이 &lt;code&gt;on&lt;/code&gt; , &lt;code&gt;yes&lt;/code&gt; 또는 1 인 경우 사용자가 대화 상자 창 크기를 조정할 수 있습니다. 그렇지 않으면 크기가 고정됩니다. 기본값은 &lt;code&gt;no&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="476daec3d24b23fbb0e3dbeb9142d7c4dfc8def9" translate="yes" xml:space="preserve">
          <source>If this argument's value is &lt;code&gt;on&lt;/code&gt;, &lt;code&gt;yes&lt;/code&gt;, or 1, the dialog window has scroll bars; otherwise its size is fixed. The default value is &lt;code&gt;no&lt;/code&gt;.</source>
          <target state="translated">이 인수의 값이 &lt;code&gt;on&lt;/code&gt; , &lt;code&gt;yes&lt;/code&gt; 또는 1이면 대화 상자 창에 스크롤 막대가 있습니다. 그렇지 않으면 크기가 고정됩니다. 기본값은 &lt;code&gt;no&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="a9ed163736fd898142df00d7aaa54fccbfad2347" translate="yes" xml:space="preserve">
          <source>If this argument's value is &lt;code&gt;on&lt;/code&gt;, &lt;code&gt;yes&lt;/code&gt;, or 1, the dialog window is centered on the desktop; otherwise it's hidden. The default value is &lt;code&gt;yes&lt;/code&gt;.</source>
          <target state="translated">이 인수의 값이 &lt;code&gt;on&lt;/code&gt; , &lt;code&gt;yes&lt;/code&gt; 또는 1이면 대화 상자 창이 데스크탑의 중앙에 있습니다. 그렇지 않으면 숨겨져 있습니다. 기본값은 &lt;code&gt;yes&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="37e14faf77a60253c199ae9ef4a40dab82e49789" translate="yes" xml:space="preserve">
          <source>If this fails (e.g. because the network is down), return a fallback response.</source>
          <target state="translated">실패하면 (예 : 네트워크가 다운되어) 폴백 응답을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="c379c9ee070c7f6f678ee0a3f09c2c6868119602" translate="yes" xml:space="preserve">
          <source>If this fails (e.g., because the network is down), return a fallback response.</source>
          <target state="translated">실패하면 (예 : 네트워크가 다운되어) 폴백 응답을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="940066c9a6b8ae66a7e27417c620d8b83e6bc996" translate="yes" xml:space="preserve">
          <source>If this feature is on, the new secondary window will be resizable.</source>
          <target state="translated">이 기능이 켜져 있으면 새 보조 창의 크기를 조정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="facf8d1e8ce8de558c083152eb0dc31987e4ab06" translate="yes" xml:space="preserve">
          <source>If this feature is on, the new secondary window will show horizontal and/or vertical scrollbar(s) if the document doesn't fit into the window's viewport.</source>
          <target state="translated">이 기능이 켜져 있으면 문서가 창의 뷰포트에 맞지 않으면 새 보조 창에 가로 및 / 또는 세로 스크롤 막대가 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="9ca4d44c46a156b0de72cd5b4170f2b8d9cbaf91" translate="yes" xml:space="preserve">
          <source>If this feature is on, then the new secondary window has a status bar. Users can force the rendering of status bar in all Mozilla-based browsers, in MSIE 6 SP2 (&lt;a href=&quot;#Note_on_security_issues_of_the_status_bar_presence&quot;&gt;Note on status bar in XP SP2&lt;/a&gt;) and in Opera 6+. The default preference setting in recent Mozilla-based browser releases and in Firefox 1.0 is to force the presence of the status bar.</source>
          <target state="translated">이 기능이 켜져 있으면 새 보조 창에 상태 표시 줄이 있습니다. 사용자는 모든 Mozilla 기반 브라우저, MSIE 6 SP2 ( &lt;a href=&quot;#Note_on_security_issues_of_the_status_bar_presence&quot;&gt;XP SP2의 상태 표시 줄 참고&lt;/a&gt; ) 및 Opera 6+에서 상태 표시 줄을 강제로 렌더링 할 수 있습니다 . 최신 Mozilla 기반 브라우저 릴리스 및 Firefox 1.0의 기본 환경 설정은 상태 표시 줄을 강제로 설정하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="236a67f9910dde46006aa43411af4cb644ea099c" translate="yes" xml:space="preserve">
          <source>If this feature is on, then the new secondary window renders the Location bar in Mozilla-based browsers. MSIE 5+ and Opera 7.x renders the Address Bar.</source>
          <target state="translated">이 기능이 켜져 있으면 새 보조 창에서 Mozilla 기반 브라우저에 위치 표시 줄이 렌더링됩니다. MSIE 5+ 및 Opera 7.x는 주소 표시 줄을 렌더링합니다.</target>
        </trans-unit>
        <trans-unit id="daffac61170e470bcb5d9b422ba35a7107b7de1d" translate="yes" xml:space="preserve">
          <source>If this feature is on, then the new secondary window renders the Navigation Toolbar (Back, Forward, Reload, Stop buttons). In addition to the Navigation Toolbar, Mozilla-based browsers will render the Tab Bar if it is visible, present in the parent window. (If this feature is set to &lt;var&gt;no&lt;/var&gt; all toolbars in the window will be invisible, for example extension toolbars).</source>
          <target state="translated">이 기능이 켜져 있으면 새 보조 창에 탐색 도구 모음 (뒤로, 앞으로, 다시로드, 중지 버튼)이 렌더링됩니다. 탐색 도구 모음 외에도 Mozilla 기반 브라우저는 상위 창에 탭 막대가 표시되면이를 렌더링합니다. (이 기능을 설정 &lt;var&gt;no&lt;/var&gt; 창의 모든 도구 모음 (예 : 확장 도구 모음)이 보이지 않습니다).</target>
        </trans-unit>
        <trans-unit id="2d90c55ba5ed164930927b7d82c5762556c899c5" translate="yes" xml:space="preserve">
          <source>If this feature is on, then the new secondary window renders the Personal Toolbar in Netscape 6.x, Netscape 7.x and Mozilla browser. It renders the Bookmarks Toolbar in Firefox. In addition to the Personal Toolbar, Mozilla browser will render the Site Navigation Bar if such toolbar is visible, present in the parent window.</source>
          <target state="translated">이 기능이 켜져 있으면 새 보조 창은 Netscape 6.x, Netscape 7.x 및 Mozilla 브라우저에서 개인 도구 모음을 렌더링합니다. Firefox에서 책갈피 도구 모음을 렌더링합니다. 개인 도구 모음 외에 모질라 브라우저는 그러한 도구 모음이 보이는 경우 부모 탐색 창에 사이트 탐색 막대를 렌더링합니다.</target>
        </trans-unit>
        <trans-unit id="087e8ff75c4eb87c34451dd62f6e4f246cdf0c8c" translate="yes" xml:space="preserve">
          <source>If this feature is on, then the new secondary window renders the menubar.</source>
          <target state="translated">이 기능이 켜져 있으면 새 보조 창에 메뉴 표시 줄이 렌더링됩니다.</target>
        </trans-unit>
        <trans-unit id="a9fe624c3135904ee191ddd48fd3224a5b14b3d2" translate="yes" xml:space="preserve">
          <source>If this feature is set, the newly-opened window will open as normal, except that it will not have access back to the originating window (via &lt;a href=&quot;opener&quot;&gt;&lt;code&gt;Window.opener&lt;/code&gt;&lt;/a&gt; &amp;mdash; it returns &lt;code&gt;null&lt;/code&gt;). In addition, the &lt;code&gt;window.open()&lt;/code&gt; call will also return &lt;code&gt;null&lt;/code&gt;, so the originating window will not have access to the new one either. This is useful for preventing untrusted sites opened via &lt;code&gt;window.open()&lt;/code&gt; from tampering with the originating window, and vice versa.</source>
          <target state="translated">이 기능이 설정되어있는 경우는 원래의 창으로 액세스 다시 필요가 없습니다 것을 제외하고, 새로 연 창은 정상적으로 열립니다 (를 통해 &lt;a href=&quot;opener&quot;&gt; &lt;code&gt;Window.opener&lt;/code&gt; 를&lt;/a&gt; - 그것은 반환 &lt;code&gt;null&lt;/code&gt; ). 또한 &lt;code&gt;window.open()&lt;/code&gt; 호출도 &lt;code&gt;null&lt;/code&gt; 을 반환 하므로 원래 창은 새 창에도 액세스 할 수 없습니다. 이는 &lt;code&gt;window.open()&lt;/code&gt; 을 통해 열린 신뢰할 수없는 사이트 가 원래 창을 변경하지 못하게하는 데 유용합니다 .</target>
        </trans-unit>
        <trans-unit id="701648fd73e7f1a6f02764f20cda1722229f8910" translate="yes" xml:space="preserve">
          <source>If this feature is specified, the window is able to open even if another application is already in the foreground. This feature is for Firefox OS applications only, and is currently restricted to certified applications. See &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Archive/B2G_OS/Firefox_OS_apps/App_permissions#Internal_(Certified)_app_permissions&quot;&gt;Internal (Certified) app permissions&lt;/a&gt; in &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Archive/B2G_OS/Firefox_OS_apps/App_permissions&quot;&gt;App permissions&lt;/a&gt; for more information.</source>
          <target state="translated">이 기능을 지정하면 다른 응용 프로그램이 이미 포 그라운드에 있어도 창을 열 수 있습니다. 이 기능은 Firefox OS 응용 프로그램 전용이며 현재 인증 된 응용 프로그램으로 제한되어 있습니다. 참조 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Archive/B2G_OS/Firefox_OS_apps/App_permissions#Internal_(Certified)_app_permissions&quot;&gt;내부 (인증) 응용 프로그램 권한&lt;/a&gt; 의 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Archive/B2G_OS/Firefox_OS_apps/App_permissions&quot;&gt;앱 권한&lt;/a&gt; 자세한 내용은.</target>
        </trans-unit>
        <trans-unit id="68d5bd703412fbd62a8ded562b61ee04ba158550" translate="yes" xml:space="preserve">
          <source>If this is indeed the first run, we set the video's height based on the size difference between the video's actual size, &lt;code&gt;video.videoWidth&lt;/code&gt;, and the width at which we're going to render it, &lt;code&gt;width&lt;/code&gt;.</source>
          <target state="translated">이것이 실제로 첫 번째 실행 인 경우 비디오의 실제 크기 인 &lt;code&gt;video.videoWidth&lt;/code&gt; 와 렌더링 할 &lt;code&gt;width&lt;/code&gt; 의 크기 차이에 따라 비디오 높이를 설정합니다 .</target>
        </trans-unit>
        <trans-unit id="56b180deedaea6a91c7daff36c44079c9d7d121f" translate="yes" xml:space="preserve">
          <source>If this is the first time a service worker has been made available, installation is attempted, then after a successful installation, it is activated.</source>
          <target state="translated">처음으로 서비스 작업자를 사용할 수있게되면 설치를 시도한 다음 설치에 성공한 후 활성화됩니다.</target>
        </trans-unit>
        <trans-unit id="18d814e0810c2015afa9bf42b943daebfe1543e9" translate="yes" xml:space="preserve">
          <source>If this method is called with no arguments or the format is an empty &lt;a href=&quot;../domstring&quot;&gt;&lt;code&gt;string&lt;/code&gt;&lt;/a&gt;, the data of all types will be removed.</source>
          <target state="translated">이 메소드가 인수없이 호출되거나 형식이 빈 &lt;a href=&quot;../domstring&quot;&gt; &lt;code&gt;string&lt;/code&gt; &lt;/a&gt; 인 경우 모든 유형의 데이터가 제거됩니다.</target>
        </trans-unit>
        <trans-unit id="66ee32e7963556cdd7dd6324e0f3751eca9e8b85" translate="yes" xml:space="preserve">
          <source>If this object exists on another origin to the constructor call, the &lt;a href=&quot;referrer&quot;&gt;&lt;code&gt;Request.referrer&lt;/code&gt;&lt;/a&gt; is stripped out.</source>
          <target state="translated">이 객체가 생성자 호출에 대한 다른 원점에 존재하면 &lt;a href=&quot;referrer&quot;&gt; &lt;code&gt;Request.referrer&lt;/code&gt; &lt;/a&gt; 가 제거됩니다.</target>
        </trans-unit>
        <trans-unit id="0a9b9a145de2a6314619e2cd2750576161bdbcf7" translate="yes" xml:space="preserve">
          <source>If this object has a &lt;a href=&quot;mode&quot;&gt;&lt;code&gt;Request.mode&lt;/code&gt;&lt;/a&gt; of &lt;code&gt;navigate&lt;/code&gt;, the &lt;code&gt;mode&lt;/code&gt; value is converted to &lt;code&gt;same-origin&lt;/code&gt;.</source>
          <target state="translated">이 객체가있는 경우 &lt;a href=&quot;mode&quot;&gt; &lt;code&gt;Request.mode&lt;/code&gt; &lt;/a&gt; 의 &lt;code&gt;navigate&lt;/code&gt; 상기 &lt;code&gt;mode&lt;/code&gt; 값으로 변환된다 &lt;code&gt;same-origin&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8464d5b656f662a859d9305d0b31c405ed9563b7" translate="yes" xml:space="preserve">
          <source>If this object store uses &lt;a href=&quot;https://developer.mozilla.org/en/IndexedDB#gloss_out-of-line_key&quot;&gt;out-of-line keys&lt;/a&gt;, and the &lt;em&gt;key&lt;/em&gt; parameter was not passed.</source>
          <target state="translated">이 오브젝트 저장소가 &lt;a href=&quot;https://developer.mozilla.org/en/IndexedDB#gloss_out-of-line_key&quot;&gt;회선 외부 키&lt;/a&gt; 를 사용하고 &lt;em&gt;키&lt;/em&gt; 매개 변수가 전달되지 않은 경우.</target>
        </trans-unit>
        <trans-unit id="988aae973788bf72d536a95c5394081256c4ab29" translate="yes" xml:space="preserve">
          <source>If this object store uses &lt;a href=&quot;https://developer.mozilla.org/en/IndexedDB#gloss_out-of-line_key&quot;&gt;out-of-line&lt;/a&gt; keys and no &lt;a href=&quot;https://developer.mozilla.org/en/IndexedDB#gloss_key_generator&quot;&gt;key generator&lt;/a&gt;, but no key was given.</source>
          <target state="translated">이 오브젝트 저장소가 &lt;a href=&quot;https://developer.mozilla.org/en/IndexedDB#gloss_out-of-line_key&quot;&gt;라인 외부&lt;/a&gt; 키를 사용하고 &lt;a href=&quot;https://developer.mozilla.org/en/IndexedDB#gloss_key_generator&quot;&gt;키 생성기가&lt;/a&gt; 없는 경우 키가 제공되지 않은 경우</target>
        </trans-unit>
        <trans-unit id="3a675912f6c8281883efae164dab5be8901f71b5" translate="yes" xml:space="preserve">
          <source>If this parameter is provided, the copy is given this string as its new file or directory name.</source>
          <target state="translated">이 매개 변수가 제공되면 사본에이 문자열이 새 파일 또는 디렉토리 이름으로 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="8ef9ceff27b1beac0d374916027f5d8c097cb9ec" translate="yes" xml:space="preserve">
          <source>If this parameter is provided, the entry is renamed to have this string as its new file or directory name.</source>
          <target state="translated">이 매개 변수가 제공되면이 문자열을 새 파일 또는 디렉토리 이름으로 사용하도록 항목 이름이 변경됩니다.</target>
        </trans-unit>
        <trans-unit id="0e88e09071a50b44c9024d17eed27919a85367c5" translate="yes" xml:space="preserve">
          <source>If this property exists on the options object when the &lt;a href=&quot;../mutationobserver/mutationobserver&quot;&gt;&lt;code&gt;MutationObserver()&lt;/code&gt;&lt;/a&gt; constructor is used to create a new &lt;code&gt;MutationObserver&lt;/code&gt;, attribute monitoring is enabled regardless of whether or not the &lt;a href=&quot;attributes&quot;&gt;&lt;code&gt;attributes&lt;/code&gt;&lt;/a&gt; property is &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">&lt;a href=&quot;../mutationobserver/mutationobserver&quot;&gt; &lt;code&gt;MutationObserver()&lt;/code&gt; &lt;/a&gt; 생성자를 사용하여 새 &lt;code&gt;MutationObserver&lt;/code&gt; 를 작성할 때이 특성이 옵션 오브젝트에 존재 하면 &lt;a href=&quot;attributes&quot;&gt; &lt;code&gt;attributes&lt;/code&gt; &lt;/a&gt; 특성이 &lt;code&gt;true&lt;/code&gt; 인지 여부에 관계없이 속성 모니터링이 사용 가능 합니다 .</target>
        </trans-unit>
        <trans-unit id="1fa4d4e330e18f43f3252f26f43d41377f124b08" translate="yes" xml:space="preserve">
          <source>If this property has a value, the &lt;a href=&quot;control&quot;&gt;&lt;code&gt;HTMLLabelElement.control&lt;/code&gt;&lt;/a&gt; property must refer to the same control.</source>
          <target state="translated">이 속성에 값이 있으면 &lt;a href=&quot;control&quot;&gt; &lt;code&gt;HTMLLabelElement.control&lt;/code&gt; &lt;/a&gt; 속성이 동일한 컨트롤을 참조해야합니다.</target>
        </trans-unit>
        <trans-unit id="a6a4cb5f92c5198381d5035daeb106335e31a1ae" translate="yes" xml:space="preserve">
          <source>If this property has a value, the &lt;a href=&quot;htmlfor&quot;&gt;&lt;code&gt;HTMLLabelElement.htmlFor&lt;/code&gt;&lt;/a&gt; property must refer to the same control.</source>
          <target state="translated">이 속성에 값이 있으면 &lt;a href=&quot;htmlfor&quot;&gt; &lt;code&gt;HTMLLabelElement.htmlFor&lt;/code&gt; &lt;/a&gt; 속성은 동일한 컨트롤을 참조해야합니다.</target>
        </trans-unit>
        <trans-unit id="cc6dce5ee2fa6492c276b6a1f5d3b57b25339b9d" translate="yes" xml:space="preserve">
          <source>If this property is &lt;code&gt;true&lt;/code&gt;, and the requested file or directory doesn't exist, the user agent should create it. The default is &lt;code&gt;false&lt;/code&gt;. The parent directory must already exist.</source>
          <target state="translated">이 특성이 &lt;code&gt;true&lt;/code&gt; 이고 요청 된 파일 또는 디렉토리가 존재하지 않으면 사용자 에이전트가 작성해야합니다. 기본값은 &lt;code&gt;false&lt;/code&gt; 입니다. 상위 디렉토리가 이미 존재해야합니다.</target>
        </trans-unit>
        <trans-unit id="56cbd842e5de84c065c75762857bf957d850825b" translate="yes" xml:space="preserve">
          <source>If this property is missing when the &lt;code&gt;DOMPointInit&lt;/code&gt; object is passed into &lt;code&gt;fromPoint()&lt;/code&gt;, the value is assumed to be 0 by default.</source>
          <target state="translated">&lt;code&gt;DOMPointInit&lt;/code&gt; 오브젝트가 &lt;code&gt;fromPoint()&lt;/code&gt; 로 전달 될 때이 특성이 누락되면 값은 기본적으로 0으로 가정됩니다.</target>
        </trans-unit>
        <trans-unit id="eea473389e69020a736003e04ee4fcf09d7091bf" translate="yes" xml:space="preserve">
          <source>If this property is null, the application must provide a key for each modification operation.</source>
          <target state="translated">이 특성이 널인 경우 애플리케이션은 각 수정 조작에 대한 키를 제공해야합니다.</target>
        </trans-unit>
        <trans-unit id="fe4ea43080775bc58b76d136bccd2e5b77d3de49" translate="yes" xml:space="preserve">
          <source>If this property is present, its value is always &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">이 특성이 존재하면 해당 값은 항상 &lt;code&gt;true&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="9dc0fa5180c50f85445e92045ffcab44b7b15877" translate="yes" xml:space="preserve">
          <source>If this property is successfully set, the port part of the origin is also set to null.</source>
          <target state="translated">이 특성이 성공적으로 설정되면 원점의 포트 부분도 널로 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="b1f347986ebf46364c0dd1f82b2008dd8f9b713a" translate="yes" xml:space="preserve">
          <source>If this property's value is a number, the user agent will attempt to obtain media whose latency tends to be as close as possible to this number given the capabilities of the hardware and the other constraints specified. Otherwise, the value of this &lt;a href=&quot;../constraindouble&quot;&gt;&lt;code&gt;ConstrainDouble&lt;/code&gt;&lt;/a&gt; will guide the user agent in its efforts to provide an exact match to the required latency (if &lt;code&gt;exact&lt;/code&gt; is specified or both &lt;code&gt;min&lt;/code&gt; and &lt;code&gt;max&lt;/code&gt; are provided and have the same value) or to a best-possible value.</source>
          <target state="translated">이 속성 값이 숫자이면 사용자 에이전트는 하드웨어의 기능 및 지정된 다른 제약 조건을 고려할 때 대기 시간이 가능한 한이 숫자에 가까운 경향이있는 미디어를 가져 오려고 시도합니다. 그렇지 않으면이 &lt;a href=&quot;../constraindouble&quot;&gt; &lt;code&gt;ConstrainDouble&lt;/code&gt; &lt;/a&gt; 의 값은 사용자 에이전트가 필요한 대기 시간 ( &lt;code&gt;exact&lt;/code&gt; 지정되거나 &lt;code&gt;min&lt;/code&gt; 과 &lt;code&gt;max&lt;/code&gt; 이 모두 제공되고 동일한 값을 갖는 경우) 또는 가장 적합한 값과 정확하게 일치하도록 노력할 것 입니다.</target>
        </trans-unit>
        <trans-unit id="9d3492b75ac61e72247d1dc6c2e274194874723c" translate="yes" xml:space="preserve">
          <source>If this style sheet is imported into the document using an &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/CSS/@import&quot;&gt;&lt;code&gt;@import&lt;/code&gt;&lt;/a&gt; rule, the &lt;code&gt;ownerRule&lt;/code&gt; property will return that &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/CSSImportRule&quot;&gt;&lt;code&gt;CSSImportRule&lt;/code&gt;&lt;/a&gt;, otherwise it returns &lt;code&gt;null&lt;/code&gt;.</source>
          <target state="translated">이 스타일 시트를 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/CSS/@import&quot;&gt; &lt;code&gt;@import&lt;/code&gt; &lt;/a&gt; 규칙을 사용하여 문서로 가져 오는 경우 &lt;code&gt;ownerRule&lt;/code&gt; 속성은 해당 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/CSSImportRule&quot;&gt; &lt;code&gt;CSSImportRule&lt;/code&gt; &lt;/a&gt; 을 반환하고 , 그렇지 않으면 &lt;code&gt;null&lt;/code&gt; 을 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="48b9c17fea0e0239ebfd170d61a1f9909377c7a7" translate="yes" xml:space="preserve">
          <source>If this transaction has already been committed or aborted.</source>
          <target state="translated">이 트랜잭션이 이미 커밋되었거나 중단 된 경우</target>
        </trans-unit>
        <trans-unit id="f02d9840f800de912e7d4d7e2fd53b49161158c3" translate="yes" xml:space="preserve">
          <source>If this transaction's scope is dynamic, and the browser cannot commit all of the changes due to another transaction.</source>
          <target state="translated">이 트랜잭션의 범위가 동적이고 브라우저가 다른 트랜잭션으로 인해 모든 변경 사항을 커밋 할 수없는 경우.</target>
        </trans-unit>
        <trans-unit id="fb2683fa2968a3f29629366d628fde46f8f2231f" translate="yes" xml:space="preserve">
          <source>If this value is &lt;code&gt;false&lt;/code&gt;, the children of entity reference nodes (as well as all of their descendants) are rejected. This takes precedence over the value of the &lt;a href=&quot;whattoshow&quot;&gt;&lt;code&gt;TreeWalker.whatToShow&lt;/code&gt;&lt;/a&gt; method and the associated filter.</source>
          <target state="translated">이 값이 &lt;code&gt;false&lt;/code&gt; 인 경우 엔티티 참조 노드의 하위 (및 모든 하위 항목)가 거부됩니다. 이것은 &lt;a href=&quot;whattoshow&quot;&gt; &lt;code&gt;TreeWalker.whatToShow&lt;/code&gt; &lt;/a&gt; 메소드 및 관련 필터 의 값보다 우선합니다 .</target>
        </trans-unit>
        <trans-unit id="c08d592b5865a2f3e455376b58da7bd81bf56aa9" translate="yes" xml:space="preserve">
          <source>If this value is &lt;code&gt;false&lt;/code&gt;, the shadow root will be the last node to be offered the event.</source>
          <target state="translated">이 값이 &lt;code&gt;false&lt;/code&gt; 인 경우 섀도우 루트는 이벤트가 제공 될 마지막 노드입니다.</target>
        </trans-unit>
        <trans-unit id="e25e6eed1e63b22db02c1db9290155b8da8da76a" translate="yes" xml:space="preserve">
          <source>If this value is a number, the user agent will attempt to obtain media whose aspect ratio is as close as possible to this number given the capabilities of the hardware and the other constraints specified. Otherwise, the value of this &lt;a href=&quot;../constraindouble&quot;&gt;&lt;code&gt;ConstrainDouble&lt;/code&gt;&lt;/a&gt; will guide the user agent in its efforts to provide an exact match to the required aspect ratio (if &lt;code&gt;exact&lt;/code&gt; is specified or both &lt;code&gt;min&lt;/code&gt; and &lt;code&gt;max&lt;/code&gt; are provided and have the same value) or to a best-possible value.</source>
          <target state="translated">이 값이 숫자 인 경우, 사용자 에이전트는 하드웨어의 기능 및 지정된 기타 제한 조건이 주어지면 종횡비가 가능한 한이 수에 가까운 매체를 확보하려고 시도합니다. 그렇지 않으면,이 &lt;a href=&quot;../constraindouble&quot;&gt; &lt;code&gt;ConstrainDouble&lt;/code&gt; &lt;/a&gt; 의 값은 사용자 에이전트가 필요한 종횡비 ( &lt;code&gt;exact&lt;/code&gt; 지정되거나 &lt;code&gt;min&lt;/code&gt; 과 &lt;code&gt;max&lt;/code&gt; 이 모두 제공되고 동일한 값을 갖는 경우) 또는 최상의 값 으로 정확하게 일치 시키도록 노력 합니다. .</target>
        </trans-unit>
        <trans-unit id="2eaca9fd692378e6e2f27b122f8cbc96660df0a0" translate="yes" xml:space="preserve">
          <source>If this value is a number, the user agent will attempt to obtain media whose channel count is as close as possible to this number given the capabilities of the hardware and the other constraints specified. Otherwise, the value of this &lt;a href=&quot;../constrainlong&quot;&gt;&lt;code&gt;ConstrainLong&lt;/code&gt;&lt;/a&gt; will guide the user agent in its efforts to provide an exact match to the required channel count (if &lt;code&gt;exact&lt;/code&gt; is specified or both &lt;code&gt;min&lt;/code&gt; and &lt;code&gt;max&lt;/code&gt; are provided and have the same value) or to a best-possible value.</source>
          <target state="translated">이 값이 숫자 인 경우, 사용자 에이전트는 하드웨어의 기능 및 지정된 다른 제한 조건을 고려하여 채널 수가이 수에 가능한 한 가까운 매체를 확보하려고 시도합니다. 그렇지 않으면,이 &lt;a href=&quot;../constrainlong&quot;&gt; &lt;code&gt;ConstrainLong&lt;/code&gt; &lt;/a&gt; 의 값은 필요한 채널 수 ( &lt;code&gt;exact&lt;/code&gt; 지정되거나 &lt;code&gt;min&lt;/code&gt; 과 &lt;code&gt;max&lt;/code&gt; 이 모두 제공되고 동일한 값을 갖는 경우) 또는 가장 적합한 값에 정확하게 일치하도록 사용자 에이전트의 노력을 안내합니다. .</target>
        </trans-unit>
        <trans-unit id="ba0c20e1b7b73619c72aaf78865c40f5d1158610" translate="yes" xml:space="preserve">
          <source>If this value is a number, the user agent will attempt to obtain media whose frame rate is as close as possible to this number given the capabilities of the hardware and the other constraints specified. Otherwise, the value of this &lt;a href=&quot;../constraindouble&quot;&gt;&lt;code&gt;ConstrainDouble&lt;/code&gt;&lt;/a&gt; will guide the user agent in its efforts to provide an exact match to the required frame rate (if &lt;code&gt;exact&lt;/code&gt; is specified or both &lt;code&gt;min&lt;/code&gt; and &lt;code&gt;max&lt;/code&gt; are provided and have the same value) or to a best-possible value.</source>
          <target state="translated">이 값이 숫자 인 경우, 사용자 에이전트는 하드웨어의 기능 및 지정된 다른 제한 조건을 고려하여 가능한 한 프레임 속도가이 수에 가까운 매체를 확보하려고 시도합니다. 그렇지 않으면이 &lt;a href=&quot;../constraindouble&quot;&gt; &lt;code&gt;ConstrainDouble&lt;/code&gt; &lt;/a&gt; 의 값은 사용자 에이전트가 필요한 프레임 속도 ( &lt;code&gt;exact&lt;/code&gt; 지정되거나 &lt;code&gt;min&lt;/code&gt; 과 &lt;code&gt;max&lt;/code&gt; 이 모두 제공되고 동일한 값을 갖는 경우) 또는 최상의 값 으로 정확하게 일치하도록 노력할 것입니다. .</target>
        </trans-unit>
        <trans-unit id="1370ba7eee25a5e460a344f9280339db2bd9a655" translate="yes" xml:space="preserve">
          <source>If this value is a number, the user agent will attempt to obtain media whose height is as close as possible to this number given the capabilities of the hardware and the other constraints specified. Otherwise, the value of this &lt;a href=&quot;../constrainlong&quot;&gt;&lt;code&gt;ConstrainLong&lt;/code&gt;&lt;/a&gt; will guide the user agent in its efforts to provide an exact match to the required height (if &lt;code&gt;exact&lt;/code&gt; is specified or both &lt;code&gt;min&lt;/code&gt; and &lt;code&gt;max&lt;/code&gt; are provided and have the same value) or to a best-possible value.</source>
          <target state="translated">이 값이 숫자 인 경우, 사용자 에이전트는 하드웨어의 기능 및 지정된 기타 제한 조건을 고려하여 가능한 한 높이가이 수에 가까운 매체를 확보하려고 시도합니다. 그렇지 않으면,이 &lt;a href=&quot;../constrainlong&quot;&gt; &lt;code&gt;ConstrainLong&lt;/code&gt; &lt;/a&gt; 의 값은 사용자 에이전트가 필요한 높이 ( &lt;code&gt;exact&lt;/code&gt; 이 지정되거나 &lt;code&gt;min&lt;/code&gt; 과 &lt;code&gt;max&lt;/code&gt; 이 모두 제공되고 동일한 값을 갖는 경우) 또는 최상의 값에 정확하게 일치하도록 노력할 것 입니다.</target>
        </trans-unit>
        <trans-unit id="e15acf76f62cbc2ad8a98b8a0ae681c657785db3" translate="yes" xml:space="preserve">
          <source>If this value is a number, the user agent will attempt to obtain media whose sample rate is as close as possible to this number given the capabilities of the hardware and the other constraints specified. Otherwise, the value of this &lt;a href=&quot;../constrainlong&quot;&gt;&lt;code&gt;ConstrainLong&lt;/code&gt;&lt;/a&gt; will guide the user agent in its efforts to provide an exact match to the required sample rate (if &lt;code&gt;exact&lt;/code&gt; is specified or both &lt;code&gt;min&lt;/code&gt; and &lt;code&gt;max&lt;/code&gt; are provided and have the same value) or to a best-possible value.</source>
          <target state="translated">이 값이 숫자 인 경우, 사용자 에이전트는 하드웨어의 기능 및 지정된 기타 제한 조건을 고려하여 샘플 속도가 가능한 한이 수에 가까운 매체를 확보하려고 시도합니다. 그렇지 않으면이 &lt;a href=&quot;../constrainlong&quot;&gt; &lt;code&gt;ConstrainLong&lt;/code&gt; &lt;/a&gt; 의 값은 사용자 에이전트가 필요한 샘플 속도 ( &lt;code&gt;exact&lt;/code&gt; 값을 지정하거나 &lt;code&gt;min&lt;/code&gt; 과 &lt;code&gt;max&lt;/code&gt; 모두 제공하고 동일한 값을 갖는 경우) 또는 가장 적합한 값과 정확하게 일치하도록 노력할 것입니다. .</target>
        </trans-unit>
        <trans-unit id="9461f678fa512ad88e94f7f44a1a48b4ae603ce1" translate="yes" xml:space="preserve">
          <source>If this value is a number, the user agent will attempt to obtain media whose sample size (in bits per linear sample) is as close as possible to this number given the capabilities of the hardware and the other constraints specified. Otherwise, the value of this &lt;a href=&quot;../constrainlong&quot;&gt;&lt;code&gt;ConstrainLong&lt;/code&gt;&lt;/a&gt; will guide the user agent in its efforts to provide an exact match to the required sample size (if &lt;code&gt;exact&lt;/code&gt; is specified or both &lt;code&gt;min&lt;/code&gt; and &lt;code&gt;max&lt;/code&gt; are provided and have the same value) or to a best-possible value.</source>
          <target state="translated">이 값이 숫자 인 경우, 사용자 에이전트는 하드웨어의 기능 및 지정된 다른 제한 조건을 고려하여 샘플 크기 (선형 샘플 당 비트 수)가이 수에 가능한 한 가까운 매체를 얻으려고 시도합니다. 그렇지 않으면,이 &lt;a href=&quot;../constrainlong&quot;&gt; &lt;code&gt;ConstrainLong&lt;/code&gt; &lt;/a&gt; 의 값은 사용자 샘플이 필요한 샘플 크기 ( &lt;code&gt;exact&lt;/code&gt; 지정되거나 &lt;code&gt;min&lt;/code&gt; 과 &lt;code&gt;max&lt;/code&gt; 이 모두 제공되고 동일한 값을 갖는 경우) 또는 가장 적합한 값과 정확하게 일치하도록 노력할 것입니다. .</target>
        </trans-unit>
        <trans-unit id="b7cf5d6b1ccabb8b5669dc6c913cd9f5094bfeea" translate="yes" xml:space="preserve">
          <source>If this value is a number, the user agent will attempt to obtain media whose volume is as close as possible to this number given the capabilities of the hardware and the other constraints specified. Otherwise, the value of this &lt;a href=&quot;../constraindouble&quot;&gt;&lt;code&gt;ConstrainDouble&lt;/code&gt;&lt;/a&gt; will guide the user agent in its efforts to provide an exact match to the required volume (if &lt;code&gt;exact&lt;/code&gt; is specified or both &lt;code&gt;min&lt;/code&gt; and &lt;code&gt;max&lt;/code&gt; are provided and have the same value) or to a best-possible value.</source>
          <target state="translated">이 값이 숫자 인 경우, 사용자 에이전트는 하드웨어의 기능 및 지정된 기타 제한 조건을 고려하여 볼륨이 가능한 한이 숫자에 가까운 매체를 확보하려고 시도합니다. 그렇지 않으면이 &lt;a href=&quot;../constraindouble&quot;&gt; &lt;code&gt;ConstrainDouble&lt;/code&gt; &lt;/a&gt; 의 값은 사용자 에이전트가 필요한 볼륨 ( &lt;code&gt;exact&lt;/code&gt; 지정되거나 &lt;code&gt;min&lt;/code&gt; 과 &lt;code&gt;max&lt;/code&gt; 이 모두 제공되고 동일한 값을 갖는 경우) 또는 최상의 값 으로 정확하게 일치하도록 노력할 것 입니다.</target>
        </trans-unit>
        <trans-unit id="0330a7cbf066a2ed1c5168d36c28d06e805b6d2c" translate="yes" xml:space="preserve">
          <source>If this value is a number, the user agent will attempt to obtain media whose width is as close as possible to this number given the capabilities of the hardware and the other constraints specified. Otherwise, the value of this &lt;a href=&quot;../constrainlong&quot;&gt;&lt;code&gt;ConstrainLong&lt;/code&gt;&lt;/a&gt; will guide the user agent in its efforts to provide an exact match to the required width (if &lt;code&gt;exact&lt;/code&gt; is specified or both &lt;code&gt;min&lt;/code&gt; and &lt;code&gt;max&lt;/code&gt; are provided and have the same value) or to a best-possible value.</source>
          <target state="translated">이 값이 숫자이면 사용자 에이전트는 하드웨어의 기능 및 지정된 기타 제한 조건을 고려하여 너비가이 숫자에 가능한 한 가까운 매체를 확보하려고 시도합니다. 그렇지 않으면이 &lt;a href=&quot;../constrainlong&quot;&gt; &lt;code&gt;ConstrainLong&lt;/code&gt; &lt;/a&gt; 의 값은 사용자 에이전트가 필요한 너비 ( &lt;code&gt;exact&lt;/code&gt; 이 지정되거나 &lt;code&gt;min&lt;/code&gt; 과 &lt;code&gt;max&lt;/code&gt; 이 모두 제공되고 동일한 값을 갖는 경우) 또는 가장 적합한 값과 정확히 일치하도록 노력할 것 입니다.</target>
        </trans-unit>
        <trans-unit id="3934d693082aa4e12edff2c4a9832abc994ba459" translate="yes" xml:space="preserve">
          <source>If this value is a simple &lt;code&gt;true&lt;/code&gt; or &lt;code&gt;false&lt;/code&gt;, the user agent will attempt to obtain media with automatic gain control enabled or disabled as specified, if possible, but will not fail if this can't be done. If, instead, the value is given as an object with an &lt;code&gt;exact&lt;/code&gt; field, that field's Boolean value indicates a required setting for the automatic gain control feature; if it can't be met, then the request will result in an error.</source>
          <target state="translated">이 값이 단순 &lt;code&gt;true&lt;/code&gt; 또는 &lt;code&gt;false&lt;/code&gt; 인 경우, 사용자 에이전트는 가능한 경우 지정된대로 자동 게인 제어를 사용하거나 사용하지 않는 매체를 확보하려고 시도하지만이를 수행 할 수없는 경우 실패하지 않습니다. 대신 값이 &lt;code&gt;exact&lt;/code&gt; 필드를 가진 객체로 제공되는 경우 해당 필드의 부울 값은 자동 게인 제어 기능에 필요한 설정을 나타냅니다. 충족되지 않으면 요청에 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="64d0cae4f6f98234458bcff499825639c04af0fe" translate="yes" xml:space="preserve">
          <source>If this value is a simple &lt;code&gt;true&lt;/code&gt; or &lt;code&gt;false&lt;/code&gt;, the user agent will attempt to obtain media with echo cancellation enabled or disabled as specified, if possible, but will not fail if this can't be done. If, instead, the value is given as an object with an &lt;code&gt;exact&lt;/code&gt; field, that field's Boolean value indicates a required setting for the echo cancellation feature; if it can't be met, then the request will result in an error.</source>
          <target state="translated">이 값이 단순 &lt;code&gt;true&lt;/code&gt; 또는 &lt;code&gt;false&lt;/code&gt; 인 경우, 사용자 에이전트는 가능하면 지정된대로 에코 제거가 사용 가능 또는 사용 불가능한 매체를 확보하려고 시도하지만이를 수행 할 수없는 경우 실패하지 않습니다. 대신 값이 &lt;code&gt;exact&lt;/code&gt; 필드를 가진 객체로 제공되는 경우 해당 필드의 부울 값은 에코 제거 기능에 필요한 설정을 나타냅니다. 충족되지 않으면 요청에 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="05d1cf6e8588fa2c1c00fd4d8ab5334007a32711" translate="yes" xml:space="preserve">
          <source>If this value is a simple &lt;code&gt;true&lt;/code&gt; or &lt;code&gt;false&lt;/code&gt;, the user agent will attempt to obtain media with noise suppression enabled or disabled as specified, if possible, but will not fail if this can't be done. If, instead, the value is given as an object with an &lt;code&gt;exact&lt;/code&gt; field, that field's Boolean value indicates a required setting for the noise suppression feature; if it can't be met, then the request will result in an error.</source>
          <target state="translated">이 값이 단순 &lt;code&gt;true&lt;/code&gt; 또는 &lt;code&gt;false&lt;/code&gt; 인 경우, 사용자 에이전트는 가능한 경우 지정된대로 노이즈 억제가 사용 가능 또는 사용 불가능한 매체를 확보하려고 시도하지만이를 수행 할 수 없으면 실패하지 않습니다. 대신 값이 &lt;code&gt;exact&lt;/code&gt; 필드를 가진 객체로 제공되는 경우 해당 필드의 부울 값은 노이즈 억제 기능에 필요한 설정을 나타냅니다. 충족되지 않으면 요청에 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="18d0a6eb920fbf28a566262066fad6a18776ff59" translate="yes" xml:space="preserve">
          <source>If this whitespace is removed from the source, the #text nodes are not inserted and the span element becomes the paragraph's first child.</source>
          <target state="translated">이 공백이 소스에서 제거되면 #text 노드가 삽입되지 않고 span 요소가 단락의 첫 번째 자식이됩니다.</target>
        </trans-unit>
        <trans-unit id="fd6e85a8fb95f1e5ed5752cf1c72d2f1a72f2f1c" translate="yes" xml:space="preserve">
          <source>If true, a key can have only one value within the index; if false, a key can have duplicate values.</source>
          <target state="translated">true 인 경우 키는 색인 내에서 하나의 값만 가질 수 있습니다. false 인 경우 키에 중복 값이있을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="75b5ef1465c573a74b71c6509940035d807b09ff" translate="yes" xml:space="preserve">
          <source>If true, keys in the index must be unique; if false, duplicate keys are allowed.</source>
          <target state="translated">true 인 경우 인덱스의 키는 고유해야합니다. false 인 경우 중복 키가 허용됩니다.</target>
        </trans-unit>
        <trans-unit id="3e46b9009b61994c41767f1dc3f9f0d452f53701" translate="yes" xml:space="preserve">
          <source>If true, the index will not allow duplicate values for a single key.</source>
          <target state="translated">true 인 경우 인덱스는 단일 키에 대한 중복 값을 허용하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="e6508d7d942e1ce228d883e27a5831c2a64188f7" translate="yes" xml:space="preserve">
          <source>If true, the object store uses a &lt;a href=&quot;https://developer.mozilla.org/en/IndexedDB#gloss_key_generator&quot;&gt;key generator&lt;/a&gt;; if false, it does not use one.</source>
          <target state="translated">true 인 경우 오브젝트 저장소는 &lt;a href=&quot;https://developer.mozilla.org/en/IndexedDB#gloss_key_generator&quot;&gt;키 생성기를&lt;/a&gt; 사용합니다 . False이면 하나를 사용하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="2a94364fb15d022d914d7625d18ee1706dcc268a" translate="yes" xml:space="preserve">
          <source>If true, this transaction is &lt;a href=&quot;https://developer.mozilla.org/en/IndexedDB#gloss_static&quot;&gt;static&lt;/a&gt;; if false, this transaction is &lt;a href=&quot;https://developer.mozilla.org/en/IndexedDB#gloss_dynamic&quot;&gt;dynamic&lt;/a&gt;.</source>
          <target state="translated">true 인 경우이 트랜잭션은 &lt;a href=&quot;https://developer.mozilla.org/en/IndexedDB#gloss_static&quot;&gt;정적입니다&lt;/a&gt; . false 인 경우이 트랜잭션은 &lt;a href=&quot;https://developer.mozilla.org/en/IndexedDB#gloss_dynamic&quot;&gt;동적&lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="787fc547467955e7d9ff69cafccc5c41eff6e56a" translate="yes" xml:space="preserve">
          <source>If trying to insert an &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/@import&quot;&gt;&lt;code&gt;@import&lt;/code&gt;&lt;/a&gt; at-rule after a style rule, then aborts with &lt;code&gt;HierarchyRequestError&lt;/code&gt;.</source>
          <target state="translated">스타일 규칙 다음에 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/@import&quot;&gt; &lt;code&gt;@import&lt;/code&gt; &lt;/a&gt; at-rule 을 삽입하려고하면 &lt;code&gt;HierarchyRequestError&lt;/code&gt; 로 중단됩니다 .</target>
        </trans-unit>
        <trans-unit id="7414a5f7be7d0708d8581f3d775e2d4ee76dd124" translate="yes" xml:space="preserve">
          <source>If unset, a default value of 1 will be used.</source>
          <target state="translated">설정하지 않으면 기본값 1이 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="ba98aac542ba9ab8bcea5ed73d15e09f7f116441" translate="yes" xml:space="preserve">
          <source>If unset, the app's (i.e. the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/html&quot;&gt;&lt;code&gt;&amp;lt;html&amp;gt;&lt;/code&gt;&lt;/a&gt;&lt;code&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/html#attr-lang&quot;&gt;lang&lt;/a&gt;&lt;/code&gt; value) lang will be used, or the user-agent default if that is unset too.</source>
          <target state="translated">설정하지 않으면 앱의 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/html&quot;&gt; &lt;code&gt;&amp;lt;html&amp;gt;&lt;/code&gt; &lt;/a&gt; &lt;code&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/html#attr-lang&quot;&gt;lang&lt;/a&gt;&lt;/code&gt; &amp;gt; lang 값이 lang이 사용되거나 설정되지 않은 경우 사용자 에이전트 기본값이 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="42ec04231d1c959c99f66d94119a9128c6dc59e6" translate="yes" xml:space="preserve">
          <source>If we add two &lt;code&gt;username&lt;/code&gt; values using &lt;a href=&quot;append&quot;&gt;&lt;code&gt;FormData.append&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">&lt;a href=&quot;append&quot;&gt; &lt;code&gt;FormData.append&lt;/code&gt; 를&lt;/a&gt; 사용하여 두 개의 &lt;code&gt;username&lt;/code&gt; 값을 추가하면 :</target>
        </trans-unit>
        <trans-unit id="8366613b40e6b5734855c52c6fdc953d4b64f9bf" translate="yes" xml:space="preserve">
          <source>If we click Back again, the URL will change to http://mozilla.org/foo.html, and the document will get a &lt;code&gt;popstate&lt;/code&gt; event, this time with a null state object. Here too, going back doesn't change the document's contents from what they were in the previous step, although the document might update its contents manually upon receiving the &lt;code&gt;popstate&lt;/code&gt; event.</source>
          <target state="translated">뒤로를 다시 클릭하면 URL이 http://mozilla.org/foo.html로 변경되고 이번에는 null 상태 객체와 함께 &lt;code&gt;popstate&lt;/code&gt; 이벤트가 발생합니다. &lt;code&gt;popstate&lt;/code&gt; 이벤트 를 수신하면 문서가 수동으로 내용을 업데이트 할 수 있지만, 여기서도 문서의 내용을 이전 단계에서 변경 한 내용으로 돌아 가지 않아도 됩니다.</target>
        </trans-unit>
        <trans-unit id="09814787827d8d9e075698c1079a803307130ada" translate="yes" xml:space="preserve">
          <source>If we compare clipping paths to the &lt;code&gt;globalCompositeOperation&lt;/code&gt; property we've seen above, we see two compositing modes that achieve more or less the same effect in &lt;code&gt;source-in&lt;/code&gt; and &lt;code&gt;source-atop&lt;/code&gt;. The most important differences between the two are that clipping paths are never actually drawn to the canvas and the clipping path is never affected by adding new shapes. This makes clipping paths ideal for drawing multiple shapes in a restricted area.</source>
          <target state="translated">클리핑 경로를 위에서 본 &lt;code&gt;globalCompositeOperation&lt;/code&gt; 속성 과 비교하면 &lt;code&gt;source-in&lt;/code&gt; 및 &lt;code&gt;source-atop&lt;/code&gt; 에서 거의 동일한 효과를 달성하는 두 가지 합성 모드가 표시 됩니다. 이 둘의 가장 중요한 차이점은 클리핑 경로가 실제로 캔버스에 그려지지 않으며 클리핑 경로가 새로운 모양을 추가해도 영향을받지 않는다는 것입니다. 이로 인해 클리핑 영역은 제한된 영역에서 여러 모양을 그리는 데 이상적입니다.</target>
        </trans-unit>
        <trans-unit id="1b43a0f19fb5a3f27351c4eee26cf4be0fd0230d" translate="yes" xml:space="preserve">
          <source>If we connect this through our audio graph and play it &amp;mdash;</source>
          <target state="translated">오디오 그래프를 통해 연결하여 재생하면 &amp;mdash;</target>
        </trans-unit>
        <trans-unit id="74f374d6e55f71d7dc71e7a4a4087018fd67c159" translate="yes" xml:space="preserve">
          <source>If we had left her paused at the beginning of her animation, she&amp;rsquo;d start at half her full size, as if she&amp;rsquo;d drunk the entire bottle already! We want to set her animation&amp;rsquo;s &amp;ldquo;playhead&amp;rdquo; in the middle, so she&amp;rsquo;s already halfway done. We could do that by setting her &lt;a href=&quot;../animation/currenttime&quot;&gt;&lt;code&gt;Animation.currentTime&lt;/code&gt;&lt;/a&gt; to 4 seconds, like so:</source>
          <target state="translated">애니메이션이 시작될 때 일시 중지 된 상태로 두었다면 이미 병 전체를 마신 것처럼 절반 크기로 시작합니다. 우리는 중간에 애니메이션의 &quot;재생 헤드&quot;를 설정하려고합니다. 그래서 그녀는 이미 반쯤 끝났습니다. 다음 과 같이 &lt;a href=&quot;../animation/currenttime&quot;&gt; &lt;code&gt;Animation.currentTime&lt;/code&gt; &lt;/a&gt; 을 4 초로 설정하면됩니다 .</target>
        </trans-unit>
        <trans-unit id="ab754374d2a15cbb098f64e44eb3c12aa6184ff5" translate="yes" xml:space="preserve">
          <source>If we pass the &lt;code&gt;user&lt;/code&gt; variable as the &lt;code&gt;label&lt;/code&gt; argument to the first invocation of &lt;code&gt;count()&lt;/code&gt;, and the string &quot;alice&quot; to the second:</source>
          <target state="translated">&lt;code&gt;count()&lt;/code&gt; 의 첫 번째 호출에 &lt;code&gt;user&lt;/code&gt; 변수를 &lt;code&gt;label&lt;/code&gt; 인수 로 전달하고 문자열 &quot;alice&quot;를 두 번째에 전달하는 경우 :</target>
        </trans-unit>
        <trans-unit id="80d4519876f16c973e699caecdedb2f99426107d" translate="yes" xml:space="preserve">
          <source>If we send &quot;MDN&quot;, we get these bytes:</source>
          <target state="translated">&quot;MDN&quot;을 보내면 다음 바이트를 얻습니다.</target>
        </trans-unit>
        <trans-unit id="1525bf158e48f2e869db05d0e153b4b945df23d5" translate="yes" xml:space="preserve">
          <source>If we send &quot;abcdef&quot;, we get these bytes:</source>
          <target state="translated">&quot;abcdef&quot;를 보내면 다음 바이트를 얻습니다.</target>
        </trans-unit>
        <trans-unit id="0e4263f67352922999f5fcb234bf534a1f187e2e" translate="yes" xml:space="preserve">
          <source>If we used &lt;code&gt;IDBKeyRange.upperBound(&quot;F&quot;, true);&lt;/code&gt;, then the range excludes &quot;F&quot;; and instead only includes the values before it.</source>
          <target state="translated">&lt;code&gt;IDBKeyRange.upperBound(&quot;F&quot;, true);&lt;/code&gt; 사용 했다면; 이면 범위는 &quot;F&quot;를 제외합니다. 대신 그 앞에 값만 포함합니다.</target>
        </trans-unit>
        <trans-unit id="b635034705d709476747d77292a6200e406b9d48" translate="yes" xml:space="preserve">
          <source>If we wanted to create an instance of this element programmatically, we'd use a call along the following lines:</source>
          <target state="translated">프로그래밍 방식으로이 요소의 인스턴스를 만들려면 다음 행을 따라 호출을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="030a680a1e30749f6317813c9f30736b70493e17" translate="yes" xml:space="preserve">
          <source>If we were being really clever, we would not only request the resource from the network; we would also save it into the cache so that later requests for that resource could be retrieved offline too! This would mean that if extra images were added to the Star Wars gallery, our app could automatically grab them and cache them. The following would do the trick:</source>
          <target state="translated">우리가 정말로 영리하다면, 우리는 네트워크로부터 자원을 요구할뿐만 아니라; 또한 나중에 해당 리소스에 대한 요청을 오프라인으로 검색 할 수 있도록 캐시에 저장합니다! 이는 Star Wars 갤러리에 추가 이미지가 추가 된 경우 앱이 자동으로 이미지를 가져 와서 캐시 할 수 있음을 의미합니다. 다음은 트릭을 수행하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="1b306d81f89e37cae5206bf0958e3404e2925328" translate="yes" xml:space="preserve">
          <source>If we're not replacing an existing ad, we need to append the element to the content area of the page using &lt;a href=&quot;../node/appendchild&quot;&gt;&lt;code&gt;Document.appendChild()&lt;/code&gt;&lt;/a&gt;. If we're replacing an ad, it's already there, with its contents replaced with the new ad's. Then we call the &lt;a href=&quot;../intersectionobserver/observe&quot;&gt;&lt;code&gt;observe()&lt;/code&gt;&lt;/a&gt; method on our Intersection Observer, &lt;code&gt;adObserver&lt;/code&gt;, to start watching the ad for changes to its intersection with the viewport. From now on, any time the ad becomes 100% obscured or even a single pixel becomes visible, or the ad passes through 75% visible in one way or another, the &lt;a href=&quot;#Handling_intersection_changes&quot;&gt;observer's callback&lt;/a&gt; is executed.</source>
          <target state="translated">기존 광고를 교체하지 않는 경우 &lt;a href=&quot;../node/appendchild&quot;&gt; &lt;code&gt;Document.appendChild()&lt;/code&gt; &lt;/a&gt; 사용하여 페이지의 콘텐츠 영역에 요소를 추가해야합니다 . 광고를 교체하는 경우 광고가 이미 있으며 새 광고로 내용이 바뀝니다. 그런 다음 교차 관찰자 인 &lt;code&gt;adObserver&lt;/code&gt; 에서 &lt;a href=&quot;../intersectionobserver/observe&quot;&gt; &lt;code&gt;observe()&lt;/code&gt; &lt;/a&gt; 메소드를 호출하여 광고가 뷰포트와의 교차로에 대한 변경 사항을보고 있는지 시작합니다. 이제부터는 광고가 100 % 가려 지거나 단일 픽셀이 표시되거나 광고가 어떤 방식 으로든 75 %가 표시 될 때마다 &lt;a href=&quot;#Handling_intersection_changes&quot;&gt;관찰자의 콜백&lt;/a&gt; 이 실행됩니다.</target>
        </trans-unit>
        <trans-unit id="16ba3da20f469e40adbb25397dc52912ddf7883d" translate="yes" xml:space="preserve">
          <source>If you abort the transaction, then all requests still in progress receive this error.</source>
          <target state="translated">트랜잭션을 중단하면 여전히 진행중인 모든 요청에이 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="b2410fdf552e64e1575f3dc6d527cb3c2b84c970" translate="yes" xml:space="preserve">
          <source>If you absolutely need to reach the target value by a specific time, you can use &lt;a href=&quot;exponentialramptovalueattime&quot;&gt;&lt;code&gt;AudioParam.exponentialRampToValueAtTime()&lt;/code&gt;&lt;/a&gt;. However, for mathematical reasons, that method does not work if the current value or the target value is &lt;code&gt;0&lt;/code&gt;.</source>
          <target state="translated">특정 시간까지 목표 값에 도달해야하는 경우 &lt;a href=&quot;exponentialramptovalueattime&quot;&gt; &lt;code&gt;AudioParam.exponentialRampToValueAtTime()&lt;/code&gt; &lt;/a&gt; 사용할 수 있습니다 . 그러나 수학적 이유로 현재 값 또는 목표 값이 &lt;code&gt;0&lt;/code&gt; 이면 해당 방법이 작동하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="7055cfa5385f630e49a045f7b52e9411d59bbdab" translate="yes" xml:space="preserve">
          <source>If you already have an MP4, but it's not properly fragmented, you can again use ffmpeg:</source>
          <target state="translated">이미 MP4가 있지만 제대로 조각화되지 않은 경우 ffmpeg를 다시 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="fd2207f2255dc4f6a14937f654b20772bb333a4d" translate="yes" xml:space="preserve">
          <source>If you are creating a sandbox, and want &lt;code&gt;indexedDB&lt;/code&gt; to be available in it, use the &lt;code&gt;wantGlobalProperties&lt;/code&gt; option in the &lt;code&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Mozilla/Tech/XPCOM/Language_Bindings/Components.utils.Sandbox&quot;&gt;Sandbox&lt;/a&gt;&lt;/code&gt; constructor:</source>
          <target state="translated">샌드 박스를 작성 &lt;code&gt;indexedDB&lt;/code&gt; 를 사용할 수있게 하려면 &lt;code&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Mozilla/Tech/XPCOM/Language_Bindings/Components.utils.Sandbox&quot;&gt;Sandbox&lt;/a&gt;&lt;/code&gt; 생성자 에서 &lt;code&gt;wantGlobalProperties&lt;/code&gt; 옵션을 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="edd8337dc642f1528ec438dbd0731164bbbf1e37" translate="yes" xml:space="preserve">
          <source>If you are curious about the effect the &lt;code&gt;smoothingTimeConstant()&lt;/code&gt; has, try cloning the above example and setting &lt;code&gt;analyser.smoothingTimeConstant = 0;&lt;/code&gt; instead. You'll notice that the value changes are much more jarring.</source>
          <target state="translated">&lt;code&gt;smoothingTimeConstant()&lt;/code&gt; 의 효과에 대해 궁금한 경우 위 예제를 복제하고 &lt;code&gt;analyser.smoothingTimeConstant = 0;&lt;/code&gt; 대신에. 값 변경이 훨씬 더 심각하다는 것을 알 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f0001dee6353c2d2d91bea5ccfb1296fb48b2512" translate="yes" xml:space="preserve">
          <source>If you are looking for sound creation or a more instrument-based option, &lt;a href=&quot;https://tonejs.github.io/&quot;&gt;tone.js&lt;/a&gt; is a great library. It provides advanced scheduling capabilities, synths, and effects, and intuitive musical abstractions built on top of the Web Audio API.</source>
          <target state="translated">사운드 생성 또는 더 많은 악기 기반 옵션을 찾고 있다면 &lt;a href=&quot;https://tonejs.github.io/&quot;&gt;tone.js&lt;/a&gt; 는 훌륭한 라이브러리입니다. 웹 오디오 API 위에 구축 된 고급 스케줄링 기능, 신디사이저 및 효과, 직관적 인 음악 추상화를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="fd1c0b03dfe77fddf22e3a0c1f4f4c078e3cfb61" translate="yes" xml:space="preserve">
          <source>If you are looking to learn more there's some &lt;a href=&quot;http://www.eas.uccs.edu/~mwickert/ece2610/lecture_notes/ece2610_chap8.pdf&quot;&gt;information about the maths behind IIR filters here&lt;/a&gt;. This enters the realms of signal processing theory &amp;mdash; don't worry if you look at it and feel like it's not for you.</source>
          <target state="translated">자세한 &lt;a href=&quot;http://www.eas.uccs.edu/~mwickert/ece2610/lecture_notes/ece2610_chap8.pdf&quot;&gt;내용을 보려면 여기 IIR 필터 배후의 수학에 대한 정보가 있습니다&lt;/a&gt; . 이것은 신호 처리 이론의 영역으로 들어갑니다. 그것을보고 자신이 아닌 것처럼 느끼더라도 걱정하지 마십시오.</target>
        </trans-unit>
        <trans-unit id="f05e5f9f48859cd19de921ce6a726468b9e6a2a8" translate="yes" xml:space="preserve">
          <source>If you are more familiar with the musical side of things, are familiar with music theory concepts, want to start building instruments, then you can go ahead and start building things with the advance tutorial and others as a guide (the above linked tutorial covers scheduling notes, creating bespoke oscillators and envelopes, as well as an LFO among other things.)</source>
          <target state="translated">사물의 음악적 측면에 더 익숙하고 음악 이론 개념에 익숙하고 악기 제작을 시작하려는 경우 고급 자습서 및 기타를 가이드로 사용하여 사물을 제작할 수 있습니다 (위의 링크 된 자습서는 일정 예약을 다룹니다) 노트, 맞춤형 오실레이터 및 엔벌 로프 및 LFO 생성 등)</target>
        </trans-unit>
        <trans-unit id="04b9c1de10d5d30df3d031b715c337793e1f3b7c" translate="yes" xml:space="preserve">
          <source>If you are using WebGL 2, you can specify the index yourself in the vertex shader code and override the default used by the graphics card, e.g. &lt;code&gt;layout(location = 3) in vec4 position;&lt;/code&gt; would set the &lt;code&gt;&quot;position&quot;&lt;/code&gt; attribute to index 3.</source>
          <target state="translated">WebGL 2를 사용하는 경우 정점 셰이더 코드에서 직접 색인을 지정하고 그래픽 카드에서 사용하는 기본값을 재정의 할 수 있습니다 &lt;code&gt;layout(location = 3) in vec4 position;&lt;/code&gt; 예 : vec4 위치의 layout (location = 3)). &lt;code&gt;&quot;position&quot;&lt;/code&gt; 속성을 인덱스 3으로 설정합니다 .</target>
        </trans-unit>
        <trans-unit id="8e81e6135fc857f9359e901bba04031911dc8a57" translate="yes" xml:space="preserve">
          <source>If you are working with 3D games and/or WebXR it's a good idea to harness a 3D library to create such functionality, rather than trying to do this all yourself from first principles. We rolled our own in this article to give you an idea of how it works, but you'll save a lot of time by taking advantage of work others have done before you.</source>
          <target state="translated">3D 게임 및 / 또는 WebXR로 작업하는 경우 첫 번째 원칙에서이 모든 것을 직접 시도하는 대신 3D 라이브러리를 활용하여 이러한 기능을 만드는 것이 좋습니다. 우리는이 기사에서 어떻게 작동하는지에 대한 아이디어를 제공하기 위해 우리 자신을 굴 렸지 만 다른 사람들이 전에 한 일을 활용하면 많은 시간을 절약 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d0b7320532a67868b56229485742f3322af62ec8" translate="yes" xml:space="preserve">
          <source>If you aren't familiar with the programming basics, you might want to consult some beginner's JavaScript tutorials first and then come back here &amp;mdash; see our &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Learn/JavaScript&quot;&gt;Beginner's JavaScript learning module&lt;/a&gt; for a great place to begin.</source>
          <target state="translated">프로그래밍 기본 사항에 익숙하지 않은 경우 먼저 초보자의 JavaScript 자습서를 참조한 다음 여기로 돌아와야합니다. &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Learn/JavaScript&quot;&gt;초보자의 JavaScript 학습 모듈&lt;/a&gt; 을 참조 하여 시작하십시오.</target>
        </trans-unit>
        <trans-unit id="b9761ab0d4ea2e47acf89062aeb015339328d406" translate="yes" xml:space="preserve">
          <source>If you attempt to add data twice with the same format, the new data will replace the old data, but in the same position within the list of types as the old data.</source>
          <target state="translated">동일한 형식으로 데이터를 두 번 추가하려고하면 새 데이터가 기존 데이터를 대체하지만 이전 데이터와 유형 목록 내에서 동일한 위치에있게됩니다.</target>
        </trans-unit>
        <trans-unit id="afaa46a6d52eadf87678d2954da32d35205ea757" translate="yes" xml:space="preserve">
          <source>If you call &lt;code&gt;HTMLElement.focus()&lt;/code&gt; from a mousedown event handler, you must call &lt;code&gt;event.preventDefault()&lt;/code&gt; to keep the focus from leaving the &lt;code&gt;HTMLElement&lt;/code&gt;.</source>
          <target state="translated">당신이 호출하면 &lt;code&gt;HTMLElement.focus()&lt;/code&gt; mouseDown 이벤트 핸들러에서, 당신은 호출해야 &lt;code&gt;event.preventDefault()&lt;/code&gt; 떠나는에서 초점을 유지하기 &lt;code&gt;HTMLElement&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8ab5182ffbcd4070523ad1b98fb9fd7a5f3ab0b9" translate="yes" xml:space="preserve">
          <source>If you call &lt;code&gt;mozCaptureMediaStream()&lt;/code&gt; on a media element with no source media, its compatibility mode will be based on the first source that's added; for example, if it's a &lt;code&gt;MediaStream&lt;/code&gt;, then the capture stream will only work with MediaStream sources from then on.</source>
          <target state="translated">소스 미디어가없는 미디어 요소에서 &lt;code&gt;mozCaptureMediaStream()&lt;/code&gt; 을 호출하면 호환성 모드는 추가 된 첫 번째 소스를 기반으로합니다. 예를 들어 &lt;code&gt;MediaStream&lt;/code&gt; 인 경우 캡처 스트림은 그때부터 MediaStream 소스에서만 작동합니다.</target>
        </trans-unit>
        <trans-unit id="42c4bfc8ec8de17db8cf0ec9ca954cce8013c199" translate="yes" xml:space="preserve">
          <source>If you call &lt;code&gt;observe()&lt;/code&gt; on a node that's already being observed by the same &lt;code&gt;MutationObserver&lt;/code&gt;, all existing observers are automatically removed from all targets being observed before the new observer is activated.</source>
          <target state="translated">동일한 &lt;code&gt;MutationObserver&lt;/code&gt; 가 이미 관찰하고있는 노드에서 &lt;code&gt;observe()&lt;/code&gt; 를 호출 하면 새 관찰자가 활성화되기 전에 기존의 모든 관찰자가 관찰중인 모든 대상에서 자동으로 제거됩니다.</target>
        </trans-unit>
        <trans-unit id="3c3d70903ce458191517fa8b297bbe273c449c8f" translate="yes" xml:space="preserve">
          <source>If you called</source>
          <target state="translated">전화하면</target>
        </trans-unit>
        <trans-unit id="62d49c5983354ff778117cc6ae15e97799f7fd3b" translate="yes" xml:space="preserve">
          <source>If you called the following in a document served at &lt;code&gt;localhost:8000&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;localhost:8000&lt;/code&gt; 에서 제공되는 문서에서 다음을 호출 한 경우 : 8000</target>
        </trans-unit>
        <trans-unit id="02a1c6b82a7457caaaa0c3fbf3e5f5ea1aa2451a" translate="yes" xml:space="preserve">
          <source>If you conclude with an XMLHttpRequest receiving &lt;code&gt;status=0&lt;/code&gt; and &lt;code&gt;statusText=null&lt;/code&gt;, this means the request was not allowed to be performed. It was &lt;code&gt;&lt;a href=&quot;https://xhr.spec.whatwg.org/#dom-xmlhttprequest-unsent&quot;&gt;UNSENT&lt;/a&gt;&lt;/code&gt;. A likely cause for this is when the &lt;a href=&quot;https://www.w3.org/TR/2010/CR-XMLHttpRequest-20100803/#xmlhttprequest-origin&quot;&gt;&lt;code&gt;XMLHttpRequest&lt;/code&gt; origin&lt;/a&gt; (at the creation of the XMLHttpRequest) has changed when the XMLHttpRequest is subsequently &lt;code&gt;open()&lt;/code&gt;. This case can happen, for example, when one has an XMLHttpRequest that gets fired on an onunload event for a window, the expected XMLHttpRequest is created when the window to be closed is still there, and finally sending the request (in otherwords, &lt;code&gt;open()&lt;/code&gt;) when this window has lost its focus and another window gains focus. The most effective way to avoid this problem is to set a listener on the new window's &lt;code&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Events/activate&quot;&gt;activate&lt;/a&gt;&lt;/code&gt; event which is set once the terminated window has its &lt;code&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Events/unload&quot;&gt;unload&lt;/a&gt;&lt;/code&gt; event triggered.</source>
          <target state="translated">&lt;code&gt;status=0&lt;/code&gt; 및 &lt;code&gt;statusText=null&lt;/code&gt; 을 받는 XMLHttpRequest로 결론을 내면 요청을 수행 할 수 없었 음을 의미합니다. 그것은 &lt;code&gt;&lt;a href=&quot;https://xhr.spec.whatwg.org/#dom-xmlhttprequest-unsent&quot;&gt;UNSENT&lt;/a&gt;&lt;/code&gt; . 이에 대한 원인은 언제 &lt;a href=&quot;https://www.w3.org/TR/2010/CR-XMLHttpRequest-20100803/#xmlhttprequest-origin&quot;&gt; &lt;code&gt;XMLHttpRequest&lt;/code&gt; 원점&lt;/a&gt; 는 XMLHttpRequest 이후 인 경우 (XMLHttpRequest의 생성시가) 변경 &lt;code&gt;open()&lt;/code&gt; . 예를 들어, 윈도우에 대한 onunload 이벤트에서 발생하는 XMLHttpRequest가있는 경우, 닫힌 윈도우가 여전히있을 때 예상되는 XMLHttpRequest가 생성되어 최종적으로 요청을 보냅니다 (즉, &lt;code&gt;open()&lt;/code&gt; )가이 창의 포커스를 잃고 다른 창의 포커스를 얻는 경우. 이 문제를 피하는 가장 효과적인 방법 은 종료 된 창의 &lt;code&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Events/unload&quot;&gt;unload&lt;/a&gt;&lt;/code&gt; 이벤트가 트리거 되면 새 창의 &lt;code&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Events/activate&quot;&gt;activate&lt;/a&gt;&lt;/code&gt; 이벤트 에 리스너를 설정하는 것 입니다.</target>
        </trans-unit>
        <trans-unit id="661c81723acf947ee69db4acdda14884afb70b75" translate="yes" xml:space="preserve">
          <source>If you consider a path from (3,1) to (3,5) with a line thickness of &lt;code&gt;1.0&lt;/code&gt;, you end up with the situation in the second image. The actual area to be filled (dark blue) only extends halfway into the pixels on either side of the path. An approximation of this has to be rendered, which means that those pixels being only partially shaded, and results in the entire area (the light blue and dark blue) being filled in with a color only half as dark as the actual stroke color. This is what happens with the &lt;code&gt;1.0&lt;/code&gt; width line in the previous example code.</source>
          <target state="translated">선 두께가 &lt;code&gt;1.0&lt;/code&gt; 인 (3,1)에서 (3,5)까지의 경로를 고려 하면 두 번째 이미지의 상황이 발생합니다. 채워질 실제 영역 (진한 파란색)은 경로의 양쪽에있는 픽셀의 절반으로 만 확장됩니다. 이 근사값을 렌더링해야합니다. 즉, 해당 픽셀은 부분적으로 만 음영 처리되어 전체 영역 (하늘색 및 진한 파란색)이 실제 획 색상의 절반만큼 어두운 색으로 채워집니다. 이것은 이전 예제 코드에서 &lt;code&gt;1.0&lt;/code&gt; 너비 라인에서 발생하는 것 입니다.</target>
        </trans-unit>
        <trans-unit id="e3734c5c1f3e0c2ce2a977e9a0a9a21e528b0ab5" translate="yes" xml:space="preserve">
          <source>If you do expect to receive messages from other sites, &lt;strong&gt;always verify the sender's identity&lt;/strong&gt; using the &lt;code&gt;origin&lt;/code&gt; and possibly &lt;code&gt;source&lt;/code&gt; properties. Any window (including, for example, &lt;code&gt;http://evil.example.com&lt;/code&gt;) can send a message to any other window, and you have no guarantees that an unknown sender will not send malicious messages. Having verified identity, however, you still should &lt;strong&gt;always verify the syntax of the received message&lt;/strong&gt;. Otherwise, a security hole in the site you trusted to send only trusted messages could then open a cross-site scripting hole in your site.</source>
          <target state="translated">다른 사이트에서 메시지를받을 것으로 예상되는 경우 &lt;strong&gt;항상 &lt;/strong&gt; &lt;code&gt;origin&lt;/code&gt; 및 가능하면 &lt;code&gt;source&lt;/code&gt; 속성을 사용하여 &lt;strong&gt;발신자의 신원&lt;/strong&gt; 을 &lt;strong&gt;확인하십시오&lt;/strong&gt; . 모든 창 (예를 들어 포함한, &lt;code&gt;http://evil.example.com&lt;/code&gt; ) 다른 창으로 메시지를 보낼 수 있습니다, 당신은 알 수없는 보낸 사람이 악의적 인 메시지를 전송하지 않는다는 보장이 없습니다. 그러나 신원을 확인한 후에도 &lt;strong&gt;수신 된 메시지의 구문을 항상 확인&lt;/strong&gt; 해야 &lt;strong&gt;합니다&lt;/strong&gt; . 그렇지 않으면 신뢰할 수있는 메시지 만 보내도록 신뢰할 수있는 사이트의 보안 허점이 사이트에서 크로스 사이트 스크립팅 구멍을 열 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="575cbc7335392e01427e6c47bcdd84e2f16293fe" translate="yes" xml:space="preserve">
          <source>If you do not require explicit control of video quality over time, the rate at which content is fetched, or the rate at which memory is evicted, then the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/video&quot;&gt;&lt;code&gt;&amp;lt;video&amp;gt;&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/source&quot;&gt;&lt;code&gt;&amp;lt;source&amp;gt;&lt;/code&gt;&lt;/a&gt; tags may well be a simple and adequate solution.</source>
          <target state="translated">시간이 지남에 따라 비디오 품질을 명시 적으로 제어 할 필요가없는 경우, 컨텐츠를 가져 오는 속도 또는 메모리가 제거되는 속도는 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/video&quot;&gt; &lt;code&gt;&amp;lt;video&amp;gt;&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/source&quot;&gt; &lt;code&gt;&amp;lt;source&amp;gt;&lt;/code&gt; &lt;/a&gt; 태그가 간단하고 적절한 솔루션 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="57d43ec9fc0d30b73ed2078791c13a040d0c62b7" translate="yes" xml:space="preserve">
          <source>If you don't provide certificates, new ones are generated automatically. One obvious benefit to providing your own is identity key continuity&amp;mdash;if you use the same certificate for subsequent calls, the remote peer can tell you're the same caller. This also avoids the cost of generating new keys.</source>
          <target state="translated">인증서를 제공하지 않으면 새 인증서가 자동으로 생성됩니다. 자신 만의 고유 한 이점을 제공하는 한 가지 확실한 이점은 ID 키 연속성입니다. 후속 통화에 동일한 인증서를 사용하면 원격 피어가 동일한 발신자임을 알 수 있습니다. 또한 새 키를 생성하는 비용을 피할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="38368e7efde0b743a004f5c93b88a6290e75dbb7" translate="yes" xml:space="preserve">
          <source>If you don't want any user interaction you can use the &lt;code&gt;setInterval()&lt;/code&gt; function which repeatedly executes the supplied code. If we wanted to make a game, we could use keyboard or mouse events to control the animation and use &lt;code&gt;setTimeout()&lt;/code&gt;. By setting &lt;a href=&quot;../../eventlistener&quot;&gt;&lt;code&gt;EventListener&lt;/code&gt;&lt;/a&gt;s, we catch any user interaction and execute our animation functions.</source>
          <target state="translated">사용자 상호 작용을 원하지 않으면 제공된 코드를 반복적으로 실행하는 &lt;code&gt;setInterval()&lt;/code&gt; 함수를 사용할 수 있습니다 . 게임을 만들고 싶다면 키보드 또는 마우스 이벤트를 사용하여 애니메이션을 제어하고 &lt;code&gt;setTimeout()&lt;/code&gt; 사용할 수 있습니다 . &lt;a href=&quot;../../eventlistener&quot;&gt; &lt;code&gt;EventListener&lt;/code&gt; &lt;/a&gt; 를 설정 하면 사용자 상호 작용을 포착하고 애니메이션 기능을 실행합니다.</target>
        </trans-unit>
        <trans-unit id="896b96919c447fa8937a6402f3678b56feea94ff" translate="yes" xml:space="preserve">
          <source>If you dont want to create a history entry, replace &lt;code&gt;open()&lt;/code&gt; with &lt;code&gt;open(&quot;text/html&quot;, &quot;replace&quot;)&lt;/code&gt;.</source>
          <target state="translated">히스토리 항목을 작성하지 않으 &lt;code&gt;open()&lt;/code&gt; 을 &lt;code&gt;open(&quot;text/html&quot;, &quot;replace&quot;)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="be55dd52a47373be153ea036d27e6db2c1054994" translate="yes" xml:space="preserve">
          <source>If you find yourself repeating some of the same drawing operations on each animation frame, consider offloading them to an offscreen canvas. You can then render the offscreen image to your primary canvas as often as needed, without unnecessarily repeating the steps needed to generate it in the first place.</source>
          <target state="translated">각 애니메이션 프레임에서 동일한 그리기 작업을 반복하는 경우 오프 스크린 캔버스로 오프로드하는 것을 고려하십시오. 그런 다음 오프 스크린 이미지를 처음에 생성하는 데 필요한 단계를 불필요하게 반복하지 않고도 필요할 때마다 기본 캔버스에 오프 스크린 이미지를 렌더링 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1a54c5e183d16edd92268d0af89ec0b5eafbbed1" translate="yes" xml:space="preserve">
          <source>If you had some functionality written in a separate script called &lt;code&gt;foo.js&lt;/code&gt; that you wanted to use inside worker.js, you could import it using the following line:</source>
          <target state="translated">worker.js 내부에서 사용하려는 &lt;code&gt;foo.js&lt;/code&gt; 라는 별도의 스크립트로 작성된 일부 기능이있는 경우 다음 행을 사용하여 가져올 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="98a8473722895746b277ae74166995438d8c08fa" translate="yes" xml:space="preserve">
          <source>If you have a &lt;a href=&quot;../dompointreadonly&quot;&gt;&lt;code&gt;DOMPointReadOnly&lt;/code&gt;&lt;/a&gt; object, you can easily create a mutable copy of that point:</source>
          <target state="translated">&lt;a href=&quot;../dompointreadonly&quot;&gt; &lt;code&gt;DOMPointReadOnly&lt;/code&gt; &lt;/a&gt; 객체 가있는 경우 해당 지점의 변경 가능한 복사본을 쉽게 만들 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c933359e511b60e5d6abf0cae2ca1f259bce0d8c" translate="yes" xml:space="preserve">
          <source>If you have a &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/FileSystemFileEntry&quot;&gt;&lt;code&gt;FileSystemFileEntry&lt;/code&gt;&lt;/a&gt; corresponding to an image file in a file system available to your Web site or app, you can call &lt;code&gt;toURL()&lt;/code&gt; to get its URL for use in HTML. If your site is located at &lt;code&gt;http://my-awesome-website.woot&lt;/code&gt;, and you have a temporary file system that contains an image file named &lt;code&gt;awesomesauce.jpg&lt;/code&gt;, the URL returned by &lt;code&gt;toURL()&lt;/code&gt; might be (depending on the browser's implementation) something like &lt;code&gt;&quot;filesystem:http://my-awesome-website.woot/temporary/awesomesauce.jpg&quot;&lt;/code&gt;.</source>
          <target state="translated">웹 사이트 나 앱에서 사용할 수있는 파일 시스템의 이미지 파일에 해당 하는 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/FileSystemFileEntry&quot;&gt; &lt;code&gt;FileSystemFileEntry&lt;/code&gt; &lt;/a&gt; 가있는 경우 &lt;code&gt;toURL()&lt;/code&gt; 을 호출 하여 HTML에서 사용할 URL을 얻을 수 있습니다. 사이트가 &lt;code&gt;http://my-awesome-website.woot&lt;/code&gt; 에 있고 &lt;code&gt;awesomesauce.jpg&lt;/code&gt; 라는 이미지 파일이 포함 된 임시 파일 시스템을 사용 하는 경우 브라우저의 구현에 따라 &lt;code&gt;toURL()&lt;/code&gt; 이 반환 한 URL이 ) &lt;code&gt;&quot;filesystem:http://my-awesome-website.woot/temporary/awesomesauce.jpg&quot;&lt;/code&gt; 와 같은 것 입니다.</target>
        </trans-unit>
        <trans-unit id="6b990e08e62a8943742c167bd89389b32a940d54" translate="yes" xml:space="preserve">
          <source>If you have a static background image, you can draw it onto a plain &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/div&quot;&gt;&lt;code&gt;&amp;lt;div&amp;gt;&lt;/code&gt;&lt;/a&gt; element using the CSS &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/CSS/background&quot;&gt;&lt;code&gt;background&lt;/code&gt;&lt;/a&gt; property and position it under the canvas. This will negate the need to render the background to the canvas on every tick.</source>
          <target state="translated">정적 배경 이미지가있는 경우 CSS &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/CSS/background&quot;&gt; &lt;code&gt;background&lt;/code&gt; &lt;/a&gt; 속성을 사용하여 일반 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/div&quot;&gt; &lt;code&gt;&amp;lt;div&amp;gt;&lt;/code&gt; &lt;/a&gt; 요소에 이미지를 그리고 캔버스 아래에 배치 할 수 있습니다. 이렇게하면 모든 틱마다 배경을 캔버스에 렌더링 할 필요가 없습니다.</target>
        </trans-unit>
        <trans-unit id="7a83b9398cf36635c6523c8dd011e90d1ee027e1" translate="yes" xml:space="preserve">
          <source>If you have an asset that is not already an MP4, ffmpeg can handle emitting a properly fragmented MP4 during the transcode process, with the &lt;code&gt;-movflags frag_keyframe+empty_moov&lt;/code&gt; command line flag:</source>
          <target state="translated">아직 MP4가 아닌 자산이있는 경우 ffmpeg는 코드 변환 프로세스 중에 &lt;code&gt;-movflags frag_keyframe+empty_moov&lt;/code&gt; 명령 행 플래그를 사용 하여 올바르게 조각난 MP4 방출을 처리 할 수 ​​있습니다 .</target>
        </trans-unit>
        <trans-unit id="095a4a14ce354bc5e83f4d9876f2d411d3a15a89" translate="yes" xml:space="preserve">
          <source>If you have any comments about this tutorial or want to thank us, feel free to reach out to us!</source>
          <target state="translated">이 튜토리얼에 대한 의견이 있거나 감사의 말씀을 전하는 경우 언제든지 문의 해주세요.</target>
        </trans-unit>
        <trans-unit id="5b4be0a31efd63f2b8928e0cc0238e6f8e03ebb5" translate="yes" xml:space="preserve">
          <source>If you have assumptions from working with other types of databases, you might get thrown off when working with IndexedDB. So keep the following important concepts in mind:</source>
          <target state="translated">다른 유형의 데이터베이스 작업에 대한 가정이있는 경우 IndexedDB로 작업 할 때 중단 될 수 있습니다. 따라서 다음과 같은 중요한 개념을 명심하십시오.</target>
        </trans-unit>
        <trans-unit id="40285cca9db9203d6467d842288d85c4143eff0d" translate="yes" xml:space="preserve">
          <source>If you have buttons that switch audio on and off, using the ARIA &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Accessibility/ARIA/Roles/Switch_role&quot;&gt;&lt;code&gt;role=&quot;switch&quot;&lt;/code&gt;&lt;/a&gt; attribute on them is a good option for signalling to assistive technology what the button's exact purpose is, and therefore making the app more accessible. There's a &lt;a href=&quot;https://codepen.io/Wilto/pen/ZoGoQm?editors=1100&quot;&gt;demo of how to use it here&lt;/a&gt;.</source>
          <target state="translated">오디오를 켜고 끄는 버튼이있는 경우 ARIA &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Accessibility/ARIA/Roles/Switch_role&quot;&gt; &lt;code&gt;role=&quot;switch&quot;&lt;/code&gt; &lt;/a&gt; 속성을 사용하면 버튼의 정확한 목적을 보조 기술에 알리므로 앱의 액세스 가능성을 높일 수 있습니다. &lt;a href=&quot;https://codepen.io/Wilto/pen/ZoGoQm?editors=1100&quot;&gt;사용 방법에&lt;/a&gt; 대한 데모가 있습니다 .</target>
        </trans-unit>
        <trans-unit id="2aa9e5e616be7ddff6bb867361e50d568a91d1ec" translate="yes" xml:space="preserve">
          <source>If you have gotten more than one ping before you get the chance to send a pong, you only send one pong.</source>
          <target state="translated">탁구를 보내기 전에 핑을 두 번 이상 받았다면 탁구를 한 개만 보냅니다.</target>
        </trans-unit>
        <trans-unit id="587c10e822b4a659a6cb91a86747aee1b61cc833" translate="yes" xml:space="preserve">
          <source>If you have to pass some complex data and have to call many different functions both on the main page and in the Worker, you can create a system which groups everything together.</source>
          <target state="translated">복잡한 데이터를 전달해야하고 메인 페이지와 작업자에서 다양한 기능을 호출해야하는 경우 모든 것을 그룹화하는 시스템을 만들 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="bc1d4bb579ef15b9c9b946a0608ad5df87732e7e" translate="yes" xml:space="preserve">
          <source>If you insert data that doesn't conform to a constraint. It's an exception type for creating stores and indexes. You get this error, for example, if you try to add a new key that already exists in the record.</source>
          <target state="translated">제약 조건을 준수하지 않는 데이터를 삽입하는 경우 상점 및 색인 작성에 대한 예외 유형입니다. 예를 들어 레코드에 이미 존재하는 새 키를 추가하려고하면이 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="9d74c81857d35741e3a98c0442070e0065715f2d" translate="yes" xml:space="preserve">
          <source>If you instead call &lt;code&gt;RTCIceCandidate()&lt;/code&gt; with a string parameter containing the &lt;code&gt;candidate&lt;/code&gt; m-line text, the value of &lt;code&gt;sdpMLineIndex&lt;/code&gt; is extracted from the m-line.</source>
          <target state="translated">대신 호출하면 &lt;code&gt;RTCIceCandidate()&lt;/code&gt; 포함하는 문자열 매개 변수와 함께 &lt;code&gt;candidate&lt;/code&gt; m 줄 텍스트의 값 &lt;code&gt;sdpMLineIndex&lt;/code&gt; 은 m 개의 라인에서 추출됩니다.</target>
        </trans-unit>
        <trans-unit id="94da9b2290f0f749237a942c0a63a114a592b053" translate="yes" xml:space="preserve">
          <source>If you instead call &lt;code&gt;RTCIceCandidate()&lt;/code&gt; with a string parameter containing the &lt;code&gt;candidate&lt;/code&gt; m-line text, the value of &lt;code&gt;usernameFragment&lt;/code&gt; is extracted from the m-line.</source>
          <target state="translated">&lt;code&gt;candidate&lt;/code&gt; m- 행 텍스트를 포함하는 문자열 매개 변수를 사용하여 &lt;code&gt;RTCIceCandidate()&lt;/code&gt; 를 대신 호출하면 &lt;code&gt;usernameFragment&lt;/code&gt; 의 값이 m- 행에서 추출됩니다.</target>
        </trans-unit>
        <trans-unit id="b1c628510846b9d819f8a77d3bb444467a09ca4e" translate="yes" xml:space="preserve">
          <source>If you just want to specify a change of direction but not constrain the results shown, you can just pass in null as the first argument:</source>
          <target state="translated">방향 변경 만 지정하고 표시된 결과를 제한하지 않으려면 첫 번째 인수로 null을 전달하면됩니다.</target>
        </trans-unit>
        <trans-unit id="572cacbd155e449c86755706a608fcff885aba77" translate="yes" xml:space="preserve">
          <source>If you know the ID of the specific image you wish to use, you can use &lt;a href=&quot;../../document/getelementbyid&quot;&gt;&lt;code&gt;document.getElementById()&lt;/code&gt;&lt;/a&gt; to retrieve that specific image</source>
          <target state="translated">사용하려는 특정 이미지의 ID를 알고있는 경우 &lt;a href=&quot;../../document/getelementbyid&quot;&gt; &lt;code&gt;document.getElementById()&lt;/code&gt; &lt;/a&gt; 를 사용 하여 해당 특정 이미지를 검색 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b58486dabf89a76ca2ffe2b1eac9040a0186b844" translate="yes" xml:space="preserve">
          <source>If you must ensure durability for some reason (e.g. you're storing critical data that cannot be recomputed later) you can force a transaction to flush to disk before delivering the &lt;code&gt;complete&lt;/code&gt; event by creating a transaction using the experimental (non-standard) &lt;code&gt;readwriteflush&lt;/code&gt; mode (see &lt;a href=&quot;idbdatabase/transaction&quot;&gt;&lt;code&gt;IDBDatabase.transaction&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">어떤 이유로 든 내구성을 보장해야하는 경우 (예 : 나중에 다시 계산할 수없는 중요한 데이터를 저장 하는 경우) 실험적인 (비표준) &lt;code&gt;readwriteflush&lt;/code&gt; 모드를 사용하여 트랜잭션을 작성 하여 &lt;code&gt;complete&lt;/code&gt; 이벤트를 전달하기 전에 트랜잭션을 디스크로 플러시 할 수 있습니다. (참조 &lt;a href=&quot;idbdatabase/transaction&quot;&gt; &lt;code&gt;IDBDatabase.transaction&lt;/code&gt; 을&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="0fc6eac051ba468c4a5dd56682b19d0b27a81ffe" translate="yes" xml:space="preserve">
          <source>If you need a list of all elements matching the specified selectors, you should use &lt;a href=&quot;queryselectorall&quot;&gt;&lt;code&gt;querySelectorAll()&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="translated">지정된 선택기와 일치하는 모든 요소 목록이 필요한 경우 대신 &lt;a href=&quot;queryselectorall&quot;&gt; &lt;code&gt;querySelectorAll()&lt;/code&gt; &lt;/a&gt; 사용해야 합니다.</target>
        </trans-unit>
        <trans-unit id="cf75f1fea3f38b0c7e42cb8faa44f13755533c58" translate="yes" xml:space="preserve">
          <source>If you need all the elements matching the selector list, use &lt;a href=&quot;queryselectorall&quot;&gt;&lt;code&gt;querySelectorAll()&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="translated">선택기 목록과 일치하는 모든 요소가 필요한 경우 &lt;a href=&quot;queryselectorall&quot;&gt; &lt;code&gt;querySelectorAll()&lt;/code&gt; &lt;/a&gt; 대신 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="a5ff07e82a040db0ce34d8194bec389f1b7f6e26" translate="yes" xml:space="preserve">
          <source>If you need an integer value, you can use &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/round&quot;&gt;&lt;code&gt;Math.round()&lt;/code&gt;&lt;/a&gt; to round it off.</source>
          <target state="translated">정수 값이 필요한 경우 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/round&quot;&gt; &lt;code&gt;Math.round()&lt;/code&gt; &lt;/a&gt; 를 사용 하여 반올림 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d89ecf25e01c4fae1a27fed14cb23a70a447302f" translate="yes" xml:space="preserve">
          <source>If you need higher performance and don't care about precision, you can use &lt;a href=&quot;getbytefrequencydata&quot;&gt;&lt;code&gt;AnalyserNode.getByteFrequencyData()&lt;/code&gt;&lt;/a&gt; instead, which works on a &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Uint8Array&quot;&gt;&lt;code&gt;Uint8Array&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">당신이 더 높은 성능을 필요로하고 정밀 걱정하지 않을 경우 사용할 수 있습니다 &lt;a href=&quot;getbytefrequencydata&quot;&gt; &lt;code&gt;AnalyserNode.getByteFrequencyData()&lt;/code&gt; &lt;/a&gt; A의 작동 대신, &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Uint8Array&quot;&gt; &lt;code&gt;Uint8Array&lt;/code&gt; 을&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="3ca2958f8d093dcd6afd58681d1398d8695f90e5" translate="yes" xml:space="preserve">
          <source>If you need only a single result, consider the &lt;a href=&quot;queryselector&quot;&gt;&lt;code&gt;querySelector()&lt;/code&gt;&lt;/a&gt; method instead.</source>
          <target state="translated">단일 결과 만 필요한 경우 &lt;a href=&quot;queryselector&quot;&gt; &lt;code&gt;querySelector()&lt;/code&gt; &lt;/a&gt; 메소드를 대신 고려하십시오 .</target>
        </trans-unit>
        <trans-unit id="99ba40678bd1f3dc6a55a9b0c372624ded2044a4" translate="yes" xml:space="preserve">
          <source>If you need or want to check to see if a specific MIME type is supported, that's possible as well. Just call &lt;a href=&quot;mediarecorder/istypesupported&quot;&gt;&lt;code&gt;MediaRecorder.isTypeSupported()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">특정 MIME 유형이 지원되는지 확인하거나 확인하려는 경우에도 가능합니다. &lt;a href=&quot;mediarecorder/istypesupported&quot;&gt; &lt;code&gt;MediaRecorder.isTypeSupported()&lt;/code&gt; &lt;/a&gt; 호출하십시오 .</target>
        </trans-unit>
        <trans-unit id="a412951be0f582bdcd1eb21eceec28e7472eb777" translate="yes" xml:space="preserve">
          <source>If you need to access all object stores in the database, you can use the property &lt;a href=&quot;objectstorenames&quot;&gt;&lt;code&gt;IDBDatabase.objectStoreNames&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">데이터베이스의 모든 오브젝트 저장소에 액세스해야하는 경우 &lt;a href=&quot;objectstorenames&quot;&gt; &lt;code&gt;IDBDatabase.objectStoreNames&lt;/code&gt; &lt;/a&gt; 특성을 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="b20109a97e1a1ead50c602fd679ef49490718c3c" translate="yes" xml:space="preserve">
          <source>If you need to access all the entries with a given &lt;code&gt;name&lt;/code&gt; you can use a cursor. You can open two different types of cursors on indexes. A normal cursor maps the index property to the object in the object store. A key cursor maps the index property to the key used to store the object in the object store. The differences are illustrated here:</source>
          <target state="translated">지정된 &lt;code&gt;name&lt;/code&gt; 모든 항목에 액세스해야하는 경우 커서를 사용할 수 있습니다. 인덱스에서 두 가지 다른 유형의 커서를 열 수 있습니다. 일반 커서는 색인 특성을 오브젝트 저장소의 오브젝트에 맵핑합니다. 키 커서는 인덱스 속성을 개체 저장소에 개체를 저장하는 데 사용되는 키에 매핑합니다. 차이점은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="6dabd4b9a0c4d29db3a994484a94bd7887d5f3eb" translate="yes" xml:space="preserve">
          <source>If you need to access only one object store, you can specify its name as a string. Therefore the following lines are equivalent:</source>
          <target state="translated">하나의 오브젝트 저장소에만 액세스해야하는 경우 해당 이름을 문자열로 지정할 수 있습니다. 따라서 다음 줄은 동일합니다.</target>
        </trans-unit>
        <trans-unit id="f496d84cbc12af742e4a5beb314ffec77bc0f0fb" translate="yes" xml:space="preserve">
          <source>If you need to change the configuration of the connection in some way (such as changing to a different set of ICE servers), you can do so before restarting ICE by calling &lt;a href=&quot;../rtcpeerconnection/setconfiguration&quot;&gt;&lt;code&gt;RTCPeerConnection.setConfiguration()&lt;/code&gt;&lt;/a&gt; with an updated &lt;a href=&quot;../rtcconfiguration&quot;&gt;&lt;code&gt;RTCConfiguration&lt;/code&gt;&lt;/a&gt; dictionary before restarting ICE.</source>
          <target state="translated">다른 방법으로 (예 : 다른 ICE 서버 세트로 변경) 연결 구성을 변경해야하는 경우 ICE를 다시 시작하기 전에 업데이트 된 &lt;a href=&quot;../rtcconfiguration&quot;&gt; &lt;code&gt;RTCConfiguration&lt;/code&gt; &lt;/a&gt; 사전으로 &lt;a href=&quot;../rtcpeerconnection/setconfiguration&quot;&gt; &lt;code&gt;RTCPeerConnection.setConfiguration()&lt;/code&gt; &lt;/a&gt; 을 호출하여 ICE를 다시 시작하기 전에 변경할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="b701e6b5756cd8deee58bc6832a89d2ea6f00088" translate="yes" xml:space="preserve">
          <source>If you need to find the specific position inside the element, use &lt;a href=&quot;caretpositionfrompoint&quot;&gt;&lt;code&gt;Document.caretPositionFromPoint()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">요소 내부의 특정 위치를 찾아야하는 경우 &lt;a href=&quot;caretpositionfrompoint&quot;&gt; &lt;code&gt;Document.caretPositionFromPoint()&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="ce1354f1280a873f6f3846bcee632318cd785e78" translate="yes" xml:space="preserve">
          <source>If you need to get access to an element which doesn't have an ID, you can use &lt;a href=&quot;queryselector&quot;&gt;&lt;code&gt;querySelector()&lt;/code&gt;&lt;/a&gt; to find the element using any &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/CSS_selector&quot;&gt;selector&lt;/a&gt;.</source>
          <target state="translated">ID가없는 요소에 액세스해야하는 경우 &lt;a href=&quot;queryselector&quot;&gt; &lt;code&gt;querySelector()&lt;/code&gt; &lt;/a&gt; 를 사용하여 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/CSS_selector&quot;&gt;selector를&lt;/a&gt; 사용하여 요소를 찾을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="9a24a5e0713af9bce31ddfda9678b3073cb3088c" translate="yes" xml:space="preserve">
          <source>If you need to get the raw string of all of the headers, use the &lt;a href=&quot;getallresponseheaders&quot;&gt;&lt;code&gt;getAllResponseHeaders()&lt;/code&gt;&lt;/a&gt; method, which returns the entire raw header string.</source>
          <target state="translated">모든 헤더의 원시 문자열을 &lt;a href=&quot;getallresponseheaders&quot;&gt; &lt;code&gt;getAllResponseHeaders()&lt;/code&gt; &lt;/a&gt; 하는 경우 전체 원시 헤더 문자열을 리턴하는 getAllResponseHeaders () 메소드를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="31c7f345f25cf22172b76f632a149677e6e77c92" translate="yes" xml:space="preserve">
          <source>If you need to immediately terminate a running worker from the main thread, you can do so by calling the worker's &lt;a href=&quot;../worker&quot;&gt;&lt;code&gt;terminate&lt;/code&gt;&lt;/a&gt; method:</source>
          <target state="translated">기본 스레드에서 실행중인 작업자를 즉시 ​​종료해야하는 경우 작업자의 &lt;a href=&quot;../worker&quot;&gt; &lt;code&gt;terminate&lt;/code&gt; &lt;/a&gt; 메소드를 호출하여 수행 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="d6fbab80b532321fd24f8e49f12df965fde8497c" translate="yes" xml:space="preserve">
          <source>If you need to know how much space the actual displayed content takes up, including padding but not including the border, margins, or scrollbars, you want to use the &lt;a href=&quot;../element/clientwidth&quot;&gt;&lt;code&gt;Element.clientWidth&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../element/clientheight&quot;&gt;&lt;code&gt;Element.clientHeight&lt;/code&gt;&lt;/a&gt; properties:</source>
          <target state="translated">패딩을 포함하여 테두리, 여백 또는 스크롤 막대는 포함하지 않고 실제 표시되는 내용이 차지하는 공간을 알아야하는 경우 &lt;a href=&quot;../element/clientwidth&quot;&gt; &lt;code&gt;Element.clientWidth&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;../element/clientheight&quot;&gt; &lt;code&gt;Element.clientHeight&lt;/code&gt; &lt;/a&gt; 속성 을 사용하려고 합니다.</target>
        </trans-unit>
        <trans-unit id="7a511cc7ffe90dd06690b4eec08b4d715860eb1a" translate="yes" xml:space="preserve">
          <source>If you need to know the actual size of the content, regardless of how much of it is currently visible, you need to use the &lt;a href=&quot;../element/scrollwidth&quot;&gt;&lt;code&gt;Element.scrollWidth&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../element/scrollheight&quot;&gt;&lt;code&gt;Element.scrollHeight&lt;/code&gt;&lt;/a&gt; properties. These return the width and height of the entire content of an element, even if only part of it is presently visible due to the use of scroll bars.</source>
          <target state="translated">현재 표시되는 내용의 양에 관계없이 내용의 실제 크기를 알아야하는 경우 &lt;a href=&quot;../element/scrollwidth&quot;&gt; &lt;code&gt;Element.scrollWidth&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;../element/scrollheight&quot;&gt; &lt;code&gt;Element.scrollHeight&lt;/code&gt; &lt;/a&gt; 속성 을 사용해야합니다 . 이들은 스크롤 바를 사용하여 현재 일부만 볼 수있는 경우에도 요소의 전체 내용의 너비와 높이를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="b04f12470e88bb9f55d7c6738393e7677747c329" translate="yes" xml:space="preserve">
          <source>If you need to know the total amount of space an element occupies, including the width of the visible content, scrollbars (if any), padding, and border, you want to use the &lt;a href=&quot;../htmlelement/offsetwidth&quot;&gt;&lt;code&gt;HTMLElement.offsetWidth&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../htmlelement/offsetheight&quot;&gt;&lt;code&gt;HTMLElement.offsetHeight&lt;/code&gt;&lt;/a&gt; properties. Most of the time these are the same as width and height of &lt;a href=&quot;../element/getboundingclientrect&quot;&gt;&lt;code&gt;Element.getBoundingClientRect()&lt;/code&gt;&lt;/a&gt;, when there aren't any transforms applied to the element. In case of transforms, the &lt;code&gt;offsetWidth&lt;/code&gt; and &lt;code&gt;offsetHeight&lt;/code&gt; returns the element's layout width and height, while &lt;code&gt;getBoundingClientRect()&lt;/code&gt; returns the rendering width and height. As an example, if the element has &lt;code&gt;width: 100px;&lt;/code&gt; and &lt;code&gt;transform: scale(0.5);&lt;/code&gt; the &lt;code&gt;getBoundingClientRect()&lt;/code&gt; will return 50 as the width, while &lt;code&gt;offsetWidth&lt;/code&gt; will return 100.</source>
          <target state="translated">표시되는 내용의 너비, 스크롤 막대 (있는 경우), 패딩 및 테두리를 포함하여 요소가 차지하는 총 공간을 알아야하는 경우 &lt;a href=&quot;../htmlelement/offsetwidth&quot;&gt; &lt;code&gt;HTMLElement.offsetWidth&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;../htmlelement/offsetheight&quot;&gt; &lt;code&gt;HTMLElement.offsetHeight&lt;/code&gt; &lt;/a&gt; 속성 을 사용하려고 합니다. 대부분의 경우 요소에 적용된 변환이없는 경우 &lt;a href=&quot;../element/getboundingclientrect&quot;&gt; &lt;code&gt;Element.getBoundingClientRect()&lt;/code&gt; &lt;/a&gt; 의 너비 및 높이와 동일 합니다. 변형의 경우, &lt;code&gt;offsetWidth&lt;/code&gt; 및 &lt;code&gt;offsetHeight&lt;/code&gt; 는 요소의 레이아웃 너비와 높이를 반환하고 &lt;code&gt;getBoundingClientRect()&lt;/code&gt; 는 렌더링 너비와 높이를 반환합니다. 예를 들어, 요소의 &lt;code&gt;width: 100px;&lt;/code&gt; 및 &lt;code&gt;transform: scale(0.5);&lt;/code&gt; 그만큼 &lt;code&gt;getBoundingClientRect()&lt;/code&gt; 는 너비로 50을 반환하고 &lt;code&gt;offsetWidth&lt;/code&gt; 는 100을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="fce33da787e9811c6b4fc1017f89fe8ee63ff1c9" translate="yes" xml:space="preserve">
          <source>If you need to know whether or not a given constriant is supported by the user agent, you can find out by calling &lt;a href=&quot;../mediadevices/getsupportedconstraints&quot;&gt;&lt;code&gt;navigator.mediaDevices.getSupportedConstraints()&lt;/code&gt;&lt;/a&gt; to get a list of the constrainable properties which the browser knows, like this:</source>
          <target state="translated">주어진 에이전트가 사용자 에이전트가 지원하는지 여부를 알아야하는 경우 &lt;a href=&quot;../mediadevices/getsupportedconstraints&quot;&gt; &lt;code&gt;navigator.mediaDevices.getSupportedConstraints()&lt;/code&gt; &lt;/a&gt; 를 호출 하여 브라우저가 알고있는 제한 가능한 특성 목록을 다음과 같이 얻을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="17865f846646d03cbb05fcf04bdb6e6f9ba2f482" translate="yes" xml:space="preserve">
          <source>If you need to open the object store in &lt;code&gt;readwrite&lt;/code&gt; mode to change data, you would use the following:</source>
          <target state="translated">데이터를 변경하기 위해 &lt;code&gt;readwrite&lt;/code&gt; 모드 에서 객체 저장소를 열어야하는 경우 다음을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="d75b11efb32646a783c398e8e0ee4f0a37608a6d" translate="yes" xml:space="preserve">
          <source>If you need to pass one or more arguments to your callback function, but need it to work in browsers which don't support sending additional parameters using either &lt;code&gt;setTimeout()&lt;/code&gt; or &lt;code&gt;setInterval() &lt;/code&gt;(e.g. Internet Explorer 9 and below&lt;code&gt;)&lt;/code&gt;, you can include this polyfill which enables the HTML5 standard parameter-passing functionality. Just add this code to the top of your script:</source>
          <target state="translated">당신이 당신의 콜백 함수에 하나 개 이상의 인수를 전달해야하지만 중 하나를 사용하여 추가 매개 변수를 전송 지원하지 않는 브라우저에서 작업을해야하는 경우 &lt;code&gt;setTimeout()&lt;/code&gt; 하거나 &lt;code&gt;setInterval() &lt;/code&gt; (예를 인터넷 익스플로러 9 이하이 &lt;code&gt;)&lt;/code&gt; , 당신은 포함 할 수 있습니다 이 polyfill은 HTML5 표준 매개 변수 전달 기능을 가능하게합니다. 이 코드를 스크립트 상단에 추가하십시오.</target>
        </trans-unit>
        <trans-unit id="ecc9d74b2fc4b59d366cd8565acae9082bd0c112" translate="yes" xml:space="preserve">
          <source>If you only want to send credentials if the request URL is on the same origin as the calling script, add &lt;code&gt;credentials: 'same-origin'&lt;/code&gt;.</source>
          <target state="translated">요청 URL이 호출 스크립트와 동일한 출처에있는 경우 신임 정보 만 보내려면 &lt;code&gt;credentials: 'same-origin'&lt;/code&gt; 추가하십시오 .</target>
        </trans-unit>
        <trans-unit id="373c2f6c1458db2cfb0512b470ed4d38fc1cee99" translate="yes" xml:space="preserve">
          <source>If you run out of disk quota and the user declined to grant you more space.</source>
          <target state="translated">디스크 할당량이 부족하고 사용자에게 더 많은 공간을 부여하지 않은 경우</target>
        </trans-unit>
        <trans-unit id="1e315bdfc1536a4c7d34fda0733639f532af94d3" translate="yes" xml:space="preserve">
          <source>If you select to pay with the BobPay demo payment provider on this merchant page, it tries to call &lt;code&gt;PaymentRequest.show()&lt;/code&gt;, while intercepting the &lt;code&gt;NOTSUPPORTEDERR&lt;/code&gt; exception. If this payment method is not supported, it redirects to the signup page for BobPay.</source>
          <target state="translated">이 판매자 페이지에서 BobPay 데모 지불 제공자로 지불하기로 선택한 경우 &lt;code&gt;NOTSUPPORTEDERR&lt;/code&gt; 예외 를 가로 채면서 &lt;code&gt;PaymentRequest.show()&lt;/code&gt; 를 호출하려고합니다 . 이 결제 수단이 지원되지 않으면 BobPay 가입 페이지로 리디렉션됩니다.</target>
        </trans-unit>
        <trans-unit id="c91e3c9519bc9580e50154d0481b21c6fdda6e21" translate="yes" xml:space="preserve">
          <source>If you set &lt;code&gt;characterDataOldValue&lt;/code&gt; to &lt;code&gt;true&lt;/code&gt;, &lt;code&gt;characterData&lt;/code&gt; is automatically assumed to be &lt;code&gt;true&lt;/code&gt;, even if you don't expressly set it as such.</source>
          <target state="translated">를 설정하면 &lt;code&gt;characterDataOldValue&lt;/code&gt; 을 에 &lt;code&gt;true&lt;/code&gt; , &lt;code&gt;characterData&lt;/code&gt; 자동으로 간주됩니다 &lt;code&gt;true&lt;/code&gt; 당신이 명시 적으로 같은 설정하지 않은 경우에도.</target>
        </trans-unit>
        <trans-unit id="bfc58c99ac5444957f63a055920b1c261489a027" translate="yes" xml:space="preserve">
          <source>If you set either &lt;code&gt;attributeFilter&lt;/code&gt; or &lt;code&gt;attributeOldValue&lt;/code&gt; to &lt;code&gt;true&lt;/code&gt;, &lt;code&gt;attributes&lt;/code&gt; is automatically assumed to be &lt;code&gt;true&lt;/code&gt;, even if you don't expressly set it as such.</source>
          <target state="translated">당신이 중 하나를 설정하면 &lt;code&gt;attributeFilter&lt;/code&gt; 또는 &lt;code&gt;attributeOldValue&lt;/code&gt; 을 에 &lt;code&gt;true&lt;/code&gt; , &lt;code&gt;attributes&lt;/code&gt; 자동으로 간주됩니다 &lt;code&gt;true&lt;/code&gt; 당신이 명시 적으로 같은 설정하지 않은 경우에도.</target>
        </trans-unit>
        <trans-unit id="dd0c6ecea1973b532755dffdaaaea7f377db47f5" translate="yes" xml:space="preserve">
          <source>If you set the &lt;a href=&quot;characterdata&quot;&gt;&lt;code&gt;MutationObserverInit.characterData&lt;/code&gt;&lt;/a&gt; property to &lt;code&gt;true&lt;/code&gt; but don't set &lt;code&gt;characterDataOldValue&lt;/code&gt; to &lt;code&gt;true&lt;/code&gt; as well, the &lt;code&gt;MutationRecord&lt;/code&gt; will not include information describing the prior state of the text node's contents.</source>
          <target state="translated">당신이 설정 한 경우 &lt;a href=&quot;characterdata&quot;&gt; &lt;code&gt;MutationObserverInit.characterData&lt;/code&gt; 의&lt;/a&gt; 에 재산 &lt;code&gt;true&lt;/code&gt; 하지만 설정하지 &lt;code&gt;characterDataOldValue&lt;/code&gt; 을 에 &lt;code&gt;true&lt;/code&gt; 뿐만 아니라의 &lt;code&gt;MutationRecord&lt;/code&gt; 는 텍스트 노드의 내용의 이전 상태를 설명하는 정보가 포함되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="6dbff80bded4dced1a9208f25c13c5f51d79ce5c" translate="yes" xml:space="preserve">
          <source>If you specify a &lt;code&gt;miterLimit&lt;/code&gt; value below 4.2 in this demo, none of the visible corners will join with a miter extension, but only with a small bevel near the blue lines; with a &lt;code&gt;miterLimit&lt;/code&gt; above 10, most corners in this demo should join with a miter far away from the blue lines, and whose height is decreasing between corners from left to right because they connect with growing angles; with intermediate values, the corners on the left side will only join with a bevel near the blue lines, and the corners on the right side with a miter extension (also with a decreasing height).</source>
          <target state="translated">이 데모에서 &lt;code&gt;miterLimit&lt;/code&gt; 값을 4.2 미만으로 지정 하면 보이는 모서리가 연귀 확장과 연결되지 않지만 파란색 선 근처의 작은 경사 만 연결됩니다. 로모그래퍼 &lt;code&gt;miterLimit&lt;/code&gt; 10 위,이 데모에서 가장 코너 멀리 파란색 라인에서 마이와 결합하고, 그 높이가 증가하는 각도와 연결하기 때문에 왼쪽에서 오른쪽으로 코너 사이에 감소한다 중간 값을 사용하면 왼쪽의 모서리가 파란색 선 근처의 경사와 만 연결되고 오른쪽의 모서리는 연귀 확장 부 (높이가 감소 함)로 연결됩니다.</target>
        </trans-unit>
        <trans-unit id="59544a7122f801112b8c40e30e34b8444220fc8a" translate="yes" xml:space="preserve">
          <source>If you try to call &lt;code&gt;drawImage()&lt;/code&gt; before the image has finished loading, it won't do anything (or, in older browsers, may even throw an exception). So you need to be sure to use the load event so you don't try this before the image has loaded:</source>
          <target state="translated">이미지로드가 완료되기 전에 &lt;code&gt;drawImage()&lt;/code&gt; 를 호출하려고 하면 아무런 작업도 수행되지 않습니다 (또는 이전 브라우저에서는 예외가 발생할 수도 있음). 따라서 이미지가로드되기 전에 시도하지 않도록 load 이벤트를 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="f1864154225ab0c02c3c102ad6fd8abd898e460b" translate="yes" xml:space="preserve">
          <source>If you try to delete a directory which contains one or more files that can't be removed, or if an error occurs while deletion of a number of files is underway, some files may not be deleted. You should provide an &lt;code&gt;errorCallback&lt;/code&gt; to watch for and handle this, perhaps by trying again.</source>
          <target state="translated">제거 할 수없는 하나 이상의 파일이 포함 된 디렉토리를 삭제하려고 시도하거나 여러 파일을 삭제하는 중에 오류가 발생하면 일부 파일이 삭제되지 않을 수 있습니다. 아마도 다시 시도 하여 &lt;code&gt;errorCallback&lt;/code&gt; 을보고이를 처리하고 처리해야합니다.</target>
        </trans-unit>
        <trans-unit id="ee77a122b2a4cd38ca29ebca14e7687a1617273b" translate="yes" xml:space="preserve">
          <source>If you try to open a database with a version lower than the one it already has.</source>
          <target state="translated">기존 버전보다 낮은 버전의 데이터베이스를 열려고하는 경우</target>
        </trans-unit>
        <trans-unit id="41066a91637e3388e02ac0bb488fa21d4aae1072" translate="yes" xml:space="preserve">
          <source>If you try to set the &lt;code&gt;mode&lt;/code&gt; property value to &lt;code&gt;segments&lt;/code&gt; when the initial value is &lt;code&gt;sequence&lt;/code&gt;, an error will be thrown. The existing segment order must be maintained in &lt;code&gt;sequence&lt;/code&gt; mode. You can, however, change the value from &lt;code&gt;segments&lt;/code&gt; to &lt;code&gt;sequence&lt;/code&gt;. It just means the play order will be fixed, and new timestamps generated to reflect this.</source>
          <target state="translated">초기 값이 &lt;code&gt;sequence&lt;/code&gt; 일 때 &lt;code&gt;mode&lt;/code&gt; 속성 값을 &lt;code&gt;segments&lt;/code&gt; 로 설정하려고 하면 오류가 발생합니다. 기존 세그먼트 순서는 &lt;code&gt;sequence&lt;/code&gt; 모드 로 유지되어야 합니다. 그러나 값을 &lt;code&gt;segments&lt;/code&gt; 에서 &lt;code&gt;sequence&lt;/code&gt; 로 변경할 수 있습니다 . 그것은 단지 플레이 순서가 고정되고 이것을 반영하기 위해 새로운 타임 스탬프가 생성된다는 것을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="32db42c6327ed5ef9bea10be19fc5174c7b0eec5" translate="yes" xml:space="preserve">
          <source>If you use &lt;code&gt;XMLHttpRequest&lt;/code&gt; to get the content of a remote HTML webpage, the &lt;a href=&quot;responsetext&quot;&gt;&lt;code&gt;responseText&lt;/code&gt;&lt;/a&gt; property is a string containing the raw HTML. This could prove difficult to manipulate and analyze. There are three primary ways to analyze and parse this raw HTML string:</source>
          <target state="translated">&lt;code&gt;XMLHttpRequest&lt;/code&gt; 를 사용 하여 원격 HTML 웹 페이지의 컨텐츠를 가져 오는 경우 &lt;a href=&quot;responsetext&quot;&gt; &lt;code&gt;responseText&lt;/code&gt; &lt;/a&gt; 특성은 원시 HTML을 포함하는 문자열입니다. 이것은 조작 및 분석이 어려울 수 있습니다. 이 원시 HTML 문자열을 분석하고 구문 분석하는 세 가지 기본 방법이 있습니다.</target>
        </trans-unit>
        <trans-unit id="a245a00eef954eafa3364e113b4beb937ab1dd88" translate="yes" xml:space="preserve">
          <source>If you use &lt;code&gt;XMLHttpRequest&lt;/code&gt; to get the content of a remote XML document, the &lt;a href=&quot;responsexml&quot;&gt;&lt;code&gt;responseXML&lt;/code&gt;&lt;/a&gt; property will be a DOM object containing a parsed XML document. This could prove difficult to manipulate and analyze. There are four primary ways of analyzing this XML document:</source>
          <target state="translated">&lt;code&gt;XMLHttpRequest&lt;/code&gt; 를 사용 하여 원격 XML 문서의 컨텐츠를 가져 오는 경우 &lt;a href=&quot;responsexml&quot;&gt; &lt;code&gt;responseXML&lt;/code&gt; &lt;/a&gt; 특성은 구문 분석 된 XML 문서를 포함하는 DOM 오브젝트입니다. 이것은 조작 및 분석이 어려울 수 있습니다. 이 XML 문서를 분석하는 기본 방법에는 네 가지가 있습니다.</target>
        </trans-unit>
        <trans-unit id="403d17f5204da19c83ed5ced5aed4cd02443a81b" translate="yes" xml:space="preserve">
          <source>If you use a relatively large radius, the arc may appear in a place you didn't expect. In this example, the arc's connecting line goes above, instead of below, the coordinate specified by &lt;code&gt;moveTo()&lt;/code&gt;. This happens because the radius is too large for the arc to fit entirely below the starting point.</source>
          <target state="translated">비교적 큰 반경을 사용하면 원치 않는 곳에 호가 나타날 수 있습니다. 이 예제에서 호의 연결선은 &lt;code&gt;moveTo()&lt;/code&gt; 지정된 좌표보다 아래가 아니라 위를갑니다 . 이는 원호가 시작점 아래에 완전히 들어가기에는 반지름이 너무 커서 발생합니다.</target>
        </trans-unit>
        <trans-unit id="3262eb12d94596219a3db95d69c9fc86682fec80" translate="yes" xml:space="preserve">
          <source>If you use an asynchronous &lt;code&gt;XMLHttpRequest&lt;/code&gt;, you receive a callback when the data has been received. This lets the browser continue to work as normal while your request is being handled.</source>
          <target state="translated">비동기 &lt;code&gt;XMLHttpRequest&lt;/code&gt; 를 사용 하면 데이터가 수신 될 때 콜백이 수신됩니다. 이를 통해 요청이 처리되는 동안 브라우저가 정상적으로 작동합니다.</target>
        </trans-unit>
        <trans-unit id="2b2a0e52c15500fecfcaef1e39851f471f11e5fd" translate="yes" xml:space="preserve">
          <source>If you use the callback to monitor these changes, you don't need to call this method. Calling this method clears the pending intersection list, so the callback will not be run.</source>
          <target state="translated">콜백을 사용하여 이러한 변경 사항을 모니터링하는 경우이 메서드를 호출 할 필요가 없습니다. 이 메소드를 호출하면 보류중인 교차 목록이 지워 지므로 콜백이 실행되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="e168a0a2d7db564d30bec3141fbbc37c06af397c" translate="yes" xml:space="preserve">
          <source>If you use this call above, you will get a stereo buffer with two channels, that when played back on an AudioContext running at 44100Hz (very common, most normal sound cards run at this rate), will last for 0.5 seconds: 22050 frames/44100Hz = 0.5 seconds.</source>
          <target state="translated">위의 호출을 사용하면 44100Hz (가장 일반적인 대부분의 일반 사운드 카드는이 속도로 실행)에서 실행되는 AudioContext에서 재생 될 때 0.5 초 동안 지속되는 두 개의 채널이있는 스테레오 버퍼를 얻게됩니다. 44100Hz = 0.5 초</target>
        </trans-unit>
        <trans-unit id="4edf8c9f1bad76f5a3fbac856c14ab6b2096fd75" translate="yes" xml:space="preserve">
          <source>If you use this call, you will get a mono buffer (one channel), that, when played back on an &lt;code&gt;AudioContext&lt;/code&gt; running at 44100Hz, will be automatically *resampled* to 44100Hz (and therefore yield 44100 frames), and last for 1.0 second: 44100 frames / 44100Hz = 1 second.</source>
          <target state="translated">이 호출을 사용하면 44100Hz로 실행 되는 &lt;code&gt;AudioContext&lt;/code&gt; 에서 재생 될 때 자동으로 * 재 샘플링 *되어 44100Hz (44100 프레임 생성)이며 1.0 초 동안 지속 되는 모노 버퍼 (하나의 채널) 가 제공됩니다. : 44100 프레임 / 44100Hz = 1 초</target>
        </trans-unit>
        <trans-unit id="ef807d51c378c8fa4f7ac09b307f94619973f4fb" translate="yes" xml:space="preserve">
          <source>If you use this call, you will get a mono buffer with just one channel), that when played back on an AudioContext running at 44100Hz, will be automatically &lt;em&gt;resampled&lt;/em&gt; to 44100Hz (and therefore yield 44100 frames), and last for 1.0 second: 44100 frames/44100Hz = 1 second.</source>
          <target state="translated">이 호출을 사용하면 44100Hz로 실행되는 AudioContext에서 재생 될 때 44100Hz로 자동 &lt;em&gt;리샘플링&lt;/em&gt; (따라서 44100 프레임 생성)되고 1.0 초 동안 지속되는 단일 채널의 모노 버퍼를 얻게됩니다 . 프레임 / 44100Hz = 1 초</target>
        </trans-unit>
        <trans-unit id="7f23834ff1f257a028c0128d51ca216428a367c2" translate="yes" xml:space="preserve">
          <source>If you use this call, you will get a stereo buffer (two channels), that, when played back on an AudioContext running at 44100Hz (very common, most normal sound cards run at this rate), will last for 0.5 seconds: 22050 frames / 44100Hz = 0.5 seconds.</source>
          <target state="translated">이 호출을 사용하면 44100Hz (가장 일반적으로 가장 일반적인 사운드 카드는이 속도로 실행)에서 실행되는 AudioContext에서 재생할 때 0.5 초 동안 지속되는 스테레오 버퍼 (2 개의 채널)가 제공됩니다. / 44100Hz = 0.5 초</target>
        </trans-unit>
        <trans-unit id="4f69fcb9cf923a9b19705928aa11df83c731b431" translate="yes" xml:space="preserve">
          <source>If you want a completely unobtrusive hack for every other mobile or desktop browser, including IE 9 and below, you can either use JavaScript conditional comments:</source>
          <target state="translated">IE 9 이하를 포함한 다른 모든 모바일 또는 데스크탑 브라우저에 대해 완전히 눈에 거슬리지 않는 해킹을 원한다면 JavaScript 조건부 주석을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="031b151057ab536e119a87cdc44fb926a17b3059" translate="yes" xml:space="preserve">
          <source>If you want to allow a drop, you must prevent the default handling by cancelling the event. You can do this either by returning &lt;code&gt;false&lt;/code&gt; from an attribute-defined event listener, or by calling the event's &lt;a href=&quot;../event/preventdefault&quot;&gt;&lt;code&gt;preventDefault()&lt;/code&gt;&lt;/a&gt; method. The latter may be more feasible in a function defined in a separate script.</source>
          <target state="translated">삭제를 허용하려면 이벤트를 취소하여 기본 처리를 방지해야합니다. 속성 정의 이벤트 리스너에서 &lt;code&gt;false&lt;/code&gt; 를 반환 하거나 이벤트의 &lt;a href=&quot;../event/preventdefault&quot;&gt; &lt;code&gt;preventDefault()&lt;/code&gt; &lt;/a&gt; 메서드 를 호출 하여이 작업을 수행 할 수 있습니다 . 후자는 별도의 스크립트에 정의 된 함수에서 더 적합 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b037687da6e5b7608e7f19311268baf6b25076dc" translate="yes" xml:space="preserve">
          <source>If you want to close your worker instance from inside the worker itself, you can call the following:</source>
          <target state="translated">작업자 내부에서 작업자 인스턴스를 닫으려면 다음을 호출하면됩니다.</target>
        </trans-unit>
        <trans-unit id="79c930c2b706b22985b60fb3d920d7ede37a6e79" translate="yes" xml:space="preserve">
          <source>If you want to extract time, frequency, and other data from your audio, the &lt;code&gt;AnalyserNode&lt;/code&gt; is what you need.</source>
          <target state="translated">오디오에서 시간, 주파수 및 기타 데이터를 추출하려면 &lt;code&gt;AnalyserNode&lt;/code&gt; 가 필요합니다.</target>
        </trans-unit>
        <trans-unit id="e00aa890b17684116773239824e0ad1dc9811b83" translate="yes" xml:space="preserve">
          <source>If you want to force e10s to be on &amp;mdash; to explicitly re-enable touch events support &amp;mdash; you need to go to &lt;code&gt;about:config&lt;/code&gt; and create a new Boolean preference &lt;code&gt;browser.tabs.remote.force-enable&lt;/code&gt;. Set it to &lt;code&gt;true&lt;/code&gt;, restart the browser, and e10s will be enabled regardless of any other settings.</source>
          <target state="translated">터치 이벤트 지원을 명시 적으로 다시 활성화하기 위해 e10을 강제로 켜려면 &lt;code&gt;about:config&lt;/code&gt; 로 이동하여 새 부울 기본 설정 &lt;code&gt;browser.tabs.remote.force-enable&lt;/code&gt; 을 만들어야합니다 . &lt;code&gt;true&lt;/code&gt; 로 설정 하고 브라우저를 다시 시작하면 다른 설정에 관계없이 e10이 활성화됩니다.</target>
        </trans-unit>
        <trans-unit id="a73417a3b4af5ea677fdd853724c79ef4f22e085" translate="yes" xml:space="preserve">
          <source>If you want to know &lt;strong&gt;&lt;em&gt;if&lt;/em&gt; &lt;em&gt;the current page&lt;/em&gt; has changed&lt;/strong&gt;, please read the article about &lt;a href=&quot;../document/lastmodified&quot;&gt;&lt;code&gt;document.lastModified&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;strong&gt;&lt;em&gt;현재 페이지&lt;/em&gt;&lt;/strong&gt;&lt;strong&gt; 가 변경&lt;/strong&gt; 되었는지 &lt;strong&gt;&lt;em&gt;확인 &lt;/em&gt; &lt;em&gt;하려면 &lt;/em&gt;&lt;/strong&gt;&lt;a href=&quot;../document/lastmodified&quot;&gt; &lt;code&gt;document.lastModified&lt;/code&gt; 에&lt;/a&gt; 대한 기사를 읽으십시오 .</target>
        </trans-unit>
        <trans-unit id="0d59e541f7c401a5f93334d4a4c8249239c20768" translate="yes" xml:space="preserve">
          <source>If you want to know &lt;strong&gt;whether &lt;em&gt;an external page&lt;/em&gt; has changed&lt;/strong&gt;, please read &lt;a href=&quot;../xmlhttprequest/using_xmlhttprequest#Get_last_modified_date&quot;&gt;this paragraph about the &lt;code&gt;XMLHttpRequest()&lt;/code&gt; API&lt;/a&gt;.</source>
          <target state="translated">&lt;strong&gt;&lt;em&gt;외부 페이지&lt;/em&gt;&lt;/strong&gt;&lt;strong&gt; 가 변경 &lt;/strong&gt;&lt;strong&gt;되었는지 여부&lt;em&gt;&lt;/em&gt;&lt;/strong&gt; 를 알고 싶다면 &lt;a href=&quot;../xmlhttprequest/using_xmlhttprequest#Get_last_modified_date&quot;&gt; &lt;code&gt;XMLHttpRequest()&lt;/code&gt; &lt;/a&gt; API에 대한이 단락을 읽으십시오 .</target>
        </trans-unit>
        <trans-unit id="74c75369ad01be29542cb331076b5c097628fce8" translate="yes" xml:space="preserve">
          <source>If you want to know how to serialize and submit a form using the &lt;a href=&quot;xmlhttprequest&quot;&gt;&lt;code&gt;XMLHttpRequest&lt;/code&gt;&lt;/a&gt; API, please read &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/DOM/XMLHttpRequest/Using_XMLHttpRequest#Submitting_forms_and_uploading_files&quot;&gt;this paragraph&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;xmlhttprequest&quot;&gt; &lt;code&gt;XMLHttpRequest&lt;/code&gt; &lt;/a&gt; API를 사용하여 양식을 직렬화하고 제출하는 방법을 알고 싶다면 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/DOM/XMLHttpRequest/Using_XMLHttpRequest#Submitting_forms_and_uploading_files&quot;&gt;이 단락을&lt;/a&gt; 읽으십시오 .</target>
        </trans-unit>
        <trans-unit id="ca69d6b3603883071e19cc428964c12123072870" translate="yes" xml:space="preserve">
          <source>If you want to know how to serialize and submit a form via &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/AJAX&quot;&gt;AJAX&lt;/a&gt;&lt;em&gt;without&lt;/em&gt; using FormData objects, please read &lt;a href=&quot;../xmlhttprequest/using_xmlhttprequest#Submitting_forms_and_uploading_files&quot;&gt;this paragraph&lt;/a&gt;.</source>
          <target state="translated">FormData 객체 &lt;em&gt;를&lt;/em&gt; 사용 &lt;em&gt;하지 않고 &lt;/em&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/AJAX&quot;&gt;AJAX &lt;/a&gt;&lt;em&gt;를&lt;/em&gt; 통해 양식을 직렬화하고 제출하는 방법을 알고 싶다면 &lt;a href=&quot;../xmlhttprequest/using_xmlhttprequest#Submitting_forms_and_uploading_files&quot;&gt;이 단락을&lt;/a&gt; 읽으십시오 .</target>
        </trans-unit>
        <trans-unit id="476db1c53ef9ace0c2a71480c52bd04db5f5e38c" translate="yes" xml:space="preserve">
          <source>If you want to let the user select multiple files, simply use the &lt;code&gt;multiple&lt;/code&gt; attribute on the &lt;code&gt;input&lt;/code&gt; element:</source>
          <target state="translated">사용자가 여러 파일을 선택하게하려면 &lt;code&gt;input&lt;/code&gt; 요소 에서 &lt;code&gt;multiple&lt;/code&gt; 속성을 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="e9c1e6be5daa92ed656206d0169bfddbaaa1cc6c" translate="yes" xml:space="preserve">
          <source>If you want to offer to open a link in a new window, then follow tested and recommendable usability and accessibility guidelines:</source>
          <target state="translated">새 창에서 링크를 열도록 제안하려면 테스트되고 권장되는 유용성 및 접근성 지침을 따르십시오.</target>
        </trans-unit>
        <trans-unit id="a04b37103ece0a5f8c3dbce1e30c156ee58dd55a" translate="yes" xml:space="preserve">
          <source>If you want to open a connection and are flexible about the protocols you support, you can specify an array of protocols:</source>
          <target state="translated">연결을 열고 지원하는 프로토콜에 대해 융통성이있는 경우 프로토콜 배열을 지정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="417e761dcad4f0a05ebae79173d26e974820044a" translate="yes" xml:space="preserve">
          <source>If you want to play with the IIR filter node and need some values to help along the way, there's &lt;a href=&quot;http://www.dspguide.com/CH20.PDF&quot;&gt;a table of already calculated values here&lt;/a&gt;; on pages 4 &amp;amp; 5 of the linked PDF the a&lt;em&gt;n&lt;/em&gt; values refer to the &lt;code&gt;feedForward&lt;/code&gt; values and the b&lt;em&gt;n&lt;/em&gt; values refer to the &lt;code&gt;feedback&lt;/code&gt;. &lt;a href=&quot;http://musicdsp.org/&quot;&gt;musicdsp.org&lt;/a&gt; is also a great resource if you want to read more about different filters and how they are implemented digitally.</source>
          <target state="translated">IIR 필터 노드를 사용하고 진행하는 데 도움이되는 값이 필요한 경우 &lt;a href=&quot;http://www.dspguide.com/CH20.PDF&quot;&gt;여기에 이미 계산 된 값 표가 있습니다&lt;/a&gt; . 링크 된 PDF의 4 및 5 페이지에서 a &lt;em&gt;n&lt;/em&gt; 값은 &lt;code&gt;feedForward&lt;/code&gt; 값을 나타내고 b &lt;em&gt;n&lt;/em&gt; 값은 &lt;code&gt;feedback&lt;/code&gt; 냅니다. &lt;a href=&quot;http://musicdsp.org/&quot;&gt;musicdsp.org&lt;/a&gt; 는 다른 필터에 대한 자세한 내용과 디지털 방식으로 구현 된 방법에 대한 훌륭한 자료입니다.</target>
        </trans-unit>
        <trans-unit id="5b1fa3e4a65fd651ff4c15543632fa264d4a7d58" translate="yes" xml:space="preserve">
          <source>If you want to use the DOM File API from extensions or other browser chrome code, you can; however, note there are some additional features to be aware of. See &lt;a href=&quot;https://developer.mozilla.org/en/Extensions/Using_the_DOM_File_API_in_chrome_code&quot;&gt;Using the DOM File API in chrome code&lt;/a&gt; for details.</source>
          <target state="translated">확장 또는 다른 브라우저 크롬 코드에서 DOM 파일 API를 사용하려는 경우 다음을 수행 할 수 있습니다. 그러나 알아야 할 몇 가지 추가 기능이 있습니다. 자세한 내용 &lt;a href=&quot;https://developer.mozilla.org/en/Extensions/Using_the_DOM_File_API_in_chrome_code&quot;&gt;은 크롬 코드에서 DOM 파일 API 사용&lt;/a&gt; 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="b7b21d969227ae7833d6beace1b3e69961c920c0" translate="yes" xml:space="preserve">
          <source>If you want your server to obey certain subprotocols, then naturally you'll need extra code on the server. Let's imagine we're using a subprotocol &lt;code&gt;json&lt;/code&gt;. In this subprotocol, all data is passed as &lt;a href=&quot;https://en.wikipedia.org/wiki/JSON&quot;&gt;JSON&lt;/a&gt;. If the client solicits this protocol and the server wants to use it, the server will need to have a JSON parser. Practically speaking, this will be part of a library, but the server will need to pass the data around.</source>
          <target state="translated">서버가 특정 서브 프로토콜을 따르도록하려면 당연히 서버에 추가 코드가 필요합니다. 서브 프로토콜 &lt;code&gt;json&lt;/code&gt; 을 사용한다고 가정 해 봅시다 . 이 서브 프로토콜에서 모든 데이터는 &lt;a href=&quot;https://en.wikipedia.org/wiki/JSON&quot;&gt;JSON&lt;/a&gt; 으로 전달됩니다 . 클라이언트가이 프로토콜을 요청하고 서버가이를 사용하려면 서버에 JSON 파서가 있어야합니다. 실제로 이것은 라이브러리의 일부이지만 서버는 데이터를 전달해야합니다.</target>
        </trans-unit>
        <trans-unit id="8fe63a224f7da01b8506a8616c49720ab5a0583b" translate="yes" xml:space="preserve">
          <source>If you wanted to completely get rid of the stream and discard any enqueued chunks, you'd use &lt;a href=&quot;../readablestream/cancel&quot;&gt;&lt;code&gt;ReadableStream.cancel()&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;../readablestreamdefaultreader/cancel&quot;&gt;&lt;code&gt;ReadableStreamDefaultReader.cancel()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">스트림을 완전히 제거하고 대기열에있는 청크를 삭제하려면 &lt;a href=&quot;../readablestream/cancel&quot;&gt; &lt;code&gt;ReadableStream.cancel()&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;../readablestreamdefaultreader/cancel&quot;&gt; &lt;code&gt;ReadableStreamDefaultReader.cancel()&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="7972945b190505edc93b3a72a6a3051719a81510" translate="yes" xml:space="preserve">
          <source>If you wish to have your function called &lt;em&gt;once&lt;/em&gt; after the specified delay, use &lt;a href=&quot;settimeout&quot;&gt;&lt;code&gt;WindowOrWorkerGlobalScope.setTimeout()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">지정된 지연 후에 함수를 &lt;em&gt;한 번&lt;/em&gt; 호출 하려면 &lt;a href=&quot;settimeout&quot;&gt; &lt;code&gt;WindowOrWorkerGlobalScope.setTimeout()&lt;/code&gt; &lt;/a&gt; 사용 하십시오 .</target>
        </trans-unit>
        <trans-unit id="436c48cee6c78a3a98319348367beb410466d6ba" translate="yes" xml:space="preserve">
          <source>If you wish to work with the bleeding edge of extensions, and want to keep working on upon ratification (assuming, of course, that the extension doesn't change in incompatible ways), that you query the canonical extension name as well as the vendor extension name. For instance:</source>
          <target state="translated">확장 기능의 최첨단을 다루고 비준시 작업을 계속하려면 (물론 확장명이 호환되지 않는 방식으로 변경되지 않는다고 가정 할 경우) 정규 확장명과 공급 업체를 쿼리해야합니다. 확장명. 예를 들어 :</target>
        </trans-unit>
        <trans-unit id="f84340bc76419803f7b903806a2680e2e81830e3" translate="yes" xml:space="preserve">
          <source>If you would like to limit the range of values you see in a cursor, you can use an &lt;code&gt;IDBKeyRange&lt;/code&gt; object and pass it as the first argument to &lt;code&gt;openCursor()&lt;/code&gt; or &lt;code&gt;openKeyCursor()&lt;/code&gt;. You can make a key range that only allows a single key, or one that has a lower or upper bound, or one that has both a lower and upper bound. The bound may be &quot;closed&quot; (i.e., the key range includes the given value(s)) or &quot;open&quot; (i.e., the key range does not include the given value(s)). Here's how it works:</source>
          <target state="translated">커서에 표시되는 값의 범위를 제한하려면 &lt;code&gt;IDBKeyRange&lt;/code&gt; 객체를 사용 하여 &lt;code&gt;openCursor()&lt;/code&gt; 또는 &lt;code&gt;openKeyCursor()&lt;/code&gt; 의 첫 번째 인수로 전달하면됩니다 . 단일 키 또는 하한 또는 상한이있는 키 범위 또는 하한과 상한이 모두있는 키 범위 만 허용하는 키 범위를 만들 수 있습니다. 경계는 &quot;닫힘&quot;(즉, 키 범위는 주어진 값 (들)을 포함 함) 또는 &quot;열기&quot;(즉, 키 범위는 주어진 값 (들)을 포함하지 않음) 일 수있다. 작동 방식은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="cbfcb48b563cec029bdb3ab2c7d04336d55ac239" translate="yes" xml:space="preserve">
          <source>If you would like to use the WebSocket API, it is useful if you have a server. In this article I will show you how to write one in C#. You can do it in any server-side language, but to keep things simple and more understandable, I chose Microsoft's language.</source>
          <target state="translated">WebSocket API를 사용하려면 서버가있는 경우 유용합니다. 이 기사에서는 C #으로 작성하는 방법을 보여줍니다. 모든 서버 측 언어로 수행 할 수 있지만 간단하고 이해하기 쉽게하기 위해 Microsoft의 언어를 선택했습니다.</target>
        </trans-unit>
        <trans-unit id="e37f1ae120d001a14724788664b70e6dc4f56d72" translate="yes" xml:space="preserve">
          <source>If you'd like to know more about how this works, read &lt;a href=&quot;https://tools.ietf.org/html/rfc3550&quot;&gt;RFC 3550: RTP: A Transport Protocol for Real-Time Applications&lt;/a&gt; and &lt;a href=&quot;https://tools.ietf.org/html/rfc4733&quot;&gt;RFC 4733: RTP Payload for DTMF Digits, Telephony Tones, and Telephony Signals&lt;/a&gt;. The details of how DTMF payloads are handled on RTP are beyond the scope of this article. Instead, we'll focus on how to use DTMF within the context of an &lt;a href=&quot;../rtcpeerconnection&quot;&gt;&lt;code&gt;RTCPeerConnection&lt;/code&gt;&lt;/a&gt; by studying how an example works.</source>
          <target state="translated">작동 방식에 대한 자세한 내용을 보려면 &lt;a href=&quot;https://tools.ietf.org/html/rfc3550&quot;&gt;RFC 3550 : RTP : 실시간 응용 프로그램을위한 전송 프로토콜&lt;/a&gt; 및 &lt;a href=&quot;https://tools.ietf.org/html/rfc4733&quot;&gt;RFC 4733 : DTMF 숫자, 전화 신호 및 전화 신호를위한 RTP 페이로드를 참조하십시오&lt;/a&gt; . RTP에서 DTMF 페이로드를 처리하는 방법에 대한 자세한 내용은이 기사의 범위를 벗어납니다. 대신 &lt;a href=&quot;../rtcpeerconnection&quot;&gt; &lt;code&gt;RTCPeerConnection&lt;/code&gt; &lt;/a&gt; 컨텍스트 내에서 DTMF를 사용하는 방법에 중점을 두어 예제의 작동 방식을 연구합니다.</target>
        </trans-unit>
        <trans-unit id="b7f840e081d9f0ebcae0de36b162356281ee9601" translate="yes" xml:space="preserve">
          <source>If you'd like to see the connecting lines, you can remove the lines that call &lt;code&gt;moveTo()&lt;/code&gt;.</source>
          <target state="translated">연결 라인을 보려면 &lt;code&gt;moveTo()&lt;/code&gt; 를 호출하는 라인을 제거 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="fe7acced3c9b16de1eda6b7b6f0c50a452231c9b" translate="yes" xml:space="preserve">
          <source>If you'd prefer, you can use a third-party library like &lt;a href=&quot;https://modernizr.com/docs&quot;&gt;Modernizr&lt;/a&gt; or &lt;a href=&quot;https://github.com/rafrex/detect-it&quot;&gt;Detect It&lt;/a&gt; to do this test for you.</source>
          <target state="translated">원하는 경우 &lt;a href=&quot;https://modernizr.com/docs&quot;&gt;Modernizr&lt;/a&gt; 또는 &lt;a href=&quot;https://github.com/rafrex/detect-it&quot;&gt;Detect It&lt;/a&gt; 과 같은 타사 라이브러리를 사용 하여이 테스트를 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7fbad3b03344c34c2eb41cb5b96421a2d239d46d" translate="yes" xml:space="preserve">
          <source>If you're changing any setting (such as styles, transformations, etc.) which affect the canvas state and you want to make sure the original state is used each time a frame is drawn, you need to save that original state.</source>
          <target state="translated">캔버스 상태에 영향을주는 설정 (예 : 스타일, 변환 등)을 변경하고 프레임을 그릴 때마다 원래 상태가 사용되도록하려면 해당 원래 상태를 저장해야합니다.</target>
        </trans-unit>
        <trans-unit id="68ce4960b627571a4ae244b26261a22f4865e8fd" translate="yes" xml:space="preserve">
          <source>If you're looking to follow the steps listed here, but don't have any media to experiment with, you can grab the trailer to Big Buck Bunny [0] &lt;a href=&quot;http://wayback.archive.org/web/20161102172252id_/http://video.blendertestbuilds.de/download.php?file=download.blender.org/peach/trailer_1080p.mov&quot;&gt;here&lt;/a&gt;. Big Buck Bunny is licensed under the &lt;a href=&quot;http://creativecommons.org/licenses/by/3.0/&quot;&gt;Creative Commons Attribution 3.0&lt;/a&gt; license. Throughout this tutorial, you'll see the filename trailer_1080p.mov which is the download.</source>
          <target state="translated">여기에 나와있는 단계를 수행 찾고 있지만, 실험 할 모든 미디어가없는 경우, 당신은 빅 벅 버니에 트레일러 [0]을 잡을 수 있습니다 &lt;a href=&quot;http://wayback.archive.org/web/20161102172252id_/http://video.blendertestbuilds.de/download.php?file=download.blender.org/peach/trailer_1080p.mov&quot;&gt;여기에&lt;/a&gt; . Big Buck Bunny는 &lt;a href=&quot;http://creativecommons.org/licenses/by/3.0/&quot;&gt;Creative Commons Attribution 3.0&lt;/a&gt; 라이센스에 따라 라이센스가 부여됩니다 . 이 자습서 전체에서 다운로드 한 파일 이름 trailer_1080p.mov가 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="131e8e960b239abcc0f1ee992ec6d71c417b3d22" translate="yes" xml:space="preserve">
          <source>If you're looking to work with audio from the user's camera or microphone you can access it via the &lt;a href=&quot;../media_streams_api&quot;&gt;Media Stream API&lt;/a&gt; and the &lt;a href=&quot;../mediastreamaudiosourcenode&quot;&gt;&lt;code&gt;MediaStreamAudioSourceNode&lt;/code&gt;&lt;/a&gt; interface. This is good for WebRTC and situations where you might want to record or possibly analyse audio.</source>
          <target state="translated">사용자의 카메라 또는 마이크에서 오디오를 사용하려면 &lt;a href=&quot;../media_streams_api&quot;&gt;Media Stream API&lt;/a&gt; 및 &lt;a href=&quot;../mediastreamaudiosourcenode&quot;&gt; &lt;code&gt;MediaStreamAudioSourceNode&lt;/code&gt; &lt;/a&gt; 인터페이스 를 통해 액세스 할 수 있습니다 . 이는 WebRTC 및 오디오를 녹음하거나 분석하려는 상황에 유용합니다.</target>
        </trans-unit>
        <trans-unit id="2ca4674bc4679ac2ad0e2484698eb22183ccc48f" translate="yes" xml:space="preserve">
          <source>If you're only using one external image this can be a good approach, but once you need to track more than one we need to resort to something more clever. It's beyond the scope of this tutorial to look at image pre-loading tactics, but you should keep that in mind.</source>
          <target state="translated">하나의 외부 이미지 만 사용하는 경우 이는 좋은 접근 방법이 될 수 있지만 둘 이상을 추적해야하는 경우보다 영리한 무언가를 사용해야합니다. 이미지 프리로드 전술을 살펴 보는 것은이 튜토리얼의 범위를 벗어납니다. 그러나 명심해야합니다.</target>
        </trans-unit>
        <trans-unit id="aa2640abfd6507fe25062ba55b582a1858886604" translate="yes" xml:space="preserve">
          <source>If you've just created a database, then you probably want to write to it. Here's what that looks like:</source>
          <target state="translated">데이터베이스를 방금 만든 경우 데이터베이스에 쓰려고 할 수 있습니다. 그 모습은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="1548cb22fbeaf614e5b9fd9d5299b85103f26114" translate="yes" xml:space="preserve">
          <source>If you've saved the state, restore it before drawing a new frame.</source>
          <target state="translated">상태를 저장 한 경우 새 프레임을 그리기 전에 상태를 복원하십시오.</target>
        </trans-unit>
        <trans-unit id="3995886a1c6a18fb15656ae2cab0d1ee421232d5" translate="yes" xml:space="preserve">
          <source>If your &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/form&quot;&gt;&lt;code&gt;&amp;lt;form&amp;gt;&lt;/code&gt;&lt;/a&gt; element contains an element named &lt;em&gt;name&lt;/em&gt; then that element overrides the &lt;code&gt;form.name&lt;/code&gt; property, so that you can't access it. Internet Explorer (IE) does not allow the name attribute of an element created using &lt;code&gt;createElement()&lt;/code&gt; to be set or modified using the &lt;code&gt;name&lt;/code&gt; property.</source>
          <target state="translated">당신이 경우 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/form&quot;&gt; &lt;code&gt;&amp;lt;form&amp;gt;&lt;/code&gt; &lt;/a&gt; 요소 요소 이름이 들어 &lt;em&gt;이름을&lt;/em&gt; 요소는보다 우선 다음 &lt;code&gt;form.name&lt;/code&gt; 의 속성을, 그래서 당신은 액세스 할 수 없습니다. 인터넷 익스플로러 (IE) 요소의 이름 속성을 사용하여 생성 할 수 없습니다 &lt;code&gt;createElement()&lt;/code&gt; 설정하거나 사용하여 수정할 &lt;code&gt;name&lt;/code&gt; 속성을.</target>
        </trans-unit>
        <trans-unit id="e214d6522442fe7f1254ef90966a4b48b3f4f4cc" translate="yes" xml:space="preserve">
          <source>If your &lt;code&gt;ChannelSplitterNode&lt;/code&gt; always has one single input, the amount of outputs is defined by a parameter on its constructor and the call to &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/AudioContext/createChannelSplitter&quot;&gt;&lt;code&gt;AudioContext.createChannelSplitter()&lt;/code&gt;&lt;/a&gt;. In the case that no value is given, it will default to &lt;code&gt;6&lt;/code&gt;. If there are fewer channels in the input than there are outputs, supernumerary outputs are silent.</source>
          <target state="translated">귀하의 경우 &lt;code&gt;ChannelSplitterNode&lt;/code&gt; 는 항상 하나 개의 입력을 가지고, 출력의 양이 생성자에 매개 변수 및 호출에 의해 정의된다 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/AudioContext/createChannelSplitter&quot;&gt; &lt;code&gt;AudioContext.createChannelSplitter()&lt;/code&gt; &lt;/a&gt; . 값이 제공되지 않은 경우 기본값은 &lt;code&gt;6&lt;/code&gt; 입니다. 출력에있는 것보다 입력에 적은 수의 채널이있는 경우, 슈퍼 넘버 출력은 무음입니다.</target>
        </trans-unit>
        <trans-unit id="e3b33283060e3e432d8eba04eb22d53564def9cb" translate="yes" xml:space="preserve">
          <source>If your application is running on Firefox OS, please take a look at &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Geolocation/navigator.requestWakeLock()&quot;&gt;geolocation wake lock&lt;/a&gt; to keep your application getting position updates while in the background or screen off.</source>
          <target state="translated">애플리케이션이 Firefox OS에서 실행중인 경우 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Geolocation/navigator.requestWakeLock()&quot;&gt;지리적 위치 깨우기 잠금&lt;/a&gt; 을 확인하여 백그라운드 또는 화면이 꺼져있는 동안 애플리케이션이 위치 업데이트 를 받도록 하십시오.</target>
        </trans-unit>
        <trans-unit id="7dd72c47cee831f9854f2c36cd9fa4d966a0c9b7" translate="yes" xml:space="preserve">
          <source>If your application uses canvas and doesn&amp;rsquo;t need a transparent backdrop, set the &lt;code&gt;alpha&lt;/code&gt; option to &lt;code&gt;false&lt;/code&gt; when creating a drawing context with &lt;a href=&quot;../../htmlcanvaselement/getcontext&quot;&gt;&lt;code&gt;HTMLCanvasElement.getContext()&lt;/code&gt;&lt;/a&gt;. This information can be used internally by the browser to optimize rendering.</source>
          <target state="translated">응용 프로그램에서 캔버스를 사용하고 투명한 배경이 필요하지 않은 경우 &lt;a href=&quot;../../htmlcanvaselement/getcontext&quot;&gt; &lt;code&gt;HTMLCanvasElement.getContext()&lt;/code&gt; &lt;/a&gt; 그리기 컨텍스트를 만들 때 &lt;code&gt;alpha&lt;/code&gt; 옵션을 &lt;code&gt;false&lt;/code&gt; 로 설정하십시오 . 이 정보는 브라우저에서 내부적으로 사용하여 렌더링을 최적화 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="323df4c51c3e93f18a84f6b1f843c6816816829d" translate="yes" xml:space="preserve">
          <source>If your architecture doesn't necessarily have all of the data ready to go at the moment it instantiates the payment interface by calling &lt;code&gt;show()&lt;/code&gt;, specify the &lt;code&gt;detailsPromise&lt;/code&gt; parameter, providing a &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise&quot;&gt;&lt;code&gt;Promise&lt;/code&gt;&lt;/a&gt; that is fulfilled once the data is ready. If this is provided, &lt;code&gt;show()&lt;/code&gt; will not allow the user to interact with the payment interface until the promise is fulfilled, so that data can be updated prior to the user engaging with the payment process.</source>
          <target state="translated">아키텍처에 &lt;code&gt;show()&lt;/code&gt; 를 호출하여 결제 인터페이스를 인스턴스화하는 순간에 모든 데이터를 준비 할 필요가없는 경우 &lt;code&gt;detailsPromise&lt;/code&gt; 매개 변수를 지정 하여 데이터가 준비되면 이행 되는 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise&quot;&gt; &lt;code&gt;Promise&lt;/code&gt; &lt;/a&gt; 를 제공하십시오 . 이것이 제공되면, &lt;code&gt;show()&lt;/code&gt; 는 약속이 이행 될 때까지 사용자가 지불 인터페이스와 상호 작용할 수 없도록하여, 사용자가 지불 프로세스에 참여하기 전에 데이터가 갱신 될 수 있도록합니다.</target>
        </trans-unit>
        <trans-unit id="2495a8efa829d160fed6735daa28561fcd80e355" translate="yes" xml:space="preserve">
          <source>If your browser supports &lt;code&gt;animationcancel&lt;/code&gt;, hiding the box using the button will cause a message to be displayed about the event.</source>
          <target state="translated">브라우저가 &lt;code&gt;animationcancel&lt;/code&gt; 을 지원 하는 경우 버튼을 사용하여 상자를 숨기면 이벤트에 대한 메시지가 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="26b8ad7e02b61dfdbebda110bee02fd2fe70b70d" translate="yes" xml:space="preserve">
          <source>If your browser supports it, you can &lt;a href=&quot;https://mdn.mozillademos.org/en-US/docs/Web/API/Touch_events%24samples/Example?revision=1408810&quot;&gt;see it live&lt;/a&gt;.</source>
          <target state="translated">브라우저가이를 지원 &lt;a href=&quot;https://mdn.mozillademos.org/en-US/docs/Web/API/Touch_events%24samples/Example?revision=1408810&quot;&gt;하면 실시간으로 볼 수 있습니다&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="5d5083d6d753c431710d5ada096860531220eace" translate="yes" xml:space="preserve">
          <source>If your communication needs involve receiving event or message data from the server, consider using &lt;a href=&quot;server-sent_events&quot;&gt;server-sent events&lt;/a&gt; through the &lt;a href=&quot;eventsource&quot;&gt;&lt;code&gt;EventSource&lt;/code&gt;&lt;/a&gt; interface. For full-duplex communication, &lt;a href=&quot;websockets_api&quot;&gt;WebSockets&lt;/a&gt; may be a better choice.</source>
          <target state="translated">통신에서 서버로부터 이벤트 또는 메시지 데이터를 수신해야하는 경우 &lt;a href=&quot;eventsource&quot;&gt; &lt;code&gt;EventSource&lt;/code&gt; &lt;/a&gt; 인터페이스를 통해 &lt;a href=&quot;server-sent_events&quot;&gt;서버가 보낸 이벤트&lt;/a&gt; 사용을 고려 하십시오 . 전이중 통신의 경우 &lt;a href=&quot;websockets_api&quot;&gt;WebSockets&lt;/a&gt; 가 더 나은 선택 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1902d240942eaacb1d961664c9a7d0556020e55e" translate="yes" xml:space="preserve">
          <source>If your goal is to record camera and/or microphone input, you may wish to examine the available input devices before beginning the process of constructing the &lt;code&gt;MediaRecorder&lt;/code&gt;. To do so, you'll need to call &lt;a href=&quot;mediadevices/enumeratedevices&quot;&gt;&lt;code&gt;navigator.mediaDevices.enumerateDevices()&lt;/code&gt;&lt;/a&gt; to get a list of the available media devices. You can then examine that list and identify the potential input sources, and even filter the list based on desired criteria.</source>
          <target state="translated">카메라 및 / 또는 마이크 입력을 기록하는 것이 목표라면 &lt;code&gt;MediaRecorder&lt;/code&gt; 구성 프로세스를 시작하기 전에 사용 가능한 입력 장치를 검사하는 것이 좋습니다. 이렇게하려면 사용 가능한 미디어 장치 목록을 얻으려면 &lt;a href=&quot;mediadevices/enumeratedevices&quot;&gt; &lt;code&gt;navigator.mediaDevices.enumerateDevices()&lt;/code&gt; &lt;/a&gt; 를 호출해야 합니다. 그런 다음 해당 목록을 검사하고 잠재적 인 입력 소스를 식별하고 원하는 기준에 따라 목록을 필터링 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="44ad6454cb8eb50d68b79888fc02dbc28104f50c" translate="yes" xml:space="preserve">
          <source>If your object is a text node, you can use the data attribute and retrieve the text content of the node.</source>
          <target state="translated">객체가 텍스트 노드 인 경우 data 속성을 사용하고 노드의 텍스트 내용을 검색 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="928774c703409e93284185ad3a9e4aa5662aa2dd" translate="yes" xml:space="preserve">
          <source>If your server worker is active on a client being served with the &lt;code&gt;Service-Worker-Allowed&lt;/code&gt; header, you can specify a list of max scopes for that worker.</source>
          <target state="translated">서버 워커가 &lt;code&gt;Service-Worker-Allowed&lt;/code&gt; 헤더 와 함께 제공되는 클라이언트에서 활성화 된 경우 해당 워커의 최대 범위 목록을 지정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0aa7872d7efb0b4aa058429a35ee098b246d1270" translate="yes" xml:space="preserve">
          <source>If your service worker has previously been installed, but then a new version of the worker is available on refresh or page load, the new version is installed in the background, but not yet activated. It is only activated when there are no longer any pages loaded that are still using the old service worker. As soon as there are no more such pages still loaded, the new service worker activates.</source>
          <target state="translated">서비스 워커가 이전에 설치되었지만 새로 고침 또는 페이지로드시 새 버전의 워커를 사용할 수있는 경우 새 버전은 백그라운드에 설치되지만 아직 활성화되지는 않습니다. 이전 서비스 워커를 여전히 사용중인 페이지가 더 이상로드되지 않은 경우에만 활성화됩니다. 이러한 페이지가 더 이상로드되지 않으면 새로운 서비스 워커가 활성화됩니다.</target>
        </trans-unit>
        <trans-unit id="76df2dff50c923af0a6405d710c7578a8c337839" translate="yes" xml:space="preserve">
          <source>If your web application is located at &lt;code&gt;http://burgers.example.com&lt;/code&gt;, you can register a protocol handler for it to handle &quot;web+burger&quot; links like this:</source>
          <target state="translated">웹 애플리케이션이 &lt;code&gt;http://burgers.example.com&lt;/code&gt; 에있는 경우 다음 과 같이 &quot;web + burger&quot;링크를 처리하기 위해 프로토콜 핸들러를 등록 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="71319a867f98faf62cb623735c9564d15e7f874f" translate="yes" xml:space="preserve">
          <source>If your web application needs to open a new window, such as a tool palette which can contain multiple panels, and wants to position it so that it occupies the entire vertical space available, you can do so using code similar to what's seen here.</source>
          <target state="translated">웹 애플리케이션이 여러 패널을 포함 할 수있는 도구 팔레트와 같은 새 창을 열어야하고 사용 가능한 전체 수직 공간을 차지하도록 위치를 지정하려는 경우 여기에 표시된 것과 유사한 코드를 사용하여이를 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3a680d9483b3868a93a84513bcd595654a4f7ddc" translate="yes" xml:space="preserve">
          <source>If your website or application contains sound, you should allow the user control over it, otherwise again, it will become annoying. This can be achieved by play/stop and volume/mute controls. The &lt;a href=&quot;using_web_audio_api&quot;&gt;Using the Web Audio API&lt;/a&gt; tutorial goes over how to do this.</source>
          <target state="translated">웹 사이트 나 응용 프로그램에 소리가 들어 있으면 사용자가 제어 할 수 있도록해야합니다. 그렇지 않으면 다시 성가 시게됩니다. 재생 / 정지 및 볼륨 / 음소거 컨트롤을 통해이 작업을 수행 할 수 있습니다. &lt;a href=&quot;using_web_audio_api&quot;&gt;웹 오디오 API를 사용하여&lt;/a&gt; 튜토리얼에서는이 작업을 수행하는 방법을 통해 간다.</target>
        </trans-unit>
        <trans-unit id="ec535b07f61356afe898f40b14788552c7417528" translate="yes" xml:space="preserve">
          <source>If, on the other hand, full-screen mode is already in effect, we call &lt;a href=&quot;../document/exitfullscreen&quot;&gt;&lt;code&gt;document.exitFullscreen()&lt;/code&gt;&lt;/a&gt; to disable full-screen mode.</source>
          <target state="translated">반면에 전체 화면 모드가 이미 적용된 경우 &lt;a href=&quot;../document/exitfullscreen&quot;&gt; &lt;code&gt;document.exitFullscreen()&lt;/code&gt; &lt;/a&gt; 을 호출 하여 전체 화면 모드를 비활성화합니다.</target>
        </trans-unit>
        <trans-unit id="50e19fda0d5b4b74a4a1a1d584e56578693a4ea4" translate="yes" xml:space="preserve">
          <source>Image</source>
          <target state="translated">Image</target>
        </trans-unit>
        <trans-unit id="e67b58624e70884cd5de353ef28c3bbb3f37a0a4" translate="yes" xml:space="preserve">
          <source>Image Capture API</source>
          <target state="translated">이미지 캡처 API</target>
        </trans-unit>
        <trans-unit id="8058c6c0c0aa2f81cfb12c5a2bcf43626baa9eac" translate="yes" xml:space="preserve">
          <source>Image height used for reading pixel data from memory</source>
          <target state="translated">메모리에서 픽셀 데이터를 읽는 데 사용되는 이미지 높이</target>
        </trans-unit>
        <trans-unit id="79b809e76a21a719209ee49c813727e7e99304e7" translate="yes" xml:space="preserve">
          <source>Image quality parameter</source>
          <target state="translated">화질 파라미터</target>
        </trans-unit>
        <trans-unit id="57f6c3ffdba16c05295820e4041709c6fed8c1df" translate="yes" xml:space="preserve">
          <source>Image smoothing</source>
          <target state="translated">이미지 스무딩</target>
        </trans-unit>
        <trans-unit id="cb38ec2700f360493809c3048ceffd73d54d64fa" translate="yes" xml:space="preserve">
          <source>Image smoothing mode; if disabled, images will not be smoothed if scaled.</source>
          <target state="translated">이미지 스무딩 모드; 비활성화하면 크기가 조정되면 이미지가 부드럽게되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="0ef9de975cdef9d9d9b896b68103ad59db30e33a" translate="yes" xml:space="preserve">
          <source>ImageBitmap</source>
          <target state="translated">ImageBitmap</target>
        </trans-unit>
        <trans-unit id="6a172a699ec49e865531d73b7ff007002bed3968" translate="yes" xml:space="preserve">
          <source>ImageBitmap as source image</source>
          <target state="translated">소스 이미지로서의 ImageBitmap</target>
        </trans-unit>
        <trans-unit id="d0ef406f9f61ca577f188d758aa109fead0b5ca8" translate="yes" xml:space="preserve">
          <source>ImageBitmap.close</source>
          <target state="translated">ImageBitmap.close</target>
        </trans-unit>
        <trans-unit id="5cf57dcf8669982b860431d06057d5836299758a" translate="yes" xml:space="preserve">
          <source>ImageBitmap.height</source>
          <target state="translated">ImageBitmap.height</target>
        </trans-unit>
        <trans-unit id="4ea2645c6f967f0323119ce8124791a8376f8aeb" translate="yes" xml:space="preserve">
          <source>ImageBitmap.width</source>
          <target state="translated">ImageBitmap.width</target>
        </trans-unit>
        <trans-unit id="91a39bdc5a33f203d5c2f138f0da931369fac84f" translate="yes" xml:space="preserve">
          <source>ImageBitmapRenderingContext</source>
          <target state="translated">ImageBitmapRenderingContext</target>
        </trans-unit>
        <trans-unit id="8dcf282e2a54020116d600d91b2efb28cb918414" translate="yes" xml:space="preserve">
          <source>ImageBitmapRenderingContext.transferFromImageBitmap</source>
          <target state="translated">ImageBitmapRenderingContext.transferFromImageBitmap</target>
        </trans-unit>
        <trans-unit id="8c336bfb3779001748cd68de43ea29f8f4e2569a" translate="yes" xml:space="preserve">
          <source>ImageCapture</source>
          <target state="translated">ImageCapture</target>
        </trans-unit>
        <trans-unit id="6a695339a52264bb2994df6ecb91dad6e435f6b8" translate="yes" xml:space="preserve">
          <source>ImageCapture.getPhotoCapabilities</source>
          <target state="translated">ImageCapture.getPhotoCapabilities</target>
        </trans-unit>
        <trans-unit id="374d1f58469fe5602933c92421242cc8747d221e" translate="yes" xml:space="preserve">
          <source>ImageCapture.getPhotoSettings</source>
          <target state="translated">ImageCapture.getPhotoSettings</target>
        </trans-unit>
        <trans-unit id="23e126b41711a703f83daf84c1eb49c4c3782628" translate="yes" xml:space="preserve">
          <source>ImageCapture.grabFrame</source>
          <target state="translated">ImageCapture.grabFrame</target>
        </trans-unit>
        <trans-unit id="8fc7753068a1704437db9b0f8e0afc5a1d89f952" translate="yes" xml:space="preserve">
          <source>ImageCapture.takePhoto</source>
          <target state="translated">ImageCapture.takePhoto</target>
        </trans-unit>
        <trans-unit id="662f38ff55d3b6cd765669b3efdb2b563125e981" translate="yes" xml:space="preserve">
          <source>ImageCapture.track</source>
          <target state="translated">ImageCapture.track</target>
        </trans-unit>
        <trans-unit id="682b65e19d67a5e783299b757e21bec2832c6fb5" translate="yes" xml:space="preserve">
          <source>ImageData</source>
          <target state="translated">ImageData</target>
        </trans-unit>
        <trans-unit id="433ff3ce0a489a34348ec015a91ac57812bae7a7" translate="yes" xml:space="preserve">
          <source>ImageData.constructor</source>
          <target state="translated">ImageData.constructor</target>
        </trans-unit>
        <trans-unit id="36a6a7f4f47ce8116630d7d1001ca2096b4e0fc4" translate="yes" xml:space="preserve">
          <source>ImageData.data</source>
          <target state="translated">ImageData.data</target>
        </trans-unit>
        <trans-unit id="6a3421601fdbdd23f2ad9b297dd2f67afe1f549c" translate="yes" xml:space="preserve">
          <source>ImageData.height</source>
          <target state="translated">ImageData.height</target>
        </trans-unit>
        <trans-unit id="ea11043e0fbc10e742c776244499730fa9dedae9" translate="yes" xml:space="preserve">
          <source>ImageData.width</source>
          <target state="translated">ImageData.width</target>
        </trans-unit>
        <trans-unit id="b09bb8217536875cfdc0cf5e6879fe4133d68af6" translate="yes" xml:space="preserve">
          <source>ImageElement</source>
          <target state="translated">ImageElement</target>
        </trans-unit>
        <trans-unit id="0fb8b6b3dbe77d633f235c892a1bfe52dc026eae" translate="yes" xml:space="preserve">
          <source>ImageSource</source>
          <target state="translated">ImageSource</target>
        </trans-unit>
        <trans-unit id="684812a1450c41e88a2cb1153fc732f6cb993fea" translate="yes" xml:space="preserve">
          <source>ImageValue</source>
          <target state="translated">ImageValue</target>
        </trans-unit>
        <trans-unit id="0c10e289075f54ccf039276d9830b43d70658650" translate="yes" xml:space="preserve">
          <source>Imagine other ways we could use playbackRate, such as improving accessibility for users with vestibular disorders by letting them slow down animations across an entire site. That&amp;rsquo;s impossible to do with CSS without recalculating durations in every CSS rule, but with the Web Animations API, we could use the upcoming (not supported in browsers yet!) &lt;a href=&quot;../document/getanimations&quot;&gt;&lt;code&gt;document.getAnimations()&lt;/code&gt;&lt;/a&gt; method to loop over each animation on the page and halve their &lt;code&gt;playbackRate&lt;/code&gt;s, like so:</source>
          <target state="translated">전정 장애가있는 사용자의 접근성을 개선하여 전체 사이트에서 애니메이션 속도를 저하시키는 등 재생률을 사용할 수있는 다른 방법을 상상해보십시오. 모든 CSS 규칙에서 지속 시간을 다시 계산하지 않고 CSS를 사용하는 것은 불가능하지만 웹 애니메이션 API를 사용하면 곧 (브라우저에서 지원되지 않습니다!) &lt;a href=&quot;../document/getanimations&quot;&gt; &lt;code&gt;document.getAnimations()&lt;/code&gt; &lt;/a&gt; 메서드를 사용하여 페이지의 각 애니메이션을 반복하고 반으로 줄일 수 있습니다 다음 과 같이 &lt;code&gt;playbackRate&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="1243e5f5f9ef2b40b2b0a0a62ea8ada7277c3647" translate="yes" xml:space="preserve">
          <source>Imagine that Naomi and Priya are engaged in a discussion using the chat software, and Naomi decides to open a video call between the two. Here's the expected sequence of events:</source>
          <target state="translated">Naomi와 Priya가 채팅 소프트웨어를 사용하여 토론에 참여하고 Naomi가 둘 사이에 화상 통화를 시작하기로 결정했다고 상상해보십시오. 예상되는 이벤트 순서는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="39c25d7b379891246cd58915a34a7659220f577d" translate="yes" xml:space="preserve">
          <source>Immediately after calling &lt;code&gt;stop()&lt;/code&gt;, the &lt;a href=&quot;readystate&quot;&gt;&lt;code&gt;track&lt;/code&gt;&lt;/a&gt; state is set to &lt;code&gt;ended&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;stop()&lt;/code&gt; 을 호출 한 직후 , &lt;a href=&quot;readystate&quot;&gt; &lt;code&gt;track&lt;/code&gt; &lt;/a&gt; 상태는 &lt;code&gt;ended&lt;/code&gt; 로 설정됩니다 .</target>
        </trans-unit>
        <trans-unit id="8d810bee3172b9261e9eac941c91dc840d20d5aa" translate="yes" xml:space="preserve">
          <source>Immediately returns a transaction object (&lt;a href=&quot;idbtransaction&quot;&gt;&lt;code&gt;IDBTransaction&lt;/code&gt;&lt;/a&gt;) containing the &lt;a href=&quot;idbtransaction/objectstore&quot;&gt;&lt;code&gt;IDBTransaction.objectStore&lt;/code&gt;&lt;/a&gt; method, which you can use to access your object store. Runs in a separate thread.</source>
          <target state="translated">개체 저장소에 액세스하는 데 사용할 수 있는 &lt;a href=&quot;idbtransaction/objectstore&quot;&gt; &lt;code&gt;IDBTransaction.objectStore&lt;/code&gt; &lt;/a&gt; 메서드가 포함 된 트랜잭션 개체 ( &lt;a href=&quot;idbtransaction&quot;&gt; &lt;code&gt;IDBTransaction&lt;/code&gt; &lt;/a&gt; )를 즉시 반환합니다 . 별도의 스레드에서 실행됩니다.</target>
        </trans-unit>
        <trans-unit id="e9b52a558205d7af53345cf107ceba8890735112" translate="yes" xml:space="preserve">
          <source>Immediately terminates the worker. This does not offer the worker an opportunity to finish its operations; it is simply stopped at once. ServiceWorker instances do not support this method.</source>
          <target state="translated">작업자를 즉시 ​​종료합니다. 이것은 근로자에게 작업을 완료 할 수있는 기회를 제공하지 않습니다. 단순히 한 번에 중지됩니다. ServiceWorker 인스턴스는이 방법을 지원하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="b2b33385dd6d86ef70719d6e10de5f1a2054743f" translate="yes" xml:space="preserve">
          <source>Immutability of the texture format and size</source>
          <target state="translated">텍스처 형식 및 크기의 불변성</target>
        </trans-unit>
        <trans-unit id="f9efa870c9eb58ac7ec5d0106d206be5b17761ee" translate="yes" xml:space="preserve">
          <source>Implement Custom Gestures</source>
          <target state="translated">맞춤 제스처 구현</target>
        </trans-unit>
        <trans-unit id="8781d615fd77be9578225c40ac67b9471394cced" translate="yes" xml:space="preserve">
          <source>Implementation</source>
          <target state="translated">Implementation</target>
        </trans-unit>
        <trans-unit id="09c7f1f8651e55a0f3b93098c2dfb044a4d15453" translate="yes" xml:space="preserve">
          <source>Implementation and deployment status</source>
          <target state="translated">구현 및 배포 상태</target>
        </trans-unit>
        <trans-unit id="47c97711d45f1e786d989837b0e43e403cabab42" translate="yes" xml:space="preserve">
          <source>Implementation dependent number of maximum texture units. At least 8.</source>
          <target state="translated">구현에 따른 최대 텍스처 단위 수. 적어도 8.</target>
        </trans-unit>
        <trans-unit id="c7562fff6a89b7185ca83a1afafada8cb2211bd3" translate="yes" xml:space="preserve">
          <source>Implementation differences</source>
          <target state="translated">구현 차이</target>
        </trans-unit>
        <trans-unit id="3ad7939217fce1bf3517c4d7f04b40fec2aa121b" translate="yes" xml:space="preserve">
          <source>Implementation in Shadow DOM.</source>
          <target state="translated">Shadow DOM에서의 구현.</target>
        </trans-unit>
        <trans-unit id="e0bf2dc952ab6d2617aa9b9ee013534f9eeb5b62" translate="yes" xml:space="preserve">
          <source>Implementation notes</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="58be97e0b51893ffcadc001b69f66a1581dcaca1" translate="yes" xml:space="preserve">
          <source>Implementation seems &lt;a href=&quot;https://bugs.webkit.org/show_bug.cgi?id=19324&quot;&gt;defect&lt;/a&gt;.</source>
          <target state="translated">구현에는 &lt;a href=&quot;https://bugs.webkit.org/show_bug.cgi?id=19324&quot;&gt;결함이있는&lt;/a&gt; 것 같습니다 .</target>
        </trans-unit>
        <trans-unit id="8a5483d1883a3fb718909070b736ff9d0397a569" translate="yes" xml:space="preserve">
          <source>Implementation status</source>
          <target state="translated">시행 현황</target>
        </trans-unit>
        <trans-unit id="220c7622837d5d7cae9f7918c973f2a1cbe72e99" translate="yes" xml:space="preserve">
          <source>Implementation tracked in &lt;a href=&quot;https://bugzil.la/1290958&quot;&gt;bug 1290958&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;https://bugzil.la/1290958&quot;&gt;버그 1290958&lt;/a&gt; 에서 추적 된 구현</target>
        </trans-unit>
        <trans-unit id="12a90de35060a0cc2b9770c959b6146dd7031ace" translate="yes" xml:space="preserve">
          <source>Implementation.createDocument</source>
          <target state="translated">Implementation.createDocument</target>
        </trans-unit>
        <trans-unit id="25ca5b2dc56298eca7c2bced595749a236c8d727" translate="yes" xml:space="preserve">
          <source>Implementation.createDocumentType</source>
          <target state="translated">Implementation.createDocumentType</target>
        </trans-unit>
        <trans-unit id="06020df99ff290a9493c8191ed7c2c6062e3214e" translate="yes" xml:space="preserve">
          <source>Implementation.createHTMLDocument</source>
          <target state="translated">Implementation.createHTMLDocument</target>
        </trans-unit>
        <trans-unit id="26b7b4e6f46539a3eb03e2a39d84dff09faa0fc9" translate="yes" xml:space="preserve">
          <source>ImplementationList</source>
          <target state="translated">ImplementationList</target>
        </trans-unit>
        <trans-unit id="98b1ea6a6f11c1f6ef7bf1265ba1e42e78f2f01c" translate="yes" xml:space="preserve">
          <source>Implemented a slightly different version of the spec.</source>
          <target state="translated">약간 다른 버전의 사양을 구현했습니다.</target>
        </trans-unit>
        <trans-unit id="3a904e4fc692650dc2965e4983ec71e583e91f83" translate="yes" xml:space="preserve">
          <source>Implemented but disabled by default.</source>
          <target state="translated">기본적으로 구현되었지만 비활성화되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="e89ae642b7cd47e1baa02eeafc53e2234054c503" translate="yes" xml:space="preserve">
          <source>Implemented from other places</source>
          <target state="translated">다른 장소에서 구현</target>
        </trans-unit>
        <trans-unit id="cbbbeb95ad4e9a2efc17a8aeec91d9b4ca7ed151" translate="yes" xml:space="preserve">
          <source>Implemented on &lt;a href=&quot;https://developer.mozilla.org/docs/Web/API/HTMLElement&quot;&gt;HTMLElement&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;https://developer.mozilla.org/docs/Web/API/HTMLElement&quot;&gt;HTMLElement에&lt;/a&gt; 구현되었습니다 .</target>
        </trans-unit>
        <trans-unit id="91713270fde79e05b406e666d19c7226fdae27e2" translate="yes" xml:space="preserve">
          <source>Implemented on &lt;code&gt;AudioContext&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;AudioContext&lt;/code&gt; 에서 구현</target>
        </trans-unit>
        <trans-unit id="7c0c940dda325630e616ff9c23c4dc64630b06c2" translate="yes" xml:space="preserve">
          <source>Implemented on the proprietary &lt;code&gt;&lt;a href=&quot;https://msdn.microsoft.com/en-us/library/hh826029(VS.85).aspx&quot;&gt;ClientRect&lt;/a&gt;&lt;/code&gt; interface.</source>
          <target state="translated">독점적 인 &lt;code&gt;&lt;a href=&quot;https://msdn.microsoft.com/en-us/library/hh826029(VS.85).aspx&quot;&gt;ClientRect&lt;/a&gt;&lt;/code&gt; 인터페이스 에 구현되었습니다 .</target>
        </trans-unit>
        <trans-unit id="f6c6f0ef5cb7c06f762c5402936f00c09119da66" translate="yes" xml:space="preserve">
          <source>Implemented via &lt;code&gt;ActiveXObject&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;ActiveXObject&lt;/code&gt; 를 통해 구현</target>
        </trans-unit>
        <trans-unit id="4ffbbd1f205a9acd3b6a1c4de5e7eb04225c5d98" translate="yes" xml:space="preserve">
          <source>Implementing &quot;infinite scrolling&quot; web sites, where more and more content is loaded and rendered as you scroll, so that the user doesn't have to flip through pages.</source>
          <target state="translated">스크롤 할 때 점점 더 많은 컨텐츠가로드되고 렌더링되는 &quot;무한 스크롤&quot;웹 사이트를 구현하여 사용자가 페이지를 넘길 필요가 없습니다.</target>
        </trans-unit>
        <trans-unit id="49e62060d8bfcee57db088615e2645518fe8affb" translate="yes" xml:space="preserve">
          <source>Implementing controls using the Gamepad API</source>
          <target state="translated">게임 패드 API를 사용하여 컨트롤 구현</target>
        </trans-unit>
        <trans-unit id="31309f5ed18c8823a30cc233e665b235c90da800" translate="yes" xml:space="preserve">
          <source>Implementing intersection detection in the past involved event handlers and loops calling methods like &lt;a href=&quot;element/getboundingclientrect&quot;&gt;&lt;code&gt;Element.getBoundingClientRect()&lt;/code&gt;&lt;/a&gt; to build up the needed information for every element affected. Since all this code runs on the main thread, even one of these can cause performance problems. When a site is loaded with these tests, things can get downright ugly.</source>
          <target state="translated">과거에 교차 감지를 구현하면 영향을받는 모든 요소에 필요한 정보를 빌드하기 위해 &lt;a href=&quot;element/getboundingclientrect&quot;&gt; &lt;code&gt;Element.getBoundingClientRect()&lt;/code&gt; &lt;/a&gt; 와 같은 메소드를 호출하는 이벤트 핸들러 및 루프가 포함 되었습니다. 이 코드는 모두 메인 스레드에서 실행되므로이 ​​중 하나라도 성능 문제를 일으킬 수 있습니다. 이러한 테스트를 통해 사이트를로드하면 상황이 너무 나빠질 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5cb52e57784810681740446b155dd8e8599f245b" translate="yes" xml:space="preserve">
          <source>Implements a general &lt;strong&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/infinite%20impulse%20response&quot;&gt;infinite impulse response&lt;/a&gt;&lt;/strong&gt; (IIR) filter; this type of filter can be used to implement tone control devices and graphic equalizers as well.</source>
          <target state="translated">일반적인 &lt;strong&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/infinite%20impulse%20response&quot;&gt;무한 임펄스 응답&lt;/a&gt;&lt;/strong&gt; (IIR) 필터를 구현합니다 . 이 유형의 필터는 톤 제어 장치 및 그래픽 이퀄라이저도 구현하는 데 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="24a94294f248c853b8d5834a66c58dd3b768af8a" translate="yes" xml:space="preserve">
          <source>Implements the document object model (DOM) representation of the font element. The HTML Font Element &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/font&quot;&gt;&lt;code&gt;&amp;lt;font&amp;gt;&lt;/code&gt;&lt;/a&gt; defines the font size, font face and color of text.</source>
          <target state="translated">글꼴 요소의 DOM (Document Object Model) 표현을 구현합니다. HTML 글꼴 요소 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/font&quot;&gt; &lt;code&gt;&amp;lt;font&amp;gt;&lt;/code&gt; &lt;/a&gt; 는 글꼴 크기, 글꼴 및 텍스트 색상을 정의합니다.</target>
        </trans-unit>
        <trans-unit id="974577006e52603b9cda5934d004c2ce6a39cbf1" translate="yes" xml:space="preserve">
          <source>Important Data Types</source>
          <target state="translated">중요한 데이터 유형</target>
        </trans-unit>
        <trans-unit id="39e930d0ac687b5ef91c92fd4b0d00ef6222ada8" translate="yes" xml:space="preserve">
          <source>Importing images into a canvas is basically a two step process:</source>
          <target state="translated">캔버스로 이미지를 가져 오는 것은 기본적으로 2 단계 프로세스입니다.</target>
        </trans-unit>
        <trans-unit id="3332127ba0d69037527bca6aabf450833df70852" translate="yes" xml:space="preserve">
          <source>Importing scripts and libraries</source>
          <target state="translated">스크립트 및 라이브러리 가져 오기</target>
        </trans-unit>
        <trans-unit id="824ccd6f23bc86a0f9b7c8ac337bcd06d1182948" translate="yes" xml:space="preserve">
          <source>Imports one or more scripts into the worker's scope. You can specify as many as you'd like, separated by commas. For example:&lt;code&gt; importScripts('foo.js', 'bar.js');&lt;/code&gt;</source>
          <target state="translated">하나 이상의 스크립트를 작업자의 범위로 가져옵니다. 쉼표로 구분하여 원하는만큼 지정할 수 있습니다. 예를 들면 다음과 같습니다. &lt;code&gt; importScripts('foo.js', 'bar.js');&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="ec58694f82f582bcbd8a134122951729ea8fed8b" translate="yes" xml:space="preserve">
          <source>Improving HTML5 Canvas Performance &amp;ndash; HTML5 Rocks</source>
          <target state="translated">HTML5 캔버스 성능 향상 &amp;ndash; HTML5 Rocks</target>
        </trans-unit>
        <trans-unit id="97dc33df388b79e95964eb63f65372610e23edab" translate="yes" xml:space="preserve">
          <source>Improving compatibility using WebRTC adapter.js</source>
          <target state="translated">WebRTC adapter.js를 사용하여 호환성 개선</target>
        </trans-unit>
        <trans-unit id="edfb7efd6a8f89bcd77c65d86232cea4dc06d838" translate="yes" xml:space="preserve">
          <source>Improving scrolling performance with passive listeners</source>
          <target state="translated">패시브 리스너로 스크롤 성능 향상</target>
        </trans-unit>
        <trans-unit id="8a480b0fbcba47707d27f84922b5a01fa531c028" translate="yes" xml:space="preserve">
          <source>In 1939 the &lt;a href=&quot;https://en.wikipedia.org/wiki/View-Master&quot;&gt;View-Master device&lt;/a&gt; was created, allowing people to see 3D pictures. The device displayed images stored on cardboard disks containing stereoscopic 3D pairs of small color photographs. After years of development the military got interested in using such technology, and Project Headsight was born in 1961 &amp;mdash; this involved a helmet incorporating a video screen with a head-tracking system.</source>
          <target state="translated">1939 년에 &lt;a href=&quot;https://en.wikipedia.org/wiki/View-Master&quot;&gt;View-Master 장치&lt;/a&gt; 가 만들어져 사람들이 3D 사진을 볼 수있게되었습니다. 이 장치는 입체 3D 작은 컬러 사진 쌍을 포함하는 골판지 디스크에 저장된 이미지를 표시했습니다. 수년간의 개발 끝에 군대는 그러한 기술의 사용에 관심을 가지게되었고 1961 년에 프로젝트 헤드 사이트 (Project Headsight)가 탄생했습니다. 여기에는 헤드 트래킹 시스템과 비디오 스크린을 통합 한 헬멧이 포함되었습니다.</target>
        </trans-unit>
        <trans-unit id="cf771940420f8aa05cb387689da22ce33a2e7e17" translate="yes" xml:space="preserve">
          <source>In &lt;a href=&quot;https://caniuse.com/#search=noopener&quot;&gt;some browsers&lt;/a&gt;, a &lt;code&gt;rel=&quot;noopener&quot;&lt;/code&gt; attribute on the originating &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/a&quot;&gt;&lt;code&gt;&amp;lt;a&amp;gt;&lt;/code&gt;&lt;/a&gt; element will prevent the &lt;code&gt;window.opener&lt;/code&gt; reference from being set, in which case this property will return &lt;code&gt;null&lt;/code&gt;.</source>
          <target state="translated">에서는 &lt;a href=&quot;https://caniuse.com/#search=noopener&quot;&gt;일부 브라우저&lt;/a&gt; 하는 &lt;code&gt;rel=&quot;noopener&quot;&lt;/code&gt; 원래의 속성 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/a&quot;&gt; &lt;code&gt;&amp;lt;a&amp;gt;&lt;/code&gt; &lt;/a&gt; 요소는 막을 &lt;code&gt;window.opener&lt;/code&gt; 의 이 속성이 리턴되는 경우에 참조되는 집합에서, &lt;code&gt;null&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="dc4f871c4dd93781ac9e0af814028225cdf965ef" translate="yes" xml:space="preserve">
          <source>In &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Selection/en/JavaScript&quot;&gt;JavaScript&lt;/a&gt;, this method is called automatically when a function the selection object is passed to requires a string:</source>
          <target state="translated">에서 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Selection/en/JavaScript&quot;&gt;자바 스크립트를&lt;/a&gt; 선택 객체에 전달되는 함수는 문자열을 필요로하는 경우,이 메소드는 자동으로 호출됩니다</target>
        </trans-unit>
        <trans-unit id="675d8600d33219a5208759d764f74ed5a33f8b8d" translate="yes" xml:space="preserve">
          <source>In &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Quirks_Mode_and_Standards_Mode&quot;&gt;quirks mode&lt;/a&gt;, the class names are compared in a case-insensitive fashion. Otherwise, they're case sensitive.</source>
          <target state="translated">에서 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Quirks_Mode_and_Standards_Mode&quot;&gt;단점 모드&lt;/a&gt; , 클래스 이름은 대소 문자를 구분 방식으로 비교된다. 그렇지 않으면 대소 문자를 구분합니다.</target>
        </trans-unit>
        <trans-unit id="f2cdf692409a28e7be04db0cc7e1f36b8341f7b3" translate="yes" xml:space="preserve">
          <source>In &lt;a href=&quot;https://en.wikipedia.org/wiki/Through_the_Looking-Glass&quot;&gt;Through the Looking-Glass&lt;/a&gt;, Alice travels to a world where she must run to stay in place &amp;mdash; and run twice as fast to move forward! In the Red Queen&amp;rsquo;s Race example, Alice and the Red Queen are running to stay in place (check out the &lt;a href=&quot;http://codepen.io/rachelnabors/pen/PNGGaV&quot;&gt;full code on Codepen&lt;/a&gt;):</source>
          <target state="translated">에서 &lt;a href=&quot;https://en.wikipedia.org/wiki/Through_the_Looking-Glass&quot;&gt;거울 나라의 앨리스&lt;/a&gt; , 앨리스는 그녀가 자리를 유지하기 위해 실행해야 세계로 여행 - 앞으로 이동하는 배 빠른 실행! Red Queen 's Race 예제에서 Alice와 Red Queen은 제자리를 유지하기 위해 실행 중입니다 ( &lt;a href=&quot;http://codepen.io/rachelnabors/pen/PNGGaV&quot;&gt;Codepen&lt;/a&gt; 에서 전체 코드 확인 ).</target>
        </trans-unit>
        <trans-unit id="f18bcf12560be2ba38bc278505b142eae22a4ea5" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;getData()&lt;/code&gt; we create a new request using the &lt;a href=&quot;../request/request&quot;&gt;&lt;code&gt;Request.Request&lt;/code&gt;&lt;/a&gt; constructor, then use it to fetch an OGG music track. We also use &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/AudioContext/createBufferSource&quot;&gt;&lt;code&gt;AudioContext.createBufferSource&lt;/code&gt;&lt;/a&gt; to create an audio buffer source. When the fetch is successful, we read an &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/ArrayBuffer&quot;&gt;&lt;code&gt;ArrayBuffer&lt;/code&gt;&lt;/a&gt; out of the response using &lt;code&gt;arrayBuffer()&lt;/code&gt;, decode the audio data using &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/AudioContext/decodeAudioData&quot;&gt;&lt;code&gt;AudioContext.decodeAudioData&lt;/code&gt;&lt;/a&gt;, set the decoded data as the audio buffer source's buffer (&lt;code&gt;source.buffer&lt;/code&gt;), then connect the source up to the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/AudioContext/destination&quot;&gt;&lt;code&gt;AudioContext.destination&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">에서 &lt;code&gt;getData()&lt;/code&gt; 우리가 사용하여 새 요청을 만들 &lt;a href=&quot;../request/request&quot;&gt; &lt;code&gt;Request.Request&lt;/code&gt; &lt;/a&gt; 생성자를, 다음 OGG 음악 트랙을 가져 오기 위해 그것을 사용할 수 있습니다. 우리는 또한 사용 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/AudioContext/createBufferSource&quot;&gt; &lt;code&gt;AudioContext.createBufferSource&lt;/code&gt; 를&lt;/a&gt; 오디오 버퍼 소스를 만들 수 있습니다. (가) 성공적으로 페치 할 때, 우리는 판독 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/ArrayBuffer&quot;&gt; &lt;code&gt;ArrayBuffer&lt;/code&gt; 을&lt;/a&gt; 이용하여 반응에서 &lt;code&gt;arrayBuffer()&lt;/code&gt; 사용하여 오디오 데이터를 디코딩 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/AudioContext/decodeAudioData&quot;&gt; &lt;code&gt;AudioContext.decodeAudioData&lt;/code&gt; 를&lt;/a&gt; 오디오 버퍼 소스의 버퍼 (같이 디코딩 된 데이터 설정 &lt;code&gt;source.buffer&lt;/code&gt; 를 ) 다음에 소스를 접속을 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/AudioContext/destination&quot;&gt; &lt;code&gt;AudioContext.destination&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="b965fdcf008cc2931c67bac89c837499156f40cd" translate="yes" xml:space="preserve">
          <source>In Chrome 45, the ability to have multiple shadow roots was deprecated.</source>
          <target state="translated">Chrome 45에서는 여러 섀도우 루트 기능이 더 이상 사용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="6c49e3d00054aaf36ffaf34073be62eb34bdcd90" translate="yes" xml:space="preserve">
          <source>In Chrome 62 and newer you cannot request notification api at all unless the site is https:// secured. (see issue &lt;a href=&quot;https://bugs.chromium.org/p/chromium/issues/detail?id=779612&quot;&gt;779612&lt;/a&gt;) If you do have https on the site you should be able to use notifications &lt;em&gt;and&lt;/em&gt; background push notifications.</source>
          <target state="translated">Chrome 62 이상에서는 사이트가 https : // 보안 상태가 아니면 알림 API를 전혀 요청할 수 없습니다. (문제 &lt;a href=&quot;https://bugs.chromium.org/p/chromium/issues/detail?id=779612&quot;&gt;779612&lt;/a&gt; 참조 ) 사이트에 https가있는 경우 알림 &lt;em&gt;및&lt;/em&gt; 백그라운드 푸시 알림 을 사용할 수 있어야합니다 .</target>
        </trans-unit>
        <trans-unit id="78c7b5b9c332ed1dc7e54d6b81e81ef5f66ccc46" translate="yes" xml:space="preserve">
          <source>In Chrome and Firefox, the 5th successive callback call is clamped; Safari clamps on the 6th call; in Edge its the 3rd one. Gecko started to treat &lt;code&gt;setInterval()&lt;/code&gt; like this in &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Mozilla/Firefox/Releases/56&quot;&gt;version 56&lt;/a&gt; (it already did this with &lt;code&gt;setTimeout()&lt;/code&gt;; see below).</source>
          <target state="translated">Chrome과 Firefox에서는 5 번째 연속 콜백 콜이 고정됩니다. 6 번째 통화에서 Safari가 고정됩니다. Edge에서 세 번째 것입니다. Gecko는 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Mozilla/Firefox/Releases/56&quot;&gt;버전 56&lt;/a&gt; 에서 이와 같이 &lt;code&gt;setInterval()&lt;/code&gt; 을 처리하기 시작 했습니다 (이미 &lt;code&gt;setTimeout()&lt;/code&gt; . 아래 참조).</target>
        </trans-unit>
        <trans-unit id="b285fb88d1d23e5c89ca38b0041fe0c0a19638a4" translate="yes" xml:space="preserve">
          <source>In Chrome and Safari, if the browser is not able to connect to a local area network (LAN) or a router, it is offline; all other conditions return &lt;code&gt;true&lt;/code&gt;. So while you can assume that the browser is offline when it returns a &lt;code&gt;false&lt;/code&gt; value, you cannot assume that a true value necessarily means that the browser can access the internet. You could be getting false positives, such as in cases where the computer is running a virtualization software that has virtual ethernet adapters that are always &quot;connected.&quot; Therefore, if you really want to determine the online status of the browser, you should develop additional means for checking. To learn more, see the HTML5 Rocks article, &lt;a href=&quot;http://www.html5rocks.com/en/mobile/workingoffthegrid.html&quot;&gt; Working Off the Grid&lt;/a&gt;.</source>
          <target state="translated">Chrome 및 Safari에서 브라우저가 LAN (Local Area Network) 또는 라우터에 연결할 수없는 경우 오프라인 상태입니다. 다른 모든 조건은 &lt;code&gt;true&lt;/code&gt; 를 반환 합니다 . 따라서 &lt;code&gt;false&lt;/code&gt; 값을 반환 할 때 브라우저가 오프라인 상태 라고 가정 할 수 있지만 실제 값이 반드시 브라우저가 인터넷에 액세스 할 수 있음을 의미한다고 가정 할 수는 없습니다. 컴퓨터가 항상 &quot;연결된&quot;가상 이더넷 어댑터가있는 가상화 소프트웨어를 실행하는 경우와 같이 오 탐지가 발생할 수 있습니다. 따라서 브라우저의 온라인 상태를 실제로 확인하려면 추가 검사 방법을 개발해야합니다. 자세한 내용은 HTML5 Rocks 기사 &lt;a href=&quot;http://www.html5rocks.com/en/mobile/workingoffthegrid.html&quot;&gt;그리드 작업을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="50f66ac87a18277292c16c81f87a3f7c412cce8a" translate="yes" xml:space="preserve">
          <source>In Chrome for Android, the method may instead open the URL in an existing browsing context provided by a &lt;a href=&quot;https://developer.mozilla.org/en-US/Apps/Progressive/Installable&quot;&gt;standalone web app&lt;/a&gt; previously added to the user's home screen.</source>
          <target state="translated">Android 용 Chrome에서이 메소드는 이전에 사용자의 홈 화면에 추가 된 &lt;a href=&quot;https://developer.mozilla.org/en-US/Apps/Progressive/Installable&quot;&gt;독립형 웹 앱&lt;/a&gt; 에서 제공 한 기존 브라우징 컨텍스트에서 URL을 열 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="54aee71f72439d923d73a00ea3b2c1b185da0b55" translate="yes" xml:space="preserve">
          <source>In Chrome, &lt;code&gt;navigator.language&lt;/code&gt; is the language of the browser UI, and is not guaranteed to be equal to &lt;code&gt;navigator.languages[0]&lt;/code&gt;.</source>
          <target state="translated">Chrome에서 &lt;code&gt;navigator.language&lt;/code&gt; 는 브라우저 UI의 언어이며 &lt;code&gt;navigator.languages[0]&lt;/code&gt; 과 같을 수는 없습니다 .</target>
        </trans-unit>
        <trans-unit id="f067dc68dd1126ff144d4d0c9acd59e4a28c54da" translate="yes" xml:space="preserve">
          <source>In Chrome/Opera, the Quota Management API handles quota management for &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Using_the_application_cache&quot;&gt;AppCache&lt;/a&gt;, &lt;a href=&quot;../indexeddb_api&quot;&gt;IndexedDB&lt;/a&gt;, WebSQL, and &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/File_and_Directory_Entries_API&quot;&gt;File System API&lt;/a&gt;.</source>
          <target state="translated">크롬 / 오페라에 대한 할당량 관리 API 핸들 할당량 관리에 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Using_the_application_cache&quot;&gt;있는 AppCache&lt;/a&gt; , &lt;a href=&quot;../indexeddb_api&quot;&gt;색인화&lt;/a&gt; , WebSQL 및 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/File_and_Directory_Entries_API&quot;&gt;파일 시스템 API&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="ed4fbf0f99d809accdff4e6fe3d188b040258944" translate="yes" xml:space="preserve">
          <source>In DOM4 this API was moved from &lt;code&gt;Node&lt;/code&gt; to the &lt;a href=&quot;../element&quot;&gt;&lt;code&gt;Element&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../attr&quot;&gt;&lt;code&gt;Attr&lt;/code&gt;&lt;/a&gt; interfaces.</source>
          <target state="translated">DOM4에서이 API는 &lt;code&gt;Node&lt;/code&gt; 에서 &lt;a href=&quot;../element&quot;&gt; &lt;code&gt;Element&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;../attr&quot;&gt; &lt;code&gt;Attr&lt;/code&gt; &lt;/a&gt; 인터페이스 로 이동되었습니다 .</target>
        </trans-unit>
        <trans-unit id="95a2bb9868cd89f678d0493fad1f8fb986cade2e" translate="yes" xml:space="preserve">
          <source>In Development</source>
          <target state="translated">개발 중</target>
        </trans-unit>
        <trans-unit id="337f02d9ef6a6531518b1f9943fb153f229afe90" translate="yes" xml:space="preserve">
          <source>In Firefox 2 through 5, the passed object is serialized using JSON. Starting in Firefox 6, the object is serialized using &lt;a href=&quot;https://developer.mozilla.org/docs/DOM/The_structured_clone_algorithm&quot;&gt;the structured clone algorithm&lt;/a&gt;. This allows a wider variety of objects to be safely passed.</source>
          <target state="translated">Firefox 2-5에서는 전달 된 객체가 JSON을 사용하여 직렬화됩니다. Firefox 6부터는 &lt;a href=&quot;https://developer.mozilla.org/docs/DOM/The_structured_clone_algorithm&quot;&gt;구조화 된 클론 알고리즘을&lt;/a&gt; 사용하여 객체가 직렬화됩니다 . 이를 통해보다 다양한 객체를 안전하게 전달할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="dec52eda400278c480cefdfaffae5c0a720902ae" translate="yes" xml:space="preserve">
          <source>In Firefox 28, a default value of &lt;code&gt;false&lt;/code&gt; was added for &lt;code&gt;isRemote&lt;/code&gt;, to match a specification update.</source>
          <target state="translated">Firefox 28에서는 사양 업데이트와 일치하도록 &lt;code&gt;isRemote&lt;/code&gt; 의 기본값 인 &lt;code&gt;false&lt;/code&gt; 가 추가되었습니다 .</target>
        </trans-unit>
        <trans-unit id="71824cc95a897064f08cc63ac731a61a7d1b839f" translate="yes" xml:space="preserve">
          <source>In Firefox 29 and later, enumeration of the &lt;code&gt;navigator.plugins&lt;/code&gt; array may be restricted as a privacy measure. Applications that must check for the presence of a browser plugin should query &lt;code&gt;navigator.plugins&lt;/code&gt; or &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/navigator/mimeTypes&quot;&gt;&lt;code&gt;navigator.mimeTypes&lt;/code&gt;&lt;/a&gt; by exact name instead of enumerating the &lt;code&gt;navigator.plugins&lt;/code&gt; array and comparing every plugin's name. This privacy change does not disable any plugins; it just hides some plugin names from enumeration.</source>
          <target state="translated">Firefox 29 이상에서는 &lt;code&gt;navigator.plugins&lt;/code&gt; 배열의 열거가 개인 정보 보호 조치로 제한 될 수 있습니다. 브라우저 플러그인이 있는지 확인해야하는 애플리케이션 은 &lt;code&gt;navigator.plugins&lt;/code&gt; 배열 을 열거하고 모든 플러그인 이름을 비교 하는 대신 정확한 이름으로 &lt;code&gt;navigator.plugins&lt;/code&gt; 또는 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/navigator/mimeTypes&quot;&gt; &lt;code&gt;navigator.mimeTypes&lt;/code&gt; &lt;/a&gt; 를 쿼리해야합니다 . 이 개인 정보 보호 변경은 플러그인을 비활성화하지 않습니다. 단지 일부 플러그인 이름을 열거에서 숨 깁니다.</target>
        </trans-unit>
        <trans-unit id="c8d665de10575353f7b8c25c205e77d09dfd85a0" translate="yes" xml:space="preserve">
          <source>In Firefox 3, &lt;code&gt;dom.disable_window_open_feature.location&lt;/code&gt; now defaults to &lt;var&gt;true&lt;/var&gt;, forcing the presence of the Location Bar much like in IE7. See bug 337344 for more information.</source>
          <target state="translated">Firefox 3에서 &lt;code&gt;dom.disable_window_open_feature.location&lt;/code&gt; 의 기본값은 &lt;var&gt;true&lt;/var&gt; 로 설정되어 IE7에서와 같이 위치 표시 줄이 존재합니다. 자세한 내용은 버그 337344를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="06a997ba142dafe53ad096fa258086906b04dec7" translate="yes" xml:space="preserve">
          <source>In Firefox 3.5 and earlier, the namespace URI for HTML attributes in HTML documents is &lt;code&gt;null&lt;/code&gt;. In later versions, in compliance with HTML5, it is &lt;code&gt;&lt;a href=&quot;https://www.w3.org/1999/xhtml&quot;&gt;https://www.w3.org/1999/xhtml&lt;/a&gt;&lt;/code&gt; as in XHTML.</source>
          <target state="translated">Firefox 3.5 및 이전 버전에서 HTML 문서의 HTML 속성에 대한 네임 스페이스 URI는 &lt;code&gt;null&lt;/code&gt; 입니다. 이후 버전에서는 HTML5에 따라 XHTML에서와 같이 &lt;code&gt;&lt;a href=&quot;https://www.w3.org/1999/xhtml&quot;&gt;https://www.w3.org/1999/xhtml&lt;/a&gt;&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="e92861e335fdcf505b87df9fdca2bb30fa01f922" translate="yes" xml:space="preserve">
          <source>In Firefox 3.5 and earlier, the namespace URI for HTML elements in HTML documents is &lt;code&gt;null&lt;/code&gt;. In later versions, in compliance with HTML5, it is &lt;code&gt;&lt;a href=&quot;http://www.w3.org/1999/xhtml&quot;&gt;http://www.w3.org/1999/xhtml&lt;/a&gt;&lt;/code&gt; as in XHTML.</source>
          <target state="translated">Firefox 3.5 이하에서 HTML 문서의 HTML 요소에 대한 네임 스페이스 URI는 &lt;code&gt;null&lt;/code&gt; 입니다. 이후 버전에서는 HTML5에 따라 XHTML에서와 같이 &lt;code&gt;&lt;a href=&quot;http://www.w3.org/1999/xhtml&quot;&gt;http://www.w3.org/1999/xhtml&lt;/a&gt;&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="3080a7d69ecb124d6ce6db8bd6f6b51a7935923b" translate="yes" xml:space="preserve">
          <source>In Firefox 3.5 and earlier, the namespace URI for HTML elements in HTML documents is &lt;code&gt;null&lt;/code&gt;. In later versions, in compliance with HTML5, it is &lt;code&gt;&lt;a href=&quot;https://www.w3.org/1999/xhtml&quot;&gt;https://www.w3.org/1999/xhtml&lt;/a&gt;&lt;/code&gt; as in XHTML.</source>
          <target state="translated">Firefox 3.5 및 이전 버전에서 HTML 문서의 HTML 요소에 대한 네임 스페이스 URI는 &lt;code&gt;null&lt;/code&gt; 입니다. 이후 버전에서는 HTML5에 따라 XHTML에서와 같이 &lt;code&gt;&lt;a href=&quot;https://www.w3.org/1999/xhtml&quot;&gt;https://www.w3.org/1999/xhtml&lt;/a&gt;&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="1b5ac43d4133318554d5c99a568d5233c7cc3fd3" translate="yes" xml:space="preserve">
          <source>In Firefox 55 and later, the standard &lt;code&gt;MessageEvent&lt;/code&gt; interface must be used instead.</source>
          <target state="translated">Firefox 55 이상에서는 표준 &lt;code&gt;MessageEvent&lt;/code&gt; 인터페이스를 대신 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="41c966bbb768e112ed78c63d897a665d7e5dd2e6" translate="yes" xml:space="preserve">
          <source>In Firefox 56, the implementation has been updated so that the &lt;code&gt;formAction&lt;/code&gt; property returns the correct form submission URL, as per spec, when the associated button is being used to submit a form (&lt;a href=&quot;https://bugzil.la/1366361&quot;&gt;bug 1366361&lt;/a&gt;).</source>
          <target state="translated">Firefox 56에서는 관련 버튼을 사용하여 양식을 제출할 때 &lt;code&gt;formAction&lt;/code&gt; 속성이 사양에 따라 올바른 양식 제출 URL을 반환 하도록 구현이 업데이트되었습니다 ( &lt;a href=&quot;https://bugzil.la/1366361&quot;&gt;버그 1366361&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="dc1de833d68e13a376ac48787853f562a98b6e7e" translate="yes" xml:space="preserve">
          <source>In Firefox 57.0.4 the accuracy was reduced to 20 microseconds.</source>
          <target state="translated">Firefox 57.0.4에서는 정확도가 20 마이크로 초로 줄었습니다.</target>
        </trans-unit>
        <trans-unit id="4c356bae3dabc646b737a05ce27657f53acb4ee2" translate="yes" xml:space="preserve">
          <source>In Firefox 59 the accuracy was reduced to 2 milliseconds.</source>
          <target state="translated">Firefox 59에서는 정확도가 2 밀리 초로 줄었습니다.</target>
        </trans-unit>
        <trans-unit id="2d8e620e934ee8758c4c20b22973ebf3f61e4109" translate="yes" xml:space="preserve">
          <source>In Firefox 60 onwards, Mozilla resolves the relative URL against the global that owns the &lt;code&gt;fetch()&lt;/code&gt; function being used (see &lt;a href=&quot;https://bugzilla.mozilla.org/show_bug.cgi?id=1432272&quot;&gt;bug 1432272&lt;/a&gt;). So in the case described above, it is resolved against the iframe's location:</source>
          <target state="translated">Firefox 60 이상에서 Mozilla 는 사용중인 &lt;code&gt;fetch()&lt;/code&gt; 함수 를 소유 한 전역에 대한 상대 URL을 확인합니다 ( &lt;a href=&quot;https://bugzilla.mozilla.org/show_bug.cgi?id=1432272&quot;&gt;버그 1432272&lt;/a&gt; 참조 ). 따라서 위에서 설명한 경우 iframe의 위치와 비교하여 해결됩니다.</target>
        </trans-unit>
        <trans-unit id="91a8e43d431661433d21232663f89aa9969d6533" translate="yes" xml:space="preserve">
          <source>In Firefox and Internet Explorer, switching the browser to offline mode sends a &lt;code&gt;false&lt;/code&gt; value. Until Firefox 41, all other conditions return a &lt;code&gt;true&lt;/code&gt; value; since Firefox 41, on OS X and Windows, the value will follow the actual network connectivity.</source>
          <target state="translated">Firefox 및 Internet Explorer에서 브라우저를 오프라인 모드로 전환하면 &lt;code&gt;false&lt;/code&gt; 값이 전송 됩니다. Firefox 41까지는 다른 모든 조건이 &lt;code&gt;true&lt;/code&gt; 값을 반환 합니다. Firefox 41부터 OS X 및 Windows에서이 값은 실제 네트워크 연결을 따릅니다.</target>
        </trans-unit>
        <trans-unit id="a5c1940f3611c4b86f163e78b87bc7c85ba4d690" translate="yes" xml:space="preserve">
          <source>In Firefox versions prior to 21, when an element's content does not generate a vertical scrollbar, then its &lt;code&gt;scrollHeight&lt;/code&gt; property is equal to its &lt;code&gt;clientHeight&lt;/code&gt; property. This can mean either the content is too short to require a scrollbar or that the element has a CSS style &lt;code&gt;overflow&lt;/code&gt; value of &lt;code&gt;visible&lt;/code&gt; (non-scrollable).</source>
          <target state="translated">21 이전의 Firefox 버전에서 요소의 내용이 세로 스크롤 막대를 생성하지 않으면 &lt;code&gt;scrollHeight&lt;/code&gt; 속성은 &lt;code&gt;clientHeight&lt;/code&gt; 속성 과 같습니다 . 이는 내용이 너무 짧아서 스크롤 막대를 요구하지 않거나 요소에 CSS 스타일 &lt;code&gt;overflow&lt;/code&gt; 값이 &lt;code&gt;visible&lt;/code&gt; (스크롤 불가) 임을 의미 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="3bd08ef4cf82279418d308a11cc78804ac191030" translate="yes" xml:space="preserve">
          <source>In Firefox, IndexedDB used to be &lt;strong&gt;durable&lt;/strong&gt;, meaning that in a readwrite transaction &lt;a href=&quot;../idbtransaction/oncomplete&quot;&gt;&lt;code&gt;IDBTransaction.oncomplete&lt;/code&gt;&lt;/a&gt; was fired only when all data was guaranteed to have been flushed to disk.</source>
          <target state="translated">Firefox에서 IndexedDB는 &lt;strong&gt;내구성이 뛰어&lt;/strong&gt; 났습니다. 즉, 읽기 / 쓰기 트랜잭션에서 &lt;a href=&quot;../idbtransaction/oncomplete&quot;&gt; &lt;code&gt;IDBTransaction.oncomplete&lt;/code&gt; &lt;/a&gt; 는 모든 데이터가 디스크로 플러시 된 경우에만 실행됩니다.</target>
        </trans-unit>
        <trans-unit id="699566e86bfea718b81173da445b60d3b6f12670" translate="yes" xml:space="preserve">
          <source>In Firefox, Service Worker APIs are hidden and cannot be used when the user is in &lt;a href=&quot;https://support.mozilla.org/en-US/kb/private-browsing-use-firefox-without-history&quot;&gt;private browsing mode&lt;/a&gt;.</source>
          <target state="translated">Firefox에서는 Service Worker API가 숨겨져 있으며 사용자가 &lt;a href=&quot;https://support.mozilla.org/en-US/kb/private-browsing-use-firefox-without-history&quot;&gt;개인 탐색 모드&lt;/a&gt; 에있을 때는 사용할 수 없습니다 .</target>
        </trans-unit>
        <trans-unit id="d3d8290f7debd4e56e886c8df3121b2adbf65a69" translate="yes" xml:space="preserve">
          <source>In Firefox, for example, the URL bar displays a pulsing red icon to indicate that recording is underway. The icon is gray if the permission is in place but recording is not currently underway. The device's physical light is used to indicate whether or not recording is currently active. If you've muted your camera (so-called &quot;facemuting&quot;), your camera's activity light goes out to indicate that the camera is not actively recording you, without discarding the permission to resume using the camera once muting is over.</source>
          <target state="translated">예를 들어 Firefox에서는 URL 표시 줄에 깜박이는 빨간색 아이콘이 표시되어 녹음 중임을 나타냅니다. 권한이 있지만 녹화가 진행 중이 아닌 경우 아이콘이 회색입니다. 장치의 물리적 표시등은 녹음이 현재 활성화되어 있는지 여부를 나타내는 데 사용됩니다. 카메라를 음소거 한 경우 (소위 &quot;얼굴 음소거&quot;) 카메라의 활동 표시등이 꺼지면서 음소거가 끝나면 카메라 사용을 재개 할 수있는 권한을 버리지 않고 카메라가 현재 사용자를 녹화하고 있지 않음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="1c82245bd95dcfac73cafd3ba3210594bc92f469" translate="yes" xml:space="preserve">
          <source>In Firefox, if you want to use workers in extensions and would like to have access to &lt;a href=&quot;https://developer.mozilla.org/en/js-ctypes&quot;&gt;js-ctypes&lt;/a&gt;, you should use the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/ChromeWorker&quot;&gt;&lt;code&gt;ChromeWorker&lt;/code&gt;&lt;/a&gt; object instead.</source>
          <target state="translated">Firefox에서 확장 프로그램에서 워커를 사용하고 &lt;a href=&quot;https://developer.mozilla.org/en/js-ctypes&quot;&gt;js-ctypes에&lt;/a&gt; 액세스 하려면 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/ChromeWorker&quot;&gt; &lt;code&gt;ChromeWorker&lt;/code&gt; &lt;/a&gt; 객체를 대신 사용해야합니다 .</target>
        </trans-unit>
        <trans-unit id="3e8914159442e80df8099ca51c082acb365bd61b" translate="yes" xml:space="preserve">
          <source>In Firefox, properties with the value &lt;code&gt;auto&lt;/code&gt; return the used value, not the value &lt;code&gt;auto&lt;/code&gt;. So if you apply &lt;code&gt;top:auto;&lt;/code&gt; and &lt;code&gt;bottom:0&lt;/code&gt;; on an element with &lt;code&gt;height:30px&lt;/code&gt; and its containing block is &lt;code&gt;height:100px;&lt;/code&gt;, upon requesting the computed style for &lt;code&gt;top&lt;/code&gt;, Firefox will return &lt;code&gt;top:70px&lt;/code&gt;, as &lt;code&gt;100px-30px=70px&lt;/code&gt;.</source>
          <target state="translated">Firefox에서, 값과 속성을 &lt;code&gt;auto&lt;/code&gt; 사용 된 값이 아닌 값을 반환 &lt;code&gt;auto&lt;/code&gt; . 따라서 &lt;code&gt;top:auto;&lt;/code&gt; 를 적용하면 ; 및 &lt;code&gt;bottom:0&lt;/code&gt; ; &lt;code&gt;height:30px&lt;/code&gt; 이고 요소를 포함하는 요소의 &lt;code&gt;height:100px;&lt;/code&gt; , &lt;code&gt;top&lt;/code&gt; 에 대한 계산 스타일을 요청하면 Firefox는 &lt;code&gt;100px-30px=70px&lt;/code&gt; 로 &lt;code&gt;top:70px&lt;/code&gt; 를 반환 합니다.</target>
        </trans-unit>
        <trans-unit id="a9e17f5c2b6e442fb2a20335f450280528d3db72" translate="yes" xml:space="preserve">
          <source>In Firefox, the &lt;a href=&quot;../rtcdatachannel&quot;&gt;&lt;code&gt;RTCDataChannel&lt;/code&gt;&lt;/a&gt; interface was implemented under the name &lt;code&gt;DataChannel&lt;/code&gt; until Firefox 24, so this method was called &lt;code&gt;DataChannel.close()&lt;/code&gt;.</source>
          <target state="translated">Firefox에서 &lt;a href=&quot;../rtcdatachannel&quot;&gt; &lt;code&gt;RTCDataChannel&lt;/code&gt; &lt;/a&gt; 인터페이스는 Firefox 24까지 &lt;code&gt;DataChannel&lt;/code&gt; 이라는 이름으로 구현 되었으므로이 메소드를 &lt;code&gt;DataChannel.close()&lt;/code&gt; 라고 합니다.</target>
        </trans-unit>
        <trans-unit id="4638eb6c3edc893c5f7e60a5d659564a141e1e6f" translate="yes" xml:space="preserve">
          <source>In Firefox, the &lt;code&gt;errorCallback&lt;/code&gt;'s input parameter is a &lt;code&gt;&lt;a href=&quot;https://developer.mozilla.org/docs/Web/API/DOMException&quot;&gt;DOMException&lt;/a&gt;&lt;/code&gt; rather than a &lt;code&gt;&lt;a href=&quot;https://developer.mozilla.org/docs/Web/API/FileError&quot;&gt;FileError&lt;/a&gt;&lt;/code&gt; object.</source>
          <target state="translated">Firefox에서 &lt;code&gt;errorCallback&lt;/code&gt; 의 입력 매개 변수는 &lt;code&gt;&lt;a href=&quot;https://developer.mozilla.org/docs/Web/API/FileError&quot;&gt;FileError&lt;/a&gt;&lt;/code&gt; 객체가 아니라 &lt;code&gt;&lt;a href=&quot;https://developer.mozilla.org/docs/Web/API/DOMException&quot;&gt;DOMException&lt;/a&gt;&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="2bc179879e4aed7054b76d3595ac19ab9fe7da77" translate="yes" xml:space="preserve">
          <source>In Firefox, the &lt;code&gt;navigator.languages&lt;/code&gt; property's value is taken from the &lt;code&gt;intl.accept_languages&lt;/code&gt; preference.</source>
          <target state="translated">Firefox에서 &lt;code&gt;navigator.languages&lt;/code&gt; 특성 값은 &lt;code&gt;intl.accept_languages&lt;/code&gt; 환경 설정 에서 가져옵니다 .</target>
        </trans-unit>
        <trans-unit id="422c70e74377e61230d6ff77f5b81b2a0af614e5" translate="yes" xml:space="preserve">
          <source>In Firefox, the &lt;code&gt;privacy.reduceTimerPrecision&lt;/code&gt; preference is enabled by default and defaults to 1ms.</source>
          <target state="translated">Firefox에서는 &lt;code&gt;privacy.reduceTimerPrecision&lt;/code&gt; 환경 설정이 기본적으로 사용되며 기본값은 1ms입니다.</target>
        </trans-unit>
        <trans-unit id="0af97ad69484c392ea6d2c53e11669126d6b3def" translate="yes" xml:space="preserve">
          <source>In Firefox, the &lt;code&gt;privacy.reduceTimerPrecision&lt;/code&gt; preference is enabled by default and defaults to 20us in Firefox 59; in 60 it will be 2ms.</source>
          <target state="translated">Firefox에서는 &lt;code&gt;privacy.reduceTimerPrecision&lt;/code&gt; 환경 설정이 기본적으로 사용되며 Firefox 59에서 기본값은 20us입니다. 60에서는 2ms입니다.</target>
        </trans-unit>
        <trans-unit id="a5019bc9c007e827a1c609f4fe3c72561adc0a10" translate="yes" xml:space="preserve">
          <source>In Firefox, the following technologies make use of browser data storage to store data when required. We term them &quot;quota clients&quot; in this context:</source>
          <target state="translated">Firefox에서 다음 기술은 브라우저 데이터 스토리지를 사용하여 필요할 때 데이터를 저장합니다. 우리는 이러한 맥락에서 &quot;견적 고객&quot;이라고합니다.</target>
        </trans-unit>
        <trans-unit id="d953e2599e083f8092a3c98359d666f4ee108786" translate="yes" xml:space="preserve">
          <source>In Firefox, the method is allowed to show popups only when called as the result of a notification click event.</source>
          <target state="translated">Firefox에서이 메소드는 알림 클릭 이벤트의 결과로 호출 될 때만 팝업을 표시 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="74f1a9d5d1c45766df33629813e914f98fb77bc9" translate="yes" xml:space="preserve">
          <source>In Firefox, the storage access grants are phased out after a number of days passing, whereas in Safari the storage access grants are phased out after a number of days of browser usage passed. This is currently a limitation of the Firefox implementation, which we may address in a future version.</source>
          <target state="translated">Firefox에서는 스토리지 액세스 권한 부여가 며칠이 지나면 단계적으로 중단되는 반면 Safari에서는 스토리지 액세스 권한 부여가 며칠 동안 브라우저 사용이 끝난 후에 단계적으로 종료됩니다. 이는 현재 Firefox 구현의 제한 사항이며 향후 버전에서 해결 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a2bf8d36e8b6b00e69eb29bddf9ff8c8692d9d2e" translate="yes" xml:space="preserve">
          <source>In Firefox, to have the PDF appear embedded in the iframe (rather than proposed as a downloaded file), the preference &lt;code&gt;pdfjs.disabled&lt;/code&gt; must be set to &lt;code&gt;false&lt;/code&gt; .</source>
          <target state="translated">Firefox에서 PDF를 다운로드 한 파일로 제안하지 않고 iframe에 포함 &lt;code&gt;pdfjs.disabled&lt;/code&gt; 려면 pdfjs.disabled 환경 설정을 &lt;code&gt;false&lt;/code&gt; 로 설정해야합니다 .</target>
        </trans-unit>
        <trans-unit id="a05fdf6b8b8b3dd7538d9f70f3454fb69d9c4491" translate="yes" xml:space="preserve">
          <source>In Firefox, touch events are disabled when e10s (electrolysis; &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Mozilla/Firefox/Multiprocess_Firefox&quot;&gt;multiprocess Firefox&lt;/a&gt;) is disabled. e10s is on by default in Firefox, but can end up becoming disabled in certain situations, for example when certain accessibility tools or Firefox add-ons are installed that require e10s to be disabled to work. This means that even on a touchscreen-enabled desktop/laptop, touch events won't be enabled.</source>
          <target state="translated">Firefox에서는 e10s (전기 분해, &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Mozilla/Firefox/Multiprocess_Firefox&quot;&gt;다중 프로세스 Firefox&lt;/a&gt; )가 비활성화 되면 터치 이벤트가 비활성화됩니다 . e10s는 Firefox에서 기본적으로 설정되어 있지만 특정 상황 (예 : e10이 작동하지 않도록 설정해야하는 특정 접근성 도구 또는 Firefox 애드온이 설치된 경우)에서 비활성화 될 수 있습니다. 즉, 터치 스크린 지원 데스크탑 / 노트북에서도 터치 이벤트가 활성화되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="4d17a507e570927a04193dbc4eb28d7daed5ea77" translate="yes" xml:space="preserve">
          <source>In Firefox, when persistent storage is used, the user is given a UI popup to alert them that this data will persist, and asks if they are happy with that. Temporary data storage does not elicit any user prompts.</source>
          <target state="translated">Firefox에서 영구 저장소를 사용하는 경우 사용자에게이 데이터가 지속될 것임을 알리는 UI 팝업이 표시되고 그 데이터에 만족하는지 묻습니다. 임시 데이터 스토리지는 사용자 프롬프트를 표시하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="226c00242c83a17c60505135221e72d92ae3a07a" translate="yes" xml:space="preserve">
          <source>In Firefox, when the promise returned from &lt;code&gt;requestStorageAccess()&lt;/code&gt; is resolved, the embedded page will gain access to its entire first-party storage, not just cookies. This includes access to APIs such as &lt;a href=&quot;web_storage_api&quot;&gt;Web Storage&lt;/a&gt;, &lt;a href=&quot;indexeddb_api&quot;&gt;IndexedDB&lt;/a&gt;, &lt;a href=&quot;cache&quot;&gt;DOM Cache&lt;/a&gt;, and so on.</source>
          <target state="translated">Firefox에서 &lt;code&gt;requestStorageAccess()&lt;/code&gt; 에서 반환 된 약속 이 해결되면 포함 된 페이지는 쿠키뿐만 아니라 자사의 전체 자사 저장소에 액세스 할 수 있습니다. 여기에는 &lt;a href=&quot;web_storage_api&quot;&gt;Web Storage&lt;/a&gt; , &lt;a href=&quot;indexeddb_api&quot;&gt;IndexedDB&lt;/a&gt; , &lt;a href=&quot;cache&quot;&gt;DOM Cache&lt;/a&gt; 등과 같은 API에 대한 액세스가 포함 됩니다.</target>
        </trans-unit>
        <trans-unit id="21f59e93c02ff648ca9cbab0045be7035480a65f" translate="yes" xml:space="preserve">
          <source>In Firefox, windows in background tabs each have their own time budget in milliseconds &amp;mdash; a max and a min value of +50 ms and -150 ms, respectively. Chrome is very similar except that the budget is specified in seconds.</source>
          <target state="translated">Firefox에서 백그라운드 탭의 창은 각각 고유 한 시간 예산 (밀리 초)을 갖습니다. 각각 최대 및 최소값은 + 50ms 및 -150ms입니다. Chrome은 예산이 초 단위로 지정된 것을 제외하고는 매우 유사합니다.</target>
        </trans-unit>
        <trans-unit id="814b66f8a38d60175752d4fa0ee4d1b4e2f7719f" translate="yes" xml:space="preserve">
          <source>In Firefox, you can also enable &lt;code&gt;privacy.resistFingerprinting&lt;/code&gt; &amp;mdash; this changes the precision to 100ms or the value of &lt;code&gt;privacy.resistFingerprinting.reduceTimerPrecision.microseconds&lt;/code&gt;, whichever is larger.</source>
          <target state="translated">Firefox에서는 &lt;code&gt;privacy.resistFingerprinting&lt;/code&gt; 을 활성화 할 수도 있습니다. 이렇게하면 정밀도가 100ms로 변경되거나 &lt;code&gt;privacy.resistFingerprinting.reduceTimerPrecision.microseconds&lt;/code&gt; 중 더 큰 값으로 변경 됩니다.</target>
        </trans-unit>
        <trans-unit id="88be9b8c2e6a3862daa95b3e9e9a80626dc191ea" translate="yes" xml:space="preserve">
          <source>In Firefox, you can also enable &lt;code&gt;privacy.resistFingerprinting&lt;/code&gt;; the precision will be 100ms or the value of &lt;code&gt;privacy.resistFingerprinting.reduceTimerPrecision.microseconds&lt;/code&gt;, whichever is larger.</source>
          <target state="translated">Firefox에서는 &lt;code&gt;privacy.resistFingerprinting&lt;/code&gt; ; 정밀도는 100ms 또는 &lt;code&gt;privacy.resistFingerprinting.reduceTimerPrecision.microseconds&lt;/code&gt; 중 더 큰 값입니다 .</target>
        </trans-unit>
        <trans-unit id="9c7ba06ca4f441cd2e83c2b7bd2b5b0d766466d1" translate="yes" xml:space="preserve">
          <source>In Firefox, you can also enabled &lt;code&gt;privacy.resistFingerprinting&lt;/code&gt;, the precision will be 100ms or the value of &lt;code&gt;privacy.resistFingerprinting.reduceTimerPrecision.microseconds&lt;/code&gt;, whichever is larger.</source>
          <target state="translated">Firefox에서는 &lt;code&gt;privacy.resistFingerprinting&lt;/code&gt; 을 활성화 할 수 있으며 정밀도는 100ms 또는 &lt;code&gt;privacy.resistFingerprinting.reduceTimerPrecision.microseconds&lt;/code&gt; 중 더 큰 값입니다 .</target>
        </trans-unit>
        <trans-unit id="e93f1f29a1a271317104252ea61346016bb795cb" translate="yes" xml:space="preserve">
          <source>In Firefox, you can change the preference &lt;code&gt;general.useragent.override&lt;/code&gt; in &lt;code&gt;about:config&lt;/code&gt;. Some Firefox extensions do that; however, this only changes the HTTP header that gets sent, and doesn't affect browser detection performed by JavaScript code.</source>
          <target state="translated">Firefox에서는 &lt;code&gt;about:config&lt;/code&gt; 에서 환경 설정 &lt;code&gt;general.useragent.override&lt;/code&gt; 를 변경할 수 있습니다 . 일부 Firefox 확장 프로그램은 그렇게합니다. 그러나 이는 전송되는 HTTP 헤더 만 변경하며 JavaScript 코드로 수행되는 브라우저 감지에는 영향을 미치지 않습니다.</target>
        </trans-unit>
        <trans-unit id="7070c56ceec36fc5064c9ae27adec33e00061e4d" translate="yes" xml:space="preserve">
          <source>In Gecko (the rendering engine of Firefox, Firefox OS and other Mozilla based applications), some &lt;a href=&quot;../../canvasrenderingcontext2d#Prefixed_APIs&quot;&gt;prefixed APIs&lt;/a&gt; were implemented in earlier versions to draw text on a canvas. These are now deprecated and removed, and are no longer guaranteed to work.</source>
          <target state="translated">Gecko (Firefox, Firefox OS 및 기타 Mozilla 기반 애플리케이션의 렌더링 엔진)에서 일부 &lt;a href=&quot;../../canvasrenderingcontext2d#Prefixed_APIs&quot;&gt;접두사 API&lt;/a&gt; 는 이전 버전에서 구현되어 캔버스에 텍스트를 그렸습니다. 이제 더 이상 사용되지 않으며 제거되어 더 이상 작동하지 않을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="eabe05e3b1671b55f141dc64b65baf19240eca59" translate="yes" xml:space="preserve">
          <source>In Gecko, since &lt;a href=&quot;https://developer.mozilla.org/en-US/Firefox/Releases/26&quot;&gt;version 26&lt;/a&gt;, you can include a non-standard &lt;code&gt;options&lt;/code&gt; object as a parameter of &lt;a href=&quot;open&quot;&gt;&lt;code&gt;IDBFactory.open&lt;/code&gt;&lt;/a&gt; that contains the &lt;code&gt;version&lt;/code&gt; number of the database, plus a storage value that specifies whether you want to use &lt;code&gt;persistent&lt;/code&gt; or &lt;code&gt;temporary&lt;/code&gt; storage.</source>
          <target state="translated">Gecko에서는 &lt;a href=&quot;https://developer.mozilla.org/en-US/Firefox/Releases/26&quot;&gt;버전 26&lt;/a&gt; 이후에 비표준 &lt;code&gt;options&lt;/code&gt; 오브젝트를 데이터베이스 의 &lt;code&gt;version&lt;/code&gt; 번호 를 포함하는 &lt;a href=&quot;open&quot;&gt; &lt;code&gt;IDBFactory.open&lt;/code&gt; &lt;/a&gt; 의 매개 변수와 &lt;code&gt;persistent&lt;/code&gt; 또는 &lt;code&gt;temporary&lt;/code&gt; 스토리지 를 사용할지 여부를 지정하는 스토리지 값으로 포함 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="b3ac10976b8d679cc89930c3b91da392e3882a43" translate="yes" xml:space="preserve">
          <source>In Gecko, since &lt;a href=&quot;https://developer.mozilla.org/en-US/Firefox/Releases/26&quot;&gt;version 26&lt;/a&gt;, you can include a non-standard optional storage parameter that specifies whether you want to delete a &lt;code&gt;permanent&lt;/code&gt; (the default value) IndexedDB, or an indexedDB in &lt;code&gt;temporary&lt;/code&gt; storage (aka shared pool.)</source>
          <target state="translated">Gecko에서는 &lt;a href=&quot;https://developer.mozilla.org/en-US/Firefox/Releases/26&quot;&gt;버전 26&lt;/a&gt; 이래로 &lt;code&gt;permanent&lt;/code&gt; (기본값) IndexedDB 또는 &lt;code&gt;temporary&lt;/code&gt; 저장소 ( index) 를 삭제할지 여부를 지정하는 비표준 선택적 스토리지 매개 변수를 포함 할 수 있습니다 (일명 공유 풀).</target>
        </trans-unit>
        <trans-unit id="8baf31a352acff2b0105a6a3a42c4c1b4ee0661e" translate="yes" xml:space="preserve">
          <source>In Gecko, when you set a system font as the value of a canvas 2D context's &lt;a href=&quot;font&quot;&gt;&lt;code&gt;font&lt;/code&gt;&lt;/a&gt; (e.g. &lt;code&gt;menu&lt;/code&gt;), getting the font value fails to return the expected font (it returns nothing). This is fixed in Firefox's new parallel CSS engine (also known as &lt;a href=&quot;https://wiki.mozilla.org/Quantum&quot;&gt;Quantum CSS&lt;/a&gt; or &lt;a href=&quot;https://wiki.mozilla.org/Quantum/Stylo&quot;&gt;Stylo&lt;/a&gt;, planned for release in Firefox 57) (&lt;a href=&quot;https://bugzilla.mozilla.org/show_bug.cgi?id=1374885&quot;&gt;bug 1374885&lt;/a&gt;).</source>
          <target state="translated">Gecko에서 시스템 글꼴을 canvas 2D 컨텍스트의 &lt;a href=&quot;font&quot;&gt; &lt;code&gt;font&lt;/code&gt; &lt;/a&gt; (예 : &lt;code&gt;menu&lt;/code&gt; )으로 설정하면 글꼴 값을 가져 오는 것이 예상 글꼴을 반환하지 못합니다 (아무 것도 반환하지 않음). 이것은 Firefox의 새로운 병렬 CSS 엔진 ( Firefox 57에서 릴리스 예정인 &lt;a href=&quot;https://wiki.mozilla.org/Quantum&quot;&gt;Quantum CSS&lt;/a&gt; 또는 &lt;a href=&quot;https://wiki.mozilla.org/Quantum/Stylo&quot;&gt;Stylo&lt;/a&gt; 라고도 함 )에서 수정되었습니다 ( &lt;a href=&quot;https://bugzilla.mozilla.org/show_bug.cgi?id=1374885&quot;&gt;버그 1374885&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="91d9a6b8134d9d220bf49a22e472acda9ba45b4f" translate="yes" xml:space="preserve">
          <source>In Gecko, you can use this API from within chrome code. See &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Extensions/Using_the_DOM_File_API_in_chrome_code&quot;&gt;Using the DOM File API in chrome code&lt;/a&gt; for details. To use it from chrome code, JSM, and Bootstrap scope, you have to import it using &lt;code&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Components.utils.importGlobalProperties&quot;&gt;Cu.importGlobalProperties&lt;/a&gt;(['File']);&lt;/code&gt;</source>
          <target state="translated">Gecko에서는 크롬 코드 내에서이 API를 사용할 수 있습니다. 자세한 내용 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Extensions/Using_the_DOM_File_API_in_chrome_code&quot;&gt;은 크롬 코드에서 DOM 파일 API 사용&lt;/a&gt; 을 참조하십시오. 크롬 코드, JSM 및 부트 스트랩 범위에서 사용 &lt;code&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Components.utils.importGlobalProperties&quot;&gt;Cu.importGlobalProperties&lt;/a&gt;(['File']);&lt;/code&gt; ([ 'File'])를 사용하여 가져와야합니다 .</target>
        </trans-unit>
        <trans-unit id="05bce110ce739be1d88c2e456860bfff086fbce0" translate="yes" xml:space="preserve">
          <source>In Gecko-based browsers, such as Firefox, a non-standard and deprecated property &lt;code&gt;ctx.mozTextStyle&lt;/code&gt; is implemented besides this property. Don't use it.</source>
          <target state="translated">Firefox와 같은 Gecko 기반 브라우저에서는 표준이 아닌 더 이상 사용되지 않는 &lt;code&gt;ctx.mozTextStyle&lt;/code&gt; 속성이이 속성 외에 구현됩니다. 사용하지 마십시오.</target>
        </trans-unit>
        <trans-unit id="78b28a4edc686e5891a33eb10e5ea42bae6b298d" translate="yes" xml:space="preserve">
          <source>In HTML, apart from the default behavior for images, links, and selections, no other elements are draggable by default. In &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Mozilla/Tech/XUL&quot;&gt;XUL&lt;/a&gt;, all elements are draggable.</source>
          <target state="translated">HTML에서는 이미지, 링크 및 선택의 기본 동작과는 별도로 기본적으로 다른 요소를 드래그 할 수 없습니다. 에서 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Mozilla/Tech/XUL&quot;&gt;XUL&lt;/a&gt; , 모든 요소는 드래그 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="76df23da947ec4864d13fbce74cde6a0fc0ad596" translate="yes" xml:space="preserve">
          <source>In Internet Explorer (IE), the &lt;code&gt;name&lt;/code&gt; property of DOM objects created using &lt;a href=&quot;../document/createelement&quot;&gt;&lt;code&gt;document.createElement()&lt;/code&gt;&lt;/a&gt; can't be set or modified.</source>
          <target state="translated">IE (Internet Explorer)에서는 &lt;a href=&quot;../document/createelement&quot;&gt; &lt;code&gt;document.createElement()&lt;/code&gt; &lt;/a&gt; 사용하여 만든 DOM 객체 의 &lt;code&gt;name&lt;/code&gt; 속성을 설정하거나 수정할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="7b9af8f116b9548c08adfed9f852f67ef221a8d9" translate="yes" xml:space="preserve">
          <source>In Internet Explorer 9, the host of an  always include the port (e.g. &lt;code&gt;developer.mozilla.org:443&lt;/code&gt;), even if there is no explicit port in the &lt;code&gt;href&lt;/code&gt; attribute value.</source>
          <target state="translated">Internet Explorer 9 에서 &lt;code&gt;href&lt;/code&gt; 속성 값 에 명시 적 포트가없는 경우에도 호스트에는 항상 포트 (예 : &lt;code&gt;developer.mozilla.org:443&lt;/code&gt; )가 포함됩니다 .</target>
        </trans-unit>
        <trans-unit id="a1012009e448d6962290cd860063c4efd310055f" translate="yes" xml:space="preserve">
          <source>In Internet Explorer versions before IE 9, you have to use &lt;a href=&quot;addeventlistener&quot;&gt;&lt;code&gt;attachEvent()&lt;/code&gt;&lt;/a&gt;, rather than the standard &lt;code&gt;addEventListener()&lt;/code&gt;. For IE, we modify the preceding example to:</source>
          <target state="translated">IE 9 이전의 Internet Explorer 버전 에서는 표준 &lt;code&gt;addEventListener()&lt;/code&gt; 대신 &lt;a href=&quot;addeventlistener&quot;&gt; &lt;code&gt;attachEvent()&lt;/code&gt; &lt;/a&gt; 를 사용해야 합니다. IE의 경우 위 예제를 다음과 같이 수정합니다.</target>
        </trans-unit>
        <trans-unit id="b8769c75bfcdf612ab218af0d40562a89c5412a0" translate="yes" xml:space="preserve">
          <source>In Internet Explorer, all events are trusted except those that are created with the &lt;code&gt;createEvent()&lt;/code&gt; method.</source>
          <target state="translated">Internet Explorer에서 &lt;code&gt;createEvent()&lt;/code&gt; 메소드 로 작성된 이벤트를 제외한 모든 이벤트를 신뢰할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="dbec194b620319b090f4ce9324ecfa2289e8f3e0" translate="yes" xml:space="preserve">
          <source>In Internet Explorer, the timeout property may be set only after calling the &lt;a href=&quot;open&quot;&gt;open()&lt;/a&gt; method and before calling the &lt;a href=&quot;send&quot;&gt;send()&lt;/a&gt; method.</source>
          <target state="translated">Internet Explorer에서 timeout 속성은 &lt;a href=&quot;open&quot;&gt;open ()&lt;/a&gt; 메서드를 호출 한 후와 &lt;a href=&quot;send&quot;&gt;send ()&lt;/a&gt; 메서드를 호출하기 전에 만 설정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="f297f045e77efbbfc858432c4ae17eef0a17f00d" translate="yes" xml:space="preserve">
          <source>In Jake Archibald's &lt;a href=&quot;https://jsbin.com/gameboy/edit?js,console&quot;&gt;cancelling a fetch&lt;/a&gt; example, a stream is used to fetch the WHATWG HTML spec chunk by chunk; each chunk is searched for the string &quot;service workers&quot;. When the search terms is found, &lt;code&gt;cancel()&lt;/code&gt; is used to cancel the stream &amp;mdash; the job is finished so it is no longer needed.</source>
          <target state="translated">Jake Archibald가 &lt;a href=&quot;https://jsbin.com/gameboy/edit?js,console&quot;&gt;가져 오기&lt;/a&gt; 예제를 취소 할 때 WHATWG HTML 스펙 청크를 청크별로 페치하는 데 스트림이 사용됩니다. 각 청크에서 &quot;service workers&quot;문자열을 검색합니다. 검색어를 찾으면 &lt;code&gt;cancel()&lt;/code&gt; 을 사용하여 스트림을 취소합니다. 작업이 완료되어 더 이상 필요하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="0731126fd7db6c280f7a82e9052bd221299fd507" translate="yes" xml:space="preserve">
          <source>In JavaScript there are two functions respectively for decoding and encoding &lt;em&gt;base64&lt;/em&gt; strings:</source>
          <target state="translated">JavaScript에는 &lt;em&gt;base64&lt;/em&gt; 문자열 을 디코딩하고 인코딩하기위한 두 가지 기능이 각각 있습니다.</target>
        </trans-unit>
        <trans-unit id="bc530bc6a80cb9969b7735ef3f67e2e210f7e069" translate="yes" xml:space="preserve">
          <source>In JavaScript, this is achieved via the &lt;a href=&quot;../readablestream/tee&quot;&gt;&lt;code&gt;ReadableStream.tee()&lt;/code&gt;&lt;/a&gt; method &amp;mdash; it outputs an array containing two identical copies of the original readable stream, which can then be read independently by two separate readers.</source>
          <target state="translated">JavaScript에서는 &lt;a href=&quot;../readablestream/tee&quot;&gt; &lt;code&gt;ReadableStream.tee()&lt;/code&gt; &lt;/a&gt; 메서드 를 통해이 작업을 수행 합니다. 원본 읽기 가능한 스트림의 동일한 사본 두 개를 포함하는 배열을 출력 한 다음 두 개의 독자가 독립적으로 읽을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4fe9f6a47bfe2501e2a412926d76d2aaecfa69a9" translate="yes" xml:space="preserve">
          <source>In JavaScript, using the array bracket syntax with a &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String&quot;&gt;&lt;code&gt;String&lt;/code&gt;&lt;/a&gt;, like &lt;code&gt;&lt;em&gt;selectElt&lt;/em&gt;[&quot;value&quot;]&lt;/code&gt; is equivalent to &lt;code&gt;&lt;em&gt;selectElt&lt;/em&gt;&lt;/code&gt;&lt;code&gt;.namedItem(&quot;value&quot;)&lt;/code&gt;.</source>
          <target state="translated">JavaScript에서 &lt;code&gt;&lt;em&gt;selectElt&lt;/em&gt;[&quot;value&quot;]&lt;/code&gt; [ &quot;value&quot;] 와 같이 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String&quot;&gt; &lt;code&gt;String&lt;/code&gt; &lt;/a&gt; 과 함께 배열 브래킷 구문을 사용하는 것은 &lt;code&gt;&lt;em&gt;selectElt&lt;/em&gt;&lt;/code&gt; &lt;code&gt;.namedItem(&quot;value&quot;)&lt;/code&gt; 와 같습니다 .&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="6f9b2583c45fb17c1e81601acfbe654df6c26f47" translate="yes" xml:space="preserve">
          <source>In JavaScript, using the array bracket syntax with an &lt;code&gt;unsigned long&lt;/code&gt;, like &lt;code&gt;&lt;em&gt;selectElt&lt;/em&gt;[&lt;em&gt;idx&lt;/em&gt;]&lt;/code&gt; is equivalent to &lt;code&gt;&lt;em&gt;selectElt&lt;/em&gt;&lt;/code&gt;&lt;code&gt;.namedItem(&lt;em&gt;idx&lt;/em&gt;)&lt;/code&gt;.</source>
          <target state="translated">JavaScript에서 &lt;code&gt;&lt;em&gt;selectElt&lt;/em&gt;[&lt;em&gt;idx&lt;/em&gt;]&lt;/code&gt; [ &lt;em&gt;idx&lt;/em&gt; ] 와 같이 &lt;code&gt;unsigned long&lt;/code&gt; 과 함께 배열 괄호 구문을 사용하는 것은 &lt;code&gt;&lt;em&gt;selectElt&lt;/em&gt;&lt;/code&gt; &lt;code&gt;.namedItem(&lt;em&gt;idx&lt;/em&gt;)&lt;/code&gt; &lt;em&gt;idx&lt;/em&gt; ) 와 같습니다 .&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="50dc20d933b4a4d292b6163114bdc8dd4c81aeac" translate="yes" xml:space="preserve">
          <source>In JavaScript, when an object is passed to a function expecting a string (like &lt;a href=&quot;../window/alert&quot;&gt;&lt;code&gt;Window.alert()&lt;/code&gt;&lt;/a&gt;), the object's &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/toString&quot;&gt;&lt;code&gt;toString()&lt;/code&gt;&lt;/a&gt; method is called and the returned value is passed to the function. This can make the object appear to be a string when used with other functions when it is really an object with properties and methods.</source>
          <target state="translated">JavaScript에서 객체가 &lt;a href=&quot;../window/alert&quot;&gt; &lt;code&gt;Window.alert()&lt;/code&gt; &lt;/a&gt; 와 같은 문자열을 기대하는 함수에 전달 되면 객체의 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/toString&quot;&gt; &lt;code&gt;toString()&lt;/code&gt; &lt;/a&gt; 메서드가 호출되고 반환 된 값이 함수에 전달됩니다. 이것은 실제로 속성과 메소드를 가진 객체 일 때 다른 함수와 함께 사용될 때 객체를 문자열로 보이게 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="84ef7c9193969970e6994b69e5fb0fd8d3e972c7" translate="yes" xml:space="preserve">
          <source>In JavaScript, when an object is passed to a function expecting a string (like &lt;a href=&quot;alert&quot;&gt;&lt;code&gt;window.alert()&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;../document/write&quot;&gt;&lt;code&gt;document.write()&lt;/code&gt;&lt;/a&gt;), the object's &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/toString&quot;&gt;&lt;code&gt;toString()&lt;/code&gt;&lt;/a&gt; method is called and the returned value is passed to the function. This can make the object appear to be a string when used with other functions when it is really an object with properties and methods.</source>
          <target state="translated">JavaScript에서 객체가 문자열을 예상하는 함수 ( &lt;a href=&quot;alert&quot;&gt; &lt;code&gt;window.alert()&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;../document/write&quot;&gt; &lt;code&gt;document.write()&lt;/code&gt; &lt;/a&gt; 와 같은 )에 전달되면 객체의 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/toString&quot;&gt; &lt;code&gt;toString()&lt;/code&gt; &lt;/a&gt; 메서드가 호출되고 반환 된 값이 함수에 전달됩니다. 이것은 실제로 속성과 메소드를 가진 객체 일 때 다른 함수와 함께 사용될 때 객체를 문자열로 보이게 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="31ee0b878e99dac03ea78cd3c1d63e034b7957af" translate="yes" xml:space="preserve">
          <source>In MSIE 6 for XP SP2:</source>
          <target state="translated">XP SP2 용 MSIE 6 :</target>
        </trans-unit>
        <trans-unit id="3df60aa7e19fc5e9d9e114120ab6cf670903429b" translate="yes" xml:space="preserve">
          <source>In MSIE 6 for XP SP2: For windows opened using &lt;code&gt;window.open()&lt;/code&gt;:</source>
          <target state="translated">XP SP2 용 MSIE 6의 경우 : &lt;code&gt;window.open()&lt;/code&gt; 사용하여 열린 창의 경우 :</target>
        </trans-unit>
        <trans-unit id="21f428615ed91f21f66bab2fa33dcf7a79983a9f" translate="yes" xml:space="preserve">
          <source>In MSIE 6, the nearest equivalent to this feature is the &lt;code&gt;showModelessDialog()&lt;/code&gt; method.</source>
          <target state="translated">MSIE 6에서이 기능과 가장 유사한 기능은 &lt;code&gt;showModelessDialog()&lt;/code&gt; 메서드입니다.</target>
        </trans-unit>
        <trans-unit id="20b6710cc9fc9e013712902727fa9c243c7557e9" translate="yes" xml:space="preserve">
          <source>In Opera 32, the ability to have multiple shadow roots was deprecated.</source>
          <target state="translated">Opera 32에서는 다중 섀도우 루트 기능이 더 이상 사용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="fe41eb685be5f16a3fc466a41fd05bfb2bb623f8" translate="yes" xml:space="preserve">
          <source>In Opera, this method is blocked inside an &lt;code&gt;&amp;lt;iframe&amp;gt;&lt;/code&gt; unless its sandbox attribute has the value &lt;code&gt;allow-modals&lt;/code&gt;.</source>
          <target state="translated">Opera에서이 메소드는 샌드 박스 속성에 &lt;code&gt;allow-modals&lt;/code&gt; 값이 없으면 &lt;code&gt;&amp;lt;iframe&amp;gt;&lt;/code&gt; 내에서 차단됩니다 .</target>
        </trans-unit>
        <trans-unit id="86711236e970b3355a2d317ba189dd9003d379b1" translate="yes" xml:space="preserve">
          <source>In React native simulator, navigator.geolocation.getCurrentPosition() returns coordinates of San Francisco (37,-122)</source>
          <target state="translated">React 기본 시뮬레이터에서 navigator.geolocation.getCurrentPosition ()은 샌프란시스코의 좌표를 반환합니다 (37, -122)</target>
        </trans-unit>
        <trans-unit id="a57ebac206e798efc3ba41d1708fdbf06e97a55b" translate="yes" xml:space="preserve">
          <source>In Web Audio, complex 3D spatializations are created using the &lt;a href=&quot;../pannernode&quot;&gt;&lt;code&gt;PannerNode&lt;/code&gt;&lt;/a&gt;, which in layman's terms is basically a whole lotta cool maths to make audio appear in 3D space. Think sounds flying over you, creeping up behind you, moving across in front of you. That sort of thing.</source>
          <target state="translated">Web Audio에서 &lt;a href=&quot;../pannernode&quot;&gt; &lt;code&gt;PannerNode&lt;/code&gt; 를&lt;/a&gt; 사용하여 복잡한 3D 공간 화가 생성됩니다. PannerNode 는 기본적으로 평신도의 용어로 오디오를 3D 공간에 표시하는 멋진 수학입니다. 당신 위로 날아가는 소리, 당신의 뒤에서 기어 오르는 소리, 당신의 앞을 가로 질러 움직이는 것을 생각하십시오. 그런 종류의 것.</target>
        </trans-unit>
        <trans-unit id="dbff28ee8699bb24155b33da2d8102ba2bac1b2f" translate="yes" xml:space="preserve">
          <source>In WebGL 2, other queries (such as occlusion queries and primitive queries) are possible using &lt;a href=&quot;webglquery&quot;&gt;&lt;code&gt;WebGLQuery&lt;/code&gt;&lt;/a&gt; objects.</source>
          <target state="translated">WebGL 2에서는 &lt;a href=&quot;webglquery&quot;&gt; &lt;code&gt;WebGLQuery&lt;/code&gt; &lt;/a&gt; 객체를 사용하여 다른 쿼리 (예 : 폐색 쿼리 및 기본 쿼리)가 가능 합니다.</target>
        </trans-unit>
        <trans-unit id="6d8348b853532b86f3c4eb5f47e10226fb27c904" translate="yes" xml:space="preserve">
          <source>In WebGL 2, the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/GetQueryObject&quot;&gt;&lt;code&gt;getQueryObject&lt;/code&gt;&lt;/a&gt; was renamed to &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/GetQueryParameter&quot;&gt;&lt;code&gt;getQueryParameter&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">WebGL을 2에서 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/GetQueryObject&quot;&gt; &lt;code&gt;getQueryObject&lt;/code&gt; 는&lt;/a&gt; 이름이 바뀌 었습니다 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/GetQueryParameter&quot;&gt; &lt;code&gt;getQueryParameter&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="cc74714e29fdf4ec27875e11090d544619ffa9c5" translate="yes" xml:space="preserve">
          <source>In WebGL, constant color and constant alpha cannot be used together as source and destination factors in the blend function. See section 6.13. of the specification.</source>
          <target state="translated">WebGL에서 고정 색상과 고정 알파는 블렌드 함수에서 소스 및 대상 요소로 함께 사용될 수 없습니다. 6.13 절을 참조하십시오. 사양의.</target>
        </trans-unit>
        <trans-unit id="0ce407b6d7057cc13bbcddff930c372e00bfa466" translate="yes" xml:space="preserve">
          <source>In WebGL, objects are built using sets of vertices, each of which has a position and a color; by default, all other pixels' colors (and all its other attributes, including position) are computed using interpolation, automatically creating smooth gradients. Previously, our vertex shader didn't apply any specific colors to the vertices; between this and the fragment shader assigning the fixed color of white to each pixel, the entire square was rendered as solid white.</source>
          <target state="translated">WebGL에서 객체는 정점 세트를 사용하여 작성되며 각 정점은 위치와 색상을 갖습니다. 기본적으로 다른 모든 픽셀의 색상 (및 위치를 포함한 다른 모든 속성)은 보간법을 사용하여 계산되어 부드러운 그라디언트를 자동으로 만듭니다. 이전에는 정점 셰이더가 정점에 특정 색상을 적용하지 않았습니다. 이것과 각 픽셀에 고정 된 흰색의 색을 할당하는 프래그먼트 쉐이더 사이에서, 전체 정사각형은 단색 흰색으로 렌더링되었습니다.</target>
        </trans-unit>
        <trans-unit id="63a56a78d439d3f52a2060db1bbf57b3913d73d7" translate="yes" xml:space="preserve">
          <source>In WebGL, values that apply to a specific vertex are stored in &lt;a href=&quot;../webgl_api/data#Attributes&quot;&gt;attributes&lt;/a&gt;. These are only available to the JavaScript code and the vertex shader. Attributes are referenced by an index number into the list of attributes maintained by the GPU. Some vertex attribute indices may have predefined purposes, depending on the platform and/or the GPU. Others are assigned by the WebGL layer when you create the attributes.</source>
          <target state="translated">WebGL에서 특정 정점에 적용되는 값은 &lt;a href=&quot;../webgl_api/data#Attributes&quot;&gt;attributes에&lt;/a&gt; 저장됩니다 . 이것들은 JavaScript 코드와 버텍스 쉐이더에서만 사용할 수 있습니다. 속성은 인덱스 번호로 GPU가 유지 관리하는 속성 목록으로 참조됩니다. 일부 버텍스 속성 인덱스는 플랫폼 및 / 또는 GPU에 따라 사전 정의 된 목적을 가질 수 있습니다. 속성을 작성할 때 WebGL 계층에서 다른 항목을 지정합니다.</target>
        </trans-unit>
        <trans-unit id="babd0a286b77a2c23f030b96a8529cabcfa2a9ab" translate="yes" xml:space="preserve">
          <source>In WebKit- and Blink-based Browsers, a non-standard and deprecated method &lt;code&gt;ctx.setAlpha()&lt;/code&gt; is implemented in addition to this property.</source>
          <target state="translated">WebKit 및 Blink 기반 브라우저에서는 이 특성 외에도 비표준적이고 더 이상 사용되지 않는 메소드 &lt;code&gt;ctx.setAlpha()&lt;/code&gt; 가 구현됩니다.</target>
        </trans-unit>
        <trans-unit id="f2886bdddd415bcc5f07f47da7635449fbd90295" translate="yes" xml:space="preserve">
          <source>In WebKit- and Blink-based Browsers, a non-standard and deprecated method &lt;code&gt;ctx.setCompositeOperation()&lt;/code&gt; is implemented besides this property.</source>
          <target state="translated">WebKit 및 Blink 기반 브라우저에서 비표준적이고 더 이상 사용되지 않는 메소드 &lt;code&gt;ctx.setCompositeOperation()&lt;/code&gt; 이이 특성 외에 구현됩니다.</target>
        </trans-unit>
        <trans-unit id="a56415221680b7086db38ccd799284c36ede7deb" translate="yes" xml:space="preserve">
          <source>In WebKit- and Blink-based Browsers, a non-standard and deprecated method &lt;code&gt;ctx.setLineCap()&lt;/code&gt; is implemented in addition to this property.</source>
          <target state="translated">WebKit 및 Blink 기반 브라우저에서는 이 특성 외에 비표준적이고 더 이상 사용되지 않는 메소드 &lt;code&gt;ctx.setLineCap()&lt;/code&gt; 이 구현됩니다.</target>
        </trans-unit>
        <trans-unit id="7896c0e7fd6f0a6d6113498686b3685dd3d51f87" translate="yes" xml:space="preserve">
          <source>In WebKit- and Blink-based Browsers, a non-standard and deprecated method &lt;code&gt;ctx.setLineJoin()&lt;/code&gt; is implemented in addition to this property.</source>
          <target state="translated">WebKit 및 Blink 기반 브라우저에서는 이 특성 외에도 비표준적이고 더 이상 사용되지 않는 메소드 &lt;code&gt;ctx.setLineJoin()&lt;/code&gt; 이 구현됩니다.</target>
        </trans-unit>
        <trans-unit id="ee03c0fa2d47cbc2fcebfd38bae5706f114493db" translate="yes" xml:space="preserve">
          <source>In WebKit- and Blink-based Browsers, a non-standard and deprecated method &lt;code&gt;ctx.setLineWidth()&lt;/code&gt; is implemented in addition to this property.</source>
          <target state="translated">WebKit 및 Blink 기반 브라우저에서는 이 특성 외에 비표준적이고 더 이상 사용되지 않는 메소드 &lt;code&gt;ctx.setLineWidth()&lt;/code&gt; 가 구현됩니다.</target>
        </trans-unit>
        <trans-unit id="8136be5e0bd96f1c939cfedc3dbd53b9ba047ee1" translate="yes" xml:space="preserve">
          <source>In WebKit- and Blink-based Browsers, a non-standard and deprecated method &lt;code&gt;ctx.setMiterLimit()&lt;/code&gt; is implemented in addition to this property.</source>
          <target state="translated">WebKit 및 Blink 기반 브라우저에서는 이 특성 외에 비표준적이고 더 이상 사용되지 않는 메소드 &lt;code&gt;ctx.setMiterLimit()&lt;/code&gt; 가 구현됩니다.</target>
        </trans-unit>
        <trans-unit id="08734d623b9332b4871d658938a3a76343b1edb7" translate="yes" xml:space="preserve">
          <source>In WebKit- and Blink-based browsers, the non-standard and deprecated method &lt;code&gt;ctx.setFillColor()&lt;/code&gt; is implemented in addition to this property.</source>
          <target state="translated">WebKit 및 Blink 기반 브라우저에서는 이 특성 외에 비표준 및 더 이상 사용되지 않는 메소드 &lt;code&gt;ctx.setFillColor()&lt;/code&gt; 가 구현됩니다.</target>
        </trans-unit>
        <trans-unit id="da8345eea03606bb45a0d767293613aa7a52287b" translate="yes" xml:space="preserve">
          <source>In WebKit- and Blink-based browsers, the non-standard and deprecated method &lt;code&gt;ctx.setShadow()&lt;/code&gt; is implemented besides this property.</source>
          <target state="translated">WebKit 및 Blink 기반 브라우저에서 비표준 및 더 이상 사용되지 않는 메소드 &lt;code&gt;ctx.setShadow()&lt;/code&gt; 가이 특성 외에 구현됩니다.</target>
        </trans-unit>
        <trans-unit id="bdee8e5c78a56e49134692ae4cbc4886d5332a0d" translate="yes" xml:space="preserve">
          <source>In WebKit- and Blink-based browsers, the non-standard and deprecated method &lt;code&gt;ctx.setStrokeColor()&lt;/code&gt; is implemented in addition to this property.</source>
          <target state="translated">WebKit 및 Blink 기반 브라우저에서 비표준 및 더 이상 사용되지 않는 메소드 &lt;code&gt;ctx.setStrokeColor()&lt;/code&gt; 가이 특성 외에도 구현됩니다.</target>
        </trans-unit>
        <trans-unit id="fe23908f69dad5945cd3ab5739ac032c31234958" translate="yes" xml:space="preserve">
          <source>In WebKit-based browsers (e.g. Safari), the non-standard and deprecated property &lt;code&gt;webkitLineDashOffset&lt;/code&gt; is implemented besides this method. Use &lt;code&gt;lineDashOffset&lt;/code&gt; instead.</source>
          <target state="translated">WebKit 기반 브라우저 (예 : Safari)에서는 이 방법 외에 비표준 및 더 이상 사용되지 않는 속성 인 &lt;code&gt;webkitLineDashOffset&lt;/code&gt; 이 구현됩니다. 대신 &lt;code&gt;lineDashOffset&lt;/code&gt; 을 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="94a41e07273af95e569869de7e5770c920a4b87b" translate="yes" xml:space="preserve">
          <source>In WebKit-based browsers (e.g., Safari), the non-standard and deprecated property &lt;code&gt;webkitLineDash&lt;/code&gt; is implemented besides this method. Use &lt;code&gt;getLineDash()&lt;/code&gt; instead.</source>
          <target state="translated">WebKit 기반 브라우저 (예 : Safari)에서는 이 방법 외에 비표준 및 더 이상 사용되지 않는 속성 &lt;code&gt;webkitLineDash&lt;/code&gt; 가 구현됩니다. 대신 &lt;code&gt;getLineDash()&lt;/code&gt; 를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="99ac1306d5334fd03c474849a643e816f9249b43" translate="yes" xml:space="preserve">
          <source>In WebKit-based browsers (e.g., Safari), the non-standard and deprecated property &lt;code&gt;webkitLineDash&lt;/code&gt; is implemented besides this method. Use &lt;code&gt;setLineDash()&lt;/code&gt; instead.</source>
          <target state="translated">WebKit 기반 브라우저 (예 : Safari)에서는 이 방법 외에 비표준 및 더 이상 사용되지 않는 속성 &lt;code&gt;webkitLineDash&lt;/code&gt; 가 구현됩니다. 대신 &lt;code&gt;setLineDash()&lt;/code&gt; 를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="1074a9ad497a881350ea353edcc331a1bd919a52" translate="yes" xml:space="preserve">
          <source>In XHTML (or any other XML format), &lt;code&gt;text_field&lt;/code&gt;'s value would read &quot;div&quot;. However, in HTML, &lt;code&gt;text_field&lt;/code&gt;'s value would read &quot;DIV&quot;, because &lt;code&gt;nodeName&lt;/code&gt; and &lt;code&gt;tagName&lt;/code&gt; return in upper case on HTML elements in DOMs flagged as HTML documents. Read more &lt;a href=&quot;http://ejohn.org/blog/nodename-case-sensitivity/&quot;&gt;details on nodeName case sensitivity in different browsers&lt;/a&gt;.</source>
          <target state="translated">XHTML (또는 다른 XML 형식)에서 &lt;code&gt;text_field&lt;/code&gt; 의 값은 &quot;div&quot;입니다. 그러나 HTML에서 &lt;code&gt;text_field&lt;/code&gt; 의 값은 &quot;DIV&quot; 로 표시됩니다. &lt;code&gt;nodeName&lt;/code&gt; 및 &lt;code&gt;tagName&lt;/code&gt; 은 HTML 문서로 플래그 지정된 DOM의 HTML 요소에서 대문자로 반환 되기 때문 입니다. &lt;a href=&quot;http://ejohn.org/blog/nodename-case-sensitivity/&quot;&gt;다른 브라우저에서 nodeName 대소 문자 구분에 대한&lt;/a&gt; 자세한 내용을 읽으십시오 .</target>
        </trans-unit>
        <trans-unit id="9408e22bb7885624859160370a74cf5240766138" translate="yes" xml:space="preserve">
          <source>In XHTML (or any other XML format), the original case will be maintained, so &lt;code&gt;&quot;span&quot;&lt;/code&gt; would be output in case the original tag name was created lowercase. In HTML, &lt;code&gt;&quot;SPAN&quot;&lt;/code&gt; would be output instead regardless of the case used while creating the original document.</source>
          <target state="translated">XHTML (또는 다른 XML 형식)에서는 원래 대소 문자가 유지되므로 원래 태그 이름이 소문자로 작성된 경우 &lt;code&gt;&quot;span&quot;&lt;/code&gt; 이 출력됩니다. HTML에서는 원본 문서를 만드는 동안 사용 된 경우에 관계없이 &lt;code&gt;&quot;SPAN&quot;&lt;/code&gt; 이 대신 출력됩니다.</target>
        </trans-unit>
        <trans-unit id="a41343eca20c588bceac15e00f8699e4c3d55b35" translate="yes" xml:space="preserve">
          <source>In XML, a CDATA section looks like:</source>
          <target state="translated">XML에서 CDATA 섹션은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="8d5c7dc1acb5bb6581d05b8004aa1fb5cfacb218" translate="yes" xml:space="preserve">
          <source>In XUL, accessing &lt;code&gt;document.title&lt;/code&gt; before the document is fully loaded has undefined behavior: &lt;code&gt;document.title&lt;/code&gt; may return an empty string and setting &lt;code&gt;document.title&lt;/code&gt; may have no effect.</source>
          <target state="translated">XUL 에서 문서가 완전히로드되기 전에 &lt;code&gt;document.title&lt;/code&gt; 에 액세스 하면 정의되지 않은 동작이 발생합니다. &lt;code&gt;document.title&lt;/code&gt; 은 빈 문자열을 반환하고 &lt;code&gt;document.title&lt;/code&gt; 을 설정해 도 효과가 없습니다.</target>
        </trans-unit>
        <trans-unit id="d0379952f2f06b5c260c5c2c88513e5c5c920720" translate="yes" xml:space="preserve">
          <source>In a &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Mozilla/Tech/XUL&quot;&gt;XUL&lt;/a&gt; document, it creates the specified XUL element.</source>
          <target state="translated">A의 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Mozilla/Tech/XUL&quot;&gt;XUL의&lt;/a&gt; 문서가 지정된 XUL 요소를 만듭니다.</target>
        </trans-unit>
        <trans-unit id="8c412148edddbf3d435dd5db9ad1fe25a3c8283b" translate="yes" xml:space="preserve">
          <source>In a &lt;a href=&quot;https://www.w3.org/TR/presentation-api/#dfn-controlling-user-agent&quot;&gt;controlling user agent&lt;/a&gt;, the</source>
          <target state="translated">(A)에 &lt;a href=&quot;https://www.w3.org/TR/presentation-api/#dfn-controlling-user-agent&quot;&gt;제어 사용자 에이전트&lt;/a&gt; 는</target>
        </trans-unit>
        <trans-unit id="999ecf606391460770c476ca8a7251cfdf10dcb5" translate="yes" xml:space="preserve">
          <source>In a &lt;a href=&quot;https://www.w3.org/TR/presentation-api/#dfn-receiving-user-agent&quot;&gt;receiving user agent&lt;/a&gt;, the</source>
          <target state="translated">A의 &lt;a href=&quot;https://www.w3.org/TR/presentation-api/#dfn-receiving-user-agent&quot;&gt;수신하는 사용자 에이전트&lt;/a&gt; 의</target>
        </trans-unit>
        <trans-unit id="baa846a16d1454a185d63cdd88529d2c99daba49" translate="yes" xml:space="preserve">
          <source>In a WebGL program data is typically uploaded to the GPU with its own coordinate system and then the vertex shader transforms those points into a different coordinate system known as &lt;strong&gt;clip space&lt;/strong&gt;. If any data is outside of the clip space, then it is clipped off and not rendered. However, if a triangle straddles the border of this space then it is chopped up into new triangles, and only the parts of the new triangles that are in clip space are kept.</source>
          <target state="translated">WebGL 프로그램에서 데이터는 일반적으로 자체 좌표계를 사용하여 GPU에 업로드 된 다음 정점 셰이더가 해당 점을 &lt;strong&gt;클립 공간&lt;/strong&gt; 이라고하는 다른 좌표계로 변환 &lt;strong&gt;합니다&lt;/strong&gt; . 클립 공간 밖에있는 데이터가 있으면 잘려서 렌더링되지 않습니다. 그러나 삼각형이이 공간의 경계에 걸쳐 있으면 새 삼각형으로 잘리고 클립 공간에있는 새 삼각형의 일부만 유지됩니다.</target>
        </trans-unit>
        <trans-unit id="6805dd35b91a76558c3a720196f4d46750aaff29" translate="yes" xml:space="preserve">
          <source>In a few years, the &lt;a href=&quot;http://www.w3.org/TR/2004/WD-css3-hyperlinks-20040224/#target0&quot;&gt;target property of the CSS3 hyperlink module&lt;/a&gt; may be implemented (if CSS3 Hyperlink module as it is right now is approved). And even if and when this happens, you can expect developers of browsers with tab-browsing to give the user entire veto power and full control over how links can open web pages. How to open a link should always be entirely under the control of the user.</source>
          <target state="translated">몇 년 &lt;a href=&quot;http://www.w3.org/TR/2004/WD-css3-hyperlinks-20040224/#target0&quot;&gt;후 CSS3 하이퍼 링크 모듈&lt;/a&gt; 의 대상 속성 이 구현 될 수 있습니다 (현재 CSS3 하이퍼 링크 모듈이 승인 된 경우). 이러한 상황이 발생하더라도 탭 브라우징 기능이있는 브라우저 개발자는 사용자에게 전체 거부권과 링크가 웹 페이지를 여는 방법에 대한 모든 권한을 부여 할 것으로 기대할 수 있습니다. 링크를 여는 방법은 항상 사용자의 통제하에 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="288257a333692380d62324a4e5d6b072936e1384" translate="yes" xml:space="preserve">
          <source>In a multi-pointer scenario (such as a touch screen that supports more than one touch point), this property is used to identify a &lt;em&gt;master pointer&lt;/em&gt; among the set of active pointers for each pointer type. Only a primary pointer will produce &lt;em&gt;compatibility mouse events&lt;/em&gt;. Authors who desire only single-pointer interaction can achieve that by ignoring non-primary pointers.</source>
          <target state="translated">다중 포인터 시나리오 (예 : 둘 이상의 터치 포인트를 지원하는 터치 스크린)에서이 속성은 각 포인터 유형에 대한 활성 포인터 세트 중에서 &lt;em&gt;마스터 포인터&lt;/em&gt; 를 식별하는 데 사용됩니다 . 기본 포인터 만 &lt;em&gt;호환 마우스 이벤트를&lt;/em&gt; 생성 &lt;em&gt;합니다&lt;/em&gt; . 단일 포인터 상호 작용 만 원하는 작성자는 기본이 아닌 포인터를 무시하여이를 달성 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="217ea5cca9699504b57fcecb48b0029845d1abba" translate="yes" xml:space="preserve">
          <source>In a nutshell</source>
          <target state="translated">간단히 말해서</target>
        </trans-unit>
        <trans-unit id="4d627150af604a4dbe3d4a3367b0a4a58b248d7b" translate="yes" xml:space="preserve">
          <source>In a previous version of the specification, the &lt;code&gt;dopplerFactor&lt;/code&gt; and &lt;code&gt;speedOfSound&lt;/code&gt; properties and the &lt;code&gt;setPosition()&lt;/code&gt; method could be used to control the doppler effect applied to &lt;a href=&quot;audiobuffersourcenode&quot;&gt;&lt;code&gt;AudioBufferSourceNode&lt;/code&gt;&lt;/a&gt;s connected downstream &amp;mdash; these would be pitched up and down according to the relative speed of the &lt;a href=&quot;pannernode&quot;&gt;&lt;code&gt;PannerNode&lt;/code&gt;&lt;/a&gt; and the &lt;a href=&quot;audiolistener&quot;&gt;&lt;code&gt;AudioListener&lt;/code&gt;&lt;/a&gt;. These features had a number of problems:</source>
          <target state="translated">사양의 이전 버전에서는 &lt;code&gt;dopplerFactor&lt;/code&gt; 및 &lt;code&gt;speedOfSound&lt;/code&gt; 속성과 &lt;code&gt;setPosition()&lt;/code&gt; 메서드를 사용하여 다운 스트림에 연결된 &lt;a href=&quot;audiobuffersourcenode&quot;&gt; &lt;code&gt;AudioBufferSourceNode&lt;/code&gt; 에&lt;/a&gt; 적용된 도플러 효과를 제어 할 수있었습니다 . &lt;a href=&quot;pannernode&quot;&gt; &lt;code&gt;PannerNode&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;audiolistener&quot;&gt; &lt;code&gt;AudioListener&lt;/code&gt; &lt;/a&gt; . 이러한 기능에는 여러 가지 문제가있었습니다.</target>
        </trans-unit>
        <trans-unit id="edf5e271e1a32d32d2624fbcd6515aea5ae46e57" translate="yes" xml:space="preserve">
          <source>In a sense, calling &lt;code&gt;pushState()&lt;/code&gt; is similar to setting &lt;code&gt;window.location = &quot;#foo&quot;&lt;/code&gt;, in that both will also create and activate another history entry associated with the current document. But &lt;code&gt;pushState()&lt;/code&gt; has a few advantages:</source>
          <target state="translated">어떤 의미에서 &lt;code&gt;pushState()&lt;/code&gt; 호출 은 &lt;code&gt;window.location = &quot;#foo&quot;&lt;/code&gt; 설정과 비슷 합니다. 둘 다 현재 문서와 관련된 다른 기록 항목을 만들고 활성화하기 때문입니다. 그러나 &lt;code&gt;pushState()&lt;/code&gt; 에는 몇 가지 장점이 있습니다.</target>
        </trans-unit>
        <trans-unit id="1aa6cf9c56e6ae6a4f5ab220b4d4141195d66294" translate="yes" xml:space="preserve">
          <source>In a tabbed browser, each tab is represented by its own &lt;code&gt;Window&lt;/code&gt; object; the global &lt;code&gt;window&lt;/code&gt; seen by JavaScript code running within a given tab always represents the tab in which the code is running. That said, even in a tabbed browser, some properties and methods still apply to the overall window that contains the tab, such as &lt;a href=&quot;window/resizeto&quot;&gt;&lt;code&gt;resizeTo()&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;window/innerheight&quot;&gt;&lt;code&gt;innerHeight&lt;/code&gt;&lt;/a&gt;. Generally, anything that can't reasonably pertain to a tab pertains to the window instead.</source>
          <target state="translated">탭 브라우저에서 각 탭은 고유 한 &lt;code&gt;Window&lt;/code&gt; 객체로 표시됩니다 . 주어진 탭 내에서 실행되는 JavaScript 코드로 표시되는 전역 &lt;code&gt;window&lt;/code&gt; 은 항상 코드가 실행되는 탭을 나타냅니다. 즉, 탭 브라우저에서도 일부 속성과 메소드는 &lt;a href=&quot;window/resizeto&quot;&gt; &lt;code&gt;resizeTo()&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;window/innerheight&quot;&gt; &lt;code&gt;innerHeight&lt;/code&gt; &lt;/a&gt; 와 같이 탭이 포함 된 전체 창에 계속 적용됩니다 . 일반적으로 탭과 관련이없는 것은 창과 관련이 있습니다.</target>
        </trans-unit>
        <trans-unit id="9e0536baeee3d104653cc45d1fb8b1017731de67" translate="yes" xml:space="preserve">
          <source>In a traditional relational data store, you would have a table that stores a collection of rows of data and columns of named types of data. IndexedDB, on the other hand, requires you to create an object store for a type of data and simply persist JavaScript objects to that store. Each object store can have a collection of indexes that makes it efficient to query and iterate across. If you are not familiar with object-oriented database management systems, read the &lt;a href=&quot;https://en.wikipedia.org/wiki/Object_database&quot;&gt;Wikipedia article on object database&lt;/a&gt;.</source>
          <target state="translated">전통적인 관계형 데이터 저장소에는 데이터 행과 명명 된 유형의 데이터 열을 저장하는 테이블이 있습니다. 반면, IndexedDB는 데이터 유형에 대한 객체 저장소를 생성하고 해당 객체에 JavaScript 객체를 유지하기 만하면됩니다. 각 오브젝트 저장소에는 쿼리 콜렉션 및 반복을 효율적으로 수행 할 수있는 인덱스 콜렉션이있을 수 있습니다. 오브젝트 지향 데이터베이스 관리 시스템에 익숙하지 않은 경우 &lt;a href=&quot;https://en.wikipedia.org/wiki/Object_database&quot;&gt;오브젝트 데이터베이스에&lt;/a&gt; 대한 Wikipedia 기사를 읽으십시오 .</target>
        </trans-unit>
        <trans-unit id="fd8ade8105095ec309d14f4e476d9c3c6d2063ab" translate="yes" xml:space="preserve">
          <source>In a web page, you should call the &lt;a href=&quot;../event/preventdefault&quot;&gt;&lt;code&gt;preventDefault()&lt;/code&gt;&lt;/a&gt; method of the event if you have accepted the drop so that the default browser handling does not handle the dropped data as well. For example, when a link is dragged to a web page, Firefox will open the link. By cancelling the event, this behavior will be prevented.</source>
          <target state="translated">웹 페이지 에서 기본 브라우저 처리가 삭제 된 데이터도 처리하지 않도록 삭제를 승인 한 경우 이벤트 의 &lt;a href=&quot;../event/preventdefault&quot;&gt; &lt;code&gt;preventDefault()&lt;/code&gt; &lt;/a&gt; 메소드를 호출 해야 합니다. 예를 들어, 링크를 웹 페이지로 드래그하면 Firefox가 링크를 엽니 다. 이벤트를 취소하면이 동작이 방지됩니다.</target>
        </trans-unit>
        <trans-unit id="ff780bc261ece6b341c72d1d771a03d00ba330c3" translate="yes" xml:space="preserve">
          <source>In addition to &quot;clamping&quot;, the timeout can also fire later when the page (or the OS/browser itself) is busy with other tasks. One important case to note is that the function or code snippet cannot be executed until the thread that called &lt;code&gt;setTimeout()&lt;/code&gt; has terminated. For example:</source>
          <target state="translated">&quot;클램핑&quot;외에도 페이지 (또는 OS / 브라우저 자체)가 다른 작업으로 바쁠 때 시간 초과가 발생할 수 있습니다. 주목해야 할 중요한 경우는 &lt;code&gt;setTimeout()&lt;/code&gt; 을 호출 한 스레드 가 종료 될 때까지 함수 또는 코드 스 니펫을 실행할 수 없다는 것 입니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="c24e4392b4e9e9a4bbe883663a270f90bfeb2816" translate="yes" xml:space="preserve">
          <source>In addition to being able to obtain direct access to the audio tracks present on a media element, &lt;code&gt;AudioTrackList&lt;/code&gt; lets you set event handlers on the &lt;code&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Events/addtrack&quot;&gt;addtrack&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Events/removetrack&quot;&gt;removetrack&lt;/a&gt;&lt;/code&gt; events, so that you can detect when tracks are added to or removed from the media element's stream. See &lt;a href=&quot;audiotracklist/onaddtrack&quot;&gt;&lt;code&gt;onaddtrack&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;audiotracklist/onremovetrack&quot;&gt;&lt;code&gt;onremovetrack&lt;/code&gt;&lt;/a&gt; for details and examples.</source>
          <target state="translated">오디오 트랙은 미디어 요소에 존재에 직접 액세스를 얻을 수있을뿐 아니라, &lt;code&gt;AudioTrackList&lt;/code&gt; 는 당신에게에 세트 이벤트 핸들러 수 있습니다 &lt;code&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Events/addtrack&quot;&gt;addtrack&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Events/removetrack&quot;&gt;removetrack&lt;/a&gt;&lt;/code&gt; 트랙이 추가되거나 미디어 요소의 스트림에서 제거 할 때이를 감지 할 수 있다는 이벤트를. 자세한 내용과 예제는 &lt;a href=&quot;audiotracklist/onaddtrack&quot;&gt; &lt;code&gt;onaddtrack&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;audiotracklist/onremovetrack&quot;&gt; &lt;code&gt;onremovetrack&lt;/code&gt; &lt;/a&gt; 을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="656746f7a9df8510b6e10d45fa72ee932e5e8412" translate="yes" xml:space="preserve">
          <source>In addition to being able to obtain direct access to the video tracks present on a media element, &lt;code&gt;VideoTrackList&lt;/code&gt; lets you set event handlers on the &lt;code&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Events/addtrack&quot;&gt;addtrack&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Events/removetrack&quot;&gt;removetrack&lt;/a&gt;&lt;/code&gt; events, so that you can detect when tracks are added to or removed from the media element's stream. See &lt;a href=&quot;videotracklist/onaddtrack&quot;&gt;&lt;code&gt;onaddtrack&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;videotracklist/onremovetrack&quot;&gt;&lt;code&gt;onremovetrack&lt;/code&gt;&lt;/a&gt; for details and examples.</source>
          <target state="translated">&lt;code&gt;VideoTrackList&lt;/code&gt; 를 사용하면 미디어 요소에있는 비디오 트랙에 직접 액세스 할 수있을뿐만 아니라 &lt;code&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Events/addtrack&quot;&gt;addtrack&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Events/removetrack&quot;&gt;removetrack&lt;/a&gt;&lt;/code&gt; 이벤트 에 이벤트 핸들러를 설정 하여 미디어 요소 스트림에서 트랙이 추가되거나 제거되는시기를 감지 할 수 있습니다. 자세한 내용과 예제는 &lt;a href=&quot;videotracklist/onaddtrack&quot;&gt; &lt;code&gt;onaddtrack&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;videotracklist/onremovetrack&quot;&gt; &lt;code&gt;onremovetrack&lt;/code&gt; &lt;/a&gt; 을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="79a2c464f89ef065a7335ebc826ecd5b324ced11" translate="yes" xml:space="preserve">
          <source>In addition to dedicated and shared web workers, there are other types of worker available:</source>
          <target state="translated">전담 및 공유 웹 워커 외에도 다른 유형의 워커가 있습니다.</target>
        </trans-unit>
        <trans-unit id="366c222257acfd309728f5961616ecb086e90c83" translate="yes" xml:space="preserve">
          <source>In addition to dedicated workers, there are other types of worker:</source>
          <target state="translated">전담 근로자 외에도 다른 유형의 근로자가 있습니다.</target>
        </trans-unit>
        <trans-unit id="16392a45a9b827117cf70215450ef600443f2836" translate="yes" xml:space="preserve">
          <source>In addition to drawing opaque shapes to the canvas, we can also draw semi-transparent (or translucent) shapes. This is done by either setting the &lt;code&gt;globalAlpha&lt;/code&gt; property or by assigning a semi-transparent color to the stroke and/or fill style.</source>
          <target state="translated">캔버스에 불투명 한 모양을 그리는 것 외에도 반투명 (또는 반투명) 모양을 그릴 수도 있습니다. &lt;code&gt;globalAlpha&lt;/code&gt; 속성을 설정 하거나 반투명 색상을 획 및 / 또는 채우기 스타일에 할당하면됩니다.</target>
        </trans-unit>
        <trans-unit id="fd211c409f437601aaddd6ae22f663ba9462e483" translate="yes" xml:space="preserve">
          <source>In addition to listing each plugin as a pseudo-array by zero-indexed numeric properties, Firefox provides properties that are the plugin name directly on the &lt;a href=&quot;../pluginarray&quot;&gt;PluginArray&lt;/a&gt; object.</source>
          <target state="translated">Firefox는 인덱스가없는 숫자 속성으로 의사 배열로 각 플러그인을 나열하는 것 외에도 플러그인 이름 인 속성을 &lt;a href=&quot;../pluginarray&quot;&gt;PluginArray&lt;/a&gt; 객체 에 직접 제공 합니다.</target>
        </trans-unit>
        <trans-unit id="f48ba43945b2765441aa4000a7ca5686d0fbfef7" translate="yes" xml:space="preserve">
          <source>In addition to listing each plugin as a pseudo-array by zero-indexed numeric properties, Firefox provides properties that are the plugin name directly on the PluginArray object.</source>
          <target state="translated">Firefox는 인덱스가없는 숫자 속성으로 의사 배열로 각 플러그인을 나열하는 것 외에도 플러그인 이름 인 속성을 PluginArray 객체에 직접 제공합니다.</target>
        </trans-unit>
        <trans-unit id="782d6da4074fe0bad62b0b984bfe97ed5dd08cfe" translate="yes" xml:space="preserve">
          <source>In addition to multiplying a matrix and a point together, you can also multiply two matrices together. The function from above can be re-used to help out in this process:</source>
          <target state="translated">행렬과 점을 곱하는 것 외에도 두 행렬을 곱할 수도 있습니다. 이 과정에서 도움을주기 위해 위의 기능을 재사용 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a600d92586516eb0a554a16b05080875a144db3a" translate="yes" xml:space="preserve">
          <source>In addition to pausing and playing, we can use the following Animation methods:</source>
          <target state="translated">일시 정지 및 재생 외에도 다음과 같은 애니메이션 방법을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d940765c3ba878ab1b52a7410aa7947d98222158" translate="yes" xml:space="preserve">
          <source>In addition to the browser, the GPU itself also needs to support the feature. So, for example, S3 Texture Compression (S3TC) is only available on Tegra-based tablets. Most browsers make the WebGL context available through the &lt;code&gt;webgl&lt;/code&gt; context name, but older ones need &lt;code&gt;experimental-webgl&lt;/code&gt; as well. In addition, the upcoming &lt;a href=&quot;webgl2renderingcontext&quot;&gt;WebGL 2&lt;/a&gt; is fully backwards-compatible and will have the context name &lt;code&gt;webgl2&lt;/code&gt;.</source>
          <target state="translated">브라우저 외에도 GPU 자체도이 기능을 지원해야합니다. 예를 들어 S3TC (S3 Texture Compression)는 Tegra 기반 태블릿에서만 사용할 수 있습니다. 대부분의 브라우저는 &lt;code&gt;webgl&lt;/code&gt; 컨텍스트 이름을 통해 WebGL 컨텍스트를 사용 가능하게 하지만, 오래된 브라우저 에도 &lt;code&gt;experimental-webgl&lt;/code&gt; 필요 합니다. 또한 곧 출시 될 &lt;a href=&quot;webgl2renderingcontext&quot;&gt;WebGL 2&lt;/a&gt; 는 이전 버전과 완전히 호환되며 컨텍스트 이름은 &lt;code&gt;webgl2&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="e7c0bca569bcdcf4d36d4b291e994357e7f94b1d" translate="yes" xml:space="preserve">
          <source>In addition to the error codes sent to the &lt;a href=&quot;../idbrequest&quot;&gt;&lt;code&gt;IDBRequest&lt;/code&gt;&lt;/a&gt; object, asynchronous operations can also raise exceptions. The list describes problems that could occur when the request is being executed, but you might also encounter other problems when the request is being made. For example, if the the request failed and the result is not available, the InvalidStateError exception is thrown.</source>
          <target state="translated">&lt;a href=&quot;../idbrequest&quot;&gt; &lt;code&gt;IDBRequest&lt;/code&gt; &lt;/a&gt; 객체로 전송 된 오류 코드 외에도 비동기 작업에서도 예외가 발생할 수 있습니다. 이 목록은 요청이 실행될 때 발생할 수있는 문제를 설명하지만 요청이있을 때 다른 문제가 발생할 수도 있습니다. 예를 들어 요청이 실패하고 결과를 사용할 수없는 경우 InvalidStateError 예외가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="882c413e72831d5bc1dee0fdf814b5854a71d7a0" translate="yes" xml:space="preserve">
          <source>In addition to the information below, you'll find a how-to guide for using HTML data attributes in our article &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Learn/HTML/Howto/Use_data_attributes&quot;&gt;Using data attributes.&lt;/a&gt;</source>
          <target state="translated">아래 정보 외에도 데이터 속성 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Learn/HTML/Howto/Use_data_attributes&quot;&gt;사용&lt;/a&gt; 기사에서 HTML 데이터 속성 사용 방법을 찾을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="233fbcddd9dcfa28b52108b770af9293069945a2" translate="yes" xml:space="preserve">
          <source>In addition to the properties listed below, &lt;code&gt;MediaStreamTrack&lt;/code&gt; has constrainable properties which can be set using &lt;a href=&quot;mediastreamtrack/applyconstraints&quot;&gt;&lt;code&gt;applyConstraints()&lt;/code&gt;&lt;/a&gt; and accessed using &lt;a href=&quot;mediastreamtrack/getconstraints&quot;&gt;&lt;code&gt;getConstraints()&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;mediastreamtrack/getsettings&quot;&gt;&lt;code&gt;getSettings()&lt;/code&gt;&lt;/a&gt;. See &lt;a href=&quot;media_streams_api/constraints&quot;&gt;Capabilities, constraints, and settings&lt;/a&gt; to learn how to correctly work with constrainable properties. Not doing so correctly will result in your code being unreliable.</source>
          <target state="translated">아래에 나열된 속성 외에도 &lt;code&gt;MediaStreamTrack&lt;/code&gt; 에는 &lt;a href=&quot;mediastreamtrack/applyconstraints&quot;&gt; &lt;code&gt;applyConstraints()&lt;/code&gt; &lt;/a&gt; 사용하여 설정 하고 &lt;a href=&quot;mediastreamtrack/getconstraints&quot;&gt; &lt;code&gt;getConstraints()&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;mediastreamtrack/getsettings&quot;&gt; &lt;code&gt;getSettings()&lt;/code&gt; &lt;/a&gt; 사용하여 액세스 할 수있는 제한적인 속성이 있습니다 . 제한 속성을 올바르게 사용하는 방법을 알아 보려면 &lt;a href=&quot;media_streams_api/constraints&quot;&gt;기능, 제약 조건 및 설정&lt;/a&gt; 을 참조하십시오 . 그렇게하지 않으면 코드를 신뢰할 수 없게됩니다.</target>
        </trans-unit>
        <trans-unit id="0c4b8f48d1b6d7f0c658305bdeada4735d6fe982" translate="yes" xml:space="preserve">
          <source>In addition to the question of whether a push notification is required at all, there are many different types of push notifications, ranging from casual-and-disappearing to persistent-and-requiring-interaction.</source>
          <target state="translated">푸시 알림이 필요한지 여부에 대한 질문 외에도 일시적 및 사라지는 상호 작용에서 지속적인 상호 작용에 이르기까지 다양한 유형의 푸시 알림이 있습니다.</target>
        </trans-unit>
        <trans-unit id="f081db8429990736e892b80ccdf39802333dd9d0" translate="yes" xml:space="preserve">
          <source>In addition to the standard &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript&quot;&gt;JavaScript&lt;/a&gt; set of functions (such as &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String&quot;&gt;&lt;code&gt;String&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array&quot;&gt;&lt;code&gt;Array&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object&quot;&gt;&lt;code&gt;Object&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/JSON&quot;&gt;&lt;code&gt;JSON&lt;/code&gt;&lt;/a&gt;, etc), there are a variety of functions available from the DOM to workers. This article provides a list of those.</source>
          <target state="translated">표준 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript&quot;&gt;JavaScript&lt;/a&gt; 함수 세트 (예 : &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String&quot;&gt; &lt;code&gt;String&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array&quot;&gt; &lt;code&gt;Array&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object&quot;&gt; &lt;code&gt;Object&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/JSON&quot;&gt; &lt;code&gt;JSON&lt;/code&gt; &lt;/a&gt; 등) 외에도 DOM에서 작업자까지 다양한 함수를 사용할 수 있습니다. 이 기사는 그 목록을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="0f3ed1a80b6001a6fb2d886c2c885ab83a15818a" translate="yes" xml:space="preserve">
          <source>In addition to the three escape sequences mentioned above, there are fours others. They are listed in the table below.</source>
          <target state="translated">위에서 언급 한 세 가지 이스케이프 시퀀스 외에도 다른 네 가지 이스케이프 시퀀스가 ​​있습니다. 아래 표에 나와 있습니다.</target>
        </trans-unit>
        <trans-unit id="678332ae18c9181f699c2ef17c9aeef68ae8aed2" translate="yes" xml:space="preserve">
          <source>In addition to the three methods we saw in &lt;a href=&quot;#Drawing_rectangles&quot;&gt;Drawing rectangles&lt;/a&gt;, which draw rectangular shapes directly to the canvas, there's also the &lt;code&gt;rect()&lt;/code&gt; method, which adds a rectangular path to a currently open path.</source>
          <target state="translated">캔버스에 직접 직사각형 모양을 그리는 직사각형 &lt;a href=&quot;#Drawing_rectangles&quot;&gt;그리기&lt;/a&gt; 에서 보았던 세 가지 방법 외에도 현재 열린 경로에 직사각형 경로를 추가하는 &lt;code&gt;rect()&lt;/code&gt; 메서드 도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="af71e733a0e3aa7d70fda75c37b4fe99759ebe63" translate="yes" xml:space="preserve">
          <source>In addition, WebVR 1.1 adds a number of events on the &lt;a href=&quot;window&quot;&gt;&lt;code&gt;Window&lt;/code&gt;&lt;/a&gt; object to allow JavaScript to respond to changes to the status of the display.</source>
          <target state="translated">또한 WebVR 1.1은 &lt;a href=&quot;window&quot;&gt; &lt;code&gt;Window&lt;/code&gt; &lt;/a&gt; 객체 에 많은 이벤트를 추가하여 JavaScript가 디스플레이 상태 변경에 응답 할 수 있도록합니다.</target>
        </trans-unit>
        <trans-unit id="9d74eecff8ea822d543cc16c23a0996c92866252" translate="yes" xml:space="preserve">
          <source>In addition, be aware that browsers can wipe out the database, such as in the following conditions:</source>
          <target state="translated">또한 브라우저는 다음과 같은 상황에서 데이터베이스를 지울 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9499549a09c42498f7ba40d50ef0a781d603f324" translate="yes" xml:space="preserve">
          <source>In addition, if something happens to cause a change in the streaming scenario, negotiation will begin again, with the &lt;code&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Events/negotiationneeded&quot;&gt;negotiationneeded&lt;/a&gt;&lt;/code&gt; event being sent to the &lt;a href=&quot;../rtcpeerconnection&quot;&gt;&lt;code&gt;RTCPeerConnection&lt;/code&gt;&lt;/a&gt;, and the entire process starts again as described before. This can happen in a variety of situations, including:</source>
          <target state="translated">또한 스트리밍 시나리오에서 무언가 변경이 발생하면 협상이 다시 시작 되고 &lt;code&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Events/negotiationneeded&quot;&gt;negotiationneeded&lt;/a&gt;&lt;/code&gt; 이벤트가 &lt;a href=&quot;../rtcpeerconnection&quot;&gt; &lt;code&gt;RTCPeerConnection&lt;/code&gt; &lt;/a&gt; 으로 전송되고 앞에서 설명한대로 전체 프로세스가 다시 시작됩니다. 다음과 같은 다양한 상황에서 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8b2d67e3af1cab52f24fd5c28ee15c8851650c06" translate="yes" xml:space="preserve">
          <source>In addition, navigating to another page, changing tabs, or switching to another application (using, for example,</source>
          <target state="translated">또한 다른 페이지로 이동하거나 탭을 변경하거나 다른 응용 프로그램으로 전환 (예 :</target>
        </trans-unit>
        <trans-unit id="26511fef9e5a7866b7fae637d4ad155c717ea4dd" translate="yes" xml:space="preserve">
          <source>In addition, sandboxed &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/iframe&quot;&gt;&lt;code&gt;&amp;lt;iframe&amp;gt;&lt;/code&gt;&lt;/a&gt;s cannot be granted storage access by default for security reasons. The API therefore also adds the &lt;code&gt;allow-storage-access-by-user-activation&lt;/code&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/iframe#attr-sandbox&quot;&gt;sandbox token&lt;/a&gt;. The embedding website needs to add this to allow storage access requests to be successful, along with &lt;code&gt;allow-scripts&lt;/code&gt; and &lt;code&gt;allow-same-origin&lt;/code&gt; to allow it to call the API, and execute in an origin that can have cookies:</source>
          <target state="translated">또한 보안상의 이유로 샌드 박스 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/iframe&quot;&gt; &lt;code&gt;&amp;lt;iframe&amp;gt;&lt;/code&gt; &lt;/a&gt; 에 기본적으로 스토리지 액세스 권한을 부여 할 수 없습니다. 따라서 API는 또한 &lt;code&gt;allow-storage-access-by-user-activation&lt;/code&gt; &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/iframe#attr-sandbox&quot;&gt;샌드 박스 토큰을 추가&lt;/a&gt; 합니다. 내장 웹 사이트는이를 저장하여 &lt;code&gt;allow-scripts&lt;/code&gt; 및 &lt;code&gt;allow-same-origin&lt;/code&gt; 과 함께 저장소 액세스 요청이 성공 하여 API를 호출하고 쿠키를 가질 수있는 원본에서 실행할 수 있도록해야합니다.</target>
        </trans-unit>
        <trans-unit id="ba2bccf95e98011193a03e5cd50f8e95faed75cc" translate="yes" xml:space="preserve">
          <source>In addition, starting in Firefox 55, if in &lt;code&gt;supportedConfigurations&lt;/code&gt;, either &lt;code&gt;audioCapabilities&lt;/code&gt;'s or &lt;code&gt;videoCapabilities&lt;/code&gt;'s &lt;code&gt;contentType&lt;/code&gt; value doesn't specify a &quot;codecs&quot; substring to define allowed codecs within the media wrapper, a warning is output to the web console. See note below table for example and correction.</source>
          <target state="translated">또한 Firefox 55부터, &lt;code&gt;supportedConfigurations&lt;/code&gt; 에서 &lt;code&gt;audioCapabilities&lt;/code&gt; 또는 &lt;code&gt;videoCapabilities&lt;/code&gt; 의 &lt;code&gt;contentType&lt;/code&gt; 값이 미디어 랩퍼 내에서 허용 된 코덱을 정의하기 위해 &quot;codecs&quot;하위 문자열을 지정하지 않으면 경고가 웹 콘솔에 출력됩니다. 예와 수정에 대해서는 아래 표를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="ccd8b6852eb05e8e477b5291fe3d4b95397e235e" translate="yes" xml:space="preserve">
          <source>In addition, the &lt;a href=&quot;mediastreamtrack&quot;&gt;&lt;code&gt;MediaStreamTrack&lt;/code&gt;&lt;/a&gt; specified by the receiver's &lt;a href=&quot;rtcrtpreceiver/track&quot;&gt;&lt;code&gt;track&lt;/code&gt;&lt;/a&gt; is the same one specified by the event's &lt;a href=&quot;rtctrackevent/track&quot;&gt;&lt;code&gt;track&lt;/code&gt;&lt;/a&gt;, and the track has been added to any associated remote &lt;a href=&quot;mediastream&quot;&gt;&lt;code&gt;MediaStream&lt;/code&gt;&lt;/a&gt; objects.</source>
          <target state="translated">또한 수신자의 &lt;a href=&quot;rtcrtpreceiver/track&quot;&gt; &lt;code&gt;track&lt;/code&gt; &lt;/a&gt; 의해 지정된 &lt;a href=&quot;mediastreamtrack&quot;&gt; &lt;code&gt;MediaStreamTrack&lt;/code&gt; &lt;/a&gt; 은 이벤트의 &lt;a href=&quot;rtctrackevent/track&quot;&gt; &lt;code&gt;track&lt;/code&gt; 에&lt;/a&gt; 의해 지정된 것과 동일 하며, 트랙은 연관된 원격 &lt;a href=&quot;mediastream&quot;&gt; &lt;code&gt;MediaStream&lt;/code&gt; &lt;/a&gt; 객체 에 추가되었습니다 .</target>
        </trans-unit>
        <trans-unit id="d4de5259e1444c83b1b5c70cb8a7ac4931bb3793" translate="yes" xml:space="preserve">
          <source>In addition, the Notifications API spec specifies a number of additions to the &lt;a href=&quot;service_worker_api&quot;&gt;ServiceWorker API&lt;/a&gt;, to allow service workers to fire notifications.</source>
          <target state="translated">또한 알림 API 스펙 은 서비스 워커가 알림을 실행할 수 있도록 &lt;a href=&quot;service_worker_api&quot;&gt;ServiceWorker API에&lt;/a&gt; 여러 가지 추가 사항을 지정합니다 .</target>
        </trans-unit>
        <trans-unit id="192681702116a96e9a96fed67ac3d7964193e0ca" translate="yes" xml:space="preserve">
          <source>In addition, the event's &lt;a href=&quot;../event/preventdefault&quot;&gt;&lt;code&gt;preventDefault()&lt;/code&gt;&lt;/a&gt; method is called to ensure that the &lt;code&gt;mouseup&lt;/code&gt; event isn't triggered unnecessarily.</source>
          <target state="translated">또한 이벤트의 &lt;a href=&quot;../event/preventdefault&quot;&gt; &lt;code&gt;preventDefault()&lt;/code&gt; &lt;/a&gt; 메서드가 호출되어 &lt;code&gt;mouseup&lt;/code&gt; 이벤트가 불필요하게 트리거되지 않도록합니다.</target>
        </trans-unit>
        <trans-unit id="2dc07687c787d20adb5f45f4b3b1ade1ef95614e" translate="yes" xml:space="preserve">
          <source>In addition, this flag is also used to indicate when cookies are to be ignored in the response. The default is &lt;code&gt;false&lt;/code&gt;. &lt;code&gt;XMLHttpRequest&lt;/code&gt; from a different domain cannot set cookie values for their own domain unless &lt;code&gt;withCredentials&lt;/code&gt; is set to &lt;code&gt;true&lt;/code&gt; before making the request. The third-party cookies obtained by setting &lt;code&gt;withCredentials&lt;/code&gt; to true will still honor same-origin policy and hence can not be accessed by the requesting script through &lt;a href=&quot;../document/cookie&quot;&gt;document.cookie&lt;/a&gt; or from response headers.</source>
          <target state="translated">또한이 플래그는 응답에서 쿠키를 무시할시기를 나타내는 데에도 사용됩니다. 기본값은 &lt;code&gt;false&lt;/code&gt; 입니다. 요청하기 전에 &lt;code&gt;withCredentials&lt;/code&gt; 가 &lt;code&gt;true&lt;/code&gt; 로 설정되어 있지 않으면 다른 도메인의 &lt;code&gt;XMLHttpRequest&lt;/code&gt; 가 자신의 도메인에 쿠키 값을 설정할 수 없습니다 . &lt;code&gt;withCredentials&lt;/code&gt; 를 true 로 설정하여 얻은 타사 쿠키 는 여전히 동일한 원본 정책을 따르 므로 요청 스크립트는 &lt;a href=&quot;../document/cookie&quot;&gt;document.cookie를&lt;/a&gt; 통해 또는 응답 헤더에서 액세스 할 수 없습니다 .</target>
        </trans-unit>
        <trans-unit id="790da41e2793ac0df68ea96f6bdad9a107400fab" translate="yes" xml:space="preserve">
          <source>In addition, we also use a &lt;code&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Events/click&quot;&gt;click&lt;/a&gt;&lt;/code&gt; event to make the box dissappear (&lt;code&gt;display: none;&lt;/code&gt;), showing how it triggers the &lt;code&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Events/transitioncancel&quot;&gt;transitioncancel&lt;/a&gt;&lt;/code&gt; event to fire.</source>
          <target state="translated">또한 &lt;code&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Events/click&quot;&gt;click&lt;/a&gt;&lt;/code&gt; 이벤트를 사용하여 상자가 사라지도록 &lt;code&gt;display: none;&lt;/code&gt; ( display : none; )하여 &lt;code&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Events/transitioncancel&quot;&gt;transitioncancel&lt;/a&gt;&lt;/code&gt; 이벤트가 실행되도록하는 방법을 보여줍니다 .</target>
        </trans-unit>
        <trans-unit id="5d5975aa89342b92cf68e8671b3386929a9b70c1" translate="yes" xml:space="preserve">
          <source>In addition, we have provided an &lt;a href=&quot;https://mdn.github.io/dom-examples/web-storage/event.html&quot;&gt;event output page&lt;/a&gt; &amp;mdash; if you load this page in another tab, then make changes to your choices in the landing page, you'll see the updated storage information outputted as the &lt;a href=&quot;storageevent&quot;&gt;&lt;code&gt;StorageEvent&lt;/code&gt;&lt;/a&gt; is fired.</source>
          <target state="translated">또한 &lt;a href=&quot;https://mdn.github.io/dom-examples/web-storage/event.html&quot;&gt;이벤트 출력 페이지를&lt;/a&gt; 제공했습니다. 이 페이지를 다른 탭에로드 한 다음 랜딩 페이지에서 선택을 변경하면 &lt;a href=&quot;storageevent&quot;&gt; &lt;code&gt;StorageEvent&lt;/code&gt; &lt;/a&gt; 가 시작될 때 업데이트 된 스토리지 정보가 출력되는 것을 볼 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="bba2f2d42746dc7113697241e1f8d8e36ba979e2" translate="yes" xml:space="preserve">
          <source>In addition, when the value of this property changes, a &lt;code&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Events/signalingstatechange&quot;&gt;signalingstatechange&lt;/a&gt;&lt;/code&gt; event is sent to the &lt;a href=&quot;../rtcpeerconnection&quot;&gt;&lt;code&gt;RTCPeerConnection&lt;/code&gt;&lt;/a&gt; instance.</source>
          <target state="translated">또한이 속성 값이 변경되면 &lt;code&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Events/signalingstatechange&quot;&gt;signalingstatechange&lt;/a&gt;&lt;/code&gt; 이벤트가 &lt;a href=&quot;../rtcpeerconnection&quot;&gt; &lt;code&gt;RTCPeerConnection&lt;/code&gt; &lt;/a&gt; 인스턴스로 전송됩니다 .</target>
        </trans-unit>
        <trans-unit id="64fad7fc10a00a22577d47c690afbf37af4d73ca" translate="yes" xml:space="preserve">
          <source>In addition, when we are done reading the fetch body we use the controller&amp;rsquo;s &lt;a href=&quot;../readablestreamdefaultcontroller/close&quot;&gt;&lt;code&gt;close()&lt;/code&gt;&lt;/a&gt; method to close the custom stream &amp;mdash; any previously-enqueued chunks can still be read from it, but no more can be enqueued, and the stream is closed when reading has finished.</source>
          <target state="translated">또한 페치 본문을 다 읽은 후에는 컨트롤러의 &lt;a href=&quot;../readablestreamdefaultcontroller/close&quot;&gt; &lt;code&gt;close()&lt;/code&gt; &lt;/a&gt; 메서드를 사용하여 사용자 지정 스트림을 닫습니다. 이전에 대기열에 넣은 청크는 여전히 읽을 수 있지만 더 이상 대기열에 넣을 수 없으며 스트림은 닫힐 때 닫힙니다. 독서가 끝났습니다.</target>
        </trans-unit>
        <trans-unit id="bf4cd7fcf0bf392583caf71224b2b73e97fd76f4" translate="yes" xml:space="preserve">
          <source>In additions to these specifications defining the API needed to use WebRTC, there are several protocols, listed under &lt;a href=&quot;#Protocols&quot;&gt;resources&lt;/a&gt;.</source>
          <target state="translated">WebRTC를 사용하는 데 필요한 API를 정의하는 이러한 사양 외에도 &lt;a href=&quot;#Protocols&quot;&gt;resources&lt;/a&gt; 아래에 몇 가지 프로토콜이 나열되어 있습니다 .</target>
        </trans-unit>
        <trans-unit id="eb91ee7606d2ee858eee8b96f42a6b48650c73fe" translate="yes" xml:space="preserve">
          <source>In all of our &lt;a href=&quot;transformations&quot;&gt;previous examples&lt;/a&gt;, shapes were always drawn one on top of the other. This is more than adequate for most situations, but it limits the order in which composite shapes are built. We can, however, change this behaviour by setting the &lt;code&gt;globalCompositeOperation&lt;/code&gt; property. In addition, the &lt;code&gt;clip&lt;/code&gt; property allows us to hide unwanted parts of shapes.</source>
          <target state="translated">&lt;a href=&quot;transformations&quot;&gt;이전의&lt;/a&gt; 모든 예제 에서 셰이프는 항상 하나의 맨 위에 그려졌습니다. 이것은 대부분의 상황에 적합하지만 복합 셰이프 작성 순서를 제한합니다. 그러나 &lt;code&gt;globalCompositeOperation&lt;/code&gt; 속성 을 설정하여이 동작을 변경할 수 있습니다 . 또한 &lt;code&gt;clip&lt;/code&gt; 속성을 사용하면 원하지 않는 모양 부분을 숨길 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6c6cfb20e3f5887abf169ebc8c75f1f9163d27c3" translate="yes" xml:space="preserve">
          <source>In all other cases, the time origin is undefined.</source>
          <target state="translated">다른 모든 경우에는 시간 원점이 정의되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="63651a9ada3befbb58fb6ad76a610a406eb9666d" translate="yes" xml:space="preserve">
          <source>In an &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML&quot;&gt;HTML&lt;/a&gt; document, the &lt;code&gt;document.createElement()&lt;/code&gt; method creates the HTML element specified by &lt;var&gt;tagName&lt;/var&gt;, or an &lt;a href=&quot;../htmlunknownelement&quot;&gt;&lt;code&gt;HTMLUnknownElement&lt;/code&gt;&lt;/a&gt; if &lt;var&gt;tagName&lt;/var&gt; isn't recognized.</source>
          <target state="translated">에는 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML&quot;&gt;HTML의&lt;/a&gt; 문서의 &lt;code&gt;document.createElement()&lt;/code&gt; 메소드에 의해 지정된 HTML 요소 생성 &lt;var&gt;tagName&lt;/var&gt; 또는 &lt;a href=&quot;../htmlunknownelement&quot;&gt; &lt;code&gt;HTMLUnknownElement&lt;/code&gt; 을&lt;/a&gt; 경우 &lt;var&gt;tagName&lt;/var&gt; 인식되지 않는다.</target>
        </trans-unit>
        <trans-unit id="a8baddc945b3c8f1d6c4b84704583e8f4f1af1a8" translate="yes" xml:space="preserve">
          <source>In another example, the &lt;a href=&quot;http://codepen.io/rachelnabors/pen/PNGGaV?editors=0010&quot;&gt;Red Queen's Race Game&lt;/a&gt;, Alice and the Red Queen are constantly slowing down:</source>
          <target state="translated">다른 예에서, &lt;a href=&quot;http://codepen.io/rachelnabors/pen/PNGGaV?editors=0010&quot;&gt;Red Queen 's Race Game&lt;/a&gt; , Alice 및 Red Queen은 지속적으로 느려지고 있습니다.</target>
        </trans-unit>
        <trans-unit id="04738823885b22029c34853da22a463fe296be8b" translate="yes" xml:space="preserve">
          <source>In audio terms, &lt;strong&gt;fan-in&lt;/strong&gt; describes the process by which a &lt;a href=&quot;../channelmergernode&quot;&gt;&lt;code&gt;ChannelMergerNode&lt;/code&gt;&lt;/a&gt; takes a series of mono input sources and outputs a single multi-channel signal:</source>
          <target state="translated">오디오 용어로 &lt;strong&gt;팬인&lt;/strong&gt; 은 &lt;a href=&quot;../channelmergernode&quot;&gt; &lt;code&gt;ChannelMergerNode&lt;/code&gt; &lt;/a&gt; 가 일련의 모노 입력 소스를 가져 와서 단일 멀티 채널 신호를 출력하는 프로세스 &lt;strong&gt;를&lt;/strong&gt; 설명합니다 .</target>
        </trans-unit>
        <trans-unit id="ab6c113a7cdaf32fdba0c8620de88add3b4495c1" translate="yes" xml:space="preserve">
          <source>In both cases, Chome may require an extra movie flag to be set:</source>
          <target state="translated">두 경우 모두 Chome에서 추가 영화 플래그를 설정해야 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="58c91886a2fd338c14ee30ef8e10aa1c23539465" translate="yes" xml:space="preserve">
          <source>In browsers that support it, an instance of this interface may be passed in the &lt;code&gt;credential&lt;/code&gt; member of the &lt;code&gt;init&lt;/code&gt; object for global &lt;a href=&quot;windoworworkerglobalscope/fetch&quot;&gt;&lt;code&gt;fetch&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이를 지원하는 브라우저에서이 인터페이스의 인스턴스는 전역 &lt;a href=&quot;windoworworkerglobalscope/fetch&quot;&gt; &lt;code&gt;fetch&lt;/code&gt; &lt;/a&gt; 위해 &lt;code&gt;init&lt;/code&gt; 오브젝트 의 &lt;code&gt;credential&lt;/code&gt; 멤버 로 전달 될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="91e518b14b157d9075471688f123070fcb6f5b67" translate="yes" xml:space="preserve">
          <source>In browsers, &lt;code&gt;document.defaultView&lt;/code&gt; returns the &lt;a href=&quot;../window&quot;&gt;&lt;code&gt;window&lt;/code&gt;&lt;/a&gt; object associated with &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/Browsing_context&quot;&gt;a document&lt;/a&gt;, or &lt;code&gt;null&lt;/code&gt; if none is available.</source>
          <target state="translated">브라우저에서 &lt;code&gt;document.defaultView&lt;/code&gt; 는 수익 &lt;a href=&quot;../window&quot;&gt; &lt;code&gt;window&lt;/code&gt; &lt;/a&gt; 에 관련된 객체 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/Browsing_context&quot;&gt;문서&lt;/a&gt; , 또는 &lt;code&gt;null&lt;/code&gt; 을 사용할 수없는 경우는 있습니다.</target>
        </trans-unit>
        <trans-unit id="ad663c9a1751b872c09fac79cfcdf47046fa8ddc" translate="yes" xml:space="preserve">
          <source>In case of an error, the returned &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise&quot;&gt;&lt;code&gt;Promise&lt;/code&gt;&lt;/a&gt; is rejected with a &lt;a href=&quot;../domexception&quot;&gt;&lt;code&gt;DOMException&lt;/code&gt;&lt;/a&gt; whose name indicates what kind of error occurred.</source>
          <target state="translated">오류가 발생한 경우 반환 된 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise&quot;&gt; &lt;code&gt;Promise&lt;/code&gt; &lt;/a&gt; 는 이름이 발생한 오류를 나타내는 &lt;a href=&quot;../domexception&quot;&gt; &lt;code&gt;DOMException&lt;/code&gt; &lt;/a&gt; 과 함께 거부됩니다 .</target>
        </trans-unit>
        <trans-unit id="332213d33ce20840de5b4f1d7cb167be4547a2ee" translate="yes" xml:space="preserve">
          <source>In case you want to test your code in browsers that still use a prefix, you can use the following code:</source>
          <target state="translated">여전히 접두사를 사용하는 브라우저에서 코드를 테스트하려는 경우 다음 코드를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8d868186a76d05ac9a59dd6893aba220173fa221" translate="yes" xml:space="preserve">
          <source>In cases where &lt;code&gt;left&lt;/code&gt; and &lt;code&gt;screenX&lt;/code&gt; (and/or &lt;code&gt;top&lt;/code&gt; and &lt;code&gt;screenY&lt;/code&gt;) have conflicting values, then &lt;code&gt;left&lt;/code&gt; and &lt;code&gt;top&lt;/code&gt; have precedence over &lt;code&gt;screenX&lt;/code&gt; and &lt;code&gt;screenY&lt;/code&gt; respectively. If &lt;code&gt;left&lt;/code&gt; and &lt;code&gt;screenX&lt;/code&gt; (and/or &lt;code&gt;top&lt;/code&gt; and &lt;code&gt;screenY&lt;/code&gt;) are defined in the &lt;var&gt;features&lt;/var&gt; list, then &lt;code&gt;left&lt;/code&gt; (and/or &lt;code&gt;top&lt;/code&gt;) will be honored and rendered. In the following example the new window will be positioned at 100 pixels from the left side of the work area for applications of the user's operating system, not at 200 pixels.</source>
          <target state="translated">경우 &lt;code&gt;left&lt;/code&gt; 과 &lt;code&gt;screenX&lt;/code&gt; 는 (및 / 또는 &lt;code&gt;top&lt;/code&gt; 및 &lt;code&gt;screenY&lt;/code&gt; ) 값을 충돌 한 후, &lt;code&gt;left&lt;/code&gt; 및 &lt;code&gt;top&lt;/code&gt; 보다 우선 순위가 &lt;code&gt;screenX&lt;/code&gt; 및 &lt;code&gt;screenY&lt;/code&gt; 를 각각. 경우 &lt;code&gt;left&lt;/code&gt; 과 &lt;code&gt;screenX&lt;/code&gt; 는 (그리고 / 또는 &lt;code&gt;top&lt;/code&gt; 및 &lt;code&gt;screenY&lt;/code&gt; (가)에서) 정의 된 &lt;var&gt;features&lt;/var&gt; 목록을 다음 &lt;code&gt;left&lt;/code&gt; (및 / 또는 &lt;code&gt;top&lt;/code&gt; )이 존중되고 렌더링됩니다. 다음 예제에서 새 창은 작업 영역의 왼쪽에서 200 픽셀이 아닌 사용자 운영 체제의 응용 프로그램에서 100 픽셀에 배치됩니다.</target>
        </trans-unit>
        <trans-unit id="43a8719df0a15822a3784cb80af083c474ccf59d" translate="yes" xml:space="preserve">
          <source>In chrome or other privileged code, you may also use the &lt;code&gt;image/jpeg&lt;/code&gt;, &lt;code&gt;image/png&lt;/code&gt; or &lt;code&gt;image/gif&lt;/code&gt; types, depending on the type of image. The data should be an object which implements the &lt;a href=&quot;https://developer.mozilla.org/en/XPCOM_Interface_Reference/nsIInputStream&quot;&gt;nsIInputStream&lt;/a&gt; interface. When this stream is read, it should provide the data bits for the image, as if the image was a file of that type.</source>
          <target state="translated">크롬 또는 기타 권한있는 코드에서는 &lt;code&gt;image/gif&lt;/code&gt; 유형에 따라 &lt;code&gt;image/jpeg&lt;/code&gt; , &lt;code&gt;image/png&lt;/code&gt; 또는 image / gif 유형을 사용할 수도 있습니다 . 데이터는 &lt;a href=&quot;https://developer.mozilla.org/en/XPCOM_Interface_Reference/nsIInputStream&quot;&gt;nsIInputStream&lt;/a&gt; 인터페이스 를 구현하는 객체 여야합니다 . 이 스트림을 읽을 때는 이미지가 해당 유형의 파일 인 것처럼 이미지의 데이터 비트를 제공해야합니다.</target>
        </trans-unit>
        <trans-unit id="d0e0032ad462e2d9566b70bb733535ef934719d2" translate="yes" xml:space="preserve">
          <source>In compliance with the specification, this property will return &lt;code&gt;null&lt;/code&gt; on Webkit if the element is hidden (the &lt;code&gt;style.display&lt;/code&gt; of this element or any ancestor is &lt;code&gt;&quot;none&quot;&lt;/code&gt;) or if the &lt;code&gt;style.position&lt;/code&gt; of the element itself is set to &lt;code&gt;&quot;fixed&quot;&lt;/code&gt;.</source>
          <target state="translated">규격 준수,이 속성은 반환 &lt;code&gt;null&lt;/code&gt; 요소가 숨겨져합니다 (경우 웹킷에 &lt;code&gt;style.display&lt;/code&gt; 를 이 요소의 또는 조상이 없다 &lt;code&gt;&quot;none&quot;&lt;/code&gt; ) 또는 경우 &lt;code&gt;style.position&lt;/code&gt; 요소의 자체로 설정 &lt;code&gt;&quot;fixed&quot;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="bdd25fb0b064dfd36be3bc05f334a139df064254" translate="yes" xml:space="preserve">
          <source>In context uses</source>
          <target state="translated">맥락에서 사용</target>
        </trans-unit>
        <trans-unit id="68c365ee48d8646bb3f03aa1bb71a33610b7ee92" translate="yes" xml:space="preserve">
          <source>In contrast to MSIE--in which almost all kinds of elements receive the blur event--almost all kinds of elements on Gecko browsers do NOT work with this event.</source>
          <target state="translated">거의 모든 종류의 요소가 흐림 이벤트를 수신하는 MSIE와 달리 Gecko 브라우저의 거의 모든 종류의 요소는이 이벤트에서 작동하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="43f92fc056487532ce0b5e81f8f19a8aefa82472" translate="yes" xml:space="preserve">
          <source>In contrast, no such assignment is done for the second canvas. The internal &lt;a href=&quot;htmlcanvaselement/width&quot;&gt;&lt;code&gt;width&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;htmlcanvaselement/height&quot;&gt;&lt;code&gt;height&lt;/code&gt;&lt;/a&gt; properties of the canvas remain at default values, which are different than the actual size of the canvas &lt;a href=&quot;element&quot;&gt;&lt;code&gt;Element&lt;/code&gt;&lt;/a&gt; in the browser window.</source>
          <target state="translated">반대로, 두 번째 캔버스에는 이러한 할당이 수행되지 않습니다. 캔버스 의 내부 &lt;a href=&quot;htmlcanvaselement/width&quot;&gt; &lt;code&gt;width&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;htmlcanvaselement/height&quot;&gt; &lt;code&gt;height&lt;/code&gt; &lt;/a&gt; 특성은 기본값으로 유지되며 이는 브라우저 창의 캔버스 &lt;a href=&quot;element&quot;&gt; &lt;code&gt;Element&lt;/code&gt; &lt;/a&gt; 의 실제 크기와 다릅니다 .</target>
        </trans-unit>
        <trans-unit id="71162c2fddbc1881896b5ade2388c4f044610200" translate="yes" xml:space="preserve">
          <source>In controlling browsing context, the &lt;a href=&quot;https://www.w3.org/TR/presentation-api/#dfn-presentation&quot;&gt;&lt;code&gt;Presentation&lt;/code&gt;&lt;/a&gt; interface provides a mechanism to override the browser default behavior of launching presentation to external screen. In receiving browsing context, &lt;code&gt;Presentation&lt;/code&gt; interface provides the access to the available presentation connections.</source>
          <target state="translated">브라우징 컨텍스트를 제어 할 때 &lt;a href=&quot;https://www.w3.org/TR/presentation-api/#dfn-presentation&quot;&gt; &lt;code&gt;Presentation&lt;/code&gt; &lt;/a&gt; 인터페이스는 프레젠테이션을 시작하는 브라우저 기본 동작을 외부 화면으로 재정의하는 메커니즘을 제공합니다. 탐색 컨텍스트를 수신 할 때 &lt;code&gt;Presentation&lt;/code&gt; 인터페이스는 사용 가능한 프리젠 테이션 연결에 대한 액세스를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="5130a730796e56550ce8a9896c1e4855e4f3091a" translate="yes" xml:space="preserve">
          <source>In controlling browsing context, the &lt;code&gt;Presentation&lt;/code&gt; interface provides a mechanism to override the browser default behavior of launching presentation to external screen. In receiving browsing context, &lt;code&gt;Presentation&lt;/code&gt; interface provides the access to the available presentation connections.</source>
          <target state="translated">브라우징 컨텍스트를 제어 할 때 &lt;code&gt;Presentation&lt;/code&gt; 인터페이스는 프레젠테이션을 시작하는 브라우저 기본 동작을 외부 화면으로 재정의하는 메커니즘을 제공합니다. 탐색 컨텍스트를 수신 할 때 &lt;code&gt;Presentation&lt;/code&gt; 인터페이스는 사용 가능한 프리젠 테이션 연결에 대한 액세스를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="1647190f46d845c8c2017ff5878c95c1e3cbd98b" translate="yes" xml:space="preserve">
          <source>In dedicated workers created from a &lt;a href=&quot;../window&quot;&gt;&lt;code&gt;Window&lt;/code&gt;&lt;/a&gt; context, the value in the worker will be lower than &lt;code&gt;performance.now()&lt;/code&gt; in the window who spawned that worker. It used to be the same as &lt;code&gt;t0&lt;/code&gt; of the main context, but this was changed.</source>
          <target state="translated">&lt;a href=&quot;../window&quot;&gt; &lt;code&gt;Window&lt;/code&gt; &lt;/a&gt; 컨텍스트 에서 생성 된 전용 워커 에서 워커의 값은 해당 워커 를 생성 한 윈도우의 &lt;code&gt;performance.now()&lt;/code&gt; 보다 낮습니다 . 예전 에는 기본 컨텍스트의 &lt;code&gt;t0&lt;/code&gt; 과 동일 했지만 변경되었습니다.</target>
        </trans-unit>
        <trans-unit id="253e146cf2742f3d49fb43e195f4db85ed087d6d" translate="yes" xml:space="preserve">
          <source>In earlier browser versions, trying to load a cross-origin worker script threw a &lt;code&gt;SecurityError&lt;/code&gt;; in newer browsers an &lt;code&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Events/error&quot;&gt;error&lt;/a&gt;&lt;/code&gt; event is thrown instead due to a spec change. Find out more information on how to deal with this in &lt;a href=&quot;https://www.fxsitecompat.com/en-CA/docs/2016/loading-cross-origin-worker-now-fires-error-event-instead-of-throwing-worker-in-sandboxed-iframe-no-longer-allowed/&quot;&gt;Loading cross-origin worker now fires error event instead of throwing; worker in sandboxed iframe no longer allowed&lt;/a&gt;.</source>
          <target state="translated">이전 버전의 브라우저에서 출처 간 작업자 스크립트를로드하려고하면 &lt;code&gt;SecurityError&lt;/code&gt; 가 발생했습니다 . 최신 브라우저에서는 사양 변경으로 인해 &lt;code&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Events/error&quot;&gt;error&lt;/a&gt;&lt;/code&gt; 이벤트가 발생합니다. 이 문제를 처리하는 방법에 대한 자세한 내용은 &lt;a href=&quot;https://www.fxsitecompat.com/en-CA/docs/2016/loading-cross-origin-worker-now-fires-error-event-instead-of-throwing-worker-in-sandboxed-iframe-no-longer-allowed/&quot;&gt;이제 원본이 아닌 작업자가 던지기 대신 오류 이벤트를 발생시킵니다. 샌드 박스 iframe의 작업자는 더 이상 허용되지 않습니다&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="0d14b3fc64a95cf72ed7eb5fe2b2538f6baa9b4c" translate="yes" xml:space="preserve">
          <source>In early versions of the WebRTC specification, this property's name was &lt;a href=&quot;stream&quot;&gt;&lt;code&gt;stream&lt;/code&gt;&lt;/a&gt;. Code that uses that property needs to be updated.</source>
          <target state="translated">WebRTC 스펙의 초기 버전에서이 특성의 이름은 &lt;a href=&quot;stream&quot;&gt; &lt;code&gt;stream&lt;/code&gt; &lt;/a&gt; 입니다. 해당 속성을 사용하는 코드를 업데이트해야합니다.</target>
        </trans-unit>
        <trans-unit id="7c3fccc5485350bc49eea58546866f393b52d76b" translate="yes" xml:space="preserve">
          <source>In environments that do not support interactivity (e.g., print media), then redraw shall not be suspended. Calls to &lt;code&gt;suspendRedraw()&lt;/code&gt; and &lt;code&gt;unsuspendRedraw()&lt;/code&gt; should, but need not be, made in balanced pairs.</source>
          <target state="translated">대화 형 기능을 지원하지 않는 환경 (예 : 인쇄 매체)에서는 다시 그리기가 일시 중단되지 않습니다. 를 호출 &lt;code&gt;suspendRedraw()&lt;/code&gt; 와 &lt;code&gt;unsuspendRedraw()&lt;/code&gt; 하지만, 필요 평형 쌍에서 만든해서는 안됩니다.</target>
        </trans-unit>
        <trans-unit id="2a6cd54c5597275fc395347727fc08e1aa760741" translate="yes" xml:space="preserve">
          <source>In exactly the same way as our &lt;a href=&quot;https://github.com/mdn/webvr-tests/tree/master/raw-webgl-example&quot;&gt;raw-webgl-example&lt;/a&gt; (see &lt;a href=&quot;using_the_webvr_api&quot;&gt;Using the WebVR API&lt;/a&gt; for details), this renders a spinning 3D cube, which you can choose to present in a VR display. The only difference is that, while in VR presenting mode, this demo allows you to move the cube by moving a VR controller (the original demo moves the cube as you move your VR headset).</source>
          <target state="translated">&lt;a href=&quot;https://github.com/mdn/webvr-tests/tree/master/raw-webgl-example&quot;&gt;raw-webgl-example&lt;/a&gt; (자세한 내용 &lt;a href=&quot;using_the_webvr_api&quot;&gt;은 WebVR API 사용&lt;/a&gt; 참조) 과 정확히 같은 방식으로 회전하는 3D 큐브를 렌더링하여 VR 디스플레이에 표시하도록 선택할 수 있습니다. 유일한 차이점은 VR 프리젠 테이션 모드에서이 데모를 사용하면 VR 컨트롤러를 움직여 큐브를 이동할 수 있습니다 (원래 데모는 VR 헤드셋을 움직일 때 큐브를 이동 함).</target>
        </trans-unit>
        <trans-unit id="6f457eaea055d30ab127ce4d0e8b0c9573945bff" translate="yes" xml:space="preserve">
          <source>In fact, there is no way to guarantee that IndexedDB transactions will complete, even with normal browser shutdown. See &lt;a href=&quot;https://bugzilla.mozilla.org/show_bug.cgi?id=870645&quot;&gt;bug 870645&lt;/a&gt;. As a workaround for this normal shutdown notification, you might track your transactions and add a &lt;code&gt;beforeunload&lt;/code&gt; event to warn the user if any transactions have not yet completed at the time of unloading.</source>
          <target state="translated">실제로 정상적인 브라우저 종료시에도 IndexedDB 트랜잭션이 완료되도록 보장 할 방법이 없습니다. &lt;a href=&quot;https://bugzilla.mozilla.org/show_bug.cgi?id=870645&quot;&gt;버그 870645를&lt;/a&gt; 참조하십시오 . 이 정상적인 종료 알림에 대한 임시 해결책 으로, 언로드시 트랜잭션이 아직 완료되지 않은 경우 트랜잭션을 추적하고 &lt;code&gt;beforeunload&lt;/code&gt; 이벤트를 추가 하여 사용자에게 경고 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="737c6674fcba1a50c632bfaa53947ce63bee83e5" translate="yes" xml:space="preserve">
          <source>In following code snippet, the &lt;code&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Events/touchmove&quot;&gt;touchmove&lt;/a&gt;&lt;/code&gt; event handler iterrates through the &lt;code&gt;changedTouches&lt;/code&gt; list and prints the identifier of each touch point that changed since the last event.</source>
          <target state="translated">다음 코드 스 니펫에서 &lt;code&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Events/touchmove&quot;&gt;touchmove&lt;/a&gt;&lt;/code&gt; 이벤트 핸들러는 &lt;code&gt;changedTouches&lt;/code&gt; 목록을 반복 하고 마지막 이벤트 이후 변경된 각 터치 포인트의 식별자를 인쇄합니다.</target>
        </trans-unit>
        <trans-unit id="1ea2644b664e6b04f6e87ac99f6798ae73beaacc" translate="yes" xml:space="preserve">
          <source>In following code snippet, the &lt;code&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Events/touchstart&quot;&gt;touchstart&lt;/a&gt;&lt;/code&gt; event handler checks the length of the &lt;a href=&quot;touches&quot;&gt;&lt;code&gt;TouchEvent.touches&lt;/code&gt;&lt;/a&gt; list to determine the number of touch points that were activated and then invokes different handlers depending on the number of touch points.</source>
          <target state="translated">다음 코드 스 니펫에서 &lt;code&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Events/touchstart&quot;&gt;touchstart&lt;/a&gt;&lt;/code&gt; 이벤트 핸들러는 &lt;a href=&quot;touches&quot;&gt; &lt;code&gt;TouchEvent.touches&lt;/code&gt; &lt;/a&gt; 목록 의 길이 를 확인하여 활성화 된 터치 포인트 수를 판별 한 후 터치 포인트 수에 따라 다른 핸들러를 호출합니다.</target>
        </trans-unit>
        <trans-unit id="c8e625e355b76cacf20e174c5d656555b587e8f7" translate="yes" xml:space="preserve">
          <source>In following code snippet, the &lt;code&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Events/touchstart&quot;&gt;touchstart&lt;/a&gt;&lt;/code&gt; event handler iterrates through the &lt;code&gt;targetTouches&lt;/code&gt; list and logs the &lt;code&gt;force&lt;/code&gt; value of each touch point but the code could invoke different processing depending on the value.</source>
          <target state="translated">다음 코드 스 니펫에서 &lt;code&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Events/touchstart&quot;&gt;touchstart&lt;/a&gt;&lt;/code&gt; 이벤트 핸들러는 &lt;code&gt;targetTouches&lt;/code&gt; 목록을 반복하고 각 터치 포인트 의 &lt;code&gt;force&lt;/code&gt; 값을 기록 하지만 값에 따라 코드가 다른 처리를 호출 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b67d96d433944651e89541bfcc4c450a7fca0ab9" translate="yes" xml:space="preserve">
          <source>In following code snippet, the &lt;code&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Events/touchstart&quot;&gt;touchstart&lt;/a&gt;&lt;/code&gt; event handler logs the state of the event's modifier keys.</source>
          <target state="translated">다음 코드 스 니펫에서 &lt;code&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Events/touchstart&quot;&gt;touchstart&lt;/a&gt;&lt;/code&gt; 이벤트 핸들러는 이벤트 수정 자 키의 상태를 기록합니다.</target>
        </trans-unit>
        <trans-unit id="92306a282839c357b2f1ddf5150f17729457e18b" translate="yes" xml:space="preserve">
          <source>In following code snippet, the function compares the length of the &lt;code&gt;touches&lt;/code&gt; list to the the length of the &lt;code&gt;targetTouches&lt;/code&gt; list and returns &lt;code&gt;true&lt;/code&gt; if the lengths are the same and returns &lt;code&gt;false&lt;/code&gt; otherwise.</source>
          <target state="translated">다음 코드 스 니펫에서 함수는 &lt;code&gt;touches&lt;/code&gt; 목록의 길이를 &lt;code&gt;targetTouches&lt;/code&gt; 목록 의 길이와 비교하고 길이가 같으면 &lt;code&gt;true&lt;/code&gt; 를 리턴 &lt;code&gt;false&lt;/code&gt; 그렇지 않으면 false를 리턴합니다 .</target>
        </trans-unit>
        <trans-unit id="7f329872aea8d7ca69eedc6f4605ccd783f7fde8" translate="yes" xml:space="preserve">
          <source>In following simple code snippet, we assume the user initiates multiple touch contacts on an element with an id of &lt;code&gt;source&lt;/code&gt; and then releases contacts with the surface. When the &lt;code&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Events/touchstart&quot;&gt;touchstart&lt;/a&gt;&lt;/code&gt; event handler is invoked, each touch point's &lt;a href=&quot;screenx&quot;&gt;&lt;code&gt;Touch.screenX&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;screeny&quot;&gt;&lt;code&gt;Touch.screenY&lt;/code&gt;&lt;/a&gt; coordinates are accessed.</source>
          <target state="translated">다음의 간단한 코드 스 니펫에서는 사용자가 &lt;code&gt;source&lt;/code&gt; 가 id 인 요소에서 여러 개의 터치 접점을 시작한 다음 표면과의 접점을 해제 한다고 가정합니다 . 때 &lt;code&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Events/touchstart&quot;&gt;touchstart&lt;/a&gt;&lt;/code&gt; 의 이벤트 핸들러가 호출되고, 각 터치 포인트의 &lt;a href=&quot;screenx&quot;&gt; &lt;code&gt;Touch.screenX&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;screeny&quot;&gt; &lt;code&gt;Touch.screenY&lt;/code&gt; &lt;/a&gt; 좌표가 액세스 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="254ea6dbef92fc739d3302d1aaca8fa225cb6c91" translate="yes" xml:space="preserve">
          <source>In following simple code snippet, we assume the user initiates one or more touch contacts on the &lt;code&gt;source&lt;/code&gt; element, moves the touch points and then releases all contacts with the surface. When the &lt;code&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Events/touchmove&quot;&gt;touchmove&lt;/a&gt;&lt;/code&gt; event handler is invoked, each touch point's &lt;a href=&quot;pagex&quot;&gt;&lt;code&gt;Touch.pageX&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;pagey&quot;&gt;&lt;code&gt;Touch.pageY&lt;/code&gt;&lt;/a&gt; coordinates are accessed via the event's &lt;a href=&quot;../touchevent/changedtouches&quot;&gt;&lt;code&gt;TouchEvent.changedTouches&lt;/code&gt;&lt;/a&gt; list.</source>
          <target state="translated">다음의 간단한 코드 스 니펫에서는 사용자가 &lt;code&gt;source&lt;/code&gt; 요소 에서 하나 이상의 터치 접점을 시작 하고 터치 점을 이동 한 다음 표면과의 모든 접점을 해제 한다고 가정합니다 . 때 &lt;code&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Events/touchmove&quot;&gt;touchmove&lt;/a&gt;&lt;/code&gt; 이벤트 핸들러가 호출되고, 각 터치 포인트의 &lt;a href=&quot;pagex&quot;&gt; &lt;code&gt;Touch.pageX&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;pagey&quot;&gt; &lt;code&gt;Touch.pageY&lt;/code&gt; &lt;/a&gt; 좌표는 이벤트의를 통해 액세스 할 수 있습니다 &lt;a href=&quot;../touchevent/changedtouches&quot;&gt; &lt;code&gt;TouchEvent.changedTouches&lt;/code&gt; 의&lt;/a&gt; 목록입니다.</target>
        </trans-unit>
        <trans-unit id="387828167b0fa291417c19c0f75ac6a6d132ec6a" translate="yes" xml:space="preserve">
          <source>In following simple code snippet, we assume the user initiates one or more touch contacts on the &lt;code&gt;source&lt;/code&gt; element. When the &lt;code&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Events/touchstart&quot;&gt;touchstart&lt;/a&gt;&lt;/code&gt; event handler for this element is invoked, each touch point's &lt;a href=&quot;target&quot;&gt;&lt;code&gt;Touch.target&lt;/code&gt;&lt;/a&gt; property is accessed via the event's &lt;a href=&quot;../touchevent/targettouches&quot;&gt;&lt;code&gt;TouchEvent.targetTouches&lt;/code&gt;&lt;/a&gt; list.</source>
          <target state="translated">다음의 간단한 코드 스 니펫에서는 사용자가 &lt;code&gt;source&lt;/code&gt; 요소 에서 하나 이상의 터치 접점을 시작한다고 가정합니다 . 때 &lt;code&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Events/touchstart&quot;&gt;touchstart&lt;/a&gt;&lt;/code&gt; 의 이 요소에 대한 이벤트 핸들러가 호출되고, 각 터치 포인트의 &lt;a href=&quot;target&quot;&gt; &lt;code&gt;Touch.target&lt;/code&gt; 의&lt;/a&gt; 속성은 이벤트의를 통해 액세스 &lt;a href=&quot;../touchevent/targettouches&quot;&gt; &lt;code&gt;TouchEvent.targetTouches&lt;/code&gt; 의&lt;/a&gt; 목록입니다.</target>
        </trans-unit>
        <trans-unit id="50ff384a91996a27b9d1a0b40a2cc90a7a958a53" translate="yes" xml:space="preserve">
          <source>In general, a positive x component represents a position to the right of the origin, a positive y component is downward from the origin, and a positive z component extends outward from the screen (in other words, toward the user).</source>
          <target state="translated">일반적으로, 양의 x 성분은 원점의 오른쪽 위치를 나타내고 양의 y 성분은 원점에서 아래쪽으로, 양의 z 성분은 화면에서 바깥쪽으로 (즉, 사용자쪽으로) 연장됩니다.</target>
        </trans-unit>
        <trans-unit id="048691864c85b9374ea1acf4022d4c4aed6233b6" translate="yes" xml:space="preserve">
          <source>In general, a web page uses the Presentation Controller API to specify the web content to be rendered on presentation device and initiate the presentation session. With Presentation Receiver API, the presenting web content obtains the session status. With providing both the controller page and the receiver one with a messaged-based channel, a Web developer can implement the interaction between these two pages.</source>
          <target state="translated">일반적으로 웹 페이지는 Presentation Controller API를 사용하여 프리젠 테이션 장치에 렌더링 될 웹 컨텐츠를 지정하고 프리젠 테이션 세션을 시작합니다. Presentation Receiver API를 사용하면 현재 웹 콘텐츠가 세션 상태를 얻습니다. 컨트롤러 페이지와 수신자에게 메시지 기반 채널을 제공함으로써 웹 개발자는이 두 페이지 간의 상호 작용을 구현할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="051bedf0a059c726c3ba200f4390a434e8675e08" translate="yes" xml:space="preserve">
          <source>In general, audio visualizations are achieved by accessing an output of audio data over time, usually gain or frequency data, and then using a graphical technology to turn that into a visual output, such as a graph. The Web Audio API has an &lt;a href=&quot;../analysernode&quot;&gt;&lt;code&gt;AnalyserNode&lt;/code&gt;&lt;/a&gt; available that doesn't alter the audio signal passing through it. Instead it outputs audio data that can be passed to a visualization technology such as &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/canvas&quot;&gt;&lt;code&gt;&amp;lt;canvas&amp;gt;&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">일반적으로 오디오 시각화는 시간이 지남에 따라 오디오 데이터의 출력 (일반적으로 게인 또는 주파수 데이터)에 액세스 한 다음 그래픽 기술을 사용하여이를 그래픽과 같은 시각적 출력으로 변환합니다. Web Audio API에는 통과하는 오디오 신호를 변경하지 않는 &lt;a href=&quot;../analysernode&quot;&gt; &lt;code&gt;AnalyserNode&lt;/code&gt; 가&lt;/a&gt; 있습니다. 대신 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/canvas&quot;&gt; &lt;code&gt;&amp;lt;canvas&amp;gt;&lt;/code&gt; &lt;/a&gt; 와 같은 시각화 기술에 전달할 수있는 오디오 데이터를 출력합니다 .</target>
        </trans-unit>
        <trans-unit id="93a76f3e7126d5a95c8f046a12913c58948da569" translate="yes" xml:space="preserve">
          <source>In general, positive values &lt;code&gt;x&lt;/code&gt; mean to the right, and negative values of &lt;code&gt;x&lt;/code&gt; means to the left, assuming no transforms have resulted in a reversal.</source>
          <target state="translated">일반적으로, 양의 값은 &lt;code&gt;x&lt;/code&gt; 우측, 그리고 음의 값을 평균 &lt;code&gt;x&lt;/code&gt; 반전 결과 아니오 변환 없다고 가정 왼쪽 수단.</target>
        </trans-unit>
        <trans-unit id="0586780dfd544b08f1c0a00ebe3c9d2adc2eb4fc" translate="yes" xml:space="preserve">
          <source>In general, positive values &lt;code&gt;x&lt;/code&gt; mean to the right, and negative values of &lt;code&gt;x&lt;/code&gt; means to the left, assuming that transforms have not altered the orientation of the axes.</source>
          <target state="translated">일반적으로, 양의 값은 &lt;code&gt;x&lt;/code&gt; 우측, 그리고 음의 값의 평균 &lt;code&gt;x&lt;/code&gt; 변형이 축 방향을 변경하지 않은 것으로 가정하면, 왼쪽 수단.</target>
        </trans-unit>
        <trans-unit id="f84631ac21056293d2e65e006532b3c41e377717" translate="yes" xml:space="preserve">
          <source>In general, positive values of &lt;code&gt;y&lt;/code&gt; mean downward, and negative values of &lt;code&gt;y&lt;/code&gt; mean upward, assuming no transforms have resulted in a reversal.</source>
          <target state="translated">일반적으로, 양의 값의 &lt;code&gt;y&lt;/code&gt; 하방을 의미하고, 음의 값 &lt;code&gt;y&lt;/code&gt; 역전시킬 수도 어떠한 변환 없다고 가정 상향 의미한다.</target>
        </trans-unit>
        <trans-unit id="6131175892e4da16229c5200b4d3fab72f9f0b68" translate="yes" xml:space="preserve">
          <source>In general, positive values of &lt;code&gt;z&lt;/code&gt; mean toward the user (out from the screen), and negative values of &lt;code&gt;z&lt;/code&gt; mean away from the user (into the screen), assuming no transforms have resulted in a reversal.</source>
          <target state="translated">일반적으로, 양의 값의 &lt;code&gt;z&lt;/code&gt; (화면 밖으로) 사용자를 향해 평균과의 음의 값 &lt;code&gt;z&lt;/code&gt; 어떠한 변환이 반전되지 않은 결과 가정 (화면에) 사용자로부터 멀리 의미한다.</target>
        </trans-unit>
        <trans-unit id="60a04db3633042b40c24499a2fb3190f7a0d689c" translate="yes" xml:space="preserve">
          <source>In general, the path of least visual effort will give the user a less tiring experience.</source>
          <target state="translated">일반적으로 최소한의 시각적 노력으로 사용자는 덜 피곤한 경험을 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e813548fe3d369a72fe457299611e348e412b256" translate="yes" xml:space="preserve">
          <source>In general, the strategy compares the size of the chunks in the queue to a value called the &lt;strong&gt;high water mark&lt;/strong&gt;, which is the largest total chunk size that the queue can realistically manage.</source>
          <target state="translated">일반적으로이 전략은 큐의 청크 크기를 큐가 실제로 관리 할 수있는 최대 총 청크 크기 인 &lt;strong&gt;high water mark&lt;/strong&gt; 값과 비교합니다 .</target>
        </trans-unit>
        <trans-unit id="0029dcb34f740ff7f0dc5d67aede26941e62446e" translate="yes" xml:space="preserve">
          <source>In general, the value of &lt;code&gt;y&lt;/code&gt; increases to the right and decreases to the left, becoming negative to the left of the origin. This may change if transforms have been applied causing the axes' orientation to change.</source>
          <target state="translated">일반적으로 &lt;code&gt;y&lt;/code&gt; 의 값은 오른쪽으로 증가하고 왼쪽으로 감소하여 원점 왼쪽에서 음수가됩니다. 축 방향이 변경되도록 변형이 적용된 경우 변경 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4bc247ab5331c70289527d7a889f7582eb7e88ee" translate="yes" xml:space="preserve">
          <source>In general, users usually disable moving and resizing of existing windows because allowing authors' scripts to do so has been abused overwhelmingly in the past and the rare scripts that do not abuse such feature are often wrong, inaccurate when resizing the window. 99% of all those scripts disable window resizability and disable scrollbars when in fact they should enable both of these features to allow a cautious and sane fallback mechanism if their calculations are wrong.</source>
          <target state="translated">일반적으로 사용자는 일반적으로 기존의 창 이동 및 크기 조정을 비활성화합니다. 과거에는 작성자의 스크립트를 허용하는 것이 압도적으로 악용되었으며 이러한 기능을 악용하지 않는 희귀 한 스크립트는 종종 창 크기를 조정할 때 부정확하고 잘못되었습니다. 모든 스크립트의 99 %는 창 크기 조정 기능을 비활성화하고 실제로 계산이 잘못된 경우 신중하고 제정 된 폴백 메커니즘을 허용하기 위해 이러한 기능을 모두 활성화해야하는 경우 스크롤 막대를 비활성화합니다.</target>
        </trans-unit>
        <trans-unit id="c19e2ecf3e8adb7c40c1e4e9c56e520b9f012791" translate="yes" xml:space="preserve">
          <source>In general, you won't create these yourself; they are delivered to your implementation of &lt;a href=&quot;../mediarecorder/onerror&quot;&gt;&lt;code&gt;MediaRecorder.onerror&lt;/code&gt;&lt;/a&gt; when errors occur while recording media.</source>
          <target state="translated">일반적으로 직접 작성하지는 않습니다. 미디어를 기록하는 동안 오류가 발생하면 &lt;a href=&quot;../mediarecorder/onerror&quot;&gt; &lt;code&gt;MediaRecorder.onerror&lt;/code&gt; &lt;/a&gt; 의 구현으로 전달됩니다 .</target>
        </trans-unit>
        <trans-unit id="84df57b822d828bd65078def365bec19ebfdf033" translate="yes" xml:space="preserve">
          <source>In general, you won't need to use this constructor, as &lt;code&gt;RTCTrackEvent&lt;/code&gt; objects are created by WebRTC and delivered to your &lt;code&gt;RTCPeerConnector&lt;/code&gt;'s &lt;a href=&quot;../rtcpeerconnection/ontrack&quot;&gt;&lt;code&gt;ontrack&lt;/code&gt;&lt;/a&gt; event handler as appropriate.</source>
          <target state="translated">&lt;code&gt;RTCTrackEvent&lt;/code&gt; 객체는 WebRTC에 의해 생성되어 &lt;code&gt;RTCPeerConnector&lt;/code&gt; 의 &lt;a href=&quot;../rtcpeerconnection/ontrack&quot;&gt; &lt;code&gt;ontrack&lt;/code&gt; &lt;/a&gt; 이벤트 핸들러로 전달 되므로 일반적 으로이 생성자를 사용할 필요가 없습니다 .</target>
        </trans-unit>
        <trans-unit id="5dc92f8267a29d610ac81b2d49290b9b0da0aaa7" translate="yes" xml:space="preserve">
          <source>In here, we use &lt;code&gt;requestAnimationFrame()&lt;/code&gt; to keep looping the drawing function once it has been started:</source>
          <target state="translated">여기서는 &lt;code&gt;requestAnimationFrame()&lt;/code&gt; 을 사용 하여 그리기 함수가 시작된 후 계속 반복합니다.</target>
        </trans-unit>
        <trans-unit id="7674896c6195d6a95ccaf5023b60734186db0ae9" translate="yes" xml:space="preserve">
          <source>In later implementations, elements that have a nonce attribute only expose it to scripts (and not to side-channels like CSS attribute selectors).</source>
          <target state="translated">이후 구현에서 nonce 속성을 가진 요소는 스크립트에만 노출하며 CSS 속성 선택기와 같은 사이드 채널에는 노출되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="8c1971c187c2cb483aa00f477acbe4dd9aa578cb" translate="yes" xml:space="preserve">
          <source>In line 2, that frame of video is copied into the graphics context &lt;code&gt;ctx1&lt;/code&gt; of the first canvas, specifying as the height and width the values we previously saved to draw the frame at half size. Note that you can simply pass the video element into the context's &lt;code&gt;drawImage()&lt;/code&gt; method to draw the current video frame into the context. The result is:</source>
          <target state="translated">2 행에서 해당 비디오 프레임이 첫 번째 캔버스 의 그래픽 컨텍스트 &lt;code&gt;ctx1&lt;/code&gt; 에 복사되어 프레임을 절반 크기로 그리기 위해 이전에 저장 한 값의 높이와 너비를 지정합니다. 비디오 요소를 컨텍스트의 &lt;code&gt;drawImage()&lt;/code&gt; 메서드에 전달하여 현재 비디오 프레임을 컨텍스트에 그릴 수 있습니다. 결과는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="264177ae5e6b2be201a268a7ae3e427b56e34b3f" translate="yes" xml:space="preserve">
          <source>In majority of modern browsers, including recent versions of Firefox and Internet Explorer, this method does nothing.</source>
          <target state="translated">최신 버전의 Firefox 및 Internet Explorer를 포함한 대부분의 최신 브라우저에서이 방법은 아무 것도 수행하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="eb9f047109da7181cfc2e65a70f3da9699b0beef" translate="yes" xml:space="preserve">
          <source>In many cases, and where possible, it really is best practice to dynamically manipulate classes via the &lt;a href=&quot;../element/classname&quot;&gt;&lt;code&gt;className&lt;/code&gt;&lt;/a&gt; property since the ultimate appearance of all of the styling hooks can be controlled in a single stylesheet. One's JavaScript code also becomes cleaner since instead of being dedicated to styling details, it can focus on the overall semantics of each section it is creating or manipulating, leaving the precise style details to the stylesheet. However, there are cases where actually obtaining or manipulating the rules can be useful (whether for whole stylesheets or individual elements), and that is described in further detail below. Note also that, as with individual element's DOM styles, when speaking of manipulating the stylesheets, this is not actually manipulating the physical document(s), but merely the internal representation of the document.</source>
          <target state="translated">많은 경우에 가능하면 &lt;a href=&quot;../element/classname&quot;&gt; &lt;code&gt;className&lt;/code&gt; 을&lt;/a&gt; 통해 클래스를 동적으로 조작하는 것이 가장 좋습니다.모든 스타일링 후크의 최종 모양을 단일 스타일 시트에서 제어 할 수 있으므로 JavaScript 코드는 스타일 세부 사항에 전념하는 대신 더 깔끔해집니다. 스타일 시트에 정확한 스타일 세부 정보를 남기고 생성하거나 조작하는 각 섹션의 전체 의미에 중점을 둘 수 있습니다. 그러나 실제로 규칙을 얻거나 조작하는 것이 전체 스타일 시트 또는 개별 요소에 관계없이 유용 할 수있는 경우가 있으며, 이에 대해서는 아래에 자세히 설명되어 있습니다. 개별 요소의 DOM 스타일과 마찬가지로 스타일 시트를 조작 할 때 실제로는 실제 문서를 조작하는 것이 아니라 문서의 내부 표현 만 수행한다는 점에 유의하십시오.</target>
        </trans-unit>
        <trans-unit id="b3369e54140654f3f2d6bfa9556a1acd92668e45" translate="yes" xml:space="preserve">
          <source>In many cases, you don't need to be this verbose. For example, in our &lt;a href=&quot;https://mdn.github.io/emogotchi/&quot;&gt;Emogotchi demo&lt;/a&gt; (&lt;a href=&quot;https://github.com/mdn/emogotchi&quot;&gt;see source code&lt;/a&gt;), we simply run &lt;a href=&quot;notification/requestpermission&quot;&gt;&lt;code&gt;Notification.requestPermission&lt;/code&gt;&lt;/a&gt; regardless to make sure we can get permission to send notifications (this uses the newer promise-based method syntax):</source>
          <target state="translated">많은 경우에, 당신은이 장황한 사람 일 필요는 없습니다. 예를 들어, &lt;a href=&quot;https://mdn.github.io/emogotchi/&quot;&gt;Emogotchi 데모&lt;/a&gt; ( &lt;a href=&quot;https://github.com/mdn/emogotchi&quot;&gt;소스 코드 참조&lt;/a&gt; )에서 &lt;a href=&quot;notification/requestpermission&quot;&gt; &lt;code&gt;Notification.requestPermission&lt;/code&gt; &lt;/a&gt; 을 보낼 수있는 권한을 얻을 수 있는지 여부에 관계없이 Notification.requestPermission을 실행 하면됩니다 (이는 새로운 약속 기반 방법 구문을 사용함).</target>
        </trans-unit>
        <trans-unit id="ac3d4f714536a91787b726ddd603cf9c86d928fe" translate="yes" xml:space="preserve">
          <source>In many code samples online, &lt;code&gt;getComputedStyle&lt;/code&gt; is used from the &lt;code&gt;document.defaultView&lt;/code&gt; object. In nearly all cases, this is needless, as &lt;code&gt;getComputedStyle&lt;/code&gt; exists on the &lt;code&gt;window&lt;/code&gt; object as well. It's likely the defaultView pattern was some combination of (1) folks not wanting to write a spec for window and (2) making an API that was also usable in Java. However, there is &lt;a href=&quot;https://github.com/jquery/jquery/pull/524#issuecomment-2241183&quot;&gt;a single case&lt;/a&gt; where the &lt;code&gt;defaultView&lt;/code&gt;'s method must be used: when using Firefox 3.6 to access framed styles.</source>
          <target state="translated">많은 코드 샘플이 온라인에서 &lt;code&gt;getComputedStyle&lt;/code&gt; 이 &lt;code&gt;document.defaultView&lt;/code&gt; 객체 에서 사용됩니다 . 거의 모든 경우에 &lt;code&gt;getComputedStyle&lt;/code&gt; 이 &lt;code&gt;window&lt;/code&gt; 객체에도 존재하기 때문에 불필요 합니다. defaultView 패턴은 (1) 창에 대한 사양을 작성하지 않으려는 사람들과 (2) Java에서도 사용할 수있는 API를 만드는 조합 일 것입니다. 그러나,이 &lt;a href=&quot;https://github.com/jquery/jquery/pull/524#issuecomment-2241183&quot;&gt;하나의 경우 &lt;/a&gt; &lt;code&gt;defaultView&lt;/code&gt; 의 방법이 사용되어야합니다은 : 액세스 프레임 스타일에 파이어 폭스 3.6을 사용하는 경우.</target>
        </trans-unit>
        <trans-unit id="6741832d552415421f3c20860afb9f72cca2ae49" translate="yes" xml:space="preserve">
          <source>In modern browsers, &lt;code&gt;setTimeout()/&lt;/code&gt;&lt;a href=&quot;../windoworworkerglobalscope/setinterval&quot;&gt;&lt;code&gt;setInterval()&lt;/code&gt;&lt;/a&gt; calls are throttled to a minimum of once every 4ms when successive calls are triggered due to callback nesting (where the nesting level is at least a certain depth), or after certain number of successive intervals. For example:</source>
          <target state="translated">최신 브라우저에서는 콜백 중첩 (중첩 수준이 특정 깊이 이상인 경우)으로 인해 또는 특정 수의 연속 간격 후에 연속적인 호출이 트리거 될 때 &lt;code&gt;setTimeout()/&lt;/code&gt; &lt;a href=&quot;../windoworworkerglobalscope/setinterval&quot;&gt; &lt;code&gt;setInterval()&lt;/code&gt; &lt;/a&gt; 호출이 최소 4ms마다 한 번씩 조절됩니다. . 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="7ac8ce5501d76714e1c78b71b4dc610bf412d231" translate="yes" xml:space="preserve">
          <source>In modern implementations, the presence of this member with a value &lt;code&gt;true&lt;/code&gt;, will ensure there is at least one transceiver set to receive audio that has not been stopped, and if there isn't one, one will be created.</source>
          <target state="translated">현대의 구현에서, 값이 &lt;code&gt;true&lt;/code&gt; 인이 멤버의 존재는 중지되지 않은 오디오를 수신하도록 설정된 하나 이상의 트랜시버가 있는지 확인하고,없는 경우 트랜시버가 작성됩니다.</target>
        </trans-unit>
        <trans-unit id="9a0e502db7c13df6132b6c7fe0851e10a03868a3" translate="yes" xml:space="preserve">
          <source>In modern implementations, the presence of this member with a value &lt;code&gt;true&lt;/code&gt;, will ensure there is at least one transceiver set to receive video that has not been stopped, and if there isn't one, one will be created.</source>
          <target state="translated">현대 구현에서, 값이 &lt;code&gt;true&lt;/code&gt; 인이 멤버의 존재는 중지되지 않은 비디오를 수신하도록 설정된 적어도 하나의 트랜시버가 있는지 확인하고,없는 경우 트랜시버가 작성됩니다.</target>
        </trans-unit>
        <trans-unit id="7b2aa9ab3e9f7950af2b3b685de7d762e5fb0c3e" translate="yes" xml:space="preserve">
          <source>In more technical terms, &lt;code&gt;scrollX&lt;/code&gt; returns the X coordinate of the left edge of the current &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/viewport&quot;&gt;viewport&lt;/a&gt;. If there is no viewport, the returned value is 0.</source>
          <target state="translated">좀 더 기술적 인 용어로 &lt;code&gt;scrollX&lt;/code&gt; 는 현재 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/viewport&quot;&gt;뷰포트&lt;/a&gt; 왼쪽 가장자리의 X 좌표를 반환합니다 . 뷰포트가 없으면 반환 값은 0입니다.</target>
        </trans-unit>
        <trans-unit id="79505fba4dc5bcfb8dc396e041ff1b74ea444456" translate="yes" xml:space="preserve">
          <source>In more technical terms, &lt;code&gt;scrollY&lt;/code&gt; returns the Y coordinate of the top edge of the current &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/viewport&quot;&gt;viewport&lt;/a&gt;. If there is no viewport, the returned value is 0.</source>
          <target state="translated">보다 기술적 인 용어로 &lt;code&gt;scrollY&lt;/code&gt; 는 현재 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/viewport&quot;&gt;뷰포트&lt;/a&gt; 위쪽 가장자리의 Y 좌표를 반환합니다 . 뷰포트가 없으면 반환 값은 0입니다.</target>
        </trans-unit>
        <trans-unit id="3411bf2cefab55059a086ee802f375412a232931" translate="yes" xml:space="preserve">
          <source>In most browsers, calling &lt;code&gt;btoa()&lt;/code&gt; on a Unicode string will cause an &lt;code&gt;InvalidCharacterError&lt;/code&gt; exception.</source>
          <target state="translated">대부분의 브라우저에서 유니 코드 문자열에서 &lt;code&gt;btoa()&lt;/code&gt; 를 호출 하면 &lt;code&gt;InvalidCharacterError&lt;/code&gt; 예외 가 발생합니다 .</target>
        </trans-unit>
        <trans-unit id="eba0afde8c7f992d74b74892633d16b8df0fb3b3" translate="yes" xml:space="preserve">
          <source>In most cases you can provide any response that the receiver understands. For example, if an &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/img&quot;&gt;&lt;code&gt;&amp;lt;img&amp;gt;&lt;/code&gt;&lt;/a&gt; initiates the request, the response body needs to be image data). For security reasons, there are a few global rules:</source>
          <target state="translated">대부분의 경우 수신자가 이해하는 응답을 제공 할 수 있습니다. 예를 들어 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/img&quot;&gt; &lt;code&gt;&amp;lt;img&amp;gt;&lt;/code&gt; &lt;/a&gt; 가 요청을 시작하면 응답 본문은 이미지 데이터 여야합니다. 보안상의 이유로 몇 가지 전역 규칙이 있습니다.</target>
        </trans-unit>
        <trans-unit id="f77f8fe95e61c7c7ca8962b83c424d78b1a5664a" translate="yes" xml:space="preserve">
          <source>In newer implementations, the value is a &lt;a href=&quot;../domhighrestimestamp&quot;&gt;&lt;code&gt;DOMHighResTimeStamp&lt;/code&gt;&lt;/a&gt; accurate to 5 microseconds (0.005 ms). In older implementations, the value is a &lt;a href=&quot;../domtimestamp&quot;&gt;&lt;code&gt;DOMTimeStamp&lt;/code&gt;&lt;/a&gt;, accurate to a millisecond.</source>
          <target state="translated">최신 구현 &lt;a href=&quot;../domhighrestimestamp&quot;&gt; &lt;code&gt;DOMHighResTimeStamp&lt;/code&gt; &lt;/a&gt; 값은 5 마이크로 초 ( 0.005ms)까지 정확한 DOMHighResTimeStamp 입니다. 이전 구현에서 값은 밀리 초 단위로 정확한 &lt;a href=&quot;../domtimestamp&quot;&gt; &lt;code&gt;DOMTimeStamp&lt;/code&gt; &lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="7a435abf519b87fd3c142c90a92d88bea97b8fad" translate="yes" xml:space="preserve">
          <source>In old browsers, as specified in old versions of the specifications, the method may throws the &lt;code&gt;INVALID_STATE_ERR&lt;/code&gt;&lt;a href=&quot;../domexception&quot;&gt;&lt;code&gt;DOMException&lt;/code&gt;&lt;/a&gt; if this method is called after the &lt;a href=&quot;detach&quot;&gt;&lt;code&gt;NodeIterator.detach()&lt;/code&gt;&lt;/a&gt;method. Recent browsers never throw.</source>
          <target state="translated">이전 버전의 스펙에 지정된대로 이전 브라우저에서는 &lt;a href=&quot;detach&quot;&gt; &lt;code&gt;NodeIterator.detach()&lt;/code&gt; &lt;/a&gt; 메소드 다음에이 메소드를 호출하면 메소드가 &lt;code&gt;INVALID_STATE_ERR&lt;/code&gt; &lt;a href=&quot;../domexception&quot;&gt; &lt;code&gt;DOMException&lt;/code&gt; 을&lt;/a&gt; 발생 시킬 수 있습니다 . 최신 브라우저는 절대로 던지지 않습니다.</target>
        </trans-unit>
        <trans-unit id="7bcfe1ed7e2c95e956a98f1e61b44851dec42196" translate="yes" xml:space="preserve">
          <source>In old implementations and outdated specifications, it returned &lt;code&gt;true&lt;/code&gt; when a modifier which is the typical modifier key for the shortcut key is pressed. For example, on Windows, pressing</source>
          <target state="translated">이전 구현 및 오래된 사양에서는 바로 가기 키의 일반적인 수정 자 키인 수정자를 누를 때 &lt;code&gt;true&lt;/code&gt; 를 반환했습니다 . 예를 들어, Windows에서</target>
        </trans-unit>
        <trans-unit id="aaaf08a2082c6b4995077fbcbcdba4984f680189" translate="yes" xml:space="preserve">
          <source>In older code and documentation, you may see a callback-based version of this function used. This has been deprecated and its use is &lt;strong&gt;strongly&lt;/strong&gt; discouraged, as it will be removed in the future. You should update any existing code to use the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise&quot;&gt;&lt;code&gt;Promise&lt;/code&gt;&lt;/a&gt;-based version of &lt;code&gt;setLocalDescription()&lt;/code&gt; instead. The parameters for the older form of &lt;code&gt;setLocalDescription()&lt;/code&gt; are described below, to aid in updating existing code.</source>
          <target state="translated">이전 코드 및 설명서에서이 함수의 콜백 기반 버전이 사용 된 것을 볼 수 있습니다. 이것은 사용되지 않으며 그 사용이됩니다 &lt;strong&gt;강력&lt;/strong&gt; 가 미래에서 제거 될 예정으로, 낙담. &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise&quot;&gt; &lt;code&gt;Promise&lt;/code&gt; &lt;/a&gt; 기반 버전의 &lt;code&gt;setLocalDescription()&lt;/code&gt; 대신 사용하려면 기존 코드를 업데이트해야 합니다. 기존 코드 업데이트를 돕기 위해 이전 형식의 &lt;code&gt;setLocalDescription()&lt;/code&gt; 대한 매개 변수 가 아래에 설명되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="097d93f40ccaa3420700a832b93b35907150d579" translate="yes" xml:space="preserve">
          <source>In older code and documentation, you may see a callback-based version of this function used. This has been deprecated and its use is &lt;strong&gt;strongly&lt;/strong&gt; discouraged. You should update any existing code to use the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise&quot;&gt;&lt;code&gt;Promise&lt;/code&gt;&lt;/a&gt;-based version of &lt;code&gt;setRemoteDescription()&lt;/code&gt; instead. The parameters for the older form of &lt;code&gt;setRemoteDescription()&lt;/code&gt; are described below, to aid in updating existing code.</source>
          <target state="translated">이전 코드 및 설명서에서이 함수의 콜백 기반 버전이 사용 된 것을 볼 수 있습니다. 이 기능은 더 이상 사용되지 않으며 사용을 &lt;strong&gt;권장&lt;/strong&gt; 하지 않습니다. &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise&quot;&gt; &lt;code&gt;Promise&lt;/code&gt; &lt;/a&gt; 기반 버전의 &lt;code&gt;setRemoteDescription()&lt;/code&gt; 대신 사용하려면 기존 코드를 업데이트해야 합니다. 기존 코드 업데이트를 돕기 위해 이전 형식의 &lt;code&gt;setRemoteDescription()&lt;/code&gt; 대한 매개 변수 가 아래에 설명되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="efcb5b5a283b8492a38c052d458cc611438bb585" translate="yes" xml:space="preserve">
          <source>In older code and documentation, you may see a callback-based version of this function. This has been deprecated and its use is &lt;strong&gt;strongly&lt;/strong&gt; discouraged. You should update any existing code to use the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise&quot;&gt;&lt;code&gt;Promise&lt;/code&gt;&lt;/a&gt;-based version of &lt;code&gt;addIceCandidate()&lt;/code&gt; instead. The parameters for this form of &lt;code&gt;addIceCandidate()&lt;/code&gt; are described below, to aid in updating existing code.</source>
          <target state="translated">이전 코드 및 설명서에서이 함수의 콜백 기반 버전이 표시 될 수 있습니다. 이 기능은 더 이상 사용되지 않으며 사용을 &lt;strong&gt;권장&lt;/strong&gt; 하지 않습니다. &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise&quot;&gt; &lt;code&gt;Promise&lt;/code&gt; &lt;/a&gt; 기반 버전의 &lt;code&gt;addIceCandidate()&lt;/code&gt; 대신 사용하려면 기존 코드를 업데이트해야 합니다. 이 형식의 &lt;code&gt;addIceCandidate()&lt;/code&gt; 대한 매개 변수는 기존 코드를 업데이트하는 데 도움이되도록 아래에 설명되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="134fdb11ab98c50f15c91878c647f37a94e7004e" translate="yes" xml:space="preserve">
          <source>In older code and documentation, you may see a callback-based version of this function. This has been deprecated and its use is &lt;strong&gt;strongly&lt;/strong&gt; discouraged. You should update any existing code to use the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise&quot;&gt;&lt;code&gt;Promise&lt;/code&gt;&lt;/a&gt;-based version of &lt;code&gt;createAnswer()&lt;/code&gt; instead. The parameters for this form of &lt;code&gt;createAnswer()&lt;/code&gt; are described below, to aid in updating existing code.</source>
          <target state="translated">이전 코드 및 설명서에서이 함수의 콜백 기반 버전이 표시 될 수 있습니다. 이 기능은 더 이상 사용되지 않으며 사용을 &lt;strong&gt;권장&lt;/strong&gt; 하지 않습니다. &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise&quot;&gt; &lt;code&gt;Promise&lt;/code&gt; &lt;/a&gt; 기반 버전의 &lt;code&gt;createAnswer()&lt;/code&gt; 대신 사용하려면 기존 코드를 업데이트해야 합니다. 이 형식의 &lt;code&gt;createAnswer()&lt;/code&gt; 의 매개 변수 는 아래에 설명되어 있으며 기존 코드를 업데이트하는 데 도움이됩니다.</target>
        </trans-unit>
        <trans-unit id="ee4b19a335993df1eded8e5fe44744d2f0b36700" translate="yes" xml:space="preserve">
          <source>In older code and documentation, you may see a callback-based version of this function. This has been deprecated and its use is &lt;strong&gt;strongly&lt;/strong&gt; discouraged. You should update any existing code to use the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise&quot;&gt;&lt;code&gt;Promise&lt;/code&gt;&lt;/a&gt;-based version of &lt;code&gt;createOffer()&lt;/code&gt; instead. The parameters for this form of &lt;code&gt;createOffer()&lt;/code&gt; are described below, to aid in updating existing code.</source>
          <target state="translated">이전 코드 및 설명서에서이 함수의 콜백 기반 버전이 표시 될 수 있습니다. 이 기능은 더 이상 사용되지 않으며 사용을 &lt;strong&gt;권장&lt;/strong&gt; 하지 않습니다. &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise&quot;&gt; &lt;code&gt;Promise&lt;/code&gt; &lt;/a&gt; 기반 버전의 &lt;code&gt;createOffer()&lt;/code&gt; 대신 사용하려면 기존 코드를 업데이트해야 합니다. 기존 코드를 업데이트하는 데 도움 이되도록이 형식의 &lt;code&gt;createOffer()&lt;/code&gt; 대한 매개 변수 가 아래에 설명되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="c0e59a85f6b027f3aa5a9fc1e39e76c7f8ac40b4" translate="yes" xml:space="preserve">
          <source>In older versions of the DOM specification, the third parameter of &lt;code&gt;addEventListener()&lt;/code&gt; was a Boolean value indicating whether or not to use capture. Over time, it became clear that more options were needed. Rather than adding more parameters to the function (complicating things enormously when dealing with optional values), the third parameter was changed to an object which can contain various properties defining the values of options to configure the process of removing the event listener.</source>
          <target state="translated">이전 버전의 DOM 스펙에서 &lt;code&gt;addEventListener()&lt;/code&gt; 의 세 번째 매개 변수는 캡처 사용 여부를 나타내는 부울 값입니다. 시간이 지남에 따라 더 많은 옵션이 필요하다는 것이 분명해졌습니다. 함수에 더 많은 매개 변수를 추가하지 않고 (선택적 값을 처리 할 때 항목을 복잡하게 함), 세 번째 매개 변수는 옵션 값을 정의하는 다양한 속성을 포함하는 이벤트 리스너 제거 프로세스를 구성 할 수있는 객체로 변경되었습니다.</target>
        </trans-unit>
        <trans-unit id="41573554a09c12a4aff0b0a323d5d5c346b1ae26" translate="yes" xml:space="preserve">
          <source>In older versions of the Media Source specification, attaching a stream to a &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/video&quot;&gt;&lt;code&gt;&amp;lt;video&amp;gt;&lt;/code&gt;&lt;/a&gt; element required creating an object URL for the &lt;a href=&quot;../mediastream&quot;&gt;&lt;code&gt;MediaStream&lt;/code&gt;&lt;/a&gt;. This is no longer necessary, and browsers are removing support for doing this.</source>
          <target state="translated">이전 버전의 미디어 소스 사양에서 스트림을 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/video&quot;&gt; &lt;code&gt;&amp;lt;video&amp;gt;&lt;/code&gt; &lt;/a&gt; 요소에 연결하려면 &lt;a href=&quot;../mediastream&quot;&gt; &lt;code&gt;MediaStream&lt;/code&gt; &lt;/a&gt; 의 객체 URL을 만들어야했습니다 . 이것은 더 이상 필요하지 않으며 브라우저는이 작업에 대한 지원을 제거하고 있습니다.</target>
        </trans-unit>
        <trans-unit id="7c302bcb3cfbd3180e4e52b76824483193bf2e26" translate="yes" xml:space="preserve">
          <source>In older versions of the spec, the default for a &lt;a href=&quot;../channelsplitternode&quot;&gt;&lt;code&gt;ChannelSplitterNode&lt;/code&gt;&lt;/a&gt; was max.</source>
          <target state="translated">이전 버전의 사양에서 &lt;a href=&quot;../channelsplitternode&quot;&gt; &lt;code&gt;ChannelSplitterNode&lt;/code&gt; &lt;/a&gt; 의 기본값 은 max입니다.</target>
        </trans-unit>
        <trans-unit id="f86093cd00563053ec5d4bf439270969b2899fd9" translate="yes" xml:space="preserve">
          <source>In one of the examples on the previous page, we used a series of loops to create a pattern of images. There is, however, a much simpler method: the &lt;code&gt;createPattern()&lt;/code&gt; method.</source>
          <target state="translated">이전 페이지의 예제 중 하나에서 일련의 루프를 사용하여 이미지 패턴을 만들었습니다. 그러나 훨씬 간단한 메소드 인 &lt;code&gt;createPattern()&lt;/code&gt; 메소드가 있습니다.</target>
        </trans-unit>
        <trans-unit id="1474b544bd087ffebb2c0693665591f47361763f" translate="yes" xml:space="preserve">
          <source>In order to be oriented about what we're trying to accomplish, let's have a look at the HTML. This establishes a box (ID &lt;code&gt;&quot;Container&quot;&lt;/code&gt;) that's used to present the progress of an operation (because you never know how long decoding &quot;quantum filament tachyon emissions&quot; will take, after all) as well as a second main box (with the ID &lt;code&gt;&quot;logBox&quot;&lt;/code&gt;), which is used to display textual output.</source>
          <target state="translated">우리가 달성하려는 것에 중점을두기 위해 HTML을 살펴 보겠습니다. 이렇게 하면 작업의 진행률을 나타내는 데 사용되는 상자 (ID &lt;code&gt;&quot;Container&quot;&lt;/code&gt; )가 설정됩니다 (결국 &quot;양성 필라멘트 타키온 방출&quot;에 걸리는 시간을 알 수 없기 때문에) 및 두 번째 기본 상자 (ID 포함) 텍스트 출력을 표시하는 데 사용되는 &lt;code&gt;&quot;logBox&quot;&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="dfc2348830420baea75c39165d0ecb114e4ddc39" translate="yes" xml:space="preserve">
          <source>In order to build a good offline-capable web application, you need to know when your application is actually offline. You also need to know when your application has returned to an 'online' status again. Effectively, the requirements break down as such:</source>
          <target state="translated">좋은 오프라인 가능 웹 응용 프로그램을 구축하려면 응용 프로그램이 실제로 오프라인 인시기를 알아야합니다. 또한 애플리케이션이 '온라인'상태로 다시 돌아 왔을 때도 알아야합니다. 효과적으로 요구 사항은 다음과 같이 분류됩니다.</target>
        </trans-unit>
        <trans-unit id="2ec3d59e58079b971cb7a57156a0caea3e5e7a7d" translate="yes" xml:space="preserve">
          <source>In order to calculate the duration of a specific operation, Gecko 10 introduced the support of timers in the &lt;code&gt;console&lt;/code&gt; object. To start a timer, call the &lt;code&gt;console.time&lt;/code&gt;&lt;code&gt;()&lt;/code&gt; method, giving it a name as the only parameter. To stop the timer, and to get the elapsed time in milliseconds, just call the &lt;code&gt;console.timeEnd()&lt;/code&gt; method, again passing the timer's name as the parameter. Up to 10,000 timers can run simultaneously on a given page.</source>
          <target state="translated">특정 작업의 지속 시간을 계산하기 위해 Gecko 10은 &lt;code&gt;console&lt;/code&gt; 개체 에 타이머 지원을 도입했습니다 . 타이머를 시작하려면 &lt;code&gt;console.time&lt;/code&gt; &lt;code&gt;()&lt;/code&gt; 메소드를 호출 하여 유일한 매개 변수로 이름을 지정하십시오. 타이머를 중지하고 경과 시간을 밀리 초 단위로 얻으려면 &lt;code&gt;console.timeEnd()&lt;/code&gt; 메서드를 호출 하고 타이머 이름을 다시 매개 변수로 전달하십시오. 특정 페이지에서 최대 10,000 개의 타이머를 동시에 실행할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="62c783e51b117fbff0f332f1103ec26b920b6cad" translate="yes" xml:space="preserve">
          <source>In order to communicate using the WebSocket protocol, you need to create a &lt;a href=&quot;https://developer.mozilla.org/en/WebSockets/WebSockets_reference/WebSocket&quot;&gt;&lt;code&gt;WebSocket&lt;/code&gt;&lt;/a&gt; object; this will automatically attempt to open the connection to the server.</source>
          <target state="translated">WebSocket 프로토콜을 사용하여 통신하려면 &lt;a href=&quot;https://developer.mozilla.org/en/WebSockets/WebSockets_reference/WebSocket&quot;&gt; &lt;code&gt;WebSocket&lt;/code&gt; &lt;/a&gt; 객체 를 만들어야 합니다. 서버와의 연결을 자동으로 시도합니다.</target>
        </trans-unit>
        <trans-unit id="968c4b9960c33fa05ceac1ea8fc75f7051b9c265" translate="yes" xml:space="preserve">
          <source>In order to exchange signaling information, you can choose to send JSON objects back and forth over a WebSocket connection, or you could use XMPP or SIP over an appropriate channel, or you could use &lt;a href=&quot;../xmlhttprequest&quot;&gt;&lt;code&gt;XMLHttpRequest&lt;/code&gt;&lt;/a&gt; over &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/HTTPS&quot;&gt;HTTPS&lt;/a&gt; with polling, or any other combination of technologies you can come up with. You could even use email as the signaling channel.</source>
          <target state="translated">신호 정보를 교환하기 위해 WebSocket 연결을 통해 JSON 객체를주고 받거나 적절한 채널을 통해 XMPP 또는 SIP를 사용 하거나 폴링 또는 기타 기술 조합을 사용 하여 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/HTTPS&quot;&gt;HTTPS&lt;/a&gt; 를 통한 &lt;a href=&quot;../xmlhttprequest&quot;&gt; &lt;code&gt;XMLHttpRequest&lt;/code&gt; &lt;/a&gt; 를 사용할 수 있습니다 당신은 생각 해낼 수 있습니다. 이메일을 신호 채널로 사용할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="0291f8233557ffa64fa29c26e39344db5ec26225" translate="yes" xml:space="preserve">
          <source>In order to make each touch's drawing look different, the &lt;code&gt;colorForTouch()&lt;/code&gt; function is used to pick a color based on the touch's unique identifier. This identifier is an opaque number, but we can at least rely on it differing between the currently-active touches.</source>
          <target state="translated">각 터치의 드로잉을 다르게 보이게하기 위해 &lt;code&gt;colorForTouch()&lt;/code&gt; 함수는 터치의 고유 식별자에 따라 색상을 선택하는 데 사용됩니다. 이 식별자는 불투명 한 숫자이지만 적어도 현재 활성화 된 터치간에 다른 식별자에 의존 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="57b1318757166bbe18bececb3673b6b66bea857f" translate="yes" xml:space="preserve">
          <source>In order to more fully support audio/video conferencing, &lt;a href=&quot;../webrtc_api&quot;&gt;WebRTC&lt;/a&gt; supports sending &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/DTMF&quot;&gt;DTMF&lt;/a&gt; to the remote peer on an &lt;a href=&quot;../rtcpeerconnection&quot;&gt;&lt;code&gt;RTCPeerConnection&lt;/code&gt;&lt;/a&gt;. This article offers a brief high-level overview of how DTMF works over WebRTC, then provides a guide for everyday developers about how to send DTMF over an &lt;code&gt;RTCPeerConnection&lt;/code&gt;. The DTMF system is often referred to as &quot;touch tone,&quot; after an old trade name for the system.</source>
          <target state="translated">오디오 / 비디오 회의를보다 완벽하게 지원하기 위해 &lt;a href=&quot;../webrtc_api&quot;&gt;WebRTC&lt;/a&gt; 는 &lt;a href=&quot;../rtcpeerconnection&quot;&gt; &lt;code&gt;RTCPeerConnection&lt;/code&gt; &lt;/a&gt; 의 원격 피어로 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/DTMF&quot;&gt;DTMF&lt;/a&gt; 전송을 지원합니다 . 이 기사는 WebRTC를 통해 DTMF가 작동하는 방법에 대한 간략한 고급 개요를 제공하며, &lt;code&gt;RTCPeerConnection&lt;/code&gt; 을 통해 DTMF를 보내는 방법에 대한 일상적인 개발자를위한 안내서를 제공합니다 . DTMF 시스템은 시스템의 오래된 상표 이름 뒤에 &quot;터치 톤&quot;이라고도합니다.</target>
        </trans-unit>
        <trans-unit id="8fcd93125ff64c453149a5e27b785291649c0d94" translate="yes" xml:space="preserve">
          <source>In order to pick up the interpolated color for each pixel, we need to change this to fetch the value from the &lt;code&gt;vColor&lt;/code&gt; varying:</source>
          <target state="translated">각 픽셀에 대해 보간 된 색상을 선택하려면 &lt;code&gt;vColor&lt;/code&gt; 가변 에서 값을 가져 오도록이를 변경해야합니다 .</target>
        </trans-unit>
        <trans-unit id="ac3b40a8dd6337c88081ee682aa292308f44907a" translate="yes" xml:space="preserve">
          <source>In order to properly stream MP4, we need the asset to be an &lt;a href=&quot;http://www.w3.org/TR/media-source/isobmff-byte-stream-format.html&quot;&gt;ISO BMF&lt;/a&gt; format MP4. Without proper fragmentation, any given mp4 file is not guaranteed to work with MSE. This means that metadata within the container is spread out and not lumped together.</source>
          <target state="translated">MP4를 올바르게 스트리밍하려면 자산이 &lt;a href=&quot;http://www.w3.org/TR/media-source/isobmff-byte-stream-format.html&quot;&gt;ISO BMF&lt;/a&gt; 형식 MP4 여야합니다 . 적절한 조각화가 없으면 주어진 mp4 파일이 MSE와 작동하지 않을 수 있습니다. 이는 컨테이너 내의 메타 데이터가 분산되어 함께 묶이지 않음을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="af63536a29b7f04f6fe5b16703c07ae972667359" translate="yes" xml:space="preserve">
          <source>In order to provide quality support for touch-based user interfaces, touch events offer the ability to interpret finger (or stylus) activity on touch screens or trackpads.</source>
          <target state="translated">터치 기반 사용자 인터페이스에 대한 품질 지원을 제공하기 위해 터치 이벤트는 터치 스크린 또는 트랙 패드에서 손가락 (또는 스타일러스) 활동을 해석하는 기능을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="bbd0130ac638b46c8af330ae1a57e8e2b08f6e76" translate="yes" xml:space="preserve">
          <source>In order to resolve this issue, a new system of &lt;strong&gt;stream schedulers&lt;/strong&gt; (usually referred to as the &quot;SCTP ndata specification&quot;) has been designed to make it possible to interleave messages sent on different streams, including streams used to implement WebRTC data channels. This &lt;a href=&quot;https://tools.ietf.org/html/draft-ietf-tsvwg-sctp-ndata&quot;&gt;proposal&lt;/a&gt; is still in IETF draft form, but once implemented, it will make it possible to send messages with essentially no size limitations, since the SCTP layer will automatically interleave the underlying sub-messages to ensure that every channel's data has the opportunity to get through.</source>
          <target state="translated">이 문제를 해결하기 위해 새로운 &lt;strong&gt;스트림 스케줄러&lt;/strong&gt; 시스템 (일반적으로 &quot;SCTP ndata specification&quot;이라고 함)은 WebRTC 데이터 채널을 구현하는 데 사용되는 스트림을 포함하여 다른 스트림으로 전송 된 메시지를 인터리브 할 수 있도록 설계되었습니다. 이 &lt;a href=&quot;https://tools.ietf.org/html/draft-ietf-tsvwg-sctp-ndata&quot;&gt;제안&lt;/a&gt; 은 여전히 ​​IETF 초안 형식이지만 일단 구현되면 SCTP 계층이 기본 하위 메시지를 자동으로 인터리빙하여 모든 채널의 데이터가 얻을 수있는 기회를 가지므로 크기 제한없이 메시지를 보낼 수 있습니다. 을 통하여.</target>
        </trans-unit>
        <trans-unit id="b03fb24169c4ea52c52cb06ed130504936fb9ad4" translate="yes" xml:space="preserve">
          <source>In order to understand how the create() and get() methods fit into the bigger picture, it is important to understand that they sit between two components that are outside the browser:</source>
          <target state="translated">create () 및 get () 메서드가 더 큰 그림에 어떻게 적용되는지 이해하려면 브라우저 외부에있는 두 구성 요소 사이에 위치한다는 것을 이해하는 것이 중요합니다.</target>
        </trans-unit>
        <trans-unit id="d13d4ddfa3ff40016f3768af5a565ed38516f5b9" translate="yes" xml:space="preserve">
          <source>In order to use adapter.js, you need to include adapter.js on any page that uses WebRTC APIs:</source>
          <target state="translated">adapter.js를 사용하려면 WebRTC API를 사용하는 모든 페이지에 adapter.js를 포함해야합니다.</target>
        </trans-unit>
        <trans-unit id="60a23f25a73b86a9f6c6e0de9db50c1290951ad7" translate="yes" xml:space="preserve">
          <source>In order to use the following code, please replace all occurrences of the word &lt;code&gt;doSomethingOnlyOnce&lt;/code&gt; (the name of the cookie) with a custom name.</source>
          <target state="translated">다음 코드를 사용하려면 단어 &lt;code&gt;doSomethingOnlyOnce&lt;/code&gt; (쿠키 이름)를 모두 사용자 정의 이름으로 바꾸십시오.</target>
        </trans-unit>
        <trans-unit id="54a3c163df8ffe471e9058c8dc2a2565970fda6b" translate="yes" xml:space="preserve">
          <source>In order to use this in the shader it must be set to a uniform location. The locations for the uniforms are saved in the &lt;code&gt;locations&lt;/code&gt; object shown below:</source>
          <target state="translated">이것을 셰이더에서 사용하려면 균일 한 위치로 설정해야합니다. 유니폼의 위치는 아래 표시된 &lt;code&gt;locations&lt;/code&gt; 개체에 저장 됩니다.</target>
        </trans-unit>
        <trans-unit id="fa66a79c3fac37fc666142b8fe2063a97c0ac7a8" translate="yes" xml:space="preserve">
          <source>In other cases, the &lt;code&gt;NodeList&lt;/code&gt; is &lt;em&gt;static, &lt;/em&gt;where any changes in the DOM does not affect the content of the collection. &lt;a href=&quot;document/queryselectorall&quot;&gt;&lt;code&gt;document.querySelectorAll()&lt;/code&gt;&lt;/a&gt; returns a static &lt;code&gt;NodeList&lt;/code&gt;.</source>
          <target state="translated">다른 경우, &lt;code&gt;NodeList&lt;/code&gt; 는 &lt;em&gt;정적이며&lt;/em&gt; DOM의 변경 사항은 콜렉션의 컨텐츠에 영향을 미치지 않습니다. &lt;a href=&quot;document/queryselectorall&quot;&gt; &lt;code&gt;document.querySelectorAll()&lt;/code&gt; &lt;/a&gt; 은 정적 &lt;code&gt;NodeList&lt;/code&gt; 를 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="97f3e56bcf0e803b1e079c87250fda38bf5f8da9" translate="yes" xml:space="preserve">
          <source>In other documents, it creates an element with a &lt;code&gt;null&lt;/code&gt; namespace URI.</source>
          <target state="translated">다른 문서에서는 네임 스페이스 URI 가 &lt;code&gt;null&lt;/code&gt; 인 요소를 만듭니다 .</target>
        </trans-unit>
        <trans-unit id="780f4a3523e4be9fa0e5d39b80e3044abb2b825e" translate="yes" xml:space="preserve">
          <source>In other words, &lt;code&gt;console.dir&lt;/code&gt; is the way to see all the properties of a specified JavaScript object in console by which the developer can easily get the properties of the object.</source>
          <target state="translated">즉, &lt;code&gt;console.dir&lt;/code&gt; 은 개발자가 객체의 속성을 쉽게 얻을 수있는 콘솔에서 지정된 JavaScript 객체의 모든 속성을 보는 방법입니다.</target>
        </trans-unit>
        <trans-unit id="e0f19ec1e06b9ae4900d618b18f622f02a09a801" translate="yes" xml:space="preserve">
          <source>In other words, any option contained within the &lt;code&gt;&amp;lt;select&amp;gt;&lt;/code&gt; element may be part of the results, but option groups are not included in the list.</source>
          <target state="translated">즉, &lt;code&gt;&amp;lt;select&amp;gt;&lt;/code&gt; 요소에 포함 된 옵션은 결과의 일부일 수 있지만 옵션 그룹은 목록에 포함되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="97a7c108b5c6140b4173059986003f1376e968b1" translate="yes" xml:space="preserve">
          <source>In other words, if window &lt;code&gt;A&lt;/code&gt; opens window &lt;code&gt;B&lt;/code&gt;, &lt;code&gt;B.opener&lt;/code&gt; returns &lt;code&gt;A&lt;/code&gt;.</source>
          <target state="translated">즉, 윈도우 &lt;code&gt;A&lt;/code&gt; 가 윈도우 &lt;code&gt;B&lt;/code&gt; 를 &lt;code&gt;B.opener&lt;/code&gt; 는 &lt;code&gt;A&lt;/code&gt; 를 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="7ce78e8d1d2a0d50c2a376afec5e90ceb657b19e" translate="yes" xml:space="preserve">
          <source>In other words, the DOM tree for the following document will look like the image below (using &quot;\n&quot; to represent newlines):</source>
          <target state="translated">다시 말해, 다음 문서의 DOM 트리는 아래 이미지와 같습니다 ( &quot;\ n&quot;을 사용하여 줄 바꿈을 나타냄).</target>
        </trans-unit>
        <trans-unit id="5c1995dd1809228319a7049ef9140329c0aa7889" translate="yes" xml:space="preserve">
          <source>In other words, the current acceleration of the sensor's rotation around the &lt;code&gt;x&lt;/code&gt;, &lt;code&gt;y&lt;/code&gt;, and &lt;code&gt;z&lt;/code&gt; axes.</source>
          <target state="translated">즉, &lt;code&gt;x&lt;/code&gt; , &lt;code&gt;y&lt;/code&gt; 및 &lt;code&gt;z&lt;/code&gt; 축을 중심으로 한 센서 회전의 현재 가속도입니다 .</target>
        </trans-unit>
        <trans-unit id="e24aa6a1d2a326510cfb988f82d3d16ac3740449" translate="yes" xml:space="preserve">
          <source>In other words, the current acceleration of the sensor, along the &lt;code&gt;x&lt;/code&gt;, &lt;code&gt;y&lt;/code&gt;, and &lt;code&gt;z&lt;/code&gt; axes.</source>
          <target state="translated">다시 말해, &lt;code&gt;x&lt;/code&gt; , &lt;code&gt;y&lt;/code&gt; 및 &lt;code&gt;z&lt;/code&gt; 축을 따라 센서의 현재 가속도입니다 .</target>
        </trans-unit>
        <trans-unit id="26342f65c936d9d1b499fb61c1d5657e37c0d6de" translate="yes" xml:space="preserve">
          <source>In other words, the current velocity at which the sensor is moving along the &lt;code&gt;x&lt;/code&gt;, &lt;code&gt;y&lt;/code&gt;, and &lt;code&gt;z&lt;/code&gt; axes.</source>
          <target state="translated">다시 말해, 센서가 &lt;code&gt;x&lt;/code&gt; , &lt;code&gt;y&lt;/code&gt; 및 &lt;code&gt;z&lt;/code&gt; 축을 따라 이동하는 현재 속도 입니다.</target>
        </trans-unit>
        <trans-unit id="c8756d342164e2002ce05df955f382173498e783" translate="yes" xml:space="preserve">
          <source>In other words, the current velocity at which the sensor is rotating around the &lt;code&gt;x&lt;/code&gt;, &lt;code&gt;y&lt;/code&gt;, and &lt;code&gt;z&lt;/code&gt; axes.</source>
          <target state="translated">다시 말해, 센서가 &lt;code&gt;x&lt;/code&gt; , &lt;code&gt;y&lt;/code&gt; 및 &lt;code&gt;z&lt;/code&gt; 축을 중심으로 회전하는 현재 속도 입니다.</target>
        </trans-unit>
        <trans-unit id="aa5bb749fa017e61f3287c0d596f0a5cd62ab091" translate="yes" xml:space="preserve">
          <source>In other words, until you've been notified that nodes are being split off from your monitored subtree, you'll get notifications of changes to that split-off subtree and its nodes. This prevents you from missing changes that occur after the connection is severed and before you have a chance to specifically begin monitoring the moved node or subtree for changes.</source>
          <target state="translated">다시 말해, 모니터링되는 하위 트리에서 노드가 분리되었다는 알림을받을 때까지 해당 분리 하위 트리 및 해당 노드의 변경 사항에 대한 알림을받습니다. 이렇게하면 연결이 끊어진 후 및 이동 된 노드 나 하위 트리에서 변경 사항을 모니터링하기 시작할 때까지 발생하는 변경 사항이 손실되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="b1886b08f743d589301dd5bab055f2e5446d6484" translate="yes" xml:space="preserve">
          <source>In our &lt;a href=&quot;http://mdn.github.io/emogotchi/&quot;&gt;Emogotchi demo&lt;/a&gt; (&lt;a href=&quot;https://github.com/mdn/emogotchi&quot;&gt;see source code&lt;/a&gt;), we run a simple &lt;code&gt;spawnNotification()&lt;/code&gt; function when we want to fire a notification &amp;mdash; this is passed arguments to specify the body, icon and title we want, then it creates the necessary &lt;code&gt;options&lt;/code&gt; object and fires the notification using the &lt;a href=&quot;notification&quot;&gt;&lt;code&gt;Notification()&lt;/code&gt;&lt;/a&gt; constructor.</source>
          <target state="translated">우리에 &lt;a href=&quot;http://mdn.github.io/emogotchi/&quot;&gt;Emogotchi 데모&lt;/a&gt; ( &lt;a href=&quot;https://github.com/mdn/emogotchi&quot;&gt;소스 코드를 참조&lt;/a&gt; ), 우리는 간단한의 실행 &lt;code&gt;spawnNotification()&lt;/code&gt; 우리는 통지를 해고하고자 할 때 기능 -이 우리가 원하는 몸, 아이콘 및 제목을 지정하는 인수를 전달, 그것은 필요한 생성 &lt;code&gt;options&lt;/code&gt; 객체 및 화재 &lt;a href=&quot;notification&quot;&gt; &lt;code&gt;Notification()&lt;/code&gt; &lt;/a&gt; 생성자를 사용한 알림</target>
        </trans-unit>
        <trans-unit id="3afbb59e3e9bdc76ed12c72cfc11652669eb6607" translate="yes" xml:space="preserve">
          <source>In our &lt;a href=&quot;http://mdn.github.io/emogotchi/&quot;&gt;Emogotchi demo&lt;/a&gt; (&lt;a href=&quot;https://github.com/mdn/emogotchi&quot;&gt;see source code&lt;/a&gt;), we run a simple &lt;code&gt;spawnNotification()&lt;/code&gt; function when we want to fire a notification &amp;mdash; this is passed arguments to specify the body, icon and title we want, then it creates the necessary &lt;code&gt;options&lt;/code&gt; object and fires the notification using the &lt;code&gt;Notification()&lt;/code&gt; constructor.</source>
          <target state="translated">우리에 &lt;a href=&quot;http://mdn.github.io/emogotchi/&quot;&gt;Emogotchi 데모&lt;/a&gt; ( &lt;a href=&quot;https://github.com/mdn/emogotchi&quot;&gt;소스 코드를 참조&lt;/a&gt; ), 우리는 간단한의 실행 &lt;code&gt;spawnNotification()&lt;/code&gt; 우리는 통지를 해고하고자 할 때 기능 -이 우리가 원하는 몸, 아이콘 및 제목을 지정하는 인수를 전달, 그것은 필요한 생성 &lt;code&gt;options&lt;/code&gt; 객체 및 화재 &lt;code&gt;Notification()&lt;/code&gt; 생성자를 사용한 알림</target>
        </trans-unit>
        <trans-unit id="90d003531c911f7be4dd1c486c92d6ac6b8bf562" translate="yes" xml:space="preserve">
          <source>In our &lt;a href=&quot;http://mdn.github.io/fetch-examples/fetch-array-buffer/&quot;&gt;fetch array buffer live&lt;/a&gt;, we have a Play button. When pressed, the &lt;code&gt;getData()&lt;/code&gt; function is run. Note that before playing full audio file will be downloaded. If you need to play ogg during downloading (stream it) - consider &lt;a href=&quot;../htmlaudioelement&quot;&gt;&lt;code&gt;HTMLAudioElement&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">우리에서 &lt;a href=&quot;http://mdn.github.io/fetch-examples/fetch-array-buffer/&quot;&gt;라이브 버퍼 가져 배열&lt;/a&gt; , 우리는 재생 버튼을 가지고있다. 누르면 &lt;code&gt;getData()&lt;/code&gt; 함수가 실행됩니다. 전체 오디오 파일을 재생하기 전에 다운로드됩니다. 다운로드하는 동안 ogg를 재생해야하는 경우 (스트리밍) &lt;a href=&quot;../htmlaudioelement&quot;&gt; &lt;code&gt;HTMLAudioElement&lt;/code&gt; &lt;/a&gt; 고려 하십시오 .</target>
        </trans-unit>
        <trans-unit id="3473029b722643bd0de6270c006a9471e3640d38" translate="yes" xml:space="preserve">
          <source>In our &lt;a href=&quot;https://github.com/mdn/dom-examples/tree/master/scrolltooptions&quot;&gt;scrolltooptions example&lt;/a&gt; (&lt;a href=&quot;https://mdn.github.io/dom-examples/scrolltooptions/&quot;&gt;see it live&lt;/a&gt;) we include a form that allows the user to enter three values &amp;mdash; two numbers representing the left and top properties (i.e. the positions to scroll to along the X and Y axes), and a checkbox indicating whether they want smooth scrolling enabled or not.</source>
          <target state="translated">우리에 &lt;a href=&quot;https://github.com/mdn/dom-examples/tree/master/scrolltooptions&quot;&gt;scrolltooptions 예제&lt;/a&gt; ( &lt;a href=&quot;https://mdn.github.io/dom-examples/scrolltooptions/&quot;&gt;이 살고 볼&lt;/a&gt; 우리는 사용자가 세 가지 값을 입력 할 수있는 양식 포함) - (X 및 Y 축을 따라으로 스크롤 즉, 위치)를 왼쪽과 위쪽 속성을 나타내는 두 개의 번호를, 및 체크 박스가 있는지 여부를 나타내는 그들은 부드러운 스크롤을 가능하게하거나 원하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="c64086b9539917286e2d87d93d5db7c8c949df9f" translate="yes" xml:space="preserve">
          <source>In our &lt;a href=&quot;https://github.com/mdn/dom-examples/tree/master/streams&quot;&gt;dom-examples/streams&lt;/a&gt; repo you&amp;rsquo;ll find a &lt;a href=&quot;https://github.com/mdn/dom-examples/blob/master/streams/simple-writer/index.html&quot;&gt;Simple writer example&lt;/a&gt; (&lt;a href=&quot;https://mdn.github.io/dom-examples/streams/simple-writer/&quot;&gt;see it live also&lt;/a&gt;). This takes a given message and writes it into a writable stream, displaying each chunk on the UI as it is written to the stream and also displaying the whole message on the UI when writing has finished.</source>
          <target state="translated">우리의 &lt;a href=&quot;https://github.com/mdn/dom-examples/tree/master/streams&quot;&gt;dom-examples / streams&lt;/a&gt; repo에는 &lt;a href=&quot;https://github.com/mdn/dom-examples/blob/master/streams/simple-writer/index.html&quot;&gt;Simple writer 예제가 있습니다&lt;/a&gt; ( &lt;a href=&quot;https://mdn.github.io/dom-examples/streams/simple-writer/&quot;&gt;실제로 참조하십시오&lt;/a&gt; ). 이것은 주어진 메시지를 가져 와서 쓰기 가능한 스트림에 기록하며, 스트림에 기록 될 때 UI에 각 청크를 표시하고 쓰기가 완료되면 UI에 전체 메시지를 표시합니다.</target>
        </trans-unit>
        <trans-unit id="85832bf0175fde6ba53c86bd83b82b6cef373f12" translate="yes" xml:space="preserve">
          <source>In our &lt;a href=&quot;https://github.com/mdn/fetch-examples/blob/master/fetch-with-init-then-request/index.html&quot;&gt;Fetch with init then Request example&lt;/a&gt; (see &lt;a href=&quot;https://mdn.github.io/fetch-examples/fetch-with-init-then-request/&quot;&gt;Fetch Request init live&lt;/a&gt;) we do the same thing except that we pass in an init object when we invoke &lt;code&gt;fetch()&lt;/code&gt;:</source>
          <target state="translated">우리에서하면 &lt;a href=&quot;https://github.com/mdn/fetch-examples/blob/master/fetch-with-init-then-request/index.html&quot;&gt;다음 요청 예를 초기화로 가져 오기&lt;/a&gt; (참조 &lt;a href=&quot;https://mdn.github.io/fetch-examples/fetch-with-init-then-request/&quot;&gt;라이브 초기화 요청을 가져 오기&lt;/a&gt; 우리는 우리가 호출 할 때 우리는 초기화 객체를 전달하는 것을 제외하고 같은 일을) &lt;code&gt;fetch()&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="5332e06ca745e4910ad89f54152ef29d7fe3c242" translate="yes" xml:space="preserve">
          <source>In our &lt;a href=&quot;https://github.com/mdn/fetch-examples/tree/gh-pages/fetch-request&quot;&gt;fetch request example&lt;/a&gt; (run &lt;a href=&quot;http://mdn.github.io/fetch-examples/fetch-request/&quot;&gt;fetch request live&lt;/a&gt;), we create a new request using the &lt;a href=&quot;../request/request&quot;&gt;&lt;code&gt;Request.Request&lt;/code&gt;&lt;/a&gt; constructor, then use it to fetch a JPG. When the fetch is successful, we read a &lt;a href=&quot;../blob&quot;&gt;&lt;code&gt;Blob&lt;/code&gt;&lt;/a&gt; out of the response using &lt;code&gt;blob()&lt;/code&gt;, put it into an object URL using &lt;a href=&quot;../url/createobjecturl&quot;&gt;&lt;code&gt;URL.createObjectURL&lt;/code&gt;&lt;/a&gt;, and then set that URL as the source of an &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/img&quot;&gt;&lt;code&gt;&amp;lt;img&amp;gt;&lt;/code&gt;&lt;/a&gt; element to display the image.</source>
          <target state="translated">우리에서 &lt;a href=&quot;https://github.com/mdn/fetch-examples/tree/gh-pages/fetch-request&quot;&gt;가져 오기 요청의 예&lt;/a&gt; (실행 &lt;a href=&quot;http://mdn.github.io/fetch-examples/fetch-request/&quot;&gt;라이브 요청을 가져&lt;/a&gt; , 우리가 사용하여 새 요청 작성) &lt;a href=&quot;../request/request&quot;&gt; &lt;code&gt;Request.Request&lt;/code&gt; &lt;/a&gt; 다음, 생성자를 JPG를 가져 오기 위해 그것을 사용할 수 있습니다. 가져 오기에 성공 하면 &lt;code&gt;blob()&lt;/code&gt; 사용하여 응답 에서 &lt;a href=&quot;../blob&quot;&gt; &lt;code&gt;Blob&lt;/code&gt; &lt;/a&gt; 을 읽고 &lt;a href=&quot;../url/createobjecturl&quot;&gt; &lt;code&gt;URL.createObjectURL&lt;/code&gt; 을&lt;/a&gt; 사용하여 객체 URL에 넣은 다음 해당 URL을 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/img&quot;&gt; &lt;code&gt;&amp;lt;img&amp;gt;&lt;/code&gt; &lt;/a&gt; 요소 의 소스로 설정 하여 이미지를 표시합니다.</target>
        </trans-unit>
        <trans-unit id="981ffc61170f85abb6ad923d558244f17fb966ec" translate="yes" xml:space="preserve">
          <source>In our &lt;a href=&quot;https://github.com/mdn/fetch-examples/tree/gh-pages/fetch-response&quot;&gt;Fetch Response example&lt;/a&gt; (see &lt;a href=&quot;http://mdn.github.io/fetch-examples/fetch-response/&quot;&gt;Fetch Response live&lt;/a&gt;) we create a new &lt;a href=&quot;../request&quot;&gt;&lt;code&gt;Request&lt;/code&gt;&lt;/a&gt; object using the &lt;a href=&quot;../request/request&quot;&gt;&lt;code&gt;Request()&lt;/code&gt;&lt;/a&gt; constructor, passing it a JPG path. We then fetch this request using &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/GlobalFetch/fetch&quot;&gt;&lt;code&gt;fetch()&lt;/code&gt;&lt;/a&gt;, extract a blob from the response using &lt;a href=&quot;../body/blob&quot;&gt;&lt;code&gt;Body.blob&lt;/code&gt;&lt;/a&gt;, create an object URL out of it using &lt;a href=&quot;../url/createobjecturl&quot;&gt;&lt;code&gt;URL.createObjectURL&lt;/code&gt;&lt;/a&gt;, and display this in an &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/img&quot;&gt;&lt;code&gt;&amp;lt;img&amp;gt;&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">우리에서 &lt;a href=&quot;https://github.com/mdn/fetch-examples/tree/gh-pages/fetch-response&quot;&gt;가져 오기 응답 예&lt;/a&gt; (참조 &lt;a href=&quot;http://mdn.github.io/fetch-examples/fetch-response/&quot;&gt;라이브 응답을 가져 오기&lt;/a&gt; 우리는 새로운 생성) &lt;a href=&quot;../request&quot;&gt; &lt;code&gt;Request&lt;/code&gt; &lt;/a&gt; 사용하여 객체 &lt;a href=&quot;../request/request&quot;&gt; &lt;code&gt;Request()&lt;/code&gt; &lt;/a&gt; 그것을 JPG 경로를 통과, 생성자를. 우리는 다음 사용 요청 페치 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/GlobalFetch/fetch&quot;&gt; &lt;code&gt;fetch()&lt;/code&gt; &lt;/a&gt; 사용하여 응답으로부터의 Blob 추출 &lt;a href=&quot;../body/blob&quot;&gt; &lt;code&gt;Body.blob&lt;/code&gt; 을&lt;/a&gt; 그것이 사용하는 URL 객체를 생성 &lt;a href=&quot;../url/createobjecturl&quot;&gt; &lt;code&gt;URL.createObjectURL&lt;/code&gt; 를&lt;/a&gt; , 및이 표시 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/img&quot;&gt; &lt;code&gt;&amp;lt;img&amp;gt;&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="32986a6f47816d4bd1d2722cbc2f89d5eb06ee4c" translate="yes" xml:space="preserve">
          <source>In our &lt;a href=&quot;https://github.com/mdn/fetch-examples/tree/gh-pages/fetch-response-clone&quot;&gt;Fetch Response clone example&lt;/a&gt; (see &lt;a href=&quot;http://mdn.github.io/fetch-examples/fetch-response-clone/&quot;&gt;Fetch Response clone live&lt;/a&gt;) we create a new &lt;a href=&quot;../request&quot;&gt;&lt;code&gt;Request&lt;/code&gt;&lt;/a&gt; object using the &lt;a href=&quot;../request/request&quot;&gt;&lt;code&gt;Request()&lt;/code&gt;&lt;/a&gt; constructor, passing it a JPG path. We then fetch this request using &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/GlobalFetch/fetch&quot;&gt;&lt;code&gt;fetch()&lt;/code&gt;&lt;/a&gt;. When the fetch resolves successfully, we clone it, extract a blob from both responses using two &lt;a href=&quot;../body/blob&quot;&gt;&lt;code&gt;Body.blob&lt;/code&gt;&lt;/a&gt; calls, create object URLs out of the blobs using &lt;a href=&quot;../url/createobjecturl&quot;&gt;&lt;code&gt;URL.createObjectURL&lt;/code&gt;&lt;/a&gt;, and display them in two separate &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/img&quot;&gt;&lt;code&gt;&amp;lt;img&amp;gt;&lt;/code&gt;&lt;/a&gt; elements.</source>
          <target state="translated">우리에서 &lt;a href=&quot;https://github.com/mdn/fetch-examples/tree/gh-pages/fetch-response-clone&quot;&gt;가져 오기 응답 복제 예&lt;/a&gt; (참조 &lt;a href=&quot;http://mdn.github.io/fetch-examples/fetch-response-clone/&quot;&gt;라이브 응답 복제 가져 오기&lt;/a&gt; 우리는 새로운 생성) &lt;a href=&quot;../request&quot;&gt; &lt;code&gt;Request&lt;/code&gt; &lt;/a&gt; 사용하여 객체 &lt;a href=&quot;../request/request&quot;&gt; &lt;code&gt;Request()&lt;/code&gt; &lt;/a&gt; 그것을 JPG 경로를 통과, 생성자를. 그런 다음 fetch &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/GlobalFetch/fetch&quot;&gt; &lt;code&gt;fetch()&lt;/code&gt; &lt;/a&gt; 사용하여이 요청을 가져옵니다 . 가져 오기가 성공적으로 해결되면이를 복제하고 두 개의 &lt;a href=&quot;../body/blob&quot;&gt; &lt;code&gt;Body.blob&lt;/code&gt; &lt;/a&gt; 호출을 사용하여 두 응답에서 블로 브를 추출하고 URL.createObjectURL을 사용하여 블로 브에서 객체 URL을 &lt;a href=&quot;../url/createobjecturl&quot;&gt; &lt;code&gt;URL.createObjectURL&lt;/code&gt; &lt;/a&gt; 두 개의 개별 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/img&quot;&gt; &lt;code&gt;&amp;lt;img&amp;gt;&lt;/code&gt; &lt;/a&gt; 요소 에 표시합니다 .</target>
        </trans-unit>
        <trans-unit id="d92cc65101815d73ef9b8d0210a121eef752599a" translate="yes" xml:space="preserve">
          <source>In our &lt;a href=&quot;https://github.com/mdn/fetch-examples/tree/master/basic-fetch&quot;&gt;basic fetch example&lt;/a&gt; (&lt;a href=&quot;http://mdn.github.io/fetch-examples/basic-fetch/&quot;&gt;run example live&lt;/a&gt;) we use a simple &lt;code&gt;fetch()&lt;/code&gt; call to grab an image and display it in an &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/img&quot;&gt;&lt;code&gt;&amp;lt;img&amp;gt;&lt;/code&gt;&lt;/a&gt; tag. The &lt;code&gt;fetch()&lt;/code&gt; call returns a promise, which resolves with the &lt;code&gt;Response&lt;/code&gt; object associated with the resource fetch operation. You'll notice that since we are requesting an image, we need to run &lt;a href=&quot;body/blob&quot;&gt;&lt;code&gt;Body.blob&lt;/code&gt;&lt;/a&gt; (&lt;a href=&quot;response&quot;&gt;&lt;code&gt;Response&lt;/code&gt;&lt;/a&gt; implements body) to give the response its correct MIME type.</source>
          <target state="translated">우리에서 &lt;a href=&quot;https://github.com/mdn/fetch-examples/tree/master/basic-fetch&quot;&gt;기본 가져 오기 예&lt;/a&gt; ( &lt;a href=&quot;http://mdn.github.io/fetch-examples/basic-fetch/&quot;&gt;실제 실행 예&lt;/a&gt; ) 우리는 간단한 사용 &lt;code&gt;fetch()&lt;/code&gt; 이미지를 잡아와에 표시하는 전화를 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/img&quot;&gt; &lt;code&gt;&amp;lt;img&amp;gt;&lt;/code&gt; &lt;/a&gt; 태그입니다. 는 &lt;code&gt;fetch()&lt;/code&gt; 호출 반환에 해결하는 약속, &lt;code&gt;Response&lt;/code&gt; 자원과 관련된 개체가 작업을 가져 오기를. 이미지를 요청하고 있기 때문에 응답에 올바른 MIME 유형을 제공하려면 &lt;a href=&quot;body/blob&quot;&gt; &lt;code&gt;Body.blob&lt;/code&gt; &lt;/a&gt; ( &lt;a href=&quot;response&quot;&gt; &lt;code&gt;Response&lt;/code&gt; &lt;/a&gt; 구현 본문)를 실행해야 합니다.</target>
        </trans-unit>
        <trans-unit id="f5a5837fac2c53936e626ad72a9dc42b1ca8ce3d" translate="yes" xml:space="preserve">
          <source>In our &lt;a href=&quot;https://github.com/mdn/fetch-examples/tree/master/fetch-json&quot;&gt;fetch json example&lt;/a&gt; (run &lt;a href=&quot;http://mdn.github.io/fetch-examples/fetch-json/&quot;&gt;fetch json live&lt;/a&gt;), we create a new request using the &lt;a href=&quot;../request/request&quot;&gt;&lt;code&gt;Request.Request&lt;/code&gt;&lt;/a&gt; constructor, then use it to fetch a &lt;code&gt;.json&lt;/code&gt; file. When the fetch is successful, we read and parse the data using &lt;code&gt;json()&lt;/code&gt;, then read values out of the resulting objects as you'd expect and insert them into list items to display our product data.</source>
          <target state="translated">우리에서 &lt;a href=&quot;https://github.com/mdn/fetch-examples/tree/master/fetch-json&quot;&gt;JSON 가져 오기 예&lt;/a&gt; (실행은 &lt;a href=&quot;http://mdn.github.io/fetch-examples/fetch-json/&quot;&gt;라이브를 JSON 가져&lt;/a&gt; 우리가 사용하여 새 요청 작성) &lt;a href=&quot;../request/request&quot;&gt; &lt;code&gt;Request.Request&lt;/code&gt; &lt;/a&gt; 페치하는 데 사용할 다음, 생성자를 &lt;code&gt;.json&lt;/code&gt; 의 파일을. 가져 오기가 성공하면 &lt;code&gt;json()&lt;/code&gt; 사용하여 데이터를 읽고 구문 분석 한 다음 예상대로 결과 객체에서 값을 읽고 목록 데이터에 삽입하여 제품 데이터를 표시합니다.</target>
        </trans-unit>
        <trans-unit id="33598b258d8cdb59feb13ce2af053fa7a45fa3e5" translate="yes" xml:space="preserve">
          <source>In our &lt;a href=&quot;https://github.com/mdn/fetch-examples/tree/master/fetch-request&quot;&gt;Fetch Request example&lt;/a&gt; (see &lt;a href=&quot;http://mdn.github.io/fetch-examples/fetch-request/&quot;&gt;Fetch Request live&lt;/a&gt;) we create a new &lt;code&gt;Request&lt;/code&gt; object using the constructor, then fetch it using a &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/GlobalFetch/fetch&quot;&gt;&lt;code&gt;GlobalFetch.fetch&lt;/code&gt;&lt;/a&gt; call. Since we are fetching an image, we run &lt;a href=&quot;../body/blob&quot;&gt;&lt;code&gt;Body.blob&lt;/code&gt;&lt;/a&gt; on the response to give it the proper MIME type so it will be handled properly, then create an Object URL of it and display it in an &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/img&quot;&gt;&lt;code&gt;&amp;lt;img&amp;gt;&lt;/code&gt;&lt;/a&gt; element.</source>
          <target state="translated">우리에서 &lt;a href=&quot;https://github.com/mdn/fetch-examples/tree/master/fetch-request&quot;&gt;가져 오기 요청의 예&lt;/a&gt; (참조 &lt;a href=&quot;http://mdn.github.io/fetch-examples/fetch-request/&quot;&gt;라이브 요청을 가져 오기&lt;/a&gt; 우리는 새로운 생성) &lt;code&gt;Request&lt;/code&gt; 생성자를 사용하여 객체를 한 후 사용하여 가져 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/GlobalFetch/fetch&quot;&gt; &lt;code&gt;GlobalFetch.fetch&lt;/code&gt; 의&lt;/a&gt; 전화를. 이미지를 가져 오기 때문에 응답에 &lt;a href=&quot;../body/blob&quot;&gt; &lt;code&gt;Body.blob&lt;/code&gt; &lt;/a&gt; 를 실행 하여 적절한 MIME 유형을 지정하여 올바르게 처리 한 다음 객체 URL을 만들어 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/img&quot;&gt; &lt;code&gt;&amp;lt;img&amp;gt;&lt;/code&gt; &lt;/a&gt; 요소 에 표시합니다 .</target>
        </trans-unit>
        <trans-unit id="1ac15390cc020979be92c6b7e3dd8af32b67ef87" translate="yes" xml:space="preserve">
          <source>In our &lt;a href=&quot;https://github.com/mdn/fetch-examples/tree/master/fetch-request&quot;&gt;Fetch Request example&lt;/a&gt; (see &lt;a href=&quot;https://mdn.github.io/fetch-examples/fetch-request/&quot;&gt;Fetch Request live&lt;/a&gt;) we create a new &lt;a href=&quot;../request&quot;&gt;&lt;code&gt;Request&lt;/code&gt;&lt;/a&gt; object using the relevant constructor, then fetch it using a &lt;code&gt;fetch()&lt;/code&gt; call. Since we are fetching an image, we run &lt;a href=&quot;../body/blob&quot;&gt;&lt;code&gt;Body.blob()&lt;/code&gt;&lt;/a&gt; on the response to give it the proper MIME type so it will be handled properly, then create an Object URL of it and display it in an &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/img&quot;&gt;&lt;code&gt;&amp;lt;img&amp;gt;&lt;/code&gt;&lt;/a&gt; element.</source>
          <target state="translated">우리에서 &lt;a href=&quot;https://github.com/mdn/fetch-examples/tree/master/fetch-request&quot;&gt;가져 오기 요청의 예&lt;/a&gt; (참조 &lt;a href=&quot;https://mdn.github.io/fetch-examples/fetch-request/&quot;&gt;라이브 요청을 가져 오기&lt;/a&gt; 우리는 새로운 생성) &lt;a href=&quot;../request&quot;&gt; &lt;code&gt;Request&lt;/code&gt; &lt;/a&gt; 관련 생성자를 사용하여 객체를 한 후 사용하여 가져 오기 &lt;code&gt;fetch()&lt;/code&gt; 호출. 이미지를 가져 오기 때문에 응답에서 &lt;a href=&quot;../body/blob&quot;&gt; &lt;code&gt;Body.blob()&lt;/code&gt; &lt;/a&gt; 를 실행 하여 적절한 MIME 유형을 지정하여 올바르게 처리 한 다음 객체 URL을 만들어 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/img&quot;&gt; &lt;code&gt;&amp;lt;img&amp;gt;&lt;/code&gt; &lt;/a&gt; 요소 에 표시합니다 .</target>
        </trans-unit>
        <trans-unit id="9b73fce4a7cf8dd740fcaa9165fde287eca56939" translate="yes" xml:space="preserve">
          <source>In our &lt;a href=&quot;https://github.com/mdn/fetch-examples/tree/master/fetch-request&quot;&gt;fetch request example&lt;/a&gt; (run &lt;a href=&quot;http://mdn.github.io/fetch-examples/fetch-request/&quot;&gt;fetch request live&lt;/a&gt;), we create a new request using the &lt;a href=&quot;../request/request&quot;&gt;&lt;code&gt;Request.Request&lt;/code&gt;&lt;/a&gt; constructor, then use it to fetch a JPG. When the fetch is successful, we read a &lt;a href=&quot;../blob&quot;&gt;&lt;code&gt;Blob&lt;/code&gt;&lt;/a&gt; out of the response using &lt;code&gt;blob()&lt;/code&gt;, put it into an object URL using &lt;a href=&quot;../url/createobjecturl&quot;&gt;&lt;code&gt;URL.createObjectURL&lt;/code&gt;&lt;/a&gt;, and then set that URL as the source of an &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/img&quot;&gt;&lt;code&gt;&amp;lt;img&amp;gt;&lt;/code&gt;&lt;/a&gt; element to display the image.</source>
          <target state="translated">우리에서 &lt;a href=&quot;https://github.com/mdn/fetch-examples/tree/master/fetch-request&quot;&gt;가져 오기 요청의 예&lt;/a&gt; (실행 &lt;a href=&quot;http://mdn.github.io/fetch-examples/fetch-request/&quot;&gt;라이브 요청을 가져&lt;/a&gt; , 우리가 사용하여 새 요청 작성) &lt;a href=&quot;../request/request&quot;&gt; &lt;code&gt;Request.Request&lt;/code&gt; &lt;/a&gt; 다음, 생성자를 JPG를 가져 오기 위해 그것을 사용할 수 있습니다. 가져 오기에 성공 하면 &lt;code&gt;blob()&lt;/code&gt; 사용하여 응답 에서 &lt;a href=&quot;../blob&quot;&gt; &lt;code&gt;Blob&lt;/code&gt; &lt;/a&gt; 을 읽고 &lt;a href=&quot;../url/createobjecturl&quot;&gt; &lt;code&gt;URL.createObjectURL&lt;/code&gt; 을&lt;/a&gt; 사용하여 객체 URL에 넣은 다음 해당 URL을 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/img&quot;&gt; &lt;code&gt;&amp;lt;img&amp;gt;&lt;/code&gt; &lt;/a&gt; 요소 의 소스로 설정 하여 이미지를 표시합니다.</target>
        </trans-unit>
        <trans-unit id="e49ee4ec9b5aad393af7294108af5db41d880394" translate="yes" xml:space="preserve">
          <source>In our &lt;a href=&quot;https://github.com/mdn/fetch-examples/tree/master/fetch-request-with-init&quot;&gt;Fetch Request with init example&lt;/a&gt; (see &lt;a href=&quot;http://mdn.github.io/fetch-examples/fetch-request-with-init/&quot;&gt;Fetch Request init live&lt;/a&gt;) we do the same thing except that we pass in an init object when we invoke &lt;code&gt;fetch()&lt;/code&gt;:</source>
          <target state="translated">우리에 &lt;a href=&quot;https://github.com/mdn/fetch-examples/tree/master/fetch-request-with-init&quot;&gt;초기화 예와 가져 오기 요청&lt;/a&gt; (참조 &lt;a href=&quot;http://mdn.github.io/fetch-examples/fetch-request-with-init/&quot;&gt;라이브 초기화 요청을 가져 오기&lt;/a&gt; 우리는 우리가 호출 할 때 우리는 초기화 객체를 전달하는 것을 제외하고 같은 일을) &lt;code&gt;fetch()&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="fa15d07ba21295882ff149b53a3dba8adc14c5dc" translate="yes" xml:space="preserve">
          <source>In our &lt;a href=&quot;https://github.com/mdn/fetch-examples/tree/master/fetch-response&quot;&gt;Fetch Response example&lt;/a&gt; (see &lt;a href=&quot;http://mdn.github.io/fetch-examples/fetch-response/&quot;&gt;Fetch Response live&lt;/a&gt;) we create a new &lt;a href=&quot;../request&quot;&gt;&lt;code&gt;Request&lt;/code&gt;&lt;/a&gt; object using the &lt;a href=&quot;../request/request&quot;&gt;&lt;code&gt;Request()&lt;/code&gt;&lt;/a&gt; constructor, passing it a JPG path. We then fetch this request using &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/GlobalFetch/fetch&quot;&gt;&lt;code&gt;fetch()&lt;/code&gt;&lt;/a&gt;, extract a blob from the response using &lt;a href=&quot;../body/blob&quot;&gt;&lt;code&gt;Body.blob&lt;/code&gt;&lt;/a&gt;, create an object URL out of it using &lt;a href=&quot;../url/createobjecturl&quot;&gt;&lt;code&gt;URL.createObjectURL&lt;/code&gt;&lt;/a&gt;, and display this in an &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/img&quot;&gt;&lt;code&gt;&amp;lt;img&amp;gt;&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">우리에서 &lt;a href=&quot;https://github.com/mdn/fetch-examples/tree/master/fetch-response&quot;&gt;가져 오기 응답 예&lt;/a&gt; (참조 &lt;a href=&quot;http://mdn.github.io/fetch-examples/fetch-response/&quot;&gt;라이브 응답을 가져 오기&lt;/a&gt; 우리는 새로운 생성) &lt;a href=&quot;../request&quot;&gt; &lt;code&gt;Request&lt;/code&gt; &lt;/a&gt; 사용하여 객체 &lt;a href=&quot;../request/request&quot;&gt; &lt;code&gt;Request()&lt;/code&gt; &lt;/a&gt; 그것을 JPG 경로를 통과, 생성자를. 우리는 다음 사용 요청 페치 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/GlobalFetch/fetch&quot;&gt; &lt;code&gt;fetch()&lt;/code&gt; &lt;/a&gt; 사용하여 응답으로부터의 Blob 추출 &lt;a href=&quot;../body/blob&quot;&gt; &lt;code&gt;Body.blob&lt;/code&gt; 을&lt;/a&gt; 그것이 사용하는 URL 객체를 생성 &lt;a href=&quot;../url/createobjecturl&quot;&gt; &lt;code&gt;URL.createObjectURL&lt;/code&gt; 를&lt;/a&gt; , 및이 표시 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/img&quot;&gt; &lt;code&gt;&amp;lt;img&amp;gt;&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="665c8210d0a86cdfd980ce3198e2c1e460bd929c" translate="yes" xml:space="preserve">
          <source>In our &lt;a href=&quot;https://github.com/mdn/fetch-examples/tree/master/fetch-response&quot;&gt;Fetch Response example&lt;/a&gt; (see &lt;a href=&quot;http://mdn.github.io/fetch-examples/fetch-response/&quot;&gt;Fetch Response live&lt;/a&gt;) we create a new &lt;code&gt;Response&lt;/code&gt; object using the constructor, passing it a new &lt;a href=&quot;../blob&quot;&gt;&lt;code&gt;Blob&lt;/code&gt;&lt;/a&gt; as a body, and an init object containing a custom &lt;code&gt;status&lt;/code&gt; and &lt;code&gt;statusText&lt;/code&gt;:</source>
          <target state="translated">우리에 &lt;a href=&quot;https://github.com/mdn/fetch-examples/tree/master/fetch-response&quot;&gt;응답 예를 가져 오기&lt;/a&gt; (참조 &lt;a href=&quot;http://mdn.github.io/fetch-examples/fetch-response/&quot;&gt;라이브 응답을 가져 오기&lt;/a&gt; 우리는 새로운 생성) &lt;code&gt;Response&lt;/code&gt; 그것에게 새로운 전달하는 생성자를 사용하여 객체를 &lt;a href=&quot;../blob&quot;&gt; &lt;code&gt;Blob&lt;/code&gt; &lt;/a&gt; 몸으로, 그리고 사용자 정의가 포함 된 초기화 객체 &lt;code&gt;status&lt;/code&gt; 와 &lt;code&gt;statusText&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="96e27f02256264c5a91b2636219a5045584adc7e" translate="yes" xml:space="preserve">
          <source>In our &lt;a href=&quot;https://github.com/mdn/fetch-examples/tree/master/fetch-text&quot;&gt;fetch text example&lt;/a&gt; (run &lt;a href=&quot;http://mdn.github.io/fetch-examples/fetch-text/&quot;&gt;fetch text live&lt;/a&gt;), we have an &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/article&quot;&gt;&lt;code&gt;&amp;lt;article&amp;gt;&lt;/code&gt;&lt;/a&gt; element and three links (stored in the &lt;code&gt;myLinks&lt;/code&gt; array.) First, we loop through all of these and give each one an &lt;code&gt;onclick&lt;/code&gt; event handler so that the &lt;code&gt;getData()&lt;/code&gt; function is run &amp;mdash; with the link's &lt;code&gt;data-page&lt;/code&gt; identifier passed to it as an argument &amp;mdash; when one of the links is clicked.</source>
          <target state="translated">우리에서 &lt;a href=&quot;https://github.com/mdn/fetch-examples/tree/master/fetch-text&quot;&gt;가져 오기 텍스트 예&lt;/a&gt; (실행은 &lt;a href=&quot;http://mdn.github.io/fetch-examples/fetch-text/&quot;&gt;라이브 텍스트를 취득&lt;/a&gt; , 우리가 가지고) &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/article&quot;&gt; &lt;code&gt;&amp;lt;article&amp;gt;&lt;/code&gt; &lt;/a&gt; (에 기억 요소와 세 개의 링크 &lt;code&gt;myLinks&lt;/code&gt; 의 이 모든 통해. 배열) 첫째, 우리는 루프를 각각 One을주고 &lt;code&gt;onclick&lt;/code&gt; 그래서 이벤트 핸들러를 &lt;code&gt;getData()&lt;/code&gt; 링크 중 하나를 클릭하면 링크의 &lt;code&gt;data-page&lt;/code&gt; 식별자가 인수로 전달 된 () 함수가 실행 됩니다.</target>
        </trans-unit>
        <trans-unit id="c74a1899d542a1f17ec28a78d061c7d3c322554c" translate="yes" xml:space="preserve">
          <source>In our &lt;a href=&quot;https://github.com/mdn/simple-shared-worker&quot;&gt;Basic shared worker example&lt;/a&gt; (&lt;a href=&quot;http://mdn.github.io/simple-shared-worker/&quot;&gt;run shared worker&lt;/a&gt;), we have two HTML pages, each of which uses some JavaScript to perform a simple calculation. The different scripts are using the same worker file to perform the calculation &amp;mdash; they can both access it, even if their pages are running inside different windows.</source>
          <target state="translated">우리에서 &lt;a href=&quot;https://github.com/mdn/simple-shared-worker&quot;&gt;기본 작업자 예를 공유&lt;/a&gt; ( &lt;a href=&quot;http://mdn.github.io/simple-shared-worker/&quot;&gt;공유 근로자를 실행&lt;/a&gt; ), 우리는 간단한 계산을 수행하기 위해 몇 가지 자바 스크립트를 사용하여 각각 두 개의 HTML 페이지를 가지고 있습니다. 다른 스크립트는 동일한 작업자 파일을 사용하여 계산을 수행합니다. 페이지가 다른 창에서 실행중인 경우에도 둘 다 액세스 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1a52dcb200ff811c53a01149609f176603f2ec40" translate="yes" xml:space="preserve">
          <source>In our &lt;a href=&quot;https://github.com/mdn/web-components-examples/tree/master/simple-template&quot;&gt;simple-template example&lt;/a&gt; (&lt;a href=&quot;https://mdn.github.io/web-components-examples/simple-template/&quot;&gt;see it live&lt;/a&gt;), we create a trivial custom element example called &lt;code&gt;&amp;lt;my-paragraph&amp;gt;&lt;/code&gt; in which a shadow root is attached and then populated using the contents of a template that contains a slot named &lt;code&gt;my-text&lt;/code&gt;.</source>
          <target state="translated">우리에서 &lt;a href=&quot;https://github.com/mdn/web-components-examples/tree/master/simple-template&quot;&gt;간단한 템플릿 예제&lt;/a&gt; ( &lt;a href=&quot;https://mdn.github.io/web-components-examples/simple-template/&quot;&gt;이 살고 참조&lt;/a&gt; ), 우리라는 사소한 사용자 정의 요소 예제를 만들 &lt;code&gt;&amp;lt;my-paragraph&amp;gt;&lt;/code&gt; 그림자 루트가 연결된 후라는 슬롯이 포함 된 템플릿의 내용을 사용하여 채워되는 &lt;code&gt;my-text&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7d243b03f6d86fe5242e67b052f046fa1fec14bc" translate="yes" xml:space="preserve">
          <source>In our &lt;a href=&quot;https://mdn.github.io/dom-examples/screenleft-screentop/&quot;&gt;screenleft-screentop&lt;/a&gt; example, you'll see a canvas onto which has been drawn a circle. In this example we are using &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/window/screenLeft&quot;&gt;&lt;code&gt;Window.screenLeft&lt;/code&gt;&lt;/a&gt;/&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/window/screenTop&quot;&gt;&lt;code&gt;Window.screenTop&lt;/code&gt;&lt;/a&gt; plus &lt;a href=&quot;requestanimationframe&quot;&gt;&lt;code&gt;Window.requestAnimationFrame()&lt;/code&gt;&lt;/a&gt; to constantly redraw the circle in the same physical position on the screen, even if the window position is moved.</source>
          <target state="translated">우리에 &lt;a href=&quot;https://mdn.github.io/dom-examples/screenleft-screentop/&quot;&gt;screenleft - screentop의&lt;/a&gt; 예를 들어, 당신은 원을 그려 된에 캔버스를 볼 수 있습니다. 이 예제에서는 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/window/screenLeft&quot;&gt; &lt;code&gt;Window.screenLeft&lt;/code&gt; &lt;/a&gt; / &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/window/screenTop&quot;&gt; &lt;code&gt;Window.screenTop&lt;/code&gt; &lt;/a&gt; 와 &lt;a href=&quot;requestanimationframe&quot;&gt; &lt;code&gt;Window.requestAnimationFrame()&lt;/code&gt; &lt;/a&gt; 을 사용하여 창 위치가 이동하더라도 화면에서 동일한 물리적 위치에서 원을 지속적으로 다시 그립니다.</target>
        </trans-unit>
        <trans-unit id="74c680f742b2a10e14602c5e84ba9854962bbedf" translate="yes" xml:space="preserve">
          <source>In our &lt;a href=&quot;https://mdn.github.io/dom-examples/screenleft-screentop/&quot;&gt;screenleft-screentop&lt;/a&gt; example, you'll see a canvas onto which has been drawn a circle. In this example we are using &lt;code&gt;screenLeft&lt;/code&gt;/&lt;code&gt;screenTop&lt;/code&gt; plus &lt;a href=&quot;requestanimationframe&quot;&gt;&lt;code&gt;Window.requestAnimationFrame()&lt;/code&gt;&lt;/a&gt; to constantly redraw the circle in the same physical position on the screen, even if the window position is moved.</source>
          <target state="translated">우리에 &lt;a href=&quot;https://mdn.github.io/dom-examples/screenleft-screentop/&quot;&gt;screenleft - screentop의&lt;/a&gt; 예를 들어, 당신은 원을 그려 된에 캔버스를 볼 수 있습니다. 이 예제에서는 &lt;code&gt;screenLeft&lt;/code&gt; / &lt;code&gt;screenTop&lt;/code&gt; plus &lt;a href=&quot;requestanimationframe&quot;&gt; &lt;code&gt;Window.requestAnimationFrame()&lt;/code&gt; &lt;/a&gt; 을 사용하여 창 위치가 이동하더라도 화면에서 동일한 물리적 위치에서 원을 지속적으로 다시 그립니다.</target>
        </trans-unit>
        <trans-unit id="6e4a5bddabd7d835f9e44b124c0a3fca92d1c53e" translate="yes" xml:space="preserve">
          <source>In our &lt;a href=&quot;https://mdn.github.io/dom-examples/streams/simple-pump.html&quot;&gt;simple stream pump&lt;/a&gt; example we fetch an image, expose the response's stream using &lt;code&gt;response.body&lt;/code&gt;, create a reader using &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Body/getReader&quot;&gt;&lt;code&gt;ReadableStream.getReader()&lt;/code&gt;&lt;/a&gt;, then enqueue that stream's chunks into a second, custom readable stream &amp;mdash; effectively creating an identical copy of the image.</source>
          <target state="translated">우리에서 &lt;a href=&quot;https://mdn.github.io/dom-examples/streams/simple-pump.html&quot;&gt;단순한 스트림 펌프&lt;/a&gt; 예 우리가 사용하는 반응의 흐름에 노출, 이미지 페치 &lt;code&gt;response.body&lt;/code&gt; 을 이용한 리더 생성 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Body/getReader&quot;&gt; &lt;code&gt;ReadableStream.getReader()&lt;/code&gt; &lt;/a&gt; 한 다음, 두 번째로 사용자가 읽을 스트림을 해당 스트림의 청크 대기열 - 효과적으로 동일한 복사본을 만드는 영상.</target>
        </trans-unit>
        <trans-unit id="22e305a832fce0d83b4f9af63ebf0741e3108c8a" translate="yes" xml:space="preserve">
          <source>In our &lt;a href=&quot;https://mdn.github.io/emogotchi/&quot;&gt;Emogotchi demo&lt;/a&gt; (&lt;a href=&quot;https://github.com/mdn/emogotchi&quot;&gt;see source code&lt;/a&gt;), we run a simple &lt;code&gt;spawnNotification()&lt;/code&gt; function when we want to fire a notification &amp;mdash; this is passed arguments to specify the body, icon and title we want, then it creates the necessary &lt;code&gt;options&lt;/code&gt; object and fires the notification using the &lt;a href=&quot;notification&quot;&gt;&lt;code&gt;Notification()&lt;/code&gt;&lt;/a&gt; constructor.</source>
          <target state="translated">우리에 &lt;a href=&quot;https://mdn.github.io/emogotchi/&quot;&gt;Emogotchi 데모&lt;/a&gt; ( &lt;a href=&quot;https://github.com/mdn/emogotchi&quot;&gt;소스 코드를 참조&lt;/a&gt; ), 우리는 간단한의 실행 &lt;code&gt;spawnNotification()&lt;/code&gt; 우리는 통지를 해고하고자 할 때 기능 -이 우리가 원하는 몸, 아이콘 및 제목을 지정하는 인수를 전달, 그것은 필요한 생성 &lt;code&gt;options&lt;/code&gt; 객체 및 화재 &lt;a href=&quot;notification&quot;&gt; &lt;code&gt;Notification()&lt;/code&gt; &lt;/a&gt; 생성자를 사용한 알림</target>
        </trans-unit>
        <trans-unit id="5448b0c22b58314f5ef162c1128a5d091ccc5e7c" translate="yes" xml:space="preserve">
          <source>In our &lt;a href=&quot;https://mdn.github.io/webaudio-examples/stereo-panner-node/&quot;&gt;StereoPannerNode example&lt;/a&gt; (&lt;a href=&quot;https://github.com/mdn/webaudio-examples/tree/master/stereo-panner-node&quot;&gt;see source code&lt;/a&gt;) HTML we have a simple &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/audio&quot;&gt;&lt;code&gt;&amp;lt;audio&amp;gt;&lt;/code&gt;&lt;/a&gt; element along with a slider &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input&quot;&gt;&lt;code&gt;&amp;lt;input&amp;gt;&lt;/code&gt;&lt;/a&gt; to increase and decrease pan value. In the JavaScript we create a &lt;a href=&quot;../mediaelementaudiosourcenode&quot;&gt;&lt;code&gt;MediaElementAudioSourceNode&lt;/code&gt;&lt;/a&gt; and a &lt;a href=&quot;../stereopannernode&quot;&gt;&lt;code&gt;StereoPannerNode&lt;/code&gt;&lt;/a&gt;, and connect the two together using the &lt;code&gt;connect() &lt;/code&gt;method. We then use an &lt;code&gt;oninput&lt;/code&gt; event handler to change the value of the &lt;a href=&quot;../stereopannernode/pan&quot;&gt;&lt;code&gt;StereoPannerNode.pan&lt;/code&gt;&lt;/a&gt; parameter and update the pan value display when the slider is moved.</source>
          <target state="translated">우리에서 &lt;a href=&quot;https://mdn.github.io/webaudio-examples/stereo-panner-node/&quot;&gt;StereoPannerNode 예&lt;/a&gt; ( &lt;a href=&quot;https://github.com/mdn/webaudio-examples/tree/master/stereo-panner-node&quot;&gt;소스 코드를 참조&lt;/a&gt; 우리가 단순 HTML) &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/audio&quot;&gt; &lt;code&gt;&amp;lt;audio&amp;gt;&lt;/code&gt; &lt;/a&gt; 슬라이더와 함께 요소 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input&quot;&gt; &lt;code&gt;&amp;lt;input&amp;gt;&lt;/code&gt; &lt;/a&gt; 증가 팬 값을 감소. JavaScript에서 &lt;a href=&quot;../mediaelementaudiosourcenode&quot;&gt; &lt;code&gt;MediaElementAudioSourceNode&lt;/code&gt; &lt;/a&gt; 와 &lt;a href=&quot;../stereopannernode&quot;&gt; &lt;code&gt;StereoPannerNode&lt;/code&gt; 를&lt;/a&gt; 생성 하고 &lt;code&gt;connect() &lt;/code&gt; 메소드를 사용하여 둘을 서로 연결합니다 . 그런 다음 &lt;code&gt;oninput&lt;/code&gt; 이벤트 핸들러를 사용 하여 &lt;a href=&quot;../stereopannernode/pan&quot;&gt; &lt;code&gt;StereoPannerNode.pan&lt;/code&gt; &lt;/a&gt; 매개 변수 의 값을 변경 하고 슬라이더가 움직일 때 팬 값 표시를 업데이트합니다.</target>
        </trans-unit>
        <trans-unit id="1ef472553ce51c5551cc764c780e04aeb0e15df5" translate="yes" xml:space="preserve">
          <source>In our &lt;a href=&quot;https://mdn.github.io/webaudio-examples/stereo-panner-node/&quot;&gt;StereoPannerNode example&lt;/a&gt; (&lt;a href=&quot;https://github.com/mdn/webaudio-examples/tree/master/stereo-panner-node&quot;&gt;see source code&lt;/a&gt;) HTML we have a simple &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/audio&quot;&gt;&lt;code&gt;&amp;lt;audio&amp;gt;&lt;/code&gt;&lt;/a&gt; element along with a slider &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input&quot;&gt;&lt;code&gt;&amp;lt;input&amp;gt;&lt;/code&gt;&lt;/a&gt; to increase and decrease pan value. In the JavaScript we create a &lt;a href=&quot;../mediaelementaudiosourcenode&quot;&gt;&lt;code&gt;MediaElementAudioSourceNode&lt;/code&gt;&lt;/a&gt; and a &lt;a href=&quot;../stereopannernode&quot;&gt;&lt;code&gt;StereoPannerNode&lt;/code&gt;&lt;/a&gt;, and connect the two together using the &lt;code&gt;connect() &lt;/code&gt;method. We then use an &lt;code&gt;oninput&lt;/code&gt; event handler to change the value of the &lt;a href=&quot;pan&quot;&gt;&lt;code&gt;StereoPannerNode.pan&lt;/code&gt;&lt;/a&gt; parameter and update the pan value display when the slider is moved.</source>
          <target state="translated">우리에서 &lt;a href=&quot;https://mdn.github.io/webaudio-examples/stereo-panner-node/&quot;&gt;StereoPannerNode 예&lt;/a&gt; ( &lt;a href=&quot;https://github.com/mdn/webaudio-examples/tree/master/stereo-panner-node&quot;&gt;소스 코드를 참조&lt;/a&gt; 우리가 단순 HTML) &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/audio&quot;&gt; &lt;code&gt;&amp;lt;audio&amp;gt;&lt;/code&gt; &lt;/a&gt; 슬라이더와 함께 요소 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input&quot;&gt; &lt;code&gt;&amp;lt;input&amp;gt;&lt;/code&gt; &lt;/a&gt; 증가 팬 값을 감소. JavaScript에서 &lt;a href=&quot;../mediaelementaudiosourcenode&quot;&gt; &lt;code&gt;MediaElementAudioSourceNode&lt;/code&gt; &lt;/a&gt; 와 &lt;a href=&quot;../stereopannernode&quot;&gt; &lt;code&gt;StereoPannerNode&lt;/code&gt; 를&lt;/a&gt; 생성 하고 &lt;code&gt;connect() &lt;/code&gt; 메소드를 사용하여 둘을 서로 연결합니다 . 그런 다음 &lt;code&gt;oninput&lt;/code&gt; 이벤트 핸들러를 사용 하여 &lt;a href=&quot;pan&quot;&gt; &lt;code&gt;StereoPannerNode.pan&lt;/code&gt; &lt;/a&gt; 매개 변수 의 값을 변경 하고 슬라이더가 움직일 때 팬 값 표시를 업데이트합니다.</target>
        </trans-unit>
        <trans-unit id="24b1e8227913f5e438a96548e9512c9d7ab13215" translate="yes" xml:space="preserve">
          <source>In our &lt;a href=&quot;https://mdn.github.io/webaudio-examples/stereo-panner-node/&quot;&gt;StereoPannerNode example&lt;/a&gt; (&lt;a href=&quot;https://github.com/mdn/webaudio-examples/tree/master/stereo-panner-node&quot;&gt;see source code&lt;/a&gt;) HTML we have a simple &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/audio&quot;&gt;&lt;code&gt;&amp;lt;audio&amp;gt;&lt;/code&gt;&lt;/a&gt; element along with a slider &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input&quot;&gt;&lt;code&gt;&amp;lt;input&amp;gt;&lt;/code&gt;&lt;/a&gt; to increase and decrease pan value. In the JavaScript we create a &lt;a href=&quot;mediaelementaudiosourcenode&quot;&gt;&lt;code&gt;MediaElementAudioSourceNode&lt;/code&gt;&lt;/a&gt; and a &lt;a href=&quot;stereopannernode&quot;&gt;&lt;code&gt;StereoPannerNode&lt;/code&gt;&lt;/a&gt;, and connect the two together using the &lt;code&gt;connect() &lt;/code&gt;method. We then use an &lt;code&gt;oninput&lt;/code&gt; event handler to change the value of the &lt;a href=&quot;stereopannernode/pan&quot;&gt;&lt;code&gt;StereoPannerNode.pan&lt;/code&gt;&lt;/a&gt; parameter and update the pan value display when the slider is moved.</source>
          <target state="translated">우리에서 &lt;a href=&quot;https://mdn.github.io/webaudio-examples/stereo-panner-node/&quot;&gt;StereoPannerNode 예&lt;/a&gt; ( &lt;a href=&quot;https://github.com/mdn/webaudio-examples/tree/master/stereo-panner-node&quot;&gt;소스 코드를 참조&lt;/a&gt; 우리가 단순 HTML) &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/audio&quot;&gt; &lt;code&gt;&amp;lt;audio&amp;gt;&lt;/code&gt; &lt;/a&gt; 슬라이더와 함께 요소 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input&quot;&gt; &lt;code&gt;&amp;lt;input&amp;gt;&lt;/code&gt; &lt;/a&gt; 증가 팬 값을 감소. JavaScript에서 &lt;a href=&quot;mediaelementaudiosourcenode&quot;&gt; &lt;code&gt;MediaElementAudioSourceNode&lt;/code&gt; &lt;/a&gt; 와 &lt;a href=&quot;stereopannernode&quot;&gt; &lt;code&gt;StereoPannerNode&lt;/code&gt; 를&lt;/a&gt; 생성 하고 &lt;code&gt;connect() &lt;/code&gt; 메소드를 사용하여 둘을 서로 연결합니다 . 그런 다음 &lt;code&gt;oninput&lt;/code&gt; 이벤트 핸들러를 사용 하여 &lt;a href=&quot;stereopannernode/pan&quot;&gt; &lt;code&gt;StereoPannerNode.pan&lt;/code&gt; &lt;/a&gt; 매개 변수 의 값을 변경 하고 슬라이더가 움직일 때 팬 값 표시를 업데이트합니다.</target>
        </trans-unit>
        <trans-unit id="4843f354641ea241795a71b67236c07ac52c08d2" translate="yes" xml:space="preserve">
          <source>In our JavaScript file we get a reference to the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/span&quot;&gt;&lt;code&gt;&amp;lt;span&amp;gt;&lt;/code&gt;&lt;/a&gt; shown above, then log a reference to the name of the corresponding &lt;code&gt;&amp;lt;slot&amp;gt;&lt;/code&gt; element.</source>
          <target state="translated">JavaScript 파일에서 위에 표시된 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/span&quot;&gt; &lt;code&gt;&amp;lt;span&amp;gt;&lt;/code&gt; 에&lt;/a&gt; 대한 참조를 얻은 다음 해당 &lt;code&gt;&amp;lt;slot&amp;gt;&lt;/code&gt; 요소 의 이름에 대한 참조를 기록하십시오 .</target>
        </trans-unit>
        <trans-unit id="87cdc4f6fb01a46a3f43555e37d60504ad6e6dd7" translate="yes" xml:space="preserve">
          <source>In our JavaScript file we get a reference to the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/span&quot;&gt;&lt;code&gt;&amp;lt;span&amp;gt;&lt;/code&gt;&lt;/a&gt; shown above, then log a reference to the original &lt;code&gt;&amp;lt;slot&amp;gt;&lt;/code&gt; element the &lt;code&gt;&amp;lt;span&amp;gt;&lt;/code&gt; was inserted in.</source>
          <target state="translated">JavaScript 파일에서 위에 표시된 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/span&quot;&gt; &lt;code&gt;&amp;lt;span&amp;gt;&lt;/code&gt; 에&lt;/a&gt; 대한 참조를 얻은 다음 &lt;code&gt;&amp;lt;span&amp;gt;&lt;/code&gt; 이 삽입 된 원래 &lt;code&gt;&amp;lt;slot&amp;gt;&lt;/code&gt; 요소에 대한 참조를 기록하십시오 .</target>
        </trans-unit>
        <trans-unit id="ceab9ce6de460ad33a9e2a0900d79499acae975c" translate="yes" xml:space="preserve">
          <source>In our Simple stream pump example, we consume the custom readable stream by passing it into a &lt;a href=&quot;../response/response&quot;&gt;&lt;code&gt;Response&lt;/code&gt;&lt;/a&gt; constructor call, after which we consume it as a blob().</source>
          <target state="translated">Simple stream pump 예제에서, 우리는 사용자 정의 읽을 수있는 스트림을 &lt;a href=&quot;../response/response&quot;&gt; &lt;code&gt;Response&lt;/code&gt; &lt;/a&gt; 생성자 호출 에 전달하여 소비합니다. 그 후에는 blob ()으로 소비합니다.</target>
        </trans-unit>
        <trans-unit id="cedc9de0305eebfbe50f45abf0dddefb92a97c35" translate="yes" xml:space="preserve">
          <source>In our basic &lt;a href=&quot;https://github.com/mdn/web-speech-api/tree/master/speak-easy-synthesis&quot;&gt;Speech synthesiser demo&lt;/a&gt;, we first grab a reference to the SpeechSynthesis controller using &lt;code&gt;window.speechSynthesis&lt;/code&gt;. After defining some necessary variables, we retrieve a list of the voices available using &lt;a href=&quot;../speechsynthesis/getvoices&quot;&gt;&lt;code&gt;SpeechSynthesis.getVoices()&lt;/code&gt;&lt;/a&gt; and populate a select menu with them so the user can choose what voice they want.</source>
          <target state="translated">기본적인 &lt;a href=&quot;https://github.com/mdn/web-speech-api/tree/master/speak-easy-synthesis&quot;&gt;음성 합성기 데모&lt;/a&gt; 에서는 먼저 &lt;code&gt;window.speechSynthesis&lt;/code&gt; 를 사용하여 SpeechSynthesis 컨트롤러에 대한 참조를 가져옵니다 . 필요한 변수를 정의한 후 &lt;a href=&quot;../speechsynthesis/getvoices&quot;&gt; &lt;code&gt;SpeechSynthesis.getVoices()&lt;/code&gt; &lt;/a&gt; 사용하여 사용할 수있는 음색 목록을 검색 하고 사용자가 원하는 음색을 선택할 수 있도록 선택 메뉴를 채 웁니다.</target>
        </trans-unit>
        <trans-unit id="10bc88397b40f8468da95f606bd3cb1baa9c28c7" translate="yes" xml:space="preserve">
          <source>In our basic &lt;a href=&quot;https://github.com/mdn/web-speech-api/tree/master/speak-easy-synthesis&quot;&gt;Speech synthesiser demo&lt;/a&gt;, we first grab a reference to the SpeechSynthesis controller using &lt;code&gt;window.speechSynthesis&lt;/code&gt;. After defining some necessary variables, we retrieve a list of the voices available using &lt;a href=&quot;speechsynthesis/getvoices&quot;&gt;&lt;code&gt;SpeechSynthesis.getVoices()&lt;/code&gt;&lt;/a&gt; and populate a select menu with them so the user can choose what voice they want.</source>
          <target state="translated">기본적인 &lt;a href=&quot;https://github.com/mdn/web-speech-api/tree/master/speak-easy-synthesis&quot;&gt;음성 합성기 데모&lt;/a&gt; 에서는 먼저 &lt;code&gt;window.speechSynthesis&lt;/code&gt; 를 사용하여 SpeechSynthesis 컨트롤러에 대한 참조를 가져옵니다 . 필요한 변수를 정의한 후 &lt;a href=&quot;speechsynthesis/getvoices&quot;&gt; &lt;code&gt;SpeechSynthesis.getVoices()&lt;/code&gt; &lt;/a&gt; 사용하여 사용할 수있는 음색 목록을 검색 하고 사용자가 원하는 음색을 선택할 수 있도록 선택 메뉴를 채 웁니다.</target>
        </trans-unit>
        <trans-unit id="7f3902c16a8973e44c8b4760bf85303af8be51ec" translate="yes" xml:space="preserve">
          <source>In our composed-composed-path example (see it live), we define two trivial custom elements, &lt;code&gt;&amp;lt;open-shadow&amp;gt;&lt;/code&gt; and &lt;code&gt;&amp;lt;closed-shadow&amp;gt;&lt;/code&gt;, both of which take the contents of their text attribute and insert them into the element's shadow DOM as the text content of a &lt;code&gt;&amp;lt;p&amp;gt;&lt;/code&gt; element. The only difference between the two is that their shadow roots are attached with their modes set to &lt;code&gt;open&lt;/code&gt; and &lt;code&gt;closed&lt;/code&gt; respectively.</source>
          <target state="translated">구성된 합성 경로 예제 (실제 참조)에서 두 가지 사소한 사용자 정의 요소 인 &lt;code&gt;&amp;lt;open-shadow&amp;gt;&lt;/code&gt; 및 &lt;code&gt;&amp;lt;closed-shadow&amp;gt;&lt;/code&gt; 를 정의합니다 . 둘 다 텍스트 속성의 내용을 가져 와서 요소의 그림자에 삽입합니다. &lt;code&gt;&amp;lt;p&amp;gt;&lt;/code&gt; 요소 의 텍스트 내용으로서의 DOM . 둘 사이의 유일한 차이는 모드로 설정된 자신의 그림자의 뿌리가 부착되어있다 &lt;code&gt;open&lt;/code&gt; 과 &lt;code&gt;closed&lt;/code&gt; 각각.</target>
        </trans-unit>
        <trans-unit id="548f7889383439313cf256bedd4737c1ccdb4456" translate="yes" xml:space="preserve">
          <source>In our example code we have defined a multiplication function &amp;mdash; &lt;code&gt;multiplyMatrixAndPoint()&lt;/code&gt;:</source>
          <target state="translated">예제 코드에서 곱셈 함수 &lt;code&gt;multiplyMatrixAndPoint()&lt;/code&gt; 정의했습니다 .</target>
        </trans-unit>
        <trans-unit id="b491f21954464f6fdc67aba99f7bb95bfd6f9f11" translate="yes" xml:space="preserve">
          <source>In our example we are using the controller&amp;rsquo;s &lt;a href=&quot;../readablestreamdefaultcontroller/enqueue&quot;&gt;&lt;code&gt;enqueue()&lt;/code&gt;&lt;/a&gt; method to enqueue a value into the custom stream after it is read from the fetch body.</source>
          <target state="translated">이 예에서는 컨트롤러의 &lt;a href=&quot;../readablestreamdefaultcontroller/enqueue&quot;&gt; &lt;code&gt;enqueue()&lt;/code&gt; &lt;/a&gt; 메소드를 사용하여 페치 본문에서 값을 읽은 후 사용자 정의 스트림에 값을 큐에 넣습니다.</target>
        </trans-unit>
        <trans-unit id="a07f47e691c12ee34185e61f30d75659b3927288" translate="yes" xml:space="preserve">
          <source>In our example, we are testing the decoding capabilities of a video configuration. The configuration requires the type of media being tested &amp;mdash; e.g. a plain &lt;code&gt;file&lt;/code&gt; or &lt;a href=&quot;../mediasource&quot;&gt;&lt;code&gt;MediaSource&lt;/code&gt;&lt;/a&gt; &amp;mdash; and a &lt;a href=&quot;../videoconfiguration&quot;&gt;&lt;code&gt;VideoConfiguration&lt;/code&gt;&lt;/a&gt; including values for the&lt;code&gt;contentType&lt;/code&gt;, &lt;code&gt;width&lt;/code&gt;, &lt;code&gt;height&lt;/code&gt;, &lt;code&gt;bitrate&lt;/code&gt;, and &lt;code&gt;framerate&lt;/code&gt;&lt;strong&gt;:&lt;/strong&gt;</source>
          <target state="translated">이 예에서는 비디오 구성의 디코딩 기능을 테스트하고 있습니다. 구성에는 테스트 할 미디어 유형 (예 : 일반 &lt;code&gt;file&lt;/code&gt; 또는 &lt;a href=&quot;../mediasource&quot;&gt; &lt;code&gt;MediaSource&lt;/code&gt; )&lt;/a&gt; 과 &lt;code&gt;contentType&lt;/code&gt; , &lt;code&gt;width&lt;/code&gt; , &lt;code&gt;height&lt;/code&gt; , &lt;code&gt;bitrate&lt;/code&gt; 및 &lt;code&gt;framerate&lt;/code&gt; 값을 포함 하는 &lt;a href=&quot;../videoconfiguration&quot;&gt; &lt;code&gt;VideoConfiguration&lt;/code&gt; 이&lt;/a&gt; 필요합니다 &lt;strong&gt;.&lt;/strong&gt;&lt;strong&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="f70c4cf3e23400c73ceb83819675631bf670e470" translate="yes" xml:space="preserve">
          <source>In our simple &lt;a href=&quot;https://github.com/mdn/web-speech-api/tree/master/speech-color-changer&quot;&gt;Speech color changer&lt;/a&gt; example, we create a new &lt;code&gt;SpeechRecognition&lt;/code&gt; object instance using the &lt;a href=&quot;../speechrecognition/speechrecognition&quot;&gt;&lt;code&gt;SpeechRecognition()&lt;/code&gt;&lt;/a&gt; constructor, create a new &lt;a href=&quot;../speechgrammarlist&quot;&gt;&lt;code&gt;SpeechGrammarList&lt;/code&gt;&lt;/a&gt;, add our grammar string to it using the &lt;a href=&quot;addfromstring&quot;&gt;&lt;code&gt;SpeechGrammarList.addFromString&lt;/code&gt;&lt;/a&gt; method, and set it to be the grammar that will be recognised by the &lt;code&gt;SpeechRecognition&lt;/code&gt; instance using the &lt;a href=&quot;../speechrecognition/grammars&quot;&gt;&lt;code&gt;SpeechRecognition.grammars&lt;/code&gt;&lt;/a&gt; property.</source>
          <target state="translated">간단한 &lt;a href=&quot;https://github.com/mdn/web-speech-api/tree/master/speech-color-changer&quot;&gt;Speech color changer&lt;/a&gt; 예제 에서 &lt;a href=&quot;../speechrecognition/speechrecognition&quot;&gt; &lt;code&gt;SpeechRecognition()&lt;/code&gt; &lt;/a&gt; 생성자를 사용하여 새로운 &lt;code&gt;SpeechRecognition&lt;/code&gt; 객체 인스턴스를 생성하고 , &lt;a href=&quot;../speechgrammarlist&quot;&gt; &lt;code&gt;SpeechGrammarList&lt;/code&gt; 를&lt;/a&gt; 생성하고 , &lt;a href=&quot;addfromstring&quot;&gt; &lt;code&gt;SpeechGrammarList.addFromString&lt;/code&gt; &lt;/a&gt; 메소드를 사용하여 문법 문자열을 추가하고 문법으로 설정합니다. &lt;a href=&quot;../speechrecognition/grammars&quot;&gt; &lt;code&gt;SpeechRecognition.grammars&lt;/code&gt; &lt;/a&gt; 속성을 사용하여 &lt;code&gt;SpeechRecognition&lt;/code&gt; 인스턴스에서 인식 합니다.</target>
        </trans-unit>
        <trans-unit id="48357f57f72de62af8d9addacb9ecaa3d210de7b" translate="yes" xml:space="preserve">
          <source>In our simple &lt;a href=&quot;https://github.com/mdn/web-speech-api/tree/master/speech-color-changer&quot;&gt;Speech color changer&lt;/a&gt; example, we create a new &lt;code&gt;SpeechRecognition&lt;/code&gt; object instance using the &lt;a href=&quot;speechrecognition/speechrecognition&quot;&gt;&lt;code&gt;SpeechRecognition()&lt;/code&gt;&lt;/a&gt; constructor, create a new &lt;a href=&quot;speechgrammarlist&quot;&gt;&lt;code&gt;SpeechGrammarList&lt;/code&gt;&lt;/a&gt;, add our grammar string to it using the &lt;a href=&quot;speechgrammarlist/addfromstring&quot;&gt;&lt;code&gt;SpeechGrammarList.addFromString&lt;/code&gt;&lt;/a&gt; method, and set it to be the grammar that will be recognised by the &lt;code&gt;SpeechRecognition&lt;/code&gt; instance using the &lt;a href=&quot;speechrecognition/grammars&quot;&gt;&lt;code&gt;SpeechRecognition.grammars&lt;/code&gt;&lt;/a&gt; property.</source>
          <target state="translated">간단한 &lt;a href=&quot;https://github.com/mdn/web-speech-api/tree/master/speech-color-changer&quot;&gt;Speech color changer&lt;/a&gt; 예제 에서 &lt;a href=&quot;speechrecognition/speechrecognition&quot;&gt; &lt;code&gt;SpeechRecognition()&lt;/code&gt; &lt;/a&gt; 생성자를 사용하여 새로운 &lt;code&gt;SpeechRecognition&lt;/code&gt; 객체 인스턴스를 생성하고 , &lt;a href=&quot;speechgrammarlist&quot;&gt; &lt;code&gt;SpeechGrammarList&lt;/code&gt; 를&lt;/a&gt; 생성하고 , &lt;a href=&quot;speechgrammarlist/addfromstring&quot;&gt; &lt;code&gt;SpeechGrammarList.addFromString&lt;/code&gt; &lt;/a&gt; 메소드를 사용하여 문법 문자열을 추가하고 문법으로 설정합니다. &lt;a href=&quot;speechrecognition/grammars&quot;&gt; &lt;code&gt;SpeechRecognition.grammars&lt;/code&gt; &lt;/a&gt; 속성을 사용하여 &lt;code&gt;SpeechRecognition&lt;/code&gt; 인스턴스에서 인식 합니다.</target>
        </trans-unit>
        <trans-unit id="6af9da9369fc06dde854a8e586e239d409f0f40c" translate="yes" xml:space="preserve">
          <source>In our video decoding example, a &lt;code&gt;TypeError&lt;/code&gt; would be raised if the media configuration passed to the &lt;code&gt;decodingInfo()&lt;/code&gt;method was invalid. The error can be due to the &lt;code&gt;type&lt;/code&gt; not being one of the two possible values, the &lt;code&gt;contentType&lt;/code&gt; not being a valid codec MIMME type, or invalid or omitted definitions required in the &lt;a href=&quot;../videoconfiguration&quot;&gt;&lt;code&gt;VideoConfiguration&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">비디오 디코딩 예제에서, &lt;code&gt;decodingInfo()&lt;/code&gt; 메소드에 전달 된 미디어 구성 이 유효하지 않으면 &lt;code&gt;TypeError&lt;/code&gt; 가 발생합니다 . &lt;code&gt;type&lt;/code&gt; 이 두 가지 가능한 값 중 하나가 아니 거나 &lt;code&gt;contentType&lt;/code&gt; 이 유효한 코덱 MIMME 형식이 아니거나 &lt;a href=&quot;../videoconfiguration&quot;&gt; &lt;code&gt;VideoConfiguration&lt;/code&gt; 에&lt;/a&gt; 필요한 유효하지 않거나 생략 된 정의 로 인해 오류가 발생할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="444a38410f8eee1ada6ea0e8209c29ec9a64dec4" translate="yes" xml:space="preserve">
          <source>In pages requiring many timers, it can often be difficult to keep track of all of the running timer events. One approach to solving this problem is to store information about the state of a timer in an object. Following is a minimal example of such an abstraction. The constructor architecture explicitly avoids the use of closures. It also offers an alternative way to pass the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/this&quot;&gt;&lt;code&gt;this&lt;/code&gt;&lt;/a&gt; object to the callback function (see &lt;a href=&quot;#The_.22this.22_problem&quot;&gt;The &quot;this&quot; problem&lt;/a&gt; for details). The following code is also &lt;a href=&quot;https://github.com/madmurphy/minidaemon.js&quot;&gt;available on GitHub&lt;/a&gt;.</source>
          <target state="translated">많은 타이머가 필요한 페이지에서는 종종 실행중인 모든 타이머 이벤트를 추적하기가 어려울 수 있습니다. 이 문제를 해결하기위한 한 가지 방법은 타이머 상태에 대한 정보를 객체에 저장하는 것입니다. 다음은 그러한 추상화의 최소한의 예입니다. 생성자 아키텍처는 클로저 사용을 명시 적으로 피합니다. 또한 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/this&quot;&gt; &lt;code&gt;this&lt;/code&gt; &lt;/a&gt; 객체를 콜백 함수 에 전달하는 다른 방법을 제공합니다 (자세한 내용 &lt;a href=&quot;#The_.22this.22_problem&quot;&gt;은 &quot;this&quot;문제&lt;/a&gt; 참조). 다음 코드는 &lt;a href=&quot;https://github.com/madmurphy/minidaemon.js&quot;&gt;GitHub&lt;/a&gt; 에서도 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="a4781153838b86061ae7ac471f555a0b2eeb6554" translate="yes" xml:space="preserve">
          <source>In particular, if a developer already has a method in place for connecting two devices, it doesn&amp;rsquo;t make sense for them to have to use another one, defined by the specification, just for WebRTC. Since WebRTC doesn&amp;rsquo;t live in a vacuum, there is likely other connectivity in play, so it makes sense to avoid having to add additional connection channels for signaling if an existing one can be used.</source>
          <target state="translated">특히, 개발자가 이미 두 장치를 연결하는 방법을 가지고 있다면 사양에 정의 된 WebRTC에 대해서만 다른 장치를 사용해야하는 것은 이치에 맞지 않습니다. WebRTC는 진공 상태에 있지 않기 때문에 다른 연결 기능이있을 수 있으므로 기존 연결 채널을 사용할 수있는 경우 신호를 보내기 위해 추가 연결 채널을 추가하지 않아도됩니다.</target>
        </trans-unit>
        <trans-unit id="480b273d124987d12c16a0c8f4ff78bcac4ee760" translate="yes" xml:space="preserve">
          <source>In particular, note that usage of textures in vertex shaders is only possible if &lt;code&gt;webgl.getParameter(webgl.MAX_VERTEX_TEXTURE_IMAGE_UNITS)&lt;/code&gt; is greater than zero. Typically, this fails on current mobile hardware.</source>
          <target state="translated">특히 정점 셰이더에서의 텍스처 사용은 &lt;code&gt;webgl.getParameter(webgl.MAX_VERTEX_TEXTURE_IMAGE_UNITS)&lt;/code&gt; 가 0보다 큰 경우에만 가능합니다 . 일반적으로 이것은 현재 모바일 하드웨어에서 실패합니다.</target>
        </trans-unit>
        <trans-unit id="863023de54e429bfc0d9fe4e4a41838da46ee3d6" translate="yes" xml:space="preserve">
          <source>In particular, the specification doesn't indicate a maximum or minimum number of audio contexts that must be able to be open at the same time, so this is left up to the browser implementations to decide.</source>
          <target state="translated">특히, 사양은 동시에 열 수 있어야하는 최대 또는 최소 오디오 컨텍스트 수를 나타내지 않으므로 브라우저 구현에 따라 결정됩니다.</target>
        </trans-unit>
        <trans-unit id="e57fac6451e79fec18e227cafa36d4d1a55b1f49" translate="yes" xml:space="preserve">
          <source>In plain words, all asynchronous methods return a request object. If the request has been completed successfully, the result is made available through the &lt;code&gt;result&lt;/code&gt; property and an event indicating success is fired at the request (&lt;a href=&quot;idbrequest/onsuccess&quot;&gt;&lt;code&gt;IDBRequest.onsuccess&lt;/code&gt;&lt;/a&gt;). If an error occurs while performing the operation, the exception is made available through the &lt;code&gt;result&lt;/code&gt; property and an error event is fired (&lt;a href=&quot;idbrequest/onerror&quot;&gt;&lt;code&gt;IDBRequest.onerror&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="translated">즉, 모든 비동기 메소드는 요청 오브젝트를 리턴합니다. 요청이 성공적으로 완료되면 &lt;code&gt;result&lt;/code&gt; 속성을 통해 결과를 사용할 수 있으며 요청시 성공을 나타내는 이벤트가 발생합니다 ( &lt;a href=&quot;idbrequest/onsuccess&quot;&gt; &lt;code&gt;IDBRequest.onsuccess&lt;/code&gt; &lt;/a&gt; ). 작업을 수행하는 동안 오류가 발생하면 &lt;code&gt;result&lt;/code&gt; 속성을 통해 예외를 사용할 수 있으며 오류 이벤트가 발생합니다 ( &lt;a href=&quot;idbrequest/onerror&quot;&gt; &lt;code&gt;IDBRequest.onerror&lt;/code&gt; &lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="24e59c71bda4325aef46faa4602d34b63b60de52" translate="yes" xml:space="preserve">
          <source>In practice this is easier to do with a library &amp;mdash; the Web Audio API was built to be built upon. If you are about to embark on building something more complex, &lt;a href=&quot;https://tonejs.github.io/&quot;&gt;tone.js&lt;/a&gt; would be a good place to start. However, we want to demonstrate how to build such a demo from first principles, as a learning exercise.</source>
          <target state="translated">실제로 이는 웹 오디오 API를 기반으로 구축 된 라이브러리로 수행하기가 더 쉽습니다. 좀 더 복잡한 것을 만들기 시작하면 &lt;a href=&quot;https://tonejs.github.io/&quot;&gt;tone.js&lt;/a&gt; 를 시작하는 것이 좋습니다. 그러나 학습 연습과 같은 첫 번째 원칙에서 이러한 데모를 작성하는 방법을 보여주고 자합니다.</target>
        </trans-unit>
        <trans-unit id="32516160de0372f860bce99327d1d19a3ef70023" translate="yes" xml:space="preserve">
          <source>In practice, the returned value is a double-precision floating-point value indicating the number of pixels the document is currently scrolled horizontally from the origin, where a positive value means the content is scrolled to the left. If the document is rendered on a subpixel-precise device, then the returned value is also subpixel-precise and may contain a decimal component. If the document isn't scrolled at all left or right, then &lt;code&gt;scrollX&lt;/code&gt; is 0.</source>
          <target state="translated">실제로 반환 된 값은 문서가 현재 원점에서 수평으로 스크롤되는 픽셀 수를 나타내는 배정 밀도 부동 소수점 값입니다. 양수 값은 내용이 왼쪽으로 스크롤됨을 의미합니다. 문서가 서브 픽셀 정밀도 장치에서 렌더링되는 경우 반환 된 값도 서브 픽셀 정밀도이며 10 진수 구성 요소를 포함 할 수 있습니다. 문서가 좌우로 스크롤되지 않으면 &lt;code&gt;scrollX&lt;/code&gt; 는 0입니다.</target>
        </trans-unit>
        <trans-unit id="c9e4c3224f024b670cafe3c2640c0a1d7b515001" translate="yes" xml:space="preserve">
          <source>In practice, the returned value is a double-precision floating-point value indicating the number of pixels the document is currently scrolled vertically from the origin, where a positive value means the content is scrolled to upward. If the document is rendered on a subpixel-precise device, then the returned value is also subpixel-precise and may contain a decimal component. If the document isn't scrolled at all up or down, then &lt;code&gt;scrollY&lt;/code&gt; is 0.</source>
          <target state="translated">실제로, 반환 된 값은 문서가 현재 원점에서 세로로 스크롤되는 픽셀 수를 나타내는 배정 밀도 부동 소수점 값입니다. 양수 값은 내용이 위로 스크롤됨을 의미합니다. 문서가 서브 픽셀 정밀 장치에서 렌더링되는 경우 반환 된 값도 서브 픽셀 정밀도이며 10 진수 구성 요소를 포함 할 수 있습니다. 문서가 전혀 위 또는 아래로 스크롤되지 않으면 &lt;code&gt;scrollY&lt;/code&gt; 는 0입니다.</target>
        </trans-unit>
        <trans-unit id="295312640161fdff38c2b50bcde9aea3c51e2408" translate="yes" xml:space="preserve">
          <source>In previous DOM specifications this API was defined within the &lt;a href=&quot;../node&quot;&gt;&lt;code&gt;Node&lt;/code&gt;&lt;/a&gt; interface.</source>
          <target state="translated">이전 DOM 사양에서이 API는 &lt;a href=&quot;../node&quot;&gt; &lt;code&gt;Node&lt;/code&gt; &lt;/a&gt; 인터페이스 내에서 정의되었습니다 .</target>
        </trans-unit>
        <trans-unit id="9d2c9022f0f0d8e5ecaf15700987363c21780126" translate="yes" xml:space="preserve">
          <source>In rendering environments supporting interactivity, forces the user agent to immediately redraw all regions of the viewport that require updating.</source>
          <target state="translated">상호 작용을 지원하는 렌더링 환경에서 사용자 에이전트는 업데이트가 필요한 뷰포트의 모든 영역을 즉시 다시 그립니다.</target>
        </trans-unit>
        <trans-unit id="adeae07f8e178d7be0eacd5d918d3c410b86f38a" translate="yes" xml:space="preserve">
          <source>In sequence 1 &amp;amp; 3, the &lt;code&gt;KeyboardEvent.key&lt;/code&gt; attribute is defined and is set appropriately to a value according to the rules defined ealier.</source>
          <target state="translated">순서 1 및 3에서 &lt;code&gt;KeyboardEvent.key&lt;/code&gt; 속성이 정의되며, 정의 된 규칙에 따라 값으로 적절하게 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="cc146c3c739a1f1ab859df4b0940afcbe4e3c4fd" translate="yes" xml:space="preserve">
          <source>In shared or service workers, the value in the worker might be higher than that of the main context because that window can be created after those workers.</source>
          <target state="translated">공유 또는 서비스 작업자의 경우 해당 작업자 다음에 해당 창을 만들 수 있으므로 작업자의 값이 기본 컨텍스트의 값보다 높을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e9dd0af79438852a4f8d38f9d9dc72e257be0b7a" translate="yes" xml:space="preserve">
          <source>In short, the &lt;a href=&quot;../mediastreamtrack&quot;&gt;&lt;code&gt;MediaStreamTrack&lt;/code&gt;&lt;/a&gt; method &lt;code&gt;stop()&lt;/code&gt; method stops the track.</source>
          <target state="translated">즉, &lt;a href=&quot;../mediastreamtrack&quot;&gt; &lt;code&gt;MediaStreamTrack&lt;/code&gt; &lt;/a&gt; 메서드 &lt;code&gt;stop()&lt;/code&gt; 메서드는 트랙을 중지합니다.</target>
        </trans-unit>
        <trans-unit id="6fe9767585f5a6087e3eefc48ac674b59b8cc1d1" translate="yes" xml:space="preserve">
          <source>In simple words, a binary string is a sequence of 1's and 0's. Javascript is loaded with rich features to manipulate the raw binary data in lower level.</source>
          <target state="translated">간단히 말해서, 이진 문자열은 1과 0의 시퀀스입니다. Javascript에는 원시 바이너리 데이터를 더 낮은 수준으로 조작 할 수있는 다양한 기능이 있습니다.</target>
        </trans-unit>
        <trans-unit id="59a183e4146a1597816ed082d6fe201ce9f7aca4" translate="yes" xml:space="preserve">
          <source>In some GTK-based environments, auto-repeat dispatches a native key-up event automatically during auto-repeat, and there's no way for Gecko to know the difference between a repeated series of keypresses and an auto-repeat. On those platforms, then, an auto-repeat key will generate the following sequence of events:</source>
          <target state="translated">일부 GTK 기반 환경에서 자동 반복은 자동 반복 중에 기본 키업 이벤트를 자동으로 전달하므로 Gecko는 반복되는 일련의 키 누름과 자동 반복의 차이점을 알 수 없습니다. 이러한 플랫폼에서 자동 반복 키는 다음과 같은 일련의 이벤트를 생성합니다.</target>
        </trans-unit>
        <trans-unit id="172174b9f593a512a9a6c6f3a6aa9205ede7b089" translate="yes" xml:space="preserve">
          <source>In some browsers, if a stylesheet is loaded from a different domain, calling &lt;code&gt;cssRules&lt;/code&gt; results in &lt;code&gt;SecurityError&lt;/code&gt;.</source>
          <target state="translated">일부 브라우저에서 스타일 시트가 다른 도메인에서로드 된 경우 &lt;code&gt;cssRules&lt;/code&gt; 를 호출 하면 &lt;code&gt;SecurityError&lt;/code&gt; 가 발생 합니다.</target>
        </trans-unit>
        <trans-unit id="dce1dcc3b182fd4da4a701ed003a7bf79ced8b8f" translate="yes" xml:space="preserve">
          <source>In some cases, an animation may run on a separate thread or process and will continue updating even while long-running JavaScript delays the main thread. In such a case, setting the &lt;a href=&quot;playbackrate&quot;&gt;&lt;code&gt;playbackRate&lt;/code&gt;&lt;/a&gt; on the animation directly may cause the animation's playback position to jump since its playback position on the main thread may have drifted from the playback position where it is currently running.</source>
          <target state="translated">경우에 따라 애니메이션이 별도의 스레드 또는 프로세스에서 실행될 수 있으며 장시간 실행되는 JavaScript가 기본 스레드를 지연시키는 동안에도 계속 업데이트됩니다. 이러한 경우, 설정 &lt;a href=&quot;playbackrate&quot;&gt; &lt;code&gt;playbackRate&lt;/code&gt; 을&lt;/a&gt; 애니메이션에 직접적 주 스레드에서의 재생 위치가 현재 실행중인 재생 위치에서 떠돌아 다녔다 수 있기 때문에 이동하는 애니메이션의 재생 위치의 원인이 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4655844bbc80dc899c798f617d6fd3597b928e06" translate="yes" xml:space="preserve">
          <source>In some cases, the &lt;code&gt;NodeList&lt;/code&gt; is &lt;em&gt;live&lt;/em&gt;, which means that changes in the DOM automatically update the collection. For example, &lt;a href=&quot;node/childnodes&quot;&gt;&lt;code&gt;Node.childNodes&lt;/code&gt;&lt;/a&gt; is live:</source>
          <target state="translated">경우에 따라 &lt;code&gt;NodeList&lt;/code&gt; 가 &lt;em&gt;live&lt;/em&gt; 이므로 DOM의 변경 사항이 자동으로 콜렉션을 업데이트합니다. 예를 들어 &lt;a href=&quot;node/childnodes&quot;&gt; &lt;code&gt;Node.childNodes&lt;/code&gt; &lt;/a&gt; 는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="6ee0c3405328ac0a1e364e03bbe1b6759943b171" translate="yes" xml:space="preserve">
          <source>In some cases, the above conversion to UTF-8 and then to Base64 will not be very space efficient. UTF-8 produces longer output than UTF-16 when the text contains a large percentage of characters in the range U+0800-U+FFFF, which are encoded with three bytes in UTF-8 but two in UTF-16. In the case where the JavaScript string contains evenly-distributed UTF-16 code points, one might consider encoding to UTF-16 instead of UTF-8 before the conversion to Base64, for a 40% reduction in size.</source>
          <target state="translated">경우에 따라 위의 UTF-8로 변환 한 다음 Base64 로의 변환은 공간 효율적이지 않을 수 있습니다. 텍스트에 U + 0800-U + FFFF 범위의 많은 문자가 포함되어 UTF-8에서는 3 바이트, UTF-16에서는 2 바이트로 인코딩되는 경우 UTF-8은 UTF-16보다 긴 출력을 생성합니다. JavaScript 문자열에 고르게 분산 된 UTF-16 코드 포인트가 포함 된 경우 Base64로 변환하기 전에 UTF-8 대신 UTF-16으로 인코딩하여 크기를 40 % 줄일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="132eae7008230e83d3da8ea93f84689e6de2d4b3" translate="yes" xml:space="preserve">
          <source>In some cases, you must read many external files. This is a standard function which uses the &lt;code&gt;XMLHttpRequest&lt;/code&gt; object asynchronously in order to switch the content of the read file to a specified listener.</source>
          <target state="translated">경우에 따라 많은 외부 파일을 읽어야합니다. 읽기 파일의 내용을 지정된 리스너로 전환하기 위해 &lt;code&gt;XMLHttpRequest&lt;/code&gt; 객체를 비동기식으로 사용하는 표준 함수입니다 .</target>
        </trans-unit>
        <trans-unit id="b299ff99aea1bc61ce766adae31254860b288ce2" translate="yes" xml:space="preserve">
          <source>In some countries, like Belgium, it's uncommon for people to provide a region as part of their postal address. In such cases, the browser returns an empty string as the value of &lt;code&gt;region&lt;/code&gt;. However, the address should still be acceptable to use for its intended purpose (e.g., to ship a product). However, always verify addresses to make sure what the user provides is usable.</source>
          <target state="translated">벨기에와 같은 일부 국가에서는 사람들이 우편 주소의 일부로 지역을 제공하는 경우가 드 un니다. 이 경우 브라우저는 &lt;code&gt;region&lt;/code&gt; 값으로 빈 문자열을 반환합니다 . 그러나 주소는 의도 된 목적으로 사용하기에 여전히 수용 가능해야합니다 (예 : 제품 배송). 그러나 항상 사용자가 제공 한 내용을 사용할 수 있도록 주소를 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="e6dea87d6416b39807b2dab77adc9ccde9c3b546" translate="yes" xml:space="preserve">
          <source>In some implementations, passing anything other than a number for the screen and client fields will throw a &lt;code&gt;TypeError&lt;/code&gt;.</source>
          <target state="translated">일부 구현에서는 화면 및 클라이언트 필드에 숫자 이외의 값을 전달하면 &lt;code&gt;TypeError&lt;/code&gt; 가 발생 합니다.</target>
        </trans-unit>
        <trans-unit id="c947099d79761880f47f1b5181a546601c8aeb25" translate="yes" xml:space="preserve">
          <source>In some instances, &lt;code&gt;InputDeviceCapabilities&lt;/code&gt; represents the capabilities of logical devices rather than physical devices. This allows, for example, touchscreen keyboards and physical keyboards to be represented the same way when they produce the same input.</source>
          <target state="translated">경우에 따라 &lt;code&gt;InputDeviceCapabilities&lt;/code&gt; 는 물리적 장치가 아닌 논리적 장치의 기능을 나타냅니다. 예를 들어 터치 스크린 키보드와 물리적 키보드가 동일한 입력을 생성 할 때 동일한 방식으로 표시 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="455954cdb79d203d096072cc645e2352e3bacba8" translate="yes" xml:space="preserve">
          <source>In some rare cases, packing greyscale textures which belong together into the color channels of a single texture might help.</source>
          <target state="translated">드물게 단일 텍스처의 색상 채널에 속하는 그레이 스케일 텍스처를 포장하는 것이 도움이 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8807053eb3061f5ccd904706d857bd4ee81c15de" translate="yes" xml:space="preserve">
          <source>In some scenarios there may be multiple pointers (for example a device with both a touchscreen and a mouse) or a pointer supports multiple contact points (for example a touchscreen that supports multiple finger touches). The application can use the &lt;a href=&quot;pointerevent/isprimary&quot;&gt;&lt;code&gt;isPrimary&lt;/code&gt;&lt;/a&gt; property to identify a master pointer among the set of &lt;em&gt;active pointers&lt;/em&gt; for each pointer type. If an application only wants to support a primary pointer, it can ignore all pointer events that are not primary.</source>
          <target state="translated">일부 시나리오에서는 여러 포인터 (예 : 터치 스크린과 마우스가있는 장치)가 있거나 포인터가 여러 접점 (예 : 여러 손가락 터치를 지원하는 터치 스크린)을 지원할 수 있습니다. 응용 프로그램은 &lt;a href=&quot;pointerevent/isprimary&quot;&gt; &lt;code&gt;isPrimary&lt;/code&gt; &lt;/a&gt; 속성을 사용하여 각 포인터 유형에 대한 &lt;em&gt;활성 포인터&lt;/em&gt; 집합 중에서 마스터 포인터를 식별 할 수 있습니다 . 응용 프로그램이 기본 포인터 만 지원하려는 경우 기본이 아닌 모든 포인터 이벤트를 무시할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4b7e8dede71e0c3ed9e9fb5f42051be333943383" translate="yes" xml:space="preserve">
          <source>In tandem with appropriate HTML and CSS, the result is:</source>
          <target state="translated">적절한 HTML 및 CSS와 함께 결과는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="87785b6aae731be29028f0420000582fe05b36af" translate="yes" xml:space="preserve">
          <source>In technical terms, we apply a &lt;a href=&quot;http://webaudio.github.io/web-audio-api/#blackman-window&quot;&gt;Blackman window&lt;/a&gt; and smooth the values over time. The default value is good enough for most cases.</source>
          <target state="translated">기술적 인 측면에서 &lt;a href=&quot;http://webaudio.github.io/web-audio-api/#blackman-window&quot;&gt;Blackman 창&lt;/a&gt; 을 적용하고 시간이 지남에 따라 값을 부드럽게합니다. 대부분의 경우 기본값이 충분합니다.</target>
        </trans-unit>
        <trans-unit id="4569a112b815930f3f6110fdab139a3c9f156284" translate="yes" xml:space="preserve">
          <source>In the &lt;a href=&quot;http://codepen.io/rachelnabors/pen/EPJdJx?editors=0010&quot;&gt;Pool of Tears&lt;/a&gt; example, each tear is passed a random &lt;code&gt;duration&lt;/code&gt; via its timing object:</source>
          <target state="translated">&lt;a href=&quot;http://codepen.io/rachelnabors/pen/EPJdJx?editors=0010&quot;&gt;눈물&lt;/a&gt; 의 풀 (Pool of Tears) 예제에서 각 눈물은 타이밍 개체를 통해 임의의 &lt;code&gt;duration&lt;/code&gt; 이 전달됩니다 .</target>
        </trans-unit>
        <trans-unit id="84baeba554340df677d283c92acea536f934dd81" translate="yes" xml:space="preserve">
          <source>In the &lt;a href=&quot;http://codepen.io/rachelnabors/pen/EPJdJx?editors=0010&quot;&gt;Pool of Tears&lt;/a&gt; example, each tear is passed a random delay via its timing object:</source>
          <target state="translated">&lt;a href=&quot;http://codepen.io/rachelnabors/pen/EPJdJx?editors=0010&quot;&gt;눈물&lt;/a&gt; 의 풀 (Pool of Tears) 예제에서 각 티어 (Tear)는 타이밍 오브젝트를 통해 임의의 지연을 통과합니다.</target>
        </trans-unit>
        <trans-unit id="8840866ab7b70934813f8b44dc4d3acedd59684a" translate="yes" xml:space="preserve">
          <source>In the &lt;a href=&quot;http://codepen.io/rachelnabors/pen/PNGGaV&quot;&gt;Red Queen Race&lt;/a&gt; example, we can inspect Alice and the RedQueen's animation to see its individual keyframes like so:</source>
          <target state="translated">에서 &lt;a href=&quot;http://codepen.io/rachelnabors/pen/PNGGaV&quot;&gt;붉은 여왕 레이스&lt;/a&gt; 예를 들어, 우리는과 같이 개별 키 프레임을 볼 앨리스와 RedQueen의 애니메이션을 검사 할 수 있습니다 :</target>
        </trans-unit>
        <trans-unit id="4e53b83e14cfbf2b6cb2206f2d31afedefa47e79" translate="yes" xml:space="preserve">
          <source>In the &lt;a href=&quot;http://codepen.io/rachelnabors/pen/PNGGaV?editors=0010&quot;&gt;Red Queen's Race&lt;/a&gt; example, we animate Alice and the Red Queen by passing an easing &lt;code&gt;of&amp;nbsp;steps(7, end)&lt;/code&gt; to &lt;code&gt;animate()&lt;/code&gt;:</source>
          <target state="translated">에서 &lt;a href=&quot;http://codepen.io/rachelnabors/pen/PNGGaV?editors=0010&quot;&gt;레드 여왕의 레이스&lt;/a&gt; 예를 들어, 우리는 완화 전달하여 Alice와 붉은 여왕 애니메이션 &lt;code&gt;of&amp;nbsp;steps(7, end)&lt;/code&gt; 로 &lt;code&gt;animate()&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="4d48fff257a7eaf677c500603cba8675d9ec15a0" translate="yes" xml:space="preserve">
          <source>In the &lt;a href=&quot;http://codepen.io/rachelnabors/pen/PNYGZQ?editors=0010&quot;&gt;Drink Me/Eat Me game&lt;/a&gt;, Alice's height is animated so it can go from small to large or large to small. At the start of the game, her height is set between the two extremes by setting her animation's &lt;code&gt;currentTime&lt;/code&gt; to half her &lt;a href=&quot;../effecttiming&quot;&gt;&lt;code&gt;KeyframeEffect&lt;/code&gt;'s duration&lt;/a&gt;:</source>
          <target state="translated">에서 &lt;a href=&quot;http://codepen.io/rachelnabors/pen/PNYGZQ?editors=0010&quot;&gt;음료 나 / 나 게임 먹고&lt;/a&gt; 는 작은 대형 또는 소형 ~ 대형 갈 수 있도록, 앨리스의 높이 애니메이션. 게임을 시작할 때 애니메이션의 &lt;code&gt;currentTime&lt;/code&gt; 을 &lt;a href=&quot;../effecttiming&quot;&gt; &lt;code&gt;KeyframeEffect&lt;/code&gt; 지속 시간의&lt;/a&gt; 절반 으로 설정하여 두 극단 사이의 높이를 설정합니다 .</target>
        </trans-unit>
        <trans-unit id="dff4039fcfe679b0dec49d92d0aba4320d8da9c3" translate="yes" xml:space="preserve">
          <source>In the &lt;a href=&quot;http://codepen.io/rachelnabors/pen/PNYGZQ?editors=0010&quot;&gt;Growing/Shrinking Alice Game&lt;/a&gt; example, clicking or tapping the bottle causes Alice's growing animation (&lt;code&gt;aliceChange&lt;/code&gt;) to play backwards, causing her to get smaller. It is done by setting &lt;code&gt;aliceChange&lt;/code&gt;'s &lt;a href=&quot;playbackrate&quot;&gt;&lt;code&gt;Animation.playbackRate&lt;/code&gt;&lt;/a&gt; to &lt;code&gt;-1&lt;/code&gt; like so:</source>
          <target state="translated">&lt;a href=&quot;http://codepen.io/rachelnabors/pen/PNYGZQ?editors=0010&quot;&gt;Alice&lt;/a&gt; 의 Growing / Shrinking Alice 게임 예제에서 병을 클릭하거나 두드리면 Alice의 성장하는 애니메이션 ( &lt;code&gt;aliceChange&lt;/code&gt; )이 뒤로 재생되어 크기가 작아집니다. &lt;code&gt;aliceChange&lt;/code&gt; 의 &lt;a href=&quot;playbackrate&quot;&gt; &lt;code&gt;Animation.playbackRate&lt;/code&gt; &lt;/a&gt; 를 다음 과 같이 &lt;code&gt;-1&lt;/code&gt; 로 설정 하면됩니다.</target>
        </trans-unit>
        <trans-unit id="75ccab065512a27e756e2ce4032133c4b2ab5ec4" translate="yes" xml:space="preserve">
          <source>In the &lt;a href=&quot;http://codepen.io/rachelnabors/pen/PNYGZQ?editors=0010&quot;&gt;Growing/Shrinking Alice Game&lt;/a&gt; example, clicking or tapping the bottle causes Alice's growing animation (&lt;code&gt;aliceChange&lt;/code&gt;) to reverse, causing her to shrink:</source>
          <target state="translated">&lt;a href=&quot;http://codepen.io/rachelnabors/pen/PNYGZQ?editors=0010&quot;&gt;Alice&lt;/a&gt; 의 Growing / Shrinking Alice 게임 예제에서 병을 클릭하거나 두드리면 Alice의 성장하는 애니메이션 ( &lt;code&gt;aliceChange&lt;/code&gt; )이 반대로되어 축소됩니다.</target>
        </trans-unit>
        <trans-unit id="a6f044f5fc3c895453f3a3776f76e7cb90e07603" translate="yes" xml:space="preserve">
          <source>In the &lt;a href=&quot;http://codepen.io/rachelnabors/pen/PNYGZQ?editors=0010&quot;&gt;Growing/Shrinking Alice Game&lt;/a&gt; example, clicking or tapping the cake causes Alice's growing animation (&lt;code&gt;aliceChange&lt;/code&gt;) to play forward, causing her to get bigger, as well as triggering the cake's animation. Two &lt;code&gt;Animation.play()&lt;/code&gt;s, one &lt;code&gt;EventListener&lt;/code&gt;:</source>
          <target state="translated">&lt;a href=&quot;http://codepen.io/rachelnabors/pen/PNYGZQ?editors=0010&quot;&gt;Alice&lt;/a&gt; 의 Growing / Shrinking Alice Game 예제에서, 케이크를 클릭하거나 두드리면 Alice의 성장하는 애니메이션 ( &lt;code&gt;aliceChange&lt;/code&gt; )이 앞으로 재생되어 케이크의 애니메이션이 트리거 될뿐만 아니라 더 커지게됩니다. 두 개의 &lt;code&gt;Animation.play()&lt;/code&gt; , 하나의 &lt;code&gt;EventListener&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="ce47f4fbd44866013a3484c775bc335526230a6b" translate="yes" xml:space="preserve">
          <source>In the &lt;a href=&quot;http://codepen.io/rachelnabors/pen/PNYGZQ?editors=0010&quot;&gt;Growing/Shrinking Alice Game&lt;/a&gt; example, players can get an ending with &lt;a href=&quot;http://codepen.io/rachelnabors/pen/EPJdJx?editors=0010&quot;&gt;Alice crying into a pool of tears&lt;/a&gt;. In the game, for performance reasons, the tears should only be animating when they're visible. So they must be paused as soon as they are animated like so:</source>
          <target state="translated">&lt;a href=&quot;http://codepen.io/rachelnabors/pen/PNYGZQ?editors=0010&quot;&gt;Alice&lt;/a&gt; 의 Growing / Shrinking Alice 게임 예제에서 플레이어는 &lt;a href=&quot;http://codepen.io/rachelnabors/pen/EPJdJx?editors=0010&quot;&gt;Alice가 눈물 웅덩이에 울고&lt;/a&gt; 있는 결말을 얻을 수 있습니다 . 게임에서 성능상의 이유로 눈물은 눈에 보일 때만 애니메이션으로 표시됩니다. 따라서 다음과 같이 애니메이션이 표시되는 즉시 일시 중지해야합니다.</target>
        </trans-unit>
        <trans-unit id="1f97c5e22a8412f74172efbe4d3fc58e65eafcde" translate="yes" xml:space="preserve">
          <source>In the &lt;a href=&quot;http://codepen.io/rachelnabors/pen/bEPdQr?editors=0010&quot;&gt;Forgotten Key&lt;/a&gt; example, Alice waves her arm up and down by passing her an &lt;code&gt;alternate&lt;/code&gt; value for her &lt;code&gt;direction&lt;/code&gt; property:</source>
          <target state="translated">에서 &lt;a href=&quot;http://codepen.io/rachelnabors/pen/bEPdQr?editors=0010&quot;&gt;잊혀진 키&lt;/a&gt; 예를 들어, 앨리스 파도 그녀는 그녀에게 전달하여 아래의 팔과 &lt;code&gt;alternate&lt;/code&gt; 그녀의 가치를 &lt;code&gt;direction&lt;/code&gt; 특성 :</target>
        </trans-unit>
        <trans-unit id="5c8cbb2f566cba2fd38c09a4aa57733808943991" translate="yes" xml:space="preserve">
          <source>In the &lt;a href=&quot;http://codepen.io/rachelnabors/pen/bEPdQr?editors=0010&quot;&gt;Forgotten Key&lt;/a&gt; example, Alice waves her arm up and down the entire time the page is open by passing &lt;code&gt;Infinity&lt;/code&gt; as the value for her &lt;code&gt;iterations&lt;/code&gt; property:</source>
          <target state="translated">에서 &lt;a href=&quot;http://codepen.io/rachelnabors/pen/bEPdQr?editors=0010&quot;&gt;잊혀진 키&lt;/a&gt; 예를 들어, 앨리스 파도는 그녀의 팔을 전체 시간 아래로 페이지를 전달하여 열려있는 &lt;code&gt;Infinity&lt;/code&gt; 그녀의 값으로 &lt;code&gt;iterations&lt;/code&gt; 특성 :</target>
        </trans-unit>
        <trans-unit id="2c892ed1b4c2d80a928b1b6bc3d60c8e0ce6d8a0" translate="yes" xml:space="preserve">
          <source>In the &lt;a href=&quot;http://codepen.io/rachelnabors/pen/eJyWzm/?editors=0010&quot;&gt;Follow the White Rabbit example&lt;/a&gt;, &lt;code&gt;whiteRabbit&lt;/code&gt; sets the &lt;code&gt;target&lt;/code&gt; element to be animated:</source>
          <target state="translated">에서 &lt;a href=&quot;http://codepen.io/rachelnabors/pen/eJyWzm/?editors=0010&quot;&gt;팔로우 화이트 래빗 예를 들어&lt;/a&gt; , &lt;code&gt;whiteRabbit&lt;/code&gt; 는 세트 &lt;code&gt;target&lt;/code&gt; 애니메이션 할 요소 :</target>
        </trans-unit>
        <trans-unit id="d57f87a4c92a2dd36732c3007295e662906a7cb1" translate="yes" xml:space="preserve">
          <source>In the &lt;a href=&quot;http://codepen.io/rachelnabors/pen/eJyWzm/?editors=0010&quot;&gt;Follow the White Rabbit example&lt;/a&gt;, the &lt;code&gt;Animation()&lt;/code&gt; constructor is used to create an &lt;code&gt;Animation&lt;/code&gt; for the &lt;code&gt;rabbitDownKeyframes&lt;/code&gt; using the document's &lt;code&gt;timeline&lt;/code&gt;:</source>
          <target state="translated">에서 &lt;a href=&quot;http://codepen.io/rachelnabors/pen/eJyWzm/?editors=0010&quot;&gt;팔로우 화이트 토끼의 예&lt;/a&gt; 는 &lt;code&gt;Animation()&lt;/code&gt; 생성자는 만드는 데 사용되는 &lt;code&gt;Animation&lt;/code&gt; 에 대한 &lt;code&gt;rabbitDownKeyframes&lt;/code&gt; 문서의 사용 &lt;code&gt;timeline&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="e919e7052a1fb04189f5298ef0aeed5addb60a81" translate="yes" xml:space="preserve">
          <source>In the &lt;a href=&quot;http://codepen.io/rachelnabors/pen/eJyWzm/?editors=0010&quot;&gt;Follow the White Rabbit example&lt;/a&gt;, the &lt;code&gt;KeyframeEffect&lt;/code&gt; constructor is used to create a set of keyframes that dictate how the White Rabbit should animate down the hole:</source>
          <target state="translated">에서 &lt;a href=&quot;http://codepen.io/rachelnabors/pen/eJyWzm/?editors=0010&quot;&gt;팔로우 화이트 토끼의 예&lt;/a&gt; 는 &lt;code&gt;KeyframeEffect&lt;/code&gt; 의 생성자를 결정 합니 화이트 토끼 구멍 아래로 움직이면서 어떻게 키 프레임 세트를 만드는 데 사용됩니다 :</target>
        </trans-unit>
        <trans-unit id="5dc7d3f46c7c879ce882c77ba8667b3a8c0fcd98" translate="yes" xml:space="preserve">
          <source>In the &lt;a href=&quot;http://codepen.io/rachelnabors/pen/eJyWzm/?editors=0010&quot;&gt;Follow the White Rabbit example&lt;/a&gt;, the KeyframeEffect constructor is used to create a set of keyframes that dictate how the White Rabbit should animate down the hole:</source>
          <target state="translated">에서 &lt;a href=&quot;http://codepen.io/rachelnabors/pen/eJyWzm/?editors=0010&quot;&gt;팔로우 화이트 토끼의 예&lt;/a&gt; 는 KeyframeEffect 생성자를 결정 합니 화이트 토끼 구멍 아래로 움직이면서 어떻게 키 프레임 세트를 만드는 데 사용됩니다 :</target>
        </trans-unit>
        <trans-unit id="071693fd0cc0ece3fcd2069423c95fa1c37f35fd" translate="yes" xml:space="preserve">
          <source>In the &lt;a href=&quot;http://codepen.io/rachelnabors/pen/eJyWzm?editors=0010&quot;&gt;Follow the White Rabbit example&lt;/a&gt;, you can assign the &lt;code&gt;rabbitDownAnimation&lt;/code&gt; an &lt;code&gt;id&lt;/code&gt; like so:</source>
          <target state="translated">에서 &lt;a href=&quot;http://codepen.io/rachelnabors/pen/eJyWzm?editors=0010&quot;&gt;팔로우 화이트 래빗 예를 들어&lt;/a&gt; , 당신은 할당 할 수 &lt;code&gt;rabbitDownAnimation&lt;/code&gt; 에게 &lt;code&gt;id&lt;/code&gt; 과 같이 :</target>
        </trans-unit>
        <trans-unit id="31e3f097211b1868c0e1036a1f521e423e1d689e" translate="yes" xml:space="preserve">
          <source>In the &lt;a href=&quot;http://codepen.io/rachelnabors/pen/eJyWzm?editors=0010&quot;&gt;Follow the White Rabbit&lt;/a&gt; example, the White Rabbit's animation is formed by coupling a &lt;code&gt;KeyframeEffect&lt;/code&gt; with an &lt;code&gt;Animation&lt;/code&gt; object. The &lt;code&gt;keyframeEffect&lt;/code&gt; takes an object of &lt;a href=&quot;../effecttiming&quot;&gt;timing properties&lt;/a&gt;, which is where we pass in &lt;code&gt;fill&lt;/code&gt;. &lt;code&gt;Forwards&lt;/code&gt; makes the rabbit retain its last keyframe rather than reverting to its unanimated state:</source>
          <target state="translated">에서 &lt;a href=&quot;http://codepen.io/rachelnabors/pen/eJyWzm?editors=0010&quot;&gt;팔로우 화이트 래빗&lt;/a&gt; 예를 들어, 흰 토끼의 애니메이션은 결합에 의해 형성된다 &lt;code&gt;KeyframeEffect&lt;/code&gt; 을 와 &lt;code&gt;Animation&lt;/code&gt; 객체입니다. &lt;code&gt;keyframeEffect&lt;/code&gt; 는 의 목적 얻어 &lt;a href=&quot;../effecttiming&quot;&gt;타이밍 특성&lt;/a&gt; 우리 전달 곳인, &lt;code&gt;fill&lt;/code&gt; . &lt;code&gt;Forwards&lt;/code&gt; 토끼가 애니메이션이없는 상태로 되돌아 가지 않고 마지막 키 프레임을 유지하도록합니다.</target>
        </trans-unit>
        <trans-unit id="9f9e06b09ced74d19ee9f6966beb25606973889e" translate="yes" xml:space="preserve">
          <source>In the &lt;a href=&quot;http://codepen.io/rachelnabors/pen/zxYexJ?editors=0010&quot;&gt;Running on Web Animations API example&lt;/a&gt;, the we can sync all new animated cats by giving them all the same &lt;code&gt;startTime&lt;/code&gt; as the original running cat:</source>
          <target state="translated">에서 &lt;a href=&quot;http://codepen.io/rachelnabors/pen/zxYexJ?editors=0010&quot;&gt;웹 애니메이션 API 예제에 실행&lt;/a&gt; 의 우리는 그들에게 모두 같은함으로써 모든 새로운 애니메이션 고양이를 동기화 할 수 있습니다 &lt;code&gt;startTime&lt;/code&gt; 을 원래의 실행 고양이 등을 :</target>
        </trans-unit>
        <trans-unit id="748f5741c26a5bddcbc0305b56737ef101affdfe" translate="yes" xml:space="preserve">
          <source>In the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/File_and_Directory_Entries_API/Introduction&quot;&gt;File System API&lt;/a&gt;, a &lt;code&gt;FileError&lt;/code&gt; represents error conditions that you might encounter while accessing the file system using the asynchronous API. It extends the &lt;code&gt;FileError&lt;/code&gt; interface described in &lt;a href=&quot;http://dev.w3.org/2009/dap/file-system/pub/FileSystem/#bib-FILE-WRITER&quot;&gt;File Writer&lt;/a&gt; and adds several new error codes.</source>
          <target state="translated">에서 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/File_and_Directory_Entries_API/Introduction&quot;&gt;파일 시스템 API&lt;/a&gt; 하는 &lt;code&gt;FileError&lt;/code&gt; 는 비동기 API를 사용하여 파일 시스템에 액세스하는 동안 발생할 수 있다는 오류 상태를 나타냅니다. &lt;a href=&quot;http://dev.w3.org/2009/dap/file-system/pub/FileSystem/#bib-FILE-WRITER&quot;&gt;File Writer에&lt;/a&gt; 설명 된 &lt;code&gt;FileError&lt;/code&gt; 인터페이스를 확장하고 몇 가지 새로운 오류 코드를 추가합니다.</target>
        </trans-unit>
        <trans-unit id="31b81cbbb80d238a2f89066bdaabab365cf298d7" translate="yes" xml:space="preserve">
          <source>In the &lt;a href=&quot;webvr_api&quot;&gt;WebVR API&lt;/a&gt;, &lt;code&gt;DOMPoint&lt;/code&gt; values are used to represent points in the coordinate space that the user's head mounted display exists in. In the following snippet, the position of the VR HMD can be retrieved by first grabbing a reference to the position sensor's current state using &lt;a href=&quot;positionsensorvrdevice/getstate&quot;&gt;&lt;code&gt;PositionSensorVRDevice.getState()&lt;/code&gt;&lt;/a&gt;, then accessing the resulting &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/VRPositionState&quot;&gt;&lt;code&gt;VRPositionState&lt;/code&gt;&lt;/a&gt;'s &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/VRPositionState/position&quot;&gt;&lt;code&gt;position&lt;/code&gt;&lt;/a&gt; property, which returns a &lt;code&gt;DOMPoint&lt;/code&gt;. Note below the usage of &lt;code&gt;position.x&lt;/code&gt;, &lt;code&gt;position.y&lt;/code&gt;, and &lt;code&gt;position.z&lt;/code&gt;.</source>
          <target state="translated">에서 &lt;a href=&quot;webvr_api&quot;&gt;WebVR의 API&lt;/a&gt; , &lt;code&gt;DOMPoint&lt;/code&gt; 의 값은 사용자의 머리가 디스플레이에 존재하는 장착되는 좌표 공간의 점을 나타 내기 위해 사용된다. 다음 코드에서, VR HMD의 위치가 위치 센서의 현재 상태에 대한 참조를 잡아 제에 의해 검색 될 수있다 &lt;a href=&quot;positionsensorvrdevice/getstate&quot;&gt; &lt;code&gt;PositionSensorVRDevice.getState()&lt;/code&gt; &lt;/a&gt; 사용하여 결과 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/VRPositionState&quot;&gt; &lt;code&gt;VRPositionState&lt;/code&gt; &lt;/a&gt; 의 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/VRPositionState/position&quot;&gt; &lt;code&gt;position&lt;/code&gt; &lt;/a&gt; 속성에 액세스하면 DOMPoint 가 반환 &lt;code&gt;DOMPoint&lt;/code&gt; . &lt;code&gt;position.x&lt;/code&gt; , &lt;code&gt;position.y&lt;/code&gt; 및 &lt;code&gt;position.z&lt;/code&gt; 사용법을 아래에 참고하십시오 .</target>
        </trans-unit>
        <trans-unit id="bb1fc260c83966dd331019cec75ccb6c2f27f605" translate="yes" xml:space="preserve">
          <source>In the &lt;code&gt;displayPoseStats()&lt;/code&gt; function, we grab all of the data we want to display out of the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/GamepadPose&quot;&gt;&lt;code&gt;GamepadPose&lt;/code&gt;&lt;/a&gt; object passed into it, then print them into the UI panel that exists in the demo for displaying such data:</source>
          <target state="translated">에서 &lt;code&gt;displayPoseStats()&lt;/code&gt; 기능, 우리는 우리가 밖으로 표시 할 데이터를 모두 잡아 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/GamepadPose&quot;&gt; &lt;code&gt;GamepadPose&lt;/code&gt; 의&lt;/a&gt; 그것으로 전달 된 객체를 다음과 같은 데이터를 표시하기위한 데모에 존재하는 UI 패널로 인쇄 :</target>
        </trans-unit>
        <trans-unit id="7c51818ebbd3921f216a6e778639df0d79c9f898" translate="yes" xml:space="preserve">
          <source>In the &lt;code&gt;draw()&lt;/code&gt; function, we call the &lt;code&gt;fillRect()&lt;/code&gt; function nine times using two &lt;code&gt;for&lt;/code&gt; loops. In each loop, the canvas is translated, the rectangle is drawn, and the canvas is returned back to its original state. Note how the call to &lt;code&gt;fillRect()&lt;/code&gt; uses the same coordinates each time, relying on &lt;code&gt;translate()&lt;/code&gt; to adjust the drawing position.</source>
          <target state="translated">에서 &lt;code&gt;draw()&lt;/code&gt; 함수를, 우리는 전화 &lt;code&gt;fillRect()&lt;/code&gt; 이 사용하는 기능을 아홉 번 &lt;code&gt;for&lt;/code&gt; 루프. 각 루프에서 캔버스가 변환되고 사각형이 그려지며 캔버스가 원래 상태로 돌아갑니다. &lt;code&gt;fillRect()&lt;/code&gt; 호출 은 매번 동일한 좌표를 사용하여 &lt;code&gt;translate()&lt;/code&gt; 를 사용하여 드로잉 위치를 조정하는 방법에 유의하십시오 .</target>
        </trans-unit>
        <trans-unit id="b56af66348fd5d195d217eafa61955360f6eb10f" translate="yes" xml:space="preserve">
          <source>In the &lt;code&gt;readStream()&lt;/code&gt; function itself, we lock a reader to the stream using &lt;a href=&quot;../readablestream/getreader&quot;&gt;&lt;code&gt;ReadableStream.getReader()&lt;/code&gt;&lt;/a&gt;, then follow the same kind of pattern we saw earlier &amp;mdash; reading each chunk with &lt;code&gt;read()&lt;/code&gt;, checking whether &lt;code&gt;done&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt; and then ending the process if so, and reading the next chunk and processing it if not, before running the &lt;code&gt;read()&lt;/code&gt; function again.</source>
          <target state="translated">에서 &lt;code&gt;readStream()&lt;/code&gt; 함수 자체, 우리가 사용하여 스트림에 독자 잠금 &lt;a href=&quot;../readablestream/getreader&quot;&gt; &lt;code&gt;ReadableStream.getReader()&lt;/code&gt; &lt;/a&gt; 와 각 청크 읽기 - 다음, 우리가 이전에 보았던 패턴의 동일한 종류에 따라 &lt;code&gt;read()&lt;/code&gt; 여부를 확인, &lt;code&gt;done&lt;/code&gt; 있다 &lt;code&gt;true&lt;/code&gt; 후 종료 &lt;code&gt;read()&lt;/code&gt; 함수를 다시 실행하기 전에 처리하고 다음 청크를 읽고 처리하지 않으면 처리 하십시오.</target>
        </trans-unit>
        <trans-unit id="bb029e4341e6bd4f62bafbfdb2ab6af6d7d6b7b3" translate="yes" xml:space="preserve">
          <source>In the &lt;code&gt;updateStyle()&lt;/code&gt; function itself, we get a reference to the shadow DOM using &lt;a href=&quot;element/shadowroot&quot;&gt;&lt;code&gt;Element.shadowRoot&lt;/code&gt;&lt;/a&gt;. From here we use standard DOM traversal techniques to find the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/style&quot;&gt;&lt;code&gt;&amp;lt;style&amp;gt;&lt;/code&gt;&lt;/a&gt; element inside the shadow DOM and then update the CSS found inside it:</source>
          <target state="translated">에서 &lt;code&gt;updateStyle()&lt;/code&gt; 함수 자체, 우리는를 사용하여 섀도우 DOM 참조 얻을 &lt;a href=&quot;element/shadowroot&quot;&gt; &lt;code&gt;Element.shadowRoot&lt;/code&gt; 를&lt;/a&gt; . 여기에서 표준 DOM 탐색 기술을 사용 하여 shadow DOM 에서 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/style&quot;&gt; &lt;code&gt;&amp;lt;style&amp;gt;&lt;/code&gt; &lt;/a&gt; 요소를 찾은 다음 그 안에있는 CSS를 업데이트합니다.</target>
        </trans-unit>
        <trans-unit id="9c6ff5af1334148b91029abc027cca914a15f932" translate="yes" xml:space="preserve">
          <source>In the &lt;code&gt;updateStyle()&lt;/code&gt; function itself, we get a reference to the shadow DOM using &lt;a href=&quot;shadowroot&quot;&gt;&lt;code&gt;Element.shadowRoot&lt;/code&gt;&lt;/a&gt;. From here we use standard DOM traversal techniques to find the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/style&quot;&gt;&lt;code&gt;&amp;lt;style&amp;gt;&lt;/code&gt;&lt;/a&gt; element inside the shadow DOM and then update the CSS found inside it:</source>
          <target state="translated">에서 &lt;code&gt;updateStyle()&lt;/code&gt; 함수 자체, 우리는를 사용하여 섀도우 DOM 참조 얻을 &lt;a href=&quot;shadowroot&quot;&gt; &lt;code&gt;Element.shadowRoot&lt;/code&gt; 를&lt;/a&gt; . 여기에서 표준 DOM 탐색 기술을 사용 하여 shadow DOM 에서 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/style&quot;&gt; &lt;code&gt;&amp;lt;style&amp;gt;&lt;/code&gt; &lt;/a&gt; 요소를 찾은 다음 그 안에있는 CSS를 업데이트합니다.</target>
        </trans-unit>
        <trans-unit id="04650fa0d0cd02a07bf39fff451f43fb09793e92" translate="yes" xml:space="preserve">
          <source>In the &lt;code&gt;worker.js&lt;/code&gt; script, a &lt;code&gt;DedicatedWorkerGlobalScope.onmessage&lt;/code&gt; handler is used to handle messages from the main script:</source>
          <target state="translated">에서 &lt;code&gt;worker.js&lt;/code&gt; 의 스크립트하는 &lt;code&gt;DedicatedWorkerGlobalScope.onmessage&lt;/code&gt; 의 핸들러는 주요 스크립트에서 핸들 메시지를 사용합니다 :</target>
        </trans-unit>
        <trans-unit id="7a0be8078e13bc0c5378221913e5c62968ec583b" translate="yes" xml:space="preserve">
          <source>In the &lt;code&gt;worker.js&lt;/code&gt; script, an &lt;code&gt;onmessage&lt;/code&gt; handler is used the handle messages from the main script:</source>
          <target state="translated">에서 &lt;code&gt;worker.js&lt;/code&gt; 스크립트, &lt;code&gt;onmessage&lt;/code&gt; 핸들러는 주요 스크립트에서 핸들 메시지를 사용합니다 :</target>
        </trans-unit>
        <trans-unit id="46c335918199385a46beee58c2f3e09cb27b9c1f" translate="yes" xml:space="preserve">
          <source>In the HTML we just need to hook our function to the `onkeypress` event and specify that our textarea does not accept pasting:</source>
          <target state="translated">HTML에서 우리는 함수를 'onkeypress'이벤트에 연결하고 텍스트 영역이 붙여 넣기를 허용하지 않도록 지정하면됩니다.</target>
        </trans-unit>
        <trans-unit id="9eaf6573ce3ac8e6c6ba35bfea60e7baeeeb376e" translate="yes" xml:space="preserve">
          <source>In the Media Stream API, both &lt;a href=&quot;../mediastream&quot;&gt;&lt;code&gt;MediaStream&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../mediastreamtrack&quot;&gt;&lt;code&gt;MediaStreamTrack&lt;/code&gt;&lt;/a&gt; have constrainable properties.</source>
          <target state="translated">Media Stream API에서 &lt;a href=&quot;../mediastream&quot;&gt; &lt;code&gt;MediaStream&lt;/code&gt; &lt;/a&gt; 과 &lt;a href=&quot;../mediastreamtrack&quot;&gt; &lt;code&gt;MediaStreamTrack&lt;/code&gt; &lt;/a&gt; 모두 제한적인 속성을 갖습니다.</target>
        </trans-unit>
        <trans-unit id="159a217b1d19a1ba5a26df24bfe572fb5946b57a" translate="yes" xml:space="preserve">
          <source>In the above example it can be observed that we can use the identifier and pseudo class name for defining the language of caption, where &lt;code&gt;&amp;lt;i&amp;gt;&lt;/code&gt; tag is for italics.</source>
          <target state="translated">위의 예에서 &lt;code&gt;&amp;lt;i&amp;gt;&lt;/code&gt; 태그는 기울임 꼴 인 캡션 언어를 정의하기 위해 식별자와 의사 클래스 이름을 사용할 수 있음을 알 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="2ea2b539c7a1c9b9602da25dfb485fd9becc08f6" translate="yes" xml:space="preserve">
          <source>In the above example, &lt;code&gt;#text&lt;/code&gt; nodes are inserted in the DOM where whitespace occurs between tags (i.e. after the closing tag of an element and before the opening tag of the next).</source>
          <target state="translated">위의 예에서 &lt;code&gt;#text&lt;/code&gt; 노드는 태그 사이에 공백이 발생하는 DOM에 삽입됩니다 (예 : 요소의 닫는 태그 다음과 다음의 여는 태그 앞에).</target>
        </trans-unit>
        <trans-unit id="2c6ec540892c01e0fe46e63eef1516429f317e9b" translate="yes" xml:space="preserve">
          <source>In the above example, &lt;code&gt;selObj.toString()&lt;/code&gt; is automatically called when it is passed to &lt;a href=&quot;../window/alert&quot;&gt;&lt;code&gt;Window.alert()&lt;/code&gt;&lt;/a&gt;. However, attempting to use a JavaScript &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String&quot;&gt;String&lt;/a&gt; property or method such as &lt;code&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/length&quot;&gt;length&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/substr&quot;&gt;substr&lt;/a&gt;&lt;/code&gt; directly on a &lt;a href=&quot;../selection&quot;&gt;&lt;code&gt;Selection&lt;/code&gt;&lt;/a&gt; object results in an error if it does not have that property or method and may return unexpected results if it does. To use a &lt;code&gt;Selection&lt;/code&gt; object as a string, call its &lt;code&gt;toString()&lt;/code&gt; method directly:</source>
          <target state="translated">위의 예제에서 &lt;code&gt;selObj.toString()&lt;/code&gt; 은 &lt;a href=&quot;../window/alert&quot;&gt; &lt;code&gt;Window.alert()&lt;/code&gt; &lt;/a&gt; 전달 될 때 자동으로 호출됩니다 . 그러나 &lt;a href=&quot;../selection&quot;&gt; &lt;code&gt;Selection&lt;/code&gt; &lt;/a&gt; 객체에서 직접 &lt;code&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/length&quot;&gt;length&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/substr&quot;&gt;substr&lt;/a&gt;&lt;/code&gt; 과 같은 JavaScript &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String&quot;&gt;문자열&lt;/a&gt; 속성 또는 메서드 를 사용하려고하면 해당 속성이나 메서드가없는 경우 오류가 발생하고 예상치 않은 결과가 반환 될 수 있습니다. &lt;code&gt;Selection&lt;/code&gt; 객체를 문자열로 사용하려면 &lt;code&gt;toString()&lt;/code&gt; 메서드를 직접 호출하십시오 .</target>
        </trans-unit>
        <trans-unit id="a89d604b3477fbfe0e9e3f5d0a2727debd14b6b3" translate="yes" xml:space="preserve">
          <source>In the above example, &lt;code&gt;selObj.toString()&lt;/code&gt; is automatically called when it is passed to &lt;a href=&quot;alert&quot;&gt;&lt;code&gt;window.alert()&lt;/code&gt;&lt;/a&gt;. However, attempting to use a JavaScript &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String&quot;&gt;String&lt;/a&gt; property or method such as &lt;code&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/length&quot;&gt;length&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/substr&quot;&gt;substr&lt;/a&gt;&lt;/code&gt; directly on a &lt;a href=&quot;../selection&quot;&gt;&lt;code&gt;Selection&lt;/code&gt;&lt;/a&gt; object will result in an error if it does not have that property or method and may return unexpected results if it does. To use a &lt;code&gt;Selection&lt;/code&gt; object as a string, call its &lt;code&gt;toString()&lt;/code&gt; method directly:</source>
          <target state="translated">위의 예에서 &lt;code&gt;selObj.toString()&lt;/code&gt; 은 &lt;a href=&quot;alert&quot;&gt; &lt;code&gt;window.alert()&lt;/code&gt; &lt;/a&gt; 전달 될 때 자동으로 호출됩니다 . 그러나 &lt;a href=&quot;../selection&quot;&gt; &lt;code&gt;Selection&lt;/code&gt; &lt;/a&gt; 객체 에서 직접 &lt;code&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/length&quot;&gt;length&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/substr&quot;&gt;substr&lt;/a&gt;&lt;/code&gt; 과 같은 JavaScript &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String&quot;&gt;문자열&lt;/a&gt; 속성 또는 메서드 를 사용하려고하면 해당 속성이나 메서드가없는 경우 오류가 발생하고 예기치 않은 결과가 반환 될 수 있습니다. &lt;code&gt;Selection&lt;/code&gt; 객체를 문자열로 사용하려면 &lt;code&gt;toString()&lt;/code&gt; 메서드를 직접 호출하십시오 .</target>
        </trans-unit>
        <trans-unit id="b312d18e2d1af2f83dda821db09d7aa9fdb45b7f" translate="yes" xml:space="preserve">
          <source>In the above examples &lt;code&gt;ws&lt;/code&gt; has replaced &lt;code&gt;http&lt;/code&gt;, similarly &lt;code&gt;wss&lt;/code&gt; replaces &lt;code&gt;https&lt;/code&gt;. Establishing a WebSocket relies on the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTTP/Protocol_upgrade_mechanism&quot;&gt;HTTP Upgrade mechanism&lt;/a&gt;, so the request for the protocol upgrade is implicit when we address the HTTP server as &lt;code&gt;ws://www.example.com&lt;/code&gt; or &lt;code&gt;wss://www.example.com&lt;/code&gt;.</source>
          <target state="translated">위 예제에서 &lt;code&gt;ws&lt;/code&gt; 는 &lt;code&gt;http&lt;/code&gt; 를 대체 했으며, 마찬가지로 &lt;code&gt;wss&lt;/code&gt; 는 &lt;code&gt;https&lt;/code&gt; 를 대체합니다 . WebSocket을 구축하려면 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTTP/Protocol_upgrade_mechanism&quot;&gt;HTTP 업그레이드 메커니즘&lt;/a&gt; 을 사용하므로 HTTP 서버에 &lt;code&gt;ws://www.example.com&lt;/code&gt; 또는 &lt;code&gt;wss://www.example.com&lt;/code&gt; 으로 주소를 지정할 때 프로토콜 업그레이드 요청이 암시 적 입니다.</target>
        </trans-unit>
        <trans-unit id="5ca15d3b8cb4a4353208bf48eb6ce069f10ddff6" translate="yes" xml:space="preserve">
          <source>In the above snippet, a named function &lt;code&gt;loop()&lt;/code&gt; is declared and is immediately executed. &lt;code&gt;loop()&lt;/code&gt; is recursively called inside &lt;code&gt;setTimeout()&lt;/code&gt; after the logic has completed executing. While this pattern does not guarantee execution on a fixed interval, it does guarantee that the previous interval has completed before recursing.</source>
          <target state="translated">위의 코드 조각에서 이름이 지정된 함수 &lt;code&gt;loop()&lt;/code&gt; 가 선언되고 즉시 실행됩니다. 논리 실행이 완료된 후 &lt;code&gt;setTimeout()&lt;/code&gt; 내에서 &lt;code&gt;loop()&lt;/code&gt; 가 재귀 적으로 호출됩니다 . 이 패턴은 고정 된 간격에서 실행을 보장하지는 않지만 반복하기 전에 이전 간격이 완료되었음을 보장합니다.</target>
        </trans-unit>
        <trans-unit id="038d50dc49f2e3b4b746867cf1c760513919ead8" translate="yes" xml:space="preserve">
          <source>In the above, the &lt;a href=&quot;../console&quot;&gt;console&lt;/a&gt; will show '#text' because a text node is inserted to maintain the whitespace between the end of the opening &lt;code&gt;&amp;lt;p&amp;gt;&lt;/code&gt; and &lt;code&gt;&amp;lt;span&amp;gt;&lt;/code&gt; tags. &lt;strong&gt;Any&lt;/strong&gt;&lt;a href=&quot;../document_object_model/whitespace_in_the_dom&quot;&gt;whitespace&lt;/a&gt; will create a &lt;code&gt;#text&lt;/code&gt; node, from a single space to multiple spaces, returns, tabs, and so on.</source>
          <target state="translated">위의 &lt;code&gt;&amp;lt;p&amp;gt;&lt;/code&gt; &lt;code&gt;&amp;lt;span&amp;gt;&lt;/code&gt; 태그 와 &amp;lt;span&amp;gt; 태그 사이에 공백을 유지하기 위해 텍스트 노드가 삽입되었으므로 &lt;a href=&quot;../console&quot;&gt;콘솔에&lt;/a&gt; '#text'가 표시됩니다 . &lt;strong&gt;모든 &lt;/strong&gt;&lt;a href=&quot;../document_object_model/whitespace_in_the_dom&quot;&gt;공백&lt;/a&gt; 은 단일 공백에서 여러 공백, 리턴, 탭 등 &lt;code&gt;#text&lt;/code&gt; 노드 를 만듭니다 .&lt;strong&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="367d14782071c764710cebf410d8d975d3cbc7b3" translate="yes" xml:space="preserve">
          <source>In the article &lt;a href=&quot;web_audio_api/controlling_multiple_parameters_with_constantsourcenode&quot;&gt;Controlling multiple parameters with ConstantSourceNode&lt;/a&gt;, a &lt;code&gt;ConstantSourceNode&lt;/code&gt; is created to allow one slider control to change the gain on two &lt;a href=&quot;gainnode&quot;&gt;&lt;code&gt;GainNode&lt;/code&gt;&lt;/a&gt;s. The three nodes are set up like this:</source>
          <target state="translated">&lt;a href=&quot;web_audio_api/controlling_multiple_parameters_with_constantsourcenode&quot;&gt;ConstantSourceNode&lt;/a&gt; 를 사용하여 여러 매개 변수 제어 기사에서 하나의 슬라이더 제어가 두 개의 &lt;a href=&quot;gainnode&quot;&gt; &lt;code&gt;GainNode&lt;/code&gt; &lt;/a&gt; 에서 게인을 변경할 수 있도록 &lt;code&gt;ConstantSourceNode&lt;/code&gt; 가 작성됩니다 . 세 개의 노드는 다음과 같이 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="4b77e474bcf3ab917f6ed436e550316024843d15" translate="yes" xml:space="preserve">
          <source>In the beginning, JavaScript and the DOM were tightly intertwined, but eventually, they evolved into separate entities. The page content is stored in the DOM and may be accessed and manipulated via JavaScript, so that we may write this approximative equation:</source>
          <target state="translated">처음에는 JavaScript와 DOM이 밀접하게 얽혀 있었지만 결국에는 별도의 엔터티로 발전했습니다. 페이지 내용은 DOM에 저장되며 JavaScript를 통해 액세스하고 조작 할 수 있으므로 다음과 같은 근사 방정식을 작성할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5bb136d61139a16fcd17f87f13d568e3b53f76eb" translate="yes" xml:space="preserve">
          <source>In the below sections we'll look at our raw-webgl-demo in detail, and see where exactly the above features are used.</source>
          <target state="translated">아래 섹션에서는 raw-webgl-demo를 자세히 살펴보고 위의 기능이 정확히 사용되는 위치를 봅니다.</target>
        </trans-unit>
        <trans-unit id="710670cb1700ac6bed01130dcfab169685441a86" translate="yes" xml:space="preserve">
          <source>In the box demo an additional &lt;code&gt;.computeSimpleProjectionMatrix()&lt;/code&gt; method is added. This is called in the &lt;code&gt;.draw()&lt;/code&gt; method and has the scale factor passed to it. The result should be identical to the last example:</source>
          <target state="translated">박스 데모에는 추가 &lt;code&gt;.computeSimpleProjectionMatrix()&lt;/code&gt; 메소드가 추가됩니다. 이것은 &lt;code&gt;.draw()&lt;/code&gt; 메소드 에서 호출되며 스케일 팩터가 전달됩니다. 결과는 마지막 예와 동일해야합니다.</target>
        </trans-unit>
        <trans-unit id="f23d9de14b710f223f240ff496d1dc7617be6575" translate="yes" xml:space="preserve">
          <source>In the case of an HTML document, you can also replace portions of the DOM with new DOM trees built from HTML by setting the value of the &lt;a href=&quot;element/innerhtml&quot;&gt;&lt;code&gt;Element.innerHTML&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;element/outerhtml&quot;&gt;&lt;code&gt;outerHTML&lt;/code&gt;&lt;/a&gt; properties. These properties can also be read to fetch HTML fragments corresponding to the corresponding DOM subtree.</source>
          <target state="translated">HTML 문서의 경우 &lt;a href=&quot;element/innerhtml&quot;&gt; &lt;code&gt;Element.innerHTML&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;element/outerhtml&quot;&gt; &lt;code&gt;outerHTML&lt;/code&gt; &lt;/a&gt; 속성 값을 설정하여 DOM의 일부를 HTML로 작성된 새 DOM 트리로 바꿀 수도 있습니다. 이러한 속성은 해당 DOM 하위 트리에 해당하는 HTML 조각을 가져 오기 위해 읽을 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="ae5881bd36ab53447d14d96fa581095cfc3ec7b3" translate="yes" xml:space="preserve">
          <source>In the case of audio, a disabled track generates frames of silence (that is, frames in which every sample's value is 0). For video tracks, every frame is filled entirely with black pixels.</source>
          <target state="translated">오디오의 경우, 비활성화 된 트랙은 무음 프레임 (즉, 모든 샘플 값이 0 인 프레임)을 생성합니다. 비디오 트랙의 경우 모든 프레임이 완전히 검은 색 픽셀로 채워집니다.</target>
        </trans-unit>
        <trans-unit id="91e954687ec9108d17a620e698e7b922f3826401" translate="yes" xml:space="preserve">
          <source>In the case of each cue:</source>
          <target state="translated">각 큐의 경우 :</target>
        </trans-unit>
        <trans-unit id="134c6dc788f159c41ef3215b21caa99007fa1a6c" translate="yes" xml:space="preserve">
          <source>In the case of readable streams, these are the chunks that have been enqueued but not yet read</source>
          <target state="translated">읽을 수있는 스트림의 경우 대기열에 있지만 아직 읽지 않은 청크</target>
        </trans-unit>
        <trans-unit id="3f53490f9424fcb6f6b4369c3cc51225440326d7" translate="yes" xml:space="preserve">
          <source>In the case of writable streams, these are chunks that have been written but not yet processed by the underlying sink.</source>
          <target state="translated">쓰기 가능한 스트림의 경우, 기본 싱크에 의해 작성되었지만 아직 처리되지 않은 청크입니다.</target>
        </trans-unit>
        <trans-unit id="be56e67b0d7c13ff05b3c79f41df3127c8b70dd0" translate="yes" xml:space="preserve">
          <source>In the case you need to obtain more details about the text, the following method allows you to measure it.</source>
          <target state="translated">텍스트에 대한 자세한 정보가 필요한 경우 다음 방법을 사용하여 텍스트를 측정 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="361649fe0478299dc207f1091242e89204e295a2" translate="yes" xml:space="preserve">
          <source>In the chapter about &lt;a href=&quot;drawing_shapes&quot;&gt;drawing shapes&lt;/a&gt; I only mentioned the &lt;code&gt;stroke()&lt;/code&gt; and &lt;code&gt;fill()&lt;/code&gt; methods, but there's a third method we can use with paths, called &lt;code&gt;clip()&lt;/code&gt;.</source>
          <target state="translated">&lt;a href=&quot;drawing_shapes&quot;&gt;도형 그리기&lt;/a&gt; 에 관한 장에서는 &lt;code&gt;stroke()&lt;/code&gt; 및 &lt;code&gt;fill()&lt;/code&gt; 메서드 만 언급 했지만 &lt;code&gt;clip()&lt;/code&gt; 이라는 경로와 함께 사용할 수있는 세 번째 방법이 있습니다 .</target>
        </trans-unit>
        <trans-unit id="a556f68a246f6b0190846f10137ad4c3abd05977" translate="yes" xml:space="preserve">
          <source>In the chapter about &lt;a href=&quot;drawing_shapes&quot;&gt;drawing shapes&lt;/a&gt;, we used only the default line and fill styles. Here we will explore the canvas options we have at our disposal to make our drawings a little more attractive. You will learn how to add different colors, line styles, gradients, patterns and shadows to your drawings.</source>
          <target state="translated">&lt;a href=&quot;drawing_shapes&quot;&gt;도형 그리기&lt;/a&gt; 에 관한 장에서는 기본 선 및 채우기 스타일 만 사용했습니다. 여기서 우리는 그림을 좀 더 매력적으로 만들기 위해 우리가 사용할 수있는 캔버스 옵션을 살펴볼 것입니다. 도면에 다른 색상, 선 스타일, 그라디언트, 패턴 및 그림자를 추가하는 방법을 배웁니다.</target>
        </trans-unit>
        <trans-unit id="c631c29a2b75acd27f3b25ebe6d701570901afdb" translate="yes" xml:space="preserve">
          <source>In the code above &lt;var&gt;allCookies&lt;/var&gt; is a string containing a semicolon-separated list of all cookies (i.e. &lt;code&gt;&lt;var&gt;key&lt;/var&gt;=&lt;var&gt;value&lt;/var&gt;&lt;/code&gt; pairs). Note that each &lt;var&gt;key&lt;/var&gt; and &lt;var&gt;value&lt;/var&gt; may be surrounded by whitespace (space and tab characters): in fact &lt;a href=&quot;https://tools.ietf.org/html/rfc6265&quot;&gt;RFC 6265&lt;/a&gt; mandates a single space after each semicolon, but some user agents may not abide by this.</source>
          <target state="translated">위 코드에서 &lt;var&gt;allCookies&lt;/var&gt; 는 세미콜론으로 구분 된 모든 쿠키 목록 (예 : &lt;code&gt;&lt;var&gt;key&lt;/var&gt;=&lt;var&gt;value&lt;/var&gt;&lt;/code&gt; 쌍)을 포함하는 문자열 입니다. 각 &lt;var&gt;key&lt;/var&gt; 와 &lt;var&gt;value&lt;/var&gt; 은 공백 (공백 및 탭 문자)으로 &lt;a href=&quot;https://tools.ietf.org/html/rfc6265&quot;&gt;묶을 수&lt;/a&gt; 있습니다. 실제로 RFC 6265 는 각 세미콜론 다음에 단일 공백을 요구하지만 일부 사용자 에이전트는이를 준수하지 않을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1beb82ea79fef09ff7e1a22efa54cee0599c7186" translate="yes" xml:space="preserve">
          <source>In the code above, &lt;code&gt;newCookie&lt;/code&gt; is a string of form &lt;code&gt;&lt;var&gt;key&lt;/var&gt;=&lt;var&gt;value&lt;/var&gt;&lt;/code&gt;. Note that you can only set/update a single cookie at a time using this method. Consider also that:</source>
          <target state="translated">위 코드에서 &lt;code&gt;newCookie&lt;/code&gt; 는 양식 &lt;code&gt;&lt;var&gt;key&lt;/var&gt;=&lt;var&gt;value&lt;/var&gt;&lt;/code&gt; 의 문자열입니다 . 이 방법을 사용하면 한 번에 하나의 쿠키 만 설정 / 업데이트 할 수 있습니다. 또한 다음을 고려하십시오.</target>
        </trans-unit>
        <trans-unit id="751430196020e462a1062f8a888bc205355532d9" translate="yes" xml:space="preserve">
          <source>In the code example, &quot;caches&quot; is an attribute of the service worker's &lt;code&gt;WorkerGlobalScope&lt;/code&gt;. It holds the &lt;code&gt;CacheStorage&lt;/code&gt; object, by which by can access the &lt;a href=&quot;cachestorage&quot;&gt;&lt;code&gt;CacheStorage&lt;/code&gt;&lt;/a&gt; interface.</source>
          <target state="translated">코드 예제에서 &quot;caches&quot;는 서비스 워커의 &lt;code&gt;WorkerGlobalScope&lt;/code&gt; 의 속성입니다 . 그것은 보유 &lt;code&gt;CacheStorage&lt;/code&gt; 에 액세스 할 수 있습니다로하는 객체, &lt;a href=&quot;cachestorage&quot;&gt; &lt;code&gt;CacheStorage&lt;/code&gt; 의&lt;/a&gt; 인터페이스를.</target>
        </trans-unit>
        <trans-unit id="790fbaf97cead8a6a45860bb674cff8e4c36ab8a" translate="yes" xml:space="preserve">
          <source>In the common case the base URL is simply the location of the document, but it can be affected by many factors, including the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/base&quot;&gt;&lt;code&gt;&amp;lt;base&amp;gt;&lt;/code&gt;&lt;/a&gt; element in HTML and &lt;code&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/XML/xml:base&quot;&gt;xml:base&lt;/a&gt;&lt;/code&gt; attribute in XML.</source>
          <target state="translated">일반적인 경우 기본 URL은 단순히 문서의 위치이지만 HTML 의 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/base&quot;&gt; &lt;code&gt;&amp;lt;base&amp;gt;&lt;/code&gt; &lt;/a&gt; 요소 및 &lt;code&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/XML/xml:base&quot;&gt;xml:base&lt;/a&gt;&lt;/code&gt; 속성을 포함하여 많은 요인의 영향을받을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="e5efef753ebf52497839ffd70a6f90392e3a260d" translate="yes" xml:space="preserve">
          <source>In the console, the following trace will be displayed:</source>
          <target state="translated">콘솔에서 다음 추적이 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="184092cb6374f0fdb574e64edd6fa7228f3006f0" translate="yes" xml:space="preserve">
          <source>In the definition of &lt;code&gt;render()&lt;/code&gt; if &lt;code&gt;copyVideo&lt;/code&gt; is true, then we call &lt;code&gt;updateTexture()&lt;/code&gt; each time just before we call the &lt;code&gt;drawScene()&lt;/code&gt; function.</source>
          <target state="translated">의 정의에서 &lt;code&gt;render()&lt;/code&gt; 경우 &lt;code&gt;copyVideo&lt;/code&gt; 는 사실, 우리는 전화 &lt;code&gt;updateTexture()&lt;/code&gt; 우리가 전화를하기 직전마다 &lt;code&gt;drawScene()&lt;/code&gt; 함수를.</target>
        </trans-unit>
        <trans-unit id="1a2b40f1952f87fed97f07552defd99596f27dfe" translate="yes" xml:space="preserve">
          <source>In the demo &lt;a href=&quot;https://codepen.io/rachelnabors/pen/rxpmJL/?editors=0010&quot;&gt;Down the Rabbit Hole (with the Web Animation API)&lt;/a&gt;, we use the convenient &lt;code&gt;animate()&lt;/code&gt; method to immediately create and play an animation on the &lt;code&gt;#tunnel&lt;/code&gt; element to make it flow upwards, infinitely. Notice the array of objects passed as keyframes and also the timing options block.</source>
          <target state="translated">&lt;a href=&quot;https://codepen.io/rachelnabors/pen/rxpmJL/?editors=0010&quot;&gt;토끼 구멍 아래로&lt;/a&gt; 데모 (웹 애니메이션 API 사용)에서는 편리한 &lt;code&gt;animate()&lt;/code&gt; 메서드를 사용하여 &lt;code&gt;#tunnel&lt;/code&gt; 요소에서 애니메이션을 즉시 생성하고 재생하여 무한대로 위로 흐르게합니다. 키 프레임으로 전달 된 객체 배열과 타이밍 옵션 블록을 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="202f4b98e2e457f51462bd23a0954aa84dff43bc" translate="yes" xml:space="preserve">
          <source>In the example below, 10 straight lines are drawn with increasing line widths. The line on the far left is 1.0 units wide. However, the leftmost and all other odd-integer-width thickness lines do not appear crisp, because of the path's positioning.</source>
          <target state="translated">아래 예에서는 10 개의 직선이 선 너비를 늘려 그려집니다. 가장 왼쪽의 선은 1.0 단위입니다. 그러나 경로의 위치 때문에 가장 왼쪽 및 다른 모든 홀수 너비 두께 선은 선명하게 나타나지 않습니다.</target>
        </trans-unit>
        <trans-unit id="4780447d1e77484538059276c40fc54c59ac1837" translate="yes" xml:space="preserve">
          <source>In the example below, &lt;code&gt;onpayerdetailchange&lt;/code&gt; is used to set up a listener for the &lt;code&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Events/payerdetailchange&quot;&gt;payerdetailchange&lt;/a&gt;&lt;/code&gt; event in order to validate the information entered by the user, requesting that any mistakes be corrected</source>
          <target state="translated">아래 예에서 &lt;code&gt;onpayerdetailchange&lt;/code&gt; 는 사용자가 입력 한 정보의 유효성을 검증하기 위해 &lt;code&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Events/payerdetailchange&quot;&gt;payerdetailchange&lt;/a&gt;&lt;/code&gt; 이벤트에 대한 리스너를 설정하는 데 사용되어 실수를 정정하도록 요청합니다.</target>
        </trans-unit>
        <trans-unit id="206c3c63cab7b422d50e2a3959c149ce7f63615b" translate="yes" xml:space="preserve">
          <source>In the example below, a data channel is established, and an &lt;code&gt;onerror&lt;/code&gt; handler is added to it. The error handler passes information about the error to a UI library's alert box function to present an error message to the user.</source>
          <target state="translated">아래 예에서 데이터 채널이 설정되고 &lt;code&gt;onerror&lt;/code&gt; 핸들러가 추가됩니다. 오류 처리기는 오류에 대한 정보를 UI 라이브러리의 경고 상자 함수에 전달하여 사용자에게 오류 메시지를 표시합니다.</target>
        </trans-unit>
        <trans-unit id="cc512e47a94228213beabd56b67ae6b89f92ac38" translate="yes" xml:space="preserve">
          <source>In the example below, the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/PaymentRequest/onshippingaoptionchange&quot;&gt;&lt;code&gt;PaymentRequest.onshippingaoptionchange&lt;/code&gt;&lt;/a&gt; event is called. It calls &lt;code&gt;updateDetails()&lt;/code&gt; to toggle the shipping method between &quot;standard&quot; and &quot;express&quot;.</source>
          <target state="translated">아래 예에서 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/PaymentRequest/onshippingaoptionchange&quot;&gt; &lt;code&gt;PaymentRequest.onshippingaoptionchange&lt;/code&gt; &lt;/a&gt; 이벤트가 호출됩니다. &lt;code&gt;updateDetails()&lt;/code&gt; 를 호출 하여 운송 방법을 &quot;standard&quot;과 &quot;express&quot;사이에서 전환합니다.</target>
        </trans-unit>
        <trans-unit id="034961eecc07f0e41d6e1c8958f78f79a6d78deb" translate="yes" xml:space="preserve">
          <source>In the example below, the &lt;a href=&quot;onshippingoptionchange&quot;&gt;&lt;code&gt;PaymentRequest.onshippingoptionchange&lt;/code&gt;&lt;/a&gt; and the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/PaymentRequest/onshippingaoptionchange&quot;&gt;&lt;code&gt;PaymentRequest.onshippingaoptionchange&lt;/code&gt;&lt;/a&gt; events are dispatched. In each calls to &lt;code&gt;updateDetails()&lt;/code&gt; are made, one using a promise, and the other with a plain JS object. This demotrates synchrounous and asynchronous updates to a payment sheet.</source>
          <target state="translated">아래 예에서 &lt;a href=&quot;onshippingoptionchange&quot;&gt; &lt;code&gt;PaymentRequest.onshippingoptionchange&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/PaymentRequest/onshippingaoptionchange&quot;&gt; &lt;code&gt;PaymentRequest.onshippingaoptionchange&lt;/code&gt; &lt;/a&gt; 이벤트가 전달됩니다. &lt;code&gt;updateDetails()&lt;/code&gt; 호출 할 때마다 약속을 사용하고 다른 하나는 일반 JS 객체를 사용합니다. 이는 지불 시트에 대한 동기 및 비동기 업데이트를 강등시킵니다.</target>
        </trans-unit>
        <trans-unit id="106802246ff2cba3885c494ae2d379522d6bdd57" translate="yes" xml:space="preserve">
          <source>In the example below, the &lt;code&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/target&quot;&gt;target&lt;/a&gt;&lt;/code&gt; attribute of the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/SVG/Element/a&quot;&gt;&lt;code&gt;&amp;lt;a&amp;gt;&lt;/code&gt;&lt;/a&gt; element is set to &lt;code&gt;_blank&lt;/code&gt; and when the link is clicked, it logs to notify whether the condition is met or not.</source>
          <target state="translated">아래 예 에서 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/SVG/Element/a&quot;&gt; &lt;code&gt;&amp;lt;a&amp;gt;&lt;/code&gt; &lt;/a&gt; 요소 의 &lt;code&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/target&quot;&gt;target&lt;/a&gt;&lt;/code&gt; 속성은 &lt;code&gt;_blank&lt;/code&gt; 로 설정되고 링크를 클릭하면 조건이 충족되는지 여부를 알리기 위해 로깅됩니다.</target>
        </trans-unit>
        <trans-unit id="c6e4566e82bb56ea28b1e39a446bd27f432d4250" translate="yes" xml:space="preserve">
          <source>In the example below, the cost of shipping varies by geography. When the &lt;a href=&quot;../paymentrequest/onshippingaddresschange&quot;&gt;&lt;code&gt;PaymentRequest.onshippingaddresschange&lt;/code&gt;&lt;/a&gt; is called, &lt;code&gt;updateDetails()&lt;/code&gt; is called to update the details of the &lt;code&gt;PaymentRequest&lt;/code&gt;, using &lt;code&gt;shippingAddress&lt;/code&gt; to set the correct shipping cost.</source>
          <target state="translated">아래 예에서 운송 비용은 지역에 따라 다릅니다. 때 &lt;a href=&quot;../paymentrequest/onshippingaddresschange&quot;&gt; &lt;code&gt;PaymentRequest.onshippingaddresschange&lt;/code&gt; 이&lt;/a&gt; 라고, &lt;code&gt;updateDetails()&lt;/code&gt; 의 세부 사항 업데이트하기 위해 호출된다 &lt;code&gt;PaymentRequest&lt;/code&gt; 을 사용하여, &lt;code&gt;shippingAddress&lt;/code&gt; 을 올바른 운송 비용을 설정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="49f2eefcbea9337ae5b9fac581b8e7748a4c155f" translate="yes" xml:space="preserve">
          <source>In the example below, the cost of shipping varies by geography. When the &lt;a href=&quot;onshippingaddresschange&quot;&gt;&lt;code&gt;PaymentRequest.onshippingaddresschange&lt;/code&gt;&lt;/a&gt; is called, &lt;code&gt;updateDetails()&lt;/code&gt; is called to update the details of the &lt;code&gt;PaymentRequest&lt;/code&gt;, using &lt;code&gt;shippingAddress&lt;/code&gt; to set the correct shipping cost.</source>
          <target state="translated">아래 예에서 운송 비용은 지역에 따라 다릅니다. 때 &lt;a href=&quot;onshippingaddresschange&quot;&gt; &lt;code&gt;PaymentRequest.onshippingaddresschange&lt;/code&gt; 이&lt;/a&gt; 라고, &lt;code&gt;updateDetails()&lt;/code&gt; 의 세부 사항 업데이트하기 위해 호출된다 &lt;code&gt;PaymentRequest&lt;/code&gt; 을 사용하여, &lt;code&gt;shippingAddress&lt;/code&gt; 을 올바른 운송 비용을 설정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f834c92189fcef8cd83b56bd0f3787c0ffac414c" translate="yes" xml:space="preserve">
          <source>In the example below, we create a node with mixed display and whitespace characters and the attribute is &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">아래 예에서는 표시 문자와 공백 문자가 혼합 된 노드를 만들고 속성이 &lt;code&gt;false&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="f50f8120d66119424065d02349efc2de9a03cfe6" translate="yes" xml:space="preserve">
          <source>In the example below, we see the implementation of a handler for the &lt;code&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Events/negotiationneeded&quot;&gt;negotiationneeded&lt;/a&gt;&lt;/code&gt; event.</source>
          <target state="translated">아래 예에서는 &lt;code&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Events/negotiationneeded&quot;&gt;negotiationneeded&lt;/a&gt;&lt;/code&gt; 이벤트 에 대한 처리기 구현을 보여 줍니다.</target>
        </trans-unit>
        <trans-unit id="dbc943052673e05ede088a6d5deb6f01db9d4689" translate="yes" xml:space="preserve">
          <source>In the example here, once we have retrieved the data, we insert the string as the textual content of the target. This has the effect of inserting the dragged text where it was dropped, assuming that the drop target is an area of text such as a &lt;code&gt;p&lt;/code&gt; or &lt;code&gt;div&lt;/code&gt; element.</source>
          <target state="translated">여기의 예에서, 데이터를 검색 한 후에는 문자열을 대상의 텍스트 내용으로 삽입합니다. 놓기 대상이 &lt;code&gt;p&lt;/code&gt; 또는 &lt;code&gt;div&lt;/code&gt; 요소 와 같은 텍스트 영역 인 경우 끌어 놓은 텍스트를 놓은 위치에 삽입하는 효과가 있습니다.</target>
        </trans-unit>
        <trans-unit id="aace07f97eb3431fa0c4367c7c8f5e95ae0370e2" translate="yes" xml:space="preserve">
          <source>In the examples above we are already making use of the &lt;code&gt;font&lt;/code&gt; property to make the text a bit larger than the default size. There are some more properties which let you adjust the way the text gets displayed on the canvas:</source>
          <target state="translated">위의 예제에서 &lt;code&gt;font&lt;/code&gt; 속성을 사용하여 텍스트를 기본 크기보다 약간 크게 만듭니다. 캔버스에 텍스트가 표시되는 방식을 조정할 수있는 속성이 몇 가지 더 있습니다.</target>
        </trans-unit>
        <trans-unit id="82a8b02b028ba58b7dfd42bdea7a01498ef4c3a6" translate="yes" xml:space="preserve">
          <source>In the examples below, we'll refer to the peer which is turning &quot;hold&quot; mode on and off as the local peer and the user being placed on hold as the remote peer.</source>
          <target state="translated">아래 예에서는 로컬 피어로 &quot;보류&quot;모드를 설정 및 해제하고 사용자를 원격 피어로 보류중인 피어를 참조합니다.</target>
        </trans-unit>
        <trans-unit id="f0ca896ae7b838120090476440aeaef9eca87c3f" translate="yes" xml:space="preserve">
          <source>In the examples below, we'll use the &lt;a href=&quot;../../window/requestanimationframe&quot;&gt;&lt;code&gt;window.requestAnimationFrame()&lt;/code&gt;&lt;/a&gt; method to control the animation. The &lt;code&gt;requestAnimationFrame&lt;/code&gt; method provides a smoother and more efficient way for animating by calling the animation frame when the system is ready to paint the frame. The number of callbacks is usually 60 times per second and may be reduced to a lower rate when running in background tabs. For more information about the animation loop, especially for games, see the article &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Games/Anatomy&quot;&gt;Anatomy of a video game&lt;/a&gt; in our &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Games&quot;&gt;Game development zone&lt;/a&gt;.</source>
          <target state="translated">아래 예제에서는 &lt;a href=&quot;../../window/requestanimationframe&quot;&gt; &lt;code&gt;window.requestAnimationFrame()&lt;/code&gt; &lt;/a&gt; 메서드를 사용하여 애니메이션을 제어합니다. &lt;code&gt;requestAnimationFrame&lt;/code&gt; 의 방법은 시스템이 프레임을 페인트 할 준비가되면 애니메이션 프레임을 호출하여 애니메이션을위한 부드럽고 더 효율적인 방법을 제공합니다. 콜백 수는 일반적으로 초당 60 회이며 백그라운드 탭에서 실행될 때 더 낮은 비율로 줄어들 수 있습니다. 특히 게임 애니메이션 루프에 대한 자세한 내용은 문서를 참조 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Games/Anatomy&quot;&gt;비디오 게임의 해부학을&lt;/a&gt; 우리의 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Games&quot;&gt;게임 개발 영역&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="5ead6a925f82797217bc4febda9e2848c9ca16de" translate="yes" xml:space="preserve">
          <source>In the final example of this chapter, we'll build a little art gallery. The gallery consists of a table containing several images. When the page is loaded, a &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/canvas&quot;&gt;&lt;code&gt;&amp;lt;canvas&amp;gt;&lt;/code&gt;&lt;/a&gt; element is inserted for each image and a frame is drawn around it.</source>
          <target state="translated">이 장의 마지막 예에서는 작은 아트 갤러리를 만들겠습니다. 갤러리는 여러 이미지가 포함 된 테이블로 구성됩니다. 페이지가로드되면 각 이미지에 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/canvas&quot;&gt; &lt;code&gt;&amp;lt;canvas&amp;gt;&lt;/code&gt; &lt;/a&gt; 요소가 삽입되고 그 주위에 프레임이 그려집니다.</target>
        </trans-unit>
        <trans-unit id="00f8f41bb21484324aa74a2ec592c179f7309a51" translate="yes" xml:space="preserve">
          <source>In the final part of the handler, we include an &lt;a href=&quot;../speechsynthesisutterance/onpause&quot;&gt;&lt;code&gt;SpeechSynthesisUtterance.onpause&lt;/code&gt;&lt;/a&gt; handler to demonstrate how &lt;a href=&quot;../speechsynthesisevent&quot;&gt;&lt;code&gt;SpeechSynthesisEvent&lt;/code&gt;&lt;/a&gt; can be put to good use. When &lt;a href=&quot;../speechsynthesis/pause&quot;&gt;&lt;code&gt;SpeechSynthesis.pause()&lt;/code&gt;&lt;/a&gt; is invoked, this returns a message reporting the character number and name that the speech was paused at.</source>
          <target state="translated">핸들러의 마지막 부분에서 &lt;a href=&quot;../speechsynthesisutterance/onpause&quot;&gt; &lt;code&gt;SpeechSynthesisUtterance.onpause&lt;/code&gt; &lt;/a&gt; 핸들러를 포함시켜 SpeechSynthesisEvent 를 어떻게 잘 &lt;a href=&quot;../speechsynthesisevent&quot;&gt; &lt;code&gt;SpeechSynthesisEvent&lt;/code&gt; &lt;/a&gt; 수 있는지 보여줍니다 . 때 &lt;a href=&quot;../speechsynthesis/pause&quot;&gt; &lt;code&gt;SpeechSynthesis.pause()&lt;/code&gt; &lt;/a&gt; 를 호출,이 문자의 번호와 연설에서 일시 중지 된 것을 이름을보고 메시지를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="d72204efa77b6140c17c0cf9a91bf2d8f8666f30" translate="yes" xml:space="preserve">
          <source>In the first case above, a new (anonymous) handler function is created with each iteration of the loop. In the second case, the same previously declared function is used as an event handler, which results in smaller memory consumption because there is only one handler function created. Moreover, in the first case, it is not possible to call &lt;a href=&quot;removeeventlistener&quot;&gt;&lt;code&gt;removeEventListener()&lt;/code&gt;&lt;/a&gt; because no reference to the anonymous function is kept (or here, not kept to any of the multiple anonymous functions the loop might create.) In the second case, it's possible to do &lt;code&gt;myElement.removeEventListener(&quot;click&quot;, processEvent, false)&lt;/code&gt; because &lt;code&gt;processEvent&lt;/code&gt; is the function reference.</source>
          <target state="translated">위의 첫 번째 경우 루프의 각 반복마다 새로운 (익명) 핸들러 함수가 작성됩니다. 두 번째 경우, 이전에 선언 된 동일한 함수가 이벤트 핸들러로 사용되며, 하나의 핸들러 함수 만 작성되므로 메모리 소비가 줄어 듭니다. 또한 첫 번째 경우 익명 함수에 대한 참조가 유지되지 않기 때문에 &lt;a href=&quot;removeeventlistener&quot;&gt; &lt;code&gt;removeEventListener()&lt;/code&gt; &lt;/a&gt; 를 호출 할 수 없습니다 (또는 여기에서 루프가 생성 할 수있는 여러 익명 함수를 유지하지 않음). 두 번째 경우에는 &lt;code&gt;processEvent&lt;/code&gt; 는 함수 참조 이므로 &lt;code&gt;myElement.removeEventListener(&quot;click&quot;, processEvent, false)&lt;/code&gt; 를 수행 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="b6a06616d2d1a79d80ad40c424ea14279868eba9" translate="yes" xml:space="preserve">
          <source>In the first example, we have to wait for &lt;code&gt;myFunction()&lt;/code&gt; to run and return &lt;code&gt;value&lt;/code&gt; before any more of the code can execute. In the second example, &lt;code&gt;myFunction()&lt;/code&gt; returns a promise for &lt;code&gt;value&lt;/code&gt;, then the rest of the code can carry on running. When the promise resolves, the code inside &lt;code&gt;then&lt;/code&gt; will be run, asynchronously.</source>
          <target state="translated">첫 번째 예에서는 더 많은 코드를 실행하기 전에 &lt;code&gt;myFunction()&lt;/code&gt; 이 실행되고 &lt;code&gt;value&lt;/code&gt; 을 반환 할 때까지 기다려야합니다 . 두 번째 예에서 &lt;code&gt;myFunction()&lt;/code&gt; 은 &lt;code&gt;value&lt;/code&gt; 에 대한 promise를 반환 한 다음 나머지 코드는 계속 실행될 수 있습니다. 약속의 결의는, 코드 내부하면 &lt;code&gt;then&lt;/code&gt; 비동기 적으로 실행됩니다.</target>
        </trans-unit>
        <trans-unit id="237bf8a80763a604c41a957e192af6c016815343" translate="yes" xml:space="preserve">
          <source>In the first few lines of code, we draw a black rectangle the size of the canvas as a backdrop, then translate the origin to the center. Next, we create the circular clipping path by drawing an arc and calling &lt;code&gt;clip()&lt;/code&gt;. Clipping paths are also part of the canvas save state. If we wanted to keep the original clipping path we could have saved the canvas state before creating the new one.</source>
          <target state="translated">처음 몇 줄의 코드에서 캔버스 크기의 검은 사각형을 배경으로 그린 ​​다음 원점을 중심으로 변환합니다. 다음으로 호를 그리고 &lt;code&gt;clip()&lt;/code&gt; 호출하여 원형 클리핑 패스를 만듭니다 . 클리핑 경로는 캔버스 저장 상태의 일부이기도합니다. 원본 클리핑 경로를 유지하려면 새 캔버스 경로를 만들기 전에 캔버스 상태를 저장했을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e01d4fbb899e1c9bfb390594c1d8dfcfcc14fd99" translate="yes" xml:space="preserve">
          <source>In the following code block, you can see a &lt;code&gt;handleMessage&lt;/code&gt; handler function, run when a message is sent back to this document using &lt;a href=&quot;../eventtarget/addeventlistener&quot;&gt;&lt;code&gt;EventTarget.addEventListener&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">다음 코드 블록에서 &lt;code&gt;handleMessage&lt;/code&gt; 핸들러 함수를 볼 수 있으며 &lt;a href=&quot;../eventtarget/addeventlistener&quot;&gt; &lt;code&gt;EventTarget.addEventListener&lt;/code&gt; 를&lt;/a&gt; 사용하여 메시지가이 문서로 다시 전송 될 때 실행됩니다 .</target>
        </trans-unit>
        <trans-unit id="2d23ea443c6c17d8a7b8694e2f35584131bc5044" translate="yes" xml:space="preserve">
          <source>In the following code block, you can see a &lt;code&gt;handleMessage&lt;/code&gt; handler function, run when a message is sent back to this document using &lt;code&gt;onmessage&lt;/code&gt;:</source>
          <target state="translated">다음 코드 블록에서 &lt;code&gt;onmessage&lt;/code&gt; 를 사용하여 메시지를이 문서로 다시 보낼 때 &lt;code&gt;handleMessage&lt;/code&gt; 핸들러 함수를 볼 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="0ef7b50d4cd728b13b1faa603128d4d510d733a4" translate="yes" xml:space="preserve">
          <source>In the following code block, you can see a new channel being created using the &lt;a href=&quot;../messagechannel&quot;&gt;&lt;code&gt;MessageChannel.MessageChannel&lt;/code&gt;&lt;/a&gt; constructor. When the IFrame has loaded, we pass &lt;a href=&quot;../messagechannel/port2&quot;&gt;&lt;code&gt;MessageChannel.port2&lt;/code&gt;&lt;/a&gt; to the IFrame using &lt;a href=&quot;../window/postmessage&quot;&gt;&lt;code&gt;window.postMessage&lt;/code&gt;&lt;/a&gt; along with a message. The &lt;code&gt;handleMessage&lt;/code&gt; handler then responds to a message being sent back from the IFrame using &lt;code&gt;onmessage&lt;/code&gt;, putting it into a paragraph &amp;mdash; &lt;a href=&quot;../messagechannel/port1&quot;&gt;&lt;code&gt;MessageChannel.port1&lt;/code&gt;&lt;/a&gt; is listened to, to check when the message arrives.</source>
          <target state="translated">다음 코드 블록에서 &lt;a href=&quot;../messagechannel&quot;&gt; &lt;code&gt;MessageChannel.MessageChannel&lt;/code&gt; &lt;/a&gt; 생성자를 사용하여 새 채널이 생성되는 것을 볼 수 있습니다 . IFrame이로드되면 &lt;a href=&quot;../window/postmessage&quot;&gt; &lt;code&gt;window.postMessage&lt;/code&gt; &lt;/a&gt; 를 사용하여 &lt;a href=&quot;../messagechannel/port2&quot;&gt; &lt;code&gt;MessageChannel.port2&lt;/code&gt; &lt;/a&gt; 를 IFrame으로 전달 합니다. &lt;code&gt;handleMessage&lt;/code&gt; 의 핸들러는 메시지의 존재가 사용 IFrame을에서 다시 전송에 응답 &lt;code&gt;onmessage&lt;/code&gt; - 단락으로 퍼팅, &lt;a href=&quot;../messagechannel/port1&quot;&gt; &lt;code&gt;MessageChannel.port1&lt;/code&gt; 는&lt;/a&gt; 메시지가 도착하면 확인, 경청한다.</target>
        </trans-unit>
        <trans-unit id="e25cf09426d4c6a9936cbd7dd3d621e9ca1d71c2" translate="yes" xml:space="preserve">
          <source>In the following code block, you can see a new channel being created using the &lt;a href=&quot;../messagechannel&quot;&gt;&lt;code&gt;MessageChannel.MessageChannel&lt;/code&gt;&lt;/a&gt; constructor. When the IFrame has loaded, we pass &lt;a href=&quot;../messagechannel/port2&quot;&gt;&lt;code&gt;MessageChannel.port2&lt;/code&gt;&lt;/a&gt; to the IFrame using &lt;a href=&quot;postmessage&quot;&gt;&lt;code&gt;MessagePort.postMessage&lt;/code&gt;&lt;/a&gt; along with a message. The &lt;code&gt;handleMessage&lt;/code&gt; handler then responds to a message being sent back from the IFrame using &lt;code&gt;onmessage&lt;/code&gt;, putting it into a paragraph &amp;mdash; &lt;a href=&quot;../messagechannel/port1&quot;&gt;&lt;code&gt;MessageChannel.port1&lt;/code&gt;&lt;/a&gt; is listened to, to check when the message arrives.</source>
          <target state="translated">다음 코드 블록에서 &lt;a href=&quot;../messagechannel&quot;&gt; &lt;code&gt;MessageChannel.MessageChannel&lt;/code&gt; &lt;/a&gt; 생성자를 사용하여 새 채널이 생성되는 것을 볼 수 있습니다 . IFrame이로드되면 &lt;a href=&quot;postmessage&quot;&gt; &lt;code&gt;MessagePort.postMessage&lt;/code&gt; &lt;/a&gt; 를 메시지 와 함께 사용하여 &lt;a href=&quot;../messagechannel/port2&quot;&gt; &lt;code&gt;MessageChannel.port2&lt;/code&gt; &lt;/a&gt; 를 IFrame으로 전달 합니다. &lt;code&gt;handleMessage&lt;/code&gt; 의 핸들러는 메시지의 존재가 사용 IFrame을에서 다시 전송에 응답 &lt;code&gt;onmessage&lt;/code&gt; - 단락으로 퍼팅, &lt;a href=&quot;../messagechannel/port1&quot;&gt; &lt;code&gt;MessageChannel.port1&lt;/code&gt; 는&lt;/a&gt; 메시지가 도착하면 확인, 경청한다.</target>
        </trans-unit>
        <trans-unit id="238f0592be750da1ce24eabeb82568b629e83a6c" translate="yes" xml:space="preserve">
          <source>In the following code block, you can see a new channel being created using the &lt;a href=&quot;../messagechannel&quot;&gt;&lt;code&gt;MessageChannel.MessageChannel&lt;/code&gt;&lt;/a&gt; constructor. When the IFrame has loaded, we pass &lt;code&gt;port2&lt;/code&gt; to the IFrame using &lt;a href=&quot;../messageport/postmessage&quot;&gt;&lt;code&gt;MessagePort.postMessage&lt;/code&gt;&lt;/a&gt; along with a message. The &lt;code&gt;handleMessage&lt;/code&gt; handler then responds to a message being sent back from the IFrame (using &lt;a href=&quot;../messageport/onmessage&quot;&gt;&lt;code&gt;MessagePort.onmessage&lt;/code&gt;&lt;/a&gt;), putting it into a paragraph. &lt;a href=&quot;port1&quot;&gt;&lt;code&gt;MessageChannel.port1&lt;/code&gt;&lt;/a&gt; is listened to, to check when the message arrives.</source>
          <target state="translated">다음 코드 블록에서 &lt;a href=&quot;../messagechannel&quot;&gt; &lt;code&gt;MessageChannel.MessageChannel&lt;/code&gt; &lt;/a&gt; 생성자를 사용하여 새 채널이 생성되는 것을 볼 수 있습니다 . IFrame이로드되면 &lt;a href=&quot;../messageport/postmessage&quot;&gt; &lt;code&gt;MessagePort.postMessage&lt;/code&gt; &lt;/a&gt; 를 사용하여 메시지 와 함께 &lt;code&gt;port2&lt;/code&gt; 를 IFrame으로 전달 합니다. &lt;code&gt;handleMessage&lt;/code&gt; 의 메시지가 다시 IFrame을 (사용에서 전송되는에 핸들러는 응답 &lt;a href=&quot;../messageport/onmessage&quot;&gt; &lt;code&gt;MessagePort.onmessage&lt;/code&gt; &lt;/a&gt; ) 단락에 퍼팅. 메시지가 도착한 시점을 확인하기 위해 &lt;a href=&quot;port1&quot;&gt; &lt;code&gt;MessageChannel.port1&lt;/code&gt; &lt;/a&gt; 을 청취합니다.</target>
        </trans-unit>
        <trans-unit id="8c569cdb98e9ad9e8e436cf060158927e2b6214b" translate="yes" xml:space="preserve">
          <source>In the following code block, you can see a new channel being created using the &lt;a href=&quot;messagechannel&quot;&gt;&lt;code&gt;MessageChannel()&lt;/code&gt;&lt;/a&gt; constructor. When the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/iframe&quot;&gt;&lt;code&gt;&amp;lt;iframe&amp;gt;&lt;/code&gt;&lt;/a&gt; has loaded, we pass &lt;a href=&quot;port2&quot;&gt;&lt;code&gt;MessageChannel.port2&lt;/code&gt;&lt;/a&gt; to the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/iframe&quot;&gt;&lt;code&gt;&amp;lt;iframe&amp;gt;&lt;/code&gt;&lt;/a&gt; using &lt;a href=&quot;../messageport/postmessage&quot;&gt;&lt;code&gt;MessagePort.postMessage&lt;/code&gt;&lt;/a&gt; along with a message. The &lt;code&gt;handleMessage&lt;/code&gt; handler then responds to a message being sent back from the &lt;code&gt;&amp;lt;iframe&amp;gt;&lt;/code&gt; (using &lt;a href=&quot;../messageport/onmessage&quot;&gt;&lt;code&gt;MessagePort.onmessage&lt;/code&gt;&lt;/a&gt;), putting it into a paragraph. The &lt;code&gt;handleMessage&lt;/code&gt; method is associated to the &lt;code&gt;port1&lt;/code&gt; to listen when the message arrives.</source>
          <target state="translated">다음 코드 블록에서 &lt;a href=&quot;messagechannel&quot;&gt; &lt;code&gt;MessageChannel()&lt;/code&gt; &lt;/a&gt; 생성자를 사용하여 새 채널이 생성되는 것을 볼 수 있습니다 . 언제 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/iframe&quot;&gt; &lt;code&gt;&amp;lt;iframe&amp;gt;&lt;/code&gt; 해당&lt;/a&gt; 로드, 우리는 합격 &lt;a href=&quot;port2&quot;&gt; &lt;code&gt;MessageChannel.port2&lt;/code&gt; 을&lt;/a&gt; 받는 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/iframe&quot;&gt; &lt;code&gt;&amp;lt;iframe&amp;gt;&lt;/code&gt; 해당&lt;/a&gt; 사용 &lt;a href=&quot;../messageport/postmessage&quot;&gt; &lt;code&gt;MessagePort.postMessage&lt;/code&gt; &lt;/a&gt; 메시지와 함께. &lt;code&gt;handleMessage&lt;/code&gt; 의 메시지가 다시 전송되기로부터 핸들러 응답은 &lt;code&gt;&amp;lt;iframe&amp;gt;&lt;/code&gt; 해당 (사용 &lt;a href=&quot;../messageport/onmessage&quot;&gt; &lt;code&gt;MessagePort.onmessage&lt;/code&gt; &lt;/a&gt; ) 단락에 넣는. &lt;code&gt;handleMessage&lt;/code&gt; 의 방법은 연관되는 &lt;code&gt;port1&lt;/code&gt; 메시지가 도착할 때 듣고.</target>
        </trans-unit>
        <trans-unit id="039a0c183e5267a50a7d7965f3b3a21f6386cb9c" translate="yes" xml:space="preserve">
          <source>In the following code snippet, we make a request to open a database, and include handlers for the success and error cases. For a full working example, see our &lt;a href=&quot;https://github.com/mdn/to-do-notifications/tree/gh-pages&quot;&gt;To-do Notifications&lt;/a&gt; app (&lt;a href=&quot;http://mdn.github.io/to-do-notifications/&quot;&gt;view example live&lt;/a&gt;.)</source>
          <target state="translated">다음 코드 스 니펫에서는 데이터베이스 열기를 요청하고 성공 및 오류 사례에 대한 핸들러를 포함합니다. 전체 예제를 보려면 &lt;a href=&quot;https://github.com/mdn/to-do-notifications/tree/gh-pages&quot;&gt;To-do Notifications&lt;/a&gt; 앱 을 참조하십시오 ( &lt;a href=&quot;http://mdn.github.io/to-do-notifications/&quot;&gt;실례보기&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="c8cbca89f7feedc8066d85994128a264e3657052" translate="yes" xml:space="preserve">
          <source>In the following code snippet, we make a request to open a database, and include handlers for the success and error cases. These events are fired via the custom &lt;code&gt;IDBVersionChangeEvent&lt;/code&gt; interface. For a full working example, see our &lt;a href=&quot;https://github.com/mdn/to-do-notifications/tree/gh-pages&quot;&gt;To-do Notifications&lt;/a&gt; app (&lt;a href=&quot;http://mdn.github.io/to-do-notifications/&quot;&gt;view example live&lt;/a&gt;.)</source>
          <target state="translated">다음 코드 스 니펫에서는 데이터베이스 열기를 요청하고 성공 및 오류 사례에 대한 핸들러를 포함합니다. 이러한 이벤트는 사용자 정의 &lt;code&gt;IDBVersionChangeEvent&lt;/code&gt; 인터페이스 를 통해 시작 됩니다. 전체 예제를 보려면 &lt;a href=&quot;https://github.com/mdn/to-do-notifications/tree/gh-pages&quot;&gt;To-do Notifications&lt;/a&gt; 앱 을 참조하십시오 ( &lt;a href=&quot;http://mdn.github.io/to-do-notifications/&quot;&gt;실례보기&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="420b628a66fb512c01a6129bb5bc84419417fe9e" translate="yes" xml:space="preserve">
          <source>In the following code snippet, we make a request to open a database, and include handlers for the success and error cases. Upon a version change (after an &lt;code&gt;upgradedneeded&lt;/code&gt; event), the &lt;code&gt;success&lt;/code&gt; event will implement the &lt;code&gt;IDBVersionChangeEvent&lt;/code&gt; interface. For a full working example, see our &lt;a href=&quot;https://github.com/mdn/to-do-notifications/tree/gh-pages&quot;&gt;To-do Notifications&lt;/a&gt; app (&lt;a href=&quot;http://mdn.github.io/to-do-notifications/&quot;&gt;view example live&lt;/a&gt;.)</source>
          <target state="translated">다음 코드 스 니펫에서는 데이터베이스 열기를 요청하고 성공 및 오류 사례에 대한 핸들러를 포함합니다. &lt;code&gt;upgradedneeded&lt;/code&gt; 이벤트 이후 버전이 변경되면 &lt;code&gt;success&lt;/code&gt; 이벤트는 &lt;code&gt;IDBVersionChangeEvent&lt;/code&gt; 인터페이스를 구현합니다 . 전체 예제를 보려면 &lt;a href=&quot;https://github.com/mdn/to-do-notifications/tree/gh-pages&quot;&gt;To-do Notifications&lt;/a&gt; 앱 을 참조하십시오 ( &lt;a href=&quot;http://mdn.github.io/to-do-notifications/&quot;&gt;실례보기&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="62bc6fcc2be4b4f1f6f5c4e9f84a194400ac424f" translate="yes" xml:space="preserve">
          <source>In the following code snippet, we open a database asynchronously (&lt;a href=&quot;idbfactory&quot;&gt;&lt;code&gt;IDBFactory&lt;/code&gt;&lt;/a&gt;), handle success and error cases, and create a new object store in the case that an upgrade is needed (&lt;a href=&quot;idbdatabase&quot;&gt;&lt;code&gt;IDBdatabase&lt;/code&gt;&lt;/a&gt;). For a complete working example, see our &lt;a href=&quot;https://github.com/mdn/to-do-notifications/&quot;&gt;To-do Notifications&lt;/a&gt; app (&lt;a href=&quot;http://mdn.github.io/to-do-notifications/&quot;&gt;view example live&lt;/a&gt;.)</source>
          <target state="translated">다음 코드 스 니펫에서는 데이터베이스를 비동기식으로 열고 ( &lt;a href=&quot;idbfactory&quot;&gt; &lt;code&gt;IDBFactory&lt;/code&gt; &lt;/a&gt; ) 성공 및 오류 사례를 처리하고 업그레이드가 필요한 경우 ( &lt;a href=&quot;idbdatabase&quot;&gt; &lt;code&gt;IDBdatabase&lt;/code&gt; &lt;/a&gt; ) 새 오브젝트 저장소를 작성합니다 . 완전한 실제 예제를 보려면 &lt;a href=&quot;https://github.com/mdn/to-do-notifications/&quot;&gt;To-do Notifications&lt;/a&gt; 앱 ( &lt;a href=&quot;http://mdn.github.io/to-do-notifications/&quot;&gt;예제보기 라이브&lt;/a&gt; )을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="5201c411fb9613fec411faeac1fccc27317c475e" translate="yes" xml:space="preserve">
          <source>In the following code snippet, we open a database asynchronously and make a request; &lt;code&gt;onerror&lt;/code&gt; and &lt;code&gt;onsuccess&lt;/code&gt; functions are included to handle the success and error cases. For a full working example, see our &lt;a href=&quot;https://github.com/chrisdavidmills/to-do-notifications/tree/gh-pages&quot;&gt;To-do Notifications&lt;/a&gt; app (&lt;a href=&quot;http://chrisdavidmills.github.io/to-do-notifications/&quot;&gt;view example live&lt;/a&gt;.)</source>
          <target state="translated">다음 코드 스 니펫에서 데이터베이스를 비동기 적으로 열고 요청합니다. 성공 및 오류 사례를 처리하기 위해 &lt;code&gt;onerror&lt;/code&gt; 및 &lt;code&gt;onsuccess&lt;/code&gt; 기능이 포함됩니다. 전체 예제를 보려면 &lt;a href=&quot;https://github.com/chrisdavidmills/to-do-notifications/tree/gh-pages&quot;&gt;To-do Notifications&lt;/a&gt; 앱 을 참조하십시오 ( &lt;a href=&quot;http://chrisdavidmills.github.io/to-do-notifications/&quot;&gt;실례보기&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="6036a2ba927c9abc293afb9b69926b7f16b41102" translate="yes" xml:space="preserve">
          <source>In the following code snippet, we open a read/write transaction on our database and add some data to an object store using &lt;code&gt;add()&lt;/code&gt;. After the object store has been created, we log objectStore.autoIncrement to the console. For a full working example, see our &lt;a href=&quot;https://github.com/mdn/to-do-notifications/&quot;&gt;To-do Notifications&lt;/a&gt; app (&lt;a href=&quot;http://mdn.github.io/to-do-notifications/&quot;&gt;view example live&lt;/a&gt;.)</source>
          <target state="translated">다음 코드 스 니펫에서는 데이터베이스에서 읽기 / 쓰기 트랜잭션을 열고 &lt;code&gt;add()&lt;/code&gt; 사용하여 일부 데이터를 오브젝트 저장소에 추가 합니다. 객체 저장소가 생성되면 objectStore.autoIncrement를 콘솔에 기록합니다. 전체 예제를 보려면 &lt;a href=&quot;https://github.com/mdn/to-do-notifications/&quot;&gt;To-do Notifications&lt;/a&gt; 앱 을 참조하십시오 ( &lt;a href=&quot;http://mdn.github.io/to-do-notifications/&quot;&gt;실례보기&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="dccc72e4a6a99203b539f07581c3ddeb17ef1de9" translate="yes" xml:space="preserve">
          <source>In the following code snippet, we open a read/write transaction on our database and add some data to an object store using &lt;code&gt;add()&lt;/code&gt;. After the object store has been created, we log objectStore.indexNames to the console. For a full working example, see our &lt;a href=&quot;https://github.com/mdn/to-do-notifications/&quot;&gt;To-do Notifications&lt;/a&gt; app (&lt;a href=&quot;http://mdn.github.io/to-do-notifications/&quot;&gt;view example live&lt;/a&gt;.)</source>
          <target state="translated">다음 코드 스 니펫에서는 데이터베이스에서 읽기 / 쓰기 트랜잭션을 열고 &lt;code&gt;add()&lt;/code&gt; 사용하여 일부 데이터를 오브젝트 저장소에 추가 합니다. 객체 저장소가 생성되면 objectStore.indexNames를 콘솔에 기록합니다. 전체 예제를 보려면 &lt;a href=&quot;https://github.com/mdn/to-do-notifications/&quot;&gt;To-do Notifications&lt;/a&gt; 앱 을 참조하십시오 ( &lt;a href=&quot;http://mdn.github.io/to-do-notifications/&quot;&gt;실례보기&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="e91d5f62da27efa68634f15d76c6ace1df3b040d" translate="yes" xml:space="preserve">
          <source>In the following code snippet, we open a read/write transaction on our database and add some data to an object store using &lt;code&gt;add()&lt;/code&gt;. After the object store has been created, we log objectStore.keyPath to the console. For a full working example, see our &lt;a href=&quot;https://github.com/mdn/to-do-notifications/&quot;&gt;To-do Notifications&lt;/a&gt; app (&lt;a href=&quot;http://mdn.github.io/to-do-notifications/&quot;&gt;view example live&lt;/a&gt;.)</source>
          <target state="translated">다음 코드 스 니펫에서는 데이터베이스에서 읽기 / 쓰기 트랜잭션을 열고 &lt;code&gt;add()&lt;/code&gt; 사용하여 일부 데이터를 오브젝트 저장소에 추가 합니다. 객체 저장소가 생성되면 objectStore.keyPath를 콘솔에 기록합니다. 전체 예제를 보려면 &lt;a href=&quot;https://github.com/mdn/to-do-notifications/&quot;&gt;To-do Notifications&lt;/a&gt; 앱 을 참조하십시오 ( &lt;a href=&quot;http://mdn.github.io/to-do-notifications/&quot;&gt;실례보기&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="8880b8fdee4d42f903cebcfe0d82afd6cc260c9b" translate="yes" xml:space="preserve">
          <source>In the following code snippet, we open a read/write transaction on our database and add some data to an object store using &lt;code&gt;add()&lt;/code&gt;. After the object store has been created, we log objectStore.name to the console. For a full working example, see our &lt;a href=&quot;https://github.com/mdn/to-do-notifications/&quot;&gt;To-do Notifications&lt;/a&gt; app (&lt;a href=&quot;http://mdn.github.io/to-do-notifications/&quot;&gt;view example live&lt;/a&gt;.)</source>
          <target state="translated">다음 코드 스 니펫에서는 데이터베이스에서 읽기 / 쓰기 트랜잭션을 열고 &lt;code&gt;add()&lt;/code&gt; 사용하여 일부 데이터를 오브젝트 저장소에 추가 합니다. 객체 저장소가 생성되면 objectStore.name을 콘솔에 기록합니다. 전체 예제를 보려면 &lt;a href=&quot;https://github.com/mdn/to-do-notifications/&quot;&gt;To-do Notifications&lt;/a&gt; 앱 을 참조하십시오 ( &lt;a href=&quot;http://mdn.github.io/to-do-notifications/&quot;&gt;실례보기&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="947b2b78865f74f8222655dfed99286833cbbf25" translate="yes" xml:space="preserve">
          <source>In the following code snippet, we open a read/write transaction on our database and add some data to an object store using &lt;code&gt;add()&lt;/code&gt;. After the object store has been created, we log objectStore.transaction to the console. For a full working example, see our &lt;a href=&quot;https://github.com/mdn/to-do-notifications/&quot;&gt;To-do Notifications&lt;/a&gt; app (&lt;a href=&quot;http://mdn.github.io/to-do-notifications/&quot;&gt;view example live&lt;/a&gt;.)</source>
          <target state="translated">다음 코드 스 니펫에서는 데이터베이스에서 읽기 / 쓰기 트랜잭션을 열고 &lt;code&gt;add()&lt;/code&gt; 사용하여 일부 데이터를 오브젝트 저장소에 추가 합니다. 객체 저장소가 생성되면 objectStore.transaction을 콘솔에 기록합니다. 전체 예제를 보려면 &lt;a href=&quot;https://github.com/mdn/to-do-notifications/&quot;&gt;To-do Notifications&lt;/a&gt; 앱 을 참조하십시오 ( &lt;a href=&quot;http://mdn.github.io/to-do-notifications/&quot;&gt;실례보기&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="aa9becddc2bb7ec90c0a3e3c9ece22246fe9674c" translate="yes" xml:space="preserve">
          <source>In the following code snippet, we open a read/write transaction on our database and add some data to an object store using &lt;code&gt;add()&lt;/code&gt;. Note also the functions attached to transaction event handlers to report on the outcome of the transaction opening in the event of success or failure. For a full working example, see our &lt;a href=&quot;https://github.com/mdn/to-do-notifications/&quot;&gt;To-do Notifications&lt;/a&gt; app (&lt;a href=&quot;http://mdn.github.io/to-do-notifications/&quot;&gt;view example live&lt;/a&gt;.)</source>
          <target state="translated">다음 코드 스 니펫에서는 데이터베이스에서 읽기 / 쓰기 트랜잭션을 열고 &lt;code&gt;add()&lt;/code&gt; 사용하여 일부 데이터를 오브젝트 저장소에 추가 합니다. 트랜잭션 이벤트 핸들러에 첨부 된 함수도 성공 또는 실패시 트랜잭션 열기 결과를보고합니다. 전체 예제를 보려면 &lt;a href=&quot;https://github.com/mdn/to-do-notifications/&quot;&gt;To-do Notifications&lt;/a&gt; 앱 을 참조하십시오 ( &lt;a href=&quot;http://mdn.github.io/to-do-notifications/&quot;&gt;실례보기&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="ad57a299009527ac8f2dd1dbd0ecdab42e093614" translate="yes" xml:space="preserve">
          <source>In the following code snippet, we open a read/write transaction on our database and add some data to an object store. Note also the functions attached to transaction event handlers to report on the outcome of the transaction opening in the event of success or failure. At the end, we return the associated database connection using &lt;code&gt;db&lt;/code&gt;. For a full working example, see our &lt;a href=&quot;https://github.com/mdn/to-do-notifications/&quot;&gt;To-do Notifications&lt;/a&gt; app (&lt;a href=&quot;http://mdn.github.io/to-do-notifications/&quot;&gt;view example live&lt;/a&gt;.)</source>
          <target state="translated">다음 코드 스 니펫에서는 데이터베이스에서 읽기 / 쓰기 트랜잭션을 열고 일부 데이터를 오브젝트 저장소에 추가합니다. 트랜잭션 이벤트 핸들러에 첨부 된 함수를 참고하여 성공 또는 실패시 트랜잭션 열기 결과를보고하십시오. 마지막으로 &lt;code&gt;db&lt;/code&gt; 를 사용하여 관련 데이터베이스 연결을 반환합니다 . 전체 예제를 보려면 &lt;a href=&quot;https://github.com/mdn/to-do-notifications/&quot;&gt;To-do Notifications&lt;/a&gt; 앱 을 참조하십시오 ( &lt;a href=&quot;http://mdn.github.io/to-do-notifications/&quot;&gt;실례보기&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="75eb1d616f6d05a9fa0821f8947490f9ee9f24f8" translate="yes" xml:space="preserve">
          <source>In the following code snippet, we open a read/write transaction on our database and add some data to an object store. Note also the functions attached to transaction event handlers to report on the outcome of the transaction opening in the event of success or failure. At the end, we simply abort any activity done under the current transaction using &lt;code&gt;abort()&lt;/code&gt;. For a full working example, see our &lt;a href=&quot;https://github.com/mdn/to-do-notifications/&quot;&gt;To-do Notifications&lt;/a&gt; app (&lt;a href=&quot;http://mdn.github.io/to-do-notifications/&quot;&gt;view example live&lt;/a&gt;.)</source>
          <target state="translated">다음 코드 스 니펫에서는 데이터베이스에서 읽기 / 쓰기 트랜잭션을 열고 일부 데이터를 오브젝트 저장소에 추가합니다. 트랜잭션 이벤트 핸들러에 첨부 된 함수도 성공 또는 실패시 트랜잭션 열기 결과를보고합니다. 마지막으로, &lt;code&gt;abort()&lt;/code&gt; 사용하여 현재 트랜잭션에서 수행 된 모든 활동을 중단합니다 . 전체 예제를 보려면 &lt;a href=&quot;https://github.com/mdn/to-do-notifications/&quot;&gt;To-do Notifications&lt;/a&gt; 앱 을 참조하십시오 ( &lt;a href=&quot;http://mdn.github.io/to-do-notifications/&quot;&gt;실례보기&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="13f59a285e31ec4566d2471042003d4ea3a258b3" translate="yes" xml:space="preserve">
          <source>In the following code snippet, we open a read/write transaction on our database and add some data to an object store. Note also the functions attached to transaction event handlers to report on the outcome of the transaction opening in the event of success or failure. At the end, we simply log the mode of the current transaction using &lt;code&gt;mode&lt;/code&gt;. For a full working example, see our &lt;a href=&quot;https://github.com/mdn/to-do-notifications/&quot;&gt;To-do Notifications&lt;/a&gt; app (&lt;a href=&quot;http://mdn.github.io/to-do-notifications/&quot;&gt;view example live&lt;/a&gt;.)</source>
          <target state="translated">다음 코드 스 니펫에서는 데이터베이스에서 읽기 / 쓰기 트랜잭션을 열고 일부 데이터를 오브젝트 저장소에 추가합니다. 트랜잭션 이벤트 핸들러에 첨부 된 함수도 성공 또는 실패시 트랜잭션 열기 결과를보고합니다. 마지막으로 mode를 사용하여 현재 트랜잭션의 모드를 간단히 기록 &lt;code&gt;mode&lt;/code&gt; . 전체 예제를 보려면 &lt;a href=&quot;https://github.com/mdn/to-do-notifications/&quot;&gt;To-do Notifications&lt;/a&gt; 앱 을 참조하십시오 ( &lt;a href=&quot;http://mdn.github.io/to-do-notifications/&quot;&gt;실례보기&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="1f4e437b34ba4b47c7d721167ae38f8bc64c3026" translate="yes" xml:space="preserve">
          <source>In the following code snippet, we open a read/write transaction on our database and add some data to an object store. Note also the functions attached to transaction event handlers to report on the outcome of the transaction opening in the event of success or failure. For a full working example, see our &lt;a href=&quot;https://github.com/mdn/to-do-notifications/&quot;&gt;To-do Notifications&lt;/a&gt; app (&lt;a href=&quot;http://mdn.github.io/to-do-notifications/&quot;&gt;view example live&lt;/a&gt;.)</source>
          <target state="translated">다음 코드 스 니펫에서는 데이터베이스에서 읽기 / 쓰기 트랜잭션을 열고 일부 데이터를 오브젝트 저장소에 추가합니다. 트랜잭션 이벤트 핸들러에 첨부 된 함수도 성공 또는 실패시 트랜잭션 열기 결과를보고합니다. 전체 예제를 보려면 &lt;a href=&quot;https://github.com/mdn/to-do-notifications/&quot;&gt;To-do Notifications&lt;/a&gt; 앱 을 참조하십시오 ( &lt;a href=&quot;http://mdn.github.io/to-do-notifications/&quot;&gt;실례보기&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="e0396bfc53f463837f3f50ead91b4ccd0303058f" translate="yes" xml:space="preserve">
          <source>In the following code snippet, we open a read/write transaction on our database and add some data to an object store. Note also the functions attached to transaction event handlers to report on the outcome of the transaction opening in the event of success or failure. Note the &lt;code&gt;transaction.onabort = function(event) { };&lt;/code&gt; block, reporting when the transaction has been aborted. For a full working example, see our &lt;a href=&quot;https://github.com/mdn/to-do-notifications/&quot;&gt;To-do Notifications&lt;/a&gt; app (&lt;a href=&quot;http://mdn.github.io/to-do-notifications/&quot;&gt;view example live&lt;/a&gt;.)</source>
          <target state="translated">다음 코드 스 니펫에서는 데이터베이스에서 읽기 / 쓰기 트랜잭션을 열고 일부 데이터를 오브젝트 저장소에 추가합니다. 트랜잭션 이벤트 핸들러에 첨부 된 함수도 성공 또는 실패시 트랜잭션 열기 결과를보고합니다. 메모 &lt;code&gt;transaction.onabort = function(event) { };&lt;/code&gt; 트랜잭션이 중단 된 시점을보고합니다. 전체 예제를 보려면 &lt;a href=&quot;https://github.com/mdn/to-do-notifications/&quot;&gt;To-do Notifications&lt;/a&gt; 앱 을 참조하십시오 ( &lt;a href=&quot;http://mdn.github.io/to-do-notifications/&quot;&gt;실례보기&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="9291a990b541f5f63cec02e040f4b041c8298814" translate="yes" xml:space="preserve">
          <source>In the following code snippet, we open a read/write transaction on our database and add some data to an object store. Note also the functions attached to transaction event handlers to report on the outcome of the transaction opening in the event of success or failure. Note the &lt;code&gt;transaction.oncomplete = function(event) { };&lt;/code&gt; block, which reports back when the transaction was successful. For a full working example, see our &lt;a href=&quot;https://github.com/mdn/to-do-notifications/&quot;&gt;To-do Notifications&lt;/a&gt; app (&lt;a href=&quot;http://mdn.github.io/to-do-notifications/&quot;&gt;view example live&lt;/a&gt;.)</source>
          <target state="translated">다음 코드 스 니펫에서는 데이터베이스에서 읽기 / 쓰기 트랜잭션을 열고 일부 데이터를 오브젝트 저장소에 추가합니다. 트랜잭션 이벤트 핸들러에 첨부 된 함수도 성공 또는 실패시 트랜잭션 열기 결과를보고합니다. 메모 &lt;code&gt;transaction.oncomplete = function(event) { };&lt;/code&gt; 트랜잭션이 성공했을 때 다시보고하는 블록. 전체 예제를 보려면 &lt;a href=&quot;https://github.com/mdn/to-do-notifications/&quot;&gt;To-do Notifications&lt;/a&gt; 앱 을 참조하십시오 ( &lt;a href=&quot;http://mdn.github.io/to-do-notifications/&quot;&gt;실례보기&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="5d979572fd1f87f060179ec0c46d8d5416b88385" translate="yes" xml:space="preserve">
          <source>In the following code snippet, we open a read/write transaction on our database and add some data to an object store. Note also the functions attached to transaction event handlers to report on the outcome of the transaction opening in the event of success or failure. Note the &lt;code&gt;transaction.onerror = function(event) { };&lt;/code&gt; block, making use of &lt;code&gt;transaction.error&lt;/code&gt; to help in reporting what went wrong when the transaction was unsuccessful. For a full working example, see our &lt;a href=&quot;https://github.com/mdn/to-do-notifications/&quot;&gt;To-do Notifications&lt;/a&gt; app (&lt;a href=&quot;http://mdn.github.io/to-do-notifications/&quot;&gt;view example live&lt;/a&gt;.)</source>
          <target state="translated">다음 코드 스 니펫에서는 데이터베이스에서 읽기 / 쓰기 트랜잭션을 열고 일부 데이터를 오브젝트 저장소에 추가합니다. 트랜잭션 이벤트 핸들러에 첨부 된 함수도 성공 또는 실패시 트랜잭션 열기 결과를보고합니다. 메모 &lt;code&gt;transaction.onerror = function(event) { };&lt;/code&gt; 트랜잭션이 실패했을 때 무엇이 ​​잘못되었는지보고하는 데 도움이되도록 &lt;code&gt;transaction.error&lt;/code&gt; 를 사용하여 차단 합니다. 전체 예제를 보려면 &lt;a href=&quot;https://github.com/mdn/to-do-notifications/&quot;&gt;To-do Notifications&lt;/a&gt; 앱 을 참조하십시오 ( &lt;a href=&quot;http://mdn.github.io/to-do-notifications/&quot;&gt;실례보기&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="1cadd885e1bfec1eafbd9f9798e746af01ce2da6" translate="yes" xml:space="preserve">
          <source>In the following code snippet, we open a read/write transaction on our database and clear all the current data out of the object store using &lt;code&gt;clear()&lt;/code&gt;. For a full working example, see our &lt;a href=&quot;https://github.com/mdn/to-do-notifications/&quot;&gt;To-do Notifications&lt;/a&gt; app (&lt;a href=&quot;http://mdn.github.io/to-do-notifications/&quot;&gt;view example live&lt;/a&gt;.)</source>
          <target state="translated">다음 코드 스 니펫에서는 데이터베이스에서 읽기 / 쓰기 트랜잭션을 열고 &lt;code&gt;clear()&lt;/code&gt; 사용하여 오브젝트 저장소에서 모든 현재 데이터를 지 웁니다 . 전체 예제를 보려면 &lt;a href=&quot;https://github.com/mdn/to-do-notifications/&quot;&gt;To-do Notifications&lt;/a&gt; 앱 을 참조하십시오 ( &lt;a href=&quot;http://mdn.github.io/to-do-notifications/&quot;&gt;실례보기&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="a59db44b4f9b5e947b3716a6d848b8d1f98f87d3" translate="yes" xml:space="preserve">
          <source>In the following code snippet, we open a read/write transaction on our database and delete one specific record out of our object store using &lt;code&gt;delete()&lt;/code&gt; &amp;mdash; a sample record with the key &quot;Walk dog&quot;. For a full working example, see our &lt;a href=&quot;https://github.com/mdn/to-do-notifications/&quot;&gt;To-do Notifications&lt;/a&gt; app (&lt;a href=&quot;http://mdn.github.io/to-do-notifications/&quot;&gt;view example live&lt;/a&gt;.)</source>
          <target state="translated">다음 코드 스 니펫에서는 데이터베이스에서 읽기 / 쓰기 트랜잭션을 열고 &quot;Walk dog&quot;키가있는 샘플 레코드 인 &lt;code&gt;delete()&lt;/code&gt; 사용하여 오브젝트 저장소에서 하나의 특정 레코드를 삭제 합니다. 전체 예제를 보려면 &lt;a href=&quot;https://github.com/mdn/to-do-notifications/&quot;&gt;To-do Notifications&lt;/a&gt; 앱 을 참조하십시오 ( &lt;a href=&quot;http://mdn.github.io/to-do-notifications/&quot;&gt;실례보기&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="13f30641085b558285bc8c95bc595644bdab0929" translate="yes" xml:space="preserve">
          <source>In the following code snippet, we open a read/write transaction on our database and get one specific record from object store using &lt;code&gt;get()&lt;/code&gt; &amp;mdash; a sample record with the key &quot;Walk dog&quot;. Once this data object is retrieved, you could then update it using normal JavaScript, then put it back into the database using a &lt;a href=&quot;put&quot;&gt;&lt;code&gt;IDBObjectStore.put&lt;/code&gt;&lt;/a&gt; operation. For a full working example, see our &lt;a href=&quot;https://github.com/mdn/to-do-notifications/&quot;&gt;To-do Notifications&lt;/a&gt; app (&lt;a href=&quot;http://mdn.github.io/to-do-notifications/&quot;&gt;view example live&lt;/a&gt;.)</source>
          <target state="translated">다음 코드 스 니펫에서는 데이터베이스에서 읽기 / 쓰기 트랜잭션을 열고 &quot;Walk dog&quot;키가있는 샘플 레코드 인 &lt;code&gt;get()&lt;/code&gt; 사용하여 오브젝트 저장소에서 하나의 특정 레코드를 가져옵니다 . 이 데이터 오브젝트가 검색되면 일반 JavaScript를 사용하여 업데이트 한 다음 &lt;a href=&quot;put&quot;&gt; &lt;code&gt;IDBObjectStore.put&lt;/code&gt; &lt;/a&gt; 조작을 사용하여 데이터베이스에 다시 넣을 수 있습니다. 전체 예제를 보려면 &lt;a href=&quot;https://github.com/mdn/to-do-notifications/&quot;&gt;To-do Notifications&lt;/a&gt; 앱 을 참조하십시오 ( &lt;a href=&quot;http://mdn.github.io/to-do-notifications/&quot;&gt;실례보기&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="322feb9948540265079df18f99d48a9e2d37112d" translate="yes" xml:space="preserve">
          <source>In the following example (see &lt;a href=&quot;https://mdn.github.io/dom-examples/streams/png-transform-stream/&quot;&gt;Unpack chunks of a PNG&lt;/a&gt; for the full code running live, and &lt;a href=&quot;https://github.com/mdn/dom-examples/tree/master/streams/png-transform-stream&quot;&gt;png-transform-stream&lt;/a&gt; for the source code), an image is fetched and its body retrieved as a &lt;a href=&quot;../readablestream&quot;&gt;&lt;code&gt;ReadableStream&lt;/code&gt;&lt;/a&gt;. Next, we log the contents of the readable stream, use &lt;code&gt;pipeThrough()&lt;/code&gt; to send it to a new function that creates a gray-scaled version of the stream, then log the new stream's contents too.</source>
          <target state="translated">다음 예제에서 (실제로 실행되는 전체 코드에 대해서는 &lt;a href=&quot;https://mdn.github.io/dom-examples/streams/png-transform-stream/&quot;&gt;PNG 청크 압축 해제&lt;/a&gt; 및 소스 코드에 대해서는 &lt;a href=&quot;https://github.com/mdn/dom-examples/tree/master/streams/png-transform-stream&quot;&gt;png 변환 스트림 &lt;/a&gt;압축 참조 ) 이미지를 가져오고 본문을 &lt;a href=&quot;../readablestream&quot;&gt; &lt;code&gt;ReadableStream&lt;/code&gt; 으로&lt;/a&gt; 검색합니다 . 다음으로, 읽을 수있는 스트림의 내용을 기록하고 &lt;code&gt;pipeThrough()&lt;/code&gt; 를 사용 하여 그레이 스케일 버전의 스트림을 생성하는 새 함수로 전송 한 다음 새 스트림의 내용도 기록합니다.</target>
        </trans-unit>
        <trans-unit id="287bf3de9023d80525000b897ab3a6b79e79ad05" translate="yes" xml:space="preserve">
          <source>In the following example we are using a biquad filter on a media stream (for the full demo, see our &lt;a href=&quot;http://mdn.github.io/stream-source-buffer/&quot;&gt;stream-source-buffer demo&lt;/a&gt; live, or &lt;a href=&quot;https://github.com/mdn/stream-source-buffer/blob/gh-pages/index.html&quot;&gt;read the source&lt;/a&gt;.) As part of this demo, we get the frequency responses for this biquad filter, for five sample frequencies. We first create the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Float32Array&quot;&gt;&lt;code&gt;Float32Array&lt;/code&gt;&lt;/a&gt;s we need, one containing the input frequencies, and two to receive the output magnitude and phase values:</source>
          <target state="translated">다음 예에서는 미디어 스트림에 바이 쿼드 필터를 사용하고 있습니다 (전체 데모는 &lt;a href=&quot;http://mdn.github.io/stream-source-buffer/&quot;&gt;스트림 소스 버퍼 데모를&lt;/a&gt; 참조 하거나 &lt;a href=&quot;https://github.com/mdn/stream-source-buffer/blob/gh-pages/index.html&quot;&gt;소스를 읽으십시오&lt;/a&gt; .)이 데모의 일부로이 쿼드에 대한 주파수 응답을 얻습니다. 5 개의 샘플 주파수에 대한 필터. 먼저 필요한 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Float32Array&quot;&gt; &lt;code&gt;Float32Array&lt;/code&gt; 를&lt;/a&gt; 생성합니다 . 하나는 입력 주파수를 포함하고 하나는 출력 크기와 위상 값을 수신합니다.</target>
        </trans-unit>
        <trans-unit id="13dcb52783e92bbdc8c8fdc2ccc00529dab0bb8c" translate="yes" xml:space="preserve">
          <source>In the following example we are using an IIR filter on a media stream (for a complete full demo, see our &lt;a href=&quot;http://mdn.github.io/stream-source-buffer/&quot;&gt;stream-source-buffer demo&lt;/a&gt; live, or &lt;a href=&quot;https://github.com/mdn/stream-source-buffer/blob/gh-pages/index.html&quot;&gt;read its source&lt;/a&gt;.) As part of this demo, we get the frequency responses for this IIR filter, for five sample frequencies. We first create the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Float32Array&quot;&gt;&lt;code&gt;Float32Array&lt;/code&gt;&lt;/a&gt; objects we need, one containing the input frequencies, and two to receive the output magnitude and phase values:</source>
          <target state="translated">다음 예제에서는 미디어 스트림에서 IIR 필터를 사용합니다 (완전한 전체 데모를 보려면 &lt;a href=&quot;http://mdn.github.io/stream-source-buffer/&quot;&gt;stream-source-buffer 데모&lt;/a&gt; 를 보거나 &lt;a href=&quot;https://github.com/mdn/stream-source-buffer/blob/gh-pages/index.html&quot;&gt;소스를 읽으십시오&lt;/a&gt; ).이 데모의 일부로 이에 대한 주파수 응답을 얻습니다. 5 개의 샘플 주파수에 대한 IIR 필터. 먼저 필요한 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Float32Array&quot;&gt; &lt;code&gt;Float32Array&lt;/code&gt; &lt;/a&gt; 객체를 생성합니다 . 하나는 입력 주파수를 포함하고 다른 하나는 출력 크기와 위상 값을 수신합니다.</target>
        </trans-unit>
        <trans-unit id="8816669e8174eda20010d216bd1c027736021aeb" translate="yes" xml:space="preserve">
          <source>In the following example we create a two second buffer, fill it with white noise, and then play it via an &lt;a href=&quot;../audiobuffersourcenode&quot;&gt;&lt;code&gt;AudioBufferSourceNode&lt;/code&gt;&lt;/a&gt;. The comments should clearly explain what is going on. You can also &lt;a href=&quot;https://mdn.github.io/webaudio-examples/audio-buffer/&quot;&gt;run the code live&lt;/a&gt;, or &lt;a href=&quot;https://github.com/mdn/webaudio-examples&quot;&gt;view the source&lt;/a&gt;.</source>
          <target state="translated">다음 예제에서는 2 초 버퍼를 만들어 화이트 노이즈로 채운 다음 &lt;a href=&quot;../audiobuffersourcenode&quot;&gt; &lt;code&gt;AudioBufferSourceNode&lt;/code&gt; &lt;/a&gt; 를 통해 재생합니다 . 의견은 무슨 일이 일어나고 있는지 명확하게 설명해야합니다. &lt;a href=&quot;https://mdn.github.io/webaudio-examples/audio-buffer/&quot;&gt;코드를 실시간으로 실행&lt;/a&gt; 하거나 &lt;a href=&quot;https://github.com/mdn/webaudio-examples&quot;&gt;소스를 볼&lt;/a&gt; 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="f4bb5bc0782a7e14fcddc65635b72a17225427f8" translate="yes" xml:space="preserve">
          <source>In the following example we open a transaction and an object store, then get the index &lt;code&gt;lName&lt;/code&gt; from a simple contacts database. We then open a basic cursor on the index using &lt;a href=&quot;../idbindex/opencursor&quot;&gt;&lt;code&gt;IDBIndex.openCursor&lt;/code&gt;&lt;/a&gt; &amp;mdash; this works the same as opening a cursor directly on an &lt;code&gt;ObjectStore&lt;/code&gt; using &lt;a href=&quot;opencursor&quot;&gt;&lt;code&gt;IDBObjectStore.openCursor&lt;/code&gt;&lt;/a&gt; except that the returned records are sorted based on the index, not the primary key.</source>
          <target state="translated">다음 예에서는 트랜잭션과 개체 저장소를 연 다음 간단한 연락처 데이터베이스에서 인덱스 &lt;code&gt;lName&lt;/code&gt; 을 가져옵니다 . 그런 다음 &lt;a href=&quot;../idbindex/opencursor&quot;&gt; &lt;code&gt;IDBIndex.openCursor&lt;/code&gt; 를&lt;/a&gt; 사용하여 인덱스에서 기본 커서를 엽니 다. 이는 반환 된 레코드가 기본 키가 아닌 인덱스를 기준으로 정렬 &lt;a href=&quot;opencursor&quot;&gt; &lt;code&gt;IDBObjectStore.openCursor&lt;/code&gt; &lt;/a&gt; 점을 제외하고 IDBObjectStore.openCursor를 사용하여 &lt;code&gt;ObjectStore&lt;/code&gt; 에서 직접 커서를 여는 것과 동일하게 작동합니다 .</target>
        </trans-unit>
        <trans-unit id="ad642637028d27153d859e39e2a13769514d21e8" translate="yes" xml:space="preserve">
          <source>In the following example we open a transaction and an object store, then get the index &lt;code&gt;lName&lt;/code&gt; from a simple contacts database. We then open a basic cursor on the index using &lt;a href=&quot;idbindex/opencursor&quot;&gt;&lt;code&gt;IDBIndex.openCursor&lt;/code&gt;&lt;/a&gt; &amp;mdash; this works the same as opening a cursor directly on an &lt;code&gt;ObjectStore&lt;/code&gt; using &lt;a href=&quot;idbobjectstore/opencursor&quot;&gt;&lt;code&gt;IDBObjectStore.openCursor&lt;/code&gt;&lt;/a&gt; except that the returned records are sorted based on the index, not the primary key.</source>
          <target state="translated">다음 예에서는 트랜잭션과 개체 저장소를 연 다음 간단한 연락처 데이터베이스에서 인덱스 &lt;code&gt;lName&lt;/code&gt; 을 가져옵니다 . 그런 다음 &lt;a href=&quot;idbindex/opencursor&quot;&gt; &lt;code&gt;IDBIndex.openCursor&lt;/code&gt; 를&lt;/a&gt; 사용하여 인덱스에서 기본 커서를 엽니 다. 이는 반환 된 레코드가 기본 키가 아닌 인덱스를 기준으로 정렬 &lt;a href=&quot;idbobjectstore/opencursor&quot;&gt; &lt;code&gt;IDBObjectStore.openCursor&lt;/code&gt; &lt;/a&gt; 점을 제외하고 IDBObjectStore.openCursor를 사용하여 &lt;code&gt;ObjectStore&lt;/code&gt; 에서 직접 커서를 여는 것과 동일하게 작동합니다 .</target>
        </trans-unit>
        <trans-unit id="0d39035e98ce578c166dc6ba88a351fd3b654900" translate="yes" xml:space="preserve">
          <source>In the following example we open a transaction and an object store, then get the index &lt;code&gt;lName&lt;/code&gt; from a simple contacts database. We then open a basic cursor on the index using &lt;a href=&quot;opencursor&quot;&gt;&lt;code&gt;IDBIndex.openCursor()&lt;/code&gt;&lt;/a&gt; &amp;mdash; this works the same as opening a cursor directly on an &lt;a href=&quot;../idbobjectstore&quot;&gt;&lt;code&gt;IDBObjectStore&lt;/code&gt;&lt;/a&gt; using &lt;a href=&quot;../idbobjectstore/opencursor&quot;&gt;&lt;code&gt;openCursor()&lt;/code&gt;&lt;/a&gt; except that the returned records are sorted based on the index, not the primary key.</source>
          <target state="translated">다음 예에서는 트랜잭션과 개체 저장소를 연 다음 간단한 연락처 데이터베이스에서 인덱스 &lt;code&gt;lName&lt;/code&gt; 을 가져옵니다 . 우리는 다음 사용하여 인덱스에 기본 커서를 열 &lt;a href=&quot;opencursor&quot;&gt; &lt;code&gt;IDBIndex.openCursor()&lt;/code&gt; &lt;/a&gt; - 이것은 직접 커서를 여는 것과 동일하게 작동 &lt;a href=&quot;../idbobjectstore&quot;&gt; &lt;code&gt;IDBObjectStore&lt;/code&gt; &lt;/a&gt; 사용하여 &lt;a href=&quot;../idbobjectstore/opencursor&quot;&gt; &lt;code&gt;openCursor()&lt;/code&gt; &lt;/a&gt; 반환 된 레코드가 인덱스가 아닌 기본 키에 따라 분류된다는 점을 제외하고.</target>
        </trans-unit>
        <trans-unit id="8694728b278a221349f924251115114166382831" translate="yes" xml:space="preserve">
          <source>In the following example we open a transaction and an object store, then get the index &lt;code&gt;lName&lt;/code&gt; from a simple contacts database. We then open a basic cursor on the index using &lt;a href=&quot;opencursor&quot;&gt;&lt;code&gt;IDBIndex.openCursor&lt;/code&gt;&lt;/a&gt; &amp;mdash; this works the same as opening a cursor directly on an &lt;code&gt;ObjectStore&lt;/code&gt; using &lt;a href=&quot;../idbobjectstore/opencursor&quot;&gt;&lt;code&gt;IDBObjectStore.openCursor&lt;/code&gt;&lt;/a&gt; except that the returned records are sorted based on the index, not the primary key.</source>
          <target state="translated">다음 예에서는 트랜잭션과 개체 저장소를 연 다음 간단한 연락처 데이터베이스에서 인덱스 &lt;code&gt;lName&lt;/code&gt; 을 가져옵니다 . 그런 다음 &lt;a href=&quot;opencursor&quot;&gt; &lt;code&gt;IDBIndex.openCursor&lt;/code&gt; 를&lt;/a&gt; 사용하여 인덱스에서 기본 커서를 엽니 다. 이는 반환 된 레코드가 기본 키가 아닌 인덱스를 기준으로 정렬 &lt;a href=&quot;../idbobjectstore/opencursor&quot;&gt; &lt;code&gt;IDBObjectStore.openCursor&lt;/code&gt; &lt;/a&gt; 점을 제외하고 IDBObjectStore.openCursor를 사용하여 &lt;code&gt;ObjectStore&lt;/code&gt; 에서 직접 커서를 여는 것과 동일하게 작동합니다 .</target>
        </trans-unit>
        <trans-unit id="21af5877ddb1b88586e3b5af4da9dc9daac0d4b3" translate="yes" xml:space="preserve">
          <source>In the following example we open a transaction and an object store, then get the index &lt;code&gt;lName&lt;/code&gt; from a simple contacts database. We then open a basic cursor on the index using &lt;a href=&quot;opencursor&quot;&gt;&lt;code&gt;IDBIndex.openCursor&lt;/code&gt;&lt;/a&gt;. This works the same as opening a cursor directly on an &lt;code&gt;ObjectStore&lt;/code&gt; using &lt;a href=&quot;../idbobjectstore/opencursor&quot;&gt;&lt;code&gt;IDBObjectStore.openCursor&lt;/code&gt;&lt;/a&gt; except that the returned records are sorted based on the index, not the primary key.</source>
          <target state="translated">다음 예에서는 트랜잭션과 개체 저장소를 연 다음 간단한 연락처 데이터베이스에서 인덱스 &lt;code&gt;lName&lt;/code&gt; 을 가져옵니다 . 그런 다음 &lt;a href=&quot;opencursor&quot;&gt; &lt;code&gt;IDBIndex.openCursor&lt;/code&gt; 를&lt;/a&gt; 사용하여 인덱스에서 기본 커서를 엽니 다 . 이는 반환 된 레코드가 기본 키가 아닌 인덱스를 기준으로 정렬 &lt;a href=&quot;../idbobjectstore/opencursor&quot;&gt; &lt;code&gt;IDBObjectStore.openCursor&lt;/code&gt; &lt;/a&gt; 점을 제외하고 IDBObjectStore.openCursor를 사용하여 &lt;code&gt;ObjectStore&lt;/code&gt; 에서 직접 커서를 여는 것과 동일하게 작동합니다 .</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
