<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="d">
    <body>
      <group id="d">
        <trans-unit id="2129521b769d915727dcb1e653df38210cfe3143" translate="yes" xml:space="preserve">
          <source>This method takes a &lt;code&gt;bool&lt;/code&gt; as first argument. In order for the data to be processed the &lt;code&gt;bool&lt;/code&gt; must be &lt;code&gt;true&lt;/code&gt; and the &lt;code&gt;LogLevel&lt;/code&gt; of the Logger must be greater or equal to the global &lt;code&gt;LogLevel&lt;/code&gt;.</source>
          <target state="translated">이 방법은 &lt;code&gt;bool&lt;/code&gt; 을 첫 번째 인수로 사용합니다. 데이터를 처리하려면 &lt;code&gt;bool&lt;/code&gt; 이 &lt;code&gt;true&lt;/code&gt; 여야하고 Logger 의 &lt;code&gt;LogLevel&lt;/code&gt; 이 전역 &lt;code&gt;LogLevel&lt;/code&gt; 보다 크거나 같아야합니다 .</target>
        </trans-unit>
        <trans-unit id="d0cb43593777a49c6e95ba5b0dcc72f45a57113c" translate="yes" xml:space="preserve">
          <source>This methods get and set the global &lt;code&gt;LogLevel&lt;/code&gt;.</source>
          <target state="translated">이 메소드는 전역 &lt;code&gt;LogLevel&lt;/code&gt; 을 가져오고 설정합니다 .</target>
        </trans-unit>
        <trans-unit id="a7803a9c22a232513790fa103468328fa0b2565b" translate="yes" xml:space="preserve">
          <source>This might affect your application if it has threads that are not suspended during the mark phase of the collection. You can configure the number of additional threads used for marking by GC option &lt;code&gt;parallel&lt;/code&gt;, e.g. by passing &lt;code&gt;--DRT-gcopt=parallel:2&lt;/code&gt; on the command line or embedding the option into the binary via &lt;code&gt;rt_options&lt;/code&gt;. The number of threads actually created is limited to &lt;a href=&quot;https://dlang.org/library/core/cpuid/threads_per_cpu.html&quot;&gt;&lt;code&gt;core.cpuid.threadsPerCPU-1&lt;/code&gt;&lt;/a&gt;. A value of &lt;code&gt;0&lt;/code&gt; disables parallel marking completely.</source>
          <target state="translated">콜렉션의 마크 단계 중에 일시 중단되지 않은 스레드가있는 경우 애플리케이션에 영향을 줄 수 있습니다. 명령 행에서 &lt;code&gt;--DRT-gcopt=parallel:2&lt;/code&gt; 를 전달 하거나 &lt;code&gt;rt_options&lt;/code&gt; 를 통해 옵션을 바이너리에 임베드하여 GC 옵션 &lt;code&gt;parallel&lt;/code&gt; 표시에 사용되는 추가 스레드 수를 구성 할 수 있습니다 . 실제로 작성된 스레드 수는 &lt;a href=&quot;https://dlang.org/library/core/cpuid/threads_per_cpu.html&quot;&gt; &lt;code&gt;core.cpuid.threadsPerCPU-1&lt;/code&gt; 로&lt;/a&gt; 제한됩니다 . 값이 &lt;code&gt;0&lt;/code&gt; 이면 병렬 표시가 완전히 비활성화됩니다.</target>
        </trans-unit>
        <trans-unit id="abf107b5c6e2c3e95aef57b0f00ce4199d6e77e4" translate="yes" xml:space="preserve">
          <source>This module allows content to be iterated by record stored in a struct, class, associative array, or as a range of fields. Upon detection of an error an CSVException is thrown (can be disabled). csvNextToken has been made public to allow for attempted recovery.  Disabling exceptions will lift many restrictions specified above. A quote can appear in a field if the field was not quoted. If in a quoted field any quote by itself, not at the end of a field, will end processing for that field. The field is ended when there is no input, even if the quote was not closed.</source>
          <target state="translated">이 모듈을 사용하면 구조체, 클래스, 연관 배열 또는 필드 범위에 저장된 레코드로 내용을 반복 할 수 있습니다. 오류를 감지하면 CSVException이 발생합니다 (비활성화 할 수 있음). 복구 시도를 허용하기 위해 csvNextToken이 공개되었습니다. 예외를 비활성화하면 위에서 지정한 많은 제한이 해제됩니다. 필드가 인용되지 않은 경우 견적이 필드에 나타날 수 있습니다. 따옴표로 묶은 필드에 필드의 끝이 아닌 그 자체로 따옴표가 있으면 해당 필드에 대한 처리가 종료됩니다. 따옴표가 닫히지 않아도 입력이 없으면 필드가 종료됩니다.</target>
        </trans-unit>
        <trans-unit id="0c12be692d1a1b6196ff193f230f2b2b54e371d1" translate="yes" xml:space="preserve">
          <source>This module and its documentation are inspired by Perl's &lt;a href=&quot;http://%20%20%20%20%20%20%20%20%20%20%20perldoc.perl.org/Getopt/Long.html&quot;&gt;Getopt::Long&lt;/a&gt; module. The syntax of D's &lt;code&gt;getopt&lt;/code&gt; is simpler than its Perl counterpart because &lt;code&gt; getopt&lt;/code&gt; infers the expected parameter types from the static types of the passed-in pointers.</source>
          <target state="translated">이 모듈과 설명서는 Perl의 &lt;a href=&quot;http://%20%20%20%20%20%20%20%20%20%20%20perldoc.perl.org/Getopt/Long.html&quot;&gt;Getopt :: Long&lt;/a&gt; 모듈 에서 영감을 받았습니다 . D의 구문 &lt;code&gt;getopt&lt;/code&gt; 에는 자사의 펄 대응보다 간단하기 때문에 &lt;code&gt; getopt&lt;/code&gt; 는 추론한다 포인터 건네의 정적 유형에서 예상되는 매개 변수 유형.</target>
        </trans-unit>
        <trans-unit id="7f09ec381e380d7513f44d1a9c117509cf562d32" translate="yes" xml:space="preserve">
          <source>This module centers around two functions:</source>
          <target state="translated">이 모듈은 두 가지 기능을 중심으로합니다.</target>
        </trans-unit>
        <trans-unit id="20c669a98c4868307d434ad05bfdc4a3a51a1300" translate="yes" xml:space="preserve">
          <source>This module conforms to the APIs defined in &lt;a href=&quot;std_digest&quot;&gt;&lt;code&gt;std.digest&lt;/code&gt;&lt;/a&gt;.  This module publicly imports &lt;a href=&quot;std_digest&quot;&gt;&lt;code&gt;std.digest&lt;/code&gt;&lt;/a&gt; and can be used as a stand-alone module.</source>
          <target state="translated">이 모듈은 &lt;a href=&quot;std_digest&quot;&gt; &lt;code&gt;std.digest&lt;/code&gt; 에&lt;/a&gt; 정의 된 API를 준수합니다 . 이 모듈은 &lt;a href=&quot;std_digest&quot;&gt; &lt;code&gt;std.digest&lt;/code&gt; 를&lt;/a&gt; 공개적으로 가져 오고 독립형 모듈로 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f7a16008011138e31550b797755a77e5d03cd02e" translate="yes" xml:space="preserve">
          <source>This module conforms to the APIs defined in &lt;a href=&quot;std_digest&quot;&gt;&lt;code&gt;std.digest&lt;/code&gt;&lt;/a&gt;. To understand the differences between the template and the OOP API, see &lt;a href=&quot;std_digest&quot;&gt;&lt;code&gt;std.digest&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 모듈은 &lt;a href=&quot;std_digest&quot;&gt; &lt;code&gt;std.digest&lt;/code&gt; 에&lt;/a&gt; 정의 된 API를 준수합니다 . 템플릿과 OOP API의 차이점을 이해하려면 &lt;a href=&quot;std_digest&quot;&gt; &lt;code&gt;std.digest&lt;/code&gt; 를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="17ae71bfaa531ddd2da20bee8e617777975ac653" translate="yes" xml:space="preserve">
          <source>This module conforms to the APIs defined in &lt;code&gt;std.digest&lt;/code&gt;. To understand the differences between the template and the OOP API, see &lt;a href=&quot;std_digest&quot;&gt;&lt;code&gt;std.digest&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 모듈은 &lt;code&gt;std.digest&lt;/code&gt; 에 정의 된 API를 준수합니다 . 템플릿과 OOP API의 차이점을 이해하려면 &lt;a href=&quot;std_digest&quot;&gt; &lt;code&gt;std.digest&lt;/code&gt; 를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="5d23cc75f3120c33113ac064a49eabf3de54b0fa" translate="yes" xml:space="preserve">
          <source>This module consists of the following submodules:</source>
          <target state="translated">이 모듈은 다음과 같은 하위 모듈로 구성됩니다.</target>
        </trans-unit>
        <trans-unit id="acafb5c32c70d9aae6c63b01f760110057442f4d" translate="yes" xml:space="preserve">
          <source>This module contains UDA's (User Defined Attributes) either used in the runtime or special UDA's recognized by compiler.</source>
          <target state="translated">이 모듈에는 런타임에서 사용되는 UDA (사용자 정의 속성) 또는 컴파일러가 인식하는 특수 UDA가 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="85899b400fb24fe82d032611b825cbfb9b44e4d4" translate="yes" xml:space="preserve">
          <source>This module contains a collection of bit-level operations.</source>
          <target state="translated">이 모듈에는 비트 수준 작업 모음이 포함되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="c1389c215e1a5264fea083894c94780e9d38b766" translate="yes" xml:space="preserve">
          <source>This module contains all functions related to an object's lifetime: allocation, resizing, deallocation, and finalization.</source>
          <target state="translated">이 모듈에는 개체 수명과 관련된 모든 기능 (할당, 크기 조정, 할당 해제 및 마무리)이 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="2e22ee3bb8cbf087613e536d6224ea16946bb6a9" translate="yes" xml:space="preserve">
          <source>This module contains bindings to selected types and functions from the standard C header &lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/009695399/basedefs/assert.h.html&quot;&gt;&lt;code&gt;&amp;lt;assert.h&amp;gt;&lt;/code&gt;&lt;/a&gt;. Note that this is not automatically generated, and may omit some types/functions from the original C header.</source>
          <target state="translated">이 모듈에는 표준 C 헤더 &lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/009695399/basedefs/assert.h.html&quot;&gt; &lt;code&gt;&amp;lt;assert.h&amp;gt;&lt;/code&gt; &lt;/a&gt; 에서 선택한 유형 및 함수에 대한 바인딩이 포함되어 있습니다 . 이것은 자동으로 생성되지 않으며 원래 C 헤더에서 일부 유형 / 기능을 생략 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0790e73d68257f0feac07da73031d54a40efb1ec" translate="yes" xml:space="preserve">
          <source>This module contains bindings to selected types and functions from the standard C header &lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/009695399/basedefs/complex.h.html&quot;&gt;&lt;code&gt;&amp;lt;complex.h&amp;gt;&lt;/code&gt;&lt;/a&gt;. Note that this is not automatically generated, and may omit some types/functions from the original C header.</source>
          <target state="translated">이 모듈에는 표준 C 헤더 &lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/009695399/basedefs/complex.h.html&quot;&gt; &lt;code&gt;&amp;lt;complex.h&amp;gt;&lt;/code&gt; &lt;/a&gt; 에서 선택한 유형 및 함수에 대한 바인딩이 포함되어 있습니다 . 이것은 자동으로 생성되지 않으며 원래 C 헤더에서 일부 유형 / 기능을 생략 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="977e99994de35a20a0e314dc2374362a82960544" translate="yes" xml:space="preserve">
          <source>This module contains bindings to selected types and functions from the standard C header &lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/009695399/basedefs/ctype.h.html&quot;&gt;&lt;code&gt;&amp;lt;ctype.h&amp;gt;&lt;/code&gt;&lt;/a&gt;. Note that this is not automatically generated, and may omit some types/functions from the original C header.</source>
          <target state="translated">이 모듈에는 표준 C 헤더 &lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/009695399/basedefs/ctype.h.html&quot;&gt; &lt;code&gt;&amp;lt;ctype.h&amp;gt;&lt;/code&gt; &lt;/a&gt; 에서 선택한 유형 및 함수에 대한 바인딩이 포함되어 있습니다 . 이것은 자동으로 생성되지 않으며 원래 C 헤더에서 일부 유형 / 기능을 생략 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="12b921fc7078621d7eaa8b76c016bec3d37b2ea8" translate="yes" xml:space="preserve">
          <source>This module contains bindings to selected types and functions from the standard C header &lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/009695399/basedefs/errno.h.html&quot;&gt;&lt;code&gt;&amp;lt;errno.h&amp;gt;&lt;/code&gt;&lt;/a&gt;. Note that this is not automatically generated, and may omit some types/functions from the original C header.</source>
          <target state="translated">이 모듈에는 표준 C 헤더 &lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/009695399/basedefs/errno.h.html&quot;&gt; &lt;code&gt;&amp;lt;errno.h&amp;gt;&lt;/code&gt; &lt;/a&gt; 에서 선택한 유형 및 함수에 대한 바인딩이 포함되어 있습니다 . 이것은 자동으로 생성되지 않으며 원래 C 헤더에서 일부 유형 / 기능을 생략 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3184aa12179289bb1bc9cc36d8ce4348bfa946fe" translate="yes" xml:space="preserve">
          <source>This module contains bindings to selected types and functions from the standard C header &lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/009695399/basedefs/fenv.h.html&quot;&gt;&lt;code&gt;&amp;lt;fenv.h&amp;gt;&lt;/code&gt;&lt;/a&gt;. Note that this is not automatically generated, and may omit some types/functions from the original C header.</source>
          <target state="translated">이 모듈에는 표준 C 헤더 &lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/009695399/basedefs/fenv.h.html&quot;&gt; &lt;code&gt;&amp;lt;fenv.h&amp;gt;&lt;/code&gt; &lt;/a&gt; 에서 선택한 유형 및 함수에 대한 바인딩이 포함되어 있습니다 . 이것은 자동으로 생성되지 않으며 원래 C 헤더에서 일부 유형 / 기능을 생략 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8eb2c62940c679e140d89cb9017957cd6a4ba64f" translate="yes" xml:space="preserve">
          <source>This module contains bindings to selected types and functions from the standard C header &lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/009695399/basedefs/float.h.html&quot;&gt;&lt;code&gt;&amp;lt;float.h&amp;gt;&lt;/code&gt;&lt;/a&gt;. Note that this is not automatically generated, and may omit some types/functions from the original C header.</source>
          <target state="translated">이 모듈에는 표준 C 헤더 &lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/009695399/basedefs/float.h.html&quot;&gt; &lt;code&gt;&amp;lt;float.h&amp;gt;&lt;/code&gt; &lt;/a&gt; 에서 선택한 유형 및 함수에 대한 바인딩이 포함되어 있습니다 . 이것은 자동으로 생성되지 않으며 원래 C 헤더에서 일부 유형 / 기능을 생략 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="82e3f25e60216c815c395312071e29f7c8ca0ddd" translate="yes" xml:space="preserve">
          <source>This module contains bindings to selected types and functions from the standard C header &lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/009695399/basedefs/inttypes.h.html&quot;&gt;&lt;code&gt;&amp;lt;inttypes.h&amp;gt;&lt;/code&gt;&lt;/a&gt;. Note that this is not automatically generated, and may omit some types/functions from the original C header.</source>
          <target state="translated">이 모듈에는 표준 C 헤더 &lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/009695399/basedefs/inttypes.h.html&quot;&gt; &lt;code&gt;&amp;lt;inttypes.h&amp;gt;&lt;/code&gt; &lt;/a&gt; 에서 선택한 유형 및 함수에 대한 바인딩이 포함되어 있습니다 . 이것은 자동으로 생성되지 않으며 원래 C 헤더에서 일부 유형 / 기능을 생략 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f313b0f4d7c80470b377169af784edeeb810ec9d" translate="yes" xml:space="preserve">
          <source>This module contains bindings to selected types and functions from the standard C header &lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/009695399/basedefs/limits.h.html&quot;&gt;&lt;code&gt;&amp;lt;limits.h&amp;gt;&lt;/code&gt;&lt;/a&gt;. Note that this is not automatically generated, and may omit some types/functions from the original C header.</source>
          <target state="translated">이 모듈에는 표준 C 헤더 &lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/009695399/basedefs/limits.h.html&quot;&gt; &lt;code&gt;&amp;lt;limits.h&amp;gt;&lt;/code&gt; &lt;/a&gt; 에서 선택한 유형 및 함수에 대한 바인딩이 포함되어 있습니다 . 이것은 자동으로 생성되지 않으며 원래 C 헤더에서 일부 유형 / 기능을 생략 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="889ac9c43694fc79bd24e61dceed4e6fda688b35" translate="yes" xml:space="preserve">
          <source>This module contains bindings to selected types and functions from the standard C header &lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/009695399/basedefs/locale.h.html&quot;&gt;&lt;code&gt;&amp;lt;locale.h&amp;gt;&lt;/code&gt;&lt;/a&gt;. Note that this is not automatically generated, and may omit some types/functions from the original C header.</source>
          <target state="translated">이 모듈에는 표준 C 헤더 &lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/009695399/basedefs/locale.h.html&quot;&gt; &lt;code&gt;&amp;lt;locale.h&amp;gt;&lt;/code&gt; &lt;/a&gt; 에서 선택한 유형 및 함수에 대한 바인딩이 포함되어 있습니다 . 이것은 자동으로 생성되지 않으며 원래 C 헤더에서 일부 유형 / 기능을 생략 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8bd014e9d5a4fdbad34dcb7fb8420e937c0abc85" translate="yes" xml:space="preserve">
          <source>This module contains bindings to selected types and functions from the standard C header &lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/009695399/basedefs/math.h.html&quot;&gt;&lt;code&gt;&amp;lt;math.h&amp;gt;&lt;/code&gt;&lt;/a&gt;. Note that this is not automatically generated, and may omit some types/functions from the original C header.</source>
          <target state="translated">이 모듈에는 표준 C 헤더 &lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/009695399/basedefs/math.h.html&quot;&gt; &lt;code&gt;&amp;lt;math.h&amp;gt;&lt;/code&gt; &lt;/a&gt; 에서 선택한 유형 및 함수에 대한 바인딩이 포함되어 있습니다 . 이것은 자동으로 생성되지 않으며 원래 C 헤더에서 일부 유형 / 기능을 생략 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="fc16180c80d567a16457d88550f7aa27a1b419aa" translate="yes" xml:space="preserve">
          <source>This module contains bindings to selected types and functions from the standard C header &lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/009695399/basedefs/signal.h.html&quot;&gt;&lt;code&gt;&amp;lt;signal.h&amp;gt;&lt;/code&gt;&lt;/a&gt;. Note that this is not automatically generated, and may omit some types/functions from the original C header.</source>
          <target state="translated">이 모듈에는 표준 C 헤더 &lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/009695399/basedefs/signal.h.html&quot;&gt; &lt;code&gt;&amp;lt;signal.h&amp;gt;&lt;/code&gt; &lt;/a&gt; 에서 선택한 유형 및 함수에 대한 바인딩이 포함되어 있습니다 . 이것은 자동으로 생성되지 않으며 원래 C 헤더에서 일부 유형 / 기능을 생략 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5971b6bf8e57282688ff4449029781d4b3a236d4" translate="yes" xml:space="preserve">
          <source>This module contains bindings to selected types and functions from the standard C header &lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/009695399/basedefs/stdarg.h.html&quot;&gt;&lt;code&gt;&amp;lt;stdarg.h&amp;gt;&lt;/code&gt;&lt;/a&gt;. Note that this is not automatically generated, and may omit some types/functions from the original C header.</source>
          <target state="translated">이 모듈에는 표준 C 헤더 &lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/009695399/basedefs/stdarg.h.html&quot;&gt; &lt;code&gt;&amp;lt;stdarg.h&amp;gt;&lt;/code&gt; &lt;/a&gt; 에서 선택한 유형 및 함수에 대한 바인딩이 포함되어 있습니다 . 이것은 자동으로 생성되지 않으며 원래 C 헤더에서 일부 유형 / 기능을 생략 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b580515d9fbf0a4ef7b9e421dec5768897b813d8" translate="yes" xml:space="preserve">
          <source>This module contains bindings to selected types and functions from the standard C header &lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/009695399/basedefs/stddef.h.html&quot;&gt;&lt;code&gt;&amp;lt;stddef.h&amp;gt;&lt;/code&gt;&lt;/a&gt;. Note that this is not automatically generated, and may omit some types/functions from the original C header.</source>
          <target state="translated">이 모듈에는 표준 C 헤더 &lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/009695399/basedefs/stddef.h.html&quot;&gt; &lt;code&gt;&amp;lt;stddef.h&amp;gt;&lt;/code&gt; &lt;/a&gt; 에서 선택한 유형 및 함수에 대한 바인딩이 포함되어 있습니다 . 이것은 자동으로 생성되지 않으며 원래 C 헤더에서 일부 유형 / 기능을 생략 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="95281628a03db4872107318eb8c99b1bea13ccc2" translate="yes" xml:space="preserve">
          <source>This module contains bindings to selected types and functions from the standard C header &lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/009695399/basedefs/stdint.h.html&quot;&gt;&lt;code&gt;&amp;lt;stdint.h&amp;gt;&lt;/code&gt;&lt;/a&gt;. Note that this is not automatically generated, and may omit some types/functions from the original C header.</source>
          <target state="translated">이 모듈에는 표준 C 헤더 &lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/009695399/basedefs/stdint.h.html&quot;&gt; &lt;code&gt;&amp;lt;stdint.h&amp;gt;&lt;/code&gt; &lt;/a&gt; 에서 선택한 유형 및 함수에 대한 바인딩이 포함되어 있습니다 . 이것은 자동으로 생성되지 않으며 원래 C 헤더에서 일부 유형 / 기능을 생략 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="51ba870a61bb5fb732f12f00ebdf0f6bdf33ab08" translate="yes" xml:space="preserve">
          <source>This module contains bindings to selected types and functions from the standard C header &lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/009695399/basedefs/stdio.h.html&quot;&gt;&lt;code&gt;&amp;lt;stdio.h&amp;gt;&lt;/code&gt;&lt;/a&gt;. Note that this is not automatically generated, and may omit some types/functions from the original C header.</source>
          <target state="translated">이 모듈에는 표준 C 헤더 &lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/009695399/basedefs/stdio.h.html&quot;&gt; &lt;code&gt;&amp;lt;stdio.h&amp;gt;&lt;/code&gt; &lt;/a&gt; 에서 선택한 유형 및 함수에 대한 바인딩이 포함되어 있습니다 . 이것은 자동으로 생성되지 않으며 원래 C 헤더에서 일부 유형 / 기능을 생략 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b6d9cbc1fb19908d75c057b6e010d377eada4d77" translate="yes" xml:space="preserve">
          <source>This module contains bindings to selected types and functions from the standard C header &lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/009695399/basedefs/stdlib.h.html&quot;&gt;&lt;code&gt;&amp;lt;stdlib.h&amp;gt;&lt;/code&gt;&lt;/a&gt;. Note that this is not automatically generated, and may omit some types/functions from the original C header.</source>
          <target state="translated">이 모듈에는 표준 C 헤더 &lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/009695399/basedefs/stdlib.h.html&quot;&gt; &lt;code&gt;&amp;lt;stdlib.h&amp;gt;&lt;/code&gt; &lt;/a&gt; 에서 선택한 유형 및 함수에 대한 바인딩이 포함되어 있습니다 . 이것은 자동으로 생성되지 않으며 원래 C 헤더에서 일부 유형 / 기능을 생략 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="050d1037c01667ef5f3b8f67c4951211e12ccacf" translate="yes" xml:space="preserve">
          <source>This module contains bindings to selected types and functions from the standard C header &lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/009695399/basedefs/string.h.html&quot;&gt;&lt;code&gt;&amp;lt;string.h&amp;gt;&lt;/code&gt;&lt;/a&gt;. Note that this is not automatically generated, and may omit some types/functions from the original C header.</source>
          <target state="translated">이 모듈에는 표준 C 헤더 &lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/009695399/basedefs/string.h.html&quot;&gt; &lt;code&gt;&amp;lt;string.h&amp;gt;&lt;/code&gt; &lt;/a&gt; 에서 선택한 유형 및 함수에 대한 바인딩이 포함되어 있습니다 . 이것은 자동으로 생성되지 않으며 원래 C 헤더에서 일부 유형 / 기능을 생략 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f549cd509c6cf2035fd5afdb0920eaa5d4d5e84e" translate="yes" xml:space="preserve">
          <source>This module contains bindings to selected types and functions from the standard C header &lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/009695399/basedefs/tgmath.h.html&quot;&gt;&lt;code&gt;&amp;lt;tgmath.h&amp;gt;&lt;/code&gt;&lt;/a&gt;. Note that this is not automatically generated, and may omit some types/functions from the original C header.</source>
          <target state="translated">이 모듈에는 표준 C 헤더 &lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/009695399/basedefs/tgmath.h.html&quot;&gt; &lt;code&gt;&amp;lt;tgmath.h&amp;gt;&lt;/code&gt; &lt;/a&gt; 에서 선택된 유형 및 함수에 대한 바인딩이 포함되어 있습니다 . 이것은 자동으로 생성되지 않으며 원래 C 헤더에서 일부 유형 / 기능을 생략 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="62c64533f70dfc4fd8955bc0b3a2834ad07751af" translate="yes" xml:space="preserve">
          <source>This module contains bindings to selected types and functions from the standard C header &lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/009695399/basedefs/time.h.html&quot;&gt;&lt;code&gt;&amp;lt;time.h&amp;gt;&lt;/code&gt;&lt;/a&gt;. Note that this is not automatically generated, and may omit some types/functions from the original C header.</source>
          <target state="translated">이 모듈에는 표준 C 헤더 &lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/009695399/basedefs/time.h.html&quot;&gt; &lt;code&gt;&amp;lt;time.h&amp;gt;&lt;/code&gt; &lt;/a&gt; 에서 선택한 유형 및 함수에 대한 바인딩이 포함되어 있습니다 . 이것은 자동으로 생성되지 않으며 원래 C 헤더에서 일부 유형 / 기능을 생략 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="92aabdabf0e70387e5a38f4c231411efd14217e3" translate="yes" xml:space="preserve">
          <source>This module contains bindings to selected types and functions from the standard C header &lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/009695399/basedefs/wchar.h.html&quot;&gt;&lt;code&gt;&amp;lt;wchar.h&amp;gt;&lt;/code&gt;&lt;/a&gt;. Note that this is not automatically generated, and may omit some types/functions from the original C header.</source>
          <target state="translated">이 모듈에는 표준 C 헤더 &lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/009695399/basedefs/wchar.h.html&quot;&gt; &lt;code&gt;&amp;lt;wchar.h&amp;gt;&lt;/code&gt; &lt;/a&gt; 에서 선택한 유형 및 함수에 대한 바인딩이 포함되어 있습니다 . 이것은 자동으로 생성되지 않으며 원래 C 헤더에서 일부 유형 / 기능을 생략 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0ec277ffc9998ff3f0f63d9eedcde3635f0eb758" translate="yes" xml:space="preserve">
          <source>This module contains bindings to selected types and functions from the standard C header &lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/009695399/basedefs/wctype.h.html&quot;&gt;&lt;code&gt;&amp;lt;wctype.h&amp;gt;&lt;/code&gt;&lt;/a&gt;. Note that this is not automatically generated, and may omit some types/functions from the original C header.</source>
          <target state="translated">이 모듈에는 표준 C 헤더 &lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/009695399/basedefs/wctype.h.html&quot;&gt; &lt;code&gt;&amp;lt;wctype.h&amp;gt;&lt;/code&gt; &lt;/a&gt; 에서 선택된 유형 및 함수에 대한 바인딩이 포함되어 있습니다 . 이것은 자동으로 생성되지 않으며 원래 C 헤더에서 일부 유형 / 기능을 생략 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4332c56ae7f44bffd58f114ac37e892a2b103dd8" translate="yes" xml:space="preserve">
          <source>This module contains compiler support determining equality of dynamic arrays.</source>
          <target state="translated">이 모듈에는 동적 배열의 동등성을 결정하는 컴파일러 지원이 포함되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="a9409989c24e53c52350805b177653fd011bfa05" translate="yes" xml:space="preserve">
          <source>This module contains compiler support for casting dynamic arrays</source>
          <target state="translated">이 모듈에는 동적 배열 캐스팅을위한 컴파일러 지원이 포함되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="98da9476138dd631b9aa80ca4972d86126ed52a1" translate="yes" xml:space="preserve">
          <source>This module contains compiler support for comparing dynamic arrays</source>
          <target state="translated">이 모듈에는 동적 배열 비교를위한 컴파일러 지원이 포함되어 있습니다</target>
        </trans-unit>
        <trans-unit id="ea25ff08ceea8b6974ce0811b1a4d3c03f3a2b61" translate="yes" xml:space="preserve">
          <source>This module contains compiler support for constructing dynamic arrays</source>
          <target state="translated">이 모듈에는 동적 배열 구성을위한 컴파일러 지원이 포함되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="130d46533e13acaf0b0f736ae469ff9f68d6ff23" translate="yes" xml:space="preserve">
          <source>This module contains high-level interfaces for interacting with DMD as a library.</source>
          <target state="translated">이 모듈에는 라이브러리로서 DMD와 상호 작용하기위한 고급 인터페이스가 포함되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="7df04f2ddca174e21d081429f9f3c53ebccb78b8" translate="yes" xml:space="preserve">
          <source>This module contains some common utilities used by containers.</source>
          <target state="translated">이 모듈에는 컨테이너가 사용하는 몇 가지 일반적인 유틸리티가 포함되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="dcac3a1b4da6941734058525116d97065268b549" translate="yes" xml:space="preserve">
          <source>This module contains support for controlling dynamic arrays' appending</source>
          <target state="translated">이 모듈은 동적 배열의 추가 제어를 지원합니다.</target>
        </trans-unit>
        <trans-unit id="c49eb9ff2d1c37482fee0bb60748312c2292f298" translate="yes" xml:space="preserve">
          <source>This module contains support for controlling dynamic arrays' capacity and length</source>
          <target state="translated">이 모듈에는 동적 어레이의 용량 및 길이 제어 지원이 포함되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="5a472e4841c397ed8a20c7da34116a395a9f78db" translate="yes" xml:space="preserve">
          <source>This module contains support for controlling dynamic arrays' concatenation</source>
          <target state="translated">이 모듈은 동적 배열의 연결 제어를 지원합니다.</target>
        </trans-unit>
        <trans-unit id="d58f6f902fb5917dee8fa5b768555a18fd9ff404" translate="yes" xml:space="preserve">
          <source>This module contains the &lt;a href=&quot;#Complex&quot;&gt;&lt;code&gt;Complex&lt;/code&gt;&lt;/a&gt; type, which is used to represent complex numbers, along with related mathematical operations and functions.</source>
          <target state="translated">이 모듈에는 &lt;a href=&quot;#Complex&quot;&gt; &lt;code&gt;Complex&lt;/code&gt; &lt;/a&gt; 유형과 관련 수학 연산 및 함수를 나타내는 데 사용되는 복소수 유형이 있습니다.</target>
        </trans-unit>
        <trans-unit id="1cafe10d55f1a2961b685e59594325a88af3e24c" translate="yes" xml:space="preserve">
          <source>This module contains the &lt;code&gt;Id&lt;/code&gt; struct with a list of predefined symbols the compiler knows about.</source>
          <target state="translated">이 모듈에는 컴파일러가 알고있는 사전 정의 된 기호 목록이 있는 &lt;code&gt;Id&lt;/code&gt; 구조체가 포함되어 있습니다 .</target>
        </trans-unit>
        <trans-unit id="99093b5cfdcc5707f50f9cafa8f212b7442853a6" translate="yes" xml:space="preserve">
          <source>This module contains utilities for TypeInfo implementation.</source>
          <target state="translated">이 모듈에는 TypeInfo 구현을위한 유틸리티가 포함되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="a058b7e236eb5ab7c537629e84966c190eced743" translate="yes" xml:space="preserve">
          <source>This module contains utility functions to help the implementation of the runtime hook</source>
          <target state="translated">이 모듈에는 런타임 후크 구현을 돕는 유틸리티 기능이 포함되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="7d6317f5849751724969636691ef1f8625b672f7" translate="yes" xml:space="preserve">
          <source>This module contains various string related functions.</source>
          <target state="translated">이 모듈에는 다양한 문자열 관련 기능이 포함되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="9a531226ad2342a85a7cda80bcc56003e90c7e5a" translate="yes" xml:space="preserve">
          <source>This module defines &lt;code&gt;TypedAllocator&lt;/code&gt;, a statically-typed allocator that aggregates multiple untyped allocators and uses them depending on the static properties of the types allocated. For example, distinct allocators may be used for thread-local vs. thread-shared data, or for fixed-size data (&lt;code&gt;struct&lt;/code&gt;, &lt;code&gt;class&lt;/code&gt; objects) vs. resizable data (arrays).</source>
          <target state="translated">이 모듈은 유형이 지정되지 않은 여러 할당자를 집계하고 할당 된 유형의 정적 속성에 따라 사용하는 정적 유형 할당 &lt;code&gt;TypedAllocator&lt;/code&gt; 정의합니다 . 예를 들어, 별개의 할당자는 스레드 로컬 데이터와 스레드 공유 데이터 또는 고정 크기 데이터 ( &lt;code&gt;struct&lt;/code&gt; , &lt;code&gt;class&lt;/code&gt; 객체)와 크기 조정 가능 데이터 (배열)에 사용될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="259e74bca77eb48b491beebe7a35554776cb2efb" translate="yes" xml:space="preserve">
          <source>This module defines a number of primitives that work with graphemes: &lt;a href=&quot;#Grapheme&quot;&gt;&lt;code&gt;Grapheme&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#decodeGrapheme&quot;&gt;&lt;code&gt;decodeGrapheme&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#graphemeStride&quot;&gt;&lt;code&gt;graphemeStride&lt;/code&gt;&lt;/a&gt;. All of them are using</source>
          <target state="translated">이 모듈은 프리미티브의 수를 정의하는 작업을 제자로 : &lt;a href=&quot;#Grapheme&quot;&gt; &lt;code&gt;Grapheme&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#decodeGrapheme&quot;&gt; &lt;code&gt;decodeGrapheme&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#graphemeStride&quot;&gt; &lt;code&gt;graphemeStride&lt;/code&gt; &lt;/a&gt; . 그들 모두가 사용하고 있습니다</target>
        </trans-unit>
        <trans-unit id="99bc02ede476ad853ab518e42294b5202a998289" translate="yes" xml:space="preserve">
          <source>This module defines facilities for efficient checking of integral operations against overflow, casting with loss of precision, unexpected change of sign, etc. The checking (and possibly correction) can be done at operation level, for example &lt;a href=&quot;#opChecked&quot;&gt;&lt;code&gt;opChecked&lt;/code&gt;&lt;/a&gt;&lt;code&gt;!&quot;+&quot;(x, y, overflow)&lt;/code&gt; adds two integrals &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; and sets &lt;code&gt;overflow&lt;/code&gt; to &lt;code&gt;true&lt;/code&gt; if an overflow occurred. The flag &lt;code&gt;overflow&lt;/code&gt; (a &lt;code&gt;bool&lt;/code&gt; passed by reference) is not touched if the operation succeeded, so the same flag can be reused for a sequence of operations and tested at the end.</source>
          <target state="translated">이 모듈은 오버플로에 대한 적분 연산의 효율적인 점검, 정밀도 손실로 인한 캐스팅, 예기치 않은 부호 변경 등의 기능을 정의합니다. 점검 (및 가능한 수정)은 조작 레벨에서 수행 될 수 있습니다 (예 : &lt;a href=&quot;#opChecked&quot;&gt; &lt;code&gt;opChecked&lt;/code&gt; &lt;/a&gt; &lt;code&gt;!&quot;+&quot;(x, y, overflow)&lt;/code&gt; 는 두 개의 정수 &lt;code&gt;x&lt;/code&gt; 와 &lt;code&gt;y&lt;/code&gt; 를 더하고 오버플로가 발생하면 &lt;code&gt;overflow&lt;/code&gt; 를 &lt;code&gt;true&lt;/code&gt; 로 설정합니다 . 작업이 성공하면 플래그 &lt;code&gt;overflow&lt;/code&gt; ( 참조로 전달 된 &lt;code&gt;bool&lt;/code&gt; )는 건드리지 않으므로 동일한 플래그를 작업 시퀀스에 재사용하고 마지막에 테스트 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8e33eb3468c635b3f1b1bf8d7ab1a84f24b11f39" translate="yes" xml:space="preserve">
          <source>This module defines functions related to exceptions and general error handling. It also defines functions intended to aid in unit testing.</source>
          <target state="translated">이 모듈은 예외 및 일반적인 오류 처리와 관련된 기능을 정의합니다. 또한 단위 테스트에 도움이되는 기능을 정의합니다.</target>
        </trans-unit>
        <trans-unit id="2f439ece9b3ae412ebb6e407781c8a8d19e803e8" translate="yes" xml:space="preserve">
          <source>This module defines generic containers.</source>
          <target state="translated">이 모듈은 일반 컨테이너를 정의합니다.</target>
        </trans-unit>
        <trans-unit id="7716ef353856b8c8fdc336f0f551c1520abef4d6" translate="yes" xml:space="preserve">
          <source>This module defines the notion of a range. Ranges generalize the concept of arrays, lists, or anything that involves sequential access. This abstraction enables the same set of algorithms (see &lt;a href=&quot;std_algorithm&quot;&gt;&lt;code&gt;std.algorithm&lt;/code&gt;&lt;/a&gt;) to be used with a vast variety of different concrete types. For example, a linear search algorithm such as &lt;a href=&quot;std_algorithm_searching#find&quot;&gt;&lt;code&gt;std.algorithm.searching.find&lt;/code&gt;&lt;/a&gt; works not just for arrays, but for linked-lists, input files, incoming network data, etc.</source>
          <target state="translated">이 모듈은 범위의 개념을 정의합니다. 범위는 배열, 목록 또는 순차적 액세스와 관련된 모든 개념을 일반화합니다. 이 추상화를 통해 동일한 알고리즘 세트 ( &lt;a href=&quot;std_algorithm&quot;&gt; &lt;code&gt;std.algorithm&lt;/code&gt; &lt;/a&gt; 참조 )를 다양한 콘크리트 유형과 함께 사용할 수 있습니다. 예를 들어 &lt;a href=&quot;std_algorithm_searching#find&quot;&gt; &lt;code&gt;std.algorithm.searching.find&lt;/code&gt; &lt;/a&gt; 와 같은 선형 검색 알고리즘 은 배열뿐만 아니라 링크 된 목록, 입력 파일, 수신 네트워크 데이터 등에서도 작동합니다.</target>
        </trans-unit>
        <trans-unit id="0c2b133a65c34666134047443b875c3c6bf1823e" translate="yes" xml:space="preserve">
          <source>This module describes the digest APIs used in Phobos. All digests follow these APIs. Additionally, this module contains useful helper methods which can be used with every digest type.</source>
          <target state="translated">이 모듈은 Phobos에서 사용되는 다이제스트 API를 설명합니다. 모든 다이제스트는이 API를 따릅니다. 또한이 모듈에는 모든 다이제스트 유형에 사용할 수있는 유용한 도우미 메서드가 포함되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="9eac267b2bca3c4e62e74376d6d1858e8b30f305" translate="yes" xml:space="preserve">
          <source>This module extracts debug info from the currently running Mach-O executable.</source>
          <target state="translated">이 모듈은 현재 실행중인 Mach-O 실행 파일에서 디버그 정보를 추출합니다.</target>
        </trans-unit>
        <trans-unit id="2b3bde835b97011d3a24374bdd792ad0a067b596" translate="yes" xml:space="preserve">
          <source>This module has two submodules:</source>
          <target state="translated">이 모듈에는 두 개의 하위 모듈이 있습니다.</target>
        </trans-unit>
        <trans-unit id="c364d07bb94ddbade750564cb1b9de747e163c33" translate="yes" xml:space="preserve">
          <source>This module implements a &lt;a href=&quot;http://erdani.org/publications/cuj-04-2002.html&quot;&gt;discriminated union&lt;/a&gt; type (a.k.a. &lt;a href=&quot;http://en.wikipedia.org/wiki/Tagged_union&quot;&gt;tagged union&lt;/a&gt;, &lt;a href=&quot;http://en.wikipedia.org/wiki/Algebraic_data_type&quot;&gt;algebraic type&lt;/a&gt;). Such types are useful for type-uniform binary interfaces, interfacing with scripting languages, and comfortable exploratory programming.</source>
          <target state="translated">이 모듈은 &lt;a href=&quot;http://erdani.org/publications/cuj-04-2002.html&quot;&gt;구별 된 공용체&lt;/a&gt; 유형 (일명 &lt;a href=&quot;http://en.wikipedia.org/wiki/Tagged_union&quot;&gt;taged union&lt;/a&gt; , &lt;a href=&quot;http://en.wikipedia.org/wiki/Algebraic_data_type&quot;&gt;algebraic type&lt;/a&gt; )을 구현합니다. 이러한 유형은 유형 균일 이진 인터페이스, 스크립팅 언어와의 인터페이스 및 편안한 탐색 프로그래밍에 유용합니다.</target>
        </trans-unit>
        <trans-unit id="dcf874427a131dcde8af3f16bcfbe7028972cb86" translate="yes" xml:space="preserve">
          <source>This module implements a generic doubly-linked list container. It can be used as a queue, dequeue or stack.</source>
          <target state="translated">이 모듈은 일반적인 이중 연결 목록 컨테이너를 구현합니다. 대기열, 대기열 제거 또는 스택으로 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="276f012505f8a462f31b45a6f4a35457a2d35dbc" translate="yes" xml:space="preserve">
          <source>This module implements a red-black tree container.</source>
          <target state="translated">이 모듈은 레드-블랙 트리 컨테이너를 구현합니다.</target>
        </trans-unit>
        <trans-unit id="7870ea3fc10596df955abb619b60da2851a384ad" translate="yes" xml:space="preserve">
          <source>This module implements a singly-linked list container. It can be used as a stack.</source>
          <target state="translated">이 모듈은 단일 링크 목록 컨테이너를 구현합니다. 스택으로 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b8ec77e995992fa015630679195d60252ee43e89" translate="yes" xml:space="preserve">
          <source>This module implements a variety of type constructors, i.e., templates that allow construction of new, useful general-purpose types.</source>
          <target state="translated">이 모듈은 다양한 유형 생성자, 즉 새롭고 유용한 범용 유형을 생성 할 수있는 템플릿을 구현합니다.</target>
        </trans-unit>
        <trans-unit id="64f274b864d84b8337845eb1c9cfcbc24ac5038e" translate="yes" xml:space="preserve">
          <source>This module implements experimental additions/modifications to &lt;a href=&quot;std_typecons&quot;&gt;&lt;code&gt;std.typecons&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 모듈은 &lt;a href=&quot;std_typecons&quot;&gt; &lt;code&gt;std.typecons&lt;/code&gt; 에&lt;/a&gt; 실험 추가 / 수정을 구현 합니다.</target>
        </trans-unit>
        <trans-unit id="eaa4498639b5fb5cabef3038967389ce127f79a8" translate="yes" xml:space="preserve">
          <source>This module implements integral arithmetic primitives that check for out-of-range results.</source>
          <target state="translated">이 모듈은 범위를 벗어난 결과를 확인하는 필수 산술 프리미티브를 구현합니다.</target>
        </trans-unit>
        <trans-unit id="19bff9c3e2a27e1a7382004762c10f34a531050a" translate="yes" xml:space="preserve">
          <source>This module implements the formatting functionality for strings and I/O. It's comparable to C99's &lt;code&gt;vsprintf()&lt;/code&gt; and uses a similar format encoding scheme.</source>
          <target state="translated">이 모듈은 문자열 및 I / O의 형식화 기능을 구현합니다. C99의 &lt;code&gt;vsprintf()&lt;/code&gt; 와 비슷하며 유사한 형식의 인코딩 체계를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="c014fbea053ad61d3a5ae1fc743fb6c3131c1dfb" translate="yes" xml:space="preserve">
          <source>This module is a port of a growing fragment of the numeric header in Alexander Stepanov's &lt;a href=&quot;https://en.wikipedia.org/wiki/Standard_Template_Library&quot;&gt;Standard Template Library&lt;/a&gt;, with a few additions.</source>
          <target state="translated">이 모듈은 Alexander Stepanov의 &lt;a href=&quot;https://en.wikipedia.org/wiki/Standard_Template_Library&quot;&gt;표준 템플릿 라이브러리&lt;/a&gt; 에서 숫자 헤더의 일부가 증가하는 포트입니다 .</target>
        </trans-unit>
        <trans-unit id="186b66046159293951af2f7bf5b6d370eaa1c7f1" translate="yes" xml:space="preserve">
          <source>This module is a submodule of &lt;a href=&quot;std_container&quot;&gt;&lt;code&gt;std.container&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 모듈은 &lt;a href=&quot;std_container&quot;&gt; &lt;code&gt;std.container&lt;/code&gt; &lt;/a&gt; 의 하위 모듈입니다 .</target>
        </trans-unit>
        <trans-unit id="b888919ea96721208483544ffecc9a20b885369e" translate="yes" xml:space="preserve">
          <source>This module is a submodule of &lt;a href=&quot;std_range&quot;&gt;&lt;code&gt;std.range&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 모듈은 &lt;a href=&quot;std_range&quot;&gt; &lt;code&gt;std.range&lt;/code&gt; &lt;/a&gt; 의 하위 모듈입니다 .</target>
        </trans-unit>
        <trans-unit id="66276a22645692b59d3aafb558b5c8800653b392" translate="yes" xml:space="preserve">
          <source>This module is used to manipulate path strings.</source>
          <target state="translated">이 모듈은 경로 문자열을 조작하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="676c0f1d3f6966f52d6837dedf54ff7909b0c357" translate="yes" xml:space="preserve">
          <source>This module provides a &lt;code&gt;BinaryHeap&lt;/code&gt; (aka priority queue) adaptor that makes a binary heap out of any user-provided random-access range.</source>
          <target state="translated">이 모듈은 &lt;code&gt;BinaryHeap&lt;/code&gt; (일명 우선 순위 큐) 어댑터를 제공하여 사용자가 제공 한 임의 액세스 범위에서 2 진 힙을 만듭니다.</target>
        </trans-unit>
        <trans-unit id="71c4856d53f3e5b6efc2d0b1e712b1b6dc800220" translate="yes" xml:space="preserve">
          <source>This module provides a few predefined hooks (below) that add useful behavior to &lt;code&gt;Checked&lt;/code&gt;:</source>
          <target state="translated">이 모듈은 &lt;code&gt;Checked&lt;/code&gt; 에 유용한 동작을 추가하는 미리 정의 된 후크 (아래)를 제공합니다 .</target>
        </trans-unit>
        <trans-unit id="b737fcac62cfd177fb2788c39a8e794c75cf3e63" translate="yes" xml:space="preserve">
          <source>This module provides all kinds of functions to create, manipulate or convert arrays:</source>
          <target state="translated">이 모듈은 배열을 생성, 조작 또는 변환하는 모든 종류의 기능을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="744c3d7cd21f0164caf9f95d6fbb778bc3ca3903" translate="yes" xml:space="preserve">
          <source>This module provides an &lt;code&gt;Array&lt;/code&gt; type with deterministic memory usage not reliant on the GC, as an alternative to the built-in arrays.</source>
          <target state="translated">이 모듈은 내장 어레이의 대안으로 GC에 의존하지 않는 결정적인 메모리 사용량을 가진 &lt;code&gt;Array&lt;/code&gt; 유형을 제공 합니다.</target>
        </trans-unit>
        <trans-unit id="223a76451a573bc8bae5a7f8a3df3aee7f1c9bdf" translate="yes" xml:space="preserve">
          <source>This module provides an interface to the garbage collector used by applications written in the D programming language. It allows the garbage collector in the runtime to be swapped without affecting binary compatibility of applications.</source>
          <target state="translated">이 모듈은 D 프로그래밍 언어로 작성된 애플리케이션이 사용하는 가비지 콜렉터에 대한 인터페이스를 제공합니다. 응용 프로그램의 이진 호환성에 영향을 미치지 않으면 서 런타임의 가비지 수집기를 교체 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="45492b4e65c39718d334c504b40cf5ab9383e9f9" translate="yes" xml:space="preserve">
          <source>This module provides functions for compile time function composition. These functions are helpful when constructing predicates for the algorithms in &lt;a href=&quot;std_algorithm&quot;&gt;&lt;code&gt;std.algorithm&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;std_range&quot;&gt;&lt;code&gt;std.range&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 모듈은 컴파일 타임 함수 구성을위한 함수를 제공합니다. 이 함수는 &lt;a href=&quot;std_algorithm&quot;&gt; &lt;code&gt;std.algorithm&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;std_range&quot;&gt; &lt;code&gt;std.range&lt;/code&gt; &lt;/a&gt; 의 알고리즘에 대한 술어를 구성 할 때 유용 합니다.</target>
        </trans-unit>
        <trans-unit id="5d2a6ed25bc583d8e01cfa972338639c00d25698" translate="yes" xml:space="preserve">
          <source>This module provides two default implementations of Base64 encoding, &lt;a href=&quot;#Base64&quot;&gt;&lt;code&gt;Base64&lt;/code&gt;&lt;/a&gt; with a standard encoding alphabet, and a variant &lt;a href=&quot;#Base64URL&quot;&gt;&lt;code&gt;Base64URL&lt;/code&gt;&lt;/a&gt; that has a modified encoding alphabet designed to be safe for embedding in URLs and filenames.</source>
          <target state="translated">이 모듈은 Base64 인코딩의 두 가지 기본 구현 , 표준 인코딩 알파벳이있는 &lt;a href=&quot;#Base64&quot;&gt; &lt;code&gt;Base64&lt;/code&gt; &lt;/a&gt; 및 URL 및 파일 이름에 안전하게 포함되도록 설계된 수정 된 인코딩 알파벳이있는 변형 &lt;a href=&quot;#Base64URL&quot;&gt; &lt;code&gt;Base64URL&lt;/code&gt; &lt;/a&gt; 을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="14ea77a508973ad119aa38dedb9cc8889215b5e7" translate="yes" xml:space="preserve">
          <source>This module publicly imports &lt;a href=&quot;std_digest&quot;&gt;&lt;code&gt;std.digest&lt;/code&gt;&lt;/a&gt; and can be used as a stand-alone module.</source>
          <target state="translated">이 모듈은 &lt;a href=&quot;std_digest&quot;&gt; &lt;code&gt;std.digest&lt;/code&gt; 를&lt;/a&gt; 공개적으로 가져 오고 독립형 모듈로 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="821aad4a4d60f837d17e068e658c2b293af2fa2e" translate="yes" xml:space="preserve">
          <source>This module publicly imports &lt;code&gt;std.digest&lt;/code&gt; and can be used as a stand-alone module.</source>
          <target state="translated">이 모듈은 &lt;code&gt;std.digest&lt;/code&gt; 를 공개적으로 가져 오고 독립형 모듈로 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b024b98a208b935e325d89f7c0523c717e6fc717" translate="yes" xml:space="preserve">
          <source>This module tells the garbage collector about the static data and bss segments, so the GC can scan them for roots. It does not deal with thread local static data.</source>
          <target state="translated">이 모듈은 가비지 수집기에 정적 데이터 및 bss 세그먼트에 대해 알려주므로 GC가 루트를 검색 할 수 있습니다. 스레드 로컬 정적 데이터를 처리하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="463dc59b1d8043356600fc31e94afe8ce61592b7" translate="yes" xml:space="preserve">
          <source>This modules defines some utility functions for DMD.</source>
          <target state="translated">이 모듈은 DMD에 대한 일부 유틸리티 기능을 정의합니다.</target>
        </trans-unit>
        <trans-unit id="43097636fc7721cda69a3011b02706b476fb53a5" translate="yes" xml:space="preserve">
          <source>This modules defines the entry point (main) for DMD, as well as related utilities needed for arguments parsing, path manipulation, etc... This file is not shared with other compilers which use the DMD front-end.</source>
          <target state="translated">이 모듈은 DMD의 진입 점 (메인)과 인수 구문 분석, 경로 조작 등에 필요한 관련 유틸리티를 정의합니다.이 파일은 DMD 프런트 엔드를 사용하는 다른 컴파일러와 공유되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="8c5c0a58905cfb5b439b5201a82885c00dee51e2" translate="yes" xml:space="preserve">
          <source>This modules defines the help texts for the CLI options offered by DMD. This file is not shared with other compilers which use the DMD front-end. However, this file will be used to generate the &lt;a href=&quot;https://dlang.org/dmd-linux.html&quot;&gt;online documentation&lt;/a&gt; and MAN pages.</source>
          <target state="translated">이 모듈은 DMD가 제공하는 CLI 옵션에 대한 도움말 텍스트를 정의합니다. 이 파일은 DMD 프런트 엔드를 사용하는 다른 컴파일러와 공유되지 않습니다. 그러나이 파일은 &lt;a href=&quot;https://dlang.org/dmd-linux.html&quot;&gt;온라인 문서&lt;/a&gt; 및 MAN 페이지 를 생성하는 데 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="d366277495521395d02d0e8919a008889699c8b6" translate="yes" xml:space="preserve">
          <source>This modules implements the serialization of a lambda function. The serialization is computed by visiting the abstract syntax subtree of the given lambda function. The serialization is a string which contains the type of the parameters and the string represantation of the lambda expression.</source>
          <target state="translated">이 모듈은 람다 함수의 직렬화를 구현합니다. 직렬화는 주어진 람다 함수의 추상 구문 서브 트리를 방문하여 계산됩니다. 직렬화는 매개 변수의 유형과 람다 식의 문자열 표현을 포함하는 문자열입니다.</target>
        </trans-unit>
        <trans-unit id="4686239dc1c916453ca8175a0c8f0fd5b10fd0f8" translate="yes" xml:space="preserve">
          <source>This mostly means checking that the &lt;a href=&quot;http://www.digitalmars.com/rtl/stdio.html#printf&quot;&gt;printf format specifier&lt;/a&gt; matches the corresponding D data type. Although printf is designed to handle 0 terminated strings, not D dynamic arrays of chars, it turns out that since D dynamic arrays are a length followed by a pointer to the data, the &lt;code&gt;%.*s&lt;/code&gt; format works:</source>
          <target state="translated">이것은 대부분 &lt;a href=&quot;http://www.digitalmars.com/rtl/stdio.html#printf&quot;&gt;printf 형식 지정자가&lt;/a&gt; 해당 D 데이터 유형과 일치 하는지 확인하는 것을 의미 합니다. printf는 문자의 D 동적 배열이 아닌 0으로 끝나는 문자열을 처리하도록 설계되었지만 D 동적 배열의 길이와 데이터에 대한 포인터가 있기 때문에 &lt;code&gt;%.*s&lt;/code&gt; 형식이 작동합니다.</target>
        </trans-unit>
        <trans-unit id="d2a9ab8f340972eb23caaae774d32f80fccc2570" translate="yes" xml:space="preserve">
          <source>This must be called when a scheduled thread terminates. It tears down the messaging system for the thread and notifies interested parties of the thread's termination.</source>
          <target state="translated">예약 된 스레드가 종료 될 때 호출해야합니다. 스레드에 대한 메시징 시스템을 분리하고 관련 당사자에게 스레드 종료를 통지합니다.</target>
        </trans-unit>
        <trans-unit id="a87fd9a7f939391e41bf76be573f03fa79c258b5" translate="yes" xml:space="preserve">
          <source>This opcode is not supported by the assembler, instead use</source>
          <target state="translated">이 opcode는 어셈블러에서 지원하지 않으며 대신</target>
        </trans-unit>
        <trans-unit id="5080314419c68e07e9fbf46cb969bb8f7aec2b87" translate="yes" xml:space="preserve">
          <source>This overload converts a character input range to a &lt;code&gt;bool&lt;/code&gt;.</source>
          <target state="translated">이 과부하는 문자 입력 범위를 &lt;code&gt;bool&lt;/code&gt; 로 변환합니다 .</target>
        </trans-unit>
        <trans-unit id="d2f77cb81e183ee70aaac158a6010f060479e211" translate="yes" xml:space="preserve">
          <source>This overload of the digest function handles arrays.</source>
          <target state="translated">다이제스트 함수의이 오버로드는 배열을 처리합니다.</target>
        </trans-unit>
        <trans-unit id="5b5704e7eb61d0c1141594f127f54400ac726629" translate="yes" xml:space="preserve">
          <source>This overload of the hexDigest function handles arrays.</source>
          <target state="translated">hexDigest 함수의이 오버로드는 배열을 처리합니다.</target>
        </trans-unit>
        <trans-unit id="9b517602563a0a0437638b7de42771ba24220c9c" translate="yes" xml:space="preserve">
          <source>This override handles the following two cases: static foreach (i, i; [0]) { ... } and static foreach (i; [0]) { enum i = 2; }</source>
          <target state="translated">이 대체는 다음 두 가지 경우를 처리합니다. static foreach (i, i; [0]) {...} 및 정적 foreach (i; [0]) {enum i = 2; }</target>
        </trans-unit>
        <trans-unit id="4b5c72b79cb5cdac8aa14be60be09b9790cb2ce2" translate="yes" xml:space="preserve">
          <source>This package also implements untyped composable memory allocators. They are</source>
          <target state="translated">이 패키지는 형식화되지 않은 작성 가능한 메모리 할당자를 구현합니다. 그들은</target>
        </trans-unit>
        <trans-unit id="5b7998033b82c18a421be4c93bdff9f111ea8e70" translate="yes" xml:space="preserve">
          <source>This package implements generic algorithms oriented towards the processing of sequences. Sequences processed by these functions define range-based interfaces. See also &lt;a href=&quot;std_range&quot;&gt;Reference on ranges&lt;/a&gt; and &lt;a href=&quot;http://ddili.org/ders/d.en/ranges.html&quot;&gt;tutorial on ranges&lt;/a&gt;.</source>
          <target state="translated">이 패키지는 시퀀스 처리를위한 일반적인 알고리즘을 구현합니다. 이러한 기능으로 처리 된 시퀀스는 범위 기반 인터페이스를 정의합니다. 참조 &lt;a href=&quot;std_range&quot;&gt;범위에 참조&lt;/a&gt; 및 &lt;a href=&quot;http://ddili.org/ders/d.en/ranges.html&quot;&gt;범위에 튜토리얼&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="58c7d9c8a3cee8b3cf80c6b3b4132f86a95f5343" translate="yes" xml:space="preserve">
          <source>This package implements the hash-based message authentication code (HMAC) algorithm as defined in &lt;a href=&quot;http://tools.ietf.org/html/rfc2104&quot;&gt;RFC2104&lt;/a&gt;. See also the corresponding &lt;a href=&quot;http://en.wikipedia.org/wiki/Hash-based_message_authentication_code&quot;&gt;Wikipedia article&lt;/a&gt;.</source>
          <target state="translated">이 패키지는 &lt;a href=&quot;http://tools.ietf.org/html/rfc2104&quot;&gt;RFC2104에&lt;/a&gt; 정의 된 해시 기반 메시지 인증 코드 (HMAC) 알고리즘을 구현합니다 . 해당 &lt;a href=&quot;http://en.wikipedia.org/wiki/Hash-based_message_authentication_code&quot;&gt;Wikipedia 기사&lt;/a&gt; 도 참조 하십시오 .</target>
        </trans-unit>
        <trans-unit id="b54b15a9491f8b22812d70e97f6e30656fbe4637" translate="yes" xml:space="preserve">
          <source>This points to a linked list of headers, struct curl_slist kind</source>
          <target state="translated">이것은 연결된 헤더 목록, 구조체 curl_slist 종류를 가리 킵니다.</target>
        </trans-unit>
        <trans-unit id="4fa3e3f63776b5b0936a2fb2bebc42c79d485368" translate="yes" xml:space="preserve">
          <source>This points to a linked list of post entries, struct curl_httppost</source>
          <target state="translated">이것은 struct curl_httppost에 연결된 게시물 항목 목록을 가리 킵니다.</target>
        </trans-unit>
        <trans-unit id="4709ade7923d0d8282a3479562e2dbd3f6142a8c" translate="yes" xml:space="preserve">
          <source>This points to a linked list of telnet options</source>
          <target state="translated">이것은 텔넷 옵션의 링크 된 목록을 가리 킵니다.</target>
        </trans-unit>
        <trans-unit id="62f59d77929e72a8f25d40e635e0a3a32957778c" translate="yes" xml:space="preserve">
          <source>This predicate must be an equivalence relation, that is, it must be reflexive (&lt;code&gt;pred(x,x)&lt;/code&gt; is always true), symmetric (&lt;code&gt;pred(x,y) == pred(y,x)&lt;/code&gt;), and transitive (&lt;code&gt;pred(x,y) &amp;amp;&amp;amp; pred(y,z)&lt;/code&gt; implies &lt;code&gt;pred(x,z)&lt;/code&gt;). If this is not the case, the range returned by chunkBy may assert at runtime or behave erratically.</source>
          <target state="translated">이 술어는 동등성 관계 여야합니다. 즉, 반사적 ( &lt;code&gt;pred(x,x)&lt;/code&gt; 는 항상 참), 대칭 ( &lt;code&gt;pred(x,y) == pred(y,x)&lt;/code&gt; ) 및 전 이적 ( &lt;code&gt;pred(x,y) &amp;amp;&amp;amp; pred(y,z)&lt;/code&gt; &lt;code&gt;pred(x,z)&lt;/code&gt; 의미 합니다. 그렇지 않은 경우, chunkBy가 리턴 한 범위는 런타임에 어설 션되거나 잘못 작동 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0a267b44ef886d9c8baf429e8671183b625c8796" translate="yes" xml:space="preserve">
          <source>This program reads standard in and writes it to standard out, pretty-printing any found D mangled names.</source>
          <target state="translated">이 프로그램은 표준 입력을 읽고 표준 출력에 기록하여 발견 된 D 맹 글링 된 이름을 예쁘게 인쇄합니다.</target>
        </trans-unit>
        <trans-unit id="afdb5e2e48fdacd7a6c8694592ad8b718667d89f" translate="yes" xml:space="preserve">
          <source>This property is overridden because the local time of the system could change while the program is running and we need to determine it dynamically rather than it being fixed like it would be with most time zones.</source>
          <target state="translated">이 속성은 프로그램이 실행되는 동안 시스템의 현지 시간이 변경 될 수 있으므로 대부분의 표준 시간대와 같이 고정되지 않고 동적으로 결정해야하므로 재정의됩니다.</target>
        </trans-unit>
        <trans-unit id="6d74dd10b5c800dca0bea3aabcacb84d776dbed7" translate="yes" xml:space="preserve">
          <source>This property sets and gets the default &lt;code&gt;Logger&lt;/code&gt;.</source>
          <target state="translated">이 속성은 기본 &lt;code&gt;Logger&lt;/code&gt; 설정하고 가져옵니다 .</target>
        </trans-unit>
        <trans-unit id="233904e9ff09001991edcef153035ddd2dc72e31" translate="yes" xml:space="preserve">
          <source>This property should not be used, but is supported for legacy purposes.</source>
          <target state="translated">이 속성은 사용하지 않아야하지만 레거시 목적으로 지원됩니다.</target>
        </trans-unit>
        <trans-unit id="0c0985b965d550bee9a97d40f84d906e5dd41300" translate="yes" xml:space="preserve">
          <source>This prototype applies to all conversion callbacks</source>
          <target state="translated">이 프로토 타입은 모든 전환 콜백에 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="362936247c39185758bfe185928298d458cd1898" translate="yes" xml:space="preserve">
          <source>This provides a transition from the non-promoting behavior of unary + - ~ to the C-like integral promotion behavior.</source>
          <target state="translated">이는 단항 +-~의 비 촉진 동작에서 C와 같은 통합 승격 동작으로의 전환을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="42fdb37f7871dd64abfac735f6f1948def69313b" translate="yes" xml:space="preserve">
          <source>This provides a way to add functions to a class externally as if they were public final member functions, which enables &lt;a href=&quot;http://www.drdobbs.com/architecture-and-design/component-programming-in-d/240008321&quot;&gt; function chaining and component programming&lt;/a&gt;.</source>
          <target state="translated">이것은 &lt;a href=&quot;http://www.drdobbs.com/architecture-and-design/component-programming-in-d/240008321&quot;&gt;함수형 체인과 컴포넌트 프로그래밍&lt;/a&gt; 을 가능하게하는 퍼블릭 최종 멤버 함수 인 것처럼 외부에 클래스에 함수를 추가하는 방법을 제공합니다 .</target>
        </trans-unit>
        <trans-unit id="b5e3135a675f967dd5c5470ea386f16d7ad31f41" translate="yes" xml:space="preserve">
          <source>This range iterates over fixed-sized chunks of size &lt;code&gt;chunkSize&lt;/code&gt; of a &lt;code&gt;source&lt;/code&gt; range. &lt;code&gt;Source&lt;/code&gt; must be an &lt;a href=&quot;std_range_primitives#isInputRange&quot;&gt;input range&lt;/a&gt;. &lt;code&gt;chunkSize&lt;/code&gt; must be greater than zero.</source>
          <target state="translated">이 범위 는 &lt;code&gt;source&lt;/code&gt; 범위의 &lt;code&gt;chunkSize&lt;/code&gt; 크기의 고정 크기 청크에 대해 반복 됩니다. &lt;code&gt;Source&lt;/code&gt; 는 &lt;a href=&quot;std_range_primitives#isInputRange&quot;&gt;입력 범위&lt;/a&gt; 여야합니다 . &lt;code&gt;chunkSize&lt;/code&gt; 는 0보다 커야합니다.</target>
        </trans-unit>
        <trans-unit id="ffdad1d5b9cd516ba877128f5377fd43732ba01e" translate="yes" xml:space="preserve">
          <source>This range splits a &lt;code&gt;source&lt;/code&gt; range into &lt;code&gt;chunkCount&lt;/code&gt; chunks of approximately equal length. &lt;code&gt;Source&lt;/code&gt; must be a forward range with known length.</source>
          <target state="translated">이 범위는 &lt;code&gt;source&lt;/code&gt; 범위를 대략 동일한 길이의 &lt;code&gt;chunkCount&lt;/code&gt; 청크 로 나눕니다 . &lt;code&gt;Source&lt;/code&gt; 는 길이가 알려진 포워드 범위 여야합니다.</target>
        </trans-unit>
        <trans-unit id="99784cdd841b29b6c6c458a6a98700cdba67e67d" translate="yes" xml:space="preserve">
          <source>This range will be a &lt;a href=&quot;std_range_primitives#isForwardRange&quot;&gt;forward range&lt;/a&gt; if the underlying data source is at least a forward range.</source>
          <target state="translated">이 범위는 것이다 &lt;a href=&quot;std_range_primitives#isForwardRange&quot;&gt;전방 영역&lt;/a&gt; 내부 데이터 소스는 적어도 전진 레인지이면.</target>
        </trans-unit>
        <trans-unit id="87508ea3111ce555c431f5b202f7db1e58a43a32" translate="yes" xml:space="preserve">
          <source>This range will receive elements of &lt;code&gt;inputRange&lt;/code&gt; progressively as iteration proceeds.</source>
          <target state="translated">이 범위는 반복이 진행됨에 따라 &lt;code&gt;inputRange&lt;/code&gt; 의 요소를 점진적으로 수신합니다 .</target>
        </trans-unit>
        <trans-unit id="76aba1f55c69e82481c98e4e2c1338584cc1691e" translate="yes" xml:space="preserve">
          <source>This represents the category of &lt;code&gt;Throwable&lt;/code&gt; objects that are &lt;b&gt;not&lt;/b&gt; safe to catch and handle. In principle, one should not catch Error objects, as they represent unrecoverable runtime errors. Certain runtime guarantees may fail to hold when these errors are thrown, making it unsafe to continue execution after catching them.</source>
          <target state="translated">이것은 잡거나 다루기가 안전 &lt;b&gt;하지 않은 &lt;/b&gt; &lt;code&gt;Throwable&lt;/code&gt; 객체 의 범주를 나타냅니다 . 원칙적으로 오류 개체는 복구 할 수없는 런타임 오류를 나타내므로 오류 개체를 잡아서는 안됩니다. 이러한 오류가 발생하면 특정 런타임 보증이 유지되지 않아 오류를 발견 한 후에도 계속 실행하는 것이 안전하지 않을 수 있습니다.&lt;b&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="f5f588659c6a58c1ddf047b3a2039449d9c56d1c" translate="yes" xml:space="preserve">
          <source>This returns the evaluation value of performance as the ratio of baseFunc's time over targetFunc's time. If performance is high, this returns a high value.</source>
          <target state="translated">targetFunc 시간에 대한 baseFunc 시간의 비율로 성능 평가 값을 리턴합니다. 성능이 높으면 높은 값을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="f6949b897dc88b2038c4de24c6845ff78a726d87" translate="yes" xml:space="preserve">
          <source>This routine allows the runtime to process any special per-thread handling for the GC. This is needed for taking into account any memory that is referenced by non-scanned pointers but is about to be freed. That currently means the array append cache.</source>
          <target state="translated">이 루틴을 통해 런타임은 GC에 대한 스레드 별 처리를 처리 할 수 ​​있습니다. 이것은 스캔되지 않은 포인터가 참조하지만 해제하려고하는 메모리를 고려하기 위해 필요합니다. 이는 현재 어레이 추가 캐시를 의미합니다.</target>
        </trans-unit>
        <trans-unit id="08f408a77465437e08636b8afacc3919eb737cd7" translate="yes" xml:space="preserve">
          <source>This routine does not run thread-local static constructors when called. If full functionality as a D thread is desired, the following function must be called after thread_attachThis:</source>
          <target state="translated">이 루틴은 호출 될 때 스레드 로컬 정적 생성자를 실행하지 않습니다. D 스레드로서의 모든 기능이 필요한 경우 thread_attachThis 다음에 다음 함수를 호출해야합니다.</target>
        </trans-unit>
        <trans-unit id="29f29aed6bb63f2bb71ea82e3247723ea06a2ff1" translate="yes" xml:space="preserve">
          <source>This routine does not run thread-local static destructors when called. If full functionality as a D thread is desired, the following function must be called after thread_detachThis, particularly if the thread is being detached at some indeterminate time before program termination:</source>
          <target state="translated">이 루틴은 호출 될 때 스레드 로컬 정적 소멸자를 실행하지 않습니다. D 스레드로서의 완전한 기능이 필요한 경우, thread_detach 후에 다음 함수를 호출해야합니다. 특히 프로그램 종료 전에 특정 시간에 스레드가 분리되는 경우 :</target>
        </trans-unit>
        <trans-unit id="e2210ae223e7d7387e02e70f648478605beed923" translate="yes" xml:space="preserve">
          <source>This routine does not run thread-local static destructors when called. If full functionality as a D thread is desired, the following function must be called by the detached thread, particularly if the thread is being detached at some indeterminate time before program termination:</source>
          <target state="translated">이 루틴은 호출 될 때 스레드 로컬 정적 소멸자를 실행하지 않습니다. D 스레드로서의 완전한 기능이 필요한 경우, 특히 프로그램 종료 전에 특정 시간이 지나서 스레드가 분리되는 경우 분리 된 스레드가 다음 기능을 호출해야합니다.</target>
        </trans-unit>
        <trans-unit id="47826c4895a3860e96fcff125901760f36d390ea" translate="yes" xml:space="preserve">
          <source>This routine is called at various points within concurrency-aware APIs to provide a scheduler a chance to yield execution when using some sort of cooperative multithreading model. If this is not appropriate, such as when each logical thread is backed by a dedicated kernel thread, this routine may be a no-op.</source>
          <target state="translated">이 루틴은 동시성 인식 API 내의 다양한 지점에서 호출되어 스케줄러가 일종의 협력 멀티 스레딩 모델을 사용할 때 실행을 생성 할 수있는 기회를 제공합니다. 각 논리 스레드가 전용 커널 스레드에 의해 백업되는 경우와 같이 이것이 적절하지 않은 경우이 루틴은 작동하지 않을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="09474f394a8e3b0e692c20bd617ea5e90dedaeea" translate="yes" xml:space="preserve">
          <source>This routine is called by spawn. It is expected to instantiate a new logical thread and run the supplied operation. This thread must call thisInfo.cleanup() when the thread terminates if the scheduled thread is not a kernel thread--all kernel threads will have their ThreadInfo cleaned up automatically by a thread-local destructor.</source>
          <target state="translated">이 루틴은 스폰에 의해 호출됩니다. 새로운 논리 스레드를 인스턴스화하고 제공된 조작을 실행해야합니다. 예약 된 스레드가 커널 스레드가 아닌 경우 스레드가 종료되면이 스레드는 thisInfo.cleanup ()을 호출해야합니다. 모든 커널 스레드는 스레드 로컬 소멸자에 의해 ThreadInfo가 자동으로 정리됩니다.</target>
        </trans-unit>
        <trans-unit id="df7600e8a5ce5c3ece105f6eb175adf2b4921aaa" translate="yes" xml:space="preserve">
          <source>This routine is called by the runtime to run module unit tests on startup. The user-supplied unit tester will be called if one has been set, otherwise all unit tests will be run in sequence.</source>
          <target state="translated">이 루틴은 시작시 모듈 단위 테스트를 실행하기 위해 런타임에 의해 호출됩니다. 사용자 제공 장치 테스터가 설정되어 있으면 호출됩니다. 그렇지 않으면 모든 장치 테스트가 순서대로 실행됩니다.</target>
        </trans-unit>
        <trans-unit id="f8232f4d22c940d991cfdba88d087083634996f9" translate="yes" xml:space="preserve">
          <source>This routine may only be called once per thread instance.</source>
          <target state="translated">이 루틴은 스레드 인스턴스 당 한 번만 호출 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5878411090cc704550555efc36dc55fc7cf0dd39" translate="yes" xml:space="preserve">
          <source>This routine must be called just prior to resuming all threads.</source>
          <target state="translated">이 루틴은 모든 스레드를 재개하기 직전에 호출되어야합니다.</target>
        </trans-unit>
        <trans-unit id="53cb6dbac5dae389abe55edf28bc4109aaf707d5" translate="yes" xml:space="preserve">
          <source>This routine must be preceded by a call to thread_suspendAll.</source>
          <target state="translated">이 루틴 앞에 thread_suspendAll을 호출해야합니다.</target>
        </trans-unit>
        <trans-unit id="cb9fbb3e9cb5f0e9bf7804e870b0289aa3f2cc00" translate="yes" xml:space="preserve">
          <source>This rule precludes any associative or commutative reordering of floating point expressions.</source>
          <target state="translated">이 규칙은 부동 소수점 식의 연관 또는 정식 순서를 배제합니다.</target>
        </trans-unit>
        <trans-unit id="a889c8b355f9d26b9d8f09416cc5c638f19cc1bc" translate="yes" xml:space="preserve">
          <source>This scheduler does no explicit multiplexing, so this is a no-op.</source>
          <target state="translated">이 스케줄러는 명시적인 멀티플렉싱을 수행하지 않으므로 이는 작동하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="101357cb2b96f04e1249bc15480608aae10e36fd" translate="yes" xml:space="preserve">
          <source>This scheme recognises the following names: &quot;ANSI_X3.4-1968&quot;, &quot;ANSI_X3.4-1986&quot;, &quot;ASCII&quot;, &quot;IBM367&quot;, &quot;ISO646-US&quot;, &quot;ISO_646.irv:1991&quot;, &quot;US-ASCII&quot;, &quot;cp367&quot;, &quot;csASCII&quot; &quot;iso-ir-6&quot;, &quot;us&quot;</source>
          <target state="translated">이 체계는 &quot;ANSI_X3.4-1968&quot;, &quot;ANSI_X3.4-1986&quot;, &quot;ASCII&quot;, &quot;IBM367&quot;, &quot;ISO646-US&quot;, &quot;ISO_646.irv : 1991&quot;, &quot;US-ASCII&quot;이름을 인식합니다. , &quot;cp367&quot;, &quot;csASCII&quot; &quot;iso-ir-6&quot;, &quot;us&quot;</target>
        </trans-unit>
        <trans-unit id="f19febfbd6afd5a3316429731972510fc66c030b" translate="yes" xml:space="preserve">
          <source>This scheme recognises the following names: &quot;CP819&quot;, &quot;IBM819&quot;, &quot;ISO-8859-1&quot;, &quot;ISO_8859-1&quot;, &quot;ISO_8859-1:1987&quot;, &quot;csISOLatin1&quot;, &quot;iso-ir-100&quot;, &quot;l1&quot;, &quot;latin1&quot;</source>
          <target state="translated">이 체계는 다음 이름을 인식합니다. &quot;CP819&quot;, &quot;IBM819&quot;, &quot;ISO-8859-1&quot;, &quot;ISO_8859-1&quot;, &quot;ISO_8859-1 : 1987&quot;, &quot;csISOLatin1&quot;, &quot;iso-ir-100&quot;, &quot; l1 &quot;,&quot;latin1 &quot;</target>
        </trans-unit>
        <trans-unit id="664030e2fd624069f198afd088ac055c78bd6022" translate="yes" xml:space="preserve">
          <source>This scheme recognises the following names: &quot;Latin 2&quot;, &quot;ISO-8859-2&quot;, &quot;ISO_8859-2&quot;, &quot;ISO_8859-2:1999&quot;, &quot;Windows-28592&quot;</source>
          <target state="translated">이 체계는 &quot;라틴어 2&quot;, &quot;ISO-8859-2&quot;, &quot;ISO_8859-2&quot;, &quot;ISO_8859-2 : 1999&quot;, &quot;Windows-28592&quot;라는 이름을 인식합니다.</target>
        </trans-unit>
        <trans-unit id="ade669f4e0479a561d644cf792664ebe8c58b7f3" translate="yes" xml:space="preserve">
          <source>This scheme recognises the following names: &quot;UTF-16LE&quot; (little-endian architecture only) &quot;UTF-16BE&quot; (big-endian architecture only)</source>
          <target state="translated">이 체계는 다음 이름을 인식합니다. &quot;UTF-16LE&quot;(little-endian 아키텍처 만) &quot;UTF-16BE&quot;(big-endian 아키텍처 만)</target>
        </trans-unit>
        <trans-unit id="270ab7b02be7a6bde21e8c3a620aecc09d063e99" translate="yes" xml:space="preserve">
          <source>This scheme recognises the following names: &quot;UTF-32LE&quot; (little-endian architecture only) &quot;UTF-32BE&quot; (big-endian architecture only)</source>
          <target state="translated">이 체계는 다음 이름을 인식합니다. &quot;UTF-32LE&quot;(little-endian 아키텍처 만) &quot;UTF-32BE&quot;(big-endian 아키텍처 만)</target>
        </trans-unit>
        <trans-unit id="bced95f493391cc0c075fc9dc4db4804161c397b" translate="yes" xml:space="preserve">
          <source>This scheme recognises the following names: &quot;UTF-8&quot;</source>
          <target state="translated">이 체계는 다음 이름을 인식합니다. &quot;UTF-8&quot;</target>
        </trans-unit>
        <trans-unit id="c947e47deb508176a3928ec96e6e69a35c074c39" translate="yes" xml:space="preserve">
          <source>This scheme recognises the following names: &quot;windows-1250&quot;</source>
          <target state="translated">이 체계는 다음 이름을 인식합니다. &quot;windows-1250&quot;</target>
        </trans-unit>
        <trans-unit id="a3402a215c1529c61ece58d5fce0d4798222c23b" translate="yes" xml:space="preserve">
          <source>This scheme recognises the following names: &quot;windows-1251&quot;</source>
          <target state="translated">이 체계는 다음 이름을 인식합니다. &quot;windows-1251&quot;</target>
        </trans-unit>
        <trans-unit id="ded1d5e22b73a1f4af6cf6f2d1b37c6532f710c1" translate="yes" xml:space="preserve">
          <source>This scheme recognises the following names: &quot;windows-1252&quot;</source>
          <target state="translated">이 체계는 다음 이름을 인식합니다. &quot;windows-1252&quot;</target>
        </trans-unit>
        <trans-unit id="d2dfa0f433df9d45239ecc782eb245fb19fd21d2" translate="yes" xml:space="preserve">
          <source>This seed function gives 2^w starting points (the lowest w bits of the value provided will be used). To allow the RNG to be started in any one of its internal states use the seed overload taking an InputRange.</source>
          <target state="translated">이 시드 함수는 2 ^ w 시작점을 제공합니다 (제공된 값의 가장 낮은 w 비트가 사용됨). 내부 상태 중 하나에서 RNG를 시작하려면 InputRange를 사용하는 시드 과부하를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="94a54cee12f5bd9b51532e5452c5a4a484e54378" translate="yes" xml:space="preserve">
          <source>This sets the current source line number to &lt;a href=&quot;#IntegerLiteral&quot;&gt;&lt;i&gt;IntegerLiteral&lt;/i&gt;&lt;/a&gt;, and optionally the current source file name to &lt;a href=&quot;#Filespec&quot;&gt;&lt;i&gt;Filespec&lt;/i&gt;&lt;/a&gt;, beginning with the next line of source text.</source>
          <target state="translated">이렇게하면 현재 소스 행 번호가 &lt;a href=&quot;#IntegerLiteral&quot;&gt;&lt;i&gt;IntegerLiteral&lt;/i&gt;&lt;/a&gt; 로 설정되고 선택적으로 현재 소스 파일 이름 이 다음 소스 텍스트 행부터 시작 하여 &lt;a href=&quot;#Filespec&quot;&gt;&lt;i&gt;Filespec로 설정&lt;/i&gt;&lt;/a&gt; 됩니다.</target>
        </trans-unit>
        <trans-unit id="4be50da9e108662a57689b8ace75d7581f5375c8" translate="yes" xml:space="preserve">
          <source>This should be used to avoid dead-locks when the init expression waits for the result of another thread that might also call initOnce. Use with care.</source>
          <target state="translated">이것은 init 표현식이 initOnce를 호출 할 수있는 다른 스레드의 결과를 기다릴 때 교착 상태를 피하기 위해 사용해야합니다. 주의해서 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="fe2d190a50345872c262cf5d3029bd911309ce44" translate="yes" xml:space="preserve">
          <source>This simply runs op directly, since no real scheduling is needed by this approach.</source>
          <target state="translated">이 접근법에는 실제 스케줄링이 필요하지 않기 때문에 이것은 직접 op를 실행합니다.</target>
        </trans-unit>
        <trans-unit id="c1f36fea04df939005e7ae3b3481769a9d3881d4" translate="yes" xml:space="preserve">
          <source>This software is distributed on an &quot;AS IS&quot; basis, WITHOUT WARRANTY OF ANY KIND, either express or implied.</source>
          <target state="translated">이 소프트웨어는 명시 적이든 묵시적이든 어떠한 종류의 보증없이 &quot;현상태대로&quot;배포됩니다.</target>
        </trans-unit>
        <trans-unit id="cce69bf7cc8f89b41a07f3aa1ac572a9417bd871" translate="yes" xml:space="preserve">
          <source>This software is licensed as described in the file COPYING, which you should have received as part of this distribution. The terms are also available at &lt;a href=&quot;http://curl.haxx.se/docs/copyright.html&quot;&gt;http://curl.haxx.se/docs/copyright.html&lt;/a&gt;.</source>
          <target state="translated">이 소프트웨어는 COPYING 파일에 설명 된대로 라이센스가 부여되며이 배포판의 일부로 받아야합니다. 이 용어는 &lt;a href=&quot;http://curl.haxx.se/docs/copyright.html&quot;&gt;http://curl.haxx.se/docs/copyright.html&lt;/a&gt; 에서도 볼 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="5a35b5b2fcea0cd5e1372a50fcdb64c90186c1d8" translate="yes" xml:space="preserve">
          <source>This string mixin generator allows one to create tagged class reference inside structs and classes.</source>
          <target state="translated">이 문자열 믹스 인 생성기를 사용하면 구조체와 클래스 내에 태그가 지정된 클래스 참조를 만들 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="89b88529e193e34ffae54fa1436ac384d8a51298" translate="yes" xml:space="preserve">
          <source>This string mixin generator allows one to create tagged pointers inside structs and classes.</source>
          <target state="translated">이 문자열 믹스 인 생성기를 사용하면 구조체와 클래스 내에 태그가 지정된 포인터를 만들 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="fa44f8a37539dd0c481f757fd2c6c916db973189" translate="yes" xml:space="preserve">
          <source>This struct encapsulates all functionality related to the underlying runtime module for the calling context.</source>
          <target state="translated">이 구조체는 호출 컨텍스트에 대한 기본 런타임 모듈과 관련된 모든 기능을 캡슐화합니다.</target>
        </trans-unit>
        <trans-unit id="93192c346919e8c29838bf372e377e45a2bf11e8" translate="yes" xml:space="preserve">
          <source>This struct encapsulates all garbage collection functionality for the D programming language.</source>
          <target state="translated">이 구조체는 D 프로그래밍 언어에 대한 모든 가비지 수집 기능을 캡슐화합니다.</target>
        </trans-unit>
        <trans-unit id="c0b4243b7a8d23b55f18ae71ce114f500fc9e037" translate="yes" xml:space="preserve">
          <source>This struct is needed for TemplateInstance to be the key in an associative array. Fixing &lt;a href=&quot;https://issues.dlang.org/show_bug.cgi?id=15812&quot;&gt;https://issues.dlang.org/show_bug.cgi?id=15812&lt;/a&gt; and &lt;a href=&quot;https://issues.dlang.org/show_bug.cgi?id=15813&quot;&gt;https://issues.dlang.org/show_bug.cgi?id=15813&lt;/a&gt; would make it unnecessary.</source>
          <target state="translated">이 구조체는 TemplateInstance가 연관 배열의 키가되기 위해 필요합니다. 고정 &lt;a href=&quot;https://issues.dlang.org/show_bug.cgi?id=15812&quot;&gt;https://issues.dlang.org/show_bug.cgi?id=15812&lt;/a&gt; 및 &lt;a href=&quot;https://issues.dlang.org/show_bug.cgi?id=15813&quot;&gt;https://issues.dlang.org/show_bug.cgi?id=15813하는 것은&lt;/a&gt; 불필요한 만들 것입니다.</target>
        </trans-unit>
        <trans-unit id="ba71ab789db33d9d41fe31ac671b08fc2ff9a27c" translate="yes" xml:space="preserve">
          <source>This struct is not intended to be created in user code directly; use the &lt;a href=&quot;#decoder&quot;&gt;&lt;code&gt;decoder&lt;/code&gt;&lt;/a&gt; function instead.</source>
          <target state="translated">이 구조체는 사용자 코드에서 직접 작성하기위한 것이 아닙니다. 사용 &lt;a href=&quot;#decoder&quot;&gt; &lt;code&gt;decoder&lt;/code&gt; &lt;/a&gt; 대신 기능.</target>
        </trans-unit>
        <trans-unit id="c808480f164a9ce60af47373128f270ece2f4c37" translate="yes" xml:space="preserve">
          <source>This struct is not intended to be created in user code directly; use the &lt;a href=&quot;#encoder&quot;&gt;&lt;code&gt;encoder&lt;/code&gt;&lt;/a&gt; function instead.</source>
          <target state="translated">이 구조체는 사용자 코드에서 직접 작성하기위한 것이 아닙니다. 사용 &lt;a href=&quot;#encoder&quot;&gt; &lt;code&gt;encoder&lt;/code&gt; &lt;/a&gt; 대신 기능을.</target>
        </trans-unit>
        <trans-unit id="bf5472fdbac439d01e7f55c549978ae9fe484216" translate="yes" xml:space="preserve">
          <source>This struct takes two ranges, &lt;code&gt;source&lt;/code&gt; and &lt;code&gt;indices&lt;/code&gt;, and creates a view of &lt;code&gt;source&lt;/code&gt; as if its elements were reordered according to &lt;code&gt;indices&lt;/code&gt;. &lt;code&gt;indices&lt;/code&gt; may include only a subset of the elements of &lt;code&gt;source&lt;/code&gt; and may also repeat elements.</source>
          <target state="translated">이 구조체는 &lt;code&gt;source&lt;/code&gt; 와 &lt;code&gt;indices&lt;/code&gt; 두 가지 범위를 취 하며 요소가 &lt;code&gt;indices&lt;/code&gt; 에 따라 재정렬 된 것처럼 &lt;code&gt;source&lt;/code&gt; 의 뷰를 만듭니다 . &lt;code&gt;indices&lt;/code&gt; 는 &lt;code&gt;source&lt;/code&gt; 요소의 서브 세트만을 포함 할 수 있고 또한 요소를 반복 할 수있다.</target>
        </trans-unit>
        <trans-unit id="321a83cb6c2189fda5f0740151e0077549cc346c" translate="yes" xml:space="preserve">
          <source>This struct uses interior pointers for callbacks. Only allocate it on the stack if you never move or copy it. This also means passing by reference when passing Curl to other functions. Otherwise always allocate on the heap.</source>
          <target state="translated">이 구조체는 콜백에 내부 포인터를 사용합니다. 이동하거나 복사하지 않은 경우에만 스택에 할당하십시오. 이것은 Curl을 다른 함수에 전달할 때 참조로 전달하는 것을 의미합니다. 그렇지 않으면 항상 힙에 할당하십시오.</target>
        </trans-unit>
        <trans-unit id="9b4fde43b38a0e50f9025a0370a796c10515fd4f" translate="yes" xml:space="preserve">
          <source>This template defines a simple struct to represent bitwise OR combinations of enum values. It can be used if all the enum values are integral constants with a bit count of at most 1, or if the &lt;code&gt;unsafe&lt;/code&gt; parameter is explicitly set to Yes. This is much safer than using the enum itself to store the OR combination, which can produce surprising effects like this:</source>
          <target state="translated">이 템플릿은 열거 형 값의 비트 단위 OR 조합을 나타내는 간단한 구조체를 정의합니다. 모든 열거 형 값이 비트 수가 최대 1 인 정수이거나, &lt;code&gt;unsafe&lt;/code&gt; 매개 변수가 Yes로 명시 적으로 설정된 경우 사용할 수 있습니다. 이것은 OR 조합을 저장하기 위해 열거 형 자체를 사용하는 것보다 훨씬 안전하며 다음과 같은 놀라운 효과를 얻을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ed7a16b135cb8df8ef4a3a540a84c393a96223c7" translate="yes" xml:space="preserve">
          <source>This template evaluates if the passed &lt;code&gt;LogLevel&lt;/code&gt; is active. The previously described version statements are used to decide if the &lt;code&gt;LogLevel&lt;/code&gt; is active. The version statements only influence the compile unit they are used with, therefore this function can only disable logging this specific compile unit.</source>
          <target state="translated">이 템플릿은 전달 된 &lt;code&gt;LogLevel&lt;/code&gt; 이 활성화되어 있는지 평가합니다 . 앞에서 설명한 버전 설명을 사용하여 &lt;code&gt;LogLevel&lt;/code&gt; 의 활성화 여부를 결정합니다 . 버전 설명은 사용되는 컴파일 단위에만 영향을 미치므로이 함수는이 특정 컴파일 단위의 로깅 만 비활성화 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="bf1947986c71233faa898611680a1e6ac855b2d0" translate="yes" xml:space="preserve">
          <source>This template is used instead of &lt;code&gt;cmpTimeUnits&lt;/code&gt; because exceptions can't be thrown at compile time and &lt;code&gt;cmpTimeUnits&lt;/code&gt; must enforce that the strings it's given are valid time unit strings. This template uses a template constraint instead.</source>
          <target state="translated">이 템플릿은 &lt;code&gt;cmpTimeUnits&lt;/code&gt; 대신 사용 되며 컴파일 타임에 예외를 throw 할 수 없으며 &lt;code&gt;cmpTimeUnits&lt;/code&gt; 는 제공된 문자열이 유효한 시간 단위 문자열이되도록 강제해야합니다. 이 템플릿은 템플릿 제약 조건을 대신 사용합니다.</target>
        </trans-unit>
        <trans-unit id="721049b2d1b7c17de4953e979423c5d9509ce4dc" translate="yes" xml:space="preserve">
          <source>This template provides the global &lt;code&gt;printf&lt;/code&gt;-style log functions with the &lt;code&gt;LogLevel&lt;/code&gt; is encoded in the function name.</source>
          <target state="translated">이 템플리트는 전역 &lt;code&gt;printf&lt;/code&gt; 스타일 로그 기능에 &lt;code&gt;LogLevel&lt;/code&gt; 이 기능 이름으로 인코딩되어 제공합니다.</target>
        </trans-unit>
        <trans-unit id="95faefdf67a9c230f11cf5997976bb55047f6e84" translate="yes" xml:space="preserve">
          <source>This template provides the global log functions with the &lt;code&gt;LogLevel&lt;/code&gt; is encoded in the function name.</source>
          <target state="translated">이 템플리트는 로그 &lt;code&gt;LogLevel&lt;/code&gt; 이 함수 이름으로 인코딩 된 글로벌 로그 기능을 제공합니다 .</target>
        </trans-unit>
        <trans-unit id="a660b19c7d186bc39b4f6c265fe64cdd5e100bb7" translate="yes" xml:space="preserve">
          <source>This template provides the log functions for the &lt;code&gt;Logger&lt;/code&gt;&lt;code&gt;class&lt;/code&gt; with the &lt;code&gt;LogLevel&lt;/code&gt; encoded in the function name.</source>
          <target state="translated">이 템플릿은의 로그 기능을 제공 &lt;code&gt;Logger&lt;/code&gt; &lt;code&gt;class&lt;/code&gt; 와 &lt;code&gt;LogLevel&lt;/code&gt; 에 함수 이름으로 인코딩.</target>
        </trans-unit>
        <trans-unit id="649dff2094ef00bc31b9858d34965ac9fc9b644e" translate="yes" xml:space="preserve">
          <source>This template returns the &lt;code&gt;LogLevel&lt;/code&gt; named &quot;logLevel&quot; of type &lt;code&gt;LogLevel&lt;/code&gt; defined in a user defined module where the filename has the suffix &quot;loggerconfig.d&quot;. This &lt;code&gt;LogLevel&lt;/code&gt; sets the minimal &lt;code&gt;LogLevel&lt;/code&gt; of the module.</source>
          <target state="translated">이 템플릿은 파일 이름에 접미사가 &quot;loggerconfig.d&quot;인 사용자 정의 모듈에 정의 된 &lt;code&gt;LogLevel&lt;/code&gt; 유형의 &quot;logLevel&quot;이라는 &lt;code&gt;LogLevel&lt;/code&gt; 을 반환합니다 . 이 &lt;code&gt;LogLevel&lt;/code&gt; 은 모듈 의 최소 &lt;code&gt;LogLevel&lt;/code&gt; 을 설정합니다 .</target>
        </trans-unit>
        <trans-unit id="965d72a63b18d413b5715e4a973525a9b52a396c" translate="yes" xml:space="preserve">
          <source>This time zone's offset from UTC with west of UTC being negative (it is added to UTC to get the adjusted time).</source>
          <target state="translated">UTC의 서쪽이 음수 인 UTC에서이 시간대의 오프셋입니다 (조정 된 시간을 얻기 위해 UTC에 추가됨).</target>
        </trans-unit>
        <trans-unit id="b7456f76fa17160c9c0587cc7d1c50d1dbf69825" translate="yes" xml:space="preserve">
          <source>This type is only used by the interpreter.</source>
          <target state="translated">이 유형은 인터프리터 만 사용합니다.</target>
        </trans-unit>
        <trans-unit id="bfaad68c51bc3ac5b55f9911a6ad3e337bcd2001" translate="yes" xml:space="preserve">
          <source>This type is returned by the module unit test handler to indicate testing results.</source>
          <target state="translated">이 유형은 테스트 결과를 나타 내기 위해 모듈 장치 테스트 핸들러에 의해 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="fe05b2c35b150ac51e9c5a58b58b8bdf4deb8005" translate="yes" xml:space="preserve">
          <source>This uniformly outdents the text as much as possible. Whitespace-only lines are always converted to blank lines.</source>
          <target state="translated">이것은 가능한 한 텍스트를 균일하게 능가합니다. 공백 전용 줄은 항상 빈 줄로 변환됩니다.</target>
        </trans-unit>
        <trans-unit id="1b0c762aaeeda93028fb7042712ade026276dad3" translate="yes" xml:space="preserve">
          <source>This unittest verifies that &lt;code&gt;myFunc&lt;/code&gt; contains only &lt;code&gt;@safe&lt;/code&gt;, &lt;code&gt;nothrow&lt;/code&gt; code. Although this can also be accomplished by attaching these attributes to &lt;code&gt;myFunc&lt;/code&gt; itself, that would prevent &lt;code&gt;myFunc&lt;/code&gt; from being instantiated with types &lt;code&gt;T&lt;/code&gt; that have &lt;code&gt;@system&lt;/code&gt; or throwing code in their &lt;code&gt;opAssign&lt;/code&gt; method, or other methods that &lt;code&gt;myFunc&lt;/code&gt; may call. The above idiom allows &lt;code&gt;myFunc&lt;/code&gt; to be instantiated with such types, yet at the same time verify that the &lt;code&gt;@system&lt;/code&gt; and throwing behavior is not introduced by the code within &lt;code&gt;myFunc&lt;/code&gt; itself.</source>
          <target state="translated">이 unittest는 &lt;code&gt;myFunc&lt;/code&gt; 에 &lt;code&gt;@safe&lt;/code&gt; , &lt;code&gt;nothrow&lt;/code&gt; 코드 만 포함되어 있는지 확인합니다 . 이러한 속성을 &lt;code&gt;myFunc&lt;/code&gt; 자체 에 첨부하여이 작업을 수행 할 수도 있지만 , 이는 &lt;code&gt;myFunc&lt;/code&gt; 가 &lt;code&gt;@system&lt;/code&gt; 이 있거나 유형 이 &lt;code&gt;opAssign&lt;/code&gt; 메소드 또는 &lt;code&gt;myFunc&lt;/code&gt; 가 호출 할 수있는 다른 메소드에 코드를 던지는 &lt;code&gt;T&lt;/code&gt; 유형으로 인스턴스화 되지 못하게 합니다. 위의 관용구는 &lt;code&gt;myFunc&lt;/code&gt; 를 이러한 유형으로 인스턴스화 할 수 있지만 동시에 &lt;code&gt;@system&lt;/code&gt; 및 throw 동작이 &lt;code&gt;myFunc&lt;/code&gt; 자체 의 코드에 의해 도입되지 않았 는지 확인하십시오 .</target>
        </trans-unit>
        <trans-unit id="6d997c4734cfeb63e2eb24775621ef1b07f282bd" translate="yes" xml:space="preserve">
          <source>This used to be in druntime, but contained a reference to Dmain which didn't work when druntime was made into a dll and was linked to a program, such as a C++ program, that didn't have a Dmain.</source>
          <target state="translated">이것은 druntime에 있었지만 drun에 대한 참조가 포함되어 있는데 druntime이 dll로 만들어 졌을 때 작동하지 않았으며 Dmain이없는 C ++ 프로그램과 같은 프로그램에 연결되었습니다.</target>
        </trans-unit>
        <trans-unit id="630760402237caac7d04f49e204e2dbcf15d6147" translate="yes" xml:space="preserve">
          <source>This uses the underlying C calls to adjust the time rather than using specific D code based off of system settings to calculate the time such as &lt;a href=&quot;#PosixTimeZone&quot;&gt;&lt;code&gt;PosixTimeZone&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#WindowsTimeZone&quot;&gt;&lt;code&gt;WindowsTimeZone&lt;/code&gt;&lt;/a&gt; do. That also means that it will use whatever the current time zone is on the system, even if the system's time zone changes while the program is running.</source>
          <target state="translated">&lt;a href=&quot;#PosixTimeZone&quot;&gt; &lt;code&gt;PosixTimeZone&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#WindowsTimeZone&quot;&gt; &lt;code&gt;WindowsTimeZone&lt;/code&gt; &lt;/a&gt; 과 같은 시간을 계산하기 위해 시스템 설정에 따라 특정 D 코드를 사용하는 대신 기본 C 호출을 사용하여 시간을 조정합니다 . 즉, 프로그램이 실행되는 동안 시스템 시간대가 변경 되더라도 현재 시간대가 시스템에있는 모든 것을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="222ffc2d96135317dcd7f4e64432ee48d6b47aca" translate="yes" xml:space="preserve">
          <source>This variable sets the Scheduler behavior within this program. Typically, when setting a Scheduler, scheduler.start() should be called in main. This routine will not return until program execution is complete.</source>
          <target state="translated">이 변수는이 프로그램 내에서 스케줄러 동작을 설정합니다. 일반적으로 스케줄러를 설정할 때 main에서 scheduler.start ()를 호출해야합니다. 이 루틴은 프로그램 실행이 완료 될 때까지 반환되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="350617ff126e41fac846ab28e60173b84f0e36ad" translate="yes" xml:space="preserve">
          <source>This version does a merge even if the deco is already computed. Necessary for types that have a deco, but are not merged.</source>
          <target state="translated">이 버전은 데코가 이미 계산 된 경우에도 병합을 수행합니다. 데코는 있지만 병합되지 않은 유형에 필요합니다.</target>
        </trans-unit>
        <trans-unit id="ca9704bfd218246a881b4d0fdbb145b4f7ed6074" translate="yes" xml:space="preserve">
          <source>This version manages its own read buffer, which means one memory allocation per call. If you are not retaining a reference to the read data, consider the &lt;code&gt;File.readln(buf)&lt;/code&gt; version, which may offer better performance as it can reuse its read buffer.</source>
          <target state="translated">이 버전은 자체 읽기 버퍼를 관리합니다. 이는 호출 당 하나의 메모리 할당을 의미합니다. 읽기 데이터에 대한 참조를 유지하지 않는 경우 &lt;code&gt;File.readln(buf)&lt;/code&gt; 버전을 고려하십시오.이 버전은 읽기 버퍼를 재사용 할 수 있으므로 성능이 향상 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4730e8481a2bf9923ca7e3e571c62d109e3d3d83" translate="yes" xml:space="preserve">
          <source>This version manages its own read buffer, which means one memory allocation per call. If you are not retaining a reference to the read data, consider the &lt;code&gt;readln(buf)&lt;/code&gt; version, which may offer better performance as it can reuse its read buffer.</source>
          <target state="translated">이 버전은 자체 읽기 버퍼를 관리합니다. 이는 호출 당 하나의 메모리 할당을 의미합니다. 읽기 데이터에 대한 참조를 유지하지 않는 경우 &lt;code&gt;readln(buf)&lt;/code&gt; 버전을 고려하십시오.이 버전은 읽기 버퍼를 재사용 할 수 있으므로 더 나은 성능을 제공 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5d0ffd1140b6bdea2f557dabf439528af74c3f10" translate="yes" xml:space="preserve">
          <source>This version replaces all of the matches found in &lt;code&gt;input&lt;/code&gt;, see &lt;a href=&quot;#replaceFirst&quot;&gt;&lt;code&gt;replaceFirst&lt;/code&gt;&lt;/a&gt; to replace the first match only.</source>
          <target state="translated">이 버전은 &lt;code&gt;input&lt;/code&gt; 에있는 모든 일치 항목을 대체합니다. 첫 번째 일치 항목 만 바꾸려면 &lt;a href=&quot;#replaceFirst&quot;&gt; &lt;code&gt;replaceFirst&lt;/code&gt; &lt;/a&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="58e4144e8bfe93d9e0c64e9b4fdfd2a6a17871d2" translate="yes" xml:space="preserve">
          <source>This version replaces the first match in &lt;code&gt;input&lt;/code&gt;, see &lt;a href=&quot;#replaceAll&quot;&gt;&lt;code&gt;replaceAll&lt;/code&gt;&lt;/a&gt; to replace the all of the matches.</source>
          <target state="translated">이 버전은 &lt;code&gt;input&lt;/code&gt; 의 첫 번째 일치 항목 을 대체합니다. 모든 일치 &lt;a href=&quot;#replaceAll&quot;&gt; &lt;code&gt;replaceAll&lt;/code&gt; &lt;/a&gt; 을 바꾸려면 replaceAll 을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="ff770a07d7fe1b2d8549b2bfe1914ce344e62c1a" translate="yes" xml:space="preserve">
          <source>This way negative spans until 10, then positive until 50, then negative until 60, then positive until 61, and so on. As seen this provides a space-efficient storage of highly redundant data that comes in long runs. A description which Unicode &lt;a href=&quot;#Character&quot;&gt;character&lt;/a&gt; properties fit nicely. The technique itself could be seen as a variation on &lt;a href=&quot;https://en.wikipedia.org/wiki/Run-length_encoding&quot;&gt;RLE encoding&lt;/a&gt;.</source>
          <target state="translated">이 방법으로 음수는 10까지, 그 다음은 50까지, 음수는 60, 양수는 61까지입니다. 보시다시피 이것은 장기적으로 제공되는 고효율 데이터의 공간 효율적인 스토리지를 제공합니다. 유니 코드 &lt;a href=&quot;#Character&quot;&gt;문자&lt;/a&gt; 속성에 잘 맞는 설명입니다 . 이 기술 자체는 &lt;a href=&quot;https://en.wikipedia.org/wiki/Run-length_encoding&quot;&gt;RLE 인코딩&lt;/a&gt; 의 변형으로 볼 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="9d7e80d5423ced31332c30ecab9af5e8333da350" translate="yes" xml:space="preserve">
          <source>This will print a message to the &lt;code&gt;stderr&lt;/code&gt; device. The message will contain the filename, the line number, the name of the surrounding function, the time and the message.  More complex log call can go along the lines like:</source>
          <target state="translated">&lt;code&gt;stderr&lt;/code&gt; 장치에 메시지가 인쇄 됩니다. 메시지에는 파일 이름, 줄 번호, 주변 기능 이름, 시간 및 메시지가 포함됩니다. 보다 복잡한 로그 호출은 다음과 같은 행을 따라 갈 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7bbc11a96caae26edcdd1170876c310429d5242c" translate="yes" xml:space="preserve">
          <source>This wrapper function documents commitment on the part of the caller that the appropriate steps have been taken to avoid whatever conditions may trigger an exception during the evaluation of &lt;code&gt;expr&lt;/code&gt;. If it turns out that the expression</source>
          <target state="translated">이 랩퍼 함수는 호출자 측에서 &lt;code&gt;expr&lt;/code&gt; 평가 중에 예외를 유발할 수있는 조건을 피하기 위해 적절한 단계를 수행했음을 확약합니다 . 그 표현이 밝혀지면</target>
        </trans-unit>
        <trans-unit id="e1c33135ff86972a6ed3b9c446ccc19496208487" translate="yes" xml:space="preserve">
          <source>Though any arbitrary D code is allowed in the &lt;code&gt;in&lt;/code&gt; and &lt;code&gt;out&lt;/code&gt; contract blocks, their only function should be to verify incoming and outgoing data. It is important to ensure that the code has no side effects, and that the release version of the code will not depend on any effects of the code. For a release build of the code, &lt;code&gt;in&lt;/code&gt; and &lt;code&gt;out&lt;/code&gt; contracts are not inserted.</source>
          <target state="translated">임의 D 코드가 허용되지만 &lt;code&gt;in&lt;/code&gt; 와 &lt;code&gt;out&lt;/code&gt; 계약 블록 유일한 기능은 수신 및 송신 데이터를 확인해야한다. 코드에 부작용이없고 코드의 릴리스 버전이 코드의 영향에 의존하지 않도록하는 것이 중요합니다. 코드의 릴리스 빌드를 들어, &lt;code&gt;in&lt;/code&gt; 와 &lt;code&gt;out&lt;/code&gt; 계약은 삽입되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="820043383b2d6abecf10763532e4c82a66d9247e" translate="yes" xml:space="preserve">
          <source>Thread &lt;code&gt;t&lt;/code&gt;</source>
          <target state="translated">나사산 &lt;code&gt;t&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="04c6d1513db9ed02d67521add8386801a5b34539" translate="yes" xml:space="preserve">
          <source>Thread &lt;strong id=&quot;thread_attachThis&quot;&gt;thread_attachThis&lt;/strong&gt;();</source>
          <target state="translated">스레드 &lt;strong id=&quot;thread_attachThis&quot;&gt;thread_attachThis&lt;/strong&gt; ();</target>
        </trans-unit>
        <trans-unit id="1f330e4c64cef67c5a0e2c92e690f07993e4d060" translate="yes" xml:space="preserve">
          <source>Thread Local Redirection</source>
          <target state="translated">스레드 로컬 리디렉션</target>
        </trans-unit>
        <trans-unit id="84f19dfef7c6980d5ce82fb1aaa5685b925bb278" translate="yes" xml:space="preserve">
          <source>Thread creation and management.</source>
          <target state="translated">스레드 생성 및 관리</target>
        </trans-unit>
        <trans-unit id="35ec6af76df19383c52b8f66c7369b7f13dd32d0" translate="yes" xml:space="preserve">
          <source>ThreadError if the resume operation fails for a running thread.</source>
          <target state="translated">실행중인 스레드에 대해 재개 작업이 실패하면 ThreadError</target>
        </trans-unit>
        <trans-unit id="9e4b42c8be29f1c6cbd83e3ca1f8a1f5acbf80c3" translate="yes" xml:space="preserve">
          <source>ThreadError if the suspend operation fails for a running thread.</source>
          <target state="translated">실행중인 스레드에 대해 일시 중단 작업이 실패하면 ThreadError</target>
        </trans-unit>
        <trans-unit id="2464c0788d3d18de94ad9135c7e0e048ee525f11" translate="yes" xml:space="preserve">
          <source>ThreadException if the operation fails. Any exception not handled by the joined thread.</source>
          <target state="translated">작업이 실패하면 ThreadException이 발생합니다. 결합 된 스레드가 처리하지 않는 예외</target>
        </trans-unit>
        <trans-unit id="988c5cc71109eafcf99c8ab21fce21fe97ec770d" translate="yes" xml:space="preserve">
          <source>ThreadException if the thread fails to start.</source>
          <target state="translated">ThreadException 스레드가 시작되지 않는 경우</target>
        </trans-unit>
        <trans-unit id="1cf40193fb824b4f6ad8cb26327d035d6a028786" translate="yes" xml:space="preserve">
          <source>ThreadID &lt;code&gt;addr&lt;/code&gt;</source>
          <target state="translated">ThreadID &lt;code&gt;addr&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="f7ed723eeac4df5e125f2b0678ab67abc0922b8b" translate="yes" xml:space="preserve">
          <source>ThreadID &lt;code&gt;tid&lt;/code&gt;</source>
          <target state="translated">ThreadID &lt;code&gt;tid&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="1f726da94b243f6df0f10d0a1927ff4f089c0ce2" translate="yes" xml:space="preserve">
          <source>Three Valued Logic on Wikipedia</source>
          <target state="translated">위키 백과의 3 가지 논리</target>
        </trans-unit>
        <trans-unit id="041271075c6e4b6b2987479db37b359cf95b9df5" translate="yes" xml:space="preserve">
          <source>Throw Statement</source>
          <target state="translated">던지기 진술</target>
        </trans-unit>
        <trans-unit id="a99ee7b003bda4ab0516b744e02d6d8979581b73" translate="yes" xml:space="preserve">
          <source>Throw a D object.</source>
          <target state="translated">D 객체를 던집니다.</target>
        </trans-unit>
        <trans-unit id="811a07f7fa5dfaadc18e11fed4ce882015f391d7" translate="yes" xml:space="preserve">
          <source>Throw a MailboxFull exception.</source>
          <target state="translated">MailboxFull 예외를 발생시킵니다.</target>
        </trans-unit>
        <trans-unit id="57315ab12c3532377a724ba12831fde623b6e79a" translate="yes" xml:space="preserve">
          <source>ThrowOnError &lt;code&gt;throwOnError&lt;/code&gt;</source>
          <target state="translated">ThrowOnError &lt;code&gt;throwOnError&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="8abf11297f412ee4fff55514bb434f634e293565" translate="yes" xml:space="preserve">
          <source>Throwable</source>
          <target state="translated">Throwable</target>
        </trans-unit>
        <trans-unit id="d49a4962de645ce124e96bde4ce448c93911dad9" translate="yes" xml:space="preserve">
          <source>Throwable &lt;code&gt;e1&lt;/code&gt;</source>
          <target state="translated">던질 수있는 &lt;code&gt;e1&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="8bea49f69b95bd4c7986b53182b30e586c968d01" translate="yes" xml:space="preserve">
          <source>Throwable &lt;code&gt;e2&lt;/code&gt;</source>
          <target state="translated">던질 수있는 &lt;code&gt;e2&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="c3508159ea74e593b1f8f83bb63c996e12b6d4b0" translate="yes" xml:space="preserve">
          <source>Throwable &lt;code&gt;e&lt;/code&gt;</source>
          <target state="translated">던질 수있는 &lt;code&gt;e&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="181dadb1ebd21977fc70a4734b2c296e2903f089" translate="yes" xml:space="preserve">
          <source>Throwable &lt;code&gt;ex&lt;/code&gt;</source>
          <target state="translated">던질 수있는 &lt;code&gt;ex&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="4bd2954e71e7cefaff13ce8e463c354cbaac4f4d" translate="yes" xml:space="preserve">
          <source>Throwable &lt;code&gt;next&lt;/code&gt;</source>
          <target state="translated">던질 수있는 &lt;code&gt;next&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="7daca6bf6d530d9a8e0dd28e96710df7d9ed3bc1" translate="yes" xml:space="preserve">
          <source>Throwable &lt;code&gt;o&lt;/code&gt;</source>
          <target state="translated">던질 수있는 &lt;code&gt;o&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="5722462feb7ab62b6beb25519312de887c65befc" translate="yes" xml:space="preserve">
          <source>Throwable &lt;code&gt;t&lt;/code&gt;</source>
          <target state="translated">던질 수있는 &lt;code&gt;t&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="d3bf36d01f399602316eb8550fa8ea67915755f2" translate="yes" xml:space="preserve">
          <source>Throwable &lt;strong id=&quot;__dmd_begin_catch&quot;&gt;__dmd_begin_catch&lt;/strong&gt;(_Unwind_Exception* exceptionObject);</source>
          <target state="translated">Throwable를 &lt;strong id=&quot;__dmd_begin_catch&quot;&gt;__dmd_begin_catch&lt;/strong&gt; (_Unwind_Exception exceptionObject *);</target>
        </trans-unit>
        <trans-unit id="ad43afcb02ba70a606fef1b16e48cd558c53facc" translate="yes" xml:space="preserve">
          <source>Throwable &lt;strong id=&quot;_d_newThrowable&quot;&gt;_d_newThrowable&lt;/strong&gt;(const TypeInfo_Class ci);</source>
          <target state="translated">Throwable &lt;strong id=&quot;_d_newThrowable&quot;&gt;_d_newThrowable&lt;/strong&gt; (const TypeInfo_Class ci);</target>
        </trans-unit>
        <trans-unit id="8b0b716c6a4da9650ea963345d9f03fa5190cefb" translate="yes" xml:space="preserve">
          <source>Throwable &lt;strong id=&quot;bypassedException&quot;&gt;bypassedException&lt;/strong&gt;;</source>
          <target state="translated">Throwable &lt;strong id=&quot;bypassedException&quot;&gt;bypassedException&lt;/strong&gt; ;</target>
        </trans-unit>
        <trans-unit id="aeb265277be0ed46b320d4bee447dd1287a5e503" translate="yes" xml:space="preserve">
          <source>Throwable that is at the start of the chain; null if both &lt;code&gt;e1&lt;/code&gt; and &lt;code&gt;e2&lt;/code&gt; are null</source>
          <target state="translated">체인의 시작 부분에있는 던질 수있는 것; &lt;code&gt;e1&lt;/code&gt; 과 &lt;code&gt;e2&lt;/code&gt; 가 모두 null 인 경우 null</target>
        </trans-unit>
        <trans-unit id="329a88fde5ec9ba12b2a662751a9fce532d8dd80" translate="yes" xml:space="preserve">
          <source>Throwable.TraceInfo &lt;strong id=&quot;_d_traceContext&quot;&gt;_d_traceContext&lt;/strong&gt;(void* ptr = null);</source>
          <target state="translated">Throwable.TraceInfo &lt;strong id=&quot;_d_traceContext&quot;&gt;_d_traceContext&lt;/strong&gt; (void * ptr = null);</target>
        </trans-unit>
        <trans-unit id="d96037e204c51c808042650da8a6d05d2f5c0fd2" translate="yes" xml:space="preserve">
          <source>Throwable.TraceInfo &lt;strong id=&quot;defaultTraceHandler&quot;&gt;defaultTraceHandler&lt;/strong&gt;(void* ptr = null);</source>
          <target state="translated">Throwable.TraceInfo &lt;strong id=&quot;defaultTraceHandler&quot;&gt;defaultTraceHandler&lt;/strong&gt; (void * ptr = null);</target>
        </trans-unit>
        <trans-unit id="b63ae3eec5f24e1fd1c64ed1289ae0f818654562" translate="yes" xml:space="preserve">
          <source>Thrown during CData constructor</source>
          <target state="translated">CData 생성자 중에 발생</target>
        </trans-unit>
        <trans-unit id="84c89a52cbdc1ec28b439af4dc893b9b91ec7840" translate="yes" xml:space="preserve">
          <source>Thrown during Comment constructor</source>
          <target state="translated">주석 생성자 중에 발생</target>
        </trans-unit>
        <trans-unit id="35729b43847e49168c803e1563bb3cc31ad4a437" translate="yes" xml:space="preserve">
          <source>Thrown during ProcessingInstruction constructor</source>
          <target state="translated">ProcessingInstruction 생성자 중에 발생</target>
        </trans-unit>
        <trans-unit id="3f251cad502f4c0805742ab01450a6da94826b64" translate="yes" xml:space="preserve">
          <source>Thrown during Text constructor</source>
          <target state="translated">텍스트 생성자 중에 발생</target>
        </trans-unit>
        <trans-unit id="c92a5bfc11a555b169a0a27ab74990b80319893a" translate="yes" xml:space="preserve">
          <source>Thrown during XMLInstruction constructor</source>
          <target state="translated">XMLInstruction 생성자 중에 발생</target>
        </trans-unit>
        <trans-unit id="6bb5956cc1d8626088d792baf8b347e8b18e899c" translate="yes" xml:space="preserve">
          <source>Thrown during check()</source>
          <target state="translated">check () 중에 발생</target>
        </trans-unit>
        <trans-unit id="86110bc7ee50ca60178c35406ca162fd7743b4e8" translate="yes" xml:space="preserve">
          <source>Thrown during decode()</source>
          <target state="translated">디코드 () 중에 발생</target>
        </trans-unit>
        <trans-unit id="c5aba430c55d417364422428a9f362472f91604b" translate="yes" xml:space="preserve">
          <source>Thrown if I/O errors happen.</source>
          <target state="translated">I / O 오류가 발생하면 발생합니다.</target>
        </trans-unit>
        <trans-unit id="6372ea6ded1ced271f30bfc67bb4f1080dda6330" translate="yes" xml:space="preserve">
          <source>Thrown if a linked thread has terminated.</source>
          <target state="translated">연결된 스레드가 종료 된 경우 발생합니다.</target>
        </trans-unit>
        <trans-unit id="91f2c1021f927e931dd4a9bfa5d4cb0938ead33e" translate="yes" xml:space="preserve">
          <source>Thrown if a message was sent to a thread via &lt;a href=&quot;std_concurrency#prioritySend&quot;&gt;&lt;code&gt;std.concurrency.prioritySend&lt;/code&gt;&lt;/a&gt; and the receiver does not have a handler for a message of this type.</source>
          <target state="translated">메시지가 &lt;a href=&quot;std_concurrency#prioritySend&quot;&gt; &lt;code&gt;std.concurrency.prioritySend&lt;/code&gt; &lt;/a&gt; 를 통해 스레드로 전송되었고 수신자에게이 유형의 메시지에 대한 핸들러가없는 경우 발생합니다.</target>
        </trans-unit>
        <trans-unit id="6ae8d47d33d71e65b4335fb509b682ebfeb58c62" translate="yes" xml:space="preserve">
          <source>Thrown if comparing with wrong type</source>
          <target state="translated">잘못된 타입과 비교하면 발생</target>
        </trans-unit>
        <trans-unit id="7cf0300c5ba15c42524d147daa6bffbdb893c34b" translate="yes" xml:space="preserve">
          <source>Thrown if errors that set &lt;a href=&quot;http://msdn.microsoft.com/en-us/library/windows/desktop/ms679360.aspx&quot;&gt; &lt;code&gt;GetLastError&lt;/code&gt;&lt;/a&gt; occur.</source>
          <target state="translated">&lt;a href=&quot;http://msdn.microsoft.com/en-us/library/windows/desktop/ms679360.aspx&quot;&gt; &lt;code&gt;GetLastError&lt;/code&gt; &lt;/a&gt; 를 설정하는 오류가 발생하면 발생합니다.</target>
        </trans-unit>
        <trans-unit id="be91161c0d8489393a798c2ad672cda178b1f826" translate="yes" xml:space="preserve">
          <source>Thrown if errors that set &lt;code&gt;errno&lt;/code&gt; occur.</source>
          <target state="translated">&lt;code&gt;errno&lt;/code&gt; 를 설정하는 오류가 발생하면 발생합니다.</target>
        </trans-unit>
        <trans-unit id="d5a85f8afbd62c38c087ce3656815cdc461fe61e" translate="yes" xml:space="preserve">
          <source>Thrown in three cases:</source>
          <target state="translated">세 가지 경우에 발생합니다 :</target>
        </trans-unit>
        <trans-unit id="a1a94163addf8ed9aeb98b45ad38a50ceb43b8d6" translate="yes" xml:space="preserve">
          <source>Thrown objects derived from</source>
          <target state="translated">에서 파생 된 객체</target>
        </trans-unit>
        <trans-unit id="1b617604610b1e1a6d54699cece22c41ffbacef5" translate="yes" xml:space="preserve">
          <source>Thrown on a range error.</source>
          <target state="translated">범위 오류가 발생했습니다.</target>
        </trans-unit>
        <trans-unit id="b565d21ffa55aff8807f89b443feb9fd6f91d085" translate="yes" xml:space="preserve">
          <source>Thrown on a switch error.</source>
          <target state="translated">스위치 오류가 발생했습니다.</target>
        </trans-unit>
        <trans-unit id="e2a9b6920e3c3f67cbd3cb688ecd5615035c5221" translate="yes" xml:space="preserve">
          <source>Thrown on a unicode conversion error.</source>
          <target state="translated">유니 코드 변환 오류에서 발생합니다.</target>
        </trans-unit>
        <trans-unit id="7dea37b71e3f163a1d2f5bf641ee7dc124d30397" translate="yes" xml:space="preserve">
          <source>Thrown on an assert error.</source>
          <target state="translated">assert 오류가 발생했습니다.</target>
        </trans-unit>
        <trans-unit id="86c6bfd21c61151f3be7775d602fc143c1a57943" translate="yes" xml:space="preserve">
          <source>Thrown on an invalid memory operation.</source>
          <target state="translated">유효하지 않은 메모리 작업에서 발생했습니다.</target>
        </trans-unit>
        <trans-unit id="16e3cf208858e40592c9d2d38ed8e64cdeeb978f" translate="yes" xml:space="preserve">
          <source>Thrown on an out of memory error.</source>
          <target state="translated">메모리 부족 오류가 발생했습니다.</target>
        </trans-unit>
        <trans-unit id="3d00baaee4bcf2f35b15a207e7685eb27dac105f" translate="yes" xml:space="preserve">
          <source>Thrown on calls to &lt;code&gt;receive&lt;/code&gt; if the thread that spawned the receiving thread has terminated and no more messages exist.</source>
          <target state="translated">&lt;code&gt;receive&lt;/code&gt; 스레드를 생성 한 스레드가 종료되고 더 이상 메시지가없는 경우 수신 호출을 처리합니다.</target>
        </trans-unit>
        <trans-unit id="2324a54efe11d589ff8d54fcc1b56a073a6a5882" translate="yes" xml:space="preserve">
          <source>Thrown on calls to &lt;code&gt;receiveOnly&lt;/code&gt; if a message other than the type the receiving thread expected is sent.</source>
          <target state="translated">수신 스레드가 예상 한 유형 이외의 메시지가 전송 된 경우 &lt;code&gt;receiveOnly&lt;/code&gt; 에 대한 호출에서 발생 합니다.</target>
        </trans-unit>
        <trans-unit id="3129f3e1668dc67a58429ffa0cef7d5a14bcbb14" translate="yes" xml:space="preserve">
          <source>Thrown on conversion errors.</source>
          <target state="translated">변환 오류가 발생했습니다.</target>
        </trans-unit>
        <trans-unit id="29878d6640bc6d1eaad971922e0aa1d911c88d3a" translate="yes" xml:space="preserve">
          <source>Thrown on conversion overflow errors.</source>
          <target state="translated">변환 오버플로 오류가 발생했습니다.</target>
        </trans-unit>
        <trans-unit id="5b47b72e06e1d04f8e2399d1acfde860c151b623" translate="yes" xml:space="preserve">
          <source>Thrown on error.</source>
          <target state="translated">오류가 발생했습니다.</target>
        </trans-unit>
        <trans-unit id="a4752cf51c73b5b3850abf244753cdd8e6632e42" translate="yes" xml:space="preserve">
          <source>Thrown on finalize error.</source>
          <target state="translated">종료 오류가 발생했습니다.</target>
        </trans-unit>
        <trans-unit id="36d88aa95deaa8eb68ccf7623cd01071911543b5" translate="yes" xml:space="preserve">
          <source>Thrown on mailbox crowding if the mailbox is configured with &lt;code&gt;OnCrowding.throwException&lt;/code&gt;.</source>
          <target state="translated">사서함이 &lt;code&gt;OnCrowding.throwException&lt;/code&gt; 으로 구성된 경우 사서함 혼잡시 발생합니다 .</target>
        </trans-unit>
        <trans-unit id="79b810076b73721a41a2673482bdf7baf7ec2c8a" translate="yes" xml:space="preserve">
          <source>Thrown on one of the following conditions:</source>
          <target state="translated">다음 조건 중 하나에 발생합니다.</target>
        </trans-unit>
        <trans-unit id="5ab114d73446a9ce4d36fd9f522df3a1eebc6c65" translate="yes" xml:space="preserve">
          <source>Thrown when a Tid is missing, e.g. when &lt;code&gt;ownerTid&lt;/code&gt; doesn't find an owner thread.</source>
          <target state="translated">예를 들어 &lt;code&gt;ownerTid&lt;/code&gt; 가 소유자 스레드를 찾지 못한 경우 Tid가 누락 된 경우 발생 합니다.</target>
        </trans-unit>
        <trans-unit id="1e6ce338b7ac50ade34d3b28700ff70b8d4a7605" translate="yes" xml:space="preserve">
          <source>Thrown when parsing for Tags</source>
          <target state="translated">태그를 구문 분석 할 때 발생합니다.</target>
        </trans-unit>
        <trans-unit id="f3f52f3792a4bcc4f042510f3988510a62c2449d" translate="yes" xml:space="preserve">
          <source>Throws an exception.</source>
          <target state="translated">예외가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="9c1b3e348c5e658c9f04296e21ad3e2315006119" translate="yes" xml:space="preserve">
          <source>Throws:</source>
          <target state="translated">Throws:</target>
        </trans-unit>
        <trans-unit id="ff6fea9d058e3c0f1cc7f0adf3f77f4b9520cb7a" translate="yes" xml:space="preserve">
          <source>Thunks adjust the incoming 'this' pointer by 'offset'.</source>
          <target state="translated">썽 크는 들어오는 'this'포인터를 'offset'으로 조정합니다.</target>
        </trans-unit>
        <trans-unit id="681bc8d0be931a268296c48f3f9e40f73e12b3a8" translate="yes" xml:space="preserve">
          <source>Thus, a static array always has the dimension statically available as part of the type, and so it is implemented like in C. Static arrays and Dynamic arrays can be easily converted back and forth to each other.</source>
          <target state="translated">따라서 정적 배열은 항상 차원의 일부로 정적으로 사용 가능한 차원을 가지므로 C와 같이 구현됩니다. 정적 배열과 동적 배열은 서로 쉽게 변환 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8b6a4f79c67e1c0cfc398c2295408f2eb4b88ca9" translate="yes" xml:space="preserve">
          <source>Tibetan</source>
          <target state="translated">Tibetan</target>
        </trans-unit>
        <trans-unit id="62fac526b50cebc251a6af759bfe5d5bd018bff6" translate="yes" xml:space="preserve">
          <source>TickDuration</source>
          <target state="translated">TickDuration</target>
        </trans-unit>
        <trans-unit id="c0d2d45e63dc40fd88c7a14b1c2358a160a7833d" translate="yes" xml:space="preserve">
          <source>TickDuration &lt;code&gt;rhs&lt;/code&gt;</source>
          <target state="translated">TickDuration &lt;code&gt;rhs&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="1ce36a6b212a9b591eeb95689defcb8d1ae88308" translate="yes" xml:space="preserve">
          <source>TickDuration[fun.length] &lt;strong id=&quot;benchmark&quot;&gt;benchmark&lt;/strong&gt;(fun...)(uint n);</source>
          <target state="translated">TickDuration [fun.length] &lt;strong id=&quot;benchmark&quot;&gt;벤치 마크&lt;/strong&gt; (fun ...) (uint n);</target>
        </trans-unit>
        <trans-unit id="dc7acc903cfca8ef291e395f7b085edc57885861" translate="yes" xml:space="preserve">
          <source>Tid &lt;code&gt;tid&lt;/code&gt;</source>
          <target state="translated">Tid &lt;code&gt;tid&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="d1f074e4e94dc8553442f6182f62fea84786f05c" translate="yes" xml:space="preserve">
          <source>Tid &lt;strong id=&quot;locate&quot;&gt;locate&lt;/strong&gt;(string name);</source>
          <target state="translated">Tid &lt;strong id=&quot;locate&quot;&gt;locate&lt;/strong&gt; (문자열 이름);</target>
        </trans-unit>
        <trans-unit id="3e99e02f714335d73cd91fb8d55900b4d5bd1b70" translate="yes" xml:space="preserve">
          <source>Tid &lt;strong id=&quot;spawn&quot;&gt;spawn&lt;/strong&gt;(F, T...)(F fn, T args)</source>
          <target state="translated">타이드 &lt;strong id=&quot;spawn&quot;&gt;스폰&lt;/strong&gt; (F, T ...) (F fn, T args)</target>
        </trans-unit>
        <trans-unit id="25d02d5a84c7931ece10b93795e423a694986b38" translate="yes" xml:space="preserve">
          <source>Tid &lt;strong id=&quot;spawnLinked&quot;&gt;spawnLinked&lt;/strong&gt;(F, T...)(F fn, T args)</source>
          <target state="translated">Tid &lt;strong id=&quot;spawnLinked&quot;&gt;spawnLinked&lt;/strong&gt; (F, T ...) (F fn, T args)</target>
        </trans-unit>
        <trans-unit id="5b2248c38faf525d4aa66c5d69e86959be2e64dd" translate="yes" xml:space="preserve">
          <source>Tid &lt;strong id=&quot;threadId&quot;&gt;threadId&lt;/strong&gt;;</source>
          <target state="translated">TID &lt;strong id=&quot;threadId&quot;&gt;threadId&lt;/strong&gt; ;</target>
        </trans-unit>
        <trans-unit id="cf46deb14abc3ae4a0180bd680085f5421becb62" translate="yes" xml:space="preserve">
          <source>Tifinagh</source>
          <target state="translated">Tifinagh</target>
        </trans-unit>
        <trans-unit id="bf7505fef58bfd49abbc3421a5a8a317c819906e" translate="yes" xml:space="preserve">
          <source>Time Measurement and Benchmarking</source>
          <target state="translated">시간 측정 및 벤치마킹</target>
        </trans-unit>
        <trans-unit id="d8b561572b4c6d9af712780047246b7bc740a0d4" translate="yes" xml:space="preserve">
          <source>Time condition enumeration as an alias of &lt;a href=&quot;etc_c_curl#CurlTimeCond&quot;&gt;&lt;code&gt;etc.c.curl.CurlTimeCond&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">등의 별칭으로 시간 조건 열거 &lt;a href=&quot;etc_c_curl#CurlTimeCond&quot;&gt; &lt;code&gt;etc.c.curl.CurlTimeCond&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="c4aa3d14f701bba1ce181f3ec53ab695e0ade4da" translate="yes" xml:space="preserve">
          <source>Time the file was created.</source>
          <target state="translated">파일이 작성된 시간입니다.</target>
        </trans-unit>
        <trans-unit id="e359a0b0bd880a8c9076e3b462259fa4ca22d2f6" translate="yes" xml:space="preserve">
          <source>Time the file was last accessed.</source>
          <target state="translated">파일에 마지막으로 액세스 한 시간</target>
        </trans-unit>
        <trans-unit id="36c7dbef3cde666059933c227164a5d18726f66b" translate="yes" xml:space="preserve">
          <source>Time the file was last modified.</source>
          <target state="translated">파일이 마지막으로 수정 된 시간입니다.</target>
        </trans-unit>
        <trans-unit id="27cd174e9f8cc698cbd69056f98a77a3a55cb471" translate="yes" xml:space="preserve">
          <source>Time the file/folder was last accessed.</source>
          <target state="translated">파일 / 폴더에 마지막으로 액세스 한 시간</target>
        </trans-unit>
        <trans-unit id="4f227039843bc9b22d4f838b81ed18e54bb7b1a9" translate="yes" xml:space="preserve">
          <source>Time the file/folder was last modified.</source>
          <target state="translated">파일 / 폴더가 마지막으로 수정 된 시간입니다.</target>
        </trans-unit>
        <trans-unit id="aa5f4600d3071981a08116aeac1a782767d2276f" translate="yes" xml:space="preserve">
          <source>Time to use with the above condition. Specified in number of seconds since 1 Jan 1970</source>
          <target state="translated">위 조건에서 사용할 시간입니다. 1970 년 1 월 1 일 이후의 초 수로 지정</target>
        </trans-unit>
        <trans-unit id="d4cc22c8986572ffe1c232ea2044aac4c6d79f91" translate="yes" xml:space="preserve">
          <source>Time units</source>
          <target state="translated">시간 단위</target>
        </trans-unit>
        <trans-unit id="27745ce39165b24aa9162930c4465ce642154b42" translate="yes" xml:space="preserve">
          <source>Time zone is irrelevant when comparing &lt;a href=&quot;#SysTime&quot;&gt;&lt;code&gt;SysTime&lt;/code&gt;&lt;/a&gt;s.</source>
          <target state="translated">&lt;a href=&quot;#SysTime&quot;&gt; &lt;code&gt;SysTime&lt;/code&gt; 을&lt;/a&gt; 비교할 때 시간대는 관련이 없습니다 .</target>
        </trans-unit>
        <trans-unit id="9699f4eda399b03a7b8d7d0af76df9f2a6323ecf" translate="yes" xml:space="preserve">
          <source>Time zone offsets will be in the form +HH:MM or -HH:MM.</source>
          <target state="translated">시간대 오프셋은 + HH : MM 또는 -HH : MM 형식입니다.</target>
        </trans-unit>
        <trans-unit id="cbdea8478f6e24b16a22dfabfcf393abc2b6f5b4" translate="yes" xml:space="preserve">
          <source>Time zone offsets will be in the form +HHMM or -HHMM.</source>
          <target state="translated">시간대 오프셋은 + HHMM 또는 -HHMM 형식입니다.</target>
        </trans-unit>
        <trans-unit id="fa9aac4028931969e4e43d5926f21c1c02b03737" translate="yes" xml:space="preserve">
          <source>Time zones</source>
          <target state="translated">시간대</target>
        </trans-unit>
        <trans-unit id="25ea0fb6ef66b02b90f259085a72c5aa3a1cb38b" translate="yes" xml:space="preserve">
          <source>Time-out connect operations after this amount of seconds, if connects are OK within this time, then fine... This only aborts the connect phase. [Only works on unix-style/SIGALRM operating systems]</source>
          <target state="translated">이 시간 (초) 후에도 연결이 정상이면 시간 초과 연결 작업이 정상인 것입니다 ... 연결 단계 만 중단됩니다. [유닉스 스타일 / SIGALRM 운영 체제에서만 작동합니다]</target>
        </trans-unit>
        <trans-unit id="7898ff5a29bdccadbf6ffe3af05c0479d1dfccc9" translate="yes" xml:space="preserve">
          <source>Time-out the read operation after this amount of seconds</source>
          <target state="translated">이 시간 (초) 후에 읽기 작업 시간이 초과되었습니다.</target>
        </trans-unit>
        <trans-unit id="3a383c209c07d7ddd4a20a832e5e3183c6735122" translate="yes" xml:space="preserve">
          <source>TimeOfDay</source>
          <target state="translated">TimeOfDay</target>
        </trans-unit>
        <trans-unit id="931ede6287bc0e0bd7fe601fddba6e76758a6ca6" translate="yes" xml:space="preserve">
          <source>TimeOfDay &lt;code&gt;rhs&lt;/code&gt;</source>
          <target state="translated">TimeOfDay &lt;code&gt;rhs&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="1555a6cfeedd9ca84067267bcd651953c04210d9" translate="yes" xml:space="preserve">
          <source>TimeOfDay &lt;code&gt;tod&lt;/code&gt;</source>
          <target state="translated">TimeOfDay &lt;code&gt;tod&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="ab9bed73cb84a17cfdff14b6f7c15cb12325d572" translate="yes" xml:space="preserve">
          <source>TimeZone &lt;code&gt;timezone&lt;/code&gt;</source>
          <target state="translated">시간대의 &lt;code&gt;timezone&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="1fda33f37c23c6bf9d7fa6e3c06b399f2722e4e9" translate="yes" xml:space="preserve">
          <source>TimeZone &lt;code&gt;tz&lt;/code&gt;</source>
          <target state="translated">타임 &lt;code&gt;tz&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="19eabc961735d78f12fc7be906ffcb033853cf85" translate="yes" xml:space="preserve">
          <source>Timestamp</source>
          <target state="translated">Timestamp</target>
        </trans-unit>
        <trans-unit id="a05f35aebea6d90bfd4a149a3c110d0ba93cf063" translate="yes" xml:space="preserve">
          <source>Timestamp for the condition  &lt;a href=&quot;http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.25&quot;&gt;RFC2616 Section 14.25&lt;/a&gt;</source>
          <target state="translated">조건 &lt;a href=&quot;http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.25&quot;&gt;RFC2616 섹션 14.25&lt;/a&gt; 의 타임 스탬프</target>
        </trans-unit>
        <trans-unit id="791214dda21a45673e6a00a407416e403372c00e" translate="yes" xml:space="preserve">
          <source>Timezones</source>
          <target state="translated">Timezones</target>
        </trans-unit>
        <trans-unit id="d19ceca501465c339e3bcf2bc0d8ff02bb697d6c" translate="yes" xml:space="preserve">
          <source>Tip</source>
          <target state="translated">Tip</target>
        </trans-unit>
        <trans-unit id="c554ef7e0f768a7921e2d8ca33350a8183049302" translate="yes" xml:space="preserve">
          <source>Tip: &lt;code&gt;cache&lt;/code&gt; is eager when evaluating elements. If calling front on the underlying range has a side effect, it will be observable before calling front on the actual cached range.  Furthermore, care should be taken composing &lt;code&gt;cache&lt;/code&gt; with &lt;a href=&quot;std_range#take&quot;&gt;&lt;code&gt;std.range.take&lt;/code&gt;&lt;/a&gt;. By placing &lt;code&gt;take&lt;/code&gt; before &lt;code&gt;cache&lt;/code&gt;, then &lt;code&gt;cache&lt;/code&gt; will be &quot;aware&quot; of when the range ends, and correctly stop caching elements when needed. If calling front has no side effect though, placing &lt;code&gt;take&lt;/code&gt; after &lt;code&gt;cache&lt;/code&gt; may yield a faster range.  Either way, the resulting ranges will be equivalent, but maybe not at the same cost or side effects.</source>
          <target state="translated">팁 : 요소를 평가할 때 &lt;code&gt;cache&lt;/code&gt; 가 열성입니다. 기본 범위에서 전면 호출이 부작용이있는 경우 실제 캐시 된 범위에서 전면 호출하기 전에 관찰 할 수 있습니다. 또한 &lt;a href=&quot;std_range#take&quot;&gt; &lt;code&gt;std.range.take&lt;/code&gt; 로&lt;/a&gt; &lt;code&gt;cache&lt;/code&gt; 를 구성 할 때주의를 기울여야합니다 . &lt;code&gt;take&lt;/code&gt; before &lt;code&gt;cache&lt;/code&gt; 를 배치 하면 &lt;code&gt;cache&lt;/code&gt; 는 범위가 끝나는 시점을 &quot;인식&quot;하고 필요할 때 요소 캐싱을 올바르게 중지합니다. 그래도 front를 호출해도 부작용이 없으면 &lt;code&gt;take&lt;/code&gt; after &lt;code&gt;cache&lt;/code&gt; 를 배치 하면 더 빠른 범위를 얻을 수 있습니다. 어느 쪽이든 결과 범위는 동일하지만 비용이나 부작용이 동일하지 않을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a22acb5aeb0a04605632e4e842da9793f03544b7" translate="yes" xml:space="preserve">
          <source>Tip: &lt;code&gt;equal&lt;/code&gt; can itself be used as a predicate to other functions. This can be very useful when the element type of a range is itself a range. In particular, &lt;code&gt;equal&lt;/code&gt; can be its own predicate, allowing range of range (of range...) comparisons.</source>
          <target state="translated">팁 : &lt;code&gt;equal&lt;/code&gt; 은 다른 함수의 술어로 사용될 수 있습니다. 범위의 요소 유형 자체가 범위 인 경우 매우 유용 할 수 있습니다. 특히 &lt;code&gt;equal&lt;/code&gt; 은 범위 범위 (범위 ...)를 비교할 수있는 자체 술어 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4cf1b54b003a59c279d1ba0b615a8a5f3459ca8c" translate="yes" xml:space="preserve">
          <source>Tips</source>
          <target state="translated">Tips</target>
        </trans-unit>
        <trans-unit id="c5a0e0828626901459115ce06aafb77df7b91db7" translate="yes" xml:space="preserve">
          <source>Titlecase_Letter</source>
          <target state="translated">Titlecase_Letter</target>
        </trans-unit>
        <trans-unit id="ae79ea1e9c6391a9ed83a2e18a031b835feec0c9" translate="yes" xml:space="preserve">
          <source>To</source>
          <target state="translated">To</target>
        </trans-unit>
        <trans-unit id="6494691e25f78cf9ccf69f1c60778c2c794c2372" translate="yes" xml:space="preserve">
          <source>To &lt;a href=&quot;#Duration&quot;&gt;&lt;code&gt;Duration&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">으로 &lt;a href=&quot;#Duration&quot;&gt; &lt;code&gt;Duration&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="108e81f625c0fab42d496ad348b5d4bf286b22ec" translate="yes" xml:space="preserve">
          <source>To &lt;a href=&quot;#FracSec&quot;&gt;&lt;code&gt;FracSec&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">에 &lt;a href=&quot;#FracSec&quot;&gt; &lt;code&gt;FracSec&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="551da37cf37171dc3ce54406334d09a8cfda8b37" translate="yes" xml:space="preserve">
          <source>To &lt;a href=&quot;#TickDuration&quot;&gt;&lt;code&gt;TickDuration&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">에 &lt;a href=&quot;#TickDuration&quot;&gt; &lt;code&gt;TickDuration&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="64a71b7026dcf6ae8a460197932fea36a34976f6" translate="yes" xml:space="preserve">
          <source>To access members of an aggregate, given a pointer to the aggregate is in a register, use the &lt;code&gt;.offsetof&lt;/code&gt; property of the qualified name of the member:</source>
          <target state="translated">집계에 대한 포인터가 레지스터에있는 경우 집계 멤버에 액세스하려면 멤버의 규정 된 이름의 &lt;code&gt;.offsetof&lt;/code&gt; 특성을 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="acccbbe3599b947ae29100cb34a4d4f21d373721" translate="yes" xml:space="preserve">
          <source>To access them, the following import is required:</source>
          <target state="translated">액세스하려면 다음을 가져와야합니다.</target>
        </trans-unit>
        <trans-unit id="e706ae3f9491e98dd5256ff2e4c4957c44c28316" translate="yes" xml:space="preserve">
          <source>To alias more than one thing at once, use &lt;a href=&quot;#AliasSeq&quot;&gt;&lt;code&gt;AliasSeq&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">한 번에 둘 이상의 별명을 지정하려면 &lt;a href=&quot;#AliasSeq&quot;&gt; &lt;code&gt;AliasSeq&lt;/code&gt; 를&lt;/a&gt; 사용 하십시오 .</target>
        </trans-unit>
        <trans-unit id="39e9b604b80a0ec5108d41826ff96040f90f8ef1" translate="yes" xml:space="preserve">
          <source>To allocate multidimensional arrays, the declaration reads in the same order as the prefix array declaration order.</source>
          <target state="translated">다차원 배열을 할당하기 위해 선언은 접두사 배열 선언 순서와 동일한 순서로 읽습니다.</target>
        </trans-unit>
        <trans-unit id="6af61f245522dedf48b1b3d8a204655196724e93" translate="yes" xml:space="preserve">
          <source>To allocate the nested arrays, multiple arguments can be used:</source>
          <target state="translated">중첩 배열을 할당하기 위해 여러 인수를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="bf5996d93a7b5a9d8df4050814c45a9661fdd6d1" translate="yes" xml:space="preserve">
          <source>To avoid dynamic binding on member function call, insert base class name before the member function name. For example:</source>
          <target state="translated">멤버 함수 호출에서 동적 바인딩을 피하려면 멤버 함수 이름 앞에 기본 클래스 이름을 삽입하십시오. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="df138afd646bec9cd5ef16ca5a7a9ffa6dca6b3a" translate="yes" xml:space="preserve">
          <source>To avoid performance overhead, &lt;a href=&quot;std_range_primitives#isBidirectionalRange&quot;&gt;bi-directionality&lt;/a&gt; is only available when &lt;a href=&quot;std_range_primitives#hasSlicing&quot;&gt;&lt;code&gt;std.range.primitives.hasSlicing&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;std_range_primitives#hasLength&quot;&gt;&lt;code&gt;std.range.primitives.hasLength&lt;/code&gt;&lt;/a&gt; are true.</source>
          <target state="translated">성능 오버 헤드를 피하기 위해 &lt;a href=&quot;std_range_primitives#isBidirectionalRange&quot;&gt;양방향&lt;/a&gt; 은 &lt;a href=&quot;std_range_primitives#hasSlicing&quot;&gt; &lt;code&gt;std.range.primitives.hasSlicing&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;std_range_primitives#hasLength&quot;&gt; &lt;code&gt;std.range.primitives.hasLength&lt;/code&gt; &lt;/a&gt; 가 true 인 경우에만 사용 가능 합니다.</target>
        </trans-unit>
        <trans-unit id="e1b64ed586a51e4f5bb9e2b8e69de6ea4cbf1eb9" translate="yes" xml:space="preserve">
          <source>To avoid this from happening, either</source>
          <target state="translated">이런 일이 발생하지 않도록하려면</target>
        </trans-unit>
        <trans-unit id="fb6c2b246e5caf09e7ad4ac345e30c3e0c4946f9" translate="yes" xml:space="preserve">
          <source>To consider the base class's functions in the overload resolution process, use an</source>
          <target state="translated">과부하 해결 프로세스에서 기본 클래스의 기능을 고려하려면</target>
        </trans-unit>
        <trans-unit id="3cb5d4aaed3b2fe5d4443f21b6ff9f49e40d7fc2" translate="yes" xml:space="preserve">
          <source>To copy at most &lt;code&gt;n&lt;/code&gt; elements from a range, you may want to use &lt;a href=&quot;std_range#take&quot;&gt;&lt;code&gt;std.range.take&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">범위 에서 최대 &lt;code&gt;n&lt;/code&gt; 개의 요소 를 복사하려면 &lt;a href=&quot;std_range#take&quot;&gt; &lt;code&gt;std.range.take&lt;/code&gt; &lt;/a&gt; 를 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="d66375110d390ecdb959eb48abc4793e5606ed6b" translate="yes" xml:space="preserve">
          <source>To copy just those elements from a range that satisfy a predicate, use &lt;a href=&quot;#filter&quot;&gt;&lt;code&gt;filter&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">술어를 만족시키는 범위에서 해당 요소 만 복사하려면 &lt;a href=&quot;#filter&quot;&gt; &lt;code&gt;filter&lt;/code&gt; 를&lt;/a&gt; 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="a57c46e45190814579474a4cac7131c8e3ca8e36" translate="yes" xml:space="preserve">
          <source>To create a documented unit test just add three forward slashes before the unittest block, like this:</source>
          <target state="translated">문서화 된 단위 테스트를 작성하려면 다음과 같이 단위 테스트 블록 앞에 세 개의 슬래시를 추가하십시오.</target>
        </trans-unit>
        <trans-unit id="eeb898e0497caa20850f724cd4cb92b13730b597" translate="yes" xml:space="preserve">
          <source>To create a horizontal rule with hyphens, add spaces between the hyphens. Without the spaces they would be treated as the start or end of an &lt;a href=&quot;#embedded_code&quot;&gt;embedded code block&lt;/a&gt;. Note that any horizontal rule may contain spaces:</source>
          <target state="translated">하이픈이있는 가로 규칙을 만들려면 하이픈 사이에 공백을 추가하십시오. 공백이 없으면 &lt;a href=&quot;#embedded_code&quot;&gt;임베디드 코드 블록&lt;/a&gt; 의 시작 또는 끝으로 처리됩니다 . 모든 수평 규칙에는 공백이 포함될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="bc19837608d956da40f53510498a517f1210860d" translate="yes" xml:space="preserve">
          <source>To customize the &lt;code&gt;Logger&lt;/code&gt; behavior, create a new &lt;code&gt;class&lt;/code&gt; that inherits from the abstract &lt;code&gt;Logger&lt;/code&gt;&lt;code&gt;class&lt;/code&gt;, and implements the &lt;code&gt;writeLogMsg&lt;/code&gt; method.</source>
          <target state="translated">&lt;code&gt;Logger&lt;/code&gt; 동작 을 사용자 정의하려면 abstract &lt;code&gt;Logger&lt;/code&gt; &lt;code&gt;class&lt;/code&gt; 에서 상속 하고 &lt;code&gt;writeLogMsg&lt;/code&gt; 메소드를 구현 하는 새 &lt;code&gt;class&lt;/code&gt; 를 작성하십시오 .</target>
        </trans-unit>
        <trans-unit id="2abc1d47025179e8b25ad0d252e787e5f2f4b0e4" translate="yes" xml:space="preserve">
          <source>To deal with these possible errors, tedious error handling code must be added to each function call. If an error happened, code must be written to recover from the error, and the error must be reported to the user in some user friendly fashion. If an error cannot be handled locally, it must be explicitly propagated back to its caller. The long list of errno values needs to be converted into appropriate text to be displayed. Adding all the code to do this can consume a large part of the time spent coding a project - and still, if a new errno value is added to the runtime system, the old code can not properly display a meaningful error message.</source>
          <target state="translated">이러한 가능한 오류를 처리하려면 각 함수 호출에 지루한 오류 처리 코드를 추가해야합니다. 오류가 발생한 경우 오류를 복구하기 위해 코드를 작성해야하며 사용자에게 오류를 사용자 친화적 인 방식으로보고해야합니다. 오류를 로컬에서 처리 할 수없는 경우 명시 적으로 해당 호출자에게 전파되어야합니다. errno 값의 긴 목록을 표시하려면 적절한 텍스트로 변환해야합니다. 이 작업을 수행하기 위해 모든 코드를 추가하면 프로젝트를 코딩하는 데 많은 시간이 소요될 수 있지만 런타임 시스템에 새 errno 값이 추가되면 이전 코드에 의미있는 오류 메시지가 제대로 표시되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="0840e11f513cf9d6a67586541ed4c39bc7f43411" translate="yes" xml:space="preserve">
          <source>To define how one type can be cast to another, define the &lt;code&gt;opCast&lt;/code&gt; template method, which is used as follows:</source>
          <target state="translated">한 유형을 다른 유형으로 캐스트하는 방법을 정의하려면 다음과 같이 사용되는 &lt;code&gt;opCast&lt;/code&gt; 템플릿 방법을 정의하십시오 .</target>
        </trans-unit>
        <trans-unit id="69db67f87737bda086a681af3ab5a4a2b512d66e" translate="yes" xml:space="preserve">
          <source>To distinguish between the type of the back reference a look-up of the back referenced character is necessary: An identifier back reference always points to a digit &lt;b&gt;0&lt;/b&gt; to &lt;b&gt;9&lt;/b&gt;, while a type back reference always points to a letter.</source>
          <target state="translated">뒷면 참조의 유형을 구분하려면 룩업 뒷면 참조 문자가 필요하다 : 숫자에 식별자를 다시 참조가 항상 포인트 &lt;b&gt;0&lt;/b&gt; 에 &lt;b&gt;(9)&lt;/b&gt; , 편지에 형 역 참조는 항상 포인트 동안.</target>
        </trans-unit>
        <trans-unit id="04d9771dcd4d104db6559e0305a6f19443a680de" translate="yes" xml:space="preserve">
          <source>To do them all en masse:</source>
          <target state="translated">그들 모두를 한꺼번에하려면 :</target>
        </trans-unit>
        <trans-unit id="dcfefb9ac665ea68efebc3194f27ebac0436a51d" translate="yes" xml:space="preserve">
          <source>To ease debugging, in a &lt;a href=&quot;version#ConditionalStatement&quot;&gt;&lt;i&gt;ConditionalStatement&lt;/i&gt;&lt;/a&gt; controlled by a &lt;a href=&quot;version#DebugCondition&quot;&gt;&lt;i&gt;DebugCondition&lt;/i&gt;&lt;/a&gt;&lt;code&gt;@nogc&lt;/code&gt; functions can call functions that are not &lt;code&gt;@nogc&lt;/code&gt;.</source>
          <target state="translated">A의 디버깅 완화 &lt;a href=&quot;version#ConditionalStatement&quot;&gt;&lt;i&gt;ConditionalStatement&lt;/i&gt;&lt;/a&gt; a로 제어 &lt;a href=&quot;version#DebugCondition&quot;&gt;&lt;i&gt;DebugCondition&lt;/i&gt;&lt;/a&gt; &lt;code&gt;@nogc&lt;/code&gt; 없는 기능을 호출 할 수있는 기능 &lt;code&gt;@nogc&lt;/code&gt; 을 .</target>
        </trans-unit>
        <trans-unit id="5d4c7d82f37671d49bf06ba7162803fca2ebe085" translate="yes" xml:space="preserve">
          <source>To experiment with alternative allocators, set &lt;a href=&quot;#theAllocator&quot;&gt;&lt;code&gt;theAllocator&lt;/code&gt;&lt;/a&gt; for the current thread. For example, consider an application that allocates many 8-byte objects. These are not well supported by the default allocator, so a &lt;a href=&quot;std_experimental_allocator_building_blocks_free_list&quot;&gt;free list allocator&lt;/a&gt; would be recommended. To install one in &lt;code&gt;main&lt;/code&gt;, the application would use:</source>
          <target state="translated">대체 할당자를 실험하려면 현재 스레드에 할당자를 설정 &lt;a href=&quot;#theAllocator&quot;&gt; &lt;code&gt;theAllocator&lt;/code&gt; &lt;/a&gt; . 예를 들어 많은 8 바이트 객체를 할당하는 응용 프로그램을 생각해보십시오. 이들은 기본 할당 자에 의해 잘 지원되지 않으므로 사용 &lt;a href=&quot;std_experimental_allocator_building_blocks_free_list&quot;&gt;가능한 목록 할당자가&lt;/a&gt; 권장됩니다. &lt;code&gt;main&lt;/code&gt; 에 설치하려면 다음을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="8d9e12dc536b1565bc9fda436c93ff675e8dc213" translate="yes" xml:space="preserve">
          <source>To find the last occurrence of &lt;code&gt;needle&lt;/code&gt; in a &lt;a href=&quot;std_range_primitives#isBidirectionalRange&quot;&gt;bidirectional&lt;/a&gt;&lt;code&gt;haystack&lt;/code&gt;, call &lt;code&gt;find(retro(haystack), needle)&lt;/code&gt;. See &lt;a href=&quot;std_range#retro&quot;&gt;&lt;code&gt;std.range.retro&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;std_range_primitives#isBidirectionalRange&quot;&gt;양방향 &lt;/a&gt; &lt;code&gt;haystack&lt;/code&gt; 에서 &lt;code&gt;needle&lt;/code&gt; 의 마지막 항목을 찾으려면 find &lt;code&gt;find(retro(haystack), needle)&lt;/code&gt; 호출하십시오 . &lt;a href=&quot;std_range#retro&quot;&gt; &lt;code&gt;std.range.retro&lt;/code&gt; 를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="940d35064ca2c064467578facb6ad445a27bab6b" translate="yes" xml:space="preserve">
          <source>To gain more precise control over the logging process, additionally to overriding the &lt;code&gt;writeLogMsg&lt;/code&gt; method the methods &lt;code&gt;beginLogMsg&lt;/code&gt;, &lt;code&gt;logMsgPart&lt;/code&gt; and &lt;code&gt;finishLogMsg&lt;/code&gt; can be overridden.</source>
          <target state="translated">로깅 프로세스를보다 정확하게 제어하려면 &lt;code&gt;writeLogMsg&lt;/code&gt; 메소드 를 대체하는 것 외에도 &lt;code&gt;beginLogMsg&lt;/code&gt; , &lt;code&gt;logMsgPart&lt;/code&gt; 및 &lt;code&gt;finishLogMsg&lt;/code&gt; 메소드를 대체 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="266f2a903ad8aca0a8023659715c707ee628d78a" translate="yes" xml:space="preserve">
          <source>To get a &lt;code&gt;PosixTimeZone&lt;/code&gt;, call &lt;code&gt;PosixTimeZone.getTimeZone&lt;/code&gt; (which allows specifying the location the time zone files).</source>
          <target state="translated">&lt;code&gt;PosixTimeZone&lt;/code&gt; 을 얻으려면 PosixTimeZone.getTimeZone 을 호출 &lt;code&gt;PosixTimeZone.getTimeZone&lt;/code&gt; (시간대 파일의 위치를 ​​지정할 수 있음).</target>
        </trans-unit>
        <trans-unit id="2ed14e678985f0d95b56a32019f42872453c2e19" translate="yes" xml:space="preserve">
          <source>To get a &lt;code&gt;WindowsTimeZone&lt;/code&gt;, call &lt;code&gt;WindowsTimeZone.getTimeZone&lt;/code&gt;.</source>
          <target state="translated">의 GET에 &lt;code&gt;WindowsTimeZone&lt;/code&gt; 를 호출 &lt;code&gt;WindowsTimeZone.getTimeZone&lt;/code&gt; 을 .</target>
        </trans-unit>
        <trans-unit id="a52fa8889b7712f63349220576c00248419ac6ec" translate="yes" xml:space="preserve">
          <source>To get the difference in years, subtract the year property of two &lt;a href=&quot;#Date&quot;&gt;&lt;code&gt;Date&lt;/code&gt;&lt;/a&gt;s. To get the difference in days or weeks, subtract the &lt;a href=&quot;#Date&quot;&gt;&lt;code&gt;Date&lt;/code&gt;&lt;/a&gt;s themselves and use the &lt;a href=&quot;core_time#Duration&quot;&gt;&lt;code&gt;core.time.Duration&lt;/code&gt;&lt;/a&gt; that results. Because converting between months and smaller units requires a specific date (which &lt;a href=&quot;core_time#Duration&quot;&gt;&lt;code&gt;core.time.Duration&lt;/code&gt;&lt;/a&gt;s don't have), getting the difference in months requires some math using both the year and month properties, so this is a convenience function for getting the difference in months.</source>
          <target state="translated">연도의 차이를 얻으려면 두 &lt;a href=&quot;#Date&quot;&gt; &lt;code&gt;Date&lt;/code&gt; &lt;/a&gt; 의 연도 속성을 뺍니다 . 일 또는 주 단위의 차이를 얻으려면 &lt;a href=&quot;#Date&quot;&gt; &lt;code&gt;Date&lt;/code&gt; &lt;/a&gt; 자체를 빼고 &lt;a href=&quot;core_time#Duration&quot;&gt; &lt;code&gt;core.time.Duration&lt;/code&gt; &lt;/a&gt; 을 사용하십시오 . 개월과 더 작은 단위 사이의 변환에는 특정 날짜 ( &lt;a href=&quot;core_time#Duration&quot;&gt; &lt;code&gt;core.time.Duration&lt;/code&gt; 에&lt;/a&gt; 없는)가 필요하기 때문에 월의 차이를 얻으려면 year 및 month 속성을 모두 사용하는 수학이 필요하므로 이는 달의 차이.</target>
        </trans-unit>
        <trans-unit id="611f6f04377a68cee3f9ad63b2b1775dac313cf8" translate="yes" xml:space="preserve">
          <source>To get the difference in years, subtract the year property of two &lt;a href=&quot;#DateTime&quot;&gt;&lt;code&gt;DateTime&lt;/code&gt;&lt;/a&gt;s. To get the difference in days or weeks, subtract the &lt;a href=&quot;#DateTime&quot;&gt;&lt;code&gt;DateTime&lt;/code&gt;&lt;/a&gt;s themselves and use the &lt;a href=&quot;core_time#Duration&quot;&gt;&lt;code&gt;core.time.Duration&lt;/code&gt;&lt;/a&gt; that results. Because converting between months and smaller units requires a specific date (which &lt;a href=&quot;core_time#Duration&quot;&gt;&lt;code&gt;core.time.Duration&lt;/code&gt;&lt;/a&gt;s don't have), getting the difference in months requires some math using both the year and month properties, so this is a convenience function for getting the difference in months.</source>
          <target state="translated">연도의 차이를 얻으려면 두 &lt;a href=&quot;#DateTime&quot;&gt; &lt;code&gt;DateTime&lt;/code&gt; &lt;/a&gt; 의 연도 속성을 뺍니다 . 일 또는 주 단위의 차이를 얻으려면 &lt;a href=&quot;#DateTime&quot;&gt; &lt;code&gt;DateTime&lt;/code&gt; &lt;/a&gt; 자체를 빼고 &lt;a href=&quot;core_time#Duration&quot;&gt; &lt;code&gt;core.time.Duration&lt;/code&gt; &lt;/a&gt; 을 사용하십시오 . 개월과 더 작은 단위 사이의 변환에는 특정 날짜 ( &lt;a href=&quot;core_time#Duration&quot;&gt; &lt;code&gt;core.time.Duration&lt;/code&gt; 에&lt;/a&gt; 없는)가 필요하기 때문에 월의 차이를 얻으려면 year 및 month 속성을 모두 사용하는 수학이 필요하므로 이는 달의 차이.</target>
        </trans-unit>
        <trans-unit id="ca114625afe6909751302b60256cce50a6455f6b" translate="yes" xml:space="preserve">
          <source>To get the difference in years, subtract the year property of two &lt;a href=&quot;#SysTime&quot;&gt;&lt;code&gt;SysTime&lt;/code&gt;&lt;/a&gt;s. To get the difference in days or weeks, subtract the &lt;a href=&quot;#SysTime&quot;&gt;&lt;code&gt;SysTime&lt;/code&gt;&lt;/a&gt;s themselves and use the &lt;a href=&quot;core_time#Duration&quot;&gt;&lt;code&gt;core.time.Duration&lt;/code&gt;&lt;/a&gt; that results. Because converting between months and smaller units requires a specific date (which &lt;a href=&quot;core_time#Duration&quot;&gt;&lt;code&gt;core.time.Duration&lt;/code&gt;&lt;/a&gt;s don't have), getting the difference in months requires some math using both the year and month properties, so this is a convenience function for getting the difference in months.</source>
          <target state="translated">연도의 차이를 얻으려면 두 &lt;a href=&quot;#SysTime&quot;&gt; &lt;code&gt;SysTime&lt;/code&gt; &lt;/a&gt; 의 연도 속성을 빼십시오 . 일 또는 주 단위의 차이를 얻으려면 &lt;a href=&quot;#SysTime&quot;&gt; &lt;code&gt;SysTime&lt;/code&gt; 을&lt;/a&gt; 빼고 &lt;a href=&quot;core_time#Duration&quot;&gt; &lt;code&gt;core.time.Duration&lt;/code&gt; &lt;/a&gt; 을 사용하십시오 . 개월과 더 작은 단위 사이의 변환에는 특정 날짜 ( &lt;a href=&quot;core_time#Duration&quot;&gt; &lt;code&gt;core.time.Duration&lt;/code&gt; 에&lt;/a&gt; 없는)가 필요하기 때문에 월의 차이를 얻으려면 year 및 month 속성을 모두 사용하는 수학이 필요하므로 이는 달의 차이.</target>
        </trans-unit>
        <trans-unit id="9044e06c13b847070ef5dcf4834092817fbca12b" translate="yes" xml:space="preserve">
          <source>To guarantee copying behavior, use the .dup property to ensure a unique array that can be resized. Also, one may use the &lt;code&gt;.capacity&lt;/code&gt; property to determine how many elements can be appended to the array without reallocating.</source>
          <target state="translated">복사 동작을 보장하려면 .dup 속성을 사용하여 크기를 조정할 수있는 고유 한 배열을 확인하십시오. 또한 &lt;code&gt;.capacity&lt;/code&gt; 속성을 사용하여 재할 당하지 않고 배열에 추가 할 수있는 요소 수를 확인할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="233d724da932399f4e00f061e832a34896042f59" translate="yes" xml:space="preserve">
          <source>To implement the different containers both struct and class based approaches have been used. &lt;a href=&quot;std_container_util#make&quot;&gt;&lt;code&gt;std.container.util.make&lt;/code&gt;&lt;/a&gt; allows for uniform construction with either approach.</source>
          <target state="translated">다른 컨테이너를 구현하기 위해 구조체 및 클래스 기반 접근 방식이 모두 사용되었습니다. &lt;a href=&quot;std_container_util#make&quot;&gt; &lt;code&gt;std.container.util.make&lt;/code&gt; 를&lt;/a&gt; 사용하면 두 가지 방법으로 균일 한 구성이 가능합니다.</target>
        </trans-unit>
        <trans-unit id="ee9b559376db4a1e8468c6848a3ba5a71bc8dfb5" translate="yes" xml:space="preserve">
          <source>To improve the speed of the factorial function,</source>
          <target state="translated">계승 함수의 속도를 향상시키기 위해</target>
        </trans-unit>
        <trans-unit id="4e375b9e257d51069f4250fe3867302e9a258fcf" translate="yes" xml:space="preserve">
          <source>To link D functions and libraries into C programs, it's necessary to only require the C runtime library to be linked in. This is accomplished by defining a subset of D that fits this requirement, called &lt;b&gt;BetterC&lt;/b&gt;.</source>
          <target state="translated">D 함수 및 라이브러리를 C 프로그램에 링크하려면 C 런타임 라이브러리 만 링크하면됩니다. 이는 &lt;b&gt;BetterC&lt;/b&gt; 라는이 요구 사항에 맞는 D 서브 세트를 정의하여 수행됩니다 .</target>
        </trans-unit>
        <trans-unit id="418e30d51bb596772e9d5629c8d43dd500ddc9a6" translate="yes" xml:space="preserve">
          <source>To maintain accuracy at values of x near 1.0, use normalDistribution(x) = 1.0 - normalDistribution(-x).</source>
          <target state="translated">x 근처에서 1.0 근처의 값을 유지하려면 normalDistribution (x) = 1.0-normalDistribution (-x)을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="5b3b3d7bbc8b8e87f34fef0c04e823aed7dd8943" translate="yes" xml:space="preserve">
          <source>To make a D function accessible from C++, give it C++ linkage:</source>
          <target state="translated">C ++에서 D 함수에 액세스 할 수있게하려면 C ++ 링크를 제공하십시오.</target>
        </trans-unit>
        <trans-unit id="85053099cfb1e1260b205f5910c452e424126760" translate="yes" xml:space="preserve">
          <source>To make a copy of a container, use the &lt;code&gt;c.dup&lt;/code&gt; container primitive.</source>
          <target state="translated">컨테이너의 사본을 작성하려면 &lt;code&gt;c.dup&lt;/code&gt; 컨테이너 기본 요소를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="4330151dd0a4b250164d66c145c77b530d3ed205" translate="yes" xml:space="preserve">
          <source>To make both the return type and the method immutable, you can write:</source>
          <target state="translated">반환 유형과 메서드를 모두 변경할 수 없도록하려면 다음과 같이 쓸 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="57e902cb18fc9ae8488bd57a41a216b45b84b7c6" translate="yes" xml:space="preserve">
          <source>To make the return type immutable, you need to surround the return type with parentheses:</source>
          <target state="translated">반환 유형을 변경할 수 없게하려면 반환 유형을 괄호로 묶어야합니다.</target>
        </trans-unit>
        <trans-unit id="eb050bb6aba36c3b829cdba22de5651eceed94cb" translate="yes" xml:space="preserve">
          <source>To match the Objective-C semantics, &lt;code&gt;static&lt;/code&gt; and &lt;code&gt;final&lt;/code&gt; methods are virtual. &lt;code&gt;static&lt;/code&gt; methods are overridable as well.</source>
          <target state="translated">Objective-C 시맨틱과 일치시키기 위해 &lt;code&gt;static&lt;/code&gt; 및 &lt;code&gt;final&lt;/code&gt; 메소드는 가상입니다. &lt;code&gt;static&lt;/code&gt; 메소드도 무시할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="399f378b17e04ab3e088842cfc946bfa37190fec" translate="yes" xml:space="preserve">
          <source>To maximize efficiency, the runtime always tries to resize the array in place to avoid extra copying. It will always do a copy if the new size is larger and the array was not allocated via the new operator or resizing in place would overwrite valid data in the array. For example:</source>
          <target state="translated">효율성을 최대화하기 위해 런타임은 추가 복사를 피하기 위해 항상 배열의 크기를 조정하려고합니다. 새 크기가 더 크고 새 연산자를 통해 배열이 할당되지 않았거나 크기를 조정하면 배열의 유효한 데이터를 덮어 쓰는 경우 항상 복사를 수행합니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="6e630a6f0fbc69f96409d719fe2bf8debbee2ea5" translate="yes" xml:space="preserve">
          <source>To memoize a recursive function, simply insert the memoized call in lieu of the plain recursive call. For example, to transform the exponential-time Fibonacci implementation into a linear-time computation:</source>
          <target state="translated">재귀 함수를 메모하려면 일반 재귀 호출 대신 메모 된 호출을 삽입하십시오. 예를 들어 지수 시간 피보나치 구현을 선형 시간 계산으로 변환하려면 다음을 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="3516e14bd92ad99d31558a33d40a58c99908579a" translate="yes" xml:space="preserve">
          <source>To output a backslash, simply use two backslashes in a row: &lt;code&gt;\\&lt;/code&gt;. Note that backslashes inside embedded or inline code do &lt;em&gt;not&lt;/em&gt; escape punctuation and are included in the output as-is. Backslashes before non-punctation are also included in the output as-is. For example, &lt;code&gt;C:\dmd2\bin\dmd.exe&lt;/code&gt; does not require escaping its embedded backslashes.</source>
          <target state="translated">백 슬래시를 출력하려면 두 개의 백 슬래시를 연속으로 사용하십시오 : &lt;code&gt;\\&lt;/code&gt; . 임베디드 또는 인라인 코드 내부의 백 슬래시 는 문장 부호를 이탈 하지 &lt;em&gt;않으며&lt;/em&gt; 그대로 출력에 포함됩니다. 비 천공 전의 백 슬래시는 또한 그대로 출력에 포함됩니다. 예를 들어 &lt;code&gt;C:\dmd2\bin\dmd.exe&lt;/code&gt; 에는 포함 된 백 슬래시를 이스케이프 처리 할 필요가 없습니다.</target>
        </trans-unit>
        <trans-unit id="8f1374001cf71d8c7f16d7eec671343030bcedf0" translate="yes" xml:space="preserve">
          <source>To overload &lt;code&gt;a[]&lt;/code&gt;, simply define &lt;code&gt;opIndex&lt;/code&gt; with no parameters:</source>
          <target state="translated">&lt;code&gt;a[]&lt;/code&gt; 를 오버로드하려면 매개 변수없이 &lt;code&gt;opIndex&lt;/code&gt; 를 정의 하십시오 .</target>
        </trans-unit>
        <trans-unit id="15d95aac44624f17ec16bbbfbc71490c6fbf287e" translate="yes" xml:space="preserve">
          <source>To overload array indexing of the form &lt;code&gt;a[&lt;/code&gt;</source>
          <target state="translated">형식 &lt;code&gt;a[&lt;/code&gt; 배열 인덱싱을 오버로드하려면</target>
        </trans-unit>
        <trans-unit id="000e88e7e58bbba47a3e6a8c3ea25f6d7d08d6b5" translate="yes" xml:space="preserve">
          <source>To parallelize the copying of a range with expensive to evaluate elements to an array, pass an identity function (a function that just returns whatever argument is provided to it) to &lt;code&gt;amap&lt;/code&gt;.  &lt;b&gt;Exception Handling&lt;/b&gt;:  When at least one exception is thrown from inside the map functions, the submission of additional &lt;code&gt;Task&lt;/code&gt; objects is terminated as soon as possible, in a non-deterministic manner. All currently executing or enqueued work units are allowed to complete. Then, all exceptions that were thrown from any work unit are chained using &lt;code&gt;Throwable.next&lt;/code&gt; and rethrown. The order of the exception chaining is non-deterministic.</source>
          <target state="translated">고가의 요소를 배열에 복사하여 범위의 복사를 병렬화하려면 &lt;code&gt;amap&lt;/code&gt; identity 함수 (제공된 인수 만 반환하는 함수)를 전달하십시오 . &lt;b&gt;예외 처리&lt;/b&gt; : 맵 함수 내에서 하나 이상의 예외가 발생 하면 가능한 한 빨리 추가 &lt;code&gt;Task&lt;/code&gt; 객체 의 제출이 비 결정적 방식으로 종료됩니다. 현재 실행 중이거나 대기중인 모든 작업 단위를 완료 할 수 있습니다. 그런 다음 모든 작업 단위에서 발생한 모든 예외는 &lt;code&gt;Throwable.next&lt;/code&gt; 를 사용하여 연결 되고 다시 throw됩니다. 예외 체인의 순서는 결정적이지 않습니다.</target>
        </trans-unit>
        <trans-unit id="87b4b285bca7df049293dca955a7cff806c39c54" translate="yes" xml:space="preserve">
          <source>To perform the mapping operation in place, provide the same range for the input and output range.</source>
          <target state="translated">적절한 위치에서 매핑 작업을 수행하려면 입력 및 출력 범위에 동일한 범위를 제공하십시오.</target>
        </trans-unit>
        <trans-unit id="b6f84739ea0309b309811ceae01cf81f2836b095" translate="yes" xml:space="preserve">
          <source>To prevent mutation, D offers the &lt;code&gt;immutable&lt;/code&gt; type qualifier. If all of a &lt;code&gt;pure&lt;/code&gt; function's parameters are &lt;code&gt;immutable&lt;/code&gt; or copied values without any indirections (e.g. &lt;code&gt;int&lt;/code&gt;), the type system guarantees no side effects.</source>
          <target state="translated">돌연변이를 방지하기 위해 D는 &lt;code&gt;immutable&lt;/code&gt; 유형 한정자를 제공합니다 . &lt;code&gt;pure&lt;/code&gt; 함수의 모든 매개 변수가 간접적 (예 : &lt;code&gt;int&lt;/code&gt; ) 없이 &lt;code&gt;immutable&lt;/code&gt; 하거나 복사 된 값인 경우, 유형 시스템은 부작용을 보장하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="510e8a37c94f1fddd48f494b45f9c445ac13386e" translate="yes" xml:space="preserve">
          <source>To replace all matches use &lt;a href=&quot;#replaceAll&quot;&gt;&lt;code&gt;replaceAll&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">모든 일치 항목을 바꾸려면 &lt;a href=&quot;#replaceAll&quot;&gt; &lt;code&gt;replaceAll&lt;/code&gt; 을&lt;/a&gt; 사용 하십시오 .</target>
        </trans-unit>
        <trans-unit id="32637bfed038dc3b07de78cef61a544d88ceed68" translate="yes" xml:space="preserve">
          <source>To replace only the first match use &lt;a href=&quot;#replaceFirst&quot;&gt;&lt;code&gt;replaceFirst&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">첫 번째 일치 항목 만 바꾸려면 &lt;a href=&quot;#replaceFirst&quot;&gt; &lt;code&gt;replaceFirst&lt;/code&gt; 를&lt;/a&gt; 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="0d699e84d4ef2358f78c4907449972ca3c8ecaf0" translate="yes" xml:space="preserve">
          <source>To set &lt;code&gt;color&lt;/code&gt; to &lt;code&gt;Color.yes&lt;/code&gt;, invoke the program with either &lt;code&gt;--color=yes&lt;/code&gt; or &lt;code&gt;--color yes&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;color&lt;/code&gt; 을 &lt;code&gt;Color.yes&lt;/code&gt; 로 설정하려면 &lt;code&gt;--color=yes&lt;/code&gt; 또는 &lt;code&gt;--color yes&lt;/code&gt; 로 프로그램을 호출하십시오 .</target>
        </trans-unit>
        <trans-unit id="6bda9df29c966af1a72e8a5182df74509b8e721a" translate="yes" xml:space="preserve">
          <source>To set &lt;code&gt;timeout&lt;/code&gt; to &lt;code&gt;5&lt;/code&gt;, invoke the program with either &lt;code&gt;--timeout=5&lt;/code&gt; or &lt;code&gt;--timeout 5&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;timeout&lt;/code&gt; 을 &lt;code&gt;5&lt;/code&gt; 로 설정하려면 &lt;code&gt;--timeout=5&lt;/code&gt; 또는 &lt;code&gt;--timeout 5&lt;/code&gt; 로 프로그램을 호출하십시오 .</target>
        </trans-unit>
        <trans-unit id="7233a698292e0a276de835ff862d037b155c9056" translate="yes" xml:space="preserve">
          <source>To set &lt;code&gt;timeout&lt;/code&gt; to &lt;code&gt;5&lt;/code&gt;, use either of the following: &lt;code&gt;--timeout=5&lt;/code&gt;, &lt;code&gt;--timeout 5&lt;/code&gt;, &lt;code&gt;--t=5&lt;/code&gt;, &lt;code&gt;--t 5&lt;/code&gt;, or &lt;code&gt;-t5&lt;/code&gt;. Forms such as &lt;code&gt;-t 5&lt;/code&gt; and &lt;code&gt;-timeout=5&lt;/code&gt; will be not accepted.  For more details about short options, refer also to the next section.</source>
          <target state="translated">설정하려면 &lt;code&gt;timeout&lt;/code&gt; 을 &lt;code&gt;5&lt;/code&gt; : 중 다음의 사용 &lt;code&gt;--timeout=5&lt;/code&gt; , &lt;code&gt;--timeout 5&lt;/code&gt; , &lt;code&gt;--t=5&lt;/code&gt; , &lt;code&gt;--t 5&lt;/code&gt; , 또는 &lt;code&gt;-t5&lt;/code&gt; . &lt;code&gt;-t 5&lt;/code&gt; 및 &lt;code&gt;-timeout=5&lt;/code&gt; 와 같은 양식 은 허용되지 않습니다. 짧은 옵션에 대한 자세한 내용은 다음 섹션을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="ddaae0a344d10b36be801991a765088949e60549" translate="yes" xml:space="preserve">
          <source>To set &lt;code&gt;verbose&lt;/code&gt; to &lt;code&gt;true&lt;/code&gt;, invoke the program with either &lt;code&gt;--verbose&lt;/code&gt; or &lt;code&gt;--verbose=true&lt;/code&gt;.  To set &lt;code&gt;debugging&lt;/code&gt; to &lt;code&gt;false&lt;/code&gt;, invoke the program with &lt;code&gt;--debugging=false&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;verbose&lt;/code&gt; 를 &lt;code&gt;true&lt;/code&gt; 로 설정하려면 &lt;code&gt;--verbose&lt;/code&gt; 또는 &lt;code&gt;--verbose=true&lt;/code&gt; 로 프로그램을 호출하십시오 . &lt;code&gt;debugging&lt;/code&gt; 을 &lt;code&gt;false&lt;/code&gt; 로 설정하려면 &lt;code&gt;--debugging=false&lt;/code&gt; 로 프로그램을 호출하십시오 .</target>
        </trans-unit>
        <trans-unit id="90aeb9b368ec13053b28da39579d017a147e76dd" translate="yes" xml:space="preserve">
          <source>To solve the fragile base class problem, instance variables in Objective-C has a dynamic offset. That means that the base class can change (add or remove instance variables) without the subclasses needing to recompile or relink. Thanks to this feature it's not necessary to declare instance variables when creating bindings to Objective-C classes.</source>
          <target state="translated">취약한 기본 클래스 문제를 해결하기 위해 Objective-C의 인스턴스 변수에는 동적 오프셋이 있습니다. 이는 서브 클래스가 재 컴파일 또는 재 링크 할 필요없이 기본 클래스가 변경 (인스턴스 변수 추가 또는 제거) 될 수 있음을 의미합니다. 이 기능 덕분에 Objective-C 클래스에 대한 바인딩을 작성할 때 인스턴스 변수를 선언 할 필요가 없습니다.</target>
        </trans-unit>
        <trans-unit id="120e7e0cecbea01188056698938dba51c73d2ca2" translate="yes" xml:space="preserve">
          <source>To understand what &lt;code&gt;gapWeightedSimilarity(s, t, lambda)&lt;/code&gt; computes, consider first the case &lt;code&gt;lambda = 1&lt;/code&gt; and the strings &lt;code&gt;s = [&quot;Hello&quot;, &quot;brave&quot;, &quot;new&quot;, &quot;world&quot;]&lt;/code&gt; and &lt;code&gt;t = [&quot;Hello&quot;, &quot;new&quot;, &quot;world&quot;]&lt;/code&gt;. In that case, &lt;code&gt;gapWeightedSimilarity&lt;/code&gt; counts the following matches:</source>
          <target state="translated">&lt;code&gt;gapWeightedSimilarity(s, t, lambda)&lt;/code&gt; 계산 하는지 이해하려면 먼저 &lt;code&gt;lambda = 1&lt;/code&gt; 이고 문자열 &lt;code&gt;s = [&quot;Hello&quot;, &quot;brave&quot;, &quot;new&quot;, &quot;world&quot;]&lt;/code&gt; 및 &lt;code&gt;t = [&quot;Hello&quot;, &quot;new&quot;, &quot;world&quot;]&lt;/code&gt; . 이 경우 &lt;code&gt;gapWeightedSimilarity&lt;/code&gt; 는 다음 일치 항목을 계산합니다.</target>
        </trans-unit>
        <trans-unit id="94904fa76d4f11340da03fec0a15c494a85ffea1" translate="yes" xml:space="preserve">
          <source>To units</source>
          <target state="translated">단위로</target>
        </trans-unit>
        <trans-unit id="b3ba6419dc9ea2b78f83db771b45536f87338e59" translate="yes" xml:space="preserve">
          <source>To use &lt;code&gt;isInstanceOf&lt;/code&gt; to check the identity of a template while inside of said template, use &lt;a href=&quot;#TemplateOf&quot;&gt;&lt;code&gt;TemplateOf&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">템플릿 내부에서 &lt;code&gt;isInstanceOf&lt;/code&gt; 를 사용 하여 템플릿의 ID를 확인하려면 &lt;a href=&quot;#TemplateOf&quot;&gt; &lt;code&gt;TemplateOf&lt;/code&gt; 를&lt;/a&gt; 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="0ccc24a097574057226e86500cf33d397fb42f61" translate="yes" xml:space="preserve">
          <source>To use a different comparison than &lt;code&gt;&quot;a &amp;lt; b&quot;&lt;/code&gt;, pass a different operator string that can be used by &lt;a href=&quot;std_functional#binaryFun&quot;&gt;&lt;code&gt;std.functional.binaryFun&lt;/code&gt;&lt;/a&gt;, or pass in a function, delegate, functor, or any type where &lt;code&gt;less(a, b)&lt;/code&gt; results in a &lt;code&gt;bool&lt;/code&gt; value.</source>
          <target state="translated">&lt;code&gt;&quot;a &amp;lt; b&quot;&lt;/code&gt; 와 다른 비교를 사용하려면 &lt;a href=&quot;std_functional#binaryFun&quot;&gt; &lt;code&gt;std.functional.binaryFun&lt;/code&gt; &lt;/a&gt; 에서 사용할 수있는 다른 연산자 문자열을 전달하거나 함수, 대리자, functor 또는 &lt;code&gt;less(a, b)&lt;/code&gt; 발생 하는 모든 유형 을 전달하십시오. &lt;code&gt;bool&lt;/code&gt; 값입니다.</target>
        </trans-unit>
        <trans-unit id="ec17d2b0393d701bb378fb92b5f34cc43ec1456a" translate="yes" xml:space="preserve">
          <source>To use it:</source>
          <target state="translated">그것을 사용하려면 :</target>
        </trans-unit>
        <trans-unit id="ccbeeee07e1df8ffe8c8184d16795dcbbad96d59" translate="yes" xml:space="preserve">
          <source>To use the registered GC, it's name must be specified gcopt runtime option, e.g. by passing &lt;em&gt;, --DRT-gcopt=gc:my_gc_name&lt;/em&gt; as application argument.</source>
          <target state="translated">등록 된 GC를 사용하려면 예를 들어 &lt;em&gt;--DRT-gcopt = gc : my_gc_name&lt;/em&gt; 을 응용 프로그램 인수로 전달하여 이름을 gcopt 런타임 옵션으로 지정해야합니다 .</target>
        </trans-unit>
        <trans-unit id="66efb9234157955b960a3139060c665ce5882658" translate="yes" xml:space="preserve">
          <source>To use this template, it must first be instantiated with a specific type:</source>
          <target state="translated">이 템플릿을 사용하려면 먼저 특정 유형으로 인스턴스화해야합니다.</target>
        </trans-unit>
        <trans-unit id="0773afb54ea37c47bd380cce3db76b12cb278887" translate="yes" xml:space="preserve">
          <source>To use, put the line: response_expand(&amp;amp;argc,&amp;amp;argv); as the first executable statement in main(int argc, char **argv). argc and argv are adjusted to be the new command line arguments after response file expansion.</source>
          <target state="translated">사용하려면 다음 줄을 입력하십시오. response_expand (&amp;amp; argc, &amp;amp; argv); main (int argc, char ** argv)의 첫 번째 실행 문으로 사용하십시오. argc 및 argv는 응답 파일 확장 후 새로운 명령 행 인수가되도록 조정됩니다.</target>
        </trans-unit>
        <trans-unit id="6054d88f6fd53a5005771519db583793dcab79e9" translate="yes" xml:space="preserve">
          <source>To what precision is x equal to y?</source>
          <target state="translated">x와 y의 정밀도는 어느 정도입니까?</target>
        </trans-unit>
        <trans-unit id="fdebf667212089ea7017a4b5425a561bdb3a30b0" translate="yes" xml:space="preserve">
          <source>Todo</source>
          <target state="translated">Todo</target>
        </trans-unit>
        <trans-unit id="fca57aee253e291d0ee9aa5ecbb555afdc35567c" translate="yes" xml:space="preserve">
          <source>Token Strings</source>
          <target state="translated">토큰 문자열</target>
        </trans-unit>
        <trans-unit id="fed427b1f3d3ef7e65fc5054b2e5e854301b06b4" translate="yes" xml:space="preserve">
          <source>Token strings open with the characters &lt;code&gt;q&lt;/code&gt;&lt;code&gt;{&lt;/code&gt; and close with the token &lt;code&gt;}&lt;/code&gt;. In between must be valid D tokens. The &lt;code&gt;{&lt;/code&gt; and &lt;code&gt;}&lt;/code&gt; tokens nest. The string is formed of all the characters between the opening and closing of the token string, including comments.</source>
          <target state="translated">토큰 문자열은 문자 &lt;code&gt;q&lt;/code&gt; &lt;code&gt;{&lt;/code&gt; 로 열고 토큰으로 닫습니다 &lt;code&gt;}&lt;/code&gt; . 사이에 유효한 D 토큰이 있어야합니다. 은 &lt;code&gt;{&lt;/code&gt; 와 &lt;code&gt;}&lt;/code&gt; 둥지를 토큰. 문자열은 주석을 포함하여 토큰 문자열의 열기와 닫기 사이의 모든 문자로 구성됩니다.</target>
        </trans-unit>
        <trans-unit id="c38c6c1f3a2743f8626703abb302e403d20ff81c" translate="yes" xml:space="preserve">
          <source>Tokens</source>
          <target state="translated">Tokens</target>
        </trans-unit>
        <trans-unit id="052c92ab74e0edce8a8ddb051550d404ed7fea5b" translate="yes" xml:space="preserve">
          <source>Total Number Of Rows Modified</source>
          <target state="translated">수정 된 총 행 수</target>
        </trans-unit>
        <trans-unit id="acfc1c14180f3c75b37d492cbf0679b8f5397d5e" translate="yes" xml:space="preserve">
          <source>Trace handler</source>
          <target state="translated">추적 핸들러</target>
        </trans-unit>
        <trans-unit id="339bd194ea0514f6931ef3cb54a8ab0164d4cdd4" translate="yes" xml:space="preserve">
          <source>TraceGC wrapper around &lt;a href=&quot;core_internal_array_concat#d_arraycatnTX&quot;&gt;&lt;code&gt;core.internal.array.concat.d_arraycatnTX&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">주위 TraceGC 래퍼 &lt;a href=&quot;core_internal_array_concat#d_arraycatnTX&quot;&gt; &lt;code&gt;core.internal.array.concat.d_arraycatnTX&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="d0e0642895405b7e1549bc202853dc5cb0187b5b" translate="yes" xml:space="preserve">
          <source>TraceGC wrapper around &lt;a href=&quot;core_internal_array_core.internal.array.capacity#d_arraysetlengthT&quot;&gt;&lt;code&gt;core.internal.array.core.internal.array.capacity.d_arraysetlengthT&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">주위 TraceGC 래퍼 &lt;a href=&quot;core_internal_array_core.internal.array.capacity#d_arraysetlengthT&quot;&gt; &lt;code&gt;core.internal.array.core.internal.array.capacity.d_arraysetlengthT&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="b368b80c6345f7eb3fde3e057ff304366850fb39" translate="yes" xml:space="preserve">
          <source>TraceGC wrapper around &lt;a href=&quot;rt_array_appending_d_arrayappendctximpl#d_arrayappendcTX&quot;&gt;&lt;code&gt;rt.array.appending.d_arrayappendcTXImpl.d_arrayappendcTX&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">주위 TraceGC 래퍼 &lt;a href=&quot;rt_array_appending_d_arrayappendctximpl#d_arrayappendcTX&quot;&gt; &lt;code&gt;rt.array.appending.d_arrayappendcTXImpl.d_arrayappendcTX&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="80dd4794746522d5a6319b62ffeb07ebb7212a09" translate="yes" xml:space="preserve">
          <source>TraceGC wrapper around &lt;a href=&quot;rt_array_appending_d_arrayappendtimpl#d_arrayappendT&quot;&gt;&lt;code&gt;rt.array.appending.d_arrayappendTImpl.d_arrayappendT&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">주위 TraceGC 래퍼 &lt;a href=&quot;rt_array_appending_d_arrayappendtimpl#d_arrayappendT&quot;&gt; &lt;code&gt;rt.array.appending.d_arrayappendTImpl.d_arrayappendT&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="75a5d485e29e7339691a82c35666d01ee9e99be8" translate="yes" xml:space="preserve">
          <source>TraceGC wrapper around runtime hook &lt;code&gt;Hook&lt;/code&gt;.</source>
          <target state="translated">런타임 후크 &lt;code&gt;Hook&lt;/code&gt; 주위의 TraceGC 랩퍼 .</target>
        </trans-unit>
        <trans-unit id="968e231f347833476137cde0bb130f49fd1066a0" translate="yes" xml:space="preserve">
          <source>TraceHandler &lt;code&gt;h&lt;/code&gt;</source>
          <target state="translated">TraceHandler &lt;code&gt;h&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="40795f513f85788543dae6b9a0f0c645b802b300" translate="yes" xml:space="preserve">
          <source>TraceHandler &lt;strong id=&quot;rt_getTraceHandler&quot;&gt;rt_getTraceHandler&lt;/strong&gt;();</source>
          <target state="translated">TraceHandler &lt;strong id=&quot;rt_getTraceHandler&quot;&gt;rt_getTraceHandler&lt;/strong&gt; ();</target>
        </trans-unit>
        <trans-unit id="3ff2cf2928371330c202528a4ec623af7dd4183d" translate="yes" xml:space="preserve">
          <source>TraceInfo &lt;strong id=&quot;info&quot;&gt;info&lt;/strong&gt;;</source>
          <target state="translated">TraceInfo &lt;strong id=&quot;info&quot;&gt;정보&lt;/strong&gt; ;</target>
        </trans-unit>
        <trans-unit id="97acc1b59f9ec17c88715b436c8c28883bd4892f" translate="yes" xml:space="preserve">
          <source>Tracing And Profiling Functions</source>
          <target state="translated">추적 및 프로파일 링 기능</target>
        </trans-unit>
        <trans-unit id="b94fe6610b8c5aab12f91b0905d8d39edb892d87" translate="yes" xml:space="preserve">
          <source>Tracks bytes currently allocated by this allocator. This number goes up and down as memory is allocated and deallocated, and is zero if the allocator currently has no active allocation.</source>
          <target state="translated">이 할당자가 현재 할당 한 바이트를 추적합니다. 이 숫자는 메모리가 할당 및 할당 해제됨에 따라 올라가고 내려갑니다. 할당자가 현재 활성 할당을 가지고 있지 않으면 0입니다.</target>
        </trans-unit>
        <trans-unit id="3ec8a086c7378a608bd7ab5887414689898832b0" translate="yes" xml:space="preserve">
          <source>Tracks the sum of all &lt;code&gt;b.length - s&lt;/code&gt; with &lt;code&gt;b.length &amp;gt; s&lt;/code&gt; in calls of the form &lt;code&gt;realloc(b, s)&lt;/code&gt; that succeed (return &lt;code&gt;true&lt;/code&gt;). In per-call statistics, also unambiguously counts the bytes deallocated with &lt;code&gt;deallocate&lt;/code&gt;.</source>
          <target state="translated">트랙 모두의 합 &lt;code&gt;b.length - s&lt;/code&gt; 와 &lt;code&gt;b.length &amp;gt; s&lt;/code&gt; 형식의 호출에 &lt;code&gt;realloc(b, s)&lt;/code&gt; 의 성공이 (반환 &lt;code&gt;true&lt;/code&gt; ). 통화 별 통계에서 deallocate와 함께 &lt;code&gt;deallocate&lt;/code&gt; 바이트도 명확하게 계산합니다 .</target>
        </trans-unit>
        <trans-unit id="b241e803ff9fd9ce02dd41f6d962d259eca7d1cc" translate="yes" xml:space="preserve">
          <source>Tracks the sum of all &lt;code&gt;delta&lt;/code&gt; values in calls of the form &lt;code&gt;expand(b, delta)&lt;/code&gt; that succeed (return &lt;code&gt;true&lt;/code&gt;).</source>
          <target state="translated">&lt;code&gt;expand(b, delta)&lt;/code&gt; 형식의 호출에서 성공한 모든 &lt;code&gt;delta&lt;/code&gt; 값 의 합계를 추적합니다 ( &lt;code&gt;true&lt;/code&gt; 반환 ).</target>
        </trans-unit>
        <trans-unit id="5008e18d38dabcd09c748f97cdb5eb01dccc1e39" translate="yes" xml:space="preserve">
          <source>Tracks the sum of all bytes NOT moved as result of calls to &lt;code&gt;realloc&lt;/code&gt; that managed to reallocate in place. A large number (relative to &lt;code&gt; bytesAllocated&lt;/code&gt;) indicates that the application is expansion-intensive and is saving a good amount of moves. However, if this number is relatively small and &lt;code&gt;bytesSlack&lt;/code&gt; is high, it means the application is overallocating for little benefit.</source>
          <target state="translated">트랙 모두의 합이 호출의 결과로 이동하지 바이트 &lt;code&gt;realloc&lt;/code&gt; 과 장소에 재 할당을 관리하는 것이다. &lt;code&gt; bytesAllocated&lt;/code&gt; 에 비해 큰 숫자 는 응용 프로그램이 확장 집약적이며 많은 양의 이동을 저장하고 있음을 나타냅니다. 그러나이 숫자가 상대적으로 작고 &lt;code&gt;bytesSlack&lt;/code&gt; 이 높으면 응용 프로그램이 전체적으로 할당되어 이점이 거의 없음을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="7955ac7f466b43052c0744fbaca4b335f62263c8" translate="yes" xml:space="preserve">
          <source>Tracks the sum of all bytes moved as a result of calls to &lt;code&gt;realloc&lt;/code&gt; that were unable to reallocate in place. A large number (relative to &lt;code&gt; bytesAllocated&lt;/code&gt;) indicates that the application should use larger preallocations.</source>
          <target state="translated">재 할당 할 수없는 &lt;code&gt;realloc&lt;/code&gt; 호출의 결과로 이동 한 모든 바이트의 합계를 추적합니다 . &lt;code&gt; bytesAllocated&lt;/code&gt; 에 비해 큰 숫자 는 응용 프로그램이 더 큰 사전 할당을 사용해야 함을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="faf9f30dc9aae03a78ac2b0d759eee7f02feabde" translate="yes" xml:space="preserve">
          <source>Tracks total cumulative bytes allocated by means of &lt;code&gt;allocate&lt;/code&gt;, &lt;code&gt;expand&lt;/code&gt;, and &lt;code&gt;reallocate&lt;/code&gt; (when resulting in an expansion). This number always grows and indicates allocation traffic. To compute bytes deallocated cumulatively, subtract &lt;code&gt;bytesUsed&lt;/code&gt; from &lt;code&gt;bytesAllocated&lt;/code&gt;.</source>
          <target state="translated">assign , &lt;code&gt;expand&lt;/code&gt; 및 &lt;code&gt;reallocate&lt;/code&gt; ( 확장 &lt;code&gt;allocate&lt;/code&gt; 경우)를 통해 할당 된 총 누적 바이트를 추적 합니다. 이 숫자는 항상 증가하고 할당 트래픽을 나타냅니다. 누적 할당이 해제 된 바이트를 계산하려면 &lt;code&gt;bytesUsed&lt;/code&gt; 에서 &lt;code&gt;bytesAllocated&lt;/code&gt; 뺍니다 .</target>
        </trans-unit>
        <trans-unit id="05e8d1a3538b3e90690cad906240b5fa54e138df" translate="yes" xml:space="preserve">
          <source>Trademarks</source>
          <target state="translated">Trademarks</target>
        </trans-unit>
        <trans-unit id="a65c761b81d8b95898721c08b732f21414baa36d" translate="yes" xml:space="preserve">
          <source>Traditionally, programs accepted single-letter options preceded by only one dash (e.g. &lt;code&gt;-t&lt;/code&gt;). &lt;code&gt;getopt&lt;/code&gt; accepts such parameters seamlessly. When used with a double-dash (e.g. &lt;code&gt;--t&lt;/code&gt;), a single-letter option behaves the same as a multi-letter option. When used with a single dash, a single-letter option is accepted. If the option has a parameter, that must be &quot;stuck&quot; to the option without any intervening space or &quot;=&quot;:</source>
          <target state="translated">전통적으로 프로그램은 단일 문자 옵션 앞에 하나의 대시 (예 : &lt;code&gt;-t&lt;/code&gt; ) 만 허용했습니다 . &lt;code&gt;getopt&lt;/code&gt; 는 이러한 매개 변수를 완벽하게 승인합니다. 이중 대시 (예 : &lt;code&gt;--t&lt;/code&gt; ) 와 함께 사용 하면 단일 문자 옵션이 다중 문자 옵션과 동일하게 작동합니다. 단일 대시와 함께 사용하면 단일 문자 옵션이 허용됩니다. 옵션에 매개 변수가있는 경우 공백이나 &quot;=&quot;없이 옵션에 &quot;고착&quot;되어야합니다.</target>
        </trans-unit>
        <trans-unit id="32a79a3c4d4b7259d08b26cc56e7bb87a9fe9843" translate="yes" xml:space="preserve">
          <source>Trailing template parameters can be given default values:</source>
          <target state="translated">후행 템플리트 매개 변수에는 기본값이 제공 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c05d0571a965a586c4e7efe02429db2afdc8c356" translate="yes" xml:space="preserve">
          <source>Trailing_Jamo</source>
          <target state="translated">Trailing_Jamo</target>
        </trans-unit>
        <trans-unit id="d1a616085a1a99a58e14bafaa350abc6783a3160" translate="yes" xml:space="preserve">
          <source>Traits</source>
          <target state="translated">Traits</target>
        </trans-unit>
        <trans-unit id="3eb508881f4d401ebe62236f9dc8c80c61228925" translate="yes" xml:space="preserve">
          <source>Traits are extensions to the language to enable programs, at compile time, to get at information internal to the compiler. This is also known as compile time reflection. It is done as a special, easily extended syntax (similar to Pragmas) so that new capabilities can be added as required.</source>
          <target state="translated">특성은 컴파일 타임에 프로그램이 컴파일러 내부의 정보를 얻을 수 있도록 언어의 확장입니다. 이것은 컴파일 타임 리플렉션이라고도합니다. 필요에 따라 새로운 기능을 추가 할 수 있도록 Pragma와 유사한 특수하고 쉽게 확장되는 구문으로 수행됩니다.</target>
        </trans-unit>
        <trans-unit id="45ce7caaed05d2b5c0efd3ebab2b970cdb17b248" translate="yes" xml:space="preserve">
          <source>TraitsExp &lt;strong id=&quot;exp&quot;&gt;exp&lt;/strong&gt;;</source>
          <target state="translated">TraitsExp &lt;strong id=&quot;exp&quot;&gt;exp&lt;/strong&gt; ;</target>
        </trans-unit>
        <trans-unit id="776df5d3d02b2f2502c0ba9fde683a6ac4564118" translate="yes" xml:space="preserve">
          <source>Transfer ownership from a &lt;code&gt;Unique&lt;/code&gt; of a type that is convertible to our type.</source>
          <target state="translated">유형으로 변환 할 수 있는 &lt;code&gt;Unique&lt;/code&gt; 한 유형의 소유권을 이전 합니다.</target>
        </trans-unit>
        <trans-unit id="b3f957b52d56c1cbf2d25e123eda610314928a9b" translate="yes" xml:space="preserve">
          <source>Transfer ownership to a &lt;code&gt;Unique&lt;/code&gt; rvalue. Nullifies the current contents. Same as calling std.algorithm.move on it.</source>
          <target state="translated">소유권을 &lt;code&gt;Unique&lt;/code&gt; rvalue로 이전하십시오. 현재 내용을 무효화합니다. std.algorithm.move를 호출하는 것과 같습니다.</target>
        </trans-unit>
        <trans-unit id="1f1886aabb4342f3629dbcd769504a41bfa676c8" translate="yes" xml:space="preserve">
          <source>Transfers execution to this fiber object. The calling context will be suspended until the fiber calls Fiber.yield() or until it terminates via an unhandled exception.</source>
          <target state="translated">이 파이버 객체로 실행을 전송합니다. 파이버가 Fiber.yield ()를 호출 할 때까지 또는 처리되지 않은 예외를 통해 종료 될 때까지 호출 컨텍스트가 일시 중단됩니다.</target>
        </trans-unit>
        <trans-unit id="31251528682bcb8b77a91ffbd3b05ea524c5340e" translate="yes" xml:space="preserve">
          <source>Transfers ownership of the buffer to the caller.</source>
          <target state="translated">버퍼의 소유권을 호출자에게 전송합니다.</target>
        </trans-unit>
        <trans-unit id="188eeca51b370b3f079cb0e0ef0721398bd7bd93" translate="yes" xml:space="preserve">
          <source>Transforms &lt;code&gt;path&lt;/code&gt; into a path relative to &lt;code&gt;base&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;path&lt;/code&gt; 를 &lt;code&gt;base&lt;/code&gt; 에 상대적인 경로 로 변환 합니다 .</target>
        </trans-unit>
        <trans-unit id="00ded035b85d9ff7c01b323b06df130cfc1720ab" translate="yes" xml:space="preserve">
          <source>Transforms &lt;code&gt;path&lt;/code&gt; into an absolute path.</source>
          <target state="translated">&lt;code&gt;path&lt;/code&gt; 를 절대 경로 로 변환 합니다 .</target>
        </trans-unit>
        <trans-unit id="34fc8e092bab0ba38ba7f911f332353c9a7c0772" translate="yes" xml:space="preserve">
          <source>Transforms a &lt;code&gt;string&lt;/code&gt; representing an expression into a binary function. The &lt;code&gt;string&lt;/code&gt; must either use symbol names &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt; as the parameters or provide the symbols via the &lt;code&gt;parm1Name&lt;/code&gt; and &lt;code&gt;parm2Name&lt;/code&gt; arguments.</source>
          <target state="translated">식을 나타내는 &lt;code&gt;string&lt;/code&gt; 이진 함수로 변환 합니다. &lt;code&gt;string&lt;/code&gt; 중 하나를 수행해야합니다 사용 심볼 이름 와 &lt;code&gt;b&lt;/code&gt; 매개 변수이나은을 통해 기호를 제공 &lt;code&gt;parm1Name&lt;/code&gt; 및 &lt;code&gt;parm2Name&lt;/code&gt; 인수를. &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="5e4574331dd9213dff75e0c56ce82cdfa938b199" translate="yes" xml:space="preserve">
          <source>Transforms a &lt;code&gt;string&lt;/code&gt; representing an expression into a unary function. The &lt;code&gt;string&lt;/code&gt; must either use symbol name &lt;code&gt;a&lt;/code&gt; as the parameter or provide the symbol via the &lt;code&gt;parmName&lt;/code&gt; argument.</source>
          <target state="translated">표현식을 나타내는 &lt;code&gt;string&lt;/code&gt; 단항 함수로 변환 합니다. &lt;code&gt;string&lt;/code&gt; 중 하나를 사용 기호 명해야한다 매개 변수로 또는은을 통해 기호를 제공 &lt;code&gt;parmName&lt;/code&gt; 의 인수를. &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="7b88afb73f270a00af5effe51e0f8272f4aa3e3a" translate="yes" xml:space="preserve">
          <source>Translate init to an &lt;code&gt;Expression&lt;/code&gt; in order to infer the type.</source>
          <target state="translated">형식을 유추하기 위해 init를 &lt;code&gt;Expression&lt;/code&gt; 으로 변환 하십시오.</target>
        </trans-unit>
        <trans-unit id="959a6d1def925aa5efa951960e2388ce3ff0f34b" translate="yes" xml:space="preserve">
          <source>Translate init to an &lt;code&gt;Expression&lt;/code&gt;.</source>
          <target state="translated">init를 &lt;code&gt;Expression&lt;/code&gt; 으로 번역하십시오 .</target>
        </trans-unit>
        <trans-unit id="4b87d9bdcb57690f52a1f26d8df3d98e87cf8b7e" translate="yes" xml:space="preserve">
          <source>Translates &lt;code&gt;path&lt;/code&gt; into a relative path.</source>
          <target state="translated">&lt;code&gt;path&lt;/code&gt; 를 상대 경로 로 변환 합니다 .</target>
        </trans-unit>
        <trans-unit id="98dc0425ab3f9caa6b04fd152b154f235170a331" translate="yes" xml:space="preserve">
          <source>Translation to D of Linux's melf.h</source>
          <target state="translated">리눅스의 melf.h의 D 로의 번역</target>
        </trans-unit>
        <trans-unit id="a4f515edfc4806822304c5e5ba93f1584400280b" translate="yes" xml:space="preserve">
          <source>Transmission Control Protocol</source>
          <target state="translated">전송 제어 프로토콜</target>
        </trans-unit>
        <trans-unit id="65ee3b2fd39b9602bb0e6c467c899854326f9080" translate="yes" xml:space="preserve">
          <source>Transmission Control Protocol level</source>
          <target state="translated">전송 제어 프로토콜 수준</target>
        </trans-unit>
        <trans-unit id="392746932775e052b533e7404ac34fc0d43420a8" translate="yes" xml:space="preserve">
          <source>Transport And Map Symbols</source>
          <target state="translated">교통 및지도 기호</target>
        </trans-unit>
        <trans-unit id="bb1493e21daf9bc01d2c8bbab57c14f37d6e777e" translate="yes" xml:space="preserve">
          <source>Transposed!(RangeOfRanges, opt) &lt;strong id=&quot;transposed&quot;&gt;transposed&lt;/strong&gt;(TransverseOptions opt = TransverseOptions.assumeJagged, RangeOfRanges)(RangeOfRanges rr)</source>
          <target state="translated">Transposed! (RangeOfRanges, opt) &lt;strong id=&quot;transposed&quot;&gt;조옮김&lt;/strong&gt; (TransverseOptions opt = TransverseOptions.assumeJagged, RangeOfRanges) (RangeOfRanges rr)</target>
        </trans-unit>
        <trans-unit id="2cb4af12ae00a70b772cd041efc803dad1d5d955" translate="yes" xml:space="preserve">
          <source>Transposes a range of ranges.</source>
          <target state="translated">범위의 범위를 바꿉니다.</target>
        </trans-unit>
        <trans-unit id="4bca179998de8185466d7b4948059e2b6d46a32a" translate="yes" xml:space="preserve">
          <source>Transversal!(RangeOfRanges, opt) &lt;strong id=&quot;transversal&quot;&gt;transversal&lt;/strong&gt;(TransverseOptions opt = TransverseOptions.assumeJagged, RangeOfRanges)(RangeOfRanges rr, size_t n);</source>
          <target state="translated">횡단! (RangeOfRanges, opt) &lt;strong id=&quot;transversal&quot;&gt;횡단&lt;/strong&gt; (TransverseOptions opt = TransverseOptions.assumeJagged, RangeOfRanges) (RangeOfRanges rr, size_t n);</target>
        </trans-unit>
        <trans-unit id="89cf6770d26bcadaba07c91c703d1d100d7ecf19" translate="yes" xml:space="preserve">
          <source>Treap container for internal usage.</source>
          <target state="translated">내부 사용을위한 용기를 처리하십시오.</target>
        </trans-unit>
        <trans-unit id="0a9f92517de5b94ca2202e73bfb4ff1ae0e96219" translate="yes" xml:space="preserve">
          <source>Treat wildcard bind as AF_INET6-only</source>
          <target state="translated">와일드 카드 바인드를 AF_INET6 전용으로 취급</target>
        </trans-unit>
        <trans-unit id="2b931f6f03ddf3f11b6a931c301cd688e5837818" translate="yes" xml:space="preserve">
          <source>Treatment of invalid UTF encodings is implementation defined.</source>
          <target state="translated">유효하지 않은 UTF 인코딩의 처리는 구현으로 정의됩니다.</target>
        </trans-unit>
        <trans-unit id="7ca6b4d5d472cc8ae3e80819b582f65c3b7ce26a" translate="yes" xml:space="preserve">
          <source>Triangular numbers, using function in lambda form:</source>
          <target state="translated">람다 형식의 함수를 사용하는 삼각형 숫자 :</target>
        </trans-unit>
        <trans-unit id="9b543ca20b4da0104d2324c842cb2ec287022816" translate="yes" xml:space="preserve">
          <source>Trie</source>
          <target state="translated">Trie</target>
        </trans-unit>
        <trans-unit id="80d0235fc8480eef2ad4552832fe178049a6c3b3" translate="yes" xml:space="preserve">
          <source>Tries to receive but will give up if no matches arrive within duration. Won't wait at all if provided &lt;a href=&quot;core_time#Duration&quot;&gt;&lt;code&gt;core.time.Duration&lt;/code&gt;&lt;/a&gt; is negative.</source>
          <target state="translated">수신하려고 시도하지만 지속 시간 내에 일치하는 경기가 없으면 포기합니다. &lt;a href=&quot;core_time#Duration&quot;&gt; &lt;code&gt;core.time.Duration&lt;/code&gt; &lt;/a&gt; 이 음수 이면 제공되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="c45198e3a1cef5be9e9ea6378e5c328265a866c6" translate="yes" xml:space="preserve">
          <source>Trigger Name Table Name</source>
          <target state="translated">트리거 이름 테이블 이름</target>
        </trans-unit>
        <trans-unit id="bcd455ee5ad5e27e2fed7e5f2b4d193ba5b2dc98" translate="yes" xml:space="preserve">
          <source>Trigonometric functions on complex numbers.</source>
          <target state="translated">복소수에 대한 삼각 함수.</target>
        </trans-unit>
        <trans-unit id="89225146f512abd9863323c7f96ee652306f95de" translate="yes" xml:space="preserve">
          <source>Trigonometry</source>
          <target state="translated">Trigonometry</target>
        </trans-unit>
        <trans-unit id="9324b1be3eab89aaa4331826e321fe950cd6f28d" translate="yes" xml:space="preserve">
          <source>True if &lt;code&gt;S&lt;/code&gt; or any type directly embedded in the representation of &lt;code&gt;S&lt;/code&gt; defines an elaborate assignment. Elaborate assignments are introduced by defining &lt;code&gt;opAssign(typeof(this))&lt;/code&gt; or &lt;code&gt;opAssign(ref typeof(this))&lt;/code&gt; for a &lt;code&gt;struct&lt;/code&gt; or when there is a compiler-generated &lt;code&gt;opAssign&lt;/code&gt;.</source>
          <target state="translated">경우는 true &lt;code&gt;S&lt;/code&gt; 또는 직접의 표현에 포함 된 모든 종류의 &lt;code&gt;S&lt;/code&gt; 는 정교한 할당을 정의합니다. &lt;code&gt;opAssign(typeof(this))&lt;/code&gt; 또는 &lt;code&gt;opAssign(ref typeof(this))&lt;/code&gt; 을 &lt;code&gt;struct&lt;/code&gt; 하거나 컴파일러에서 생성 한 &lt;code&gt;opAssign&lt;/code&gt; 이있는 경우 정교한 할당이 도입됩니다 .</target>
        </trans-unit>
        <trans-unit id="435f68d9ae71393e298d71580ab5403b39c6eeb4" translate="yes" xml:space="preserve">
          <source>True if &lt;code&gt;S&lt;/code&gt; or any type directly embedded in the representation of &lt;code&gt;S&lt;/code&gt; defines an elaborate destructor. Elaborate destructors are introduced by defining &lt;code&gt;~this()&lt;/code&gt; for a &lt;code&gt; struct&lt;/code&gt;.</source>
          <target state="translated">경우는 true &lt;code&gt;S&lt;/code&gt; 또는 직접의 표현에 포함 된 모든 종류의 &lt;code&gt;S&lt;/code&gt; 는 정교한 소멸자를 정의합니다. &lt;code&gt; struct&lt;/code&gt; &lt;code&gt;~this()&lt;/code&gt; 를 정의하여 정교한 소멸자를 소개합니다 .</target>
        </trans-unit>
        <trans-unit id="a05d6bcd95b9d55e986b0af7bf4aba60806b34ed" translate="yes" xml:space="preserve">
          <source>True if &lt;code&gt;S&lt;/code&gt; or any type embedded directly in the representation of &lt;code&gt;S&lt;/code&gt; defines an elaborate copy constructor. Elaborate copy constructors are introduced by defining &lt;code&gt;this(this)&lt;/code&gt; for a &lt;code&gt;struct&lt;/code&gt;.</source>
          <target state="translated">경우는 true &lt;code&gt;S&lt;/code&gt; 또는 표현에 직접 포함 된 모든 종류의 &lt;code&gt;S&lt;/code&gt; 는 정교한 복사 생성자를 정의합니다. &lt;code&gt;struct&lt;/code&gt; 에 &lt;code&gt;this(this)&lt;/code&gt; 를 정의 하면 정교한 복사 생성자가 도입됩니다 .</target>
        </trans-unit>
        <trans-unit id="db144774838df48d1aab2237df1c1431f648dde1" translate="yes" xml:space="preserve">
          <source>True if &lt;code&gt;S&lt;/code&gt; or any type embedded directly in the representation of &lt;code&gt;S&lt;/code&gt; defines elaborate move semantics. Elaborate move semantics are introduced by defining &lt;code&gt;opPostMove(ref typeof(this))&lt;/code&gt; for a &lt;code&gt;struct&lt;/code&gt;.</source>
          <target state="translated">true의 경우 &lt;code&gt;S&lt;/code&gt; 또는 표현에 직접 포함 된 모든 종류의 &lt;code&gt;S&lt;/code&gt; 는 정교한 움직임의 의미를 정의한다. &lt;code&gt;struct&lt;/code&gt; 에 대해 &lt;code&gt;opPostMove(ref typeof(this))&lt;/code&gt; 를 정의하여 정교한 이동 의미론을 소개합니다 .</target>
        </trans-unit>
        <trans-unit id="83286feea43cbdff092efa76ecf7b71ba2f88e52" translate="yes" xml:space="preserve">
          <source>True if output is already ordered</source>
          <target state="translated">출력이 이미 주문 된 경우 참</target>
        </trans-unit>
        <trans-unit id="a07b7fa9f3e40c77f1c67f20db579672485bc6b7" translate="yes" xml:space="preserve">
          <source>True if the element existed and was successfully removed, false otherwise.</source>
          <target state="translated">요소가 존재하고 성공적으로 제거되면 true이고, 그렇지 않으면 false입니다.</target>
        </trans-unit>
        <trans-unit id="9ce4971f7bab09ad8525733035042183aaa85004" translate="yes" xml:space="preserve">
          <source>True if the instance is stopped. A stopped instance is not usable.</source>
          <target state="translated">인스턴스가 중지되면 true입니다. 중지 된 인스턴스는 사용할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="a4d0aeb9232f48bb1fab12af59602ee0a168f2c0" translate="yes" xml:space="preserve">
          <source>True if this object contains valid extended grapheme cluster. Decoding primitives of this module always return a valid &lt;code&gt;Grapheme&lt;/code&gt;.</source>
          <target state="translated">이 객체에 유효한 확장 된 grapheme 클러스터가 포함되어 있으면 true입니다. 이 모듈의 디코딩 프리미티브는 항상 유효한 &lt;code&gt;Grapheme&lt;/code&gt; 을 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="741d78e7c1f0bffb06939bcb7022d56f2f3604a6" translate="yes" xml:space="preserve">
          <source>True if this set doesn't contain any &lt;a href=&quot;#Code%20point&quot;&gt;code points&lt;/a&gt;.</source>
          <target state="translated">이 세트는 모든 포함하지 않는 경우 진정한 &lt;a href=&quot;#Code%20point&quot;&gt;코드 포인트를&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="a7044bfa031ab131bad87130e1755ca8c06a8fda" translate="yes" xml:space="preserve">
          <source>True when the archive is in Zip64 format.</source>
          <target state="translated">아카이브가 Zip64 형식 인 경우 참입니다.</target>
        </trans-unit>
        <trans-unit id="f9be005b0435403e870851df7d4131f3a0109ac9" translate="yes" xml:space="preserve">
          <source>Trusted Functions</source>
          <target state="translated">신뢰할 수있는 기능</target>
        </trans-unit>
        <trans-unit id="40f12844940629afacea122912b44fee54a96dc6" translate="yes" xml:space="preserve">
          <source>Trusted functions are covariant with safe or system functions.</source>
          <target state="translated">신뢰할 수있는 기능은 안전 또는 시스템 기능과 공변합니다.</target>
        </trans-unit>
        <trans-unit id="b81cf6c642ef243859e62c2673b1273c1506df41" translate="yes" xml:space="preserve">
          <source>Trusted functions are guaranteed to not exhibit any undefined behavior if called by a safe function. Furthermore, calls to trusted functions cannot lead to undefined behavior in &lt;code&gt;@safe&lt;/code&gt; code that is executed afterwards. It is the responsibility of the programmer to ensure that these guarantees are upheld.</source>
          <target state="translated">안전한 함수에 의해 호출 된 경우 신뢰할 수있는 함수는 정의되지 않은 동작을 나타내지 않습니다. 또한 신뢰할 수있는 함수를 호출하면 나중에 실행되는 &lt;code&gt;@safe&lt;/code&gt; 코드 에서 정의되지 않은 동작이 발생할 수 없습니다 . 이러한 보증을 유지하는 것은 프로그래머의 책임입니다.</target>
        </trans-unit>
        <trans-unit id="e99ece345b7d4461848926cc1472e577d410e5e4" translate="yes" xml:space="preserve">
          <source>Trusted functions are marked with the &lt;code&gt;@trusted&lt;/code&gt; attribute.</source>
          <target state="translated">신뢰할 수있는 기능에는 &lt;code&gt;@trusted&lt;/code&gt; 속성 이 표시됩니다 .</target>
        </trans-unit>
        <trans-unit id="44bf3c1616a6357f7a131b6c0a39fc313c94e84c" translate="yes" xml:space="preserve">
          <source>Trusted functions may call safe, trusted, or system functions.</source>
          <target state="translated">신뢰할 수있는 기능은 안전, 신뢰성 또는 시스템 기능을 호출 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="459c8d9a1e6d3847007459ddd42920c4db61b906" translate="yes" xml:space="preserve">
          <source>Truth table for logical operations</source>
          <target state="translated">논리 연산을위한 진리표</target>
        </trans-unit>
        <trans-unit id="13da7fbcb3f25e75b715c9fd87fc1fcc65959500" translate="yes" xml:space="preserve">
          <source>Try Statement</source>
          <target state="translated">시험판</target>
        </trans-unit>
        <trans-unit id="1ed4257452c884a8b0797028299d6b533a605ed8" translate="yes" xml:space="preserve">
          <source>Try to canonically compose 2 &lt;a href=&quot;#Character&quot;&gt;characters&lt;/a&gt;. Returns the composed &lt;a href=&quot;#Character&quot;&gt;character&lt;/a&gt; if they do compose and dchar.init otherwise.</source>
          <target state="translated">정식으로 2 &lt;a href=&quot;#Character&quot;&gt;자를&lt;/a&gt; 작성해보십시오 . 작성된 &lt;a href=&quot;#Character&quot;&gt;문자를&lt;/a&gt; 작성하고 그렇지 않으면 dchar.init를 리턴합니다 .</target>
        </trans-unit>
        <trans-unit id="af1dc631a797cf3323aa1ab6b455b4f41ff959a7" translate="yes" xml:space="preserve">
          <source>Try to compose hangul syllable out of a leading consonant (&lt;code&gt;lead&lt;/code&gt;), a &lt;code&gt;vowel&lt;/code&gt; and optional &lt;code&gt;trailing&lt;/code&gt; consonant jamos.</source>
          <target state="translated">선도적 인 자음 (의 한글 음절을 구성하려고 &lt;code&gt;lead&lt;/code&gt; ,)는 &lt;code&gt;vowel&lt;/code&gt; 과 옵션 &lt;code&gt;trailing&lt;/code&gt; 자음의 자모를.</target>
        </trans-unit>
        <trans-unit id="2f882d1c819b2be8fca22d9247747ab281b24bcf" translate="yes" xml:space="preserve">
          <source>Try to get arg as a type.</source>
          <target state="translated">arg를 유형으로 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="4cb5c2463fdeee729189be2318f4a45f82417dad" translate="yes" xml:space="preserve">
          <source>Try to run semantic routines. If they fail, return NULL.</source>
          <target state="translated">시맨틱 루틴을 실행하십시오. 실패하면 NULL을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="2e3437da5d7c211579a17d9d89d77ab06ca5cfe0" translate="yes" xml:space="preserve">
          <source>Try to stop forgetting to remove the breakpoints from release builds.</source>
          <target state="translated">릴리스 빌드에서 중단 점을 제거하는 것을 잊지 마십시오.</target>
        </trans-unit>
        <trans-unit id="bd89ac0e2f8d21f48d2dd844d0cfaadc52595afa" translate="yes" xml:space="preserve">
          <source>TryFinallyStatement &lt;strong id=&quot;tf&quot;&gt;tf&lt;/strong&gt;;</source>
          <target state="translated">TryFinallyStatement &lt;strong id=&quot;tf&quot;&gt;tf&lt;/strong&gt; ;</target>
        </trans-unit>
        <trans-unit id="7b1fdcae82a3bda8500a782276a90907df015b0b" translate="yes" xml:space="preserve">
          <source>TryStatement</source>
          <target state="translated">TryStatement</target>
        </trans-unit>
        <trans-unit id="db36ec316b7f2d3519063434cfdeb6b15e62e78d" translate="yes" xml:space="preserve">
          <source>Trying to use returned value will result in a &quot;Symbol Undefined&quot; error at link time.</source>
          <target state="translated">반환 된 값을 사용하려고하면 링크 타임에 &quot;Symbol Undefined&quot;오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="c41a2be51027c17da2914785c19c9af65da7231f" translate="yes" xml:space="preserve">
          <source>Tuple</source>
          <target state="translated">Tuple</target>
        </trans-unit>
        <trans-unit id="81493a4efae126007a86642029f330ea19b00d39" translate="yes" xml:space="preserve">
          <source>Tuple containing the remainder portions of r1 and r2 that were not swapped</source>
          <target state="translated">교체되지 않은 r1 및 r2의 나머지 부분을 포함하는 튜플</target>
        </trans-unit>
        <trans-unit id="0334a3ee71c30886045ce944919d843672b82a98" translate="yes" xml:space="preserve">
          <source>Tuple of result identifier (possibly null) and statement. This is used to store out contracts: out(id){ ensure }</source>
          <target state="translated">결과 식별자 (널일 수도 있음) 및 명령문의 튜플. 계약을 저장하는 데 사용됩니다. out (id) {ensure}</target>
        </trans-unit>
        <trans-unit id="fe605913e40c1b2d66822716dc9acacaef59b4a5" translate="yes" xml:space="preserve">
          <source>Tuple of values, for example &lt;code&gt;Tuple!(int, string)&lt;/code&gt; is a record that stores an &lt;code&gt;int&lt;/code&gt; and a &lt;code&gt;string&lt;/code&gt;. &lt;code&gt;Tuple&lt;/code&gt; can be used to bundle values together, notably when returning multiple values from a function. If &lt;code&gt;obj&lt;/code&gt; is a &lt;code&gt;Tuple&lt;/code&gt;, the individual members are accessible with the syntax &lt;code&gt;obj[0]&lt;/code&gt; for the first field, &lt;code&gt;obj[1]&lt;/code&gt; for the second, and so on.</source>
          <target state="translated">Tuple &lt;code&gt;Tuple!(int, string)&lt;/code&gt; 과 같은 값의 튜플은 &lt;code&gt;int&lt;/code&gt; 및 &lt;code&gt;string&lt;/code&gt; 을 저장하는 레코드입니다 . &lt;code&gt;Tuple&lt;/code&gt; 은 특히 ​​함수에서 여러 값을 반환 할 때 값을 함께 묶는 데 사용할 수 있습니다. 경우 &lt;code&gt;obj&lt;/code&gt; 가 A는 &lt;code&gt;Tuple&lt;/code&gt; 개별 회원 구문으로 액세스 &lt;code&gt;obj[0]&lt;/code&gt; 첫번째 필드, &lt;code&gt;obj[1]&lt;/code&gt; 제 대 등.</target>
        </trans-unit>
        <trans-unit id="0a9986e9aa2ae5162b29264e46abc7e827c1fef4" translate="yes" xml:space="preserve">
          <source>Tuple with the first element being the minimal amount of edits to transform s into t and the second element being the sequence of edits to effect this transformation.  Allocates GC memory for the returned EditOp[] array.</source>
          <target state="translated">첫 번째 요소가 s를 t로 변환하기위한 최소 편집 량 인 튜플이고 두 번째 요소가이 변환에 영향을주는 편집 순서 인 튜플입니다. 반환 된 EditOp [] 배열에 GC 메모리를 할당합니다.</target>
        </trans-unit>
        <trans-unit id="ca82eca51bdda72eb0ed74065cca566ee0b72807" translate="yes" xml:space="preserve">
          <source>Tuple!(ElementType!Range, size_t) &lt;strong id=&quot;maxCount&quot;&gt;maxCount&lt;/strong&gt;(alias pred = &quot;a &amp;lt; b&quot;, Range)(Range range)</source>
          <target state="translated">튜플! (ElementType! Range, size_t) &lt;strong id=&quot;maxCount&quot;&gt;maxCount&lt;/strong&gt; (별칭 pred = &quot;a &amp;lt;b&quot;, 범위) (범위 범위)</target>
        </trans-unit>
        <trans-unit id="c94a9ad6dc26bde095208b9742dea8d55cd74e36" translate="yes" xml:space="preserve">
          <source>Tuple!(ElementType!Range, size_t) &lt;strong id=&quot;minCount&quot;&gt;minCount&lt;/strong&gt;(alias pred = &quot;a &amp;lt; b&quot;, Range)(Range range)</source>
          <target state="translated">튜플! (ElementType! Range, size_t) &lt;strong id=&quot;minCount&quot;&gt;minCount&lt;/strong&gt; (별칭 pred = &quot;a &amp;lt;b&quot;, 범위) (범위 범위)</target>
        </trans-unit>
        <trans-unit id="5b8d3e9bf7e07ed5d350fa5b6dce75fa73629a67" translate="yes" xml:space="preserve">
          <source>Tuple!(InputRange1, InputRange2) &lt;strong id=&quot;moveSome&quot;&gt;moveSome&lt;/strong&gt;(InputRange1, InputRange2)(InputRange1 src, InputRange2 tgt)</source>
          <target state="translated">튜플! (InputRange1, InputRange2) &lt;strong id=&quot;moveSome&quot;&gt;moveSome&lt;/strong&gt; (InputRange1, InputRange2) (InputRange1 src, InputRange2 tgt)</target>
        </trans-unit>
        <trans-unit id="06252b12aadc6855e3f6a48094435d5ba0fef2ac" translate="yes" xml:space="preserve">
          <source>Tuple!(InputRange1, InputRange2) &lt;strong id=&quot;swapRanges&quot;&gt;swapRanges&lt;/strong&gt;(InputRange1, InputRange2)(InputRange1 r1, InputRange2 r2)</source>
          <target state="translated">튜플! (InputRange1, InputRange2) &lt;strong id=&quot;swapRanges&quot;&gt;swapRanges&lt;/strong&gt; (InputRange1, InputRange2) (InputRange1 r1, InputRange2 r2)</target>
        </trans-unit>
        <trans-unit id="bce2cc2678db91fbec2284d40957048f616f80c5" translate="yes" xml:space="preserve">
          <source>Tuple!(Module, &quot;module_&quot;, Diagnostics, &quot;diagnostics&quot;) &lt;strong id=&quot;parseModule&quot;&gt;parseModule&lt;/strong&gt;(AST = ASTCodegen)(const(char)[] fileName, const(char)[] code = null, DiagnosticReporter diagnosticReporter = defaultDiagnosticReporter);</source>
          <target state="translated">Tuple! (모듈, &quot;module_&quot;, 진단, &quot;진단&quot;) &lt;strong id=&quot;parseModule&quot;&gt;parseModule&lt;/strong&gt; (AST = ASTCodegen) (const (char) [] fileName, const (char) [] code = null, DiagnosticReporter diagnosticReporter = defaultDiagnosticReporter);</target>
        </trans-unit>
        <trans-unit id="ecf8ee3baa7b9c5aeb7e04fdf957e2203fbab0aa" translate="yes" xml:space="preserve">
          <source>Tuple!(Range, size_t) &lt;strong id=&quot;find&quot;&gt;find&lt;/strong&gt;(alias pred = &quot;a == b&quot;, Range, Ranges...)(Range haystack, Ranges needles)</source>
          <target state="translated">튜플! (범위, size_t) &lt;strong id=&quot;find&quot;&gt;찾기&lt;/strong&gt; (별칭 pred = &quot;a == b&quot;, 범위, 범위 ...) (범위 건초 더미, 범위 바늘)</target>
        </trans-unit>
        <trans-unit id="95cc77bd73a8dcdc8783b1903366dc167f6f0405" translate="yes" xml:space="preserve">
          <source>Tuple!(Range1, Range2) &lt;strong id=&quot;mismatch&quot;&gt;mismatch&lt;/strong&gt;(alias pred = &quot;a == b&quot;, Range1, Range2)(Range1 r1, Range2 r2)</source>
          <target state="translated">Tuple! (Range1, Range2) &lt;strong id=&quot;mismatch&quot;&gt;불일치&lt;/strong&gt; (별칭 pred = &quot;a == b&quot;, Range1, Range2) (Range1 r1, Range2 r2)</target>
        </trans-unit>
        <trans-unit id="000cf2a61823c3534d53f39458b33b8bdccf2670" translate="yes" xml:space="preserve">
          <source>Tuple!(T, &quot;x&quot;, Unqual!(ReturnType!DF), &quot;y&quot;, T, &quot;error&quot;) &lt;strong id=&quot;findLocalMin&quot;&gt;findLocalMin&lt;/strong&gt;(T, DF)(scope DF f, in T ax, in T bx, in T relTolerance = sqrt(T.epsilon), in T absTolerance = sqrt(T.epsilon))</source>
          <target state="translated">Tuple! (T, &quot;x&quot;, Unqual! (ReturnType! DF), &quot;y&quot;, T, &quot;error&quot;) &lt;strong id=&quot;findLocalMin&quot;&gt;findLocalMin&lt;/strong&gt; (T, DF) (scope DF f, T ax, T bx, T relTolerance = sqrt (T.epsilon), T absTolerance = sqrt (T.epsilon))</target>
        </trans-unit>
        <trans-unit id="840acdf57ba98e4920f2fbec545eb130df4593a8" translate="yes" xml:space="preserve">
          <source>Tuple!(T, T, R, R) &lt;strong id=&quot;findRoot&quot;&gt;findRoot&lt;/strong&gt;(T, R, DF)(scope DF f, in T ax, in T bx, in R fax, in R fbx);</source>
          <target state="translated">튜플! (T, T, R, R) &lt;strong id=&quot;findRoot&quot;&gt;findRoot&lt;/strong&gt; (T, R, DF) (스코프 DF f, T ax, T bx, R 팩스, R fbx);</target>
        </trans-unit>
        <trans-unit id="51994771db6a3d28fa759af046d2c850390305a5" translate="yes" xml:space="preserve">
          <source>Tuple!(T, T, R, R) &lt;strong id=&quot;findRoot&quot;&gt;findRoot&lt;/strong&gt;(T, R, DF, DT)(scope DF f, in T ax, in T bx, in R fax, in R fbx, scope DT tolerance)</source>
          <target state="translated">튜플! (T, T, R, R) &lt;strong id=&quot;findRoot&quot;&gt;findRoot&lt;/strong&gt; (T, R, DF, DT) (스코프 DF f, T ax, T bx, R 팩스, R fbx, 범위 DT 공차)</target>
        </trans-unit>
        <trans-unit id="639ddd2f21c13c7af4c3fc3a46fe3e1d7b82673a" translate="yes" xml:space="preserve">
          <source>Tuple!(size_t, EditOp[]) &lt;strong id=&quot;levenshteinDistanceAndPath&quot;&gt;levenshteinDistanceAndPath&lt;/strong&gt;(alias equals = (a, b) =&amp;gt; a == b, Range1, Range2)(Range1 s, Range2 t)</source>
          <target state="translated">튜플! (size_t, EditOp []) &lt;strong id=&quot;levenshteinDistanceAndPath&quot;&gt;levenshteinDistanceAndPath&lt;/strong&gt; (별칭 = (a, b) =&amp;gt; a == b, Range1, Range2) (Range1 s, Range2 t)</target>
        </trans-unit>
        <trans-unit id="c0c86644914e59cf3e95dc2d9e3358d7adb8b024" translate="yes" xml:space="preserve">
          <source>Tuple!(size_t, EditOp[]) &lt;strong id=&quot;levenshteinDistanceAndPath&quot;&gt;levenshteinDistanceAndPath&lt;/strong&gt;(alias equals = (a, b) =&amp;gt; a == b, Range1, Range2)(auto ref Range1 s, auto ref Range2 t)</source>
          <target state="translated">튜플! (size_t, EditOp []) &lt;strong id=&quot;levenshteinDistanceAndPath&quot;&gt;levenshteinDistanceAndPath&lt;/strong&gt; (별칭 = (a, b) =&amp;gt; a == b, Range1, Range2) (자동 참조 Range1 s, 자동 참조 Range2 t)</target>
        </trans-unit>
        <trans-unit id="b4ce998808efbe7007c7ba094a0ff589456afbc6" translate="yes" xml:space="preserve">
          <source>TupleDeclaration &lt;strong id=&quot;isAliasThisTuple&quot;&gt;isAliasThisTuple&lt;/strong&gt;(Expression e);</source>
          <target state="translated">Tuple 선언 &lt;strong id=&quot;isAliasThisTuple&quot;&gt;isAliasThisTuple&lt;/strong&gt; (식 e);</target>
        </trans-unit>
        <trans-unit id="80678cb1445455517d232f6976a2ee0f4da0533a" translate="yes" xml:space="preserve">
          <source>TupleForeachRet!(isStatic, isDecl) &lt;strong id=&quot;makeTupleForeach&quot;&gt;makeTupleForeach&lt;/strong&gt;(bool isStatic, bool isDecl)(Scope* sc, ForeachStatement fs, TupleForeachArgs!(isStatic, isDecl) args);</source>
          <target state="translated">TupleForeachRet! (isStatic, isDecl) &lt;strong id=&quot;makeTupleForeach&quot;&gt;makeTupleForeach&lt;/strong&gt; (bool isStatic, bool isDecl) (Scope * sc, ForeachStatement fs, TupleForeachArgs! (isStatic, isDecl) args);</target>
        </trans-unit>
        <trans-unit id="6584111cad42d4105dd8e9be93a1310902d91e92" translate="yes" xml:space="preserve">
          <source>Tuples of two integral offsets can be used to remove an indices range:</source>
          <target state="translated">두 가지 정수 오프셋의 튜플을 사용하여 인덱스 범위를 제거 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d9a474dda4f883ffd7fcbe2488c48bb66a58fbd7" translate="yes" xml:space="preserve">
          <source>Turn DT_azeros into DTcommon</source>
          <target state="translated">DT_azeros를 DTcommon으로 변환</target>
        </trans-unit>
        <trans-unit id="b124a21a659b94416124a0c6d11837b408eec822" translate="yes" xml:space="preserve">
          <source>Turn StringExp into Symbol.</source>
          <target state="translated">StringExp를 Symbol로 바꿉니다.</target>
        </trans-unit>
        <trans-unit id="e5fc19e75828d2a9872def0cc347c568479bfe06" translate="yes" xml:space="preserve">
          <source>Turn bundling off (default)</source>
          <target state="translated">번들링 끄기 (기본값)</target>
        </trans-unit>
        <trans-unit id="bba5b8eb4f9f33288234c4eea8f1ef87433a4f05" translate="yes" xml:space="preserve">
          <source>Turn bundling on</source>
          <target state="translated">번들링 켜기</target>
        </trans-unit>
        <trans-unit id="902547bf87091225cc20e88f552ffa5d6f0ad9d8" translate="yes" xml:space="preserve">
          <source>Turn case sensitivity off (default)</source>
          <target state="translated">대소 문자 구분 끄기 (기본값)</target>
        </trans-unit>
        <trans-unit id="62ba7010a40283d77918d8073bba5d1ed5b505cc" translate="yes" xml:space="preserve">
          <source>Turn case sensitivity on</source>
          <target state="translated">대소 문자 구분 켜기</target>
        </trans-unit>
        <trans-unit id="74f2dbf84af28045a37d376cd4e1edd3fa01e659" translate="yes" xml:space="preserve">
          <source>Turn next token in buffer into a token.</source>
          <target state="translated">버퍼의 다음 토큰을 토큰으로 바꿉니다.</target>
        </trans-unit>
        <trans-unit id="5e3e0a4844ec64b01594e006a743ab91237a31f0" translate="yes" xml:space="preserve">
          <source>Turn off &lt;code&gt;STC.maybescope&lt;/code&gt; for variable &lt;code&gt;v&lt;/code&gt;.</source>
          <target state="translated">변수 &lt;code&gt;v&lt;/code&gt; 에 대해 &lt;code&gt;STC.maybescope&lt;/code&gt; 를 끄십시오 .</target>
        </trans-unit>
        <trans-unit id="84cccbe55a872601d865bab8ec58d82539ff0a07" translate="yes" xml:space="preserve">
          <source>Turn on wildcard matching</source>
          <target state="translated">와일드 카드 일치 사용</target>
        </trans-unit>
        <trans-unit id="a87d900130ba3c16a326f82759f1060e5ae35223" translate="yes" xml:space="preserve">
          <source>Turn symbol &lt;code&gt;s&lt;/code&gt; into the expression it represents.</source>
          <target state="translated">기호 돌려 &lt;code&gt;s&lt;/code&gt; 가 나타내는 표현으로.</target>
        </trans-unit>
        <trans-unit id="e5a454f3b1345dd58c63efa8e881a860cfb32111" translate="yes" xml:space="preserve">
          <source>Two adjacent separators are considered to surround an empty element in the split range. Use &lt;code&gt;filter!(a =&amp;gt; !a.empty)&lt;/code&gt; on the result to compress empty elements.</source>
          <target state="translated">두 개의 인접한 분리기는 분리 범위에서 빈 요소를 둘러싸는 것으로 간주됩니다. 사용 &lt;code&gt;filter!(a =&amp;gt; !a.empty)&lt;/code&gt; 결과에 빈 요소를 압축한다.</target>
        </trans-unit>
        <trans-unit id="e3ed11541d2964198473ed0a82426d9b49c8d63f" translate="yes" xml:space="preserve">
          <source>Two format specifiers are supported:</source>
          <target state="translated">두 가지 형식 지정자가 지원됩니다.</target>
        </trans-unit>
        <trans-unit id="f728c436a5d60ae7a74a1fb01d9c670443ddbdc1" translate="yes" xml:space="preserve">
          <source>Two functions have been added for convenience:</source>
          <target state="translated">편의를 위해 두 가지 기능이 추가되었습니다.</target>
        </trans-unit>
        <trans-unit id="241f31fb40e72ec287fecd2a2aa243010af09b63" translate="yes" xml:space="preserve">
          <source>Two local variables &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt; are in different contexts, but outer context is indirectly accessible from innter context, so nested template instance &lt;code&gt;sum!(a, b)&lt;/code&gt; will capture only inner context.</source>
          <target state="translated">두 개의 로컬 변수 &lt;code&gt;a&lt;/code&gt; 와 &lt;code&gt;b&lt;/code&gt; 는 서로 다른 컨텍스트에 있지만 외부 컨텍스트는 innter 컨텍스트에서 간접적으로 액세스 할 수 있으므로 중첩 된 템플릿 인스턴스 &lt;code&gt;sum!(a, b)&lt;/code&gt; 는 내부 컨텍스트 만 캡처합니다.</target>
        </trans-unit>
        <trans-unit id="7344649ec3349339576b149dc016e926290914de" translate="yes" xml:space="preserve">
          <source>Two or more non-infinite forward ranges</source>
          <target state="translated">두 개 이상의 무한대 범위</target>
        </trans-unit>
        <trans-unit id="541bef60f707acc034ee30fb6ceb5b604a068f40" translate="yes" xml:space="preserve">
          <source>Two versions of programs are commonly built, a release build and a debug build. The debug build includes extra error checking code, test harnesses, pretty-printing code, etc. The debug statement conditionally compiles in its statement body. It is D's way of what in C is done with &lt;code&gt;#ifdef DEBUG&lt;/code&gt; / &lt;code&gt;#endif&lt;/code&gt; pairs.</source>
          <target state="translated">릴리스 빌드와 디버그 빌드라는 두 가지 버전의 프로그램이 일반적으로 빌드됩니다. 디버그 빌드에는 추가 오류 검사 코드, 테스트 하네스, 예쁜 인쇄 코드 등이 포함됩니다. 디버그 명령문은 명령문 본문에서 조건부로 컴파일됩니다. C에서 &lt;code&gt;#ifdef DEBUG&lt;/code&gt; / &lt;code&gt;#endif&lt;/code&gt; 쌍으로 수행되는 방식은 D 입니다.</target>
        </trans-unit>
        <trans-unit id="3deb7456519697ecf4eefc455516c969a3681bae" translate="yes" xml:space="preserve">
          <source>Type</source>
          <target state="translated">Type</target>
        </trans-unit>
        <trans-unit id="96e4f0ac6a824b3c4a6ad224979d9909d711bd86" translate="yes" xml:space="preserve">
          <source>Type &lt;code&gt;T&lt;/code&gt; can be one of:</source>
          <target state="translated">유형 &lt;code&gt;T&lt;/code&gt; 는 다음 중 하나 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="074961b98338169a77631354ecc98de531ee94fd" translate="yes" xml:space="preserve">
          <source>Type &lt;code&gt;itype&lt;/code&gt;</source>
          <target state="translated">타입 &lt;code&gt;itype&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="abcae8ebd4b965d368a249e36f4d23c1e65f3bc6" translate="yes" xml:space="preserve">
          <source>Type &lt;code&gt;mt&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;mt&lt;/code&gt; 유형</target>
        </trans-unit>
        <trans-unit id="96b17264511c000a8d2d312a068c77228139ea5b" translate="yes" xml:space="preserve">
          <source>Type &lt;code&gt;stype&lt;/code&gt;</source>
          <target state="translated">타입 &lt;code&gt;stype&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="b088eef787c263bc72b35d7bf8bffb02250f35af" translate="yes" xml:space="preserve">
          <source>Type &lt;code&gt;t1&lt;/code&gt;</source>
          <target state="translated">타입 &lt;code&gt;t1&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="7dce03ad43b5e48ad6926eff66da1dc0fbd992e8" translate="yes" xml:space="preserve">
          <source>Type &lt;code&gt;t2&lt;/code&gt;</source>
          <target state="translated">타입 &lt;code&gt;t2&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="1f8a5d9f738e3ec7573a4c3d2bfa71c9dab55055" translate="yes" xml:space="preserve">
          <source>Type &lt;code&gt;t&lt;/code&gt;</source>
          <target state="translated">타입 &lt;code&gt;t&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="c297c055e8021da1038d32c6451a431dc0cd79a4" translate="yes" xml:space="preserve">
          <source>Type &lt;code&gt;tfrom&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;tfrom&lt;/code&gt; 유형</target>
        </trans-unit>
        <trans-unit id="be5260cde80d2a83f5fa8c9f051bba7fb9b67140" translate="yes" xml:space="preserve">
          <source>Type &lt;code&gt;torig&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;torig&lt;/code&gt; 타입</target>
        </trans-unit>
        <trans-unit id="265bebeeaa74df34bb2463a7ccd6495a2fd2b3e7" translate="yes" xml:space="preserve">
          <source>Type &lt;code&gt;tthis&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;tthis&lt;/code&gt; 를 입력 하십시오</target>
        </trans-unit>
        <trans-unit id="d90e13e3fed6c33599ffe3adfef07d6fecfb113f" translate="yes" xml:space="preserve">
          <source>Type &lt;code&gt;tto&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;tto&lt;/code&gt; 타입</target>
        </trans-unit>
        <trans-unit id="ac37939248da7ca7fc509e594e3e1162b28e7f03" translate="yes" xml:space="preserve">
          <source>Type &lt;code&gt;type&lt;/code&gt;</source>
          <target state="translated">유형 &lt;code&gt;type&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="fa75b76e3b4d199eb5bf1cbe330006d90e593043" translate="yes" xml:space="preserve">
          <source>Type &lt;strong id=&quot;addStorageClass&quot;&gt;addStorageClass&lt;/strong&gt;(StorageClass stc);</source>
          <target state="translated">입력 &lt;strong id=&quot;addStorageClass&quot;&gt;addStorageClass을&lt;/strong&gt; (StorageClass STC);</target>
        </trans-unit>
        <trans-unit id="d84d22937a28d260576af02a61a011cb7b2b2cc5" translate="yes" xml:space="preserve">
          <source>Type &lt;strong id=&quot;compileTypeMixin&quot;&gt;compileTypeMixin&lt;/strong&gt;(TypeMixin tm, Loc loc, Scope* sc);</source>
          <target state="translated">입력 &lt;strong id=&quot;compileTypeMixin&quot;&gt;compileTypeMixin&lt;/strong&gt; (TypeMixin의 TM, LOC는 LOC, 범위 * 사우스 캐롤라이나)</target>
        </trans-unit>
        <trans-unit id="c24f3c59131a7c5a8bc5e783fc5e665af1b32a5e" translate="yes" xml:space="preserve">
          <source>Type &lt;strong id=&quot;getIndirection&quot;&gt;getIndirection&lt;/strong&gt;(Type t);</source>
          <target state="translated">입력 &lt;strong id=&quot;getIndirection&quot;&gt;getIndirection&lt;/strong&gt; (T 형)를;</target>
        </trans-unit>
        <trans-unit id="c2b92e082fd5a3ac4a7a6baf60cbd699edacc254" translate="yes" xml:space="preserve">
          <source>Type &lt;strong id=&quot;getTypeInfoType&quot;&gt;getTypeInfoType&lt;/strong&gt;(Loc loc, Type t, Scope* sc);</source>
          <target state="translated">입력 &lt;strong id=&quot;getTypeInfoType&quot;&gt;getTypeInfoType&lt;/strong&gt; (LOC는 LOC, T 형, 범위 * 사우스 캐롤라이나)</target>
        </trans-unit>
        <trans-unit id="7988a8b265a00347de81079da3fe4590a68ee7ca" translate="yes" xml:space="preserve">
          <source>Type &lt;strong id=&quot;isLazyArray&quot;&gt;isLazyArray&lt;/strong&gt;();</source>
          <target state="translated">&lt;strong id=&quot;isLazyArray&quot;&gt;isLazyArray&lt;/strong&gt; 유형 ();</target>
        </trans-unit>
        <trans-unit id="f4d3b40b91dc28c4e5940a35bf69a0bbb241540d" translate="yes" xml:space="preserve">
          <source>Type &lt;strong id=&quot;merge&quot;&gt;merge&lt;/strong&gt;(Type type);</source>
          <target state="translated">타입 &lt;strong id=&quot;merge&quot;&gt;병합&lt;/strong&gt; (Type type);</target>
        </trans-unit>
        <trans-unit id="35806f9ee47f3dd812d869bb49adecc56fab810b" translate="yes" xml:space="preserve">
          <source>Type &lt;strong id=&quot;nextOf&quot;&gt;nextOf&lt;/strong&gt;();</source>
          <target state="translated">&lt;strong id=&quot;nextOf&quot;&gt;nextOf&lt;/strong&gt; ()를 입력 &lt;strong id=&quot;nextOf&quot;&gt;하십시오&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="87e0a9680f0eea47764ac3ffa10dd8d73e88aeee" translate="yes" xml:space="preserve">
          <source>Type &lt;strong id=&quot;parameterType&quot;&gt;parameterType&lt;/strong&gt;(Parameter p);</source>
          <target state="translated">유형 &lt;strong id=&quot;parameterType&quot;&gt;매개 변수&lt;/strong&gt; 유형 (매개 변수 p);</target>
        </trans-unit>
        <trans-unit id="7016ea73ad39a852ab2478cb095dfe5d455408a3" translate="yes" xml:space="preserve">
          <source>Type &lt;strong id=&quot;stype&quot;&gt;stype&lt;/strong&gt;;</source>
          <target state="translated">&lt;strong id=&quot;stype&quot;&gt;stype을&lt;/strong&gt; 입력하십시오 ;</target>
        </trans-unit>
        <trans-unit id="deae4e726d62ba433ff0fa85c1e57f1770faea08" translate="yes" xml:space="preserve">
          <source>Type &lt;strong id=&quot;tintro&quot;&gt;tintro&lt;/strong&gt;;</source>
          <target state="translated">입력 &lt;strong id=&quot;tintro&quot;&gt;tintro을&lt;/strong&gt; ;</target>
        </trans-unit>
        <trans-unit id="1eadd5370543a51dcc388d2fe2066cef28052c13" translate="yes" xml:space="preserve">
          <source>Type &lt;strong id=&quot;toBasetype&quot;&gt;toBasetype&lt;/strong&gt;();</source>
          <target state="translated">Type &lt;strong id=&quot;toBasetype&quot;&gt;toBasetype&lt;/strong&gt; ();</target>
        </trans-unit>
        <trans-unit id="a8533c3e5233456fb672ac9c547f329a114136e2" translate="yes" xml:space="preserve">
          <source>Type &lt;strong id=&quot;toHeadMutable&quot;&gt;toHeadMutable&lt;/strong&gt;();</source>
          <target state="translated">&lt;strong id=&quot;toHeadMutable&quot;&gt;toHeadMutable&lt;/strong&gt; ()을 입력 &lt;strong id=&quot;toHeadMutable&quot;&gt;하십시오&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="96b0f23e070ede5bec63f5e83cdeac74f8089165" translate="yes" xml:space="preserve">
          <source>Type &lt;strong id=&quot;typeSemantic&quot;&gt;typeSemantic&lt;/strong&gt;(Type t, Loc loc, Scope* sc);</source>
          <target state="translated">타입 타입 &lt;strong id=&quot;typeSemantic&quot;&gt;시맨틱&lt;/strong&gt; (Type t, Loc loc, Scope * sc);</target>
        </trans-unit>
        <trans-unit id="5d4688f5531e8a08ef8e0ff730f862cace988d3d" translate="yes" xml:space="preserve">
          <source>Type &lt;strong id=&quot;va_listType&quot;&gt;va_listType&lt;/strong&gt;();</source>
          <target state="translated">&lt;strong id=&quot;va_listType&quot;&gt;va_listType&lt;/strong&gt; ()을 입력 &lt;strong id=&quot;va_listType&quot;&gt;하십시오&lt;/strong&gt; ;</target>
        </trans-unit>
        <trans-unit id="4f59c6d42771bbb84c27a2121ad3681f0bb72d20" translate="yes" xml:space="preserve">
          <source>Type AST node</source>
          <target state="translated">AST 노드 유형</target>
        </trans-unit>
        <trans-unit id="5e1573953474c6c0a25673b1f064154b46a8a93e" translate="yes" xml:space="preserve">
          <source>Type Conversion</source>
          <target state="translated">타입 변환</target>
        </trans-unit>
        <trans-unit id="c6b7ec08c1e42e9023620d7d964ae0eef2d20644" translate="yes" xml:space="preserve">
          <source>Type Mangling</source>
          <target state="translated">타입 맨 글링</target>
        </trans-unit>
        <trans-unit id="264ee4dfa69c98ad557b3342fe8cc1e2b97db3e7" translate="yes" xml:space="preserve">
          <source>Type Qualifiers</source>
          <target state="translated">한정자</target>
        </trans-unit>
        <trans-unit id="edc9c0e21717c816a5ec56b1e42647baf2336f1d" translate="yes" xml:space="preserve">
          <source>Type Qualifiers vs. Storage Classes</source>
          <target state="translated">타입 한정자 vs. 스토리지 클래스</target>
        </trans-unit>
        <trans-unit id="931cf893dd7787c77998acad492a0ecb55e589ff" translate="yes" xml:space="preserve">
          <source>Type behaviours</source>
          <target state="translated">유형 행동</target>
        </trans-unit>
        <trans-unit id="25bae51139cada12199444a9e1b243f934dd5a35" translate="yes" xml:space="preserve">
          <source>Type checking can be done when fmt is known at compile-time:</source>
          <target state="translated">컴파일 타임에 fmt가 알려진 경우 유형 검사를 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e3ba04dc56b4f38a8765f8f4d22b580ca485aa27" translate="yes" xml:space="preserve">
          <source>Type constructor for final (aka head-const) variables.</source>
          <target state="translated">최종 (일명 head-const) 변수의 유형 생성자.</target>
        </trans-unit>
        <trans-unit id="5bf7d2b202fca4883a92f0548ad74fcbd4972ddc" translate="yes" xml:space="preserve">
          <source>Type constructors for scoped variables, ref counted types, etc.</source>
          <target state="translated">범위가 지정된 변수, 참조 횟수 유형 등에 대한 유형 생성자</target>
        </trans-unit>
        <trans-unit id="8b9b79043e64613a9793b392102a5c4ae4b65fe0" translate="yes" xml:space="preserve">
          <source>Type containing symbol &lt;code&gt;member&lt;/code&gt;.</source>
          <target state="translated">symbol &lt;code&gt;member&lt;/code&gt; 를 포함하는 유형 입니다.</target>
        </trans-unit>
        <trans-unit id="cb30eafbd228209766b8a8bef60c18b615f0e87b" translate="yes" xml:space="preserve">
          <source>Type for the &lt;code&gt;va_list&lt;/code&gt; type for the target.</source>
          <target state="translated">대상 의 &lt;code&gt;va_list&lt;/code&gt; 유형을 입력하십시오.</target>
        </trans-unit>
        <trans-unit id="ef47c7ac43e7255929d6c306077f07f47b722eec" translate="yes" xml:space="preserve">
          <source>Type of Trie generated by codepointSetTrie function.</source>
          <target state="translated">codepointSetTrie 함수로 생성 된 Trie 유형입니다.</target>
        </trans-unit>
        <trans-unit id="4dccd7a2bbd9b94a92f0a8c92cf9c4faa4852cf6" translate="yes" xml:space="preserve">
          <source>Type of a factory object that returns new allocators on a need basis. For an object &lt;code&gt;sweatshop&lt;/code&gt; of type &lt;code&gt;Factory&lt;/code&gt;, &lt;code&gt;sweatshop(n)&lt;/code&gt; should return an allocator able to allocate at least &lt;code&gt;n&lt;/code&gt; bytes (i.e. &lt;code&gt;Factory&lt;/code&gt; must define &lt;code&gt;opCall(size_t)&lt;/code&gt; to return an allocator object). Usually the capacity of allocators created should be much larger than &lt;code&gt;n&lt;/code&gt; such that an allocator can be used for many subsequent allocations. &lt;code&gt;n&lt;/code&gt; is passed only to ensure the minimum necessary for the next allocation. The factory object is allowed to hold state, which will be stored inside &lt;code&gt;AllocatorList&lt;/code&gt; as a direct &lt;code&gt;public&lt;/code&gt; member called &lt;code&gt;factory&lt;/code&gt;.</source>
          <target state="translated">필요에 따라 새 할당자를 반환하는 팩토리 객체의 유형입니다. &lt;code&gt;Factory&lt;/code&gt; 유형 의 객체 &lt;code&gt;sweatshop&lt;/code&gt; 의 경우 &lt;code&gt;sweatshop(n)&lt;/code&gt; 은 최소 &lt;code&gt;n&lt;/code&gt; 바이트 를 할당 할 수있는 할당자를 반환 해야합니다 (즉, &lt;code&gt;Factory&lt;/code&gt; 는 할당 자 객체를 반환하려면 &lt;code&gt;opCall(size_t)&lt;/code&gt; 를 정의해야 함 ). 일반적으로 작성된 할당 자의 용량은 &lt;code&gt;n&lt;/code&gt; 보다 훨씬 커야 할당자가 많은 후속 할당에 사용될 수 있습니다. &lt;code&gt;n&lt;/code&gt; 은 다음 할당에 필요한 최소값을 보장하기 위해서만 전달됩니다. 팩토리 객체는 상태를 유지할 수 있으며 &lt;code&gt;AllocatorList&lt;/code&gt; 에 직접 &lt;code&gt;public&lt;/code&gt; 로 저장됩니다. &lt;code&gt;factory&lt;/code&gt; 라는 멤버 .</target>
        </trans-unit>
        <trans-unit id="53b3c45deaab965f30fbaf51880e1afc49233e18" translate="yes" xml:space="preserve">
          <source>Type of hook to report to accumulate</source>
          <target state="translated">누적보고하는 후크 유형</target>
        </trans-unit>
        <trans-unit id="15e383896d707844d0eca91f8b6889d73b97fbb0" translate="yes" xml:space="preserve">
          <source>Type of proxy</source>
          <target state="translated">프록시 유형</target>
        </trans-unit>
        <trans-unit id="c83110b1d2db2259adf4200ec37888cbc9846639" translate="yes" xml:space="preserve">
          <source>Type of tag</source>
          <target state="translated">태그의 종류</target>
        </trans-unit>
        <trans-unit id="d3fa4f954ab06add7bd749b7bdea58934c993aaa" translate="yes" xml:space="preserve">
          <source>Type of the object being created.</source>
          <target state="translated">작성중인 오브젝트의 유형</target>
        </trans-unit>
        <trans-unit id="a0daf2f1b22dd08dc29f641bae271010f9baf166" translate="yes" xml:space="preserve">
          <source>Type parameter deduction is not influenced by the order of function arguments.</source>
          <target state="translated">형식 매개 변수 공제는 함수 인수의 순서에 영향을받지 않습니다.</target>
        </trans-unit>
        <trans-unit id="6589b7ca4f64019c13d806f181e6e2f0d2a12efe" translate="yes" xml:space="preserve">
          <source>Type qualifer and storage classes are distinct.</source>
          <target state="translated">유형 qualifer와 스토리지 클래스는 다릅니다.</target>
        </trans-unit>
        <trans-unit id="6be815ee4e71cdcd2fdc1b9f5a931c3396cc2ae9" translate="yes" xml:space="preserve">
          <source>Type qualifiers modify a type by applying a &lt;a href=&quot;declaration#TypeCtor&quot;&gt;&lt;i&gt;TypeCtor&lt;/i&gt;&lt;/a&gt;.</source>
          <target state="translated">타입 한정자는 &lt;a href=&quot;declaration#TypeCtor&quot;&gt;&lt;i&gt;TypeCtor&lt;/i&gt;&lt;/a&gt; 를 적용하여 타입을 수정합니다 .</target>
        </trans-unit>
        <trans-unit id="a70515f861481e8dc4615de28615ff7366fcc202" translate="yes" xml:space="preserve">
          <source>Type representing the DOS file date/time format.</source>
          <target state="translated">DOS 파일 날짜 / 시간 형식을 나타내는 유형입니다.</target>
        </trans-unit>
        <trans-unit id="8707ce3b635eb9df5d025d3f0450b4a8fd3eb48d" translate="yes" xml:space="preserve">
          <source>Type sequences can also be deduced from the type of a delegate or function parameter list passed as a function argument:</source>
          <target state="translated">함수 시퀀스로 전달 된 대리자 또는 함수 매개 변수 목록의 형식에서 형식 시퀀스를 추론 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="733ee898e1598d12bae36c91271af1529e4fcaa2" translate="yes" xml:space="preserve">
          <source>Type sequences can be deduced from the trailing parameters of an implicitly instantiated function template:</source>
          <target state="translated">암시 적으로 인스턴스화 된 함수 템플릿의 후행 매개 변수에서 형식 시퀀스를 추론 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a8e4656cb8d277115469c8e6ecd03e51fd9b8df7" translate="yes" xml:space="preserve">
          <source>Type to check</source>
          <target state="translated">확인할 유형</target>
        </trans-unit>
        <trans-unit id="f741a0744a1572f9886a07067ea02acc1834b951" translate="yes" xml:space="preserve">
          <source>Type to check against existing types</source>
          <target state="translated">기존 유형을 확인하는 유형</target>
        </trans-unit>
        <trans-unit id="de396937e60ad29356ea188a9c5d9ea651e367c0" translate="yes" xml:space="preserve">
          <source>Type tuple with 0, 1 or 2 types in it.</source>
          <target state="translated">0, 1 또는 2 유형의 튜플을 입력하십시오.</target>
        </trans-unit>
        <trans-unit id="011c9eabb9ffe20e7e22482cfbe2286b6120bfa9" translate="yes" xml:space="preserve">
          <source>Type* &lt;code&gt;pt&lt;/code&gt;</source>
          <target state="translated">유형 * &lt;code&gt;pt&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="58d77e6f74277f79b951803afbe1ddf1b35734df" translate="yes" xml:space="preserve">
          <source>TypeCtor</source>
          <target state="translated">TypeCtor</target>
        </trans-unit>
        <trans-unit id="ac9e1cc0b26d4033ad5c959b5f820850ea93475b" translate="yes" xml:space="preserve">
          <source>TypeCtors</source>
          <target state="translated">TypeCtors</target>
        </trans-unit>
        <trans-unit id="3928ee67b003a61e2825045ee7c6856586fe197b" translate="yes" xml:space="preserve">
          <source>TypeDotIdExp</source>
          <target state="translated">TypeDotIdExp</target>
        </trans-unit>
        <trans-unit id="0019be4cb34cff2695b5aff262952fd301c46685" translate="yes" xml:space="preserve">
          <source>TypeFunction &lt;code&gt;tf&lt;/code&gt;</source>
          <target state="translated">유형 기능 &lt;code&gt;tf&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="db700355f8924fab7eada69ef0fe0e550c49d3a6" translate="yes" xml:space="preserve">
          <source>TypeFunction which holds parameter.</source>
          <target state="translated">매개 변수를 보유하는 TypeFunction.</target>
        </trans-unit>
        <trans-unit id="5ca2910cf68fdd66a12e3e8220178f8b4cc5a0db" translate="yes" xml:space="preserve">
          <source>TypeIdentifier &lt;strong id=&quot;getException&quot;&gt;getException&lt;/strong&gt;();</source>
          <target state="translated">TypeIdentifier &lt;strong id=&quot;getException&quot;&gt;getException&lt;/strong&gt; ();</target>
        </trans-unit>
        <trans-unit id="42f5b285fc85964089e7dc297caf59c7103f1888" translate="yes" xml:space="preserve">
          <source>TypeIdentifier &lt;strong id=&quot;getThrowable&quot;&gt;getThrowable&lt;/strong&gt;();</source>
          <target state="translated">TypeIdentifier &lt;strong id=&quot;getThrowable&quot;&gt;getThrowable&lt;/strong&gt; ();</target>
        </trans-unit>
        <trans-unit id="f9d611bfddd3405f459de10a0cf6d218aa6287a1" translate="yes" xml:space="preserve">
          <source>TypeIdentifier corresponding to &lt;code&gt;object.Exception&lt;/code&gt;</source>
          <target state="translated">대응 TypeIdentifier &lt;code&gt;object.Exception&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="4ea8bcbfb0a4687ca07a5f9448fa2692699ee114" translate="yes" xml:space="preserve">
          <source>TypeInfo &lt;code&gt;info&lt;/code&gt;</source>
          <target state="translated">TypeInfo &lt;code&gt;info&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="a1b8e2e2628fbdb6b877b9991519908026efcaf7" translate="yes" xml:space="preserve">
          <source>TypeInfo &lt;code&gt;keyti&lt;/code&gt;</source>
          <target state="translated">TypeInfo &lt;code&gt;keyti&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="5dec97b284949d704d7ee4541006a5521ba97794" translate="yes" xml:space="preserve">
          <source>TypeInfo &lt;code&gt;ti&lt;/code&gt;</source>
          <target state="translated">TypeInfo &lt;code&gt;ti&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="67c22ded6663e84767a53e56d998760516256038" translate="yes" xml:space="preserve">
          <source>TypeInfo &lt;strong id=&quot;source&quot;&gt;source&lt;/strong&gt;;</source>
          <target state="translated">TypeInfo &lt;strong id=&quot;source&quot;&gt;소스&lt;/strong&gt; ;</target>
        </trans-unit>
        <trans-unit id="c1278db525adc97eab488999431f521bd14cee3e" translate="yes" xml:space="preserve">
          <source>TypeInfo &lt;strong id=&quot;target&quot;&gt;target&lt;/strong&gt;;</source>
          <target state="translated">TypeInfo &lt;strong id=&quot;target&quot;&gt;대상&lt;/strong&gt; ;</target>
        </trans-unit>
        <trans-unit id="79ae15533fd627996ea193ee400334ad48f0ffa1" translate="yes" xml:space="preserve">
          <source>TypeInfo &lt;strong id=&quot;ti&quot;&gt;ti&lt;/strong&gt;;</source>
          <target state="translated">TypeInfo &lt;strong id=&quot;ti&quot;&gt;ti&lt;/strong&gt; ;</target>
        </trans-unit>
        <trans-unit id="472c2c18b4ef0579bcce9fff2441baed8006d608" translate="yes" xml:space="preserve">
          <source>TypeInfo and ModuleInfo</source>
          <target state="translated">TypeInfo 및 ModuleInfo</target>
        </trans-unit>
        <trans-unit id="f93be7833a3f5791fae09a639aee73a46e387e3c" translate="yes" xml:space="preserve">
          <source>TypeInfo for the associative array</source>
          <target state="translated">연관 배열의 TypeInfo</target>
        </trans-unit>
        <trans-unit id="7c7bfccff9046ef36445ee4c709ff7d995d70ab8" translate="yes" xml:space="preserve">
          <source>TypeInfo for the key</source>
          <target state="translated">키의 TypeInfo</target>
        </trans-unit>
        <trans-unit id="23d395400e74ed54a9281933209acee2f90cbe4e" translate="yes" xml:space="preserve">
          <source>TypeInfo for this member</source>
          <target state="translated">이 멤버의 TypeInfo</target>
        </trans-unit>
        <trans-unit id="6cae780f43ad1913cc11d46eaafdb1d914a0fecd" translate="yes" xml:space="preserve">
          <source>TypeInfo operations</source>
          <target state="translated">TypeInfo 작업</target>
        </trans-unit>
        <trans-unit id="0c903e4430a6af28fc4a701dcf89fccf74b52c8e" translate="yes" xml:space="preserve">
          <source>TypeInfo support code.</source>
          <target state="translated">TypeInfo 지원 코드.</target>
        </trans-unit>
        <trans-unit id="7bac08fb0ecc35c0c1645fa9688ec0c7cbb7320b" translate="yes" xml:space="preserve">
          <source>TypeInfo to describe the full memory block. The GC might use this information to improve scanning for pointers or to call finalizers.</source>
          <target state="translated">전체 메모리 블록을 설명하는 TypeInfo GC는이 정보를 사용하여 포인터 스캔을 향상 시키거나 종료자를 호출 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e6a910dc0d5bf54bb8bb28b4e2782c2fac837ad2" translate="yes" xml:space="preserve">
          <source>TypeInfo to describe the memory. The GC might use this information to improve scanning for pointers or to call finalizers</source>
          <target state="translated">메모리를 설명하는 TypeInfo GC는이 정보를 사용하여 포인터 스캔을 개선하거나 종료자를 호출 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8c13cb9891545ae558cb22a55266091cadf68bb8" translate="yes" xml:space="preserve">
          <source>TypeInfo to describe the memory. The GC might use this information to improve scanning for pointers or to call finalizers.</source>
          <target state="translated">메모리를 설명하는 TypeInfo GC는이 정보를 사용하여 포인터 스캔을 향상 시키거나 종료자를 호출 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="aff0fe6a2bf6b7e4ef9a8e4a029e01a4aeb8762f" translate="yes" xml:space="preserve">
          <source>TypeInfo_AssociativeArray &lt;code&gt;ti&lt;/code&gt;</source>
          <target state="translated">TypeInfo_AssociativeArray &lt;code&gt;ti&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="e25e4540ada3cc921bdd8d8fd0d8e1e7b7781066" translate="yes" xml:space="preserve">
          <source>TypeInfo_Class &lt;strong id=&quot;base&quot;&gt;base&lt;/strong&gt;;</source>
          <target state="translated">TypeInfo_Class &lt;strong id=&quot;base&quot;&gt;base&lt;/strong&gt; ;</target>
        </trans-unit>
        <trans-unit id="9239ac5fb46ce2e24e9298817e7012c20bc78405" translate="yes" xml:space="preserve">
          <source>TypeInfo_Class &lt;strong id=&quot;classinfo&quot;&gt;classinfo&lt;/strong&gt;;</source>
          <target state="translated">TypeInfo_Class &lt;strong id=&quot;classinfo&quot;&gt;classinfo&lt;/strong&gt; ;</target>
        </trans-unit>
        <trans-unit id="2bd0ed90864a622e90192ec41cb245073bc3a096" translate="yes" xml:space="preserve">
          <source>TypeMixin &lt;code&gt;tm&lt;/code&gt;</source>
          <target state="translated">TypeMixin &lt;code&gt;tm&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="773e0bc0cc8840334c10f79e302767527cb23cf4" translate="yes" xml:space="preserve">
          <source>TypeSeq</source>
          <target state="translated">TypeSeq</target>
        </trans-unit>
        <trans-unit id="2485569c283c3e15dcdf66b2941cf2585cfbb0fb" translate="yes" xml:space="preserve">
          <source>TypeSpecialization</source>
          <target state="translated">TypeSpecialization</target>
        </trans-unit>
        <trans-unit id="d5bc30e762df0213573cbaddbf2be54ecff91c7a" translate="yes" xml:space="preserve">
          <source>TypeTuple &lt;strong id=&quot;toArgTypes&quot;&gt;toArgTypes&lt;/strong&gt;(Type t);</source>
          <target state="translated">TypeTuple &lt;strong id=&quot;toArgTypes&quot;&gt;toArgTypes&lt;/strong&gt; (타입 t);</target>
        </trans-unit>
        <trans-unit id="0a55489e3ecfb05595ff8f54b93c8573e3ce85a8" translate="yes" xml:space="preserve">
          <source>TypeTuple &lt;strong id=&quot;toArgTypes_sysv_x64&quot;&gt;toArgTypes_sysv_x64&lt;/strong&gt;(Type t);</source>
          <target state="translated">TypeTuple &lt;strong id=&quot;toArgTypes_sysv_x64&quot;&gt;toArgTypes_sysv_x64&lt;/strong&gt; (유형 t);</target>
        </trans-unit>
        <trans-unit id="e642a3765f89fbde01f0a2276d7abdf9b70ab3cf" translate="yes" xml:space="preserve">
          <source>Typed alias parameters</source>
          <target state="translated">유형 별명 매개 변수</target>
        </trans-unit>
        <trans-unit id="b30db53a60d0c35c43aeee9bc4f602733c935e33" translate="yes" xml:space="preserve">
          <source>Typedef creates a new type</source>
          <target state="translated">Typedef는 새로운 유형을 만듭니다</target>
        </trans-unit>
        <trans-unit id="6201a322fae660c45cd9849605bc8c759be0c5b0" translate="yes" xml:space="preserve">
          <source>Typeid Expressions</source>
          <target state="translated">타입 식</target>
        </trans-unit>
        <trans-unit id="bf3662203dcf0ffc0db3cb9a25590ff39043990d" translate="yes" xml:space="preserve">
          <source>Typeof</source>
          <target state="translated">Typeof</target>
        </trans-unit>
        <trans-unit id="93b9e289e2842469d001eccf7ad5d79f3c302dc9" translate="yes" xml:space="preserve">
          <source>Types</source>
          <target state="translated">Types</target>
        </trans-unit>
        <trans-unit id="98208c2d7d35bb6c2bec43c9c9c8b3b514bcabb3" translate="yes" xml:space="preserve">
          <source>Types &lt;code&gt;values&lt;/code&gt;</source>
          <target state="translated">유형 &lt;code&gt;values&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="ad7fbb5ff653b4fb1310a106afd7d4d247c60fc4" translate="yes" xml:space="preserve">
          <source>Types &lt;strong id=&quot;expand&quot;&gt;expand&lt;/strong&gt;;</source>
          <target state="translated">유형 &lt;strong id=&quot;expand&quot;&gt;확장&lt;/strong&gt; ;</target>
        </trans-unit>
        <trans-unit id="d33ff32e1c661c88ebc3ad3634169408689bdb2c" translate="yes" xml:space="preserve">
          <source>Types affected</source>
          <target state="translated">영향을받는 유형</target>
        </trans-unit>
        <trans-unit id="8b8ed26fa191ff295582e384bddd39585a3f8db2" translate="yes" xml:space="preserve">
          <source>Types are mangled using a simple linear scheme:</source>
          <target state="translated">간단한 선형 체계를 사용하여 유형이 엉망이됩니다.</target>
        </trans-unit>
        <trans-unit id="056fa98818fde905c87d68b5a8122d7a217fa627" translate="yes" xml:space="preserve">
          <source>Types for C Debuggers</source>
          <target state="translated">C 디버거의 유형</target>
        </trans-unit>
        <trans-unit id="a317ddf00723db3897d96406a7af0777748b751e" translate="yes" xml:space="preserve">
          <source>Typesafe PIMPL idiom so we can keep CompiledCtfeFunction private.</source>
          <target state="translated">CompiledCtfeFunction을 비공개로 유지할 수 있도록 Typesafe PIMPL 관용구를 입력하십시오.</target>
        </trans-unit>
        <trans-unit id="8c1a6486831bba104b5c93d116efda5decae0955" translate="yes" xml:space="preserve">
          <source>Typesafe Variadic Functions</source>
          <target state="translated">타입 세이프 가변 기능</target>
        </trans-unit>
        <trans-unit id="9c18f7085ca663e2eeeb1ab419e11c946cc281e9" translate="yes" xml:space="preserve">
          <source>Typesafe variadic functions</source>
          <target state="translated">타입 세이프 variadic 함수</target>
        </trans-unit>
        <trans-unit id="c158adeb6705f4b21c628caabe72dc1f58ae0f9b" translate="yes" xml:space="preserve">
          <source>Typesafe variadic functions are used when the variable argument portion of the arguments are used to construct an array or class object.</source>
          <target state="translated">형식이 안전한 가변 함수는 인수의 변수 인수 부분이 배열 또는 클래스 객체를 구성하는 데 사용될 때 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="e6941e6087f5c747e81f3548ced3b053ce9e7b28" translate="yes" xml:space="preserve">
          <source>Typically updating a value in an associative array is simply done with an assign statement.</source>
          <target state="translated">일반적으로 연관 배열에서 값을 업데이트하는 것은 단순히 assign 문으로 수행됩니다.</target>
        </trans-unit>
        <trans-unit id="db183258f807139f91ca3be4ce6506a44b76a64e" translate="yes" xml:space="preserve">
          <source>Typically used to transfer a &lt;code&gt;Unique&lt;/code&gt; rvalue of derived type to a &lt;code&gt;Unique&lt;/code&gt; of base type.</source>
          <target state="translated">일반적으로 파생 유형 의 &lt;code&gt;Unique&lt;/code&gt; rvalue 를 기본 유형 의 &lt;code&gt;Unique&lt;/code&gt; 로 전송하는 데 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="733f934ae56c1f7d0fdf7d7b634f135f6d1638cd" translate="yes" xml:space="preserve">
          <source>Typically, &lt;code&gt;assumeUnique&lt;/code&gt; is used to return arrays from functions that have allocated and built them.</source>
          <target state="translated">일반적으로 &lt;code&gt;assumeUnique&lt;/code&gt; 는 배열을 할당하고 만든 함수에서 배열을 반환하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="22c79bf41fa01646983d0e1c75126cd457c1bd02" translate="yes" xml:space="preserve">
          <source>Typically, the abbreviation (generally 3 or 4 letters) for the time zone when DST</source>
          <target state="translated">일반적으로 DST 인 경우 시간대의 약어 (일반적으로 3 자 또는 4 자)</target>
        </trans-unit>
        <trans-unit id="b795aa6d3d9c14054ccb6a6aea11b3269a8595b3" translate="yes" xml:space="preserve">
          <source>Typically, the abbreviation (generally 3 or 4 letters) for the time zone when DST is</source>
          <target state="translated">일반적으로 DST가 다음과 같은 시간대의 약어 (일반적으로 3 ~ 4 자)</target>
        </trans-unit>
        <trans-unit id="b7f34bb41388ea7e3fb767468d24019362880e11" translate="yes" xml:space="preserve">
          <source>Typically, the first element of &lt;code&gt;argv&lt;/code&gt; is the command being executed, i.e. &lt;code&gt;argv[0] == pathname&lt;/code&gt;. The 'p' versions of &lt;code&gt;exec&lt;/code&gt; search the PATH environment variable for &lt;code&gt; pathname&lt;/code&gt;. The 'e' versions additionally take the new process' environment variables as an array of strings of the form key=value.</source>
          <target state="translated">일반적으로 &lt;code&gt;argv&lt;/code&gt; 의 첫 번째 요소는 실행중인 명령입니다 (예 : &lt;code&gt;argv[0] == pathname&lt;/code&gt; . &lt;code&gt;exec&lt;/code&gt; 의 'p'버전은 PATH 환경 변수에서 &lt;code&gt; pathname&lt;/code&gt; 을 검색합니다 . 'e'버전은 또한 key = value 형식의 문자열 배열로 새 프로세스 환경 변수를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="de16dec91e0419147faeea7cdd994e0d6a8f8d25" translate="yes" xml:space="preserve">
          <source>U &lt;code&gt;another&lt;/code&gt;</source>
          <target state="translated">U &lt;code&gt;another&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="3fb667fdcab211117158dd3ce9d3203d725af2f1" translate="yes" xml:space="preserve">
          <source>U &lt;code&gt;argument&lt;/code&gt;</source>
          <target state="translated">U &lt;code&gt;argument&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="697f0c45a847f453216f051a5a6ee69d25e04ed2" translate="yes" xml:space="preserve">
          <source>U &lt;code&gt;end&lt;/code&gt;</source>
          <target state="translated">U &lt;code&gt;end&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="63a11922fe248c81fbee9848ffa1f8b4dfbc12bd" translate="yes" xml:space="preserve">
          <source>U &lt;code&gt;item&lt;/code&gt;</source>
          <target state="translated">U &lt;code&gt;item&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="39dcf3fde6cc76619903303aa59a8ee79c73ff4f" translate="yes" xml:space="preserve">
          <source>U &lt;code&gt;rhs&lt;/code&gt;</source>
          <target state="translated">U &lt;code&gt;rhs&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="dd1523b1327c39f05597e30713c7dff5a3ff10c0" translate="yes" xml:space="preserve">
          <source>U &lt;code&gt;stuff&lt;/code&gt;</source>
          <target state="translated">U &lt;code&gt;stuff&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="14d2ebb04ddb126790e90698955610cc1aa2858f" translate="yes" xml:space="preserve">
          <source>U &lt;code&gt;update&lt;/code&gt;</source>
          <target state="translated">U &lt;code&gt;update&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="5fa4864c90d6d362e77a889c4b5d08bf8651a60b" translate="yes" xml:space="preserve">
          <source>U &lt;strong id=&quot;opCast&quot;&gt;opCast&lt;/strong&gt;(U, this _)()</source>
          <target state="translated">U &lt;strong id=&quot;opCast&quot;&gt;opCast&lt;/strong&gt; (U, this _) ()</target>
        </trans-unit>
        <trans-unit id="dc24734c978d9bb3d649f59ea57f6fbfebb04938" translate="yes" xml:space="preserve">
          <source>UDAs can be extracted into an expression tuple using &lt;code&gt;__traits&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;__traits&lt;/code&gt; 를 사용하여 UDA를 표현식 튜플로 추출 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="8c9a445b357a8879b87fe2a26129a13cff925174" translate="yes" xml:space="preserve">
          <source>UDAs cannot be attached to template parameters.</source>
          <target state="translated">UDA는 템플릿 매개 변수에 연결할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="4196b39d1eebc6a19e223c4aac2d97a9aacf8120" translate="yes" xml:space="preserve">
          <source>UIntType</source>
          <target state="translated">UIntType</target>
        </trans-unit>
        <trans-unit id="c05d8b4022a5b33bdfe1da8ac44209fadee29acb" translate="yes" xml:space="preserve">
          <source>UIntType &lt;code&gt;x0&lt;/code&gt;</source>
          <target state="translated">UIntType &lt;code&gt;x0&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="cf1134895e9b29127e491e75b96f85825dd4e274" translate="yes" xml:space="preserve">
          <source>UNIX 98 requires that errno be set to ENOMEM upon failure. &lt;a href=&quot;https://linux.die.net/man/3/malloc&quot;&gt;https://linux.die.net/man/3/malloc&lt;/a&gt; However, this is irrelevant for DMD's purposes, and best practice protocol for using errno is to treat it as an &lt;code&gt;out&lt;/code&gt; parameter, and not something with state that can be relied on across function calls. So, we'll ignore it.</source>
          <target state="translated">UNIX 98에서는 실패시 errno를 ENOMEM으로 설정해야합니다. &lt;a href=&quot;https://linux.die.net/man/3/malloc&quot;&gt;https://linux.die.net/man/3/malloc&lt;/a&gt; 그러나 이것은 DMD의 목적 과 관련이 없으며 errno를 사용하는 모범 사례 프로토콜은이를 신뢰할 수있는 상태가 아닌 &lt;code&gt;out&lt;/code&gt; 매개 변수 로 처리하는 것입니다 여러 함수 호출. 따라서 무시하겠습니다.</target>
        </trans-unit>
        <trans-unit id="beccb674b27af0ddeedf12b4de67513a39156f03" translate="yes" xml:space="preserve">
          <source>UNIX 98 requires that errno be set to ENOMEM upon failure. Purity is achieved by saving and restoring the value of &lt;code&gt;errno&lt;/code&gt;, thus behaving as if it were never changed.</source>
          <target state="translated">UNIX 98에서는 실패시 errno를 ENOMEM으로 설정해야합니다. 순도는 &lt;code&gt;errno&lt;/code&gt; 값을 저장하고 복원하여 변경되지 않은 것처럼 동작 함으로써 달성됩니다 .</target>
        </trans-unit>
        <trans-unit id="fd4c42e93b798f843e95525ca51904fccdadcf92" translate="yes" xml:space="preserve">
          <source>UNIX(7)</source>
          <target state="translated">UNIX(7)</target>
        </trans-unit>
        <trans-unit id="f9fc2ebde19b1bdca47e809441ff08ef908d85ea" translate="yes" xml:space="preserve">
          <source>UTF Byte Order Marks</source>
          <target state="translated">UTF 바이트 주문 마크</target>
        </trans-unit>
        <trans-unit id="9f8129fc3aa0089cfcf72b031ad3d481df53b04d" translate="yes" xml:space="preserve">
          <source>UTF character support is restricted to &lt;code&gt;'\u0000' &amp;lt;= character &amp;lt;= '\U0010FFFF'&lt;/code&gt;.</source>
          <target state="translated">UTF 문자 지원은 &lt;code&gt;'\u0000' &amp;lt;= character &amp;lt;= '\U0010FFFF'&lt;/code&gt; 됩니다.</target>
        </trans-unit>
        <trans-unit id="f5411953a4d42cf12809bd4464e6d4db7776d601" translate="yes" xml:space="preserve">
          <source>UTF sequences that cannot be converted to the specified encoding are replaced by U+FFFD per &quot;5.22 Best Practice for U+FFFD Substitution&quot; of the Unicode Standard 6.2. Hence byUTF is not symmetric. This algorithm is lazy, and does not allocate memory. &lt;code&gt;@nogc&lt;/code&gt;, &lt;code&gt;pure&lt;/code&gt;-ity, &lt;code&gt;nothrow&lt;/code&gt;, and &lt;code&gt;@safe&lt;/code&gt;-ty are inferred from the &lt;code&gt;r&lt;/code&gt; parameter.</source>
          <target state="translated">지정된 인코딩으로 변환 할 수없는 UTF 시퀀스는 유니 코드 표준 6.2의 &quot;5.22 U + FFFD 대체 모범 사례&quot;에 따라 U + FFFD로 대체됩니다. 따라서 byUTF는 대칭이 아닙니다. 이 알고리즘은 게으 르며 메모리를 할당하지 않습니다. &lt;code&gt;@nogc&lt;/code&gt; , &lt;code&gt;pure&lt;/code&gt; -ity, &lt;code&gt;nothrow&lt;/code&gt; 및 &lt;code&gt;@safe&lt;/code&gt; -ty이 유추되는 &lt;code&gt;r&lt;/code&gt; 매개 변수입니다.</target>
        </trans-unit>
        <trans-unit id="815b5d137b049f840a84ea779942f380fee2d1b2" translate="yes" xml:space="preserve">
          <source>UTF-16 sequence</source>
          <target state="translated">UTF-16 시퀀스</target>
        </trans-unit>
        <trans-unit id="de4a45e716017695cfee4bc84f1a4e0c8e1e9b9a" translate="yes" xml:space="preserve">
          <source>UTF-16BE</source>
          <target state="translated">UTF-16BE</target>
        </trans-unit>
        <trans-unit id="6af12beb19d40aa853839c482e864ce703f4d2a9" translate="yes" xml:space="preserve">
          <source>UTF-16LE</source>
          <target state="translated">UTF-16LE</target>
        </trans-unit>
        <trans-unit id="9e4d8d4f017185a065b570c771eb332a1c842bec" translate="yes" xml:space="preserve">
          <source>UTF-32BE</source>
          <target state="translated">UTF-32BE</target>
        </trans-unit>
        <trans-unit id="35cabe85c31dfe3f6b86974de33fef51a0f7276a" translate="yes" xml:space="preserve">
          <source>UTF-32LE</source>
          <target state="translated">UTF-32LE</target>
        </trans-unit>
        <trans-unit id="663b90c899fa25a111067be0c22ffc64dcf581c2" translate="yes" xml:space="preserve">
          <source>UTF-8</source>
          <target state="translated">UTF-8</target>
        </trans-unit>
        <trans-unit id="f9496a431551e339492736948b4e238922bacdef" translate="yes" xml:space="preserve">
          <source>UTF-8 sequence</source>
          <target state="translated">UTF-8 시퀀스</target>
        </trans-unit>
        <trans-unit id="877994f4b4067d2a1f1f0f6bd6384f2638fcb6f8" translate="yes" xml:space="preserve">
          <source>UTF-8 string to convert.</source>
          <target state="translated">변환 할 UTF-8 문자열.</target>
        </trans-unit>
        <trans-unit id="4ec698a623934218d006f758f60cc65200b7e5d5" translate="yes" xml:space="preserve">
          <source>UUID &lt;strong id=&quot;parseUUID&quot;&gt;parseUUID&lt;/strong&gt;(Range)(ref Range uuidRange)</source>
          <target state="translated">UUID &lt;strong id=&quot;parseUUID&quot;&gt;구문 분석&lt;/strong&gt; UUID (범위) (참조 범위 uuidRange)</target>
        </trans-unit>
        <trans-unit id="67faabd33b533aa2705b030a23deec418ddc4531" translate="yes" xml:space="preserve">
          <source>UUID &lt;strong id=&quot;parseUUID&quot;&gt;parseUUID&lt;/strong&gt;(T)(T uuidString)</source>
          <target state="translated">UUID &lt;strong id=&quot;parseUUID&quot;&gt;구문 분석&lt;/strong&gt; UUID (T) (T uuidString)</target>
        </trans-unit>
        <trans-unit id="cc9e30340d1753d3d85fd300f0e9b269c9de763e" translate="yes" xml:space="preserve">
          <source>UUID &lt;strong id=&quot;randomUUID&quot;&gt;randomUUID&lt;/strong&gt;(RNG)(ref RNG randomGen)</source>
          <target state="translated">UUID &lt;strong id=&quot;randomUUID&quot;&gt;randomUUID&lt;/strong&gt; (RNG) (참조 RNG randomGen)</target>
        </trans-unit>
        <trans-unit id="a772ba2e5a42ae80f2c9272ebcf1178fcfb9d897" translate="yes" xml:space="preserve">
          <source>UUID namespaces</source>
          <target state="translated">UUID 네임 스페이스</target>
        </trans-unit>
        <trans-unit id="5138cdf5aa51c8e0f95889706fc9ee1e7f17902c" translate="yes" xml:space="preserve">
          <source>UUID uses a 16-ubyte representation for the UUID data. RFC 4122 defines a UUID as a special structure in big-endian format. These 16-ubytes always equal the big-endian structure defined in RFC 4122.</source>
          <target state="translated">UUID는 UUID 데이터에 16 바이트 바이트 표현을 사용합니다. RFC 4122는 UUID를 빅 엔디안 형식의 특수 구조로 정의합니다. 이 16 바이트는 항상 RFC 4122에 정의 된 빅 엔디안 구조와 같습니다.</target>
        </trans-unit>
        <trans-unit id="97f3c3a3c12b841a2a4769e7f1a5d3a8268ab30f" translate="yes" xml:space="preserve">
          <source>UUIDs have many applications. Some examples follow: Databases may use UUIDs to identify rows or records in order to ensure that they are unique across different databases, or for publication/subscription services. Network messages may be identified with a UUID to ensure that different parts of a message are put back together again. Distributed computing may use UUIDs to identify a remote procedure call. Transactions and classes involved in serialization may be identified by UUIDs. Microsoft's component object model (COM) uses UUIDs to distinguish different software component interfaces. UUIDs are inserted into documents from Microsoft Office programs. UUIDs identify audio or video streams in the Advanced Systems Format (ASF). UUIDs are also a basis for OIDs (object identifiers), and URNs (uniform resource name).</source>
          <target state="translated">UUID에는 많은 응용 프로그램이 있습니다. 데이터베이스는 UUID를 사용하여 행이나 레코드를 식별하여 서로 다른 데이터베이스에서 또는 게시 / 가입 서비스에서 고유 한 행 또는 레코드를 식별 할 수 있습니다. 메시지의 다른 부분이 다시 결합되도록 네트워크 메시지를 UUID로 식별 할 수 있습니다. 분산 컴퓨팅은 UUID를 사용하여 원격 프로 시저 호출을 식별 할 수 있습니다. 직렬화와 관련된 트랜잭션 및 클래스는 UUID로 식별 될 수 있습니다. Microsoft의 COM (구성 요소 개체 모델)은 UUID를 사용하여 다른 소프트웨어 구성 요소 인터페이스를 구별합니다. UUID는 Microsoft Office 프로그램의 문서에 삽입됩니다. UUID는 ASF (Advanced Systems Format)에서 오디오 또는 비디오 스트림을 식별합니다. UUID는 OID (개체 식별자) 및 URN (고일 리소스 이름)의 기초이기도합니다.</target>
        </trans-unit>
        <trans-unit id="7cfb32627383e93254e644d1ee41cde2752bcfaa" translate="yes" xml:space="preserve">
          <source>U[] &lt;code&gt;b&lt;/code&gt;</source>
          <target state="translated">U [] &lt;code&gt;b&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="b5a8724faaa7b7c394cdf13e24050e05ae9df5e7" translate="yes" xml:space="preserve">
          <source>U[n] &lt;code&gt;values&lt;/code&gt;</source>
          <target state="translated">U [n] &lt;code&gt;values&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="6328bc9f36f37764a79ddabe4b86ab6e97f09add" translate="yes" xml:space="preserve">
          <source>Ugaritic</source>
          <target state="translated">Ugaritic</target>
        </trans-unit>
        <trans-unit id="b338855e51e0be5b8018fcc6c3c8f1fb58ef1ed1" translate="yes" xml:space="preserve">
          <source>UnaExp &lt;code&gt;ue&lt;/code&gt;</source>
          <target state="translated">UnaExp &lt;code&gt;ue&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="a7362d38845d769ab9292607291056855e2183b1" translate="yes" xml:space="preserve">
          <source>Unable to open the database file</source>
          <target state="translated">데이터베이스 파일을 열 수 없습니다</target>
        </trans-unit>
        <trans-unit id="33bd9ce85f04d2d2b0510e3bbb94561d4ef14386" translate="yes" xml:space="preserve">
          <source>Unary Expressions</source>
          <target state="translated">단항식</target>
        </trans-unit>
        <trans-unit id="591cb6d4ab93ebc2d2043b2cb411e0fb42e0f3f7" translate="yes" xml:space="preserve">
          <source>Unary Operator Overloading</source>
          <target state="translated">단항 연산자 오버로딩</target>
        </trans-unit>
        <trans-unit id="f513f3dda804c19713470f3838e16096aa4d57eb" translate="yes" xml:space="preserve">
          <source>Unary SIMD instructions.</source>
          <target state="translated">단항 SIMD 지침.</target>
        </trans-unit>
        <trans-unit id="d4b656c31bdca61d3708bf6436103a5e4c87af7f" translate="yes" xml:space="preserve">
          <source>UnaryExpression</source>
          <target state="translated">UnaryExpression</target>
        </trans-unit>
        <trans-unit id="e57016edceec7e7b4449fe027bb35d1ba319eb9f" translate="yes" xml:space="preserve">
          <source>Unassigned</source>
          <target state="translated">Unassigned</target>
        </trans-unit>
        <trans-unit id="eb5d4c5516fc1c059de7a6392f9c37511d73768b" translate="yes" xml:space="preserve">
          <source>Unavailable Features</source>
          <target state="translated">사용할 수없는 기능</target>
        </trans-unit>
        <trans-unit id="68af9ad2189921beb26a800d338b2a6b4e676cf3" translate="yes" xml:space="preserve">
          <source>Unclosed comment</source>
          <target state="translated">비공개 댓글</target>
        </trans-unit>
        <trans-unit id="f6243a69cb62441fa6d87afa14c8d5e89b20730a" translate="yes" xml:space="preserve">
          <source>Unclosed quoted string</source>
          <target state="translated">닫히지 않은 따옴표로 묶인 문자열</target>
        </trans-unit>
        <trans-unit id="bf324c3d5f2f1b78051107d12302e948c629d468" translate="yes" xml:space="preserve">
          <source>Underlying ranges</source>
          <target state="translated">기본 범위</target>
        </trans-unit>
        <trans-unit id="83480b867507019f42179ab37987dcdb4c62cd97" translate="yes" xml:space="preserve">
          <source>Unescapes URL encoding in strings (converts all %XX codes to their 8bit versions). This function returns a new allocated string or NULL if an error occurred. Conversion Note: On non-ASCII platforms the ASCII %XX codes are converted into the host encoding.</source>
          <target state="translated">문자열에서 URL 인코딩을 이스케이프 해제합니다 (모든 % XX 코드를 8 비트 버전으로 변환). 이 함수는 새로운 할당 문자열을 반환하거나 오류가 발생하면 NULL을 반환합니다. 변환 참고 : 비 ASCII 플랫폼에서 ASCII % XX 코드는 호스트 인코딩으로 변환됩니다.</target>
        </trans-unit>
        <trans-unit id="1043e7d94fb950dfc41b004ced60f3e79b56ed17" translate="yes" xml:space="preserve">
          <source>Unfortunately, there is no way to do it on Windows using the TZ Database name, so this function only exists on Posix systems.</source>
          <target state="translated">불행히도 TZ 데이터베이스 이름을 사용하여 Windows에서 수행 할 수있는 방법이 없으므로이 기능은 Posix 시스템에만 존재합니다.</target>
        </trans-unit>
        <trans-unit id="c7e823b88e4feebda781e31901fb8ed6b6646bbd" translate="yes" xml:space="preserve">
          <source>Unicode 5.0, ASCII, ISO-8859-1, ISO-8859-2, WINDOWS-1250, WINDOWS-1251, WINDOWS-1252</source>
          <target state="translated">유니 코드 5.0, ASCII, ISO-8859-1, ISO-8859-2, WINDOWS-1250, WINDOWS-1251, WINDOWS-1252</target>
        </trans-unit>
        <trans-unit id="b81efb17a923e74f971664cf6551b29e3911eb7f" translate="yes" xml:space="preserve">
          <source>Unicode 5.0, ASCII, ISO-8859-1, WINDOWS-1252</source>
          <target state="translated">유니 코드 5.0, ASCII, ISO-8859-1, WINDOWS-1252</target>
        </trans-unit>
        <trans-unit id="9efb04e249cf52e825a2ae577ec002967cfd9907" translate="yes" xml:space="preserve">
          <source>Unicode character U+</source>
          <target state="translated">유니 코드 문자 U +</target>
        </trans-unit>
        <trans-unit id="86d5346f841497e1a9a9e132b4794f45dbdd869c" translate="yes" xml:space="preserve">
          <source>Unicode character decomposition type.</source>
          <target state="translated">유니 코드 문자 분해 유형</target>
        </trans-unit>
        <trans-unit id="85292ebf0b3cae013871cb556874cf9db932ca12" translate="yes" xml:space="preserve">
          <source>Unicode integrity is not preserved:</source>
          <target state="translated">유니 코드 무결성은 유지되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="3ec807b074593d04a3ef86db0a4d24fa457b2e5f" translate="yes" xml:space="preserve">
          <source>Unicode properties</source>
          <target state="translated">유니 코드 속성</target>
        </trans-unit>
        <trans-unit id="5be5c9fefc535768d2b96dd8780acd22043ffcf7" translate="yes" xml:space="preserve">
          <source>Unicode properties such as Scripts, Blocks and common binary properties e.g Alphabetic, White_Space, Hex_Digit etc.</source>
          <target state="translated">스크립트, 블록과 같은 유니 코드 속성 및 알파벳, White_Space, Hex_Digit 등과 같은 일반적인 이진 속성</target>
        </trans-unit>
        <trans-unit id="4247bd31bdb74c5074c844a1f51c93a859ff8578" translate="yes" xml:space="preserve">
          <source>Unicode support</source>
          <target state="translated">유니 코드 지원</target>
        </trans-unit>
        <trans-unit id="b82773bc5411a43a67f701a9ac627a06c1cb6db2" translate="yes" xml:space="preserve">
          <source>Unicode v6.2</source>
          <target state="translated">유니 코드 v6.2</target>
        </trans-unit>
        <trans-unit id="7e2aea9a1091a65f50509009229ce4d23b5ee960" translate="yes" xml:space="preserve">
          <source>Unicode(tm) is a trademark of Unicode, Inc.</source>
          <target state="translated">Unicode (tm)는 Unicode, Inc.의 상표입니다.</target>
        </trans-unit>
        <trans-unit id="91c29c138dfa854b43a9c50a2f9ff956dcfd1401" translate="yes" xml:space="preserve">
          <source>Unified Canadian Aboriginal Syllabics</source>
          <target state="translated">통합 캐나다 원주민 실라 빅</target>
        </trans-unit>
        <trans-unit id="0f85f583bbf512091ad1e17cda1699402ef799e1" translate="yes" xml:space="preserve">
          <source>Unified Canadian Aboriginal Syllabics Extended</source>
          <target state="translated">통합 캐나다 원주민 실라 빅 확장</target>
        </trans-unit>
        <trans-unit id="4f290c277dbce6544950d95c7ffc983b5b870a4c" translate="yes" xml:space="preserve">
          <source>Unified_Ideograph</source>
          <target state="translated">Unified_Ideograph</target>
        </trans-unit>
        <trans-unit id="5ea2f727e179d06cc6c0064064aea5ee05d170fa" translate="yes" xml:space="preserve">
          <source>Uniform Function Call Syntax (UFCS)</source>
          <target state="translated">UFCS (Uniform Function Call Syntax)</target>
        </trans-unit>
        <trans-unit id="367b834ab9bc6ea15eef6f05af78776738e3081a" translate="yes" xml:space="preserve">
          <source>Uniform construction syntax for built-in scalar types</source>
          <target state="translated">내장 스칼라 유형에 대한 균일 한 구성 구문</target>
        </trans-unit>
        <trans-unit id="bf061382e10d6798c2517c28e31d8d381de29d04" translate="yes" xml:space="preserve">
          <source>Uniform sampling</source>
          <target state="translated">균일 한 샘플링</target>
        </trans-unit>
        <trans-unit id="14c21961b2726c16163dc7492f677c46d510610a" translate="yes" xml:space="preserve">
          <source>UniformRNG &lt;code&gt;rng&lt;/code&gt;</source>
          <target state="translated">유니폼 RNG &lt;code&gt;rng&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="b1dc2d8aa43cf4b7523681bf7a9d62b6503ab053" translate="yes" xml:space="preserve">
          <source>UniformRandomNumberGenerator &lt;code&gt;urng&lt;/code&gt;</source>
          <target state="translated">UniformRandomNumberGenerator &lt;code&gt;urng&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="7e68b9abd8444d542ee7ea49339a9fa1aecc4ff1" translate="yes" xml:space="preserve">
          <source>Union Constructors</source>
          <target state="translated">연합 생성자</target>
        </trans-unit>
        <trans-unit id="b97025b5c9cabc7c40bfa14c6e38d256fa91fedc" translate="yes" xml:space="preserve">
          <source>Union of all data types. Storage allocated must be the right size of the data on the TARGET, not the host.</source>
          <target state="translated">모든 데이터 유형의 합집합 할당 된 스토리지는 호스트가 아닌 TARGET에있는 데이터의 올바른 크기 여야합니다.</target>
        </trans-unit>
        <trans-unit id="7fb0a0c24f714a3c6908f62d1750b60678074165" translate="yes" xml:space="preserve">
          <source>UnionExp &lt;code&gt;ue&lt;/code&gt;</source>
          <target state="translated">UnionExp의 &lt;code&gt;ue&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="40c214e69699ab35dd26f2aea53893c65df5da1a" translate="yes" xml:space="preserve">
          <source>UnionExp &lt;strong id=&quot;changeArrayLiteralLength&quot;&gt;changeArrayLiteralLength&lt;/strong&gt;(ref const Loc loc, TypeArray arrayType, Expression oldval, size_t oldlen, size_t newlen);</source>
          <target state="translated">UnionExp &lt;strong id=&quot;changeArrayLiteralLength&quot;&gt;changeArrayLiteralLength&lt;/strong&gt; (참조 const Loc loc, TypeArray arrayType, Expression oldval, size_t oldlen, size_t newlen 참조);</target>
        </trans-unit>
        <trans-unit id="1331c179350671227b2059c060f0fb6cc96a01f6" translate="yes" xml:space="preserve">
          <source>UnionExp &lt;strong id=&quot;voidInitLiteral&quot;&gt;voidInitLiteral&lt;/strong&gt;(Type t, VarDeclaration var);</source>
          <target state="translated">UnionExp &lt;strong id=&quot;voidInitLiteral&quot;&gt;voidInitLiteral&lt;/strong&gt; (Type t, VarDeclaration var);</target>
        </trans-unit>
        <trans-unit id="573f8fc1579ee858b3690058c2822e4646fa3070" translate="yes" xml:space="preserve">
          <source>UnionExp* &lt;code&gt;pue&lt;/code&gt;</source>
          <target state="translated">UnionExp * &lt;code&gt;pue&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="01e4d3a9b6c2a2f384ce5dac1eab2350dbb93588" translate="yes" xml:space="preserve">
          <source>Unions and Special Member Functions</source>
          <target state="translated">노동 조합과 특별 회원 기능</target>
        </trans-unit>
        <trans-unit id="a0102ec82c0bb90d78b643d15cf3fa6be00c6e25" translate="yes" xml:space="preserve">
          <source>Unions are a variation on structs.</source>
          <target state="translated">조합은 구조체의 변형입니다.</target>
        </trans-unit>
        <trans-unit id="a62d59993aea7f6e6c355a91c3f289c9e8b350b1" translate="yes" xml:space="preserve">
          <source>Unions are by default initialized to whatever the &lt;a href=&quot;declaration#Initializer&quot;&gt;&lt;i&gt;Initializer&lt;/i&gt;&lt;/a&gt; for the first field is, and if none is supplied, to the default initializer for the first field's type.</source>
          <target state="translated">유니언은 기본적으로 첫 번째 필드 의 이니셜 라이저에 관계없이 &lt;a href=&quot;declaration#Initializer&quot;&gt;&lt;i&gt;초기화&lt;/i&gt;&lt;/a&gt; 되며, 제공되지 않은 경우 첫 번째 필드 유형의 기본 이니셜 라이저로 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="4a6e457080b0b859845bccdbe95da2d70fb71565" translate="yes" xml:space="preserve">
          <source>Unions are constructed in the same way as structs.</source>
          <target state="translated">유니언은 구조체와 같은 방식으로 구성됩니다.</target>
        </trans-unit>
        <trans-unit id="f20d83de9444f44397049b15f04bc93ca6fb349d" translate="yes" xml:space="preserve">
          <source>Unions are initialized similarly to structs, except that only one initializer is allowed.</source>
          <target state="translated">유니언은 하나의 이니셜 라이저 만 허용된다는 점을 제외하고 구조체와 유사하게 초기화됩니다.</target>
        </trans-unit>
        <trans-unit id="0b47874cdb794bfd2c5c4b866c3d58b4a7e2e1c5" translate="yes" xml:space="preserve">
          <source>Unions may have fields that have destructors. However, a union itself never has a destructor. When a union goes out of scope, destructors for it's fields are not called. If those calls are desired, they must be inserted explicitly by the programmer:</source>
          <target state="translated">조합에는 소멸자가있는 필드가있을 수 있습니다. 그러나 노조 자체에는 결코 소멸자가 없습니다. 공용체가 범위를 벗어나면 해당 필드의 소멸자가 호출되지 않습니다. 이러한 호출이 필요한 경우 프로그래머가 명시 적으로 삽입해야합니다.</target>
        </trans-unit>
        <trans-unit id="2269a14097f76a4ebedc600cc449a6625817e305" translate="yes" xml:space="preserve">
          <source>Unions may have fields that have postblits. However, a union itself never has a postblit. Copying a union does not result in postblit calls for any fields. If those calls are desired, they must be inserted explicitly by the programmer:</source>
          <target state="translated">노조는 사격 후 필드를 가질 수 있습니다. 그러나 노조 자체에는 결코 사후 조치가 없습니다. 통합을 복사해도 필드에 대한 포스트 블리치 호출이 발생하지 않습니다. 이러한 호출이 필요한 경우 프로그래머가 명시 적으로 삽입해야합니다.</target>
        </trans-unit>
        <trans-unit id="b87fbd8e5787af83ccbd207ba527d5b29aa8f496" translate="yes" xml:space="preserve">
          <source>Unions may not have postblits, destructors, or invariants.</source>
          <target state="translated">노조는 후퇴, 소멸자 또는 변하지 않을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8298d2824bd021c0211d1ca231e5f2a363ecb036" translate="yes" xml:space="preserve">
          <source>Uniprocessor Garbage Collector Techniques</source>
          <target state="translated">단일 프로세서 가비지 수집기 기법</target>
        </trans-unit>
        <trans-unit id="27f5b1d97be4caf26df5cfa5ab8e2560a4fec6a2" translate="yes" xml:space="preserve">
          <source>Unique &lt;strong id=&quot;release&quot;&gt;release&lt;/strong&gt;();</source>
          <target state="translated">독창적 인 &lt;strong id=&quot;release&quot;&gt;출시&lt;/strong&gt; ();</target>
        </trans-unit>
        <trans-unit id="4be5d0f640b96963a935995d6fcf68492057bc00" translate="yes" xml:space="preserve">
          <source>Unique Expression</source>
          <target state="translated">독특한 표현</target>
        </trans-unit>
        <trans-unit id="5ff1a5fc9718890c18a9173ea983ebaa427e76cf" translate="yes" xml:space="preserve">
          <source>Unique!T &lt;strong id=&quot;create&quot;&gt;create&lt;/strong&gt;(A...)(auto ref A args)</source>
          <target state="translated">Unique! T &lt;strong id=&quot;create&quot;&gt;create&lt;/strong&gt; (A ...) (자동 참조 A 인수)</target>
        </trans-unit>
        <trans-unit id="438d23452047f4defac8e18aecae37372fcea335" translate="yes" xml:space="preserve">
          <source>Unit Testing</source>
          <target state="translated">단위 테스트</target>
        </trans-unit>
        <trans-unit id="55319d93decd49524c6577ad2944aab8499b8def" translate="yes" xml:space="preserve">
          <source>Unit Tests</source>
          <target state="translated">단위 테스트</target>
        </trans-unit>
        <trans-unit id="3db9bdfab0f022f13a4bb48d254cae9da8cb6639" translate="yes" xml:space="preserve">
          <source>Unit separator</source>
          <target state="translated">단위 분리기</target>
        </trans-unit>
        <trans-unit id="b3da7cee02b824a66bc3ea485a41f342035764bb" translate="yes" xml:space="preserve">
          <source>Unit tests are a builtin framework of test cases applied to a module to determine if it is working properly. A D program can be run with unit tests enabled or disabled.</source>
          <target state="translated">단위 테스트는 모듈이 올바르게 작동하는지 확인하기 위해 모듈에 적용되는 테스트 사례의 기본 프레임 워크입니다. 단위 테스트를 활성화 또는 비활성화하여 AD 프로그램을 실행할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="fefa6220ed6b9dc9a0e4d5cb4616b291bfab064b" translate="yes" xml:space="preserve">
          <source>Unit tests are a special function defined like:</source>
          <target state="translated">단위 테스트는 다음과 같이 정의 된 특수 기능입니다.</target>
        </trans-unit>
        <trans-unit id="ad9b402c3f3372b26a20431c0ca8997a9ad0b7f1" translate="yes" xml:space="preserve">
          <source>Unit tests are run in the lexical order in which they appear within a module.</source>
          <target state="translated">단위 테스트는 어휘 순서대로 실행되며 모듈 내에서 나타납니다.</target>
        </trans-unit>
        <trans-unit id="a5c1e04fbed64b862e97e53f2641fe2ab46a7d9e" translate="yes" xml:space="preserve">
          <source>Unit tests, when enabled, are run after all static initialization is complete and before the &lt;code&gt;main()&lt;/code&gt; function is called.</source>
          <target state="translated">활성화되면 유닛 테스트는 모든 정적 초기화가 완료된 후와 &lt;code&gt;main()&lt;/code&gt; 함수가 호출 되기 전에 실행 됩니다.</target>
        </trans-unit>
        <trans-unit id="055cf0570e66f2eea5181aa00a5c52d90e010552" translate="yes" xml:space="preserve">
          <source>UnitTestResult &lt;strong id=&quot;runModuleUnitTests&quot;&gt;runModuleUnitTests&lt;/strong&gt;();</source>
          <target state="translated">UnitTestResult &lt;strong id=&quot;runModuleUnitTests&quot;&gt;runModuleUnitTests&lt;/strong&gt; ();</target>
        </trans-unit>
        <trans-unit id="277414d40589e8e43fb1bb639e3eda546d3a39fa" translate="yes" xml:space="preserve">
          <source>Universally-unique identifiers for resources in distributed systems.</source>
          <target state="translated">분산 시스템의 자원에 대한 범용 고유 식별자.</target>
        </trans-unit>
        <trans-unit id="b65181ba4f28882f88c26feebc5a1054a0622a74" translate="yes" xml:space="preserve">
          <source>Unknown opcode in sqlite3_file_control()</source>
          <target state="translated">sqlite3_file_control ()의 알 수없는 opcode</target>
        </trans-unit>
        <trans-unit id="1931c3a0db3408e15d30035b5b64b4f6292dfc44" translate="yes" xml:space="preserve">
          <source>Unknown version</source>
          <target state="translated">알 수없는 버전</target>
        </trans-unit>
        <trans-unit id="33daa36ae00d362b5c2c8e9facf98bab576abcff" translate="yes" xml:space="preserve">
          <source>Unless a directory is specified in &lt;code&gt;args[0]&lt;/code&gt; or &lt;code&gt;program&lt;/code&gt;, &lt;code&gt;spawnProcess&lt;/code&gt; will search for the program in a platform-dependent manner. On POSIX systems, it will look for the executable in the directories listed in the PATH environment variable, in the order they are listed. On Windows, it will search for the executable in the following sequence:</source>
          <target state="translated">디렉토리가에 규정 된 경우를 제외하고 &lt;code&gt;args[0]&lt;/code&gt; 또는 &lt;code&gt;program&lt;/code&gt; , &lt;code&gt;spawnProcess&lt;/code&gt; 는 플랫폼에 의존하지 않는 방법으로 프로그램을 검색합니다. POSIX 시스템에서는 PATH 환경 변수에 나열된 디렉토리에서 실행 파일을 나열된 순서대로 찾습니다. Windows에서는 다음 순서로 실행 파일을 검색합니다.</target>
        </trans-unit>
        <trans-unit id="b365da39577f92d7cfe9d00eec2c0518ddb0e1eb" translate="yes" xml:space="preserve">
          <source>Unless marked as &lt;code&gt;@trusted&lt;/code&gt; or &lt;code&gt;@safe&lt;/code&gt;, artifacts in this module allow implicit data sharing between threads and cannot guarantee that client code is free from low level data races.</source>
          <target state="translated">&lt;code&gt;@trusted&lt;/code&gt; 또는 &lt;code&gt;@safe&lt;/code&gt; 로 표시되지 않는 한이 모듈의 아티팩트는 스레드간에 암시 적 데이터 공유를 허용하며 클라이언트 코드에 저수준 데이터 레이스가 없음을 보장 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="2fa828ccd66084db8a03f15b05f0b611fac7ce01" translate="yes" xml:space="preserve">
          <source>Unless the child process inherits the standard input/output/error streams of its parent, one almost always wants the streams closed in the parent when &lt;a href=&quot;#spawnProcess&quot;&gt;&lt;code&gt;spawnProcess&lt;/code&gt;&lt;/a&gt; returns. Therefore, by default, this is done. If this is not desirable, pass any of these options to spawnProcess.</source>
          <target state="translated">자식 프로세스가 부모의 표준 입력 / 출력 / 오류 스트림을 상속하지 않으면 &lt;a href=&quot;#spawnProcess&quot;&gt; &lt;code&gt;spawnProcess&lt;/code&gt; 가&lt;/a&gt; 반환 될 때 부모에서 항상 스트림을 닫기를 원합니다 . 따라서 기본적으로이 작업이 수행됩니다. 이것이 바람직하지 않은 경우, 이러한 옵션 중 하나를 spawnProcess에 전달하십시오.</target>
        </trans-unit>
        <trans-unit id="0408692a5b5d8444ca9b8f0092ac439bf7234efa" translate="yes" xml:space="preserve">
          <source>Unless your system's local time zone deals with leap seconds (which is highly unlikely), then the only way to get a time zone which takes leap seconds into account is to use &lt;code&gt;PosixTimeZone&lt;/code&gt; with a time zone whose name starts with &quot;right/&quot;. Those time zone files do include leap seconds, and &lt;code&gt;PosixTimeZone&lt;/code&gt; will take them into account (though posix systems which use a &quot;right/&quot; time zone as their local time zone will</source>
          <target state="translated">시스템의 현지 시간대가 윤초를 처리하지 않는 한 ( &lt;code&gt;PosixTimeZone&lt;/code&gt; 윤초를 고려하는 시간대를 얻는 유일한 방법 은 이름이 &quot;right /&quot;로 시작하는 시간대와 함께 PosixTimeZone 을 사용하는 것 입니다. 해당 시간대 파일에는 윤초가 포함되며 &lt;code&gt;PosixTimeZone&lt;/code&gt; 은 해당 시간대를 &quot;오른쪽 /&quot;시간대를 사용하는 posix 시스템을 현지 시간대로 사용합니다.</target>
        </trans-unit>
        <trans-unit id="64deb7f976a8cd98e26158b9c8e43cd6ab842a23" translate="yes" xml:space="preserve">
          <source>Unlike &lt;a href=&quot;#chunks&quot;&gt;&lt;code&gt;chunks&lt;/code&gt;&lt;/a&gt;, &lt;code&gt;evenChunks&lt;/code&gt; takes a chunk count (not size). The returned range will contain zero or more &lt;code&gt;source.length / chunkCount + 1&lt;/code&gt; elements followed by &lt;code&gt;source.length / chunkCount&lt;/code&gt; elements. If &lt;code&gt;source.length &amp;lt; chunkCount&lt;/code&gt;, some chunks will be empty.</source>
          <target state="translated">달리 &lt;a href=&quot;#chunks&quot;&gt; &lt;code&gt;chunks&lt;/code&gt; &lt;/a&gt; , &lt;code&gt;evenChunks&lt;/code&gt; 는 청크 수 (안 크기)합니다. 반환 된 범위에는 0 개 이상의 &lt;code&gt;source.length / chunkCount + 1&lt;/code&gt; 요소와 &lt;code&gt;source.length / chunkCount&lt;/code&gt; 요소가 포함됩니다. 경우 &lt;code&gt;source.length &amp;lt; chunkCount&lt;/code&gt; , 약간의 덩어리가 비어 있습니다.</target>
        </trans-unit>
        <trans-unit id="dcac2deafdbf1d1c8f905ae685dd247664bd1125" translate="yes" xml:space="preserve">
          <source>Unlike &lt;a href=&quot;#environment.opIndex&quot;&gt;&lt;code&gt;environment.opIndex&lt;/code&gt;&lt;/a&gt;, this function never throws on Posix.</source>
          <target state="translated">&lt;a href=&quot;#environment.opIndex&quot;&gt; &lt;code&gt;environment.opIndex&lt;/code&gt; &lt;/a&gt; 와 달리이 함수는 Posix에서 절대 발생하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="78c9b1ecfc17a2d5366ab58d22803f6df68d29c3" translate="yes" xml:space="preserve">
          <source>Unlike &lt;a href=&quot;#popFrontN&quot;&gt;&lt;code&gt;popFrontN&lt;/code&gt;&lt;/a&gt;, &lt;code&gt;popFrontExactly&lt;/code&gt; will assume that the range holds at least &lt;code&gt;n&lt;/code&gt; elements. This makes &lt;code&gt;popFrontExactly&lt;/code&gt; faster than &lt;code&gt;popFrontN&lt;/code&gt;, but it also means that if &lt;code&gt;range&lt;/code&gt; does not contain at least &lt;code&gt;n&lt;/code&gt; elements, it will attempt to call &lt;code&gt;popFront&lt;/code&gt; on an empty range, which is undefined behavior. So, only use &lt;code&gt;popFrontExactly&lt;/code&gt; when it is guaranteed that &lt;code&gt;range&lt;/code&gt; holds at least &lt;code&gt;n&lt;/code&gt; elements.</source>
          <target state="translated">달리 &lt;a href=&quot;#popFrontN&quot;&gt; &lt;code&gt;popFrontN&lt;/code&gt; &lt;/a&gt; , &lt;code&gt;popFrontExactly&lt;/code&gt; 이 범위는 적어도 유지한다고 가정한다 &lt;code&gt;n&lt;/code&gt; 소자. 이 만드는 &lt;code&gt;popFrontExactly&lt;/code&gt; 보다 빠른 &lt;code&gt;popFrontN&lt;/code&gt; 뿐만 아니라 수단이 경우 것으로 &lt;code&gt;range&lt;/code&gt; 포함하지 않는 최소한 &lt;code&gt;n&lt;/code&gt; 개의 요소, 그것은 전화를 시도합니다 &lt;code&gt;popFront&lt;/code&gt; 을 정의되지 않은 동작입니다 빈 범위에. 따라서 &lt;code&gt;range&lt;/code&gt; 가 &lt;code&gt;n&lt;/code&gt; 개 이상의 요소를 보유 한다고 보장되는 경우 에만 &lt;code&gt;popFrontExactly&lt;/code&gt; 를 사용 하십시오 .</target>
        </trans-unit>
        <trans-unit id="ca26f78b889208702d57ff1d787f37620c2c7d92" translate="yes" xml:space="preserve">
          <source>Unlike &lt;a href=&quot;#take&quot;&gt;&lt;code&gt;take&lt;/code&gt;&lt;/a&gt;, however, it is illegal to pass a range with less than &lt;code&gt;n&lt;/code&gt; elements to &lt;code&gt;takeExactly&lt;/code&gt;; this will cause an assertion failure.</source>
          <target state="translated">그러나 &lt;a href=&quot;#take&quot;&gt; &lt;code&gt;take&lt;/code&gt; &lt;/a&gt; 와 달리 , &lt;code&gt;n&lt;/code&gt; 개 미만의 요소로 범위를 전달 하여 &lt;code&gt;takeExactly&lt;/code&gt; 하는 것은 불법입니다 . 어설 션 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="59fe163f287d88736da3589233f0c4e6d80fde94" translate="yes" xml:space="preserve">
          <source>Unlike &lt;a href=&quot;#takeExactly&quot;&gt;&lt;code&gt;takeExactly&lt;/code&gt;&lt;/a&gt;, &lt;code&gt;take&lt;/code&gt; does not require that there are &lt;code&gt;n&lt;/code&gt; or more elements in &lt;code&gt;input&lt;/code&gt;. As a consequence, length information is not applied to the result unless &lt;code&gt;input&lt;/code&gt; also has length information.</source>
          <target state="translated">달리 &lt;a href=&quot;#takeExactly&quot;&gt; &lt;code&gt;takeExactly&lt;/code&gt; &lt;/a&gt; , &lt;code&gt;take&lt;/code&gt; 있다는 것을 필요로하지 않는다 &lt;code&gt;n&lt;/code&gt; 에서 이상의 요소 &lt;code&gt;input&lt;/code&gt; . 않는 결과, 길이 정보의 결과에 적용되지 않고 &lt;code&gt;input&lt;/code&gt; 또한 길이 정보를 갖는다.</target>
        </trans-unit>
        <trans-unit id="b8426ded2da3debb58d04add3a4a2ee0a01cedef" translate="yes" xml:space="preserve">
          <source>Unlike &lt;a href=&quot;expression#AssertExpression&quot;&gt;&lt;i&gt;AssertExpression&lt;/i&gt;&lt;/a&gt;s,</source>
          <target state="translated">달리 &lt;a href=&quot;expression#AssertExpression&quot;&gt;&lt;i&gt;AssertExpression&lt;/i&gt;&lt;/a&gt; 의,</target>
        </trans-unit>
        <trans-unit id="3c0a127638c1aa0ed774f4d832ca5f66eb374213" translate="yes" xml:space="preserve">
          <source>Unlike &lt;a href=&quot;https://daringfireball.net/projects/markdown/syntax&quot;&gt;Markdown&lt;/a&gt;, underscores (&lt;code&gt;_&lt;/code&gt;) are not supported for emphasizing text because it would break snake_case names and underscore prefix processing in &lt;a href=&quot;#emphasis&quot;&gt;identifier emphasis&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;https://daringfireball.net/projects/markdown/syntax&quot;&gt;Markdown&lt;/a&gt; 과 달리 밑줄 ( &lt;code&gt;_&lt;/code&gt; )은 텍스트를 강조하는 데 지원되지 않습니다 . 이는 &lt;a href=&quot;#emphasis&quot;&gt;식별자 강조&lt;/a&gt; 에서 snake_case 이름과 밑줄 접두어 처리를 중단하기 때문입니다 .</target>
        </trans-unit>
        <trans-unit id="62d6e6c303937f42cfdcfdeece835bc7d820f2ce" translate="yes" xml:space="preserve">
          <source>Unlike &lt;code&gt;drop&lt;/code&gt;, &lt;code&gt;dropExactly&lt;/code&gt; will assume that the range holds at least &lt;code&gt;n&lt;/code&gt; elements. This makes &lt;code&gt;dropExactly&lt;/code&gt; faster than &lt;code&gt;drop&lt;/code&gt;, but it also means that if &lt;code&gt;range&lt;/code&gt; does not contain at least &lt;code&gt;n&lt;/code&gt; elements, it will attempt to call &lt;code&gt;popFront&lt;/code&gt; on an empty range, which is undefined behavior. So, only use &lt;code&gt;popFrontExactly&lt;/code&gt; when it is guaranteed that &lt;code&gt;range&lt;/code&gt; holds at least &lt;code&gt;n&lt;/code&gt; elements.</source>
          <target state="translated">달리 &lt;code&gt;drop&lt;/code&gt; , &lt;code&gt;dropExactly&lt;/code&gt; 이 범위는 적어도 유지한다고 가정한다 &lt;code&gt;n&lt;/code&gt; 소자. 이 만드는 &lt;code&gt;dropExactly&lt;/code&gt; 보다 빠른 &lt;code&gt;drop&lt;/code&gt; 뿐만 아니라 수단이 경우 것으로 &lt;code&gt;range&lt;/code&gt; 포함하지 않는 최소한 &lt;code&gt;n&lt;/code&gt; 개의 요소, 그것은 전화를 시도합니다 &lt;code&gt;popFront&lt;/code&gt; 을 정의되지 않은 동작입니다 빈 범위에. 따라서 &lt;code&gt;range&lt;/code&gt; 가 &lt;code&gt;n&lt;/code&gt; 개 이상의 요소를 보유 한다고 보장되는 경우 에만 &lt;code&gt;popFrontExactly&lt;/code&gt; 를 사용 하십시오 .</target>
        </trans-unit>
        <trans-unit id="2dc495b4828660cfb1a6c926b761c16a9be27525" translate="yes" xml:space="preserve">
          <source>Unlike &lt;code&gt;isSorted&lt;/code&gt;, &lt;code&gt;isStrictlyMonotonic&lt;/code&gt; does not allow for equal values, i.e. values for which both &lt;code&gt;less(a, b)&lt;/code&gt; and &lt;code&gt;less(b, a)&lt;/code&gt; are false.</source>
          <target state="translated">달리 &lt;code&gt;isSorted&lt;/code&gt; , &lt;code&gt;isStrictlyMonotonic&lt;/code&gt; 은 동일한 값, 즉 어떤 값 모두를 허용하지 않는 &lt;code&gt;less(a, b)&lt;/code&gt; 및 &lt;code&gt;less(b, a)&lt;/code&gt; 거짓이다.</target>
        </trans-unit>
        <trans-unit id="d9f03ddd3a521372a8aeb68d3750dc19aca654fd" translate="yes" xml:space="preserve">
          <source>Unlike C, there is no global 'errno' variable. Consequently, almost all of these functions are pure nothrow.</source>
          <target state="translated">C와 달리 전역 'errno'변수는 없습니다. 결과적으로,이 기능들 대부분은 순수한 문제입니다.</target>
        </trans-unit>
        <trans-unit id="48065da6c19826224a06652b7752de447906d1e2" translate="yes" xml:space="preserve">
          <source>Unlike a template instantiation, a template mixin's body is evaluated within the scope where the mixin appears, not where the template declaration is defined. It is analogous to cutting and pasting the body of the template into the location of the mixin into a &lt;a href=&quot;#mixin_scope&quot;&gt;nested scope&lt;/a&gt;. It is useful for injecting parameterized &amp;lsquo;boilerplate&amp;rsquo; code, as well as for creating templated nested functions, which is not possible with template instantiations.</source>
          <target state="translated">템플릿 인스턴스화와 달리 템플릿 믹스 인의 본문은 템플릿 선언이 정의 된 위치가 아니라 믹스 인이 나타나는 범위 내에서 평가됩니다. 이는 템플릿 본문을 잘라내어 &lt;a href=&quot;#mixin_scope&quot;&gt;중첩 된 범위&lt;/a&gt; 로 믹스 인의 위치에 붙여 넣는 것과 유사합니다 . 템플릿 인스턴스화에서는 불가능한 템플릿 중첩 함수를 생성 할뿐만 아니라 매개 변수화 된 'boilerplate'코드를 주입하는 데 유용합니다.</target>
        </trans-unit>
        <trans-unit id="b78dd4d0c28721d6f33da60e8a9c5d426e8812c8" translate="yes" xml:space="preserve">
          <source>Unlike classes and interfaces with D linkage, &lt;code&gt;extern (C++)&lt;/code&gt; classes and interfaces are not rooted in &lt;code&gt;Object&lt;/code&gt; and cannot be used with &lt;code&gt;typeid&lt;/code&gt;.</source>
          <target state="translated">D 연결을 사용하는 클래스 및 인터페이스와 달리 &lt;code&gt;extern (C++)&lt;/code&gt; 클래스 및 인터페이스는 &lt;code&gt;Object&lt;/code&gt; 에서 루팅 되지 않으며 &lt;code&gt;typeid&lt;/code&gt; 와 함께 사용할 수 없습니다 .</target>
        </trans-unit>
        <trans-unit id="c4a06fb407933b874e0e43772b69d5b66b0d98d0" translate="yes" xml:space="preserve">
          <source>Unlike module level declarations, declarations within function scope are processed in order. This means that two nested functions cannot mutually call each other:</source>
          <target state="translated">모듈 수준 선언과 달리 함수 범위 내의 선언은 순서대로 처리됩니다. 이는 두 개의 중첩 함수가 서로를 호출 할 수 없음을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="1e921c8f35a8b97ca5f6203bfbaa7a401ab85c77" translate="yes" xml:space="preserve">
          <source>Unlike other functional programming languages, D's &lt;code&gt;pure&lt;/code&gt; functions allow modification of the caller state through their mutable parameters.</source>
          <target state="translated">다른 함수형 프로그래밍 언어와 달리 D의 &lt;code&gt;pure&lt;/code&gt; 함수를 사용하면 변경 가능한 매개 변수를 통해 호출자 상태를 수정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0b036ee20c8407122782725738b7cc625cbeaae0" translate="yes" xml:space="preserve">
          <source>Unlike the &lt;code&gt;shared&lt;/code&gt; attribute, &lt;code&gt;__gshared&lt;/code&gt; provides no safe-guards against data races or other multi-threaded synchronization issues. It is the responsibility of the programmer to ensure that access to variables marked &lt;code&gt;__gshared&lt;/code&gt; is synchronized correctly.</source>
          <target state="translated">&lt;code&gt;shared&lt;/code&gt; 속성 과 달리 &lt;code&gt;__gshared&lt;/code&gt; 는 데이터 경쟁 또는 기타 다중 스레드 동기화 문제에 대한 안전 보호 기능을 제공하지 않습니다. &lt;code&gt;__gshared&lt;/code&gt; 로 표시된 변수에 대한 액세스 가 올바르게 동기화 되도록하는 것은 프로그래머의 책임입니다 .</target>
        </trans-unit>
        <trans-unit id="c04836bfb0781712a35902e55ee66bab09a7b952" translate="yes" xml:space="preserve">
          <source>Unlike the allocators for the C and C++ programming languages, which manage the allocated size internally, these allocators require that the client maintains (or knows</source>
          <target state="translated">할당 된 크기를 내부적으로 관리하는 C 및 C ++ 프로그래밍 언어의 할당 자와 달리 이러한 할당자는 클라이언트가 유지 관리하거나 알고 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="4328a809b4119b5d1cdcaad1f63f238165209f39" translate="yes" xml:space="preserve">
          <source>Unlike the other modules in std.datetime, this module is not currently publicly imported in std.datetime.package, because the old versions of this functionality which use &lt;a href=&quot;core_time#TickDuration&quot;&gt;&lt;code&gt;core.time.TickDuration&lt;/code&gt;&lt;/a&gt; are in std.datetime.package and would conflict with the symbols in this module. After the old symbols have gone through the deprecation cycle and have been fully removed, then this module will be publicly imported in std.datetime.package. The old, deprecated symbols are currently scheduled to be removed from the documentation in October 2018 and fully removed from Phobos in October 2019.</source>
          <target state="translated">std.datetime의 다른 모듈과 달리이 모듈은 현재 std.datetime.package에서 공개적으로 가져 오지 않습니다. core.time.TickDuration을 사용하는이 기능의 이전 버전은 &lt;a href=&quot;core_time#TickDuration&quot;&gt; &lt;code&gt;core.time.TickDuration&lt;/code&gt; &lt;/a&gt; 있으며 기호와 충돌하기 때문입니다. 이 모듈에서. 이전 심볼이 사용 중단주기를 거쳐 완전히 제거 된 후이 모듈은 std.datetime.package에서 공개적으로 가져옵니다. 더 이상 사용되지 않는 오래된 기호는 현재 2018 년 10 월 설명서에서 제거되고 2019 년 10 월 Phobos에서 완전히 제거 될 예정입니다.</target>
        </trans-unit>
        <trans-unit id="7a96be23bb834e45b7c6ec859f0a33bbc2f1ea04" translate="yes" xml:space="preserve">
          <source>Unlike the other overloads of &lt;a href=&quot;#translate&quot;&gt;&lt;code&gt;translate&lt;/code&gt;&lt;/a&gt;, this one does not take an AA. Rather, it takes a &lt;code&gt;string&lt;/code&gt; generated by &lt;a href=&quot;#makeTransTable&quot;&gt;&lt;code&gt;makeTransTable&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#translate&quot;&gt; &lt;code&gt;translate&lt;/code&gt; &lt;/a&gt; 의 다른 과부하와는 달리 , 이것은 AA를 취하지 않습니다. 오히려 &lt;a href=&quot;#makeTransTable&quot;&gt; &lt;code&gt;makeTransTable&lt;/code&gt; 에&lt;/a&gt; 의해 생성 된 &lt;code&gt;string&lt;/code&gt; 이 필요합니다 .</target>
        </trans-unit>
        <trans-unit id="a2e414f9a9014ee44b7edd2f5c74b2ba99d64ccc" translate="yes" xml:space="preserve">
          <source>Unlike the rint functions, nearbyint does not raise the FE_INEXACT exception.</source>
          <target state="translated">rint 함수와 달리 nearint는 FE_INEXACT 예외를 발생시키지 않습니다.</target>
        </trans-unit>
        <trans-unit id="57cc5a44978b2a56fd0b72e29be98d16b0472af0" translate="yes" xml:space="preserve">
          <source>Unloads the dynamic library referenced by p. If this library contains a D runtime then any necessary finalization or cleanup of that runtime will be performed.</source>
          <target state="translated">p가 참조하는 동적 라이브러리를 언로드합니다. 이 라이브러리에 D 런타임이 포함 된 경우 해당 런타임의 필요한 마무리 또는 정리가 수행됩니다.</target>
        </trans-unit>
        <trans-unit id="2e66bd886206de5f2b17ce23c8df1ed8d25d65b5" translate="yes" xml:space="preserve">
          <source>Unlock Notification</source>
          <target state="translated">알림 잠금 해제</target>
        </trans-unit>
        <trans-unit id="664d16b3bbd5ce740428335dc91179d8203f0409" translate="yes" xml:space="preserve">
          <source>Unpacks the content of a &lt;code&gt;Nullable&lt;/code&gt;, performs an operation and packs it again. Does nothing if isNull.</source>
          <target state="translated">&lt;code&gt;Nullable&lt;/code&gt; 의 내용을 압축 해제하고 작업을 수행 한 후 다시 압축합니다. isNull이면 아무것도하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="cc345a9119374c547d811f8c7da41c9ef92ad2fe" translate="yes" xml:space="preserve">
          <source>Unpadded variation of Base64 encoding that is safe for use in URLs and filenames, as used in RFCs 4648 and 7515 (JWS/JWT/JWE).</source>
          <target state="translated">RFC 4648 및 7515 (JWS / JWT / JWE)에 사용 된 URL 및 파일 이름에 안전한 Base64 인코딩의 패딩되지 않은 변형입니다.</target>
        </trans-unit>
        <trans-unit id="f88d720623b583f1cffc913373fdcc3a60ba2726" translate="yes" xml:space="preserve">
          <source>Unqual!(ElementEncodingType!R)[] &lt;strong id=&quot;makeArray&quot;&gt;makeArray&lt;/strong&gt;(Allocator, R)(auto ref Allocator alloc, R range)</source>
          <target state="translated">Unqual! (ElementEncodingType! R) [] &lt;strong id=&quot;makeArray&quot;&gt;makeArray&lt;/strong&gt; (Allocator, R) (자동 참조 할당 자 할당, R 범위)</target>
        </trans-unit>
        <trans-unit id="3c02fdbec5f33d0e592b953502081d961d449bb0" translate="yes" xml:space="preserve">
          <source>Unqual!(Largest!(F, H)) &lt;strong id=&quot;powmod&quot;&gt;powmod&lt;/strong&gt;(F, G, H)(F x, G n, H m)</source>
          <target state="translated">부적합! (가장 큰! (F, H)) &lt;strong id=&quot;powmod&quot;&gt;powmod&lt;/strong&gt; (F, G, H) (F x, G n, H m)</target>
        </trans-unit>
        <trans-unit id="2bcb32fecdb532acd729e7486f0232969b7c3e9c" translate="yes" xml:space="preserve">
          <source>Unqual!F &lt;strong id=&quot;quantize&quot;&gt;quantize&lt;/strong&gt;(alias rfunc = rint, F)(const F val, const F unit)</source>
          <target state="translated">Unqual! F &lt;strong id=&quot;quantize&quot;&gt;양자화&lt;/strong&gt; (별칭 rfunc = rint, F) (const F val, const F 단위)</target>
        </trans-unit>
        <trans-unit id="9a98f2e85574e76d68401f4ce73c39509c4a2933" translate="yes" xml:space="preserve">
          <source>Unqual!F &lt;strong id=&quot;quantize&quot;&gt;quantize&lt;/strong&gt;(real base, alias rfunc = rint, F, E)(const F val, const E exp)</source>
          <target state="translated">Unqual! F &lt;strong id=&quot;quantize&quot;&gt;양자화&lt;/strong&gt; (실제베이스, 앨리어스 rfunc = rint, F, E) (const F val, const E exp)</target>
        </trans-unit>
        <trans-unit id="1e2635e37463787b5dba88522830617f525b628d" translate="yes" xml:space="preserve">
          <source>Unqual!F &lt;strong id=&quot;quantize&quot;&gt;quantize&lt;/strong&gt;(real base, long exp = 1, alias rfunc = rint, F)(const F val)</source>
          <target state="translated">Unqual! F &lt;strong id=&quot;quantize&quot;&gt;양자화&lt;/strong&gt; (실제베이스, 긴 exp = 1, 앨리어스 rfunc = rint, F) (const F val)</target>
        </trans-unit>
        <trans-unit id="5a8d3ca0e300be0d25c318a263a03af4f2fff63d" translate="yes" xml:space="preserve">
          <source>Unqualified data has unqualified affixes.</source>
          <target state="translated">규정되지 않은 데이터에는 규정되지 않은 접미사가 있습니다.</target>
        </trans-unit>
        <trans-unit id="c723d38c4fa3b7930c545d9e405d1f146212a63e" translate="yes" xml:space="preserve">
          <source>Unrestricted use of compile-time features</source>
          <target state="translated">컴파일 타임 기능의 무제한 사용</target>
        </trans-unit>
        <trans-unit id="80cfb4a037726fdae410bbf6df144554bff220d4" translate="yes" xml:space="preserve">
          <source>Unsafe function that wraps an existing &lt;code&gt;FILE*&lt;/code&gt;. The resulting &lt;code&gt;File&lt;/code&gt; never takes the initiative in closing the file. Note that the created file has no &lt;a href=&quot;#name&quot;&gt;&lt;code&gt;name&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">기존 &lt;code&gt;FILE*&lt;/code&gt; 를 감싸는 안전하지 않은 기능 . 결과 &lt;code&gt;File&lt;/code&gt; 은 파일을 닫을 때 주도권을 가지지 않습니다. 작성된 파일에는 &lt;a href=&quot;#name&quot;&gt; &lt;code&gt;name&lt;/code&gt; &lt;/a&gt; 이 없습니다.</target>
        </trans-unit>
        <trans-unit id="65422cb666169d3f3987078a0c14c3573d3c2445" translate="yes" xml:space="preserve">
          <source>Unsigned long divide.</source>
          <target state="translated">부호없는 긴 나누기</target>
        </trans-unit>
        <trans-unit id="0b87e9858f088c1c3ef7326a4daa7bc92af7a7dd" translate="yes" xml:space="preserve">
          <source>Unsigned or signed integers to strings.</source>
          <target state="translated">문자열에 부호없는 또는 부호있는 정수.</target>
        </trans-unit>
        <trans-unit id="7dd2dae7076eed8003f9916d0a11ef6b86330446" translate="yes" xml:space="preserve">
          <source>Unsigned types are forwarded</source>
          <target state="translated">부호없는 유형이 전달됩니다</target>
        </trans-unit>
        <trans-unit id="db264537a77391b4d1ffa4ba5078dbd65e89c632" translate="yes" xml:space="preserve">
          <source>Unsigned!T &lt;strong id=&quot;absUnsign&quot;&gt;absUnsign&lt;/strong&gt;(T)(T x)</source>
          <target state="translated">부호 없음! T &lt;strong id=&quot;absUnsign&quot;&gt;abs&lt;/strong&gt; 부호 &lt;strong id=&quot;absUnsign&quot;&gt;없음&lt;/strong&gt; (T) (T x)</target>
        </trans-unit>
        <trans-unit id="ee28505eeae48ed21fb9c1a0cf9d2afe5eb71525" translate="yes" xml:space="preserve">
          <source>Unspecified address family</source>
          <target state="translated">지정되지 않은 주소 패밀리</target>
        </trans-unit>
        <trans-unit id="12a25d56dc3fd00254d1725dedadf02ca44b6632" translate="yes" xml:space="preserve">
          <source>Until!(pred, Range, Sentinel) &lt;strong id=&quot;until&quot;&gt;until&lt;/strong&gt;(alias pred = &quot;a == b&quot;, Range, Sentinel)(Range range, Sentinel sentinel, OpenRight openRight = Yes.openRight)</source>
          <target state="translated">까지! (pred, Range, Sentinel) &lt;strong id=&quot;until&quot;&gt;까지&lt;/strong&gt; (별칭 pred = &quot;a == b&quot;, Range, Sentinel) (범위 범위, Sentinel sentinel, OpenRight openRight = Yes.openRight)</target>
        </trans-unit>
        <trans-unit id="4b4508b4a6bcff851bf86982a2055c2003b1fa47" translate="yes" xml:space="preserve">
          <source>Until!(pred, Range, void) &lt;strong id=&quot;until&quot;&gt;until&lt;/strong&gt;(alias pred, Range)(Range range, OpenRight openRight = Yes.openRight);</source>
          <target state="translated">까지! (pred, Range, void) &lt;strong id=&quot;until&quot;&gt;까지&lt;/strong&gt; (별칭 pred, Range) (범위 범위, OpenRight openRight = 예 .openRight);</target>
        </trans-unit>
        <trans-unit id="9c59dea84fd569db02119fea1a063859bf29b83a" translate="yes" xml:space="preserve">
          <source>Untyped array of bytes read.</source>
          <target state="translated">형식화되지 않은 바이트 배열을 읽습니다.</target>
        </trans-unit>
        <trans-unit id="4136979d06ff082f9f315b1eebb740ff6c03f3f6" translate="yes" xml:space="preserve">
          <source>Unused</source>
          <target state="translated">Unused</target>
        </trans-unit>
        <trans-unit id="b6935e98e40b6e21b32a31ee8441a03644c81e5c" translate="yes" xml:space="preserve">
          <source>Update real environment with our copy.</source>
          <target state="translated">사본으로 실제 환경을 업데이트하십시오.</target>
        </trans-unit>
        <trans-unit id="9bfdc7ffd31c3f1d9f8a46b9030a47cb21f4a6a6" translate="yes" xml:space="preserve">
          <source>Upload file from local files system using the HTTP or FTP protocol.</source>
          <target state="translated">HTTP 또는 FTP 프로토콜을 사용하여 로컬 파일 시스템에서 파일을 업로드하십시오.</target>
        </trans-unit>
        <trans-unit id="d92a94252ae6e6e7308555bfab068876b651496a" translate="yes" xml:space="preserve">
          <source>Upon a correct comparison, returns the result of the comparison. Otherwise, the function terminates the application so it never returns.</source>
          <target state="translated">올바르게 비교하면 비교 결과를 반환합니다. 그렇지 않으면 함수는 응용 프로그램을 종료하므로 반환되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="635a8d59b65d6fe6e79727c2b607e63e7021a7fc" translate="yes" xml:space="preserve">
          <source>Upon a mistaken comparison such as &lt;code&gt;int(-1) &amp;lt; uint(0)&lt;/code&gt;, the function never returns because it throws a &lt;code&gt;Throw.CheckedFailure&lt;/code&gt; exception.</source>
          <target state="translated">&lt;code&gt;int(-1) &amp;lt; uint(0)&lt;/code&gt; 과 같은 잘못된 비교시 함수는 &lt;code&gt;Throw.CheckedFailure&lt;/code&gt; 예외를 발생 시키기 때문에 반환되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="fa0a038d12e10d6ea11977030e0079027d88a558" translate="yes" xml:space="preserve">
          <source>Upon deallocation, the deallocated block is inserted in the internally maintained free tree (not returned to the parent). The free tree is not kept balanced. Instead, it has a last-in-first-out flavor because newly inserted blocks are rotated to the root of the tree. That way allocations are cache friendly and also frequently used sizes are more likely to be found quickly, whereas seldom used sizes migrate to the leaves of the tree.</source>
          <target state="translated">할당 해제시 할당 해제 된 블록은 내부적으로 유지 관리되는 사용 가능한 트리에 삽입됩니다 (부모에게 반환되지 않음). 사용 가능한 트리는 균형을 유지하지 않습니다. 대신 새로 삽입 된 블록이 트리의 루트로 회전하기 때문에 후입 선출 방식이 있습니다. 이렇게하면 할당이 캐시에 친숙하고 자주 사용되는 크기를 빨리 찾을 수있는 반면, 사용 된 크기는 트리의 잎으로 거의 이동하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="5f1bf936fc97a8f0474440921cf17c9bca92dd9a" translate="yes" xml:space="preserve">
          <source>Upper case letters</source>
          <target state="translated">대문자</target>
        </trans-unit>
        <trans-unit id="83087183cf2fc461034d823bb990cf31750aea63" translate="yes" xml:space="preserve">
          <source>Uppercase</source>
          <target state="translated">Uppercase</target>
        </trans-unit>
        <trans-unit id="7a4164382331e68559c0554c6d69676b3cadeb03" translate="yes" xml:space="preserve">
          <source>Uppercase_Letter</source>
          <target state="translated">Uppercase_Letter</target>
        </trans-unit>
        <trans-unit id="c697647e510548f93776f9aafa822873da30eacb" translate="yes" xml:space="preserve">
          <source>UprExpression</source>
          <target state="translated">UprExpression</target>
        </trans-unit>
        <trans-unit id="0bb18642b70b9f8a9c12ccf39487328f306b8e19" translate="yes" xml:space="preserve">
          <source>Usage</source>
          <target state="translated">Usage</target>
        </trans-unit>
        <trans-unit id="607204c2f99f603cd34be761bcbeaa8343288f47" translate="yes" xml:space="preserve">
          <source>Usage is otherwise identical to &lt;code&gt;task&lt;/code&gt;.</source>
          <target state="translated">그렇지 않으면 사용법은 &lt;code&gt;task&lt;/code&gt; 와 동일합니다 .</target>
        </trans-unit>
        <trans-unit id="47d7700c39adc856cd703ac849cd6f7a58cd58a0" translate="yes" xml:space="preserve">
          <source>Use &lt;a href=&quot;#DigestType&quot;&gt;&lt;code&gt;DigestType&lt;/code&gt;&lt;/a&gt; to obtain the actual return type.</source>
          <target state="translated">실제 리턴 유형을 얻으려면 &lt;a href=&quot;#DigestType&quot;&gt; &lt;code&gt;DigestType&lt;/code&gt; &lt;/a&gt; 을 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="adbbdb084a9fb0ec3254af6094f4eb6c04b801eb" translate="yes" xml:space="preserve">
          <source>Use &lt;a href=&quot;#digestLength&quot;&gt;&lt;code&gt;digestLength&lt;/code&gt;&lt;/a&gt; to obtain the length of the ubyte array.</source>
          <target state="translated">&lt;a href=&quot;#digestLength&quot;&gt; &lt;code&gt;digestLength&lt;/code&gt; &lt;/a&gt; 를 사용 하여 ubyte 배열의 길이를 얻으십시오.</target>
        </trans-unit>
        <trans-unit id="b3231f8622cd090ef9e587f5edbb465aca7b09c8" translate="yes" xml:space="preserve">
          <source>Use &lt;a href=&quot;#feqrel&quot;&gt;&lt;code&gt;feqrel&lt;/code&gt;&lt;/a&gt; to get the number of equal bits in the mantissa.</source>
          <target state="translated">가수에서 등가 비트 수를 얻으려면 &lt;a href=&quot;#feqrel&quot;&gt; &lt;code&gt;feqrel&lt;/code&gt; &lt;/a&gt; 을 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="6d9307c326b8942333b6c398ebd4c07ddf71f566" translate="yes" xml:space="preserve">
          <source>Use &lt;a href=&quot;#isFunctionPointer&quot;&gt;&lt;code&gt;isFunctionPointer&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;#isDelegate&quot;&gt;&lt;code&gt;isDelegate&lt;/code&gt;&lt;/a&gt; for detecting those types respectively.</source>
          <target state="translated">이러한 유형을 각각 감지 하려면 &lt;a href=&quot;#isFunctionPointer&quot;&gt; &lt;code&gt;isFunctionPointer&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;#isDelegate&quot;&gt; &lt;code&gt;isDelegate&lt;/code&gt; &lt;/a&gt; 를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="05ceeae1c0ec5acb33be5d48da2dcb40fadf69b9" translate="yes" xml:space="preserve">
          <source>Use &lt;a href=&quot;#makeTransTable&quot;&gt;&lt;code&gt;makeTransTable&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="translated">대신 &lt;a href=&quot;#makeTransTable&quot;&gt; &lt;code&gt;makeTransTable&lt;/code&gt; &lt;/a&gt; 을 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="f0a91d81a9ba5ac4e99ca49d89974cc7a9058e19" translate="yes" xml:space="preserve">
          <source>Use &lt;a href=&quot;std_range#only&quot;&gt;&lt;code&gt;std.range.only&lt;/code&gt;&lt;/a&gt; to find single elements:</source>
          <target state="translated">단일 요소를 찾으 &lt;a href=&quot;std_range#only&quot;&gt; &lt;code&gt;std.range.only&lt;/code&gt; &lt;/a&gt; 를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="48dd858d3ce799ecfe17031cfb5c7e47121b6231" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;Yes.keepTerminator&lt;/code&gt; to include the terminator at the end of each line.</source>
          <target state="translated">각 줄 끝에 터미네이터를 포함 &lt;code&gt;Yes.keepTerminator&lt;/code&gt; 려면 예. keepTerminator 를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="8b6c1674d2f204c22694f576b979cd1814df2141" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;fold&lt;/code&gt; instead of &lt;code&gt;reduce&lt;/code&gt; to use the seed version in a UFCS chain.</source>
          <target state="translated">사용은 &lt;code&gt;fold&lt;/code&gt; 대신 &lt;code&gt;reduce&lt;/code&gt; UFCS 체인의 씨앗 버전을 사용 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ffd1556b516ef1f66dbe93c932b16f01c4bc9667" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;ptrdiff_t&lt;/code&gt; as an alias for a signed integral type that can span the address space. A type representing the difference between two pointers should be of type &lt;code&gt;ptrdiff_t&lt;/code&gt;.</source>
          <target state="translated">주소 공간을 확장 할 수있는 부호있는 정수 유형의 별명으로 &lt;code&gt;ptrdiff_t&lt;/code&gt; 를 사용하십시오 . 두 포인터 사이의 차이를 나타내는 유형은 &lt;code&gt;ptrdiff_t&lt;/code&gt; 유형이어야합니다 .</target>
        </trans-unit>
        <trans-unit id="7fdf440fcaae93b5efe254ec61870d973ace818a" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;size_t&lt;/code&gt; as an alias for an unsigned integral type that can span the address space. Array indices should be of type &lt;code&gt;size_t&lt;/code&gt;.</source>
          <target state="translated">주소 공간을 확장 할 수있는 부호없는 정수 유형의 별명으로 &lt;code&gt;size_t&lt;/code&gt; 를 사용하십시오 . 배열 인덱스는 &lt;code&gt;size_t&lt;/code&gt; 유형이어야합니다 .</target>
        </trans-unit>
        <trans-unit id="0c8e53d39e2a0f98ecbcc400dea4845b6223508c" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;t.expand&lt;/code&gt; for a &lt;code&gt;Tuple&lt;/code&gt;&lt;code&gt;t&lt;/code&gt; to expand it into its components. The result of &lt;code&gt;expand&lt;/code&gt; acts as if the &lt;code&gt;Tuple&lt;/code&gt;'s components were listed as a list of values. (Ordinarily, a &lt;code&gt;Tuple&lt;/code&gt; acts as a single value.)</source>
          <target state="translated">&lt;code&gt;Tuple&lt;/code&gt; &lt;code&gt;t&lt;/code&gt; 에 &lt;code&gt;t.expand&lt;/code&gt; 를 사용 하여 컴포넌트로 확장하십시오. 의 결과 &lt;code&gt;expand&lt;/code&gt; 은 if 역할을 &lt;code&gt;Tuple&lt;/code&gt; 의 구성 요소 값 목록으로 표시했다. 일반적으로 &lt;code&gt;Tuple&lt;/code&gt; 은 단일 값으로 작동합니다.</target>
        </trans-unit>
        <trans-unit id="48d884b7ca15aa475ec50789ca2ff3e23d86c484" translate="yes" xml:space="preserve">
          <source>Use EnumMembers to generate a switch statement using static foreach.</source>
          <target state="translated">정적 foreach를 사용하여 switch 문을 생성하려면 EnumMembers를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="ea3185b41d0b5eef9ea7299e9eaac7a36af0572e" translate="yes" xml:space="preserve">
          <source>Use a delegate:</source>
          <target state="translated">대리인을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="0c1e0d0bf9ac652eb81fddab0fdf99124b593eff" translate="yes" xml:space="preserve">
          <source>Use a lambda to get the thrown object.</source>
          <target state="translated">던져진 객체를 얻으려면 람다를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="873a141220012e552838fdcfee0dd363789fe021" translate="yes" xml:space="preserve">
          <source>Use a range for splitting</source>
          <target state="translated">분할 범위를 사용하십시오</target>
        </trans-unit>
        <trans-unit id="743a812236b290eb42a4bbf575f256526d81c48f" translate="yes" xml:space="preserve">
          <source>Use a separate mutex when init blocks on another thread that might also call initOnce.</source>
          <target state="translated">initOnce를 호출 할 수도있는 다른 스레드에서 init가 차단 될 때 별도의 뮤텍스를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="b175392fd564ac3cefbc17dfb5b685defa989e44" translate="yes" xml:space="preserve">
          <source>Use a union to share storage with a pointer:</source>
          <target state="translated">공용체를 사용하여 포인터와 스토리지를 공유하십시오.</target>
        </trans-unit>
        <trans-unit id="b01dba754a5979101f473d00f0a72b08eaa453e0" translate="yes" xml:space="preserve">
          <source>Use an automated tool such as SWIG to construct a C wrapper.</source>
          <target state="translated">SWIG와 같은 자동화 된 도구를 사용하여 C 랩퍼를 구성하십시오.</target>
        </trans-unit>
        <trans-unit id="391314ce9442e0f12875856e20c62869fdd57c69" translate="yes" xml:space="preserve">
          <source>Use an existing socket handle.</source>
          <target state="translated">기존 소켓 핸들을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="a7f84b37a52370f02dd55991fe07b971f3630397" translate="yes" xml:space="preserve">
          <source>Use bitwise OR to combine flags.</source>
          <target state="translated">비트 OR을 사용하여 플래그를 결합하십시오.</target>
        </trans-unit>
        <trans-unit id="d8684aed3619612b2b8756065eb3877a3a2f839f" translate="yes" xml:space="preserve">
          <source>Use dynamic arrays for larger arrays.</source>
          <target state="translated">더 큰 배열에는 동적 배열을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="666b47896c954d06222547665bcbfad2b613e2cd" translate="yes" xml:space="preserve">
          <source>Use dynamic arrays instead of pointers to arrays as much as practical. Indexing of dynamic arrays are bounds checked, avoiding buffer underflow and overflow problems.</source>
          <target state="translated">배열에 대한 포인터 대신 동적 배열을 사용하십시오. 버퍼 언더 플로 및 오버플로 문제를 피하면서 동적 배열의 인덱싱을 검사합니다.</target>
        </trans-unit>
        <trans-unit id="7d2098c363acbeebbd0189589ce87c1539461b35" translate="yes" xml:space="preserve">
          <source>Use exceptions when input has incorrect CSV.</source>
          <target state="translated">입력에 잘못된 CSV가있는 경우 예외를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="4f7a702bd6e584b41d91d0f760813b556c810824" translate="yes" xml:space="preserve">
          <source>Use instead:</source>
          <target state="translated">대신 사용하십시오 :</target>
        </trans-unit>
        <trans-unit id="a0bd8b9fd1352e9a7ee83b86e96f850112dd5cf1" translate="yes" xml:space="preserve">
          <source>Use leading zeros to pad rather than spaces (except for the floating point values &lt;code&gt;nan&lt;/code&gt; and &lt;code&gt;infinity&lt;/code&gt;). Ignore if there's a</source>
          <target state="translated">부동 소수점 값 &lt;code&gt;nan&lt;/code&gt; 및 &lt;code&gt;infinity&lt;/code&gt; 를 제외하고 공백이 아닌 앞에 0을 사용하십시오 . 있는 경우 무시</target>
        </trans-unit>
        <trans-unit id="e9eb0693d837d691dc401377d0b5f372d6ba7c76" translate="yes" xml:space="preserve">
          <source>Use native byte order</source>
          <target state="translated">기본 바이트 순서 사용</target>
        </trans-unit>
        <trans-unit id="494d644b4cea82b0f2a11f12d31fe2c2c6340bb0" translate="yes" xml:space="preserve">
          <source>Use of this facility may invalidate grapheme cluster, see also &lt;a href=&quot;#Grapheme.valid&quot;&gt;&lt;code&gt;Grapheme.valid&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 기능을 사용하면 grapheme 클러스터가 무효화 될 수 있습니다 ( &lt;a href=&quot;#Grapheme.valid&quot;&gt; &lt;code&gt;Grapheme.valid&lt;/code&gt; &lt;/a&gt; 참조) .</target>
        </trans-unit>
        <trans-unit id="b875251d6eb81c5967bf6e62329a54f26bfa6687" translate="yes" xml:space="preserve">
          <source>Use of this facility may invalidate grapheme cluster, see also &lt;code&gt;valid&lt;/code&gt;.</source>
          <target state="translated">이 기능을 사용하면 grapheme 클러스터가 무효화 될 수 있습니다 . &lt;code&gt;valid&lt;/code&gt; 도 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="884a243fefd8e60fe323817fec2a996c8bebbfbc" translate="yes" xml:space="preserve">
          <source>Use of void initializers is rarely useful for individual local variables, as a modern optimizer will remove the dead store of its initialization if it is initialized later.</source>
          <target state="translated">현대의 옵티마이 저가 나중에 초기화되면 죽은 저장소를 제거하므로 void 이니셜 라이저를 사용하는 것은 개별 로컬 변수에 거의 유용하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="5f23be35fdcc7ad601fb3afd85d59caa262fe40f" translate="yes" xml:space="preserve">
          <source>Use of with object symbols that shadow local symbols with the same identifier are not allowed. This is to reduce the risk of inadvertent breakage of with statements when new members are added to the object declaration.</source>
          <target state="translated">동일한 식별자로 로컬 심볼을 음영 처리하는 객체 심볼과 함께 사용할 수 없습니다. 이는 새 멤버가 객체 선언에 추가 될 때 with 문이 실수로 손상 될 위험을 줄입니다.</target>
        </trans-unit>
        <trans-unit id="191654677e98da602653c371d9dfd799ee8ada8a" translate="yes" xml:space="preserve">
          <source>Use only if you have waited on every &lt;code&gt;Task&lt;/code&gt; and therefore know the queue is empty, or if you speculatively executed some tasks and no longer need the results.</source>
          <target state="translated">모든 &lt;code&gt;Task&lt;/code&gt; 을 기다렸다가 대기열이 비어 있음을 알고 있거나 추론 적으로 일부 작업을 실행하여 더 이상 결과가 필요하지 않은 경우에만 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="6a3134f25820d6e9b99efcc040afa78a19060e81" translate="yes" xml:space="preserve">
          <source>Use opSlice() from now on.</source>
          <target state="translated">지금부터 opSlice ()를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="0f7ce138690e71e3a3dfa4ced6f5458ab1f5899d" translate="yes" xml:space="preserve">
          <source>Use splitter without a separator</source>
          <target state="translated">분리기가없는 스플리터 사용</target>
        </trans-unit>
        <trans-unit id="18386a6712ddd2e90ccdfcddd96ef23c786f1142" translate="yes" xml:space="preserve">
          <source>Use the &lt;a href=&quot;#RangePrimitive&quot;&gt;&lt;code&gt;RangePrimitive&lt;/code&gt;&lt;/a&gt; enum to specify which primitives to handle. Multiple range primitives can be handled at once by using the &lt;code&gt;OR&lt;/code&gt; operator or the pseudo-primitives &lt;code&gt;RangePrimitive.access&lt;/code&gt; and &lt;code&gt;RangePrimitive.pop&lt;/code&gt;. All handled primitives must have return types or values compatible with the user-supplied handler.</source>
          <target state="translated">처리 할 프리미티브를 지정 하려면 &lt;a href=&quot;#RangePrimitive&quot;&gt; &lt;code&gt;RangePrimitive&lt;/code&gt; &lt;/a&gt; 열거를 사용하십시오 . &lt;code&gt;OR&lt;/code&gt; 연산자 또는 의사 프리미티브 &lt;code&gt;RangePrimitive.access&lt;/code&gt; 및 &lt;code&gt;RangePrimitive.pop&lt;/code&gt; 을 사용하여 여러 범위 프리미티브를 한 번에 처리 할 수 ​​있습니다 . 처리 된 모든 프리미티브에는 사용자 제공 핸들러와 호환 가능한 리턴 유형 또는 값이 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="0b5f27af6328268d2605eb68f81d45548b5054bd" translate="yes" xml:space="preserve">
          <source>Use the &lt;a href=&quot;#dur&quot;&gt;&lt;code&gt;dur&lt;/code&gt;&lt;/a&gt; function or one of its non-generic aliases to create &lt;code&gt;Duration&lt;/code&gt;s.</source>
          <target state="translated">사용 &lt;a href=&quot;#dur&quot;&gt; &lt;code&gt;dur&lt;/code&gt; &lt;/a&gt; 생성 기능 또는 제네릭이 아닌 별명 중 하나를 &lt;code&gt;Duration&lt;/code&gt; 들.</target>
        </trans-unit>
        <trans-unit id="78a059e1d81c669061770e6ebc73b731a6af9efd" translate="yes" xml:space="preserve">
          <source>Use the &lt;code&gt;arrayPtr&lt;/code&gt; overload of &lt;a href=&quot;#appender&quot;&gt;&lt;code&gt;appender&lt;/code&gt;&lt;/a&gt; for construction with type-inference.</source>
          <target state="translated">타입 추론으로 구성하기 위해서는 &lt;a href=&quot;#appender&quot;&gt; &lt;code&gt;appender&lt;/code&gt; &lt;/a&gt; 의 &lt;code&gt;arrayPtr&lt;/code&gt; 과부하를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="d09a4630f154886909155b3e1ae35f59cb094891" translate="yes" xml:space="preserve">
          <source>Use the ForwardingScopeDsymbol as the parent symbol for members.</source>
          <target state="translated">ForwardingScopeDsymbol을 멤버의 상위 심볼로 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="225bd24669abe9be158ae39e2ef06005821005b8" translate="yes" xml:space="preserve">
          <source>Use the SOCKS5 protocol but pass along the host name rather than the IP address. added in 7.18.0</source>
          <target state="translated">SOCKS5 프로토콜을 사용하되 IP 주소가 아닌 호스트 이름을 전달하십시오. 7.18.0에서 추가됨</target>
        </trans-unit>
        <trans-unit id="5ad265a5408a557c8739bbf477749f03fe8edee2" translate="yes" xml:space="preserve">
          <source>Use the attributes &lt;code&gt;@nogc&lt;/code&gt; as much as possible on the &lt;code&gt;toHash&lt;/code&gt; and &lt;code&gt;opEquals&lt;/code&gt; overrides.</source>
          <target state="translated">&lt;code&gt;toHash&lt;/code&gt; 및 &lt;code&gt;opEquals&lt;/code&gt; 대체 에서 가능한 &lt;code&gt;@nogc&lt;/code&gt; 속성을 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="fa837e971bab06ebe9fa8cced0faa302241fa259" translate="yes" xml:space="preserve">
          <source>Use the attributes &lt;code&gt;@safe&lt;/code&gt;, &lt;code&gt;@nogc&lt;/code&gt;, &lt;code&gt;pure&lt;/code&gt;, &lt;code&gt;const&lt;/code&gt;, and &lt;code&gt;scope&lt;/code&gt; as much as possible on the &lt;code&gt;toHash&lt;/code&gt; and &lt;code&gt;opEquals&lt;/code&gt; overrides.</source>
          <target state="translated">&lt;code&gt;toHash&lt;/code&gt; 및 &lt;code&gt;opEquals&lt;/code&gt; 재정의 에서 가능한 한 &lt;code&gt;@safe&lt;/code&gt; , &lt;code&gt;@nogc&lt;/code&gt; , &lt;code&gt;pure&lt;/code&gt; , &lt;code&gt;const&lt;/code&gt; 및 &lt;code&gt;scope&lt;/code&gt; 속성을 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="73f4ee5c163a4b03bed0243fb0edd865f02a04da" translate="yes" xml:space="preserve">
          <source>Use the coarse clock, not the normal one (e.g. on Linux, that would be &lt;code&gt;CLOCK_REALTIME_COARSE&lt;/code&gt; instead of &lt;code&gt;CLOCK_REALTIME&lt;/code&gt; for &lt;code&gt;clock_gettime&lt;/code&gt; if a function is using the realtime clock). It's generally faster to get the time with the coarse clock than the normal clock, but it's less precise (e.g. 1 msec instead of 1 usec or 1 nsec). Howeover, it</source>
          <target state="translated">일반 시계가 아닌 굵은 시계를 사용하십시오 (예 : Linux의 경우 함수가 실시간 시계를 사용하는 경우 &lt;code&gt;clock_gettime&lt;/code&gt; 에 대해 &lt;code&gt;CLOCK_REALTIME_COARSE&lt;/code&gt; 대신 &lt;code&gt;CLOCK_REALTIME&lt;/code&gt; _COARSE 가 됨). 일반적으로 일반 클럭보다 거친 클럭으로 시간을 얻는 것이 더 빠르지 만 정확도는 떨어집니다 (예 : 1 usec 또는 1 nsec 대신 1 msec). Howeover, 그것</target>
        </trans-unit>
        <trans-unit id="b5e0f9bdfa9016956fef4c6395c40953244dbc05" translate="yes" xml:space="preserve">
          <source>Use the faster compile-time overload</source>
          <target state="translated">더 빠른 컴파일 타임 오버로드 사용</target>
        </trans-unit>
        <trans-unit id="003ec607e3d7cca9e027c3ee29178ae85ad8baeb" translate="yes" xml:space="preserve">
          <source>Use the most visible overload to check visibility. Later perform an access check on the resolved overload. This function is similar to overloadApply, but doesn't recurse nor resolve aliases because protection/visibility is an attribute of the alias not the aliasee.</source>
          <target state="translated">가장 눈에 띄는 과부하를 사용하여 가시성을 확인하십시오. 나중에 해결 된 과부하에 대한 액세스 점검을 수행하십시오. 이 함수는 overloadApply와 유사하지만 보호 / 가시성은 별칭이 아닌 별칭의 속성이므로 별칭을 되풀이하거나 해결하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="ecea27e7268c13a18f824b4741edffcbd21384fd" translate="yes" xml:space="preserve">
          <source>Use the normal clock.</source>
          <target state="translated">일반 시계를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="2decee5fdcb2e6abe0efae775d6d245ceb48d907" translate="yes" xml:space="preserve">
          <source>Use the optional &lt;code&gt;cookie&lt;/code&gt; argument to create different types of the same base type</source>
          <target state="translated">선택적 &lt;code&gt;cookie&lt;/code&gt; 인수를 사용하여 동일한 기본 유형의 다른 유형을 작성 하십시오.</target>
        </trans-unit>
        <trans-unit id="199dc20b591ee68d927b26f24f29015b8587604c" translate="yes" xml:space="preserve">
          <source>Use the two operand form of the instruction format;</source>
          <target state="translated">명령어 형식의 두 피연산자 형식을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="95a7b20ad88258a006cdce3eb4a48069b1dcaa41" translate="yes" xml:space="preserve">
          <source>Use this attribute to attach an Objective-C selector to a method.</source>
          <target state="translated">이 속성을 사용하여 Objective-C 선택기를 메소드에 첨부하십시오.</target>
        </trans-unit>
        <trans-unit id="eb7ee948a98daed0fa240ed47144ff4132b6001e" translate="yes" xml:space="preserve">
          <source>Use this constructor for string mixins.</source>
          <target state="translated">문자열 믹스 인에이 생성자를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="5b498b0856e978dcbbf4e0ffb7b97a34e638161a" translate="yes" xml:space="preserve">
          <source>Use this expression for error recovery. It should behave as a 'sink' to prevent further cascaded error messages.</source>
          <target state="translated">오류 복구에이 표현식을 사용하십시오. 계단식 오류 메시지가 더 이상 발생하지 않도록 '싱크'역할을해야합니다.</target>
        </trans-unit>
        <trans-unit id="bd06c192db7792c4cf00ede209798b786767b1ca" translate="yes" xml:space="preserve">
          <source>Use this for multipart formpost building</source>
          <target state="translated">멀티 파트 폼 포스트 빌딩에 사용</target>
        </trans-unit>
        <trans-unit id="7c6ab14342528c5b12e30f0b33b6f65a5c654581" translate="yes" xml:space="preserve">
          <source>Use this instead of creating new instances for commonly used literals such as 0 or 1.</source>
          <target state="translated">0 또는 1과 같이 일반적으로 사용되는 리터럴에 대해 새 인스턴스를 작성하는 대신 이것을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="f3c0cff7dd757ca5c15bd47e9f720de6ca2a6e5e" translate="yes" xml:space="preserve">
          <source>Use this module to test out new functionality for &lt;a href=&quot;std_typecons#wrap&quot;&gt;&lt;code&gt;std.typecons.wrap&lt;/code&gt;&lt;/a&gt; which allows for a struct to be wrapped against an interface; the implementation in &lt;a href=&quot;std_typecons&quot;&gt;&lt;code&gt;std.typecons&lt;/code&gt;&lt;/a&gt; only allows for classes to use the wrap functionality.</source>
          <target state="translated">이 모듈을 사용하여 &lt;a href=&quot;std_typecons#wrap&quot;&gt; &lt;code&gt;std.typecons.wrap&lt;/code&gt; 의&lt;/a&gt; 새로운 기능을 테스트 하여 구조체를 인터페이스에 래핑 할 수 있습니다. &lt;a href=&quot;std_typecons&quot;&gt; &lt;code&gt;std.typecons&lt;/code&gt; &lt;/a&gt; 의 구현은 클래스가 랩 기능을 사용하도록 허용합니다.</target>
        </trans-unit>
        <trans-unit id="a95cb1b3a079b5ec85c4f5f432209f3bba70e39c" translate="yes" xml:space="preserve">
          <source>Use this only when it is certain there are no elements in use beyond the array in the memory block. If there are, those elements will be overwritten by appending to this array.</source>
          <target state="translated">메모리 블록의 배열 이외의 요소가 사용되지 않는 것이 확실한 경우에만 사용하십시오. 있는 경우이 배열에 추가하여 해당 요소를 덮어 씁니다.</target>
        </trans-unit>
        <trans-unit id="a582381933463d5deb51e05bf545416141895fa5" translate="yes" xml:space="preserve">
          <source>Use this template to get the type which is returned by a digest's &lt;a href=&quot;#finish&quot;&gt;&lt;code&gt;finish&lt;/code&gt;&lt;/a&gt; method.</source>
          <target state="translated">이 템플릿을 사용하여 다이제스트의 &lt;a href=&quot;#finish&quot;&gt; &lt;code&gt;finish&lt;/code&gt; &lt;/a&gt; 메소드에 의해 반환되는 유형을 가져옵니다 .</target>
        </trans-unit>
        <trans-unit id="f759a1693042701634c4658a13cab1e8618f57f7" translate="yes" xml:space="preserve">
          <source>Use this to check if a type is a digest. See &lt;a href=&quot;#ExampleDigest&quot;&gt;&lt;code&gt;ExampleDigest&lt;/code&gt;&lt;/a&gt; to see what a type must provide to pass this check.</source>
          <target state="translated">이것을 사용하여 형식이 다이제스트인지 확인하십시오. 참조 &lt;a href=&quot;#ExampleDigest&quot;&gt; &lt;code&gt;ExampleDigest&lt;/code&gt; 를&lt;/a&gt; 유형이 검사를 통과 할 때 입력해야하는 것을 볼 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="dc036b8b38f636a8da26f31247bb9aaf42862d52" translate="yes" xml:space="preserve">
          <source>Use this to feed the digest with data. Also implements the &lt;a href=&quot;std_range_primitives#isOutputRange&quot;&gt;&lt;code&gt;std.range.primitives.isOutputRange&lt;/code&gt;&lt;/a&gt; interface for &lt;code&gt;ubyte&lt;/code&gt; and &lt;code&gt;const(ubyte)[]&lt;/code&gt;.</source>
          <target state="translated">이를 사용하여 다이제스트에 데이터를 공급하십시오. 또한 &lt;code&gt;ubyte&lt;/code&gt; 및 &lt;code&gt;const(ubyte)[]&lt;/code&gt; 대한 &lt;a href=&quot;std_range_primitives#isOutputRange&quot;&gt; &lt;code&gt;std.range.primitives.isOutputRange&lt;/code&gt; &lt;/a&gt; 인터페이스를 구현합니다 .</target>
        </trans-unit>
        <trans-unit id="4716d195c3662fddb3b8f04d5d336c547d5e1633" translate="yes" xml:space="preserve">
          <source>Use this to feed the digest with data. Also implements the &lt;a href=&quot;std_range_primitives#isOutputRange&quot;&gt;&lt;code&gt;std.range.primitives.isOutputRange&lt;/code&gt;&lt;/a&gt; interface for &lt;code&gt;ubyte&lt;/code&gt; and &lt;code&gt;const(ubyte)[]&lt;/code&gt;. The following usages of &lt;code&gt;put&lt;/code&gt; must work for any type which passes &lt;a href=&quot;#isDigest&quot;&gt;&lt;code&gt;isDigest&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">이를 사용하여 다이제스트에 데이터를 공급하십시오. 또한 &lt;code&gt;ubyte&lt;/code&gt; 및 &lt;code&gt;const(ubyte)[]&lt;/code&gt; 대한 &lt;a href=&quot;std_range_primitives#isOutputRange&quot;&gt; &lt;code&gt;std.range.primitives.isOutputRange&lt;/code&gt; &lt;/a&gt; 인터페이스를 구현합니다 . 다음의 &lt;code&gt;put&lt;/code&gt; 사용법은 &lt;a href=&quot;#isDigest&quot;&gt; &lt;code&gt;isDigest&lt;/code&gt; &lt;/a&gt; 를 통과하는 모든 유형에 대해 작동해야합니다 .</target>
        </trans-unit>
        <trans-unit id="f0c5e9e55d90ec5f58114e5393a0956447e2f3df" translate="yes" xml:space="preserve">
          <source>Use tuples as ranges</source>
          <target state="translated">튜플을 범위로 사용</target>
        </trans-unit>
        <trans-unit id="27f93c20b3a083f74d82c63db067812d27ea3722" translate="yes" xml:space="preserve">
          <source>Use when we prefer the default initializer to be a literal, rather than a global immutable variable.</source>
          <target state="translated">기본 이니셜 라이저가 전역 불변 변수가 아닌 리터럴 인 것을 선호 할 때 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="8d5ca1642ce1a35cb57a7b97089dfc54c5486ae4" translate="yes" xml:space="preserve">
          <source>Use with care as the sub-matcher won't match any &lt;a href=&quot;#Code%20point&quot;&gt;code points&lt;/a&gt; that have encoded length that doesn't belong to the selected set of lengths. Also the sub-matcher object references the parent matcher and must not be used past the liftetime of the latter.</source>
          <target state="translated">하위 매처는 선택한 길이 세트에 속하지 않는 인코딩 된 길이를 가진 &lt;a href=&quot;#Code%20point&quot;&gt;코드 포인트&lt;/a&gt; 와 일치하지 않으므로주의해서 사용하십시오 . 또한 하위 매처 개체는 상위 매처를 참조하며 후매의 리프트 시간 이후에는 사용해서는 안됩니다.</target>
        </trans-unit>
        <trans-unit id="83af243aeee73279b4357b44c2865c0c312de9ce" translate="yes" xml:space="preserve">
          <source>Use with care for relatively small or regular sets. It could end up being slower then just using multi-staged tables.</source>
          <target state="translated">비교적 작거나 규칙적인 세트에주의하여 사용하십시오. 다단계 테이블을 사용하면 속도가 느려질 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4c271740e0ce7eb2e00647fa4da41721ca1e00a1" translate="yes" xml:space="preserve">
          <source>Used as a way to import a set of functions from another scope into this one.</source>
          <target state="translated">다른 범위에서이 범위로 함수 세트를 가져 오는 방법으로 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="9aff366f8817a8d85016a5af2ffa72cb41c12ea4" translate="yes" xml:space="preserve">
          <source>Used by PRAGMA temp_store_directory</source>
          <target state="translated">PRAGMA temp_store_directory에서 사용</target>
        </trans-unit>
        <trans-unit id="c0d28c0a10bf62a3760e12afc8a7ed5df5261d7b" translate="yes" xml:space="preserve">
          <source>Used by StopWatch to indicate whether it should start immediately upon construction.</source>
          <target state="translated">StopWatch가 시공 즉시 시작해야하는지 여부를 나타내는 데 사용합니다.</target>
        </trans-unit>
        <trans-unit id="d77cd63df95be5f8257fdd3b6685af113cfcac98" translate="yes" xml:space="preserve">
          <source>Used by scp/sftp to do public/private key authentication</source>
          <target state="translated">공개 / 개인 키 인증을 수행하기 위해 scp / sftp에서 사용</target>
        </trans-unit>
        <trans-unit id="62d064b18e4792e174e1c38c7f164d4b65412e06" translate="yes" xml:space="preserve">
          <source>Used for empty tags</source>
          <target state="translated">빈 태그에 사용</target>
        </trans-unit>
        <trans-unit id="948c35e8d2024f482ef61469edc1997c031e7684" translate="yes" xml:space="preserve">
          <source>Used for end tags</source>
          <target state="translated">종료 태그에 사용</target>
        </trans-unit>
        <trans-unit id="6de76570eb43640d4d9e5b45038a00acc6b2bb9d" translate="yes" xml:space="preserve">
          <source>Used for reordering elem trees to minimize register usage.</source>
          <target state="translated">레지스터 사용을 최소화하기 위해 elem 트리를 재정렬하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="f4030c3289de70676f4cc6c0e214e32db123298d" translate="yes" xml:space="preserve">
          <source>Used for start tags</source>
          <target state="translated">시작 태그에 사용</target>
        </trans-unit>
        <trans-unit id="522e09bb5920f3c467bc6428b962e366709a3220" translate="yes" xml:space="preserve">
          <source>Used to (re)initialize the MD5 digest.</source>
          <target state="translated">MD5 다이제스트를 (재) 초기화하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="d8ae013d8b394207c78281137c668f2dfc3c43cf" translate="yes" xml:space="preserve">
          <source>Used to (re)initialize the RIPEMD160 digest.</source>
          <target state="translated">RIPEMD160 다이제스트를 (재) 초기화하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="f62bf8f2aca98cad054cf426c5476cfd425e9977" translate="yes" xml:space="preserve">
          <source>Used to check if a digest supports the &lt;code&gt;peek&lt;/code&gt; method. Peek has exactly the same function signatures as finish, but it doesn't reset the digest's internal state.</source>
          <target state="translated">다이제스트가 &lt;code&gt;peek&lt;/code&gt; 방법을 지원하는지 확인하는 데 사용됩니다 . Peek는 finish와 기능 서명이 정확히 동일하지만 다이제스트의 내부 상태를 재설정하지는 않습니다.</target>
        </trans-unit>
        <trans-unit id="b2ca2eff17dd582e5ff65726409ecb0158897554" translate="yes" xml:space="preserve">
          <source>Used to convert a hash value (a static or dynamic array of ubytes) to a string. Can be used with the OOP and with the template API.</source>
          <target state="translated">해시 값 (정적 또는 동적 ubyte 배열)을 문자열로 변환하는 데 사용됩니다. OOP 및 템플릿 API와 함께 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="46222499a18dfe951ecc78e1c9590456d26ad7e4" translate="yes" xml:space="preserve">
          <source>Used to convert the argument to a lazy parameter.</source>
          <target state="translated">인수를 지연 매개 변수로 변환하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="65abc6a52a7ca50f9b90aca875b02f4b756c4a7a" translate="yes" xml:space="preserve">
          <source>Used to get the metaclass of an Objective-C class, &lt;code&gt;NSObject.Class&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;NSObject.Class&lt;/code&gt; Objective-C 클래스의 메타 클래스를 가져 오는 데 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="87b79b0e524609461d16e79324d5b506d0bd2f97" translate="yes" xml:space="preserve">
          <source>Used to indicate whether &lt;code&gt;popFront&lt;/code&gt; should be called immediately upon creating a range. The idea is that for some functions used to generate a range for an interval, &lt;code&gt;front&lt;/code&gt; is not necessarily a time point which would ever be generated by the range (e.g. if the range were every Sunday within an interval, but the interval started on a Monday), so there needs to be a way to deal with that. To get the first time point in the range to match what the function generates, then use &lt;code&gt;PopFirst.yes&lt;/code&gt; to indicate that the range should have &lt;code&gt;popFront&lt;/code&gt; called on it before the range is returned so that &lt;code&gt;front&lt;/code&gt; is a time point which the function would generate. To let the first time point not match the generator function, use &lt;code&gt;PopFront.no&lt;/code&gt;.</source>
          <target state="translated">범위를 만들 때 &lt;code&gt;popFront&lt;/code&gt; 를 즉시 호출 해야하는지 여부를 나타내는 데 사용됩니다 . 간격에 대한 범위를 생성하는 데 사용되는 일부 함수의 경우, &lt;code&gt;front&lt;/code&gt; 이 범위에 의해 생성되는 시점 일 필요는 없습니다 (예 : 범위가 간격 내에 매주 일요일이지만 간격이 월요일에 시작된 경우) )를 처리 할 수있는 방법이 필요합니다. 함수가 생성하는 것과 일치하는 범위의 첫 번째 시점을 얻으려면 &lt;code&gt;PopFirst.yes&lt;/code&gt; 를 사용 하여 범위가 리턴되기 전에 범위가 &lt;code&gt;popFront&lt;/code&gt; 를 호출 해야 함을 표시하여 &lt;code&gt;front&lt;/code&gt; 는 함수가 생성하는 시점입니다. 첫 번째 시점이 생성기 기능과 일치하지 않게하려면 &lt;code&gt;PopFront.no&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="401f8606923b6b90d5e6990af08c1ea19653cfb5" translate="yes" xml:space="preserve">
          <source>Used to initialize the CRC32 digest.</source>
          <target state="translated">CRC32 다이제스트를 초기화하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="9956d500692d633ff2d3c01404cd742cd7a59cd4" translate="yes" xml:space="preserve">
          <source>Used to specify the lock type for &lt;code&gt;File.lock&lt;/code&gt; and &lt;code&gt;File.tryLock&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;File.lock&lt;/code&gt; 및 &lt;code&gt;File.tryLock&lt;/code&gt; 의 잠금 유형을 지정하는 데 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="063f3cd8cbb18d78d982d0fe8406f2b8aad31844" translate="yes" xml:space="preserve">
          <source>Used to work around syntactic limitations of D with regard to instantiating a template from an alias sequence (e.g. &lt;code&gt;T[0]!(...)&lt;/code&gt; is not valid) or a template returning another template (e.g. &lt;code&gt;Foo!(Bar)!(Baz)&lt;/code&gt; is not allowed).</source>
          <target state="translated">별칭 시퀀스 (예 : &lt;code&gt;T[0]!(...)&lt;/code&gt; 가 유효하지 않음) 에서 템플릿을 인스턴스화 하거나 다른 템플릿을 반환하는 템플릿 (예 : &lt;code&gt;Foo!(Bar)!(Baz)&lt;/code&gt; 에서 D의 구문 제한을 해결하는 데 사용됩니다 . ) 는 허용되지 않습니다).</target>
        </trans-unit>
        <trans-unit id="9c84f45b498b0d39f128dcbb45ac2921760d01ee" translate="yes" xml:space="preserve">
          <source>Used when the data to be compressed is not all in one buffer.</source>
          <target state="translated">압축 할 데이터가 모두 하나의 버퍼에없는 경우에 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="5bb82bdca5155ef6b15ec62c178c8aa8ec5a96b1" translate="yes" xml:space="preserve">
          <source>Used when the data to be decompressed is not all in one buffer.</source>
          <target state="translated">압축 해제 할 데이터가 모두 하나의 버퍼에없는 경우에 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="c12660b5a95dd9583c836ce084d3eaa0c55a6813" translate="yes" xml:space="preserve">
          <source>Useful for converting the result to a string after doing operations on graphemes.</source>
          <target state="translated">grapheme에 대한 작업을 수행 한 후 결과를 문자열로 변환하는 데 유용합니다.</target>
        </trans-unit>
        <trans-unit id="7652b35b91d37f1b6a3e33d8a155a1f2c6064611" translate="yes" xml:space="preserve">
          <source>Useful for doing string manipulation that needs to be aware of graphemes.</source>
          <target state="translated">그래프를 인식해야하는 문자열 조작에 유용합니다.</target>
        </trans-unit>
        <trans-unit id="314d8fb768e706877d004a50cc06fd222bca9e32" translate="yes" xml:space="preserve">
          <source>Useful for error messages</source>
          <target state="translated">오류 메시지에 유용</target>
        </trans-unit>
        <trans-unit id="6dc0953ee871790fa8f35a1a09d04c414cbf0ea7" translate="yes" xml:space="preserve">
          <source>Useful for using &lt;code&gt;foreach&lt;/code&gt; with an index loop variable:</source>
          <target state="translated">인덱스 루프 변수와 함께 &lt;code&gt;foreach&lt;/code&gt; 를 사용하는 데 유용 합니다.</target>
        </trans-unit>
        <trans-unit id="4db4c19014a191f09a1cb0e5ee4b594d36a17fa5" translate="yes" xml:space="preserve">
          <source>Useful when a single value or multiple disconnected values must be passed to an algorithm expecting a range, without having to perform dynamic memory allocation.</source>
          <target state="translated">동적 메모리 할당을 수행하지 않고 단일 값 또는 여러 개의 연결 해제 된 값을 범위를 예상하는 알고리즘으로 전달해야 할 때 유용합니다.</target>
        </trans-unit>
        <trans-unit id="83a28142d94277b9f824e8d439d35c64935809cf" translate="yes" xml:space="preserve">
          <source>User Data For Functions</source>
          <target state="translated">기능에 대한 사용자 데이터</target>
        </trans-unit>
        <trans-unit id="0ada253ac93105524488fa0636dd4f599ad803cd" translate="yes" xml:space="preserve">
          <source>User Datagram Protocol</source>
          <target state="translated">사용자 데이터 그램 프로토콜</target>
        </trans-unit>
        <trans-unit id="663967dca54d1f5a78a7cc7579aff26c92ec0848" translate="yes" xml:space="preserve">
          <source>User Datagram Protocol level</source>
          <target state="translated">사용자 데이터 그램 프로토콜 수준</target>
        </trans-unit>
        <trans-unit id="7f12f4404ca8d6331a7dda600211516b88689808" translate="yes" xml:space="preserve">
          <source>User Defined Logger</source>
          <target state="translated">사용자 정의 로거</target>
        </trans-unit>
        <trans-unit id="41b70159aa80a814a1c6708051f3c2cd54f55274" translate="yes" xml:space="preserve">
          <source>User defined attributes look like: @foo(args, ...) @(args, ...)</source>
          <target state="translated">사용자 정의 속성은 다음과 같습니다. @foo (args, ...) @ (args, ...)</target>
        </trans-unit>
        <trans-unit id="6911ae8d9122e09ba3672b9fc7a2f5a03117c4b5" translate="yes" xml:space="preserve">
          <source>User-Defined Attributes</source>
          <target state="translated">사용자 정의 속성</target>
        </trans-unit>
        <trans-unit id="53dcd43d2037ced97e920ab7c52c6c2b3f1d4b5b" translate="yes" xml:space="preserve">
          <source>User-Defined Attributes (UDA) are compile-time expressions that can be attached to a declaration. These attributes can then be queried, extracted, and manipulated at compile time. There is no runtime component to them.</source>
          <target state="translated">UDA (User-Defined Attributes)는 선언에 첨부 할 수있는 컴파일 타임 표현식입니다. 그런 다음 컴파일시 이러한 속성을 쿼리, 추출 및 조작 할 수 있습니다. 그들에게는 런타임 컴포넌트가 없습니다.</target>
        </trans-unit>
        <trans-unit id="79c69632c5bdcde773a2213887dfa8de28b97fcd" translate="yes" xml:space="preserve">
          <source>User-Defined Attributes for Parameters</source>
          <target state="translated">매개 변수에 대한 사용자 정의 속성</target>
        </trans-unit>
        <trans-unit id="f97038e5aef05b8d6da775ac91f3df3186383a15" translate="yes" xml:space="preserve">
          <source>User-Defined Properties</source>
          <target state="translated">사용자 정의 속성</target>
        </trans-unit>
        <trans-unit id="a481ec805686b1111f45e923c0482b9b383bb80f" translate="yes" xml:space="preserve">
          <source>User-Defined Types</source>
          <target state="translated">사용자 정의 유형</target>
        </trans-unit>
        <trans-unit id="df398272c254dd9772b28c77026104de0cb4813e" translate="yes" xml:space="preserve">
          <source>User-defined properties can be created using &lt;a href=&quot;function#property-functions&quot;&gt;Property Functions&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;function#property-functions&quot;&gt;속성 함수를&lt;/a&gt; 사용하여 사용자 정의 속성을 만들 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="ad57ad15c0703a0e0107ec919b23c65c4cb01b03" translate="yes" xml:space="preserve">
          <source>User-defined type names</source>
          <target state="translated">사용자 정의 유형 이름</target>
        </trans-unit>
        <trans-unit id="e276f7847775a88fc2abcad4667b89c9759a4155" translate="yes" xml:space="preserve">
          <source>User-defined types that support comparison with &amp;lt; are supported.</source>
          <target state="translated">&amp;lt;과의 비교를 지원하는 사용자 정의 유형이 지원됩니다.</target>
        </trans-unit>
        <trans-unit id="e23e2a8ab594792759d1b60610fa3c8b02dd3e4d" translate="yes" xml:space="preserve">
          <source>User-provided store backing up the region. If &lt;code&gt; ParentAllocator&lt;/code&gt; is different from &lt;a href=&quot;std_experimental_allocator_building_blocks_null_allocator#NullAllocator&quot;&gt;&lt;code&gt;NullAllocator&lt;/code&gt;&lt;/a&gt;, memory is assumed to have been allocated with &lt;code&gt;ParentAllocator&lt;/code&gt;.</source>
          <target state="translated">리젼을 백업하는 사용자 제공 상점. 경우 &lt;code&gt; ParentAllocator&lt;/code&gt; 가 상이한 &lt;a href=&quot;std_experimental_allocator_building_blocks_null_allocator#NullAllocator&quot;&gt; &lt;code&gt;NullAllocator&lt;/code&gt; &lt;/a&gt; 메모리가 할당 된 것으로 가정한다 &lt;code&gt;ParentAllocator&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5092e979a5a593d67b4e82f9d2bbd095571e3d50" translate="yes" xml:space="preserve">
          <source>User-provided store backing up the region. If &lt;code&gt;ParentAllocator&lt;/code&gt; is different from &lt;a href=&quot;std_experimental_allocator_building_blocks_null_allocator#NullAllocator&quot;&gt;&lt;code&gt;NullAllocator&lt;/code&gt;&lt;/a&gt;, memory is assumed to have been allocated with &lt;code&gt;ParentAllocator&lt;/code&gt;.</source>
          <target state="translated">리젼을 백업하는 사용자 제공 상점. 경우 &lt;code&gt;ParentAllocator&lt;/code&gt; 가 상이한 &lt;a href=&quot;std_experimental_allocator_building_blocks_null_allocator#NullAllocator&quot;&gt; &lt;code&gt;NullAllocator&lt;/code&gt; &lt;/a&gt; 메모리가 할당 된 것으로 가정한다 &lt;code&gt;ParentAllocator&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e82338a943d21a1789251b44a5bd82afdadd9523" translate="yes" xml:space="preserve">
          <source>Users should prefer &lt;a href=&quot;object#destroy&quot;&gt;&lt;code&gt;destroy&lt;/code&gt;&lt;/a&gt; to explicitly finalize objects, and only resort to &lt;a href=&quot;core_memory#_delete&quot;&gt;&lt;code&gt;core.memory._delete&lt;/code&gt;&lt;/a&gt; when &lt;a href=&quot;object_#destroy&quot;&gt;&lt;code&gt;object.destroy&lt;/code&gt;&lt;/a&gt; wouldn't be a feasible option.</source>
          <target state="translated">사용자는 명시 적으로 객체를 마무리 &lt;a href=&quot;object#destroy&quot;&gt; &lt;code&gt;destroy&lt;/code&gt; &lt;/a&gt; 위해 destroy 를 선호 하고 &lt;a href=&quot;object_#destroy&quot;&gt; &lt;code&gt;object.destroy&lt;/code&gt; &lt;/a&gt; 가 실현 가능한 옵션이 아닌 경우 에만 &lt;a href=&quot;core_memory#_delete&quot;&gt; &lt;code&gt;core.memory._delete&lt;/code&gt; &lt;/a&gt; 를 사용해야 합니다.</target>
        </trans-unit>
        <trans-unit id="b4005d61c7d8ff0cb653333de46ae3789f1d31fe" translate="yes" xml:space="preserve">
          <source>Uses &lt;a href=&quot;http://man7.org/linux/man-pages/man3/posix_memalign.3.html&quot;&gt; &lt;code&gt;posix_memalign&lt;/code&gt;&lt;/a&gt; on Posix and &lt;a href=&quot;http://msdn.microsoft.com/en-us/library/8z34s9c6(v=vs.80).aspx&quot;&gt; &lt;code&gt;__aligned_malloc&lt;/code&gt;&lt;/a&gt; on Windows.</source>
          <target state="translated">용도는 &lt;a href=&quot;http://man7.org/linux/man-pages/man3/posix_memalign.3.html&quot;&gt; &lt;code&gt;posix_memalign&lt;/code&gt; &lt;/a&gt; 하여 Posix과에 &lt;a href=&quot;http://msdn.microsoft.com/en-us/library/8z34s9c6(v=vs.80).aspx&quot;&gt; &lt;code&gt;__aligned_malloc&lt;/code&gt; &lt;/a&gt; Windows에서.</target>
        </trans-unit>
        <trans-unit id="431691e401faf58fb8c19131908c69ff710b059d" translate="yes" xml:space="preserve">
          <source>Uses &lt;code&gt;CLOCK_BOOTTIME&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;CLOCK_BOOTTIME&lt;/code&gt; 을 사용 합니다 .</target>
        </trans-unit>
        <trans-unit id="5a50d919e60bef0f60af91bbb8d114a0afe4665d" translate="yes" xml:space="preserve">
          <source>Uses &lt;code&gt;CLOCK_MONOTONIC_RAW&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;CLOCK_MONOTONIC_RAW&lt;/code&gt; 를 사용합니다 .</target>
        </trans-unit>
        <trans-unit id="668062aef7777a80761a341372c3e3e366c83d67" translate="yes" xml:space="preserve">
          <source>Uses &lt;code&gt;CLOCK_PROCESS_CPUTIME_ID&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;CLOCK_PROCESS_CPUTIME_ID&lt;/code&gt; 를 사용합니다 .</target>
        </trans-unit>
        <trans-unit id="8b6a765f3682873a0a6c777b9f9c93d6e30d47aa" translate="yes" xml:space="preserve">
          <source>Uses &lt;code&gt;CLOCK_THREAD_CPUTIME_ID&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;CLOCK_THREAD_CPUTIME_ID&lt;/code&gt; 를 사용 합니다 .</target>
        </trans-unit>
        <trans-unit id="a32c41537d0762601fcb3b8547ba1c5f0e90c61b" translate="yes" xml:space="preserve">
          <source>Uses &lt;code&gt;CLOCK_UPTIME&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;CLOCK_UPTIME&lt;/code&gt; 을 사용 합니다 .</target>
        </trans-unit>
        <trans-unit id="d155d55219e59719f96afbc402b6fce30fe7decd" translate="yes" xml:space="preserve">
          <source>Uses &lt;code&gt;CLOCK_UPTIME_FAST&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;CLOCK_UPTIME_FAST&lt;/code&gt; 를 사용 합니다 .</target>
        </trans-unit>
        <trans-unit id="32cbdb3659578d385f11021d0324dc0968ef7d2b" translate="yes" xml:space="preserve">
          <source>Uses &lt;code&gt;CLOCK_UPTIME_PRECISE&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;CLOCK_UPTIME_PRECISE&lt;/code&gt; 를 사용 합니다 .</target>
        </trans-unit>
        <trans-unit id="21b474dd996ab465a4609dacd8af3f0c2c6b9e0a" translate="yes" xml:space="preserve">
          <source>Uses Horner's rule A(x) = a&lt;sub&gt;0&lt;/sub&gt; + x(a&lt;sub&gt;1&lt;/sub&gt; + x(a&lt;sub&gt;2&lt;/sub&gt; + x(a&lt;sub&gt;3&lt;/sub&gt; + ...)))</source>
          <target state="translated">호너의 규칙 A (x) = a &lt;sub&gt;0&lt;/sub&gt; + x (a &lt;sub&gt;1&lt;/sub&gt; + x (a &lt;sub&gt;2&lt;/sub&gt; + x (a &lt;sub&gt;3&lt;/sub&gt; + ...)) 사용)</target>
        </trans-unit>
        <trans-unit id="89865df2ae553e13ce078a7680590fe066489642" translate="yes" xml:space="preserve">
          <source>Uses OS features not supported on host</source>
          <target state="translated">호스트에서 지원되지 않는 OS 기능을 사용합니다</target>
        </trans-unit>
        <trans-unit id="d43174ab3f2c7ceb67637889035614b690710449" translate="yes" xml:space="preserve">
          <source>Uses a clock that has a precision of one second (contrast to the coarse clock, which has sub-second precision like the normal clock does).</source>
          <target state="translated">정밀도가 1 초인 클록을 사용합니다 (일반 클록과 같이 초 미만의 정밀도를 갖는 거친 클록과 대조).</target>
        </trans-unit>
        <trans-unit id="660abbaeae3754fa828725fdd746d4c8c7d904f7" translate="yes" xml:space="preserve">
          <source>Uses a more precise clock than the normal one (which is already very precise), but it takes longer to get the time. Similarly to &lt;code&gt;ClockType.coarse&lt;/code&gt;, if it's used on a system that does not support a more precise clock than the normal one, it's treated as equivalent to &lt;code&gt;ClockType.normal&lt;/code&gt;.</source>
          <target state="translated">일반 시계보다 더 정확한 시계를 사용하지만 (이미 매우 정확함) 시간을 얻는 데 시간이 더 걸립니다. 마찬가지로에 &lt;code&gt;ClockType.coarse&lt;/code&gt; 이 시스템에 사용되는 경우, 정상보다 더 정확한 클럭을 지원하지 않는, 그것은과 동일하게 처리됩니다 &lt;code&gt;ClockType.normal&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4810f4cffe0fe4e539877249a5f80a146a9437e8" translate="yes" xml:space="preserve">
          <source>Uses an algorithm based on TOMS748, which uses inverse cubic interpolation whenever possible, otherwise reverting to parabolic or secant interpolation. Compared to TOMS748, this implementation improves worst-case performance by a factor of more than 100, and typical performance by a factor of 2. For 80-bit reals, most problems require 8 to 15 calls to &lt;code&gt;f(x)&lt;/code&gt; to achieve full machine precision. The worst-case performance (pathological cases) is approximately twice the number of bits.</source>
          <target state="translated">TOMS748을 기반으로하는 알고리즘을 사용합니다.이 알고리즘은 가능할 때마다 역 입방 보간을 사용하고, 그렇지 않으면 포물선 또는 시차 보간으로 되돌립니다. TOMS748과 비교하여이 구현은 최악의 성능을 100 배 이상 향상시키고 일반적인 성능을 2 배 향상시킵니다. 80 비트 실수의 경우 대부분의 문제는 전체 시스템을 달성하기 위해 &lt;code&gt;f(x)&lt;/code&gt; 를 8 ~ 15 번 호출해야 합니다. 정도. 최악의 성능 (병리학 적 경우)은 비트 수의 약 2 배입니다.</target>
        </trans-unit>
        <trans-unit id="4498cdd81a3af92be5d71f0feb7499f91526eda6" translate="yes" xml:space="preserve">
          <source>Uses static address range/handler tables. It is not compatible with the ELF/Mach-O exception handling tables. The stack is walked assuming it uses the EBP/RBP stack frame convention. The EBP/RBP convention must be used for every function that has an associated EH (Exception Handler) table.</source>
          <target state="translated">고정 주소 범위 / 핸들러 테이블을 사용합니다. ELF / Mach-O 예외 처리 테이블과 호환되지 않습니다. 스택은 EBP / RBP 스택 프레임 규칙을 사용하는 것으로 가정합니다. EBP / RBP 규칙은 관련된 EH (예외 처리기) 테이블이있는 모든 함수에 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="29fa78ad0c4fcffa6a248e751ed5f9b54e278c81" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;delete&lt;/code&gt; to free memory not allocated by the garbage collector.</source>
          <target state="translated">가비지 수집기에서 할당하지 않은 메모리 를 &lt;code&gt;delete&lt;/code&gt; 려면 delete 를 사용 하십시오.</target>
        </trans-unit>
        <trans-unit id="dbc2fb498947c6d15c4f030eec28a604eed13c66" translate="yes" xml:space="preserve">
          <source>Using Allocators without &lt;code&gt;IAllocator&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;IAllocator&lt;/code&gt; 없이 할당 자 사용</target>
        </trans-unit>
        <trans-unit id="f74c7aa68c43b38fd906d3d9eab694820f7c02be" translate="yes" xml:space="preserve">
          <source>Using C++ Classes From D</source>
          <target state="translated">D에서 C ++ 클래스 사용하기</target>
        </trans-unit>
        <trans-unit id="5d2653c4926bb52d976ff78e98c04428994e66ea" translate="yes" xml:space="preserve">
          <source>Using Classes as the KeyType</source>
          <target state="translated">클래스를 KeyType으로 사용</target>
        </trans-unit>
        <trans-unit id="42a76c4e6e5c83e56266b53307bd6eb59b5b616d" translate="yes" xml:space="preserve">
          <source>Using D Classes From C++</source>
          <target state="translated">C ++에서 D 클래스 사용</target>
        </trans-unit>
        <trans-unit id="5de7af94f529ff0a340538c931f4aeeba8137b89" translate="yes" xml:space="preserve">
          <source>Using Ddoc for other Documentation</source>
          <target state="translated">다른 문서에 Ddoc 사용</target>
        </trans-unit>
        <trans-unit id="a452f39b71d34befc0278e622c50c8e1b7016ce7" translate="yes" xml:space="preserve">
          <source>Using Ddoc to generate examples from unit tests</source>
          <target state="translated">Ddoc을 사용하여 단위 테스트에서 예제 생성</target>
        </trans-unit>
        <trans-unit id="ffcf84b5292979d6d33051f4fd30a1a26f6708e4" translate="yes" xml:space="preserve">
          <source>Using Existing C Libraries</source>
          <target state="translated">기존 C 라이브러리 사용</target>
        </trans-unit>
        <trans-unit id="ca7da0d401d332ac17ab9ac27d6baa37cb6bed49" translate="yes" xml:space="preserve">
          <source>Using Structs or Unions as the KeyType</source>
          <target state="translated">Structs 또는 Union을 KeyType으로 사용</target>
        </trans-unit>
        <trans-unit id="ac95e41bbb29ad991114a19ec2ec8a9eb2e7d8d1" translate="yes" xml:space="preserve">
          <source>Using UUIDs</source>
          <target state="translated">UUID 사용</target>
        </trans-unit>
        <trans-unit id="5fa5d3e48800cfb7875c91e382ef8e4590ba92ea" translate="yes" xml:space="preserve">
          <source>Using a struct with modified delimiter:</source>
          <target state="translated">구분 기호가 수정 된 구조체 사용 :</target>
        </trans-unit>
        <trans-unit id="04602bc03bbc945a58891e81ee57c8cb19c96764" translate="yes" xml:space="preserve">
          <source>Using alias template parameter in &lt;code&gt;how&lt;/code&gt; and/or &lt;code&gt;what&lt;/code&gt; may cause strange compile error. Use template tuple parameter instead to workaround this problem. [&lt;a href=&quot;https://issues.dlang.org/show_bug.cgi?id=4217&quot;&gt;Bugzilla 4217&lt;/a&gt;]</source>
          <target state="translated">에 별칭 템플릿 매개 변수를 사용 &lt;code&gt;how&lt;/code&gt; 및 / 또는 &lt;code&gt;what&lt;/code&gt; 이상한 컴파일 오류가 발생할 수 있습니다. 이 문제를 해결하려면 템플릿 튜플 매개 변수를 대신 사용하십시오. [ &lt;a href=&quot;https://issues.dlang.org/show_bug.cgi?id=4217&quot;&gt;Bugzilla 4217&lt;/a&gt; ]</target>
        </trans-unit>
        <trans-unit id="a2607c615db72ef7bb05726a2cf4b245712b98a0" translate="yes" xml:space="preserve">
          <source>Using an uninitialized struct-based container will work, because the struct intializes itself upon use; however, up to this point the container will not have an identity and assignment does not create two references to the same data.</source>
          <target state="translated">초기화되지 않은 구조체 기반 컨테이너를 사용하면 구조체가 사용시 자체 화되기 때문에 작동합니다. 그러나이 시점까지 컨테이너에는 ID가 없으며 할당으로 인해 동일한 데이터에 대한 두 개의 참조가 생성되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="35a44b902e18d805798c2c1e89fd00d153fbd20b" translate="yes" xml:space="preserve">
          <source>Using asNormalizedPath on empty paths will always return an empty path.</source>
          <target state="translated">빈 경로에서 asNormalizedPath를 사용하면 항상 빈 경로가 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="0290f4a41ecd4a75dc3439f50553b7b4b3cab521" translate="yes" xml:space="preserve">
          <source>Using buildNormalizedPath on null paths will always return null.</source>
          <target state="translated">널 경로에서 buildNormalizedPath를 사용하면 항상 널을 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="6805f8dde5047fa0a76de0b0a48672e08cbc9fdb" translate="yes" xml:space="preserve">
          <source>Using builtin &lt;code&gt;typeof&lt;/code&gt; on a property function yields the types of the property value, not of the property function itself. Still, &lt;code&gt;FunctionTypeOf&lt;/code&gt; is able to obtain function types of properties.</source>
          <target state="translated">특성 함수에 내장 &lt;code&gt;typeof&lt;/code&gt; 를 사용 하면 특성 함수 자체가 아닌 특성 값의 유형이 생성됩니다. 여전히 &lt;code&gt;FunctionTypeOf&lt;/code&gt; 는 함수 유형의 속성을 얻을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7eb690c3ef3a1529c909411cf3d35c20b241fbf3" translate="yes" xml:space="preserve">
          <source>Using exceptions to handle errors leads to another issue - how to write exception safe programs. &lt;a href=&quot;https://dlang.org/exception-safe.html&quot;&gt;Here's how&lt;/a&gt;.</source>
          <target state="translated">예외를 사용하여 오류를 처리하면 예외 안전 프로그램을 작성하는 방법과 같은 또 다른 문제가 발생합니다. &lt;a href=&quot;https://dlang.org/exception-safe.html&quot;&gt;방법은 다음과 같습니다&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="48badfbf8cc430bc5e24fa5412476d41eda3ceaf" translate="yes" xml:space="preserve">
          <source>Using functions and more types than the template:</source>
          <target state="translated">템플릿보다 함수와 더 많은 유형을 사용하는 경우 :</target>
        </trans-unit>
        <trans-unit id="4eca2488380272881b9de30c76f64561c55803ca" translate="yes" xml:space="preserve">
          <source>Using group, an associative array can be easily generated with the count of each unique element in the range.</source>
          <target state="translated">그룹을 사용하면 범위 내 각 고유 요소의 개수를 사용하여 연관 배열을 쉽게 생성 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e894da306300d7264b04f9bbeb317a07ad4c4216" translate="yes" xml:space="preserve">
          <source>Using the above flag, the linker will search in the standard framework paths. The standard search paths for frameworks are:</source>
          <target state="translated">링커는 위의 플래그를 사용하여 표준 프레임 워크 경로에서 검색합니다. 프레임 워크의 표준 검색 경로는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="e137a8793cb9aa11c5797755fd5b985067bcda9f" translate="yes" xml:space="preserve">
          <source>Using the range returned by this function in a parallel foreach loop will not work because buffers may be overwritten while the task that processes them is in queue. This is checked for at compile time and will result in a static assertion failure.</source>
          <target state="translated">병렬 foreach 루프에서이 함수가 리턴 한 범위를 사용하면 버퍼를 처리하는 태스크가 큐에있는 동안 버퍼를 겹쳐 쓸 수 있으므로 작동하지 않습니다. 컴파일시 확인되며 정적 어설 션 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="b6ed578893f11c816c086498ada4c56ae14083de" translate="yes" xml:space="preserve">
          <source>Using this delegate allows iteration over successive time points which are all the same day of the week. e.g. passing &lt;code&gt;DayOfWeek.mon&lt;/code&gt; to &lt;code&gt;everyDayOfWeek&lt;/code&gt; would result in a delegate which could be used to iterate over all of the Mondays in a range.</source>
          <target state="translated">이 대리자를 사용하면 모두 같은 요일 인 연속 시간에 걸쳐 반복 할 수 있습니다. 예를 들어 &lt;code&gt;DayOfWeek.mon&lt;/code&gt; 을 &lt;code&gt;everyDayOfWeek&lt;/code&gt; 에 전달 하면 일정 범위의 모든 월요일을 반복하는 데 사용할 수있는 델리게이트가 생성됩니다.</target>
        </trans-unit>
        <trans-unit id="01e4a295ee1f89ba313532d06753451f037e5d2d" translate="yes" xml:space="preserve">
          <source>Using this delegate allows iteration over successive time points which are apart by the given duration e.g. passing &lt;code&gt;dur!&quot;days&quot;(3)&lt;/code&gt; to &lt;code&gt;everyDuration&lt;/code&gt; would result in a delegate which could be used to iterate over a range of days which are each 3 days apart.</source>
          <target state="translated">이 대리자를 사용하면 &lt;code&gt;dur!&quot;days&quot;(3)&lt;/code&gt; 를 &lt;code&gt;everyDuration&lt;/code&gt; 에 전달하는 등 주어진 지속 시간만큼 떨어진 연속 된 시점 에 대해 반복 할 수 있습니다. .</target>
        </trans-unit>
        <trans-unit id="c6ec51f5ced2a1c1be894f86e670f88f6e1b3f63" translate="yes" xml:space="preserve">
          <source>Using this module is not necessary in typical D code. It is mostly useful when doing low-level memory management.</source>
          <target state="translated">일반적인 D 코드에서는이 모듈을 사용할 필요가 없습니다. 저수준 메모리 관리를 수행 할 때 주로 유용합니다.</target>
        </trans-unit>
        <trans-unit id="631bc23f5ec2b24f0267b7cee38a13c6b70e0b32" translate="yes" xml:space="preserve">
          <source>Using unit tests in conjuction with coverage testing (such as &lt;a href=&quot;https://dlang.org/dmd.html#switch-cov&quot;&gt;&lt;b&gt;-cov&lt;/b&gt;&lt;/a&gt;) is effective.</source>
          <target state="translated">적용 범위 테스트 (예 : &lt;a href=&quot;https://dlang.org/dmd.html#switch-cov&quot;&gt;&lt;b&gt;-cov&lt;/b&gt;&lt;/a&gt; ) 와 함께 단위 테스트를 사용하면 효과적입니다.</target>
        </trans-unit>
        <trans-unit id="d387cfce482bd0157645391025dc0dab84b81bed" translate="yes" xml:space="preserve">
          <source>Using with void handlers:</source>
          <target state="translated">void 핸들러와 함께 사용 :</target>
        </trans-unit>
        <trans-unit id="9d57966a5fe4d9e61b9bd2b025a52cea4116ac88" translate="yes" xml:space="preserve">
          <source>Usual Arithmetic Conversions</source>
          <target state="translated">일반적인 산술 변환</target>
        </trans-unit>
        <trans-unit id="375fab11fc70c98c677eac17e0744c53564be0ee" translate="yes" xml:space="preserve">
          <source>Usual decimal notation</source>
          <target state="translated">일반적인 십진 표기법</target>
        </trans-unit>
        <trans-unit id="189e13a83ee98c7852ba58517289e900a3678612" translate="yes" xml:space="preserve">
          <source>Usually &lt;code&gt;CAllocatorImpl&lt;/code&gt; is used indirectly by calling &lt;a href=&quot;#theAllocator&quot;&gt;&lt;code&gt;theAllocator&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">일반적으로 &lt;code&gt;CAllocatorImpl&lt;/code&gt; 는 호출하여 간접적으로 사용되는 &lt;a href=&quot;#theAllocator&quot;&gt; &lt;code&gt;theAllocator&lt;/code&gt; 을&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="5a3ab50d8476aca67a9de9d6b2f04749ce4d85ba" translate="yes" xml:space="preserve">
          <source>Usually &lt;code&gt;CSharedAllocatorImpl&lt;/code&gt; is used indirectly by calling &lt;a href=&quot;#processAllocator&quot;&gt;&lt;code&gt;processAllocator&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">일반적으로 &lt;code&gt;CSharedAllocatorImpl&lt;/code&gt; 은 &lt;a href=&quot;#processAllocator&quot;&gt; &lt;code&gt;processAllocator&lt;/code&gt; &lt;/a&gt; 를 호출하여 간접적으로 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="fcec0c4180b39c4ca2dae249c28eee53727aacb0" translate="yes" xml:space="preserve">
          <source>Usually one would use &lt;code&gt;expression.checkDeprecated(scope, aliasthis)&lt;/code&gt; to check if &lt;code&gt;expression&lt;/code&gt; uses a deprecated &lt;code&gt;aliasthis&lt;/code&gt;, but this calls &lt;code&gt;toPrettyChars&lt;/code&gt; which lead to the following message: &quot;Deprecation: alias this &lt;code&gt;fullyqualified.aggregate.__anonymous&lt;/code&gt; is deprecated&quot;</source>
          <target state="translated">일반적으로 &lt;code&gt;expression.checkDeprecated(scope, aliasthis)&lt;/code&gt; 를 사용하여 &lt;code&gt;expression&lt;/code&gt; 이 더 이상 사용되지 않는 &lt;code&gt;aliasthis&lt;/code&gt; 를 사용 하는지 확인 하지만 &lt;code&gt;toPrettyChars&lt;/code&gt; 를 호출 하여 &quot;Deprecation : alias this &lt;code&gt;fullyqualified.aggregate.__anonymous&lt;/code&gt; is deprecated&quot; 라는 메시지가 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="56e90d07707b3458a805a4bacd63daec2c432b02" translate="yes" xml:space="preserve">
          <source>Utf8Matcher</source>
          <target state="translated">Utf8Matcher</target>
        </trans-unit>
        <trans-unit id="18fdc5ee8b1f8fba8dabaa933373c0483ab7fad7" translate="yes" xml:space="preserve">
          <source>Utilities</source>
          <target state="translated">Utilities</target>
        </trans-unit>
        <trans-unit id="7ad38c788cc45a5074b9ffb9432c47c67a220b54" translate="yes" xml:space="preserve">
          <source>Utilities for manipulating files and scanning directories. Functions in this module handle files as a unit, e.g., read or write one file at a time. For opening files and manipulating them via handles refer to module &lt;a href=&quot;std_stdio&quot;&gt;&lt;code&gt;std.stdio&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">파일 조작 및 디렉토리 검색을위한 유틸리티. 이 모듈의 기능은 파일을 한 번에 한 파일 씩 읽거나 쓰는 등의 단위로 처리합니다. 파일을 열고 핸들을 통해 파일을 조작하려면 &lt;a href=&quot;std_stdio&quot;&gt; &lt;code&gt;std.stdio&lt;/code&gt; &lt;/a&gt; 모듈을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="5cb76eeaae4889cbc133d348ffc75221ffb8b4b7" translate="yes" xml:space="preserve">
          <source>Utility and ancillary artifacts of &lt;code&gt;std.experimental.allocator&lt;/code&gt;. This module shouldn't be used directly; its functionality will be migrated into more appropriate parts of &lt;code&gt;std&lt;/code&gt;.</source>
          <target state="translated">유틸리티 및 보조 유물 &lt;code&gt;std.experimental.allocator&lt;/code&gt; . 이 모듈은 직접 사용해서는 안됩니다. 그것의 기능은 &lt;code&gt;std&lt;/code&gt; 의 보다 적절한 부분으로 옮겨 질 것이다 .</target>
        </trans-unit>
        <trans-unit id="b9867d3a9c49162da041043a50cf7008b982e4ef" translate="yes" xml:space="preserve">
          <source>Utility to build a function call out of this reference and argument.</source>
          <target state="translated">이 참조 및 인수에서 함수 호출을 빌드하는 유틸리티입니다.</target>
        </trans-unit>
        <trans-unit id="c9ee5681d3c59f7541c27a38b67edf46259e187b" translate="yes" xml:space="preserve">
          <source>V</source>
          <target state="translated">V</target>
        </trans-unit>
        <trans-unit id="6cf0c0c7f5bb0a5a5c7282f8cd30993e76deb2f0" translate="yes" xml:space="preserve">
          <source>V &lt;code&gt;exchangeWith&lt;/code&gt;</source>
          <target state="translated">V &lt;code&gt;exchangeWith&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="996b87ed0fe8487bff29a2dec4722ab527ea5a40" translate="yes" xml:space="preserve">
          <source>V &lt;code&gt;maxAbsDiff&lt;/code&gt;</source>
          <target state="translated">V &lt;code&gt;maxAbsDiff&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="58e6f841de246b5933aae9d3dc5868627507c120" translate="yes" xml:space="preserve">
          <source>V &lt;code&gt;maxRelDiff&lt;/code&gt;</source>
          <target state="translated">V &lt;code&gt;maxRelDiff&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="ebf6b2708f752f3849720cb5f4bb150990c142ea" translate="yes" xml:space="preserve">
          <source>V &lt;code&gt;value&lt;/code&gt;</source>
          <target state="translated">V &lt;code&gt;value&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="c7aa9428cf99ed21c9b2d50259bb210fc9c6653b" translate="yes" xml:space="preserve">
          <source>V &lt;strong id=&quot;loadUnaligned&quot;&gt;loadUnaligned&lt;/strong&gt;(V)(const V* p)</source>
          <target state="translated">V &lt;strong id=&quot;loadUnaligned&quot;&gt;로드 정렬되지 않음&lt;/strong&gt; (V) (const V * p)</target>
        </trans-unit>
        <trans-unit id="ea4bf31a65b803e6d5e8754862432a804bcf1f21" translate="yes" xml:space="preserve">
          <source>V &lt;strong id=&quot;storeUnaligned&quot;&gt;storeUnaligned&lt;/strong&gt;(V)(V* p, V value)</source>
          <target state="translated">V &lt;strong id=&quot;storeUnaligned&quot;&gt;store 비 정렬&lt;/strong&gt; (V) (V * p, V 값)</target>
        </trans-unit>
        <trans-unit id="942a90c9bec88d5207a1a5060881571e2b1fe393" translate="yes" xml:space="preserve">
          <source>V* &lt;code&gt;p&lt;/code&gt;</source>
          <target state="translated">V * &lt;code&gt;p&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="e3bd3be2bbc21bec248542658e53653f18b36f05" translate="yes" xml:space="preserve">
          <source>V1 &lt;code&gt;ifThis&lt;/code&gt;</source>
          <target state="translated">V1 &lt;code&gt;ifThis&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="049a85cf151f96bcc540c68c5cd2d1eea3c1509d" translate="yes" xml:space="preserve">
          <source>V1 &lt;code&gt;mod&lt;/code&gt;</source>
          <target state="translated">V1 &lt;code&gt;mod&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="f4053c68a54663b4758120d92e86ef8bfc8c214a" translate="yes" xml:space="preserve">
          <source>V1 &lt;code&gt;newval&lt;/code&gt;</source>
          <target state="translated">V1 &lt;code&gt;newval&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="e0d2c6ab8c00acf411a44e6002c81ee87fc3e301" translate="yes" xml:space="preserve">
          <source>V1* &lt;code&gt;ifThis&lt;/code&gt;</source>
          <target state="translated">V1 * &lt;code&gt;ifThis&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="40135827f1648afd73698821e7495e8c2df48b20" translate="yes" xml:space="preserve">
          <source>V2 &lt;code&gt;writeThis&lt;/code&gt;</source>
          <target state="translated">V2 &lt;code&gt;writeThis&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="025198e42a319f7e1b7d4e566d6832369521d744" translate="yes" xml:space="preserve">
          <source>VFS only</source>
          <target state="translated">VFS 만</target>
        </trans-unit>
        <trans-unit id="76bc45e6071b6bf840834c3190d06cac0f7b7fac" translate="yes" xml:space="preserve">
          <source>V[K] &lt;code&gt;aa&lt;/code&gt;</source>
          <target state="translated">V [K] &lt;code&gt;aa&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="84f91d8df4169488a6e5b0c8d99b4bcf85ff79ce" translate="yes" xml:space="preserve">
          <source>V[K] &lt;strong id=&quot;dup&quot;&gt;dup&lt;/strong&gt;(T : V[K], K, V)(T aa);</source>
          <target state="translated">V [K] &lt;strong id=&quot;dup&quot;&gt;dup&lt;/strong&gt; (T : V [K], K, V) (T aa);</target>
        </trans-unit>
        <trans-unit id="4f374392fc8216fb266b35c7afa3c5383908a973" translate="yes" xml:space="preserve">
          <source>Vai</source>
          <target state="translated">Vai</target>
        </trans-unit>
        <trans-unit id="83f96f97d6bbb741686c832649fe36d1655e12f1" translate="yes" xml:space="preserve">
          <source>Validates an email address according to RFCs 5321, 5322 and others.</source>
          <target state="translated">RFC 5321, 5322 등에 따라 이메일 주소를 확인합니다.</target>
        </trans-unit>
        <trans-unit id="dd74d182c641e4c78502d863b44d0aeff1575e54" translate="yes" xml:space="preserve">
          <source>Validation</source>
          <target state="translated">Validation</target>
        </trans-unit>
        <trans-unit id="cde694e20f6f1970e02f61b4fe4c250aab2573eb" translate="yes" xml:space="preserve">
          <source>Value &lt;code&gt;value&lt;/code&gt;</source>
          <target state="translated">가치 &lt;code&gt;value&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="40e4777c3c9339aee0e1471542316f607e20c0b4" translate="yes" xml:space="preserve">
          <source>Value getter for &lt;code&gt;JSONType.array&lt;/code&gt;. Unlike &lt;code&gt;array&lt;/code&gt;, this retrieves the array by value and can be used in @safe code.</source>
          <target state="translated">용 게터 &lt;code&gt;JSONType.array&lt;/code&gt; . &lt;code&gt;array&lt;/code&gt; 와 달리 값으로 배열을 검색하여 @safe 코드에서 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="debaeee666e351d6eab3b4f3c90b3aa9118a0ea0" translate="yes" xml:space="preserve">
          <source>Value getter for &lt;code&gt;JSONType.object&lt;/code&gt;. Unlike &lt;code&gt;object&lt;/code&gt;, this retrieves the object by value and can be used in @safe code.</source>
          <target state="translated">용 게터 &lt;code&gt;JSONType.object&lt;/code&gt; . &lt;code&gt;object&lt;/code&gt; 와 달리 값으로 객체를 검색하여 @safe 코드에서 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0d34b60081d5920e95d26de3b14e5976c483a6c8" translate="yes" xml:space="preserve">
          <source>Value getter/setter for &lt;code&gt;JSONType.array&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;JSONType.array&lt;/code&gt; 의 값 getter / setter입니다 .</target>
        </trans-unit>
        <trans-unit id="06d88a23659d2106a272fc3c2a0cbf425061e548" translate="yes" xml:space="preserve">
          <source>Value getter/setter for &lt;code&gt;JSONType.float_&lt;/code&gt;. Note that despite the name, this is a &lt;b&gt;64&lt;/b&gt;-bit &lt;code&gt;double&lt;/code&gt;, not a 32-bit &lt;code&gt;float&lt;/code&gt;.</source>
          <target state="translated">값 게터 / 대한 세터 &lt;code&gt;JSONType.float_&lt;/code&gt; . 이름에도 불구하고 이것은 32 비트 &lt;code&gt;float&lt;/code&gt; 가 아니라 &lt;b&gt;64&lt;/b&gt; 비트 &lt;code&gt;double&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="682193cf221d6f67ac3388d98af6c6643d6280c0" translate="yes" xml:space="preserve">
          <source>Value getter/setter for &lt;code&gt;JSONType.integer&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;JSONType.integer&lt;/code&gt; 의 값 getter / setter입니다 .</target>
        </trans-unit>
        <trans-unit id="b856cf95a7918cf8c4713730d8144e2773a78ad5" translate="yes" xml:space="preserve">
          <source>Value getter/setter for &lt;code&gt;JSONType.object&lt;/code&gt;.</source>
          <target state="translated">값 게터 / 대한 세터 &lt;code&gt;JSONType.object&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f77315c89ea8901db907f7202a186401d954a3ab" translate="yes" xml:space="preserve">
          <source>Value getter/setter for &lt;code&gt;JSONType.string&lt;/code&gt;.</source>
          <target state="translated">값 게터 / 대한 세터 &lt;code&gt;JSONType.string&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="04d25aeadd95822d75f9e6c63a59113dd6ae997a" translate="yes" xml:space="preserve">
          <source>Value getter/setter for &lt;code&gt;JSONType.uinteger&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;JSONType.uinteger&lt;/code&gt; 의 값 getter / setter입니다 .</target>
        </trans-unit>
        <trans-unit id="c903c7f6e0c9717a3204ee2e6392ffb91a1e532e" translate="yes" xml:space="preserve">
          <source>Value getter/setter for boolean stored in JSON.</source>
          <target state="translated">부울에 대한 값 getter / setter는 JSON에 저장됩니다.</target>
        </trans-unit>
        <trans-unit id="f6a96ca6f671cd62067e2694b2efd9807e5523cb" translate="yes" xml:space="preserve">
          <source>Value of &lt;code&gt;f(ax)&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;f(ax)&lt;/code&gt; 값입니다 .</target>
        </trans-unit>
        <trans-unit id="6f84944c7f8eab7774fddf4925d08c76461c466b" translate="yes" xml:space="preserve">
          <source>Value of &lt;code&gt;f(bx)&lt;/code&gt;. &lt;code&gt;fax&lt;/code&gt; and &lt;code&gt;fbx&lt;/code&gt; should have opposite signs. (&lt;code&gt;f(ax)&lt;/code&gt; and &lt;code&gt;f(bx)&lt;/code&gt; are commonly known in advance.)</source>
          <target state="translated">&lt;code&gt;f(bx)&lt;/code&gt; 값입니다 . &lt;code&gt;fax&lt;/code&gt; 와 &lt;code&gt;fbx&lt;/code&gt; 의 반대 부호가 있어야합니다. ( &lt;code&gt;f(ax)&lt;/code&gt; 와 &lt;code&gt;f(bx)&lt;/code&gt; 는 일반적으로 미리 알려져 있습니다.)</target>
        </trans-unit>
        <trans-unit id="d1610fa402b56db1bc6c44e14091878669be03b2" translate="yes" xml:space="preserve">
          <source>Value that collectExceptionMsg returns when it catches an exception with an empty exception message.</source>
          <target state="translated">emptyException 메시지가있는 예외를 포착 할 때 collectExceptionMsg가 리턴하는 값.</target>
        </trans-unit>
        <trans-unit id="640fc9d1038f173d9ff4e515bd951053c5419590" translate="yes" xml:space="preserve">
          <source>Value to return from &lt;code&gt;onSend&lt;/code&gt;/&lt;code&gt;onReceive&lt;/code&gt; delegates in order to pause a request</source>
          <target state="translated">요청을 일시 중지하기 위해 &lt;code&gt;onSend&lt;/code&gt; / &lt;code&gt;onReceive&lt;/code&gt; 델리게이트에서 반환 할 값</target>
        </trans-unit>
        <trans-unit id="436caeedb105a260006f5d9f53f71e6eb7af184e" translate="yes" xml:space="preserve">
          <source>Value to return from onSend delegate in order to abort a request</source>
          <target state="translated">요청을 중단하기 위해 onSend 델리게이트에서 반환 할 값</target>
        </trans-unit>
        <trans-unit id="ed85e45d389cbb4acbbfe9be4b8d5516228b0f43" translate="yes" xml:space="preserve">
          <source>Value type demonstration</source>
          <target state="translated">가치 유형 데모</target>
        </trans-unit>
        <trans-unit id="ad0bdabc6c843c169a4bd7ec05f40c7999e6699f" translate="yes" xml:space="preserve">
          <source>Value value</source>
          <target state="translated">가치 가치</target>
        </trans-unit>
        <trans-unit id="5fb5308fe6160bec01a01fc2fea5f665d1701122" translate="yes" xml:space="preserve">
          <source>ValueSeq</source>
          <target state="translated">ValueSeq</target>
        </trans-unit>
        <trans-unit id="cff7efaccf1f82a33020670f421492cb87dbc329" translate="yes" xml:space="preserve">
          <source>Values &lt;code&gt;values&lt;/code&gt;</source>
          <target state="translated">값 &lt;code&gt;values&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="e66a2fd88968dd1905cd7e88ccfa7f4decf710b7" translate="yes" xml:space="preserve">
          <source>Values for Tflags:</source>
          <target state="translated">Tflags의 값 :</target>
        </trans-unit>
        <trans-unit id="d65dbad78909b2a5a1065f983fcd9dc730699c3f" translate="yes" xml:space="preserve">
          <source>Values representing all properties for floating point types</source>
          <target state="translated">부동 소수점 유형의 모든 속성을 나타내는 값</target>
        </trans-unit>
        <trans-unit id="f93686df732b3fd8135c18d6d396b9ab2d76ddbc" translate="yes" xml:space="preserve">
          <source>Values that have no mutable indirections (including structs that don't contain any field with mutable indirections) can be implicitly converted across</source>
          <target state="translated">변경 가능한 간접 지정이없는 값 (변경 가능한 간접 지정을 가진 필드를 포함하지 않는 구조체 포함)은 암시 적으로 변환 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6dae52b6d63731f1974b82b7571f6c94a8ffe05e" translate="yes" xml:space="preserve">
          <source>Values to initialize the &lt;code&gt;Tuple&lt;/code&gt; with. The &lt;code&gt;Tuple&lt;/code&gt;'s type will be inferred from the types of the values given.</source>
          <target state="translated">&lt;code&gt;Tuple&lt;/code&gt; 을 초기화 할 값 입니다. &lt;code&gt;Tuple&lt;/code&gt; 의 유형은 주어진 값의 유형에서 유추됩니다.</target>
        </trans-unit>
        <trans-unit id="a08087f5493c6ce5a8e9b48863d20de7128f05b2" translate="yes" xml:space="preserve">
          <source>VarDeclaration &lt;code&gt;v&lt;/code&gt;</source>
          <target state="translated">VarDeclaration &lt;code&gt;v&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="09a1466d563df21a998ae094ed1211927a8bb608" translate="yes" xml:space="preserve">
          <source>VarDeclaration &lt;strong id=&quot;copyToTemp&quot;&gt;copyToTemp&lt;/strong&gt;(StorageClass stc, const char* name, Expression e);</source>
          <target state="translated">VarDeclaration &lt;strong id=&quot;copyToTemp&quot;&gt;copyToTemp&lt;/strong&gt; (StorageClass stc, const char * 이름, 식 e);</target>
        </trans-unit>
        <trans-unit id="8b0928059a3c63031609334a2150b3e8d06084c2" translate="yes" xml:space="preserve">
          <source>VarDeclaration &lt;strong id=&quot;expToVariable&quot;&gt;expToVariable&lt;/strong&gt;(Expression e);</source>
          <target state="translated">VarDeclaration &lt;strong id=&quot;expToVariable&quot;&gt;expToVariable&lt;/strong&gt; (식 e);</target>
        </trans-unit>
        <trans-unit id="90f8642275d9fc08bf7503b4c8af023eb923bdfb" translate="yes" xml:space="preserve">
          <source>VarDeclaration &lt;strong id=&quot;lastVar&quot;&gt;lastVar&lt;/strong&gt;;</source>
          <target state="translated">VarDeclaration &lt;strong id=&quot;lastVar&quot;&gt;lastVar&lt;/strong&gt; ;</target>
        </trans-unit>
        <trans-unit id="93a7a74d06aa15956fd41f9b3c8c0f88bdfeb09e" translate="yes" xml:space="preserve">
          <source>VarDeclaration &lt;strong id=&quot;makeThis2Argument&quot;&gt;makeThis2Argument&lt;/strong&gt;(ref const Loc loc, Scope* sc, FuncDeclaration fd);</source>
          <target state="translated">VarDeclaration &lt;strong id=&quot;makeThis2Argument&quot;&gt;makeThis2Argument&lt;/strong&gt; (참조 const Loc loc, Scope * sc, FuncDeclaration fd);</target>
        </trans-unit>
        <trans-unit id="f8436ac83c71ac8d42475febc7871f32c710c99c" translate="yes" xml:space="preserve">
          <source>VarDeclaration &lt;strong id=&quot;nrvo_var&quot;&gt;nrvo_var&lt;/strong&gt;;</source>
          <target state="translated">VarDeclaration &lt;strong id=&quot;nrvo_var&quot;&gt;nrvo_var&lt;/strong&gt; ;</target>
        </trans-unit>
        <trans-unit id="18c616e0fbbc261b725f83621064accc3a1deeea" translate="yes" xml:space="preserve">
          <source>VarDeclaration &lt;strong id=&quot;selectorParameter&quot;&gt;selectorParameter&lt;/strong&gt;;</source>
          <target state="translated">VarDeclaration &lt;strong id=&quot;selectorParameter&quot;&gt;selectorParameter&lt;/strong&gt; ;</target>
        </trans-unit>
        <trans-unit id="12d50a347dabe7e15bb22e20811c56593e1bcae1" translate="yes" xml:space="preserve">
          <source>VarDeclaration &lt;strong id=&quot;v_argptr&quot;&gt;v_argptr&lt;/strong&gt;;</source>
          <target state="translated">VarDeclaration &lt;strong id=&quot;v_argptr&quot;&gt;v_argptr&lt;/strong&gt; ;</target>
        </trans-unit>
        <trans-unit id="f56d1a786ffb7ff06d7bb5bfa04d51b1b21ab644" translate="yes" xml:space="preserve">
          <source>VarDeclaration &lt;strong id=&quot;v_arguments&quot;&gt;v_arguments&lt;/strong&gt;;</source>
          <target state="translated">VarDeclaration &lt;strong id=&quot;v_arguments&quot;&gt;v_arguments&lt;/strong&gt; ;</target>
        </trans-unit>
        <trans-unit id="876239d27c5e57e358e8556afab8f0538d5c97fc" translate="yes" xml:space="preserve">
          <source>VarDeclaration &lt;strong id=&quot;var&quot;&gt;var&lt;/strong&gt;;</source>
          <target state="translated">VarDeclaration &lt;strong id=&quot;var&quot;&gt;var&lt;/strong&gt; ;</target>
        </trans-unit>
        <trans-unit id="42355f26f4ab9b91101680194f5be4e62a6fe977" translate="yes" xml:space="preserve">
          <source>VarDeclaration &lt;strong id=&quot;vresult&quot;&gt;vresult&lt;/strong&gt;;</source>
          <target state="translated">VarDeclaration &lt;strong id=&quot;vresult&quot;&gt;vresult&lt;/strong&gt; ;</target>
        </trans-unit>
        <trans-unit id="2e565c7d36ce463afb9fc418f5d295a5bbc339dc" translate="yes" xml:space="preserve">
          <source>VarDeclaration &lt;strong id=&quot;vthis&quot;&gt;vthis&lt;/strong&gt;;</source>
          <target state="translated">VarDeclaration &lt;strong id=&quot;vthis&quot;&gt;vthis&lt;/strong&gt; ;</target>
        </trans-unit>
        <trans-unit id="cbb4632d198d84986be1df6e34c6a01f8e53f3c6" translate="yes" xml:space="preserve">
          <source>VarDeclaration[] &lt;code&gt;array&lt;/code&gt;</source>
          <target state="translated">VarDeclaration [] &lt;code&gt;array&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="3cd372ff99770eda36a8d3e2dcd3e16f4cd0b425" translate="yes" xml:space="preserve">
          <source>VarDeclarations &lt;strong id=&quot;closureVars&quot;&gt;closureVars&lt;/strong&gt;;</source>
          <target state="translated">VarDeclarations &lt;strong id=&quot;closureVars&quot;&gt;closureVars&lt;/strong&gt; ;</target>
        </trans-unit>
        <trans-unit id="d1b9876e8a834a3e9b9e89838f595256e4706851" translate="yes" xml:space="preserve">
          <source>VarDeclarations* &lt;code&gt;vars&lt;/code&gt;</source>
          <target state="translated">VarDeclarations * &lt;code&gt;vars&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="12d65fd05a8f0de9525a8aab22e9d373bb1f9c2e" translate="yes" xml:space="preserve">
          <source>VarDeclarations* &lt;strong id=&quot;parameters&quot;&gt;parameters&lt;/strong&gt;;</source>
          <target state="translated">VarDeclarations * &lt;strong id=&quot;parameters&quot;&gt;매개 변수&lt;/strong&gt; ;</target>
        </trans-unit>
        <trans-unit id="19de69cb601f53a4ea7af22a65c71ae63251365c" translate="yes" xml:space="preserve">
          <source>Variable</source>
          <target state="translated">Variable</target>
        </trans-unit>
        <trans-unit id="8de05a295df0a022b8c2f74c1c4b8846fa725f50" translate="yes" xml:space="preserve">
          <source>Variable Templates</source>
          <target state="translated">변수 템플릿</target>
        </trans-unit>
        <trans-unit id="9ac503641226541343accfe90a0e5126b2011089" translate="yes" xml:space="preserve">
          <source>Variable declarations with the storage class &lt;code&gt;extern&lt;/code&gt; are not allocated storage within the module. They must be defined in some other object file with a matching name which is then linked in.</source>
          <target state="translated">스토리지 클래스 &lt;code&gt;extern&lt;/code&gt; 을 사용한 변수 선언 에는 모듈 내의 스토리지가 할당되지 않습니다. 그것들은 일치하는 이름을 가진 다른 객체 파일에 정의되어 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="6d65e9595c5fe8cf9c55be3b01afd1c068462a4a" translate="yes" xml:space="preserve">
          <source>Variadic Function Templates can have parameters with default values. These parameters are always set to their default value in case of IFTI.</source>
          <target state="translated">Variadic Function Templates에는 기본값을 가진 매개 변수가있을 수 있습니다. IFTI의 경우이 매개 변수는 항상 기본값으로 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="816e535fd41b8ae59e68e3a0203deed34e57e3f0" translate="yes" xml:space="preserve">
          <source>Variadic Functions</source>
          <target state="translated">가변 함수</target>
        </trans-unit>
        <trans-unit id="3ce44260db47b27a0765a58fa46f6799200c7452" translate="yes" xml:space="preserve">
          <source>Variadic argument list.</source>
          <target state="translated">다양한 인수 목록.</target>
        </trans-unit>
        <trans-unit id="7587c77875817ada8a5026c856c2f1518162a905" translate="yes" xml:space="preserve">
          <source>Variadic argument lists &lt;a href=&quot;https://dlang.org/spec/function.html#variadic&quot;&gt;https://dlang.org/spec/function.html#variadic&lt;/a&gt;</source>
          <target state="translated">다양한 인수 목록 &lt;a href=&quot;https://dlang.org/spec/function.html#variadic&quot;&gt;https://dlang.org/spec/function.html#variadic&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="2baf171f268c7ff8a5516278ea308ebe744eee6a" translate="yes" xml:space="preserve">
          <source>Variadic arguments to constructors are not forwarded to super.</source>
          <target state="translated">생성자에 대한 다양한 인수는 수퍼로 전달되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="032728a05fbda40894355d391ba66d41db7dfa0b" translate="yes" xml:space="preserve">
          <source>Variadic constructor</source>
          <target state="translated">가변 생성자</target>
        </trans-unit>
        <trans-unit id="399c0cba694f3cc4563013462fe2f380391903d2" translate="yes" xml:space="preserve">
          <source>Variadic functions with argument and type info are declared as taking a parameter of ... after the required function parameters. It has D linkage, and need not have any non-variadic parameters declared:</source>
          <target state="translated">인수 및 유형 정보가있는 가변 함수는 필수 함수 매개 변수 뒤에 ...의 매개 변수를 사용하는 것으로 선언됩니다. D 연결이 있으며 가변이 아닌 매개 변수를 선언 할 필요가 없습니다.</target>
        </trans-unit>
        <trans-unit id="e4ee6519876a792c801d55be8e1784d8bf29d4ef" translate="yes" xml:space="preserve">
          <source>Variadic functions with type info</source>
          <target state="translated">유형 정보가있는 다양한 기능</target>
        </trans-unit>
        <trans-unit id="5d2a300261f6a90712ba60d1554b5378b1469844" translate="yes" xml:space="preserve">
          <source>Variadic list of arguments to format into returned string.</source>
          <target state="translated">반환 된 문자열로 서식을 지정할 다양한 인수 목록.</target>
        </trans-unit>
        <trans-unit id="1cacd55c63e5681b498a2a8e79b74af695379b94" translate="yes" xml:space="preserve">
          <source>Variadic skipOver</source>
          <target state="translated">가변 건너 뛰기</target>
        </trans-unit>
        <trans-unit id="3ec54f528a04bfb78ded9b978c3382ebd1084d0f" translate="yes" xml:space="preserve">
          <source>Variant &lt;strong id=&quot;message&quot;&gt;message&lt;/strong&gt;;</source>
          <target state="translated">변형 &lt;strong id=&quot;message&quot;&gt;메시지&lt;/strong&gt; ;</target>
        </trans-unit>
        <trans-unit id="32ee207e01c00b2bfe4113ac9e48d0adc0d9a6ad" translate="yes" xml:space="preserve">
          <source>Variant &lt;strong id=&quot;opIndexAssign&quot;&gt;opIndexAssign&lt;/strong&gt;(T, N)(T value, N i);</source>
          <target state="translated">변형 &lt;strong id=&quot;opIndexAssign&quot;&gt;opIndexAssign&lt;/strong&gt; (T, N) (T 값, &lt;strong id=&quot;opIndexAssign&quot;&gt;NI&lt;/strong&gt; );</target>
        </trans-unit>
        <trans-unit id="39996f79d077e561bfc7c4efc30631527277acc7" translate="yes" xml:space="preserve">
          <source>Variant &lt;strong id=&quot;opIndexOpAssign&quot;&gt;opIndexOpAssign&lt;/strong&gt;(string op, T, N)(T value, N i);</source>
          <target state="translated">변형 &lt;strong id=&quot;opIndexOpAssign&quot;&gt;opIndexOpAssign&lt;/strong&gt; (문자열 op, T, N) (T 값, N i);</target>
        </trans-unit>
        <trans-unit id="54c59e2064d684bcdbd701d33a0bcca0d124521f" translate="yes" xml:space="preserve">
          <source>VariantN &lt;strong id=&quot;opAssign&quot;&gt;opAssign&lt;/strong&gt;(T)(T rhs);</source>
          <target state="translated">변형 N &lt;strong id=&quot;opAssign&quot;&gt;opAssign&lt;/strong&gt; (T) (T rhs);</target>
        </trans-unit>
        <trans-unit id="a89006b66590fbcedb1cf804abc7dcc4a7855324" translate="yes" xml:space="preserve">
          <source>VariantN &lt;strong id=&quot;opBinary&quot;&gt;opBinary&lt;/strong&gt;(string op, T)(T rhs)</source>
          <target state="translated">VariantN &lt;strong id=&quot;opBinary&quot;&gt;opBinary&lt;/strong&gt; (스트링 op, T) (T rhs)</target>
        </trans-unit>
        <trans-unit id="d50bd63e988142a8ed68771d6708dd3a3ef38a9f" translate="yes" xml:space="preserve">
          <source>VariantN &lt;strong id=&quot;opBinaryRight&quot;&gt;opBinaryRight&lt;/strong&gt;(string op, T)(T lhs)</source>
          <target state="translated">VariantN &lt;strong id=&quot;opBinaryRight&quot;&gt;opBinaryRight&lt;/strong&gt; (문자열 op, T) ( &lt;strong id=&quot;opBinaryRight&quot;&gt;Tlhs&lt;/strong&gt; )</target>
        </trans-unit>
        <trans-unit id="dcf8ce2200e09370d71e1c6c556f440c7178243e" translate="yes" xml:space="preserve">
          <source>VariantN &lt;strong id=&quot;opOpAssign&quot;&gt;opOpAssign&lt;/strong&gt;(string op, T)(T rhs);</source>
          <target state="translated">VariantN &lt;strong id=&quot;opOpAssign&quot;&gt;opOpAssign&lt;/strong&gt; (문자열 op, T) (T rhs);</target>
        </trans-unit>
        <trans-unit id="61d3a42cae9e2aa7a2127354c8d2a82e31e5f69f" translate="yes" xml:space="preserve">
          <source>Variant[] &lt;strong id=&quot;variantArray&quot;&gt;variantArray&lt;/strong&gt;(T...)(T args);</source>
          <target state="translated">변형 [] &lt;strong id=&quot;variantArray&quot;&gt;variantArray&lt;/strong&gt; (T ...) (T args);</target>
        </trans-unit>
        <trans-unit id="901dc81724f513c6e370e0d8b34b4fa85efd9490" translate="yes" xml:space="preserve">
          <source>Variation Selectors</source>
          <target state="translated">변형 선택기</target>
        </trans-unit>
        <trans-unit id="c842f577712c9ce569d8ca8213f4583b78433b04" translate="yes" xml:space="preserve">
          <source>Variation Selectors Supplement</source>
          <target state="translated">변형 선택기 보충</target>
        </trans-unit>
        <trans-unit id="66283c9058f793e57afbf6f12f5f67c2782019ef" translate="yes" xml:space="preserve">
          <source>Variation of Base64 encoding that is safe for use in URLs and filenames.</source>
          <target state="translated">URL 및 파일 이름에 안전한 Base64 인코딩의 변형입니다.</target>
        </trans-unit>
        <trans-unit id="85213404cd60884f4a897dfadd72c6565a384b83" translate="yes" xml:space="preserve">
          <source>Variation_Selector</source>
          <target state="translated">Variation_Selector</target>
        </trans-unit>
        <trans-unit id="37d044e9653fde1af3399c03c94f78dbe8624404" translate="yes" xml:space="preserve">
          <source>Various different debug builds can be built with a parameter to debug:</source>
          <target state="translated">디버그 할 매개 변수를 사용하여 다양한 디버그 빌드를 빌드 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="fdc4922db0ff01d0b7edd8e9b629bfcad196b8fd" translate="yes" xml:space="preserve">
          <source>Various different version builds can be built with a parameter to version:</source>
          <target state="translated">버전에 대한 매개 변수를 사용하여 다양한 버전 빌드를 빌드 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e63f884e9cb15e3080b00623367fb3234dfb09e6" translate="yes" xml:space="preserve">
          <source>Various functions take a string (or strings) to represent a unit of time (e.g. &lt;code&gt;convert!(&quot;days&quot;, &quot;hours&quot;)(numDays)&lt;/code&gt;). The valid strings to use with such functions are &quot;years&quot;, &quot;months&quot;, &quot;weeks&quot;, &quot;days&quot;, &quot;hours&quot;, &quot;minutes&quot;, &quot;seconds&quot;, &quot;msecs&quot; (milliseconds), &quot;usecs&quot; (microseconds), &quot;hnsecs&quot; (hecto-nanoseconds - i.e. 100 ns) or some subset thereof. There are a few functions that also allow &quot;nsecs&quot;, but very little actually has precision greater than hnsecs.</source>
          <target state="translated">다양한 함수는 시간 단위를 나타내는 문자열 (또는 문자열)을 사용합니다 (예 : &lt;code&gt;convert!(&quot;days&quot;, &quot;hours&quot;)(numDays)&lt;/code&gt; ). 이러한 함수와 함께 사용할 수있는 유효한 문자열은 &quot;년&quot;, &quot;달&quot;, &quot;주&quot;, &quot;일&quot;, &quot;시간&quot;, &quot;분&quot;, &quot;초&quot;, &quot;msecs&quot;(밀리 초), &quot;usecs&quot;(마이크로 초)입니다. &quot;hnsecs&quot;(헥토 나노초 (즉, 100ns)) 또는 이들의 일부 서브 세트. &quot;nsecs&quot;도 허용하는 몇 가지 함수가 있지만 실제로 hnsecs보다 큰 정밀도는 거의 없습니다.</target>
        </trans-unit>
        <trans-unit id="0e7432cf190c6da3860c9d822a4eb7ba1045ce6c" translate="yes" xml:space="preserve">
          <source>Vector Extensions</source>
          <target state="translated">벡터 확장</target>
        </trans-unit>
        <trans-unit id="10629e605ca0729fbf04887a08544de5fca2798c" translate="yes" xml:space="preserve">
          <source>Vector Operation Intrinsics</source>
          <target state="translated">벡터 연산 내장 함수</target>
        </trans-unit>
        <trans-unit id="c92e264e05e71f98aeb7e123b045932363360044" translate="yes" xml:space="preserve">
          <source>Vector Type Properties</source>
          <target state="translated">벡터 유형 속성</target>
        </trans-unit>
        <trans-unit id="2e86fbb68d6a32b094e97ddedce6b62c4721cb9e" translate="yes" xml:space="preserve">
          <source>Vector Types</source>
          <target state="translated">벡터 타입</target>
        </trans-unit>
        <trans-unit id="07181b72545f73b7288ae34baa8a686beb32c758" translate="yes" xml:space="preserve">
          <source>Vector types and operations are introduced by importing &lt;a href=&quot;https://dlang.org/phobos/core_simd.html&quot;&gt;&lt;code&gt;core.simd&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">벡터 유형 및 작업은 가져 소개 &lt;a href=&quot;https://dlang.org/phobos/core_simd.html&quot;&gt; &lt;code&gt;core.simd&lt;/code&gt; &lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="c049990f0c907a0b35a257826bc00e0b75b1e2f2" translate="yes" xml:space="preserve">
          <source>Vector types have the property:</source>
          <target state="translated">벡터 유형에는 다음과 같은 속성이 있습니다.</target>
        </trans-unit>
        <trans-unit id="b74915db3cd649e1a4f2705d1b61481a4f84d736" translate="yes" xml:space="preserve">
          <source>Vector types of the same size can be implicitly converted among each other. Vector types can be cast to their &lt;a href=&quot;declaration#VectorBaseType&quot;&gt;&lt;i&gt;VectorBaseType&lt;/i&gt;&lt;/a&gt;.</source>
          <target state="translated">크기가 같은 벡터 유형은 서로 암시 적으로 변환 될 수 있습니다. 벡터 유형은 &lt;a href=&quot;declaration#VectorBaseType&quot;&gt;&lt;i&gt;VectorBaseType&lt;/i&gt;&lt;/a&gt; 으로 캐스트 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="18c53b8bedaa759385d9a1d0719db45a3122d467" translate="yes" xml:space="preserve">
          <source>Vedic Extensions</source>
          <target state="translated">베다 확장</target>
        </trans-unit>
        <trans-unit id="1414b2c627a4af94b45e0a6f7329a9caaa64d766" translate="yes" xml:space="preserve">
          <source>Vendor Specific Pragmas</source>
          <target state="translated">공급 업체별 프라 그마</target>
        </trans-unit>
        <trans-unit id="643648d81a8af7bf6b4f73a64885b12b7476a866" translate="yes" xml:space="preserve">
          <source>Vendor specific pragma</source>
          <target state="translated">공급 업체별 pragma</target>
        </trans-unit>
        <trans-unit id="9200d77a5dd8fafeec19ec715fa8db6a41135a49" translate="yes" xml:space="preserve">
          <source>Vendor specific string naming the compiler, for example: &quot;Digital Mars D&quot;.</source>
          <target state="translated">컴파일러의 이름을 지정하는 공급 업체별 문자열입니다 (예 : &quot;Digital Mars D&quot;).</target>
        </trans-unit>
        <trans-unit id="db3cbc01da600701b9fe4a497fe328e71fa7022f" translate="yes" xml:space="preserve">
          <source>Version 1</source>
          <target state="translated">버전 1</target>
        </trans-unit>
        <trans-unit id="57ce28f628abe360a4bb4a57891d0472e82ed0fe" translate="yes" xml:space="preserve">
          <source>Version 2</source>
          <target state="translated">버전 2</target>
        </trans-unit>
        <trans-unit id="075d8b625649c8aff29ec9c2a1b5610d7c109764" translate="yes" xml:space="preserve">
          <source>Version 3 (Name based + MD5)</source>
          <target state="translated">버전 3 (이름 기반 + MD5)</target>
        </trans-unit>
        <trans-unit id="ddcc753d5e82e42538acd5fc16f4473c5257f4b4" translate="yes" xml:space="preserve">
          <source>Version 4 (Random)</source>
          <target state="translated">버전 4 (임의)</target>
        </trans-unit>
        <trans-unit id="319868a4751c2b346e9dfe64ab6429818b302223" translate="yes" xml:space="preserve">
          <source>Version 5 (Name based + SHA-1)</source>
          <target state="translated">버전 5 (이름 기반 + SHA-1)</target>
        </trans-unit>
        <trans-unit id="e66316ca12a840f1988c4b94ab525a7f42bae2cc" translate="yes" xml:space="preserve">
          <source>Version Condition</source>
          <target state="translated">버전 조건</target>
        </trans-unit>
        <trans-unit id="4d10083d98ea26e265f0014436dbfce2fa1927ba" translate="yes" xml:space="preserve">
          <source>Version Specification</source>
          <target state="translated">버전 사양</target>
        </trans-unit>
        <trans-unit id="60cbe77612285f77722795eaf486e9077345ff6b" translate="yes" xml:space="preserve">
          <source>Version identifiers are in their own unique name space, they do not conflict with debug identifiers or other symbols in the module. Version identifiers defined in one module have no influence over other imported modules.</source>
          <target state="translated">버전 식별자는 고유 한 네임 스페이스에 있으며 디버그 식별자 또는 모듈의 다른 기호와 충돌하지 않습니다. 한 모듈에 정의 된 버전 식별자는 다른 가져온 모듈에 영향을 미치지 않습니다.</target>
        </trans-unit>
        <trans-unit id="8452f9b655098d440b8bbfefe1781b61039f888f" translate="yes" xml:space="preserve">
          <source>Version identifiers or levels may not be forward referenced:</source>
          <target state="translated">버전 식별자 또는 레벨은 앞으로 참조되지 않을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8639bd1e7277675ae42f2185af060f18565b1cba" translate="yes" xml:space="preserve">
          <source>Version of &lt;code&gt;task&lt;/code&gt; usable from &lt;code&gt;@safe&lt;/code&gt; code. Usage mechanics are identical to the non-@safe case, but safety introduces some restrictions:</source>
          <target state="translated">&lt;code&gt;@safe&lt;/code&gt; 코드 에서 사용할 수있는 &lt;code&gt;task&lt;/code&gt; 버전 . 사용법 역학은 비 안전 사례와 동일하지만 안전성에는 몇 가지 제한 사항이 있습니다.</target>
        </trans-unit>
        <trans-unit id="9f49127025fb5873ad1bd738867c76e3725ffeaa" translate="yes" xml:space="preserve">
          <source>Version:</source>
          <target state="translated">Version:</target>
        </trans-unit>
        <trans-unit id="8ba6c0ad00aab5da97cc5e9d2ce6ef4a16d6e35f" translate="yes" xml:space="preserve">
          <source>VersionCondition</source>
          <target state="translated">VersionCondition</target>
        </trans-unit>
        <trans-unit id="d5945a6259445f6d607383ec1208b7b2bf5b1920" translate="yes" xml:space="preserve">
          <source>VersionSpecification</source>
          <target state="translated">VersionSpecification</target>
        </trans-unit>
        <trans-unit id="7870ecf513f546adaa9964ca9e10d00cc0c279a8" translate="yes" xml:space="preserve">
          <source>VersionSymbol's happen for statements like: version = identifier; version = integer;</source>
          <target state="translated">VersionSymbol은 다음과 같은 문장에서 발생합니다 : version = identifier; 버전 = 정수;</target>
        </trans-unit>
        <trans-unit id="3f4a4fcd926f6c485e563d96d221a73c6f637a3b" translate="yes" xml:space="preserve">
          <source>Versions enable multiple versions of a module to be implemented with a single source file.</source>
          <target state="translated">버전을 사용하면 단일 소스 파일로 여러 버전의 모듈을 구현할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6fd4c427e710fed77db57126b79deded3402ad4f" translate="yes" xml:space="preserve">
          <source>Vertical Forms</source>
          <target state="translated">수직 형태</target>
        </trans-unit>
        <trans-unit id="f26a73edd5911cc59d619f45a8244a225ed70c75" translate="yes" xml:space="preserve">
          <source>Vertical tab</source>
          <target state="translated">세로 탭</target>
        </trans-unit>
        <trans-unit id="783de7e5b7d2118dade416730da300df060f3cbb" translate="yes" xml:space="preserve">
          <source>Vertical tab (U+000B).</source>
          <target state="translated">세로 탭 (U + 000B).</target>
        </trans-unit>
        <trans-unit id="b5a83b3d5b0ebbd94dda9282d36df61edd71daee" translate="yes" xml:space="preserve">
          <source>Very good at doing absolutely nothing. A good starting point for defining other allocators or for studying the API.</source>
          <target state="translated">전혀 아무것도하지 않는 것이 좋습니다. 다른 할당자를 정의하거나 API를 연구하기에 좋은 출발점입니다.</target>
        </trans-unit>
        <trans-unit id="83b6b08c6edd1287fdcd6c32741f985b4501a4d1" translate="yes" xml:space="preserve">
          <source>View Name NULL</source>
          <target state="translated">뷰 이름 NULL</target>
        </trans-unit>
        <trans-unit id="7661d9e884510184f3115feaa61daa7fb90ab554" translate="yes" xml:space="preserve">
          <source>Virtual File System Objects</source>
          <target state="translated">가상 파일 시스템 객체</target>
        </trans-unit>
        <trans-unit id="b0befb20b7c19afcab0b8606b1eb82ff57c76c58" translate="yes" xml:space="preserve">
          <source>Virtual Function Pointer Table Layout</source>
          <target state="translated">가상 함수 포인터 테이블 레이아웃</target>
        </trans-unit>
        <trans-unit id="7dcd32ac0fb832374c32b25d413091959d3ff701" translate="yes" xml:space="preserve">
          <source>Virtual Functions</source>
          <target state="translated">가상 함수</target>
        </trans-unit>
        <trans-unit id="0f4f4c40c9b657d040c9a5a3549b3c5d32fbc234" translate="yes" xml:space="preserve">
          <source>Virtual Table Configuration Options</source>
          <target state="translated">가상 테이블 구성 옵션</target>
        </trans-unit>
        <trans-unit id="d3cabefe217e8ae9513576669d0630c721003893" translate="yes" xml:space="preserve">
          <source>Virtual Table Cursor Object</source>
          <target state="translated">가상 테이블 커서 객체</target>
        </trans-unit>
        <trans-unit id="02d05d9b66c15b554ca60cadbe6ddd8d5a77642f" translate="yes" xml:space="preserve">
          <source>Virtual Table Indexing Information</source>
          <target state="translated">가상 테이블 인덱싱 정보</target>
        </trans-unit>
        <trans-unit id="80548cb099ad243dfef606537d8cb425cbe7b21c" translate="yes" xml:space="preserve">
          <source>Virtual Table Instance Object</source>
          <target state="translated">가상 테이블 인스턴스 객체</target>
        </trans-unit>
        <trans-unit id="c7613e2461269638f02a689a01bdfb20ef96932a" translate="yes" xml:space="preserve">
          <source>Virtual Table Object</source>
          <target state="translated">가상 테이블 객체</target>
        </trans-unit>
        <trans-unit id="aff3c69afbe7a90d7ffde690777408380726fb5f" translate="yes" xml:space="preserve">
          <source>Virtual functions all have a hidden parameter called the</source>
          <target state="translated">가상 함수에는 모두</target>
        </trans-unit>
        <trans-unit id="e1c58c4269e8592749612ae3da0cd7b360ba819a" translate="yes" xml:space="preserve">
          <source>Virtual functions are functions that are called indirectly through a function pointer table, called a vtbl[], rather than directly. All &lt;code&gt;public&lt;/code&gt; and &lt;code&gt;protected&lt;/code&gt; member functions which are non-static and are not templatized are virtual unless the compiler can determine that they will never be overridden (e.g. they are marked with &lt;code&gt;final&lt;/code&gt; and do not override any functions in a base class), in which case, it will make them non-virtual. Static or &lt;code&gt;final&lt;/code&gt; functions with &lt;code&gt;Objective-C&lt;/code&gt; linkage are virtual as well. This results in fewer bugs caused by not declaring a function virtual and then overriding it anyway.</source>
          <target state="translated">가상 함수는 직접적이 아니라 vtbl []라고하는 함수 포인터 테이블을 통해 간접적으로 호출되는 함수입니다. 정적이 아니며 템플릿 화되지 않은 모든 &lt;code&gt;public&lt;/code&gt; 및 &lt;code&gt;protected&lt;/code&gt; 멤버 함수는 컴파일러에서 절대 오버라이드되지 않을 것으로 판단 할 수없는 경우 (예 : &lt;code&gt;final&lt;/code&gt; 로 표시되고 기본 클래스의 함수를 재정의하지 않음) 가 아니면 가상입니다. 그것들을 비가 상으로 만들 것입니다. &lt;code&gt;Objective-C&lt;/code&gt; 연결을 사용한 정적 또는 &lt;code&gt;final&lt;/code&gt; 함수 도 가상입니다. 이로 인해 가상 함수를 선언하지 않고 재정의함으로써 발생하는 버그가 줄어 듭니다.</target>
        </trans-unit>
        <trans-unit id="14cc5cce0a54264b12497e056c1917afd19e7eb7" translate="yes" xml:space="preserve">
          <source>Virtual interface member functions do not have implementations. Interfaces are expected to implement static or final functions.</source>
          <target state="translated">가상 인터페이스 멤버 함수에는 구현이 없습니다. 인터페이스는 정적 또는 최종 기능을 구현할 것으로 예상됩니다.</target>
        </trans-unit>
        <trans-unit id="23ecb6a10d1b99be3019a63076a2464bbfbb2301" translate="yes" xml:space="preserve">
          <source>Virtual table of this cursor</source>
          <target state="translated">이 커서의 가상 테이블</target>
        </trans-unit>
        <trans-unit id="1c1672376b6b5ed02995bff06fe4feb7630511fb" translate="yes" xml:space="preserve">
          <source>Visibility Attribute</source>
          <target state="translated">가시성 속성</target>
        </trans-unit>
        <trans-unit id="770309d5c2e0f2778ba518ab224adafe114b41f4" translate="yes" xml:space="preserve">
          <source>Visibility is an attribute that is one of &lt;code&gt;private&lt;/code&gt;, &lt;code&gt;package&lt;/code&gt;, &lt;code&gt;protected&lt;/code&gt;, &lt;code&gt;public&lt;/code&gt;, or &lt;code&gt;export&lt;/code&gt;. They may be referred to as protection attributes in documents predating &lt;a href=&quot;http://wiki.dlang.org/DIP22&quot;&gt;DIP22&lt;/a&gt;.</source>
          <target state="translated">가시성은 &lt;code&gt;private&lt;/code&gt; , &lt;code&gt;package&lt;/code&gt; , &lt;code&gt;protected&lt;/code&gt; , &lt;code&gt;public&lt;/code&gt; 또는 &lt;code&gt;export&lt;/code&gt; 중 하나 인 속성입니다 . 이들은 &lt;a href=&quot;http://wiki.dlang.org/DIP22&quot;&gt;DIP22&lt;/a&gt; 이전의 문서에서 보호 속성이라고 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="6c05960b386f26ee3e915fac197d378f3ebcb6a8" translate="yes" xml:space="preserve">
          <source>Visibility participates in &lt;a href=&quot;module#name_lookup&quot;&gt;symbol name lookup&lt;/a&gt;.</source>
          <target state="translated">가시성은 &lt;a href=&quot;module#name_lookup&quot;&gt;심볼 이름 조회에&lt;/a&gt; 참여 합니다.</target>
        </trans-unit>
        <trans-unit id="1c92fbe0bbb759a09c0faa29208bb88b78b9b6f8" translate="yes" xml:space="preserve">
          <source>Visit each overloaded function/template in turn, and call dg(s) on it. Exit when no more, or dg(s) returns nonzero.</source>
          <target state="translated">오버로드 된 각 함수 / 템플릿을 차례로 방문하여 dg (s)를 호출하십시오. 더 이상 없으면 종료하거나 dg가 0이 아닌 값을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="095d4e1da0ccccf0f23cb7d7417321dea1d13b5b" translate="yes" xml:space="preserve">
          <source>Visitor &lt;code&gt;v&lt;/code&gt;</source>
          <target state="translated">방문자 &lt;code&gt;v&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="ed75e8e2064c0cf00a947caba1ce28a6fe75f18b" translate="yes" xml:space="preserve">
          <source>Visitor that implements the AST traversal logic. The nodes just accept their children.</source>
          <target state="translated">AST 순회 로직을 구현하는 방문자입니다. 노드는 단지 자녀를 받아들입니다.</target>
        </trans-unit>
        <trans-unit id="15fa187dd92efb368750787f933eb6c9f5cdd9fe" translate="yes" xml:space="preserve">
          <source>Visits this AST node using the given visitor.</source>
          <target state="translated">지정된 방문자를 사용하여이 AST 노드를 방문합니다.</target>
        </trans-unit>
        <trans-unit id="7e76fe40efd36819ad4216cae6d472d259442ebf" translate="yes" xml:space="preserve">
          <source>Void Arrays</source>
          <target state="translated">무효 배열</target>
        </trans-unit>
        <trans-unit id="a3b9953f805ebbaefa9422b2c296b873ff21f42c" translate="yes" xml:space="preserve">
          <source>Void Initialization</source>
          <target state="translated">무효 초기화</target>
        </trans-unit>
        <trans-unit id="bf3edd1e4d2a01f42d21c6548696eea61602c39b" translate="yes" xml:space="preserve">
          <source>Void Initializations</source>
          <target state="translated">무효 초기화</target>
        </trans-unit>
        <trans-unit id="ccfd4941fe26581cb178fed9382832c4cba184df" translate="yes" xml:space="preserve">
          <source>Void arrays can also be static if their length is known at compile-time. The length is specified in bytes:</source>
          <target state="translated">Void 배열은 컴파일 타임에 길이가 알려진 경우 정적 일 수 있습니다. 길이는 바이트로 지정됩니다.</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
