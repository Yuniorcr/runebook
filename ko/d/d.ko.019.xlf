<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="d">
    <body>
      <group id="d">
        <trans-unit id="c2cc357fb7c03c09f92dcb1aaffc28e51837dbc6" translate="yes" xml:space="preserve">
          <source>Flag used by &lt;a href=&quot;#resolveFuncCall&quot;&gt;&lt;code&gt;resolveFuncCall&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#resolveFuncCall&quot;&gt; &lt;code&gt;resolveFuncCall&lt;/code&gt; 가&lt;/a&gt; 사용하는 플래그 .</target>
        </trans-unit>
        <trans-unit id="dfa1ebe73458327f2f1b2331e7d2bc64bda02225" translate="yes" xml:space="preserve">
          <source>Flag!&quot;&lt;strong id=&quot;each&quot;&gt;each&lt;/strong&gt;&quot; &lt;strong id=&quot;each&quot;&gt;each&lt;/strong&gt;(Iterable)(auto ref Iterable r)</source>
          <target state="translated">플래그! &quot; &lt;strong id=&quot;each&quot;&gt;각&lt;/strong&gt; &quot; &lt;strong id=&quot;each&quot;&gt;각&lt;/strong&gt; (반복 가능) (자동 참조 반복 가능 r)</target>
        </trans-unit>
        <trans-unit id="2e29bfd584368e0b6c450b93dff8e2b4b7d7e79b" translate="yes" xml:space="preserve">
          <source>Flag!&quot;&lt;strong id=&quot;each&quot;&gt;each&lt;/strong&gt;&quot; &lt;strong id=&quot;each&quot;&gt;each&lt;/strong&gt;(Range)(Range r)</source>
          <target state="translated">깃발! &quot; &lt;strong id=&quot;each&quot;&gt;각각&lt;/strong&gt; &quot; &lt;strong id=&quot;each&quot;&gt;각&lt;/strong&gt; (범위) (범위 r)</target>
        </trans-unit>
        <trans-unit id="5d728758adcdd5154d3be55552c1c061ef1489b2" translate="yes" xml:space="preserve">
          <source>Flags</source>
          <target state="translated">Flags</target>
        </trans-unit>
        <trans-unit id="a98a30dbf66202f4a1ca6fcfeff706e1cb961f9b" translate="yes" xml:space="preserve">
          <source>Flags affect formatting depending on the specifier as follows.</source>
          <target state="translated">플래그는 다음과 같이 지정자에 따라 형식화에 영향을줍니다.</target>
        </trans-unit>
        <trans-unit id="517da122a2fd8a775a91cf3934a2421fdfecad5e" translate="yes" xml:space="preserve">
          <source>Flags may be OR'ed together:</source>
          <target state="translated">플래그는 함께 OR 될 수 있습니다 :</target>
        </trans-unit>
        <trans-unit id="9a817b12d43958a297fe78c774ef0aab232c3032" translate="yes" xml:space="preserve">
          <source>Flags that can be passed to &lt;a href=&quot;#pipeProcess&quot;&gt;&lt;code&gt;pipeProcess&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#pipeShell&quot;&gt;&lt;code&gt;pipeShell&lt;/code&gt;&lt;/a&gt; to specify which of the child process' standard streams are redirected. Use bitwise OR to combine flags.</source>
          <target state="translated">자식 프로세스의 표준 스트림 중 리디렉션되는 것을 지정 하기 위해 &lt;a href=&quot;#pipeProcess&quot;&gt; &lt;code&gt;pipeProcess&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#pipeShell&quot;&gt; &lt;code&gt;pipeShell&lt;/code&gt; &lt;/a&gt; 에 전달할 수있는 플래그입니다 . 비트 OR을 사용하여 플래그를 결합하십시오.</target>
        </trans-unit>
        <trans-unit id="d7bf08131e02f1b45b6731cfdb8ac81266998286" translate="yes" xml:space="preserve">
          <source>Flags that control how json is encoded and parsed.</source>
          <target state="translated">json의 인코딩 및 구문 분석 방법을 제어하는 ​​플래그입니다.</target>
        </trans-unit>
        <trans-unit id="9101e63c4b97693993f5de7e6caad68a3e230e45" translate="yes" xml:space="preserve">
          <source>Flags that control process creation. See &lt;a href=&quot;#Config&quot;&gt;&lt;code&gt;Config&lt;/code&gt;&lt;/a&gt; for an overview of available flags, and note that the &lt;code&gt;retainStd...&lt;/code&gt; flags have no effect in this function.</source>
          <target state="translated">프로세스 생성을 제어하는 ​​플래그. 사용 가능한 플래그에 대한 개요는 &lt;a href=&quot;#Config&quot;&gt; &lt;code&gt;Config&lt;/code&gt; &lt;/a&gt; 을 참조하십시오 . &lt;code&gt;retainStd...&lt;/code&gt; 플래그는이 기능에 영향을 미치지 않습니다.</target>
        </trans-unit>
        <trans-unit id="8fa52f42ca8ff70a9db0dc2e586798abb191d35d" translate="yes" xml:space="preserve">
          <source>Flags that control process creation. See &lt;a href=&quot;#Config&quot;&gt;&lt;code&gt;Config&lt;/code&gt;&lt;/a&gt; for an overview of available flags.</source>
          <target state="translated">프로세스 생성을 제어하는 ​​플래그. 사용 가능한 플래그에 대한 개요는 &lt;a href=&quot;#Config&quot;&gt; &lt;code&gt;Config&lt;/code&gt; &lt;/a&gt; 을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="c0978ac0b3ccfd7282e3c33d010ed6583a1755a4" translate="yes" xml:space="preserve">
          <source>Flags that control the behaviour of process creation functions in this module. Most flags only apply to &lt;a href=&quot;#spawnProcess&quot;&gt;&lt;code&gt;spawnProcess&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#spawnShell&quot;&gt;&lt;code&gt;spawnShell&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 모듈에서 프로세스 작성 기능의 동작을 제어하는 ​​플래그. 대부분의 플래그는 &lt;a href=&quot;#spawnProcess&quot;&gt; &lt;code&gt;spawnProcess&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#spawnShell&quot;&gt; &lt;code&gt;spawnShell&lt;/code&gt; &lt;/a&gt; 에만 적용됩니다 .</target>
        </trans-unit>
        <trans-unit id="a98c5de453c2c7c3caf6bb14f159914e55de8b90" translate="yes" xml:space="preserve">
          <source>Flags that determine which streams are redirected, and how. See &lt;a href=&quot;#Redirect&quot;&gt;&lt;code&gt;Redirect&lt;/code&gt;&lt;/a&gt; for an overview of available flags.</source>
          <target state="translated">리디렉션되는 스트림과 방법을 결정하는 플래그입니다. 사용 가능한 플래그에 대한 개요는 &lt;a href=&quot;#Redirect&quot;&gt; &lt;code&gt;Redirect&lt;/code&gt; &lt;/a&gt; 을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="b620409ddfc3fc2bb8b14e73ba7780a044ad90c9" translate="yes" xml:space="preserve">
          <source>Flatten out the scope by presenting the statement as an array of statements.</source>
          <target state="translated">명령문을 명령문 배열로 표시하여 범위를 평평하게하십시오.</target>
        </trans-unit>
        <trans-unit id="69f2ec628a1c75aed5c37949245c44cc81da511d" translate="yes" xml:space="preserve">
          <source>Flips a single bit, specified by &lt;code&gt;pos&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;pos&lt;/code&gt; 로 지정된 단일 비트를 뒤집습니다.</target>
        </trans-unit>
        <trans-unit id="a4e1ce065ff47fa12c8210de50047287b30b8075" translate="yes" xml:space="preserve">
          <source>Flips all the bits in the &lt;code&gt;BitArray&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;BitArray&lt;/code&gt; 의 모든 비트를 뒤집습니다.</target>
        </trans-unit>
        <trans-unit id="f980f6669a99ae97aa471b598c62ac0c3e1f823b" translate="yes" xml:space="preserve">
          <source>Floating Point</source>
          <target state="translated">부동 소수점</target>
        </trans-unit>
        <trans-unit id="a7a463a748e16b2f5b0e11e3ae1b317ccea7b0fc" translate="yes" xml:space="preserve">
          <source>Floating Point Constant Folding</source>
          <target state="translated">부동 소수점 상수 폴딩</target>
        </trans-unit>
        <trans-unit id="d66cb8936a51df45efbb55e9f325e90025cbbefc" translate="yes" xml:space="preserve">
          <source>Floating Point Intermediate Values</source>
          <target state="translated">부동 소수점 중간 값</target>
        </trans-unit>
        <trans-unit id="a6c4e80d19a5698157c68955c5feabc616b55ad5" translate="yes" xml:space="preserve">
          <source>Floating Point Literals</source>
          <target state="translated">부동 소수점 리터럴</target>
        </trans-unit>
        <trans-unit id="549c1462b87072d7712396a53e8de6f7b9f76688" translate="yes" xml:space="preserve">
          <source>Floating Point Transformations</source>
          <target state="translated">부동 소수점 변환</target>
        </trans-unit>
        <trans-unit id="00848e3da3c10e7ab7937982dcd4c2d2c3dffaaa" translate="yes" xml:space="preserve">
          <source>Floating literals can have embedded &amp;lsquo;_&amp;rsquo; characters, which are ignored.</source>
          <target state="translated">부동 리터럴에는 '_'문자가 포함될 수 있으며 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="01668267e3349ef380ebd600403f931fc5d66ef9" translate="yes" xml:space="preserve">
          <source>Floating literals with no suffix are of type &lt;code&gt;double&lt;/code&gt;. They can be followed by one &lt;b&gt;f&lt;/b&gt;, &lt;b&gt;F&lt;/b&gt;, or &lt;b&gt;L&lt;/b&gt; suffix. The &lt;b&gt;f&lt;/b&gt; or &lt;b&gt;F&lt;/b&gt; suffix types it is a &lt;code&gt;float&lt;/code&gt;, and &lt;b&gt;L&lt;/b&gt; types it is a &lt;code&gt;real&lt;/code&gt;.</source>
          <target state="translated">접미사가없는 부동 리터럴은 &lt;code&gt;double&lt;/code&gt; 유형 입니다. 그 뒤에 하나의 &lt;b&gt;f&lt;/b&gt; , &lt;b&gt;F&lt;/b&gt; 또는 &lt;b&gt;L&lt;/b&gt; 접미 부가 올 수 있습니다. &lt;b&gt;F&lt;/b&gt; 또는 &lt;b&gt;F의&lt;/b&gt; 접미사 유형 그것은 인 &lt;code&gt;float&lt;/code&gt; 와 &lt;b&gt;L의&lt;/b&gt; 유형이다 그것은 &lt;code&gt;real&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1a4195feb88e405b4996ac5dcca713ad5c6175c1" translate="yes" xml:space="preserve">
          <source>Floating point NaN's are formatted as &lt;b&gt;nan&lt;/b&gt; if the</source>
          <target state="translated">부동 소수점의 NaN의이 같은 형식이 &lt;b&gt;유모&lt;/b&gt; 는 IF</target>
        </trans-unit>
        <trans-unit id="afa8bdea6b3525811aead9f74976b708a0d15aba" translate="yes" xml:space="preserve">
          <source>Floating point comparison operators</source>
          <target state="translated">부동 소수점 비교 연산자</target>
        </trans-unit>
        <trans-unit id="ed4b0ae6cd9ee0a107d7642401f3d58f692c98b4" translate="yes" xml:space="preserve">
          <source>Floating point comparisons</source>
          <target state="translated">부동 소수점 비교</target>
        </trans-unit>
        <trans-unit id="51fe49d981df10fc2a3ca0c38f66d9ec597eda64" translate="yes" xml:space="preserve">
          <source>Floating point computations can be carried out at a higher precision than the size of the floating point variable can hold. Floating point algorithms should continue to work properly if precision is arbitrarily increased.</source>
          <target state="translated">부동 소수점 계산은 부동 소수점 변수가 보유 할 수있는 것보다 더 높은 정밀도로 수행 될 수 있습니다. 정밀도가 임의로 증가하면 부동 소수점 알고리즘이 계속 제대로 작동해야합니다.</target>
        </trans-unit>
        <trans-unit id="cbc0ff66a82e332f74b6f7f08625c15927132156" translate="yes" xml:space="preserve">
          <source>Floating point constants are internally represented in the implementation in at least &lt;code&gt;real&lt;/code&gt; precision, regardless of the constant's type. The extra precision is available for constant folding. Committing to the precision of the result is done as late as possible in the compilation process. For example:</source>
          <target state="translated">부동 소수점 상수는 구현에서 상수 유형에 관계없이 최소한 &lt;code&gt;real&lt;/code&gt; 정밀도 로 내부적으로 표시됩니다 . 지속적인 접힘을 위해 추가 정밀도가 제공됩니다. 결과의 정확성에 대한 커밋은 컴파일 프로세스에서 가능한 한 늦게 수행됩니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="35c2559ddef9cb0435b556f187c76ca13d0d375f" translate="yes" xml:space="preserve">
          <source>Floating point numbers</source>
          <target state="translated">부동 소수점 숫자</target>
        </trans-unit>
        <trans-unit id="95bc83092a43ba79dea2ddad11b46e7cfef6083c" translate="yes" xml:space="preserve">
          <source>Floating point numerics functions.</source>
          <target state="translated">부동 소수점 숫자 기능.</target>
        </trans-unit>
        <trans-unit id="160661b47177ecb78c896bad472b47b4dfd37f9e" translate="yes" xml:space="preserve">
          <source>Floating point return values are returned on the FPU stack. These must be cleaned off by the caller, even if they are not used.</source>
          <target state="translated">부동 소수점 반환 값은 FPU 스택에 반환됩니다. 사용하지 않더라도 발신자가 청소해야합니다.</target>
        </trans-unit>
        <trans-unit id="33856b075b952fb87e57ad69006f9b871108ab99" translate="yes" xml:space="preserve">
          <source>Floating point types cannot be implicitly converted to integral types. Complex or imaginary floating point types cannot be implicitly converted to non-complex floating point types. Non-complex floating point types cannot be implicitly converted to imaginary floating point types.</source>
          <target state="translated">부동 소수점 유형은 암시 적으로 정수 유형으로 변환 될 수 없습니다. 복소수 또는 허수 부동 소수점 유형은 암시 적으로 비 복잡 부동 소수점 유형으로 변환 될 수 없습니다. 비 복합 부동 소수점 유형은 내재적으로 가상 부동 소수점 유형으로 변환 될 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="d3a01c245469b7e18ff38a92dc5c6ea9b1ec4c23" translate="yes" xml:space="preserve">
          <source>Floating-Point Number: (cfloat, cdouble, and creal) ['+'|'-']digit(s)[.][digit(s)][[e-|e+]digit(s)][+] [digit(s)[.][digit(s)][[e-|e+]digit(s)][i|f|L|Li|fi]] or [nan|nani|nan+nani|inf|-inf]</source>
          <target state="translated">부동 소수점 수 : (cfloat, cdouble 및 creal) [ '+'| '-'] 자리수 [.] [자리수] [[e- | e +] 자리수] [+] [자리 (들) [.] [자리 (들)] [[e- | e +] 자리] [i | f | L | Li | fi]] 또는 [nan | nani | nan + nani | inf | -inf]</target>
        </trans-unit>
        <trans-unit id="6d2316f26e5bf23de4ad985a49ccce2c80f4f913" translate="yes" xml:space="preserve">
          <source>Floating-Point Number: (float, double, real, ifloat, idouble, and ireal) ['+'|'-']digit(s)[.][digit(s)][[e-|e+]digit(s)][i|f|L|Li|fi]] or [nan|nani|inf|-inf]</source>
          <target state="translated">부동 소수점 수 : (float, double, real, ifloat, idouble 및 ireal) [ '+'| '-'] 자리수 [.] [자리수] [[e- | e +] 자리수 ( s)] [i | f | L | Li | fi]] 또는 [nan | nani | inf | -inf]</target>
        </trans-unit>
        <trans-unit id="4e439c8e69a24e7d54c5622205640014d4f59099" translate="yes" xml:space="preserve">
          <source>Floating-Point manipulation</source>
          <target state="translated">부동 소수점 조작</target>
        </trans-unit>
        <trans-unit id="417d3791f22357e1adf665e28ee4d505d124a89d" translate="yes" xml:space="preserve">
          <source>Floating-point operations</source>
          <target state="translated">부동 소수점 연산</target>
        </trans-unit>
        <trans-unit id="e0d24bd6f36291462113f127088f35f4090a373d" translate="yes" xml:space="preserve">
          <source>Floating-point random variate of type &lt;code&gt;T&lt;/code&gt; drawn from the uniform distribution across the half-open interval [0, 1).</source>
          <target state="translated">반 개방 구간 [0, 1)에 걸쳐 균일 한 분포에서 도출 된 유형 &lt;code&gt;T&lt;/code&gt; 의 부동 소수점 랜덤 변이입니다 .</target>
        </trans-unit>
        <trans-unit id="f2714b106a05319f2ace1ce68d8ac69bcf4f5ff7" translate="yes" xml:space="preserve">
          <source>Floating-point values are formatted like &lt;a href=&quot;core_stdc_stdio#printf&quot;&gt;&lt;code&gt;core.stdc.stdio.printf&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">부동 소수점 값은 &lt;a href=&quot;core_stdc_stdio#printf&quot;&gt; &lt;code&gt;core.stdc.stdio.printf&lt;/code&gt; &lt;/a&gt; 와 같은 형식입니다.</target>
        </trans-unit>
        <trans-unit id="c6b8da4fa90bdf05e2c05a6593125f02a7d82431" translate="yes" xml:space="preserve">
          <source>Floats can be in decimal or hexadecimal format.</source>
          <target state="translated">플로트는 10 진수 또는 16 진수 형식 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="aee4c734dc6fd3c7a89584d7e5348d40237e1949" translate="yes" xml:space="preserve">
          <source>Flush cookie jar to disk.</source>
          <target state="translated">쿠키 병을 디스크에 플러시하십시오.</target>
        </trans-unit>
        <trans-unit id="7f0c95d2e99f8f6f791a3dcf13701e05342006cc" translate="yes" xml:space="preserve">
          <source>Flushes the C &lt;code&gt;FILE&lt;/code&gt; buffers.</source>
          <target state="translated">C &lt;code&gt;FILE&lt;/code&gt; 버퍼를 플러시합니다 .</target>
        </trans-unit>
        <trans-unit id="bebb80c78ce429db39d79d68feeba680b58038de" translate="yes" xml:space="preserve">
          <source>Folding White Space contains consecutive CRLF sequences</source>
          <target state="translated">접는 공백에는 연속적인 CRLF 시퀀스가 ​​포함됩니다.</target>
        </trans-unit>
        <trans-unit id="67f0ed9d72f8298bdd413ec634b75103f7a22dc1" translate="yes" xml:space="preserve">
          <source>Folding White Space ends with a CRLF sequence</source>
          <target state="translated">접는 공백은 CRLF 시퀀스로 끝납니다.</target>
        </trans-unit>
        <trans-unit id="08097cc4ab9f5b9568ed73c27e3a597381bce1b4" translate="yes" xml:space="preserve">
          <source>Following arguments works the same way as &lt;code&gt;bitfield&lt;/code&gt;'s. The bitfield must fit into the bits known to be zero because of the pointer alignment.</source>
          <target state="translated">다음 인수는 &lt;code&gt;bitfield&lt;/code&gt; 와 같은 방식으로 작동합니다 . 포인터 정렬 때문에 비트 필드는 0으로 알려진 비트에 맞아야합니다.</target>
        </trans-unit>
        <trans-unit id="6cfe2219958a5948a49371cf65d64e832c75a6f7" translate="yes" xml:space="preserve">
          <source>Following initialization, the &lt;code&gt;HashTable&lt;/code&gt; object would consistently use its &lt;code&gt;allocator&lt;/code&gt; object for acquiring memory. Furthermore, setting &lt;code&gt;HashTable.allocator&lt;/code&gt; to point to a different allocator should be legal but only if the object is empty; otherwise, the object wouldn't be able to deallocate its existing state.</source>
          <target state="translated">초기화 후 &lt;code&gt;HashTable&lt;/code&gt; 개체는 메모리를 얻기 위해 &lt;code&gt;allocator&lt;/code&gt; 개체를 일관되게 사용합니다 . 또한 &lt;code&gt;HashTable.allocator&lt;/code&gt; 가 다른 할당자를 가리 키 도록 설정 하는 것은 합법적이지만 객체가 비어있는 경우에만 가능합니다. 그렇지 않으면 객체가 기존 상태를 할당 해제 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="c77938fcdf67aea78282407b90406b49eb71c3e5" translate="yes" xml:space="preserve">
          <source>Follows Itanium C++ ABI 1.86 section 5.1 &lt;a href=&quot;http://refspecs.linux-foundation.org/cxxabi-1.86.html#mangling&quot;&gt;http://refspecs.linux-foundation.org/cxxabi-1.86.html#mangling&lt;/a&gt; which is where the grammar comments come from.</source>
          <target state="translated">문법 주석의 출처 인 Itanium C ++ ABI 1.86 섹션 5.1 &lt;a href=&quot;http://refspecs.linux-foundation.org/cxxabi-1.86.html#mangling&quot;&gt;http://refspecs.linux-foundation.org/cxxabi-1.86.html#mangling&lt;/a&gt; 을 따릅니다 .</target>
        </trans-unit>
        <trans-unit id="f7880600348a091a43e2a84906d6002820643108" translate="yes" xml:space="preserve">
          <source>For</source>
          <target state="translated">For</target>
        </trans-unit>
        <trans-unit id="2496332383d78a1d33c27c0e38fa6de47dc78a49" translate="yes" xml:space="preserve">
          <source>For &quot;store&quot; operations of the form: op1 op= op2</source>
          <target state="translated">다음과 같은 형식의 &quot;저장&quot;조작의 경우 : op1 op = op2</target>
        </trans-unit>
        <trans-unit id="97c9b61a869134f6120476fe4a99b3b11a45291d" translate="yes" xml:space="preserve">
          <source>For 16 bit generator, this is always a (targ_short) sign-extended value.</source>
          <target state="translated">16 비트 생성기의 경우 항상 (targ_short) 부호 확장 값입니다.</target>
        </trans-unit>
        <trans-unit id="78b280836f07395eef32226ce729d39d05fd0d6b" translate="yes" xml:space="preserve">
          <source>For 64 bit code, follows Itanium C++ ABI 1.86 Chapter 3 &lt;a href=&quot;http://refspecs.linux-foundation.org/cxxabi-1.86.html#calls&quot;&gt;http://refspecs.linux-foundation.org/cxxabi-1.86.html#calls&lt;/a&gt;</source>
          <target state="translated">64 비트 코드의 경우 Itanium C ++ ABI 1.86 3 장 &lt;a href=&quot;http://refspecs.linux-foundation.org/cxxabi-1.86.html#calls&quot;&gt;http://refspecs.linux-foundation.org/cxxabi-1.86.html#calls를&lt;/a&gt; 따릅니다.</target>
        </trans-unit>
        <trans-unit id="b23dde54b23d16d77035a1e0e2b0833121f3ea89" translate="yes" xml:space="preserve">
          <source>For &lt;code&gt;++&lt;/code&gt; and &lt;code&gt;--&lt;/code&gt;, if &lt;code&gt;v == WithNaN.defaultValue!Lhs&lt;/code&gt; or the operation would result in an overflow, sets &lt;code&gt;v&lt;/code&gt; to &lt;code&gt;WithNaN.defaultValue!T&lt;/code&gt;. Otherwise, the semantics is the same as for the built-in operator.</source>
          <target state="translated">들어 &lt;code&gt;++&lt;/code&gt; 와 &lt;code&gt;--&lt;/code&gt; 경우 &lt;code&gt;v == WithNaN.defaultValue!Lhs&lt;/code&gt; 또는 작업이 오버 플로우가 발생할 것이다, 세트는 &lt;code&gt;v&lt;/code&gt; 에 에 &lt;code&gt;WithNaN.defaultValue!T&lt;/code&gt; . 그렇지 않으면 의미는 내장 연산자의 의미와 동일합니다.</target>
        </trans-unit>
        <trans-unit id="c0328592d323a259faf0da7a348a86fd52092b62" translate="yes" xml:space="preserve">
          <source>For &lt;code&gt;-&lt;/code&gt; and &lt;code&gt;~&lt;/code&gt;, if &lt;code&gt;v == WithNaN.defaultValue!T&lt;/code&gt;, returns &lt;code&gt;WithNaN.defaultValue!T&lt;/code&gt;. Otherwise, the semantics is the same as for the built-in operator.</source>
          <target state="translated">들어 &lt;code&gt;-&lt;/code&gt; 와 &lt;code&gt;~&lt;/code&gt; , 경우 &lt;code&gt;v == WithNaN.defaultValue!T&lt;/code&gt; , 반환 &lt;code&gt;WithNaN.defaultValue!T&lt;/code&gt; . 그렇지 않으면 의미는 내장 연산자의 의미와 동일합니다.</target>
        </trans-unit>
        <trans-unit id="4e56b23a72d6de96ffb1933a70486eb64d0dea7d" translate="yes" xml:space="preserve">
          <source>For &lt;code&gt;foreach&lt;/code&gt;, the elements for the array are iterated over starting at index 0 and continuing to the maximum of the array. For &lt;code&gt;foreach_reverse&lt;/code&gt;, the array elements are visited in the reverse order.</source>
          <target state="translated">들면 &lt;code&gt;foreach&lt;/code&gt; 는 상기 어레이의 요소는 인덱스 0에서 시작하여, 배열의 최대 지속 동안 반복된다. 들면 &lt;code&gt;foreach_reverse&lt;/code&gt; 배열 요소 역순 방문했다.</target>
        </trans-unit>
        <trans-unit id="d0ceede7c3735e19c4f9e84dfec5a98cdaa80c75" translate="yes" xml:space="preserve">
          <source>For &lt;code&gt;windowSize = 1&lt;/code&gt; it splits the range into single element groups (aka &lt;code&gt;unflatten&lt;/code&gt;) For &lt;code&gt;windowSize = 2&lt;/code&gt; it is similar to &lt;code&gt;zip(source, source.save.dropOne)&lt;/code&gt;.</source>
          <target state="translated">들면 &lt;code&gt;windowSize = 1&lt;/code&gt; 은 하나의 요소 그룹으로 영역 분할 (일명 &lt;code&gt;unflatten&lt;/code&gt; ) 용 &lt;code&gt;windowSize = 2&lt;/code&gt; 가 비슷 &lt;code&gt;zip(source, source.save.dropOne)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5fde640aa4409bbb47d5287c2ea78c26d39f59e9" translate="yes" xml:space="preserve">
          <source>For &lt;code&gt;x == &quot;++&quot; || x == &quot;--&quot;&lt;/code&gt;: The function returns &lt;code&gt;void&lt;/code&gt;.</source>
          <target state="translated">들어 &lt;code&gt;x == &quot;++&quot; || x == &quot;--&quot;&lt;/code&gt; :이 함수는 &lt;code&gt;void&lt;/code&gt; 를 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="f5ba5d0612e564fafee84b671c5c4d115f7c0b6e" translate="yes" xml:space="preserve">
          <source>For &lt;code&gt;x == &quot;-&quot; || x == &quot;~&quot;&lt;/code&gt;: If &lt;code&gt;v == WithNaN.defaultValue!T&lt;/code&gt;, the function returns &lt;code&gt;WithNaN.defaultValue!T&lt;/code&gt;. Otherwise it returns the normal result of the operator.</source>
          <target state="translated">를 들어 &lt;code&gt;x == &quot;-&quot; || x == &quot;~&quot;&lt;/code&gt; : &lt;code&gt;v == WithNaN.defaultValue!T&lt;/code&gt; 인 경우 함수는 &lt;code&gt;WithNaN.defaultValue!T&lt;/code&gt; 반환합니다 . 그렇지 않으면 연산자의 정상적인 결과를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="d465e34c13d15e0333f8cd7f1c7c1944ae2b7911" translate="yes" xml:space="preserve">
          <source>For C++ class cd, generate an instance of _cpp_type_info_ptr and populate it with a pointer to the C++ type info.</source>
          <target state="translated">C ++ 클래스 cd의 경우 _cpp_type_info_ptr의 인스턴스를 생성하고 C ++ 유형 정보에 대한 포인터로 채 웁니다.</target>
        </trans-unit>
        <trans-unit id="84fc2ed3d82dfac4fe4b1db7e54128df57816954" translate="yes" xml:space="preserve">
          <source>For Posix/x86_64 this returns the type which will really be used for passing an argument of type va_list.</source>
          <target state="translated">Posix / x86_64의 경우 va_list 유형의 인수를 전달하는 데 실제로 사용될 유형을 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="826bad097a9af03241478f133b816c28a093c4ff" translate="yes" xml:space="preserve">
          <source>For Statement</source>
          <target state="translated">성명</target>
        </trans-unit>
        <trans-unit id="1658d59f02098b291dd70d6afbe72baf35b0b46e" translate="yes" xml:space="preserve">
          <source>For TypeFunction, nextOf() can return NULL if the function return type is meant to be inferred, and semantic() hasn't yet ben run on the function. After semantic(), it must no longer be NULL.</source>
          <target state="translated">TypeFunction의 경우 함수 반환 유형이 유추되고 semantic ()이 아직 함수에서 실행되지 않은 경우 nextOf ()는 NULL을 반환 할 수 있습니다. semantic () 이후에는 더 이상 NULL이 아니어야합니다.</target>
        </trans-unit>
        <trans-unit id="ed4c1eb6664e08f8534b1fe769460ebc44281875" translate="yes" xml:space="preserve">
          <source>For a lazy version, refer to &lt;a href=&quot;std_range#repeat&quot;&gt;&lt;code&gt;std.range.repeat&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">게으른 버전은 &lt;a href=&quot;std_range#repeat&quot;&gt; &lt;code&gt;std.range.repeat&lt;/code&gt; 를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="8cd7374ae5703f87c90badd0385e4fb829226681" translate="yes" xml:space="preserve">
          <source>For a lazy version, see &lt;a href=&quot;std_algorithm_iteration#joiner&quot;&gt;&lt;code&gt;std.algorithm.iteration.joiner&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">게으른 버전에 대해서는 &lt;a href=&quot;std_algorithm_iteration#joiner&quot;&gt; &lt;code&gt;std.algorithm.iteration.joiner&lt;/code&gt; 를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="20ca13cf71a91c26b14ec6bf15dd84151e56cf9e" translate="yes" xml:space="preserve">
          <source>For a lazy, non-allocating version of these functions, see &lt;a href=&quot;#byUTF&quot;&gt;&lt;code&gt;byUTF&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이러한 함수의 게으르고 할당되지 않은 버전은 &lt;a href=&quot;#byUTF&quot;&gt; &lt;code&gt;byUTF&lt;/code&gt; 를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="567c03cab3251ca5dd2f65be01f597e8de5b789b" translate="yes" xml:space="preserve">
          <source>For a less strict parser, see &lt;a href=&quot;#parseUUID&quot;&gt;&lt;code&gt;parseUUID&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">덜 엄격한 파서는 &lt;a href=&quot;#parseUUID&quot;&gt; &lt;code&gt;parseUUID&lt;/code&gt; 를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="32cf17cd505298c5983970817a14f4d4aa02e1a3" translate="yes" xml:space="preserve">
          <source>For a size zero pool, the getter arbitrarily returns &lt;code&gt;core.thread.Thread.PRIORITY_MIN&lt;/code&gt; and the setter has no effect.</source>
          <target state="translated">크기가 0 인 풀의 경우 getter는 임의로 &lt;code&gt;core.thread.Thread.PRIORITY_MIN&lt;/code&gt; 을 반환 하며 setter는 영향을 미치지 않습니다.</target>
        </trans-unit>
        <trans-unit id="703bdcc05cee4b856a950e3e2494d43650695c33" translate="yes" xml:space="preserve">
          <source>For a size zero pool, the getter arbitrarily returns true and the setter has no effect.</source>
          <target state="translated">크기가 0 인 풀의 경우 getter는 임의로 true를 반환하고 setter는 영향을 미치지 않습니다.</target>
        </trans-unit>
        <trans-unit id="7062424b6df58f7b0070477aac1caffce7eac347" translate="yes" xml:space="preserve">
          <source>For all assign expressions, the left operand must be a modifiable lvalue. The type of the assign expression is the type of the left operand, and the value is the value of the left operand after assignment occurs. The resulting expression is a modifiable lvalue.</source>
          <target state="translated">모든 대입 식에 대해 왼쪽 피연산자는 수정 가능한 lvalue 여야합니다. 어사 인 표현식의 유형은 왼쪽 피연산자의 유형이며 값은 대입이 발생한 후 왼쪽 피연산자의 값입니다. 결과 표현식은 수정 가능한 lvalue입니다.</target>
        </trans-unit>
        <trans-unit id="4c1c5870b4b89a912a0f2d752c3a6fab5551a649" translate="yes" xml:space="preserve">
          <source>For all other cases, the temporaries generated for the purpose of invoking functions are deferred to the end of the full expression. The order of destruction is inverse to the order of construction.</source>
          <target state="translated">다른 모든 경우에 함수를 호출하기 위해 생성 된 임시는 전체 표현식의 끝으로 연기됩니다. 파괴의 순서는 건설 순서와 반대입니다.</target>
        </trans-unit>
        <trans-unit id="95e2e0ca2da36fd3882b011dd82190d8d5ee7297" translate="yes" xml:space="preserve">
          <source>For an introductory look at &lt;b&gt;std.format&lt;/b&gt;'s capabilities and how to use this module see the dedicated &lt;a href=&quot;http://wiki.dlang.org/Defining_custom_print_format_specifiers&quot;&gt;DWiki article&lt;/a&gt;.</source>
          <target state="translated">&lt;b&gt;std.format&lt;/b&gt; 의 기능과이 모듈을 사용하는 방법에 대한 소개 는 전용 &lt;a href=&quot;http://wiki.dlang.org/Defining_custom_print_format_specifiers&quot;&gt;DWiki 기사를 참조하십시오&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="076ae6cb1419d1feff35ba4b7e6bb266176337c6" translate="yes" xml:space="preserve">
          <source>For another example:</source>
          <target state="translated">다른 예를 들면 :</target>
        </trans-unit>
        <trans-unit id="4f7c5dea21579ef43f50bda4d8b8e7dd5ee9236e" translate="yes" xml:space="preserve">
          <source>For any given platform/compiler curl_off_t must be typedef'ed to a 64-bit wide signed integral data type. The width of this data type must remain constant and independent of any possible large file support settings.</source>
          <target state="translated">주어진 플랫폼 / 컴파일러의 경우 curl_off_t는 64 비트의 부호있는 정수 데이터 유형으로 typedef되어야합니다. 이 데이터 유형의 너비는 일정하고 가능한 큰 파일 지원 설정과 무관하게 유지되어야합니다.</target>
        </trans-unit>
        <trans-unit id="078912245b32cd2a66bf3a96da7307acc2485fbe" translate="yes" xml:space="preserve">
          <source>For any other declaration even if &lt;code&gt;@disable&lt;/code&gt; is a syntactically valid attribute &lt;code&gt;false&lt;/code&gt; is returned because the annotation has no effect.</source>
          <target state="translated">&lt;code&gt;@disable&lt;/code&gt; 이 구문 상 유효한 속성 인 경우에도 다른 선언의 경우 주석이 적용되지 않으므로 &lt;code&gt;false&lt;/code&gt; 가 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="701d1a14380c65e4a855899951d9d7a65d27e60f" translate="yes" xml:space="preserve">
          <source>For any values &lt;code&gt;v1&lt;/code&gt; on the right-hand side and &lt;code&gt;v2&lt;/code&gt; on the left-hand side:</source>
          <target state="translated">오른쪽의 &lt;code&gt;v1&lt;/code&gt; 값 과 왼쪽의 &lt;code&gt;v2&lt;/code&gt; 값 :</target>
        </trans-unit>
        <trans-unit id="f1e77f1044f99821b0b2c5cfb9d3d37a079ad5ec" translate="yes" xml:space="preserve">
          <source>For applications like command line switch processing, this can lead to much more straightforward code, being clearer and less error prone. char, wchar and dchar strings are allowed.</source>
          <target state="translated">명령 줄 스위치 처리와 같은 응용 프로그램의 경우 훨씬 더 간단한 코드를 사용하여보다 명확하고 오류 발생이 줄어 듭니다. char, wchar 및 dchar 문자열이 허용됩니다.</target>
        </trans-unit>
        <trans-unit id="d1b8d2445b680cd8ee27f3fc95623cb30af7a286" translate="yes" xml:space="preserve">
          <source>For arguments of built-in types, assignment operator expressions such as</source>
          <target state="translated">내장 유형의 인수의 경우 다음과 같은 대입 연산자 표현식</target>
        </trans-unit>
        <trans-unit id="0f5d29eff2633e7fd841d0a6738a98ac739e92a9" translate="yes" xml:space="preserve">
          <source>For arrays:</source>
          <target state="translated">배열의 경우 :</target>
        </trans-unit>
        <trans-unit id="dc14ba04c2c4629e1d2d0d30f5dc9d2a1dddd9e2" translate="yes" xml:space="preserve">
          <source>For backward compatibility, &lt;code&gt;a[]&lt;/code&gt; and &lt;code&gt;a[&lt;/code&gt;</source>
          <target state="translated">이전 버전과의 호환성을 &lt;code&gt;a[]&lt;/code&gt; 및 &lt;code&gt;a[&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="542878137297059fb68730fd24d9158d8fdb95d5" translate="yes" xml:space="preserve">
          <source>For backward compatibility, &lt;code&gt;multiwayMerge&lt;/code&gt; is available under the name &lt;code&gt;nWayUnion&lt;/code&gt; and &lt;code&gt;MultiwayMerge&lt;/code&gt; under the name of &lt;code&gt;NWayUnion&lt;/code&gt; . Future code should use &lt;code&gt;multiwayMerge&lt;/code&gt; and &lt;code&gt;MultiwayMerge&lt;/code&gt; as &lt;code&gt;nWayUnion&lt;/code&gt; and &lt;code&gt;NWayUnion&lt;/code&gt; will be deprecated.</source>
          <target state="translated">이전 버전과의 호환성을 위해 &lt;code&gt;multiwayMerge&lt;/code&gt; 는 이름에서 볼 수 있습니다 &lt;code&gt;nWayUnion&lt;/code&gt; 및 &lt;code&gt;MultiwayMerge&lt;/code&gt; 의 이름으로 &lt;code&gt;NWayUnion&lt;/code&gt; . 미래의 코드를 사용해야 &lt;code&gt;multiwayMerge&lt;/code&gt; 및 &lt;code&gt;MultiwayMerge&lt;/code&gt; 을 같이 &lt;code&gt;nWayUnion&lt;/code&gt; 및 &lt;code&gt;NWayUnion&lt;/code&gt; 는 더 이상 사용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="e3a3c169dbbfe63cc4460a15c98153cda1f6881e" translate="yes" xml:space="preserve">
          <source>For backward compatibility, if rewriting &lt;code&gt;a[&lt;/code&gt;</source>
          <target state="translated">호환성을 위해, 경우에 재기록 &lt;code&gt;a[&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="92276f55c3cccb89a03bd28b0c6443429cb6df1c" translate="yes" xml:space="preserve">
          <source>For backward compatibility, if the above rewrites fail and &lt;code&gt;opSliceOpAssign&lt;/code&gt; is defined, then the rewrites &lt;code&gt;a.opSliceOpAssign(c, i, j)&lt;/code&gt; and &lt;code&gt;a.opSliceOpAssign(c)&lt;/code&gt; are tried, respectively.</source>
          <target state="translated">이전 버전과의 호환성을 위해 위의 다시 &lt;code&gt;opSliceOpAssign&lt;/code&gt; 가 실패하고 opSliceOpAssign 이 정의 된 경우 다시 &lt;code&gt;a.opSliceOpAssign(c, i, j)&lt;/code&gt; 및 &lt;code&gt;a.opSliceOpAssign(c)&lt;/code&gt; 가 각각 시도됩니다.</target>
        </trans-unit>
        <trans-unit id="e5a6a2446de90976e232d13603325c19c48a5a94" translate="yes" xml:space="preserve">
          <source>For backward compatibility, if the above rewrites fail to compile and &lt;code&gt;opSliceUnary&lt;/code&gt; is defined, then the rewrites &lt;code&gt;a.opSliceUnary!(op)(i, j)&lt;/code&gt; and &lt;code&gt;a.opSliceUnary!(op)&lt;/code&gt; are tried instead, respectively.</source>
          <target state="translated">이전 버전과의 호환성을 위해 위의 다시 &lt;code&gt;opSliceUnary&lt;/code&gt; 가 컴파일되지 않고 opSliceUnary 가 정의 된 경우 다시 &lt;code&gt;a.opSliceUnary!(op)(i, j)&lt;/code&gt; 및 &lt;code&gt;a.opSliceUnary!(op)&lt;/code&gt; 가 각각 대신 시도됩니다.</target>
        </trans-unit>
        <trans-unit id="757d4d7a3dccc207f58716a0eadde379a304a5d2" translate="yes" xml:space="preserve">
          <source>For binary operators, the result is as follows:</source>
          <target state="translated">이진 연산자의 경우 결과는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="aeea5f41f2c7d1bd01e14aae86afc3b17192c6d2" translate="yes" xml:space="preserve">
          <source>For blocks &amp;gt;= pagesize, the length is a size_t and is at the beginning of the block. The reason we have to do this is because the block can extend into more pages, so we cannot trust the block length if it sits at the end of the block, because it might have just been extended. If we can prove in the future that the block is unshared, we may be able to change this, but I'm not sure it's important.</source>
          <target state="translated">블록&amp;gt; = pagesize의 경우 길이는 size_t이며 블록의 시작 부분에 있습니다. 우리가 해야하는 이유는 블록이 더 많은 페이지로 확장 될 수 있기 때문에 블록의 길이가 블록의 끝에 있으면 블록 길이가 확장되었을 수 있기 때문에 블록 길이를 신뢰할 수 없기 때문입니다. 나중에 블록이 공유되지 않았다는 것을 증명할 수 있으면이를 변경할 수 있지만 중요하지는 않습니다.</target>
        </trans-unit>
        <trans-unit id="6435d22c869fa126d1d0aea9e7983183ab7f918e" translate="yes" xml:space="preserve">
          <source>For both ++i and --i</source>
          <target state="translated">++ i 및 --i 모두</target>
        </trans-unit>
        <trans-unit id="93107872cedc76cc5719158670858cf146f5ce57" translate="yes" xml:space="preserve">
          <source>For both i++ and i--</source>
          <target state="translated">i ++와 i--</target>
        </trans-unit>
        <trans-unit id="c2f1745a5232cce644154e5a3850452a31978021" translate="yes" xml:space="preserve">
          <source>For both overloads, the entire value of the Duration is split among the units (rather than splitting the Duration across all units and then only providing the values for the requested units), so if only one unit is given, the result is equivalent to &lt;a href=&quot;#total&quot;&gt;&lt;code&gt;total&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">두 과부하 모두, Duration의 전체 값은 모든 Unit에 Duration을 분할 한 다음 요청 된 Unit에 대한 값만 제공하는 것이 아니라 Unit간에 분할되므로 하나의 Unit 만 제공하면 결과는 &lt;a href=&quot;#total&quot;&gt; &lt;code&gt;total&lt;/code&gt; &lt;/a&gt; 과 같습니다. .</target>
        </trans-unit>
        <trans-unit id="ad0f0aabfe7ebb013586fcfb45b89ab392324a84" translate="yes" xml:space="preserve">
          <source>For built-in numerical types, accurate Knuth &amp;amp; Welford mean calculation is used. For user-defined types, element by element summation is used. Additionally an extra parameter &lt;code&gt;seed&lt;/code&gt; is needed in order to correctly seed the summation with the equivalent to &lt;code&gt;0&lt;/code&gt;.</source>
          <target state="translated">내장 숫자 유형의 경우 정확한 Knuth &amp;amp; Welford 평균 계산이 사용됩니다. 사용자 정의 유형의 경우 요소 별 요약이 사용됩니다. 또한 &lt;code&gt;0&lt;/code&gt; 과 동등한 합계를 올바르게 시드하려면 추가 매개 변수 &lt;code&gt;seed&lt;/code&gt; 가 필요합니다 .</target>
        </trans-unit>
        <trans-unit id="a4cc9dd81eb95c3553b97b6dbcaf73ca851ceabc" translate="yes" xml:space="preserve">
          <source>For calendar-based operations that don't care about time zones, then &lt;a href=&quot;std_datetime_date#DateTime&quot;&gt;&lt;code&gt;std.datetime.date.DateTime&lt;/code&gt;&lt;/a&gt; would be the type to use. For system time, use &lt;code&gt;SysTime&lt;/code&gt;.</source>
          <target state="translated">시간대를 신경 쓰지 않는 달력 기반 작업의 경우 &lt;a href=&quot;std_datetime_date#DateTime&quot;&gt; &lt;code&gt;std.datetime.date.DateTime&lt;/code&gt; &lt;/a&gt; 이 사용되는 유형입니다. 시스템 시간의 경우 &lt;code&gt;SysTime&lt;/code&gt; 을 사용 하십시오 .</target>
        </trans-unit>
        <trans-unit id="b7199c84f095b28abf14901a280827544df19151" translate="yes" xml:space="preserve">
          <source>For cases where the encoding is known at compile-time, functions are provided for arbitrary encoding and decoding of characters, arbitrary transcoding between strings of different type, as well as validation and sanitization.</source>
          <target state="translated">컴파일 타임에 인코딩이 알려진 경우, 문자의 임의 인코딩 및 디코딩, 다른 유형의 문자열 간 임의의 트랜스 코딩, 유효성 검증 및 살균을위한 기능이 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="a53a545de095bd4f4e296c839d801de6e744e030" translate="yes" xml:space="preserve">
          <source>For cases where the encoding is not known at compile-time, but is known at run-time, the abstract class &lt;a href=&quot;#EncodingScheme&quot;&gt;&lt;code&gt;EncodingScheme&lt;/code&gt;&lt;/a&gt; and its subclasses is provided. To construct a run-time encoder/decoder, one does e.g.</source>
          <target state="translated">컴파일 타임에는 인코딩은 없지만 런타임에는 &lt;a href=&quot;#EncodingScheme&quot;&gt; &lt;code&gt;EncodingScheme&lt;/code&gt; &lt;/a&gt; 있는 경우 추상 클래스 EncodingScheme 및 해당 서브 클래스가 제공됩니다. 런타임 인코더 / 디코더를 구성하기 위해 다음과 같은 작업을 수행합니다.</target>
        </trans-unit>
        <trans-unit id="d53cba26ee6cdc76a4ea74c67f57bac33bebf848" translate="yes" xml:space="preserve">
          <source>For class and struct objects, the expression &lt;code&gt;(a == b)&lt;/code&gt; is rewritten as &lt;code&gt;a.opEquals(b)&lt;/code&gt;, and &lt;code&gt;(a != b)&lt;/code&gt; is rewritten as &lt;code&gt;!a.opEquals(b)&lt;/code&gt;.</source>
          <target state="translated">클래스 및 구조체 객체의 경우 &lt;code&gt;(a == b)&lt;/code&gt; 표현식 은 &lt;code&gt;a.opEquals(b)&lt;/code&gt; 로 다시 작성 되고 &lt;code&gt;(a != b)&lt;/code&gt; 는 &lt;code&gt;!a.opEquals(b)&lt;/code&gt; 로 다시 작성됩니다 .</target>
        </trans-unit>
        <trans-unit id="a6164499db4fd6a0a2e064668be7de8146561558" translate="yes" xml:space="preserve">
          <source>For class objects, identity is defined as the object references are for the same object. Null class objects can be compared with &lt;code&gt;is&lt;/code&gt;.</source>
          <target state="translated">클래스 객체의 경우 객체 참조가 동일한 객체에 대한 것이므로 아이디가 정의됩니다. null 클래스 객체는 &lt;code&gt;is&lt;/code&gt; 와 비교할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="95c093eaf464e50c213285367cf108a1f21af7e6" translate="yes" xml:space="preserve">
          <source>For class objects, the &lt;code&gt;==&lt;/code&gt; and &lt;code&gt;!=&lt;/code&gt; operators are intended to compare the contents of the objects, however an appropriate &lt;code&gt;opEquals&lt;/code&gt; override must be defined for this to work. The default &lt;code&gt;opEquals&lt;/code&gt; provided by the root &lt;code&gt;Object&lt;/code&gt; class is equivalent to the &lt;code&gt;is&lt;/code&gt; operator. Comparing against &lt;code&gt;null&lt;/code&gt; is invalid, as &lt;code&gt;null&lt;/code&gt; has no contents. Use the &lt;code&gt;is&lt;/code&gt; and &lt;code&gt;!is&lt;/code&gt; operators instead.</source>
          <target state="translated">클래스 객체의 경우 &lt;code&gt;==&lt;/code&gt; 및 &lt;code&gt;!=&lt;/code&gt; 연산자는 객체의 내용을 비교하기위한 것이지만 이를 위해서는 적절한 &lt;code&gt;opEquals&lt;/code&gt; 재정의를 정의해야합니다. 루트 &lt;code&gt;Object&lt;/code&gt; 클래스 에서 제공하는 기본 &lt;code&gt;opEquals&lt;/code&gt; 는 &lt;code&gt;is&lt;/code&gt; 연산자 와 같습니다 . 에 대해 비교 &lt;code&gt;null&lt;/code&gt; 같은 유효하지 않은 &lt;code&gt;null&lt;/code&gt; 어떤 내용이 없습니다. (가) 사용 &lt;code&gt;is&lt;/code&gt; 와 &lt;code&gt;!is&lt;/code&gt; 대신 운영자.</target>
        </trans-unit>
        <trans-unit id="d5b1405cc3330cccfdcfd53a468de428485e9157" translate="yes" xml:space="preserve">
          <source>For class objects, the relational operators compare the contents of the objects. Therefore, comparing against &lt;code&gt;null&lt;/code&gt; is invalid, as &lt;code&gt;null&lt;/code&gt; has no contents.</source>
          <target state="translated">클래스 객체의 경우 관계 연산자는 객체의 내용을 비교합니다. 따라서,에 대한 비교 &lt;code&gt;null&lt;/code&gt; 등, 무효 &lt;code&gt;null&lt;/code&gt; 에 내용이 없습니다.</target>
        </trans-unit>
        <trans-unit id="ab366bbd1fd34ad6f5b2cd340e858e3c25d5bb75" translate="yes" xml:space="preserve">
          <source>For class objects, the result of Object.opCmp() forms the left operand, and 0 forms the right operand. The result of the relational expression (o1 op o2) is:</source>
          <target state="translated">클래스 객체의 경우 Object.opCmp ()의 결과는 왼쪽 피연산자를 형성하고 0은 오른쪽 피연산자를 형성합니다. 관계식 (o1 op o2)의 결과는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="e894f77d4bc27bedbf87e79de7b7a21550ebd3e1" translate="yes" xml:space="preserve">
          <source>For class objects:</source>
          <target state="translated">클래스 객체의 경우 :</target>
        </trans-unit>
        <trans-unit id="6ae638739525d1c55b35c525b46eec46d1197fc5" translate="yes" xml:space="preserve">
          <source>For completeness a level 1 trie is simply an array. The current implementation takes advantage of bit-packing values when the range is known to be limited in advance (such as &lt;code&gt;bool&lt;/code&gt;). See also &lt;a href=&quot;#BitPacked&quot;&gt;&lt;code&gt;BitPacked&lt;/code&gt;&lt;/a&gt; for enforcing it manually. The major size advantage however comes from the fact that multiple &lt;b&gt;identical pages on every level are merged&lt;/b&gt; by construction.</source>
          <target state="translated">완전성을 위해 레벨 1 트리는 단순히 배열입니다. 현재 구현에서는 범위가 미리 제한되어있는 것으로 알려진 경우 (예 : &lt;code&gt;bool&lt;/code&gt; ) 비트 패킹 값을 활용 합니다. 수동으로 적용 &lt;a href=&quot;#BitPacked&quot;&gt; &lt;code&gt;BitPacked&lt;/code&gt; &lt;/a&gt; 를 참조하십시오 . 그러나 주요한 크기 이점 &lt;b&gt;은 모든 수준에서&lt;/b&gt; 여러 &lt;b&gt;동일한 페이지&lt;/b&gt; 가 구성에 의해 &lt;b&gt;병합&lt;/b&gt; 된다는 사실에서 비롯됩니다 .</target>
        </trans-unit>
        <trans-unit id="8ebdc89d7f40766ce711349010ffd3cd409b6e68" translate="yes" xml:space="preserve">
          <source>For complex numbers, equality is defined as equivalent to:</source>
          <target state="translated">복소수의 경우, 평등은 다음과 같은 것으로 정의됩니다.</target>
        </trans-unit>
        <trans-unit id="c92d80178cde078393b89e6d6a1bab596929a28f" translate="yes" xml:space="preserve">
          <source>For consistency and predictability, there are several standard sections. None of these are required to be present.</source>
          <target state="translated">일관성과 예측 성을 위해 몇 가지 표준 섹션이 있습니다. 이들 중 어느 것도 존재하지 않아도됩니다.</target>
        </trans-unit>
        <trans-unit id="b5df2d0a44db277a01e403815ff3d6ffbf0a4688" translate="yes" xml:space="preserve">
          <source>For console programs, &lt;code&gt;main()&lt;/code&gt; serves as the entry point. It gets called after all the module initializers are run, and after any unittests are run. After it returns, all the module destructors are run. &lt;code&gt;main()&lt;/code&gt; must be declared using one of the following forms:</source>
          <target state="translated">콘솔 프로그램의 경우 &lt;code&gt;main()&lt;/code&gt; 이 진입 점 역할을합니다. 모든 모듈 이니셜 라이저가 실행 된 후 그리고 단위 테스트가 실행 된 후에 호출됩니다. 돌아온 후 모든 모듈 소멸자가 실행됩니다. &lt;code&gt;main()&lt;/code&gt; 은 다음 형식 중 하나를 사용하여 선언해야합니다.</target>
        </trans-unit>
        <trans-unit id="a87a16b2108087eba4cfd4c27e06f2199e9c9ea6" translate="yes" xml:space="preserve">
          <source>For convenience</source>
          <target state="translated">편의상</target>
        </trans-unit>
        <trans-unit id="c28923eb8e6fce56c97d1e69a2459b17db795a95" translate="yes" xml:space="preserve">
          <source>For convenience, if the seed is const, or has qualified fields, then &lt;code&gt;reduce&lt;/code&gt; will operate on an unqualified copy. If this happens then the returned type will not perfectly match &lt;code&gt;S&lt;/code&gt;.</source>
          <target state="translated">편의상 시드가 const이거나 규정 된 필드가있는 경우 &lt;code&gt;reduce&lt;/code&gt; 는 규정되지 않은 사본에서 작동합니다. 이 경우 반환 된 형식은 &lt;code&gt;S&lt;/code&gt; 와 완벽하게 일치하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="db55a017e4d8880bceaa15cbff12d8e02dda2446" translate="yes" xml:space="preserve">
          <source>For convenience, this module publicly imports &lt;a href=&quot;core_time&quot;&gt;&lt;code&gt;core.time&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">편의상이 모듈은 공개적으로 &lt;a href=&quot;core_time&quot;&gt; &lt;code&gt;core.time&lt;/code&gt; 을&lt;/a&gt; 가져 옵니다 .</target>
        </trans-unit>
        <trans-unit id="0750ffdd6d85bc11bd3ef50c265df606e3d06eba" translate="yes" xml:space="preserve">
          <source>For conversion of strings to signed types, the grammar recognized is:</source>
          <target state="translated">문자열을 부호있는 유형으로 변환하는 경우 인식되는 문법은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="6d295d9ab6e17239455a68d95e6a9009da2b2b99" translate="yes" xml:space="preserve">
          <source>For conversion to unsigned types, the grammar recognized is:</source>
          <target state="translated">부호없는 유형으로 변환하는 경우 인식되는 문법은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="7cbf49f210f0c77ac5cb0d36bff7e0a64b475c82" translate="yes" xml:space="preserve">
          <source>For correct comparisons, returns a positive integer if &lt;code&gt;lhs &amp;gt; rhs&lt;/code&gt;, a negative integer if &lt;code&gt;lhs &amp;lt; rhs&lt;/code&gt;, &lt;code&gt;0&lt;/code&gt; if the two are equal.</source>
          <target state="translated">올바른 비교를 위해 &lt;code&gt;lhs &amp;gt; rhs&lt;/code&gt; 인 경우 양의 정수를, &lt;code&gt;lhs &amp;lt; rhs&lt;/code&gt; 인 경우 음의 정수를 , 두 값이 같은 경우 &lt;code&gt;0&lt;/code&gt; 을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="3eb5e30aca486d38067e5e0193c4b1bb0345617f" translate="yes" xml:space="preserve">
          <source>For correct comparisons, returns a positive integer if &lt;code&gt;lhs &amp;gt; rhs&lt;/code&gt;, a negative integer if &lt;code&gt;lhs &amp;lt; rhs&lt;/code&gt;, &lt;code&gt;0&lt;/code&gt; if the two are equal. Upon a mistaken comparison such as &lt;code&gt;int(-1) &amp;lt; uint(0)&lt;/code&gt;, the function never returns because it aborts the program.</source>
          <target state="translated">올바른 비교를 위해 &lt;code&gt;lhs &amp;gt; rhs&lt;/code&gt; 인 경우 양의 정수를, &lt;code&gt;lhs &amp;lt; rhs&lt;/code&gt; 인 경우 음의 정수를 , 두 값이 같은 경우 &lt;code&gt;0&lt;/code&gt; 을 반환합니다. &lt;code&gt;int(-1) &amp;lt; uint(0)&lt;/code&gt; 과 같은 비교가 잘못되면 함수가 프로그램을 중단하기 때문에 반환되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="fa11ef91f282359e697ab411a2105694aa1fc413" translate="yes" xml:space="preserve">
          <source>For debuggers that can be modified to accept new types, the following extensions help them fully support the types.</source>
          <target state="translated">새 유형을 허용하도록 수정 될 수있는 디버거의 경우 다음 확장은 유형을 완전히 지원하는 데 도움이됩니다.</target>
        </trans-unit>
        <trans-unit id="63e9558b3c028e1d9a23d1722de151ab9342540d" translate="yes" xml:space="preserve">
          <source>For dynamic array and object parameters, which are passed by reference, in/out/ref apply only to the reference and not the contents.</source>
          <target state="translated">참조로 전달되는 동적 배열 및 객체 매개 변수의 경우, 입 / 출력 / 참조는 내용이 아닌 참조에만 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="26ffddfdbc1c41c2be1034e80310b3f852b74078" translate="yes" xml:space="preserve">
          <source>For each active attribute (ref/const/nogc/etc) call &lt;code&gt;fp&lt;/code&gt; with a void* for the work param and a string representation of the attribute.</source>
          <target state="translated">각 활성 속성 (ref / const / nogc / etc) 에 대해 작업 매개 변수에 대해 void *와 속성의 문자열 표시를 사용하여 &lt;code&gt;fp&lt;/code&gt; 를 호출 하십시오.</target>
        </trans-unit>
        <trans-unit id="8eea3bce7669308b1434c353731e136dc4b97c1c" translate="yes" xml:space="preserve">
          <source>For each active modifier (MODFlags.const_, MODFlags.immutable_, etc) call &lt;code&gt;fp&lt;/code&gt; with a void* for the work param and a string representation of the attribute.</source>
          <target state="translated">각 활성 수정 자 (MODFlags.const_, MODFlags.immutable_ 등) 에 대해 작업 매개 변수 및 속성의 문자열 표시에 대해 void *와 함께 &lt;code&gt;fp&lt;/code&gt; 를 호출 하십시오.</target>
        </trans-unit>
        <trans-unit id="3203682624a9b4a1635c6de69e488d06fa56e15c" translate="yes" xml:space="preserve">
          <source>For each evaluation that yields a temporary value, the lifetime of that temporary begins at the evaluation point, similarly to creation of a usual named value initialized with an expression.</source>
          <target state="translated">임시 값을 산출하는 각 평가에 대해, 해당 임시의 수명은 표현식으로 초기화 된 일반적인 명명 된 값을 작성하는 것과 유사하게 평가 지점에서 시작됩니다.</target>
        </trans-unit>
        <trans-unit id="5f7caa6316d56bf976ab623e5dd0b440be2fe098" translate="yes" xml:space="preserve">
          <source>For each function &lt;code&gt;f&lt;/code&gt; in &lt;code&gt;fun&lt;/code&gt;, the corresponding seed type &lt;code&gt;S&lt;/code&gt; is &lt;code&gt;Unqual!(typeof(f(e, e)))&lt;/code&gt;, where &lt;code&gt;e&lt;/code&gt; is an element of &lt;code&gt;r&lt;/code&gt;: &lt;code&gt;ElementType!R&lt;/code&gt; for ranges, and &lt;code&gt;ForeachType!R&lt;/code&gt; otherwise.</source>
          <target state="translated">&lt;code&gt;fun&lt;/code&gt; 의 각 함수 &lt;code&gt;f&lt;/code&gt; 에 대해 해당 시드 유형 &lt;code&gt;S&lt;/code&gt; 는 &lt;code&gt;Unqual!(typeof(f(e, e)))&lt;/code&gt; . 여기서 &lt;code&gt;e&lt;/code&gt; 는 범위에 대한 &lt;code&gt;r&lt;/code&gt; : &lt;code&gt;ElementType!R&lt;/code&gt; &lt;code&gt;ForeachType!R&lt;/code&gt; 그렇지 않으면 ForeachType! R 입니다.</target>
        </trans-unit>
        <trans-unit id="89f96ba2b9022471ac4b3f99072ac57893d52c5d" translate="yes" xml:space="preserve">
          <source>For each function that has exception handlers, an EH table entry is generated.</source>
          <target state="translated">예외 핸들러가있는 각 함수에 대해 EH 테이블 항목이 생성됩니다.</target>
        </trans-unit>
        <trans-unit id="c170bc5a2dcbb7f263f34807c28c73343f6168e3" translate="yes" xml:space="preserve">
          <source>For each template parameter, the following rules are applied in order until a type is deduced for each parameter:</source>
          <target state="translated">각 템플릿 매개 변수에 대해 각 매개 변수에 대해 유형이 추론 될 때까지 다음 규칙이 순서대로 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="de2d36eb496ad6425d4fddf01b0f74d4997c1c21" translate="yes" xml:space="preserve">
          <source>For each type &lt;code&gt;T&lt;/code&gt; on the left-hand side and each type &lt;code&gt;U&lt;/code&gt; on the right-hand side, values of type &lt;code&gt;T&lt;/code&gt; can be compared with values of type &lt;code&gt;U&lt;/code&gt;.</source>
          <target state="translated">왼쪽의 각 유형 &lt;code&gt;T&lt;/code&gt; 와 오른쪽의 각 유형 &lt;code&gt;U&lt;/code&gt; 에 대해 &lt;code&gt;T&lt;/code&gt; 유형의 값을 &lt;code&gt;U&lt;/code&gt; 유형의 값과 비교할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="e27d5d7f20198430510bed8d554d11950a10ed02" translate="yes" xml:space="preserve">
          <source>For each value &lt;code&gt;v1&lt;/code&gt; on the left-hand side and each value &lt;code&gt;v2&lt;/code&gt; on the right-hand side, the expression &lt;code&gt;v1 == v2&lt;/code&gt; is true.</source>
          <target state="translated">왼쪽의 각 값 &lt;code&gt;v1&lt;/code&gt; 과 오른쪽의 각 값 &lt;code&gt;v2&lt;/code&gt; 에 대해 식 &lt;code&gt;v1 == v2&lt;/code&gt; 는 true입니다.</target>
        </trans-unit>
        <trans-unit id="9025d5cca105be0e8976e2851061cc835c9a962a" translate="yes" xml:space="preserve">
          <source>For efficiency, UUID is implemented as a struct. UUIDs are therefore empty if not explicitly initialized. An UUID is empty if &lt;a href=&quot;#empty&quot;&gt;`UUID.empty`&lt;/a&gt; is true. Empty UUIDs are equal to &lt;code&gt;UUID.init&lt;/code&gt;, which is a UUID with all 16 bytes set to 0. Use UUID's constructors or the UUID generator functions to get an initialized UUID.</source>
          <target state="translated">효율성을 위해 UUID는 구조체로 구현됩니다. 따라서 UUID는 명시 적으로 초기화되지 않은 경우 비어 있습니다. &lt;a href=&quot;#empty&quot;&gt;`UUID.empty`&lt;/a&gt; 가 true이면 UUID가 비어 있습니다. 빈 UUID는 16 바이트가 모두 0으로 설정된 UUID 인 &lt;code&gt;UUID.init&lt;/code&gt; 와 같습니다. UUID의 생성자 또는 UUID 생성기 함수를 사용하여 초기화 된 UUID를 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="62d0aac1e2c0659f1732b0c95533d24eac16f4a7" translate="yes" xml:space="preserve">
          <source>For example the primitives &lt;code&gt;c.remove(r)&lt;/code&gt; and &lt;code&gt;c.linearRemove(r)&lt;/code&gt; both remove the sequence of elements in range &lt;code&gt;r&lt;/code&gt; from the container &lt;code&gt;c&lt;/code&gt;. The primitive &lt;code&gt;c.remove(r)&lt;/code&gt; guarantees &amp;Omicron;(&lt;code&gt;n&lt;sub&gt;r&lt;/sub&gt; log n&lt;sub&gt;c&lt;/sub&gt;&lt;/code&gt;) complexity in the worst case and &lt;code&gt;c.linearRemove(r)&lt;/code&gt; relaxes this guarantee to &amp;Omicron;(&lt;code&gt;n&lt;sub&gt;c&lt;/sub&gt;&lt;/code&gt;).  Since a sequence of elements can be removed from a &lt;a href=&quot;std_container_dlist&quot;&gt;doubly linked list&lt;/a&gt; in constant time, &lt;code&gt;DList&lt;/code&gt; provides the primitive &lt;code&gt;c.remove(r)&lt;/code&gt; as well as &lt;code&gt;c.linearRemove(r)&lt;/code&gt;. On the other hand &lt;a href=&quot;std_container_array&quot;&gt;Array&lt;/a&gt; only offers &lt;code&gt;c.linearRemove(r)&lt;/code&gt;.  The following table describes the common set of primitives that containers implement. A container need not implement all primitives, but if a primitive is implemented, it must support the syntax described in the &lt;b&gt;syntax&lt;/b&gt; column with the semantics described in the &lt;b&gt;description&lt;/b&gt; column, and it must not have a worst-case complexity worse than denoted in big-O notation in the &amp;Omicron;(&lt;code&gt;&amp;middot;&lt;/code&gt;) column. Below, &lt;code&gt;C&lt;/code&gt; means a container type, &lt;code&gt;c&lt;/code&gt; is a value of container type, &lt;code&gt;n&lt;sub&gt;x&lt;/sub&gt;&lt;/code&gt; represents the effective length of value &lt;code&gt;x&lt;/code&gt;, which could be a single element (in which case &lt;code&gt;n&lt;sub&gt;x&lt;/sub&gt;&lt;/code&gt; is &lt;code&gt;1&lt;/code&gt;), a container, or a range.</source>
          <target state="translated">예를 들어 프리미티브 &lt;code&gt;c.remove(r)&lt;/code&gt; 및 &lt;code&gt;c.linearRemove(r)&lt;/code&gt; 는 컨테이너 &lt;code&gt;c&lt;/code&gt; 에서 &lt;code&gt;r&lt;/code&gt; 범위의 요소 시퀀스를 제거합니다 . 기본 &lt;code&gt;c.remove(r)&lt;/code&gt; 는 최악의 경우 &amp;Omicron; ( &lt;code&gt;n&lt;sub&gt;r&lt;/sub&gt; log n&lt;sub&gt;c&lt;/sub&gt;&lt;/code&gt; &lt;sub&gt;r&lt;/sub&gt; log n &lt;sub&gt;c&lt;/sub&gt; ) 복잡성을 보장 하고 &lt;code&gt;c.linearRemove(r)&lt;/code&gt; 은이 보증을 &amp;Omicron; ( &lt;code&gt;n&lt;sub&gt;c&lt;/sub&gt;&lt;/code&gt; &lt;sub&gt;c&lt;/sub&gt; ) 로 완화합니다 . 요소들의 시퀀스가 제거 될 수 있기 때문에, &lt;a href=&quot;std_container_dlist&quot;&gt;이중 연결리스트&lt;/a&gt; 일정한 시간에 &lt;code&gt;DList&lt;/code&gt; 는 프리미티브 제공 &lt;code&gt;c.remove(r)&lt;/code&gt; 뿐만 아니라 &lt;code&gt;c.linearRemove(r)&lt;/code&gt; . 반면에 &lt;a href=&quot;std_container_array&quot;&gt;배열&lt;/a&gt;&lt;sub&gt;&lt;/sub&gt;&lt;sub&gt;&lt;/sub&gt;&lt;sub&gt;&lt;/sub&gt; &lt;code&gt;c.linearRemove(r)&lt;/code&gt; 만 제공합니다 . 다음 표는 컨테이너가 구현하는 공통 기본 세트를 설명합니다. 컨테이너는 모든 프리미티브를 구현할 필요는 없지만 프리미티브가 구현 된 경우 &lt;b&gt;설명&lt;/b&gt; 열에 설명 된 의미론 을 사용하여 &lt;b&gt;구문&lt;/b&gt; 열에 설명 된 구문을 지원 해야하며, 큰 경우에 표시된 것보다 최악의 복잡성을 악화시키지 않아야합니다. &amp;Omicron; ( &lt;code&gt;&amp;middot;&lt;/code&gt; ) 열의 O 표기법 . 아래에서 &lt;code&gt;C&lt;/code&gt; 는 컨테이너 유형을 의미하고, &lt;code&gt;c&lt;/code&gt; 는 컨테이너 유형 의 값을 의미하며 , &lt;code&gt;n&lt;sub&gt;x&lt;/sub&gt;&lt;/code&gt; &lt;sub&gt;x&lt;/sub&gt; 는 &lt;code&gt;x&lt;/code&gt; 값의 유효 길이를 나타냅니다 . 단일 요소 일 수 있습니다 (이 경우 &lt;code&gt;n&lt;sub&gt;x&lt;/sub&gt;&lt;/code&gt; &lt;sub&gt;x&lt;/sub&gt; 는&lt;b&gt;&lt;/b&gt;&lt;sub&gt;&lt;/sub&gt;&lt;sub&gt;&lt;/sub&gt; &lt;code&gt;1&lt;/code&gt; ), 용기 또는 범위.</target>
        </trans-unit>
        <trans-unit id="d00edd8f12a04d1befc302c87668dfdb2d903e2a" translate="yes" xml:space="preserve">
          <source>For example, &lt;code&gt;\U0001F603&lt;/code&gt; represents the Unicode character U+1F603 (SMILING FACE WITH OPEN MOUTH).</source>
          <target state="translated">예를 들어, &lt;code&gt;\U0001F603&lt;/code&gt; 은 유니 코드 문자 U + 1F603 (SMILING FACE WITH OPEN MOUTH)을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="bddb2b6572ea79b1700e73180c6a9ef4a9e2c7be" translate="yes" xml:space="preserve">
          <source>For example, &lt;code&gt;\u03B3&lt;/code&gt; represents the Unicode character &amp;gamma; (U+03B3 - GREEK SMALL LETTER GAMMA).</source>
          <target state="translated">예를 들어, &lt;code&gt;\u03B3&lt;/code&gt; 은 유니 코드 문자 &amp;gamma; (U + 03B3-GREEK SMALL LETTER GAMMA)를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="e8c9021af829ec2346f217a33bffab12b0880918" translate="yes" xml:space="preserve">
          <source>For example, &lt;code&gt;a[index]&lt;/code&gt; is really &lt;code&gt;a&lt;/code&gt;, and &lt;code&gt;s.f&lt;/code&gt; is really &lt;code&gt;s&lt;/code&gt;.</source>
          <target state="translated">예를 들어, &lt;code&gt;a[index]&lt;/code&gt; 는 실제로 &lt;code&gt;a&lt;/code&gt; 이고 &lt;code&gt;s.f&lt;/code&gt; 는 실제로 &lt;code&gt;s&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="aee49e2b5de63bc28985d9e3f5b2391109f50868" translate="yes" xml:space="preserve">
          <source>For example, consider a class that is a container for two elements:</source>
          <target state="translated">예를 들어, 두 요소의 컨테이너 인 클래스를 생각해보십시오.</target>
        </trans-unit>
        <trans-unit id="f4060213712449048c8c23e8aed13169261c66f1" translate="yes" xml:space="preserve">
          <source>For example, for the Intel Pentium:</source>
          <target state="translated">예를 들어, Intel Pentium의 경우 :</target>
        </trans-unit>
        <trans-unit id="56a66959fa3d6d051e3f2985a858c24aef88cfec" translate="yes" xml:space="preserve">
          <source>For example, given a class &lt;code&gt;Sum&lt;/code&gt; that is used to add two values, a unit test can be given:</source>
          <target state="translated">예를 들어, 두 개의 값을 추가하는 데 사용되는 클래스 &lt;code&gt;Sum&lt;/code&gt; 이 주어지면 단위 ​​테스트를 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="afa20f7fd4e06e98278c1c050fed1f04af8aa95d" translate="yes" xml:space="preserve">
          <source>For example, here is how to remove a single element from an array:</source>
          <target state="translated">예를 들어, 배열에서 단일 요소를 제거하는 방법은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="664b22b4de56d86a94d4d1f08efe5f39ea8b5955" translate="yes" xml:space="preserve">
          <source>For example, if this qualifies to 'a1.a2' and pkg - to 'a1.a2.a3', this function returns 'true'. If it is other way around or qualified package paths conflict function returns 'false'.</source>
          <target state="translated">예를 들어, 이것이 'a1.a2'및 pkg- 'a1.a2.a3'에 해당되면이 함수는 'true'를 리턴합니다. 다른 방법이거나 정규화 된 패키지 경로 인 경우 충돌 함수는 'false'를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="2f4a0bc25491ad453cd52460e2badab7db117513" translate="yes" xml:space="preserve">
          <source>For example, in order to overload the &lt;code&gt;-&lt;/code&gt; (negation) operator for struct S, and no other operator:</source>
          <target state="translated">예를 들어, 구조체 S에 대해 &lt;code&gt;-&lt;/code&gt; (음수) 연산자 를 오버로드하고 다른 연산자 는 오버로드 하지 않으 려면 다음을 수행하십시오 .</target>
        </trans-unit>
        <trans-unit id="1db4a09c9c6a230d99b45c4869c4f6e84c23d582" translate="yes" xml:space="preserve">
          <source>For example, one could redefine &lt;code&gt;DDOC_SUMMARY&lt;/code&gt;:</source>
          <target state="translated">예를 들어 &lt;code&gt;DDOC_SUMMARY&lt;/code&gt; 를 재정의 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="0e5d29b3a3287b6048a7baf84989543162cfde72" translate="yes" xml:space="preserve">
          <source>For example, the &lt;code&gt;immutable&lt;/code&gt; type qualifier can be used to create variables of immutable type, such as:</source>
          <target state="translated">예를 들어, &lt;code&gt;immutable&lt;/code&gt; 유형 한정자는 다음과 같은 불변 유형의 변수를 만드는 데 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b3a7c81f27baa62d867db8143dafce975505e522" translate="yes" xml:space="preserve">
          <source>For example, the expression &lt;code&gt;(p1 &amp;gt; q1 &amp;amp;&amp;amp; p2 &amp;lt;= q2)&lt;/code&gt; is permitted when &lt;code&gt;p1&lt;/code&gt;, &lt;code&gt;p2&lt;/code&gt; are expressions yielding pointers to memory block</source>
          <target state="translated">예를 들어, &lt;code&gt;p1&lt;/code&gt; , &lt;code&gt;p2&lt;/code&gt; 가 메모리 블록에 대한 포인터를 생성 하는 표현식 인 경우 표현식 &lt;code&gt;(p1 &amp;gt; q1 &amp;amp;&amp;amp; p2 &amp;lt;= q2)&lt;/code&gt; 이 허용됩니다.</target>
        </trans-unit>
        <trans-unit id="afa193b836783a5ecabcde946cad5a9128e2b421" translate="yes" xml:space="preserve">
          <source>For example, the following function template only matches with odd values of &lt;code&gt;N&lt;/code&gt;:</source>
          <target state="translated">예를 들어 다음 함수 템플릿은 홀수 값 &lt;code&gt;N&lt;/code&gt; 과만 일치합니다 .</target>
        </trans-unit>
        <trans-unit id="059c3e8cce263b2945a18ac90b2637e10a8026b1" translate="yes" xml:space="preserve">
          <source>For example:</source>
          <target state="translated">예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="38096dc369d1ebe6ec7ec60de5ac2d73db72feee" translate="yes" xml:space="preserve">
          <source>For example: &lt;code&gt;\101&lt;/code&gt; represents the character with the value 65 (&lt;code&gt;'A'&lt;/code&gt;). Analogous to hexadecimal characters, the largest byte value is &lt;code&gt;\377&lt;/code&gt; (= &lt;code&gt;\xFF&lt;/code&gt; in hexadecimal or &lt;code&gt;255&lt;/code&gt; in decimal)</source>
          <target state="translated">예를 들어, &lt;code&gt;\101&lt;/code&gt; 은 값이 65 ( &lt;code&gt;'A'&lt;/code&gt; ) 인 문자를 나타냅니다 . 16 진 문자와 유사하게 가장 큰 바이트 값은 &lt;code&gt;\377&lt;/code&gt; (= 16 진 &lt;code&gt;\xFF&lt;/code&gt; 또는 10 진 &lt;code&gt;255&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="8187ba92149a37ed481170300ec07180dd3c8361" translate="yes" xml:space="preserve">
          <source>For example: &lt;code&gt;\xFF&lt;/code&gt; represents the character with the value 255.</source>
          <target state="translated">예를 들어, &lt;code&gt;\xFF&lt;/code&gt; 는 값이 255 인 문자를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="4d1688fe7c391489009113fe8f20b160cce3978f" translate="yes" xml:space="preserve">
          <source>For examples see the &lt;a href=&quot;#Grapheme&quot;&gt;&lt;code&gt;Grapheme&lt;/code&gt;&lt;/a&gt; below.</source>
          <target state="translated">예를 들어 아래의 &lt;a href=&quot;#Grapheme&quot;&gt; &lt;code&gt;Grapheme&lt;/code&gt; 을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="79381ea951fd6aadf813123f5b529dd772681030" translate="yes" xml:space="preserve">
          <source>For finite ranges, the result of &lt;code&gt;opSlice&lt;/code&gt; must be of the same type as the original range type. If the range defines &lt;code&gt;opDollar&lt;/code&gt;, then it must support subtraction.</source>
          <target state="translated">유한 범위의 경우 &lt;code&gt;opSlice&lt;/code&gt; 의 결과 는 원래 범위 유형과 동일한 유형이어야합니다. 범위가 &lt;code&gt;opDollar&lt;/code&gt; 를 정의하면 빼기를 지원해야합니다.</target>
        </trans-unit>
        <trans-unit id="c77ba69b2b7b1720fb5f6b789826c71a3c605b97" translate="yes" xml:space="preserve">
          <source>For float, double, and real values, the &lt;a href=&quot;type#usual-arithmetic-conversions&quot;&gt;Usual Arithmetic Conversions&lt;/a&gt; are applied to bring them to a common type before comparison. The values &lt;code&gt;-0&lt;/code&gt; and &lt;code&gt;+0&lt;/code&gt; are considered equal. If either or both operands are NAN, then &lt;code&gt;==&lt;/code&gt; returns false and &lt;code&gt;!=&lt;/code&gt; returns &lt;code&gt;true&lt;/code&gt;. Otherwise, the bit patterns of the common type are compared for equality.</source>
          <target state="translated">float, double 및 real 값의 경우 &lt;a href=&quot;type#usual-arithmetic-conversions&quot;&gt;일반적인 산술 변환&lt;/a&gt; 을 적용하여 비교 전에 공통 유형으로 가져옵니다. 값 &lt;code&gt;-0&lt;/code&gt; 과 &lt;code&gt;+0&lt;/code&gt; 은 동일한 것으로 간주됩니다. 피연산자 중 하나 또는 둘 다가 NAN이면 &lt;code&gt;==&lt;/code&gt; 는 false를 반환하고 &lt;code&gt;!=&lt;/code&gt; 는 &lt;code&gt;true&lt;/code&gt; 를 반환 합니다 . 그렇지 않으면 공통 유형의 비트 패턴이 동일한 지 비교됩니다.</target>
        </trans-unit>
        <trans-unit id="ec28333c5408aa27a2824def03dd893394acfa05" translate="yes" xml:space="preserve">
          <source>For floating point inputs, calculations are made in &lt;a href=&quot;https://dlang.org/spec/type.html&quot;&gt;&lt;code&gt;real&lt;/code&gt;&lt;/a&gt; precision for &lt;code&gt;real&lt;/code&gt; inputs and in &lt;code&gt;double&lt;/code&gt; precision otherwise (Note this is a special case that deviates from &lt;code&gt;fold&lt;/code&gt;'s behavior, which would have kept &lt;code&gt;float&lt;/code&gt; precision for a &lt;code&gt;float&lt;/code&gt; range). For all other types, the calculations are done in the same type obtained from from adding two elements of the range, which may be a different type from the elements themselves (for example, in case of &lt;a href=&quot;https://dlang.org/spec/type.html#integer-promotions&quot;&gt;integral promotion&lt;/a&gt;).</source>
          <target state="translated">부동 소수점 입력의 경우 &lt;code&gt;real&lt;/code&gt; 입력에 대해 &lt;a href=&quot;https://dlang.org/spec/type.html&quot;&gt; &lt;code&gt;real&lt;/code&gt; &lt;/a&gt; 정밀도 로 계산 하고 그렇지 않으면 &lt;code&gt;double&lt;/code&gt; 밀도로 계산합니다 (이 경우 &lt;code&gt;float&lt;/code&gt; 범위 에 대해 부동 &lt;code&gt;float&lt;/code&gt; 정밀도를 유지 한 &lt;code&gt;fold&lt;/code&gt; 동작 에서 벗어난 특수한 경우입니다 ). 다른 모든 유형의 경우 범위의 두 요소를 추가하여 얻은 동일한 유형으로 계산이 수행되는데, 이는 요소 자체와 다른 유형일 수 있습니다 (예 : &lt;a href=&quot;https://dlang.org/spec/type.html#integer-promotions&quot;&gt;통합 승격의&lt;/a&gt; 경우 ).</target>
        </trans-unit>
        <trans-unit id="765c4ec4b98b1848bab9c8fba86795001e6760ec" translate="yes" xml:space="preserve">
          <source>For floating point operands, the * and / operations correspond to the IEEE 754 floating point equivalents. % is not the same as the IEEE 754 remainder. For example, 15.0 % 10.0 == 5.0, whereas for IEEE 754, remainder(15.0,10.0) == -5.0.</source>
          <target state="translated">부동 소수점 피연산자의 경우 * 및 / 연산은 IEEE 754 부동 소수점에 해당합니다. %는 IEEE 754 나머지와 동일하지 않습니다. 예를 들어, 15.0 % 10.0 == 5.0 인 반면 IEEE 754의 경우 나머지 (15.0,10.0) == -5.0입니다.</target>
        </trans-unit>
        <trans-unit id="311831dfcbe2aa85299a9b7419ec3f7edbd674b9" translate="yes" xml:space="preserve">
          <source>For floating point operations and expression intermediate values, a greater precision can be used than the type of the expression. Only the minimum precision is set by the types of the operands, not the maximum. &lt;b&gt;Implementation Note:&lt;/b&gt; On Intel x86 machines, for example, it is expected (but not required) that the intermediate calculations be done to the full 80 bits of precision implemented by the hardware.</source>
          <target state="translated">부동 소수점 연산 및 표현식 중간 값의 경우 표현식 유형보다 더 큰 정밀도를 사용할 수 있습니다. 최대 정밀도가 아닌 피연산자의 유형에 따라 최소 정밀도 만 설정됩니다. &lt;b&gt;구현 참고 사항 :&lt;/b&gt; 예를 들어 Intel x86 시스템에서는 중간 계산이 하드웨어에 의해 구현 된 전체 80 비트 정밀도로 수행 될 것으로 예상됩니다 (필요하지는 않습니다).</target>
        </trans-unit>
        <trans-unit id="a8f36fac9b0314aa81c6e99d081aedbe4af658c5" translate="yes" xml:space="preserve">
          <source>For floats, the largest possible payload is 0x3F_FFFF. For doubles, it is 0x3_FFFF_FFFF_FFFF. For 80-bit or 128-bit reals, it is 0x3FFF_FFFF_FFFF_FFFF.</source>
          <target state="translated">플로트의 경우 가능한 최대 페이로드는 0x3F_FFFF입니다. 복식의 경우 0x3_FFFF_FFFF_FFFF입니다. 80 비트 또는 128 비트 실수의 경우 0x3FFF_FFFF_FFFF_FFFF입니다.</target>
        </trans-unit>
        <trans-unit id="f68bb29877591d4b489a9f6fff54379ee749f0f3" translate="yes" xml:space="preserve">
          <source>For forward compatibility, the CPU is compared against different microarchitectures. For 32-bit x86, comparisons are made against the Intel PPro/PII/PIII/PM family.</source>
          <target state="translated">순방향 호환성을 위해 CPU는 다른 마이크로 아키텍처와 비교됩니다. 32 비트 x86의 경우 인텔 PPro / PII / PIII / PM 제품군과 비교됩니다.</target>
        </trans-unit>
        <trans-unit id="cb68f2aaef1107ffda2b00fc87de858154352d8d" translate="yes" xml:space="preserve">
          <source>For functions which operate on Unicode characters, see &lt;a href=&quot;std_uni&quot;&gt;&lt;code&gt;std.uni&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">유니 코드 문자에서 작동하는 함수는 &lt;a href=&quot;std_uni&quot;&gt; &lt;code&gt;std.uni&lt;/code&gt; 를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="4c427f88fad780106904fb230a561fe45ae8afed" translate="yes" xml:space="preserve">
          <source>For functions, the &lt;code&gt;auto&lt;/code&gt; attribute means return type inference. See &lt;a href=&quot;https://dlang.org/function.html#auto-functions&quot;&gt;Auto Functions&lt;/a&gt;.</source>
          <target state="translated">함수의 경우 &lt;code&gt;auto&lt;/code&gt; 속성은 반환 유형 유추를 의미합니다. &lt;a href=&quot;https://dlang.org/function.html#auto-functions&quot;&gt;자동 기능을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="fb6e8700842932cee5fe004d021df4907ea6dd83" translate="yes" xml:space="preserve">
          <source>For further information see the the two functions defined inside of this template.</source>
          <target state="translated">자세한 내용은이 템플릿 내에 정의 된 두 가지 기능을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="6d45ac630dd39944ad55493060e8c4dac92d7fc5" translate="yes" xml:space="preserve">
          <source>For garbage collected pointers and references, however, there are some restrictions. These restrictions are minor, but they are intended to enable the maximum flexibility in garbage collector design.</source>
          <target state="translated">그러나 가비지 수집 포인터 및 참조의 경우 몇 가지 제한 사항이 있습니다. 이러한 제한은 미미하지만 가비지 수집기 디자인에서 최대한의 유연성을 발휘하기위한 것입니다.</target>
        </trans-unit>
        <trans-unit id="b7afa355fcaa31af2cd3f80d70dbcf199acfca98" translate="yes" xml:space="preserve">
          <source>For historical compatibility when &lt;code&gt;nbits == 192&lt;/code&gt; and &lt;code&gt;UIntType&lt;/code&gt; is &lt;code&gt;uint&lt;/code&gt; a legacy hybrid PRNG is used consisting of a 160-bit xorshift combined with a 32-bit counter. This combined generator has period equal to the least common multiple of &lt;code&gt;2^^160 - 1&lt;/code&gt; and &lt;code&gt;2^^32&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;nbits == 192&lt;/code&gt; 이고 &lt;code&gt;UIntType&lt;/code&gt; 이 &lt;code&gt;uint&lt;/code&gt; 인 경우 기록 호환성을 위해 레거시 하이브리드 PRNG는 32 비트 카운터와 결합 된 160 비트 xorshift로 구성됩니다. 이 결합 된 생성기는 &lt;code&gt;2^^160 - 1&lt;/code&gt; 과 &lt;code&gt;2^^32&lt;/code&gt; 의 최소 ​​공배수와 동일한주기를 갖습니다 .</target>
        </trans-unit>
        <trans-unit id="373d2d5153ba00f28887ffdca247e026ee396782" translate="yes" xml:space="preserve">
          <source>For hot code paths, it is worthwhile to check to see if the void initializer actually improves results before using it.</source>
          <target state="translated">핫 코드 경로의 경우 void 초기화 프로그램이 실제로 사용하기 전에 결과를 개선하는지 확인하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="e4f4bd7aa4cad79620e1f6020bf4450eeadc7446" translate="yes" xml:space="preserve">
          <source>For illustration purposes only, every method call results in assertion failure. Use &lt;a href=&quot;#utfMatcher&quot;&gt;&lt;code&gt;utfMatcher&lt;/code&gt;&lt;/a&gt; to obtain a concrete matcher for UTF-8 or UTF-16 encodings.</source>
          <target state="translated">설명 목적으로 만 모든 메서드 호출로 어설 ​​션 오류가 발생합니다. UTF-8 또는 UTF-16 인코딩을위한 구체적 매처를 얻으려면 &lt;a href=&quot;#utfMatcher&quot;&gt; &lt;code&gt;utfMatcher&lt;/code&gt; &lt;/a&gt; 를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="4cd5f2dc243960435d23cc958481129bcfb42bcc" translate="yes" xml:space="preserve">
          <source>For infinite ranges, when</source>
          <target state="translated">무한 범위의 경우</target>
        </trans-unit>
        <trans-unit id="aae2fd6469d641f1e8d553dabcf2fe7c0be1babf" translate="yes" xml:space="preserve">
          <source>For instance, if the function used to generate a range of time points generated successive Easters (i.e. you're iterating over all of the Easters within the interval), the initial date probably isn't an Easter. Using &lt;code&gt;PopFirst.yes&lt;/code&gt; would tell the function which returned the range that &lt;code&gt;popFront&lt;/code&gt; was to be called so that front would then be an Easter - the next one generated by the function (which when iterating forward would be the Easter following the original &lt;code&gt;front&lt;/code&gt;, while when iterating backward, it would be the Easter prior to the original &lt;code&gt;front&lt;/code&gt;). If &lt;code&gt;PopFirst.no&lt;/code&gt; were used, then &lt;code&gt;front&lt;/code&gt; would remain the original time point and it would not necessarily be a time point which would be generated by the range-generating function (which in many cases is exactly what is desired - e.g. if iterating over every day starting at the beginning of the interval).</source>
          <target state="translated">예를 들어, 일련의 시점을 생성하는 데 사용 된 함수가 연속적인 부활절을 생성 한 경우 (즉, 간격 내 모든 부활절을 반복하는 경우) 초기 날짜는 부활절이 아닐 수 있습니다. 사용 &lt;code&gt;PopFirst.yes&lt;/code&gt; 을 하는 범위에서 반환 된 기능 말할 것 &lt;code&gt;popFront&lt;/code&gt; 가 그 앞에 다음 부활절 될 수 있도록 호출했다 - 기능 (에 의해 생성 된 다음의 일을하는 반복하는 앞으로 원래 다음 부활절 될 때 &lt;code&gt;front&lt;/code&gt; 때 동안, 거꾸로 반복하면 원래 &lt;code&gt;front&lt;/code&gt; 보다 먼저 부활절이 됩니다. &lt;code&gt;PopFirst.no&lt;/code&gt; 가 사용 된 경우 &lt;code&gt;front&lt;/code&gt; 원래 시점을 유지하고 반드시 범위 생성 기능에 의해 생성되는 시점 일 필요는 없습니다 (예를 들어, 간격의 시작에서 시작하여 매일 반복되는 경우). .</target>
        </trans-unit>
        <trans-unit id="1a761bf1c3bac8790220dd0e044887eeb25a2cc8" translate="yes" xml:space="preserve">
          <source>For instructions with the imm8 version: PSLLD, PSLLQ, PSLLW, PSRAD, PSRAW, PSRLD, PSRLQ, PSRLW, PSRLDQ, PSLLDQ</source>
          <target state="translated">imm8 버전에 대한 지침 : PSLLD, PSLLQ, PSLLW, PSRAD, PSRAW, PSRLD, PSRLQ, PSRLW, PSRLDQ, PSLLDQ</target>
        </trans-unit>
        <trans-unit id="abfb408bf733bafad2f02f380cf2ab1c7688837d" translate="yes" xml:space="preserve">
          <source>For instructions: CMPPD, CMPSS, CMPSD, CMPPS, PSHUFD, PSHUFHW, PSHUFLW, BLENDPD, BLENDPS, DPPD, DPPS, MPSADBW, PBLENDW, ROUNDPD, ROUNDPS, ROUNDSD, ROUNDSS</source>
          <target state="translated">지시 사항 : CMPPD, CMPSS, CMPSD, CMPPS, PSHUFD, PSHUFHW, PSHUFLW, BLENDPD, BLENDPS, DPPD, DPPS, MPSADBW, PBLENDW, ROUNDPD, ROUNDPS, ROUNDSD, ROUNDSS</target>
        </trans-unit>
        <trans-unit id="2912089b8e4b5f7fb17c30aa7f29625c50f1f39a" translate="yes" xml:space="preserve">
          <source>For integral operands of the &lt;code&gt;/&lt;/code&gt; and &lt;code&gt;%&lt;/code&gt; operators, the quotient rounds towards zero and the remainder has the same sign as the dividend. If the divisor is zero, an Exception is thrown.</source>
          <target state="translated">&lt;code&gt;/&lt;/code&gt; 및 &lt;code&gt;%&lt;/code&gt; 연산자 의 정수 피연산자의 경우 몫은 0으로 반올림되며 나머지는 피제수와 같은 부호를 갖습니다. 제수가 0이면 예외가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="00fe6a3ea358be700add2733e7f987f7657eccea" translate="yes" xml:space="preserve">
          <source>For integral operands, the &lt;code&gt;*&lt;/code&gt;, &lt;code&gt;/&lt;/code&gt;, and &lt;code&gt;%&lt;/code&gt; correspond to multiply, divide, and modulus operations. For multiply, overflows are ignored and simply chopped to fit into the integral type.</source>
          <target state="translated">정수 피연산자의 경우 &lt;code&gt;*&lt;/code&gt; , &lt;code&gt;/&lt;/code&gt; 및 &lt;code&gt;%&lt;/code&gt; 는 곱하기, 나누기 및 모듈러스 연산에 해당합니다. 곱하기 위해 오버플로는 무시되고 간단하게 정수 유형에 맞게 잘립니다.</target>
        </trans-unit>
        <trans-unit id="f8089e9fce56a8de104b1a2fd89f78f4e3794e38" translate="yes" xml:space="preserve">
          <source>For large file support, there is also a LARGE version of the key which takes an off_t type, allowing platforms with larger off_t sizes to handle larger files. See below for INFILESIZE_LARGE.</source>
          <target state="translated">큰 파일 지원을 위해 off_t 유형을 사용하는 큰 버전의 키도 있으므로 off_t 크기가 큰 플랫폼이 더 큰 파일을 처리 할 수 ​​있습니다. INFILESIZE_LARGE에 대해서는 아래를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="4573bc72a0b35e6968fbc43281884135acda5317" translate="yes" xml:space="preserve">
          <source>For many processes, a grapheme cluster behaves as if it was a single character with the same properties as its grapheme base. Effectively, nonspacing marks apply</source>
          <target state="translated">많은 프로세스에서 grapheme 클러스터는 grapheme base와 동일한 속성을 가진 단일 문자 인 것처럼 동작합니다. 효과적으로 비 간격 표시가 적용됩니다</target>
        </trans-unit>
        <trans-unit id="d9d2c4569580379d483d010c37b2df4e739e00dd" translate="yes" xml:space="preserve">
          <source>For methods, it would be the class object or struct value the method is called on. For nested functions it would be the enclosing function's stack frame.</source>
          <target state="translated">메소드의 경우 메소드가 호출되는 클래스 오브젝트 또는 구조체 값입니다. 중첩 함수의 경우 둘러싸는 함수의 스택 프레임이됩니다.</target>
        </trans-unit>
        <trans-unit id="c658e43c1de6b0fdb8fb67e28199ecda730200d8" translate="yes" xml:space="preserve">
          <source>For more control than the high level functions provide, use the low level API:</source>
          <target state="translated">고수준 함수가 제공하는 것보다 더 많은 제어를하려면 저수준 API를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="62fcc5c0c32d14129884b840a9ef5db5f9b4d71a" translate="yes" xml:space="preserve">
          <source>For more info about callbacks read the &lt;a href=&quot;function#closures&quot;&gt;closures&lt;/a&gt; section.</source>
          <target state="translated">콜백에 대한 자세한 내용은 &lt;a href=&quot;function#closures&quot;&gt;클로저&lt;/a&gt; 섹션을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="4e48b9f8da2dcff74dfa76b614f30e09e82d9357" translate="yes" xml:space="preserve">
          <source>For more information on normalization forms see the &lt;a href=&quot;#Normalization&quot;&gt;normalization section&lt;/a&gt;.</source>
          <target state="translated">정규화 양식에 대한 자세한 내용은 &lt;a href=&quot;#Normalization&quot;&gt;정규화 섹션을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="c70774a3bc49910eb2a297e31d36c248a26d7f7c" translate="yes" xml:space="preserve">
          <source>For more information please see the full section on &lt;a href=&quot;unittest#documented-unittests&quot;&gt;documented unit tests&lt;/a&gt;.</source>
          <target state="translated">자세한 내용은 &lt;a href=&quot;unittest#documented-unittests&quot;&gt;문서화 된 단위 테스트&lt;/a&gt; 에 대한 전체 섹션을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="f4836c4e8b6fd2beb1b18962cae04c16a239752f" translate="yes" xml:space="preserve">
          <source>For more information see the &lt;a href=&quot;https://developer.apple.com/library/mac/documentation/MacOSX/Conceptual/BPFrameworks/Tasks/IncludingFrameworks.html&quot;&gt;reference documentation&lt;/a&gt; and the &lt;code&gt;ld&lt;/code&gt; man page.</source>
          <target state="translated">자세한 내용은 &lt;a href=&quot;https://developer.apple.com/library/mac/documentation/MacOSX/Conceptual/BPFrameworks/Tasks/IncludingFrameworks.html&quot;&gt;참조 설명서&lt;/a&gt; 및 &lt;code&gt;ld&lt;/code&gt; 매뉴얼 페이지를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="d343011cf3b0f9c5af4eccef2d47be216bb18517" translate="yes" xml:space="preserve">
          <source>For more information, see &lt;a href=&quot;http://lunesu.com/uploads/ModernCOMProgramminginD.pdf&quot;&gt;Modern COM Programming in D&lt;/a&gt;</source>
          <target state="translated">자세한 내용 &lt;a href=&quot;http://lunesu.com/uploads/ModernCOMProgramminginD.pdf&quot;&gt;은 D의 최신 COM 프로그래밍을&lt;/a&gt; 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="c75305c01a420c526f9930f5f2afef16712fe3db" translate="yes" xml:space="preserve">
          <source>For more information, see &lt;a href=&quot;https://dlang.org/ctarguments.html&quot;&gt;Compile-time Sequences&lt;/a&gt;.</source>
          <target state="translated">자세한 내용은 &lt;a href=&quot;https://dlang.org/ctarguments.html&quot;&gt;컴파일 타임 시퀀스를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="232f8923a5b9a1c36aaeed4b764cc4a027de9c86" translate="yes" xml:space="preserve">
          <source>For more information, see &lt;a href=&quot;template#function-templates&quot;&gt;function templates&lt;/a&gt;.</source>
          <target state="translated">자세한 정보는 &lt;a href=&quot;template#function-templates&quot;&gt;함수 템플리트를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="14fe53fd058540daece4c12310ac08fab7493096" translate="yes" xml:space="preserve">
          <source>For more information, see: &lt;a href=&quot;attribute#uda&quot;&gt;User-Defined Attributes&lt;/a&gt;</source>
          <target state="translated">자세한 정보는 &lt;a href=&quot;attribute#uda&quot;&gt;사용자 정의 속성을&lt;/a&gt; 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="4b01b147c4aa5229fbefd3dfcace458d961ffaae" translate="yes" xml:space="preserve">
          <source>For more on infering uniqueness see the &lt;b&gt;unique&lt;/b&gt; and &lt;b&gt;lent&lt;/b&gt; keywords in the &lt;a href=&quot;http://www.cs.cmu.edu/~aldrich/papers/aldrich-dissertation.pdf&quot;&gt;ArchJava&lt;/a&gt; language.  The downside of using &lt;code&gt;assumeUnique&lt;/code&gt;'s convention-based usage is that at this time there is no formal checking of the correctness of the assumption; on the upside, the idiomatic use of &lt;code&gt;assumeUnique&lt;/code&gt; is simple and rare enough to be tolerable.</source>
          <target state="translated">고유성을 &lt;a href=&quot;http://www.cs.cmu.edu/~aldrich/papers/aldrich-dissertation.pdf&quot;&gt;유추&lt;/a&gt; 하는 것에 대한 자세한 내용 은 ArchJava 언어 의 &lt;b&gt;고유&lt;/b&gt; 하고 &lt;b&gt;빌려준&lt;/b&gt; 키워드를 참조하십시오 . &lt;code&gt;assumeUnique&lt;/code&gt; 의 규칙 기반 사용법 을 사용하는 단점은 현재 가정의 정확성에 대한 공식적인 점검이 없다는 것입니다. 거꾸로, &lt;code&gt;assumeUnique&lt;/code&gt; 의 관용적 인 사용 은 간단하고 견딜 수있을 정도로 드 rare니다.</target>
        </trans-unit>
        <trans-unit id="9821fa00e5b3937536d63348fff48dbf21802af0" translate="yes" xml:space="preserve">
          <source>For most purposes, direct usage of this template is not necessary; instead, this module provides default implementations: &lt;a href=&quot;#Base64&quot;&gt;&lt;code&gt;Base64&lt;/code&gt;&lt;/a&gt;, implementing basic Base64 encoding, and &lt;a href=&quot;#Base64URL&quot;&gt;&lt;code&gt;Base64URL&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#Base64URLNoPadding&quot;&gt;&lt;code&gt;Base64URLNoPadding&lt;/code&gt;&lt;/a&gt;, that implement the Base64 variant for use in URLs and filenames, with and without padding, respectively.</source>
          <target state="translated">대부분의 경우이 템플릿을 직접 사용하지 않아도됩니다. 대신,이 모듈은 기본 구현을 제공 &lt;a href=&quot;#Base64&quot;&gt; &lt;code&gt;Base64&lt;/code&gt; 로를&lt;/a&gt; 기본 Base64 인코딩을 구현하고, &lt;a href=&quot;#Base64URL&quot;&gt; &lt;code&gt;Base64URL&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#Base64URLNoPadding&quot;&gt; &lt;code&gt;Base64URLNoPadding&lt;/code&gt; 은&lt;/a&gt; , 그와 각각 패딩없이 URL과 파일 이름에 사용하기 위해 Base64로 변형을 구현합니다.</target>
        </trans-unit>
        <trans-unit id="1227b6928512c13bafca17372e6fc839cf749e01" translate="yes" xml:space="preserve">
          <source>For negative durations, all of the split values will be negative.</source>
          <target state="translated">음수 지속 시간의 경우 모든 분할 값은 음수입니다.</target>
        </trans-unit>
        <trans-unit id="45d1ac4eefadfd952fb52f8057a9eb1805d7b858" translate="yes" xml:space="preserve">
          <source>For non-struct types, &lt;code&gt;move&lt;/code&gt; just performs &lt;code&gt;target = source&lt;/code&gt;:</source>
          <target state="translated">구조체가 아닌 유형의 경우 &lt;code&gt;move&lt;/code&gt; 은 &lt;code&gt;target = source&lt;/code&gt; 만 수행합니다 .</target>
        </trans-unit>
        <trans-unit id="3570c921d353ad6046f6122f9d8cb40d604f2aae" translate="yes" xml:space="preserve">
          <source>For other operand types, identity is defined as being the same as equality.</source>
          <target state="translated">다른 피연산자 유형의 경우 동일성은 동일성과 동일한 것으로 정의됩니다.</target>
        </trans-unit>
        <trans-unit id="c79c85aac54555c7fe4b24d5b33131b97310e7b3" translate="yes" xml:space="preserve">
          <source>For other sized structs and static arrays, the return value is stored through a hidden pointer passed as an argument to the function.</source>
          <target state="translated">다른 크기의 구조체와 정적 배열의 경우 반환 값은 함수에 인수로 전달 된 숨겨진 포인터를 통해 저장됩니다.</target>
        </trans-unit>
        <trans-unit id="c922333737093f82b45fffe13ff631745c29e34e" translate="yes" xml:space="preserve">
          <source>For other types, the argument is built with itself, as in:</source>
          <target state="translated">다른 유형의 경우 인수는 다음과 같이 자체적으로 빌드됩니다.</target>
        </trans-unit>
        <trans-unit id="936523f8bfb5590c510abb12f08771cbe0e0675b" translate="yes" xml:space="preserve">
          <source>For our new type 'this', which is type-constructed from t, fill in the cto, ito, sto, scto, wto shortcuts.</source>
          <target state="translated">t에서 유형으로 구성된 새로운 유형 'this'의 경우 cto, ito, sto, scto, wto 단축키를 입력하십시오.</target>
        </trans-unit>
        <trans-unit id="4b41c44e66bd12d32d9b45595720696363ec412b" translate="yes" xml:space="preserve">
          <source>For popular C libraries, the first place to look for the corresponding D interface file is the &lt;a href=&quot;https://github.com/D-Programming-Deimos/&quot;&gt;Deimos Project&lt;/a&gt;. If it isn't there already, and you write one, please contribute it to the Deimos Project.</source>
          <target state="translated">널리 사용되는 C 라이브러리의 경우 해당 D 인터페이스 파일을 찾는 첫 번째 장소는 &lt;a href=&quot;https://github.com/D-Programming-Deimos/&quot;&gt;Deimos Project&lt;/a&gt; 입니다. 아직 존재하지 않고 작성했다면 Deimos 프로젝트에 공헌하십시오.</target>
        </trans-unit>
        <trans-unit id="dd500fbbdcecf0b15b4a7bec7168a77dbb809b02" translate="yes" xml:space="preserve">
          <source>For precise typing of that area, you can also let the compiler generate the class instance into the DATA segment for you:</source>
          <target state="translated">해당 영역을 정확하게 입력하기 위해 컴파일러가 클래스 인스턴스를 DATA 세그먼트로 생성하도록 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="d95500d6486dd9976894874f4bc1686c74984f1a" translate="yes" xml:space="preserve">
          <source>For pretty-printing a type.</source>
          <target state="translated">예쁘게 인쇄 할 때 사용합니다.</target>
        </trans-unit>
        <trans-unit id="6beaf38011ce8934c0bf0fe14801463a84176de7" translate="yes" xml:space="preserve">
          <source>For printing two types with qualification when necessary.</source>
          <target state="translated">필요한 경우 자격을 갖춘 두 가지 유형을 인쇄합니다.</target>
        </trans-unit>
        <trans-unit id="b457b27aba75e0c9b673db93afc4a6454c8737c9" translate="yes" xml:space="preserve">
          <source>For ranges that do not offer random access, &lt;code&gt;SearchPolicy.linear&lt;/code&gt; is the only policy allowed (and it must be specified explicitly lest it exposes user code to unexpected inefficiencies). For random-access searches, all policies are allowed, and &lt;code&gt;SearchPolicy.binarySearch&lt;/code&gt; is the default.</source>
          <target state="translated">임의 액세스를 제공하지 않는 범위의 경우 &lt;code&gt;SearchPolicy.linear&lt;/code&gt; 가 유일하게 허용되는 정책이며 사용자 코드가 예기치 않은 비 효율성에 노출되지 않도록 명시 적으로 지정해야합니다. 임의 액세스 검색의 경우 모든 정책이 허용되며 &lt;code&gt;SearchPolicy.binarySearch&lt;/code&gt; 가 기본값입니다.</target>
        </trans-unit>
        <trans-unit id="ed3956141d9c50632728180436f8b91fa73ece41" translate="yes" xml:space="preserve">
          <source>For reals, logGamma is equivalent to log(fabs(gamma(x))).</source>
          <target state="translated">실수의 경우 logGamma는 log (fabs (gamma (x)))와 같습니다.</target>
        </trans-unit>
        <trans-unit id="96cc49076f4a58f629be6c15f8c505a83f5ad981" translate="yes" xml:space="preserve">
          <source>For runtime testing to see if certain vector instructions are available, see the functions in &lt;a href=&quot;https://dlang.org/phobos/core_cpuid.html&quot;&gt;core.cpuid&lt;/a&gt;.</source>
          <target state="translated">특정 벡터 명령어를 사용할 수 있는지 확인하기위한 런타임 테스트는 &lt;a href=&quot;https://dlang.org/phobos/core_cpuid.html&quot;&gt;core.cpuid&lt;/a&gt; 의 함수를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="b0f737f02cc74529ec3e1d25c3b2fb5c37d91021" translate="yes" xml:space="preserve">
          <source>For some D implementations, such as a translator from D to C, an inline assembler makes no sense, and need not be implemented. The version statement can be used to account for this:</source>
          <target state="translated">D에서 C 로의 변환기와 같은 일부 D 구현의 경우 인라인 어셈블러가 의미가 없으며 구현할 필요가 없습니다. 버전 설명을 사용하여이를 설명 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="432250ecd3da26b3dac3ea1fed77d588163ee5c7" translate="yes" xml:space="preserve">
          <source>For stateless allocators, this does nothing.</source>
          <target state="translated">상태 비 저장 할당 자에게는이 작업이 수행되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="098a57b35500f4f0a012b83d59f1556df0c13332" translate="yes" xml:space="preserve">
          <source>For statements implement loops with initialization, test, and increment clauses.</source>
          <target state="translated">For 문은 초기화, 테스트 및 증가 절을 사용하여 루프를 구현합니다.</target>
        </trans-unit>
        <trans-unit id="53f702e5ced5b4f4e7dbc696e5107fe16283acd0" translate="yes" xml:space="preserve">
          <source>For static and dynamic arrays, equality is defined as the lengths of the arrays matching, and all the elements are equal.</source>
          <target state="translated">정적 및 동적 배열의 경우, 동일성은 배열의 길이가 일치하는 것으로 정의되며 모든 요소가 동일합니다.</target>
        </trans-unit>
        <trans-unit id="fa40b68079370408167ad68be5b40bbec28bf002" translate="yes" xml:space="preserve">
          <source>For static and dynamic arrays, identity is defined as referring to the same array elements and the same number of elements.</source>
          <target state="translated">정적 및 동적 배열의 경우 동일성은 동일한 배열 요소 및 동일한 수의 요소를 참조하는 것으로 정의됩니다.</target>
        </trans-unit>
        <trans-unit id="0ec6b65a9ed5b90b70c026136f3fd68edfea3f4e" translate="yes" xml:space="preserve">
          <source>For static and dynamic arrays, the result of the relational op is the result of the operator applied to the first non-equal element of the array. If two arrays compare equal, but are of different lengths, the shorter array compares as &quot;less&quot; than the longer array.</source>
          <target state="translated">정적 및 동적 배열의 경우 관계형 op의 결과는 연산자가 배열의 첫 번째 같지 않은 요소에 적용된 결과입니다. 두 배열이 동일하지만 길이가 다른 경우 더 짧은 배열은 더 긴 배열보다 &quot;낮음&quot;으로 비교됩니다.</target>
        </trans-unit>
        <trans-unit id="f2b8a81160066cc4e2c9823b604d02970c2dda27" translate="yes" xml:space="preserve">
          <source>For static arrays:</source>
          <target state="translated">정적 배열의 경우 :</target>
        </trans-unit>
        <trans-unit id="e3e34261f3141bf464d51f74f924244b763433b8" translate="yes" xml:space="preserve">
          <source>For struct objects and floating point values, identity is defined as the bits in the operands being identical.</source>
          <target state="translated">구조체 객체와 부동 소수점 값의 경우 항등은 피연산자의 비트가 동일한 것으로 정의됩니다.</target>
        </trans-unit>
        <trans-unit id="dacb4ed6715c30c5a9147d7fcd6915634bae0082" translate="yes" xml:space="preserve">
          <source>For struct objects, equality means the result of the &lt;a href=&quot;operatoroverloading#equals&quot;&gt;&lt;code&gt;opEquals()&lt;/code&gt; member function&lt;/a&gt;. If an &lt;code&gt;opEquals()&lt;/code&gt; is not provided, equality is defined as the logical product of all equality results of the corresponding object fields.</source>
          <target state="translated">구조체 객체의 경우 항등은 &lt;a href=&quot;operatoroverloading#equals&quot;&gt; &lt;code&gt;opEquals()&lt;/code&gt; 멤버 함수&lt;/a&gt; 의 결과를 의미합니다 . 는 IF &lt;code&gt;opEquals()&lt;/code&gt; 제공되지 않고, 평등 해당 개체의 모든 필드 평등 결과의 논리 곱으로 정의된다.</target>
        </trans-unit>
        <trans-unit id="77b81660c87ba600c859281896d0e680dc7a0639" translate="yes" xml:space="preserve">
          <source>For struct types, operator overloading for the identity assignment is allowed.</source>
          <target state="translated">구조체 유형의 경우 아이디 할당에 대한 연산자 오버로드가 허용됩니다.</target>
        </trans-unit>
        <trans-unit id="7d6ebd4bd1de4cb13975d6ad6d6494f493e36039" translate="yes" xml:space="preserve">
          <source>For structs that do not define &lt;code&gt;toString&lt;/code&gt;, the conversion to string produces the list of fields.</source>
          <target state="translated">&lt;code&gt;toString&lt;/code&gt; 을 정의하지 않은 구조체의 경우 문자열로 변환하면 필드 목록이 생성됩니다.</target>
        </trans-unit>
        <trans-unit id="24c5ae67500605fc6fe25591d513c37d81e53fba" translate="yes" xml:space="preserve">
          <source>For the &quot;this&quot; parameter to member functions</source>
          <target state="translated">멤버 함수에 대한 &quot;this&quot;매개 변수</target>
        </trans-unit>
        <trans-unit id="1c01d80e91a2499949025f2280ab6ed6d2555900" translate="yes" xml:space="preserve">
          <source>For the &lt;code&gt;struct&lt;/code&gt; and &lt;code&gt;union&lt;/code&gt; objects which does not have &lt;code&gt;toString&lt;/code&gt;,</source>
          <target state="translated">를 들어 &lt;code&gt;struct&lt;/code&gt; 와 &lt;code&gt;union&lt;/code&gt; 이없는 객체 &lt;code&gt;toString&lt;/code&gt; 를 ,</target>
        </trans-unit>
        <trans-unit id="4f49cbadbf80fd5534728dbb0a52da7243f0e4cf" translate="yes" xml:space="preserve">
          <source>For the class objects which have input range interface,</source>
          <target state="translated">입력 범위 인터페이스가있는 클래스 객체의 경우</target>
        </trans-unit>
        <trans-unit id="3fe70e23dba2fe2f6a6436972a79f198b1023846" translate="yes" xml:space="preserve">
          <source>For the default implementation, &lt;code&gt;notifyAll&lt;/code&gt;will behave like &lt;code&gt;notify&lt;/code&gt;.</source>
          <target state="translated">기본 구현을 위해, &lt;code&gt;notifyAll&lt;/code&gt; 처럼 행동합니다 &lt;code&gt;notify&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7a32f3e2bbec4c5b80346149779ed01edefc9b85" translate="yes" xml:space="preserve">
          <source>For the expression &lt;code&gt;__traits(compiles, exp)&lt;/code&gt; where &lt;code&gt;exp&lt;/code&gt; is an &lt;code&gt;@property&lt;/code&gt; function, a further check is made to see if the function can be called.</source>
          <target state="translated">발현을 위해 &lt;code&gt;__traits(compiles, exp)&lt;/code&gt; &lt;code&gt;exp&lt;/code&gt; 이다 &lt;code&gt;@property&lt;/code&gt; 의 기능 추가 확인은 함수가 호출 될 수 있는지를 확인하기위한 검사가 행해진 다.</target>
        </trans-unit>
        <trans-unit id="b458b5efdd66ae7f2f84dbe61163a34a752450a1" translate="yes" xml:space="preserve">
          <source>For the expression &lt;code&gt;typeof(exp)&lt;/code&gt; where &lt;code&gt;exp&lt;/code&gt; is an &lt;code&gt;@property&lt;/code&gt; function, the type is the return type of the function, rather than the type of the function.</source>
          <target state="translated">발현 들어 &lt;code&gt;typeof(exp)&lt;/code&gt; 여기서 &lt;code&gt;exp&lt;/code&gt; 인 &lt;code&gt;@property&lt;/code&gt; 의 기능, 종류가 함수의 리턴 타입보다는 기능 유형이다.</target>
        </trans-unit>
        <trans-unit id="4da3489e77815a3f59254a16848fd39b736c2ccf" translate="yes" xml:space="preserve">
          <source>For the given module, perform any post parsing analysis. Certain compiler backends (ie: GDC) have special placeholder modules whose source are empty, but code gets injected immediately after loading.</source>
          <target state="translated">지정된 모듈에 대해 사후 분석 분석을 수행하십시오. 특정 컴파일러 백엔드 (예 : GDC)에는 소스가 비어있는 특수 자리 표시 자 모듈이 있지만로드 후 즉시 코드가 삽입됩니다.</target>
        </trans-unit>
        <trans-unit id="eee09d9bd02ca0e040c01e0c78e4b5fbf6e37934" translate="yes" xml:space="preserve">
          <source>For this CRC32 Digest implementation calling start after default construction is not necessary. Calling start is only necessary to reset the Digest.</source>
          <target state="translated">이 CRC32 다이제스트 구현의 경우 기본 구성 후 start 호출이 필요하지 않습니다. 호출 시작은 다이제스트를 재설정하는 데만 필요합니다.</target>
        </trans-unit>
        <trans-unit id="cffc81d750572e8587c7a4c64f2343abc051fae9" translate="yes" xml:space="preserve">
          <source>For this MD5 Digest implementation calling start after default construction is not necessary. Calling start is only necessary to reset the Digest.</source>
          <target state="translated">이 MD5 다이제스트 구현의 경우 기본 구성 후 start 호출이 필요하지 않습니다. 호출 시작은 다이제스트를 재설정하는 데만 필요합니다.</target>
        </trans-unit>
        <trans-unit id="ed2c37418037d9b0c7a9812c6d18534a64e6ecf7" translate="yes" xml:space="preserve">
          <source>For this RIPEMD160 Digest implementation calling start after default construction is not necessary. Calling start is only necessary to reset the Digest.</source>
          <target state="translated">이 RIPEMD160 다이제스트 구현의 경우 기본 구성 후 start를 호출 할 필요가 없습니다. 호출 시작은 다이제스트를 재설정하는 데만 필요합니다.</target>
        </trans-unit>
        <trans-unit id="249161f18b734896a386ad2283f2254a90cd8dc8" translate="yes" xml:space="preserve">
          <source>For this SHA Digest implementation calling start after default construction is not necessary. Calling start is only necessary to reset the Digest.</source>
          <target state="translated">이 SHA 다이제스트 구현의 경우 기본 구성 후 start 호출이 필요하지 않습니다. 호출 시작은 다이제스트를 재설정하는 데만 필요합니다.</target>
        </trans-unit>
        <trans-unit id="29b834a88118650bc23043a0e1a119bc9548636a" translate="yes" xml:space="preserve">
          <source>For unary &lt;code&gt;-&lt;/code&gt;, &lt;code&gt;onOverflow&lt;/code&gt; is called if &lt;code&gt;lhs == Lhs.min&lt;/code&gt; and &lt;code&gt;Lhs&lt;/code&gt; is a signed type. The function returns &lt;code&gt;Lhs.max&lt;/code&gt;.</source>
          <target state="translated">단항의 경우 &lt;code&gt;-&lt;/code&gt; , &lt;code&gt;onOverflow&lt;/code&gt; 는 경우라고 &lt;code&gt;lhs == Lhs.min&lt;/code&gt; 및 &lt;code&gt;Lhs&lt;/code&gt; 서명 유형입니다. 이 함수는 &lt;code&gt;Lhs.max&lt;/code&gt; 를 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="3735f46e74c34d876c612b5f0d45ae5d470195b4" translate="yes" xml:space="preserve">
          <source>For unsatisfied conditions, the conditionally compiled code need only be syntactically correct. It does not have to be semantically correct.</source>
          <target state="translated">만족스럽지 않은 조건의 경우 조건부로 컴파일 된 코드는 구문 상 정확해야합니다. 의미 적으로 정확할 필요는 없습니다.</target>
        </trans-unit>
        <trans-unit id="cbc5de8d1ef5491a35e3c236ec7889a9c2c4a94d" translate="yes" xml:space="preserve">
          <source>For use by application</source>
          <target state="translated">응용 프로그램에서 사용</target>
        </trans-unit>
        <trans-unit id="e74c782f1ffbeab9de3e921ce4304765a91d12e2" translate="yes" xml:space="preserve">
          <source>For use by application VFS</source>
          <target state="translated">응용 프로그램 VFS에서 사용</target>
        </trans-unit>
        <trans-unit id="3505b0edb5eee92682026f8144fd82b24c70a4f7" translate="yes" xml:space="preserve">
          <source>For use by built-in VFS</source>
          <target state="translated">내장 VFS에서 사용</target>
        </trans-unit>
        <trans-unit id="88dbc145581c8c0573b319436a71bb181cd0808c" translate="yes" xml:space="preserve">
          <source>For use by extension VFS</source>
          <target state="translated">확장 VFS에서 사용</target>
        </trans-unit>
        <trans-unit id="230bac78e67f31568eb4729e25ce498036be0132" translate="yes" xml:space="preserve">
          <source>For user defined types. Should be equivalent to &lt;code&gt;0&lt;/code&gt;.</source>
          <target state="translated">사용자 정의 유형의 경우. &lt;code&gt;0&lt;/code&gt; 과 같아야합니다 .</target>
        </trans-unit>
        <trans-unit id="b5f2524697bf575ce5005555e479cdd81f208227" translate="yes" xml:space="preserve">
          <source>For user-defined types, assignment operator expressions are overloaded separately from the binary operator. Still the left operand must be an lvalue.</source>
          <target state="translated">사용자 정의 형식의 경우 할당 연산자 식은 이진 연산자와 별도로 오버로드됩니다. 여전히 왼쪽 피연산자는 lvalue 여야합니다.</target>
        </trans-unit>
        <trans-unit id="0fb758f20654c3c8f3d278d2ed2c4c22389d5933" translate="yes" xml:space="preserve">
          <source>For using time zones other than local time or UTC, use &lt;a href=&quot;std_datetime_timezone#PosixTimeZone&quot;&gt;&lt;code&gt;std.datetime.timezone.PosixTimeZone&lt;/code&gt;&lt;/a&gt; on Posix systems (or on Windows, if providing the TZ Database files), and use &lt;a href=&quot;std_datetime_timezone#WindowsTimeZone&quot;&gt;&lt;code&gt;std.datetime.timezone.WindowsTimeZone&lt;/code&gt;&lt;/a&gt; on Windows systems. The time in &lt;code&gt;SysTime&lt;/code&gt; is kept internally in hnsecs from midnight, January 1st, 1 A.D. UTC. Conversion error cannot happen when changing the time zone of a &lt;code&gt;SysTime&lt;/code&gt;. &lt;a href=&quot;std_datetime_timezone#LocalTime&quot;&gt;&lt;code&gt;std.datetime.timezone.LocalTime&lt;/code&gt;&lt;/a&gt; is the &lt;a href=&quot;std_datetime_timezone#TimeZone&quot;&gt;&lt;code&gt;std.datetime.timezone.TimeZone&lt;/code&gt;&lt;/a&gt; class which represents the local time, and &lt;code&gt;UTC&lt;/code&gt; is the &lt;a href=&quot;std_datetime_timezone#TimeZone&quot;&gt;&lt;code&gt;std.datetime.timezone.TimeZone&lt;/code&gt;&lt;/a&gt; class which represents UTC. &lt;code&gt;SysTime&lt;/code&gt; uses &lt;a href=&quot;std_datetime_timezone#LocalTime&quot;&gt;&lt;code&gt;std.datetime.timezone.LocalTime&lt;/code&gt;&lt;/a&gt; if no &lt;a href=&quot;std_datetime_timezone#TimeZone&quot;&gt;&lt;code&gt;std.datetime.timezone.TimeZone&lt;/code&gt;&lt;/a&gt; is provided. For more details on time zones, see the documentation for &lt;a href=&quot;std_datetime_timezone#TimeZone&quot;&gt;&lt;code&gt;std.datetime.timezone.TimeZone&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;std_datetime_timezone#PosixTimeZone&quot;&gt;&lt;code&gt;std.datetime.timezone.PosixTimeZone&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;std_datetime_timezone#WindowsTimeZone&quot;&gt;&lt;code&gt;std.datetime.timezone.WindowsTimeZone&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">현지 시간 또는 UTC를 사용 이외의 시간대에 사용하기 위해 &lt;a href=&quot;std_datetime_timezone#PosixTimeZone&quot;&gt; &lt;code&gt;std.datetime.timezone.PosixTimeZone&lt;/code&gt; &lt;/a&gt; POSIX 시스템에서 (또는 Windows에서 TZ 데이터베이스 파일을 제공하는 경우) 및 사용 &lt;a href=&quot;std_datetime_timezone#WindowsTimeZone&quot;&gt; &lt;code&gt;std.datetime.timezone.WindowsTimeZone&lt;/code&gt; &lt;/a&gt; Windows 시스템을. &lt;code&gt;SysTime&lt;/code&gt; 의 시간은 AD UTC 1 월 1 일 자정부터 내부적 으로 hnsecs 로 유지됩니다. &lt;code&gt;SysTime&lt;/code&gt; 의 시간대를 변경할 때 변환 오류가 발생할 수 없습니다 . &lt;a href=&quot;std_datetime_timezone#LocalTime&quot;&gt; &lt;code&gt;std.datetime.timezone.LocalTime&lt;/code&gt; &lt;/a&gt; 은 현지 시간을 나타내는 &lt;a href=&quot;std_datetime_timezone#TimeZone&quot;&gt; &lt;code&gt;std.datetime.timezone.TimeZone&lt;/code&gt; &lt;/a&gt; 클래스이고 &lt;code&gt;UTC&lt;/code&gt; 는 UTC를 나타내는 &lt;a href=&quot;std_datetime_timezone#TimeZone&quot;&gt; &lt;code&gt;std.datetime.timezone.TimeZone&lt;/code&gt; &lt;/a&gt; 클래스입니다. &lt;code&gt;SysTime&lt;/code&gt; 은&lt;a href=&quot;std_datetime_timezone#LocalTime&quot;&gt; &lt;code&gt;std.datetime.timezone.LocalTime&lt;/code&gt; &lt;/a&gt; 이 제공되지 않은 경우&lt;a href=&quot;std_datetime_timezone#TimeZone&quot;&gt; &lt;code&gt;std.datetime.timezone.TimeZone&lt;/code&gt; &lt;/a&gt;표준 시간대에 대한 자세한 내용은&lt;a href=&quot;std_datetime_timezone#TimeZone&quot;&gt; &lt;code&gt;std.datetime.timezone.TimeZone&lt;/code&gt; &lt;/a&gt; ,&lt;a href=&quot;std_datetime_timezone#PosixTimeZone&quot;&gt; &lt;code&gt;std.datetime.timezone.PosixTimeZone&lt;/code&gt; &lt;/a&gt; 및&lt;a href=&quot;std_datetime_timezone#WindowsTimeZone&quot;&gt; &lt;code&gt;std.datetime.timezone.WindowsTimeZone&lt;/code&gt; &lt;/a&gt; 설명서를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="ab8570d227afb15f540b536d5d1262c12c2ed538" translate="yes" xml:space="preserve">
          <source>For very large numbers, consider using the &lt;a href=&quot;http://gmplib.org&quot;&gt;GMP library&lt;/a&gt; instead.</source>
          <target state="translated">매우 많은 수의 경우 대신 &lt;a href=&quot;http://gmplib.org&quot;&gt;GMP 라이브러리&lt;/a&gt; 사용을 고려하십시오 .</target>
        </trans-unit>
        <trans-unit id="eb0aaa1972b9827ddaeaa8c903dd012d64dc52a6" translate="yes" xml:space="preserve">
          <source>For very small x, expm1(x) is more accurate than exp(x)-1.</source>
          <target state="translated">매우 작은 x의 경우 expm1 (x)가 exp (x) -1보다 정확합니다.</target>
        </trans-unit>
        <trans-unit id="f6a75d7a9f98a84894db843b9fa129f7e85e4ad5" translate="yes" xml:space="preserve">
          <source>For very small x, log1p(x) will be more accurate than log(1 + x).</source>
          <target state="translated">매우 작은 x의 경우 log1p (x)가 log (1 + x)보다 정확합니다.</target>
        </trans-unit>
        <trans-unit id="d5e2ba36b5f0fe67d03dfd60aced704179f8dc15" translate="yes" xml:space="preserve">
          <source>For virtual tables.</source>
          <target state="translated">가상 테이블의 경우</target>
        </trans-unit>
        <trans-unit id="9b2f5f01d7f036017bc44e0f5e7dd87067f218dd" translate="yes" xml:space="preserve">
          <source>For when the array has a non-zero initializer.</source>
          <target state="translated">배열에 0이 아닌 이니셜 라이저가있는 경우.</target>
        </trans-unit>
        <trans-unit id="62235af30d4d3e83911b7f668444bdadcbf6e31f" translate="yes" xml:space="preserve">
          <source>For which &lt;code&gt;TargetOS&lt;/code&gt; the flags are applicable</source>
          <target state="translated">어떤 &lt;code&gt;TargetOS&lt;/code&gt; 에 플래그를 적용 할 수 있습니까?</target>
        </trans-unit>
        <trans-unit id="0512a8baa5c7d81d4b0fde3207bf25c16a72e5f5" translate="yes" xml:space="preserve">
          <source>ForStatement</source>
          <target state="translated">ForStatement</target>
        </trans-unit>
        <trans-unit id="2d317e6f14c862c7eb4252c51b1bf37d642b8a8c" translate="yes" xml:space="preserve">
          <source>ForStatements</source>
          <target state="translated">ForStatements</target>
        </trans-unit>
        <trans-unit id="809149a8ad9a0028e99b6a9d68c6c4147cc5a5e7" translate="yes" xml:space="preserve">
          <source>Force all integral errors to fail by printing an error message to &lt;code&gt;stderr&lt;/code&gt; and then abort the program. &lt;code&gt;Abort&lt;/code&gt; is the default second argument for &lt;code&gt;Checked&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;stderr&lt;/code&gt; 에 오류 메시지를 인쇄 한 후 프로그램을 중단하여 모든 오류를 강제로 실패 하십시오. &lt;code&gt;Abort&lt;/code&gt; 은 &lt;code&gt;Checked&lt;/code&gt; 의 기본 두 번째 인수입니다 .</target>
        </trans-unit>
        <trans-unit id="cb769685cb2418f96e7eb5cd6f3bc4bc9cdba76c" translate="yes" xml:space="preserve">
          <source>Force all integral errors to fail by throwing an exception of type &lt;code&gt;Throw.CheckFailure&lt;/code&gt;. The message coming with the error is similar to the one printed by &lt;code&gt;Warn&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Throw.CheckFailure&lt;/code&gt; 유형의 예외를 발생시켜 모든 적분 오류가 발생하지 않도록 합니다. 오류와 함께 제공되는 메시지는 &lt;code&gt;Warn&lt;/code&gt; 이 인쇄 한 메시지와 유사합니다 .</target>
        </trans-unit>
        <trans-unit id="568ec7a75ae095d53209f55c9ce73fe37d60ef50" translate="yes" xml:space="preserve">
          <source>Forces &lt;code&gt;capacity&lt;/code&gt; to at least &lt;code&gt;x&lt;/code&gt; without reducing it.</source>
          <target state="translated">&lt;code&gt;capacity&lt;/code&gt; 을 줄이지 않고 최소 &lt;code&gt;x&lt;/code&gt; 로 강제 설정 합니다.</target>
        </trans-unit>
        <trans-unit id="19149ba839181262b9bdb188174930e36e6f0df9" translate="yes" xml:space="preserve">
          <source>Forces &lt;code&gt;this&lt;/code&gt; to the null state.</source>
          <target state="translated">강제로 &lt;code&gt;this&lt;/code&gt; 널 상태로.</target>
        </trans-unit>
        <trans-unit id="a8db5e83b8a35fac9d3b32ebcc923950ddcc52de" translate="yes" xml:space="preserve">
          <source>Forces a context switch to occur away from the calling fiber and then throws obj in the calling fiber.</source>
          <target state="translated">컨텍스트 전환이 호출 파이버에서 멀어 지도록 강제 한 다음 호출 파이버에서 obj를 던집니다.</target>
        </trans-unit>
        <trans-unit id="2f48cbfa34abf44639ec829c0d55463cc9494c97" translate="yes" xml:space="preserve">
          <source>Forces a context switch to occur away from the calling fiber.</source>
          <target state="translated">컨텍스트 전환이 호출 파이버에서 멀어 지도록 강제 실행합니다.</target>
        </trans-unit>
        <trans-unit id="80579a9d1e587d7b0ea440174e72821dab14c81a" translate="yes" xml:space="preserve">
          <source>Forces a context switch to occur away from the calling thread.</source>
          <target state="translated">컨텍스트 전환이 호출 스레드에서 발생하도록합니다.</target>
        </trans-unit>
        <trans-unit id="13258c0abcfb4cca178a3b35d4e0664b60f42a89" translate="yes" xml:space="preserve">
          <source>Forces any data buffered by the OS to be written to disk. Call &lt;a href=&quot;#flush&quot;&gt;&lt;code&gt;flush&lt;/code&gt;&lt;/a&gt; before calling this function to flush the C &lt;code&gt;FILE&lt;/code&gt; buffers first.</source>
          <target state="translated">OS에 의해 버퍼링 된 데이터를 디스크에 강제로 기록합니다. 전화 &lt;a href=&quot;#flush&quot;&gt; &lt;code&gt;flush&lt;/code&gt; &lt;/a&gt; 는 C 플러시이 함수를 호출하기 전에 &lt;code&gt;FILE&lt;/code&gt; 첫번째 버퍼를.</target>
        </trans-unit>
        <trans-unit id="23e389c62cad5bc7af8046c1d45faa80b7add735" translate="yes" xml:space="preserve">
          <source>Forces free list mode. If already in free list mode, does nothing. Otherwise, sorts the free list accumulated so far and switches strategy for future allocations to KR style.</source>
          <target state="translated">자유 목록 모드를 강제합니다. 이미 사용 가능 목록 모드 인 경우 아무 것도 수행하지 않습니다. 그렇지 않으면 지금까지 누적 된 무료 목록을 정렬하고 향후 할당을위한 전략을 KR 스타일로 전환합니다.</target>
        </trans-unit>
        <trans-unit id="7438f3f3f123487789d348d295cbd3a74e9f3636" translate="yes" xml:space="preserve">
          <source>Forces the number of elements in the container to &lt;code&gt;n&lt;/code&gt;. If the container ends up growing, the added elements are initialized in a container-dependent manner (usually with &lt;code&gt;T.init&lt;/code&gt;).</source>
          <target state="translated">컨테이너의 요소 수를 &lt;code&gt;n&lt;/code&gt; 으로 강제합니다 . 컨테이너가 &lt;code&gt;T.init&lt;/code&gt; 추가 된 요소는 컨테이너에 따라 달라집니다 (일반적으로 T.init 사용 ).</target>
        </trans-unit>
        <trans-unit id="41991c2a7e01e941592d10ca1b4c7b6d194af71f" translate="yes" xml:space="preserve">
          <source>Forcibly deallocates all memory allocated by this allocator, making it available for further allocations. Does not return memory to &lt;code&gt;ParentAllocator&lt;/code&gt;.</source>
          <target state="translated">이 할당자가 할당 한 모든 메모리를 강제로 할당 해제하여 추가 할당에 사용할 수 있도록합니다. &lt;code&gt;ParentAllocator&lt;/code&gt; 에 메모리를 반환하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="e05b71be24859a77e2790b0d8e71bc9f4dd8c1f8" translate="yes" xml:space="preserve">
          <source>Foreach</source>
          <target state="translated">Foreach</target>
        </trans-unit>
        <trans-unit id="24a9bd4ac18d7ddab41be52adbe896067b46f066" translate="yes" xml:space="preserve">
          <source>Foreach Range Methods</source>
          <target state="translated">Foreach 범위 방법</target>
        </trans-unit>
        <trans-unit id="2c53155a2e00768b8f625193cebda30089ce0843" translate="yes" xml:space="preserve">
          <source>Foreach Range Properties</source>
          <target state="translated">Foreach 범위 속성</target>
        </trans-unit>
        <trans-unit id="45b6dd48295de07cd5e6e8af0d02a0aba0d48189" translate="yes" xml:space="preserve">
          <source>Foreach Range Statement</source>
          <target state="translated">Foreach 범위 설명</target>
        </trans-unit>
        <trans-unit id="3e61286776c3201ae4e25284f6e9997d2d997281" translate="yes" xml:space="preserve">
          <source>Foreach Ref Parameters</source>
          <target state="translated">Foreach Ref 파라미터</target>
        </trans-unit>
        <trans-unit id="a6c2c1398fe7e48f653dc8f0a8caddaee072679f" translate="yes" xml:space="preserve">
          <source>Foreach Restrictions</source>
          <target state="translated">Foreach 제한 사항</target>
        </trans-unit>
        <trans-unit id="0553132dc6cdd5f87cabaeda4197e661d068c9f8" translate="yes" xml:space="preserve">
          <source>Foreach Statement</source>
          <target state="translated">Foreach 문</target>
        </trans-unit>
        <trans-unit id="da94ac95aa14d4788d7fd4a24d8272c7d97d35a8" translate="yes" xml:space="preserve">
          <source>Foreach over Arrays</source>
          <target state="translated">배열에 대한 Foreach</target>
        </trans-unit>
        <trans-unit id="b1b911444dc098ad04d8c1492527b6551f0916f7" translate="yes" xml:space="preserve">
          <source>Foreach over Arrays of Characters</source>
          <target state="translated">여러 문자 배열</target>
        </trans-unit>
        <trans-unit id="2a77599ec0f128dc2ac0586f465739ede0b37cd8" translate="yes" xml:space="preserve">
          <source>Foreach over Associative Arrays</source>
          <target state="translated">연관 배열에 대한 Foreach</target>
        </trans-unit>
        <trans-unit id="140fe06b456ed9f1ae3d0c4efbee66b6a7732580" translate="yes" xml:space="preserve">
          <source>Foreach over Delegates</source>
          <target state="translated">위의 대표단</target>
        </trans-unit>
        <trans-unit id="2118d2308b39d4304cee2cfe11851139c70627b5" translate="yes" xml:space="preserve">
          <source>Foreach over Sequences</source>
          <target state="translated">Foreach over 시퀀스</target>
        </trans-unit>
        <trans-unit id="2f65a25f9fa525fd78d322a8ac805a6f39540fba" translate="yes" xml:space="preserve">
          <source>Foreach over Structs and Classes with Ranges</source>
          <target state="translated">범위가있는 구조체와 클래스에 대한 Foreach</target>
        </trans-unit>
        <trans-unit id="3d5dd8a83fe426ccb28e159ceb15528fef952829" translate="yes" xml:space="preserve">
          <source>Foreach over Structs and Classes with opApply</source>
          <target state="translated">opApply를 사용하여 구조체와 클래스에 대해 Foreach</target>
        </trans-unit>
        <trans-unit id="f667fe9347feaa7cb4e621c258d2edcbe22519e9" translate="yes" xml:space="preserve">
          <source>ForeachAggregate</source>
          <target state="translated">ForeachAggregate</target>
        </trans-unit>
        <trans-unit id="df2d328871cd71e3623bbdef344f4992bcecf2e1" translate="yes" xml:space="preserve">
          <source>ForeachRangeStatement &lt;strong id=&quot;rangefe&quot;&gt;rangefe&lt;/strong&gt;;</source>
          <target state="translated">ForeachRangeStatement 범위 &lt;strong id=&quot;rangefe&quot;&gt;fe&lt;/strong&gt; ;</target>
        </trans-unit>
        <trans-unit id="9e19df85959b2b1a13377a372c2de5cdf84d1b37" translate="yes" xml:space="preserve">
          <source>ForeachStatement</source>
          <target state="translated">ForeachStatement</target>
        </trans-unit>
        <trans-unit id="9e64b4731b7dbeb3175b639030eb1b4587e3cf60" translate="yes" xml:space="preserve">
          <source>ForeachStatement &lt;code&gt;fes&lt;/code&gt;</source>
          <target state="translated">ForeachStatement &lt;code&gt;fes&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="3a17c7a682fe18e111c85eb3ffb6f2a4cbaae0f4" translate="yes" xml:space="preserve">
          <source>ForeachStatement &lt;strong id=&quot;aggrfe&quot;&gt;aggrfe&lt;/strong&gt;;</source>
          <target state="translated">ForeachStatement &lt;strong id=&quot;aggrfe&quot;&gt;aggrfe&lt;/strong&gt; ;</target>
        </trans-unit>
        <trans-unit id="1330e14342be598ec267758faf0b9d03bb95ce41" translate="yes" xml:space="preserve">
          <source>ForeachStatement &lt;strong id=&quot;fes&quot;&gt;fes&lt;/strong&gt;;</source>
          <target state="translated">ForeachStatement &lt;strong id=&quot;fes&quot;&gt;fes&lt;/strong&gt; ;</target>
        </trans-unit>
        <trans-unit id="856f0cb9ba209b9b76b5f3f3110e190ba107f316" translate="yes" xml:space="preserve">
          <source>ForeachType</source>
          <target state="translated">ForeachType</target>
        </trans-unit>
        <trans-unit id="9c4e220b832fdde833e953123e22e947e7b36940" translate="yes" xml:space="preserve">
          <source>ForeachType!(PointerTarget!Range)[] &lt;strong id=&quot;array&quot;&gt;array&lt;/strong&gt;(Range)(Range r)</source>
          <target state="translated">ForeachType! (PointerTarget! Range) [] &lt;strong id=&quot;array&quot;&gt;배열&lt;/strong&gt; (범위) (범위 r)</target>
        </trans-unit>
        <trans-unit id="b97cbae09882028f8cf2caca90479d52c2db87df" translate="yes" xml:space="preserve">
          <source>ForeachType!Range[] &lt;strong id=&quot;array&quot;&gt;array&lt;/strong&gt;(Range)(Range r)</source>
          <target state="translated">ForeachType! Range [] &lt;strong id=&quot;array&quot;&gt;배열&lt;/strong&gt; (범위) (범위 r)</target>
        </trans-unit>
        <trans-unit id="6c99353d4eb960ce958a85dea4dafad1de143866" translate="yes" xml:space="preserve">
          <source>ForeachTypeAttribute</source>
          <target state="translated">ForeachTypeAttribute</target>
        </trans-unit>
        <trans-unit id="7ce9ed7c2184e929a253429a20b37b4560fb165d" translate="yes" xml:space="preserve">
          <source>ForeachTypeList</source>
          <target state="translated">ForeachTypeList</target>
        </trans-unit>
        <trans-unit id="3432f720952ad1ef45f41182f803dfead87c5b2b" translate="yes" xml:space="preserve">
          <source>Foreach_reverse Range Methods</source>
          <target state="translated">Foreach_reverse 범위 방법</target>
        </trans-unit>
        <trans-unit id="b050df33fa944ca9312b95dbcf3146816b9fa5f7" translate="yes" xml:space="preserve">
          <source>Foreach_reverse Range Properties</source>
          <target state="translated">Foreach_reverse 범위 속성</target>
        </trans-unit>
        <trans-unit id="4f7e5954df7c830e01a29a86da382389a582afe9" translate="yes" xml:space="preserve">
          <source>Form TypeTuple from the types of the expressions. Assume exps[] is already tuple expanded.</source>
          <target state="translated">식 유형에서 튜플 유형 튜플. exps []가 이미 튜플 확장되었다고 가정합니다.</target>
        </trans-unit>
        <trans-unit id="2d244117783206496417e62aa99112e2aad4b472" translate="yes" xml:space="preserve">
          <source>Form feed (FF) (U+000C).</source>
          <target state="translated">용지 공급 (FF) (U + 000C).</target>
        </trans-unit>
        <trans-unit id="676f10eb2f485163d62fd19ea9c8545ba45ba1b3" translate="yes" xml:space="preserve">
          <source>Formally, the minimum is a value &lt;code&gt;x&lt;/code&gt; in &lt;code&gt;range&lt;/code&gt; such that &lt;code&gt;pred(a, x)&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt; for all values &lt;code&gt;a&lt;/code&gt; in &lt;code&gt;range&lt;/code&gt;. Conversely, the maximum is a value &lt;code&gt;x&lt;/code&gt; in &lt;code&gt;range&lt;/code&gt; such that &lt;code&gt;pred(x, a)&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt; for all values &lt;code&gt;a&lt;/code&gt; in &lt;code&gt;range&lt;/code&gt; (note the swapped arguments to &lt;code&gt;pred&lt;/code&gt;).</source>
          <target state="translated">공식적으로 최소 값이고 &lt;code&gt;x&lt;/code&gt; 의 &lt;code&gt;range&lt;/code&gt; 되도록 &lt;code&gt;pred(a, x)&lt;/code&gt; 되는 &lt;code&gt;false&lt;/code&gt; 모든 값 의 &lt;code&gt;range&lt;/code&gt; . 반대로, 최대 값이며 &lt;code&gt;x&lt;/code&gt; 의 &lt;code&gt;range&lt;/code&gt; 되도록 &lt;code&gt;pred(x, a)&lt;/code&gt; 되는 &lt;code&gt;false&lt;/code&gt; 모든 값 의 &lt;code&gt;range&lt;/code&gt; (의 교환 인자 유의 &lt;code&gt;pred&lt;/code&gt; ). &lt;code&gt;a&lt;/code&gt; &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="041a5dec481d6bf0724caeaa84bc135d7d9062d4" translate="yes" xml:space="preserve">
          <source>Format</source>
          <target state="translated">Format</target>
        </trans-unit>
        <trans-unit id="150d9f841097f64a42b925806fe3290abd9bc35d" translate="yes" xml:space="preserve">
          <source>Format String</source>
          <target state="translated">형식 문자열</target>
        </trans-unit>
        <trans-unit id="683303f489ff84a56879ace6d1310dfe54be7ff4" translate="yes" xml:space="preserve">
          <source>Format a static condition as a tree-like structure, marking failed and bypassed expressions.</source>
          <target state="translated">정적 조건을 트리와 유사한 구조로 형식화하여 실패하고 무시 된 표현식을 표시하십시오.</target>
        </trans-unit>
        <trans-unit id="51e82ebaf2db5ec167460d9fcf90c1ef8ea0f2d7" translate="yes" xml:space="preserve">
          <source>Format arguments into a string.</source>
          <target state="translated">인수를 문자열로 형식화하십시오.</target>
        </trans-unit>
        <trans-unit id="b0fb6e308cc109a50167ee0e6731cc7e72eb7494" translate="yes" xml:space="preserve">
          <source>Format arguments into buffer</source>
          <target state="translated">인수를 버퍼로 포맷</target>
        </trans-unit>
        <trans-unit id="926bb79848aace359e9158738e215805c41e663b" translate="yes" xml:space="preserve">
          <source>Format data into strings.</source>
          <target state="translated">데이터를 문자열로 형식화하십시오.</target>
        </trans-unit>
        <trans-unit id="23e10a3db64de41eba0cd45a912f85a4b56f3f1b" translate="yes" xml:space="preserve">
          <source>Format flags for CustomFloat.</source>
          <target state="translated">CustomFloat의 형식 플래그</target>
        </trans-unit>
        <trans-unit id="9bc6c7decb7638f7f45249d89d49acf2bfdc2a16" translate="yes" xml:space="preserve">
          <source>Format like &lt;code&gt;Tuple!(types)(elements formatted with %s each)&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Tuple!(types)(elements formatted with %s each)&lt;/code&gt; 과 같은 형식입니다 .</target>
        </trans-unit>
        <trans-unit id="02e42cbae72865d54225666f797f795a1b96d6bb" translate="yes" xml:space="preserve">
          <source>Format specifier</source>
          <target state="translated">형식 지정자</target>
        </trans-unit>
        <trans-unit id="c69b10975ea22ae776aa724f607ec9f6aa5721da" translate="yes" xml:space="preserve">
          <source>Format string.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ee3b46d05547f4e1ed0fb6b16e92db78c1a30405" translate="yes" xml:space="preserve">
          <source>Format string. For detailed specification, see &lt;a href=&quot;#formattedWrite&quot;&gt;&lt;code&gt;formattedWrite&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">형식 문자열. 자세한 사양은 &lt;a href=&quot;#formattedWrite&quot;&gt; &lt;code&gt;formattedWrite&lt;/code&gt; 를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="b9e1764b317ef266e49f202653a88a32e68ea2fd" translate="yes" xml:space="preserve">
          <source>Format to a string such as: &lt;code&gt;mymodule.d(655): [numAllocate:21, numAllocateOK:21, bytesAllocated:324202]&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;mymodule.d(655): [numAllocate:21, numAllocateOK:21, bytesAllocated:324202]&lt;/code&gt; 와 같은 문자열로 형식을 지정하십시오 .</target>
        </trans-unit>
        <trans-unit id="e7a8c4c502d36efd7cdb40b63094b0c90409c783" translate="yes" xml:space="preserve">
          <source>FormatChar</source>
          <target state="translated">FormatChar</target>
        </trans-unit>
        <trans-unit id="d7ab63d27b9f2759987e52fd620d64164025e796" translate="yes" xml:space="preserve">
          <source>FormatSpec!Char &lt;code&gt;f&lt;/code&gt;</source>
          <target state="translated">FormatSpec! Char &lt;code&gt;f&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="eb9d269d7b56db9164861bd1ad68cf391c388350" translate="yes" xml:space="preserve">
          <source>FormatSpec!Char &lt;code&gt;fmt&lt;/code&gt;</source>
          <target state="translated">FormatSpec! Char &lt;code&gt;fmt&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="1fcb49409d4c929c4b7d5f9fa3a44391c37114d5" translate="yes" xml:space="preserve">
          <source>FormatSpec!Char &lt;code&gt;spec&lt;/code&gt;</source>
          <target state="translated">FormatSpec! Char &lt;code&gt;spec&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="f215319169c289fbb719f3b0d628a3b737f8eded" translate="yes" xml:space="preserve">
          <source>FormatSpec!Char &lt;strong id=&quot;singleSpec&quot;&gt;singleSpec&lt;/strong&gt;(Char)(Char[] fmt);</source>
          <target state="translated">FormatSpec! Char &lt;strong id=&quot;singleSpec&quot;&gt;singleSpec&lt;/strong&gt; (Char) (Char [] fmt);</target>
        </trans-unit>
        <trans-unit id="ff3a107be5350e9cbdf489fea1b9a3cb189415cc" translate="yes" xml:space="preserve">
          <source>FormatSpec!char &lt;code&gt;fmt&lt;/code&gt;</source>
          <target state="translated">FormatSpec! char &lt;code&gt;fmt&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="d214509fa791f89f2be58f52b1b3767a22ec982d" translate="yes" xml:space="preserve">
          <source>Formats &lt;code&gt;Tuple&lt;/code&gt; with either &lt;code&gt;%s&lt;/code&gt;, &lt;code&gt;%(inner%)&lt;/code&gt; or &lt;code&gt;%(inner%|sep%)&lt;/code&gt;.</source>
          <target state="translated">형식 &lt;code&gt;Tuple&lt;/code&gt; 하나와 &lt;code&gt;%s&lt;/code&gt; , &lt;code&gt;%(inner%)&lt;/code&gt; 또는 &lt;code&gt;%(inner%|sep%)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="36fd923e1d2f6994803ec17defea621b9f080f14" translate="yes" xml:space="preserve">
          <source>Formats and writes its arguments in text format to the OutBuffer, followed by a newline.</source>
          <target state="translated">인수를 텍스트 형식으로 OutBuffer에 형식화하고 그 뒤에 줄 바꾸기를 씁니다.</target>
        </trans-unit>
        <trans-unit id="7071823457762f9707da94f7448fddbd240e7baf" translate="yes" xml:space="preserve">
          <source>Formats and writes its arguments in text format to the OutBuffer.</source>
          <target state="translated">인수를 텍스트 형식으로 OutBuffer에 형식화하고 씁니다.</target>
        </trans-unit>
        <trans-unit id="a51cf9b2e5a5b055fe6bcc1d2693b2624065293b" translate="yes" xml:space="preserve">
          <source>Formats any value into &lt;code&gt;Char&lt;/code&gt; accepting &lt;code&gt;OutputRange&lt;/code&gt;, using the given &lt;code&gt;FormatSpec&lt;/code&gt;.</source>
          <target state="translated">주어진 &lt;code&gt;FormatSpec&lt;/code&gt; 을 사용하여 &lt;code&gt;OutputRange&lt;/code&gt; 를 허용하는 모든 값을 &lt;code&gt;Char&lt;/code&gt; 로 형식화 합니다.</target>
        </trans-unit>
        <trans-unit id="6b1857e4f5a36639d321cc75f53c946b6701eca2" translate="yes" xml:space="preserve">
          <source>Formats its arguments according to the format string and puts them to an OutputRange.</source>
          <target state="translated">형식 문자열에 따라 인수를 형식화하고 OutputRange에 넣습니다.</target>
        </trans-unit>
        <trans-unit id="7b102bb156b0812a82b4b3cc910bf7cff6a74f11" translate="yes" xml:space="preserve">
          <source>Formats supported by Tuple</source>
          <target state="translated">Tuple에서 지원하는 형식</target>
        </trans-unit>
        <trans-unit id="1eebc61a97141f60643e629482bce7edcfb75fe1" translate="yes" xml:space="preserve">
          <source>Formats the &lt;code&gt;Options&lt;/code&gt; for CLI printing.</source>
          <target state="translated">포맷합니다 &lt;code&gt;Options&lt;/code&gt; CLI 인쇄합니다.</target>
        </trans-unit>
        <trans-unit id="026cf84e486080b485be195c8355623b05fc9001" translate="yes" xml:space="preserve">
          <source>Formats the RedBlackTree into a sink function. For more info see &lt;code&gt; std.format.formatValue&lt;/code&gt;. Note that this only is available when the element type can be formatted. Otherwise, the default toString from Object is used.</source>
          <target state="translated">RedBlackTree를 싱크 함수로 포맷합니다. 자세한 정보는 &lt;code&gt; std.format.formatValue&lt;/code&gt; 를 참조하십시오 . 요소 유형을 형식화 할 수있는 경우에만 사용할 수 있습니다. 그렇지 않으면 Object의 기본 toString이 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="1a1c1d1c97be2b241e71fcbcd57b8c7212c71103" translate="yes" xml:space="preserve">
          <source>Formats the stored value as a string.</source>
          <target state="translated">저장된 값을 문자열로 형식화합니다.</target>
        </trans-unit>
        <trans-unit id="ff2a0eb4d03de61d70053787eab6804fcec445da" translate="yes" xml:space="preserve">
          <source>Formatted String Printing Functions</source>
          <target state="translated">형식화 된 문자열 인쇄 기능</target>
        </trans-unit>
        <trans-unit id="fc5187ca67d19625ec5705d6a55febca2c516352" translate="yes" xml:space="preserve">
          <source>Formatted number of arguments.</source>
          <target state="translated">형식화 된 인수 수</target>
        </trans-unit>
        <trans-unit id="dfdf9e737f02222e3b629df49845cd2f57eea582" translate="yes" xml:space="preserve">
          <source>Formatting a struct by defining a method &lt;code&gt;toString&lt;/code&gt;, which takes an output range.  It's recommended that any &lt;code&gt;toString&lt;/code&gt; using &lt;a href=&quot;std_range_primitives#isOutputRange&quot;&gt;output ranges&lt;/a&gt; use &lt;a href=&quot;std_range_primitives#put&quot;&gt;&lt;code&gt;std.range.primitives.put&lt;/code&gt;&lt;/a&gt; rather than use the &lt;code&gt;put&lt;/code&gt; method of the range directly.</source>
          <target state="translated">출력 범위를 취하는 &lt;code&gt;toString&lt;/code&gt; 메소드를 정의하여 구조체를 형식화합니다 . &lt;a href=&quot;std_range_primitives#isOutputRange&quot;&gt;출력 범위를&lt;/a&gt; 사용 하는 모든 &lt;code&gt;toString&lt;/code&gt; 은 범위 의 &lt;code&gt;put&lt;/code&gt; 메소드를 직접 사용하지 않고 &lt;a href=&quot;std_range_primitives#put&quot;&gt; &lt;code&gt;std.range.primitives.put&lt;/code&gt; 을&lt;/a&gt; 사용 하는 것이 좋습니다 .</target>
        </trans-unit>
        <trans-unit id="8e465166e94e67eebeab101e4359626150ec10a5" translate="yes" xml:space="preserve">
          <source>Forms the symbols available to all D programs. Includes Object, which is the root of the class object hierarchy. This module is implicitly imported.</source>
          <target state="translated">모든 D 프로그램에서 사용할 수있는 기호를 형성합니다. 클래스 객체 계층의 루트 인 Object를 포함합니다. 이 모듈은 내재적으로 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="be4f9eeadbcbd0250352284fb3cd5289c89dd0aa" translate="yes" xml:space="preserve">
          <source>Forward range primitive.</source>
          <target state="translated">순방향 범위 기본 요소.</target>
        </trans-unit>
        <trans-unit id="f29ecd0a8c2e85a8dd0a05e6e1849d59d6e26721" translate="yes" xml:space="preserve">
          <source>Forward range primitives.</source>
          <target state="translated">순방향 프리미티브.</target>
        </trans-unit>
        <trans-unit id="0aa520a29c82bb14e915d25c13dc5e309db9aa45" translate="yes" xml:space="preserve">
          <source>Forward range primitives. Always present.</source>
          <target state="translated">순방향 프리미티브. 항상 존재합니다.</target>
        </trans-unit>
        <trans-unit id="d22e131c3ac191040ab33d51c37ffdb89ec4f5bd" translate="yes" xml:space="preserve">
          <source>Forward range primitives. Only present if &lt;code&gt;Source&lt;/code&gt; is a forward range.</source>
          <target state="translated">순방향 프리미티브. &lt;code&gt;Source&lt;/code&gt; 가 순방향 범위 인 경우에만 존재합니다 .</target>
        </trans-unit>
        <trans-unit id="97bc99924d633226857a96f6afec14fc043cb16b" translate="yes" xml:space="preserve">
          <source>Forward range to check for sortedness.</source>
          <target state="translated">정렬을 점검하기위한 정방향 범위.</target>
        </trans-unit>
        <trans-unit id="7657ababded98f92f21842f17fb3c2a8cd28a85d" translate="yes" xml:space="preserve">
          <source>Forward to &lt;code&gt;opSlice().back&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;opSlice().back&lt;/code&gt; 전달하십시오 .</target>
        </trans-unit>
        <trans-unit id="f670785452e24c08e6662a674722599db21dae68" translate="yes" xml:space="preserve">
          <source>Forward to &lt;code&gt;opSlice().front&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;opSlice().front&lt;/code&gt; 전달하십시오 .</target>
        </trans-unit>
        <trans-unit id="406d6f916ef4dc2cf86b7e71d06ceb89e750f775" translate="yes" xml:space="preserve">
          <source>Forward.</source>
          <target state="translated">Forward.</target>
        </trans-unit>
        <trans-unit id="619c49003b4924854c54d8f88890d01e742d1cdb" translate="yes" xml:space="preserve">
          <source>ForwardRange &lt;code&gt;back&lt;/code&gt;</source>
          <target state="translated">ForwardRange &lt;code&gt;back&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="ef30f2488fc02c13b78587f98f5f66b1ed09c755" translate="yes" xml:space="preserve">
          <source>ForwardRange &lt;code&gt;choices&lt;/code&gt;</source>
          <target state="translated">ForwardRange &lt;code&gt;choices&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="073a409c0a0f8fb805007ded8e0840b82337c88e" translate="yes" xml:space="preserve">
          <source>ForwardRange &lt;code&gt;filler&lt;/code&gt;</source>
          <target state="translated">ForwardRange &lt;code&gt;filler&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="d735aafe3953821674bcc047eed0a464f448083f" translate="yes" xml:space="preserve">
          <source>Forwarding</source>
          <target state="translated">Forwarding</target>
        </trans-unit>
        <trans-unit id="59753dcda35fa8785a7cb0df7205b2d4bd41fb72" translate="yes" xml:space="preserve">
          <source>Forwarding ScopeDsymbol. Used by ForwardingAttribDeclaration and ForwardingScopeDeclaration to forward symbol insertions to another scope. See &lt;code&gt;dmd.attrib.ForwardingAttribDeclaration&lt;/code&gt; for more details.</source>
          <target state="translated">전달 범위 기호 ForwardingAttribDeclaration 및 ForwardingScopeDeclaration에서 심볼 삽입을 다른 범위로 전달하는 데 사용됩니다. 자세한 내용은 &lt;code&gt;dmd.attrib.ForwardingAttribDeclaration&lt;/code&gt; 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="a8c3c38ee76d4f3b54240c75f491818942150299" translate="yes" xml:space="preserve">
          <source>ForwardingScopeDsymbol &lt;strong id=&quot;sym&quot;&gt;sym&lt;/strong&gt;;</source>
          <target state="translated">ForwardingScopeDsymbol &lt;strong id=&quot;sym&quot;&gt;sym&lt;/strong&gt; ;</target>
        </trans-unit>
        <trans-unit id="350d94101794444e552e24c257a1f22a4fbe99df" translate="yes" xml:space="preserve">
          <source>ForwardingStatements are distributed over the flattened sequence of statements. This prevents flattening to be &quot;blocked&quot; by a ForwardingStatement and is necessary, for example, to support generating scope guards with `static foreach`:</source>
          <target state="translated">ForwardingStatement는 병합 된 일련의 명령문으로 분산됩니다. 이는 FlatingStatement에 의해 평탄화가 &quot;차단&quot;되는 것을 방지하며, 예를 들어 'static foreach'를 사용하여 스코프 가드 생성을 지원해야합니다.</target>
        </trans-unit>
        <trans-unit id="692658a69283f7fb6a21aa51f11e5d6d2994d5d3" translate="yes" xml:space="preserve">
          <source>Forwards &lt;code&gt;length&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;length&lt;/code&gt; 전달 합니다 .</target>
        </trans-unit>
        <trans-unit id="5654a0e021e96bad526eccdeb7cb0d25a7be5435" translate="yes" xml:space="preserve">
          <source>Forwards each of the methods in &lt;code&gt;funs&lt;/code&gt; (if defined) to &lt;code&gt;member&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;funs&lt;/code&gt; (정의 된 경우)의 각 메소드 를 &lt;code&gt;member&lt;/code&gt; 에 전달 합니다.</target>
        </trans-unit>
        <trans-unit id="e165afdb83bce78d5a7427c72318f24d46092f4d" translate="yes" xml:space="preserve">
          <source>Forwards function arguments while keeping &lt;code&gt;out&lt;/code&gt;, &lt;code&gt;ref&lt;/code&gt;, and &lt;code&gt;lazy&lt;/code&gt; on the parameters.</source>
          <target state="translated">유지하면서 앞으로 인수를 작동 &lt;code&gt;out&lt;/code&gt; , &lt;code&gt;ref&lt;/code&gt; , 그리고 &lt;code&gt;lazy&lt;/code&gt; 매개 변수에.</target>
        </trans-unit>
        <trans-unit id="9385c6728b753fbb370a1c4f1034c150548b8bf1" translate="yes" xml:space="preserve">
          <source>Forwards function arguments while saving ref-ness.</source>
          <target state="translated">참조를 저장하면서 함수 인수를 전달합니다.</target>
        </trans-unit>
        <trans-unit id="9bf1ea57d6c29870d04450f92da2598f5a795126" translate="yes" xml:space="preserve">
          <source>Forwards to &lt;code&gt;alignedAllocate(bytes, platformAlignment)&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;alignedAllocate(bytes, platformAlignment)&lt;/code&gt; 전달합니다 .</target>
        </trans-unit>
        <trans-unit id="e78d71ac4fe9046b06039c1f36978f900fc90d21" translate="yes" xml:space="preserve">
          <source>Forwards to &lt;code&gt;alignedReallocate(b, newSize, platformAlignment)&lt;/code&gt;. Should be used with blocks obtained with &lt;code&gt;allocate&lt;/code&gt; otherwise the custom alignment passed with &lt;code&gt;alignedAllocate&lt;/code&gt; can be lost.</source>
          <target state="translated">이 전진 &lt;code&gt;alignedReallocate(b, newSize, platformAlignment)&lt;/code&gt; . &lt;code&gt;allocate&lt;/code&gt; 얻은 블록과 함께 사용해야합니다. 그렇지 않으면 &lt;code&gt;alignedAllocate&lt;/code&gt; 와 함께 전달 된 사용자 지정 정렬 이 손실 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d788f6c07eb5fb2e6319214dbdc4af6789c0f502" translate="yes" xml:space="preserve">
          <source>Forwards to &lt;code&gt;impl.alignedReallocate&lt;/code&gt; if defined, &lt;code&gt;false&lt;/code&gt; otherwise.</source>
          <target state="translated">정의 된 경우 &lt;code&gt;impl.alignedReallocate&lt;/code&gt; 로 전달하고 그렇지 않으면 &lt;code&gt;false&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="8bd9cee5dc99654ad10a48eac7f3712c848d2492" translate="yes" xml:space="preserve">
          <source>Forwards to &lt;code&gt;impl.empty()&lt;/code&gt; if defined, otherwise returns &lt;code&gt;Ternary.unknown&lt;/code&gt;.</source>
          <target state="translated">정의 된 경우 &lt;code&gt;impl.empty()&lt;/code&gt; 전달하고 그렇지 않으면 &lt;code&gt;Ternary.unknown&lt;/code&gt; 을 리턴합니다 .</target>
        </trans-unit>
        <trans-unit id="acf2453169c3a58c2868738f1fc21eb777d091c4" translate="yes" xml:space="preserve">
          <source>Forwards to &lt;code&gt;insertBack&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;insertBack&lt;/code&gt; 으로 전달합니다 .</target>
        </trans-unit>
        <trans-unit id="60a899e29a86abcd90907c95435a5280010cfeb4" translate="yes" xml:space="preserve">
          <source>Forwards to &lt;code&gt;parent.alignedAllocate&lt;/code&gt;. Affects per instance: &lt;code&gt;numAlignedAllocate&lt;/code&gt;, &lt;code&gt;bytesUsed&lt;/code&gt;, &lt;code&gt;bytesAllocated&lt;/code&gt;, &lt;code&gt;bytesSlack&lt;/code&gt;, &lt;code&gt;numAlignedAllocateOk&lt;/code&gt;, and &lt;code&gt;bytesHighTide&lt;/code&gt;. Affects per call: &lt;code&gt;numAlignedAllocate&lt;/code&gt;, &lt;code&gt;numAlignedAllocateOk&lt;/code&gt;, and &lt;code&gt;bytesAllocated&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;parent.alignedAllocate&lt;/code&gt; 로 전달합니다 . 인스턴스에 미치는 영향 : &lt;code&gt;numAlignedAllocate&lt;/code&gt; , &lt;code&gt;bytesUsed&lt;/code&gt; , &lt;code&gt;bytesAllocated&lt;/code&gt; , &lt;code&gt;bytesSlack&lt;/code&gt; , &lt;code&gt;numAlignedAllocateOk&lt;/code&gt; 및 &lt;code&gt;bytesHighTide&lt;/code&gt; . 호출 당 영향 : &lt;code&gt;numAlignedAllocate&lt;/code&gt; , &lt;code&gt;numAlignedAllocateOk&lt;/code&gt; 및 &lt;code&gt;bytesAllocated&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0de51b91db75956f253cd2e990aebff215db91a5" translate="yes" xml:space="preserve">
          <source>Forwards to &lt;code&gt;parent.allocate&lt;/code&gt;. Affects per instance: &lt;code&gt;numAllocate&lt;/code&gt;, &lt;code&gt;bytesUsed&lt;/code&gt;, &lt;code&gt;bytesAllocated&lt;/code&gt;, &lt;code&gt;bytesSlack&lt;/code&gt;, &lt;code&gt;numAllocateOK&lt;/code&gt;, and &lt;code&gt;bytesHighTide&lt;/code&gt;. Affects per call: &lt;code&gt;numAllocate&lt;/code&gt;, &lt;code&gt; numAllocateOK&lt;/code&gt;, and &lt;code&gt;bytesAllocated&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;parent.allocate&lt;/code&gt; 로 전달합니다 . 인스턴스에 미치는 영향 : &lt;code&gt;numAllocate&lt;/code&gt; , &lt;code&gt;bytesUsed&lt;/code&gt; , &lt;code&gt;bytesAllocated&lt;/code&gt; , &lt;code&gt;bytesSlack&lt;/code&gt; , &lt;code&gt;numAllocateOK&lt;/code&gt; 및 &lt;code&gt;bytesHighTide&lt;/code&gt; . 호출 당 영향 : &lt;code&gt;numAllocate&lt;/code&gt; , &lt;code&gt; numAllocateOK&lt;/code&gt; 및 &lt;code&gt;bytesAllocated&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="dcaf3b31885140c27644f437101ba9113ddebba0" translate="yes" xml:space="preserve">
          <source>Forwards to &lt;code&gt;parent.expand(b, delta)&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;parent.expand(b, delta)&lt;/code&gt; 전달합니다 .</target>
        </trans-unit>
        <trans-unit id="b27aa4f3be329203334bb86f539151cb305c808b" translate="yes" xml:space="preserve">
          <source>Forwards to &lt;code&gt;parent.goodAllocSize&lt;/code&gt; (which accounts for the management overhead).</source>
          <target state="translated">관리 오버 헤드를 설명 하는 &lt;code&gt;parent.goodAllocSize&lt;/code&gt; 로 전달합니다 .</target>
        </trans-unit>
        <trans-unit id="0a8e660798dc338a8a1471f38403abdf431c688a" translate="yes" xml:space="preserve">
          <source>Forwards to &lt;code&gt;parent.owns(b)&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;parent.owns(b)&lt;/code&gt; 전달합니다 .</target>
        </trans-unit>
        <trans-unit id="c49defce19fbb5c360ddd5f8418442bee4a9e756" translate="yes" xml:space="preserve">
          <source>Found function if it satisfies &lt;code&gt;isThis()&lt;/code&gt;, otherwise &lt;code&gt;null&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;isThis()&lt;/code&gt; 만족하면 함수를 찾았습니다 . 그렇지 않으면 &lt;code&gt;null&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="0e5b2644294a615403e1d25df5a0697b50b1f11f" translate="yes" xml:space="preserve">
          <source>Fractional seconds past the second (i.e. the portion of a &lt;a href=&quot;#SysTime&quot;&gt;&lt;code&gt;SysTime&lt;/code&gt;&lt;/a&gt; which is less than a second).</source>
          <target state="translated">초를 지나는 분수 초 (즉, 1 초 미만 의 &lt;a href=&quot;#SysTime&quot;&gt; &lt;code&gt;SysTime&lt;/code&gt; &lt;/a&gt; 부분 ).</target>
        </trans-unit>
        <trans-unit id="379f2457e03cb11d9fb2efb285637d5db4d20d0e" translate="yes" xml:space="preserve">
          <source>Framework Paths</source>
          <target state="translated">프레임 워크 경로</target>
        </trans-unit>
        <trans-unit id="af39dd055c3ef8226fbe929d048cafb094dc8a51" translate="yes" xml:space="preserve">
          <source>Frameworks</source>
          <target state="translated">Frameworks</target>
        </trans-unit>
        <trans-unit id="76f3bbf403c0a1d06091b2e954aa5148b52956ac" translate="yes" xml:space="preserve">
          <source>Free ExceptionHeader that was created by create().</source>
          <target state="translated">create ()로 작성된 무료 ExceptionHeader입니다.</target>
        </trans-unit>
        <trans-unit id="6e84d556b35797f261b67f9c140d77ba6a16046e" translate="yes" xml:space="preserve">
          <source>Free Memory Used By A Database Connection</source>
          <target state="translated">데이터베이스 연결에 사용 된 여유 메모리</target>
        </trans-unit>
        <trans-unit id="ebc0d55c1803ae64cbd97a59b9b2802ad68ac4a1" translate="yes" xml:space="preserve">
          <source>Free a data definition struct.</source>
          <target state="translated">데이터 정의 구조체를 비 웁니다.</target>
        </trans-unit>
        <trans-unit id="b863a7908826b1af85e7908ab51bda44bf1ecda4" translate="yes" xml:space="preserve">
          <source>Free a multipart formpost previously built with curl_formadd().</source>
          <target state="translated">curl_formadd ()로 이전에 빌드 한 멀티 파트 폼 포스트를 해제하십시오.</target>
        </trans-unit>
        <trans-unit id="3195ad8b795496334c672bd13584f65569ba68b7" translate="yes" xml:space="preserve">
          <source>Free a prior allocation</source>
          <target state="translated">사전 할당 해제</target>
        </trans-unit>
        <trans-unit id="b1f545998e095b9a06b4728df726ebf0dad217f2" translate="yes" xml:space="preserve">
          <source>Free blocks have variable size and are linked in a singly-linked list.</source>
          <target state="translated">사용 가능한 블록의 크기는 가변적이며 단일 연결 목록으로 연결됩니다.</target>
        </trans-unit>
        <trans-unit id="2e8b5134a1b2ec3e5e93b6a487571bc8ad9bf630" translate="yes" xml:space="preserve">
          <source>Free free list.</source>
          <target state="translated">무료 무료 목록.</target>
        </trans-unit>
        <trans-unit id="0917613170fb85672a58086626671da808078654" translate="yes" xml:space="preserve">
          <source>Free idxStr using sqlite3_free() if true</source>
          <target state="translated">true 인 경우 sqlite3_free ()를 사용하여 무료 idxStr</target>
        </trans-unit>
        <trans-unit id="98a1ae48a4466ad89a88d462e43c40189625122d" translate="yes" xml:space="preserve">
          <source>Free list built on top of exactly one contiguous block of memory. The block is assumed to have been allocated with &lt;code&gt;ParentAllocator&lt;/code&gt;, and is released in &lt;code&gt;ContiguousFreeList&lt;/code&gt;'s destructor (unless &lt;code&gt;ParentAllocator&lt;/code&gt; is &lt;code&gt;NullAllocator&lt;/code&gt;).</source>
          <target state="translated">정확히 하나의 연속 된 메모리 블록 위에 구축 된 사용 가능 목록. 블록이 할당 된 것으로 가정한다 &lt;code&gt;ParentAllocator&lt;/code&gt; 및 해제에 &lt;code&gt;ContiguousFreeList&lt;/code&gt; (않는 소멸자 &lt;code&gt;ParentAllocator&lt;/code&gt; 가 있다 &lt;code&gt;NullAllocator&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="10d99eecb5370b60ca034187daa4ef1e45d53646" translate="yes" xml:space="preserve">
          <source>Free list.</source>
          <target state="translated">무료 목록.</target>
        </trans-unit>
        <trans-unit id="56d7e4661565975bfba4769fa7e3d64507696d05" translate="yes" xml:space="preserve">
          <source>Free memory allocated by FileName routines</source>
          <target state="translated">FileName 루틴에 의해 할당 된 사용 가능한 메모리</target>
        </trans-unit>
        <trans-unit id="f7c1a4f30544ddc6377c5a280a73f14897416990" translate="yes" xml:space="preserve">
          <source>Free returned value with FileName::free()</source>
          <target state="translated">FileName :: free ()를 사용하여 반환 된 값을 해제</target>
        </trans-unit>
        <trans-unit id="3b18d56d2ee33e5deee0527f6a5620f9d07c8560" translate="yes" xml:space="preserve">
          <source>Free-form syntax, ignores whitespace in pattern, useful for formatting complex regular expressions.</source>
          <target state="translated">자유 형식 구문은 패턴의 공백을 무시하고 복잡한 정규식을 형식화하는 데 유용합니다.</target>
        </trans-unit>
        <trans-unit id="b845fdaff1bf49c014dff506cfa6bdc63dadd835" translate="yes" xml:space="preserve">
          <source>FreeBSD</source>
          <target state="translated">FreeBSD</target>
        </trans-unit>
        <trans-unit id="927e12a7e999b3e0f18d3a882968560f012cc81f" translate="yes" xml:space="preserve">
          <source>FreeBSD-Only</source>
          <target state="translated">FreeBSD-Only</target>
        </trans-unit>
        <trans-unit id="736e4cd346eb715c4446b514550578d814d7d0e0" translate="yes" xml:space="preserve">
          <source>FreeBSD/DragonFlyBSD are the only systems which specifically have a clock set up for this (it has &lt;code&gt;CLOCK_SECOND&lt;/code&gt; to use with &lt;code&gt;clock_gettime&lt;/code&gt; which takes advantage of an in-kernel cached value), but on other systems, the fastest function available will be used, and the resulting &lt;code&gt;SysTime&lt;/code&gt; will be rounded down to the second if the clock that was used gave the time at a more precise resolution. So, it's guaranteed that the time will be given at a precision of one second and it's likely the case that will be faster than &lt;code&gt;ClockType.normal&lt;/code&gt;, since there tend to be several options on a system to get the time at low resolutions, and they tend to be faster than getting the time at high resolutions.</source>
          <target state="translated">FreeBSD / DragonFlyBSD는이를 위해 특별히 클럭을 설정 한 유일한 시스템입니다 (클럭 내 캐시 된 값 을 이용하는 &lt;code&gt;clock_gettime&lt;/code&gt; 과 함께 사용할 &lt;code&gt;CLOCK_SECOND&lt;/code&gt; 가 있음 ). 다른 시스템에서는 가장 빠른 기능이 사용됩니다. 사용 된 클럭이 더 정확한 해상도로 시간을 &lt;code&gt;SysTime&lt;/code&gt; 결과 SysTime 은 초로 반올림됩니다. 따라서 시간은 1 초의 정밀도로 제공되며 시스템에서 저해상도에서 시간을 얻는 여러 옵션이있는 경향이 있기 때문에 &lt;code&gt;ClockType.normal&lt;/code&gt; 보다 빠를 가능성이 높습니다. 고해상도에서 시간을 보내는 것보다 빠른 경향이 있습니다.</target>
        </trans-unit>
        <trans-unit id="a9cdca34912cf1be0977006662f6f41677329f87" translate="yes" xml:space="preserve">
          <source>FreeList shared across threads. Allocation and deallocation are lock-free. The parameters have the same semantics as for &lt;code&gt;FreeList&lt;/code&gt;.</source>
          <target state="translated">스레드간에 FreeList가 공유되었습니다. 할당 및 할당 해제는 잠금이 없습니다. 매개 변수는 &lt;code&gt;FreeList&lt;/code&gt; 와 동일한 의미를 갖습니다 .</target>
        </trans-unit>
        <trans-unit id="ebdbf1c9047d64cde03eaed8b92301afb24c8b3e" translate="yes" xml:space="preserve">
          <source>Freeing all GC allocated memory that has no active pointers to it and do not need destructors to run.</source>
          <target state="translated">활성 포인터가없고 소멸자를 실행할 필요가없는 모든 GC 할당 메모리를 해제합니다.</target>
        </trans-unit>
        <trans-unit id="9c1d262fbf3a7e284bb2c20e67267943ef09c825" translate="yes" xml:space="preserve">
          <source>Freeing any remaining unreachable memory.</source>
          <target state="translated">연결할 수없는 나머지 메모리를 비 웁니다.</target>
        </trans-unit>
        <trans-unit id="b1843177cd4be06555f8650438e2f5cee23b6d7c" translate="yes" xml:space="preserve">
          <source>Frees the memory allocated for &lt;code&gt;x&lt;/code&gt;. If &lt;code&gt;x&lt;/code&gt; is a reference to a class or interface, the memory allocated for the underlying instance is freed. If &lt;code&gt;x&lt;/code&gt; is a pointer, the memory allocated for the pointed-to object is freed. If &lt;code&gt;x&lt;/code&gt; is a built-in array, the memory allocated for the array is freed. If &lt;code&gt;x&lt;/code&gt; does not refer to memory previously allocated with &lt;code&gt;new&lt;/code&gt; (or the lower-level equivalents in the GC API), the behavior is undefined.</source>
          <target state="translated">&lt;code&gt;x&lt;/code&gt; 에 할당 된 메모리를 해제합니다 . &lt;code&gt;x&lt;/code&gt; 가 클래스 또는 인터페이스에 대한 참조 인 경우 기본 인스턴스에 할당 된 메모리가 해제됩니다. 경우 &lt;code&gt;x&lt;/code&gt; 는 포인터이며, 메모리는 지적-에 객체가 해제됩니다에 할당. 경우 &lt;code&gt;x&lt;/code&gt; 되는 내장 된 어레이 배열에 할당 된 메모리가 해제된다. 경우 &lt;code&gt;x&lt;/code&gt; 는 이전에 할당 된 메모리를 참조하지 않는 &lt;code&gt;new&lt;/code&gt; (GC가 API 나 낮은 수준의 당량), 동작은 정의되지 않는다.</target>
        </trans-unit>
        <trans-unit id="3f66052a107eaf9bae7cad0f61fb462f47ec2c47" translate="yes" xml:space="preserve">
          <source>From</source>
          <target state="translated">From</target>
        </trans-unit>
        <trans-unit id="306cb21df3375fca60d15a5cf9f358aab2a447e3" translate="yes" xml:space="preserve">
          <source>From &lt;a href=&quot;#Duration&quot;&gt;&lt;code&gt;Duration&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">에서 &lt;a href=&quot;#Duration&quot;&gt; &lt;code&gt;Duration&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="db2022114f51428d23663985d9512c4f397b106d" translate="yes" xml:space="preserve">
          <source>From &lt;a href=&quot;#FracSec&quot;&gt;&lt;code&gt;FracSec&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">에서 &lt;a href=&quot;#FracSec&quot;&gt; &lt;code&gt;FracSec&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="2dcadc69133dc56548eb2198fe024d580cc53763" translate="yes" xml:space="preserve">
          <source>From &lt;a href=&quot;#TickDuration&quot;&gt;&lt;code&gt;TickDuration&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">에서 &lt;a href=&quot;#TickDuration&quot;&gt; &lt;code&gt;TickDuration&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="9e8638502dca540c07f22be8e25e01957c58dc0f" translate="yes" xml:space="preserve">
          <source>From a postblit perspective, qualifiying the struct definition yields the same result as explicitly qualifying the postblit.</source>
          <target state="translated">포스트 블릿 관점에서, 구조체 정의를 규정하면 포스트 블릿을 명시 적으로 규정하는 것과 동일한 결과를 얻을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a4300cea6afd6c5c0528f1834abaff027668e0ed" translate="yes" xml:space="preserve">
          <source>From units</source>
          <target state="translated">단위에서</target>
        </trans-unit>
        <trans-unit id="87b5b5d7f217c54f10b305679e84d27b0ffddee6" translate="yes" xml:space="preserve">
          <source>Front-end expression rewriting should create temporary variables for non trivial sub-expressions in order to: 1. save evaluation order 2. prevent sharing of sub-expression in AST</source>
          <target state="translated">프론트 엔드 표현식 재 작성은 다음을 수행하기 위해 사소하지 않은 서브 표현식에 대한 임시 변수를 작성해야합니다.</target>
        </trans-unit>
        <trans-unit id="d866f093f3136af5a6cee1f9313a0fdd24da6c23" translate="yes" xml:space="preserve">
          <source>FrontTransversal!(RangeOfRanges, opt) &lt;strong id=&quot;frontTransversal&quot;&gt;frontTransversal&lt;/strong&gt;(TransverseOptions opt = TransverseOptions.assumeJagged, RangeOfRanges)(RangeOfRanges rr);</source>
          <target state="translated">FrontTransversal! (RangeOfRanges, opt) &lt;strong id=&quot;frontTransversal&quot;&gt;frontTransversal&lt;/strong&gt; (TransverseOptions opt = TransverseOptions.assumeJagged, RangeOfRanges) (RangeOfRanges rr);</target>
        </trans-unit>
        <trans-unit id="b96493999dfb84df4fdc104ae8dc68c5ab28eeb6" translate="yes" xml:space="preserve">
          <source>Full Usage Example</source>
          <target state="translated">전체 사용 예</target>
        </trans-unit>
        <trans-unit id="dd2159a885b04c76ad21acb9e9df96e1b3df4a78" translate="yes" xml:space="preserve">
          <source>Full content of the file to be written</source>
          <target state="translated">쓸 파일의 전체 내용</target>
        </trans-unit>
        <trans-unit id="890fb87ee1e5cddd39317993afd9de0de79b7d45" translate="yes" xml:space="preserve">
          <source>Full metaprogramming facilities</source>
          <target state="translated">완전한 메타 프로그래밍 시설</target>
        </trans-unit>
        <trans-unit id="0c7ebd23a12a9077c88a3e9d528a97811a94a547" translate="yes" xml:space="preserve">
          <source>Fully sequenced (acquire + release). Corresponds to &lt;a href=&quot;https://llvm.org/docs/Atomics.html#sequentiallyconsistent&quot;&gt;LLVM AtomicOrdering.SequentiallyConsistent&lt;/a&gt; and C++11/C11 &lt;code&gt;memory_order_seq_cst&lt;/code&gt;.</source>
          <target state="translated">완전히 시퀀싱되었습니다 (획득 + 릴리스). 에 해당하는 &lt;a href=&quot;https://llvm.org/docs/Atomics.html#sequentiallyconsistent&quot;&gt;LLVM AtomicOrdering.SequentiallyConsistent&lt;/a&gt; 및 C ++ 11 / C11의 &lt;code&gt;memory_order_seq_cst&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="244c67389fed3259f84c95197cc9eb3648ddcb0d" translate="yes" xml:space="preserve">
          <source>Fully working example is available at &lt;a href=&quot;#usage-example&quot;&gt;the bottom&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#usage-example&quot;&gt;아래&lt;/a&gt; 에서 완전한 작업 예를 볼 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="d32cb0b70d83396fe47823d8472eaa9476a37437" translate="yes" xml:space="preserve">
          <source>FuncDeclaration &lt;code&gt;f&lt;/code&gt;</source>
          <target state="translated">기능 선언 &lt;code&gt;f&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="46c96c463b9529c91720bbc72354f9466bd3c26f" translate="yes" xml:space="preserve">
          <source>FuncDeclaration &lt;code&gt;fd&lt;/code&gt;</source>
          <target state="translated">기능 선언 &lt;code&gt;fd&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="6fd968926da674858b925b704767caf618b18035" translate="yes" xml:space="preserve">
          <source>FuncDeclaration &lt;code&gt;fdc&lt;/code&gt;</source>
          <target state="translated">기능 선언 &lt;code&gt;fdc&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="85e24cae0141215bceece007770b580c50fd2f38" translate="yes" xml:space="preserve">
          <source>FuncDeclaration &lt;code&gt;func&lt;/code&gt;</source>
          <target state="translated">선언 &lt;code&gt;func&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="7f3b288cb44551e47fdefb27fe0ea167fb4d1483" translate="yes" xml:space="preserve">
          <source>FuncDeclaration &lt;strong id=&quot;buildInv&quot;&gt;buildInv&lt;/strong&gt;(AggregateDeclaration ad, Scope* sc);</source>
          <target state="translated">FuncDeclaration &lt;strong id=&quot;buildInv&quot;&gt;buildInv&lt;/strong&gt; (AggregateDeclaration ad, Scope * sc);</target>
        </trans-unit>
        <trans-unit id="2e19843cd5ed176434a3efaeff7d8bda7426dc57" translate="yes" xml:space="preserve">
          <source>FuncDeclaration &lt;strong id=&quot;buildOpAssign&quot;&gt;buildOpAssign&lt;/strong&gt;(StructDeclaration sd, Scope* sc);</source>
          <target state="translated">FuncDeclaration &lt;strong id=&quot;buildOpAssign&quot;&gt;buildOpAssign&lt;/strong&gt; (StructDeclaration sd, Scope * sc);</target>
        </trans-unit>
        <trans-unit id="03359c276bccc50045b57bc8ace08bc6d8f2ae59" translate="yes" xml:space="preserve">
          <source>FuncDeclaration &lt;strong id=&quot;buildOpEquals&quot;&gt;buildOpEquals&lt;/strong&gt;(StructDeclaration sd, Scope* sc);</source>
          <target state="translated">FuncDeclaration &lt;strong id=&quot;buildOpEquals&quot;&gt;buildOpEquals&lt;/strong&gt; (StructDeclaration sd, Scope * sc);</target>
        </trans-unit>
        <trans-unit id="507d5c363210e3f23b2c42085b0c0ff39e10c2cc" translate="yes" xml:space="preserve">
          <source>FuncDeclaration &lt;strong id=&quot;buildXopCmp&quot;&gt;buildXopCmp&lt;/strong&gt;(StructDeclaration sd, Scope* sc);</source>
          <target state="translated">FuncDeclaration &lt;strong id=&quot;buildXopCmp&quot;&gt;buildXopCmp&lt;/strong&gt; (StructDeclaration sd, Scope * sc);</target>
        </trans-unit>
        <trans-unit id="859ef670635a842eaebad8ac23f82e95392d9e8c" translate="yes" xml:space="preserve">
          <source>FuncDeclaration &lt;strong id=&quot;buildXopEquals&quot;&gt;buildXopEquals&lt;/strong&gt;(StructDeclaration sd, Scope* sc);</source>
          <target state="translated">FuncDeclaration &lt;strong id=&quot;buildXopEquals&quot;&gt;buildXopEquals&lt;/strong&gt; (StructDeclaration sd, Scope * sc);</target>
        </trans-unit>
        <trans-unit id="dc070bb95306fb1a92b40edce98353f4664181ad" translate="yes" xml:space="preserve">
          <source>FuncDeclaration &lt;strong id=&quot;buildXtoHash&quot;&gt;buildXtoHash&lt;/strong&gt;(StructDeclaration sd, Scope* sc);</source>
          <target state="translated">기능 선언 &lt;strong id=&quot;buildXtoHash&quot;&gt;buildXtoHash&lt;/strong&gt; (StructDeclaration sd, Scope * sc);</target>
        </trans-unit>
        <trans-unit id="a30ba00bb5d45e8e8a6da89f6ff22fb9cbecb606" translate="yes" xml:space="preserve">
          <source>FuncDeclaration &lt;strong id=&quot;doHeaderInstantiation&quot;&gt;doHeaderInstantiation&lt;/strong&gt;(TemplateInstance ti, Scope* sc2, FuncDeclaration fd, Type tthis, Expressions* fargs);</source>
          <target state="translated">FuncDeclaration &lt;strong id=&quot;doHeaderInstantiation&quot;&gt;doHeaderInstantiation&lt;/strong&gt; (TemplateInstance ti, Scope * sc2, FuncDeclaration fd, 타입 tthis, Expressions * fargs);</target>
        </trans-unit>
        <trans-unit id="d05a566062ec8864bd0d4c9e283c124ce8c44dfa" translate="yes" xml:space="preserve">
          <source>FuncDeclaration &lt;strong id=&quot;fdensure&quot;&gt;fdensure&lt;/strong&gt;;</source>
          <target state="translated">기능 선언 &lt;strong id=&quot;fdensure&quot;&gt;fdensure&lt;/strong&gt; ;</target>
        </trans-unit>
        <trans-unit id="9e42a220d72031c5ac346bcdb8b0d4dc5655921c" translate="yes" xml:space="preserve">
          <source>FuncDeclaration &lt;strong id=&quot;fdrequire&quot;&gt;fdrequire&lt;/strong&gt;;</source>
          <target state="translated">FuncDeclaration &lt;strong id=&quot;fdrequire&quot;&gt;fdrequire&lt;/strong&gt; ;</target>
        </trans-unit>
        <trans-unit id="d75bdbbe19a26e762aba1b2f76a15fde383c64a0" translate="yes" xml:space="preserve">
          <source>FuncDeclaration &lt;strong id=&quot;hasIdentityOpAssign&quot;&gt;hasIdentityOpAssign&lt;/strong&gt;(AggregateDeclaration ad, Scope* sc);</source>
          <target state="translated">FuncDeclaration &lt;strong id=&quot;hasIdentityOpAssign&quot;&gt;hasIdentityOpAssign&lt;/strong&gt; (AggregateDeclaration ad, Scope * sc);</target>
        </trans-unit>
        <trans-unit id="fb1ead50f11e27697b705598972fc6d1ffead188" translate="yes" xml:space="preserve">
          <source>FuncDeclaration &lt;strong id=&quot;hasThis&quot;&gt;hasThis&lt;/strong&gt;(Scope* sc);</source>
          <target state="translated">기능 선언에는 &lt;strong id=&quot;hasThis&quot;&gt;이것&lt;/strong&gt; (Scope * sc)이 있습니다.</target>
        </trans-unit>
        <trans-unit id="9c8e5d63f59418c4c2add44a220d39f8eb8d7843" translate="yes" xml:space="preserve">
          <source>FuncDeclaration &lt;strong id=&quot;overnext0&quot;&gt;overnext0&lt;/strong&gt;;</source>
          <target state="translated">기능 선언 &lt;strong id=&quot;overnext0&quot;&gt;overnext0&lt;/strong&gt; ;</target>
        </trans-unit>
        <trans-unit id="e92604a27d4e8a86aead189ab657e429f7804d91" translate="yes" xml:space="preserve">
          <source>FuncDeclaration &lt;strong id=&quot;resolveFuncCall&quot;&gt;resolveFuncCall&lt;/strong&gt;(ref const Loc loc, Scope* sc, Dsymbol s, Objects* tiargs, Type tthis, Expressions* fargs, FuncResolveFlag flags);</source>
          <target state="translated">FuncDeclaration &lt;strong id=&quot;resolveFuncCall&quot;&gt;resolveFuncCall&lt;/strong&gt; (참조 const Loc loc, Scope * sc, Dsymbol s, Objects * tiargs, 유형 tthis, Expressions * fargs, FuncResolveFlag 플래그 참조);</target>
        </trans-unit>
        <trans-unit id="6bc7f2dda0d8c4f33d8fa77e2a6866f9c3e063da" translate="yes" xml:space="preserve">
          <source>FuncDeclaration &lt;strong id=&quot;search_toString&quot;&gt;search_toString&lt;/strong&gt;(StructDeclaration sd);</source>
          <target state="translated">FuncDeclaration &lt;strong id=&quot;search_toString&quot;&gt;search_toString&lt;/strong&gt; (StructDeclaration의 SD);</target>
        </trans-unit>
        <trans-unit id="d2f8d9014611a673032f33ed2918b0db3cbea6e7" translate="yes" xml:space="preserve">
          <source>FuncDeclaration of &lt;code&gt;toString()&lt;/code&gt; if found, &lt;code&gt;null&lt;/code&gt; if not</source>
          <target state="translated">발견되면 &lt;code&gt;toString()&lt;/code&gt; FuncDeclaration , 없으면 &lt;code&gt;null&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="0de7865b78f78b6942752a1607fa8f3decdf8f8b" translate="yes" xml:space="preserve">
          <source>FuncDeclarations &lt;strong id=&quot;foverrides&quot;&gt;foverrides&lt;/strong&gt;;</source>
          <target state="translated">FuncDeclarations &lt;strong id=&quot;foverrides&quot;&gt;foverrides&lt;/strong&gt; ;</target>
        </trans-unit>
        <trans-unit id="cefac5fb4c4f6f7aad7982a9de7b94425bbd152a" translate="yes" xml:space="preserve">
          <source>FuncDeclarations &lt;strong id=&quot;siblingCallers&quot;&gt;siblingCallers&lt;/strong&gt;;</source>
          <target state="translated">FuncDeclarations &lt;strong id=&quot;siblingCallers&quot;&gt;siblingCallers&lt;/strong&gt; ;</target>
        </trans-unit>
        <trans-unit id="1147d19864a2f24679061fb745f4f2745312dc4d" translate="yes" xml:space="preserve">
          <source>FuncLiteralDeclaration &lt;code&gt;l1&lt;/code&gt;</source>
          <target state="translated">FuncLiteral 선언 &lt;code&gt;l1&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="34754aacf81ddb7c1a4c8be9c611413058146f76" translate="yes" xml:space="preserve">
          <source>FuncLiteralDeclaration &lt;code&gt;l2&lt;/code&gt;</source>
          <target state="translated">FuncLiteral 선언 &lt;code&gt;l2&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="0df7e78750c597d40962880c788feb5d42d0507c" translate="yes" xml:space="preserve">
          <source>FuncResolveFlag &lt;code&gt;flags&lt;/code&gt;</source>
          <target state="translated">FuncResolveFlag &lt;code&gt;flags&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="8d148d41b57da4467de12a195094eac776bca54d" translate="yes" xml:space="preserve">
          <source>Function Attribute Inference</source>
          <target state="translated">함수 속성 추론</target>
        </trans-unit>
        <trans-unit id="a019467e942226e7593baeafe04451d52208ddbd" translate="yes" xml:space="preserve">
          <source>Function Auxiliary Data</source>
          <target state="translated">기능 보조 데이터</target>
        </trans-unit>
        <trans-unit id="7cb4de12c910c8d000862c6b8806ba33b405085e" translate="yes" xml:space="preserve">
          <source>Function Call Operator Overloading</source>
          <target state="translated">함수 호출 연산자 오버로딩</target>
        </trans-unit>
        <trans-unit id="b257168e280b545833c00a892f5a9654498e1038" translate="yes" xml:space="preserve">
          <source>Function Call Operator Overloading &lt;code&gt;f()&lt;/code&gt;</source>
          <target state="translated">함수 호출 연산자 오버로드 &lt;code&gt;f()&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="287c317aff3ca62b6d115ccce3c3993c93d19bb1" translate="yes" xml:space="preserve">
          <source>Function Calling Conventions</source>
          <target state="translated">함수 호출 규칙</target>
        </trans-unit>
        <trans-unit id="897aa7901cb2b135a5d5c44d09b74d23db3807ca" translate="yes" xml:space="preserve">
          <source>Function Default Arguments</source>
          <target state="translated">함수 기본 인수</target>
        </trans-unit>
        <trans-unit id="95b0294dd891e754097881615649b65fc6ba31c5" translate="yes" xml:space="preserve">
          <source>Function Flags</source>
          <target state="translated">기능 플래그</target>
        </trans-unit>
        <trans-unit id="d8861f5c13214753c72cc4ec28a42da4d33141ab" translate="yes" xml:space="preserve">
          <source>Function Inheritance and Overriding</source>
          <target state="translated">함수 상속과 재정의</target>
        </trans-unit>
        <trans-unit id="5bcb901ef2c2acd0ad4fdd3aaa4dbd63df1c459e" translate="yes" xml:space="preserve">
          <source>Function Literals</source>
          <target state="translated">함수 리터럴</target>
        </trans-unit>
        <trans-unit id="a9ab374cd6bd246bd36d7f40fb0af05f53c4d5a7" translate="yes" xml:space="preserve">
          <source>Function Name</source>
          <target state="translated">기능 이름</target>
        </trans-unit>
        <trans-unit id="84101354a0a57697de0f255638b9cba689a57826" translate="yes" xml:space="preserve">
          <source>Function Overloading</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cec90ffa8d067cfb33c2b7e5ea59f57a4ab51f07" translate="yes" xml:space="preserve">
          <source>Function Parameters</source>
          <target state="translated">기능 매개 변수</target>
        </trans-unit>
        <trans-unit id="27e4c7203c9643477f2a066182da530038d7af91" translate="yes" xml:space="preserve">
          <source>Function Return Values</source>
          <target state="translated">함수 반환 값</target>
        </trans-unit>
        <trans-unit id="564f4636a468d710ec718d52c0a86615388f886e" translate="yes" xml:space="preserve">
          <source>Function Safety</source>
          <target state="translated">기능 안전</target>
        </trans-unit>
        <trans-unit id="89ef743a3244fbdb65d0570367a96fdb2440073a" translate="yes" xml:space="preserve">
          <source>Function Templates</source>
          <target state="translated">함수 템플릿</target>
        </trans-unit>
        <trans-unit id="26851646d4034fb238c1b8a8d1cbdf65764b94ab" translate="yes" xml:space="preserve">
          <source>Function Templates with Auto Ref Parameters</source>
          <target state="translated">자동 기준 파라미터가있는 기능 템플릿</target>
        </trans-unit>
        <trans-unit id="2a828a2f47a94f98e25eacb43fb34ce3a0a927e6" translate="yes" xml:space="preserve">
          <source>Function argument initializes a &lt;code&gt;return&lt;/code&gt; parameter, and that parameter gets assigned to &lt;code&gt;firstArg&lt;/code&gt;. Essentially, treat as &lt;code&gt;firstArg = arg;&lt;/code&gt;</source>
          <target state="translated">함수 인수는 &lt;code&gt;return&lt;/code&gt; 매개 변수를 초기화 하고 해당 매개 변수는 &lt;code&gt;firstArg&lt;/code&gt; 에 할당됩니다 . 본질적으로 &lt;code&gt;firstArg = arg;&lt;/code&gt; 로 취급하십시오 .</target>
        </trans-unit>
        <trans-unit id="87a4aa72b8e4acaa8f362e2eba871dd25b95962b" translate="yes" xml:space="preserve">
          <source>Function attributes</source>
          <target state="translated">기능 속성</target>
        </trans-unit>
        <trans-unit id="a3518d2ba96341cb705a0844010da23ec63c4f60" translate="yes" xml:space="preserve">
          <source>Function attributes are emitted in the order as listed above.</source>
          <target state="translated">함수 속성은 위에 나열된 순서대로 생성됩니다.</target>
        </trans-unit>
        <trans-unit id="090cdc3abee08672ecc88627488c127b4dd88e47" translate="yes" xml:space="preserve">
          <source>Function bodies cannot be empty:</source>
          <target state="translated">함수 본문은 비워 둘 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="5bfbcebae9458d0af9e37589048c8edd93acdcad" translate="yes" xml:space="preserve">
          <source>Function body</source>
          <target state="translated">기능 바디</target>
        </trans-unit>
        <trans-unit id="daa6044eeb443eca769ad767c0b819da1d93de92" translate="yes" xml:space="preserve">
          <source>Function calls to these are generated by the compiler and inserted into the object code.</source>
          <target state="translated">이것에 대한 함수 호출은 컴파일러에 의해 생성되고 객체 코드에 삽입됩니다.</target>
        </trans-unit>
        <trans-unit id="dcd2bd5d9c9b442091f087f1d3ab7d165c7a6f01" translate="yes" xml:space="preserve">
          <source>Function contracts</source>
          <target state="translated">기능 계약</target>
        </trans-unit>
        <trans-unit id="c89b9bb41c4c13c872e30f5eb0bb250a5c580801" translate="yes" xml:space="preserve">
          <source>Function declaration</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dd0e134160bc0255e9ac645522671a4ceac9664b" translate="yes" xml:space="preserve">
          <source>Function for starting to a stop watch time when the function is called and stopping it when its return value goes out of scope and is destroyed.</source>
          <target state="translated">함수가 호출 될 때 감시 중지 시간을 시작하고 반환 값이 범위를 벗어나 파괴 될 때 중지하는 기능입니다.</target>
        </trans-unit>
        <trans-unit id="aae2ba6220f8db51d41c8edbd64b6b01f43243fd" translate="yes" xml:space="preserve">
          <source>Function is a C-style variadic function, which uses &lt;code&gt;core.stdc.stdarg&lt;/code&gt;</source>
          <target state="translated">함수는 C 스타일의 가변 함수이며 &lt;code&gt;core.stdc.stdarg&lt;/code&gt; 를 사용 합니다.</target>
        </trans-unit>
        <trans-unit id="87d2f358ca186efbcb568c16e606003520afa9cd" translate="yes" xml:space="preserve">
          <source>Function is a D-style variadic function, which uses &lt;code&gt;__argptr&lt;/code&gt; and &lt;code&gt;__arguments&lt;/code&gt;.</source>
          <target state="translated">함수는 D 스타일의 가변 함수이며 &lt;code&gt;__argptr&lt;/code&gt; 및 &lt;code&gt;__arguments&lt;/code&gt; 를 사용합니다 .</target>
        </trans-unit>
        <trans-unit id="d3435b54d43e95cebfb7003ed401ba2d6c58be33" translate="yes" xml:space="preserve">
          <source>Function is a typesafe variadic function.</source>
          <target state="translated">함수는 형식이 안전한 가변 함수입니다.</target>
        </trans-unit>
        <trans-unit id="02eaa479f3aca73ffbcbe24d76bdcbcb5f2a00b8" translate="yes" xml:space="preserve">
          <source>Function is not variadic.</source>
          <target state="translated">기능은 가변적이지 않습니다.</target>
        </trans-unit>
        <trans-unit id="f04ac1afcdca4559aaa061f6f7593d6d3478e357" translate="yes" xml:space="preserve">
          <source>Function parameter &lt;code&gt;par&lt;/code&gt; is being initialized to &lt;code&gt;arg&lt;/code&gt;, and &lt;code&gt;par&lt;/code&gt; may escape. Detect if scoped values can escape this way. Print error messages when these are detected.</source>
          <target state="translated">함수 매개 변수 &lt;code&gt;par&lt;/code&gt; 가 &lt;code&gt;arg&lt;/code&gt; 로 초기화되고 있으며 &lt;code&gt;par&lt;/code&gt; 이스케이프 될 수 있습니다. 범위가 지정된 값이 이런 식으로 벗어날 수 있는지 감지합니다. 오류 메시지가 감지되면 인쇄하십시오.</target>
        </trans-unit>
        <trans-unit id="3029155acb4ac5fc232abd3463c11350cc2d960a" translate="yes" xml:space="preserve">
          <source>Function parameter declarations can have default values:</source>
          <target state="translated">함수 매개 변수 선언은 기본값을 가질 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f6a6b4c753629a0ad23be9a19a0def5754916cb7" translate="yes" xml:space="preserve">
          <source>Function parameters can be documented by listing them in a params section. Each line that starts with an identifier followed by an '=' starts a new parameter description. A description can span multiple lines.</source>
          <target state="translated">Function parameters can be documented by listing them in a params section. Each line that starts with an identifier followed by an '=' starts a new parameter description. A description can span multiple lines.</target>
        </trans-unit>
        <trans-unit id="6678c5d32e09052e0172ebd3cea351dcf7ca2766" translate="yes" xml:space="preserve">
          <source>Function parameters: Pident identifier of parameter Ptype type of argument Pelem default value for argument Psym symbol corresponding to Pident when using the parameter list as a symbol table For template-parameter-list: Pident identifier of parameter Ptype if NULL, this is a type-parameter else the type for a parameter-declaration value argument Pelem default value for value argument Pdeftype default value for type-parameter Pptpl template-parameter-list for template-template-parameter Psym default value for template-template-parameter For template-arg-list: (actual arguments) Pident NULL Ptype type-name Pelem expression (either Ptype or Pelem is NULL) Psym SCtemplate for template-template-argument</source>
          <target state="translated">함수 매개 변수 : 매개 변수의 Pident 식별자 Ptype 인수의 유형 Pelem 기본값 Psym 기호 매개 변수 목록을 기호 테이블로 사용할 때 Pident에 해당함 template-parameter-list의 경우 : 매개 변수 Ptype의 Pident ID NULL 인 경우, 매개 변수 else 매개 변수 선언 값 인수의 유형 값 인수의 Pelem 기본값 Pdeftype 유형의 매개 변수의 기본값 Pptpl template-parameter-template-template-parameter의 템플릿 -template-template-parameter의 템플릿 기본값 template-arg-의 경우 list : (실제 인수) Pident NULL Ptype type-name Pelem 식 (Ptype 또는 Pelem은 NULL 임) 템플릿-템플릿 인수에 대한 Psym SCtemplate</target>
        </trans-unit>
        <trans-unit id="4e74811387b8309f2eba7069545da73ad882b5db" translate="yes" xml:space="preserve">
          <source>Function pointers can be passed to functions taking a delegate argument by passing them through the &lt;a href=&quot;https://dlang.org/phobos/std_functional.html#toDelegate&quot;&gt;&lt;code&gt;std.functional.toDelegate&lt;/code&gt;&lt;/a&gt; template, which converts any callable to a delegate without context.</source>
          <target state="translated">함수 포인터는 &lt;a href=&quot;https://dlang.org/phobos/std_functional.html#toDelegate&quot;&gt; &lt;code&gt;std.functional.toDelegate&lt;/code&gt; &lt;/a&gt; 템플릿을 통해 대리자 인수를 사용하여 함수에 전달할 수 있습니다.이 함수 는 호출 가능한 컨텍스트를 컨텍스트없이 대리자로 변환합니다.</target>
        </trans-unit>
        <trans-unit id="2f4d971f1b9568ee68d3c3afd0afa4bb0664e45b" translate="yes" xml:space="preserve">
          <source>Function results are returned from &lt;code&gt;yieldForce&lt;/code&gt;, &lt;code&gt;spinForce&lt;/code&gt; and &lt;code&gt;workForce&lt;/code&gt; by ref. If &lt;code&gt;fun&lt;/code&gt; returns by ref, the reference will point to the returned reference of &lt;code&gt;fun&lt;/code&gt;. Otherwise it will point to a field in this struct.</source>
          <target state="translated">&lt;code&gt;yieldForce&lt;/code&gt; , &lt;code&gt;spinForce&lt;/code&gt; 및 &lt;code&gt;workForce&lt;/code&gt; 로부터 함수 결과가 ref로 리턴 됩니다. 경우 &lt;code&gt;fun&lt;/code&gt; 심판에 의해 반환 기준은 반환 된 참조를 가리 킵니다 &lt;code&gt;fun&lt;/code&gt; . 그렇지 않으면이 구조체의 필드를 가리 킵니다.</target>
        </trans-unit>
        <trans-unit id="c3097f849806cf699273164feb8e2d0ccfb12c15" translate="yes" xml:space="preserve">
          <source>Function return values are considered to be rvalues. This means they cannot be passed by reference to other functions.</source>
          <target state="translated">함수 반환 값은 rvalue로 간주됩니다. 이는 다른 함수를 참조하여 전달할 수 없음을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="828053ed1d877ebcde1ff06a5dea505b651e20d3" translate="yes" xml:space="preserve">
          <source>Function template type parameters that are to be implicitly deduced may not have specializations:</source>
          <target state="translated">암시 적으로 추론되는 함수 템플릿 유형 매개 변수에는 전문화가 없을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a7d00ef56bc1d2f06bd67eb8bc21de19e80c263d" translate="yes" xml:space="preserve">
          <source>Function templates can be explicitly instantiated with a !(</source>
          <target state="translated">함수 템플릿은! (</target>
        </trans-unit>
        <trans-unit id="3b8df2ef7fc72848cf8d0bce3a9220b3a898f0b1" translate="yes" xml:space="preserve">
          <source>Function templates can have their return types deduced based on the &lt;a href=&quot;statement#ReturnStatement&quot;&gt;&lt;i&gt;ReturnStatement&lt;/i&gt;&lt;/a&gt;s in the function, just as with normal functions. See &lt;a href=&quot;https://dlang.org/function.html#auto-functions&quot;&gt;Auto Functions&lt;/a&gt;.</source>
          <target state="translated">함수 템플릿은 일반 함수와 마찬가지로 함수 의 &lt;a href=&quot;statement#ReturnStatement&quot;&gt;&lt;i&gt;ReturnStatement&lt;/i&gt;&lt;/a&gt; 에 따라 반환 유형을 추론 할 수 있습니다 . &lt;a href=&quot;https://dlang.org/function.html#auto-functions&quot;&gt;자동 기능을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="55b6f95d2a2736a8bfaa71fcc12b1d0a3c85769f" translate="yes" xml:space="preserve">
          <source>Function that called &lt;code&gt;_d_HookTraceImpl&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;_d_HookTraceImpl&lt;/code&gt; 을 호출 한 함수</target>
        </trans-unit>
        <trans-unit id="8c7a2db7de16ccd53dc1b73193b31c814b7489e6" translate="yes" xml:space="preserve">
          <source>Function that does not take any parameters</source>
          <target state="translated">매개 변수를 사용하지 않는 기능</target>
        </trans-unit>
        <trans-unit id="85ff978df4b7d827c80c5b427bf2c4db1e2ed45d" translate="yes" xml:space="preserve">
          <source>Function that will be called instead of the internal progress display function. This function should be defined as the curl_progress_callback prototype defines.</source>
          <target state="translated">내부 진행 표시 기능 대신 호출되는 기능. 이 함수는 curl_progress_callback 프로토 타입이 정의한대로 정의해야합니다.</target>
        </trans-unit>
        <trans-unit id="23533f8923b79f1dc08d42a47fdcce75663a40c0" translate="yes" xml:space="preserve">
          <source>Function that will be called to convert from UTF8 (instead of using the iconv calls in libcurl) Note that this is used only for SSL certificate processing</source>
          <target state="translated">libcurl에서 iconv 호출을 사용하는 대신 UTF8에서 변환하기 위해 호출되는 함수 이는 SSL 인증서 처리에만 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="9149aa5e3f56e9141da81bbd147711474255a324" translate="yes" xml:space="preserve">
          <source>Function that will be called to convert from the network encoding (instead of using the iconv calls in libcurl)</source>
          <target state="translated">libcurl에서 iconv 호출을 사용하는 대신 네트워크 인코딩에서 변환하기 위해 호출되는 함수</target>
        </trans-unit>
        <trans-unit id="cffc93dc9124a77261edd44618001f6b42f32854" translate="yes" xml:space="preserve">
          <source>Function that will be called to convert to the network encoding (instead of using the iconv calls in libcurl)</source>
          <target state="translated">libcurl에서 iconv 호출을 사용하는 대신 네트워크 인코딩으로 변환하기 위해 호출되는 함수</target>
        </trans-unit>
        <trans-unit id="53a515cf174973bb65a87a5952e5c03252c9695d" translate="yes" xml:space="preserve">
          <source>Function that will be called to read the input (instead of fread). The parameters will use fread() syntax, make sure to follow them.</source>
          <target state="translated">입력을 읽기 위해 호출되는 함수 (fread 대신). 매개 변수는 fread () 구문을 사용하므로 반드시 따라야합니다.</target>
        </trans-unit>
        <trans-unit id="babcbdb82bd11f7164bb99107054b2a484fb1682" translate="yes" xml:space="preserve">
          <source>Function that will be called to store headers (instead of fwrite). The parameters will use fwrite() syntax, make sure to follow them.</source>
          <target state="translated">fwrite 대신 헤더를 저장하기 위해 호출되는 함수입니다. 매개 변수는 fwrite () 구문을 사용하므로 반드시 따라야합니다.</target>
        </trans-unit>
        <trans-unit id="233d456dba50e927381d10867821a9bfe1f04637" translate="yes" xml:space="preserve">
          <source>Function that will be called to store the output (instead of fwrite). The parameters will use fwrite() syntax, make sure to follow them.</source>
          <target state="translated">fwrite 대신 출력을 저장하기 위해 호출되는 함수입니다. 매개 변수는 fwrite () 구문을 사용하므로 반드시 따라야합니다.</target>
        </trans-unit>
        <trans-unit id="e221c711ff99df59e968c914d1979c6a0ad3ee61" translate="yes" xml:space="preserve">
          <source>Function to apply to each element of range</source>
          <target state="translated">범위의 각 요소에 적용하는 기능</target>
        </trans-unit>
        <trans-unit id="b844384b07c0f5d9caaa10fd46cb397be8c61ded" translate="yes" xml:space="preserve">
          <source>Function to be analyzed</source>
          <target state="translated">분석 할 기능</target>
        </trans-unit>
        <trans-unit id="b78a95743121775c17568fcabf9200b6a902bef0" translate="yes" xml:space="preserve">
          <source>Function to check, followed by a variadic number of function attributes as strings</source>
          <target state="translated">확인할 함수, 문자열로 다양한 함수 속성 수</target>
        </trans-unit>
        <trans-unit id="aefc954f08bca71e2e39ec093b9e23048430f8af" translate="yes" xml:space="preserve">
          <source>Function traits</source>
          <target state="translated">기능 특성</target>
        </trans-unit>
        <trans-unit id="2e40e24355bdf1170d50a1d6ead524ba20679656" translate="yes" xml:space="preserve">
          <source>Function/Delegate literal</source>
          <target state="translated">함수 / 위임 리터럴</target>
        </trans-unit>
        <trans-unit id="8ebd95c8f1ce3b6070bf21aaa16655aa94a89c6b" translate="yes" xml:space="preserve">
          <source>FunctionLiteral</source>
          <target state="translated">FunctionLiteral</target>
        </trans-unit>
        <trans-unit id="a3d450d75bfa53b89f98aa6dae8be36130018cbb" translate="yes" xml:space="preserve">
          <source>FunctionLiteralBody</source>
          <target state="translated">FunctionLiteralBody</target>
        </trans-unit>
        <trans-unit id="79fde2ac8490ff2b99ac9c9890e046fdff6e3659" translate="yes" xml:space="preserve">
          <source>Functionality</source>
          <target state="translated">Functionality</target>
        </trans-unit>
        <trans-unit id="a03b0f45370db4b978978138169257e95bfff4b6" translate="yes" xml:space="preserve">
          <source>Functionality for processing subsequent matches of global regexes via range interface:</source>
          <target state="translated">범위 인터페이스를 통해 전역 정규 표현식의 후속 일치를 처리하는 기능 :</target>
        </trans-unit>
        <trans-unit id="2b961dea1dc0c60ddf9a2c8e9d090f6f7d082483" translate="yes" xml:space="preserve">
          <source>Functions</source>
          <target state="translated">Functions</target>
        </trans-unit>
        <trans-unit id="5687015bfcd81aa78a69312ebd359e3273b183cc" translate="yes" xml:space="preserve">
          <source>Functions Without Bodies</source>
          <target state="translated">시체없는 기능</target>
        </trans-unit>
        <trans-unit id="bba90169e567d9c68b308641b7cc0ffd3300695b" translate="yes" xml:space="preserve">
          <source>Functions and delegates declared at module scope are zero-initialized by default. However both can be initialized to any function pointer (including a function literal). For delegates, the context pointer &lt;code&gt;.ptr&lt;/code&gt; is initialized to null.</source>
          <target state="translated">모듈 범위에서 선언 된 함수 및 대리자는 기본적으로 0으로 초기화됩니다. 그러나 둘 다 함수 리터럴을 포함한 모든 함수 포인터로 초기화 할 수 있습니다. 델리게이트의 경우 컨텍스트 포인터 &lt;code&gt;.ptr&lt;/code&gt; 이 널로 초기화됩니다.</target>
        </trans-unit>
        <trans-unit id="b9443a12c52c106d6f6936a59aa4d60507110962" translate="yes" xml:space="preserve">
          <source>Functions and types that manipulate built-in arrays and associative arrays.</source>
          <target state="translated">내장 배열 및 연관 배열을 조작하는 함수 및 유형</target>
        </trans-unit>
        <trans-unit id="1fcc64ae1b70c55efc217545c066c056d0513c2e" translate="yes" xml:space="preserve">
          <source>Functions and variables specific to interface with extern(C++) ABI.</source>
          <target state="translated">extern (C ++) ABI와의 인터페이스에 특정한 함수 및 변수.</target>
        </trans-unit>
        <trans-unit id="fd8851f8cc2c81bc5719fd2159093b00e7797298" translate="yes" xml:space="preserve">
          <source>Functions and variables specific to interfacing with extern(C) ABI.</source>
          <target state="translated">extern (C) ABI와의 인터페이스에 특정한 기능 및 변수.</target>
        </trans-unit>
        <trans-unit id="7f5a53c5e8af7e00f9774b9397648dd6e21fd328" translate="yes" xml:space="preserve">
          <source>Functions are never inlined.</source>
          <target state="translated">함수는 인라인되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="4713c57b4dfbd0d2f4ef062d96b18f64a40c55bc" translate="yes" xml:space="preserve">
          <source>Functions are overloaded based on how well the arguments to a function can match up with the parameters. The function with the</source>
          <target state="translated">함수에 대한 인수가 매개 변수와 얼마나 잘 일치하는지에 따라 함수가 오버로드됩니다. 기능</target>
        </trans-unit>
        <trans-unit id="a7f661a74f02a377df2091c16fea97336e40806f" translate="yes" xml:space="preserve">
          <source>Functions as Array Properties</source>
          <target state="translated">배열 속성으로서의 기능</target>
        </trans-unit>
        <trans-unit id="e47c1a27abfc73a2fed656e28cc0a5aa9ab7a938" translate="yes" xml:space="preserve">
          <source>Functions can also be declared as &lt;code&gt;ref&lt;/code&gt;, meaning their return value is passed by reference:</source>
          <target state="translated">함수는 &lt;code&gt;ref&lt;/code&gt; 로 선언 될 수도 있습니다 . 즉, 반환 값이 참조로 전달됩니다.</target>
        </trans-unit>
        <trans-unit id="fc9e94fc77751f7a520ef1950989f7a0e1c7828b" translate="yes" xml:space="preserve">
          <source>Functions can be nested within member functions:</source>
          <target state="translated">함수는 멤버 함수 내에 중첩 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7e69a10d10797495520ab6d16edfbd50e9742682" translate="yes" xml:space="preserve">
          <source>Functions declared at the same scope overload against each other, and are called an</source>
          <target state="translated">동일한 범위에서 서로에 대해 과부하로 선언 된 함수를</target>
        </trans-unit>
        <trans-unit id="c566e2fda222bdb6e383ab5ff3c3433df764aa7f" translate="yes" xml:space="preserve">
          <source>Functions defined with non-D linkage cannot be overloaded. This is because the name mangling might not take the parameter types into account.</source>
          <target state="translated">비 D 연결로 정의 된 함수는 오버로드 할 수 없습니다. 이름 변경은 매개 변수 유형을 고려하지 않을 수 있기 때문입니다.</target>
        </trans-unit>
        <trans-unit id="988f1aa7ff1ca669378942571abfebb6288e682f" translate="yes" xml:space="preserve">
          <source>Functions executed via CTFE can give different results from run time in the following scenarios:</source>
          <target state="translated">CTFE를 통해 실행되는 함수는 다음 시나리오에서 런타임과 다른 결과를 제공 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="419aab857f4bb8c6136ba89e91fb3714fd5cb75f" translate="yes" xml:space="preserve">
          <source>Functions for starting and interacting with other processes, and for working with the current process' execution environment.</source>
          <target state="translated">다른 프로세스를 시작하고 다른 프로세스와 상호 작용하고 현재 프로세스의 실행 환경과 작업하기위한 기능</target>
        </trans-unit>
        <trans-unit id="50b5e5b232695481bdd4d283f8038b839689e2f6" translate="yes" xml:space="preserve">
          <source>Functions marked as &lt;code&gt;final&lt;/code&gt; may not be overridden in a derived class, unless they are also &lt;code&gt;private&lt;/code&gt;. For example:</source>
          <target state="translated">&lt;code&gt;final&lt;/code&gt; 로 표시된 함수 는 &lt;code&gt;private&lt;/code&gt; 이 아닌 한 파생 클래스에서 재정의 될 수 없습니다 . 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="c40c48a24043c849a46e19c95c7d6f6bb43d3af4" translate="yes" xml:space="preserve">
          <source>Functions may be nested within other functions:</source>
          <target state="translated">함수는 다른 함수 내에 중첩 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ab842017af8570439bf6ba4b27c54b5312a024b2" translate="yes" xml:space="preserve">
          <source>Functions nested inside safe functions default to being safe functions.</source>
          <target state="translated">안전 기능 내에 중첩 된 기능은 기본적으로 안전 기능입니다.</target>
        </trans-unit>
        <trans-unit id="e7c3eeba379274331a0b9c881db32559bea140a9" translate="yes" xml:space="preserve">
          <source>Functions taking a variable number of arguments are called variadic functions. A variadic function can take one of three forms:</source>
          <target state="translated">가변 개수의 인수를 취하는 함수를 가변 함수라고합니다. variadic 함수는 다음 세 가지 형식 중 하나를 취할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2f8dcbed7cf260c12b9f8f40b2d592ffce349a24" translate="yes" xml:space="preserve">
          <source>Functions that deal with mutable, const, or immutable types with equanimity often need to transmit their type to the return value:</source>
          <target state="translated">동일성을 갖는 변경 가능, const 또는 변경 불가능한 유형을 처리하는 함수는 종종 해당 유형을 리턴 값으로 전송해야합니다.</target>
        </trans-unit>
        <trans-unit id="8cc0d5a6974c142e0e42bd69101ee5cdc41acf88" translate="yes" xml:space="preserve">
          <source>Functions that manipulate other functions.</source>
          <target state="translated">다른 기능을 조작하는 기능.</target>
        </trans-unit>
        <trans-unit id="9283433eaa6818c4d57146ef0bb556e3d0ffc12f" translate="yes" xml:space="preserve">
          <source>Functions which are both portable and free of global side-effects can be executed at compile time. In certain contexts, such compile time execution is guaranteed. It is called Compile Time Function Execution (CTFE) then. The contexts that trigger CTFE are:</source>
          <target state="translated">이식 가능하고 전역 부작용이없는 기능은 컴파일 타임에 실행될 수 있습니다. 특정 상황에서 이러한 컴파일 시간 실행이 보장됩니다. 그런 다음 CTFE (Compile Time Function Execution)라고합니다. CTFE를 트리거하는 컨텍스트는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="670fb705837790471a38cafc20ec80fbf30c8bf6" translate="yes" xml:space="preserve">
          <source>Functions which operate on ASCII characters.</source>
          <target state="translated">ASCII 문자에서 작동하는 기능.</target>
        </trans-unit>
        <trans-unit id="7c0d365cb94dab42778d857cad063abfc3d8f3b6" translate="yes" xml:space="preserve">
          <source>Functions with &lt;code&gt;Objective-C&lt;/code&gt; linkage has an additional hidden, unnamed, parameter which is the selector it was called with.</source>
          <target state="translated">&lt;code&gt;Objective-C&lt;/code&gt; 연계 기능이있는 함수에는 이름이 지정되지 않은 추가 숨겨진 매개 변수가 있으며이 매개 변수는 호출 된 선택기입니다.</target>
        </trans-unit>
        <trans-unit id="ffbb7352ab0b0a6abe4eb4d50fb47e8061479506" translate="yes" xml:space="preserve">
          <source>Functions with non-D linkage cannot be virtual and hence cannot be overridden.</source>
          <target state="translated">D 연결이 아닌 함수는 가상 일 수 없으므로 재정의 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="2adb6747d6f26e87d983ed577d7da81919733d7b" translate="yes" xml:space="preserve">
          <source>Functions without bodies:</source>
          <target state="translated">신체가없는 기능 :</target>
        </trans-unit>
        <trans-unit id="d783b16a7b27b910940b783d5fcc870c6c683d47" translate="yes" xml:space="preserve">
          <source>Fundamental Unicode algorithms and data structures.</source>
          <target state="translated">기본 유니 코드 알고리즘 및 데이터 구조</target>
        </trans-unit>
        <trans-unit id="ba469f1bc17cb15fca5f5581188a0b34ac4471eb" translate="yes" xml:space="preserve">
          <source>Furthermore, even with orderable types, the order relation may not be linear. For example, one may define an ordering on sets via the subset relation, such that &lt;code&gt;x &amp;lt; y&lt;/code&gt; is true if &lt;code&gt;x&lt;/code&gt; is a (strict) subset of &lt;code&gt;y&lt;/code&gt;. If &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; are disjoint sets, then neither &lt;code&gt;x &amp;lt; y&lt;/code&gt; nor &lt;code&gt;y &amp;lt; x&lt;/code&gt; holds, but that does not imply that &lt;code&gt;x == y&lt;/code&gt;. Thus, it is insufficient to determine equality purely based on &lt;code&gt;opCmp&lt;/code&gt; alone. For this reason, &lt;code&gt;opCmp&lt;/code&gt; is only used for the inequality operators &lt;code&gt;&amp;lt;&lt;/code&gt;, &lt;code&gt;&amp;lt;=&lt;/code&gt;, &lt;code&gt;&amp;gt;=&lt;/code&gt;, and &lt;code&gt;&amp;gt;&lt;/code&gt;. The equality operators &lt;code&gt;==&lt;/code&gt; and &lt;code&gt;!=&lt;/code&gt; always employ &lt;code&gt;opEquals&lt;/code&gt; instead.</source>
          <target state="translated">또한 주문 가능한 유형의 경우에도 주문 관계는 선형이 아닐 수 있습니다. 예를 들어, 하나가되도록, 상기 서브 세트 관계를 통해 세트에 순서를 정의 할 수있다 &lt;code&gt;x &amp;lt; y&lt;/code&gt; 있는 경우 true &lt;code&gt;x&lt;/code&gt; 의 (엄격한) 부분이고 &lt;code&gt;y&lt;/code&gt; . 경우 &lt;code&gt;x&lt;/code&gt; 및 &lt;code&gt;y&lt;/code&gt; 개별 세트이다 후도 &lt;code&gt;x &amp;lt; y&lt;/code&gt; 나 &lt;code&gt;y &amp;lt; x&lt;/code&gt; 보유하고 있지만, 그 것을 의미하지는 않으며 &lt;code&gt;x == y&lt;/code&gt; . 따라서 &lt;code&gt;opCmp&lt;/code&gt; 만으로 만 순등 을 결정하는 것만으로는 충분하지 않습니다 . 이러한 이유로 &lt;code&gt;opCmp&lt;/code&gt; 는 부등호 연산자 &lt;code&gt;&amp;lt;&lt;/code&gt; , &lt;code&gt;&amp;lt;=&lt;/code&gt; , &lt;code&gt;&amp;gt;=&lt;/code&gt; 및 &lt;code&gt;&amp;gt;&lt;/code&gt; . 동등 연산자 &lt;code&gt;==&lt;/code&gt; 및 &lt;code&gt;!=&lt;/code&gt; 항상 대신 &lt;code&gt;opEquals&lt;/code&gt; 를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="869bc7df187eb57c1861571c27bf80367e22db67" translate="yes" xml:space="preserve">
          <source>Furthermore, predefined version identifiers from this list cannot be set from the command line or from version statements. (This prevents things like both &lt;code&gt;Windows&lt;/code&gt; and &lt;code&gt;linux&lt;/code&gt; being simultaneously set.)</source>
          <target state="translated">또한이 목록의 사전 정의 된 버전 ID는 명령 행 또는 버전 명령문에서 설정할 수 없습니다. (이것은 &lt;code&gt;Windows&lt;/code&gt; 와 &lt;code&gt;linux&lt;/code&gt; 모두 가 동시에 설정되는 것을 방지 합니다.)</target>
        </trans-unit>
        <trans-unit id="2b04009b8ca8039e0507f25a9f0361986b70a3e6" translate="yes" xml:space="preserve">
          <source>Future policies may offer a more even balance between reader and writer precedence.</source>
          <target state="translated">미래의 정책은 독자와 작가 우선 순위 사이의 균형을보다 균등하게 제공 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="99d254d35351117c9cff18872b82ba6d91c00e60" translate="yes" xml:space="preserve">
          <source>G &lt;code&gt;n&lt;/code&gt;</source>
          <target state="translated">G의 &lt;code&gt;n&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="227e2edf0447cd04a773c3b823f1c89795158178" translate="yes" xml:space="preserve">
          <source>GC &lt;strong id=&quot;createGCInstance&quot;&gt;createGCInstance&lt;/strong&gt;(string name);</source>
          <target state="translated">GC &lt;strong id=&quot;createGCInstance&quot;&gt;createGCInstance&lt;/strong&gt; (문자열 이름);</target>
        </trans-unit>
        <trans-unit id="17686e6502ad0f3cdaf4206e0191cbc522cc8283" translate="yes" xml:space="preserve">
          <source>GC FAQ</source>
          <target state="translated">GC FAQ</target>
        </trans-unit>
        <trans-unit id="2715953d0812423734ebffeea6a105ce46d2c5b2" translate="yes" xml:space="preserve">
          <source>GC allocated string</source>
          <target state="translated">GC 할당 문자열</target>
        </trans-unit>
        <trans-unit id="8b2c6daf9a150d506a85e85cb9bcb053667888f2" translate="yes" xml:space="preserve">
          <source>GC allocated string with spaces replaced with tabs; use &lt;a href=&quot;#entabber&quot;&gt;&lt;code&gt;entabber&lt;/code&gt;&lt;/a&gt; to not allocate.</source>
          <target state="translated">공백이있는 GC 할당 문자열이 탭으로 대체되었습니다. 할당하지 않으 려면 &lt;a href=&quot;#entabber&quot;&gt; &lt;code&gt;entabber&lt;/code&gt; &lt;/a&gt; 를 사용 하십시오 .</target>
        </trans-unit>
        <trans-unit id="86e1b687d8486a9dcb7b4165bc8e5226d854f2c7" translate="yes" xml:space="preserve">
          <source>GC allocated string with tabs replaced with spaces</source>
          <target state="translated">공백이있는 탭이있는 GC 할당 문자열</target>
        </trans-unit>
        <trans-unit id="6b9746104b4c3bc7be22e5b6d74741bddee5a6bf" translate="yes" xml:space="preserve">
          <source>GC implementations are added to a registry that allows to supply more implementations by just linking them into the binary. To do so add a function that is executed before the D runtime initialization using &lt;code&gt;pragma(crt_constructor)&lt;/code&gt;:</source>
          <target state="translated">GC 구현은 레지스트리에 추가되어 더 많은 구현을 바이너리에 연결함으로써 더 많은 구현을 제공 할 수 있습니다. &lt;code&gt;pragma(crt_constructor)&lt;/code&gt; 사용하여 D 런타임 초기화 전에 실행되는 함수를 추가하십시오 .</target>
        </trans-unit>
        <trans-unit id="5951ff6858fe229e78c3aef61db342f3d5f757a1" translate="yes" xml:space="preserve">
          <source>GC scan hook, called FOR each thread. Can be used to scan additional thread local memory.</source>
          <target state="translated">각 스레드에 대해 호출되는 GC 스캔 후크. 추가 스레드 로컬 메모리를 스캔하는 데 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="44da27f9ddec555cbd5fcd60022e2b6c8808bbdc" translate="yes" xml:space="preserve">
          <source>GC sweep hook, called FOR each thread. Can be used to free additional thread local memory or associated data structures. Note that only memory allocated from the GC can have marks.</source>
          <target state="translated">각 스레드마다 호출되는 GC 스윕 후크. 추가 스레드 로컬 메모리 또는 관련 데이터 구조를 해제하는 데 사용할 수 있습니다. GC에서 할당 된 메모리에만 마크가있을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="152e90dd32518be928b899f58b1e3835f65ca8cc" translate="yes" xml:space="preserve">
          <source>GCFactory &lt;code&gt;factory&lt;/code&gt;</source>
          <target state="translated">GC &lt;code&gt;factory&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="04a69c000934b632336629d0d827590961013d5f" translate="yes" xml:space="preserve">
          <source>GDC (GNU D Compiler) is the compiler</source>
          <target state="translated">GDC (GNU D Compiler)는 컴파일러입니다</target>
        </trans-unit>
        <trans-unit id="c6b9fdbe9b835ce607d5f9465603dc2e9dd09b8c" translate="yes" xml:space="preserve">
          <source>GNU D Compiler (GDC)</source>
          <target state="translated">GNU D 컴파일러 (GDC)</target>
        </trans-unit>
        <trans-unit id="1ced0cf23647bda25b46395cd7423d5899e8cec5" translate="yes" xml:space="preserve">
          <source>GNU Hurd</source>
          <target state="translated">GNU 허드</target>
        </trans-unit>
        <trans-unit id="c9744a883d88a359c771c7c407727c811697e7d9" translate="yes" xml:space="preserve">
          <source>GSS-Negotiate</source>
          <target state="translated">GSS-Negotiate</target>
        </trans-unit>
        <trans-unit id="649101d4277d8226d1453ed4ac0ae23fef3f6651" translate="yes" xml:space="preserve">
          <source>GapWeightedSimilarityIncremental!(R, F) &lt;strong id=&quot;gapWeightedSimilarityIncremental&quot;&gt;gapWeightedSimilarityIncremental&lt;/strong&gt;(R, F)(R r1, R r2, F penalty);</source>
          <target state="translated">GapWeightedSimilarityIncremental! (R, F) &lt;strong id=&quot;gapWeightedSimilarityIncremental&quot;&gt;간격 WeightedSimilarityIncremental&lt;/strong&gt; (R, F) (R r1, R r2, F 페널티);</target>
        </trans-unit>
        <trans-unit id="5b32b8542e4c8854b05455c0b114c2bdced713ad" translate="yes" xml:space="preserve">
          <source>Garbage Collection</source>
          <target state="translated">가비지 콜렉션</target>
        </trans-unit>
        <trans-unit id="b68927a1fc8d1a3e9f2d3afdf28381f11e58bc69" translate="yes" xml:space="preserve">
          <source>Garbage Collection: Algorithms for Automatic Dynamic Memory Management</source>
          <target state="translated">가비지 콜렉션 : 자동 동적 메모리 관리를위한 알고리즘</target>
        </trans-unit>
        <trans-unit id="26ed33deae58e27843afa7f067144cf4cc6aa56f" translate="yes" xml:space="preserve">
          <source>Garbage collected programs are faster to develop and debug, because there's no need for developing, debugging, testing, or maintaining the explicit deallocation code.</source>
          <target state="translated">가비지 수집 프로그램은 명시 적 할당 해제 코드를 개발, 디버깅, 테스트 또는 유지 관리 할 필요가 없기 때문에 개발 및 디버깅 속도가 더 빠릅니다.</target>
        </trans-unit>
        <trans-unit id="b5b34cabae6ba38a27f9919e85bfc06a08059602" translate="yes" xml:space="preserve">
          <source>Garbage collected programs are often faster. This is counterintuitive, but the reasons are:</source>
          <target state="translated">가비지 수집 프로그램은 종종 더 빠릅니다. 이것은 직관적이지 않지만 그 이유는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="a8b92a6daa02321044a81fa8b11e153716774a33" translate="yes" xml:space="preserve">
          <source>Garbage collected programs do not suffer from gradual deterioration due to an accumulation of memory leaks.</source>
          <target state="translated">가비지 수집 프로그램은 메모리 누수가 누적되어 점진적으로 저하되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="7b3b619bb8bd26c9ff456e8cbc3e5bc6b3b1d018" translate="yes" xml:space="preserve">
          <source>Garbage collected programs have fewer hard-to-find pointer bugs. This is because there are no dangling references to freed memory. There is no code to explicitly manage memory, hence no bugs in such code.</source>
          <target state="translated">가비지 수집 프로그램은 찾기 어려운 포인터 버그가 적습니다. 해제 된 메모리에 매달려있는 참조가 없기 때문입니다. 메모리를 명시 적으로 관리하는 코드가 없으므로 이러한 코드에는 버그가 없습니다.</target>
        </trans-unit>
        <trans-unit id="6274199ad9ef2c79ed1df932fffcb7da577e7439" translate="yes" xml:space="preserve">
          <source>Garbage collection doesn't solve every memory deallocation problem. For example, if a pointer to a large data structure is kept, the garbage collector cannot reclaim it, even if it is never referred to again. To eliminate this problem, it is good practice to set a reference or pointer to an object to null when no longer needed.</source>
          <target state="translated">가비지 콜렉션이 모든 메모리 할당 해제 문제점을 해결하지는 않습니다. 예를 들어, 큰 데이터 구조에 대한 포인터가 유지되면 다시 참조하지 않더라도 가비지 수집기가이를 회수 할 수 없습니다. 이 문제를 해결하려면 더 이상 필요하지 않은 객체에 대한 참조 또는 포인터를 null로 설정하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="2a483157166b15cc6add50950e71104545209b12" translate="yes" xml:space="preserve">
          <source>Garbage collection is not a panacea. There are some downsides:</source>
          <target state="translated">가비지 콜렉션은 만병 통치약이 아닙니다. 몇 가지 단점이 있습니다.</target>
        </trans-unit>
        <trans-unit id="bdc8494b0a1f3be26c109010c1300b5540a63f86" translate="yes" xml:space="preserve">
          <source>Garbage collection kicks in only when memory gets tight. When memory is not tight, the program runs at full speed and does not spend any time tracing and freeing memory.</source>
          <target state="translated">가비지 콜렉션은 메모리가 부족할 때만 시작됩니다. 메모리가 부족하지 않은 경우 프로그램은 최고 속도로 실행되며 메모리를 추적하고 해제하는 데 시간을 소비하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="43e630068e8d3af90d5baf5c490d09a820b5fe43" translate="yes" xml:space="preserve">
          <source>Garbage collection should be implemented as a basic operating system kernel service. But since it is not, garbage collecting programs must carry around with them the garbage collection implementation. While this can be a shared library, it is still there.</source>
          <target state="translated">가비지 콜렉션은 기본 운영 체제 커널 서비스로 구현되어야합니다. 그러나 가비지 수집 프로그램은 그렇지 않으므로 가비지 수집 구현을 수행해야합니다. 이 라이브러리는 공유 라이브러리 일 수 있지만 여전히 있습니다.</target>
        </trans-unit>
        <trans-unit id="8de09af360c7bfc02cd9b07759c0be1a92997bf1" translate="yes" xml:space="preserve">
          <source>Garbage collectors can keep around some memory that an explicit deallocator would not.</source>
          <target state="translated">가비지 콜렉터는 명시 적 할당 취소 기가 원하지 않는 일부 메모리를 유지할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="52f128a6c5d8578ad64f58e212419d6613dc978b" translate="yes" xml:space="preserve">
          <source>Garbage collectors reclaim unused memory, therefore they do not suffer from &quot;memory leaks&quot; which can cause long running applications to gradually consume more and more memory until they bring down the system. GC programs have longer term stability.</source>
          <target state="translated">가비지 콜렉터는 사용되지 않은 메모리를 회수하므로 &quot;메모리 누수&quot;로 인해 장시간 실행되는 애플리케이션이 시스템을 중단시킬 때까지 점점 더 많은 메모리를 점진적으로 사용할 수 있습니다. GC 프로그램은 장기적인 안정성을 가지고 있습니다.</target>
        </trans-unit>
        <trans-unit id="5929f6c7d4d9ef8bac1c480f80dfd125a208b5f6" translate="yes" xml:space="preserve">
          <source>Gateway to Gateway Protocol</source>
          <target state="translated">게이트웨이 대 게이트웨이 프로토콜</target>
        </trans-unit>
        <trans-unit id="6b850d9a8cc2ef5b85b6581a88258447107ac8f9" translate="yes" xml:space="preserve">
          <source>Gateway to Gateway Protocol level</source>
          <target state="translated">게이트웨이 대 게이트웨이 프로토콜 수준</target>
        </trans-unit>
        <trans-unit id="f0db25c1007f1ac431f102d1b6f3db7e823e1c1d" translate="yes" xml:space="preserve">
          <source>GccAsmStatement &lt;code&gt;s&lt;/code&gt;</source>
          <target state="translated">GccAsmStatement &lt;code&gt;s&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="9239ee2cda84eca4c3440e2a7b50148af67da3d4" translate="yes" xml:space="preserve">
          <source>General</source>
          <target state="translated">General</target>
        </trans-unit>
        <trans-unit id="cc2b80e244c5b3f85b819f8e001f39a8b1778b1c" translate="yes" xml:space="preserve">
          <source>General Punctuation</source>
          <target state="translated">문장 부호</target>
        </trans-unit>
        <trans-unit id="0c7eb0b3402889bd567c0d3af8902acae19e04ce" translate="yes" xml:space="preserve">
          <source>General Types</source>
          <target state="translated">일반 유형</target>
        </trans-unit>
        <trans-unit id="fd7aec0ee16d41be57526539a4c6ef8ef63c34e9" translate="yes" xml:space="preserve">
          <source>General case =&amp;gt; symmetric calls to method opEquals</source>
          <target state="translated">일반적인 경우 =&amp;gt; opEquals 메소드에 대한 대칭 호출</target>
        </trans-unit>
        <trans-unit id="2def4e3aff28a0804ab7417604344f41584fcca9" translate="yes" xml:space="preserve">
          <source>General category sets listed below are only accessible with the &lt;a href=&quot;#unicode&quot;&gt;&lt;code&gt;unicode&lt;/code&gt;&lt;/a&gt; shorthand accessor.</source>
          <target state="translated">아래에 나열된 일반 범주 세트는 &lt;a href=&quot;#unicode&quot;&gt; &lt;code&gt;unicode&lt;/code&gt; &lt;/a&gt; 속기 접근 자를 통해서만 액세스 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="2083d118900999f8d32dc5f2e8254d3f52ea6bf1" translate="yes" xml:space="preserve">
          <source>General use synchronization semaphore.</source>
          <target state="translated">일반적인 사용 동기화 세마포어.</target>
        </trans-unit>
        <trans-unit id="15c16d502337718b40d0beb9afa9790ccdf94859" translate="yes" xml:space="preserve">
          <source>Generally useful building blocks for customized normalization: &lt;a href=&quot;#combiningClass&quot;&gt;&lt;code&gt;combiningClass&lt;/code&gt;&lt;/a&gt; for querying combining class and &lt;a href=&quot;#allowedIn&quot;&gt;&lt;code&gt;allowedIn&lt;/code&gt;&lt;/a&gt; for testing the Quick_Check property of a given normalization form.</source>
          <target state="translated">사용자 정의 정규화에 일반적으로 유용한 구성 요소 : &lt;a href=&quot;#combiningClass&quot;&gt; &lt;code&gt;combiningClass&lt;/code&gt; &lt;/a&gt; 클래스를 쿼리 하기위한 &lt;a href=&quot;#allowedIn&quot;&gt; &lt;code&gt;allowedIn&lt;/code&gt; &lt;/a&gt; 및 주어진 정규화 양식의 Quick_Check 속성을 테스트하기 위해 allowedIn.</target>
        </trans-unit>
        <trans-unit id="9641d9bcb23b576cc813cade93d2589aaa993fe5" translate="yes" xml:space="preserve">
          <source>Generally, the &lt;code&gt;stable&lt;/code&gt; ordering strategy may be more costly in time and/or space than the other two because it imposes additional constraints. Similarly, &lt;code&gt;semistable&lt;/code&gt; may be costlier than &lt;code&gt;unstable&lt;/code&gt;. As (semi-)stability is not needed very often, the ordering algorithms in this module parameterized by &lt;code&gt;SwapStrategy&lt;/code&gt; all choose &lt;code&gt;SwapStrategy.unstable&lt;/code&gt; as the default.</source>
          <target state="translated">일반적으로, &lt;code&gt;stable&lt;/code&gt; 순서 전략은 추가적인 제약을 부과하기 때문에 다른 것보다 시간 및 / 또는 공간이 더 비쌀 수있다. 마찬가지로 &lt;code&gt;semistable&lt;/code&gt; 은 &lt;code&gt;unstable&lt;/code&gt; 보다 비용이 많이 듭니다 . (반) 안정성이 자주 필요하지 않기 때문에 &lt;code&gt;SwapStrategy&lt;/code&gt; 가 매개 변수화 한이 모듈의 순서 알고리즘은 모두 &lt;code&gt;SwapStrategy.unstable&lt;/code&gt; 을 기본값으로 선택합니다 .</target>
        </trans-unit>
        <trans-unit id="05d74eaaa124507aed1ad66047271caa648813e4" translate="yes" xml:space="preserve">
          <source>Generally, the &lt;code&gt;std&lt;/code&gt; namespace is used for the main modules in the Phobos standard library. The &lt;code&gt;etc&lt;/code&gt; namespace is used for external C/C++ library bindings. The &lt;code&gt;core&lt;/code&gt; namespace is used for low-level D runtime functions.</source>
          <target state="translated">일반적으로 &lt;code&gt;std&lt;/code&gt; 네임 스페이스는 Phobos 표준 라이브러리의 기본 모듈에 사용됩니다. &lt;code&gt;etc&lt;/code&gt; 네임 스페이스는 외부 C / C ++ 라이브러리 바인딩에 사용됩니다. &lt;code&gt;core&lt;/code&gt; 네임 스페이스는 낮은 수준의 D 런타임 기능을 위해 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="270a807f0de4d20f0d7b86a3f7b8a65802e708dd" translate="yes" xml:space="preserve">
          <source>Generally, this function checks that &lt;code&gt;path&lt;/code&gt; is not empty, and that each component of the path either satisfies &lt;a href=&quot;#isValidFilename&quot;&gt;&lt;code&gt;isValidFilename&lt;/code&gt;&lt;/a&gt; or is equal to &lt;code&gt;&quot;.&quot;&lt;/code&gt; or &lt;code&gt;&quot;..&quot;&lt;/code&gt;.</source>
          <target state="translated">일반적으로이 함수는 &lt;code&gt;path&lt;/code&gt; 가 비어 있지 않은지, 경로의 각 구성 요소가 &lt;a href=&quot;#isValidFilename&quot;&gt; &lt;code&gt;isValidFilename&lt;/code&gt; 을&lt;/a&gt; 만족 하는지 또는 &lt;code&gt;&quot;.&quot;&lt;/code&gt; 같은지 확인합니다 . 또는 &lt;code&gt;&quot;..&quot;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ac3d74ace2e58f845d2e516e7b9c956be3febfc4" translate="yes" xml:space="preserve">
          <source>Generate .obj file for Module.</source>
          <target state="translated">모듈에 대한 .obj 파일을 생성하십시오.</target>
        </trans-unit>
        <trans-unit id="f9dad7b8a1ce93a4eb80b95d85ef1cf88d8f4597" translate="yes" xml:space="preserve">
          <source>Generate C main() in response to seeing D main().</source>
          <target state="translated">D main ()을보고 C main ()을 생성하십시오.</target>
        </trans-unit>
        <trans-unit id="345123c70e49b34125173495f611953054f48574" translate="yes" xml:space="preserve">
          <source>Generate Expression to call the invariant.</source>
          <target state="translated">불변을 호출하는 식을 생성합니다.</target>
        </trans-unit>
        <trans-unit id="d90320355fd64aadd68db9a959d0db877a879578" translate="yes" xml:space="preserve">
          <source>Generate HALT instruction.</source>
          <target state="translated">HALT 명령을 생성하십시오.</target>
        </trans-unit>
        <trans-unit id="f40cd732815b9b227c307d8a881eabcde883c532" translate="yes" xml:space="preserve">
          <source>Generate Symbol of C++ type info for C++ class cd.</source>
          <target state="translated">C ++ 클래스 cd에 대한 C ++ 유형 정보의 기호를 생성하십시오.</target>
        </trans-unit>
        <trans-unit id="71428fcf71b36719232a357b20981c579d5f795c" translate="yes" xml:space="preserve">
          <source>Generate a FuncDeclaration for a runtime library function.</source>
          <target state="translated">런타임 라이브러리 함수에 대한 FuncDeclaration을 생성하십시오.</target>
        </trans-unit>
        <trans-unit id="c1f38d03f2f34b3b4a976dcf593b7574be546eff" translate="yes" xml:space="preserve">
          <source>Generate a convenient string for identifying this Tid. This is only useful to see if Tid's that are currently executing are the same or different, e.g. for logging and debugging. It is potentially possible that a Tid executed in the future will have the same toString() output as another Tid that has already terminated.</source>
          <target state="translated">이 Tid를 식별하기위한 편리한 문자열을 생성하십시오. 이것은 현재 실행중인 Tid가 동일하거나 다른지 (예 : 로깅 및 디버깅) 경우에만 유용합니다. 나중에 실행되는 Tid는 이미 종료 된 다른 Tid와 동일한 toString () 출력을 가질 가능성이 있습니다.</target>
        </trans-unit>
        <trans-unit id="42a4983512e25bdf4577cfbc7ade2d3d9ef11551" translate="yes" xml:space="preserve">
          <source>Generate a copy from e2 to e1.</source>
          <target state="translated">e2에서 e1로 사본을 생성하십시오.</target>
        </trans-unit>
        <trans-unit id="7e990bafe6b9623ad15b6163c4381e1e24f60827" translate="yes" xml:space="preserve">
          <source>Generate and output scope table.</source>
          <target state="translated">범위 테이블 생성 및 출력</target>
        </trans-unit>
        <trans-unit id="d887428fee6838e30b863f3266f3121541d951d0" translate="yes" xml:space="preserve">
          <source>Generate call to C's assert failure function. One of exp, emsg, or str must not be null.</source>
          <target state="translated">C의 주장 실패 함수에 대한 호출을 생성하십시오. exp, emsg 또는 str 중 하나가 널이 아니어야합니다.</target>
        </trans-unit>
        <trans-unit id="b0e2deeef3299cd274df6c669c731ce070bbe521" translate="yes" xml:space="preserve">
          <source>Generate data for instance of _cpp_type_info_ptr that refers to the C++ RTTI symbol for cd.</source>
          <target state="translated">cd의 C ++ RTTI 기호를 참조하는 _cpp_type_info_ptr의 예를 들어 데이터를 생성하십시오.</target>
        </trans-unit>
        <trans-unit id="92ed283aad401b73892410374fb18c0200210984" translate="yes" xml:space="preserve">
          <source>Generate deterministic named identifier based on a source location, such that the name is consistent across multiple compilations. A new unique name is generated. If the prefix+location is already in the stringtable, an extra suffix is added (starting the count at &quot;1&quot;).</source>
          <target state="translated">소스 위치를 기반으로 결정적 명명 된 식별자를 생성하여 이름이 여러 컴파일에서 일관되게합니다. 새로운 고유 이름이 생성됩니다. 접두사 + 위치가 이미 문자열 테이블에 있으면 추가 접미사가 추가됩니다 ( &quot;1&quot;에서 카운트 시작).</target>
        </trans-unit>
        <trans-unit id="e688f516a8d461fb5372c55840691f744fd51391" translate="yes" xml:space="preserve">
          <source>Generate import symbol from symbol.</source>
          <target state="translated">심볼에서 가져 오기 심볼을 생성합니다.</target>
        </trans-unit>
        <trans-unit id="9978fdec524f341bfac18807618c73a3b51b46c1" translate="yes" xml:space="preserve">
          <source>Generate symbol of type ty at DATA:offset</source>
          <target state="translated">DATA : offset에서 ty 유형의 심볼 생성</target>
        </trans-unit>
        <trans-unit id="821fb78c5c9319cc69fa8057c9c2cd2d48fedaf8" translate="yes" xml:space="preserve">
          <source>Generate two operand instruction with XMM 128 bit operands.</source>
          <target state="translated">XMM 128 비트 피연산자로 두 개의 피연산자 명령어를 생성합니다.</target>
        </trans-unit>
        <trans-unit id="5c437f1471923979723873169275d327e196c1fa" translate="yes" xml:space="preserve">
          <source>Generated Macro Definitions</source>
          <target state="translated">생성 된 매크로 정의</target>
        </trans-unit>
        <trans-unit id="b53fd19a2486af4f399d146936aa03eb7d82a727" translate="yes" xml:space="preserve">
          <source>Generated code is inserted in the scope of &lt;code&gt;std.typecons&lt;/code&gt; module. Thus, any useful functions outside &lt;code&gt;std.typecons&lt;/code&gt; cannot be used in the generated code. To workaround this problem, you may &lt;code&gt;import&lt;/code&gt; necessary things in a local struct, as done in the &lt;code&gt;generateLogger()&lt;/code&gt; template in the above example.</source>
          <target state="translated">생성 된 코드는 &lt;code&gt;std.typecons&lt;/code&gt; 모듈 의 범위에 삽입됩니다 . 따라서 &lt;code&gt;std.typecons&lt;/code&gt; 외부의 유용한 함수 는 생성 된 코드에서 사용할 수 없습니다. 이 문제를 해결하려면 위 예제 의 &lt;code&gt;generateLogger()&lt;/code&gt; 템플릿에서와 같이 로컬 구조체에서 필요한 것을 &lt;code&gt;import&lt;/code&gt; 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="e6857b9e8cb1c55a9a2f9226a5b4dc0cf595f501" translate="yes" xml:space="preserve">
          <source>Generates a hash for &lt;code&gt;this&lt;/code&gt;. If &lt;code&gt;Hook&lt;/code&gt; defines &lt;code&gt;hookToHash&lt;/code&gt;, the call immediately returns &lt;code&gt;hook.hookToHash(payload)&lt;/code&gt;. If &lt;code&gt;Hook&lt;/code&gt; does not implement &lt;code&gt;hookToHash&lt;/code&gt;, but it has state, a hash will be generated for the &lt;code&gt;Hook&lt;/code&gt; using the built-in function and it will be xored with the hash of the &lt;code&gt;payload&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;this&lt;/code&gt; 대한 해시를 생성합니다 . 경우 &lt;code&gt;Hook&lt;/code&gt; 정의 &lt;code&gt;hookToHash&lt;/code&gt; 를 호출은 즉시 반환 &lt;code&gt;hook.hookToHash(payload)&lt;/code&gt; . 경우 &lt;code&gt;Hook&lt;/code&gt; 구현하지 않는 &lt;code&gt;hookToHash&lt;/code&gt; 을 하지만 상태가, 해시가 생성됩니다 &lt;code&gt;Hook&lt;/code&gt; 내장 기능을 사용하고 그것은의 해시 약하게 될 것이다 &lt;code&gt;payload&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="feba4b72ab473cbf0cd5ea105195b64ec1ac1f2d" translate="yes" xml:space="preserve">
          <source>Generates a hash for the tree. Note that with a custom comparison function it may not hold that if two rbtrees are equal, the hashes of the trees will be equal.</source>
          <target state="translated">트리의 해시를 생성합니다. 사용자 정의 비교 함수를 사용하면 두 개의 rbtree가 동일하면 트리의 해시가 동일하다는 것을 유지할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="398b1403000b9404acc8a7edce2480693602dfc5" translate="yes" xml:space="preserve">
          <source>Generates a number between &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt;. The &lt;code&gt;boundaries&lt;/code&gt; parameter controls the shape of the interval (open vs. closed on either side). Valid values for &lt;code&gt;boundaries&lt;/code&gt; are &lt;code&gt;&quot;[]&quot;&lt;/code&gt;, &lt;code&gt;&quot;(]&quot;&lt;/code&gt;, &lt;code&gt;&quot;[)&quot;&lt;/code&gt;, and &lt;code&gt;&quot;()&quot;&lt;/code&gt;. The default interval is closed to the left and open to the right. The version that does not take &lt;code&gt;urng&lt;/code&gt; uses the default generator &lt;code&gt;rndGen&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;a&lt;/code&gt; 와 &lt;code&gt;b&lt;/code&gt; 사이의 숫자를 생성합니다 . &lt;code&gt;boundaries&lt;/code&gt; 제어 파라미터 간격의 형태 (개방 대 양쪽에 폐쇄). &lt;code&gt;boundaries&lt;/code&gt; 유효한 값 은 &lt;code&gt;&quot;[]&quot;&lt;/code&gt; , &lt;code&gt;&quot;(]&quot;&lt;/code&gt; , &lt;code&gt;&quot;[)&quot;&lt;/code&gt; 및 &lt;code&gt;&quot;()&quot;&lt;/code&gt; 입니다. 기본 간격은 왼쪽에서 닫히고 오른쪽에서 열립니다. &lt;code&gt;urng&lt;/code&gt; 을 사용 하지 않는 버전 은 기본 생성기 &lt;code&gt;rndGen&lt;/code&gt; 을 사용합니다 .</target>
        </trans-unit>
        <trans-unit id="31d5a7a72aa7d6403397ac8f8b98d7136fb359b8" translate="yes" xml:space="preserve">
          <source>Generates a uniform probability distribution of size &lt;code&gt;n&lt;/code&gt;, i.e., an array of size &lt;code&gt;n&lt;/code&gt; of positive numbers of type &lt;code&gt;F&lt;/code&gt; that sum to &lt;code&gt;1&lt;/code&gt;. If &lt;code&gt;useThis&lt;/code&gt; is provided, it is used as storage.</source>
          <target state="translated">크기 &lt;code&gt;n&lt;/code&gt; 의 균일 한 확률 분포 , 즉 &lt;code&gt;1&lt;/code&gt; 에 합산 된 &lt;code&gt;F&lt;/code&gt; 유형의 양수 의 크기 &lt;code&gt;n&lt;/code&gt; 의 배열을 생성합니다 . 경우 &lt;code&gt;useThis&lt;/code&gt; 가 제공되는데, 이는 저장 장치로 사용된다.</target>
        </trans-unit>
        <trans-unit id="e2682a8625295cc7a75ade62ec910662e42eb1ad" translate="yes" xml:space="preserve">
          <source>Generates a uniformly-distributed floating point number of type &lt;code&gt;T&lt;/code&gt; in the range [0, 1). If no random number generator is specified, the default RNG &lt;code&gt;rndGen&lt;/code&gt; will be used as the source of randomness.</source>
          <target state="translated">[0, 1) 범위에서 유형 &lt;code&gt;T&lt;/code&gt; 의 균일하게 분포 된 부동 소수점 수를 생성합니다 . 난수 생성기가 지정되지 않은 경우 기본 RNG &lt;code&gt;rndGen&lt;/code&gt; 이 난수의 소스로 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="590a92dca2ec49812f71151418c5576ff9ad8ac5" translate="yes" xml:space="preserve">
          <source>Generates a uniformly-distributed number in the range &lt;code&gt;[T.min, T.max]&lt;/code&gt; for any integral or character type &lt;code&gt;T&lt;/code&gt;. If no random number generator is passed, uses the default &lt;code&gt;rndGen&lt;/code&gt;.</source>
          <target state="translated">정수 또는 문자 유형 &lt;code&gt;T&lt;/code&gt; 에 대해 &lt;code&gt;[T.min, T.max]&lt;/code&gt; 범위에서 균일하게 분포 된 숫자를 생성합니다 . 난수 생성기가 전달되지 않으면 기본 &lt;code&gt;rndGen&lt;/code&gt; 을 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="5a3dd4ef1d89d221f34cd8efe42c23a94aa835c2" translate="yes" xml:space="preserve">
          <source>Generates string with D source code of unary function with name of &lt;code&gt;funcName&lt;/code&gt; taking a single &lt;code&gt;dchar&lt;/code&gt; argument. If &lt;code&gt;funcName&lt;/code&gt; is empty the code is adjusted to be a lambda function.</source>
          <target state="translated">단일 &lt;code&gt;dchar&lt;/code&gt; 인수 를 사용하여 &lt;code&gt;funcName&lt;/code&gt; 이라는 이름으로 단항 함수의 D 소스 코드로 문자열을 생성합니다 . 경우 &lt;code&gt;funcName&lt;/code&gt; 비어 코드는 람다 함수로 조정된다.</target>
        </trans-unit>
        <trans-unit id="4b3935a65e18852e853df767745851e9e88c4154" translate="yes" xml:space="preserve">
          <source>Generates the &lt;code&gt;TypeInfo&lt;/code&gt; object associated with &lt;code&gt;torig&lt;/code&gt; if it hasn't already been generated</source>
          <target state="translated">생성 &lt;code&gt;TypeInfo&lt;/code&gt; 와 관련된 객체 &lt;code&gt;torig&lt;/code&gt; 를 이미 생성되어 있지 않은 경우</target>
        </trans-unit>
        <trans-unit id="c898dd30458bc82445a94b03bf4338f7812ed73c" translate="yes" xml:space="preserve">
          <source>Generates the following:</source>
          <target state="translated">다음을 생성합니다.</target>
        </trans-unit>
        <trans-unit id="ef2e0bcfe378859fb93a76e38ab31870b5aaab4c" translate="yes" xml:space="preserve">
          <source>Generating UUIDs</source>
          <target state="translated">UUID 생성</target>
        </trans-unit>
        <trans-unit id="ff7613e54fc90271b8a71da3dfd9a50e5acd96c2" translate="yes" xml:space="preserve">
          <source>Generic</source>
          <target state="translated">Generic</target>
        </trans-unit>
        <trans-unit id="7282cafe7ab4dcfbd06151ce87eab6a8cb7b662e" translate="yes" xml:space="preserve">
          <source>Generic Template API used for CRC32 and CRC64 implementations.</source>
          <target state="translated">CRC32 및 CRC64 구현에 사용되는 일반 템플릿 API.</target>
        </trans-unit>
        <trans-unit id="48d04e2739718c3b5809e3d93e9ab17e0175ee79" translate="yes" xml:space="preserve">
          <source>Generic algorithms for processing sequences.</source>
          <target state="translated">시퀀스 처리를위한 일반 알고리즘.</target>
        </trans-unit>
        <trans-unit id="7bca8ef182b8f3deaa44e5a838347a3d8559084e" translate="yes" xml:space="preserve">
          <source>Generic algorithms that work with &lt;a href=&quot;std_range&quot;&gt;ranges&lt;/a&gt; of any type, including strings, arrays, and other kinds of sequentially-accessed data. Algorithms include searching, comparison, iteration, sorting, set operations, and mutation.</source>
          <target state="translated">문자열, 배열 및 순차적으로 액세스되는 다른 종류의 데이터를 포함하여 모든 유형의 &lt;a href=&quot;std_range&quot;&gt;범위&lt;/a&gt; 에서 작동하는 일반 알고리즘 . 알고리즘에는 검색, 비교, 반복, 정렬, 설정 작업 및 돌연변이가 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="e37a68ed0e7f2e44e67335effd984a4809f41f52" translate="yes" xml:space="preserve">
          <source>Generic code which deals with different Digest types should always call start though.</source>
          <target state="translated">다른 다이제스트 유형을 처리하는 일반 코드는 항상 start를 호출해야합니다.</target>
        </trans-unit>
        <trans-unit id="a4fe6a7b8d8e501df226058c573d01d9418d71dd" translate="yes" xml:space="preserve">
          <source>Generic error</source>
          <target state="translated">일반적인 오류</target>
        </trans-unit>
        <trans-unit id="070a5062376a825143c54fc921ea5b5a3350219e" translate="yes" xml:space="preserve">
          <source>Generic stripping on ranges: &lt;a href=&quot;std_algorithm_mutation#strip&quot;&gt;&lt;code&gt;std.algorithm.mutation.strip&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">범위의 일반 스트리핑 : &lt;a href=&quot;std_algorithm_mutation#strip&quot;&gt; &lt;code&gt;std.algorithm.mutation.strip&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="a5f39e04859e495f02a94a4f09ad4d9de0e5160e" translate="yes" xml:space="preserve">
          <source>Generic stripping on ranges: &lt;a href=&quot;std_algorithm_mutation#stripLeft&quot;&gt;&lt;code&gt;std.algorithm.mutation.stripLeft&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">범위의 일반 스트리핑 : &lt;a href=&quot;std_algorithm_mutation#stripLeft&quot;&gt; &lt;code&gt;std.algorithm.mutation.stripLeft&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="14b5394baf94216f2e7707c45724f2e122958d4a" translate="yes" xml:space="preserve">
          <source>Generic stripping on ranges: &lt;a href=&quot;std_algorithm_mutation#stripRight&quot;&gt;&lt;code&gt;std.algorithm.mutation.stripRight&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">범위의 일반 스트리핑 : &lt;a href=&quot;std_algorithm_mutation#stripRight&quot;&gt; &lt;code&gt;std.algorithm.mutation.stripRight&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="9d110955c054077a9782bc3e9dc049c8ed9e192f" translate="yes" xml:space="preserve">
          <source>Generic way of converting between two time units.</source>
          <target state="translated">두 시간 단위 사이의 일반적인 변환 방법.</target>
        </trans-unit>
        <trans-unit id="fdfe3a8efedde26bb169021d4c0add270ebc9913" translate="yes" xml:space="preserve">
          <source>Generic way of converting between two time units. Conversions to smaller units use truncating division. Years and months can be converted to each other, small units can be converted to each other, but years and months cannot be converted to or from smaller units (due to the varying number of days in a month or year).</source>
          <target state="translated">두 시간 단위 사이의 일반적인 변환 방법. 더 작은 단위로 변환하면 잘림 나누기가 사용됩니다. 연도와 월은 서로 변환 될 수 있고, 작은 단위는 서로 변환 될 수 있지만, 연도와 월은 작은 단위로 변환하거나 작은 단위로 변환 할 수 없습니다 (달 또는 연도의 다양한 일 수로 인해).</target>
        </trans-unit>
        <trans-unit id="8351f1bd421bb3c2f34de06d3708adb7a974a3d4" translate="yes" xml:space="preserve">
          <source>Geometric Shapes</source>
          <target state="translated">기하학적 모양</target>
        </trans-unit>
        <trans-unit id="aca441ddd2e8d07643b87c1b24a828fa5b4b3e42" translate="yes" xml:space="preserve">
          <source>Georgian</source>
          <target state="translated">Georgian</target>
        </trans-unit>
        <trans-unit id="c559cff938d372579d74b90c80d2874125e4b5d4" translate="yes" xml:space="preserve">
          <source>Georgian Supplement</source>
          <target state="translated">그루지야 어 보충</target>
        </trans-unit>
        <trans-unit id="2e85da619ae334aca9d3221727062ef17b60edd9" translate="yes" xml:space="preserve">
          <source>Get Pointer to Thrown Object if type of thrown object is implicitly convertible to the catch type.</source>
          <target state="translated">던져진 객체의 타입이 캐치 타입으로 암시 적으로 변환 될 수 있다면 포인터를 던져진 객체로 가져 오기.</target>
        </trans-unit>
        <trans-unit id="49759c09a6285b1e1c3c2442b86bed6b17c79b57" translate="yes" xml:space="preserve">
          <source>Get RTTI mangling of the given class declaration for C++ ABI.</source>
          <target state="translated">C ++ ABI에 대해 주어진 클래스 선언의 RTTI 조작을 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="30af4ba10b05a5544d5e9caa6adff1c6bc3df069" translate="yes" xml:space="preserve">
          <source>Get TypeInfo for 'next' type, as defined by what kind of type this is, null if none.</source>
          <target state="translated">어떤 유형의 유형으로 정의 된 '다음'유형에 대한 TypeInfo를 가져옵니다 (없는 경우).</target>
        </trans-unit>
        <trans-unit id="c92e7f5f377e9154bb8151fe8cde1e5454a8ad6b" translate="yes" xml:space="preserve">
          <source>Get a AliasSeq of</source>
          <target state="translated">AliasSeq of</target>
        </trans-unit>
        <trans-unit id="2697c6709922de4b4eb3a504173797b3b2d2f222" translate="yes" xml:space="preserve">
          <source>Get a AliasSeq of the base class and base interfaces of this class or interface. BaseTypeTuple!Object returns the empty type tuple.</source>
          <target state="translated">이 클래스 또는 인터페이스의 기본 클래스 및 기본 인터페이스의 AliasSeq를 가져옵니다. BaseTypeTuple! Object는 빈 유형 튜플을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="debff9d835c323dd33cb0eb8c68915f9979c7a6c" translate="yes" xml:space="preserve">
          <source>Get a range from the container with all elements that are &amp;gt; e according to the less comparator</source>
          <target state="translated">덜 비교기에 따라&amp;gt; e 인 모든 요소가있는 컨테이너에서 범위를 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="2f427a0e190ea30b9ef773b930557ceb28c95c24" translate="yes" xml:space="preserve">
          <source>Get a range from the container with all elements that are &amp;lt; e according to the less comparator</source>
          <target state="translated">덜 비교기에 따라 &amp;lt;e 인 모든 요소를 ​​가진 컨테이너에서 범위를 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="1a49fd135d74779940e67901f3680596c3cb7489" translate="yes" xml:space="preserve">
          <source>Get a range from the container with all elements that are == e according to the less comparator</source>
          <target state="translated">덜 비교기에 따라 == e 인 모든 요소가있는 컨테이너에서 범위를 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="57416603cdc2a4317e5cef5fc1df8438a0dc691d" translate="yes" xml:space="preserve">
          <source>Get a socket option.</source>
          <target state="translated">소켓 옵션을 얻으십시오.</target>
        </trans-unit>
        <trans-unit id="ab0526a6b77b2a6ea32e278479a2c15bfc6233f8" translate="yes" xml:space="preserve">
          <source>Get a text description of this socket's error status, and clear the socket's error status.</source>
          <target state="translated">이 소켓의 에러 상태에 관한 텍스트 설명을 취득 해, 소켓의 에러 상태를 클리어합니다.</target>
        </trans-unit>
        <trans-unit id="cb65e9616425e0463e1160c764ce114f293c53ad" translate="yes" xml:space="preserve">
          <source>Get a timeout (duration) option.</source>
          <target state="translated">시간 초과 (지속 기간) 옵션을 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="cb1503c554d562fcb4fdd362460ca0e88facc2f1" translate="yes" xml:space="preserve">
          <source>Get as a tuple the types of the fields of a struct, class, or union. This consists of the fields that take up memory space, excluding the hidden fields like the virtual function table pointer or a context pointer for nested types. If &lt;code&gt;T&lt;/code&gt; isn't a struct, class, or union returns a tuple with one element &lt;code&gt;T&lt;/code&gt;.</source>
          <target state="translated">구조체, 클래스 또는 공용체의 필드 유형을 튜플로 가져옵니다. 가상 함수 테이블 포인터 또는 중첩 유형의 컨텍스트 포인터와 같은 숨겨진 필드를 제외하고 메모리 공간을 차지하는 필드로 구성됩니다. &lt;code&gt;T&lt;/code&gt; 가 구조체, 클래스 또는 공용체가 아닌 경우 하나의 요소 &lt;code&gt;T&lt;/code&gt; 가있는 튜플을 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="8352810d8951fe7d425bf1322ba1521329088590" translate="yes" xml:space="preserve">
          <source>Get as an expression tuple the names of the fields of a struct, class, or union. This consists of the fields that take up memory space, excluding the hidden fields like the virtual function table pointer or a context pointer for nested types. Inherited fields (for classes) are not included. If &lt;code&gt;T&lt;/code&gt; isn't a struct, class, or union, an expression tuple with an empty string is returned.</source>
          <target state="translated">구조체, 클래스 또는 공용체의 필드 이름을 튜플로 표현하십시오. 가상 함수 테이블 포인터 또는 중첩 유형의 컨텍스트 포인터와 같은 숨겨진 필드를 제외하고 메모리 공간을 차지하는 필드로 구성됩니다. 상속 된 필드 (클래스 용)는 포함되지 않습니다. &lt;code&gt;T&lt;/code&gt; 가 구조체, 클래스 또는 공용체가 아닌 경우 빈 문자열이있는 표현식 튜플이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="a198ff5da76a4a9aab19b26589c9b2c10f34f479" translate="yes" xml:space="preserve">
          <source>Get creation/access/modified times of file &lt;code&gt;name&lt;/code&gt;.</source>
          <target state="translated">파일 &lt;code&gt;name&lt;/code&gt; 의 생성 / 액세스 / 수정 된 시간을 가져 옵니다 .</target>
        </trans-unit>
        <trans-unit id="d0005ffe3affeeb682da9580156ed97b001d178e" translate="yes" xml:space="preserve">
          <source>Get flags for type: 1 means GC should scan for pointers, 2 means arg of this type is passed in XMM register</source>
          <target state="translated">유형에 대한 플래그 가져 오기 : 1은 GC가 포인터를 스캔해야 함을 의미하고, 2는이 유형의 인수가 XMM 레지스터에 전달됨을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="d67dceb8ecd32907f4c80efef5b62cf3e873c8e4" translate="yes" xml:space="preserve">
          <source>Get index of field. Returns -1 if not found.</source>
          <target state="translated">필드 인덱스를 가져옵니다. 찾지 못하면 -1을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="7cbd98494450e74ae712eba7afdee4e2a97eaec8" translate="yes" xml:space="preserve">
          <source>Get nth Parameter, folding in tuples.</source>
          <target state="translated">튜플로 접는 n 번째 매개 변수를 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="b0d99cd151ddfeaf2b13f0d9a95c891f89fbb223" translate="yes" xml:space="preserve">
          <source>Get offset of base class's vtbl[] initializer from start of csym. Returns ~0 if not this csym.</source>
          <target state="translated">csym 시작에서 기본 클래스의 vtbl [] 이니셜 라이저 오프셋을 가져옵니다. 이 csym이 아닌 경우 ~ 0을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="a4feb1bf141a1d88be78b9a3366a4467fa93a965" translate="yes" xml:space="preserve">
          <source>Get range that spans all of the &lt;a href=&quot;#Code%20point&quot;&gt;code point&lt;/a&gt; intervals in this &lt;a href=&quot;#InversionList&quot;&gt;&lt;code&gt;InversionList&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 &lt;a href=&quot;#InversionList&quot;&gt; &lt;code&gt;InversionList&lt;/code&gt; 의&lt;/a&gt; 모든 &lt;a href=&quot;#Code%20point&quot;&gt;코드 포인트&lt;/a&gt; 간격에 걸쳐있는 범위를 가져옵니다 .</target>
        </trans-unit>
        <trans-unit id="f03d5bd32538b64243f7cd6441ecfa2b2622dbab" translate="yes" xml:space="preserve">
          <source>Get size of file &lt;code&gt;name&lt;/code&gt; in bytes.</source>
          <target state="translated">파일 &lt;code&gt;name&lt;/code&gt; 크기를 바이트 단위로 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="461490b8f32608cfbfd66725579129263619bc8c" translate="yes" xml:space="preserve">
          <source>Get size of ty</source>
          <target state="translated">타이의 크기를 얻으십시오</target>
        </trans-unit>
        <trans-unit id="be155f80e71c94e749bac3dc7da0073ca4565577" translate="yes" xml:space="preserve">
          <source>Get targetInfo by key</source>
          <target state="translated">키로 targetInfo 가져 오기</target>
        </trans-unit>
        <trans-unit id="73796f5728cf9c28582274f26067b749361695c9" translate="yes" xml:space="preserve">
          <source>Get the Key type of an Associative Array.</source>
          <target state="translated">연관 배열의 키 유형을 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="d22a099130780c3f0f5de0e5b8d691ed79199316" translate="yes" xml:space="preserve">
          <source>Get the OS specific file attributes for the archive member.</source>
          <target state="translated">아카이브 멤버의 OS 특정 파일 속성을 가져 오십시오.</target>
        </trans-unit>
        <trans-unit id="79ecfb6529a74964e1e68cd5ab4d563b90f3da7a" translate="yes" xml:space="preserve">
          <source>Get the Value type of an Associative Array.</source>
          <target state="translated">연관 배열의 값 유형을 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="98635513b7474e13e846f5ff833241b41e74887e" translate="yes" xml:space="preserve">
          <source>Get the access and modified times of file or folder &lt;code&gt;name&lt;/code&gt;.</source>
          <target state="translated">파일 또는 폴더 &lt;code&gt;name&lt;/code&gt; 의 액세스 및 수정 시간을 가져옵니다 .</target>
        </trans-unit>
        <trans-unit id="5e205b38d81166876ff783947529f334bd179d77" translate="yes" xml:space="preserve">
          <source>Get the cached block info of an interior pointer. Returns null if the interior pointer's block is not cached.</source>
          <target state="translated">내부 포인터의 캐시 된 블록 정보를 가져옵니다. 내부 포인터의 블록이 캐시되지 않은 경우 null을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="4282bb82ffa1bb1dd9a0f9f0f2bf4c8c171f011b" translate="yes" xml:space="preserve">
          <source>Get the code unit at index i</source>
          <target state="translated">인덱스 i에서 코드 단위 가져 오기</target>
        </trans-unit>
        <trans-unit id="7c3dd3625eabe5a78ecd2dfc079c83bf66c607d8" translate="yes" xml:space="preserve">
          <source>Get the current thread's instance. Returns by ref. Note that calling &lt;code&gt;get&lt;/code&gt; from any thread outside the &lt;code&gt;TaskPool&lt;/code&gt; that created this instance will return the same reference, so an instance of worker-local storage should only be accessed from one thread outside the pool that created it. If this rule is violated, undefined behavior will result.</source>
          <target state="translated">현재 스레드의 인스턴스를 가져옵니다. 심판에 의해 반환합니다. 이 인스턴스를 만든 &lt;code&gt;TaskPool&lt;/code&gt; 외부의 스레드에서 &lt;code&gt;get&lt;/code&gt; 을 호출 하면 동일한 참조가 반환되므로 작업자 로컬 저장소의 인스턴스는 해당 인스턴스를 만든 풀 외부의 한 스레드에서만 액세스해야합니다. 이 규칙을 위반하면 정의되지 않은 동작이 발생합니다.</target>
        </trans-unit>
        <trans-unit id="2fa40eed5d4831ba4894fa0d2f99824123d18451" translate="yes" xml:space="preserve">
          <source>Get the current time as a &lt;a href=&quot;#SysTime&quot;&gt;&lt;code&gt;SysTime&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;#SysTime&quot;&gt; &lt;code&gt;SysTime&lt;/code&gt; &lt;/a&gt; 으로 현재 시간 가져 오기</target>
        </trans-unit>
        <trans-unit id="f8dce800f00dab2a31ba905f4b229d5e41f026c6" translate="yes" xml:space="preserve">
          <source>Get the current time from the system clock</source>
          <target state="translated">시스템 시계에서 현재 시간을 가져옵니다</target>
        </trans-unit>
        <trans-unit id="7d101e5841a77867eef23ee238263d38f724a6f3" translate="yes" xml:space="preserve">
          <source>Get the current working directory.</source>
          <target state="translated">현재 작업 디렉토리를 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="b3b0d480375a5d6d1deedae54218ae4809699a35" translate="yes" xml:space="preserve">
          <source>Get the default &lt;code&gt;Throwable.TraceInfo&lt;/code&gt; implementation for the platform</source>
          <target state="translated">플랫폼에 대한 기본 &lt;code&gt;Throwable.TraceInfo&lt;/code&gt; 구현을 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="1a4ef6fd99cfc2a1e29f50c6d9ba5ed116754be8" translate="yes" xml:space="preserve">
          <source>Get the drive portion of a path.</source>
          <target state="translated">경로의 드라이브 부분을 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="c1d426ae9f2d48f1089e0e4fbe50dd7b4c9abc89" translate="yes" xml:space="preserve">
          <source>Get the first argument &lt;code&gt;a&lt;/code&gt; that passes an &lt;code&gt;if (unaryFun!pred(a))&lt;/code&gt; test. If no argument passes the test, return the last argument.</source>
          <target state="translated">&lt;code&gt;if (unaryFun!pred(a))&lt;/code&gt; 테스트 를 통과 한 첫 번째 인수 &lt;code&gt;a&lt;/code&gt; 를 가져옵니다 . 인수가 테스트를 통과하지 못하면 마지막 인수를 반환하십시오.</target>
        </trans-unit>
        <trans-unit id="71fd3b068f374669047aed8f9838bd5650f74328" translate="yes" xml:space="preserve">
          <source>Get the full package name for the given symbol.</source>
          <target state="translated">주어진 기호에 대한 전체 패키지 이름을 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="e88db6759fbbcb530d5bab26ba3ec77a124f346e" translate="yes" xml:space="preserve">
          <source>Get the fully qualified name of a type or a symbol. Can act as an intelligent type/symbol to string converter.</source>
          <target state="translated">형식이나 기호의 정규화 된 이름을 가져옵니다. 지능형 유형 / 기호-문자열 변환기로 작동 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e02735fcab968c6e59f5f8bdf04603517f7d65eb" translate="yes" xml:space="preserve">
          <source>Get the function type from a callable object &lt;code&gt;func&lt;/code&gt;.</source>
          <target state="translated">호출 가능한 객체 &lt;code&gt;func&lt;/code&gt; 에서 함수 유형을 가져옵니다 .</target>
        </trans-unit>
        <trans-unit id="0126813350919cfa23ae233f4d4ec97faf37d1f5" translate="yes" xml:space="preserve">
          <source>Get the last modification time for this member.</source>
          <target state="translated">이 멤버의 마지막 수정 시간을 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="2b55b05c55c5a5fab2ff26e964d410c035b4ab1b" translate="yes" xml:space="preserve">
          <source>Get the linger option.</source>
          <target state="translated">느린 옵션을 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="2731449c54e0db2efeec9062c6ec93a54eb72587" translate="yes" xml:space="preserve">
          <source>Get the message describing the error. Base behavior is to return the &lt;code&gt;Throwable.msg&lt;/code&gt; field. Override to return some other error message.</source>
          <target state="translated">오류를 설명하는 메시지를 받으십시오. 기본 동작은 &lt;code&gt;Throwable.msg&lt;/code&gt; 필드 를 반환하는 것 입니다. 다른 오류 메시지를 반환하도록 재정의하십시오.</target>
        </trans-unit>
        <trans-unit id="4b21108b2b9de9b6cbf7e566c0a2ddc0c0ca72f0" translate="yes" xml:space="preserve">
          <source>Get the module name (including package) for the given symbol.</source>
          <target state="translated">주어진 기호에 대한 모듈 이름 (패키지 포함)을 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="3288e20d4e0a2e8cea872e1f5d70b8c2b93389f8" translate="yes" xml:space="preserve">
          <source>Get the primitive types of the fields of a struct or class, in topological order.</source>
          <target state="translated">구조체 또는 클래스 필드의 기본 유형을 토폴로지 순서대로 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="3543b05579b2dbf35e3b0cd1e4b2b942a6076e5c" translate="yes" xml:space="preserve">
          <source>Get the size of the file, ulong.max if file is not searchable, but still throws if an actual error occurs.</source>
          <target state="translated">파일의 크기를 가져옵니다. 파일을 검색 할 수없는 경우 ulong.max이지만 실제 오류가 발생하면 계속 발생합니다.</target>
        </trans-unit>
        <trans-unit id="79a49f491dcc81c94695a311e67110f25317cf05" translate="yes" xml:space="preserve">
          <source>Get the socket's address family.</source>
          <target state="translated">소켓의 주소 패밀리를 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="4e5a697008886f18598415a18e551017ef50a8a2" translate="yes" xml:space="preserve">
          <source>Get the the default initialization expression for a type.</source>
          <target state="translated">형식의 기본 초기화 식을 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="ebb8fbb5373a6b9ecc71521fb5c82104b76b2dda" translate="yes" xml:space="preserve">
          <source>Get the type of the return value from a function, a pointer to function, a delegate, a struct with an opCall, a pointer to a struct with an opCall, or a class with an &lt;code&gt;opCall&lt;/code&gt;. Please note that ref is not part of a type, but the attribute of the function (see template &lt;a href=&quot;#functionAttributes&quot;&gt;&lt;code&gt;functionAttributes&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="translated">함수의 반환 값의 유형, 함수에 대한 포인터, 대리인, opCall, opCall, 또는있는 클래스와 구조체에 대한 포인터와 구조체 가져 &lt;code&gt;opCall&lt;/code&gt; 을 . 그 심판 유형의 일부가 아닌 참고하지만, 함수의 속성 (템플릿 참조하십시오 &lt;a href=&quot;#functionAttributes&quot;&gt; &lt;code&gt;functionAttributes&lt;/code&gt; 을&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="2f15e792b4182f5761446203a960686f6a1fd8cb" translate="yes" xml:space="preserve">
          <source>Get the type that a scalar type &lt;code&gt;T&lt;/code&gt; will &lt;a href=&quot;https://dlang.org/spec/type.html#integer-promotions&quot;&gt;promote&lt;/a&gt; to in multi-term arithmetic expressions.</source>
          <target state="translated">다항 산술 식에서 스칼라 형식 &lt;code&gt;T&lt;/code&gt; 가 &lt;a href=&quot;https://dlang.org/spec/type.html#integer-promotions&quot;&gt;승격시킬&lt;/a&gt; 형식을 가져옵니다 .</target>
        </trans-unit>
        <trans-unit id="d86851901246015e180e22d937a94cdd4a67d0cf" translate="yes" xml:space="preserve">
          <source>Get the type that all types can be implicitly converted to. Useful e.g. in figuring out an array type from a bunch of initializing values. Returns void if passed an empty list, or if the types have no common type.</source>
          <target state="translated">모든 유형을 암시 적으로 변환 할 수있는 유형을 가져옵니다. 예를 들어 많은 초기화 값에서 배열 유형을 알아내는 데 유용합니다. 빈 목록을 전달했거나 형식에 공통 형식이없는 경우 void를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="d8834c0e5c45f02dee115c0af5916029dd3645eb" translate="yes" xml:space="preserve">
          <source>Get the type that will really be used for passing the given argument to an &lt;code&gt;extern(C++)&lt;/code&gt; function.</source>
          <target state="translated">주어진 인수를 &lt;code&gt;extern(C++)&lt;/code&gt; 함수 에 전달하는 데 실제로 사용될 유형을 가져옵니다 .</target>
        </trans-unit>
        <trans-unit id="1a8db062181587e0a37ac18deba2e6a2d99a21b8" translate="yes" xml:space="preserve">
          <source>Get the underlying path.</source>
          <target state="translated">기본 경로를 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="8aa89601daef2aac5d5712f9ccfde65d17aeb883" translate="yes" xml:space="preserve">
          <source>Get the underlying type which a &lt;code&gt;Typedef&lt;/code&gt; wraps. If &lt;code&gt;T&lt;/code&gt; is not a &lt;code&gt;Typedef&lt;/code&gt; it will alias itself to &lt;code&gt;T&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Typedef&lt;/code&gt; 가 래핑 하는 기본 유형을 가져옵니다 . 경우 &lt;code&gt;T&lt;/code&gt; 는 하지 않은 것입니다 &lt;code&gt;Typedef&lt;/code&gt; 는 자체의 별명합니다 &lt;code&gt;T&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="bc66c2f8e24da37f6181d5e17247039b03831383" translate="yes" xml:space="preserve">
          <source>Get the value of the .max/.min property as an Expression. Lazily computes the value and caches it in maxval/minval. Reports any errors.</source>
          <target state="translated">.max / .min 속성 값을 Expression으로 가져옵니다. Lazily는 값을 계산하고 maxval / minval로 캐시합니다. 오류를보고합니다.</target>
        </trans-unit>
        <trans-unit id="bb25c1e8984031c906b57204ab00dc5ad735d012" translate="yes" xml:space="preserve">
          <source>Get the various timings like name lookup time, total time, connect time etc. The timed category is passed through the timing parameter while the timing value is stored at val. The value is usable only if res is equal to &lt;code&gt;etc.c.curl.CurlError.ok&lt;/code&gt;.</source>
          <target state="translated">이름 조회 시간, 총 시간, 연결 시간 등과 같은 다양한 타이밍을 가져옵니다. 타이밍 값이 val에 저장되는 동안 타이밍 범주가 타이밍 매개 변수를 통과합니다. res가 &lt;code&gt;etc.c.curl.CurlError.ok&lt;/code&gt; 와 같은 경우에만 값을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="912a474bb0a0204ed6b0e20848237a640087bf6c" translate="yes" xml:space="preserve">
          <source>Get tuple, one per function parameter, of the storage classes of the parameters.</source>
          <target state="translated">매개 변수의 스토리지 클래스에 대해 함수 매개 변수 당 하나씩 튜플을 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="36c705a4549f55994270c31cf59dc15c22af56b1" translate="yes" xml:space="preserve">
          <source>Get type information on the contents of the type; null if not available</source>
          <target state="translated">형식의 내용에 대한 형식 정보를 가져옵니다. 사용할 수없는 경우는 null</target>
        </trans-unit>
        <trans-unit id="96f72b00f8ed83794b8d1d1ca2272471a19aedec" translate="yes" xml:space="preserve">
          <source>Get underlying socket handle.</source>
          <target state="translated">기본 소켓 핸들을 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="48ec336cb3c23da76d213eaa7aef8a04ca5f0b14" translate="yes" xml:space="preserve">
          <source>Get various timings defined in &lt;a href=&quot;etc_c_curl#CurlInfo&quot;&gt;&lt;code&gt;etc.c.curl.CurlInfo&lt;/code&gt;&lt;/a&gt;. The value is usable only if the return value is equal to &lt;code&gt;etc.c.curl.CurlError.ok&lt;/code&gt;.</source>
          <target state="translated">&lt;a href=&quot;etc_c_curl#CurlInfo&quot;&gt; &lt;code&gt;etc.c.curl.CurlInfo&lt;/code&gt; 에&lt;/a&gt; 정의 된 다양한 타이밍을 가져옵니다 . 반환 값이 &lt;code&gt;etc.c.curl.CurlError.ok&lt;/code&gt; 와 같은 경우에만 값을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="bb969faa69556a50edb8b7474adfcb5288a0eabc" translate="yes" xml:space="preserve">
          <source>Get, as a tuple, the default value of the parameters to a function symbol. If a parameter doesn't have the default value, &lt;code&gt;void&lt;/code&gt; is returned instead.</source>
          <target state="translated">매개 변수의 기본값을 함수 기호로 튜플로 가져옵니다. 매개 변수에 기본값이 없으면 &lt;code&gt;void&lt;/code&gt; 가 대신 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="6e5eb1b88f56e22db495838fb23d06aff7902858" translate="yes" xml:space="preserve">
          <source>Get, as a tuple, the identifiers of the parameters to a function symbol.</source>
          <target state="translated">함수 식별자에 매개 변수의 식별자를 튜플로 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="0d9be8cea698e918f8f5553c38491cc55f980684" translate="yes" xml:space="preserve">
          <source>Get, as a tuple, the types of the parameters to a function, a pointer to function, a delegate, a struct with an &lt;code&gt;opCall&lt;/code&gt;, a pointer to a struct with an &lt;code&gt;opCall&lt;/code&gt;, or a class with an &lt;code&gt;opCall&lt;/code&gt;.</source>
          <target state="translated">튜플로서 함수에 대한 매개 변수 유형, 함수에 대한 포인터, 대리자, &lt;code&gt;opCall&lt;/code&gt; 이있는 구조체, &lt;code&gt;opCall&lt;/code&gt; 이있는 구조체에 대한 포인터 또는 opCall이 있는 클래스를 &lt;code&gt;opCall&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4a2a322d7843413da4411904750627b588381236" translate="yes" xml:space="preserve">
          <source>Get/set number of elements in the array. It is of type &lt;code&gt;size_t&lt;/code&gt;.</source>
          <target state="translated">배열의 요소 수를 가져 오거나 설정합니다. &lt;code&gt;size_t&lt;/code&gt; 유형 입니다.</target>
        </trans-unit>
        <trans-unit id="e903dced1589591dccd55f4a2a573704d37b25f7" translate="yes" xml:space="preserve">
          <source>Get/set socket's blocking flag.</source>
          <target state="translated">소켓의 블로킹 플래그를 가져 오거나 설정합니다.</target>
        </trans-unit>
        <trans-unit id="8143cfad11bbcb508b2faa890c629adbe90a1326" translate="yes" xml:space="preserve">
          <source>GetoptResult &lt;strong id=&quot;getopt&quot;&gt;getopt&lt;/strong&gt;(T...)(ref string[] args, T opts);</source>
          <target state="translated">GetoptResult &lt;strong id=&quot;getopt&quot;&gt;getopt&lt;/strong&gt; (T ...) (참조 문자열 [] args, T opts);</target>
        </trans-unit>
        <trans-unit id="3639898092fae686744daf985b5a5af78426e672" translate="yes" xml:space="preserve">
          <source>Gets a &lt;a href=&quot;#Code%20point&quot;&gt;code point&lt;/a&gt; at the given index in this cluster.</source>
          <target state="translated">이 클러스터의 지정된 인덱스에서 &lt;a href=&quot;#Code%20point&quot;&gt;코드 포인트&lt;/a&gt; 를 가져 옵니다.</target>
        </trans-unit>
        <trans-unit id="3b7dd24ad864c772981b0d66dc0022feced1b999" translate="yes" xml:space="preserve">
          <source>Gets a larger buffer &lt;code&gt;buf&lt;/code&gt; by calling &lt;code&gt;parent.allocate(goodAllocSize(n))&lt;/code&gt;. If &lt;code&gt;buf&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt;, returns &lt;code&gt;null&lt;/code&gt;. Otherwise, returns &lt;code&gt;buf[0 .. n]&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;parent.allocate(goodAllocSize(n))&lt;/code&gt; 을 호출 하여 더 큰 버퍼 &lt;code&gt;buf&lt;/code&gt; 를 가져 옵니다 . &lt;code&gt;buf&lt;/code&gt; 가 &lt;code&gt;null&lt;/code&gt; 의 경우 는 null 를 돌려 &lt;code&gt;null&lt;/code&gt; . 그렇지 않으면 &lt;code&gt;buf[0 .. n]&lt;/code&gt; 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="b2c0f14712193b76cf9f29f4a2238a646ef9482c" translate="yes" xml:space="preserve">
          <source>Gets a range of key/values for &lt;code&gt;aa&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;aa&lt;/code&gt; 의 키 / 값 범위를 가져 옵니다 .</target>
        </trans-unit>
        <trans-unit id="0f00eae4c2ff9337f7291213da97c9dc6aebf8d8" translate="yes" xml:space="preserve">
          <source>Gets a thread-local instance of ThreadInfo, which should be used as the default instance when info is requested for a thread not created by the Scheduler.</source>
          <target state="translated">스케줄러가 작성하지 않은 스레드에 대한 정보가 요청 될 때 기본 인스턴스로 사용해야하는 ThreadInfo의 스레드 로컬 인스턴스를 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="f6f18bccfb576e34d7b5fa60615448449996ea12" translate="yes" xml:space="preserve">
          <source>Gets a thread-local instance of ThreadInfo.</source>
          <target state="translated">ThreadInfo의 스레드 로컬 인스턴스를 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="b472fcab365d2a6ba9fdba822432b62db948d127" translate="yes" xml:space="preserve">
          <source>Gets an object representing the reader lock for the associated mutex.</source>
          <target state="translated">연결된 뮤텍스의 판독기 잠금을 나타내는 개체를 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="2bad6a1697863b959c51608194a08c6aaf894ca4" translate="yes" xml:space="preserve">
          <source>Gets an object representing the writer lock for the associated mutex.</source>
          <target state="translated">연결된 뮤텍스의 작성기 잠금을 나타내는 개체를 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="c2134c8e8821e26937fe2aedd4aa0e2891a164f8" translate="yes" xml:space="preserve">
          <source>Gets called on program shutdown just after GC is terminated.</source>
          <target state="translated">GC가 종료 된 직후 프로그램 종료시 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="3863a33d5ec162d09008cccc833b8dbca9f1864e" translate="yes" xml:space="preserve">
          <source>Gets called on program startup just before GC is initialized.</source>
          <target state="translated">GC가 초기화되기 직전에 프로그램 시작시 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="fdc75e27ba04f67b552a395ef0dbfb72c8501519" translate="yes" xml:space="preserve">
          <source>Gets expression at offset of type. Returns NULL if not found.</source>
          <target state="translated">형식의 오프셋에서 식을 가져옵니다. 찾을 수 없으면 NULL을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="cc94d4edefc014f546538ff3e9cb05bec4999447" translate="yes" xml:space="preserve">
          <source>Gets the &lt;code&gt;i&lt;/code&gt;'th bit in the &lt;code&gt;BitArray&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;BitArray&lt;/code&gt; 에서 &lt;code&gt;i&lt;/code&gt; 번째 비트를 가져 옵니다 .</target>
        </trans-unit>
        <trans-unit id="8011563ddbd748ff521930918dc8bcb499b269a2" translate="yes" xml:space="preserve">
          <source>Gets the OS identifier for this thread.</source>
          <target state="translated">이 스레드의 OS 식별자를 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="685489f583759f962fe7c1daab0034a07cb9d516" translate="yes" xml:space="preserve">
          <source>Gets the Tid associated with name.</source>
          <target state="translated">이름과 관련된 Tid를 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="5c6e15b07949cc6ff89428732b9e3b99b89bcdc8" translate="yes" xml:space="preserve">
          <source>Gets the current collect handler.</source>
          <target state="translated">현재 수집 처리기를 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="4ee9c2ec9df011130e3394bc652f9b3e7978ed43" translate="yes" xml:space="preserve">
          <source>Gets the current legacy module unit tester.</source>
          <target state="translated">현재 레거시 모듈 장치 테스터를 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="b9fd850a635cce1ec806814a7cb5c442887ef8c8" translate="yes" xml:space="preserve">
          <source>Gets the current module unit tester.</source>
          <target state="translated">현재 모듈 단위 테스터를 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="e72b94a5c6c1c6b67ed9a2ba11a48dec6fb51fea" translate="yes" xml:space="preserve">
          <source>Gets the current state of this fiber.</source>
          <target state="translated">이 파이버의 현재 상태를 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="86b54a37d38df76c69490341ad477a651e752312" translate="yes" xml:space="preserve">
          <source>Gets the current trace handler.</source>
          <target state="translated">현재 추적 핸들러를 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="48b50302326e46ace0f0f71974024ade98c4d812" translate="yes" xml:space="preserve">
          <source>Gets the daemon status for this thread. While the runtime will wait for all normal threads to complete before tearing down the process, daemon threads are effectively ignored and thus will not prevent the process from terminating. In effect, daemon threads will be terminated automatically by the OS when the process exits.</source>
          <target state="translated">이 스레드의 데몬 상태를 가져옵니다. 런타임은 프로세스를 해제하기 전에 모든 일반 스레드가 완료되기를 기다리는 동안 데몬 스레드는 효과적으로 무시되므로 프로세스가 종료되지 않습니다. 실제로 데몬 스레드는 프로세스가 종료 될 때 OS에 의해 자동으로 종료됩니다.</target>
        </trans-unit>
        <trans-unit id="6388b81675e677f57fc44bb674c4998dc61bbf09" translate="yes" xml:space="preserve">
          <source>Gets the index of the current thread relative to this &lt;code&gt;TaskPool&lt;/code&gt;. Any thread not in this pool will receive an index of 0. The worker threads in this pool receive unique indices of 1 through &lt;code&gt;this.size&lt;/code&gt;.</source>
          <target state="translated">이 &lt;code&gt;TaskPool&lt;/code&gt; 에 상대적인 현재 스레드의 인덱스를 가져옵니다 . 이 풀에없는 스레드는 인덱스 0을 &lt;code&gt;this.size&lt;/code&gt; . 이 풀의 작업자 스레드는 1부터 this.size 까지의 고유 인덱스를 받습니다 .</target>
        </trans-unit>
        <trans-unit id="397d4288bd9f56373ed42093b36baf0cf34c80d4" translate="yes" xml:space="preserve">
          <source>Gets the matching &lt;a href=&quot;https://dlang.org/spec/attribute.html#uda&quot;&gt;user-defined attributes&lt;/a&gt; from the given symbol.</source>
          <target state="translated">주어진 기호에서 일치하는 &lt;a href=&quot;https://dlang.org/spec/attribute.html#uda&quot;&gt;사용자 정의 속성&lt;/a&gt; 을 가져옵니다 .</target>
        </trans-unit>
        <trans-unit id="ff4bb9618e0f172c3deb93f3fe4c73732cb67c80" translate="yes" xml:space="preserve">
          <source>Gets the mutex associated with this condition.</source>
          <target state="translated">이 조건과 관련된 뮤텍스를 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="b1cafc8d1ad4c93a1519578fd6ef07cfbae8c0d4" translate="yes" xml:space="preserve">
          <source>Gets the nth number in the underlying representation that makes up the whole &lt;code&gt;BigInt&lt;/code&gt;.</source>
          <target state="translated">전체 &lt;code&gt;BigInt&lt;/code&gt; 를 구성하는 기본 표현에서 n 번째 숫자를 가져옵니다 .</target>
        </trans-unit>
        <trans-unit id="801e40683c25723cacc6326aca38101be95c4627" translate="yes" xml:space="preserve">
          <source>Gets the policy used by this mutex.</source>
          <target state="translated">이 뮤텍스가 사용하는 정책을 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="8aba27c226485427875db239e8c2e09071484ea6" translate="yes" xml:space="preserve">
          <source>Gets the scheduling priority for the associated thread.</source>
          <target state="translated">연결된 스레드의 예약 우선 순위를 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="cf58bd5c03eda3fe4cc7594124c4b61e9c109dc9" translate="yes" xml:space="preserve">
          <source>Gets the type of the &lt;code&gt;TypeInfo&lt;/code&gt; object associated with &lt;code&gt;t&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;t&lt;/code&gt; 와 관련된 &lt;code&gt;TypeInfo&lt;/code&gt; 개체 의 형식을 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="9211b2fb8e24a472f1780790cfdc50455081852e" translate="yes" xml:space="preserve">
          <source>Gets the user-readable label for this thread.</source>
          <target state="translated">이 스레드에 대한 사용자가 읽을 수있는 레이블을 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="611d2080794dfc9ee82363d9d9da4aa9a138b19f" translate="yes" xml:space="preserve">
          <source>Gets the value if not null. If &lt;code&gt;this&lt;/code&gt; is in the null state, and the optional parameter &lt;code&gt;fallback&lt;/code&gt; was provided, it will be returned. Without &lt;code&gt;fallback&lt;/code&gt;, calling &lt;code&gt;get&lt;/code&gt; with a null state is invalid.</source>
          <target state="translated">null이 아닌 경우는 값을 가져옵니다. 경우 &lt;code&gt;this&lt;/code&gt; 널 상태이며, 선택적 매개 변수 &lt;code&gt;fallback&lt;/code&gt; 제공되었다, 그것은 반환됩니다. &lt;code&gt;fallback&lt;/code&gt; 이 없으면 null 상태의 &lt;code&gt;get&lt;/code&gt; 호출 이 유효하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="7ce43e8e9e8874c455bc1d408b4db63789ae5ade" translate="yes" xml:space="preserve">
          <source>Gets the value. &lt;code&gt;this&lt;/code&gt; must not be in the null state. This function is also called for the implicit conversion to &lt;code&gt;T&lt;/code&gt;.</source>
          <target state="translated">값을 가져옵니다. &lt;code&gt;this&lt;/code&gt; null 상태가 아니어야합니다. 이 함수는 또한 &lt;code&gt;T&lt;/code&gt; 로의 암시 적 변환을 위해 호출됩니다 .</target>
        </trans-unit>
        <trans-unit id="27ec2c5053941a53ff7bc20b3630c9aa87b310af" translate="yes" xml:space="preserve">
          <source>Gets vendor-specific type mangling for C++ ABI.</source>
          <target state="translated">C ++ ABI에 대한 공급 업체별 유형 처리를 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="7e2612461374b070bc3713b89e3df4f4c33fbf6f" translate="yes" xml:space="preserve">
          <source>Gets/sets assert hander. null means the default handler is used.</source>
          <target state="translated">어설 션 처리기를 가져 오거나 설정합니다. null은 기본 처리기가 사용됨을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="8a46199cc00d346a1fe72a372a1bcb52b3b1947f" translate="yes" xml:space="preserve">
          <source>Gets/sets the allocator for the current process. This allocator must be used for allocating memory shared across threads. Objects created using this allocator can be cast to &lt;code&gt;shared&lt;/code&gt;.</source>
          <target state="translated">현재 프로세스의 할당자를 가져 오거나 설정합니다. 이 할당자는 스레드간에 공유되는 메모리를 할당하는 데 사용해야합니다. 이 할당자를 사용하여 생성 된 객체는 &lt;code&gt;shared&lt;/code&gt; 로 캐스트 될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="b3f3fc74fb3ec91a1abfd15e2f2178014ba02b91" translate="yes" xml:space="preserve">
          <source>Gets/sets the allocator for the current thread. This is the default allocator that should be used for allocating thread-local memory. For allocating memory to be shared across threads, use &lt;code&gt;processAllocator&lt;/code&gt; (below). By default, &lt;code&gt;theAllocator&lt;/code&gt; ultimately fetches memory from &lt;code&gt;processAllocator&lt;/code&gt;, which in turn uses the garbage collected heap.</source>
          <target state="translated">현재 스레드의 할당자를 가져 오거나 설정합니다. 스레드 로컬 메모리 할당에 사용해야하는 기본 할당 자입니다. 스레드간에 메모리가 공유되도록 할당하려면 &lt;code&gt;processAllocator&lt;/code&gt; (아래)를 사용하십시오. 기본적으로 &lt;code&gt;theAllocator&lt;/code&gt; 궁극적으로 &lt;code&gt;processAllocator&lt;/code&gt; 에서 메모리를 가져 오며 ,이 메모리 는 가비지 수집 힙을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="ce0e5e384b0423d01fbe02461b7f604937af05a9" translate="yes" xml:space="preserve">
          <source>Getting a range of all the named captures in the regex.</source>
          <target state="translated">정규식에서 명명 된 모든 캡처 범위를 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="3239f451b140324af46d3a3db896ec8a5a618fbd" translate="yes" xml:space="preserve">
          <source>Getting the benefits of multiple adaptable freelists that do not need to be tuned for one specific size but insted automatically adapts itself to frequently used sizes.</source>
          <target state="translated">하나의 특정 크기로 조정할 필요는 없지만 자주 사용되는 크기에 자동으로 적응하는 여러 개의 조정 가능한 프리리스트의 이점을 얻습니다.</target>
        </trans-unit>
        <trans-unit id="c7ae27f036579182bace286ba1e0cf636e5ff36f" translate="yes" xml:space="preserve">
          <source>Getting the priority of a thread that already terminated might return the default priority.</source>
          <target state="translated">이미 종료 된 스레드의 우선 순위를 가져 오면 기본 우선 순위를 리턴 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d5546b9dfb555ac771be9469163d9af49686adbe" translate="yes" xml:space="preserve">
          <source>Give error if we're not an lvalue. If we can, convert expression to be an lvalue.</source>
          <target state="translated">lvalue가 아닌 경우 오류를 제공하십시오. 가능하면 expression을 lvalue로 변환하십시오.</target>
        </trans-unit>
        <trans-unit id="74474e23aa26985e7a98ca671962a908920e33b2" translate="yes" xml:space="preserve">
          <source>Give up.</source>
          <target state="translated">포기 해</target>
        </trans-unit>
        <trans-unit id="6839d82e03f5268d9a7cc97802db76c48c8cce6e" translate="yes" xml:space="preserve">
          <source>Given</source>
          <target state="translated">Given</target>
        </trans-unit>
        <trans-unit id="545c45c89bb40c5d7b7b442770eb2c94a5c06899" translate="yes" xml:space="preserve">
          <source>Given &lt;code&gt;a == b&lt;/code&gt; :</source>
          <target state="translated">주어진 &lt;code&gt;a == b&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="53726705da0088ae9fbab83c8c50c091febc70d1" translate="yes" xml:space="preserve">
          <source>Given &lt;code&gt;flags&lt;/code&gt; as a combination of &lt;code&gt;AllocFlag&lt;/code&gt; values, or a type &lt;code&gt;T&lt;/code&gt;, returns the allocator that's a closest fit in capabilities.</source>
          <target state="translated">감안할 때 &lt;code&gt;flags&lt;/code&gt; 의 조합으로 &lt;code&gt;AllocFlag&lt;/code&gt; 의 값 또는 유형 &lt;code&gt;T&lt;/code&gt; , 기능에 가장 가까운 적합의 할당자를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="62b1bd97df8e740424d65deb5d1e60e2802ffce0" translate="yes" xml:space="preserve">
          <source>Given &lt;code&gt;index&lt;/code&gt; into &lt;code&gt;str&lt;/code&gt; and assuming that &lt;code&gt;index&lt;/code&gt; is at the start of a UTF sequence, &lt;code&gt;toUCSindex&lt;/code&gt; determines the number of UCS characters up to &lt;code&gt;index&lt;/code&gt;. So, &lt;code&gt;index&lt;/code&gt; is the index of a code unit at the beginning of a code point, and the return value is how many code points into the string that that code point is.</source>
          <target state="translated">&lt;code&gt;str&lt;/code&gt; 에 &lt;code&gt;index&lt;/code&gt; 가 주어 지고 &lt;code&gt;index&lt;/code&gt; 가 UTF 시퀀스의 시작에 있다고 가정하면 &lt;code&gt;toUCSindex&lt;/code&gt; 는 &lt;code&gt;index&lt;/code&gt; 까지 UCS 문자 수를 판별합니다 . 따라서 &lt;code&gt;index&lt;/code&gt; 는 코드 포인트의 시작 부분에있는 코드 단위의 인덱스이며 반환 값은 해당 코드 포인트가 문자열에있는 코드 포인트 수입니다.</target>
        </trans-unit>
        <trans-unit id="bb7cf3072f3bd953aeae94de343ed5c6b8a94867" translate="yes" xml:space="preserve">
          <source>Given D code like:</source>
          <target state="translated">주어진 D 코드는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="d736ecdf41cd9fce2597d330cc34519b6b941a39" translate="yes" xml:space="preserve">
          <source>Given EBP, find return address to caller, and caller's EBP.</source>
          <target state="translated">EBP가 주어지면 발신자에게 반송 주소와 발신자의 EBP를 찾습니다.</target>
        </trans-unit>
        <trans-unit id="eb6400b34d9067d59b3f43922d46e893c8d36002" translate="yes" xml:space="preserve">
          <source>Given a &lt;code&gt;source&lt;/code&gt; range that is expensive to iterate over, returns an &lt;a href=&quot;std_range_primitives#isInputRange&quot;&gt;input range&lt;/a&gt; that asynchronously buffers the contents of &lt;code&gt;source&lt;/code&gt; into a buffer of &lt;code&gt;bufSize&lt;/code&gt; elements in a worker thread, while making previously buffered elements from a second buffer, also of size &lt;code&gt;bufSize&lt;/code&gt;, available via the range interface of the returned object. The returned range has a length iff &lt;code&gt;hasLength!S&lt;/code&gt;. &lt;code&gt;asyncBuf&lt;/code&gt; is useful, for example, when performing expensive operations on the elements of ranges that represent data on a disk or network.</source>
          <target state="translated">주어진 &lt;code&gt;source&lt;/code&gt; 반복 비싸다 범위 반환 &lt;a href=&quot;std_range_primitives#isInputRange&quot;&gt;입력 범위&lt;/a&gt; 비동기의 내용 버퍼 것을 &lt;code&gt;source&lt;/code&gt; 를 버퍼로 &lt;code&gt;bufSize&lt;/code&gt; buf의의 같은 크기의 제 2 버퍼로부터 이전에 버퍼링 엘리먼트하면서, 작업자 스레드 요소 &lt;code&gt;bufSize&lt;/code&gt; buf의를 통해 사용할 반환 된 객체의 범위 인터페이스 반환 된 범위의 길이는 iff &lt;code&gt;hasLength!S&lt;/code&gt; 입니다. &lt;code&gt;asyncBuf&lt;/code&gt; 는 예를 들어 디스크 또는 네트워크의 데이터를 나타내는 범위의 요소에 대해 비싼 작업을 수행 할 때 유용합니다.</target>
        </trans-unit>
        <trans-unit id="699c74248abd14b4250ad690ede845e5aad24631" translate="yes" xml:space="preserve">
          <source>Given a Base64 encoded string, calculates the length of the decoded string.</source>
          <target state="translated">Base64로 인코딩 된 문자열이 제공되면 디코딩 된 문자열의 길이를 계산합니다.</target>
        </trans-unit>
        <trans-unit id="bc7d61e132762100a6e8861609dacf0581eebca4" translate="yes" xml:space="preserve">
          <source>Given a C++ function in a C++ source file:</source>
          <target state="translated">C ++ 소스 파일에 C ++ 함수가 제공된 경우 :</target>
        </trans-unit>
        <trans-unit id="7de884353daa1d02f969775316b89c9805864eba" translate="yes" xml:space="preserve">
          <source>Given a UCS index &lt;code&gt;n&lt;/code&gt; into &lt;code&gt;str&lt;/code&gt;, returns the UTF index. So, &lt;code&gt;n&lt;/code&gt; is how many code points into the string the code point is, and the array index of the code unit is returned.</source>
          <target state="translated">UCS 인덱스 감안할 때 &lt;code&gt;n&lt;/code&gt; 에 &lt;code&gt;str&lt;/code&gt; 의 UTF 인덱스를 돌려줍니다. 따라서 &lt;code&gt;n&lt;/code&gt; 은 코드 포인트가있는 문자열의 코드 포인트 수이며 코드 단위의 배열 인덱스가 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="3aa76f9d8ead49fe4c4634dcc93f9d715d5abf9c" translate="yes" xml:space="preserve">
          <source>Given a and p, the function finds x such that</source>
          <target state="translated">a와 p가 주어지면 함수는 x를 찾습니다.</target>
        </trans-unit>
        <trans-unit id="97696594fbe0457c99be87ef93b37c947e4a5703" translate="yes" xml:space="preserve">
          <source>Given a callable object &lt;code&gt;next&lt;/code&gt; that writes to a user-provided buffer and a second callable object &lt;code&gt;empty&lt;/code&gt; that determines whether more data is available to write via &lt;code&gt;next&lt;/code&gt;, returns an input range that asynchronously calls &lt;code&gt;next&lt;/code&gt; with a set of size &lt;code&gt;nBuffers&lt;/code&gt; of buffers and makes the results available in the order they were obtained via the input range interface of the returned object. Similarly to the input range overload of &lt;code&gt;asyncBuf&lt;/code&gt;, the first half of the buffers are made available via the range interface while the second half are filled and vice-versa.</source>
          <target state="translated">호출 가능한 객체 주어 &lt;code&gt;next&lt;/code&gt; 사용자 제공 버퍼 및 제 호출 객체 쓴다 &lt;code&gt;empty&lt;/code&gt; 즉 통해 기록에 사용할 수 많은 데이터의 여부를 판정 &lt;code&gt;next&lt;/code&gt; 비동기 호출하는 입력 범위 리턴 &lt;code&gt;next&lt;/code&gt; 크기의 세트와 &lt;code&gt;nBuffers&lt;/code&gt; 버퍼와한다을 반환 된 객체의 입력 범위 인터페이스를 통해 얻은 순서대로 결과를 사용할 수 있습니다. &lt;code&gt;asyncBuf&lt;/code&gt; 의 입력 범위 과부하와 유사하게 , 버퍼의 전반부는 범위 인터페이스를 통해 사용 가능하게되고 후반은 채워지고 그 반대도 마찬가지입니다.</target>
        </trans-unit>
        <trans-unit id="f4bc9912c00cf7ade5e6f59f3c7bafa79a0098bb" translate="yes" xml:space="preserve">
          <source>Given a function &lt;code&gt;f&lt;/code&gt; and a range &lt;code&gt;[a .. b]&lt;/code&gt; such that &lt;code&gt;f(a)&lt;/code&gt; and &lt;code&gt;f(b)&lt;/code&gt; have opposite signs or at least one of them equals &amp;plusmn;0, returns the value of &lt;code&gt;x&lt;/code&gt; in the range which is closest to a root of &lt;code&gt;f(x)&lt;/code&gt;. If &lt;code&gt;f(x)&lt;/code&gt; has more than one root in the range, one will be chosen arbitrarily. If &lt;code&gt;f(x)&lt;/code&gt; returns NaN, NaN will be returned; otherwise, this algorithm is guaranteed to succeed.</source>
          <target state="translated">&lt;code&gt;f(a)&lt;/code&gt; 와 &lt;code&gt;f(b)&lt;/code&gt; 가 반대 부호를 갖거나 그 중 적어도 하나가 &amp;plusmn; 0 과 같은 함수 &lt;code&gt;f&lt;/code&gt; 와 범위 &lt;code&gt;[a .. b]&lt;/code&gt; 주어지면 a 에 가장 가까운 범위에서 &lt;code&gt;x&lt;/code&gt; 의 값을 반환합니다 . 뿌리 &lt;code&gt;f(x)&lt;/code&gt; . 경우 &lt;code&gt;f(x)&lt;/code&gt; 범위 내에 하나 개 이상의 루트를 갖고, 하나는 임의로 선택된다. 경우 &lt;code&gt;f(x)&lt;/code&gt; NaN의를 반환 NaN이 반환됩니다; 그렇지 않으면이 알고리즘이 성공합니다.</target>
        </trans-unit>
        <trans-unit id="b3d905355b0b0e68c40d2c94bafa678611e3caae" translate="yes" xml:space="preserve">
          <source>Given a new instance tithis of this TemplateDeclaration, see if there already exists an instance. If so, return that existing instance.</source>
          <target state="translated">이 TemplateDeclaration의 새로운 인스턴스가 주어지면 이미 인스턴스가 있는지 확인하십시오. 그렇다면 기존 인스턴스를 반환하십시오.</target>
        </trans-unit>
        <trans-unit id="7902cf88ea3243b9d5f9eb153e89c6c4585563c1" translate="yes" xml:space="preserve">
          <source>Given a pointer &lt;code&gt;chunk&lt;/code&gt; to uninitialized memory (but already typed as &lt;code&gt;T&lt;/code&gt;), constructs an object of non-&lt;code&gt;class&lt;/code&gt; type &lt;code&gt;T&lt;/code&gt; at that address. If &lt;code&gt;T&lt;/code&gt; is a class, initializes the class reference to null.</source>
          <target state="translated">초기화되지 않은 메모리 (이미 &lt;code&gt;T&lt;/code&gt; 로 입력 됨 )에 대한 포인터 &lt;code&gt;chunk&lt;/code&gt; 가 주어지면 해당 주소에서 &lt;code&gt;class&lt;/code&gt; 가 아닌 유형 &lt;code&gt;T&lt;/code&gt; 의 객체를 구성합니다 . 경우 &lt;code&gt;T&lt;/code&gt; 는 클래스이며, null로 클래스 참조를 초기화합니다.</target>
        </trans-unit>
        <trans-unit id="abaa134bbbf8060e8ac6344879f8e8d611739ebe" translate="yes" xml:space="preserve">
          <source>Given a pointer &lt;code&gt;chunk&lt;/code&gt; to uninitialized memory (but already typed as a non-class type &lt;code&gt;T&lt;/code&gt;), constructs an object of type &lt;code&gt;T&lt;/code&gt; at that address from arguments &lt;code&gt;args&lt;/code&gt;. If &lt;code&gt;T&lt;/code&gt; is a class, initializes the class reference to &lt;code&gt;args[0]&lt;/code&gt;.</source>
          <target state="translated">초기화되지 않은 메모리에 대한 포인터 &lt;code&gt;chunk&lt;/code&gt; 가 주어 졌지만 (이미 클래스가 아닌 유형 &lt;code&gt;T&lt;/code&gt; 로 입력 된 경우) 인수 &lt;code&gt;args&lt;/code&gt; 에서 해당 주소에 &lt;code&gt;T&lt;/code&gt; 유형의 오브젝트를 구성합니다 . &lt;code&gt;T&lt;/code&gt; 가 클래스 인 경우 &lt;code&gt;args[0]&lt;/code&gt; 대한 클래스 참조를 초기화합니다 .</target>
        </trans-unit>
        <trans-unit id="58557c048614c0f1ce20fdb67b5db3ba6bf2d1b4" translate="yes" xml:space="preserve">
          <source>Given a pointer &lt;code&gt;chunk&lt;/code&gt; to uninitialized memory (but already typed as a non-class type &lt;code&gt;T&lt;/code&gt;), constructs an object of type &lt;code&gt;T&lt;/code&gt; at that address from arguments &lt;code&gt;args&lt;/code&gt;. If &lt;code&gt;T&lt;/code&gt; is a class, initializes the class reference to &lt;code&gt;args[0]&lt;/code&gt;. This function can be &lt;code&gt;@trusted&lt;/code&gt; if the corresponding constructor of &lt;code&gt;T&lt;/code&gt; is &lt;code&gt;@safe&lt;/code&gt;.</source>
          <target state="translated">초기화되지 않은 메모리에 대한 포인터 &lt;code&gt;chunk&lt;/code&gt; 가 주어 졌지만 (이미 클래스가 아닌 유형 &lt;code&gt;T&lt;/code&gt; 로 입력 된 경우) 인수 &lt;code&gt;args&lt;/code&gt; 에서 해당 주소에 &lt;code&gt;T&lt;/code&gt; 유형의 오브젝트를 구성합니다 . &lt;code&gt;T&lt;/code&gt; 가 클래스 인 경우 &lt;code&gt;args[0]&lt;/code&gt; 대한 클래스 참조를 초기화합니다 . 이 기능 할 수 &lt;code&gt;@trusted&lt;/code&gt; 의 대응 생성자 경우 &lt;code&gt;T&lt;/code&gt; 는 이다 &lt;code&gt;@safe&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="18ffdf892cf328d6d063a845b68a6520844d64c2" translate="yes" xml:space="preserve">
          <source>Given a pointer: If it is an Object, return that Object. If it is an interface, return the Object implementing the interface. If it is null, return null. Else, undefined crash</source>
          <target state="translated">포인터가 주어지면 : Object 인 경우 해당 Object를 반환하십시오. 인터페이스 인 경우 인터페이스를 구현하는 Object를 반환합니다. 널인 경우 널을 리턴하십시오. 그렇지 않으면 정의되지 않은 충돌</target>
        </trans-unit>
        <trans-unit id="a2a17bffc5b9d113dc0183d4777b121f1563c333" translate="yes" xml:space="preserve">
          <source>Given a random-access range and a starting point, creates a range that alternately returns the next left and next right element to the starting point.</source>
          <target state="translated">랜덤 액세스 범위와 시작점이 주어지면 다음 왼쪽 및 다음 오른쪽 요소를 시작점으로 교대로 반환하는 범위를 만듭니다.</target>
        </trans-unit>
        <trans-unit id="cf77f4783176c69f24bf5139063bed48dbcdbc05" translate="yes" xml:space="preserve">
          <source>Given a range of elements, constructs an index of its top</source>
          <target state="translated">다양한 요소가 주어지면 최상위 인덱스를 생성합니다.</target>
        </trans-unit>
        <trans-unit id="f82f27390a9cc6295ef9d3e2c499d003645adbcb" translate="yes" xml:space="preserve">
          <source>Given a range of ranges, iterate transversally through the &lt;code&gt;n&lt;/code&gt;th element of each of the enclosed ranges. This function is similar to &lt;code&gt;unzip&lt;/code&gt; in other languages.</source>
          <target state="translated">범위의 범위가 주어지면, 각각의 닫힌 범위 의 &lt;code&gt;n&lt;/code&gt; 번째 요소를 가로로 반복 합니다. 이 기능은 다른 언어의 &lt;code&gt;unzip&lt;/code&gt; 와 유사합니다 .</target>
        </trans-unit>
        <trans-unit id="99d831c39b761ba6173d077a392b684dab424593" translate="yes" xml:space="preserve">
          <source>Given a range of ranges, iterate transversally through the first elements of each of the enclosed ranges.</source>
          <target state="translated">범위의 범위가 주어지면 닫힌 범위 각각의 첫 번째 요소를 가로로 반복합니다.</target>
        </trans-unit>
        <trans-unit id="76deeb26e0b9b94a659a1c8d77489812eb190823" translate="yes" xml:space="preserve">
          <source>Given a range of ranges, returns a range of ranges where the</source>
          <target state="translated">범위의 범위가 주어지면 범위의 범위를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="23b1b22050fe1a6a85e37baec0da8ef5a908711a" translate="yes" xml:space="preserve">
          <source>Given a range of sorted &lt;a href=&quot;std_range_primitives#isForwardRange&quot;&gt;forward ranges&lt;/a&gt;&lt;code&gt;ror&lt;/code&gt;, copies to &lt;code&gt;tgt&lt;/code&gt; the elements that are common to most ranges, along with their number of occurrences. All ranges in &lt;code&gt;ror&lt;/code&gt; are assumed to be sorted by &lt;code&gt;less&lt;/code&gt;. Only the most frequent &lt;code&gt;tgt.length&lt;/code&gt; elements are returned.</source>
          <target state="translated">정렬 된 &lt;a href=&quot;std_range_primitives#isForwardRange&quot;&gt;순방향 범위가 &lt;/a&gt; &lt;code&gt;ror&lt;/code&gt; 인 경우, 발생 횟수와 함께 대부분의 범위에 공통 인 요소 를 &lt;code&gt;tgt&lt;/code&gt; 에 복사합니다 . &lt;code&gt;ror&lt;/code&gt; 의 모든 범위는 &lt;code&gt;less&lt;/code&gt; 정렬 된 것으로 가정합니다 . 가장 빈번한 &lt;code&gt;tgt.length&lt;/code&gt; 요소 만 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="6cadfddfad656a52536264d1af9f3900d194ed5c" translate="yes" xml:space="preserve">
          <source>Given a raw memory area &lt;code&gt;chunk&lt;/code&gt; (but already typed as a class type &lt;code&gt;T&lt;/code&gt;), constructs an object of &lt;code&gt;class&lt;/code&gt; type &lt;code&gt;T&lt;/code&gt; at that address. The constructor is passed the arguments &lt;code&gt;Args&lt;/code&gt;.</source>
          <target state="translated">원시 메모리 영역 &lt;code&gt;chunk&lt;/code&gt; 주어 졌지만 (이미 클래스 유형 &lt;code&gt;T&lt;/code&gt; 로 입력 됨 ) 해당 주소에서 &lt;code&gt;class&lt;/code&gt; 유형 &lt;code&gt;T&lt;/code&gt; 의 객체를 구성합니다 . 생성자에는 &lt;code&gt;Args&lt;/code&gt; 인수가 전달 됩니다.</target>
        </trans-unit>
        <trans-unit id="adbee075f1252282f1c423c0af02edd4265ab66b" translate="yes" xml:space="preserve">
          <source>Given a raw memory area &lt;code&gt;chunk&lt;/code&gt; (but already typed as a class type &lt;code&gt;T&lt;/code&gt;), constructs an object of &lt;code&gt;class&lt;/code&gt; type &lt;code&gt;T&lt;/code&gt; at that address. The constructor is passed the arguments &lt;code&gt;Args&lt;/code&gt;. If &lt;code&gt;T&lt;/code&gt; is an inner class whose &lt;code&gt;outer&lt;/code&gt; field can be used to access an instance of the enclosing class, then &lt;code&gt;Args&lt;/code&gt; must not be empty, and the first member of it must be a valid initializer for that &lt;code&gt;outer&lt;/code&gt; field. Correct initialization of this field is essential to access members of the outer class inside &lt;code&gt;T&lt;/code&gt; methods.</source>
          <target state="translated">원시 메모리 영역 &lt;code&gt;chunk&lt;/code&gt; 주어 졌지만 (이미 클래스 유형 &lt;code&gt;T&lt;/code&gt; 로 입력 됨 ) 해당 주소에서 &lt;code&gt;class&lt;/code&gt; 유형 &lt;code&gt;T&lt;/code&gt; 의 객체를 구성합니다 . 생성자에는 &lt;code&gt;Args&lt;/code&gt; 인수가 전달 됩니다. 경우 &lt;code&gt;T&lt;/code&gt; 는 그 내부 클래스 &lt;code&gt;outer&lt;/code&gt; 필드를 둘러싸는 클래스의 인스턴스에 액세스하는 데 사용될 수는 다음 &lt;code&gt;Args&lt;/code&gt; 비어 있지 않아야하고 그것의 제 1 부재에는 해당하는 유효 초기화 있어야 &lt;code&gt;outer&lt;/code&gt; 필드. 이 필드의 올바른 초기화는 &lt;code&gt;T&lt;/code&gt; 메소드 내부의 외부 클래스 멤버에 액세스하는 데 필수적 입니다.</target>
        </trans-unit>
        <trans-unit id="0653a1ab81721bb4c49575b0fcabecb4d629612a" translate="yes" xml:space="preserve">
          <source>Given a raw memory area &lt;code&gt;chunk&lt;/code&gt;, constructs an object of &lt;code&gt;class&lt;/code&gt; type &lt;code&gt;T&lt;/code&gt; at that address. The constructor is passed the arguments &lt;code&gt;Args&lt;/code&gt;.</source>
          <target state="translated">원시 메모리 영역 &lt;code&gt;chunk&lt;/code&gt; 주어지면 해당 주소에서 &lt;code&gt;class&lt;/code&gt; 유형 &lt;code&gt;T&lt;/code&gt; 의 객체를 구성합니다 . 생성자에는 &lt;code&gt;Args&lt;/code&gt; 인수가 전달 됩니다.</target>
        </trans-unit>
        <trans-unit id="74cf19c0277fb6a57dd8ab3cb630a33bfe4fee0c" translate="yes" xml:space="preserve">
          <source>Given a raw memory area &lt;code&gt;chunk&lt;/code&gt;, constructs an object of &lt;code&gt;class&lt;/code&gt; type &lt;code&gt;T&lt;/code&gt; at that address. The constructor is passed the arguments &lt;code&gt;Args&lt;/code&gt;. If &lt;code&gt;T&lt;/code&gt; is an inner class whose &lt;code&gt;outer&lt;/code&gt; field can be used to access an instance of the enclosing class, then &lt;code&gt;Args&lt;/code&gt; must not be empty, and the first member of it must be a valid initializer for that &lt;code&gt;outer&lt;/code&gt; field. Correct initialization of this field is essential to access members of the outer class inside &lt;code&gt;T&lt;/code&gt; methods.</source>
          <target state="translated">원시 메모리 영역 &lt;code&gt;chunk&lt;/code&gt; 주어지면 해당 주소에서 &lt;code&gt;class&lt;/code&gt; 유형 &lt;code&gt;T&lt;/code&gt; 의 객체를 구성합니다 . 생성자에는 &lt;code&gt;Args&lt;/code&gt; 인수가 전달 됩니다. 경우 &lt;code&gt;T&lt;/code&gt; 는 그 내부 클래스 &lt;code&gt;outer&lt;/code&gt; 필드를 둘러싸는 클래스의 인스턴스에 액세스하는 데 사용될 수는 다음 &lt;code&gt;Args&lt;/code&gt; 비어 있지 않아야하고 그것의 제 1 부재에는 해당하는 유효 초기화 있어야 &lt;code&gt;outer&lt;/code&gt; 필드. 이 필드의 올바른 초기화는 &lt;code&gt;T&lt;/code&gt; 메소드 내부의 외부 클래스 멤버에 액세스하는 데 필수적 입니다.</target>
        </trans-unit>
        <trans-unit id="e137ad6b52d9b560e6ecf089479316e86462ce01" translate="yes" xml:space="preserve">
          <source>Given a raw memory area &lt;code&gt;chunk&lt;/code&gt;, constructs an object of non-&lt;code&gt;class&lt;/code&gt; type &lt;code&gt;T&lt;/code&gt; at that address. The constructor is passed the arguments &lt;code&gt;args&lt;/code&gt;, if any.</source>
          <target state="translated">원시 메모리 영역 &lt;code&gt;chunk&lt;/code&gt; 주어지면 해당 주소에서 &lt;code&gt;class&lt;/code&gt; 가 아닌 유형 &lt;code&gt;T&lt;/code&gt; 의 객체를 구성합니다 . 생성자에는 인수 &lt;code&gt;args&lt;/code&gt; 가 전달 됩니다 (있는 경우).</target>
        </trans-unit>
        <trans-unit id="f8745e4f392d96921746aba6d016d8b75a3eaf5b" translate="yes" xml:space="preserve">
          <source>Given a symbol that could be either a FuncDeclaration or a function template, resolve it to a function symbol.</source>
          <target state="translated">FuncDeclaration 또는 함수 템플릿 일 수있는 기호가 있으면 함수 기호로 해석하십시오.</target>
        </trans-unit>
        <trans-unit id="3ec7e3b2070dd15d8c86e7da24a716e09d94b001" translate="yes" xml:space="preserve">
          <source>Given a type &lt;code&gt;S&lt;/code&gt; that is one of:</source>
          <target state="translated">다음 중 하나 인 유형 &lt;code&gt;S&lt;/code&gt; 가 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="5bf486ff307c1ac9da00abda18e996a0151d6f51" translate="yes" xml:space="preserve">
          <source>Given a type &lt;code&gt;T&lt;/code&gt;, returns its allocation-related flags as a combination of &lt;code&gt;AllocFlag&lt;/code&gt; values.</source>
          <target state="translated">유형 &lt;code&gt;T&lt;/code&gt; 가 주어지면 할당 관련 플래그를 &lt;code&gt;AllocFlag&lt;/code&gt; 값 의 조합으로 반환 합니다.</target>
        </trans-unit>
        <trans-unit id="1ec656f1b47e3a570669cfd79e664b45a8112e7a" translate="yes" xml:space="preserve">
          <source>Given address that is inside a function, figure out which function it is in. Return DHandlerTable if there is one, NULL if not.</source>
          <target state="translated">함수 안에있는 주소가 있다면, 어떤 함수 안에 있는지 알아 내십시오. DHandlerTable이 있으면 리턴하고, 없으면 NULL을 리턴하십시오.</target>
        </trans-unit>
        <trans-unit id="84fb4bae252188c74a52ee250ba7895934a71e72" translate="yes" xml:space="preserve">
          <source>Given an &lt;a href=&quot;https://en.wikipedia.org/wiki/Factory_(object-oriented_programming)&quot;&gt;object factory&lt;/a&gt; of type &lt;code&gt;Factory&lt;/code&gt; or a factory function &lt;code&gt;factoryFunction&lt;/code&gt;, and optionally also &lt;code&gt;BookkeepingAllocator&lt;/code&gt; as a supplemental allocator for bookkeeping, &lt;code&gt;AllocatorList&lt;/code&gt; creates an allocator that lazily creates as many allocators are needed for satisfying client allocation requests.</source>
          <target state="translated">&lt;a href=&quot;https://en.wikipedia.org/wiki/Factory_(object-oriented_programming)&quot;&gt;팩토리&lt;/a&gt; 유형의 &lt;code&gt;Factory&lt;/code&gt; 또는 팩토리 함수 &lt;code&gt;factoryFunction&lt;/code&gt; 의 오브젝트 팩토리 및 선택적으로 &lt;code&gt;BookkeepingAllocator&lt;/code&gt; (예약 유지 를위한 보충 할당 자)가 지정되면 &lt;code&gt;AllocatorList&lt;/code&gt; 는 클라이언트 할당 요청을 충족시키기 위해 필요한만큼 많은 할당자가 느리게 작성되는 할당자를 작성합니다.</target>
        </trans-unit>
        <trans-unit id="2c2ffbad9b196900545a99b58a4a8084fb8e968f" translate="yes" xml:space="preserve">
          <source>Given an &lt;code&gt;AssignExp&lt;/code&gt;, determine if the lvalue will cause the contents of the rvalue to escape. Print error messages when these are detected. Infer &lt;code&gt;scope&lt;/code&gt; attribute for the lvalue where possible, in order to eliminate the error.</source>
          <target state="translated">&lt;code&gt;AssignExp&lt;/code&gt; 가 주어지면 lvalue가 rvalue의 내용을 이스케이프하게 만들지 결정하십시오. 오류 메시지가 감지되면 인쇄하십시오. 추론의 &lt;code&gt;scope&lt;/code&gt; 오류를 제거하기 위해 가능하면 좌변에 대한 속성.</target>
        </trans-unit>
        <trans-unit id="f4edc9674fd3041f4bd8fcdf8c36704d26537a1f" translate="yes" xml:space="preserve">
          <source>Given an Expression, find the variable it really is.</source>
          <target state="translated">식이 주어지면 실제로 변수를 찾으십시오.</target>
        </trans-unit>
        <trans-unit id="10135b6f779b47ff66661cf2060528825cdb0465" translate="yes" xml:space="preserve">
          <source>Given an allocator factory, lazily creates as many allocators as needed to satisfy allocation requests. The allocators are stored in a linked list. Requests for allocation are satisfied by searching the list in a linear manner.</source>
          <target state="translated">할당 자 팩토리가 주어지면 할당 요청을 충족시키기 위해 필요한만큼 할당자를 느리게 만듭니다. 할당자는 연결된 목록에 저장됩니다. 할당 요청은 선형 방식으로 목록을 검색하여 충족됩니다.</target>
        </trans-unit>
        <trans-unit id="c68fd4e0d6a4caa1cbbef6c7b7cc84e1b16b2800" translate="yes" xml:space="preserve">
          <source>Given an error instantiating the TemplateInstance, give the nested TemplateInstance instantiations that got us here. Those are a list threaded into the nested scopes.</source>
          <target state="translated">TemplateInstance를 인스턴스화하는 중 오류가 발생하면 중첩 된 TemplateInstance 인스턴스를 제공하십시오. 이들은 중첩 된 범위에 스레드 된 목록입니다.</target>
        </trans-unit>
        <trans-unit id="0d192178ddf2961ae655bd11083f31d24b553ec6" translate="yes" xml:space="preserve">
          <source>Given an expression e that is an array, determine and set the 'length' variable.</source>
          <target state="translated">배열 인 표현식 e가 주어지면 'length'변수를 결정하고 설정하십시오.</target>
        </trans-unit>
        <trans-unit id="13b4b240c1888ba281f7a8d067f704fc09eba179" translate="yes" xml:space="preserve">
          <source>Given array literal oldval of type ArrayLiteralExp or StringExp, of length oldlen, change its length to newlen. If the newlen is longer than oldlen, all new elements will be set to the default initializer for the element type.</source>
          <target state="translated">ArrayLiteralExp 또는 StringExp 유형의 배열 리터럴 oldval이 oldlen 인 경우 길이를 newlen로 변경하십시오. newlen이 oldlen보다 길면 모든 새 요소가 요소 유형의 기본 이니셜 라이저로 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="4fe6c27981ac387048ac652b298a3c233afd1136" translate="yes" xml:space="preserve">
          <source>Given array of foreach parameters and an aggregate type, find best opApply overload, if any of the parameter types are missing, attempt to infer them from the aggregate type.</source>
          <target state="translated">foreach 매개 변수와 집계 유형의 배열이 제공되면 매개 변수 유형이 누락 된 경우 가장 적합한 opApply 과부하를 찾으십시오.</target>
        </trans-unit>
        <trans-unit id="548081a2237345a0383114c21603c8b8dab1f303" translate="yes" xml:space="preserve">
          <source>Given callable (&lt;a href=&quot;std_traits#isCallable&quot;&gt;&lt;code&gt;std.traits.isCallable&lt;/code&gt;&lt;/a&gt;) &lt;code&gt;fun&lt;/code&gt;, create as a range whose front is defined by successive calls to &lt;code&gt;fun()&lt;/code&gt;. This is especially useful to call function with global side effects (random functions), or to create ranges expressed as a single delegate, rather than an entire &lt;code&gt;front&lt;/code&gt;/&lt;code&gt;popFront&lt;/code&gt;/&lt;code&gt;empty&lt;/code&gt; structure. &lt;code&gt;fun&lt;/code&gt; maybe be passed either a template alias parameter (existing function, delegate, struct type defining &lt;code&gt;static opCall&lt;/code&gt;) or a run-time value argument (delegate, function object). The result range models an InputRange (&lt;a href=&quot;std_range_primitives#isInputRange&quot;&gt;&lt;code&gt;std.range.primitives.isInputRange&lt;/code&gt;&lt;/a&gt;). The resulting range will call &lt;code&gt;fun()&lt;/code&gt; on construction, and every call to &lt;code&gt;popFront&lt;/code&gt;, and the cached value will be returned when &lt;code&gt;front&lt;/code&gt; is called.</source>
          <target state="translated">callable ( &lt;a href=&quot;std_traits#isCallable&quot;&gt; &lt;code&gt;std.traits.isCallable&lt;/code&gt; &lt;/a&gt; ) &lt;code&gt;fun&lt;/code&gt; 이 주어지면 &lt;code&gt;fun()&lt;/code&gt; 을 연속적으로 호출하여 범위를 정의하는 범위로 작성하십시오 . 전역 부작용 (임의 함수)을 사용하여 함수를 호출하거나 전체 &lt;code&gt;front&lt;/code&gt; / &lt;code&gt;popFront&lt;/code&gt; / &lt;code&gt;empty&lt;/code&gt; 구조가 아닌 단일 델리게이트로 표현 된 범위를 만드는 데 특히 유용합니다 . &lt;code&gt;fun&lt;/code&gt; 은 템플릿 별칭 매개 변수 (기존 함수, 대리자, &lt;code&gt;static opCall&lt;/code&gt; 정의하는 구조체 유형 ) 또는 런타임 값 인수 (대리자, 함수 객체)로 전달 될 수 있습니다. 결과 범위는 InputRange ( &lt;a href=&quot;std_range_primitives#isInputRange&quot;&gt; &lt;code&gt;std.range.primitives.isInputRange&lt;/code&gt; &lt;/a&gt; )를 모델링 합니다. 결과 범위는 &lt;code&gt;fun()&lt;/code&gt; 을 호출합니다.구성 및 &lt;code&gt;popFront&lt;/code&gt; 에 대한 모든 호출 에서 캐시 된 값은 &lt;code&gt;front&lt;/code&gt; 가 호출 될 때 반환됩니다 .</target>
        </trans-unit>
        <trans-unit id="a6cdf45c5874188e502ef446c2f299954ad8e06e" translate="yes" xml:space="preserve">
          <source>Given function arguments, figure out which template function to expand, and return matching result.</source>
          <target state="translated">함수 인수가 주어지면 확장 할 템플릿 함수를 찾아서 일치하는 결과를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="f1c0666f9da353f9c6f10f1cf5edecb5189140bb" translate="yes" xml:space="preserve">
          <source>Given that the most frequent use of &lt;code&gt;InSituRegion&lt;/code&gt; is as a stack allocator, it allocates starting at the end on systems where stack grows downwards, such that hot memory is used first.</source>
          <target state="translated">&lt;code&gt;InSituRegion&lt;/code&gt; 의 가장 빈번한 사용은 스택 할당 자로 사용 되므로 핫 메모리가 먼저 사용되도록 스택이 아래쪽으로 커지는 시스템에서 시작부터 할당합니다.</target>
        </trans-unit>
        <trans-unit id="433dfce23255598b88ff3eee832e615faf6acb1f" translate="yes" xml:space="preserve">
          <source>Given that ti is an instance of this TemplateDeclaration, deduce the types of the parameters to this, and store those deduced types in dedtypes[].</source>
          <target state="translated">ti가이 TemplateDeclaration의 인스턴스라고 가정하면 이에 대한 매개 변수 유형을 추론하고 추론 된 유형을 dedtypes []에 저장하십시오.</target>
        </trans-unit>
        <trans-unit id="de6b7e538358277d4d77d0a6dfdd22d328ebcdc2" translate="yes" xml:space="preserve">
          <source>Given y, the function finds x such log(x) - digamma(x) = y.</source>
          <target state="translated">y가 주어지면 함수는 x와 같은 log (x)-digamma (x) = y를 찾습니다.</target>
        </trans-unit>
        <trans-unit id="992b94a2b2bacb1095a0b111a75eb520df8ea274" translate="yes" xml:space="preserve">
          <source>Given y, the function finds x such that</source>
          <target state="translated">y가 주어지면 함수는 x를 찾습니다.</target>
        </trans-unit>
        <trans-unit id="a6d6838e980e7d735fe427a6cf2d72e4e8647a21" translate="yes" xml:space="preserve">
          <source>Gives a string containing all of the member variables on their own line.</source>
          <target state="translated">모든 멤버 변수를 포함하는 문자열을 자체 줄에 제공합니다.</target>
        </trans-unit>
        <trans-unit id="7913f0379d403503a25672003418cf5f3eca8630" translate="yes" xml:space="preserve">
          <source>Gives a string in the form of &lt;code&gt;Appender!(A)(data)&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Appender!(A)(data)&lt;/code&gt; 형식의 문자열을 제공합니다 .</target>
        </trans-unit>
        <trans-unit id="e8ea4a4989f9ed3007485f30bc4c477cf8cf78af" translate="yes" xml:space="preserve">
          <source>Gives a template that can be used to apply the same attributes that are on the given type &lt;code&gt;T&lt;/code&gt;. E.g. passing &lt;code&gt;inout shared int&lt;/code&gt; will return &lt;code&gt;SharedInoutOf&lt;/code&gt;.</source>
          <target state="translated">주어진 유형 &lt;code&gt;T&lt;/code&gt; 와 동일한 속성을 적용하는 데 사용할 수있는 템플리트를 제공합니다 . 예를 들어 &lt;code&gt;inout shared int&lt;/code&gt; 를 전달 하면 &lt;code&gt;SharedInoutOf&lt;/code&gt; 가 반환 됩니다 .</target>
        </trans-unit>
        <trans-unit id="a2633d057ea2e2d5df044edc1a3e53e74d5c07e4" translate="yes" xml:space="preserve">
          <source>Gives size in bytes of the memory mapped file.</source>
          <target state="translated">메모리 맵핑 된 파일의 크기를 바이트 단위로 제공합니다.</target>
        </trans-unit>
        <trans-unit id="16bbae332a1e2ca617ea29aad4cae716be022cf2" translate="yes" xml:space="preserve">
          <source>Gives the &lt;code&gt;sizeof&lt;/code&gt; the largest type given.</source>
          <target state="translated">부여 &lt;code&gt;sizeof&lt;/code&gt; 주어진 가장 큰 유형입니다.</target>
        </trans-unit>
        <trans-unit id="83055a3a0dd1a147d856955312d10beee008598a" translate="yes" xml:space="preserve">
          <source>Gives the difference between two &lt;a href=&quot;#Date&quot;&gt;&lt;code&gt;Date&lt;/code&gt;&lt;/a&gt;s.</source>
          <target state="translated">두 &lt;a href=&quot;#Date&quot;&gt; &lt;code&gt;Date&lt;/code&gt; &lt;/a&gt; 사이의 차이를 제공합니다 .</target>
        </trans-unit>
        <trans-unit id="7aeb61024a32a4be6fbe1fa0169b6dc0e34e0c60" translate="yes" xml:space="preserve">
          <source>Gives the difference between two &lt;a href=&quot;#DateTime&quot;&gt;&lt;code&gt;DateTime&lt;/code&gt;&lt;/a&gt;s.</source>
          <target state="translated">두 &lt;a href=&quot;#DateTime&quot;&gt; &lt;code&gt;DateTime&lt;/code&gt; &lt;/a&gt; 의 차이를 제공합니다 .</target>
        </trans-unit>
        <trans-unit id="a3e5e3dc87d1abe001240e5d15a0f4c35cd6e9f2" translate="yes" xml:space="preserve">
          <source>Gives the difference between two &lt;a href=&quot;#SysTime&quot;&gt;&lt;code&gt;SysTime&lt;/code&gt;&lt;/a&gt;s.</source>
          <target state="translated">두 &lt;a href=&quot;#SysTime&quot;&gt; &lt;code&gt;SysTime&lt;/code&gt; &lt;/a&gt; 의 차이를 제공합니다 .</target>
        </trans-unit>
        <trans-unit id="e0ddf7ec5492699d7655f4aa024331ee0d174c96" translate="yes" xml:space="preserve">
          <source>Gives the difference between two &lt;a href=&quot;#TimeOfDay&quot;&gt;&lt;code&gt;TimeOfDay&lt;/code&gt;&lt;/a&gt;s.</source>
          <target state="translated">두 &lt;a href=&quot;#TimeOfDay&quot;&gt; &lt;code&gt;TimeOfDay&lt;/code&gt; &lt;/a&gt; 의 차이를 나타 냅니다.</target>
        </trans-unit>
        <trans-unit id="23a706ac15ae0a2795d3b9540c47b5bd8f3ce3a4" translate="yes" xml:space="preserve">
          <source>Gives the last power of two before &lt;code&gt;val&lt;/code&gt;. &amp;lt;&amp;gt;&amp;gt; can be any built-in numerical type.</source>
          <target state="translated">&lt;code&gt;val&lt;/code&gt; 전에 2의 ​​마지막 거듭 제곱을 제공합니다 . &amp;lt;&amp;gt;&amp;gt;는 모든 내장 숫자 유형이 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5eba15a4a12033f10f76ecaeb54e9264300c3d84" translate="yes" xml:space="preserve">
          <source>Gives the next power of two after &lt;code&gt;val&lt;/code&gt;. &lt;code&gt;T&lt;/code&gt; can be any built-in numerical type.</source>
          <target state="translated">&lt;code&gt;val&lt;/code&gt; 다음에 2의 다음 거듭 제곱을 제공합니다 . &lt;code&gt;T&lt;/code&gt; 는 모든 내장 숫자 유형이 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5dcd127d912205c801dfa9fd55aab21bc7540488" translate="yes" xml:space="preserve">
          <source>Gives the precision for numeric conversions. If the precision is a &lt;b&gt;*&lt;/b&gt;, an additional argument of type &lt;b&gt;int&lt;/b&gt;, preceding the actual argument, is taken as the precision. If it is negative, it is as if there was no</source>
          <target state="translated">숫자 변환의 정밀도를 제공합니다. 정밀도가 &lt;b&gt;*&lt;/b&gt; 이면 실제 인수 앞에있는 &lt;b&gt;int&lt;/b&gt; 유형의 추가 인수가 정밀도로 사용됩니다. 음수이면없는 것처럼</target>
        </trans-unit>
        <trans-unit id="066636e1bed1369dff6efcd3fab1c1e8776d7710" translate="yes" xml:space="preserve">
          <source>Gives the result of adding or subtracting a &lt;a href=&quot;core_time#Duration&quot;&gt;&lt;code&gt;core.time.Duration&lt;/code&gt;&lt;/a&gt; from</source>
          <target state="translated">&lt;a href=&quot;core_time#Duration&quot;&gt; &lt;code&gt;core.time.Duration&lt;/code&gt; &lt;/a&gt; 을 더하거나 뺀 결과를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="13fd9f69f64522f3bd20d1184529d631b3677431" translate="yes" xml:space="preserve">
          <source>Gives the result of adding or subtracting a &lt;a href=&quot;core_time#Duration&quot;&gt;&lt;code&gt;core.time.Duration&lt;/code&gt;&lt;/a&gt; from this &lt;a href=&quot;#Date&quot;&gt;&lt;code&gt;Date&lt;/code&gt;&lt;/a&gt;, as well as assigning the result to this &lt;a href=&quot;#Date&quot;&gt;&lt;code&gt;Date&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 &lt;a href=&quot;#Date&quot;&gt; &lt;code&gt;Date&lt;/code&gt; &lt;/a&gt; 에서 &lt;a href=&quot;core_time#Duration&quot;&gt; &lt;code&gt;core.time.Duration&lt;/code&gt; &lt;/a&gt; 을 더하거나 뺀 결과를이 &lt;a href=&quot;#Date&quot;&gt; &lt;code&gt;Date&lt;/code&gt; 에&lt;/a&gt; 지정합니다 .</target>
        </trans-unit>
        <trans-unit id="f3c64b6298caea8c356268035bf6bb2213d1e63d" translate="yes" xml:space="preserve">
          <source>Gives the result of adding or subtracting a &lt;a href=&quot;core_time#Duration&quot;&gt;&lt;code&gt;core.time.Duration&lt;/code&gt;&lt;/a&gt; from this &lt;a href=&quot;#DateTime&quot;&gt;&lt;code&gt;DateTime&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 &lt;a href=&quot;#DateTime&quot;&gt; &lt;code&gt;DateTime&lt;/code&gt; &lt;/a&gt; 에서 &lt;a href=&quot;core_time#Duration&quot;&gt; &lt;code&gt;core.time.Duration&lt;/code&gt; &lt;/a&gt; 을 더하거나 뺀 결과를 제공합니다 .</target>
        </trans-unit>
        <trans-unit id="a1405f5ebc75767bb0c5bcf744b2d2f96a676122" translate="yes" xml:space="preserve">
          <source>Gives the result of adding or subtracting a &lt;a href=&quot;core_time#Duration&quot;&gt;&lt;code&gt;core.time.Duration&lt;/code&gt;&lt;/a&gt; from this &lt;a href=&quot;#SysTime&quot;&gt;&lt;code&gt;SysTime&lt;/code&gt;&lt;/a&gt;, as well as assigning the result to this &lt;a href=&quot;#SysTime&quot;&gt;&lt;code&gt;SysTime&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 &lt;a href=&quot;#SysTime&quot;&gt; &lt;code&gt;SysTime&lt;/code&gt; &lt;/a&gt; 에서 &lt;a href=&quot;core_time#Duration&quot;&gt; &lt;code&gt;core.time.Duration&lt;/code&gt; &lt;/a&gt; 을 더하거나 빼고 결과를이 &lt;a href=&quot;#SysTime&quot;&gt; &lt;code&gt;SysTime&lt;/code&gt; 에&lt;/a&gt; 할당 한 결과를 제공합니다 .</target>
        </trans-unit>
        <trans-unit id="aea621df7ee3b5185f92bf03dc43838e74f11ab8" translate="yes" xml:space="preserve">
          <source>Gives the result of adding or subtracting a &lt;a href=&quot;core_time#Duration&quot;&gt;&lt;code&gt;core.time.Duration&lt;/code&gt;&lt;/a&gt; from this &lt;a href=&quot;#SysTime&quot;&gt;&lt;code&gt;SysTime&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 &lt;a href=&quot;#SysTime&quot;&gt; &lt;code&gt;SysTime&lt;/code&gt; &lt;/a&gt; 에서 &lt;a href=&quot;core_time#Duration&quot;&gt; &lt;code&gt;core.time.Duration&lt;/code&gt; &lt;/a&gt; 을 더하거나 뺀 결과를 제공합니다 .</target>
        </trans-unit>
        <trans-unit id="3d5dfde7603919eee6582396d3e52686e64f60c3" translate="yes" xml:space="preserve">
          <source>Gives the result of adding or subtracting a &lt;a href=&quot;core_time#Duration&quot;&gt;&lt;code&gt;core.time.Duration&lt;/code&gt;&lt;/a&gt; from this &lt;a href=&quot;#TimeOfDay&quot;&gt;&lt;code&gt;TimeOfDay&lt;/code&gt;&lt;/a&gt;, as well as assigning the result to this &lt;a href=&quot;#TimeOfDay&quot;&gt;&lt;code&gt;TimeOfDay&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 &lt;a href=&quot;#TimeOfDay&quot;&gt; &lt;code&gt;TimeOfDay&lt;/code&gt; &lt;/a&gt; 에서 &lt;a href=&quot;core_time#Duration&quot;&gt; &lt;code&gt;core.time.Duration&lt;/code&gt; &lt;/a&gt; 을 더하거나 빼고 결과를이 &lt;a href=&quot;#TimeOfDay&quot;&gt; &lt;code&gt;TimeOfDay&lt;/code&gt; 에&lt;/a&gt; 할당 한 결과를 제공합니다 .</target>
        </trans-unit>
        <trans-unit id="c1b9fd1a6e616c022dd85e5f596721b33e55dad9" translate="yes" xml:space="preserve">
          <source>Gives the result of adding or subtracting a &lt;a href=&quot;core_time#Duration&quot;&gt;&lt;code&gt;core.time.Duration&lt;/code&gt;&lt;/a&gt; from this &lt;a href=&quot;#TimeOfDay&quot;&gt;&lt;code&gt;TimeOfDay&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 &lt;a href=&quot;#TimeOfDay&quot;&gt; &lt;code&gt;TimeOfDay&lt;/code&gt; &lt;/a&gt; 에서 &lt;a href=&quot;core_time#Duration&quot;&gt; &lt;code&gt;core.time.Duration&lt;/code&gt; &lt;/a&gt; 을 더하거나 뺀 결과를 제공합니다 .</target>
        </trans-unit>
        <trans-unit id="d7bb55c3ac43c11992ce982a465028a297070c37" translate="yes" xml:space="preserve">
          <source>Gives the result of adding or subtracting a duration from this &lt;a href=&quot;#DateTime&quot;&gt;&lt;code&gt;DateTime&lt;/code&gt;&lt;/a&gt;, as well as assigning the result to this &lt;a href=&quot;#DateTime&quot;&gt;&lt;code&gt;DateTime&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 &lt;a href=&quot;#DateTime&quot;&gt; &lt;code&gt;DateTime&lt;/code&gt; &lt;/a&gt; 에서 기간을 더하거나 빼고 결과를이 &lt;a href=&quot;#DateTime&quot;&gt; &lt;code&gt;DateTime&lt;/code&gt; 에&lt;/a&gt; 할당 한 결과를 제공합니다 .</target>
        </trans-unit>
        <trans-unit id="b010645431226eb0d475a6508504f6360118e2aa" translate="yes" xml:space="preserve">
          <source>Gives the string &lt;code&gt;&quot;Nullable.null&quot;&lt;/code&gt; if &lt;code&gt;isNull&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;. Otherwise, the result is equivalent to calling &lt;a href=&quot;std_format#formattedWrite&quot;&gt;&lt;code&gt;std.format.formattedWrite&lt;/code&gt;&lt;/a&gt; on the underlying value.</source>
          <target state="translated">&lt;code&gt;isNull&lt;/code&gt; 이 &lt;code&gt;true&lt;/code&gt; 인 경우 &lt;code&gt;&quot;Nullable.null&quot;&lt;/code&gt; 문자열을 제공 합니다 . 그렇지 않으면 결과는 기본 값에서 &lt;a href=&quot;std_format#formattedWrite&quot;&gt; &lt;code&gt;std.format.formattedWrite&lt;/code&gt; &lt;/a&gt; 를 호출하는 것과 같습니다 .</target>
        </trans-unit>
        <trans-unit id="ee3ba1f4d58b51dacaf77da9e736c2398dd52211" translate="yes" xml:space="preserve">
          <source>Giving better error messages inside generic code than the sometimes hard to follow compiler ones.</source>
          <target state="translated">때때로 따르기 어려운 컴파일러보다 일반적인 코드 내에 더 나은 오류 메시지를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="fe40132df9803a579f2616316fd9f36e8b76b6f5" translate="yes" xml:space="preserve">
          <source>Glagolitic</source>
          <target state="translated">Glagolitic</target>
        </trans-unit>
        <trans-unit id="52d16b8e3607d3a956a90dad397b270e88b2a626" translate="yes" xml:space="preserve">
          <source>Glibc C runtime</source>
          <target state="translated">Glibc C 런타임</target>
        </trans-unit>
        <trans-unit id="5f1184f7df96c5928092ad9c6b550699bf887826" translate="yes" xml:space="preserve">
          <source>Global</source>
          <target state="translated">Global</target>
        </trans-unit>
        <trans-unit id="ae4f56ae4da16df74b3d2aeca8b4352281e7be45" translate="yes" xml:space="preserve">
          <source>Global Functions</source>
          <target state="translated">글로벌 함수</target>
        </trans-unit>
        <trans-unit id="60d510ca3fec034b096ecb101e79c44baa3bcfa4" translate="yes" xml:space="preserve">
          <source>Global and Static Initializers</source>
          <target state="translated">글로벌 및 정적 이니셜 라이저</target>
        </trans-unit>
        <trans-unit id="ad8992e0e77b510d8dd8c9f31b8493285307157f" translate="yes" xml:space="preserve">
          <source>Global names</source>
          <target state="translated">글로벌 이름</target>
        </trans-unit>
        <trans-unit id="fb160cab6ebf08ae16224b7387fbe010ff67af79" translate="yes" xml:space="preserve">
          <source>Global random number generator used by various functions in this module whenever no generator is specified. It is allocated per-thread and initialized to an unpredictable value for each thread.</source>
          <target state="translated">생성기가 지정되지 않은 경우이 모듈의 다양한 기능에서 사용되는 전역 난수 생성기. 스레드 당 할당되며 각 스레드에 대해 예측할 수없는 값으로 초기화됩니다.</target>
        </trans-unit>
        <trans-unit id="359a7909d420e528181333df942be655d355c0d2" translate="yes" xml:space="preserve">
          <source>Global regex, repeat over the whole input.</source>
          <target state="translated">글로벌 정규 표현식, 전체 입력에 대해 반복하십시오.</target>
        </trans-unit>
        <trans-unit id="9d8204544b72aac8944f7aa50f34d5f2b83ebda7" translate="yes" xml:space="preserve">
          <source>Global status of the CTFE engine. Mostly used for performance diagnostics</source>
          <target state="translated">CTFE 엔진의 글로벌 상태. 성능 진단에 주로 사용</target>
        </trans-unit>
        <trans-unit id="3bb8f4a4ce9e8fc53902a34f5711af6100354847" translate="yes" xml:space="preserve">
          <source>Global variables.</source>
          <target state="translated">글로벌 변수.</target>
        </trans-unit>
        <trans-unit id="322346956002b43d1272ba3ca4fad36e87acf31f" translate="yes" xml:space="preserve">
          <source>Go through the variables in function fd that are to be allocated in a closure, and set the .offset fields for those variables to their positions relative to the start of the closure instance. Also turns off nrvo for closure variables.</source>
          <target state="translated">클로저에 할당 될 함수 fd의 변수를 살펴보고 해당 변수의 .offset 필드를 클로저 인스턴스의 시작과 관련된 위치로 설정하십시오. 또한 클로저 변수에 대해 nrvo를 끕니다.</target>
        </trans-unit>
        <trans-unit id="83644e2182412c095ed367b8519c41f7f1a72b2f" translate="yes" xml:space="preserve">
          <source>Good error handling code tends to clutter up what otherwise would be a neat and clean looking implementation.</source>
          <target state="translated">좋은 오류 처리 코드는 깔끔하고 깔끔한 구현을 혼란스럽게 만드는 경향이 있습니다.</target>
        </trans-unit>
        <trans-unit id="a4cc20ddddd5df91dbeeeac20e28069cdc6d35d5" translate="yes" xml:space="preserve">
          <source>Gothic</source>
          <target state="translated">Gothic</target>
        </trans-unit>
        <trans-unit id="523bd87e510be4584eb678bda56047b4e81b4e41" translate="yes" xml:space="preserve">
          <source>Goto Statement</source>
          <target state="translated">고토 진술</target>
        </trans-unit>
        <trans-unit id="d153d2afa0d10e789b42decd9c86f4c6ba7c4b32" translate="yes" xml:space="preserve">
          <source>GotoCaseStatements &lt;strong id=&quot;gotoCases&quot;&gt;gotoCases&lt;/strong&gt;;</source>
          <target state="translated">GotoCaseStatements &lt;strong id=&quot;gotoCases&quot;&gt;gotoCases&lt;/strong&gt; ;</target>
        </trans-unit>
        <trans-unit id="2d75a452fb197b862328ddf89077f60c5411007e" translate="yes" xml:space="preserve">
          <source>GotoStatement</source>
          <target state="translated">GotoStatement</target>
        </trans-unit>
        <trans-unit id="469b09861974ba8cba6608f5b50f5a4378e847aa" translate="yes" xml:space="preserve">
          <source>GotoStatements* &lt;strong id=&quot;gotos&quot;&gt;gotos&lt;/strong&gt;;</source>
          <target state="translated">GotoStatements * &lt;strong id=&quot;gotos&quot;&gt;gotos&lt;/strong&gt; ;</target>
        </trans-unit>
        <trans-unit id="b1b76e26ed39195055923abbd6da5da5869145b4" translate="yes" xml:space="preserve">
          <source>Gotos with forward references</source>
          <target state="translated">전방 참조가있는 Gotos</target>
        </trans-unit>
        <trans-unit id="dd17342cb47b948d64f169d73cfeec3f8b3e3f31" translate="yes" xml:space="preserve">
          <source>Grammar</source>
          <target state="translated">Grammar</target>
        </trans-unit>
        <trans-unit id="40e6976321b98f0050106aca23fe0094f3e12aec" translate="yes" xml:space="preserve">
          <source>Grapheme &lt;strong id=&quot;decodeGrapheme&quot;&gt;decodeGrapheme&lt;/strong&gt;(Input)(ref Input inp)</source>
          <target state="translated">Grapheme &lt;strong id=&quot;decodeGrapheme&quot;&gt;decodeGrapheme&lt;/strong&gt; (입력) (ref 입력 inp)</target>
        </trans-unit>
        <trans-unit id="09e21aefbc5d72becfb6e61403ad83558925c509" translate="yes" xml:space="preserve">
          <source>Grapheme cluster length in &lt;a href=&quot;#Code%20point&quot;&gt;code points&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#Code%20point&quot;&gt;코드 포인트의&lt;/a&gt; Grapheme 클러스터 길이 .</target>
        </trans-unit>
        <trans-unit id="85a58af54a6759d4a9d1a773cb4f960185f26fe4" translate="yes" xml:space="preserve">
          <source>Grapheme_Base</source>
          <target state="translated">Grapheme_Base</target>
        </trans-unit>
        <trans-unit id="9aa96ceeca035f99f4979af4785877395b3fcca9" translate="yes" xml:space="preserve">
          <source>Grapheme_Extend</source>
          <target state="translated">Grapheme_Extend</target>
        </trans-unit>
        <trans-unit id="2299a70876b7b20196c0e232824b6e303cf0f817" translate="yes" xml:space="preserve">
          <source>Grapheme_Link</source>
          <target state="translated">Grapheme_Link</target>
        </trans-unit>
        <trans-unit id="59d5f5b13f13f6d5e8e88a5a92e137f7d64b2954" translate="yes" xml:space="preserve">
          <source>Greek</source>
          <target state="translated">Greek</target>
        </trans-unit>
        <trans-unit id="305ccd272b16a96e13db1c4faa38b1913caf51d8" translate="yes" xml:space="preserve">
          <source>Greek Extended</source>
          <target state="translated">그리스어 확장</target>
        </trans-unit>
        <trans-unit id="63e0451063c60d5f6eae102313ee1b6d993a1f76" translate="yes" xml:space="preserve">
          <source>Greek and Coptic</source>
          <target state="translated">그리스와 콥트어</target>
        </trans-unit>
        <trans-unit id="73fb2dd5cc2643e9f02bc351410b98713e0c50c9" translate="yes" xml:space="preserve">
          <source>Group separator</source>
          <target state="translated">그룹 분리기</target>
        </trans-unit>
        <trans-unit id="10986e5fcbdd40c81d3e51dfc3ad691df9a6347c" translate="yes" xml:space="preserve">
          <source>Group!(pred, Range) &lt;strong id=&quot;group&quot;&gt;group&lt;/strong&gt;(alias pred = &quot;a == b&quot;, Range)(Range r);</source>
          <target state="translated">Group! (사전, 범위) &lt;strong id=&quot;group&quot;&gt;그룹&lt;/strong&gt; (별칭 pred = &quot;a == b&quot;, 범위) (범위 r);</target>
        </trans-unit>
        <trans-unit id="83af1301254c2810b776d48cab533ffdca19f557" translate="yes" xml:space="preserve">
          <source>Groups consecutively equivalent elements into a single tuple of the element and the number of its repetitions.</source>
          <target state="translated">연속적으로 동등한 요소를 요소의 단일 튜플과 반복 횟수로 그룹화합니다.</target>
        </trans-unit>
        <trans-unit id="afb8bcba7055a53eb0c5db950f6c2af39388fdf2" translate="yes" xml:space="preserve">
          <source>Grows &lt;code&gt;array&lt;/code&gt; by appending &lt;code&gt;delta&lt;/code&gt; more elements. The needed memory is allocated using &lt;code&gt;alloc&lt;/code&gt;. The extra elements added are either default- initialized, filled with copies of &lt;code&gt;init&lt;/code&gt;, or initialized with values fetched from &lt;code&gt;range&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;delta&lt;/code&gt; 더 많은 요소 를 추가하여 &lt;code&gt;array&lt;/code&gt; 을 확장 합니다. 필요한 메모리는 &lt;code&gt;alloc&lt;/code&gt; 을 사용하여 할당 됩니다. 추가 된 추가 요소는 기본적으로 초기화 되거나, &lt;code&gt;init&lt;/code&gt; 사본으로 채워지 거나, &lt;code&gt;range&lt;/code&gt; 에서 가져온 값으로 초기화됩니다 .</target>
        </trans-unit>
        <trans-unit id="e03f30a2f53aecda689ec68c63bc0d88b73542a6" translate="yes" xml:space="preserve">
          <source>Grows &lt;code&gt;array&lt;/code&gt; by appending &lt;code&gt;delta&lt;/code&gt; more elements. The needed memory is allocated using the same allocator that was used for the array type. The extra elements added are either default-initialized, filled with copies of &lt;code&gt;init&lt;/code&gt;, or initialized with values fetched from &lt;code&gt;range&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;delta&lt;/code&gt; 더 많은 요소 를 추가하여 &lt;code&gt;array&lt;/code&gt; 을 확장 합니다. 필요한 메모리는 배열 유형에 사용 된 것과 동일한 할당자를 사용하여 할당됩니다. 추가 된 추가 요소는 기본적으로 초기화 되거나 &lt;code&gt;init&lt;/code&gt; 사본으로 채워지 거나 &lt;code&gt;range&lt;/code&gt; 에서 가져온 값으로 초기화됩니다 .</target>
        </trans-unit>
        <trans-unit id="77afda6ffc95cc0f06adb904e94cef0fc69add7d" translate="yes" xml:space="preserve">
          <source>Guaranteed &amp;Omicron;(&lt;code&gt;abs(length - newLength)&lt;/code&gt;) if &lt;code&gt;capacity &amp;gt;= newLength&lt;/code&gt;. If &lt;code&gt;capacity &amp;lt; newLength&lt;/code&gt; the worst case is &amp;Omicron;(&lt;code&gt;newLength&lt;/code&gt;).</source>
          <target state="translated">&lt;code&gt;capacity &amp;gt;= newLength&lt;/code&gt; 경우 &amp;Omicron; ( &lt;code&gt;abs(length - newLength)&lt;/code&gt; )가 보장 됩니다 . 경우 &lt;code&gt;capacity &amp;lt; newLength&lt;/code&gt; 최악의 경우는 &amp;Omicron; (이다 &lt;code&gt;newLength&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="929a28d261428029e61c0f81c6161fd71ba0b2fe" translate="yes" xml:space="preserve">
          <source>Guides</source>
          <target state="translated">Guides</target>
        </trans-unit>
        <trans-unit id="35776951606a73d6ff2bfb1c43d6ba2de2721cad" translate="yes" xml:space="preserve">
          <source>Guillaume Chatelet</source>
          <target state="translated">기 illa 샤 틀레</target>
        </trans-unit>
        <trans-unit id="971317803587830757efb436fa41eeb1d9292828" translate="yes" xml:space="preserve">
          <source>Guillaume Chatelet Manu Evans</source>
          <target state="translated">기 illa 샤 틀레 마누 에반스</target>
        </trans-unit>
        <trans-unit id="c06c55a5bcd005bf56c5234eb953099ffc1de3f1" translate="yes" xml:space="preserve">
          <source>Gujarati</source>
          <target state="translated">Gujarati</target>
        </trans-unit>
        <trans-unit id="265e1c23debf982bad1eb28dbf1fb86580b82eab" translate="yes" xml:space="preserve">
          <source>Gurmukhi</source>
          <target state="translated">Gurmukhi</target>
        </trans-unit>
        <trans-unit id="72c5d728b8c5e13d38cf050220cb41c1803704d1" translate="yes" xml:space="preserve">
          <source>H &lt;code&gt;m&lt;/code&gt;</source>
          <target state="translated">H의 &lt;code&gt;m&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="d44602ce53397cc7e3837311abb7db1d03042b84" translate="yes" xml:space="preserve">
          <source>H. S. Teoh's &lt;a href=&quot;http://wiki.dlang.org/Component_programming_with_ranges&quot;&gt;tutorial on component programming with ranges&lt;/a&gt; for a real-world showcase of the influence of range-based programming on complex algorithms.</source>
          <target state="translated">복잡한 알고리즘에 대한 범위 기반 프로그래밍의 영향에 대한 실제 쇼케이스를위한 &lt;a href=&quot;http://wiki.dlang.org/Component_programming_with_ranges&quot;&gt;범위&lt;/a&gt; 가있는 컴포넌트 프로그래밍에 대한 HS Teoh의 튜토리얼 .</target>
        </trans-unit>
        <trans-unit id="7fa36c2d12dc8308dd96737ca9539591241ccb57" translate="yes" xml:space="preserve">
          <source>HTML can be embedded into the documentation comments, and it will be passed through to the HTML output unchanged. However, since it is not necessarily true that HTML will be the desired output format of the embedded documentation comment extractor, it is best to avoid using it where practical.</source>
          <target state="translated">HTML은 문서 주석에 포함될 수 있으며 변경되지 않은 HTML 출력으로 전달됩니다. 그러나 HTML이 포함 된 문서 주석 추출기의 원하는 출력 형식 일 필요는 없지만 반드시 실제 사용하지 않는 것이 가장 좋습니다.</target>
        </trans-unit>
        <trans-unit id="f40b27d6b8b9a4fc3827264c1da16a04ecf4d094" translate="yes" xml:space="preserve">
          <source>HTTP</source>
          <target state="translated">HTTP</target>
        </trans-unit>
        <trans-unit id="0481530df63832f72dfdebbe0c7a51d57e32da26" translate="yes" xml:space="preserve">
          <source>HTTP &lt;code&gt;conn&lt;/code&gt;</source>
          <target state="translated">HTTP &lt;code&gt;conn&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="ca83e4b247db9f9a4bf080067c192c5cb65a0d61" translate="yes" xml:space="preserve">
          <source>HTTP &lt;strong id=&quot;dup&quot;&gt;dup&lt;/strong&gt;();</source>
          <target state="translated">HTTP &lt;strong id=&quot;dup&quot;&gt;dup&lt;/strong&gt; ();</target>
        </trans-unit>
        <trans-unit id="e4e09a7d12cb155ba460134c8bdd1f1479d801ce" translate="yes" xml:space="preserve">
          <source>HTTP POST method</source>
          <target state="translated">HTTP POST 방법</target>
        </trans-unit>
        <trans-unit id="923988ff39d0e3042c9df0f259d1de84a01fde11" translate="yes" xml:space="preserve">
          <source>HTTP PUT</source>
          <target state="translated">HTTP PUT</target>
        </trans-unit>
        <trans-unit id="cc2478137d7b71e72935b2fddc027880593e756f" translate="yes" xml:space="preserve">
          <source>HTTP client functionality.</source>
          <target state="translated">HTTP 클라이언트 기능.</target>
        </trans-unit>
        <trans-unit id="827e4a67a71c875b43e732a905d1fd8e7200d6d6" translate="yes" xml:space="preserve">
          <source>HTTP connect request.</source>
          <target state="translated">HTTP 연결 요청</target>
        </trans-unit>
        <trans-unit id="51449b9a0615713cbd19f5f01e23d5f58e4358b0" translate="yes" xml:space="preserve">
          <source>HTTP connection to use</source>
          <target state="translated">사용할 HTTP 연결</target>
        </trans-unit>
        <trans-unit id="797634e3b267b6d81699bf16ac8a0f81dc1a1ba6" translate="yes" xml:space="preserve">
          <source>HTTP connection to use  The template parameter &lt;code&gt;T&lt;/code&gt; specifies the type to return. Possible values are &lt;code&gt;char&lt;/code&gt; and &lt;code&gt;ubyte&lt;/code&gt; to return &lt;code&gt;char[]&lt;/code&gt; or &lt;code&gt;ubyte[]&lt;/code&gt;.</source>
          <target state="translated">사용할 HTTP 연결 템플리트 매개 변수 &lt;code&gt;T&lt;/code&gt; 는 리턴 할 유형을 지정합니다. &lt;code&gt;char[]&lt;/code&gt; 또는 &lt;code&gt;ubyte[]&lt;/code&gt; 를 리턴 하는 &lt;code&gt;char&lt;/code&gt; 및 &lt;code&gt;ubyte&lt;/code&gt; 값이 가능합니다 .</target>
        </trans-unit>
        <trans-unit id="e5b69d980b7b8a0f8d5057989430d112ecf22206" translate="yes" xml:space="preserve">
          <source>HTTP method used.</source>
          <target state="translated">사용 된 HTTP 메소드.</target>
        </trans-unit>
        <trans-unit id="bedfc3b8a98f74436dfffc470905a4cb727d6eb4" translate="yes" xml:space="preserve">
          <source>HTTP options request.</source>
          <target state="translated">HTTP 옵션 요청</target>
        </trans-unit>
        <trans-unit id="eca27a5fb0f79404f93ba2b2ff7621d850fa94c3" translate="yes" xml:space="preserve">
          <source>HTTP patch content.</source>
          <target state="translated">HTTP 패치 내용.</target>
        </trans-unit>
        <trans-unit id="0f24bcb381b514379fb794061233a0fac483e67d" translate="yes" xml:space="preserve">
          <source>HTTP post content.</source>
          <target state="translated">HTTP 게시물 내용.</target>
        </trans-unit>
        <trans-unit id="fd473bd4cc525d8634b2d06223e94be806e9169e" translate="yes" xml:space="preserve">
          <source>HTTP request, for odd commands like DELETE, TRACE and others</source>
          <target state="translated">DELETE, TRACE 등과 같은 이상한 명령에 대한 HTTP 요청</target>
        </trans-unit>
        <trans-unit id="7c360b79abb627a8a4c93e546c995b917aedbbb1" translate="yes" xml:space="preserve">
          <source>HTTP status line code e.g. 200.</source>
          <target state="translated">HTTP 상태 라인 코드 (예 : 200)</target>
        </trans-unit>
        <trans-unit id="7fb8b94d5f23dd0fd12704704bd5724a9a81dd11" translate="yes" xml:space="preserve">
          <source>HTTP status line ie. the first line returned in an HTTP response.</source>
          <target state="translated">HTTP 상태 줄 즉 첫 번째 줄은 HTTP 응답으로 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="5c1ee2091ce3bea9e5a23e0562f6b6fd7953de16" translate="yes" xml:space="preserve">
          <source>HTTP status line of last response. One call to perform may result in several requests because of redirection.</source>
          <target state="translated">마지막 응답의 HTTP 상태 라인. 한 번의 호출로 리디렉션 때문에 여러 요청이 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="45f917922bd09e11086c274630d2415137d36f0f" translate="yes" xml:space="preserve">
          <source>HTTP status line reason string.</source>
          <target state="translated">HTTP 상태 행 이유 문자열</target>
        </trans-unit>
        <trans-unit id="1909e6b2261783a8d317d6f55a66a50ec6cfafb1" translate="yes" xml:space="preserve">
          <source>HTTP trace request.</source>
          <target state="translated">HTTP 추적 요청</target>
        </trans-unit>
        <trans-unit id="52f8dbc2c259a9731d9751db65ced2bb8937f72a" translate="yes" xml:space="preserve">
          <source>HTTP.TimeCond &lt;code&gt;cond&lt;/code&gt;</source>
          <target state="translated">HTTP.TimeCond &lt;code&gt;cond&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="a59dd0563a7efe56dbe888a8e6b63f08d0ec7b1a" translate="yes" xml:space="preserve">
          <source>HTTP/FTP delete content.</source>
          <target state="translated">HTTP / FTP는 컨텐츠를 삭제합니다.</target>
        </trans-unit>
        <trans-unit id="c911addb5a09d460fe739f0ee6699cd1115b2ceb" translate="yes" xml:space="preserve">
          <source>HTTP/FTP download to local file system.</source>
          <target state="translated">로컬 파일 시스템으로 HTTP / FTP 다운로드</target>
        </trans-unit>
        <trans-unit id="444e75970e6f6b8a13c7660b530b8789eb9d1688" translate="yes" xml:space="preserve">
          <source>HTTP/FTP fetch content as a range of chunks asynchronously.</source>
          <target state="translated">HTTP / FTP는 비동기 적으로 청크 범위로 컨텐츠를 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="067f2a38c032292745289e6d568747297c1eb36d" translate="yes" xml:space="preserve">
          <source>HTTP/FTP fetch content as a range of chunks.</source>
          <target state="translated">HTTP / FTP는 다양한 청크로 콘텐츠를 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="ba7a6201d2a706377c412c319526144deec7201e" translate="yes" xml:space="preserve">
          <source>HTTP/FTP fetch content as a range of lines asynchronously.</source>
          <target state="translated">HTTP / FTP는 컨텐츠를 비동기 적으로 라인 범위로 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="a30ab80f3f96882837554330daf0f4a6aaa048ff" translate="yes" xml:space="preserve">
          <source>HTTP/FTP fetch content as a range of lines.</source>
          <target state="translated">HTTP / FTP는 컨텐츠를 여러 줄로 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="0a0a651b4d9a70a2c11401ce60fa08020ea7c52c" translate="yes" xml:space="preserve">
          <source>HTTP/FTP get content.</source>
          <target state="translated">HTTP / FTP는 컨텐츠를 얻습니다.</target>
        </trans-unit>
        <trans-unit id="a18566ddab985dc1d64ecd1c3e55c7fe0283f6cd" translate="yes" xml:space="preserve">
          <source>HTTP/FTP put content.</source>
          <target state="translated">HTTP / FTP는 내용을 넣습니다.</target>
        </trans-unit>
        <trans-unit id="fd41ab93c5537d58968dc08902626f4aedcfc790" translate="yes" xml:space="preserve">
          <source>Halfwidth and Fullwidth Forms</source>
          <target state="translated">반자 및 전각 양식</target>
        </trans-unit>
        <trans-unit id="15710324ddc14a3ddc719e414d041bb782d93764" translate="yes" xml:space="preserve">
          <source>Han</source>
          <target state="translated">Han</target>
        </trans-unit>
        <trans-unit id="495fba644d4dd3d28a3df2c5e262bc0aa344bdc1" translate="yes" xml:space="preserve">
          <source>Handle and transcode between various text encodings.</source>
          <target state="translated">다양한 텍스트 인코딩 간 처리 및 코드 변환</target>
        </trans-unit>
        <trans-unit id="4cae35b945ed013183aeec759fb173f2b5e74ee5" translate="yes" xml:space="preserve">
          <source>Handle enums.</source>
          <target state="translated">열거 형을 처리하십시오.</target>
        </trans-unit>
        <trans-unit id="70c0fd2c64cbbc7d9a73e18bc0fd02b46b142b9f" translate="yes" xml:space="preserve">
          <source>Handle exceptions thrown from range primitives.</source>
          <target state="translated">범위 기본 요소에서 발생한 예외를 처리합니다.</target>
        </trans-unit>
        <trans-unit id="ed3da861f4c68bd404277c3815bb4277903ee0c7" translate="yes" xml:space="preserve">
          <source>Handle the postblit call on lvalue, or the move of rvalue.</source>
          <target state="translated">lvalue 또는 rvalue 이동에 대한 포스트 블리치 호출을 처리하십시오.</target>
        </trans-unit>
        <trans-unit id="e61477ad33d711243071181209298dcaac99b754" translate="yes" xml:space="preserve">
          <source>Handle to the system-specific semaphore.</source>
          <target state="translated">시스템 별 세마포어를 처리합니다.</target>
        </trans-unit>
        <trans-unit id="362f233bfd36bbe9ffba21ece507104cececa24e" translate="yes" xml:space="preserve">
          <source>Handlers</source>
          <target state="translated">Handlers</target>
        </trans-unit>
        <trans-unit id="bd7d4b95fcd93ad906141f781368bc43c7c7f10a" translate="yes" xml:space="preserve">
          <source>Hangul</source>
          <target state="translated">Hangul</target>
        </trans-unit>
        <trans-unit id="46a74e921ed0b81734815d203a76d63ac9b445e2" translate="yes" xml:space="preserve">
          <source>Hangul Compatibility Jamo</source>
          <target state="translated">한글 호환성 자모</target>
        </trans-unit>
        <trans-unit id="6e435e03b7ff7b49d783dd12f4139eb337e88129" translate="yes" xml:space="preserve">
          <source>Hangul Jamo</source>
          <target state="translated">한글 자모</target>
        </trans-unit>
        <trans-unit id="1af30ae437546a0c8f4e8c904b38e9e32c465cd5" translate="yes" xml:space="preserve">
          <source>Hangul Jamo Extended-A</source>
          <target state="translated">한글 자모 확장 -A</target>
        </trans-unit>
        <trans-unit id="7f76ea3a5ca65b3f7be6271028b86fb4c24ad5b4" translate="yes" xml:space="preserve">
          <source>Hangul Jamo Extended-B</source>
          <target state="translated">한글 자모 확장 B</target>
        </trans-unit>
        <trans-unit id="a3c09f1beeeb5e6518d7a5aa130f9229a5bab1c8" translate="yes" xml:space="preserve">
          <source>Hangul Syllables</source>
          <target state="translated">한글 음절</target>
        </trans-unit>
        <trans-unit id="9649db5db6338c7bb1ab5215b20988c58817b67a" translate="yes" xml:space="preserve">
          <source>Hangul syllables are not covered by this function. See &lt;code&gt;composeJamo&lt;/code&gt; below.</source>
          <target state="translated">한글 음절에는이 기능이 적용되지 않습니다. 아래의 &lt;code&gt;composeJamo&lt;/code&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="ed413af43425a39818253cc0c5de7394d4a39735" translate="yes" xml:space="preserve">
          <source>Hanunoo</source>
          <target state="translated">Hanunoo</target>
        </trans-unit>
        <trans-unit id="e938944cea2d9cc40e1f9955e4a0cfe8a2544308" translate="yes" xml:space="preserve">
          <source>Hardware Control</source>
          <target state="translated">하드웨어 제어</target>
        </trans-unit>
        <trans-unit id="624a7b201d0ea02f7b27a09976e5469ea739a9e3" translate="yes" xml:space="preserve">
          <source>Has the same meaning as outside of a character class.</source>
          <target state="translated">문자 클래스 외부와 동일한 의미를 갖습니다.</target>
        </trans-unit>
        <trans-unit id="ff69afc8afb157be53fcca5d806ead0afca8f54a" translate="yes" xml:space="preserve">
          <source>Hash &lt;strong id=&quot;makeDigest&quot;&gt;makeDigest&lt;/strong&gt;(Hash)();</source>
          <target state="translated">해시 &lt;strong id=&quot;makeDigest&quot;&gt;makeDigest&lt;/strong&gt; (해시) ();</target>
        </trans-unit>
        <trans-unit id="512530e2001855653aa805d74cb64a05638ad3fd" translate="yes" xml:space="preserve">
          <source>Hash options.</source>
          <target state="translated">해시 옵션.</target>
        </trans-unit>
        <trans-unit id="82c3b55a6e6190b4ea897a708e89b49564008ef7" translate="yes" xml:space="preserve">
          <source>Hash syntax for json objects.</source>
          <target state="translated">json 객체의 해시 구문.</target>
        </trans-unit>
        <trans-unit id="8d05adeedcb7aa54cc03e4f260b3e38d1479ae1c" translate="yes" xml:space="preserve">
          <source>HashTab container for internal usage.</source>
          <target state="translated">내부 사용을위한 HashTab 컨테이너.</target>
        </trans-unit>
        <trans-unit id="201cd54dff7c562fa04665ce3ec7f389323b7356" translate="yes" xml:space="preserve">
          <source>Have some variables that are maybescopes that were assigned values from other maybescope variables. Now that semantic analysis of the function is complete, we can finalize this by turning off maybescope for array elements that cannot be scope.</source>
          <target state="translated">다른 범위 변수의 값이 지정된 범위 범위 변수 일 수 있습니다. 함수의 의미 론적 분석이 완료되었으므로 범위가 될 수없는 배열 요소에 대해 maybescope를 해제하여이를 마무리 할 수 ​​있습니다.</target>
        </trans-unit>
        <trans-unit id="dea56ebbd4737b0cd9262ab0c819e3683d0b5416" translate="yes" xml:space="preserve">
          <source>Having unmatched parentheses can hose the output of Ddoc, as the macros depend on properly nested parentheses. This function replaces all ( with ( and ) with ) to preserve text literally. This also means macros in the text won't be expanded.</source>
          <target state="translated">매크로가 올바르게 중첩 된 괄호에 의존하기 때문에 괄호가 일치하지 않으면 Ddoc의 출력이 호스로 연결될 수 있습니다. 이 함수는 문자를 그대로 유지하기 위해 모든 (와 (및)을)로 바꿉니다. 이것은 또한 텍스트의 매크로가 확장되지 않음을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="71653e5271aa72abad98ba52f8927b0be428b96b" translate="yes" xml:space="preserve">
          <source>Haystack &lt;code&gt;haystack&lt;/code&gt;</source>
          <target state="translated">건초 &lt;code&gt;haystack&lt;/code&gt; 건초 더미</target>
        </trans-unit>
        <trans-unit id="e0403de1effb4e88849c3d2d079f299e89f093ed" translate="yes" xml:space="preserve">
          <source>HeaderFormat &lt;code&gt;header&lt;/code&gt;</source>
          <target state="translated">HeaderFormat &lt;code&gt;header&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="c97d4c3dede14ee24bc42018c52f19917fd481c9" translate="yes" xml:space="preserve">
          <source>Headings</source>
          <target state="translated">Headings</target>
        </trans-unit>
        <trans-unit id="348d00693e12bc983bd092677b90434b5a4d869e" translate="yes" xml:space="preserve">
          <source>Hebrew</source>
          <target state="translated">Hebrew</target>
        </trans-unit>
        <trans-unit id="fbea2ec13adcf999e380e13a429a4e17dc3d8090" translate="yes" xml:space="preserve">
          <source>Help Information Generation</source>
          <target state="translated">정보 생성 도움말</target>
        </trans-unit>
        <trans-unit id="1e7eebdb08c9dbf27c7668e2badd51e667707d3c" translate="yes" xml:space="preserve">
          <source>Helper</source>
          <target state="translated">Helper</target>
        </trans-unit>
        <trans-unit id="5e31a530e83afec402c4c09898e79e56b473dc7d" translate="yes" xml:space="preserve">
          <source>Helper for NewExp Create a string literal consisting of 'value' duplicated 'dim' times.</source>
          <target state="translated">NewExp의 도우미 '값'복제 된 'dim'시간으로 구성된 문자열 리터럴을 작성하십시오.</target>
        </trans-unit>
        <trans-unit id="766c386647e8e48a9fcd435724f1d350167f7ed5" translate="yes" xml:space="preserve">
          <source>Helper for NewExp Create an array literal consisting of 'elem' duplicated 'dim' times.</source>
          <target state="translated">NewExp의 도우미 'elem'복제 된 'dim'시간으로 구성된 배열 리터럴을 만듭니다.</target>
        </trans-unit>
        <trans-unit id="c02c79263e4ed8c5595da2dd0c63a6d49edcd0eb" translate="yes" xml:space="preserve">
          <source>Helper function for &lt;code&gt;getRightThis()&lt;/code&gt;. Gets &lt;code&gt;this&lt;/code&gt; of the next outer aggregate.</source>
          <target state="translated">&lt;code&gt;getRightThis()&lt;/code&gt; 헬퍼 함수 . 다음 외부 집계의 &lt;code&gt;this&lt;/code&gt; 가져 옵니다.</target>
        </trans-unit>
        <trans-unit id="467531459771317152c9703e3f120447d81f80b5" translate="yes" xml:space="preserve">
          <source>Helper function for easy error propagation. If error occurs, returns ErrorExp. Otherwise returns NULL.</source>
          <target state="translated">쉬운 오류 전파를위한 도우미 기능. 오류가 발생하면 ErrorExp를 반환합니다. 그렇지 않으면 NULL을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="3576c823fa70ffbb40f146b4e65274f6dc08a676" translate="yes" xml:space="preserve">
          <source>Helper function for the expansion of manifest constant.</source>
          <target state="translated">매니페스트 상수의 확장을위한 도우미 기능</target>
        </trans-unit>
        <trans-unit id="f45a0f048cca01c298f3e28147b97707c3bec7c9" translate="yes" xml:space="preserve">
          <source>Helper function that returns a &lt;code&gt;FormatSpec&lt;/code&gt; for a single specifier given in &lt;code&gt;fmt&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;fmt&lt;/code&gt; 에 제공된 단일 지정자에 대해 &lt;code&gt;FormatSpec&lt;/code&gt; 을 리턴하는 헬퍼 함수입니다 .</target>
        </trans-unit>
        <trans-unit id="10a93d4497e85393cb5499fb73d96c729ebc3ddb" translate="yes" xml:space="preserve">
          <source>Helper function that returns a complex number with the specified real and imaginary parts.</source>
          <target state="translated">지정된 실수 부와 허수 부를 가진 복소수를 반환하는 도우미 함수입니다.</target>
        </trans-unit>
        <trans-unit id="b43936919328317134bad177cd4f68d6f84246ac" translate="yes" xml:space="preserve">
          <source>Helper function to turn operator into template argument list</source>
          <target state="translated">연산자를 템플릿 인수 목록으로 바꾸는 도우미 기능</target>
        </trans-unit>
        <trans-unit id="934835a36e88b263f02948e4dbd8c5dd04401bc0" translate="yes" xml:space="preserve">
          <source>Helper functions</source>
          <target state="translated">도우미 기능</target>
        </trans-unit>
        <trans-unit id="3c9b3433e6f225e4ae00ef2041d44d91bfbf7113" translate="yes" xml:space="preserve">
          <source>Helpers</source>
          <target state="translated">Helpers</target>
        </trans-unit>
        <trans-unit id="e9e62a53ff4cde1bc51ffbf3814a1010c7743286" translate="yes" xml:space="preserve">
          <source>Here &lt;code&gt;o&lt;/code&gt; supplies the</source>
          <target state="translated">여기에 &lt;code&gt;o&lt;/code&gt; 공급한다</target>
        </trans-unit>
        <trans-unit id="8cf320d31b7dd0774140c8f2ed90c8c274ff772d" translate="yes" xml:space="preserve">
          <source>Here block names are unambiguous as no scripts are searched and thus to search use simply &lt;code&gt;unicode.block.BlockName&lt;/code&gt; notation.</source>
          <target state="translated">여기서는 스크립트를 검색하지 않으므로 블록 이름이 명확하므로 &lt;code&gt;unicode.block.BlockName&lt;/code&gt; 표기법을 사용하여 검색하십시오 .</target>
        </trans-unit>
        <trans-unit id="6dcb204b7bfbc922a65c81d29d2d9fe0db1b0d9c" translate="yes" xml:space="preserve">
          <source>Here is an example function in both forms:</source>
          <target state="translated">다음은 두 가지 형태의 함수 예제입니다.</target>
        </trans-unit>
        <trans-unit id="d0b4b9e647805e60f485e34136037cafd1a89034" translate="yes" xml:space="preserve">
          <source>Here the method &lt;code&gt;add&lt;/code&gt; returns the base type, which doesn't implement the &lt;code&gt;remove&lt;/code&gt; method. The &lt;code&gt;template this&lt;/code&gt; parameter can be used for this purpose:</source>
          <target state="translated">여기서 &lt;code&gt;add&lt;/code&gt; 메소드 는 &lt;code&gt;remove&lt;/code&gt; 메소드를 구현하지 않는 기본 유형을 리턴합니다 . &lt;code&gt;template this&lt;/code&gt; 매개 변수는이 목적을 위해 사용할 수 있습니다 :</target>
        </trans-unit>
        <trans-unit id="c4a0b731de4fd47e1ec934359b73224f54545eef" translate="yes" xml:space="preserve">
          <source>Here the method &lt;code&gt;initWith&lt;/code&gt; is overloaded with two versions, one accepting &lt;code&gt;in char*&lt;/code&gt;, the other one &lt;code&gt;NSString&lt;/code&gt;. These two methods are mapped to two different Objective-C selectors, &lt;code&gt;initWithUTF8String:&lt;/code&gt; and &lt;code&gt;initWithString:&lt;/code&gt;.</source>
          <target state="translated">여기에서 &lt;code&gt;initWith&lt;/code&gt; 메소드 는 두 가지 버전으로 오버로드 되는데 , 하나 &lt;code&gt;in char*&lt;/code&gt; 에서, 다른 하나는 &lt;code&gt;NSString&lt;/code&gt; 입니다. 이 두 메소드는 두 개의 다른 Objective-C 선택기 ( &lt;code&gt;initWithUTF8String:&lt;/code&gt; 및 &lt;code&gt;initWithString:&lt;/code&gt; :)에 맵핑됩니다 .</target>
        </trans-unit>
        <trans-unit id="7394eed5672426c0a80d302b8f8393ed7eec5e66" translate="yes" xml:space="preserve">
          <source>Here's an example of C code providing a callback to D code:</source>
          <target state="translated">다음은 D 코드에 콜백을 제공하는 C 코드의 예입니다.</target>
        </trans-unit>
        <trans-unit id="ca207d127693f0056dad58049c5cee1c802022ff" translate="yes" xml:space="preserve">
          <source>Here's an example of a</source>
          <target state="translated">여기에 예가 있습니다</target>
        </trans-unit>
        <trans-unit id="62b798df4ae2b665a95d9fcc9f504deddb178a54" translate="yes" xml:space="preserve">
          <source>Here, &lt;code&gt;S&lt;/code&gt; has a temporary workspace &lt;code&gt;buf[]&lt;/code&gt;. The normal postblit will pointlessly free and reallocate it. The custom &lt;code&gt;opAssign&lt;/code&gt; will reuse the existing storage.</source>
          <target state="translated">여기서 &lt;code&gt;S&lt;/code&gt; 에는 임시 작업 공간 &lt;code&gt;buf[]&lt;/code&gt; 있습니다. 정상적인 포스트 블릿은 무의미하게 해제되고 재 할당됩니다. 사용자 지정 &lt;code&gt;opAssign&lt;/code&gt; 은 기존 스토리지를 재사용합니다.</target>
        </trans-unit>
        <trans-unit id="8062e6745c830b66848176f824bd120bb6ff6bff" translate="yes" xml:space="preserve">
          <source>Here, an implementation may assume (without having knowledge of the body of &lt;code&gt;make&lt;/code&gt;) that all references in &lt;code&gt;make&lt;/code&gt;'s result refer to other &lt;code&gt;List&lt;/code&gt; objects created by &lt;code&gt;make&lt;/code&gt;, and that no other part of the program refers to any of these objects.</source>
          <target state="translated">여기에서, 구현은 (의 몸에 대한 지식없이 가정 할 수 &lt;code&gt;make&lt;/code&gt; 모두 참조하는) &lt;code&gt;make&lt;/code&gt; 결과의 다른 참조 &lt;code&gt;List&lt;/code&gt; 에 의해 만들어진 객체 &lt;code&gt;make&lt;/code&gt; , 프로그램의 다른 부분은 이러한 개체 중 하나를 의미 없다.</target>
        </trans-unit>
        <trans-unit id="aa7249d3729c33470954c40f7854c88ac6ea3626" translate="yes" xml:space="preserve">
          <source>Hex Strings</source>
          <target state="translated">16 진 현</target>
        </trans-unit>
        <trans-unit id="55d1c93cb26fa4369bf6dcef06802017d907bd51" translate="yes" xml:space="preserve">
          <source>Hex strings allow string literals to be created using hex data. The hex data need not form valid UTF characters.</source>
          <target state="translated">16 진 문자열을 사용하면 16 진 데이터를 사용하여 문자열 리터럴을 작성할 수 있습니다. 16 진 데이터는 유효한 UTF 문자를 형성 할 필요가 없습니다.</target>
        </trans-unit>
        <trans-unit id="d39bdde77ca95b7a4b0450ffc2d016efdeac30d3" translate="yes" xml:space="preserve">
          <source>Hex_Digit</source>
          <target state="translated">Hex_Digit</target>
        </trans-unit>
        <trans-unit id="c45ee0a2d08a303c51fd2da33a102a3979857332" translate="yes" xml:space="preserve">
          <source>Hexadecimal floats are preceded by a &lt;b&gt;0x&lt;/b&gt; or &lt;b&gt;0X&lt;/b&gt; and the exponent is a &lt;b&gt;p&lt;/b&gt; or &lt;b&gt;P&lt;/b&gt; followed by a decimal number serving as the exponent of 2.</source>
          <target state="translated">16 진 부동 소수점 앞에는 &lt;b&gt;0x&lt;/b&gt; 또는 &lt;b&gt;0X가&lt;/b&gt; 있고 지수는 &lt;b&gt;p&lt;/b&gt; 또는 &lt;b&gt;P에&lt;/b&gt; 이어 2의 지수로 사용되는 10 진수입니다.</target>
        </trans-unit>
        <trans-unit id="f16858a5f250d36219d82e048f143333094b2747" translate="yes" xml:space="preserve">
          <source>Hexadecimal integers are a sequence of hexadecimal digits preceded by a &amp;lsquo;0x&amp;rsquo; or &amp;lsquo;0X&amp;rsquo;.</source>
          <target state="translated">16 진 정수는 '0x'또는 '0X'가 앞에 오는 16 진 숫자의 순서입니다.</target>
        </trans-unit>
        <trans-unit id="11ddb91ab70b44df8f22cc56bf0f33cd3a59aeec" translate="yes" xml:space="preserve">
          <source>Hexadecimal notation</source>
          <target state="translated">16 진법</target>
        </trans-unit>
        <trans-unit id="66364879eee2501137250fec2b98de691bb34dff" translate="yes" xml:space="preserve">
          <source>Hexadecimal notation with explicit suffixes</source>
          <target state="translated">명시적인 접미사가있는 16 진 표기법</target>
        </trans-unit>
        <trans-unit id="4606d5486909f59f9ecd950c1b17f287693253b2" translate="yes" xml:space="preserve">
          <source>Hexadecimal, lower case</source>
          <target state="translated">16 진, 소문자</target>
        </trans-unit>
        <trans-unit id="bf0117ce1416e40b23cca8ffd7b3aa016afb333f" translate="yes" xml:space="preserve">
          <source>Hexadecimal, upper case</source>
          <target state="translated">16 진 대문자</target>
        </trans-unit>
        <trans-unit id="30b3eea9819f7439bb0562c0c53437f8d9a50617" translate="yes" xml:space="preserve">
          <source>Hidden parameters include the &lt;code&gt;this&lt;/code&gt; parameter of a class, struct or nested function and the selector parameter for Objective-C methods.</source>
          <target state="translated">숨겨진 매개 변수에는 클래스, 구조체 또는 중첩 함수 의 &lt;code&gt;this&lt;/code&gt; 매개 변수와 Objective-C 메서드의 선택기 매개 변수가 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="53541869fd4c351759ad332d3244e2355b446808" translate="yes" xml:space="preserve">
          <source>High Private Use Surrogates</source>
          <target state="translated">높은 개인 사용 대리</target>
        </trans-unit>
        <trans-unit id="a2c5b830397db70f03f56d26786a97a92aad7755" translate="yes" xml:space="preserve">
          <source>High Surrogates</source>
          <target state="translated">대리모</target>
        </trans-unit>
        <trans-unit id="f8ac1be04c27612db7a3ef64fd5edd48a9cbefb5" translate="yes" xml:space="preserve">
          <source>High level</source>
          <target state="translated">높은 레벨</target>
        </trans-unit>
        <trans-unit id="0720fad238d3af6e0d988b6041fc7aff02b725de" translate="yes" xml:space="preserve">
          <source>High level bit level manipulation, bit arrays, bit fields.</source>
          <target state="translated">높은 수준의 비트 수준 조작, 비트 배열, 비트 필드.</target>
        </trans-unit>
        <trans-unit id="a05a4fbe2b607cf88b24dc00ca5c949b2b6f1756" translate="yes" xml:space="preserve">
          <source>High level primitives for SMP parallelism.</source>
          <target state="translated">SMP 병렬 처리를위한 고급 프리미티브.</target>
        </trans-unit>
        <trans-unit id="2ced0d4c7e1faee3d9f900306c2e846112d18012" translate="yes" xml:space="preserve">
          <source>High-level interface for allocators. Implements bundled allocation/creation and destruction/deallocation of data including &lt;code&gt;struct&lt;/code&gt;s and &lt;code&gt;class&lt;/code&gt;es, and also array primitives related to allocation. This module is the entry point for both making use of allocators and for their documentation.</source>
          <target state="translated">할당자를위한 고급 인터페이스. &lt;code&gt;struct&lt;/code&gt; 및 &lt;code&gt;class&lt;/code&gt; es를 포함한 데이터의 번들 할당 / 생성 및 파기 / 할당을 구현 하고 할당과 관련된 배열 프리미티브도 구현합니다. 이 모듈은 할당자를 사용하고 문서화하기위한 시작점입니다.</target>
        </trans-unit>
        <trans-unit id="e4a71da2c94aa8ebb4eabe525bf9bfaf87c49456" translate="yes" xml:space="preserve">
          <source>Highest generated value (&lt;code&gt;modulus - 1&lt;/code&gt;).</source>
          <target state="translated">가장 높은 생성 값 ( &lt;code&gt;modulus - 1&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="9a7ebfdbeeab34f9a74c5ea30182aae05ebb58ca" translate="yes" xml:space="preserve">
          <source>Highest possible &lt;code&gt;LogLevel&lt;/code&gt;.</source>
          <target state="translated">가능한 가장 높은 &lt;code&gt;LogLevel&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="464c7e7834d9d7bd5320fc6bf866ca1e41042986" translate="yes" xml:space="preserve">
          <source>Highlighting</source>
          <target state="translated">Highlighting</target>
        </trans-unit>
        <trans-unit id="b95101e7e46150f6462631854125e5fff96c059a" translate="yes" xml:space="preserve">
          <source>Highlighting of D code is performed by the following macros:</source>
          <target state="translated">D 코드 강조 표시는 다음 매크로에 의해 수행됩니다.</target>
        </trans-unit>
        <trans-unit id="683f475e2ebb85d31bca86c12acb027ecf0e8eb2" translate="yes" xml:space="preserve">
          <source>Highlighting of D keywords</source>
          <target state="translated">D 키워드 강조</target>
        </trans-unit>
        <trans-unit id="c4ca1644d89763135e446cfbeade41acbff8ee52" translate="yes" xml:space="preserve">
          <source>Highlighting of D keywords.</source>
          <target state="translated">D 키워드 강조</target>
        </trans-unit>
        <trans-unit id="935e04346b38d14f49040acb6c379fad11a7bf81" translate="yes" xml:space="preserve">
          <source>Highlighting of a function parameter section.</source>
          <target state="translated">기능 파라미터 섹션의 하이라이트.</target>
        </trans-unit>
        <trans-unit id="826389bac96eaeab4717271d63b43c94f3297c72" translate="yes" xml:space="preserve">
          <source>Highlighting of a name=value function parameter.</source>
          <target state="translated">이름 = 값 함수 매개 변수 강조 표시.</target>
        </trans-unit>
        <trans-unit id="51eda7a8eeff739d414894834699b4db25dca6d2" translate="yes" xml:space="preserve">
          <source>Highlighting of a template constraint.</source>
          <target state="translated">템플릿 제약 조건 강조</target>
        </trans-unit>
        <trans-unit id="cc13dc42b045774509fcd534fa3f901ea5ee4636" translate="yes" xml:space="preserve">
          <source>Highlighting of a template's individual parameters.</source>
          <target state="translated">템플릿의 개별 매개 변수를 강조 표시합니다.</target>
        </trans-unit>
        <trans-unit id="61100e35b4349aa073e0605d9e5a97e7d22147a5" translate="yes" xml:space="preserve">
          <source>Highlighting of a template's parameter list.</source>
          <target state="translated">템플릿 매개 변수 목록 강조</target>
        </trans-unit>
        <trans-unit id="c13fcc9292d599790bf9edbd77af674db96191fd" translate="yes" xml:space="preserve">
          <source>Highlighting of all the members of a class.</source>
          <target state="translated">수업의 모든 구성원을 강조합니다.</target>
        </trans-unit>
        <trans-unit id="e4ae17c8f2cb1ec34256f6f0903677d6b391295e" translate="yes" xml:space="preserve">
          <source>Highlighting of all the members of a module.</source>
          <target state="translated">모듈의 모든 멤버를 강조 표시합니다.</target>
        </trans-unit>
        <trans-unit id="c09feb09e99ce22a8559d127647547ccdb5c7c15" translate="yes" xml:space="preserve">
          <source>Highlighting of all the members of a struct.</source>
          <target state="translated">구조체의 모든 멤버를 강조 표시합니다.</target>
        </trans-unit>
        <trans-unit id="cbef76e4daad8898695a45761c2de54a52f8635b" translate="yes" xml:space="preserve">
          <source>Highlighting of all the members of a template.</source>
          <target state="translated">템플릿의 모든 멤버를 강조 표시합니다.</target>
        </trans-unit>
        <trans-unit id="0faf83c3ae32ade36ccd67312a59a723e525d473" translate="yes" xml:space="preserve">
          <source>Highlighting of all the members of an enum.</source>
          <target state="translated">열거 형의 모든 멤버를 강조 표시합니다.</target>
        </trans-unit>
        <trans-unit id="e8d93f96992576e6ba1194d00e53b1efd8bd3019" translate="yes" xml:space="preserve">
          <source>Highlighting of all the sections.</source>
          <target state="translated">모든 섹션을 강조 표시합니다.</target>
        </trans-unit>
        <trans-unit id="4778b67265bf5d04ac6df97ab091affb27b022ea" translate="yes" xml:space="preserve">
          <source>Highlighting of auto-detected keywords</source>
          <target state="translated">자동 감지 된 키워드 강조</target>
        </trans-unit>
        <trans-unit id="dd81b3fecd0f20ab2c7c2cd23019f77363841968" translate="yes" xml:space="preserve">
          <source>Highlighting of auto-detected parameters</source>
          <target state="translated">자동 감지 매개 변수 강조</target>
        </trans-unit>
        <trans-unit id="2d5dbc630aa84bc9b06ad40e57222a60ed6a293a" translate="yes" xml:space="preserve">
          <source>Highlighting of auto-detected symbol</source>
          <target state="translated">자동 감지 기호 강조</target>
        </trans-unit>
        <trans-unit id="5a59602c4760ed030bee0db0f8f2fc1e157c8fe6" translate="yes" xml:space="preserve">
          <source>Highlighting of auto-detected symbol that starts with underscore</source>
          <target state="translated">밑줄로 시작하는 자동 감지 기호 강조</target>
        </trans-unit>
        <trans-unit id="03eeb845c1ab1c169a400e57021a9975be5fcd70" translate="yes" xml:space="preserve">
          <source>Highlighting of comments</source>
          <target state="translated">주석 강조</target>
        </trans-unit>
        <trans-unit id="b342620229626113c8bd37f08c3e00019479575f" translate="yes" xml:space="preserve">
          <source>Highlighting of current declaration name</source>
          <target state="translated">현재 선언 이름 강조</target>
        </trans-unit>
        <trans-unit id="176f12498ba670eeda224994c2d82350441886fe" translate="yes" xml:space="preserve">
          <source>Highlighting of current function declaration parameters</source>
          <target state="translated">현재 함수 선언 파라미터의 하이라이트</target>
        </trans-unit>
        <trans-unit id="6b99cfaf4826b1d374574b650af15bdd57440bdb" translate="yes" xml:space="preserve">
          <source>Highlighting of declaration name to which a particular section is referring.</source>
          <target state="translated">특정 섹션이 참조하는 선언 이름 강조</target>
        </trans-unit>
        <trans-unit id="0ccd215d873103285e575951e68bee16377784a3" translate="yes" xml:space="preserve">
          <source>Highlighting of ditto declarations.</source>
          <target state="translated">ditto 선언 강조</target>
        </trans-unit>
        <trans-unit id="e60176b3b0d8bba6525dbfb5d2184816b026c16d" translate="yes" xml:space="preserve">
          <source>Highlighting of function parameters.</source>
          <target state="translated">기능 매개 변수 강조 표시.</target>
        </trans-unit>
        <trans-unit id="738f3d1a73adb20a6fc751e428562fd5770c4fbf" translate="yes" xml:space="preserve">
          <source>Highlighting of non-special sections is done.</source>
          <target state="translated">비 특수 섹션의 강조 표시가 완료되었습니다.</target>
        </trans-unit>
        <trans-unit id="4e9319188986e049a769be81e81ed23eb17972c2" translate="yes" xml:space="preserve">
          <source>Highlighting of string literals</source>
          <target state="translated">문자열 리터럴 강조</target>
        </trans-unit>
        <trans-unit id="9dc393c818c0c8fcccd04642b35f2031235608ef" translate="yes" xml:space="preserve">
          <source>Highlighting of the authors section.</source>
          <target state="translated">저자 섹션의 하이라이트.</target>
        </trans-unit>
        <trans-unit id="c04db9dc0d813c1ccd8c3f2345ab8b620b85f230" translate="yes" xml:space="preserve">
          <source>Highlighting of the base type of a class.</source>
          <target state="translated">클래스의 기본 유형을 강조합니다.</target>
        </trans-unit>
        <trans-unit id="a07587fe4175acb9782fe36fd142c60cdfdd6da4" translate="yes" xml:space="preserve">
          <source>Highlighting of the bugs section.</source>
          <target state="translated">버그 섹션 강조</target>
        </trans-unit>
        <trans-unit id="7882769ed43990ada8c8b23f2c29f9e27cd0f71b" translate="yes" xml:space="preserve">
          <source>Highlighting of the contents of a non-standard section.</source>
          <target state="translated">비표준 섹션의 내용을 강조 표시합니다.</target>
        </trans-unit>
        <trans-unit id="4f9d3c220f1308abbd19a33e68d9159fe1a7bcac" translate="yes" xml:space="preserve">
          <source>Highlighting of the copyright section.</source>
          <target state="translated">저작권 섹션 강조</target>
        </trans-unit>
        <trans-unit id="7d6e48fe7e09c72518d7c42b2053ac6afd252e38" translate="yes" xml:space="preserve">
          <source>Highlighting of the date section.</source>
          <target state="translated">날짜 섹션을 강조 표시합니다.</target>
        </trans-unit>
        <trans-unit id="895c3d9b137fe00aae27a823464b74cfac8c6e8b" translate="yes" xml:space="preserve">
          <source>Highlighting of the declaration.</source>
          <target state="translated">선언의 강조.</target>
        </trans-unit>
        <trans-unit id="63dc31f05686ee2516c9b1d4403bc34707de916c" translate="yes" xml:space="preserve">
          <source>Highlighting of the deprecated section.</source>
          <target state="translated">더 이상 사용되지 않는 섹션 강조 표시</target>
        </trans-unit>
        <trans-unit id="c8decd9303e1480e7050896c2d68e41aba55a19d" translate="yes" xml:space="preserve">
          <source>Highlighting of the description of a declaration.</source>
          <target state="translated">선언의 설명을 강조합니다.</target>
        </trans-unit>
        <trans-unit id="c34c68b3feaf8a8af047b5dc0b27284ee8a4a976" translate="yes" xml:space="preserve">
          <source>Highlighting of the description section.</source>
          <target state="translated">설명 섹션 강조 표시</target>
        </trans-unit>
        <trans-unit id="66395af507be6d2f2c64374c4dcc34d87ba08e37" translate="yes" xml:space="preserve">
          <source>Highlighting of the examples section.</source>
          <target state="translated">예제 섹션의 하이라이트.</target>
        </trans-unit>
        <trans-unit id="6c9891d5d62ba75e6f4bc3861099aa91d8757c3e" translate="yes" xml:space="preserve">
          <source>Highlighting of the history section.</source>
          <target state="translated">역사 섹션의 하이라이트.</target>
        </trans-unit>
        <trans-unit id="b7f85e62f0cd3405e5bd64486a1604e80fdbaccf" translate="yes" xml:space="preserve">
          <source>Highlighting of the license section.</source>
          <target state="translated">라이센스 섹션 강조</target>
        </trans-unit>
        <trans-unit id="a1bf0eef04a7e415262c4a93c4981e89e888edcc" translate="yes" xml:space="preserve">
          <source>Highlighting of the parameter name.</source>
          <target state="translated">매개 변수 이름 강조 표시.</target>
        </trans-unit>
        <trans-unit id="f88d01cfff7b61b2efa32b18d2de859fdd295ab7" translate="yes" xml:space="preserve">
          <source>Highlighting of the parameter value.</source>
          <target state="translated">매개 변수 값 강조 표시.</target>
        </trans-unit>
        <trans-unit id="e1964e06337cb784d3309fe34806373d2ea7eb8f" translate="yes" xml:space="preserve">
          <source>Highlighting of the returns section.</source>
          <target state="translated">반품 섹션 강조</target>
        </trans-unit>
        <trans-unit id="833453d17a268f3c235ee74c7f3da2609550d437" translate="yes" xml:space="preserve">
          <source>Highlighting of the section name of a non-standard section.</source>
          <target state="translated">비표준 섹션의 섹션 이름을 강조 표시합니다.</target>
        </trans-unit>
        <trans-unit id="c7903d232b908137bafe89e336276f896f569fc5" translate="yes" xml:space="preserve">
          <source>Highlighting of the see-also section.</source>
          <target state="translated">참조 섹션 강조 표시.</target>
        </trans-unit>
        <trans-unit id="df390d31d75e9b616a073ce0adb1eeb2634d7fd5" translate="yes" xml:space="preserve">
          <source>Highlighting of the standards section.</source>
          <target state="translated">표준 섹션 강조</target>
        </trans-unit>
        <trans-unit id="f0d2af38c35f5e37acd97274204555972b2988bd" translate="yes" xml:space="preserve">
          <source>Highlighting of the summary section.</source>
          <target state="translated">요약 섹션 강조</target>
        </trans-unit>
        <trans-unit id="21e5f168213fe615e9ee4675e90cca4182bf4f11" translate="yes" xml:space="preserve">
          <source>Highlighting of the throws section.</source>
          <target state="translated">던지기 섹션의 하이라이트.</target>
        </trans-unit>
        <trans-unit id="0dff0c156a9e500788193fc7d13465ffae833297" translate="yes" xml:space="preserve">
          <source>Highlighting of the type an enum is based upon</source>
          <target state="translated">열거 형이 기반한 유형의 강조</target>
        </trans-unit>
        <trans-unit id="6b50d26c177d3621167352e70fcbe2f923cd28c3" translate="yes" xml:space="preserve">
          <source>Highlighting of the version section.</source>
          <target state="translated">버전 섹션 강조</target>
        </trans-unit>
        <trans-unit id="ba1d0a643c81d860412a884b89435cac1cf023d7" translate="yes" xml:space="preserve">
          <source>Hiragana</source>
          <target state="translated">Hiragana</target>
        </trans-unit>
        <trans-unit id="835fe32e11d06c07988640ea18d5a882081aeaae" translate="yes" xml:space="preserve">
          <source>History:</source>
          <target state="translated">History:</target>
        </trans-unit>
        <trans-unit id="b44fed8b2ad60db45d1dfeb77fbed8d582ca1505" translate="yes" xml:space="preserve">
          <source>Hoist-load + hoist-store barrier. Corresponds to &lt;a href=&quot;https://llvm.org/docs/Atomics.html#acquire&quot;&gt;LLVM AtomicOrdering.Acquire&lt;/a&gt; and C++11/C11 &lt;code&gt;memory_order_acquire&lt;/code&gt;.</source>
          <target state="translated">호이스트 하중 + 호이스트 매장 장벽. 에 해당하는 &lt;a href=&quot;https://llvm.org/docs/Atomics.html#acquire&quot;&gt;LLVM AtomicOrdering.Acquire&lt;/a&gt; 및 C ++ 11 / C11의 &lt;code&gt;memory_order_acquire&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8e61310c65ecb57873a154d2408b9cc4403ad4a2" translate="yes" xml:space="preserve">
          <source>Holds information about a socket address retrieved by &lt;code&gt;getAddressInfo&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;getAddressInfo&lt;/code&gt; 로 검색된 소켓 주소에 대한 정보를 보유합니다 .</target>
        </trans-unit>
        <trans-unit id="c10ba96a990de4f937f02e9f283e74796b47e3f8" translate="yes" xml:space="preserve">
          <source>Home of the TZ Database files</source>
          <target state="translated">TZ 데이터베이스 파일의 홈</target>
        </trans-unit>
        <trans-unit id="b3e0a103daa9ae3f375b2654f0a482c7c0d36297" translate="yes" xml:space="preserve">
          <source>Hook</source>
          <target state="translated">Hook</target>
        </trans-unit>
        <trans-unit id="df83ba56b9bf84a7f6828386bfb0ec0b4ea31298" translate="yes" xml:space="preserve">
          <source>Hook &lt;strong id=&quot;hook&quot;&gt;hook&lt;/strong&gt;;</source>
          <target state="translated">훅 &lt;strong id=&quot;hook&quot;&gt;훅&lt;/strong&gt; ;</target>
        </trans-unit>
        <trans-unit id="c491dcee1ba5406ded29938b72d3efa58c8898bc" translate="yes" xml:space="preserve">
          <source>Hook for &lt;code&gt;&amp;lt;&lt;/code&gt;, &lt;code&gt;&amp;lt;=&lt;/code&gt;, &lt;code&gt;&amp;gt;&lt;/code&gt;, and &lt;code&gt;&amp;gt;=&lt;/code&gt; that ensures comparison against integral values has the behavior expected by the usual arithmetic rules. The built-in semantics yield surprising behavior when comparing signed values against unsigned values, for example &lt;code&gt;0u &amp;lt; -1&lt;/code&gt;. The call &lt;code&gt;hookOpCmp(x, y)&lt;/code&gt; returns &lt;code&gt;-1&lt;/code&gt; if and only if &lt;code&gt;x&lt;/code&gt; is smaller than &lt;code&gt;y&lt;/code&gt; in abstract arithmetic sense.</source>
          <target state="translated">적분 값과의 비교를 보장 하는 &lt;code&gt;&amp;lt;&lt;/code&gt; , &lt;code&gt;&amp;lt;=&lt;/code&gt; , &lt;code&gt;&amp;gt;&lt;/code&gt; 및 &lt;code&gt;&amp;gt;=&lt;/code&gt; 에 대한 후크 는 일반적인 산술 규칙에서 예상되는 동작을 갖습니다. 내장 의미론은 부호있는 값과 부호없는 값 (예 : &lt;code&gt;0u &amp;lt; -1&lt;/code&gt; 비교할 때 놀라운 동작을 생성 합니다. 호출 &lt;code&gt;hookOpCmp(x, y)&lt;/code&gt; 는 &lt;code&gt;x&lt;/code&gt; 가 추상 산술적 의미에서 &lt;code&gt;y&lt;/code&gt; 보다 작은 경우에만 &lt;code&gt;-1&lt;/code&gt; 을 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="9cf42c2609ccf8480c4c29b09d1eeb015d535402" translate="yes" xml:space="preserve">
          <source>Hook for &lt;code&gt;==&lt;/code&gt; and &lt;code&gt;!=&lt;/code&gt; that ensures comparison against integral values has the behavior expected by the usual arithmetic rules. The built-in semantics yield surprising behavior when comparing signed values against unsigned values for equality, for example &lt;code&gt;uint.max == -1&lt;/code&gt; or &lt;code&gt;-1_294_967_296 == 3_000_000_000u&lt;/code&gt;. The call &lt;code&gt;hookOpEquals(x, y)&lt;/code&gt; returns &lt;code&gt;true&lt;/code&gt; if and only if &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; represent the same arithmetic number.</source>
          <target state="translated">적분 값과의 비교를 보장하는 &lt;code&gt;==&lt;/code&gt; 및 &lt;code&gt;!=&lt;/code&gt; 용 후크 에는 일반적인 산술 규칙에서 예상되는 동작이 있습니다. 내장 된 시맨틱은 부호있는 값과 부호없는 값을 &lt;code&gt;uint.max == -1&lt;/code&gt; 예 : uint.max == -1 또는 &lt;code&gt;-1_294_967_296 == 3_000_000_000u&lt;/code&gt; 비교할 때 놀라운 동작을 생성 합니다. &lt;code&gt;hookOpEquals(x, y)&lt;/code&gt; 호출 은 &lt;code&gt;x&lt;/code&gt; 와 &lt;code&gt;y&lt;/code&gt; 가 동일한 산술 숫자를 나타내는 경우에만 &lt;code&gt;true&lt;/code&gt; 를 반환 합니다 .</target>
        </trans-unit>
        <trans-unit id="041c61fdd24218cf59730fd0cdbaa1de754b6893" translate="yes" xml:space="preserve">
          <source>Hook that implements</source>
          <target state="translated">구현하는 후크</target>
        </trans-unit>
        <trans-unit id="b449d04fd061c7af394902d015ecf01abcf02e96" translate="yes" xml:space="preserve">
          <source>Hook that prints to &lt;code&gt;stderr&lt;/code&gt; a trace of all integral errors, without affecting default behavior.</source>
          <target state="translated">기본 동작에 영향을주지 않으면 서 모든 필수 오류의 흔적 을 &lt;code&gt;stderr&lt;/code&gt; 에 인쇄하는 후크 .</target>
        </trans-unit>
        <trans-unit id="efbf28167139074d8823a898190b189c85ea78aa" translate="yes" xml:space="preserve">
          <source>Hook that provides arithmetically correct comparisons for equality and ordering. Comparing an object of type &lt;code&gt;Checked!(X, ProperCompare)&lt;/code&gt; against another integral (for equality or ordering) ensures that no surprising conversions from signed to unsigned integral occur before the comparison. Using &lt;code&gt;Checked!(X, ProperCompare)&lt;/code&gt; on either side of a comparison for equality against a floating-point number makes sure the integral can be properly converted to the floating point type, thus making sure equality is transitive.</source>
          <target state="translated">평등과 순서에 대한 산술적으로 올바른 비교를 제공하는 후크. &lt;code&gt;Checked!(X, ProperCompare)&lt;/code&gt; 유형의 객체를 다른 적분 (동일 또는 순서)과 비교하면 비교 전에 부호있는 적분에서 부호없는 적분으로의 놀라운 변환이 발생하지 않습니다. 사용 &lt;code&gt;Checked!(X, ProperCompare)&lt;/code&gt; 부동 소수점 숫자 같은지 비교의 양쪽에있는 것은 따라서 반드시 평등 이행되게 부동 소수점 입력해야합니다 적분이 제대로 변환 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d806e6661a85f88dc9eaa221319b2117db0f755d" translate="yes" xml:space="preserve">
          <source>Hook that reserves a special value as a &quot;Not a Number&quot; representative. For signed integrals, the reserved value is &lt;code&gt;T.min&lt;/code&gt;. For signed integrals, the reserved value is &lt;code&gt;T.max&lt;/code&gt;.</source>
          <target state="translated">&quot;숫자가 아님&quot;담당자로서 특별한 가치를 보유하는 후크. 부호있는 적분의 경우 예약 된 값은 &lt;code&gt;T.min&lt;/code&gt; 입니다. 부호있는 적분의 경우 예약 된 값은 &lt;code&gt;T.max&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="33488d4b3cbb5ba16b0673469e60db7094fb670e" translate="yes" xml:space="preserve">
          <source>Horizontal Rules</source>
          <target state="translated">수평 규칙</target>
        </trans-unit>
        <trans-unit id="7212f381e90838fabdee36fb0501fbba0ed9cd58" translate="yes" xml:space="preserve">
          <source>Horizontal tab</source>
          <target state="translated">가로 탭</target>
        </trans-unit>
        <trans-unit id="3ac6fafe4ab0f338471b45cb71f20d044e5f5cc2" translate="yes" xml:space="preserve">
          <source>Horizontal tab (U+0009).</source>
          <target state="translated">가로 탭 (U + 0009).</target>
        </trans-unit>
        <trans-unit id="bbb1b4f452c31b5eb2b5c0983d50e71cb342831f" translate="yes" xml:space="preserve">
          <source>Host compiler vendor string and language version.</source>
          <target state="translated">호스트 컴파일러 공급 업체 문자열 및 언어 버전.</target>
        </trans-unit>
        <trans-unit id="e118cd39d323f526da5b0f63e4f3c3b86e96af36" translate="yes" xml:space="preserve">
          <source>Hour of the day [0 - 24).</source>
          <target state="translated">하루 중 시간 [0-24).</target>
        </trans-unit>
        <trans-unit id="47f45a8e9beb5422f5775e424c56239ab38cf0a6" translate="yes" xml:space="preserve">
          <source>Hours past midnight.</source>
          <target state="translated">자정이 지난 시간.</target>
        </trans-unit>
        <trans-unit id="aea1f84448c4cd135127feb893d3e5b86649ead7" translate="yes" xml:space="preserve">
          <source>How Garbage Collection Works</source>
          <target state="translated">가비지 콜렉션 작동 방식</target>
        </trans-unit>
        <trans-unit id="5e1ecfe3dd4c1b701a8f4295c2bd308de6db519e" translate="yes" xml:space="preserve">
          <source>How a socket is shutdown:</source>
          <target state="translated">소켓이 종료되는 방법 :</target>
        </trans-unit>
        <trans-unit id="14072cd783ee679dcd4faa9d6011722e64957f7d" translate="yes" xml:space="preserve">
          <source>How does this meet our assumptions about errors?</source>
          <target state="translated">이것이 오류에 대한 우리의 가정을 어떻게 충족 시키는가?</target>
        </trans-unit>
        <trans-unit id="2cef028c4c427db32ab248fb0fa09f711b8938d4" translate="yes" xml:space="preserve">
          <source>How does this meet our criteria?</source>
          <target state="translated">이것이 우리의 기준을 어떻게 충족 시키는가?</target>
        </trans-unit>
        <trans-unit id="46c019e7726b602bf175d16d3e47d3c9855717af" translate="yes" xml:space="preserve">
          <source>How much &lt;code&gt;r&lt;/code&gt; was actually advanced, which may be less than &lt;code&gt;n&lt;/code&gt; if &lt;code&gt;r&lt;/code&gt; did not have at least &lt;code&gt;n&lt;/code&gt; elements.</source>
          <target state="translated">실제로 &lt;code&gt;r&lt;/code&gt; 이 얼마나 많이 진행 되었는지, &lt;code&gt;r&lt;/code&gt; 에 &lt;code&gt;n&lt;/code&gt; 개 이상의 요소 가없는 경우 &lt;code&gt;n&lt;/code&gt; 보다 작을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="39a1caec9f5c9eff0c38eb6253af004f14eeaf48" translate="yes" xml:space="preserve">
          <source>How the deprecation messages are presented to the user.</source>
          <target state="translated">사용 중단 메시지가 사용자에게 표시되는 방법</target>
        </trans-unit>
        <trans-unit id="45ad0b30a0ba21c8300555e31b930fb7fa5c8e56" translate="yes" xml:space="preserve">
          <source>How to check an entire string</source>
          <target state="translated">전체 문자열을 확인하는 방법</target>
        </trans-unit>
        <trans-unit id="3944bdd486c5b281b0d76b6fea24f7aa42d88928" translate="yes" xml:space="preserve">
          <source>However for class types, identity assignment is not allowed. All class types have reference semantics, so identity assignment by default rebinds the left-hand-side to the argument at the right, and this is not overridable.</source>
          <target state="translated">그러나 클래스 유형의 경우 ID 할당이 허용되지 않습니다. 모든 클래스 유형에는 참조 시맨틱이 있으므로 기본적으로 ID 지정은 왼쪽을 오른쪽의 인수에 리 바인드하며 이는 무시할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="d81485ead3a03b09d4ef041206a388f9ba3d1726" translate="yes" xml:space="preserve">
          <source>However, &lt;code&gt;Rebindable!(Widget)&lt;/code&gt; does allow reassignment, while otherwise behaving exactly like a &lt;code&gt;const Widget&lt;/code&gt;.</source>
          <target state="translated">그러나 &lt;code&gt;Rebindable!(Widget)&lt;/code&gt; 은 재 할당을 허용하는 반면 &lt;code&gt;const Widget&lt;/code&gt; 과 똑같이 동작합니다 .</target>
        </trans-unit>
        <trans-unit id="39fcf81b03ae2153072256cf5c2ed783812c0162" translate="yes" xml:space="preserve">
          <source>However, if the AA element type is a struct which supports an implicit constructor call from the assigned value, implicit construction is used for setting the AA entry:</source>
          <target state="translated">그러나 AA 요소 유형이 지정된 값에서 내재 된 생성자 호출을 지원하는 구조체 인 경우 내재 구성은 AA 항목 설정에 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="be6cc5f771eb95dadab03bad5c4c89972ffb70a4" translate="yes" xml:space="preserve">
          <source>However, in &lt;code&gt;-betterC&lt;/code&gt;&lt;code&gt;assert&lt;/code&gt; expressions don't use Druntime's assert and are directed to &lt;code&gt;assert&lt;/code&gt; of the C runtime library instead.</source>
          <target state="translated">그러나 &lt;code&gt;-betterC&lt;/code&gt; 에서 &lt;code&gt;assert&lt;/code&gt; 표현식은 Druntime의 assert를 사용하지 않으며 대신 C 런타임 라이브러리의 &lt;code&gt;assert&lt;/code&gt; 로 지정됩니다.</target>
        </trans-unit>
        <trans-unit id="5a66b8122994e01e172373073ab6d4fa34b94942" translate="yes" xml:space="preserve">
          <source>However, it should be noted that the time zone information on Windows is frequently less accurate than that in the IANA time zone database, and if someone really wants accurate time zone information, they should use the IANA time zone database files with &lt;a href=&quot;#PosixTimeZone&quot;&gt;&lt;code&gt;PosixTimeZone&lt;/code&gt;&lt;/a&gt; on Windows rather than &lt;a href=&quot;#WindowsTimeZone&quot;&gt;&lt;code&gt;WindowsTimeZone&lt;/code&gt;&lt;/a&gt;, whereas &lt;a href=&quot;#WindowsTimeZone&quot;&gt;&lt;code&gt;WindowsTimeZone&lt;/code&gt;&lt;/a&gt; makes more sense when trying to match what Windows will think the time is in a specific time zone.</source>
          <target state="translated">그러나 Windows의 표준 시간대 정보는 IANA 표준 시간대 데이터베이스의 표준 시간대 정보보다 정확하지 않은 경우가 많으며, 누군가가 정확한 표준 시간대 정보를 원할 경우 Windows의 &lt;a href=&quot;#PosixTimeZone&quot;&gt; &lt;code&gt;PosixTimeZone&lt;/code&gt; &lt;/a&gt; 과 함께 IANA 표준 시간대 데이터베이스 파일을 사용해야합니다 . 보다 &lt;a href=&quot;#WindowsTimeZone&quot;&gt; &lt;code&gt;WindowsTimeZone&lt;/code&gt; &lt;/a&gt; 반면, &lt;a href=&quot;#WindowsTimeZone&quot;&gt; &lt;code&gt;WindowsTimeZone&lt;/code&gt; 이&lt;/a&gt; 더 의미가 Windows가 시간이 특정 시간대에 생각됩니다 일치 할 때.</target>
        </trans-unit>
        <trans-unit id="6fe9389c4ddd121d6493079f489aee81befd5618" translate="yes" xml:space="preserve">
          <source>However, on Windows, it may be the unabbreviated name (e.g. Pacific Daylight Time). Regardless, it is not the same as name.</source>
          <target state="translated">그러나 Windows에서는 약식 이름 일 수 있습니다 (예 : 태평양 일광 절약 시간). 어쨌든 이름과 같지 않습니다.</target>
        </trans-unit>
        <trans-unit id="47c13d8e213a10f9001fd45644c1b3afeb68823d" translate="yes" xml:space="preserve">
          <source>However, on Windows, it may be the unabbreviated name (e.g. Pacific Standard Time). Regardless, it is not the same as name.</source>
          <target state="translated">그러나 Windows에서는 약식 이름 (예 : 태평양 표준시) 일 수 있습니다. 어쨌든 이름과 같지 않습니다.</target>
        </trans-unit>
        <trans-unit id="eff8dd0f2d633371467a00fc8759aea595ab2872" translate="yes" xml:space="preserve">
          <source>However, when doing overload resolution, the functions in the base class are not considered:</source>
          <target state="translated">그러나 과부하 해결을 수행 할 때 기본 클래스의 함수는 고려되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="599b7a863c6a59d1092f07e1710589a8785bdb8d" translate="yes" xml:space="preserve">
          <source>Human readable string representing the IPv4 address in dotted-decimal form.</source>
          <target state="translated">점으로 구분 된 십진수 형식으로 IPv4 주소를 나타내는 사람이 읽을 수있는 문자열입니다.</target>
        </trans-unit>
        <trans-unit id="aff39bc2ec043587101457aaa3ae19023826875e" translate="yes" xml:space="preserve">
          <source>Human readable string representing the IPv4 port.</source>
          <target state="translated">IPv4 포트를 나타내는 사람이 읽을 수있는 문자열.</target>
        </trans-unit>
        <trans-unit id="a79746cad8ecf9d33b60d8dd5347136a9d85ef98" translate="yes" xml:space="preserve">
          <source>Human readable string representing this address.</source>
          <target state="translated">이 주소를 나타내는 사람이 읽을 수있는 문자열입니다.</target>
        </trans-unit>
        <trans-unit id="4c4d996a690c3ac43662d610a18221ccc97faec3" translate="yes" xml:space="preserve">
          <source>Hyphen</source>
          <target state="translated">Hyphen</target>
        </trans-unit>
        <trans-unit id="ca73ab65568cd125c2d27a22bbd9e863c10b675d" translate="yes" xml:space="preserve">
          <source>I</source>
          <target state="translated">I</target>
        </trans-unit>
        <trans-unit id="47af55839c3e9c9ba933349c6295cd1ce082a6a3" translate="yes" xml:space="preserve">
          <source>I &lt;code&gt;im&lt;/code&gt;</source>
          <target state="translated">나는 &lt;code&gt;im&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="84ff080e0a1bf2c778d5efdc523acd4678a5928f" translate="yes" xml:space="preserve">
          <source>I &lt;code&gt;sizes&lt;/code&gt;</source>
          <target state="translated">나는 &lt;code&gt;sizes&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="d4ce4e386de11613809ef416e70170284dffb219" translate="yes" xml:space="preserve">
          <source>I &lt;code&gt;startingIndex&lt;/code&gt;</source>
          <target state="translated">색인 &lt;code&gt;startingIndex&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="3df1df26aa4ea931d9e988f62da215ed0c3e81a7" translate="yes" xml:space="preserve">
          <source>I came, I coded, I crashed.</source>
          <target state="translated">내가 와서 코딩하고 충돌했습니다.</target>
        </trans-unit>
        <trans-unit id="81cb37800b131d16bca390e388601790ff6f313b" translate="yes" xml:space="preserve">
          <source>I.e. is it a single return statement or some compound statement that unconditionally hits a return statement.</source>
          <target state="translated">즉, 단일 반환 문이거나 무조건 반환 문에 도달하는 복합 문입니다.</target>
        </trans-unit>
        <trans-unit id="d8212950b3ac05f1c5deaff0d3a32ce51c051e7f" translate="yes" xml:space="preserve">
          <source>I/O operation successful</source>
          <target state="translated">I / O 작업 성공</target>
        </trans-unit>
        <trans-unit id="a07107356f25616c07b6fd35ca4ce30f409251c5" translate="yes" xml:space="preserve">
          <source>IBM Advanced Interactive eXecutive OS</source>
          <target state="translated">IBM Advanced Interactive eXecutive OS</target>
        </trans-unit>
        <trans-unit id="7e73f4b459341f6552e0a60723ed4f4fb582c963" translate="yes" xml:space="preserve">
          <source>IDS_Binary_Operator</source>
          <target state="translated">IDS_Binary_Operator</target>
        </trans-unit>
        <trans-unit id="dfddbbc74d0d43db63cde2a6e1024f6ba8221fff" translate="yes" xml:space="preserve">
          <source>IDS_Trinary_Operator</source>
          <target state="translated">IDS_Trinary_Operator</target>
        </trans-unit>
        <trans-unit id="0a50f9983af5839dd0d0dc6f249331d57b64db6f" translate="yes" xml:space="preserve">
          <source>ID_Continue</source>
          <target state="translated">ID_Continue</target>
        </trans-unit>
        <trans-unit id="92936d6f1e8f3e471e6f43d46a9887af5d007bd8" translate="yes" xml:space="preserve">
          <source>ID_Start</source>
          <target state="translated">ID_Start</target>
        </trans-unit>
        <trans-unit id="3f4e414c32b3902ba3f69c8b82e07f90e3313525" translate="yes" xml:space="preserve">
          <source>IEEE 754 floating point arithmetic can set several flags based on what happened with a computation:</source>
          <target state="translated">IEEE 754 부동 소수점 산술은 계산 결과에 따라 몇 가지 플래그를 설정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ca31149be1b5f9a497eaee503fda4915c7e1c829" translate="yes" xml:space="preserve">
          <source>IEEE 754 floating point arithmetic includes the ability to set 4 different rounding modes. These are accessible via the functions in &lt;code&gt;core.stdc.fenv&lt;/code&gt;.</source>
          <target state="translated">IEEE 754 부동 소수점 산술에는 4 개의 다른 반올림 모드를 설정하는 기능이 포함되어 있습니다. 이들은 &lt;code&gt;core.stdc.fenv&lt;/code&gt; 의 기능을 통해 액세스 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="c9fbff470ecc71dad6d33f5eeaccc83f4e863050" translate="yes" xml:space="preserve">
          <source>IEEE exception status flags ('sticky bits')</source>
          <target state="translated">IEEE 예외 상태 플래그 ( '스티커 비트')</target>
        </trans-unit>
        <trans-unit id="a2584841fe85abc74e15db0f23c9cdba2dd8ab2a" translate="yes" xml:space="preserve">
          <source>IEEE hardware exceptions. By default, all exceptions are masked (disabled).</source>
          <target state="translated">IEEE 하드웨어 예외. 기본적으로 모든 예외는 마스킹 (비활성화)됩니다.</target>
        </trans-unit>
        <trans-unit id="b9e2d958b9ca41f87ae15ec8c35999c50ae4ff8c" translate="yes" xml:space="preserve">
          <source>IEEE rounding modes. The default mode is roundToNearest.</source>
          <target state="translated">IEEE 반올림 모드. 기본 모드는 roundToNearest입니다.</target>
        </trans-unit>
        <trans-unit id="7d81343ef8eab15b8d8f8c68c7c8bdb404ed88bb" translate="yes" xml:space="preserve">
          <source>ILS &lt;strong id=&quot;inlineStatusStmt&quot;&gt;inlineStatusStmt&lt;/strong&gt;;</source>
          <target state="translated">ILS &lt;strong id=&quot;inlineStatusStmt&quot;&gt;inlineStatusStmt&lt;/strong&gt; ;</target>
        </trans-unit>
        <trans-unit id="362fa36f30a060b9e1fcf247cb78ff4ce49924f2" translate="yes" xml:space="preserve">
          <source>IMP</source>
          <target state="translated">IMP</target>
        </trans-unit>
        <trans-unit id="bdc4004339f8557d5a75257afe0bb8aef0ebaaba" translate="yes" xml:space="preserve">
          <source>IP multicast hops</source>
          <target state="translated">IP 멀티 캐스트 홉</target>
        </trans-unit>
        <trans-unit id="20fe7e463770b20399ece7b586c1bbb5d3def572" translate="yes" xml:space="preserve">
          <source>IP multicast interface</source>
          <target state="translated">IP 멀티 캐스트 인터페이스</target>
        </trans-unit>
        <trans-unit id="7279e4b3160656f1f51a778df4e83b92cb83cf30" translate="yes" xml:space="preserve">
          <source>IP multicast loopback</source>
          <target state="translated">IP 멀티 캐스트 루프백</target>
        </trans-unit>
        <trans-unit id="9ebd1fbe7ba3cf5bdc775290d0d686e15bf4c0b2" translate="yes" xml:space="preserve">
          <source>IP unicast hop limit</source>
          <target state="translated">IP 유니 캐스트 홉 제한</target>
        </trans-unit>
        <trans-unit id="cc01b492cee0acdf48f0b298c26fa47256bd3faf" translate="yes" xml:space="preserve">
          <source>IPA Extensions</source>
          <target state="translated">IPA 확장</target>
        </trans-unit>
        <trans-unit id="80570baac1433d8da38eb560349f85ffa3c24938" translate="yes" xml:space="preserve">
          <source>IPv6 address ends with a single colon</source>
          <target state="translated">IPv6 주소는 단일 콜론으로 끝납니다</target>
        </trans-unit>
        <trans-unit id="f971f61e6734e2eb397d8944032e3b5547c71b4c" translate="yes" xml:space="preserve">
          <source>IPv6 address starts with a single colon</source>
          <target state="translated">IPv6 주소는 단일 콜론으로 시작</target>
        </trans-unit>
        <trans-unit id="ffeae36229b4084ab3f5431d5a5e2894acff57f8" translate="yes" xml:space="preserve">
          <source>IPv6-enabled</source>
          <target state="translated">IPv6-enabled</target>
        </trans-unit>
        <trans-unit id="ae9887477b5a4dc86ce15b0c56db938ec92c9140" translate="yes" xml:space="preserve">
          <source>IRState* &lt;code&gt;irs&lt;/code&gt;</source>
          <target state="translated">IRState * &lt;code&gt;irs&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="445867d9c88cb9ec795d4d1edb4358f7f32ed23d" translate="yes" xml:space="preserve">
          <source>ISO 8601</source>
          <target state="translated">ISO 8601</target>
        </trans-unit>
        <trans-unit id="0f3e173e17d8fbdbf144076143d8cd16c3b60805" translate="yes" xml:space="preserve">
          <source>ISO Week Date</source>
          <target state="translated">ISO 주일</target>
        </trans-unit>
        <trans-unit id="6edb4ac9bcba71ad7ccb4ee02897a84fda819a4e" translate="yes" xml:space="preserve">
          <source>ISO/IEC 9899:1999 (E)</source>
          <target state="translated">ISO / IEC 9899 : 1999 (E)</target>
        </trans-unit>
        <trans-unit id="8e40d146e834aa0554ad9d258a39d303ac74b95c" translate="yes" xml:space="preserve">
          <source>ISO/IEC 9899:1999 (E)  These are the various functions called by the assert() macro. They are all noreturn functions, although D doesn't have a specific attribute for that.</source>
          <target state="translated">ISO / IEC 9899 : 1999 (E) assert () 매크로가 호출하는 다양한 함수입니다. D에는 특정 속성이 없지만 모두 반환 기능입니다.</target>
        </trans-unit>
        <trans-unit id="79c91cb6efbe5dfcc03f77ea0bf59ceecfb03a1b" translate="yes" xml:space="preserve">
          <source>Iain Buclaw</source>
          <target state="translated">이아 인 부 클로</target>
        </trans-unit>
        <trans-unit id="a61268b8e652624d626d166308f20560b1d3aa63" translate="yes" xml:space="preserve">
          <source>Id::max or Id::min</source>
          <target state="translated">Id :: max 또는 Id :: min</target>
        </trans-unit>
        <trans-unit id="06b6ace8ca3f18249e8ba4ea9090c0f34564ce1c" translate="yes" xml:space="preserve">
          <source>Identifier</source>
          <target state="translated">Identifier</target>
        </trans-unit>
        <trans-unit id="d884429135c14548b3e978b368447365cb96cfc8" translate="yes" xml:space="preserve">
          <source>Identifier (inside Identifier.idPool) with deterministic name based on the source location.</source>
          <target state="translated">소스 위치를 기반으로 결정적인 이름을 가진 식별자 (Identifier.idPool 내부)</target>
        </trans-unit>
        <trans-unit id="d39412a656d9c3c7bf8a3a174965f8e76b9c6aae" translate="yes" xml:space="preserve">
          <source>Identifier : NonVoidInitializer</source>
          <target state="translated">식별자 : NonVoidInitializer</target>
        </trans-unit>
        <trans-unit id="2ea823871928966eb34d2d6331730d76f54cfc52" translate="yes" xml:space="preserve">
          <source>Identifier &lt;code&gt;id&lt;/code&gt;</source>
          <target state="translated">식별자 &lt;code&gt;id&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="fd812024edf80fc26687c86baab342484d1cca2a" translate="yes" xml:space="preserve">
          <source>Identifier &lt;code&gt;ident&lt;/code&gt;</source>
          <target state="translated">식별자 &lt;code&gt;ident&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="f032313123f1ffabc6636b37a2cdfb763957f48d" translate="yes" xml:space="preserve">
          <source>Identifier &lt;code&gt;module_&lt;/code&gt;</source>
          <target state="translated">식별자 &lt;code&gt;module_&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="0ff20fb48822c4ece471eaa71420a8e3f17752e0" translate="yes" xml:space="preserve">
          <source>Identifier &lt;strong id=&quot;identifier&quot;&gt;identifier&lt;/strong&gt;;</source>
          <target state="translated">식별자 &lt;strong id=&quot;identifier&quot;&gt;식별자&lt;/strong&gt; ;</target>
        </trans-unit>
        <trans-unit id="964e8904f66adfee7e7841e9b8d4ec24e389fed4" translate="yes" xml:space="preserve">
          <source>Identifier Emphasis</source>
          <target state="translated">식별자 강조</target>
        </trans-unit>
        <trans-unit id="57fd2f9988cc1bead6d88fdd99fa28550daa5071" translate="yes" xml:space="preserve">
          <source>Identifier required for this condition to pass. If &lt;code&gt;null&lt;/code&gt;, this conditiion will use an integer level.</source>
          <target state="translated">이 조건을 통과하려면 식별자가 필요합니다. 경우 &lt;code&gt;null&lt;/code&gt; 이 conditiion는 정수 수준을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="72a03d37bdb5a52d9cfa01295909001833684faa" translate="yes" xml:space="preserve">
          <source>Identifier value (e.g. &lt;code&gt;Id.unitTest&lt;/code&gt;) or &lt;code&gt;TOK.identifier&lt;/code&gt;</source>
          <target state="translated">식별자 값 (예 : &lt;code&gt;Id.unitTest&lt;/code&gt; ) 또는 &lt;code&gt;TOK.identifier&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="22dcd4202be0468eb915e08817484731c04ef629" translate="yes" xml:space="preserve">
          <source>IdentifierList</source>
          <target state="translated">IdentifierList</target>
        </trans-unit>
        <trans-unit id="649d2864df18704de32e689e69e63f2483e8b76e" translate="yes" xml:space="preserve">
          <source>Identifiers</source>
          <target state="translated">Identifiers</target>
        </trans-unit>
        <trans-unit id="29849b8a9887214097873771c1ada1e4a2b26c67" translate="yes" xml:space="preserve">
          <source>Identifiers in documentation comments that are function parameters or are names that are in scope at the associated declaration are emphasized in the output. This emphasis can take the form of italics, boldface, a hyperlink, etc. How it is emphasized depends on what it is</source>
          <target state="translated">함수 매개 변수이거나 연관된 선언의 범위에있는 이름 인 문서 주석의 식별자는 출력에서 ​​강조됩니다. 이 강조는 이탤릭체, 볼드체, 하이퍼 링크 등의 형태를 취할 수 있습니다. 강조되는 방법은 그 의미에 따라 다릅니다.</target>
        </trans-unit>
        <trans-unit id="ee26ed57025d5c31d0bf47a619bdb084494918ff" translate="yes" xml:space="preserve">
          <source>Identifiers start with a letter, &lt;code&gt;_&lt;/code&gt;, or universal alpha, and are followed by any number of letters, &lt;code&gt;_&lt;/code&gt;, digits, or universal alphas. Universal alphas are as defined in ISO/IEC 9899:1999(E) Appendix D of the C99 Standard. Identifiers can be arbitrarily long, and are case sensitive.</source>
          <target state="translated">식별자는 문자 &lt;code&gt;_&lt;/code&gt; 또는 유니버설 알파로 시작하고 그 뒤에 여러 문자, &lt;code&gt;_&lt;/code&gt; , 숫자 또는 유니버설 알파 가옵니다 . 범용 알파는 C99 표준의 ISO / IEC 9899 : 1999 (E) 부록 D에 정의되어 있습니다. 식별자는 임의로 길 수 있으며 대소 문자를 구분합니다.</target>
        </trans-unit>
        <trans-unit id="745651339d520944f46b951509355e65410d85d8" translate="yes" xml:space="preserve">
          <source>Identifiers* &lt;code&gt;ids&lt;/code&gt;</source>
          <target state="translated">식별자 * &lt;code&gt;ids&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="8bce0759953389b7f6673a7b1dcdcbe2f5adafd6" translate="yes" xml:space="preserve">
          <source>Identifiers* &lt;code&gt;pkg_identifiers&lt;/code&gt;</source>
          <target state="translated">식별자 * &lt;code&gt;pkg_identifiers&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="fd196121fbac89b149b3c74f08384f1bdda01148" translate="yes" xml:space="preserve">
          <source>Identify Statement types with this enum rather than virtual functions.</source>
          <target state="translated">가상 함수가 아닌이 열거 형으로 명령문 유형을 식별하십시오.</target>
        </trans-unit>
        <trans-unit id="897cc900af9b1d4567cf3ac949c0ce028e5b29c4" translate="yes" xml:space="preserve">
          <source>Identify the characteristics of the host CPU, providing information about cache sizes and assembly optimisation hints. This module is provided primarily for assembly language programmers.</source>
          <target state="translated">캐시 크기 및 어셈블리 최적화 힌트에 대한 정보를 제공하여 호스트 CPU의 특성을 식별하십시오. 이 모듈은 주로 어셈블리 언어 프로그래머를 위해 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="294c861b2aa613142591a5192af15c07f9d87cde" translate="yes" xml:space="preserve">
          <source>Identify the compiler used and its various features.</source>
          <target state="translated">사용 된 컴파일러와 다양한 기능을 식별하십시오.</target>
        </trans-unit>
        <trans-unit id="2adbbf9ddb856b5eee69eb90a8ddc235f490d75b" translate="yes" xml:space="preserve">
          <source>Identify whether a variable is defined in the environment.</source>
          <target state="translated">환경에 변수가 정의되어 있는지 확인하십시오.</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
