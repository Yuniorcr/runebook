<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="d">
    <body>
      <group id="d">
        <trans-unit id="5957f81d5474beefa7065939b0cc1473131ad62e" translate="yes" xml:space="preserve">
          <source>The address cannot end with a backslash</source>
          <target state="translated">주소는 백 슬래시로 끝날 수 없습니다</target>
        </trans-unit>
        <trans-unit id="884473b76201e4868789c53f5ad5333ae6e63e04" translate="yes" xml:space="preserve">
          <source>The address contains a character that is not allowed in a quoted pair</source>
          <target state="translated">주소에 따옴표로 묶을 수없는 문자가 포함되어 있습니다</target>
        </trans-unit>
        <trans-unit id="8c9a5ff6c7f32f248ada10269768a9f567d3a6d9" translate="yes" xml:space="preserve">
          <source>The address is only valid according to the broad definition of RFC 5322. It is otherwise invalid</source>
          <target state="translated">주소는 RFC 5322의 광범위한 정의에 따라서 만 유효합니다. 그렇지 않으면 유효하지 않습니다</target>
        </trans-unit>
        <trans-unit id="612f02a9ea5a91c0f5d3bab0d248e35b8e08d288" translate="yes" xml:space="preserve">
          <source>The address may not contain consecutive dots</source>
          <target state="translated">주소는 연속 된 점을 포함 할 수 없습니다</target>
        </trans-unit>
        <trans-unit id="f2ec315916ee72c713d94760053a490c4200261c" translate="yes" xml:space="preserve">
          <source>The address of the destination variable.</source>
          <target state="translated">대상 변수의 주소입니다.</target>
        </trans-unit>
        <trans-unit id="eb5d226a327a58219779ec6f85c14805039c0902" translate="yes" xml:space="preserve">
          <source>The address of the stack bottom.</source>
          <target state="translated">스택 하단의 주소입니다.</target>
        </trans-unit>
        <trans-unit id="6d486d434e5db9fa409133a5d2911ad3ba926ad2" translate="yes" xml:space="preserve">
          <source>The address of the stack top.</source>
          <target state="translated">스택 상단의 주소입니다.</target>
        </trans-unit>
        <trans-unit id="573e0fdfafaaaa6327f4d3ad798c62e0ac496505" translate="yes" xml:space="preserve">
          <source>The address of the value to compare, and receives the prior value of &lt;code&gt;here&lt;/code&gt; as output.</source>
          <target state="translated">비교할 값의 주소이며 &lt;code&gt;here&lt;/code&gt; 에서 이전 값을 출력으로받습니다.</target>
        </trans-unit>
        <trans-unit id="100ae837312c2864dadfce5bae741844606a1fdc" translate="yes" xml:space="preserve">
          <source>The aggregate it is a member of, or null.</source>
          <target state="translated">멤버가 속한 집계 또는 null입니다.</target>
        </trans-unit>
        <trans-unit id="99842dfccac0d88c0dc49fd2be32200c326ae7be" translate="yes" xml:space="preserve">
          <source>The aggregate itself must not be resized, reallocated, free'd, reassigned or destructed while the foreach is iterating over the elements.</source>
          <target state="translated">foreach가 요소를 반복하는 동안 집계 자체의 크기를 조정, 재 할당, 해제, 재 할당 또는 파괴해서는 안됩니다.</target>
        </trans-unit>
        <trans-unit id="6dd852d4a388be331d9744743f8822707966e7c3" translate="yes" xml:space="preserve">
          <source>The aggregate must be loop invariant, meaning that elements to the aggregate cannot be added or removed from it in the &lt;a href=&quot;#NoScopeNonEmptyStatement&quot;&gt;&lt;i&gt;NoScopeNonEmptyStatement&lt;/i&gt;&lt;/a&gt;.</source>
          <target state="translated">집계는 루프 불변이어야합니다. 즉, &lt;a href=&quot;#NoScopeNonEmptyStatement&quot;&gt;&lt;i&gt;NoScopeNonEmptyStatement&lt;/i&gt;&lt;/a&gt; 에서 집계의 요소를 추가하거나 제거 할 수 없습니다 .</target>
        </trans-unit>
        <trans-unit id="a40360593993a6e7d8a1dd4dee1078680e89ae6d" translate="yes" xml:space="preserve">
          <source>The aggregate type to search</source>
          <target state="translated">검색 할 집계 유형</target>
        </trans-unit>
        <trans-unit id="be4d7abfbf6a487ccbcd0c016363e65c1e7e3e7f" translate="yes" xml:space="preserve">
          <source>The aggregate/range bounds are evaluated at compile time and turned into a sequence of compile-time entities by evaluating corresponding code with a &lt;a href=&quot;statement#ForeachStatement&quot;&gt;&lt;i&gt;ForeachStatement&lt;/i&gt;&lt;/a&gt;/&lt;a href=&quot;statement#ForeachRangeStatement&quot;&gt;&lt;i&gt;ForeachRangeStatement&lt;/i&gt;&lt;/a&gt; at compile time. The body of the &lt;code&gt;static foreach&lt;/code&gt; is then copied a number of times that corresponds to the number of elements of the sequence. Within the i-th copy, the name of the &lt;code&gt;static foreach&lt;/code&gt; variable is bound to the i-th entry of the sequence, either as an &lt;code&gt;enum&lt;/code&gt; variable declaration (for constants) or an &lt;code&gt;alias&lt;/code&gt; declaration (for symbols). (In particular, &lt;code&gt;static foreach&lt;/code&gt; variables are never runtime variables.)</source>
          <target state="translated">집계 / 범위 경계는 컴파일 타임에 평가되며 컴파일 타임에 &lt;a href=&quot;statement#ForeachStatement&quot;&gt;&lt;i&gt;ForeachStatement&lt;/i&gt;&lt;/a&gt; / &lt;a href=&quot;statement#ForeachRangeStatement&quot;&gt;&lt;i&gt;ForeachRangeStatement&lt;/i&gt;&lt;/a&gt; 를 사용 하여 해당 코드를 평가하여 컴파일 타임 엔터티 시퀀스로 &lt;i&gt;바뀝니다&lt;/i&gt; . &lt;code&gt;static foreach&lt;/code&gt; 의 본문은 시퀀스의 요소 수에 해당하는 여러 번 복사됩니다. i 번째 사본 내에서 &lt;code&gt;static foreach&lt;/code&gt; 변수 의 이름은 &lt;code&gt;enum&lt;/code&gt; 변수 선언 (상수) 또는 &lt;code&gt;alias&lt;/code&gt; 선언 (기호) 으로 시퀀스의 i 번째 항목에 바인딩됩니다 . 특히 &lt;code&gt;static foreach&lt;/code&gt; 변수는 런타임 변수가 아닙니다.</target>
        </trans-unit>
        <trans-unit id="7524e87df0e2bd2478aea3589a41e1a028d60509" translate="yes" xml:space="preserve">
          <source>The algorithm was designed by Hans Dobbertin, Antoon Bosselaers, and Bart Preneel.</source>
          <target state="translated">알고리즘은 Hans Dobbertin, Antoon Bosselaers 및 Bart Preneel에 의해 설계되었습니다.</target>
        </trans-unit>
        <trans-unit id="4c2bfa97d67b17e650534b7eef10e7ad4c0bcc79" translate="yes" xml:space="preserve">
          <source>The algorithm works as follows:</source>
          <target state="translated">알고리즘은 다음과 같이 작동합니다.</target>
        </trans-unit>
        <trans-unit id="48a9b12ecf15252f0b5157732b6ca9173b4931d2" translate="yes" xml:space="preserve">
          <source>The aliases are:</source>
          <target state="translated">별명은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="81631da16100dd8478c92e814bda7bbba00ac288" translate="yes" xml:space="preserve">
          <source>The aliases following this template create the public names of the log functions.</source>
          <target state="translated">이 템플리트 다음에 오는 별명은 로그 함수의 공용 이름을 작성합니다.</target>
        </trans-unit>
        <trans-unit id="bcbe81e1130e17fc3109bc8509350a184b24f288" translate="yes" xml:space="preserve">
          <source>The aliases following this template create the public names of these log functions.</source>
          <target state="translated">이 템플릿 다음에 오는 별칭은 이러한 로그 함수의 공개 이름을 만듭니다.</target>
        </trans-unit>
        <trans-unit id="c567df7009dd19d930ebcb716790130e92399528" translate="yes" xml:space="preserve">
          <source>The alignment for the fields of an aggregate does not affect the alignment of the aggregate itself - that is affected by the alignment setting outside of the aggregate.</source>
          <target state="translated">집계 필드의 정렬은 집계 자체의 정렬에 영향을 미치지 않습니다. 이는 집계 외부의 정렬 설정에 영향을받습니다.</target>
        </trans-unit>
        <trans-unit id="f093103ea9ccde93c26257d52a8ebe06d2563d51" translate="yes" xml:space="preserve">
          <source>The alignment is a static constant equal to &lt;code&gt;platformAlignment&lt;/code&gt;, which ensures proper alignment for any D data type.</source>
          <target state="translated">정렬은 &lt;code&gt;platformAlignment&lt;/code&gt; 와 동일한 정적 상수 이며 모든 D 데이터 유형에 대한 올바른 정렬을 보장합니다.</target>
        </trans-unit>
        <trans-unit id="15ebd1ca8e45d31f001b9c11ace8a2913c42cd0b" translate="yes" xml:space="preserve">
          <source>The alignment offered is the minimum of the two allocators' alignment.</source>
          <target state="translated">제공되는 정렬은 두 할당 자의 정렬 중 최소입니다.</target>
        </trans-unit>
        <trans-unit id="98d787b597dca14b1cd2aa32405fb6769c33f39f" translate="yes" xml:space="preserve">
          <source>The alignment offered is the same as &lt;code&gt;Allocator.alignment&lt;/code&gt;.</source>
          <target state="translated">제공되는 정렬은 &lt;code&gt;Allocator.alignment&lt;/code&gt; 와 동일합니다 .</target>
        </trans-unit>
        <trans-unit id="2d9bcfc1fe50fa247260c84039c4e52f5cc8339c" translate="yes" xml:space="preserve">
          <source>The alignment offered is user-configurable statically through parameter &lt;code&gt;theAlignment&lt;/code&gt;, defaulted to &lt;code&gt;platformAlignment&lt;/code&gt;.</source>
          <target state="translated">제공되는 정렬은 매개 변수 &lt;code&gt;theAlignment&lt;/code&gt; 를 통해 정적으로 사용자가 구성 할 수 있으며 &lt;code&gt;platformAlignment&lt;/code&gt; 로 기본 설정됩니다 .</target>
        </trans-unit>
        <trans-unit id="55ae38068c659d6482341d5f2a9544d2084b247f" translate="yes" xml:space="preserve">
          <source>The alignment offered.</source>
          <target state="translated">정렬이 제공되었습니다.</target>
        </trans-unit>
        <trans-unit id="0f037bbde370840fb51ae0cd55e297a5ad94c4c1" translate="yes" xml:space="preserve">
          <source>The alignment that is guaranteed to accommodate any D object allocation on the current platform.</source>
          <target state="translated">현재 플랫폼에서 D 객체 할당을 수용 할 수있는 정렬입니다.</target>
        </trans-unit>
        <trans-unit id="ffaeeba22bc74fcd6590cff49e1181655746149d" translate="yes" xml:space="preserve">
          <source>The allocated block looks like this for blocks &amp;lt; PAGESIZE:</source>
          <target state="translated">할당 된 블록은 &amp;lt;PAGESIZE 블록에 대해 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="1e6e16df97f3afd43394873bd1850208370d0247" translate="yes" xml:space="preserve">
          <source>The allocated block, or &lt;code&gt;null&lt;/code&gt;.</source>
          <target state="translated">할당 된 블록, 또는 &lt;code&gt;null&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4d585ec1807a2dc496ab963634c47b6fc38f63ce" translate="yes" xml:space="preserve">
          <source>The allocated memory is aligned to the specified alignment &lt;code&gt;a&lt;/code&gt;.</source>
          <target state="translated">할당 된 메모리는 지정된 정렬 &lt;code&gt;a&lt;/code&gt; 에 정렬 됩니다.</target>
        </trans-unit>
        <trans-unit id="26fd1cc82ed45b7bca2ff3a406ac59e252c10871" translate="yes" xml:space="preserve">
          <source>The allocator used for getting the needed memory. It may be an object implementing the static interface for allocators, or an &lt;code&gt;IAllocator&lt;/code&gt; reference.</source>
          <target state="translated">할당자는 필요한 메모리를 얻는 데 사용됩니다. 할당 자에 대한 정적 인터페이스를 구현하는 객체이거나 &lt;code&gt;IAllocator&lt;/code&gt; 참조 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7a162642b55adf8c70cb72e78e6a91ca645573ee" translate="yes" xml:space="preserve">
          <source>The amount of time (as a &lt;a href=&quot;core_time#Duration&quot;&gt;&lt;code&gt;core.time.Duration&lt;/code&gt;&lt;/a&gt;) that it took to call each function &lt;code&gt;n&lt;/code&gt; times. The first value is the length of time that it took to call &lt;code&gt;fun[0]&lt;/code&gt;&lt;code&gt;n&lt;/code&gt; times. The second value is the length of time it took to call &lt;code&gt;fun[1]&lt;/code&gt;&lt;code&gt;n&lt;/code&gt; times. Etc.</source>
          <target state="translated">각 함수를 &lt;code&gt;n&lt;/code&gt; 번 호출하는 데 걸린 시간 ( &lt;a href=&quot;core_time#Duration&quot;&gt; &lt;code&gt;core.time.Duration&lt;/code&gt; &lt;/a&gt; )입니다 . 첫 번째 값은 &lt;code&gt;fun[0]&lt;/code&gt; &lt;code&gt;n&lt;/code&gt; 번 호출하는 데 걸린 시간입니다. 두 번째 값은 &lt;code&gt;fun[1]&lt;/code&gt; &lt;code&gt;n&lt;/code&gt; 번 호출하는 데 걸린 시간입니다. 기타.</target>
        </trans-unit>
        <trans-unit id="679e02f2df98ca53eb58d9358d749fc6899efa4f" translate="yes" xml:space="preserve">
          <source>The amount of time (as a &lt;a href=&quot;core_time#TickDuration&quot;&gt;&lt;code&gt;core.time.TickDuration&lt;/code&gt;&lt;/a&gt;) that it took to call each function &lt;code&gt;n&lt;/code&gt; times. The first value is the length of time that it took to call &lt;code&gt;fun[0]&lt;/code&gt;&lt;code&gt;n&lt;/code&gt; times. The second value is the length of time it took to call &lt;code&gt;fun[1]&lt;/code&gt;&lt;code&gt;n&lt;/code&gt; times. Etc.  Note that casting the TickDurations to &lt;a href=&quot;core_time#Duration&quot;&gt;&lt;code&gt;core.time.Duration&lt;/code&gt;&lt;/a&gt;s will make the results easier to deal with (and it may change in the future that benchmark will return an array of Durations rather than TickDurations).</source>
          <target state="translated">각 함수를 &lt;code&gt;n&lt;/code&gt; 번 호출하는 데 걸린 시간 ( &lt;a href=&quot;core_time#TickDuration&quot;&gt; &lt;code&gt;core.time.TickDuration&lt;/code&gt; &lt;/a&gt; )입니다 . 첫 번째 값은 &lt;code&gt;fun[0]&lt;/code&gt; &lt;code&gt;n&lt;/code&gt; 번 호출하는 데 걸린 시간입니다. 두 번째 값은 &lt;code&gt;fun[1]&lt;/code&gt; &lt;code&gt;n&lt;/code&gt; 번 호출하는 데 걸린 시간입니다. 기타 TickDurations를 &lt;a href=&quot;core_time#Duration&quot;&gt; &lt;code&gt;core.time.Duration&lt;/code&gt; 으로&lt;/a&gt; 캐스팅하면 결과를보다 쉽게 ​​처리 할 수 ​​있습니다 (그리고 나중에 벤치 마크에서 TickDurations가 아닌 지속 시간 배열이 반환 될 수 있음).</target>
        </trans-unit>
        <trans-unit id="5f2ab544dd26a15cec91af6687d533c4df3410af" translate="yes" xml:space="preserve">
          <source>The amount of time the offset from UTC is (negative is west of UTC, positive is east).</source>
          <target state="translated">UTC와의 오프셋 시간은 양입니다 (음수는 UTC 서쪽, 양수는 동쪽).</target>
        </trans-unit>
        <trans-unit id="6ca92b99392b2201548ac94076929186c2729bd5" translate="yes" xml:space="preserve">
          <source>The argument</source>
          <target state="translated">논쟁 거리</target>
        </trans-unit>
        <trans-unit id="95ad1044a61a4a355c884ad9c8beb68fea8cbf9e" translate="yes" xml:space="preserve">
          <source>The argument (or phase) of &lt;code&gt;z&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;z&lt;/code&gt; 의 인수 (또는 위상) .</target>
        </trans-unit>
        <trans-unit id="c58aecc00ef7e3c30bc80ddf70bce576b8c7b76a" translate="yes" xml:space="preserve">
          <source>The argument count.</source>
          <target state="translated">인수 개수</target>
        </trans-unit>
        <trans-unit id="d38f16231ac42e003a0a7d9c3c817f7a78c027ca" translate="yes" xml:space="preserve">
          <source>The argument is a symbol. The result is a string giving its protection level: &quot;public&quot;, &quot;private&quot;, &quot;protected&quot;, &quot;export&quot;, or &quot;package&quot;.</source>
          <target state="translated">논쟁은 상징이다. 결과는 &quot;public&quot;, &quot;private&quot;, &quot;protected&quot;, &quot;export&quot;또는 &quot;package&quot;와 같은 보호 수준을 제공하는 문자열입니다.</target>
        </trans-unit>
        <trans-unit id="b7bee920123d48f748fd063723855b9cdf7fc70e" translate="yes" xml:space="preserve">
          <source>The argument is a type. The result is an array of &lt;code&gt;size_t&lt;/code&gt; describing the memory used by an instance of the given type.</source>
          <target state="translated">인수는 유형입니다. 결과는 주어진 유형의 인스턴스가 사용하는 메모리를 설명하는 &lt;code&gt;size_t&lt;/code&gt; 배열입니다 .</target>
        </trans-unit>
        <trans-unit id="bd0d0e4c2f22549c04310e29901bafb6d89f2cbb" translate="yes" xml:space="preserve">
          <source>The argument to &lt;code&gt;dg&lt;/code&gt; is &lt;code&gt;scope&lt;/code&gt;. To keep the data around after &lt;code&gt;dg&lt;/code&gt; exits, one has to copy it.</source>
          <target state="translated">&lt;code&gt;dg&lt;/code&gt; 에 대한 인수 는 &lt;code&gt;scope&lt;/code&gt; 입니다. &lt;code&gt;dg&lt;/code&gt; 종료 후 데이터를 유지하려면 복사해야합니다.</target>
        </trans-unit>
        <trans-unit id="d6506a51a0d81317d36c0b3931580ed4ae34e0c1" translate="yes" xml:space="preserve">
          <source>The arguments as a C array of strings.</source>
          <target state="translated">문자열의 C 배열로서의 인수.</target>
        </trans-unit>
        <trans-unit id="9a539cbbe8582d8d5d90be89210dc5f77ab9a858" translate="yes" xml:space="preserve">
          <source>The arguments supplied when this process was started.</source>
          <target state="translated">이 프로세스가 시작될 때 제공된 인수입니다.</target>
        </trans-unit>
        <trans-unit id="afc42ff1b01f9fdceb0afc9990aeafdba8561cdc" translate="yes" xml:space="preserve">
          <source>The arguments the function was called with. Changes to &lt;code&gt;out&lt;/code&gt; and &lt;code&gt;ref&lt;/code&gt; arguments will be visible here.</source>
          <target state="translated">함수가 호출 된 인수 &lt;code&gt;out&lt;/code&gt; 및 &lt;code&gt;ref&lt;/code&gt; 인수에 대한 변경 사항이 여기에 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="63025a0e656a03617731632fd0d058123f82e206" translate="yes" xml:space="preserve">
          <source>The array generated by &lt;code&gt;makeTransTable&lt;/code&gt; is &lt;code&gt;256&lt;/code&gt; elements long such that the index is equal to the ASCII character being replaced and the value is equal to the character that it's being replaced with. Note that translate does not decode any of the characters, so you can actually pass it Extended ASCII characters if you want to (ASCII only actually uses &lt;code&gt;128&lt;/code&gt; characters), but be warned that Extended ASCII characters are not valid Unicode and therefore will result in a &lt;code&gt;UTFException&lt;/code&gt; being thrown from most other Phobos functions.</source>
          <target state="translated">&lt;code&gt;makeTransTable&lt;/code&gt; 에 의해 생성 된 배열의 길이 는 &lt;code&gt;256&lt;/code&gt; 요소 이므로 색인은 교체 될 ASCII 문자와 같고 값은 교체되는 문자와 같습니다. translate는 문자를 해독하지 않으므로 원하는 경우 확장 ASCII 문자를 실제로 전달할 수 있지만 (ASCII는 실제로 &lt;code&gt;128&lt;/code&gt; 자만 사용함 ) 확장 ASCII 문자는 유효한 유니 코드가 아니므로 경고가 표시됩니다. 대부분의 다른 Phobos 함수에서 &lt;code&gt;UTFException&lt;/code&gt; 이 발생했습니다.</target>
        </trans-unit>
        <trans-unit id="1e36bd34216b4fb890e4b17cc00a08b3fe10bf73" translate="yes" xml:space="preserve">
          <source>The array indexing and slicing operators are overloaded by implementing the &lt;code&gt;opIndex&lt;/code&gt;, &lt;code&gt;opSlice&lt;/code&gt;, and &lt;code&gt;opDollar&lt;/code&gt; methods. These may be combined to implement multidimensional arrays.</source>
          <target state="translated">&lt;code&gt;opIndex&lt;/code&gt; , &lt;code&gt;opSlice&lt;/code&gt; 및 &lt;code&gt;opDollar&lt;/code&gt; 메서드 를 구현하면 배열 인덱싱 및 슬라이싱 연산자가 오버로드됩니다 . 이들은 다차원 어레이를 구현하기 위해 결합 될 수있다.</target>
        </trans-unit>
        <trans-unit id="1b2a7128d2d832c1302cb48d5006b21f210a2eeb" translate="yes" xml:space="preserve">
          <source>The array of &lt;code&gt;Statements&lt;/code&gt;, or &lt;code&gt;null&lt;/code&gt; if no flattening necessary</source>
          <target state="translated">어레이의 &lt;code&gt;Statements&lt;/code&gt; , 또는 &lt;code&gt;null&lt;/code&gt; 더 필요한 평탄화 없으면</target>
        </trans-unit>
        <trans-unit id="45a797de9ee37043ed5d9c3044ead0d769c8dfec" translate="yes" xml:space="preserve">
          <source>The array of allocators is publicly available for e.g. initialization and inspection.</source>
          <target state="translated">할당 자 배열은 초기화 및 검사 등을 위해 공개적으로 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="78465f24447e3c88a59d9835a9423a9e3ebd4f18" translate="yes" xml:space="preserve">
          <source>The array of bits to iterate over</source>
          <target state="translated">반복 할 비트 배열</target>
        </trans-unit>
        <trans-unit id="4ca952de23045dd7d8a84c57a2dc3a2d3b262893" translate="yes" xml:space="preserve">
          <source>The array that &lt;code&gt;stuff&lt;/code&gt; will be inserted into.</source>
          <target state="translated">&lt;code&gt;stuff&lt;/code&gt; 이 삽입되는 배열입니다 .</target>
        </trans-unit>
        <trans-unit id="4321c353e1c32d604816547a52f50f3db51eff04" translate="yes" xml:space="preserve">
          <source>The array to cast to immutable.</source>
          <target state="translated">불변으로 캐스트 할 배열입니다.</target>
        </trans-unit>
        <trans-unit id="c1207d2a97f985ed8f1d6e838bce196b8c261949" translate="yes" xml:space="preserve">
          <source>The array to store the factorial number. The array is of size 21 as &lt;code&gt;ulong.max&lt;/code&gt; requires 21 digits in the factorial number system.</source>
          <target state="translated">계승 수를 저장할 배열입니다. &lt;code&gt;ulong.max&lt;/code&gt; 는 계승 수 시스템에서 21 자리가 필요하므로 배열의 크기는 21 입니다.</target>
        </trans-unit>
        <trans-unit id="2e58d1006cb20d5f3840c703c981f56532e89433" translate="yes" xml:space="preserve">
          <source>The array type to simulate</source>
          <target state="translated">시뮬레이션 할 배열 유형</target>
        </trans-unit>
        <trans-unit id="5eff91e039ba4d6d8d23f84bae72af3efca47e6c" translate="yes" xml:space="preserve">
          <source>The asm.js intermediate programming language</source>
          <target state="translated">asm.js 중간 프로그래밍 언어</target>
        </trans-unit>
        <trans-unit id="9e1495896a8171a6a847812d0360c297c1cf65a4" translate="yes" xml:space="preserve">
          <source>The assembled path.</source>
          <target state="translated">조립 된 경로.</target>
        </trans-unit>
        <trans-unit id="1e2b85b82e92a3856a1e1c2b72d37fa265091420" translate="yes" xml:space="preserve">
          <source>The assertion is independent from -release, by abort()ing. Regular assertions throw an AssertError and thus require an initialized GC, which might not be the case (yet or anymore) for the startup/shutdown code in this package (called by CRT ctors/dtors etc.).</source>
          <target state="translated">어설 션은 abort () ing에 의해 -release와 독립적입니다. 일반 어설 션에서는 AssertError가 발생하므로 초기화 된 GC가 필요합니다.이 패키지의 시작 / 종료 코드 (CRT ctors / dtors 등)의 경우에는 아직 그렇지 않을 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="dd468c6bd7b4f24fe4681661a1f4c1bf9f53f209" translate="yes" xml:space="preserve">
          <source>The assignment character used in options with parameters (default '=').</source>
          <target state="translated">매개 변수와 함께 옵션에 사용되는 대입 문자 (기본값 '=')</target>
        </trans-unit>
        <trans-unit id="d1cc08d2be4a1f3b1bcdb0c1a5ad7e06c61f4a9a" translate="yes" xml:space="preserve">
          <source>The assignment operator &lt;code&gt;=&lt;/code&gt; can be overloaded if the left hand side is a struct aggregate, and &lt;code&gt;opAssign&lt;/code&gt; is a member function of that aggregate.</source>
          <target state="translated">왼쪽이 구조체 집계이고 &lt;code&gt;opAssign&lt;/code&gt; 이 해당 집계의 멤버 함수 인 경우 대입 연산자 &lt;code&gt;=&lt;/code&gt; 가 오버로드 될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="9ca96b2dca99020e1c9332c4a525410f5467c7f8" translate="yes" xml:space="preserve">
          <source>The associated Tid or Tid.init if name is not registered.</source>
          <target state="translated">이름이 등록되지 않은 경우 관련된 Tid 또는 Tid.init</target>
        </trans-unit>
        <trans-unit id="d2c138793e6130d41176963ee803d482cbf6ac55" translate="yes" xml:space="preserve">
          <source>The associative array to iterate over.</source>
          <target state="translated">반복 할 연관 배열입니다.</target>
        </trans-unit>
        <trans-unit id="3f8e903e0ceb75b15c10ccad54194376c61bbba7" translate="yes" xml:space="preserve">
          <source>The associative array.</source>
          <target state="translated">연관 배열.</target>
        </trans-unit>
        <trans-unit id="7878f31bd1a31b1a2cfd5e7a52ffdc7c9ecd24a9" translate="yes" xml:space="preserve">
          <source>The assumption is that &lt;code&gt;first&lt;/code&gt; comes before &lt;code&gt;second&lt;/code&gt; in the original text, usually meaning that the first is a starter.</source>
          <target state="translated">원래 텍스트에서 &lt;code&gt;first&lt;/code&gt; 가 &lt;code&gt;second&lt;/code&gt; 보다 먼저 나오는 것으로 가정 합니다. 일반적으로 첫 번째가 시작임을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="61806db12d64abe42691b62a374e038f9ecaadda" translate="yes" xml:space="preserve">
          <source>The atomic module provides basic support for lock-free concurrent programming.</source>
          <target state="translated">원자 모듈은 잠금없는 동시 프로그래밍에 대한 기본 지원을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="75eef2eb2a8bfe31e731a278f35f0ceb7c55d5e5" translate="yes" xml:space="preserve">
          <source>The attack happens as follows:</source>
          <target state="translated">공격은 다음과 같이 발생합니다.</target>
        </trans-unit>
        <trans-unit id="f7c54a735163e7d571809eeacaa1471999099ee3" translate="yes" xml:space="preserve">
          <source>The attribute can only be attached once to a method</source>
          <target state="translated">속성은 메소드에 한 번만 첨부 할 수 있습니다</target>
        </trans-unit>
        <trans-unit id="79ccd1c77d9bb55894eeaf0ddb5f8bb5f1442f97" translate="yes" xml:space="preserve">
          <source>The attribute can only be attached to methods or constructors which have Objective-C linkage. That is, a method or a constructor in a class or interface declared as</source>
          <target state="translated">이 속성은 Objective-C 링크가있는 메소드 또는 생성자에만 첨부 할 수 있습니다. 즉, 클래스 또는 인터페이스의 메소드 또는 생성자로 선언 된</target>
        </trans-unit>
        <trans-unit id="9e6a8c7917aafe6dd89c5b3da037ce8ce791dcd0" translate="yes" xml:space="preserve">
          <source>The attribute can only be attached to methods with Objective-C linkage</source>
          <target state="translated">이 속성은 Objective-C 연결이있는 메소드에만 첨부 할 수 있습니다</target>
        </trans-unit>
        <trans-unit id="0cc4b73eb5ab20f789654491f3d1669a5a798998" translate="yes" xml:space="preserve">
          <source>The attribute cannot be attached to a template method</source>
          <target state="translated">속성을 템플릿 메소드에 첨부 할 수 없습니다</target>
        </trans-unit>
        <trans-unit id="c3e58f213e4368a17eae0f25fdb580af5f953648" translate="yes" xml:space="preserve">
          <source>The attribute is defined in druntime in &lt;a href=&quot;https://dlang.org/phobos/core_attribute.html&quot;&gt;&lt;code&gt;core.attribute&lt;/code&gt;&lt;/a&gt; and aliased in &lt;a href=&quot;https://dlang.org/phobos/object.html&quot;&gt;&lt;code&gt;object&lt;/code&gt;&lt;/a&gt;, meaning it will be implicitly imported. The attribute is only defined when the version identifier &lt;a href=&quot;#objc-version-identifier&quot;&gt;&lt;code&gt;D_ObjectiveC&lt;/code&gt;&lt;/a&gt; is enabled.</source>
          <target state="translated">이 속성은에서 druntime에 정의되어 &lt;a href=&quot;https://dlang.org/phobos/core_attribute.html&quot;&gt; &lt;code&gt;core.attribute&lt;/code&gt; &lt;/a&gt; 과의 별명 &lt;a href=&quot;https://dlang.org/phobos/object.html&quot;&gt; &lt;code&gt;object&lt;/code&gt; &lt;/a&gt; 가 암시 적으로 가져옵니다 의미한다. 이 속성은 버전 식별자 &lt;a href=&quot;#objc-version-identifier&quot;&gt; &lt;code&gt;D_ObjectiveC&lt;/code&gt; &lt;/a&gt; 가 활성화 된 경우에만 정의됩니다 .</target>
        </trans-unit>
        <trans-unit id="96eac9336921a98926c132d1b4d9806462791d58" translate="yes" xml:space="preserve">
          <source>The attribute of the type name is not the same as the attribute of the variable:</source>
          <target state="translated">유형 이름의 속성이 변수의 속성과 동일하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="24cd99fe8bbe482a8a5a81e7f4b51e39455ae56f" translate="yes" xml:space="preserve">
          <source>The attributes (g, i, m, s and x accepted)</source>
          <target state="translated">속성 (g, i, m, s 및 x가 허용됨)</target>
        </trans-unit>
        <trans-unit id="4ee39b3b86f5106a3fdc7e1ea7775bb7c85ac176" translate="yes" xml:space="preserve">
          <source>The attributes of the &lt;a href=&quot;expression#AssignExpression&quot;&gt;&lt;i&gt;AssignExpression&lt;/i&gt;&lt;/a&gt; are applied where the default expression is used.</source>
          <target state="translated">&lt;a href=&quot;expression#AssignExpression&quot;&gt;&lt;i&gt;AssignExpression&lt;/i&gt;&lt;/a&gt; 의 속성은 기본 표현식이 사용되는 곳에 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="06da5fd89d1e09344f5502c88832d0079ac5062c" translate="yes" xml:space="preserve">
          <source>The attributes of the file as a &lt;code&gt;uint&lt;/code&gt;.</source>
          <target state="translated">파일의 속성을 &lt;code&gt;uint&lt;/code&gt; 로 나타 냅니다.</target>
        </trans-unit>
        <trans-unit id="ab103bac227f27736507e49db9f68f7e1c3bdf17" translate="yes" xml:space="preserve">
          <source>The background thread will buffer up to transmitBuffers number of chunks before is stops receiving data from network. When the main thread reads the chunks from the range it frees up buffers and allows for the background thread to receive more data from the network.</source>
          <target state="translated">백그라운드 스레드는 네트워크에서 데이터 수신을 중지하기 전에 최대 전송 버퍼 수의 청크까지 버퍼링합니다. 메인 스레드가 범위에서 청크를 읽으면 버퍼를 비우고 백그라운드 스레드가 네트워크에서 더 많은 데이터를 수신 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2f49fc1ac2fa753eb385adebbde8c5e3739e3eb5" translate="yes" xml:space="preserve">
          <source>The background thread will buffer up to transmitBuffers number of lines before it stops receiving data from network. When the main thread reads the lines from the range it frees up buffers and allows for the background thread to receive more data from the network.</source>
          <target state="translated">백그라운드 스레드는 네트워크에서 데이터 수신을 중지하기 전에 최대 전송 버퍼 수의 라인까지 버퍼링합니다. 메인 스레드가 범위에서 라인을 읽으면 버퍼를 비우고 백그라운드 스레드가 네트워크에서 더 많은 데이터를 수신 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="df002316032ff2e092a1cc3a410d04df468eda1d" translate="yes" xml:space="preserve">
          <source>The backslash character is not treated specially inside &lt;a href=&quot;#Filespec&quot;&gt;&lt;i&gt;Filespec&lt;/i&gt;&lt;/a&gt; strings.</source>
          <target state="translated">백 슬래시 문자는 &lt;a href=&quot;#Filespec&quot;&gt;&lt;i&gt;Filespec&lt;/i&gt;&lt;/a&gt; 문자열 내에서 특별히 처리되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="a707c2f980ce4edb81a7e52be4d3486a20f75970" translate="yes" xml:space="preserve">
          <source>The barrier module provides a primitive for synchronizing the progress of a group of threads.</source>
          <target state="translated">배리어 모듈은 스레드 그룹의 진행 상황을 동기화하기위한 기본 요소를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="0f16b21bd145c48ee38391d193636c622ee32ed4" translate="yes" xml:space="preserve">
          <source>The base address of the memory block referenced by p or null on error.</source>
          <target state="translated">p가 참조하는 메모리 블록의 기본 주소 또는 오류시 null.</target>
        </trans-unit>
        <trans-unit id="202abe43b53a16dc33ac200ec72cb69c866674c7" translate="yes" xml:space="preserve">
          <source>The base class for exceptions thrown by this module</source>
          <target state="translated">이 모듈에 의해 발생 된 예외의 기본 클래스</target>
        </trans-unit>
        <trans-unit id="1a2d8f5221992ec16fa6b9228ee8706ba1b5f8a3" translate="yes" xml:space="preserve">
          <source>The base class of all AST nodes.</source>
          <target state="translated">모든 AST 노드의 기본 클래스입니다.</target>
        </trans-unit>
        <trans-unit id="2c62b6527d85866989d96fc04ef66293021bf4e4" translate="yes" xml:space="preserve">
          <source>The base class of all errors that are safe to catch and handle.</source>
          <target state="translated">파악하고 처리하기에 안전한 모든 오류의 기본 클래스입니다.</target>
        </trans-unit>
        <trans-unit id="3d510f9f0a1f647c90ed3c0e84e9bc68e62fbef9" translate="yes" xml:space="preserve">
          <source>The base class of all thrown objects.</source>
          <target state="translated">던져진 모든 객체의 기본 클래스.</target>
        </trans-unit>
        <trans-unit id="f59893c50b7d9f6fccbb634dce991efa1ec27e2a" translate="yes" xml:space="preserve">
          <source>The base class of all unrecoverable runtime errors.</source>
          <target state="translated">복구 할 수없는 모든 런타임 오류의 기본 클래스입니다.</target>
        </trans-unit>
        <trans-unit id="2ae564b78fab59c5ea57c135e5d25f9a2f2f9e56" translate="yes" xml:space="preserve">
          <source>The base path to construct the relative path from.</source>
          <target state="translated">상대 경로를 구성 할 기본 경로입니다.</target>
        </trans-unit>
        <trans-unit id="7b8c780a7aaf44d0ec25e2d71c9d91275146dbb5" translate="yes" xml:space="preserve">
          <source>The base ptr in this struct can be cleared asynchronously by the GC, so any use of the returned BlkInfo should copy it and then check the base ptr of the copy before actually using it.</source>
          <target state="translated">이 구조체의 기본 ptr은 GC에 의해 비동기 적으로 지워질 수 있으므로 반환 된 BlkInfo를 사용하면이를 복사 한 다음 실제로 사용하기 전에 복사본의 기본 ptr을 확인해야합니다.</target>
        </trans-unit>
        <trans-unit id="8690f4437635a1d2bf0002da1660f73ae69c67e5" translate="yes" xml:space="preserve">
          <source>The base type.</source>
          <target state="translated">기본 유형입니다.</target>
        </trans-unit>
        <trans-unit id="dbcf092daafa8f2354629e2a622f62afa3a72b3b" translate="yes" xml:space="preserve">
          <source>The basetype must be one of: byte[16],ubyte[16],short[8],ushort[8],int[4],uint[4],long[2],ulong[2],float[4],double[2] For AVX: byte[32],ubyte[32],short[16],ushort[16],int[8],uint[8],long[4],ulong[4],float[8],double[4]</source>
          <target state="translated">기본 유형은 byte [16], ubyte [16], short [8], ushort [8], int [4], uint [4], long [2], ulong [2], float [4 중 하나 여야합니다. ], double [2] AVX의 경우 : byte [32], ubyte [32], short [16], ushort [16], int [8], uint [8], long [4], ulong [4], float [8], 더블 [4]</target>
        </trans-unit>
        <trans-unit id="399482d1c370eb1ac5e16d0aa1eed3cdd1c42d74" translate="yes" xml:space="preserve">
          <source>The basic architecture of this module is that there are standalone functions, classes for constructing an XML document from scratch (Tag, Element and Document), and also classes for parsing a pre-existing XML file (ElementParser and DocumentParser). The parsing classes</source>
          <target state="translated">이 모듈의 기본 아키텍처는 독립형 함수, 처음부터 XML 문서를 작성하기위한 클래스 (태그, 요소 및 문서) 및 기존 XML 파일 (ElementParser 및 DocumentParser)을 구문 분석하기위한 클래스가 있다는 것입니다. 파싱 ​​클래스</target>
        </trans-unit>
        <trans-unit id="bd83f1731835a7762685d9b1b4c80ae22caa482b" translate="yes" xml:space="preserve">
          <source>The basic syntax shouldn't surprise experienced users of regular expressions. For an introduction to &lt;code&gt;std.regex&lt;/code&gt; see a &lt;a href=&quot;http://dlang.org/regular-expression.html&quot;&gt;short tour&lt;/a&gt; of the module API and its abilities.</source>
          <target state="translated">기본 구문은 숙련 된 정규 표현식 사용자에게 놀라지 않아야합니다. &lt;code&gt;std.regex&lt;/code&gt; 에 대한 소개 는 모듈 API와 그 기능에 대한 &lt;a href=&quot;http://dlang.org/regular-expression.html&quot;&gt;간단한 둘러보기&lt;/a&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="234f6e28893085e219de1f945a7e3dc32736e80c" translate="yes" xml:space="preserve">
          <source>The behavior executed when a message is sent to a full mailbox.</source>
          <target state="translated">메시지가 전체 사서함으로 전송 될 때 실행되는 동작입니다.</target>
        </trans-unit>
        <trans-unit id="ab5c4600b299e121274047c9c50598443a05a652" translate="yes" xml:space="preserve">
          <source>The behavior when a</source>
          <target state="translated">때 행동</target>
        </trans-unit>
        <trans-unit id="10d232650e9a8e91839d30ef0b07aa3a7812c3ee" translate="yes" xml:space="preserve">
          <source>The behavior when the invariant does not hold is typically the same as for when &lt;a href=&quot;expression#AssertExpression&quot;&gt;&lt;i&gt;AssertExpression&lt;/i&gt;&lt;/a&gt;s fail.</source>
          <target state="translated">불변 값이 유지되지 않을 때의 동작은 일반적으로 &lt;a href=&quot;expression#AssertExpression&quot;&gt;&lt;i&gt;AssertExpression이&lt;/i&gt;&lt;/a&gt; 실패한 경우와 동일 합니다.</target>
        </trans-unit>
        <trans-unit id="32c253b8b8075fafad7db46ce9573fe20079099e" translate="yes" xml:space="preserve">
          <source>The best way is to use std.stdio.writefln, which can handle D strings:</source>
          <target state="translated">가장 좋은 방법은 std.stdio.writefln을 사용하는 것입니다.이 문자열은 D 문자열을 처리 할 수 ​​있습니다.</target>
        </trans-unit>
        <trans-unit id="074a4ed5e1cf5284566f4613af5758030a468edf" translate="yes" xml:space="preserve">
          <source>The beta function is defined as</source>
          <target state="translated">베타 기능은 다음과 같이 정의됩니다</target>
        </trans-unit>
        <trans-unit id="776df6b9101ffe92329a9ec86d4f259d56f6f5cd" translate="yes" xml:space="preserve">
          <source>The binary heap induces structure over the underlying store such that accessing the largest element (by using the &lt;code&gt;front&lt;/code&gt; property) is a &amp;Omicron;(&lt;code&gt;1&lt;/code&gt;) operation and extracting it (by using the &lt;code&gt;removeFront()&lt;/code&gt; method) is done fast in &amp;Omicron;(&lt;code&gt;log n&lt;/code&gt;) time.</source>
          <target state="translated">이진 힙은 가장 큰 요소에 액세스하는 경우 ( &lt;code&gt;front&lt;/code&gt; 속성 을 사용하여 ) &amp;Omicron; ( &lt;code&gt;1&lt;/code&gt; ) 연산이고 추출 ( &lt;code&gt;removeFront()&lt;/code&gt; 메서드 를 사용하여)을 추출하는 것이 &amp;Omicron; ( &lt;code&gt;log n&lt;/code&gt; ) 에서 빠르게 수행 되도록 기본 저장소에 대한 구조를 유도 합니다. 시각.</target>
        </trans-unit>
        <trans-unit id="4c8ec4e4b9635f6e100188d75e888fd06cd8e192" translate="yes" xml:space="preserve">
          <source>The binary operator involved, e.g. &lt;code&gt;/&lt;/code&gt;</source>
          <target state="translated">관련된 이진 연산자, 예를 들어 &lt;code&gt;/&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="d68c85a934ba6bb56625f3815258575a45ac4309" translate="yes" xml:space="preserve">
          <source>The binary operator ~ is the</source>
          <target state="translated">이항 연산자 ~는</target>
        </trans-unit>
        <trans-unit id="97c48bbd4c951e34df677fdb5ba8d5cff4f6b9ee" translate="yes" xml:space="preserve">
          <source>The binary predicate to compare the elements of the two ranges.</source>
          <target state="translated">이 범위 술어는 두 범위의 요소를 비교합니다.</target>
        </trans-unit>
        <trans-unit id="c0f1385da3c1b4c526f08c5b626218775066160e" translate="yes" xml:space="preserve">
          <source>The bit number of the first bit set. The return value is undefined if v is zero.</source>
          <target state="translated">첫 번째 비트 세트의 비트 번호입니다. v가 0이면 리턴 값이 정의되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="f465b8408295f09e1e80dc77dc9289f124c8a06a" translate="yes" xml:space="preserve">
          <source>The bitwise OR of the equivalent &lt;a href=&quot;#ParameterStorageClass&quot;&gt;&lt;code&gt;ParameterStorageClass&lt;/code&gt;&lt;/a&gt;&lt;code&gt;enum&lt;/code&gt;s.</source>
          <target state="translated">동등한 &lt;a href=&quot;#ParameterStorageClass&quot;&gt; &lt;code&gt;ParameterStorageClass&lt;/code&gt; &lt;/a&gt; &lt;code&gt;enum&lt;/code&gt; 의 비트 단위 OR입니다 .</target>
        </trans-unit>
        <trans-unit id="4fdcc0b7027ad4b488f80691f340dd0dc77ff487" translate="yes" xml:space="preserve">
          <source>The block statement form is:</source>
          <target state="translated">블록 설명 양식은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="dd4bbefc576334b8b13692b8e44bc6ee98e6f364" translate="yes" xml:space="preserve">
          <source>The body of the</source>
          <target state="translated">몸</target>
        </trans-unit>
        <trans-unit id="96cd6fd8f2e0864106740818ab2710f9f6ce82f8" translate="yes" xml:space="preserve">
          <source>The body of the constructor is executed.</source>
          <target state="translated">생성자의 본문이 실행됩니다.</target>
        </trans-unit>
        <trans-unit id="6863a629a6b6532a62dd2be0fcf0c83cbe0ecc4b" translate="yes" xml:space="preserve">
          <source>The bool type is a byte-size type that can only hold the value &lt;code&gt;true&lt;/code&gt; or &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">bool 유형은 &lt;code&gt;true&lt;/code&gt; 또는 &lt;code&gt;false&lt;/code&gt; 값만 보유 할 수있는 바이트 크기 유형입니다 .</target>
        </trans-unit>
        <trans-unit id="595a315b8710f1cdf54c5c5a89b18ff6fdc7c01a" translate="yes" xml:space="preserve">
          <source>The bound being violated</source>
          <target state="translated">위반되는 경계</target>
        </trans-unit>
        <trans-unit id="58bf9949e91d1f67475ea8dd8dc1479acb9a7b6c" translate="yes" xml:space="preserve">
          <source>The buffer to store decoded result.</source>
          <target state="translated">디코딩 된 결과를 저장할 버퍼입니다.</target>
        </trans-unit>
        <trans-unit id="cbd8e18ccd6c72e47f49142b87596eb0b37a2753" translate="yes" xml:space="preserve">
          <source>The buffer to write to</source>
          <target state="translated">쓸 버퍼</target>
        </trans-unit>
        <trans-unit id="d4158bf50efe732ca75d7c0746df60cf6a107caa" translate="yes" xml:space="preserve">
          <source>The built in properties &lt;code&gt;.sizeof&lt;/code&gt;, &lt;code&gt;.alignof&lt;/code&gt;, and &lt;code&gt;.mangleof&lt;/code&gt; may not be declared as fields or methods in structs, unions, classes or enums.</source>
          <target state="translated">내장 속성 &lt;code&gt;.sizeof&lt;/code&gt; , &lt;code&gt;.alignof&lt;/code&gt; 및 &lt;code&gt;.mangleof&lt;/code&gt; 는 구조체, 공용체, 클래스 또는 열거 형의 필드 또는 메서드로 선언 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="cb37eb5828bb8f76b215ba701695af10297cc319" translate="yes" xml:space="preserve">
          <source>The built-in address-of operator (unary &lt;code&gt;&amp;amp;&lt;/code&gt;) may only be applied to lvalues.</source>
          <target state="translated">기본 제공 주소 연산자 (단항 &lt;code&gt;&amp;amp;&lt;/code&gt; )는 lvalue에만 적용 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="01d529a280bedf8d2329f923f87f28d6d2414970" translate="yes" xml:space="preserve">
          <source>The built-in char types are any of &lt;code&gt;char&lt;/code&gt;, &lt;code&gt;wchar&lt;/code&gt; or &lt;code&gt;dchar&lt;/code&gt;, with or without qualifiers.</source>
          <target state="translated">내장 문자 유형은 규정자가 있거나없는 &lt;code&gt;char&lt;/code&gt; , &lt;code&gt;wchar&lt;/code&gt; 또는 &lt;code&gt;dchar&lt;/code&gt; 중 하나입니다.</target>
        </trans-unit>
        <trans-unit id="26447929ba19118cb6719911318de883e533656a" translate="yes" xml:space="preserve">
          <source>The built-in string types are &lt;code&gt;Char[]&lt;/code&gt;, where &lt;code&gt;Char&lt;/code&gt; is any of &lt;code&gt;char&lt;/code&gt;, &lt;code&gt;wchar&lt;/code&gt; or &lt;code&gt;dchar&lt;/code&gt;, with or without qualifiers.</source>
          <target state="translated">내장 문자열 유형은 &lt;code&gt;Char[]&lt;/code&gt; 이며, 여기서 &lt;code&gt;Char&lt;/code&gt; 는 한정자가 있거나없는 &lt;code&gt;char&lt;/code&gt; , &lt;code&gt;wchar&lt;/code&gt; 또는 &lt;code&gt;dchar&lt;/code&gt; 중 하나입니다.</target>
        </trans-unit>
        <trans-unit id="985d41f10ebe09bea42e87e43e676a34b5b701c9" translate="yes" xml:space="preserve">
          <source>The call &lt;code&gt;gapWeightedSimilarity(s, t, 1)&lt;/code&gt; simply counts all of these matches and adds them up, returning 7.</source>
          <target state="translated">&lt;code&gt;gapWeightedSimilarity(s, t, 1)&lt;/code&gt; 호출은 단순히 이러한 모든 일치 항목을 계산하고 합산하여 7을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="9504202f5ac0a1e1b308309ee50027e163c8c607" translate="yes" xml:space="preserve">
          <source>The call above eliminated the gapped matches (&lt;code&gt;&quot;Hello&quot;, &quot;new&quot;&lt;/code&gt;), (&lt;code&gt;&quot;Hello&quot;, &quot;world&quot;&lt;/code&gt;), and (&lt;code&gt;&quot;Hello&quot;, &quot;new&quot;, &quot;world&quot;&lt;/code&gt;) from the tally. That leaves only 4 matches.</source>
          <target state="translated">위의 호출은 집계에서 일치하지 않는 일치 항목 ( &lt;code&gt;&quot;Hello&quot;, &quot;new&quot;&lt;/code&gt; ), &lt;code&gt;&quot;Hello&quot;, &quot;world&quot;&lt;/code&gt; ) 및 ( &lt;code&gt;&quot;Hello&quot;, &quot;new&quot;, &quot;world&quot;&lt;/code&gt; )를 제거했습니다. 그것은 4 경기 만 남습니다.</target>
        </trans-unit>
        <trans-unit id="a0a65d3fa68c14100a930ea8ba7a95c4b2425c75" translate="yes" xml:space="preserve">
          <source>The call to &lt;code&gt;func()&lt;/code&gt; is ambiguous because Foo.func and Bar.func are in different scopes.</source>
          <target state="translated">Foo.func와 Bar.func의 범위가 다르기 때문에 &lt;code&gt;func()&lt;/code&gt; 호출 이 모호합니다.</target>
        </trans-unit>
        <trans-unit id="e538f3dd7f1bdd1b474917678b37be623289cdfe" translate="yes" xml:space="preserve">
          <source>The call will duplicate the array appropriately.  Note that checking for uniqueness during compilation is possible in certain cases, especially when a function is marked as a pure function. The following example does not need to call assumeUnique because the compiler can infer the uniqueness of the array in the pure function:</source>
          <target state="translated">호출은 배열을 적절히 복제합니다. 컴파일 중 고유성을 검사하는 것은 특정 경우, 특히 함수가 순수한 함수로 표시 될 때 가능합니다. 컴파일러가 순수 함수에서 배열의 고유성을 유추 할 수 있으므로 다음 예제에서는 assumeUnique를 호출 할 필요가 없습니다.</target>
        </trans-unit>
        <trans-unit id="242f08d2b1a1a758366f7a48d7e4dad847e662cb" translate="yes" xml:space="preserve">
          <source>The callable that is called when a handled primitive throws a &lt;code&gt;Throwable&lt;/code&gt; of type &lt;code&gt;E&lt;/code&gt;. The handler must accept arguments of the form &lt;code&gt;E, ref IRange&lt;/code&gt; and its return value is used as the primitive's return value whenever &lt;code&gt;E&lt;/code&gt; is thrown. For &lt;code&gt;opIndex&lt;/code&gt;, the handler can optionally recieve a third argument; the index that caused the exception.</source>
          <target state="translated">처리 된 기본 요소가 &lt;code&gt;E&lt;/code&gt; 유형 의 &lt;code&gt;Throwable&lt;/code&gt; 을 던질 때 호출되는 콜 러블 . 핸들러는 &lt;code&gt;E, ref IRange&lt;/code&gt; 형식의 인수를 허용해야하며 &lt;code&gt;E&lt;/code&gt; 가 발생할 때마다 해당 리턴 값이 기본 요소의 리턴 값으로 사용됩니다 . 들면 &lt;code&gt;opIndex&lt;/code&gt; 핸들러는 임의로 번째 인수를받을 수있다; 예외의 원인이 된 인덱스</target>
        </trans-unit>
        <trans-unit id="8595a4fb5e8942c865e60e579f4bc97ae9361768" translate="yes" xml:space="preserve">
          <source>The callable to apply on create.</source>
          <target state="translated">작성시 적용 할 호출 가능.</target>
        </trans-unit>
        <trans-unit id="9e7cb4c784340dbcc9223bb09fc5bd0008d15a78" translate="yes" xml:space="preserve">
          <source>The callable to apply on update.</source>
          <target state="translated">업데이트시 적용 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="47f8d3d3341c2f3859f008d663d7d39abed383a3" translate="yes" xml:space="preserve">
          <source>The callback returns the incoming bytes read. If not the entire array is the request will abort. The special value .pauseRequest can be returned in order to pause the current request.</source>
          <target state="translated">콜백은 읽은 수신 바이트를 반환합니다. 전체 배열이 아닌 경우 요청이 중단됩니다. 현재 요청을 일시 정지하기 위해 특수 값 .pauseRequest를 리턴 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7ff970a770b2ff7a8a51d3f9664a81966555d9c0" translate="yes" xml:space="preserve">
          <source>The callback returns the incoming bytes read. If not the entire array is the request will abort. The special value HTTP.pauseRequest can be returned in order to pause the current request.</source>
          <target state="translated">콜백은 읽은 수신 바이트를 반환합니다. 전체 배열이 아닌 경우 요청이 중단됩니다. 현재 요청을 일시 정지하기 위해 특수 값 HTTP.pauseRequest를 리턴 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8e149c07dded4d56d5080da41c572390f4d5c4e3" translate="yes" xml:space="preserve">
          <source>The callback returns the number of elements in the buffer that have been filled and are ready to send. The special value &lt;code&gt;.abortRequest&lt;/code&gt; can be returned in order to abort the current request. The special value &lt;code&gt;.pauseRequest&lt;/code&gt; can be returned in order to pause the current request.</source>
          <target state="translated">콜백은 버퍼에 채워져 보낼 준비가 된 요소 수를 반환합니다. 현재 요청을 중단하기 위해 특수 값 &lt;code&gt;.abortRequest&lt;/code&gt; 를 리턴 할 수 있습니다. 현재 요청을 일시 정지하기 위해 특수 값 &lt;code&gt;.pauseRequest&lt;/code&gt; 를 리턴 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2137ada3ae84929eb868bf721851f3520aa621f8" translate="yes" xml:space="preserve">
          <source>The callback returns the number of elements in the buffer that have been filled and are ready to send. The special value &lt;code&gt;Curl.abortRequest&lt;/code&gt; can be returned in order to abort the current request. The special value &lt;code&gt;Curl.pauseRequest&lt;/code&gt; can be returned in order to pause the current request.</source>
          <target state="translated">콜백은 버퍼에 채워져 보낼 준비가 된 요소 수를 반환합니다. 현재 요청을 중단하기 위해 &lt;code&gt;Curl.abortRequest&lt;/code&gt; 특수 값을 리턴 할 수 있습니다. 현재 요청을 일시 정지하기 위해 특수 값 &lt;code&gt;Curl.pauseRequest&lt;/code&gt; 를 리턴 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="559652851d8e835ca6e4e25200037a9b2b88d7e9" translate="yes" xml:space="preserve">
          <source>The callback returns the success state of the seeking &lt;a href=&quot;etc_c_curl#CurlSeek&quot;&gt;&lt;code&gt;etc.c.curl.CurlSeek&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">콜백은 탐색 등의 성공 상태를 반환합니다 &lt;a href=&quot;etc_c_curl#CurlSeek&quot;&gt; &lt;code&gt;etc.c.curl.CurlSeek&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="4f77b46c5f5f6357c24d9647b815993a85d323b8" translate="yes" xml:space="preserve">
          <source>The callback should return zero.</source>
          <target state="translated">콜백은 0을 반환해야합니다.</target>
        </trans-unit>
        <trans-unit id="bf29eeac01c5a4dd86a6df695ab4b58778a8d6c6" translate="yes" xml:space="preserve">
          <source>The callback will receive a header field key, value as parameter. The &lt;code&gt;const(char)[]&lt;/code&gt; arrays are not valid after the delegate has returned.</source>
          <target state="translated">콜백은 헤더 필드 키, 값을 매개 변수로받습니다. &lt;code&gt;const(char)[]&lt;/code&gt; 대리자가 리턴 한 후 어레이는 유효하지 않다.</target>
        </trans-unit>
        <trans-unit id="0479a0d5e5b9b6df459258bae677881c90ce0ee0" translate="yes" xml:space="preserve">
          <source>The callee cleans the stack.</source>
          <target state="translated">수신자가 스택을 청소합니다.</target>
        </trans-unit>
        <trans-unit id="969d6b1248484a0e1ba90ba5ae45f38dfe225ca5" translate="yes" xml:space="preserve">
          <source>The caller guarantees that there are no other live pointers to the passed memory block, still it might not be freed immediately by &lt;code&gt;realloc&lt;/code&gt;. The garbage collector can reclaim the memory block in a later collection if it is unused. If allocation fails, this function will throw an &lt;code&gt;OutOfMemoryError&lt;/code&gt;.</source>
          <target state="translated">호출자는 전달 된 메모리 블록에 대한 다른 라이브 포인터가 없음을 보장하지만 여전히 &lt;code&gt;realloc&lt;/code&gt; 에 의해 즉시 해제되지 않을 수 있습니다 . 가비지 수집기는 메모리 블록이 사용되지 않는 경우 이후 컬렉션에서 메모리 블록을 회수 할 수 있습니다. 할당이 실패하면이 함수는 &lt;code&gt;OutOfMemoryError&lt;/code&gt; 를 발생 시킵니다.</target>
        </trans-unit>
        <trans-unit id="42c8382f8ef7fb6520cb3687eb152b34b852d9fc" translate="yes" xml:space="preserve">
          <source>The caller is expected to clean the stack. &lt;code&gt;_argptr&lt;/code&gt; is not passed, it is computed by the callee.</source>
          <target state="translated">호출자는 스택을 청소해야합니다. &lt;code&gt;_argptr&lt;/code&gt; 은 전달되지 않으며, 수신자가 계산합니다.</target>
        </trans-unit>
        <trans-unit id="71f4f46b73c55f9c109f0c80b9ef8abbb104d1fb" translate="yes" xml:space="preserve">
          <source>The calling thread must be attached to the runtime.</source>
          <target state="translated">호출 스레드는 런타임에 연결되어야합니다.</target>
        </trans-unit>
        <trans-unit id="958f07aa30dc8c63baec5ad6b7a6ab8de498d71d" translate="yes" xml:space="preserve">
          <source>The canonical name is returned in &lt;code&gt;canonicalName&lt;/code&gt; member in the first &lt;code&gt;AddressInfo&lt;/code&gt;.</source>
          <target state="translated">표준 이름은 첫 번째 &lt;code&gt;AddressInfo&lt;/code&gt; 의 &lt;code&gt;canonicalName&lt;/code&gt; 멤버에 리턴됩니다 .</target>
        </trans-unit>
        <trans-unit id="5578f20f728ef7ea894f9c8485dc8375879fa1eb" translate="yes" xml:space="preserve">
          <source>The capacity of a slice may be impacted by operations on other slices.</source>
          <target state="translated">슬라이스의 용량은 다른 슬라이스의 작업에 영향을받을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="107b78d2e608ef92e8a7f001aab1e580890d2636" translate="yes" xml:space="preserve">
          <source>The capitalized string.</source>
          <target state="translated">대문자 문자열</target>
        </trans-unit>
        <trans-unit id="a02d900e092203fe7acb10d7253e6c7295d71b57" translate="yes" xml:space="preserve">
          <source>The case expressions cannot evaluate to a run time initialized value.</source>
          <target state="translated">케이스 표현식은 런타임 초기화 값으로 평가할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="c660de992148409122dcd32983da08c9290b863c" translate="yes" xml:space="preserve">
          <source>The case expressions must all evaluate to a constant value or array, or a runtime initialized const or immutable variable of integral type. They must be implicitly convertible to the type of the switch &lt;a href=&quot;expression#Expression&quot;&gt;&lt;i&gt;Expression&lt;/i&gt;&lt;/a&gt;.</source>
          <target state="translated">대소 문자 표현식은 모두 상수 값 또는 배열 또는 런타임으로 초기화 된 const 또는 정수 유형의 불변 변수로 평가되어야합니다. 스위치 &lt;a href=&quot;expression#Expression&quot;&gt;&lt;i&gt;Expression&lt;/i&gt;&lt;/a&gt; 형식으로 암시 적으로 변환 할 수 있어야합니다 .</target>
        </trans-unit>
        <trans-unit id="5f4e6b9553e729310217386d882aa9d464ad3e08" translate="yes" xml:space="preserve">
          <source>The case expressions, &lt;a href=&quot;expression#ArgumentList&quot;&gt;&lt;i&gt;ArgumentList&lt;/i&gt;&lt;/a&gt;, are a comma separated list of expressions.</source>
          <target state="translated">대소 문자 표현식 &lt;a href=&quot;expression#ArgumentList&quot;&gt;&lt;i&gt;ArgumentList&lt;/i&gt;&lt;/a&gt; 는 쉼표로 구분 된 표현식 목록입니다.</target>
        </trans-unit>
        <trans-unit id="5c065923e841d97029a1a1a23e3c446aaf97b033" translate="yes" xml:space="preserve">
          <source>The character that terminates a line</source>
          <target state="translated">줄을 끝내는 문자</target>
        </trans-unit>
        <trans-unit id="629001ed0c4dadc576ebea811f98cc1aed6e90df" translate="yes" xml:space="preserve">
          <source>The character to represent a comma in the specification</source>
          <target state="translated">사양에서 쉼표를 나타내는 문자</target>
        </trans-unit>
        <trans-unit id="ec12026df227efabbda621551d1564e02d496853" translate="yes" xml:space="preserve">
          <source>The character to represent a quote in the specification</source>
          <target state="translated">사양에서 인용을 나타내는 문자</target>
        </trans-unit>
        <trans-unit id="ed980b4c59776662298660727d4c9f56b2f99259" translate="yes" xml:space="preserve">
          <source>The character to test.</source>
          <target state="translated">테스트 할 캐릭터입니다.</target>
        </trans-unit>
        <trans-unit id="f806bb97e00ae2a4d1965414bf699f20536e139e" translate="yes" xml:space="preserve">
          <source>The character to use for filling excess space in the field</source>
          <target state="translated">필드에서 여분의 공간을 채우는 데 사용할 문자</target>
        </trans-unit>
        <trans-unit id="7954bf846b49b756c8f7adbc1f7bb59d31d8fe0f" translate="yes" xml:space="preserve">
          <source>The character-based range to be split. Must be a string, or a random-access range of character types.</source>
          <target state="translated">분할 할 문자 기반 범위입니다. 문자열이거나 임의 액세스 범위의 문자 유형이어야합니다.</target>
        </trans-unit>
        <trans-unit id="da430ad7582915a68166d7b59e0099addfd5c754" translate="yes" xml:space="preserve">
          <source>The characters to remove from the string.</source>
          <target state="translated">문자열에서 제거 할 문자입니다.</target>
        </trans-unit>
        <trans-unit id="0bc92faf6490d5bb1265aa7a3286ff3cc0386eb8" translate="yes" xml:space="preserve">
          <source>The characters to replace with.</source>
          <target state="translated">바꿀 문자입니다.</target>
        </trans-unit>
        <trans-unit id="b24b1e6a036609d0af960c16ec68d51a3e145307" translate="yes" xml:space="preserve">
          <source>The characters to replace.</source>
          <target state="translated">바꿀 문자입니다.</target>
        </trans-unit>
        <trans-unit id="da530bf40507c33ab0ce7b6f55c2e0bfe50af65c" translate="yes" xml:space="preserve">
          <source>The choice of the normalization form depends on the particular use case. NFC is the best form for general text, since it's more compatible with strings converted from legacy encodings. NFKC is the preferred form for identifiers, especially where there are security concerns. NFD and NFKD are the most useful for internal processing.</source>
          <target state="translated">정규화 양식의 선택은 특정 사용 사례에 따라 다릅니다. NFC는 레거시 인코딩에서 변환 된 문자열과 더 호환되므로 일반 텍스트에 가장 적합한 형식입니다. NFKC는 특히 보안 문제가있는 경우 선호되는 식별자 형식입니다. NFD 및 NFKD는 내부 처리에 가장 유용합니다.</target>
        </trans-unit>
        <trans-unit id="f5c734e10fd22e90551eca30f40d587d99f0c42a" translate="yes" xml:space="preserve">
          <source>The class allocator is not called if the instance is created on the stack.</source>
          <target state="translated">인스턴스가 스택에서 작성되면 클래스 할당자가 호출되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="888d63439c91bbcddad644e4c7db9438fc2745dc" translate="yes" xml:space="preserve">
          <source>The class declaration this belongs to.</source>
          <target state="translated">이것에 속하는 클래스 선언.</target>
        </trans-unit>
        <trans-unit id="9821e074c45da0757bbe913fb06d396a19d66ece" translate="yes" xml:space="preserve">
          <source>The class definition:</source>
          <target state="translated">클래스 정의 :</target>
        </trans-unit>
        <trans-unit id="6cd8612310d940ff26e5edb5b4fcdb1ec41c2ab8" translate="yes" xml:space="preserve">
          <source>The class destructor will be called when the result of &lt;code&gt;scoped()&lt;/code&gt; is itself destroyed.</source>
          <target state="translated">&lt;code&gt;scoped()&lt;/code&gt; 결과 자체가 소멸 되면 클래스 소멸자가 호출됩니다 .</target>
        </trans-unit>
        <trans-unit id="c93c7a1d79db5f0e6fcfb2d97ac7ab27199857e4" translate="yes" xml:space="preserve">
          <source>The code above is equivalent to:</source>
          <target state="translated">위의 코드는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="5b07f3ff2ae08c1115f9318187e98dfad8b61d12" translate="yes" xml:space="preserve">
          <source>The code below defines a scalable allocator consisting of 1 MB (or larger) blocks fetched from the garbage-collected heap. Each block is organized as a KR-style heap. More blocks are allocated and freed on a need basis.  This is the closest example to the allocator introduced in the K&amp;amp;R book. It should perform slightly better because instead of searching through one large free list, it searches through several shorter lists in LRU order. Also, it actually returns memory to the operating system when possible.</source>
          <target state="translated">아래 코드는 가비지 수집 힙에서 가져온 1MB 이상의 블록으로 구성된 확장 가능 할당자를 정의합니다. 각 블록은 KR 스타일 힙으로 구성됩니다. 더 많은 블록이 필요에 따라 할당되고 해제됩니다. 이것은 K &amp;amp; R 책에서 소개 된 할당 자에 가장 가까운 예입니다. 하나의 큰 사용 가능한 목록을 검색하는 대신 LRU 순서로 여러 개의 짧은 목록을 검색하므로 약간 더 성능이 좋아야합니다. 또한 가능한 경우 실제로 운영 체제로 메모리를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="12ac0fdde9cbd45bcf0987afae5cbf0bd1ef3d0f" translate="yes" xml:space="preserve">
          <source>The code example below shows a simple implementation of a 2-dimensional array with overloaded indexing and slicing operators. The explanations of the various constructs employed are given in the sections following.</source>
          <target state="translated">아래 코드 예제는 오버로드 된 인덱싱 및 슬라이싱 연산자를 사용하여 2 차원 배열의 간단한 구현을 보여줍니다. 사용 된 다양한 구성에 대한 설명은 다음 섹션에 있습니다.</target>
        </trans-unit>
        <trans-unit id="0ef6a79ff5d24e866faf6946cbbd2a6330b8fc2c" translate="yes" xml:space="preserve">
          <source>The code generated by these three functions is identical. To indicate that these can be one function, the inout type constructor is employed:</source>
          <target state="translated">이 세 가지 기능으로 생성 된 코드는 동일합니다. 이것이 하나의 함수가 될 수 있음을 나타 내기 위해 inout 유형 생성자가 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="a7b0bdcbeba131b0b10ad17da0e5e625fbde9d3f" translate="yes" xml:space="preserve">
          <source>The code in the invariant may not call any public non-static members of the class or struct, either directly or indirectly. Doing so will result in a stack overflow, as the invariant will wind up being called in an infinitely recursive manner.</source>
          <target state="translated">불변의 코드는 직간접 적으로 클래스 또는 구조체의 정적이 아닌 공용 멤버를 호출 할 수 없습니다. 이렇게하면 고정 재귀적인 방식으로 불변 값이 호출되므로 스택 오버플로가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="5567d3893a01342e1a0bc105518655a6faaaab38" translate="yes" xml:space="preserve">
          <source>The code that detects an error knows more about the error than the code that must recover from the error.</source>
          <target state="translated">오류를 감지하는 코드는 오류에서 복구해야하는 코드보다 오류에 대해 더 많이 알고 있습니다.</target>
        </trans-unit>
        <trans-unit id="820bb6ee9e6aba52c669ddd54299d0ca78f94c71" translate="yes" xml:space="preserve">
          <source>The code to implement this API is not available in the public release of SQLite.</source>
          <target state="translated">이 API를 구현하는 코드는 SQLite의 공개 릴리스에서 사용할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="0b173c608e91ac1dd9ab1e2ebbf859ba8dcba5c7" translate="yes" xml:space="preserve">
          <source>The comment form must match the D language comments.</source>
          <target state="translated">주석 양식은 D 언어 주석과 일치해야합니다.</target>
        </trans-unit>
        <trans-unit id="c27e68ae34b416356827d090284f419f63369dc7" translate="yes" xml:space="preserve">
          <source>The communication domain used to resolve an address.</source>
          <target state="translated">주소를 확인하는 데 사용되는 통신 도메인</target>
        </trans-unit>
        <trans-unit id="a8ad0e630b8b0da66aee6c7edb8a63daad73619d" translate="yes" xml:space="preserve">
          <source>The comparison predicate</source>
          <target state="translated">비교 술어</target>
        </trans-unit>
        <trans-unit id="8236e0769cfa2f3f369ae0002ca893f3e532ba5d" translate="yes" xml:space="preserve">
          <source>The comparison to use.</source>
          <target state="translated">사용할 비교입니다.</target>
        </trans-unit>
        <trans-unit id="5dabbbc6b85984f7c631dd31a40e4692958581a7" translate="yes" xml:space="preserve">
          <source>The comparison value.</source>
          <target state="translated">비교 값.</target>
        </trans-unit>
        <trans-unit id="1884ff0398391fb51645ddf67a895753f5f23bb8" translate="yes" xml:space="preserve">
          <source>The compile time length of &lt;code&gt;arr&lt;/code&gt; if it's known.</source>
          <target state="translated">알려진 경우 &lt;code&gt;arr&lt;/code&gt; 의 컴파일 시간 길이입니다 .</target>
        </trans-unit>
        <trans-unit id="20e21ca3ed0c66cb684853be4c9050ce61bc28b7" translate="yes" xml:space="preserve">
          <source>The compiler is free to assume the assert expression is true and optimize subsequent code accordingly.</source>
          <target state="translated">컴파일러는 어설 션 표현식이 참이라고 가정하고 그에 따라 후속 코드를 최적화합니다.</target>
        </trans-unit>
        <trans-unit id="7c2be101920c07dfed2a3b2ae4e783a017a150b5" translate="yes" xml:space="preserve">
          <source>The compiler lowers expressions of &lt;code&gt;cast(TTo[])TFrom[]&lt;/code&gt; to this implementation.</source>
          <target state="translated">컴파일러는 &lt;code&gt;cast(TTo[])TFrom[]&lt;/code&gt; 표현식 을이 구현으로 낮 춥니 다 .</target>
        </trans-unit>
        <trans-unit id="3119e558dc9b76ce9fd8e624bacd61cca8100ec6" translate="yes" xml:space="preserve">
          <source>The compiler makes the decision whether to inline a function or not. This decision may be controlled by &lt;a href=&quot;pragma#inline&quot;&gt;&lt;code&gt;pragma(inline)&lt;/code&gt;&lt;/a&gt;, assuming that the compiler implements it, which is not mandatory.</source>
          <target state="translated">컴파일러는 함수를 인라인할지 여부를 결정합니다. 이 결정은 컴파일러가이를 구현한다고 가정하고 &lt;a href=&quot;pragma#inline&quot;&gt; &lt;code&gt;pragma(inline)&lt;/code&gt; &lt;/a&gt; 의해 제어 될 수 있습니다 ( 필수 아님).</target>
        </trans-unit>
        <trans-unit id="291025563ce73c7bc11eafe0442e20ca4b9ab725" translate="yes" xml:space="preserve">
          <source>The compiler performs the following checks to enforce the correct usage of the &lt;code&gt;@selector&lt;/code&gt; attribute:</source>
          <target state="translated">컴파일러는 다음과 같은 검사를 수행하여 &lt;code&gt;@selector&lt;/code&gt; 속성을 올바르게 사용 합니다.</target>
        </trans-unit>
        <trans-unit id="634747431ffe30a4862ec872dad71a6eb253993f" translate="yes" xml:space="preserve">
          <source>The compiler will not give an error if the hidden function is disjoint, as far as overloading is concerned, from all the other virtual functions is the inheritance hierarchy.</source>
          <target state="translated">오버로드와 관련하여 숨겨진 함수가 분리되어 있으면 다른 모든 가상 함수에서 상속 계층 구조가 컴파일러에서 오류를 발생시키지 않습니다.</target>
        </trans-unit>
        <trans-unit id="7e55718066f0afe8bf9a0cce63044c7450d60879" translate="yes" xml:space="preserve">
          <source>The compiler will then know to use the symbols from std.datetime.stopwatch rather than the deprecated ones from std.datetime.package.</source>
          <target state="translated">그러면 컴파일러는 더 이상 사용되지 않는 std.datetime.package가 아닌 std.datetime.stopwatch의 기호를 사용하는 것을 알게됩니다.</target>
        </trans-unit>
        <trans-unit id="473d434a9b1e1fa3c3fa95983b0cf370022ebc41" translate="yes" xml:space="preserve">
          <source>The complex conjugate of &lt;code&gt;z&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;z&lt;/code&gt; 의 켤레 복소수입니다 .</target>
        </trans-unit>
        <trans-unit id="0c3998eac6614ebf21d49abc1e3b482249568f18" translate="yes" xml:space="preserve">
          <source>The complex number with the given modulus and argument.</source>
          <target state="translated">주어진 계수와 인수가있는 복소수입니다.</target>
        </trans-unit>
        <trans-unit id="ffd55f19d01437a4948ba1ff58d0011690958c82" translate="yes" xml:space="preserve">
          <source>The concepts of &lt;a href=&quot;#Canonical%20equivalent&quot;&gt;canonical equivalent&lt;/a&gt; or &lt;a href=&quot;#Compatibility%20equivalent&quot;&gt;compatibility equivalent&lt;/a&gt; characters in the Unicode Standard make it necessary to have a full, formal definition of equivalence for Unicode strings. String equivalence is determined by a process called normalization, whereby strings are converted into forms which are compared directly for identity. This is the primary goal of the normalization process, see the function &lt;a href=&quot;#normalize&quot;&gt;&lt;code&gt;normalize&lt;/code&gt;&lt;/a&gt; to convert into any of the four defined forms.</source>
          <target state="translated">유니 코드 표준에서 &lt;a href=&quot;#Canonical%20equivalent&quot;&gt;정식 등가&lt;/a&gt; 또는 &lt;a href=&quot;#Compatibility%20equivalent&quot;&gt;호환성 등가&lt;/a&gt; 문자 의 개념은 유니 코드 문자열에 대한 등가의 완전하고 공식적인 정의가 필요합니다. 문자열 동등성은 정규화라고하는 프로세스에 의해 결정되며, 이로 인해 문자열은 식별을 위해 직접 비교되는 형식으로 변환됩니다. 이것이 정규화 프로세스의 주요 목표입니다. 함수가 &lt;a href=&quot;#normalize&quot;&gt; &lt;code&gt;normalize&lt;/code&gt; &lt;/a&gt; 네 가지 형식 중 하나로 변환을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="2abedb352be4b4cad8d77bc09501301df20a32a4" translate="yes" xml:space="preserve">
          <source>The condition is satisfied if</source>
          <target state="translated">조건이 충족되면</target>
        </trans-unit>
        <trans-unit id="2f916d19cc4604e724f8fa53e2900b77b6ea76e6" translate="yes" xml:space="preserve">
          <source>The condition is satisfied if &lt;code&gt;Type&lt;/code&gt; is semantically correct (it must be syntactically correct regardless).</source>
          <target state="translated">&lt;code&gt;Type&lt;/code&gt; 이 의미 적으로 올바른 경우 조건이 충족됩니다 (구문 적으로 구문에 상관없이).</target>
        </trans-unit>
        <trans-unit id="e653b278fd905a7f3ea022f157c287cd4a9f01c9" translate="yes" xml:space="preserve">
          <source>The condition module provides a primitive for synchronized condition checking.</source>
          <target state="translated">조건 모듈은 동기화 된 조건 확인을위한 기본 요소를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="6ccd24f12a395f85abd20793c28ab1014d198ff2" translate="yes" xml:space="preserve">
          <source>The condition must be &lt;code&gt;true&lt;/code&gt; for the data to be logged.</source>
          <target state="translated">데이터가 기록 되려면 조건이 &lt;code&gt;true&lt;/code&gt; 여야합니다 .</target>
        </trans-unit>
        <trans-unit id="7f67746204d06208bb04d7be048bff0edfd1312d" translate="yes" xml:space="preserve">
          <source>The conditions for the two-range case are as follows:</source>
          <target state="translated">두 가지 범위의 조건은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="9db8141e8da442e0a29cf9a7252671c3c3646d9b" translate="yes" xml:space="preserve">
          <source>The config module contains utility routines and configuration information specific to this package.</source>
          <target state="translated">구성 모듈에는이 패키지와 관련된 유틸리티 루틴 및 구성 정보가 포함되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="25247015a813aa1799daef3d9f06262e98658698" translate="yes" xml:space="preserve">
          <source>The connection to use e.g. HTTP or FTP.</source>
          <target state="translated">HTTP 또는 FTP와 같은 연결.</target>
        </trans-unit>
        <trans-unit id="150a6335aad7ff29ac857e269ddb2bcb66d82956" translate="yes" xml:space="preserve">
          <source>The constructed &lt;code&gt;to&lt;/code&gt;</source>
          <target state="translated">구축 된 &lt;code&gt;to&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="76163a15ff5da4a6811b7d818ac307640ccf574e" translate="yes" xml:space="preserve">
          <source>The constructor does not initialize the attributes. To initialize the attributes, you access the &lt;b&gt;attr&lt;/b&gt; member variable.</source>
          <target state="translated">생성자는 속성을 초기화하지 않습니다. 속성을 초기화하려면 &lt;b&gt;attr&lt;/b&gt; 멤버 변수에 액세스하십시오 .</target>
        </trans-unit>
        <trans-unit id="bca7fb1c9668c6b5381caf14aec377df51a6a261" translate="yes" xml:space="preserve">
          <source>The constructor leaves the digest in an initialized state, so that this method only needs to be called if an unfinished digest is to be reused.</source>
          <target state="translated">생성자는 다이제스트를 초기화 된 상태로 유지하므로 완료되지 않은 다이제스트를 다시 사용해야하는 경우에만이 메소드를 호출하면됩니다.</target>
        </trans-unit>
        <trans-unit id="70a470b379ed3334099897b9dc79f34ba48d24b6" translate="yes" xml:space="preserve">
          <source>The content length in bytes of the ftp data.</source>
          <target state="translated">ftp 데이터의 컨텐츠 길이 (바이트)입니다.</target>
        </trans-unit>
        <trans-unit id="d2356d15b14610202018dcbb7e4c8229b54b1b8a" translate="yes" xml:space="preserve">
          <source>The content length in bytes when using request that has content e.g. POST/PUT and not using chunked transfer. Is set as the &quot;Content-Length&quot; header. Set to ulong.max to reset to chunked transfer.</source>
          <target state="translated">POST / PUT과 같이 콘텐츠가 있고 청크 전송을 사용하지 않는 요청을 사용할 때 콘텐츠 길이 (바이트)입니다. &quot;Content-Length&quot;헤더로 설정됩니다. 청크 전송으로 재설정하려면 ulong.max로 설정하십시오.</target>
        </trans-unit>
        <trans-unit id="c5718211c764df7e99cb685b897ebad52a7de67a" translate="yes" xml:space="preserve">
          <source>The content of &lt;code&gt;buffer&lt;/code&gt; is reused across calls. In the example above, &lt;code&gt;buffer.length&lt;/code&gt; is 4096 for all iterations, except for the last one, in which case &lt;code&gt;buffer.length&lt;/code&gt; may be less than 4096 (but always greater than zero).  In case of an I/O error, an &lt;code&gt;StdioException&lt;/code&gt; is thrown.</source>
          <target state="translated">&lt;code&gt;buffer&lt;/code&gt; 의 내용은 모든 호출에서 재사용됩니다. 위의 예에서 &lt;code&gt;buffer.length&lt;/code&gt; 는 마지막 반복을 제외하고 모든 반복에 대해 4096입니다.이 경우 &lt;code&gt;buffer.length&lt;/code&gt; 는 4096보다 작을 수 있지만 항상 0보다 큽니다. I / O 오류 가 발생 하면 &lt;code&gt;StdioException&lt;/code&gt; 이 발생합니다.</target>
        </trans-unit>
        <trans-unit id="2138553c63d001080b141495fda74a55a8794df5" translate="yes" xml:space="preserve">
          <source>The content of an environment variable</source>
          <target state="translated">환경 변수의 내용</target>
        </trans-unit>
        <trans-unit id="5e9be2c8175e2abe02a707a8002878697ac86dfd" translate="yes" xml:space="preserve">
          <source>The contents of strings and comments are not tokenized. Consequently, comment openings occurring within a string do not begin a comment, and string delimiters within a comment do not affect the recognition of comment closings and nested &lt;code&gt;/+&lt;/code&gt; comment openings. With the exception of &lt;code&gt;/+&lt;/code&gt; occurring within a &lt;code&gt;/+&lt;/code&gt; comment, comment openings within a comment are ignored.</source>
          <target state="translated">문자열과 주석의 내용은 토큰 화되지 않습니다. 결과적으로 문자열 내에서 발생하는 주석 열기는 주석을 시작하지 않으며 주석 내의 문자열 분리 문자는 주석 닫기 및 중첩 된 &lt;code&gt;/+&lt;/code&gt; 주석 열기 의 인식에 영향을 미치지 않습니다 . &lt;code&gt;/+&lt;/code&gt; 주석 내에서 발생하는 &lt;code&gt;/+&lt;/code&gt; 를 제외 하고 주석 내 주석 열기는 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="acc47ba92e60a8eb6a7f0995cfd09e1266cb2c0b" translate="yes" xml:space="preserve">
          <source>The convenient digest template allows for quick hashing of any data.</source>
          <target state="translated">편리한 다이제스트 템플릿을 사용하면 모든 데이터를 빠르게 해싱 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9df1871b1d5b6cf09ccc48d6467fcecce1d269f6" translate="yes" xml:space="preserve">
          <source>The converted associative array initializer or ErrorExp if &lt;code&gt;ai&lt;/code&gt; is not an associative array initializer.</source>
          <target state="translated">변환 된 연관 배열 이니셜 라이저 또는 &lt;code&gt;ai&lt;/code&gt; 가 연관 배열 이니셜 라이저가 아닌 경우 ErrorExp</target>
        </trans-unit>
        <trans-unit id="f43effea59b8beccdd892ba167ecb555ed8c79da" translate="yes" xml:space="preserve">
          <source>The copy constructor can be overloaded with different qualifiers applied to the parameter (copying from a qualified source) or to the copy constructor itself (copying to a qualified destination):</source>
          <target state="translated">복사 생성자는 매개 변수 (적격 한 소스에서 복사) 또는 복사 생성자 자체 (적격 대상으로 복사)에 적용된 다른 규정 자로 과부하 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="190d6795cdd5f40388f14ac3afa87aeffbee0f68" translate="yes" xml:space="preserve">
          <source>The copy constructor is type checked as a normal constructor.</source>
          <target state="translated">복사 생성자는 일반 생성자로 유형 검사됩니다.</target>
        </trans-unit>
        <trans-unit id="8ce4fd58f0ef3f442e38a96e86e12b71ac036747" translate="yes" xml:space="preserve">
          <source>The corresponding argument is formatted in a manner consistent with its type:</source>
          <target state="translated">해당 인수는 형식과 일치하는 방식으로 형식이 지정됩니다.</target>
        </trans-unit>
        <trans-unit id="48e51bdf1a95a79ac6426f7eff677cbb11ecae43" translate="yes" xml:space="preserve">
          <source>The corresponding argument must be a character type.</source>
          <target state="translated">해당 인수는 문자 유형이어야합니다.</target>
        </trans-unit>
        <trans-unit id="0274ce33cba3929bfbdf7475c2fd6fc9d51d564e" translate="yes" xml:space="preserve">
          <source>The corresponding argument must be an integral type and is formatted as an integer. If the argument is a signed type and the</source>
          <target state="translated">해당 인수는 정수 유형이어야하며 정수 형식입니다. 인수가 부호있는 유형이고</target>
        </trans-unit>
        <trans-unit id="0178a031a9f0514977acc39575ef4aaa0e2662a0" translate="yes" xml:space="preserve">
          <source>The corresponding lowercase letter, if &lt;code&gt;c&lt;/code&gt; is an uppercase ASCII character, otherwise &lt;code&gt;c&lt;/code&gt; itself.</source>
          <target state="translated">&lt;code&gt;c&lt;/code&gt; 가 대문자 ASCII 문자 이면 해당 소문자 , 그렇지 않으면 &lt;code&gt;c&lt;/code&gt; 자체</target>
        </trans-unit>
        <trans-unit id="69cee4c45eeccc903fcf47055f5f19036cae6663" translate="yes" xml:space="preserve">
          <source>The corresponding unsigned numeric type for &lt;code&gt;T&lt;/code&gt; with the same type qualifiers.  If &lt;code&gt;T&lt;/code&gt; is not a integral or vector, a compile-time error is given.</source>
          <target state="translated">형식 한정자가 동일한 &lt;code&gt;T&lt;/code&gt; 에 해당하는 부호없는 숫자 형식입니다 . &lt;code&gt;T&lt;/code&gt; 가 정수 또는 벡터가 아닌 경우 컴파일 타임 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="65ac2725a8076a2b686ff66848f84c573dbad022" translate="yes" xml:space="preserve">
          <source>The corresponding uppercase letter, if &lt;code&gt;c&lt;/code&gt; is a lowercase ASCII character, otherwise &lt;code&gt;c&lt;/code&gt; itself.</source>
          <target state="translated">&lt;code&gt;c&lt;/code&gt; 가 소문자 ASCII 문자 이면 해당 대문자 , 그렇지 않으면 &lt;code&gt;c&lt;/code&gt; 자체</target>
        </trans-unit>
        <trans-unit id="c9ce88bd48ff277e4bfb8bb20fde5641ab64da29" translate="yes" xml:space="preserve">
          <source>The coverage callback.</source>
          <target state="translated">적용 범위 콜백</target>
        </trans-unit>
        <trans-unit id="fe4e5d3b2725d57149f74ea4401dddd72e356025" translate="yes" xml:space="preserve">
          <source>The created GC instance or &lt;code&gt;null&lt;/code&gt; if no factory for that name was registered</source>
          <target state="translated">생성 된 GC 인스턴스 또는 &lt;code&gt;null&lt;/code&gt; 해당 이름의 팩토리가 등록되지 않은 경우</target>
        </trans-unit>
        <trans-unit id="25c75bcefa05f1c507f7f1fc6ff9cd42539bbd75" translate="yes" xml:space="preserve">
          <source>The curl_easy_pause function pauses or unpauses transfers. Select the new state by setting the bitmask, use the convenience defines below.</source>
          <target state="translated">curl_easy_pause 함수는 전송을 일시 정지 또는 일시 정지 해제합니다. 비트 마스크를 설정하여 새 상태를 선택하고 아래 정의 된 편의를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="153bfd2d6b2d30ac140c40feedadba5366f389ef" translate="yes" xml:space="preserve">
          <source>The curl_easy_strerror function may be used to turn a CURLcode value into the equivalent human readable error string. This is useful for printing meaningful error messages.</source>
          <target state="translated">curl_easy_strerror 함수는 CURLcode 값을 사람이 읽을 수있는 동등한 오류 문자열로 변환하는 데 사용될 수 있습니다. 의미있는 오류 메시지를 인쇄 할 때 유용합니다.</target>
        </trans-unit>
        <trans-unit id="e7d8cb9ade20ed61c82c1a60ebe359477845f192" translate="yes" xml:space="preserve">
          <source>The curl_multi_strerror function may be used to turn a CURLMcode value into the equivalent human readable error string. This is useful for printing meaningful error messages.</source>
          <target state="translated">curl_multi_strerror 함수는 CURLMcode 값을 사람이 읽을 수있는 동등한 오류 문자열로 변환하는 데 사용될 수 있습니다. 의미있는 오류 메시지를 인쇄 할 때 유용합니다.</target>
        </trans-unit>
        <trans-unit id="8ac8c7edec906e82e20cff95e57160d4c2ae8742" translate="yes" xml:space="preserve">
          <source>The curl_share_strerror function may be used to turn a CURLSHcode value into the equivalent human readable error string. This is useful for printing meaningful error messages.</source>
          <target state="translated">curl_share_strerror 함수는 CURLSHcode 값을 사람이 읽을 수있는 동등한 오류 문자열로 변환하는 데 사용될 수 있습니다. 의미있는 오류 메시지를 인쇄 할 때 유용합니다.</target>
        </trans-unit>
        <trans-unit id="12b95a210f2fd732ae6323a477ee3db950ce1e48" translate="yes" xml:space="preserve">
          <source>The current capacity of this &lt;code&gt;SocketSet&lt;/code&gt;. The exact meaning of the return value varies from platform to platform.</source>
          <target state="translated">이 &lt;code&gt;SocketSet&lt;/code&gt; 의 현재 용량 . 반환 값의 정확한 의미는 플랫폼마다 다릅니다.</target>
        </trans-unit>
        <trans-unit id="b7e8d20bcf3e91b443f49906cb7f9c26202d7b33" translate="yes" xml:space="preserve">
          <source>The current chunk of encoded data.</source>
          <target state="translated">인코딩 된 데이터의 현재 청크</target>
        </trans-unit>
        <trans-unit id="5f09ff18e0bf3e3a50451c990acfd44da2f4d0cf" translate="yes" xml:space="preserve">
          <source>The current collect handler or null if none has been set.</source>
          <target state="translated">현재의 수집 핸들러. 설정되어 있지 않은 경우는 null</target>
        </trans-unit>
        <trans-unit id="ff00e2ec15ad157fa0acd49db009126af4219c9c" translate="yes" xml:space="preserve">
          <source>The current day of the week.</source>
          <target state="translated">요일.</target>
        </trans-unit>
        <trans-unit id="5445bb4bc1730b9d0cce5b36844644b773e9edcb" translate="yes" xml:space="preserve">
          <source>The current decoded byte.</source>
          <target state="translated">현재 디코딩 된 바이트입니다.</target>
        </trans-unit>
        <trans-unit id="d4f2882db12d78c2fc4e970047ad93065891fe53" translate="yes" xml:space="preserve">
          <source>The current directory for the parent process.</source>
          <target state="translated">상위 프로세스의 현재 디렉토리</target>
        </trans-unit>
        <trans-unit id="62615ccff9de65abffb1ae1e70b58ec0562e8494" translate="yes" xml:space="preserve">
          <source>The current encoded character.</source>
          <target state="translated">현재 인코딩 된 문자입니다.</target>
        </trans-unit>
        <trans-unit id="2bcc037a390d8689344ebfd625c83c159bbdaa3a" translate="yes" xml:space="preserve">
          <source>The current implementation is contained in and defined by &lt;a href=&quot;https://github.com/dlang/druntime/blob/master/src/rt/aaA.d&quot;&gt;rt/aaA.d&lt;/a&gt;.</source>
          <target state="translated">현재 구현은 &lt;a href=&quot;https://github.com/dlang/druntime/blob/master/src/rt/aaA.d&quot;&gt;rt / aaA.d&lt;/a&gt; 에 포함되어 정의되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="135564ffafda532e35fa0b7d48812ffee033cd42" translate="yes" xml:space="preserve">
          <source>The current implementation is optimized for little endian architectures. It will exhibit different results on big endian architectures and a slightly less uniform distribution.</source>
          <target state="translated">현재 구현은 리틀 엔디안 아키텍처에 최적화되어 있습니다. 빅 엔디안 아키텍처와 약간 덜 균일 한 분포에서 다른 결과를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="8b386bdee0746666a56a36200a693020a21530e4" translate="yes" xml:space="preserve">
          <source>The current legacy module unit tester handler or null if none has been set.</source>
          <target state="translated">현재 레거시 모듈 단위 테스터 핸들러 또는 설정되지 않은 경우 null입니다.</target>
        </trans-unit>
        <trans-unit id="8ef65e94b9168b0ff7203f6b263d0e8b2bd6eeac" translate="yes" xml:space="preserve">
          <source>The current module unit tester handler or null if none has been set.</source>
          <target state="translated">현재의 모듈 유닛 테스터 핸들러. 설정되어 있지 않은 경우는 null</target>
        </trans-unit>
        <trans-unit id="6f8938955ef3df10335744a73b91094b9fffec70" translate="yes" xml:space="preserve">
          <source>The current month of the year.</source>
          <target state="translated">올해의 현재 달.</target>
        </trans-unit>
        <trans-unit id="67943f85151903b71f2ef45fecfce18f374500bf" translate="yes" xml:space="preserve">
          <source>The current system tick. The number of ticks per second varies from system to system. &lt;code&gt;currSystemTick&lt;/code&gt; uses a monotonic clock, so it's intended for precision timing by comparing relative time values, not for getting the current system time.</source>
          <target state="translated">현재 시스템 틱. 초당 틱 수는 시스템마다 다릅니다. &lt;code&gt;currSystemTick&lt;/code&gt; 은 모노 토닉 클록을 사용하므로 현재 시스템 시간을 얻는 것이 아니라 상대 시간 값을 비교하여 정밀한 타이밍을 위해 고안되었습니다.</target>
        </trans-unit>
        <trans-unit id="222a86bbae85929301dc215f9e9c008965d24955" translate="yes" xml:space="preserve">
          <source>The current time of the system's monotonic clock. This has no relation to the wall clock time, as the wall clock time can be adjusted (e.g. by NTP), whereas the monotonic clock always moves forward. The source of the monotonic time is system-specific.</source>
          <target state="translated">시스템의 단조로운 시계의 현재 시간입니다. 벽시계 시간은 (예를 들어 NTP에 의해) 조정될 수있는 반면, 단조로운 시계는 항상 앞으로 이동하기 때문에 이것은 벽시계 시간과 관련이 없다. 단조로운 시간의 근원은 시스템에 따라 다릅니다.</target>
        </trans-unit>
        <trans-unit id="6d131b2d67d2e2d0708dd4d35e46ff7bb470d695" translate="yes" xml:space="preserve">
          <source>The current time zone of this &lt;a href=&quot;#SysTime&quot;&gt;&lt;code&gt;SysTime&lt;/code&gt;&lt;/a&gt;. It's internal time is always kept in UTC, so there are no conversion issues between time zones due to DST. Functions which return all or part of the time - such as hours - adjust the time to this &lt;a href=&quot;#SysTime&quot;&gt;&lt;code&gt;SysTime&lt;/code&gt;&lt;/a&gt;'s time zone before returning.</source>
          <target state="translated">이것의 현재 시간대 &lt;a href=&quot;#SysTime&quot;&gt; &lt;code&gt;SysTime&lt;/code&gt; &lt;/a&gt; . 내부 시간은 항상 UTC로 유지되므로 DST로 인해 시간대간에 변환 문제가 없습니다. 시간과 같이 시간의 일부 또는 전부를 반환하는 함수는 반환하기 &lt;a href=&quot;#SysTime&quot;&gt; &lt;code&gt;SysTime&lt;/code&gt; &lt;/a&gt; 표준 시간대로 시간을 조정합니다 .</target>
        </trans-unit>
        <trans-unit id="92e4138ca0558ee1a8d76b41157b476bc178803c" translate="yes" xml:space="preserve">
          <source>The current time zone of this &lt;a href=&quot;#SysTime&quot;&gt;&lt;code&gt;SysTime&lt;/code&gt;&lt;/a&gt;. Its internal time is always kept in UTC, so there are no conversion issues between time zones due to DST. Functions which return all or part of the time - such as hours - adjust the time to this &lt;a href=&quot;#SysTime&quot;&gt;&lt;code&gt;SysTime&lt;/code&gt;&lt;/a&gt;'s time zone before returning.</source>
          <target state="translated">이것의 현재 시간대 &lt;a href=&quot;#SysTime&quot;&gt; &lt;code&gt;SysTime&lt;/code&gt; &lt;/a&gt; . 내부 시간은 항상 UTC로 유지되므로 DST로 인해 시간대간에 변환 문제가 없습니다. 시간과 같이 시간의 일부 또는 전부를 반환하는 함수는 반환하기 &lt;a href=&quot;#SysTime&quot;&gt; &lt;code&gt;SysTime&lt;/code&gt; &lt;/a&gt; 표준 시간대로 시간을 조정합니다 .</target>
        </trans-unit>
        <trans-unit id="73b94772e416a8ec2451e84a4f045bcf0b0bd2f8" translate="yes" xml:space="preserve">
          <source>The current trace handler or null if none has been set.</source>
          <target state="translated">현재의 트레이스 핸들러. 설정되어 있지 않은 경우는 null</target>
        </trans-unit>
        <trans-unit id="1168fa07ec5310179d0a7d8dd293fdee5d851995" translate="yes" xml:space="preserve">
          <source>The current version is MurmurHash3, which yields a 32-bit or 128-bit hash value. The older MurmurHash 1 and 2 are currently not supported.</source>
          <target state="translated">현재 버전은 MurmurHash3이며 32 비트 또는 128 비트 해시 값을 생성합니다. 이전 MurmurHash 1 및 2는 현재 지원되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="f46d4edbe0670620eb95290f8f2a6487face97bc" translate="yes" xml:space="preserve">
          <source>The data caches. If there are fewer than 5 physical caches levels, the remaining levels are set to size_t.max (== entire memory space)</source>
          <target state="translated">데이터 캐시 실제 캐시 레벨이 5 미만인 경우 나머지 레벨은 size_t.max (== 전체 메모리 공간)로 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="a6ef57ac8d9ec9aa6eaa6d13ed88211ab558ef56" translate="yes" xml:space="preserve">
          <source>The data is NOT copied by the library. Content-Type will default to application/octet-stream. Data is not converted or encoded by this method.</source>
          <target state="translated">라이브러리는 데이터를 복사하지 않습니다. Content-Type은 기본적으로 application / octet-stream이됩니다. 이 방법으로 데이터를 변환하거나 인코딩하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="6bcbd37c2c2ac85eb1356e64319455a6bd36b26b" translate="yes" xml:space="preserve">
          <source>The data is NOT copied by the library. Content-Type will default to text/plain. Data is not converted or encoded by this method.</source>
          <target state="translated">라이브러리는 데이터를 복사하지 않습니다. Content-Type은 기본적으로 text / plain으로 설정됩니다. 이 방법으로 데이터를 변환하거나 인코딩하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="cce9ef674e018900e5c73c744a07e56499cc18a7" translate="yes" xml:space="preserve">
          <source>The data is always shareable across threads. Even if the data is &lt;code&gt;const&lt;/code&gt;, the affix is modifiable by the same reasoning as for &lt;code&gt;immutable&lt;/code&gt;.</source>
          <target state="translated">데이터는 항상 스레드간에 공유 할 수 있습니다. 데이터가 &lt;code&gt;const&lt;/code&gt; 인 경우에도 &lt;code&gt;immutable&lt;/code&gt; 경우와 동일한 추론으로 접미사를 수정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="493973138a3d3f979064d5411c98ae5301a703dd" translate="yes" xml:space="preserve">
          <source>The data that is to be logged.</source>
          <target state="translated">기록 될 데이터.</target>
        </trans-unit>
        <trans-unit id="ca2344350b8df2bdd7d03df57b987d64c46b085c" translate="yes" xml:space="preserve">
          <source>The data that should be logged.</source>
          <target state="translated">기록해야 할 데이터.</target>
        </trans-unit>
        <trans-unit id="78b3f17895b8c6a1ec55d26a5815c6b3e2f691ad" translate="yes" xml:space="preserve">
          <source>The database disk image is malformed</source>
          <target state="translated">데이터베이스 디스크 이미지가 잘못되었습니다</target>
        </trans-unit>
        <trans-unit id="99b3c2c49461425bf6cff4391127f75d483d0614" translate="yes" xml:space="preserve">
          <source>The database file is locked</source>
          <target state="translated">데이터베이스 파일이 잠겨 있습니다</target>
        </trans-unit>
        <trans-unit id="5e44b1ae3d4ce260d0b6e54dfe79b9e83c8a047e" translate="yes" xml:space="preserve">
          <source>The database schema changed</source>
          <target state="translated">데이터베이스 스키마가 변경되었습니다.</target>
        </trans-unit>
        <trans-unit id="8c85f90f34182d4804f085ae127ba5dcaa363aac" translate="yes" xml:space="preserve">
          <source>The date portion of &lt;a href=&quot;#DateTime&quot;&gt;&lt;code&gt;DateTime&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#DateTime&quot;&gt; &lt;code&gt;DateTime&lt;/code&gt; &lt;/a&gt; 의 날짜 부분입니다 .</target>
        </trans-unit>
        <trans-unit id="afe331c3b8358f5c9f6aa03d6d996e549edd7dd9" translate="yes" xml:space="preserve">
          <source>The day of the Gregorian Calendar to set this &lt;a href=&quot;#Date&quot;&gt;&lt;code&gt;Date&lt;/code&gt;&lt;/a&gt; to.</source>
          <target state="translated">이 &lt;a href=&quot;#Date&quot;&gt; &lt;code&gt;Date&lt;/code&gt; &lt;/a&gt; 를 설정할 그레고리력 일입니다 .</target>
        </trans-unit>
        <trans-unit id="4ae0c452a064fb3ca47b7a7c9701724ac4dce1ca" translate="yes" xml:space="preserve">
          <source>The day of the Gregorian Calendar to set this &lt;a href=&quot;#DateTime&quot;&gt;&lt;code&gt;DateTime&lt;/code&gt;&lt;/a&gt; to.</source>
          <target state="translated">이 &lt;a href=&quot;#DateTime&quot;&gt; &lt;code&gt;DateTime&lt;/code&gt; &lt;/a&gt; 을 설정할 그레고리력의 요일입니다 .</target>
        </trans-unit>
        <trans-unit id="bd19a7c8e8386d921c721461757d18c3618278c9" translate="yes" xml:space="preserve">
          <source>The day of the Gregorian Calendar to set this &lt;a href=&quot;#SysTime&quot;&gt;&lt;code&gt;SysTime&lt;/code&gt;&lt;/a&gt; to.</source>
          <target state="translated">이 &lt;a href=&quot;#SysTime&quot;&gt; &lt;code&gt;SysTime&lt;/code&gt; &lt;/a&gt; 을 설정하는 그레고리력 일입니다 .</target>
        </trans-unit>
        <trans-unit id="0b0bd119a12bf4f397ebf472b36184d281c6821c" translate="yes" xml:space="preserve">
          <source>The day of the month to set this &lt;a href=&quot;#Date&quot;&gt;&lt;code&gt;Date&lt;/code&gt;&lt;/a&gt;'s day to.</source>
          <target state="translated">이 &lt;a href=&quot;#Date&quot;&gt; &lt;code&gt;Date&lt;/code&gt; &lt;/a&gt; 를 설정할 날짜 입니다.</target>
        </trans-unit>
        <trans-unit id="5240ff1dc8c3d7350efab2ccc0dcbc8c48902add" translate="yes" xml:space="preserve">
          <source>The day of the month to set this &lt;a href=&quot;#DateTime&quot;&gt;&lt;code&gt;DateTime&lt;/code&gt;&lt;/a&gt;'s day to.</source>
          <target state="translated">이 &lt;a href=&quot;#DateTime&quot;&gt; &lt;code&gt;DateTime&lt;/code&gt; &lt;/a&gt; 의 요일을 설정하는 달 입니다.</target>
        </trans-unit>
        <trans-unit id="54dc94925cf86835f631cdafa18de7d7060f146b" translate="yes" xml:space="preserve">
          <source>The day of the month to set this &lt;a href=&quot;#SysTime&quot;&gt;&lt;code&gt;SysTime&lt;/code&gt;&lt;/a&gt;'s day to.</source>
          <target state="translated">이 &lt;a href=&quot;#SysTime&quot;&gt; &lt;code&gt;SysTime&lt;/code&gt; &lt;/a&gt; 의 요일을 설정할 요일입니다.</target>
        </trans-unit>
        <trans-unit id="f06065ad9961deec3076217123d1f3724a43ad9e" translate="yes" xml:space="preserve">
          <source>The day of the week is ignored beyond verifying that it's a valid day of the week, as the day of the week can be inferred from the date. It is not checked whether the given day of the week matches the actual day of the week of the given date (though it is technically invalid per the spec if the day of the week doesn't match the actual day of the week of the given date).</source>
          <target state="translated">요일은 날짜로부터 유추 될 수 있으므로 유효한 요일임을 확인하는 것 외에는 무시됩니다. 주어진 요일이 주어진 날짜의 실제 요일과 일치하는지 여부는 확인되지 않습니다 (요일이 주어진 요일과 일치하지 않으면 스펙에 따라 기술적으로 유효하지 않습니다). 데이트).</target>
        </trans-unit>
        <trans-unit id="5e854e19e24462bd8df16bbd3e656946dc758006" translate="yes" xml:space="preserve">
          <source>The day of the week to get the number of days to.</source>
          <target state="translated">일 수를 얻는 요일입니다.</target>
        </trans-unit>
        <trans-unit id="9b2b14b5c754fd8843dde38b4959242869b20add" translate="yes" xml:space="preserve">
          <source>The day of the year to set which day of the year this &lt;a href=&quot;#Date&quot;&gt;&lt;code&gt;Date&lt;/code&gt;&lt;/a&gt; is on.</source>
          <target state="translated">이 &lt;a href=&quot;#Date&quot;&gt; &lt;code&gt;Date&lt;/code&gt; &lt;/a&gt; 가있는 날짜 를 설정하기위한 날짜 입니다.</target>
        </trans-unit>
        <trans-unit id="ccf6b0017db205f1a9b8b83cdf38246cf64f3b0f" translate="yes" xml:space="preserve">
          <source>The day of the year to set which day of the year this &lt;a href=&quot;#DateTime&quot;&gt;&lt;code&gt;DateTime&lt;/code&gt;&lt;/a&gt; is on.</source>
          <target state="translated">이 &lt;a href=&quot;#DateTime&quot;&gt; &lt;code&gt;DateTime&lt;/code&gt; &lt;/a&gt; 이 켜져 있는 날짜를 설정하는 날짜입니다 .</target>
        </trans-unit>
        <trans-unit id="8dcb327ec830e9013bbcabf4579c3b122dd13db5" translate="yes" xml:space="preserve">
          <source>The day of the year to set which day of the year this &lt;a href=&quot;#SysTime&quot;&gt;&lt;code&gt;SysTime&lt;/code&gt;&lt;/a&gt; is on.</source>
          <target state="translated">이 &lt;a href=&quot;#SysTime&quot;&gt; &lt;code&gt;SysTime&lt;/code&gt; &lt;/a&gt; 이 작동 하는 날짜를 설정하는 날짜입니다 .</target>
        </trans-unit>
        <trans-unit id="1ca7f565ccafa6d910e84ff93887a8b0d0bb5eea" translate="yes" xml:space="preserve">
          <source>The day portion of the date.</source>
          <target state="translated">날짜의 일 부분.</target>
        </trans-unit>
        <trans-unit id="5ad71e8507c7301863c1c60659bd8b3c6b7f0dc6" translate="yes" xml:space="preserve">
          <source>The day to validate.</source>
          <target state="translated">검증 할 요일입니다.</target>
        </trans-unit>
        <trans-unit id="99ff0048fa491b367eccc6b67cb9b69f2ad2defa" translate="yes" xml:space="preserve">
          <source>The decimal value to convert into the factorial number system.</source>
          <target state="translated">계승 시스템으로 변환 할 10 진수 값입니다.</target>
        </trans-unit>
        <trans-unit id="112d499aea5e8fc601570782799d1151e557b4de" translate="yes" xml:space="preserve">
          <source>The declarations in a mixin are placed in a nested scope and then &amp;lsquo;imported&amp;rsquo; into the surrounding scope. If the name of a declaration in a mixin is the same as a declaration in the surrounding scope, the surrounding declaration overrides the mixin one:</source>
          <target state="translated">믹스 인의 선언은 중첩 범위에 배치 된 다음 주변 범위로 '가져 오기'됩니다. 믹스 인의 선언 이름이 주변 범위의 선언과 동일하면 주변 선언이 믹스 인을 재정의합니다.</target>
        </trans-unit>
        <trans-unit id="1c2cdcf3cf79afdc906fde394e5c2b865521f41b" translate="yes" xml:space="preserve">
          <source>The decoded string</source>
          <target state="translated">디코딩 된 문자열</target>
        </trans-unit>
        <trans-unit id="945488b25e8ef473c0f2b20f9c6b8b8c99511eb5" translate="yes" xml:space="preserve">
          <source>The decoding of the current element in the input.</source>
          <target state="translated">입력에서 현재 요소의 디코딩</target>
        </trans-unit>
        <trans-unit id="4f67de430c432c552831b7793db0a2c0326b2d16" translate="yes" xml:space="preserve">
          <source>The deduced type parameter for dynamic array and pointer arguments has an unqualified head:</source>
          <target state="translated">동적 배열 및 포인터 인수에 대한 추론 된 유형 매개 변수에는 규정되지 않은 헤드가 있습니다.</target>
        </trans-unit>
        <trans-unit id="dc7258b7cd7137907e6fca7bf0fc234fc2e2ce18" translate="yes" xml:space="preserve">
          <source>The default &quot;User-Agent&quot; value send with a request. It has the form &quot;Phobos-std.net.curl/</source>
          <target state="translated">기본 &quot;User-Agent&quot;값은 요청과 함께 보냅니다. &quot;Phobos-std.net.curl / 형식입니다.</target>
        </trans-unit>
        <trans-unit id="7a46984a3f96d58aec5d4d9868c2110f34d995ba" translate="yes" xml:space="preserve">
          <source>The default (or most common) setting for the current platform. That is, &lt;code&gt;no&lt;/code&gt; on Windows and Mac OS X, and &lt;code&gt;yes&lt;/code&gt; on all POSIX systems except OS X (Linux, *BSD, etc.).</source>
          <target state="translated">현재 플랫폼의 기본 (또는 가장 일반적인) 설정입니다. 즉,하지 &lt;code&gt;no&lt;/code&gt; Windows 및 Mac OS X, 그리고에 &lt;code&gt;yes&lt;/code&gt; OS X (리눅스, * BSD 등)를 제외한 모든 POSIX 시스템에서.</target>
        </trans-unit>
        <trans-unit id="87b0a2695d56ceaeb7eb9433e1d06841db861c10" translate="yes" xml:space="preserve">
          <source>The default &lt;code&gt;Logger&lt;/code&gt; will by default log to &lt;code&gt;stderr&lt;/code&gt; and has a default &lt;code&gt;LogLevel&lt;/code&gt; of &lt;code&gt;LogLevel.all&lt;/code&gt;. The default Logger can be accessed by using the property called &lt;code&gt;sharedLog&lt;/code&gt;. This property is a reference to the current default &lt;code&gt;Logger&lt;/code&gt;. This reference can be used to assign a new default &lt;code&gt;Logger&lt;/code&gt;.</source>
          <target state="translated">기본 &lt;code&gt;Logger&lt;/code&gt; 는 기본적으로 &lt;code&gt;stderr&lt;/code&gt; 에 로그 하며 기본 &lt;code&gt;LogLevel&lt;/code&gt; 은 &lt;code&gt;LogLevel.all&lt;/code&gt; 입니다. &lt;code&gt;sharedLog&lt;/code&gt; 라는 속성을 사용하여 기본 로거에 액세스 할 수 있습니다 . 이 속성은 현재 기본 &lt;code&gt;Logger&lt;/code&gt; 대한 참조 입니다. 이 참조는 새로운 기본 &lt;code&gt;Logger&lt;/code&gt; 를 할당하는 데 사용될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="b72f9c3623b76d776ddcc9d314e5ca75b551f9a9" translate="yes" xml:space="preserve">
          <source>The default &lt;code&gt;alignedReallocate&lt;/code&gt; function first attempts to use &lt;code&gt;expand&lt;/code&gt;. If &lt;code&gt;Allocator.expand&lt;/code&gt; is not defined or returns &lt;code&gt;false&lt;/code&gt;, &lt;code&gt;alignedReallocate&lt;/code&gt; allocates a new block of memory of appropriate size and copies data from the old block to the new block. Finally, if &lt;code&gt;Allocator&lt;/code&gt; defines &lt;code&gt;deallocate&lt;/code&gt;, &lt;code&gt;alignedReallocate&lt;/code&gt; uses it to free the old memory block.</source>
          <target state="translated">기본 &lt;code&gt;alignedReallocate&lt;/code&gt; 함수는 먼저 &lt;code&gt;expand&lt;/code&gt; 사용을 시도합니다 . &lt;code&gt;Allocator.expand&lt;/code&gt; 가 정의되지 않았거나 &lt;code&gt;false&lt;/code&gt; 를 반환하는 경우 , &lt;code&gt;alignedReallocate&lt;/code&gt; 할당 새로운 블록 이전 블록에서 적절한 크기 및 사본 데이터 메모리의 새로운 블록. 마지막으로 &lt;code&gt;Allocator&lt;/code&gt; 가 &lt;code&gt;deallocate&lt;/code&gt; 를 정의 하면 &lt;code&gt;alignedReallocate&lt;/code&gt; 는 할당을 사용하여 이전 메모리 블록을 해제합니다.</target>
        </trans-unit>
        <trans-unit id="11d5f052dd46a2986ac861f2bb2c8694b1113749" translate="yes" xml:space="preserve">
          <source>The default &lt;code&gt;reallocate&lt;/code&gt; function first attempts to use &lt;code&gt;expand&lt;/code&gt;. If &lt;code&gt;Allocator.expand&lt;/code&gt; is not defined or returns &lt;code&gt;false&lt;/code&gt;, &lt;code&gt;reallocate&lt;/code&gt; allocates a new block of memory of appropriate size and copies data from the old block to the new block. Finally, if &lt;code&gt;Allocator&lt;/code&gt; defines &lt;code&gt;deallocate&lt;/code&gt;, &lt;code&gt;reallocate&lt;/code&gt; uses it to free the old memory block.</source>
          <target state="translated">기본 &lt;code&gt;reallocate&lt;/code&gt; 기능은 먼저 &lt;code&gt;expand&lt;/code&gt; 사용을 시도합니다 . 경우 &lt;code&gt;Allocator.expand&lt;/code&gt; 이 정의되거나 반환되지 않은 &lt;code&gt;false&lt;/code&gt; , &lt;code&gt;reallocate&lt;/code&gt; 할당 새로운 블록 이전 블록에서 적절한 크기와 데이터를 복사 메모리의 새로운 블록. 마지막으로 &lt;code&gt;Allocator&lt;/code&gt; 가 &lt;code&gt;deallocate&lt;/code&gt; 를 정의 하면 &lt;code&gt;reallocate&lt;/code&gt; 는이를 사용하여 이전 메모리 블록을 해제합니다.</target>
        </trans-unit>
        <trans-unit id="b4b278f4d2972020f4ba9b115cb1013b58d050b9" translate="yes" xml:space="preserve">
          <source>The default alignment is &lt;code&gt;platformAlignment&lt;/code&gt;.</source>
          <target state="translated">기본 정렬은 &lt;code&gt;platformAlignment&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="86db8edf378862e012fa8f8fcf58a7d5108946ce" translate="yes" xml:space="preserve">
          <source>The default allocator.</source>
          <target state="translated">기본 할당 자.</target>
        </trans-unit>
        <trans-unit id="84034aca41f128da43b408ac2e8f9758bed62159" translate="yes" xml:space="preserve">
          <source>The default constructor for the &lt;code&gt;NullLogger&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;NullLogger&lt;/code&gt; 의 기본 생성자입니다 .</target>
        </trans-unit>
        <trans-unit id="60dfda69676fc480f5f6faa42faf083636619c98" translate="yes" xml:space="preserve">
          <source>The default constructor for the &lt;code&gt;StdForwardLogger&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;StdForwardLogger&lt;/code&gt; 의 기본 생성자입니다 .</target>
        </trans-unit>
        <trans-unit id="44546e235ac407a00aa0d819574df31ac96d3e13" translate="yes" xml:space="preserve">
          <source>The default directory where the TZ Database files are stored. It's empty for Windows, since Windows doesn't have them. You can also use the TZDatabaseDir version to pass an arbitrary path at compile-time, rather than hard-coding it here. Android concatenates all time zone data into a single file called tzdata and stores it in the directory below.</source>
          <target state="translated">TZ 데이터베이스 파일이 저장되는 기본 디렉토리입니다. Windows에는 Windows가 없으므로 비어 있습니다. TZDatabaseDir 버전을 사용하여 여기에서 하드 코딩하는 대신 컴파일 타임에 임의의 경로를 전달할 수도 있습니다. Android는 모든 시간대 데이터를 tzdata라는 단일 파일로 연결하여 아래 디렉토리에 저장합니다.</target>
        </trans-unit>
        <trans-unit id="8df16f51964aeebfe4bc3a051bf58dca3ecbc7ca" translate="yes" xml:space="preserve">
          <source>The default extension to use.</source>
          <target state="translated">사용할 기본 확장명입니다.</target>
        </trans-unit>
        <trans-unit id="85ad9abd95b264167c92cdc2a1adee2b573ef599" translate="yes" xml:space="preserve">
          <source>The default good size allocation is deduced as &lt;code&gt;n&lt;/code&gt; rounded up to the allocator's alignment.</source>
          <target state="translated">기본 양호한 크기 할당은 &lt;code&gt;n&lt;/code&gt; 으로 추론됩니다. 이 할당 자의 정렬로 반올림 .</target>
        </trans-unit>
        <trans-unit id="1b0fe911bc214b516e59012b05dd0e28695378c4" translate="yes" xml:space="preserve">
          <source>The default initializer is evaluated at compile time.</source>
          <target state="translated">기본 이니셜 라이저는 컴파일 타임에 평가됩니다.</target>
        </trans-unit>
        <trans-unit id="09875c3ec3c0432a38d2825c4ab0b5b1b8a97473" translate="yes" xml:space="preserve">
          <source>The default initializers are evaluated at compile time.</source>
          <target state="translated">기본 이니셜 라이저는 컴파일 타임에 평가됩니다.</target>
        </trans-unit>
        <trans-unit id="b315cb15ffa0ca81f8d98d7b66d415e4aa5dc1b4" translate="yes" xml:space="preserve">
          <source>The default initializers may not contain references to mutable data.</source>
          <target state="translated">기본 이니셜 라이저는 변경 가능한 데이터에 대한 참조를 포함하지 않을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="198b7d1107c41684b20ca53736c0025d3ab9b73c" translate="yes" xml:space="preserve">
          <source>The default inline behavior is typically selectable with a compiler switch such as &lt;a href=&quot;https://dlang.org/dmd.html#switch-inline&quot;&gt;&lt;em&gt;-inline&lt;/em&gt;.&lt;/a&gt;</source>
          <target state="translated">기본 인라인 동작은 일반적으로 &lt;a href=&quot;https://dlang.org/dmd.html#switch-inline&quot;&gt;&lt;em&gt;-inline&lt;/em&gt;&lt;/a&gt; 과 같은 컴파일러 스위치로 &lt;em&gt;선택할 수&lt;/em&gt; 있습니다.</target>
        </trans-unit>
        <trans-unit id="d4be45be08a1c8c22dbb96c12305596159d25e0b" translate="yes" xml:space="preserve">
          <source>The default layout of the fields of a struct is an exact match with the</source>
          <target state="translated">구조체 필드의 기본 레이아웃은</target>
        </trans-unit>
        <trans-unit id="2f337be32b3aefecfcb4859e625057b7bd434d30" translate="yes" xml:space="preserve">
          <source>The default linkage for member functions of COM classes is &lt;code&gt;extern(System)&lt;/code&gt;.  Note that if you want to implement or override any base-class methods of D interfaces or classes (ones which do not inherit from &lt;code&gt;IUnknown&lt;/code&gt;), you have to explicitly mark them as having the &lt;code&gt;extern(D)&lt;/code&gt; linkage:</source>
          <target state="translated">COM 클래스의 멤버 함수에 대한 기본 연결은 &lt;code&gt;extern(System)&lt;/code&gt; 입니다. D 인터페이스 또는 클래스의 기본 클래스 메소드 ( &lt;code&gt;IUnknown&lt;/code&gt; 에서 상속되지 않은 메소드)를 구현하거나 대체 하려면 &lt;code&gt;extern(D)&lt;/code&gt; 가있는 것으로 명시 적으로 표시해야합니다. 링크 .</target>
        </trans-unit>
        <trans-unit id="7f4262f95c707a983226fca6d9fb6bf885e79c8c" translate="yes" xml:space="preserve">
          <source>The default namespaces (&lt;a href=&quot;#dnsNamespace&quot;&gt;&lt;code&gt;dnsNamespace&lt;/code&gt;&lt;/a&gt;, ...) defined by this module should be used when appropriate.</source>
          <target state="translated">기본 네임 스페이스 ( &lt;a href=&quot;#dnsNamespace&quot;&gt; &lt;code&gt;dnsNamespace&lt;/code&gt; &lt;/a&gt;이 모듈에서 정의한 , ...)는 필요할 때 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="c2f98d39df30add62dee5880988c4ddc9def3c49" translate="yes" xml:space="preserve">
          <source>The default scheduling priority that is set for a thread. On systems where multiple scheduling policies are defined, this value represents the default priority for the scheduling policy of the process.</source>
          <target state="translated">스레드에 설정된 기본 스케줄링 우선 순위. 다중 스케줄링 정책이 정의 된 시스템에서이 값은 프로세스의 스케줄링 정책에 대한 기본 우선 순위를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="39cb60f50514180fcf08c0496a2e6d58784782d0" translate="yes" xml:space="preserve">
          <source>The default seed value.</source>
          <target state="translated">기본 시드 값입니다.</target>
        </trans-unit>
        <trans-unit id="cd5dbb92220cc6a8e8b2d5783ecebaacc60df5fc" translate="yes" xml:space="preserve">
          <source>The default value of a &lt;code&gt;Checked!(X, WithNaN)&lt;/code&gt; is its NaN value, so care must be taken that all variables are explicitly initialized. Any arithmetic and logic operation involving at least on NaN becomes NaN itself. All of &lt;code&gt;a == b&lt;/code&gt;, &lt;code&gt;a &amp;lt; b&lt;/code&gt;, &lt;code&gt;a &amp;gt; b&lt;/code&gt;, &lt;code&gt;a &amp;lt;= b&lt;/code&gt;, &lt;code&gt;a &amp;gt;= b&lt;/code&gt; yield &lt;code&gt;false&lt;/code&gt; if at least one of &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt; is NaN.</source>
          <target state="translated">&lt;code&gt;Checked!(X, WithNaN)&lt;/code&gt; 의 기본값 은 NaN 값이므로 모든 변수가 명시 적으로 초기화되도록주의해야합니다. NaN에 관련된 산술 및 논리 연산은 NaN 자체가됩니다. 모든 &lt;code&gt;a == b&lt;/code&gt; , &lt;code&gt;a &amp;lt; b&lt;/code&gt; , &lt;code&gt;a &amp;gt; b&lt;/code&gt; , &lt;code&gt;a &amp;lt;= b&lt;/code&gt; , &lt;code&gt;a &amp;gt;= b&lt;/code&gt; 항복 &lt;code&gt;false&lt;/code&gt; 의 경우 적어도 하나 및 &lt;code&gt;b&lt;/code&gt; &lt;code&gt;a&lt;/code&gt; NaN이된다.</target>
        </trans-unit>
        <trans-unit id="60336805f352e76f45059516632dd3aebf2bb4c8" translate="yes" xml:space="preserve">
          <source>The default value used for values not explicitly initialized. It is the NaN value, i.e. &lt;code&gt;T.min&lt;/code&gt; for signed integrals and &lt;code&gt;T.max&lt;/code&gt; for unsigned integrals.</source>
          <target state="translated">명시 적으로 초기화되지 않은 값에 사용되는 기본값입니다. 그것은 즉, NaN의 값입니다 &lt;code&gt;T.min&lt;/code&gt; 서명 적분과에 대한 &lt;code&gt;T.max&lt;/code&gt; 부호 적분합니다.</target>
        </trans-unit>
        <trans-unit id="175f9e59ae6d8d45a5ecbc8d3bf95ccec9b46335" translate="yes" xml:space="preserve">
          <source>The default value.</source>
          <target state="translated">기본값입니다.</target>
        </trans-unit>
        <trans-unit id="5298372926ef4a5550bf5eba62d1b79774021d32" translate="yes" xml:space="preserve">
          <source>The default way to configure the runtime is by passing command line arguments starting with &lt;code&gt;--DRT-&lt;/code&gt; and followed by the option name, e.g. &lt;code&gt;--DRT-gcopt&lt;/code&gt; to configure the GC. When command line parsing is enabled, command line options starting with &lt;code&gt;--DRT-&lt;/code&gt; are filtered out before calling main, so the program will not see them. They are still available via &lt;code&gt;rt_args()&lt;/code&gt;.</source>
          <target state="translated">런타임을 구성하는 기본 방법은 &lt;code&gt;--DRT-&lt;/code&gt; 로 시작 하고 그 뒤에 옵션 이름 (예 : &lt;code&gt;--DRT-gcopt&lt;/code&gt; ) 을 사용하여 GC를 구성 하는 명령 행 인수를 전달하는 것 입니다. 명령 줄 구문 분석이 활성화되면 &lt;code&gt;--DRT-&lt;/code&gt; 로 시작하는 명령 줄 옵션 이 main을 호출하기 전에 필터링되므로 프로그램에서이를 볼 수 없습니다. 그들은 여전히 &lt;code&gt;rt_args()&lt;/code&gt; 를 통해 사용 가능합니다 합니다.</target>
        </trans-unit>
        <trans-unit id="ba1df5a4c503e2e5ff553646b53232a4dc9fad0b" translate="yes" xml:space="preserve">
          <source>The delegate or function having the currently held value as parameter is called with &lt;code&gt;variant&lt;/code&gt;'s current value. Visiting handlers are passed in the template parameter list. It is statically ensured that all held types of &lt;code&gt;variant&lt;/code&gt; are handled across all handlers. &lt;code&gt;visit&lt;/code&gt; allows delegates and static functions to be passed as parameters.</source>
          <target state="translated">현재 보유 된 값을 매개 변수로 갖는 델리게이트 또는 함수는 &lt;code&gt;variant&lt;/code&gt; 의 현재 값으로 호출됩니다 . 방문 핸들러는 템플리트 매개 변수 목록에 전달됩니다. 모든 보유 유형의 &lt;code&gt;variant&lt;/code&gt; 이 모든 핸들러에서 처리 되도록 정적으로 보장 됩니다. &lt;code&gt;visit&lt;/code&gt; 델리게이트와 정적 함수를 매개 변수로 전달할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2b6e50abb4f0914ce14cb54a228ba5c564bcd73a" translate="yes" xml:space="preserve">
          <source>The delegate to be called if the value evaluates to false.</source>
          <target state="translated">값이 false로 평가되면 호출 할 대리자입니다.</target>
        </trans-unit>
        <trans-unit id="95f480c7d2ae51400206ecb9e084d35ded98b8d3" translate="yes" xml:space="preserve">
          <source>The demangle module converts mangled D symbols to a representation similar to what would have existed in code.</source>
          <target state="translated">demangle 모듈은 맹 글링 된 D 심볼을 코드에 존재했던 것과 유사한 표현으로 변환합니다.</target>
        </trans-unit>
        <trans-unit id="48b3f69fad23d9b2d8c32fdb445562e4fbbe9924" translate="yes" xml:space="preserve">
          <source>The demangled name or the original string if the name is not a mangled D name.</source>
          <target state="translated">얽힌 이름 또는 이름이 엉망인 D 이름이 아닌 경우 원래 문자열입니다.</target>
        </trans-unit>
        <trans-unit id="0cc17d9f531c72835705e440a701b890a1903124" translate="yes" xml:space="preserve">
          <source>The demangled type name or the original string if the name is not a mangled D type.</source>
          <target state="translated">얽힌 유형 이름 또는 이름이 엉망인 D 유형이 아닌 경우 원래 문자열입니다.</target>
        </trans-unit>
        <trans-unit id="60c01151d0f392e7605b5a47b38d319dce929d2b" translate="yes" xml:space="preserve">
          <source>The description of this option</source>
          <target state="translated">이 옵션에 대한 설명</target>
        </trans-unit>
        <trans-unit id="f84ede836de109cb779bab9fc0b1fd8d408f2a87" translate="yes" xml:space="preserve">
          <source>The desired &lt;a href=&quot;#FunctionAttribute&quot;&gt;&lt;code&gt;FunctionAttribute&lt;/code&gt;&lt;/a&gt;s of the result type.</source>
          <target state="translated">결과 유형 의 원하는 &lt;a href=&quot;#FunctionAttribute&quot;&gt; &lt;code&gt;FunctionAttribute&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="23d72f95e07dcbef384a7cb27da3b8ccb18812f3" translate="yes" xml:space="preserve">
          <source>The desired allocation size in bytes.</source>
          <target state="translated">바이트 단위의 원하는 할당 크기</target>
        </trans-unit>
        <trans-unit id="9a65e8347e92f2a998eac03474e781c85ca96f7b" translate="yes" xml:space="preserve">
          <source>The desired extension size in bytes.</source>
          <target state="translated">바이트 단위의 원하는 확장 크기입니다.</target>
        </trans-unit>
        <trans-unit id="af2fe61e437d6dfeba930d32d765dbac31989651" translate="yes" xml:space="preserve">
          <source>The desired linkage of the result type.</source>
          <target state="translated">결과 유형의 원하는 연결입니다.</target>
        </trans-unit>
        <trans-unit id="59cf426293fa685ffeb3c9d3c020fed48d5397c1" translate="yes" xml:space="preserve">
          <source>The desired size in bytes.</source>
          <target state="translated">바이트 단위로 원하는 크기입니다.</target>
        </trans-unit>
        <trans-unit id="ac522378c8d7addb4cb9d53d5b7d048c9264b788" translate="yes" xml:space="preserve">
          <source>The destructor automatically closes the file as soon as no &lt;code&gt;File&lt;/code&gt; object refers to it anymore.</source>
          <target state="translated">&lt;code&gt;File&lt;/code&gt; 객체가 더 이상 참조 하지 않으면 소멸자가 파일을 자동으로 닫습니다 .</target>
        </trans-unit>
        <trans-unit id="8c331e4eecbd8270b0e4ce21fab87b6858ba74cc" translate="yes" xml:space="preserve">
          <source>The destructor for the super class automatically gets called when the destructor ends. There is no way to call the super destructor explicitly.</source>
          <target state="translated">수퍼 클래스의 소멸자는 소멸자가 종료되면 자동으로 호출됩니다. 슈퍼 소멸자를 명시 적으로 호출하는 방법은 없습니다.</target>
        </trans-unit>
        <trans-unit id="f6330e2ba0f0050af5f9f70cf0eec4389de5eb4b" translate="yes" xml:space="preserve">
          <source>The destructor is expected to release any resources held by the object.</source>
          <target state="translated">소멸자는 객체가 보유한 모든 자원을 해제해야합니다.</target>
        </trans-unit>
        <trans-unit id="7159cd12fe27172c0a0982e4b8092e7e75f8821b" translate="yes" xml:space="preserve">
          <source>The difference between rolling and adding is that rolling does not affect larger units. For instance, rolling a &lt;a href=&quot;#Date&quot;&gt;&lt;code&gt;Date&lt;/code&gt;&lt;/a&gt; one year's worth of days gets the exact same &lt;a href=&quot;#Date&quot;&gt;&lt;code&gt;Date&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">롤링과 추가의 차이점은 롤링이 더 큰 단위에 영향을 미치지 않는다는 것입니다. 예를 들어, 1 년 동안 &lt;a href=&quot;#Date&quot;&gt; &lt;code&gt;Date&lt;/code&gt; 를&lt;/a&gt; 롤링 하면 정확히 같은 &lt;a href=&quot;#Date&quot;&gt; &lt;code&gt;Date&lt;/code&gt; 가&lt;/a&gt; 됩니다.</target>
        </trans-unit>
        <trans-unit id="b7c404d040d8fd24e8c117abcb04c6ad2d048280" translate="yes" xml:space="preserve">
          <source>The difference between rolling and adding is that rolling does not affect larger units. For instance, rolling a &lt;a href=&quot;#DateTime&quot;&gt;&lt;code&gt;DateTime&lt;/code&gt;&lt;/a&gt; one year's worth of days gets the exact same &lt;a href=&quot;#DateTime&quot;&gt;&lt;code&gt;DateTime&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">롤링과 추가의 차이점은 롤링이 더 큰 단위에 영향을 미치지 않는다는 것입니다. 예를 들어 &lt;a href=&quot;#DateTime&quot;&gt; &lt;code&gt;DateTime&lt;/code&gt; 을&lt;/a&gt; 1 년 동안 롤링 하면 정확히 동일한 &lt;a href=&quot;#DateTime&quot;&gt; &lt;code&gt;DateTime&lt;/code&gt; 이&lt;/a&gt; 됩니다.</target>
        </trans-unit>
        <trans-unit id="b3c3c9ee3f68d7a39533f5e98688e28838282e6b" translate="yes" xml:space="preserve">
          <source>The difference between rolling and adding is that rolling does not affect larger units. For instance, rolling a &lt;a href=&quot;#SysTime&quot;&gt;&lt;code&gt;SysTime&lt;/code&gt;&lt;/a&gt; one year's worth of days gets the exact same &lt;a href=&quot;#SysTime&quot;&gt;&lt;code&gt;SysTime&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">롤링과 추가의 차이점은 롤링이 더 큰 단위에 영향을 미치지 않는다는 것입니다. 예를 들어, 1 년 동안 &lt;a href=&quot;#SysTime&quot;&gt; &lt;code&gt;SysTime&lt;/code&gt; 을&lt;/a&gt; 롤링 하면 정확히 동일한 &lt;a href=&quot;#SysTime&quot;&gt; &lt;code&gt;SysTime&lt;/code&gt; 이&lt;/a&gt; 됩니다.</target>
        </trans-unit>
        <trans-unit id="24751c549ef6022fb5253fa2ab74c9f98d81a539" translate="yes" xml:space="preserve">
          <source>The difference between rolling and adding is that rolling does not affect larger units. For instance, rolling a &lt;a href=&quot;#TimeOfDay&quot;&gt;&lt;code&gt;TimeOfDay&lt;/code&gt;&lt;/a&gt; one hours's worth of minutes gets the exact same &lt;a href=&quot;#TimeOfDay&quot;&gt;&lt;code&gt;TimeOfDay&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">롤링과 추가의 차이점은 롤링이 더 큰 단위에 영향을 미치지 않는다는 것입니다. 예를 들어, &lt;a href=&quot;#TimeOfDay&quot;&gt; &lt;code&gt;TimeOfDay&lt;/code&gt; 를&lt;/a&gt; 1 시간 분 동안 롤링 하면 정확히 동일한 &lt;a href=&quot;#TimeOfDay&quot;&gt; &lt;code&gt;TimeOfDay&lt;/code&gt; 를&lt;/a&gt; 얻습니다 .</target>
        </trans-unit>
        <trans-unit id="e8c7039887bf08601f56a0509005c2c5688e3ba7" translate="yes" xml:space="preserve">
          <source>The difference between rolling and adding is that rolling does not affect larger units. Rolling a &lt;a href=&quot;#Date&quot;&gt;&lt;code&gt;Date&lt;/code&gt;&lt;/a&gt; 12 months gets the exact same &lt;a href=&quot;#Date&quot;&gt;&lt;code&gt;Date&lt;/code&gt;&lt;/a&gt;. However, the days can still be affected due to the differing number of days in each month.</source>
          <target state="translated">롤링과 추가의 차이점은 롤링이 더 큰 단위에 영향을 미치지 않는다는 것입니다. 롤링 &lt;a href=&quot;#Date&quot;&gt; &lt;code&gt;Date&lt;/code&gt; &lt;/a&gt; 12개월하면 동일한 도착 &lt;a href=&quot;#Date&quot;&gt; &lt;code&gt;Date&lt;/code&gt; &lt;/a&gt; . 그러나 매월 다른 요일로 인해 요일에 영향을 줄 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4c92275a7e175bacd3ce746d6adc1eff5f6f35c0" translate="yes" xml:space="preserve">
          <source>The difference between rolling and adding is that rolling does not affect larger units. Rolling a &lt;a href=&quot;#DateTime&quot;&gt;&lt;code&gt;DateTime&lt;/code&gt;&lt;/a&gt; 12 months gets the exact same &lt;a href=&quot;#DateTime&quot;&gt;&lt;code&gt;DateTime&lt;/code&gt;&lt;/a&gt;. However, the days can still be affected due to the differing number of days in each month.</source>
          <target state="translated">롤링과 추가의 차이점은 롤링이 더 큰 단위에 영향을 미치지 않는다는 것입니다. &lt;a href=&quot;#DateTime&quot;&gt; &lt;code&gt;DateTime&lt;/code&gt; 을&lt;/a&gt; 12 개월 롤링 하면 정확히 동일한 &lt;a href=&quot;#DateTime&quot;&gt; &lt;code&gt;DateTime&lt;/code&gt; 이 표시&lt;/a&gt; 됩니다. 그러나 매월 다른 요일로 인해 요일에 영향을 줄 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="bd425db182cd0598846f2e904965692d4bd6f1e2" translate="yes" xml:space="preserve">
          <source>The difference between rolling and adding is that rolling does not affect larger units. Rolling a &lt;a href=&quot;#SysTime&quot;&gt;&lt;code&gt;SysTime&lt;/code&gt;&lt;/a&gt; 12 months gets the exact same &lt;a href=&quot;#SysTime&quot;&gt;&lt;code&gt;SysTime&lt;/code&gt;&lt;/a&gt;. However, the days can still be affected due to the differing number of days in each month.</source>
          <target state="translated">롤링과 추가의 차이점은 롤링이 더 큰 단위에 영향을 미치지 않는다는 것입니다. &lt;a href=&quot;#SysTime&quot;&gt; &lt;code&gt;SysTime&lt;/code&gt; 을&lt;/a&gt; 12 개월 롤링 하면 정확히 동일한 &lt;a href=&quot;#SysTime&quot;&gt; &lt;code&gt;SysTime&lt;/code&gt; 을 얻습니다&lt;/a&gt; . 그러나 매월 다른 요일로 인해 요일에 영향을 줄 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9607cb254c58607b6f72a2ec85c44f16a7c46305" translate="yes" xml:space="preserve">
          <source>The difference between this version of &lt;code&gt;everyDuration&lt;/code&gt; and the version which just takes a &lt;a href=&quot;core_time#Duration&quot;&gt;&lt;code&gt;core.time.Duration&lt;/code&gt;&lt;/a&gt; is that this one also takes the number of years and months (along with an &lt;code&gt;AllowDayOverflow&lt;/code&gt; to indicate whether adding years and months should allow the days to overflow).</source>
          <target state="translated">이 버전의 차이 &lt;code&gt;everyDuration&lt;/code&gt; 단지 걸리는 버전 &lt;a href=&quot;core_time#Duration&quot;&gt; &lt;code&gt;core.time.Duration&lt;/code&gt; 은&lt;/a&gt; 이것 또한 (AN과 함께 년 개월 수를 취한다는 것입니다 &lt;code&gt;AllowDayOverflow&lt;/code&gt; 추가 년 개월 오버플로 일을 허용할지 여부를 나타냅니다) .</target>
        </trans-unit>
        <trans-unit id="448504c864d4f8f6a21520c51c1f3e9b8a81d617" translate="yes" xml:space="preserve">
          <source>The digamma function is the logarithmic derivative of the gamma function.</source>
          <target state="translated">디 감마 함수는 감마 함수의 로그 미분입니다.</target>
        </trans-unit>
        <trans-unit id="df031407b714e9d3fe5339c97f81f1b5df587638" translate="yes" xml:space="preserve">
          <source>The direction and magnitude of the 1st shift. Positive means left, negative means right.</source>
          <target state="translated">첫 번째 교대의 방향과 규모. 양수는 왼쪽을, 음수는 오른쪽을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="ac46a68fb5f59b21b538d08a263d443a6d4a88ba" translate="yes" xml:space="preserve">
          <source>The direction and magnitude of the 2nd shift. Positive means left, negative means right.</source>
          <target state="translated">두 번째 교대의 방향과 규모. 양수는 왼쪽을, 음수는 오른쪽을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="2f490894285820c4987bf19f75fcde524a0fa198" translate="yes" xml:space="preserve">
          <source>The direction and magnitude of the 3rd shift. Positive means left, negative means right.</source>
          <target state="translated">세 번째 교대의 방향과 규모. 양수는 왼쪽을, 음수는 오른쪽을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="3c5a37562720e9b61ecfa6b8583112dc5d6824cf" translate="yes" xml:space="preserve">
          <source>The direction in time to expand the interval.</source>
          <target state="translated">간격을 확장 할 시간 방향입니다.</target>
        </trans-unit>
        <trans-unit id="52fc8addeaa24de333c4f04db15ff317feeb8f10" translate="yes" xml:space="preserve">
          <source>The direction to iterate in. If passing the return value to &lt;code&gt;fwdRange&lt;/code&gt;, use &lt;code&gt;Direction.fwd&lt;/code&gt;. If passing it to &lt;code&gt;bwdRange&lt;/code&gt;, use &lt;code&gt;Direction.bwd&lt;/code&gt;.</source>
          <target state="translated">반복 할 방향입니다. 반환 값을 &lt;code&gt;fwdRange&lt;/code&gt; 로 전달하는 경우 &lt;code&gt;Direction.fwd&lt;/code&gt; 를 사용하십시오 . &lt;code&gt;bwdRange&lt;/code&gt; 로 전달하는 경우 &lt;code&gt;Direction.bwd&lt;/code&gt; 를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="ae829e1bef022f58af3dfe6292cdbc4a3e16363d" translate="yes" xml:space="preserve">
          <source>The directories listed in the PATH environment variable.</source>
          <target state="translated">PATH 환경 변수에 나열된 디렉토리</target>
        </trans-unit>
        <trans-unit id="745a52fd17585cda122240a437ff94eb24ff53ba" translate="yes" xml:space="preserve">
          <source>The directory from which the application loaded.</source>
          <target state="translated">애플리케이션이로드 된 디렉토리입니다.</target>
        </trans-unit>
        <trans-unit id="c70ca0dd7d389cc0f66b4748ce2158d5f654afbf" translate="yes" xml:space="preserve">
          <source>The directory given by the &lt;code&gt;TEMP&lt;/code&gt; environment variable.</source>
          <target state="translated">&lt;code&gt;TEMP&lt;/code&gt; 환경 변수가 제공 한 디렉토리 .</target>
        </trans-unit>
        <trans-unit id="9ae0bd7ea20121e71f355b6ae61308dbc4fc4a8d" translate="yes" xml:space="preserve">
          <source>The directory given by the &lt;code&gt;TMP&lt;/code&gt; environment variable.</source>
          <target state="translated">&lt;code&gt;TMP&lt;/code&gt; 환경 변수가 제공 한 디렉토리 .</target>
        </trans-unit>
        <trans-unit id="daef8bc56ebc827befeb7f02e13c0987eaa60ed2" translate="yes" xml:space="preserve">
          <source>The directory given by the &lt;code&gt;TMPDIR&lt;/code&gt; environment variable.</source>
          <target state="translated">&lt;code&gt;TMPDIR&lt;/code&gt; 환경 변수가 제공 한 디렉토리 .</target>
        </trans-unit>
        <trans-unit id="d4eec1b6c0603738af374e4a976caa00a506fd85" translate="yes" xml:space="preserve">
          <source>The directory to iterate over. If empty, the current directory will be iterated.</source>
          <target state="translated">반복 할 디렉토리입니다. 비어 있으면 현재 디렉토리가 반복됩니다.</target>
        </trans-unit>
        <trans-unit id="98b1c4850f41f23860e357cb3645bbbb143947fc" translate="yes" xml:space="preserve">
          <source>The directory where the TZ Database files are located.</source>
          <target state="translated">TZ 데이터베이스 파일이있는 디렉토리입니다.</target>
        </trans-unit>
        <trans-unit id="5185a0b5ceb9f32e8b2ce8a938cb585e46dedffd" translate="yes" xml:space="preserve">
          <source>The directory where the TZ Database files are located. Because these files are not located on Windows systems, provide them and give their location here to use &lt;a href=&quot;#PosixTimeZone&quot;&gt;&lt;code&gt;PosixTimeZone&lt;/code&gt;&lt;/a&gt;s.</source>
          <target state="translated">TZ 데이터베이스 파일이있는 디렉토리입니다. 이러한 파일은 Windows 시스템에 &lt;a href=&quot;#PosixTimeZone&quot;&gt; &lt;code&gt;PosixTimeZone&lt;/code&gt; &lt;/a&gt; 을 사용하려면 파일 을 제공하고 여기에 해당 위치를 제공하십시오 .</target>
        </trans-unit>
        <trans-unit id="1b936f38c2f1aa54bd76a7cc62b14148166a642a" translate="yes" xml:space="preserve">
          <source>The disadvantages of &lt;code&gt;ContiguousFreeList&lt;/code&gt; over &lt;code&gt;FreeList&lt;/code&gt; are its pay upfront model (as opposed to &lt;code&gt;FreeList&lt;/code&gt;'s pay-as-you-go approach), and a hard limit on the number of nodes in the list. Thus, a large number of long- lived objects may occupy the entire block, making it unavailable for serving allocations from the free list. However, an absolute cap on the free list size may be beneficial.</source>
          <target state="translated">의 단점 &lt;code&gt;ContiguousFreeList&lt;/code&gt; 이상 &lt;code&gt;FreeList&lt;/code&gt; (반대의 지불 선행 모델이다 &lt;code&gt;FreeList&lt;/code&gt; 의 부과 방식 - 이동 방식)하고 목록에있는 노드의 수에 엄격한 제한. 따라서 수명이 긴 많은 개체가 전체 블록을 차지하여 사용 가능한 목록에서 할당을 제공 할 수 없게됩니다. 그러나 무료 목록 크기의 절대 한계가 유리할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3b64019a956fdeb2b48af242389c7dfaf52e1521" translate="yes" xml:space="preserve">
          <source>The distinction is made in the semantic analysis pass.</source>
          <target state="translated">시맨틱 분석 단계에서 구별됩니다.</target>
        </trans-unit>
        <trans-unit id="d29faf2564401dd940d152dda18be8c2fa0d07a8" translate="yes" xml:space="preserve">
          <source>The document comment is a series of</source>
          <target state="translated">문서 주석은 일련의</target>
        </trans-unit>
        <trans-unit id="e57c999ce3911b8c1791d1a7eb04e0490e4fee0b" translate="yes" xml:space="preserve">
          <source>The documentation comment processor includes a simple macro text preprocessor. When a &amp;amp;dollar;(</source>
          <target state="translated">문서 주석 프로세서에는 간단한 매크로 텍스트 프리 프로세서가 포함되어 있습니다. &amp;amp; dollar; (</target>
        </trans-unit>
        <trans-unit id="0f835ee5f6e2ea0040d44210ead7dc160306901a" translate="yes" xml:space="preserve">
          <source>The documentation comments can themselves be commented using the &amp;amp;dollar;&lt;code&gt;(DDOC_COMMENT comment text)&lt;/code&gt; syntax. These comments do not nest.</source>
          <target state="translated">문서 주석은 &amp;amp; dollar; &lt;code&gt;(DDOC_COMMENT comment text)&lt;/code&gt; 구문. 이 주석은 중첩되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="ad9fa243a6cd23895dc3ad60e16a76e4b15cce21" translate="yes" xml:space="preserve">
          <source>The domain literal is not a valid RFC 5321 address literal</source>
          <target state="translated">도메인 리터럴이 유효한 RFC 5321 주소 리터럴이 아닙니다.</target>
        </trans-unit>
        <trans-unit id="e9bc2306173e1f523fc346c3259e214855410cc4" translate="yes" xml:space="preserve">
          <source>The domain literal is not a valid RFC 5321 address literal and it contains obsolete characters</source>
          <target state="translated">도메인 리터럴이 유효한 RFC 5321 주소 리터럴이 아니며 더 이상 사용되지 않는 문자가 포함되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="9635c78033f40ef6473df58ddae1875249393348" translate="yes" xml:space="preserve">
          <source>The domain of definition is 0 &amp;lt;= x &amp;lt;= 1. In this implementation a and b are restricted to positive values. The integral from x to 1 may be obtained by the symmetry relation</source>
          <target state="translated">정의 영역은 0 &amp;lt;= x &amp;lt;= 1입니다.이 구현에서 a 및 b는 양수 값으로 제한됩니다. x에서 1까지의 적분은 대칭 관계에 의해 얻어 질 수있다</target>
        </trans-unit>
        <trans-unit id="7630f4b6e086656f20c44179d8d49a08885c5ad0" translate="yes" xml:space="preserve">
          <source>The domain part contains an element that is too long</source>
          <target state="translated">도메인 부분에 너무 긴 요소가 포함되어 있습니다</target>
        </trans-unit>
        <trans-unit id="f9e782a18f0e80044819c477465949e037991e2b" translate="yes" xml:space="preserve">
          <source>The domain part is too long</source>
          <target state="translated">도메인 부분이 너무 깁니다</target>
        </trans-unit>
        <trans-unit id="b4015656a3a26966f5bb779ad625cb099b930b1f" translate="yes" xml:space="preserve">
          <source>The domain part of the email address, that is, the part after the @ sign.</source>
          <target state="translated">이메일 주소의 도메인 부분, 즉 @ 기호 뒤의 부분입니다.</target>
        </trans-unit>
        <trans-unit id="bc43c1b6acb6b3f1be54a397e4365b408708f795" translate="yes" xml:space="preserve">
          <source>The drain of the data read.</source>
          <target state="translated">읽은 데이터의 드레인.</target>
        </trans-unit>
        <trans-unit id="d6c5fc3ceb4e2b528f0297088355338c6c888969" translate="yes" xml:space="preserve">
          <source>The duration from the starting point to the end point.</source>
          <target state="translated">시작점에서 끝점까지의 지속 시간입니다.</target>
        </trans-unit>
        <trans-unit id="13e96de5799e2b95c36e302f2857b76d002475c9" translate="yes" xml:space="preserve">
          <source>The duration to add to or subtract from this &lt;a href=&quot;#DateTime&quot;&gt;&lt;code&gt;DateTime&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 &lt;a href=&quot;#DateTime&quot;&gt; &lt;code&gt;DateTime&lt;/code&gt; 에&lt;/a&gt; 더하거나 뺄 시간 입니다.</target>
        </trans-unit>
        <trans-unit id="5de9a67b89b5b7a6e94e2e5ed705920f06e257b1" translate="yes" xml:space="preserve">
          <source>The duration to add to or subtract from this &lt;code&gt;Duration&lt;/code&gt;.</source>
          <target state="translated">이 &lt;code&gt;Duration&lt;/code&gt; 에 더하거나 빼는 기간 입니다.</target>
        </trans-unit>
        <trans-unit id="045eb63ee5246a358977769376ebbddf4f7e79de" translate="yes" xml:space="preserve">
          <source>The duration to add to the time point passed to the delegate.</source>
          <target state="translated">대리인에게 전달 된 시점에 추가 할 기간입니다.</target>
        </trans-unit>
        <trans-unit id="f712fda6f39835e50109819b59fa2e17d776d88d" translate="yes" xml:space="preserve">
          <source>The duration to divide this &lt;code&gt;Duration&lt;/code&gt; by.</source>
          <target state="translated">이 기간을 나눌 &lt;code&gt;Duration&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="ebebf2b9a88fc743bbefdf245fe1996fed62b5d4" translate="yes" xml:space="preserve">
          <source>The duration to expand the interval by.</source>
          <target state="translated">간격을 연장하는 기간입니다.</target>
        </trans-unit>
        <trans-unit id="6b8d59a6b4eb6f151c22d18ab315e8905cbca345" translate="yes" xml:space="preserve">
          <source>The duration to set this &lt;a href=&quot;#SysTime&quot;&gt;&lt;code&gt;SysTime&lt;/code&gt;&lt;/a&gt;'s fractional seconds to.</source>
          <target state="translated">이 &lt;a href=&quot;#SysTime&quot;&gt; &lt;code&gt;SysTime&lt;/code&gt; &lt;/a&gt; 소수 초를 설정하는 기간 입니다.</target>
        </trans-unit>
        <trans-unit id="10a00cd16c4e11d477797057c8547364622ecc0c" translate="yes" xml:space="preserve">
          <source>The duration to shift the interval by.</source>
          <target state="translated">간격을 변경하는 기간입니다.</target>
        </trans-unit>
        <trans-unit id="b1c624813bb3a1615cc85c1ae1a0262dd3e649d6" translate="yes" xml:space="preserve">
          <source>The duration which separates each successive time point in the range.</source>
          <target state="translated">범위에서 각 연속 시점을 분리하는 기간입니다.</target>
        </trans-unit>
        <trans-unit id="4aceca3575bedab7bdf950c54d8f75f4cd974c6c" translate="yes" xml:space="preserve">
          <source>The effect of this function, as well as the meaning of &lt;code&gt;codeOrSignal&lt;/code&gt;, is highly platform dependent. Details are given below. Common to all platforms is that this function only</source>
          <target state="translated">&lt;code&gt;codeOrSignal&lt;/code&gt; 의 의미뿐만 아니라이 함수의 효과는 플랫폼에 따라 크게 달라집니다. 자세한 내용은 다음과 같습니다. 모든 플랫폼에 공통적 인 것은이 기능 만</target>
        </trans-unit>
        <trans-unit id="b949a7d4d40b96549035bb1b9cabaaf6d915fa2c" translate="yes" xml:space="preserve">
          <source>The effect on &lt;code&gt;inp&lt;/code&gt; depends on the kind of function called:</source>
          <target state="translated">&lt;code&gt;inp&lt;/code&gt; 에 대한 영향은 호출 된 함수의 종류에 따라 다릅니다.</target>
        </trans-unit>
        <trans-unit id="562dbad759d6f2a80acd12d273fe89562ff6f2e0" translate="yes" xml:space="preserve">
          <source>The element (or range) to be treated as the separator between range segments to be split.</source>
          <target state="translated">분할 할 범위 세그먼트 사이의 분리 자로 취급 할 요소 (또는 범위)입니다.</target>
        </trans-unit>
        <trans-unit id="67f3be77d3c98017b171a56f0b2ef27d5b2a4614" translate="yes" xml:space="preserve">
          <source>The element at offset &lt;code&gt;1&lt;/code&gt; has been removed and the rest of the elements have shifted up to fill its place, however, the original array remains of the same length. This is because all functions in &lt;code&gt;std.algorithm&lt;/code&gt; only change</source>
          <target state="translated">오프셋 &lt;code&gt;1&lt;/code&gt; 의 요소 가 제거되었고 나머지 요소가 그 자리를 채우도록 위로 이동했지만 원래 배열의 길이는 동일합니다. &lt;code&gt;std.algorithm&lt;/code&gt; 모든 기능 만 변경 되기 때문입니다.</target>
        </trans-unit>
        <trans-unit id="889dab60cf01b0f7421719ab37f1b28c9311efa0" translate="yes" xml:space="preserve">
          <source>The element corresponding with a left (opening) parenthesis.</source>
          <target state="translated">왼쪽 괄호에 해당하는 요소입니다.</target>
        </trans-unit>
        <trans-unit id="0932ed8af54392d39cf0d92fcbcc4890a1724cbd" translate="yes" xml:space="preserve">
          <source>The element corresponding with a right (closing) parenthesis.</source>
          <target state="translated">오른쪽 (닫는) 괄호에 해당하는 요소입니다.</target>
        </trans-unit>
        <trans-unit id="dedbb295326b4d3eda9e5e759f27bfe1c5ac6bc2" translate="yes" xml:space="preserve">
          <source>The element is assumed to contain text</source>
          <target state="translated">요소는 텍스트를 포함하는 것으로 가정</target>
        </trans-unit>
        <trans-unit id="8312cc74e186b12d4ed20f4003b6c04acdd49b6e" translate="yes" xml:space="preserve">
          <source>The element or a reference to the element at the specified index.</source>
          <target state="translated">지정된 인덱스의 요소 또는 요소에 대한 참조입니다.</target>
        </trans-unit>
        <trans-unit id="7131957f7eb94e306d342b5195eb84dc3e1e781f" translate="yes" xml:space="preserve">
          <source>The element or sub-range to count in the &lt;code&gt;haystack&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;haystack&lt;/code&gt; 에서 계산할 요소 또는 하위 범위 입니다.</target>
        </trans-unit>
        <trans-unit id="7a38c4dc1b72acf54e9b103de60a08c5dad1c7f0" translate="yes" xml:space="preserve">
          <source>The element removed.</source>
          <target state="translated">요소가 제거되었습니다.</target>
        </trans-unit>
        <trans-unit id="f20b1e66abf934338028bfca19daea068ac238b3" translate="yes" xml:space="preserve">
          <source>The element searched for.</source>
          <target state="translated">요소가 검색되었습니다.</target>
        </trans-unit>
        <trans-unit id="3af3bbcb06a3c010f8dd6e115df00414b2ef76c3" translate="yes" xml:space="preserve">
          <source>The element to match.</source>
          <target state="translated">일치시킬 요소입니다.</target>
        </trans-unit>
        <trans-unit id="bfcc76451138cf6e179bded66babeafecdbfe06a" translate="yes" xml:space="preserve">
          <source>The element to stop at.</source>
          <target state="translated">멈출 요소.</target>
        </trans-unit>
        <trans-unit id="b80bff8085fdd511cb9c4d9e05da48019bf3dd74" translate="yes" xml:space="preserve">
          <source>The element type for 32-bit implementation.</source>
          <target state="translated">32 비트 구현을위한 요소 유형입니다.</target>
        </trans-unit>
        <trans-unit id="218ef2dcaf3b3057dc646bab34be48640fa2fc83" translate="yes" xml:space="preserve">
          <source>The element type for the range will be &lt;code&gt;Char[]&lt;/code&gt;. Range primitives may throw &lt;code&gt;StdioException&lt;/code&gt; on I/O error.</source>
          <target state="translated">범위의 요소 유형은 &lt;code&gt;Char[]&lt;/code&gt; 입니다. 범위 프리미티브는 I / O 오류에서 &lt;code&gt;StdioException&lt;/code&gt; 을 발생시킬 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c8e0ad7d182f093115b2321024fb0d43eeab8ccb" translate="yes" xml:space="preserve">
          <source>The element type for the range will be &lt;code&gt;ubyte[]&lt;/code&gt;. Range primitives may throw &lt;code&gt;StdioException&lt;/code&gt; on I/O error.</source>
          <target state="translated">범위의 요소 유형은 &lt;code&gt;ubyte[]&lt;/code&gt; 입니다. 범위 프리미티브는 I / O 오류에서 &lt;code&gt;StdioException&lt;/code&gt; 을 발생시킬 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="146f6e63904487c6bc88a456ffe5bb5d872efab2" translate="yes" xml:space="preserve">
          <source>The element type of &lt;code&gt;R&lt;/code&gt;. &lt;code&gt;R&lt;/code&gt; does not have to be a range. The element type is determined as the type yielded by &lt;code&gt;r.front&lt;/code&gt; for an object &lt;code&gt;r&lt;/code&gt; of type &lt;code&gt;R&lt;/code&gt;. For example, &lt;code&gt;ElementType!(T[])&lt;/code&gt; is &lt;code&gt;T&lt;/code&gt; if &lt;code&gt;T[]&lt;/code&gt; isn't a narrow string; if it is, the element type is &lt;code&gt;dchar&lt;/code&gt;. If &lt;code&gt;R&lt;/code&gt; doesn't have &lt;code&gt;front&lt;/code&gt;, &lt;code&gt;ElementType!R&lt;/code&gt; is &lt;code&gt;void&lt;/code&gt;.</source>
          <target state="translated">의 요소 타입 &lt;code&gt;R&lt;/code&gt; . &lt;code&gt;R&lt;/code&gt; 은 범위 일 필요는 없습니다. 유형에 의해 수득으로하는 요소 타입이 결정된다 &lt;code&gt;r.front&lt;/code&gt; 객체에 대한 &lt;code&gt;r&lt;/code&gt; 형의 &lt;code&gt;R&lt;/code&gt; . 예를 들어, &lt;code&gt;ElementType!(T[])&lt;/code&gt; 이고 &lt;code&gt;T&lt;/code&gt; 는 경우 &lt;code&gt;T[]&lt;/code&gt; 좁은 문자열 아니다; 있는 경우 요소 유형은 &lt;code&gt;dchar&lt;/code&gt; 입니다. 경우 &lt;code&gt;R&lt;/code&gt; 이 없는 &lt;code&gt;front&lt;/code&gt; , &lt;code&gt;ElementType!R&lt;/code&gt; 이다 &lt;code&gt;void&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="242b60e2b158a7060db8baf4f6cc26e6d87af9f3" translate="yes" xml:space="preserve">
          <source>The element's CData items</source>
          <target state="translated">요소의 CData 항목</target>
        </trans-unit>
        <trans-unit id="c3b9d2b70df47460f19754a079e90ba32c948935" translate="yes" xml:space="preserve">
          <source>The element's child elements</source>
          <target state="translated">요소의 자식 요소</target>
        </trans-unit>
        <trans-unit id="a931fa1a5c6e1ac62a1fb67480e5e8ac09b9bdb7" translate="yes" xml:space="preserve">
          <source>The element's comments</source>
          <target state="translated">요소의 의견</target>
        </trans-unit>
        <trans-unit id="a2b54c10854bacd9d44680700556c9e99d65c27d" translate="yes" xml:space="preserve">
          <source>The element's items</source>
          <target state="translated">요소의 항목</target>
        </trans-unit>
        <trans-unit id="585ede5c120291a9643e02011ada89b79cd9d6f7" translate="yes" xml:space="preserve">
          <source>The element's processing instructions</source>
          <target state="translated">요소의 처리 지침</target>
        </trans-unit>
        <trans-unit id="eb70f51eec72df5d60ca23b74395601f21da9c66" translate="yes" xml:space="preserve">
          <source>The element's text items</source>
          <target state="translated">요소의 텍스트 항목</target>
        </trans-unit>
        <trans-unit id="e5bc2ae39e4f9e29954c5367c1c69157fdd19e00" translate="yes" xml:space="preserve">
          <source>The email address to check</source>
          <target state="translated">확인할 이메일 주소</target>
        </trans-unit>
        <trans-unit id="48e5305233fe3d75b0443ee1f50818a6d648fd6c" translate="yes" xml:space="preserve">
          <source>The email status code</source>
          <target state="translated">이메일 상태 코드</target>
        </trans-unit>
        <trans-unit id="4346e3e9e5e3a95198a31c78de02c8e03150e933" translate="yes" xml:space="preserve">
          <source>The encoded string</source>
          <target state="translated">인코딩 된 문자열</target>
        </trans-unit>
        <trans-unit id="381ff9274ef41642af8e81eebffce945d9f4f6ee" translate="yes" xml:space="preserve">
          <source>The encoding element type of &lt;code&gt;R&lt;/code&gt;. For narrow strings (&lt;code&gt;char[]&lt;/code&gt;, &lt;code&gt;wchar[]&lt;/code&gt; and their qualified variants including &lt;code&gt;string&lt;/code&gt; and &lt;code&gt;wstring&lt;/code&gt;), &lt;code&gt;ElementEncodingType&lt;/code&gt; is the character type of the string. For all other types, &lt;code&gt;ElementEncodingType&lt;/code&gt; is the same as &lt;code&gt;ElementType&lt;/code&gt;.</source>
          <target state="translated">인코딩 요소 타입 &lt;code&gt;R&lt;/code&gt; . 좁은 문자열 ( &lt;code&gt;char[]&lt;/code&gt; , &lt;code&gt;wchar[]&lt;/code&gt; 및 &lt;code&gt;string&lt;/code&gt; 및 &lt;code&gt;wstring&lt;/code&gt; 을 포함한 정규화 된 변형 )의 경우 &lt;code&gt;ElementEncodingType&lt;/code&gt; 은 문자열의 문자 유형입니다. 다른 모든 유형의 경우 &lt;code&gt;ElementEncodingType&lt;/code&gt; 은 &lt;code&gt;ElementType&lt;/code&gt; 과 동일합니다 .</target>
        </trans-unit>
        <trans-unit id="8ddaa2a73311c2a472b8bde0c140d7d16072aef8" translate="yes" xml:space="preserve">
          <source>The end point of the interval. It is excluded from the interval.</source>
          <target state="translated">간격의 끝점입니다. 간격에서 제외됩니다.</target>
        </trans-unit>
        <trans-unit id="3045098b74bc924c86c93e1e08406b98332239d1" translate="yes" xml:space="preserve">
          <source>The endianness that the bytes are assumed to be in.</source>
          <target state="translated">바이트가있는 것으로 간주되는 엔디안입니다.</target>
        </trans-unit>
        <trans-unit id="d625680f2f5053e8d89e9dc8332e606f7d3ff5c0" translate="yes" xml:space="preserve">
          <source>The endianness that the program was compiled for.</source>
          <target state="translated">프로그램이 컴파일 된 엔디안.</target>
        </trans-unit>
        <trans-unit id="2c31e59fa05bc473d51ba9ff8b1fbea71679f185" translate="yes" xml:space="preserve">
          <source>The endianness to write the bytes in.</source>
          <target state="translated">바이트를 쓸 엔디안</target>
        </trans-unit>
        <trans-unit id="598292bc5270606189fdedc665ef492ceced68f0" translate="yes" xml:space="preserve">
          <source>The entire random number library architecture is derived from the excellent &lt;a href=&quot;http://open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2461.pdf&quot;&gt;C++0X&lt;/a&gt; random number facility proposed by Jens Maurer and contributed to by researchers at the Fermi laboratory (excluding Xorshift).</source>
          <target state="translated">전체 난수 라이브러리 아키텍처는 Jens Maurer가 제안한 우수한 &lt;a href=&quot;http://open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2461.pdf&quot;&gt;C ++ 0X&lt;/a&gt; 난수 기능 에서 파생되었으며 Fermi 연구소의 연구원 (Xorshift 제외)이 제공했습니다.</target>
        </trans-unit>
        <trans-unit id="888201d962022c79856dc1d83803a781978d38cd" translate="yes" xml:space="preserve">
          <source>The equality and inequality operators are treated separately because while practically all user-defined types can be compared for equality, only a subset of types have a meaningful ordering. For example, while it makes sense to determine if two RGB color vectors are equal, it is not meaningful to say that one color is greater than another, because colors do not have an ordering. Thus, one would define &lt;code&gt;opEquals&lt;/code&gt; for a &lt;code&gt;Color&lt;/code&gt; type, but not &lt;code&gt;opCmp&lt;/code&gt;.</source>
          <target state="translated">동등성 및 부등식 연산자는 실질적으로 모든 사용자 정의 형식을 동일하게 비교할 수 있지만 형식의 하위 집합 만 의미있는 순서를 갖기 때문에 개별적으로 처리됩니다. 예를 들어, 두 RGB 색상 벡터가 같은지 확인하는 것이 합리적이지만 색상에는 순서가 없기 때문에 한 색상이 다른 색상보다 크다고 말하는 것은 의미가 없습니다. 따라서 &lt;code&gt;Color&lt;/code&gt; 유형에 대해서는 &lt;code&gt;opEquals&lt;/code&gt; 를 정의 하지만 &lt;code&gt;opCmp&lt;/code&gt; 는 정의 하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="8b1ab6f47e6e402fb3a24bfb9f554e1d0036e9f7" translate="yes" xml:space="preserve">
          <source>The equivalent of member function pointers can be constructed using anonymous lambda functions:</source>
          <target state="translated">익명의 람다 함수를 사용하여 동등한 멤버 함수 포인터를 구성 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b934e5ce8d172dbc9fefc885ad8f4ba875129f8a" translate="yes" xml:space="preserve">
          <source>The error message incase &lt;code&gt;version != D_TypeInfo&lt;/code&gt;</source>
          <target state="translated">오류 메시지 incase &lt;code&gt;version != D_TypeInfo&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="74494fb82c47edd9793007790b8ec76ed5efb325" translate="yes" xml:space="preserve">
          <source>The error message to put in the exception if it is thrown.</source>
          <target state="translated">예외가 발생하면 예외에 넣을 오류 메시지입니다.</target>
        </trans-unit>
        <trans-unit id="ac179c7a25f054b9a84b196608bf4de9e907b671" translate="yes" xml:space="preserve">
          <source>The error number.</source>
          <target state="translated">오류 번호</target>
        </trans-unit>
        <trans-unit id="bb2bfcd8d277ad988cd58683c68c61867529b4d8" translate="yes" xml:space="preserve">
          <source>The escape sequences listed in &lt;a href=&quot;#EscapeSequence&quot;&gt;&lt;i&gt;EscapeSequence&lt;/i&gt;&lt;/a&gt; are:</source>
          <target state="translated">&lt;a href=&quot;#EscapeSequence&quot;&gt;&lt;i&gt;EscapeSequence&lt;/i&gt;&lt;/a&gt; 에 나열된 이스케이프 시퀀스는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="813068399b629e54556fe2331c136edacd43967a" translate="yes" xml:space="preserve">
          <source>The escapes section is a series of substitutions which replace special characters with a string. It's useful when the output format requires escaping of certain characters, for example in HTML &lt;b&gt;&amp;amp;&lt;/b&gt; should be escaped with &lt;b&gt;&amp;amp;amp;&lt;/b&gt;.</source>
          <target state="translated">이스케이프 섹션은 특수 문자를 문자열로 대체하는 일련의 대체입니다. 출력 형식이 특정 문자를 이스케이프해야하는 경우에 유용합니다 (예 : HTML에서 &lt;b&gt;&amp;amp;&lt;/b&gt; 는 &lt;b&gt;&amp;amp; amp; &lt;/b&gt;.</target>
        </trans-unit>
        <trans-unit id="75a80775312b743d79dc5f0458ad6638745e66ff" translate="yes" xml:space="preserve">
          <source>The event handler that gets called to inform of upload/download progress.</source>
          <target state="translated">업로드 / 다운로드 진행률을 알리기 위해 호출되는 이벤트 핸들러입니다.</target>
        </trans-unit>
        <trans-unit id="28ee4bbd0a86e9401b5c283e4626c6777888197c" translate="yes" xml:space="preserve">
          <source>The event handler that gets called when data is needed for sending.</source>
          <target state="translated">전송에 데이터가 필요할 때 호출되는 이벤트 핸들러입니다.</target>
        </trans-unit>
        <trans-unit id="ec0b1eb03ea092eed8857727c86d04dbd3bf6621" translate="yes" xml:space="preserve">
          <source>The event handler that gets called when data is needed for sending. The length of the &lt;code&gt;void[]&lt;/code&gt; specifies the maximum number of bytes that can be sent.</source>
          <target state="translated">전송에 데이터가 필요할 때 호출되는 이벤트 핸들러입니다. &lt;code&gt;void[]&lt;/code&gt; 의 길이는 보낼 수있는 최대 바이트 수를 지정합니다.</target>
        </trans-unit>
        <trans-unit id="c126a38e12f3ea900a6ea7dfdda2e34138f69566" translate="yes" xml:space="preserve">
          <source>The event handler that gets called when the curl backend needs to seek the data to be sent.</source>
          <target state="translated">curl 백엔드가 전송 될 데이터를 찾아야 할 때 호출되는 이벤트 핸들러입니다.</target>
        </trans-unit>
        <trans-unit id="c7e1c85c7ca7e98c1826ed981521b324453ed7c7" translate="yes" xml:space="preserve">
          <source>The event handler that gets called when the net socket has been created but a &lt;code&gt;connect()&lt;/code&gt; call has not yet been done. This makes it possible to set misc. socket options.</source>
          <target state="translated">net 소켓이 작성되었지만 &lt;code&gt;connect()&lt;/code&gt; 호출이 아직 완료되지 않았을 때 호출되는 이벤트 핸들러 . 기타를 설정할 수 있습니다. 소켓 옵션.</target>
        </trans-unit>
        <trans-unit id="02f312ca0b7e961f5a4f5917e4aa7edb41e07360" translate="yes" xml:space="preserve">
          <source>The event handler that receives incoming data.</source>
          <target state="translated">들어오는 데이터를받는 이벤트 핸들러입니다.</target>
        </trans-unit>
        <trans-unit id="b87e0289d3effbf7cf04a5f7cfbfced82cc1d3d4" translate="yes" xml:space="preserve">
          <source>The event handler that receives incoming data. Be sure to copy the incoming ubyte[] since it is not guaranteed to be valid after the callback returns.</source>
          <target state="translated">들어오는 데이터를받는 이벤트 핸들러입니다. 콜백이 리턴 된 후에는 수신 ubyte []가 유효하지 않으므로 반드시 복사하십시오.</target>
        </trans-unit>
        <trans-unit id="4c604b49f0361c7bde910df7da9e4d17ed0e24e3" translate="yes" xml:space="preserve">
          <source>The event handler that receives incoming headers for protocols that uses headers.</source>
          <target state="translated">헤더를 사용하는 프로토콜에 대한 수신 헤더를받는 이벤트 핸들러입니다.</target>
        </trans-unit>
        <trans-unit id="52a6be95e3d2f965951f9ddade7c43108c67742d" translate="yes" xml:space="preserve">
          <source>The event module provides a primitive for lightweight signaling of other threads (emulating Windows events on Posix)</source>
          <target state="translated">이벤트 모듈은 다른 스레드 (Posix에서 Windows 이벤트 에뮬레이션)의 간단한 신호 전달을위한 기본 요소를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="76cbd20f024df6b80d67a632d5c0a1a01fd91d83" translate="yes" xml:space="preserve">
          <source>The exact format is exactly as described in &lt;code&gt;toISOExtString&lt;/code&gt; except that trailing zeroes are permitted - including having fractional seconds with all zeroes. However, a decimal point with nothing following it is invalid. Also, while &lt;a href=&quot;#toISOExtString&quot;&gt;&lt;code&gt;toISOExtString&lt;/code&gt;&lt;/a&gt; will never generate a string with more than 7 digits in the fractional seconds (because that's the limit with hecto-nanosecond precision), it will allow more than 7 digits in order to read strings from other sources that have higher precision (however, any digits beyond 7 will be truncated).</source>
          <target state="translated">정확한 형식은 모든 0으로 소수 초를 포함하여 후행 0이 허용 &lt;code&gt;toISOExtString&lt;/code&gt; 점을 제외하고 는 toISOExtString에 설명 된 것과 동일합니다. 그러나 그 뒤에 아무것도없는 소수점은 유효하지 않습니다. 또한 &lt;a href=&quot;#toISOExtString&quot;&gt; &lt;code&gt;toISOExtString&lt;/code&gt; &lt;/a&gt; 은 분수 초 단위로 7 자리를 초과하는 문자열을 생성하지 않지만 (정수 나 초 단위 정밀도의 한계이기 때문에) 더 높은 정밀도를 가진 다른 소스에서 문자열을 읽으려면 7 자리를 초과 할 수 있습니다 ( 그러나 7보다 큰 숫자는 잘립니다.)</target>
        </trans-unit>
        <trans-unit id="dbfdac6af98f1a47c12d787fa314f16848732e36" translate="yes" xml:space="preserve">
          <source>The exact format is exactly as described in &lt;code&gt;toISOString&lt;/code&gt; except that trailing zeroes are permitted - including having fractional seconds with all zeroes. However, a decimal point with nothing following it is invalid. Also, while &lt;a href=&quot;#toISOString&quot;&gt;&lt;code&gt;toISOString&lt;/code&gt;&lt;/a&gt; will never generate a string with more than 7 digits in the fractional seconds (because that's the limit with hecto-nanosecond precision), it will allow more than 7 digits in order to read strings from other sources that have higher precision (however, any digits beyond 7 will be truncated).</source>
          <target state="translated">정확한 형식은 모든 0이있는 소수 초를 포함하여 후행 0이 허용 &lt;code&gt;toISOString&lt;/code&gt; 점을 제외하고 는 toISOString에 설명 된 것과 동일합니다. 그러나 그 뒤에 아무것도없는 소수점은 유효하지 않습니다. 또한 &lt;a href=&quot;#toISOString&quot;&gt; &lt;code&gt;toISOString&lt;/code&gt; &lt;/a&gt; 은 소수 초에 7 자리를 초과하는 문자열을 생성하지 않지만 (정수 나 초 단위 정밀도의 한계이므로) 정밀도가 높은 다른 소스에서 문자열을 읽으려면 7 자리를 초과 할 수 있습니다 ( 그러나 7보다 큰 숫자는 잘립니다.)</target>
        </trans-unit>
        <trans-unit id="8035aabeb60ff48fad9d3507168fac10a852f522" translate="yes" xml:space="preserve">
          <source>The exact format is exactly as described in &lt;code&gt;toSimpleString&lt;/code&gt; except that trailing zeroes are permitted - including having fractional seconds with all zeroes. However, a decimal point with nothing following it is invalid. Also, while &lt;a href=&quot;#toSimpleString&quot;&gt;&lt;code&gt;toSimpleString&lt;/code&gt;&lt;/a&gt; will never generate a string with more than 7 digits in the fractional seconds (because that's the limit with hecto-nanosecond precision), it will allow more than 7 digits in order to read strings from other sources that have higher precision (however, any digits beyond 7 will be truncated).</source>
          <target state="translated">정확한 형식은 &lt;code&gt;toSimpleString&lt;/code&gt; 에 설명 된 것과 동일합니다. 단, 모든 0이있는 소수 초를 포함하여 후행 0이 허용됩니다. 그러나 그 뒤에 아무것도없는 소수점은 유효하지 않습니다. 또한 &lt;a href=&quot;#toSimpleString&quot;&gt; &lt;code&gt;toSimpleString&lt;/code&gt; &lt;/a&gt; 은 분수 초 단위로 7 자리를 초과하는 문자열을 생성하지 않지만 (정수 나 초 단위 정밀도의 한계이기 때문에) 정밀도가 높은 다른 소스에서 문자열을 읽으려면 7 자리를 초과 할 수 있습니다 ( 그러나 7보다 큰 숫자는 잘립니다.)</target>
        </trans-unit>
        <trans-unit id="65836ccc655a37d33dfc806f525851b4dc381228" translate="yes" xml:space="preserve">
          <source>The example above creates a tagged pointer in the struct A. The pointer is of type &lt;code&gt;uint*&lt;/code&gt; as specified by the first argument, and is named x, as specified by the second argument.</source>
          <target state="translated">위의 예제는 구조체 A에 태그가 지정된 포인터를 만듭니다. 포인터는 첫 번째 인수에 의해 지정된 &lt;code&gt;uint*&lt;/code&gt; 유형 이고 두 번째 인수에 의해 지정된 x라는 이름입니다.</target>
        </trans-unit>
        <trans-unit id="a8289a8de27bbcdd9e4b7b9885e6899b4349a782" translate="yes" xml:space="preserve">
          <source>The example above creates a tagged reference to an Object in the struct A. This expects the same parameters as &lt;code&gt;taggedPointer&lt;/code&gt;, except the first argument which must be a class type instead of a pointer type.</source>
          <target state="translated">위의 예제는 구조체 A에서 Object에 태그가 지정된 참조를 만듭니다. 이는 포인터 유형 대신 클래스 유형이어야하는 첫 번째 인수를 제외하고 &lt;code&gt;taggedPointer&lt;/code&gt; 와 동일한 매개 변수를 예상합니다 .</target>
        </trans-unit>
        <trans-unit id="95c0102684861c4577b62ad69eb70ff34b2390d6" translate="yes" xml:space="preserve">
          <source>The example above wreaks havoc on client code because it is modifying arrays that callers considered immutable. To obtain an immutable array from the writable array &lt;code&gt;buffer&lt;/code&gt;, replace the last line with:</source>
          <target state="translated">위의 예제는 호출자가 불변으로 간주되는 배열을 수정하기 때문에 클라이언트 코드를 혼란스럽게 만듭니다. 쓰기 가능한 배열 &lt;code&gt;buffer&lt;/code&gt; 에서 불변 배열을 얻으려면 마지막 행을 다음으로 바꾸십시오.</target>
        </trans-unit>
        <trans-unit id="399a22d99c9e7b3b5ee30ddef81ec062aec6bdce" translate="yes" xml:space="preserve">
          <source>The example below features an allocator modeled after &lt;a href=&quot;http://goo.gl/m7329l&quot;&gt;jemalloc&lt;/a&gt;, which uses a battery of free-list allocators spaced so as to keep internal fragmentation to a minimum. The &lt;code&gt;FList&lt;/code&gt; definitions specify no bounds for the freelist because the &lt;code&gt;Segregator&lt;/code&gt; does all size selection in advance.</source>
          <target state="translated">아래 예는 &lt;a href=&quot;http://goo.gl/m7329l&quot;&gt;jemalloc을&lt;/a&gt; 모델로 한 할당자를 특징으로하며 , 이는 내부 조각화를 최소로 유지하기 위해 여유 목록 할당 자의 배터리를 사용합니다. &lt;code&gt;Segregator&lt;/code&gt; 가 모든 크기 선택을 미리 수행 하므로 &lt;code&gt;FList&lt;/code&gt; 정의 는 자유 목록에 대한 경계를 지정하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="03c82011a176c73b7fd2e55e8d4ca5d5e5bc2671" translate="yes" xml:space="preserve">
          <source>The example sets a new &lt;code&gt;FileLogger&lt;/code&gt; as new &lt;code&gt;sharedLog&lt;/code&gt;.  If at some point you want to use the original default logger again, you can use &lt;code&gt;sharedLog = null;&lt;/code&gt;. This will put back the original.</source>
          <target state="translated">이 예에서는 새 &lt;code&gt;FileLogger&lt;/code&gt; 를 new &lt;code&gt;sharedLog&lt;/code&gt; 로 설정합니다 . 어느 시점에서 원래 기본 로거를 다시 사용하려는 경우 &lt;code&gt;sharedLog = null;&lt;/code&gt; . 원본이 다시 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="ad582bc954e72accfcbe7e749d32e98547d0b17c" translate="yes" xml:space="preserve">
          <source>The exception module defines all system-level exceptions and provides a mechanism to alter system-level error handling.</source>
          <target state="translated">예외 모듈은 모든 시스템 수준 예외를 정의하고 시스템 수준 오류 처리를 변경하는 메커니즘을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="7a6c8dd2c388cd128d91f81fff3c160065b3f34b" translate="yes" xml:space="preserve">
          <source>The exception thrown during finalization.</source>
          <target state="translated">종료하는 동안 예외가 발생했습니다.</target>
        </trans-unit>
        <trans-unit id="9e6c1b1caa6f537b3b32ae230a3319f2a84949f0" translate="yes" xml:space="preserve">
          <source>The exception to throw if the value evaluates to false.</source>
          <target state="translated">값이 false로 평가되면 발생하는 예외입니다.</target>
        </trans-unit>
        <trans-unit id="cbc3d84209a76290f33343978e317c76e214fa4c" translate="yes" xml:space="preserve">
          <source>The exponent is negative and the factor is one, i.e., output[j] := sum[ exp(-2 PI i j k / N) input[k] ].</source>
          <target state="translated">지수는 음수이고 인수는 1입니다. 즉 출력 [j] : = sum [exp (-2 PI ijk / N) 입력 [k]].</target>
        </trans-unit>
        <trans-unit id="08786360cdc12838546c00b5767cf2cab959b50c" translate="yes" xml:space="preserve">
          <source>The exponent is positive and the factor is 1/N, i.e., output[j] := (1 / N) sum[ exp(+2 PI i j k / N) input[k] ].</source>
          <target state="translated">지수는 양수이고 계수는 1 / N입니다. 즉, 출력 [j] : = (1 / N) 합 [exp (+2 PI ijk / N) 입력 [k]].</target>
        </trans-unit>
        <trans-unit id="c871c5d07aafe7ec6925f7e7fae1500b032e2b52" translate="yes" xml:space="preserve">
          <source>The expression and the errorHandler must have a common type they can both be implicitly casted to, and that type will be the type of the compound expression.</source>
          <target state="translated">표현식과 errorHandler는 내재적으로 캐스트 될 수있는 공통 유형을 가져야하며 해당 유형은 복합 표현식의 유형입니다.</target>
        </trans-unit>
        <trans-unit id="34375c5ee3f5635a2e38da6b0e76fc609894c573" translate="yes" xml:space="preserve">
          <source>The expression asserted not to throw.</source>
          <target state="translated">그 표현은 던지지 말 것을 주장했다.</target>
        </trans-unit>
        <trans-unit id="940dd3375faca27ce190b8fb03def99092a3aab1" translate="yes" xml:space="preserve">
          <source>The expression form is:</source>
          <target state="translated">표현 형식은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="cc54de17f165e5e9a2ba7fa962f4eecaa39f90b2" translate="yes" xml:space="preserve">
          <source>The expression is evaluated.</source>
          <target state="translated">식이 평가됩니다.</target>
        </trans-unit>
        <trans-unit id="22a556158ebfbc64522a677428ab0391c34f8183" translate="yes" xml:space="preserve">
          <source>The expression that copy constructs or moves the value.</source>
          <target state="translated">복사하는 표현식은 값을 구성하거나 이동합니다.</target>
        </trans-unit>
        <trans-unit id="91f707cf0e8e3128051036fb96ff3b7693733b1d" translate="yes" xml:space="preserve">
          <source>The expression to resolve as type or symbol.</source>
          <target state="translated">유형 또는 기호로 해석 할 표현식입니다.</target>
        </trans-unit>
        <trans-unit id="29c4204e99277952fc7a54ab66543bc42d61a803" translate="yes" xml:space="preserve">
          <source>The expression to run and return its result.</source>
          <target state="translated">실행하고 결과를 리턴하는 표현식입니다.</target>
        </trans-unit>
        <trans-unit id="92d0bb2bd94dd52b7503e678d48be02f028860ef" translate="yes" xml:space="preserve">
          <source>The expression to test.</source>
          <target state="translated">테스트 할 표현식입니다.</target>
        </trans-unit>
        <trans-unit id="3ba5f3fe8e3c4ad3783ea96faee9ce1e4526ddb4" translate="yes" xml:space="preserve">
          <source>The expression which may throw an exception.</source>
          <target state="translated">예외가 발생할 수있는 표현식입니다.</target>
        </trans-unit>
        <trans-unit id="646fe39033d4569a34021185a6750173a3852965" translate="yes" xml:space="preserve">
          <source>The expression:</source>
          <target state="translated">표현식:</target>
        </trans-unit>
        <trans-unit id="24968438ed1fc3f9aa123f08e882cf9dcb629a30" translate="yes" xml:space="preserve">
          <source>The extension part of a file name, including the dot.  If there is no extension, &lt;code&gt;null&lt;/code&gt; is returned.</source>
          <target state="translated">점을 포함하여 파일 이름의 확장자 부분. 확장명이 없으면 &lt;code&gt;null&lt;/code&gt; 이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="001c41a8faed92276e0710e5f77bacf1f43befe9" translate="yes" xml:space="preserve">
          <source>The extra *'s and +'s on the comment opening, closing and left margin are ignored and are not part of the embedded documentation. Comments not following one of those forms are not documentation comments.</source>
          <target state="translated">주석 열기, 닫기 및 왼쪽 여백에있는 여분의 *와 +는 무시되며 내장 문서의 일부가 아닙니다. 이러한 양식 중 하나를 따르지 않는 주석은 문서 ​​주석이 아닙니다.</target>
        </trans-unit>
        <trans-unit id="60cbf9a8b6c782eeaf3b240238aaad4006024e93" translate="yes" xml:space="preserve">
          <source>The factory should print an error and abort the program if it cannot successfully initialize the GC instance.</source>
          <target state="translated">팩토리는 GC 인스턴스를 성공적으로 초기화 할 수없는 경우 오류를 인쇄하고 프로그램을 중단해야합니다.</target>
        </trans-unit>
        <trans-unit id="f5a2d7b1faf4a00e391206a0b6d040b1dd55f507" translate="yes" xml:space="preserve">
          <source>The fallback allocator.</source>
          <target state="translated">대체 할당 자.</target>
        </trans-unit>
        <trans-unit id="6444c34b4999b63334e3fe1c10565688c176440d" translate="yes" xml:space="preserve">
          <source>The fiber function.</source>
          <target state="translated">섬유 기능.</target>
        </trans-unit>
        <trans-unit id="4ebf4ba0f41676101df65de78d14565377976d26" translate="yes" xml:space="preserve">
          <source>The fiber object representing the calling fiber or null if no fiber is currently active within this thread. The result of deleting this object is undefined.</source>
          <target state="translated">호출 파이버를 나타내는 파이버 객체. 현재이 스레드에서 활성화 된 파이버가없는 경우 null입니다. 이 객체를 삭제 한 결과는 정의되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="7163e2b220c5c73c7ee35da99996a1282317d054" translate="yes" xml:space="preserve">
          <source>The field is ended when there is no input, even if the quote was not closed.</source>
          <target state="translated">따옴표가 닫히지 않아도 입력이 없으면 필드가 종료됩니다.</target>
        </trans-unit>
        <trans-unit id="779d09c98e4cfcdaab8d2edfcd062b2bc1c5fe62" translate="yes" xml:space="preserve">
          <source>The fields below this were added in CURLVERSION_SECOND</source>
          <target state="translated">이 아래의 필드는 CURLVERSION_SECOND에 추가되었습니다.</target>
        </trans-unit>
        <trans-unit id="7fb4d8eebf35f6bbc1f833a412d5cc7420dea229" translate="yes" xml:space="preserve">
          <source>The file (or directory) to get a DirEntry for.</source>
          <target state="translated">DirEntry를 가져올 파일 (또는 디렉토리)입니다.</target>
        </trans-unit>
        <trans-unit id="40dabb9eb8e81154153036d71178601514e1f7f3" translate="yes" xml:space="preserve">
          <source>The file and line of the call.</source>
          <target state="translated">통화의 파일과 회선.</target>
        </trans-unit>
        <trans-unit id="2587d80da404ef88f56c1d45c26f059538ee948c" translate="yes" xml:space="preserve">
          <source>The file attributes or 0 if the file attributes were encoded for an incompatible OS (Windows vs. Posix).</source>
          <target state="translated">파일 속성 또는 파일 속성이 호환되지 않는 OS (Windows와 Posix)로 인코딩 된 경우 0입니다.</target>
        </trans-unit>
        <trans-unit id="f357296885e979c9eb815032610719a979731bd8" translate="yes" xml:space="preserve">
          <source>The file attributes.</source>
          <target state="translated">파일 속성</target>
        </trans-unit>
        <trans-unit id="21cf4d39fea8701f9ccea1f6e9c33a8dca629be0" translate="yes" xml:space="preserve">
          <source>The file name of the D source code corresponding with where the error was thrown from.</source>
          <target state="translated">오류가 발생한 위치에 해당하는 D 소스 코드의 파일 이름입니다.</target>
        </trans-unit>
        <trans-unit id="b64522363b929d137710605ff07b8daf334bc620" translate="yes" xml:space="preserve">
          <source>The file name to show. If not set, the actual file name will be used (if this is a file part)</source>
          <target state="translated">표시 할 파일 이름입니다. 설정하지 않으면 실제 파일 이름이 사용됩니다 (파일 부분 인 경우).</target>
        </trans-unit>
        <trans-unit id="bf8ad1ee8706b576c3d861ca4c35b04004625b5d" translate="yes" xml:space="preserve">
          <source>The file names for packages and modules should also be composed of the ASCII characters lower case letters, digits or &lt;code&gt;_&lt;/code&gt; and should not be a &lt;a href=&quot;lex#Keyword&quot;&gt;&lt;i&gt;Keyword&lt;/i&gt;&lt;/a&gt;.</source>
          <target state="translated">패키지 및 모듈의 파일 이름은 ASCII 문자 소문자, 숫자 또는 &lt;code&gt;_&lt;/code&gt; 로 구성되어야하며 &lt;a href=&quot;lex#Keyword&quot;&gt;&lt;i&gt;키워드&lt;/i&gt;&lt;/a&gt; 가 아니어야합니다 .</target>
        </trans-unit>
        <trans-unit id="27e521d84e71e057af31f6b16036a8dda6098775" translate="yes" xml:space="preserve">
          <source>The file that is being linked. This is the target path that's stored in the symlink. A relative path is relative to the created symlink.</source>
          <target state="translated">링크되는 파일입니다. 심볼릭 링크에 저장된 대상 경로입니다. 상대 경로는 생성 된 심볼릭 링크를 기준으로합니다.</target>
        </trans-unit>
        <trans-unit id="a48d130bf6ed7fe001b9b68c13bd4356b06eb640" translate="yes" xml:space="preserve">
          <source>The file that the &lt;a href=&quot;#DateTimeException&quot;&gt;&lt;code&gt;DateTimeException&lt;/code&gt;&lt;/a&gt; will list if thrown.</source>
          <target state="translated">발생 된 경우 &lt;a href=&quot;#DateTimeException&quot;&gt; &lt;code&gt;DateTimeException&lt;/code&gt; &lt;/a&gt; 이 나열 할 파일입니다 .</target>
        </trans-unit>
        <trans-unit id="886ddc5df982fa3a52b4dae1cc5e097e3fae8531" translate="yes" xml:space="preserve">
          <source>The file to get the attributes of.</source>
          <target state="translated">속성을 가져올 파일입니다.</target>
        </trans-unit>
        <trans-unit id="c5856ac3b9ed35958ce9f401bbff0c265bcd66da" translate="yes" xml:space="preserve">
          <source>The file to get the symbolic link attributes of.</source>
          <target state="translated">기호 링크 속성을 가져올 파일입니다.</target>
        </trans-unit>
        <trans-unit id="d5a902223a6a641c14dbfbc008db96721d6af330" translate="yes" xml:space="preserve">
          <source>The file used for logging.</source>
          <target state="translated">로깅에 사용되는 파일입니다.</target>
        </trans-unit>
        <trans-unit id="f7969ce864cdb7d64da59da6dfc8b40cf28ba7bb" translate="yes" xml:space="preserve">
          <source>The file where the error occurred.</source>
          <target state="translated">오류가 발생한 파일입니다.</target>
        </trans-unit>
        <trans-unit id="3ff1fcb05fd162b545299ba30ad59377c1eb86a5" translate="yes" xml:space="preserve">
          <source>The file where the error occurred. Defaults to &lt;code&gt;__FILE__&lt;/code&gt;.</source>
          <target state="translated">오류가 발생한 파일입니다. 기본값은 &lt;code&gt;__FILE__&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="9a7b4c097e4526bdecb31861d25a87231f1a612b" translate="yes" xml:space="preserve">
          <source>The file where the exception occurred.</source>
          <target state="translated">예외가 발생한 파일입니다.</target>
        </trans-unit>
        <trans-unit id="2a8a857ec47a034acf4c2fcaed0de229c31869d5" translate="yes" xml:space="preserve">
          <source>The filename of the &lt;code&gt;File&lt;/code&gt; log messages are written to.</source>
          <target state="translated">&lt;code&gt;File&lt;/code&gt; 로그 메시지 의 파일 이름 이 기록됩니다.</target>
        </trans-unit>
        <trans-unit id="37dc45c1af7cba50c135f406c906822e95a5938d" translate="yes" xml:space="preserve">
          <source>The filename of the output file of the &lt;code&gt;FileLogger&lt;/code&gt;. If that file can not be opened for writting an exception will be thrown.</source>
          <target state="translated">&lt;code&gt;FileLogger&lt;/code&gt; 출력 파일의 파일 이름입니다 . 해당 파일을 쓰기 위해 열 수 없으면 예외가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="3910614447549528bc2d2fc1be565210c1526e11" translate="yes" xml:space="preserve">
          <source>The finish function returns the final hash sum and resets the Digest.</source>
          <target state="translated">finish 함수는 최종 해시 합계를 반환하고 다이제스트를 재설정합니다.</target>
        </trans-unit>
        <trans-unit id="133d5dd83ff02e493d05a0e47c1deb319a8252d7" translate="yes" xml:space="preserve">
          <source>The finish function returns the hash value. It takes an optional buffer to copy the data into. If a buffer is passed, it must be at least &lt;a href=&quot;#length&quot;&gt;&lt;code&gt;length&lt;/code&gt;&lt;/a&gt; bytes big.</source>
          <target state="translated">finish 함수는 해시 값을 반환합니다. 데이터를 복사하려면 선택적 버퍼가 필요합니다. 버퍼가 전달되면 최소한 &lt;a href=&quot;#length&quot;&gt; &lt;code&gt;length&lt;/code&gt; &lt;/a&gt; 바이트 이상이어야합니다 .</target>
        </trans-unit>
        <trans-unit id="22bbeb22c4ba0a11e694a3fb88ce4ce66c1aa8c4" translate="yes" xml:space="preserve">
          <source>The finish function returns the hash value. It takes an optional buffer to copy the data into. If a buffer is passed, it must have a length at least &lt;a href=&quot;#length&quot;&gt;&lt;code&gt;length&lt;/code&gt;&lt;/a&gt; bytes.</source>
          <target state="translated">finish 함수는 해시 값을 반환합니다. 데이터를 복사하려면 선택적 버퍼가 필요합니다. 버퍼가 전달되면 길이는 최소한 &lt;a href=&quot;#length&quot;&gt; &lt;code&gt;length&lt;/code&gt; &lt;/a&gt; 바이트 이상이어야 합니다.</target>
        </trans-unit>
        <trans-unit id="957dc77c438abefa8c77eaf7563108a790ce4d94" translate="yes" xml:space="preserve">
          <source>The first</source>
          <target state="translated">첫번째</target>
        </trans-unit>
        <trans-unit id="a33576b80d4f4e8bd604397c308091bd4d49eeac" translate="yes" xml:space="preserve">
          <source>The first &lt;code&gt;Exception&lt;/code&gt; which was bypassed when this Error was thrown, or &lt;code&gt;null&lt;/code&gt; if no &lt;code&gt;Exception&lt;/code&gt;s were pending.</source>
          <target state="translated">이 오류가 발생했을 때 무시 된 최초의 &lt;code&gt;Exception&lt;/code&gt; . 보류중인 &lt;code&gt;Exception&lt;/code&gt; &lt;code&gt;null&lt;/code&gt; 경우는 null</target>
        </trans-unit>
        <trans-unit id="83bd533ac7ce9ad8a841e8cf9ee5bfbb37b7a8f6" translate="yes" xml:space="preserve">
          <source>The first &lt;code&gt;v1&lt;/code&gt; for which &lt;code&gt;v1 &amp;gt; v2&lt;/code&gt; is true determines the result. This could lead to unexpected behaviour.</source>
          <target state="translated">제 &lt;code&gt;v1&lt;/code&gt; 되는 &lt;code&gt;v1 &amp;gt; v2&lt;/code&gt; 참이 결과를 판정한다. 예기치 않은 동작이 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ba9501cbc71e13c8461adcfc7cfb46ad49a3228f" translate="yes" xml:space="preserve">
          <source>The first argument for the predicate.</source>
          <target state="translated">술어에 대한 첫 번째 인수.</target>
        </trans-unit>
        <trans-unit id="d76b59c9568cb4d5adeddeb8e61ac34ba34641de" translate="yes" xml:space="preserve">
          <source>The first argument is a class type or an expression of class type. The second argument is a string that matches the name of one of the functions of that class. The result is a tuple of the virtual overloads of that function. It does not include final functions that do not override anything.</source>
          <target state="translated">첫 번째 인수는 클래스 유형 또는 클래스 유형의 표현식입니다. 두 번째 인수는 해당 클래스의 함수 중 하나의 이름과 일치하는 문자열입니다. 결과적으로 해당 기능의 가상 과부하가 터플됩니다. 대체하지 않는 최종 기능은 포함하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="dd726d5af5bf0120b5bd49b63370601b230f8cd3" translate="yes" xml:space="preserve">
          <source>The first argument is a type that has members, or is an expression of a type that has members. The second argument is a string. If the string is a valid property of the type, &lt;code&gt;true&lt;/code&gt; is returned, otherwise &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">첫 번째 인수는 멤버가있는 유형이거나 멤버가있는 유형의 표현식입니다. 두 번째 인수는 문자열입니다. 문자열이 유효한 유형의 속성 &lt;code&gt;true&lt;/code&gt; 가 반환되고 그렇지 않으면 &lt;code&gt;false&lt;/code&gt; 가 반환 됩니다.</target>
        </trans-unit>
        <trans-unit id="1a43e4ec8b9b76809401c1e8287827f1c5ded36c" translate="yes" xml:space="preserve">
          <source>The first argument is an aggregate (e.g. struct/class/module). The second argument is a &lt;code&gt;string&lt;/code&gt; that matches the name of the member(s) to return. The third argument is a &lt;code&gt;bool&lt;/code&gt;, and is optional. If &lt;code&gt;true&lt;/code&gt;, the result will also include template overloads. The result is a tuple of all the overloads of the supplied name.</source>
          <target state="translated">첫 번째 인수는 집계입니다 (예 : struct / class / module). 두 번째 인수는 반환 할 멤버의 이름과 일치 하는 &lt;code&gt;string&lt;/code&gt; 입니다. 세 번째 인수는 &lt;code&gt;bool&lt;/code&gt; 이며 선택 사항입니다. 경우 &lt;code&gt;true&lt;/code&gt; 결과는 템플릿 과부하도 포함됩니다. 결과는 제공된 이름의 모든 과부하의 튜플입니다.</target>
        </trans-unit>
        <trans-unit id="2a174554ed3bb0d11c52209ee3ed7c598d6bcaa6" translate="yes" xml:space="preserve">
          <source>The first argument of &lt;code&gt;Checked&lt;/code&gt;, e.g. &lt;code&gt;int&lt;/code&gt; if the left-hand side of the operator is &lt;code&gt;Checked!int&lt;/code&gt;</source>
          <target state="translated">첫 번째 인수 &lt;code&gt;Checked&lt;/code&gt; 예 &lt;code&gt;int&lt;/code&gt; 오퍼레이터의 좌측이 경우 &lt;code&gt;Checked!int&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="8841f05f16f8289043fb3adb8a0d9f6c62e9f3bb" translate="yes" xml:space="preserve">
          <source>The first argument that passes the test &lt;code&gt;pred&lt;/code&gt;.</source>
          <target state="translated">테스트 &lt;code&gt;pred&lt;/code&gt; 를 통과 한 첫 번째 인수입니다 .</target>
        </trans-unit>
        <trans-unit id="6f69babce0033893a00ba9dd4fdded8c5d91d428" translate="yes" xml:space="preserve">
          <source>The first argument to apply to &lt;code&gt;fun&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;fun&lt;/code&gt; 에 적용 할 첫 번째 주장</target>
        </trans-unit>
        <trans-unit id="5e0881d9245470375fca9c2a63d7fd75c1ab511d" translate="yes" xml:space="preserve">
          <source>The first array to compare</source>
          <target state="translated">비교할 첫 번째 배열</target>
        </trans-unit>
        <trans-unit id="6402ea9c3911f868771a9ad2ee306a3ff47b76c7" translate="yes" xml:space="preserve">
          <source>The first choice that &lt;code&gt;switchObject&lt;/code&gt; can be casted to the type of argument it accepts will be called with &lt;code&gt;switchObject&lt;/code&gt; casted to that type, and the value it'll return will be returned by &lt;code&gt;castSwitch&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;switchObject&lt;/code&gt; 가 허용하는 인수 유형으로 캐스트 될 수있는 첫 번째 선택은 해당 유형으로 캐스트 된 &lt;code&gt;switchObject&lt;/code&gt; 와 함께 호출되며 , 리턴 할 값은 &lt;code&gt;castSwitch&lt;/code&gt; 에 의해 리턴됩니다 .</target>
        </trans-unit>
        <trans-unit id="8c0a3698b1be7dcab735cd7cac7d279e510c1569" translate="yes" xml:space="preserve">
          <source>The first element of the array is the size of the type (for classes it is the &lt;a href=&quot;#classInstanceSize&quot;&gt;&lt;i&gt;classInstanceSize&lt;/i&gt;&lt;/a&gt;).</source>
          <target state="translated">배열의 첫 번째 요소는 유형의 크기입니다 (클래스의 경우 &lt;a href=&quot;#classInstanceSize&quot;&gt;&lt;i&gt;classInstanceSize입니다&lt;/i&gt;&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="d156d92ea93ea0bd49c4929ebca8565a10591e92" translate="yes" xml:space="preserve">
          <source>The first element of the array.</source>
          <target state="translated">배열의 첫 번째 요소</target>
        </trans-unit>
        <trans-unit id="d8e16b70885d5121ddc9494a6960e6bb4c96cb43" translate="yes" xml:space="preserve">
          <source>The first expression is converted to &lt;code&gt;bool&lt;/code&gt;, and is evaluated.</source>
          <target state="translated">첫 번째 표현식은 &lt;code&gt;bool&lt;/code&gt; 로 변환되어 평가됩니다.</target>
        </trans-unit>
        <trans-unit id="cf9e5f533fce6e846463f393ddd35d42bb1f1cd6" translate="yes" xml:space="preserve">
          <source>The first field in the input</source>
          <target state="translated">입력의 첫 번째 필드</target>
        </trans-unit>
        <trans-unit id="d4d950398e4d3043c7b4cad357808ae2f4342dfd" translate="yes" xml:space="preserve">
          <source>The first form attaches the &lt;code&gt;return&lt;/code&gt; to the &lt;code&gt;scope&lt;/code&gt;, and has &lt;a href=&quot;#return-scope-parameters&quot;&gt;return scope parameter&lt;/a&gt; semantics for the value of the &lt;code&gt;ref&lt;/code&gt; parameter.</source>
          <target state="translated">첫 번째 형태는 첨부 &lt;code&gt;return&lt;/code&gt; 받는 &lt;code&gt;scope&lt;/code&gt; 및 보유 &lt;a href=&quot;#return-scope-parameters&quot;&gt;복귀 범위 매개 변수&lt;/a&gt; 의 값에 대한 의미 &lt;code&gt;ref&lt;/code&gt; 파라미터.</target>
        </trans-unit>
        <trans-unit id="8b1ce77e77b315411f0f72483fe564f04bb631f4" translate="yes" xml:space="preserve">
          <source>The first function</source>
          <target state="translated">첫 번째 기능</target>
        </trans-unit>
        <trans-unit id="f3024cc5ecfa3c08bdbe44b263a51764ec97fd6f" translate="yes" xml:space="preserve">
          <source>The first member of the &lt;code&gt;vtbl[]&lt;/code&gt; is not the pointer to the &lt;code&gt;Interface&lt;/code&gt;, but the first virtual function pointer.</source>
          <target state="translated">&lt;code&gt;vtbl[]&lt;/code&gt; 의 첫 번째 멤버 는 &lt;code&gt;Interface&lt;/code&gt; 에 대한 포인터가 아니라 첫 번째 가상 함수 포인터입니다.</target>
        </trans-unit>
        <trans-unit id="847d6d02e0c1f522b786c8972c9a6146a642fa90" translate="yes" xml:space="preserve">
          <source>The first member of the &lt;code&gt;vtbl[]&lt;/code&gt; is not the pointer to the InterfaceInfo, but the first virtual function pointer.</source>
          <target state="translated">&lt;code&gt;vtbl[]&lt;/code&gt; 의 첫 번째 멤버 는 InterfaceInfo에 대한 포인터가 아니라 첫 번째 가상 함수 포인터입니다.</target>
        </trans-unit>
        <trans-unit id="c2d2ce897245ef2180a0c50b1783471cf2be4244" translate="yes" xml:space="preserve">
          <source>The first overload exists only if &lt;code&gt;autoInit == RefCountedAutoInitialize.yes&lt;/code&gt;. So if &lt;code&gt;autoInit == RefCountedAutoInitialize.no&lt;/code&gt; or called for a constant or immutable object, then &lt;code&gt;refCountedPayload&lt;/code&gt; will also be qualified as safe and nothrow (but will still assert if not initialized).</source>
          <target state="translated">첫 번째 과부하는 &lt;code&gt;autoInit == RefCountedAutoInitialize.yes&lt;/code&gt; 경우에만 존재합니다 . 따라서 &lt;code&gt;autoInit == RefCountedAutoInitialize.no&lt;/code&gt; 또는 상수 또는 불변의 객체를 &lt;code&gt;refCountedPayload&lt;/code&gt; 하면 refCountedPayload 도 안전하고 문제가없는 것으로 규정됩니다 (그러나 초기화되지 않은 경우에는 여전히 주장됩니다).</target>
        </trans-unit>
        <trans-unit id="dfd8266058456fb8b44a614fe1b78098bba5c6d8" translate="yes" xml:space="preserve">
          <source>The first overload of &lt;code&gt;makeIndex&lt;/code&gt; writes to a range containing pointers, and the second writes to a range containing offsets. The first overload requires &lt;code&gt;Range&lt;/code&gt; to be a &lt;a href=&quot;std_range_primitives#isForwardRange&quot;&gt;forward range&lt;/a&gt;, and the latter requires it to be a random-access range.</source>
          <target state="translated">&lt;code&gt;makeIndex&lt;/code&gt; 의 첫 번째 오버로드는 포인터를 포함하는 범위에 쓰고 두 번째는 오프셋을 포함하는 범위에 씁니다. 첫 번째 과부하는 &lt;code&gt;Range&lt;/code&gt; 가 &lt;a href=&quot;std_range_primitives#isForwardRange&quot;&gt;순방향 범위&lt;/a&gt; 여야 하고 후자는 랜덤 액세스 범위 여야합니다.</target>
        </trans-unit>
        <trans-unit id="2797f8bab40930285c67d69e0f78f4ff6b12f672" translate="yes" xml:space="preserve">
          <source>The first overload of this function will return &lt;code&gt;T.init&lt;/code&gt; if the range is empty. However, the second overload will return &lt;code&gt;seed&lt;/code&gt; on empty ranges.</source>
          <target state="translated">이 함수의 첫 번째 과부하 는 범위가 비어 있으면 &lt;code&gt;T.init&lt;/code&gt; 를 반환 합니다. 그러나 두 번째 과부하는 빈 범위에서 &lt;code&gt;seed&lt;/code&gt; 를 반환 합니다.</target>
        </trans-unit>
        <trans-unit id="fa15d56dc093902b6572dae74b23ea12e4df8659" translate="yes" xml:space="preserve">
          <source>The first part is done automatically by the language, the second part is done if a postblit function is defined for the struct. The postblit has access only to the destination struct object, not the source. Its job is to &amp;lsquo;fix up&amp;rsquo; the destination as necessary, such as making copies of referenced data, incrementing reference counts, etc. For example:</source>
          <target state="translated">첫 번째 부분은 언어에 의해 자동으로 수행되고 두 번째 부분은 포스트 블릿 기능이 구조체에 대해 정의 된 경우 수행됩니다. 포스트 블릿은 소스가 아닌 대상 구조체 객체에만 액세스 할 수 있습니다. 이 작업은 참조 데이터의 사본 작성, 참조 횟수 증가 등과 같이 필요에 따라 대상을 '수정'하는 것입니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="b6a25e3471beef6bed20eb948a4b0de3cefb170f" translate="yes" xml:space="preserve">
          <source>The first part of the desired time zones.</source>
          <target state="translated">원하는 시간대의 첫 부분.</target>
        </trans-unit>
        <trans-unit id="f479a5f1dc2ec5b3e8f93d2c246a61132b592fa7" translate="yes" xml:space="preserve">
          <source>The first range</source>
          <target state="translated">첫 번째 범위</target>
        </trans-unit>
        <trans-unit id="978014a33cbc746b950a93b0f0736f4203ea8def" translate="yes" xml:space="preserve">
          <source>The first range to be compared.</source>
          <target state="translated">비교할 첫 번째 범위입니다.</target>
        </trans-unit>
        <trans-unit id="ca9cc691843153958d1dfce3f9f135428053bc03" translate="yes" xml:space="preserve">
          <source>The first range.</source>
          <target state="translated">첫 번째 범위.</target>
        </trans-unit>
        <trans-unit id="376b0679101f4b59ef8dcfe360d9831914d2f062" translate="yes" xml:space="preserve">
          <source>The first section is the</source>
          <target state="translated">첫 번째 섹션은</target>
        </trans-unit>
        <trans-unit id="0a2ac8281c00878fb6aeb93d4c1aa8543d1c7cdd" translate="yes" xml:space="preserve">
          <source>The first template argument is the size of the region and the second is the needed alignment. Depending on the alignment requested and platform details, the actual available storage may be smaller than the compile-time parameter. To make sure that at least &lt;code&gt;n&lt;/code&gt; bytes are available in the region, use &lt;code&gt;InSituRegion!(n + a - 1, a)&lt;/code&gt;.</source>
          <target state="translated">첫 번째 템플릿 인수는 영역의 크기이고 두 번째 템플릿은 필요한 정렬입니다. 요청 된 정렬 및 플랫폼 세부 사항에 따라 실제 사용 가능한 스토리지는 컴파일 타임 매개 변수보다 작을 수 있습니다. 리전에서 &lt;code&gt;n&lt;/code&gt; 바이트 이상 을 사용할 수있게하려면 &lt;code&gt;InSituRegion!(n + a - 1, a)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f09dcfe52dd359d217c384efcd5e2b579c11d4d5" translate="yes" xml:space="preserve">
          <source>The first thing a catch handler does is call this.</source>
          <target state="translated">캐치 핸들러가 가장 먼저하는 일은 이것을 호출하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="06bc16353a0bd43b921f8f9a4d6fe2a9b273859a" translate="yes" xml:space="preserve">
          <source>The first time point in the range.</source>
          <target state="translated">범위의 첫 번째 시점</target>
        </trans-unit>
        <trans-unit id="ee856ba33815edde83d3ab4573c1bb58ec0e2ba8" translate="yes" xml:space="preserve">
          <source>The first two overloads throw only if &lt;code&gt;alloc&lt;/code&gt;'s primitives do. The overloads that involve copy initialization deallocate memory and propagate the exception if the copy operation throws.</source>
          <target state="translated">처음 두 개의 과부하는 &lt;code&gt;alloc&lt;/code&gt; 의 프리미티브가 수행하는 경우에만 발생 합니다. 복사 초기화와 관련된 오버로드는 메모리를 할당 해제하고 복사 작업이 발생하면 예외를 전파합니다.</target>
        </trans-unit>
        <trans-unit id="333231d0183ec9a4310007ffcf10aa12ccaa5deb" translate="yes" xml:space="preserve">
          <source>The first two overloads throw only if the used allocator's primitives do. The overloads that involve copy initialization deallocate memory and propagate the exception if the copy operation throws.</source>
          <target state="translated">처음 두 개의 과부하는 사용 된 할당 자의 프리미티브가 수행하는 경우에만 발생합니다. 복사 초기화와 관련된 오버로드는 메모리를 할당 해제하고 복사 작업이 발생하면 예외를 전파합니다.</target>
        </trans-unit>
        <trans-unit id="8adbee74bf4af885c51ba2cdd7ef319e8a5ccd70" translate="yes" xml:space="preserve">
          <source>The first type to receive the type name for</source>
          <target state="translated">유형 이름을받는 첫 번째 유형</target>
        </trans-unit>
        <trans-unit id="24a327b5e33473298dc52e8aa179b1270880d206" translate="yes" xml:space="preserve">
          <source>The first version counts the number of elements &lt;code&gt;x&lt;/code&gt; in &lt;code&gt;r&lt;/code&gt; for which &lt;code&gt;pred(x, value)&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;. &lt;code&gt;pred&lt;/code&gt; defaults to equality. Performs &amp;Omicron;(&lt;code&gt;haystack.length&lt;/code&gt;) evaluations of &lt;code&gt;pred&lt;/code&gt;.</source>
          <target state="translated">소자의 수는 제 버전 카운트 &lt;code&gt;x&lt;/code&gt; 에서 &lt;code&gt;r&lt;/code&gt; 되는 &lt;code&gt;pred(x, value)&lt;/code&gt; 이다 &lt;code&gt;true&lt;/code&gt; . &lt;code&gt;pred&lt;/code&gt; 는 평등으로 기본 설정됩니다. &lt;code&gt;pred&lt;/code&gt; 의 &amp;Omicron; ( &lt;code&gt;haystack.length&lt;/code&gt; ) 평가를 수행합니다 .</target>
        </trans-unit>
        <trans-unit id="c9816b3b28ee2e6c5406da992bb1cbb42be32059" translate="yes" xml:space="preserve">
          <source>The first way is to use a literal that is already immutable, such as string literals. String literals are always immutable.</source>
          <target state="translated">첫 번째 방법은 문자열 리터럴과 같이 이미 변경할 수없는 리터럴을 사용하는 것입니다. 문자열 리터럴은 항상 변경할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="b05e9e189cc2bf7e6e8a6f344ff95d0591fc3a0f" translate="yes" xml:space="preserve">
          <source>The first will queue writers until no readers hold the mutex, then pass the writers through one at a time. If a reader acquires the mutex while there are still writers queued, the reader will take precedence.</source>
          <target state="translated">첫 번째는 뮤텍스를 보유한 독자가 없을 때까지 작성자를 대기시킨 다음 한 번에 하나씩 작성자를 통과시킵니다. 대기중인 기록기가 여전히있는 동안 판독기가 뮤텍스를 획득하면 판독기가 우선합니다.</target>
        </trans-unit>
        <trans-unit id="1b1951cc36673198c26cd910de69ac59cf5f6d05" translate="yes" xml:space="preserve">
          <source>The focus of this module is the core needs of developing Unicode-aware applications. To that effect it provides the following optimized primitives:</source>
          <target state="translated">이 모듈의 초점은 유니 코드 인식 응용 프로그램 개발의 핵심 요구 사항입니다. 이를 위해 다음과 같은 최적화 된 프리미티브를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="6fa1fe0d7308c90108a99d43bd343885cf39b2f7" translate="yes" xml:space="preserve">
          <source>The following IEEE 'real' formats are currently supported:</source>
          <target state="translated">다음과 같은 IEEE '실제'형식이 현재 지원됩니다.</target>
        </trans-unit>
        <trans-unit id="fd79ad5ff3bdc8ea5cc9c7e973de1494e808a075" translate="yes" xml:space="preserve">
          <source>The following algorithm is used:</source>
          <target state="translated">다음 알고리즘이 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="3781d7d912eacb6b194d6abe4908fafb2e1b7d5d" translate="yes" xml:space="preserve">
          <source>The following algorithms are currently implemented:</source>
          <target state="translated">다음 알고리즘이 현재 구현되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="d55ceaf72919876c8f40561d12b134a3ea66a2f7" translate="yes" xml:space="preserve">
          <source>The following alias declarations are valid:</source>
          <target state="translated">다음과 같은 별명 선언이 유효합니다.</target>
        </trans-unit>
        <trans-unit id="3cfdc04ab915c01ce32c8d0e68bf6bc781aec0c7" translate="yes" xml:space="preserve">
          <source>The following are all embedded documentation comments:</source>
          <target state="translated">다음은 모두 포함 된 설명서 주석입니다.</target>
        </trans-unit>
        <trans-unit id="98d73aa2fbdeacfd5d17519697402797329a5e39" translate="yes" xml:space="preserve">
          <source>The following are rules of input ranges are assumed to hold true in all Phobos code. These rules are not checkable at compile-time, so not conforming to these rules when writing ranges or range based code will result in undefined behavior.</source>
          <target state="translated">다음은 모든 Phobo 코드에서 적용되는 입력 범위 규칙입니다. 이러한 규칙은 컴파일 타임에 확인할 수 없으므로 범위 나 범위 기반 코드를 작성할 때 이러한 규칙을 준수하지 않으면 동작이 정의되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="eabfe29dc68817824868f2b1cc59ea44b7368f75" translate="yes" xml:space="preserve">
          <source>The following are what the Unicode standard considers as line terminators:</source>
          <target state="translated">다음은 유니 코드 표준이 줄 종결 자로 간주하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="21052e7f487ea1e8da6a5dfd837062e0257bbb6f" translate="yes" xml:space="preserve">
          <source>The following binary operators are overloadable:</source>
          <target state="translated">다음과 같은 이진 연산자를 오버로드 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="85cad5d1bff24fce98bfd578ab9c72fa9869b15d" translate="yes" xml:space="preserve">
          <source>The following code compares the use of &lt;code&gt;formatValue&lt;/code&gt; and &lt;code&gt;formattedWrite&lt;/code&gt;.</source>
          <target state="translated">다음 코드는 &lt;code&gt;formatValue&lt;/code&gt; 와 &lt;code&gt;formattedWrite&lt;/code&gt; 의 사용을 비교합니다 .</target>
        </trans-unit>
        <trans-unit id="36006625c3fb62c010db1770cfe9a955d1abc844" translate="yes" xml:space="preserve">
          <source>The following code does a full unzip</source>
          <target state="translated">다음 코드는 전체 압축을 해제합니다</target>
        </trans-unit>
        <trans-unit id="707a5e8dae71e24794f64d11490781d72f147427" translate="yes" xml:space="preserve">
          <source>The following code should compile for any forward range.</source>
          <target state="translated">다음 코드는 모든 포워드 범위에 대해 컴파일해야합니다.</target>
        </trans-unit>
        <trans-unit id="b75b3b21bc4ed533a6d7d4185c0635676c150be0" translate="yes" xml:space="preserve">
          <source>The following describes the behavior of the qualified postblit definitions:</source>
          <target state="translated">다음은 규정 된 포스트 블리트 정의의 동작을 설명합니다.</target>
        </trans-unit>
        <trans-unit id="cc1ef4d0137291a52b36237f0a56da4b9479ab3e" translate="yes" xml:space="preserve">
          <source>The following describes the specific implementation of the vector types for the X86 and X86_64 architectures.</source>
          <target state="translated">다음은 X86 및 X86_64 아키텍처에 대한 벡터 유형의 특정 구현에 대해 설명합니다.</target>
        </trans-unit>
        <trans-unit id="f4a4096a1a2c3a608e01b521d07c483d3463c6b6" translate="yes" xml:space="preserve">
          <source>The following elements describe the locations of GC managed pointers within the memory occupied by an instance of the type. For type T, there are &lt;code&gt;T.sizeof / size_t.sizeof&lt;/code&gt; possible pointers represented by the bits of the array values.</source>
          <target state="translated">다음 요소는 유형의 인스턴스가 차지하는 메모리 내의 GC 관리 포인터의 위치를 ​​설명합니다. 타입 T 의 경우, 배열 값의 비트로 표현되는 가능한 포인터의 &lt;code&gt;T.sizeof / size_t.sizeof&lt;/code&gt; 있습니다.</target>
        </trans-unit>
        <trans-unit id="64e995a24781ca67ad26542b15d464819ff2f49a" translate="yes" xml:space="preserve">
          <source>The following example shows binding of a pure virtual function, its implementation in a derived class, a non-virtual member function, and a member field:</source>
          <target state="translated">다음 예제는 순수 가상 함수 바인딩, 파생 클래스에서의 구현, 비가 상 멤버 함수 및 멤버 필드를 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="7394f4cff4af73de38cdcc123f9d9cc433c49d32" translate="yes" xml:space="preserve">
          <source>The following expression must be true for &lt;code&gt;hasSlicing&lt;/code&gt; to be &lt;code&gt;true&lt;/code&gt;:</source>
          <target state="translated">에 대해 다음 식을 충족해야 &lt;code&gt;hasSlicing&lt;/code&gt; 이 될 &lt;code&gt;true&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="9182b2bc4da6786571366018715b092f896d0a9d" translate="yes" xml:space="preserve">
          <source>The following flag from DMD can be used to add a new path in which to search for frameworks:</source>
          <target state="translated">DMD의 다음 플래그를 사용하여 프레임 워크를 검색 할 새 경로를 추가 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f255eea7299aed827ce99b1b18680817e56fa6aa" translate="yes" xml:space="preserve">
          <source>The following forms of slice expression can be convertible to a static array type:</source>
          <target state="translated">다음 형식의 슬라이스 식을 정적 배열 유형으로 변환 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b112356e7e4259c722c195a6e095476ecaa2fdb9" translate="yes" xml:space="preserve">
          <source>The following functions are publicly imported:</source>
          <target state="translated">다음 기능을 공개적으로 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="37498d7cc50ed898202c2748c98849d1a32c6302" translate="yes" xml:space="preserve">
          <source>The following identifiers are defined, but are deprecated:</source>
          <target state="translated">다음 식별자가 정의되었지만 더 이상 사용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="4b758467388bb94c690cea1fb26de17875ff1787" translate="yes" xml:space="preserve">
          <source>The following information might be of help with choosing the appropriate block size. Actual allocation occurs in sizes multiple of the block size. Allocating one block is the fastest because only one 0 bit needs to be found in the metadata. Allocating 2 through 64 blocks is the next cheapest because it affects a maximum of two &lt;code&gt;ulong&lt;/code&gt; in the metadata. Allocations greater than 64 blocks require a multiword search through the metadata.</source>
          <target state="translated">다음 정보는 적절한 블록 크기를 선택하는 데 도움이 될 수 있습니다. 실제 할당은 블록 크기의 배수로 발생합니다. 메타 데이터에서 하나의 0 비트 만 찾으면되므로 하나의 블록을 할당하는 것이 가장 빠릅니다. 2-64 개의 블록을 할당하는 것이 메타 데이터에서 최대 2 개의 &lt;code&gt;ulong&lt;/code&gt; 에 영향을 미치므로 가장 저렴 합니다. 64 개보다 큰 할당에는 메타 데이터를 통한 다중 단어 검색이 필요합니다.</target>
        </trans-unit>
        <trans-unit id="3576cbb0f30565829c9a8b467650fa45b457f446" translate="yes" xml:space="preserve">
          <source>The following is a list of important Unicode notions and definitions. Any conventions used specifically in this module alone are marked as such. The descriptions are based on the formal definition as found in &lt;a href=&quot;http://www.unicode.org/versions/Unicode6.2.0/ch03.pdf&quot;&gt; chapter three of The Unicode Standard Core Specification.&lt;/a&gt;</source>
          <target state="translated">다음은 중요한 유니 코드 개념 및 정의 목록입니다. 이 모듈에서만 사용되는 모든 규칙은 그대로 표시됩니다. 이 설명은 &lt;a href=&quot;http://www.unicode.org/versions/Unicode6.2.0/ch03.pdf&quot;&gt;The Unicode Standard Core Specification의 3 장&lt;/a&gt; 에있는 공식적인 정의를 기반으로합니다 .</target>
        </trans-unit>
        <trans-unit id="ee35f7e05bf101609042076d8164187dce2ce440" translate="yes" xml:space="preserve">
          <source>The following methods are defined if &lt;code&gt;Allocator&lt;/code&gt; defines them, and forward to it: &lt;code&gt;deallocateAll&lt;/code&gt;, &lt;code&gt;empty&lt;/code&gt;, &lt;code&gt;owns&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Allocator&lt;/code&gt; 가이를 정의하고 전달하는 경우 다음 메소드가 정의됩니다 . &lt;code&gt;deallocateAll&lt;/code&gt; , &lt;code&gt;empty&lt;/code&gt; , &lt;code&gt;owns&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="91a10c7b038d71ce23d47d4e91b5d6d57a0c0ec0" translate="yes" xml:space="preserve">
          <source>The following methods are defined if &lt;code&gt;ParentAllocator&lt;/code&gt; defines them, and forward to it: &lt;code&gt;allocateAll&lt;/code&gt;, &lt;code&gt;expand&lt;/code&gt;, &lt;code&gt;owns&lt;/code&gt;, &lt;code&gt;reallocate&lt;/code&gt;.</source>
          <target state="translated">다음 방법은 경우에 정의되어 &lt;code&gt;ParentAllocator&lt;/code&gt; 이 그것을 기대를 정의하고, : &lt;code&gt;allocateAll&lt;/code&gt; 는 , &lt;code&gt;expand&lt;/code&gt; , &lt;code&gt;owns&lt;/code&gt; , &lt;code&gt;reallocate&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="14685afb8641a641e101312bd747ad3ce716f779" translate="yes" xml:space="preserve">
          <source>The following methods are defined if &lt;code&gt;ParentAllocator&lt;/code&gt; defines them, and forward to it: &lt;code&gt;expand&lt;/code&gt;, &lt;code&gt;owns&lt;/code&gt;, &lt;code&gt;reallocate&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;ParentAllocator&lt;/code&gt; 가 정의하고이를 전달하는 경우 다음 메소드가 정의됩니다 . &lt;code&gt;expand&lt;/code&gt; , &lt;code&gt;owns&lt;/code&gt; , &lt;code&gt;reallocate&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d5e999922ed0b2b38ea541add7eceec13e307896" translate="yes" xml:space="preserve">
          <source>The following methods are forwarded to the parent allocator if present: &lt;code&gt;allocateAll&lt;/code&gt;, &lt;code&gt;owns&lt;/code&gt;, &lt;code&gt;deallocateAll&lt;/code&gt;, &lt;code&gt;empty&lt;/code&gt;.</source>
          <target state="translated">다음과 같은 메소드가 존재하는 경우 상위 할당 자에게 전달됩니다 : &lt;code&gt;allocateAll&lt;/code&gt; , &lt;code&gt;owns&lt;/code&gt; , &lt;code&gt;deallocateAll&lt;/code&gt; , &lt;code&gt;empty&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="90832fc606780913417ad9424b5b78d805e2f1c9" translate="yes" xml:space="preserve">
          <source>The following must not compile:</source>
          <target state="translated">다음은 컴파일해서는 안됩니다.</target>
        </trans-unit>
        <trans-unit id="151cf7cc11e7e2474415594512b78561ff78c2e4" translate="yes" xml:space="preserve">
          <source>The following op assignment operators are overloadable:</source>
          <target state="translated">다음 op 할당 연산자는 오버로드 가능합니다.</target>
        </trans-unit>
        <trans-unit id="1686f8bc7687029bb8df07eb18087ba36d800516" translate="yes" xml:space="preserve">
          <source>The following operations are not allowed in safe functions:</source>
          <target state="translated">안전 기능에서는 다음 작업이 허용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="74510166d7dbf32dd076c82ed552fa55a6bbe522" translate="yes" xml:space="preserve">
          <source>The following part &lt;code&gt;=&amp;gt;&lt;/code&gt;</source>
          <target state="translated">다음 부분 &lt;code&gt;=&amp;gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="5f46ca3cf008a6a798269fad6d3b26dd55f13657" translate="yes" xml:space="preserve">
          <source>The following registers are supported. Register names are always in upper case.</source>
          <target state="translated">다음 레지스터가 지원됩니다. 레지스터 이름은 항상 대문자입니다.</target>
        </trans-unit>
        <trans-unit id="747c928a756931b0ee0b7f4bfca0b996d4e0288f" translate="yes" xml:space="preserve">
          <source>The following restrictions apply to class construction:</source>
          <target state="translated">수업 구성에는 다음과 같은 제한 사항이 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="b257030ef10af45e49786ee89d857d61ed4e94b9" translate="yes" xml:space="preserve">
          <source>The following restrictions apply to struct construction:</source>
          <target state="translated">구조체 생성에는 다음과 같은 제한 사항이 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="2f5e979077d2f3caabdbb4640da99e0c00a00749" translate="yes" xml:space="preserve">
          <source>The following steps happen:</source>
          <target state="translated">다음 단계가 수행됩니다.</target>
        </trans-unit>
        <trans-unit id="b441496fc086e7e8d354986714d6c04ebf32cc29" translate="yes" xml:space="preserve">
          <source>The following table compactly summarises the different process creation functions and how they relate to each other:</source>
          <target state="translated">다음 표는 다양한 프로세스 생성 기능과 기능 간의 관계를 간략하게 요약 한 것입니다.</target>
        </trans-unit>
        <trans-unit id="05b248b2126c26cb91a89762582c19941d257e43" translate="yes" xml:space="preserve">
          <source>The following table is a quick reference guide for which Phobos modules to use for a given category of functionality. Note that some modules may appear in more than one category, as some Phobos modules are quite generic and can be applied in a variety of situations.</source>
          <target state="translated">다음 표는 특정 기능 범주에 Phobos 모듈을 사용하기위한 빠른 참조 안내서입니다. 일부 Phobos 모듈은 매우 일반적이며 다양한 상황에 적용 할 수 있으므로 일부 모듈은 둘 이상의 범주에 나타날 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a2cf73cb06dd66656b8e69a1d451407dbc663bbe" translate="yes" xml:space="preserve">
          <source>The following table lists all the possibilities of grouping qualifiers for a postblit associated with the type of object that needs to be used in order to succesfully invoke the postblit:</source>
          <target state="translated">다음 표는 포스트 블릿을 성공적으로 호출하기 위해 사용해야하는 오브젝트 유형과 연관된 포스트 블릿에 대한 규정자를 그룹화 할 수있는 모든 가능성을 나열합니다.</target>
        </trans-unit>
        <trans-unit id="824da93e42b4013db578b67b46a78528e680f556" translate="yes" xml:space="preserve">
          <source>The following transformations of floating point expressions are not allowed because under IEEE rules they could produce different results.</source>
          <target state="translated">IEEE 규칙에서 다른 결과를 생성 할 수 있으므로 다음과 같은 부동 소수점 표현식 변환은 허용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="a206952bbb005ee76451476eb55d6acde4281a6d" translate="yes" xml:space="preserve">
          <source>The following typedef's are signatures of malloc, free, realloc, strdup and calloc respectively. Function pointers of these types can be passed to the curl_global_init_mem() function to set user defined memory management callback routines.</source>
          <target state="translated">다음 typedef는 각각 malloc, free, realloc, strdup 및 calloc의 서명입니다. 이러한 유형의 함수 포인터는 curl_global_init_mem () 함수에 전달되어 사용자 정의 메모리 관리 콜백 루틴을 설정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6266d602387c0c2612f1f18ac8c95fc02fe3bb5d" translate="yes" xml:space="preserve">
          <source>The format &lt;code&gt;inner&lt;/code&gt; is applied the expanded &lt;code&gt;Tuple&lt;/code&gt;, so it may contain as many formats as the &lt;code&gt;Tuple&lt;/code&gt; has fields.</source>
          <target state="translated">&lt;code&gt;inner&lt;/code&gt; 형식 은 확장 된 &lt;code&gt;Tuple&lt;/code&gt; 에 적용 되므로 &lt;code&gt;Tuple&lt;/code&gt; 의 필드 수만큼 많은 형식을 포함 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="d91cc2eaba6a476564c6ddbd8124208fde7d92fe" translate="yes" xml:space="preserve">
          <source>The format &lt;code&gt;inner&lt;/code&gt; is one format, that is applied on all fields of the &lt;code&gt;Tuple&lt;/code&gt;. The inner format must be compatible to all of them.</source>
          <target state="translated">포맷 &lt;code&gt;inner&lt;/code&gt; 의 모든 필드에 적용되는 하나의 포맷 인 &lt;code&gt;Tuple&lt;/code&gt; . 내부 형식은 모든 형식과 호환 가능해야합니다.</target>
        </trans-unit>
        <trans-unit id="b804a9979bb24328a2b2b5b25616b3fc268adff1" translate="yes" xml:space="preserve">
          <source>The format of the data to read.</source>
          <target state="translated">읽을 데이터의 형식입니다.</target>
        </trans-unit>
        <trans-unit id="0a7a62414c21f47b50a1e92c766dda1b08a5910c" translate="yes" xml:space="preserve">
          <source>The format of the date should follow this template:</source>
          <target state="translated">날짜 형식은 다음 템플릿을 따라야합니다.</target>
        </trans-unit>
        <trans-unit id="659e106c79a7ed685e316895f1b36b5ece514b7f" translate="yes" xml:space="preserve">
          <source>The format of the instructions is, of course, highly dependent on the native instruction set of the target CPU, and so is &lt;a href=&quot;iasm&quot;&gt;implementation defined&lt;/a&gt;. But, the format will follow the following conventions:</source>
          <target state="translated">물론 명령어의 형식은 대상 CPU의 기본 명령어 세트에 따라 크게 달라 지므로 &lt;a href=&quot;iasm&quot;&gt;구현도 정의됩니다&lt;/a&gt; . 그러나 형식은 다음 규칙을 따릅니다.</target>
        </trans-unit>
        <trans-unit id="d00ef203b4bd1ca0d23b1201e668116dd138801d" translate="yes" xml:space="preserve">
          <source>The format of the string is purposefully unspecified, and code that cares about the format of the string should use &lt;code&gt;toISOString&lt;/code&gt;, &lt;code&gt;toISOExtString&lt;/code&gt;, &lt;code&gt;toSimpleString&lt;/code&gt;, or some other custom formatting function that explicitly generates the format that the code needs. The reason is that the code is then clear about what format it's using, making it less error-prone to maintain the code and interact with other software that consumes the generated strings. It's for this same reason &lt;a href=&quot;#Date&quot;&gt;&lt;code&gt;Date&lt;/code&gt;&lt;/a&gt; has no &lt;code&gt;fromString&lt;/code&gt; function, whereas it does have &lt;code&gt;fromISOString&lt;/code&gt;, &lt;code&gt;fromISOExtString&lt;/code&gt;, and &lt;code&gt;fromSimpleString&lt;/code&gt;.</source>
          <target state="translated">문자열의 형식은 의도적으로 지정되어 있지 않으며 문자열 형식을 관리하는 코드는 &lt;code&gt;toISOString&lt;/code&gt; , &lt;code&gt;toISOExtString&lt;/code&gt; , &lt;code&gt;toSimpleString&lt;/code&gt; 또는 코드에 필요한 형식을 명시 적으로 생성하는 다른 사용자 지정 형식 지정 함수를 사용해야합니다. 그 이유는 코드가 어떤 형식을 사용하고 있는지 명확하게 알 수 있기 때문에 코드를 유지 관리하고 생성 된 문자열을 사용하는 다른 소프트웨어와 상호 작용하기에 오류가 덜 발생하기 때문입니다. 같은 이유로 &lt;a href=&quot;#Date&quot;&gt; &lt;code&gt;Date&lt;/code&gt; &lt;/a&gt; 에는 &lt;code&gt;fromString&lt;/code&gt; 함수가 &lt;code&gt;fromISOString&lt;/code&gt; , &lt;code&gt;fromISOExtString&lt;/code&gt; 및 &lt;code&gt;fromSimpleString&lt;/code&gt; 이 있습니다.</target>
        </trans-unit>
        <trans-unit id="7e82eb1994e0d2ee7e98c5b8f8c20cfd78e8b067" translate="yes" xml:space="preserve">
          <source>The format of the string is purposefully unspecified, and code that cares about the format of the string should use &lt;code&gt;toISOString&lt;/code&gt;, &lt;code&gt;toISOExtString&lt;/code&gt;, &lt;code&gt;toSimpleString&lt;/code&gt;, or some other custom formatting function that explicitly generates the format that the code needs. The reason is that the code is then clear about what format it's using, making it less error-prone to maintain the code and interact with other software that consumes the generated strings. It's for this same reason that &lt;a href=&quot;#DateTime&quot;&gt;&lt;code&gt;DateTime&lt;/code&gt;&lt;/a&gt; has no &lt;code&gt;fromString&lt;/code&gt; function, whereas it does have &lt;code&gt;fromISOString&lt;/code&gt;, &lt;code&gt;fromISOExtString&lt;/code&gt;, and &lt;code&gt;fromSimpleString&lt;/code&gt;.</source>
          <target state="translated">문자열의 형식은 의도적으로 지정되어 있지 않으며 문자열 형식을 관리하는 코드는 &lt;code&gt;toISOString&lt;/code&gt; , &lt;code&gt;toISOExtString&lt;/code&gt; , &lt;code&gt;toSimpleString&lt;/code&gt; 또는 코드에 필요한 형식을 명시 적으로 생성하는 다른 사용자 지정 형식 지정 함수를 사용해야합니다. 그 이유는 코드가 어떤 형식을 사용하고 있는지 명확하게 알 수 있기 때문에 코드를 유지 관리하고 생성 된 문자열을 사용하는 다른 소프트웨어와 상호 작용하기에 오류가 덜 발생하기 때문입니다. &lt;a href=&quot;#DateTime&quot;&gt; &lt;code&gt;DateTime&lt;/code&gt; &lt;/a&gt; 에는 &lt;code&gt;fromString&lt;/code&gt; 함수 가없는 것과 같은 이유로 &lt;code&gt;fromISOString&lt;/code&gt; , &lt;code&gt;fromISOExtString&lt;/code&gt; 및 &lt;code&gt;fromSimpleString&lt;/code&gt; 이 있습니다.</target>
        </trans-unit>
        <trans-unit id="96cf4abaa3ec73526e49a27860bcadf20906a190" translate="yes" xml:space="preserve">
          <source>The format of the string is purposefully unspecified, and code that cares about the format of the string should use &lt;code&gt;toISOString&lt;/code&gt;, &lt;code&gt;toISOExtString&lt;/code&gt;, &lt;code&gt;toSimpleString&lt;/code&gt;, or some other custom formatting function that explicitly generates the format that the code needs. The reason is that the code is then clear about what format it's using, making it less error-prone to maintain the code and interact with other software that consumes the generated strings. It's for this same reason that &lt;a href=&quot;#SysTime&quot;&gt;&lt;code&gt;SysTime&lt;/code&gt;&lt;/a&gt; has no &lt;code&gt;fromString&lt;/code&gt; function, whereas it does have &lt;code&gt;fromISOString&lt;/code&gt;, &lt;code&gt;fromISOExtString&lt;/code&gt;, and &lt;code&gt;fromSimpleString&lt;/code&gt;.</source>
          <target state="translated">문자열의 형식은 의도적으로 지정되어 있지 않으며 문자열 형식을 관리하는 코드는 &lt;code&gt;toISOString&lt;/code&gt; , &lt;code&gt;toISOExtString&lt;/code&gt; , &lt;code&gt;toSimpleString&lt;/code&gt; 또는 코드에 필요한 형식을 명시 적으로 생성하는 다른 사용자 지정 형식 지정 함수를 사용해야합니다. 그 이유는 코드가 어떤 형식을 사용하고 있는지 명확하게 알 수 있기 때문에 코드를 유지 관리하고 생성 된 문자열을 사용하는 다른 소프트웨어와 상호 작용하기에 오류가 덜 발생하기 때문입니다. &lt;a href=&quot;#SysTime&quot;&gt; &lt;code&gt;SysTime&lt;/code&gt; &lt;/a&gt; 에는 &lt;code&gt;fromString&lt;/code&gt; 함수가 &lt;code&gt;fromISOString&lt;/code&gt; , &lt;code&gt;fromISOExtString&lt;/code&gt; 및 &lt;code&gt;fromSimpleString&lt;/code&gt; 이 같은 이유입니다 .</target>
        </trans-unit>
        <trans-unit id="02a7f64095e841cf54dadcac2f9cbc728022a8d4" translate="yes" xml:space="preserve">
          <source>The format of the string is purposefully unspecified, and code that cares about the format of the string should use &lt;code&gt;toISOString&lt;/code&gt;, &lt;code&gt;toISOExtString&lt;/code&gt;, or some other custom formatting function that explicitly generates the format that the code needs. The reason is that the code is then clear about what format it's using, making it less error-prone to maintain the code and interact with other software that consumes the generated strings. It's for this same reason that &lt;a href=&quot;#TimeOfDay&quot;&gt;&lt;code&gt;TimeOfDay&lt;/code&gt;&lt;/a&gt; has no &lt;code&gt;fromString&lt;/code&gt; function, whereas it does have &lt;code&gt;fromISOString&lt;/code&gt; and &lt;code&gt;fromISOExtString&lt;/code&gt;.</source>
          <target state="translated">문자열의 형식은 의도적으로 지정되어 있지 않으며 문자열 형식을 관리하는 코드는 &lt;code&gt;toISOString&lt;/code&gt; , &lt;code&gt;toISOExtString&lt;/code&gt; 또는 코드에 필요한 형식을 명시 적으로 생성하는 다른 사용자 지정 형식 지정 함수를 사용해야합니다. 그 이유는 코드가 어떤 형식을 사용하고 있는지 명확하게 알 수 있기 때문에 코드를 유지 관리하고 생성 된 문자열을 사용하는 다른 소프트웨어와 상호 작용하기에 오류가 덜 발생하기 때문입니다. 같은 이유로 &lt;a href=&quot;#TimeOfDay&quot;&gt; &lt;code&gt;TimeOfDay&lt;/code&gt; &lt;/a&gt; 에는 &lt;code&gt;fromString&lt;/code&gt; 함수 가없고 &lt;code&gt;fromISOString&lt;/code&gt; 및 &lt;code&gt;fromISOExtString&lt;/code&gt; 이 있습니다.</target>
        </trans-unit>
        <trans-unit id="ffca9618faa656329893915994f22e9af2d88357" translate="yes" xml:space="preserve">
          <source>The format returned by toString may or may not change in the future.</source>
          <target state="translated">toString에 의해 반환되는 형식은 나중에 변경 될 수도 있고 변경되지 않을 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="03b68c7b67ac69b6f5b3f857c44f365ee971e450" translate="yes" xml:space="preserve">
          <source>The format specifier contained a &lt;code&gt;' '&lt;/code&gt; (&lt;code&gt;printf&lt;/code&gt; compatibility).</source>
          <target state="translated">형식 지정자에는 &lt;code&gt;' '&lt;/code&gt; ( &lt;code&gt;printf&lt;/code&gt; 호환성)가 포함되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="f06eba7969af19af6a609393b286c72694c125a1" translate="yes" xml:space="preserve">
          <source>The format specifier contained a &lt;code&gt;'#'&lt;/code&gt; (&lt;code&gt;printf&lt;/code&gt; compatibility).</source>
          <target state="translated">형식 지정자에는 &lt;code&gt;'#'&lt;/code&gt; ( &lt;code&gt;printf&lt;/code&gt; 호환성)이 포함되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="2b3efef6165630dae7b0c5941cb57f0ff6fb2723" translate="yes" xml:space="preserve">
          <source>The format specifier contained a &lt;code&gt;'+'&lt;/code&gt; (&lt;code&gt;printf&lt;/code&gt; compatibility).</source>
          <target state="translated">형식 지정자에는 &lt;code&gt;'+'&lt;/code&gt; ( &lt;code&gt;printf&lt;/code&gt; 호환성)가 포함되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="6460ee5bc9ce27cd4f9cfd713bf8f2494817b14f" translate="yes" xml:space="preserve">
          <source>The format specifier contained a &lt;code&gt;','&lt;/code&gt;</source>
          <target state="translated">형식 지정자에는 &lt;code&gt;','&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="962882364923635b105d5f54d8d7565b59680ac3" translate="yes" xml:space="preserve">
          <source>The format specifier contained a &lt;code&gt;'-'&lt;/code&gt; (&lt;code&gt;printf&lt;/code&gt; compatibility).</source>
          <target state="translated">형식 지정자에는 &lt;code&gt;'-'&lt;/code&gt; ( &lt;code&gt;printf&lt;/code&gt; 호환성)가 포함되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="d34bdd42fd319223df703e24b238ea323c66c17e" translate="yes" xml:space="preserve">
          <source>The format specifier contained a &lt;code&gt;'0'&lt;/code&gt; (&lt;code&gt;printf&lt;/code&gt; compatibility).</source>
          <target state="translated">형식 지정자에는 &lt;code&gt;'0'&lt;/code&gt; ( &lt;code&gt;printf&lt;/code&gt; 호환성)이 포함되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="4e47d83ed9645d662de3546c090652b44c5fa2bb" translate="yes" xml:space="preserve">
          <source>The format string can be checked at compile-time (see &lt;a href=&quot;#format&quot;&gt;&lt;code&gt;format&lt;/code&gt;&lt;/a&gt; for details):</source>
          <target state="translated">형식 문자열은 컴파일 타임에 확인할 수 있습니다 (자세한 내용은 &lt;a href=&quot;#format&quot;&gt; &lt;code&gt;format&lt;/code&gt; &lt;/a&gt; 참조).</target>
        </trans-unit>
        <trans-unit id="bd749ebde47823b6d49d60691dec84566b639bf8" translate="yes" xml:space="preserve">
          <source>The format string can reference parts of match using the following notation.</source>
          <target state="translated">형식 문자열은 다음 표기법을 사용하여 일치하는 부분을 참조 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2d3aec5d983c44f1af503ee811b2266d3dca8cd3" translate="yes" xml:space="preserve">
          <source>The format string has the following grammar:</source>
          <target state="translated">형식 문자열에는 다음과 같은 문법이 있습니다.</target>
        </trans-unit>
        <trans-unit id="0625c7ec1018d088678495be9b57d04b31498a03" translate="yes" xml:space="preserve">
          <source>The format string supports the formatting of array and nested array elements via the grouping format specifiers &lt;b&gt;%(&lt;/b&gt; and &lt;b&gt;%)&lt;/b&gt;. Each matching pair of &lt;b&gt;%(&lt;/b&gt; and &lt;b&gt;%)&lt;/b&gt; corresponds with a single array argument. The enclosed sub-format string is applied to individual array elements. The trailing portion of the sub-format string following the conversion specifier for the array element is interpreted as the array delimiter, and is therefore omitted following the last array element. The &lt;b&gt;%|&lt;/b&gt; specifier may be used to explicitly indicate the start of the delimiter, so that the preceding portion of the string will be included following the last array element. (See below for explicit examples.)</source>
          <target state="translated">형식화 문자열은 그룹화 형식 지정자 &lt;b&gt;% (&lt;/b&gt; 및 &lt;b&gt;%)&lt;/b&gt; 를 통해 배열 및 중첩 배열 요소의 형식화를 지원합니다 . &lt;b&gt;% (&lt;/b&gt; 와 &lt;b&gt;%)&lt;/b&gt; 의 각 일치 쌍은 단일 배열 인수에 해당합니다. 동봉 된 하위 형식 문자열은 개별 배열 요소에 적용됩니다. 배열 요소의 변환 지정자 다음에 오는 하위 형식 문자열의 후미 부분은 배열 구분 기호로 해석되므로 마지막 배열 요소 다음에는 생략됩니다. &lt;b&gt;% | &lt;/b&gt;지정자는 구분 기호의 시작을 명시 적으로 표시하는 데 사용될 수 있으므로 문자열의 앞 부분이 마지막 배열 요소 다음에 포함됩니다. (명시적인 예는 아래를 참조하십시오.)</target>
        </trans-unit>
        <trans-unit id="693a71e5dd0ab926d97018418f98a27b3e174029" translate="yes" xml:space="preserve">
          <source>The format string used for this log call.</source>
          <target state="translated">이 로그 호출에 사용되는 형식 문자열입니다.</target>
        </trans-unit>
        <trans-unit id="9fa2fc4abd1b83aca1055ee06f982cdb131c59e5" translate="yes" xml:space="preserve">
          <source>The formatting flag is applied individually to each value, for example:</source>
          <target state="translated">형식 플래그는 다음과 같이 각 값에 개별적으로 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="d26ac44ffe5a86909c11c81e0ef71d3888da5c4c" translate="yes" xml:space="preserve">
          <source>The forms of the</source>
          <target state="translated">의 형태</target>
        </trans-unit>
        <trans-unit id="38e88fa7315be494a88a395eb056b9ace726e37c" translate="yes" xml:space="preserve">
          <source>The four character array with the Soundex result in it. Returns null if there is no Soundex representation for the string.</source>
          <target state="translated">Soundex를 사용한 4 개의 문자 배열이 결과입니다. 문자열에 대한 Soundex 표현이 없으면 null을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="0480c3df77ed33fc07e614d2d8de8fc045910624" translate="yes" xml:space="preserve">
          <source>The four character array with the Soundex result in it. The array has zero's in it if there is no Soundex representation for the string.</source>
          <target state="translated">Soundex를 사용한 4 개의 문자 배열이 결과입니다. 문자열에 대한 Soundex 표현이없는 경우 배열에 0이 있습니다.</target>
        </trans-unit>
        <trans-unit id="5766013bffb3825b0abbe1d083667aa11616b979" translate="yes" xml:space="preserve">
          <source>The fourth form, &lt;code&gt;goto case&lt;/code&gt;&lt;a href=&quot;expression#Expression&quot;&gt;&lt;i&gt;Expression&lt;/i&gt;&lt;/a&gt;&lt;code&gt;;&lt;/code&gt;, transfers to the &lt;a href=&quot;#CaseStatement&quot;&gt;&lt;i&gt;CaseStatement&lt;/i&gt;&lt;/a&gt; of the innermost enclosing &lt;a href=&quot;#SwitchStatement&quot;&gt;&lt;i&gt;SwitchStatement&lt;/i&gt;&lt;/a&gt; with a matching &lt;a href=&quot;expression#Expression&quot;&gt;&lt;i&gt;Expression&lt;/i&gt;&lt;/a&gt;.</source>
          <target state="translated">네 번째 형태 인 &lt;code&gt;goto case&lt;/code&gt; &lt;a href=&quot;expression#Expression&quot;&gt;&lt;i&gt;Expression&lt;/i&gt;&lt;/a&gt; &lt;code&gt;;&lt;/code&gt; , 일치하는 &lt;a href=&quot;expression#Expression&quot;&gt;&lt;i&gt;Expression&lt;/i&gt;&lt;/a&gt; 을 사용하여 가장 안쪽에있는 &lt;a href=&quot;#SwitchStatement&quot;&gt;&lt;i&gt;SwitchStatement&lt;/i&gt;&lt;/a&gt; 의 &lt;a href=&quot;#CaseStatement&quot;&gt;&lt;i&gt;CaseStatement&lt;/i&gt;&lt;/a&gt; 로 전송합니다 .&lt;i&gt;&lt;/i&gt;&lt;i&gt;&lt;/i&gt;</target>
        </trans-unit>
        <trans-unit id="13efbc5e672643becc355867b63d8f22b9e474d7" translate="yes" xml:space="preserve">
          <source>The fourth version counts the number of elements in a range. It is an optimization for the third version: if the given range has the &lt;code&gt;length&lt;/code&gt; property the count is returned right away, otherwise performs &amp;Omicron;(&lt;code&gt;haystack.length&lt;/code&gt;) to walk the range.</source>
          <target state="translated">네 번째 버전은 범위 내의 요소 수를 계산합니다. 주어진 범위에 &lt;code&gt;length&lt;/code&gt; 속성 이 있으면 카운트가 즉시 반환되고, 그렇지 않으면 &amp;Omicron; ( &lt;code&gt;haystack.length&lt;/code&gt; )를 수행 하여 범위를 걷습니다.</target>
        </trans-unit>
        <trans-unit id="48edc0798b06f223cb1ddbda6fdb31f83f4e14ab" translate="yes" xml:space="preserve">
          <source>The fractional part of x.</source>
          <target state="translated">x의 소수 부분.</target>
        </trans-unit>
        <trans-unit id="afaeb9378608c5260a3259e8f02e82dbd938d6f1" translate="yes" xml:space="preserve">
          <source>The fractional seconds portion of the time.</source>
          <target state="translated">시간의 소수 초입니다.</target>
        </trans-unit>
        <trans-unit id="a033f1a65da2c07804aca3b53ca406684bb91d81" translate="yes" xml:space="preserve">
          <source>The free list is circular, with the last node pointing back to the first.</source>
          <target state="translated">자유 목록은 원형이며 마지막 노드는 첫 번째 노드를 다시 가리 킵니다.</target>
        </trans-unit>
        <trans-unit id="c4517bc5d244bf2185e9745bb334e09ef6af1ee0" translate="yes" xml:space="preserve">
          <source>The free tree has special handling of duplicates (a singly-linked list per node) in anticipation of large number of duplicates. Allocation time from the free tree is expected to be &amp;Omicron;(&lt;code&gt;log n&lt;/code&gt;) where &lt;code&gt;n&lt;/code&gt; is the number of distinct sizes (not total nodes) kept in the free tree.</source>
          <target state="translated">사용 가능한 트리에는 많은 수의 중복을 예상하여 중복 (노드 당 단일 연결 목록)에 대한 특수 처리가 있습니다. 사용 가능한 트리에서 할당 시간은 &amp;Omicron; ( &lt;code&gt;log n&lt;/code&gt; ) 이어야합니다. 여기서 &lt;code&gt;n&lt;/code&gt; 은 사용 가능한 트리에 보관 된 고유 한 크기 (총 노드 아님)의 수입니다.</target>
        </trans-unit>
        <trans-unit id="ee4d09c6e55b89fcf5b3563176298a96aa717ff4" translate="yes" xml:space="preserve">
          <source>The freelist is maintained in increasing address order, which makes coalescing easy.</source>
          <target state="translated">프리리스트는 증가하는 주소 순서로 유지되므로 통합이 쉬워집니다.</target>
        </trans-unit>
        <trans-unit id="8fea8f11f99f1f8b366c244a4de1a614fd67b29c" translate="yes" xml:space="preserve">
          <source>The front element in the container</source>
          <target state="translated">컨테이너의 앞면 요소</target>
        </trans-unit>
        <trans-unit id="13da137fb2ab48bf4928214ec4fc5ac7d9dd7e0b" translate="yes" xml:space="preserve">
          <source>The full URL to get/put</source>
          <target state="translated">가져 오거나 넣을 전체 URL</target>
        </trans-unit>
        <trans-unit id="bdda625bfb1430028e4b6006d0968612c21121d6" translate="yes" xml:space="preserve">
          <source>The full list of named character entities from the &lt;a href=&quot;https://w3.org/TR/html5/syntax.html#named-character-references&quot;&gt;HTML 5 Spec&lt;/a&gt; is supported except for the named entities which contain multiple code points. Below is a</source>
          <target state="translated">여러 코드 포인트를 포함하는 명명 된 엔터티를 제외하고 &lt;a href=&quot;https://w3.org/TR/html5/syntax.html#named-character-references&quot;&gt;HTML 5 사양&lt;/a&gt; 의 명명 된 문자 엔터티 전체 목록 이 지원됩니다. 아래는</target>
        </trans-unit>
        <trans-unit id="53abcf6f821b2e7ec7e516af58f09e5bd8d1aff5" translate="yes" xml:space="preserve">
          <source>The full module system</source>
          <target state="translated">전체 모듈 시스템</target>
        </trans-unit>
        <trans-unit id="ee63124c4c066661e689e48b06ebee05399673e5" translate="yes" xml:space="preserve">
          <source>The fully qualified name of the symbol.</source>
          <target state="translated">정규화 된 기호 이름입니다.</target>
        </trans-unit>
        <trans-unit id="4d00150ca0468a4f7743a4f3a38c13aec942337c" translate="yes" xml:space="preserve">
          <source>The fully-qualified names of both types if the two type names are not the same, or the unqualified names of both types if the two type names are the same.</source>
          <target state="translated">두 유형 이름이 동일하지 않은 경우 두 유형의 완전한 이름이거나 두 유형 이름이 동일한 경우 두 유형의 규정되지 않은 이름입니다.</target>
        </trans-unit>
        <trans-unit id="38a1580a58c3012db59e4a8a700c45c0c6b1674d" translate="yes" xml:space="preserve">
          <source>The function &lt;code&gt;fd&lt;/code&gt; is added to the nested references of the newly created variable such that a closure is made for the variable when the address of &lt;code&gt;fd&lt;/code&gt; is taken.</source>
          <target state="translated">함수 &lt;code&gt;fd&lt;/code&gt; 주소가 폐쇄 될 때 가변 만들어 지도록 새롭게 생성 된 변수의 중첩 된 참조에 첨가 &lt;code&gt;fd&lt;/code&gt; 취해진 다.</target>
        </trans-unit>
        <trans-unit id="1bc8d00dffc62265a3b988178c4153a69f61f3ec" translate="yes" xml:space="preserve">
          <source>The function &lt;code&gt;remove&lt;/code&gt; works on bidirectional ranges that have assignable lvalue elements. The moving strategy is (listed from fastest to slowest):</source>
          <target state="translated">&lt;code&gt;remove&lt;/code&gt; 기능 은 할당 가능한 lvalue 요소가있는 양방향 범위에서 작동합니다. 이동 전략은 다음과 같습니다 (가장 빠름에서 느림).</target>
        </trans-unit>
        <trans-unit id="dfdecb6a33548c2c3a57ed9788619ffcbcd64fcd" translate="yes" xml:space="preserve">
          <source>The function allocates memory if and only if it gets to the third stage of this algorithm.</source>
          <target state="translated">이 알고리즘의 세 번째 단계에 도달하는 경우에만 함수가 메모리를 할당합니다.</target>
        </trans-unit>
        <trans-unit id="59d7ef7bccfe8628462077a719a53074c919f8fa" translate="yes" xml:space="preserve">
          <source>The function call operator, &lt;code&gt;()&lt;/code&gt;, can be overloaded by declaring a function named &lt;code&gt;opCall&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;opCall&lt;/code&gt; 이라는 함수를 선언하면 함수 호출 연산자 &lt;code&gt;()&lt;/code&gt; 가 오버로드 될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="75414fa30a8eeadba0f9df43d9a81faffe1eb302" translate="yes" xml:space="preserve">
          <source>The function declaration makes it clear what the inputs and outputs to the function are.</source>
          <target state="translated">함수 선언은 함수의 입력과 출력이 무엇인지 명확하게합니다.</target>
        </trans-unit>
        <trans-unit id="36bd72a87a6fb51210593d16c9d3850d26ad2813" translate="yes" xml:space="preserve">
          <source>The function generated tests if the &lt;a href=&quot;#Code%20point&quot;&gt;code point&lt;/a&gt; passed belongs to this set or not. The result is to be used with string mixin. The intended usage area is aggressive optimization via meta programming in parser generators and the like.</source>
          <target state="translated">함수는 전달 된 &lt;a href=&quot;#Code%20point&quot;&gt;코드 포인트&lt;/a&gt; 가이 세트에 속 하는지 테스트합니다 . 결과는 문자열 믹스 인과 함께 사용됩니다. 의도 된 사용 영역은 파서 생성기 등에서의 메타 프로그래밍을 통한 적극적인 최적화이다.</target>
        </trans-unit>
        <trans-unit id="98e31cd639a66b786829a51b07b196c9eb02f441" translate="yes" xml:space="preserve">
          <source>The function is doing something impure, so mark it as impure. If there's a purity error, return true.</source>
          <target state="translated">함수가 불완전한 작업을 수행하고 있으므로 불완전한 것으로 표시하십시오. 순도 오류가 있으면 true를 리턴하십시오.</target>
        </trans-unit>
        <trans-unit id="78716a8e02a777fde55cd9f5bd9506b86f2cd433" translate="yes" xml:space="preserve">
          <source>The function is doing something that may allocate with the GC, so mark it as not nogc (not no-how).</source>
          <target state="translated">함수가 GC에 할당 할 수있는 작업을 수행하고 있으므로 nogc가 아닌 것으로 표시하십시오 (노하우 아님).</target>
        </trans-unit>
        <trans-unit id="1582435911618910fd1cebd4a56e5bade73d2f42" translate="yes" xml:space="preserve">
          <source>The function is doing something unsafe, so mark it as unsafe. If there's a safe error, return true.</source>
          <target state="translated">함수가 안전하지 않은 작업을 수행하고 있으므로 안전하지 않은 것으로 표시하십시오. 안전한 오류가 있으면 true를 반환하십시오.</target>
        </trans-unit>
        <trans-unit id="185793595bc4f7b5898c63f905d91abe291e2c5e" translate="yes" xml:space="preserve">
          <source>The function is explicitly annotated &lt;code&gt;@nogc&lt;/code&gt; because inference could fail, see &lt;a href=&quot;https://issues.dlang.org/show_bug.cgi?id=17084&quot;&gt;issue 17084&lt;/a&gt;.</source>
          <target state="translated">이 함수는 추론이 실패 할 수 있기 때문에 &lt;code&gt;@nogc&lt;/code&gt; 에 명시 적으로 주석이 달려 있습니다 ( &lt;a href=&quot;https://issues.dlang.org/show_bug.cgi?id=17084&quot;&gt;문제 17084&lt;/a&gt; 참조) .</target>
        </trans-unit>
        <trans-unit id="94377b90d447230e8a5ccf1a52d33d616f20136c" translate="yes" xml:space="preserve">
          <source>The function is intended to replace the hexadecimal literal strings starting with &lt;code&gt;'x'&lt;/code&gt;, which could be removed to simplify the core language.</source>
          <target state="translated">이 함수는 핵심 언어를 단순화하기 위해 제거 할 수있는 &lt;code&gt;'x'&lt;/code&gt; 로 시작하는 16 진 리터럴 문자열을 대체하기위한 것 입니다.</target>
        </trans-unit>
        <trans-unit id="408608d2bfc199a6a551d83606a62872252fdf6d" translate="yes" xml:space="preserve">
          <source>The function overloads returning a string allocate their return values using the GC. The versions returning static arrays use pass-by-value for the return value, effectively avoiding dynamic allocation.</source>
          <target state="translated">문자열을 반환하는 함수 오버로드는 GC를 사용하여 반환 값을 할당합니다. 정적 배열을 반환하는 버전은 동적 할당을 효과적으로 피하면서 반환 값에 값별 패스를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="7b0e25cbd51eccc8cf3fde77bb9a906902973f49" translate="yes" xml:space="preserve">
          <source>The function parameter attributes &lt;code&gt;return&lt;/code&gt; and &lt;code&gt;scope&lt;/code&gt; are used to track what happens to low-level pointers passed to functions. Such pointers include: raw pointers, arrays, &lt;code&gt;this&lt;/code&gt;, classes, &lt;code&gt;ref&lt;/code&gt; parameters, delegate/lazy parameters, and aggregates containing a pointer.</source>
          <target state="translated">함수 매개 변수 속성 &lt;code&gt;return&lt;/code&gt; 및 &lt;code&gt;scope&lt;/code&gt; 는 함수에 전달 된 하위 레벨 포인터에서 발생하는 상황을 추적하는 데 사용됩니다. 이러한 포인터에는 원시 포인터, 배열, &lt;code&gt;this&lt;/code&gt; , 클래스, &lt;code&gt;ref&lt;/code&gt; 매개 변수, 대리자 / 지연 매개 변수 및 포인터가 포함 된 집계가 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="6e994bfc1a839ed290d4129f0f5733e981d5373e" translate="yes" xml:space="preserve">
          <source>The function returns a range containing the consecutive reduced values. If there is more than one &lt;code&gt;fun&lt;/code&gt;, the element type will be &lt;a href=&quot;std_typecons#Tuple&quot;&gt;&lt;code&gt; std.typecons.Tuple&lt;/code&gt;&lt;/a&gt; containing one element for each &lt;code&gt;fun&lt;/code&gt;.</source>
          <target state="translated">이 함수는 연속 감소 값이 포함 된 범위를 반환합니다. &lt;code&gt;fun&lt;/code&gt; 이 하나 이상인 경우 요소 유형은 &lt;a href=&quot;std_typecons#Tuple&quot;&gt; &lt;code&gt; std.typecons.Tuple&lt;/code&gt; &lt;/a&gt; 로 각 &lt;code&gt;fun&lt;/code&gt; 에 대해 하나의 요소를 포함 합니다.</target>
        </trans-unit>
        <trans-unit id="f1de9581bb40aa0605e1d4f2b900b32c62cf6dcb" translate="yes" xml:space="preserve">
          <source>The function returns immediately, leaving the child process to execute in parallel with its parent. It is recommended to always call &lt;a href=&quot;#wait&quot;&gt;&lt;code&gt;wait&lt;/code&gt;&lt;/a&gt; on the returned &lt;a href=&quot;#Pid&quot;&gt;&lt;code&gt;Pid&lt;/code&gt;&lt;/a&gt; unless the process was spawned with &lt;code&gt;Config.detached&lt;/code&gt; flag, as detailed in the documentation for &lt;code&gt;wait&lt;/code&gt;.</source>
          <target state="translated">이 함수는 즉시 반환되어 자식 프로세스가 부모 프로세스와 병렬로 실행되도록합니다. 그것은 항상 호출에 추천 &lt;a href=&quot;#wait&quot;&gt; &lt;code&gt;wait&lt;/code&gt; &lt;/a&gt; 반환에 &lt;a href=&quot;#Pid&quot;&gt; &lt;code&gt;Pid&lt;/code&gt; &lt;/a&gt; 프로세스로 양산하지 않는 한 &lt;code&gt;Config.detached&lt;/code&gt; 플래그에 대한 설명서에 따라 &lt;code&gt;wait&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d1462ec35dc456ac6ff3045ecdc8148b89412c36" translate="yes" xml:space="preserve">
          <source>The function source code must be available to the compiler. Functions which exist in the source code only as extern declarations cannot be executed in CTFE.</source>
          <target state="translated">함수 소스 코드는 컴파일러에서 사용할 수 있어야합니다. 소스 코드에 extern 선언으로 만 존재하는 함수는 CTFE에서 실행할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="c99c9ccaa6aadf1ddb21d118ac9a2b39a2936c1d" translate="yes" xml:space="preserve">
          <source>The function that wants to measure speed.</source>
          <target state="translated">속도를 측정하려는 기능입니다.</target>
        </trans-unit>
        <trans-unit id="411ac38391245e7bd9f2d61489a0679e909d3705" translate="yes" xml:space="preserve">
          <source>The function to become the base of the speed.</source>
          <target state="translated">속도의 기초가되는 기능.</target>
        </trans-unit>
        <trans-unit id="ca30c519a6a156f76c6573e841573612bc2aad51" translate="yes" xml:space="preserve">
          <source>The function to execute.</source>
          <target state="translated">실행할 함수입니다.</target>
        </trans-unit>
        <trans-unit id="38560d673ec14174a5201f65e942b10ff886f6eb" translate="yes" xml:space="preserve">
          <source>The function to execute. This may be the actual function passed by the user to spawn itself, or may be a wrapper function.</source>
          <target state="translated">실행할 함수입니다. 이것은 사용자가 자신을 스폰하기 위해 전달한 실제 함수이거나 래퍼 함수일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="67a64604c4717ec6e34e3f3a6e53ee63c3039ae1" translate="yes" xml:space="preserve">
          <source>The function used to check if &lt;code&gt;addr&lt;/code&gt; is marked.</source>
          <target state="translated">&lt;code&gt;addr&lt;/code&gt; 가 표시되어 있는지 확인하는 데 사용되는 기능 입니다.</target>
        </trans-unit>
        <trans-unit id="a4a8105c562ae246a8ce7c12b0a3320ba9511dc7" translate="yes" xml:space="preserve">
          <source>The function used to generate the next time point in the range.</source>
          <target state="translated">범위에서 다음 시점을 생성하는 데 사용되는 함수입니다.</target>
        </trans-unit>
        <trans-unit id="dc715bdc2551fef5137debdc9a1fe82c19568021" translate="yes" xml:space="preserve">
          <source>The function used to generate the time points of the range over the interval.</source>
          <target state="translated">간격에 걸쳐 범위의 시점을 생성하는 데 사용되는 함수입니다.</target>
        </trans-unit>
        <trans-unit id="f3d2158936e817ae5d4b5a34d016e49a32ca1146" translate="yes" xml:space="preserve">
          <source>The function will not return if any enclosing finally clause does a return, goto or throw that exits the finally clause.</source>
          <target state="translated">엔 클로징 finally 절이 finally 절을 종료하는 return, goto 또는 throw를 수행하면 함수가 반환되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="46f3e02eaaa99bc9ca72c46c606ddf965d307189" translate="yes" xml:space="preserve">
          <source>The functionality closely follows the IEEE754-2008 standard for floating-point arithmetic, including the use of camelCase names rather than C99-style lower case names. All of these functions behave correctly when presented with an infinity or NaN.</source>
          <target state="translated">이 기능은 C99 스타일의 소문자 이름이 아닌 카멜 케이스 이름 사용을 포함하여 부동 소수점 산술에 대한 IEEE754-2008 표준을 밀접하게 따릅니다. 이러한 기능은 모두 무한대 또는 NaN으로 표시 될 때 올바르게 작동합니다.</target>
        </trans-unit>
        <trans-unit id="a8b49dde8278905e1da61afa2345291851916bc1" translate="yes" xml:space="preserve">
          <source>The functionally is based on &lt;a href=&quot;http://curl.haxx.se/libcurl&quot;&gt;libcurl&lt;/a&gt;. LibCurl is licensed under an MIT/X derivative license.</source>
          <target state="translated">기능적으로는 &lt;a href=&quot;http://curl.haxx.se/libcurl&quot;&gt;libcurl을&lt;/a&gt; 기반으로 합니다. LibCurl은 MIT / X 파생 라이센스에 따라 라이센스가 부여됩니다.</target>
        </trans-unit>
        <trans-unit id="4e9193abd91f293a360c49af75182f625a029338" translate="yes" xml:space="preserve">
          <source>The functions &lt;a href=&quot;#formatValue&quot;&gt;&lt;code&gt;formatValue&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#unformatValue&quot;&gt;&lt;code&gt;unformatValue&lt;/code&gt;&lt;/a&gt; are used for the plumbing.</source>
          <target state="translated">&lt;a href=&quot;#formatValue&quot;&gt; &lt;code&gt;formatValue&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#unformatValue&quot;&gt; &lt;code&gt;unformatValue&lt;/code&gt; &lt;/a&gt; 함수 는 배관에 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="09d84b61f63134826318f5b038f0d9e7c6a89164" translate="yes" xml:space="preserve">
          <source>The functions &lt;a href=&quot;#multiwayMerge&quot;&gt;&lt;code&gt;multiwayMerge&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#multiwayUnion&quot;&gt;&lt;code&gt;multiwayUnion&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#setDifference&quot;&gt;&lt;code&gt;setDifference&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#setIntersection&quot;&gt;&lt;code&gt;setIntersection&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#setSymmetricDifference&quot;&gt;&lt;code&gt;setSymmetricDifference&lt;/code&gt;&lt;/a&gt; expect a range of sorted ranges as input.</source>
          <target state="translated">기능은 &lt;a href=&quot;#multiwayMerge&quot;&gt; &lt;code&gt;multiwayMerge&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#multiwayUnion&quot;&gt; &lt;code&gt;multiwayUnion&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#setDifference&quot;&gt; &lt;code&gt;setDifference&lt;/code&gt; 는&lt;/a&gt; , &lt;a href=&quot;#setIntersection&quot;&gt; &lt;code&gt;setIntersection&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#setSymmetricDifference&quot;&gt; &lt;code&gt;setSymmetricDifference&lt;/code&gt; 는&lt;/a&gt; 입력으로 정렬 범위의 범위를 기대한다.</target>
        </trans-unit>
        <trans-unit id="4fde7de03cdc04e15dde2a51577db6987e675d9f" translate="yes" xml:space="preserve">
          <source>The functions can use &lt;code&gt;@trusted&lt;/code&gt; instead of &lt;code&gt;@safe&lt;/code&gt;.</source>
          <target state="translated">기능을 사용할 수 있습니다 &lt;code&gt;@trusted&lt;/code&gt; 대신 &lt;code&gt;@safe&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="30a160975f83d4201f4fd65daf1113007bc807be" translate="yes" xml:space="preserve">
          <source>The gamma and related functions, and the error function are crucial for mathematical statistics. The Bessel and related functions arise in problems involving wave propagation (especially in optics). Other major categories of special functions include the elliptic integrals (related to the arc length of an ellipse), and the hypergeometric functions.</source>
          <target state="translated">감마 및 관련 함수와 오류 함수는 수학 통계에 중요합니다. 베셀 및 관련 기능은 웨이브 전파와 관련된 문제 (특히 광학 분야)에서 발생합니다. 특수 함수의 다른 주요 범주에는 타원 적분 (타원의 호 길이와 관련) 및 초기 하 함수가 있습니다.</target>
        </trans-unit>
        <trans-unit id="447281d1324337b15482dcfc848c6a78d28256cf" translate="yes" xml:space="preserve">
          <source>The gapped similarity at the current match length (initially 1, grows with each call to &lt;code&gt;popFront&lt;/code&gt;).</source>
          <target state="translated">현재 일치 길이에서의 갭 유사성 (처음에는 1, &lt;code&gt;popFront&lt;/code&gt; 에 대한 호출마다 증가 )</target>
        </trans-unit>
        <trans-unit id="05176e7bf5bf611688f908ea258370d40d6b3039" translate="yes" xml:space="preserve">
          <source>The garbage collector calls the destructor function when the object is deleted. The syntax is:</source>
          <target state="translated">가비지 콜렉터는 오브젝트가 삭제 될 때 소멸자 함수를 호출합니다. 구문은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="8162594fc1e13b54530b98ac255177e2a9d2ab78" translate="yes" xml:space="preserve">
          <source>The garbage collector does not scan non-pointer fields for GC pointers.</source>
          <target state="translated">가비지 수집기는 포인터가 아닌 필드에서 GC 포인터를 검색하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="bace0715c82c9b149257399e18cc90537b20fbf1" translate="yes" xml:space="preserve">
          <source>The garbage collector does not scan the stacks of threads not created by the D Thread interface. Nor does it scan the data segments of other DLLs, etc.</source>
          <target state="translated">가비지 콜렉터는 D 스레드 인터페이스로 작성되지 않은 스레드 스택을 스캔하지 않습니다. 다른 DLL 등의 데이터 세그먼트도 스캔하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="679912e5f590d3f8f03034fbcabdaff8e29c8cba" translate="yes" xml:space="preserve">
          <source>The garbage collector does not scan the stacks of threads not registered with the D runtime, nor does it scan the data segments of shared libraries that aren't registered with the D runtime.</source>
          <target state="translated">가비지 수집기는 D 런타임에 등록되지 않은 스레드 스택을 검색하지 않으며 D 런타임에 등록되지 않은 공유 라이브러리의 데이터 세그먼트를 검색하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="248f5f617e65210251e2aceaf897cfac6784a5ad" translate="yes" xml:space="preserve">
          <source>The garbage collector is not guaranteed to run the destructor for all unreferenced objects. Furthermore, the order in which the garbage collector calls destructors for unreferenced objects is not specified. This means that when the garbage collector calls a destructor for an object of a class that has members which are references to garbage collected objects, those references may no longer be valid. This means that destructors cannot reference sub objects. This rule does not apply to auto objects or objects destructed with &lt;a href=&quot;https://dlang.org/phobos/object.html#destroy&quot;&gt;&lt;code&gt;destroy&lt;/code&gt;&lt;/a&gt;, as the destructor is not being run by the garbage collector, meaning all references are valid.</source>
          <target state="translated">가비지 수집기는 참조되지 않은 모든 객체에 대해 소멸자를 실행한다고 보장하지는 않습니다. 또한 가비지 수집기가 참조되지 않은 객체에 대한 소멸자를 호출하는 순서는 지정되지 않습니다. 이것은 가비지 수집기가 가비지 수집 된 객체에 대한 참조 인 멤버가있는 클래스의 객체에 대한 소멸자를 호출 할 때 해당 참조가 더 이상 유효하지 않을 수 있음을 의미합니다. 이는 소멸자가 하위 오브젝트를 참조 할 수 없음을 의미합니다. 가비지 수집기가 소멸자를 실행 하지 않으므로 자동 참조 또는 &lt;a href=&quot;https://dlang.org/phobos/object.html#destroy&quot;&gt; &lt;code&gt;destroy&lt;/code&gt; 로&lt;/a&gt; 소멸 된 객체에는이 규칙이 적용되지 않으므로 모든 참조가 유효합니다.</target>
        </trans-unit>
        <trans-unit id="7ed0a2988d2028482af5b70f4886f714e874cd68" translate="yes" xml:space="preserve">
          <source>The garbage collector looks for roots in:</source>
          <target state="translated">가비지 수집기는 다음에서 루트를 찾습니다.</target>
        </trans-unit>
        <trans-unit id="a61608c994e8531817d927f16b69cb4ec2652687" translate="yes" xml:space="preserve">
          <source>The general usage guideline is to keep regex complexity on the side of simplicity, as its capabilities reside in purely character-level manipulation. As such it's ill-suited for tasks involving higher level invariants like matching an integer number &lt;em&gt;bounded&lt;/em&gt; in an [a,b] interval. Checks of this sort of are better addressed by additional post-processing.</source>
          <target state="translated">일반적인 사용법 지침은 정규식의 복잡성을 단순성 측면에서 유지하는 것인데, 그 기능은 순전히 문자 수준 조작에 있기 때문입니다. 따라서 [a, b] 간격으로 &lt;em&gt;경계를 정하는&lt;/em&gt; 정수와 일치하는 것과 같이 더 높은 수준의 불변 값을 포함하는 작업에는 적합하지 않습니다 . 이러한 종류의 검사는 추가 사후 처리로 해결하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="587ae2153e1cd24d01fed6ce88e2ec32ff8c2014" translate="yes" xml:space="preserve">
          <source>The generated &lt;code&gt;opAssign&lt;/code&gt; function has the following signature:</source>
          <target state="translated">생성 된 &lt;code&gt;opAssign&lt;/code&gt; 함수에는 다음과 같은 서명이 있습니다.</target>
        </trans-unit>
        <trans-unit id="b65a1da736509a9381ee000758f5d850e508e3e2" translate="yes" xml:space="preserve">
          <source>The generated links to D symbols are relative if they have the same root package as the module being documented. If not, their URLs are preceeded by a &lt;code&gt;&amp;amp;dollar;(DDOC_ROOT_pkg)&lt;/code&gt; macro, where &lt;code&gt;pkg&lt;/code&gt; is the root package of the symbol being linked to. Links to D symbols are generated with a &lt;code&gt;&amp;amp;dollar;(DOC_EXTENSION)&lt;/code&gt; macro after the module name. So the generated URL for &lt;code&gt;[Object]&lt;/code&gt; in the above example is as if you had written:</source>
          <target state="translated">생성 된 D 심볼에 대한 링크는 문서화 할 모듈과 동일한 루트 패키지가있는 경우 상대적입니다. 그렇지 않은 경우 URL 앞에 &lt;code&gt;&amp;amp;dollar;(DDOC_ROOT_pkg)&lt;/code&gt; 매크로 가옵니다. 여기서 &lt;code&gt;pkg&lt;/code&gt; 는 연결된 심볼의 루트 패키지입니다. D 기호에 대한 링크 는 모듈 이름 뒤에 &lt;code&gt;&amp;amp;dollar;(DOC_EXTENSION)&lt;/code&gt; 매크로를 사용하여 생성됩니다 . 따라서 위 예제에서 &lt;code&gt;[Object]&lt;/code&gt; 에 대해 생성 된 URL 은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="adc505580a3e3a25fed9b9c63e6f0745b68f08fa" translate="yes" xml:space="preserve">
          <source>The getopt module implements a &lt;code&gt;getopt&lt;/code&gt; function, which adheres to the POSIX syntax for command line options. GNU extensions are supported in the form of long options introduced by a double dash (&quot;--&quot;). Support for bundling of command line options, as was the case with the more traditional single-letter approach, is provided but not enabled by default.</source>
          <target state="translated">getopt 모듈은 &lt;code&gt;getopt&lt;/code&gt; 기능을 구현하며 명령 행 옵션에 대한 POSIX 구문을 준수합니다. GNU 확장은 이중 대시 ( &quot;-&quot;)로 도입 된 긴 옵션의 형태로 지원됩니다. 보다 전통적인 단일 문자 접근 방식과 마찬가지로 명령 줄 옵션 번들 지원이 제공되지만 기본적으로 활성화되어 있지는 않습니다.</target>
        </trans-unit>
        <trans-unit id="38436bf13581d96cda14b3d712a9839eef76ade6" translate="yes" xml:space="preserve">
          <source>The given HMAC token is compared with the expected token using the &lt;code&gt;==&lt;/code&gt; string comparison, which returns &lt;code&gt;false&lt;/code&gt; as soon as the first wrong element is found. If a wrong element is found, then a rejection is sent back to the sender.</source>
          <target state="translated">주어진 HMAC 토큰은 &lt;code&gt;==&lt;/code&gt; 문자열 비교를 사용하여 예상 토큰과 비교 되며, 첫 번째 잘못된 요소가 발견되면 즉시 &lt;code&gt;false&lt;/code&gt; 를 반환합니다 . 잘못된 요소가 발견되면 거부가 발신자에게 다시 전송됩니다.</target>
        </trans-unit>
        <trans-unit id="262b74b064f7ed4973ae2acf3633f01634ced6b1" translate="yes" xml:space="preserve">
          <source>The given array exposed to a standard D array.</source>
          <target state="translated">주어진 배열은 표준 D 배열에 노출됩니다.</target>
        </trans-unit>
        <trans-unit id="8bc950de5698dccabc99a10c52424998aec0c7a6" translate="yes" xml:space="preserve">
          <source>The given array of &lt;code&gt;char&lt;/code&gt; or random-access range of &lt;code&gt;char&lt;/code&gt; or &lt;code&gt;ubyte&lt;/code&gt; is expected to be in the format specified in &lt;a href=&quot;http://tools.ietf.org/html/rfc5322&quot;&gt;RFC 5322&lt;/a&gt; section 3.3 with the grammar rule</source>
          <target state="translated">주어진 &lt;code&gt;char&lt;/code&gt; 배열 또는 &lt;code&gt;char&lt;/code&gt; 또는 &lt;code&gt;ubyte&lt;/code&gt; 의 임의 액세스 범위 는 문법 규칙과 함께 &lt;a href=&quot;http://tools.ietf.org/html/rfc5322&quot;&gt;RFC 5322&lt;/a&gt; 섹션 3.3에 지정된 형식이어야합니다.</target>
        </trans-unit>
        <trans-unit id="12501a73a540c686a37f4823a66a820dabde2f39" translate="yes" xml:space="preserve">
          <source>The glob pattern</source>
          <target state="translated">글로브 패턴</target>
        </trans-unit>
        <trans-unit id="496ff2fc921b0a5cf99d9a4227ed4bf96d90c632" translate="yes" xml:space="preserve">
          <source>The grapheme cluster represents a horizontally segmentable unit of text, consisting of some grapheme base (which may consist of a Korean syllable) together with any number of nonspacing marks applied to it.</source>
          <target state="translated">grapheme 클러스터는 수평으로 분할 가능한 텍스트 단위를 나타내며, 일부 grapheme base (한국어 음절로 구성 될 수 있음)와 적용되는 임의의 비 간격 표시로 구성됩니다.</target>
        </trans-unit>
        <trans-unit id="37af0a5e629675000a6dfa7103d088d3ddd62dac" translate="yes" xml:space="preserve">
          <source>The greatest common divisor of the given arguments.</source>
          <target state="translated">주어진 인수의 최대 공약수입니다.</target>
        </trans-unit>
        <trans-unit id="8b3e1c284ef7e8df3ea6a61551c667aeed265141" translate="yes" xml:space="preserve">
          <source>The hack for bugzilla 4820 case is still questionable. Perhaps would have to handle a delegate expression with 'null' context properly in front-end.</source>
          <target state="translated">bugzilla 4820 사례에 대한 해킹은 여전히 ​​의문입니다. 프런트 엔드에서 'null'컨텍스트를 사용하여 대리자 식을 처리해야 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="38f5b63c8a583d4d295cf756159c50490e54c13e" translate="yes" xml:space="preserve">
          <source>The handle to an array is specified by naming the array, as in p, s or a:</source>
          <target state="translated">배열 핸들은 p, s 또는 a와 같이 배열의 이름을 지정하여 지정됩니다.</target>
        </trans-unit>
        <trans-unit id="06b9457ea3f4fa7b2cb019db8602c7584d3ac0a3" translate="yes" xml:space="preserve">
          <source>The handler to run if the expression throwed.</source>
          <target state="translated">표현식이 발생하면 실행할 핸들러입니다.</target>
        </trans-unit>
        <trans-unit id="bb782c4330787617d4fce577aae35ea8ac20fb68" translate="yes" xml:space="preserve">
          <source>The hash function RIPEMD-160</source>
          <target state="translated">해시 함수 RIPEMD-160</target>
        </trans-unit>
        <trans-unit id="1a548321e03af2d162f5b6fb8172e4e75095c3be" translate="yes" xml:space="preserve">
          <source>The hashBlockSize and digestSize are in bits. However, it's likely easier to simply use the convenience aliases: SHA1, SHA224, SHA256, SHA384, SHA512, SHA512_224 and SHA512_256.</source>
          <target state="translated">hashBlockSize 및 digestSize는 비트 단위입니다. 그러나 편의 별칭 (SHA1, SHA224, SHA256, SHA384, SHA512, SHA512_224 및 SHA512_256)을 사용하는 것이 더 쉽습니다.</target>
        </trans-unit>
        <trans-unit id="71c022924374f373de8247c9ee1154db2efdf429" translate="yes" xml:space="preserve">
          <source>The header can also be left empty if the input contains a header row and all columns should be iterated. The header from the input can always be accessed from the &lt;code&gt;header&lt;/code&gt; field.</source>
          <target state="translated">입력에 헤더 행이 포함되어 있고 모든 열을 반복해야하는 경우 헤더를 비워 둘 수도 있습니다. 입력의 헤더는 항상 &lt;code&gt;header&lt;/code&gt; 필드 에서 액세스 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="23806478590a3d73211d3f9cfeab9ec2c30f42f5" translate="yes" xml:space="preserve">
          <source>The header of &lt;a href=&quot;std_range&quot;&gt;&lt;code&gt;std.range&lt;/code&gt;&lt;/a&gt; for tutorials on ranges.</source>
          <target state="translated">범위에 대한 학습서를위한 &lt;a href=&quot;std_range&quot;&gt; &lt;code&gt;std.range&lt;/code&gt; &lt;/a&gt; 의 헤더입니다 .</target>
        </trans-unit>
        <trans-unit id="a73e614d706951342951d40aeeb01697424cadb7" translate="yes" xml:space="preserve">
          <source>The headers read from a successful response.</source>
          <target state="translated">성공적인 응답에서 헤더를 읽습니다.</target>
        </trans-unit>
        <trans-unit id="1ba658c4da138d5aa67105b1d7cc27b3cfde13e6" translate="yes" xml:space="preserve">
          <source>The highlighting macros start with &lt;code&gt;DDOC_&lt;/code&gt;. They control the formatting of individual parts of the presentation.</source>
          <target state="translated">강조 표시 매크로는 &lt;code&gt;DDOC_&lt;/code&gt; 로 시작 합니다. 프리젠 테이션의 개별 부분의 형식을 제어합니다.</target>
        </trans-unit>
        <trans-unit id="7850bd95e95bab4d64e3c6d1c398982e32639f37" translate="yes" xml:space="preserve">
          <source>The hook to wrap</source>
          <target state="translated">포장 고리</target>
        </trans-unit>
        <trans-unit id="8f90c58c05f3db77fe848d30cab0798e3f6b00e3" translate="yes" xml:space="preserve">
          <source>The hook's members are looked up statically in a Design by Introspection manner and are all optional. The table below illustrates the members that a hook type may define and their influence over the behavior of the &lt;code&gt;Checked&lt;/code&gt; type using it. In the table, &lt;code&gt;hook&lt;/code&gt; is an alias for &lt;code&gt;Hook&lt;/code&gt; if the type &lt;code&gt;Hook&lt;/code&gt; does not introduce any state, or an object of type &lt;code&gt;Hook&lt;/code&gt; otherwise.</source>
          <target state="translated">후크의 멤버는 Design by Introspection 방식으로 정적으로 조회되며 모두 선택 사항입니다. 아래 표는 후크 유형이 정의 할 수있는 멤버와 이를 사용하여 &lt;code&gt;Checked&lt;/code&gt; 유형 의 동작에 미치는 영향을 보여줍니다 . 표에서 &lt;code&gt;hook&lt;/code&gt; 유형 이 상태를 도입하지 않으면 &lt;code&gt;Hook&lt;/code&gt; 는 &lt;code&gt;Hook&lt;/code&gt; 의 별명 이거나 그렇지 않으면 &lt;code&gt;Hook&lt;/code&gt; 유형의 오브젝트입니다 .</target>
        </trans-unit>
        <trans-unit id="c351eba3d013581a191d3a885a49968be29fd469" translate="yes" xml:space="preserve">
          <source>The hour of the day to set this &lt;a href=&quot;#DateTime&quot;&gt;&lt;code&gt;DateTime&lt;/code&gt;&lt;/a&gt;'s hour to.</source>
          <target state="translated">이 &lt;a href=&quot;#DateTime&quot;&gt; &lt;code&gt;DateTime&lt;/code&gt; 시간&lt;/a&gt; 을 설정할 시간입니다.</target>
        </trans-unit>
        <trans-unit id="66136c779346b036c2def79ac7f0dfb73004b7bb" translate="yes" xml:space="preserve">
          <source>The hour of the day to set this &lt;a href=&quot;#TimeOfDay&quot;&gt;&lt;code&gt;TimeOfDay&lt;/code&gt;&lt;/a&gt;'s hour to.</source>
          <target state="translated">이 &lt;a href=&quot;#TimeOfDay&quot;&gt; &lt;code&gt;TimeOfDay&lt;/code&gt; &lt;/a&gt; 시간을 설정할 시간입니다.</target>
        </trans-unit>
        <trans-unit id="a6a4e60304c50d5e98aa115b78722f98c55537a4" translate="yes" xml:space="preserve">
          <source>The hour portion of the time;</source>
          <target state="translated">시간의 시간 부분;</target>
        </trans-unit>
        <trans-unit id="ae576aa7ec4954f0a9eb6186b74173801d58e446" translate="yes" xml:space="preserve">
          <source>The hours to set this &lt;a href=&quot;#SysTime&quot;&gt;&lt;code&gt;SysTime&lt;/code&gt;&lt;/a&gt;'s hour to.</source>
          <target state="translated">이 &lt;a href=&quot;#SysTime&quot;&gt; &lt;code&gt;SysTime&lt;/code&gt; &lt;/a&gt; 시간을 설정하는 시간 입니다.</target>
        </trans-unit>
        <trans-unit id="dc9947af90e8e00095ff57d0a5f1abb3e951dbc5" translate="yes" xml:space="preserve">
          <source>The idea being these are compatible with C structs.</source>
          <target state="translated">이것에 대한 아이디어는 C 구조체와 호환됩니다.</target>
        </trans-unit>
        <trans-unit id="1355f078be2cb8440aa75f9a09689cdae9f0217b" translate="yes" xml:space="preserve">
          <source>The idea of a contract is simple - it's just an expression that must evaluate to true. If it does not, the contract is broken, and by definition, the program has a bug in it. Contracts form part of the specification for a program, moving it from the documentation to the code itself. And as every programmer knows, documentation tends to be incomplete, out of date, wrong, or non-existent. Moving the contracts into the code makes them verifiable against the program.</source>
          <target state="translated">계약의 아이디어는 간단합니다. 이는 참으로 평가되어야하는 표현 일뿐입니다. 그렇지 않은 경우 계약이 중단되고 정의에 따라 프로그램에 버그가 있습니다. 계약은 프로그램 스펙의 일부를 문서에서 코드 자체로 이동하여 프로그램에 적용합니다. 그리고 모든 프로그래머가 알고 있듯이 문서는 불완전하거나 오래되었거나 잘못되었거나 존재하지 않는 경향이 있습니다. 계약을 코드로 옮기면 프로그램에 대해 검증 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f6757769fd791ee402dbfe3e43c1aa10845db21c" translate="yes" xml:space="preserve">
          <source>The identity operator &lt;code&gt;is&lt;/code&gt; cannot be overloaded.</source>
          <target state="translated">아이디 연산자 &lt;code&gt;is&lt;/code&gt; 오버로드 될 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="1a6dd428d8629e97cfcace7f86b78f24c85c36c4" translate="yes" xml:space="preserve">
          <source>The imaginary part of the number.</source>
          <target state="translated">숫자의 허수 부.</target>
        </trans-unit>
        <trans-unit id="1ac7f7e21c56da918de0900c242a59f862e477cf" translate="yes" xml:space="preserve">
          <source>The immutable applies to the type within the following parentheses. So, while &lt;code&gt;s&lt;/code&gt; can be assigned new values, the contents of &lt;code&gt;s[]&lt;/code&gt; cannot be:</source>
          <target state="translated">불변은 다음 괄호 안의 유형에 적용됩니다. 따라서 &lt;code&gt;s&lt;/code&gt; 에 새로운 값을 할당 할 수 있지만 &lt;code&gt;s[]&lt;/code&gt; 의 내용은 다음과 같을 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="b076480db50c8a69f17ceccfb8074a2146342dec" translate="yes" xml:space="preserve">
          <source>The immutable array.</source>
          <target state="translated">불변 배열.</target>
        </trans-unit>
        <trans-unit id="d4da7504d70ac035ecf312cd124c3e9b875475b7" translate="yes" xml:space="preserve">
          <source>The implementation exploits properties of types and operations to minimize additional work.</source>
          <target state="translated">이 구현은 유형 및 작업의 속성을 활용하여 추가 작업을 최소화합니다.</target>
        </trans-unit>
        <trans-unit id="94333a362aef71aa736007c1291437cf4a5d5675" translate="yes" xml:space="preserve">
          <source>The implementation guarantees that all threads simultaneously calling initOnce with the same var argument block until var is fully initialized. All side-effects of init are globally visible afterwards.</source>
          <target state="translated">구현은 모든 스레드가 var가 완전히 초기화 될 때까지 동일한 var 인수 블록으로 initOnce를 동시에 호출하도록 보장합니다. init의 모든 부작용은 나중에 세계적으로 볼 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2e2b0dbd8c35c5a1541392596f49b59f590b7d4b" translate="yes" xml:space="preserve">
          <source>The implementation is available as a public member.</source>
          <target state="translated">구현은 공개 멤버로 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="61a0fdac2dd135b95e81234f7a42c96423c9eb12" translate="yes" xml:space="preserve">
          <source>The implementation is based on the pseudocode in Fig. 4 of the paper &lt;a href=&quot;http://jmlr.csail.mit.edu/papers/volume6/rousu05a/rousu05a.pdf&quot;&gt;&quot;Efﬁcient Computation of Gapped Substring Kernels on Large Alphabets&quot;&lt;/a&gt; by Rousu et al., with additional algorithmic and systems-level optimizations.</source>
          <target state="translated">이 구현은 Rousu 등 의 논문 &lt;a href=&quot;http://jmlr.csail.mit.edu/papers/volume6/rousu05a/rousu05a.pdf&quot;&gt;&quot;큰 알파벳에서 갭이있는 서브 스트링 커널의 효율적인 계산&quot;&lt;/a&gt; 의 그림 4의 의사 코드를 기반으로하며 추가적인 알고리즘 및 시스템 수준 최적화를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="c3c79f00444b1a8f6b8dd0d247228e66376bb4b5" translate="yes" xml:space="preserve">
          <source>The implementation may handle the case of the first</source>
          <target state="translated">구현은 첫 번째 경우를 처리 할 수 ​​있습니다</target>
        </trans-unit>
        <trans-unit id="3f62d25116bc0232c42a3fb96db6f12be7eef293" translate="yes" xml:space="preserve">
          <source>The implementations of all predefined macros are implementation-defined. The reference implementation's macro definitions can be found &lt;a href=&quot;https://github.com/dlang/dmd/blob/master/res/default_ddoc_theme.ddoc&quot;&gt;here&lt;/a&gt;.</source>
          <target state="translated">사전 정의 된 모든 매크로의 구현은 구현 정의됩니다. 참조 구현의 매크로 정의는 &lt;a href=&quot;https://github.com/dlang/dmd/blob/master/res/default_ddoc_theme.ddoc&quot;&gt;여기&lt;/a&gt; 에서 찾을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="ce44ea558c01cd44607fe7bfdaba1c3db8da7616" translate="yes" xml:space="preserve">
          <source>The implicit conversions of built-in scalar types can be explicitly represented by using function call syntax. For example:</source>
          <target state="translated">내장 스칼라 유형의 암시 적 변환은 함수 호출 구문을 사용하여 명시 적으로 나타낼 수 있습니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="8663ba6f06eeb782a371db21df4acbb1af0c444b" translate="yes" xml:space="preserve">
          <source>The importance of component programming (properties, signals and slots, etc)</source>
          <target state="translated">컴포넌트 프로그래밍의 중요성 (속성, 신호 및 슬롯 등)</target>
        </trans-unit>
        <trans-unit id="c5712d89ed6b6b5326913e6635b003b614c7a5c4" translate="yes" xml:space="preserve">
          <source>The imports are looked up to satisfy any unresolved symbols at that scope. Imported symbols may hide symbols from outer scopes.</source>
          <target state="translated">가져 오기는 해당 범위에서 해결되지 않은 기호를 충족시키기 위해 조회됩니다. 가져온 심볼은 외부 범위에서 심볼을 숨길 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="28c93ed79edf143da68c0f3519f73741ba79046d" translate="yes" xml:space="preserve">
          <source>The index of the element that should be in sorted position after the function is done.</source>
          <target state="translated">함수가 완료된 후 정렬 된 위치에 있어야하는 요소의 색인입니다.</target>
        </trans-unit>
        <trans-unit id="7b8cbc4deacf04830f34d38905f8ffd00330c728" translate="yes" xml:space="preserve">
          <source>The index of the first encounter of the maximum in &lt;code&gt;range&lt;/code&gt;. If the &lt;code&gt;range&lt;/code&gt; is empty, -1 is returned.</source>
          <target state="translated">&lt;code&gt;range&lt;/code&gt; 에서 최대 값의 첫 번째 색인입니다 . 는 IF &lt;code&gt;range&lt;/code&gt; 비어, -1이 돌려 주어집니다.</target>
        </trans-unit>
        <trans-unit id="1a84eb9548c30b563a95a1fcfb270886bdd52d9e" translate="yes" xml:space="preserve">
          <source>The index of the first encounter of the minimum element in &lt;code&gt;range&lt;/code&gt;. If the &lt;code&gt;range&lt;/code&gt; is empty, -1 is returned.</source>
          <target state="translated">&lt;code&gt;range&lt;/code&gt; 에서 최소 요소가 처음 발견 된 인덱스입니다 . 는 IF &lt;code&gt;range&lt;/code&gt; 비어, -1이 돌려 주어집니다.</target>
        </trans-unit>
        <trans-unit id="33a0038a0fcaf095d5057aead72f83713739fc8b" translate="yes" xml:space="preserve">
          <source>The index of the last occurrence of &lt;code&gt;c&lt;/code&gt; in &lt;code&gt;s&lt;/code&gt;. If &lt;code&gt;c&lt;/code&gt; is not found, then &lt;code&gt;-1&lt;/code&gt; is returned. The &lt;code&gt;startIdx&lt;/code&gt; slices &lt;code&gt;s&lt;/code&gt; in the following way &lt;code&gt;s[0 .. startIdx]&lt;/code&gt;. &lt;code&gt;startIdx&lt;/code&gt; represents a codeunit index in &lt;code&gt;s&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;s&lt;/code&gt; 에서 &lt;code&gt;c&lt;/code&gt; 가 마지막으로 발생한 인덱스입니다 . 경우 &lt;code&gt;c&lt;/code&gt; 발견되지 않는, 다음 &lt;code&gt;-1&lt;/code&gt; 반환됩니다. &lt;code&gt;startIdx&lt;/code&gt; 의 슬라이스 &lt;code&gt;s&lt;/code&gt; 다음과 같은 방법으로 &lt;code&gt;s[0 .. startIdx]&lt;/code&gt; . &lt;code&gt;startIdx&lt;/code&gt; 는 &lt;code&gt;s&lt;/code&gt; 의 코드 단위 색인을 나타냅니다 .</target>
        </trans-unit>
        <trans-unit id="c2e5baf3f6abe9b83760e32cef1632ac5f67ea47" translate="yes" xml:space="preserve">
          <source>The index of the pivot for partitioning, must be less than &lt;code&gt;r.length&lt;/code&gt; or &lt;code&gt;0&lt;/code&gt; if &lt;code&gt;r.length&lt;/code&gt; is &lt;code&gt;0&lt;/code&gt;</source>
          <target state="translated">파티셔닝을위한 피벗의 인덱스는 &lt;code&gt;r.length&lt;/code&gt; 보다 작 거나 &lt;code&gt;r.length&lt;/code&gt; 가 &lt;code&gt;0&lt;/code&gt; 인 경우 &lt;code&gt;0&lt;/code&gt; 보다 작아야 합니다.</target>
        </trans-unit>
        <trans-unit id="f4e8d4da6e42c851e373823697d10ed8eae4adf3" translate="yes" xml:space="preserve">
          <source>The index of the type among &lt;code&gt;AllowedTypesParam&lt;/code&gt;, zero-based.</source>
          <target state="translated">&lt;code&gt;AllowedTypesParam&lt;/code&gt; 중 유형의 인덱스 ( 0부터 시작)입니다.</target>
        </trans-unit>
        <trans-unit id="6f4d7d5591308d1987c179c707865f7263b2522b" translate="yes" xml:space="preserve">
          <source>The index of this archive member within the archive.</source>
          <target state="translated">아카이브 내에서이 아카이브 멤버의 색인입니다.</target>
        </trans-unit>
        <trans-unit id="9b3efb64d9c8c3a8462cc2762d6a92ac26c24dcc" translate="yes" xml:space="preserve">
          <source>The index starts at &lt;code&gt;start&lt;/code&gt; and is incremented by one on every iteration.</source>
          <target state="translated">인덱스는 시작시 &lt;code&gt;start&lt;/code&gt; 하여 반복 할 때마다 하나씩 증가합니다.</target>
        </trans-unit>
        <trans-unit id="86fe7372a9779ec608c645bda74b3617bd2f68d1" translate="yes" xml:space="preserve">
          <source>The index to start reading from (instead of starting at the front). If index is a pointer, then it is updated to the index after the bytes read. The overloads with index are only available if &lt;code&gt;hasSlicing!R&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">읽기 시작 색인 (앞에서 시작하는 대신). index가 포인터이면 바이트를 읽은 후에 인덱스로 업데이트됩니다. &lt;code&gt;hasSlicing!R&lt;/code&gt; 이 &lt;code&gt;true&lt;/code&gt; 인 경우에만 인덱스가있는 과부하를 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="3b0d5226f25947ab0cd2172717539dced2cf1ca0" translate="yes" xml:space="preserve">
          <source>The index to start writing to. If index is a pointer, then it is updated to the index after the bytes read.</source>
          <target state="translated">쓸 인덱스입니다. index가 포인터이면 바이트를 읽은 후에 인덱스로 업데이트됩니다.</target>
        </trans-unit>
        <trans-unit id="f9ffb074b766c5938ff8b7357963618eaf462bcb" translate="yes" xml:space="preserve">
          <source>The indexed range. If rs consists of only one range, the return type is an alias of that range's type.</source>
          <target state="translated">인덱스 범위. rs가 하나의 범위로만 구성된 경우 리턴 유형은 해당 범위 유형의 별명입니다.</target>
        </trans-unit>
        <trans-unit id="619765ffdaa0071187a8f77abd362e7dda091d2c" translate="yes" xml:space="preserve">
          <source>The inference is done by determining if the function body follows the rules of the particular attribute.</source>
          <target state="translated">함수 본문이 특정 속성의 규칙을 따르는 지 여부를 판별하여 추론을 수행합니다.</target>
        </trans-unit>
        <trans-unit id="44470f7ce0660d4121c31a312118ccb100fd5b58" translate="yes" xml:space="preserve">
          <source>The initial count for the semaphore.</source>
          <target state="translated">세마포어의 초기 카운트</target>
        </trans-unit>
        <trans-unit id="8c9e853ca955ba71f49e1626fd9e59d97a172b5c" translate="yes" xml:space="preserve">
          <source>The initial range wrapped as a &lt;code&gt;SortedRange&lt;/code&gt; with its predicates converted to an equivalent single predicate.</source>
          <target state="translated">술어를 동등한 단일 술어로 변환하여 &lt;code&gt;SortedRange&lt;/code&gt; 로 랩핑 된 초기 범위 .</target>
        </trans-unit>
        <trans-unit id="47bf51e4f2c2e73e2360a982a3dcd26ed977c3bb" translate="yes" xml:space="preserve">
          <source>The initial range wrapped as a &lt;code&gt;SortedRange&lt;/code&gt; with the predicate &lt;code&gt;(a, b) =&amp;gt; binaryFun!less(transform(a), transform(b))&lt;/code&gt;.</source>
          <target state="translated">초기 범위 는 술어 &lt;code&gt;(a, b) =&amp;gt; binaryFun!less(transform(a), transform(b))&lt;/code&gt; 와 함께 &lt;code&gt;SortedRange&lt;/code&gt; 로 래핑됩니다 .</target>
        </trans-unit>
        <trans-unit id="ae187df68ec47146dca1715d3e3c373579beb355" translate="yes" xml:space="preserve">
          <source>The initial range wrapped as a &lt;code&gt;SortedRange&lt;/code&gt; with the predicate &lt;code&gt;binaryFun!less&lt;/code&gt;.</source>
          <target state="translated">초기 범위 는 술어 &lt;code&gt;binaryFun!less&lt;/code&gt; 와 함께 &lt;code&gt;SortedRange&lt;/code&gt; 로 랩핑되었습니다 .</target>
        </trans-unit>
        <trans-unit id="80d1aad4ad1e534532ce1e885f47d8eb7c78b11f" translate="yes" xml:space="preserve">
          <source>The initial size of each buffer. If &lt;code&gt;next&lt;/code&gt; takes its array by reference, it may resize the buffers.</source>
          <target state="translated">각 버퍼의 초기 크기 &lt;code&gt;next&lt;/code&gt; 으로 참조로 배열을 가져 오면 버퍼 크기를 조정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="06bcd9aed8f8362952958dfe41f57dcc25fe7b79" translate="yes" xml:space="preserve">
          <source>The initialization expression for the type.</source>
          <target state="translated">유형의 초기화 표현식입니다.</target>
        </trans-unit>
        <trans-unit id="ef4a846934e7e3a7c6fada2c58784a67e938dc53" translate="yes" xml:space="preserve">
          <source>The initializer for a manifest constant is evaluated using compile time function evaluation.</source>
          <target state="translated">매니페스트 상수의 이니셜 라이저는 컴파일 시간 함수 평가를 사용하여 평가됩니다.</target>
        </trans-unit>
        <trans-unit id="4866f78cdd0450f210abe845a0008dc25126137c" translate="yes" xml:space="preserve">
          <source>The initializer for a non-local immutable declaration must be evaluatable at compile time:</source>
          <target state="translated">로컬이 아닌 불변 선언의 이니셜 라이저는 컴파일 타임에 평가할 수 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="c3ff76d4230d39e88bec6a17e3fa23c6428b640f" translate="yes" xml:space="preserve">
          <source>The initializer for a non-static local immutable declaration is evaluated at run time:</source>
          <target state="translated">정적이 아닌 로컬 불변 선언의 이니셜 라이저는 런타임에 평가됩니다.</target>
        </trans-unit>
        <trans-unit id="8f27ed7b518832024e3d6a15cbe377f8e47f39ab" translate="yes" xml:space="preserve">
          <source>The initializer for a static variable must be evaluatable at compile time, and they are initialized upon the start of the thread (or the start of the program for &lt;code&gt;__gshared&lt;/code&gt;). There are no static constructors or static destructors for static local variables.</source>
          <target state="translated">정적 변수의 이니셜 라이저는 컴파일 타임에 &lt;code&gt;__gshared&lt;/code&gt; 하며 스레드 시작시 (또는 __gshared 의 프로그램 시작시) 초기화됩니다 . 정적 로컬 변수에 대한 정적 생성자 또는 정적 소멸자가 없습니다.</target>
        </trans-unit>
        <trans-unit id="56398784568892251b9dcc7b9a121fdad0fc1209" translate="yes" xml:space="preserve">
          <source>The inout forms a wildcard that stands in for any of mutable, const, immutable, inout, or inout const. When the function is called, the inout of the return type is changed to whatever the mutable, const, immutable, inout, or inout const status of the argument type to the parameter inout was.</source>
          <target state="translated">입력은 변경 가능, const, 불변, 입력 또는 입력 const 중 하나를 나타내는 와일드 카드를 형성합니다. 함수가 호출되면 리턴 유형의 입력이 매개 변수 inout에 대한 인수 유형의 가변, const, 불변, inout 또는 inout const 상태로 변경됩니다.</target>
        </trans-unit>
        <trans-unit id="47e39fe3c6321bc48452728017762afb10e65931" translate="yes" xml:space="preserve">
          <source>The inout in the return type is then rewritten to be the inout matched qualifiers:</source>
          <target state="translated">그런 다음 리턴 유형의 입력은 입력 일치 된 규정 자로 다시 작성됩니다.</target>
        </trans-unit>
        <trans-unit id="894e5ecc4ff73411cc66384f9e949e3263a04d5e" translate="yes" xml:space="preserve">
          <source>The input data is too long (There's no guarantee the first part of the data is valid)</source>
          <target state="translated">입력 데이터가 너무 깁니다 (데이터의 첫 부분이 유효하다는 보장은 없습니다)</target>
        </trans-unit>
        <trans-unit id="37721cea9b7ff856cc5a0d72da55bfcef8342f2c" translate="yes" xml:space="preserve">
          <source>The input elements. If there are less elements than the specified length of the static array, the rest of it is default-initialized. If there are more than specified, the first elements up to the specified length are used.</source>
          <target state="translated">입력 요소. 정적 배열의 지정된 길이보다 적은 수의 요소가 있으면 나머지는 기본적으로 초기화됩니다. 지정된 것보다 많으면 지정된 길이까지 첫 번째 요소가 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="4b42c37fa56b476654b6a22d064c38aab28dcdfc" translate="yes" xml:space="preserve">
          <source>The input is returned.</source>
          <target state="translated">입력이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="fb78206bd59b576b51359aab6e37d1fe64780809" translate="yes" xml:space="preserve">
          <source>The input may have originated from &lt;code&gt;U[]&lt;/code&gt; or &lt;code&gt;immutable(U)[]&lt;/code&gt;, so it may be actually shared or not. Returning an unqualified affix may result in race conditions, whereas returning a &lt;code&gt;shared&lt;/code&gt; affix may result in inadvertent sharing of mutable thread-local data across multiple threads. So the returned type is conservatively &lt;code&gt;ref const&lt;/code&gt;.</source>
          <target state="translated">입력이 &lt;code&gt;U[]&lt;/code&gt; 또는 &lt;code&gt;immutable(U)[]&lt;/code&gt; 에서 시작되었을 수 있으므로 실제로 공유되거나 공유되지 않을 수 있습니다. 규정되지 않은 접두어를 반환하면 경쟁 조건이 발생할 수 있지만 &lt;code&gt;shared&lt;/code&gt; 접두어를 반환하면 여러 스레드에서 변경 가능한 스레드 로컬 데이터를 실수로 공유 할 수 있습니다. 따라서 반환 된 유형은 보수적으로 &lt;code&gt;ref const&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="ab7802e78bae021ec9f77bb19cdbefc46c138fde" translate="yes" xml:space="preserve">
          <source>The input range being passed through.</source>
          <target state="translated">통과되는 입력 범위.</target>
        </trans-unit>
        <trans-unit id="c0225247a221452c012002a0bc4a76423e77fd6b" translate="yes" xml:space="preserve">
          <source>The input range must not be empty.</source>
          <target state="translated">입력 범위는 비워 둘 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="786f6ba29b51fa6818ec422c83e424f885e18b3d" translate="yes" xml:space="preserve">
          <source>The input range set up to parse one line at a time into a record tuple.</source>
          <target state="translated">입력 범위는 한 번에 한 줄씩 레코드 튜플로 구문 분석하도록 설정되었습니다.</target>
        </trans-unit>
        <trans-unit id="4c83aa414329fad18718e6fa488a3b442df22d1b" translate="yes" xml:space="preserve">
          <source>The input range to check.</source>
          <target state="translated">확인할 입력 범위.</target>
        </trans-unit>
        <trans-unit id="4dd476cc824391e088069cbddbb750e2eef61f40" translate="yes" xml:space="preserve">
          <source>The input text string s is formed into a paragraph by breaking it up into a sequence of lines, delineated by \n, such that the number of columns is not exceeded on each line. The last line is terminated with a \n.</source>
          <target state="translated">입력 텍스트 문자열 s는 각 행에서 열 수가 초과되지 않도록 \ n으로 구분 된 일련의 행으로 구분하여 단락으로 구성됩니다. 마지막 줄은 \ n으로 끝납니다.</target>
        </trans-unit>
        <trans-unit id="93424042a1977cf3da75467c8916a2a7eddec8a8" translate="yes" xml:space="preserve">
          <source>The input to this function MUST be a valid code point.</source>
          <target state="translated">이 함수의 입력은 유효한 코드 포인트 여야합니다.</target>
        </trans-unit>
        <trans-unit id="44b890bb7f50ef5e291775cda4bfde289081100b" translate="yes" xml:space="preserve">
          <source>The input to this function MUST be a valid code point. This is enforced by the function's in-contract.</source>
          <target state="translated">이 함수의 입력은 유효한 코드 포인트 여야합니다. 이는 계약의 계약에 의해 시행됩니다.</target>
        </trans-unit>
        <trans-unit id="c67615e6ffc16592b049d69cbff653f9fe85f2f3" translate="yes" xml:space="preserve">
          <source>The input to this function MUST be valid XML. This is enforced by DocumentParser's in contract.</source>
          <target state="translated">이 함수의 입력은 유효한 XML이어야합니다. 이것은 DocumentParser의 계약에 의해 시행됩니다.</target>
        </trans-unit>
        <trans-unit id="4bb4a25af5340195ef134855f808d1711e956a9a" translate="yes" xml:space="preserve">
          <source>The input to this function MUST be valid XML. This is enforced by the function's in contract.</source>
          <target state="translated">이 함수의 입력은 유효한 XML이어야합니다. 이것은 계약의 기능에 의해 시행됩니다.</target>
        </trans-unit>
        <trans-unit id="323b8c9102f07dbc17e6156b32bdb18e8608c8b5" translate="yes" xml:space="preserve">
          <source>The input to this function MUST be validly encoded.</source>
          <target state="translated">이 함수의 입력은 반드시 올바르게 인코딩되어야합니다.</target>
        </trans-unit>
        <trans-unit id="d4a76f46d20716b9c53fd13981afb49f20693850" translate="yes" xml:space="preserve">
          <source>The input to this function MUST be validly encoded. This is enforced by the function's in-contract.</source>
          <target state="translated">이 함수의 입력은 반드시 올바르게 인코딩되어야합니다. 이는 계약의 계약에 의해 시행됩니다.</target>
        </trans-unit>
        <trans-unit id="52bc0973d7be9145a7f9c10120f8ee1522aa2643" translate="yes" xml:space="preserve">
          <source>The instantiated template.</source>
          <target state="translated">인스턴스화 된 템플릿.</target>
        </trans-unit>
        <trans-unit id="caa69ad6f2cd188077c7e982e4e11f26b6cdf5a4" translate="yes" xml:space="preserve">
          <source>The integral and floating type sizes should be considered as minimums. Algorithms should be designed to continue to work properly if the type size increases.</source>
          <target state="translated">정수 및 부동 유형 크기는 최소값으로 고려해야합니다. 알고리즘은 유형 크기가 커지면 계속 제대로 작동하도록 설계되어야합니다.</target>
        </trans-unit>
        <trans-unit id="bfaa650f603081ed06b593e3b4e5c458c3260e28" translate="yes" xml:space="preserve">
          <source>The integral is</source>
          <target state="translated">적분은</target>
        </trans-unit>
        <trans-unit id="d07416a83435e11558037f6cda4d47f4d33fe73e" translate="yes" xml:space="preserve">
          <source>The integral is evaluated by a continued fraction expansion or, when b * x is small, by a power series.</source>
          <target state="translated">적분은 지속적인 분수 팽창, 또는 b * x가 작을 때, 전력 계열에 의해 평가됩니다.</target>
        </trans-unit>
        <trans-unit id="4502af3e801c133bfaf7193afbee4f48610ef881" translate="yes" xml:space="preserve">
          <source>The integral type to convert the first &lt;code&gt;T.sizeof&lt;/code&gt; bytes to.</source>
          <target state="translated">첫 번째 &lt;code&gt;T.sizeof&lt;/code&gt; 바이트를 변환 할 정수 유형 입니다.</target>
        </trans-unit>
        <trans-unit id="51127e20341aada7d08b3905487eaefce7dd284a" translate="yes" xml:space="preserve">
          <source>The integral value to return the absolute value of.</source>
          <target state="translated">절대 값을 반환하는 정수 값입니다.</target>
        </trans-unit>
        <trans-unit id="54f14afee26358f556f656a70b82a5a8901a5411" translate="yes" xml:space="preserve">
          <source>The intent of this function is to provide an allocation-less way to call a C function using a D slice. The function internally allocates a buffer if needed, but frees it on exit.</source>
          <target state="translated">이 함수의 목적은 D 슬라이스를 사용하여 C 함수를 호출하는 할당없는 방법을 제공하는 것입니다. 이 함수는 필요한 경우 내부적으로 버퍼를 할당하지만 종료시 버퍼를 해제합니다.</target>
        </trans-unit>
        <trans-unit id="aa32bace5214cedb20ff140ded35da64a7980bf0" translate="yes" xml:space="preserve">
          <source>The intention is that &lt;code&gt;opDollar!i&lt;/code&gt; should return the length of the array along its &lt;code&gt;i&lt;/code&gt;'th dimension, or a user-defined object representing the end of the array along that dimension, that is understood by &lt;code&gt;opSlice&lt;/code&gt; and &lt;code&gt;opIndex&lt;/code&gt;.</source>
          <target state="translated">의도이다 &lt;code&gt;opDollar!i&lt;/code&gt; 그 따라 배열 길이 돌려 &lt;code&gt;i&lt;/code&gt; '번째 차원 또는 이해되는 사이즈에 따라 배열의 끝을 나타내는 사용자 정의 물체 &lt;code&gt;opSlice&lt;/code&gt; 및 &lt;code&gt;opIndex&lt;/code&gt; 를 .</target>
        </trans-unit>
        <trans-unit id="7ed569bfceb9bac4ccf7954c87c2cc7395c8f770" translate="yes" xml:space="preserve">
          <source>The intention is that &lt;code&gt;opSlice!i&lt;/code&gt; should return a user-defined object that represents an interval of indices along the &lt;code&gt;i&lt;/code&gt;'th dimension of the array. This object is then passed to &lt;code&gt;opIndex&lt;/code&gt; to perform the actual slicing operation. If only one-dimensional slicing is desired, &lt;code&gt;opSlice&lt;/code&gt; may be declared without the compile-time parameter &lt;code&gt;i&lt;/code&gt;.</source>
          <target state="translated">의도이다 &lt;code&gt;opSlice!i&lt;/code&gt; 따라 인덱스의 간격 나타내는 사용자 정의 물체 돌려 &lt;code&gt;i&lt;/code&gt; '어레이의 일 차원을. 그런 다음이 객체를 &lt;code&gt;opIndex&lt;/code&gt; 로 전달 하여 실제 슬라이싱 작업을 수행합니다. 1 차원 슬라이싱 만 필요한 경우 컴파일 타임 매개 변수 &lt;code&gt;i&lt;/code&gt; 없이 &lt;code&gt;opSlice&lt;/code&gt; 를 선언 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="cf6066b8690ba4fa47007edd6d83a6b71547ae35" translate="yes" xml:space="preserve">
          <source>The interface to the virtual-table mechanism defined above (back up to a comment remarkably similar to this one) is currently considered to be experimental. The interface might change in incompatible ways. If this is a problem for you, do not use the interface at this time.</source>
          <target state="translated">위에서 정의한 가상 테이블 메커니즘에 대한 인터페이스 (이것과 상당히 유사한 주석까지)는 현재 실험적인 것으로 간주됩니다. 인터페이스가 호환되지 않는 방식으로 변경 될 수 있습니다. 이것이 문제인 경우, 지금 인터페이스를 사용하지 마십시오.</target>
        </trans-unit>
        <trans-unit id="6250bca0465ce111dcc80945b2149f4168412958" translate="yes" xml:space="preserve">
          <source>The interface to the virtual-table mechanism is currently considered to be experimental. The interface might change in incompatible ways. If this is a problem for you, do not use the interface at this time.</source>
          <target state="translated">가상 테이블 메커니즘에 대한 인터페이스는 현재 실험적인 것으로 간주됩니다. 인터페이스가 호환되지 않는 방식으로 변경 될 수 있습니다. 이것이 문제인 경우, 지금 인터페이스를 사용하지 마십시오.</target>
        </trans-unit>
        <trans-unit id="8d2e293904f5395fe014c79325ed5dca620f1643" translate="yes" xml:space="preserve">
          <source>The interface to this is found in Druntime's &lt;a href=&quot;https://github.com/dlang/druntime/blob/master/src/gc/gcinterface.d&quot;&gt;gc/gcinterface.d&lt;/a&gt;.</source>
          <target state="translated">이것에 대한 인터페이스는 Druntime의 &lt;a href=&quot;https://github.com/dlang/druntime/blob/master/src/gc/gcinterface.d&quot;&gt;gc / gcinterface.d에&lt;/a&gt; 있습니다.</target>
        </trans-unit>
        <trans-unit id="70ba1bd45dceaea5f1daa9192d952a7efda4639e" translate="yes" xml:space="preserve">
          <source>The interval that this &lt;code&gt;IntervalRange&lt;/code&gt; currently covers.</source>
          <target state="translated">이 &lt;code&gt;IntervalRange&lt;/code&gt; 가 현재 다루는 간격입니다 .</target>
        </trans-unit>
        <trans-unit id="b1b8b6efa0b6085f29ca02a503001474bd874de3" translate="yes" xml:space="preserve">
          <source>The interval that this range currently covers.</source>
          <target state="translated">이 범위가 현재 포함하는 간격입니다.</target>
        </trans-unit>
        <trans-unit id="99ed0102a151474509c2f50c80c6a8fd9abde664" translate="yes" xml:space="preserve">
          <source>The interval to check against this interval.</source>
          <target state="translated">이 간격과 비교할 간격입니다.</target>
        </trans-unit>
        <trans-unit id="e9709ec7167a6294d35ca54cb0db7b761b6bd4bb" translate="yes" xml:space="preserve">
          <source>The interval to check for against this interval.</source>
          <target state="translated">이 간격에 대해 확인할 간격입니다.</target>
        </trans-unit>
        <trans-unit id="c93a05b54bf8db01ca44894e1b6574520f0f25cd" translate="yes" xml:space="preserve">
          <source>The interval to check for inclusion in this interval.</source>
          <target state="translated">이 간격에 포함되는지 확인할 간격입니다.</target>
        </trans-unit>
        <trans-unit id="7af5c560175f78550b8fa16520f8bceb2478bd1e" translate="yes" xml:space="preserve">
          <source>The interval to check for intersection with this interval.</source>
          <target state="translated">이 간격과의 교차점을 확인할 간격입니다.</target>
        </trans-unit>
        <trans-unit id="758e2e8521e78873ca075d9d09978b3e79b23a85" translate="yes" xml:space="preserve">
          <source>The interval to check whether its adjecent to this interval.</source>
          <target state="translated">이 간격에 적합한 지 여부를 확인하는 간격입니다.</target>
        </trans-unit>
        <trans-unit id="ec8c525abec811d6fafbe3af351dcf7c933228a1" translate="yes" xml:space="preserve">
          <source>The interval to create a span together with this interval.</source>
          <target state="translated">이 간격과 함께 범위를 만드는 간격입니다.</target>
        </trans-unit>
        <trans-unit id="ffa8edd7fe1af9b169dddd595e3c77f03e44244d" translate="yes" xml:space="preserve">
          <source>The interval to intersect with this interval.</source>
          <target state="translated">이 간격과 교차 할 간격입니다.</target>
        </trans-unit>
        <trans-unit id="450cf7fb1673450b11d1c6b4254176a2488c262a" translate="yes" xml:space="preserve">
          <source>The interval to merge with this interval.</source>
          <target state="translated">이 간격과 병합 할 간격입니다.</target>
        </trans-unit>
        <trans-unit id="6dd87bff580699a73195a62f3312346bd1ffd61d" translate="yes" xml:space="preserve">
          <source>The invariant can be checked with an &lt;code&gt;assert()&lt;/code&gt; expression:</source>
          <target state="translated">불변량은 &lt;code&gt;assert()&lt;/code&gt; 표현식 으로 확인할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="3d1bc4f7a43b5f2dfbf63c4d45e4f9ad2787305a" translate="yes" xml:space="preserve">
          <source>The invariant is a contract saying that the &lt;code&gt;assert&lt;/code&gt;s must hold true. The invariant is checked when a class or struct constructor completes, and at the start of the class or struct destructor. For public or exported functions, the order of execution is:</source>
          <target state="translated">불변은 &lt;code&gt;assert&lt;/code&gt; 진실이어야 한다는 계약 입니다. 불변량은 클래스 또는 구조체 생성자가 완료되고 클래스 또는 구조체 소멸자가 시작될 때 확인됩니다. 공개 또는 내 보낸 함수의 경우 실행 순서는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="db3237f4b413cd2d050f8846cd6a9cf6b11b5b9b" translate="yes" xml:space="preserve">
          <source>The invariant is in the form of a &lt;code&gt;const&lt;/code&gt; member function. The invariant is defined to</source>
          <target state="translated">불변은 &lt;code&gt;const&lt;/code&gt; 멤버 함수 의 형태입니다 . 불변량은</target>
        </trans-unit>
        <trans-unit id="4013ec9a85db3fcab85de75b73cedbcdfe5398d3" translate="yes" xml:space="preserve">
          <source>The invariant is not checked if the class or struct is implicitly constructed using the default &lt;code&gt;.init&lt;/code&gt; value.</source>
          <target state="translated">클래스 또는 구조체가 기본 &lt;code&gt;.init&lt;/code&gt; 값을 사용하여 암시 적으로 생성 된 경우 불변은 확인되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="b006ea59664dde8c9966b0ba37f0d9de49867d7b" translate="yes" xml:space="preserve">
          <source>The invariant need not hold if the class instance is implicitly constructed using the default &lt;code&gt;.init&lt;/code&gt; value.</source>
          <target state="translated">클래스 인스턴스가 기본 &lt;code&gt;.init&lt;/code&gt; 값을 사용하여 암시 적으로 생성 된 경우 고정 변수를 유지할 필요가 없습니다 .</target>
        </trans-unit>
        <trans-unit id="90d62a6c20b7727a896f3c7231e895bd333ec112" translate="yes" xml:space="preserve">
          <source>The invariant need not hold if the struct instance is implicitly constructed using the default &lt;code&gt;.init&lt;/code&gt; value.</source>
          <target state="translated">구조체 인스턴스가 기본 &lt;code&gt;.init&lt;/code&gt; 값을 사용하여 암시 적으로 생성 된 경우 고정 변수를 유지할 필요가 없습니다 .</target>
        </trans-unit>
        <trans-unit id="ae2f7e963cff5e59d45cd356ad6b537b6f9c2bbf" translate="yes" xml:space="preserve">
          <source>The isMarked callback function.</source>
          <target state="translated">isMarked 콜백 함수</target>
        </trans-unit>
        <trans-unit id="b53b0d99e692dbe7d750a9e3a8ec485970e1fe1a" translate="yes" xml:space="preserve">
          <source>The issue remains of calling &lt;code&gt;a.deallocate(b)&lt;/code&gt; from a different thread than the one that allocated &lt;code&gt;b&lt;/code&gt;. It follows that both threads must have access to the same instance &lt;code&gt;a&lt;/code&gt; of the respective allocator type. By definition of D, this is possible only if &lt;code&gt;a&lt;/code&gt; has the &lt;code&gt;shared&lt;/code&gt; qualifier. It follows that the allocator type must implement &lt;code&gt;allocate&lt;/code&gt; and &lt;code&gt;deallocate&lt;/code&gt; as &lt;code&gt;shared&lt;/code&gt; methods. That way, the allocator commits to allowing usable &lt;code&gt;shared&lt;/code&gt; instances.</source>
          <target state="translated">호출하는 문제가 남아 &lt;code&gt;a.deallocate(b)&lt;/code&gt; 에 할당하는 것과 다른 스레드로부터 &lt;code&gt;b&lt;/code&gt; . 두 스레드 모두 각각의 할당 자 유형 의 동일한 인스턴스 &lt;code&gt;a&lt;/code&gt; 에 액세스 할 수 있어야합니다 . 에만 D의 정의에 따라이 가능 &lt;code&gt;a&lt;/code&gt; 가지고 &lt;code&gt;shared&lt;/code&gt; 규정. 할당 자 유형은 &lt;code&gt;shared&lt;/code&gt; 메소드 로 &lt;code&gt;allocate&lt;/code&gt; 및 &lt;code&gt;deallocate&lt;/code&gt; 를 구현해야합니다 . 이렇게하면 할당자는 사용 가능한 &lt;code&gt;shared&lt;/code&gt; 인스턴스 를 허용 합니다.</target>
        </trans-unit>
        <trans-unit id="f906deb3cb569875f4c530161fd80e93b9be746c" translate="yes" xml:space="preserve">
          <source>The key is the IANA time zone database name, and the value is a list of Windows time zone names which are close (usually only one, but it could be multiple).</source>
          <target state="translated">키는 IANA 표준 시간대 데이터베이스 이름이고 값은 가까운 Windows 표준 시간대 이름 목록입니다 (일반적으로 하나이지만 여러 개일 수 있음).</target>
        </trans-unit>
        <trans-unit id="0cdd5bd88b6b5b8af271fba7af0cd3f24ac411a0" translate="yes" xml:space="preserve">
          <source>The key is the Windows time zone name, and the value is a list of IANA TZ database names which are close (currently only ever one, but it allows for multiple in case it's ever necessary).</source>
          <target state="translated">키는 Windows 표준 시간대 이름이고 값은 가까운 IANA TZ 데이터베이스 이름 목록입니다 (현재는 하나만 필요하지만 필요한 경우 여러 개를 허용 함).</target>
        </trans-unit>
        <trans-unit id="07021616652b4190834cc6f5cd3d6a99828ab34d" translate="yes" xml:space="preserve">
          <source>The key.</source>
          <target state="translated">열쇠.</target>
        </trans-unit>
        <trans-unit id="a80046e2f9e469e161e9b64d7a84ab6bec7ee185" translate="yes" xml:space="preserve">
          <source>The keyword &lt;code&gt;do&lt;/code&gt; can be used to announce the function body. Although any number of pre or post contracts of any form may follow each other, &lt;code&gt;do&lt;/code&gt; is required only when the last contract before the body is a block statement. (Before the acceptance of &lt;a href=&quot;https://github.com/dlang/DIPs/blob/master/DIPs/accepted/DIP1003.md&quot;&gt;DIP1003&lt;/a&gt;, the keyword &lt;code&gt;body&lt;/code&gt; was required instead of &lt;code&gt;do&lt;/code&gt;, and may still be encountered in old code bases. In the long term, &lt;code&gt;body&lt;/code&gt; may be deprecated, but for now it's allowed both as a keyword in this context and as an identifier elsewhere, although &lt;code&gt;do&lt;/code&gt; is preferred.)</source>
          <target state="translated">키워드 &lt;code&gt;do&lt;/code&gt; 는 함수 본문을 알리는 데 사용될 수 있습니다. 어떤 형태의 사전 또는 사후 계약의 숫자가 서로를 따를 수 있지만, &lt;code&gt;do&lt;/code&gt; 신체 전에 마지막 계약이 블록 문 경우에만 필요합니다. ( &lt;a href=&quot;https://github.com/dlang/DIPs/blob/master/DIPs/accepted/DIP1003.md&quot;&gt;DIP1003을&lt;/a&gt; 수락하기 전에 키워드 &lt;code&gt;body&lt;/code&gt; 이 &lt;code&gt;do&lt;/code&gt; 대신 필요 했지만 여전히 오래된 코드 기반에서 발견 될 수 있습니다. 장기적으로 &lt;code&gt;body&lt;/code&gt; 은 더 이상 사용되지 않을 수 있지만 현재로서는이 문맥에서 키워드로 허용됩니다. 다른 식별자 있지만 &lt;code&gt;do&lt;/code&gt; 바람직하다.)</target>
        </trans-unit>
        <trans-unit id="d0cf199fa5ede60a30e00df7068d936c5578eb01" translate="yes" xml:space="preserve">
          <source>The kind of pragma it is determined by the</source>
          <target state="translated">그것은 pragma의 종류에 의해 결정됩니다</target>
        </trans-unit>
        <trans-unit id="8c29b92f234fc529a35e51b203804649a01ac419" translate="yes" xml:space="preserve">
          <source>The lambda function arguments must not have a template instantiation as an explicit argument type. Any other argument types (basic, user-defined, template) are supported.</source>
          <target state="translated">람다 함수 인수에는 명시 적 인수 유형으로 템플릿 인스턴스화가 없어야합니다. 다른 인수 유형 (기본, 사용자 정의, 템플릿)이 지원됩니다.</target>
        </trans-unit>
        <trans-unit id="bdcf91e0f4f606e17a112c301f88ad8c5b2c10fe" translate="yes" xml:space="preserve">
          <source>The lambda function body must contain a single expression (no return statement) which contains only numeric values, manifest constants, enum values, function arguments and function calls. If the expression contains local variables or return statements, the function is considered incomparable.</source>
          <target state="translated">람다 함수 본문에는 숫자 값, 매니페스트 상수, 열거 형 값, 함수 인수 및 함수 호출 만 포함하는 단일 표현식 (반환 문 없음)이 포함되어야합니다. 식에 지역 변수 나 return 문이 포함 된 경우 함수는 비교할 수없는 것으로 간주됩니다.</target>
        </trans-unit>
        <trans-unit id="95be9f6bb557ebac60c617f8309a121bd86960bc" translate="yes" xml:space="preserve">
          <source>The last day in the month that this &lt;a href=&quot;#Date&quot;&gt;&lt;code&gt;Date&lt;/code&gt;&lt;/a&gt; is in.</source>
          <target state="translated">이 &lt;a href=&quot;#Date&quot;&gt; &lt;code&gt;Date&lt;/code&gt; &lt;/a&gt; 가 있는 달의 마지막 날 입니다.</target>
        </trans-unit>
        <trans-unit id="7a278dbcde6702c093900cb5053e8bf5709be9d8" translate="yes" xml:space="preserve">
          <source>The last day in the month that this &lt;a href=&quot;#DateTime&quot;&gt;&lt;code&gt;DateTime&lt;/code&gt;&lt;/a&gt; is in.</source>
          <target state="translated">이 &lt;a href=&quot;#DateTime&quot;&gt; &lt;code&gt;DateTime&lt;/code&gt; &lt;/a&gt; 이 있는 달의 마지막 날 입니다.</target>
        </trans-unit>
        <trans-unit id="49136c9e4ea103b38fd972475d00bbb19f727989" translate="yes" xml:space="preserve">
          <source>The last day in the month that this &lt;a href=&quot;#SysTime&quot;&gt;&lt;code&gt;SysTime&lt;/code&gt;&lt;/a&gt; is in.</source>
          <target state="translated">이 &lt;a href=&quot;#SysTime&quot;&gt; &lt;code&gt;SysTime&lt;/code&gt; &lt;/a&gt; 이 있는 달의 마지막 날 입니다.</target>
        </trans-unit>
        <trans-unit id="a7a9289af76d268aef34222393a4318b6b13e368" translate="yes" xml:space="preserve">
          <source>The last element in the container</source>
          <target state="translated">컨테이너의 마지막 요소</target>
        </trans-unit>
        <trans-unit id="6a4a00d2337afbe6c2df52717b98e8e13215bd50" translate="yes" xml:space="preserve">
          <source>The last element of the array.</source>
          <target state="translated">배열의 마지막 요소</target>
        </trans-unit>
        <trans-unit id="bdc0ac79d31e7752c2d29a6d8b9bf43609b17c83" translate="yes" xml:space="preserve">
          <source>The last parameter is passed in EAX rather than being pushed on the stack if the following conditions are met:</source>
          <target state="translated">다음 조건이 충족되면 마지막 매개 변수는 스택에서 푸시되지 않고 EAX로 전달됩니다.</target>
        </trans-unit>
        <trans-unit id="746b4bdff136b3fa913bf1eeb63d7355bf56ba56" translate="yes" xml:space="preserve">
          <source>The last template parameter if it's a &lt;code&gt;TemplateTupleParameter&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;TemplateTupleParameter&lt;/code&gt; 인 경우 마지막 템플리트 매개 변수</target>
        </trans-unit>
        <trans-unit id="81aad1de98ee0f65f497fb989a25778e1871d9df" translate="yes" xml:space="preserve">
          <source>The lazy initializer value</source>
          <target state="translated">게으른 이니셜 라이저 값</target>
        </trans-unit>
        <trans-unit id="ea4b5c8a99ea43d9dec4f2b203a2486705eaedf1" translate="yes" xml:space="preserve">
          <source>The lazy variadic delegate solution is preferable to using a lazy variadic array, because each array index would evaluate every element:</source>
          <target state="translated">각 배열 인덱스는 모든 요소를 ​​평가하므로, 게으른 가변 배열을 사용하는 것보다 게으른 가변 배열 대리 솔루션이 선호됩니다.</target>
        </trans-unit>
        <trans-unit id="421c4166a84b43c53a129a72090df266fc5436fb" translate="yes" xml:space="preserve">
          <source>The least significant bit in any &lt;code&gt;size_t&lt;/code&gt; unit is the starting bit of this unit, and the most significant bit is the last bit of this unit. Therefore, passing e.g. an array of &lt;code&gt;int&lt;/code&gt;s may result in a different &lt;code&gt;BitArray&lt;/code&gt; depending on the processor's endianness.</source>
          <target state="translated">&lt;code&gt;size_t&lt;/code&gt; 단위의 최하위 비트 는이 장치의 시작 비트이며, 최상위 비트는이 장치의 마지막 비트입니다. 따라서 &lt;code&gt;int&lt;/code&gt; 배열을 전달 하면 프로세서의 엔디안에 따라 다른 &lt;code&gt;BitArray&lt;/code&gt; 가 발생할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="eeb9274b7abe5ec5313e249b7496b6be61a66b8b" translate="yes" xml:space="preserve">
          <source>The left operand of the &lt;code&gt;,&lt;/code&gt; is evaluated, then the right operand is evaluated. The type of the expression is the type of the right operand, and the result is the result of the right operand. Using the result of comma expressions isn't allowed.</source>
          <target state="translated">의 왼쪽 피연산자는 &lt;code&gt;,&lt;/code&gt; 다음 오른쪽 피연산자가 평가되고 평가된다. 표현식의 유형은 오른쪽 피연산자의 유형이며 결과는 오른쪽 피연산자의 결과입니다. 쉼표 표현식의 결과를 사용할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="f0716ee491b6b3f2e07375f7797e5c102ad33bdc" translate="yes" xml:space="preserve">
          <source>The left-hand side (or sole) argument</source>
          <target state="translated">왼쪽 (또는 단독) 인수</target>
        </trans-unit>
        <trans-unit id="4d310cf569bfdf7161ed54cffc976e1b48e7851c" translate="yes" xml:space="preserve">
          <source>The left-hand side of the comparison (&lt;code&gt;Lhs&lt;/code&gt; is the first argument to &lt;code&gt;Checked&lt;/code&gt;)</source>
          <target state="translated">비교의 왼쪽 ( &lt;code&gt;Lhs&lt;/code&gt; 는 &lt;code&gt;Checked&lt;/code&gt; 의 첫 번째 인수입니다 )</target>
        </trans-unit>
        <trans-unit id="204d5f370e11576f0fecb8929fdcdb88b117af5c" translate="yes" xml:space="preserve">
          <source>The left-hand side of the comparison (&lt;code&gt;T&lt;/code&gt; is the first argument to &lt;code&gt;Checked&lt;/code&gt;)</source>
          <target state="translated">비교의 왼쪽 ( &lt;code&gt;T&lt;/code&gt; 는 &lt;code&gt;Checked&lt;/code&gt; 의 첫 번째 인수 )</target>
        </trans-unit>
        <trans-unit id="4fefd353c917f9a3bb60b52cf3d51cddee41a3f3" translate="yes" xml:space="preserve">
          <source>The left-hand side of the comparison for equality</source>
          <target state="translated">평등 비교의 왼쪽</target>
        </trans-unit>
        <trans-unit id="2b109cf29bece1affa9b23e640454252b8ecd16d" translate="yes" xml:space="preserve">
          <source>The left-hand side of the comparison for ordering</source>
          <target state="translated">주문 비교를위한 왼쪽</target>
        </trans-unit>
        <trans-unit id="ae7fc7c90c99a250cd16f28bd7d7dbc3b81e86a8" translate="yes" xml:space="preserve">
          <source>The left-hand side of the operator</source>
          <target state="translated">운전자의 왼쪽</target>
        </trans-unit>
        <trans-unit id="b4517c6bf6d758579387be92cded7d53dd545722" translate="yes" xml:space="preserve">
          <source>The left-hand side of the operator (&lt;code&gt;Lhs&lt;/code&gt; is the first argument to &lt;code&gt;Checked&lt;/code&gt;)</source>
          <target state="translated">연산자의 왼쪽입니다 ( &lt;code&gt;Lhs&lt;/code&gt; 는 &lt;code&gt;Checked&lt;/code&gt; 의 첫 번째 인수입니다 )</target>
        </trans-unit>
        <trans-unit id="1d155e4a7561179c70fb7012ae70744e878991c7" translate="yes" xml:space="preserve">
          <source>The left-hand side operand</source>
          <target state="translated">왼쪽 피연산자</target>
        </trans-unit>
        <trans-unit id="56ecf39f32678f6ba12fdb543c053bc2a2538cfe" translate="yes" xml:space="preserve">
          <source>The left-hand side operand (&lt;code&gt;Lhs&lt;/code&gt; is the first argument to &lt;code&gt;Checked&lt;/code&gt;)</source>
          <target state="translated">왼쪽 피연산자 ( &lt;code&gt;Lhs&lt;/code&gt; 는 &lt;code&gt;Checked&lt;/code&gt; 의 첫 번째 인수입니다 )</target>
        </trans-unit>
        <trans-unit id="fdc93a0d76b637886498906e463f3074234e7249" translate="yes" xml:space="preserve">
          <source>The leftmost side of the inheritance graph of the interfaces all share their vptrs, this is the single inheritance model. Every time the inheritance graph forks (for multiple inheritance) a new vptr is created and stored in the class' instance. Every time a virtual method is overridden, a new vtbl[] must be created with the updated method pointers in it.</source>
          <target state="translated">인터페이스의 상속 그래프의 가장 왼쪽은 모두 vptr을 공유합니다. 이것이 단일 상속 모델입니다. 상속 그래프가 다중 상속을 위해 분기 될 때마다 새로운 vptr이 생성되어 클래스의 인스턴스에 저장됩니다. 가상 메서드를 재정의 할 때마다 업데이트 된 메서드 포인터를 사용하여 새로운 vtbl []을 만들어야합니다.</target>
        </trans-unit>
        <trans-unit id="f8ab85ff43a9b405f7f858dd6bd44661050bcbfb" translate="yes" xml:space="preserve">
          <source>The leftover portion of &lt;code&gt;tgt&lt;/code&gt; after all elements from &lt;code&gt;src&lt;/code&gt; have been moved.</source>
          <target state="translated">&lt;code&gt;src&lt;/code&gt; 의 모든 요소 가 이동 한 후 &lt;code&gt;tgt&lt;/code&gt; 의 남은 부분 .</target>
        </trans-unit>
        <trans-unit id="ff1f6ec0205e886692fcbf4cdbd24c49883d76fd" translate="yes" xml:space="preserve">
          <source>The leftover portions of the two ranges after one or the other of the ranges have been exhausted.</source>
          <target state="translated">하나 또는 다른 범위가 소진 된 후 두 범위의 남은 부분.</target>
        </trans-unit>
        <trans-unit id="4aa5bf288555be6562c9b8eb71a2ee00b9edbaea" translate="yes" xml:space="preserve">
          <source>The legal types of arithmetic for &lt;a href=&quot;#Date&quot;&gt;&lt;code&gt;Date&lt;/code&gt;&lt;/a&gt; using this operator are</source>
          <target state="translated">이 연산자를 사용 하는 &lt;a href=&quot;#Date&quot;&gt; &lt;code&gt;Date&lt;/code&gt; &lt;/a&gt; 의 유효한 산술 유형은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="06d117fb1568b3c185b1dd70cf5e4111bec8c49d" translate="yes" xml:space="preserve">
          <source>The legal types of arithmetic for &lt;a href=&quot;#DateTime&quot;&gt;&lt;code&gt;DateTime&lt;/code&gt;&lt;/a&gt; using this operator are</source>
          <target state="translated">이 연산자를 사용 하는 &lt;a href=&quot;#DateTime&quot;&gt; &lt;code&gt;DateTime&lt;/code&gt; &lt;/a&gt; 의 유효한 산술 유형은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="31c5da3679aa5d6d97a971e899c7a8329e3f0d92" translate="yes" xml:space="preserve">
          <source>The legal types of arithmetic for &lt;a href=&quot;#SysTime&quot;&gt;&lt;code&gt;SysTime&lt;/code&gt;&lt;/a&gt; using this operator are</source>
          <target state="translated">이 연산자를 사용 하는 &lt;a href=&quot;#SysTime&quot;&gt; &lt;code&gt;SysTime&lt;/code&gt; 에&lt;/a&gt; 대한 올바른 유형의 산술</target>
        </trans-unit>
        <trans-unit id="1d00a55c762fc066020331efbb630b4cfc23721c" translate="yes" xml:space="preserve">
          <source>The legal types of arithmetic for &lt;a href=&quot;#TimeOfDay&quot;&gt;&lt;code&gt;TimeOfDay&lt;/code&gt;&lt;/a&gt; using this operator are</source>
          <target state="translated">이 연산자를 사용 하는 &lt;a href=&quot;#TimeOfDay&quot;&gt; &lt;code&gt;TimeOfDay&lt;/code&gt; &lt;/a&gt; 에 대한 유효한 산술 유형은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="e029991ebf163a2ec03f499fc47cd21941b26f69" translate="yes" xml:space="preserve">
          <source>The legal types of arithmetic for &lt;code&gt;Duration&lt;/code&gt; using this operator are</source>
          <target state="translated">이 연산자를 사용 하는 &lt;code&gt;Duration&lt;/code&gt; 동안 유효한 산술 유형은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="2131ddc8b843bbfb7a2f56781e6183f4a90599d7" translate="yes" xml:space="preserve">
          <source>The legal types of arithmetic for &lt;code&gt;Duration&lt;/code&gt; using this operator overload are</source>
          <target state="translated">이 연산자 오버로드를 사용 하는 &lt;code&gt;Duration&lt;/code&gt; 의 유효한 산술 유형은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="5584f88d5b275ee008fabf19cf9bf9477c6ef1e2" translate="yes" xml:space="preserve">
          <source>The legal types of arithmetic for &lt;code&gt;TickDuration&lt;/code&gt; using this operator are</source>
          <target state="translated">이 연산자를 사용 하는 &lt;code&gt;TickDuration&lt;/code&gt; 의 올바른 유형의 산술은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="c5479006c238183b17f8e4535d66092bdb92a1fe" translate="yes" xml:space="preserve">
          <source>The legal types of arithmetic for &lt;code&gt;TickDuration&lt;/code&gt; using this operator overload are</source>
          <target state="translated">이 연산자 오버로드를 사용 하는 &lt;code&gt;TickDuration&lt;/code&gt; 의 올바른 유형의 산술은 다음 과 같습니다.</target>
        </trans-unit>
        <trans-unit id="0bd23cc00d282f158f381c5c9ffe519dc3f30f3b" translate="yes" xml:space="preserve">
          <source>The length dimension(s) of the resulting array</source>
          <target state="translated">결과 배열의 길이 치수</target>
        </trans-unit>
        <trans-unit id="44d89bfdd05d1a58a582eeedae0d9a14e3912d91" translate="yes" xml:space="preserve">
          <source>The length of a Base64 encoding of an array of the given length.</source>
          <target state="translated">주어진 길이의 배열에 대한 Base64 인코딩의 길이입니다.</target>
        </trans-unit>
        <trans-unit id="a5db64910ec8c3458fc1370fda6dd6afe4df6242" translate="yes" xml:space="preserve">
          <source>The length of the Base64 encoding.</source>
          <target state="translated">Base64 인코딩의 길이입니다.</target>
        </trans-unit>
        <trans-unit id="a6c0235529e0d9db5d811993877bcc8428ae8800" translate="yes" xml:space="preserve">
          <source>The length of the decoded string corresponding to a Base64 encoding of length sourceLength.</source>
          <target state="translated">길이 sourceLength의 Base64 인코딩에 해당하는 디코딩 된 문자열의 길이입니다.</target>
        </trans-unit>
        <trans-unit id="11a141a49e0a68aaa17cb7bd6222ca0a80676913" translate="yes" xml:space="preserve">
          <source>The length of the initial segment of &lt;code&gt;r&lt;/code&gt; to sort.</source>
          <target state="translated">정렬 할 &lt;code&gt;r&lt;/code&gt; 의 초기 세그먼트 길이입니다 .</target>
        </trans-unit>
        <trans-unit id="79633e883a28c37fc7cd1efc3c868307222fbc17" translate="yes" xml:space="preserve">
          <source>The length of the resulting range is the sum of all lengths of the ranges passed as input. This means that all elements (duplicates included) are transferred to the resulting range.</source>
          <target state="translated">결과 범위의 길이는 입력으로 전달 된 범위의 모든 길이의 합입니다. 이는 모든 요소 (중복 포함)가 결과 범위로 전송됨을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="e1ae840eb910889a7516866d4d199999a725e819" translate="yes" xml:space="preserve">
          <source>The length of the token is known to be 40 characters long due to its format, so the attacker first sends &lt;code&gt;&quot;0000000000000000000000000000000000000000&quot;&lt;/code&gt;, then &lt;code&gt;&quot;1000000000000000000000000000000000000000&quot;&lt;/code&gt;, and so on.</source>
          <target state="translated">토큰 길이는 형식으로 인해 길이가 40자인 것으로 알려져 있으므로 공격자는 먼저 &lt;code&gt;&quot;0000000000000000000000000000000000000000&quot;&lt;/code&gt; 을 보낸 다음 &lt;code&gt;&quot;1000000000000000000000000000000000000000&quot;&lt;/code&gt; 등 을 보냅니다 .</target>
        </trans-unit>
        <trans-unit id="1987089f20ee0b5d2ec2f8112d140a36df239f5b" translate="yes" xml:space="preserve">
          <source>The level at which a socket option is defined.</source>
          <target state="translated">소켓 옵션이 정의되는 수준.</target>
        </trans-unit>
        <trans-unit id="b86bd023c662d4e208c258be711aadc0b1b2efae" translate="yes" xml:space="preserve">
          <source>The level at which a socket option is defined:</source>
          <target state="translated">소켓 옵션이 정의되는 레벨 :</target>
        </trans-unit>
        <trans-unit id="f491d891c138db3f9bceff46473b495e216f49dc" translate="yes" xml:space="preserve">
          <source>The lexical analysis is independent of the syntax parsing and the semantic analysis. The lexical analyzer splits the source text up into tokens. The lexical grammar describes the syntax of those tokens. The grammar is designed to be suitable for high speed scanning and to make it easy to write a correct scanner for it. It has a minimum of special case rules and there is only one phase of translation.</source>
          <target state="translated">어휘 분석은 구문 분석 및 의미 분석과 무관합니다. 어휘 분석기는 소스 텍스트를 토큰으로 분할합니다. 어휘 문법은 이러한 토큰의 구문을 설명합니다. 문법은 고속 스캔에 적합하고 올바른 스캐너를 쉽게 작성할 수 있도록 설계되었습니다. 특수한 경우 최소 규칙이 있으며 번역의 한 단계 만 있습니다.</target>
        </trans-unit>
        <trans-unit id="64fc62f1647f32635083b06c594d00bb08d6c211" translate="yes" xml:space="preserve">
          <source>The lexical order of the attributes &lt;code&gt;ref&lt;/code&gt;, &lt;code&gt;return&lt;/code&gt;, and &lt;code&gt;scope&lt;/code&gt; is not significant.</source>
          <target state="translated">&lt;code&gt;ref&lt;/code&gt; , &lt;code&gt;return&lt;/code&gt; 및 &lt;code&gt;scope&lt;/code&gt; 속성의 어휘 순서는 중요하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="f68c7b698966b101a1a595982c2044cc2a404192" translate="yes" xml:space="preserve">
          <source>The line number information from where the call originates</source>
          <target state="translated">통화가 시작된 회선 번호 정보</target>
        </trans-unit>
        <trans-unit id="630ea807f4230ab332463ca98ac961bf9f44e6d5" translate="yes" xml:space="preserve">
          <source>The line number of the D source code corresponding with where the error was thrown from.</source>
          <target state="translated">오류가 발생한 위치에 해당하는 D 소스 코드의 행 번호입니다.</target>
        </trans-unit>
        <trans-unit id="229e0a2bdd93317a19e4a68e09629b3b6f154aca" translate="yes" xml:space="preserve">
          <source>The line number of the caller.</source>
          <target state="translated">발신자의 회선 번호입니다.</target>
        </trans-unit>
        <trans-unit id="0ad55de99f59d99a8ffdf4bac1fdfeed484559cb" translate="yes" xml:space="preserve">
          <source>The line number on which this error occurred.</source>
          <target state="translated">이 오류가 발생한 줄 번호입니다.</target>
        </trans-unit>
        <trans-unit id="b99341808eb5c2aeef537e3bc3ba23e7d2391ae4" translate="yes" xml:space="preserve">
          <source>The line number that the &lt;a href=&quot;#DateTimeException&quot;&gt;&lt;code&gt;DateTimeException&lt;/code&gt;&lt;/a&gt; will list if thrown.</source>
          <target state="translated">발생 된 경우 &lt;a href=&quot;#DateTimeException&quot;&gt; &lt;code&gt;DateTimeException&lt;/code&gt; &lt;/a&gt; 이 나열 할 행 번호입니다 .</target>
        </trans-unit>
        <trans-unit id="f269870f6d1360520fe00512e2c2e3c4c0c50b6e" translate="yes" xml:space="preserve">
          <source>The line number where the exception occurred.</source>
          <target state="translated">예외가 발생한 줄 번호입니다.</target>
        </trans-unit>
        <trans-unit id="f737b0208cdb15cf160156fb11b96cdbc64efed4" translate="yes" xml:space="preserve">
          <source>The line terminator (&lt;code&gt;'\n'&lt;/code&gt; by default) is part of the string read (it could be missing in the last line of the file). Several types are supported for &lt;code&gt;line&lt;/code&gt;, and the behavior of &lt;code&gt;lines&lt;/code&gt; changes accordingly:</source>
          <target state="translated">줄 종결 자 ( 기본적으로 &lt;code&gt;'\n'&lt;/code&gt; )는 읽은 문자열의 일부입니다 (파일의 마지막 줄에서 누락 될 수 있음). &lt;code&gt;line&lt;/code&gt; 에 여러 유형이 지원되며 그에 따라 &lt;code&gt;lines&lt;/code&gt; 의 동작이 변경됩니다.</target>
        </trans-unit>
        <trans-unit id="4223574eefbbf292923ac805daa2d742c2ceff1c" translate="yes" xml:space="preserve">
          <source>The line that was read, including the line terminator character.</source>
          <target state="translated">줄 종결 자 문자를 포함하여 읽은 줄.</target>
        </trans-unit>
        <trans-unit id="0c791857d998bbf0bb74dbde8821e8c09defc3d6" translate="yes" xml:space="preserve">
          <source>The line where the error occurred.</source>
          <target state="translated">오류가 발생한 줄입니다.</target>
        </trans-unit>
        <trans-unit id="5ba806293f71618709ac5ca5570d100d47098201" translate="yes" xml:space="preserve">
          <source>The line where the error occurred. Defaults to &lt;code&gt;__LINE__&lt;/code&gt;.</source>
          <target state="translated">오류가 발생한 줄입니다. 기본값은 &lt;code&gt;__LINE__&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="c9ec5dcfd170a3e54aa2b0486e8b3a659ecba856" translate="yes" xml:space="preserve">
          <source>The linkage form &lt;code&gt;extern (C++, &lt;/code&gt;</source>
          <target state="translated">연결 형식 &lt;code&gt;extern (C++, &lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="1a68509fefd64796f7d1a07f49a259470873e621" translate="yes" xml:space="preserve">
          <source>The linkage is recognized on all platforms but will issue a compile error if it is used on a platform where Objective-C support is not available. This allows to easily hide Objective-C declarations from platforms where it is not available using the &lt;a href=&quot;version#version&quot;&gt;&lt;code&gt;version&lt;/code&gt;&lt;/a&gt; statement, without resorting to string mixins or other workarounds.</source>
          <target state="translated">연결은 모든 플랫폼에서 인식되지만 Objective-C 지원을 사용할 수없는 플랫폼에서 사용되는 경우 컴파일 오류가 발생합니다. 따라서 문자열 믹스 인 또는 다른 해결 방법을 사용하지 않고 &lt;a href=&quot;version#version&quot;&gt; &lt;code&gt;version&lt;/code&gt; &lt;/a&gt; 문을 사용하여 사용할 수없는 플랫폼에서 Objective-C 선언을 쉽게 숨길 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="ee2dc34efb622f40653a49dbfe76ceb8d1ee0eff" translate="yes" xml:space="preserve">
          <source>The list of allowed types. If empty, any type is allowed.</source>
          <target state="translated">허용되는 유형의 목록입니다. 비어 있으면 모든 유형이 허용됩니다.</target>
        </trans-unit>
        <trans-unit id="7d752b3e0c165ac9972ad67362f39567c19601ad" translate="yes" xml:space="preserve">
          <source>The literal may not exceed the range of the type. The literal is rounded to fit into the significant digits of the type.</source>
          <target state="translated">리터럴은 유형의 범위를 초과 할 수 없습니다. 리터럴은 유형의 유효 숫자에 맞게 반올림됩니다.</target>
        </trans-unit>
        <trans-unit id="cfda6f32ee8182b11470321e18429ff54847d85e" translate="yes" xml:space="preserve">
          <source>The local part is in a deprecated form</source>
          <target state="translated">로컬 부분은 더 이상 사용되지 않는 형식입니다.</target>
        </trans-unit>
        <trans-unit id="6f51eadb663d2759618c2c7f55ed73ce81e81662" translate="yes" xml:space="preserve">
          <source>The local part of the address is too long</source>
          <target state="translated">주소의 로컬 부분이 너무 깁니다</target>
        </trans-unit>
        <trans-unit id="d43703ab62f0fdfb0730decc44b9accfe993fc48" translate="yes" xml:space="preserve">
          <source>The local part of the email address, that is, the part before the @ sign.</source>
          <target state="translated">이메일 주소의 로컬 부분, 즉 @ 기호 앞 부분입니다.</target>
        </trans-unit>
        <trans-unit id="fb2b16bfeb403dd9d23822ef47a96282d2506733" translate="yes" xml:space="preserve">
          <source>The logger used by the logging function as reference.</source>
          <target state="translated">로깅 기능이 참조로 사용하는 로거.</target>
        </trans-unit>
        <trans-unit id="9dc35ce16bcd5e0f3997b30f4a3a933ead8e2be7" translate="yes" xml:space="preserve">
          <source>The long</source>
          <target state="translated">긴</target>
        </trans-unit>
        <trans-unit id="cdce859b555eda9a366f161871fcdb633ee5b0eb" translate="yes" xml:space="preserve">
          <source>The long symbol for this option</source>
          <target state="translated">이 옵션의 긴 기호</target>
        </trans-unit>
        <trans-unit id="eb826857f96e2fa8c72d4f984e7520701feb3d3d" translate="yes" xml:space="preserve">
          <source>The loop is correctly written:</source>
          <target state="translated">루프가 올바르게 작성되었습니다.</target>
        </trans-unit>
        <trans-unit id="80cd3f025f71ab9fb6d037c50456d7fb59577d15" translate="yes" xml:space="preserve">
          <source>The lower bound of the clamp.</source>
          <target state="translated">클램프의 하한.</target>
        </trans-unit>
        <trans-unit id="c3ba355fcfd258cdc3b0962e2c92c7fd02aec3ad" translate="yes" xml:space="preserve">
          <source>The macro &quot;##&quot; is ISO C, we assume pre-ISO C doesn't support it.</source>
          <target state="translated">매크로 &quot;##&quot;는 ISO C입니다. ISO C 이전은 지원하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="4493cedee574dfabffbc81a40e14a5b6a3a6b77b" translate="yes" xml:space="preserve">
          <source>The macros section follows the same syntax as the &lt;b&gt;Params:&lt;/b&gt; section. It's a series of</source>
          <target state="translated">매크로 섹션은 &lt;b&gt;Params :&lt;/b&gt; 섹션 과 동일한 구문을 따릅니다 . 일련의</target>
        </trans-unit>
        <trans-unit id="7ae8a3b1299a2612db122fcc08bc88452fa0e22f" translate="yes" xml:space="preserve">
          <source>The magnitude of x is limited to about 106.56 for IEEE 80-bit arithmetic; 1 or -1 is returned outside this range.</source>
          <target state="translated">x의 크기는 IEEE 80 비트 산술의 경우 약 106.56으로 제한됩니다. 이 범위를 벗어나면 1 또는 -1이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="327523b3c0bae538d6dd857c0b63c542d4c2e3ff" translate="yes" xml:space="preserve">
          <source>The main &lt;a href=&quot;std_range&quot;&gt;&lt;code&gt;std.range&lt;/code&gt;&lt;/a&gt; module provides template-based tools for working with ranges, but sometimes an object-based interface for ranges is needed, such as when runtime polymorphism is required. For this purpose, this submodule provides a number of object and &lt;code&gt;interface&lt;/code&gt; definitions that can be used to wrap around range objects created by the &lt;a href=&quot;std_range&quot;&gt;&lt;code&gt;std.range&lt;/code&gt;&lt;/a&gt; templates.</source>
          <target state="translated">기본 &lt;a href=&quot;std_range&quot;&gt; &lt;code&gt;std.range&lt;/code&gt; &lt;/a&gt; 모듈은 범위 작업을위한 템플릿 기반 도구를 제공하지만 때로는 런타임 다형성이 필요한 경우와 같이 범위에 대한 객체 기반 인터페이스가 필요합니다. 이를 위해이 서브 모듈은 &lt;a href=&quot;std_range&quot;&gt; &lt;code&gt;std.range&lt;/code&gt; &lt;/a&gt; 템플리트로 작성된 범위 오브젝트를 랩핑하는 데 사용할 수 있는 많은 오브젝트 및 &lt;code&gt;interface&lt;/code&gt; 정의를 제공합니다 .</target>
        </trans-unit>
        <trans-unit id="3c02f05cd38724c7e8cb17756e9c5152cd9c1060" translate="yes" xml:space="preserve">
          <source>The main entry point for garbage collection. The supplied delegate will be passed ranges representing both stack and register values.</source>
          <target state="translated">가비지 수집의 주요 진입 점입니다. 제공된 델리게이트에는 스택 및 레지스터 값을 모두 나타내는 범위가 전달됩니다.</target>
        </trans-unit>
        <trans-unit id="70a5f20578712db84e71fcdbe8fd245260ba0674" translate="yes" xml:space="preserve">
          <source>The main reasons that a program might need to use ticks directly is if the system clock has higher precision than hnsecs, and the program needs that higher precision, or if the program needs to avoid the rounding errors caused by converting to hnsecs.</source>
          <target state="translated">프로그램에서 틱을 직접 사용해야하는 주된 이유는 시스템 클럭의 정밀도가 hnsecs보다 높고 프로그램의 정밀도가 높거나 프로그램이 hnsecs로 변환하여 발생하는 반올림 오류를 피해야하는 경우입니다.</target>
        </trans-unit>
        <trans-unit id="99346c9361ee044918b5692d75d84b05203809b4" translate="yes" xml:space="preserve">
          <source>The main uses cases for &lt;code&gt;WorkerLocalStorageStorage&lt;/code&gt; are:</source>
          <target state="translated">&lt;code&gt;WorkerLocalStorageStorage&lt;/code&gt; 의 주요 사용 사례는 다음 과 같습니다.</target>
        </trans-unit>
        <trans-unit id="37721286eae1f656c81db469ea0c2aa0407bd201" translate="yes" xml:space="preserve">
          <source>The major 32-bit x86 microarchitecture 'dynasties' have been:</source>
          <target state="translated">주요 32 비트 x86 마이크로 아키텍처 'dynaties'는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="982a1e7c4fc73fa370e90c954afb1f355930cd55" translate="yes" xml:space="preserve">
          <source>The managed array.</source>
          <target state="translated">관리 형 배열.</target>
        </trans-unit>
        <trans-unit id="24b3c10fb402cc3696f43a7e032402872866e5ae" translate="yes" xml:space="preserve">
          <source>The mangled name for a function with function pointer type T and the given fully qualified name.</source>
          <target state="translated">함수 포인터 유형이 T이고 주어진 정규화 된 이름을 가진 함수의 맹 글링 된 이름입니다.</target>
        </trans-unit>
        <trans-unit id="2222f24e9ff7ad414fdd6df5db1a3a27354c9552" translate="yes" xml:space="preserve">
          <source>The mangled name for a symbols of type T and the given fully qualified name.</source>
          <target state="translated">T 유형의 기호에 대한 맹 글링 된 이름과 지정된 정규화 된 이름.</target>
        </trans-unit>
        <trans-unit id="582a49c9af38036e1960cd170f7932701e0fb6f3" translate="yes" xml:space="preserve">
          <source>The mangled name with deduplicated identifiers</source>
          <target state="translated">중복 제거 된 식별자가있는 맹 글링 된 이름</target>
        </trans-unit>
        <trans-unit id="08774dd4c4d75e3bd42a748ee71506481a4f0a1b" translate="yes" xml:space="preserve">
          <source>The mangled string representing the type</source>
          <target state="translated">유형을 나타내는 맹 글링 된 문자열</target>
        </trans-unit>
        <trans-unit id="aa7ae029a5326a80d32c23d17dde2c45ccbc8321" translate="yes" xml:space="preserve">
          <source>The mapping of package and module identifiers to directory and file names.</source>
          <target state="translated">패키지 및 모듈 식별자를 디렉토리 및 파일 이름에 매핑</target>
        </trans-unit>
        <trans-unit id="43effc8161287353136863e8d2f53a67a4ef703b" translate="yes" xml:space="preserve">
          <source>The max aliases are the largest integral types:</source>
          <target state="translated">최대 별칭은 가장 큰 정수 유형입니다.</target>
        </trans-unit>
        <trans-unit id="986ee926972449f806f769e32d7dd4ba24b84874" translate="yes" xml:space="preserve">
          <source>The maximal element of the passed-in range.</source>
          <target state="translated">전달 된 범위의 최대 요소입니다.</target>
        </trans-unit>
        <trans-unit id="ae723b7ad52bbfa1e17cf08fd49aa1b7abbdc458" translate="yes" xml:space="preserve">
          <source>The maximum allowed nesting level.</source>
          <target state="translated">허용되는 최대 중첩 수준입니다.</target>
        </trans-unit>
        <trans-unit id="c15b5870b72ff9ade8671f564f3ad47e5d8703b2" translate="yes" xml:space="preserve">
          <source>The maximum guarantee of &lt;code&gt;pure&lt;/code&gt; is called &quot;strong purity&quot;. It can enable optimizations based on the fact that a function is guaranteed to not mutate anything which isn't passed to it. For cases where the compiler can guarantee that a pure function cannot alter its arguments, it can enable full, functional purity (i.e. the guarantee that the function will always return the same result for the same arguments). To that end, a pure function:</source>
          <target state="translated">&lt;code&gt;pure&lt;/code&gt; 의 최대 보증을 &quot;강한 순도&quot;라고합니다. 함수가 전달되지 않은 것을 변경하지 않도록 보장한다는 사실을 기반으로 최적화를 활성화 할 수 있습니다. 컴파일러가 순수 함수가 인수를 변경할 수 없음을 보장 할 수있는 경우 완전한 기능 순도를 사용할 수 있습니다 (즉, 함수가 항상 동일한 인수에 대해 동일한 결과를 리턴하도록 보장 할 수 있음). 이를 위해 순수한 기능 :</target>
        </trans-unit>
        <trans-unit id="c855c6313f529356306d651f3e145813bb160323" translate="yes" xml:space="preserve">
          <source>The maximum length of &lt;code&gt;filename&lt;/code&gt; is given by the constant &lt;code&gt;core.stdc.stdio.FILENAME_MAX&lt;/code&gt;. (On Windows, this number is defined as the maximum number of UTF-16 code points, and the test will therefore only yield strictly correct results when &lt;code&gt;filename&lt;/code&gt; is a string of &lt;code&gt;wchar&lt;/code&gt;s.)</source>
          <target state="translated">&lt;code&gt;filename&lt;/code&gt; 의 최대 길이 는 상수 &lt;code&gt;core.stdc.stdio.FILENAME_MAX&lt;/code&gt; 에 의해 제공됩니다 . (Windows에서이 숫자는 최대 UTF-16 코드 포인트 수로 정의되므로 &lt;code&gt;filename&lt;/code&gt; 이 &lt;code&gt;wchar&lt;/code&gt; 문자열 인 경우 테스트에서 정확한 결과 만 제공 합니다.)</target>
        </trans-unit>
        <trans-unit id="05e735a756b3fa2f43497424f8b3020883222ceb" translate="yes" xml:space="preserve">
          <source>The maximum number of bytes of output that should be captured.</source>
          <target state="translated">캡처해야하는 최대 출력 바이트 수입니다.</target>
        </trans-unit>
        <trans-unit id="f3e3e4f751fc559f30cd92f8522a3febd435ec99" translate="yes" xml:space="preserve">
          <source>The maximum number of elements the array can store without reallocating memory and invalidating iterators upon insertion.</source>
          <target state="translated">삽입시 메모리를 재 할당하고 반복자를 무효화하지 않고 어레이가 저장할 수있는 최대 요소 수입니다.</target>
        </trans-unit>
        <trans-unit id="ff490f34a5e2c376eac774681e1598898ac5391d" translate="yes" xml:space="preserve">
          <source>The maximum number of messages or zero if no limit.</source>
          <target state="translated">최대 메시지 수 또는 제한이 없으면 0입니다.</target>
        </trans-unit>
        <trans-unit id="23ffb3d6838b02986026c5eeb543b889e4e64af2" translate="yes" xml:space="preserve">
          <source>The maximum of the passed-in args. The type of the returned value is the type among the passed arguments that is able to store the largest value.</source>
          <target state="translated">전달 된 인수의 최대 값입니다. 리턴 된 값의 유형은 가장 큰 값을 저장할 수있는 전달 된 인수 중 유형입니다.</target>
        </trans-unit>
        <trans-unit id="7eb2470a27937a3494cee9a54b8062f651c54299" translate="yes" xml:space="preserve">
          <source>The maximum scheduling priority that may be set for a thread. On systems where multiple scheduling policies are defined, this value represents the maximum valid priority for the scheduling policy of the process.</source>
          <target state="translated">스레드에 대해 설정 될 수있는 최대 스케줄링 우선 순위. 다중 스케줄링 정책이 정의 된 시스템에서이 값은 프로세스의 스케줄링 정책에 대한 최대 유효 우선 순위를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="f397747108afabbaad398b1bbfbbdd699e4c5ce8" translate="yes" xml:space="preserve">
          <source>The maximum size of the GC buffer to hold the return values</source>
          <target state="translated">리턴 값을 보유 할 GC 버퍼의 최대 크기</target>
        </trans-unit>
        <trans-unit id="075c481912178c8ac79090ee5b3669c3def2fbb2" translate="yes" xml:space="preserve">
          <source>The maximum value representable is &lt;code&gt;T.max&lt;/code&gt; for signed integrals, &lt;code&gt; T.max - 1&lt;/code&gt; for unsigned integrals. The minimum value representable is &lt;code&gt; T.min + 1&lt;/code&gt; for signed integrals, &lt;code&gt;0&lt;/code&gt; for unsigned integrals.</source>
          <target state="translated">최대 값 표현할 수는 &lt;code&gt;T.max&lt;/code&gt; , 서명 적분에 대한 &lt;code&gt; T.max - 1&lt;/code&gt; 부호 적분합니다. 표현 가능한 최소값 은 부호있는 적분의 경우 &lt;code&gt; T.min + 1&lt;/code&gt; , 부호없는 적분의 경우 &lt;code&gt;0&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="4957d9a3700ae6f7d93e51da85b7d5a4964d27b2" translate="yes" xml:space="preserve">
          <source>The mean of &lt;code&gt;r&lt;/code&gt; when &lt;code&gt;r&lt;/code&gt; is non-empty.</source>
          <target state="translated">의 평균 &lt;code&gt;r&lt;/code&gt; &lt;code&gt;r&lt;/code&gt; 은 비 비어 있습니다.</target>
        </trans-unit>
        <trans-unit id="c587177906e3358831db8b1c6944ffdb24226077" translate="yes" xml:space="preserve">
          <source>The members are completely hidden to the user, and so the only operations on those types are ones that do not require any knowledge of the contents of those types. For example:</source>
          <target state="translated">멤버는 사용자에게 완전히 숨겨져 있으므로 해당 유형에 대한 유일한 조작은 해당 유형의 컨텐츠에 대한 지식이 필요하지 않은 조작입니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="00dd946dd7ec09c0536b1658fc7e8ead520e7c8e" translate="yes" xml:space="preserve">
          <source>The memory is obtained from &lt;code&gt;SmallAllocator&lt;/code&gt; if &lt;code&gt;s &amp;lt;= threshold&lt;/code&gt;, or &lt;code&gt;LargeAllocator&lt;/code&gt; otherwise.</source>
          <target state="translated">메모리은 얻을 &lt;code&gt;SmallAllocator&lt;/code&gt; 만약 &lt;code&gt;s &amp;lt;= threshold&lt;/code&gt; 또는 &lt;code&gt;LargeAllocator&lt;/code&gt; 그렇지.</target>
        </trans-unit>
        <trans-unit id="f8c96911fea13cb1c02d9f105c0c295fa2deb239" translate="yes" xml:space="preserve">
          <source>The memory location of different memory blocks is not defined. Ordered comparison (&lt;code&gt;&amp;lt;&lt;/code&gt;, &lt;code&gt;&amp;lt;&lt;/code&gt;&lt;code&gt;=&lt;/code&gt;, &lt;code&gt;&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;gt;=&lt;/code&gt;) between two pointers is permitted when both pointers point to the same array, or when at least one pointer is &lt;code&gt;null&lt;/code&gt;.</source>
          <target state="translated">다른 메모리 블록의 메모리 위치는 정의되어 있지 않습니다. 두 포인터가 같은 배열을 가리 키거나 하나 이상의 포인터가 &lt;code&gt;null&lt;/code&gt; 인 경우 두 포인터 간의 순서 비교 ( &lt;code&gt;&amp;lt;&lt;/code&gt; , &lt;code&gt;&amp;lt;&lt;/code&gt; &lt;code&gt;=&lt;/code&gt; , &lt;code&gt;&amp;gt;&lt;/code&gt; , &lt;code&gt;&amp;gt;=&lt;/code&gt; )가 허용됩니다 .</target>
        </trans-unit>
        <trans-unit id="fe0b84897743c23c53a5e9577a10299a7a7b020c" translate="yes" xml:space="preserve">
          <source>The memory usage of this implementation is guaranteed to be constant in &lt;code&gt;range.length&lt;/code&gt;.</source>
          <target state="translated">이 구현의 메모리 사용량은 &lt;code&gt;range.length&lt;/code&gt; 에서 일정하게 보장됩니다 .</target>
        </trans-unit>
        <trans-unit id="7609ac8f3cf653b1ce0270fa8139880a547a9eea" translate="yes" xml:space="preserve">
          <source>The message for the exception.</source>
          <target state="translated">예외 메시지입니다.</target>
        </trans-unit>
        <trans-unit id="4c338cd37584d6e6e69bd4c24d1ae2acb50b8634" translate="yes" xml:space="preserve">
          <source>The message that was sent.</source>
          <target state="translated">보낸 메시지입니다.</target>
        </trans-unit>
        <trans-unit id="68d612f02557a1940b9b2866c12015c2578745a2" translate="yes" xml:space="preserve">
          <source>The message to include in the &lt;code&gt;AssertError&lt;/code&gt; if the assumption turns out to be false.</source>
          <target state="translated">가정이 거짓으로 판명 된 경우 &lt;code&gt;AssertError&lt;/code&gt; 에 포함 할 메시지 입니다.</target>
        </trans-unit>
        <trans-unit id="488aa84d557c1a01800a687e8f424ca1dc36fdd6" translate="yes" xml:space="preserve">
          <source>The message to include in the &lt;code&gt;ErrnoException&lt;/code&gt; if it is thrown.</source>
          <target state="translated">던져 질 경우 &lt;code&gt;ErrnoException&lt;/code&gt; 에 포함 할 메시지 .</target>
        </trans-unit>
        <trans-unit id="79b8f8765c27119a953cd29d5a9f80179e617637" translate="yes" xml:space="preserve">
          <source>The metaclass of this class.</source>
          <target state="translated">이 클래스의 메타 클래스</target>
        </trans-unit>
        <trans-unit id="93cc36b0067843c6450f0911a4ca8b3ad0ea0493" translate="yes" xml:space="preserve">
          <source>The method used to enable or disable the unit tests. Use of a compiler switch such as &lt;a href=&quot;https://dlang.org/dmd.html#switch-unittest&quot;&gt;&lt;b&gt;-unittest&lt;/b&gt;&lt;/a&gt; to enable them is suggested.</source>
          <target state="translated">단위 테스트를 활성화 또는 비활성화하는 데 사용되는 방법입니다. &lt;a href=&quot;https://dlang.org/dmd.html#switch-unittest&quot;&gt;&lt;b&gt;-unittest&lt;/b&gt;&lt;/a&gt; 와 같은 컴파일러 스위치 를 사용하여 활성화하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="c6a75cd2237917d2ed85214e205b4f1cf25efd9f" translate="yes" xml:space="preserve">
          <source>The minimal element of the passed-in range.</source>
          <target state="translated">전달 된 범위의 최소 요소입니다.</target>
        </trans-unit>
        <trans-unit id="ab6714e3fe053113da2960956c8eb82b3e5bbc67" translate="yes" xml:space="preserve">
          <source>The minimal number of edits to transform s into t.  Does not allocate GC memory.</source>
          <target state="translated">s를 t로 변환하는 최소 편집 횟수입니다. GC 메모리를 할당하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="10a4be4f3adcabd3abe79325f2076e9b9a100888" translate="yes" xml:space="preserve">
          <source>The minimum duration the calling thread should be suspended.</source>
          <target state="translated">호출 스레드가 일시 중단되어야하는 최소 기간입니다.</target>
        </trans-unit>
        <trans-unit id="28711c27ca983081eb31b72306fa4a118f39be3b" translate="yes" xml:space="preserve">
          <source>The minimum extension size in bytes.</source>
          <target state="translated">바이트 단위의 최소 확장 크기입니다.</target>
        </trans-unit>
        <trans-unit id="c06ab7e4e215252c3c928d52e3071658c4a68764" translate="yes" xml:space="preserve">
          <source>The minimum of the passed-in values.</source>
          <target state="translated">전달 된 값의 최소값입니다.</target>
        </trans-unit>
        <trans-unit id="95346b92b5307b71b43fcd27332d111b5c7b81cb" translate="yes" xml:space="preserve">
          <source>The minimum scheduling priority that may be set for a thread. On systems where multiple scheduling policies are defined, this value represents the minimum valid priority for the scheduling policy of the process.</source>
          <target state="translated">스레드에 대해 설정 될 수있는 최소 스케줄링 우선 순위. 다중 스케줄링 정책이 정의 된 시스템에서이 값은 프로세스의 스케줄링 정책에 대한 최소 유효 우선 순위를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="91d9db5c5ad3a0f6b05ff83250575799825e9e6d" translate="yes" xml:space="preserve">
          <source>The minimum, respectively maximum element of a range together with the number it occurs in the range.</source>
          <target state="translated">범위에서 발생하는 숫자와 함께 범위의 최소, 최대 요소.</target>
        </trans-unit>
        <trans-unit id="4776ba2a4d44664c280371c94d75db0a68aa7f47" translate="yes" xml:space="preserve">
          <source>The minute portion of the time;</source>
          <target state="translated">시간의 분;</target>
        </trans-unit>
        <trans-unit id="804dde72e3fca52bb6fee9e6c9a891f7a218393e" translate="yes" xml:space="preserve">
          <source>The minute to set this &lt;a href=&quot;#DateTime&quot;&gt;&lt;code&gt;DateTime&lt;/code&gt;&lt;/a&gt;'s minute to.</source>
          <target state="translated">이 &lt;a href=&quot;#DateTime&quot;&gt; &lt;code&gt;DateTime&lt;/code&gt; &lt;/a&gt; 분을 설정하는 분 입니다.</target>
        </trans-unit>
        <trans-unit id="fd8186f6e2f846fa308524ef0f64113f0d7289dd" translate="yes" xml:space="preserve">
          <source>The minute to set this &lt;a href=&quot;#SysTime&quot;&gt;&lt;code&gt;SysTime&lt;/code&gt;&lt;/a&gt;'s minute to.</source>
          <target state="translated">이 &lt;a href=&quot;#SysTime&quot;&gt; &lt;code&gt;SysTime&lt;/code&gt; &lt;/a&gt; 분을 설정하는 분 입니다.</target>
        </trans-unit>
        <trans-unit id="80d86d248f3ac806d407ff7069134427130713b0" translate="yes" xml:space="preserve">
          <source>The minute to set this &lt;a href=&quot;#TimeOfDay&quot;&gt;&lt;code&gt;TimeOfDay&lt;/code&gt;&lt;/a&gt;'s minute to.</source>
          <target state="translated">이 &lt;a href=&quot;#TimeOfDay&quot;&gt; &lt;code&gt;TimeOfDay&lt;/code&gt; &lt;/a&gt; 분을 설정하는 분 입니다.</target>
        </trans-unit>
        <trans-unit id="204cac3357eeb22cb6ce425410ebf52a7b2c34ef" translate="yes" xml:space="preserve">
          <source>The mode the memory mapped file is opened with.</source>
          <target state="translated">메모리 매핑 된 파일을 여는 모드입니다.</target>
        </trans-unit>
        <trans-unit id="973816115210d9c45eb2bc6fdd4a572e4108483e" translate="yes" xml:space="preserve">
          <source>The modified &lt;a href=&quot;http://en.wikipedia.org/wiki/Julian_day&quot;&gt;Julian day&lt;/a&gt; for any time on this date (since, the modified Julian day changes at midnight).</source>
          <target state="translated">수정 된 &lt;a href=&quot;http://en.wikipedia.org/wiki/Julian_day&quot;&gt;율리우스 일&lt;/a&gt; 이 날짜에 언제든지 (이후 수정 된 율리우스 일 자정에 변경)합니다.</target>
        </trans-unit>
        <trans-unit id="860d6be9b0cf54ee441891db4a2fd6202c776fe2" translate="yes" xml:space="preserve">
          <source>The modifier to apply.</source>
          <target state="translated">적용 할 수정 자입니다.</target>
        </trans-unit>
        <trans-unit id="124f2941f2e52ecf62ccffc3b7646e3953931e7d" translate="yes" xml:space="preserve">
          <source>The modifiers of the &lt;code&gt;lhsMod&lt;/code&gt; mismatching the ones with the &lt;code&gt;rhsMod&lt;/code&gt; are printed, i.e. lhs(shared) vs. rhs() prints &quot;&lt;code&gt;shared&lt;/code&gt;&quot;, wheras lhs() vs rhs(shared) prints &quot;non-shared&quot;.</source>
          <target state="translated">의 수정 자 &lt;code&gt;lhsMod&lt;/code&gt; 을 가진 사람이 일치하지 &lt;code&gt;rhsMod&lt;/code&gt; 가 인쇄됩니다, 즉, 좌 (공유) 대 우 () 인쇄는 &quot; &lt;code&gt;shared&lt;/code&gt; 우 대 좌 ()가 (공유) 인쇄는&quot;비는 공유 &quot;wheras&quot;.</target>
        </trans-unit>
        <trans-unit id="95523edab7d804c0b6ab6eed37c8c3cadada1694" translate="yes" xml:space="preserve">
          <source>The module edges as found in the &lt;code&gt;importedModules&lt;/code&gt; member of each ModuleInfo. Generated in sortCtors.</source>
          <target state="translated">에서 발견 모듈은 에지 &lt;code&gt;importedModules&lt;/code&gt; 의 각 부재의 ModuleInfo. sortCtors에서 생성됩니다.</target>
        </trans-unit>
        <trans-unit id="47af20b56ee3955f4fd47d6c7951eb2d036d5a4c" translate="yes" xml:space="preserve">
          <source>The module for this virtual table</source>
          <target state="translated">이 가상 테이블의 모듈</target>
        </trans-unit>
        <trans-unit id="cab05c206d3bb715fd01c040c88f5fe361c942e4" translate="yes" xml:space="preserve">
          <source>The modulus</source>
          <target state="translated">계수</target>
        </trans-unit>
        <trans-unit id="82131155f810a5f75ba3764eb1563b749deb3cf3" translate="yes" xml:space="preserve">
          <source>The monotonic clock has no relation to wall clock time. Rather, it holds its time as the number of ticks of the clock which have occurred since the clock started (typically when the system booted up). So, to determine how much time has passed between two points in time, one monotonic time is subtracted from the other to determine the number of ticks which occurred between the two points of time, and those ticks are divided by the number of ticks that occur every second (as represented by MonoTime.ticksPerSecond) to get a meaningful duration of time. Normally, MonoTime does these calculations for the programmer, but the &lt;code&gt;ticks&lt;/code&gt; and &lt;code&gt;ticksPerSecond&lt;/code&gt; properties are provided for those who require direct access to the system ticks. The normal way that MonoTime would be used is</source>
          <target state="translated">단조로운 시계는 벽시계 시간과 관련이 없습니다. 오히려, 시계가 시작된 이후 (일반적으로 시스템이 부팅 될 때) 발생한 시계의 틱 수로 시간을 유지합니다. 따라서 두 시점 사이에 경과 한 시간을 결정하기 위해 두 시점 사이에 발생한 틱 수를 결정하기 위해 한 단조 시간을 다른 시간에서 빼고 그 틱을 발생하는 틱 수로 나눕니다. 의미있는 시간을 얻기 위해 매초 (MonoTime.ticksPerSecond로 표시) 일반적으로 MonoTime은 프로그래머에 대해 이러한 계산을 수행하지만 시스템 눈금에 직접 액세스해야하는 사용자를 위해 &lt;code&gt;ticks&lt;/code&gt; 및 &lt;code&gt;ticksPerSecond&lt;/code&gt; 속성이 제공됩니다. MonoTime이 사용되는 일반적인 방법은</target>
        </trans-unit>
        <trans-unit id="d74977e8496820ecedeff19e20ade1b05de3e4b6" translate="yes" xml:space="preserve">
          <source>The month of the day to validate (January is 1).</source>
          <target state="translated">확인할 월 (1 월은 1)입니다.</target>
        </trans-unit>
        <trans-unit id="6ebaf2163e939c5ad1bf15c5f8dae4f8a043e786" translate="yes" xml:space="preserve">
          <source>The month of the day to validate.</source>
          <target state="translated">확인할 월입니다.</target>
        </trans-unit>
        <trans-unit id="d4d21752a92d87f995da2fa4e777f8856076f4d2" translate="yes" xml:space="preserve">
          <source>The month of the year to get the number of months to.</source>
          <target state="translated">개월 수를 구할 연도의 월입니다.</target>
        </trans-unit>
        <trans-unit id="3b03ba6279034200ca13bdea73b6dd032c6515f6" translate="yes" xml:space="preserve">
          <source>The month portion of the date (January is 1).</source>
          <target state="translated">날짜의 월 부분 (1 월은 1)입니다.</target>
        </trans-unit>
        <trans-unit id="e6fd335018a8476e0b61c3352fc0e3562dbfcc53" translate="yes" xml:space="preserve">
          <source>The month that each time point in the range will be in (January is 1).</source>
          <target state="translated">범위의 각 시점이있는 달 (1 월은 1)입니다.</target>
        </trans-unit>
        <trans-unit id="3a058535cdaf9aa70980ff68790ecdb70d352df1" translate="yes" xml:space="preserve">
          <source>The month to set this &lt;a href=&quot;#Date&quot;&gt;&lt;code&gt;Date&lt;/code&gt;&lt;/a&gt;'s month to.</source>
          <target state="translated">이 &lt;a href=&quot;#Date&quot;&gt; &lt;code&gt;Date&lt;/code&gt; &lt;/a&gt; 월을 설정할 월입니다.</target>
        </trans-unit>
        <trans-unit id="b85e045063e5ffa8ef021269a9798226e87028d9" translate="yes" xml:space="preserve">
          <source>The month to set this &lt;a href=&quot;#DateTime&quot;&gt;&lt;code&gt;DateTime&lt;/code&gt;&lt;/a&gt;'s month to.</source>
          <target state="translated">이 &lt;a href=&quot;#DateTime&quot;&gt; &lt;code&gt;DateTime&lt;/code&gt; &lt;/a&gt; 월을 설정할 월입니다.</target>
        </trans-unit>
        <trans-unit id="a9daf4d7ebc51fc3e649125b409fa21bb86aa474" translate="yes" xml:space="preserve">
          <source>The month to set this &lt;a href=&quot;#SysTime&quot;&gt;&lt;code&gt;SysTime&lt;/code&gt;&lt;/a&gt;'s month to.</source>
          <target state="translated">이 &lt;a href=&quot;#SysTime&quot;&gt; &lt;code&gt;SysTime&lt;/code&gt; &lt;/a&gt; 의 월을 설정할 월입니다.</target>
        </trans-unit>
        <trans-unit id="cf6b4f0b397f7fd7fb57c763984e8789cb54772a" translate="yes" xml:space="preserve">
          <source>The most basic contract is the &lt;a href=&quot;expression#AssertExpression&quot;&gt;&lt;i&gt;AssertExpression&lt;/i&gt;&lt;/a&gt;. An &lt;b&gt;assert&lt;/b&gt; declares an expression that must evaluate to true, with an optional failure string as a second argument:</source>
          <target state="translated">가장 기본적인 계약은 &lt;a href=&quot;expression#AssertExpression&quot;&gt;&lt;i&gt;AssertExpression&lt;/i&gt;&lt;/a&gt; 입니다. &lt;b&gt;어설&lt;/b&gt; 두 번째 인수로 옵션 실패 문자열로, true로 평가해야하는 식을 선언합니다 :</target>
        </trans-unit>
        <trans-unit id="8a6bd68f79c5b13e9b7d8eaf7293f850cd2e0e6d" translate="yes" xml:space="preserve">
          <source>The most conservative/general allocation: memory may be shared, deallocated in a different thread, may or may not be resized, and may embed references.</source>
          <target state="translated">가장 보수적 / 일반 할당 : 메모리는 공유 될 수 있고, 다른 스레드에서 할당 해제 될 수 있으며, 크기가 조정되거나 조정되지 않을 수 있으며, 참조를 포함 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1f6880935884c96d8b2634bfd6b4fbc9dbe4652c" translate="yes" xml:space="preserve">
          <source>The most interesting case is when gapped matches still participate in the result, but not as strongly as ungapped matches. The result will be a smooth, fine-grained similarity measure between the input strings. This is where values of &lt;code&gt;lambda&lt;/code&gt; between 0 and 1 enter into play: gapped matches are</source>
          <target state="translated">가장 흥미로운 경우는 갭 매치가 결과에 여전히 참여하지만 홉핑 된 매치만큼 강하지 않은 경우입니다. 결과는 입력 문자열 사이에서 부드럽고 세분화 된 유사성 측정 값이됩니다. 이것은 0과 1 사이 의 &lt;code&gt;lambda&lt;/code&gt; 값이 작용하는 곳입니다 .</target>
        </trans-unit>
        <trans-unit id="9317ec6cdc50605b3f7ad3a0a9efb80f09d16bb9" translate="yes" xml:space="preserve">
          <source>The mutex associated with this condition.</source>
          <target state="translated">이 조건과 관련된 뮤텍스.</target>
        </trans-unit>
        <trans-unit id="8402314bcd0aba6dacdd48ffde4057ad88f89bec" translate="yes" xml:space="preserve">
          <source>The mutex module provides a primitive for maintaining mutually exclusive access.</source>
          <target state="translated">뮤텍스 모듈은 상호 배타적 인 액세스를 유지하기위한 프리미티브를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="437cb228e7e76ab9ff7feb1b0fb4ca0971be7ae2" translate="yes" xml:space="preserve">
          <source>The mutex with which this condition will be associated.</source>
          <target state="translated">이 조건과 관련된 뮤텍스.</target>
        </trans-unit>
        <trans-unit id="4d5ce17987e89e660e90474cca14f7f4718221ad" translate="yes" xml:space="preserve">
          <source>The name &lt;code&gt;string&lt;/code&gt; is aliased to &lt;code&gt;immutable(char)[]&lt;/code&gt;, so the above declarations could be equivalently written as:</source>
          <target state="translated">이름 &lt;code&gt;string&lt;/code&gt; 은 &lt;code&gt;immutable(char)[]&lt;/code&gt; 로 별칭이 지정 되므로 위 선언을 다음과 같이 작성할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="abdfc7dd54ebeb228e02bc4ac46894950c3ebbee" translate="yes" xml:space="preserve">
          <source>The name came from &lt;a href=&quot;http://search.cpan.org/~mschwern/Class-WhiteHole-0.04/lib/Class/WhiteHole.pm&quot;&gt;Class::WhiteHole&lt;/a&gt; Perl module by Michael G Schwern.</source>
          <target state="translated">그 이름은 Michael G Schwern의 &lt;a href=&quot;http://search.cpan.org/~mschwern/Class-WhiteHole-0.04/lib/Class/WhiteHole.pm&quot;&gt;Class :: WhiteHole&lt;/a&gt; Perl 모듈에서 유래했습니다 .</target>
        </trans-unit>
        <trans-unit id="173aa229bfebb13b14fcecd5dd6654d108541499" translate="yes" xml:space="preserve">
          <source>The name came from &lt;a href=&quot;http://search.cpan.org/~sburke/Class-BlackHole-0.04/lib/Class/BlackHole.pm&quot;&gt;Class::BlackHole&lt;/a&gt; Perl module by Sean M. Burke.</source>
          <target state="translated">이름은 Sean M. Burke의 &lt;a href=&quot;http://search.cpan.org/~sburke/Class-BlackHole-0.04/lib/Class/BlackHole.pm&quot;&gt;Class :: BlackHole&lt;/a&gt; Perl 모듈 에서 유래했습니다 .</target>
        </trans-unit>
        <trans-unit id="ba677412cf6055cfe046fa4f2b82702d23be25af" translate="yes" xml:space="preserve">
          <source>The name if the &lt;code&gt;Logger&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;Logger&lt;/code&gt; 의 이름</target>
        </trans-unit>
        <trans-unit id="ef45a06b2c7cb94d26e3df83157cd1f979d10e1a" translate="yes" xml:space="preserve">
          <source>The name of the &lt;code&gt;Logger&lt;/code&gt; to insert.</source>
          <target state="translated">삽입 할 &lt;code&gt;Logger&lt;/code&gt; 의 이름입니다 .</target>
        </trans-unit>
        <trans-unit id="dd55ce2538ac752361cbfd21c951f733e9d094b0" translate="yes" xml:space="preserve">
          <source>The name of the &lt;code&gt;Logger&lt;/code&gt; to remove. If the &lt;code&gt;Logger&lt;/code&gt; is not found &lt;code&gt;null&lt;/code&gt; will be returned. Only the first occurrence of a &lt;code&gt;Logger&lt;/code&gt; with the given name will be removed.</source>
          <target state="translated">제거 할 &lt;code&gt;Logger&lt;/code&gt; 의 이름입니다 . 경우 &lt;code&gt;Logger&lt;/code&gt; 발견되지 않는 &lt;code&gt;null&lt;/code&gt; 가 반환됩니다. 이름이 지정된 &lt;code&gt;Logger&lt;/code&gt; 의 첫 번째 항목 만 제거됩니다.</target>
        </trans-unit>
        <trans-unit id="9ee544165e4b0ac751c5682d99380143dea28b21" translate="yes" xml:space="preserve">
          <source>The name of the coverage file.</source>
          <target state="translated">적용 범위 파일의 이름입니다.</target>
        </trans-unit>
        <trans-unit id="8ede299dc9f0c5729961ad67f198075314269cda" translate="yes" xml:space="preserve">
          <source>The name of the dynamic library to load.</source>
          <target state="translated">로드 할 동적 라이브러리의 이름입니다.</target>
        </trans-unit>
        <trans-unit id="eb57c5ab9b22c7728fcb5026ae94a8f672f4064a" translate="yes" xml:space="preserve">
          <source>The name of the file in the path name, without any leading directory and with an optional suffix chopped off.  If &lt;code&gt;suffix&lt;/code&gt; is specified, it will be compared to &lt;code&gt;path&lt;/code&gt; using &lt;code&gt;filenameCmp!cs&lt;/code&gt;, where &lt;code&gt;cs&lt;/code&gt; is an optional template parameter determining whether the comparison is case sensitive or not. See the &lt;a href=&quot;#filenameCmp&quot;&gt;&lt;code&gt;filenameCmp&lt;/code&gt;&lt;/a&gt; documentation for details.</source>
          <target state="translated">선행 디렉토리가없고 옵션 접미사가 잘린 경로 이름의 파일 이름입니다. 경우 &lt;code&gt;suffix&lt;/code&gt; 지정되어, 그것은 비교됩니다 &lt;code&gt;path&lt;/code&gt; 사용 &lt;code&gt;filenameCmp!cs&lt;/code&gt; , &lt;code&gt;cs&lt;/code&gt; 비교가 대소 문자를 구분 여부를 결정하는 옵션 템플릿 매개 변수입니다. 자세한 내용은 &lt;a href=&quot;#filenameCmp&quot;&gt; &lt;code&gt;filenameCmp&lt;/code&gt; &lt;/a&gt; 설명서를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="300f2fc600e9d7ddc4bfc394a66a2e870cf5e607" translate="yes" xml:space="preserve">
          <source>The name of the file that signaled this error.</source>
          <target state="translated">이 오류를 표시 한 파일의 이름입니다.</target>
        </trans-unit>
        <trans-unit id="c3104c1d832397234efa203c02c8d138f5d9f9fd" translate="yes" xml:space="preserve">
          <source>The name of the file to get the modification time for.</source>
          <target state="translated">수정 시간을 가져올 파일의 이름입니다.</target>
        </trans-unit>
        <trans-unit id="e8109b9ee879cd4547f4e2ca59c0889a944b8289" translate="yes" xml:space="preserve">
          <source>The name of the time zone.</source>
          <target state="translated">시간대의 이름입니다.</target>
        </trans-unit>
        <trans-unit id="f27bf1b63b731926e3cb9f283408921e662cdceb" translate="yes" xml:space="preserve">
          <source>The name of the time zone. Exactly how the time zone name is formatted depends on the derived class. In the case of &lt;a href=&quot;#PosixTimeZone&quot;&gt;&lt;code&gt;PosixTimeZone&lt;/code&gt;&lt;/a&gt;, it's the TZ Database name, whereas with &lt;a href=&quot;#WindowsTimeZone&quot;&gt;&lt;code&gt;WindowsTimeZone&lt;/code&gt;&lt;/a&gt;, it's the name that Windows chose to give the registry key for that time zone (typically the name that they give &lt;a href=&quot;#stdTime&quot;&gt;&lt;code&gt;stdTime&lt;/code&gt;&lt;/a&gt; if the OS is in English). For other time zone types, what it is depends on how they're implemented.</source>
          <target state="translated">시간대의 이름입니다. 표준 시간대 이름의 형식은 파생 클래스에 따라 다릅니다. 의 경우 &lt;a href=&quot;#PosixTimeZone&quot;&gt; &lt;code&gt;PosixTimeZone&lt;/code&gt; &lt;/a&gt; , 그것과 함께, 반면 TZ 데이터베이스 이름입니다 &lt;a href=&quot;#WindowsTimeZone&quot;&gt; &lt;code&gt;WindowsTimeZone&lt;/code&gt; &lt;/a&gt; , 그것은 Windows가 그 시간대에 대한 레지스트리 키 (그들이 제공하는 일반적으로 이름을 부여하기로 결정하는 이름의 &lt;a href=&quot;#stdTime&quot;&gt; &lt;code&gt;stdTime&lt;/code&gt; 를&lt;/a&gt; OS가 영어 인 경우는). 다른 시간대 유형의 경우 구현 방식에 따라 다릅니다.</target>
        </trans-unit>
        <trans-unit id="7356c9b705dbe74fbd4051d488c2e6132abcd4c9" translate="yes" xml:space="preserve">
          <source>The name of this thread.</source>
          <target state="translated">이 스레드의 이름입니다.</target>
        </trans-unit>
        <trans-unit id="c1776179bbf96730aef0ae7bbd1e4946315a478b" translate="yes" xml:space="preserve">
          <source>The name to associate with tid.</source>
          <target state="translated">tid와 연관시킬 이름입니다.</target>
        </trans-unit>
        <trans-unit id="6450e623e92fd399a84552aa61d8d22ade4cc69a" translate="yes" xml:space="preserve">
          <source>The name to locate within the registry.</source>
          <target state="translated">레지스트리 내에서 찾을 이름입니다.</target>
        </trans-unit>
        <trans-unit id="2b6764cf8c6facb0fec9b546a291b7a2d4a5f2ee" translate="yes" xml:space="preserve">
          <source>The name to unregister.</source>
          <target state="translated">등록을 취소 할 이름입니다.</target>
        </trans-unit>
        <trans-unit id="237ed33d70031f44c43457be931f956373047992" translate="yes" xml:space="preserve">
          <source>The names of the &lt;code&gt;Tuple&lt;/code&gt;'s components. Unnamed fields have empty names.</source>
          <target state="translated">&lt;code&gt;Tuple&lt;/code&gt; 구성 요소 의 이름입니다 . 이름이없는 필드에는 빈 이름이 있습니다.</target>
        </trans-unit>
        <trans-unit id="3ad8dfc5a740c084b53b8cdd123ef24e70479c04" translate="yes" xml:space="preserve">
          <source>The names of the fields that are to be aligned.</source>
          <target state="translated">정렬 할 필드의 이름입니다.</target>
        </trans-unit>
        <trans-unit id="4d205145a6dee0cb48fa4896fcd5718737412eec" translate="yes" xml:space="preserve">
          <source>The necessity of &lt;code&gt;FPTemporary&lt;/code&gt; stems from the optimized floating-point operations and registers present in virtually all processors. When adding numbers in the example above, the addition may in fact be done in &lt;code&gt;real&lt;/code&gt; precision internally. In that case, storing the intermediate &lt;code&gt;result&lt;/code&gt; in &lt;code&gt;double format&lt;/code&gt; is not only less precise, it is also (surprisingly) slower, because a conversion from &lt;code&gt;real&lt;/code&gt; to &lt;code&gt;double&lt;/code&gt; is performed every pass through the loop. This being a lose-lose situation, &lt;code&gt;FPTemporary!F&lt;/code&gt; has been defined as the</source>
          <target state="translated">&lt;code&gt;FPTemporary&lt;/code&gt; 의 필요성은 거의 모든 프로세서에 존재하는 최적화 된 부동 소수점 연산 및 레지스터에서 비롯됩니다. 위의 예에서 번호를 추가 할 때 추가는 사실에 수행 할 수 있습니다 &lt;code&gt;real&lt;/code&gt; 내부적으로 정밀. 이 경우, 기억 중간 &lt;code&gt;result&lt;/code&gt; 의 &lt;code&gt;double format&lt;/code&gt; 행 변환 있기 때문에, (놀랍게도) 느도뿐만 아니라, 덜 정확 &lt;code&gt;real&lt;/code&gt; 으로 &lt;code&gt;double&lt;/code&gt; IS 루프를 통해 모든 패스를 수행 하였다. 이것은 잃어버린 잃어버린 상황입니다. &lt;code&gt;FPTemporary!F&lt;/code&gt; 는</target>
        </trans-unit>
        <trans-unit id="ce69a83fa824acdbab753bf226be620b99f45d75" translate="yes" xml:space="preserve">
          <source>The needles against which the range is to be checked, which may be individual elements or input ranges of elements.</source>
          <target state="translated">범위를 점검 할 바늘. 개별 요소 또는 요소의 입력 범위 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="bfdb89ae3952e0ebbdb470ec1b2208c20a477858" translate="yes" xml:space="preserve">
          <source>The needles to check against, which may be single elements, or bidirectional ranges of elements.</source>
          <target state="translated">점검 할 바늘은 단일 요소 또는 양방향 요소 범위 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="aadc952b806bed5663dabd85a1e647a24a59b7a9" translate="yes" xml:space="preserve">
          <source>The network interface to use in form of the the IP of the interface.</source>
          <target state="translated">인터페이스의 IP 형식으로 사용할 네트워크 인터페이스입니다.</target>
        </trans-unit>
        <trans-unit id="d0400083bef2e7ef7cc46b24ddfeddfeb8ab8c14" translate="yes" xml:space="preserve">
          <source>The new GC is added to the list of available garbage collectors that can be selected via the usual configuration options, e.g. by embedding &lt;code&gt;rt_options&lt;/code&gt; into the binary:</source>
          <target state="translated">새로운 GC는 일반적인 구성 옵션을 통해 선택할 수있는 가비지 수집기 목록에 추가됩니다 (예 : &lt;code&gt;rt_options&lt;/code&gt; 를 이진 파일에 포함).</target>
        </trans-unit>
        <trans-unit id="9669eec52fe11c4d6bad1a51de754d4e92f468df" translate="yes" xml:space="preserve">
          <source>The new capacity of the array (which may be larger than the requested capacity).</source>
          <target state="translated">어레이의 새로운 용량 (요청 된 용량보다 클 수 있음).</target>
        </trans-unit>
        <trans-unit id="1cf6198accddd14ad946cf8a5d9d64fbb23a0e02" translate="yes" xml:space="preserve">
          <source>The new collect handler. Set to null to use the default handler.</source>
          <target state="translated">새로운 수집 처리기 기본 핸들러를 사용하려면 널로 설정하십시오.</target>
        </trans-unit>
        <trans-unit id="0c74f8b0b947d138316f600a118f4af837db2c6f" translate="yes" xml:space="preserve">
          <source>The new daemon status for this thread.</source>
          <target state="translated">이 스레드의 새로운 데몬 상태.</target>
        </trans-unit>
        <trans-unit id="cc66954b4cb782475e75068053434548b84f648b" translate="yes" xml:space="preserve">
          <source>The new extension</source>
          <target state="translated">새로운 확장</target>
        </trans-unit>
        <trans-unit id="6c6fed22d3bfa6cee371ded07b99f5fc419355ad" translate="yes" xml:space="preserve">
          <source>The new handle will have all options set as the one it was duplicated from. An exception to this is that all options that cannot be shared across threads are reset thereby making it safe to use the duplicate in a new thread.</source>
          <target state="translated">새 핸들에는 모든 옵션이 복제 된 것으로 설정됩니다. 이에 대한 예외는 스레드간에 공유 할 수없는 모든 옵션이 재설정되어 새 스레드에서 복제본을 안전하게 사용할 수 있다는 것입니다.</target>
        </trans-unit>
        <trans-unit id="acc5bddfa65365c1a41f6c814bd0b6ebf529b8b6" translate="yes" xml:space="preserve">
          <source>The new length of the array</source>
          <target state="translated">배열의 새로운 길이</target>
        </trans-unit>
        <trans-unit id="44a43ff11b1752259ff91b328a916debf3f4639d" translate="yes" xml:space="preserve">
          <source>The new name of this thread.</source>
          <target state="translated">이 스레드의 새로운 이름입니다.</target>
        </trans-unit>
        <trans-unit id="06d8bda027bfab1541ebec46a9bfa9f862174683" translate="yes" xml:space="preserve">
          <source>The new path name.</source>
          <target state="translated">새로운 경로 이름.</target>
        </trans-unit>
        <trans-unit id="69ac0b91bb8b9e837548ad9dd2ea12af0f0c91cd" translate="yes" xml:space="preserve">
          <source>The new position of the pivot</source>
          <target state="translated">피벗의 새로운 위치</target>
        </trans-unit>
        <trans-unit id="66818226d4d8e1db31b172237309a1e18f4a385a" translate="yes" xml:space="preserve">
          <source>The new scheduling priority of this thread.</source>
          <target state="translated">이 스레드의 새로운 스케줄링 우선 순위.</target>
        </trans-unit>
        <trans-unit id="bd1e49caf2a8a204c7259f45e5e91918594335cb" translate="yes" xml:space="preserve">
          <source>The new trace handler. Set to null to use the default handler.</source>
          <target state="translated">새로운 추적 핸들러 기본 핸들러를 사용하려면 널로 설정하십시오.</target>
        </trans-unit>
        <trans-unit id="ef32f36ed520dab3a13bb8e95c2b955f22dc9b02" translate="yes" xml:space="preserve">
          <source>The new type supports all operations that the underlying type does, including all operators such as &lt;code&gt;+&lt;/code&gt;, &lt;code&gt;--&lt;/code&gt;, &lt;code&gt;&amp;lt;&lt;/code&gt;, &lt;code&gt;[]&lt;/code&gt;, etc.</source>
          <target state="translated">새 유형은 &lt;code&gt;+&lt;/code&gt; , &lt;code&gt;--&lt;/code&gt; , &lt;code&gt;&amp;lt;&lt;/code&gt; , &lt;code&gt;[]&lt;/code&gt; 등과 같은 모든 연산자를 포함하여 기본 유형이 수행하는 모든 작업을 지원합니다 .</target>
        </trans-unit>
        <trans-unit id="4c2af0bb285d74b0268707c20367567927c3ffc7" translate="yes" xml:space="preserve">
          <source>The new unit tester. Set both to null to use the default unit tester.</source>
          <target state="translated">새로운 단위 테스터. 기본 단위 테스터를 사용하려면 둘 다 null로 설정하십시오.</target>
        </trans-unit>
        <trans-unit id="6444785f7ab11942d704329e47346be10efdb756" translate="yes" xml:space="preserve">
          <source>The new value of &lt;code&gt;px&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;px&lt;/code&gt; 의 새로운 가치</target>
        </trans-unit>
        <trans-unit id="a51d15a8fa704020915ee450c5caa4010f6aa779" translate="yes" xml:space="preserve">
          <source>The new value of &lt;code&gt;x&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;x&lt;/code&gt; 의 새로운 가치</target>
        </trans-unit>
        <trans-unit id="e4e6a0eafbf606dbc06607e9b4455a1bb56b0445" translate="yes" xml:space="preserve">
          <source>The new-style generator objects hold their own state so they are immune of threading issues. The generators feature a number of well-known and well-documented methods of generating random numbers. An overall fast and reliable means to generate random numbers is the Mt19937 generator, which derives its name from &quot;&lt;a href=&quot;https://en.wikipedia.org/wiki/Mersenne_Twister&quot;&gt;Mersenne Twister&lt;/a&gt; with a period of 2 to the power of 19937&quot;. In memory-constrained situations, &lt;a href=&quot;https://en.wikipedia.org/wiki/Linear_congruential_generator&quot;&gt;linear congruential generators&lt;/a&gt; such as &lt;code&gt;MinstdRand0&lt;/code&gt; and &lt;code&gt;MinstdRand&lt;/code&gt; might be useful. The standard library provides an alias Random for whichever generator it considers the most fit for the target environment.</source>
          <target state="translated">새로운 스타일 생성기 객체는 자체 상태를 유지하므로 스레드 문제에 영향을받지 않습니다. 생성기는 난수를 생성하는 잘 알려지고 잘 문서화 된 여러 가지 방법을 제공합니다. 난수를 생성하는 전체 빠르고 신뢰할 수있는 수단은 Mt19937 생성기이며, &quot; 2의 기간 인 &lt;a href=&quot;https://en.wikipedia.org/wiki/Mersenne_Twister&quot;&gt;Mersenne Twister&lt;/a&gt; 에서 19937의 거듭 제곱&quot; 이라는 이름에서 유래합니다 . 메모리가 제한된 상황에서는 &lt;code&gt;MinstdRand0&lt;/code&gt; 및 &lt;code&gt;MinstdRand&lt;/code&gt; 와 같은 &lt;a href=&quot;https://en.wikipedia.org/wiki/Linear_congruential_generator&quot;&gt;선형 합동 생성기&lt;/a&gt; 가 유용 할 수 있습니다. 표준 라이브러리는 대상 환경에 가장 적합한 것으로 생각되는 생성기에 임의의 별칭을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="6e04d5ec9d8b3f77749de3ac5300639b2dab8407" translate="yes" xml:space="preserve">
          <source>The newline following the opening identifier is not part of the string, but the last newline before the closing identifier is part of the string. The closing identifier must be placed on its own line at the leftmost column.</source>
          <target state="translated">여는 식별자 뒤에 오는 줄 바꿈은 문자열의 일부가 아니지만 닫는 식별자 앞의 마지막 줄 바꿈은 문자열의 일부입니다. 닫는 식별자는 가장 왼쪽 열의 자체 줄에 배치해야합니다.</target>
        </trans-unit>
        <trans-unit id="51929efa4bba26701d3e4c3aa50f3e9c95ba7e57" translate="yes" xml:space="preserve">
          <source>The newly constructed object.</source>
          <target state="translated">새로 생성 된 객체.</target>
        </trans-unit>
        <trans-unit id="c4d7c48e5f93c9ad9f6d35527dbfa50a57849838" translate="yes" xml:space="preserve">
          <source>The newly-created array, or &lt;code&gt;null&lt;/code&gt; if either &lt;code&gt;length&lt;/code&gt; was &lt;code&gt;0&lt;/code&gt; or allocation failed.</source>
          <target state="translated">새로 생성 된 배열. &lt;code&gt;length&lt;/code&gt; 가 &lt;code&gt;0&lt;/code&gt; 이거나 할당에 실패한 경우 &lt;code&gt;null&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="b81ee0139f4bf3ca132aff416b4badbbfb8df40c" translate="yes" xml:space="preserve">
          <source>The next unnamed section is the</source>
          <target state="translated">이름이없는 다음 섹션은</target>
        </trans-unit>
        <trans-unit id="4c1d1956fd234c462fed35c0d040ec6b5d07b95f" translate="yes" xml:space="preserve">
          <source>The non-static data members of a struct are called</source>
          <target state="translated">구조체의 비 정적 데이터 멤버를</target>
        </trans-unit>
        <trans-unit id="604fdea6e74692fe9e13e9f5a58a3d2b1b6ac2cf" translate="yes" xml:space="preserve">
          <source>The normal (or Gaussian, or bell-shaped) distribution is defined as:</source>
          <target state="translated">정규 (또는 가우스 또는 종 모양) 분포는 다음과 같이 정의됩니다.</target>
        </trans-unit>
        <trans-unit id="eff21418db566bf6deaa5b9e66141af90f3d37fd" translate="yes" xml:space="preserve">
          <source>The normal flow of program logic is performance critical.</source>
          <target state="translated">프로그램 논리의 정상적인 흐름은 성능에 중요합니다.</target>
        </trans-unit>
        <trans-unit id="7d10d0ff78a75299a167b0002f609034c9aaa171" translate="yes" xml:space="preserve">
          <source>The nth &lt;code&gt;ulong&lt;/code&gt; in the representation of this &lt;code&gt;BigInt&lt;/code&gt;.</source>
          <target state="translated">이 &lt;code&gt;BigInt&lt;/code&gt; 의 표현의 n 번째 &lt;code&gt;ulong&lt;/code&gt; 입니다 .</target>
        </trans-unit>
        <trans-unit id="bb3057bb9b7c5b0a70e9ce3b421bd111159e0bc0" translate="yes" xml:space="preserve">
          <source>The nth number to retrieve. Must be less than &lt;a href=&quot;#ulongLength&quot;&gt;&lt;code&gt;ulongLength&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;#uintLength&quot;&gt;&lt;code&gt;uintLength&lt;/code&gt;&lt;/a&gt; with respect to &lt;code&gt;T&lt;/code&gt;.</source>
          <target state="translated">검색 할 n 번째 숫자입니다. &lt;code&gt;T&lt;/code&gt; 와 관련하여 &lt;a href=&quot;#ulongLength&quot;&gt; &lt;code&gt;ulongLength&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;#uintLength&quot;&gt; &lt;code&gt;uintLength&lt;/code&gt; &lt;/a&gt; 보다 작아야 합니다.</target>
        </trans-unit>
        <trans-unit id="b76d5847a278447b3f3920d9aa794bc68c09f466" translate="yes" xml:space="preserve">
          <source>The null value which denotes the null state of this &lt;code&gt;Nullable&lt;/code&gt;. Must be of type &lt;code&gt;T&lt;/code&gt;.</source>
          <target state="translated">이러한 널 (null) 상태이다 NULL 값 &lt;code&gt;Nullable&lt;/code&gt; . &lt;code&gt;T&lt;/code&gt; 유형이어야합니다 .</target>
        </trans-unit>
        <trans-unit id="199b0fb0977641f832ecd7a38d40b0a14f3dad41" translate="yes" xml:space="preserve">
          <source>The number of &lt;code&gt;Tgt&lt;/code&gt; elements written.</source>
          <target state="translated">쓰여진 &lt;code&gt;Tgt&lt;/code&gt; 요소 의 수</target>
        </trans-unit>
        <trans-unit id="95368522e59bb86a89704bd4d6738e476908f01e" translate="yes" xml:space="preserve">
          <source>The number of bits of state of this generator. This must be a positive multiple of the size in bits of UIntType. If nbits is large this struct may occupy slightly more memory than this so it can use a circular counter instead of shifting the entire array.</source>
          <target state="translated">이 생성기의 상태 비트 수입니다. UIntType의 비트 단위 크기의 양의 배수 여야합니다. nbit가 크면이 구조체는 이것보다 약간 더 많은 메모리를 차지할 수 있으므로 전체 배열을 이동하는 대신 원형 카운터를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ed0599417ff90656d7b8a7db044e9965e3ca5970" translate="yes" xml:space="preserve">
          <source>The number of buffers to cycle through when calling &lt;code&gt;next&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;next&lt;/code&gt; 를 호출 할 때 순환 할 버퍼 수입니다 .</target>
        </trans-unit>
        <trans-unit id="30308060113660277e7be67f08fdce3f91011c41" translate="yes" xml:space="preserve">
          <source>The number of bytes actually received, &lt;code&gt;0&lt;/code&gt; if the remote side has closed the connection, or &lt;code&gt;Socket.ERROR&lt;/code&gt; on failure.</source>
          <target state="translated">실제로 수신 된 바이트 수 , 원격 측이 연결을 닫은 경우 &lt;code&gt;0&lt;/code&gt; 또는 실패시 &lt;code&gt;Socket.ERROR&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="52771a2599e853e22c9997ae74caf507a27e6674" translate="yes" xml:space="preserve">
          <source>The number of bytes actually sent, or &lt;code&gt;Socket.ERROR&lt;/code&gt; on failure.</source>
          <target state="translated">실제로 전송 된 바이트 수 또는 실패시 &lt;code&gt;Socket.ERROR&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="cb4925770f917957f95841228cf7a081251584ac" translate="yes" xml:space="preserve">
          <source>The number of bytes written to &lt;code&gt;result&lt;/code&gt;. The length, in bytes, of the actual result - very different from getsockopt()</source>
          <target state="translated">&lt;code&gt;result&lt;/code&gt; 에 쓴 바이트 수입니다 . 실제 결과의 길이 (바이트)-getsockopt ()와는 매우 다릅니다</target>
        </trans-unit>
        <trans-unit id="18e0b014069c5b9a5015fd8266605137eb19d431" translate="yes" xml:space="preserve">
          <source>The number of cache levels in the CPU.</source>
          <target state="translated">CPU의 캐시 레벨 수입니다.</target>
        </trans-unit>
        <trans-unit id="4e1a5c7628d25ca94f5309da0ccfd2a5e3544707" translate="yes" xml:space="preserve">
          <source>The number of chunks buffered asynchronously</source>
          <target state="translated">비동기 적으로 버퍼링 된 청크 수</target>
        </trans-unit>
        <trans-unit id="d794552fb711e9d13296816f458408c772152acf" translate="yes" xml:space="preserve">
          <source>The number of code units in &lt;code&gt;input&lt;/code&gt; when encoded to &lt;code&gt;C&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;C&lt;/code&gt; 로 인코딩 될 때 &lt;code&gt;input&lt;/code&gt; 된 코드 단위 수</target>
        </trans-unit>
        <trans-unit id="4af8e22ffe4686545114fe30d8267cec1e21b38c" translate="yes" xml:space="preserve">
          <source>The number of code units in the UTF sequence. For UTF-8, this is a value between 1 and 4 (as per &lt;a href=&quot;http://tools.ietf.org/html/rfc3629#section-3&quot;&gt;RFC 3629, section 3&lt;/a&gt;). For UTF-16, it is either 1 or 2. For UTF-32, it is always 1.</source>
          <target state="translated">UTF 시퀀스의 코드 단위 수입니다. UTF-8의 경우, 이것은 1과 4 사이의 값입니다 ( &lt;a href=&quot;http://tools.ietf.org/html/rfc3629#section-3&quot;&gt;RFC 3629, 섹션 3에 따라&lt;/a&gt; ). UTF-16의 경우 1 또는 2입니다. UTF-32의 경우 항상 1입니다.</target>
        </trans-unit>
        <trans-unit id="5eb0aafa3d3443973bc7f248675786f305586655" translate="yes" xml:space="preserve">
          <source>The number of colons in the selector needs to match the number of parameters the method is declared with</source>
          <target state="translated">선택기의 콜론 수는 메소드가 선언 된 매개 변수 수와 일치해야합니다.</target>
        </trans-unit>
        <trans-unit id="cf1a54117f4160455c190793bfbc5f270d3ef431" translate="yes" xml:space="preserve">
          <source>The number of colons in the string need to match the number of arguments the method accept.</source>
          <target state="translated">문자열의 콜론 수는 메소드가 허용하는 인수 수와 일치해야합니다.</target>
        </trans-unit>
        <trans-unit id="74867ebd8619c3c9f54bb7be26778ccc990cfd33" translate="yes" xml:space="preserve">
          <source>The number of days to add to this &lt;a href=&quot;#Date&quot;&gt;&lt;code&gt;Date&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 &lt;a href=&quot;#Date&quot;&gt; &lt;code&gt;Date&lt;/code&gt; &lt;/a&gt; 에 추가 할 일수 입니다.</target>
        </trans-unit>
        <trans-unit id="17519ebe025dfa827b2543290a321667b7bbfac2" translate="yes" xml:space="preserve">
          <source>The number of elements brought to the front, i.e., the length of &lt;code&gt;back&lt;/code&gt;.</source>
          <target state="translated">요소의 수는 앞의 예, 길이에 데리고 &lt;code&gt;back&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="30c9197d75a0a694e962a609bbc59e4ba11be6f0" translate="yes" xml:space="preserve">
          <source>The number of elements in an</source>
          <target state="translated">의 요소 수</target>
        </trans-unit>
        <trans-unit id="0419481cf5884d86b99e61181cced8b51e95c26d" translate="yes" xml:space="preserve">
          <source>The number of elements in the array.</source>
          <target state="translated">배열의 요소 수</target>
        </trans-unit>
        <trans-unit id="325aeffb680232bb5eba0a4534994930400a1165" translate="yes" xml:space="preserve">
          <source>The number of elements inserted</source>
          <target state="translated">삽입 된 요소 수</target>
        </trans-unit>
        <trans-unit id="4f13d3392d3b50fea45a81fe242fa67f3021e8e8" translate="yes" xml:space="preserve">
          <source>The number of elements inserted.</source>
          <target state="translated">삽입 된 요소 수</target>
        </trans-unit>
        <trans-unit id="c6d6d4be5d1980bfa9a3ce44b333a124372b6ae3" translate="yes" xml:space="preserve">
          <source>The number of elements removed</source>
          <target state="translated">제거 된 요소 수</target>
        </trans-unit>
        <trans-unit id="20396f56c8e3a0c13e5e36b7f2622f3b64ae5d64" translate="yes" xml:space="preserve">
          <source>The number of elements removed.</source>
          <target state="translated">제거 된 요소 수</target>
        </trans-unit>
        <trans-unit id="a147df2d8f03d61a2cbd49ca985ab3c09c4946c0" translate="yes" xml:space="preserve">
          <source>The number of elements to evaluate in a single &lt;code&gt;Task&lt;/code&gt;. Must be less than or equal to &lt;code&gt;bufSize&lt;/code&gt;, and should be a fraction of &lt;code&gt;bufSize&lt;/code&gt; such that all worker threads can be used. If the default of size_t.max is used, workUnitSize will be set to the pool-wide default.</source>
          <target state="translated">단일 &lt;code&gt;Task&lt;/code&gt; 에서 평가할 요소 수입니다 . &lt;code&gt;bufSize&lt;/code&gt; 이하이어야하며 모든 작업자 스레드를 사용할 수 있도록 &lt;code&gt;bufSize&lt;/code&gt; 의 일부 여야합니다 . size_t.max의 기본값을 사용하면 workUnitSize가 풀 전체 기본값으로 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="9de93b8e68b06f4138b723f65ba57f9135fbd680" translate="yes" xml:space="preserve">
          <source>The number of elements which must be popped from the front of &lt;code&gt;haystack&lt;/code&gt; before reaching an element for which &lt;code&gt;startsWith!pred(haystack, needles)&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;. If &lt;code&gt;startsWith!pred(haystack, needles)&lt;/code&gt; is not &lt;code&gt;true&lt;/code&gt; for any element in &lt;code&gt;haystack&lt;/code&gt;, then &lt;code&gt;-1&lt;/code&gt; is returned. If only &lt;code&gt;pred&lt;/code&gt; is provided, &lt;code&gt;pred(haystack)&lt;/code&gt; is tested for each element.</source>
          <target state="translated">&lt;code&gt;startsWith!pred(haystack, needles)&lt;/code&gt; 에 &lt;code&gt;true&lt;/code&gt; 하는 요소에 도달하기 전에 &lt;code&gt;haystack&lt;/code&gt; 의 전면에서 튀어 나와야 하는 요소 수 는 true 입니다. 경우 &lt;code&gt;startsWith!pred(haystack, needles)&lt;/code&gt; 아닌 &lt;code&gt;true&lt;/code&gt; 의 모든 요소에 대한 &lt;code&gt;haystack&lt;/code&gt; , 다음 &lt;code&gt;-1&lt;/code&gt; 반환됩니다. &lt;code&gt;pred&lt;/code&gt; 만 제공되면 각 요소에 대해 &lt;code&gt;pred(haystack)&lt;/code&gt; 가 테스트됩니다.</target>
        </trans-unit>
        <trans-unit id="495bce27f099960a19a7f2777229fe07b08dc353" translate="yes" xml:space="preserve">
          <source>The number of hnsecs since January 1st, 1 A.D. UTC.</source>
          <target state="translated">AD UTC 1 월 1 일 이후의 hnsec 수</target>
        </trans-unit>
        <trans-unit id="0128cf9b280876e985f5bc63b3c33b05eec8b671" translate="yes" xml:space="preserve">
          <source>The number of hnsecs since midnight, January 1st, 1 A.D. UTC.</source>
          <target state="translated">AD UTC 1 월 1 일 자정 이후의 hnsecs 수입니다.</target>
        </trans-unit>
        <trans-unit id="dfa696143d106fe9221db705fdd3a015ad40f3ab" translate="yes" xml:space="preserve">
          <source>The number of lines buffered asynchronously</source>
          <target state="translated">비동기식으로 버퍼링 된 라인 수</target>
        </trans-unit>
        <trans-unit id="9bd6f12f8ce1f299c0d0263b77bcc143be77d073" translate="yes" xml:space="preserve">
          <source>The number of months or years to add to this &lt;a href=&quot;#Date&quot;&gt;&lt;code&gt;Date&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 &lt;a href=&quot;#Date&quot;&gt; &lt;code&gt;Date&lt;/code&gt; &lt;/a&gt; 에 추가 할 개월 또는 년 수입니다 .</target>
        </trans-unit>
        <trans-unit id="b9c39f066ee7dbe68f94fd81f8c5f3cf00396747" translate="yes" xml:space="preserve">
          <source>The number of months or years to add to this &lt;a href=&quot;#DateTime&quot;&gt;&lt;code&gt;DateTime&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 &lt;a href=&quot;#DateTime&quot;&gt; &lt;code&gt;DateTime&lt;/code&gt; &lt;/a&gt; 에 추가 할 개월 또는 년 수입니다 .</target>
        </trans-unit>
        <trans-unit id="57340a14727c652a36c1e1fc1ba3e2830bbfa123" translate="yes" xml:space="preserve">
          <source>The number of months or years to add to this &lt;a href=&quot;#SysTime&quot;&gt;&lt;code&gt;SysTime&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 &lt;a href=&quot;#SysTime&quot;&gt; &lt;code&gt;SysTime&lt;/code&gt; &lt;/a&gt; 에 추가 할 개월 또는 년 수입니다 .</target>
        </trans-unit>
        <trans-unit id="02485194b1dc362bace73e65c9372da46a13c61b" translate="yes" xml:space="preserve">
          <source>The number of months to add to the time point passed to the delegate.</source>
          <target state="translated">대리인에게 전달 된 시점에 추가 할 개월 수입니다.</target>
        </trans-unit>
        <trans-unit id="aca30d94828d21a4c6a8ef3a42e227aa33b46f16" translate="yes" xml:space="preserve">
          <source>The number of months to expand the interval by.</source>
          <target state="translated">간격을 확장 할 개월 수입니다.</target>
        </trans-unit>
        <trans-unit id="4f7751ef3f5968bb794d3b81c43237882d9d52ee" translate="yes" xml:space="preserve">
          <source>The number of months to shift the interval by.</source>
          <target state="translated">간격을 변경하는 개월 수입니다.</target>
        </trans-unit>
        <trans-unit id="63a68d030d7307514d07c50786c06b3b1b3f26d9" translate="yes" xml:space="preserve">
          <source>The number of pages is variable (but not less then 1) unlike the number of entries in the index. The slots of the index all have to contain a number of a page that is present. The lookup is then just a couple of operations - slice the upper bits, lookup an index for these, take a page at this index and use the lower bits as an offset within this page.</source>
          <target state="translated">페이지 수는 색인의 항목 수와 달리 가변적이지만 1보다 작습니다. 색인의 슬롯에는 모두 여러 페이지가 있어야합니다. 조회는 단지 두 개의 연산입니다-상위 비트를 슬라이스하고, 이들을위한 인덱스를 조회하고,이 인덱스에서 페이지를 가져 와서이 페이지 내에서 하위 비트를 오프셋으로 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="a4a9d929861b7f4540e0616b20649c026af1b75f" translate="yes" xml:space="preserve">
          <source>The number of positions in the &lt;code&gt;haystack&lt;/code&gt; for which &lt;code&gt;pred&lt;/code&gt; returned true.</source>
          <target state="translated">의 위치의 수 &lt;code&gt;haystack&lt;/code&gt; 있는 &lt;code&gt;pred&lt;/code&gt; 사실 돌아왔다.</target>
        </trans-unit>
        <trans-unit id="e5d60a9e70df9e4591b2299d06f99ccc91195edd" translate="yes" xml:space="preserve">
          <source>The number of sockets with status changes, &lt;code&gt;0&lt;/code&gt; on timeout, or &lt;code&gt;-1&lt;/code&gt; on interruption. If the return value is greater than &lt;code&gt;0&lt;/code&gt;, the &lt;code&gt;SocketSets&lt;/code&gt; are updated to only contain the sockets having status changes. For a connecting socket, a write status change means the connection is established and it's able to send. For a listening socket, a read status change means there is an incoming connection request and it's able to accept.  &lt;code&gt;SocketSet&lt;/code&gt;'s updated to include only those sockets which an event occured. For a &lt;code&gt;connect()&lt;/code&gt;ing socket, writeability means connected. For a &lt;code&gt;listen()&lt;/code&gt;ing socket, readability means listening &lt;code&gt;Winsock&lt;/code&gt;; possibly internally limited to 64 sockets per set.</source>
          <target state="translated">상태가 변경된 소켓 수, 시간 종료시 &lt;code&gt;0&lt;/code&gt; 또는 중단시 &lt;code&gt;-1&lt;/code&gt; 반환 값이보다 큰 경우 &lt;code&gt;0&lt;/code&gt; 의 &lt;code&gt;SocketSets&lt;/code&gt; 는 전용 상태 변화를 갖는 소켓을 포함하도록 업데이트됩니다. 연결 소켓의 경우 쓰기 상태 변경은 연결이 설정되어 전송할 수 있음을 의미합니다. 청취 소켓의 경우 읽기 상태 변경은 들어오는 연결 요청이 있으며 수락 할 수 있음을 의미합니다. &lt;code&gt;SocketSet&lt;/code&gt; 가 이벤트가 발생한 소켓 만 포함하도록 업데이트되었습니다. A에 대한 &lt;code&gt;connect()&lt;/code&gt; ING 소켓 writeability 수단이 접속되어있다. A가 들어 &lt;code&gt;listen()&lt;/code&gt; 소켓, 가독성 수단 듣기를 보내고 &lt;code&gt;Winsock&lt;/code&gt; ; 내부적으로 세트당 64 개의 소켓으로 제한 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="92623bd7d09398f80bbab3bb0f5f2ef38d3da421" translate="yes" xml:space="preserve">
          <source>The number of system ticks in this &lt;code&gt;TickDuration&lt;/code&gt;.</source>
          <target state="translated">이 &lt;code&gt;TickDuration&lt;/code&gt; 의 시스템 틱 수입니다 .</target>
        </trans-unit>
        <trans-unit id="8f11ee7d7d27eb3d41061b45eac584df0b5f1cfe" translate="yes" xml:space="preserve">
          <source>The number of ticks in the TickDuration.</source>
          <target state="translated">TickDuration의 틱 수입니다.</target>
        </trans-unit>
        <trans-unit id="c3535c21516c22bad36e4ae79f60e710279eebd0" translate="yes" xml:space="preserve">
          <source>The number of ticks in the monotonic time.</source>
          <target state="translated">단조로운 시간의 틱 수입니다.</target>
        </trans-unit>
        <trans-unit id="133c2247d181f5eb459c19f2950580ed684e418a" translate="yes" xml:space="preserve">
          <source>The number of ticks that MonoTime has per second - i.e. the resolution or frequency of the system's monotonic clock.</source>
          <target state="translated">MonoTime의 초당 틱 수-시스템의 단조로운 클럭의 해상도 또는 주파수.</target>
        </trans-unit>
        <trans-unit id="8271982f8f2afc20c964508f18ca6b32767857e7" translate="yes" xml:space="preserve">
          <source>The number of ticks that the system clock has in one second.</source>
          <target state="translated">시스템 시계의 틱 수는 1 초입니다.</target>
        </trans-unit>
        <trans-unit id="8b51266ea49a500bd86819d90d5f5babd9fda252" translate="yes" xml:space="preserve">
          <source>The number of times each function is to be executed.</source>
          <target state="translated">각 기능이 실행되는 횟수입니다.</target>
        </trans-unit>
        <trans-unit id="f1050ae226927365357fc51efba9b81760d7056b" translate="yes" xml:space="preserve">
          <source>The number of times the output range's &lt;code&gt;put&lt;/code&gt; method was invoked.</source>
          <target state="translated">출력 범위의 &lt;code&gt;put&lt;/code&gt; 메소드가 호출 된 횟수입니다 .</target>
        </trans-unit>
        <trans-unit id="4d82522805f2ebbbf559fec74a61f5c7cb9cc3a6" translate="yes" xml:space="preserve">
          <source>The number of units in the &lt;code&gt;Duration&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Duration&lt;/code&gt; 의 단위 수입니다 .</target>
        </trans-unit>
        <trans-unit id="794f084381c766ea0ff9fffa3e14bba305b1eb34" translate="yes" xml:space="preserve">
          <source>The number of units in the &lt;code&gt;TickDuration&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;TickDuration&lt;/code&gt; 의 단위 수입니다 .</target>
        </trans-unit>
        <trans-unit id="22c3d0c8685c468fadcdccd79c29727ddf2e7e9a" translate="yes" xml:space="preserve">
          <source>The number of units to add to this &lt;a href=&quot;#DateTime&quot;&gt;&lt;code&gt;DateTime&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 &lt;a href=&quot;#DateTime&quot;&gt; &lt;code&gt;DateTime&lt;/code&gt; &lt;/a&gt; 에 추가 할 단위 수입니다 .</target>
        </trans-unit>
        <trans-unit id="9b148446ca97774856b435f40497b3469e8ca6ab" translate="yes" xml:space="preserve">
          <source>The number of units to add to this &lt;a href=&quot;#SysTime&quot;&gt;&lt;code&gt;SysTime&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 &lt;a href=&quot;#SysTime&quot;&gt; &lt;code&gt;SysTime&lt;/code&gt; &lt;/a&gt; 에 추가 할 단위 수입니다 .</target>
        </trans-unit>
        <trans-unit id="b3b24aff6aba1d0b2f312ff80d7560f7feabc059" translate="yes" xml:space="preserve">
          <source>The number of units to add to this &lt;a href=&quot;#TimeOfDay&quot;&gt;&lt;code&gt;TimeOfDay&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 &lt;a href=&quot;#TimeOfDay&quot;&gt; &lt;code&gt;TimeOfDay&lt;/code&gt; &lt;/a&gt; 에 추가 할 단위 수입니다 .</target>
        </trans-unit>
        <trans-unit id="37c2540cc1f38510b5307fd0d898532d4c17f0e5" translate="yes" xml:space="preserve">
          <source>The number of units to multiply this &lt;code&gt;Duration&lt;/code&gt; by.</source>
          <target state="translated">이 &lt;code&gt;Duration&lt;/code&gt; 에 곱할 단위 수입니다 .</target>
        </trans-unit>
        <trans-unit id="5f6b34534215487ddb13229d1e9eb704abfb659b" translate="yes" xml:space="preserve">
          <source>The number of values inserted.</source>
          <target state="translated">삽입 된 값의 수입니다.</target>
        </trans-unit>
        <trans-unit id="d14be6e779a48d8faa82f80e4dc078722606651d" translate="yes" xml:space="preserve">
          <source>The number of waiting threads to release in unison.</source>
          <target state="translated">한꺼번에 해제 대기 스레드 수입니다.</target>
        </trans-unit>
        <trans-unit id="365cb2c08dafe42960332e827da68e53b00a9bd8" translate="yes" xml:space="preserve">
          <source>The number of years to add to the time point passed to the delegate.</source>
          <target state="translated">대리인에게 전달 된 시점에 추가 할 연수입니다.</target>
        </trans-unit>
        <trans-unit id="fcc2e5d2212e8d8be70b8d4677e493fc3848a020" translate="yes" xml:space="preserve">
          <source>The number of years to expand the interval by.</source>
          <target state="translated">간격을 연장하는 연도입니다.</target>
        </trans-unit>
        <trans-unit id="2241ab252f8a5484883abb33a8af4a6dad25eb69" translate="yes" xml:space="preserve">
          <source>The number of years to shift the interval by.</source>
          <target state="translated">간격을 옮길 년 수입니다.</target>
        </trans-unit>
        <trans-unit id="ab33e33805a08eda08dd986381c2b8f8b862f93b" translate="yes" xml:space="preserve">
          <source>The number to validate.</source>
          <target state="translated">검증 할 번호입니다.</target>
        </trans-unit>
        <trans-unit id="b28803e23c2f1bebd73a4d48e79b273e730f7db3" translate="yes" xml:space="preserve">
          <source>The numeric literals &lt;code&gt;0&lt;/code&gt; and &lt;code&gt;1&lt;/code&gt; can be implicitly converted to the &lt;code&gt;bool&lt;/code&gt; values &lt;code&gt;false&lt;/code&gt; and &lt;code&gt;true&lt;/code&gt;, respectively. Casting an expression to &lt;code&gt;bool&lt;/code&gt; means testing for &lt;code&gt;0&lt;/code&gt; or &lt;code&gt;!=0&lt;/code&gt; for arithmetic types, and &lt;code&gt;null&lt;/code&gt; or &lt;code&gt;!=null&lt;/code&gt; for pointers or references.</source>
          <target state="translated">숫자 리터럴 &lt;code&gt;0&lt;/code&gt; 과 &lt;code&gt;1&lt;/code&gt; 은 각각 &lt;code&gt;bool&lt;/code&gt; 값 &lt;code&gt;false&lt;/code&gt; 및 &lt;code&gt;true&lt;/code&gt; 로 암시 적으로 변환 될 수 있습니다 . 식을 &lt;code&gt;bool&lt;/code&gt; 캐스팅 한다는 것은 산술 형식에 대해 &lt;code&gt;0&lt;/code&gt; 또는 &lt;code&gt;!=0&lt;/code&gt; 을 테스트 하고 포인터 또는 참조에 대해서는 &lt;code&gt;null&lt;/code&gt; 또는 &lt;code&gt;!=null&lt;/code&gt; 을 테스트하는 것을 의미 합니다.</target>
        </trans-unit>
        <trans-unit id="fe0da3c8ef7d3c766ce89becdf0b23671a0397f9" translate="yes" xml:space="preserve">
          <source>The numeric version number is also available &quot;in parts&quot; by using these constants</source>
          <target state="translated">이 상수를 사용하여 숫자 버전 번호를 &quot;부분적으로&quot;사용할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="126529265bda77a1ffa31840d1614e6dc6547606" translate="yes" xml:space="preserve">
          <source>The object to throw.</source>
          <target state="translated">던질 객체.</target>
        </trans-unit>
        <trans-unit id="917127d4e18a9f0f96c8fddb70a363dd7f1bb7b1" translate="yes" xml:space="preserve">
          <source>The object-oriented features of D all come from classes. The class hierarchy has as its root the class Object. Object defines a minimum level of functionality that each derived class has, and a default implementation for that functionality.</source>
          <target state="translated">D의 객체 지향 기능은 모두 클래스에서 비롯됩니다. 클래스 계층 구조는 그 루트가 Object 클래스입니다. Object는 각 파생 클래스가 갖는 최소 수준의 기능과 해당 기능에 대한 기본 구현을 정의합니다.</target>
        </trans-unit>
        <trans-unit id="83450785309cc6865682ad266cad8f967bd48d27" translate="yes" xml:space="preserve">
          <source>The old benchmarking functionality in std.datetime (which uses &lt;a href=&quot;core_time#TickDuration&quot;&gt;&lt;code&gt;core.time.TickDuration&lt;/code&gt;&lt;/a&gt;) has been deprecated. Use what's in std.datetime.stopwatch instead. It uses &lt;a href=&quot;core_time#MonoTime&quot;&gt;&lt;code&gt;core.time.MonoTime&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;core_time#Duration&quot;&gt;&lt;code&gt;core.time.Duration&lt;/code&gt;&lt;/a&gt;. Note that comparingBenchmark has not been ported over, because it's a trivial wrapper around benchmark. See &lt;a href=&quot;std_datetime_stopwatch#benchmark&quot;&gt;&lt;code&gt;std.datetime.stopwatch.benchmark&lt;/code&gt;&lt;/a&gt;. This symbol will be removed from the documentation in October 2018 and fully removed from Phobos in October 2019.</source>
          <target state="translated">std.datetime ( &lt;a href=&quot;core_time#TickDuration&quot;&gt; &lt;code&gt;core.time.TickDuration&lt;/code&gt; &lt;/a&gt; 사용 ) 의 이전 벤치마킹 기능은 더 이상 사용되지 않습니다. 대신 std.datetime.stopwatch에있는 것을 사용하십시오. &lt;a href=&quot;core_time#MonoTime&quot;&gt; &lt;code&gt;core.time.MonoTime&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;core_time#Duration&quot;&gt; &lt;code&gt;core.time.Duration&lt;/code&gt; 을&lt;/a&gt; 사용합니다 . 비교 벤치 마크는 벤치마킹에 대한 간단한 래퍼이기 때문에 포팅되지 않았습니다. &lt;a href=&quot;std_datetime_stopwatch#benchmark&quot;&gt; &lt;code&gt;std.datetime.stopwatch.benchmark&lt;/code&gt; 를&lt;/a&gt; 참조하십시오 . 이 기호는 2018 년 10 월 설명서에서 제거되고 2019 년 10 월 Phobos에서 완전히 제거됩니다.</target>
        </trans-unit>
        <trans-unit id="efeb1eab4dde5b659a31f85b9f2c2ca05099ac2d" translate="yes" xml:space="preserve">
          <source>The old benchmarking functionality in std.datetime (which uses &lt;a href=&quot;core_time#TickDuration&quot;&gt;&lt;code&gt;core.time.TickDuration&lt;/code&gt;&lt;/a&gt;) has been deprecated. Use what's in std.datetime.stopwatch instead. It uses &lt;a href=&quot;core_time#MonoTime&quot;&gt;&lt;code&gt;core.time.MonoTime&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;core_time#Duration&quot;&gt;&lt;code&gt;core.time.Duration&lt;/code&gt;&lt;/a&gt;. Note that measureTime has not been ported over, because it's a trivial wrapper around StopWatch. See &lt;a href=&quot;std_datetime_stopwatch#StopWatch&quot;&gt;&lt;code&gt;std.datetime.stopwatch.StopWatch&lt;/code&gt;&lt;/a&gt;. This symbol will be removed from the documentation in October 2018 and fully removed from Phobos in October 2019.</source>
          <target state="translated">std.datetime의 이전 벤치마킹 기능 ( &lt;a href=&quot;core_time#TickDuration&quot;&gt; &lt;code&gt;core.time.TickDuration&lt;/code&gt; &lt;/a&gt;)더 이상 사용되지 않습니다. 대신 std.datetime.stopwatch에있는 것을 사용하십시오.&lt;a href=&quot;core_time#MonoTime&quot;&gt; &lt;code&gt;core.time.MonoTime&lt;/code&gt; &lt;/a&gt; 및&lt;a href=&quot;core_time#Duration&quot;&gt; &lt;code&gt;core.time.Duration&lt;/code&gt; 을&lt;/a&gt; 사용합니다. measureTime은 StopWatch를 둘러싼 간단한 래퍼이기 때문에 포팅되지 않았습니다.&lt;a href=&quot;std_datetime_stopwatch#StopWatch&quot;&gt; &lt;code&gt;std.datetime.stopwatch.StopWatch&lt;/code&gt; 를&lt;/a&gt; 참조하십시오. 이 기호는 2018 년 10 월 설명서에서 제거되고 2019 년 10 월 Phobos에서 완전히 제거됩니다.</target>
        </trans-unit>
        <trans-unit id="8251e06b859fc1bf7834e47982a51786233d653a" translate="yes" xml:space="preserve">
          <source>The old benchmarking functionality in std.datetime (which uses &lt;a href=&quot;core_time#TickDuration&quot;&gt;&lt;code&gt;core.time.TickDuration&lt;/code&gt;&lt;/a&gt;) has been deprecated. Use what's in std.datetime.stopwatch instead. It uses &lt;a href=&quot;core_time#MonoTime&quot;&gt;&lt;code&gt;core.time.MonoTime&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;core_time#Duration&quot;&gt;&lt;code&gt;core.time.Duration&lt;/code&gt;&lt;/a&gt;. See &lt;a href=&quot;std_datetime_stopwatch#AutoStart&quot;&gt;&lt;code&gt;std.datetime.stopwatch.AutoStart&lt;/code&gt;&lt;/a&gt;. This symbol will be removed from the documentation in October 2018 and fully removed from Phobos in October 2019.</source>
          <target state="translated">std.datetime의 이전 벤치마킹 기능 ( &lt;a href=&quot;core_time#TickDuration&quot;&gt; &lt;code&gt;core.time.TickDuration&lt;/code&gt; &lt;/a&gt;)더 이상 사용되지 않습니다. 대신 std.datetime.stopwatch에있는 것을 사용하십시오.&lt;a href=&quot;core_time#MonoTime&quot;&gt; &lt;code&gt;core.time.MonoTime&lt;/code&gt; &lt;/a&gt; 및&lt;a href=&quot;core_time#Duration&quot;&gt; &lt;code&gt;core.time.Duration&lt;/code&gt; 을&lt;/a&gt; 사용합니다.&lt;a href=&quot;std_datetime_stopwatch#AutoStart&quot;&gt; &lt;code&gt;std.datetime.stopwatch.AutoStart&lt;/code&gt; 를&lt;/a&gt; 참조하십시오. 이 기호는 2018 년 10 월 설명서에서 제거되고 2019 년 10 월 Phobos에서 완전히 제거됩니다.</target>
        </trans-unit>
        <trans-unit id="3836851ebe09983822b4948475513fd0ffdb5b68" translate="yes" xml:space="preserve">
          <source>The old benchmarking functionality in std.datetime (which uses &lt;a href=&quot;core_time#TickDuration&quot;&gt;&lt;code&gt;core.time.TickDuration&lt;/code&gt;&lt;/a&gt;) has been deprecated. Use what's in std.datetime.stopwatch instead. It uses &lt;a href=&quot;core_time#MonoTime&quot;&gt;&lt;code&gt;core.time.MonoTime&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;core_time#Duration&quot;&gt;&lt;code&gt;core.time.Duration&lt;/code&gt;&lt;/a&gt;. See &lt;a href=&quot;std_datetime_stopwatch#StopWatch&quot;&gt;&lt;code&gt;std.datetime.stopwatch.StopWatch&lt;/code&gt;&lt;/a&gt;. This symbol will be removed from the documentation in October 2018 and fully removed from Phobos in October 2019.</source>
          <target state="translated">std.datetime의 이전 벤치마킹 기능 ( &lt;a href=&quot;core_time#TickDuration&quot;&gt; &lt;code&gt;core.time.TickDuration&lt;/code&gt; 을 사용함)&lt;/a&gt; ) 더 이상 사용되지 않습니다. 대신 std.datetime.stopwatch에있는 것을 사용하십시오. &lt;a href=&quot;core_time#MonoTime&quot;&gt; &lt;code&gt;core.time.MonoTime&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;core_time#Duration&quot;&gt; &lt;code&gt;core.time.Duration&lt;/code&gt; 을&lt;/a&gt; 사용합니다 . &lt;a href=&quot;std_datetime_stopwatch#StopWatch&quot;&gt; &lt;code&gt;std.datetime.stopwatch.StopWatch&lt;/code&gt; 를&lt;/a&gt; 참조하십시오 . 이 기호는 2018 년 10 월 설명서에서 제거되고 2019 년 10 월 Phobos에서 완전히 제거됩니다.</target>
        </trans-unit>
        <trans-unit id="852cd69a4d8476a6740350b9e4fa04e022f147f2" translate="yes" xml:space="preserve">
          <source>The old benchmarking functionality in std.datetime (which uses &lt;a href=&quot;core_time#TickDuration&quot;&gt;&lt;code&gt;core.time.TickDuration&lt;/code&gt;&lt;/a&gt;) has been deprecated. Use what's in std.datetime.stopwatch instead. It uses &lt;a href=&quot;core_time#MonoTime&quot;&gt;&lt;code&gt;core.time.MonoTime&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;core_time#Duration&quot;&gt;&lt;code&gt;core.time.Duration&lt;/code&gt;&lt;/a&gt;. See &lt;a href=&quot;std_datetime_stopwatch#benchmark&quot;&gt;&lt;code&gt;std.datetime.stopwatch.benchmark&lt;/code&gt;&lt;/a&gt;. This symbol will be removed from the documentation in October 2018 and fully removed from Phobos in October 2019.</source>
          <target state="translated">std.datetime ( &lt;a href=&quot;core_time#TickDuration&quot;&gt; &lt;code&gt;core.time.TickDuration&lt;/code&gt; &lt;/a&gt; 사용 ) 의 이전 벤치마킹 기능은 더 이상 사용되지 않습니다. 대신 std.datetime.stopwatch에있는 것을 사용하십시오. 사용합니다&lt;a href=&quot;core_time#MonoTime&quot;&gt; &lt;code&gt;core.time.MonoTime&lt;/code&gt; &lt;/a&gt; 및&lt;a href=&quot;core_time#Duration&quot;&gt; &lt;code&gt;core.time.Duration&lt;/code&gt; 을&lt;/a&gt;. &lt;a href=&quot;std_datetime_stopwatch#benchmark&quot;&gt; &lt;code&gt;std.datetime.stopwatch.benchmark&lt;/code&gt; 를&lt;/a&gt; 참조하십시오. 이 기호는 2018 년 10 월 설명서에서 제거되고 2019 년 10 월 Phobos에서 완전히 제거됩니다.</target>
        </trans-unit>
        <trans-unit id="e2b766119f4b2cc6bf40fa4a91668ec3bf749415" translate="yes" xml:space="preserve">
          <source>The one area in which this function violates RFC 5322 is that it accepts &lt;code&gt;&quot;\n&quot;&lt;/code&gt; in folding whitespace in the place of &lt;code&gt;&quot;\r\n&quot;&lt;/code&gt;, because the HTTP spec requires it.</source>
          <target state="translated">이 함수가 RFC 5322를 위반하는 한 가지 영역 은 HTTP 스펙에서 요구하기 때문에 &lt;code&gt;&quot;\r\n&quot;&lt;/code&gt; 대신 공백을 접는 경우 &lt;code&gt;&quot;\n&quot;&lt;/code&gt; 을 허용한다는 것입니다.</target>
        </trans-unit>
        <trans-unit id="1e2e3dd788c39da352fad71950c0b91387508356" translate="yes" xml:space="preserve">
          <source>The one shared instance.</source>
          <target state="translated">하나의 공유 인스턴스</target>
        </trans-unit>
        <trans-unit id="c72b10055e71a8b6b107b05c7231e9b97b023ff1" translate="yes" xml:space="preserve">
          <source>The only accepted units are &lt;code&gt;&quot;days&quot;&lt;/code&gt;.</source>
          <target state="translated">허용되는 단위는 &lt;code&gt;&quot;days&quot;&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="8437a6599312b98a4f8ede285a1950b78c0b6f0d" translate="yes" xml:space="preserve">
          <source>The only operators that can accept operands of type bool are: &lt;code&gt;&amp;amp;&lt;/code&gt;&lt;code&gt;|&lt;/code&gt;&lt;code&gt;^&lt;/code&gt;&lt;code&gt;&amp;amp;&lt;/code&gt;&lt;code&gt;=&lt;/code&gt;&lt;code&gt;|&lt;/code&gt;&lt;code&gt;=&lt;/code&gt;&lt;code&gt;^=&lt;/code&gt; ! &lt;code&gt;&amp;amp;&lt;/code&gt;&lt;code&gt;&amp;amp;&lt;/code&gt;&lt;code&gt;|&lt;/code&gt;&lt;code&gt;|&lt;/code&gt;&lt;code&gt;?:&lt;/code&gt;.</source>
          <target state="translated">bool 유형의 피연산자를 허용 할 수있는 유일한 연산자는 다음 &lt;code&gt;&amp;amp;&lt;/code&gt; 같습니다. &amp;amp; &lt;code&gt;|&lt;/code&gt; &lt;code&gt;^&lt;/code&gt; &lt;code&gt;&amp;amp;&lt;/code&gt; &lt;code&gt;=&lt;/code&gt; &lt;code&gt;|&lt;/code&gt; &lt;code&gt;=&lt;/code&gt; &lt;code&gt;^=&lt;/code&gt; ! &lt;code&gt;&amp;amp;&lt;/code&gt; &lt;code&gt;&amp;amp;&lt;/code&gt; &lt;code&gt;|&lt;/code&gt; &lt;code&gt;|&lt;/code&gt; &lt;code&gt;?:&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="984e1c71edfda04f82606405d232f57e26747587" translate="yes" xml:space="preserve">
          <source>The only reason to have a max limit for this is to avoid the risk of a bad server feeding libcurl with a never-ending header that will cause reallocs infinitely</source>
          <target state="translated">이것에 대한 최대 제한을 갖는 유일한 이유는 끝없는 헤더로 libcurl을 공급하는 나쁜 서버의 위험을 피하여 재 할당을 무한정 발생시키는 것입니다</target>
        </trans-unit>
        <trans-unit id="6b3469bf6885e1dc5e98c3245a18dbbf237d2baa" translate="yes" xml:space="preserve">
          <source>The opAssign function will be built for a struct &lt;code&gt;S&lt;/code&gt; if the following constraints are met:</source>
          <target state="translated">opAssign 함수는 구조체를 위해 만들어 질 것입니다 &lt;code&gt;S&lt;/code&gt; 다음 제약 조건이 충족되면 S에 .</target>
        </trans-unit>
        <trans-unit id="7e056906d7315529b66ec021904f0bc134465c13" translate="yes" xml:space="preserve">
          <source>The operand syntax more or less follows the Intel CPU documentation conventions. In particular, the convention is that for two operand instructions the source is the right operand and the destination is the left operand. The syntax differs from that of Intel's in order to be compatible with the D language tokenizer and to simplify parsing.</source>
          <target state="translated">피연산자 구문은 인텔 CPU 설명서 규칙을 어느 정도 따릅니다. 특히, 두 개의 피연산자 명령어의 경우 소스는 오른쪽 피연산자이고 대상은 왼쪽 피연산자입니다. 구문은 D 언어 토크 나이저와 호환되고 구문 분석을 단순화하기 위해 인텔의 구문과 다릅니다.</target>
        </trans-unit>
        <trans-unit id="73d4a21766587b932de571c9748f396e770947d7" translate="yes" xml:space="preserve">
          <source>The operands are AND'd together.</source>
          <target state="translated">피연산자는 함께 AND됩니다.</target>
        </trans-unit>
        <trans-unit id="8d68364ecd5a5efc98bbefe2167cf9e02f879955" translate="yes" xml:space="preserve">
          <source>The operands are OR'd together.</source>
          <target state="translated">피연산자는 함께 OR됩니다.</target>
        </trans-unit>
        <trans-unit id="164b0a5deb7171b65940816115319c8c761747b7" translate="yes" xml:space="preserve">
          <source>The operands are XOR'd together.</source>
          <target state="translated">피연산자는 함께 XOR됩니다.</target>
        </trans-unit>
        <trans-unit id="efb02cff4c27dc22b01308f5fbd88aaf28eb4b20" translate="yes" xml:space="preserve">
          <source>The operands must be arithmetic types. They undergo the &lt;a href=&quot;type#usual-arithmetic-conversions&quot;&gt;Usual Arithmetic Conversions&lt;/a&gt;.</source>
          <target state="translated">피연산자는 산술 유형이어야합니다. 그들은 &lt;a href=&quot;type#usual-arithmetic-conversions&quot;&gt;일상적인 산술 변환을&lt;/a&gt; 겪습니다 .</target>
        </trans-unit>
        <trans-unit id="1d66ba90561dbdef784a715ae4ab9b7cee0e0776" translate="yes" xml:space="preserve">
          <source>The operands must be integral types, and undergo the &lt;a href=&quot;type#integer-promotions&quot;&gt;Integer Promotions&lt;/a&gt;. The result type is the type of the left operand after the promotions. The result value is the result of shifting the bits by the right operand's value.</source>
          <target state="translated">피연산자는 정수 유형이어야하며 &lt;a href=&quot;type#integer-promotions&quot;&gt;정수 프로모션을&lt;/a&gt; 받아야합니다 . 결과 유형은 승격 후 왼쪽 피연산자의 유형입니다. 결과 값은 비트를 오른쪽 피연산자 값만큼 이동 한 결과입니다.</target>
        </trans-unit>
        <trans-unit id="194f20d5a432fe368709d99fb1ac7743c7e38bcc" translate="yes" xml:space="preserve">
          <source>The operation takes time proportional to the number of adjacent free blocks at the front of the free list. These blocks get coalesced, whether &lt;code&gt;allocateAll&lt;/code&gt; succeeds or fails due to fragmentation.</source>
          <target state="translated">작업은 사용 가능한 목록의 앞쪽에있는 인접한 사용 가능한 블록 수에 비례하여 시간이 걸립니다. 여부를이 블록은, 합체 얻을 &lt;code&gt;allocateAll&lt;/code&gt; 이 성공하거나 단편화로 인해 실패합니다.</target>
        </trans-unit>
        <trans-unit id="f1c4e404ec78b75726373485d13f7546b584f7c2" translate="yes" xml:space="preserve">
          <source>The operator involved</source>
          <target state="translated">관련된 운영자</target>
        </trans-unit>
        <trans-unit id="56d4f8f0aeb6a713fa59381e88345eb1ab065529" translate="yes" xml:space="preserve">
          <source>The operator involved (without the &lt;code&gt;&quot;=&quot;&lt;/code&gt;, e.g. &lt;code&gt;&quot;+&quot;&lt;/code&gt; for &lt;code&gt;&quot;+=&quot;&lt;/code&gt; etc)</source>
          <target state="translated">관련된 연산자 ( 예 : &lt;code&gt;&quot;+&quot;&lt;/code&gt; &lt;code&gt;&quot;=&quot;&lt;/code&gt; 없이 ( 예 : &lt;code&gt;&quot;+=&quot;&lt;/code&gt; 등의 경우 &quot;+&quot; ))</target>
        </trans-unit>
        <trans-unit id="141e2b7ce22914ac93e27f77aab194720297a6c0" translate="yes" xml:space="preserve">
          <source>The operator involved in the &lt;code&gt;opAssign&lt;/code&gt; operation</source>
          <target state="translated">&lt;code&gt;opAssign&lt;/code&gt; 작업에 관련된 연산자</target>
        </trans-unit>
        <trans-unit id="c70edf6dccf2f2bcea3add3cefb68aaf253c7966" translate="yes" xml:space="preserve">
          <source>The operator symbol</source>
          <target state="translated">연산자 기호</target>
        </trans-unit>
        <trans-unit id="a647036ebf74c7864e90900632a3906ffefe590e" translate="yes" xml:space="preserve">
          <source>The operator symbol (without the &lt;code&gt;=&lt;/code&gt;)</source>
          <target state="translated">연산자 기호 ( &lt;code&gt;=&lt;/code&gt; 제외)</target>
        </trans-unit>
        <trans-unit id="e53e52b5f08d1bbd687148f6992aae7c464c1b9d" translate="yes" xml:space="preserve">
          <source>The operator, e.g. &lt;code&gt;-&lt;/code&gt;</source>
          <target state="translated">연산자, 예 : &lt;code&gt;-&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="638907907a566c0abcca8d70105d1f419f1a935d" translate="yes" xml:space="preserve">
          <source>The option &quot;--Foo&quot; is rejected due to &lt;code&gt;std.getopt.config.caseSensitive&lt;/code&gt;, but not &quot;--Bar&quot;, &quot;--bAr&quot; etc. because the directive &lt;code&gt;std.getopt.config.caseInsensitive&lt;/code&gt; turned sensitivity off before option &quot;bar&quot; was parsed.</source>
          <target state="translated">옵션 &quot;--Foo은&quot;인해 거부 &lt;code&gt;std.getopt.config.caseSensitive&lt;/code&gt; 있지만 &quot;--Bar&quot;, &quot;--bAr&quot;등을 지시 때문에 &lt;code&gt;std.getopt.config.caseInsensitive&lt;/code&gt; 옵션 전에 떨어져 감도 설정 &quot; bar &quot;가 파싱되었습니다.</target>
        </trans-unit>
        <trans-unit id="ca52d0f89f2c76dbc26910f2e62e7d1ae6cb85b2" translate="yes" xml:space="preserve">
          <source>The option character (default '-').</source>
          <target state="translated">옵션 문자 (기본값 '-')</target>
        </trans-unit>
        <trans-unit id="18b9f1ce4c729b2ded7edcf5db48cd7ab36a842d" translate="yes" xml:space="preserve">
          <source>The optional</source>
          <target state="translated">옵션</target>
        </trans-unit>
        <trans-unit id="2c9d42a79cf23316432c06818064db7b0873ce86" translate="yes" xml:space="preserve">
          <source>The optional arguments &lt;code&gt;stdin&lt;/code&gt;, &lt;code&gt;stdout&lt;/code&gt; and &lt;code&gt;stderr&lt;/code&gt; may be used to assign arbitrary &lt;a href=&quot;std_stdio#File&quot;&gt;&lt;code&gt;std.stdio.File&lt;/code&gt;&lt;/a&gt; objects as the standard input, output and error streams, respectively, of the child process. The former must be opened for reading, while the latter two must be opened for writing. The default is for the child process to inherit the standard streams of its parent.</source>
          <target state="translated">선택적 인수 &lt;code&gt;stdin&lt;/code&gt; , &lt;code&gt;stdout&lt;/code&gt; 및 &lt;code&gt;stderr&lt;/code&gt; 을 사용하여 임의의 &lt;a href=&quot;std_stdio#File&quot;&gt; &lt;code&gt;std.stdio.File&lt;/code&gt; &lt;/a&gt; 을 지정할 수 있습니다. 오브젝트를 하위 프로세스의 표준 입력, 출력 및 오류 스트림으로 각각 . 전자는 읽기 위해 열어야하고, 후자는 쓰기 위해 열어야합니다. 디폴트는 자식 프로세스가 부모의 표준 스트림을 상속하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="fa35856038ac4a3b33d6b7f25cf0f4d58ca154fb" translate="yes" xml:space="preserve">
          <source>The optional identifier in either type of &lt;code&gt;out&lt;/code&gt; contract is set to the return value of the function.</source>
          <target state="translated">유형 중 하나의 옵션 식별자 &lt;code&gt;out&lt;/code&gt; 계약 함수의 리턴 값으로 설정된다.</target>
        </trans-unit>
        <trans-unit id="2a198d0d9bb81399553ce901d094fc3b34485c1e" translate="yes" xml:space="preserve">
          <source>The optional parameters &lt;code&gt;sSelfSim&lt;/code&gt; and &lt;code&gt;tSelfSim&lt;/code&gt; are meant for avoiding duplicate computation. Many applications may have already computed &lt;code&gt;gapWeightedSimilarity(s, s, lambda)&lt;/code&gt; and/or &lt;code&gt;gapWeightedSimilarity(t, t, lambda)&lt;/code&gt;. In that case, they can be passed as &lt;code&gt;sSelfSim&lt;/code&gt; and &lt;code&gt;tSelfSim&lt;/code&gt;, respectively.</source>
          <target state="translated">선택적 매개 변수 &lt;code&gt;sSelfSim&lt;/code&gt; 및 &lt;code&gt;tSelfSim&lt;/code&gt; 은 중복 계산을 피하기위한 것입니다. 많은 응용 프로그램에서 이미 &lt;code&gt;gapWeightedSimilarity(s, s, lambda)&lt;/code&gt; 및 / 또는 &lt;code&gt;gapWeightedSimilarity(t, t, lambda)&lt;/code&gt; 계산 했을 수 있습니다 . 이 경우 각각 &lt;code&gt;sSelfSim&lt;/code&gt; 및 &lt;code&gt;tSelfSim&lt;/code&gt; 으로 전달 될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="5c87a0f28ba13b43a3c29d6c4b297e44986adfc3" translate="yes" xml:space="preserve">
          <source>The optional second &lt;a href=&quot;expression#AssignExpression&quot;&gt;&lt;i&gt;AssignExpression&lt;/i&gt;&lt;/a&gt; can be used to supply additional information, such as a text string, that will be printed out along with the error diagnostic.</source>
          <target state="translated">선택적인 두 번째 &lt;a href=&quot;expression#AssignExpression&quot;&gt;&lt;i&gt;AssignExpression&lt;/i&gt;&lt;/a&gt; 을 사용하면 오류 진단과 함께 인쇄 될 텍스트 문자열과 같은 추가 정보를 제공 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c53af2790b7d2658a475ec200743c6decbbbabb1" translate="yes" xml:space="preserve">
          <source>The options &lt;code&gt;minSize == unbounded&lt;/code&gt; and &lt;code&gt;maxSize == unbounded&lt;/code&gt; are not available for &lt;code&gt;ContiguousFreeList&lt;/code&gt;.</source>
          <target state="translated">옵션 &lt;code&gt;minSize == unbounded&lt;/code&gt; 및 &lt;code&gt;maxSize == unbounded&lt;/code&gt; 사용할 수 없습니다 &lt;code&gt;ContiguousFreeList&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="908f73a8a6b26eae214ea14d01c95ac8e585a696" translate="yes" xml:space="preserve">
          <source>The options corresponding to the statistics collected.</source>
          <target state="translated">수집 된 통계에 해당하는 옵션입니다.</target>
        </trans-unit>
        <trans-unit id="9f44bfb42bea099b410e3ae043b64bf941a3d3a9" translate="yes" xml:space="preserve">
          <source>The order in which</source>
          <target state="translated">순서</target>
        </trans-unit>
        <trans-unit id="b05eb5dee9e8e5735c1321572abe7fba26d328c8" translate="yes" xml:space="preserve">
          <source>The order in which modules are called to run their unit tests.</source>
          <target state="translated">단위 테스트를 실행하기 위해 모듈을 호출하는 순서입니다.</target>
        </trans-unit>
        <trans-unit id="ded62be1138c956a50d03fffedad7ec44e6f9533" translate="yes" xml:space="preserve">
          <source>The order in which modules are imported does not affect the semantics.</source>
          <target state="translated">모듈을 가져 오는 순서는 의미에 영향을 미치지 않습니다.</target>
        </trans-unit>
        <trans-unit id="506073a2cdf721a37f43310020509dea0ea03bee" translate="yes" xml:space="preserve">
          <source>The order in which the array elements are computed is implementation defined, and may even occur in parallel. An application must not depend on this order.</source>
          <target state="translated">배열 요소가 계산되는 순서는 구현 정의이며 병렬로 발생할 수도 있습니다. 응용 프로그램은이 순서에 의존해서는 안됩니다.</target>
        </trans-unit>
        <trans-unit id="fae272dd73f8d57ce9c199e28861d6ffb1d9af6c" translate="yes" xml:space="preserve">
          <source>The order in which the strings appear in the result is not defined.</source>
          <target state="translated">문자열이 결과에 나타나는 순서는 정의되어 있지 않습니다.</target>
        </trans-unit>
        <trans-unit id="ce7e17de4cb24469d3444a40e36096efcb9cbfd4" translate="yes" xml:space="preserve">
          <source>The order is defined as follows:</source>
          <target state="translated">순서는 다음과 같이 정의됩니다.</target>
        </trans-unit>
        <trans-unit id="29a373653e2bfc1cca0d961f259da0c1298ecbea" translate="yes" xml:space="preserve">
          <source>The order of evaluation of function arguments for functions with linkage other than &lt;code&gt;extern (D)&lt;/code&gt;.</source>
          <target state="translated">이외의 기능과 연동 기능 인자 평가 순서 &lt;code&gt;extern (D)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a021fc1e222d6a27aea27e4b5f97128841b9a128" translate="yes" xml:space="preserve">
          <source>The order of evaluation of the operands of &lt;a href=&quot;#AssignExpression&quot;&gt;&lt;i&gt;AssignExpression&lt;/i&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#AssignExpression&quot;&gt;&lt;i&gt;AssignExpression&lt;/i&gt;&lt;/a&gt; 피연산자의 평가 순서입니다 .</target>
        </trans-unit>
        <trans-unit id="2d093662468f96c13ae9c5b9d6116c7cabff1635" translate="yes" xml:space="preserve">
          <source>The order of execution within a function is controlled by &lt;a href=&quot;#Statement&quot;&gt;&lt;i&gt;Statement&lt;/i&gt;&lt;/a&gt;s. A function's body consists of a sequence of zero or more</source>
          <target state="translated">함수 내에서의 실행 순서는 &lt;a href=&quot;#Statement&quot;&gt;&lt;i&gt;Statement에&lt;/i&gt;&lt;/a&gt; 의해 제어됩니다&lt;i&gt;&lt;/i&gt; . 함수의 본문은 0 이상의 시퀀스로 구성됩니다.</target>
        </trans-unit>
        <trans-unit id="86b67a2b0c6a048e601645470c096d4bbf2604b6" translate="yes" xml:space="preserve">
          <source>The order of static initialization is implicitly determined by the</source>
          <target state="translated">정적 초기화 순서는 다음과 같이 암시 적으로 결정됩니다.</target>
        </trans-unit>
        <trans-unit id="24e23dd7191b5b1c5bce0de2b67d0f3911ebed53" translate="yes" xml:space="preserve">
          <source>The ordering predicate to use to determine the extremum (minimum or maximum) element.</source>
          <target state="translated">극단 (최소 또는 최대) 요소를 판별하는 데 사용하는 순서 술어.</target>
        </trans-unit>
        <trans-unit id="15fe5b10e5755a86213c0dc1ab135ad913a77ba2" translate="yes" xml:space="preserve">
          <source>The ordering predicate to use to determine the extremum (minimum or maximum).</source>
          <target state="translated">극단 (최소 또는 최대)을 결정하는 데 사용하는 순서 술어.</target>
        </trans-unit>
        <trans-unit id="15cad23161bf9aec9c429568dd291ae988b53252" translate="yes" xml:space="preserve">
          <source>The ordering predicate to use to determine the maximum element.</source>
          <target state="translated">최대 요소를 결정하는 데 사용할 순서 술어.</target>
        </trans-unit>
        <trans-unit id="c31f591c19316494ae227e4269b1bc55d8071c12" translate="yes" xml:space="preserve">
          <source>The ordering predicate to use to determine the minimum element.</source>
          <target state="translated">최소 요소를 결정하는 데 사용할 순서 술어.</target>
        </trans-unit>
        <trans-unit id="c29760283ce7793aa4d7bc71616456fe1b03fbb5" translate="yes" xml:space="preserve">
          <source>The ordering to be used to determine lexicographical ordering of the permutations.</source>
          <target state="translated">순열의 사전 순서를 결정하는 데 사용되는 순서입니다.</target>
        </trans-unit>
        <trans-unit id="e1d7ba6a0bf70661c8825f1616095c8946712ba1" translate="yes" xml:space="preserve">
          <source>The original input string which should have been parsed.</source>
          <target state="translated">파싱해야 할 원래 입력 문자열입니다.</target>
        </trans-unit>
        <trans-unit id="d69e475dd9b96313d02abbca4307d1659af41d28" translate="yes" xml:space="preserve">
          <source>The original range.</source>
          <target state="translated">원래 범위.</target>
        </trans-unit>
        <trans-unit id="8724db772d60fec4013f34182f1e847ecec76068" translate="yes" xml:space="preserve">
          <source>The original string.</source>
          <target state="translated">원래 문자열.</target>
        </trans-unit>
        <trans-unit id="2c0e83de5dd344b677213345fa51e9db2eed3ab8" translate="yes" xml:space="preserve">
          <source>The other &lt;code&gt;ClockType&lt;/code&gt;s are provided so that other clocks provided by the underlying C, system calls can be used with &lt;a href=&quot;#MonoTimeImpl&quot;&gt;&lt;code&gt;MonoTimeImpl&lt;/code&gt;&lt;/a&gt; or &lt;code&gt;std.datetime.Clock.currTime&lt;/code&gt; without having to use the C API directly.</source>
          <target state="translated">다른 &lt;code&gt;ClockType&lt;/code&gt; 은 기본 C에서 제공하는 다른 시계가 제공되므로 C API를 직접 사용할 필요없이 시스템 호출을 &lt;a href=&quot;#MonoTimeImpl&quot;&gt; &lt;code&gt;MonoTimeImpl&lt;/code&gt; &lt;/a&gt; 또는 &lt;code&gt;std.datetime.Clock.currTime&lt;/code&gt; 과 함께 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="b74ff8ee45b0b8f3cea227a5cb8b0ca2512e0fa1" translate="yes" xml:space="preserve">
          <source>The output is:</source>
          <target state="translated">출력은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="a69373623c7518d00fa36ea24366f398f8ce8bad" translate="yes" xml:space="preserve">
          <source>The output of the code above is:</source>
          <target state="translated">위 코드의 결과는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="515b77d0f9f95e74d1d9b053ac5339be1c82aca5" translate="yes" xml:space="preserve">
          <source>The output range used to write the help information.</source>
          <target state="translated">도움말 정보를 작성하는 데 사용되는 출력 범위.</target>
        </trans-unit>
        <trans-unit id="708e6e32f4bb4d910b35568c24af1ecbdd8ae5b7" translate="yes" xml:space="preserve">
          <source>The overflow indicator (assigned &lt;code&gt;true&lt;/code&gt; in case there's an error)</source>
          <target state="translated">오버플로 표시기 ( 오류가있는 경우 &lt;code&gt;true&lt;/code&gt; 로 지정됨 )</target>
        </trans-unit>
        <trans-unit id="49d360d20fd79e75a1f6f41c1f5efdbc589a5b18" translate="yes" xml:space="preserve">
          <source>The overflow is sticky, meaning a sequence of operations can be done and overflow need only be checked at the end.</source>
          <target state="translated">오버플로는 고정적이므로 일련의 작업을 수행 할 수 있으며 오버플로는 끝에서만 확인하면됩니다.</target>
        </trans-unit>
        <trans-unit id="ef93ac8e948c5ada2f00084b4ec036473c66f367" translate="yes" xml:space="preserve">
          <source>The overlapping portion of the two arrays.</source>
          <target state="translated">두 배열의 겹치는 부분.</target>
        </trans-unit>
        <trans-unit id="fae150090ecb0366b43d58bfc4a6f3010da8d11c" translate="yes" xml:space="preserve">
          <source>The overload which accepts function arguments takes integral types in the order that the time unit strings were given, and those integers are passed by &lt;code&gt;ref&lt;/code&gt;. split assigns the values for the units to each corresponding integer. Any integral type may be used, but no attempt is made to prevent integer overflow, so don't use small integral types in circumstances where the values for those units aren't likely to fit in an integral type that small.</source>
          <target state="translated">함수 인수를 허용하는 오버로드에는 시간 단위 문자열이 제공된 순서대로 정수 유형이 사용되며 해당 정수는 &lt;code&gt;ref&lt;/code&gt; 로 전달됩니다 . split은 단위 값을 각 해당 정수에 할당합니다. 모든 정수 유형을 사용할 수 있지만 정수 오버플로를 방지하려는 시도는 없으므로 해당 단위의 값이 작은 정수 유형에 맞지 않는 상황에서는 작은 정수 유형을 사용하지 마십시오.</target>
        </trans-unit>
        <trans-unit id="8a27d36415963d11bb0a2a74d725380e58b5b81a" translate="yes" xml:space="preserve">
          <source>The overload with no arguments returns the values for the units in a struct with members whose names are the same as the given time unit strings. The members are all &lt;code&gt;long&lt;/code&gt;s. This overload will also work with no time strings being given, in which case</source>
          <target state="translated">인수가없는 오버로드는 주어진 시간 단위 문자열과 이름이 같은 멤버를 가진 구조체의 단위 값을 반환합니다. 멤버는 모두 &lt;code&gt;long&lt;/code&gt; . 이 오버로드는 시간 문자열이 제공되지 않은 상태에서도 작동합니다.</target>
        </trans-unit>
        <trans-unit id="260af145e3cbda28a26f16fe1989f4e1c8d1a0d0" translate="yes" xml:space="preserve">
          <source>The package module can then be imported with the standard module import declaration:</source>
          <target state="translated">그런 다음 표준 모듈 가져 오기 선언으로 패키지 모듈을 가져올 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5512330e5fcd74efc6dbc5aca616099f51685035" translate="yes" xml:space="preserve">
          <source>The package module must have the file name &lt;code&gt;package.d&lt;/code&gt;. The module name is declared to be the fully qualified name of the package. Package modules can be imported just like any other modules:</source>
          <target state="translated">패키지 모듈에는 파일 이름 &lt;code&gt;package.d&lt;/code&gt; 가 있어야합니다 . 모듈 이름은 패키지의 완전한 이름으로 선언됩니다. 패키지 모듈은 다른 모듈과 마찬가지로 가져올 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="136770d3c4f96881a7cd83ac52b3b200de071989" translate="yes" xml:space="preserve">
          <source>The padding data can be accessed, but its contents are undefined.</source>
          <target state="translated">패딩 데이터에 액세스 할 수 있지만 해당 내용은 정의되어 있지 않습니다.</target>
        </trans-unit>
        <trans-unit id="c23637ad29e92d690ee7e91ffa4bbac52dae1105" translate="yes" xml:space="preserve">
          <source>The parameter &lt;code&gt;level&lt;/code&gt; indicates the number of trie levels to use, allowed values are: 1, 2, 3 or 4. Levels represent different trade-offs speed-size wise.</source>
          <target state="translated">파라미터 &lt;code&gt;level&lt;/code&gt; 은 사용할 트리 레벨의 수를 나타내며 허용되는 값은 1, 2, 3 또는 4입니다. 레벨은 속도 크기에 따라 다른 절충점을 나타냅니다.</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
