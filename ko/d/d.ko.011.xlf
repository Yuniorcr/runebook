<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="d">
    <body>
      <group id="d">
        <trans-unit id="6eb83bdeacbc683c48cd46fa8c78709c87f5c6e7" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;int8&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;int8&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="0bc5c42eb664068361d3e2bbc2960242bd85d74b" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;keyword&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;keyword&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="3b9e4bd665940376fedb5c229b6879e66e25b129" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;kind&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;kind&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="39874f9381dfd5125b3dc75af7a4807bddc23602" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;lexical analysis&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;어휘 분석&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="60cb138dd66d9b1cea2cf1f5b4bd36ee7ac47180" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;libweb/client.d:&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;libweb/client.d:&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="75eebb7236eb3aa32c6dc795bfed2a8d86d951e3" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;libweb/package.d:&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;libweb/package.d:&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="56e429a57597934579d15405784f8b67f7cc03cd" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;libweb/server.d:&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;libweb/server.d:&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="17043ff939f0a4d5aa83327a00043cf0e170b24f" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;libweb/utils/package.d:&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;libweb/utils/package.d:&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="94101c8a81ea933dc5fe9c5f4fa029879581936c" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;locality&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;locality&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="79de8a252f3b8296225e83ed7108cd637d70a477" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;long2&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;long2&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="30347d665ca86f231e2df3cb086f8b88462effde" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;long4&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;long4&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="ddfb91165ad865d8237032c7afaf6d8ce0c7ac1c" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;n&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;n&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="1fee7dc0a20b6d874a56c2d0b86c4cc5d8b57ae4" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;num indices&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;숫자 인덱스&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="6496c7e7c4bec23654f7a5bb3df81748f05b7ca7" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;offset&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;offset&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="06bfb906e8762b446a59a8cbf8b2275f7051d05f" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;optimization&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;optimization&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="25b59a877580563a729d892f5a673eb16a77e781" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;property&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;property&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="6f5464b43bbaecac5c913e0786a739f28573a242" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;recOEM&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;recOEM&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="5cd2dc7ff7a80db85f72138e3cda8c958131fc1e" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;result&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;result&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="f34d5555301381a812b8cf40c1629a72d2b5a99b" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;rewrite 1&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;다시 쓰기 1&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="1b8d7df792dfa36a9ba8a406912753452f1b8759" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;rewrite 2&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;다시 쓰기 2&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="d01b17e5b387a974fb541eb4d6aee320bd90be5e" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;script line&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;스크립트 라인&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="1ec805147dbc1a6c96d4c4890d2a1d36e134d0c9" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;semantic analysis&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;시맨틱 분석&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="39185722ec687d6398c10760183f1a8a7c946c16" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;short16&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;short16&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="331218862d2c0cc4114357876e1c6aab4e7c97d2" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;short8&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;short8&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="19c7aa78c143d0cda3e321b08d3b851686f7c884" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;size&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;size&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="40c918b147d545d46767b6b640e40fe9e57ecb0e" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;source character set&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;소스 문자 세트&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="6df6bbab98fdd51b7b4d00b71d342406d5e8fe68" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;syntax analysis&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;구문 분석&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="f3c6733f39cdd7a9e8621428971a6e56e7acffa4" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;test.d:&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;test.d:&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="0d24e82b92b971a8bcc7f67b709d52e3453e1098" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;to&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;to&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="5baa61f483637ac5899c306b1f2cd344e3fb2e1d" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;transformation&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;transformation&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="ff1a31b0c2563249b2d8482a3b794f210b6e124d" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;type index&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;유형 색인&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="2ca9cdb144a3b03da7c2246df004461cf1a14926" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;ubyte16&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;ubyte16&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="42f7de6b8374369101f797a088885fff3c76c783" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;ubyte32&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;ubyte32&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="4f467489c4d041333165be8da10f1be6549a5f16" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;uint4&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;uint4&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="08863c66b1da554575c1c3284f58524b547459f8" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;uint8&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;uint8&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="a3606b1022fbd8c072a4e873fe9277c82347261d" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;ulong2&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;ulong2&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="1b18d2fb08ab825308c7b45488ab9efe0e32c3bc" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;ulong4&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;ulong4&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="e9b9b6937b917876163161b430b6959ac30267f3" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;ushort16&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;ushort16&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="c99bf9bca7e059672660f7e98cd1be42241f0514" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;ushort8&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;ushort8&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="61bacdf1f48f1d936407dc6074b0e45fc43810b2" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;void16&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;void16&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="a5422ec2a1c10c4479e71743298351157043d09a" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;void32&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;void32&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="c20077a29e599915f41b1e175f47e4fdb5d50ed4" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;writeFetch&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;writeFetch&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="08fbf87e0e966c600cff0671bfc78bc01d9cb068" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;&quot;cppRuntimeLibrary&quot;&lt;/code&gt; - The C++ runtime library affinity for this toolchain</source>
          <target state="translated">&lt;code&gt;&quot;cppRuntimeLibrary&quot;&lt;/code&gt; - The C++ runtime library affinity for this toolchain</target>
        </trans-unit>
        <trans-unit id="bd853af5509f93ff9e6a43dadc4835581d3279f6" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;&quot;floatAbi&quot;&lt;/code&gt; - Floating point ABI; may be &lt;code&gt;&quot;hard&quot;&lt;/code&gt;, &lt;code&gt;&quot;soft&quot;&lt;/code&gt;, or &lt;code&gt;&quot;softfp&quot;&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;&quot;floatAbi&quot;&lt;/code&gt; - Floating point ABI; may be &lt;code&gt;&quot;hard&quot;&lt;/code&gt;, &lt;code&gt;&quot;soft&quot;&lt;/code&gt;, or &lt;code&gt;&quot;softfp&quot;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="74851dd38fd93446fd7732603f0d38c8e0f7a0d9" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;&quot;nsecs&quot;&lt;/code&gt; is accepted by split, but &lt;code&gt;&quot;years&quot;&lt;/code&gt; and &lt;code&gt;&quot;months&quot;&lt;/code&gt; are not.</source>
          <target state="translated">&lt;code&gt;&quot;nsecs&quot;&lt;/code&gt; is accepted by split, but &lt;code&gt;&quot;years&quot;&lt;/code&gt; and &lt;code&gt;&quot;months&quot;&lt;/code&gt; are not.</target>
        </trans-unit>
        <trans-unit id="b8516c0d0a6ab337eb757368f9822bd55aaca147" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;&quot;nsecs&quot;&lt;/code&gt; is not considered a valid unit of time. Nothing in std.datetime can handle precision greater than hnsecs, and the few functions in core.time which deal with &quot;nsecs&quot; deal with it explicitly.</source>
          <target state="translated">&lt;code&gt;&quot;nsecs&quot;&lt;/code&gt; is not considered a valid unit of time. Nothing in std.datetime can handle precision greater than hnsecs, and the few functions in core.time which deal with &quot;nsecs&quot; deal with it explicitly.</target>
        </trans-unit>
        <trans-unit id="ae2740b26a8bc9a21a01bfad11940cfcc6533f5e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;&quot;objectFormat&quot;&lt;/code&gt; - Target object format</source>
          <target state="translated">&lt;code&gt;&quot;objectFormat&quot;&lt;/code&gt; - Target object format</target>
        </trans-unit>
        <trans-unit id="d1389937ce4aec811485a500d92bce3e9367a1e8" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;%&lt;/code&gt;&lt;code&gt;=&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;%&lt;/code&gt;&lt;code&gt;=&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="0e53a5b7ba9737cc3fe4ccfb3c80c0384c9c3177" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;&amp;amp;&lt;/code&gt;&lt;code&gt;=&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;&amp;amp;&lt;/code&gt;&lt;code&gt;=&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="3958503a584f5923c53a365e8416542c23f78839" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;&amp;amp;&lt;/code&gt;=</source>
          <target state="translated">&lt;code&gt;&amp;amp;&lt;/code&gt;=</target>
        </trans-unit>
        <trans-unit id="f398556003232e6b8c82be05607d67585d76b9cb" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;&amp;gt;&lt;/code&gt;&lt;code&gt;&amp;gt;&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;&amp;gt;&lt;/code&gt;&lt;code&gt;&amp;gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="54f8ced1abd619e968232335d212d3b4a5b3885a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;&amp;gt;&lt;/code&gt;&lt;code&gt;&amp;gt;&lt;/code&gt;&lt;code&gt;&amp;gt;&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;&amp;gt;&lt;/code&gt;&lt;code&gt;&amp;gt;&lt;/code&gt;&lt;code&gt;&amp;gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="b8ef2fda6bef4225fce98f2f1a768cb76822621a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;&amp;gt;&lt;/code&gt;&lt;code&gt;&amp;gt;&lt;/code&gt;&lt;code&gt;&amp;gt;&lt;/code&gt;&lt;code&gt;=&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;&amp;gt;&lt;/code&gt;&lt;code&gt;&amp;gt;&lt;/code&gt;&lt;code&gt;&amp;gt;&lt;/code&gt;&lt;code&gt;=&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="1407373b43004cda1d8c1d2aaf08f988c49587e3" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;&amp;gt;&lt;/code&gt;&lt;code&gt;&amp;gt;&lt;/code&gt;&lt;code&gt;=&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;&amp;gt;&lt;/code&gt;&lt;code&gt;&amp;gt;&lt;/code&gt;&lt;code&gt;=&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="dec18c41670087a443f485e56ddb67fcf7bb9225" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;&amp;lt; 0&lt;/code&gt; if &lt;code&gt;a &amp;lt; b&lt;/code&gt;, &lt;code&gt;0&lt;/code&gt; if &lt;code&gt;a == b&lt;/code&gt;, and &lt;code&gt;&amp;gt; 0&lt;/code&gt; if &lt;code&gt;a &amp;gt; b&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&amp;lt; 0&lt;/code&gt; if &lt;code&gt;a &amp;lt; b&lt;/code&gt;, &lt;code&gt;0&lt;/code&gt; if &lt;code&gt;a == b&lt;/code&gt;, and &lt;code&gt;&amp;gt; 0&lt;/code&gt; if &lt;code&gt;a &amp;gt; b&lt;/code&gt;.</target>
        </trans-unit>
        <trans-unit id="d960d71c8ad6cb23cf55077cd4184f48019c5533" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;&amp;lt; 0&lt;/code&gt; if &lt;code&gt;filename1 &amp;lt; filename2&lt;/code&gt;, &lt;code&gt;0&lt;/code&gt; if &lt;code&gt;filename1 == filename2&lt;/code&gt; and &lt;code&gt;&amp;gt; 0&lt;/code&gt; if &lt;code&gt;filename1 &amp;gt; filename2&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&amp;lt; 0&lt;/code&gt; if &lt;code&gt;filename1 &amp;lt; filename2&lt;/code&gt;, &lt;code&gt;0&lt;/code&gt; if &lt;code&gt;filename1 == filename2&lt;/code&gt; and &lt;code&gt;&amp;gt; 0&lt;/code&gt; if &lt;code&gt;filename1 &amp;gt; filename2&lt;/code&gt;.</target>
        </trans-unit>
        <trans-unit id="6087007a54c59e3a946fc72a09e238e44c46e800" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;&amp;lt;&lt;/code&gt;&lt;code&gt;&amp;lt;&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;&amp;lt;&lt;/code&gt;&lt;code&gt;&amp;lt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="8cf4f97182bd11f758e1c3d6be7426bf8fdfa094" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;&amp;lt;&lt;/code&gt;&lt;code&gt;&amp;lt;&lt;/code&gt; is a left shift. &lt;code&gt;&amp;gt;&lt;/code&gt;&lt;code&gt;&amp;gt;&lt;/code&gt; is a signed right shift. &lt;code&gt;&amp;gt;&lt;/code&gt;&lt;code&gt;&amp;gt;&lt;/code&gt;&lt;code&gt;&amp;gt;&lt;/code&gt; is an unsigned right shift.</source>
          <target state="translated">&lt;code&gt;&amp;lt;&lt;/code&gt;&lt;code&gt;&amp;lt;&lt;/code&gt; is a left shift. &lt;code&gt;&amp;gt;&lt;/code&gt;&lt;code&gt;&amp;gt;&lt;/code&gt; is a signed right shift. &lt;code&gt;&amp;gt;&lt;/code&gt;&lt;code&gt;&amp;gt;&lt;/code&gt;&lt;code&gt;&amp;gt;&lt;/code&gt; is an unsigned right shift.</target>
        </trans-unit>
        <trans-unit id="e7249a5c1a593b3ce165dd68eae0bb3425e21a3f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;&amp;lt;&lt;/code&gt;&lt;code&gt;&amp;lt;&lt;/code&gt;&lt;code&gt;=&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;&amp;lt;&lt;/code&gt;&lt;code&gt;&amp;lt;&lt;/code&gt;&lt;code&gt;=&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="3288fa6008c0378c34f18d5113fe9c3e8c6c76d1" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;&amp;lt;&lt;/code&gt;&lt;code&gt;=&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;&amp;lt;&lt;/code&gt;&lt;code&gt;=&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="122586fc5fa324741645aeef49e2bf8b3aaf2594" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;'\uFFFE'&lt;/code&gt; and &lt;code&gt;'\uFFFF'&lt;/code&gt; are considered valid by &lt;code&gt;isValidDchar&lt;/code&gt;, as they are permitted for internal use by an application, but they are not allowed for interchange by the Unicode standard.</source>
          <target state="translated">&lt;code&gt;'\uFFFE'&lt;/code&gt; and &lt;code&gt;'\uFFFF'&lt;/code&gt; are considered valid by &lt;code&gt;isValidDchar&lt;/code&gt;, as they are permitted for internal use by an application, but they are not allowed for interchange by the Unicode standard.</target>
        </trans-unit>
        <trans-unit id="f60e033c2072c35ccd5e717641020108f1c2041b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;(&lt;/code&gt;&lt;a href=&quot;lex#Identifier&quot;&gt;&lt;i&gt;Identifier&lt;/i&gt;&lt;/a&gt;&lt;code&gt;)&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;(&lt;/code&gt;&lt;a href=&quot;lex#Identifier&quot;&gt;&lt;i&gt;Identifier&lt;/i&gt;&lt;/a&gt;&lt;code&gt;)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="2a08cf564c650ee367e12a53c5693ab287b4205f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;(new A()).castSwitch((A a)=&amp;gt;1,(B b)=&amp;gt;2)&lt;/code&gt; returns &lt;code&gt;1&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;(new A()).castSwitch((A a)=&amp;gt;1,(B b)=&amp;gt;2)&lt;/code&gt; returns &lt;code&gt;1&lt;/code&gt;.</target>
        </trans-unit>
        <trans-unit id="5084a193ecf41e338c076c0c17db9011e1830d3f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;))&lt;/code&gt; fails to compile, the legacy rewrite &lt;code&gt;opSliceAssign(c,&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;))&lt;/code&gt; fails to compile, the legacy rewrite &lt;code&gt;opSliceAssign(c,&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="0837c7282cf26b93c696de19c537766158e0843c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;))&lt;/code&gt;, and &lt;code&gt;a[] = c&lt;/code&gt; as &lt;code&gt;a.opIndexAssign(c)&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;))&lt;/code&gt;, and &lt;code&gt;a[] = c&lt;/code&gt; as &lt;code&gt;a.opIndexAssign(c)&lt;/code&gt;.</target>
        </trans-unit>
        <trans-unit id="11e6e41966a2741f6eda239699f5a89fe68d2b17" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;)&lt;/code&gt; condition is satisfied when the debug identifier matches</source>
          <target state="translated">&lt;code&gt;)&lt;/code&gt; condition is satisfied when the debug identifier matches</target>
        </trans-unit>
        <trans-unit id="8fa45ebcfa13cbab71d496a27f9fbb9f9afcba8a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;)&lt;/code&gt; condition is satisfied when the debug level is &lt;code&gt;&amp;gt;=&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;)&lt;/code&gt; condition is satisfied when the debug level is &lt;code&gt;&amp;gt;=&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="aa4b0d2797ed2e918bd432feb2fcec6c9f3fb73f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;)&lt;/code&gt; creates C++ declarations that reside in C++ namespaces. The</source>
          <target state="translated">&lt;code&gt;)&lt;/code&gt; creates C++ declarations that reside in C++ namespaces. The</target>
        </trans-unit>
        <trans-unit id="9925093c94a8b2d6b68305707b4c9b14bbfe8a78" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;)&lt;/code&gt; is used instead.</source>
          <target state="translated">&lt;code&gt;)&lt;/code&gt; is used instead.</target>
        </trans-unit>
        <trans-unit id="f1b41032db3326fa1cb5496cde41eaf9cdb01448" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;)&lt;/code&gt; when applied to an lvalue.</source>
          <target state="translated">&lt;code&gt;)&lt;/code&gt; when applied to an lvalue.</target>
        </trans-unit>
        <trans-unit id="b1de402a83a45114ff0faf7e6d0aeedf6bbc5326" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;)&lt;/code&gt; with two arguments, respectively. This only applies for one-dimensional slicing, and dates from when D did not have full support for multidimensional arrays. This usage of &lt;code&gt;opSlice&lt;/code&gt; is discouraged.</source>
          <target state="translated">&lt;code&gt;)&lt;/code&gt; with two arguments, respectively. This only applies for one-dimensional slicing, and dates from when D did not have full support for multidimensional arrays. This usage of &lt;code&gt;opSlice&lt;/code&gt; is discouraged.</target>
        </trans-unit>
        <trans-unit id="206712b8f8db89befea06a21ffb6c96d5634437b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;**double asterisks**&lt;/code&gt; is rendered as &lt;strong&gt;double asterisks&lt;/strong&gt;.</source>
          <target state="translated">&lt;code&gt;**double asterisks**&lt;/code&gt; is rendered as &lt;strong&gt;double asterisks&lt;/strong&gt;.</target>
        </trans-unit>
        <trans-unit id="6185639dc48e1b078578c025762b660d95e30ad2" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;*single asterisks*&lt;/code&gt; is rendered as &lt;em&gt;single asterisks&lt;/em&gt;.</source>
          <target state="translated">&lt;code&gt;*single asterisks*&lt;/code&gt; is rendered as &lt;em&gt;single asterisks&lt;/em&gt;.</target>
        </trans-unit>
        <trans-unit id="a889907639d280d7bcce02cbbea7d7fae19a44f9" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;++&lt;/code&gt; and Postdecrement</source>
          <target state="translated">&lt;code&gt;++&lt;/code&gt; and Postdecrement</target>
        </trans-unit>
        <trans-unit id="e4b39a750f8d4f75d6b1d22cfdf811ebaf9481db" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;+1&lt;/code&gt; is the same as the value of the previous</source>
          <target state="translated">&lt;code&gt;+1&lt;/code&gt; is the same as the value of the previous</target>
        </trans-unit>
        <trans-unit id="94aeafa98cf3b84e505daf5f3afc0bc7809c2780" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;+1&lt;/code&gt;. If the value of the previous</source>
          <target state="translated">&lt;code&gt;+1&lt;/code&gt;. If the value of the previous</target>
        </trans-unit>
        <trans-unit id="e5d93e3086b69015c0f32e6de990de14dd909214" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;,&lt;/code&gt; ...&lt;code&gt;]&lt;/code&gt;, two steps are needed. First, the expressions of the form</source>
          <target state="translated">&lt;code&gt;,&lt;/code&gt; ...&lt;code&gt;]&lt;/code&gt;, two steps are needed. First, the expressions of the form</target>
        </trans-unit>
        <trans-unit id="ce47578d0683bbc3a7759581717d39518e3bd074" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;,&lt;/code&gt;&amp;hellip;&lt;code&gt;}&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;,&lt;/code&gt;&amp;hellip;&lt;code&gt;}&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="99588c23695c0ee55194ee8a309e79b3bf5cee4e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;,&lt;/code&gt;&lt;a href=&quot;template#TemplateParameterList&quot;&gt;&lt;i&gt;TemplateParameterList&lt;/i&gt;&lt;/a&gt;&lt;code&gt;)&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;,&lt;/code&gt;&lt;a href=&quot;template#TemplateParameterList&quot;&gt;&lt;i&gt;TemplateParameterList&lt;/i&gt;&lt;/a&gt;&lt;code&gt;)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="099853a8e9fedf93d291e0d176049a446c7c73d5" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;,&lt;/code&gt;&lt;a href=&quot;template#TemplateParameterList&quot;&gt;&lt;i&gt;TemplateParameterList&lt;/i&gt;&lt;/a&gt;&lt;code&gt;)&lt;/code&gt;  More complex types can be pattern matched; the &lt;a href=&quot;template#TemplateParameterList&quot;&gt;&lt;i&gt;TemplateParameterList&lt;/i&gt;&lt;/a&gt; declares symbols based on the parts of the pattern that are matched, analogously to the way implied template parameters are matched.</source>
          <target state="translated">&lt;code&gt;,&lt;/code&gt;&lt;a href=&quot;template#TemplateParameterList&quot;&gt;&lt;i&gt;TemplateParameterList&lt;/i&gt;&lt;/a&gt;&lt;code&gt;)&lt;/code&gt;  More complex types can be pattern matched; the &lt;a href=&quot;template#TemplateParameterList&quot;&gt;&lt;i&gt;TemplateParameterList&lt;/i&gt;&lt;/a&gt; declares symbols based on the parts of the pattern that are matched, analogously to the way implied template parameters are matched.</target>
        </trans-unit>
        <trans-unit id="7d285d5f941ddf4b338ad50a32ea2c0191fae56b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;--&lt;/code&gt; Operators</source>
          <target state="translated">&lt;code&gt;--&lt;/code&gt; Operators</target>
        </trans-unit>
        <trans-unit id="7bd2725afa85bcfddda64b0eb7c49fdbfb09a6b4" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;.alignof&lt;/code&gt; gives the aligned size of an expression or type. For example, an aligned size of 1 means that it is aligned on a byte boundary, 4 means it is aligned on a 32 bit boundary.</source>
          <target state="translated">&lt;code&gt;.alignof&lt;/code&gt; gives the aligned size of an expression or type. For example, an aligned size of 1 means that it is aligned on a byte boundary, 4 means it is aligned on a 32 bit boundary.</target>
        </trans-unit>
        <trans-unit id="e5196b62974b3d8f215e2d910f7f52f6922146ea" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;.classinfo&lt;/code&gt; applied to an interface gives the information for the interface, not the class it might be an instance of.</source>
          <target state="translated">&lt;code&gt;.classinfo&lt;/code&gt; applied to an interface gives the information for the interface, not the class it might be an instance of.</target>
        </trans-unit>
        <trans-unit id="63b0f429d2b2e3c16f17ed1cdb76e7cacdca4946" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;.classinfo&lt;/code&gt; provides information about the dynamic type of a class object. It returns a reference to type &lt;a href=&quot;https://dlang.org/phobos/object.html&quot;&gt;&lt;code&gt;object.TypeInfo_Class&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;.classinfo&lt;/code&gt; provides information about the dynamic type of a class object. It returns a reference to type &lt;a href=&quot;https://dlang.org/phobos/object.html&quot;&gt;&lt;code&gt;object.TypeInfo_Class&lt;/code&gt;&lt;/a&gt;.</target>
        </trans-unit>
        <trans-unit id="b456dd1c2f9c0d10f1789cad30a16c60fc51af38" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;.init&lt;/code&gt; produces a constant expression that is the default initializer. If applied to a type, it is the default initializer for that type. If applied to a variable or field, it is the default initializer for that variable or field's type.</source>
          <target state="translated">&lt;code&gt;.init&lt;/code&gt; produces a constant expression that is the default initializer. If applied to a type, it is the default initializer for that type. If applied to a variable or field, it is the default initializer for that variable or field's type.</target>
        </trans-unit>
        <trans-unit id="f56bc5ae2b4045d3d6ac97ffcf098f910b771e8e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;.sizeof&lt;/code&gt; applied to a class object returns the size of the class reference, not the class instantiation.</source>
          <target state="translated">&lt;code&gt;.sizeof&lt;/code&gt; applied to a class object returns the size of the class reference, not the class instantiation.</target>
        </trans-unit>
        <trans-unit id="56191db3ac0b73d97dbb68e4b586da74f6c27ddb" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;.stringof&lt;/code&gt; produces a constant string that is the source representation of its prefix. If applied to a type, it is the string for that type. If applied to an expression, it is the source representation of that expression. The expression will not be evaluated.</source>
          <target state="translated">&lt;code&gt;.stringof&lt;/code&gt; produces a constant string that is the source representation of its prefix. If applied to a type, it is the string for that type. If applied to an expression, it is the source representation of that expression. The expression will not be evaluated.</target>
        </trans-unit>
        <trans-unit id="32a0616dfbfe5a9ba4aea5d2a2f3d043257aeb30" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;0&lt;/code&gt; if &lt;code&gt;lhs&lt;/code&gt; is being shifted left by a negative value, or shifted right by a large positive value</source>
          <target state="translated">&lt;code&gt;0&lt;/code&gt; &lt;code&gt;lhs&lt;/code&gt; 가 음수 값만큼 왼쪽으로 이동하거나 큰 양수 값만큼 오른쪽으로 이동하는 경우 0</target>
        </trans-unit>
        <trans-unit id="cd0f13cb35b0f6cfcff43bbaff7453822c3899ae" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;0&lt;/code&gt; if the ranges compare equal. A negative value if &lt;code&gt;r1&lt;/code&gt; is a prefix of &lt;code&gt;r2&lt;/code&gt; or the first differing element of &lt;code&gt;r1&lt;/code&gt; is less than the corresponding element of &lt;code&gt;r2&lt;/code&gt; according to &lt;code&gt;pred&lt;/code&gt;. A positive value if &lt;code&gt;r2&lt;/code&gt; is a prefix of &lt;code&gt;r1&lt;/code&gt; or the first differing element of &lt;code&gt;r2&lt;/code&gt; is less than the corresponding element of &lt;code&gt;r1&lt;/code&gt; according to &lt;code&gt;pred&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;0&lt;/code&gt; 범위가 동일한 경우 0 입니다. &lt;code&gt;r1&lt;/code&gt; 이 &lt;code&gt;r2&lt;/code&gt; 의 접두사 이거나 &lt;code&gt;r1&lt;/code&gt; 의 첫 번째 다른 요소 가 &lt;code&gt;pred&lt;/code&gt; 에 따라 &lt;code&gt;r2&lt;/code&gt; 의 해당 요소보다 작은 경우 음수 값 입니다. &lt;code&gt;r2&lt;/code&gt; 가 &lt;code&gt;r1&lt;/code&gt; 의 접두사 이거나 &lt;code&gt;r2&lt;/code&gt; 의 첫 번째 다른 요소 가 &lt;code&gt;pred&lt;/code&gt; 에 따라 &lt;code&gt;r1&lt;/code&gt; 의 해당 요소보다 작은 경우 양수 값 입니다.</target>
        </trans-unit>
        <trans-unit id="f5fa0e4f4c4640464fdf6df63f5ca41e5095594b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;2.predSwitch(1, &quot;one&quot;, 2, &quot;two&quot;, 3, &quot;three&quot;)&lt;/code&gt; returns &lt;code&gt;&quot;two&quot;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;2.predSwitch(1, &quot;one&quot;, 2, &quot;two&quot;, 3, &quot;three&quot;)&lt;/code&gt; 는 &lt;code&gt;&quot;two&quot;&lt;/code&gt; 를 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="89e0c97d25cdfc5fbaa32647daa1dc8abaab5615" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;==&lt;/code&gt; and &lt;code&gt;!=&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;==&lt;/code&gt; and &lt;code&gt;!=&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="945e03d010c2450da457899882fa6887ba75a11f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;@disable&lt;/code&gt; Attribute</source>
          <target state="translated">&lt;code&gt;@disable&lt;/code&gt; Attribute</target>
        </trans-unit>
        <trans-unit id="668de6cdeed818fd05f519609a55e3f17f5419d9" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;@nogc&lt;/code&gt; Attribute</source>
          <target state="translated">&lt;code&gt;@nogc&lt;/code&gt; Attribute</target>
        </trans-unit>
        <trans-unit id="bbf50b7d4a9c14b6324016a55b2e05c9b2b3304e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;@nogc&lt;/code&gt; affects the type of the function. A &lt;code&gt;@nogc&lt;/code&gt; function is covariant with a non-&lt;code&gt;@nogc&lt;/code&gt; function.</source>
          <target state="translated">&lt;code&gt;@nogc&lt;/code&gt; affects the type of the function. A &lt;code&gt;@nogc&lt;/code&gt; function is covariant with a non-&lt;code&gt;@nogc&lt;/code&gt; function.</target>
        </trans-unit>
        <trans-unit id="35e398484da7da2b70be396e858ccb202fbfc291" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;@property&lt;/code&gt; Attribute</source>
          <target state="translated">&lt;code&gt;@property&lt;/code&gt; Attribute</target>
        </trans-unit>
        <trans-unit id="e9dda840d85606d23c926d0fc958fba3c05a42b4" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;@property&lt;/code&gt; are mangled differently, meaning that &lt;code&gt;@property&lt;/code&gt; must be consistently used across different compilation units.</source>
          <target state="translated">&lt;code&gt;@property&lt;/code&gt; are mangled differently, meaning that &lt;code&gt;@property&lt;/code&gt; must be consistently used across different compilation units.</target>
        </trans-unit>
        <trans-unit id="65432aebdccf8c92f41a4bc846f3193e0c1a00f7" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;@property&lt;/code&gt; functions can only have zero, one or two parameters.</source>
          <target state="translated">&lt;code&gt;@property&lt;/code&gt; functions can only have zero, one or two parameters.</target>
        </trans-unit>
        <trans-unit id="59321333ece34441ee987512696709e6c8398415" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;@property&lt;/code&gt; functions cannot be overloaded with non-&lt;code&gt;@property&lt;/code&gt; functions with the same name.</source>
          <target state="translated">&lt;code&gt;@property&lt;/code&gt; functions cannot be overloaded with non-&lt;code&gt;@property&lt;/code&gt; functions with the same name.</target>
        </trans-unit>
        <trans-unit id="1899b0354c680094e6ce0955a619b11401875aac" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;@property&lt;/code&gt; functions cannot have variadic parameters.</source>
          <target state="translated">&lt;code&gt;@property&lt;/code&gt; functions cannot have variadic parameters.</target>
        </trans-unit>
        <trans-unit id="76380ecaf01afb85f0044254a7d4b66358545c56" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;@safe&lt;/code&gt; functions have a number of restrictions on what they may do and are intended to disallow operations that may cause memory corruption. See &lt;a href=&quot;function#safe-functions&quot;&gt;&lt;code&gt;@safe&lt;/code&gt; functions&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;@safe&lt;/code&gt; functions have a number of restrictions on what they may do and are intended to disallow operations that may cause memory corruption. See &lt;a href=&quot;function#safe-functions&quot;&gt;&lt;code&gt;@safe&lt;/code&gt; functions&lt;/a&gt;.</target>
        </trans-unit>
        <trans-unit id="9256c91d32406bfdf38800a20bf913361e88031e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;@safe&lt;/code&gt;, &lt;code&gt;@trusted&lt;/code&gt;, and &lt;code&gt;@system&lt;/code&gt; Attribute</source>
          <target state="translated">&lt;code&gt;@safe&lt;/code&gt;, &lt;code&gt;@trusted&lt;/code&gt;, and &lt;code&gt;@system&lt;/code&gt; Attribute</target>
        </trans-unit>
        <trans-unit id="63252c0535bac17f08c817b75c5f13428fdb17d2" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;@system&lt;/code&gt; functions may perform any operation legal from the perspective of the language including inherently memory unsafe operations like returning pointers to expired stackframes. These functions may not be called directly from &lt;code&gt;@safe&lt;/code&gt; functions.</source>
          <target state="translated">&lt;code&gt;@system&lt;/code&gt; functions may perform any operation legal from the perspective of the language including inherently memory unsafe operations like returning pointers to expired stackframes. These functions may not be called directly from &lt;code&gt;@safe&lt;/code&gt; functions.</target>
        </trans-unit>
        <trans-unit id="1e802eb587afd93d2f6c4d83fb8f23730a64dd76" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;@trusted&lt;/code&gt; functions have all the capabilities of &lt;code&gt;@system&lt;/code&gt; functions but may be called from &lt;code&gt;@safe&lt;/code&gt; functions. For this reason they should be very limited in the scope of their use. Typical uses of &lt;code&gt;@trusted&lt;/code&gt; functions include wrapping system calls that take buffer pointer and length arguments separately so that @safe` functions may call them with arrays.</source>
          <target state="translated">&lt;code&gt;@trusted&lt;/code&gt; functions have all the capabilities of &lt;code&gt;@system&lt;/code&gt; functions but may be called from &lt;code&gt;@safe&lt;/code&gt; functions. For this reason they should be very limited in the scope of their use. Typical uses of &lt;code&gt;@trusted&lt;/code&gt; functions include wrapping system calls that take buffer pointer and length arguments separately so that @safe` functions may call them with arrays.</target>
        </trans-unit>
        <trans-unit id="7b7b2ec22a078014319be45b79df08258bb74f13" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;A.foo()&lt;/code&gt; and &lt;code&gt;A.foo(long)&lt;/code&gt; form an overload set. A different module can also define functions with the same name:</source>
          <target state="translated">&lt;code&gt;A.foo()&lt;/code&gt; 와 &lt;code&gt;A.foo(long)&lt;/code&gt; 는 과부하 세트를 형성합니다. 다른 모듈도 같은 이름으로 함수를 정의 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0494fa5e8697863931a268f56a7e313b15fa7bc6" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Address&lt;/code&gt; is an abstract class for representing a socket addresses.</source>
          <target state="translated">&lt;code&gt;Address&lt;/code&gt; 는 소켓 주소를 나타내는 추상 클래스입니다.</target>
        </trans-unit>
        <trans-unit id="63f8e6c905b185a2e61cdd95f261d361df08a36c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;AddressException&lt;/code&gt; on error, or &lt;code&gt;SocketFeatureException&lt;/code&gt; if host name lookup for this address family is not available on the current system.</source>
          <target state="translated">&lt;code&gt;AddressException&lt;/code&gt; 현재 시스템에서이 주소 패밀리에 대한 호스트 이름 검색을 사용할 수없는 경우 오류시 AddressException 또는 &lt;code&gt;SocketFeatureException&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="2f961238680f01eeda9c0208d72d9a727592f0e5" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;AddressException&lt;/code&gt; on error.</source>
          <target state="translated">&lt;code&gt;AddressException&lt;/code&gt; 에러시의 AddressException</target>
        </trans-unit>
        <trans-unit id="5ebe362c761732ab62a4361ba380d53bd21d7194" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;AddressException&lt;/code&gt; on failure, or &lt;code&gt;SocketFeatureException&lt;/code&gt; if address retrieval for this address family is not available on the current system.</source>
          <target state="translated">&lt;code&gt;AddressException&lt;/code&gt; 현재 시스템에서이 주소 계열에 대한 주소 검색을 사용할 수없는 경우 실패시 AddressException 또는 &lt;code&gt;SocketFeatureException&lt;/code&gt; 이 발생합니다.</target>
        </trans-unit>
        <trans-unit id="f40e1758855b4027e53355680b270fb2100d0ae4" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;AddressException&lt;/code&gt; on failure, or &lt;code&gt;SocketFeatureException&lt;/code&gt; if port number retrieval for this address family is not available on the current system.</source>
          <target state="translated">&lt;code&gt;AddressException&lt;/code&gt; 현재 시스템에서이 주소 계열의 포트 번호 검색을 사용할 수없는 경우 실패시 AddressException 또는 &lt;code&gt;SocketFeatureException&lt;/code&gt; 이 발생합니다.</target>
        </trans-unit>
        <trans-unit id="a0f47e28a240c095ac0652696954b5953fcbc0a3" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;AddressException&lt;/code&gt; on failure, or &lt;code&gt;SocketFeatureException&lt;/code&gt; if service name lookup for this address family is not available on the current system.</source>
          <target state="translated">&lt;code&gt;AddressException&lt;/code&gt; 현재 시스템에서이 주소 계열에 대한 서비스 이름 조회를 사용할 수없는 경우 실패시 AddressException 또는 &lt;code&gt;SocketFeatureException&lt;/code&gt; 이 발생합니다.</target>
        </trans-unit>
        <trans-unit id="b5828f821b8aea42c299b3e9109f069f9c37a828" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;AddressFamily&lt;/code&gt; - address family to filter by</source>
          <target state="translated">&lt;code&gt;AddressFamily&lt;/code&gt; - 필터링 할 주소 제품군</target>
        </trans-unit>
        <trans-unit id="64ad3aa38a4e1cf80b2339b1f85a40825b728d1b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;AddressInfoFlags&lt;/code&gt; - option flags</source>
          <target state="translated">&lt;code&gt;AddressInfoFlags&lt;/code&gt; - 옵션 플래그</target>
        </trans-unit>
        <trans-unit id="7dc4a85ea5727659d699df6d8c458e28309faed3" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;AlignedBlockList&lt;/code&gt; represents a wrapper around a chain of allocators, allowing for fast deallocations and preserving a low degree of fragmentation by means of aligned allocations.</source>
          <target state="translated">&lt;code&gt;AlignedBlockList&lt;/code&gt; 는 할당 자 체인 주위의 래퍼를 나타내므로 빠른 할당 해제를 허용하고 정렬 된 할당을 통해 낮은 수준의 조각화를 유지합니다.</target>
        </trans-unit>
        <trans-unit id="2aac4ff89a1251fffc9ea676fd3d3a75e327c061" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;AlignedBlockList&lt;/code&gt; represents a wrapper around a chain of allocators, allowing for fast deallocations and preserving a low degree of fragmentation. The allocator holds internally a doubly linked list of &lt;code&gt;Allocator&lt;/code&gt; objects, which will serve allocations in a most-recently-used fashion. Most recent allocators used for &lt;code&gt;allocate&lt;/code&gt; calls, will be moved to the front of the list.</source>
          <target state="translated">&lt;code&gt;AlignedBlockList&lt;/code&gt; 는 할당 기 체인 주위의 래퍼를 나타내므로 빠른 할당 해제를 허용하고 낮은 수준의 조각화를 유지합니다. 할당자는 내부적으로 이중으로 연결된 &lt;code&gt;Allocator&lt;/code&gt; 객체 목록을 보유 하며, 가장 많이 사용되는 방식으로 할당을 제공합니다. 통화 할당에 사용 &lt;code&gt;allocate&lt;/code&gt; 가장 최근 할당자는 목록의 맨 앞으로 이동합니다.</target>
        </trans-unit>
        <trans-unit id="13e555da2052e32dcab37e698e860002bf9cfb74" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;AllocFlag&lt;/code&gt; combination</source>
          <target state="translated">&lt;code&gt;AllocFlag&lt;/code&gt; 조합</target>
        </trans-unit>
        <trans-unit id="2d0e2d98007fbd8a78591eed210eee8ac8b3c6a7" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;AllocatorList&lt;/code&gt; is primarily intended for coarse-grained handling of allocators, i.e. the number of allocators in the list is expected to be relatively small compared to the number of allocations handled by each allocator. However, the per-allocator overhead is small so using &lt;code&gt;AllocatorList&lt;/code&gt; with a large number of allocators should be satisfactory as long as the most-recently-used strategy is fast enough for the application.</source>
          <target state="translated">&lt;code&gt;AllocatorList&lt;/code&gt; 는 기본적으로 할당자를 대략적으로 처리하기위한 것입니다. 즉, 목록의 할당 자 수는 각 할당자가 처리하는 할당 수에 비해 상대적으로 적을 것으로 예상됩니다. 그러나 할당 자당 오버 헤드가 작기 때문에 가장 많이 사용되는 전략이 응용 프로그램에 충분히 빠르면 할당 자 수가 많은 &lt;code&gt;AllocatorList&lt;/code&gt; 를 사용하는 것이 만족 스럽습니다.</target>
        </trans-unit>
        <trans-unit id="2a9263569f31d6f21ef7c6064d7d886d4088e71e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;AllocatorList&lt;/code&gt; makes an effort to return allocated memory back when no longer used. It does so by destroying empty allocators. However, in order to avoid thrashing (excessive creation/destruction of allocators under certain use patterns), it keeps unused allocators for a while.</source>
          <target state="translated">&lt;code&gt;AllocatorList&lt;/code&gt; 는 더 이상 사용되지 않을 때 할당 된 메모리를 다시 반환하려고합니다. 빈 할당자를 파괴하면됩니다. 그러나 스 래싱 (특정 사용 패턴에서 할당 자의 과도한 생성 / 파괴)을 피하기 위해 사용되지 않은 할당자를 잠시 동안 유지합니다.</target>
        </trans-unit>
        <trans-unit id="5d071eb9976a79b4a2500d3fbf6dab04761c67f6" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Args&lt;/code&gt; must not have unshared aliasing.</source>
          <target state="translated">&lt;code&gt;Args&lt;/code&gt; 는 비공유 별칭이 없어야합니다.</target>
        </trans-unit>
        <trans-unit id="3d6c9e4352fe5c3f5c6acaa10eb2b6833c10d2c0" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Array!bool&lt;/code&gt; packs together values efficiently by allocating one bit per element</source>
          <target state="translated">&lt;code&gt;Array!bool&lt;/code&gt; 은 요소 당 하나의 비트를 할당하여 효율적으로 값을 묶습니다.</target>
        </trans-unit>
        <trans-unit id="705c9b8cd80c0abcd241a8704a8e03e6c9084b57" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;AscendingPageAllocator&lt;/code&gt; is a fast and safe allocator that rounds all allocations to multiples of the system's page size. It reserves a range of virtual addresses (using &lt;code&gt;mmap&lt;/code&gt; on Posix and &lt;code&gt;VirtualAlloc&lt;/code&gt; on Windows) and allocates memory at consecutive virtual addresses.</source>
          <target state="translated">&lt;code&gt;AscendingPageAllocator&lt;/code&gt; 는 모든 할당을 시스템 페이지 크기의 배수로 반올림하는 빠르고 안전한 할당 자입니다. Posix에서 &lt;code&gt;mmap&lt;/code&gt; 을 사용 하고 Windows에서 &lt;code&gt;VirtualAlloc&lt;/code&gt; 을 사용하여 가상 주소 범위를 예약하고 연속 가상 주소에서 메모리를 할당합니다.</target>
        </trans-unit>
        <trans-unit id="04218a7012508fe4191b10a87336cc6b1273cc13" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;AssertError&lt;/code&gt; if the given &lt;code&gt;Throwable&lt;/code&gt; is not thrown.</source>
          <target state="translated">&lt;code&gt;AssertError&lt;/code&gt; 주어진 &lt;code&gt;Throwable&lt;/code&gt; 이 발생하지 않으면 AssertError 입니다.</target>
        </trans-unit>
        <trans-unit id="79a5a3ac59900685640330cfc081e2b319714288" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;AssertError&lt;/code&gt; if the given &lt;code&gt;Throwable&lt;/code&gt; is thrown.</source>
          <target state="translated">&lt;code&gt;AssertError&lt;/code&gt; 주어진 &lt;code&gt;Throwable&lt;/code&gt; 이 발생 하면 AssertError 입니다.</target>
        </trans-unit>
        <trans-unit id="48065955e3cbf0f918e5b84c93a8195ee5d56267" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;AssignExp&lt;/code&gt; or &lt;code&gt;CatAssignExp&lt;/code&gt; to check for any pointers to the stack</source>
          <target state="translated">&lt;code&gt;AssignExp&lt;/code&gt; 스택에 대한 포인터를 확인하기 위해 AssignExp 또는 &lt;code&gt;CatAssignExp&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="b546397158fafebfd9a66a9cae2f9c303cb63883" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;AutoImplement&lt;/code&gt; automatically implements (by default) all abstract member functions in the class or interface &lt;code&gt;Base&lt;/code&gt; in specified way.</source>
          <target state="translated">&lt;code&gt;AutoImplement&lt;/code&gt; (기본적으로) 자동으로 구현하는 클래스 또는 인터페이스의 모든 추상 멤버 함수 &lt;code&gt;Base&lt;/code&gt; 지정 방법이다.</target>
        </trans-unit>
        <trans-unit id="21bb1733c4ce14ff9de978726113c04a3401771e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Base64Exception&lt;/code&gt; If invoked when &lt;a href=&quot;#Base64Impl.Encoder.empty&quot;&gt;`empty`&lt;/a&gt; returns &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Base64Exception&lt;/code&gt; 경우 때 호출 &lt;a href=&quot;#Base64Impl.Encoder.empty&quot;&gt;empty`이`&lt;/a&gt; 반환 &lt;code&gt;true&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ebced38d3d013a303994fc7294831ec443f6b2c5" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Base64Exception&lt;/code&gt; If invoked when &lt;a href=&quot;#Base64Impl.Encoder.empty.2&quot;&gt;` empty`&lt;/a&gt; returns &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Base64Exception&lt;/code&gt; 경우 때 호출 &lt;a href=&quot;#Base64Impl.Encoder.empty.2&quot;&gt;empty`이`&lt;/a&gt; 반환 &lt;code&gt;true&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="500444657b554197a2e7e1e88e444620d4ec0295" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Base64Exception&lt;/code&gt; if invoked when &lt;a href=&quot;#Base64Impl.Decoder.empty&quot;&gt;` empty`&lt;/a&gt; returns &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Base64Exception&lt;/code&gt; 때 호출하면 &lt;a href=&quot;#Base64Impl.Decoder.empty&quot;&gt;`empty`의&lt;/a&gt; 반환 &lt;code&gt;true&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7cb7869f728c8d6d25945c2b87f5bcbca9b27844" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Base64Exception&lt;/code&gt; if source contains characters outside the base alphabet of the current Base64 encoding scheme.</source>
          <target state="translated">&lt;code&gt;Base64Exception&lt;/code&gt; source에 현재 Base64 인코딩 체계의 기본 알파벳 이외의 문자가 포함 된 경우.</target>
        </trans-unit>
        <trans-unit id="a386e95823d58783ccfcf9ed4858920237676d35" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;BinaryHeap&lt;/code&gt; implements the standard input range interface, allowing lazy iteration of the underlying range in descending order.</source>
          <target state="translated">&lt;code&gt;BinaryHeap&lt;/code&gt; 은 표준 입력 범위 인터페이스를 구현하여 내림차순으로 기본 범위의 지연 반복을 허용합니다.</target>
        </trans-unit>
        <trans-unit id="39e18f0659912331e89425afd9610294f5efef67" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;BitmappedBlock&lt;/code&gt; implements a simple heap consisting of one contiguous area of memory organized in blocks, each of size &lt;code&gt;theBlockSize&lt;/code&gt;. A block is a unit of allocation. A bitmap serves as bookkeeping data, more precisely one bit per block indicating whether that block is currently allocated or not.</source>
          <target state="translated">&lt;code&gt;BitmappedBlock&lt;/code&gt; 의 구현 블록 구성 메모리를 하나 개의 연속 영역 크기의 각 구성되는 간단한 힙 &lt;code&gt;theBlockSize&lt;/code&gt; . 블록은 할당 단위입니다. 비트 맵은 부기 데이터의 역할을하며, 블록 당 정확히 1 비트는 해당 블록이 현재 할당되어 있는지 여부를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="933f016b603e800d31983480a5c372706d49a5e2" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;BlackHole!Base&lt;/code&gt; is a subclass of &lt;code&gt;Base&lt;/code&gt; which automatically implements all abstract member functions in &lt;code&gt;Base&lt;/code&gt; as do-nothing functions. Each auto-implemented function just returns the default value of the return type without doing anything.</source>
          <target state="translated">&lt;code&gt;BlackHole!Base&lt;/code&gt; 의 서브 클래스입니다 &lt;code&gt;Base&lt;/code&gt; 자동으로 모든 추상 멤버 함수를 구현하는 &lt;code&gt;Base&lt;/code&gt; , 아무것도 실시하지 않는 기능을한다. 각 자동 구현 함수는 아무 것도 수행하지 않고 반환 유형의 기본값을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="43ce84cda21371df91482f18480d181e60b4d348" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;BoyerMooreFinder&lt;/code&gt; allocates GC memory.</source>
          <target state="translated">&lt;code&gt;BoyerMooreFinder&lt;/code&gt; 는 GC 메모리를 할당합니다.</target>
        </trans-unit>
        <trans-unit id="ad37dbabc0225dbe91d779a5c2478ebbe06c13bd" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Bucketizer&lt;/code&gt; holds a fixed-size array of allocators and dispatches calls to them appropriately. The size of the array is &lt;code&gt;(max + 1 - min) / step&lt;/code&gt;, which must be an exact division.</source>
          <target state="translated">&lt;code&gt;Bucketizer&lt;/code&gt; 는 고정 크기의 할당 자 배열을 보유하고 적절하게 호출을 발송합니다. 배열의 크기는 &lt;code&gt;(max + 1 - min) / step&lt;/code&gt; 이며 정확한 나눗셈이어야합니다.</target>
        </trans-unit>
        <trans-unit id="d7e5303aaec3d1918d07f980b6ff3c717de278f0" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Captures&lt;/code&gt; object contains submatches captured during a call to &lt;code&gt;match&lt;/code&gt; or iteration over &lt;code&gt;RegexMatch&lt;/code&gt; range.</source>
          <target state="translated">&lt;code&gt;Captures&lt;/code&gt; 개체에는 &lt;code&gt;RegexMatch&lt;/code&gt; 범위 에서 &lt;code&gt;match&lt;/code&gt; 또는 반복을 호출하는 동안 캡처 된 하위 일치 가 포함 됩니다.</target>
        </trans-unit>
        <trans-unit id="309893639b24ac675f2672438e92cfb6821b443e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;CheckFailure&lt;/code&gt; if the comparison is mathematically erroneous.</source>
          <target state="translated">&lt;code&gt;CheckFailure&lt;/code&gt; 비교가 수학적으로 잘못된 경우 실패를 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="ccdb30bb454730e08beb8407ef654f2c4fc02f5e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Checked&lt;/code&gt; has customizable behavior with the help of a second type parameter, &lt;code&gt;Hook&lt;/code&gt;. Depending on what methods &lt;code&gt;Hook&lt;/code&gt; defines, core operations on the underlying integral may be verified for overflow or completely redefined. If &lt;code&gt;Hook&lt;/code&gt; defines no method at all and carries no state, there is no change in behavior, i.e. &lt;code&gt;Checked!(int, void)&lt;/code&gt; is a wrapper around &lt;code&gt;int&lt;/code&gt; that adds no customization at all.</source>
          <target state="translated">&lt;code&gt;Checked&lt;/code&gt; 는 두 번째 유형 매개 변수 인 &lt;code&gt;Hook&lt;/code&gt; 를 사용하여 사용자 정의 가능한 동작을 갖습니다 . &lt;code&gt;Hook&lt;/code&gt; 정의한 방법 에 따라 기본 적분에 대한 핵심 작업이 오버플로되거나 완전히 재정의되었는지 확인할 수 있습니다. 경우 &lt;code&gt;Hook&lt;/code&gt; 전혀 메소드를 정의하지 않고 상태를 전달하지, 행동의 변화, 즉이없는 &lt;code&gt;Checked!(int, void)&lt;/code&gt; 래퍼되어 &lt;code&gt;int&lt;/code&gt; 전혀 정의를 추가하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="b33f2fe31af4e020ff9efa1c941efd75f784be56" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;ClockType.normal&lt;/code&gt;, &lt;code&gt;ClockType.coarse&lt;/code&gt;, and &lt;code&gt;ClockType.precise&lt;/code&gt; work with both &lt;code&gt;Clock.currTime&lt;/code&gt; and &lt;a href=&quot;#MonoTimeImpl&quot;&gt;&lt;code&gt;MonoTimeImpl&lt;/code&gt;&lt;/a&gt;. &lt;code&gt;ClockType.second&lt;/code&gt; only works with &lt;code&gt;Clock.currTime&lt;/code&gt;. The others only work with &lt;a href=&quot;#MonoTimeImpl&quot;&gt;&lt;code&gt;MonoTimeImpl&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;ClockType.normal&lt;/code&gt; , &lt;code&gt;ClockType.coarse&lt;/code&gt; 및 &lt;code&gt;ClockType.precise&lt;/code&gt; 는 &lt;code&gt;Clock.currTime&lt;/code&gt; 및 &lt;a href=&quot;#MonoTimeImpl&quot;&gt; &lt;code&gt;MonoTimeImpl&lt;/code&gt; &lt;/a&gt; 과 함께 작동 합니다. &lt;code&gt;ClockType.second&lt;/code&gt; 는 에서만 작동 &lt;code&gt;Clock.currTime&lt;/code&gt; . 다른 것들은 &lt;a href=&quot;#MonoTimeImpl&quot;&gt; &lt;code&gt;MonoTimeImpl&lt;/code&gt; &lt;/a&gt; 에서만 작동 합니다.</target>
        </trans-unit>
        <trans-unit id="3bd546dd377a5ca9a91504338ed3d12c7a06c162" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Complex&lt;/code&gt; instance with real and imaginary parts set to the values provided as input. If neither &lt;code&gt;re&lt;/code&gt; nor &lt;code&gt;im&lt;/code&gt; are floating-point numbers, the return type will be &lt;code&gt;Complex!double&lt;/code&gt;. Otherwise, the return type is deduced using &lt;code&gt;std.traits.CommonType!(R, I)&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Complex&lt;/code&gt; 실수 부와 허수 부가 입력으로 제공된 값으로 설정된 복잡한 인스턴스. &lt;code&gt;re&lt;/code&gt; 나 &lt;code&gt;im&lt;/code&gt; 이 부동 소수점 숫자가 아닌 경우 반환 유형은 &lt;code&gt;Complex!double&lt;/code&gt; 입니다. 그렇지 않으면, 리턴 유형은 &lt;code&gt;std.traits.CommonType!(R, I)&lt;/code&gt; 사용하여 추론됩니다 .</target>
        </trans-unit>
        <trans-unit id="4f1981cf0c5b9aacc8c3e1f9ea526f149b5b37a4" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;ConstRange&lt;/code&gt; is a variant with &lt;code&gt;const&lt;/code&gt; elements. &lt;code&gt;ImmutableRange&lt;/code&gt; is a variant with &lt;code&gt;immutable&lt;/code&gt; elements.</source>
          <target state="translated">&lt;code&gt;ConstRange&lt;/code&gt; 는 &lt;code&gt;const&lt;/code&gt; 요소 가있는 변형입니다 . &lt;code&gt;ImmutableRange&lt;/code&gt; 는 &lt;code&gt;immutable&lt;/code&gt; 요소 가있는 변형입니다 .</target>
        </trans-unit>
        <trans-unit id="9f0a285a64a257a738ddc8215c5d1f4b1ea5f630" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;ContiguousFreeList&lt;/code&gt; has most advantages of &lt;code&gt;FreeList&lt;/code&gt; but fewer disadvantages. It has better cache locality because items are closer to one another. It imposes less fragmentation on its parent allocator.</source>
          <target state="translated">&lt;code&gt;ContiguousFreeList&lt;/code&gt; &lt;code&gt;FreeList&lt;/code&gt; 는 FreeList의 장점이 가장 많지만 단점은 적습니다. 항목이 서로 가까이 있기 때문에 캐시 위치가 더 좋습니다. 부모 할당 자에 대한 조각화가 적습니다.</target>
        </trans-unit>
        <trans-unit id="5fdcd2f0664be754d421f0e8e94106531175532e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;CurlException&lt;/code&gt; on error.</source>
          <target state="translated">&lt;code&gt;CurlException&lt;/code&gt; 오류가 발생 하면 CurlException 이 발생합니다.</target>
        </trans-unit>
        <trans-unit id="c207e7eb5b1c2a73f8ac5ffe36b3bcc018bf05ce" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;DList&lt;/code&gt; uses reference semantics.</source>
          <target state="translated">&lt;code&gt;DList&lt;/code&gt; 는 참조 의미론을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="56d091bff1aace57a8798a77c763e1d6bc36b169" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Date&lt;/code&gt; uses the Proleptic Gregorian Calendar, so it assumes the Gregorian leap year calculations for its entire length. As per &lt;a href=&quot;http://en.wikipedia.org/wiki/ISO_8601&quot;&gt;ISO 8601&lt;/a&gt;, it treats 1 B.C. as year 0, i.e. 1 B.C. is 0, 2 B.C. is -1, etc. Use &lt;a href=&quot;#yearBC&quot;&gt;&lt;code&gt;yearBC&lt;/code&gt;&lt;/a&gt; to use B.C. as a positive integer with 1 B.C. being the year prior to 1 A.D.</source>
          <target state="translated">&lt;code&gt;Date&lt;/code&gt; 는 Proleptic Gregorian Calendar를 사용하므로 전체 길이에 대한 Gregorian 윤년 계산을 가정합니다. 당으로 &lt;a href=&quot;http://en.wikipedia.org/wiki/ISO_8601&quot;&gt;ISO 8601&lt;/a&gt; , 그것은 년 0으로 1 개 BC, 즉 (1 개) BC가 0을 취급, 2 BC은 -1 등 사용 &lt;a href=&quot;#yearBC&quot;&gt; &lt;code&gt;yearBC&lt;/code&gt; &lt;/a&gt; 양의 정수로 사용 BC 1 개 BC 이전 1 AD에 해를 인 상태</target>
        </trans-unit>
        <trans-unit id="7bfc68ccb2a4e22e418742b095af915878cf89fa" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;ErrnoException&lt;/code&gt; if the file could not be opened.</source>
          <target state="translated">&lt;code&gt;ErrnoException&lt;/code&gt; 파일을 열 수없는 경우</target>
        </trans-unit>
        <trans-unit id="493ee8438d3cfa33971d7dccea919872285bce11" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;ErrnoException&lt;/code&gt; if the file is not opened or if the call to &lt;code&gt;fwrite&lt;/code&gt; fails.</source>
          <target state="translated">&lt;code&gt;ErrnoException&lt;/code&gt; 파일이 열리지 않거나 &lt;code&gt;fwrite&lt;/code&gt; 호출에 실패한 경우</target>
        </trans-unit>
        <trans-unit id="07b5a06c5039124b8ad1df2dc89969b320d534d4" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;ErrnoException&lt;/code&gt; in case of error.</source>
          <target state="translated">&lt;code&gt;ErrnoException&lt;/code&gt; 오류가 발생 하면 ErrnoException 이 발생합니다.</target>
        </trans-unit>
        <trans-unit id="8b930e092cece6fadf6f6900420461e2d20e336e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;ErrnoException&lt;/code&gt; on error.</source>
          <target state="translated">&lt;code&gt;ErrnoException&lt;/code&gt; 오류가 발생 하면 ErrnoException 이 발생합니다.</target>
        </trans-unit>
        <trans-unit id="dd239e85060d6e26ab1980f40e672ff73bfb0858" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;ErrnoException&lt;/code&gt; on failure if closing the file.</source>
          <target state="translated">&lt;code&gt;ErrnoException&lt;/code&gt; 파일을 닫을 때 실패하면 ErrnoException 이 발생합니다.</target>
        </trans-unit>
        <trans-unit id="37e046750496d7d91c0e7d494f6853286088255f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Exception&lt;/code&gt; if &lt;code&gt;buffer&lt;/code&gt; is empty. &lt;code&gt;ErrnoException&lt;/code&gt; if the file is not opened or the call to &lt;code&gt;fread&lt;/code&gt; fails.  &lt;code&gt;rawRead&lt;/code&gt; always reads in binary mode on Windows.</source>
          <target state="translated">&lt;code&gt;Exception&lt;/code&gt; &lt;code&gt;buffer&lt;/code&gt; 가 비어있는 경우 는 예외 입니다. 파일이 열리지 않거나 &lt;code&gt;fread&lt;/code&gt; 호출이 실패하면 &lt;code&gt;ErrnoException&lt;/code&gt; 이 발생합니다. &lt;code&gt;rawRead&lt;/code&gt; 는 항상 Windows에서 이진 모드로 읽습니다.</target>
        </trans-unit>
        <trans-unit id="5357a482b6af648bdfdae7c4c52ac903a4330a1f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Exception&lt;/code&gt; if &lt;code&gt;r&lt;/code&gt; is empty</source>
          <target state="translated">&lt;code&gt;Exception&lt;/code&gt; &lt;code&gt;r&lt;/code&gt; 이 비어있는 경우 예외</target>
        </trans-unit>
        <trans-unit id="c39a22e167279d617a0fc36daa4eccdae4e0b8a0" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Exception&lt;/code&gt; if &lt;code&gt;r&lt;/code&gt; is not a range extracted from this array.</source>
          <target state="translated">&lt;code&gt;Exception&lt;/code&gt; &lt;code&gt;r&lt;/code&gt; 이이 배열에서 추출 된 범위가 아닌 경우 예외 입니다.</target>
        </trans-unit>
        <trans-unit id="2d3c1830fcba55441c8b8708ac54ee0a65f17621" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Exception&lt;/code&gt; if &lt;code&gt;r&lt;/code&gt; is not a valid range extracted from this array.</source>
          <target state="translated">&lt;code&gt;Exception&lt;/code&gt; &lt;code&gt;r&lt;/code&gt; 이이 배열에서 추출 된 유효한 범위가 아닌 경우 예외 입니다.</target>
        </trans-unit>
        <trans-unit id="6eea76a1ffc828fd53a324818d486f97cad280bd" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Exception&lt;/code&gt; if &lt;code&gt;range.empty&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Exception&lt;/code&gt; &lt;code&gt;range.empty&lt;/code&gt; 의 경우는 예외 입니다.</target>
        </trans-unit>
        <trans-unit id="9a3c6b353ef2f15072975ede8bc10964dd5ce9b9" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Exception&lt;/code&gt; if newlength is greater than the current array length.</source>
          <target state="translated">&lt;code&gt;Exception&lt;/code&gt; newlength가 현재 배열 길이보다 큰 경우 예외 입니다.</target>
        </trans-unit>
        <trans-unit id="5dfec39555f552ab3cc5ab1e7f2d9d9d48f01214" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Exception&lt;/code&gt; if the InputRange didn't provide enough elements to seed the generator. The number of elements required is the 'n' template parameter of the MersenneTwisterEngine struct.</source>
          <target state="translated">&lt;code&gt;Exception&lt;/code&gt; InputRange가 생성기를 시드하기에 충분한 요소를 제공하지 않은 경우 예외 입니다. 필요한 요소의 수는 MersenneTwisterEngine 구조체의 'n'템플릿 매개 변수입니다.</target>
        </trans-unit>
        <trans-unit id="865428949f240b5fee7e83d1edb9e3fe9d25cc8c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Exception&lt;/code&gt; if the array is empty.</source>
          <target state="translated">&lt;code&gt;Exception&lt;/code&gt; 배열이 비어 있으면 예외 입니다.</target>
        </trans-unit>
        <trans-unit id="24bffc299c874cdf767b7647906bba79e926a8eb" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Exception&lt;/code&gt; if the file is not opened or if the OS call fails.</source>
          <target state="translated">&lt;code&gt;Exception&lt;/code&gt; 파일이 열리지 않거나 OS 호출이 실패하면 예외 입니다.</target>
        </trans-unit>
        <trans-unit id="1425ed7cd12f20780c89a15069d569df2ac8153d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Exception&lt;/code&gt; if the file is not opened or if the call to &lt;code&gt;fflush&lt;/code&gt; fails.</source>
          <target state="translated">&lt;code&gt;Exception&lt;/code&gt; 파일이 열리지 않거나 &lt;code&gt;fflush&lt;/code&gt; 호출에 실패한 경우 예외 입니다.</target>
        </trans-unit>
        <trans-unit id="4d278807b320706797dc5f37c056c614e9ab56c0" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Exception&lt;/code&gt; if the file is not opened.</source>
          <target state="translated">&lt;code&gt;Exception&lt;/code&gt; 파일이 열리지 않은 경우 예외 입니다.</target>
        </trans-unit>
        <trans-unit id="12ff2eb3e485817238b511a24e61f4e5651047c1" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Exception&lt;/code&gt; if the file is not opened. &lt;code&gt;ErrnoException&lt;/code&gt; if the call to &lt;code&gt;fseek&lt;/code&gt; fails.</source>
          <target state="translated">&lt;code&gt;Exception&lt;/code&gt; 파일이 열리지 않은 경우 예외 입니다. &lt;code&gt;fseek&lt;/code&gt; 호출이 실패하면 &lt;code&gt;ErrnoException&lt;/code&gt; 이 발생합니다.</target>
        </trans-unit>
        <trans-unit id="92e2886b83c958de5c8cbfe39732479fc0881ca0" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Exception&lt;/code&gt; if the file is not opened. &lt;code&gt;ErrnoException&lt;/code&gt; if the call to &lt;code&gt;ftell&lt;/code&gt; fails.</source>
          <target state="translated">&lt;code&gt;Exception&lt;/code&gt; 파일이 열리지 않은 경우 예외 입니다. &lt;code&gt;ftell&lt;/code&gt; 호출이 실패하면 &lt;code&gt;ErrnoException&lt;/code&gt; 이 발생합니다.</target>
        </trans-unit>
        <trans-unit id="9c058e1025053f932c8cbe059de6e6a45a7ade6f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Exception&lt;/code&gt; if the file is not opened. &lt;code&gt;ErrnoException&lt;/code&gt; if the call to &lt;code&gt;setvbuf&lt;/code&gt; fails.</source>
          <target state="translated">&lt;code&gt;Exception&lt;/code&gt; 파일이 열리지 않은 경우 예외 입니다. &lt;code&gt;setvbuf&lt;/code&gt; 호출이 실패하면 &lt;code&gt;ErrnoException&lt;/code&gt; 이 발생합니다.</target>
        </trans-unit>
        <trans-unit id="9f59183ade2749bbcd85be7bdd7539cc2dde8f91" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Exception&lt;/code&gt; if the file is not opened. &lt;code&gt;ErrnoException&lt;/code&gt; on an error writing to the file.</source>
          <target state="translated">&lt;code&gt;Exception&lt;/code&gt; 파일이 열리지 않은 경우 예외 입니다. &lt;code&gt;ErrnoException&lt;/code&gt; 파일에 오류가 작성합니다.</target>
        </trans-unit>
        <trans-unit id="880297ec9e517b1658e861861ad15bb2e8e8065e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Exception&lt;/code&gt; if the format string is malformed. Also, throws &lt;code&gt;Exception&lt;/code&gt; if any of the lines in the file are not fully consumed by the call to &lt;a href=&quot;std_format#formattedRead&quot;&gt;&lt;code&gt;std.format.formattedRead&lt;/code&gt;&lt;/a&gt;. Meaning that no empty lines or lines with extra characters are allowed.</source>
          <target state="translated">&lt;code&gt;Exception&lt;/code&gt; 형식 문자열이 잘못된 경우 예외 입니다. 또한 파일의 행 중 하나라도 &lt;a href=&quot;std_format#formattedRead&quot;&gt; &lt;code&gt;std.format.formattedRead&lt;/code&gt; &lt;/a&gt; 호출로 완전히 소비되지 않으면 &lt;code&gt;Exception&lt;/code&gt; 발생합니다 . 빈 줄이나 추가 문자가있는 줄은 허용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="de0a5fbad1ac6efb5fd9baf8351d9afcefe62cb5" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Exception&lt;/code&gt; if the specified base directory is not absolute.</source>
          <target state="translated">&lt;code&gt;Exception&lt;/code&gt; 지정된 기본 디렉토리가 절대가 아닌 경우 예외 입니다.</target>
        </trans-unit>
        <trans-unit id="f6df157c4a7711890860c9639006d090861c8052" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Expression&lt;/code&gt; created, &lt;code&gt;null&lt;/code&gt; if cannot, &lt;code&gt;ErrorExp&lt;/code&gt; for other errors</source>
          <target state="translated">&lt;code&gt;Expression&lt;/code&gt; 생성 된 표현식 , 그렇지 않은 경우 &lt;code&gt;null&lt;/code&gt; , 다른 오류에 대한 &lt;code&gt;ErrorExp&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="ebd4302c37b74c7523edd170489c26935f44df7d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;F&lt;/code&gt; must not have any unshared aliasing as defined by &lt;a href=&quot;std_traits#hasUnsharedAliasing&quot;&gt;&lt;code&gt;std.traits.hasUnsharedAliasing&lt;/code&gt;&lt;/a&gt;. This means it may not be an unshared delegate or a non-shared class or struct with overloaded &lt;code&gt;opCall&lt;/code&gt;. This also precludes accepting template alias parameters.</source>
          <target state="translated">&lt;code&gt;F&lt;/code&gt; 는 &lt;a href=&quot;std_traits#hasUnsharedAliasing&quot;&gt; &lt;code&gt;std.traits.hasUnsharedAliasing&lt;/code&gt; 에&lt;/a&gt; 의해 정의 된 비공유 별칭을 가져서는 안됩니다 . 즉, 공유되지 않은 대리자 또는 공유되지 않은 클래스가 아니거나 &lt;code&gt;opCall&lt;/code&gt; 이 오버로드 된 구조체가 아닐 수 있습니다. 또한 템플릿 별칭 매개 변수를 허용하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="4417b447d6e34a9b6a9d00ab903bf61ae7b12316" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;FILETIME&lt;/code&gt;s are always in UTC.</source>
          <target state="translated">&lt;code&gt;FILETIME&lt;/code&gt; 은 항상 UTC입니다.</target>
        </trans-unit>
        <trans-unit id="9ad36e002f703b7a77a7d8759412e0073c140460" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;FTP&lt;/code&gt; struct for advanced usage</source>
          <target state="translated">&lt;code&gt;FTP&lt;/code&gt; 고급 사용을위한 FTP 구조체</target>
        </trans-unit>
        <trans-unit id="53f59d90a4d9a81fffddf93c0be659170d389f60" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;FallbackAllocator&lt;/code&gt; is the allocator equivalent of an &quot;or&quot; operator in algebra. An allocation request is first attempted with the &lt;code&gt;Primary&lt;/code&gt; allocator. If that returns &lt;code&gt;null&lt;/code&gt;, the request is forwarded to the &lt;code&gt;Fallback&lt;/code&gt; allocator. All other requests are dispatched appropriately to one of the two allocators.</source>
          <target state="translated">&lt;code&gt;FallbackAllocator&lt;/code&gt; 는 대수학에서 &quot;또는&quot;연산자에 해당하는 할당 자입니다. 1 &lt;code&gt;Primary&lt;/code&gt; 할당기로 할당 요청을 먼저 시도합니다 . 그것이 &lt;code&gt;null&lt;/code&gt; 을 반환 하면 요청은 &lt;code&gt;Fallback&lt;/code&gt; 할당 자 에게 전달됩니다 . 다른 모든 요청은 두 할당 자 중 하나에 적절하게 발송됩니다.</target>
        </trans-unit>
        <trans-unit id="30b00ee005e62aee06d690c21d13b91062908c24" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;FallbackAllocator&lt;/code&gt; is useful for fast, special-purpose allocators backed up by general-purpose allocators. The example below features a stack region backed up by the &lt;code&gt;GCAllocator&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;FallbackAllocator&lt;/code&gt; 는 범용 할당 자에 의해 백업되는 빠르고 특수한 할당 자에 유용합니다. 아래 예는 &lt;code&gt;GCAllocator&lt;/code&gt; 가 백업 한 스택 영역 입니다.</target>
        </trans-unit>
        <trans-unit id="12059211a1f2cd4c2168c76ad92a90e7719491a6" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;FallbackAllocator&lt;/code&gt; offers &lt;code&gt;alignedAllocate&lt;/code&gt; iff at least one of the allocators also offers it. It attempts to allocate using either or both.</source>
          <target state="translated">&lt;code&gt;FallbackAllocator&lt;/code&gt; 는 하나 이상의 할당자가 제공 할 경우 &lt;code&gt;alignedAllocate&lt;/code&gt; 된 할당을 제공합니다. 둘 중 하나 또는 둘 다를 사용하여 할당을 시도합니다.</target>
        </trans-unit>
        <trans-unit id="d37b29b23fa316d94fdcad5c8166e439cc28f457" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;FileException&lt;/code&gt; if it fails to read from disk.</source>
          <target state="translated">&lt;code&gt;FileException&lt;/code&gt; 디스크에서 읽을 수 없는 경우입니다.</target>
        </trans-unit>
        <trans-unit id="188634dda23bd46b447ec8ec1668b156fc7d14b0" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Final&lt;/code&gt; can also be used to create read-only data fields without using transitive immutability:</source>
          <target state="translated">&lt;code&gt;Final&lt;/code&gt; 은 또한 전이 불변성을 사용하지 않고 읽기 전용 데이터 필드를 만드는 데 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="889460128c963ae0b50d3b48964b85c59fa375e8" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Final&lt;/code&gt; can be used to create class references which cannot be rebound:</source>
          <target state="translated">&lt;code&gt;Final&lt;/code&gt; 은 리바운드 할 수없는 클래스 참조를 만드는 데 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="478f5e1ecc311901ec2b0e13063c90a9401676ec" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;FreeTree&lt;/code&gt; rounds up small allocations to at least &lt;code&gt;4 * size_t.sizeof&lt;/code&gt;, which on 64-bit system is one cache line size. If very small objects need to be efficiently allocated, the &lt;code&gt;FreeTree&lt;/code&gt; should be fronted with an appropriate small object allocator.</source>
          <target state="translated">&lt;code&gt;FreeTree&lt;/code&gt; 는 작은 할당을 최소 &lt;code&gt;4 * size_t.sizeof&lt;/code&gt; . 64 비트 시스템에서는 하나의 캐시 라인 크기입니다. 아주 작은 객체를 효율적으로 할당해야하는 경우 &lt;code&gt;FreeTree&lt;/code&gt; 앞에 적절한 작은 객체 할당 자가 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="d77d6371df752392d6a3dc05802d163d4563983a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;FuncDeclaration&lt;/code&gt; to mangle</source>
          <target state="translated">&lt;code&gt;FuncDeclaration&lt;/code&gt; 맹글에 대한 선언</target>
        </trans-unit>
        <trans-unit id="534218dc2a9eff64b3a6d0dd395079c920a853c3" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;GetLastError&lt;/code&gt;'s return value.</source>
          <target state="translated">&lt;code&gt;GetLastError&lt;/code&gt; 의 반환 값.</target>
        </trans-unit>
        <trans-unit id="fe0e872c807344ef938e77fe62dbcc2ee42252f1" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Grapheme&lt;/code&gt; has value semantics so 2 copies of a &lt;code&gt;Grapheme&lt;/code&gt; always refer to distinct objects. In most actual scenarios a &lt;code&gt;Grapheme&lt;/code&gt; fits on the stack and avoids memory allocation overhead for all but quite long clusters.</source>
          <target state="translated">&lt;code&gt;Grapheme&lt;/code&gt; 에는 값 의미가 있으므로 &lt;code&gt;Grapheme&lt;/code&gt; 의 사본 2 개는 항상 개별 객체를 참조합니다. 대부분의 실제 시나리오에서 &lt;code&gt;Grapheme&lt;/code&gt; 은 스택에 맞고 상당히 긴 클러스터에 대한 메모리 할당 오버 헤드를 피합니다.</target>
        </trans-unit>
        <trans-unit id="a47bfdb3d233e9007f4d4e19f342cf063fcacfb4" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;HTTP&lt;/code&gt; struct for advanced usage</source>
          <target state="translated">&lt;code&gt;HTTP&lt;/code&gt; 고급 사용을위한 HTTP 구조체</target>
        </trans-unit>
        <trans-unit id="283f10bc662194860ed924948e7ca2b00bc64cd8" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Hook&lt;/code&gt; member</source>
          <target state="translated">&lt;code&gt;Hook&lt;/code&gt; 멤버</target>
        </trans-unit>
        <trans-unit id="3528ef07a2db59ecdda7c525258080250b32a27c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Implementation Note:&lt;/code&gt; Compilers should attempt to detect array bounds errors at compile time, for example:</source>
          <target state="translated">&lt;code&gt;Implementation Note:&lt;/code&gt; 컴파일러는 컴파일 타임에 배열 범위 오류를 감지해야합니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="e55f857cc1242d132c8a00873c15908f891e0a9c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Implementation Note:&lt;/code&gt; The compiler should have a switch specifying if &lt;code&gt;deprecated&lt;/code&gt; should be ignored, cause a warning, or cause an error during compilation.</source>
          <target state="translated">&lt;code&gt;Implementation Note:&lt;/code&gt; 컴파일러에는 &lt;code&gt;deprecated&lt;/code&gt; 것을 무시하고, 경고를 발생 시키거나, 컴파일하는 동안 오류를 발생시키는 지 지정하는 스위치 가 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="561dda1be5a110b61fe901643d2776b6422899b1" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Implementation Note:&lt;/code&gt; The compiler's code generator may assume that the case statements are sorted by frequency of use, with the most frequent appearing first and the least frequent last. Although this is irrelevant as far as program correctness is concerned, it is of performance interest.</source>
          <target state="translated">&lt;code&gt;Implementation Note:&lt;/code&gt; 컴파일러의 코드 생성기는 사례 문이 사용 빈도에 따라 정렬되며 가장 빈번하게 나타나고 가장 빈번하게 나타나는 것으로 가정 할 수 있습니다. 프로그램 정확성에 관한 한 이것은 관련이 없지만 성능에 관심이 있습니다.</target>
        </trans-unit>
        <trans-unit id="450a1b223ad68d4502564215cf64c6560e8a199b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;InSituRegion&lt;/code&gt; is a convenient region that carries its storage within itself (in the form of a statically-sized array).</source>
          <target state="translated">&lt;code&gt;InSituRegion&lt;/code&gt; 은 자체 저장 공간 (정적 크기의 배열 형식)을 저장하는 편리한 영역입니다.</target>
        </trans-unit>
        <trans-unit id="72722ed0146cefed0b01dfb5c3c45d47c9f4bbfe" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Initializer&lt;/code&gt; AST node</source>
          <target state="translated">&lt;code&gt;Initializer&lt;/code&gt; AST 노드</target>
        </trans-unit>
        <trans-unit id="f7a41aecd6b56da1cad754e3be715002c57e3b64" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Initializer&lt;/code&gt; with completed semantic analysis, &lt;code&gt;ErrorInitializer&lt;/code&gt; if errors were encountered</source>
          <target state="translated">&lt;code&gt;Initializer&lt;/code&gt; 완료 의미 론적 분석, &lt;code&gt;ErrorInitializer&lt;/code&gt; 는 오류가 발생 된 경우</target>
        </trans-unit>
        <trans-unit id="f00d758a57b29aab9fb23c7584ece328b1a47384" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;InputRange&lt;/code&gt; of &lt;code&gt;ElementType&lt;/code&gt; implicitly convertible to &lt;code&gt;ubyte&lt;/code&gt;, &lt;code&gt;ubyte[]&lt;/code&gt; or &lt;code&gt;ubyte[num]&lt;/code&gt; or one or more arrays of any type.</source>
          <target state="translated">&lt;code&gt;InputRange&lt;/code&gt; &lt;code&gt;ElementType&lt;/code&gt; 의InputRange 는 암시 적으로 &lt;code&gt;ubyte&lt;/code&gt; , &lt;code&gt;ubyte[]&lt;/code&gt; 또는 &lt;code&gt;ubyte[num]&lt;/code&gt; 또는 모든 유형의 하나 이상의 배열로 변환 가능합니다.</target>
        </trans-unit>
        <trans-unit id="23ce00df7053058cd95cf5976c1008a23c0c4613" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Internet6Address&lt;/code&gt; encapsulates an IPv6 (Internet Protocol version 6) socket address.</source>
          <target state="translated">&lt;code&gt;Internet6Address&lt;/code&gt; 는 IPv6 (Internet Protocol version 6) 소켓 주소를 캡슐화합니다.</target>
        </trans-unit>
        <trans-unit id="929d7b4c4cc9a8637b6ae8f312d62876e111741b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;InternetAddress&lt;/code&gt; encapsulates an IPv4 (Internet Protocol version 4) socket address.</source>
          <target state="translated">&lt;code&gt;InternetAddress&lt;/code&gt; 는 IPv4 (Internet Protocol version 4) 소켓 주소를 캡슐화합니다.</target>
        </trans-unit>
        <trans-unit id="b4014cd878c2c4218d0565b355de1af14ef65088" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;InternetHost&lt;/code&gt; is a class for resolving IPv4 addresses.</source>
          <target state="translated">&lt;code&gt;InternetHost&lt;/code&gt; 는 IPv4 주소를 확인하는 클래스입니다.</target>
        </trans-unit>
        <trans-unit id="303b79b6697c06325ef20861d3893a0348a6c9bc" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;IntervalRange&lt;/code&gt; is only ever constructed by &lt;a href=&quot;#Interval&quot;&gt;&lt;code&gt;Interval&lt;/code&gt;&lt;/a&gt;. However, when it is constructed, it is given a function, &lt;code&gt;func&lt;/code&gt;, which is used to generate the time points which are iterated over. &lt;code&gt;func&lt;/code&gt; takes a time point and returns a time point of the same type. For instance, to iterate over all of the days in the interval &lt;code&gt;Interval!Date&lt;/code&gt;, pass a function to &lt;a href=&quot;#Interval&quot;&gt;&lt;code&gt;Interval&lt;/code&gt;&lt;/a&gt;'s &lt;code&gt;fwdRange&lt;/code&gt; where that function took a &lt;a href=&quot;std_datetime_date#Date&quot;&gt;&lt;code&gt;std.datetime.date.Date&lt;/code&gt;&lt;/a&gt; and returned a &lt;a href=&quot;std_datetime_date#Date&quot;&gt;&lt;code&gt;std.datetime.date.Date&lt;/code&gt;&lt;/a&gt; which was one day later. That function would then be used by &lt;code&gt;IntervalRange&lt;/code&gt;'s &lt;code&gt;popFront&lt;/code&gt; to iterate over the &lt;a href=&quot;std_datetime_date#Date&quot;&gt;&lt;code&gt;std.datetime.date.Date&lt;/code&gt;&lt;/a&gt;s in the interval.</source>
          <target state="translated">&lt;code&gt;IntervalRange&lt;/code&gt; 은 오직 의해 구성되어 &lt;a href=&quot;#Interval&quot;&gt; &lt;code&gt;Interval&lt;/code&gt; &lt;/a&gt; . 그러나 구성되면 반복되는 시점을 생성하는 데 사용되는 &lt;code&gt;func&lt;/code&gt; 함수가 제공 됩니다. &lt;code&gt;func&lt;/code&gt; 는 시점을 가져와 같은 유형의 시점을 반환합니다. 예를 들어, 간격에서 일의 모든 것을 반복하는 &lt;code&gt;Interval!Date&lt;/code&gt; 에 함수 통과 &lt;a href=&quot;#Interval&quot;&gt; &lt;code&gt;Interval&lt;/code&gt; &lt;/a&gt; 의 &lt;code&gt;fwdRange&lt;/code&gt; 을 그 함수가 어디로 데려 갔는지 &lt;a href=&quot;std_datetime_date#Date&quot;&gt; &lt;code&gt;std.datetime.date.Date&lt;/code&gt; 을&lt;/a&gt; a와 반환 &lt;a href=&quot;std_datetime_date#Date&quot;&gt; &lt;code&gt;std.datetime.date.Date&lt;/code&gt; &lt;/a&gt; 을했다 하루 후에. 그런 다음 &lt;code&gt;IntervalRange&lt;/code&gt; 의 &lt;code&gt;popFront&lt;/code&gt; 에서이 함수 를 사용하여&lt;a href=&quot;std_datetime_date#Date&quot;&gt; &lt;code&gt;std.datetime.date.Date&lt;/code&gt; &lt;/a&gt; 간격입니다.</target>
        </trans-unit>
        <trans-unit id="42f5f38819dff3129805052506f09ab99038900b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;InversionList&lt;/code&gt; is a set of &lt;a href=&quot;#Code%20point&quot;&gt;code points&lt;/a&gt; represented as an array of open-right [a, b) intervals (see &lt;a href=&quot;#CodepointInterval&quot;&gt;&lt;code&gt;CodepointInterval&lt;/code&gt;&lt;/a&gt; above). The name comes from the way the representation reads left to right. For instance a set of all values [10, 50), [80, 90), plus a singular value 60 looks like this:</source>
          <target state="translated">&lt;code&gt;InversionList&lt;/code&gt; 는 오른쪽 오른쪽 [a, b) 간격의 배열로 표시되는 &lt;a href=&quot;#Code%20point&quot;&gt;코드 포인트&lt;/a&gt; 세트입니다 ( 위의 &lt;a href=&quot;#CodepointInterval&quot;&gt; &lt;code&gt;CodepointInterval&lt;/code&gt; &lt;/a&gt; 참조). 이름은 왼쪽에서 오른쪽으로 읽는 방식에서 나옵니다. 예를 들어 모든 값 [10, 50), [80, 90)과 특이 값 60의 집합은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="37d4eb6c709e9700de66fdc10c8e540d20a7e4b1" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;JSONException&lt;/code&gt; for read access if &lt;code&gt;this.type&lt;/code&gt; is not &lt;code&gt;JSONType.true_&lt;/code&gt; or &lt;code&gt;JSONType.false_&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;JSONException&lt;/code&gt; 는 읽기 액세스를위한 경우 &lt;code&gt;this.type&lt;/code&gt; 은 아니다 &lt;code&gt;JSONType.true_&lt;/code&gt; 또는 &lt;code&gt;JSONType.false_&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0a9df16fb53d7d19ae3457b20afe88f508b70112" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;JSONException&lt;/code&gt; for read access if &lt;code&gt;type&lt;/code&gt; is not &lt;code&gt;JSONType.array&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;JSONException&lt;/code&gt; 읽기 액세스는 경우 &lt;code&gt;type&lt;/code&gt; 아니다 &lt;code&gt;JSONType.array&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="374fc56bce7b34d2d4fb37271f341137a55bd7f7" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;JSONException&lt;/code&gt; for read access if &lt;code&gt;type&lt;/code&gt; is not &lt;code&gt;JSONType.float_&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;JSONException&lt;/code&gt; 읽기 액세스는 경우 &lt;code&gt;type&lt;/code&gt; 아니다 &lt;code&gt;JSONType.float_&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d02dc7a78830e793dd620b25cd54dc82c0b138c3" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;JSONException&lt;/code&gt; for read access if &lt;code&gt;type&lt;/code&gt; is not &lt;code&gt;JSONType.integer&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;JSONException&lt;/code&gt; 읽기 액세스는 경우 &lt;code&gt;type&lt;/code&gt; 아니다 &lt;code&gt;JSONType.integer&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="28e63f5ce8b66a0b7464a33759d365eb7b21a25f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;JSONException&lt;/code&gt; for read access if &lt;code&gt;type&lt;/code&gt; is not &lt;code&gt;JSONType.object&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;JSONException&lt;/code&gt; 읽기 액세스는 경우 &lt;code&gt;type&lt;/code&gt; 아니다 &lt;code&gt;JSONType.object&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3d471f0121d68cc1a9cbef2f94fe907eced15162" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;JSONException&lt;/code&gt; for read access if &lt;code&gt;type&lt;/code&gt; is not &lt;code&gt;JSONType.string&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;JSONException&lt;/code&gt; 읽기 액세스는 경우 &lt;code&gt;type&lt;/code&gt; 아니다 &lt;code&gt;JSONType.string&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8b58c34a2444a67e9977423cf25f961b52bddb51" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;JSONException&lt;/code&gt; for read access if &lt;code&gt;type&lt;/code&gt; is not &lt;code&gt;JSONType.uinteger&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;JSONException&lt;/code&gt; 읽기 액세스는 경우 &lt;code&gt;type&lt;/code&gt; 아니다 &lt;code&gt;JSONType.uinteger&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="924a316d93ba1266b4a2524f7d5f0279e50f3486" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;JSONException&lt;/code&gt; if &lt;code&gt;type&lt;/code&gt; is not &lt;code&gt;JSONType.array&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;JSONException&lt;/code&gt; 는 경우 &lt;code&gt;type&lt;/code&gt; 아니다 &lt;code&gt;JSONType.array&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="288bfc2188bff0897b8c9f679a97e076b2f6137e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;JSONException&lt;/code&gt; if &lt;code&gt;type&lt;/code&gt; is not &lt;code&gt;JSONType.object&lt;/code&gt; or &lt;code&gt;JSONType.null_&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;JSONException&lt;/code&gt; 경우 &lt;code&gt;type&lt;/code&gt; 아니다 &lt;code&gt;JSONType.object&lt;/code&gt; 또는 &lt;code&gt;JSONType.null_&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f353747ce5b1603415e719ffa2e430d1926bd101" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;JSONException&lt;/code&gt; if &lt;code&gt;type&lt;/code&gt; is not &lt;code&gt;JSONType.object&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;JSONException&lt;/code&gt; 는 경우 &lt;code&gt;type&lt;/code&gt; 아니다 &lt;code&gt;JSONType.object&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9086cd140a77112c308b7aa75d5b636b32089093" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;JSONException&lt;/code&gt; if the right hand side argument &lt;code&gt;JSONType&lt;/code&gt; is not &lt;code&gt;object&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;JSONException&lt;/code&gt; 오른쪽 인수하는 경우 &lt;code&gt;JSONType&lt;/code&gt; 가 되지 않는 &lt;code&gt;object&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6bbca7de6c016dd7eb089e3687fc9b8bc4ab9f11" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;KRRegion&lt;/code&gt; = &lt;code&gt;Region&lt;/code&gt; + Kernighan-Ritchie Allocator</source>
          <target state="translated">&lt;code&gt;KRRegion&lt;/code&gt; &lt;code&gt;Region&lt;/code&gt; = 지역 + Kernighan-Ritchie Allocator</target>
        </trans-unit>
        <trans-unit id="f321db249483bbe4363807ada55b49818b58ef95" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;KRRegion&lt;/code&gt; draws inspiration from the &lt;a href=&quot;std_experimental_allocator_building_blocks_region&quot;&gt;region allocation strategy&lt;/a&gt; and also the &lt;a href=&quot;http://stackoverflow.com/questions/13159564/explain-this-implementation-of-malloc-from-the-kr-book&quot;&gt;famed allocator&lt;/a&gt; described by Brian Kernighan and Dennis Ritchie in section 8.7 of the book &lt;a href=&quot;http://amazon.com/exec/obidos/ASIN/0131103628/classicempire&quot;&gt;&quot;The C Programming Language&quot;&lt;/a&gt;, Second Edition, Prentice Hall, 1988.</source>
          <target state="translated">&lt;code&gt;KRRegion&lt;/code&gt; 은 &lt;a href=&quot;std_experimental_allocator_building_blocks_region&quot;&gt;지역 할당 전략&lt;/a&gt; 과 Brian Kernighan과 Dennis Ritchie가 1988 년 Prentice Hall 2 판의 &lt;a href=&quot;http://amazon.com/exec/obidos/ASIN/0131103628/classicempire&quot;&gt;&quot;C Programming Language&quot;&lt;/a&gt; 책 8.7에 설명 된 &lt;a href=&quot;http://stackoverflow.com/questions/13159564/explain-this-implementation-of-malloc-from-the-kr-book&quot;&gt;유명한 할당 자&lt;/a&gt; 로부터 영감을 얻습니다 .</target>
        </trans-unit>
        <trans-unit id="db7d6e394e1f58df812747633f0d7ada9be95b40" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;KRRegion&lt;/code&gt; is preferable to &lt;code&gt;Region&lt;/code&gt; as a front for a general-purpose allocator if &lt;code&gt;deallocate&lt;/code&gt; is needed, yet the actual deallocation traffic is relatively low. The example below shows a &lt;code&gt;KRRegion&lt;/code&gt; using stack storage fronting the GC allocator.</source>
          <target state="translated">&lt;code&gt;KRRegion&lt;/code&gt; 할당 &lt;code&gt;deallocate&lt;/code&gt; 가 필요한 경우 KRRegion 이 범용 할당 기의 앞쪽 으로 &lt;code&gt;Region&lt;/code&gt; 보다 선호 되지만 실제 할당 해제 트래픽은 상대적으로 적습니다. 아래 예 는 GC 할당 자 &lt;code&gt;KRRegion&lt;/code&gt; 스택 스토리지를 사용 하는 KRRegion 을 보여줍니다 .</target>
        </trans-unit>
        <trans-unit id="407854dafd56dc695bff6d9f8c5ac2000bd997b9" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;KeepTerminator&lt;/code&gt;&lt;code&gt;keepTerm&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;KeepTerminator&lt;/code&gt;&lt;code&gt;keepTerm&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="66af2d9115e5fccdf0825879dc694b6243dc0999" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;LINK&lt;/code&gt; to use for &lt;code&gt;extern(System)&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;LINK&lt;/code&gt; &lt;code&gt;extern(System)&lt;/code&gt; 에 사용하는 LINK</target>
        </trans-unit>
        <trans-unit id="eb1fb7a2d30c4bb9ff4f302703eea931bc144e7b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Lhs.max&lt;/code&gt; if &lt;code&gt;rhs &amp;gt;= 0&lt;/code&gt;, &lt;code&gt;Lhs.min&lt;/code&gt; otherwise.</source>
          <target state="translated">&lt;code&gt;Lhs.max&lt;/code&gt; 경우 &lt;code&gt;rhs &amp;gt;= 0&lt;/code&gt; , &lt;code&gt;Lhs.min&lt;/code&gt; 그렇지.</target>
        </trans-unit>
        <trans-unit id="9419d1db36082b226ab787fbc5117f1ef86ba81b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Lhs.max&lt;/code&gt; if the result overflows in the positive direction, on division by &lt;code&gt;0&lt;/code&gt;, or on shifting right by a negative value</source>
          <target state="translated">&lt;code&gt;Lhs.max&lt;/code&gt; 결과가 양의 방향으로 넘치 거나 &lt;code&gt;0&lt;/code&gt; 으로 나눈 값 또는 음의 값으로 오른쪽으로 이동할 때 Lhs.max</target>
        </trans-unit>
        <trans-unit id="9867d599d3360d2166c727451bf5ed485b43771d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Lhs.min&lt;/code&gt; if the result overflows in the negative direction</source>
          <target state="translated">&lt;code&gt;Lhs.min&lt;/code&gt; 결과가 음의 방향으로 넘치면 Lhs.min</target>
        </trans-unit>
        <trans-unit id="e1f2a80c67e78e54a24eb42ee38cb80badfaf8a9" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Loc&lt;/code&gt; of the expression triggering the access to &lt;code&gt;at&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;Loc&lt;/code&gt; 데이 에 대한 액세스 트리거 식의 &lt;code&gt;at&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="dae9c9a060f568e240a1c42e1af07db039cffb81" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;LogLevel&lt;/code&gt; for tracing the execution of the program.</source>
          <target state="translated">&lt;code&gt;LogLevel&lt;/code&gt; 프로그램 실행 추적을위한 LogLevel</target>
        </trans-unit>
        <trans-unit id="15d5c9fe039a45ff10bfb3fcf4c6a78d808c24c4" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;LogLevel&lt;/code&gt; to use for this &lt;code&gt;Logger&lt;/code&gt; instance.</source>
          <target state="translated">&lt;code&gt;LogLevel&lt;/code&gt; 이 &lt;code&gt;Logger&lt;/code&gt; 인스턴스 에 사용하는 LogLevel</target>
        </trans-unit>
        <trans-unit id="e1150e0e8c50b4644e9b3ad3ca52da419b7c609f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;MessageMismatch&lt;/code&gt; if a message of types other than &lt;code&gt;T&lt;/code&gt; is received.</source>
          <target state="translated">&lt;code&gt;MessageMismatch&lt;/code&gt; &lt;code&gt;T&lt;/code&gt; 이외의 유형의 메시지 가 수신 되면 MessageMismatch .</target>
        </trans-unit>
        <trans-unit id="65c7de08109ea54efe1649a109bfcb32d09b34bc" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;ModuleInfo&lt;/code&gt; is supported. Evaluates to &lt;code&gt;false&lt;/code&gt; when compiling with command line switch &lt;a href=&quot;https://dlang.org/dmd.html#switch-betterC&quot;&gt;&lt;em&gt;-betterC&lt;/em&gt;&lt;/a&gt;</source>
          <target state="translated">&lt;code&gt;ModuleInfo&lt;/code&gt; 가 지원됩니다. 평가 &lt;code&gt;false&lt;/code&gt; 명령 줄 스위치를 사용하여 컴파일 할 때 &lt;a href=&quot;https://dlang.org/dmd.html#switch-betterC&quot;&gt;&lt;em&gt;-betterC&lt;/em&gt;&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="88d77c659174b60bf4b59f2ff6bb6d3cc340de4e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;MurmurHash3!(128, 32)&lt;/code&gt; and &lt;code&gt;MurmurHash3!(128, 64)&lt;/code&gt; produce different values.</source>
          <target state="translated">&lt;code&gt;MurmurHash3!(128, 32)&lt;/code&gt; 및 &lt;code&gt;MurmurHash3!(128, 64)&lt;/code&gt; 는 다른 값을 생성합니다.</target>
        </trans-unit>
        <trans-unit id="52bcc9f7af8f6f12630050db8b23eb2e2e49e448" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;MurmurHash3!(128, 32)&lt;/code&gt; produces a 128-bit value and is optimized for 32-bit architectures</source>
          <target state="translated">&lt;code&gt;MurmurHash3!(128, 32)&lt;/code&gt; 는 128 비트 값을 생성하며 32 비트 아키텍처에 최적화되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="f32ddff3d6f4849c7478516798a4ac1b52282d34" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;MurmurHash3!(128, 64)&lt;/code&gt; produces a 128-bit value and is optimized for 64-bit architectures</source>
          <target state="translated">&lt;code&gt;MurmurHash3!(128, 64)&lt;/code&gt; 는 128 비트 값을 생성하며 64 비트 아키텍처에 최적화되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="0bd9dfe00b1b4ab2b4da44c82f7641cfaac9239b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;MurmurHash3!32&lt;/code&gt; produces a 32-bit value and is optimized for 32-bit architectures</source>
          <target state="translated">&lt;code&gt;MurmurHash3!32&lt;/code&gt; 는 32 비트 값을 생성하고 32 비트 아키텍처에 최적화되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="4474b7d5c23fed4796fe3c267e522c992cd94904" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Mutex.lock&lt;/code&gt; does not throw, but a class derived from Mutex can throw. Use &lt;code&gt;lock_nothrow&lt;/code&gt; in &lt;code&gt;nothrow @nogc&lt;/code&gt; code.</source>
          <target state="translated">&lt;code&gt;Mutex.lock&lt;/code&gt; 은 던지지 않지만 Mutex에서 파생 된 클래스는 던질 수 있습니다. &lt;code&gt;nothrow @nogc&lt;/code&gt; 코드 에서 &lt;code&gt;lock_nothrow&lt;/code&gt; 를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="19fbb5f989c0af04c8b083d15c647d76145e30b4" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Mutex.tryLock&lt;/code&gt; does not throw, but a class derived from Mutex can throw. Use &lt;code&gt;tryLock_nothrow&lt;/code&gt; in &lt;code&gt;nothrow @nogc&lt;/code&gt; code.</source>
          <target state="translated">&lt;code&gt;Mutex.tryLock&lt;/code&gt; 은 발생 하지 않지만 Mutex에서 파생 된 클래스는 발생 될 수 있습니다. &lt;code&gt;nothrow @nogc&lt;/code&gt; 코드 에서 &lt;code&gt;tryLock_nothrow&lt;/code&gt; 를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="7c0ef9f513fc9d530a91bc805078e6a6099ffd49" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Mutex.unlock&lt;/code&gt; does not throw, but a class derived from Mutex can throw. Use &lt;code&gt;unlock_nothrow&lt;/code&gt; in &lt;code&gt;nothrow @nogc&lt;/code&gt; code.</source>
          <target state="translated">&lt;code&gt;Mutex.unlock&lt;/code&gt; 은 던지지 않지만 Mutex에서 파생 된 클래스는 던질 수 있습니다. &lt;code&gt;nothrow @nogc&lt;/code&gt; 코드 에서 &lt;code&gt;unlock_nothrow&lt;/code&gt; 를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="0f1eca57de65dba2657112d5d3b43e02e51f2136" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;NegInfIntervalRange&lt;/code&gt; is only ever constructed by &lt;code&gt;NegInfInterval&lt;/code&gt;. However, when it is constructed, it is given a function, &lt;code&gt;func&lt;/code&gt;, which is used to generate the time points which are iterated over. &lt;code&gt;func&lt;/code&gt; takes a time point and returns a time point of the same type. For instance, to iterate over all of the days in the interval &lt;code&gt;NegInfInterval!Date&lt;/code&gt;, pass a function to &lt;code&gt;NegInfInterval&lt;/code&gt;'s &lt;code&gt;bwdRange&lt;/code&gt; where that function took a &lt;a href=&quot;std_datetime_date#Date&quot;&gt;&lt;code&gt;std.datetime.date.Date&lt;/code&gt;&lt;/a&gt; and returned a &lt;a href=&quot;std_datetime_date#Date&quot;&gt;&lt;code&gt;std.datetime.date.Date&lt;/code&gt;&lt;/a&gt; which was one day earlier. That function would then be used by &lt;code&gt;NegInfIntervalRange&lt;/code&gt;'s &lt;code&gt;popFront&lt;/code&gt; to iterate over the &lt;a href=&quot;std_datetime_date#Date&quot;&gt;&lt;code&gt;std.datetime.date.Date&lt;/code&gt;&lt;/a&gt;s in the interval - though obviously, since the range is infinite, use a function such as &lt;code&gt;std.range.take&lt;/code&gt; with it rather than iterating over</source>
          <target state="translated">&lt;code&gt;NegInfIntervalRange&lt;/code&gt; 은 오직 의해 구성되어 &lt;code&gt;NegInfInterval&lt;/code&gt; . 그러나 구성되면 반복되는 시점을 생성하는 데 사용되는 &lt;code&gt;func&lt;/code&gt; 함수가 제공 됩니다. &lt;code&gt;func&lt;/code&gt; 는 시점을 가져와 같은 유형의 시점을 반환합니다. 예를 들어, 간격의 일을 모두 반복하는 &lt;code&gt;NegInfInterval!Date&lt;/code&gt; 에 함수를 통과 &lt;code&gt;NegInfInterval&lt;/code&gt; 의 &lt;code&gt;bwdRange&lt;/code&gt; 그 함수가했다 &lt;a href=&quot;std_datetime_date#Date&quot;&gt; &lt;code&gt;std.datetime.date.Date&lt;/code&gt; 을&lt;/a&gt; 하고 돌아 &lt;a href=&quot;std_datetime_date#Date&quot;&gt; &lt;code&gt;std.datetime.date.Date&lt;/code&gt; &lt;/a&gt; 하나 전날. 이 함수는 &lt;code&gt;NegInfIntervalRange&lt;/code&gt; 의 &lt;code&gt;popFront&lt;/code&gt; 에 의해 사용됩니다간격에서 &lt;a href=&quot;std_datetime_date#Date&quot;&gt; &lt;code&gt;std.datetime.date.Date&lt;/code&gt; &lt;/a&gt; s 를 반복하려면 -범위는 무한 하기 때문에 반복하지 않고 &lt;code&gt;std.range.take&lt;/code&gt; 와 같은 함수를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="20f1388bdae9c724328768c67e2bf74ccf100c75" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Note:&lt;/code&gt; If a finally clause executes a throw out of the finally clause, the break target is never reached.</source>
          <target state="translated">&lt;code&gt;Note:&lt;/code&gt; finally 절이 finally 절에서 throw를 실행하면 중단 대상에 도달하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="c45e10577dee6f4cb71de927dc8836b2f1ac9a27" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Note:&lt;/code&gt; If a finally clause executes a throw out of the finally clause, the continue target is never reached.</source>
          <target state="translated">&lt;code&gt;Note:&lt;/code&gt; finally 절이 finally 절에서 throw를 실행하면 continue 대상에 도달하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="21edd622bef9e1c578cfde461f5374945dff73cf" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;NullAllocator&lt;/code&gt; advertises a relatively large alignment equal to 64 KB. This is because &lt;code&gt;NullAllocator&lt;/code&gt; never actually needs to honor this alignment and because composite allocators using &lt;code&gt;NullAllocator&lt;/code&gt; shouldn't be unnecessarily constrained.</source>
          <target state="translated">&lt;code&gt;NullAllocator&lt;/code&gt; 는 64KB에 해당 하는 비교적 큰 정렬을 알립니다 . &lt;code&gt;NullAllocator&lt;/code&gt; 가 실제로이 정렬을 &lt;code&gt;NullAllocator&lt;/code&gt; 할 필요가없고 NullAllocator 를 사용하는 복합 할당 자가 불필요하게 제한 되어서 는 안되기 때문 입니다.</target>
        </trans-unit>
        <trans-unit id="fde2a7522ff25f76c62d43d840e184a9693bf37b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;NullAllocator&lt;/code&gt; is an emphatically empty implementation of the allocator interface. Although it has no direct use, it is useful as a &quot;terminator&quot; in composite allocators.</source>
          <target state="translated">&lt;code&gt;NullAllocator&lt;/code&gt; 는 할당 자 인터페이스의 빈 구현입니다. 직접 사용하지는 않지만 복합 할당 기에서 &quot;터미네이터&quot;로 유용합니다.</target>
        </trans-unit>
        <trans-unit id="26af361fb937ce89c2ffa3c9c2d6a1257d185c4b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;OutBuffer&lt;/code&gt; to write the mangled function signature to</source>
          <target state="translated">&lt;code&gt;OutBuffer&lt;/code&gt; 맹 글링 된 함수 서명을 쓰는 OutBuffer</target>
        </trans-unit>
        <trans-unit id="3fe9a99db1ee4d687b3f8bd5d0c960a952d9bdc4" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;OutOfMemoryError&lt;/code&gt; on allocation failure.</source>
          <target state="translated">&lt;code&gt;OutOfMemoryError&lt;/code&gt; 할당 실패시 OutOfMemoryError .</target>
        </trans-unit>
        <trans-unit id="d50b7d457eec0ba1f8877d663f932cf82639bd11" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;PosInfIntervalRange&lt;/code&gt; is only ever constructed by &lt;code&gt;PosInfInterval&lt;/code&gt;. However, when it is constructed, it is given a function, &lt;code&gt;func&lt;/code&gt;, which is used to generate the time points which are iterated over. &lt;code&gt;func&lt;/code&gt; takes a time point and returns a time point of the same type. For instance, to iterate over all of the days in the interval &lt;code&gt;PosInfInterval!Date&lt;/code&gt;, pass a function to &lt;code&gt;PosInfInterval&lt;/code&gt;'s &lt;code&gt;fwdRange&lt;/code&gt; where that function took a &lt;a href=&quot;std_datetime_date#Date&quot;&gt;&lt;code&gt;std.datetime.date.Date&lt;/code&gt;&lt;/a&gt; and returned a &lt;a href=&quot;std_datetime_date#Date&quot;&gt;&lt;code&gt;std.datetime.date.Date&lt;/code&gt;&lt;/a&gt; which was one day later. That function would then be used by &lt;code&gt;PosInfIntervalRange&lt;/code&gt;'s &lt;code&gt;popFront&lt;/code&gt; to iterate over the &lt;a href=&quot;std_datetime_date#Date&quot;&gt;&lt;code&gt;std.datetime.date.Date&lt;/code&gt;&lt;/a&gt;s in the interval - though obviously, since the range is infinite, use a function such as &lt;code&gt;std.range.take&lt;/code&gt; with it rather than iterating over</source>
          <target state="translated">&lt;code&gt;PosInfIntervalRange&lt;/code&gt; 은 오직 의해 구성되어 &lt;code&gt;PosInfInterval&lt;/code&gt; . 그러나 구성되면 반복되는 시점을 생성하는 데 사용되는 &lt;code&gt;func&lt;/code&gt; 함수가 제공 됩니다. &lt;code&gt;func&lt;/code&gt; 는 시점을 가져와 같은 유형의 시점을 반환합니다. 예를 들어, 간격에서 일의 모든 것을 반복하는 &lt;code&gt;PosInfInterval!Date&lt;/code&gt; 에 함수 통과 &lt;code&gt;PosInfInterval&lt;/code&gt; 의 &lt;code&gt;fwdRange&lt;/code&gt; 을 그 함수가 어디로 데려 갔는지 &lt;a href=&quot;std_datetime_date#Date&quot;&gt; &lt;code&gt;std.datetime.date.Date&lt;/code&gt; 을&lt;/a&gt; a와 반환 &lt;a href=&quot;std_datetime_date#Date&quot;&gt; &lt;code&gt;std.datetime.date.Date&lt;/code&gt; &lt;/a&gt; 을했다 하루 후에. 이 함수는 &lt;code&gt;PosInfIntervalRange&lt;/code&gt; 의 &lt;code&gt;popFront&lt;/code&gt; 에 의해 사용됩니다간격에서 &lt;a href=&quot;std_datetime_date#Date&quot;&gt; &lt;code&gt;std.datetime.date.Date&lt;/code&gt; &lt;/a&gt; s 를 반복하려면 -범위는 무한 하기 때문에 반복하지 않고 &lt;code&gt;std.range.take&lt;/code&gt; 와 같은 함수를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="cb8dc60d5bc32b6bcdebce52b394fac49414cf48" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;ProperCompare&lt;/code&gt; fixes the comparison operators ==, !=, &amp;lt;, &amp;lt;=, &amp;gt;, and &amp;gt;= to return correct results</source>
          <target state="translated">&lt;code&gt;ProperCompare&lt;/code&gt; 는 비교 연산자 == ,! =, &amp;lt;, &amp;lt;=,&amp;gt; 및&amp;gt; =를 수정하여 올바른 결과를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="c20b8bd63e178e519036e1081ea692a599a4c8fa" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Protocol&lt;/code&gt; is a class for retrieving protocol information.</source>
          <target state="translated">&lt;code&gt;Protocol&lt;/code&gt; 은 프로토콜 정보를 검색하기위한 클래스입니다.</target>
        </trans-unit>
        <trans-unit id="bb48bdc418739c506d179ce3cbcd0758cea6acca" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;ProtocolType&lt;/code&gt; - protocol to filter by</source>
          <target state="translated">&lt;code&gt;ProtocolType&lt;/code&gt; - 필터링 할 프로토콜</target>
        </trans-unit>
        <trans-unit id="5cb5a15effd4c34f04b113fc0b80aca348b723c6" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;R&lt;/code&gt; accepts some form of string or character. put will transcode the character &lt;code&gt;e&lt;/code&gt; accordingly.</source>
          <target state="translated">&lt;code&gt;R&lt;/code&gt; 은 어떤 형태의 문자열이나 문자를 받아들입니다. put은 그에 따라 문자 &lt;code&gt;e&lt;/code&gt; 를 코드 변환합니다 .</target>
        </trans-unit>
        <trans-unit id="780b6e42b49937b33d3acf041f9f55b645a2cc51" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;R&lt;/code&gt; specifically accepts an &lt;code&gt;E&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;R&lt;/code&gt; 은 구체적으로 &lt;code&gt;E&lt;/code&gt; 를 받아들 입니다.</target>
        </trans-unit>
        <trans-unit id="0c66441bc26ad454d0cc3d154df2f83c7aaac35f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;R&lt;/code&gt; specifically accepts an &lt;code&gt;E[]&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;R&lt;/code&gt; 은 특히 &lt;code&gt;E[]&lt;/code&gt; 허용합니다 .</target>
        </trans-unit>
        <trans-unit id="75cde118348c0e71fa950e422d9c9e78ae88ab95" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;RangePrimitive.access&lt;/code&gt; is a shortcut for the access primitives; &lt;code&gt;front&lt;/code&gt;, &lt;code&gt;back&lt;/code&gt; and &lt;code&gt;opIndex&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;RangePrimitive.access&lt;/code&gt; 는 액세스 프리미티브의 바로 가기입니다. &lt;code&gt;front&lt;/code&gt; , &lt;code&gt;back&lt;/code&gt; 및 &lt;code&gt;opIndex&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f762138a599689e87a282296107b6b29b6a13874" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;RangePrimitive.pop&lt;/code&gt; is a shortcut for the mutating primitives; &lt;code&gt;popFront&lt;/code&gt; and &lt;code&gt;popBack&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;RangePrimitive.pop&lt;/code&gt; 은 변형 프리미티브의 바로 가기입니다. &lt;code&gt;popFront&lt;/code&gt; 및 &lt;code&gt;popBack&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="030771000e0ceb8354a01647408b24878dcaca4d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Rebindable!(T)&lt;/code&gt; is a simple, efficient wrapper that behaves just like an object of type &lt;code&gt;T&lt;/code&gt;, except that you can reassign it to refer to another object. For completeness, &lt;code&gt;Rebindable!(T)&lt;/code&gt; aliases itself away to &lt;code&gt;T&lt;/code&gt; if &lt;code&gt;T&lt;/code&gt; is a non-const object type.</source>
          <target state="translated">&lt;code&gt;Rebindable!(T)&lt;/code&gt; 는 다른 객체를 참조하도록 다시 할당 할 수 있다는 점을 제외하고는 &lt;code&gt;T&lt;/code&gt; 유형의 객체처럼 동작하는 간단하고 효율적인 래퍼입니다 . 완성도를 들어, &lt;code&gt;Rebindable!(T)&lt;/code&gt; 거리에 자신을 별칭 &lt;code&gt;T&lt;/code&gt; 경우 &lt;code&gt;T&lt;/code&gt; 는 비 const 인 오브젝트 유형입니다.</target>
        </trans-unit>
        <trans-unit id="b00a9e0b0a644fd8087968f990c22c18c90edf0b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;RefCounted&lt;/code&gt; is unsafe and should be used with care. No references to the payload should be escaped outside the &lt;code&gt;RefCounted&lt;/code&gt; object.</source>
          <target state="translated">&lt;code&gt;RefCounted&lt;/code&gt; 는 안전하지 않으므로 주의해서 사용해야합니다. 페이로드에 대한 참조는 &lt;code&gt;RefCounted&lt;/code&gt; 객체 외부에서 이스케이프되지 않아야 합니다.</target>
        </trans-unit>
        <trans-unit id="d88ab8258f37733765c1601e808462b33b8aee2a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;RefCounted&lt;/code&gt; storage implementation.</source>
          <target state="translated">&lt;code&gt;RefCounted&lt;/code&gt; 스토리지 구현.</target>
        </trans-unit>
        <trans-unit id="9bee36718af73e578a30bbaedc2c37541d5e249f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Regex&lt;/code&gt; object holds regular expression pattern in compiled form.</source>
          <target state="translated">&lt;code&gt;Regex&lt;/code&gt; 개체는 정규식 패턴을 컴파일 된 형태로 유지합니다.</target>
        </trans-unit>
        <trans-unit id="87d4168f1bbd4eac219801b43c6bc243bfc23d42" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Regex&lt;/code&gt; object that works on inputs having the same character width as &lt;code&gt;pattern&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Regex&lt;/code&gt; &lt;code&gt;pattern&lt;/code&gt; 과 동일한 문자 너비를 가진 입력에서 작동하는 정규식 객체 .</target>
        </trans-unit>
        <trans-unit id="471e1b858b0c776c473a1871b9341b72606ac29f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;RegexException&lt;/code&gt; if there were any errors during compilation.</source>
          <target state="translated">&lt;code&gt;RegexException&lt;/code&gt; 컴파일하는 동안 오류가 발생한 경우</target>
        </trans-unit>
        <trans-unit id="a53adf2cbff9ae2891543c9eacc87e202aff05df" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;ReplaceType&lt;/code&gt; aliases itself to the type(s) that result after replacement.</source>
          <target state="translated">&lt;code&gt;ReplaceType&lt;/code&gt; 은 교체 후 생성 된 유형에 자체 별칭을 부여 합니다.</target>
        </trans-unit>
        <trans-unit id="2f1f6bbeb799dd234e6f795209127f34ac65e265" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;S&lt;/code&gt; defines at least one direct member that has a copy constructor, and that member is not overlapped (by means of &lt;code&gt;union&lt;/code&gt;) with any other member.</source>
          <target state="translated">&lt;code&gt;S&lt;/code&gt; 는 복사 생성자를 가진 하나 이상의 직접 멤버를 정의하고 해당 멤버는 다른 멤버와 겹치지 않습니다 ( &lt;code&gt;union&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="75630199841be5d37303401849758dd2a43984da" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;S&lt;/code&gt; does not explicitly declare any copy constructors;</source>
          <target state="translated">&lt;code&gt;S&lt;/code&gt; 는 복사 생성자를 명시 적으로 선언하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="78494e20fa7de6742095448d88b655fd51d08a41" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;SList&lt;/code&gt; uses reference semantics.</source>
          <target state="translated">&lt;code&gt;SList&lt;/code&gt; 는 참조 시맨틱을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="c56058ec16a4fa994151ef298e8adc161ce878c9" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;SMTP&lt;/code&gt; struct for advanced usage</source>
          <target state="translated">&lt;code&gt;SMTP&lt;/code&gt; 고급 사용을위한 SMTP 구조</target>
        </trans-unit>
        <trans-unit id="7e9d8cf3e45f79f3c4e342d8fae899fb65e16630" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Saturate&lt;/code&gt; stops at an overflow</source>
          <target state="translated">&lt;code&gt;Saturate&lt;/code&gt; 오버플로에서 포화 가 멈춤</target>
        </trans-unit>
        <trans-unit id="2f7486cdf10bdc5b58b2b22311800e044e643d8d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Scope&lt;/code&gt; of the expression (deprecations do not trigger in deprecated scopes)</source>
          <target state="translated">&lt;code&gt;Scope&lt;/code&gt; 식의 범위 (더 이상 사용되지 않는 범위에서는 더 이상 사용되지 않음)</target>
        </trans-unit>
        <trans-unit id="332dd805aa714f4c9de1b65f527e6f2f95a4b450" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;ScopedAllocator&lt;/code&gt; delegates all allocation requests to &lt;code&gt;ParentAllocator&lt;/code&gt;. When destroyed, the &lt;code&gt;ScopedAllocator&lt;/code&gt; object automatically calls &lt;code&gt;deallocate&lt;/code&gt; for all memory allocated through its lifetime. (The &lt;code&gt;deallocateAll&lt;/code&gt; function is also implemented with the same semantics.)</source>
          <target state="translated">&lt;code&gt;ScopedAllocator&lt;/code&gt; 의 위임에 대한 모든 할당 요청 &lt;code&gt;ParentAllocator&lt;/code&gt; . 파괴되면 &lt;code&gt;ScopedAllocator&lt;/code&gt; 객체 는 수명 동안 할당 된 모든 메모리에 대해 &lt;code&gt;deallocate&lt;/code&gt; 를 자동으로 호출합니다 . ( &lt;code&gt;deallocateAll&lt;/code&gt; 함수도 동일한 의미로 구현됩니다.)</target>
        </trans-unit>
        <trans-unit id="68e3c30a95c281a86363341aaa246fbc3330c338" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Sequence&lt;/code&gt; is similar to &lt;code&gt;Recurrence&lt;/code&gt; except that iteration is presented in the so-called &lt;a href=&quot;http://en.wikipedia.org/wiki/Closed_form&quot;&gt; closed form&lt;/a&gt;. This means that the &lt;code&gt;n&lt;/code&gt;th element in the series is computable directly from the initial values and &lt;code&gt;n&lt;/code&gt; itself. This implies that the interface offered by &lt;code&gt;Sequence&lt;/code&gt; is a random-access range, as opposed to the regular &lt;code&gt;Recurrence&lt;/code&gt;, which only offers forward iteration.</source>
          <target state="translated">&lt;code&gt;Sequence&lt;/code&gt; 는 반복이 소위 &lt;a href=&quot;http://en.wikipedia.org/wiki/Closed_form&quot;&gt;닫힌 형식으로&lt;/a&gt; 표시된다는 점을 제외 하면 &lt;code&gt;Recurrence&lt;/code&gt; 와 유사합니다 . 이것은 시리즈 의 &lt;code&gt;n&lt;/code&gt; 번째 요소가 초기 값과 &lt;code&gt;n&lt;/code&gt; 자체 에서 직접 계산할 수 있음을 의미 합니다. 이는 &lt;code&gt;Sequence&lt;/code&gt; 반복 만 제공 하는 일반 &lt;code&gt;Recurrence&lt;/code&gt; 와 달리 Sequence에서 제공하는 인터페이스 가 임의 액세스 범위 임을 의미합니다 .</target>
        </trans-unit>
        <trans-unit id="1f74cfffb73a2e53c60382547eeaff4ebf62277d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Service&lt;/code&gt; is a class for retrieving service information.</source>
          <target state="translated">&lt;code&gt;Service&lt;/code&gt; 는 서비스 정보를 검색하기위한 클래스입니다.</target>
        </trans-unit>
        <trans-unit id="5dd3d87bf4379ada60681ae524288a8b96bcde1a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;SharedAlignedBlockList&lt;/code&gt; is the threadsafe version of &lt;code&gt;AlignedBlockList&lt;/code&gt;. The &lt;code&gt;Allocator&lt;/code&gt; template parameter must refer a shared allocator. Also, &lt;code&gt;ParentAllocator&lt;/code&gt; must be a shared allocator, supporting &lt;code&gt;alignedAllocate&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;SharedAlignedBlockList&lt;/code&gt; 는 Threaded 버전의 &lt;code&gt;AlignedBlockList&lt;/code&gt; 입니다. &lt;code&gt;Allocator&lt;/code&gt; 템플릿 매개 변수는 공유 할당을 참조해야합니다. 또한, &lt;code&gt;ParentAllocator&lt;/code&gt; 가 지원하는 공유 할당이어야합니다 &lt;code&gt;alignedAllocate&lt;/code&gt; 을 .</target>
        </trans-unit>
        <trans-unit id="746754b2aa00bad45fb2be52daaa182ac49c6430" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;SharedAscendingPageAllocator&lt;/code&gt; is the threadsafe version of &lt;code&gt;AscendingPageAllocator&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;SharedAscendingPageAllocator&lt;/code&gt; 는 스레드 안전 버전의 &lt;code&gt;AscendingPageAllocator&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="c6efd4b35b5ba7aadd42b05cb7b5432c9aa7ea3a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Socket&lt;/code&gt; is a class that creates a network communication endpoint using the Berkeley sockets interface.</source>
          <target state="translated">&lt;code&gt;Socket&lt;/code&gt; 은 Berkeley 소켓 인터페이스를 사용하여 네트워크 통신 끝점을 만드는 클래스입니다.</target>
        </trans-unit>
        <trans-unit id="87fa4417125d3cac79e8cb411aa1e3d62379087e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;SocketException&lt;/code&gt; if creation of the sockets fails.</source>
          <target state="translated">&lt;code&gt;SocketException&lt;/code&gt; 소켓 작성에 실패한 경우</target>
        </trans-unit>
        <trans-unit id="b78b331409d25e66115d26e36b7a7111d4712e46" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;SocketException&lt;/code&gt; if setting the options fails.</source>
          <target state="translated">&lt;code&gt;SocketException&lt;/code&gt; 옵션 설정에 실패한 경우 SocketException 이 발생합니다.</target>
        </trans-unit>
        <trans-unit id="62fb2c297f48546eaf7d5c402b4d6de00e5102d7" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;SocketException&lt;/code&gt; on error.</source>
          <target state="translated">&lt;code&gt;SocketException&lt;/code&gt; 오류가 발생하면 SocketException 이 발생합니다.</target>
        </trans-unit>
        <trans-unit id="76dfb042cff82ec649174071c6f90d7f55b3bb47" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;SocketException&lt;/code&gt; on failure.</source>
          <target state="translated">&lt;code&gt;SocketException&lt;/code&gt; 실패시 SocketException .</target>
        </trans-unit>
        <trans-unit id="6a0ac3e53834af046f515ebd06d9bdfc272be3ba" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;SocketOSException&lt;/code&gt; if setting the options fails, or &lt;code&gt;SocketFeatureException&lt;/code&gt; if setting keep-alive parameters is unsupported on the current platform.</source>
          <target state="translated">&lt;code&gt;SocketOSException&lt;/code&gt; 이 옵션을 설정하면 실패 할 경우, 또는 &lt;code&gt;SocketFeatureException&lt;/code&gt; 연결 유지 매개 변수를 설정하면 현재의 플랫폼에서 지원되지 않는 경우.</target>
        </trans-unit>
        <trans-unit id="7a0981fb867b9d1010fb7e98f0f42f113299e19e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;SocketOSException&lt;/code&gt; on failure, or &lt;code&gt;SocketFeatureException&lt;/code&gt; if this functionality is not available on the current system.</source>
          <target state="translated">&lt;code&gt;SocketOSException&lt;/code&gt; 실패시 SocketOSException 또는 현재 시스템에서이 기능을 사용할 수없는 경우 &lt;code&gt;SocketFeatureException&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="3eb13bd8112aca0871aae534a7fb63f8bff6f0ea" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;SocketOSException&lt;/code&gt; on failure.</source>
          <target state="translated">&lt;code&gt;SocketOSException&lt;/code&gt; 실패시 SocketOSException .</target>
        </trans-unit>
        <trans-unit id="533fe63858ca229c5548c18bba5c935275d9786a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;SocketSet&lt;/code&gt; wraps the platform &lt;code&gt;fd_set&lt;/code&gt; type. However, unlike &lt;code&gt;fd_set&lt;/code&gt;, &lt;code&gt;SocketSet&lt;/code&gt; is not statically limited to &lt;code&gt;FD_SETSIZE&lt;/code&gt; or any other limit, and grows as needed.</source>
          <target state="translated">&lt;code&gt;SocketSet&lt;/code&gt; 은 플랫폼 &lt;code&gt;fd_set&lt;/code&gt; 유형을 래핑합니다 . 그러나 달리 &lt;code&gt;fd_set&lt;/code&gt; , &lt;code&gt;SocketSet&lt;/code&gt; 은 정적에 한정되지 않고, &lt;code&gt;FD_SETSIZE&lt;/code&gt; 또는 기타 제한하고 필요에 따라 성장한다.</target>
        </trans-unit>
        <trans-unit id="6292666f1fd27e364014781db58d7c9f3d224716" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;SocketType&lt;/code&gt; - socket type to filter by</source>
          <target state="translated">&lt;code&gt;SocketType&lt;/code&gt; - 필터링 할 소켓 유형</target>
        </trans-unit>
        <trans-unit id="c787eccd1cfe254a883d5baa6dbc853ad90fc0c3" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;SortedRange&lt;/code&gt; could accept ranges weaker than random-access, but it is unable to provide interesting functionality for them. Therefore, &lt;code&gt;SortedRange&lt;/code&gt; is currently restricted to random-access ranges.  No copy of the original range is ever made. If the underlying range is changed concurrently with its corresponding &lt;code&gt;SortedRange&lt;/code&gt; in ways that break its sorted-ness, &lt;code&gt;SortedRange&lt;/code&gt; will work erratically.</source>
          <target state="translated">&lt;code&gt;SortedRange&lt;/code&gt; 는 임의 액세스보다 약한 범위를 허용 할 수 있지만 흥미로운 기능을 제공 할 수는 없습니다. 따라서 &lt;code&gt;SortedRange&lt;/code&gt; 는 현재 임의 액세스 범위로 제한됩니다. 원래 범위의 사본이 만들어지지 않았습니다. 정렬 범위를 벗어나는 방식으로 기본 범위가 해당 &lt;code&gt;SortedRange&lt;/code&gt; 와 동시에 변경 되면 &lt;code&gt;SortedRange&lt;/code&gt; 가 잘못 작동합니다.</target>
        </trans-unit>
        <trans-unit id="5b9ca29b38b1f15d8973e1ced47848fd1d2dba6f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Source&lt;/code&gt; must be a random access range. The returned range will be bidirectional or random-access if &lt;code&gt;Indices&lt;/code&gt; is bidirectional or random-access, respectively.</source>
          <target state="translated">&lt;code&gt;Source&lt;/code&gt; 는 임의의 액세스 범위 여야합니다. &lt;code&gt;Indices&lt;/code&gt; 가 각각 양방향 또는 랜덤 액세스 인 경우 반환되는 범위 는 양방향 또는 랜덤 액세스입니다.</target>
        </trans-unit>
        <trans-unit id="4c0feeb1ff674d28575106f12aafb6a73cdd4968" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;StdioException&lt;/code&gt; on I/O error, or &lt;code&gt;UnicodeException&lt;/code&gt; on Unicode conversion error.</source>
          <target state="translated">&lt;code&gt;StdioException&lt;/code&gt; I / O 오류의 StdioException 또는 &lt;code&gt;UnicodeException&lt;/code&gt; 코드 변환 오류의 UnicodeException</target>
        </trans-unit>
        <trans-unit id="a895bd9ca37148b0bedbdaf72160091894b81f68" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;StopWatch&lt;/code&gt; measures time as precisely as possible.</source>
          <target state="translated">&lt;code&gt;StopWatch&lt;/code&gt; 는 가능한 한 정확하게 시간을 측정합니다.</target>
        </trans-unit>
        <trans-unit id="6a66ba194c1af962c95944ee31d9e398b9989bf7" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;SysTime&lt;/code&gt; is the type used to get the current time from the system or doing anything that involves time zones. Unlike &lt;a href=&quot;std_datetime_date#DateTime&quot;&gt;&lt;code&gt;std.datetime.date.DateTime&lt;/code&gt;&lt;/a&gt;, the time zone is an integral part of &lt;code&gt;SysTime&lt;/code&gt; (though for local time applications, time zones can be ignored and it will work, since it defaults to using the local time zone). It holds its internal time in std time (hnsecs since midnight, January 1st, 1 A.D. UTC), so it interfaces well with the system time. However, that means that, unlike &lt;a href=&quot;std_datetime_date#DateTime&quot;&gt;&lt;code&gt;std.datetime.date.DateTime&lt;/code&gt;&lt;/a&gt;, it is not optimized for calendar-based operations, and getting individual units from it such as years or days is going to involve conversions and be less efficient.</source>
          <target state="translated">&lt;code&gt;SysTime&lt;/code&gt; 은 시스템에서 현재 시간을 가져 오거나 시간대와 관련된 모든 작업을 수행하는 데 사용되는 유형입니다. &lt;a href=&quot;std_datetime_date#DateTime&quot;&gt; &lt;code&gt;std.datetime.date.DateTime&lt;/code&gt; &lt;/a&gt; 과 달리 표준 시간대는 &lt;code&gt;SysTime&lt;/code&gt; 의 필수 부분입니다 (현지 시간 응용 프로그램의 경우 표준 시간대는 로컬 표준 시간대를 사용하기 때문에 표준 시간대를 무시하고 작동 할 수 있음). 내부 시간을 표준시 (AD UTC 1 월 1 일 자정 이후의 hnsecs)로 유지하므로 시스템 시간과 잘 연결됩니다. 그러나 이는 &lt;a href=&quot;std_datetime_date#DateTime&quot;&gt; &lt;code&gt;std.datetime.date.DateTime&lt;/code&gt; &lt;/a&gt; 과 달리 달력 기반 작업에 최적화되어 있지 않으며 몇 년 또는 며칠과 같이 개별 단위를 가져 오는 경우 변환이 수반되고 효율성이 떨어집니다.</target>
        </trans-unit>
        <trans-unit id="ac0c6b1810b24c03416add46f5ae8e5d1b27562a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;SysTime&lt;/code&gt;'s range is from approximately 29,000 B.C. to approximately 29,000 A.D.</source>
          <target state="translated">&lt;code&gt;SysTime&lt;/code&gt; 의 범위는 대략 29,000 BC에서 대략 29,000 AD입니다</target>
        </trans-unit>
        <trans-unit id="91628f7ac20b93970362b69b9450bc20627b98eb" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;T&lt;/code&gt; must define a &lt;code&gt;opBinary&lt;/code&gt; for subtraction which accepts &lt;code&gt;T&lt;/code&gt; and returns returns &lt;a href=&quot;core_time#Duration&quot;&gt;&lt;code&gt;core.time.Duration&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;T&lt;/code&gt; 는 빼기를 위해 &lt;code&gt;opBinary&lt;/code&gt; 를 정의해야 하며, &lt;code&gt;T&lt;/code&gt; 를 받아들이고 반환 값은 &lt;a href=&quot;core_time#Duration&quot;&gt; &lt;code&gt;core.time.Duration&lt;/code&gt; 을&lt;/a&gt; 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="4d2c6bca96e673afe06d9e325d4acc343fd20d60" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;T&lt;/code&gt; must define a static property named &lt;code&gt;max&lt;/code&gt; which is the largest value of &lt;code&gt;T&lt;/code&gt; as &lt;code&gt;Unqual!T&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;T&lt;/code&gt; 는 라는 이름의 정적 속성 정의해야 &lt;code&gt;max&lt;/code&gt; 의 가장 큰 값 &lt;code&gt;T&lt;/code&gt; 로 &lt;code&gt;Unqual!T&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f294feb51e2d2f00db976416287ad63fee9f66c4" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;T&lt;/code&gt; must define a static property named &lt;code&gt;min&lt;/code&gt; which is the smallest value of &lt;code&gt;T&lt;/code&gt; as &lt;code&gt;Unqual!T&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;T&lt;/code&gt; 는 정적이라는 속성을 정의해야 &lt;code&gt;min&lt;/code&gt; 의 최소 값 &lt;code&gt;T&lt;/code&gt; 로서 &lt;code&gt;Unqual!T&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="53e8de8dac2a8691b4bdd0087daafbe6712c0f2a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;T&lt;/code&gt; must define an &lt;code&gt;opBinary&lt;/code&gt; for addition and subtraction that accepts &lt;a href=&quot;core_time#Duration&quot;&gt;&lt;code&gt;core.time.Duration&lt;/code&gt;&lt;/a&gt; and returns &lt;code&gt;Unqual!T&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;T&lt;/code&gt; 는 &lt;a href=&quot;core_time#Duration&quot;&gt; &lt;code&gt;core.time.Duration&lt;/code&gt; &lt;/a&gt; 을 받아들이고 &lt;code&gt;Unqual!T&lt;/code&gt; 반환 하는 덧셈과 뺄셈에 &lt;code&gt;opBinary&lt;/code&gt; 를 정의해야합니다 .</target>
        </trans-unit>
        <trans-unit id="7fab6f337372fb064f170e2a181317eb9e44fc5e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;T&lt;/code&gt; must define an &lt;code&gt;opOpAssign&lt;/code&gt; for addition and subtraction that accepts &lt;a href=&quot;core_time#Duration&quot;&gt;&lt;code&gt;core.time.Duration&lt;/code&gt;&lt;/a&gt; and returns &lt;code&gt;ref Unqual!T&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;T&lt;/code&gt; 는 &lt;a href=&quot;core_time#Duration&quot;&gt; &lt;code&gt;core.time.Duration&lt;/code&gt; &lt;/a&gt; 을 허용 하고 &lt;code&gt;ref Unqual!T&lt;/code&gt; 반환 하는 덧셈과 뺄셈에 대해 &lt;code&gt;opOpAssign&lt;/code&gt; 을 정의해야합니다 .</target>
        </trans-unit>
        <trans-unit id="7e5a544e1bd186a2a67b6a67ef05e99600fe89c6" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;T&lt;/code&gt; with the &lt;code&gt;const&lt;/code&gt; and &lt;code&gt;shared&lt;/code&gt; qualifiers added.</source>
          <target state="translated">&lt;code&gt;T&lt;/code&gt; 와 &lt;code&gt;const&lt;/code&gt; 및 &lt;code&gt;shared&lt;/code&gt; 예선 덧붙였다.</target>
        </trans-unit>
        <trans-unit id="31ec721d20b2801e5d346700c80f678793d1c0e2" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;T&lt;/code&gt; with the &lt;code&gt;const&lt;/code&gt; qualifier added.</source>
          <target state="translated">&lt;code&gt;T&lt;/code&gt; 와 &lt;code&gt;const&lt;/code&gt; 규정했다.</target>
        </trans-unit>
        <trans-unit id="186a43c969a1f6b869085813b17231ea61972375" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;T&lt;/code&gt; with the &lt;code&gt;immutable&lt;/code&gt; qualifier added.</source>
          <target state="translated">&lt;code&gt;T&lt;/code&gt; 와 &lt;code&gt;immutable&lt;/code&gt; 규정했다.</target>
        </trans-unit>
        <trans-unit id="0f4a39908568cd6d472669bdc7cd96a13cb06098" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;T&lt;/code&gt; with the &lt;code&gt;inout&lt;/code&gt; and &lt;code&gt;shared&lt;/code&gt; qualifiers added.</source>
          <target state="translated">&lt;code&gt;T&lt;/code&gt; 와 &lt;code&gt;inout&lt;/code&gt; 및 &lt;code&gt;shared&lt;/code&gt; 예선 덧붙였다.</target>
        </trans-unit>
        <trans-unit id="470204d231d8939583648e7203f7b1cd2a937dff" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;T&lt;/code&gt; with the &lt;code&gt;inout&lt;/code&gt; qualifier added.</source>
          <target state="translated">&lt;code&gt;T&lt;/code&gt; 와 &lt;code&gt;inout&lt;/code&gt; 규정했다.</target>
        </trans-unit>
        <trans-unit id="3275cab2586883588d212e6312445a72995e25af" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;T&lt;/code&gt; with the &lt;code&gt;shared&lt;/code&gt; qualifier added.</source>
          <target state="translated">&lt;code&gt;T&lt;/code&gt; 와 함께 &lt;code&gt;shared&lt;/code&gt; 규정했다.</target>
        </trans-unit>
        <trans-unit id="0108d5739821b102796437e45f235d8ce482969a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Task&lt;/code&gt; objects created using &lt;code&gt;scopedTask&lt;/code&gt; will automatically call &lt;code&gt;Task.yieldForce&lt;/code&gt; in their destructor if necessary to ensure the &lt;code&gt;Task&lt;/code&gt; is complete before the stack frame they reside on is destroyed.</source>
          <target state="translated">&lt;code&gt;Task&lt;/code&gt; 사용하여 만든 개체 &lt;code&gt;scopedTask&lt;/code&gt; 를 자동으로 호출합니다 &lt;code&gt;Task.yieldForce&lt;/code&gt; 를 필요한 경우 확인하기 위해 자신의 소멸자에서 &lt;code&gt;Task&lt;/code&gt; 그들에있는 스택 프레임이 파괴되기 전에 완료됩니다.</target>
        </trans-unit>
        <trans-unit id="2832ad7b33aebd000a73dcb20f507e685a655947" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Task&lt;/code&gt; represents the fundamental unit of work. A &lt;code&gt;Task&lt;/code&gt; may be executed in parallel with any other &lt;code&gt;Task&lt;/code&gt;. Using this struct directly allows future/promise parallelism. In this paradigm, a function (or delegate or other callable) is executed in a thread other than the one it was called from. The calling thread does not block while the function is being executed. A call to &lt;code&gt;workForce&lt;/code&gt;, &lt;code&gt;yieldForce&lt;/code&gt;, or &lt;code&gt;spinForce&lt;/code&gt; is used to ensure that the &lt;code&gt;Task&lt;/code&gt; has finished executing and to obtain the return value, if any. These functions and &lt;code&gt;done&lt;/code&gt; also act as full memory barriers, meaning that any memory writes made in the thread that executed the &lt;code&gt;Task&lt;/code&gt; are guaranteed to be visible in the calling thread after one of these functions returns.</source>
          <target state="translated">&lt;code&gt;Task&lt;/code&gt; 은 기본 작업 단위를 나타냅니다. &lt;code&gt;Task&lt;/code&gt; 모든 병렬로 실행될 수있는 &lt;code&gt;Task&lt;/code&gt; . 이 구조체를 사용하면 미래 / 약속 병렬 처리가 가능합니다. 이 패러다임에서 함수 (또는 델리게이트 또는 다른 호출 가능)는 호출 된 스레드 이외의 스레드에서 실행됩니다. 함수가 실행되는 동안 호출 스레드가 차단되지 않습니다. &lt;code&gt;workForce&lt;/code&gt; , &lt;code&gt;yieldForce&lt;/code&gt; 또는 &lt;code&gt;spinForce&lt;/code&gt; 에 대한 호출 은 &lt;code&gt;Task&lt;/code&gt; 가 실행을 완료하고 리턴 값이있는 경우이를 얻기 위해 사용됩니다. 이러한 기능과 &lt;code&gt;done&lt;/code&gt; 은 전체 메모리 장벽으로 작동하므로 &lt;code&gt;Task&lt;/code&gt; 을 실행 한 스레드에서 작성된 모든 메모리 쓰기 이 함수 중 하나가 반환되면 호출 스레드에서 볼 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="82cd55fb0d006768136f2c5c0b4fcccab522c36f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;TcpSocket&lt;/code&gt; is a shortcut class for a TCP Socket.</source>
          <target state="translated">&lt;code&gt;TcpSocket&lt;/code&gt; 은 TCP 소켓의 바로 가기 클래스입니다.</target>
        </trans-unit>
        <trans-unit id="38f55edede4991a3cf116d69d68fc1d676b1f44d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Ternary.no&lt;/code&gt; for &lt;code&gt;false&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;Ternary.no&lt;/code&gt; 에 대한 &lt;code&gt;false&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="2869c4358399eebb5142dbe39568cc4e025e08d4" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Ternary.unknown&lt;/code&gt; as an unknown state</source>
          <target state="translated">&lt;code&gt;Ternary.unknown&lt;/code&gt; 알 수없는 상태로 알려지지 않은 Ternary.</target>
        </trans-unit>
        <trans-unit id="69476aeb136d8de7d30539eb5cacebe2d2d3358d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Ternary.yes&lt;/code&gt; for &lt;code&gt;true&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;Ternary.yes&lt;/code&gt; 에 대한 &lt;code&gt;true&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="46a182d3e8c1d404cdf9f37047a9ee60a7e8b3cc" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Ternary.yes&lt;/code&gt; if one allocator was found to return &lt;code&gt;Ternary.yes&lt;/code&gt;, &lt;code&gt;Ternary.no&lt;/code&gt; if all component allocators returned &lt;code&gt;Ternary.no&lt;/code&gt;, and &lt;code&gt;Ternary.unknown&lt;/code&gt; if no allocator returned &lt;code&gt;Ternary.yes&lt;/code&gt; and at least one returned &lt;code&gt;Ternary.unknown&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Ternary.yes&lt;/code&gt; 은 하나 개의 할당이 반환하는 것으로 확인 된 경우 &lt;code&gt;Ternary.yes&lt;/code&gt; 을 , &lt;code&gt;Ternary.no&lt;/code&gt; 모든 구성 요소 할당 자 반환하는 경우 &lt;code&gt;Ternary.no&lt;/code&gt; 및 &lt;code&gt;Ternary.unknown&lt;/code&gt; 을 더 할당 반환하지 않는 경우 &lt;code&gt;Ternary.yes&lt;/code&gt; 을 하고 적어도 하나에 반환 &lt;code&gt;Ternary.unknown&lt;/code&gt; 을 .</target>
        </trans-unit>
        <trans-unit id="7599544c003fc14111a32d44931860cfa0dd0ec1" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Ternary.yes&lt;/code&gt; if owned by this allocator and &lt;code&gt;Ternary.no&lt;/code&gt; otherwise</source>
          <target state="translated">&lt;code&gt;Ternary.yes&lt;/code&gt; 이 할당하고 소유하는 경우 &lt;code&gt;Ternary.no&lt;/code&gt; 그렇지 않으면</target>
        </trans-unit>
        <trans-unit id="4ad19c9b06c6c6a7d61bae14eea7ed48e0a9b259" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Ternary.yes&lt;/code&gt; if the allocator is empty, &lt;code&gt;Ternary.no&lt;/code&gt; otherwise. Never returns &lt;code&gt;Ternary.unknown&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Ternary.yes&lt;/code&gt; 할당자가 비어있는 경우, &lt;code&gt;Ternary.no&lt;/code&gt; 그렇지. &lt;code&gt;Ternary.unknown&lt;/code&gt; 을 반환하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="f1b49c13e674e31d46bece718af98b61034636b7" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Throw&lt;/code&gt; fails every incorrect operation by throwing an exception</source>
          <target state="translated">&lt;code&gt;Throw&lt;/code&gt; 예외를 throw에 의해 모든 잘못된 작업을 실패</target>
        </trans-unit>
        <trans-unit id="5697669daea1d2edaa6375d26bbad9518d5edafa" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;TimeException&lt;/code&gt; if an attempt to divide by &lt;code&gt;0&lt;/code&gt; is made.</source>
          <target state="translated">&lt;code&gt;TimeException&lt;/code&gt; &lt;code&gt;0&lt;/code&gt; 으로 나누려고하면 TimeException이 발생합니다 .</target>
        </trans-unit>
        <trans-unit id="2dc0d79c91d4e0597dd2ceebdb751a34fe72f1a4" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;TimeException&lt;/code&gt; if it fails to get the time.</source>
          <target state="translated">&lt;code&gt;TimeException&lt;/code&gt; 시간을 얻지 못하면 TimeException 이 발생합니다.</target>
        </trans-unit>
        <trans-unit id="c70993b8aed1eb03ef954291b34693b20ea0b2c2" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Transposed&lt;/code&gt; currently defines &lt;code&gt;save&lt;/code&gt;, but does not work as a forward range. Consuming a copy made with &lt;code&gt;save&lt;/code&gt; will consume all copies, even the original sub-ranges fed into &lt;code&gt;Transposed&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Transposed&lt;/code&gt; 는 현재 &lt;code&gt;save&lt;/code&gt; 를 정의 하지만 앞으로 범위로 작동하지 않습니다. &lt;code&gt;save&lt;/code&gt; 로 만든 복사본 을 소비하면 모든 하위 항목이 &lt;code&gt;Transposed&lt;/code&gt; 로 공급 된 원본 하위 범위를 포함하여 모든 복사본이 소비됩니다 .</target>
        </trans-unit>
        <trans-unit id="34644096ee359c9f543613726d2a575c3df43b36" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Tuple&lt;/code&gt; members can be named. It is legal to mix named and unnamed members. The method above is still applicable to all fields.</source>
          <target state="translated">&lt;code&gt;Tuple&lt;/code&gt; 멤버의 이름을 지정할 수 있습니다. 명명 된 멤버와 명명되지 않은 멤버를 혼합하는 것이 합법적입니다. 위의 방법은 여전히 ​​모든 필드에 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="22855b22d24613edb4797b3b3082b40e8bf9bd08" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Type&lt;/code&gt; that represents &lt;code&gt;va_list&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Type&lt;/code&gt; &lt;code&gt;va_list&lt;/code&gt; 를 나타내는 유형 입니다 .</target>
        </trans-unit>
        <trans-unit id="5995b12e3c639fd0ac9edd39fe711f66a051c4a3" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Type&lt;/code&gt; to use for parameter &lt;code&gt;p&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Type&lt;/code&gt; 매개 변수 &lt;code&gt;p&lt;/code&gt; 에 사용할 유형 입니다.</target>
        </trans-unit>
        <trans-unit id="9b7e28bca0b07d1e1da65763c6214f44c548470e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Type&lt;/code&gt; with completed semantic analysis, &lt;code&gt;Terror&lt;/code&gt; if errors were encountered</source>
          <target state="translated">&lt;code&gt;Type&lt;/code&gt; 의미 분석이 완료된 유형 , 오류가 발생한 경우 &lt;code&gt;Terror&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="03eaa064f1e4b2fb2c72e1d6e5d83085754ab33e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;TypeIdentifier&lt;/code&gt; corresponding to &lt;code&gt;object.Throwable&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;TypeIdentifier&lt;/code&gt; 해당하는 TypeIdentifier &lt;code&gt;object.Throwable&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="897ecbae7f27f97ae3e90420e022adc7dd2fbbd6" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;TypedAllocator&lt;/code&gt; acts like a chassis on which several specialized allocators can be assembled. To let the system make a choice about a particular kind of allocation, use &lt;code&gt;Default&lt;/code&gt; for the respective parameters.</source>
          <target state="translated">&lt;code&gt;TypedAllocator&lt;/code&gt; 는 여러 특수 할당자가 조립 될 수있는 섀시와 같은 역할을합니다. 시스템이 특정 종류의 할당에 대해 선택하도록하려면 각 매개 변수에 대해 &lt;code&gt;Default&lt;/code&gt; 을 사용 하십시오.</target>
        </trans-unit>
        <trans-unit id="6b1f38ae7efe6d59115175c5fdcc377f07580928" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;UTC&lt;/code&gt; is a singleton class. &lt;code&gt;UTC&lt;/code&gt; returns its only instance.</source>
          <target state="translated">&lt;code&gt;UTC&lt;/code&gt; 는 싱글 톤 클래스입니다. &lt;code&gt;UTC&lt;/code&gt; 는 유일한 인스턴스를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="007930a39a0f2faab8c8e4ee31d60aa7baf6481f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;UTFException&lt;/code&gt; if &lt;code&gt;c&lt;/code&gt; is not a valid UTF code point.</source>
          <target state="translated">&lt;code&gt;UTFException&lt;/code&gt; &lt;code&gt;c&lt;/code&gt; 가 유효한 UTF 코드 포인트가 아닌 경우</target>
        </trans-unit>
        <trans-unit id="2e62d6eb9384d3f58094d2720a94e28aae93a734" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;UTFException&lt;/code&gt; if &lt;code&gt;str&lt;/code&gt; is not well-formed.</source>
          <target state="translated">&lt;code&gt;UTFException&lt;/code&gt; &lt;code&gt;str&lt;/code&gt; 의 형식 이 올바르지 않은 경우</target>
        </trans-unit>
        <trans-unit id="0dfa2e2d6c82d1a56c3f65f1ee4bf18752205a6d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;UdpSocket&lt;/code&gt; is a shortcut class for a UDP Socket.</source>
          <target state="translated">&lt;code&gt;UdpSocket&lt;/code&gt; 은 UDP 소켓의 바로 가기 클래스입니다.</target>
        </trans-unit>
        <trans-unit id="5182d8d27ca95d277c11a3764eae17a180358ab4" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;UnixAddress&lt;/code&gt; encapsulates an address for a Unix domain socket (&lt;code&gt;AF_UNIX&lt;/code&gt;), i.e. a socket bound to a path name in the file system. Available only on supported systems.</source>
          <target state="translated">&lt;code&gt;UnixAddress&lt;/code&gt; 는 Unix 도메인 소켓 ( &lt;code&gt;AF_UNIX&lt;/code&gt; ) 의 주소 , 즉 파일 시스템의 경로 이름에 바인드 된 소켓을 캡슐화합니다 . 지원되는 시스템에서만 사용 가능합니다.</target>
        </trans-unit>
        <trans-unit id="570cc7188794ad606227ced38f371e5a4e45af02" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;UnknownAddress&lt;/code&gt; encapsulates an unknown socket address.</source>
          <target state="translated">&lt;code&gt;UnknownAddress&lt;/code&gt; 는 알 수없는 소켓 주소를 캡슐화합니다.</target>
        </trans-unit>
        <trans-unit id="9f804467942c17845726358bd0a49138438d2921" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;UnknownAddressReference&lt;/code&gt; encapsulates a reference to an arbitrary socket address.</source>
          <target state="translated">&lt;code&gt;UnknownAddressReference&lt;/code&gt; 는 임의의 소켓 주소에 대한 참조를 캡슐화합니다.</target>
        </trans-unit>
        <trans-unit id="86d81bb175d8331c17abee4394d7ff9941e66945" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;VariantN&lt;/code&gt; is a discriminated union type parameterized with the largest size of the types stored (&lt;code&gt;maxDataSize&lt;/code&gt;) and with the list of allowed types (&lt;code&gt;AllowedTypes&lt;/code&gt;). If the list is empty, then any type up of size up to &lt;code&gt; maxDataSize&lt;/code&gt; (rounded up for alignment) can be stored in a &lt;code&gt;VariantN&lt;/code&gt; object without being boxed (types larger than this will be boxed).</source>
          <target state="translated">&lt;code&gt;VariantN&lt;/code&gt; 은 저장된 최대 유형 ( &lt;code&gt;maxDataSize&lt;/code&gt; ) 및 허용 된 유형 목록 ( &lt;code&gt;AllowedTypes&lt;/code&gt; )으로 매개 변수화 된 구별 조합 유형 입니다. 목록이 비어 있으면 최대 &lt;code&gt; maxDataSize&lt;/code&gt; 크기의 정렬 (반올림을 위해 반올림)을 상자에 &lt;code&gt;VariantN&lt;/code&gt; 않고 VariantN 객체에 저장할 수 있습니다 (이보다 큰 유형은 상자에 넣습니다 ).</target>
        </trans-unit>
        <trans-unit id="e1cd77bcc0cf1f030ae7901413fc0caacad7cb4e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;WhiteHole!Base&lt;/code&gt; is a subclass of &lt;code&gt;Base&lt;/code&gt; which automatically implements all abstract member functions as functions that always fail. These functions simply throw an &lt;code&gt;Error&lt;/code&gt; and never return. &lt;code&gt;Whitehole&lt;/code&gt; is useful for trapping the use of class member functions that haven't been implemented.</source>
          <target state="translated">&lt;code&gt;WhiteHole!Base&lt;/code&gt; 는 모든 추상 멤버 함수를 항상 실패하는 함수로 자동 구현하는 &lt;code&gt;Base&lt;/code&gt; 의 서브 클래스입니다 . 이 함수는 단순히 &lt;code&gt;Error&lt;/code&gt; 시키고 반환하지 않습니다. &lt;code&gt;Whitehole&lt;/code&gt; 은 구현되지 않은 클래스 멤버 함수의 사용을 트랩하는 데 유용합니다.</target>
        </trans-unit>
        <trans-unit id="88dc88b6a51b76108d5dab31380ce314448dfd5c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;WindowsTimeZone&lt;/code&gt; does not exist on Posix systems.</source>
          <target state="translated">&lt;code&gt;WindowsTimeZone&lt;/code&gt; Posix 시스템에는 WindowsTimeZone 이 없습니다.</target>
        </trans-unit>
        <trans-unit id="b4dc9fa60360bfc14db34f4ba777455add3c797a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;WithNaN&lt;/code&gt; has a special &quot;Not a Number&quot; (NaN) value akin to the homonym value reserved for floating-point values</source>
          <target state="translated">&lt;code&gt;WithNaN&lt;/code&gt; 에는 부동 소수점 값을 위해 예약 된 동수 값과 유사한 특수한 &quot;숫자가 아님&quot;(NaN) 값이 있습니다</target>
        </trans-unit>
        <trans-unit id="75932668cda7d1c138194cb2dc0ebce2d67618fc" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Yes.allocateGC&lt;/code&gt;/&lt;code&gt;No.allocateGC&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;Yes.allocateGC&lt;/code&gt;/&lt;code&gt;No.allocateGC&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="37096fcbb3223cda99b6350080a7ac8758291a16" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Yes.caseSensitive&lt;/code&gt; (default) or &lt;code&gt;No.caseSensitive&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;Yes.caseSensitive&lt;/code&gt; (기본값) 또는 &lt;code&gt;No.caseSensitive&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="aa4e1929badc6e0a53755ba0d2f8f6d82478fac6" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Yes.caseSensitive&lt;/code&gt; or &lt;code&gt;No.caseSensitive&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;Yes.caseSensitive&lt;/code&gt; 또는 &lt;code&gt;No.caseSensitive&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="acde99d49e2a347fbbea03032397e4d04b670d2f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Yes.each&lt;/code&gt; if the entire range was iterated, &lt;code&gt;No.each&lt;/code&gt; in case of early stopping.</source>
          <target state="translated">&lt;code&gt;Yes.each&lt;/code&gt; 범위 전체가 반복 된 경우, 조기 중지시 각 &lt;code&gt;No.each&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1a0894a8a8a7fcd48b48f86aff52d4085ed4d7ea" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Yes.keepTerminator&lt;/code&gt; signals that the line terminator should be returned as part of the lines in the range.</source>
          <target state="translated">&lt;code&gt;Yes.keepTerminator&lt;/code&gt; 는 라인 터미네이터가 범위 내의 라인의 일부로 반환되어야한다는 신호를 보냅니다 .</target>
        </trans-unit>
        <trans-unit id="0e9225c219b029fb33b9467a4723c8b934677c56" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Yes.multiblock&lt;/code&gt; to support allocations spanning across multiple blocks and &lt;code&gt;No.multiblock&lt;/code&gt; to support single block allocations. Although limited by single block allocations, &lt;code&gt;No.multiblock&lt;/code&gt; will generally provide higher performance.</source>
          <target state="translated">&lt;code&gt;Yes.multiblock&lt;/code&gt; 여러 블록에 걸쳐 걸쳐 지원 할당에 &lt;code&gt;No.multiblock&lt;/code&gt; 은 단일 블록 할당을 지원합니다. 단일 블록 할당에 의해 제한되지만 &lt;code&gt;No.multiblock&lt;/code&gt; 은 일반적으로 더 높은 성능을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="4e26adb07aa94d1c5cf3ef86c050cd4d263aafe0" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;[1, 2].substitute(1, 0.1)&lt;/code&gt; returns &lt;code&gt;[0.1, 2]&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;[1, 2].substitute(1, 0.1)&lt;/code&gt; returns &lt;code&gt;[0.1, 2]&lt;/code&gt;.</target>
        </trans-unit>
        <trans-unit id="0473657586b4b2fbdfc343d365146a98334ec2c8" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;] = c&lt;/code&gt; are rewritten as &lt;code&gt;a.opIndexAssign(c,&lt;/code&gt;&lt;code&gt;a.opSlice(&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;] = c&lt;/code&gt; are rewritten as &lt;code&gt;a.opIndexAssign(c,&lt;/code&gt;&lt;code&gt;a.opSlice(&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="f9bd65cd7b31f1495857902ae8fd7a208acd1507" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;]&lt;/code&gt; as &lt;code&gt;a.opIndexAssign(a.opSlice(&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;]&lt;/code&gt; as &lt;code&gt;a.opIndexAssign(a.opSlice(&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="53d36c336609c242959efe9929c29b979ffec086" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;]&lt;/code&gt; can also be overloaded by implementing &lt;code&gt;opSlice()&lt;/code&gt; with no arguments and &lt;code&gt;opSlice(&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;]&lt;/code&gt; can also be overloaded by implementing &lt;code&gt;opSlice()&lt;/code&gt; with no arguments and &lt;code&gt;opSlice(&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="f97d7e3a93902ed9c6d203a821119d9132a3f3b5" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;]&lt;/code&gt;, where the expressions inside the square brackets contain slice expressions of the form</source>
          <target state="translated">&lt;code&gt;]&lt;/code&gt;, where the expressions inside the square brackets contain slice expressions of the form</target>
        </trans-unit>
        <trans-unit id="49268134baf72802931b8c3948cac60b86dde66e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;_&lt;/code&gt;arguments</source>
          <target state="translated">&lt;code&gt;_&lt;/code&gt;arguments</target>
        </trans-unit>
        <trans-unit id="e31497ca3e9899507e5c69f4846b4a071560e54b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;__FILE_FULL_PATH__&lt;/code&gt; expands to the absolute source file name at the point of instantiation.</source>
          <target state="translated">&lt;code&gt;__FILE_FULL_PATH__&lt;/code&gt; expands to the absolute source file name at the point of instantiation.</target>
        </trans-unit>
        <trans-unit id="80a25cf93923c63ad8518f587ae90ca9069798a1" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;__FILE__&lt;/code&gt; and &lt;code&gt;__LINE__&lt;/code&gt; expand to the source file name and line number at the point of instantiation. The path of the source file is left up to the compiler.</source>
          <target state="translated">&lt;code&gt;__FILE__&lt;/code&gt; and &lt;code&gt;__LINE__&lt;/code&gt; expand to the source file name and line number at the point of instantiation. The path of the source file is left up to the compiler.</target>
        </trans-unit>
        <trans-unit id="ed588f6dcc2cb7aa7133ee1f40685cad687bdaf9" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;__FUNCTION__&lt;/code&gt; expands to the fully qualified name of the function at the point of instantiation.</source>
          <target state="translated">&lt;code&gt;__FUNCTION__&lt;/code&gt; expands to the fully qualified name of the function at the point of instantiation.</target>
        </trans-unit>
        <trans-unit id="2359fdfddc3fc8d10e8fe72822341452b6bf1b38" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;__MODULE__&lt;/code&gt; expands to the module name at the point of instantiation.</source>
          <target state="translated">&lt;code&gt;__MODULE__&lt;/code&gt; expands to the module name at the point of instantiation.</target>
        </trans-unit>
        <trans-unit id="eca932952e18272728a561301fa1405e49487c48" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;__PRETTY_FUNCTION__&lt;/code&gt; is similar to &lt;code&gt;__FUNCTION__&lt;/code&gt;, but also expands the function return type, its parameter types, and its attributes.</source>
          <target state="translated">&lt;code&gt;__PRETTY_FUNCTION__&lt;/code&gt; is similar to &lt;code&gt;__FUNCTION__&lt;/code&gt;, but also expands the function return type, its parameter types, and its attributes.</target>
        </trans-unit>
        <trans-unit id="79b8a8782b10376be103a1b46f17d41a7ce95fde" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;__deh_eh&lt;/code&gt;, &lt;code&gt;__DATA&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;__deh_eh&lt;/code&gt;, &lt;code&gt;__DATA&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="16b9bfc2a738412fd0d279ded1128b5343a9e21f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;__gshared&lt;/code&gt; Attribute</source>
          <target state="translated">&lt;code&gt;__gshared&lt;/code&gt; Attribute</target>
        </trans-unit>
        <trans-unit id="64d15ca2a1aa87d72f7c89826d3003d8d24ce658" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;__gshared&lt;/code&gt; is disallowed in safe mode.</source>
          <target state="translated">&lt;code&gt;__gshared&lt;/code&gt; is disallowed in safe mode.</target>
        </trans-unit>
        <trans-unit id="067be2526e301e788923402f587a4884fcca8cbf" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;__gshared&lt;/code&gt; may also be applied to member variables and local variables. In these cases, &lt;code&gt;__gshared&lt;/code&gt; is equivalent to &lt;code&gt;static&lt;/code&gt;, except that the variable is shared by all threads rather than being thread local.</source>
          <target state="translated">&lt;code&gt;__gshared&lt;/code&gt; may also be applied to member variables and local variables. In these cases, &lt;code&gt;__gshared&lt;/code&gt; is equivalent to &lt;code&gt;static&lt;/code&gt;, except that the variable is shared by all threads rather than being thread local.</target>
        </trans-unit>
        <trans-unit id="da5929d8792a5bf4d5a1a5e20ebb3b7545142b09" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;_argptr&lt;/code&gt; and &lt;code&gt;_arguments&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;_argptr&lt;/code&gt; and &lt;code&gt;_arguments&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="927a35ea306e7d9e1a9c8f224e1e1f44cc56f803" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;_trailing&lt;/code&gt; contains the rest of the format string.</source>
          <target state="translated">&lt;code&gt;_trailing&lt;/code&gt; contains the rest of the format string.</target>
        </trans-unit>
        <trans-unit id="c23d4c448b30b7e5762e3b9f50f1b38c92addc3b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;a.opCmp(b)&lt;/code&gt;&lt;code&gt;&amp;gt;&lt;/code&gt;&lt;code&gt;0&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;a.opCmp(b)&lt;/code&gt;&lt;code&gt;&amp;gt;&lt;/code&gt;&lt;code&gt;0&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="83aca5e23ffe5179da8d2a164f7e4d0b65a4c6c4" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;a.opCmp(b)&lt;/code&gt;&lt;code&gt;&amp;gt;&lt;/code&gt;&lt;code&gt;= 0&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;a.opCmp(b)&lt;/code&gt; &lt;code&gt;&amp;gt;&lt;/code&gt; &lt;code&gt;= 0&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="181857568295d56eba9a6a198de27c754dd04414" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;a.opCmp(b)&lt;/code&gt;&lt;code&gt;&amp;lt;&lt;/code&gt;&lt;code&gt;0&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;a.opCmp(b)&lt;/code&gt;&lt;code&gt;&amp;lt;&lt;/code&gt;&lt;code&gt;0&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="85dd9503032ce2e1a2b3998f9b3f43ee7645078a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;a.opCmp(b)&lt;/code&gt;&lt;code&gt;&amp;lt;&lt;/code&gt;&lt;code&gt;= 0&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;a.opCmp(b)&lt;/code&gt; &lt;code&gt;&amp;lt;&lt;/code&gt; &lt;code&gt;= 0&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="e146d9bd2ea897b3e719a63d2a74b59414f2e3d2" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;a0&lt;/code&gt;, &lt;code&gt;a1&lt;/code&gt;, &amp;hellip;: arguments passed to the function;</source>
          <target state="translated">&lt;code&gt;a0&lt;/code&gt; , &lt;code&gt;a1&lt;/code&gt; ,&amp;hellip; : 함수에 인수가 전달되었습니다.</target>
        </trans-unit>
        <trans-unit id="b8067ead0423db1cae0ce0fbdd233161504053f4" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;a&lt;/code&gt; without evaluating &lt;code&gt;b&lt;/code&gt; if &lt;code&gt;cond&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;. Otherwise, returns &lt;code&gt;b&lt;/code&gt; without evaluating &lt;code&gt;a&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;a&lt;/code&gt; 평가없이 &lt;code&gt;b&lt;/code&gt; 하는 경우 &lt;code&gt;cond&lt;/code&gt; 있다 &lt;code&gt;true&lt;/code&gt; . 그렇지 않으면 &lt;code&gt;b&lt;/code&gt; 를 평가하지 않고 b 를 반환 &lt;code&gt;a&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a080773255c341a2088ee851b7f90e5bac4bd5d8" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;a&lt;/code&gt;, &lt;code&gt;b&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b3f340a48cc5ef4b2a7c3fb270ef208c519320ab" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;a&lt;/code&gt;&lt;code&gt;&amp;gt;&lt;/code&gt;&lt;code&gt;= b&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;a&lt;/code&gt; &lt;code&gt;&amp;gt;&lt;/code&gt; &lt;code&gt;= b&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="3c47794bafd1b854eee29c6dd3c8d0a62f9c6390" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;a&lt;/code&gt;&lt;code&gt;&amp;gt;&lt;/code&gt;&lt;code&gt;b&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;a&lt;/code&gt;&lt;code&gt;&amp;gt;&lt;/code&gt;&lt;code&gt;b&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="a7e18871ebac940afccefd06288a22599af4a142" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;a&lt;/code&gt;&lt;code&gt;&amp;lt;&lt;/code&gt;&lt;code&gt;= b&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;a&lt;/code&gt; &lt;code&gt;&amp;lt;&lt;/code&gt; &lt;code&gt;= b&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="4394b6408820c3ccbeb907463762684a0db34545" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;a&lt;/code&gt;&lt;code&gt;&amp;lt;&lt;/code&gt;&lt;code&gt;b&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;a&lt;/code&gt;&lt;code&gt;&amp;lt;&lt;/code&gt;&lt;code&gt;b&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="481e0e3279ea55db4490b4e12b497bb7796185c2" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;abort&lt;/code&gt; The default behavior. The normal behavior as described in the previous section</source>
          <target state="translated">&lt;code&gt;abort&lt;/code&gt; 기본 동작입니다. 이전 섹션에서 설명한 정상적인 동작</target>
        </trans-unit>
        <trans-unit id="862ebc26b834e571d93df7218de8a3cf6a0a6944" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;absTolerance&lt;/code&gt; shall be normal positive real no less then &lt;code&gt;T.epsilon*2&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;absTolerance&lt;/code&gt; 는 &lt;code&gt;T.epsilon*2&lt;/code&gt; 보다 크지 않은 정상적인 양의 실수 여야합니다 .</target>
        </trans-unit>
        <trans-unit id="069bc530f0c192a689ee8804bab426dafd2e186a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;abstract&lt;/code&gt; Attribute</source>
          <target state="translated">&lt;code&gt;abstract&lt;/code&gt; 속성</target>
        </trans-unit>
        <trans-unit id="dea734aca244e1fa75a85bf8024a6dda064dd51f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;align&lt;/code&gt; Attribute</source>
          <target state="translated">&lt;code&gt;align&lt;/code&gt; 속성 정렬</target>
        </trans-unit>
        <trans-unit id="2bbda70a12b1dfb683a3d0eeefb4b0af80992840" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;align&lt;/code&gt; by itself sets it to the default, which matches the default member alignment of the companion C compiler.</source>
          <target state="translated">&lt;code&gt;align&lt;/code&gt; 자체는이를 기본값으로 설정하며, 이는 컴패니언 C 컴파일러의 기본 멤버 정렬과 일치합니다.</target>
        </trans-unit>
        <trans-unit id="96c65851d0dfae10224f2b4c30d382fe864e2e13" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;alignedReallocate&lt;/code&gt; does not attempt to use &lt;code&gt;Allocator.reallocate&lt;/code&gt; even if defined. This is deliberate so allocators may use it internally within their own implementation of &lt;code&gt;reallocate&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;alignedReallocate&lt;/code&gt; 는 정의 된 경우에도 &lt;code&gt;Allocator.reallocate&lt;/code&gt; 를 사용하지 않습니다 . 이것은 의도적으로 할당 자들이 자신의 &lt;code&gt;reallocate&lt;/code&gt; 구현 내에서 내부적으로 사용할 수 있도록합니다 .</target>
        </trans-unit>
        <trans-unit id="920656092b134a330263b0a718fccea2594e0c24" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;all!&quot;a &amp;gt; 0&quot;([1, 2, 3, 4])&lt;/code&gt; returns &lt;code&gt;true&lt;/code&gt; because all elements are positive</source>
          <target state="translated">&lt;code&gt;all!&quot;a &amp;gt; 0&quot;([1, 2, 3, 4])&lt;/code&gt; 은 모든 요소가 양수이므로 &lt;code&gt;true&lt;/code&gt; 를 반환 합니다.</target>
        </trans-unit>
        <trans-unit id="e1ec3a1b62b705508abcddac095e37129e263fa2" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;all&lt;/code&gt; can also be used without a predicate, if its items can be evaluated to true or false in a conditional statement. This can be a convenient way to quickly evaluate that</source>
          <target state="translated">&lt;code&gt;all&lt;/code&gt; 의 항목이 조건문에서 true 또는 false로 평가 될 수있는 경우 또한, 조건없이 사용할 수 있습니다. 이를 통해 신속하게 평가할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="40bf88a393461716b9db758c2a860087764c87d9" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;any!&quot;a &amp;gt; 0&quot;([1, 2, -3, -4])&lt;/code&gt; returns &lt;code&gt;true&lt;/code&gt; because at least one element is positive</source>
          <target state="translated">&lt;code&gt;any!&quot;a &amp;gt; 0&quot;([1, 2, -3, -4])&lt;/code&gt; 는 하나 이상의 요소가 양수이므로 &lt;code&gt;true&lt;/code&gt; 를 반환 합니다.</target>
        </trans-unit>
        <trans-unit id="75c0218f1f4dc4fd6870ad5899d4a2555db6aab3" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;any&lt;/code&gt; can also be used without a predicate, if its items can be evaluated to true or false in a conditional statement. &lt;code&gt;!any&lt;/code&gt; can be a convenient way to quickly test that</source>
          <target state="translated">&lt;code&gt;any&lt;/code&gt; 의 항목이 조건문에서 true 또는 false로 평가 될 수있는 경우 또한, 조건없이 사용할 수 있습니다. &lt;code&gt;!any&lt;/code&gt; 빠른 테스트를위한 편리한 방법이 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="920ac1cf35f2ec8de62ed4ca28b101cde7e08da0" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;args&lt;/code&gt; must not have unshared aliasing. In other words, all arguments to &lt;code&gt;fn&lt;/code&gt; must either be &lt;code&gt;shared&lt;/code&gt; or &lt;code&gt;immutable&lt;/code&gt; or have no pointer indirection. This is necessary for enforcing isolation among threads.</source>
          <target state="translated">&lt;code&gt;args&lt;/code&gt; 는 비공유 별칭이 없어야합니다. 다시 말해서, &lt;code&gt;fn&lt;/code&gt; 에 대한 모든 인수 는 &lt;code&gt;shared&lt;/code&gt; 되거나 &lt;code&gt;immutable&lt;/code&gt; 하거나 포인터 간접 지정이 없어야합니다. 스레드 간 격리를 강화하는 데 필요합니다.</target>
        </trans-unit>
        <trans-unit id="bb52ec3e03bf0cb8732949695494b891c652b1e7" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;args&lt;/code&gt;: a tuple of the arguments;</source>
          <target state="translated">&lt;code&gt;args&lt;/code&gt; : 인수의 튜플;</target>
        </trans-unit>
        <trans-unit id="d04beebd234d53b9bd69f97edc333bfcb532821c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;assert&lt;/code&gt; failures are directed to the C runtime library</source>
          <target state="translated">&lt;code&gt;assert&lt;/code&gt; 오류는 C 런타임 라이브러리로 전달됩니다.</target>
        </trans-unit>
        <trans-unit id="fa92f6e99c1b6ea8acd4d7c57031128038c6661d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;auto&lt;/code&gt; Attribute</source>
          <target state="translated">&lt;code&gt;auto&lt;/code&gt; 속성</target>
        </trans-unit>
        <trans-unit id="cbe5e5a31e6057e02bc7e46eae1f3fee6b097927" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;ax&lt;/code&gt; and &lt;code&gt;bx&lt;/code&gt; shall be finite reals.</source>
          <target state="translated">&lt;code&gt;ax&lt;/code&gt; 와 &lt;code&gt;bx&lt;/code&gt; 는 유한 실수 여야합니다.</target>
        </trans-unit>
        <trans-unit id="785b2818320935ab9035e9ed41b00039824ad4ba" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;b !is null&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt; must have been allocated with this allocator.</source>
          <target state="translated">&lt;code&gt;b !is null&lt;/code&gt; 이며 &lt;code&gt;b&lt;/code&gt; 는이 할당 자로 할당되어야합니다.</target>
        </trans-unit>
        <trans-unit id="9d8ade1d9189252415ea271c17ad1402ce7018c2" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;b is null&lt;/code&gt;. This is because there is no other possible legitimate input.</source>
          <target state="translated">&lt;code&gt;b is null&lt;/code&gt; 입니다. 다른 가능한 합법적 인 입력이 없기 때문입니다.</target>
        </trans-unit>
        <trans-unit id="9b3bbb98cab24e06860664bbf90aad4fd5a0f595" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;b.opCmp(a)&lt;/code&gt;&lt;code&gt;&amp;gt;&lt;/code&gt;&lt;code&gt;0&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;b.opCmp(a)&lt;/code&gt;&lt;code&gt;&amp;gt;&lt;/code&gt;&lt;code&gt;0&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="29bcab357223ee6c8c5f67694f47a5d3c9e64fff" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;b.opCmp(a)&lt;/code&gt;&lt;code&gt;&amp;gt;&lt;/code&gt;&lt;code&gt;= 0&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;b.opCmp(a)&lt;/code&gt; &lt;code&gt;&amp;gt;&lt;/code&gt; &lt;code&gt;= 0&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="593c76dfe41796a74b9d56ecfa87752e9ea806a7" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;b.opCmp(a)&lt;/code&gt;&lt;code&gt;&amp;lt;&lt;/code&gt;&lt;code&gt;0&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;b.opCmp(a)&lt;/code&gt;&lt;code&gt;&amp;lt;&lt;/code&gt;&lt;code&gt;0&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="80e0464eea74b423d0de6d015b3d002ecf879c9b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;b.opCmp(a)&lt;/code&gt;&lt;code&gt;&amp;lt;&lt;/code&gt;&lt;code&gt;= 0&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;b.opCmp(a)&lt;/code&gt; &lt;code&gt;&amp;lt;&lt;/code&gt; &lt;code&gt;= 0&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="b75c3b04355d5b293310910e92a79197b5586c14" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;b&lt;/code&gt; has been allocated with this allocator, or is &lt;code&gt; null&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;b&lt;/code&gt; 가이 할당 자에 할당되었거나 &lt;code&gt; null&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="6fc256c493430315b6eed935052cb72d6e6aef3e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;balancedParens(&quot;((1 + 1) / 2)&quot;)&lt;/code&gt; returns &lt;code&gt;true&lt;/code&gt; because the string has balanced parentheses.</source>
          <target state="translated">&lt;code&gt;balancedParens(&quot;((1 + 1) / 2)&quot;)&lt;/code&gt; 는 문자열에 균형이있는 괄호가 있으므로 &lt;code&gt;true&lt;/code&gt; 를 반환 합니다 .</target>
        </trans-unit>
        <trans-unit id="67d7a26d3b5511855f2e0c34eb245328c333d854" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;bool&lt;/code&gt;s are formatted as &lt;code&gt;&quot;true&quot;&lt;/code&gt; or &lt;code&gt;&quot;false&quot;&lt;/code&gt; with &lt;code&gt;%s&lt;/code&gt; and as &lt;code&gt;1&lt;/code&gt; or &lt;code&gt;0&lt;/code&gt; with integral-specific format specs.</source>
          <target state="translated">&lt;code&gt;bool&lt;/code&gt; 들로 서식이 &lt;code&gt;&quot;true&quot;&lt;/code&gt; 또는 &lt;code&gt;&quot;false&quot;&lt;/code&gt; 으로 &lt;code&gt;%s&lt;/code&gt; 등의 &lt;code&gt;1&lt;/code&gt; 또는 &lt;code&gt;0&lt;/code&gt; 통합 특정 형식 사양과.</target>
        </trans-unit>
        <trans-unit id="aec8b12c63c29d1b55fc273193e84c10d1c29428" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;break&lt;/code&gt; exits the innermost enclosing while, for, foreach, do, or switch statement, resuming execution at the statement following it.</source>
          <target state="translated">&lt;code&gt;break&lt;/code&gt; 종료에게 가장 안쪽을, 잠시 동안, foreach는 수행 또는 스위치 문을 다음 문에서 실행을 재개.</target>
        </trans-unit>
        <trans-unit id="ad7d5b04e91ed51a96a115cccedf9bf33d34abd4" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;bringToFront&lt;/code&gt; takes two ranges &lt;code&gt;front&lt;/code&gt; and &lt;code&gt;back&lt;/code&gt;, which may be of different types. Considering the concatenation of &lt;code&gt;front&lt;/code&gt; and &lt;code&gt;back&lt;/code&gt; one unified range, &lt;code&gt;bringToFront&lt;/code&gt; rotates that unified range such that all elements in &lt;code&gt;back&lt;/code&gt; are brought to the beginning of the unified range. The relative ordering of elements in &lt;code&gt;front&lt;/code&gt; and &lt;code&gt;back&lt;/code&gt;, respectively, remains unchanged.</source>
          <target state="translated">&lt;code&gt;bringToFront&lt;/code&gt; 는 두 범위 얻어 &lt;code&gt;front&lt;/code&gt; 과 &lt;code&gt;back&lt;/code&gt; 다른 타입 일 수있다. 고려의 연결 &lt;code&gt;front&lt;/code&gt; 과 &lt;code&gt;back&lt;/code&gt; 단일화 범위를 &lt;code&gt;bringToFront&lt;/code&gt; 의 통합 범위는 이러한 모든 요소 있다는 것을 회전 &lt;code&gt;back&lt;/code&gt; 통합 범위의 시작하게된다. &lt;code&gt;front&lt;/code&gt; 과 &lt;code&gt;back&lt;/code&gt; 의 요소의 상대적 순서는 각각 변경되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="927abef211407b2f445dd66eacc6dd89aa442eb2" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;byChunk(&quot;dlang.org&quot;, 10)&lt;/code&gt; returns a range of ubyte[10] containing the dlang.org web page.</source>
          <target state="translated">&lt;code&gt;byChunk(&quot;dlang.org&quot;, 10)&lt;/code&gt; 는 dlang.org 웹 페이지를 포함하는 ubyte [10] 범위를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="63eabee68fef61a3ee33534d563febf1004d637d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;byChunkAsync(&quot;dlang.org&quot;, 10)&lt;/code&gt; returns a range of ubyte[10] containing the dlang.org web page asynchronously.</source>
          <target state="translated">&lt;code&gt;byChunkAsync(&quot;dlang.org&quot;, 10)&lt;/code&gt; 는 dlang.org 웹 페이지를 비동기 적으로 포함하는 ubyte [10] 범위를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="e07e59b1a940539cf55688cd2653347c4d8fe2d0" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;byCodeUnit&lt;/code&gt; does no Unicode decoding</source>
          <target state="translated">&lt;code&gt;byCodeUnit&lt;/code&gt; 은 유니 코드 디코딩을하지 않습니다</target>
        </trans-unit>
        <trans-unit id="e7bacd8ab0219c831357aa6d37c67a75166cc2af" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;byCodeUnit&lt;/code&gt; exposes a &lt;code&gt;source&lt;/code&gt; property when wrapping narrow strings.</source>
          <target state="translated">&lt;code&gt;byCodeUnit&lt;/code&gt; 은 좁은 문자열을 줄 바꿈 할 때 &lt;code&gt;source&lt;/code&gt; 속성을 노출합니다 .</target>
        </trans-unit>
        <trans-unit id="09c9aa4121d7ea220de3b1140939386f7ed28379" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;byLine(&quot;dlang.org&quot;)&lt;/code&gt; returns a range of char[] containing the dlang.org web page.</source>
          <target state="translated">&lt;code&gt;byLine(&quot;dlang.org&quot;)&lt;/code&gt; 는 dlang.org 웹 페이지를 포함하는 char [] 범위를 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="51878799bbf07b2664da8a52401f39df0b2ac581" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;byLineAsync(&quot;dlang.org&quot;)&lt;/code&gt; returns a range of char[] containing the dlang.org web page asynchronously.</source>
          <target state="translated">&lt;code&gt;byLineAsync(&quot;dlang.org&quot;)&lt;/code&gt; 는 dlang.org 웹 페이지를 비동기 적으로 포함하는 char [] 범위를 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="304cd505e182bc2c4f64cc2e2693038a437eeb75" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;cache&lt;/code&gt; does not provide random access primitives, as &lt;code&gt;cache&lt;/code&gt; would be unable to cache the random accesses. If &lt;code&gt;Range&lt;/code&gt; provides slicing primitives, then &lt;code&gt;cache&lt;/code&gt; will provide the same slicing primitives, but &lt;code&gt;hasSlicing!Cache&lt;/code&gt; will not yield true (as the &lt;a href=&quot;std_range_primitives#hasSlicing&quot;&gt;&lt;code&gt;std.range.primitives.hasSlicing&lt;/code&gt;&lt;/a&gt; trait also checks for random access).</source>
          <target state="translated">&lt;code&gt;cache&lt;/code&gt; 는 임의 액세스를 &lt;code&gt;cache&lt;/code&gt; 할 수 없으므로 임의 액세스 프리미티브를 제공하지 않습니다 . 경우 &lt;code&gt;Range&lt;/code&gt; 프리미티브를 얇게 제공, 다음 &lt;code&gt;cache&lt;/code&gt; 동일한 슬라이스 프리미티브를 제공하지만 &lt;code&gt;hasSlicing!Cache&lt;/code&gt; 합니다 (TRUE로 산출되지 않습니다 &lt;a href=&quot;std_range_primitives#hasSlicing&quot;&gt; &lt;code&gt;std.range.primitives.hasSlicing&lt;/code&gt; 는&lt;/a&gt; 또한 랜덤 액세스에 대한 검사를 특징 부 (trait)).</target>
        </trans-unit>
        <trans-unit id="f606f9f15aaebf711d9bba631df12df0a788678b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;cache&lt;/code&gt; eagerly evaluates &lt;a href=&quot;std_range_primitives#front&quot;&gt;front&lt;/a&gt; of &lt;code&gt;range&lt;/code&gt; on each construction or call to &lt;a href=&quot;std_range_primitives#popFront&quot;&gt;popFront&lt;/a&gt;, to store the result in a cache. The result is then directly returned when &lt;a href=&quot;std_range_primitives#front&quot;&gt;front&lt;/a&gt; is called, rather than re-evaluated.</source>
          <target state="translated">&lt;code&gt;cache&lt;/code&gt; 는 각 구성 에서 &lt;code&gt;range&lt;/code&gt; &lt;a href=&quot;std_range_primitives#front&quot;&gt;앞&lt;/a&gt; 을 열심히 평가 하거나 &lt;a href=&quot;std_range_primitives#popFront&quot;&gt;popFront를&lt;/a&gt; 호출 하여 결과를 캐시에 저장합니다. 그러면 결과가 재평가되지 않고 &lt;a href=&quot;std_range_primitives#front&quot;&gt;front&lt;/a&gt; 가 호출 될 때 직접 리턴됩니다 .</target>
        </trans-unit>
        <trans-unit id="e14e0b9f44b3e89356c7590fdf0f91e4eeaa0a59" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;cache&lt;/code&gt; may provide &lt;a href=&quot;std_range_primitives#isBidirectionalRange&quot;&gt;bidirectional range&lt;/a&gt; iteration if needed, but since this comes at an increased cost, it must be explicitly requested via the call to &lt;code&gt;cacheBidirectional&lt;/code&gt;. Furthermore, a bidirectional cache will evaluate the &quot;center&quot; element twice, when there is only one element left in the range.</source>
          <target state="translated">&lt;code&gt;cache&lt;/code&gt; 는 필요한 경우 &lt;a href=&quot;std_range_primitives#isBidirectionalRange&quot;&gt;양방향 범위&lt;/a&gt; 반복을 제공 할 수 있지만 비용이 증가하므로 &lt;code&gt;cacheBidirectional&lt;/code&gt; 호출을 통해 명시 적으로 요청해야합니다 . 또한 양방향 캐시는 해당 범위에 하나의 요소 만 남은 경우 &quot;중심&quot;요소를 두 번 평가합니다.</target>
        </trans-unit>
        <trans-unit id="410f8af0117e2ba07fd5bc8bff4390d619dd775a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;canFind(&quot;hello world&quot;, &quot;or&quot;)&lt;/code&gt; returns &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;canFind(&quot;hello world&quot;, &quot;or&quot;)&lt;/code&gt; 는 &lt;code&gt;true&lt;/code&gt; 를 반환 합니다 .</target>
        </trans-unit>
        <trans-unit id="ff2c61cde18123e357fe1a8f2663dce97f508b69" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;cast()&lt;/code&gt; and &lt;code&gt;cast(&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;cast()&lt;/code&gt; 와 &lt;code&gt;cast(&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="60ae09af485be0ac7cd9b6f70f585c2dbee91ecd" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;cast(U)&lt;/code&gt; expressions applied to lvalues of type &lt;code&gt;T&lt;/code&gt; when &lt;code&gt;T*&lt;/code&gt; is implicitly convertible to &lt;code&gt;U*&lt;/code&gt;;</source>
          <target state="translated">&lt;code&gt;cast(U)&lt;/code&gt; 표현은 형의 lvalues에 적용 &lt;code&gt;T&lt;/code&gt; 때 &lt;code&gt;T*&lt;/code&gt; 암시 적 변환입니다 &lt;code&gt;U*&lt;/code&gt; ;</target>
        </trans-unit>
        <trans-unit id="b89b8e9c45bb4feabdacbf66c526326b90e2d994" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;castSwitch&lt;/code&gt; can only be used with object types.</source>
          <target state="translated">&lt;code&gt;castSwitch&lt;/code&gt; 는 객체 유형에만 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3d916f0dc7c1e1eec21981dac40ca5db26d4906f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;char&lt;/code&gt; (chars are unsigned in D)</source>
          <target state="translated">&lt;code&gt;char&lt;/code&gt; (문자는 D에서 부호가 없습니다)</target>
        </trans-unit>
        <trans-unit id="fb295624198dc0f8123396e13dc59dba2a6dfa32" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;char&lt;/code&gt;, &lt;code&gt;wchar&lt;/code&gt;, &lt;code&gt;dchar&lt;/code&gt; to a string type.</source>
          <target state="translated">&lt;code&gt;char&lt;/code&gt; , &lt;code&gt;wchar&lt;/code&gt; , &lt;code&gt;dchar&lt;/code&gt; 를 문자열 유형으로 변환하십시오.</target>
        </trans-unit>
        <trans-unit id="c8e47cbd8e35276af4679f6e7b5bda73ed1d9d62" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;char&lt;/code&gt;, &lt;code&gt;wchar&lt;/code&gt;, or &lt;code&gt;dchar&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;char&lt;/code&gt; , &lt;code&gt;wchar&lt;/code&gt; 또는 &lt;code&gt;dchar&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="3e2a921f6a1d6d0ef8009fc307e0b2d445b1297e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;char[]&lt;/code&gt; strings are in UTF-8 format. &lt;code&gt;wchar[]&lt;/code&gt; strings are in UTF-16 format. &lt;code&gt;dchar[]&lt;/code&gt; strings are in UTF-32 format.</source>
          <target state="translated">&lt;code&gt;char[]&lt;/code&gt; 문자열은 UTF-8 형식입니다. &lt;code&gt;wchar[]&lt;/code&gt; 문자열은 UTF-16 형식입니다. &lt;code&gt;dchar[]&lt;/code&gt; 문자열은 UTF-32 형식입니다.</target>
        </trans-unit>
        <trans-unit id="f2bd0519659f995011158dca0a093bc2a43687cf" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;choices&lt;/code&gt; needs to be composed of pairs of test expressions and return expressions. Each test-expression is compared with &lt;code&gt;switchExpression&lt;/code&gt; using &lt;code&gt;pred&lt;/code&gt;(&lt;code&gt;switchExpression&lt;/code&gt; is the first argument) and if that yields true - the return expression is returned.</source>
          <target state="translated">&lt;code&gt;choices&lt;/code&gt; 은 테스트 표현식과 리턴 표현식의 쌍으로 구성되어야합니다. 각 test-expression은 &lt;code&gt;pred&lt;/code&gt; ( &lt;code&gt;switchExpression&lt;/code&gt; 이 첫 번째 인수 임)를 사용하여 &lt;code&gt;switchExpression&lt;/code&gt; 과 비교되며 true 인 경우 리턴 표현식이 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="ce5b206c240b5efd37495766481c140fd6dd85f8" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;chooseAtRuntime&lt;/code&gt; is a compile-time constant of type &lt;code&gt;size_t&lt;/code&gt; that several parameterized structures in this module recognize to mean deferral to runtime of the exact value. For example, &lt;code&gt;BitmappedBlock!(Allocator, 4096)&lt;/code&gt; (described in detail below) defines a block allocator with block size of 4096 bytes, whereas &lt;code&gt;BitmappedBlock!(Allocator, chooseAtRuntime)&lt;/code&gt; defines a block allocator that has a field storing the block size, initialized by the user.</source>
          <target state="translated">&lt;code&gt;chooseAtRuntime&lt;/code&gt; 은 &lt;code&gt;size_t&lt;/code&gt; 유형의 컴파일 타임 상수로 ,이 모듈의 여러 매개 변수화 된 구조는 정확한 값의 런타임 지연을 의미합니다. 예를 들어 &lt;code&gt;BitmappedBlock!(Allocator, 4096)&lt;/code&gt; (아래에 자세히 설명 됨)은 블록 크기가 4096 바이트 인 블록 할당자를 정의하는 반면 &lt;code&gt;BitmappedBlock!(Allocator, chooseAtRuntime)&lt;/code&gt; 은 블록 크기를 저장하는 필드가있는 블록 할당자를 정의합니다. 사용자.</target>
        </trans-unit>
        <trans-unit id="4566f06b914a580f926d5a0099020d085b440b14" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;chunk&lt;/code&gt; must be at least as large as &lt;code&gt;T&lt;/code&gt; needs and should have an alignment multiple of &lt;code&gt;T&lt;/code&gt;'s alignment.</source>
          <target state="translated">&lt;code&gt;chunk&lt;/code&gt; 큰대로 적어도해야 &lt;code&gt;T&lt;/code&gt; 의 요구 사항과의 정렬 여러 있어야한다 &lt;code&gt;T&lt;/code&gt; 의 정렬을.</target>
        </trans-unit>
        <trans-unit id="455127cdf62cc10f2c9d34b7dba0f57d384c5937" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;chunk&lt;/code&gt; must be at least as large as &lt;code&gt;T&lt;/code&gt; needs and should have an alignment multiple of &lt;code&gt;T&lt;/code&gt;'s alignment. (The size of a &lt;code&gt;class&lt;/code&gt; instance is obtained by using &lt;code&gt;_traits(classInstanceSize, T)&lt;/code&gt;).</source>
          <target state="translated">&lt;code&gt;chunk&lt;/code&gt; 큰대로 적어도해야 &lt;code&gt;T&lt;/code&gt; 의 요구 사항과의 정렬 여러 있어야한다 &lt;code&gt;T&lt;/code&gt; 의 정렬을. &lt;code&gt;class&lt;/code&gt; 인스턴스 의 크기는 &lt;code&gt;_traits(classInstanceSize, T)&lt;/code&gt; 사용하여 얻습니다 .</target>
        </trans-unit>
        <trans-unit id="5bf1191081aa876778470c09b21f3b6c55852ee1" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;chunkBy!((a,b) =&amp;gt; a[1] == b[1])([[1, 1], [1, 2], [2, 2], [2, 1]])&lt;/code&gt; returns a range containing 3 subranges: the first with just &lt;code&gt;[1, 1]&lt;/code&gt;; the second with the elements &lt;code&gt;[1, 2]&lt;/code&gt; and &lt;code&gt;[2, 2]&lt;/code&gt;; and the third with just &lt;code&gt;[2, 1]&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;chunkBy!((a,b) =&amp;gt; a[1] == b[1])([[1, 1], [1, 2], [2, 2], [2, 1]])&lt;/code&gt; 은 3 개의 하위 범위를 포함하는 범위 : &lt;code&gt;[1, 1]&lt;/code&gt; 의 첫 번째 ; 두 번째 요소 &lt;code&gt;[1, 2]&lt;/code&gt; 및 &lt;code&gt;[2, 2]&lt;/code&gt; ; 세 번째는 단지 &lt;code&gt;[2, 1]&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="6b9a3a8566809a020c68aaea90acac74e5efb03e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;chunkCount&lt;/code&gt; must not be zero, unless &lt;code&gt;source&lt;/code&gt; is also empty.</source>
          <target state="translated">&lt;code&gt;chunkCount&lt;/code&gt; &lt;code&gt;source&lt;/code&gt; 도 비어 있지 않으면 chunkCount 는 0이 아니 어야합니다 .</target>
        </trans-unit>
        <trans-unit id="e4fa67ca853568548d80d9ea722ce341af284387" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;clamp(1, 3, 6)&lt;/code&gt; returns &lt;code&gt;3&lt;/code&gt;. &lt;code&gt;clamp(4, 3, 6)&lt;/code&gt; returns &lt;code&gt;4&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;clamp(1, 3, 6)&lt;/code&gt; 은 &lt;code&gt;3&lt;/code&gt; 을 반환합니다 . &lt;code&gt;clamp(4, 3, 6)&lt;/code&gt; 은 &lt;code&gt;4&lt;/code&gt; 를 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="0e931bbc6e887a57f25ca3ea62a185b1d52c88ae" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;cmp(&quot;abc&quot;, &quot;abcd&quot;)&lt;/code&gt; is &lt;code&gt;-1&lt;/code&gt;, &lt;code&gt;cmp(&quot;abc&quot;, &quot;aba&quot;)&lt;/code&gt; is &lt;code&gt;1&lt;/code&gt;, and &lt;code&gt;cmp(&quot;abc&quot;, &quot;abc&quot;)&lt;/code&gt; is &lt;code&gt;0&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;cmp(&quot;abc&quot;, &quot;abcd&quot;)&lt;/code&gt; 는 &lt;code&gt;-1&lt;/code&gt; 이고 &lt;code&gt;cmp(&quot;abc&quot;, &quot;aba&quot;)&lt;/code&gt; 는 &lt;code&gt;1&lt;/code&gt; 이고 &lt;code&gt;cmp(&quot;abc&quot;, &quot;abc&quot;)&lt;/code&gt; 는 &lt;code&gt;0&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="35e6384e8ce379e258f83b09389948c49d161e83" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;commonPrefix(&quot;parakeet&quot;, &quot;parachute&quot;)&lt;/code&gt; returns &lt;code&gt;&quot;para&quot;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;commonPrefix(&quot;parakeet&quot;, &quot;parachute&quot;)&lt;/code&gt; 는 &lt;code&gt;&quot;para&quot;&lt;/code&gt; 를 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="df5d8088e316cfde0b98978a7ef3c894646eb3bd" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;const&lt;/code&gt; (= c)</source>
          <target state="translated">&lt;code&gt;const&lt;/code&gt; (= c)</target>
        </trans-unit>
        <trans-unit id="93ad55dd726f30a8bd9799af2132fb43bcfaf1f7" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;const&lt;/code&gt; Attribute</source>
          <target state="translated">&lt;code&gt;const&lt;/code&gt; 속성</target>
        </trans-unit>
        <trans-unit id="b0a59a87faddcc9b5e518c4dc18b7892c90c80c1" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;const&lt;/code&gt; applies to data that cannot be changed by the const reference to that data. It may, however, be changed by another reference to that same data. Const finds applications in passing data through interfaces that promise not to modify them.</source>
          <target state="translated">&lt;code&gt;const&lt;/code&gt; 는 해당 데이터에 대한 const 참조로 변경할 수없는 데이터에 적용됩니다. 그러나 동일한 데이터에 대한 다른 참조로 변경 될 수 있습니다. Const는 데이터를 수정하지 않는 인터페이스를 통해 데이터를 전달하는 응용 프로그램을 찾습니다.</target>
        </trans-unit>
        <trans-unit id="4d9a6e876791ac6f810114009c11949947079c7f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;const&lt;/code&gt; keyword</source>
          <target state="translated">&lt;code&gt;const&lt;/code&gt; 키워드</target>
        </trans-unit>
        <trans-unit id="e4ba079ff031a5bee8e6a39743aec55c4c5aff36" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;const&lt;/code&gt;, &lt;code&gt;immutable&lt;/code&gt;, &lt;code&gt;inout&lt;/code&gt;, &lt;code&gt;shared&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;const&lt;/code&gt; , &lt;code&gt;immutable&lt;/code&gt; , &lt;code&gt;inout&lt;/code&gt; , &lt;code&gt;shared&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="a3bf9d93abb5e5cd019144ad24a88a584006df22" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;const&lt;/code&gt;. When a postblit is qualified with &lt;code&gt;const&lt;/code&gt; as in &lt;code&gt;this(this) const;&lt;/code&gt; or &lt;code&gt;const this(this);&lt;/code&gt; then the postblit is succesfully called on mutable (unqualified), &lt;code&gt;const&lt;/code&gt;, and &lt;code&gt;immutable&lt;/code&gt; objects, but the postblit cannot modify the object because it regards it as &lt;code&gt;const&lt;/code&gt;; hence &lt;code&gt;const&lt;/code&gt; postblits are of limited usefulness. Example:</source>
          <target state="translated">&lt;code&gt;const&lt;/code&gt; . postblit이 &lt;code&gt;this(this) const;&lt;/code&gt; 와 같이 &lt;code&gt;const&lt;/code&gt; 로 한정된 경우 ; 또는 &lt;code&gt;const this(this);&lt;/code&gt; 그런 다음 포스트 블릿은 변경 가능 (정규화되지 않은), &lt;code&gt;const&lt;/code&gt; 및 &lt;code&gt;immutable&lt;/code&gt; 오브젝트 에 대해 성공적으로 호출 되지만 포스트 블릿은 오브젝트를 &lt;code&gt;const&lt;/code&gt; 로 간주하므로 오브젝트를 수정할 수 없습니다 . 따라서 &lt;code&gt;const&lt;/code&gt; postblits는 유용성이 제한적입니다. 예:</target>
        </trans-unit>
        <trans-unit id="cc47342e29e943cc96416253c9cc4dfa61c2b6da" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;continue&lt;/code&gt; aborts the current iteration of its enclosing loop statement, and starts the next iteration.</source>
          <target state="translated">&lt;code&gt;continue&lt;/code&gt; 는 포함 루프 명령문의 현재 반복을 중단하고 다음 반복을 시작합니다.</target>
        </trans-unit>
        <trans-unit id="f55d3c51867037260ee7b3bb73eed621d681d3b9" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;coshisinh&lt;/code&gt; is included here for convenience and for easy migration of code that uses &lt;a href=&quot;std_math#coshisinh&quot;&gt;&lt;code&gt;std.math.coshisinh&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;coshisinh&lt;/code&gt; 편의성과 &lt;a href=&quot;std_math#coshisinh&quot;&gt; &lt;code&gt;std.math.coshisinh&lt;/code&gt; &lt;/a&gt; 를 사용하는 코드를 쉽게 마이그레이션하기 위해 coshisinh 가 여기에 포함됩니다 .</target>
        </trans-unit>
        <trans-unit id="8e42ad99a10dd7cd20a1b4ee231d4706ca8c339d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;countUntil(a, b)&lt;/code&gt; returns the number of steps taken in &lt;code&gt;a&lt;/code&gt; to reach &lt;code&gt;b&lt;/code&gt;; for example, &lt;code&gt;countUntil(&quot;hello!&quot;, &quot;o&quot;)&lt;/code&gt; returns &lt;code&gt;4&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;countUntil(a, b)&lt;/code&gt; 는 &lt;code&gt;a&lt;/code&gt; 에 도달하여 &lt;code&gt;b&lt;/code&gt; 에 도달 하는 단계 수를 반환합니다 . 예를 들어 &lt;code&gt;countUntil(&quot;hello!&quot;, &quot;o&quot;)&lt;/code&gt; 는 &lt;code&gt;4&lt;/code&gt; 를 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="c628f95698b35b08f15cc1f377f06aeb25415331" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;cumulativeFold!((a, b) =&amp;gt; a + b)([1, 2, 3, 4])&lt;/code&gt; returns a lazily-evaluated range containing the successive reduced values &lt;code&gt;1&lt;/code&gt;, &lt;code&gt;3&lt;/code&gt;, &lt;code&gt;6&lt;/code&gt;, &lt;code&gt;10&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;cumulativeFold!((a, b) =&amp;gt; a + b)([1, 2, 3, 4])&lt;/code&gt; 는 연속 감소 값 &lt;code&gt;1&lt;/code&gt; , &lt;code&gt;3&lt;/code&gt; , &lt;code&gt;6&lt;/code&gt; , &lt;code&gt;10&lt;/code&gt; 을 포함하는 지연 평가 된 범위를 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="0b182a1591e1ea15b6088bb533ef38a0b3dfe450" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;deallocate&lt;/code&gt; is also supported, which is where most implementation effort and overhead of &lt;code&gt;ScopedAllocator&lt;/code&gt; go. If &lt;code&gt;deallocate&lt;/code&gt; is not needed, a simpler design combining &lt;code&gt;AllocatorList&lt;/code&gt; with &lt;code&gt;Region&lt;/code&gt; is recommended.</source>
          <target state="translated">&lt;code&gt;deallocate&lt;/code&gt; 도 지원되는데, &lt;code&gt;ScopedAllocator&lt;/code&gt; 의 대부분의 구현 노력과 오버 헤드가 발생 합니다. &lt;code&gt;deallocate&lt;/code&gt; 가 필요하지 않은 경우 &lt;code&gt;AllocatorList&lt;/code&gt; 를 &lt;code&gt;Region&lt;/code&gt; 과 결합한보다 단순한 설계 가 권장됩니다.</target>
        </trans-unit>
        <trans-unit id="c3a273cc82ac96180bffd6bc28ee735da5c11187" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;deallocate&lt;/code&gt; is defined if and only if at least one of the allocators define &lt;code&gt;deallocate&lt;/code&gt;. It works as follows. If &lt;code&gt;primary.owns(b)&lt;/code&gt;, then the request is forwarded to &lt;code&gt;primary.deallocate&lt;/code&gt; if it is defined, or is a no-op otherwise. If &lt;code&gt;primary&lt;/code&gt; does not own &lt;code&gt;b&lt;/code&gt;, then the request is forwarded to &lt;code&gt;fallback.deallocate&lt;/code&gt; if it is defined, or is a no-op otherwise.</source>
          <target state="translated">&lt;code&gt;deallocate&lt;/code&gt; 상기 할당 자의 경우 적어도 하나의 정의하면 정의 된 &lt;code&gt;deallocate&lt;/code&gt; . 다음과 같이 작동합니다. 경우 &lt;code&gt;primary.owns(b)&lt;/code&gt; , 그 요청이 전송된다 &lt;code&gt;primary.deallocate&lt;/code&gt; 이것은 정의되거나 무 조작하지 않은 경우. 경우 &lt;code&gt;primary&lt;/code&gt; 소유하지 않는 &lt;code&gt;b&lt;/code&gt; , 다음 요청이 전달됩니다 &lt;code&gt;fallback.deallocate&lt;/code&gt; 가 정의되어있는 경우, 또는 다른 조작은 행해지 지 않습니다.</target>
        </trans-unit>
        <trans-unit id="74accc0b79c91cd3ea11df6f90b09a6dd01837e0" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;decodeBack&lt;/code&gt; is a variant of &lt;a href=&quot;#decode&quot;&gt;&lt;code&gt;decode&lt;/code&gt;&lt;/a&gt; which specifically decodes the last code point. Unlike &lt;a href=&quot;#decode&quot;&gt;&lt;code&gt;decode&lt;/code&gt;&lt;/a&gt;, &lt;code&gt;decodeBack&lt;/code&gt; accepts any bidirectional range of code units (rather than just a string or random access range). It also takes the range by &lt;code&gt;ref&lt;/code&gt; and pops off the elements as it decodes them. If &lt;code&gt;numCodeUnits&lt;/code&gt; is passed in, it gets set to the number of code units which were in the code point which was decoded.</source>
          <target state="translated">&lt;code&gt;decodeBack&lt;/code&gt; 은 변종 인 &lt;a href=&quot;#decode&quot;&gt; &lt;code&gt;decode&lt;/code&gt; &lt;/a&gt; 특히 마지막 코드 포인트를 디코딩한다. &lt;a href=&quot;#decode&quot;&gt; &lt;code&gt;decode&lt;/code&gt; &lt;/a&gt; 와는 달리 , &lt;code&gt;decodeBack&lt;/code&gt; 은 문자열 또는 임의 액세스 범위가 아닌 양방향 코드 단위의 모든 범위를 허용합니다. 또한 &lt;code&gt;ref&lt;/code&gt; 로 범위를 가져 와서 요소를 디코딩 할 때 튀어 나옵니다. 경우 &lt;code&gt;numCodeUnits&lt;/code&gt; 가 전달되고,이를 디코딩 된 코드 포인트에 있던 코드 단위의 숫자로 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="67288590e0efb2949e43eabd6c7c73a4328806ba" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;decodeFront&lt;/code&gt; is a variant of &lt;a href=&quot;#decode&quot;&gt;&lt;code&gt;decode&lt;/code&gt;&lt;/a&gt; which specifically decodes the first code point. Unlike &lt;a href=&quot;#decode&quot;&gt;&lt;code&gt;decode&lt;/code&gt;&lt;/a&gt;, &lt;code&gt;decodeFront&lt;/code&gt; accepts any &lt;a href=&quot;std_range_primitives#isInputRange&quot;&gt;input range&lt;/a&gt; of code units (rather than just a string or random access range). It also takes the range by &lt;code&gt;ref&lt;/code&gt; and pops off the elements as it decodes them. If &lt;code&gt;numCodeUnits&lt;/code&gt; is passed in, it gets set to the number of code units which were in the code point which was decoded.</source>
          <target state="translated">&lt;code&gt;decodeFront&lt;/code&gt; 은 변종 인 &lt;a href=&quot;#decode&quot;&gt; &lt;code&gt;decode&lt;/code&gt; &lt;/a&gt; 특히 첫번째 코드 포인트를 디코딩한다. &lt;a href=&quot;#decode&quot;&gt; &lt;code&gt;decode&lt;/code&gt; &lt;/a&gt; 와 달리 , &lt;code&gt;decodeFront&lt;/code&gt; 는 (문자열 또는 임의 액세스 범위가 아닌) 모든 코드 단위 &lt;a href=&quot;std_range_primitives#isInputRange&quot;&gt;입력 범위&lt;/a&gt; 를 허용합니다 . 또한 &lt;code&gt;ref&lt;/code&gt; 로 범위를 가져 와서 요소를 디코딩 할 때 튀어 나옵니다. 경우 &lt;code&gt;numCodeUnits&lt;/code&gt; 가 전달되고,이를 디코딩 된 코드 포인트에 있던 코드 단위의 숫자로 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="a8839f0e531d17486dee499042f1d0072c16f817" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;delimiter&lt;/code&gt;, then it is returned unchanged.</source>
          <target state="translated">&lt;code&gt;delimiter&lt;/code&gt; 이면 변경되지 않은 상태로 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="c3ad863d355559bfb72ddf6d9a50a94c65161a75" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;deprecate&lt;/code&gt; This functions just like &lt;code&gt;abort&lt;/code&gt;, but upon cycle detection the runtime will use a flawed pre-2.072 algorithm to determine if the cycle was previously detected. If no cycles are detected in the old algorithm, execution continues, but a deprecation message is printed.</source>
          <target state="translated">&lt;code&gt;deprecate&lt;/code&gt; 이 기능은 &lt;code&gt;abort&lt;/code&gt; 처럼 작동 하지만 사이클 감지시 런타임은 결함이있는 2.072 이전 알고리즘을 사용하여 사이클이 이전에 감지되었는지 확인합니다. 이전 알고리즘에서 사이클이 감지되지 않으면 실행이 계속되지만 사용 중단 메시지가 인쇄됩니다.</target>
        </trans-unit>
        <trans-unit id="d18f1ba74723b3d893b7f7c2730705de22bb0d19" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;deprecated&lt;/code&gt; Attribute</source>
          <target state="translated">&lt;code&gt;deprecated&lt;/code&gt; 속성</target>
        </trans-unit>
        <trans-unit id="6805fd5312efcc0ca879f765f2e0c19218cf93e1" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;dg&lt;/code&gt; - custom delegate that return a string and is only called if an exception occurred</source>
          <target state="translated">&lt;code&gt;dg&lt;/code&gt; - 문자열을 반환하고 예외가 발생한 경우에만 호출되는 사용자 지정 대리자</target>
        </trans-unit>
        <trans-unit id="3f6badc39b215958c8978f7765441eb5e2a2f607" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;double.init&lt;/code&gt; if &lt;code&gt;lhs == WitnNaN.defaultValue!Lhs&lt;/code&gt;, &lt;code&gt;-1.0&lt;/code&gt; if &lt;code&gt; lhs &amp;lt; rhs&lt;/code&gt;, &lt;code&gt;0.0&lt;/code&gt; if &lt;code&gt;lhs == rhs&lt;/code&gt;, &lt;code&gt;1.0&lt;/code&gt; if &lt;code&gt;lhs &amp;gt; rhs&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;double.init&lt;/code&gt; 경우 &lt;code&gt;lhs == WitnNaN.defaultValue!Lhs&lt;/code&gt; , &lt;code&gt;-1.0&lt;/code&gt; 경우 &lt;code&gt; lhs &amp;lt; rhs&lt;/code&gt; , &lt;code&gt;0.0&lt;/code&gt; 의 경우 &lt;code&gt;lhs == rhs&lt;/code&gt; , &lt;code&gt;1.0&lt;/code&gt; 의 경우 &lt;code&gt;lhs &amp;gt; rhs&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d6287d5a0a715e9fe34f9a5e926b06c464979322" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;download(&quot;ftp.digitalmars.com/sieve.ds&quot;, &quot;/tmp/downloaded-ftp-file&quot;)&lt;/code&gt; downloads file from URL to file system.</source>
          <target state="translated">&lt;code&gt;download(&quot;ftp.digitalmars.com/sieve.ds&quot;, &quot;/tmp/downloaded-ftp-file&quot;)&lt;/code&gt; 는 URL에서 파일 시스템으로 파일을 다운로드합니다.</target>
        </trans-unit>
        <trans-unit id="ae45f410eafadc75e7784e0049dfaa9348862102" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;drop&lt;/code&gt; and &lt;code&gt;dropBack&lt;/code&gt; will only pop</source>
          <target state="translated">&lt;code&gt;drop&lt;/code&gt; 앤 드롭 &lt;code&gt;dropBack&lt;/code&gt; 은 팝만 됩니다</target>
        </trans-unit>
        <trans-unit id="92678e10b01739e363a145cad7231efe25dc368f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;dropBack&lt;/code&gt; provides the same functionality but instead calls &lt;a href=&quot;std_range_primitives#popBackN&quot;&gt;&lt;code&gt;std.range.primitives.popBackN&lt;/code&gt;&lt;/a&gt;&lt;code&gt;(range, n)&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;dropBack&lt;/code&gt; 은 동일한 기능을 제공하지만 대신 &lt;a href=&quot;std_range_primitives#popBackN&quot;&gt; &lt;code&gt;std.range.primitives.popBackN&lt;/code&gt; &lt;/a&gt; &lt;code&gt;(range, n)&lt;/code&gt; 호출합니다.</target>
        </trans-unit>
        <trans-unit id="b3dfad69b0fc743d45dfe5be856a302f4f3b612f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;dropBackOne&lt;/code&gt; provides the same functionality but instead calls &lt;code&gt;range.popBack()&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;dropBackOne&lt;/code&gt; 은 동일한 기능을 제공하지만 대신 &lt;code&gt;range.popBack()&lt;/code&gt; 호출합니다 .</target>
        </trans-unit>
        <trans-unit id="3cad355e345c645ef7c2bc148a0241cff87d3380" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;dur!&quot;msecs&quot;(5)&lt;/code&gt; or &lt;code&gt;5.msecs()&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;dur!&quot;msecs&quot;(5)&lt;/code&gt; 또는 &lt;code&gt;5.msecs()&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="c772ef4b91d8eb5af7e6be3a8a3eaa78551b8465" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;duration.&lt;/code&gt;&lt;a href=&quot;std_conv#to&quot;&gt;&lt;code&gt;to&lt;/code&gt;&lt;/a&gt;&lt;code&gt;!TickDuration()&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;duration.&lt;/code&gt;&lt;a href=&quot;std_conv#to&quot;&gt;&lt;code&gt;to&lt;/code&gt;&lt;/a&gt;&lt;code&gt;!TickDuration()&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="d36e7aa6c21b2266b972c062e2002da654f12f35" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;e.sizeof&lt;/code&gt; gives the size in bytes of the expression &lt;code&gt;e&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;e.sizeof&lt;/code&gt; 는 표현식 &lt;code&gt;e&lt;/code&gt; 의 크기를 바이트 단위로 제공합니다 .</target>
        </trans-unit>
        <trans-unit id="1ddf110e0236e48f69127ea061fd64414c28dbfa" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;e&lt;/code&gt; is an lvalue, and keep it as an lvalue since it is an argument to a &lt;code&gt;ref&lt;/code&gt; or &lt;code&gt;out&lt;/code&gt; parameter, or the operand of &lt;code&gt;&amp;amp;&lt;/code&gt; operator</source>
          <target state="translated">&lt;code&gt;e&lt;/code&gt; 는 lvalue이며 &lt;code&gt;ref&lt;/code&gt; 또는 &lt;code&gt;out&lt;/code&gt; 매개 변수에 대한 인수 이거나 &lt;code&gt;&amp;amp;&lt;/code&gt; 연산자 의 피연산자 이므로 lvalue로 유지하십시오.</target>
        </trans-unit>
        <trans-unit id="63a03c99efc9c30d70d73137984321acf547459a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;e&lt;/code&gt; must be semantically valid expression. In other words, it should not contain any &lt;code&gt;ErrorExp&lt;/code&gt;s in it. But, CTFE interpretation will cross over functions and may invoke a function that contains &lt;code&gt;ErrorStatement&lt;/code&gt; in its body. If that, the &quot;CTFE failed because of previous errors&quot; error is raised.</source>
          <target state="translated">&lt;code&gt;e&lt;/code&gt; 는 의미 상 유효한 표현이어야합니다. 즉, &lt;code&gt;ErrorExp&lt;/code&gt; 가 포함되어서는 안됩니다 . 그러나 CTFE 해석은 함수를 교차 하며 본문에 &lt;code&gt;ErrorStatement&lt;/code&gt; 가 포함 된 함수를 호출 할 수 있습니다 . 이 경우 &quot;이전 오류로 인해 CTFE 실패&quot;오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="ea2dad0d2c560452981a079bdac2e97b675022d1" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;each!writeln([1, 2, 3])&lt;/code&gt; eagerly prints the numbers &lt;code&gt;1&lt;/code&gt;, &lt;code&gt;2&lt;/code&gt; and &lt;code&gt;3&lt;/code&gt; on their own lines.</source>
          <target state="translated">&lt;code&gt;each!writeln([1, 2, 3])&lt;/code&gt; 은 숫자 &lt;code&gt;1&lt;/code&gt; , &lt;code&gt;2&lt;/code&gt; 및 &lt;code&gt;3&lt;/code&gt; 을 자신의 줄에 열심히 인쇄합니다 .</target>
        </trans-unit>
        <trans-unit id="53d24af0626c7733c499592c9ff5e9fdd21ecce3" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;each&lt;/code&gt; also supports &lt;code&gt;opApply&lt;/code&gt;-based types, so it works with e.g. &lt;a href=&quot;std_parallelism#parallel&quot;&gt;&lt;code&gt;std.parallelism.parallel&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;each&lt;/code&gt; 도 지원 &lt;code&gt;opApply&lt;/code&gt; 이 예와 함께 작동하므로, 기반 유형을 &lt;a href=&quot;std_parallelism#parallel&quot;&gt; &lt;code&gt;std.parallelism.parallel&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="931465da1e8dfbf1b466d2cd0faeeaffaad9464a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;each&lt;/code&gt; works with iterable objects which provide an index variable, along with each element</source>
          <target state="translated">&lt;code&gt;each&lt;/code&gt; 요소와 함께 인덱스 변수를 제공하는 반복 가능한 객체와 함께 작동합니다.</target>
        </trans-unit>
        <trans-unit id="d01f390bdbeb84b4919e65d81c8a05dd73291482" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;empty&lt;/code&gt; is defined if both allocators also define it.</source>
          <target state="translated">&lt;code&gt;empty&lt;/code&gt; 은 두 할당자가 모두 정의하면 정의됩니다.</target>
        </trans-unit>
        <trans-unit id="04ffa2fab19caa7316bc21ce23c836375fc7e74f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;endsWith(&quot;rocks&quot;, &quot;ks&quot;)&lt;/code&gt; returns &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;endsWith(&quot;rocks&quot;, &quot;ks&quot;)&lt;/code&gt; 는 &lt;code&gt;true&lt;/code&gt; 를 반환 합니다 .</target>
        </trans-unit>
        <trans-unit id="039258fd2a7b4225b13e358a4b74a589a22f1909" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;enforce&lt;/code&gt; is used to throw exceptions and is therefore intended to aid in error handling. It is</source>
          <target state="translated">&lt;code&gt;enforce&lt;/code&gt; 은 예외를 처리하는 데 사용되므로 오류 처리에 도움이됩니다. 그것은</target>
        </trans-unit>
        <trans-unit id="8fafbf8d3403f46d7862dbd4e094c44bc49345fd" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;enum&lt;/code&gt;s are formatted like their base value</source>
          <target state="translated">&lt;code&gt;enum&lt;/code&gt; 은 기본 값과 같은 형식입니다.</target>
        </trans-unit>
        <trans-unit id="32d81ab5c5f77a48742ebf127f581f59d3e8d4ae" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;etc.c.odbc.sql&lt;/code&gt; is the the main include for ODBC v3.0+ Core functions, corresponding to the &lt;code&gt;sql.h&lt;/code&gt; C header file. It &lt;code&gt;import&lt;/code&gt;s &lt;code&gt;public&lt;/code&gt;ly &lt;code&gt;etc.c.odbc.sqltypes&lt;/code&gt; for conformity with the C header.</source>
          <target state="translated">&lt;code&gt;etc.c.odbc.sql&lt;/code&gt; 은 &lt;code&gt;sql.h&lt;/code&gt; C 헤더 파일에 해당하는 ODBC v3.0 + Core 기능의 기본 포함입니다 . 그것은 &lt;code&gt;import&lt;/code&gt; 의 &lt;code&gt;public&lt;/code&gt; 만민 &lt;code&gt;etc.c.odbc.sqltypes&lt;/code&gt; 는 C 헤더를 준수합니다.</target>
        </trans-unit>
        <trans-unit id="493dd95c88ebdea7f9d7904c3fee52bfa826a845" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;etc.c.odbc.sqlext.d&lt;/code&gt; corresponds to the &lt;code&gt;sqlext.h&lt;/code&gt; C header file.</source>
          <target state="translated">&lt;code&gt;etc.c.odbc.sqlext.d&lt;/code&gt; 는 &lt;code&gt;sqlext.h&lt;/code&gt; C 헤더 파일에 해당 합니다.</target>
        </trans-unit>
        <trans-unit id="486a71d42d523c21eb5f4c5e3cefa083fc33dd21" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;etc.c.odbc.sqlext&lt;/code&gt; corresponds to the &lt;code&gt;sqlext.h&lt;/code&gt; C header file.</source>
          <target state="translated">&lt;code&gt;etc.c.odbc.sqlext&lt;/code&gt; 는 &lt;code&gt;sqlext.h&lt;/code&gt; C 헤더 파일에 해당 합니다.</target>
        </trans-unit>
        <trans-unit id="91b33b7c7cdf5a354414e128e0689849615d7b78" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;etc.c.odbc.sqlucode&lt;/code&gt; corresponds to the &lt;code&gt;sqlucode.h&lt;/code&gt; C include file.</source>
          <target state="translated">&lt;code&gt;etc.c.odbc.sqlucode&lt;/code&gt; 는 &lt;code&gt;sqlucode.h&lt;/code&gt; C 포함 파일에 해당 합니다.</target>
        </trans-unit>
        <trans-unit id="454779ffb1ce2972a948b6bf53de77b10d82170e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;ethis2&lt;/code&gt; if successful, null otherwise</source>
          <target state="translated">&lt;code&gt;ethis2&lt;/code&gt; 하면 ethis2 , 그렇지 않으면 null</target>
        </trans-unit>
        <trans-unit id="8e284d610007241b05a4495262aca884af842da3" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;ex&lt;/code&gt; - custom exception to be thrown. It is &lt;code&gt;lazy&lt;/code&gt; and is only created if an exception occurred</source>
          <target state="translated">&lt;code&gt;ex&lt;/code&gt; - 발생하는 커스텀 예외 그것은 인 &lt;code&gt;lazy&lt;/code&gt; 예외가 발생하는 경우에만 만들어</target>
        </trans-unit>
        <trans-unit id="9005151b0602951785e8ba2fbc90642894270124" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;execute&lt;/code&gt; and &lt;code&gt;executeShell&lt;/code&gt; start a new process using &lt;a href=&quot;#spawnProcess&quot;&gt;&lt;code&gt;spawnProcess&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#spawnShell&quot;&gt;&lt;code&gt;spawnShell&lt;/code&gt;&lt;/a&gt;, respectively, and wait for the process to complete before returning. The functions capture what the child process prints to both its standard output and standard error streams, and return this together with its exit code.</source>
          <target state="translated">&lt;code&gt;execute&lt;/code&gt; 및 &lt;code&gt;executeShell&lt;/code&gt; 은 각각 &lt;a href=&quot;#spawnProcess&quot;&gt; &lt;code&gt;spawnProcess&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#spawnShell&quot;&gt; &lt;code&gt;spawnShell&lt;/code&gt; 을&lt;/a&gt; 사용하여 새 프로세스를 시작 하고 프로세스가 완료 될 때까지 기다렸다가 반환합니다. 이 함수는 하위 프로세스가 표준 출력 및 표준 오류 스트림 모두에 인쇄하는 내용을 캡처하고 종료 코드와 함께이를 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="25a408e63ee5fdc008f0667d1e3f2484f161de72" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;expand&lt;/code&gt; is defined if and only if at least one of the allocators defines &lt;code&gt;expand&lt;/code&gt;. It works as follows. If &lt;code&gt;primary.owns(b)&lt;/code&gt;, then the request is forwarded to &lt;code&gt;primary.expand&lt;/code&gt; if it is defined, or fails (returning &lt;code&gt;false&lt;/code&gt;) otherwise. If &lt;code&gt;primary&lt;/code&gt; does not own &lt;code&gt;b&lt;/code&gt;, then the request is forwarded to &lt;code&gt;fallback.expand&lt;/code&gt; if it is defined, or fails (returning &lt;code&gt;false&lt;/code&gt;) otherwise.</source>
          <target state="translated">&lt;code&gt;expand&lt;/code&gt; 정의되어있는 경우와 정의가 할당 자의 경우에만 적어도 하나의 &lt;code&gt;expand&lt;/code&gt; . 다음과 같이 작동합니다. 경우 &lt;code&gt;primary.owns(b)&lt;/code&gt; , 그 요청이 전송된다 &lt;code&gt;primary.expand&lt;/code&gt; 그것을 정의되거나 (복귀 실패하면 &lt;code&gt;false&lt;/code&gt; 달리). 경우 &lt;code&gt;primary&lt;/code&gt; 소유하지 않는 &lt;code&gt;b&lt;/code&gt; , 다음 요청이 전달됩니다 &lt;code&gt;fallback.expand&lt;/code&gt; 가 정의되어있는 경우, 또는 (반환 실패 &lt;code&gt;false&lt;/code&gt; , 그렇지 않으면).</target>
        </trans-unit>
        <trans-unit id="a03fad7c1bd9e067282b6a7ecbfb7d33e094a76a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;expand&lt;/code&gt; is defined to forward to &lt;code&gt;ParentAllocator.expand&lt;/code&gt; (it must be also &lt;code&gt;shared&lt;/code&gt;).</source>
          <target state="translated">&lt;code&gt;expand&lt;/code&gt; 는 &lt;code&gt;ParentAllocator.expand&lt;/code&gt; 로 전달되도록 정의됩니다 ( &lt;code&gt;shared&lt;/code&gt; 해야 함 ).</target>
        </trans-unit>
        <trans-unit id="47816e4a2ec9a59899e059a111251af1df09db1a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;expi&lt;/code&gt; is included here for convenience and for easy migration of code that uses &lt;a href=&quot;std_math#expi&quot;&gt;&lt;code&gt;std.math.expi&lt;/code&gt;&lt;/a&gt;. Unlike &lt;a href=&quot;std_math#expi&quot;&gt;&lt;code&gt;std.math.expi&lt;/code&gt;&lt;/a&gt;, which uses the x87</source>
          <target state="translated">&lt;code&gt;expi&lt;/code&gt; 편의성과 &lt;a href=&quot;std_math#expi&quot;&gt; &lt;code&gt;std.math.expi&lt;/code&gt; &lt;/a&gt; 를 사용하는 코드의 쉬운 마이그레이션을 위해 expi 가 여기에 포함됩니다 . x87을 사용하는 &lt;a href=&quot;std_math#expi&quot;&gt; &lt;code&gt;std.math.expi&lt;/code&gt; &lt;/a&gt; 와 달리</target>
        </trans-unit>
        <trans-unit id="a666fac0e544127bb5b87071b0c4108b7442235d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;export&lt;/code&gt; means that any code outside the executable can access the member. &lt;code&gt;export&lt;/code&gt; is analogous to exporting definitions from a DLL.</source>
          <target state="translated">&lt;code&gt;export&lt;/code&gt; 는 실행 파일 외부의 모든 코드가 멤버에 액세스 할 수 있음을 의미합니다. &lt;code&gt;export&lt;/code&gt; 는 DLL에서 정의를 내보내는 것과 유사합니다.</target>
        </trans-unit>
        <trans-unit id="33ba0fa9a8ac23d86d958946a9de87c65b515928" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;extern (C++)&lt;/code&gt; class</source>
          <target state="translated">&lt;code&gt;extern (C++)&lt;/code&gt; 클래스</target>
        </trans-unit>
        <trans-unit id="ca577828af2e02c109ac54927bd1b37db6478559" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;extern (C++)&lt;/code&gt; interface</source>
          <target state="translated">&lt;code&gt;extern (C++)&lt;/code&gt; 인터페이스</target>
        </trans-unit>
        <trans-unit id="574b3c7b37c3e1a7f05898210e2609d55a7c9966" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;extern (C++)&lt;/code&gt; struct</source>
          <target state="translated">&lt;code&gt;extern (C++)&lt;/code&gt; 구조체</target>
        </trans-unit>
        <trans-unit id="305317a6dc1998948f72a8a8641a7ab92acd7d65" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;extern (C++)&lt;/code&gt; structs do not support virtual functions but can be used to map C++ value types.</source>
          <target state="translated">&lt;code&gt;extern (C++)&lt;/code&gt; 구조체는 가상 함수를 지원하지 않지만 C ++ 값 형식을 매핑하는 데 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4a7ada48bd1641fc57878ac99f8bcffbe1293181" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;extern(C++, class)&lt;/code&gt; and &lt;code&gt;extern(C++, struct)&lt;/code&gt; can be combined with C++ namespaces:</source>
          <target state="translated">&lt;code&gt;extern(C++, class)&lt;/code&gt; 및 &lt;code&gt;extern(C++, struct)&lt;/code&gt; 은 C ++ 네임 스페이스와 결합 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d25d14d0478f1342bfec27af6b28e317ef69344e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;far ptr&lt;/code&gt; is not relevant for flat model code.</source>
          <target state="translated">&lt;code&gt;far ptr&lt;/code&gt; 은 플랫 모델 코드와 관련이 없습니다.</target>
        </trans-unit>
        <trans-unit id="110d7c73996e6e69d6712009dfbc60270710cca8" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;filename&lt;/code&gt; may not end with a space (&lt;code&gt;' '&lt;/code&gt;) or a period (&lt;code&gt;'.'&lt;/code&gt;).</source>
          <target state="translated">&lt;code&gt;filename&lt;/code&gt; 은 공백 ( &lt;code&gt;' '&lt;/code&gt; ) 또는 마침표 ( &lt;code&gt;'.'&lt;/code&gt; )로 끝날 수 없습니다 .</target>
        </trans-unit>
        <trans-unit id="d6462d8d6673fc8802f5508b14756158d5b1d44d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;filename&lt;/code&gt; must not contain any characters whose integer representation is in the range 0-31.</source>
          <target state="translated">&lt;code&gt;filename&lt;/code&gt; 은 정수 표현이 0-31 범위의 문자를 포함하지 않아야합니다.</target>
        </trans-unit>
        <trans-unit id="4bc53882af8209667748fb8ea2bac1b8f7a1d6a4" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;filename&lt;/code&gt; must not contain any of the following</source>
          <target state="translated">&lt;code&gt;filename&lt;/code&gt; 은 다음을 포함하지 않아야합니다.</target>
        </trans-unit>
        <trans-unit id="3e6b6d43bf7966ade005e73afc8d7220b233e99c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;filter!(a =&amp;gt; a &amp;gt; 0)([1, -1, 2, 0, -3])&lt;/code&gt; iterates over elements &lt;code&gt;1&lt;/code&gt; and &lt;code&gt;2&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;filter!(a =&amp;gt; a &amp;gt; 0)([1, -1, 2, 0, -3])&lt;/code&gt; 은 요소 &lt;code&gt;1&lt;/code&gt; 및 &lt;code&gt;2&lt;/code&gt; 를 반복 합니다.</target>
        </trans-unit>
        <trans-unit id="d65e8f52696c79f08f41c7e99ceb95631c8309a4" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;filter!(predicate)(range)&lt;/code&gt; returns a new range containing only elements &lt;code&gt;x&lt;/code&gt; in &lt;code&gt;range&lt;/code&gt; for which &lt;code&gt;predicate(x)&lt;/code&gt; returns &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;filter!(predicate)(range)&lt;/code&gt; 에서만 요소가 포함 된 새로운 범위를 반환 &lt;code&gt;x&lt;/code&gt; 의 &lt;code&gt;range&lt;/code&gt; 있는 &lt;code&gt;predicate(x)&lt;/code&gt; 반환 &lt;code&gt;true&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="59d9557c846c7dfb5f62fc519414fe5786287fd1" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;find(&quot;hello world&quot;, &quot;or&quot;)&lt;/code&gt; returns &lt;code&gt;&quot;orld&quot;&lt;/code&gt; using linear search. (For binary search refer to &lt;a href=&quot;std_range#SortedRange&quot;&gt;&lt;code&gt;std.range.SortedRange&lt;/code&gt;&lt;/a&gt;.)</source>
          <target state="translated">&lt;code&gt;find(&quot;hello world&quot;, &quot;or&quot;)&lt;/code&gt; 는 선형 검색을 사용하여 &lt;code&gt;&quot;orld&quot;&lt;/code&gt; 를 반환합니다 . 이진 검색은 &lt;a href=&quot;std_range#SortedRange&quot;&gt; &lt;code&gt;std.range.SortedRange&lt;/code&gt; 를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="463012de765d32105b8129513c2f76e386958d86" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;find(&quot;hello world&quot;, boyerMooreFinder(&quot;or&quot;))&lt;/code&gt; returns &lt;code&gt;&quot;orld&quot;&lt;/code&gt; using the &lt;a href=&quot;https://en.wikipedia.org/wiki/Boyer%E2%80%93Moore_string_search_algorithm&quot;&gt; Boyer-Moore algorithm&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;find(&quot;hello world&quot;, boyerMooreFinder(&quot;or&quot;))&lt;/code&gt; 는 &lt;a href=&quot;https://en.wikipedia.org/wiki/Boyer%E2%80%93Moore_string_search_algorithm&quot;&gt;Boyer-Moore 알고리즘을&lt;/a&gt; 사용하여 &lt;code&gt;&quot;orld&quot;&lt;/code&gt; 를 반환 합니다 .</target>
        </trans-unit>
        <trans-unit id="aceb824dc701623af00fdfc39b0050aa1cc5ca45" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;find&lt;/code&gt; behaves similar to &lt;code&gt;dropWhile&lt;/code&gt; in other languages.</source>
          <target state="translated">&lt;code&gt;find&lt;/code&gt; 는 다른 언어 로 &lt;code&gt;dropWhile&lt;/code&gt; 과 유사한 동작을 합니다.</target>
        </trans-unit>
        <trans-unit id="5b74ba9237918431c22bb8a7b4f43c4a503d1135" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;find&lt;/code&gt; performs &amp;Omicron;(&lt;code&gt;walkLength(haystack)&lt;/code&gt;) evaluations of &lt;code&gt;pred&lt;/code&gt;. There are specializations that improve performance by taking advantage of &lt;a href=&quot;std_range_primitives#isBidirectionalRange&quot;&gt;bidirectional&lt;/a&gt; or &lt;a href=&quot;std_range_primitives#isRandomAccess&quot;&gt;random access&lt;/a&gt; ranges (where possible).</source>
          <target state="translated">&lt;code&gt;find&lt;/code&gt; 는 &lt;code&gt;pred&lt;/code&gt; 의 &amp;Omicron; ( &lt;code&gt;walkLength(haystack)&lt;/code&gt; ) 평가를 수행합니다 . &lt;a href=&quot;std_range_primitives#isBidirectionalRange&quot;&gt;양방향&lt;/a&gt; 또는 &lt;a href=&quot;std_range_primitives#isRandomAccess&quot;&gt;임의 액세스&lt;/a&gt; 범위 (가능한 경우) 를 이용하여 성능을 향상시키는 전문화가 있습니다.</target>
        </trans-unit>
        <trans-unit id="3a741cc4590b1272b88f9debbbf9dcbe5bc2eb5c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;findAdjacent([1, 2, 3, 3, 4])&lt;/code&gt; returns the subrange starting with two equal adjacent elements, i.e. &lt;code&gt;[3, 3, 4]&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;findAdjacent([1, 2, 3, 3, 4])&lt;/code&gt; 는 두 개의 동일한 인접한 요소, 즉 &lt;code&gt;[3, 3, 4]&lt;/code&gt; 시작하는 하위 범위를 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="4954a80a8d1e2b0bd00aa0e1771015ac0a0a59b1" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;findAmong(&quot;abcd&quot;, &quot;qcx&quot;)&lt;/code&gt; returns &lt;code&gt;&quot;cd&quot;&lt;/code&gt; because &lt;code&gt;'c'&lt;/code&gt; is among &lt;code&gt;&quot;qcx&quot;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;findAmong(&quot;abcd&quot;, &quot;qcx&quot;)&lt;/code&gt; 는 &lt;code&gt;'c'&lt;/code&gt; 가 &lt;code&gt;&quot;qcx&quot;&lt;/code&gt; 중 하나 이므로 &lt;code&gt;&quot;cd&quot;&lt;/code&gt; 를 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="16451c18369e0d82460ebf3cbe0f6d69e643b0d1" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;findSplit(&quot;abcdefg&quot;, &quot;de&quot;)&lt;/code&gt; returns the three ranges &lt;code&gt;&quot;abc&quot;&lt;/code&gt;, &lt;code&gt;&quot;de&quot;&lt;/code&gt;, and &lt;code&gt;&quot;fg&quot;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;findSplit(&quot;abcdefg&quot;, &quot;de&quot;)&lt;/code&gt; 는 세 개의 범위 &lt;code&gt;&quot;abc&quot;&lt;/code&gt; , &lt;code&gt;&quot;de&quot;&lt;/code&gt; 및 &lt;code&gt;&quot;fg&quot;&lt;/code&gt; 를 리턴합니다 .</target>
        </trans-unit>
        <trans-unit id="25c36cb151505618abe7889bcca004fa70004ac9" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;findSplit&lt;/code&gt; returns a tuple &lt;code&gt;result&lt;/code&gt; containing</source>
          <target state="translated">&lt;code&gt;findSplit&lt;/code&gt; 은 다음을 포함하는 튜플 &lt;code&gt;result&lt;/code&gt; 를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="dea2a901faeede8850674e82df6d24827cef5045" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;findSplitAfter(&quot;abcdefg&quot;, &quot;de&quot;)&lt;/code&gt; returns the two ranges &lt;code&gt;&quot;abcde&quot;&lt;/code&gt; and &lt;code&gt;&quot;fg&quot;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;findSplitAfter(&quot;abcdefg&quot;, &quot;de&quot;)&lt;/code&gt; 는 두 범위 &lt;code&gt;&quot;abcde&quot;&lt;/code&gt; 및 &lt;code&gt;&quot;fg&quot;&lt;/code&gt; 를 리턴합니다 .</target>
        </trans-unit>
        <trans-unit id="7a5a332327a9e6ea3836154ccab37e65fe922147" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;findSplitAfter&lt;/code&gt; returns a tuple &lt;code&gt;result&lt;/code&gt; containing two ranges. &lt;code&gt;result[0]&lt;/code&gt; is the portion of &lt;code&gt;haystack&lt;/code&gt; up to and including the match, and &lt;code&gt;result[1]&lt;/code&gt; is the balance of &lt;code&gt;haystack&lt;/code&gt; starting after the match. If &lt;code&gt;needle&lt;/code&gt; was not found, &lt;code&gt;result[0]&lt;/code&gt; is empty and &lt;code&gt;result[1]&lt;/code&gt; is &lt;code&gt;haystack&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;findSplitAfter&lt;/code&gt; 는 두 범위를 포함 하는 튜플 &lt;code&gt;result&lt;/code&gt; 를 반환 합니다. &lt;code&gt;result[0]&lt;/code&gt; 은 일치까지 의 &lt;code&gt;haystack&lt;/code&gt; 부분이며 , &lt;code&gt;result[1]&lt;/code&gt; 은 일치 후에 시작 하는 &lt;code&gt;haystack&lt;/code&gt; 의 균형입니다 . 경우 &lt;code&gt;needle&lt;/code&gt; 없는 한, &lt;code&gt;result[0]&lt;/code&gt; 비어 인 &lt;code&gt;result[1]&lt;/code&gt; 인 &lt;code&gt;haystack&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="dbd528c44f7da153b86040e16bf3eb34ac8884af" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;findSplitBefore(&quot;abcdefg&quot;, &quot;de&quot;)&lt;/code&gt; returns the two ranges &lt;code&gt;&quot;abc&quot;&lt;/code&gt; and &lt;code&gt;&quot;defg&quot;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;findSplitBefore(&quot;abcdefg&quot;, &quot;de&quot;)&lt;/code&gt; 는 두 개의 범위 &lt;code&gt;&quot;abc&quot;&lt;/code&gt; 및 &lt;code&gt;&quot;defg&quot;&lt;/code&gt; 를 리턴합니다 .</target>
        </trans-unit>
        <trans-unit id="8aa1b48a6404736eb0e5593fc1439a4e0704881d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;findSplitBefore&lt;/code&gt; returns a tuple &lt;code&gt;result&lt;/code&gt; containing two ranges. &lt;code&gt;result[0]&lt;/code&gt; is the portion of &lt;code&gt;haystack&lt;/code&gt; before &lt;code&gt;needle&lt;/code&gt;, and &lt;code&gt;result[1]&lt;/code&gt; is the balance of &lt;code&gt;haystack&lt;/code&gt; starting with the match. If &lt;code&gt;needle&lt;/code&gt; was not found, &lt;code&gt;result[0]&lt;/code&gt; comprehends &lt;code&gt;haystack&lt;/code&gt; entirely and &lt;code&gt;result[1]&lt;/code&gt; is empty.</source>
          <target state="translated">&lt;code&gt;findSplitBefore&lt;/code&gt; 는 두 범위를 포함 하는 튜플 &lt;code&gt;result&lt;/code&gt; 를 반환 합니다. &lt;code&gt;result[0]&lt;/code&gt; 은 &lt;code&gt;needle&lt;/code&gt; 이전 의 &lt;code&gt;haystack&lt;/code&gt; 부분 이며 &lt;code&gt;result[1]&lt;/code&gt; 은 일치로 시작하는 &lt;code&gt;haystack&lt;/code&gt; 의 균형입니다 . 경우 &lt;code&gt;needle&lt;/code&gt; 없는 한, &lt;code&gt;result[0]&lt;/code&gt; 알겠지만는 &lt;code&gt;haystack&lt;/code&gt; 전적으로 및 &lt;code&gt;result[1]&lt;/code&gt; 비어있다.</target>
        </trans-unit>
        <trans-unit id="2a17297b469e0d45acc481afe01915097c421c8b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;fold!((a, b) =&amp;gt; a + b)([1, 2, 3, 4])&lt;/code&gt; returns &lt;code&gt;10&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;fold!((a, b) =&amp;gt; a + b)([1, 2, 3, 4])&lt;/code&gt; 는 &lt;code&gt;10&lt;/code&gt; 을 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="348e97cd2ed7107060d1b3285fa4dbc81dd2cffb" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;fold&lt;/code&gt; is functionally equivalent to &lt;a href=&quot;#reduce&quot;&gt;&lt;code&gt;reduce&lt;/code&gt;&lt;/a&gt; except the range parameter comes first and there is no need to use &lt;a href=&quot;std_typecons#tuple&quot;&gt; &lt;code&gt;tuple&lt;/code&gt;&lt;/a&gt; for multiple seeds.</source>
          <target state="translated">&lt;code&gt;fold&lt;/code&gt; 는 range 매개 변수가 먼저 나오고 여러 시드에 &lt;a href=&quot;std_typecons#tuple&quot;&gt; &lt;code&gt;tuple&lt;/code&gt; &lt;/a&gt; 을 사용할 필요가 없다는 점을 제외하면 기능적으로 &lt;a href=&quot;#reduce&quot;&gt; &lt;code&gt;reduce&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="1c5d9f4eccff4639d1f58c3663f02fcb0724c0e2" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;foreach&lt;/code&gt; iteration uses opApply, since one delegate call per loop iteration is faster than three virtual function calls.</source>
          <target state="translated">&lt;code&gt;foreach&lt;/code&gt; 루프 반복마다 하나의 델리게이트 호출이 세 개의 가상 함수 호출보다 빠르기 때문에 foreach 반복은 opApply를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="110a86b489c1c1a0ba5523c061f671f89d25d3ce" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;forwardMsg&lt;/code&gt; will ensure proper synchronization and then call &lt;code&gt;writeLogMsg&lt;/code&gt;. This is an API for implementing your own loggers and should not be called by normal user code. A notable difference from other logging functions is that the &lt;code&gt;globalLogLevel&lt;/code&gt; wont be evaluated again since it is assumed that the caller already checked that.</source>
          <target state="translated">&lt;code&gt;forwardMsg&lt;/code&gt; 는 적절한 동기화를 보장 한 다음 &lt;code&gt;writeLogMsg&lt;/code&gt; 를 호출 합니다 . 이것은 자신의 로거를 구현하기위한 API이며 일반 사용자 코드로 호출하면 안됩니다. 다른 로깅 기능과의 현저한 차이점 은 호출자가 이미 확인한 것으로 가정하기 때문에 &lt;code&gt;globalLogLevel&lt;/code&gt; 이 다시 평가되지 않는다는 것입니다.</target>
        </trans-unit>
        <trans-unit id="d65fa22650a0b8a3eb196a6250ab4fff48eaa821" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;from&lt;/code&gt; reinterpreted as &lt;code&gt;TTo[]&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;from&lt;/code&gt; 으로서 재 해석 &lt;code&gt;TTo[]&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="c0a306783b5406bdc03554e654b13fe88160475b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;fun(t.get).nullable&lt;/code&gt; if &lt;code&gt;!t.isNull&lt;/code&gt;, else &lt;code&gt;Nullable.init&lt;/code&gt;.  See also: &lt;a href=&quot;https://en.wikipedia.org/wiki/Monad_(functional_programming)#The_Maybe_monad&quot;&gt;The &lt;code&gt;Maybe&lt;/code&gt; monad&lt;/a&gt;</source>
          <target state="translated">&lt;code&gt;fun(t.get).nullable&lt;/code&gt; &lt;code&gt;!t.isNull&lt;/code&gt; 이면 fun (t.get) .nullable 이고 , 그렇지 않으면 &lt;code&gt;Nullable.init&lt;/code&gt; 입니다. 참조 : &lt;a href=&quot;https://en.wikipedia.org/wiki/Monad_(functional_programming)#The_Maybe_monad&quot;&gt; &lt;code&gt;Maybe&lt;/code&gt; &lt;/a&gt; 모나드</target>
        </trans-unit>
        <trans-unit id="a038dd88a5733c8b2a2fa8c9ddcfa7967abb774f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;fun&lt;/code&gt; must be @safe or @trusted.</source>
          <target state="translated">&lt;code&gt;fun&lt;/code&gt; 은 @safe 또는 @trusted 여야합니다.</target>
        </trans-unit>
        <trans-unit id="9b954ea7606d866416b11b50a60545717b5a9a21" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;fun&lt;/code&gt; must not return by reference.</source>
          <target state="translated">&lt;code&gt;fun&lt;/code&gt; 는 참조로 반환해서는 안됩니다.</target>
        </trans-unit>
        <trans-unit id="47805b817580eb31fc0ac75d4b6cb18c9ae0d5b1" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;func&lt;/code&gt; takes a template parameter &lt;code&gt;T&lt;/code&gt; and a runtime parameter, &lt;code&gt;x&lt;/code&gt;. &lt;code&gt;T&lt;/code&gt; is a placeholder identifier that can accept any type. In this case &lt;code&gt;T&lt;/code&gt; can be inferred from the runtime argument type.</source>
          <target state="translated">&lt;code&gt;func&lt;/code&gt; 는 템플릿 매개 변수 &lt;code&gt;T&lt;/code&gt; 와 런타임 매개 변수 &lt;code&gt;x&lt;/code&gt; 를 사용 합니다. &lt;code&gt;T&lt;/code&gt; 는 모든 유형을 허용 할 수있는 자리 표시 자 식별자입니다. 이 경우 런타임 인수 유형에서 &lt;code&gt;T&lt;/code&gt; 를 유추 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a5a1dd63a3ea288980aa5f1118ceb9e3611d769f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;gapWeightedSimilarity&lt;/code&gt; is useful wherever a smooth similarity measure between sequences allowing for approximate matches is needed. The examples above are given with words, but any sequences with elements comparable for equality are allowed, e.g. characters or numbers. &lt;code&gt;gapWeightedSimilarity&lt;/code&gt; uses a highly optimized dynamic programming implementation that needs &lt;code&gt;16 * min(s.length, t.length)&lt;/code&gt; extra bytes of memory and &amp;Omicron;(&lt;code&gt;s.length * t.length&lt;/code&gt;) time to complete.</source>
          <target state="translated">&lt;code&gt;gapWeightedSimilarity&lt;/code&gt; 는 대략적인 일치를 허용하는 시퀀스 간의 부드러운 유사성 측정이 필요한 경우 유용합니다. 위의 예는 단어와 함께 제공되지만 문자 또는 숫자와 같이 동등에 필적하는 요소를 가진 모든 시퀀스가 ​​허용됩니다. &lt;code&gt;gapWeightedSimilarity&lt;/code&gt; 는 &lt;code&gt;16 * min(s.length, t.length)&lt;/code&gt; 추가 바이트 메모리와 &amp;Omicron; ( &lt;code&gt;s.length * t.length&lt;/code&gt; ) 시간 이 필요한 고도로 최적화 된 동적 프로그래밍 구현을 사용합니다 .</target>
        </trans-unit>
        <trans-unit id="3959a0b351f7ec8406be31ce94953a1866110474" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;get(&quot;dlang.org&quot;)&lt;/code&gt; returns a char[] containing the dlang.org web page.</source>
          <target state="translated">&lt;code&gt;get(&quot;dlang.org&quot;)&lt;/code&gt; 는 dlang.org 웹 페이지를 포함하는 char []를 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="5e9e6f3319f03a2f023ac7b33c656ba598442179" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;goto&lt;/code&gt; transfers to the statement labeled with</source>
          <target state="translated">&lt;code&gt;goto&lt;/code&gt; 으로 표시 문에 전송</target>
        </trans-unit>
        <trans-unit id="efdd57ae0124db505495be1ff22bae5b4ccb4fad" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;group([5, 2, 2, 3, 3])&lt;/code&gt; returns a range containing the tuples &lt;code&gt;tuple(5, 1)&lt;/code&gt;, &lt;code&gt;tuple(2, 2)&lt;/code&gt;, and &lt;code&gt;tuple(3, 2)&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;group([5, 2, 2, 3, 3])&lt;/code&gt; 은 튜플 &lt;code&gt;tuple(5, 1)&lt;/code&gt; , &lt;code&gt;tuple(2, 2)&lt;/code&gt; 및 &lt;code&gt;tuple(3, 2)&lt;/code&gt; 포함하는 범위를 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="06dafad0eef61a654d008ef7ea92cffe8261aeee" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;haystack&lt;/code&gt; advanced such that &lt;code&gt;needle&lt;/code&gt; is a prefix of it (if no such position exists, returns &lt;code&gt;haystack&lt;/code&gt; advanced to termination).</source>
          <target state="translated">&lt;code&gt;haystack&lt;/code&gt; advanced ( &lt;code&gt;needle&lt;/code&gt; 이 접두사 임) (해당 위치가 없으면 &lt;code&gt;haystack&lt;/code&gt; advanced를 종료로 반환 )</target>
        </trans-unit>
        <trans-unit id="1342092e3ae92bd56e1008e1700f839172dc6d62" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;haystack&lt;/code&gt; advanced such that the front element is the one searched for; that is, until &lt;code&gt;binaryFun!pred(haystack.front, needle)&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;. If no such position exists, returns an empty &lt;code&gt;haystack&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;haystack&lt;/code&gt; 는 전방 요소가 검색된 것과 같이 전진했다; 때까지 즉, &lt;code&gt;binaryFun!pred(haystack.front, needle)&lt;/code&gt; 입니다 &lt;code&gt;true&lt;/code&gt; . 그러한 위치가 존재하지 않으면 빈 &lt;code&gt;haystack&lt;/code&gt; 을 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="3a7709f5444c09b2db5958f871fde3a58239214d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;helpWanted&lt;/code&gt; is set if the option &lt;code&gt;--help&lt;/code&gt; or &lt;code&gt;-h&lt;/code&gt; was passed to the option parser.</source>
          <target state="translated">&lt;code&gt;helpWanted&lt;/code&gt; 는 &lt;code&gt;--help&lt;/code&gt; 또는 &lt;code&gt;-h&lt;/code&gt; 옵션이 옵션 파서에 전달 된 경우 설정됩니다 .</target>
        </trans-unit>
        <trans-unit id="90b47fb385002d5be035355df9fcf1c2d63722b3" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;high &amp;gt;= min&lt;/code&gt;, or &lt;code&gt;minSize == chooseAtRuntime&lt;/code&gt; and &lt;code&gt;min&lt;/code&gt; has not yet been initialized. Also &lt;code&gt;high &amp;gt;= (void*).sizeof&lt;/code&gt;. Also, no allocation has been yet done with this allocator.</source>
          <target state="translated">&lt;code&gt;high &amp;gt;= min&lt;/code&gt; 또는 &lt;code&gt;minSize == chooseAtRuntime&lt;/code&gt; 이며 &lt;code&gt;min&lt;/code&gt; 은 아직 초기화되지 않았습니다. 또한 &lt;code&gt;high &amp;gt;= (void*).sizeof&lt;/code&gt; 입니다. 또한이 할당기로 할당이 아직 완료되지 않았습니다.</target>
        </trans-unit>
        <trans-unit id="0aa929a94bde73d993953027e9e45983b2a25faf" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;hook&lt;/code&gt; is a member variable if it has state, or an alias for &lt;code&gt;Hook&lt;/code&gt; otherwise.</source>
          <target state="translated">&lt;code&gt;hook&lt;/code&gt; 은 상태가있는 멤버 변수이거나 그렇지 않은 경우 &lt;code&gt;Hook&lt;/code&gt; 의 별명입니다 .</target>
        </trans-unit>
        <trans-unit id="e30039c28096c73c13dc10d17a63e8d65082ed94" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;ignore&lt;/code&gt; Do not abort execution or print any cycles. When cycles are present, order of static construction is implementation defined, and not guaranteed to be valid.</source>
          <target state="translated">&lt;code&gt;ignore&lt;/code&gt; 실행을 중단하거나주기를 인쇄하지 마십시오. 사이클이 존재할 때, 정적 구성의 순서는 구현이 정의되며 유효하지는 않습니다.</target>
        </trans-unit>
        <trans-unit id="2900fa2143c8a9554a50e42157ae7de4e9a10d57" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;immutable&lt;/code&gt; (= i)</source>
          <target state="translated">&lt;code&gt;immutable&lt;/code&gt; (= i)</target>
        </trans-unit>
        <trans-unit id="71481ed3d36e92db19dd7c5a87a5f2c82034d7cb" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;immutable&lt;/code&gt; Attribute</source>
          <target state="translated">&lt;code&gt;immutable&lt;/code&gt; 속성</target>
        </trans-unit>
        <trans-unit id="4492f625b3c03c9e03748ad120820e2cb2e70cc8" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;immutable&lt;/code&gt; applies to data that cannot change. Immutable data values, once constructed, remain the same for the duration of the program's execution. Immutable data can be placed in ROM (Read Only Memory) or in memory pages marked by the hardware as read only. Since immutable data does not change, it enables many opportunities for program optimization, and has applications in functional style programming.</source>
          <target state="translated">&lt;code&gt;immutable&lt;/code&gt; 은 변경할 수없는 데이터에 적용됩니다. 변경 불가능한 데이터 값은 일단 구성되면 프로그램 실행 기간 동안 동일하게 유지됩니다. 변경 불가능한 데이터는 ROM (읽기 전용 메모리) 또는 하드웨어에서 읽기 전용으로 표시된 메모리 페이지에 배치 할 수 있습니다. 불변 데이터는 변경되지 않기 때문에 프로그램 최적화를위한 많은 기회가 가능하며 기능적 스타일 프로그래밍에 응용 프로그램이 있습니다.</target>
        </trans-unit>
        <trans-unit id="436d66a299b3ac0c65e6f16abd43ab92f216596e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;immutable&lt;/code&gt; keyword</source>
          <target state="translated">&lt;code&gt;immutable&lt;/code&gt; 키워드</target>
        </trans-unit>
        <trans-unit id="c2df067ae666f1bc5a565ba7a7986dc9010e82b8" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;immutable&lt;/code&gt;. When a postblit is qualified with &lt;code&gt;immutable&lt;/code&gt; as in &lt;code&gt;this(this) immutable&lt;/code&gt; or &lt;code&gt;immutable this(this)&lt;/code&gt; the code is ill-formed. The &lt;code&gt;immutable&lt;/code&gt; postblit passes the compilation phase but cannot be invoked. Example:</source>
          <target state="translated">&lt;code&gt;immutable&lt;/code&gt; . postblit이 &lt;code&gt;this(this) immutable&lt;/code&gt; 또는 &lt;code&gt;immutable this(this)&lt;/code&gt; 와 같이 &lt;code&gt;immutable&lt;/code&gt; 으로 정규화 되면 코드가 잘못 형성됩니다. &lt;code&gt;immutable&lt;/code&gt; postblit은 컴파일 단계를 통과하지만 호출 할 수 없습니다. 예:</target>
        </trans-unit>
        <trans-unit id="ad0072c6746bc27e24f45537eafcbb149a3d4312" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;in&lt;/code&gt; operator. Check to see if the given element exists in the container.</source>
          <target state="translated">&lt;code&gt;in&lt;/code&gt; 오퍼레이터. 주어진 요소가 컨테이너에 존재하는지 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="a9f30f56c33bc12f05c33f96f90e1facd80a129f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;include&lt;/code&gt; can be called multiple times, but a &lt;code&gt;static foreach&lt;/code&gt; should be expanded at most once. Achieved by caching the result of the first call. We need both &lt;code&gt;cached&lt;/code&gt; and &lt;code&gt;cache&lt;/code&gt;, because &lt;code&gt;null&lt;/code&gt; is a valid value for &lt;code&gt;cache&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;include&lt;/code&gt; 는 여러 번 호출 할 수 있지만 &lt;code&gt;static foreach&lt;/code&gt; 는 최대 한 번 확장해야합니다. 첫 번째 호출 결과를 캐싱하여 달성합니다. &lt;code&gt;null&lt;/code&gt; 은 &lt;code&gt;cache&lt;/code&gt; 에 유효한 값 이므로 &lt;code&gt;cached&lt;/code&gt; 와 &lt;code&gt;cache&lt;/code&gt; 가 모두 필요 합니다 .</target>
        </trans-unit>
        <trans-unit id="44ae195465b408cf88051622b07be00d82f8e415" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;inout const&lt;/code&gt; (= wc)</source>
          <target state="translated">&lt;code&gt;inout const&lt;/code&gt; (= 화장실)</target>
        </trans-unit>
        <trans-unit id="550f2068280d8918c09f917242e8703c16af0b11" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;inout ref&lt;/code&gt; parameters imply the &lt;code&gt;return&lt;/code&gt; attribute.</source>
          <target state="translated">&lt;code&gt;inout ref&lt;/code&gt; 매개 변수는 &lt;code&gt;return&lt;/code&gt; 특성을 의미 합니다.</target>
        </trans-unit>
        <trans-unit id="8ff88e48057de7710ee582351fabcc94618d3e37" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;inout&lt;/code&gt; (= w)</source>
          <target state="translated">&lt;code&gt;inout&lt;/code&gt; (= w)</target>
        </trans-unit>
        <trans-unit id="efb4702b3ddeb95b18625f1d83639e13135ca271" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;inout&lt;/code&gt; Attribute</source>
          <target state="translated">&lt;code&gt;inout&lt;/code&gt; 속성</target>
        </trans-unit>
        <trans-unit id="5081215deaf6187f6bbf3fd090202c23c801d59e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;input&lt;/code&gt; and the returned value will share the same tail (see &lt;a href=&quot;std_array#sameTail&quot;&gt;&lt;code&gt;std.array.sameTail&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="translated">&lt;code&gt;input&lt;/code&gt; 값과 반환 값은 동일한 꼬리를 공유합니다 ( &lt;a href=&quot;std_array#sameTail&quot;&gt; &lt;code&gt;std.array.sameTail&lt;/code&gt; &lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="dfe4937f2a62392719a9715f9ba67a8b5935be9d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;input&lt;/code&gt; stripped of leading whitespace or characters specified in the second argument.</source>
          <target state="translated">&lt;code&gt;input&lt;/code&gt; 두 번째 인수에 지정된 선행 공백 또는 문자 박탈.</target>
        </trans-unit>
        <trans-unit id="f7c4a45e70d8feffbee29baa015d55bb36b53552" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;inputPath&lt;/code&gt; with the tilde expanded, or just &lt;code&gt;inputPath&lt;/code&gt; if it could not be expanded. For Windows, &lt;code&gt;expandTilde&lt;/code&gt; merely returns its argument &lt;code&gt;inputPath&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;inputPath&lt;/code&gt; 물결표와는 확장 또는 &lt;code&gt;inputPath&lt;/code&gt; 가 확장 할 수없는 경우. Windows의 경우 &lt;code&gt;expandTilde&lt;/code&gt; 는 단순히 인수 &lt;code&gt;inputPath&lt;/code&gt; 를 리턴합니다 .</target>
        </trans-unit>
        <trans-unit id="084278a1724aad084c8a91d99892ec68cf516c2e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;is&lt;/code&gt; and &lt;code&gt;!is&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;is&lt;/code&gt; 와 &lt;code&gt;!is&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="c6071e4e2b023d8249ec4ccd3e337fffdf3c94c9" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;isAssignable&lt;/code&gt; returns whether both an lvalue and rvalue can be assigned.</source>
          <target state="translated">&lt;code&gt;isAssignable&lt;/code&gt; 은 lvalue와 rvalue를 모두 할당 할 수 있는지 여부를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="66879705a4dc657173ac2d5753a2cb2b985201d0" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;isNarrowString&lt;/code&gt; to be converted to an array of &lt;code&gt;dchar&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;isNarrowString&lt;/code&gt; &lt;code&gt;dchar&lt;/code&gt; 배열로 변환</target>
        </trans-unit>
        <trans-unit id="ecb92a876691a04ff916735fdb76c540fac9e376" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;isNull&lt;/code&gt; must be &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;isNull&lt;/code&gt; 은 &lt;code&gt;false&lt;/code&gt; 여야합니다 .</target>
        </trans-unit>
        <trans-unit id="c9fe38cab0466125758effcc8010350c52973f9a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;isPartitioned!&quot;a &amp;lt; 0&quot;([-1, -2, 1, 0, 2])&lt;/code&gt; returns &lt;code&gt;true&lt;/code&gt; because the predicate is &lt;code&gt;true&lt;/code&gt; for a portion of the range and &lt;code&gt;false&lt;/code&gt; afterwards.</source>
          <target state="translated">&lt;code&gt;isPartitioned!&quot;a &amp;lt; 0&quot;([-1, -2, 1, 0, 2])&lt;/code&gt; 는 술어가 범위의 일부에 대해 &lt;code&gt;true&lt;/code&gt; 이고 이후에 &lt;code&gt;false&lt;/code&gt; 이므로 true 를 리턴 &lt;code&gt;true&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="dddbca49d1d853191ca6e06fd51d81def37636c9" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;isPermutation([1, 2], [2, 1])&lt;/code&gt; returns &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;isPermutation([1, 2], [2, 1])&lt;/code&gt; 은 &lt;code&gt;true&lt;/code&gt; 를 반환 합니다 .</target>
        </trans-unit>
        <trans-unit id="5ede47dcbc7a2deb630d825388c29438f3a2f9bc" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;isSameLength([1, 2, 3], [4, 5, 6])&lt;/code&gt; returns &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;isSameLength([1, 2, 3], [4, 5, 6])&lt;/code&gt; 는 &lt;code&gt;true&lt;/code&gt; 를 반환 합니다 .</target>
        </trans-unit>
        <trans-unit id="22dbb64f1eb66960d30cdd0d045a91b4bebc460a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;isSorted([1, 1, 2, 3])&lt;/code&gt; returns &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;isSorted([1, 1, 2, 3])&lt;/code&gt; 는 &lt;code&gt;true&lt;/code&gt; 를 반환 합니다 .</target>
        </trans-unit>
        <trans-unit id="95020a0d026466773d6e7d2d4a1d82c17a6cdd7d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;isStrictlyMonotonic([1, 1, 2, 3])&lt;/code&gt; returns &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;isStrictlyMonotonic([1, 1, 2, 3])&lt;/code&gt; 은 &lt;code&gt;false&lt;/code&gt; 를 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="e139cb4c8e4b1cc92d499904e7985ee32759ecff" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;joiner([&quot;hello&quot;, &quot;world!&quot;], &quot;; &quot;)&lt;/code&gt; returns a range that iterates over the characters &lt;code&gt;&quot;hello; world!&quot;&lt;/code&gt;. No new string is created - the existing inputs are iterated.</source>
          <target state="translated">&lt;code&gt;joiner([&quot;hello&quot;, &quot;world!&quot;], &quot;; &quot;)&lt;/code&gt; 는 &lt;code&gt;&quot;hello; world!&quot;&lt;/code&gt; 문자를 반복하는 범위를 반환합니다 . . 새 문자열이 작성되지 않습니다. 기존 입력이 반복됩니다.</target>
        </trans-unit>
        <trans-unit id="3e315f86bc48178511e8543de42af5b89ad43fa0" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;levenshteinDistance(&quot;kitten&quot;, &quot;sitting&quot;)&lt;/code&gt; returns &lt;code&gt;3&lt;/code&gt; by using the &lt;a href=&quot;https://en.wikipedia.org/wiki/Levenshtein_distance&quot;&gt; Levenshtein distance algorithm&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;levenshteinDistance(&quot;kitten&quot;, &quot;sitting&quot;)&lt;/code&gt; 는 &lt;a href=&quot;https://en.wikipedia.org/wiki/Levenshtein_distance&quot;&gt;Levenshtein 거리 알고리즘&lt;/a&gt; 을 사용하여 &lt;code&gt;3&lt;/code&gt; 을 반환 합니다 .</target>
        </trans-unit>
        <trans-unit id="9909ab215a345d0b27a717c33e2385edf613ac2f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;levenshteinDistanceAndPath(&quot;kitten&quot;, &quot;sitting&quot;)&lt;/code&gt; returns &lt;code&gt;tuple(3, &quot;snnnsni&quot;)&lt;/code&gt; by using the &lt;a href=&quot;https://en.wikipedia.org/wiki/Levenshtein_distance&quot;&gt; Levenshtein distance algorithm&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;levenshteinDistanceAndPath(&quot;kitten&quot;, &quot;sitting&quot;)&lt;/code&gt; 는 &lt;a href=&quot;https://en.wikipedia.org/wiki/Levenshtein_distance&quot;&gt;Levenshtein 거리 알고리즘&lt;/a&gt; 을 사용하여 &lt;code&gt;tuple(3, &quot;snnnsni&quot;)&lt;/code&gt; 를 반환 합니다 .</target>
        </trans-unit>
        <trans-unit id="043c4ef9c5504856de8db336671697c62d26de91" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;lhs&lt;/code&gt; and &lt;code&gt;rhs&lt;/code&gt; must be mutable. If &lt;code&gt;T&lt;/code&gt; is a struct or union, then its fields must also all be (recursively) mutable.</source>
          <target state="translated">&lt;code&gt;lhs&lt;/code&gt; 및 &lt;code&gt;rhs&lt;/code&gt; 는 변경 가능해야합니다. 경우 &lt;code&gt;T&lt;/code&gt; 는 구조체 또는 노동 조합은 다음의 필드는 모든 (재귀 적으로) 변경할 수 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="4fa27a482d0b37131f1db39d8bafd63dbc0f62a5" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;linearRemove&lt;/code&gt; functions as &lt;code&gt;remove&lt;/code&gt;, but also accepts ranges that are result the of a &lt;code&gt;take&lt;/code&gt; operation. This is a convenient way to remove a fixed amount of elements from the range.</source>
          <target state="translated">&lt;code&gt;linearRemove&lt;/code&gt; 는 &lt;code&gt;remove&lt;/code&gt; 로 기능 하지만 &lt;code&gt;take&lt;/code&gt; 작업 의 결과 인 범위도 허용합니다 . 이는 범위에서 고정 된 양의 요소를 제거하는 편리한 방법입니다.</target>
        </trans-unit>
        <trans-unit id="7ee71cc6858f0c96f71361219decb26e2942e05d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;lock&lt;/code&gt;, &lt;code&gt;rep&lt;/code&gt;, &lt;code&gt;repe&lt;/code&gt;, &lt;code&gt;repne&lt;/code&gt;, &lt;code&gt;repnz&lt;/code&gt;, &lt;code&gt;repz&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;lock&lt;/code&gt; , &lt;code&gt;rep&lt;/code&gt; , &lt;code&gt;repe&lt;/code&gt; , &lt;code&gt;repne&lt;/code&gt; , &lt;code&gt;repnz&lt;/code&gt; , &lt;code&gt;repz&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="0608ab6000f01a8274d98d95b81bd6b9a45d923b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;long&lt;/code&gt; (or &lt;code&gt;long long&lt;/code&gt;)</source>
          <target state="translated">&lt;code&gt;long&lt;/code&gt; (또는 &lt;code&gt;long long&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="25eeae832d72ed3ac287745a8b11538f1c57ec70" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;low &amp;lt;= max&lt;/code&gt;, or &lt;code&gt;maxSize == chooseAtRuntime&lt;/code&gt; and &lt;code&gt;max&lt;/code&gt; has not yet been initialized. Also, no allocation has been yet done with this allocator.</source>
          <target state="translated">&lt;code&gt;low &amp;lt;= max&lt;/code&gt; 또는 &lt;code&gt;maxSize == chooseAtRuntime&lt;/code&gt; 이며 &lt;code&gt;max&lt;/code&gt; 가 아직 초기화되지 않았습니다. 또한이 할당기로 할당이 아직 완료되지 않았습니다.</target>
        </trans-unit>
        <trans-unit id="fb726eb349abf2e37154eb8736f944062867db87" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;main()&lt;/code&gt; Function</source>
          <target state="translated">&lt;code&gt;main()&lt;/code&gt; 함수</target>
        </trans-unit>
        <trans-unit id="129c758d4ac6dd6b6924ab4249d29cb61ded7cad" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;makeIndex&lt;/code&gt; overwrites its second argument with the result, but never reallocates it.</source>
          <target state="translated">&lt;code&gt;makeIndex&lt;/code&gt; 는 두 번째 인수를 결과로 덮어 쓰지만 다시 할당하지는 않습니다.</target>
        </trans-unit>
        <trans-unit id="b7b59ca16aed965bf946f9a2c80d7fa247a48e12" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;mangledName&lt;/code&gt; is the same as builtin &lt;code&gt;.mangleof&lt;/code&gt; property, but might be more convenient in generic code, e.g. as a template argument when invoking staticMap.</source>
          <target state="translated">&lt;code&gt;mangledName&lt;/code&gt; 은 내장 &lt;code&gt;.mangleof&lt;/code&gt; 속성 과 동일 하지만 staticMap을 호출 할 때 템플릿 인수와 같이 일반 코드에서 더 편리 할 수 ​​있습니다.</target>
        </trans-unit>
        <trans-unit id="c544143563e1f74a6c402ca380463fcaef1fbc2c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;map!(a =&amp;gt; a * 2)([1, 2, 3])&lt;/code&gt; lazily returns a range with the numbers &lt;code&gt;2&lt;/code&gt;, &lt;code&gt;4&lt;/code&gt;, &lt;code&gt;6&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;map!(a =&amp;gt; a * 2)([1, 2, 3])&lt;/code&gt; 는 숫자 &lt;code&gt;2&lt;/code&gt; , &lt;code&gt;4&lt;/code&gt; , &lt;code&gt;6&lt;/code&gt; 의 범위를 느리게 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="4761b7dc7f583a3d31830f3e09d1438fb71453b0" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;map&lt;/code&gt; has more overhead than the simpler procedure used by &lt;code&gt;amap&lt;/code&gt; but avoids the need to keep all results in memory simultaneously and works with non-random access ranges.</source>
          <target state="translated">&lt;code&gt;map&lt;/code&gt; 은 &lt;code&gt;amap&lt;/code&gt; 에 의해 사용되는 간단한 절차보다 오버 헤드가 많지만 모든 결과를 동시에 메모리에 보관할 필요가 없으며 비 랜덤 액세스 범위에서 작동합니다.</target>
        </trans-unit>
        <trans-unit id="ad50cff4e88d0799e190aa7ade21aa72c4ee06e4" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;max(3, 4, 2)&lt;/code&gt; returns &lt;code&gt;4&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;max(3, 4, 2)&lt;/code&gt; 는 &lt;code&gt;4&lt;/code&gt; 를 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="15bb7ee8875811b3baf41488e3c96e099c2a02b5" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;maxCount([2, 4, 1, 4, 1])&lt;/code&gt; returns &lt;code&gt;tuple(4, 2)&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;maxCount([2, 4, 1, 4, 1])&lt;/code&gt; 은 &lt;code&gt;tuple(4, 2)&lt;/code&gt; 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="655f2b7c21e23c123906923a24f5c793344bba90" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;maxPos([2, 3, 1, 3, 4, 1])&lt;/code&gt; returns the subrange &lt;code&gt;[4, 1]&lt;/code&gt;, i.e., positions the range at the first occurrence of its maximal element.</source>
          <target state="translated">&lt;code&gt;maxPos([2, 3, 1, 3, 4, 1])&lt;/code&gt; 은 하위 범위 &lt;code&gt;[4, 1]&lt;/code&gt; 반환합니다 . 즉, 최대 요소가 처음 나타날 때 범위를 배치합니다.</target>
        </trans-unit>
        <trans-unit id="1071e9ef737014048e3bccf0ff565f1f954f2ccf" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;min(3, 4, 2)&lt;/code&gt; returns &lt;code&gt;2&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;min(3, 4, 2)&lt;/code&gt; 는 &lt;code&gt;2&lt;/code&gt; 를 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="6fff40f5a24451779daba8933602d60ed7ce2faf" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;minCount([2, 1, 1, 4, 1])&lt;/code&gt; returns &lt;code&gt;tuple(1, 3)&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;minCount([2, 1, 1, 4, 1])&lt;/code&gt; 은 &lt;code&gt;tuple(1, 3)&lt;/code&gt; 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="b8ef619f4e0a49816b959045c7488e102ae84ae5" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;minPos([2, 3, 1, 3, 4, 1])&lt;/code&gt; returns the subrange &lt;code&gt;[1, 3, 4, 1]&lt;/code&gt;, i.e., positions the range at the first occurrence of its minimal element.</source>
          <target state="translated">&lt;code&gt;minPos([2, 3, 1, 3, 4, 1])&lt;/code&gt; 은 하위 범위 &lt;code&gt;[1, 3, 4, 1]&lt;/code&gt; 반환합니다 . 즉, 최소 요소가 처음 나타날 때 범위를 배치합니다.</target>
        </trans-unit>
        <trans-unit id="ebb26ab5e762f1a839431b369278827700f15efa" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;mismatch(&quot;oh hi&quot;, &quot;ohayo&quot;)&lt;/code&gt; returns &lt;code&gt;tuple(&quot; hi&quot;, &quot;ayo&quot;)&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;mismatch(&quot;oh hi&quot;, &quot;ohayo&quot;)&lt;/code&gt; 는 &lt;code&gt;tuple(&quot; hi&quot;, &quot;ayo&quot;)&lt;/code&gt; 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="ad172e35f10a277274b0ed5b3fbcd82e3bbfd231" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;mixin(x ~ &quot;lhs&quot;)&lt;/code&gt; for unary, &lt;code&gt;mixin(&quot;lhs&quot; ~ x ~ &quot;rhs&quot;)&lt;/code&gt; for binary</source>
          <target state="translated">&lt;code&gt;mixin(x ~ &quot;lhs&quot;)&lt;/code&gt; 단항에 대한 &lt;code&gt;mixin(&quot;lhs&quot; ~ x ~ &quot;rhs&quot;)&lt;/code&gt; 바이너리에 대한</target>
        </trans-unit>
        <trans-unit id="17739b82698658d46a9e5259c44de548d2101630" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;mixin&lt;/code&gt; expressions if and only if the compilation of the expression resulting from compiling the argument(s) to &lt;code&gt;mixin&lt;/code&gt; is an lvalue;</source>
          <target state="translated">&lt;code&gt;mixin&lt;/code&gt; 인수를 &lt;code&gt;mixin&lt;/code&gt; 으로 컴파일하여 생성 된 표현식의 컴파일이 lvalue 인 경우에만 mixin 표현식 ;</target>
        </trans-unit>
        <trans-unit id="6da6e8146acef891595f833e9c41c8d7f16194fd" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;mixin&lt;/code&gt; statement</source>
          <target state="translated">&lt;code&gt;mixin&lt;/code&gt; 진술</target>
        </trans-unit>
        <trans-unit id="bcf9e8ea748e70f1cc770bfd4e8fdf662e551518" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;move(a, b)&lt;/code&gt; moves &lt;code&gt;a&lt;/code&gt; into &lt;code&gt;b&lt;/code&gt;. &lt;code&gt;move(a)&lt;/code&gt; reads &lt;code&gt;a&lt;/code&gt; destructively when necessary.</source>
          <target state="translated">&lt;code&gt;move(a, b)&lt;/code&gt; 는 &lt;code&gt;a&lt;/code&gt; 를 &lt;code&gt;b&lt;/code&gt; 로 이동 합니다 . &lt;code&gt;move(a)&lt;/code&gt; &lt;code&gt;a&lt;/code&gt; 필요할 때 파괴적으로 읽습니다 .</target>
        </trans-unit>
        <trans-unit id="6319ed7e079aa5cdd6b26c22ceb64f71bfdb61d8" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;msg&lt;/code&gt; - error message as a &lt;code&gt;string&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;msg&lt;/code&gt; - &lt;code&gt;string&lt;/code&gt; 로서의 오류 메시지</target>
        </trans-unit>
        <trans-unit id="aed62f47a9973b1a8fbc6a93da9d4ae885be19f7" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;n&lt;/code&gt; elements but will stop if the range is empty first. In other languages this is sometimes called &lt;code&gt;skip&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;n&lt;/code&gt; 요소이지만 범위가 비어 있으면 중지됩니다. 다른 언어에서는 이것을 때때로 &lt;code&gt;skip&lt;/code&gt; 라고 합니다.</target>
        </trans-unit>
        <trans-unit id="8f82b80e4b107c5455404b0aa2d60f7e17d0658e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;name&lt;/code&gt; and &lt;code&gt;dstName&lt;/code&gt; are always the empty string since this time zone has no DST, and while it may be meant to represent a time zone which is in the TZ Database, obviously it's not likely to be following the exact rules of any of the time zones in the TZ Database, so it makes no sense to set it.</source>
          <target state="translated">&lt;code&gt;name&lt;/code&gt; 이 시간대에는 DST가 없으므로 name 및 &lt;code&gt;dstName&lt;/code&gt; 은 항상 빈 문자열이며, TZ 데이터베이스에있는 시간대를 나타내는 것일 수도 있지만 분명히 시간대 중 하나의 정확한 규칙을 따르지 않을 것입니다 TZ 데이터베이스에서 설정하는 것은 의미가 없습니다.</target>
        </trans-unit>
        <trans-unit id="3d6734e2e3e13b6908442f1d4b994b0564c1e1b0" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;nothrow&lt;/code&gt; Attribute</source>
          <target state="translated">&lt;code&gt;nothrow&lt;/code&gt; 속성</target>
        </trans-unit>
        <trans-unit id="7a4ae3472c64b73ed1017173116c41279dd3cadb" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;null&lt;/code&gt; if &lt;code&gt;e&lt;/code&gt; is not an aggregate or if it is an aggregate that doesn't permit inlining, and the aggregate otherwise.</source>
          <target state="translated">&lt;code&gt;null&lt;/code&gt; &lt;code&gt;e&lt;/code&gt; 가 집계가 아니거나 인라인을 허용하지 않는 집계 이면 null 이고 그렇지 않으면 집계입니다.</target>
        </trans-unit>
        <trans-unit id="342db145b5532dfeb4960769e8d2ac17e8ca5092" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;null&lt;/code&gt; if not an operator overload, otherwise the lowered expression</source>
          <target state="translated">&lt;code&gt;null&lt;/code&gt; 연산자 오버로드가 아닌 경우 null , 그렇지 않은 경우 낮은 표현</target>
        </trans-unit>
        <trans-unit id="09a5f97c5f824bf4bb328e3511556aa409edc0ac" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;null&lt;/code&gt; literal is formatted as &lt;code&gt;&quot;null&quot;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;null&lt;/code&gt; 리터럴은 &lt;code&gt;&quot;null&quot;&lt;/code&gt; 로 형식이 지정됩니다 .</target>
        </trans-unit>
        <trans-unit id="7148866e024541832be10dd624dc857d377ef474" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;null&lt;/code&gt; on failure or if the requested size exceeds the remaining capacity.</source>
          <target state="translated">&lt;code&gt;null&lt;/code&gt; 실패하거나 요청 된 크기가 남은 용량을 초과하는 경우 null 입니다.</target>
        </trans-unit>
        <trans-unit id="13d3a4d132e79d8c89a8051d12f32981ae7abc4c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;null&lt;/code&gt; or &lt;code&gt;this&lt;/code&gt; expression when this declaration is a field</source>
          <target state="translated">&lt;code&gt;null&lt;/code&gt; 이 선언이 필드 인 경우는 null 또는 &lt;code&gt;this&lt;/code&gt; 식</target>
        </trans-unit>
        <trans-unit id="a15765a5e2096039162ed69d34289b746d72ae10" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;null&lt;/code&gt; represents the null value for pointers, pointers to functions, delegates, dynamic arrays, associative arrays, and class objects. If it has not already been cast to a type, it is given the singular type &lt;code&gt;typeof(null)&lt;/code&gt; and it is an exact conversion to convert it to the null value for pointers, pointers to functions, delegates, etc. After it is cast to a type, such conversions are implicit, but no longer exact.</source>
          <target state="translated">&lt;code&gt;null&lt;/code&gt; 은 포인터, 함수에 대한 포인터, 대리자, 동적 배열, 연관 배열 및 클래스 개체에 대한 null 값을 나타냅니다. 아직 유형으로 캐스트되지 않은 경우, 단일 유형 &lt;code&gt;typeof(null)&lt;/code&gt; 되며 포인터, 함수에 대한 포인터, 대리자 등에 대한 널값으로 변환하는 정확한 변환입니다. 유형, 이러한 전환은 암시 적이지만 더 이상 정확하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="6c9fcd375cb2635f126aa8c4382fed567cda668c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;obj&lt;/code&gt; must not already have a monitor.</source>
          <target state="translated">&lt;code&gt;obj&lt;/code&gt; 에는 모니터가 없어야합니다.</target>
        </trans-unit>
        <trans-unit id="53265aa7a3308ec880f4e25e7bc1b18c458fed7c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;obj&lt;/code&gt; without any modification.</source>
          <target state="translated">&lt;code&gt;obj&lt;/code&gt; 수정없이 obj .</target>
        </trans-unit>
        <trans-unit id="9a972bce84feda7e286dd14976860b2837b979c3" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;op&lt;/code&gt; is one of: TOK.lessThan, TOK.lessOrEqual, TOK.greaterThan, TOK.greaterOrEqual</source>
          <target state="translated">&lt;code&gt;op&lt;/code&gt; 는 TOK.lessThan, TOK.lessOrEqual, TOK.greaterThan, TOK.greaterOrEqual 중 하나입니다.</target>
        </trans-unit>
        <trans-unit id="e03743facb1bd4fbbad5c7ae7e1be25ba907b2ad" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;opPostMove&lt;/code&gt; will be called if defined:</source>
          <target state="translated">&lt;code&gt;opPostMove&lt;/code&gt; 다음과 같이 정의 된 경우 opPostMove 가 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="7cac9e13dbedf038b706359b0b3bfdddbff1e67a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;ordered(1, 1, 2, 3)&lt;/code&gt; returns &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;ordered(1, 1, 2, 3)&lt;/code&gt; 은 &lt;code&gt;true&lt;/code&gt; 를 반환 합니다 .</target>
        </trans-unit>
        <trans-unit id="fe01c087c1137c8c50eb31f65e4b2c604b452370" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;ordered&lt;/code&gt; allows repeated values, e.g. &lt;code&gt;ordered(1, 1, 2)&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;. To verify that the values are ordered strictly monotonically, use &lt;code&gt;strictlyOrdered&lt;/code&gt;; &lt;code&gt;strictlyOrdered(1, 1, 2)&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;ordered&lt;/code&gt; 는 반복 된 값을 허용합니다. 예를 들어 &lt;code&gt;ordered(1, 1, 2)&lt;/code&gt; 가 &lt;code&gt;true&lt;/code&gt; 입니다. 값이 엄격하게 단조롭게 정렬되어 있는지 확인하기 위해 사용 &lt;code&gt;strictlyOrdered&lt;/code&gt; ; &lt;code&gt;strictlyOrdered(1, 1, 2)&lt;/code&gt; 가 &lt;code&gt;false&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="6a5e0ca2626efd372513012144aeeb5aa2c60756" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;override&lt;/code&gt; Attribute</source>
          <target state="translated">&lt;code&gt;override&lt;/code&gt; 속성 무시</target>
        </trans-unit>
        <trans-unit id="6863469fa5d3953fc0cab9dedf798bbbdc3091fa" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;owns&lt;/code&gt; is defined if and only if both allocators define &lt;code&gt;owns&lt;/code&gt;. Returns &lt;code&gt;primary.owns(b) | fallback.owns(b)&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;owns&lt;/code&gt; 모두 할당 자 정의 경우에만이 경우 정의 &lt;code&gt;owns&lt;/code&gt; . &lt;code&gt;primary.owns(b) | fallback.owns(b)&lt;/code&gt; 반환합니다. | fallback.owns (b) .</target>
        </trans-unit>
        <trans-unit id="5c036498ea7ccc88df0ddae88726f48b50505edc" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;package&lt;/code&gt; extends private so that package members can be accessed from code in other modules that are in the same package. If no identifier is provided, this applies to the innermost package only, or defaults to &lt;code&gt;private&lt;/code&gt; if a module is not nested in a package.</source>
          <target state="translated">&lt;code&gt;package&lt;/code&gt; 는 동일한 패키지에있는 다른 모듈의 코드에서 패키지 멤버에 액세스 할 수 있도록 개인용으로 확장됩니다. 식별자가 제공되지 않으면 가장 안쪽의 패키지에만 적용되거나 모듈이 패키지에 중첩되지 않은 경우 기본적으로 &lt;code&gt;private&lt;/code&gt; 으로 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="99e9b5e43e5735f74de8ff7517e6dcba640ff75d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;package&lt;/code&gt; may have an optional parameter in the form of a dot-separated identifier list which is resolved as the qualified package name. The package must be either the module's parent package or one of its anscestors. If this optional parameter is present, the symbol will be visible in the specified package and all of its descendants.</source>
          <target state="translated">&lt;code&gt;package&lt;/code&gt; 는 한정된 패키지 이름으로 확인되는 점으로 구분 된 식별자 목록 형식의 선택적 매개 변수를 가질 수 있습니다. 패키지는 모듈의 상위 패키지이거나 그 중 하나 여야합니다. 이 선택적 매개 변수가 있으면 지정된 패키지 및 모든 하위 항목에 기호가 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="8b16f6c70937381d9273f435f11d2e00eea7e2d4" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;parent&lt;/code&gt; field returns a lexically enclosing scope symbol this is a member of.</source>
          <target state="translated">&lt;code&gt;parent&lt;/code&gt; 필드는 이것이 속한 어휘 적으로 둘러싸인 범위 기호를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="785ee288b8022b3dbdd08f20aaed022d962e94ef" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;parent&lt;/code&gt;: an alias to the overridden function (if any).</source>
          <target state="translated">&lt;code&gt;parent&lt;/code&gt; : 재정의 된 함수에 대한 별칭입니다 (있는 경우).</target>
        </trans-unit>
        <trans-unit id="e089e7b3b9b73809abfb92ef56b5e3c884a692a9" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;pastMixin&lt;/code&gt; returns the enclosing symbol if this is a template mixin.</source>
          <target state="translated">&lt;code&gt;pastMixin&lt;/code&gt; 이 템플리트 믹스 인 인 경우 둘러싸는 기호를 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="2b80008427b9535aedf9b70afeb14098e58d8e4d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;pastMixinAndNspace&lt;/code&gt; does likewise, additionally skipping over Nspaces that are mangleOnly.</source>
          <target state="translated">&lt;code&gt;pastMixinAndNspace&lt;/code&gt; 도 마찬가지로 mangleOnly 인 Nspace를 건너 뜁니다.</target>
        </trans-unit>
        <trans-unit id="c82c59282aaf3a7e7db645460bd099ce8ee421b8" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;pipeProcess&lt;/code&gt; and &lt;code&gt;pipeShell&lt;/code&gt; are convenient wrappers around &lt;a href=&quot;#spawnProcess&quot;&gt;&lt;code&gt;spawnProcess&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#spawnShell&quot;&gt;&lt;code&gt;spawnShell&lt;/code&gt;&lt;/a&gt;, respectively, and automate the task of redirecting one or more of the child process' standard streams through pipes. Like the functions they wrap, these functions return immediately, leaving the child process to execute in parallel with the invoking process. It is recommended to always call &lt;a href=&quot;#wait&quot;&gt;&lt;code&gt;wait&lt;/code&gt;&lt;/a&gt; on the returned &lt;a href=&quot;#ProcessPipes.pid&quot;&gt;&lt;code&gt;ProcessPipes.pid&lt;/code&gt;&lt;/a&gt;, as detailed in the documentation for &lt;code&gt;wait&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;pipeProcess&lt;/code&gt; 및 &lt;code&gt;pipeShell&lt;/code&gt; 은 각각 &lt;a href=&quot;#spawnProcess&quot;&gt; &lt;code&gt;spawnProcess&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#spawnShell&quot;&gt; &lt;code&gt;spawnShell&lt;/code&gt; &lt;/a&gt; 주위에 편리한 래퍼 이며 파이프를 통해 하나 이상의 자식 프로세스 표준 스트림을 리디렉션하는 작업을 자동화합니다. 랩핑하는 함수와 마찬가지로,이 함수는 즉시 리턴되어 하위 프로세스가 호출 프로세스와 동시에 실행되도록합니다. 그것은 항상 호출에 추천 &lt;a href=&quot;#wait&quot;&gt; &lt;code&gt;wait&lt;/code&gt; &lt;/a&gt; 반환에 &lt;a href=&quot;#ProcessPipes.pid&quot;&gt; &lt;code&gt;ProcessPipes.pid&lt;/code&gt; &lt;/a&gt; 에 대한 설명서에 따라 &lt;code&gt;wait&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9ebf87651ef2f151be369c9174cb3ac21dab708d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;popBackExactly&lt;/code&gt; will behave the same but instead removes elements from the back of the (bidirectional) range instead of the front.</source>
          <target state="translated">&lt;code&gt;popBackExactly&lt;/code&gt; 는 동일하게 작동하지만 대신 (양방향) 범위의 뒷면에서 요소를 제거합니다.</target>
        </trans-unit>
        <trans-unit id="765c4bc07ddeed29065f2acfd024ee4fc027cdf8" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;popBackN&lt;/code&gt; behaves the same as &lt;code&gt;popFrontN&lt;/code&gt; but instead removes elements from the back of the (bidirectional) range instead of the front.</source>
          <target state="translated">&lt;code&gt;popBackN&lt;/code&gt; 은 popFrontN 과 동일하게 &lt;code&gt;popFrontN&lt;/code&gt; 하지만 대신 앞 (양방향) 범위의 뒷면에서 요소를 제거합니다.</target>
        </trans-unit>
        <trans-unit id="be6ef5b9245c320746a5e716e6554a963c6f5b9c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;popFrontN&lt;/code&gt; eagerly advances &lt;code&gt;r&lt;/code&gt; itself (not a copy) up to &lt;code&gt;n&lt;/code&gt; times (by calling &lt;code&gt;r.popFront&lt;/code&gt;). &lt;code&gt;popFrontN&lt;/code&gt; takes &lt;code&gt;r&lt;/code&gt; by &lt;code&gt;ref&lt;/code&gt;, so it mutates the original range. Completes in &amp;Omicron;(&lt;code&gt;1&lt;/code&gt;) steps for ranges that support slicing and have length. Completes in &amp;Omicron;(&lt;code&gt;n&lt;/code&gt;) time for all other ranges.</source>
          <target state="translated">&lt;code&gt;popFrontN&lt;/code&gt; 은 &lt;code&gt;r&lt;/code&gt; 자체를 (복사본 아님) 최대 &lt;code&gt;n&lt;/code&gt; 배까지 ( &lt;code&gt;r.popFront&lt;/code&gt; 호출 하여 ) 간절히 전진 합니다 . &lt;code&gt;popFrontN&lt;/code&gt; 은 &lt;code&gt;r&lt;/code&gt; 을 &lt;code&gt;ref&lt;/code&gt; 로 가져 오므로 원래 범위를 변경합니다. 슬라이싱을 지원하고 길이가있는 범위에 대해 &amp;Omicron; ( &lt;code&gt;1&lt;/code&gt; ) 단계로 완료 합니다. 다른 모든 범위에 대해 &amp;Omicron; ( &lt;code&gt;n&lt;/code&gt; ) 시간 내에 완료 합니다.</target>
        </trans-unit>
        <trans-unit id="5e43d3f60830438c35b679ac8111772b9fd759ef" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;post(&quot;dlang.org&quot;, &quot;Hi&quot;)&lt;/code&gt; returns a char[] containing the dlang.org web page. after a HTTP POST of &quot;hi&quot;</source>
          <target state="translated">&lt;code&gt;post(&quot;dlang.org&quot;, &quot;Hi&quot;)&lt;/code&gt; 는 dlang.org 웹 페이지를 포함하는 char []를 반환합니다. &quot;hi&quot;의 HTTP POST 후</target>
        </trans-unit>
        <trans-unit id="3b56c571dc782994b2ad8a9de2f9c60b84c8d58e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;pragma&lt;/code&gt; argument</source>
          <target state="translated">&lt;code&gt;pragma&lt;/code&gt; 논쟁</target>
        </trans-unit>
        <trans-unit id="9de19508347bbfe1195e8d606a362d1a2fc4ac3d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;print&lt;/code&gt; Print all cycles detected, but do not abort execution. When cycles are present, order of static construction is implementation defined, and not guaranteed to be valid.</source>
          <target state="translated">&lt;code&gt;print&lt;/code&gt; 감지 된 모든주기를 인쇄하지만 실행을 중단하지는 않습니다. 사이클이 존재할 때, 정적 구성의 순서는 구현이 정의되며 유효하지는 않습니다.</target>
        </trans-unit>
        <trans-unit id="a6c36e16798b3bee716e3c7d1bfa395fccf04885" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;printf()&lt;/code&gt; is a C function and is not part of D. &lt;code&gt;printf()&lt;/code&gt; will print C strings, which are 0 terminated. There are two ways to use &lt;code&gt;printf()&lt;/code&gt; with D strings. The first is to add a terminating 0, and cast the result to a char*:</source>
          <target state="translated">&lt;code&gt;printf()&lt;/code&gt; 는 C 함수이며 D의 일부가 아닙니다. &lt;code&gt;printf()&lt;/code&gt; 는 0으로 끝나는 C 문자열을 인쇄합니다. D 문자열과 함께 &lt;code&gt;printf()&lt;/code&gt; 를 사용하는 방법에는 두 가지가 있습니다 . 첫 번째는 종료 0을 추가하고 결과를 char *에 캐스트하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="885eaccdd6ff3a7f55587c62f3e2ef120742b0cb" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;protected&lt;/code&gt; only applies inside classes (and templates as they can be mixed in) and means that a symbol can only be seen by members of the same module, or by a derived class. If accessing a protected instance member through a derived class member function, that member can only be accessed for the object instance which can be implicitly cast to the same type as &amp;lsquo;this&amp;rsquo;. &lt;code&gt;protected&lt;/code&gt; module members are illegal.</source>
          <target state="translated">&lt;code&gt;protected&lt;/code&gt; 는 클래스 내부 (및 템플릿이 혼합 될 수있는 템플릿)에만 적용되며 동일한 모듈의 멤버 또는 파생 클래스에서만 심볼을 볼 수 있음을 의미합니다. 파생 클래스 멤버 함수를 통해 보호 된 인스턴스 멤버에 액세스하는 경우 'this'와 동일한 유형으로 내재적으로 캐스트 할 수있는 오브젝트 인스턴스에 대해서만 해당 멤버에 액세스 할 수 있습니다. &lt;code&gt;protected&lt;/code&gt; 모듈 구성원은 불법입니다.</target>
        </trans-unit>
        <trans-unit id="58104d24c97eca4573f45c0f775fb78ad6fc3db1" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;ptrdiff_t&lt;/code&gt; is an alias to the signed integral basic type the same size as &lt;code&gt;size_t&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;ptrdiff_t&lt;/code&gt; 는 &lt;code&gt;size_t&lt;/code&gt; 와 동일한 크기의 부호있는 정수 기본 유형의 별명 입니다.</target>
        </trans-unit>
        <trans-unit id="c0c955a9b07864cb44d663b9a3edf65f6d23651e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;public&lt;/code&gt; means that any code within the executable can see the member. It is the default visibility attribute.</source>
          <target state="translated">&lt;code&gt;public&lt;/code&gt; 은 실행 파일 내의 모든 코드가 멤버를 볼 수 있음을 의미합니다. 기본 가시성 속성입니다.</target>
        </trans-unit>
        <trans-unit id="79e8d813b3487dee878c4257552cc6b79a81eafa" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;pure&lt;/code&gt; Attribute</source>
          <target state="translated">&lt;code&gt;pure&lt;/code&gt; 속성</target>
        </trans-unit>
        <trans-unit id="355e1b792f5254a4df82ea4a1c4c52dbe2ca371f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;pure&lt;/code&gt;, &lt;code&gt;nothrow&lt;/code&gt;, &lt;code&gt;@nogc&lt;/code&gt;, &lt;code&gt;@property&lt;/code&gt;, &lt;code&gt;@system&lt;/code&gt;, &lt;code&gt;@trusted&lt;/code&gt;, &lt;code&gt;@safe&lt;/code&gt;, and &lt;code&gt;ref&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;pure&lt;/code&gt; , &lt;code&gt;nothrow&lt;/code&gt; , &lt;code&gt;@nogc&lt;/code&gt; , &lt;code&gt;@property&lt;/code&gt; , &lt;code&gt;@system&lt;/code&gt; , &lt;code&gt;@trusted&lt;/code&gt; , &lt;code&gt;@safe&lt;/code&gt; 및 &lt;code&gt;ref&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="37a05e6ea71c58e0ecc8b8f22dc710971b6a30f7" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;put(&quot;dlang.org&quot;, &quot;Hi&quot;)&lt;/code&gt; returns a char[] containing the dlang.org web page. after a HTTP PUT of &quot;hi&quot;</source>
          <target state="translated">&lt;code&gt;put(&quot;dlang.org&quot;, &quot;Hi&quot;)&lt;/code&gt; 는 dlang.org 웹 페이지를 포함하는 char []를 반환합니다. &quot;hi&quot;의 HTTP PUT 이후</target>
        </trans-unit>
        <trans-unit id="ad07519f507b3041d07e3c20f839ab72ee2e1e99" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;put&lt;/code&gt; should</source>
          <target state="translated">&lt;code&gt;put&lt;/code&gt; 해야</target>
        </trans-unit>
        <trans-unit id="9a592372b6a5ac856e36481ab0ba287c9445c4e9" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;put&lt;/code&gt; treats dynamic arrays as array slices, and will call &lt;code&gt;popFront&lt;/code&gt; on the slice after an element has been copied.  Be sure to save the position of the array before calling &lt;code&gt;put&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;put&lt;/code&gt; 은 동적 배열을 배열 슬라이스로 취급 하고 요소가 복사 된 후 슬라이스에서 &lt;code&gt;popFront&lt;/code&gt; 를 호출 합니다. &lt;code&gt;put&lt;/code&gt; 을 호출하기 전에 배열의 위치를 ​​저장하십시오 .</target>
        </trans-unit>
        <trans-unit id="9193340cac39846b4cfea0d1c78fc84d0f2f893f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;r.back&lt;/code&gt; returns (possibly a reference to) the last element in the range. Calling &lt;code&gt;r.back&lt;/code&gt; is allowed only if calling &lt;code&gt;r.empty&lt;/code&gt; has, or would have, returned &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;r.back&lt;/code&gt; 은 범위의 마지막 요소를 반환합니다 (아마도 참조). 호출 &lt;code&gt;r.back&lt;/code&gt; 호출하는 경우에만 허용된다 &lt;code&gt;r.empty&lt;/code&gt; 것은 있다, 또는 반환 할 것이다 &lt;code&gt;false&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="13af710cd09013b2e064b363bf36b6cbc35fcbef" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;r.empty&lt;/code&gt; evaluated multiple times, without calling &lt;code&gt;r.popFront&lt;/code&gt;, or otherwise mutating the range object or the underlying data, yields the same result for every evaluation.</source>
          <target state="translated">&lt;code&gt;r.empty&lt;/code&gt; 를 호출하지 않고, 여러 번 평가 &lt;code&gt;r.popFront&lt;/code&gt; 을 하거나 그렇지 범위 객체 돌연변이 또는 기본 데이터, 각 평가에 대해 동일한 결과를 산출한다.</target>
        </trans-unit>
        <trans-unit id="9e47c532ad11f99cc48c6a97a263483fe2fb84ac" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;r.empty&lt;/code&gt; returns &lt;code&gt;false&lt;/code&gt; if and only if there is more data available in the range.</source>
          <target state="translated">&lt;code&gt;r.empty&lt;/code&gt; 는 범위에서 사용 가능한 데이터가 더있는 경우에만 &lt;code&gt;false&lt;/code&gt; 를 반환 합니다.</target>
        </trans-unit>
        <trans-unit id="33a82d6bd254c8ddeec0ab5cce7440aeb3a26b7f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;r.front&lt;/code&gt; can be legally evaluated if and only if evaluating &lt;code&gt;r.empty&lt;/code&gt; has, or would have, equaled &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;r.front&lt;/code&gt; 는 평가 만하고 있다면 법적으로 평가 될 수 &lt;code&gt;r.empty&lt;/code&gt; 것은 있다, 또는 것, 같게 &lt;code&gt;false&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="70a4ae757d1f6b79696d48604892d6f38fdeb2b2" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;r.front&lt;/code&gt; evaluated multiple times, without calling &lt;code&gt;r.popFront&lt;/code&gt;, or otherwise mutating the range object or the underlying data, yields the same result for every evaluation.</source>
          <target state="translated">&lt;code&gt;r.front&lt;/code&gt; 를 호출하지 않고, 여러 번 평가 &lt;code&gt;r.popFront&lt;/code&gt; 을 하거나 그렇지 범위 객체 돌연변이 또는 기본 데이터, 각 평가에 대해 동일한 결과를 산출한다.</target>
        </trans-unit>
        <trans-unit id="988cf166f117ce8d9c9381f74cc01ac3753e3cf0" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;r.front&lt;/code&gt; returns the current element in the range. It may return by value or by reference.</source>
          <target state="translated">&lt;code&gt;r.front&lt;/code&gt; 는 범위의 현재 요소를 반환합니다. 값 또는 참조로 반환 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6d03a5433bfb6e8943880060c7a7f6081694bfa9" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;r.opIndex(n)&lt;/code&gt; returns a reference to the &lt;code&gt;n&lt;/code&gt;th element in the range.</source>
          <target state="translated">&lt;code&gt;r.opIndex(n)&lt;/code&gt; 은 범위 의 &lt;code&gt;n&lt;/code&gt; 번째 요소에 대한 참조를 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="49c07d736b9df0517fbba6cc7e05a9eafafd0457" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;r.popFront&lt;/code&gt; advances to the next element in the range.</source>
          <target state="translated">&lt;code&gt;r.popFront&lt;/code&gt; 가 범위의 다음 요소로 이동합니다.</target>
        </trans-unit>
        <trans-unit id="03e39f666e8ff147ad6b6dc8a0ff7c40edcf747a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;r.popFront&lt;/code&gt; can be called if and only if evaluating &lt;code&gt;r.empty&lt;/code&gt; has, or would have, equaled &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;r.popFront&lt;/code&gt; 를 평가하는 것이 &lt;code&gt;false&lt;/code&gt; 또는 &lt;code&gt;r.empty&lt;/code&gt; 경우에만 r.popFront 를 호출 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="45425e928901d43b7c9007bba36a4e02162c3a42" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;r&lt;/code&gt; advanced to the first occurrence of two adjacent elements that satisfy the given predicate. If there are no such two elements, returns &lt;code&gt;r&lt;/code&gt; advanced until empty.</source>
          <target state="translated">&lt;code&gt;r&lt;/code&gt; 주어진 술어를 만족시키는 두 개의 인접한 요소가 처음으로 나아갔습니다. 이러한 두 요소가 없으면 비어있을 때까지 &lt;code&gt;r&lt;/code&gt; advanced를 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="11bb7f38ea0c23dd1df658dfc6cfd544881c52c5" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;r&lt;/code&gt; must be a random-access range with length. &lt;code&gt;n&lt;/code&gt; must be less than or equal to &lt;code&gt;r.length&lt;/code&gt;. If no RNG is specified, &lt;code&gt;rndGen&lt;/code&gt; will be used.</source>
          <target state="translated">&lt;code&gt;r&lt;/code&gt; 은 길이가 랜덤 액세스 범위 여야합니다. &lt;code&gt;n&lt;/code&gt; 은 &lt;code&gt;r.length&lt;/code&gt; 이하 여야합니다 . RNG를 지정하지 않으면 &lt;code&gt;rndGen&lt;/code&gt; 이 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="da6cb3cc16e9187eebb9753b8301da3699b87ada" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;r[pivot]&lt;/code&gt; is swapped to &lt;code&gt;r[k]&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;r[pivot]&lt;/code&gt; 이 &lt;code&gt;r[k]&lt;/code&gt; 바뀝니다 .</target>
        </trans-unit>
        <trans-unit id="75528cc8ea4ca3059d520e5cbbdcdb8078984b9c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;range&lt;/code&gt; with &lt;code&gt;n&lt;/code&gt; elements dropped</source>
          <target state="translated">&lt;code&gt;range&lt;/code&gt; 를 가진 &lt;code&gt;n&lt;/code&gt; 요소 삭제</target>
        </trans-unit>
        <trans-unit id="47ab73990ea3858b873e813654c0700f917d618a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;range&lt;/code&gt; with up to &lt;code&gt;n&lt;/code&gt; elements dropped</source>
          <target state="translated">&lt;code&gt;range&lt;/code&gt; 최대 &lt;code&gt;n&lt;/code&gt; 개의 요소가 떨어진 범위</target>
        </trans-unit>
        <trans-unit id="51de97b8f207a648c1f4d661babb19e96cb91a05" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;rawWrite&lt;/code&gt; always writes in binary mode on Windows.</source>
          <target state="translated">&lt;code&gt;rawWrite&lt;/code&gt; 는 항상 Windows에서 이진 모드로 씁니다.</target>
        </trans-unit>
        <trans-unit id="7e01cc52b2fb39cae323fcbb92dd524e80347e92" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;re&lt;/code&gt; parameter can be one of three types:</source>
          <target state="translated">&lt;code&gt;re&lt;/code&gt; 매개 변수는 다음 세 가지 유형 중 하나 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9f5e9e6d00cc09a02683bc78dffa8ff6fb85f34f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;real&lt;/code&gt; is not supported, because its size is implementation-dependent and therefore could vary from machine to machine (which could make it unusable if you tried to transfer it to another machine).</source>
          <target state="translated">&lt;code&gt;real&lt;/code&gt; 크기는 구현에 따라 다르므로 시스템마다 다를 수 있기 때문에 지원되지 않습니다 (다른 시스템으로 전송하려고하면 사용하지 못할 수 있음).</target>
        </trans-unit>
        <trans-unit id="8c40895248f80db003f0fbe8781e5e9f4a2a0773" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;reallocate&lt;/code&gt; does not attempt to use &lt;code&gt;Allocator.reallocate&lt;/code&gt; even if defined. This is deliberate so allocators may use it internally within their own implementation of &lt;code&gt;reallocate&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;reallocate&lt;/code&gt; 는 정의 된 경우에도 &lt;code&gt;Allocator.reallocate&lt;/code&gt; 를 사용하지 않습니다 . 이것은 의도적으로 할당 자들이 자신의 &lt;code&gt;reallocate&lt;/code&gt; 구현 내에서 내부적으로 사용할 수 있도록합니다 .</target>
        </trans-unit>
        <trans-unit id="9dd5860f115951d36e1f86e186eb1c5079118b9c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;reallocate&lt;/code&gt; works as follows. If &lt;code&gt;primary.owns(b)&lt;/code&gt;, then &lt;code&gt; primary.reallocate(b, newSize)&lt;/code&gt; is attempted. If it fails, an attempt is made to move the allocation from &lt;code&gt;primary&lt;/code&gt; to &lt;code&gt;fallback&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;reallocate&lt;/code&gt; 은 다음과 같이 작동합니다. 경우 &lt;code&gt;primary.owns(b)&lt;/code&gt; , 다음 &lt;code&gt; primary.reallocate(b, newSize)&lt;/code&gt; 시도됩니다. 실패하면 할당을 &lt;code&gt;primary&lt;/code&gt; 에서 &lt;code&gt;fallback&lt;/code&gt; 으로 이동하려고 시도 합니다 .</target>
        </trans-unit>
        <trans-unit id="e269b93fff7df8dc53d3774c6da5a14d7fb8db6f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;reduce!((a, b) =&amp;gt; a + b)([1, 2, 3, 4])&lt;/code&gt; returns &lt;code&gt;10&lt;/code&gt;. This is the old implementation of &lt;code&gt;fold&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;reduce!((a, b) =&amp;gt; a + b)([1, 2, 3, 4])&lt;/code&gt; 는 &lt;code&gt;10&lt;/code&gt; 을 반환합니다 . 이것은 &lt;code&gt;fold&lt;/code&gt; 의 이전 구현입니다 .</target>
        </trans-unit>
        <trans-unit id="71c273ae8de7dc1231647f39241604ef79ab6c96" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;ref&lt;/code&gt; Attribute</source>
          <target state="translated">&lt;code&gt;ref&lt;/code&gt; 속성</target>
        </trans-unit>
        <trans-unit id="a6f5f10cc217e4f1cac077c32c1493718928e341" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;ref&lt;/code&gt; argument through which &lt;code&gt;arg&lt;/code&gt; may be assigned</source>
          <target state="translated">&lt;code&gt;ref&lt;/code&gt; 되는 인수 &lt;code&gt;arg&lt;/code&gt; 할당 될 수있다</target>
        </trans-unit>
        <trans-unit id="204baff180e7e3a468a1f9c56b74a65a751e70cf" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;ref&lt;/code&gt; can be used to update the original elements:</source>
          <target state="translated">&lt;code&gt;ref&lt;/code&gt; 를 사용하여 원래 요소를 업데이트 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e8269973bbdb978f0397e67fc8a6355eb51b2130" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;ref&lt;/code&gt; can not be applied to the index values.</source>
          <target state="translated">&lt;code&gt;ref&lt;/code&gt; 인덱스 값에는 ref 를 적용 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="932eeb15c70bdcc684754cbc9bc11f2688ddcc81" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;relTolerance&lt;/code&gt; shall be normal positive real.</source>
          <target state="translated">&lt;code&gt;relTolerance&lt;/code&gt; 는 정상 양수 여야합니다.</target>
        </trans-unit>
        <trans-unit id="1076698319f98e76706f3fc28826ddcc4b9b7224" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;remove(key)&lt;/code&gt; does nothing if the given</source>
          <target state="translated">&lt;code&gt;remove(key)&lt;/code&gt; 주어진 경우 remove (key) 는 아무것도하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="cef283158d0f1a50261d4f80c63bd68c62f99e27" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;remquo&lt;/code&gt; and &lt;code&gt;remainder&lt;/code&gt; not supported on Windows.</source>
          <target state="translated">&lt;code&gt;remquo&lt;/code&gt; 및 &lt;code&gt;remainder&lt;/code&gt; 는 Windows에서 지원되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="2ecbc7094325c066ef8cdf3361653dbbfc37ce1d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;rename&lt;/code&gt; uses the passed &lt;code&gt;names&lt;/code&gt; and returns a new &lt;a href=&quot;#Tuple&quot;&gt;&lt;code&gt;Tuple&lt;/code&gt;&lt;/a&gt; using these names, with the content unchanged. If fewer names are passed than there are members of the &lt;a href=&quot;#Tuple&quot;&gt;&lt;code&gt;Tuple&lt;/code&gt;&lt;/a&gt; then those trailing members are unchanged. An empty string will remove the name for that member. It is an compile-time error to pass more names than there are members of the &lt;a href=&quot;#Tuple&quot;&gt;&lt;code&gt;Tuple&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;rename&lt;/code&gt; 은 전달 된 &lt;code&gt;names&lt;/code&gt; 사용하고이 이름을 사용하여 내용을 변경하지 않고 새 &lt;a href=&quot;#Tuple&quot;&gt; &lt;code&gt;Tuple&lt;/code&gt; &lt;/a&gt; 을 반환합니다 . &lt;a href=&quot;#Tuple&quot;&gt; &lt;code&gt;Tuple&lt;/code&gt; 의&lt;/a&gt; 멤버보다 적은 수의 이름이 전달되면 해당 멤버는 변경되지 않습니다. 빈 문자열은 해당 멤버의 이름을 제거합니다. &lt;a href=&quot;#Tuple&quot;&gt; &lt;code&gt;Tuple&lt;/code&gt; 의&lt;/a&gt; 멤버보다 많은 이름을 전달하는 것은 컴파일 타임 오류 입니다.</target>
        </trans-unit>
        <trans-unit id="f5cb9eecaf9f022d0a8470e17dd2137035c24912" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;resolveInternalPointer&lt;/code&gt; is defined if and only if both allocators define it.</source>
          <target state="translated">&lt;code&gt;resolveInternalPointer&lt;/code&gt; 는 두 할당자가 정의한 경우에만 정의됩니다.</target>
        </trans-unit>
        <trans-unit id="cc87f8f1d317e08f1002d55d8c9053664da7610a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;return scope&lt;/code&gt; can be applied to the &lt;code&gt;this&lt;/code&gt; of class and interface member functions.</source>
          <target state="translated">&lt;code&gt;return scope&lt;/code&gt; 에인가 될 수있는 &lt;code&gt;this&lt;/code&gt; 클래스 및 인터페이스 기능 부재.</target>
        </trans-unit>
        <trans-unit id="0a098ce0d05675d45db864ce47dfe56507839992" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;return&lt;/code&gt; Attribute</source>
          <target state="translated">&lt;code&gt;return&lt;/code&gt; 속성 반환</target>
        </trans-unit>
        <trans-unit id="4c4e55e29e207e9b091c1a308208acc22bbe6d2a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;return&lt;/code&gt; exits the current function and supplies its return value.</source>
          <target state="translated">&lt;code&gt;return&lt;/code&gt; 은 현재 기능을 종료하고 반환 값을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="0d1e4e7673cd67124b7c2117ce90a093529e4757" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;return&lt;/code&gt; indicates that either the return value of the function or the first parameter is a pointer derived from the &lt;code&gt;return&lt;/code&gt; parameter or any other parameters also marked &lt;code&gt;return&lt;/code&gt;. For constructors, &lt;code&gt;return&lt;/code&gt; applies to the (implicitly returned) &lt;code&gt;this&lt;/code&gt; reference. For void functions, &lt;code&gt;return&lt;/code&gt; applies to the first parameter</source>
          <target state="translated">&lt;code&gt;return&lt;/code&gt; 은 함수 또는 첫 번째 매개 변수의 반환 값이 &lt;code&gt;return&lt;/code&gt; 매개 변수 또는 &lt;code&gt;return&lt;/code&gt; 으로 표시된 다른 매개 변수 에서 파생 된 포인터임을 나타냅니다 . 생성자의 경우 &lt;code&gt;return&lt;/code&gt; &lt;code&gt;this&lt;/code&gt; 참조에 암시 적으로 적용됩니다 . void 함수의 경우 &lt;code&gt;return&lt;/code&gt; 은 첫 번째 매개 변수에 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="b4d1e67726ee639f9a5c7f346530a61fa00f8ba1" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;roundRobin(r1, r2, r3)&lt;/code&gt; yields &lt;code&gt;r1.front&lt;/code&gt;, then &lt;code&gt;r2.front&lt;/code&gt;, then &lt;code&gt;r3.front&lt;/code&gt;, after which it pops off one element from each and continues again from &lt;code&gt;r1&lt;/code&gt;. For example, if two ranges are involved, it alternately yields elements off the two ranges. &lt;code&gt;roundRobin&lt;/code&gt; stops after it has consumed all ranges (skipping over the ones that finish early).</source>
          <target state="translated">&lt;code&gt;roundRobin(r1, r2, r3)&lt;/code&gt; 은 &lt;code&gt;r1.front&lt;/code&gt; , &lt;code&gt;r2.front&lt;/code&gt; , &lt;code&gt;r3.front&lt;/code&gt; 를 생성 한 후 각 요소에서 하나의 요소를 제거하고 &lt;code&gt;r1&lt;/code&gt; 에서 다시 계속됩니다 . 예를 들어, 두 범위가 관련되는 경우 두 범위에서 요소를 번갈아 생성합니다. &lt;code&gt;roundRobin&lt;/code&gt; 이 모든 범위를 소비 한 후 중지합니다 (초기 완료 범위를 뛰어 넘음 ).</target>
        </trans-unit>
        <trans-unit id="0f5bb74811faa1591cdad4c836be024aee1e88e1" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;roundingFunction(n) &amp;gt;= n&lt;/code&gt; for all &lt;code&gt;n&lt;/code&gt; of type &lt;code&gt;size_t&lt;/code&gt;;</source>
          <target state="translated">&lt;code&gt;roundingFunction(n) &amp;gt;= n&lt;/code&gt; &lt;code&gt;size_t&lt;/code&gt; 유형의 모든 &lt;code&gt;n&lt;/code&gt; 에 대해 roundingFunction (n)&amp;gt; = n ;</target>
        </trans-unit>
        <trans-unit id="308b72cef8c5b530189638ec876ae903345922ca" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;roundingFunction&lt;/code&gt; must be &lt;code&gt;nothrow&lt;/code&gt;, &lt;code&gt;@safe&lt;/code&gt;, &lt;code&gt;@nogc&lt;/code&gt; and &lt;code&gt;pure&lt;/code&gt;, i.e. always return the same value for a given &lt;code&gt;n&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;roundingFunction&lt;/code&gt; 은 &lt;code&gt;nothrow&lt;/code&gt; , &lt;code&gt;@safe&lt;/code&gt; , &lt;code&gt;@nogc&lt;/code&gt; 및 &lt;code&gt;pure&lt;/code&gt; 여야합니다 . 즉 항상 주어진 &lt;code&gt;n&lt;/code&gt; 에 대해 동일한 값을 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="109cdbe06887b34b6b16365fe723cf15c4d1291a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;roundingFunction&lt;/code&gt; must be monotonically increasing, i.e. &lt;code&gt;roundingFunction(n1) &amp;lt;= roundingFunction(n2)&lt;/code&gt; for all &lt;code&gt;n1 &amp;lt; n2&lt;/code&gt;;</source>
          <target state="translated">&lt;code&gt;roundingFunction&lt;/code&gt; 은 단조 증가해야합니다. 즉, &lt;code&gt;roundingFunction(n1) &amp;lt;= roundingFunction(n2)&lt;/code&gt; 모든 &lt;code&gt;n1 &amp;lt; n2&lt;/code&gt; ;</target>
        </trans-unit>
        <trans-unit id="d2742c8e141b08b59565abb12504e62ecd5fa332" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;roundingFunction&lt;/code&gt; must satisfy three constraints. These are not enforced (save for the use of &lt;code&gt;assert&lt;/code&gt;) for the sake of efficiency.</source>
          <target state="translated">&lt;code&gt;roundingFunction&lt;/code&gt; 은 세 가지 제약 조건을 만족해야합니다. 이것들은 효율성을 위해 시행되지 않습니다 ( &lt;code&gt;assert&lt;/code&gt; 사용을 위해 저장 ).</target>
        </trans-unit>
        <trans-unit id="c8420b0329603c1302842ffb196fac98e4ea5918" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;s&lt;/code&gt; turned into an expression, &lt;code&gt;ErrorExp&lt;/code&gt; if an error occurred</source>
          <target state="translated">&lt;code&gt;s&lt;/code&gt; 는 오류가 발생하면 표현식, &lt;code&gt;ErrorExp&lt;/code&gt; 로 바 turned</target>
        </trans-unit>
        <trans-unit id="dd6c5560263e9d7106d8390afa95f09a9dcd7c46" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;save&lt;/code&gt; works as normal and operates on a new range, so if &lt;code&gt;save&lt;/code&gt; is ever called on the &lt;code&gt;RefRange&lt;/code&gt;, then no operations on the saved range will affect the original.</source>
          <target state="translated">&lt;code&gt;save&lt;/code&gt; 는 정상적으로 작동하고 새로운 범위에서 작동하므로 &lt;code&gt;RefRange&lt;/code&gt; 에서 &lt;code&gt;save&lt;/code&gt; 를 호출 하면 저장된 범위에 대한 작업이 원본에 영향을 미치지 않습니다.</target>
        </trans-unit>
        <trans-unit id="c1856b9100bdac38994d4cdb68f1848445200c7b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;scope&lt;/code&gt; Attribute</source>
          <target state="translated">&lt;code&gt;scope&lt;/code&gt; 속성</target>
        </trans-unit>
        <trans-unit id="605b97283af3bfaf0042af48044ab3db174a5e7d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;scope&lt;/code&gt; cannot be applied to globals, statics, data members, ref or out parameters. Arrays of &lt;code&gt;scope&lt;/code&gt;s are not allowed, and &lt;code&gt;scope&lt;/code&gt; function return values are not allowed. Assignment to a &lt;code&gt;scope&lt;/code&gt;, other than initialization, is not allowed. &lt;code&gt;Rationale:&lt;/code&gt; These restrictions may get relaxed in the future if a compelling reason to appears.</source>
          <target state="translated">&lt;code&gt;scope&lt;/code&gt; 는 전역, 정적, 데이터 멤버, 참조 또는 출력 매개 변수에 적용 할 수 없습니다. &lt;code&gt;scope&lt;/code&gt; 배열은 허용되지 않으며 &lt;code&gt;scope&lt;/code&gt; 함수 리턴 값은 허용되지 않습니다. 초기화 이외 의 &lt;code&gt;scope&lt;/code&gt; 에 대한 할당 은 허용되지 않습니다. &lt;code&gt;Rationale:&lt;/code&gt; 이러한 제한 사항은 강력한 이유가 나타날 경우 향후 완화 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="de58cba1b63566938adce3e13bef6a93cbd5e801" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;scope&lt;/code&gt; ensures that no references to the pointed-to object are retained, in global variables or pointers passed to the function (and recursively to other functions called in the function), as a result of calling the function. Variables in the function body and parameter list that are &lt;code&gt;scope&lt;/code&gt; may have their allocations elided as a result.</source>
          <target state="translated">&lt;code&gt;scope&lt;/code&gt; 는 함수를 호출 한 결과로 전역 변수 또는 함수에 전달 된 포인터 (및 함수에서 호출 된 다른 함수에 대한 포인터)에서 지정된 객체에 대한 참조가 유지되지 않도록합니다. &lt;code&gt;scope&lt;/code&gt; 함수 본문 및 매개 변수 목록의 변수 는 결과적으로 할당이 생략 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7e11f308a204e081f111ee3bf2a5a482b9381e79" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;scopedTask&lt;/code&gt; might be preferred over &lt;code&gt;task&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;scopedTask&lt;/code&gt; 가 &lt;code&gt;task&lt;/code&gt; 보다 선호 될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="6408fb12bc31b661581f337ae2267afe0bfc681c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;self&lt;/code&gt;: an alias to the function itself;</source>
          <target state="translated">&lt;code&gt;self&lt;/code&gt; : 함수 자체의 별명;</target>
        </trans-unit>
        <trans-unit id="f05d3272cc81781898ada7fb162b5d7951fba66d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;seq&lt;/code&gt; advanced to the first matching element, or until empty if there are no matching elements.</source>
          <target state="translated">&lt;code&gt;seq&lt;/code&gt; 는 첫 번째 일치 요소로 진행되거나 일치하는 요소가없는 경우 비어있을 때까지 진행됩니다.</target>
        </trans-unit>
        <trans-unit id="06257616c41cacb4ce31abd296b3a46dd70958b2" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;shared&lt;/code&gt; Attribute</source>
          <target state="translated">&lt;code&gt;shared&lt;/code&gt; 속성</target>
        </trans-unit>
        <trans-unit id="9b6ab6f176994589d27d564332f0146fa64462d4" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;shared&lt;/code&gt;. When a postblit is qualified with &lt;code&gt;shared&lt;/code&gt; as in &lt;code&gt;this(this) shared&lt;/code&gt; or &lt;code&gt;shared this(this)&lt;/code&gt; solely &lt;code&gt;shared&lt;/code&gt; objects may invoke the postblit; attempts of postbliting unshared objects will result in compile time errors:</source>
          <target state="translated">&lt;code&gt;shared&lt;/code&gt; . postblit이 &lt;code&gt;this(this) shared&lt;/code&gt; 또는 &lt;code&gt;shared this(this)&lt;/code&gt; 와 같이 &lt;code&gt;shared&lt;/code&gt; 로 인증 된 경우, 오직 &lt;code&gt;shared&lt;/code&gt; 객체 만이 postblit을 호출 할 수 있습니다. 공유되지 않은 객체를 포스트 블리 팅하려고하면 컴파일 타임 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="e79d49bb12749d54349a7e1da24c925d0a9c9b5a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;sharedLog&lt;/code&gt; is only thread-safe if the the used &lt;code&gt;Logger&lt;/code&gt; is thread-safe. The default &lt;code&gt;Logger&lt;/code&gt; is thread-safe.</source>
          <target state="translated">&lt;code&gt;sharedLog&lt;/code&gt; 는 사용 된 &lt;code&gt;Logger&lt;/code&gt; 가 스레드 안전 인 경우에만 스레드 안전합니다. 기본 &lt;code&gt;Logger&lt;/code&gt; 는 스레드로부터 안전합니다.</target>
        </trans-unit>
        <trans-unit id="223c9c7bd3e5173b52c93ac3449e4ed7df37d6c0" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;size_t&lt;/code&gt; 0 for end of file, otherwise number of characters read</source>
          <target state="translated">&lt;code&gt;size_t&lt;/code&gt; 파일 끝의 경우 size_t 0, 그렇지 않으면 읽은 문자 수</target>
        </trans-unit>
        <trans-unit id="481bc787f0b1a627493311fd994efbba2ed4cc7c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;size_t&lt;/code&gt; is an alias to one of the unsigned integral basic types, and represents a type that is large enough to represent an offset into all addressable memory.</source>
          <target state="translated">&lt;code&gt;size_t&lt;/code&gt; 는 부호없는 정수 기본 유형 중 하나의 별명이며 모든 주소 지정 가능 메모리에 대한 오프셋을 표시하기에 충분히 큰 유형을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="df033de8837c1e0c009462fae21291df75580008" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;sort&lt;/code&gt; returns a &lt;a href=&quot;std_range#SortedRange&quot;&gt;&lt;code&gt;std.range.SortedRange&lt;/code&gt;&lt;/a&gt; over the original range, allowing functions that can take advantage of sorted data to know that the range is sorted and adjust accordingly. The &lt;a href=&quot;std_range#SortedRange&quot;&gt;&lt;code&gt;std.range.SortedRange&lt;/code&gt;&lt;/a&gt; is a wrapper around the original range, so both it and the original range are sorted. Other functions can't know that the original range has been sorted, but they</source>
          <target state="translated">&lt;code&gt;sort&lt;/code&gt; 는 원래 범위에 대해 &lt;a href=&quot;std_range#SortedRange&quot;&gt; &lt;code&gt;std.range.SortedRange&lt;/code&gt; &lt;/a&gt; 를 반환 하므로 정렬 된 데이터를 활용할 수있는 함수를 통해 범위가 정렬되어 있음을 알 수 있습니다. &lt;a href=&quot;std_range#SortedRange&quot;&gt; &lt;code&gt;std.range.SortedRange&lt;/code&gt; 은&lt;/a&gt; 그 원래의 범위 모두가 분류되어 있으므로, 원래의 범위 래퍼입니다. 다른 함수는 원래 범위가 정렬되었음을 알 수 없지만</target>
        </trans-unit>
        <trans-unit id="e4c6ea564f371d9ede380d1ded149063253741d2" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;startsWith(&quot;hello, world&quot;, &quot;hello&quot;)&lt;/code&gt; returns &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;startsWith(&quot;hello, world&quot;, &quot;hello&quot;)&lt;/code&gt; 는 &lt;code&gt;true&lt;/code&gt; 를 반환 합니다 .</target>
        </trans-unit>
        <trans-unit id="9b479c5ce0a7bcc0a387d731c3bea31274eb3618" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;static foreach&lt;/code&gt; supports multiple variables in cases where the corresponding &lt;code&gt;foreach&lt;/code&gt; statement supports them. (In this case, &lt;code&gt;static foreach&lt;/code&gt; generates a compile-time sequence of tuples, and the tuples are subsequently unpacked during iteration.)</source>
          <target state="translated">&lt;code&gt;static foreach&lt;/code&gt; 는 해당 &lt;code&gt;foreach&lt;/code&gt; 문이 지원 하는 경우 여러 변수를 지원합니다. (이 경우 &lt;code&gt;static foreach&lt;/code&gt; 는 컴파일 타임의 튜플 시퀀스를 생성하고 튜플은 반복 중에 압축이 풀립니다.)</target>
        </trans-unit>
        <trans-unit id="6f937f4e1c8d330cfe36aa5a7dac2283a0e18588" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;static opCall&lt;/code&gt; also works as expected for a function call operator with type names.</source>
          <target state="translated">&lt;code&gt;static opCall&lt;/code&gt; 은 유형 이름이있는 함수 호출 연산자에도 예상대로 작동합니다.</target>
        </trans-unit>
        <trans-unit id="58e93a06ab727109993d9039f8909c7568769569" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;static&lt;/code&gt; Attribute</source>
          <target state="translated">&lt;code&gt;static&lt;/code&gt; 속성</target>
        </trans-unit>
        <trans-unit id="f861a00c2c4e8f4a3c18c76a83270bfdfb229222" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;static&lt;/code&gt; cannot be used with selective imports.</source>
          <target state="translated">&lt;code&gt;static&lt;/code&gt; 은 선택적 가져 오기와 함께 사용할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="0c05b4bf3a0823e983b650821a7fea25264f6966" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;staticArray&lt;/code&gt; returns by value, so expressions involving large arrays may be inefficient.</source>
          <target state="translated">&lt;code&gt;staticArray&lt;/code&gt; 는 값으로 반환되므로 큰 배열과 관련된 표현식은 비효율적 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d186527edac8a16bdcca857733d1babbfdb6d0fb" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std.parallelism&lt;/code&gt; implements high-level primitives for SMP parallelism. These include parallel foreach, parallel reduce, parallel eager map, pipelining and future/promise parallelism. &lt;code&gt;std.parallelism&lt;/code&gt; is recommended when the same operation is to be executed in parallel on different data, or when a function is to be executed in a background thread and its result returned to a well-defined main thread. For communication between arbitrary threads, see &lt;code&gt;std.concurrency&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;std.parallelism&lt;/code&gt; 은 SMP 병렬 처리를위한 고급 프리미티브를 구현합니다. 여기에는 병렬 foreach, 병렬 축소, 병렬 열망 맵, 파이프 라이닝 및 미래 / 약속 병렬 처리가 포함됩니다. &lt;code&gt;std.parallelism&lt;/code&gt; 은 다른 데이터에서 동일한 작업을 병렬로 실행하거나 백그라운드 스레드에서 함수를 실행하고 결과를 잘 정의 된 기본 스레드로 반환하는 경우 권장됩니다. 임의의 스레드 간 통신에 대해서는 &lt;code&gt;std.concurrency&lt;/code&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="e539f2e5797833bc4d4c570169e4fef76e97deff" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std.parallelism&lt;/code&gt; is based on the concept of a &lt;code&gt;Task&lt;/code&gt;. A &lt;code&gt;Task&lt;/code&gt; is an object that represents the fundamental unit of work in this library and may be executed in parallel with any other &lt;code&gt;Task&lt;/code&gt;. Using &lt;code&gt;Task&lt;/code&gt; directly allows programming with a future/promise paradigm. All other supported parallelism paradigms (parallel foreach, map, reduce, pipelining) represent an additional level of abstraction over &lt;code&gt;Task&lt;/code&gt;. They automatically create one or more &lt;code&gt;Task&lt;/code&gt; objects, or closely related types that are conceptually identical but not part of the public API.</source>
          <target state="translated">&lt;code&gt;std.parallelism&lt;/code&gt; 은 &lt;code&gt;Task&lt;/code&gt; 의 개념을 기반으로합니다 . &lt;code&gt;Task&lt;/code&gt; 이 라이브러리의 작업의 기본 단위를 나타내고, 다른 병렬로 실행될 수있는 목적 &lt;code&gt;Task&lt;/code&gt; . 사용 &lt;code&gt;Task&lt;/code&gt; 직접 미래 / 약속 패러다임 프로그래밍을 허용한다. 지원되는 다른 모든 병렬 처리 패러다임 (병렬 foreach, 맵, 축소, 파이프 라이닝)은 &lt;code&gt;Task&lt;/code&gt; 에 대한 추가적인 추상화 수준을 나타냅니다 . 이들은 하나 이상의 &lt;code&gt;Task&lt;/code&gt; 객체 또는 개념적으로 동일하지만 공개 API의 일부가 아닌 밀접하게 관련된 유형을 자동으로 만듭니다 .</target>
        </trans-unit>
        <trans-unit id="d51ba1cf1d887be72a4c35b6e027f3b0b776e392" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;strictlyOrdered(1, 1, 2, 3)&lt;/code&gt; returns &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;strictlyOrdered(1, 1, 2, 3)&lt;/code&gt; 은 &lt;code&gt;false&lt;/code&gt; 를 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="b18ef91248deb0535ed182732bf3a2e7452fccd6" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;stride&lt;/code&gt; will only analyze the first &lt;code&gt;str[index]&lt;/code&gt; element. It will not fully verify the validity of the UTF sequence, nor even verify the presence of the sequence: it will not actually guarantee that &lt;code&gt;index + stride(str, index) &amp;lt;= str.length&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;stride&lt;/code&gt; 는 첫 번째 &lt;code&gt;str[index]&lt;/code&gt; 요소 만 분석합니다 . UTF 시퀀스의 유효성을 완전히 검증하거나 시퀀스의 존재를 검증하지는 않습니다. 실제로 &lt;code&gt;index + stride(str, index) &amp;lt;= str.length&lt;/code&gt; 보장하지는 않습니다 .</target>
        </trans-unit>
        <trans-unit id="3524e11e2cd1a4bae8c339623913a2a68d9caf67" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;strideBack&lt;/code&gt; will only analyze the element at &lt;code&gt;str[index - 1]&lt;/code&gt; element. It will not fully verify the validity of the UTF sequence, nor even verify the presence of the sequence: it will not actually guarantee that &lt;code&gt;strideBack(str, index) &amp;lt;= index&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;strideBack&lt;/code&gt; 은 &lt;code&gt;str[index - 1]&lt;/code&gt; 요소 의 요소 만 분석합니다 . UTF 시퀀스의 유효성을 완전히 검증하지 않으며 시퀀스의 존재를 검증하지도 않습니다. 실제로 &lt;code&gt;strideBack(str, index) &amp;lt;= index&lt;/code&gt; 보장하지는 않습니다 .</target>
        </trans-unit>
        <trans-unit id="815abb2cb935d9d225a7cd705522e3fbcba850f8" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;string&lt;/code&gt; - service name or port number</source>
          <target state="translated">&lt;code&gt;string&lt;/code&gt; -서비스 이름 또는 포트 번호</target>
        </trans-unit>
        <trans-unit id="70ead95fb34de5f02a9f1b5d84525c2ccc28179b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;struct&lt;/code&gt;, &lt;code&gt;union&lt;/code&gt;, &lt;code&gt;class&lt;/code&gt;, and &lt;code&gt;interface&lt;/code&gt; are formatted by calling &lt;code&gt;toString&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;struct&lt;/code&gt; , &lt;code&gt;union&lt;/code&gt; , &lt;code&gt;class&lt;/code&gt; 및 &lt;code&gt;interface&lt;/code&gt; 는 &lt;code&gt;toString&lt;/code&gt; 을 호출하여 형식이 지정됩니다 .</target>
        </trans-unit>
        <trans-unit id="6b94224ee093a8b123c1a890be96840068352cc9" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;stuff&lt;/code&gt; can be a value convertible to &lt;code&gt;T&lt;/code&gt; or a range of objects convertible to &lt;code&gt;T&lt;/code&gt;. The stable version behaves the same, but guarantees that ranges iterating over the container are never invalidated.</source>
          <target state="translated">&lt;code&gt;stuff&lt;/code&gt; 는 &lt;code&gt;T&lt;/code&gt; 로 변환 가능한 값 이거나 &lt;code&gt;T&lt;/code&gt; 로 변환 가능한 객체 범위 일 수 있습니다 . 안정적인 버전은 동일하게 작동하지만 컨테이너를 반복하는 범위가 무효화되지 않도록 보장합니다.</target>
        </trans-unit>
        <trans-unit id="12300e292a3239ecad42ff3d93d0648b61fb7834" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;super&lt;/code&gt; is identical to &lt;code&gt;this&lt;/code&gt;, except that it is cast to &lt;code&gt;this&lt;/code&gt;'s base class. It is an error if there is no base class. It is an error to use &lt;code&gt;super&lt;/code&gt; within a struct member function. (Only class &lt;code&gt;Object&lt;/code&gt; has no base class.) If a member function is called with an explicit reference to &lt;code&gt;super&lt;/code&gt;, a non-virtual call is made.</source>
          <target state="translated">&lt;code&gt;super&lt;/code&gt; 동일 &lt;code&gt;this&lt;/code&gt; , 그것은으로 캐스팅되는 것을 제외하고는 &lt;code&gt;this&lt;/code&gt; '의 기본 클래스입니다. 기본 클래스가 없으면 오류입니다. 구조체 멤버 함수 내에서 &lt;code&gt;super&lt;/code&gt; 를 사용하는 것은 오류 입니다. ( &lt;code&gt;Object&lt;/code&gt; 클래스에만 기본 클래스가 없습니다.) &lt;code&gt;super&lt;/code&gt; 에 대한 명시 적 참조로 멤버 함수가 호출 되면 비가 상 호출이 수행됩니다.</target>
        </trans-unit>
        <trans-unit id="5d3e225f1cfb66733f5c5c3a82747e4de13d407e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;switch&lt;/code&gt; with strings</source>
          <target state="translated">&lt;code&gt;switch&lt;/code&gt; 문자열로 전환</target>
        </trans-unit>
        <trans-unit id="e1ab526b163fcaca146d0f4387c01f84d9d8e8ed" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;synchronized&lt;/code&gt; and &lt;a href=&quot;https://dlang.org/phobos/core_sync.html&quot;&gt;&lt;code&gt;core.sync&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">&lt;code&gt;synchronized&lt;/code&gt; 및 &lt;a href=&quot;https://dlang.org/phobos/core_sync.html&quot;&gt; &lt;code&gt;core.sync&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="c2ae5b48daba2a435390a96fc178a22c54b9103e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;target&lt;/code&gt; shall have enough room to accommodate the entirety of &lt;code&gt;source&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;target&lt;/code&gt; 은 전체 &lt;code&gt;source&lt;/code&gt; 를 수용 할 수있는 충분한 공간을 가져야 합니다 .</target>
        </trans-unit>
        <trans-unit id="4b618d9a887c9286570dc763d1956279cd9a67d3" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;this&lt;/code&gt; inside &lt;code&gt;struct&lt;/code&gt; and &lt;code&gt;union&lt;/code&gt; member functions;</source>
          <target state="translated">&lt;code&gt;this&lt;/code&gt; 내부 &lt;code&gt;struct&lt;/code&gt; 와 &lt;code&gt;union&lt;/code&gt; 멤버 함수;</target>
        </trans-unit>
        <trans-unit id="1dd7c7da4f2db512c36ff60aea324bbf46d7f1eb" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;this&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;this&lt;/code&gt;.</target>
        </trans-unit>
        <trans-unit id="cdd590867d10eda8e591ba3c504661cc4d5c524a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;tickDuration.&lt;/code&gt;&lt;a href=&quot;std_conv#to&quot;&gt;&lt;code&gt;to&lt;/code&gt;&lt;/a&gt;&lt;code&gt;!Duration()&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;tickDuration.&lt;/code&gt;&lt;a href=&quot;std_conv#to&quot;&gt;&lt;code&gt;to&lt;/code&gt;&lt;/a&gt;&lt;code&gt;!Duration()&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="d0bd3c31ca7c7f29752ad58a8ef9e6ff27520e91" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;toHash&lt;/code&gt; is rarely directly invoked; it is implicitly used when BigInt is used as the key of an associative array.</source>
          <target state="translated">&lt;code&gt;toHash&lt;/code&gt; 는 거의 직접 호출되지 않습니다. BigInt가 연관 배열의 키로 사용될 때 내재적으로 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="82ec7686ea934cd2f18c7f60e28371c82c9f447d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;toParent()&lt;/code&gt; returns a logically enclosing scope symbol this is a member of. It skips over TemplateMixin's.</source>
          <target state="translated">&lt;code&gt;toParent()&lt;/code&gt; 는 이것이 속한 논리적으로 둘러싸인 범위 기호를 반환합니다. TemplateMixin을 건너 뜁니다.</target>
        </trans-unit>
        <trans-unit id="0083bc7cd319ebdfebdf2e1edfc6c99f806fcb76" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;toParent2()&lt;/code&gt; returns an enclosing scope symbol this is living at runtime. It skips over both TemplateInstance's and TemplateMixin's. It's used when looking for the 'this' pointer of the enclosing function/class.</source>
          <target state="translated">&lt;code&gt;toParent2()&lt;/code&gt; 는 런타임에 존재하는 둘러싸는 범위 기호를 반환합니다. TemplateInstance와 TemplateMixin을 모두 건너 뜁니다. 엔 클로징 함수 / 클래스의 'this'포인터를 찾을 때 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="73cfc104297a470e42637ccf91c2c36ee3245422" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;toParentDecl()&lt;/code&gt; similar to &lt;code&gt;toParent2()&lt;/code&gt; but always follows the template declaration scope instead of the instantiation scope.</source>
          <target state="translated">&lt;code&gt;toParentDecl()&lt;/code&gt; 와 유사한 &lt;code&gt;toParent2()&lt;/code&gt; 이지만 인스턴스화 범위 대신 항상 템플릿 선언 범위를 따릅니다.</target>
        </trans-unit>
        <trans-unit id="a94d9760694ab57714a8a469c5e5cfc3daa57828" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;toParentLocal()&lt;/code&gt; similar to &lt;code&gt;toParentDecl()&lt;/code&gt; but follows the instantiation scope if a template declaration is non-local i.e. global or static.</source>
          <target state="translated">&lt;code&gt;toParentLocal()&lt;/code&gt; 과 유사 &lt;code&gt;toParentDecl()&lt;/code&gt; 하지만 템플릿 선언이 로컬이 아닌 즉, 전역 또는 정적 인 경우 인스턴스의 범위를 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="1390a2eb1c2e28916c37115c0998c8521c9afee8" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;toString&lt;/code&gt; is rarely directly invoked; the usual way of using it is via &lt;a href=&quot;std_format#format&quot;&gt;&lt;code&gt;std.format.format&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">&lt;code&gt;toString&lt;/code&gt; 은 거의 직접 호출되지 않습니다. 그것을 사용하는 일반적인 방법은 &lt;a href=&quot;std_format#format&quot;&gt; &lt;code&gt;std.format.format&lt;/code&gt; &lt;/a&gt; 을 사용하는 것입니다 .</target>
        </trans-unit>
        <trans-unit id="3bfea05b95eb98e11a8adc4ee7aed975ec8509c1" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;toString&lt;/code&gt; should have one of the following signatures:</source>
          <target state="translated">&lt;code&gt;toString&lt;/code&gt; 에는 다음 서명 중 하나가 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="005990d2619465a8e0eb37195710b4753844c21d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;toUTF16z&lt;/code&gt; is a convenience function for &lt;code&gt;toUTFz!(const(wchar)*)&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;toUTF16z&lt;/code&gt; 는 &lt;code&gt;toUTFz!(const(wchar)*)&lt;/code&gt; 의 편리한 기능입니다 .</target>
        </trans-unit>
        <trans-unit id="3034b52ad5e2b666f9d4ac76c8767f747dbc8719" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;toUTFz&lt;/code&gt; accepts any type of string and is templated on the type of character pointer that you wish to convert to. It will avoid allocating a new string if it can, but there's a decent chance that it will end up having to allocate a new string - particularly when dealing with character types other than &lt;code&gt;char&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;toUTFz&lt;/code&gt; 는 모든 유형의 문자열을 허용하며 변환하려는 문자 포인터 유형에 따라 템플릿 화됩니다. 가능한 경우 새 문자열을 할당하지 않아도되지만 특히 &lt;code&gt;char&lt;/code&gt; 이외의 문자 유형을 처리 할 때 새 문자열을 할당해야 할 가능성이 있습니다 .</target>
        </trans-unit>
        <trans-unit id="7b0fb0a2af81d4622c3f0ca12fdc722369079377" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;tr&lt;/code&gt; is based on &lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/9699919799/utilities/tr.html&quot;&gt;Posix's tr&lt;/a&gt;, though it doesn't do everything that the Posix utility does.</source>
          <target state="translated">&lt;code&gt;tr&lt;/code&gt; 은 &lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/9699919799/utilities/tr.html&quot;&gt;Posix의 tr을&lt;/a&gt; 기반으로 하지만 Posix 유틸리티가하는 모든 것을 수행하지는 않습니다.</target>
        </trans-unit>
        <trans-unit id="588c5db26f0574479497abcc48d3bf48bfbf6db3" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;true&lt;/code&gt; if &lt;code&gt;S&lt;/code&gt; can be copied. &lt;code&gt;false&lt;/code&gt; otherwise.</source>
          <target state="translated">&lt;code&gt;true&lt;/code&gt; &lt;code&gt;S&lt;/code&gt; 를 복사 할 수 있으면 true 입니다. 그렇지 않으면 &lt;code&gt;false&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="fcf3589ad960d9be2578a5d3a446eecbfb4e6104" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;true&lt;/code&gt; if &lt;code&gt;Seq&lt;/code&gt; is sorted; otherwise &lt;code&gt;false&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;true&lt;/code&gt; &lt;code&gt;Seq&lt;/code&gt; 가 정렬 되면 true 이고; 그렇지 않으면 &lt;code&gt;false&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="7f2a6e0d185693da342465248f1cdf7eba4f160a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;true&lt;/code&gt; if &lt;code&gt;T&lt;/code&gt; is a class nested inside another, with the conditions described above; &lt;code&gt;false&lt;/code&gt; otherwise</source>
          <target state="translated">&lt;code&gt;true&lt;/code&gt; &lt;code&gt;T&lt;/code&gt; 가 다른 조건에 중첩 된 클래스이고 위에서 설명한 조건을 만족 하면 true 이고; 그렇지 않으면 &lt;code&gt;false&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="08a01985c40be7b92a7f5350b980124535abdb46" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;true&lt;/code&gt; if &lt;code&gt;T&lt;/code&gt; is a file handle, &lt;code&gt;false&lt;/code&gt; otherwise.</source>
          <target state="translated">&lt;code&gt;true&lt;/code&gt; &lt;code&gt;T&lt;/code&gt; 가 파일 핸들 이면 true 이고 , 그렇지 않으면 &lt;code&gt;false&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="8567cd36d9c50f8238ab4ae84132dbf24c80defb" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;true&lt;/code&gt; if &lt;code&gt;X&lt;/code&gt; is a function, &lt;code&gt;false&lt;/code&gt; otherwise</source>
          <target state="translated">&lt;code&gt;true&lt;/code&gt; 경우 &lt;code&gt;X&lt;/code&gt; 는 함수이며, &lt;code&gt;false&lt;/code&gt; 그렇지</target>
        </trans-unit>
        <trans-unit id="9aa819b66833bb0b0171317b2e1ce1b3bea60f99" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;true&lt;/code&gt; if &lt;code&gt;X&lt;/code&gt; is a type, &lt;code&gt;false&lt;/code&gt; otherwise</source>
          <target state="translated">&lt;code&gt;true&lt;/code&gt; 경우 &lt;code&gt;X&lt;/code&gt; 는 유형이며, &lt;code&gt;false&lt;/code&gt; 그렇지</target>
        </trans-unit>
        <trans-unit id="e058cf11ca944763bc20d7e2edd7c761ca2be574" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;true&lt;/code&gt; if &lt;code&gt;X&lt;/code&gt; is final, &lt;code&gt;false&lt;/code&gt; otherwise</source>
          <target state="translated">&lt;code&gt;true&lt;/code&gt; 경우 &lt;code&gt;X&lt;/code&gt; 는 , 최종 &lt;code&gt;false&lt;/code&gt; 그렇지</target>
        </trans-unit>
        <trans-unit id="4803b0700c5c007902d1debfefc0c159c43d6fab" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;true&lt;/code&gt; if &lt;code&gt;b&lt;/code&gt; has been allocated with this region, &lt;code&gt;false&lt;/code&gt; otherwise.</source>
          <target state="translated">&lt;code&gt;true&lt;/code&gt; 이 영역에 &lt;code&gt;b&lt;/code&gt; 가 할당되어 있으면 true 이고 , 그렇지 않으면 &lt;code&gt;false&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="48ffa31f7ed81bcabcb75c22bb37eed8da935d1d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;true&lt;/code&gt; if &lt;code&gt;func&lt;/code&gt; is &lt;code&gt;@safe&lt;/code&gt; or &lt;code&gt;@trusted&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;true&lt;/code&gt; &lt;code&gt;func&lt;/code&gt; 가 &lt;code&gt;@safe&lt;/code&gt; 또는 &lt;code&gt;@trusted&lt;/code&gt; 인 경우 true 입니다.</target>
        </trans-unit>
        <trans-unit id="a649d64ab71bc5584e6c4abd2b0fcb8c1a771fe4" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;true&lt;/code&gt; if &lt;code&gt;func&lt;/code&gt; is &lt;code&gt;@system&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;true&lt;/code&gt; &lt;code&gt;func&lt;/code&gt; 가 &lt;code&gt;@system&lt;/code&gt; 인 경우 true 입니다.</target>
        </trans-unit>
        <trans-unit id="95d0ce1a4c8d33c8a989eafdbe862e7a941b8f3c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;true&lt;/code&gt; if &lt;code&gt;lhs.ptr == rhs.ptr&lt;/code&gt;, &lt;code&gt;false&lt;/code&gt; otherwise.</source>
          <target state="translated">&lt;code&gt;true&lt;/code&gt; 경우 &lt;code&gt;lhs.ptr == rhs.ptr&lt;/code&gt; , &lt;code&gt;false&lt;/code&gt; 그렇지.</target>
        </trans-unit>
        <trans-unit id="db55e28196a1c212f4b61f6ad375a9336bc44dc8" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;true&lt;/code&gt; if &lt;code&gt;name&lt;/code&gt;'s extension is &lt;code&gt;ext&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;true&lt;/code&gt; &lt;code&gt;name&lt;/code&gt; 의 확장자가 &lt;code&gt;ext&lt;/code&gt; 인 경우 true</target>
        </trans-unit>
        <trans-unit id="736ca71e45580c10aa2d52cf7f053eaba4c25c73" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;true&lt;/code&gt; if &lt;code&gt;r&lt;/code&gt; is partitioned according to predicate &lt;code&gt;pred&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;true&lt;/code&gt; 술어 &lt;code&gt;pred&lt;/code&gt; 에 따라 &lt;code&gt;r&lt;/code&gt; 이 분할 된 경우 true 입니다.</target>
        </trans-unit>
        <trans-unit id="ee04fb6edad869ab006abfb10ae6248745a92500" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;true&lt;/code&gt; if &lt;code&gt;s1 == s2&lt;/code&gt; regardless of case</source>
          <target state="translated">&lt;code&gt;true&lt;/code&gt; 경우 &lt;code&gt;s1 == s2&lt;/code&gt; 없이 케이스</target>
        </trans-unit>
        <trans-unit id="4716ee2fbb535862a27757ab1941b9ff0cb859bc" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;true&lt;/code&gt; if &lt;code&gt;source&lt;/code&gt;'s representation embeds a pointer that points to &lt;code&gt;target&lt;/code&gt;'s representation or somewhere inside it.  If &lt;code&gt;source&lt;/code&gt; is or contains a dynamic array, then, then these functions will check if there is overlap between the dynamic array and &lt;code&gt;target&lt;/code&gt;'s representation.  If &lt;code&gt;source&lt;/code&gt; is a class, then it will be handled as a pointer.  If &lt;code&gt;target&lt;/code&gt; is a pointer, a dynamic array or a class, then these functions will only check if &lt;code&gt;source&lt;/code&gt; points to &lt;code&gt;target&lt;/code&gt;,</source>
          <target state="translated">&lt;code&gt;true&lt;/code&gt; &lt;code&gt;source&lt;/code&gt; 표현에 &lt;code&gt;target&lt;/code&gt; 표현 또는 그 안의 어딘가 를 가리키는 포인터가 포함되어 있으면 true 입니다. 경우 &lt;code&gt;source&lt;/code&gt; 또는 동적 배열을 포함하는 동적 배열 사이에 오버랩이있는 경우, 다음에, 이들 기능을 체크 할 &lt;code&gt;target&lt;/code&gt; 의 표현. 경우 &lt;code&gt;source&lt;/code&gt; 클래스이며, 다음은 포인터로 처리됩니다. 경우 &lt;code&gt;target&lt;/code&gt; 포인터 동적 배열 또는 클래스 인 경우, 이들 기능만을 확인한다 &lt;code&gt;source&lt;/code&gt; 포인트가 &lt;code&gt;target&lt;/code&gt; ,</target>
        </trans-unit>
        <trans-unit id="aed899d348bc31c47364d7bcccc68dfd78bd3781" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;true&lt;/code&gt; if &lt;code&gt;x&lt;/code&gt; is a NaN, &lt;code&gt;false&lt;/code&gt; otherwise</source>
          <target state="translated">&lt;code&gt;true&lt;/code&gt; 경우 &lt;code&gt;x&lt;/code&gt; NaN의입니다 &lt;code&gt;false&lt;/code&gt; 그렇지 않은 경우는</target>
        </trans-unit>
        <trans-unit id="e909c65ed2d088f338774b25ee5916d6c6a31a6f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;true&lt;/code&gt; if &lt;code&gt;x&lt;/code&gt; is an integer power of two.</source>
          <target state="translated">&lt;code&gt;true&lt;/code&gt; 경우 &lt;code&gt;x&lt;/code&gt; 는 두 가지의 정수 능력이 됨.</target>
        </trans-unit>
        <trans-unit id="01576b38e53f760d7fa441f81b6a38331a755a90" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;true&lt;/code&gt; if R is an input range, &lt;code&gt;false&lt;/code&gt; if not</source>
          <target state="translated">&lt;code&gt;true&lt;/code&gt; R은 입력 범위 인 경우, &lt;code&gt;false&lt;/code&gt; 없는 경우</target>
        </trans-unit>
        <trans-unit id="22105968f4bd62f765fe40f641d7369b250d9b52" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;true&lt;/code&gt; if all of the elements in &lt;code&gt;r1&lt;/code&gt; appear the same number of times in &lt;code&gt;r2&lt;/code&gt;. Otherwise, returns &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;true&lt;/code&gt; 의 모든 요소가있는 경우 &lt;code&gt;r1&lt;/code&gt; 에서 동일한 횟수 표시 &lt;code&gt;r2&lt;/code&gt; . 그렇지 않으면 &lt;code&gt;false&lt;/code&gt; 를 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="647b425da501748cddce279a9e4a6ef7b9ff0896" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;true&lt;/code&gt; if and only if &lt;code&gt;c&lt;/code&gt; is a valid Unicode code point</source>
          <target state="translated">&lt;code&gt;true&lt;/code&gt; &lt;code&gt;c&lt;/code&gt; 가 유효한 유니 코드 코드 포인트 인 경우에만 true</target>
        </trans-unit>
        <trans-unit id="4521edc34e50fd3161666a50db965c80b72349ec" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;true&lt;/code&gt; if and only if &lt;code&gt;filename&lt;/code&gt; is not empty, not too long, and does not contain invalid characters.</source>
          <target state="translated">&lt;code&gt;true&lt;/code&gt; &lt;code&gt;filename&lt;/code&gt; 이 비어 있지 않고 너무 길지 않고 유효하지 않은 문자를 포함하지 않는 경우에만 true 입니다.</target>
        </trans-unit>
        <trans-unit id="6c8531dd442dde642df6adb3732b3ac0bcdbd097" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;true&lt;/code&gt; if and only if the array has no elements.</source>
          <target state="translated">&lt;code&gt;true&lt;/code&gt; 배열에 요소가없는 경우에만 true 입니다.</target>
        </trans-unit>
        <trans-unit id="df8b9d49f1b0ad4418768e972f5ff8f26e3eb90f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;true&lt;/code&gt; if and only if the two ranges compare equal element for element, according to binary predicate &lt;code&gt;pred&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;true&lt;/code&gt; 이진 술어 &lt;code&gt;pred&lt;/code&gt; 에 따라 두 범위가 요소의 동일한 요소를 비교하는 경우에만 true 입니다.</target>
        </trans-unit>
        <trans-unit id="43da0fcd50fb3e44bc97d1779a5a0585c003578b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;true&lt;/code&gt; if any elements escaped</source>
          <target state="translated">&lt;code&gt;true&lt;/code&gt; 탈출 한 요소가 있으면 참</target>
        </trans-unit>
        <trans-unit id="fd062df197246c3fbf8d28beb36028005e887a34" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;true&lt;/code&gt; if any errors occurred during lexing or parsing.</source>
          <target state="translated">&lt;code&gt;true&lt;/code&gt; 어휘 분석 또는 구문 분석 중에 오류가 발생하면 true 입니다.</target>
        </trans-unit>
        <trans-unit id="1d8f7f146e54740a0d8df7019b35493c9329a523" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;true&lt;/code&gt; if assignment to &lt;code&gt;firstArg&lt;/code&gt; would cause an error</source>
          <target state="translated">&lt;code&gt;true&lt;/code&gt; &lt;code&gt;firstArg&lt;/code&gt; 에 할당 하면 오류가 발생하면 true</target>
        </trans-unit>
        <trans-unit id="4bf38a0de72bf9a9960cb44c7ba18e39cf09405b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;true&lt;/code&gt; if both arrays are the same length and &lt;code&gt;lhs.ptr == rhs.ptr&lt;/code&gt;, &lt;code&gt;false&lt;/code&gt; otherwise.</source>
          <target state="translated">&lt;code&gt;true&lt;/code&gt; 두 배열은 같은 길이 인 경우 &lt;code&gt;lhs.ptr == rhs.ptr&lt;/code&gt; , &lt;code&gt;false&lt;/code&gt; 그렇지.</target>
        </trans-unit>
        <trans-unit id="9ac3764e3160f18d1bccd835c289cdb2330d2c25" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;true&lt;/code&gt; if both ranges have the same length, &lt;code&gt;false&lt;/code&gt; otherwise.</source>
          <target state="translated">&lt;code&gt;true&lt;/code&gt; 두 범위의 길이가 같으면 true 이고, 그렇지 않으면 &lt;code&gt;false&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="36ceac4ce50650aac661ae00a2ba169845655943" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;true&lt;/code&gt; if both representations are equal, &lt;code&gt;false&lt;/code&gt; otherwise</source>
          <target state="translated">&lt;code&gt;true&lt;/code&gt; 두 표현이 같으면 true , 그렇지 않으면 &lt;code&gt;false&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="39ff04c17f38cc82afededf77e72dd30164a69f2" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;true&lt;/code&gt; if construction would cause an escaping reference error</source>
          <target state="translated">&lt;code&gt;true&lt;/code&gt; 생성시 이스케이프 참조 오류가 발생하는 경우 true</target>
        </trans-unit>
        <trans-unit id="303af4808ad2baecce90c36afc6560330e3d32c5" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;true&lt;/code&gt; if errors have been diagnosed</source>
          <target state="translated">&lt;code&gt;true&lt;/code&gt; 오류가 진단 된 경우 true</target>
        </trans-unit>
        <trans-unit id="c5afd4cd9e62983cefa444c2a133f0d9bf5e1e04" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;true&lt;/code&gt; if function is really nested within other function.</source>
          <target state="translated">&lt;code&gt;true&lt;/code&gt; 함수가 실제로 다른 함수 내에 중첩되어 있으면 true 입니다.</target>
        </trans-unit>
        <trans-unit id="3ea300fe97ac7f51e74b492d018077cf50054e6e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;true&lt;/code&gt; if it does</source>
          <target state="translated">&lt;code&gt;true&lt;/code&gt; 그렇다면 true</target>
        </trans-unit>
        <trans-unit id="2cbf067aba4bdad738328a3ce75e53fb26ca7370" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;true&lt;/code&gt; if it is special</source>
          <target state="translated">&lt;code&gt;true&lt;/code&gt; 특별하다면 참</target>
        </trans-unit>
        <trans-unit id="d307d51918d914c77ec41a0e6892c2e4866f78ee" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;true&lt;/code&gt; if no errors</source>
          <target state="translated">&lt;code&gt;true&lt;/code&gt; 오류가 없으면 true</target>
        </trans-unit>
        <trans-unit id="d1f8d85b30851e65377e6627837464bf19f191dc" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;true&lt;/code&gt; if normalization completed normally, &lt;code&gt;false&lt;/code&gt; if all elements in &lt;code&gt;range&lt;/code&gt; were zero or if &lt;code&gt;range&lt;/code&gt; is empty.</source>
          <target state="translated">&lt;code&gt;true&lt;/code&gt; 정규화가 정상적으로 완료되면 true 이고, &lt;code&gt;range&lt;/code&gt; 모든 요소 가 0이거나 &lt;code&gt;range&lt;/code&gt; 가 비어 있으면 &lt;code&gt;false&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="aed7c27f1c7731761f2c1cd71c40b58e2f287d79" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;true&lt;/code&gt; if pattern matches path, &lt;code&gt;false&lt;/code&gt; otherwise.</source>
          <target state="translated">&lt;code&gt;true&lt;/code&gt; 패턴이 경로와 일치하면 true 이고, 그렇지 않으면 &lt;code&gt;false&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="461691066f4a233761207873a6c1a5621c8a2fe4" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;true&lt;/code&gt; if pointers to the stack can escape</source>
          <target state="translated">&lt;code&gt;true&lt;/code&gt; 스택에 대한 포인터가 이스케이프 될 수있는 경우 true</target>
        </trans-unit>
        <trans-unit id="eac3e452588356a664a212ed933cbc90570f8f52" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;true&lt;/code&gt; if pointers to the stack can escape via assignment</source>
          <target state="translated">&lt;code&gt;true&lt;/code&gt; 스택에 대한 포인터가 할당을 통해 벗어날 수있는 경우 true</target>
        </trans-unit>
        <trans-unit id="60ca524063ed35647335cc75fabf9b2110a7e50f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;true&lt;/code&gt; if references to the stack can escape</source>
          <target state="translated">&lt;code&gt;true&lt;/code&gt; 스택에 대한 참조가 이스케이프 될 수있는 경우 true</target>
        </trans-unit>
        <trans-unit id="f3f56d935c90d3b16b4684a1b5724de202629d96" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;true&lt;/code&gt; if special</source>
          <target state="translated">&lt;code&gt;true&lt;/code&gt; 특별하면 참</target>
        </trans-unit>
        <trans-unit id="caf43bf9888cecf7cf63ded7f3c6d3b0af21f554" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;true&lt;/code&gt; if statement 'comes from' somewhere else, like a goto</source>
          <target state="translated">&lt;code&gt;true&lt;/code&gt; 성명서처럼 다른 곳에서 '문이 나오는 경우' true</target>
        </trans-unit>
        <trans-unit id="67a3b1de444a60f32cca1d083e46bbcd443d7ec7" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;true&lt;/code&gt; if statement has executable code.</source>
          <target state="translated">&lt;code&gt;true&lt;/code&gt; 명령문에 실행 코드가 있으면 true 입니다.</target>
        </trans-unit>
        <trans-unit id="96444596e9cdaa5283ccaf2d66fcfbb0199200ba" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;true&lt;/code&gt; if statement uses exception handling</source>
          <target state="translated">&lt;code&gt;true&lt;/code&gt; 문이 예외 처리를 사용하는 경우 true</target>
        </trans-unit>
        <trans-unit id="1da5b3b9b2f6758b8600858d63d6845c211c848a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;true&lt;/code&gt; if successful</source>
          <target state="translated">&lt;code&gt;true&lt;/code&gt; 성공하면 true</target>
        </trans-unit>
        <trans-unit id="60bfef6717d458b4089bebf93690bce834609c26" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;true&lt;/code&gt; if the 2 lambda functions are equal, &lt;code&gt;false&lt;/code&gt; otherwise</source>
          <target state="translated">&lt;code&gt;true&lt;/code&gt; 2 개 람다 함수가 동일한 경우, &lt;code&gt;false&lt;/code&gt; 그렇지</target>
        </trans-unit>
        <trans-unit id="e2c94ffbb5fbd44461e4bc55c729fb41009d2ec9" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;true&lt;/code&gt; if the character is in the Alphabetic, Nd, Nl, or No Unicode categories</source>
          <target state="translated">&lt;code&gt;true&lt;/code&gt; 문자가 알파벳, Nd, Nl 또는 유니 코드 없음 범주에있는 경우 true</target>
        </trans-unit>
        <trans-unit id="975530ebe416c50fa316849689c1b9c84bdce985" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;true&lt;/code&gt; if the directory exists or was successfully created</source>
          <target state="translated">&lt;code&gt;true&lt;/code&gt; 디렉토리가 존재하거나 성공적으로 작성된 경우 true</target>
        </trans-unit>
        <trans-unit id="e43f48b191a968d2108ef45b3265b47e07417128" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;true&lt;/code&gt; if the event is in signaled state, &lt;code&gt;false&lt;/code&gt; if the event is uninitialized or another error occured</source>
          <target state="translated">&lt;code&gt;true&lt;/code&gt; 이벤트가, 신호 상태에있는 경우 &lt;code&gt;false&lt;/code&gt; 이벤트가 초기화되지 않았거나 다른 오류가 발생하는 경우</target>
        </trans-unit>
        <trans-unit id="2f1569e1846ee1e5ca37b0ee2af6741e1637451e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;true&lt;/code&gt; if the event is in signaled state, &lt;code&gt;false&lt;/code&gt; if the event was nonsignaled for the given time or the event is uninitialized or another error occured</source>
          <target state="translated">&lt;code&gt;true&lt;/code&gt; 이벤트가, 신호 상태에있는 경우 &lt;code&gt;false&lt;/code&gt; 이벤트가 주어진 시간 동안 nonsignaled 않았거나 이벤트가 초기화되지 않았거나 다른 오류가 발생하는 경우</target>
        </trans-unit>
        <trans-unit id="113e77a108be9ae1dd3293e6b6a5943dc6e2977d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;true&lt;/code&gt; if the given character is a valid mangled character</source>
          <target state="translated">&lt;code&gt;true&lt;/code&gt; 주어진 문자가 유효한 맹 글링 문자 이면 true</target>
        </trans-unit>
        <trans-unit id="bd39a6a2f186a6cc7017a4e5cb92a04e3ba80c2e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;true&lt;/code&gt; if the last socket operation failed because the socket was in non-blocking mode and the operation would have blocked.</source>
          <target state="translated">&lt;code&gt;true&lt;/code&gt; 소켓이 비 블로킹 모드에 있고 작업이 차단되어 마지막 소켓 작업이 실패한 경우 true 입니다.</target>
        </trans-unit>
        <trans-unit id="c88d13eb3e3221036fb4aac2edb3a5f74da225b9" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;true&lt;/code&gt; if the lock was successful, and &lt;code&gt;false&lt;/code&gt; if the specified file segment was already locked.</source>
          <target state="translated">&lt;code&gt;true&lt;/code&gt; 잠금에 성공하면 true 이고 지정된 파일 세그먼트가 이미 잠겨 있으면 &lt;code&gt;false&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="c391a399880ca8ac7ebb20fbb88f6087244d9d1f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;true&lt;/code&gt; if the needle was found, in which case &lt;code&gt;haystack&lt;/code&gt; is positioned after the end of the first occurrence of &lt;code&gt;needle&lt;/code&gt;; otherwise &lt;code&gt;false&lt;/code&gt;, leaving &lt;code&gt;haystack&lt;/code&gt; untouched. If no needle is provided, it returns the number of times &lt;code&gt;pred(haystack.front)&lt;/code&gt; returned true.</source>
          <target state="translated">&lt;code&gt;true&lt;/code&gt; 바늘이 발견되었을 경우,이 경우 &lt;code&gt;haystack&lt;/code&gt; 의 첫번째 발생의 종료 후에 위치되는 &lt;code&gt;needle&lt;/code&gt; ; 그렇지 않으면 &lt;code&gt;false&lt;/code&gt; , &lt;code&gt;haystack&lt;/code&gt; 그대로 둡니다 . 바늘이 제공되지 않으면 &lt;code&gt;pred(haystack.front)&lt;/code&gt; true를 반환 한 횟수를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="a175ce1d936dfebd42507cfbe21c8b2e7b23d9de" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;true&lt;/code&gt; if the prefix of &lt;code&gt;haystack&lt;/code&gt; matches any range of &lt;code&gt;needles&lt;/code&gt; fully or &lt;code&gt;pred&lt;/code&gt; evaluates to true, and &lt;code&gt;haystack&lt;/code&gt; has been advanced to the point past this segment; otherwise false, and &lt;code&gt;haystack&lt;/code&gt; is left in its original position.</source>
          <target state="translated">&lt;code&gt;true&lt;/code&gt; 의 접두사 경우 &lt;code&gt;haystack&lt;/code&gt; 의 범위와 일치 &lt;code&gt;needles&lt;/code&gt; 완전히 또는 &lt;code&gt;pred&lt;/code&gt; 참으로 평가를하고, &lt;code&gt;haystack&lt;/code&gt; 이 부분을 건너 뛸 지점으로 진행되었습니다; 그렇지 않으면 거짓이며 &lt;code&gt;haystack&lt;/code&gt; 는 원래 위치에 남아 있습니다.</target>
        </trans-unit>
        <trans-unit id="4c24804d7d89da4dbfceb2e23da57e0da329b035" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;true&lt;/code&gt; if the range is sorted, false otherwise. &lt;code&gt;isSorted&lt;/code&gt; allows duplicates, &lt;code&gt;isStrictlyMonotonic&lt;/code&gt; not.</source>
          <target state="translated">&lt;code&gt;true&lt;/code&gt; 범위가 정렬되어있는 경우, 그렇지 않은 경우는 false. &lt;code&gt;isSorted&lt;/code&gt; 는 중복을 허용하고 &lt;code&gt;isStrictlyMonotonic&lt;/code&gt; 은 허용 하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="83d1f2aff5b95cbd92a0fce194d4b5a2cbf7071c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;true&lt;/code&gt; if the reference count is greater than &lt;code&gt;0&lt;/code&gt; and &lt;code&gt;false&lt;/code&gt; when it hits &lt;code&gt;0&lt;/code&gt;. For stateless allocators, it always returns &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;true&lt;/code&gt; 참조 횟수가보다 큰 경우 &lt;code&gt;0&lt;/code&gt; 과 &lt;code&gt;false&lt;/code&gt; 이 칠 때 &lt;code&gt;0&lt;/code&gt; . 상태 비 저장 할당 자의 경우 항상 &lt;code&gt;true&lt;/code&gt; 를 반환 합니다 .</target>
        </trans-unit>
        <trans-unit id="90eac6476595c502fd3275f7a9821859015a444f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;true&lt;/code&gt; if the thread was created by &lt;code&gt;createLowLevelThread&lt;/code&gt; and is still running.</source>
          <target state="translated">&lt;code&gt;true&lt;/code&gt; 스레드가 &lt;code&gt;createLowLevelThread&lt;/code&gt; 에 의해 작성되었고 여전히 실행중인 경우 true 입니다.</target>
        </trans-unit>
        <trans-unit id="ccd328eef72a7bff331437c901f6ecfa74aa6c6c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;true&lt;/code&gt; if the two items are approximately equal under either criterium. If one item is a range, and the other is a single value, then the result is the logical and-ing of calling &lt;code&gt;approxEqual&lt;/code&gt; on each element of the ranged item against the single item. If both items are ranges, then &lt;code&gt;approxEqual&lt;/code&gt; returns &lt;code&gt;true&lt;/code&gt; if and only if the ranges have the same number of elements and if &lt;code&gt;approxEqual&lt;/code&gt; evaluates to &lt;code&gt;true&lt;/code&gt; for each pair of elements.</source>
          <target state="translated">&lt;code&gt;true&lt;/code&gt; 두 항목이 어느 한 기준에서 거의 동일한 경우 true 입니다. 한 항목이 범위이고 다른 항목이 단일 값인 경우 결과는 단일 항목에 대해 범위가 지정된 항목의 각 요소에 대해 &lt;code&gt;approxEqual&lt;/code&gt; 을 호출하는 논리적 인 결과입니다 . 두 항목 범위 인 경우에, &lt;code&gt;approxEqual&lt;/code&gt; 는 반환 &lt;code&gt;true&lt;/code&gt; 범위 요소의면, 같은 수있는 경우에만 경우 &lt;code&gt;approxEqual&lt;/code&gt; 의 평가를 &lt;code&gt;true&lt;/code&gt; 요소의 각 쌍에 대해.</target>
        </trans-unit>
        <trans-unit id="7bca98b9828324a100c5c2bf450aba6fec922fc8" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;true&lt;/code&gt; if the values are ordered; &lt;code&gt;ordered&lt;/code&gt; allows for duplicates, &lt;code&gt;strictlyOrdered&lt;/code&gt; does not.</source>
          <target state="translated">&lt;code&gt;true&lt;/code&gt; 값이 정렬되면 true 이고; &lt;code&gt;ordered&lt;/code&gt; 는 중복을 허용하지만 &lt;code&gt;strictlyOrdered&lt;/code&gt; 주문 하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="e52eb334eccf7af84905903e88bbc2ee4e2362a0" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;true&lt;/code&gt; if this &lt;code&gt;Declaration&lt;/code&gt; is &lt;code&gt;@disable&lt;/code&gt;d, &lt;code&gt;false&lt;/code&gt; otherwise.</source>
          <target state="translated">&lt;code&gt;true&lt;/code&gt; 이 &lt;code&gt;Declaration&lt;/code&gt; 이 &lt;code&gt;@disable&lt;/code&gt; 인 경우 는 true , 그렇지 않은 경우 는 &lt;code&gt;false&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="ea21e9fc593db78397da9a076ce8abbf1795e14e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;true&lt;/code&gt; if this class is a metaclass.</source>
          <target state="translated">&lt;code&gt;true&lt;/code&gt; 이 클래스가 메타 클래스 인 경우는 true</target>
        </trans-unit>
        <trans-unit id="3b23821093362e8fee7cf930fb569f2afa7dccae" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;true&lt;/code&gt; if this class is externally defined.</source>
          <target state="translated">&lt;code&gt;true&lt;/code&gt; 이 클래스가 외부 적으로 정의되어있는 경우는 true</target>
        </trans-unit>
        <trans-unit id="b6c35c42020228b2903355d9cbb57558c69b2b25" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;true&lt;/code&gt; if this duration is non-zero.</source>
          <target state="translated">&lt;code&gt;true&lt;/code&gt; 이 기간이 0이 아닌 경우 true 입니다.</target>
        </trans-unit>
        <trans-unit id="19e69c3151c77c41b315753ae89fb38727bd2d21" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;true&lt;/code&gt; if warnings have been diagnosed</source>
          <target state="translated">&lt;code&gt;true&lt;/code&gt; 경고가 진단 된 경우 true</target>
        </trans-unit>
        <trans-unit id="be3d6f4970bb17847deff217df6bcc9c3542ea2c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;true&lt;/code&gt; if x is &amp;plusmn;&amp;infin;.</source>
          <target state="translated">&lt;code&gt;true&lt;/code&gt; x가 &amp;plusmn; &amp;infin; 이면 true 입니다.</target>
        </trans-unit>
        <trans-unit id="a2e10729efeca8adc0d5e6c2e9608120e2e73efe" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;true&lt;/code&gt; if x is Nan.</source>
          <target state="translated">&lt;code&gt;true&lt;/code&gt; x가 Nan 이면 true 입니다.</target>
        </trans-unit>
        <trans-unit id="392a8f18d3aafeb3b757fe74ab32cf1c8d68ff76" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;true&lt;/code&gt; if x is a denormal number.</source>
          <target state="translated">&lt;code&gt;true&lt;/code&gt; x가 비정규 숫자 이면 true 입니다.</target>
        </trans-unit>
        <trans-unit id="5c80c7160cf5bcaed5afcbc690d5e1ce55fce1ad" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;true&lt;/code&gt; if x is finite.</source>
          <target state="translated">&lt;code&gt;true&lt;/code&gt; x가 유한하면 true 입니다.</target>
        </trans-unit>
        <trans-unit id="70b59e8a6fb2a9a46b8b33eef61ecbe8e59ffb8b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;true&lt;/code&gt; if x is normalized.</source>
          <target state="translated">&lt;code&gt;true&lt;/code&gt; x가 정규화되면 true 입니다.</target>
        </trans-unit>
        <trans-unit id="5e2e042678636c0e2dc5b38da9c0df243832199c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;true&lt;/code&gt; iff &lt;code&gt;member&lt;/code&gt; exists and is static.</source>
          <target state="translated">&lt;code&gt;true&lt;/code&gt; iff &lt;code&gt;member&lt;/code&gt; 가 존재하며 정적입니다.</target>
        </trans-unit>
        <trans-unit id="873cb5b33a579701b5fe0d3c103392dc3bf3a28d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;true&lt;/code&gt; iff all types &lt;code&gt;T&lt;/code&gt; are the same.</source>
          <target state="translated">&lt;code&gt;true&lt;/code&gt; 모든 유형 &lt;code&gt;T&lt;/code&gt; 가 동일하면 true 입니다.</target>
        </trans-unit>
        <trans-unit id="a6b6da9695a900a242b2f7d02cd85c2472b5dfc1" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;true&lt;/code&gt; iff ready to call &lt;code&gt;dmd.statementsem.makeTupleForeach&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;true&lt;/code&gt; &lt;code&gt;dmd.statementsem.makeTupleForeach&lt;/code&gt; 를 호출 할 준비가 되었으면 true 입니다.</target>
        </trans-unit>
        <trans-unit id="1351a06c681ea01bec618f6884bbd34de37b7523" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;true&lt;/code&gt; iff the type &lt;code&gt;T&lt;/code&gt; can be tested in an &lt;code&gt; if&lt;/code&gt;-expression, that is if &lt;code&gt;if (pred(T.init)) {}&lt;/code&gt; is compilable.</source>
          <target state="translated">&lt;code&gt;true&lt;/code&gt; 형식 IFF &lt;code&gt;T&lt;/code&gt; 는 테스트 할 수 &lt;code&gt; if&lt;/code&gt; 경우 즉, -expression &lt;code&gt;if (pred(T.init)) {}&lt;/code&gt; 컴파일 가능한 것이다.</target>
        </trans-unit>
        <trans-unit id="cbc3cedfb1abd592f57b3f79cdab586da17c3d3b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;true&lt;/code&gt; in case the permutation worked, &lt;code&gt;false&lt;/code&gt; in case &lt;code&gt;perm&lt;/code&gt; had more digits in the factorial number system than range had elements. This case must not occur as this would lead to out of range accesses.</source>
          <target state="translated">&lt;code&gt;true&lt;/code&gt; 순열이 일 경우, &lt;code&gt;false&lt;/code&gt; 경우에 &lt;code&gt;perm&lt;/code&gt; 범위 요소를 가지고보다 계승 수 체계에 더 많은 숫자를했다. 이 경우 범위를 벗어난 액세스가 발생할 수 있으므로 발생해서는 안됩니다.</target>
        </trans-unit>
        <trans-unit id="fd7e986aa9a43e1d6abe499e7204cd25c3bfab21" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;true&lt;/code&gt; on success and &lt;code&gt;false&lt;/code&gt; on failure</source>
          <target state="translated">&lt;code&gt;true&lt;/code&gt; 성공과 &lt;code&gt;false&lt;/code&gt; 실패</target>
        </trans-unit>
        <trans-unit id="849941da8f86be5e40746a14f2e59a072ae48a82" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;true&lt;/code&gt; upon success, &lt;code&gt;false&lt;/code&gt; if memory could not be allocated. In the latter case &lt;code&gt;array&lt;/code&gt; is left unaffected.</source>
          <target state="translated">&lt;code&gt;true&lt;/code&gt; 성공시 &lt;code&gt;false&lt;/code&gt; 메모리를 할당 할 수없는 경우. 후자의 경우 &lt;code&gt;array&lt;/code&gt; 은 영향을받지 않습니다.</target>
        </trans-unit>
        <trans-unit id="10732ac56ce3f0e5bd6f2a954e9827563a8258a5" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;true&lt;/code&gt; upon success, &lt;code&gt;false&lt;/code&gt; if memory could not be reallocated. In the latter case &lt;code&gt;arr[$ - delta .. $]&lt;/code&gt; is left with default-initialized elements.</source>
          <target state="translated">&lt;code&gt;true&lt;/code&gt; 성공시 &lt;code&gt;false&lt;/code&gt; 메모리를 재 할당 할 수없는 경우. 후자의 경우 &lt;code&gt;arr[$ - delta .. $]&lt;/code&gt; 는 기본 초기화 요소로 남습니다.</target>
        </trans-unit>
        <trans-unit id="01b642e31c66a686661a487c4cef012c4988d3b2" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;true&lt;/code&gt; upon success, &lt;code&gt;false&lt;/code&gt; if memory could not be reallocated. In the latter case, the slice &lt;code&gt;array[$ - delta .. $]&lt;/code&gt; is left with default-initialized elements.</source>
          <target state="translated">&lt;code&gt;true&lt;/code&gt; 성공시 &lt;code&gt;false&lt;/code&gt; 메모리를 재 할당 할 수없는 경우. 후자의 경우 슬라이스 &lt;code&gt;array[$ - delta .. $]&lt;/code&gt; 은 기본적으로 초기화 된 요소로 남습니다.</target>
        </trans-unit>
        <trans-unit id="1599a1c8f77f5355dd6f302974ae6e748423331a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;true&lt;/code&gt;, if the function has the list of attributes attached and &lt;code&gt;false&lt;/code&gt; otherwise.</source>
          <target state="translated">&lt;code&gt;true&lt;/code&gt; 함수에 속성 ​​목록이 첨부되어 있으면 true 이고, 그렇지 않으면 &lt;code&gt;false&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="e74013817c4f54e852c614b55224f04ed73cb603" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;typeof(return)&lt;/code&gt; will, when inside a function scope, give the return type of that function.</source>
          <target state="translated">&lt;code&gt;typeof(return)&lt;/code&gt; 은 함수 범위 내에있을 때 해당 함수의 반환 유형을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="401c131af329fb39ea8b1f78929613004978cd51" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;typeof(this)&lt;/code&gt; will generate the type of what &lt;code&gt;this&lt;/code&gt; would be in a non-static member function, even if not in a member function.</source>
          <target state="translated">&lt;code&gt;typeof(this)&lt;/code&gt; 어떤 유형 생성 &lt;code&gt;this&lt;/code&gt; , 비 정적 멤버 함수에있을 것입니다을 심지어 멤버 함수에없는 경우.</target>
        </trans-unit>
        <trans-unit id="779537377c86a249b1949eb047163a4ef1e9694b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;ubyte&lt;/code&gt; becomes &lt;code&gt;char&lt;/code&gt;, &lt;code&gt;ushort&lt;/code&gt; becomes &lt;code&gt;wchar&lt;/code&gt; and &lt;code&gt;uint&lt;/code&gt; becomes &lt;code&gt;dchar&lt;/code&gt;. Type qualifiers are preserved.</source>
          <target state="translated">&lt;code&gt;ubyte&lt;/code&gt; 는 &lt;code&gt;char&lt;/code&gt; , &lt;code&gt;ushort&lt;/code&gt; 는 &lt;code&gt;wchar&lt;/code&gt; , &lt;code&gt;uint&lt;/code&gt; 는 &lt;code&gt;dchar&lt;/code&gt; 가 됩니다. 형식 한정자가 유지됩니다.</target>
        </trans-unit>
        <trans-unit id="0f181d063de1eccb82f86b6c3b7003e8848e5b01" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;unbounded&lt;/code&gt; is a compile-time constant of type &lt;code&gt;size_t&lt;/code&gt; that several parameterized structures in this module recognize to mean &quot;infinite&quot; bounds for the parameter. For example, &lt;code&gt;Freelist&lt;/code&gt; (described in detail below) accepts a &lt;code&gt;maxNodes&lt;/code&gt; parameter limiting the number of freelist items. If &lt;code&gt;unbounded&lt;/code&gt; is passed for &lt;code&gt;maxNodes&lt;/code&gt;, then there is no limit and no checking for the number of nodes.</source>
          <target state="translated">&lt;code&gt;unbounded&lt;/code&gt; 은 이 모듈의 여러 매개 변수화 된 구조가 매개 변수에 대한 &quot;무한&quot;범위를 의미하는 것으로 인식하는 &lt;code&gt;size_t&lt;/code&gt; 유형의 컴파일 타임 상수입니다 . 예를 들어, &lt;code&gt;Freelist&lt;/code&gt; (아래에서 상세히 설명)를 수용 &lt;code&gt;maxNodes&lt;/code&gt; 가능리스트 항목의 수를 제한하는 파라미터. &lt;code&gt;maxNodes&lt;/code&gt; 에 대해 &lt;code&gt;unbounded&lt;/code&gt; 이 전달 되면 제한 이 없고 노드 수를 확인하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="8bc437caf54a4442736a6c2461d4505138f55f91" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;uniform01&lt;/code&gt; offers a faster generation of random variates than the equivalent &lt;code&gt;uniform!&quot;[)&quot;(0.0, 1.0)&lt;/code&gt; and so may be preferred for some applications.</source>
          <target state="translated">&lt;code&gt;uniform01&lt;/code&gt; 은 등가의 &lt;code&gt;uniform!&quot;[)&quot;(0.0, 1.0)&lt;/code&gt; 보다 더 빠른 랜덤 변량을 생성합니다 ! &quot;[)&quot;(0.0, 1.0) 따라서 일부 응용 분야에 적합 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5f1669e35822ad6d7a8ef7e1190d0d0a8687f82d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;unsigned long&lt;/code&gt; (or &lt;code&gt;unsigned long long&lt;/code&gt;)</source>
          <target state="translated">&lt;code&gt;unsigned long&lt;/code&gt; (또는 &lt;code&gt;unsigned long long&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="a511ddc689072ede3fe30ef960085644f7eca030" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;unwrap&lt;/code&gt; can be used to extract objects which have been wrapped by &lt;code&gt;wrap&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;unwrap&lt;/code&gt; 은 &lt;code&gt;wrap&lt;/code&gt; 으로 감싸 진 객체를 추출하는 데 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="45acfa21317d0063756937f5ee8baff7f58f6535" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;upload(&quot;/tmp/downloaded-ftp-file&quot;, &quot;ftp.digitalmars.com/sieve.ds&quot;);&lt;/code&gt; uploads file from file system to URL.</source>
          <target state="translated">&lt;code&gt;upload(&quot;/tmp/downloaded-ftp-file&quot;, &quot;ftp.digitalmars.com/sieve.ds&quot;);&lt;/code&gt; 파일 시스템에서 URL로 파일을 업로드합니다.</target>
        </trans-unit>
        <trans-unit id="3d60e080a176215c5a1b49107f6911976cc162b2" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;value&lt;/code&gt;, if &lt;code&gt;cast(bool) value&lt;/code&gt; is true. Otherwise, &lt;code&gt;new ErrnoException(msg)&lt;/code&gt; is thrown. It is assumed that the last operation set &lt;code&gt;errno&lt;/code&gt; to an error code corresponding with the failed condition.</source>
          <target state="translated">&lt;code&gt;value&lt;/code&gt; , 경우 &lt;code&gt;cast(bool) value&lt;/code&gt; true입니다. 그렇지 않으면 &lt;code&gt;new ErrnoException(msg)&lt;/code&gt; 이 발생합니다. 마지막 조작 세트 &lt;code&gt;errno&lt;/code&gt; 는 실패 조건에 해당하는 오류 코드 로 가정 됩니다.</target>
        </trans-unit>
        <trans-unit id="a27040952215ed3b860dd4df6cc49b621ae01b6c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;value&lt;/code&gt;, if &lt;code&gt;cast(bool) value&lt;/code&gt; is true. Otherwise, depending on the chosen overload, &lt;code&gt;new Exception(msg)&lt;/code&gt;, &lt;code&gt;dg()&lt;/code&gt; or &lt;code&gt;ex&lt;/code&gt; is thrown.</source>
          <target state="translated">&lt;code&gt;value&lt;/code&gt; , 경우 &lt;code&gt;cast(bool) value&lt;/code&gt; true입니다. 그렇지 않으면 선택한 과부하에 따라 &lt;code&gt;new Exception(msg)&lt;/code&gt; , &lt;code&gt;dg()&lt;/code&gt; 또는 &lt;code&gt;ex&lt;/code&gt; 가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="89ce2b9510af56abd276e49fc0c6896c8c2ee1ec" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;void __aggrPostblit()&lt;/code&gt;. If a struct has an explicitly defined postblit and at least 1 struct member that has a postblit (explicit or implicit) an aggregated postblit is generated which calls &lt;code&gt;__fieldPostblit&lt;/code&gt; first and then &lt;code&gt;__postblit&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;void __aggrPostblit()&lt;/code&gt; . 구조체에 명시 적으로 정의 된 포스트 블리트와 포스트 블리트 (명시 적 또는 암시 적)를 갖는 적어도 하나의 구조체 멤버가있는 경우 &lt;code&gt;__fieldPostblit&lt;/code&gt; 을 먼저 호출 한 다음 &lt;code&gt;__postblit&lt;/code&gt; 을 호출하는 집계 된 포스트 블릿이 생성됩니다 .</target>
        </trans-unit>
        <trans-unit id="a7d412974083659735c5bf3a9a43ad6ac9e004c7" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;void __fieldPostblit()&lt;/code&gt;. If a struct &lt;code&gt;X&lt;/code&gt; has at least one &lt;code&gt;struct&lt;/code&gt; member that in turn defines (explicitly or implicitly) a postblit, then a field postblit is generated for &lt;code&gt;X&lt;/code&gt; that calls all the underlying postblits of the struct fields in declaration order.</source>
          <target state="translated">&lt;code&gt;void __fieldPostblit()&lt;/code&gt; . 구조체 &lt;code&gt;X&lt;/code&gt; 에 포스트 블리트를 (명시 적으로 또는 암시 적으로) 정의하는 &lt;code&gt;struct&lt;/code&gt; 멤버가 하나 이상 있으면 구조체 필드의 모든 기본 포스트 블릿을 선언 순서대로 호출 하는 필드 포스트 블릿이 &lt;code&gt;X&lt;/code&gt; 에 대해 생성됩니다 .</target>
        </trans-unit>
        <trans-unit id="43cee24221eb62cef3e2c687882ab5a08633aff2" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;void __postblit()&lt;/code&gt;. The compiler assigns this name to the explicitly defined postblit &lt;code&gt;this(this)&lt;/code&gt; so that it can be treated exactly as a normal function. Note that if a struct defines a postblit, it cannot define a function named &lt;code&gt;__postblit&lt;/code&gt; - no matter the signature - as this would result in a compilation error due to the name conflict.</source>
          <target state="translated">&lt;code&gt;void __postblit()&lt;/code&gt; . 컴파일러는이 이름을 명시 적으로 정의 된 postblit &lt;code&gt;this(this)&lt;/code&gt; 할당하여 정확하게 일반 함수로 취급 할 수 있도록합니다. 구조체가 포스트 블릿을 정의 하면 서명과 상관없이 &lt;code&gt;__postblit&lt;/code&gt; 이라는 함수를 정의 할 수 없습니다 . 이름 충돌로 인해 컴파일 오류가 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="dc6d1a9f79c3a9d7761e5aff58d0729c99ffc5b0" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;void __xpostblit()&lt;/code&gt;. The field and aggregated postblits, although generated for a struct, are not actual struct members. In order to be able to call them, the compiler internally creates an alias, called &lt;code&gt;__xpostblit&lt;/code&gt; which is a member of the struct and which points to the generated postblit that is the most inclusive.</source>
          <target state="translated">&lt;code&gt;void __xpostblit()&lt;/code&gt; . 필드와 집계 된 포스트 블리트는 구조체에 대해 생성되었지만 실제 구조체 멤버가 아닙니다. 이를 호출하기 위해 컴파일러는 내부적으로 &lt;code&gt;__xpostblit&lt;/code&gt; 이라는 별칭을 생성합니다.이 별칭 은 구조체의 멤버이며 가장 포괄적 인 생성 된 포스트 블릿을 가리 킵니다.</target>
        </trans-unit>
        <trans-unit id="25815dc372c3c73661b0a266b38876dd6894ac4c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;void*&lt;/code&gt;, catch handler code</source>
          <target state="translated">&lt;code&gt;void*&lt;/code&gt; , 캐치 핸들러 코드</target>
        </trans-unit>
        <trans-unit id="18c0cd3b31df7367a71c75205c8ae819cf902d5c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;void[]&lt;/code&gt; is formatted like &lt;code&gt;ubyte[]&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;void[]&lt;/code&gt; 는 &lt;code&gt;ubyte[]&lt;/code&gt; 와 같은 형식 입니다.</target>
        </trans-unit>
        <trans-unit id="879559c0d4c10d9f1613c9c2ea4e1ebd13338b46" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;walkLength(src) &amp;lt;= walkLength(tgt)&lt;/code&gt;. This precondition will be asserted. If you cannot ensure there is enough room in &lt;code&gt;tgt&lt;/code&gt; to accommodate all of &lt;code&gt;src&lt;/code&gt; use &lt;a href=&quot;#moveSome&quot;&gt;&lt;code&gt;moveSome&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="translated">&lt;code&gt;walkLength(src) &amp;lt;= walkLength(tgt)&lt;/code&gt; 입니다. 이 전제 조건이 주장 될 것이다. 당신은 보장 할 수없는 경우에 충분한 공간이 &lt;code&gt;tgt&lt;/code&gt; 를 모두 수용 할 수 &lt;code&gt;src&lt;/code&gt; 사용 &lt;a href=&quot;#moveSome&quot;&gt; &lt;code&gt;moveSome&lt;/code&gt; 을&lt;/a&gt; 대신은.</target>
        </trans-unit>
        <trans-unit id="9fa5adcc8bbbe8c7dbc689f02b582cfbdc6e2b7a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;wchar_t&lt;/code&gt; (when &lt;code&gt;sizeof(wchar_t)&lt;/code&gt; is 2)</source>
          <target state="translated">&lt;code&gt;wchar_t&lt;/code&gt; ( &lt;code&gt;sizeof(wchar_t)&lt;/code&gt; 가 2 인 경우)</target>
        </trans-unit>
        <trans-unit id="4068d60126f19ea07b4c62829deefe17a30c0b36" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;wchar_t&lt;/code&gt; (when &lt;code&gt;sizeof(wchar_t)&lt;/code&gt; is 4)</source>
          <target state="translated">&lt;code&gt;wchar_t&lt;/code&gt; ( &lt;code&gt;sizeof(wchar_t)&lt;/code&gt; 가 4 인 경우)</target>
        </trans-unit>
        <trans-unit id="2b068e31aeae500c9824222981eba3a5720d1923" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;x86_64&lt;/code&gt; adds these additional registers.</source>
          <target state="translated">&lt;code&gt;x86_64&lt;/code&gt; 는 이러한 추가 레지스터를 추가합니다.</target>
        </trans-unit>
        <trans-unit id="65ad3e1a76ad32463dc9020237a5d914d2d31a09" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;x&lt;/code&gt; rounded to an integer value</source>
          <target state="translated">&lt;code&gt;x&lt;/code&gt; 는 정수 값으로 반올림</target>
        </trans-unit>
        <trans-unit id="1a8b8f719d68c5db31ae5c5b532606293873c9f6" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;x&lt;/code&gt; to the power &lt;code&gt;n&lt;/code&gt;, modulo &lt;code&gt;m&lt;/code&gt;. The return type is the largest of &lt;code&gt;x&lt;/code&gt;'s and &lt;code&gt;m&lt;/code&gt;'s type.  The function requires that all values have unsigned types.</source>
          <target state="translated">&lt;code&gt;x&lt;/code&gt; 의 거듭 제곱 &lt;code&gt;n&lt;/code&gt; , 모듈로 &lt;code&gt;m&lt;/code&gt; . 반환 유형은 &lt;code&gt;x&lt;/code&gt; 및 &lt;code&gt;m&lt;/code&gt; 유형 중 가장 큰 유형입니다. 이 기능을 사용하려면 모든 값에 부호없는 유형이 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="b0a4cffb76a02e21c3feea7c78cbcb8a08519c85" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;zip&lt;/code&gt; is powerful - the following code sorts two arrays in parallel:</source>
          <target state="translated">&lt;code&gt;zip&lt;/code&gt; 은 강력합니다. 다음 코드는 두 배열을 병렬로 정렬합니다.</target>
        </trans-unit>
        <trans-unit id="459db4250d5bf26b0be3b8f2acabeedcdb7411ca" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;zip&lt;/code&gt; is similar to &lt;a href=&quot;#lockstep&quot;&gt;&lt;code&gt;lockstep&lt;/code&gt;&lt;/a&gt;, but &lt;code&gt;lockstep&lt;/code&gt; doesn't bundle its elements and uses the &lt;code&gt;opApply&lt;/code&gt; protocol. &lt;code&gt;lockstep&lt;/code&gt; allows reference access to the elements in &lt;code&gt;foreach&lt;/code&gt; iterations.</source>
          <target state="translated">&lt;code&gt;zip&lt;/code&gt; 은 &lt;a href=&quot;#lockstep&quot;&gt; &lt;code&gt;lockstep&lt;/code&gt; &lt;/a&gt; 과 유사 하지만 &lt;code&gt;lockstep&lt;/code&gt; 은 해당 요소를 번들로 묶지 않고 &lt;code&gt;opApply&lt;/code&gt; 프로토콜을 사용합니다 . &lt;code&gt;lockstep&lt;/code&gt; 은 &lt;code&gt;foreach&lt;/code&gt; 반복 에서 요소에 대한 참조 액세스를 허용 합니다.</target>
        </trans-unit>
        <trans-unit id="1ef6339fb889601443d9770b014f952cfe5e025f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;|&lt;/code&gt;&lt;code&gt;=&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;|&lt;/code&gt;&lt;code&gt;=&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="3a7b5c722aed22925a460482c6466ebf4260e520" translate="yes" xml:space="preserve">
          <source>&lt;em&gt; Access &lt;/em&gt;</source>
          <target state="translated">&lt;em&gt; Access &lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="bc30681a7eae3ef70207f0d141b2a462299b888b" translate="yes" xml:space="preserve">
          <source>&lt;em&gt; Algorithms &amp;amp; ranges&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt; 알고리즘 및 범위&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="c095a8951c487c309f82861a4f4ba04ba2d45500" translate="yes" xml:space="preserve">
          <source>&lt;em&gt; Array manipulation&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt; 배열 조작&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="d0bc0ed5b74d5a0db56a0d91a4a4797dbf06a96d" translate="yes" xml:space="preserve">
          <source>&lt;em&gt; Capacity &lt;/em&gt;</source>
          <target state="translated">&lt;em&gt; Capacity &lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="0b8d298cf54c59ef00375c100cdfb8d6246ef00c" translate="yes" xml:space="preserve">
          <source>&lt;em&gt; Containers&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt; Containers&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="94395c48227e3036d6b3e6673878c713799d0dc8" translate="yes" xml:space="preserve">
          <source>&lt;em&gt; Data formats&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt; 데이터 형식&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="92ffb86b899cbe82077812e59698e2b2dac9aa46" translate="yes" xml:space="preserve">
          <source>&lt;em&gt; Data integrity&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt; 데이터 무결성&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="fc68b0afd4817d6d1bd5753f9fce96373cab87a4" translate="yes" xml:space="preserve">
          <source>&lt;em&gt; Date &amp;amp; time&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt; 날짜 시간&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="8b2d246f9ef73764d6765ea2cf5aff25de8a3b56" translate="yes" xml:space="preserve">
          <source>&lt;em&gt; Exception handling&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt; 예외 처리&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="b6c2a4f16f0034306a7ee08545b129367c57d55b" translate="yes" xml:space="preserve">
          <source>&lt;em&gt; External library bindings&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt; 외부 라이브러리 바인딩&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="e6c17ec0940f424ec5767e37367bc5ed3d9144b6" translate="yes" xml:space="preserve">
          <source>&lt;em&gt; Functions&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt; Functions&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="e3cec7e3fb7e40acf8687eb1f9231ecb635e5486" translate="yes" xml:space="preserve">
          <source>&lt;em&gt; High level&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt; 높은 레벨&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="6c816329c6776a07d0287baa6e3483feaede6b41" translate="yes" xml:space="preserve">
          <source>&lt;em&gt; I/O &amp;amp; File system&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt; I / O 및 파일 시스템&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="f75118f780d0ae77b25ca4b32d07c19523d14214" translate="yes" xml:space="preserve">
          <source>&lt;em&gt; Interoperability&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt; Interoperability&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="a93e169344d9e4b578679263af9c3ac09d6ee1ea" translate="yes" xml:space="preserve">
          <source>&lt;em&gt; Iteration &lt;/em&gt;</source>
          <target state="translated">&lt;em&gt; Iteration &lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="0fa3d22678c42ecb9ef7abc360e4b4f19eb19127" translate="yes" xml:space="preserve">
          <source>&lt;em&gt; Low level &lt;/em&gt;</source>
          <target state="translated">&lt;em&gt; 저수준 &lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="dccbd3fd9070ee1b3641cbf486f64a3b2200d84b" translate="yes" xml:space="preserve">
          <source>&lt;em&gt; Memory management&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt; 메모리 관리&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="09a5c6f5efe26853892ad44c63201a6603c81a23" translate="yes" xml:space="preserve">
          <source>&lt;em&gt; Metaprogramming&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt; Metaprogramming&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="1e883194753e4ca161843ed4c9237dabce84b58e" translate="yes" xml:space="preserve">
          <source>&lt;em&gt; Modifiers &lt;/em&gt;</source>
          <target state="translated">&lt;em&gt; Modifiers &lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="847ecfd8ae03468bd0625c64f67549550880f970" translate="yes" xml:space="preserve">
          <source>&lt;em&gt; Multitasking&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt; Multitasking&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="6d0d417d2ad372e46c5080908386cd9255303ad7" translate="yes" xml:space="preserve">
          <source>&lt;em&gt; Networking&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt; Networking&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="38eae575d1a7828c72f73af9d9797c05a26ddbb6" translate="yes" xml:space="preserve">
          <source>&lt;em&gt; Numeric&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt; Numeric&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="33af9b4935b253ac84014f9f785f136db3c78d1f" translate="yes" xml:space="preserve">
          <source>&lt;em&gt; Operations &lt;/em&gt;</source>
          <target state="translated">&lt;em&gt; Operations &lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="6a477843bafc9ce02245ad5f41eddd8012f73621" translate="yes" xml:space="preserve">
          <source>&lt;em&gt; Paradigms&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt; Paradigms&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="c499ab97bed7f2f3212ddbef25a6f926b3a369dd" translate="yes" xml:space="preserve">
          <source>&lt;em&gt; Publicly imported functions&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt; 공개적으로 가져온 함수&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="84f09ad7796ccc3798e30ab53b927446ab2753a4" translate="yes" xml:space="preserve">
          <source>&lt;em&gt; Runtime utilities&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt; 런타임 유틸리티&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="53e9f46dc618afd51e3c2220ffc47610b3bd4e7d" translate="yes" xml:space="preserve">
          <source>&lt;em&gt; String manipulation&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt; 문자열 조작&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="146cea4c54149c952b53a0477e6ff85e0e29beb6" translate="yes" xml:space="preserve">
          <source>&lt;em&gt; Type manipulations&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt; 타입 조작&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="fb940b2b4b3bd08198a84bc673ba50b694c644b7" translate="yes" xml:space="preserve">
          <source>&lt;em&gt; Types&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt; Types&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="4ae4efd4b54d81f463d5fd325dc5a206f87e9a2c" translate="yes" xml:space="preserve">
          <source>&lt;em&gt; Vector programming&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt; 벡터 프로그래밍&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="783ba461fe8c666b24948cbe429f77043b171614" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Digest&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;Digest&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="84f1bd19e3ec4781ade0f748a2af4b8c1dcda431" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Enable support for backticks, tildes and other code languages with the &lt;code&gt;-preview=markdown&lt;/code&gt; compiler flag.&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt; &lt;code&gt;-preview=markdown&lt;/code&gt; 컴파일러 플래그를 사용하여 백틱, 물결표 및 기타 코드 언어를 지원할 수 있습니다 .&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="1b14bb400fad8a7fda4989cb98829046ab5883e6" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Enable this feature with the &lt;code&gt;-preview=markdown&lt;/code&gt; compiler flag.&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt; &lt;code&gt;-preview=markdown&lt;/code&gt; 컴파일러 플래그를 사용하여이 기능을 사용하십시오 .&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="cad9826a40d7cac0dd92d79018b3a425cec01f08" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;ILLEGAL&lt;/em&gt; http version</source>
          <target state="translated">&lt;em&gt;불법&lt;/em&gt; http 버전</target>
        </trans-unit>
        <trans-unit id="84d700f33fd199df90a3b8e291da9156478a48b4" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;MD5&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;MD5&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="8d1994dff12ffcd867055351a399ba2eff31ce9d" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;MD5Digest&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;MD5Digest&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="ed4f96e25a72b758be38a8a066ce0bd22cfaee2b" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;RIPEMD160&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;RIPEMD160&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="99519fd2ab2e235270c1d71519b6d68c3fdb2e11" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;RIPEMD160Digest&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;RIPEMD160Digest&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="294dfbe626cd1401cd15424ac601518cbfe69a29" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;SHA1&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;SHA1&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="091d02fc9acad31c2d4e52ba53a8bf23e8c3403e" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;SHA1Digest&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;SHA1Digest&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="274ac3a3f91608d104539ec7c821c012efd92d78" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;aaa&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;aaa&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="7588babd4f0b2b7ae02e8880206eb18207292a1d" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;aad&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;aad&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="4df783b6d180de03478089805a881105f3cadd42" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;aam&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;aam&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="8d02f41518030b8787ab09bbea0a8d67d8426530" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;aas&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;aas&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="df4a4818708fc3de9efbe8d2eb2f496a975c1a29" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;adc&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;adc&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="6c5258bbe828a82728cc4ed33fa5b2a769a9f041" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;add&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;add&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="669607c013d13851e9589948d41c8ff14803f058" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;addpd&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;addpd&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="d4555a11aa4a3dc0d73314fed52e2c5863033ff0" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;addps&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;addps&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="603663458993a35a03f85b569f99582519b45931" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;addsd&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;addsd&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="d640f13a3f982b14dfddae136cc30f4cc82defea" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;addss&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;addss&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="171f846452747ed33bb422ca28d951e546292754" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;addsubpd&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;addsubpd&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="8fb1f304ece6367db702ee1a1bd5e2e4ab270e78" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;addsubps&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;addsubps&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="692844e1de9cbe71308e5612ae3e4cfc42de8708" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;and&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;and&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="f1f43e4d115e5a8a4c15ca434debeead3baab0d6" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;andnpd&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;andnpd&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="8ab94df34718b1bba3e84a58a1097218a1c7daf4" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;andnps&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;andnps&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="348d3191a05390d9cbad6ec44be415d8a1f0c000" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;andpd&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;andpd&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="aae24f7e7b696be2067e4ada439be0d551196469" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;andps&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;andps&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="e829bd0db8a8d33136116a19e0cb91efb0b02804" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;arpl&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;arpl&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="5db72c532589bf65d9ff177f7cd70a982f45a812" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;bound&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;bound&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="f2be76e7e30b8c49dd60bf29e87be13fdcab0454" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;bsf&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;bsf&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="7b797add93629d108f13ec585c788c0765e24409" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;bsr&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;bsr&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="09941d8edc03eb4f1479d6812e75a5f9cb78a645" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;bswap&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;bswap&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="ef6ed5d5231a531322255b844105cc5a57b1bc9c" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;bt&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;bt&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="741afc5feebc49fac328e2d55f1a5c6ebff8d914" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;btc&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;btc&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="72c37b8037304d3804e9927a88808a7c2f3ff260" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;btr&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;btr&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="e9e6ff86043a18a24c45d6aa76459fca75c116f6" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;bts&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;bts&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="a052cef3cc75f4db6315362acf22bfb2a0ffc8de" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;call&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;call&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="bc4e83871d6ca7b2eae6ae34476224eb2a912d01" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;capitalize&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;capitalize&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="8e0a35bbbcb6c86e72803d7111f1104aec236e63" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;cbw&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;cbw&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="b00bd98a17914276ba79dc6cd2f88a2474947cf1" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;cdq&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;cdq&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="e411be14fa5b56d5473617085fb4f0f4e3f7f36a" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;clc&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;clc&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="c00b6efa8c41835d737883544aa4bd41a660c9cb" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;cld&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;cld&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="848176d9242b520847d62dab0614e19f0dfb838d" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;clflush&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;clflush&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="c42d55ab12598b1bf7aca3776823b3d972284753" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;cli&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;cli&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="21eb9e5400447b8eed598b33915f4edb69478f62" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;clts&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;clts&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="b92aae5a57b2d06a48ce9e2daee0b70462c3965b" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;cmc&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;cmc&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="c6598c355738b0e360ba72ab86a54034892e816e" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;cmova&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;cmova&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="b03d2c951078153df871053f41018e8a7b055cb5" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;cmovae&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;cmovae&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="4129bdf5c54904383733140a3007452ccb97565a" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;cmovb&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;cmovb&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="1cc9172ddde5c38ce8c9f2fc625d0972979daa82" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;cmovbe&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;cmovbe&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="111e40dc4dfb04ec36c00e42a1a4469348f82e4f" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;cmovc&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;cmovc&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="4f78f56f5202094d19c9cfdf6728e9c684c46595" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;cmove&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;cmove&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="28441e770e85047a6c2abde03c02dc4bcae4d746" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;cmovg&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;cmovg&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="e0760d8c0f127239224a2bd5f35590ec8219bac3" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;cmovge&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;cmovge&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="3a27e2c4593e0d03a1930313afc14818fa014fbb" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;cmovl&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;cmovl&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="2989760e44dd4610b656a586a38b758185a79da7" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;cmovle&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;cmovle&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="7eb8390f413a550cb5f26327a8b3e97227e986e1" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;cmovna&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;cmovna&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="6e0dce8da3413b2fff4db97f460ea86bb850160d" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;cmovnae&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;cmovnae&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="8108b390f996ade5bee82f21813712772e3e5150" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;cmovnb&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;cmovnb&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="961409e858105693ff6e506a9fe09ddb85a1d9f1" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;cmovnbe&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;cmovnbe&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="e8ec2f5e6988d878bdcf0aa1f9abc88741d0e360" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;cmovnc&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;cmovnc&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="50bf45bb0404fc35cdd05e6a8f1086df7950ac47" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;cmovne&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;cmovne&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="06f747ed13ab2f2758ef319eb71920fd8f9a07fd" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;cmovng&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;cmovng&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="233166e6f6cc3f3c42e69dc03585a77158547670" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;cmovnge&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;cmovnge&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="d5f5c1e1d55eaf8f6555c0b6ebd01408d4014b24" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;cmovnl&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;cmovnl&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="d80091b5d9155625d0b4637ebae7a5e79c8718c3" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;cmovnle&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;cmovnle&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="f809a792dade42d8e9aca29d939269d6acc0c33a" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;cmovno&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;cmovno&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="5c5ae7612eee3a042ecfba8dd4d5201ef4709701" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;cmovnp&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;cmovnp&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="b93a97c2d6edfa89df3b90ad343d54aa44d58c51" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;cmovns&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;cmovns&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="064baaadd28f66c9a3583b8b61cd1a7f6b7bb720" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;cmovnz&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;cmovnz&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="c2ebd1a04852a74a4bf46bbe4d0242d136cd7fd9" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;cmovo&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;cmovo&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="c342c00f9155332857d93ef6805653ed9bacce09" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;cmovp&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;cmovp&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="97bac93bf4acbf2b992e27a64f08e567f0a113d0" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;cmovpe&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;cmovpe&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="86916e0031a3000ceff8db848b020b20ecd5a05c" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;cmovpo&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;cmovpo&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="bb9ce11f371fd4b2affd007558aa4e5e625ff8a0" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;cmovs&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;cmovs&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="a9604d101d312f98cbe257cccd691e5a0c31b2d7" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;cmovz&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;cmovz&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="6fd90bd9e4d1a433718ea1b68a8bb195571a7696" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;cmp&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;cmp&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="1cee5d7e8fcf38f1e3f065e891ae4cd9e8bd5be8" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;cmppd&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;cmppd&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="1e272176453fec8068368eed364102b1d225e7cd" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;cmpps&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;cmpps&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="6ce8db169aeeb9c89c2500e9b0b80e227974e6d6" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;cmps&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;cmps&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="6599c4c2d9ecb33f234e07c89bd4905d1b51e2b6" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;cmpsb&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;cmpsb&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="730f8126d0cf3675bf5b4c23998d30b19da1b487" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;cmpsd&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;cmpsd&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="2b21cb9e8933715b3ccd4d7a20e199590cec3818" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;cmpss&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;cmpss&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="fc0ad81c58c54c0d21ff0bdd053a7938368acdd4" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;cmpsw&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;cmpsw&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="e487c5f81006bc807e464143803badf158e6eddd" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;cmpxchg16b&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;cmpxchg16b&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="2f611050434a367a257b162eac17b4e2ef228d77" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;cmpxchg8b&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;cmpxchg8b&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="d498a2a43552a13063aa8894b9d1f17bee883670" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;cmpxchg&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;cmpxchg&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="cf58d302adc914b53e05998342d1661e161682e4" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;comisd&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;comisd&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="1bcf4cdf2222de470f5e2d9fbec06f695b7015d3" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;comiss&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;comiss&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="696f1015ca54a71bb83a44adebeed3728fe79275" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;cpuid&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;cpuid&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="b23c8423a7464aa9f278e00c526c0e7e149025c2" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;cvtdq2pd&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;cvtdq2pd&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="efb02186e74b91308bd79679c50c0efa595d5497" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;cvtdq2ps&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;cvtdq2ps&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="4e84b87118765de1da2fa66f186ffce7dfa9bbcb" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;cvtpd2dq&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;cvtpd2dq&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="60a3c073c2f273460c2e57ce0c75760b5b3c4513" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;cvtpd2pi&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;cvtpd2pi&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="4a3174aa806386b4d63772a7779fd8d2723df2a1" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;cvtpd2ps&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;cvtpd2ps&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="7519f3e2217487943b6c7c5106e4b943fa6e93b9" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;cvtpi2pd&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;cvtpi2pd&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="edc02a38a5b509554a8e0c90958e2209fd2e47be" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;cvtpi2ps&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;cvtpi2ps&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="57148a528d5075133b7af32f7eb1dfc6c9b78f23" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;cvtps2dq&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;cvtps2dq&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="3c263f20996de047aa56dd524d8fb912231403d6" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;cvtps2pd&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;cvtps2pd&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="ab7b2f1525535e426d09536867a145d357aec9c6" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;cvtps2pi&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;cvtps2pi&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="f1e2cc4b6ab4ccaf4a17041f6fa7b19209c229c3" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;cvtsd2si&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;cvtsd2si&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="0753b31c2ebb6c699cf5ebbbe000f08b2c5ab6e3" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;cvtsd2ss&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;cvtsd2ss&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="653583a9827218258f05df8e578f57daef9c87e5" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;cvtsi2sd&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;cvtsi2sd&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="874dea0f119c5edefcbe663654becb7e467bacf7" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;cvtsi2ss&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;cvtsi2ss&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="91322f99d4ac646d89b3f3f22c92d063f1d9d9d8" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;cvtss2sd&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;cvtss2sd&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="f308c1714555cde3135a09c2eac0944e1976a186" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;cvtss2si&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;cvtss2si&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="7b5810df70b4d9fabb0959e092847b418ae89d42" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;cvttpd2dq&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;cvttpd2dq&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="de17c417723497cf080e69f80bfcb8266fe9c0a0" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;cvttpd2pi&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;cvttpd2pi&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="3d5a8c0d32d62f8e239f763a8bb7c3351d0cddfc" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;cvttps2dq&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;cvttps2dq&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="7d54f5c169cd5fa3a152f4c4c8fd49778d89a2e0" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;cvttps2pi&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;cvttps2pi&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="97a4476a098b695765aa30ed12bc938dc44be2bb" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;cvttsd2si&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;cvttsd2si&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="3b88e3e55088a8855b1d0cecde751d72147ae482" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;cvttss2si&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;cvttss2si&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="669caaf5697e7d34fe62e05c80eb1402f1b950d6" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;cwd&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;cwd&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="31d6e7bd19fff86ce479820670b88ccf96b5130d" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;cwde&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;cwde&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="4e190ea7235dc0b20321199790eb30a3b953bbf0" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;da&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;da&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="4fd5b1a04d5951a7161e8c80a1d1373d2e082f25" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;daa&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;daa&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="73862bf3a5db403d402fdda6bff131bda683789c" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;das&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;das&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="888130835893ad0a4431b9e92e3bfb28c0d22d4f" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;db&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;db&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="37c1cbf29cfb5fb2d44ec24cde2861f1da38ab8c" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;dd&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;dd&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="e9f9ba688190888c6b4c8520163db67896658b42" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;de&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;de&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="c29343d6460a115a15c26a9fbe97cd46103cf4e3" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;dec&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;dec&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="d28e76d5ed75ae63c85b82cbc4e7e0e23009a39b" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;df&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;df&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="0e572dc634afc4215c76a3e18c98cd025090a954" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;di&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;di&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="832fe89e924c6f3f13f9319cb3470edfe51828bb" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;div&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;div&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="d8f67b0ba552607c0058389064ef22f24b888ce1" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;divpd&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;divpd&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="5405ff76508aa21c6049fd100b06e269f333124c" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;divps&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;divps&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="854d3262d677f6d1b9742af9731f5867a0b6fc4f" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;divsd&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;divsd&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="978211ee9b084908c11af536af9b99083351e71f" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;divss&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;divss&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="0137168f13119693a3164c917ddc72456310cbd1" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;dl&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;dl&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="c77490a0ba7588468cde78b2c7a3043fbad2438e" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;dq&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;dq&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="525f6057c83f7eafc09911773afe33e2d6e69f03" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;ds&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;ds&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="b90c84183fa55ef436c644a46ed425ec0335c9b6" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;dt&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;dt&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="09b7b7be48bc35b1be992df90414e882eb518d15" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;dw&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;dw&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="29c94bac6bb9031553e222e8503286f13713a2fe" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;emms&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;emms&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="d55c80f8c3e2ef8ce62d005de09e75e2ad916cec" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;enter&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;enter&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="338a12659fc0906399eb38fbe822015ca2962483" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;f2xm1&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;f2xm1&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="d55da3aaf092d8ff5828840252d69e8f06057dfd" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;fabs&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;fabs&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="630642bd09a59dff2a7ec932ea825151397adb5d" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;fadd&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;fadd&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="fa7fd23fe9f5f8ffab12444e35caea778c8558c0" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;faddp&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;faddp&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="b13e208f8ada129c4f82a0b45b8df9524f95774a" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;fbld&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;fbld&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="ec366ca140bae33b5e13019b0951cb511ad62f5e" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;fbstp&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;fbstp&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="e8292637dfa3fc477abdaf3b73d14b1b81cad934" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;fchs&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;fchs&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="30b2330c517611309fdcd480cf9450e5ca99c799" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;fclex&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;fclex&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="272678e667b446eed0a53765d1b139eddf95e6c1" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;fcmovb&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;fcmovb&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="4943a4b1ac0b9695f840e0990a71322d1bdbb74d" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;fcmovbe&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;fcmovbe&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="1da960602e6701c419e908c314a3b0f7b7bc9335" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;fcmove&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;fcmove&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="147f757a6e690cc5a0ac918c9ce28e3210557b74" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;fcmovnb&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;fcmovnb&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="3a711cb3ea7dd3846afe1244c76cda9369573210" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;fcmovnbe&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;fcmovnbe&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="1e42316dbc4457ea190a4026fe77e942616b11a4" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;fcmovne&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;fcmovne&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="74e2f5fad7f28ed432793a9bd55e627fcca69400" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;fcmovnu&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;fcmovnu&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="d6a1452b2302113a9bbfec4f4ac925533b08339b" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;fcmovu&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;fcmovu&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="4169e501ef550c4a5b35fc7e0a81823b4bea5cc6" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;fcom&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;fcom&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="f94fea85ac3e4cca049dc5fc8873ffc0cc4531a9" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;fcomi&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;fcomi&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="1d2fa4a0e8c96221feee8d1af2796994fadb3f17" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;fcomip&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;fcomip&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="f7f4be0d977cfd2c7d9be4e37a2658fc7ae09954" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;fcomp&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;fcomp&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="61953b004b222a98cbac3832568ff4c3e125d363" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;fcompp&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;fcompp&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="7a3016870eb6ea33a2181dfbb12af36ac7162e15" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;fcos&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;fcos&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="5256fe9cd0505c25d40df2dd34c4fb0c4c1c88ec" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;fdecstp&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;fdecstp&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="54d647d43192d34a249866a822da1c83b8fffb80" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;fdisi&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;fdisi&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="f968e2a24ff5d98b75bafa35613142ba2a5fb2dc" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;fdiv&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;fdiv&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="80afbcd1063d4d2d44dbf986de74a4de9929582e" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;fdivp&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;fdivp&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="f26bbbd4b2589aefcca64acee991404b7c0b0ef2" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;fdivr&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;fdivr&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="27abc8ec360b84a1d9367a1f7ba7ee6ef6945ead" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;fdivrp&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;fdivrp&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="ec12165dd788fabfadd5db4dff2dd277509f9cb4" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;feni&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;feni&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="9f6b7ac93301006ed079309add1f24467004ccf6" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;ffree&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;ffree&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="3e72458117bbe2c3b9ee4bee1c71c63ce34ce702" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;fiadd&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;fiadd&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="92603e707d992825da8bfe8d97f800084bf73f77" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;ficom&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;ficom&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="e351165fae08d8cb1630ef63f0e3aa79d72f0acd" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;ficomp&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;ficomp&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="9530aa35cfdd1951c5239b0d8f37c524d47ae5b1" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;fidiv&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;fidiv&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="a09143b334c24103163bd13ef22aaa5ed84d7937" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;fidivr&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;fidivr&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="6066b28ced7c2c9ffe41737f08b755fee8c96eed" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;fild&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;fild&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="c3d28cb1eff4d97491263cbc3ee67f81a29bd978" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;fimul&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;fimul&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="f44ea8121c3aa8b53ee0259264bfe93c08c90d93" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;fincstp&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;fincstp&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="68c83d3bde1ec17d87167aff95de4af61a0e04c4" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;finit&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;finit&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="576094f961b66284a1b26cc6701cfd315ae4267f" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;fist&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;fist&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="ec92f1294f1e5869a5d6b797160875b09122a8ee" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;fistp&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;fistp&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="472c15aaab864a990d0f2d7383de908594e96a82" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;fisttp&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;fisttp&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="ce220bfa1001aee727eca0c7a990da0b739e1cd1" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;fisub&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;fisub&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="b4fe6a5088328bd66b46a5a3e12559b987d09481" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;fisubr&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;fisubr&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="c514e32e5192413c1a440acb5ac7a27cb0943804" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;fld1&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;fld1&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="67eb1c250feea2b0518f659ecaef98d2b151b8fa" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;fld&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;fld&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="4d610ec17fa42a8d83dde0e05982d71d28403ae8" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;fldcw&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;fldcw&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="b89d66b88f015b633678fb03f278b700b88769bf" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;fldenv&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;fldenv&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="bde7d099ccb0a4d7201c802f4fff25e4f181ace6" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;fldl2e&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;fldl2e&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="4a348450fd48d9a73cac5abcc7014f079ee7b811" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;fldl2t&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;fldl2t&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="81d85908bbf6bcd4f6cd9702fa3f0a0b34c0ab0a" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;fldlg2&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;fldlg2&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="64c5150d4745c083cb16f42001023b178818db6b" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;fldln2&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;fldln2&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="2d910bca5c4a5d5a4504f508f00036de3e13f574" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;fldpi&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;fldpi&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="e444efb4c135c238da06dae03ca9f3af57e21e73" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;fldz&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;fldz&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="d1bba05f92dc17efe9d2e940bebecf73ba5926f7" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;fmul&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;fmul&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="9cd5e540b232ca2010803382fa74fa19c256f03c" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;fmulp&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;fmulp&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="90d6d5baee2388054162cdd30ebd626602967dbd" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;fnclex&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;fnclex&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="01700ce2e4c58c6176b09ac024cd38cff98916e7" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;fndisi&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;fndisi&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="53b49e3c31324c2d22284744506e29887f8d0837" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;fneni&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;fneni&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="3356f8dd4b08eddfa80b91fd0c7f1f063ed37354" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;fninit&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;fninit&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="4174d07a9a7a8adb3e9a59b7658dd1d19b698a9b" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;fnop&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;fnop&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="ff9dacc7e0eefb8614aedd85c1e08b4da47523a0" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;fnsave&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;fnsave&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="df73274afb62337e465bbb43b80df984eeca3b1f" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;fnstcw&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;fnstcw&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="cc7138deb7befbde0f49fbb2598860ba8fa9cb6d" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;fnstenv&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;fnstenv&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="eb9e5ccae7908256580150a87796462458a5f5dd" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;fnstsw&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;fnstsw&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="0726dd18fa2eded64d13ec237ced32b0ccfdff63" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;fpatan&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;fpatan&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="7fd238bdf767aa0cdde1981303d12a31b77b69ec" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;fprem1&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;fprem1&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="34f6d303818f2891b67670e9676be89b8e2ed92f" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;fprem&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;fprem&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="4fc5e4a83e4d6ff73cc4fa7dc0dc61299be67237" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;fptan&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;fptan&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="aae639c4f808bc44916ce8a97c646415d3873018" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;frndint&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;frndint&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="e753f0b44f4c446a9c470c4097a50422e12ed2fb" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;frstor&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;frstor&lt;/em&gt;</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
