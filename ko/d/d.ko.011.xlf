<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="d">
    <body>
      <group id="d">
        <trans-unit id="6eb83bdeacbc683c48cd46fa8c78709c87f5c6e7" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;int8&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;int8&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="0bc5c42eb664068361d3e2bbc2960242bd85d74b" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;keyword&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;keyword&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="3b9e4bd665940376fedb5c229b6879e66e25b129" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;kind&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;kind&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="39874f9381dfd5125b3dc75af7a4807bddc23602" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;lexical analysis&lt;/b&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="60cb138dd66d9b1cea2cf1f5b4bd36ee7ac47180" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;libweb/client.d:&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;libweb/client.d:&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="75eebb7236eb3aa32c6dc795bfed2a8d86d951e3" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;libweb/package.d:&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;libweb/package.d:&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="56e429a57597934579d15405784f8b67f7cc03cd" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;libweb/server.d:&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;libweb/server.d:&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="17043ff939f0a4d5aa83327a00043cf0e170b24f" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;libweb/utils/package.d:&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;libweb/utils/package.d:&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="94101c8a81ea933dc5fe9c5f4fa029879581936c" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;locality&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;locality&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="79de8a252f3b8296225e83ed7108cd637d70a477" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;long2&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;long2&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="30347d665ca86f231e2df3cb086f8b88462effde" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;long4&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;long4&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="ddfb91165ad865d8237032c7afaf6d8ce0c7ac1c" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;n&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;n&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="1fee7dc0a20b6d874a56c2d0b86c4cc5d8b57ae4" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;num indices&lt;/b&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6496c7e7c4bec23654f7a5bb3df81748f05b7ca7" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;offset&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;offset&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="06bfb906e8762b446a59a8cbf8b2275f7051d05f" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;optimization&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;optimization&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="25b59a877580563a729d892f5a673eb16a77e781" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;property&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;property&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="6f5464b43bbaecac5c913e0786a739f28573a242" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;recOEM&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;recOEM&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="5cd2dc7ff7a80db85f72138e3cda8c958131fc1e" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;result&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;result&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="f34d5555301381a812b8cf40c1629a72d2b5a99b" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;rewrite 1&lt;/b&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1b8d7df792dfa36a9ba8a406912753452f1b8759" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;rewrite 2&lt;/b&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d01b17e5b387a974fb541eb4d6aee320bd90be5e" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;script line&lt;/b&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1ec805147dbc1a6c96d4c4890d2a1d36e134d0c9" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;semantic analysis&lt;/b&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="39185722ec687d6398c10760183f1a8a7c946c16" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;short16&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;short16&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="331218862d2c0cc4114357876e1c6aab4e7c97d2" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;short8&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;short8&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="19c7aa78c143d0cda3e321b08d3b851686f7c884" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;size&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;size&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="40c918b147d545d46767b6b640e40fe9e57ecb0e" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;source character set&lt;/b&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6df6bbab98fdd51b7b4d00b71d342406d5e8fe68" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;syntax analysis&lt;/b&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f3c6733f39cdd7a9e8621428971a6e56e7acffa4" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;test.d:&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;test.d:&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="0d24e82b92b971a8bcc7f67b709d52e3453e1098" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;to&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;to&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="5baa61f483637ac5899c306b1f2cd344e3fb2e1d" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;transformation&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;transformation&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="ff1a31b0c2563249b2d8482a3b794f210b6e124d" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;type index&lt;/b&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2ca9cdb144a3b03da7c2246df004461cf1a14926" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;ubyte16&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;ubyte16&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="42f7de6b8374369101f797a088885fff3c76c783" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;ubyte32&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;ubyte32&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="4f467489c4d041333165be8da10f1be6549a5f16" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;uint4&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;uint4&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="08863c66b1da554575c1c3284f58524b547459f8" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;uint8&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;uint8&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="a3606b1022fbd8c072a4e873fe9277c82347261d" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;ulong2&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;ulong2&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="1b18d2fb08ab825308c7b45488ab9efe0e32c3bc" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;ulong4&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;ulong4&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="e9b9b6937b917876163161b430b6959ac30267f3" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;ushort16&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;ushort16&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="c99bf9bca7e059672660f7e98cd1be42241f0514" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;ushort8&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;ushort8&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="61bacdf1f48f1d936407dc6074b0e45fc43810b2" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;void16&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;void16&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="a5422ec2a1c10c4479e71743298351157043d09a" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;void32&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;void32&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="c20077a29e599915f41b1e175f47e4fdb5d50ed4" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;writeFetch&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;writeFetch&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="08fbf87e0e966c600cff0671bfc78bc01d9cb068" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;&quot;cppRuntimeLibrary&quot;&lt;/code&gt; - The C++ runtime library affinity for this toolchain</source>
          <target state="translated">&lt;code&gt;&quot;cppRuntimeLibrary&quot;&lt;/code&gt; - The C++ runtime library affinity for this toolchain</target>
        </trans-unit>
        <trans-unit id="bd853af5509f93ff9e6a43dadc4835581d3279f6" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;&quot;floatAbi&quot;&lt;/code&gt; - Floating point ABI; may be &lt;code&gt;&quot;hard&quot;&lt;/code&gt;, &lt;code&gt;&quot;soft&quot;&lt;/code&gt;, or &lt;code&gt;&quot;softfp&quot;&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;&quot;floatAbi&quot;&lt;/code&gt; - Floating point ABI; may be &lt;code&gt;&quot;hard&quot;&lt;/code&gt;, &lt;code&gt;&quot;soft&quot;&lt;/code&gt;, or &lt;code&gt;&quot;softfp&quot;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="74851dd38fd93446fd7732603f0d38c8e0f7a0d9" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;&quot;nsecs&quot;&lt;/code&gt; is accepted by split, but &lt;code&gt;&quot;years&quot;&lt;/code&gt; and &lt;code&gt;&quot;months&quot;&lt;/code&gt; are not.</source>
          <target state="translated">&lt;code&gt;&quot;nsecs&quot;&lt;/code&gt; is accepted by split, but &lt;code&gt;&quot;years&quot;&lt;/code&gt; and &lt;code&gt;&quot;months&quot;&lt;/code&gt; are not.</target>
        </trans-unit>
        <trans-unit id="b8516c0d0a6ab337eb757368f9822bd55aaca147" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;&quot;nsecs&quot;&lt;/code&gt; is not considered a valid unit of time. Nothing in std.datetime can handle precision greater than hnsecs, and the few functions in core.time which deal with &quot;nsecs&quot; deal with it explicitly.</source>
          <target state="translated">&lt;code&gt;&quot;nsecs&quot;&lt;/code&gt; is not considered a valid unit of time. Nothing in std.datetime can handle precision greater than hnsecs, and the few functions in core.time which deal with &quot;nsecs&quot; deal with it explicitly.</target>
        </trans-unit>
        <trans-unit id="ae2740b26a8bc9a21a01bfad11940cfcc6533f5e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;&quot;objectFormat&quot;&lt;/code&gt; - Target object format</source>
          <target state="translated">&lt;code&gt;&quot;objectFormat&quot;&lt;/code&gt; - Target object format</target>
        </trans-unit>
        <trans-unit id="d1389937ce4aec811485a500d92bce3e9367a1e8" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;%&lt;/code&gt;&lt;code&gt;=&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;%&lt;/code&gt;&lt;code&gt;=&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="0e53a5b7ba9737cc3fe4ccfb3c80c0384c9c3177" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;&amp;amp;&lt;/code&gt;&lt;code&gt;=&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;&amp;amp;&lt;/code&gt;&lt;code&gt;=&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="3958503a584f5923c53a365e8416542c23f78839" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;&amp;amp;&lt;/code&gt;=</source>
          <target state="translated">&lt;code&gt;&amp;amp;&lt;/code&gt;=</target>
        </trans-unit>
        <trans-unit id="f398556003232e6b8c82be05607d67585d76b9cb" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;&amp;gt;&lt;/code&gt;&lt;code&gt;&amp;gt;&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;&amp;gt;&lt;/code&gt;&lt;code&gt;&amp;gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="54f8ced1abd619e968232335d212d3b4a5b3885a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;&amp;gt;&lt;/code&gt;&lt;code&gt;&amp;gt;&lt;/code&gt;&lt;code&gt;&amp;gt;&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;&amp;gt;&lt;/code&gt;&lt;code&gt;&amp;gt;&lt;/code&gt;&lt;code&gt;&amp;gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="b8ef2fda6bef4225fce98f2f1a768cb76822621a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;&amp;gt;&lt;/code&gt;&lt;code&gt;&amp;gt;&lt;/code&gt;&lt;code&gt;&amp;gt;&lt;/code&gt;&lt;code&gt;=&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;&amp;gt;&lt;/code&gt;&lt;code&gt;&amp;gt;&lt;/code&gt;&lt;code&gt;&amp;gt;&lt;/code&gt;&lt;code&gt;=&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="1407373b43004cda1d8c1d2aaf08f988c49587e3" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;&amp;gt;&lt;/code&gt;&lt;code&gt;&amp;gt;&lt;/code&gt;&lt;code&gt;=&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;&amp;gt;&lt;/code&gt;&lt;code&gt;&amp;gt;&lt;/code&gt;&lt;code&gt;=&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="dec18c41670087a443f485e56ddb67fcf7bb9225" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;&amp;lt; 0&lt;/code&gt; if &lt;code&gt;a &amp;lt; b&lt;/code&gt;, &lt;code&gt;0&lt;/code&gt; if &lt;code&gt;a == b&lt;/code&gt;, and &lt;code&gt;&amp;gt; 0&lt;/code&gt; if &lt;code&gt;a &amp;gt; b&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&amp;lt; 0&lt;/code&gt; if &lt;code&gt;a &amp;lt; b&lt;/code&gt;, &lt;code&gt;0&lt;/code&gt; if &lt;code&gt;a == b&lt;/code&gt;, and &lt;code&gt;&amp;gt; 0&lt;/code&gt; if &lt;code&gt;a &amp;gt; b&lt;/code&gt;.</target>
        </trans-unit>
        <trans-unit id="d960d71c8ad6cb23cf55077cd4184f48019c5533" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;&amp;lt; 0&lt;/code&gt; if &lt;code&gt;filename1 &amp;lt; filename2&lt;/code&gt;, &lt;code&gt;0&lt;/code&gt; if &lt;code&gt;filename1 == filename2&lt;/code&gt; and &lt;code&gt;&amp;gt; 0&lt;/code&gt; if &lt;code&gt;filename1 &amp;gt; filename2&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&amp;lt; 0&lt;/code&gt; if &lt;code&gt;filename1 &amp;lt; filename2&lt;/code&gt;, &lt;code&gt;0&lt;/code&gt; if &lt;code&gt;filename1 == filename2&lt;/code&gt; and &lt;code&gt;&amp;gt; 0&lt;/code&gt; if &lt;code&gt;filename1 &amp;gt; filename2&lt;/code&gt;.</target>
        </trans-unit>
        <trans-unit id="6087007a54c59e3a946fc72a09e238e44c46e800" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;&amp;lt;&lt;/code&gt;&lt;code&gt;&amp;lt;&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;&amp;lt;&lt;/code&gt;&lt;code&gt;&amp;lt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="8cf4f97182bd11f758e1c3d6be7426bf8fdfa094" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;&amp;lt;&lt;/code&gt;&lt;code&gt;&amp;lt;&lt;/code&gt; is a left shift. &lt;code&gt;&amp;gt;&lt;/code&gt;&lt;code&gt;&amp;gt;&lt;/code&gt; is a signed right shift. &lt;code&gt;&amp;gt;&lt;/code&gt;&lt;code&gt;&amp;gt;&lt;/code&gt;&lt;code&gt;&amp;gt;&lt;/code&gt; is an unsigned right shift.</source>
          <target state="translated">&lt;code&gt;&amp;lt;&lt;/code&gt;&lt;code&gt;&amp;lt;&lt;/code&gt; is a left shift. &lt;code&gt;&amp;gt;&lt;/code&gt;&lt;code&gt;&amp;gt;&lt;/code&gt; is a signed right shift. &lt;code&gt;&amp;gt;&lt;/code&gt;&lt;code&gt;&amp;gt;&lt;/code&gt;&lt;code&gt;&amp;gt;&lt;/code&gt; is an unsigned right shift.</target>
        </trans-unit>
        <trans-unit id="e7249a5c1a593b3ce165dd68eae0bb3425e21a3f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;&amp;lt;&lt;/code&gt;&lt;code&gt;&amp;lt;&lt;/code&gt;&lt;code&gt;=&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;&amp;lt;&lt;/code&gt;&lt;code&gt;&amp;lt;&lt;/code&gt;&lt;code&gt;=&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="3288fa6008c0378c34f18d5113fe9c3e8c6c76d1" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;&amp;lt;&lt;/code&gt;&lt;code&gt;=&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;&amp;lt;&lt;/code&gt;&lt;code&gt;=&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="122586fc5fa324741645aeef49e2bf8b3aaf2594" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;'\uFFFE'&lt;/code&gt; and &lt;code&gt;'\uFFFF'&lt;/code&gt; are considered valid by &lt;code&gt;isValidDchar&lt;/code&gt;, as they are permitted for internal use by an application, but they are not allowed for interchange by the Unicode standard.</source>
          <target state="translated">&lt;code&gt;'\uFFFE'&lt;/code&gt; and &lt;code&gt;'\uFFFF'&lt;/code&gt; are considered valid by &lt;code&gt;isValidDchar&lt;/code&gt;, as they are permitted for internal use by an application, but they are not allowed for interchange by the Unicode standard.</target>
        </trans-unit>
        <trans-unit id="f60e033c2072c35ccd5e717641020108f1c2041b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;(&lt;/code&gt;&lt;a href=&quot;lex#Identifier&quot;&gt;&lt;i&gt;Identifier&lt;/i&gt;&lt;/a&gt;&lt;code&gt;)&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;(&lt;/code&gt;&lt;a href=&quot;lex#Identifier&quot;&gt;&lt;i&gt;Identifier&lt;/i&gt;&lt;/a&gt;&lt;code&gt;)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="2a08cf564c650ee367e12a53c5693ab287b4205f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;(new A()).castSwitch((A a)=&amp;gt;1,(B b)=&amp;gt;2)&lt;/code&gt; returns &lt;code&gt;1&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;(new A()).castSwitch((A a)=&amp;gt;1,(B b)=&amp;gt;2)&lt;/code&gt; returns &lt;code&gt;1&lt;/code&gt;.</target>
        </trans-unit>
        <trans-unit id="5084a193ecf41e338c076c0c17db9011e1830d3f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;))&lt;/code&gt; fails to compile, the legacy rewrite &lt;code&gt;opSliceAssign(c,&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;))&lt;/code&gt; fails to compile, the legacy rewrite &lt;code&gt;opSliceAssign(c,&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="0837c7282cf26b93c696de19c537766158e0843c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;))&lt;/code&gt;, and &lt;code&gt;a[] = c&lt;/code&gt; as &lt;code&gt;a.opIndexAssign(c)&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;))&lt;/code&gt;, and &lt;code&gt;a[] = c&lt;/code&gt; as &lt;code&gt;a.opIndexAssign(c)&lt;/code&gt;.</target>
        </trans-unit>
        <trans-unit id="11e6e41966a2741f6eda239699f5a89fe68d2b17" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;)&lt;/code&gt; condition is satisfied when the debug identifier matches</source>
          <target state="translated">&lt;code&gt;)&lt;/code&gt; condition is satisfied when the debug identifier matches</target>
        </trans-unit>
        <trans-unit id="8fa45ebcfa13cbab71d496a27f9fbb9f9afcba8a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;)&lt;/code&gt; condition is satisfied when the debug level is &lt;code&gt;&amp;gt;=&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;)&lt;/code&gt; condition is satisfied when the debug level is &lt;code&gt;&amp;gt;=&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="aa4b0d2797ed2e918bd432feb2fcec6c9f3fb73f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;)&lt;/code&gt; creates C++ declarations that reside in C++ namespaces. The</source>
          <target state="translated">&lt;code&gt;)&lt;/code&gt; creates C++ declarations that reside in C++ namespaces. The</target>
        </trans-unit>
        <trans-unit id="9925093c94a8b2d6b68305707b4c9b14bbfe8a78" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;)&lt;/code&gt; is used instead.</source>
          <target state="translated">&lt;code&gt;)&lt;/code&gt; is used instead.</target>
        </trans-unit>
        <trans-unit id="f1b41032db3326fa1cb5496cde41eaf9cdb01448" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;)&lt;/code&gt; when applied to an lvalue.</source>
          <target state="translated">&lt;code&gt;)&lt;/code&gt; when applied to an lvalue.</target>
        </trans-unit>
        <trans-unit id="b1de402a83a45114ff0faf7e6d0aeedf6bbc5326" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;)&lt;/code&gt; with two arguments, respectively. This only applies for one-dimensional slicing, and dates from when D did not have full support for multidimensional arrays. This usage of &lt;code&gt;opSlice&lt;/code&gt; is discouraged.</source>
          <target state="translated">&lt;code&gt;)&lt;/code&gt; with two arguments, respectively. This only applies for one-dimensional slicing, and dates from when D did not have full support for multidimensional arrays. This usage of &lt;code&gt;opSlice&lt;/code&gt; is discouraged.</target>
        </trans-unit>
        <trans-unit id="206712b8f8db89befea06a21ffb6c96d5634437b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;**double asterisks**&lt;/code&gt; is rendered as &lt;strong&gt;double asterisks&lt;/strong&gt;.</source>
          <target state="translated">&lt;code&gt;**double asterisks**&lt;/code&gt; is rendered as &lt;strong&gt;double asterisks&lt;/strong&gt;.</target>
        </trans-unit>
        <trans-unit id="6185639dc48e1b078578c025762b660d95e30ad2" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;*single asterisks*&lt;/code&gt; is rendered as &lt;em&gt;single asterisks&lt;/em&gt;.</source>
          <target state="translated">&lt;code&gt;*single asterisks*&lt;/code&gt; is rendered as &lt;em&gt;single asterisks&lt;/em&gt;.</target>
        </trans-unit>
        <trans-unit id="a889907639d280d7bcce02cbbea7d7fae19a44f9" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;++&lt;/code&gt; and Postdecrement</source>
          <target state="translated">&lt;code&gt;++&lt;/code&gt; and Postdecrement</target>
        </trans-unit>
        <trans-unit id="e4b39a750f8d4f75d6b1d22cfdf811ebaf9481db" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;+1&lt;/code&gt; is the same as the value of the previous</source>
          <target state="translated">&lt;code&gt;+1&lt;/code&gt; is the same as the value of the previous</target>
        </trans-unit>
        <trans-unit id="94aeafa98cf3b84e505daf5f3afc0bc7809c2780" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;+1&lt;/code&gt;. If the value of the previous</source>
          <target state="translated">&lt;code&gt;+1&lt;/code&gt;. If the value of the previous</target>
        </trans-unit>
        <trans-unit id="e5d93e3086b69015c0f32e6de990de14dd909214" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;,&lt;/code&gt; ...&lt;code&gt;]&lt;/code&gt;, two steps are needed. First, the expressions of the form</source>
          <target state="translated">&lt;code&gt;,&lt;/code&gt; ...&lt;code&gt;]&lt;/code&gt;, two steps are needed. First, the expressions of the form</target>
        </trans-unit>
        <trans-unit id="ce47578d0683bbc3a7759581717d39518e3bd074" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;,&lt;/code&gt;&amp;hellip;&lt;code&gt;}&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;,&lt;/code&gt;&amp;hellip;&lt;code&gt;}&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="99588c23695c0ee55194ee8a309e79b3bf5cee4e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;,&lt;/code&gt;&lt;a href=&quot;template#TemplateParameterList&quot;&gt;&lt;i&gt;TemplateParameterList&lt;/i&gt;&lt;/a&gt;&lt;code&gt;)&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;,&lt;/code&gt;&lt;a href=&quot;template#TemplateParameterList&quot;&gt;&lt;i&gt;TemplateParameterList&lt;/i&gt;&lt;/a&gt;&lt;code&gt;)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="099853a8e9fedf93d291e0d176049a446c7c73d5" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;,&lt;/code&gt;&lt;a href=&quot;template#TemplateParameterList&quot;&gt;&lt;i&gt;TemplateParameterList&lt;/i&gt;&lt;/a&gt;&lt;code&gt;)&lt;/code&gt;  More complex types can be pattern matched; the &lt;a href=&quot;template#TemplateParameterList&quot;&gt;&lt;i&gt;TemplateParameterList&lt;/i&gt;&lt;/a&gt; declares symbols based on the parts of the pattern that are matched, analogously to the way implied template parameters are matched.</source>
          <target state="translated">&lt;code&gt;,&lt;/code&gt;&lt;a href=&quot;template#TemplateParameterList&quot;&gt;&lt;i&gt;TemplateParameterList&lt;/i&gt;&lt;/a&gt;&lt;code&gt;)&lt;/code&gt;  More complex types can be pattern matched; the &lt;a href=&quot;template#TemplateParameterList&quot;&gt;&lt;i&gt;TemplateParameterList&lt;/i&gt;&lt;/a&gt; declares symbols based on the parts of the pattern that are matched, analogously to the way implied template parameters are matched.</target>
        </trans-unit>
        <trans-unit id="7d285d5f941ddf4b338ad50a32ea2c0191fae56b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;--&lt;/code&gt; Operators</source>
          <target state="translated">&lt;code&gt;--&lt;/code&gt; Operators</target>
        </trans-unit>
        <trans-unit id="7bd2725afa85bcfddda64b0eb7c49fdbfb09a6b4" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;.alignof&lt;/code&gt; gives the aligned size of an expression or type. For example, an aligned size of 1 means that it is aligned on a byte boundary, 4 means it is aligned on a 32 bit boundary.</source>
          <target state="translated">&lt;code&gt;.alignof&lt;/code&gt; gives the aligned size of an expression or type. For example, an aligned size of 1 means that it is aligned on a byte boundary, 4 means it is aligned on a 32 bit boundary.</target>
        </trans-unit>
        <trans-unit id="e5196b62974b3d8f215e2d910f7f52f6922146ea" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;.classinfo&lt;/code&gt; applied to an interface gives the information for the interface, not the class it might be an instance of.</source>
          <target state="translated">&lt;code&gt;.classinfo&lt;/code&gt; applied to an interface gives the information for the interface, not the class it might be an instance of.</target>
        </trans-unit>
        <trans-unit id="63b0f429d2b2e3c16f17ed1cdb76e7cacdca4946" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;.classinfo&lt;/code&gt; provides information about the dynamic type of a class object. It returns a reference to type &lt;a href=&quot;https://dlang.org/phobos/object.html&quot;&gt;&lt;code&gt;object.TypeInfo_Class&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;.classinfo&lt;/code&gt; provides information about the dynamic type of a class object. It returns a reference to type &lt;a href=&quot;https://dlang.org/phobos/object.html&quot;&gt;&lt;code&gt;object.TypeInfo_Class&lt;/code&gt;&lt;/a&gt;.</target>
        </trans-unit>
        <trans-unit id="b456dd1c2f9c0d10f1789cad30a16c60fc51af38" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;.init&lt;/code&gt; produces a constant expression that is the default initializer. If applied to a type, it is the default initializer for that type. If applied to a variable or field, it is the default initializer for that variable or field's type.</source>
          <target state="translated">&lt;code&gt;.init&lt;/code&gt; produces a constant expression that is the default initializer. If applied to a type, it is the default initializer for that type. If applied to a variable or field, it is the default initializer for that variable or field's type.</target>
        </trans-unit>
        <trans-unit id="f56bc5ae2b4045d3d6ac97ffcf098f910b771e8e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;.sizeof&lt;/code&gt; applied to a class object returns the size of the class reference, not the class instantiation.</source>
          <target state="translated">&lt;code&gt;.sizeof&lt;/code&gt; applied to a class object returns the size of the class reference, not the class instantiation.</target>
        </trans-unit>
        <trans-unit id="56191db3ac0b73d97dbb68e4b586da74f6c27ddb" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;.stringof&lt;/code&gt; produces a constant string that is the source representation of its prefix. If applied to a type, it is the string for that type. If applied to an expression, it is the source representation of that expression. The expression will not be evaluated.</source>
          <target state="translated">&lt;code&gt;.stringof&lt;/code&gt; produces a constant string that is the source representation of its prefix. If applied to a type, it is the string for that type. If applied to an expression, it is the source representation of that expression. The expression will not be evaluated.</target>
        </trans-unit>
        <trans-unit id="32a0616dfbfe5a9ba4aea5d2a2f3d043257aeb30" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;0&lt;/code&gt; if &lt;code&gt;lhs&lt;/code&gt; is being shifted left by a negative value, or shifted right by a large positive value</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cd0f13cb35b0f6cfcff43bbaff7453822c3899ae" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;0&lt;/code&gt; if the ranges compare equal. A negative value if &lt;code&gt;r1&lt;/code&gt; is a prefix of &lt;code&gt;r2&lt;/code&gt; or the first differing element of &lt;code&gt;r1&lt;/code&gt; is less than the corresponding element of &lt;code&gt;r2&lt;/code&gt; according to &lt;code&gt;pred&lt;/code&gt;. A positive value if &lt;code&gt;r2&lt;/code&gt; is a prefix of &lt;code&gt;r1&lt;/code&gt; or the first differing element of &lt;code&gt;r2&lt;/code&gt; is less than the corresponding element of &lt;code&gt;r1&lt;/code&gt; according to &lt;code&gt;pred&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f5fa0e4f4c4640464fdf6df63f5ca41e5095594b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;2.predSwitch(1, &quot;one&quot;, 2, &quot;two&quot;, 3, &quot;three&quot;)&lt;/code&gt; returns &lt;code&gt;&quot;two&quot;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="89e0c97d25cdfc5fbaa32647daa1dc8abaab5615" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;==&lt;/code&gt; and &lt;code&gt;!=&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;==&lt;/code&gt; and &lt;code&gt;!=&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="945e03d010c2450da457899882fa6887ba75a11f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;@disable&lt;/code&gt; Attribute</source>
          <target state="translated">&lt;code&gt;@disable&lt;/code&gt; Attribute</target>
        </trans-unit>
        <trans-unit id="668de6cdeed818fd05f519609a55e3f17f5419d9" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;@nogc&lt;/code&gt; Attribute</source>
          <target state="translated">&lt;code&gt;@nogc&lt;/code&gt; Attribute</target>
        </trans-unit>
        <trans-unit id="bbf50b7d4a9c14b6324016a55b2e05c9b2b3304e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;@nogc&lt;/code&gt; affects the type of the function. A &lt;code&gt;@nogc&lt;/code&gt; function is covariant with a non-&lt;code&gt;@nogc&lt;/code&gt; function.</source>
          <target state="translated">&lt;code&gt;@nogc&lt;/code&gt; affects the type of the function. A &lt;code&gt;@nogc&lt;/code&gt; function is covariant with a non-&lt;code&gt;@nogc&lt;/code&gt; function.</target>
        </trans-unit>
        <trans-unit id="35e398484da7da2b70be396e858ccb202fbfc291" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;@property&lt;/code&gt; Attribute</source>
          <target state="translated">&lt;code&gt;@property&lt;/code&gt; Attribute</target>
        </trans-unit>
        <trans-unit id="e9dda840d85606d23c926d0fc958fba3c05a42b4" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;@property&lt;/code&gt; are mangled differently, meaning that &lt;code&gt;@property&lt;/code&gt; must be consistently used across different compilation units.</source>
          <target state="translated">&lt;code&gt;@property&lt;/code&gt; are mangled differently, meaning that &lt;code&gt;@property&lt;/code&gt; must be consistently used across different compilation units.</target>
        </trans-unit>
        <trans-unit id="65432aebdccf8c92f41a4bc846f3193e0c1a00f7" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;@property&lt;/code&gt; functions can only have zero, one or two parameters.</source>
          <target state="translated">&lt;code&gt;@property&lt;/code&gt; functions can only have zero, one or two parameters.</target>
        </trans-unit>
        <trans-unit id="59321333ece34441ee987512696709e6c8398415" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;@property&lt;/code&gt; functions cannot be overloaded with non-&lt;code&gt;@property&lt;/code&gt; functions with the same name.</source>
          <target state="translated">&lt;code&gt;@property&lt;/code&gt; functions cannot be overloaded with non-&lt;code&gt;@property&lt;/code&gt; functions with the same name.</target>
        </trans-unit>
        <trans-unit id="1899b0354c680094e6ce0955a619b11401875aac" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;@property&lt;/code&gt; functions cannot have variadic parameters.</source>
          <target state="translated">&lt;code&gt;@property&lt;/code&gt; functions cannot have variadic parameters.</target>
        </trans-unit>
        <trans-unit id="76380ecaf01afb85f0044254a7d4b66358545c56" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;@safe&lt;/code&gt; functions have a number of restrictions on what they may do and are intended to disallow operations that may cause memory corruption. See &lt;a href=&quot;function#safe-functions&quot;&gt;&lt;code&gt;@safe&lt;/code&gt; functions&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;@safe&lt;/code&gt; functions have a number of restrictions on what they may do and are intended to disallow operations that may cause memory corruption. See &lt;a href=&quot;function#safe-functions&quot;&gt;&lt;code&gt;@safe&lt;/code&gt; functions&lt;/a&gt;.</target>
        </trans-unit>
        <trans-unit id="9256c91d32406bfdf38800a20bf913361e88031e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;@safe&lt;/code&gt;, &lt;code&gt;@trusted&lt;/code&gt;, and &lt;code&gt;@system&lt;/code&gt; Attribute</source>
          <target state="translated">&lt;code&gt;@safe&lt;/code&gt;, &lt;code&gt;@trusted&lt;/code&gt;, and &lt;code&gt;@system&lt;/code&gt; Attribute</target>
        </trans-unit>
        <trans-unit id="63252c0535bac17f08c817b75c5f13428fdb17d2" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;@system&lt;/code&gt; functions may perform any operation legal from the perspective of the language including inherently memory unsafe operations like returning pointers to expired stackframes. These functions may not be called directly from &lt;code&gt;@safe&lt;/code&gt; functions.</source>
          <target state="translated">&lt;code&gt;@system&lt;/code&gt; functions may perform any operation legal from the perspective of the language including inherently memory unsafe operations like returning pointers to expired stackframes. These functions may not be called directly from &lt;code&gt;@safe&lt;/code&gt; functions.</target>
        </trans-unit>
        <trans-unit id="1e802eb587afd93d2f6c4d83fb8f23730a64dd76" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;@trusted&lt;/code&gt; functions have all the capabilities of &lt;code&gt;@system&lt;/code&gt; functions but may be called from &lt;code&gt;@safe&lt;/code&gt; functions. For this reason they should be very limited in the scope of their use. Typical uses of &lt;code&gt;@trusted&lt;/code&gt; functions include wrapping system calls that take buffer pointer and length arguments separately so that @safe` functions may call them with arrays.</source>
          <target state="translated">&lt;code&gt;@trusted&lt;/code&gt; functions have all the capabilities of &lt;code&gt;@system&lt;/code&gt; functions but may be called from &lt;code&gt;@safe&lt;/code&gt; functions. For this reason they should be very limited in the scope of their use. Typical uses of &lt;code&gt;@trusted&lt;/code&gt; functions include wrapping system calls that take buffer pointer and length arguments separately so that @safe` functions may call them with arrays.</target>
        </trans-unit>
        <trans-unit id="7b7b2ec22a078014319be45b79df08258bb74f13" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;A.foo()&lt;/code&gt; and &lt;code&gt;A.foo(long)&lt;/code&gt; form an overload set. A different module can also define functions with the same name:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0494fa5e8697863931a268f56a7e313b15fa7bc6" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Address&lt;/code&gt; is an abstract class for representing a socket addresses.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="63f8e6c905b185a2e61cdd95f261d361df08a36c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;AddressException&lt;/code&gt; on error, or &lt;code&gt;SocketFeatureException&lt;/code&gt; if host name lookup for this address family is not available on the current system.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2f961238680f01eeda9c0208d72d9a727592f0e5" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;AddressException&lt;/code&gt; on error.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5ebe362c761732ab62a4361ba380d53bd21d7194" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;AddressException&lt;/code&gt; on failure, or &lt;code&gt;SocketFeatureException&lt;/code&gt; if address retrieval for this address family is not available on the current system.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f40e1758855b4027e53355680b270fb2100d0ae4" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;AddressException&lt;/code&gt; on failure, or &lt;code&gt;SocketFeatureException&lt;/code&gt; if port number retrieval for this address family is not available on the current system.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a0f47e28a240c095ac0652696954b5953fcbc0a3" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;AddressException&lt;/code&gt; on failure, or &lt;code&gt;SocketFeatureException&lt;/code&gt; if service name lookup for this address family is not available on the current system.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b5828f821b8aea42c299b3e9109f069f9c37a828" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;AddressFamily&lt;/code&gt; - address family to filter by</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="64ad3aa38a4e1cf80b2339b1f85a40825b728d1b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;AddressInfoFlags&lt;/code&gt; - option flags</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7dc4a85ea5727659d699df6d8c458e28309faed3" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;AlignedBlockList&lt;/code&gt; represents a wrapper around a chain of allocators, allowing for fast deallocations and preserving a low degree of fragmentation by means of aligned allocations.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2aac4ff89a1251fffc9ea676fd3d3a75e327c061" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;AlignedBlockList&lt;/code&gt; represents a wrapper around a chain of allocators, allowing for fast deallocations and preserving a low degree of fragmentation. The allocator holds internally a doubly linked list of &lt;code&gt;Allocator&lt;/code&gt; objects, which will serve allocations in a most-recently-used fashion. Most recent allocators used for &lt;code&gt;allocate&lt;/code&gt; calls, will be moved to the front of the list.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="13e555da2052e32dcab37e698e860002bf9cfb74" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;AllocFlag&lt;/code&gt; combination</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2d0e2d98007fbd8a78591eed210eee8ac8b3c6a7" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;AllocatorList&lt;/code&gt; is primarily intended for coarse-grained handling of allocators, i.e. the number of allocators in the list is expected to be relatively small compared to the number of allocations handled by each allocator. However, the per-allocator overhead is small so using &lt;code&gt;AllocatorList&lt;/code&gt; with a large number of allocators should be satisfactory as long as the most-recently-used strategy is fast enough for the application.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2a9263569f31d6f21ef7c6064d7d886d4088e71e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;AllocatorList&lt;/code&gt; makes an effort to return allocated memory back when no longer used. It does so by destroying empty allocators. However, in order to avoid thrashing (excessive creation/destruction of allocators under certain use patterns), it keeps unused allocators for a while.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5d071eb9976a79b4a2500d3fbf6dab04761c67f6" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Args&lt;/code&gt; must not have unshared aliasing.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3d6c9e4352fe5c3f5c6acaa10eb2b6833c10d2c0" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Array!bool&lt;/code&gt; packs together values efficiently by allocating one bit per element</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="705c9b8cd80c0abcd241a8704a8e03e6c9084b57" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;AscendingPageAllocator&lt;/code&gt; is a fast and safe allocator that rounds all allocations to multiples of the system's page size. It reserves a range of virtual addresses (using &lt;code&gt;mmap&lt;/code&gt; on Posix and &lt;code&gt;VirtualAlloc&lt;/code&gt; on Windows) and allocates memory at consecutive virtual addresses.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="04218a7012508fe4191b10a87336cc6b1273cc13" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;AssertError&lt;/code&gt; if the given &lt;code&gt;Throwable&lt;/code&gt; is not thrown.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="79a5a3ac59900685640330cfc081e2b319714288" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;AssertError&lt;/code&gt; if the given &lt;code&gt;Throwable&lt;/code&gt; is thrown.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="48065955e3cbf0f918e5b84c93a8195ee5d56267" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;AssignExp&lt;/code&gt; or &lt;code&gt;CatAssignExp&lt;/code&gt; to check for any pointers to the stack</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b546397158fafebfd9a66a9cae2f9c303cb63883" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;AutoImplement&lt;/code&gt; automatically implements (by default) all abstract member functions in the class or interface &lt;code&gt;Base&lt;/code&gt; in specified way.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="21bb1733c4ce14ff9de978726113c04a3401771e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Base64Exception&lt;/code&gt; If invoked when &lt;a href=&quot;#Base64Impl.Encoder.empty&quot;&gt;`empty`&lt;/a&gt; returns &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ebced38d3d013a303994fc7294831ec443f6b2c5" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Base64Exception&lt;/code&gt; If invoked when &lt;a href=&quot;#Base64Impl.Encoder.empty.2&quot;&gt;` empty`&lt;/a&gt; returns &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="500444657b554197a2e7e1e88e444620d4ec0295" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Base64Exception&lt;/code&gt; if invoked when &lt;a href=&quot;#Base64Impl.Decoder.empty&quot;&gt;` empty`&lt;/a&gt; returns &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7cb7869f728c8d6d25945c2b87f5bcbca9b27844" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Base64Exception&lt;/code&gt; if source contains characters outside the base alphabet of the current Base64 encoding scheme.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a386e95823d58783ccfcf9ed4858920237676d35" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;BinaryHeap&lt;/code&gt; implements the standard input range interface, allowing lazy iteration of the underlying range in descending order.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="39e18f0659912331e89425afd9610294f5efef67" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;BitmappedBlock&lt;/code&gt; implements a simple heap consisting of one contiguous area of memory organized in blocks, each of size &lt;code&gt;theBlockSize&lt;/code&gt;. A block is a unit of allocation. A bitmap serves as bookkeeping data, more precisely one bit per block indicating whether that block is currently allocated or not.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="933f016b603e800d31983480a5c372706d49a5e2" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;BlackHole!Base&lt;/code&gt; is a subclass of &lt;code&gt;Base&lt;/code&gt; which automatically implements all abstract member functions in &lt;code&gt;Base&lt;/code&gt; as do-nothing functions. Each auto-implemented function just returns the default value of the return type without doing anything.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="43ce84cda21371df91482f18480d181e60b4d348" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;BoyerMooreFinder&lt;/code&gt; allocates GC memory.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ad37dbabc0225dbe91d779a5c2478ebbe06c13bd" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Bucketizer&lt;/code&gt; holds a fixed-size array of allocators and dispatches calls to them appropriately. The size of the array is &lt;code&gt;(max + 1 - min) / step&lt;/code&gt;, which must be an exact division.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d7e5303aaec3d1918d07f980b6ff3c717de278f0" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Captures&lt;/code&gt; object contains submatches captured during a call to &lt;code&gt;match&lt;/code&gt; or iteration over &lt;code&gt;RegexMatch&lt;/code&gt; range.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="309893639b24ac675f2672438e92cfb6821b443e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;CheckFailure&lt;/code&gt; if the comparison is mathematically erroneous.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ccdb30bb454730e08beb8407ef654f2c4fc02f5e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Checked&lt;/code&gt; has customizable behavior with the help of a second type parameter, &lt;code&gt;Hook&lt;/code&gt;. Depending on what methods &lt;code&gt;Hook&lt;/code&gt; defines, core operations on the underlying integral may be verified for overflow or completely redefined. If &lt;code&gt;Hook&lt;/code&gt; defines no method at all and carries no state, there is no change in behavior, i.e. &lt;code&gt;Checked!(int, void)&lt;/code&gt; is a wrapper around &lt;code&gt;int&lt;/code&gt; that adds no customization at all.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b33f2fe31af4e020ff9efa1c941efd75f784be56" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;ClockType.normal&lt;/code&gt;, &lt;code&gt;ClockType.coarse&lt;/code&gt;, and &lt;code&gt;ClockType.precise&lt;/code&gt; work with both &lt;code&gt;Clock.currTime&lt;/code&gt; and &lt;a href=&quot;#MonoTimeImpl&quot;&gt;&lt;code&gt;MonoTimeImpl&lt;/code&gt;&lt;/a&gt;. &lt;code&gt;ClockType.second&lt;/code&gt; only works with &lt;code&gt;Clock.currTime&lt;/code&gt;. The others only work with &lt;a href=&quot;#MonoTimeImpl&quot;&gt;&lt;code&gt;MonoTimeImpl&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3bd546dd377a5ca9a91504338ed3d12c7a06c162" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Complex&lt;/code&gt; instance with real and imaginary parts set to the values provided as input. If neither &lt;code&gt;re&lt;/code&gt; nor &lt;code&gt;im&lt;/code&gt; are floating-point numbers, the return type will be &lt;code&gt;Complex!double&lt;/code&gt;. Otherwise, the return type is deduced using &lt;code&gt;std.traits.CommonType!(R, I)&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4f1981cf0c5b9aacc8c3e1f9ea526f149b5b37a4" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;ConstRange&lt;/code&gt; is a variant with &lt;code&gt;const&lt;/code&gt; elements. &lt;code&gt;ImmutableRange&lt;/code&gt; is a variant with &lt;code&gt;immutable&lt;/code&gt; elements.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9f0a285a64a257a738ddc8215c5d1f4b1ea5f630" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;ContiguousFreeList&lt;/code&gt; has most advantages of &lt;code&gt;FreeList&lt;/code&gt; but fewer disadvantages. It has better cache locality because items are closer to one another. It imposes less fragmentation on its parent allocator.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5fdcd2f0664be754d421f0e8e94106531175532e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;CurlException&lt;/code&gt; on error.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c207e7eb5b1c2a73f8ac5ffe36b3bcc018bf05ce" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;DList&lt;/code&gt; uses reference semantics.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="56d091bff1aace57a8798a77c763e1d6bc36b169" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Date&lt;/code&gt; uses the Proleptic Gregorian Calendar, so it assumes the Gregorian leap year calculations for its entire length. As per &lt;a href=&quot;http://en.wikipedia.org/wiki/ISO_8601&quot;&gt;ISO 8601&lt;/a&gt;, it treats 1 B.C. as year 0, i.e. 1 B.C. is 0, 2 B.C. is -1, etc. Use &lt;a href=&quot;#yearBC&quot;&gt;&lt;code&gt;yearBC&lt;/code&gt;&lt;/a&gt; to use B.C. as a positive integer with 1 B.C. being the year prior to 1 A.D.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7bfc68ccb2a4e22e418742b095af915878cf89fa" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;ErrnoException&lt;/code&gt; if the file could not be opened.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="493ee8438d3cfa33971d7dccea919872285bce11" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;ErrnoException&lt;/code&gt; if the file is not opened or if the call to &lt;code&gt;fwrite&lt;/code&gt; fails.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="07b5a06c5039124b8ad1df2dc89969b320d534d4" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;ErrnoException&lt;/code&gt; in case of error.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8b930e092cece6fadf6f6900420461e2d20e336e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;ErrnoException&lt;/code&gt; on error.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dd239e85060d6e26ab1980f40e672ff73bfb0858" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;ErrnoException&lt;/code&gt; on failure if closing the file.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="37e046750496d7d91c0e7d494f6853286088255f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Exception&lt;/code&gt; if &lt;code&gt;buffer&lt;/code&gt; is empty. &lt;code&gt;ErrnoException&lt;/code&gt; if the file is not opened or the call to &lt;code&gt;fread&lt;/code&gt; fails.  &lt;code&gt;rawRead&lt;/code&gt; always reads in binary mode on Windows.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5357a482b6af648bdfdae7c4c52ac903a4330a1f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Exception&lt;/code&gt; if &lt;code&gt;r&lt;/code&gt; is empty</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c39a22e167279d617a0fc36daa4eccdae4e0b8a0" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Exception&lt;/code&gt; if &lt;code&gt;r&lt;/code&gt; is not a range extracted from this array.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2d3c1830fcba55441c8b8708ac54ee0a65f17621" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Exception&lt;/code&gt; if &lt;code&gt;r&lt;/code&gt; is not a valid range extracted from this array.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6eea76a1ffc828fd53a324818d486f97cad280bd" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Exception&lt;/code&gt; if &lt;code&gt;range.empty&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9a3c6b353ef2f15072975ede8bc10964dd5ce9b9" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Exception&lt;/code&gt; if newlength is greater than the current array length.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5dfec39555f552ab3cc5ab1e7f2d9d9d48f01214" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Exception&lt;/code&gt; if the InputRange didn't provide enough elements to seed the generator. The number of elements required is the 'n' template parameter of the MersenneTwisterEngine struct.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="865428949f240b5fee7e83d1edb9e3fe9d25cc8c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Exception&lt;/code&gt; if the array is empty.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="24bffc299c874cdf767b7647906bba79e926a8eb" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Exception&lt;/code&gt; if the file is not opened or if the OS call fails.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1425ed7cd12f20780c89a15069d569df2ac8153d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Exception&lt;/code&gt; if the file is not opened or if the call to &lt;code&gt;fflush&lt;/code&gt; fails.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4d278807b320706797dc5f37c056c614e9ab56c0" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Exception&lt;/code&gt; if the file is not opened.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="12ff2eb3e485817238b511a24e61f4e5651047c1" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Exception&lt;/code&gt; if the file is not opened. &lt;code&gt;ErrnoException&lt;/code&gt; if the call to &lt;code&gt;fseek&lt;/code&gt; fails.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="92e2886b83c958de5c8cbfe39732479fc0881ca0" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Exception&lt;/code&gt; if the file is not opened. &lt;code&gt;ErrnoException&lt;/code&gt; if the call to &lt;code&gt;ftell&lt;/code&gt; fails.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9c058e1025053f932c8cbe059de6e6a45a7ade6f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Exception&lt;/code&gt; if the file is not opened. &lt;code&gt;ErrnoException&lt;/code&gt; if the call to &lt;code&gt;setvbuf&lt;/code&gt; fails.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9f59183ade2749bbcd85be7bdd7539cc2dde8f91" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Exception&lt;/code&gt; if the file is not opened. &lt;code&gt;ErrnoException&lt;/code&gt; on an error writing to the file.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="880297ec9e517b1658e861861ad15bb2e8e8065e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Exception&lt;/code&gt; if the format string is malformed. Also, throws &lt;code&gt;Exception&lt;/code&gt; if any of the lines in the file are not fully consumed by the call to &lt;a href=&quot;std_format#formattedRead&quot;&gt;&lt;code&gt;std.format.formattedRead&lt;/code&gt;&lt;/a&gt;. Meaning that no empty lines or lines with extra characters are allowed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="de0a5fbad1ac6efb5fd9baf8351d9afcefe62cb5" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Exception&lt;/code&gt; if the specified base directory is not absolute.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f6df157c4a7711890860c9639006d090861c8052" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Expression&lt;/code&gt; created, &lt;code&gt;null&lt;/code&gt; if cannot, &lt;code&gt;ErrorExp&lt;/code&gt; for other errors</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ebd4302c37b74c7523edd170489c26935f44df7d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;F&lt;/code&gt; must not have any unshared aliasing as defined by &lt;a href=&quot;std_traits#hasUnsharedAliasing&quot;&gt;&lt;code&gt;std.traits.hasUnsharedAliasing&lt;/code&gt;&lt;/a&gt;. This means it may not be an unshared delegate or a non-shared class or struct with overloaded &lt;code&gt;opCall&lt;/code&gt;. This also precludes accepting template alias parameters.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4417b447d6e34a9b6a9d00ab903bf61ae7b12316" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;FILETIME&lt;/code&gt;s are always in UTC.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9ad36e002f703b7a77a7d8759412e0073c140460" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;FTP&lt;/code&gt; struct for advanced usage</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="53f59d90a4d9a81fffddf93c0be659170d389f60" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;FallbackAllocator&lt;/code&gt; is the allocator equivalent of an &quot;or&quot; operator in algebra. An allocation request is first attempted with the &lt;code&gt;Primary&lt;/code&gt; allocator. If that returns &lt;code&gt;null&lt;/code&gt;, the request is forwarded to the &lt;code&gt;Fallback&lt;/code&gt; allocator. All other requests are dispatched appropriately to one of the two allocators.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="30b00ee005e62aee06d690c21d13b91062908c24" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;FallbackAllocator&lt;/code&gt; is useful for fast, special-purpose allocators backed up by general-purpose allocators. The example below features a stack region backed up by the &lt;code&gt;GCAllocator&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="12059211a1f2cd4c2168c76ad92a90e7719491a6" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;FallbackAllocator&lt;/code&gt; offers &lt;code&gt;alignedAllocate&lt;/code&gt; iff at least one of the allocators also offers it. It attempts to allocate using either or both.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d37b29b23fa316d94fdcad5c8166e439cc28f457" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;FileException&lt;/code&gt; if it fails to read from disk.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="188634dda23bd46b447ec8ec1668b156fc7d14b0" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Final&lt;/code&gt; can also be used to create read-only data fields without using transitive immutability:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="889460128c963ae0b50d3b48964b85c59fa375e8" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Final&lt;/code&gt; can be used to create class references which cannot be rebound:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="478f5e1ecc311901ec2b0e13063c90a9401676ec" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;FreeTree&lt;/code&gt; rounds up small allocations to at least &lt;code&gt;4 * size_t.sizeof&lt;/code&gt;, which on 64-bit system is one cache line size. If very small objects need to be efficiently allocated, the &lt;code&gt;FreeTree&lt;/code&gt; should be fronted with an appropriate small object allocator.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d77d6371df752392d6a3dc05802d163d4563983a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;FuncDeclaration&lt;/code&gt; to mangle</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="534218dc2a9eff64b3a6d0dd395079c920a853c3" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;GetLastError&lt;/code&gt;'s return value.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fe0e872c807344ef938e77fe62dbcc2ee42252f1" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Grapheme&lt;/code&gt; has value semantics so 2 copies of a &lt;code&gt;Grapheme&lt;/code&gt; always refer to distinct objects. In most actual scenarios a &lt;code&gt;Grapheme&lt;/code&gt; fits on the stack and avoids memory allocation overhead for all but quite long clusters.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a47bfdb3d233e9007f4d4e19f342cf063fcacfb4" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;HTTP&lt;/code&gt; struct for advanced usage</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="283f10bc662194860ed924948e7ca2b00bc64cd8" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Hook&lt;/code&gt; member</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3528ef07a2db59ecdda7c525258080250b32a27c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Implementation Note:&lt;/code&gt; Compilers should attempt to detect array bounds errors at compile time, for example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e55f857cc1242d132c8a00873c15908f891e0a9c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Implementation Note:&lt;/code&gt; The compiler should have a switch specifying if &lt;code&gt;deprecated&lt;/code&gt; should be ignored, cause a warning, or cause an error during compilation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="561dda1be5a110b61fe901643d2776b6422899b1" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Implementation Note:&lt;/code&gt; The compiler's code generator may assume that the case statements are sorted by frequency of use, with the most frequent appearing first and the least frequent last. Although this is irrelevant as far as program correctness is concerned, it is of performance interest.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="450a1b223ad68d4502564215cf64c6560e8a199b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;InSituRegion&lt;/code&gt; is a convenient region that carries its storage within itself (in the form of a statically-sized array).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="72722ed0146cefed0b01dfb5c3c45d47c9f4bbfe" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Initializer&lt;/code&gt; AST node</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f7a41aecd6b56da1cad754e3be715002c57e3b64" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Initializer&lt;/code&gt; with completed semantic analysis, &lt;code&gt;ErrorInitializer&lt;/code&gt; if errors were encountered</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f00d758a57b29aab9fb23c7584ece328b1a47384" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;InputRange&lt;/code&gt; of &lt;code&gt;ElementType&lt;/code&gt; implicitly convertible to &lt;code&gt;ubyte&lt;/code&gt;, &lt;code&gt;ubyte[]&lt;/code&gt; or &lt;code&gt;ubyte[num]&lt;/code&gt; or one or more arrays of any type.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="23ce00df7053058cd95cf5976c1008a23c0c4613" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Internet6Address&lt;/code&gt; encapsulates an IPv6 (Internet Protocol version 6) socket address.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="929d7b4c4cc9a8637b6ae8f312d62876e111741b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;InternetAddress&lt;/code&gt; encapsulates an IPv4 (Internet Protocol version 4) socket address.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b4014cd878c2c4218d0565b355de1af14ef65088" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;InternetHost&lt;/code&gt; is a class for resolving IPv4 addresses.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="303b79b6697c06325ef20861d3893a0348a6c9bc" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;IntervalRange&lt;/code&gt; is only ever constructed by &lt;a href=&quot;#Interval&quot;&gt;&lt;code&gt;Interval&lt;/code&gt;&lt;/a&gt;. However, when it is constructed, it is given a function, &lt;code&gt;func&lt;/code&gt;, which is used to generate the time points which are iterated over. &lt;code&gt;func&lt;/code&gt; takes a time point and returns a time point of the same type. For instance, to iterate over all of the days in the interval &lt;code&gt;Interval!Date&lt;/code&gt;, pass a function to &lt;a href=&quot;#Interval&quot;&gt;&lt;code&gt;Interval&lt;/code&gt;&lt;/a&gt;'s &lt;code&gt;fwdRange&lt;/code&gt; where that function took a &lt;a href=&quot;std_datetime_date#Date&quot;&gt;&lt;code&gt;std.datetime.date.Date&lt;/code&gt;&lt;/a&gt; and returned a &lt;a href=&quot;std_datetime_date#Date&quot;&gt;&lt;code&gt;std.datetime.date.Date&lt;/code&gt;&lt;/a&gt; which was one day later. That function would then be used by &lt;code&gt;IntervalRange&lt;/code&gt;'s &lt;code&gt;popFront&lt;/code&gt; to iterate over the &lt;a href=&quot;std_datetime_date#Date&quot;&gt;&lt;code&gt;std.datetime.date.Date&lt;/code&gt;&lt;/a&gt;s in the interval.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="42f5f38819dff3129805052506f09ab99038900b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;InversionList&lt;/code&gt; is a set of &lt;a href=&quot;#Code%20point&quot;&gt;code points&lt;/a&gt; represented as an array of open-right [a, b) intervals (see &lt;a href=&quot;#CodepointInterval&quot;&gt;&lt;code&gt;CodepointInterval&lt;/code&gt;&lt;/a&gt; above). The name comes from the way the representation reads left to right. For instance a set of all values [10, 50), [80, 90), plus a singular value 60 looks like this:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="37d4eb6c709e9700de66fdc10c8e540d20a7e4b1" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;JSONException&lt;/code&gt; for read access if &lt;code&gt;this.type&lt;/code&gt; is not &lt;code&gt;JSONType.true_&lt;/code&gt; or &lt;code&gt;JSONType.false_&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0a9df16fb53d7d19ae3457b20afe88f508b70112" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;JSONException&lt;/code&gt; for read access if &lt;code&gt;type&lt;/code&gt; is not &lt;code&gt;JSONType.array&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="374fc56bce7b34d2d4fb37271f341137a55bd7f7" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;JSONException&lt;/code&gt; for read access if &lt;code&gt;type&lt;/code&gt; is not &lt;code&gt;JSONType.float_&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d02dc7a78830e793dd620b25cd54dc82c0b138c3" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;JSONException&lt;/code&gt; for read access if &lt;code&gt;type&lt;/code&gt; is not &lt;code&gt;JSONType.integer&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="28e63f5ce8b66a0b7464a33759d365eb7b21a25f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;JSONException&lt;/code&gt; for read access if &lt;code&gt;type&lt;/code&gt; is not &lt;code&gt;JSONType.object&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3d471f0121d68cc1a9cbef2f94fe907eced15162" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;JSONException&lt;/code&gt; for read access if &lt;code&gt;type&lt;/code&gt; is not &lt;code&gt;JSONType.string&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8b58c34a2444a67e9977423cf25f961b52bddb51" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;JSONException&lt;/code&gt; for read access if &lt;code&gt;type&lt;/code&gt; is not &lt;code&gt;JSONType.uinteger&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="924a316d93ba1266b4a2524f7d5f0279e50f3486" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;JSONException&lt;/code&gt; if &lt;code&gt;type&lt;/code&gt; is not &lt;code&gt;JSONType.array&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="288bfc2188bff0897b8c9f679a97e076b2f6137e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;JSONException&lt;/code&gt; if &lt;code&gt;type&lt;/code&gt; is not &lt;code&gt;JSONType.object&lt;/code&gt; or &lt;code&gt;JSONType.null_&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f353747ce5b1603415e719ffa2e430d1926bd101" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;JSONException&lt;/code&gt; if &lt;code&gt;type&lt;/code&gt; is not &lt;code&gt;JSONType.object&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9086cd140a77112c308b7aa75d5b636b32089093" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;JSONException&lt;/code&gt; if the right hand side argument &lt;code&gt;JSONType&lt;/code&gt; is not &lt;code&gt;object&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6bbca7de6c016dd7eb089e3687fc9b8bc4ab9f11" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;KRRegion&lt;/code&gt; = &lt;code&gt;Region&lt;/code&gt; + Kernighan-Ritchie Allocator</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f321db249483bbe4363807ada55b49818b58ef95" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;KRRegion&lt;/code&gt; draws inspiration from the &lt;a href=&quot;std_experimental_allocator_building_blocks_region&quot;&gt;region allocation strategy&lt;/a&gt; and also the &lt;a href=&quot;http://stackoverflow.com/questions/13159564/explain-this-implementation-of-malloc-from-the-kr-book&quot;&gt;famed allocator&lt;/a&gt; described by Brian Kernighan and Dennis Ritchie in section 8.7 of the book &lt;a href=&quot;http://amazon.com/exec/obidos/ASIN/0131103628/classicempire&quot;&gt;&quot;The C Programming Language&quot;&lt;/a&gt;, Second Edition, Prentice Hall, 1988.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="db7d6e394e1f58df812747633f0d7ada9be95b40" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;KRRegion&lt;/code&gt; is preferable to &lt;code&gt;Region&lt;/code&gt; as a front for a general-purpose allocator if &lt;code&gt;deallocate&lt;/code&gt; is needed, yet the actual deallocation traffic is relatively low. The example below shows a &lt;code&gt;KRRegion&lt;/code&gt; using stack storage fronting the GC allocator.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="407854dafd56dc695bff6d9f8c5ac2000bd997b9" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;KeepTerminator&lt;/code&gt;&lt;code&gt;keepTerm&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;KeepTerminator&lt;/code&gt;&lt;code&gt;keepTerm&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="66af2d9115e5fccdf0825879dc694b6243dc0999" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;LINK&lt;/code&gt; to use for &lt;code&gt;extern(System)&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eb1fb7a2d30c4bb9ff4f302703eea931bc144e7b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Lhs.max&lt;/code&gt; if &lt;code&gt;rhs &amp;gt;= 0&lt;/code&gt;, &lt;code&gt;Lhs.min&lt;/code&gt; otherwise.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9419d1db36082b226ab787fbc5117f1ef86ba81b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Lhs.max&lt;/code&gt; if the result overflows in the positive direction, on division by &lt;code&gt;0&lt;/code&gt;, or on shifting right by a negative value</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9867d599d3360d2166c727451bf5ed485b43771d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Lhs.min&lt;/code&gt; if the result overflows in the negative direction</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e1f2a80c67e78e54a24eb42ee38cb80badfaf8a9" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Loc&lt;/code&gt; of the expression triggering the access to &lt;code&gt;at&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dae9c9a060f568e240a1c42e1af07db039cffb81" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;LogLevel&lt;/code&gt; for tracing the execution of the program.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="15d5c9fe039a45ff10bfb3fcf4c6a78d808c24c4" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;LogLevel&lt;/code&gt; to use for this &lt;code&gt;Logger&lt;/code&gt; instance.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e1150e0e8c50b4644e9b3ad3ca52da419b7c609f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;MessageMismatch&lt;/code&gt; if a message of types other than &lt;code&gt;T&lt;/code&gt; is received.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="65c7de08109ea54efe1649a109bfcb32d09b34bc" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;ModuleInfo&lt;/code&gt; is supported. Evaluates to &lt;code&gt;false&lt;/code&gt; when compiling with command line switch &lt;a href=&quot;https://dlang.org/dmd.html#switch-betterC&quot;&gt;&lt;em&gt;-betterC&lt;/em&gt;&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="88d77c659174b60bf4b59f2ff6bb6d3cc340de4e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;MurmurHash3!(128, 32)&lt;/code&gt; and &lt;code&gt;MurmurHash3!(128, 64)&lt;/code&gt; produce different values.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="52bcc9f7af8f6f12630050db8b23eb2e2e49e448" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;MurmurHash3!(128, 32)&lt;/code&gt; produces a 128-bit value and is optimized for 32-bit architectures</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f32ddff3d6f4849c7478516798a4ac1b52282d34" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;MurmurHash3!(128, 64)&lt;/code&gt; produces a 128-bit value and is optimized for 64-bit architectures</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0bd9dfe00b1b4ab2b4da44c82f7641cfaac9239b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;MurmurHash3!32&lt;/code&gt; produces a 32-bit value and is optimized for 32-bit architectures</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4474b7d5c23fed4796fe3c267e522c992cd94904" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Mutex.lock&lt;/code&gt; does not throw, but a class derived from Mutex can throw. Use &lt;code&gt;lock_nothrow&lt;/code&gt; in &lt;code&gt;nothrow @nogc&lt;/code&gt; code.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="19fbb5f989c0af04c8b083d15c647d76145e30b4" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Mutex.tryLock&lt;/code&gt; does not throw, but a class derived from Mutex can throw. Use &lt;code&gt;tryLock_nothrow&lt;/code&gt; in &lt;code&gt;nothrow @nogc&lt;/code&gt; code.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7c0ef9f513fc9d530a91bc805078e6a6099ffd49" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Mutex.unlock&lt;/code&gt; does not throw, but a class derived from Mutex can throw. Use &lt;code&gt;unlock_nothrow&lt;/code&gt; in &lt;code&gt;nothrow @nogc&lt;/code&gt; code.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0f1eca57de65dba2657112d5d3b43e02e51f2136" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;NegInfIntervalRange&lt;/code&gt; is only ever constructed by &lt;code&gt;NegInfInterval&lt;/code&gt;. However, when it is constructed, it is given a function, &lt;code&gt;func&lt;/code&gt;, which is used to generate the time points which are iterated over. &lt;code&gt;func&lt;/code&gt; takes a time point and returns a time point of the same type. For instance, to iterate over all of the days in the interval &lt;code&gt;NegInfInterval!Date&lt;/code&gt;, pass a function to &lt;code&gt;NegInfInterval&lt;/code&gt;'s &lt;code&gt;bwdRange&lt;/code&gt; where that function took a &lt;a href=&quot;std_datetime_date#Date&quot;&gt;&lt;code&gt;std.datetime.date.Date&lt;/code&gt;&lt;/a&gt; and returned a &lt;a href=&quot;std_datetime_date#Date&quot;&gt;&lt;code&gt;std.datetime.date.Date&lt;/code&gt;&lt;/a&gt; which was one day earlier. That function would then be used by &lt;code&gt;NegInfIntervalRange&lt;/code&gt;'s &lt;code&gt;popFront&lt;/code&gt; to iterate over the &lt;a href=&quot;std_datetime_date#Date&quot;&gt;&lt;code&gt;std.datetime.date.Date&lt;/code&gt;&lt;/a&gt;s in the interval - though obviously, since the range is infinite, use a function such as &lt;code&gt;std.range.take&lt;/code&gt; with it rather than iterating over</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="20f1388bdae9c724328768c67e2bf74ccf100c75" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Note:&lt;/code&gt; If a finally clause executes a throw out of the finally clause, the break target is never reached.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c45e10577dee6f4cb71de927dc8836b2f1ac9a27" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Note:&lt;/code&gt; If a finally clause executes a throw out of the finally clause, the continue target is never reached.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="21edd622bef9e1c578cfde461f5374945dff73cf" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;NullAllocator&lt;/code&gt; advertises a relatively large alignment equal to 64 KB. This is because &lt;code&gt;NullAllocator&lt;/code&gt; never actually needs to honor this alignment and because composite allocators using &lt;code&gt;NullAllocator&lt;/code&gt; shouldn't be unnecessarily constrained.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fde2a7522ff25f76c62d43d840e184a9693bf37b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;NullAllocator&lt;/code&gt; is an emphatically empty implementation of the allocator interface. Although it has no direct use, it is useful as a &quot;terminator&quot; in composite allocators.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="26af361fb937ce89c2ffa3c9c2d6a1257d185c4b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;OutBuffer&lt;/code&gt; to write the mangled function signature to</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3fe9a99db1ee4d687b3f8bd5d0c960a952d9bdc4" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;OutOfMemoryError&lt;/code&gt; on allocation failure.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d50b7d457eec0ba1f8877d663f932cf82639bd11" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;PosInfIntervalRange&lt;/code&gt; is only ever constructed by &lt;code&gt;PosInfInterval&lt;/code&gt;. However, when it is constructed, it is given a function, &lt;code&gt;func&lt;/code&gt;, which is used to generate the time points which are iterated over. &lt;code&gt;func&lt;/code&gt; takes a time point and returns a time point of the same type. For instance, to iterate over all of the days in the interval &lt;code&gt;PosInfInterval!Date&lt;/code&gt;, pass a function to &lt;code&gt;PosInfInterval&lt;/code&gt;'s &lt;code&gt;fwdRange&lt;/code&gt; where that function took a &lt;a href=&quot;std_datetime_date#Date&quot;&gt;&lt;code&gt;std.datetime.date.Date&lt;/code&gt;&lt;/a&gt; and returned a &lt;a href=&quot;std_datetime_date#Date&quot;&gt;&lt;code&gt;std.datetime.date.Date&lt;/code&gt;&lt;/a&gt; which was one day later. That function would then be used by &lt;code&gt;PosInfIntervalRange&lt;/code&gt;'s &lt;code&gt;popFront&lt;/code&gt; to iterate over the &lt;a href=&quot;std_datetime_date#Date&quot;&gt;&lt;code&gt;std.datetime.date.Date&lt;/code&gt;&lt;/a&gt;s in the interval - though obviously, since the range is infinite, use a function such as &lt;code&gt;std.range.take&lt;/code&gt; with it rather than iterating over</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cb8dc60d5bc32b6bcdebce52b394fac49414cf48" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;ProperCompare&lt;/code&gt; fixes the comparison operators ==, !=, &amp;lt;, &amp;lt;=, &amp;gt;, and &amp;gt;= to return correct results</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c20b8bd63e178e519036e1081ea692a599a4c8fa" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Protocol&lt;/code&gt; is a class for retrieving protocol information.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bb48bdc418739c506d179ce3cbcd0758cea6acca" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;ProtocolType&lt;/code&gt; - protocol to filter by</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5cb5a15effd4c34f04b113fc0b80aca348b723c6" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;R&lt;/code&gt; accepts some form of string or character. put will transcode the character &lt;code&gt;e&lt;/code&gt; accordingly.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="780b6e42b49937b33d3acf041f9f55b645a2cc51" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;R&lt;/code&gt; specifically accepts an &lt;code&gt;E&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0c66441bc26ad454d0cc3d154df2f83c7aaac35f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;R&lt;/code&gt; specifically accepts an &lt;code&gt;E[]&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="75cde118348c0e71fa950e422d9c9e78ae88ab95" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;RangePrimitive.access&lt;/code&gt; is a shortcut for the access primitives; &lt;code&gt;front&lt;/code&gt;, &lt;code&gt;back&lt;/code&gt; and &lt;code&gt;opIndex&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f762138a599689e87a282296107b6b29b6a13874" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;RangePrimitive.pop&lt;/code&gt; is a shortcut for the mutating primitives; &lt;code&gt;popFront&lt;/code&gt; and &lt;code&gt;popBack&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="030771000e0ceb8354a01647408b24878dcaca4d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Rebindable!(T)&lt;/code&gt; is a simple, efficient wrapper that behaves just like an object of type &lt;code&gt;T&lt;/code&gt;, except that you can reassign it to refer to another object. For completeness, &lt;code&gt;Rebindable!(T)&lt;/code&gt; aliases itself away to &lt;code&gt;T&lt;/code&gt; if &lt;code&gt;T&lt;/code&gt; is a non-const object type.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b00a9e0b0a644fd8087968f990c22c18c90edf0b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;RefCounted&lt;/code&gt; is unsafe and should be used with care. No references to the payload should be escaped outside the &lt;code&gt;RefCounted&lt;/code&gt; object.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d88ab8258f37733765c1601e808462b33b8aee2a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;RefCounted&lt;/code&gt; storage implementation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9bee36718af73e578a30bbaedc2c37541d5e249f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Regex&lt;/code&gt; object holds regular expression pattern in compiled form.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="87d4168f1bbd4eac219801b43c6bc243bfc23d42" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Regex&lt;/code&gt; object that works on inputs having the same character width as &lt;code&gt;pattern&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="471e1b858b0c776c473a1871b9341b72606ac29f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;RegexException&lt;/code&gt; if there were any errors during compilation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a53adf2cbff9ae2891543c9eacc87e202aff05df" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;ReplaceType&lt;/code&gt; aliases itself to the type(s) that result after replacement.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2f1f6bbeb799dd234e6f795209127f34ac65e265" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;S&lt;/code&gt; defines at least one direct member that has a copy constructor, and that member is not overlapped (by means of &lt;code&gt;union&lt;/code&gt;) with any other member.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="75630199841be5d37303401849758dd2a43984da" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;S&lt;/code&gt; does not explicitly declare any copy constructors;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="78494e20fa7de6742095448d88b655fd51d08a41" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;SList&lt;/code&gt; uses reference semantics.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c56058ec16a4fa994151ef298e8adc161ce878c9" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;SMTP&lt;/code&gt; struct for advanced usage</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7e9d8cf3e45f79f3c4e342d8fae899fb65e16630" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Saturate&lt;/code&gt; stops at an overflow</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2f7486cdf10bdc5b58b2b22311800e044e643d8d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Scope&lt;/code&gt; of the expression (deprecations do not trigger in deprecated scopes)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="332dd805aa714f4c9de1b65f527e6f2f95a4b450" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;ScopedAllocator&lt;/code&gt; delegates all allocation requests to &lt;code&gt;ParentAllocator&lt;/code&gt;. When destroyed, the &lt;code&gt;ScopedAllocator&lt;/code&gt; object automatically calls &lt;code&gt;deallocate&lt;/code&gt; for all memory allocated through its lifetime. (The &lt;code&gt;deallocateAll&lt;/code&gt; function is also implemented with the same semantics.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="68e3c30a95c281a86363341aaa246fbc3330c338" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Sequence&lt;/code&gt; is similar to &lt;code&gt;Recurrence&lt;/code&gt; except that iteration is presented in the so-called &lt;a href=&quot;http://en.wikipedia.org/wiki/Closed_form&quot;&gt; closed form&lt;/a&gt;. This means that the &lt;code&gt;n&lt;/code&gt;th element in the series is computable directly from the initial values and &lt;code&gt;n&lt;/code&gt; itself. This implies that the interface offered by &lt;code&gt;Sequence&lt;/code&gt; is a random-access range, as opposed to the regular &lt;code&gt;Recurrence&lt;/code&gt;, which only offers forward iteration.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1f74cfffb73a2e53c60382547eeaff4ebf62277d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Service&lt;/code&gt; is a class for retrieving service information.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5dd3d87bf4379ada60681ae524288a8b96bcde1a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;SharedAlignedBlockList&lt;/code&gt; is the threadsafe version of &lt;code&gt;AlignedBlockList&lt;/code&gt;. The &lt;code&gt;Allocator&lt;/code&gt; template parameter must refer a shared allocator. Also, &lt;code&gt;ParentAllocator&lt;/code&gt; must be a shared allocator, supporting &lt;code&gt;alignedAllocate&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="746754b2aa00bad45fb2be52daaa182ac49c6430" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;SharedAscendingPageAllocator&lt;/code&gt; is the threadsafe version of &lt;code&gt;AscendingPageAllocator&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c6efd4b35b5ba7aadd42b05cb7b5432c9aa7ea3a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Socket&lt;/code&gt; is a class that creates a network communication endpoint using the Berkeley sockets interface.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="87fa4417125d3cac79e8cb411aa1e3d62379087e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;SocketException&lt;/code&gt; if creation of the sockets fails.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b78b331409d25e66115d26e36b7a7111d4712e46" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;SocketException&lt;/code&gt; if setting the options fails.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="62fb2c297f48546eaf7d5c402b4d6de00e5102d7" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;SocketException&lt;/code&gt; on error.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="76dfb042cff82ec649174071c6f90d7f55b3bb47" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;SocketException&lt;/code&gt; on failure.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6a0ac3e53834af046f515ebd06d9bdfc272be3ba" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;SocketOSException&lt;/code&gt; if setting the options fails, or &lt;code&gt;SocketFeatureException&lt;/code&gt; if setting keep-alive parameters is unsupported on the current platform.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7a0981fb867b9d1010fb7e98f0f42f113299e19e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;SocketOSException&lt;/code&gt; on failure, or &lt;code&gt;SocketFeatureException&lt;/code&gt; if this functionality is not available on the current system.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3eb13bd8112aca0871aae534a7fb63f8bff6f0ea" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;SocketOSException&lt;/code&gt; on failure.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="533fe63858ca229c5548c18bba5c935275d9786a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;SocketSet&lt;/code&gt; wraps the platform &lt;code&gt;fd_set&lt;/code&gt; type. However, unlike &lt;code&gt;fd_set&lt;/code&gt;, &lt;code&gt;SocketSet&lt;/code&gt; is not statically limited to &lt;code&gt;FD_SETSIZE&lt;/code&gt; or any other limit, and grows as needed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6292666f1fd27e364014781db58d7c9f3d224716" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;SocketType&lt;/code&gt; - socket type to filter by</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c787eccd1cfe254a883d5baa6dbc853ad90fc0c3" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;SortedRange&lt;/code&gt; could accept ranges weaker than random-access, but it is unable to provide interesting functionality for them. Therefore, &lt;code&gt;SortedRange&lt;/code&gt; is currently restricted to random-access ranges.  No copy of the original range is ever made. If the underlying range is changed concurrently with its corresponding &lt;code&gt;SortedRange&lt;/code&gt; in ways that break its sorted-ness, &lt;code&gt;SortedRange&lt;/code&gt; will work erratically.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5b9ca29b38b1f15d8973e1ced47848fd1d2dba6f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Source&lt;/code&gt; must be a random access range. The returned range will be bidirectional or random-access if &lt;code&gt;Indices&lt;/code&gt; is bidirectional or random-access, respectively.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4c0feeb1ff674d28575106f12aafb6a73cdd4968" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;StdioException&lt;/code&gt; on I/O error, or &lt;code&gt;UnicodeException&lt;/code&gt; on Unicode conversion error.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a895bd9ca37148b0bedbdaf72160091894b81f68" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;StopWatch&lt;/code&gt; measures time as precisely as possible.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6a66ba194c1af962c95944ee31d9e398b9989bf7" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;SysTime&lt;/code&gt; is the type used to get the current time from the system or doing anything that involves time zones. Unlike &lt;a href=&quot;std_datetime_date#DateTime&quot;&gt;&lt;code&gt;std.datetime.date.DateTime&lt;/code&gt;&lt;/a&gt;, the time zone is an integral part of &lt;code&gt;SysTime&lt;/code&gt; (though for local time applications, time zones can be ignored and it will work, since it defaults to using the local time zone). It holds its internal time in std time (hnsecs since midnight, January 1st, 1 A.D. UTC), so it interfaces well with the system time. However, that means that, unlike &lt;a href=&quot;std_datetime_date#DateTime&quot;&gt;&lt;code&gt;std.datetime.date.DateTime&lt;/code&gt;&lt;/a&gt;, it is not optimized for calendar-based operations, and getting individual units from it such as years or days is going to involve conversions and be less efficient.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ac0c6b1810b24c03416add46f5ae8e5d1b27562a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;SysTime&lt;/code&gt;'s range is from approximately 29,000 B.C. to approximately 29,000 A.D.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="91628f7ac20b93970362b69b9450bc20627b98eb" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;T&lt;/code&gt; must define a &lt;code&gt;opBinary&lt;/code&gt; for subtraction which accepts &lt;code&gt;T&lt;/code&gt; and returns returns &lt;a href=&quot;core_time#Duration&quot;&gt;&lt;code&gt;core.time.Duration&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4d2c6bca96e673afe06d9e325d4acc343fd20d60" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;T&lt;/code&gt; must define a static property named &lt;code&gt;max&lt;/code&gt; which is the largest value of &lt;code&gt;T&lt;/code&gt; as &lt;code&gt;Unqual!T&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f294feb51e2d2f00db976416287ad63fee9f66c4" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;T&lt;/code&gt; must define a static property named &lt;code&gt;min&lt;/code&gt; which is the smallest value of &lt;code&gt;T&lt;/code&gt; as &lt;code&gt;Unqual!T&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="53e8de8dac2a8691b4bdd0087daafbe6712c0f2a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;T&lt;/code&gt; must define an &lt;code&gt;opBinary&lt;/code&gt; for addition and subtraction that accepts &lt;a href=&quot;core_time#Duration&quot;&gt;&lt;code&gt;core.time.Duration&lt;/code&gt;&lt;/a&gt; and returns &lt;code&gt;Unqual!T&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7fab6f337372fb064f170e2a181317eb9e44fc5e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;T&lt;/code&gt; must define an &lt;code&gt;opOpAssign&lt;/code&gt; for addition and subtraction that accepts &lt;a href=&quot;core_time#Duration&quot;&gt;&lt;code&gt;core.time.Duration&lt;/code&gt;&lt;/a&gt; and returns &lt;code&gt;ref Unqual!T&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7e5a544e1bd186a2a67b6a67ef05e99600fe89c6" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;T&lt;/code&gt; with the &lt;code&gt;const&lt;/code&gt; and &lt;code&gt;shared&lt;/code&gt; qualifiers added.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="31ec721d20b2801e5d346700c80f678793d1c0e2" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;T&lt;/code&gt; with the &lt;code&gt;const&lt;/code&gt; qualifier added.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="186a43c969a1f6b869085813b17231ea61972375" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;T&lt;/code&gt; with the &lt;code&gt;immutable&lt;/code&gt; qualifier added.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0f4a39908568cd6d472669bdc7cd96a13cb06098" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;T&lt;/code&gt; with the &lt;code&gt;inout&lt;/code&gt; and &lt;code&gt;shared&lt;/code&gt; qualifiers added.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="470204d231d8939583648e7203f7b1cd2a937dff" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;T&lt;/code&gt; with the &lt;code&gt;inout&lt;/code&gt; qualifier added.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3275cab2586883588d212e6312445a72995e25af" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;T&lt;/code&gt; with the &lt;code&gt;shared&lt;/code&gt; qualifier added.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0108d5739821b102796437e45f235d8ce482969a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Task&lt;/code&gt; objects created using &lt;code&gt;scopedTask&lt;/code&gt; will automatically call &lt;code&gt;Task.yieldForce&lt;/code&gt; in their destructor if necessary to ensure the &lt;code&gt;Task&lt;/code&gt; is complete before the stack frame they reside on is destroyed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2832ad7b33aebd000a73dcb20f507e685a655947" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Task&lt;/code&gt; represents the fundamental unit of work. A &lt;code&gt;Task&lt;/code&gt; may be executed in parallel with any other &lt;code&gt;Task&lt;/code&gt;. Using this struct directly allows future/promise parallelism. In this paradigm, a function (or delegate or other callable) is executed in a thread other than the one it was called from. The calling thread does not block while the function is being executed. A call to &lt;code&gt;workForce&lt;/code&gt;, &lt;code&gt;yieldForce&lt;/code&gt;, or &lt;code&gt;spinForce&lt;/code&gt; is used to ensure that the &lt;code&gt;Task&lt;/code&gt; has finished executing and to obtain the return value, if any. These functions and &lt;code&gt;done&lt;/code&gt; also act as full memory barriers, meaning that any memory writes made in the thread that executed the &lt;code&gt;Task&lt;/code&gt; are guaranteed to be visible in the calling thread after one of these functions returns.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="82cd55fb0d006768136f2c5c0b4fcccab522c36f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;TcpSocket&lt;/code&gt; is a shortcut class for a TCP Socket.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="38f55edede4991a3cf116d69d68fc1d676b1f44d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Ternary.no&lt;/code&gt; for &lt;code&gt;false&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2869c4358399eebb5142dbe39568cc4e025e08d4" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Ternary.unknown&lt;/code&gt; as an unknown state</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="69476aeb136d8de7d30539eb5cacebe2d2d3358d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Ternary.yes&lt;/code&gt; for &lt;code&gt;true&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="46a182d3e8c1d404cdf9f37047a9ee60a7e8b3cc" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Ternary.yes&lt;/code&gt; if one allocator was found to return &lt;code&gt;Ternary.yes&lt;/code&gt;, &lt;code&gt;Ternary.no&lt;/code&gt; if all component allocators returned &lt;code&gt;Ternary.no&lt;/code&gt;, and &lt;code&gt;Ternary.unknown&lt;/code&gt; if no allocator returned &lt;code&gt;Ternary.yes&lt;/code&gt; and at least one returned &lt;code&gt;Ternary.unknown&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7599544c003fc14111a32d44931860cfa0dd0ec1" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Ternary.yes&lt;/code&gt; if owned by this allocator and &lt;code&gt;Ternary.no&lt;/code&gt; otherwise</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4ad19c9b06c6c6a7d61bae14eea7ed48e0a9b259" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Ternary.yes&lt;/code&gt; if the allocator is empty, &lt;code&gt;Ternary.no&lt;/code&gt; otherwise. Never returns &lt;code&gt;Ternary.unknown&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f1b49c13e674e31d46bece718af98b61034636b7" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Throw&lt;/code&gt; fails every incorrect operation by throwing an exception</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5697669daea1d2edaa6375d26bbad9518d5edafa" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;TimeException&lt;/code&gt; if an attempt to divide by &lt;code&gt;0&lt;/code&gt; is made.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2dc0d79c91d4e0597dd2ceebdb751a34fe72f1a4" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;TimeException&lt;/code&gt; if it fails to get the time.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c70993b8aed1eb03ef954291b34693b20ea0b2c2" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Transposed&lt;/code&gt; currently defines &lt;code&gt;save&lt;/code&gt;, but does not work as a forward range. Consuming a copy made with &lt;code&gt;save&lt;/code&gt; will consume all copies, even the original sub-ranges fed into &lt;code&gt;Transposed&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="34644096ee359c9f543613726d2a575c3df43b36" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Tuple&lt;/code&gt; members can be named. It is legal to mix named and unnamed members. The method above is still applicable to all fields.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="22855b22d24613edb4797b3b3082b40e8bf9bd08" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Type&lt;/code&gt; that represents &lt;code&gt;va_list&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5995b12e3c639fd0ac9edd39fe711f66a051c4a3" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Type&lt;/code&gt; to use for parameter &lt;code&gt;p&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9b7e28bca0b07d1e1da65763c6214f44c548470e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Type&lt;/code&gt; with completed semantic analysis, &lt;code&gt;Terror&lt;/code&gt; if errors were encountered</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="03eaa064f1e4b2fb2c72e1d6e5d83085754ab33e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;TypeIdentifier&lt;/code&gt; corresponding to &lt;code&gt;object.Throwable&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="897ecbae7f27f97ae3e90420e022adc7dd2fbbd6" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;TypedAllocator&lt;/code&gt; acts like a chassis on which several specialized allocators can be assembled. To let the system make a choice about a particular kind of allocation, use &lt;code&gt;Default&lt;/code&gt; for the respective parameters.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6b1f38ae7efe6d59115175c5fdcc377f07580928" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;UTC&lt;/code&gt; is a singleton class. &lt;code&gt;UTC&lt;/code&gt; returns its only instance.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="007930a39a0f2faab8c8e4ee31d60aa7baf6481f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;UTFException&lt;/code&gt; if &lt;code&gt;c&lt;/code&gt; is not a valid UTF code point.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2e62d6eb9384d3f58094d2720a94e28aae93a734" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;UTFException&lt;/code&gt; if &lt;code&gt;str&lt;/code&gt; is not well-formed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0dfa2e2d6c82d1a56c3f65f1ee4bf18752205a6d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;UdpSocket&lt;/code&gt; is a shortcut class for a UDP Socket.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5182d8d27ca95d277c11a3764eae17a180358ab4" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;UnixAddress&lt;/code&gt; encapsulates an address for a Unix domain socket (&lt;code&gt;AF_UNIX&lt;/code&gt;), i.e. a socket bound to a path name in the file system. Available only on supported systems.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="570cc7188794ad606227ced38f371e5a4e45af02" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;UnknownAddress&lt;/code&gt; encapsulates an unknown socket address.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9f804467942c17845726358bd0a49138438d2921" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;UnknownAddressReference&lt;/code&gt; encapsulates a reference to an arbitrary socket address.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="86d81bb175d8331c17abee4394d7ff9941e66945" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;VariantN&lt;/code&gt; is a discriminated union type parameterized with the largest size of the types stored (&lt;code&gt;maxDataSize&lt;/code&gt;) and with the list of allowed types (&lt;code&gt;AllowedTypes&lt;/code&gt;). If the list is empty, then any type up of size up to &lt;code&gt; maxDataSize&lt;/code&gt; (rounded up for alignment) can be stored in a &lt;code&gt;VariantN&lt;/code&gt; object without being boxed (types larger than this will be boxed).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e1cd77bcc0cf1f030ae7901413fc0caacad7cb4e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;WhiteHole!Base&lt;/code&gt; is a subclass of &lt;code&gt;Base&lt;/code&gt; which automatically implements all abstract member functions as functions that always fail. These functions simply throw an &lt;code&gt;Error&lt;/code&gt; and never return. &lt;code&gt;Whitehole&lt;/code&gt; is useful for trapping the use of class member functions that haven't been implemented.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="88dc88b6a51b76108d5dab31380ce314448dfd5c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;WindowsTimeZone&lt;/code&gt; does not exist on Posix systems.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b4dc9fa60360bfc14db34f4ba777455add3c797a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;WithNaN&lt;/code&gt; has a special &quot;Not a Number&quot; (NaN) value akin to the homonym value reserved for floating-point values</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="75932668cda7d1c138194cb2dc0ebce2d67618fc" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Yes.allocateGC&lt;/code&gt;/&lt;code&gt;No.allocateGC&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;Yes.allocateGC&lt;/code&gt;/&lt;code&gt;No.allocateGC&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="37096fcbb3223cda99b6350080a7ac8758291a16" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Yes.caseSensitive&lt;/code&gt; (default) or &lt;code&gt;No.caseSensitive&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aa4e1929badc6e0a53755ba0d2f8f6d82478fac6" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Yes.caseSensitive&lt;/code&gt; or &lt;code&gt;No.caseSensitive&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="acde99d49e2a347fbbea03032397e4d04b670d2f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Yes.each&lt;/code&gt; if the entire range was iterated, &lt;code&gt;No.each&lt;/code&gt; in case of early stopping.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1a0894a8a8a7fcd48b48f86aff52d4085ed4d7ea" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Yes.keepTerminator&lt;/code&gt; signals that the line terminator should be returned as part of the lines in the range.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0e9225c219b029fb33b9467a4723c8b934677c56" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Yes.multiblock&lt;/code&gt; to support allocations spanning across multiple blocks and &lt;code&gt;No.multiblock&lt;/code&gt; to support single block allocations. Although limited by single block allocations, &lt;code&gt;No.multiblock&lt;/code&gt; will generally provide higher performance.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4e26adb07aa94d1c5cf3ef86c050cd4d263aafe0" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;[1, 2].substitute(1, 0.1)&lt;/code&gt; returns &lt;code&gt;[0.1, 2]&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;[1, 2].substitute(1, 0.1)&lt;/code&gt; returns &lt;code&gt;[0.1, 2]&lt;/code&gt;.</target>
        </trans-unit>
        <trans-unit id="0473657586b4b2fbdfc343d365146a98334ec2c8" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;] = c&lt;/code&gt; are rewritten as &lt;code&gt;a.opIndexAssign(c,&lt;/code&gt;&lt;code&gt;a.opSlice(&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;] = c&lt;/code&gt; are rewritten as &lt;code&gt;a.opIndexAssign(c,&lt;/code&gt;&lt;code&gt;a.opSlice(&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="f9bd65cd7b31f1495857902ae8fd7a208acd1507" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;]&lt;/code&gt; as &lt;code&gt;a.opIndexAssign(a.opSlice(&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;]&lt;/code&gt; as &lt;code&gt;a.opIndexAssign(a.opSlice(&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="53d36c336609c242959efe9929c29b979ffec086" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;]&lt;/code&gt; can also be overloaded by implementing &lt;code&gt;opSlice()&lt;/code&gt; with no arguments and &lt;code&gt;opSlice(&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;]&lt;/code&gt; can also be overloaded by implementing &lt;code&gt;opSlice()&lt;/code&gt; with no arguments and &lt;code&gt;opSlice(&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="f97d7e3a93902ed9c6d203a821119d9132a3f3b5" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;]&lt;/code&gt;, where the expressions inside the square brackets contain slice expressions of the form</source>
          <target state="translated">&lt;code&gt;]&lt;/code&gt;, where the expressions inside the square brackets contain slice expressions of the form</target>
        </trans-unit>
        <trans-unit id="49268134baf72802931b8c3948cac60b86dde66e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;_&lt;/code&gt;arguments</source>
          <target state="translated">&lt;code&gt;_&lt;/code&gt;arguments</target>
        </trans-unit>
        <trans-unit id="e31497ca3e9899507e5c69f4846b4a071560e54b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;__FILE_FULL_PATH__&lt;/code&gt; expands to the absolute source file name at the point of instantiation.</source>
          <target state="translated">&lt;code&gt;__FILE_FULL_PATH__&lt;/code&gt; expands to the absolute source file name at the point of instantiation.</target>
        </trans-unit>
        <trans-unit id="80a25cf93923c63ad8518f587ae90ca9069798a1" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;__FILE__&lt;/code&gt; and &lt;code&gt;__LINE__&lt;/code&gt; expand to the source file name and line number at the point of instantiation. The path of the source file is left up to the compiler.</source>
          <target state="translated">&lt;code&gt;__FILE__&lt;/code&gt; and &lt;code&gt;__LINE__&lt;/code&gt; expand to the source file name and line number at the point of instantiation. The path of the source file is left up to the compiler.</target>
        </trans-unit>
        <trans-unit id="ed588f6dcc2cb7aa7133ee1f40685cad687bdaf9" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;__FUNCTION__&lt;/code&gt; expands to the fully qualified name of the function at the point of instantiation.</source>
          <target state="translated">&lt;code&gt;__FUNCTION__&lt;/code&gt; expands to the fully qualified name of the function at the point of instantiation.</target>
        </trans-unit>
        <trans-unit id="2359fdfddc3fc8d10e8fe72822341452b6bf1b38" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;__MODULE__&lt;/code&gt; expands to the module name at the point of instantiation.</source>
          <target state="translated">&lt;code&gt;__MODULE__&lt;/code&gt; expands to the module name at the point of instantiation.</target>
        </trans-unit>
        <trans-unit id="eca932952e18272728a561301fa1405e49487c48" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;__PRETTY_FUNCTION__&lt;/code&gt; is similar to &lt;code&gt;__FUNCTION__&lt;/code&gt;, but also expands the function return type, its parameter types, and its attributes.</source>
          <target state="translated">&lt;code&gt;__PRETTY_FUNCTION__&lt;/code&gt; is similar to &lt;code&gt;__FUNCTION__&lt;/code&gt;, but also expands the function return type, its parameter types, and its attributes.</target>
        </trans-unit>
        <trans-unit id="79b8a8782b10376be103a1b46f17d41a7ce95fde" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;__deh_eh&lt;/code&gt;, &lt;code&gt;__DATA&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;__deh_eh&lt;/code&gt;, &lt;code&gt;__DATA&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="16b9bfc2a738412fd0d279ded1128b5343a9e21f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;__gshared&lt;/code&gt; Attribute</source>
          <target state="translated">&lt;code&gt;__gshared&lt;/code&gt; Attribute</target>
        </trans-unit>
        <trans-unit id="64d15ca2a1aa87d72f7c89826d3003d8d24ce658" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;__gshared&lt;/code&gt; is disallowed in safe mode.</source>
          <target state="translated">&lt;code&gt;__gshared&lt;/code&gt; is disallowed in safe mode.</target>
        </trans-unit>
        <trans-unit id="067be2526e301e788923402f587a4884fcca8cbf" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;__gshared&lt;/code&gt; may also be applied to member variables and local variables. In these cases, &lt;code&gt;__gshared&lt;/code&gt; is equivalent to &lt;code&gt;static&lt;/code&gt;, except that the variable is shared by all threads rather than being thread local.</source>
          <target state="translated">&lt;code&gt;__gshared&lt;/code&gt; may also be applied to member variables and local variables. In these cases, &lt;code&gt;__gshared&lt;/code&gt; is equivalent to &lt;code&gt;static&lt;/code&gt;, except that the variable is shared by all threads rather than being thread local.</target>
        </trans-unit>
        <trans-unit id="da5929d8792a5bf4d5a1a5e20ebb3b7545142b09" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;_argptr&lt;/code&gt; and &lt;code&gt;_arguments&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;_argptr&lt;/code&gt; and &lt;code&gt;_arguments&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="927a35ea306e7d9e1a9c8f224e1e1f44cc56f803" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;_trailing&lt;/code&gt; contains the rest of the format string.</source>
          <target state="translated">&lt;code&gt;_trailing&lt;/code&gt; contains the rest of the format string.</target>
        </trans-unit>
        <trans-unit id="c23d4c448b30b7e5762e3b9f50f1b38c92addc3b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;a.opCmp(b)&lt;/code&gt;&lt;code&gt;&amp;gt;&lt;/code&gt;&lt;code&gt;0&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;a.opCmp(b)&lt;/code&gt;&lt;code&gt;&amp;gt;&lt;/code&gt;&lt;code&gt;0&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="83aca5e23ffe5179da8d2a164f7e4d0b65a4c6c4" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;a.opCmp(b)&lt;/code&gt;&lt;code&gt;&amp;gt;&lt;/code&gt;&lt;code&gt;= 0&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="181857568295d56eba9a6a198de27c754dd04414" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;a.opCmp(b)&lt;/code&gt;&lt;code&gt;&amp;lt;&lt;/code&gt;&lt;code&gt;0&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;a.opCmp(b)&lt;/code&gt;&lt;code&gt;&amp;lt;&lt;/code&gt;&lt;code&gt;0&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="85dd9503032ce2e1a2b3998f9b3f43ee7645078a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;a.opCmp(b)&lt;/code&gt;&lt;code&gt;&amp;lt;&lt;/code&gt;&lt;code&gt;= 0&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e146d9bd2ea897b3e719a63d2a74b59414f2e3d2" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;a0&lt;/code&gt;, &lt;code&gt;a1&lt;/code&gt;, &amp;hellip;: arguments passed to the function;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b8067ead0423db1cae0ce0fbdd233161504053f4" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;a&lt;/code&gt; without evaluating &lt;code&gt;b&lt;/code&gt; if &lt;code&gt;cond&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;. Otherwise, returns &lt;code&gt;b&lt;/code&gt; without evaluating &lt;code&gt;a&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a080773255c341a2088ee851b7f90e5bac4bd5d8" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;a&lt;/code&gt;, &lt;code&gt;b&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b3f340a48cc5ef4b2a7c3fb270ef208c519320ab" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;a&lt;/code&gt;&lt;code&gt;&amp;gt;&lt;/code&gt;&lt;code&gt;= b&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3c47794bafd1b854eee29c6dd3c8d0a62f9c6390" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;a&lt;/code&gt;&lt;code&gt;&amp;gt;&lt;/code&gt;&lt;code&gt;b&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;a&lt;/code&gt;&lt;code&gt;&amp;gt;&lt;/code&gt;&lt;code&gt;b&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="a7e18871ebac940afccefd06288a22599af4a142" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;a&lt;/code&gt;&lt;code&gt;&amp;lt;&lt;/code&gt;&lt;code&gt;= b&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4394b6408820c3ccbeb907463762684a0db34545" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;a&lt;/code&gt;&lt;code&gt;&amp;lt;&lt;/code&gt;&lt;code&gt;b&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;a&lt;/code&gt;&lt;code&gt;&amp;lt;&lt;/code&gt;&lt;code&gt;b&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="481e0e3279ea55db4490b4e12b497bb7796185c2" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;abort&lt;/code&gt; The default behavior. The normal behavior as described in the previous section</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="862ebc26b834e571d93df7218de8a3cf6a0a6944" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;absTolerance&lt;/code&gt; shall be normal positive real no less then &lt;code&gt;T.epsilon*2&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="069bc530f0c192a689ee8804bab426dafd2e186a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;abstract&lt;/code&gt; Attribute</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dea734aca244e1fa75a85bf8024a6dda064dd51f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;align&lt;/code&gt; Attribute</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2bbda70a12b1dfb683a3d0eeefb4b0af80992840" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;align&lt;/code&gt; by itself sets it to the default, which matches the default member alignment of the companion C compiler.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="96c65851d0dfae10224f2b4c30d382fe864e2e13" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;alignedReallocate&lt;/code&gt; does not attempt to use &lt;code&gt;Allocator.reallocate&lt;/code&gt; even if defined. This is deliberate so allocators may use it internally within their own implementation of &lt;code&gt;reallocate&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="920656092b134a330263b0a718fccea2594e0c24" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;all!&quot;a &amp;gt; 0&quot;([1, 2, 3, 4])&lt;/code&gt; returns &lt;code&gt;true&lt;/code&gt; because all elements are positive</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e1ec3a1b62b705508abcddac095e37129e263fa2" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;all&lt;/code&gt; can also be used without a predicate, if its items can be evaluated to true or false in a conditional statement. This can be a convenient way to quickly evaluate that</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="40bf88a393461716b9db758c2a860087764c87d9" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;any!&quot;a &amp;gt; 0&quot;([1, 2, -3, -4])&lt;/code&gt; returns &lt;code&gt;true&lt;/code&gt; because at least one element is positive</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="75c0218f1f4dc4fd6870ad5899d4a2555db6aab3" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;any&lt;/code&gt; can also be used without a predicate, if its items can be evaluated to true or false in a conditional statement. &lt;code&gt;!any&lt;/code&gt; can be a convenient way to quickly test that</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="920ac1cf35f2ec8de62ed4ca28b101cde7e08da0" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;args&lt;/code&gt; must not have unshared aliasing. In other words, all arguments to &lt;code&gt;fn&lt;/code&gt; must either be &lt;code&gt;shared&lt;/code&gt; or &lt;code&gt;immutable&lt;/code&gt; or have no pointer indirection. This is necessary for enforcing isolation among threads.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bb52ec3e03bf0cb8732949695494b891c652b1e7" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;args&lt;/code&gt;: a tuple of the arguments;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d04beebd234d53b9bd69f97edc333bfcb532821c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;assert&lt;/code&gt; failures are directed to the C runtime library</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fa92f6e99c1b6ea8acd4d7c57031128038c6661d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;auto&lt;/code&gt; Attribute</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cbe5e5a31e6057e02bc7e46eae1f3fee6b097927" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;ax&lt;/code&gt; and &lt;code&gt;bx&lt;/code&gt; shall be finite reals.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="785b2818320935ab9035e9ed41b00039824ad4ba" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;b !is null&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt; must have been allocated with this allocator.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9d8ade1d9189252415ea271c17ad1402ce7018c2" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;b is null&lt;/code&gt;. This is because there is no other possible legitimate input.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9b3bbb98cab24e06860664bbf90aad4fd5a0f595" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;b.opCmp(a)&lt;/code&gt;&lt;code&gt;&amp;gt;&lt;/code&gt;&lt;code&gt;0&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;b.opCmp(a)&lt;/code&gt;&lt;code&gt;&amp;gt;&lt;/code&gt;&lt;code&gt;0&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="29bcab357223ee6c8c5f67694f47a5d3c9e64fff" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;b.opCmp(a)&lt;/code&gt;&lt;code&gt;&amp;gt;&lt;/code&gt;&lt;code&gt;= 0&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="593c76dfe41796a74b9d56ecfa87752e9ea806a7" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;b.opCmp(a)&lt;/code&gt;&lt;code&gt;&amp;lt;&lt;/code&gt;&lt;code&gt;0&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;b.opCmp(a)&lt;/code&gt;&lt;code&gt;&amp;lt;&lt;/code&gt;&lt;code&gt;0&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="80e0464eea74b423d0de6d015b3d002ecf879c9b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;b.opCmp(a)&lt;/code&gt;&lt;code&gt;&amp;lt;&lt;/code&gt;&lt;code&gt;= 0&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b75c3b04355d5b293310910e92a79197b5586c14" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;b&lt;/code&gt; has been allocated with this allocator, or is &lt;code&gt; null&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6fc256c493430315b6eed935052cb72d6e6aef3e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;balancedParens(&quot;((1 + 1) / 2)&quot;)&lt;/code&gt; returns &lt;code&gt;true&lt;/code&gt; because the string has balanced parentheses.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="67d7a26d3b5511855f2e0c34eb245328c333d854" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;bool&lt;/code&gt;s are formatted as &lt;code&gt;&quot;true&quot;&lt;/code&gt; or &lt;code&gt;&quot;false&quot;&lt;/code&gt; with &lt;code&gt;%s&lt;/code&gt; and as &lt;code&gt;1&lt;/code&gt; or &lt;code&gt;0&lt;/code&gt; with integral-specific format specs.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aec8b12c63c29d1b55fc273193e84c10d1c29428" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;break&lt;/code&gt; exits the innermost enclosing while, for, foreach, do, or switch statement, resuming execution at the statement following it.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ad7d5b04e91ed51a96a115cccedf9bf33d34abd4" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;bringToFront&lt;/code&gt; takes two ranges &lt;code&gt;front&lt;/code&gt; and &lt;code&gt;back&lt;/code&gt;, which may be of different types. Considering the concatenation of &lt;code&gt;front&lt;/code&gt; and &lt;code&gt;back&lt;/code&gt; one unified range, &lt;code&gt;bringToFront&lt;/code&gt; rotates that unified range such that all elements in &lt;code&gt;back&lt;/code&gt; are brought to the beginning of the unified range. The relative ordering of elements in &lt;code&gt;front&lt;/code&gt; and &lt;code&gt;back&lt;/code&gt;, respectively, remains unchanged.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="927abef211407b2f445dd66eacc6dd89aa442eb2" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;byChunk(&quot;dlang.org&quot;, 10)&lt;/code&gt; returns a range of ubyte[10] containing the dlang.org web page.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="63eabee68fef61a3ee33534d563febf1004d637d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;byChunkAsync(&quot;dlang.org&quot;, 10)&lt;/code&gt; returns a range of ubyte[10] containing the dlang.org web page asynchronously.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e07e59b1a940539cf55688cd2653347c4d8fe2d0" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;byCodeUnit&lt;/code&gt; does no Unicode decoding</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e7bacd8ab0219c831357aa6d37c67a75166cc2af" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;byCodeUnit&lt;/code&gt; exposes a &lt;code&gt;source&lt;/code&gt; property when wrapping narrow strings.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="09c9aa4121d7ea220de3b1140939386f7ed28379" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;byLine(&quot;dlang.org&quot;)&lt;/code&gt; returns a range of char[] containing the dlang.org web page.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="51878799bbf07b2664da8a52401f39df0b2ac581" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;byLineAsync(&quot;dlang.org&quot;)&lt;/code&gt; returns a range of char[] containing the dlang.org web page asynchronously.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="304cd505e182bc2c4f64cc2e2693038a437eeb75" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;cache&lt;/code&gt; does not provide random access primitives, as &lt;code&gt;cache&lt;/code&gt; would be unable to cache the random accesses. If &lt;code&gt;Range&lt;/code&gt; provides slicing primitives, then &lt;code&gt;cache&lt;/code&gt; will provide the same slicing primitives, but &lt;code&gt;hasSlicing!Cache&lt;/code&gt; will not yield true (as the &lt;a href=&quot;std_range_primitives#hasSlicing&quot;&gt;&lt;code&gt;std.range.primitives.hasSlicing&lt;/code&gt;&lt;/a&gt; trait also checks for random access).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f606f9f15aaebf711d9bba631df12df0a788678b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;cache&lt;/code&gt; eagerly evaluates &lt;a href=&quot;std_range_primitives#front&quot;&gt;front&lt;/a&gt; of &lt;code&gt;range&lt;/code&gt; on each construction or call to &lt;a href=&quot;std_range_primitives#popFront&quot;&gt;popFront&lt;/a&gt;, to store the result in a cache. The result is then directly returned when &lt;a href=&quot;std_range_primitives#front&quot;&gt;front&lt;/a&gt; is called, rather than re-evaluated.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e14e0b9f44b3e89356c7590fdf0f91e4eeaa0a59" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;cache&lt;/code&gt; may provide &lt;a href=&quot;std_range_primitives#isBidirectionalRange&quot;&gt;bidirectional range&lt;/a&gt; iteration if needed, but since this comes at an increased cost, it must be explicitly requested via the call to &lt;code&gt;cacheBidirectional&lt;/code&gt;. Furthermore, a bidirectional cache will evaluate the &quot;center&quot; element twice, when there is only one element left in the range.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="410f8af0117e2ba07fd5bc8bff4390d619dd775a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;canFind(&quot;hello world&quot;, &quot;or&quot;)&lt;/code&gt; returns &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ff2c61cde18123e357fe1a8f2663dce97f508b69" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;cast()&lt;/code&gt; and &lt;code&gt;cast(&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="60ae09af485be0ac7cd9b6f70f585c2dbee91ecd" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;cast(U)&lt;/code&gt; expressions applied to lvalues of type &lt;code&gt;T&lt;/code&gt; when &lt;code&gt;T*&lt;/code&gt; is implicitly convertible to &lt;code&gt;U*&lt;/code&gt;;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b89b8e9c45bb4feabdacbf66c526326b90e2d994" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;castSwitch&lt;/code&gt; can only be used with object types.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3d916f0dc7c1e1eec21981dac40ca5db26d4906f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;char&lt;/code&gt; (chars are unsigned in D)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fb295624198dc0f8123396e13dc59dba2a6dfa32" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;char&lt;/code&gt;, &lt;code&gt;wchar&lt;/code&gt;, &lt;code&gt;dchar&lt;/code&gt; to a string type.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c8e47cbd8e35276af4679f6e7b5bda73ed1d9d62" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;char&lt;/code&gt;, &lt;code&gt;wchar&lt;/code&gt;, or &lt;code&gt;dchar&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3e2a921f6a1d6d0ef8009fc307e0b2d445b1297e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;char[]&lt;/code&gt; strings are in UTF-8 format. &lt;code&gt;wchar[]&lt;/code&gt; strings are in UTF-16 format. &lt;code&gt;dchar[]&lt;/code&gt; strings are in UTF-32 format.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f2bd0519659f995011158dca0a093bc2a43687cf" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;choices&lt;/code&gt; needs to be composed of pairs of test expressions and return expressions. Each test-expression is compared with &lt;code&gt;switchExpression&lt;/code&gt; using &lt;code&gt;pred&lt;/code&gt;(&lt;code&gt;switchExpression&lt;/code&gt; is the first argument) and if that yields true - the return expression is returned.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ce5b206c240b5efd37495766481c140fd6dd85f8" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;chooseAtRuntime&lt;/code&gt; is a compile-time constant of type &lt;code&gt;size_t&lt;/code&gt; that several parameterized structures in this module recognize to mean deferral to runtime of the exact value. For example, &lt;code&gt;BitmappedBlock!(Allocator, 4096)&lt;/code&gt; (described in detail below) defines a block allocator with block size of 4096 bytes, whereas &lt;code&gt;BitmappedBlock!(Allocator, chooseAtRuntime)&lt;/code&gt; defines a block allocator that has a field storing the block size, initialized by the user.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4566f06b914a580f926d5a0099020d085b440b14" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;chunk&lt;/code&gt; must be at least as large as &lt;code&gt;T&lt;/code&gt; needs and should have an alignment multiple of &lt;code&gt;T&lt;/code&gt;'s alignment.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="455127cdf62cc10f2c9d34b7dba0f57d384c5937" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;chunk&lt;/code&gt; must be at least as large as &lt;code&gt;T&lt;/code&gt; needs and should have an alignment multiple of &lt;code&gt;T&lt;/code&gt;'s alignment. (The size of a &lt;code&gt;class&lt;/code&gt; instance is obtained by using &lt;code&gt;_traits(classInstanceSize, T)&lt;/code&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5bf1191081aa876778470c09b21f3b6c55852ee1" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;chunkBy!((a,b) =&amp;gt; a[1] == b[1])([[1, 1], [1, 2], [2, 2], [2, 1]])&lt;/code&gt; returns a range containing 3 subranges: the first with just &lt;code&gt;[1, 1]&lt;/code&gt;; the second with the elements &lt;code&gt;[1, 2]&lt;/code&gt; and &lt;code&gt;[2, 2]&lt;/code&gt;; and the third with just &lt;code&gt;[2, 1]&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6b9a3a8566809a020c68aaea90acac74e5efb03e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;chunkCount&lt;/code&gt; must not be zero, unless &lt;code&gt;source&lt;/code&gt; is also empty.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e4fa67ca853568548d80d9ea722ce341af284387" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;clamp(1, 3, 6)&lt;/code&gt; returns &lt;code&gt;3&lt;/code&gt;. &lt;code&gt;clamp(4, 3, 6)&lt;/code&gt; returns &lt;code&gt;4&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0e931bbc6e887a57f25ca3ea62a185b1d52c88ae" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;cmp(&quot;abc&quot;, &quot;abcd&quot;)&lt;/code&gt; is &lt;code&gt;-1&lt;/code&gt;, &lt;code&gt;cmp(&quot;abc&quot;, &quot;aba&quot;)&lt;/code&gt; is &lt;code&gt;1&lt;/code&gt;, and &lt;code&gt;cmp(&quot;abc&quot;, &quot;abc&quot;)&lt;/code&gt; is &lt;code&gt;0&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="35e6384e8ce379e258f83b09389948c49d161e83" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;commonPrefix(&quot;parakeet&quot;, &quot;parachute&quot;)&lt;/code&gt; returns &lt;code&gt;&quot;para&quot;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="df5d8088e316cfde0b98978a7ef3c894646eb3bd" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;const&lt;/code&gt; (= c)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="93ad55dd726f30a8bd9799af2132fb43bcfaf1f7" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;const&lt;/code&gt; Attribute</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b0a59a87faddcc9b5e518c4dc18b7892c90c80c1" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;const&lt;/code&gt; applies to data that cannot be changed by the const reference to that data. It may, however, be changed by another reference to that same data. Const finds applications in passing data through interfaces that promise not to modify them.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4d9a6e876791ac6f810114009c11949947079c7f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;const&lt;/code&gt; keyword</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e4ba079ff031a5bee8e6a39743aec55c4c5aff36" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;const&lt;/code&gt;, &lt;code&gt;immutable&lt;/code&gt;, &lt;code&gt;inout&lt;/code&gt;, &lt;code&gt;shared&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a3bf9d93abb5e5cd019144ad24a88a584006df22" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;const&lt;/code&gt;. When a postblit is qualified with &lt;code&gt;const&lt;/code&gt; as in &lt;code&gt;this(this) const;&lt;/code&gt; or &lt;code&gt;const this(this);&lt;/code&gt; then the postblit is succesfully called on mutable (unqualified), &lt;code&gt;const&lt;/code&gt;, and &lt;code&gt;immutable&lt;/code&gt; objects, but the postblit cannot modify the object because it regards it as &lt;code&gt;const&lt;/code&gt;; hence &lt;code&gt;const&lt;/code&gt; postblits are of limited usefulness. Example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cc47342e29e943cc96416253c9cc4dfa61c2b6da" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;continue&lt;/code&gt; aborts the current iteration of its enclosing loop statement, and starts the next iteration.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f55d3c51867037260ee7b3bb73eed621d681d3b9" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;coshisinh&lt;/code&gt; is included here for convenience and for easy migration of code that uses &lt;a href=&quot;std_math#coshisinh&quot;&gt;&lt;code&gt;std.math.coshisinh&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8e42ad99a10dd7cd20a1b4ee231d4706ca8c339d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;countUntil(a, b)&lt;/code&gt; returns the number of steps taken in &lt;code&gt;a&lt;/code&gt; to reach &lt;code&gt;b&lt;/code&gt;; for example, &lt;code&gt;countUntil(&quot;hello!&quot;, &quot;o&quot;)&lt;/code&gt; returns &lt;code&gt;4&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c628f95698b35b08f15cc1f377f06aeb25415331" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;cumulativeFold!((a, b) =&amp;gt; a + b)([1, 2, 3, 4])&lt;/code&gt; returns a lazily-evaluated range containing the successive reduced values &lt;code&gt;1&lt;/code&gt;, &lt;code&gt;3&lt;/code&gt;, &lt;code&gt;6&lt;/code&gt;, &lt;code&gt;10&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0b182a1591e1ea15b6088bb533ef38a0b3dfe450" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;deallocate&lt;/code&gt; is also supported, which is where most implementation effort and overhead of &lt;code&gt;ScopedAllocator&lt;/code&gt; go. If &lt;code&gt;deallocate&lt;/code&gt; is not needed, a simpler design combining &lt;code&gt;AllocatorList&lt;/code&gt; with &lt;code&gt;Region&lt;/code&gt; is recommended.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c3a273cc82ac96180bffd6bc28ee735da5c11187" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;deallocate&lt;/code&gt; is defined if and only if at least one of the allocators define &lt;code&gt;deallocate&lt;/code&gt;. It works as follows. If &lt;code&gt;primary.owns(b)&lt;/code&gt;, then the request is forwarded to &lt;code&gt;primary.deallocate&lt;/code&gt; if it is defined, or is a no-op otherwise. If &lt;code&gt;primary&lt;/code&gt; does not own &lt;code&gt;b&lt;/code&gt;, then the request is forwarded to &lt;code&gt;fallback.deallocate&lt;/code&gt; if it is defined, or is a no-op otherwise.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="74accc0b79c91cd3ea11df6f90b09a6dd01837e0" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;decodeBack&lt;/code&gt; is a variant of &lt;a href=&quot;#decode&quot;&gt;&lt;code&gt;decode&lt;/code&gt;&lt;/a&gt; which specifically decodes the last code point. Unlike &lt;a href=&quot;#decode&quot;&gt;&lt;code&gt;decode&lt;/code&gt;&lt;/a&gt;, &lt;code&gt;decodeBack&lt;/code&gt; accepts any bidirectional range of code units (rather than just a string or random access range). It also takes the range by &lt;code&gt;ref&lt;/code&gt; and pops off the elements as it decodes them. If &lt;code&gt;numCodeUnits&lt;/code&gt; is passed in, it gets set to the number of code units which were in the code point which was decoded.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="67288590e0efb2949e43eabd6c7c73a4328806ba" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;decodeFront&lt;/code&gt; is a variant of &lt;a href=&quot;#decode&quot;&gt;&lt;code&gt;decode&lt;/code&gt;&lt;/a&gt; which specifically decodes the first code point. Unlike &lt;a href=&quot;#decode&quot;&gt;&lt;code&gt;decode&lt;/code&gt;&lt;/a&gt;, &lt;code&gt;decodeFront&lt;/code&gt; accepts any &lt;a href=&quot;std_range_primitives#isInputRange&quot;&gt;input range&lt;/a&gt; of code units (rather than just a string or random access range). It also takes the range by &lt;code&gt;ref&lt;/code&gt; and pops off the elements as it decodes them. If &lt;code&gt;numCodeUnits&lt;/code&gt; is passed in, it gets set to the number of code units which were in the code point which was decoded.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a8839f0e531d17486dee499042f1d0072c16f817" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;delimiter&lt;/code&gt;, then it is returned unchanged.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c3ad863d355559bfb72ddf6d9a50a94c65161a75" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;deprecate&lt;/code&gt; This functions just like &lt;code&gt;abort&lt;/code&gt;, but upon cycle detection the runtime will use a flawed pre-2.072 algorithm to determine if the cycle was previously detected. If no cycles are detected in the old algorithm, execution continues, but a deprecation message is printed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d18f1ba74723b3d893b7f7c2730705de22bb0d19" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;deprecated&lt;/code&gt; Attribute</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6805fd5312efcc0ca879f765f2e0c19218cf93e1" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;dg&lt;/code&gt; - custom delegate that return a string and is only called if an exception occurred</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3f6badc39b215958c8978f7765441eb5e2a2f607" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;double.init&lt;/code&gt; if &lt;code&gt;lhs == WitnNaN.defaultValue!Lhs&lt;/code&gt;, &lt;code&gt;-1.0&lt;/code&gt; if &lt;code&gt; lhs &amp;lt; rhs&lt;/code&gt;, &lt;code&gt;0.0&lt;/code&gt; if &lt;code&gt;lhs == rhs&lt;/code&gt;, &lt;code&gt;1.0&lt;/code&gt; if &lt;code&gt;lhs &amp;gt; rhs&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d6287d5a0a715e9fe34f9a5e926b06c464979322" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;download(&quot;ftp.digitalmars.com/sieve.ds&quot;, &quot;/tmp/downloaded-ftp-file&quot;)&lt;/code&gt; downloads file from URL to file system.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ae45f410eafadc75e7784e0049dfaa9348862102" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;drop&lt;/code&gt; and &lt;code&gt;dropBack&lt;/code&gt; will only pop</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="92678e10b01739e363a145cad7231efe25dc368f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;dropBack&lt;/code&gt; provides the same functionality but instead calls &lt;a href=&quot;std_range_primitives#popBackN&quot;&gt;&lt;code&gt;std.range.primitives.popBackN&lt;/code&gt;&lt;/a&gt;&lt;code&gt;(range, n)&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b3dfad69b0fc743d45dfe5be856a302f4f3b612f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;dropBackOne&lt;/code&gt; provides the same functionality but instead calls &lt;code&gt;range.popBack()&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3cad355e345c645ef7c2bc148a0241cff87d3380" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;dur!&quot;msecs&quot;(5)&lt;/code&gt; or &lt;code&gt;5.msecs()&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c772ef4b91d8eb5af7e6be3a8a3eaa78551b8465" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;duration.&lt;/code&gt;&lt;a href=&quot;std_conv#to&quot;&gt;&lt;code&gt;to&lt;/code&gt;&lt;/a&gt;&lt;code&gt;!TickDuration()&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;duration.&lt;/code&gt;&lt;a href=&quot;std_conv#to&quot;&gt;&lt;code&gt;to&lt;/code&gt;&lt;/a&gt;&lt;code&gt;!TickDuration()&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="d36e7aa6c21b2266b972c062e2002da654f12f35" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;e.sizeof&lt;/code&gt; gives the size in bytes of the expression &lt;code&gt;e&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1ddf110e0236e48f69127ea061fd64414c28dbfa" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;e&lt;/code&gt; is an lvalue, and keep it as an lvalue since it is an argument to a &lt;code&gt;ref&lt;/code&gt; or &lt;code&gt;out&lt;/code&gt; parameter, or the operand of &lt;code&gt;&amp;amp;&lt;/code&gt; operator</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="63a03c99efc9c30d70d73137984321acf547459a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;e&lt;/code&gt; must be semantically valid expression. In other words, it should not contain any &lt;code&gt;ErrorExp&lt;/code&gt;s in it. But, CTFE interpretation will cross over functions and may invoke a function that contains &lt;code&gt;ErrorStatement&lt;/code&gt; in its body. If that, the &quot;CTFE failed because of previous errors&quot; error is raised.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ea2dad0d2c560452981a079bdac2e97b675022d1" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;each!writeln([1, 2, 3])&lt;/code&gt; eagerly prints the numbers &lt;code&gt;1&lt;/code&gt;, &lt;code&gt;2&lt;/code&gt; and &lt;code&gt;3&lt;/code&gt; on their own lines.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="53d24af0626c7733c499592c9ff5e9fdd21ecce3" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;each&lt;/code&gt; also supports &lt;code&gt;opApply&lt;/code&gt;-based types, so it works with e.g. &lt;a href=&quot;std_parallelism#parallel&quot;&gt;&lt;code&gt;std.parallelism.parallel&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="931465da1e8dfbf1b466d2cd0faeeaffaad9464a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;each&lt;/code&gt; works with iterable objects which provide an index variable, along with each element</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d01f390bdbeb84b4919e65d81c8a05dd73291482" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;empty&lt;/code&gt; is defined if both allocators also define it.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="04ffa2fab19caa7316bc21ce23c836375fc7e74f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;endsWith(&quot;rocks&quot;, &quot;ks&quot;)&lt;/code&gt; returns &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="039258fd2a7b4225b13e358a4b74a589a22f1909" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;enforce&lt;/code&gt; is used to throw exceptions and is therefore intended to aid in error handling. It is</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8fafbf8d3403f46d7862dbd4e094c44bc49345fd" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;enum&lt;/code&gt;s are formatted like their base value</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="32d81ab5c5f77a48742ebf127f581f59d3e8d4ae" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;etc.c.odbc.sql&lt;/code&gt; is the the main include for ODBC v3.0+ Core functions, corresponding to the &lt;code&gt;sql.h&lt;/code&gt; C header file. It &lt;code&gt;import&lt;/code&gt;s &lt;code&gt;public&lt;/code&gt;ly &lt;code&gt;etc.c.odbc.sqltypes&lt;/code&gt; for conformity with the C header.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="493dd95c88ebdea7f9d7904c3fee52bfa826a845" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;etc.c.odbc.sqlext.d&lt;/code&gt; corresponds to the &lt;code&gt;sqlext.h&lt;/code&gt; C header file.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="486a71d42d523c21eb5f4c5e3cefa083fc33dd21" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;etc.c.odbc.sqlext&lt;/code&gt; corresponds to the &lt;code&gt;sqlext.h&lt;/code&gt; C header file.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="91b33b7c7cdf5a354414e128e0689849615d7b78" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;etc.c.odbc.sqlucode&lt;/code&gt; corresponds to the &lt;code&gt;sqlucode.h&lt;/code&gt; C include file.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="454779ffb1ce2972a948b6bf53de77b10d82170e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;ethis2&lt;/code&gt; if successful, null otherwise</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8e284d610007241b05a4495262aca884af842da3" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;ex&lt;/code&gt; - custom exception to be thrown. It is &lt;code&gt;lazy&lt;/code&gt; and is only created if an exception occurred</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9005151b0602951785e8ba2fbc90642894270124" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;execute&lt;/code&gt; and &lt;code&gt;executeShell&lt;/code&gt; start a new process using &lt;a href=&quot;#spawnProcess&quot;&gt;&lt;code&gt;spawnProcess&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#spawnShell&quot;&gt;&lt;code&gt;spawnShell&lt;/code&gt;&lt;/a&gt;, respectively, and wait for the process to complete before returning. The functions capture what the child process prints to both its standard output and standard error streams, and return this together with its exit code.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="25a408e63ee5fdc008f0667d1e3f2484f161de72" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;expand&lt;/code&gt; is defined if and only if at least one of the allocators defines &lt;code&gt;expand&lt;/code&gt;. It works as follows. If &lt;code&gt;primary.owns(b)&lt;/code&gt;, then the request is forwarded to &lt;code&gt;primary.expand&lt;/code&gt; if it is defined, or fails (returning &lt;code&gt;false&lt;/code&gt;) otherwise. If &lt;code&gt;primary&lt;/code&gt; does not own &lt;code&gt;b&lt;/code&gt;, then the request is forwarded to &lt;code&gt;fallback.expand&lt;/code&gt; if it is defined, or fails (returning &lt;code&gt;false&lt;/code&gt;) otherwise.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a03fad7c1bd9e067282b6a7ecbfb7d33e094a76a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;expand&lt;/code&gt; is defined to forward to &lt;code&gt;ParentAllocator.expand&lt;/code&gt; (it must be also &lt;code&gt;shared&lt;/code&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="47816e4a2ec9a59899e059a111251af1df09db1a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;expi&lt;/code&gt; is included here for convenience and for easy migration of code that uses &lt;a href=&quot;std_math#expi&quot;&gt;&lt;code&gt;std.math.expi&lt;/code&gt;&lt;/a&gt;. Unlike &lt;a href=&quot;std_math#expi&quot;&gt;&lt;code&gt;std.math.expi&lt;/code&gt;&lt;/a&gt;, which uses the x87</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a666fac0e544127bb5b87071b0c4108b7442235d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;export&lt;/code&gt; means that any code outside the executable can access the member. &lt;code&gt;export&lt;/code&gt; is analogous to exporting definitions from a DLL.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="33ba0fa9a8ac23d86d958946a9de87c65b515928" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;extern (C++)&lt;/code&gt; class</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ca577828af2e02c109ac54927bd1b37db6478559" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;extern (C++)&lt;/code&gt; interface</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="574b3c7b37c3e1a7f05898210e2609d55a7c9966" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;extern (C++)&lt;/code&gt; struct</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="305317a6dc1998948f72a8a8641a7ab92acd7d65" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;extern (C++)&lt;/code&gt; structs do not support virtual functions but can be used to map C++ value types.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4a7ada48bd1641fc57878ac99f8bcffbe1293181" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;extern(C++, class)&lt;/code&gt; and &lt;code&gt;extern(C++, struct)&lt;/code&gt; can be combined with C++ namespaces:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d25d14d0478f1342bfec27af6b28e317ef69344e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;far ptr&lt;/code&gt; is not relevant for flat model code.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="110d7c73996e6e69d6712009dfbc60270710cca8" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;filename&lt;/code&gt; may not end with a space (&lt;code&gt;' '&lt;/code&gt;) or a period (&lt;code&gt;'.'&lt;/code&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d6462d8d6673fc8802f5508b14756158d5b1d44d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;filename&lt;/code&gt; must not contain any characters whose integer representation is in the range 0-31.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4bc53882af8209667748fb8ea2bac1b8f7a1d6a4" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;filename&lt;/code&gt; must not contain any of the following</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3e6b6d43bf7966ade005e73afc8d7220b233e99c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;filter!(a =&amp;gt; a &amp;gt; 0)([1, -1, 2, 0, -3])&lt;/code&gt; iterates over elements &lt;code&gt;1&lt;/code&gt; and &lt;code&gt;2&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d65e8f52696c79f08f41c7e99ceb95631c8309a4" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;filter!(predicate)(range)&lt;/code&gt; returns a new range containing only elements &lt;code&gt;x&lt;/code&gt; in &lt;code&gt;range&lt;/code&gt; for which &lt;code&gt;predicate(x)&lt;/code&gt; returns &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="59d9557c846c7dfb5f62fc519414fe5786287fd1" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;find(&quot;hello world&quot;, &quot;or&quot;)&lt;/code&gt; returns &lt;code&gt;&quot;orld&quot;&lt;/code&gt; using linear search. (For binary search refer to &lt;a href=&quot;std_range#SortedRange&quot;&gt;&lt;code&gt;std.range.SortedRange&lt;/code&gt;&lt;/a&gt;.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="463012de765d32105b8129513c2f76e386958d86" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;find(&quot;hello world&quot;, boyerMooreFinder(&quot;or&quot;))&lt;/code&gt; returns &lt;code&gt;&quot;orld&quot;&lt;/code&gt; using the &lt;a href=&quot;https://en.wikipedia.org/wiki/Boyer%E2%80%93Moore_string_search_algorithm&quot;&gt; Boyer-Moore algorithm&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aceb824dc701623af00fdfc39b0050aa1cc5ca45" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;find&lt;/code&gt; behaves similar to &lt;code&gt;dropWhile&lt;/code&gt; in other languages.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5b74ba9237918431c22bb8a7b4f43c4a503d1135" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;find&lt;/code&gt; performs &amp;Omicron;(&lt;code&gt;walkLength(haystack)&lt;/code&gt;) evaluations of &lt;code&gt;pred&lt;/code&gt;. There are specializations that improve performance by taking advantage of &lt;a href=&quot;std_range_primitives#isBidirectionalRange&quot;&gt;bidirectional&lt;/a&gt; or &lt;a href=&quot;std_range_primitives#isRandomAccess&quot;&gt;random access&lt;/a&gt; ranges (where possible).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3a741cc4590b1272b88f9debbbf9dcbe5bc2eb5c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;findAdjacent([1, 2, 3, 3, 4])&lt;/code&gt; returns the subrange starting with two equal adjacent elements, i.e. &lt;code&gt;[3, 3, 4]&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4954a80a8d1e2b0bd00aa0e1771015ac0a0a59b1" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;findAmong(&quot;abcd&quot;, &quot;qcx&quot;)&lt;/code&gt; returns &lt;code&gt;&quot;cd&quot;&lt;/code&gt; because &lt;code&gt;'c'&lt;/code&gt; is among &lt;code&gt;&quot;qcx&quot;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="16451c18369e0d82460ebf3cbe0f6d69e643b0d1" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;findSplit(&quot;abcdefg&quot;, &quot;de&quot;)&lt;/code&gt; returns the three ranges &lt;code&gt;&quot;abc&quot;&lt;/code&gt;, &lt;code&gt;&quot;de&quot;&lt;/code&gt;, and &lt;code&gt;&quot;fg&quot;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="25c36cb151505618abe7889bcca004fa70004ac9" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;findSplit&lt;/code&gt; returns a tuple &lt;code&gt;result&lt;/code&gt; containing</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dea2a901faeede8850674e82df6d24827cef5045" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;findSplitAfter(&quot;abcdefg&quot;, &quot;de&quot;)&lt;/code&gt; returns the two ranges &lt;code&gt;&quot;abcde&quot;&lt;/code&gt; and &lt;code&gt;&quot;fg&quot;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7a5a332327a9e6ea3836154ccab37e65fe922147" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;findSplitAfter&lt;/code&gt; returns a tuple &lt;code&gt;result&lt;/code&gt; containing two ranges. &lt;code&gt;result[0]&lt;/code&gt; is the portion of &lt;code&gt;haystack&lt;/code&gt; up to and including the match, and &lt;code&gt;result[1]&lt;/code&gt; is the balance of &lt;code&gt;haystack&lt;/code&gt; starting after the match. If &lt;code&gt;needle&lt;/code&gt; was not found, &lt;code&gt;result[0]&lt;/code&gt; is empty and &lt;code&gt;result[1]&lt;/code&gt; is &lt;code&gt;haystack&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dbd528c44f7da153b86040e16bf3eb34ac8884af" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;findSplitBefore(&quot;abcdefg&quot;, &quot;de&quot;)&lt;/code&gt; returns the two ranges &lt;code&gt;&quot;abc&quot;&lt;/code&gt; and &lt;code&gt;&quot;defg&quot;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8aa1b48a6404736eb0e5593fc1439a4e0704881d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;findSplitBefore&lt;/code&gt; returns a tuple &lt;code&gt;result&lt;/code&gt; containing two ranges. &lt;code&gt;result[0]&lt;/code&gt; is the portion of &lt;code&gt;haystack&lt;/code&gt; before &lt;code&gt;needle&lt;/code&gt;, and &lt;code&gt;result[1]&lt;/code&gt; is the balance of &lt;code&gt;haystack&lt;/code&gt; starting with the match. If &lt;code&gt;needle&lt;/code&gt; was not found, &lt;code&gt;result[0]&lt;/code&gt; comprehends &lt;code&gt;haystack&lt;/code&gt; entirely and &lt;code&gt;result[1]&lt;/code&gt; is empty.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2a17297b469e0d45acc481afe01915097c421c8b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;fold!((a, b) =&amp;gt; a + b)([1, 2, 3, 4])&lt;/code&gt; returns &lt;code&gt;10&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="348e97cd2ed7107060d1b3285fa4dbc81dd2cffb" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;fold&lt;/code&gt; is functionally equivalent to &lt;a href=&quot;#reduce&quot;&gt;&lt;code&gt;reduce&lt;/code&gt;&lt;/a&gt; except the range parameter comes first and there is no need to use &lt;a href=&quot;std_typecons#tuple&quot;&gt; &lt;code&gt;tuple&lt;/code&gt;&lt;/a&gt; for multiple seeds.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1c5d9f4eccff4639d1f58c3663f02fcb0724c0e2" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;foreach&lt;/code&gt; iteration uses opApply, since one delegate call per loop iteration is faster than three virtual function calls.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="110a86b489c1c1a0ba5523c061f671f89d25d3ce" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;forwardMsg&lt;/code&gt; will ensure proper synchronization and then call &lt;code&gt;writeLogMsg&lt;/code&gt;. This is an API for implementing your own loggers and should not be called by normal user code. A notable difference from other logging functions is that the &lt;code&gt;globalLogLevel&lt;/code&gt; wont be evaluated again since it is assumed that the caller already checked that.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d65fa22650a0b8a3eb196a6250ab4fff48eaa821" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;from&lt;/code&gt; reinterpreted as &lt;code&gt;TTo[]&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c0a306783b5406bdc03554e654b13fe88160475b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;fun(t.get).nullable&lt;/code&gt; if &lt;code&gt;!t.isNull&lt;/code&gt;, else &lt;code&gt;Nullable.init&lt;/code&gt;.  See also: &lt;a href=&quot;https://en.wikipedia.org/wiki/Monad_(functional_programming)#The_Maybe_monad&quot;&gt;The &lt;code&gt;Maybe&lt;/code&gt; monad&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a038dd88a5733c8b2a2fa8c9ddcfa7967abb774f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;fun&lt;/code&gt; must be @safe or @trusted.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9b954ea7606d866416b11b50a60545717b5a9a21" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;fun&lt;/code&gt; must not return by reference.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="47805b817580eb31fc0ac75d4b6cb18c9ae0d5b1" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;func&lt;/code&gt; takes a template parameter &lt;code&gt;T&lt;/code&gt; and a runtime parameter, &lt;code&gt;x&lt;/code&gt;. &lt;code&gt;T&lt;/code&gt; is a placeholder identifier that can accept any type. In this case &lt;code&gt;T&lt;/code&gt; can be inferred from the runtime argument type.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a5a1dd63a3ea288980aa5f1118ceb9e3611d769f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;gapWeightedSimilarity&lt;/code&gt; is useful wherever a smooth similarity measure between sequences allowing for approximate matches is needed. The examples above are given with words, but any sequences with elements comparable for equality are allowed, e.g. characters or numbers. &lt;code&gt;gapWeightedSimilarity&lt;/code&gt; uses a highly optimized dynamic programming implementation that needs &lt;code&gt;16 * min(s.length, t.length)&lt;/code&gt; extra bytes of memory and &amp;Omicron;(&lt;code&gt;s.length * t.length&lt;/code&gt;) time to complete.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3959a0b351f7ec8406be31ce94953a1866110474" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;get(&quot;dlang.org&quot;)&lt;/code&gt; returns a char[] containing the dlang.org web page.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5e9e6f3319f03a2f023ac7b33c656ba598442179" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;goto&lt;/code&gt; transfers to the statement labeled with</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="efdd57ae0124db505495be1ff22bae5b4ccb4fad" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;group([5, 2, 2, 3, 3])&lt;/code&gt; returns a range containing the tuples &lt;code&gt;tuple(5, 1)&lt;/code&gt;, &lt;code&gt;tuple(2, 2)&lt;/code&gt;, and &lt;code&gt;tuple(3, 2)&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="06dafad0eef61a654d008ef7ea92cffe8261aeee" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;haystack&lt;/code&gt; advanced such that &lt;code&gt;needle&lt;/code&gt; is a prefix of it (if no such position exists, returns &lt;code&gt;haystack&lt;/code&gt; advanced to termination).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1342092e3ae92bd56e1008e1700f839172dc6d62" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;haystack&lt;/code&gt; advanced such that the front element is the one searched for; that is, until &lt;code&gt;binaryFun!pred(haystack.front, needle)&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;. If no such position exists, returns an empty &lt;code&gt;haystack&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3a7709f5444c09b2db5958f871fde3a58239214d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;helpWanted&lt;/code&gt; is set if the option &lt;code&gt;--help&lt;/code&gt; or &lt;code&gt;-h&lt;/code&gt; was passed to the option parser.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="90b47fb385002d5be035355df9fcf1c2d63722b3" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;high &amp;gt;= min&lt;/code&gt;, or &lt;code&gt;minSize == chooseAtRuntime&lt;/code&gt; and &lt;code&gt;min&lt;/code&gt; has not yet been initialized. Also &lt;code&gt;high &amp;gt;= (void*).sizeof&lt;/code&gt;. Also, no allocation has been yet done with this allocator.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0aa929a94bde73d993953027e9e45983b2a25faf" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;hook&lt;/code&gt; is a member variable if it has state, or an alias for &lt;code&gt;Hook&lt;/code&gt; otherwise.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e30039c28096c73c13dc10d17a63e8d65082ed94" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;ignore&lt;/code&gt; Do not abort execution or print any cycles. When cycles are present, order of static construction is implementation defined, and not guaranteed to be valid.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2900fa2143c8a9554a50e42157ae7de4e9a10d57" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;immutable&lt;/code&gt; (= i)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="71481ed3d36e92db19dd7c5a87a5f2c82034d7cb" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;immutable&lt;/code&gt; Attribute</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4492f625b3c03c9e03748ad120820e2cb2e70cc8" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;immutable&lt;/code&gt; applies to data that cannot change. Immutable data values, once constructed, remain the same for the duration of the program's execution. Immutable data can be placed in ROM (Read Only Memory) or in memory pages marked by the hardware as read only. Since immutable data does not change, it enables many opportunities for program optimization, and has applications in functional style programming.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="436d66a299b3ac0c65e6f16abd43ab92f216596e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;immutable&lt;/code&gt; keyword</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c2df067ae666f1bc5a565ba7a7986dc9010e82b8" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;immutable&lt;/code&gt;. When a postblit is qualified with &lt;code&gt;immutable&lt;/code&gt; as in &lt;code&gt;this(this) immutable&lt;/code&gt; or &lt;code&gt;immutable this(this)&lt;/code&gt; the code is ill-formed. The &lt;code&gt;immutable&lt;/code&gt; postblit passes the compilation phase but cannot be invoked. Example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ad0072c6746bc27e24f45537eafcbb149a3d4312" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;in&lt;/code&gt; operator. Check to see if the given element exists in the container.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a9f30f56c33bc12f05c33f96f90e1facd80a129f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;include&lt;/code&gt; can be called multiple times, but a &lt;code&gt;static foreach&lt;/code&gt; should be expanded at most once. Achieved by caching the result of the first call. We need both &lt;code&gt;cached&lt;/code&gt; and &lt;code&gt;cache&lt;/code&gt;, because &lt;code&gt;null&lt;/code&gt; is a valid value for &lt;code&gt;cache&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="44ae195465b408cf88051622b07be00d82f8e415" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;inout const&lt;/code&gt; (= wc)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="550f2068280d8918c09f917242e8703c16af0b11" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;inout ref&lt;/code&gt; parameters imply the &lt;code&gt;return&lt;/code&gt; attribute.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8ff88e48057de7710ee582351fabcc94618d3e37" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;inout&lt;/code&gt; (= w)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="efb4702b3ddeb95b18625f1d83639e13135ca271" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;inout&lt;/code&gt; Attribute</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5081215deaf6187f6bbf3fd090202c23c801d59e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;input&lt;/code&gt; and the returned value will share the same tail (see &lt;a href=&quot;std_array#sameTail&quot;&gt;&lt;code&gt;std.array.sameTail&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dfe4937f2a62392719a9715f9ba67a8b5935be9d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;input&lt;/code&gt; stripped of leading whitespace or characters specified in the second argument.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f7c4a45e70d8feffbee29baa015d55bb36b53552" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;inputPath&lt;/code&gt; with the tilde expanded, or just &lt;code&gt;inputPath&lt;/code&gt; if it could not be expanded. For Windows, &lt;code&gt;expandTilde&lt;/code&gt; merely returns its argument &lt;code&gt;inputPath&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="084278a1724aad084c8a91d99892ec68cf516c2e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;is&lt;/code&gt; and &lt;code&gt;!is&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c6071e4e2b023d8249ec4ccd3e337fffdf3c94c9" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;isAssignable&lt;/code&gt; returns whether both an lvalue and rvalue can be assigned.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="66879705a4dc657173ac2d5753a2cb2b985201d0" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;isNarrowString&lt;/code&gt; to be converted to an array of &lt;code&gt;dchar&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ecb92a876691a04ff916735fdb76c540fac9e376" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;isNull&lt;/code&gt; must be &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c9fe38cab0466125758effcc8010350c52973f9a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;isPartitioned!&quot;a &amp;lt; 0&quot;([-1, -2, 1, 0, 2])&lt;/code&gt; returns &lt;code&gt;true&lt;/code&gt; because the predicate is &lt;code&gt;true&lt;/code&gt; for a portion of the range and &lt;code&gt;false&lt;/code&gt; afterwards.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dddbca49d1d853191ca6e06fd51d81def37636c9" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;isPermutation([1, 2], [2, 1])&lt;/code&gt; returns &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5ede47dcbc7a2deb630d825388c29438f3a2f9bc" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;isSameLength([1, 2, 3], [4, 5, 6])&lt;/code&gt; returns &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="22dbb64f1eb66960d30cdd0d045a91b4bebc460a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;isSorted([1, 1, 2, 3])&lt;/code&gt; returns &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="95020a0d026466773d6e7d2d4a1d82c17a6cdd7d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;isStrictlyMonotonic([1, 1, 2, 3])&lt;/code&gt; returns &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e139cb4c8e4b1cc92d499904e7985ee32759ecff" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;joiner([&quot;hello&quot;, &quot;world!&quot;], &quot;; &quot;)&lt;/code&gt; returns a range that iterates over the characters &lt;code&gt;&quot;hello; world!&quot;&lt;/code&gt;. No new string is created - the existing inputs are iterated.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3e315f86bc48178511e8543de42af5b89ad43fa0" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;levenshteinDistance(&quot;kitten&quot;, &quot;sitting&quot;)&lt;/code&gt; returns &lt;code&gt;3&lt;/code&gt; by using the &lt;a href=&quot;https://en.wikipedia.org/wiki/Levenshtein_distance&quot;&gt; Levenshtein distance algorithm&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9909ab215a345d0b27a717c33e2385edf613ac2f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;levenshteinDistanceAndPath(&quot;kitten&quot;, &quot;sitting&quot;)&lt;/code&gt; returns &lt;code&gt;tuple(3, &quot;snnnsni&quot;)&lt;/code&gt; by using the &lt;a href=&quot;https://en.wikipedia.org/wiki/Levenshtein_distance&quot;&gt; Levenshtein distance algorithm&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="043c4ef9c5504856de8db336671697c62d26de91" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;lhs&lt;/code&gt; and &lt;code&gt;rhs&lt;/code&gt; must be mutable. If &lt;code&gt;T&lt;/code&gt; is a struct or union, then its fields must also all be (recursively) mutable.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4fa27a482d0b37131f1db39d8bafd63dbc0f62a5" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;linearRemove&lt;/code&gt; functions as &lt;code&gt;remove&lt;/code&gt;, but also accepts ranges that are result the of a &lt;code&gt;take&lt;/code&gt; operation. This is a convenient way to remove a fixed amount of elements from the range.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7ee71cc6858f0c96f71361219decb26e2942e05d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;lock&lt;/code&gt;, &lt;code&gt;rep&lt;/code&gt;, &lt;code&gt;repe&lt;/code&gt;, &lt;code&gt;repne&lt;/code&gt;, &lt;code&gt;repnz&lt;/code&gt;, &lt;code&gt;repz&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0608ab6000f01a8274d98d95b81bd6b9a45d923b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;long&lt;/code&gt; (or &lt;code&gt;long long&lt;/code&gt;)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="25eeae832d72ed3ac287745a8b11538f1c57ec70" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;low &amp;lt;= max&lt;/code&gt;, or &lt;code&gt;maxSize == chooseAtRuntime&lt;/code&gt; and &lt;code&gt;max&lt;/code&gt; has not yet been initialized. Also, no allocation has been yet done with this allocator.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fb726eb349abf2e37154eb8736f944062867db87" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;main()&lt;/code&gt; Function</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="129c758d4ac6dd6b6924ab4249d29cb61ded7cad" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;makeIndex&lt;/code&gt; overwrites its second argument with the result, but never reallocates it.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b7b59ca16aed965bf946f9a2c80d7fa247a48e12" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;mangledName&lt;/code&gt; is the same as builtin &lt;code&gt;.mangleof&lt;/code&gt; property, but might be more convenient in generic code, e.g. as a template argument when invoking staticMap.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c544143563e1f74a6c402ca380463fcaef1fbc2c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;map!(a =&amp;gt; a * 2)([1, 2, 3])&lt;/code&gt; lazily returns a range with the numbers &lt;code&gt;2&lt;/code&gt;, &lt;code&gt;4&lt;/code&gt;, &lt;code&gt;6&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4761b7dc7f583a3d31830f3e09d1438fb71453b0" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;map&lt;/code&gt; has more overhead than the simpler procedure used by &lt;code&gt;amap&lt;/code&gt; but avoids the need to keep all results in memory simultaneously and works with non-random access ranges.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ad50cff4e88d0799e190aa7ade21aa72c4ee06e4" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;max(3, 4, 2)&lt;/code&gt; returns &lt;code&gt;4&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="15bb7ee8875811b3baf41488e3c96e099c2a02b5" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;maxCount([2, 4, 1, 4, 1])&lt;/code&gt; returns &lt;code&gt;tuple(4, 2)&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="655f2b7c21e23c123906923a24f5c793344bba90" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;maxPos([2, 3, 1, 3, 4, 1])&lt;/code&gt; returns the subrange &lt;code&gt;[4, 1]&lt;/code&gt;, i.e., positions the range at the first occurrence of its maximal element.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1071e9ef737014048e3bccf0ff565f1f954f2ccf" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;min(3, 4, 2)&lt;/code&gt; returns &lt;code&gt;2&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6fff40f5a24451779daba8933602d60ed7ce2faf" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;minCount([2, 1, 1, 4, 1])&lt;/code&gt; returns &lt;code&gt;tuple(1, 3)&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b8ef619f4e0a49816b959045c7488e102ae84ae5" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;minPos([2, 3, 1, 3, 4, 1])&lt;/code&gt; returns the subrange &lt;code&gt;[1, 3, 4, 1]&lt;/code&gt;, i.e., positions the range at the first occurrence of its minimal element.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ebb26ab5e762f1a839431b369278827700f15efa" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;mismatch(&quot;oh hi&quot;, &quot;ohayo&quot;)&lt;/code&gt; returns &lt;code&gt;tuple(&quot; hi&quot;, &quot;ayo&quot;)&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ad172e35f10a277274b0ed5b3fbcd82e3bbfd231" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;mixin(x ~ &quot;lhs&quot;)&lt;/code&gt; for unary, &lt;code&gt;mixin(&quot;lhs&quot; ~ x ~ &quot;rhs&quot;)&lt;/code&gt; for binary</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="17739b82698658d46a9e5259c44de548d2101630" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;mixin&lt;/code&gt; expressions if and only if the compilation of the expression resulting from compiling the argument(s) to &lt;code&gt;mixin&lt;/code&gt; is an lvalue;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6da6e8146acef891595f833e9c41c8d7f16194fd" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;mixin&lt;/code&gt; statement</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bcf9e8ea748e70f1cc770bfd4e8fdf662e551518" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;move(a, b)&lt;/code&gt; moves &lt;code&gt;a&lt;/code&gt; into &lt;code&gt;b&lt;/code&gt;. &lt;code&gt;move(a)&lt;/code&gt; reads &lt;code&gt;a&lt;/code&gt; destructively when necessary.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6319ed7e079aa5cdd6b26c22ceb64f71bfdb61d8" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;msg&lt;/code&gt; - error message as a &lt;code&gt;string&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aed62f47a9973b1a8fbc6a93da9d4ae885be19f7" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;n&lt;/code&gt; elements but will stop if the range is empty first. In other languages this is sometimes called &lt;code&gt;skip&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8f82b80e4b107c5455404b0aa2d60f7e17d0658e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;name&lt;/code&gt; and &lt;code&gt;dstName&lt;/code&gt; are always the empty string since this time zone has no DST, and while it may be meant to represent a time zone which is in the TZ Database, obviously it's not likely to be following the exact rules of any of the time zones in the TZ Database, so it makes no sense to set it.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3d6734e2e3e13b6908442f1d4b994b0564c1e1b0" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;nothrow&lt;/code&gt; Attribute</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7a4ae3472c64b73ed1017173116c41279dd3cadb" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;null&lt;/code&gt; if &lt;code&gt;e&lt;/code&gt; is not an aggregate or if it is an aggregate that doesn't permit inlining, and the aggregate otherwise.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="342db145b5532dfeb4960769e8d2ac17e8ca5092" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;null&lt;/code&gt; if not an operator overload, otherwise the lowered expression</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="09a5f97c5f824bf4bb328e3511556aa409edc0ac" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;null&lt;/code&gt; literal is formatted as &lt;code&gt;&quot;null&quot;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7148866e024541832be10dd624dc857d377ef474" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;null&lt;/code&gt; on failure or if the requested size exceeds the remaining capacity.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="13d3a4d132e79d8c89a8051d12f32981ae7abc4c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;null&lt;/code&gt; or &lt;code&gt;this&lt;/code&gt; expression when this declaration is a field</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a15765a5e2096039162ed69d34289b746d72ae10" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;null&lt;/code&gt; represents the null value for pointers, pointers to functions, delegates, dynamic arrays, associative arrays, and class objects. If it has not already been cast to a type, it is given the singular type &lt;code&gt;typeof(null)&lt;/code&gt; and it is an exact conversion to convert it to the null value for pointers, pointers to functions, delegates, etc. After it is cast to a type, such conversions are implicit, but no longer exact.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6c9fcd375cb2635f126aa8c4382fed567cda668c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;obj&lt;/code&gt; must not already have a monitor.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="53265aa7a3308ec880f4e25e7bc1b18c458fed7c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;obj&lt;/code&gt; without any modification.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9a972bce84feda7e286dd14976860b2837b979c3" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;op&lt;/code&gt; is one of: TOK.lessThan, TOK.lessOrEqual, TOK.greaterThan, TOK.greaterOrEqual</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e03743facb1bd4fbbad5c7ae7e1be25ba907b2ad" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;opPostMove&lt;/code&gt; will be called if defined:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7cac9e13dbedf038b706359b0b3bfdddbff1e67a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;ordered(1, 1, 2, 3)&lt;/code&gt; returns &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fe01c087c1137c8c50eb31f65e4b2c604b452370" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;ordered&lt;/code&gt; allows repeated values, e.g. &lt;code&gt;ordered(1, 1, 2)&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;. To verify that the values are ordered strictly monotonically, use &lt;code&gt;strictlyOrdered&lt;/code&gt;; &lt;code&gt;strictlyOrdered(1, 1, 2)&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6a5e0ca2626efd372513012144aeeb5aa2c60756" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;override&lt;/code&gt; Attribute</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6863469fa5d3953fc0cab9dedf798bbbdc3091fa" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;owns&lt;/code&gt; is defined if and only if both allocators define &lt;code&gt;owns&lt;/code&gt;. Returns &lt;code&gt;primary.owns(b) | fallback.owns(b)&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5c036498ea7ccc88df0ddae88726f48b50505edc" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;package&lt;/code&gt; extends private so that package members can be accessed from code in other modules that are in the same package. If no identifier is provided, this applies to the innermost package only, or defaults to &lt;code&gt;private&lt;/code&gt; if a module is not nested in a package.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="99e9b5e43e5735f74de8ff7517e6dcba640ff75d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;package&lt;/code&gt; may have an optional parameter in the form of a dot-separated identifier list which is resolved as the qualified package name. The package must be either the module's parent package or one of its anscestors. If this optional parameter is present, the symbol will be visible in the specified package and all of its descendants.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8b16f6c70937381d9273f435f11d2e00eea7e2d4" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;parent&lt;/code&gt; field returns a lexically enclosing scope symbol this is a member of.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="785ee288b8022b3dbdd08f20aaed022d962e94ef" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;parent&lt;/code&gt;: an alias to the overridden function (if any).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e089e7b3b9b73809abfb92ef56b5e3c884a692a9" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;pastMixin&lt;/code&gt; returns the enclosing symbol if this is a template mixin.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2b80008427b9535aedf9b70afeb14098e58d8e4d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;pastMixinAndNspace&lt;/code&gt; does likewise, additionally skipping over Nspaces that are mangleOnly.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c82c59282aaf3a7e7db645460bd099ce8ee421b8" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;pipeProcess&lt;/code&gt; and &lt;code&gt;pipeShell&lt;/code&gt; are convenient wrappers around &lt;a href=&quot;#spawnProcess&quot;&gt;&lt;code&gt;spawnProcess&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#spawnShell&quot;&gt;&lt;code&gt;spawnShell&lt;/code&gt;&lt;/a&gt;, respectively, and automate the task of redirecting one or more of the child process' standard streams through pipes. Like the functions they wrap, these functions return immediately, leaving the child process to execute in parallel with the invoking process. It is recommended to always call &lt;a href=&quot;#wait&quot;&gt;&lt;code&gt;wait&lt;/code&gt;&lt;/a&gt; on the returned &lt;a href=&quot;#ProcessPipes.pid&quot;&gt;&lt;code&gt;ProcessPipes.pid&lt;/code&gt;&lt;/a&gt;, as detailed in the documentation for &lt;code&gt;wait&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9ebf87651ef2f151be369c9174cb3ac21dab708d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;popBackExactly&lt;/code&gt; will behave the same but instead removes elements from the back of the (bidirectional) range instead of the front.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="765c4bc07ddeed29065f2acfd024ee4fc027cdf8" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;popBackN&lt;/code&gt; behaves the same as &lt;code&gt;popFrontN&lt;/code&gt; but instead removes elements from the back of the (bidirectional) range instead of the front.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="be6ef5b9245c320746a5e716e6554a963c6f5b9c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;popFrontN&lt;/code&gt; eagerly advances &lt;code&gt;r&lt;/code&gt; itself (not a copy) up to &lt;code&gt;n&lt;/code&gt; times (by calling &lt;code&gt;r.popFront&lt;/code&gt;). &lt;code&gt;popFrontN&lt;/code&gt; takes &lt;code&gt;r&lt;/code&gt; by &lt;code&gt;ref&lt;/code&gt;, so it mutates the original range. Completes in &amp;Omicron;(&lt;code&gt;1&lt;/code&gt;) steps for ranges that support slicing and have length. Completes in &amp;Omicron;(&lt;code&gt;n&lt;/code&gt;) time for all other ranges.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5e43d3f60830438c35b679ac8111772b9fd759ef" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;post(&quot;dlang.org&quot;, &quot;Hi&quot;)&lt;/code&gt; returns a char[] containing the dlang.org web page. after a HTTP POST of &quot;hi&quot;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3b56c571dc782994b2ad8a9de2f9c60b84c8d58e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;pragma&lt;/code&gt; argument</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9de19508347bbfe1195e8d606a362d1a2fc4ac3d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;print&lt;/code&gt; Print all cycles detected, but do not abort execution. When cycles are present, order of static construction is implementation defined, and not guaranteed to be valid.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a6c36e16798b3bee716e3c7d1bfa395fccf04885" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;printf()&lt;/code&gt; is a C function and is not part of D. &lt;code&gt;printf()&lt;/code&gt; will print C strings, which are 0 terminated. There are two ways to use &lt;code&gt;printf()&lt;/code&gt; with D strings. The first is to add a terminating 0, and cast the result to a char*:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="885eaccdd6ff3a7f55587c62f3e2ef120742b0cb" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;protected&lt;/code&gt; only applies inside classes (and templates as they can be mixed in) and means that a symbol can only be seen by members of the same module, or by a derived class. If accessing a protected instance member through a derived class member function, that member can only be accessed for the object instance which can be implicitly cast to the same type as &amp;lsquo;this&amp;rsquo;. &lt;code&gt;protected&lt;/code&gt; module members are illegal.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="58104d24c97eca4573f45c0f775fb78ad6fc3db1" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;ptrdiff_t&lt;/code&gt; is an alias to the signed integral basic type the same size as &lt;code&gt;size_t&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c0c955a9b07864cb44d663b9a3edf65f6d23651e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;public&lt;/code&gt; means that any code within the executable can see the member. It is the default visibility attribute.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="79e8d813b3487dee878c4257552cc6b79a81eafa" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;pure&lt;/code&gt; Attribute</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="355e1b792f5254a4df82ea4a1c4c52dbe2ca371f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;pure&lt;/code&gt;, &lt;code&gt;nothrow&lt;/code&gt;, &lt;code&gt;@nogc&lt;/code&gt;, &lt;code&gt;@property&lt;/code&gt;, &lt;code&gt;@system&lt;/code&gt;, &lt;code&gt;@trusted&lt;/code&gt;, &lt;code&gt;@safe&lt;/code&gt;, and &lt;code&gt;ref&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="37a05e6ea71c58e0ecc8b8f22dc710971b6a30f7" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;put(&quot;dlang.org&quot;, &quot;Hi&quot;)&lt;/code&gt; returns a char[] containing the dlang.org web page. after a HTTP PUT of &quot;hi&quot;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ad07519f507b3041d07e3c20f839ab72ee2e1e99" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;put&lt;/code&gt; should</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9a592372b6a5ac856e36481ab0ba287c9445c4e9" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;put&lt;/code&gt; treats dynamic arrays as array slices, and will call &lt;code&gt;popFront&lt;/code&gt; on the slice after an element has been copied.  Be sure to save the position of the array before calling &lt;code&gt;put&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9193340cac39846b4cfea0d1c78fc84d0f2f893f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;r.back&lt;/code&gt; returns (possibly a reference to) the last element in the range. Calling &lt;code&gt;r.back&lt;/code&gt; is allowed only if calling &lt;code&gt;r.empty&lt;/code&gt; has, or would have, returned &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="13af710cd09013b2e064b363bf36b6cbc35fcbef" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;r.empty&lt;/code&gt; evaluated multiple times, without calling &lt;code&gt;r.popFront&lt;/code&gt;, or otherwise mutating the range object or the underlying data, yields the same result for every evaluation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9e47c532ad11f99cc48c6a97a263483fe2fb84ac" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;r.empty&lt;/code&gt; returns &lt;code&gt;false&lt;/code&gt; if and only if there is more data available in the range.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="33a82d6bd254c8ddeec0ab5cce7440aeb3a26b7f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;r.front&lt;/code&gt; can be legally evaluated if and only if evaluating &lt;code&gt;r.empty&lt;/code&gt; has, or would have, equaled &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="70a4ae757d1f6b79696d48604892d6f38fdeb2b2" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;r.front&lt;/code&gt; evaluated multiple times, without calling &lt;code&gt;r.popFront&lt;/code&gt;, or otherwise mutating the range object or the underlying data, yields the same result for every evaluation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="988cf166f117ce8d9c9381f74cc01ac3753e3cf0" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;r.front&lt;/code&gt; returns the current element in the range. It may return by value or by reference.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6d03a5433bfb6e8943880060c7a7f6081694bfa9" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;r.opIndex(n)&lt;/code&gt; returns a reference to the &lt;code&gt;n&lt;/code&gt;th element in the range.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="49c07d736b9df0517fbba6cc7e05a9eafafd0457" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;r.popFront&lt;/code&gt; advances to the next element in the range.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="03e39f666e8ff147ad6b6dc8a0ff7c40edcf747a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;r.popFront&lt;/code&gt; can be called if and only if evaluating &lt;code&gt;r.empty&lt;/code&gt; has, or would have, equaled &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="45425e928901d43b7c9007bba36a4e02162c3a42" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;r&lt;/code&gt; advanced to the first occurrence of two adjacent elements that satisfy the given predicate. If there are no such two elements, returns &lt;code&gt;r&lt;/code&gt; advanced until empty.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="11bb7f38ea0c23dd1df658dfc6cfd544881c52c5" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;r&lt;/code&gt; must be a random-access range with length. &lt;code&gt;n&lt;/code&gt; must be less than or equal to &lt;code&gt;r.length&lt;/code&gt;. If no RNG is specified, &lt;code&gt;rndGen&lt;/code&gt; will be used.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="da6cb3cc16e9187eebb9753b8301da3699b87ada" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;r[pivot]&lt;/code&gt; is swapped to &lt;code&gt;r[k]&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="75528cc8ea4ca3059d520e5cbbdcdb8078984b9c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;range&lt;/code&gt; with &lt;code&gt;n&lt;/code&gt; elements dropped</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="47ab73990ea3858b873e813654c0700f917d618a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;range&lt;/code&gt; with up to &lt;code&gt;n&lt;/code&gt; elements dropped</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="51de97b8f207a648c1f4d661babb19e96cb91a05" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;rawWrite&lt;/code&gt; always writes in binary mode on Windows.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7e01cc52b2fb39cae323fcbb92dd524e80347e92" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;re&lt;/code&gt; parameter can be one of three types:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9f5e9e6d00cc09a02683bc78dffa8ff6fb85f34f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;real&lt;/code&gt; is not supported, because its size is implementation-dependent and therefore could vary from machine to machine (which could make it unusable if you tried to transfer it to another machine).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8c40895248f80db003f0fbe8781e5e9f4a2a0773" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;reallocate&lt;/code&gt; does not attempt to use &lt;code&gt;Allocator.reallocate&lt;/code&gt; even if defined. This is deliberate so allocators may use it internally within their own implementation of &lt;code&gt;reallocate&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9dd5860f115951d36e1f86e186eb1c5079118b9c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;reallocate&lt;/code&gt; works as follows. If &lt;code&gt;primary.owns(b)&lt;/code&gt;, then &lt;code&gt; primary.reallocate(b, newSize)&lt;/code&gt; is attempted. If it fails, an attempt is made to move the allocation from &lt;code&gt;primary&lt;/code&gt; to &lt;code&gt;fallback&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e269b93fff7df8dc53d3774c6da5a14d7fb8db6f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;reduce!((a, b) =&amp;gt; a + b)([1, 2, 3, 4])&lt;/code&gt; returns &lt;code&gt;10&lt;/code&gt;. This is the old implementation of &lt;code&gt;fold&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="71c273ae8de7dc1231647f39241604ef79ab6c96" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;ref&lt;/code&gt; Attribute</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a6f5f10cc217e4f1cac077c32c1493718928e341" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;ref&lt;/code&gt; argument through which &lt;code&gt;arg&lt;/code&gt; may be assigned</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="204baff180e7e3a468a1f9c56b74a65a751e70cf" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;ref&lt;/code&gt; can be used to update the original elements:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e8269973bbdb978f0397e67fc8a6355eb51b2130" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;ref&lt;/code&gt; can not be applied to the index values.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="932eeb15c70bdcc684754cbc9bc11f2688ddcc81" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;relTolerance&lt;/code&gt; shall be normal positive real.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1076698319f98e76706f3fc28826ddcc4b9b7224" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;remove(key)&lt;/code&gt; does nothing if the given</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cef283158d0f1a50261d4f80c63bd68c62f99e27" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;remquo&lt;/code&gt; and &lt;code&gt;remainder&lt;/code&gt; not supported on Windows.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2ecbc7094325c066ef8cdf3361653dbbfc37ce1d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;rename&lt;/code&gt; uses the passed &lt;code&gt;names&lt;/code&gt; and returns a new &lt;a href=&quot;#Tuple&quot;&gt;&lt;code&gt;Tuple&lt;/code&gt;&lt;/a&gt; using these names, with the content unchanged. If fewer names are passed than there are members of the &lt;a href=&quot;#Tuple&quot;&gt;&lt;code&gt;Tuple&lt;/code&gt;&lt;/a&gt; then those trailing members are unchanged. An empty string will remove the name for that member. It is an compile-time error to pass more names than there are members of the &lt;a href=&quot;#Tuple&quot;&gt;&lt;code&gt;Tuple&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f5cb9eecaf9f022d0a8470e17dd2137035c24912" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;resolveInternalPointer&lt;/code&gt; is defined if and only if both allocators define it.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cc87f8f1d317e08f1002d55d8c9053664da7610a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;return scope&lt;/code&gt; can be applied to the &lt;code&gt;this&lt;/code&gt; of class and interface member functions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0a098ce0d05675d45db864ce47dfe56507839992" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;return&lt;/code&gt; Attribute</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4c4e55e29e207e9b091c1a308208acc22bbe6d2a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;return&lt;/code&gt; exits the current function and supplies its return value.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0d1e4e7673cd67124b7c2117ce90a093529e4757" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;return&lt;/code&gt; indicates that either the return value of the function or the first parameter is a pointer derived from the &lt;code&gt;return&lt;/code&gt; parameter or any other parameters also marked &lt;code&gt;return&lt;/code&gt;. For constructors, &lt;code&gt;return&lt;/code&gt; applies to the (implicitly returned) &lt;code&gt;this&lt;/code&gt; reference. For void functions, &lt;code&gt;return&lt;/code&gt; applies to the first parameter</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b4d1e67726ee639f9a5c7f346530a61fa00f8ba1" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;roundRobin(r1, r2, r3)&lt;/code&gt; yields &lt;code&gt;r1.front&lt;/code&gt;, then &lt;code&gt;r2.front&lt;/code&gt;, then &lt;code&gt;r3.front&lt;/code&gt;, after which it pops off one element from each and continues again from &lt;code&gt;r1&lt;/code&gt;. For example, if two ranges are involved, it alternately yields elements off the two ranges. &lt;code&gt;roundRobin&lt;/code&gt; stops after it has consumed all ranges (skipping over the ones that finish early).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0f5bb74811faa1591cdad4c836be024aee1e88e1" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;roundingFunction(n) &amp;gt;= n&lt;/code&gt; for all &lt;code&gt;n&lt;/code&gt; of type &lt;code&gt;size_t&lt;/code&gt;;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="308b72cef8c5b530189638ec876ae903345922ca" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;roundingFunction&lt;/code&gt; must be &lt;code&gt;nothrow&lt;/code&gt;, &lt;code&gt;@safe&lt;/code&gt;, &lt;code&gt;@nogc&lt;/code&gt; and &lt;code&gt;pure&lt;/code&gt;, i.e. always return the same value for a given &lt;code&gt;n&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="109cdbe06887b34b6b16365fe723cf15c4d1291a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;roundingFunction&lt;/code&gt; must be monotonically increasing, i.e. &lt;code&gt;roundingFunction(n1) &amp;lt;= roundingFunction(n2)&lt;/code&gt; for all &lt;code&gt;n1 &amp;lt; n2&lt;/code&gt;;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d2742c8e141b08b59565abb12504e62ecd5fa332" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;roundingFunction&lt;/code&gt; must satisfy three constraints. These are not enforced (save for the use of &lt;code&gt;assert&lt;/code&gt;) for the sake of efficiency.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c8420b0329603c1302842ffb196fac98e4ea5918" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;s&lt;/code&gt; turned into an expression, &lt;code&gt;ErrorExp&lt;/code&gt; if an error occurred</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dd6c5560263e9d7106d8390afa95f09a9dcd7c46" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;save&lt;/code&gt; works as normal and operates on a new range, so if &lt;code&gt;save&lt;/code&gt; is ever called on the &lt;code&gt;RefRange&lt;/code&gt;, then no operations on the saved range will affect the original.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c1856b9100bdac38994d4cdb68f1848445200c7b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;scope&lt;/code&gt; Attribute</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="605b97283af3bfaf0042af48044ab3db174a5e7d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;scope&lt;/code&gt; cannot be applied to globals, statics, data members, ref or out parameters. Arrays of &lt;code&gt;scope&lt;/code&gt;s are not allowed, and &lt;code&gt;scope&lt;/code&gt; function return values are not allowed. Assignment to a &lt;code&gt;scope&lt;/code&gt;, other than initialization, is not allowed. &lt;code&gt;Rationale:&lt;/code&gt; These restrictions may get relaxed in the future if a compelling reason to appears.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="de58cba1b63566938adce3e13bef6a93cbd5e801" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;scope&lt;/code&gt; ensures that no references to the pointed-to object are retained, in global variables or pointers passed to the function (and recursively to other functions called in the function), as a result of calling the function. Variables in the function body and parameter list that are &lt;code&gt;scope&lt;/code&gt; may have their allocations elided as a result.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7e11f308a204e081f111ee3bf2a5a482b9381e79" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;scopedTask&lt;/code&gt; might be preferred over &lt;code&gt;task&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6408fb12bc31b661581f337ae2267afe0bfc681c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;self&lt;/code&gt;: an alias to the function itself;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f05d3272cc81781898ada7fb162b5d7951fba66d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;seq&lt;/code&gt; advanced to the first matching element, or until empty if there are no matching elements.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="06257616c41cacb4ce31abd296b3a46dd70958b2" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;shared&lt;/code&gt; Attribute</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9b6ab6f176994589d27d564332f0146fa64462d4" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;shared&lt;/code&gt;. When a postblit is qualified with &lt;code&gt;shared&lt;/code&gt; as in &lt;code&gt;this(this) shared&lt;/code&gt; or &lt;code&gt;shared this(this)&lt;/code&gt; solely &lt;code&gt;shared&lt;/code&gt; objects may invoke the postblit; attempts of postbliting unshared objects will result in compile time errors:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e79d49bb12749d54349a7e1da24c925d0a9c9b5a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;sharedLog&lt;/code&gt; is only thread-safe if the the used &lt;code&gt;Logger&lt;/code&gt; is thread-safe. The default &lt;code&gt;Logger&lt;/code&gt; is thread-safe.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="223c9c7bd3e5173b52c93ac3449e4ed7df37d6c0" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;size_t&lt;/code&gt; 0 for end of file, otherwise number of characters read</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="481bc787f0b1a627493311fd994efbba2ed4cc7c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;size_t&lt;/code&gt; is an alias to one of the unsigned integral basic types, and represents a type that is large enough to represent an offset into all addressable memory.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="df033de8837c1e0c009462fae21291df75580008" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;sort&lt;/code&gt; returns a &lt;a href=&quot;std_range#SortedRange&quot;&gt;&lt;code&gt;std.range.SortedRange&lt;/code&gt;&lt;/a&gt; over the original range, allowing functions that can take advantage of sorted data to know that the range is sorted and adjust accordingly. The &lt;a href=&quot;std_range#SortedRange&quot;&gt;&lt;code&gt;std.range.SortedRange&lt;/code&gt;&lt;/a&gt; is a wrapper around the original range, so both it and the original range are sorted. Other functions can't know that the original range has been sorted, but they</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e4c6ea564f371d9ede380d1ded149063253741d2" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;startsWith(&quot;hello, world&quot;, &quot;hello&quot;)&lt;/code&gt; returns &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9b479c5ce0a7bcc0a387d731c3bea31274eb3618" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;static foreach&lt;/code&gt; supports multiple variables in cases where the corresponding &lt;code&gt;foreach&lt;/code&gt; statement supports them. (In this case, &lt;code&gt;static foreach&lt;/code&gt; generates a compile-time sequence of tuples, and the tuples are subsequently unpacked during iteration.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6f937f4e1c8d330cfe36aa5a7dac2283a0e18588" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;static opCall&lt;/code&gt; also works as expected for a function call operator with type names.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="58e93a06ab727109993d9039f8909c7568769569" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;static&lt;/code&gt; Attribute</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f861a00c2c4e8f4a3c18c76a83270bfdfb229222" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;static&lt;/code&gt; cannot be used with selective imports.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0c05b4bf3a0823e983b650821a7fea25264f6966" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;staticArray&lt;/code&gt; returns by value, so expressions involving large arrays may be inefficient.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d186527edac8a16bdcca857733d1babbfdb6d0fb" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std.parallelism&lt;/code&gt; implements high-level primitives for SMP parallelism. These include parallel foreach, parallel reduce, parallel eager map, pipelining and future/promise parallelism. &lt;code&gt;std.parallelism&lt;/code&gt; is recommended when the same operation is to be executed in parallel on different data, or when a function is to be executed in a background thread and its result returned to a well-defined main thread. For communication between arbitrary threads, see &lt;code&gt;std.concurrency&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e539f2e5797833bc4d4c570169e4fef76e97deff" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std.parallelism&lt;/code&gt; is based on the concept of a &lt;code&gt;Task&lt;/code&gt;. A &lt;code&gt;Task&lt;/code&gt; is an object that represents the fundamental unit of work in this library and may be executed in parallel with any other &lt;code&gt;Task&lt;/code&gt;. Using &lt;code&gt;Task&lt;/code&gt; directly allows programming with a future/promise paradigm. All other supported parallelism paradigms (parallel foreach, map, reduce, pipelining) represent an additional level of abstraction over &lt;code&gt;Task&lt;/code&gt;. They automatically create one or more &lt;code&gt;Task&lt;/code&gt; objects, or closely related types that are conceptually identical but not part of the public API.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d51ba1cf1d887be72a4c35b6e027f3b0b776e392" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;strictlyOrdered(1, 1, 2, 3)&lt;/code&gt; returns &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b18ef91248deb0535ed182732bf3a2e7452fccd6" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;stride&lt;/code&gt; will only analyze the first &lt;code&gt;str[index]&lt;/code&gt; element. It will not fully verify the validity of the UTF sequence, nor even verify the presence of the sequence: it will not actually guarantee that &lt;code&gt;index + stride(str, index) &amp;lt;= str.length&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3524e11e2cd1a4bae8c339623913a2a68d9caf67" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;strideBack&lt;/code&gt; will only analyze the element at &lt;code&gt;str[index - 1]&lt;/code&gt; element. It will not fully verify the validity of the UTF sequence, nor even verify the presence of the sequence: it will not actually guarantee that &lt;code&gt;strideBack(str, index) &amp;lt;= index&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="815abb2cb935d9d225a7cd705522e3fbcba850f8" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;string&lt;/code&gt; - service name or port number</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="70ead95fb34de5f02a9f1b5d84525c2ccc28179b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;struct&lt;/code&gt;, &lt;code&gt;union&lt;/code&gt;, &lt;code&gt;class&lt;/code&gt;, and &lt;code&gt;interface&lt;/code&gt; are formatted by calling &lt;code&gt;toString&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6b94224ee093a8b123c1a890be96840068352cc9" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;stuff&lt;/code&gt; can be a value convertible to &lt;code&gt;T&lt;/code&gt; or a range of objects convertible to &lt;code&gt;T&lt;/code&gt;. The stable version behaves the same, but guarantees that ranges iterating over the container are never invalidated.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="12300e292a3239ecad42ff3d93d0648b61fb7834" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;super&lt;/code&gt; is identical to &lt;code&gt;this&lt;/code&gt;, except that it is cast to &lt;code&gt;this&lt;/code&gt;'s base class. It is an error if there is no base class. It is an error to use &lt;code&gt;super&lt;/code&gt; within a struct member function. (Only class &lt;code&gt;Object&lt;/code&gt; has no base class.) If a member function is called with an explicit reference to &lt;code&gt;super&lt;/code&gt;, a non-virtual call is made.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5d3e225f1cfb66733f5c5c3a82747e4de13d407e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;switch&lt;/code&gt; with strings</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e1ab526b163fcaca146d0f4387c01f84d9d8e8ed" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;synchronized&lt;/code&gt; and &lt;a href=&quot;https://dlang.org/phobos/core_sync.html&quot;&gt;&lt;code&gt;core.sync&lt;/code&gt;&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c2ae5b48daba2a435390a96fc178a22c54b9103e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;target&lt;/code&gt; shall have enough room to accommodate the entirety of &lt;code&gt;source&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4b618d9a887c9286570dc763d1956279cd9a67d3" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;this&lt;/code&gt; inside &lt;code&gt;struct&lt;/code&gt; and &lt;code&gt;union&lt;/code&gt; member functions;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1dd7c7da4f2db512c36ff60aea324bbf46d7f1eb" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;this&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;this&lt;/code&gt;.</target>
        </trans-unit>
        <trans-unit id="cdd590867d10eda8e591ba3c504661cc4d5c524a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;tickDuration.&lt;/code&gt;&lt;a href=&quot;std_conv#to&quot;&gt;&lt;code&gt;to&lt;/code&gt;&lt;/a&gt;&lt;code&gt;!Duration()&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;tickDuration.&lt;/code&gt;&lt;a href=&quot;std_conv#to&quot;&gt;&lt;code&gt;to&lt;/code&gt;&lt;/a&gt;&lt;code&gt;!Duration()&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="d0bd3c31ca7c7f29752ad58a8ef9e6ff27520e91" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;toHash&lt;/code&gt; is rarely directly invoked; it is implicitly used when BigInt is used as the key of an associative array.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="82ec7686ea934cd2f18c7f60e28371c82c9f447d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;toParent()&lt;/code&gt; returns a logically enclosing scope symbol this is a member of. It skips over TemplateMixin's.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0083bc7cd319ebdfebdf2e1edfc6c99f806fcb76" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;toParent2()&lt;/code&gt; returns an enclosing scope symbol this is living at runtime. It skips over both TemplateInstance's and TemplateMixin's. It's used when looking for the 'this' pointer of the enclosing function/class.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="73cfc104297a470e42637ccf91c2c36ee3245422" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;toParentDecl()&lt;/code&gt; similar to &lt;code&gt;toParent2()&lt;/code&gt; but always follows the template declaration scope instead of the instantiation scope.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a94d9760694ab57714a8a469c5e5cfc3daa57828" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;toParentLocal()&lt;/code&gt; similar to &lt;code&gt;toParentDecl()&lt;/code&gt; but follows the instantiation scope if a template declaration is non-local i.e. global or static.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1390a2eb1c2e28916c37115c0998c8521c9afee8" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;toString&lt;/code&gt; is rarely directly invoked; the usual way of using it is via &lt;a href=&quot;std_format#format&quot;&gt;&lt;code&gt;std.format.format&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3bfea05b95eb98e11a8adc4ee7aed975ec8509c1" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;toString&lt;/code&gt; should have one of the following signatures:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="005990d2619465a8e0eb37195710b4753844c21d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;toUTF16z&lt;/code&gt; is a convenience function for &lt;code&gt;toUTFz!(const(wchar)*)&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3034b52ad5e2b666f9d4ac76c8767f747dbc8719" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;toUTFz&lt;/code&gt; accepts any type of string and is templated on the type of character pointer that you wish to convert to. It will avoid allocating a new string if it can, but there's a decent chance that it will end up having to allocate a new string - particularly when dealing with character types other than &lt;code&gt;char&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7b0fb0a2af81d4622c3f0ca12fdc722369079377" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;tr&lt;/code&gt; is based on &lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/9699919799/utilities/tr.html&quot;&gt;Posix's tr&lt;/a&gt;, though it doesn't do everything that the Posix utility does.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="588c5db26f0574479497abcc48d3bf48bfbf6db3" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;true&lt;/code&gt; if &lt;code&gt;S&lt;/code&gt; can be copied. &lt;code&gt;false&lt;/code&gt; otherwise.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fcf3589ad960d9be2578a5d3a446eecbfb4e6104" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;true&lt;/code&gt; if &lt;code&gt;Seq&lt;/code&gt; is sorted; otherwise &lt;code&gt;false&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7f2a6e0d185693da342465248f1cdf7eba4f160a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;true&lt;/code&gt; if &lt;code&gt;T&lt;/code&gt; is a class nested inside another, with the conditions described above; &lt;code&gt;false&lt;/code&gt; otherwise</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="08a01985c40be7b92a7f5350b980124535abdb46" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;true&lt;/code&gt; if &lt;code&gt;T&lt;/code&gt; is a file handle, &lt;code&gt;false&lt;/code&gt; otherwise.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8567cd36d9c50f8238ab4ae84132dbf24c80defb" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;true&lt;/code&gt; if &lt;code&gt;X&lt;/code&gt; is a function, &lt;code&gt;false&lt;/code&gt; otherwise</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9aa819b66833bb0b0171317b2e1ce1b3bea60f99" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;true&lt;/code&gt; if &lt;code&gt;X&lt;/code&gt; is a type, &lt;code&gt;false&lt;/code&gt; otherwise</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e058cf11ca944763bc20d7e2edd7c761ca2be574" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;true&lt;/code&gt; if &lt;code&gt;X&lt;/code&gt; is final, &lt;code&gt;false&lt;/code&gt; otherwise</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4803b0700c5c007902d1debfefc0c159c43d6fab" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;true&lt;/code&gt; if &lt;code&gt;b&lt;/code&gt; has been allocated with this region, &lt;code&gt;false&lt;/code&gt; otherwise.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="48ffa31f7ed81bcabcb75c22bb37eed8da935d1d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;true&lt;/code&gt; if &lt;code&gt;func&lt;/code&gt; is &lt;code&gt;@safe&lt;/code&gt; or &lt;code&gt;@trusted&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a649d64ab71bc5584e6c4abd2b0fcb8c1a771fe4" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;true&lt;/code&gt; if &lt;code&gt;func&lt;/code&gt; is &lt;code&gt;@system&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="95d0ce1a4c8d33c8a989eafdbe862e7a941b8f3c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;true&lt;/code&gt; if &lt;code&gt;lhs.ptr == rhs.ptr&lt;/code&gt;, &lt;code&gt;false&lt;/code&gt; otherwise.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="db55e28196a1c212f4b61f6ad375a9336bc44dc8" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;true&lt;/code&gt; if &lt;code&gt;name&lt;/code&gt;'s extension is &lt;code&gt;ext&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="736ca71e45580c10aa2d52cf7f053eaba4c25c73" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;true&lt;/code&gt; if &lt;code&gt;r&lt;/code&gt; is partitioned according to predicate &lt;code&gt;pred&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ee04fb6edad869ab006abfb10ae6248745a92500" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;true&lt;/code&gt; if &lt;code&gt;s1 == s2&lt;/code&gt; regardless of case</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4716ee2fbb535862a27757ab1941b9ff0cb859bc" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;true&lt;/code&gt; if &lt;code&gt;source&lt;/code&gt;'s representation embeds a pointer that points to &lt;code&gt;target&lt;/code&gt;'s representation or somewhere inside it.  If &lt;code&gt;source&lt;/code&gt; is or contains a dynamic array, then, then these functions will check if there is overlap between the dynamic array and &lt;code&gt;target&lt;/code&gt;'s representation.  If &lt;code&gt;source&lt;/code&gt; is a class, then it will be handled as a pointer.  If &lt;code&gt;target&lt;/code&gt; is a pointer, a dynamic array or a class, then these functions will only check if &lt;code&gt;source&lt;/code&gt; points to &lt;code&gt;target&lt;/code&gt;,</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aed899d348bc31c47364d7bcccc68dfd78bd3781" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;true&lt;/code&gt; if &lt;code&gt;x&lt;/code&gt; is a NaN, &lt;code&gt;false&lt;/code&gt; otherwise</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e909c65ed2d088f338774b25ee5916d6c6a31a6f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;true&lt;/code&gt; if &lt;code&gt;x&lt;/code&gt; is an integer power of two.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="01576b38e53f760d7fa441f81b6a38331a755a90" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;true&lt;/code&gt; if R is an input range, &lt;code&gt;false&lt;/code&gt; if not</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="22105968f4bd62f765fe40f641d7369b250d9b52" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;true&lt;/code&gt; if all of the elements in &lt;code&gt;r1&lt;/code&gt; appear the same number of times in &lt;code&gt;r2&lt;/code&gt;. Otherwise, returns &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="647b425da501748cddce279a9e4a6ef7b9ff0896" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;true&lt;/code&gt; if and only if &lt;code&gt;c&lt;/code&gt; is a valid Unicode code point</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4521edc34e50fd3161666a50db965c80b72349ec" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;true&lt;/code&gt; if and only if &lt;code&gt;filename&lt;/code&gt; is not empty, not too long, and does not contain invalid characters.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6c8531dd442dde642df6adb3732b3ac0bcdbd097" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;true&lt;/code&gt; if and only if the array has no elements.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="df8b9d49f1b0ad4418768e972f5ff8f26e3eb90f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;true&lt;/code&gt; if and only if the two ranges compare equal element for element, according to binary predicate &lt;code&gt;pred&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="43da0fcd50fb3e44bc97d1779a5a0585c003578b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;true&lt;/code&gt; if any elements escaped</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fd062df197246c3fbf8d28beb36028005e887a34" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;true&lt;/code&gt; if any errors occurred during lexing or parsing.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1d8f7f146e54740a0d8df7019b35493c9329a523" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;true&lt;/code&gt; if assignment to &lt;code&gt;firstArg&lt;/code&gt; would cause an error</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4bf38a0de72bf9a9960cb44c7ba18e39cf09405b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;true&lt;/code&gt; if both arrays are the same length and &lt;code&gt;lhs.ptr == rhs.ptr&lt;/code&gt;, &lt;code&gt;false&lt;/code&gt; otherwise.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9ac3764e3160f18d1bccd835c289cdb2330d2c25" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;true&lt;/code&gt; if both ranges have the same length, &lt;code&gt;false&lt;/code&gt; otherwise.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="36ceac4ce50650aac661ae00a2ba169845655943" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;true&lt;/code&gt; if both representations are equal, &lt;code&gt;false&lt;/code&gt; otherwise</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="39ff04c17f38cc82afededf77e72dd30164a69f2" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;true&lt;/code&gt; if construction would cause an escaping reference error</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="303af4808ad2baecce90c36afc6560330e3d32c5" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;true&lt;/code&gt; if errors have been diagnosed</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c5afd4cd9e62983cefa444c2a133f0d9bf5e1e04" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;true&lt;/code&gt; if function is really nested within other function.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3ea300fe97ac7f51e74b492d018077cf50054e6e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;true&lt;/code&gt; if it does</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2cbf067aba4bdad738328a3ce75e53fb26ca7370" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;true&lt;/code&gt; if it is special</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d307d51918d914c77ec41a0e6892c2e4866f78ee" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;true&lt;/code&gt; if no errors</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d1f8d85b30851e65377e6627837464bf19f191dc" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;true&lt;/code&gt; if normalization completed normally, &lt;code&gt;false&lt;/code&gt; if all elements in &lt;code&gt;range&lt;/code&gt; were zero or if &lt;code&gt;range&lt;/code&gt; is empty.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aed7c27f1c7731761f2c1cd71c40b58e2f287d79" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;true&lt;/code&gt; if pattern matches path, &lt;code&gt;false&lt;/code&gt; otherwise.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="461691066f4a233761207873a6c1a5621c8a2fe4" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;true&lt;/code&gt; if pointers to the stack can escape</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eac3e452588356a664a212ed933cbc90570f8f52" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;true&lt;/code&gt; if pointers to the stack can escape via assignment</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="60ca524063ed35647335cc75fabf9b2110a7e50f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;true&lt;/code&gt; if references to the stack can escape</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f3f56d935c90d3b16b4684a1b5724de202629d96" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;true&lt;/code&gt; if special</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="caf43bf9888cecf7cf63ded7f3c6d3b0af21f554" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;true&lt;/code&gt; if statement 'comes from' somewhere else, like a goto</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="67a3b1de444a60f32cca1d083e46bbcd443d7ec7" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;true&lt;/code&gt; if statement has executable code.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="96444596e9cdaa5283ccaf2d66fcfbb0199200ba" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;true&lt;/code&gt; if statement uses exception handling</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1da5b3b9b2f6758b8600858d63d6845c211c848a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;true&lt;/code&gt; if successful</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="60bfef6717d458b4089bebf93690bce834609c26" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;true&lt;/code&gt; if the 2 lambda functions are equal, &lt;code&gt;false&lt;/code&gt; otherwise</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e2c94ffbb5fbd44461e4bc55c729fb41009d2ec9" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;true&lt;/code&gt; if the character is in the Alphabetic, Nd, Nl, or No Unicode categories</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="975530ebe416c50fa316849689c1b9c84bdce985" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;true&lt;/code&gt; if the directory exists or was successfully created</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e43f48b191a968d2108ef45b3265b47e07417128" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;true&lt;/code&gt; if the event is in signaled state, &lt;code&gt;false&lt;/code&gt; if the event is uninitialized or another error occured</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2f1569e1846ee1e5ca37b0ee2af6741e1637451e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;true&lt;/code&gt; if the event is in signaled state, &lt;code&gt;false&lt;/code&gt; if the event was nonsignaled for the given time or the event is uninitialized or another error occured</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="113e77a108be9ae1dd3293e6b6a5943dc6e2977d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;true&lt;/code&gt; if the given character is a valid mangled character</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bd39a6a2f186a6cc7017a4e5cb92a04e3ba80c2e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;true&lt;/code&gt; if the last socket operation failed because the socket was in non-blocking mode and the operation would have blocked.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c88d13eb3e3221036fb4aac2edb3a5f74da225b9" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;true&lt;/code&gt; if the lock was successful, and &lt;code&gt;false&lt;/code&gt; if the specified file segment was already locked.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c391a399880ca8ac7ebb20fbb88f6087244d9d1f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;true&lt;/code&gt; if the needle was found, in which case &lt;code&gt;haystack&lt;/code&gt; is positioned after the end of the first occurrence of &lt;code&gt;needle&lt;/code&gt;; otherwise &lt;code&gt;false&lt;/code&gt;, leaving &lt;code&gt;haystack&lt;/code&gt; untouched. If no needle is provided, it returns the number of times &lt;code&gt;pred(haystack.front)&lt;/code&gt; returned true.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a175ce1d936dfebd42507cfbe21c8b2e7b23d9de" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;true&lt;/code&gt; if the prefix of &lt;code&gt;haystack&lt;/code&gt; matches any range of &lt;code&gt;needles&lt;/code&gt; fully or &lt;code&gt;pred&lt;/code&gt; evaluates to true, and &lt;code&gt;haystack&lt;/code&gt; has been advanced to the point past this segment; otherwise false, and &lt;code&gt;haystack&lt;/code&gt; is left in its original position.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4c24804d7d89da4dbfceb2e23da57e0da329b035" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;true&lt;/code&gt; if the range is sorted, false otherwise. &lt;code&gt;isSorted&lt;/code&gt; allows duplicates, &lt;code&gt;isStrictlyMonotonic&lt;/code&gt; not.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="83d1f2aff5b95cbd92a0fce194d4b5a2cbf7071c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;true&lt;/code&gt; if the reference count is greater than &lt;code&gt;0&lt;/code&gt; and &lt;code&gt;false&lt;/code&gt; when it hits &lt;code&gt;0&lt;/code&gt;. For stateless allocators, it always returns &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="90eac6476595c502fd3275f7a9821859015a444f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;true&lt;/code&gt; if the thread was created by &lt;code&gt;createLowLevelThread&lt;/code&gt; and is still running.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ccd328eef72a7bff331437c901f6ecfa74aa6c6c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;true&lt;/code&gt; if the two items are approximately equal under either criterium. If one item is a range, and the other is a single value, then the result is the logical and-ing of calling &lt;code&gt;approxEqual&lt;/code&gt; on each element of the ranged item against the single item. If both items are ranges, then &lt;code&gt;approxEqual&lt;/code&gt; returns &lt;code&gt;true&lt;/code&gt; if and only if the ranges have the same number of elements and if &lt;code&gt;approxEqual&lt;/code&gt; evaluates to &lt;code&gt;true&lt;/code&gt; for each pair of elements.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7bca98b9828324a100c5c2bf450aba6fec922fc8" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;true&lt;/code&gt; if the values are ordered; &lt;code&gt;ordered&lt;/code&gt; allows for duplicates, &lt;code&gt;strictlyOrdered&lt;/code&gt; does not.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e52eb334eccf7af84905903e88bbc2ee4e2362a0" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;true&lt;/code&gt; if this &lt;code&gt;Declaration&lt;/code&gt; is &lt;code&gt;@disable&lt;/code&gt;d, &lt;code&gt;false&lt;/code&gt; otherwise.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ea21e9fc593db78397da9a076ce8abbf1795e14e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;true&lt;/code&gt; if this class is a metaclass.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3b23821093362e8fee7cf930fb569f2afa7dccae" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;true&lt;/code&gt; if this class is externally defined.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b6c35c42020228b2903355d9cbb57558c69b2b25" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;true&lt;/code&gt; if this duration is non-zero.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="19e69c3151c77c41b315753ae89fb38727bd2d21" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;true&lt;/code&gt; if warnings have been diagnosed</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="be3d6f4970bb17847deff217df6bcc9c3542ea2c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;true&lt;/code&gt; if x is &amp;plusmn;&amp;infin;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a2e10729efeca8adc0d5e6c2e9608120e2e73efe" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;true&lt;/code&gt; if x is Nan.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="392a8f18d3aafeb3b757fe74ab32cf1c8d68ff76" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;true&lt;/code&gt; if x is a denormal number.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5c80c7160cf5bcaed5afcbc690d5e1ce55fce1ad" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;true&lt;/code&gt; if x is finite.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="70b59e8a6fb2a9a46b8b33eef61ecbe8e59ffb8b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;true&lt;/code&gt; if x is normalized.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5e2e042678636c0e2dc5b38da9c0df243832199c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;true&lt;/code&gt; iff &lt;code&gt;member&lt;/code&gt; exists and is static.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="873cb5b33a579701b5fe0d3c103392dc3bf3a28d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;true&lt;/code&gt; iff all types &lt;code&gt;T&lt;/code&gt; are the same.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a6b6da9695a900a242b2f7d02cd85c2472b5dfc1" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;true&lt;/code&gt; iff ready to call &lt;code&gt;dmd.statementsem.makeTupleForeach&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1351a06c681ea01bec618f6884bbd34de37b7523" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;true&lt;/code&gt; iff the type &lt;code&gt;T&lt;/code&gt; can be tested in an &lt;code&gt; if&lt;/code&gt;-expression, that is if &lt;code&gt;if (pred(T.init)) {}&lt;/code&gt; is compilable.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cbc3cedfb1abd592f57b3f79cdab586da17c3d3b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;true&lt;/code&gt; in case the permutation worked, &lt;code&gt;false&lt;/code&gt; in case &lt;code&gt;perm&lt;/code&gt; had more digits in the factorial number system than range had elements. This case must not occur as this would lead to out of range accesses.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fd7e986aa9a43e1d6abe499e7204cd25c3bfab21" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;true&lt;/code&gt; on success and &lt;code&gt;false&lt;/code&gt; on failure</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="849941da8f86be5e40746a14f2e59a072ae48a82" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;true&lt;/code&gt; upon success, &lt;code&gt;false&lt;/code&gt; if memory could not be allocated. In the latter case &lt;code&gt;array&lt;/code&gt; is left unaffected.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="10732ac56ce3f0e5bd6f2a954e9827563a8258a5" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;true&lt;/code&gt; upon success, &lt;code&gt;false&lt;/code&gt; if memory could not be reallocated. In the latter case &lt;code&gt;arr[$ - delta .. $]&lt;/code&gt; is left with default-initialized elements.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="01b642e31c66a686661a487c4cef012c4988d3b2" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;true&lt;/code&gt; upon success, &lt;code&gt;false&lt;/code&gt; if memory could not be reallocated. In the latter case, the slice &lt;code&gt;array[$ - delta .. $]&lt;/code&gt; is left with default-initialized elements.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1599a1c8f77f5355dd6f302974ae6e748423331a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;true&lt;/code&gt;, if the function has the list of attributes attached and &lt;code&gt;false&lt;/code&gt; otherwise.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e74013817c4f54e852c614b55224f04ed73cb603" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;typeof(return)&lt;/code&gt; will, when inside a function scope, give the return type of that function.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="401c131af329fb39ea8b1f78929613004978cd51" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;typeof(this)&lt;/code&gt; will generate the type of what &lt;code&gt;this&lt;/code&gt; would be in a non-static member function, even if not in a member function.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="779537377c86a249b1949eb047163a4ef1e9694b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;ubyte&lt;/code&gt; becomes &lt;code&gt;char&lt;/code&gt;, &lt;code&gt;ushort&lt;/code&gt; becomes &lt;code&gt;wchar&lt;/code&gt; and &lt;code&gt;uint&lt;/code&gt; becomes &lt;code&gt;dchar&lt;/code&gt;. Type qualifiers are preserved.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0f181d063de1eccb82f86b6c3b7003e8848e5b01" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;unbounded&lt;/code&gt; is a compile-time constant of type &lt;code&gt;size_t&lt;/code&gt; that several parameterized structures in this module recognize to mean &quot;infinite&quot; bounds for the parameter. For example, &lt;code&gt;Freelist&lt;/code&gt; (described in detail below) accepts a &lt;code&gt;maxNodes&lt;/code&gt; parameter limiting the number of freelist items. If &lt;code&gt;unbounded&lt;/code&gt; is passed for &lt;code&gt;maxNodes&lt;/code&gt;, then there is no limit and no checking for the number of nodes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8bc437caf54a4442736a6c2461d4505138f55f91" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;uniform01&lt;/code&gt; offers a faster generation of random variates than the equivalent &lt;code&gt;uniform!&quot;[)&quot;(0.0, 1.0)&lt;/code&gt; and so may be preferred for some applications.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5f1669e35822ad6d7a8ef7e1190d0d0a8687f82d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;unsigned long&lt;/code&gt; (or &lt;code&gt;unsigned long long&lt;/code&gt;)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a511ddc689072ede3fe30ef960085644f7eca030" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;unwrap&lt;/code&gt; can be used to extract objects which have been wrapped by &lt;code&gt;wrap&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="45acfa21317d0063756937f5ee8baff7f58f6535" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;upload(&quot;/tmp/downloaded-ftp-file&quot;, &quot;ftp.digitalmars.com/sieve.ds&quot;);&lt;/code&gt; uploads file from file system to URL.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3d60e080a176215c5a1b49107f6911976cc162b2" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;value&lt;/code&gt;, if &lt;code&gt;cast(bool) value&lt;/code&gt; is true. Otherwise, &lt;code&gt;new ErrnoException(msg)&lt;/code&gt; is thrown. It is assumed that the last operation set &lt;code&gt;errno&lt;/code&gt; to an error code corresponding with the failed condition.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a27040952215ed3b860dd4df6cc49b621ae01b6c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;value&lt;/code&gt;, if &lt;code&gt;cast(bool) value&lt;/code&gt; is true. Otherwise, depending on the chosen overload, &lt;code&gt;new Exception(msg)&lt;/code&gt;, &lt;code&gt;dg()&lt;/code&gt; or &lt;code&gt;ex&lt;/code&gt; is thrown.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="89ce2b9510af56abd276e49fc0c6896c8c2ee1ec" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;void __aggrPostblit()&lt;/code&gt;. If a struct has an explicitly defined postblit and at least 1 struct member that has a postblit (explicit or implicit) an aggregated postblit is generated which calls &lt;code&gt;__fieldPostblit&lt;/code&gt; first and then &lt;code&gt;__postblit&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a7d412974083659735c5bf3a9a43ad6ac9e004c7" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;void __fieldPostblit()&lt;/code&gt;. If a struct &lt;code&gt;X&lt;/code&gt; has at least one &lt;code&gt;struct&lt;/code&gt; member that in turn defines (explicitly or implicitly) a postblit, then a field postblit is generated for &lt;code&gt;X&lt;/code&gt; that calls all the underlying postblits of the struct fields in declaration order.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="43cee24221eb62cef3e2c687882ab5a08633aff2" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;void __postblit()&lt;/code&gt;. The compiler assigns this name to the explicitly defined postblit &lt;code&gt;this(this)&lt;/code&gt; so that it can be treated exactly as a normal function. Note that if a struct defines a postblit, it cannot define a function named &lt;code&gt;__postblit&lt;/code&gt; - no matter the signature - as this would result in a compilation error due to the name conflict.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dc6d1a9f79c3a9d7761e5aff58d0729c99ffc5b0" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;void __xpostblit()&lt;/code&gt;. The field and aggregated postblits, although generated for a struct, are not actual struct members. In order to be able to call them, the compiler internally creates an alias, called &lt;code&gt;__xpostblit&lt;/code&gt; which is a member of the struct and which points to the generated postblit that is the most inclusive.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="25815dc372c3c73661b0a266b38876dd6894ac4c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;void*&lt;/code&gt;, catch handler code</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="18c0cd3b31df7367a71c75205c8ae819cf902d5c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;void[]&lt;/code&gt; is formatted like &lt;code&gt;ubyte[]&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="879559c0d4c10d9f1613c9c2ea4e1ebd13338b46" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;walkLength(src) &amp;lt;= walkLength(tgt)&lt;/code&gt;. This precondition will be asserted. If you cannot ensure there is enough room in &lt;code&gt;tgt&lt;/code&gt; to accommodate all of &lt;code&gt;src&lt;/code&gt; use &lt;a href=&quot;#moveSome&quot;&gt;&lt;code&gt;moveSome&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9fa5adcc8bbbe8c7dbc689f02b582cfbdc6e2b7a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;wchar_t&lt;/code&gt; (when &lt;code&gt;sizeof(wchar_t)&lt;/code&gt; is 2)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4068d60126f19ea07b4c62829deefe17a30c0b36" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;wchar_t&lt;/code&gt; (when &lt;code&gt;sizeof(wchar_t)&lt;/code&gt; is 4)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2b068e31aeae500c9824222981eba3a5720d1923" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;x86_64&lt;/code&gt; adds these additional registers.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="65ad3e1a76ad32463dc9020237a5d914d2d31a09" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;x&lt;/code&gt; rounded to an integer value</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1a8b8f719d68c5db31ae5c5b532606293873c9f6" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;x&lt;/code&gt; to the power &lt;code&gt;n&lt;/code&gt;, modulo &lt;code&gt;m&lt;/code&gt;. The return type is the largest of &lt;code&gt;x&lt;/code&gt;'s and &lt;code&gt;m&lt;/code&gt;'s type.  The function requires that all values have unsigned types.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b0a4cffb76a02e21c3feea7c78cbcb8a08519c85" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;zip&lt;/code&gt; is powerful - the following code sorts two arrays in parallel:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="459db4250d5bf26b0be3b8f2acabeedcdb7411ca" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;zip&lt;/code&gt; is similar to &lt;a href=&quot;#lockstep&quot;&gt;&lt;code&gt;lockstep&lt;/code&gt;&lt;/a&gt;, but &lt;code&gt;lockstep&lt;/code&gt; doesn't bundle its elements and uses the &lt;code&gt;opApply&lt;/code&gt; protocol. &lt;code&gt;lockstep&lt;/code&gt; allows reference access to the elements in &lt;code&gt;foreach&lt;/code&gt; iterations.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1ef6339fb889601443d9770b014f952cfe5e025f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;|&lt;/code&gt;&lt;code&gt;=&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;|&lt;/code&gt;&lt;code&gt;=&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="3a7b5c722aed22925a460482c6466ebf4260e520" translate="yes" xml:space="preserve">
          <source>&lt;em&gt; Access &lt;/em&gt;</source>
          <target state="translated">&lt;em&gt; Access &lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="bc30681a7eae3ef70207f0d141b2a462299b888b" translate="yes" xml:space="preserve">
          <source>&lt;em&gt; Algorithms &amp;amp; ranges&lt;/em&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c095a8951c487c309f82861a4f4ba04ba2d45500" translate="yes" xml:space="preserve">
          <source>&lt;em&gt; Array manipulation&lt;/em&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d0bc0ed5b74d5a0db56a0d91a4a4797dbf06a96d" translate="yes" xml:space="preserve">
          <source>&lt;em&gt; Capacity &lt;/em&gt;</source>
          <target state="translated">&lt;em&gt; Capacity &lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="0b8d298cf54c59ef00375c100cdfb8d6246ef00c" translate="yes" xml:space="preserve">
          <source>&lt;em&gt; Containers&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt; Containers&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="94395c48227e3036d6b3e6673878c713799d0dc8" translate="yes" xml:space="preserve">
          <source>&lt;em&gt; Data formats&lt;/em&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="92ffb86b899cbe82077812e59698e2b2dac9aa46" translate="yes" xml:space="preserve">
          <source>&lt;em&gt; Data integrity&lt;/em&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fc68b0afd4817d6d1bd5753f9fce96373cab87a4" translate="yes" xml:space="preserve">
          <source>&lt;em&gt; Date &amp;amp; time&lt;/em&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8b2d246f9ef73764d6765ea2cf5aff25de8a3b56" translate="yes" xml:space="preserve">
          <source>&lt;em&gt; Exception handling&lt;/em&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b6c2a4f16f0034306a7ee08545b129367c57d55b" translate="yes" xml:space="preserve">
          <source>&lt;em&gt; External library bindings&lt;/em&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e6c17ec0940f424ec5767e37367bc5ed3d9144b6" translate="yes" xml:space="preserve">
          <source>&lt;em&gt; Functions&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt; Functions&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="e3cec7e3fb7e40acf8687eb1f9231ecb635e5486" translate="yes" xml:space="preserve">
          <source>&lt;em&gt; High level&lt;/em&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6c816329c6776a07d0287baa6e3483feaede6b41" translate="yes" xml:space="preserve">
          <source>&lt;em&gt; I/O &amp;amp; File system&lt;/em&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f75118f780d0ae77b25ca4b32d07c19523d14214" translate="yes" xml:space="preserve">
          <source>&lt;em&gt; Interoperability&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt; Interoperability&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="a93e169344d9e4b578679263af9c3ac09d6ee1ea" translate="yes" xml:space="preserve">
          <source>&lt;em&gt; Iteration &lt;/em&gt;</source>
          <target state="translated">&lt;em&gt; Iteration &lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="0fa3d22678c42ecb9ef7abc360e4b4f19eb19127" translate="yes" xml:space="preserve">
          <source>&lt;em&gt; Low level &lt;/em&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dccbd3fd9070ee1b3641cbf486f64a3b2200d84b" translate="yes" xml:space="preserve">
          <source>&lt;em&gt; Memory management&lt;/em&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="09a5c6f5efe26853892ad44c63201a6603c81a23" translate="yes" xml:space="preserve">
          <source>&lt;em&gt; Metaprogramming&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt; Metaprogramming&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="1e883194753e4ca161843ed4c9237dabce84b58e" translate="yes" xml:space="preserve">
          <source>&lt;em&gt; Modifiers &lt;/em&gt;</source>
          <target state="translated">&lt;em&gt; Modifiers &lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="847ecfd8ae03468bd0625c64f67549550880f970" translate="yes" xml:space="preserve">
          <source>&lt;em&gt; Multitasking&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt; Multitasking&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="6d0d417d2ad372e46c5080908386cd9255303ad7" translate="yes" xml:space="preserve">
          <source>&lt;em&gt; Networking&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt; Networking&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="38eae575d1a7828c72f73af9d9797c05a26ddbb6" translate="yes" xml:space="preserve">
          <source>&lt;em&gt; Numeric&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt; Numeric&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="33af9b4935b253ac84014f9f785f136db3c78d1f" translate="yes" xml:space="preserve">
          <source>&lt;em&gt; Operations &lt;/em&gt;</source>
          <target state="translated">&lt;em&gt; Operations &lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="6a477843bafc9ce02245ad5f41eddd8012f73621" translate="yes" xml:space="preserve">
          <source>&lt;em&gt; Paradigms&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt; Paradigms&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="c499ab97bed7f2f3212ddbef25a6f926b3a369dd" translate="yes" xml:space="preserve">
          <source>&lt;em&gt; Publicly imported functions&lt;/em&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="84f09ad7796ccc3798e30ab53b927446ab2753a4" translate="yes" xml:space="preserve">
          <source>&lt;em&gt; Runtime utilities&lt;/em&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="53e9f46dc618afd51e3c2220ffc47610b3bd4e7d" translate="yes" xml:space="preserve">
          <source>&lt;em&gt; String manipulation&lt;/em&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="146cea4c54149c952b53a0477e6ff85e0e29beb6" translate="yes" xml:space="preserve">
          <source>&lt;em&gt; Type manipulations&lt;/em&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fb940b2b4b3bd08198a84bc673ba50b694c644b7" translate="yes" xml:space="preserve">
          <source>&lt;em&gt; Types&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt; Types&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="4ae4efd4b54d81f463d5fd325dc5a206f87e9a2c" translate="yes" xml:space="preserve">
          <source>&lt;em&gt; Vector programming&lt;/em&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="783ba461fe8c666b24948cbe429f77043b171614" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Digest&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;Digest&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="84f1bd19e3ec4781ade0f748a2af4b8c1dcda431" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Enable support for backticks, tildes and other code languages with the &lt;code&gt;-preview=markdown&lt;/code&gt; compiler flag.&lt;/em&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1b14bb400fad8a7fda4989cb98829046ab5883e6" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Enable this feature with the &lt;code&gt;-preview=markdown&lt;/code&gt; compiler flag.&lt;/em&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cad9826a40d7cac0dd92d79018b3a425cec01f08" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;ILLEGAL&lt;/em&gt; http version</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="84d700f33fd199df90a3b8e291da9156478a48b4" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;MD5&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;MD5&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="8d1994dff12ffcd867055351a399ba2eff31ce9d" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;MD5Digest&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;MD5Digest&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="ed4f96e25a72b758be38a8a066ce0bd22cfaee2b" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;RIPEMD160&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;RIPEMD160&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="99519fd2ab2e235270c1d71519b6d68c3fdb2e11" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;RIPEMD160Digest&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;RIPEMD160Digest&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="294dfbe626cd1401cd15424ac601518cbfe69a29" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;SHA1&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;SHA1&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="091d02fc9acad31c2d4e52ba53a8bf23e8c3403e" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;SHA1Digest&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;SHA1Digest&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="274ac3a3f91608d104539ec7c821c012efd92d78" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;aaa&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;aaa&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="7588babd4f0b2b7ae02e8880206eb18207292a1d" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;aad&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;aad&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="4df783b6d180de03478089805a881105f3cadd42" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;aam&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;aam&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="8d02f41518030b8787ab09bbea0a8d67d8426530" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;aas&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;aas&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="df4a4818708fc3de9efbe8d2eb2f496a975c1a29" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;adc&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;adc&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="6c5258bbe828a82728cc4ed33fa5b2a769a9f041" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;add&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;add&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="669607c013d13851e9589948d41c8ff14803f058" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;addpd&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;addpd&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="d4555a11aa4a3dc0d73314fed52e2c5863033ff0" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;addps&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;addps&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="603663458993a35a03f85b569f99582519b45931" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;addsd&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;addsd&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="d640f13a3f982b14dfddae136cc30f4cc82defea" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;addss&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;addss&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="171f846452747ed33bb422ca28d951e546292754" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;addsubpd&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;addsubpd&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="8fb1f304ece6367db702ee1a1bd5e2e4ab270e78" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;addsubps&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;addsubps&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="692844e1de9cbe71308e5612ae3e4cfc42de8708" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;and&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;and&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="f1f43e4d115e5a8a4c15ca434debeead3baab0d6" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;andnpd&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;andnpd&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="8ab94df34718b1bba3e84a58a1097218a1c7daf4" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;andnps&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;andnps&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="348d3191a05390d9cbad6ec44be415d8a1f0c000" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;andpd&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;andpd&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="aae24f7e7b696be2067e4ada439be0d551196469" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;andps&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;andps&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="e829bd0db8a8d33136116a19e0cb91efb0b02804" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;arpl&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;arpl&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="5db72c532589bf65d9ff177f7cd70a982f45a812" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;bound&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;bound&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="f2be76e7e30b8c49dd60bf29e87be13fdcab0454" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;bsf&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;bsf&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="7b797add93629d108f13ec585c788c0765e24409" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;bsr&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;bsr&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="09941d8edc03eb4f1479d6812e75a5f9cb78a645" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;bswap&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;bswap&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="ef6ed5d5231a531322255b844105cc5a57b1bc9c" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;bt&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;bt&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="741afc5feebc49fac328e2d55f1a5c6ebff8d914" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;btc&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;btc&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="72c37b8037304d3804e9927a88808a7c2f3ff260" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;btr&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;btr&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="e9e6ff86043a18a24c45d6aa76459fca75c116f6" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;bts&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;bts&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="a052cef3cc75f4db6315362acf22bfb2a0ffc8de" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;call&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;call&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="bc4e83871d6ca7b2eae6ae34476224eb2a912d01" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;capitalize&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;capitalize&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="8e0a35bbbcb6c86e72803d7111f1104aec236e63" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;cbw&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;cbw&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="b00bd98a17914276ba79dc6cd2f88a2474947cf1" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;cdq&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;cdq&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="e411be14fa5b56d5473617085fb4f0f4e3f7f36a" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;clc&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;clc&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="c00b6efa8c41835d737883544aa4bd41a660c9cb" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;cld&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;cld&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="848176d9242b520847d62dab0614e19f0dfb838d" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;clflush&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;clflush&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="c42d55ab12598b1bf7aca3776823b3d972284753" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;cli&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;cli&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="21eb9e5400447b8eed598b33915f4edb69478f62" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;clts&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;clts&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="b92aae5a57b2d06a48ce9e2daee0b70462c3965b" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;cmc&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;cmc&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="c6598c355738b0e360ba72ab86a54034892e816e" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;cmova&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;cmova&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="b03d2c951078153df871053f41018e8a7b055cb5" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;cmovae&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;cmovae&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="4129bdf5c54904383733140a3007452ccb97565a" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;cmovb&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;cmovb&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="1cc9172ddde5c38ce8c9f2fc625d0972979daa82" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;cmovbe&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;cmovbe&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="111e40dc4dfb04ec36c00e42a1a4469348f82e4f" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;cmovc&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;cmovc&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="4f78f56f5202094d19c9cfdf6728e9c684c46595" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;cmove&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;cmove&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="28441e770e85047a6c2abde03c02dc4bcae4d746" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;cmovg&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;cmovg&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="e0760d8c0f127239224a2bd5f35590ec8219bac3" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;cmovge&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;cmovge&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="3a27e2c4593e0d03a1930313afc14818fa014fbb" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;cmovl&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;cmovl&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="2989760e44dd4610b656a586a38b758185a79da7" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;cmovle&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;cmovle&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="7eb8390f413a550cb5f26327a8b3e97227e986e1" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;cmovna&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;cmovna&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="6e0dce8da3413b2fff4db97f460ea86bb850160d" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;cmovnae&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;cmovnae&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="8108b390f996ade5bee82f21813712772e3e5150" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;cmovnb&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;cmovnb&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="961409e858105693ff6e506a9fe09ddb85a1d9f1" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;cmovnbe&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;cmovnbe&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="e8ec2f5e6988d878bdcf0aa1f9abc88741d0e360" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;cmovnc&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;cmovnc&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="50bf45bb0404fc35cdd05e6a8f1086df7950ac47" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;cmovne&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;cmovne&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="06f747ed13ab2f2758ef319eb71920fd8f9a07fd" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;cmovng&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;cmovng&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="233166e6f6cc3f3c42e69dc03585a77158547670" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;cmovnge&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;cmovnge&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="d5f5c1e1d55eaf8f6555c0b6ebd01408d4014b24" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;cmovnl&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;cmovnl&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="d80091b5d9155625d0b4637ebae7a5e79c8718c3" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;cmovnle&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;cmovnle&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="f809a792dade42d8e9aca29d939269d6acc0c33a" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;cmovno&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;cmovno&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="5c5ae7612eee3a042ecfba8dd4d5201ef4709701" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;cmovnp&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;cmovnp&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="b93a97c2d6edfa89df3b90ad343d54aa44d58c51" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;cmovns&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;cmovns&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="064baaadd28f66c9a3583b8b61cd1a7f6b7bb720" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;cmovnz&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;cmovnz&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="c2ebd1a04852a74a4bf46bbe4d0242d136cd7fd9" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;cmovo&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;cmovo&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="c342c00f9155332857d93ef6805653ed9bacce09" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;cmovp&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;cmovp&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="97bac93bf4acbf2b992e27a64f08e567f0a113d0" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;cmovpe&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;cmovpe&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="86916e0031a3000ceff8db848b020b20ecd5a05c" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;cmovpo&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;cmovpo&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="bb9ce11f371fd4b2affd007558aa4e5e625ff8a0" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;cmovs&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;cmovs&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="a9604d101d312f98cbe257cccd691e5a0c31b2d7" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;cmovz&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;cmovz&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="6fd90bd9e4d1a433718ea1b68a8bb195571a7696" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;cmp&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;cmp&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="1cee5d7e8fcf38f1e3f065e891ae4cd9e8bd5be8" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;cmppd&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;cmppd&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="1e272176453fec8068368eed364102b1d225e7cd" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;cmpps&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;cmpps&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="6ce8db169aeeb9c89c2500e9b0b80e227974e6d6" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;cmps&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;cmps&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="6599c4c2d9ecb33f234e07c89bd4905d1b51e2b6" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;cmpsb&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;cmpsb&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="730f8126d0cf3675bf5b4c23998d30b19da1b487" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;cmpsd&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;cmpsd&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="2b21cb9e8933715b3ccd4d7a20e199590cec3818" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;cmpss&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;cmpss&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="fc0ad81c58c54c0d21ff0bdd053a7938368acdd4" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;cmpsw&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;cmpsw&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="e487c5f81006bc807e464143803badf158e6eddd" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;cmpxchg16b&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;cmpxchg16b&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="2f611050434a367a257b162eac17b4e2ef228d77" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;cmpxchg8b&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;cmpxchg8b&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="d498a2a43552a13063aa8894b9d1f17bee883670" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;cmpxchg&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;cmpxchg&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="cf58d302adc914b53e05998342d1661e161682e4" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;comisd&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;comisd&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="1bcf4cdf2222de470f5e2d9fbec06f695b7015d3" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;comiss&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;comiss&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="696f1015ca54a71bb83a44adebeed3728fe79275" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;cpuid&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;cpuid&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="b23c8423a7464aa9f278e00c526c0e7e149025c2" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;cvtdq2pd&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;cvtdq2pd&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="efb02186e74b91308bd79679c50c0efa595d5497" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;cvtdq2ps&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;cvtdq2ps&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="4e84b87118765de1da2fa66f186ffce7dfa9bbcb" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;cvtpd2dq&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;cvtpd2dq&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="60a3c073c2f273460c2e57ce0c75760b5b3c4513" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;cvtpd2pi&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;cvtpd2pi&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="4a3174aa806386b4d63772a7779fd8d2723df2a1" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;cvtpd2ps&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;cvtpd2ps&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="7519f3e2217487943b6c7c5106e4b943fa6e93b9" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;cvtpi2pd&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;cvtpi2pd&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="edc02a38a5b509554a8e0c90958e2209fd2e47be" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;cvtpi2ps&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;cvtpi2ps&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="57148a528d5075133b7af32f7eb1dfc6c9b78f23" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;cvtps2dq&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;cvtps2dq&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="3c263f20996de047aa56dd524d8fb912231403d6" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;cvtps2pd&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;cvtps2pd&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="ab7b2f1525535e426d09536867a145d357aec9c6" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;cvtps2pi&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;cvtps2pi&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="f1e2cc4b6ab4ccaf4a17041f6fa7b19209c229c3" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;cvtsd2si&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;cvtsd2si&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="0753b31c2ebb6c699cf5ebbbe000f08b2c5ab6e3" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;cvtsd2ss&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;cvtsd2ss&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="653583a9827218258f05df8e578f57daef9c87e5" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;cvtsi2sd&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;cvtsi2sd&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="874dea0f119c5edefcbe663654becb7e467bacf7" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;cvtsi2ss&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;cvtsi2ss&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="91322f99d4ac646d89b3f3f22c92d063f1d9d9d8" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;cvtss2sd&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;cvtss2sd&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="f308c1714555cde3135a09c2eac0944e1976a186" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;cvtss2si&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;cvtss2si&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="7b5810df70b4d9fabb0959e092847b418ae89d42" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;cvttpd2dq&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;cvttpd2dq&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="de17c417723497cf080e69f80bfcb8266fe9c0a0" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;cvttpd2pi&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;cvttpd2pi&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="3d5a8c0d32d62f8e239f763a8bb7c3351d0cddfc" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;cvttps2dq&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;cvttps2dq&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="7d54f5c169cd5fa3a152f4c4c8fd49778d89a2e0" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;cvttps2pi&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;cvttps2pi&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="97a4476a098b695765aa30ed12bc938dc44be2bb" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;cvttsd2si&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;cvttsd2si&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="3b88e3e55088a8855b1d0cecde751d72147ae482" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;cvttss2si&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;cvttss2si&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="669caaf5697e7d34fe62e05c80eb1402f1b950d6" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;cwd&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;cwd&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="31d6e7bd19fff86ce479820670b88ccf96b5130d" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;cwde&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;cwde&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="4e190ea7235dc0b20321199790eb30a3b953bbf0" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;da&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;da&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="4fd5b1a04d5951a7161e8c80a1d1373d2e082f25" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;daa&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;daa&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="73862bf3a5db403d402fdda6bff131bda683789c" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;das&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;das&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="888130835893ad0a4431b9e92e3bfb28c0d22d4f" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;db&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;db&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="37c1cbf29cfb5fb2d44ec24cde2861f1da38ab8c" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;dd&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;dd&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="e9f9ba688190888c6b4c8520163db67896658b42" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;de&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;de&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="c29343d6460a115a15c26a9fbe97cd46103cf4e3" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;dec&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;dec&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="d28e76d5ed75ae63c85b82cbc4e7e0e23009a39b" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;df&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;df&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="0e572dc634afc4215c76a3e18c98cd025090a954" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;di&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;di&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="832fe89e924c6f3f13f9319cb3470edfe51828bb" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;div&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;div&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="d8f67b0ba552607c0058389064ef22f24b888ce1" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;divpd&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;divpd&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="5405ff76508aa21c6049fd100b06e269f333124c" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;divps&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;divps&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="854d3262d677f6d1b9742af9731f5867a0b6fc4f" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;divsd&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;divsd&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="978211ee9b084908c11af536af9b99083351e71f" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;divss&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;divss&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="0137168f13119693a3164c917ddc72456310cbd1" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;dl&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;dl&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="c77490a0ba7588468cde78b2c7a3043fbad2438e" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;dq&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;dq&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="525f6057c83f7eafc09911773afe33e2d6e69f03" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;ds&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;ds&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="b90c84183fa55ef436c644a46ed425ec0335c9b6" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;dt&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;dt&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="09b7b7be48bc35b1be992df90414e882eb518d15" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;dw&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;dw&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="29c94bac6bb9031553e222e8503286f13713a2fe" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;emms&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;emms&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="d55c80f8c3e2ef8ce62d005de09e75e2ad916cec" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;enter&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;enter&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="338a12659fc0906399eb38fbe822015ca2962483" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;f2xm1&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;f2xm1&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="d55da3aaf092d8ff5828840252d69e8f06057dfd" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;fabs&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;fabs&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="630642bd09a59dff2a7ec932ea825151397adb5d" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;fadd&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;fadd&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="fa7fd23fe9f5f8ffab12444e35caea778c8558c0" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;faddp&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;faddp&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="b13e208f8ada129c4f82a0b45b8df9524f95774a" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;fbld&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;fbld&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="ec366ca140bae33b5e13019b0951cb511ad62f5e" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;fbstp&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;fbstp&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="e8292637dfa3fc477abdaf3b73d14b1b81cad934" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;fchs&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;fchs&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="30b2330c517611309fdcd480cf9450e5ca99c799" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;fclex&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;fclex&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="272678e667b446eed0a53765d1b139eddf95e6c1" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;fcmovb&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;fcmovb&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="4943a4b1ac0b9695f840e0990a71322d1bdbb74d" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;fcmovbe&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;fcmovbe&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="1da960602e6701c419e908c314a3b0f7b7bc9335" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;fcmove&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;fcmove&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="147f757a6e690cc5a0ac918c9ce28e3210557b74" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;fcmovnb&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;fcmovnb&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="3a711cb3ea7dd3846afe1244c76cda9369573210" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;fcmovnbe&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;fcmovnbe&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="1e42316dbc4457ea190a4026fe77e942616b11a4" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;fcmovne&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;fcmovne&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="74e2f5fad7f28ed432793a9bd55e627fcca69400" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;fcmovnu&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;fcmovnu&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="d6a1452b2302113a9bbfec4f4ac925533b08339b" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;fcmovu&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;fcmovu&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="4169e501ef550c4a5b35fc7e0a81823b4bea5cc6" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;fcom&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;fcom&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="f94fea85ac3e4cca049dc5fc8873ffc0cc4531a9" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;fcomi&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;fcomi&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="1d2fa4a0e8c96221feee8d1af2796994fadb3f17" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;fcomip&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;fcomip&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="f7f4be0d977cfd2c7d9be4e37a2658fc7ae09954" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;fcomp&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;fcomp&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="61953b004b222a98cbac3832568ff4c3e125d363" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;fcompp&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;fcompp&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="7a3016870eb6ea33a2181dfbb12af36ac7162e15" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;fcos&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;fcos&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="5256fe9cd0505c25d40df2dd34c4fb0c4c1c88ec" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;fdecstp&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;fdecstp&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="54d647d43192d34a249866a822da1c83b8fffb80" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;fdisi&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;fdisi&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="f968e2a24ff5d98b75bafa35613142ba2a5fb2dc" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;fdiv&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;fdiv&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="80afbcd1063d4d2d44dbf986de74a4de9929582e" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;fdivp&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;fdivp&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="f26bbbd4b2589aefcca64acee991404b7c0b0ef2" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;fdivr&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;fdivr&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="27abc8ec360b84a1d9367a1f7ba7ee6ef6945ead" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;fdivrp&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;fdivrp&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="ec12165dd788fabfadd5db4dff2dd277509f9cb4" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;feni&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;feni&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="9f6b7ac93301006ed079309add1f24467004ccf6" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;ffree&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;ffree&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="3e72458117bbe2c3b9ee4bee1c71c63ce34ce702" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;fiadd&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;fiadd&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="92603e707d992825da8bfe8d97f800084bf73f77" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;ficom&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;ficom&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="e351165fae08d8cb1630ef63f0e3aa79d72f0acd" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;ficomp&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;ficomp&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="9530aa35cfdd1951c5239b0d8f37c524d47ae5b1" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;fidiv&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;fidiv&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="a09143b334c24103163bd13ef22aaa5ed84d7937" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;fidivr&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;fidivr&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="6066b28ced7c2c9ffe41737f08b755fee8c96eed" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;fild&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;fild&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="c3d28cb1eff4d97491263cbc3ee67f81a29bd978" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;fimul&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;fimul&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="f44ea8121c3aa8b53ee0259264bfe93c08c90d93" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;fincstp&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;fincstp&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="68c83d3bde1ec17d87167aff95de4af61a0e04c4" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;finit&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;finit&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="576094f961b66284a1b26cc6701cfd315ae4267f" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;fist&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;fist&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="ec92f1294f1e5869a5d6b797160875b09122a8ee" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;fistp&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;fistp&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="472c15aaab864a990d0f2d7383de908594e96a82" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;fisttp&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;fisttp&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="ce220bfa1001aee727eca0c7a990da0b739e1cd1" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;fisub&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;fisub&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="b4fe6a5088328bd66b46a5a3e12559b987d09481" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;fisubr&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;fisubr&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="c514e32e5192413c1a440acb5ac7a27cb0943804" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;fld1&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;fld1&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="67eb1c250feea2b0518f659ecaef98d2b151b8fa" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;fld&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;fld&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="4d610ec17fa42a8d83dde0e05982d71d28403ae8" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;fldcw&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;fldcw&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="b89d66b88f015b633678fb03f278b700b88769bf" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;fldenv&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;fldenv&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="bde7d099ccb0a4d7201c802f4fff25e4f181ace6" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;fldl2e&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;fldl2e&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="4a348450fd48d9a73cac5abcc7014f079ee7b811" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;fldl2t&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;fldl2t&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="81d85908bbf6bcd4f6cd9702fa3f0a0b34c0ab0a" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;fldlg2&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;fldlg2&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="64c5150d4745c083cb16f42001023b178818db6b" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;fldln2&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;fldln2&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="2d910bca5c4a5d5a4504f508f00036de3e13f574" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;fldpi&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;fldpi&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="e444efb4c135c238da06dae03ca9f3af57e21e73" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;fldz&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;fldz&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="d1bba05f92dc17efe9d2e940bebecf73ba5926f7" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;fmul&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;fmul&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="9cd5e540b232ca2010803382fa74fa19c256f03c" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;fmulp&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;fmulp&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="90d6d5baee2388054162cdd30ebd626602967dbd" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;fnclex&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;fnclex&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="01700ce2e4c58c6176b09ac024cd38cff98916e7" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;fndisi&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;fndisi&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="53b49e3c31324c2d22284744506e29887f8d0837" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;fneni&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;fneni&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="3356f8dd4b08eddfa80b91fd0c7f1f063ed37354" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;fninit&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;fninit&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="4174d07a9a7a8adb3e9a59b7658dd1d19b698a9b" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;fnop&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;fnop&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="ff9dacc7e0eefb8614aedd85c1e08b4da47523a0" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;fnsave&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;fnsave&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="df73274afb62337e465bbb43b80df984eeca3b1f" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;fnstcw&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;fnstcw&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="cc7138deb7befbde0f49fbb2598860ba8fa9cb6d" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;fnstenv&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;fnstenv&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="eb9e5ccae7908256580150a87796462458a5f5dd" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;fnstsw&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;fnstsw&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="0726dd18fa2eded64d13ec237ced32b0ccfdff63" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;fpatan&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;fpatan&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="7fd238bdf767aa0cdde1981303d12a31b77b69ec" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;fprem1&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;fprem1&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="34f6d303818f2891b67670e9676be89b8e2ed92f" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;fprem&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;fprem&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="4fc5e4a83e4d6ff73cc4fa7dc0dc61299be67237" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;fptan&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;fptan&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="aae639c4f808bc44916ce8a97c646415d3873018" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;frndint&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;frndint&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="e753f0b44f4c446a9c470c4097a50422e12ed2fb" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;frstor&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;frstor&lt;/em&gt;</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
