<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="d">
    <body>
      <group id="d">
        <trans-unit id="40c8a933628c77ca08e491a5b2e22d9b1ce4fde0" translate="yes" xml:space="preserve">
          <source>Composition of allocators is not recommended at this level due to inflexibility of dynamic interfaces and inefficiencies caused by cascaded multiple calls. Instead, compose allocators using the static interface defined in &lt;a href=&quot;std_experimental_allocator_building_blocks&quot;&gt;&lt;code&gt;std.experimental.allocator.building_blocks&lt;/code&gt;&lt;/a&gt;, then adapt the composed allocator to &lt;code&gt;ISharedAllocator&lt;/code&gt; (possibly by using &lt;a href=&quot;#CSharedAllocatorImpl&quot;&gt;&lt;code&gt;CSharedAllocatorImpl&lt;/code&gt;&lt;/a&gt; below).</source>
          <target state="translated">동적 인터페이스의 융통성 및 계단식 다중 호출로 인한 비 효율성으로 인해이 레벨에서 할당 자의 구성은 권장되지 않습니다. 대신 &lt;a href=&quot;std_experimental_allocator_building_blocks&quot;&gt; &lt;code&gt;std.experimental.allocator.building_blocks&lt;/code&gt; 에&lt;/a&gt; 정의 된 정적 인터페이스를 사용하여 할당자를 구성한 다음 작성된 할당자를 &lt;code&gt;ISharedAllocator&lt;/code&gt; 에 맞게 조정하십시오 ( 아래 &lt;a href=&quot;#CSharedAllocatorImpl&quot;&gt; &lt;code&gt;CSharedAllocatorImpl&lt;/code&gt; &lt;/a&gt; 사용 ).</target>
        </trans-unit>
        <trans-unit id="d7b50cb2c8713f1b5ca6e3a46afeecbf46654a4a" translate="yes" xml:space="preserve">
          <source>Composition of allocators is not recommended at this level due to inflexibility of dynamic interfaces and inefficiencies caused by cascaded multiple calls. Instead, compose allocators using the static interface defined in &lt;a href=&quot;std_experimental_allocator_building_blocks&quot;&gt;&lt;code&gt;std.experimental.allocator.building_blocks&lt;/code&gt;&lt;/a&gt;, then adapt the composed allocator to &lt;code&gt;RCIAllocator&lt;/code&gt; (possibly by using &lt;a href=&quot;#allocatorObject&quot;&gt;&lt;code&gt;allocatorObject&lt;/code&gt;&lt;/a&gt; below).</source>
          <target state="translated">동적 인터페이스의 융통성 및 계단식 다중 호출로 인한 비 효율성으로 인해이 레벨에서 할당 자의 구성은 권장되지 않습니다. 대신 &lt;a href=&quot;std_experimental_allocator_building_blocks&quot;&gt; &lt;code&gt;std.experimental.allocator.building_blocks&lt;/code&gt; 에&lt;/a&gt; 정의 된 정적 인터페이스 를 사용하여 &lt;a href=&quot;#allocatorObject&quot;&gt; &lt;code&gt;allocatorObject&lt;/code&gt; &lt;/a&gt; 구성한 다음 작성된 할당자를 &lt;code&gt;RCIAllocator&lt;/code&gt; 에 적용하십시오 ( 아래의 allocatorObject 를 사용하여 가능 ).</target>
        </trans-unit>
        <trans-unit id="d600c469ce6615aec4b9ccc9ac99015222a2cd4a" translate="yes" xml:space="preserve">
          <source>Composition of allocators is not recommended at this level due to inflexibility of dynamic interfaces and inefficiencies caused by cascaded multiple calls. Instead, compose allocators using the static interface defined in &lt;a href=&quot;std_experimental_allocator_building_blocks&quot;&gt;&lt;code&gt;std.experimental.allocator.building_blocks&lt;/code&gt;&lt;/a&gt;, then adapt the composed allocator to &lt;code&gt;RCISharedAllocator&lt;/code&gt; (possibly by using &lt;a href=&quot;#sharedAllocatorObject&quot;&gt;&lt;code&gt;sharedAllocatorObject&lt;/code&gt;&lt;/a&gt; below).</source>
          <target state="translated">동적 인터페이스의 융통성 및 계단식 다중 호출로 인한 비 효율성으로 인해이 레벨에서 할당 자의 구성은 권장되지 않습니다. 대신 &lt;a href=&quot;std_experimental_allocator_building_blocks&quot;&gt; &lt;code&gt;std.experimental.allocator.building_blocks&lt;/code&gt; 에&lt;/a&gt; 정의 된 정적 인터페이스를 사용하여 할당자를 구성한 다음 구성된 할당자를 &lt;code&gt;RCISharedAllocator&lt;/code&gt; 에 적용하십시오 ( 아래의 &lt;a href=&quot;#sharedAllocatorObject&quot;&gt; &lt;code&gt;sharedAllocatorObject&lt;/code&gt; &lt;/a&gt; 를 사용하여 가능 ).</target>
        </trans-unit>
        <trans-unit id="b431b82e9bce2d80758c9a0364b1e899b167bca3" translate="yes" xml:space="preserve">
          <source>Compress and return any remaining data. The returned data should be appended to that returned by compress().</source>
          <target state="translated">나머지 데이터를 압축하고 반환하십시오. 반환 된 데이터는 compress ()에 의해 반환 된 데이터에 추가되어야합니다.</target>
        </trans-unit>
        <trans-unit id="6b91383db4a977df84d9d757e34690eb3fc7d851" translate="yes" xml:space="preserve">
          <source>Compress data</source>
          <target state="translated">데이터 압축</target>
        </trans-unit>
        <trans-unit id="a8dc2c07db65d42c9c393d98f8d9729c6beed681" translate="yes" xml:space="preserve">
          <source>Compress the data in buf and return the compressed data.</source>
          <target state="translated">buf로 데이터를 압축하고 압축 된 데이터를 리턴하십시오.</target>
        </trans-unit>
        <trans-unit id="89a75f1668dd36d7548c52993ff9cd9810b43d8a" translate="yes" xml:space="preserve">
          <source>Compress/decompress data using the &lt;a href=&quot;http://www.zlib.net&quot;&gt;zlib library&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;http://www.zlib.net&quot;&gt;zlib 라이브러리를&lt;/a&gt; 사용하여 데이터를 압축 / 압축 해제하십시오 .</target>
        </trans-unit>
        <trans-unit id="80550794074729987ba2c50d10325a6661e3698e" translate="yes" xml:space="preserve">
          <source>Compress/decompress data using the zlib library.</source>
          <target state="translated">zlib 라이브러리를 사용하여 데이터를 압축 / 압축 해제하십시오.</target>
        </trans-unit>
        <trans-unit id="f100b192df1f9c75c6c1d947e071005a9b94874f" translate="yes" xml:space="preserve">
          <source>Compression method used by ArchiveMember</source>
          <target state="translated">ArchiveMember에서 사용하는 압축 방법</target>
        </trans-unit>
        <trans-unit id="26aaa35645fb564b496958b2c50db8717acc133f" translate="yes" xml:space="preserve">
          <source>CompressionMethod</source>
          <target state="translated">CompressionMethod</target>
        </trans-unit>
        <trans-unit id="cbc8d8043da3b003c6d2aff42124a5bad20359c0" translate="yes" xml:space="preserve">
          <source>Compute HMAC digests of arbitrary data.</source>
          <target state="translated">임의 데이터의 HMAC 다이제스트를 계산합니다.</target>
        </trans-unit>
        <trans-unit id="95994e5336c058f341ee7887a377a099034ec411" translate="yes" xml:space="preserve">
          <source>Compute MD5 hash of arbitrary data.</source>
          <target state="translated">임의 데이터의 MD5 해시를 계산합니다.</target>
        </trans-unit>
        <trans-unit id="24baedad0dbc82d64549a5102e14973f3260590c" translate="yes" xml:space="preserve">
          <source>Compute MOD bits matching &lt;code&gt;this&lt;/code&gt; argument type to wild parameter type.</source>
          <target state="translated">&lt;code&gt;this&lt;/code&gt; 인수 타입을 와일드 파라미터 타입에 일치시키는 MOD 비트를 계산 합니다.</target>
        </trans-unit>
        <trans-unit id="081bc30fb0efc1dbeb72897ae1b50df74202f671" translate="yes" xml:space="preserve">
          <source>Compute MurmurHash of arbitrary data.</source>
          <target state="translated">임의 데이터의 MurmurHash를 계산합니다.</target>
        </trans-unit>
        <trans-unit id="4ada77a245b8b65254fa2bd2ec7982197684a020" translate="yes" xml:space="preserve">
          <source>Compute RIPEMD-160 hash of arbitrary data.</source>
          <target state="translated">임의 데이터의 RIPEMD-160 해시를 계산합니다.</target>
        </trans-unit>
        <trans-unit id="0ba34f35a04123a2ebf02b152eea60a361465caa" translate="yes" xml:space="preserve">
          <source>Compute SHA1 and SHA2 hashes of arbitrary data.</source>
          <target state="translated">임의 데이터의 SHA1 및 SHA2 해시를 계산합니다.</target>
        </trans-unit>
        <trans-unit id="59806efe8816bdf113fe5ffcf24b9d67587999dc" translate="yes" xml:space="preserve">
          <source>Compute column number at the end of the printed form of the string, assuming the string starts in the leftmost column, which is numbered starting from 0.</source>
          <target state="translated">문자열이 맨 왼쪽 열에서 시작하고 0부터 시작하여 번호가 매겨진 것으로 가정하면 인쇄 된 문자열 형식의 끝에서 열 번호를 계산하십시오.</target>
        </trans-unit>
        <trans-unit id="39ea6ece3f7ff3bfca84b026b3c00d5558a650d8" translate="yes" xml:space="preserve">
          <source>Compute covariance of parameters &lt;code&gt;this&lt;/code&gt; and &lt;code&gt;p&lt;/code&gt; as determined by the storage classes of both.</source>
          <target state="translated">둘 다의 스토리지 클래스에 의해 결정된 파라미터 &lt;code&gt;this&lt;/code&gt; 및 &lt;code&gt;p&lt;/code&gt; 의 공분산을 계산 합니다.</target>
        </trans-unit>
        <trans-unit id="2899928c342104b102c9fb899b2a19b12b7c6b8f" translate="yes" xml:space="preserve">
          <source>Compute digests such as md5, sha1 and crc32.</source>
          <target state="translated">md5, sha1 및 crc32와 같은 계산 다이제스트</target>
        </trans-unit>
        <trans-unit id="114ac47572e156cc9f60194024ceb062761cf170" translate="yes" xml:space="preserve">
          <source>Compute hash function for Object.</source>
          <target state="translated">Object의 계산 해시 함수입니다.</target>
        </trans-unit>
        <trans-unit id="3b9f081e79f23af8321ffcc88ead6e2e02f25fb6" translate="yes" xml:space="preserve">
          <source>Compute n * 2&lt;sup&gt;exp&lt;/sup&gt;</source>
          <target state="translated">계산 n * 2 &lt;sup&gt;exp&lt;/sup&gt;</target>
        </trans-unit>
        <trans-unit id="605710f35eafe733df0dc2a4c0e73d7c711eb032" translate="yes" xml:space="preserve">
          <source>Compute number of elements for a (possibly multidimensional) static array, or 1 for other types.</source>
          <target state="translated">(다차원) 정적 배열의 경우 요소 수를 계산하거나 다른 유형의 경우 1을 계산하십시오.</target>
        </trans-unit>
        <trans-unit id="23878574338ad4ed6153fe2d2983bb38e8e88560" translate="yes" xml:space="preserve">
          <source>Compute size of a dt</source>
          <target state="translated">dt의 계산 크기</target>
        </trans-unit>
        <trans-unit id="47dd82c7c7297f6f9c8f6783436ccac77ec97b62" translate="yes" xml:space="preserve">
          <source>Compute square root of x.</source>
          <target state="translated">x의 제곱근을 계산합니다.</target>
        </trans-unit>
        <trans-unit id="6810299cd458778af68742dfbad149d1819bc21e" translate="yes" xml:space="preserve">
          <source>Compute the Adler-32 checksum of a buffer's worth of data.</source>
          <target state="translated">버퍼 가치가있는 데이터의 Adler-32 체크섬을 계산합니다.</target>
        </trans-unit>
        <trans-unit id="99c622a401ade4d7e2ebcffe7d148251987300a5" translate="yes" xml:space="preserve">
          <source>Compute the CRC32 checksum of a buffer's worth of data.</source>
          <target state="translated">버퍼에 해당하는 데이터의 CRC32 체크섬을 계산하십시오.</target>
        </trans-unit>
        <trans-unit id="9fe16e5290f537eb58bcbe27dcbb8dabf4bc6163" translate="yes" xml:space="preserve">
          <source>Compute the Fourier transform of range using the &amp;Omicron;(&lt;code&gt;N log N&lt;/code&gt;) Cooley-Tukey Algorithm. &lt;code&gt;range&lt;/code&gt; must be a random-access range with slicing and a length equal to &lt;code&gt;size&lt;/code&gt; as provided at the construction of this object. The contents of range can be either numeric types, which will be interpreted as pure real values, or complex types with properties or members &lt;code&gt;.re&lt;/code&gt; and &lt;code&gt;.im&lt;/code&gt; that can be read.</source>
          <target state="translated">&amp;Omicron; ( &lt;code&gt;N log N&lt;/code&gt; ) Cooley-Tukey 알고리즘을 사용하여 범위의 푸리에 변환을 계산합니다 . &lt;code&gt;range&lt;/code&gt; 동일 슬라이싱 및 길이의 랜덤 액세스 범위이어야 &lt;code&gt;size&lt;/code&gt; 객체의 구성에 제공한다. 범위의 내용은 속성 또는 회원과 순수한 실제 값 또는 복합 유형으로 해석됩니다 중 숫자 형식이 될 수 있습니다 &lt;code&gt;.re&lt;/code&gt; 및 &lt;code&gt;.im&lt;/code&gt; 그 읽을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b471c4955a83035411d5b45de39b1b5e1642da44" translate="yes" xml:space="preserve">
          <source>Compute the sum of binary logarithms of the input range &lt;code&gt;r&lt;/code&gt;. The error of this method is much smaller than with a naive sum of log2.</source>
          <target state="translated">입력 범위 &lt;code&gt;r&lt;/code&gt; 의 이진 로그의 합을 계산합니다 . 이 방법의 오류는 순진 합계 log2보다 훨씬 작습니다.</target>
        </trans-unit>
        <trans-unit id="ff38c1a05c708138b2214f90d4dc1a12310dd41c" translate="yes" xml:space="preserve">
          <source>Compute the value of an integer x, raised to the power of a positive integer n.</source>
          <target state="translated">양의 정수 n만큼 거듭 제곱 한 정수 x의 값을 계산합니다.</target>
        </trans-unit>
        <trans-unit id="4f68d18423d62869cea6398c61a35fc2726681da" translate="yes" xml:space="preserve">
          <source>Compute the value of x &lt;sup&gt;n&lt;/sup&gt;, where n is an integer</source>
          <target state="translated">x &lt;sup&gt;n&lt;/sup&gt; 의 값을 계산합니다 . 여기서 n은 정수입니다.</target>
        </trans-unit>
        <trans-unit id="77fc143961f9dbeaf572c0de2cdcd8820a0f8972" translate="yes" xml:space="preserve">
          <source>Computes &lt;a href=&quot;https://en.wikipedia.org/wiki/Entropy_(information_theory)&quot;&gt;entropy&lt;/a&gt; of input range &lt;code&gt;r&lt;/code&gt; in bits. This function assumes (without checking) that the values in &lt;code&gt;r&lt;/code&gt; are all in &lt;code&gt;[0, 1]&lt;/code&gt;. For the entropy to be meaningful, often &lt;code&gt;r&lt;/code&gt; should be normalized too (i.e., its values should sum to 1). The two-parameter version stops evaluating as soon as the intermediate result is greater than or equal to &lt;code&gt;max&lt;/code&gt;.</source>
          <target state="translated">입력 범위 &lt;code&gt;r&lt;/code&gt; 의&lt;a href=&quot;https://en.wikipedia.org/wiki/Entropy_(information_theory)&quot;&gt;엔트로피&lt;/a&gt; 를 비트 단위로 계산 합니다 . 이 함수는 (확인하지 않고) &lt;code&gt;r&lt;/code&gt; 의 값 이 모두 &lt;code&gt;[0, 1]&lt;/code&gt; 있다고 가정합니다 . 엔트로피가 의미를 갖기 위해서는 종종 &lt;code&gt;r&lt;/code&gt; 도 정규화해야합니다 (즉, 그 값의 합은 1이어야 함). 중간 결과가 &lt;code&gt;max&lt;/code&gt; 이상이되는 즉시 2- 파라미터 버전의 평가가 중지됩니다 .</target>
        </trans-unit>
        <trans-unit id="296843c88206c491563d4a7f5e7016600d230563" translate="yes" xml:space="preserve">
          <source>Computes &lt;a href=&quot;https://en.wikipedia.org/wiki/Euclidean_distance&quot;&gt;Euclidean distance&lt;/a&gt; between input ranges &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt;. The two ranges must have the same length. The three-parameter version stops computation as soon as the distance is greater than or equal to &lt;code&gt;limit&lt;/code&gt; (this is useful to save computation if a small distance is sought).</source>
          <target state="translated">입력 범위 &lt;code&gt;a&lt;/code&gt; 와 &lt;code&gt;b&lt;/code&gt; 사이의 &lt;a href=&quot;https://en.wikipedia.org/wiki/Euclidean_distance&quot;&gt;유클리드 거리&lt;/a&gt; 를 계산합니다 . 두 범위의 길이는 같아야합니다. 3- 파라미터 버전은 거리가 &lt;code&gt;limit&lt;/code&gt; 보다 크거나 같은 즉시 계산을 중지 합니다 (작은 거리를 찾는 경우 계산을 저장하는 데 유용함).</target>
        </trans-unit>
        <trans-unit id="e8687c4446d77dec6b0783c73ae0c35b758b4e36" translate="yes" xml:space="preserve">
          <source>Computes &lt;a href=&quot;https://en.wikipedia.org/wiki/MurmurHash&quot;&gt;MurmurHash&lt;/a&gt; hashes of arbitrary data. MurmurHash is a non-cryptographic hash function suitable for general hash-based lookup. It is optimized for x86 but can be used on all architectures.</source>
          <target state="translated">임의 데이터의 &lt;a href=&quot;https://en.wikipedia.org/wiki/MurmurHash&quot;&gt;MurmurHash&lt;/a&gt; 해시를 계산 합니다. MurmurHash는 일반 해시 기반 조회에 적합한 비 암호화 해시 기능입니다. x86에 최적화되어 있지만 모든 아키텍처에서 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3d1c57bf08f15b670eca8f41ce0168ced47af851" translate="yes" xml:space="preserve">
          <source>Computes Cartesian product of two ranges.</source>
          <target state="translated">두 범위의 데카르트 곱을 계산합니다.</target>
        </trans-unit>
        <trans-unit id="fb193027e232a8b400c045bedc504035cc557cce" translate="yes" xml:space="preserve">
          <source>Computes MD5 hashes of arbitrary data. MD5 hashes are 16 byte quantities that are like a checksum or CRC, but are more robust.</source>
          <target state="translated">임의 데이터의 MD5 해시를 계산합니다. MD5 해시는 체크섬 또는 CRC와 유사하지만보다 강력한 16 바이트 수량입니다.</target>
        </trans-unit>
        <trans-unit id="5579e2951cd84cd7814305254794db678509d171" translate="yes" xml:space="preserve">
          <source>Computes RIPEMD-160 hashes of arbitrary data. RIPEMD-160 hashes are 20 byte quantities that are like a checksum or CRC, but are more robust.</source>
          <target state="translated">임의 데이터의 RIPEMD-160 해시를 계산합니다. RIPEMD-160 해시는 체크섬 또는 CRC와 유사하지만보다 강력한 20 바이트 수량입니다.</target>
        </trans-unit>
        <trans-unit id="b03ce1bab59ab2d228bb375354ca2f56fee8c218" translate="yes" xml:space="preserve">
          <source>Computes SHA1 and SHA2 hashes of arbitrary data. SHA hashes are 20 to 64 byte quantities (depending on the SHA algorithm) that are like a checksum or CRC, but are more robust.</source>
          <target state="translated">임의 데이터의 SHA1 및 SHA2 해시를 계산합니다. SHA 해시는 체크섬 또는 CRC와 유사하지만보다 강력한 20-64 바이트 (SHA 알고리즘에 따라 다름) 수량입니다.</target>
        </trans-unit>
        <trans-unit id="e7873407fccab092da69ee0890f41357999dc857" translate="yes" xml:space="preserve">
          <source>Computes a hash of the instance of a type.</source>
          <target state="translated">유형 인스턴스의 해시를 계산합니다.</target>
        </trans-unit>
        <trans-unit id="82604089c1a3a9639da1f3dad4ff14761ed55648" translate="yes" xml:space="preserve">
          <source>Computes a subrange of &lt;code&gt;range&lt;/code&gt; starting at the first occurrence of &lt;code&gt;range&lt;/code&gt;'s minimum (respectively maximum) and with the same ending as &lt;code&gt;range&lt;/code&gt;, or the empty range if &lt;code&gt;range&lt;/code&gt; itself is empty.</source>
          <target state="translated">부분 범위의 계산 &lt;code&gt;range&lt;/code&gt; 의 처음부터 발생 &lt;code&gt;range&lt;/code&gt; 의 최소값 (각각 최대) '과 동일한 결말 &lt;code&gt;range&lt;/code&gt; 않거나 빈 영역 &lt;code&gt;range&lt;/code&gt; 자체가 비어있다.</target>
        </trans-unit>
        <trans-unit id="b28e3792ae1738b85ec20e79a7ef0f511b39b00f" translate="yes" xml:space="preserve">
          <source>Computes an index for &lt;code&gt;r&lt;/code&gt; based on the comparison &lt;code&gt;less&lt;/code&gt;. The index is a sorted array of pointers or indices into the original range. This technique is similar to sorting, but it is more flexible because (1) it allows &quot;sorting&quot; of immutable collections, (2) allows binary search even if the original collection does not offer random access, (3) allows multiple indexes, each on a different predicate, and (4) may be faster when dealing with large objects. However, using an index may also be slower under certain circumstances due to the extra indirection, and is always larger than a sorting-based solution because it needs space for the index in addition to the original collection. The complexity is the same as &lt;code&gt;sort&lt;/code&gt;'s.</source>
          <target state="translated">&lt;code&gt;less&lt;/code&gt; 비교를 기반으로 &lt;code&gt;r&lt;/code&gt; 에 대한 인덱스를 계산합니다 . 인덱스는 원래 범위로 정렬 된 포인터 또는 인덱스의 배열입니다. 이 기술은 정렬과 유사하지만 (1) 변경 불가능한 콜렉션의 &quot;정렬&quot;을 허용하고 (2) 원래 콜렉션이 무작위 액세스를 제공하지 않더라도 2 진 검색을 허용하고 (3) 각각 여러 인덱스를 허용하므로보다 유연합니다. 다른 술어에서 (4) 큰 오브젝트를 처리 할 때 더 빠를 수 있습니다. 그러나 추가 간접적으로 인해 특정 환경에서는 인덱스 사용이 느려질 수 있으며 원본 컬렉션 외에 인덱스를위한 공간이 필요하기 때문에 정렬 기반 솔루션보다 항상 더 큽니다. 복잡성은 &lt;code&gt;sort&lt;/code&gt; 와 동일 합니다.</target>
        </trans-unit>
        <trans-unit id="92f85def44d73b410c07064bdb1637d1fdade94c" translate="yes" xml:space="preserve">
          <source>Computes integer to floating point powers.</source>
          <target state="translated">정수를 부동 소수점으로 계산합니다.</target>
        </trans-unit>
        <trans-unit id="828dda1e22c2f096a88e923fc1bc2efd10471f59" translate="yes" xml:space="preserve">
          <source>Computes the &lt;a href=&quot;https://en.wikipedia.org/wiki/Cosine_similarity&quot;&gt;cosine similarity&lt;/a&gt; of input ranges &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt;. The two ranges must have the same length. If both ranges define length, the check is done once; otherwise, it is done at each iteration. If either range has all-zero elements, return 0.</source>
          <target state="translated">입력 범위 &lt;code&gt;a&lt;/code&gt; 와 &lt;code&gt;b&lt;/code&gt; 의 &lt;a href=&quot;https://en.wikipedia.org/wiki/Cosine_similarity&quot;&gt;코사인 유사성&lt;/a&gt; 을 계산합니다 . 두 범위의 길이는 같아야합니다. 두 범위가 모두 길이를 정의하면 점검이 한 번 수행됩니다. 그렇지 않으면 각 반복에서 수행됩니다. 두 범위 중 하나에 모두 0의 요소가 있으면 0을 반환하십시오.</target>
        </trans-unit>
        <trans-unit id="001e06c86d6d760ab7657dfb18427574bae02730" translate="yes" xml:space="preserve">
          <source>Computes the &lt;a href=&quot;https://en.wikipedia.org/wiki/Dot_product&quot;&gt;dot product&lt;/a&gt; of input ranges &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt;. The two ranges must have the same length. If both ranges define length, the check is done once; otherwise, it is done at each iteration.</source>
          <target state="translated">입력 범위 &lt;code&gt;a&lt;/code&gt; 와 &lt;code&gt;b&lt;/code&gt; 의 &lt;a href=&quot;https://en.wikipedia.org/wiki/Dot_product&quot;&gt;내적을&lt;/a&gt; 계산합니다 . 두 범위의 길이는 같아야합니다. 두 범위가 모두 길이를 정의하면 점검이 한 번 수행됩니다. 그렇지 않으면 각 반복에서 수행됩니다.</target>
        </trans-unit>
        <trans-unit id="bcf4ed97371360235833e69216aba07328958d9e" translate="yes" xml:space="preserve">
          <source>Computes the &lt;a href=&quot;https://en.wikipedia.org/wiki/Jensen%E2%80%93Shannon_divergence&quot;&gt;Jensen-Shannon divergence&lt;/a&gt; between &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt;, which is the sum &lt;code&gt;(ai * log(2 * ai / (ai + bi)) + bi * log(2 * bi / (ai + bi))) / 2&lt;/code&gt;. The base of logarithm is 2. The ranges are assumed to contain elements in &lt;code&gt;[0, 1]&lt;/code&gt;. Usually the ranges are normalized probability distributions, but this is not required or checked by &lt;code&gt;jensenShannonDivergence&lt;/code&gt;. If the inputs are normalized, the result is bounded within &lt;code&gt;[0, 1]&lt;/code&gt;. The three-parameter version stops evaluations as soon as the intermediate result is greater than or equal to &lt;code&gt;limit&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;a&lt;/code&gt; 와 &lt;code&gt;b&lt;/code&gt; 사이 의 &lt;a href=&quot;https://en.wikipedia.org/wiki/Jensen%E2%80%93Shannon_divergence&quot;&gt;Jensen-Shannon 분기 발산을&lt;/a&gt; 계산합니다. 이 합은 &lt;code&gt;(ai * log(2 * ai / (ai + bi)) + bi * log(2 * bi / (ai + bi))) / 2&lt;/code&gt; 입니다. 로그의 밑은 2입니다. 범위는 &lt;code&gt;[0, 1]&lt;/code&gt; 요소를 포함한다고 가정합니다 . 일반적으로 범위는 정규화 된 확률 분포이지만 &lt;code&gt;jensenShannonDivergence&lt;/code&gt; 는이를 요구하거나 확인하지 않습니다 . 입력이 정규화되면 결과는 &lt;code&gt;[0, 1]&lt;/code&gt; 내로 제한됩니다 . 3 개 매개 변수 버전은 중간 결과가 &lt;code&gt;limit&lt;/code&gt; 보다 크거나 같으면 평가를 중지 합니다 .</target>
        </trans-unit>
        <trans-unit id="bccc93152f84cfb32d87abe05334a1cc08f473ea" translate="yes" xml:space="preserve">
          <source>Computes the &lt;a href=&quot;https://en.wikipedia.org/wiki/Kullback%E2%80%93Leibler_divergence&quot;&gt;Kullback-Leibler divergence&lt;/a&gt; between input ranges &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt;, which is the sum &lt;code&gt;ai * log(ai / bi)&lt;/code&gt;. The base of logarithm is 2. The ranges are assumed to contain elements in &lt;code&gt;[0, 1]&lt;/code&gt;. Usually the ranges are normalized probability distributions, but this is not required or checked by &lt;code&gt;kullbackLeiblerDivergence&lt;/code&gt;. If any element &lt;code&gt;bi&lt;/code&gt; is zero and the corresponding element &lt;code&gt;ai&lt;/code&gt; nonzero, returns infinity. (Otherwise, if &lt;code&gt;ai == 0 &amp;amp;&amp;amp; bi == 0&lt;/code&gt;, the term &lt;code&gt;ai * log(ai / bi)&lt;/code&gt; is considered zero.) If the inputs are normalized, the result is positive.</source>
          <target state="translated">입력 범위 &lt;code&gt;a&lt;/code&gt; 와 &lt;code&gt;b&lt;/code&gt; 사이 의 &lt;a href=&quot;https://en.wikipedia.org/wiki/Kullback%E2%80%93Leibler_divergence&quot;&gt;Kullback-Leibler 발산을&lt;/a&gt; 계산합니다 . 이는 합 &lt;code&gt;ai * log(ai / bi)&lt;/code&gt; 입니다. 로그의 밑은 2입니다. 범위는 &lt;code&gt;[0, 1]&lt;/code&gt; 요소를 포함한다고 가정합니다 . 일반적으로 범위는 정규화 된 확률 분포이지만 &lt;code&gt;kullbackLeiblerDivergence&lt;/code&gt; 는 필수 또는 점검하지 않습니다 . 요소 &lt;code&gt;bi&lt;/code&gt; 가 0이고 해당 요소 &lt;code&gt;ai&lt;/code&gt; 가 0이 아닌 경우 무한대를 반환합니다. (그렇지 않으면 &lt;code&gt;ai == 0 &amp;amp;&amp;amp; bi == 0&lt;/code&gt; 이면 &lt;code&gt;ai * log(ai / bi)&lt;/code&gt; 은 0으로 간주됩니다.) 입력이 정규화되면 결과는 양수입니다.</target>
        </trans-unit>
        <trans-unit id="82f8a61e8d0a5e2c407cc15d0dc98d8a7c77f454" translate="yes" xml:space="preserve">
          <source>Computes the greatest common divisor of &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt; by using an efficient algorithm such as &lt;a href=&quot;https://en.wikipedia.org/wiki/Euclidean_algorithm&quot;&gt;Euclid's&lt;/a&gt; or &lt;a href=&quot;https://en.wikipedia.org/wiki/Binary_GCD_algorithm&quot;&gt;Stein's&lt;/a&gt; algorithm.</source>
          <target state="translated">&lt;a href=&quot;https://en.wikipedia.org/wiki/Euclidean_algorithm&quot;&gt;Euclid&lt;/a&gt; 또는 &lt;a href=&quot;https://en.wikipedia.org/wiki/Binary_GCD_algorithm&quot;&gt;Stein&lt;/a&gt; 알고리즘과 같은 효율적인 알고리즘을 사용하여 &lt;code&gt;a&lt;/code&gt; 와 &lt;code&gt;b&lt;/code&gt; 의 최대 공약수를 계산합니다 .</target>
        </trans-unit>
        <trans-unit id="62daeb05222388ac697dc74b9f37d3d0822c2a6e" translate="yes" xml:space="preserve">
          <source>Computes the hash of the held value.</source>
          <target state="translated">보류 값의 해시를 계산합니다.</target>
        </trans-unit>
        <trans-unit id="265e1e72bdf2f361616fec34db23103d27bf2241" translate="yes" xml:space="preserve">
          <source>Computes the index of the first occurrence of &lt;code&gt;range&lt;/code&gt;'s maximum element.</source>
          <target state="translated">&lt;code&gt;range&lt;/code&gt; 의 최대 요소 가 처음 나타나는 인덱스를 계산합니다 .</target>
        </trans-unit>
        <trans-unit id="355f343fa9f1a69e378af49768a7655e8cf9c6b9" translate="yes" xml:space="preserve">
          <source>Computes the index of the first occurrence of &lt;code&gt;range&lt;/code&gt;'s minimum element.</source>
          <target state="translated">&lt;code&gt;range&lt;/code&gt; 의 최소 ​​요소 가 처음 나타나는 인덱스를 계산합니다 .</target>
        </trans-unit>
        <trans-unit id="23157290f28401c16bb054d1176e6a8721bc9834" translate="yes" xml:space="preserve">
          <source>Computes the inverse Fourier transform of a range. The range must be a random access range with slicing, have a length equal to the size provided at construction of this object, and contain elements that are either of type std.complex.Complex or have essentially the same compile-time interface.</source>
          <target state="translated">범위의 역 푸리에 변환을 계산합니다. 범위는 슬라이싱을 사용하는 임의의 액세스 범위 여야하고이 객체를 구성 할 때 제공되는 크기와 길이가 동일해야하며 std.complex.Complex 유형이거나 본질적으로 동일한 컴파일 타임 인터페이스를 가진 요소를 포함해야합니다.</target>
        </trans-unit>
        <trans-unit id="a4770977a60d3756b3fc642893a20b59f0fe70f5" translate="yes" xml:space="preserve">
          <source>Computes the length of any range in O(n) time.</source>
          <target state="translated">O (n) 시간으로 범위의 길이를 계산합니다.</target>
        </trans-unit>
        <trans-unit id="a53d2cd20ccb22bc201e56bc6c6a7059b3ec842d" translate="yes" xml:space="preserve">
          <source>Computes the length of grapheme cluster starting at &lt;code&gt;index&lt;/code&gt;. Both the resulting length and the &lt;code&gt;index&lt;/code&gt; are measured in &lt;a href=&quot;#Code%20unit&quot;&gt;code units&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;index&lt;/code&gt; 에서 시작하는 grapheme 클러스터의 길이를 계산합니다 . 결과 길이와 &lt;code&gt;index&lt;/code&gt; 은 모두 &lt;a href=&quot;#Code%20unit&quot;&gt;코드 단위&lt;/a&gt; 로 측정됩니다 .</target>
        </trans-unit>
        <trans-unit id="1a5a9de63581b03924af8f2c2bbd32e205910376" translate="yes" xml:space="preserve">
          <source>Computes the match of the popFront length. Completes in &amp;Omicron;(&lt;code&gt;s.length * t.length&lt;/code&gt;) time.</source>
          <target state="translated">popFront 길이의 일치를 계산합니다. &amp;Omicron; ( &lt;code&gt;s.length * t.length&lt;/code&gt; ) 시간으로 완료 합니다.</target>
        </trans-unit>
        <trans-unit id="3d970629c10f34f68e73440748e21b623f859402" translate="yes" xml:space="preserve">
          <source>Computes the minimum (respectively maximum) of &lt;code&gt;range&lt;/code&gt; along with its number of occurrences. Formally, the minimum is a value &lt;code&gt;x&lt;/code&gt; in &lt;code&gt;range&lt;/code&gt; such that &lt;code&gt;pred(a, x)&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt; for all values &lt;code&gt;a&lt;/code&gt; in &lt;code&gt;range&lt;/code&gt;. Conversely, the maximum is a value &lt;code&gt;x&lt;/code&gt; in &lt;code&gt;range&lt;/code&gt; such that &lt;code&gt;pred(x, a)&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt; for all values &lt;code&gt;a&lt;/code&gt; in &lt;code&gt;range&lt;/code&gt; (note the swapped arguments to &lt;code&gt;pred&lt;/code&gt;).</source>
          <target state="translated">발생 횟수와 함께 &lt;code&gt;range&lt;/code&gt; 의 최소 ​​(각각 최대)를 계산합니다 . 공식적으로 최소 값이고 &lt;code&gt;x&lt;/code&gt; 의 &lt;code&gt;range&lt;/code&gt; 되도록 &lt;code&gt;pred(a, x)&lt;/code&gt; 되는 &lt;code&gt;false&lt;/code&gt; 모든 값 의 &lt;code&gt;range&lt;/code&gt; . 반대로, 최대 값이며 &lt;code&gt;x&lt;/code&gt; 의 &lt;code&gt;range&lt;/code&gt; 되도록 &lt;code&gt;pred(x, a)&lt;/code&gt; 되는 &lt;code&gt;false&lt;/code&gt; 모든 값 의 &lt;code&gt;range&lt;/code&gt; (의 교환 인자 유의 &lt;code&gt;pred&lt;/code&gt; ). &lt;code&gt;a&lt;/code&gt; &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="ef86bb558e70e54418dec649b83e309302fe4774" translate="yes" xml:space="preserve">
          <source>Computes the next lexicographically greater even permutation of a range in-place.</source>
          <target state="translated">범위 내에서 다음 사전 사전 순으로 더 큰 순열을 계산합니다.</target>
        </trans-unit>
        <trans-unit id="c939037e683052e11796212630e886a0f710fc91" translate="yes" xml:space="preserve">
          <source>Computes the next lexicographically greater permutation of a range in-place.</source>
          <target state="translated">범위 내 다음 사전 순으로 더 큰 순열을 계산합니다.</target>
        </trans-unit>
        <trans-unit id="0ac0eb054effc8e964f179add51ac8ce5cde0817" translate="yes" xml:space="preserve">
          <source>Computes the nth permutation of a range in-place.</source>
          <target state="translated">전체 범위의 n 번째 순열을 계산합니다.</target>
        </trans-unit>
        <trans-unit id="7776b0304fc7917421d0069aa2e2faee1db476d1" translate="yes" xml:space="preserve">
          <source>Computes the union of a range of sorted ranges.</source>
          <target state="translated">정렬 된 범위의 합집합을 계산합니다.</target>
        </trans-unit>
        <trans-unit id="cb77e0d53b3af1bb492d078444229137406cc49e" translate="yes" xml:space="preserve">
          <source>Computes the union of multiple ranges. The &lt;a href=&quot;std_range_primitives#isInputRange&quot;&gt;input ranges&lt;/a&gt; are passed as a range of ranges and each is assumed to be sorted by &lt;code&gt;less&lt;/code&gt;. Computation is done lazily, one union element at a time. &lt;code&gt;multiwayUnion(ror)&lt;/code&gt; is functionally equivalent to &lt;code&gt;multiwayMerge(ror).uniq&lt;/code&gt;.</source>
          <target state="translated">여러 범위의 합집합을 계산합니다. &lt;a href=&quot;std_range_primitives#isInputRange&quot;&gt;입력 범위&lt;/a&gt; 의 범위의 범위로 전달되고, 각각으로 분류되는 것으로 가정 &lt;code&gt;less&lt;/code&gt; . 계산은 한 번에 하나의 공용체 요소로 느리게 수행됩니다. &lt;code&gt;multiwayUnion(ror)&lt;/code&gt; 은 기능적으로 &lt;code&gt;multiwayMerge(ror).uniq&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1a126dbb5dda187ebb7d5104cb58f176f39bc7db" translate="yes" xml:space="preserve">
          <source>Computes the value of a positive integer &lt;code&gt;x&lt;/code&gt;, raised to the power &lt;code&gt;n&lt;/code&gt;, modulo &lt;code&gt;m&lt;/code&gt;.</source>
          <target state="translated">양의 정수 &lt;code&gt;x&lt;/code&gt; 값을 거듭 제곱 &lt;code&gt;n&lt;/code&gt; , 모듈로 &lt;code&gt;m&lt;/code&gt; 으로 계산 합니다.</target>
        </trans-unit>
        <trans-unit id="04fa1754d0f3ba8b19daaf72ab1060db4c420591" translate="yes" xml:space="preserve">
          <source>Computes whether two values are approximately equal, admitting a maximum relative difference, and a maximum absolute difference.</source>
          <target state="translated">최대 상대 차이와 최대 절대 차이를 허용하여 두 값이 대략 같은지 여부를 계산합니다.</target>
        </trans-unit>
        <trans-unit id="90f1bfbd09f8811922bf824de5a2cde80eff4934" translate="yes" xml:space="preserve">
          <source>Computing array lengths during compilation</source>
          <target state="translated">컴파일하는 동안 배열 길이 계산</target>
        </trans-unit>
        <trans-unit id="ed0c24b1a7f07e9baa4b3d7d42eace24ae7358ef" translate="yes" xml:space="preserve">
          <source>Concatenate Tuples. Tuple concatenation is only allowed if all named fields are distinct (no named field of this tuple occurs in &lt;code&gt;t&lt;/code&gt; and no named field of &lt;code&gt;t&lt;/code&gt; occurs in this tuple).</source>
          <target state="translated">튜플을 연결하십시오. 튜플 연결은 모든 명명 된 필드가 고유 한 경우에만 허용됩니다 (이 튜플의 명명 된 필드는 &lt;code&gt;t&lt;/code&gt; 에서 발생 하지 않으며 &lt;code&gt;t&lt;/code&gt; 의 명명 된 필드는이 튜플에서 발생 하지 않음 ).</target>
        </trans-unit>
        <trans-unit id="c1cbdd888810a65f9ce252092149adeb11bad0f8" translate="yes" xml:space="preserve">
          <source>Concatenate multiple &lt;code&gt;escapeShellCommand&lt;/code&gt; and &lt;a href=&quot;#escapeShellFileName&quot;&gt;&lt;code&gt;escapeShellFileName&lt;/code&gt;&lt;/a&gt; results to use shell redirection or piping operators.</source>
          <target state="translated">쉘 재 지정 또는 파이핑 연산자를 사용하기 위해 여러 &lt;code&gt;escapeShellCommand&lt;/code&gt; 및 &lt;a href=&quot;#escapeShellFileName&quot;&gt; &lt;code&gt;escapeShellFileName&lt;/code&gt; &lt;/a&gt; 결과를 연결하십시오 .</target>
        </trans-unit>
        <trans-unit id="ef92b5ecddb9c03ee25b9741d86e91adf28ae5ee" translate="yes" xml:space="preserve">
          <source>Concatenate path segments together to form one path.</source>
          <target state="translated">경로 세그먼트를 함께 연결하여 하나의 경로를 형성하십시오.</target>
        </trans-unit>
        <trans-unit id="fbbbf15264cd015326c8650e5c9bcfe45679594d" translate="yes" xml:space="preserve">
          <source>Concatenate tuples</source>
          <target state="translated">튜플 연결</target>
        </trans-unit>
        <trans-unit id="d334da4f36d3ac970a49b9c6ff3d38de0a94daec" translate="yes" xml:space="preserve">
          <source>Concatenate two lists (l2 appended to l1).</source>
          <target state="translated">두 목록을 연결하십시오 (l1이 l1에 추가됨).</target>
        </trans-unit>
        <trans-unit id="54605f22a1f1252b76de960747267c3c0603476d" translate="yes" xml:space="preserve">
          <source>Concatenates a range of ranges into one array.</source>
          <target state="translated">범위의 범위를 하나의 배열로 연결합니다.</target>
        </trans-unit>
        <trans-unit id="09f32ec319e44bc6f468a74c63ca6c7d780d7a7f" translate="yes" xml:space="preserve">
          <source>Concatenates several ranges into a single range.</source>
          <target state="translated">여러 범위를 단일 범위로 연결합니다.</target>
        </trans-unit>
        <trans-unit id="aba48fb5ee4afc0282b513e1b8419e115676e665" translate="yes" xml:space="preserve">
          <source>Concatenating the arrays inside of &lt;code&gt;arrs&lt;/code&gt;. &lt;code&gt;_d_arraycatnTX([a, b, c])&lt;/code&gt; means &lt;code&gt;a ~ b ~ c&lt;/code&gt;.</source>
          <target state="translated">내부의 배열을 연결 &lt;code&gt;arrs&lt;/code&gt; . &lt;code&gt;_d_arraycatnTX([a, b, c])&lt;/code&gt; 는 &lt;code&gt;a ~ b ~ c&lt;/code&gt; 를 의미 합니다 .</target>
        </trans-unit>
        <trans-unit id="1fd32d36258eae30e3a703b388fd2d676ac083d9" translate="yes" xml:space="preserve">
          <source>Concatenation always creates a copy of its operands, even if one of the operands is a 0 length array, so:</source>
          <target state="translated">피연산자 중 하나가 0 길이 배열 인 경우에도 연결은 항상 피연산자의 복사본을 만듭니다.</target>
        </trans-unit>
        <trans-unit id="8bfdaed1fe3ba5044986f54f678261c455c4286e" translate="yes" xml:space="preserve">
          <source>Concatenation and appending</source>
          <target state="translated">연결 및 추가</target>
        </trans-unit>
        <trans-unit id="f307354edc327002aff0696b23e699bed6b0337f" translate="yes" xml:space="preserve">
          <source>Conceptual type that outlines the common properties of all UTF Matchers.</source>
          <target state="translated">모든 UTF 매처의 공통 특성을 설명하는 개념적 유형입니다.</target>
        </trans-unit>
        <trans-unit id="2f4979324e03e4571b1d7eba701226670c2ee2da" translate="yes" xml:space="preserve">
          <source>Condition</source>
          <target state="translated">Condition</target>
        </trans-unit>
        <trans-unit id="368834630d459ecc51471d8ef1eb3550a7af82cb" translate="yes" xml:space="preserve">
          <source>Conditional Compilation</source>
          <target state="translated">조건부 컴파일</target>
        </trans-unit>
        <trans-unit id="8a0d63179619b501ad5800876cf0df368b27a390" translate="yes" xml:space="preserve">
          <source>Conditional Expressions</source>
          <target state="translated">조건식</target>
        </trans-unit>
        <trans-unit id="02b96d4c9fbd3a91b071d3d53be1d37274828f1c" translate="yes" xml:space="preserve">
          <source>Conditional Logging</source>
          <target state="translated">조건부 로깅</target>
        </trans-unit>
        <trans-unit id="61fb1fb5259174d8968cdd64b4b930f65a905d82" translate="yes" xml:space="preserve">
          <source>Conditional compilation</source>
          <target state="translated">조건부 컴파일</target>
        </trans-unit>
        <trans-unit id="41d7d233afb0dd68d28fc8f570d341d5c22d2172" translate="yes" xml:space="preserve">
          <source>Conditional logging can be achieved be passing a &lt;code&gt;bool&lt;/code&gt; as first argument to a log function. If conditional logging is used the condition must be &lt;code&gt;true&lt;/code&gt; in order to have the log message logged.  In order to combine an explicit &lt;code&gt;LogLevel&lt;/code&gt; passing with conditional logging, the &lt;code&gt;LogLevel&lt;/code&gt; has to be passed as first argument followed by the &lt;code&gt;bool&lt;/code&gt;.</source>
          <target state="translated">조건부 로깅은 &lt;code&gt;bool&lt;/code&gt; 을 첫 번째 인수로 로그 함수에 전달하여 얻을 수 있습니다 . 조건부 로깅을 사용하는 경우 로그 메시지를 로깅 하려면 조건이 &lt;code&gt;true&lt;/code&gt; 여야합니다 . 명시 적으로 결합하기 위하여 &lt;code&gt;LogLevel&lt;/code&gt; 에 조건부 로깅 지나가는 상기 &lt;code&gt;LogLevel&lt;/code&gt; 첫번째 인자는 다음과 같이 전달되어야 &lt;code&gt;bool&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7e9b71968760fc03c2bd272ee9bbb297247e44ef" translate="yes" xml:space="preserve">
          <source>ConditionalDeclaration</source>
          <target state="translated">ConditionalDeclaration</target>
        </trans-unit>
        <trans-unit id="c5b4a55bf44bb04ff293c5deb38688769ac299cf" translate="yes" xml:space="preserve">
          <source>ConditionalStatement</source>
          <target state="translated">ConditionalStatement</target>
        </trans-unit>
        <trans-unit id="2cda11f185fbbbe7d23cfc89fd493405e9cae9a1" translate="yes" xml:space="preserve">
          <source>Config &lt;code&gt;config&lt;/code&gt;</source>
          <target state="translated">구성 &lt;code&gt;config&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="754164850f38c1ecdaf6b8ed894cb192bc36c5f4" translate="yes" xml:space="preserve">
          <source>Configuration</source>
          <target state="translated">Configuration</target>
        </trans-unit>
        <trans-unit id="06610b8b075f898940036a6adb700398270f1776" translate="yes" xml:space="preserve">
          <source>Configuration options for &lt;code&gt;getopt&lt;/code&gt;.</source>
          <target state="translated">에 대한 구성 옵션 &lt;code&gt;getopt&lt;/code&gt; 는 .</target>
        </trans-unit>
        <trans-unit id="a6431b321225e094a850e4edc49d8a1243e81cc7" translate="yes" xml:space="preserve">
          <source>Configuration options for druntime.</source>
          <target state="translated">druntime에 대한 구성 옵션.</target>
        </trans-unit>
        <trans-unit id="1b3ac33acfeded0c91e96d651db32f59b33bf43d" translate="yes" xml:space="preserve">
          <source>Configuration via the command line can be disabled by declaring a variable for the linker to pick up before using it's default from the runtime:</source>
          <target state="translated">런타임에서 기본값을 사용하기 전에 링커가 선택할 변수를 선언하여 명령 줄을 통한 구성을 비활성화 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c549a207a37db7214dfa5f6be06a12b29fcccee0" translate="yes" xml:space="preserve">
          <source>Configuration via the command line can be disabled by declaring a variable for the linker to pick up before using its default from the runtime:</source>
          <target state="translated">런타임에서 기본값을 사용하기 전에 링커가 선택할 변수를 선언하여 명령 줄을 통한 구성을 비활성화 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1cfd39d93ce243f8209e2cb0fd6a72bd5199a441" translate="yes" xml:space="preserve">
          <source>Configure an auto-checkpoint</source>
          <target state="translated">자동 검사 점 구성</target>
        </trans-unit>
        <trans-unit id="5cda84f2fffb92ec6200fae3e17f21d369027339" translate="yes" xml:space="preserve">
          <source>Configure database connections</source>
          <target state="translated">데이터베이스 연결 구성</target>
        </trans-unit>
        <trans-unit id="9d3bc7d832ae044f63c47a2f9e7fae292f78d77f" translate="yes" xml:space="preserve">
          <source>Configuring The SQLite Library</source>
          <target state="translated">SQLite 라이브러리 구성</target>
        </trans-unit>
        <trans-unit id="6c9652511df81d8bc126592a1f7ea6652bb3ab73" translate="yes" xml:space="preserve">
          <source>Configuring the Garbage Collector</source>
          <target state="translated">가비지 콜렉터 구성</target>
        </trans-unit>
        <trans-unit id="76ad8dda0a203dcd9a14445916230e10df73a7f3" translate="yes" xml:space="preserve">
          <source>Confirm s is a valid template, then store it.</source>
          <target state="translated">s가 유효한 템플리트인지 확인한 후 저장하십시오.</target>
        </trans-unit>
        <trans-unit id="db012c464d251d67ffbcac09777d640d209be8dd" translate="yes" xml:space="preserve">
          <source>Confirm whether this stopwatch is measuring time.</source>
          <target state="translated">이 스톱워치가 시간을 측정하고 있는지 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="841a7cce211d41301505ff131d9f016fac1e6279" translate="yes" xml:space="preserve">
          <source>Conforms to IEEE 754-2008</source>
          <target state="translated">IEEE 754-2008 준수</target>
        </trans-unit>
        <trans-unit id="8d2931da0a4a255003ce81824b3d90572948d6f8" translate="yes" xml:space="preserve">
          <source>Conforms to the Microsoft Windows Structured Exception Handling conventions.</source>
          <target state="translated">Microsoft Windows 구조적 예외 처리 규칙을 준수합니다.</target>
        </trans-unit>
        <trans-unit id="bad8df68294c8ab2277b9345f70f577dbf3c8959" translate="yes" xml:space="preserve">
          <source>Conforms to the target's C ABI struct layout.</source>
          <target state="translated">대상의 C ABI 구조체 레이아웃을 준수합니다.</target>
        </trans-unit>
        <trans-unit id="49578a731259515bbadf31f422528ce8c4631b50" translate="yes" xml:space="preserve">
          <source>Conn &lt;code&gt;conn&lt;/code&gt;</source>
          <target state="translated">코네티컷의 &lt;code&gt;conn&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="0474ba2f1ee3e396c97ac1ac34d1d19ad3689dae" translate="yes" xml:space="preserve">
          <source>Connection encoding. Defaults to ISO-8859-1.</source>
          <target state="translated">연결 인코딩. 기본값은 ISO-8859-1입니다.</target>
        </trans-unit>
        <trans-unit id="519ecd274822b5f9ddc30ae246a94167b56bf039" translate="yes" xml:space="preserve">
          <source>Connection type used when the URL should be used to auto detect the protocol. This struct is used as placeholder for the connection parameter when calling the high level API and the connection type (HTTP/FTP) should be guessed by inspecting the URL parameter. The rules for guessing the protocol are: 1, if URL starts with ftp://, ftps:// or ftp. then FTP connection is assumed. 2, HTTP connection otherwise.</source>
          <target state="translated">프로토콜을 자동 감지하기 위해 URL을 사용해야 할 때 사용되는 연결 유형입니다. 이 구조체는 고급 API를 호출 할 때 연결 매개 변수의 자리 표시 자로 사용되며 URL 매개 변수를 검사하여 연결 유형 (HTTP / FTP)을 추측해야합니다. 프로토콜을 추측하기위한 규칙은 다음과 같습니다. 1, URL이 ftp : //, ftps : // 또는 ftp로 시작하는 경우. FTP 연결이 가정됩니다. 그렇지 않으면 2, HTTP 연결.</target>
        </trans-unit>
        <trans-unit id="078912762bea745ba2c41bae707b195db48327c8" translate="yes" xml:space="preserve">
          <source>Connectionless, unreliable datagrams with a fixed maximum length; data may be lost or arrive out of order</source>
          <target state="translated">최대 길이가 고정 된 연결이없고 신뢰할 수없는 데이터 그램 데이터가 손실되거나 고장난 경우</target>
        </trans-unit>
        <trans-unit id="d929792a86b18c9fb89df6aef5598294f6328000" translate="yes" xml:space="preserve">
          <source>Connector_Punctuation</source>
          <target state="translated">Connector_Punctuation</target>
        </trans-unit>
        <trans-unit id="a30b51b4925a7ede0792face17a4f0e9710a0252" translate="yes" xml:space="preserve">
          <source>Consider using &lt;code&gt;getAddress&lt;/code&gt;, &lt;code&gt;parseAddress&lt;/code&gt; and &lt;code&gt;Address&lt;/code&gt; methods instead of using this class directly.</source>
          <target state="translated">사용을 고려 &lt;code&gt;getAddress&lt;/code&gt; 에 , &lt;code&gt;parseAddress&lt;/code&gt; 및 &lt;code&gt;Address&lt;/code&gt; 방법 대신이 클래스를 사용하여.</target>
        </trans-unit>
        <trans-unit id="9810660bbdff1aae34eac15a7facdded0db22668" translate="yes" xml:space="preserve">
          <source>Const Member Functions</source>
          <target state="translated">Const 멤버 함수</target>
        </trans-unit>
        <trans-unit id="83dcf3de7eb019ec6629bbd79f8b667634364e18" translate="yes" xml:space="preserve">
          <source>Const Storage Class</source>
          <target state="translated">콘 스트 스토리지 클래스</target>
        </trans-unit>
        <trans-unit id="3d742d8dde06f988077f8f82f51f498a3531d234" translate="yes" xml:space="preserve">
          <source>Const Type</source>
          <target state="translated">콘 스트 타입</target>
        </trans-unit>
        <trans-unit id="784fed24b477710eef1f5226f481179174928151" translate="yes" xml:space="preserve">
          <source>Const and Immutable</source>
          <target state="translated">불변과 불변</target>
        </trans-unit>
        <trans-unit id="896cf932e98b76529cba660f6f6a0543fea0acaa" translate="yes" xml:space="preserve">
          <source>Const and Immutable Interfaces</source>
          <target state="translated">불변 및 불변 인터페이스</target>
        </trans-unit>
        <trans-unit id="9069f2cf93e274994d11feade6815e9fb488f82d" translate="yes" xml:space="preserve">
          <source>Const array is converted to input range by removing its qualifier.</source>
          <target state="translated">Const 배열은 한정자를 제거하여 입력 범위로 변환됩니다.</target>
        </trans-unit>
        <trans-unit id="f40015b781b2d4acdb42042e30dd8e0561ab4289" translate="yes" xml:space="preserve">
          <source>Const member functions are functions that are not allowed to change any part of the object through the member function's this reference.</source>
          <target state="translated">Const 멤버 함수는 멤버 함수의이 참조를 통해 객체의 일부를 변경할 수없는 함수입니다.</target>
        </trans-unit>
        <trans-unit id="2250093f69faa6a58322166f59cb9d509a15db57" translate="yes" xml:space="preserve">
          <source>Const types are like immutable types, except that const forms a read-only</source>
          <target state="translated">const 유형은 불변 유형과 유사하지만 const는 읽기 전용입니다.</target>
        </trans-unit>
        <trans-unit id="cc17a30efd81f4b6809eff7a896b92f5876f25e3" translate="yes" xml:space="preserve">
          <source>Const, Immutable Comparison</source>
          <target state="translated">불변의 불변 비교</target>
        </trans-unit>
        <trans-unit id="b27c2428c75022095914c42cb3f655e37a5625b8" translate="yes" xml:space="preserve">
          <source>Const, Immutable and Shared Classes</source>
          <target state="translated">불변의 공유 클래스</target>
        </trans-unit>
        <trans-unit id="8681eda928fe17b6615fbb79a2dc733c8ebaba94" translate="yes" xml:space="preserve">
          <source>Const, Immutable and Shared Structs</source>
          <target state="translated">불변의 공유 구조</target>
        </trans-unit>
        <trans-unit id="6c73b65a7e00144e4a4cd7b116f22177ab58213a" translate="yes" xml:space="preserve">
          <source>Constant &lt;a href=&quot;#Code%20point&quot;&gt;code point&lt;/a&gt; (0x0085) - next line.</source>
          <target state="translated">상수 &lt;a href=&quot;#Code%20point&quot;&gt;코드 포인트&lt;/a&gt; (0x0085)-다음 줄.</target>
        </trans-unit>
        <trans-unit id="ee9a92399d6335bc2aeede4d454001baa024aaf3" translate="yes" xml:space="preserve">
          <source>Constant &lt;a href=&quot;#Code%20point&quot;&gt;code point&lt;/a&gt; (0x2028) - line separator.</source>
          <target state="translated">상수 &lt;a href=&quot;#Code%20point&quot;&gt;코드 포인트&lt;/a&gt; (0x2028)-줄 구분 기호</target>
        </trans-unit>
        <trans-unit id="d9cdea9445ed1d8ad134d40b5e8dd40f3350c441" translate="yes" xml:space="preserve">
          <source>Constant &lt;a href=&quot;#Code%20point&quot;&gt;code point&lt;/a&gt; (0x2029) - paragraph separator.</source>
          <target state="translated">상수 &lt;a href=&quot;#Code%20point&quot;&gt;코드 포인트&lt;/a&gt; (0x2029)-단락 구분 기호</target>
        </trans-unit>
        <trans-unit id="ae1de1f3ec7fd1e298252331c9256b1f73d60516" translate="yes" xml:space="preserve">
          <source>Constant defining a fully decoded BOM</source>
          <target state="translated">완전히 디코딩 된 BOM을 정의하는 상수</target>
        </trans-unit>
        <trans-unit id="513fd3be0bfd521c00e6fe601132e59539268d57" translate="yes" xml:space="preserve">
          <source>Constant fold an Expression.</source>
          <target state="translated">식을 일정하게 접습니다.</target>
        </trans-unit>
        <trans-unit id="3db4fce387c01b326d3e15a975e8b04f8af06c7c" translate="yes" xml:space="preserve">
          <source>Constant folded version of &lt;code&gt;e&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;e&lt;/code&gt; 일정한 접힌 버전</target>
        </trans-unit>
        <trans-unit id="9c1d160235265d86d921f707d3ce59f58aed4954" translate="yes" xml:space="preserve">
          <source>Constant folding, with support for CTFE Return true if non-pointer expression e can be compared with &amp;gt;,is, ==, etc, using ctfeCmp, ctfeEqual, ctfeIdentity</source>
          <target state="translated">CTFE를 지원하는 상수 폴딩 ctfeCmp, ctfeEqual, ctfeIdentity를 사용하여 비 포인터 식 e를&amp;gt;, is, == 등과 비교할 수 있으면 true를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="0f386d7e7881b32fa39cb7b62bdb15c0f3a4c0e1" translate="yes" xml:space="preserve">
          <source>Constants</source>
          <target state="translated">Constants</target>
        </trans-unit>
        <trans-unit id="f7d639ba9c48f5467c4d1a8f0152a2dc90222051" translate="yes" xml:space="preserve">
          <source>Constants Defining Special Destructor Behavior</source>
          <target state="translated">특수 소멸자 동작을 정의하는 상수</target>
        </trans-unit>
        <trans-unit id="cdd87b7907fb17673e884c148848c9c5e93b59ca" translate="yes" xml:space="preserve">
          <source>Constraint</source>
          <target state="translated">Constraint</target>
        </trans-unit>
        <trans-unit id="52e68a873a2be3470675b9ee933b98d781ae7fef" translate="yes" xml:space="preserve">
          <source>Constraints</source>
          <target state="translated">Constraints</target>
        </trans-unit>
        <trans-unit id="cd7dc62d6119143cd2fd7c7185b12b70cf0749f3" translate="yes" xml:space="preserve">
          <source>Construct 256 character translation table, where characters in from[] are replaced by corresponding characters in to[].</source>
          <target state="translated">from []의 문자가 to []의 해당 문자로 대체되는 256 자 변환 표를 구성하십시오.</target>
        </trans-unit>
        <trans-unit id="5de02eef75a505103dd6a73f454b30bd0638b7c9" translate="yes" xml:space="preserve">
          <source>Construct a &lt;a href=&quot;#SysTime&quot;&gt;&lt;code&gt;SysTime&lt;/code&gt;&lt;/a&gt; from a ISO time string</source>
          <target state="translated">구성체 &lt;a href=&quot;#SysTime&quot;&gt; &lt;code&gt;SysTime&lt;/code&gt; &lt;/a&gt; ISO 시간 문자열</target>
        </trans-unit>
        <trans-unit id="cef526ef10de16815aa0c9df0e5fee07dd4e2470" translate="yes" xml:space="preserve">
          <source>Construct a &lt;code&gt;BigInt&lt;/code&gt; from a built-in integral type.</source>
          <target state="translated">컨스 &lt;code&gt;BigInt&lt;/code&gt; 일체형으로 내장에서.</target>
        </trans-unit>
        <trans-unit id="d5b5175be9d000ff28745ca7b47dfab50bb5237b" translate="yes" xml:space="preserve">
          <source>Construct a &lt;code&gt;BigInt&lt;/code&gt; from a decimal or hexadecimal string. The number must be in the form of a decimal or hex literal. It may have a leading &lt;code&gt;+&lt;/code&gt; or &lt;code&gt;-&lt;/code&gt; sign, followed by &lt;code&gt;0x&lt;/code&gt; or &lt;code&gt;0X&lt;/code&gt; if hexadecimal. Underscores are permitted in any location after the &lt;code&gt;0x&lt;/code&gt; and/or the sign of the number.</source>
          <target state="translated">구성체 &lt;code&gt;BigInt&lt;/code&gt; 진수 또는 16 진수 문자열. 숫자는 10 진수 또는 16 진 리터럴 형식이어야합니다. &lt;code&gt;0x&lt;/code&gt; &lt;code&gt;+&lt;/code&gt; 또는 &lt;code&gt;-&lt;/code&gt; 부호 가있을 수 있고 16 진수 인 경우 0x 또는 &lt;code&gt;0X&lt;/code&gt; 가 올 수 있습니다. 밑줄은 &lt;code&gt;0x&lt;/code&gt; 및 / 또는 숫자 부호 뒤의 모든 위치에서 허용됩니다 .</target>
        </trans-unit>
        <trans-unit id="0d7c3b4548cf75fac0de21ecc52fb10d3606eec5" translate="yes" xml:space="preserve">
          <source>Construct a &lt;code&gt;BigInt&lt;/code&gt; from another &lt;code&gt;BigInt&lt;/code&gt;.</source>
          <target state="translated">구성체 &lt;code&gt;BigInt&lt;/code&gt; 서로 &lt;code&gt;BigInt&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7efa1a6ab14f5ccd00f6c0c9a24eba2121df8bda" translate="yes" xml:space="preserve">
          <source>Construct a &lt;code&gt;CompoundStatement&lt;/code&gt; from an array of &lt;code&gt;Statement&lt;/code&gt;s</source>
          <target state="translated">&lt;code&gt;Statement&lt;/code&gt; 의 배열로부터 &lt;code&gt;CompoundStatement&lt;/code&gt; 를 구축합니다</target>
        </trans-unit>
        <trans-unit id="29b364a0138bce0f5c44e30e508e17d93f7c05ed" translate="yes" xml:space="preserve">
          <source>Construct a &lt;code&gt;CompoundStatement&lt;/code&gt; using an already existing array of &lt;code&gt;Statement&lt;/code&gt;s</source>
          <target state="translated">컨스 &lt;code&gt;CompoundStatement&lt;/code&gt; 의 기존 배열하여 &lt;code&gt;Statement&lt;/code&gt; 들</target>
        </trans-unit>
        <trans-unit id="c4a6c4a823793d5f65499787e95138d6100b624f" translate="yes" xml:space="preserve">
          <source>Construct a &lt;code&gt;Decoder&lt;/code&gt; that iterates over the decoding of the given Base64 encoded data.</source>
          <target state="translated">주어진 Base64 인코딩 데이터의 디코딩을 반복 하는 &lt;code&gt;Decoder&lt;/code&gt; 를 구성합니다.</target>
        </trans-unit>
        <trans-unit id="edbcd15b10b6211f79e2728db1542060e841dc30" translate="yes" xml:space="preserve">
          <source>Construct a BitRange.</source>
          <target state="translated">BitRange를 구성하십시오.</target>
        </trans-unit>
        <trans-unit id="4e5951f021a460e25ffeab1777192f63d5dcad38" translate="yes" xml:space="preserve">
          <source>Construct a Processing Instruction section</source>
          <target state="translated">처리 명령 섹션 구성</target>
        </trans-unit>
        <trans-unit id="1f8c7657f3358e4444599716fc5a5104fadd594b" translate="yes" xml:space="preserve">
          <source>Construct a UUID struct from the 16 byte representation of a UUID.</source>
          <target state="translated">UUID의 16 바이트 표현에서 UUID 구조체를 구성하십시오.</target>
        </trans-unit>
        <trans-unit id="16a3dc0d5228e43b22556eb8ffea43940ae8f1b3" translate="yes" xml:space="preserve">
          <source>Construct a UUID struct from the 16 byte representation of a UUID. Variadic constructor to allow a simpler syntax, see examples. You need to pass exactly 16 ubytes.</source>
          <target state="translated">UUID의 16 바이트 표현에서 UUID 구조체를 구성하십시오. 보다 간단한 구문을 허용하는 다양한 생성자 (예제 참조) 정확히 16 바이트를 전달해야합니다.</target>
        </trans-unit>
        <trans-unit id="23141c0f7e0d7ab9526562ff979c5df531f9e26b" translate="yes" xml:space="preserve">
          <source>Construct a character data section</source>
          <target state="translated">문자 데이터 섹션 구성</target>
        </trans-unit>
        <trans-unit id="e7a49314abea8219c1157b1b3da7ac10cc878066" translate="yes" xml:space="preserve">
          <source>Construct a comment</source>
          <target state="translated">주석 구성</target>
        </trans-unit>
        <trans-unit id="a2c71e5e027279ee45a7931fee354af43aa8085a" translate="yes" xml:space="preserve">
          <source>Construct a complex number with the specified real and imaginary parts. In the case where a single argument is passed that is not complex, the imaginary part of the result will be zero.</source>
          <target state="translated">지정된 실수 부와 허수 부로 복소수를 만듭니다. 복잡하지 않은 단일 인수가 전달되는 경우 결과의 허수 부분은 0이됩니다.</target>
        </trans-unit>
        <trans-unit id="1f1465ea8ff9842efb9f4fb5533375eb53710f4b" translate="yes" xml:space="preserve">
          <source>Construct a new &lt;code&gt;FormatSpec&lt;/code&gt; using the format string &lt;code&gt;fmt&lt;/code&gt;, no processing is done until needed.</source>
          <target state="translated">형식 문자열 &lt;code&gt;fmt&lt;/code&gt; 를 사용하여 새 &lt;code&gt;FormatSpec&lt;/code&gt; 을 구성하십시오 . 필요한 때까지 처리가 수행되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="7b338b11da2dffa6fdc8f6e1cebf5a1fc9737f7a" translate="yes" xml:space="preserve">
          <source>Construct a new &lt;code&gt;Internet6Address&lt;/code&gt;.</source>
          <target state="translated">새로운 &lt;code&gt;Internet6Address&lt;/code&gt; 를 구축합니다 .</target>
        </trans-unit>
        <trans-unit id="2d79b3621c7911196f6ede8afe742e5c8ec1d706" translate="yes" xml:space="preserve">
          <source>Construct a new &lt;code&gt;InternetAddress&lt;/code&gt;.</source>
          <target state="translated">새로운 &lt;code&gt;InternetAddress&lt;/code&gt; 를 구축합니다 .</target>
        </trans-unit>
        <trans-unit id="a7538127e5f1404acba2c44fa3de190633fd2308" translate="yes" xml:space="preserve">
          <source>Construct a new &lt;code&gt;UnixAddress&lt;/code&gt; from the specified path.</source>
          <target state="translated">지정된 경로에서 새로운 &lt;code&gt;UnixAddress&lt;/code&gt; 를 구성합니다.</target>
        </trans-unit>
        <trans-unit id="dd446bfae9180e30b1daa43c407ceb3fdf970415" translate="yes" xml:space="preserve">
          <source>Construct a new &lt;code&gt;UnixAddress&lt;/code&gt;.</source>
          <target state="translated">새로운 &lt;code&gt;UnixAddress&lt;/code&gt; 를 구축합니다 .</target>
        </trans-unit>
        <trans-unit id="1bdec3f526944ac27208976a2f90415d2bb71451" translate="yes" xml:space="preserve">
          <source>Construct a new string from &lt;code&gt;input&lt;/code&gt; by replacing all of the fragments that match a pattern &lt;code&gt;re&lt;/code&gt; with a string generated from the match according to the &lt;code&gt;format&lt;/code&gt; specifier.</source>
          <target state="translated">의 새로운 캐릭터 구축 &lt;code&gt;input&lt;/code&gt; 패턴에 일치하는 조각을 모두 교체하여 &lt;code&gt;re&lt;/code&gt; 받는 따른 매치로부터 생성 된 문자열 &lt;code&gt;format&lt;/code&gt; 지정자.</target>
        </trans-unit>
        <trans-unit id="70db60e9276b0769769d7bc219186f785f9656d7" translate="yes" xml:space="preserve">
          <source>Construct a new string from &lt;code&gt;input&lt;/code&gt; by replacing the first match with a string generated from it according to the &lt;code&gt;format&lt;/code&gt; specifier.</source>
          <target state="translated">&lt;code&gt;format&lt;/code&gt; 지정자 에 따라 첫 번째 일치 항목을 생성 한 문자열로 대체하여 &lt;code&gt;input&lt;/code&gt; 에서 새 문자열 을 구성하십시오 .</target>
        </trans-unit>
        <trans-unit id="3cf2215c38ab2484cd95c1a3f8d7e5ea5d6e5d89" translate="yes" xml:space="preserve">
          <source>Construct a range iterating over an associative array by key/value tuples.</source>
          <target state="translated">키 / 값 튜플을 사용하여 연관 배열에서 반복되는 범위를 구성하십시오.</target>
        </trans-unit>
        <trans-unit id="e49b6c0e84de21ca12a39e319d7d0f1c33c4e83a" translate="yes" xml:space="preserve">
          <source>Construct a set from a forward range of code point intervals.</source>
          <target state="translated">코드 포인트 간격의 정방향 범위에서 세트를 구성하십시오.</target>
        </trans-unit>
        <trans-unit id="7ce8cada6e1ecb8296e6778664e7e54197cd4560" translate="yes" xml:space="preserve">
          <source>Construct a set from plain values of code point intervals.</source>
          <target state="translated">코드 포인트 간격의 일반 값으로 세트를 구성하십시오.</target>
        </trans-unit>
        <trans-unit id="f66ee7eaa1f920dff7ccd0302783f06c78ac43a1" translate="yes" xml:space="preserve">
          <source>Construct a specific point in time in the UTC timezone and add two days.</source>
          <target state="translated">UTC 시간대에서 특정 시점을 구성하고 이틀을 추가하십시오.</target>
        </trans-unit>
        <trans-unit id="d5725c80a7627176eef25dd37fe82818e437ca5c" translate="yes" xml:space="preserve">
          <source>Construct a specific point in time without timezone information and get its ISO string.</source>
          <target state="translated">시간대 정보없이 특정 시점을 구성하고 해당 ISO 문자열을 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="394f0b49b16c495da3d93936f500ab9712ce9376" translate="yes" xml:space="preserve">
          <source>Construct a ternary value from another ternary value</source>
          <target state="translated">다른 삼항 값에서 삼항 값 구성</target>
        </trans-unit>
        <trans-unit id="0e61b23e18fedae64c5d35d65cf20fb2f2d67df8" translate="yes" xml:space="preserve">
          <source>Construct a text (aka PCData) section</source>
          <target state="translated">텍스트 (일명 PCData) 섹션 구성</target>
        </trans-unit>
        <trans-unit id="84da9edb06d68da916babe0161ac2b1d6a5d7665" translate="yes" xml:space="preserve">
          <source>Construct a variable from &lt;code&gt;name&lt;/code&gt; and &lt;code&gt;value&lt;/code&gt; and put it in the environment while saving the previous value of the environment variable into a global list so it can be restored later.</source>
          <target state="translated">에서 변수 구축 &lt;code&gt;name&lt;/code&gt; 과 &lt;code&gt;value&lt;/code&gt; 하고 나중에 복원 할 수 있도록 글로벌 목록에 환경 변수의 이전 값을 저장하는 동안 환경에 넣어.</target>
        </trans-unit>
        <trans-unit id="49fa16f74b39989050bae31ab6353db2926f9d36" translate="yes" xml:space="preserve">
          <source>Construct an &lt;code&gt;Encoder&lt;/code&gt; that iterates over the Base64 encoding of the given &lt;a href=&quot;std_range_primitives#isInputRange&quot;&gt;input range&lt;/a&gt;.</source>
          <target state="translated">주어진 &lt;a href=&quot;std_range_primitives#isInputRange&quot;&gt;입력 범위&lt;/a&gt; 의 Base64 인코딩을 반복 하는 &lt;code&gt;Encoder&lt;/code&gt; 를 구성합니다 .</target>
        </trans-unit>
        <trans-unit id="aa8c85542dd824e935b81b57a1863e6723f75cb5" translate="yes" xml:space="preserve">
          <source>Construct an XML Instruction section</source>
          <target state="translated">XML 명령어 섹션 생성</target>
        </trans-unit>
        <trans-unit id="a194031f6ae934ce18b0c67914deaf21cac16ec1" translate="yes" xml:space="preserve">
          <source>Construct an archive out of the current members of the archive.</source>
          <target state="translated">현재 아카이브 멤버에서 아카이브를 구성하십시오.</target>
        </trans-unit>
        <trans-unit id="d5c166b2ff50eb5ec5eec43caf2eb44127f34619" translate="yes" xml:space="preserve">
          <source>Construct an associative array consisting of all abbreviations that uniquely map to the strings in values.</source>
          <target state="translated">값의 문자열에 고유하게 맵핑되는 모든 약어로 구성된 연관 배열을 구성하십시오.</target>
        </trans-unit>
        <trans-unit id="5cf702deece5ed2b82278e20dc28296a3a195348" translate="yes" xml:space="preserve">
          <source>Construct an associative array of type ti from keys and value</source>
          <target state="translated">키와 값으로 ti 유형의 연관 배열을 구성하십시오.</target>
        </trans-unit>
        <trans-unit id="e75af0c6e150db4d6b4dec02927806bba690aec9" translate="yes" xml:space="preserve">
          <source>Construct an identifier from a D slice</source>
          <target state="translated">D 슬라이스에서 식별자 구성</target>
        </trans-unit>
        <trans-unit id="80d4446ef4560aaedf6b918f5799b1c445900184" translate="yes" xml:space="preserve">
          <source>Construct and assign from a &lt;code&gt;bool&lt;/code&gt;, receiving &lt;code&gt;no&lt;/code&gt; for &lt;code&gt;false&lt;/code&gt; and &lt;code&gt;yes&lt;/code&gt; for &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">A로부터 구성하고 할당 &lt;code&gt;bool&lt;/code&gt; 수신 &lt;code&gt;no&lt;/code&gt; 에 대한 &lt;code&gt;false&lt;/code&gt; 과 &lt;code&gt;yes&lt;/code&gt; 에 대한 &lt;code&gt;true&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="647783f6e0c996a537f44ec3b423196a31d77d95" translate="yes" xml:space="preserve">
          <source>Construct and manipulate template argument lists (aka type lists).</source>
          <target state="translated">템플릿 인수 목록 (일명 유형 목록)을 구성하고 조작합니다.</target>
        </trans-unit>
        <trans-unit id="b7a26e15daa59c5841cd23ead59280c64ffa4247" translate="yes" xml:space="preserve">
          <source>Construct elem to run when an array bounds check fails.</source>
          <target state="translated">배열 경계 검사가 실패 할 때 실행할 elem을 구성하십시오.</target>
        </trans-unit>
        <trans-unit id="6de53d9bc658052402833a77bcc70a7c52e05729" translate="yes" xml:space="preserve">
          <source>Construct from another code point set of any type.</source>
          <target state="translated">모든 유형의 다른 코드 포인트 세트에서 구성하십시오.</target>
        </trans-unit>
        <trans-unit id="195707e72a012ddb97f51ce7407e70d2a55623c4" translate="yes" xml:space="preserve">
          <source>Construct new, useful general purpose types.</source>
          <target state="translated">새롭고 유용한 범용 유형을 구성하십시오.</target>
        </trans-unit>
        <trans-unit id="82ce738c4d85678079ef40a05612ba2651226474" translate="yes" xml:space="preserve">
          <source>Construct the array operation expression, call object.arrayOp!(tiargs)(args). Encode operand types and operations into tiargs using reverse polish notation (RPN) to preserve precedence. Unary operations are prefixed with &quot;u&quot; (e.g. &quot;u~&quot;). Pass operand values (slices or scalars) as args.</source>
          <target state="translated">배열 연산 식을 생성하고 object.arrayOp! (tiargs) (args)를 호출하십시오. 우선 순위를 유지하기 위해 RPN (Reverse Polish Notation)을 사용하여 피연산자 유형 및 연산을 tiarg로 인코딩합니다. 단항 연산은 &quot;u&quot;로 시작합니다 (예 : &quot;u ~&quot;). 피연산자 값 (슬라이스 또는 스칼라)을 인수로 전달합니다.</target>
        </trans-unit>
        <trans-unit id="2f3ec07075420c87a074dd94b630d897ff817037" translate="yes" xml:space="preserve">
          <source>Construct. destbufsize is the same as for D.zlib.uncompress().</source>
          <target state="translated">구성합니다. destbufsize는 D.zlib.uncompress ()와 동일합니다.</target>
        </trans-unit>
        <trans-unit id="1cba1d6a444e0426f16ee3f9f52dcc2b14b8af47" translate="yes" xml:space="preserve">
          <source>Constructed ArrayLiteralExp</source>
          <target state="translated">생성 된 ArrayLiteralExp</target>
        </trans-unit>
        <trans-unit id="da33e1b7e0c4eae1911ee4a15280f0990e1a6115" translate="yes" xml:space="preserve">
          <source>Construction</source>
          <target state="translated">Construction</target>
        </trans-unit>
        <trans-unit id="a3fe9a9b809ec5725205d76e7f854c1241a03e33" translate="yes" xml:space="preserve">
          <source>Construction and Reference Semantics</source>
          <target state="translated">구성 및 참조 의미론</target>
        </trans-unit>
        <trans-unit id="976162fa882990e03c8dd184b0b58a781b3a0c3b" translate="yes" xml:space="preserve">
          <source>Construction from an input and an index.</source>
          <target state="translated">입력과 색인으로 구성.</target>
        </trans-unit>
        <trans-unit id="2186eebe242de29328a263df29ae1111232f2644" translate="yes" xml:space="preserve">
          <source>Construction from an input.</source>
          <target state="translated">입력으로부터의 구성.</target>
        </trans-unit>
        <trans-unit id="b811fc2a657ea4e942e1143cd08736916b4217a0" translate="yes" xml:space="preserve">
          <source>Construction of lookup tables</source>
          <target state="translated">룩업 테이블의 건설</target>
        </trans-unit>
        <trans-unit id="6dd3a5d9a969f9c6c6072358abb68461c1de1b22" translate="yes" xml:space="preserve">
          <source>Construction or Assignment on Setting AA Entries</source>
          <target state="translated">AA 항목 설정에 대한 구성 또는 할당</target>
        </trans-unit>
        <trans-unit id="a494a02b46c9d078348d4b43daaa23777792b7f5" translate="yes" xml:space="preserve">
          <source>Constructor argument for default construction</source>
          <target state="translated">기본 구성에 대한 생성자 인수</target>
        </trans-unit>
        <trans-unit id="054ab73cf0d9f14ed49f82c4cff717124d2a513c" translate="yes" xml:space="preserve">
          <source>Constructor binding &lt;code&gt;this&lt;/code&gt; to &lt;code&gt;value&lt;/code&gt;.</source>
          <target state="translated">생성자 바인딩 &lt;code&gt;this&lt;/code&gt; 에 &lt;code&gt;value&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e7aca37d11a5dad62fa7753ebd2d62be1dbbcf19" translate="yes" xml:space="preserve">
          <source>Constructor for &lt;code&gt;JSONValue&lt;/code&gt;. If &lt;code&gt;arg&lt;/code&gt; is a &lt;code&gt;JSONValue&lt;/code&gt; its value and type will be copied to the new &lt;code&gt;JSONValue&lt;/code&gt;. Note that this is a shallow copy: if type is &lt;code&gt;JSONType.object&lt;/code&gt; or &lt;code&gt;JSONType.array&lt;/code&gt; then only the reference to the data will be copied. Otherwise, &lt;code&gt;arg&lt;/code&gt; must be implicitly convertible to one of the following types: &lt;code&gt;typeof(null)&lt;/code&gt;, &lt;code&gt;string&lt;/code&gt;, &lt;code&gt;ulong&lt;/code&gt;, &lt;code&gt;long&lt;/code&gt;, &lt;code&gt;double&lt;/code&gt;, an associative array &lt;code&gt;V[K]&lt;/code&gt; for any &lt;code&gt;V&lt;/code&gt; and &lt;code&gt;K&lt;/code&gt; i.e. a JSON object, any array or &lt;code&gt;bool&lt;/code&gt;. The type will be set accordingly.</source>
          <target state="translated">생성자 &lt;code&gt;JSONValue&lt;/code&gt; . 경우 &lt;code&gt;arg&lt;/code&gt; A는 &lt;code&gt;JSONValue&lt;/code&gt; 의 가치와 유형은 새에 복사됩니다 &lt;code&gt;JSONValue&lt;/code&gt; . 얕은 사본입니다. type이 &lt;code&gt;JSONType.object&lt;/code&gt; 또는 &lt;code&gt;JSONType.array&lt;/code&gt; 인 경우 데이터에 대한 참조 만 복사됩니다. 그렇지 않으면, &lt;code&gt;arg&lt;/code&gt; 는 &lt;code&gt;typeof(null)&lt;/code&gt; , &lt;code&gt;string&lt;/code&gt; , &lt;code&gt;ulong&lt;/code&gt; , &lt;code&gt;long&lt;/code&gt; , &lt;code&gt;double&lt;/code&gt; , &lt;code&gt;V&lt;/code&gt; 및 &lt;code&gt;K&lt;/code&gt; 에 대한 연관 배열 &lt;code&gt;V[K]&lt;/code&gt; , 즉 JSON 객체, 배열 또는 &lt;code&gt;bool&lt;/code&gt; 중 하나로 암시 적으로 변환 가능해야합니다.. 그에 따라 유형이 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="958db728358d20353a09b0ce14e29f648fa7b9b6" translate="yes" xml:space="preserve">
          <source>Constructor initializing &lt;code&gt;this&lt;/code&gt; with &lt;code&gt;value&lt;/code&gt;.</source>
          <target state="translated">생성자 초기화 &lt;code&gt;this&lt;/code&gt; 함께 &lt;code&gt;value&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0367f2949e838dbf344d79ca0be183c08f50ddea" translate="yes" xml:space="preserve">
          <source>Constructor taking a compatible &lt;code&gt;Tuple&lt;/code&gt;. Two &lt;code&gt;Tuple&lt;/code&gt;s are compatible &lt;b&gt;iff&lt;/b&gt; they are both of the same length, and, for each type &lt;code&gt;T&lt;/code&gt; on the left-hand side, the corresponding type &lt;code&gt;U&lt;/code&gt; on the right-hand side can implicitly convert to &lt;code&gt;T&lt;/code&gt;.</source>
          <target state="translated">호환되는 &lt;code&gt;Tuple&lt;/code&gt; 을 생성하는 생성자 . 두 &lt;code&gt;Tuple&lt;/code&gt; 들 호환되는 &lt;b&gt;IFF에&lt;/b&gt; 각 타입에 대해, 그들은 같은 길이의 모두가, 그리고 &lt;code&gt;T&lt;/code&gt; 왼쪽에, 해당 유형 &lt;code&gt;U&lt;/code&gt; 오른쪽에 암시 적으로 변환 할 수 있습니다 &lt;code&gt;T&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="82fb824d4d5cc73ecbddf2d369c8b6d494d4005e" translate="yes" xml:space="preserve">
          <source>Constructor taking a compatible array.</source>
          <target state="translated">호환 가능한 배열을 취하는 생성자</target>
        </trans-unit>
        <trans-unit id="337303cb1c4142f79bb21427c7834170cf217748" translate="yes" xml:space="preserve">
          <source>Constructor taking a number of items.</source>
          <target state="translated">여러 항목을 취하는 생성자.</target>
        </trans-unit>
        <trans-unit id="312dcee2fedfca8db731097219798f4fda057356" translate="yes" xml:space="preserve">
          <source>Constructor taking a number of nodes</source>
          <target state="translated">다수의 노드를 취하는 생성자</target>
        </trans-unit>
        <trans-unit id="39aa104961235c81ea7ce5789ee56792a20446f0" translate="yes" xml:space="preserve">
          <source>Constructor taking a value properly convertible to the underlying type. &lt;code&gt;U&lt;/code&gt; may be either an integral that can be converted to &lt;code&gt;T&lt;/code&gt; without a loss, or another &lt;code&gt;Checked&lt;/code&gt; instance whose representation may be in turn converted to &lt;code&gt;T&lt;/code&gt; without a loss.</source>
          <target state="translated">기본 유형으로 올바르게 변환 가능한 값을 취하는 생성자 &lt;code&gt;U&lt;/code&gt; 가 변환 될 수있는 일체 이어도 &lt;code&gt;T&lt;/code&gt; 손실없이, 또는 다른 &lt;code&gt;Checked&lt;/code&gt; 그 표현 될 수 차례 변환 인스턴스 &lt;code&gt;T&lt;/code&gt; 손실없이.</target>
        </trans-unit>
        <trans-unit id="c7462d0e28326868b6e970d116a087457bc47647" translate="yes" xml:space="preserve">
          <source>Constructor taking an &lt;a href=&quot;std_range_primitives#isInputRange&quot;&gt;input range&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;std_range_primitives#isInputRange&quot;&gt;입력 범위를&lt;/a&gt; 취하는 생성자</target>
        </trans-unit>
        <trans-unit id="028ef1ffceb1a8e2f931182078782ecd73909dff" translate="yes" xml:space="preserve">
          <source>Constructor taking one value for each field.</source>
          <target state="translated">각 필드에 대해 하나의 값을 취하는 생성자.</target>
        </trans-unit>
        <trans-unit id="ec87cd71d0c30421b4e1bbb4504a346899fd1803" translate="yes" xml:space="preserve">
          <source>Constructor taking the name of the file to open and the open mode.</source>
          <target state="translated">열려는 파일 이름과 열기 모드를 취하는 생성자.</target>
        </trans-unit>
        <trans-unit id="2b736db750e5b8588933a2cab677f5fbd588db97" translate="yes" xml:space="preserve">
          <source>Constructor taking the url as parameter.</source>
          <target state="translated">URL을 매개 변수로 사용하는 생성자</target>
        </trans-unit>
        <trans-unit id="2f815f9d325af38009f8487671b992fc3b8edee2" translate="yes" xml:space="preserve">
          <source>Constructor that initializes the payload.</source>
          <target state="translated">페이로드를 초기화하는 생성자</target>
        </trans-unit>
        <trans-unit id="016997051201ccc98c813dcc7c39a587d61ab8c6" translate="yes" xml:space="preserve">
          <source>Constructor that takes a &lt;code&gt;Unique&lt;/code&gt; of a type that is convertible to our type.</source>
          <target state="translated">우리 유형으로 변환 할 수 있는 &lt;code&gt;Unique&lt;/code&gt; 한 유형 을 취하는 생성자 .</target>
        </trans-unit>
        <trans-unit id="0b1f1dc0db9cef3da3b4be09aee734bc80e7d08c" translate="yes" xml:space="preserve">
          <source>Constructor that takes an lvalue. It nulls its source. The nulling will ensure uniqueness as long as there are no previous aliases to the source.</source>
          <target state="translated">lvalue를 취하는 생성자 소스를 무효로합니다. 널링은 소스에 대한 이전 별명이없는 한 고유성을 보장합니다.</target>
        </trans-unit>
        <trans-unit id="6d0b20d8fc18f15a14377620be1f3f6c18b63a08" translate="yes" xml:space="preserve">
          <source>Constructor that takes an rvalue. It will ensure uniqueness, as long as the rvalue isn't just a view on an lvalue (e.g., a cast). Typical usage:</source>
          <target state="translated">rvalue를 취하는 생성자 rvalue가 lvalue (예 : 캐스트)에 대한 관점이 아닌 한 고유성을 보장합니다. 일반적인 사용법 :</target>
        </trans-unit>
        <trans-unit id="05f636b7912d58ac3b449cb36c994c98a7238361" translate="yes" xml:space="preserve">
          <source>Constructor to use when creating a new archive.</source>
          <target state="translated">새로운 아카이브를 생성 할 때 사용할 생성자.</target>
        </trans-unit>
        <trans-unit id="7c1ac12e45facf352f3efe44eb326d743f2088a0" translate="yes" xml:space="preserve">
          <source>Constructor to use when reading an existing archive.</source>
          <target state="translated">기존 아카이브를 읽을 때 사용할 생성자입니다.</target>
        </trans-unit>
        <trans-unit id="48b7f1869a1fb50e06c68f08a76aa0238231d852" translate="yes" xml:space="preserve">
          <source>Constructor which takes an error message and error code.</source>
          <target state="translated">오류 메시지와 오류 코드를받는 생성자</target>
        </trans-unit>
        <trans-unit id="28237bb656117133502ebdcbb4cc87ee22fad07c" translate="yes" xml:space="preserve">
          <source>Constructor which takes an error message.</source>
          <target state="translated">에러 메세지를받는 생성자</target>
        </trans-unit>
        <trans-unit id="4c0e6f93d76eef0a5ad9b6d7bb2bad4c3b17cd12" translate="yes" xml:space="preserve">
          <source>Constructor which takes an error message. The current global &lt;a href=&quot;core_stdc_errno#errno&quot;&gt;&lt;code&gt;core.stdc.errno.errno&lt;/code&gt;&lt;/a&gt; value is used as error code.</source>
          <target state="translated">에러 메세지를받는 생성자 현재 전역 &lt;a href=&quot;core_stdc_errno#errno&quot;&gt; &lt;code&gt;core.stdc.errno.errno&lt;/code&gt; &lt;/a&gt; 값이 오류 코드로 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="4d4ae6f60e2d60a48fe329503bd32951d4cbc36d" translate="yes" xml:space="preserve">
          <source>Constructor which takes the error number (&lt;a href=&quot;https://google.com/search?btnI=I%27m+Feeling+Lucky&amp;amp;ie=UTF-8&amp;amp;oe=UTF-8&amp;amp;q=GetLastError&quot;&gt;GetLastError&lt;/a&gt; in Windows, errno in Posix).</source>
          <target state="translated">오류 번호를 갖는 생성자 ( Windows의 &lt;a href=&quot;https://google.com/search?btnI=I%27m+Feeling+Lucky&amp;amp;ie=UTF-8&amp;amp;oe=UTF-8&amp;amp;q=GetLastError&quot;&gt;GetLastError&lt;/a&gt; , Posix의 errno)</target>
        </trans-unit>
        <trans-unit id="ba2200976ccedc895aa8714dc1e6fb4e9038e5f4" translate="yes" xml:space="preserve">
          <source>Constructor.</source>
          <target state="translated">Constructor.</target>
        </trans-unit>
        <trans-unit id="fb6b24775698549efb7aa5531d3b2988935f90f6" translate="yes" xml:space="preserve">
          <source>Constructor. Pass in a range of elements to initialize the tree with.</source>
          <target state="translated">건설자. 트리를 초기화하려면 다양한 요소를 전달하십시오.</target>
        </trans-unit>
        <trans-unit id="1a178df59f99c60619523cc28c3159353aae12d6" translate="yes" xml:space="preserve">
          <source>Constructor. Pass in an array of elements, or individual elements to initialize the tree with.</source>
          <target state="translated">건설자. 요소의 배열 또는 개별 요소를 전달하여 트리를 초기화하십시오.</target>
        </trans-unit>
        <trans-unit id="60a5c966a71a24034f9238685790a526710ef75d" translate="yes" xml:space="preserve">
          <source>Constructors</source>
          <target state="translated">Constructors</target>
        </trans-unit>
        <trans-unit id="807d66814f4ba4f921c1396af90944a155259be3" translate="yes" xml:space="preserve">
          <source>Constructors accepting desired capacity or a preallocated buffer, similar in semantics to those of &lt;code&gt;BitmappedBlock&lt;/code&gt;.</source>
          <target state="translated">의미론의 것과 유사한 용량 원하는 또는 미리 할당 된 버퍼 수락 생성자 &lt;code&gt;BitmappedBlock&lt;/code&gt; 를 .</target>
        </trans-unit>
        <trans-unit id="16754c38fa1206780e385874d1438ae4c6a8b8c6" translate="yes" xml:space="preserve">
          <source>Constructors are defined with a function name of &lt;code&gt;this&lt;/code&gt; and having no return value. The grammar is the same as for the class &lt;a href=&quot;class#Constructor&quot;&gt;&lt;i&gt;Constructor&lt;/i&gt;&lt;/a&gt;.</source>
          <target state="translated">생성자는 함수의 이름으로 정의되는 &lt;code&gt;this&lt;/code&gt; 어떠한 리턴 값을 갖는 않는다. 문법은 &lt;a href=&quot;class#Constructor&quot;&gt;&lt;i&gt;Constructor&lt;/i&gt;&lt;/a&gt; 클래스와 동일 합니다.</target>
        </trans-unit>
        <trans-unit id="c2e6c63b9009979683923270fe7969b7aa741e91" translate="yes" xml:space="preserve">
          <source>Constructors are defined with a function name of &lt;code&gt;this&lt;/code&gt; and having no return value:</source>
          <target state="translated">생성자는 함수의 이름으로 정의되는 &lt;code&gt;this&lt;/code&gt; 더 리턴 값이없는 :</target>
        </trans-unit>
        <trans-unit id="fc2ab456b803f2a781f337931bdcedefaed757d1" translate="yes" xml:space="preserve">
          <source>Constructors can be overloaded with different attributes.</source>
          <target state="translated">생성자는 다른 속성으로 오버로드 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3aa2beb6e3d0ab0cb39859e1839af45b65f842fd" translate="yes" xml:space="preserve">
          <source>Constructors can call other constructors for the same class in order to share common initializations (this is called a delegating constructor):</source>
          <target state="translated">생성자는 공통 초기화를 공유하기 위해 동일한 클래스에 대해 다른 생성자를 호출 할 수 있습니다 (위임 생성자라고 함).</target>
        </trans-unit>
        <trans-unit id="3f4fc5393e597a57538cf4de6d5462b225d2d51e" translate="yes" xml:space="preserve">
          <source>Constructors can call other constructors for the same struct in order to share common initializations (this is called a &lt;a href=&quot;class#delegating-constructors&quot;&gt;delegating constructor&lt;/a&gt;):</source>
          <target state="translated">생성자는 공통 초기화를 공유하기 위해 동일한 구조체에 대해 다른 생성자를 호출 할 수 있습니다 ( &lt;a href=&quot;class#delegating-constructors&quot;&gt;위임 생성자&lt;/a&gt; 라고 함 ).</target>
        </trans-unit>
        <trans-unit id="5417b6074f85a905aed32a156a099f6cc6ef82a9" translate="yes" xml:space="preserve">
          <source>Constructors can have one of these member function attributes: &lt;code&gt;const&lt;/code&gt;, &lt;code&gt;immutable&lt;/code&gt;, and &lt;code&gt;shared&lt;/code&gt;. Construction of qualified objects will then be restricted to the implemented qualified constructors.</source>
          <target state="translated">생성자는 &lt;code&gt;const&lt;/code&gt; , &lt;code&gt;immutable&lt;/code&gt; 및 &lt;code&gt;shared&lt;/code&gt; 멤버 함수 속성 중 하나를 가질 수 있습니다 . 정규화 된 객체의 생성은 구현 된 정규화 된 생성자로 제한됩니다.</target>
        </trans-unit>
        <trans-unit id="6224547e06b5379ad7844e2e3e6bdd01e198c7c9" translate="yes" xml:space="preserve">
          <source>Constructors return the this pointer in EAX.</source>
          <target state="translated">생성자는이 포인터를 EAX로 반환합니다.</target>
        </trans-unit>
        <trans-unit id="e983ecc3235a082ac5ab3438cb35588e5913d548" translate="yes" xml:space="preserve">
          <source>Constructors setting up the memory structured as a free list.</source>
          <target state="translated">생성자는 사용 가능한 목록으로 구조화 된 메모리를 설정합니다.</target>
        </trans-unit>
        <trans-unit id="917fbdc8fb87d3240ea5d269d2fec24c7e203ffc" translate="yes" xml:space="preserve">
          <source>Constructs a &lt;a href=&quot;#Tuple&quot;&gt;&lt;code&gt;Tuple&lt;/code&gt;&lt;/a&gt; object instantiated and initialized according to the given arguments.</source>
          <target state="translated">주어진 인수에 따라 인스턴스화되고 초기화 된 &lt;a href=&quot;#Tuple&quot;&gt; &lt;code&gt;Tuple&lt;/code&gt; &lt;/a&gt; 객체를 구성합니다.</target>
        </trans-unit>
        <trans-unit id="dad768a1d3c806574ce4ef1d6f17739935f5ef4b" translate="yes" xml:space="preserve">
          <source>Constructs a &lt;code&gt;DirEntry&lt;/code&gt; for the given file (or directory).</source>
          <target state="translated">지정된 파일 (또는 디렉토리) 의 &lt;code&gt;DirEntry&lt;/code&gt; 를 구축합니다 .</target>
        </trans-unit>
        <trans-unit id="a1f2cf92b74dfa870775ce13ac3caf1d9e122173" translate="yes" xml:space="preserve">
          <source>Constructs a &lt;code&gt;RefAppender&lt;/code&gt; with a given array reference. This does not copy the data. If the array has a larger capacity as determined by &lt;code&gt;arr.capacity&lt;/code&gt;, it will be used by the appender.</source>
          <target state="translated">지정된 배열 참조 로 &lt;code&gt;RefAppender&lt;/code&gt; 를 구축합니다 . 이것은 데이터를 복사하지 않습니다. &lt;code&gt;arr.capacity&lt;/code&gt; 에 의해 결정된 배열의 용량이 더 큰 경우 어 펜더가 사용합니다.</target>
        </trans-unit>
        <trans-unit id="0a99c29487dadc182d8a3bda120934df206639c9" translate="yes" xml:space="preserve">
          <source>Constructs a &lt;code&gt;VariantN&lt;/code&gt; value given an argument of a generic type. Statically rejects disallowed types.</source>
          <target state="translated">구축 &lt;code&gt;VariantN&lt;/code&gt; 의 제네릭 형식의 인수 지정된 값을. 허용되지 않는 유형을 정적으로 거부합니다.</target>
        </trans-unit>
        <trans-unit id="4bc5b4b671ae60c2f6de52fe65f7ef1b9d577caf" translate="yes" xml:space="preserve">
          <source>Constructs a &lt;code&gt;XorshiftEngine&lt;/code&gt; generator seeded with x0.</source>
          <target state="translated">x0으로 시드 된 &lt;code&gt;XorshiftEngine&lt;/code&gt; 생성기를 구성합니다 .</target>
        </trans-unit>
        <trans-unit id="ecf8fa50fa09e85a50a7ee1d6d9cb5689198b305" translate="yes" xml:space="preserve">
          <source>Constructs a Document by parsing XML text.</source>
          <target state="translated">XML 텍스트를 구문 분석하여 문서를 구성합니다.</target>
        </trans-unit>
        <trans-unit id="142fbb3a4f3a407f93e0c16daba0bb5064ea4c6d" translate="yes" xml:space="preserve">
          <source>Constructs a Document from a Tag.</source>
          <target state="translated">태그에서 문서를 구성합니다.</target>
        </trans-unit>
        <trans-unit id="b95fdaa893c80a5c04bf4437cd4b6fdd348c04af" translate="yes" xml:space="preserve">
          <source>Constructs a DocumentParser.</source>
          <target state="translated">DocumentParser를 구축합니다.</target>
        </trans-unit>
        <trans-unit id="f20472cfd83dc45168ff0eb4d99a68f4a6aafcdf" translate="yes" xml:space="preserve">
          <source>Constructs a LinearCongruentialEngine generator seeded with &lt;code&gt;x0&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;x0&lt;/code&gt; 시드 된 LinearCongruentialEngine 생성기를 구성합니다 .</target>
        </trans-unit>
        <trans-unit id="233b957299550b15a28e3548a091cca8b823bc0f" translate="yes" xml:space="preserve">
          <source>Constructs a MersenneTwisterEngine object.</source>
          <target state="translated">MersenneTwisterEngine 객체를 구축합니다.</target>
        </trans-unit>
        <trans-unit id="9f9db8efce8dd429db5938c30a8f172827296779" translate="yes" xml:space="preserve">
          <source>Constructs a StopWatch. Whether it starts immediately depends on the &lt;a href=&quot;#AutoStart&quot;&gt;&lt;code&gt;AutoStart&lt;/code&gt;&lt;/a&gt; argument.</source>
          <target state="translated">스톱워치를 구성합니다. 시작 여부는 &lt;a href=&quot;#AutoStart&quot;&gt; &lt;code&gt;AutoStart&lt;/code&gt; &lt;/a&gt; 인수 에 따라 다릅니다 .</target>
        </trans-unit>
        <trans-unit id="00d1a29960b8444e123571c0597b354c35facc3d" translate="yes" xml:space="preserve">
          <source>Constructs a block allocator given a hunk of memory, or a desired capacity in bytes.</source>
          <target state="translated">메모리 덩어리 또는 원하는 용량 (바이트)이 주어지면 블록 할당자를 구성합니다.</target>
        </trans-unit>
        <trans-unit id="146e982316dbe394422d91958193b29e48ddcb91" translate="yes" xml:space="preserve">
          <source>Constructs a blocking IPv4 TCP Socket.</source>
          <target state="translated">차단 IPv4 TCP 소켓을 구성합니다.</target>
        </trans-unit>
        <trans-unit id="53247329cc6a51d22ab4698276b1f754d0339aaa" translate="yes" xml:space="preserve">
          <source>Constructs a blocking IPv4 UDP Socket.</source>
          <target state="translated">차단 IPv4 UDP 소켓을 구축합니다.</target>
        </trans-unit>
        <trans-unit id="f485ed96de3ac13b7303b9b65eca592e0443e023" translate="yes" xml:space="preserve">
          <source>Constructs a blocking TCP Socket and connects to an &lt;code&gt;Address&lt;/code&gt;.</source>
          <target state="translated">차단 TCP 소켓을 구성하고 &lt;code&gt;Address&lt;/code&gt; 에 연결합니다 .</target>
        </trans-unit>
        <trans-unit id="431478cfa4f05184c54f87ab32bb9c9692007e39" translate="yes" xml:space="preserve">
          <source>Constructs a blocking TCP Socket.</source>
          <target state="translated">블로킹 TCP 소켓을 구성합니다.</target>
        </trans-unit>
        <trans-unit id="d350c91652d7b9b0cd2159ce6cde3003102137a6" translate="yes" xml:space="preserve">
          <source>Constructs a blocking UDP Socket.</source>
          <target state="translated">블로킹 UDP 소켓을 구성합니다.</target>
        </trans-unit>
        <trans-unit id="17cdbaf765f763438b5c9e4f2e41158243f3b098" translate="yes" xml:space="preserve">
          <source>Constructs a complex number given its absolute value and argument.</source>
          <target state="translated">절대 값과 인수가 주어진 복소수를 구성합니다.</target>
        </trans-unit>
        <trans-unit id="6854fd227e337caa25e42f39155a6f82de1c1e18" translate="yes" xml:space="preserve">
          <source>Constructs a matcher object to classify &lt;a href=&quot;#Code%20point&quot;&gt;code points&lt;/a&gt; from the &lt;code&gt;set&lt;/code&gt; for encoding that has &lt;code&gt;Char&lt;/code&gt; as code unit.</source>
          <target state="translated">&lt;code&gt;Char&lt;/code&gt; 를 코드 단위로 사용 하는 인코딩 &lt;code&gt;set&lt;/code&gt; 에서 &lt;a href=&quot;#Code%20point&quot;&gt;코드 포인트&lt;/a&gt; 를 분류하는 matcher 객체를 구성합니다.</target>
        </trans-unit>
        <trans-unit id="ec9df545fbfee53dd90779724e7a812c8dc67a55" translate="yes" xml:space="preserve">
          <source>Constructs a message from the</source>
          <target state="translated">메시지를 구성합니다</target>
        </trans-unit>
        <trans-unit id="ea8599b64b5ab10e1403a39d677d9d23280a9390" translate="yes" xml:space="preserve">
          <source>Constructs a new function or delegate type with the same basic signature as the given one, but different attributes (including linkage).</source>
          <target state="translated">지정된 것과 동일한 기본 서명을 사용하지만 다른 속성 (링크 포함)을 사용하여 새 함수 또는 델리게이트 유형을 구성합니다.</target>
        </trans-unit>
        <trans-unit id="a007be1fb9fb1e9a3bb438949e90dfe8105d9f56" translate="yes" xml:space="preserve">
          <source>Constructs a region backed by a user-provided store. Assumes the memory was allocated with &lt;code&gt;ParentAllocator&lt;/code&gt; (if different from &lt;a href=&quot;std_experimental_allocator_building_blocks_null_allocator#NullAllocator&quot;&gt;&lt;code&gt;NullAllocator&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="translated">사용자 제공 상점이 지원하는 영역을 구성합니다. 메모리는 할당 된 가정합니다 &lt;code&gt;ParentAllocator&lt;/code&gt; (다를 경우 &lt;a href=&quot;std_experimental_allocator_building_blocks_null_allocator#NullAllocator&quot;&gt; &lt;code&gt;NullAllocator&lt;/code&gt; &lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="b06ce7a9e6471d4b389eadc615ef60d562d5d9b2" translate="yes" xml:space="preserve">
          <source>Constructs a static array from &lt;code&gt;a&lt;/code&gt;. The type of elements can be specified implicitly so that &lt;code&gt;[1, 2].staticArray&lt;/code&gt; results in &lt;code&gt;int[2]&lt;/code&gt;, or explicitly, e.g. &lt;code&gt;[1, 2].staticArray!float&lt;/code&gt; returns &lt;code&gt;float[2]&lt;/code&gt;. When &lt;code&gt;a&lt;/code&gt; is a range whose length is not known at compile time, the number of elements must be given as template argument (e.g. &lt;code&gt;myrange.staticArray!2&lt;/code&gt;). Size and type can be combined, if the source range elements are implicitly convertible to the requested element type (eg: &lt;code&gt;2.iota.staticArray!(long[2])&lt;/code&gt;). When the range &lt;code&gt;a&lt;/code&gt; is known at compile time, it can also be specified as a template argument to avoid having to specify the number of elements (e.g.: &lt;code&gt;staticArray!(2.iota)&lt;/code&gt; or &lt;code&gt;staticArray!(double, 2.iota)&lt;/code&gt;).</source>
          <target state="translated">에서 정적 배열을 생성 &lt;code&gt;a&lt;/code&gt; . 요소의 유형은 &lt;code&gt;[1, 2].staticArray&lt;/code&gt; 가 &lt;code&gt;int[2]&lt;/code&gt; 가되거나 명시 적으로 &lt;code&gt;[1, 2].staticArray!float&lt;/code&gt; 가 &lt;code&gt;float[2]&lt;/code&gt; 반환 하도록 암시 적으로 지정할 수 있습니다 . 때 &lt;code&gt;a&lt;/code&gt; 길이가 컴파일 타임에 알려지지 않은 범위는, 요소의 수는 템플릿 인수 (예로서 제공해야합니다 &lt;code&gt;myrange.staticArray!2&lt;/code&gt; ). 소스 범위 요소를 요청 된 요소 유형으로 암시 적으로 변환 할 수있는 경우 크기와 유형을 결합 할 수 있습니다 (예 : &lt;code&gt;2.iota.staticArray!(long[2])&lt;/code&gt; ). 범위 &lt;code&gt;a&lt;/code&gt; 컴파일 타임에 알려진 것으로, 요소의 수를 지정하지 않아도되는 템플릿 인수로 지정할 수도 있습니다 (예 : &lt;code&gt;staticArray!(2.iota)&lt;/code&gt; 또는 &lt;code&gt;staticArray!(double, 2.iota)&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="7781933a4887fd803519fc54f562055cd812781c" translate="yes" xml:space="preserve">
          <source>Constructs an &lt;code&gt;Address&lt;/code&gt; with a copy of the specified &lt;code&gt;sockaddr&lt;/code&gt;.</source>
          <target state="translated">지정된 &lt;code&gt;sockaddr&lt;/code&gt; 의 카피로 &lt;code&gt;Address&lt;/code&gt; 를 구축합니다 .</target>
        </trans-unit>
        <trans-unit id="9aec993528ca9dc016d572af7cf82ee72630798f" translate="yes" xml:space="preserve">
          <source>Constructs an &lt;code&gt;Address&lt;/code&gt; with a reference to the specified &lt;code&gt;sockaddr&lt;/code&gt;.</source>
          <target state="translated">지정된 &lt;code&gt;sockaddr&lt;/code&gt; 를 참조 해 &lt;code&gt;Address&lt;/code&gt; 를 구축합니다 .</target>
        </trans-unit>
        <trans-unit id="9615b78e90ddc4141b1f50da180143f27c8af2f7" translate="yes" xml:space="preserve">
          <source>Constructs an &lt;code&gt;AllocatorList&lt;/code&gt; given a factory object. This constructor is defined only if &lt;code&gt;Factory&lt;/code&gt; has state.</source>
          <target state="translated">팩토리 객체를 지정해 &lt;code&gt;AllocatorList&lt;/code&gt; 를 구축 합니다. 이 생성자는 &lt;code&gt;Factory&lt;/code&gt; 에 상태가있는 경우에만 정의됩니다 .</target>
        </trans-unit>
        <trans-unit id="0bb58461416282d926d1b319755b4712d0bb7ef9" translate="yes" xml:space="preserve">
          <source>Constructs an &lt;code&gt;Appender&lt;/code&gt; with a given array. Note that this does not copy the data. If the array has a larger capacity as determined by &lt;code&gt;arr.capacity&lt;/code&gt;, it will be used by the appender. After initializing an appender on an array, appending to the original array will reallocate.</source>
          <target state="translated">지정된 배열 로 &lt;code&gt;Appender&lt;/code&gt; 를 구축합니다 . 이것은 데이터를 복사하지 않습니다. &lt;code&gt;arr.capacity&lt;/code&gt; 에 의해 결정된 배열의 용량이 더 큰 경우 어 펜더가 사용합니다. 배열에서 어 펜더를 초기화 한 후 원래 배열에 추가하면 재 할당됩니다.</target>
        </trans-unit>
        <trans-unit id="0a3c9e846d5ff280c1c43c0fc859906e5949020f" translate="yes" xml:space="preserve">
          <source>Constructs an Element from a Tag.</source>
          <target state="translated">태그에서 요소를 구성합니다.</target>
        </trans-unit>
        <trans-unit id="b04b95cb59989b1f3e6f81986bdbf5684b4e8e11" translate="yes" xml:space="preserve">
          <source>Constructs an Element given a name and a string to be used as a Text interior.</source>
          <target state="translated">텍스트 내부로 사용될 이름과 문자열이 지정된 Element를 구성합니다.</target>
        </trans-unit>
        <trans-unit id="7ef5c16305c0cacfff7b62667368f5395c44c8f0" translate="yes" xml:space="preserve">
          <source>Constructs an instance of Tag with a specified name and type</source>
          <target state="translated">지정된 이름과 타입으로 Tag의 인스턴스를 구축합니다</target>
        </trans-unit>
        <trans-unit id="0eb54bebdca75e4774fca8547e272f327c707365" translate="yes" xml:space="preserve">
          <source>Constructs an object given two ranges &lt;code&gt;s&lt;/code&gt; and &lt;code&gt;t&lt;/code&gt; and a penalty &lt;code&gt;lambda&lt;/code&gt;. Constructor completes in &amp;Omicron;(&lt;code&gt;s.length * t.length&lt;/code&gt;) time and computes all matches of length 1.</source>
          <target state="translated">두 개의 범위 &lt;code&gt;s&lt;/code&gt; 와 &lt;code&gt;t&lt;/code&gt; 와 페널티 &lt;code&gt;lambda&lt;/code&gt; 주어진 객체를 구성합니다 . 생성자는 &amp;Omicron; ( &lt;code&gt;s.length * t.length&lt;/code&gt; ) 시간 내에 완료되고 길이 1의 모든 일치 항목을 계산합니다.</target>
        </trans-unit>
        <trans-unit id="1c2e1b07aa0f19ca657a0f923e6620e04e17d896" translate="yes" xml:space="preserve">
          <source>Constructs the HMAC digest using the specified secret.</source>
          <target state="translated">지정된 비밀을 사용해 HMAC 다이제스트를 구축합니다.</target>
        </trans-unit>
        <trans-unit id="3ac831e9f5e17e420e37b7e07bf6060ff89784d9" translate="yes" xml:space="preserve">
          <source>Container primitives</source>
          <target state="translated">컨테이너 프리미티브</target>
        </trans-unit>
        <trans-unit id="cdcf8089bd1bb28d912fe327273fec402f37b4f0" translate="yes" xml:space="preserve">
          <source>Containers do not form a class hierarchy, instead they implement a common set of primitives (see table below). These primitives each guarantee a specific worst case complexity and thus allow generic code to be written independently of the container implementation.</source>
          <target state="translated">컨테이너는 클래스 계층 구조를 형성하지 않고 일반적인 기본 세트를 구현합니다 (아래 표 참조). 이러한 프리미티브는 각각 최악의 특정 복잡성을 보장하므로 컨테이너 구현과 독립적으로 일반 코드를 작성할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3fc21d6c189ee8cb63a6e6aac085f59dcacbe434" translate="yes" xml:space="preserve">
          <source>Contains a memset implementation used by compiler-generated code.</source>
          <target state="translated">컴파일러 생성 코드에서 사용하는 memset 구현을 포함합니다.</target>
        </trans-unit>
        <trans-unit id="7a6f3a1f434d86f30876a874a0b93c581c1c8b1e" translate="yes" xml:space="preserve">
          <source>Contains a registry for GC factories.</source>
          <target state="translated">GC 팩토리의 레지스트리를 포함합니다.</target>
        </trans-unit>
        <trans-unit id="e083cdb203f74feb48a6a33669824a6e66cb3369" translate="yes" xml:space="preserve">
          <source>Contains aggregate information about a block of managed memory. The purpose of this struct is to support a more efficient query style in instances where detailed information is needed.</source>
          <target state="translated">관리 메모리 블록에 대한 집계 정보를 포함합니다. 이 구조체의 목적은 자세한 정보가 필요한 경우보다 효율적인 쿼리 스타일을 지원하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="29492764613b66bb03de8ad7679e7a717630eb80" translate="yes" xml:space="preserve">
          <source>Contains aggregated diagnostics information.</source>
          <target state="translated">집계 된 진단 정보를 포함합니다.</target>
        </trans-unit>
        <trans-unit id="273a7dc903587fcac7ec096b9861c3c1e1e83e38" translate="yes" xml:space="preserve">
          <source>Contains all available CLI &lt;a href=&quot;#Usage.Option&quot;&gt;&lt;code&gt;Usage.Option&lt;/code&gt;&lt;/a&gt;s.</source>
          <target state="translated">사용 가능한 모든 CLI &lt;a href=&quot;#Usage.Option&quot;&gt; &lt;code&gt;Usage.Option&lt;/code&gt; 을&lt;/a&gt; 포함합니다 .</target>
        </trans-unit>
        <trans-unit id="7ca74771e8e4d50838a5d61dfe30a32ee401633a" translate="yes" xml:space="preserve">
          <source>Contains all data for a class declaration that is needed for the Objective-C integration.</source>
          <target state="translated">Objective-C 통합에 필요한 클래스 선언에 대한 모든 데이터를 포함합니다.</target>
        </trans-unit>
        <trans-unit id="5758660e7aee75739c576bec5bbbf585a0eeed56" translate="yes" xml:space="preserve">
          <source>Contains all text which occurs after the root element. Defaults to the empty string</source>
          <target state="translated">루트 요소 다음에 나오는 모든 텍스트를 포함합니다. 빈 문자열을 기본값으로</target>
        </trans-unit>
        <trans-unit id="d8783cd5f87b85b9067504dfc5f62c8eeef387c4" translate="yes" xml:space="preserve">
          <source>Contains all text which occurs before the root element. Defaults to &amp;lt;?xml version=&quot;1.0&quot;?&amp;gt;</source>
          <target state="translated">루트 요소 앞에 나타나는 모든 텍스트를 포함합니다. 기본적으로 &amp;lt;? xml version = &quot;1.0&quot;?&amp;gt;</target>
        </trans-unit>
        <trans-unit id="08c7edba7490157d52a2bebdf452e082ec47a85a" translate="yes" xml:space="preserve">
          <source>Contains druntime startup and shutdown routines.</source>
          <target state="translated">druntime 시작 및 종료 루틴을 포함합니다.</target>
        </trans-unit>
        <trans-unit id="99a79c4c156e712bb397dee3eeb5c6eea6c0caf3" translate="yes" xml:space="preserve">
          <source>Contains implementations of functions called when the -profile=gc switch is thrown.</source>
          <target state="translated">-profile = gc 스위치가 발생할 때 호출되는 함수의 구현을 포함합니다.</target>
        </trans-unit>
        <trans-unit id="61ba82fdcfc8dae9c85e2e28e679b79ee9524ff4" translate="yes" xml:space="preserve">
          <source>Contains support code for code profiling.</source>
          <target state="translated">코드 프로파일 링을위한 지원 코드가 들어 있습니다.</target>
        </trans-unit>
        <trans-unit id="9d68b82f5a6be5a484ed9b7861d6e9244ca39d4e" translate="yes" xml:space="preserve">
          <source>Contains the elementary mathematical functions (powers, roots, and trigonometric functions), and low-level floating-point operations. Mathematical special functions are available in &lt;code&gt;std.mathspecial&lt;/code&gt;.</source>
          <target state="translated">기초 수학 함수 (승리, 근, 삼각 함수) 및 저수준 부동 소수점 연산을 포함합니다. 수학 특수 함수는 &lt;code&gt;std.mathspecial&lt;/code&gt; 에서 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="374abc9326723db2e7c697a2e6e4a267fe502ba8" translate="yes" xml:space="preserve">
          <source>Contains the garbage collector configuration.</source>
          <target state="translated">가비지 수집기 구성을 포함합니다.</target>
        </trans-unit>
        <trans-unit id="55cac8fa5f9a9f51445b40b028c04583fd1b7e94" translate="yes" xml:space="preserve">
          <source>Contains the implementation for object monitors.</source>
          <target state="translated">오브젝트 모니터 구현을 포함합니다.</target>
        </trans-unit>
        <trans-unit id="c43e50c1f103bb404d1f65f3ca0cac200dba4a52" translate="yes" xml:space="preserve">
          <source>Contains the internal GC interface.</source>
          <target state="translated">내부 GC 인터페이스를 포함합니다.</target>
        </trans-unit>
        <trans-unit id="a032e0777594355a5de7f90137f141d62d5d95dd" translate="yes" xml:space="preserve">
          <source>Contains various utility functions used by the runtime implementation.</source>
          <target state="translated">런타임 구현에서 사용되는 다양한 유틸리티 기능을 포함합니다.</target>
        </trans-unit>
        <trans-unit id="a08a8cb56aef49a4bb99834f8677b54329650228" translate="yes" xml:space="preserve">
          <source>Content of this structure depends on information which is known and is achievable (e.g. by FTP LIST parsing). Please see the url_easy_setopt(3) man page for callbacks returning this structure -- some fields are mandatory, some others are optional. The FLAG field has special meaning.</source>
          <target state="translated">이 구조의 내용은 알려지고 달성 할 수있는 정보 (예 : FTP LIST 구문 분석)에 따라 다릅니다. 이 구조를 반환하는 콜백에 대해서는 url_easy_setopt (3) 매뉴얼 페이지를 참조하십시오. 일부 필드는 필수이며 일부는 선택 사항입니다. FLAG 필드는 특별한 의미가 있습니다.</target>
        </trans-unit>
        <trans-unit id="77d12b97ba61ffccb079e0dd2ef6809c1e957255" translate="yes" xml:space="preserve">
          <source>Content-Type</source>
          <target state="translated">Content-Type</target>
        </trans-unit>
        <trans-unit id="98251b802b3d8e0fab3d7ef7d11a13d8ba221384" translate="yes" xml:space="preserve">
          <source>Context Limitation</source>
          <target state="translated">상황 제한</target>
        </trans-unit>
        <trans-unit id="6cc99c46b528420190afd0244c38be46fd558d8e" translate="yes" xml:space="preserve">
          <source>Continue Statement</source>
          <target state="translated">계속 진술</target>
        </trans-unit>
        <trans-unit id="e00690c736538c71ad18c2491100afa18d8ad07d" translate="yes" xml:space="preserve">
          <source>Continue to send authentication (user+password) when following locations, even when hostname changed. This can potentially send off the name and password to whatever host the server decides.</source>
          <target state="translated">호스트 이름이 변경된 경우에도 다음 위치에있을 때 인증 (사용자 + 암호)을 계속 보냅니다. 이것은 서버가 결정한 호스트에게 이름과 암호를 보낼 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="871aae3a25947aaa249c78c11e20e318f84bf435" translate="yes" xml:space="preserve">
          <source>Contract Programming</source>
          <target state="translated">계약 프로그래밍</target>
        </trans-unit>
        <trans-unit id="ef3ae2c761b4a2473b2910338e239fa3eb7fe7d0" translate="yes" xml:space="preserve">
          <source>ContractChecking &lt;strong id=&quot;arrayBounds&quot;&gt;arrayBounds&lt;/strong&gt;;</source>
          <target state="translated">ContractChecking &lt;strong id=&quot;arrayBounds&quot;&gt;arrayBounds&lt;/strong&gt; ;</target>
        </trans-unit>
        <trans-unit id="58b151a487b5b15bd53e628c2aa67fcd794d1b65" translate="yes" xml:space="preserve">
          <source>ContractChecking &lt;strong id=&quot;assert_&quot;&gt;assert_&lt;/strong&gt;;</source>
          <target state="translated">ContractChecking &lt;strong id=&quot;assert_&quot;&gt;assert_&lt;/strong&gt; ;</target>
        </trans-unit>
        <trans-unit id="5375164204a2f5e56cdbbed34a61f0552eceffaf" translate="yes" xml:space="preserve">
          <source>ContractChecking &lt;strong id=&quot;invariant_&quot;&gt;invariant_&lt;/strong&gt;;</source>
          <target state="translated">&lt;strong id=&quot;invariant_&quot;&gt;불변량&lt;/strong&gt; 계약 확인 ;</target>
        </trans-unit>
        <trans-unit id="07797d6d70881f0065abbaa5d2db584cee41ccbe" translate="yes" xml:space="preserve">
          <source>ContractChecking &lt;strong id=&quot;postcondition&quot;&gt;postcondition&lt;/strong&gt;;</source>
          <target state="translated">계약 확인 &lt;strong id=&quot;postcondition&quot;&gt;후 상태&lt;/strong&gt; ;</target>
        </trans-unit>
        <trans-unit id="b8c4e2d35f85c409b1763c5d617c7124eb387c47" translate="yes" xml:space="preserve">
          <source>ContractChecking &lt;strong id=&quot;precondition&quot;&gt;precondition&lt;/strong&gt;;</source>
          <target state="translated">계약 체결 &lt;strong id=&quot;precondition&quot;&gt;전제 조건&lt;/strong&gt; ;</target>
        </trans-unit>
        <trans-unit id="d8a121a438ee5a2fb57a169295d9586a112d6e2a" translate="yes" xml:space="preserve">
          <source>ContractChecking &lt;strong id=&quot;switchError&quot;&gt;switchError&lt;/strong&gt;;</source>
          <target state="translated">ContractChecking &lt;strong id=&quot;switchError&quot;&gt;switchError&lt;/strong&gt; ;</target>
        </trans-unit>
        <trans-unit id="32767bc87ce3ae8cd973b35c715a2ae94be49543" translate="yes" xml:space="preserve">
          <source>Contracts</source>
          <target state="translated">Contracts</target>
        </trans-unit>
        <trans-unit id="e08ca7a19394780a00d421700b2b6072e92cd151" translate="yes" xml:space="preserve">
          <source>Contracts Reading List</source>
          <target state="translated">계약서 읽기 목록</target>
        </trans-unit>
        <trans-unit id="4a6fd7ad54f6db44bd48aaa1e54275e15709f220" translate="yes" xml:space="preserve">
          <source>Contracts are a breakthrough technique to reduce the programming effort for large projects. Contracts are the concept of preconditions, postconditions, errors, and invariants.</source>
          <target state="translated">계약은 대규모 프로젝트의 프로그래밍 노력을 줄이는 혁신적인 기술입니다. 계약은 전제 조건, 사후 조건, 오류 및 변형의 개념입니다.</target>
        </trans-unit>
        <trans-unit id="ea1d3df298ca84104dbf8b2f6f916c02f6f77c6e" translate="yes" xml:space="preserve">
          <source>Control</source>
          <target state="translated">Control</target>
        </trans-unit>
        <trans-unit id="adf251f07168589eca3ad151f045da715921ca0e" translate="yes" xml:space="preserve">
          <source>Control Pictures</source>
          <target state="translated">사진 제어</target>
        </trans-unit>
        <trans-unit id="1c2234cbd63091af60ac97c73f8399e25e57cbf0" translate="yes" xml:space="preserve">
          <source>Control and configure the D runtime.</source>
          <target state="translated">D 런타임을 제어하고 구성하십시오.</target>
        </trans-unit>
        <trans-unit id="537748b8d0b3c009932ffdcb2807345633628bae" translate="yes" xml:space="preserve">
          <source>Control the Floating point hardware</source>
          <target state="translated">부동 소수점 하드웨어 제어</target>
        </trans-unit>
        <trans-unit id="c7f5075a114488026d76dd48e5050fddf4db4821" translate="yes" xml:space="preserve">
          <source>Control the built-in garbage collector.</source>
          <target state="translated">내장 가비지 수집기를 제어하십시오.</target>
        </trans-unit>
        <trans-unit id="6184ead7fbc8b585f30f7328c7d83cf9c22576b4" translate="yes" xml:space="preserve">
          <source>Control the various text mode attributes, such as color, when writing text to the console.</source>
          <target state="translated">콘솔에 텍스트를 쓸 때 색상과 같은 다양한 텍스트 모드 속성을 제어하십시오.</target>
        </trans-unit>
        <trans-unit id="0d531b827bceefa0692483efc8f1348a688772d8" translate="yes" xml:space="preserve">
          <source>Controls the assumptions the function makes about the lengths of the ranges</source>
          <target state="translated">함수가 범위의 길이에 대한 가정을 제어합니다.</target>
        </trans-unit>
        <trans-unit id="1fc385e9b61ce294ccbd6295a709917db7660e5f" translate="yes" xml:space="preserve">
          <source>Controls the assumptions the function makes about the lengths of the ranges (i.e. jagged or not)</source>
          <target state="translated">함수가 범위의 길이에 대한 가정을 제어합니다 (즉, 들쭉날쭉한지 여부)</target>
        </trans-unit>
        <trans-unit id="ea782105450bbc3723c1b76880caef4ed08032a7" translate="yes" xml:space="preserve">
          <source>Convenience Routines For Running Queries</source>
          <target state="translated">쿼리 실행을위한 편의 루틴</target>
        </trans-unit>
        <trans-unit id="bbaf8ee56cf3b9369018adb601f4bf25663e048e" translate="yes" xml:space="preserve">
          <source>Convenience aliases for &lt;a href=&quot;#dur&quot;&gt;&lt;code&gt;dur&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#dur&quot;&gt; &lt;code&gt;dur&lt;/code&gt; 에&lt;/a&gt; 대한 편의 별명 .</target>
        </trans-unit>
        <trans-unit id="bd805f155418cecaf1531265afd99b52aac61ab2" translate="yes" xml:space="preserve">
          <source>Convenience function for constructing a generic container.</source>
          <target state="translated">일반 컨테이너 구성을위한 편의 기능</target>
        </trans-unit>
        <trans-unit id="97a89cd2033f72e4eb474981a122ebe612ce8f03" translate="yes" xml:space="preserve">
          <source>Convenience function for creating a &lt;code&gt;Rebindable&lt;/code&gt; using automatic type inference.</source>
          <target state="translated">자동 형식 유추를 사용하여 &lt;code&gt;Rebindable&lt;/code&gt; 을 만드는 편의 기능 .</target>
        </trans-unit>
        <trans-unit id="7fe3ba594a0730c8377a41b425b9f0bdc446eba1" translate="yes" xml:space="preserve">
          <source>Convenience function for creating a &lt;code&gt;RedBlackTree!E&lt;/code&gt; from a list of values.</source>
          <target state="translated">값 목록에서 &lt;code&gt;RedBlackTree!E&lt;/code&gt; 를 작성하기위한 편의 기능 .</target>
        </trans-unit>
        <trans-unit id="5fcfa4530313650065bc0666bdfaa3f7071ece58" translate="yes" xml:space="preserve">
          <source>Convenience function for creating an &lt;code&gt;InputRangeObject&lt;/code&gt; of the proper type.</source>
          <target state="translated">적절한 타입 의 &lt;code&gt;InputRangeObject&lt;/code&gt; 를 작성하기위한 간이 함수입니다 .</target>
        </trans-unit>
        <trans-unit id="2deeddfbf7c17e3c5ed993f8f07764fedbbc9c86" translate="yes" xml:space="preserve">
          <source>Convenience function for creating an &lt;code&gt;InputRangeObject&lt;/code&gt; of the proper type. See &lt;a href=&quot;#InputRange&quot;&gt;&lt;code&gt;InputRange&lt;/code&gt;&lt;/a&gt; for an example.</source>
          <target state="translated">적절한 타입 의 &lt;code&gt;InputRangeObject&lt;/code&gt; 를 작성하기위한 간이 함수입니다 . 예제는 &lt;a href=&quot;#InputRange&quot;&gt; &lt;code&gt;InputRange&lt;/code&gt; &lt;/a&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="33f3457273684d37c964b9c19f1490014d05b78c" translate="yes" xml:space="preserve">
          <source>Convenience function for creating an &lt;code&gt;OutputRangeObject&lt;/code&gt; with a base range of type &lt;code&gt;R&lt;/code&gt; that accepts types &lt;code&gt;E&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;E&lt;/code&gt; 유형을 허용하는 &lt;code&gt;R&lt;/code&gt; 유형의 기본 범위를 갖는 &lt;code&gt;OutputRangeObject&lt;/code&gt; 를 작성하기위한 편의 함수입니다 .</target>
        </trans-unit>
        <trans-unit id="f13ca9b185b997f6100d99d5834656c2a0f654b1" translate="yes" xml:space="preserve">
          <source>Convenience function for creating an &lt;code&gt;OutputRangeObject&lt;/code&gt; with a base range of type R that accepts types E.</source>
          <target state="translated">E 유형을 허용하는 R 유형의 기본 범위로 &lt;code&gt;OutputRangeObject&lt;/code&gt; 를 작성하기위한 편의 함수</target>
        </trans-unit>
        <trans-unit id="543a17dfa7cd9fecc2d051d691cc274f44674a5b" translate="yes" xml:space="preserve">
          <source>Convenience function that forwards to &lt;code&gt;core.sys.posix.stdio.popen&lt;/code&gt; with appropriately-constructed C-style strings.</source>
          <target state="translated">적절하게 구성된 C 스타일 문자열을 사용 하여 &lt;code&gt;core.sys.posix.stdio.popen&lt;/code&gt; 으로 전달하는 편의 기능 .</target>
        </trans-unit>
        <trans-unit id="57e58ca108f45c53d8dfc085d29212201f4aa333" translate="yes" xml:space="preserve">
          <source>Convenience function that returns a &lt;a href=&quot;#RefAppender&quot;&gt;&lt;code&gt;RefAppender&lt;/code&gt;&lt;/a&gt; instance initialized with &lt;code&gt;arrayPtr&lt;/code&gt;. Don't use null for the array pointer, use the other version of &lt;code&gt;appender&lt;/code&gt; instead.</source>
          <target state="translated">반환 편리한 기능 &lt;a href=&quot;#RefAppender&quot;&gt; &lt;code&gt;RefAppender&lt;/code&gt; 의&lt;/a&gt; 로 초기화 예를 &lt;code&gt;arrayPtr&lt;/code&gt; 을 . 배열 포인터에 null을 사용하지 말고 다른 버전의 &lt;code&gt;appender&lt;/code&gt; 를 대신 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="281f96e0594e5b73a2e2e9d42b693c5d84ca8aef" translate="yes" xml:space="preserve">
          <source>Convenience function that returns a &lt;code&gt;BinaryHeap!Store&lt;/code&gt; object initialized with &lt;code&gt;s&lt;/code&gt; and &lt;code&gt;initialSize&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;s&lt;/code&gt; 및 &lt;code&gt;initialSize&lt;/code&gt; 로 초기화 된 &lt;code&gt;BinaryHeap!Store&lt;/code&gt; 객체 를 반환하는 간이 함수입니다 .</target>
        </trans-unit>
        <trans-unit id="dbf606ab86105b722d7651433b775855c8f60974" translate="yes" xml:space="preserve">
          <source>Convenience function that returns an &lt;a href=&quot;#Appender&quot;&gt;&lt;code&gt;Appender&lt;/code&gt;&lt;/a&gt; instance, optionally initialized with &lt;code&gt;array&lt;/code&gt;.</source>
          <target state="translated">선택적으로 &lt;code&gt;array&lt;/code&gt; 로 초기화 된 &lt;a href=&quot;#Appender&quot;&gt; &lt;code&gt;Appender&lt;/code&gt; &lt;/a&gt; 인스턴스 를 반환하는 편의 함수입니다 .</target>
        </trans-unit>
        <trans-unit id="47da49afa84caecf99a65771eecc2d27ea32a75e" translate="yes" xml:space="preserve">
          <source>Convenience function that turns an integral into the corresponding &lt;code&gt;Checked&lt;/code&gt; instance by using template argument deduction. The hook type may be specified (by default &lt;code&gt;Abort&lt;/code&gt;).</source>
          <target state="translated">템플릿 인수 공제를 사용하여 적분을 해당 &lt;code&gt;Checked&lt;/code&gt; 인스턴스 로 바꾸는 편의 기능 . 후크 유형을 지정할 수 있습니다 (기본적으로 &lt;code&gt;Abort&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="7eb2cf7a70b87e610611dcba9cc0bdabcaa306a1" translate="yes" xml:space="preserve">
          <source>Convenience function that uses type deduction to return the appropriate &lt;code&gt;FallbackAllocator&lt;/code&gt; instance. To initialize with allocators that don't have state, use their &lt;code&gt;it&lt;/code&gt; static member.</source>
          <target state="translated">형식 추론을 사용하여 적절한 &lt;code&gt;FallbackAllocator&lt;/code&gt; 인스턴스 를 반환하는 편의 함수입니다 . 상태가없는 할당 자와 함께 초기화하려면, 자신의 사용 &lt;code&gt;it&lt;/code&gt; 정적 멤버를.</target>
        </trans-unit>
        <trans-unit id="81c10fc980c8a23004da700f26d2e49b63195765" translate="yes" xml:space="preserve">
          <source>Convenience function to construct optimal configurations for packed Trie from any &lt;code&gt;set&lt;/code&gt; of &lt;a href=&quot;#Code%20point&quot;&gt;code points&lt;/a&gt;.</source>
          <target state="translated">편리한 기능은 어떤에서 포장 트리는을위한 최적의 구성을 구성하는 &lt;code&gt;set&lt;/code&gt; 의 &lt;a href=&quot;#Code%20point&quot;&gt;코드 포인트&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="fa203451ffb1f6e9e972677557577f159f71f56a" translate="yes" xml:space="preserve">
          <source>Convenience function which calls &lt;a href=&quot;std_range_primitives#popFrontN&quot;&gt;&lt;code&gt;std.range.primitives.popFrontN&lt;/code&gt;&lt;/a&gt;&lt;code&gt;(range, n)&lt;/code&gt; and returns &lt;code&gt;range&lt;/code&gt;. &lt;code&gt;drop&lt;/code&gt; makes it easier to pop elements from a range and then pass it to another function within a single expression, whereas &lt;code&gt;popFrontN&lt;/code&gt; would require multiple statements.</source>
          <target state="translated">&lt;a href=&quot;std_range_primitives#popFrontN&quot;&gt; &lt;code&gt;std.range.primitives.popFrontN&lt;/code&gt; &lt;/a&gt; &lt;code&gt;(range, n)&lt;/code&gt; 을 호출 하고 &lt;code&gt;range&lt;/code&gt; 를 반환 하는 편의 함수입니다 . &lt;code&gt;drop&lt;/code&gt; 을 사용하면 범위에서 요소를 더 쉽게 팝하고 단일 표현식 내에서 다른 함수로 전달할 수 있지만 &lt;code&gt;popFrontN&lt;/code&gt; 에는 여러 명령문이 필요합니다.</target>
        </trans-unit>
        <trans-unit id="6ed83ebf96e10dc1b8f43752d4d2a8c69a7ef125" translate="yes" xml:space="preserve">
          <source>Convenience function which calls &lt;code&gt;range.popFront()&lt;/code&gt; and returns &lt;code&gt;range&lt;/code&gt;. &lt;code&gt;dropOne&lt;/code&gt; makes it easier to pop an element from a range and then pass it to another function within a single expression, whereas &lt;code&gt;popFront&lt;/code&gt; would require multiple statements.</source>
          <target state="translated">&lt;code&gt;range.popFront()&lt;/code&gt; 를 호출 하고 &lt;code&gt;range&lt;/code&gt; 를 반환 하는 편의 함수입니다 . &lt;code&gt;dropOne&lt;/code&gt; 을 사용하면 범위에서 요소를 더 쉽게 팝한 다음 단일 표현식 내에서 다른 함수로 전달할 수 있지만 &lt;code&gt;popFront&lt;/code&gt; 에는 여러 명령문이 필요합니다.</target>
        </trans-unit>
        <trans-unit id="d00821ec7d482d22259510bb224af117d2300d18" translate="yes" xml:space="preserve">
          <source>Convenience function. Like find, but only returns whether or not the search was successful.</source>
          <target state="translated">편의 기능. 찾기와 같지만 검색이 성공했는지 여부 만 반환합니다.</target>
        </trans-unit>
        <trans-unit id="d3dc32f284d99498a3ff78fa7f8707de6601d006" translate="yes" xml:space="preserve">
          <source>Convenience functions for converting one or more arguments of any type into text (the three character widths).</source>
          <target state="translated">모든 유형의 하나 이상의 인수를 텍스트 (세 문자 너비)로 변환하기위한 편의 함수.</target>
        </trans-unit>
        <trans-unit id="63a9968094dce5e51d767213fb044fe75d3397ea" translate="yes" xml:space="preserve">
          <source>Convenience functions that create an &lt;code&gt;Fft&lt;/code&gt; object, run the FFT or inverse FFT and return the result. Useful for one-off FFTs.</source>
          <target state="translated">&lt;code&gt;Fft&lt;/code&gt; 객체 를 생성 하고 FFT를 실행하거나 역 FFT를 실행하여 결과를 반환하는 편의 함수입니다 . 일회성 FFT에 유용합니다.</target>
        </trans-unit>
        <trans-unit id="a5a94220c8ea5abfb148116a7e3799cbbf7ea2be" translate="yes" xml:space="preserve">
          <source>Convenience functions that forwards to &lt;code&gt;taskPool.parallel&lt;/code&gt;. The purpose of these is to make parallel foreach less verbose and more readable.</source>
          <target state="translated">&lt;code&gt;taskPool.parallel&lt;/code&gt; 로 전달하는 편의 기능 . 이것의 목적은 각각의 문장을 덜 장황하고 읽기 쉽게하기위한 것입니다.</target>
        </trans-unit>
        <trans-unit id="967ff579d1b9e412dbb4fb0ba6bf32a0206aa7b7" translate="yes" xml:space="preserve">
          <source>Convenience functions that throw an &lt;code&gt;StdioException&lt;/code&gt;.</source>
          <target state="translated">던져 편리한 기능 &lt;code&gt;StdioException&lt;/code&gt; 을 .</target>
        </trans-unit>
        <trans-unit id="4f361faef9831cb8d5034d73da3a4a91d8124d09" translate="yes" xml:space="preserve">
          <source>Convenience mixin for trivially sub-classing exceptions</source>
          <target state="translated">사소한 서브 클래 싱 예외를위한 편의 믹스 인</target>
        </trans-unit>
        <trans-unit id="df84ccbf276b4bf10a3abe6941075be97f75450b" translate="yes" xml:space="preserve">
          <source>Convenience names that allow using e.g. &lt;code&gt;Yes.encryption&lt;/code&gt; instead of &lt;code&gt;Flag!&quot;encryption&quot;.yes&lt;/code&gt; and &lt;code&gt;No.encryption&lt;/code&gt; instead of &lt;code&gt;Flag!&quot;encryption&quot;.no&lt;/code&gt;.</source>
          <target state="translated">예를 들어 &lt;code&gt;Flag!&quot;encryption&quot;.yes&lt;/code&gt; &lt;code&gt;No.encryption&lt;/code&gt; 대신 Yes.encryption! 및 &lt;code&gt;Flag!&quot;encryption&quot;.no&lt;/code&gt; 대신 &lt;code&gt;Yes.encryption&lt;/code&gt; 을 사용할 수있는 편의 이름 .</target>
        </trans-unit>
        <trans-unit id="1cb541d4dad444c9b9a7542a4394d7feffdcfdf0" translate="yes" xml:space="preserve">
          <source>Convenience wrapper around &lt;a href=&quot;#convClockFreq&quot;&gt;&lt;code&gt;convClockFreq&lt;/code&gt;&lt;/a&gt; which converts ticks at a clock frequency of &lt;code&gt;MonoTime.ticksPerSecond&lt;/code&gt; to nanoseconds.</source>
          <target state="translated">&lt;a href=&quot;#convClockFreq&quot;&gt; &lt;code&gt;convClockFreq&lt;/code&gt; &lt;/a&gt; 주변의 편의 래퍼로 MonoTime.ticksPerSecond 의 클럭 주파수에서 &lt;code&gt;MonoTime.ticksPerSecond&lt;/code&gt; 을 나노초 로 변환 합니다.</target>
        </trans-unit>
        <trans-unit id="2b5c35c190fd9666d416cddc663fbf2993d10e6b" translate="yes" xml:space="preserve">
          <source>Convenient operations commonly used with built-in arrays. Note that many common array operations are subsets of more generic algorithms that work with arbitrary ranges, so they are found in &lt;code&gt;std.algorithm&lt;/code&gt;.</source>
          <target state="translated">내장 어레이에 일반적으로 사용되는 편리한 조작. 많은 일반적인 배열 연산은 임의의 범위에서 작동하는보다 일반적인 알고리즘의 하위 집합이므로 &lt;code&gt;std.algorithm&lt;/code&gt; 에서 찾을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="61856b8c17a4ff32006fe4b7dcc6f96f253b2120" translate="yes" xml:space="preserve">
          <source>Conventions</source>
          <target state="translated">Conventions</target>
        </trans-unit>
        <trans-unit id="e5a1bf84f0030e4788165ba4a4686a376904272f" translate="yes" xml:space="preserve">
          <source>Conversely, all of the &lt;code&gt;out&lt;/code&gt; contracts need to be satisfied, so overriding functions becomes a processes of</source>
          <target state="translated">반대로 모든 &lt;code&gt;out&lt;/code&gt; 계약은 충족되어야하므로 재정의 기능은 다음과 같은 프로세스가됩니다.</target>
        </trans-unit>
        <trans-unit id="c5af5b7bf221e414a8c6a208feed4235fe84af14" translate="yes" xml:space="preserve">
          <source>Conversely, allocating memory with one non-&lt;code&gt;shared&lt;/code&gt; allocator, passing it across threads (by casting the obtained buffer to &lt;code&gt;shared&lt;/code&gt;), and later deallocating it in a different thread (either with a different allocator object or with the same allocator object after casting it to &lt;code&gt;shared&lt;/code&gt;) is illegal.</source>
          <target state="translated">반대로, 하나의 &lt;code&gt;shared&lt;/code&gt; 할당 자에 메모리를 할당하고, 스레드를 통해 메모리를 전달하고 (구입 된 버퍼를 &lt;code&gt;shared&lt;/code&gt; 로 캐스팅하여 ) 나중에 다른 스레드 (다른 할당 자 객체 또는 다른 할당 자 객체를 사용하여 캐스팅 한 후)에 할당 해제 &lt;code&gt;shared&lt;/code&gt; )는 불법입니다.</target>
        </trans-unit>
        <trans-unit id="9151f8433f795cb0f0b5b6743aeb7de77ec49f00" translate="yes" xml:space="preserve">
          <source>Conversion</source>
          <target state="translated">Conversion</target>
        </trans-unit>
        <trans-unit id="494c619bf8123d3b37b181684cb6338f68758f1b" translate="yes" xml:space="preserve">
          <source>Conversion from string types to char types enforces the input to consist of a single code point, and said code point must fit in the target type. Otherwise, &lt;a href=&quot;#ConvException&quot;&gt;&lt;code&gt;ConvException&lt;/code&gt;&lt;/a&gt; is thrown.</source>
          <target state="translated">문자열 유형에서 문자 유형으로 변환하면 입력이 단일 코드 포인트로 구성되고 해당 코드 포인트가 대상 유형에 맞아야합니다. 그렇지 않으면 &lt;a href=&quot;#ConvException&quot;&gt; &lt;code&gt;ConvException&lt;/code&gt; &lt;/a&gt; 이 발생합니다.</target>
        </trans-unit>
        <trans-unit id="9809150893d2b2bb036c8fb3972fbb95c93ae93b" translate="yes" xml:space="preserve">
          <source>Conversion operators. Convert from conversion operator to conversion index parallel array invconvtab[] in cgelem.c</source>
          <target state="translated">변환 연산자. cgelem.c의 변환 연산자에서 변환 색인 병렬 배열 invconvtab []로 변환</target>
        </trans-unit>
        <trans-unit id="6b9cd0af162c3095105f23d4382e114423f820eb" translate="yes" xml:space="preserve">
          <source>Conversion to bool and int</source>
          <target state="translated">bool 및 int로 변환</target>
        </trans-unit>
        <trans-unit id="b08eaadf77cfdba7944ddcaf69eee5a983b74af3" translate="yes" xml:space="preserve">
          <source>Conversions</source>
          <target state="translated">Conversions</target>
        </trans-unit>
        <trans-unit id="197e8fd63c43eaa131c7d71bd1c845f261c1ca73" translate="yes" xml:space="preserve">
          <source>Conversions from integral types to floating-point types always succeed, but might lose accuracy. The largest integers with a predecessor representable in floating-point format are &lt;code&gt;2^24-1&lt;/code&gt; for &lt;code&gt;float&lt;/code&gt;, &lt;code&gt;2^53-1&lt;/code&gt; for &lt;code&gt;double&lt;/code&gt;, and &lt;code&gt;2^64-1&lt;/code&gt; for &lt;code&gt;real&lt;/code&gt; (when &lt;code&gt;real&lt;/code&gt; is 80-bit, e.g. on Intel machines).</source>
          <target state="translated">정수 유형에서 부동 소수점 유형으로의 변환은 항상 성공하지만 정확도가 떨어질 수 있습니다. 부동 소수점 형식의 선행 표현할 수와 가장 큰 정수는 &lt;code&gt;2^24-1&lt;/code&gt; 에 대한 &lt;code&gt;float&lt;/code&gt; , &lt;code&gt;2^53-1&lt;/code&gt; 에 대한 &lt;code&gt;double&lt;/code&gt; , 및 &lt;code&gt;2^64-1&lt;/code&gt; 에 대한 &lt;code&gt;real&lt;/code&gt; (때 &lt;code&gt;real&lt;/code&gt; 인텔 시스템에서 80 비트, 예입니다) .</target>
        </trans-unit>
        <trans-unit id="86f181ecd6da52a393babcdf0413f894069d62dc" translate="yes" xml:space="preserve">
          <source>Conversions from string to numeric types differ from the C equivalents &lt;code&gt;atoi()&lt;/code&gt; and &lt;code&gt;atol()&lt;/code&gt; by checking for overflow and not allowing whitespace.</source>
          <target state="translated">문자열에서 숫자 유형으로의 변환은 오버 플로우를 확인하고 공백을 허용하지 않음에 따라 &lt;code&gt;atoi()&lt;/code&gt; 및 &lt;code&gt;atol()&lt;/code&gt; C와 다릅니다 .</target>
        </trans-unit>
        <trans-unit id="7d749a4f79969e83668c822ec3cb207e0dfcb26a" translate="yes" xml:space="preserve">
          <source>Conversions operate transitively, meaning that they work on arrays and associative arrays of any complexity.  This conversion works because &lt;code&gt;to!short&lt;/code&gt; applies to an &lt;code&gt;int&lt;/code&gt;, &lt;code&gt;to!wstring&lt;/code&gt; applies to a &lt;code&gt;string&lt;/code&gt;, &lt;code&gt;to!string&lt;/code&gt; applies to a &lt;code&gt;double&lt;/code&gt;, and &lt;code&gt;to!(double[])&lt;/code&gt; applies to an &lt;code&gt;int[]&lt;/code&gt;. The conversion might throw an exception because &lt;code&gt;to!short&lt;/code&gt; might fail the range check.</source>
          <target state="translated">변환은 전 이적으로 작동하므로 복잡한 배열 및 연관 배열에서 작동합니다. 때문에 변환 작업 &lt;code&gt;to!short&lt;/code&gt; 적용 &lt;code&gt;int&lt;/code&gt; , &lt;code&gt;to!wstring&lt;/code&gt; A를 적용 &lt;code&gt;string&lt;/code&gt; , &lt;code&gt;to!string&lt;/code&gt; A와 적용 &lt;code&gt;double&lt;/code&gt; , 그리고 &lt;code&gt;to!(double[])&lt;/code&gt; 에 적용 &lt;code&gt;int[]&lt;/code&gt; . &lt;code&gt;to!short&lt;/code&gt; 는 범위 검사에 실패 할 수 있으므로 변환에서 예외 가 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3f15ce79532d7a88716daffe2b5fa5245abe9c20" translate="yes" xml:space="preserve">
          <source>Convert</source>
          <target state="translated">Convert</target>
        </trans-unit>
        <trans-unit id="cbfd7dd188ff7f487f68697a8d34f14f04f7dec6" translate="yes" xml:space="preserve">
          <source>Convert Expression to elem, then append destructors for any temporaries created in elem.</source>
          <target state="translated">Expression을 elem으로 변환 한 다음 elem에서 만든 모든 임시 요소에 대해 소멸자를 추가합니다.</target>
        </trans-unit>
        <trans-unit id="300d1d44e039ebbc34544e6257ab84ea8d05e054" translate="yes" xml:space="preserve">
          <source>Convert MODxxxx to STCxxx</source>
          <target state="translated">MODxxxx를 STCxxx로 변환</target>
        </trans-unit>
        <trans-unit id="cac4192e2c3b155cebc1be34d4b77eb443e533c0" translate="yes" xml:space="preserve">
          <source>Convert Object to a human readable string.</source>
          <target state="translated">Object를 사람이 읽을 수있는 문자열로 변환하십시오.</target>
        </trans-unit>
        <trans-unit id="a157b506be054ad583671757f6739b58b4eae2cf" translate="yes" xml:space="preserve">
          <source>Convert Win32 error code to string.</source>
          <target state="translated">Win32 오류 코드를 문자열로 변환하십시오.</target>
        </trans-unit>
        <trans-unit id="8203e1072dab83cb9ec37a4f4016d9ab9deef361" translate="yes" xml:space="preserve">
          <source>Convert a callable to a delegate with the same parameter list and return type, avoiding heap allocations and use of auxiliary storage.</source>
          <target state="translated">힙 할당 및 보조 기억 장치 사용을 피하면서 호출 가능 매개 변수를 동일한 매개 변수 목록 및 리턴 유형을 가진 대리자로 변환하십시오.</target>
        </trans-unit>
        <trans-unit id="7616efe01f9711b656d048ab996095537d915ed4" translate="yes" xml:space="preserve">
          <source>Convert a narrow string to an array type that fully supports random access. This is handled as a special case and always returns an array of &lt;code&gt;dchar&lt;/code&gt;</source>
          <target state="translated">좁은 문자열을 임의 액세스를 완전히 지원하는 배열 유형으로 변환하십시오. 이것은 특별한 경우로 처리되며 항상 &lt;code&gt;dchar&lt;/code&gt; 배열을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="ae8c143fc472917c228a5c0ff4611ff8f4b320dd" translate="yes" xml:space="preserve">
          <source>Convert a string from one encoding to another.</source>
          <target state="translated">한 인코딩에서 다른 인코딩으로 문자열을 변환합니다.</target>
        </trans-unit>
        <trans-unit id="775fe4e45be29046b343c44db1012fcf4054e8bd" translate="yes" xml:space="preserve">
          <source>Convert an &lt;a href=&quot;std_range_primitives#isInputRange&quot;&gt;input range&lt;/a&gt; or a string to upper or lower case.</source>
          <target state="translated">&lt;a href=&quot;std_range_primitives#isInputRange&quot;&gt;입력 범위&lt;/a&gt; 또는 문자열을 대문자 또는 소문자로 변환하십시오 .</target>
        </trans-unit>
        <trans-unit id="c279cb7055f08eba41ad9320ed65a8b4bd24423e" translate="yes" xml:space="preserve">
          <source>Convert an IPv4 address number in host byte order to a human readable string representing the IPv4 address in dotted-decimal form.</source>
          <target state="translated">호스트 바이트 순서의 IPv4 주소 번호를 점으로 구분 된 십진수 형식으로 IPv4 주소를 나타내는 사람이 읽을 수있는 문자열로 변환하십시오.</target>
        </trans-unit>
        <trans-unit id="7a94a08d73d55d4d138a67dc22b14b4c3e02569f" translate="yes" xml:space="preserve">
          <source>Convert array to a dynamic array.</source>
          <target state="translated">배열을 동적 배열로 변환합니다.</target>
        </trans-unit>
        <trans-unit id="6ca78c70b84ae82ae6555ba40c8527618a61c871" translate="yes" xml:space="preserve">
          <source>Convert array to a pointer to the data.</source>
          <target state="translated">배열을 데이터에 대한 포인터로 변환하십시오.</target>
        </trans-unit>
        <trans-unit id="6a023ef771ded91cccae26939483968bef14680b" translate="yes" xml:space="preserve">
          <source>Convert expression into a delegate.</source>
          <target state="translated">식을 대리자로 변환합니다.</target>
        </trans-unit>
        <trans-unit id="21d2c697aa6b1950d17d8a4c4f437a6c775e1abd" translate="yes" xml:space="preserve">
          <source>Convert from pointer to exception_object field to pointer to CppExceptionHeader that it is embedded inside of.</source>
          <target state="translated">포인터를 exception_object 필드로 변환하고 그 안에 포함 된 CppExceptionHeader를 가리키는 포인터로 변환하십시오.</target>
        </trans-unit>
        <trans-unit id="ca97d234020c359f0ea9445b2940ce5ecabb073f" translate="yes" xml:space="preserve">
          <source>Convert from pointer to exception_object to pointer to ExceptionHeader that it is embedded inside of.</source>
          <target state="translated">내부에 포함 된 ExceptionHeader에 대한 포인터에서 exception_object로 변환하십시오.</target>
        </trans-unit>
        <trans-unit id="141d85c0215cf01962972ffaaf51166d383ad99a" translate="yes" xml:space="preserve">
          <source>Convert front end type &lt;code&gt;t&lt;/code&gt; to backend type &lt;code&gt;t.ctype&lt;/code&gt;. Memoize the result.</source>
          <target state="translated">프론트 엔드 유형 &lt;code&gt;t&lt;/code&gt; 를 백엔드 유형 &lt;code&gt;t.ctype&lt;/code&gt; 으로 변환하십시오 . 결과를 기억하십시오.</target>
        </trans-unit>
        <trans-unit id="cdd72d6f2bdb11b763377603b2356cca157b65d6" translate="yes" xml:space="preserve">
          <source>Convert integer to a range of characters. Intended to be lightweight and fast.</source>
          <target state="translated">정수를 문자 범위로 변환하십시오. 가볍고 빠르다.</target>
        </trans-unit>
        <trans-unit id="dbbceb68e9badc857157ec44ce9e4004ea0d70fb" translate="yes" xml:space="preserve">
          <source>Convert integral value to string in radix radix. radix must be a value from 2 to 36. value is treated as a signed value only if radix is 10. The characters A through Z are used to represent values 10 through 36 and their case is determined by the letterCase parameter.</source>
          <target state="translated">기수로 적분 값을 문자열로 변환합니다. 기수는 2-36 사이의 값이어야합니다. 기수는 10 인 경우에만 부호있는 값으로 처리됩니다. 문자 A-Z는 값 10-36을 나타내는 데 사용되며 대소 ​​문자는 letterCase 매개 변수에 의해 결정됩니다.</target>
        </trans-unit>
        <trans-unit id="c7b617a1afa58073368ac7644c913c0a1351ae0d" translate="yes" xml:space="preserve">
          <source>Convert internal buffer to array of chars.</source>
          <target state="translated">내부 버퍼를 문자 배열로 변환합니다.</target>
        </trans-unit>
        <trans-unit id="f1c0c49893f30f59cf861f572b87531ec8714ef8" translate="yes" xml:space="preserve">
          <source>Convert intrinsic function to operator.</source>
          <target state="translated">내장 함수를 연산자로 변환하십시오.</target>
        </trans-unit>
        <trans-unit id="df7a4dda020c82114c65501c86fda6ef64fb7578" translate="yes" xml:space="preserve">
          <source>Convert string contents to a 0 terminated string, allocated by mem.xmalloc().</source>
          <target state="translated">문자열 내용을 mem.xmalloc ()에 의해 할당 된 0 종료 문자열로 변환합니다.</target>
        </trans-unit>
        <trans-unit id="ec4aa6a499b7d8a47d71bacac0397813ddfaa4db" translate="yes" xml:space="preserve">
          <source>Convert string to char[].</source>
          <target state="translated">문자열을 char []로 변환하십시오.</target>
        </trans-unit>
        <trans-unit id="4e5b362d69a7b7939119a85847912d34f42f3d2a" translate="yes" xml:space="preserve">
          <source>Convert the &lt;code&gt;BigInt&lt;/code&gt; to &lt;code&gt;string&lt;/code&gt;, passing it to the given sink.</source>
          <target state="translated">지정된 싱크로 전달 하여 &lt;code&gt;BigInt&lt;/code&gt; 를 &lt;code&gt;string&lt;/code&gt; 으로 변환하십시오 .</target>
        </trans-unit>
        <trans-unit id="7e697a11907653a602483019409a860f0b6b446e" translate="yes" xml:space="preserve">
          <source>Convert the result of &lt;code&gt;__traits(getParameterStorageClasses)&lt;/code&gt; to &lt;a href=&quot;#ParameterStorageClass&quot;&gt;&lt;code&gt;ParameterStorageClass&lt;/code&gt;&lt;/a&gt;&lt;code&gt;enum&lt;/code&gt;s.</source>
          <target state="translated">&lt;code&gt;__traits(getParameterStorageClasses)&lt;/code&gt; 의 결과 를 &lt;a href=&quot;#ParameterStorageClass&quot;&gt; &lt;code&gt;ParameterStorageClass&lt;/code&gt; &lt;/a&gt; &lt;code&gt;enum&lt;/code&gt; 변환하십시오 .</target>
        </trans-unit>
        <trans-unit id="7da59e0b399f4430a5165fc7efc2188b462909d8" translate="yes" xml:space="preserve">
          <source>Convert to 'const'.</source>
          <target state="translated">'const'로 변환하십시오.</target>
        </trans-unit>
        <trans-unit id="2d339781d067223d4ff6ffa91e1a499862e4e10d" translate="yes" xml:space="preserve">
          <source>Convert to 'immutable'.</source>
          <target state="translated">'불변'으로 변환하십시오.</target>
        </trans-unit>
        <trans-unit id="64a97922b6ad5fabb50249f78bb7261af9bfcdc7" translate="yes" xml:space="preserve">
          <source>Convert to 'wild'.</source>
          <target state="translated">'wild'로 변환하십시오.</target>
        </trans-unit>
        <trans-unit id="87e0f4222e74eab68817299371f9ec11a177e211" translate="yes" xml:space="preserve">
          <source>Convert to &lt;code&gt;size_t[]&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;size_t[]&lt;/code&gt; 변환하십시오 .</target>
        </trans-unit>
        <trans-unit id="2b01671f329e1e8db8dfaf9b057f7d93f19d92bc" translate="yes" xml:space="preserve">
          <source>Convert to &lt;code&gt;void[]&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;void[]&lt;/code&gt; 변환하십시오 .</target>
        </trans-unit>
        <trans-unit id="e7e573911db63a61f22b50d1d7f51e71f6801020" translate="yes" xml:space="preserve">
          <source>Convert to array of bytes.</source>
          <target state="translated">바이트 배열로 변환합니다.</target>
        </trans-unit>
        <trans-unit id="81f5f7ef2860779e845c8d181cf922cbaa33cd4e" translate="yes" xml:space="preserve">
          <source>Convert types from one type to another.</source>
          <target state="translated">한 유형에서 다른 유형으로 유형을 변환하십시오.</target>
        </trans-unit>
        <trans-unit id="f2ca50a2d69bd1118ceb42e9e63fb2cadf8cec83" translate="yes" xml:space="preserve">
          <source>Convert wrapped value to a human readable string</source>
          <target state="translated">랩핑 된 값을 사람이 읽을 수있는 문자열로 변환</target>
        </trans-unit>
        <trans-unit id="792ceeff170dffe3167fec916d1a3b1293c9dd91" translate="yes" xml:space="preserve">
          <source>Converted to D from curl headers by &lt;a href=&quot;http://www.digitalmars.com/d/2.0/htod.html&quot;&gt;htod&lt;/a&gt; and cleaned up by Jonas Drewsen (jdrewsen)</source>
          <target state="translated">&lt;a href=&quot;http://www.digitalmars.com/d/2.0/htod.html&quot;&gt;htod에&lt;/a&gt; 의해 curl header에서 D로 변환 되고 Jonas Drewsen (jdrewsen)에 의해 정리</target>
        </trans-unit>
        <trans-unit id="b36e0d9093c25cbc6e2a4908ce26bc8670d8275a" translate="yes" xml:space="preserve">
          <source>Converting a value to its own type (useful mostly for generic code) simply returns its argument.</source>
          <target state="translated">값을 고유 한 유형으로 변환하면 (일반적으로 일반 코드에 유용함) 단순히 인수를 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="450f535fe5b129de6888d6e0eaa750ca3a090834" translate="yes" xml:space="preserve">
          <source>Converting among numeric types is a safe way to cast them around.  Conversions from floating-point types to integral types allow loss of precision (the fractional part of a floating-point number). The conversion is truncating towards zero, the same way a cast would truncate. (To round a floating point value when casting to an integral, use &lt;code&gt;roundTo&lt;/code&gt;.)</source>
          <target state="translated">숫자 유형간에 변환하는 것이 안전한 방법입니다. 부동 소수점 유형에서 정수 유형으로 변환하면 정밀도 손실 (부동 소수점 수의 소수 부분)이 허용됩니다. 캐스트가 잘리는 것과 같은 방식으로 변환이 0으로 잘립니다. 정수로 캐스트 할 때 부동 소수점 값을 반올림하려면 &lt;code&gt;roundTo&lt;/code&gt; 를 사용 하십시오 .</target>
        </trans-unit>
        <trans-unit id="031bf48dec6b48a765724d561163e257c0bd643c" translate="yes" xml:space="preserve">
          <source>Converting an array to another array type works by converting each element in turn. Associative arrays can be converted to associative arrays as long as keys and values can in turn be converted.</source>
          <target state="translated">각 요소를 차례로 변환하면 배열을 다른 배열 유형으로 변환 할 수 있습니다. 키와 값을 차례로 변환 할 수 있으면 연관 배열을 연관 배열로 변환 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d54717abb3bcd9a560b4033abb55a3f1b9abaf0c" translate="yes" xml:space="preserve">
          <source>Converting text to any of the four normalization forms via &lt;a href=&quot;#normalize&quot;&gt;&lt;code&gt;normalize&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">를 통해 네 개의 정규화 형태의 텍스트를 변환 &lt;a href=&quot;#normalize&quot;&gt; &lt;code&gt;normalize&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="a774f38191f5ee26ac3460d0bd0ede6e3b255259" translate="yes" xml:space="preserve">
          <source>Converts &lt;code&gt;s&lt;/code&gt; to lowercase (by performing Unicode lowercase mapping) in place. For a few characters string length may increase after the transformation, in such a case the function reallocates exactly once. If &lt;code&gt;s&lt;/code&gt; does not have any uppercase characters, then &lt;code&gt;s&lt;/code&gt; is unaltered.</source>
          <target state="translated">변환 &lt;code&gt;s&lt;/code&gt; 대신에 (유니 코드 소문자 매핑을 수행하여) 소문자로. 변환 후 몇 자의 문자열 길이가 증가 할 수 있으며,이 경우 함수가 정확히 한 번 재 할당됩니다. 경우 &lt;code&gt;s&lt;/code&gt; 모든 대문자가없는 한 다음 &lt;code&gt;s&lt;/code&gt; 변경되지 않은 것입니다.</target>
        </trans-unit>
        <trans-unit id="f50788ea46280702695186b92c1242c64d22af55" translate="yes" xml:space="preserve">
          <source>Converts &lt;code&gt;s&lt;/code&gt; to uppercase (by performing Unicode uppercase mapping) in place. For a few characters string length may increase after the transformation, in such a case the function reallocates exactly once. If &lt;code&gt;s&lt;/code&gt; does not have any lowercase characters, then &lt;code&gt;s&lt;/code&gt; is unaltered.</source>
          <target state="translated">&lt;code&gt;s&lt;/code&gt; 를 대문자로 변환합니다 (유니 코드 대문자 매핑을 수행하여). 변환 후 몇 자의 문자열 길이가 증가 할 수 있으며,이 경우 함수가 정확히 한 번 재 할당됩니다. 경우 &lt;code&gt;s&lt;/code&gt; 모든 소문자가없는 한 다음 &lt;code&gt;s&lt;/code&gt; 변경되지 않은 것입니다.</target>
        </trans-unit>
        <trans-unit id="1ae33ebc9b2f5b3c2490b1760900c22c6b676fbc" translate="yes" xml:space="preserve">
          <source>Converts a &lt;a href=&quot;#SysTime&quot;&gt;&lt;code&gt;SysTime&lt;/code&gt;&lt;/a&gt; to a &lt;code&gt;FILETIME&lt;/code&gt; struct.</source>
          <target state="translated">&lt;a href=&quot;#SysTime&quot;&gt; &lt;code&gt;SysTime&lt;/code&gt; &lt;/a&gt; 을 &lt;code&gt;FILETIME&lt;/code&gt; 구조체 로 변환합니다 .</target>
        </trans-unit>
        <trans-unit id="56be3b4d1a90af46d0b4592f89cac9048787f523" translate="yes" xml:space="preserve">
          <source>Converts a &lt;a href=&quot;#SysTime&quot;&gt;&lt;code&gt;SysTime&lt;/code&gt;&lt;/a&gt; to a &lt;code&gt;SYSTEMTIME&lt;/code&gt; struct.</source>
          <target state="translated">&lt;a href=&quot;#SysTime&quot;&gt; &lt;code&gt;SysTime&lt;/code&gt; &lt;/a&gt; 을 &lt;code&gt;SYSTEMTIME&lt;/code&gt; 구조체 로 변환합니다 .</target>
        </trans-unit>
        <trans-unit id="894edb86f4a8a0cd1f69c6b5d9062818feeb4ddd" translate="yes" xml:space="preserve">
          <source>Converts a &lt;code&gt;FILETIME&lt;/code&gt; struct to a &lt;a href=&quot;#SysTime&quot;&gt;&lt;code&gt;SysTime&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;FILETIME&lt;/code&gt; 구조체를 &lt;a href=&quot;#SysTime&quot;&gt; &lt;code&gt;SysTime&lt;/code&gt; 으로&lt;/a&gt; 변환합니다 .</target>
        </trans-unit>
        <trans-unit id="ed832f63736b31569fc124964cd3c928884d26d6" translate="yes" xml:space="preserve">
          <source>Converts a &lt;code&gt;FILETIME&lt;/code&gt; struct to the number of hnsecs since midnight, January 1st, 1 A.D.</source>
          <target state="translated">&lt;code&gt;FILETIME&lt;/code&gt; 구조체를 AD 1 월 1 일 자정 이후의 hnsec 수로 변환</target>
        </trans-unit>
        <trans-unit id="cf543602844b3062641ecae07379d485cf8d1e9c" translate="yes" xml:space="preserve">
          <source>Converts a &lt;code&gt;SYSTEMTIME&lt;/code&gt; struct to a &lt;a href=&quot;#SysTime&quot;&gt;&lt;code&gt;SysTime&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;SYSTEMTIME&lt;/code&gt; 구조체를 &lt;a href=&quot;#SysTime&quot;&gt; &lt;code&gt;SysTime&lt;/code&gt; 으로&lt;/a&gt; 변환합니다 .</target>
        </trans-unit>
        <trans-unit id="543b837fe53783efdefb34be70919c615cbd90b2" translate="yes" xml:space="preserve">
          <source>Converts a &lt;code&gt;TickDuration&lt;/code&gt; to the given units as either an integral value or a floating point value.</source>
          <target state="translated">&lt;code&gt;TickDuration&lt;/code&gt; 을 정수 또는 부동 소수점 값으로 지정된 단위로 변환 합니다.</target>
        </trans-unit>
        <trans-unit id="da8e27299262cc14743b153feb76d11d4fc53020" translate="yes" xml:space="preserve">
          <source>Converts a callable to a delegate.</source>
          <target state="translated">콜 러블을 델리게이트로 변환합니다.</target>
        </trans-unit>
        <trans-unit id="b2246d69735597617ac670e1cd79c63e9b7c718e" translate="yes" xml:space="preserve">
          <source>Converts a hex literal to a string at compile time.</source>
          <target state="translated">컴파일 타임에 16 진 리터럴을 문자열로 변환합니다.</target>
        </trans-unit>
        <trans-unit id="12fd3fc98603c4c30662a5d938bee086fc318076" translate="yes" xml:space="preserve">
          <source>Converts a number of hnsecs since midnight, January 1st, 1 A.D. to a &lt;code&gt;FILETIME&lt;/code&gt; struct.</source>
          <target state="translated">AD 1 월 1 일 자정 이후의 hnsec 수를 &lt;code&gt;FILETIME&lt;/code&gt; 구조체로 변환합니다.</target>
        </trans-unit>
        <trans-unit id="e8645b8b019a6a92357fd2abaf953b052fdc1822" translate="yes" xml:space="preserve">
          <source>Converts an ASCII letter to lowercase.</source>
          <target state="translated">ASCII 문자를 소문자로 변환합니다.</target>
        </trans-unit>
        <trans-unit id="498c6f9ce172411761c196b39cf785adcfc26947" translate="yes" xml:space="preserve">
          <source>Converts an ASCII letter to uppercase.</source>
          <target state="translated">ASCII 문자를 대문자로 변환합니다.</target>
        </trans-unit>
        <trans-unit id="f236af9686b5551670717880afe98b4a169a9b35" translate="yes" xml:space="preserve">
          <source>Converts any foreach-iterable entity (e.g. an input range) to an alias sequence.</source>
          <target state="translated">각각의 반복 가능한 엔티티 (예 : 입력 범위)를 별명 시퀀스로 변환합니다.</target>
        </trans-unit>
        <trans-unit id="9cd9c57aa4a490cac5e73dc3d34bbb7dcb896ecd" translate="yes" xml:space="preserve">
          <source>Converts array (other than strings) to string. Each element is converted by calling &lt;code&gt;to!T&lt;/code&gt;.</source>
          <target state="translated">문자열 이외의 배열을 문자열로 변환합니다. 각 요소는 &lt;code&gt;to!T&lt;/code&gt; 를 호출 하여 변환됩니다 .</target>
        </trans-unit>
        <trans-unit id="7f0da0dc296d4db8687cb43fe21c97d98f43b18d" translate="yes" xml:space="preserve">
          <source>Converts from &lt;a href=&quot;#SysTime&quot;&gt;&lt;code&gt;SysTime&lt;/code&gt;&lt;/a&gt; to DOS file date/time.</source>
          <target state="translated">&lt;a href=&quot;#SysTime&quot;&gt; &lt;code&gt;SysTime&lt;/code&gt; &lt;/a&gt; 에서 DOS 파일 날짜 / 시간으로 변환 합니다.</target>
        </trans-unit>
        <trans-unit id="203d4991495ad2a5ccd5bf2eb36f27bdb41d0ab3" translate="yes" xml:space="preserve">
          <source>Converts from DOS file date/time to &lt;a href=&quot;#SysTime&quot;&gt;&lt;code&gt;SysTime&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">DOS 파일 날짜 / 시간에서 &lt;a href=&quot;#SysTime&quot;&gt; &lt;code&gt;SysTime&lt;/code&gt; &lt;/a&gt; 으로 변환 합니다.</target>
        </trans-unit>
        <trans-unit id="96775ca56ca5ed48ab90888921d90905553fc258" translate="yes" xml:space="preserve">
          <source>Converts from unix time (i.e. seconds from midnight, January 1st, 1970 in UTC) to a &lt;a href=&quot;#SysTime&quot;&gt;&lt;code&gt;SysTime&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">유닉스 시간 (즉, 1970 년 1 월 1 일 자정에서 UTC로 초)을 &lt;a href=&quot;#SysTime&quot;&gt; &lt;code&gt;SysTime&lt;/code&gt; 으로 변환&lt;/a&gt; 합니다.</target>
        </trans-unit>
        <trans-unit id="47a6cd5246b5128f541dc1f56c74256ce4a5cf6e" translate="yes" xml:space="preserve">
          <source>Converts from unix time (which uses midnight, January 1st, 1970 UTC as its epoch and seconds as its units) to &quot;std time&quot; (which uses midnight, January 1st, 1 A.D. UTC and hnsecs as its units).</source>
          <target state="translated">unix 시간 (1970 년 1 월 1 일 자정을 UTC로, 초를 단위로 사용)을 &quot;std time&quot;(1 월 1 일 1 일 자정을 UTC로 사용하고 hnsecs를 단위로)으로 변환합니다.</target>
        </trans-unit>
        <trans-unit id="2ff42625e816f32f0e903105abab719aab3bc247" translate="yes" xml:space="preserve">
          <source>Converts std time (which uses midnight, January 1st, 1 A.D. UTC as its epoch and hnsecs as its units) to unix time (which uses midnight, January 1st, 1970 UTC as its epoch and seconds as its units).</source>
          <target state="translated">std 시간 (1 월 1 일 자정 1 AD UTC를 에포크로 사용하고 hnsecs를 단위로 사용)을 유닉스 시간 (1970 년 1 월 1 일 자정 UTC를 에포크로 사용하고 초를 단위로 사용)으로 변환합니다.</target>
        </trans-unit>
        <trans-unit id="02026be234370e8ba0fa5a12a01ca8dc15195021" translate="yes" xml:space="preserve">
          <source>Converts the UTF-8 string s into a null-terminated string in a Windows 8-bit character set.</source>
          <target state="translated">UTF-8 문자열을 Windows 8 비트 문자 세트의 널 종료 문자열로 변환합니다.</target>
        </trans-unit>
        <trans-unit id="68545d42d5434868c8492fc2ad3250e2f1494c37" translate="yes" xml:space="preserve">
          <source>Converts the complex number to a string representation.</source>
          <target state="translated">복소수를 문자열 표현으로 변환합니다.</target>
        </trans-unit>
        <trans-unit id="d4417d8f06d1b116703d3dde566fa560d538d75d" translate="yes" xml:space="preserve">
          <source>Converts the given time from one clock frequency/resolution to another.</source>
          <target state="translated">주어진 시간을 한 클럭 주파수 / 해상도에서 다른 클럭 주파수로 변환합니다.</target>
        </trans-unit>
        <trans-unit id="1a6e949bbca6ba048ef59d86f6355918bc8f8588" translate="yes" xml:space="preserve">
          <source>Converts the given value from big endian to the native endianness and returns it. The value is given as a &lt;code&gt;ubyte[n]&lt;/code&gt; where &lt;code&gt;n&lt;/code&gt; is the size of the target type. You must give the target type as a template argument, because there are multiple types with the same size and so the type of the argument is not enough to determine the return type.</source>
          <target state="translated">주어진 값을 빅 엔디안에서 네이티브 엔디안으로 변환하여 반환합니다. 값은 &lt;code&gt;ubyte[n]&lt;/code&gt; 으로 제공되며, 여기서 &lt;code&gt;n&lt;/code&gt; 은 대상 유형의 크기입니다. 크기가 동일한 여러 유형이 있으므로 인수 유형이 리턴 유형을 판별하기에 충분하지 않으므로 대상 유형을 템플리트 인수로 제공해야합니다.</target>
        </trans-unit>
        <trans-unit id="99754092cef6ee8c6b8a8736f7dda136a6df1796" translate="yes" xml:space="preserve">
          <source>Converts the given value from little endian to the native endianness and returns it. The value is given as a &lt;code&gt;ubyte[n]&lt;/code&gt; where &lt;code&gt;n&lt;/code&gt; is the size of the target type. You must give the target type as a template argument, because there are multiple types with the same size and so the type of the argument is not enough to determine the return type.</source>
          <target state="translated">주어진 값을 리틀 엔디안에서 네이티브 엔디안으로 변환하여 반환합니다. 값은 &lt;code&gt;ubyte[n]&lt;/code&gt; 으로 제공됩니다 . 여기서 &lt;code&gt;n&lt;/code&gt; 은 대상 유형의 크기입니다. 크기가 동일한 여러 유형이 있으므로 인수 유형이 리턴 유형을 판별하기에 충분하지 않으므로 대상 유형을 템플리트 인수로 제공해야합니다.</target>
        </trans-unit>
        <trans-unit id="7026ec6ca618852b8dbaface42f39c87c3912a93" translate="yes" xml:space="preserve">
          <source>Converts the given value from the native endianness to big endian and returns it as a &lt;code&gt;ubyte[n]&lt;/code&gt; where &lt;code&gt;n&lt;/code&gt; is the size of the given type.</source>
          <target state="translated">주어진 값을 원시 엔디안에서 빅 엔디안으로 변환하고 &lt;code&gt;ubyte[n]&lt;/code&gt; 으로 반환합니다 . 여기서 &lt;code&gt;n&lt;/code&gt; 은 주어진 유형의 크기입니다.</target>
        </trans-unit>
        <trans-unit id="db7766a0ee6d7c4c104a32edc118f2a266f57364" translate="yes" xml:space="preserve">
          <source>Converts the given value from the native endianness to little endian and returns it as a &lt;code&gt;ubyte[n]&lt;/code&gt; where &lt;code&gt;n&lt;/code&gt; is the size of the given type.</source>
          <target state="translated">주어진 값을 원시 엔디안에서 리틀 엔디안으로 변환하고 &lt;code&gt;ubyte[n]&lt;/code&gt; 으로 반환합니다 . 여기서 &lt;code&gt;n&lt;/code&gt; 은 주어진 유형의 크기입니다.</target>
        </trans-unit>
        <trans-unit id="71032212236b6edba85329a7e36a9ebec7e90c73" translate="yes" xml:space="preserve">
          <source>Converts the null-terminated string s from a Windows 8-bit character set into a UTF-8 char array.</source>
          <target state="translated">널 종료 문자열을 Windows 8 비트 문자 세트에서 UTF-8 문자 배열로 변환합니다.</target>
        </trans-unit>
        <trans-unit id="453bede937d557afda6a1aea6ab1d8f1c5734489" translate="yes" xml:space="preserve">
          <source>Converts the store &lt;code&gt;s&lt;/code&gt; into a heap. If &lt;code&gt;initialSize&lt;/code&gt; is specified, only the first &lt;code&gt;initialSize&lt;/code&gt; elements in &lt;code&gt;s&lt;/code&gt; are transformed into a heap, after which the heap can grow up to &lt;code&gt;r.length&lt;/code&gt; (if &lt;code&gt;Store&lt;/code&gt; is a range) or indefinitely (if &lt;code&gt;Store&lt;/code&gt; is a container with &lt;code&gt;insertBack&lt;/code&gt;). Performs &amp;Omicron;(&lt;code&gt;min(r.length, initialSize)&lt;/code&gt;) evaluations of &lt;code&gt;less&lt;/code&gt;.</source>
          <target state="translated">가게 변환 &lt;code&gt;s&lt;/code&gt; 힙에. 경우 &lt;code&gt;initialSize&lt;/code&gt; 가이 지정된 경우에만 제 &lt;code&gt;initialSize&lt;/code&gt; 가 된 요소 &lt;code&gt;s&lt;/code&gt; 힙가 자랄 수있는 후 힙로 변환된다 &lt;code&gt;r.length&lt;/code&gt; (경우 &lt;code&gt;Store&lt;/code&gt; (무기한의 범위이다) 또는 &lt;code&gt;Store&lt;/code&gt; 와 컨테이너 &lt;code&gt;insertBack&lt;/code&gt; ). &amp;Omicron; 행한다 ( &lt;code&gt;min(r.length, initialSize)&lt;/code&gt; )의 평가를 &lt;code&gt;less&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2f93578046a37a61d755a351d7403ee07d2feb19" translate="yes" xml:space="preserve">
          <source>Converts this &lt;a href=&quot;#Date&quot;&gt;&lt;code&gt;Date&lt;/code&gt;&lt;/a&gt; to a string with the format &lt;code&gt;YYYY-MM-DD&lt;/code&gt;. If &lt;code&gt;writer&lt;/code&gt; is set, the resulting string will be written directly to it.</source>
          <target state="translated">이 &lt;a href=&quot;#Date&quot;&gt; &lt;code&gt;Date&lt;/code&gt; &lt;/a&gt; 를 &lt;code&gt;YYYY-MM-DD&lt;/code&gt; 형식의 문자열로 변환합니다 . 경우 &lt;code&gt;writer&lt;/code&gt; 설정되어, 결과 문자열을 직접 기록됩니다.</target>
        </trans-unit>
        <trans-unit id="6603b566288f85150171c62cd84c2febe4e416d1" translate="yes" xml:space="preserve">
          <source>Converts this &lt;a href=&quot;#Date&quot;&gt;&lt;code&gt;Date&lt;/code&gt;&lt;/a&gt; to a string with the format &lt;code&gt;YYYY-Mon-DD&lt;/code&gt;. If &lt;code&gt;writer&lt;/code&gt; is set, the resulting string will be written directly to it.</source>
          <target state="translated">이 &lt;a href=&quot;#Date&quot;&gt; &lt;code&gt;Date&lt;/code&gt; &lt;/a&gt; 를 &lt;code&gt;YYYY-Mon-DD&lt;/code&gt; 형식의 문자열로 변환합니다 . 경우 &lt;code&gt;writer&lt;/code&gt; 설정되어, 결과 문자열을 직접 기록됩니다.</target>
        </trans-unit>
        <trans-unit id="bbed58be0aee4969a87b68c3fa4d895942507f6c" translate="yes" xml:space="preserve">
          <source>Converts this &lt;a href=&quot;#Date&quot;&gt;&lt;code&gt;Date&lt;/code&gt;&lt;/a&gt; to a string with the format &lt;code&gt;YYYYMMDD&lt;/code&gt;. If &lt;code&gt;writer&lt;/code&gt; is set, the resulting string will be written directly to it.</source>
          <target state="translated">이 &lt;a href=&quot;#Date&quot;&gt; &lt;code&gt;Date&lt;/code&gt; &lt;/a&gt; 를 &lt;code&gt;YYYYMMDD&lt;/code&gt; 형식의 문자열로 변환합니다 . 경우 &lt;code&gt;writer&lt;/code&gt; 설정되어, 결과 문자열을 직접 기록됩니다.</target>
        </trans-unit>
        <trans-unit id="6a1ebbb6b69924d680654dfe931f3d107306042b" translate="yes" xml:space="preserve">
          <source>Converts this &lt;a href=&quot;#Date&quot;&gt;&lt;code&gt;Date&lt;/code&gt;&lt;/a&gt; to a string.</source>
          <target state="translated">이 &lt;a href=&quot;#Date&quot;&gt; &lt;code&gt;Date&lt;/code&gt; &lt;/a&gt; 를 문자열로 변환 합니다.</target>
        </trans-unit>
        <trans-unit id="2cdf3feb7790120701384059bf58b361680f227a" translate="yes" xml:space="preserve">
          <source>Converts this &lt;a href=&quot;#DateTime&quot;&gt;&lt;code&gt;DateTime&lt;/code&gt;&lt;/a&gt; to a string with the format &lt;code&gt;YYYY-MM-DDTHH:MM:SS&lt;/code&gt;. If &lt;code&gt;writer&lt;/code&gt; is set, the resulting string will be written directly to it.</source>
          <target state="translated">이 &lt;a href=&quot;#DateTime&quot;&gt; &lt;code&gt;DateTime&lt;/code&gt; &lt;/a&gt; 을 &lt;code&gt;YYYY-MM-DDTHH:MM:SS&lt;/code&gt; 형식의 문자열로 변환합니다 . 경우 &lt;code&gt;writer&lt;/code&gt; 설정되어, 결과 문자열을 직접 기록됩니다.</target>
        </trans-unit>
        <trans-unit id="b4b6f600d98add32575a23efab5b281c9146f97b" translate="yes" xml:space="preserve">
          <source>Converts this &lt;a href=&quot;#DateTime&quot;&gt;&lt;code&gt;DateTime&lt;/code&gt;&lt;/a&gt; to a string with the format &lt;code&gt;YYYY-Mon-DD HH:MM:SS&lt;/code&gt;. If &lt;code&gt;writer&lt;/code&gt; is set, the resulting string will be written directly to it.</source>
          <target state="translated">이 &lt;a href=&quot;#DateTime&quot;&gt; &lt;code&gt;DateTime&lt;/code&gt; &lt;/a&gt; 을 &lt;code&gt;YYYY-Mon-DD HH:MM:SS&lt;/code&gt; 형식의 문자열로 변환합니다 . 경우 &lt;code&gt;writer&lt;/code&gt; 설정되어, 결과 문자열을 직접 기록됩니다.</target>
        </trans-unit>
        <trans-unit id="f02a2e92abc14cc294c7e38e57188968b21a1abb" translate="yes" xml:space="preserve">
          <source>Converts this &lt;a href=&quot;#DateTime&quot;&gt;&lt;code&gt;DateTime&lt;/code&gt;&lt;/a&gt; to a string with the format &lt;code&gt;YYYYMMDDTHHMMSS&lt;/code&gt;. If &lt;code&gt;writer&lt;/code&gt; is set, the resulting string will be written directly to it.</source>
          <target state="translated">이 &lt;a href=&quot;#DateTime&quot;&gt; &lt;code&gt;DateTime&lt;/code&gt; &lt;/a&gt; 을 &lt;code&gt;YYYYMMDDTHHMMSS&lt;/code&gt; 형식의 문자열로 변환합니다 . 경우 &lt;code&gt;writer&lt;/code&gt; 설정되어, 결과 문자열을 직접 기록됩니다.</target>
        </trans-unit>
        <trans-unit id="db51859446cb3a5e9180034baebbd2056ca398e0" translate="yes" xml:space="preserve">
          <source>Converts this &lt;a href=&quot;#DateTime&quot;&gt;&lt;code&gt;DateTime&lt;/code&gt;&lt;/a&gt; to a string.</source>
          <target state="translated">이 &lt;a href=&quot;#DateTime&quot;&gt; &lt;code&gt;DateTime&lt;/code&gt; &lt;/a&gt; 을 문자열로 변환 합니다.</target>
        </trans-unit>
        <trans-unit id="2476ac04da69ffdc944a61493a1b71959fe371eb" translate="yes" xml:space="preserve">
          <source>Converts this &lt;a href=&quot;#SysTime&quot;&gt;&lt;code&gt;SysTime&lt;/code&gt;&lt;/a&gt; to a string with the format YYYY-MM-DDTHH:MM:SS.FFFFFFFTZ (where F is fractional seconds and TZ is the time zone).</source>
          <target state="translated">이 &lt;a href=&quot;#SysTime&quot;&gt; &lt;code&gt;SysTime&lt;/code&gt; &lt;/a&gt; 을 YYYY-MM-DDTHH : MM : SS.FFFFFFFTZ 형식의 문자열로 변환합니다 (여기서 F는 소수 초이고 TZ는 시간대입니다).</target>
        </trans-unit>
        <trans-unit id="6fd506aa039e90544044bf8ca9bc422fc2f26564" translate="yes" xml:space="preserve">
          <source>Converts this &lt;a href=&quot;#SysTime&quot;&gt;&lt;code&gt;SysTime&lt;/code&gt;&lt;/a&gt; to a string with the format YYYY-Mon-DD HH:MM:SS.FFFFFFFTZ (where F is fractional seconds and TZ is the time zone).</source>
          <target state="translated">이 &lt;a href=&quot;#SysTime&quot;&gt; &lt;code&gt;SysTime&lt;/code&gt; &lt;/a&gt; 을 YYYY-Mon-DD HH : MM : SS.FFFFFFFTZ 형식의 문자열로 변환합니다 (여기서 F는 소수 초이고 TZ는 시간대입니다).</target>
        </trans-unit>
        <trans-unit id="d39abfdab21a7e5012c4e5c22865dc3c6b9b9a8f" translate="yes" xml:space="preserve">
          <source>Converts this &lt;a href=&quot;#SysTime&quot;&gt;&lt;code&gt;SysTime&lt;/code&gt;&lt;/a&gt; to a string with the format YYYYMMDDTHHMMSS.FFFFFFFTZ (where F is fractional seconds and TZ is time zone).</source>
          <target state="translated">이 &lt;a href=&quot;#SysTime&quot;&gt; &lt;code&gt;SysTime&lt;/code&gt; &lt;/a&gt; 을 YYYYMMDDTHHMMSS.FFFFFFFTZ 형식의 문자열로 변환합니다 (여기서 F는 소수 초이고 TZ는 시간대입니다).</target>
        </trans-unit>
        <trans-unit id="288ffc29180217ab372bbf85f774ec19f9c71bdb" translate="yes" xml:space="preserve">
          <source>Converts this &lt;a href=&quot;#SysTime&quot;&gt;&lt;code&gt;SysTime&lt;/code&gt;&lt;/a&gt; to a string.</source>
          <target state="translated">이 &lt;a href=&quot;#SysTime&quot;&gt; &lt;code&gt;SysTime&lt;/code&gt; &lt;/a&gt; 을 문자열로 변환 합니다.</target>
        </trans-unit>
        <trans-unit id="b5ead06637aa29f4e0f3f6e8350a6b3d0470262f" translate="yes" xml:space="preserve">
          <source>Converts this &lt;a href=&quot;#SysTime&quot;&gt;&lt;code&gt;SysTime&lt;/code&gt;&lt;/a&gt; to unix time (i.e. seconds from midnight, January 1st, 1970 in UTC).</source>
          <target state="translated">이 &lt;a href=&quot;#SysTime&quot;&gt; &lt;code&gt;SysTime&lt;/code&gt; &lt;/a&gt; 을 유닉스 시간으로 변환합니다 (즉, 1970 년 1 월 1 일 자정에서 UTC로 초).</target>
        </trans-unit>
        <trans-unit id="11c0c6c4e0883ccde835c4d2ba2f873e1dc0fe81" translate="yes" xml:space="preserve">
          <source>Converts this &lt;a href=&quot;#TimeOfDay&quot;&gt;&lt;code&gt;TimeOfDay&lt;/code&gt;&lt;/a&gt; to a string with the format &lt;code&gt;HH:MM:SS&lt;/code&gt;. If &lt;code&gt;writer&lt;/code&gt; is set, the resulting string will be written directly to it.</source>
          <target state="translated">이 &lt;a href=&quot;#TimeOfDay&quot;&gt; &lt;code&gt;TimeOfDay&lt;/code&gt; &lt;/a&gt; 를 &lt;code&gt;HH:MM:SS&lt;/code&gt; 형식의 문자열로 변환합니다 . 경우 &lt;code&gt;writer&lt;/code&gt; 설정되어, 결과 문자열을 직접 기록됩니다.</target>
        </trans-unit>
        <trans-unit id="289897447b39fc44b7870f5a328e8892eb4029c1" translate="yes" xml:space="preserve">
          <source>Converts this &lt;a href=&quot;#TimeOfDay&quot;&gt;&lt;code&gt;TimeOfDay&lt;/code&gt;&lt;/a&gt; to a string with the format &lt;code&gt;HHMMSS&lt;/code&gt;. If &lt;code&gt;writer&lt;/code&gt; is set, the resulting string will be written directly to it.</source>
          <target state="translated">이 &lt;a href=&quot;#TimeOfDay&quot;&gt; &lt;code&gt;TimeOfDay&lt;/code&gt; &lt;/a&gt; 를 &lt;code&gt;HHMMSS&lt;/code&gt; 형식의 문자열로 변환합니다 . 경우 &lt;code&gt;writer&lt;/code&gt; 설정되어, 결과 문자열을 직접 기록됩니다.</target>
        </trans-unit>
        <trans-unit id="8233cbfc0d952b5bfeda989512aed9518e2812db" translate="yes" xml:space="preserve">
          <source>Converts this &lt;code&gt;Duration&lt;/code&gt; to a &lt;code&gt;string&lt;/code&gt;.</source>
          <target state="translated">이 &lt;code&gt;Duration&lt;/code&gt; 를 &lt;code&gt;string&lt;/code&gt; 변환 합니다 .</target>
        </trans-unit>
        <trans-unit id="c6e0e45d39cee812b4f40d98644bee8bb2dbdb9d" translate="yes" xml:space="preserve">
          <source>Converts this TimeOfDay to a string.</source>
          <target state="translated">이 TimeOfDay를 문자열로 변환합니다.</target>
        </trans-unit>
        <trans-unit id="2d70de6e4f1b10ef5bbf7032a91df90630348700" translate="yes" xml:space="preserve">
          <source>Converts this interval to a string.</source>
          <target state="translated">이 간격을 문자열로 변환합니다.</target>
        </trans-unit>
        <trans-unit id="da35025d96842d394967858a7a95f5b87cb34797" translate="yes" xml:space="preserve">
          <source>Converts to string.</source>
          <target state="translated">문자열로 변환합니다.</target>
        </trans-unit>
        <trans-unit id="cf38165162fb8000f4b46022cfe90ad022d53d08" translate="yes" xml:space="preserve">
          <source>Copies a range to another. If &lt;code&gt;a = [1, 2, 3]&lt;/code&gt; and &lt;code&gt;b = new int[5]&lt;/code&gt;, then &lt;code&gt;copy(a, b)&lt;/code&gt; leaves &lt;code&gt;b = [1, 2, 3, 0, 0]&lt;/code&gt; and returns &lt;code&gt;b[3 .. $]&lt;/code&gt;.</source>
          <target state="translated">범위를 다른 범위로 복사합니다. 하면 &lt;code&gt;a = [1, 2, 3]&lt;/code&gt; 및 &lt;code&gt;b = new int[5]&lt;/code&gt; 다음 &lt;code&gt;copy(a, b)&lt;/code&gt; 잎 &lt;code&gt;b = [1, 2, 3, 0, 0]&lt;/code&gt; 되돌아 &lt;code&gt;b[3 .. $]&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="14bbc85755baa25d4951be7218064216daa78c34" translate="yes" xml:space="preserve">
          <source>Copies all environment variables into an associative array.</source>
          <target state="translated">모든 환경 변수를 연관 배열로 복사합니다.</target>
        </trans-unit>
        <trans-unit id="3484c1ab3cd6af03dbf05b6c0cb7f8dbede1bc3e" translate="yes" xml:space="preserve">
          <source>Copies out the top elements of a range.</source>
          <target state="translated">범위의 최상위 요소를 복사합니다.</target>
        </trans-unit>
        <trans-unit id="3760826c7bb74f35fbcd18d73458a48731a1bc5b" translate="yes" xml:space="preserve">
          <source>Copies out the values that occur most frequently (multiplied by per-value weights) in a range of ranges.</source>
          <target state="translated">범위 범위에서 가장 자주 발생하는 값 (값당 가중치를 곱한 값)을 복사합니다.</target>
        </trans-unit>
        <trans-unit id="7bdd3f12e99e3b707353754ea1c09e13976482b7" translate="yes" xml:space="preserve">
          <source>Copies out the values that occur most frequently in a range of ranges.</source>
          <target state="translated">다양한 범위에서 가장 자주 발생하는 값을 복사합니다.</target>
        </trans-unit>
        <trans-unit id="cc55bda0ef1918898bb2580421cef4d1e592ad70" translate="yes" xml:space="preserve">
          <source>Copies the content of &lt;code&gt;source&lt;/code&gt; into &lt;code&gt;target&lt;/code&gt; and returns the remaining (unfilled) part of &lt;code&gt;target&lt;/code&gt;.</source>
          <target state="translated">복사본의 컨텐츠 &lt;code&gt;source&lt;/code&gt; 에 &lt;code&gt;target&lt;/code&gt; 및 나머지 (잔여) 부분 반환 &lt;code&gt;target&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="78798d20653e71e4060adbb2cf9963f5c8d2dbc1" translate="yes" xml:space="preserve">
          <source>Copies the top &lt;code&gt;n&lt;/code&gt; elements of the &lt;a href=&quot;std_range_primitives#isInputRange&quot;&gt;input range&lt;/a&gt;&lt;code&gt;source&lt;/code&gt; into the random-access range &lt;code&gt;target&lt;/code&gt;, where &lt;code&gt;n = target.length&lt;/code&gt;. Elements of &lt;code&gt;source&lt;/code&gt; are not touched. If &lt;code&gt;sorted&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;, the target is sorted. Otherwise, the target respects the &lt;a href=&quot;http://en.wikipedia.org/wiki/Binary_heap&quot;&gt;heap property&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;std_range_primitives#isInputRange&quot;&gt;입력 범위 &lt;/a&gt; &lt;code&gt;source&lt;/code&gt; 의 상위 &lt;code&gt;n&lt;/code&gt; 개 요소를 랜덤 액세스 범위 &lt;code&gt;target&lt;/code&gt; 에 복사합니다 ( 여기서 &lt;code&gt;n = target.length&lt;/code&gt; . &lt;code&gt;source&lt;/code&gt; 요소는 건드리지 않습니다. 경우 &lt;code&gt;sorted&lt;/code&gt; 있다 &lt;code&gt;true&lt;/code&gt; , 대상이 정렬됩니다. 그렇지 않으면 대상은 &lt;a href=&quot;http://en.wikipedia.org/wiki/Binary_heap&quot;&gt;힙 특성을&lt;/a&gt; 존중합니다 .</target>
        </trans-unit>
        <trans-unit id="c860f91e1096880f98894442e0fd5b51861a8938" translate="yes" xml:space="preserve">
          <source>Copies type qualifiers from &lt;code&gt;FromType&lt;/code&gt; to &lt;code&gt;ToType&lt;/code&gt;.</source>
          <target state="translated">사본에서 예선 입력 &lt;code&gt;FromType&lt;/code&gt; 을 에 &lt;code&gt;ToType&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f831e18f3d39d06a4db85c2a93c55cd8de3583f9" translate="yes" xml:space="preserve">
          <source>Coptic</source>
          <target state="translated">Coptic</target>
        </trans-unit>
        <trans-unit id="709184dfbdae79b767c073438461d5232cfaf826" translate="yes" xml:space="preserve">
          <source>Copy a list and return it.</source>
          <target state="translated">리스트를 복사하여 리턴하십시오.</target>
        </trans-unit>
        <trans-unit id="cd1c2a586ccbd243219ac10eddf70c09e31d365c" translate="yes" xml:space="preserve">
          <source>Copy construction</source>
          <target state="translated">복사 공사</target>
        </trans-unit>
        <trans-unit id="37418ac4b9973316ffcd94559dc007884df26d17" translate="yes" xml:space="preserve">
          <source>Copy constructors are used to initialize a &lt;code&gt;struct&lt;/code&gt; instance from another &lt;code&gt;struct&lt;/code&gt; of the same type.</source>
          <target state="translated">Copy 생성자는 같은 유형의 다른 &lt;code&gt;struct&lt;/code&gt; 에서 &lt;code&gt;struct&lt;/code&gt; 인스턴스 를 초기화하는 데 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="320779b333b853c0722a1290050d477167e8a078" translate="yes" xml:space="preserve">
          <source>Copy file &lt;code&gt;from&lt;/code&gt; to file &lt;code&gt;to&lt;/code&gt;. File timestamps are preserved. File attributes are preserved, if &lt;code&gt;preserve&lt;/code&gt; equals &lt;code&gt;Yes.preserveAttributes&lt;/code&gt;. On Windows only &lt;code&gt;Yes.preserveAttributes&lt;/code&gt; (the default on Windows) is supported. If the target file exists, it is overwritten.</source>
          <target state="translated">파일을 복사 &lt;code&gt;from&lt;/code&gt; 파일 &lt;code&gt;to&lt;/code&gt; . 파일 타임 스탬프가 유지됩니다. 경우 파일 속성은 보존 &lt;code&gt;preserve&lt;/code&gt; 등호의 &lt;code&gt;Yes.preserveAttributes&lt;/code&gt; 을 . Windows에서만 &lt;code&gt;Yes.preserveAttributes&lt;/code&gt; ( Windows 의 기본값)가 지원됩니다. 대상 파일이 있으면 덮어 씁니다.</target>
        </trans-unit>
        <trans-unit id="6adfec0ea49b245d49516253d1dd309df3c674d0" translate="yes" xml:space="preserve">
          <source>Copy list of pointers into an array of pointers.</source>
          <target state="translated">포인터 목록을 포인터 배열로 복사하십시오.</target>
        </trans-unit>
        <trans-unit id="308a306712a72a68760a831c427ff9a7b6f477e8" translate="yes" xml:space="preserve">
          <source>Copy of pContext passed to s_r_g_c()</source>
          <target state="translated">s_r_g_c ()에 전달 된 pContext의 사본</target>
        </trans-unit>
        <trans-unit id="a8fcd23e55300e52517fa8bcab8fa048a94546e8" translate="yes" xml:space="preserve">
          <source>Copy the AST for Initializer.</source>
          <target state="translated">이니셜 라이저의 AST를 복사하십시오.</target>
        </trans-unit>
        <trans-unit id="a9b2e4441cb240ca98a4ab28279101e86791c233" translate="yes" xml:space="preserve">
          <source>Copy the content of &lt;code&gt;src&lt;/code&gt; into a C-string ('\0' terminated) then call &lt;code&gt;dg&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;src&lt;/code&gt; 의 내용을 C- 문자열 ( '\ 0'종결 됨)에 복사 한 다음 &lt;code&gt;dg&lt;/code&gt; 를 호출하십시오.</target>
        </trans-unit>
        <trans-unit id="b95b3aef1bd39e43db4216e5417954c43df1366d" translate="yes" xml:space="preserve">
          <source>Copy the syntax. Used for template instantiations. If s is NULL, allocate the new object, otherwise fill it in.</source>
          <target state="translated">구문을 복사하십시오. 템플릿 인스턴스화에 사용됩니다. s가 NULL이면 새 객체를 할당하고 그렇지 않으면 채 웁니다.</target>
        </trans-unit>
        <trans-unit id="8ec1721ef2b902c8de7cb0d0aa34612ec83401fd" translate="yes" xml:space="preserve">
          <source>Copying of this struct is disabled, since it would provide no useful semantics. If you want to pass this struct around, you should do so by reference or pointer.</source>
          <target state="translated">이 구조체의 복사는 유용한 의미를 제공하지 않으므로 비활성화됩니다. 이 구조체를 전달하려면 참조 또는 포인터로 전달해야합니다.</target>
        </trans-unit>
        <trans-unit id="b9e302476e5802312f92d2000e1d7eb281d3f5c6" translate="yes" xml:space="preserve">
          <source>Copying one &lt;code&gt;File&lt;/code&gt; object to another results in the two &lt;code&gt;File&lt;/code&gt; objects referring to the same underlying file.</source>
          <target state="translated">한 &lt;code&gt;File&lt;/code&gt; 객체를 다른 File 객체로 복사 하면 두 개의 &lt;code&gt;File&lt;/code&gt; 객체가 동일한 기본 파일을 참조하게됩니다.</target>
        </trans-unit>
        <trans-unit id="e9a652bd968ffd57a4235b12a1e05a73da8e344b" translate="yes" xml:space="preserve">
          <source>Copying range &lt;code&gt;E&lt;/code&gt; into &lt;code&gt;R&lt;/code&gt;.</source>
          <target state="translated">범위 &lt;code&gt;E&lt;/code&gt; 를 &lt;code&gt;R&lt;/code&gt; 에 복사합니다 .</target>
        </trans-unit>
        <trans-unit id="9c490d0555e01fccc566b2049a123406254aec4e" translate="yes" xml:space="preserve">
          <source>Copyright (C) 1998 - 2010, Daniel Stenberg, &amp;lt;daniel@haxx.se&amp;gt;, et al.</source>
          <target state="translated">Copyright (C) 1998-2010, Daniel Stenberg, &amp;lt;daniel@haxx.se&amp;gt;, et al.</target>
        </trans-unit>
        <trans-unit id="d7fd2f0b0b062e7925bd7e80f9edff1469e8c0cd" translate="yes" xml:space="preserve">
          <source>Copyright (C) 2018-2019 by The D Language Foundation, All Rights Reserved</source>
          <target state="translated">Copyright (C) 2018-2019 D 언어 재단, 판권 소유</target>
        </trans-unit>
        <trans-unit id="791e6eab1ad061b18a1d6efc93a77ad535bf0203" translate="yes" xml:space="preserve">
          <source>Copyright Digital Mars 2007 - 2010.</source>
          <target state="translated">Copyright Digital Mars 2007-2010.</target>
        </trans-unit>
        <trans-unit id="4671543319eb1a3e40086a095380b9f58bb42d23" translate="yes" xml:space="preserve">
          <source>Copyright:</source>
          <target state="translated">Copyright:</target>
        </trans-unit>
        <trans-unit id="c1c6068dcf095f0b88f5e50f1dfe0135b6190c47" translate="yes" xml:space="preserve">
          <source>Core allocator objects that interface with D's garbage collected heap (&lt;a href=&quot;std_experimental_allocator_gc_allocator&quot;&gt;&lt;code&gt;std.experimental.allocator.gc_allocator&lt;/code&gt;&lt;/a&gt;), the C &lt;code&gt;malloc&lt;/code&gt; family (&lt;a href=&quot;std_experimental_allocator_mallocator&quot;&gt;&lt;code&gt;std.experimental.allocator.mallocator&lt;/code&gt;&lt;/a&gt;), and the OS (&lt;a href=&quot;std_experimental_allocator_mmap_allocator&quot;&gt;&lt;code&gt;std.experimental.allocator.mmap_allocator&lt;/code&gt;&lt;/a&gt;). Most custom allocators would ultimately obtain memory from one of these core allocators.</source>
          <target state="translated">D의 가비지 수집 힙 ( &lt;a href=&quot;std_experimental_allocator_gc_allocator&quot;&gt; &lt;code&gt;std.experimental.allocator.gc_allocator&lt;/code&gt; &lt;/a&gt; ), C &lt;code&gt;malloc&lt;/code&gt; 패밀리 ( &lt;a href=&quot;std_experimental_allocator_mallocator&quot;&gt; &lt;code&gt;std.experimental.allocator.mallocator&lt;/code&gt; &lt;/a&gt; ) 및 OS ( &lt;a href=&quot;std_experimental_allocator_mmap_allocator&quot;&gt; &lt;code&gt;std.experimental.allocator.mmap_allocator&lt;/code&gt; &lt;/a&gt; ) 와 인터페이스하는 코어 할당 자 오브젝트 대부분의 커스텀 할당자는 궁극적으로 이러한 핵심 할당 자 중 하나로부터 메모리를 얻습니다.</target>
        </trans-unit>
        <trans-unit id="7b820d5ee9cbef08cc0675cf59c9e9666eb11879" translate="yes" xml:space="preserve">
          <source>Core language definitions. Automatically imported.</source>
          <target state="translated">핵심 언어 정의. 자동으로 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="76cb799cd1522d52368e0a75ed33732541a23b3a" translate="yes" xml:space="preserve">
          <source>Could not find an MX record for this domain but an A-record does exist</source>
          <target state="translated">이 도메인에 대한 MX 레코드를 찾을 수 없지만 A 레코드가 존재합니다</target>
        </trans-unit>
        <trans-unit id="08c19a8f1d0d59ad9d116a7f6a492aba8099b5e8" translate="yes" xml:space="preserve">
          <source>Could not find an MX record or an A-record for this domain</source>
          <target state="translated">이 도메인에 대한 MX 레코드 또는 A 레코드를 찾을 수 없습니다</target>
        </trans-unit>
        <trans-unit id="0939fecded0f0c9d546d71641c3908e28d8f44d4" translate="yes" xml:space="preserve">
          <source>Count The Number Of Rows Modified</source>
          <target state="translated">수정 된 행 수 계산</target>
        </trans-unit>
        <trans-unit id="8d5ade84a80435c2bfa6f6177104e09a64281c70" translate="yes" xml:space="preserve">
          <source>Count all the possible substrings of length 2</source>
          <target state="translated">길이 2의 가능한 모든 부분 문자열을 세십시오</target>
        </trans-unit>
        <trans-unit id="8be0facbf0a137c1553dcd917b58aac8fddcb84c" translate="yes" xml:space="preserve">
          <source>Count up and return number of items in list.</source>
          <target state="translated">목록에있는 항목 수를 세고 반환합니다.</target>
        </trans-unit>
        <trans-unit id="e564d45aaad122a5874f0bff4352287fa9c20217" translate="yes" xml:space="preserve">
          <source>Counting Rod Numerals</source>
          <target state="translated">카운팅로드 숫자</target>
        </trans-unit>
        <trans-unit id="173f9b130d44a68c96e425930a40f7564c0cd832" translate="yes" xml:space="preserve">
          <source>Counts all the set bits in the &lt;code&gt;BitArray&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;BitArray&lt;/code&gt; 의 모든 설정 비트 수</target>
        </trans-unit>
        <trans-unit id="7ce36e691e55ca1534110cdf92701208325abb85" translate="yes" xml:space="preserve">
          <source>Counts elements in the given &lt;a href=&quot;std_range_primitives#isForwardRange&quot;&gt;forward range&lt;/a&gt; until the given predicate is true for one of the given &lt;code&gt;needles&lt;/code&gt;.</source>
          <target state="translated">주어진 &lt;code&gt;needles&lt;/code&gt; 중 하나에 대해 주어진 술어가 true가 될 때까지 주어진 &lt;a href=&quot;std_range_primitives#isForwardRange&quot;&gt;앞으로 범위의&lt;/a&gt; 요소를 계산합니다 .</target>
        </trans-unit>
        <trans-unit id="036b8b1123e79381082e175aa22db7cf31f3e5e1" translate="yes" xml:space="preserve">
          <source>Counts elements that are equal to a specified value or satisfy a predicate. &lt;code&gt;count([1, 2, 1], 1)&lt;/code&gt; returns &lt;code&gt;2&lt;/code&gt; and &lt;code&gt;count!&quot;a &amp;lt; 0&quot;([1, -3, 0])&lt;/code&gt; returns &lt;code&gt;1&lt;/code&gt;.</source>
          <target state="translated">지정된 값과 같거나 술어를 만족시키는 요소를 계산합니다. &lt;code&gt;count([1, 2, 1], 1)&lt;/code&gt; 은 &lt;code&gt;2&lt;/code&gt; 를 반환 하고 &lt;code&gt;count!&quot;a &amp;lt; 0&quot;([1, -3, 0])&lt;/code&gt; 은 &lt;code&gt;1&lt;/code&gt; 을 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="ccf0dfb24dfd16253b0f3c9addacb80ba1861801" translate="yes" xml:space="preserve">
          <source>Counts the number of calls to &lt;code&gt;alignedAllocate&lt;/code&gt; that succeeded, i.e. they returned a block as large as requested. (N.B. requests for zero bytes count as successful.)</source>
          <target state="translated">성공한 &lt;code&gt;alignedAllocate&lt;/code&gt; 대한 호출 수를 계산합니다 . 즉, 요청한만큼 큰 블록을 반환합니다. 0 바이트에 대한 NB 요청은 성공한 것으로 간주됩니다.</target>
        </trans-unit>
        <trans-unit id="89e430aecb0bc14a42573f4e6f98203eeb3b69aa" translate="yes" xml:space="preserve">
          <source>Counts the number of calls to &lt;code&gt;alignedAllocate&lt;/code&gt;. All calls are counted, including requests for zero bytes or failed requests.</source>
          <target state="translated">&lt;code&gt;alignedAllocate&lt;/code&gt; 대한 호출 수를 계산합니다 . 0 바이트 요청 또는 실패한 요청을 포함한 모든 호출이 계산됩니다.</target>
        </trans-unit>
        <trans-unit id="33412aaca6b7b7660ddf82c644a97ea07b39f016" translate="yes" xml:space="preserve">
          <source>Counts the number of calls to &lt;code&gt;allocate&lt;/code&gt; that succeeded, i.e. they returned a block as large as requested. (N.B. requests for zero bytes count as successful.)</source>
          <target state="translated">성공한 &lt;code&gt;allocate&lt;/code&gt; 즉, 요청한만큼 큰 블록을 반환 한 호출 수를 계산합니다 . 0 바이트에 대한 NB 요청은 성공한 것으로 간주됩니다.</target>
        </trans-unit>
        <trans-unit id="b35cbf7d07dd6ee024a9bcd8d87883db36546721" translate="yes" xml:space="preserve">
          <source>Counts the number of calls to &lt;code&gt;allocate&lt;/code&gt;. All calls are counted, including requests for zero bytes or failed requests.</source>
          <target state="translated">&lt;code&gt;allocate&lt;/code&gt; 호출 수를 계산합니다 . 0 바이트 요청 또는 실패한 요청을 포함한 모든 호출이 계산됩니다.</target>
        </trans-unit>
        <trans-unit id="3219b291728cf96157a69f99f29e801ca560a91d" translate="yes" xml:space="preserve">
          <source>Counts the number of calls to &lt;code&gt;deallocate&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;deallocate&lt;/code&gt; 호출 횟수를 계산합니다 .</target>
        </trans-unit>
        <trans-unit id="5961c3ed47a6ea7e033c8af93daa0abd5528a016" translate="yes" xml:space="preserve">
          <source>Counts the number of calls to &lt;code&gt;deallocateAll&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;deallocateAll&lt;/code&gt; 호출 횟수를 계산합니다 .</target>
        </trans-unit>
        <trans-unit id="2879654a173945a9cba0580571953a4dc0a97302" translate="yes" xml:space="preserve">
          <source>Counts the number of calls to &lt;code&gt;expand&lt;/code&gt; that resulted in a successful expansion.</source>
          <target state="translated">성공적으로 확장 된 &lt;code&gt;expand&lt;/code&gt; 호출 횟수를 계산합니다 .</target>
        </trans-unit>
        <trans-unit id="5c5af41f873e7913601ca76a10cc79cc68d7c141" translate="yes" xml:space="preserve">
          <source>Counts the number of calls to &lt;code&gt;expand&lt;/code&gt;, regardless of arguments or result.</source>
          <target state="translated">인수 또는 결과에 관계없이 &lt;code&gt;expand&lt;/code&gt; 호출 횟수를 계산합니다 .</target>
        </trans-unit>
        <trans-unit id="09d92465f887e970b05288ec88d3e63ccb6de9ca" translate="yes" xml:space="preserve">
          <source>Counts the number of calls to &lt;code&gt;owns&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;owns&lt;/code&gt; 통화 수를 계산합니다 .</target>
        </trans-unit>
        <trans-unit id="1afc421ebe17abffb879f6aab12a15ef83d68dd4" translate="yes" xml:space="preserve">
          <source>Counts the number of calls to &lt;code&gt;reallocate&lt;/code&gt; that resulted in an in-place reallocation (no memory moved). If this number is close to the total number of reallocations, that indicates the allocator finds room at the current block's end in a large fraction of the cases, but also that internal fragmentation may be high (the size of the unit of allocation is large compared to the typical allocation size of the application).</source>
          <target state="translated">전체 재 할당 (메모리 이동 없음)을 초래 한 &lt;code&gt;reallocate&lt;/code&gt; 호출 수를 계산합니다 . 이 수가 총 재 할당의 총 수에 가까우면 할당자가 많은 경우에 현재 블록의 끝에서 공간을 찾았지만 내부 조각화가 클 수 있음을 나타냅니다 (배분 단위의 크기가 비교됨). 응용 프로그램의 일반적인 할당 크기로).</target>
        </trans-unit>
        <trans-unit id="820537dc16117e7850cbde5ae4bfce6bca7be8ed" translate="yes" xml:space="preserve">
          <source>Counts the number of calls to &lt;code&gt;reallocate&lt;/code&gt; that succeeded. (Reallocations to zero bytes count as successful.)</source>
          <target state="translated">&lt;code&gt;reallocate&lt;/code&gt; 호출 이 성공한 횟수를 계산합니다 . (0 바이트로의 재 할당은 성공한 것으로 간주됩니다.)</target>
        </trans-unit>
        <trans-unit id="bc15833a702b66d803c03a8019110e6825ca2625" translate="yes" xml:space="preserve">
          <source>Counts the number of calls to &lt;code&gt;reallocate&lt;/code&gt;, regardless of arguments or result.</source>
          <target state="translated">인수 또는 결과에 관계없이 &lt;code&gt;reallocate&lt;/code&gt; 호출 횟수를 계산합니다 .</target>
        </trans-unit>
        <trans-unit id="c12f5fb99ca2154f2dcfa85d6b67e6da2e844b9b" translate="yes" xml:space="preserve">
          <source>Covariant means that 'this' can substitute for 't', i.e. a pure function is a match for an impure type.</source>
          <target state="translated">공변량은 'this'가 't'를 대신 할 수 있음을 의미합니다. 즉 순수한 함수는 불순한 유형과 일치합니다.</target>
        </trans-unit>
        <trans-unit id="d95e70de908fe667a8d90b4c2c9835cc65a2bc51" translate="yes" xml:space="preserve">
          <source>Covariant return types are supported, which means that the overriding function in a derived class can return a type that is derived from the type returned by the overridden function:</source>
          <target state="translated">공변량 반환 유형이 지원됩니다. 즉, 파생 클래스의 재정의 함수는 재정의 된 함수에 의해 반환 된 유형에서 파생 된 유형을 반환 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="80e13549b47a4dfc6e898a282920091b209c78be" translate="yes" xml:space="preserve">
          <source>Coverage</source>
          <target state="translated">Coverage</target>
        </trans-unit>
        <trans-unit id="134b318951a0e9fd4c15b2f4d1bdf343d3855913" translate="yes" xml:space="preserve">
          <source>Covers a given range &lt;code&gt;r&lt;/code&gt; in a random manner, i.e. goes through each element of &lt;code&gt;r&lt;/code&gt; once and only once, just in a random order. &lt;code&gt;r&lt;/code&gt; must be a random-access range with length.</source>
          <target state="translated">주어진 범위 &lt;code&gt;r&lt;/code&gt; 을 임의의 방식으로 처리합니다. 즉 , 임의의 순서 로 &lt;code&gt;r&lt;/code&gt; 의 각 요소를 한 번만 통과합니다 . &lt;code&gt;r&lt;/code&gt; 은 길이가 랜덤 액세스 범위 여야합니다.</target>
        </trans-unit>
        <trans-unit id="80b8fd5910e5321eafb27f61b9891d1fcfabc69f" translate="yes" xml:space="preserve">
          <source>CppTypeInfo &lt;code&gt;sti&lt;/code&gt;</source>
          <target state="translated">CppTypeInfo &lt;code&gt;sti&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="49b9f541df9267a1e81a2e1318c39164b9049cf8" translate="yes" xml:space="preserve">
          <source>Create A New Dynamic String Object</source>
          <target state="translated">새로운 동적 문자열 객체 생성</target>
        </trans-unit>
        <trans-unit id="f738b7c71ee4fcfa212cb684acc179c459d0f67c" translate="yes" xml:space="preserve">
          <source>Create Or Redefine SQL Functions</source>
          <target state="translated">SQL 함수 작성 또는 재정의</target>
        </trans-unit>
        <trans-unit id="ece1dfb335b9491989584a0b93ef182f523f9560" translate="yes" xml:space="preserve">
          <source>Create RTInfo for type T</source>
          <target state="translated">타입 T에 대한 RTInfo 생성</target>
        </trans-unit>
        <trans-unit id="d375db3a1f3f34950378c2942ec463da134ac351" translate="yes" xml:space="preserve">
          <source>Create a &lt;code&gt;KRRegion&lt;/code&gt;. If &lt;code&gt;ParentAllocator&lt;/code&gt; is not &lt;code&gt;NullAllocator&lt;/code&gt;, &lt;code&gt;KRRegion&lt;/code&gt;'s destructor will call &lt;code&gt;parent.deallocate&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;KRRegion&lt;/code&gt; 을 작성하십시오 . 경우 &lt;code&gt;ParentAllocator&lt;/code&gt; 가 아닌 &lt;code&gt;NullAllocator&lt;/code&gt; , &lt;code&gt;KRRegion&lt;/code&gt; 의 소멸자 호출합니다 &lt;code&gt;parent.deallocate&lt;/code&gt; 을 .</target>
        </trans-unit>
        <trans-unit id="f87dab8d862d0e2f326eb6f6f98422949344a463" translate="yes" xml:space="preserve">
          <source>Create a SocketSet with a specific initial capacity (defaults to &lt;code&gt;FD_SETSIZE&lt;/code&gt;, the system's default capacity).</source>
          <target state="translated">초기 용량이 특정인 SocketSet을 작성하십시오 (기본값 은 시스템의 기본 용량 인 &lt;code&gt;FD_SETSIZE&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="6115e98c8527cdbd982abe785b7a57087cb4c9e9" translate="yes" xml:space="preserve">
          <source>Create a bitfield pack of eight bits, which fit in one ubyte. The bitfields are allocated starting from the least significant bit, i.e. x occupies the two least significant bits of the bitfields storage.</source>
          <target state="translated">1 바이트에 맞는 8 비트 비트 필드 팩을 만듭니다. 비트 필드는 최하위 비트부터 시작하여 할당됩니다. 즉, x는 비트 필드 스토리지의 최하위 비트 2 개를 차지합니다.</target>
        </trans-unit>
        <trans-unit id="839d59c094905e9232ab8c88f3cdc905e73f062f" translate="yes" xml:space="preserve">
          <source>Create a blocking socket using the parameters from the specified &lt;code&gt;AddressInfo&lt;/code&gt; structure.</source>
          <target state="translated">지정된 &lt;code&gt;AddressInfo&lt;/code&gt; 구조 의 매개 변수를 사용하여 블로킹 소켓을 작성하십시오 .</target>
        </trans-unit>
        <trans-unit id="75ae856d1b4059fd4c939c4490a4432d4ce09656" translate="yes" xml:space="preserve">
          <source>Create a blocking socket. If a single protocol type exists to support this socket type within the address family, the &lt;code&gt;ProtocolType&lt;/code&gt; may be omitted.</source>
          <target state="translated">차단 소켓을 만듭니다. 주소 패밀리 내에서이 소켓 유형을 지원하기 위해 단일 프로토콜 유형이 존재하면 &lt;code&gt;ProtocolType&lt;/code&gt; 은 생략 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d5c91e7ca2204837ccbc8674326fb67dea000b39" translate="yes" xml:space="preserve">
          <source>Create a deep copy of &lt;code&gt;this&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;this&lt;/code&gt; 의 깊은 사본을 만듭니다</target>
        </trans-unit>
        <trans-unit id="2eb536cb42ec7dabddf6284395324e96212d115e" translate="yes" xml:space="preserve">
          <source>Create a dynamic array of the same size and copy the contents of the array into it. The copy is typed as being immutable. If this conversion is invalid the call will not compile.</source>
          <target state="translated">동일한 크기의 동적 배열을 만들고 배열의 내용을 그 안에 복사하십시오. 사본이 변경 불가능한 것으로 입력되었습니다. 이 변환이 유효하지 않으면 호출이 컴파일되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="8ddf0e62c5224c606a534ff3f1eb6d8fe747981d" translate="yes" xml:space="preserve">
          <source>Create a dynamic array of the same size and copy the contents of the array into it. The copy will have any immutability or const stripped. If this conversion is invalid the call will not compile.</source>
          <target state="translated">동일한 크기의 동적 배열을 만들고 배열의 내용을 그 안에 복사하십시오. 사본에는 불변성 또는 const가 제거됩니다. 이 변환이 유효하지 않으면 호출이 컴파일되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="341accefd95b61afa9893db29309cc44315c3a2a" translate="yes" xml:space="preserve">
          <source>Create a horizontal rule by adding a line containing three or more asterisks, underscores or hyphens:</source>
          <target state="translated">별표, 밑줄 또는 하이픈이 3 개 이상 포함 된 줄을 추가하여 가로 규칙을 만듭니다.</target>
        </trans-unit>
        <trans-unit id="e967753a33c5c7c7aa1e8f4422915e9dfd50d92c" translate="yes" xml:space="preserve">
          <source>Create a new associative array of the same size and copy the contents of the associative array into it.</source>
          <target state="translated">동일한 크기의 새 연관 배열을 작성하고 연관 배열의 컨텐츠를 여기에 복사하십시오.</target>
        </trans-unit>
        <trans-unit id="4c9de552758093961aee77c1dae8b1dd3d177f54" translate="yes" xml:space="preserve">
          <source>Create a new scope from sc. semantic, semantic2 and semantic3 will use this for aggregate members.</source>
          <target state="translated">sc에서 새 범위를 만듭니다. semantic, semantic2 및 semantic3은 집계 멤버에이를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="765b47ab87cb7a6d03987e9ff17e776ff00c1f20" translate="yes" xml:space="preserve">
          <source>Create a new scope if one or more given attributes are different from the sc's. If the returned scope != sc, the caller should pop the scope after it used.</source>
          <target state="translated">하나 이상의 지정된 속성이 sc와 다른 경우 새 범위를 만듭니다. 반환 된 범위! = sc 인 경우 호출자는 사용 후 범위를 팝해야합니다.</target>
        </trans-unit>
        <trans-unit id="0af330de1bfdb44bc3db78edbb6764a903bd5a6f" translate="yes" xml:space="preserve">
          <source>Create a new thread for executing this &lt;code&gt;Task&lt;/code&gt;, execute it in the newly created thread, then terminate the thread. This can be used for future/promise parallelism. An explicit priority may be given to the &lt;code&gt;Task&lt;/code&gt;. If one is provided, its value is forwarded to &lt;code&gt;core.thread.Thread.priority&lt;/code&gt;. See &lt;a href=&quot;std_parallelism#task&quot;&gt;&lt;code&gt;std.parallelism.task&lt;/code&gt;&lt;/a&gt; for usage example.</source>
          <target state="translated">이 &lt;code&gt;Task&lt;/code&gt; 를 실행할 새 스레드를 작성하고 새로 작성된 스레드에서 실행 한 다음 스레드를 종료하십시오. 이것은 미래 / 약속 병렬 처리에 사용될 수 있습니다. 명시 적 우선 순위가 부여 될 수 있습니다 &lt;code&gt;Task&lt;/code&gt; . 제공되는 경우 해당 값은 &lt;code&gt;core.thread.Thread.priority&lt;/code&gt; 로 전달됩니다 . 사용법 예는 &lt;a href=&quot;std_parallelism#task&quot;&gt; &lt;code&gt;std.parallelism.task&lt;/code&gt; &lt;/a&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="c71ba660ac8a783c6ab9eb2e83d4cb7a0caf6e05" translate="yes" xml:space="preserve">
          <source>Create a quiet NAN, storing an integer inside the payload.</source>
          <target state="translated">페이로드 안에 정수를 저장하여 조용한 NAN을 만듭니다.</target>
        </trans-unit>
        <trans-unit id="b0230dbb481a6cc7524fc6a1776a286525afecbb" translate="yes" xml:space="preserve">
          <source>Create a range which repeats one value.</source>
          <target state="translated">하나의 값을 반복하는 범위를 만듭니다.</target>
        </trans-unit>
        <trans-unit id="05cea08ac76b777160923ee7d8caa033b1e3267d" translate="yes" xml:space="preserve">
          <source>Create a reference to another dt.</source>
          <target state="translated">다른 dt에 대한 참조를 작성하십시오.</target>
        </trans-unit>
        <trans-unit id="956893df969cb511fe8cb0a535aa0c05eb7c1e44" translate="yes" xml:space="preserve">
          <source>Create a scope for the parameters of the TemplateInstance &lt;code&gt;ti&lt;/code&gt; in the parent scope sc from the ScopeDsymbol paramsym.</source>
          <target state="translated">ScopeDsymbol 매개 변수 에서 상위 범위 sc 의 TemplateInstance &lt;code&gt;ti&lt;/code&gt; 매개 변수에 대한 범위를 작성하십시오 .</target>
        </trans-unit>
        <trans-unit id="6243527d15de44e02eb522bb38a9f03d7ab0c9b3" translate="yes" xml:space="preserve">
          <source>Create a thread not under control of the runtime, i.e. TLS module constructors are not run and the GC does not suspend it during a collection.</source>
          <target state="translated">런타임을 제어하지 않는 스레드를 작성하십시오. 즉, TLS 모듈 생성자가 실행되지 않고 GC가 콜렉션 중에이를 일시 중단하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="348e3661ccba88f4db846a336ac30d6c05131e6d" translate="yes" xml:space="preserve">
          <source>Create a unary or binary function from a string. Most often used when defining algorithms on ranges.</source>
          <target state="translated">문자열에서 단항 또는 이진 함수를 만듭니다. 범위에서 알고리즘을 정의 할 때 가장 자주 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="959f9dde6d0a81fc23a2588b08ba6db6bae1876b" translate="yes" xml:space="preserve">
          <source>Create a vector type.</source>
          <target state="translated">벡터 유형을 만듭니다.</target>
        </trans-unit>
        <trans-unit id="9572cfad6b3211fcd4b15b756e271a21d6de1572" translate="yes" xml:space="preserve">
          <source>Create an &lt;code&gt;Fft&lt;/code&gt; object for computing fast Fourier transforms of power of two sizes of &lt;code&gt;size&lt;/code&gt; or smaller. &lt;code&gt;size&lt;/code&gt; must be a power of two.</source>
          <target state="translated">두 가지 &lt;code&gt;size&lt;/code&gt; 또는 그보다 작은 크기의 고속 푸리에 변환을 계산하기위한 &lt;code&gt;Fft&lt;/code&gt; 객체를 만듭니다 . &lt;code&gt;size&lt;/code&gt; 는 2의 거듭 제곱이어야합니다.</target>
        </trans-unit>
        <trans-unit id="d6650f16211e259caf5365253a1f7216d8f5171d" translate="yes" xml:space="preserve">
          <source>Create an array of &lt;code&gt;T&lt;/code&gt; with &lt;code&gt;length&lt;/code&gt; elements using &lt;code&gt;alloc&lt;/code&gt;. The array is either default-initialized, filled with copies of &lt;code&gt;init&lt;/code&gt;, or initialized with values fetched from &lt;code&gt;range&lt;/code&gt;.</source>
          <target state="translated">배열 생성 &lt;code&gt;T&lt;/code&gt; 와 &lt;code&gt;length&lt;/code&gt; 사용 요소 &lt;code&gt;alloc&lt;/code&gt; . 배열은 기본적으로 초기화 되거나, &lt;code&gt;init&lt;/code&gt; 사본으로 채워지 거나, &lt;code&gt;range&lt;/code&gt; 에서 가져온 값으로 초기화됩니다 .</target>
        </trans-unit>
        <trans-unit id="526001f9a9b94b9fd00bba4fb0e338ddc47b01cf" translate="yes" xml:space="preserve">
          <source>Create an array of &lt;code&gt;T&lt;/code&gt; with &lt;code&gt;length&lt;/code&gt; elements. The array is either default-initialized, filled with copies of &lt;code&gt;init&lt;/code&gt;, or initialized with values fetched from &lt;code&gt;range&lt;/code&gt;.</source>
          <target state="translated">배열 생성 &lt;code&gt;T&lt;/code&gt; 와 &lt;code&gt;length&lt;/code&gt; 요소. 배열은 기본적으로 초기화 되거나, &lt;code&gt;init&lt;/code&gt; 사본으로 채워지 거나, &lt;code&gt;range&lt;/code&gt; 에서 가져온 값으로 초기화됩니다 .</target>
        </trans-unit>
        <trans-unit id="afd41877e2d03683b62c3966d07b3578b44fa83c" translate="yes" xml:space="preserve">
          <source>Create an array of enumerated values</source>
          <target state="translated">열거 된 값으로 구성된 배열 만들기</target>
        </trans-unit>
        <trans-unit id="d624d8319aaa043a0e0bcda5eb8c6692ae1c99ad" translate="yes" xml:space="preserve">
          <source>Create an array of random numbers using range functions and UFCS</source>
          <target state="translated">범위 함수와 UFCS를 사용하여 난수 배열을 만듭니다.</target>
        </trans-unit>
        <trans-unit id="14ef15a3d735dc58c104a58836a40a871675370e" translate="yes" xml:space="preserve">
          <source>Create an identifier in the string table.</source>
          <target state="translated">문자열 테이블에서 식별자를 작성하십시오.</target>
        </trans-unit>
        <trans-unit id="5f15bb6174bb0ae0102d8f77548b958b264eca0f" translate="yes" xml:space="preserve">
          <source>Create inclusive destructor for struct/class by aggregating all the destructors in dtors[] with the destructors for all the members.</source>
          <target state="translated">dtors []의 모든 소멸자를 모든 멤버의 소멸자와 집계하여 struct / class에 대한 포괄적 인 소멸자를 작성하십시오.</target>
        </trans-unit>
        <trans-unit id="06412ef3cdbe60fb294e12eeae1a8f44ed3439af" translate="yes" xml:space="preserve">
          <source>Create inclusive invariant for struct/class by aggregating all the invariants in invs[]. void __invariant() const [pure nothrow @trusted] { invs[0](), invs[1](), ...; }</source>
          <target state="translated">invs []에있는 모든 불변량을 모아서 구조체 / 클래스에 대한 불변 값을 만드십시오. void __invariant () const [순수하지 않은 @trusted] {invs [0] (), invs [1] (), ...; }</target>
        </trans-unit>
        <trans-unit id="86c9df773642e6041f2232b04da0147162423a70" translate="yes" xml:space="preserve">
          <source>Create instance of Object represented by 'this'.</source>
          <target state="translated">'this'로 표시되는 Object의 인스턴스를 작성하십시오.</target>
        </trans-unit>
        <trans-unit id="8f91dcf5e8a8544b29b8c109ab40e97ebba994da" translate="yes" xml:space="preserve">
          <source>Create instance of class specified by the fully qualified name classname. The class must either have no constructors or have a default constructor.</source>
          <target state="translated">완전한 이름 classname으로 지정된 클래스의 인스턴스를 작성하십시오. 클래스에는 생성자가 없거나 기본 생성자가 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="3aae95e6ec02b6e5eb22379134870bf1f1adbec6" translate="yes" xml:space="preserve">
          <source>Create link to existing list, that is, share the list with somebody else.</source>
          <target state="translated">기존 목록에 대한 링크를 작성하십시오. 즉, 다른 사람과 목록을 공유하십시오.</target>
        </trans-unit>
        <trans-unit id="aeec46bd186170bc95905007868367a92e1a1373" translate="yes" xml:space="preserve">
          <source>Create reference to s+offset</source>
          <target state="translated">s + offset에 대한 참조 생성</target>
        </trans-unit>
        <trans-unit id="e69371dea3bc5d5b1ce101edd514aa4b5a3a2c33" translate="yes" xml:space="preserve">
          <source>Create the static initializer for the struct/class.</source>
          <target state="translated">구조체 / 클래스에 대한 정적 초기화 프로그램을 만듭니다.</target>
        </trans-unit>
        <trans-unit id="e2c8a09dc1433291cd9bc6fd5786498693b64e21" translate="yes" xml:space="preserve">
          <source>CreateFolder &lt;code&gt;createFileNameFolder&lt;/code&gt;</source>
          <target state="translated">CreateFolder &lt;code&gt;createFileNameFolder&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="e34f80c232756fb185e577f5d37547da03fc5dc5" translate="yes" xml:space="preserve">
          <source>Creates a &lt;a href=&quot;#Date&quot;&gt;&lt;code&gt;Date&lt;/code&gt;&lt;/a&gt; from a string with the format YYYY-MM-DD. Whitespace is stripped from the given string.</source>
          <target state="translated">YYYY-MM-DD 형식의 문자열에서 &lt;a href=&quot;#Date&quot;&gt; &lt;code&gt;Date&lt;/code&gt; &lt;/a&gt; 를 만듭니다 . 주어진 문자열에서 공백이 제거됩니다.</target>
        </trans-unit>
        <trans-unit id="ddc6e946bb7d665d5d024eddf994d6bb9a983bdc" translate="yes" xml:space="preserve">
          <source>Creates a &lt;a href=&quot;#Date&quot;&gt;&lt;code&gt;Date&lt;/code&gt;&lt;/a&gt; from a string with the format YYYY-Mon-DD. Whitespace is stripped from the given string.</source>
          <target state="translated">YYYY-Mon-DD 형식의 문자열에서 &lt;a href=&quot;#Date&quot;&gt; &lt;code&gt;Date&lt;/code&gt; &lt;/a&gt; 를 만듭니다 . 주어진 문자열에서 공백이 제거됩니다.</target>
        </trans-unit>
        <trans-unit id="b0e20c926289335859e6d97ff01950b27ec62dd2" translate="yes" xml:space="preserve">
          <source>Creates a &lt;a href=&quot;#Date&quot;&gt;&lt;code&gt;Date&lt;/code&gt;&lt;/a&gt; from a string with the format YYYYMMDD. Whitespace is stripped from the given string.</source>
          <target state="translated">YYYYMMDD 형식의 문자열에서 &lt;a href=&quot;#Date&quot;&gt; &lt;code&gt;Date&lt;/code&gt; &lt;/a&gt; 를 만듭니다 . 주어진 문자열에서 공백이 제거됩니다.</target>
        </trans-unit>
        <trans-unit id="d3091af4b2ee859443ab3c8a53bebcda60ddb979" translate="yes" xml:space="preserve">
          <source>Creates a &lt;a href=&quot;#DateTime&quot;&gt;&lt;code&gt;DateTime&lt;/code&gt;&lt;/a&gt; from a string with the format YYYY-MM-DDTHH:MM:SS. Whitespace is stripped from the given string.</source>
          <target state="translated">YYYY-MM-DDTHH : MM : SS 형식의 문자열에서 &lt;a href=&quot;#DateTime&quot;&gt; &lt;code&gt;DateTime&lt;/code&gt; &lt;/a&gt; 을 만듭니다 . 주어진 문자열에서 공백이 제거됩니다.</target>
        </trans-unit>
        <trans-unit id="3041e4d81e36a466d1e51fa044e13c66f2d70792" translate="yes" xml:space="preserve">
          <source>Creates a &lt;a href=&quot;#DateTime&quot;&gt;&lt;code&gt;DateTime&lt;/code&gt;&lt;/a&gt; from a string with the format YYYY-Mon-DD HH:MM:SS. Whitespace is stripped from the given string.</source>
          <target state="translated">YYYY-Mon-DD HH : MM : SS 형식의 문자열에서 &lt;a href=&quot;#DateTime&quot;&gt; &lt;code&gt;DateTime&lt;/code&gt; &lt;/a&gt; 을 만듭니다 . 주어진 문자열에서 공백이 제거됩니다.</target>
        </trans-unit>
        <trans-unit id="9dbacf39bfced8fa82e9ebe4c805f56fa4355100" translate="yes" xml:space="preserve">
          <source>Creates a &lt;a href=&quot;#DateTime&quot;&gt;&lt;code&gt;DateTime&lt;/code&gt;&lt;/a&gt; from a string with the format YYYYMMDDTHHMMSS. Whitespace is stripped from the given string.</source>
          <target state="translated">YYYYMMDDTHHMMSS 형식의 문자열에서 &lt;a href=&quot;#DateTime&quot;&gt; &lt;code&gt;DateTime&lt;/code&gt; &lt;/a&gt; 을 만듭니다 . 주어진 문자열에서 공백이 제거됩니다.</target>
        </trans-unit>
        <trans-unit id="89d6b000a1e0072815008260d5751f430cc1bc5b" translate="yes" xml:space="preserve">
          <source>Creates a &lt;a href=&quot;#SysTime&quot;&gt;&lt;code&gt;SysTime&lt;/code&gt;&lt;/a&gt; from a string with the format YYYY-MM-DD HH:MM:SS.FFFFFFFTZ (where F is fractional seconds is the time zone). Whitespace is stripped from the given string.</source>
          <target state="translated">작성 &lt;a href=&quot;#SysTime&quot;&gt; &lt;code&gt;SysTime&lt;/code&gt; &lt;/a&gt; MM : 형식 YYYY-MM-DD HH의 문자열을 행 SS.FFFFFFFTZ (F 분수 초이다 시간대이다). 주어진 문자열에서 공백이 제거됩니다.</target>
        </trans-unit>
        <trans-unit id="25e0e1d4a091ccac9d256e34e9f9ae4e5842e2bf" translate="yes" xml:space="preserve">
          <source>Creates a &lt;a href=&quot;#SysTime&quot;&gt;&lt;code&gt;SysTime&lt;/code&gt;&lt;/a&gt; from a string with the format YYYY-MM-DDTHH:MM:SS.FFFFFFFTZ (where F is fractional seconds is the time zone). Whitespace is stripped from the given string.</source>
          <target state="translated">작성 &lt;a href=&quot;#SysTime&quot;&gt; &lt;code&gt;SysTime&lt;/code&gt; &lt;/a&gt; MM : 형식 YYYY-MM-ISO 형식의 문자열을 행 SS.FFFFFFFTZ (F 분수 초이다 시간대이다). 주어진 문자열에서 공백이 제거됩니다.</target>
        </trans-unit>
        <trans-unit id="bbfa00e601500f8abcab6f8903eca2c36e737ac4" translate="yes" xml:space="preserve">
          <source>Creates a &lt;a href=&quot;#SysTime&quot;&gt;&lt;code&gt;SysTime&lt;/code&gt;&lt;/a&gt; from a string with the format YYYYMMDDTHHMMSS.FFFFFFFTZ (where F is fractional seconds is the time zone). Whitespace is stripped from the given string.</source>
          <target state="translated">작성 &lt;a href=&quot;#SysTime&quot;&gt; &lt;code&gt;SysTime&lt;/code&gt; &lt;/a&gt; 포맷 YYYYMMDDTHHMMSS.FFFFFFFTZ의 문자열을 행 (F 분수 초이다 시간대이다). 주어진 문자열에서 공백이 제거됩니다.</target>
        </trans-unit>
        <trans-unit id="b213f5d28de923b7220902c1697934db1c8f60d3" translate="yes" xml:space="preserve">
          <source>Creates a &lt;a href=&quot;#TimeOfDay&quot;&gt;&lt;code&gt;TimeOfDay&lt;/code&gt;&lt;/a&gt; from a string with the format HH:MM:SS. Whitespace is stripped from the given string.</source>
          <target state="translated">HH : MM : SS 형식의 문자열에서 &lt;a href=&quot;#TimeOfDay&quot;&gt; &lt;code&gt;TimeOfDay&lt;/code&gt; &lt;/a&gt; 를 만듭니다 . 주어진 문자열에서 공백이 제거됩니다.</target>
        </trans-unit>
        <trans-unit id="96b1a32d19336613b876dcd9a105f13defae7bd7" translate="yes" xml:space="preserve">
          <source>Creates a &lt;a href=&quot;#TimeOfDay&quot;&gt;&lt;code&gt;TimeOfDay&lt;/code&gt;&lt;/a&gt; from a string with the format HHMMSS. Whitespace is stripped from the given string.</source>
          <target state="translated">작성 &lt;a href=&quot;#TimeOfDay&quot;&gt; &lt;code&gt;TimeOfDay&lt;/code&gt; &lt;/a&gt; 형식 HHMMSS의 문자열에서합니다. 주어진 문자열에서 공백이 제거됩니다.</target>
        </trans-unit>
        <trans-unit id="661f5e4bfc4e5c0b2feb77d82f632d60d90264a2" translate="yes" xml:space="preserve">
          <source>Creates a &lt;code&gt;BitArray&lt;/code&gt; from a &lt;code&gt;bool&lt;/code&gt; array, such that &lt;code&gt;bool&lt;/code&gt; values read from left to right correspond to subsequent bits in the &lt;code&gt;BitArray&lt;/code&gt;.</source>
          <target state="translated">작성 &lt;code&gt;BitArray&lt;/code&gt; 를 A로부터 &lt;code&gt;bool&lt;/code&gt; 되도록 배열 &lt;code&gt;bool&lt;/code&gt; 값은 후속 비트 오른쪽 대응하여 왼쪽에서 판독 &lt;code&gt;BitArray&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="75f1a094795d835c2e6c032e474ae4ed7954f131" translate="yes" xml:space="preserve">
          <source>Creates a &lt;code&gt;BitArray&lt;/code&gt; from the raw contents of the source array. The source array is not copied but simply acts as the underlying array of bits, which stores data as &lt;code&gt;size_t&lt;/code&gt; units.</source>
          <target state="translated">소스 배열의 원시 내용에서 &lt;code&gt;BitArray&lt;/code&gt; 를 만듭니다 . 소스 배열은 복사되지 않고 단순히 기본 비트 배열로 작동하여 데이터를 &lt;code&gt;size_t&lt;/code&gt; 단위 로 저장합니다 .</target>
        </trans-unit>
        <trans-unit id="91bf27933374868d67d5fe77c4446e5f6d88a641" translate="yes" xml:space="preserve">
          <source>Creates a &lt;code&gt;Task&lt;/code&gt; on the GC heap that calls a function pointer, delegate, or class/struct with overloaded opCall.</source>
          <target state="translated">오버로드 된 opCall을 사용하여 함수 포인터, 델리게이트 또는 클래스 / 구조를 호출 하는 &lt;code&gt;Task&lt;/code&gt; 을 GC 힙에 만듭니다 .</target>
        </trans-unit>
        <trans-unit id="f4058ec66257ae48d3c3078de7f6e641a360c7cb" translate="yes" xml:space="preserve">
          <source>Creates a &lt;code&gt;Task&lt;/code&gt; on the GC heap that calls an alias. This may be executed via &lt;code&gt;Task.executeInNewThread&lt;/code&gt; or by submitting to a &lt;a href=&quot;std_parallelism#TaskPool&quot;&gt;&lt;code&gt;std.parallelism.TaskPool&lt;/code&gt;&lt;/a&gt;. A globally accessible instance of &lt;code&gt;TaskPool&lt;/code&gt; is provided by &lt;a href=&quot;std_parallelism#taskPool&quot;&gt;&lt;code&gt;std.parallelism.taskPool&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">별칭을 호출하는 GC 힙에 &lt;code&gt;Task&lt;/code&gt; 을 만듭니다 . 이를 통해 실행될 수있다 &lt;code&gt;Task.executeInNewThread&lt;/code&gt; 또는에 제출 &lt;a href=&quot;std_parallelism#TaskPool&quot;&gt; &lt;code&gt;std.parallelism.TaskPool&lt;/code&gt; &lt;/a&gt; . &lt;a href=&quot;std_parallelism#taskPool&quot;&gt; &lt;code&gt;std.parallelism.taskPool&lt;/code&gt; &lt;/a&gt; 은 세계적으로 액세스 가능한 &lt;code&gt;TaskPool&lt;/code&gt; 인스턴스를 제공합니다 .</target>
        </trans-unit>
        <trans-unit id="34e4d8ddfca04c3316cc068b4800ba69aa18ecdf" translate="yes" xml:space="preserve">
          <source>Creates a Condition variable analog for signaling.</source>
          <target state="translated">시그널링을위한 Condition 변수 아날로그를 작성합니다.</target>
        </trans-unit>
        <trans-unit id="c859ea4adbfacacaab358299326fde8ee39270d1" translate="yes" xml:space="preserve">
          <source>Creates a Lexer for the source code base[begoffset..endoffset+1]. The last character, base[endoffset], must be null (0) or EOF (0x1A).</source>
          <target state="translated">소스 코드베이스 [begoffset..endoffset + 1]에 대한 Lexer를 작성합니다. 마지막 문자 인 base [endoffset]은 null (0) 또는 EOF (0x1A) 여야합니다.</target>
        </trans-unit>
        <trans-unit id="a4043d1c472260058ff2b44188bce91464289418" translate="yes" xml:space="preserve">
          <source>Creates a bitfield pack of eight bits, which fit in one &lt;code&gt;ubyte&lt;/code&gt;. The bitfields are allocated starting from the least significant bit, i.e. x occupies the two least significant bits of the bitfields storage.</source>
          <target state="translated">한 적합한 8 비트의 비트 필드 팩 생성 &lt;code&gt;ubyte&lt;/code&gt; 를 . 비트 필드는 최하위 비트부터 시작하여 할당됩니다. 즉, x는 비트 필드 스토리지의 최하위 비트 2 개를 차지합니다.</target>
        </trans-unit>
        <trans-unit id="22e271cc711a759e645164a6c0eb60bcdf7daa84" translate="yes" xml:space="preserve">
          <source>Creates a container of type &lt;code&gt;C&lt;/code&gt; from either another container or a range. The created container must not be a null reference even if x is empty.</source>
          <target state="translated">다른 컨테이너 또는 범위에서 유형 &lt;code&gt;C&lt;/code&gt; 의 컨테이너를 만듭니다 . x가 비어 있어도 작성된 컨테이너는 널 참조가 아니어야합니다.</target>
        </trans-unit>
        <trans-unit id="1c88b30b91f6883b933e7785db39c6a543b98bd1" translate="yes" xml:space="preserve">
          <source>Creates a copy of a &lt;a href=&quot;#Tuple&quot;&gt;&lt;code&gt;Tuple&lt;/code&gt;&lt;/a&gt; with its fields in reverse order.</source>
          <target state="translated">필드를 역순 으로 &lt;a href=&quot;#Tuple&quot;&gt; &lt;code&gt;Tuple&lt;/code&gt; &lt;/a&gt; 의 복사본을 만듭니다 .</target>
        </trans-unit>
        <trans-unit id="eafa6a0f5a2c3f7d41c7a2a8061125f06fba9dbe" translate="yes" xml:space="preserve">
          <source>Creates a forward range whose values are defined by a mathematical recurrence relation.</source>
          <target state="translated">수학적 되풀이 관계에 의해 값이 정의되는 전달 범위를 만듭니다.</target>
        </trans-unit>
        <trans-unit id="f24557243bfa5bfdcb62b5e9b12d22b154537901" translate="yes" xml:space="preserve">
          <source>Creates a function that binds the first argument of a given function to a given value.</source>
          <target state="translated">주어진 함수의 첫 번째 인수를 주어진 값에 바인딩하는 함수를 만듭니다.</target>
        </trans-unit>
        <trans-unit id="bb183c0a9d71fad3327428b4e288c762c0601c56" translate="yes" xml:space="preserve">
          <source>Creates a function that caches its result for fast re-evaluation.</source>
          <target state="translated">빠른 재평가를 위해 결과를 캐시하는 함수를 만듭니다.</target>
        </trans-unit>
        <trans-unit id="ca671f44e7aaeac35a6537c07507991cbe066f68" translate="yes" xml:space="preserve">
          <source>Creates a function that negates another.</source>
          <target state="translated">다른 것을 무효화하는 함수를 작성합니다.</target>
        </trans-unit>
        <trans-unit id="cde91551966a8c3538a557aa7e1f65e48ffab5da" translate="yes" xml:space="preserve">
          <source>Creates a hash of this &lt;code&gt;Tuple&lt;/code&gt;.</source>
          <target state="translated">이 &lt;code&gt;Tuple&lt;/code&gt; 의 해시를 작성합니다 .</target>
        </trans-unit>
        <trans-unit id="0adb30e0283a4af18094accba2f9b8d4adae66b8" translate="yes" xml:space="preserve">
          <source>Creates a mathematical sequence given the initial values and a recurrence function that computes the next value from the existing values. The sequence comes in the form of an infinite forward range. The type &lt;code&gt;Recurrence&lt;/code&gt; itself is seldom used directly; most often, recurrences are obtained by calling the function &lt;code&gt;recurrence&lt;/code&gt;.</source>
          <target state="translated">초기 값과 기존 값에서 다음 값을 계산하는 반복 함수가 주어지면 수학적 시퀀스를 만듭니다. 시퀀스는 무한 앞으로 범위의 형태로 제공됩니다. &lt;code&gt;Recurrence&lt;/code&gt; 유형 자체는 거의 사용되지 않습니다. 대부분의 경우 재발은 함수 &lt;code&gt;recurrence&lt;/code&gt; 을 호출하여 얻습니다 .</target>
        </trans-unit>
        <trans-unit id="96ee19dd76d73d769afaaa909687c75babff0184" translate="yes" xml:space="preserve">
          <source>Creates a new Condition variable analog which is used to check for and to signal the addition of messages to a thread's message queue. Like yield, some schedulers may need to define custom behavior so that calls to Condition.wait() yield to another thread when no new messages are available instead of blocking.</source>
          <target state="translated">스레드의 메시지 큐에 메시지 추가를 확인하고 신호를 보내는 데 사용되는 새로운 조건 변수 아날로그를 작성합니다. yield와 마찬가지로 일부 스케줄러는 블로킹 대신 사용 가능한 새 메시지가 없을 때 Condition.wait () 호출이 다른 스레드를 생성하도록 사용자 지정 동작을 정의해야 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a031f47a97f06dd1d0df403626203b69d541f12c" translate="yes" xml:space="preserve">
          <source>Creates a new Condition variable. No custom behavior is needed here.</source>
          <target state="translated">새로운 조건 변수를 만듭니다. 여기에는 사용자 지정 동작이 필요하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="124555a8b0f648fe1d012d276d753c0d19322a5b" translate="yes" xml:space="preserve">
          <source>Creates a new array out of several copies of an input array or range.</source>
          <target state="translated">입력 배열 또는 범위의 여러 복사본으로 새 배열을 만듭니다.</target>
        </trans-unit>
        <trans-unit id="c29b4591a6c00e3151f27e3a3a0216407411dd7f" translate="yes" xml:space="preserve">
          <source>Creates a new array such that the items in &lt;code&gt;slice&lt;/code&gt; are replaced with the items in &lt;code&gt;replacement&lt;/code&gt;. &lt;code&gt;slice&lt;/code&gt; and &lt;code&gt;replacement&lt;/code&gt; do not need to be the same length. The result will grow or shrink based on the items given.</source>
          <target state="translated">&lt;code&gt;slice&lt;/code&gt; 의 항목이 &lt;code&gt;replacement&lt;/code&gt; 항목으로 대체 되도록 새 배열을 만듭니다 . &lt;code&gt;slice&lt;/code&gt; 와 &lt;code&gt;replacement&lt;/code&gt; 길이가 같을 필요는 없습니다. 주어진 항목에 따라 결과가 커지거나 줄어 듭니다.</target>
        </trans-unit>
        <trans-unit id="3890727bd831b1cb6c012e4c91606c3ef658c4a3" translate="yes" xml:space="preserve">
          <source>Creates a new array which is identical to &lt;code&gt;s&lt;/code&gt; except that all of its characters are converted to lowercase (by preforming Unicode lowercase mapping). If none of &lt;code&gt;s&lt;/code&gt; characters were affected, then &lt;code&gt;s&lt;/code&gt; itself is returned if &lt;code&gt;s&lt;/code&gt; is a &lt;code&gt;string&lt;/code&gt;-like type.</source>
          <target state="translated">모든 문자가 유니 코드 소문자 매핑을 수행하여 소문자로 변환된다는 점을 제외하고 &lt;code&gt;s&lt;/code&gt; 와 동일한 새 배열을 만듭니다 . 아무도 경우 &lt;code&gt;s&lt;/code&gt; 문자가 영향을받지 된 후 &lt;code&gt;s&lt;/code&gt; 의 경우 그 자체가 반환 &lt;code&gt;s&lt;/code&gt; A는 &lt;code&gt;string&lt;/code&gt; 유형 -like가.</target>
        </trans-unit>
        <trans-unit id="7e9c86b82c6b1fb66dd08cc61c38a1b079756d54" translate="yes" xml:space="preserve">
          <source>Creates a new curl session handle with the same options set for the handle passed in. Duplicating a handle could only be a matter of cloning data and options, internal state info and things like persistant connections cannot be transfered. It is useful in multithreaded applications when you can run curl_easy_duphandle() for each new thread to avoid a series of identical curl_easy_setopt() invokes in every thread.</source>
          <target state="translated">전달 된 핸들에 대해 동일한 옵션 세트를 사용하여 새로운 curl 세션 핸들을 작성합니다. 핸들 복제는 데이터 및 옵션 복제, 내부 상태 정보 및 지속 연결과 같은 항목 만 전송할 수 있습니다. 모든 스레드에서 일련의 동일한 curl_easy_setopt () 호출을 피하기 위해 각 새 스레드에 대해 curl_easy_duphandle ()을 실행할 수있는 경우 다중 스레드 응용 프로그램에 유용합니다.</target>
        </trans-unit>
        <trans-unit id="60a4fea607c23225fa400ed6c857bae74cd299af" translate="yes" xml:space="preserve">
          <source>Creates a new function call expression</source>
          <target state="translated">새로운 함수 호출 표현식을 작성합니다</target>
        </trans-unit>
        <trans-unit id="2112334d42e17720c661c805ce3324b558dd51cb" translate="yes" xml:space="preserve">
          <source>Creates a new instance of Error. The nextInChain parameter is used internally and should always be &lt;code&gt;null&lt;/code&gt; when passed by user code. This constructor does not automatically throw the newly-created Error; the &lt;code&gt;throw&lt;/code&gt; statement should be used for that purpose.</source>
          <target state="translated">새 Error 인스턴스를 만듭니다. nextInChain 매개 변수는 내부적으로 사용 되며 사용자 코드가 전달할 때 항상 &lt;code&gt;null&lt;/code&gt; 이어야 합니다. 이 생성자는 새로 작성된 오류를 자동으로 발생시키지 않습니다. &lt;code&gt;throw&lt;/code&gt; 문은 그 목적을 위해 사용되어야한다.</target>
        </trans-unit>
        <trans-unit id="29ef1c3bd126426d443d7475b7ad71d8d8c5679c" translate="yes" xml:space="preserve">
          <source>Creates a new instance of Exception. The nextInChain parameter is used internally and should always be &lt;code&gt;null&lt;/code&gt; when passed by user code. This constructor does not automatically throw the newly-created Exception; the &lt;code&gt;throw&lt;/code&gt; statement should be used for that purpose.</source>
          <target state="translated">Exception의 새 인스턴스를 만듭니다. nextInChain 매개 변수는 내부적으로 사용 되며 사용자 코드가 전달할 때 항상 &lt;code&gt;null&lt;/code&gt; 이어야 합니다. 이 생성자는 새로 만든 예외를 자동으로 throw하지 않습니다. &lt;code&gt;throw&lt;/code&gt; 문은 그 목적을 위해 사용되어야한다.</target>
        </trans-unit>
        <trans-unit id="75f34c3d414f8f4a0b73cf72e2fb0126aa145b92" translate="yes" xml:space="preserve">
          <source>Creates a new kernel thread and assigns it to run the supplied op.</source>
          <target state="translated">새로운 커널 스레드를 생성하고 제공된 op를 실행하도록 할당합니다.</target>
        </trans-unit>
        <trans-unit id="8d99a8a851fc71224c4095d3dc8c906d38b101b8" translate="yes" xml:space="preserve">
          <source>Creates a new static array from given data.</source>
          <target state="translated">주어진 데이터에서 새로운 정적 배열을 만듭니다.</target>
        </trans-unit>
        <trans-unit id="ecd36a22428e9994d09134717eafec38a89d2e58" translate="yes" xml:space="preserve">
          <source>Creates a pair of connected sockets.</source>
          <target state="translated">연결된 소켓 쌍을 만듭니다.</target>
        </trans-unit>
        <trans-unit id="19f224f0cad04c0c9a5314d50caf1aa975093e9d" translate="yes" xml:space="preserve">
          <source>Creates a proxy for the value &lt;code&gt;a&lt;/code&gt; that will forward all operations while disabling implicit conversions. The aliased item &lt;code&gt;a&lt;/code&gt; must be an &lt;b&gt;lvalue&lt;/b&gt;. This is useful for creating a new type from the &quot;base&quot; type (though this is &lt;b&gt;not&lt;/b&gt; a subtype-supertype relationship; the new type is not related to the old type in any way, by design).</source>
          <target state="translated">암시 적 변환을 비활성화하면서 모든 작업을 전달 하는 값 &lt;code&gt;a&lt;/code&gt; 에 대한 프록시를 만듭니다 . 별명 항목 &lt;code&gt;a&lt;/code&gt; 는 &lt;b&gt;lvalue&lt;/b&gt; 이어야합니다 . 이것은 &quot;기본&quot;유형의 새로운 유형을 만드는 데 유용합니다 (이 비록 &lt;b&gt;하지&lt;/b&gt; 하위 유형 - 슈퍼 관계, 새로운 유형의 디자인에 의해, 어떤 방식으로 기존의 유형과 관련이 없습니다).</target>
        </trans-unit>
        <trans-unit id="facab5397d905340fc2ff34e036fe91a505cf570" translate="yes" xml:space="preserve">
          <source>Creates a random-access range consisting of exactly the first element of the given range.</source>
          <target state="translated">주어진 범위의 첫 번째 요소로 구성된 랜덤 액세스 범위를 만듭니다.</target>
        </trans-unit>
        <trans-unit id="491697895d99be2bf8ff4cd9ed471190dfadb752" translate="yes" xml:space="preserve">
          <source>Creates a random-access range consisting of zero elements of the given range.</source>
          <target state="translated">주어진 범위의 0 요소로 구성된 랜덤 액세스 범위를 만듭니다.</target>
        </trans-unit>
        <trans-unit id="2f69619e79d80e1df263dcf9dbcb2c394594c350" translate="yes" xml:space="preserve">
          <source>Creates a range by successive calls to a given function. This allows to create ranges as a single delegate.</source>
          <target state="translated">주어진 함수를 연속적으로 호출하여 범위를 만듭니다. 이를 통해 범위를 단일 대리자로 만들 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="167e3b6167defb5f50874936631196fc03fabc4e" translate="yes" xml:space="preserve">
          <source>Creates a range consisting of numbers between a starting point and ending point, spaced apart by a given interval.</source>
          <target state="translated">지정된 간격으로 이격 된 시작점과 끝점 사이의 숫자로 구성된 범위를 만듭니다.</target>
        </trans-unit>
        <trans-unit id="095bb16dbe08643123728b96d2a088f28e3da974" translate="yes" xml:space="preserve">
          <source>Creates a range of values that span the given starting and stopping values.</source>
          <target state="translated">지정된 시작 및 중지 값에 걸쳐있는 값 범위를 만듭니다.</target>
        </trans-unit>
        <trans-unit id="c95f11a9b28c359aba0cb5384ce5aea65f8856bc" translate="yes" xml:space="preserve">
          <source>Creates a range that consists of a single element repeated</source>
          <target state="translated">반복되는 단일 요소로 구성된 범위를 만듭니다.</target>
        </trans-unit>
        <trans-unit id="6fa647cca40fc0069485c0e4600015ae305d64f8" translate="yes" xml:space="preserve">
          <source>Creates a range that iterates over the</source>
          <target state="translated">반복되는 범위를 만듭니다.</target>
        </trans-unit>
        <trans-unit id="119d886f6f9141897a559c5bf0cae6c375d23ffa" translate="yes" xml:space="preserve">
          <source>Creates a range that iterates over the first elements of the given ranges.</source>
          <target state="translated">주어진 범위의 첫 번째 요소를 반복하는 범위를 만듭니다.</target>
        </trans-unit>
        <trans-unit id="b3797332557503d8df3a90878b6a631d088b9e66" translate="yes" xml:space="preserve">
          <source>Creates a range that iterates over the given arguments.</source>
          <target state="translated">주어진 인수를 반복하는 범위를 만듭니다.</target>
        </trans-unit>
        <trans-unit id="27a319945d62e58889db17071829a24459cceffe" translate="yes" xml:space="preserve">
          <source>Creates a range that offers a view of a given range as though its elements were reordered according to a given range of indices.</source>
          <target state="translated">주어진 인덱스 범위에 따라 요소가 재정렬 된 것처럼 지정된 범위의보기를 제공하는 범위를 만듭니다.</target>
        </trans-unit>
        <trans-unit id="f505e45463d22852e5431617427809b2bc561947" translate="yes" xml:space="preserve">
          <source>Creates a range that returns a fixed-size sliding window over the original range. Unlike chunks, it advances a configurable number of items at a time, not one chunk at a time.</source>
          <target state="translated">원래 범위에 고정 크기 슬라이딩 창을 반환하는 범위를 만듭니다. 청크와 달리 한 번에 한 청크가 아니라 구성 가능한 항목 수를 한 번에 전진시킵니다.</target>
        </trans-unit>
        <trans-unit id="e2da09b0362ffc9ff9f92b609fc490c7a66e9f7b" translate="yes" xml:space="preserve">
          <source>Creates a range that returns a number of chunks of approximately equal length from the original range.</source>
          <target state="translated">원래 범위와 대략 같은 길이의 청크 수를 반환하는 범위를 만듭니다.</target>
        </trans-unit>
        <trans-unit id="c3774ff477392cd2c3383bbfc03f5d68150b2336" translate="yes" xml:space="preserve">
          <source>Creates a range that returns fixed-size chunks of the original range.</source>
          <target state="translated">원래 범위의 고정 크기 청크를 반환하는 범위를 만듭니다.</target>
        </trans-unit>
        <trans-unit id="0d113436e57d2b2729c85287cfeed4bd50c9facf" translate="yes" xml:space="preserve">
          <source>Creates a range that wraps a given range, forwarding along its elements while also calling a provided function with each element.</source>
          <target state="translated">각 요소와 함께 제공된 함수를 호출하면서 해당 요소를 전달하면서 주어진 범위를 감싸는 범위를 만듭니다.</target>
        </trans-unit>
        <trans-unit id="f7977beaa2aaf3f6cc573dcadaf85a1c0d137ad7" translate="yes" xml:space="preserve">
          <source>Creates a scalable &lt;code&gt;AllocatorList&lt;/code&gt; of &lt;code&gt;Regions&lt;/code&gt;, each having at least &lt;code&gt;bytesPerRegion&lt;/code&gt; bytes. Allocation is very fast. This allocator does not offer &lt;code&gt;deallocate&lt;/code&gt; but does free all regions in its destructor. It is recommended for short-lived batch applications that count on never running out of memory.</source>
          <target state="translated">적어도 &lt;code&gt;bytesPerRegion&lt;/code&gt; 바이트를 갖는 &lt;code&gt;Regions&lt;/code&gt; 의 확장 가능한 &lt;code&gt;AllocatorList&lt;/code&gt; 를 작성 합니다. 할당이 매우 빠릅니다. 이 할당자는 할당 &lt;code&gt;deallocate&lt;/code&gt; 제공하지 않지만 소멸자의 모든 지역을 해제 합니다. 절대로 메모리가 부족하지 않은 단기 배치 응용 프로그램에 권장됩니다.</target>
        </trans-unit>
        <trans-unit id="6f435c0e7fa6220851faf44b48ca047ab20cefcb" translate="yes" xml:space="preserve">
          <source>Creates a separate index for a range.</source>
          <target state="translated">범위에 대해 별도의 인덱스를 만듭니다.</target>
        </trans-unit>
        <trans-unit id="dd006c74f19abaa4a0761b1b7efaf29942f86da3" translate="yes" xml:space="preserve">
          <source>Creates a sequence of zero or more aliases. This is most commonly used as template parameters or arguments.</source>
          <target state="translated">0 개 이상의 별칭 시퀀스를 만듭니다. 템플릿 매개 변수 또는 인수로 가장 일반적으로 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="40566702e6ad921ff558ff9ca4d1037811d09aae" translate="yes" xml:space="preserve">
          <source>Creates a sub-range consisting of only up to the first</source>
          <target state="translated">처음까지만 구성된 하위 범위를 만듭니다.</target>
        </trans-unit>
        <trans-unit id="469d599d62d1c2fd391700f6a0c78d2089510708" translate="yes" xml:space="preserve">
          <source>Creates a symbolic link (symlink).</source>
          <target state="translated">심볼릭 링크 (symlink)를 만듭니다.</target>
        </trans-unit>
        <trans-unit id="802b8df3eba4f0a49c5a4217df7e199c969ce5ad" translate="yes" xml:space="preserve">
          <source>Creates a unidirectional pipe.</source>
          <target state="translated">단방향 파이프를 만듭니다.</target>
        </trans-unit>
        <trans-unit id="cf8f38539d3338ea07ae1f542a53a2838ccaf683" translate="yes" xml:space="preserve">
          <source>Creates an &lt;a href=&quot;std_range_primitives#isInputRange&quot;&gt;input range&lt;/a&gt; set up to parse one line at a time from the file into a tuple.</source>
          <target state="translated">작성 &lt;a href=&quot;std_range_primitives#isInputRange&quot;&gt;입력 범위&lt;/a&gt; 튜플로 파일에서 동시에 해석 한 라인을 설정한다.</target>
        </trans-unit>
        <trans-unit id="3561d870353a64c33492bae1227a4b54a7562e97" translate="yes" xml:space="preserve">
          <source>Creates an &lt;code&gt;AliasSeq&lt;/code&gt; which repeats &lt;code&gt;TList&lt;/code&gt; exactly &lt;code&gt;n&lt;/code&gt; times.</source>
          <target state="translated">&lt;code&gt;TList&lt;/code&gt; 를 정확히 &lt;code&gt;n&lt;/code&gt; 번 반복 하는 &lt;code&gt;AliasSeq&lt;/code&gt; 를 작성 합니다.</target>
        </trans-unit>
        <trans-unit id="8204b9ea20ad3e99dc18dafe9f5966a149ef25a0" translate="yes" xml:space="preserve">
          <source>Creates an empty range from the given range in &amp;Omicron;(&lt;code&gt;1&lt;/code&gt;). If it can, it will return the same range type. If not, it will return &lt;code&gt;takeExactly(range, 0)&lt;/code&gt;.</source>
          <target state="translated">지정된 범위에서 &amp;Omicron; ( &lt;code&gt;1&lt;/code&gt; ) 의 빈 범위를 만듭니다 . 가능한 경우 동일한 범위 유형을 반환합니다. 그렇지 않으면 &lt;code&gt;takeExactly(range, 0)&lt;/code&gt; 반환 합니다.</target>
        </trans-unit>
        <trans-unit id="98c208a0fd5b7f2985b53749917bb319ab1b4a0f" translate="yes" xml:space="preserve">
          <source>Creates an event object.</source>
          <target state="translated">이벤트 객체를 만듭니다.</target>
        </trans-unit>
        <trans-unit id="9fc3668b0b3ac61f1c2ccf2f6e391f909fb421a6" translate="yes" xml:space="preserve">
          <source>Creates an infinite range that repeats the given forward range indefinitely. Good for implementing circular buffers.</source>
          <target state="translated">주어진 앞으로 범위를 무기한 반복하는 무한 범위를 만듭니다. 순환 버퍼 구현에 좋습니다.</target>
        </trans-unit>
        <trans-unit id="dcde82886bef2cfc57fa138c18fa3fe6f213ba99" translate="yes" xml:space="preserve">
          <source>Creates an instance of worker-local storage, initialized with a given value. The value is &lt;code&gt;lazy&lt;/code&gt; so that you can, for example, easily create one instance of a class for each worker. For usage example, see the &lt;code&gt;WorkerLocalStorage&lt;/code&gt; struct.</source>
          <target state="translated">지정된 값으로 초기화 된 작업자 로컬 저장소 인스턴스를 만듭니다. 예를 들어 각 작업자에 대해 하나의 클래스 인스턴스를 쉽게 만들 수 있도록 값이 &lt;code&gt;lazy&lt;/code&gt; 됩니다. 사용 예는 &lt;code&gt;WorkerLocalStorage&lt;/code&gt; 구조체를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="be1b805e9512fab0c82226f8469579575b03085d" translate="yes" xml:space="preserve">
          <source>Creates an lvalue or rvalue of type &lt;code&gt;T&lt;/code&gt; for &lt;code&gt;typeof(...)&lt;/code&gt; and &lt;code&gt;__traits(compiles, ...)&lt;/code&gt; purposes. No actual value is returned.</source>
          <target state="translated">형의 좌변 또는를 rvalue 작성 &lt;code&gt;T&lt;/code&gt; 에 &lt;code&gt;typeof(...)&lt;/code&gt; 와 &lt;code&gt;__traits(compiles, ...)&lt;/code&gt; 목적. 실제 값이 반환되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="eaebf9f2d50b56a9272662e3ba187103b8fd7fb6" translate="yes" xml:space="preserve">
          <source>Creates and returns the hidden parameters for this function declaration.</source>
          <target state="translated">이 함수 선언에 대한 숨겨진 매개 변수를 작성하고 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="9b553ea67f7afbb68b5ef6b9110f190f5fa0d536" translate="yes" xml:space="preserve">
          <source>Creates and starts a new Thread object that executes dg and adds it to the list of tracked threads.</source>
          <target state="translated">dg를 실행하고 추적 된 스레드 목록에 추가하는 새 Thread 객체를 만들고 시작합니다.</target>
        </trans-unit>
        <trans-unit id="d8465192a47f3a3964b86383849851b3f987af9e" translate="yes" xml:space="preserve">
          <source>Creates and starts a new Thread object that executes fn and adds it to the list of tracked threads.</source>
          <target state="translated">fn을 실행하고 추적 된 스레드 목록에 추가하는 새 Thread 객체를 만들고 시작합니다.</target>
        </trans-unit>
        <trans-unit id="1f14747fb861d9f57045e9760eebadb571c0f14c" translate="yes" xml:space="preserve">
          <source>Creates the file if it does not already exist.</source>
          <target state="translated">파일이 없으면 작성합니다.</target>
        </trans-unit>
        <trans-unit id="5e72ff62874af2b080424b1f364475d8251da057" translate="yes" xml:space="preserve">
          <source>Creates the list of modules based on the files provided</source>
          <target state="translated">제공된 파일을 기반으로 모듈 목록을 만듭니다.</target>
        </trans-unit>
        <trans-unit id="c36b26347d25b74467c336b27111c896866bd305" translate="yes" xml:space="preserve">
          <source>Creates the range that results from discarding exactly</source>
          <target state="translated">정확히 버림으로써 발생하는 범위를 만듭니다.</target>
        </trans-unit>
        <trans-unit id="3bc721a88f6358a1f98c1960601822da71eda438" translate="yes" xml:space="preserve">
          <source>Creates the range that results from discarding the first</source>
          <target state="translated">첫 번째를 버린 결과 범위를 만듭니다.</target>
        </trans-unit>
        <trans-unit id="f4fae2eaf902de2336623c5f44ed9233da515843" translate="yes" xml:space="preserve">
          <source>Creates the range that results from discarding the first element from the given range.</source>
          <target state="translated">주어진 범위에서 첫 번째 요소를 버린 결과 범위를 만듭니다.</target>
        </trans-unit>
        <trans-unit id="e8ccf47a3faeae60cbaa6e290f3c7add8d8439e4" translate="yes" xml:space="preserve">
          <source>Creates the range that results from discarding the last</source>
          <target state="translated">마지막을 버린 결과 범위를 만듭니다.</target>
        </trans-unit>
        <trans-unit id="e26745f992813425c3f6e9ec560904ac5dfc6d56" translate="yes" xml:space="preserve">
          <source>Creates the range that results from discarding the last element from the given range.</source>
          <target state="translated">주어진 범위에서 마지막 요소를 버린 결과 범위를 만듭니다.</target>
        </trans-unit>
        <trans-unit id="702d6feb03374612a47955af68790e7167c2df15" translate="yes" xml:space="preserve">
          <source>Creating Immutable Data</source>
          <target state="translated">불변 데이터 생성</target>
        </trans-unit>
        <trans-unit id="bfac50d6424b5166c3ee2808c85ae7c139b5182f" translate="yes" xml:space="preserve">
          <source>Credits</source>
          <target state="translated">Credits</target>
        </trans-unit>
        <trans-unit id="662cb4a2bd7d633921dbca8a7d42f872af7c9656" translate="yes" xml:space="preserve">
          <source>Cs</source>
          <target state="translated">Cs</target>
        </trans-unit>
        <trans-unit id="c2c3639bbe4de0aea10b057ea83de756ef98378f" translate="yes" xml:space="preserve">
          <source>Ctor</source>
          <target state="translated">Ctor</target>
        </trans-unit>
        <trans-unit id="a47b165571b7225fe9e41c496a97f58f335b0c95" translate="yes" xml:space="preserve">
          <source>CtorFlow &lt;code&gt;ctorflow&lt;/code&gt;</source>
          <target state="translated">CtorFlow &lt;code&gt;ctorflow&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="f2ec2f1f5ce49dd13daec8eee36db1395ae3b43f" translate="yes" xml:space="preserve">
          <source>CtorFlow &lt;strong id=&quot;clone&quot;&gt;clone&lt;/strong&gt;();</source>
          <target state="translated">CtorFlow &lt;strong id=&quot;clone&quot;&gt;클론&lt;/strong&gt; ();</target>
        </trans-unit>
        <trans-unit id="7c804c33db286558bb634271d46f72ed27582aa7" translate="yes" xml:space="preserve">
          <source>Cuneiform</source>
          <target state="translated">Cuneiform</target>
        </trans-unit>
        <trans-unit id="45b5a2c7a3a08d60fb826e098c079562c9b73f47" translate="yes" xml:space="preserve">
          <source>Cuneiform Numbers and Punctuation</source>
          <target state="translated">설형 문자 숫자와 문장 부호</target>
        </trans-unit>
        <trans-unit id="c04085590ca8e7a54d013972ef35c99a27d5d737" translate="yes" xml:space="preserve">
          <source>Curl &lt;strong id=&quot;dup&quot;&gt;dup&lt;/strong&gt;();</source>
          <target state="translated">컬 &lt;strong id=&quot;dup&quot;&gt;덥&lt;/strong&gt; ();</target>
        </trans-unit>
        <trans-unit id="773dbcf2918b7b09831a0ed13a940ea3c1ee1fa6" translate="yes" xml:space="preserve">
          <source>CurlCode &lt;strong id=&quot;getTiming&quot;&gt;getTiming&lt;/strong&gt;(CurlInfo timing, ref double val);</source>
          <target state="translated">CurlCode &lt;strong id=&quot;getTiming&quot;&gt;getTiming&lt;/strong&gt; (CurlInfo 타이밍, ref double val);</target>
        </trans-unit>
        <trans-unit id="c2ad2d9e83c0551cb2f717df5892a96ecafc33b4" translate="yes" xml:space="preserve">
          <source>CurlCode &lt;strong id=&quot;perform&quot;&gt;perform&lt;/strong&gt;(ThrowOnError throwOnError = Yes.throwOnError);</source>
          <target state="translated">CurlCode &lt;strong id=&quot;perform&quot;&gt;perform&lt;/strong&gt; (ThrowOnError throwOnError = Yes.throwOnError);</target>
        </trans-unit>
        <trans-unit id="be31623169a932d4c6c560d7201b407aa5182a35" translate="yes" xml:space="preserve">
          <source>CurlInfo &lt;code&gt;timing&lt;/code&gt;</source>
          <target state="translated">CurlInfo &lt;code&gt;timing&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="12060f8ec6f86ad11a42f46cb52ac099f81f88f5" translate="yes" xml:space="preserve">
          <source>CurlKHType &lt;strong id=&quot;keytype&quot;&gt;keytype&lt;/strong&gt;;</source>
          <target state="translated">CurlKHType &lt;strong id=&quot;keytype&quot;&gt;키 타입&lt;/strong&gt; ;</target>
        </trans-unit>
        <trans-unit id="88902869e96472323a9edc08d7ae406940c970e5" translate="yes" xml:space="preserve">
          <source>CurlOption &lt;code&gt;option&lt;/code&gt;</source>
          <target state="translated">CurlOption &lt;code&gt;option&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="52b9269b5ed7da7a493a1dbe83846551a4d7568c" translate="yes" xml:space="preserve">
          <source>CurlSeek delegate(long, CurlSeekPos) &lt;code&gt;callback&lt;/code&gt;</source>
          <target state="translated">CurlSeek 델리게이트 (long, CurlSeekPos) &lt;code&gt;callback&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="37f1460d74729779c053720f8343662b43997475" translate="yes" xml:space="preserve">
          <source>Currency Symbols</source>
          <target state="translated">통화 기호</target>
        </trans-unit>
        <trans-unit id="84f9a40ca51da6b15c30fb2dde0fe4ae3193cebf" translate="yes" xml:space="preserve">
          <source>Currency_Symbol</source>
          <target state="translated">Currency_Symbol</target>
        </trans-unit>
        <trans-unit id="1c51a4dec4b6d066a950991a20e81d7204b847ff" translate="yes" xml:space="preserve">
          <source>Current 'state' of the compiler. Used to gather together most global variables. This struct is saved/restored during function body parsing.</source>
          <target state="translated">컴파일러의 현재 '상태'. 대부분의 전역 변수를 모으는 데 사용됩니다. 이 구조체는 함수 본문 파싱 중에 저장 / 복원됩니다.</target>
        </trans-unit>
        <trans-unit id="8bb5afa66ef9deeeb65948941312b1da2a80f78e" translate="yes" xml:space="preserve">
          <source>Current items are equal; no editing is necessary.</source>
          <target state="translated">현재 품목은 동일합니다. 편집이 필요하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="69802cb8c8d960584abd7b92600c394739df538c" translate="yes" xml:space="preserve">
          <source>Current limitation: Due to &lt;a href=&quot;https://issues.dlang.org/show_bug.cgi?id=11500&quot;&gt;bug #11500&lt;/a&gt;, currently the constructors specified in this mixin cannot be overloaded with any other custom constructors. Thus this mixin can currently only be used when no such custom constructors need to be explicitly specified.</source>
          <target state="translated">현재 제한 사항 : &lt;a href=&quot;https://issues.dlang.org/show_bug.cgi?id=11500&quot;&gt;버그 # 11500&lt;/a&gt; 때문에 현재이 믹스 인에 지정된 생성자는 다른 사용자 지정 생성자로 오버로드 할 수 없습니다. 따라서이 믹스 인은 현재 이러한 사용자 정의 생성자를 명시 적으로 지정할 필요가없는 경우에만 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ce942321383836e436083da3460ea976ea73c9cf" translate="yes" xml:space="preserve">
          <source>Currently nested templates can capture at most one context. As a typical example, non-static template member functions cannot take local symbol by using template alias parameter.</source>
          <target state="translated">현재 중첩 된 템플릿은 최대 하나의 컨텍스트를 캡처 할 수 있습니다. 일반적인 예로 정적이 아닌 템플릿 멤버 함수는 템플릿 별칭 매개 변수를 사용하여 로컬 심볼을 사용할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="ff4623ac05dc3913907977438836d2f3c936fb47" translate="yes" xml:space="preserve">
          <source>Currently only supports UTF documents.  If there is an encoding attribute in the prolog, it is ignored.</source>
          <target state="translated">현재 UTF 문서 만 지원합니다. 프롤로그에 인코딩 속성이 있으면 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="cdb34bac47d9c08061ba96d029fe7cfb9cc5802d" translate="yes" xml:space="preserve">
          <source>Currently only works on x86 and Itanium CPUs. Many processors have bugs in their microcode for the CPUID instruction, so sometimes the cache information may be incorrect.</source>
          <target state="translated">현재 x86 및 Itanium CPU에서만 작동합니다. 많은 프로세서가 CPUID 명령에 대한 마이크로 코드에 버그를 가지고 있으므로 때때로 캐시 정보가 올바르지 않을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="cfc0dbba909b8d801dfd589ff4ce7238fefbfe4c" translate="yes" xml:space="preserve">
          <source>Currently, only FreeBSD/DragonFlyBSD supports a more precise clock, where it uses &lt;code&gt;CLOCK_MONOTONIC_PRECISE&lt;/code&gt; for the monotonic time and &lt;code&gt;CLOCK_REALTIME_PRECISE&lt;/code&gt; for the wall clock time.</source>
          <target state="translated">현재는 FreeBSD / DragonFlyBSD만이보다 정확한 클럭을 지원합니다 . 단조로운 시간 에는 &lt;code&gt;CLOCK_MONOTONIC_PRECISE&lt;/code&gt; 를 사용 하고 &lt;code&gt;CLOCK_REALTIME_PRECISE&lt;/code&gt; 시간에는 CLOCK_REALTIME_PRECISE 를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="959207731027f2760054a49b8e3de46c08dd6bdd" translate="yes" xml:space="preserve">
          <source>Currently, only Linux and FreeBSD/DragonFlyBSD support a coarser clock, and on other platforms, it's treated as &lt;code&gt;ClockType.normal&lt;/code&gt;.</source>
          <target state="translated">현재는 Linux 및 FreeBSD / DragonFlyBSD 만 더 거친 시계를 지원하며 다른 플랫폼에서는 &lt;code&gt;ClockType.normal&lt;/code&gt; 로 처리됩니다 .</target>
        </trans-unit>
        <trans-unit id="dfcc51a98311f46893672f2fb6d173d44d66fc77" translate="yes" xml:space="preserve">
          <source>Custom Page Cache Object</source>
          <target state="translated">맞춤 페이지 캐시 객체</target>
        </trans-unit>
        <trans-unit id="b3fc60eff39cb549b6d9c803b4a451eb43428671" translate="yes" xml:space="preserve">
          <source>Custom predicate for comparison of haystack and needle</source>
          <target state="translated">건초 더미와 바늘의 비교를위한 사용자 정의 술어</target>
        </trans-unit>
        <trans-unit id="c8a592f320e5a686e3807c060bc9b332dcc6b0b4" translate="yes" xml:space="preserve">
          <source>Custom predicate functions.</source>
          <target state="translated">사용자 정의 술어 기능.</target>
        </trans-unit>
        <trans-unit id="bfed9740a3d512ab6d90b0cbc0ffce4c3744006e" translate="yes" xml:space="preserve">
          <source>Custom request, for customizing the get command like</source>
          <target state="translated">다음과 같이 get 명령을 사용자 정의하기위한 사용자 정의 요청</target>
        </trans-unit>
        <trans-unit id="a74881d82849f50f687aa6d7ccfec894be3d7785" translate="yes" xml:space="preserve">
          <source>Customized Base64 encoding schemes can be implemented by instantiating this template with the appropriate arguments. For example:</source>
          <target state="translated">이 인수를 적절한 인수로 인스턴스화하여 사용자 정의 된 Base64 인코딩 체계를 구현할 수 있습니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="5edb9626eb87d040db1eb00c7aa5b2c28b0e6650" translate="yes" xml:space="preserve">
          <source>Cycle!R &lt;strong id=&quot;cycle&quot;&gt;cycle&lt;/strong&gt;(R)(R input, size_t index = 0)</source>
          <target state="translated">사이클! R &lt;strong id=&quot;cycle&quot;&gt;사이클&lt;/strong&gt; (R) (R 입력, size_t 인덱스 = 0)</target>
        </trans-unit>
        <trans-unit id="7d8cafa53ee2c1c0875ad69af202f51945cbe5f0" translate="yes" xml:space="preserve">
          <source>Cycles (circular dependencies) in the import declarations are allowed as long as not both of the modules contain static constructors or static destructors. Violation of this rule will result in a runtime exception.</source>
          <target state="translated">두 모듈 모두 정적 생성자 또는 정적 소멸자를 포함하지 않는 한 가져 오기 선언의 순환 (순환 종속성)이 허용됩니다. 이 규칙을 위반하면 런타임 예외가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="467f7f2e1a32702888fd1652ec31b786fd0b1c0b" translate="yes" xml:space="preserve">
          <source>Cyclic Redundancy Check (32-bit) implementation.</source>
          <target state="translated">주기적 중복 검사 (32 비트) 구현.</target>
        </trans-unit>
        <trans-unit id="36c9c09d1a88bef7e48da22695dc2c7f51367161" translate="yes" xml:space="preserve">
          <source>Cyclic functions (i.e. functions that wind up directly or indirectly calling themselves) are inferred as being impure, throwing, and @system.</source>
          <target state="translated">순환 함수 (즉, 직접 또는 간접적으로 자신을 호출하는 함수)는 불순하고, 던지고, @ 시스템 인 것으로 추론됩니다.</target>
        </trans-unit>
        <trans-unit id="5330ddfa4df379999c1bfc18ba91ec4dcf678d1d" translate="yes" xml:space="preserve">
          <source>Cypriot</source>
          <target state="translated">Cypriot</target>
        </trans-unit>
        <trans-unit id="3f15c59d268026cfd87f29afcccbd986a8b120f6" translate="yes" xml:space="preserve">
          <source>Cypriot Syllabary</source>
          <target state="translated">키프로스 실라 바리</target>
        </trans-unit>
        <trans-unit id="1cb0955565a00adf2d4dd0f3ab0976a162bd4df5" translate="yes" xml:space="preserve">
          <source>Cyrillic</source>
          <target state="translated">Cyrillic</target>
        </trans-unit>
        <trans-unit id="13cb71dbdc01614be3dd0248e4bab527145b3a0c" translate="yes" xml:space="preserve">
          <source>Cyrillic Extended-A</source>
          <target state="translated">키릴 확장 -A</target>
        </trans-unit>
        <trans-unit id="6e19f6b8db26b5f4584e846a958391e34785c75d" translate="yes" xml:space="preserve">
          <source>Cyrillic Extended-B</source>
          <target state="translated">키릴 확장 B</target>
        </trans-unit>
        <trans-unit id="5f096016543cf8648b1e0ba5ebd0cde1cb50f3a2" translate="yes" xml:space="preserve">
          <source>Cyrillic Supplement</source>
          <target state="translated">키릴 보충</target>
        </trans-unit>
        <trans-unit id="50c9e8d5fc98727b4bbc93cf5d64a68db647f04f" translate="yes" xml:space="preserve">
          <source>D</source>
          <target state="translated">D</target>
        </trans-unit>
        <trans-unit id="c075a684f58014ba537d34ff9519af0073d068d0" translate="yes" xml:space="preserve">
          <source>D &lt;code&gt;duration&lt;/code&gt;</source>
          <target state="translated">D &lt;code&gt;duration&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="420ba6fd12e656eed08bc3686d185ed3d67a02db" translate="yes" xml:space="preserve">
          <source>D &lt;code&gt;lhs&lt;/code&gt;</source>
          <target state="translated">D &lt;code&gt;lhs&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="31ddff47ea2df1a65990ec2b6a0572ffb0107b5b" translate="yes" xml:space="preserve">
          <source>D &lt;code&gt;rhs&lt;/code&gt;</source>
          <target state="translated">D &lt;code&gt;rhs&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="df22aa7a42bde4b06895be25544565774c8fe9f9" translate="yes" xml:space="preserve">
          <source>D &lt;code&gt;td&lt;/code&gt;</source>
          <target state="translated">D &lt;code&gt;td&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="6ca85edb97301be7fd1849c8854fbc23b8139193" translate="yes" xml:space="preserve">
          <source>D And C Function Prototype Equivalence</source>
          <target state="translated">D와 C 함수 프로토 타입 동등성</target>
        </trans-unit>
        <trans-unit id="c3dde59eb8e6d6f854408cbe61a4fbfc9b447911" translate="yes" xml:space="preserve">
          <source>D And C Type Equivalence</source>
          <target state="translated">D와 C 유형 동등 물</target>
        </trans-unit>
        <trans-unit id="4959476e34feab4fd79ecd8a71227840715bd031" translate="yes" xml:space="preserve">
          <source>D And C++ Type Equivalence</source>
          <target state="translated">D와 C ++ 타입 동등성</target>
        </trans-unit>
        <trans-unit id="86da087c301b2f798d4ba996b708f1700a968709" translate="yes" xml:space="preserve">
          <source>D Code Formatting Macros</source>
          <target state="translated">D 코드 형식 매크로</target>
        </trans-unit>
        <trans-unit id="d3f23c864026a341662336508bfcf4b56460282f" translate="yes" xml:space="preserve">
          <source>D Grammar</source>
          <target state="translated">D 문법</target>
        </trans-unit>
        <trans-unit id="20fb9b176e61fdbf6fd72a0f9b1c75e432e9363e" translate="yes" xml:space="preserve">
          <source>D Operations That Involve the Garbage Collector</source>
          <target state="translated">가비지 콜렉터와 관련된 D 작업</target>
        </trans-unit>
        <trans-unit id="3b1a6b14130ac212af69f729479639b4f6728d35" translate="yes" xml:space="preserve">
          <source>D accomplishes typesafe linking by</source>
          <target state="translated">D는 다음에 의해 타입 세이프 연결을 달성합니다.</target>
        </trans-unit>
        <trans-unit id="e8bd85138c80a70ce7a94bdf0dbb9e8c049bd318" translate="yes" xml:space="preserve">
          <source>D allows overloading of the comparison operators &lt;code&gt;==&lt;/code&gt;, &lt;code&gt;!=&lt;/code&gt;, &lt;code&gt;&amp;lt;&lt;/code&gt;, &lt;code&gt;&amp;lt;=&lt;/code&gt;, &lt;code&gt;&amp;gt;=&lt;/code&gt;, &lt;code&gt;&amp;gt;&lt;/code&gt; via two functions, &lt;code&gt;opEquals&lt;/code&gt; and &lt;code&gt;opCmp&lt;/code&gt;.</source>
          <target state="translated">D는 비교 연산자 과부하 허용 &lt;code&gt;==&lt;/code&gt; , &lt;code&gt;!=&lt;/code&gt; , &lt;code&gt;&amp;lt;&lt;/code&gt; , &lt;code&gt;&amp;lt;=&lt;/code&gt; , &lt;code&gt;&amp;gt;=&lt;/code&gt; , &lt;code&gt;&amp;gt;&lt;/code&gt; 두 가지 기능을 통해 &lt;code&gt;opEquals&lt;/code&gt; 및 &lt;code&gt;opCmp&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="245c88a0d2db8ba44dd302d346881e4a09782dfc" translate="yes" xml:space="preserve">
          <source>D also provides the mechanisms to write code where the garbage collector is &lt;b&gt;not involved&lt;/b&gt;. More information is provided below.</source>
          <target state="translated">D는 또한 가비지 수집기가 포함 &lt;b&gt;되지 않은&lt;/b&gt; 코드를 작성하는 메커니즘을 제공합니다 . 자세한 내용은 아래에 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="536f3a2ed377e10f64d552c2d73a20c905e02fc9" translate="yes" xml:space="preserve">
          <source>D binding to C++</source>
          <target state="translated">C ++에 대한 D 바인딩</target>
        </trans-unit>
        <trans-unit id="19ddf415c5a9aba3800b9f9389ba5483b40b7a2f" translate="yes" xml:space="preserve">
          <source>D binding to C++ std::allocator.</source>
          <target state="translated">C ++ std :: allocator에 대한 D 바인딩.</target>
        </trans-unit>
        <trans-unit id="31b1546a7311b8038bca2bd20f9fc0ac1391d37a" translate="yes" xml:space="preserve">
          <source>D bindings for standard C headers.</source>
          <target state="translated">표준 C 헤더에 대한 D 바인딩.</target>
        </trans-unit>
        <trans-unit id="40b1be27cbfa93ccf74b6920df5a41be8c48c101" translate="yes" xml:space="preserve">
          <source>D can easily call C callbacks (function pointers), and C can call callbacks provided by D code if the callback is an &lt;code&gt;extern(C)&lt;/code&gt; function, or some other linkage that both sides have agreed to (e.g. &lt;code&gt;extern(Windows)&lt;/code&gt;).</source>
          <target state="translated">D는 C 콜백 (함수 포인터)을 쉽게 호출 할 수 있으며 콜백이 &lt;code&gt;extern(C)&lt;/code&gt; 함수이거나 양측이 동의 한 다른 연결 (예 : &lt;code&gt;extern(Windows)&lt;/code&gt; ) 인 경우 D 코드가 제공하는 콜백을 콜할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="c470394ce7797205adec8b8a502a172295e638c7" translate="yes" xml:space="preserve">
          <source>D can explicitly manage memory using a variety of library tools, such as with &lt;a href=&quot;https://dlang.org/phobos/std_experimental_allocator.html&quot;&gt;&lt;code&gt;std.experimental.allocator&lt;/code&gt;&lt;/a&gt;. Additionally, &lt;code&gt;core.stdc.stdlib.malloc&lt;/code&gt; and &lt;code&gt;core.stdc.stdlib.free&lt;/code&gt; can be used directly for connecting to C++ functions that expect &lt;code&gt;malloc&lt;/code&gt;'d buffers.</source>
          <target state="translated">D는 &lt;a href=&quot;https://dlang.org/phobos/std_experimental_allocator.html&quot;&gt; &lt;code&gt;std.experimental.allocator&lt;/code&gt; &lt;/a&gt; 와 같은 다양한 라이브러리 도구를 사용하여 메모리를 명시 적으로 관리 할 수 ​​있습니다 . 또한 &lt;code&gt;core.stdc.stdlib.malloc&lt;/code&gt; 및 &lt;code&gt;core.stdc.stdlib.free&lt;/code&gt; 는 &lt;code&gt;malloc&lt;/code&gt; 'd 버퍼 가 필요한 C ++ 함수에 연결하는 데 직접 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="5acb9506d75a51ad2e949d226d6eb45b0c67820e" translate="yes" xml:space="preserve">
          <source>D can still explicitly allocate memory using core.stdc.stdlib.malloc() and core.stdc.stdlib.free(), these are useful for connecting to C functions that expect malloc'd buffers, etc.</source>
          <target state="translated">D는 core.stdc.stdlib.malloc () 및 core.stdc.stdlib.free ()를 사용하여 메모리를 명시 적으로 할당 할 수 있습니다. 이들은 malloc의 버퍼 등을 기대하는 C 함수에 연결하는 데 유용합니다.</target>
        </trans-unit>
        <trans-unit id="17e8e7c234c8b135698e2569ad7c740d6032f484" translate="yes" xml:space="preserve">
          <source>D cannot directly call C++ special member functions, and vice versa. These include constructors, destructors, conversion operators, operator overloading, and allocators.</source>
          <target state="translated">D는 C ++ 특수 멤버 함수를 직접 호출 할 수 없으며 그 반대도 마찬가지입니다. 여기에는 생성자, 소멸자, 변환 연산자, 연산자 오버로드 및 할당자가 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="0fb4b87546a27bc737044f6f7e9773793eda6a11" translate="yes" xml:space="preserve">
          <source>D code can be embedded using lines beginning with at least three hyphens &lt;code&gt;-&lt;/code&gt;, backticks &lt;code&gt;`&lt;/code&gt; or tildes &lt;code&gt;~&lt;/code&gt; (ignoring whitespace) to delineate the code section:</source>
          <target state="translated">D 코드는 적어도 세 하이픈으로 시작하는 라인을 사용하여 포함 할 수있다 &lt;code&gt;-&lt;/code&gt; , 역 따옴표 &lt;code&gt;`&lt;/code&gt; 또는 물결표 &lt;code&gt;~&lt;/code&gt; 코드 섹션을 윤곽을 그리다 (무시 공백) :</target>
        </trans-unit>
        <trans-unit id="dcedc4ea27f9fbbf3eaeba264e973e8baac897d0" translate="yes" xml:space="preserve">
          <source>D code gets automatic syntax highlighting. To include code in another language without syntax highlighting, add a language string at the end of the top delimiter line:</source>
          <target state="translated">D 코드는 자동 구문 강조를 가져옵니다. 구문 강조 표시없이 다른 언어로 코드를 포함 시키려면 상단 구분 기호 줄 끝에 언어 문자열을 추가하십시오.</target>
        </trans-unit>
        <trans-unit id="db2576347b92e13d169d9d3a8ec611d68f429441" translate="yes" xml:space="preserve">
          <source>D constrains integral types to specific sizes. But efficiency of different sizes varies from machine to machine, pointer sizes vary, and the maximum integer size varies. &lt;b&gt;stdint&lt;/b&gt; offers a portable way of trading off size vs efficiency, in a manner compatible with the</source>
          <target state="translated">D는 정수 유형을 특정 크기로 제한합니다. 그러나 다른 크기의 효율성은 기계마다 다르고 포인터 크기는 다양하며 최대 정수 크기는 다양합니다. &lt;b&gt;stdint&lt;/b&gt; 는 다음과 호환되는 방식으로 크기와 효율성을 교환 할 수있는 휴대용 방법을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="507bee50e6e5c4a08c20f7a821523744843dab1d" translate="yes" xml:space="preserve">
          <source>D conventions are:</source>
          <target state="translated">D 규칙은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="9a11c2269497647472aad8b1a5fbcb4adc87a952" translate="yes" xml:space="preserve">
          <source>D does not support bit fields. If needed, they can be emulated with shift and mask operations, or use the &lt;a href=&quot;https://dlang.org/phobos/std_bitmanip.html#bitfields&quot;&gt;std.bitmanip.bitfields&lt;/a&gt; library type. &lt;a href=&quot;https://dlang.org/htod.html&quot;&gt;htod&lt;/a&gt; will convert bit fields to inline functions that do the right shift and masks.</source>
          <target state="translated">D는 비트 필드를 지원하지 않습니다. 필요한 경우 시프트 및 마스크 조작으로 에뮬레이트하거나 &lt;a href=&quot;https://dlang.org/phobos/std_bitmanip.html#bitfields&quot;&gt;std.bitmanip.bitfields&lt;/a&gt; 라이브러리 유형을 사용할 수 있습니다 . &lt;a href=&quot;https://dlang.org/htod.html&quot;&gt;htod&lt;/a&gt; 는 비트 필드를 올바른 시프트 및 마스크를 수행하는 인라인 함수로 변환합니다.</target>
        </trans-unit>
        <trans-unit id="10392eddc0ec6cd68606fb4c53a826525a44407e" translate="yes" xml:space="preserve">
          <source>D does not support declaring variables of anonymous struct types. In such a case you can define a named struct in D and make it private:</source>
          <target state="translated">D는 익명 구조체 형식의 변수 선언을 지원하지 않습니다. 이 경우 D에서 명명 된 구조체를 정의하고 비공개로 만들 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b5ed1c9e2e5b85b71f5da5cc74c0dc2f3e444e1a" translate="yes" xml:space="preserve">
          <source>D exception handling fits right in with that.</source>
          <target state="translated">D 예외 처리는 그에 맞습니다.</target>
        </trans-unit>
        <trans-unit id="2996c849bb3b528029f848ec1204d0c07cdcd623" translate="yes" xml:space="preserve">
          <source>D features not available with &lt;b&gt;BetterC&lt;/b&gt;:</source>
          <target state="translated">&lt;b&gt;BetterC&lt;/b&gt; 에서는 사용할 수없는 D 기능 :</target>
        </trans-unit>
        <trans-unit id="883282b9d057cb0d92c679117bdb3b124bb34d24" translate="yes" xml:space="preserve">
          <source>D grammar allows declarations only as statements. However in AST representation it can be part of any expression. This is used, for example, during internal syntax re-writes to inject hidden symbols.</source>
          <target state="translated">D 문법은 선언을 선언문으로 만 허용합니다. 그러나 AST 표현에서는 모든 표현의 일부가 될 수 있습니다. 예를 들어 숨겨진 구문을 삽입하기 위해 내부 구문을 다시 쓰는 동안 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="bff43f4fa297f3c093df3b2ac4a91965cf38a6b0" translate="yes" xml:space="preserve">
          <source>D has reference types, but they are implicit. For example, classes are always referred to by reference; this means that class instances can never reside on the stack or be passed as function parameters.</source>
          <target state="translated">D에는 참조 유형이 있지만 암시 적입니다. 예를 들어, 클래스는 항상 참조로 참조됩니다. 이는 클래스 인스턴스가 스택에 상주하거나 함수 매개 변수로 전달 될 수 없음을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="1b55a6666e706c8c18a3807c207816e092af0934" translate="yes" xml:space="preserve">
          <source>D has some support for interfacing with Objective-C. It supports classes, subclasses, instance variables, instance and class methods. It is only available on macOS, compiling for 64bit.</source>
          <target state="translated">D는 Objective-C와의 인터페이스를 지원합니다. 클래스, 서브 클래스, 인스턴스 변수, 인스턴스 및 클래스 메소드를 지원합니다. 64 비트 용으로 컴파일되는 macOS에서만 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="121b6728c073450cbfd13591bf64f1dacb90a45f" translate="yes" xml:space="preserve">
          <source>D has types that are not represented in existing C or C++ debuggers. These are dynamic arrays, associative arrays, and delegates. Representing these types as structs causes problems because function calling conventions for structs are often different than that for these types, which causes C/C++ debuggers to misrepresent things. For these debuggers, they are represented as a C type which does match the calling conventions for the type. The &lt;b&gt;dmd&lt;/b&gt; compiler will generate only C symbolic type info with the &lt;b&gt;-gc&lt;/b&gt; compiler switch.</source>
          <target state="translated">D에는 기존 C 또는 C ++ 디버거에 표시되지 않은 형식이 있습니다. 이들은 동적 배열, 연관 배열 및 대리자입니다. 구조체에 대한 함수 호출 규칙이 이러한 형식에 대한 함수 호출 규칙과 다르기 때문에 이러한 형식을 구조체로 표시하면 문제가 발생하므로 C / C ++ 디버거가 잘못 표시합니다. 이러한 디버거의 경우 해당 유형의 호출 규칙과 일치하는 C 유형으로 표시됩니다. &lt;b&gt;DMD&lt;/b&gt; 컴파일러는 만 C 상징적 유형의 정보를 생성합니다 &lt;b&gt;-gc&lt;/b&gt; 컴파일러 스위치를.</target>
        </trans-unit>
        <trans-unit id="0d7dc7a95854603cb8d9462f5cc1ad1a152da8c2" translate="yes" xml:space="preserve">
          <source>D header file for C99</source>
          <target state="translated">C99 용 D 헤더 파일</target>
        </trans-unit>
        <trans-unit id="ed764989e25528a9844d96827752e35b6e2e9eea" translate="yes" xml:space="preserve">
          <source>D header file for C99.</source>
          <target state="translated">C99 용 D 헤더 파일</target>
        </trans-unit>
        <trans-unit id="7ad95cc9683672fd46f6a22377da886b23e6e760" translate="yes" xml:space="preserve">
          <source>D header file for interaction with C++ std::array.</source>
          <target state="translated">C ++ std :: array와의 상호 작용을위한 D 헤더 파일</target>
        </trans-unit>
        <trans-unit id="4f35219179c87ed75b46610654f6f3ed6dbd80a3" translate="yes" xml:space="preserve">
          <source>D header file for interaction with C++ std::string.</source>
          <target state="translated">C ++ std :: string과의 상호 작용을위한 D 헤더 파일.</target>
        </trans-unit>
        <trans-unit id="8745691e9f4a9ab07ce82e5bf211832a13541675" translate="yes" xml:space="preserve">
          <source>D header file for interaction with C++ std::string_view.</source>
          <target state="translated">C ++ std :: string_view와의 상호 작용을위한 D 헤더 파일</target>
        </trans-unit>
        <trans-unit id="0fa30a4a6e6e6ac7b257dba8aee80922db2a59d4" translate="yes" xml:space="preserve">
          <source>D header file for interaction with C++ std::type_traits.</source>
          <target state="translated">C ++ std :: type_traits와의 상호 작용을위한 D 헤더 파일.</target>
        </trans-unit>
        <trans-unit id="e89f07a65806c6e223faa5fc9abe0d71cc5e02bb" translate="yes" xml:space="preserve">
          <source>D header file for interaction with C++ std::vector.</source>
          <target state="translated">C ++ std :: vector와의 상호 작용을위한 D 헤더 파일</target>
        </trans-unit>
        <trans-unit id="5824cf94dceeaf8ce80dcdea0f69c87be67a1def" translate="yes" xml:space="preserve">
          <source>D is a general-purpose systems programming language with a C-like syntax that compiles to native code. It is statically typed and supports both automatic (garbage collected) and manual memory management. D programs are structured as modules that can be compiled separately and linked with external libraries to create native libraries or executables.</source>
          <target state="translated">D는 네이티브 코드로 컴파일되는 C와 유사한 구문을 가진 범용 시스템 프로그래밍 언어입니다. 정적으로 입력되며 자동 (가비지 수집) 및 수동 메모리 관리를 모두 지원합니다. D 프로그램은 개별 라이브러리를 컴파일하고 외부 라이브러리와 연결하여 기본 라이브러리 또는 실행 파일을 만들 수있는 모듈로 구성됩니다.</target>
        </trans-unit>
        <trans-unit id="f4523654c6ad41f53f1cb538f5b3376ea8b5d67c" translate="yes" xml:space="preserve">
          <source>D is a systems programming language with support for garbage collection. Usually it is not necessary to free memory explicitly. Just allocate as needed, and the garbage collector will periodically return all unused memory to the pool of available memory.</source>
          <target state="translated">D는 가비지 수집을 지원하는 시스템 프로그래밍 언어입니다. 일반적으로 메모리를 명시 적으로 비울 필요는 없습니다. 필요에 따라 할당하면 가비지 수집기가 사용하지 않는 모든 메모리를 주기적으로 사용 가능한 메모리 풀로 반환합니다.</target>
        </trans-unit>
        <trans-unit id="e55199a6ff4a3d3957959784edcd8f8e4b27511c" translate="yes" xml:space="preserve">
          <source>D is designed to fit comfortably with a C compiler for the target system. D makes up for not having its own VM by relying on the target environment's C runtime library. It would be senseless to attempt to port to D or write D wrappers for the vast array of C APIs available. How much easier it is to just call them directly.</source>
          <target state="translated">D는 대상 시스템을위한 C 컴파일러와 편안하게 맞도록 설계되었습니다. D는 대상 환경의 C 런타임 라이브러리에 의존하여 자체 VM을 갖지 않습니다. 사용 가능한 방대한 C API에 대해 D로 포팅하거나 D 랩퍼를 작성하려고 시도하는 것은 의미가 없습니다. 직접 전화하는 것이 얼마나 쉬운가요?</target>
        </trans-unit>
        <trans-unit id="cc6ee9028bb527b99c9d4c56e23cdd8645b43dac" translate="yes" xml:space="preserve">
          <source>D is statically typed. Every expression has a type. Types constrain the values an expression can hold, and determine the semantics of operations on those values.</source>
          <target state="translated">D는 정적으로 입력됩니다. 모든 표현에는 유형이 있습니다. 유형은 표현식이 보유 할 수있는 값을 제한하고 해당 값에 대한 연산의 의미를 결정합니다.</target>
        </trans-unit>
        <trans-unit id="4cbe911218e52a81c61994de4956c194b77f145c" translate="yes" xml:space="preserve">
          <source>D language counterpart to C++ std::array.</source>
          <target state="translated">C ++ std :: array에 대응하는 D 언어.</target>
        </trans-unit>
        <trans-unit id="d67cb3c014edbba57daff299226c50e7d26383c4" translate="yes" xml:space="preserve">
          <source>D language counterpart to C++ std::basic_string.</source>
          <target state="translated">C ++ std :: basic_string에 대응하는 D 언어.</target>
        </trans-unit>
        <trans-unit id="41ac364d23fcf29b68564ddbcd4409f706b80280" translate="yes" xml:space="preserve">
          <source>D language counterpart to C++ std::basic_string_view.</source>
          <target state="translated">C ++ std :: basic_string_view에 대응하는 D 언어</target>
        </trans-unit>
        <trans-unit id="9d7d4857e53f3903d163814c3fd126b718eac23d" translate="yes" xml:space="preserve">
          <source>D makes this simple. All member initializations must be determinable by the compiler at compile time, hence there is no order-of-evaluation dependency for member initializations, and it is not possible to read a value that has not been initialized. Dynamic initialization is performed by a static constructor, defined with a special syntax &lt;code&gt;static this()&lt;/code&gt;.</source>
          <target state="translated">D는 이것을 간단하게 만듭니다. 모든 멤버 초기화는 컴파일 타임에 컴파일러가 결정할 수 있어야하므로 멤버 초기화에 대한 평가 순서 종속성이 없으며 초기화되지 않은 값을 읽을 수 없습니다. 동적 초기화는 정적 구문 &lt;code&gt;static this()&lt;/code&gt; 정의 된 정적 생성자에 의해 수행됩니다 .</target>
        </trans-unit>
        <trans-unit id="348b41b262e2ee87f7ee9a58be800f10e55e96d7" translate="yes" xml:space="preserve">
          <source>D makes use of the Codeview OEM generic type record indicated by &lt;code&gt;LF_OEM&lt;/code&gt; (0x0015). The format is:</source>
          <target state="translated">D는 &lt;code&gt;LF_OEM&lt;/code&gt; (0x0015)으로 표시되는 Codeview OEM 일반 형식 레코드를 사용 합니다. 형식은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="f05a7b018a28bc978c0088c176ce00074272430c" translate="yes" xml:space="preserve">
          <source>D programs generally require:</source>
          <target state="translated">D 프로그램에는 일반적으로 다음이 필요합니다.</target>
        </trans-unit>
        <trans-unit id="9d19d04a51d14b6f326e1ab50d8689f157419398" translate="yes" xml:space="preserve">
          <source>D provides an easy way to call C functions and operating system API functions, as compatibility with both is essential. The</source>
          <target state="translated">D는 두 기능과의 호환성이 필수적이므로 C 함수와 운영 체제 API 함수를 쉽게 호출 할 수있는 방법을 제공합니다. 그만큼</target>
        </trans-unit>
        <trans-unit id="2b7505970a750559a4a0dcb9c95b55f7ba6c9212" translate="yes" xml:space="preserve">
          <source>D runtime type identification uses completely different techniques than C++. The two are incompatible.</source>
          <target state="translated">D 런타임 유형 식별은 C ++과 완전히 다른 기술을 사용합니다. 둘은 호환되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="2f074b4f5342d38c9e4b97593d5d852288629b0d" translate="yes" xml:space="preserve">
          <source>D structs and classes have different semantics whereas C++ structs and classes are basically the same. The use of a D struct or class depends on the C++ implementation and not on the used C++ keyword. When mapping a D &lt;code&gt;class&lt;/code&gt; onto a C++ &lt;code&gt;struct&lt;/code&gt;, use &lt;code&gt;extern(C++, struct)&lt;/code&gt; to avoid linking problems with C++ compilers (notably MSVC) that distinguish between C++'s &lt;code&gt;class&lt;/code&gt; and &lt;code&gt;struct&lt;/code&gt; when mangling. Conversely, use &lt;code&gt;extern(C++, class)&lt;/code&gt; to map a D &lt;code&gt;struct&lt;/code&gt; onto a C++ &lt;code&gt;class&lt;/code&gt;.</source>
          <target state="translated">D 구조체와 클래스는 서로 다른 의미를 갖지만 C ++ 구조체와 클래스는 기본적으로 동일합니다. D 구조체 또는 클래스의 사용은 사용 된 C ++ 키워드가 아닌 C ++ 구현에 따라 다릅니다. 는 D의 매핑 할 때 &lt;code&gt;class&lt;/code&gt; 는 C ++에 &lt;code&gt;struct&lt;/code&gt; 를 사용 &lt;code&gt;extern(C++, struct)&lt;/code&gt; C ++의 구별 C ++ 컴파일러 (특히 MSVC)에 문제가 연결 방지하기 위해 &lt;code&gt;class&lt;/code&gt; 및 &lt;code&gt;struct&lt;/code&gt; 맹 글링 때를. 반대로 &lt;code&gt;extern(C++, class)&lt;/code&gt; 을 사용하여 D &lt;code&gt;struct&lt;/code&gt; 를 C ++ &lt;code&gt;class&lt;/code&gt; 에 매핑합니다 .</target>
        </trans-unit>
        <trans-unit id="413b9f9ee5f4a33c9e8e2c74310bb7e1520feb22" translate="yes" xml:space="preserve">
          <source>D structs and unions are analogous to C's.</source>
          <target state="translated">D 구조체와 공용체는 C와 유사합니다.</target>
        </trans-unit>
        <trans-unit id="b0e98f6d2eaf06b89533f60085e7a9609ecffc56" translate="yes" xml:space="preserve">
          <source>D style variadic function</source>
          <target state="translated">D 스타일 가변 기능</target>
        </trans-unit>
        <trans-unit id="c9234fe1a36dd900caaf3d14d414557e453441fe" translate="yes" xml:space="preserve">
          <source>D supports bitfields in the standard library: see &lt;a href=&quot;https://dlang.org/phobos/std_bitmanip.html#bitfields&quot;&gt;&lt;code&gt;std.bitmanip.bitfields&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">D는 표준 라이브러리에서 비트 필드를 지원합니다 ( &lt;a href=&quot;https://dlang.org/phobos/std_bitmanip.html#bitfields&quot;&gt; &lt;code&gt;std.bitmanip.bitfields&lt;/code&gt; &lt;/a&gt; 참조) .</target>
        </trans-unit>
        <trans-unit id="0a3e7acb063a730b948300d255921be3f44a2bd6" translate="yes" xml:space="preserve">
          <source>D symbol identifiers to source representation.</source>
          <target state="translated">소스 표현에 대한 D 심볼 식별자.</target>
        </trans-unit>
        <trans-unit id="63b2085b5ee886bb893b17cc3825c3a7bac6abcc" translate="yes" xml:space="preserve">
          <source>D takes a pragmatic approach that assumes a couple modest accommodations can solve a significant chunk of the problem:</source>
          <target state="translated">D는 몇 가지 겸손한 편의가 심각한 문제를 해결할 수 있다고 가정하는 실용적인 접근 방식을 취합니다.</target>
        </trans-unit>
        <trans-unit id="076ea0cddc7cd8818920bc029904f93dd150a22a" translate="yes" xml:space="preserve">
          <source>D understands how C function names are &quot;mangled&quot; and the correct C function call/return sequence.</source>
          <target state="translated">D는 C 함수 이름이 어떻게 &quot;혼합&quot;되고 올바른 C 함수 호출 / 반환 순서를 이해합니다.</target>
        </trans-unit>
        <trans-unit id="bfdb702abc09e4bf6af6f33ee84d8a6561bdb436" translate="yes" xml:space="preserve">
          <source>D understands how C++ function names are &quot;mangled&quot; and the correct C++ function call/return sequence.</source>
          <target state="translated">D는 C ++ 함수 이름이 어떻게 &quot;혼합&quot;되고 올바른 C ++ 함수 호출 / 반환 순서를 이해합니다.</target>
        </trans-unit>
        <trans-unit id="f2ca0b27fd611ef015ce14be30794acd4f9a7076" translate="yes" xml:space="preserve">
          <source>D x86 Inline Assembler</source>
          <target state="translated">D x86 인라인 어셈블러</target>
        </trans-unit>
        <trans-unit id="5cdfa72ceece084d32cc919a274b9cba8fcd894f" translate="yes" xml:space="preserve">
          <source>D's allocators have a layered structure in both implementation and documentation:</source>
          <target state="translated">D의 할당자는 구현과 문서 모두에서 계층 구조를 갖습니다.</target>
        </trans-unit>
        <trans-unit id="6829dc591dc54cea15edb61fe39f95e34f7f3982" translate="yes" xml:space="preserve">
          <source>D's built-in garbage-collected allocator.</source>
          <target state="translated">D의 내장 가비지 수집 할당 자.</target>
        </trans-unit>
        <trans-unit id="b8187ee85e129e1f90db421cc9a29c74c3da265a" translate="yes" xml:space="preserve">
          <source>D's goals for embedded documentation are:</source>
          <target state="translated">임베디드 문서에 대한 D의 목표는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="40a87633288b39dd560b9503d0951d9deec4c501" translate="yes" xml:space="preserve">
          <source>D, being a systems programming language, provides an inline assembler. The inline assembler is standardized for D implementations across the same CPU family, for example, the Intel Pentium inline assembler for a Win32 D compiler will be syntax compatible with the inline assembler for Linux running on an Intel Pentium.</source>
          <target state="translated">시스템 프로그래밍 언어 인 D는 인라인 어셈블러를 제공합니다. 인라인 어셈블러는 동일한 CPU 제품군에서 D 구현에 대해 표준화되어 있습니다. 예를 들어 Win32 D 컴파일러 용 인텔 펜티엄 인라인 어셈블러는 인텔 펜티엄에서 실행되는 Linux 용 인라인 어셈블러와 구문 호환됩니다.</target>
        </trans-unit>
        <trans-unit id="f121662d3ed579c4262cd8ee742f37a867894743" translate="yes" xml:space="preserve">
          <source>D-style Variadic Functions</source>
          <target state="translated">D 스타일 가변 기능</target>
        </trans-unit>
        <trans-unit id="85f3cd4f9bad02d84690368f648e490c0fb00c1d" translate="yes" xml:space="preserve">
          <source>D-style variadic functions cannot be marked as &lt;code&gt;@safe&lt;/code&gt;.</source>
          <target state="translated">D 스타일의 가변 함수는 &lt;code&gt;@safe&lt;/code&gt; 로 표시 할 수 없습니다 .</target>
        </trans-unit>
        <trans-unit id="1ff8c600ebb573fe27a75c1d69933fce59916bff" translate="yes" xml:space="preserve">
          <source>D.NET</source>
          <target state="translated">D.NET</target>
        </trans-unit>
        <trans-unit id="32d5e09780df47e67febb678521d8abe246ef7f3" translate="yes" xml:space="preserve">
          <source>D1 style operator overloading</source>
          <target state="translated">D1 스타일 연산자 과부하</target>
        </trans-unit>
        <trans-unit id="6e915cae90d2c29f2358559dc05c3df58595f55d" translate="yes" xml:space="preserve">
          <source>DATETIME</source>
          <target state="translated">DATETIME</target>
        </trans-unit>
        <trans-unit id="1814daa949d9be12578d550487601b3ffb0f3294" translate="yes" xml:space="preserve">
          <source>DCatchBlock</source>
          <target state="translated">DCatchBlock</target>
        </trans-unit>
        <trans-unit id="c35aab27f1f16d077844d1e2e843f5ad7a4d74b4" translate="yes" xml:space="preserve">
          <source>DCatchInfo</source>
          <target state="translated">DCatchInfo</target>
        </trans-unit>
        <trans-unit id="149aac94bd27b95bb54c837312e06b3ff1e01797" translate="yes" xml:space="preserve">
          <source>DELETE, TRACE and others</source>
          <target state="translated">삭제, 추적 및 기타</target>
        </trans-unit>
        <trans-unit id="ed03c1e6eea87bb52507c25ade7ebb2cf71c59b0" translate="yes" xml:space="preserve">
          <source>DEPRECATED: Use &lt;a href=&quot;#reverseArgs&quot;&gt;&lt;code&gt;reverseArgs&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">더 이상 사용되지 않음 : &lt;a href=&quot;#reverseArgs&quot;&gt; &lt;code&gt;reverseArgs&lt;/code&gt; &lt;/a&gt; 사용</target>
        </trans-unit>
        <trans-unit id="5684aeb3ce6e6bbccefbe8970e6bd7ea5a037735" translate="yes" xml:space="preserve">
          <source>DF &lt;code&gt;f&lt;/code&gt;</source>
          <target state="translated">DF &lt;code&gt;f&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="c26f4629698733a6034fa75e0b7268c2d40e6d7a" translate="yes" xml:space="preserve">
          <source>DG &lt;code&gt;sink&lt;/code&gt;</source>
          <target state="translated">DG &lt;code&gt;sink&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="fea0a308507e8c0ea8d5406ec3aa47072ac89917" translate="yes" xml:space="preserve">
          <source>DHandlerInfo</source>
          <target state="translated">DHandlerInfo</target>
        </trans-unit>
        <trans-unit id="8ac04a874fab478591710648015b2cab5ac04e7a" translate="yes" xml:space="preserve">
          <source>DHandlerTable</source>
          <target state="translated">DHandlerTable</target>
        </trans-unit>
        <trans-unit id="281b3e844c7c9ebd0f0700420e0eca42f1c07f3d" translate="yes" xml:space="preserve">
          <source>DList &lt;strong id=&quot;opBinary&quot;&gt;opBinary&lt;/strong&gt;(string op, Stuff)(Stuff rhs)</source>
          <target state="translated">DList &lt;strong id=&quot;opBinary&quot;&gt;opBinary&lt;/strong&gt; (스트링 op, Stuff) (Stuff rhs)</target>
        </trans-unit>
        <trans-unit id="db5bf0255282647c454fa59e6c8c5eb7735233ea" translate="yes" xml:space="preserve">
          <source>DList &lt;strong id=&quot;opBinaryRight&quot;&gt;opBinaryRight&lt;/strong&gt;(string op, Stuff)(Stuff lhs)</source>
          <target state="translated">DList &lt;strong id=&quot;opBinaryRight&quot;&gt;opBinaryRight&lt;/strong&gt; (문자열 op, 항목) (Stuff lhs)</target>
        </trans-unit>
        <trans-unit id="25c0b6803c5bf3452395c58abf6779ae685c3351" translate="yes" xml:space="preserve">
          <source>DList &lt;strong id=&quot;opOpAssign&quot;&gt;opOpAssign&lt;/strong&gt;(string op, Stuff)(Stuff rhs)</source>
          <target state="translated">DList &lt;strong id=&quot;opOpAssign&quot;&gt;opOpAssign&lt;/strong&gt; (문자열 op, 항목) (Stuff rhs)</target>
        </trans-unit>
        <trans-unit id="73220b6fc86e8444477fc3e4a8f1ac57ede8ba51" translate="yes" xml:space="preserve">
          <source>DMD (Digital Mars D) is the compiler</source>
          <target state="translated">DMD (Digital Mars D)는 컴파일러입니다</target>
        </trans-unit>
        <trans-unit id="2252ec1f6791e8118b0737f8262fe59003241113" translate="yes" xml:space="preserve">
          <source>DMD's entry point, C main.</source>
          <target state="translated">DMD의 진입 점, C main.</target>
        </trans-unit>
        <trans-unit id="20cf49a295826203fca48874eadc25984298220f" translate="yes" xml:space="preserve">
          <source>DMD-generated module &lt;code&gt;__entrypoint&lt;/code&gt; where the C main resides</source>
          <target state="translated">C main이 상주하는 DMD 생성 모듈 &lt;code&gt;__entrypoint&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="a40af10594b1fe393f992683f992876e5b82c830" translate="yes" xml:space="preserve">
          <source>DNS cache timeout</source>
          <target state="translated">DNS 캐시 시간 초과</target>
        </trans-unit>
        <trans-unit id="839b4d242b27d4e00dc0979927fcbe8223225c0f" translate="yes" xml:space="preserve">
          <source>DNS lookup timeout.</source>
          <target state="translated">DNS 조회 시간 초과.</target>
        </trans-unit>
        <trans-unit id="05360ae598da60f4c6ea48e2bd59a360ad627b22" translate="yes" xml:space="preserve">
          <source>DOCFILENAME</source>
          <target state="translated">DOCFILENAME</target>
        </trans-unit>
        <trans-unit id="527d9c071bb7a8c959e3b30d96d47f285f9bf286" translate="yes" xml:space="preserve">
          <source>DT &lt;code&gt;tolerance&lt;/code&gt;</source>
          <target state="translated">DT &lt;code&gt;tolerance&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="24942523bd10801ae5b643487a7c28eba38f21f5" translate="yes" xml:space="preserve">
          <source>Dash</source>
          <target state="translated">Dash</target>
        </trans-unit>
        <trans-unit id="876c81de0c2e26d99cf08d9a14af93e711b19f5c" translate="yes" xml:space="preserve">
          <source>Dash_Punctuation</source>
          <target state="translated">Dash_Punctuation</target>
        </trans-unit>
        <trans-unit id="f4ad2706fa87a802352efdbb422cb64dbe61c91c" translate="yes" xml:space="preserve">
          <source>Data &lt;code&gt;data&lt;/code&gt;</source>
          <target state="translated">데이터 &lt;code&gt;data&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="352953a16a74f0790135416ee3270f630371240c" translate="yes" xml:space="preserve">
          <source>Data Change Notification Callbacks</source>
          <target state="translated">데이터 변경 알림 콜백</target>
        </trans-unit>
        <trans-unit id="df6ebe7969c4d5202b832d782941362c6e0cae9d" translate="yes" xml:space="preserve">
          <source>Data Type Compatibility</source>
          <target state="translated">데이터 타입 호환성</target>
        </trans-unit>
        <trans-unit id="300eccfd0c54c3aa5cc0df22eac803dbe88630e3" translate="yes" xml:space="preserve">
          <source>Data definitions DTibytes 1..7 bytes DTabytes offset of bytes of data a { a data bytes } DTnbytes bytes of data a { a data bytes } a = offset DTazeros # of 0 bytes a DTsymsize same as DTazeros, but the type of the symbol gives the size DTcommon # of 0 bytes (in a common block) a DTxoff offset from symbol w a w = symbol number (pointer for CPP) a = offset DTcoff offset into code segment</source>
          <target state="translated">데이터 정의 DTibytes 1..7 bytes DTabytes 바이트의 데이터 오프셋 a {data bytes} DTnbytes 바이트의 데이터 a {a data bytes} a = offset DTazeros # 0의 바이트 DTazeros와 동일한 DTsymsize이지만 기호의 유형 코드 커먼으로의 코드 waw = 심볼 번호 (CPP에 대한 포인터)로부터 DTxoff 오프셋을 0 바이트 (공통 블록으로)의 DTxoff 오프셋에 제공 a = 오프셋 DTcoff 오프셋</target>
        </trans-unit>
        <trans-unit id="5938adc1e4b8fc6c4fa6aeefb38d094858c6ba03" translate="yes" xml:space="preserve">
          <source>Data for a class declaration that is needed for the Objective-C integration.</source>
          <target state="translated">Objective-C 통합에 필요한 클래스 선언에 대한 데이터입니다.</target>
        </trans-unit>
        <trans-unit id="6a01abb210c956c2e12e9ccb27efc6f5697b4642" translate="yes" xml:space="preserve">
          <source>Data is shared across threads and the affix follows suit.</source>
          <target state="translated">데이터는 여러 스레드에서 공유되며 접두사가 적합합니다.</target>
        </trans-unit>
        <trans-unit id="775e1e628cf251b049c3fa9bfe1977a634c74e05" translate="yes" xml:space="preserve">
          <source>Data is written to one end of the pipe and read from the other.</source>
          <target state="translated">데이터는 파이프의 한쪽 끝에 쓰여지고 다른 쪽 끝에서 읽습니다.</target>
        </trans-unit>
        <trans-unit id="b510f83fb9e39f1a10ce10e2dd7b90e9a99c4178" translate="yes" xml:space="preserve">
          <source>Data link escape</source>
          <target state="translated">데이터 링크 이스케이프</target>
        </trans-unit>
        <trans-unit id="09d7927bd586a435c13e162ffd8e2037761ee143" translate="yes" xml:space="preserve">
          <source>Data may be placed into a table. Tables consist of a single header row, a delimiter row, and zero or more data rows. Cells in each row are separated by pipe (&lt;code&gt;|&lt;/code&gt;) characters. Initial and trailing &lt;code&gt;|&lt;/code&gt;'s are optional. The number of cells in the delimiter row must match the number of cells in the header row:</source>
          <target state="translated">데이터는 테이블에 배치 될 수 있습니다. 테이블은 단일 헤더 행, 구분자 행 및 0 개 이상의 데이터 행으로 구성됩니다. 각 행의 셀은 파이프 ( &lt;code&gt;|&lt;/code&gt; ) 문자 로 구분됩니다 . 초기 및 후행 &lt;code&gt;|&lt;/code&gt; 는 선택 사항입니다. 구분자 행의 셀 수는 헤더 행의 셀 수와 일치해야합니다.</target>
        </trans-unit>
        <trans-unit id="b20bde9629e5c99004ca74941e9b23c3a1df877c" translate="yes" xml:space="preserve">
          <source>Data passed to the progress callback</source>
          <target state="translated">진행 콜백으로 전달 된 데이터</target>
        </trans-unit>
        <trans-unit id="cc3e0536ab13aed2fb72da353c6d1b107881a065" translate="yes" xml:space="preserve">
          <source>Data pulled from input before finding a problem</source>
          <target state="translated">문제를 발견하기 전에 입력에서 가져온 데이터</target>
        </trans-unit>
        <trans-unit id="a46a83973f1d5005a51cff8503ad3554d15739dd" translate="yes" xml:space="preserve">
          <source>Data that will never change its value can be typed as immutable. The immutable keyword can be used as a</source>
          <target state="translated">값을 변경하지 않는 데이터는 변경 불가능한 것으로 입력 할 수 있습니다. 변경 불가능한 키워드는</target>
        </trans-unit>
        <trans-unit id="bd76809af8087d8bf86bccfefc1fce2214a3765e" translate="yes" xml:space="preserve">
          <source>Data to HTTP Post</source>
          <target state="translated">데이터를 HTTP 포스트로</target>
        </trans-unit>
        <trans-unit id="0be170abfdf228097d8fd04a092e2e686eb56209" translate="yes" xml:space="preserve">
          <source>Data to be swapped with &lt;code&gt;lhs&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;lhs&lt;/code&gt; 로 교체 할 데이터 .</target>
        </trans-unit>
        <trans-unit id="e4c961498463f7e0d6c406d9c8008486428ab14e" translate="yes" xml:space="preserve">
          <source>Data to be swapped with &lt;code&gt;rhs&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;rhs&lt;/code&gt; 와 교체 될 데이터 .</target>
        </trans-unit>
        <trans-unit id="0c3a807b2afb3a1c7be0e9b4ae52d8810bae9911" translate="yes" xml:space="preserve">
          <source>Data to copy.</source>
          <target state="translated">복사 할 데이터.</target>
        </trans-unit>
        <trans-unit id="1dfd2ee1303ec46c31262cfa19e2f7fb06dc1a8b" translate="yes" xml:space="preserve">
          <source>Data to post.</source>
          <target state="translated">게시 할 데이터입니다.</target>
        </trans-unit>
        <trans-unit id="797bc05b357305e1932e73a7d36b5c5d9e636a5c" translate="yes" xml:space="preserve">
          <source>Data type definition of curl_off_t.</source>
          <target state="translated">curl_off_t의 데이터 유형 정의.</target>
        </trans-unit>
        <trans-unit id="805e631b2c4331634631ab9d3d378e6f37ae988c" translate="yes" xml:space="preserve">
          <source>Data type mismatch</source>
          <target state="translated">데이터 타입 불일치</target>
        </trans-unit>
        <trans-unit id="87ad120a4ba60c79863260e10eca7015248baadd" translate="yes" xml:space="preserve">
          <source>Database Connection For Functions</source>
          <target state="translated">함수를위한 데이터베이스 연결</target>
        </trans-unit>
        <trans-unit id="f77d22fb96d5dfa5073b2fe8ffcf8caa0f1f055f" translate="yes" xml:space="preserve">
          <source>Database Connection Handle</source>
          <target state="translated">데이터베이스 연결 핸들</target>
        </trans-unit>
        <trans-unit id="ed913bb076648fca64b8de1c707bbce02bda0945" translate="yes" xml:space="preserve">
          <source>Database Connection Status</source>
          <target state="translated">데이터베이스 연결 상태</target>
        </trans-unit>
        <trans-unit id="74cbb2ae7b134d31108d39d85d470240bf8ec748" translate="yes" xml:space="preserve">
          <source>Database Name NULL</source>
          <target state="translated">데이터베이스 이름 NULL</target>
        </trans-unit>
        <trans-unit id="9c74d7c4589947e1f0611e10551aa7c9e1f5efa2" translate="yes" xml:space="preserve">
          <source>Database Name Table Name</source>
          <target state="translated">데이터베이스 이름 테이블 이름</target>
        </trans-unit>
        <trans-unit id="08868372fcc6df03923ff0a62b6740aab4b59a1d" translate="yes" xml:space="preserve">
          <source>Database lock protocol error</source>
          <target state="translated">데이터베이스 잠금 프로토콜 오류</target>
        </trans-unit>
        <trans-unit id="eb9a4bc1c0c153e4e4b042a79113b815b7e3021d" translate="yes" xml:space="preserve">
          <source>Date</source>
          <target state="translated">Date</target>
        </trans-unit>
        <trans-unit id="e41c9dca2333fa788b5cf30714ffc607513d2701" translate="yes" xml:space="preserve">
          <source>Date &lt;code&gt;date&lt;/code&gt;</source>
          <target state="translated">날짜 &lt;code&gt;date&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="30ef0df6fd820e100e2b862329873127bc101367" translate="yes" xml:space="preserve">
          <source>Date &lt;code&gt;rhs&lt;/code&gt;</source>
          <target state="translated">날짜 &lt;code&gt;rhs&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="0992381fbd2ed819a8d85ebd8c5f3c4e046a291c" translate="yes" xml:space="preserve">
          <source>Date checking</source>
          <target state="translated">날짜 확인</target>
        </trans-unit>
        <trans-unit id="f9a570306f04512676b4ec99a692b20b053ab81b" translate="yes" xml:space="preserve">
          <source>Date conversion</source>
          <target state="translated">날짜 변환</target>
        </trans-unit>
        <trans-unit id="f1e5baf5ecc3589631088c40cbdd43061976ed8f" translate="yes" xml:space="preserve">
          <source>DateTime</source>
          <target state="translated">DateTime</target>
        </trans-unit>
        <trans-unit id="7bd0a645e83d6293f2ac658ba2c541a128f65160" translate="yes" xml:space="preserve">
          <source>DateTime &lt;code&gt;dateTime&lt;/code&gt;</source>
          <target state="translated">DateTime &lt;code&gt;dateTime&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="50c465a7e603d7f34f3bc92280dabffaa722ae0b" translate="yes" xml:space="preserve">
          <source>DateTime &lt;code&gt;rhs&lt;/code&gt;</source>
          <target state="translated">DateTime &lt;code&gt;rhs&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="102540d9bb31a7bb0220b673237b8d10f7c7275f" translate="yes" xml:space="preserve">
          <source>David Simcha</source>
          <target state="translated">데이비드 심차</target>
        </trans-unit>
        <trans-unit id="23c1a4a564924c404275ccc90f9032d7bc610cd3" translate="yes" xml:space="preserve">
          <source>Day of a Gregorian Month.</source>
          <target state="translated">그레고리력의 달.</target>
        </trans-unit>
        <trans-unit id="232f188c18baa6ec73f240c2283edac2e895ead4" translate="yes" xml:space="preserve">
          <source>Day of the month.</source>
          <target state="translated">달의 일.</target>
        </trans-unit>
        <trans-unit id="626768dfcc6b9633ecc6a7e7e7bf8195db816514" translate="yes" xml:space="preserve">
          <source>Day of the week this &lt;a href=&quot;#Date&quot;&gt;&lt;code&gt;Date&lt;/code&gt;&lt;/a&gt; is on.</source>
          <target state="translated">일주일이의 날 &lt;a href=&quot;#Date&quot;&gt; &lt;code&gt;Date&lt;/code&gt; &lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="c331185171d5b8b397558aeeba86ec31a95daba4" translate="yes" xml:space="preserve">
          <source>Day of the week this &lt;a href=&quot;#DateTime&quot;&gt;&lt;code&gt;DateTime&lt;/code&gt;&lt;/a&gt; is on.</source>
          <target state="translated">이 &lt;a href=&quot;#DateTime&quot;&gt; &lt;code&gt;DateTime&lt;/code&gt; &lt;/a&gt; 요일 이 입니다.</target>
        </trans-unit>
        <trans-unit id="88e734266606869df957a7c0f140482b5dc9240d" translate="yes" xml:space="preserve">
          <source>Day of the week this &lt;a href=&quot;#SysTime&quot;&gt;&lt;code&gt;SysTime&lt;/code&gt;&lt;/a&gt; is on.</source>
          <target state="translated">이 &lt;a href=&quot;#SysTime&quot;&gt; &lt;code&gt;SysTime&lt;/code&gt; 요일&lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="5adf2e7dce3355a8b43b9e02348a4d264604444a" translate="yes" xml:space="preserve">
          <source>Day of the year this &lt;a href=&quot;#Date&quot;&gt;&lt;code&gt;Date&lt;/code&gt;&lt;/a&gt; is on.</source>
          <target state="translated">이 &lt;a href=&quot;#Date&quot;&gt; &lt;code&gt;Date&lt;/code&gt; &lt;/a&gt; 요일 가 입니다.</target>
        </trans-unit>
        <trans-unit id="d8cf70c5944db45b0744da7bbc738777a7ad789e" translate="yes" xml:space="preserve">
          <source>Day of the year this &lt;a href=&quot;#DateTime&quot;&gt;&lt;code&gt;DateTime&lt;/code&gt;&lt;/a&gt; is on.</source>
          <target state="translated">이 &lt;a href=&quot;#DateTime&quot;&gt; &lt;code&gt;DateTime&lt;/code&gt; &lt;/a&gt; 의 연도 이 입니다.</target>
        </trans-unit>
        <trans-unit id="f9c83570b5900ee02a21939abef960bd71f7ebe0" translate="yes" xml:space="preserve">
          <source>Day of the year this &lt;a href=&quot;#SysTime&quot;&gt;&lt;code&gt;SysTime&lt;/code&gt;&lt;/a&gt; is on.</source>
          <target state="translated">이 &lt;a href=&quot;#SysTime&quot;&gt; &lt;code&gt;SysTime&lt;/code&gt; 의 일&lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="9d217acf15d9c91018c040a87e1a6703ff4783db" translate="yes" xml:space="preserve">
          <source>Day of the year.</source>
          <target state="translated">올해의 날.</target>
        </trans-unit>
        <trans-unit id="5556bda98087587c3fd3795ebf53b124789c5586" translate="yes" xml:space="preserve">
          <source>DayOfWeek &lt;code&gt;currDoW&lt;/code&gt;</source>
          <target state="translated">DayOfWeek &lt;code&gt;currDoW&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="f233ca1cd32606c49e90bb687b290b377c3fa09c" translate="yes" xml:space="preserve">
          <source>DayOfWeek &lt;code&gt;dayOfWeek&lt;/code&gt;</source>
          <target state="translated">DayOfWeek &lt;code&gt;dayOfWeek&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="fe0c0bef273fca4c1fc04dfe682d2fed5f5b8c28" translate="yes" xml:space="preserve">
          <source>DayOfWeek &lt;code&gt;dow&lt;/code&gt;</source>
          <target state="translated">DayOfWeek &lt;code&gt;dow&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="8064b01fec4de1e986ae9989edb52515cfd892bb" translate="yes" xml:space="preserve">
          <source>Daylight Savings Time flag</source>
          <target state="translated">일광 절약 시간제 플래그</target>
        </trans-unit>
        <trans-unit id="86ccd9040e164f6b31eff441e1b4ddc44e72847d" translate="yes" xml:space="preserve">
          <source>Ddoc Section Formatting Macros</source>
          <target state="translated">Ddoc 섹션 서식 매크로</target>
        </trans-unit>
        <trans-unit id="6ac46f279a1fa0133478a64489b3104466715043" translate="yes" xml:space="preserve">
          <source>Ddoc can automatically generate usage examples for declarations using unit tests. If a declaration is followed by a documented unit test, the code from the test will be inserted into the example section of the declaration. This avoids the frequent problem of having outdated documentation for pieces of code.</source>
          <target state="translated">Ddoc은 단위 테스트를 사용하여 선언의 사용 예제를 자동으로 생성 할 수 있습니다. 선언에 문서화 된 단위 테스트가 뒤 따르면 테스트 코드가 선언의 예제 섹션에 삽입됩니다. 이렇게하면 코드 조각에 대한 오래된 문서가 자주 발생하는 문제를 피할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c18b6736ff9c9b5405dba716c1075e7224dff8e0" translate="yes" xml:space="preserve">
          <source>Ddoc does not generate HTML code. It formats into the basic formatting macros, which (in their predefined form) are then expanded into HTML. If output other than HTML is desired, then these macros need to be redefined.</source>
          <target state="translated">Ddoc은 HTML 코드를 생성하지 않습니다. 기본 형식 매크로로 형식을 지정한 다음 사전 정의 된 형식으로 HTML로 확장됩니다. HTML 이외의 출력이 필요한 경우 이러한 매크로를 다시 정의해야합니다.</target>
        </trans-unit>
        <trans-unit id="e9840b40bb80bed37d395f716bc6b09d4d6c01d5" translate="yes" xml:space="preserve">
          <source>Ddoc is primarily designed for use in producing documentation from embedded comments. It can also, however, be used for processing other general documentation. The reason for doing this would be to take advantage of the macro capability of Ddoc and the D code syntax highlighting capability.</source>
          <target state="translated">Ddoc은 주로 포함 된 주석에서 문서를 작성하는 데 사용하도록 설계되었습니다. 그러나 다른 일반 문서를 처리하는 데에도 사용할 수 있습니다. 이를 수행하는 이유는 Ddoc의 매크로 기능과 D 코드 구문 강조 기능을 활용하기 위함입니다.</target>
        </trans-unit>
        <trans-unit id="1fb7c1687832d0818c78d9fb05c4ecb341d15249" translate="yes" xml:space="preserve">
          <source>Deallocates &lt;code&gt;b&lt;/code&gt;, which is assumed to have been previously allocated with this allocator. Deallocation performs a linear search in the free list to preserve its sorting order. It follows that blocks with higher addresses in allocators with many free blocks are slower to deallocate.</source>
          <target state="translated">&lt;code&gt;b&lt;/code&gt; 를 할당 해제이전에이 할당 자로 할당 된 것으로 가정되는 합니다. 할당 해제는 사용 가능한 목록에서 선형 검색을 수행하여 정렬 순서를 유지합니다. 사용 가능한 블록이 많은 할당 자에서 주소가 높은 블록은 할당 취소 속도가 느립니다.</target>
        </trans-unit>
        <trans-unit id="3d01931f745782a57d8fca7493bd853c4a9ddce7" translate="yes" xml:space="preserve">
          <source>Deallocates &lt;code&gt;b&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;b&lt;/code&gt; 를 할당 해제 합니다.</target>
        </trans-unit>
        <trans-unit id="e7fadc0e35dabce1bf9846c81d69446d932164cd" translate="yes" xml:space="preserve">
          <source>Deallocates &lt;code&gt;b&lt;/code&gt;. If it's of eligible size, it's put on the free list. Otherwise, it's returned to &lt;code&gt;parent&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;b&lt;/code&gt; 를 할당 해제 합니다. 적합한 크기이면 무료 목록에 추가됩니다. 그렇지 않으면 &lt;code&gt;parent&lt;/code&gt; 로 반환됩니다 .</target>
        </trans-unit>
        <trans-unit id="4dedb91c6fcf841105df2821d7153a890b807f6b" translate="yes" xml:space="preserve">
          <source>Deallocates &lt;code&gt;b&lt;/code&gt;. This works only if &lt;code&gt;b&lt;/code&gt; was obtained as the last call to &lt;code&gt;allocate&lt;/code&gt;; otherwise (i.e. another allocation has occurred since) it does nothing.</source>
          <target state="translated">&lt;code&gt;b&lt;/code&gt; 를 할당 해제 합니다. 이것은 마지막 &lt;code&gt;allocate&lt;/code&gt; 호출로 &lt;code&gt;b&lt;/code&gt; 를 얻은 경우에만 작동합니다 . 그렇지 않으면 (즉, 다른 할당이 발생한 이후) 아무 것도 수행하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="81959fcf2b1407376d1d5051d3ba64c2b39ce9b1" translate="yes" xml:space="preserve">
          <source>Deallocates &lt;code&gt;b&lt;/code&gt;. This works only if &lt;code&gt;b&lt;/code&gt; was obtained as the last call to &lt;code&gt;allocate&lt;/code&gt;; otherwise (i.e. another allocation has occurred since) it does nothing. This semantics is tricky and therefore &lt;code&gt;deallocate&lt;/code&gt; is defined only if &lt;code&gt;Region&lt;/code&gt; is instantiated with &lt;code&gt;Yes.defineDeallocate&lt;/code&gt; as the third template argument.</source>
          <target state="translated">&lt;code&gt;b&lt;/code&gt; 를 할당 해제 합니다. 이것은 마지막 &lt;code&gt;allocate&lt;/code&gt; 호출로 &lt;code&gt;b&lt;/code&gt; 를 얻은 경우에만 작동합니다 . 그렇지 않으면 (즉, 다른 할당이 이후에 발생) 아무것도하지 않습니다. 이 의미는 까다로운이므로 &lt;code&gt;deallocate&lt;/code&gt; 경우에만 정의 된 &lt;code&gt;Region&lt;/code&gt; 인스턴스화됩니다 &lt;code&gt;Yes.defineDeallocate&lt;/code&gt; 세 번째 템플릿 인수 로 .</target>
        </trans-unit>
        <trans-unit id="00417f5823644f33bf5edec704252ae474e90607" translate="yes" xml:space="preserve">
          <source>Deallocates a block previously allocated with this allocator.</source>
          <target state="translated">이 할당기로 이전에 할당 된 블록을 할당 해제합니다.</target>
        </trans-unit>
        <trans-unit id="e60dbe0f533b075afd615147044f432f563e90fc" translate="yes" xml:space="preserve">
          <source>Deallocates a memory block. Implementations that don't support this primitive should always return &lt;code&gt;false&lt;/code&gt;. A simple way to check that an allocator supports deallocation is to call &lt;code&gt;deallocate(null)&lt;/code&gt;.</source>
          <target state="translated">메모리 블록을 할당 해제합니다. 이 프리미티브를 지원하지 않는 구현은 항상 &lt;code&gt;false&lt;/code&gt; 를 반환해야합니다 . 할당자가 할당 해제를 지원하는지 확인하는 간단한 방법은 &lt;code&gt;deallocate(null)&lt;/code&gt; 을 호출하는 것 입니다.</target>
        </trans-unit>
        <trans-unit id="1aecd159fca1c4e67fecc7d26fe360b4f5fa379d" translate="yes" xml:space="preserve">
          <source>Deallocates all memory allocated by this region, which can be subsequently reused for new allocations.</source>
          <target state="translated">이 영역에 의해 할당 된 모든 메모리를 할당 해제하고, 이후에 새로운 할당에 재사용 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="29e7515d0b0fa1aa05fab0cdf677555556bd1ab2" translate="yes" xml:space="preserve">
          <source>Deallocates all memory allocated with this allocator.</source>
          <target state="translated">이 할당 자로 할당 된 모든 메모리를 할당 해제합니다.</target>
        </trans-unit>
        <trans-unit id="13ee72b94b0c3a01c2b39dc74bddd998b6f54bff" translate="yes" xml:space="preserve">
          <source>Deallocates all memory allocated with this allocator. If an allocator implements this method, it must specify whether its destructor calls it, too.</source>
          <target state="translated">이 할당 자로 할당 된 모든 메모리를 할당 해제합니다. 할당자가이 메소드를 구현하면 소멸자가 호출 할 것인지도 지정해야합니다.</target>
        </trans-unit>
        <trans-unit id="c8b0dd85166c453cf047322a1d701f8f0774ce61" translate="yes" xml:space="preserve">
          <source>Deallocates all memory allocated.</source>
          <target state="translated">할당 된 모든 메모리를 할당 해제합니다.</target>
        </trans-unit>
        <trans-unit id="dc581d2fbe01bbad449340bd78f6d3905d3d52bc" translate="yes" xml:space="preserve">
          <source>Deallocates all memory currently allocated, making the allocator ready for other allocations. This is a &amp;Omicron;(&lt;code&gt;1&lt;/code&gt;) operation.</source>
          <target state="translated">현재 할당 된 모든 메모리를 할당 해제하여 할당자를 다른 할당에 사용할 수 있도록합니다. 이것은 &amp;Omicron; ( &lt;code&gt;1&lt;/code&gt; ) 연산입니다.</target>
        </trans-unit>
        <trans-unit id="375eb34e6b4c58d529175cc75b6080a5179fa77c" translate="yes" xml:space="preserve">
          <source>Deallocates all memory. Implementations that don't support this primitive should always return &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">모든 메모리를 할당 해제합니다. 이 프리미티브를 지원하지 않는 구현은 항상 &lt;code&gt;false&lt;/code&gt; 를 반환해야합니다 .</target>
        </trans-unit>
        <trans-unit id="693611e2f31c3d686f38d8d59ef91ed8a58f5e60" translate="yes" xml:space="preserve">
          <source>Deallocates everything from the parent.</source>
          <target state="translated">부모로부터 모든 것을 할당 해제합니다.</target>
        </trans-unit>
        <trans-unit id="28e790db63e16ffb73cddf977ba22e95426db2d3" translate="yes" xml:space="preserve">
          <source>Deallocates the buffer &lt;code&gt;b&lt;/code&gt; given as parameter. Deallocations take place in constant time, regardless of the number of nodes in the list. &lt;code&gt;b.ptr&lt;/code&gt; is rounded down to the nearest multiple of the &lt;code&gt;alignment&lt;/code&gt; to quickly find the corresponding &lt;code&gt;AlignedBlockNode&lt;/code&gt;.</source>
          <target state="translated">매개 변수로 제공된 버퍼 &lt;code&gt;b&lt;/code&gt; 를 할당 해제합니다 . 할당 해제는 목록의 노드 수에 관계없이 일정한 시간에 발생합니다. &lt;code&gt;b.ptr&lt;/code&gt; 은 가장 가까운 &lt;code&gt;alignment&lt;/code&gt; 배수로 반올림 되어 해당 &lt;code&gt;AlignedBlockNode&lt;/code&gt; 를 빠르게 찾습니다. .</target>
        </trans-unit>
        <trans-unit id="e6ed360d4abba38f3529f274c0f497df84327d1f" translate="yes" xml:space="preserve">
          <source>Deallocates the given buffer &lt;code&gt;b&lt;/code&gt;, by atomically setting the corresponding bit to &lt;code&gt;0&lt;/code&gt;. &lt;code&gt;b&lt;/code&gt; must be valid, and cannot contain multiple adjacent &lt;code&gt;blocks&lt;/code&gt;.</source>
          <target state="translated">해당 비트를 &lt;code&gt;0&lt;/code&gt; 으로 원자 적으로 설정 하여 지정된 버퍼 &lt;code&gt;b&lt;/code&gt; 를 할당 해제합니다 . &lt;code&gt;b&lt;/code&gt; 는 유효해야하며 여러 개의 인접한 &lt;code&gt;blocks&lt;/code&gt; 포함 할 수 없습니다 .</target>
        </trans-unit>
        <trans-unit id="6756d0c2656d83a2c4a40d0c6c294083d6454148" translate="yes" xml:space="preserve">
          <source>Deallocates the memory referenced by p. If p is null, no action occurs. If p references memory not originally allocated by this garbage collector, if p points to the interior of a memory block, or if this method is called from a finalizer, no action will be taken. The block will not be finalized regardless of whether the FINALIZE attribute is set. If finalization is desired, call &lt;a href=&quot;object#destroy&quot;&gt;&lt;code&gt;destroy&lt;/code&gt;&lt;/a&gt; prior to &lt;code&gt;GC.free&lt;/code&gt;.</source>
          <target state="translated">p가 참조하는 메모리를 할당 해제합니다. p가 null이면 아무런 작업도 수행되지 않습니다. p가이 가비지 수집기에 의해 원래 할당되지 않은 메모리를 참조하는 경우, p가 메모리 블록의 내부를 가리 키거나이 메서드가 종료 자에서 호출되면 아무 작업도 수행되지 않습니다. FINALIZE 속성의 설정 여부에 관계없이 블록이 완료되지 않습니다. 마무리가 필요한 경우 &lt;code&gt;GC.free&lt;/code&gt; 전에 &lt;a href=&quot;object#destroy&quot;&gt; &lt;code&gt;destroy&lt;/code&gt; 를&lt;/a&gt; 호출 하십시오 .</target>
        </trans-unit>
        <trans-unit id="91420f5f3acdf53b1f959f067447b487323b2d18" translate="yes" xml:space="preserve">
          <source>Deallocation removes any read/write permissions from the target pages and notifies the OS to reclaim the physical memory, while keeping the virtual memory.</source>
          <target state="translated">할당 해제는 대상 페이지에서 읽기 / 쓰기 권한을 제거하고 가상 메모리를 유지하면서 물리적 메모리를 회수하도록 OS에 알립니다.</target>
        </trans-unit>
        <trans-unit id="978410b97d8a330550445ffa9ad9d811af65a9f4" translate="yes" xml:space="preserve">
          <source>Debug Condition</source>
          <target state="translated">디버그 조건</target>
        </trans-unit>
        <trans-unit id="14a5529bad4b06400e8ae61ab912a7cd0d10cc37" translate="yes" xml:space="preserve">
          <source>Debug Specification</source>
          <target state="translated">디버그 사양</target>
        </trans-unit>
        <trans-unit id="06a1228bc1a2b90a6f69119da7257f1a1ab45207" translate="yes" xml:space="preserve">
          <source>Debug Statement</source>
          <target state="translated">디버그 문장</target>
        </trans-unit>
        <trans-unit id="e0c2c1850c4f5c7487bbcf707447288586061665" translate="yes" xml:space="preserve">
          <source>Debug identifiers and levels are set either by the command line switch &lt;code&gt;-debug&lt;/code&gt; or by a</source>
          <target state="translated">디버그 식별자와 레벨은 명령 행 스위치 &lt;code&gt;-debug&lt;/code&gt; 또는</target>
        </trans-unit>
        <trans-unit id="f2acd488deeb1960df8e4e199af113ed6c4248b5" translate="yes" xml:space="preserve">
          <source>Debug specifications only affect the module they appear in, they do not affect any imported modules. Debug identifiers are in their own namespace, independent from version identifiers and other symbols.</source>
          <target state="translated">디버그 사양은 표시되는 모듈에만 영향을 미치며 가져온 모듈에는 영향을 미치지 않습니다. 디버그 식별자는 버전 식별자 및 기타 기호와 독립적으로 자체 네임 스페이스에 있습니다.</target>
        </trans-unit>
        <trans-unit id="9e4e870be69d39ebaf5be79f4a5e8a28e4a8f09b" translate="yes" xml:space="preserve">
          <source>DebugSpecification</source>
          <target state="translated">DebugSpecification</target>
        </trans-unit>
        <trans-unit id="3d2007a7dd8aa1714c20fa92fcc1113b1137a313" translate="yes" xml:space="preserve">
          <source>DebugStatement</source>
          <target state="translated">DebugStatement</target>
        </trans-unit>
        <trans-unit id="54b7fa5fd17a033513aa4603fe16f3295eb20cde" translate="yes" xml:space="preserve">
          <source>DebugStatements</source>
          <target state="translated">DebugStatements</target>
        </trans-unit>
        <trans-unit id="4d93d7d3dbfcebf8261ee800b21d2d60de831b8a" translate="yes" xml:space="preserve">
          <source>DebugSymbol's happen for statements like: debug = identifier; debug = integer;</source>
          <target state="translated">DebugSymbol은 다음과 같은 명령문에서 발생합니다. debug = identifier; 디버그 = 정수;</target>
        </trans-unit>
        <trans-unit id="a30a20c0780e4f65a6fbda30a51368b3ea650aeb" translate="yes" xml:space="preserve">
          <source>Decide if attributes for this function can be inferred from examining the function body.</source>
          <target state="translated">함수 본문을 검사하여이 함수의 속성을 유추 할 수 있는지 결정하십시오.</target>
        </trans-unit>
        <trans-unit id="e4c3a2d0cc24a4535ef91791064ffe989cbd382a" translate="yes" xml:space="preserve">
          <source>Decimal</source>
          <target state="translated">Decimal</target>
        </trans-unit>
        <trans-unit id="9e7ef50b518db60d788f6a66f520f096a5520932" translate="yes" xml:space="preserve">
          <source>Decimal Literal Types</source>
          <target state="translated">십진 리터럴 유형</target>
        </trans-unit>
        <trans-unit id="a474b82d29231d6f1ccbf54770e91331804b5e39" translate="yes" xml:space="preserve">
          <source>Decimal integers are a sequence of decimal digits.</source>
          <target state="translated">십진 정수는 십진 숫자의 시퀀스입니다.</target>
        </trans-unit>
        <trans-unit id="2de80026e02653cd40f376511faf80e503b57dad" translate="yes" xml:space="preserve">
          <source>Decimal_Number</source>
          <target state="translated">Decimal_Number</target>
        </trans-unit>
        <trans-unit id="902215ab9cce221464c82a811ffbf787aae569a5" translate="yes" xml:space="preserve">
          <source>Declaration &lt;code&gt;d&lt;/code&gt;</source>
          <target state="translated">선언 &lt;code&gt;d&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="4a9836d7a1f0bfb09fb9f17d77609357ee100d20" translate="yes" xml:space="preserve">
          <source>Declaration Statement</source>
          <target state="translated">선언문</target>
        </trans-unit>
        <trans-unit id="0d29683a9ffa0394ace63543e28e006b48029722" translate="yes" xml:space="preserve">
          <source>Declaration Syntax</source>
          <target state="translated">선언 구문</target>
        </trans-unit>
        <trans-unit id="6dbd41224edfbe68c7f2bb4f6490fc6955007a5d" translate="yes" xml:space="preserve">
          <source>Declaration of a symbol</source>
          <target state="translated">심볼 선언</target>
        </trans-unit>
        <trans-unit id="4df4d0d514f56b499f06d9d0b79927ecf23d6473" translate="yes" xml:space="preserve">
          <source>Declaration statements define variables, and declare types, templates, functions, imports, conditionals, static foreaches, and static asserts.</source>
          <target state="translated">선언문은 변수를 정의하고 유형, 템플릿, 함수, 가져 오기, 조건부, 정적 foreaches 및 정적 어설 션을 선언합니다.</target>
        </trans-unit>
        <trans-unit id="f167d58fa1936ba9d8b8b66ebb917ff8a385b7fc" translate="yes" xml:space="preserve">
          <source>Declaration syntax generally reads right to left:</source>
          <target state="translated">선언 구문은 일반적으로 오른쪽에서 왼쪽으로 읽습니다.</target>
        </trans-unit>
        <trans-unit id="f529c46c42bf47385843447380f9083ea85ad933" translate="yes" xml:space="preserve">
          <source>DeclarationBlock</source>
          <target state="translated">DeclarationBlock</target>
        </trans-unit>
        <trans-unit id="5bb823617a62be17e705b335fba5d4aec48eeccc" translate="yes" xml:space="preserve">
          <source>DeclarationExp &lt;code&gt;e&lt;/code&gt;</source>
          <target state="translated">선언 Expe &lt;code&gt;e&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="b9b846963186dedc9a34aab11fab9a0a092e2d1b" translate="yes" xml:space="preserve">
          <source>Declarations</source>
          <target state="translated">Declarations</target>
        </trans-unit>
        <trans-unit id="b2d470601a3d4487d9aa450f5db0b4407b71ec6f" translate="yes" xml:space="preserve">
          <source>Declarations appear before the identifier being declared and read right to left, so:</source>
          <target state="translated">선언은 식별자가 선언되기 전에 나타나고 오른쪽에서 왼쪽으로 읽습니다.</target>
        </trans-unit>
        <trans-unit id="792121f5e5959941aabdee1cc06fb17c681269dd" translate="yes" xml:space="preserve">
          <source>Declarations at module scope.</source>
          <target state="translated">모듈 범위에서의 선언.</target>
        </trans-unit>
        <trans-unit id="357cee9200ca080c7e1bb92afd3f56d835106b03" translate="yes" xml:space="preserve">
          <source>Declarations for interfacing with the ODBC library.</source>
          <target state="translated">ODBC 라이브러리와의 인터페이스 선언.</target>
        </trans-unit>
        <trans-unit id="6c8080422baab7c5dfd2ef7a7d95733d7d14dbd2" translate="yes" xml:space="preserve">
          <source>Declarations inside &lt;code&gt;BaseClass&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;BaseClass&lt;/code&gt; 내부의 선언 .</target>
        </trans-unit>
        <trans-unit id="acbd57364da8ec4429f99f9abe1e2cf960f39c4c" translate="yes" xml:space="preserve">
          <source>Declarations inside &lt;code&gt;Foo&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Foo&lt;/code&gt; 내부의 선언 .</target>
        </trans-unit>
        <trans-unit id="07073b60f0a5c321ba826fabc66323c4ccf44ef5" translate="yes" xml:space="preserve">
          <source>Declarations inside &lt;code&gt;bar&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;bar&lt;/code&gt; 내부의 선언 .</target>
        </trans-unit>
        <trans-unit id="e39406434fba037956df51d317adc73db26ad763" translate="yes" xml:space="preserve">
          <source>Declarator</source>
          <target state="translated">Declarator</target>
        </trans-unit>
        <trans-unit id="4884a58f8854eaff9e14e4541fa2bfc15e139d8a" translate="yes" xml:space="preserve">
          <source>Declare The Schema Of A Virtual Table</source>
          <target state="translated">가상 테이블의 스키마 선언</target>
        </trans-unit>
        <trans-unit id="789b27945c32aa3b3dc27c3088dc1d56ef533c8f" translate="yes" xml:space="preserve">
          <source>Declare one or more of the functions to be function templates even if they take no specific template arguments:</source>
          <target state="translated">특정 템플릿 인수를 사용하지 않더라도 하나 이상의 함수를 함수 템플릿으로 선언합니다.</target>
        </trans-unit>
        <trans-unit id="d589e1ed3e4a83c9e3c689d35e6af4db16cf6a59" translate="yes" xml:space="preserve">
          <source>Declare parameters of template instance, initialize them with the template instance arguments.</source>
          <target state="translated">템플릿 인스턴스의 파라미터를 선언하고 템플릿 인스턴스 인수로 초기화합니다.</target>
        </trans-unit>
        <trans-unit id="d8118e66aa0d9891f4571c1ab2494aaa3cdb7a6b" translate="yes" xml:space="preserve">
          <source>Declare result variable lazily.</source>
          <target state="translated">결과 변수를 느리게 선언하십시오.</target>
        </trans-unit>
        <trans-unit id="8ce51b37a7f81f5172fdac6a58f02604f2a69530" translate="yes" xml:space="preserve">
          <source>Declare template parameter tp with value o, and install it in the scope sc.</source>
          <target state="translated">템플릿 매개 변수 tp를 값 o로 선언하고 범위 sc에 설치하십시오.</target>
        </trans-unit>
        <trans-unit id="13a40c01b2509965e38c4e58bf4f7081ffd728d9" translate="yes" xml:space="preserve">
          <source>Declare the functions inside of a mixin template:</source>
          <target state="translated">믹스 인 템플릿 내부의 함수를 선언하십시오.</target>
        </trans-unit>
        <trans-unit id="a85107bcac12057ef2b3cbc11e112f58d45e3a1d" translate="yes" xml:space="preserve">
          <source>Declare the functions to be static members of a nested struct:</source>
          <target state="translated">중첩 구조체의 정적 멤버가되도록 함수를 선언하십시오.</target>
        </trans-unit>
        <trans-unit id="23776085f3b27f84d9591be0a7aa80866f3538fd" translate="yes" xml:space="preserve">
          <source>Declare your own linear congruential engine</source>
          <target state="translated">자신 만의 선형 합동 엔진 선언</target>
        </trans-unit>
        <trans-unit id="c657d4e9ebee4c198c968bcba7aff6eeab9209c1" translate="yes" xml:space="preserve">
          <source>Declared Datatype Of A Query Result</source>
          <target state="translated">쿼리 결과의 선언 된 데이터 유형</target>
        </trans-unit>
        <trans-unit id="71a17a71a9f79cc8bd76ac0e7f0f13c4f0c8db81" translate="yes" xml:space="preserve">
          <source>Declaring an External Class</source>
          <target state="translated">외부 클래스 선언</target>
        </trans-unit>
        <trans-unit id="6c0d8f96cd8b374527e48fbd5b4e9fb411f6bca8" translate="yes" xml:space="preserve">
          <source>Declaring an instance variable looks exactly the same as for a regular D class.</source>
          <target state="translated">인스턴스 변수 선언은 일반 D 클래스와 동일하게 보입니다.</target>
        </trans-unit>
        <trans-unit id="df50d3b937b66b95438db0baeefd22f2c1fa73b6" translate="yes" xml:space="preserve">
          <source>Decode</source>
          <target state="translated">Decode</target>
        </trans-unit>
        <trans-unit id="dbba0fda2419c5ddfc2c1e2e7bf06860f6436900" translate="yes" xml:space="preserve">
          <source>Decode Signed LEB128.</source>
          <target state="translated">서명 된 LEB128을 디코딩합니다.</target>
        </trans-unit>
        <trans-unit id="6d4fd06fda3c2f0f209bfb521e76e6c96911badb" translate="yes" xml:space="preserve">
          <source>Decode Unsigned LEB128.</source>
          <target state="translated">부호없는 LEB128을 디코딩합니다.</target>
        </trans-unit>
        <trans-unit id="1331e16b2aa86b673e67d5de5aa0667a06e438f1" translate="yes" xml:space="preserve">
          <source>Decode a UTF-16 sequence as a single UTF-32 code point.</source>
          <target state="translated">UTF-16 시퀀스를 단일 UTF-32 코드 포인트로 디코딩하십시오.</target>
        </trans-unit>
        <trans-unit id="37b32b5db730690ed79c40536224b996ea9780ef" translate="yes" xml:space="preserve">
          <source>Decode a UTF-8 sequence as a single UTF-32 code point.</source>
          <target state="translated">UTF-8 시퀀스를 단일 UTF-32 코드 포인트로 디코딩하십시오.</target>
        </trans-unit>
        <trans-unit id="dfd3524c8c563b09008218fac3d408952ffb4b11" translate="yes" xml:space="preserve">
          <source>Decode, and throw exception on error</source>
          <target state="translated">디코딩하고 오류 발생시 예외 발생</target>
        </trans-unit>
        <trans-unit id="406bb62f3f33b8ee5964cf4ecafe3878f9b6291c" translate="yes" xml:space="preserve">
          <source>Decode, but ignore errors</source>
          <target state="translated">디코딩하지만 오류는 무시</target>
        </trans-unit>
        <trans-unit id="3821e20522daad9f57316f912fe1be7b26097318" translate="yes" xml:space="preserve">
          <source>DecodeException if decode fails</source>
          <target state="translated">디코딩에 실패한 경우 DecodeException</target>
        </trans-unit>
        <trans-unit id="46664e82aa4d152b87c49f64b8c12e4e9f3bfc63" translate="yes" xml:space="preserve">
          <source>DecodeException if mode == DecodeMode.STRICT and decode fails</source>
          <target state="translated">mode == DecodeMode.STRICT이고 디코딩에 실패한 경우 DecodeException</target>
        </trans-unit>
        <trans-unit id="f001d418c3a6a2090bdc0efd4a74748a8652ac76" translate="yes" xml:space="preserve">
          <source>DecodeMode &lt;code&gt;mode&lt;/code&gt;</source>
          <target state="translated">디코드 &lt;code&gt;mode&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="e9f9cd86a51b3e2f8f8bb9ccc352699712738757" translate="yes" xml:space="preserve">
          <source>Decoder!Range &lt;strong id=&quot;decoder&quot;&gt;decoder&lt;/strong&gt;(Range)(Range range)</source>
          <target state="translated">디코더! 범위 &lt;strong id=&quot;decoder&quot;&gt;디코더&lt;/strong&gt; (범위) (범위 범위)</target>
        </trans-unit>
        <trans-unit id="1b1bd0df056cc5b05a9c21efd16cacfb012e0aa6" translate="yes" xml:space="preserve">
          <source>Decodes a single code point from the end of a string.</source>
          <target state="translated">문자열 끝에서 단일 코드 포인트를 디코딩합니다.</target>
        </trans-unit>
        <trans-unit id="3d5e319e3deb54e40422a2ff80fdffd0d465c77c" translate="yes" xml:space="preserve">
          <source>Decodes a single code point.</source>
          <target state="translated">단일 코드 포인트를 디코딩합니다.</target>
        </trans-unit>
        <trans-unit id="d605555fd554268d3f7092e4dfd739e804d6e4ff" translate="yes" xml:space="preserve">
          <source>Decodes a single code point. The input does not have to be valid.</source>
          <target state="translated">단일 코드 포인트를 디코딩합니다. 입력이 유효하지 않아도됩니다.</target>
        </trans-unit>
        <trans-unit id="0f95dd9db2c1f3dc7f42ac75e283334b4487f4e0" translate="yes" xml:space="preserve">
          <source>Decodes a string by unescaping all predefined XML entities.</source>
          <target state="translated">미리 정의 된 모든 XML 엔터티를 이스케이프 처리하여 문자열을 디코딩합니다.</target>
        </trans-unit>
        <trans-unit id="394691f122913c450c1d979638fefc7f9b4936d9" translate="yes" xml:space="preserve">
          <source>Decodes and returns the code point starting at &lt;code&gt;str[index]&lt;/code&gt;. &lt;code&gt;index&lt;/code&gt; is advanced to one past the decoded code point. If the code point is not well-formed, then a &lt;code&gt;UTFException&lt;/code&gt; is thrown and &lt;code&gt;index&lt;/code&gt; remains unchanged.</source>
          <target state="translated">&lt;code&gt;str[index]&lt;/code&gt; 에서 시작하는 코드 포인트를 디코딩하고 리턴합니다 . &lt;code&gt;index&lt;/code&gt; 는 디코딩 된 코드 포인트를 지나서 1로 진행된다. 코드 포인트의 형식이 올바르지 않으면 &lt;code&gt;UTFException&lt;/code&gt; 이 발생하고 &lt;code&gt;index&lt;/code&gt; 은 변경되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="a966f90f685bee27fa037e2c88b5c7e4eaa16b77" translate="yes" xml:space="preserve">
          <source>Decodes source into a given &lt;a href=&quot;std_range_primitives#isOutputRange&quot;&gt;output range&lt;/a&gt;.</source>
          <target state="translated">지정된 &lt;a href=&quot;std_range_primitives#isOutputRange&quot;&gt;출력 범위&lt;/a&gt; 로 소스를 디코딩 합니다 .</target>
        </trans-unit>
        <trans-unit id="49d1787ea4b9bb131d20e33432426cfac5ed8daf" translate="yes" xml:space="preserve">
          <source>Decodes source into newly-allocated buffer.</source>
          <target state="translated">소스를 새로 할당 된 버퍼로 디코딩합니다.</target>
        </trans-unit>
        <trans-unit id="dc99eaa6f996cb24aaa9f16d927e74ca329a6edf" translate="yes" xml:space="preserve">
          <source>Decodes source into the given buffer.</source>
          <target state="translated">지정된 버퍼로 소스를 디코드합니다.</target>
        </trans-unit>
        <trans-unit id="ac1d3d72ef820f018eec0cf37be48d3fc07063e8" translate="yes" xml:space="preserve">
          <source>Decodes the URI string encodedURI into a UTF-8 string and returns it. All escape sequences are decoded.</source>
          <target state="translated">encodeURI URI 문자열을 UTF-8 문자열로 디코딩하여 리턴합니다. 모든 이스케이프 시퀀스가 ​​디코딩됩니다.</target>
        </trans-unit>
        <trans-unit id="475eb1f0fc19db39961b576c47d3442f49745df2" translate="yes" xml:space="preserve">
          <source>Decodes the URI string encodedURI into a UTF-8 string and returns it. Escape sequences that resolve to reserved URI characters are not replaced. Escape sequences that resolve to the '#' character are not replaced.</source>
          <target state="translated">encodeURI URI 문자열을 UTF-8 문자열로 디코딩하여 리턴합니다. 예약 된 URI 문자로 해석되는 이스케이프 시퀀스는 바뀌지 않습니다. '#'문자로 해석되는 이스케이프 시퀀스는 바뀌지 않습니다.</target>
        </trans-unit>
        <trans-unit id="73e4e91afe8b4f47795484e980cc395b572d9595" translate="yes" xml:space="preserve">
          <source>Decoding (&lt;a href=&quot;#decodeGrapheme&quot;&gt;&lt;code&gt;decodeGrapheme&lt;/code&gt;&lt;/a&gt;) and iteration (&lt;a href=&quot;#byGrapheme&quot;&gt;&lt;code&gt;byGrapheme&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#graphemeStride&quot;&gt;&lt;code&gt;graphemeStride&lt;/code&gt;&lt;/a&gt;) by user-perceived characters, that is by &lt;a href=&quot;#Grapheme&quot;&gt;&lt;code&gt;Grapheme&lt;/code&gt;&lt;/a&gt; clusters.</source>
          <target state="translated">사용자 인식 문자, 즉 &lt;a href=&quot;#Grapheme&quot;&gt; &lt;code&gt;Grapheme&lt;/code&gt; &lt;/a&gt; 클러스터에 의한 디코딩 ( &lt;a href=&quot;#decodeGrapheme&quot;&gt; &lt;code&gt;decodeGrapheme&lt;/code&gt; &lt;/a&gt; ) 및 반복 ( &lt;a href=&quot;#byGrapheme&quot;&gt; &lt;code&gt;byGrapheme&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#graphemeStride&quot;&gt; &lt;code&gt;graphemeStride&lt;/code&gt; &lt;/a&gt; ) .</target>
        </trans-unit>
        <trans-unit id="c8daa89a5a99e8ec115a0662f2e1660217e62ec8" translate="yes" xml:space="preserve">
          <source>Decommit all physical memory associated with the buffer given as parameter, but keep the range of virtual addresses.</source>
          <target state="translated">매개 변수로 제공된 버퍼와 연관된 모든 실제 메모리를 해제하지만 가상 주소의 범위는 유지하십시오.</target>
        </trans-unit>
        <trans-unit id="9b0a363a7d243d250d53b4cbfe3e066f33145e52" translate="yes" xml:space="preserve">
          <source>Decompose</source>
          <target state="translated">Decompose</target>
        </trans-unit>
        <trans-unit id="f696ff6edb97c27479dfeb370594310b979f4fdf" translate="yes" xml:space="preserve">
          <source>Decomposes a Hangul syllable. If &lt;code&gt;ch&lt;/code&gt; is not a composed syllable then this function returns &lt;a href=&quot;#Grapheme&quot;&gt;&lt;code&gt;Grapheme&lt;/code&gt;&lt;/a&gt; containing only &lt;code&gt;ch&lt;/code&gt; as is.</source>
          <target state="translated">한글 음절을 분해합니다. 경우 &lt;code&gt;ch&lt;/code&gt; 다음이 함수가 반환 합성 음절하지 &lt;a href=&quot;#Grapheme&quot;&gt; &lt;code&gt;Grapheme&lt;/code&gt; &lt;/a&gt; 포함 된 단지 &lt;code&gt;ch&lt;/code&gt; 로합니다.</target>
        </trans-unit>
        <trans-unit id="8e7b400681f356e884cec054477da6ae1fd30add" translate="yes" xml:space="preserve">
          <source>Decomposing and composing of individual character(s) according to canonical or compatibility rules, see &lt;a href=&quot;#compose&quot;&gt;&lt;code&gt;compose&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#decompose&quot;&gt;&lt;code&gt;decompose&lt;/code&gt;&lt;/a&gt;, including the specific version for Hangul syllables &lt;a href=&quot;#composeJamo&quot;&gt;&lt;code&gt;composeJamo&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#decomposeHangul&quot;&gt;&lt;code&gt;decomposeHangul&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">정식 또는 호환성 규칙에 따라 개별 문자를 분해하고 구성 하려면 한글 음절 &lt;a href=&quot;#composeJamo&quot;&gt; &lt;code&gt;composeJamo&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#decomposeHangul&quot;&gt; &lt;code&gt;decomposeHangul&lt;/code&gt; &lt;/a&gt; 의 특정 버전을 포함하여 &lt;a href=&quot;#compose&quot;&gt; &lt;code&gt;compose&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#decompose&quot;&gt; &lt;code&gt;decompose&lt;/code&gt; &lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="64557b59c3e3b422b56194c79018a7a402df5f75" translate="yes" xml:space="preserve">
          <source>Decompress and return any remaining data. The returned data should be appended to that returned by uncompress(). The UnCompress object cannot be used further.</source>
          <target state="translated">나머지 데이터를 압축 해제하고 반환하십시오. 반환 된 데이터는 uncompress ()에 의해 반환 된 데이터에 추가되어야합니다. UnCompress 개체는 더 이상 사용할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="758d2baadff9e7263131434184a3f463f60af9a5" translate="yes" xml:space="preserve">
          <source>Decompress the contents of archive member de and return the expanded data.</source>
          <target state="translated">아카이브 멤버 de의 컨텐츠를 압축 해제하고 확장 된 데이터를 리턴하십시오.</target>
        </trans-unit>
        <trans-unit id="331e56cb06cb518e2402ea3951b07bb690da1ffd" translate="yes" xml:space="preserve">
          <source>Decompress the data in buf and return the decompressed data. The buffers returned from successive calls to this should be concatenated together.</source>
          <target state="translated">buf의 데이터를 압축 해제하고 압축 해제 된 데이터를 리턴하십시오. 연속적인 호출에서 리턴 된 버퍼는 함께 연결되어야합니다.</target>
        </trans-unit>
        <trans-unit id="9ea10b070e9d7365e1dfb76f204e09a139b7b4bf" translate="yes" xml:space="preserve">
          <source>Decompresses the data in srcbuf[].</source>
          <target state="translated">srcbuf []에서 데이터를 압축 해제합니다.</target>
        </trans-unit>
        <trans-unit id="3e9abbc6f4724b8e785725d912f2aaa59750275e" translate="yes" xml:space="preserve">
          <source>Decreases the reference count of the concrete class that implements this interface. When the reference count is &lt;code&gt;0&lt;/code&gt;, the object self-destructs.</source>
          <target state="translated">이 인터페이스를 구현하는 구체적 클래스의 참조 횟수를 줄입니다. 참조 카운트가 &lt;code&gt;0&lt;/code&gt; 이면 객체가 자체 소멸됩니다.</target>
        </trans-unit>
        <trans-unit id="02c806f941459077b10b340cd9632e9a0cb538f5" translate="yes" xml:space="preserve">
          <source>Decrements the internal lock count by one. If this brings the count to zero, the lock is released.</source>
          <target state="translated">내부 잠금 수를 1 씩 줄입니다. 카운트가 0이되면 잠금이 해제됩니다.</target>
        </trans-unit>
        <trans-unit id="ef0d38f738fb21cfe095e1269d745948ad990bfd" translate="yes" xml:space="preserve">
          <source>Deduction from a specialization can provide values for more than one parameter:</source>
          <target state="translated">전문화에서 제외하면 둘 이상의 매개 변수에 대한 값을 제공 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e9d287d865171614d8dedf150d2d0836f7b7edd5" translate="yes" xml:space="preserve">
          <source>Deep interface inheritance causes compile error with messages like &quot;Error: function std.typecons.AutoImplement!(Foo).AutoImplement.bar does not override any function&quot;. [&lt;a href=&quot;https://issues.dlang.org/show_bug.cgi?id=2525&quot;&gt;Bugzilla 2525&lt;/a&gt;]</source>
          <target state="translated">딥 인터페이스 상속은 &quot;오류 : function std.typecons.AutoImplement! (Foo) .AutoImplement.bar는 어떤 함수도 무시하지 않습니다&quot;와 같은 메시지와 함께 컴파일 오류를 발생시킵니다. [ &lt;a href=&quot;https://issues.dlang.org/show_bug.cgi?id=2525&quot;&gt;버그질라 2525&lt;/a&gt; ]</target>
        </trans-unit>
        <trans-unit id="c748de0e8bf8554aeb51f7845528d2e387d7b157" translate="yes" xml:space="preserve">
          <source>Default Initialization</source>
          <target state="translated">기본 초기화</target>
        </trans-unit>
        <trans-unit id="371d87a5f41a115cc6ae98f15bc16de04539f72f" translate="yes" xml:space="preserve">
          <source>Default Initialization of Structs</source>
          <target state="translated">구조체의 기본 초기화</target>
        </trans-unit>
        <trans-unit id="420b1de5ee5bd01f3bccad5941846b453e834c77" translate="yes" xml:space="preserve">
          <source>Default Initialization of Unions</source>
          <target state="translated">연합의 기본 초기화</target>
        </trans-unit>
        <trans-unit id="50c0422b1bd3c0cb85a3b10f878811736afd4f6f" translate="yes" xml:space="preserve">
          <source>Default Random Engines</source>
          <target state="translated">기본 랜덤 엔진</target>
        </trans-unit>
        <trans-unit id="4f3b4cf1b282f5e24851d2fc312835e2ee1126a7" translate="yes" xml:space="preserve">
          <source>Default constructor that initializes a &lt;code&gt;TaskPool&lt;/code&gt; with &lt;code&gt;totalCPUs&lt;/code&gt; - 1 worker threads. The minus 1 is included because the main thread will also be available to do work.</source>
          <target state="translated">초기화 기본 생성자 &lt;code&gt;TaskPool&lt;/code&gt; 을 가진 &lt;code&gt;totalCPUs&lt;/code&gt; 을 - 1 개 작업자 스레드. 마이너스 1은 메인 스레드가 작동하기 때문에 포함되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="27d8f5b12b08679fa1ceeb7aa68b26b65ef2045f" translate="yes" xml:space="preserve">
          <source>Default formatting (same as &quot;d&quot;)</source>
          <target state="translated">기본 형식 ( &quot;d&quot;와 동일)</target>
        </trans-unit>
        <trans-unit id="e96836a37f607443c594efaed093035c05afe38b" translate="yes" xml:space="preserve">
          <source>Default highlighting of all the members of a class, struct, etc.</source>
          <target state="translated">클래스, 구조체 등의 모든 멤버에 대한 기본 강조 표시</target>
        </trans-unit>
        <trans-unit id="98f9ae2cc7e4e80454521f2ab1730089e9d6baa9" translate="yes" xml:space="preserve">
          <source>Default namespace from RFC 4122</source>
          <target state="translated">RFC 4122의 기본 네임 스페이스</target>
        </trans-unit>
        <trans-unit id="2c5cd1f0d1dcc8e95ce7f83f2ec37a797706dca3" translate="yes" xml:space="preserve">
          <source>Default parameters are resolved and semantically checked in the context of the function declaration.</source>
          <target state="translated">기본 매개 변수는 함수 선언의 컨텍스트에서 해석되고 의미 적으로 점검됩니다.</target>
        </trans-unit>
        <trans-unit id="dc75ea9274f6222114e96e9234906962c3ab1c51" translate="yes" xml:space="preserve">
          <source>Default system linkage for the target.</source>
          <target state="translated">대상의 기본 시스템 연결</target>
        </trans-unit>
        <trans-unit id="a76b4f3915cc1ec7629202bfab49b91d3e8811c7" translate="yes" xml:space="preserve">
          <source>Default value to use for architecture. Should be &quot;32&quot; or &quot;64&quot;</source>
          <target state="translated">아키텍처에 사용할 기본값입니다. &quot;32&quot;또는 &quot;64&quot;여야합니다</target>
        </trans-unit>
        <trans-unit id="0471388472434480b398dbbb1b529f53c8403a1a" translate="yes" xml:space="preserve">
          <source>DefaultStatement &lt;strong id=&quot;sdefault&quot;&gt;sdefault&lt;/strong&gt;;</source>
          <target state="translated">DefaultStatement &lt;strong id=&quot;sdefault&quot;&gt;sdefault&lt;/strong&gt; ;</target>
        </trans-unit>
        <trans-unit id="bc406dd5812a1993fbe6a79d3cd9b04e74387b96" translate="yes" xml:space="preserve">
          <source>Default_Ignorable_Code_Point</source>
          <target state="translated">Default_Ignorable_Code_Point</target>
        </trans-unit>
        <trans-unit id="f04a631e5fb8580ab675839a96ca7cd9782ddc95" translate="yes" xml:space="preserve">
          <source>Defaults to &quot;&quot; but can be assigned to prior to calling &lt;code&gt;getopt&lt;/code&gt;.</source>
          <target state="translated">기본값은 &quot;&quot;이지만 &lt;code&gt;getopt&lt;/code&gt; 를 호출하기 전에 지정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="df1395a4ccfcda2ee16159ff05ed2cc4232a297b" translate="yes" xml:space="preserve">
          <source>Defaults to &quot;--&quot; but can be assigned to prior to calling &lt;code&gt;getopt&lt;/code&gt;. Assigning an empty string to &lt;code&gt;endOfOptions&lt;/code&gt; effectively disables it.</source>
          <target state="translated">기본값은 &quot;-&quot;이지만 &lt;code&gt;getopt&lt;/code&gt; 를 호출하기 전에 지정할 수 있습니다 . &lt;code&gt;endOfOptions&lt;/code&gt; 에 빈 문자열을 할당하면 효과적으로 비활성화됩니다.</target>
        </trans-unit>
        <trans-unit id="8aa51945574822bec5dcd1c3efc97549eb710c3f" translate="yes" xml:space="preserve">
          <source>Defaults to '-' but it can be assigned to prior to calling &lt;code&gt;getopt&lt;/code&gt;.</source>
          <target state="translated">기본값은 '-'이지만 &lt;code&gt;getopt&lt;/code&gt; 를 호출하기 전에 지정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="9de2851fac6dd53ccefeb661bb98002fd0c199f4" translate="yes" xml:space="preserve">
          <source>Defaults to '=' but can be assigned to prior to calling &lt;code&gt;getopt&lt;/code&gt;.</source>
          <target state="translated">기본값은 '='이지만 &lt;code&gt;getopt&lt;/code&gt; 를 호출하기 전에 지정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="8503b1ebf1456be871732701f4598afac98d9a38" translate="yes" xml:space="preserve">
          <source>Defaults to &lt;code&gt;Yes.preserveAttributes&lt;/code&gt; on Windows, and the opposite on all other platforms.</source>
          <target state="translated">Windows에서는 기본값이 &lt;code&gt;Yes.preserveAttributes&lt;/code&gt; 이고 다른 모든 플랫폼에서는 반대입니다.</target>
        </trans-unit>
        <trans-unit id="fd21e76d6af8f49e1eb6914fb6c49390fd8bd8c1" translate="yes" xml:space="preserve">
          <source>Define &lt;code&gt;XorshiftEngine&lt;/code&gt; generators with well-chosen parameters. See each bits examples of &quot;Xorshift RNGs&quot;. &lt;code&gt;Xorshift&lt;/code&gt; is a Xorshift128's alias because 128bits implementation is mostly used.</source>
          <target state="translated">잘 선택된 매개 변수로 &lt;code&gt;XorshiftEngine&lt;/code&gt; 생성기를 정의하십시오 . &quot;Xorshift RNG&quot;의 각 비트 예를 참조하십시오. &lt;code&gt;Xorshift&lt;/code&gt; 는 Xorshift128의 별칭이며 128 비트 구현이 대부분 사용되기 때문입니다.</target>
        </trans-unit>
        <trans-unit id="81847ec7dd3ceb5453d0ee6884a6280e90c956b1" translate="yes" xml:space="preserve">
          <source>Define LinearCongruentialEngine generators with well-chosen parameters. &lt;code&gt;MinstdRand0&lt;/code&gt; implements Park and Miller's &quot;minimal standard&quot; &lt;a href=&quot;http://wikipedia.org/wiki/Park%E2%80%93Miller_random_number_generator&quot;&gt;generator&lt;/a&gt; that uses 16807 for the multiplier. &lt;code&gt;MinstdRand&lt;/code&gt; implements a variant that has slightly better spectral behavior by using the multiplier 48271. Both generators are rather simplistic.</source>
          <target state="translated">잘 선택된 매개 변수로 LinearCongruentialEngine 생성기를 정의하십시오. &lt;code&gt;MinstdRand0&lt;/code&gt; 은 곱셈기에 16807을 사용 하는 Park 및 Miller의 &quot;최소 표준&quot; &lt;a href=&quot;http://wikipedia.org/wiki/Park%E2%80%93Miller_random_number_generator&quot;&gt;생성기&lt;/a&gt; 를 구현합니다. &lt;code&gt;MinstdRand&lt;/code&gt; 는 승수 48271을 사용하여 약간 더 나은 스펙트럼 동작을 갖는 변형을 구현합니다. 두 생성기는 다소 단순합니다.</target>
        </trans-unit>
        <trans-unit id="2a32a694b454b48f0c6093b3ea95bcc7ae1e63ab" translate="yes" xml:space="preserve">
          <source>Define New Collating Sequences</source>
          <target state="translated">새로운 조합 순서 정의</target>
        </trans-unit>
        <trans-unit id="39097f9cdbdc9c13d9f7924e620c0870a6ab1f2d" translate="yes" xml:space="preserve">
          <source>Define base class for synchronization exceptions.</source>
          <target state="translated">동기화 예외의 기본 클래스를 정의하십시오.</target>
        </trans-unit>
        <trans-unit id="1fe6ef7e4374fbc92435a3eb3a1da3f110264323" translate="yes" xml:space="preserve">
          <source>Define when building the standard library</source>
          <target state="translated">표준 라이브러리를 구축 할 때 정의</target>
        </trans-unit>
        <trans-unit id="3531e23462282b88161b0b09c4198f983f8f5d9c" translate="yes" xml:space="preserve">
          <source>Defined if &lt;code&gt;Allocator.deallocate&lt;/code&gt; and &lt;code&gt;Allocator.owns&lt;/code&gt; are defined.</source>
          <target state="translated">&lt;code&gt;Allocator.deallocate&lt;/code&gt; 및 &lt;code&gt;Allocator.owns&lt;/code&gt; 가 정의 된 경우 정의됩니다.</target>
        </trans-unit>
        <trans-unit id="a3e2600e60e43fcc7af73e79b544e721703b0e8b" translate="yes" xml:space="preserve">
          <source>Defined if &lt;code&gt;ParentAllocator.deallocate&lt;/code&gt; exists and forwards to &lt;code&gt;parent.deallocate(b.ptr[0 .. goodAllocSize(b.length)])&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;ParentAllocator.deallocate&lt;/code&gt; 가 존재하고 &lt;code&gt;parent.deallocate(b.ptr[0 .. goodAllocSize(b.length)])&lt;/code&gt; 전달 되는지 여부를 정의합니다 .</target>
        </trans-unit>
        <trans-unit id="d5839c46fd4f57e4f4534cc94d889acf7302900a" translate="yes" xml:space="preserve">
          <source>Defined if &lt;code&gt;ParentAllocator.deallocate&lt;/code&gt; exists, and returns to it all memory held in the free tree.</source>
          <target state="translated">&lt;code&gt;ParentAllocator.deallocate&lt;/code&gt; 가 존재하고 사용 가능한 트리에있는 모든 메모리를 반환하는 경우 정의됩니다 .</target>
        </trans-unit>
        <trans-unit id="ae7fc2022dee75f14540e1bb6b89db20bb6af50b" translate="yes" xml:space="preserve">
          <source>Defined if &lt;code&gt;ParentAllocator.deallocateAll&lt;/code&gt; exists, and forwards to it. Also nullifies the free tree (it's assumed the parent frees all memory stil managed by the free tree).</source>
          <target state="translated">&lt;code&gt;ParentAllocator.deallocateAll&lt;/code&gt; 이 존재하고 전달하는 경우 정의됩니다 . 또한 사용 가능한 트리를 무효화합니다 (부모가 사용 가능한 트리에서 관리하는 모든 메모리를 사용 가능하게하는 것으로 가정).</target>
        </trans-unit>
        <trans-unit id="924b574b2f51f1f91bae0a753d7a3cd5e721d17d" translate="yes" xml:space="preserve">
          <source>Defined if &lt;code&gt;ParentAllocator&lt;/code&gt; defines it. Checks whether the block belongs to this allocator.</source>
          <target state="translated">&lt;code&gt;ParentAllocator&lt;/code&gt; 가 정의한 경우 정의됩니다. 블록이이 할당 자에 속하는지 확인합니다.</target>
        </trans-unit>
        <trans-unit id="22d483263bd2221c01661d83bf480b3a1978600e" translate="yes" xml:space="preserve">
          <source>Defined if &lt;code&gt;perCallFlags&lt;/code&gt; is nonzero.</source>
          <target state="translated">&lt;code&gt;perCallFlags&lt;/code&gt; 가 0이 아닌 경우 정의됩니다 .</target>
        </trans-unit>
        <trans-unit id="80fb3bfe81400b11248d1a55abb8916e94447707" translate="yes" xml:space="preserve">
          <source>Defined if &lt;code&gt;perCallFlags&lt;/code&gt; is nonzero. Iterates all monitored file/line instances. The order of iteration is not meaningful (items are inserted at the front of a list upon the first call), so preprocessing the statistics after collection might be appropriate.</source>
          <target state="translated">&lt;code&gt;perCallFlags&lt;/code&gt; 가 0이 아닌 경우 정의됩니다 . 모니터링 된 모든 파일 / 라인 인스턴스를 반복합니다. 반복 순서는 의미가 없으므로 (첫 번째 호출시 목록 앞에 항목이 삽입 됨) 수집 후 통계를 사전 처리하는 것이 적절할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="af0b04d11e256e5ba5a86b4d6ccc479ac3bb0733" translate="yes" xml:space="preserve">
          <source>Defined if &lt;code&gt;perCallFlags&lt;/code&gt; is nonzero. Outputs (e.g. to a &lt;code&gt;File&lt;/code&gt;) a simple report of the collected per-call statistics.</source>
          <target state="translated">&lt;code&gt;perCallFlags&lt;/code&gt; 가 0이 아닌 경우 정의됩니다 . 수집 된 통화 별 통계에 대한 간단한 보고서 를 출력합니다 (예 : &lt;code&gt;File&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="0e6aad149de6e35db7818ba9e061e221c789d78e" translate="yes" xml:space="preserve">
          <source>Defined in RFC 4122 document</source>
          <target state="translated">RFC 4122 문서에 정의</target>
        </trans-unit>
        <trans-unit id="74bb7ab73b6be283bed5a27e4f9da6abe208f8a4" translate="yes" xml:space="preserve">
          <source>Defined only if &lt;code&gt;Allocator.deallocateAll&lt;/code&gt; is defined. Affects per instance and per call &lt;code&gt;numDeallocateAll&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Allocator.deallocateAll&lt;/code&gt; 이 정의 된 경우에만 정의됩니다. 인스턴스 및 호출 &lt;code&gt;numDeallocateAll&lt;/code&gt; 에 영향을줍니다 .</target>
        </trans-unit>
        <trans-unit id="880dd85210629b3db5a46cc41b73cc297fc347f0" translate="yes" xml:space="preserve">
          <source>Defined only if &lt;code&gt;Allocator.expand&lt;/code&gt; is defined. Finds the owner of &lt;code&gt;b&lt;/code&gt; and calls &lt;code&gt;expand&lt;/code&gt; for it. The owner is not brought to the head of the list.</source>
          <target state="translated">&lt;code&gt;Allocator.expand&lt;/code&gt; 가 정의 된 경우에만 정의됩니다. 의 소유자 찾습니다 &lt;code&gt;b&lt;/code&gt; 하고 호출 &lt;code&gt;expand&lt;/code&gt; 그것을 위해. 소유자는 목록의 머리로 가져 오지 않습니다.</target>
        </trans-unit>
        <trans-unit id="744c61edf3dc2f8cca313264c4f118c38c0b2a22" translate="yes" xml:space="preserve">
          <source>Defined only if &lt;code&gt;Allocator.owns&lt;/code&gt; and &lt;code&gt;Allocator.deallocateAll&lt;/code&gt; are defined.</source>
          <target state="translated">&lt;code&gt;Allocator.owns&lt;/code&gt; 및 &lt;code&gt;Allocator.deallocateAll&lt;/code&gt; 이 정의 된 경우에만 정의됩니다.</target>
        </trans-unit>
        <trans-unit id="1fdfa394d06528a596ae4874c40d528d999bfd2b" translate="yes" xml:space="preserve">
          <source>Defined only if &lt;code&gt;Allocator.reallocate&lt;/code&gt; is defined. Finds the owner of &lt;code&gt;b&lt;/code&gt; and calls &lt;code&gt;reallocate&lt;/code&gt; for it. If that fails, calls the global &lt;code&gt;reallocate&lt;/code&gt;, which allocates a new block and moves memory.</source>
          <target state="translated">&lt;code&gt;Allocator.reallocate&lt;/code&gt; 가 정의 된 경우에만 정의됩니다. &lt;code&gt;b&lt;/code&gt; 의 소유자를 찾아 &lt;code&gt;reallocate&lt;/code&gt; 을 호출 합니다. 실패하면 전역 &lt;code&gt;reallocate&lt;/code&gt; 호출하여 새 블록을 할당하고 메모리를 이동시킵니다.</target>
        </trans-unit>
        <trans-unit id="ed697f6a88a630666af1c722afd39b1d0f4f4f19" translate="yes" xml:space="preserve">
          <source>Defined only if &lt;code&gt;Allocator&lt;/code&gt; defines &lt;code&gt;owns&lt;/code&gt;. Finds the owner of &lt;code&gt;b&lt;/code&gt; and forwards the call to it.</source>
          <target state="translated">경우에만 정의 &lt;code&gt;Allocator&lt;/code&gt; 정의가 &lt;code&gt;owns&lt;/code&gt; . &lt;code&gt;b&lt;/code&gt; 의 소유자를 찾아서 호출을 전달합니다.</target>
        </trans-unit>
        <trans-unit id="a0e6bc044e12c4e9611bf3580583040fda29e9b8" translate="yes" xml:space="preserve">
          <source>Defined only if &lt;code&gt;Allocator&lt;/code&gt; defines &lt;code&gt;owns&lt;/code&gt;. Tries each allocator in turn, in most-recently-used order. If the owner is found, it is moved to the front of the list as a side effect under the assumption it will be used soon.</source>
          <target state="translated">경우에만 정의 &lt;code&gt;Allocator&lt;/code&gt; 정의가 &lt;code&gt;owns&lt;/code&gt; . 가장 최근에 사용한 순서대로 각 할당자를 차례로 시도합니다. 소유자가 발견되면 곧 사용될 것이라는 가정하에 부작용으로 목록의 맨 앞으로 이동합니다.</target>
        </trans-unit>
        <trans-unit id="2e24b737d8be4f0fce227702cdf2d4971d9bd548" translate="yes" xml:space="preserve">
          <source>Defined only if &lt;code&gt;Options.bytesUsed&lt;/code&gt; is defined. Returns &lt;code&gt;bytesUsed == 0&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Options.bytesUsed&lt;/code&gt; 가 정의 된 경우에만 정의됩니다. &lt;code&gt;bytesUsed == 0&lt;/code&gt; 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="e866186e044949f060cc13ede78f11571f00e878" translate="yes" xml:space="preserve">
          <source>Defined only if &lt;code&gt;ParentAllocator.alignedAllocate&lt;/code&gt; exists. Expansion occurs in place under the conditions required by &lt;code&gt;expand&lt;/code&gt;. Shrinking occurs in place if &lt;code&gt;goodAllocSize(b.length) == goodAllocSize(s)&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;ParentAllocator.alignedAllocate&lt;/code&gt; 가 존재하는 경우에만 정의됩니다 . 확장에 필요한 조건 하에서 장소에 발생합니다 &lt;code&gt;expand&lt;/code&gt; . &lt;code&gt;goodAllocSize(b.length) == goodAllocSize(s)&lt;/code&gt; 경우 축소가 발생합니다 .</target>
        </trans-unit>
        <trans-unit id="9de3285d7d12656c0f50a8bc0845b0e3663f1845" translate="yes" xml:space="preserve">
          <source>Defined only if &lt;code&gt;ParentAllocator&lt;/code&gt; defines &lt;code&gt;deallocateAll&lt;/code&gt;. If so, forwards to it and resets the freelist.</source>
          <target state="translated">&lt;code&gt;ParentAllocator&lt;/code&gt; 가 &lt;code&gt;deallocateAll&lt;/code&gt; 을 정의한 경우에만 정의됩니다 . 그렇다면 전달하고 프리리스트를 재설정하십시오.</target>
        </trans-unit>
        <trans-unit id="bb02e98056476e0ccf512cbbc349777443611e1f" translate="yes" xml:space="preserve">
          <source>Defined only if &lt;code&gt;parent.alignedAllocate&lt;/code&gt; exists and works similarly to &lt;code&gt;allocate&lt;/code&gt; by forwarding to &lt;code&gt;parent.alignedAllocate(goodAllocSize(n), a)&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;parent.alignedAllocate&lt;/code&gt; 가 존재하고 &lt;code&gt;parent.alignedAllocate(goodAllocSize(n), a)&lt;/code&gt; 로 전달하여 &lt;code&gt;allocate&lt;/code&gt; 하는 것과 유사하게 작동하는 경우에만 정의됩니다 .</target>
        </trans-unit>
        <trans-unit id="3bdcfae19e6266cb37491298481490d18641857e" translate="yes" xml:space="preserve">
          <source>Defined when building the standard runtime</source>
          <target state="translated">표준 런타임을 구축 할 때 정의</target>
        </trans-unit>
        <trans-unit id="8603ace2093f41a5875c31508c40434bf1934d95" translate="yes" xml:space="preserve">
          <source>Defined whether or not &lt;code&gt;Allocator.deallocate&lt;/code&gt; is defined. Affects per instance: &lt;code&gt;numDeallocate&lt;/code&gt;, &lt;code&gt;bytesUsed&lt;/code&gt;, and &lt;code&gt;bytesSlack&lt;/code&gt;. Affects per call: &lt;code&gt;numDeallocate&lt;/code&gt; and &lt;code&gt;bytesContracted&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Allocator.deallocate&lt;/code&gt; 의 정의 여부를 정의합니다 . 인스턴스에 미치는 영향 : &lt;code&gt;numDeallocate&lt;/code&gt; , &lt;code&gt;bytesUsed&lt;/code&gt; 및 &lt;code&gt;bytesSlack&lt;/code&gt; 을 . 호출 당에 미치는 영향 : &lt;code&gt;numDeallocate&lt;/code&gt; 및 &lt;code&gt;bytesContracted&lt;/code&gt; 을 .</target>
        </trans-unit>
        <trans-unit id="a10dcb53bbdef9f4f52f70eb8281de857ea0c04d" translate="yes" xml:space="preserve">
          <source>Defined whether or not &lt;code&gt;Allocator.expand&lt;/code&gt; is defined. Affects per instance: &lt;code&gt;numExpand&lt;/code&gt;, &lt;code&gt;numExpandOK&lt;/code&gt;, &lt;code&gt;bytesExpanded&lt;/code&gt;, &lt;code&gt;bytesSlack&lt;/code&gt;, &lt;code&gt;bytesAllocated&lt;/code&gt;, and &lt;code&gt;bytesUsed&lt;/code&gt;. Affects per call: &lt;code&gt;numExpand&lt;/code&gt;, &lt;code&gt;numExpandOK&lt;/code&gt;, &lt;code&gt;bytesExpanded&lt;/code&gt;, and &lt;code&gt;bytesAllocated&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Allocator.expand&lt;/code&gt; 의 정의 여부를 정의합니다 . 인스턴스 당 영향 : &lt;code&gt;numExpand&lt;/code&gt; , &lt;code&gt;numExpandOK&lt;/code&gt; , &lt;code&gt;bytesExpanded&lt;/code&gt; , &lt;code&gt;bytesSlack&lt;/code&gt; , &lt;code&gt;bytesAllocated&lt;/code&gt; 및 &lt;code&gt;bytesUsed&lt;/code&gt; . 호출 당 영향 : &lt;code&gt;numExpand&lt;/code&gt; , &lt;code&gt;numExpandOK&lt;/code&gt; , &lt;code&gt;bytesExpanded&lt;/code&gt; 및 &lt;code&gt;bytesAllocated&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b422af85c74e4035f60d8efe5ab2781d63622be3" translate="yes" xml:space="preserve">
          <source>Defined whether or not &lt;code&gt;Allocator.reallocate&lt;/code&gt; is defined. Affects per instance: &lt;code&gt;numReallocate&lt;/code&gt;, &lt;code&gt;numReallocateOK&lt;/code&gt;, &lt;code&gt; numReallocateInPlace&lt;/code&gt;, &lt;code&gt;bytesNotMoved&lt;/code&gt;, &lt;code&gt;bytesAllocated&lt;/code&gt;, &lt;code&gt; bytesSlack&lt;/code&gt;, &lt;code&gt;bytesExpanded&lt;/code&gt;, and &lt;code&gt;bytesContracted&lt;/code&gt;. Affects per call: &lt;code&gt;numReallocate&lt;/code&gt;, &lt;code&gt;numReallocateOK&lt;/code&gt;, &lt;code&gt;numReallocateInPlace&lt;/code&gt;, &lt;code&gt;bytesNotMoved&lt;/code&gt;, &lt;code&gt;bytesExpanded&lt;/code&gt;, &lt;code&gt;bytesContracted&lt;/code&gt;, and &lt;code&gt;bytesMoved&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Allocator.reallocate&lt;/code&gt; 의 정의 여부를 정의합니다 . 인스턴스 당 영향 : &lt;code&gt;numReallocate&lt;/code&gt; , &lt;code&gt;numReallocateOK&lt;/code&gt; , &lt;code&gt; numReallocateInPlace&lt;/code&gt; , &lt;code&gt;bytesNotMoved&lt;/code&gt; , &lt;code&gt;bytesAllocated&lt;/code&gt; , &lt;code&gt; bytesSlack&lt;/code&gt; , &lt;code&gt;bytesExpanded&lt;/code&gt; 및 &lt;code&gt;bytesContracted&lt;/code&gt; . 호출 당에 미치는 영향 : &lt;code&gt;numReallocate&lt;/code&gt; , &lt;code&gt;numReallocateOK&lt;/code&gt; , &lt;code&gt;numReallocateInPlace&lt;/code&gt; , &lt;code&gt;bytesNotMoved&lt;/code&gt; , &lt;code&gt;bytesExpanded&lt;/code&gt; , &lt;code&gt;bytesContracted&lt;/code&gt; 및 &lt;code&gt;bytesMoved&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e01f0090ee0730f66f1a15b18bea750a3d6fc2b4" translate="yes" xml:space="preserve">
          <source>Defines a Latin2-encoded character.</source>
          <target state="translated">라틴어 인코딩 된 문자를 정의합니다.</target>
        </trans-unit>
        <trans-unit id="5e53ecfaa755cb1d4f19e088a8c9f00a6dbfc490" translate="yes" xml:space="preserve">
          <source>Defines a Windows1250-encoded character.</source>
          <target state="translated">Windows1250으로 인코딩 된 문자를 정의합니다.</target>
        </trans-unit>
        <trans-unit id="9f1903090723311586df4cd37fbdf5f26e67079a" translate="yes" xml:space="preserve">
          <source>Defines a Windows1251-encoded character.</source>
          <target state="translated">Windows1251 인코딩 문자를 정의합니다.</target>
        </trans-unit>
        <trans-unit id="cccb5b7d80539ad53bf55ca34e9f94b1953e89a5" translate="yes" xml:space="preserve">
          <source>Defines a Windows1252-encoded character.</source>
          <target state="translated">Windows1252 인코딩 문자를 정의합니다.</target>
        </trans-unit>
        <trans-unit id="56254a36f29bce74ac63e1c814d120ccbdcc4a03" translate="yes" xml:space="preserve">
          <source>Defines a reference-counted object containing a &lt;code&gt;T&lt;/code&gt; value as payload.</source>
          <target state="translated">&lt;code&gt;T&lt;/code&gt; 값을 포함하는 참조 횟수 개체를 페이로드로 정의합니다 .</target>
        </trans-unit>
        <trans-unit id="ba5e2fe31df68893adfb9e39176c913b0ab90b13" translate="yes" xml:space="preserve">
          <source>Defines a simple, self-documenting yes/no flag. This makes it easy for APIs to define functions accepting flags without resorting to &lt;code&gt;bool&lt;/code&gt;, which is opaque in calls, and without needing to define an enumerated type separately. Using &lt;code&gt;Flag!&quot;Name&quot;&lt;/code&gt; instead of &lt;code&gt;bool&lt;/code&gt; makes the flag's meaning visible in calls. Each yes/no flag has its own type, which makes confusions and mix-ups impossible.</source>
          <target state="translated">간단한 자체 문서화 예 / 아니오 플래그를 정의합니다. 이를 통해 API 는 &lt;code&gt;bool&lt;/code&gt; 에 의존하지 않고 호출에서 불투명하고 열거 형을 별도로 정의하지 않고도 플래그를 수락하는 함수를 쉽게 정의 할 수 있습니다 . 사용 &lt;code&gt;Flag!&quot;Name&quot;&lt;/code&gt; 대신 &lt;code&gt;bool&lt;/code&gt; 플래그의 통화에서 볼 의미한다. 각 예 / 아니오 플래그에는 고유 한 유형이 있으므로 혼동 및 혼합이 불가능합니다.</target>
        </trans-unit>
        <trans-unit id="d037c0e93cb77eea8d259e298e9c276dd536788f" translate="yes" xml:space="preserve">
          <source>Defines a total order on all floating-point numbers.</source>
          <target state="translated">모든 부동 소수점 숫자의 총 순서를 정의합니다.</target>
        </trans-unit>
        <trans-unit id="1b2fe2f27a3c2be6c4b5a0300512ceb77431cca8" translate="yes" xml:space="preserve">
          <source>Defines a value paired with a distinctive &quot;null&quot; state that denotes the absence of a value. If default constructed, a &lt;code&gt;Nullable!T&lt;/code&gt; object starts in the null state. Assigning it renders it non-null. Calling &lt;code&gt;nullify&lt;/code&gt; can nullify it again.</source>
          <target state="translated">값이 없음을 나타내는 고유 한 &quot;널&quot;상태와 쌍을 이루는 값을 정의합니다. 기본적으로 구성된 경우 &lt;code&gt;Nullable!T&lt;/code&gt; 객체는 null 상태에서 시작됩니다. 지정하면 널이 아닌 것으로 렌더링됩니다. &lt;code&gt;nullify&lt;/code&gt; 를 호출 하면 다시 nullize 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3f49f1773a53446e251ede71ac0716adcb46d913" translate="yes" xml:space="preserve">
          <source>Defines an Latin1-encoded character.</source>
          <target state="translated">라틴어로 인코딩 된 문자를 정의합니다.</target>
        </trans-unit>
        <trans-unit id="e57a29ea6d093696ef6c6f7d8afb730e34136a6d" translate="yes" xml:space="preserve">
          <source>Defines an Latin1-encoded string (as an array of &lt;code&gt;immutable(Latin1Char)&lt;/code&gt;).</source>
          <target state="translated">라틴어로 인코딩 된 문자열을 정의합니다 ( &lt;code&gt;immutable(Latin1Char)&lt;/code&gt; 의 배열로 ).</target>
        </trans-unit>
        <trans-unit id="011886a5161af4c4e37e5385fd27679cc8b830bd" translate="yes" xml:space="preserve">
          <source>Defines an Latin2-encoded string (as an array of &lt;code&gt; immutable(Latin2Char)&lt;/code&gt;).</source>
          <target state="translated">라틴어 인코딩 된 문자열을 정의합니다 ( &lt;code&gt; immutable(Latin2Char)&lt;/code&gt; 의 배열로 ).</target>
        </trans-unit>
        <trans-unit id="8d5cf26107dde7d6c09fcfb638d212a7bf2e12ba" translate="yes" xml:space="preserve">
          <source>Defines an Windows1250-encoded string (as an array of &lt;code&gt; immutable(Windows1250Char)&lt;/code&gt;).</source>
          <target state="translated">Windows1250으로 인코딩 된 문자열을 정의합니다 ( &lt;code&gt; immutable(Windows1250Char)&lt;/code&gt; 의 배열 (Windows1250Char) ).</target>
        </trans-unit>
        <trans-unit id="e8732904f5c920a3848f6eb11eb4689860b73df6" translate="yes" xml:space="preserve">
          <source>Defines an Windows1251-encoded string (as an array of &lt;code&gt; immutable(Windows1251Char)&lt;/code&gt;).</source>
          <target state="translated">Windows1251로 인코딩 된 문자열을 정의합니다 ( &lt;code&gt; immutable(Windows1251Char)&lt;/code&gt; 의 배열 (Windows1251Char) ).</target>
        </trans-unit>
        <trans-unit id="e4276c26be648ff75c1e818b48f26e071b93fc98" translate="yes" xml:space="preserve">
          <source>Defines an Windows1252-encoded string (as an array of &lt;code&gt; immutable(Windows1252Char)&lt;/code&gt;).</source>
          <target state="translated">Windows1252로 인코딩 된 문자열을 정의합니다 ( &lt;code&gt; immutable(Windows1252Char)&lt;/code&gt; 의 배열 (Windows1252Char) ).</target>
        </trans-unit>
        <trans-unit id="97ccdd739d5a34ddd79a07f475bf10a7ea2872af" translate="yes" xml:space="preserve">
          <source>Defines an early termination condition. Receives the current upper and lower bounds on the root. The delegate must return &lt;code&gt;true&lt;/code&gt; when these bounds are acceptable. If this function always returns &lt;code&gt;false&lt;/code&gt;, full machine precision will be achieved.</source>
          <target state="translated">조기 종료 조건을 정의합니다. 루트의 현재 상한 및 하한을받습니다. 이러한 범위가 허용되면 대리자는 &lt;code&gt;true&lt;/code&gt; 를 반환해야합니다 . 이 함수가 항상 &lt;code&gt;false&lt;/code&gt; 를 반환 하면 전체 기계 정밀도가 달성됩니다.</target>
        </trans-unit>
        <trans-unit id="5c3a4051688057309dd223cc23bc9904e0d4075a" translate="yes" xml:space="preserve">
          <source>Defines binary operations with overflow checking for any two integral types. The result type obeys the language rules (even when they may be counterintuitive), and &lt;code&gt;overflow&lt;/code&gt; is set if an overflow occurs (including inadvertent change of signedness, e.g. &lt;code&gt;-1&lt;/code&gt; is converted to &lt;code&gt;uint&lt;/code&gt;). Conceptually the behavior is:</source>
          <target state="translated">두 가지 정수 유형에 대한 오버 플로우 검사를 사용하여 이진 연산을 정의합니다. 결과 유형은 언어 규칙을 따르며 (반 직관적 일 수 있음에도 불구하고) &lt;code&gt;overflow&lt;/code&gt; 가 발생하면 오버플로 가 설정됩니다 (예 : &lt;code&gt;-1&lt;/code&gt; 이 &lt;code&gt;uint&lt;/code&gt; 로 변환 된 실수로 부호가 변경됨 ). 개념적으로 동작은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="c6275d2a02318e95dbebc22c44c93c7e2829c06d" translate="yes" xml:space="preserve">
          <source>Defines binary operators &lt;code&gt;+&lt;/code&gt;, &lt;code&gt;-&lt;/code&gt;, &lt;code&gt;*&lt;/code&gt;, &lt;code&gt;/&lt;/code&gt;, &lt;code&gt;%&lt;/code&gt;, &lt;code&gt;^^&lt;/code&gt;, &lt;code&gt;&amp;amp;&lt;/code&gt;, &lt;code&gt;|&lt;/code&gt;, &lt;code&gt;^&lt;/code&gt;, &lt;code&gt;&amp;lt;&amp;lt;&lt;/code&gt;, &lt;code&gt;&amp;gt;&amp;gt;&lt;/code&gt;, and &lt;code&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/code&gt; for the case when a built-in numeric or Boolean type is on the left-hand side, and a &lt;code&gt;Checked&lt;/code&gt; instance is on the right-hand side.</source>
          <target state="translated">이진 연산자 &lt;code&gt;+&lt;/code&gt; , &lt;code&gt;-&lt;/code&gt; , &lt;code&gt;*&lt;/code&gt; , &lt;code&gt;/&lt;/code&gt; , &lt;code&gt;%&lt;/code&gt; , &lt;code&gt;^^&lt;/code&gt; , &lt;code&gt;&amp;amp;&lt;/code&gt; , &lt;code&gt;|&lt;/code&gt; 내장 숫자 또는 부울 유형이 왼쪽에 있고 &lt;code&gt;Checked&lt;/code&gt; 인스턴스가 오른쪽 에있는 경우 , &lt;code&gt;^&lt;/code&gt; , &lt;code&gt;&amp;lt;&amp;lt;&lt;/code&gt; , &lt;code&gt;&amp;gt;&amp;gt;&lt;/code&gt; 및 &lt;code&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="deff15ac1ee86ba403037d1ba526c39f22f79b38" translate="yes" xml:space="preserve">
          <source>Defines binary operators &lt;code&gt;+&lt;/code&gt;, &lt;code&gt;-&lt;/code&gt;, &lt;code&gt;*&lt;/code&gt;, &lt;code&gt;/&lt;/code&gt;, &lt;code&gt;%&lt;/code&gt;, &lt;code&gt;^^&lt;/code&gt;, &lt;code&gt;&amp;amp;&lt;/code&gt;, &lt;code&gt;|&lt;/code&gt;, &lt;code&gt;^&lt;/code&gt;, &lt;code&gt;&amp;lt;&amp;lt;&lt;/code&gt;, &lt;code&gt;&amp;gt;&amp;gt;&lt;/code&gt;, and &lt;code&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/code&gt;. If &lt;code&gt;Hook&lt;/code&gt; defines &lt;code&gt;hookOpBinary&lt;/code&gt;, &lt;code&gt;opBinary&lt;/code&gt; forwards to &lt;code&gt; Checked!(typeof(hook.hookOpBinary!op(get, rhs)), Hook)(hook.hookOpBinary!op(get, rhs))&lt;/code&gt;.</source>
          <target state="translated">이진 연산자 &lt;code&gt;+&lt;/code&gt; , &lt;code&gt;-&lt;/code&gt; , &lt;code&gt;*&lt;/code&gt; , &lt;code&gt;/&lt;/code&gt; , &lt;code&gt;%&lt;/code&gt; , &lt;code&gt;^^&lt;/code&gt; , &lt;code&gt;&amp;amp;&lt;/code&gt; , &lt;code&gt;|&lt;/code&gt; , &lt;code&gt;^&lt;/code&gt; , &lt;code&gt;&amp;lt;&amp;lt;&lt;/code&gt; , &lt;code&gt;&amp;gt;&amp;gt;&lt;/code&gt; 및 &lt;code&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/code&gt; . 경우 &lt;code&gt;Hook&lt;/code&gt; 정의 &lt;code&gt;hookOpBinary&lt;/code&gt; , &lt;code&gt;opBinary&lt;/code&gt; 을 에 전달 &lt;code&gt; Checked!(typeof(hook.hookOpBinary!op(get, rhs)), Hook)(hook.hookOpBinary!op(get, rhs))&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="82d51c5b573b12f3ad98f02a60e2594b70eb07ed" translate="yes" xml:space="preserve">
          <source>Defines built-in exception types and low-level language hooks required by the compiler.</source>
          <target state="translated">컴파일러에 필요한 내장 예외 유형 및 저수준 언어 후크를 정의합니다.</target>
        </trans-unit>
        <trans-unit id="4e91c153395398611d9ad588b394bf5e23ccda89" translate="yes" xml:space="preserve">
          <source>Defines hooks for binary operators &lt;code&gt;+&lt;/code&gt;, &lt;code&gt;-&lt;/code&gt;, &lt;code&gt;*&lt;/code&gt;, &lt;code&gt;/&lt;/code&gt;, &lt;code&gt;%&lt;/code&gt;, &lt;code&gt;^^&lt;/code&gt;, &lt;code&gt;&amp;amp;&lt;/code&gt;, &lt;code&gt;|&lt;/code&gt;, &lt;code&gt;^&lt;/code&gt;, &lt;code&gt;&amp;lt;&amp;lt;&lt;/code&gt;, &lt;code&gt;&amp;gt;&amp;gt;&lt;/code&gt;, and &lt;code&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/code&gt; for cases where a &lt;code&gt;Checked&lt;/code&gt; object is the left-hand side operand. If &lt;code&gt;lhs == WithNaN.defaultValue!Lhs&lt;/code&gt;, returns &lt;code&gt;WithNaN.defaultValue!(typeof(lhs + rhs))&lt;/code&gt; without evaluating the operand. Otherwise, evaluates the operand. If evaluation does not overflow, returns the result. Otherwise, returns &lt;code&gt;WithNaN.defaultValue!(typeof(lhs + rhs))&lt;/code&gt;.</source>
          <target state="translated">이진 연산자 &lt;code&gt;+&lt;/code&gt; , &lt;code&gt;-&lt;/code&gt; , &lt;code&gt;*&lt;/code&gt; , &lt;code&gt;/&lt;/code&gt; , &lt;code&gt;%&lt;/code&gt; , &lt;code&gt;^^&lt;/code&gt; , &lt;code&gt;&amp;amp;&lt;/code&gt; , &lt;code&gt;|&lt;/code&gt; &lt;code&gt;Checked&lt;/code&gt; 객체가 왼쪽 피연산자 인 경우 , &lt;code&gt;^&lt;/code&gt; , &lt;code&gt;&amp;lt;&amp;lt;&lt;/code&gt; , &lt;code&gt;&amp;gt;&amp;gt;&lt;/code&gt; 및 &lt;code&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/code&gt; . 경우 &lt;code&gt;lhs == WithNaN.defaultValue!Lhs&lt;/code&gt; , 반환 &lt;code&gt;WithNaN.defaultValue!(typeof(lhs + rhs))&lt;/code&gt; 피연산자를 평가하지 않고. 그렇지 않으면 피연산자를 평가합니다. 평가가 오버플로되지 않으면 결과를 반환합니다. 그렇지 않으면 &lt;code&gt;WithNaN.defaultValue!(typeof(lhs + rhs))&lt;/code&gt; 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="b4943eeb1bdb96455051418c789cfdb6862bc56c" translate="yes" xml:space="preserve">
          <source>Defines hooks for binary operators &lt;code&gt;+&lt;/code&gt;, &lt;code&gt;-&lt;/code&gt;, &lt;code&gt;*&lt;/code&gt;, &lt;code&gt;/&lt;/code&gt;, &lt;code&gt;%&lt;/code&gt;, &lt;code&gt;^^&lt;/code&gt;, &lt;code&gt;&amp;amp;&lt;/code&gt;, &lt;code&gt;|&lt;/code&gt;, &lt;code&gt;^&lt;/code&gt;, &lt;code&gt;&amp;lt;&amp;lt;&lt;/code&gt;, &lt;code&gt;&amp;gt;&amp;gt;&lt;/code&gt;, and &lt;code&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/code&gt; for cases where a &lt;code&gt;Checked&lt;/code&gt; object is the right-hand side operand. If &lt;code&gt;rhs == WithNaN.defaultValue!Rhs&lt;/code&gt;, returns &lt;code&gt;WithNaN.defaultValue!(typeof(lhs + rhs))&lt;/code&gt; without evaluating the operand. Otherwise, evaluates the operand. If evaluation does not overflow, returns the result. Otherwise, returns &lt;code&gt;WithNaN.defaultValue!(typeof(lhs + rhs))&lt;/code&gt;.</source>
          <target state="translated">이진 연산자 &lt;code&gt;+&lt;/code&gt; , &lt;code&gt;-&lt;/code&gt; , &lt;code&gt;*&lt;/code&gt; , &lt;code&gt;/&lt;/code&gt; , &lt;code&gt;%&lt;/code&gt; , &lt;code&gt;^^&lt;/code&gt; , &lt;code&gt;&amp;amp;&lt;/code&gt; , &lt;code&gt;|&lt;/code&gt; &lt;code&gt;Checked&lt;/code&gt; 객체가 오른쪽 피연산자 인 경우 , &lt;code&gt;^&lt;/code&gt; , &lt;code&gt;&amp;lt;&amp;lt;&lt;/code&gt; , &lt;code&gt;&amp;gt;&amp;gt;&lt;/code&gt; 및 &lt;code&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/code&gt; . 경우 &lt;code&gt;rhs == WithNaN.defaultValue!Rhs&lt;/code&gt; , 반환 &lt;code&gt;WithNaN.defaultValue!(typeof(lhs + rhs))&lt;/code&gt; 피연산자를 평가하지 않고. 그렇지 않으면 피연산자를 평가합니다. 평가가 오버플로되지 않으면 결과를 반환합니다. 그렇지 않으면 &lt;code&gt;WithNaN.defaultValue!(typeof(lhs + rhs))&lt;/code&gt; 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="344e4af67915b1da0a4f7b2eb4baa46168d0a009" translate="yes" xml:space="preserve">
          <source>Defines hooks for binary operators &lt;code&gt;+=&lt;/code&gt;, &lt;code&gt;-=&lt;/code&gt;, &lt;code&gt;*=&lt;/code&gt;, &lt;code&gt;/=&lt;/code&gt;, &lt;code&gt;%=&lt;/code&gt;, &lt;code&gt;^^=&lt;/code&gt;, &lt;code&gt;&amp;amp;=&lt;/code&gt;, &lt;code&gt;|=&lt;/code&gt;, &lt;code&gt;^=&lt;/code&gt;, &lt;code&gt;&amp;lt;&amp;lt;=&lt;/code&gt;, &lt;code&gt;&amp;gt;&amp;gt;=&lt;/code&gt;, and &lt;code&gt;&amp;gt;&amp;gt;&amp;gt;=&lt;/code&gt; for cases where a &lt;code&gt;Checked&lt;/code&gt; object is the left-hand side operand. If &lt;code&gt;lhs == WithNaN.defaultValue!Lhs&lt;/code&gt;, no action is carried. Otherwise, evaluates the operand. If evaluation does not overflow and fits in &lt;code&gt;Lhs&lt;/code&gt; without loss of information or change of sign, sets &lt;code&gt;lhs&lt;/code&gt; to the result. Otherwise, sets &lt;code&gt;lhs&lt;/code&gt; to &lt;code&gt;WithNaN.defaultValue!Lhs&lt;/code&gt;.</source>
          <target state="translated">이진 연산자 &lt;code&gt;+=&lt;/code&gt; , &lt;code&gt;-=&lt;/code&gt; , &lt;code&gt;*=&lt;/code&gt; , &lt;code&gt;/=&lt;/code&gt; , &lt;code&gt;%=&lt;/code&gt; , &lt;code&gt;^^=&lt;/code&gt; , &lt;code&gt;&amp;amp;=&lt;/code&gt; , &lt;code&gt;|=&lt;/code&gt; , &lt;code&gt;^=&lt;/code&gt; , &lt;code&gt;&amp;lt;&amp;lt;=&lt;/code&gt; , &lt;code&gt;&amp;gt;&amp;gt;=&lt;/code&gt; 및 &lt;code&gt;&amp;gt;&amp;gt;&amp;gt;=&lt;/code&gt; 에 대한 후크를 정의합니다 . &lt;code&gt;Checked&lt;/code&gt; 개체는 왼쪽 피연산자입니다. 경우 &lt;code&gt;lhs == WithNaN.defaultValue!Lhs&lt;/code&gt; , 조치가 수행되지 않습니다. 그렇지 않으면 피연산자를 평가합니다. 정보 손실이나 부호 변경없이 평가가 오버플로되지 않고 &lt;code&gt;Lhs&lt;/code&gt; 에 적합 하면 &lt;code&gt;lhs&lt;/code&gt; 를 결과로 설정합니다 . 그렇지 않으면 &lt;code&gt;lhs&lt;/code&gt; 를 &lt;code&gt;WithNaN.defaultValue!Lhs&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1765c6ae1549ba0f78d30a2ebbb0c0bf7b13cc1d" translate="yes" xml:space="preserve">
          <source>Defines hooks for unary operators &lt;code&gt;-&lt;/code&gt;, &lt;code&gt;~&lt;/code&gt;, &lt;code&gt;++&lt;/code&gt;, and &lt;code&gt;--&lt;/code&gt;.</source>
          <target state="translated">단항 연산자 &lt;code&gt;-&lt;/code&gt; , &lt;code&gt;~&lt;/code&gt; , &lt;code&gt;++&lt;/code&gt; 및 &lt;code&gt;--&lt;/code&gt; 대한 후크를 정의합니다 .</target>
        </trans-unit>
        <trans-unit id="1062f11ecac31d0859fcc7cf5ec29909f863a7eb" translate="yes" xml:space="preserve">
          <source>Defines operators &lt;code&gt;+=&lt;/code&gt;, &lt;code&gt;-=&lt;/code&gt;, &lt;code&gt;*=&lt;/code&gt;, &lt;code&gt;/=&lt;/code&gt;, &lt;code&gt;%=&lt;/code&gt;, &lt;code&gt;^^=&lt;/code&gt;, &lt;code&gt;&amp;amp;=&lt;/code&gt;, &lt;code&gt;|=&lt;/code&gt;, &lt;code&gt;^=&lt;/code&gt;, &lt;code&gt;&amp;lt;&amp;lt;=&lt;/code&gt;, &lt;code&gt;&amp;gt;&amp;gt;=&lt;/code&gt;, and &lt;code&gt;&amp;gt;&amp;gt;&amp;gt;=&lt;/code&gt;.</source>
          <target state="translated">연산자 &lt;code&gt;+=&lt;/code&gt; , &lt;code&gt;-=&lt;/code&gt; , &lt;code&gt;*=&lt;/code&gt; , &lt;code&gt;/=&lt;/code&gt; , &lt;code&gt;%=&lt;/code&gt; , &lt;code&gt;^^=&lt;/code&gt; , &lt;code&gt;&amp;amp;=&lt;/code&gt; , &lt;code&gt;|=&lt;/code&gt; , &lt;code&gt;^=&lt;/code&gt; , &lt;code&gt;&amp;lt;&amp;lt;=&lt;/code&gt; , &lt;code&gt;&amp;gt;&amp;gt;=&lt;/code&gt; 및 &lt;code&gt;&amp;gt;&amp;gt;&amp;gt;=&lt;/code&gt; 을 정의 합니다.</target>
        </trans-unit>
        <trans-unit id="a84f96c56e07c3c0d4be57b930a8414c37127be8" translate="yes" xml:space="preserve">
          <source>Defines the array's primary range, which is a random-access range.</source>
          <target state="translated">랜덤 액세스 범위 인 어레이의 기본 범위를 정의합니다.</target>
        </trans-unit>
        <trans-unit id="b9547918d0ec754aaa9e5611e63002c034456218" translate="yes" xml:space="preserve">
          <source>Defines the array's primary range.</source>
          <target state="translated">배열의 기본 범위를 정의합니다.</target>
        </trans-unit>
        <trans-unit id="25307811d2b650458426086b1231b34b76190751" translate="yes" xml:space="preserve">
          <source>Defines the constants A=0, B=1, C=2, all of type &lt;code&gt;int&lt;/code&gt;.</source>
          <target state="translated">상수 A = 0, B = 1, C = 2 (모두 &lt;code&gt;int&lt;/code&gt; 유형)를 정의합니다 .</target>
        </trans-unit>
        <trans-unit id="5960422815ff02efca0bb0b0bc511d329a4df6b9" translate="yes" xml:space="preserve">
          <source>Defines the container's primary range, which embodies a bidirectional range.</source>
          <target state="translated">컨테이너의 기본 범위를 정의하며 양방향 범위를 구현합니다.</target>
        </trans-unit>
        <trans-unit id="cfb64e179215d70a5466203268165ded0aa67b71" translate="yes" xml:space="preserve">
          <source>Defines the container's primary range, which embodies a forward range.</source>
          <target state="translated">컨테이너의 기본 범위를 정의합니다.이 범위는 전달 범위를 구현합니다.</target>
        </trans-unit>
        <trans-unit id="7704b43cc8447527f7119f9c397053172e452d7c" translate="yes" xml:space="preserve">
          <source>Defines the fastest type to use when storing temporaries of a calculation intended to ultimately yield a result of type &lt;code&gt;F&lt;/code&gt; (where &lt;code&gt;F&lt;/code&gt; must be one of &lt;code&gt;float&lt;/code&gt;, &lt;code&gt;double&lt;/code&gt;, or &lt;code&gt;real&lt;/code&gt;). When doing a multi-step computation, you may want to store intermediate results as &lt;code&gt;FPTemporary!F&lt;/code&gt;.</source>
          <target state="translated">궁극적으로 &lt;code&gt;F&lt;/code&gt; 유형의 결과를 산출하기 위해 계산의 임시를 저장할 때 사용할 가장 빠른 유형을 정의합니다 (여기서 &lt;code&gt;F&lt;/code&gt; 는 &lt;code&gt;float&lt;/code&gt; , &lt;code&gt;double&lt;/code&gt; 또는 &lt;code&gt;real&lt;/code&gt; 중 하나 여야 함 ). 다단계 계산을 수행 할 때 중간 결과를 &lt;code&gt;FPTemporary!F&lt;/code&gt; 로 저장할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="7510c989e941b6308941ea24aee5fb7c86db407f" translate="yes" xml:space="preserve">
          <source>Defines the minimum and maximum. These values are hookable by defining &lt;code&gt;Hook.min&lt;/code&gt; and/or &lt;code&gt;Hook.max&lt;/code&gt;.</source>
          <target state="translated">최소 및 최대를 정의합니다. 이러한 값은 Hook.min 및 / 또는 &lt;code&gt;Hook.max&lt;/code&gt; 를 정의 &lt;code&gt;Hook.min&lt;/code&gt; 후크 가능 합니다.</target>
        </trans-unit>
        <trans-unit id="de7aa10564ec957fefcba6baa79ce725c7abf349" translate="yes" xml:space="preserve">
          <source>Defines the policy used by this mutex. Currently, two policies are defined.</source>
          <target state="translated">이 뮤텍스가 사용하는 정책을 정의합니다. 현재 두 가지 정책이 정의되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="b305949e5df45bb169d88a908bbe6d1143c90bf8" translate="yes" xml:space="preserve">
          <source>Defines the swapping strategy for algorithms that need to swap elements in a range (such as partition and sort). The strategy concerns the swapping of elements that are not the core concern of the algorithm. For example, consider an algorithm that sorts &lt;code&gt;[ &quot;abc&quot;, &quot;b&quot;, &quot;aBc&quot; ]&lt;/code&gt; according to &lt;code&gt;toUpper(a) &amp;lt; toUpper(b)&lt;/code&gt;. That algorithm might choose to swap the two equivalent strings &lt;code&gt;&quot;abc&quot;&lt;/code&gt; and &lt;code&gt;&quot;aBc&quot;&lt;/code&gt;. That does not affect the sorting since both &lt;code&gt;[&quot;abc&quot;, &quot;aBc&quot;, &quot;b&quot; ]&lt;/code&gt; and &lt;code&gt;[ &quot;aBc&quot;, &quot;abc&quot;, &quot;b&quot; ]&lt;/code&gt; are valid outcomes.</source>
          <target state="translated">범위의 요소 (예 : 파티션 및 정렬)를 교체해야하는 알고리즘의 교체 전략을 정의합니다. 이 전략은 알고리즘의 핵심 관심사가 아닌 요소의 교환과 관련이 있습니다. 예를 들어 &lt;code&gt;toUpper(a) &amp;lt; toUpper(b)&lt;/code&gt; 에 따라 &lt;code&gt;[ &quot;abc&quot;, &quot;b&quot;, &quot;aBc&quot; ]&lt;/code&gt; 를 정렬하는 알고리즘을 고려하십시오 . 해당 알고리즘은 두 개의 동등한 문자열 &lt;code&gt;&quot;abc&quot;&lt;/code&gt; 및 &lt;code&gt;&quot;aBc&quot;&lt;/code&gt; 를 교체하도록 선택할 수 있습니다 . &lt;code&gt;[&quot;abc&quot;, &quot;aBc&quot;, &quot;b&quot; ]&lt;/code&gt; 및 &lt;code&gt;[ &quot;aBc&quot;, &quot;abc&quot;, &quot;b&quot; ]&lt;/code&gt; 모두 유효한 결과 이므로 정렬에 영향을 미치지 않습니다.</target>
        </trans-unit>
        <trans-unit id="4ffb8042426740aa5362d442a645d2b525c7e4eb" translate="yes" xml:space="preserve">
          <source>Defines unary operators &lt;code&gt;+&lt;/code&gt;, &lt;code&gt;-&lt;/code&gt;, &lt;code&gt;~&lt;/code&gt;, &lt;code&gt;++&lt;/code&gt;, and &lt;code&gt;--&lt;/code&gt;. Unary &lt;code&gt;+&lt;/code&gt; is not overridable and always has built-in behavior (returns &lt;code&gt;this&lt;/code&gt;). For the others, if &lt;code&gt;Hook&lt;/code&gt; defines &lt;code&gt;hookOpUnary&lt;/code&gt;, &lt;code&gt;opUnary&lt;/code&gt; forwards to &lt;code&gt; Checked!(typeof(hook.hookOpUnary!op(get)), Hook)(hook.hookOpUnary!op(get))&lt;/code&gt;.</source>
          <target state="translated">단항 연산자 &lt;code&gt;+&lt;/code&gt; , &lt;code&gt;-&lt;/code&gt; , &lt;code&gt;~&lt;/code&gt; , &lt;code&gt;++&lt;/code&gt; 및 &lt;code&gt;--&lt;/code&gt; 정의합니다 . 단항 &lt;code&gt;+&lt;/code&gt; 는 재정의 할 수 없으며 항상 기본 제공 동작 &lt;code&gt;this&lt;/code&gt; 있습니다 (이 값을 반환 함 ). 다른 경우, &lt;code&gt;Hook&lt;/code&gt; 가 &lt;code&gt;hookOpUnary&lt;/code&gt; 를 정의 하면 &lt;code&gt;opUnary&lt;/code&gt; 는 &lt;code&gt; Checked!(typeof(hook.hookOpUnary!op(get)), Hook)(hook.hookOpUnary!op(get))&lt;/code&gt; 됩니다.</target>
        </trans-unit>
        <trans-unit id="c91bdc265815b43c5de3c96f45a415a58fc03b3a" translate="yes" xml:space="preserve">
          <source>Defines various character sets.</source>
          <target state="translated">다양한 문자 집합을 정의합니다.</target>
        </trans-unit>
        <trans-unit id="91c4c727f1758e45e932ce0db96676cf294ad1a7" translate="yes" xml:space="preserve">
          <source>Defining a Class</source>
          <target state="translated">클래스 정의</target>
        </trans-unit>
        <trans-unit id="253771ce82d51dcb870328ec077ebadd1937c2b0" translate="yes" xml:space="preserve">
          <source>Defining an Objective-C class is exactly the same as declaring an external class but it should not be declared as &lt;code&gt;extern&lt;/code&gt;.</source>
          <target state="translated">Objective-C 클래스를 정의하는 것은 외부 클래스를 선언하는 것과 정확히 동일하지만 &lt;code&gt;extern&lt;/code&gt; 으로 선언해서는 안됩니다 .</target>
        </trans-unit>
        <trans-unit id="49228588f4c386e959561b07cb41a3da0cc8a81a" translate="yes" xml:space="preserve">
          <source>Definitions and Terms</source>
          <target state="translated">정의와 용어</target>
        </trans-unit>
        <trans-unit id="ebbaa67091704824d3f48a282a09651d409aa6bd" translate="yes" xml:space="preserve">
          <source>Definitions from *.ddoc files specified on the command line.</source>
          <target state="translated">명령 행에 지정된 * .ddoc 파일의 정의</target>
        </trans-unit>
        <trans-unit id="a576cd4219d3b8794f54a95b3ea7cef6eaff9c96" translate="yes" xml:space="preserve">
          <source>Definitions from any Macros: sections.</source>
          <target state="translated">모든 매크로에서 정의 : 섹션.</target>
        </trans-unit>
        <trans-unit id="56ddc5afa8fef3fcf012921b1f9dae5145cf3f46" translate="yes" xml:space="preserve">
          <source>Definitions from file specified by &lt;a href=&quot;https://dlang.org/dmd-windows.html&quot;&gt;sc.ini&lt;/a&gt;'s or &lt;a href=&quot;https://dlang.org/dmd-linux.html#dmd_conf&quot;&gt;dmd.conf&lt;/a&gt; DDOCFILE setting.</source>
          <target state="translated">&lt;a href=&quot;https://dlang.org/dmd-windows.html&quot;&gt;sc.ini&lt;/a&gt; 또는 &lt;a href=&quot;https://dlang.org/dmd-linux.html#dmd_conf&quot;&gt;dmd.conf&lt;/a&gt; DDOCFILE 설정으로 지정된 파일의 정의</target>
        </trans-unit>
        <trans-unit id="5248d2cbc097c85b5bf07bd79ad21d3dc04f00b6" translate="yes" xml:space="preserve">
          <source>Definitions of common Byte Order Marks. The elements of the &lt;code&gt;enum&lt;/code&gt; can used as indices into &lt;code&gt;bomTable&lt;/code&gt; to get matching &lt;code&gt;BOMSeq&lt;/code&gt;.</source>
          <target state="translated">일반적인 바이트 순서 마크의 정의. &lt;code&gt;enum&lt;/code&gt; 의 요소는 &lt;code&gt;bomTable&lt;/code&gt; 의 색인으로 사용하여 일치하는 &lt;code&gt;BOMSeq&lt;/code&gt; 를 얻을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7897876db0bd35868da0c36a32fa7a500fda668a" translate="yes" xml:space="preserve">
          <source>Definitions of special attributes recognized by the compiler.</source>
          <target state="translated">컴파일러가 인식하는 특수 속성의 정의.</target>
        </trans-unit>
        <trans-unit id="b21b82b54b0a65d096a65a8b2d7349eacef2dd27" translate="yes" xml:space="preserve">
          <source>Deflate algorithm. Use zlib library to compress</source>
          <target state="translated">알고리즘을 수축시킵니다. zlib 라이브러리를 사용하여 압축</target>
        </trans-unit>
        <trans-unit id="d3b60fd736fbc73cf4f2f050a5951f01d10ff552" translate="yes" xml:space="preserve">
          <source>Deinitialize the memory allocator</source>
          <target state="translated">메모리 할당 기 초기화 해제</target>
        </trans-unit>
        <trans-unit id="718411bfbf8f7d188783f4bac4960c2189d9cac7" translate="yes" xml:space="preserve">
          <source>Deinitializes the global state of the compiler.</source>
          <target state="translated">컴파일러의 전역 상태를 초기화 해제합니다.</target>
        </trans-unit>
        <trans-unit id="065cfc5102f580580f89796dcd1da1ae87b21082" translate="yes" xml:space="preserve">
          <source>Deinitializes the global variables of the DMD compiler.</source>
          <target state="translated">DMD 컴파일러의 전역 변수를 초기화 해제합니다.</target>
        </trans-unit>
        <trans-unit id="35ad6c0b40711e9f140e5814aaeef4e704df85cf" translate="yes" xml:space="preserve">
          <source>Delegate Layout</source>
          <target state="translated">델리게이트 레이아웃</target>
        </trans-unit>
        <trans-unit id="d47fb2fb1178c716e771f8849c7c3bc1aa8bb49f" translate="yes" xml:space="preserve">
          <source>Delegate constructor calls cannot appear after labels.</source>
          <target state="translated">레이블 뒤에 위임 생성자 호출을 표시 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="64b5c80659df5d38b23f9b3191515d8daefe2e21" translate="yes" xml:space="preserve">
          <source>Delegate to call afterwards</source>
          <target state="translated">나중에 전화를 위임</target>
        </trans-unit>
        <trans-unit id="7dcccba4f8856a9df41efcf1d5ea4f2cfd327cec" translate="yes" xml:space="preserve">
          <source>Delegates</source>
          <target state="translated">Delegates</target>
        </trans-unit>
        <trans-unit id="3cf9845d1e82b5c764efd1c97377bd5fd9ba42fb" translate="yes" xml:space="preserve">
          <source>Delegates are</source>
          <target state="translated">대리인은</target>
        </trans-unit>
        <trans-unit id="16abb00eb4427b3b72f26ec632c009b0430dcf6f" translate="yes" xml:space="preserve">
          <source>Delegates are an aggregate of two pieces of data: an object reference and a pointer to a non-static member function, or a pointer to a closure and a pointer to a nested function. The object reference forms the &lt;code&gt;this&lt;/code&gt; pointer when the function is called.</source>
          <target state="translated">델리게이트는 객체 참조와 비 정적 멤버 함수에 대한 포인터 또는 클로저에 대한 포인터와 중첩 된 함수에 대한 포인터라는 두 가지 데이터의 집합입니다. 함수가 호출 될 때 객체 참조가 &lt;code&gt;this&lt;/code&gt; 포인터를 형성합니다 .</target>
        </trans-unit>
        <trans-unit id="4aec14b7fdac5fb0ecec8f415ab6eb69aa261acb" translate="yes" xml:space="preserve">
          <source>Delegates are called analogously to function pointers:</source>
          <target state="translated">대표는 함수 포인터와 유사하게 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="2558e9f7d9f5526e4364edc3b8db3d61cf86460c" translate="yes" xml:space="preserve">
          <source>Delegates are declared similarly to function pointers:</source>
          <target state="translated">델리게이트는 함수 포인터와 유사하게 선언됩니다.</target>
        </trans-unit>
        <trans-unit id="aa625441b78d7acde925782444188a7c87208857" translate="yes" xml:space="preserve">
          <source>Delegates are formatted by &lt;code&gt;ReturnType delegate(Parameters) FunctionAttributes&lt;/code&gt;</source>
          <target state="translated">대리인은 &lt;code&gt;ReturnType delegate(Parameters) FunctionAttributes&lt;/code&gt; 로 형식이 지정됩니다.</target>
        </trans-unit>
        <trans-unit id="5e1b39ccb37a9961d1255101485bf15889e010ca" translate="yes" xml:space="preserve">
          <source>Delegates are returned with the pointer to the function in EDX and the context pointer in EAX.</source>
          <target state="translated">EDX의 함수에 대한 포인터와 EAX의 컨텍스트 포인터와 함께 대리자가 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="052b6f63bd5851cead5b4c172e8f935a644d89b8" translate="yes" xml:space="preserve">
          <source>Delegates cannot be initialized with static member functions or non-member functions.</source>
          <target state="translated">정적 멤버 함수 또는 비 멤버 함수로 대리자를 초기화 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="7c7d30725d61528bbe87347b21c48cb4af14cdd7" translate="yes" xml:space="preserve">
          <source>Delegates to non-static nested functions contain two pieces of data: the pointer to the stack frame of the lexically enclosing function (called the</source>
          <target state="translated">정적이 아닌 중첩 함수에 대한 위임에는 두 개의 데이터가 포함됩니다. 어휘 적으로 둘러싸는 함수의 스택 프레임에 대한 포인터 (</target>
        </trans-unit>
        <trans-unit id="df2bc9c8ae8ec095a651df2d9f40d26505be447e" translate="yes" xml:space="preserve">
          <source>Delegates vs interfaces</source>
          <target state="translated">대리인 대 인터페이스</target>
        </trans-unit>
        <trans-unit id="d54452ca4b1bb4f12762b945e239935abe5fa967" translate="yes" xml:space="preserve">
          <source>Delegates, Function Pointers, and Closures</source>
          <target state="translated">델리게이트, 함수 포인터 및 클로저</target>
        </trans-unit>
        <trans-unit id="9c2f909da974c69b9255abf22c4ae5cb45c5d450" translate="yes" xml:space="preserve">
          <source>Delegating the kind of operation to &quot;g&quot; flag is soon to be phased out along with the ability to choose the exact matching scheme. The choice of matching scheme to use depends highly on the pattern kind and can done automatically on case by case basis.</source>
          <target state="translated">정확한 일치 체계를 선택할 수있는 기능과 함께 작업 종류를 &quot;g&quot;플래그로 위임하는 단계가 곧 중단됩니다. 사용할 매칭 방식의 선택은 패턴 종류에 따라 크게 달라지며 사례별로 자동으로 수행 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f6fdbe48dc54dd86f63097a03bd24094dedd713a" translate="yes" xml:space="preserve">
          <source>Delete</source>
          <target state="translated">Delete</target>
        </trans-unit>
        <trans-unit id="65ff71d2eb372c56b3f421a32122f09cb83f3b55" translate="yes" xml:space="preserve">
          <source>Delete Expressions</source>
          <target state="translated">식 삭제</target>
        </trans-unit>
        <trans-unit id="8f55705e486ea8516926708c08c13c9256e8a95e" translate="yes" xml:space="preserve">
          <source>Delete a file.</source>
          <target state="translated">파일을 삭제하십시오.</target>
        </trans-unit>
        <trans-unit id="972202c713fa07c93a56a91c10a0682843f3a8e5" translate="yes" xml:space="preserve">
          <source>Delete de from the archive.</source>
          <target state="translated">아카이브에서 de를 삭제하십시오.</target>
        </trans-unit>
        <trans-unit id="88fe1a4f86d7d55ef149bd6699c8cb4ae2ad5354" translate="yes" xml:space="preserve">
          <source>Delete entry in AA, return true if it was present</source>
          <target state="translated">AA에서 항목을 삭제하고 존재하면 true를 리턴하십시오.</target>
        </trans-unit>
        <trans-unit id="2f7a502591586046031c9af95e9952db392fbf2f" translate="yes" xml:space="preserve">
          <source>Delete exception instance &lt;code&gt;t&lt;/code&gt; from the exception pool. Must have been allocated with &lt;code&gt;_d_newThrowable()&lt;/code&gt;. This is meant to be called at the close of a catch block. It's nothrow because otherwise any function with a catch block could not be nothrow.</source>
          <target state="translated">예외 풀에서 예외 인스턴스 &lt;code&gt;t&lt;/code&gt; 를 삭제 하십시오. &lt;code&gt;_d_newThrowable()&lt;/code&gt; 으로 할당되어 있어야합니다 . 캐치 블록이 닫힐 때 호출됩니다. 캐치 블록이있는 함수는 안됩니다.</target>
        </trans-unit>
        <trans-unit id="5dfa5a5b1782a414f9933fb08f5b7f16627c244b" translate="yes" xml:space="preserve">
          <source>Delete existing file, write new file</source>
          <target state="translated">기존 파일 삭제, 새 파일 작성</target>
        </trans-unit>
        <trans-unit id="046b836f5646c2c23db59e441ec8c005c9a8f702" translate="yes" xml:space="preserve">
          <source>Delete file &lt;code&gt;name&lt;/code&gt;.</source>
          <target state="translated">파일 &lt;code&gt;name&lt;/code&gt; 삭제하십시오 .</target>
        </trans-unit>
        <trans-unit id="d9e7b44b2cadf44f0c32b15240292c8452debe64" translate="yes" xml:space="preserve">
          <source>Deleting arrays</source>
          <target state="translated">배열 삭제</target>
        </trans-unit>
        <trans-unit id="0fdf5407bec76f65af9589ccf41be8c79bf847a1" translate="yes" xml:space="preserve">
          <source>Deleting arrays of structs</source>
          <target state="translated">구조체 배열 삭제</target>
        </trans-unit>
        <trans-unit id="4254b9286de9f21e4cee34675ef4eebdc65ff8c6" translate="yes" xml:space="preserve">
          <source>Deleting classes</source>
          <target state="translated">수업 삭제</target>
        </trans-unit>
        <trans-unit id="ed4c149e0b712f4e2bb72b0013511d6f061d5740" translate="yes" xml:space="preserve">
          <source>Deleting interfaces</source>
          <target state="translated">인터페이스 삭제</target>
        </trans-unit>
        <trans-unit id="ae17b3b5e7a92728accc290c8bf686e71c3e3517" translate="yes" xml:space="preserve">
          <source>Deleting structs</source>
          <target state="translated">구조체 삭제</target>
        </trans-unit>
        <trans-unit id="be9605dcb1e588f88c8bee392dc7b467d126321c" translate="yes" xml:space="preserve">
          <source>Delimited Strings</source>
          <target state="translated">구분 된 문자열</target>
        </trans-unit>
        <trans-unit id="9e387962609f0e1e964c7e568f72f9e7ae3c3956" translate="yes" xml:space="preserve">
          <source>Delimited strings use various forms of delimiters. The delimiter, whether a character or identifer, must immediately follow the &quot; without any intervening whitespace. The terminating delimiter must immediately precede the closing &quot; without any intervening whitespace. A</source>
          <target state="translated">구분 된 문자열은 다양한 형식의 구분자를 사용합니다. 문자 든 식별자 든 구분 기호는 중간에 공백없이 &quot;&quot;바로 뒤에 와야합니다. 종료 구분 기호는 중간에 공백없이 닫는 &quot;바로 앞에 와야합니다. ㅏ</target>
        </trans-unit>
        <trans-unit id="5dec72453c3798227c53d3e18645cc781f128098" translate="yes" xml:space="preserve">
          <source>Demangle D mangled names.</source>
          <target state="translated">얽힌 D 맹 글링 된 이름.</target>
        </trans-unit>
        <trans-unit id="ddfd9e8118efdecff8dd2d2af4b014f3b4804c01" translate="yes" xml:space="preserve">
          <source>Demangles D mangled names. If it is not a D mangled name, it returns its argument name.</source>
          <target state="translated">D 맹 글링 된 이름을 나타냅니다. D 맹 글링 된 이름이 아닌 경우 인수 이름을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="debfefbb9cba46b7cd15ad0f72aee393c6142eb7" translate="yes" xml:space="preserve">
          <source>Demangles a D mangled type.</source>
          <target state="translated">D 맹 글링 유형을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="ef35d5b2d9137e56445dcb13b1926641ac1748d1" translate="yes" xml:space="preserve">
          <source>Denis Shelomovskij</source>
          <target state="translated">데니스 셸 로브 스키</target>
        </trans-unit>
        <trans-unit id="b119328fcf0f1a8506c71d6d5c90a4b602176677" translate="yes" xml:space="preserve">
          <source>Depending on the architecture, compiler flags may be required to activate support for SIMD types.</source>
          <target state="translated">아키텍처에 따라 SIMD 유형에 대한 지원을 활성화하기 위해 컴파일러 플래그가 필요할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5800c53d5e6610496fae36318de2fc0ee48759c2" translate="yes" xml:space="preserve">
          <source>Depending on the sign, NANs go to either end of the spectrum.</source>
          <target state="translated">부호에 따라 NAN은 스펙트럼의 한쪽 끝으로 이동합니다.</target>
        </trans-unit>
        <trans-unit id="eef926e2307412ea5d18dc2f434ab76df97c9426" translate="yes" xml:space="preserve">
          <source>Depending on the struct layout, the compiler may generate the following internal postblit functions:</source>
          <target state="translated">구조체 레이아웃에 따라 컴파일러는 다음과 같은 내부 포스트 블릿 함수를 생성 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="527600bf0272b6bf3abcb495a99c6ee346bb82b2" translate="yes" xml:space="preserve">
          <source>Deprecated</source>
          <target state="translated">Deprecated</target>
        </trans-unit>
        <trans-unit id="42a66abe1669ce3ffad7695dbe407c22ed591eb2" translate="yes" xml:space="preserve">
          <source>Deprecated Functions</source>
          <target state="translated">더 이상 사용되지 않는 함수</target>
        </trans-unit>
        <trans-unit id="bfc32553e9a3941dedadb9fb40b33e7008f653d9" translate="yes" xml:space="preserve">
          <source>Deprecated Soft Heap Limit Interface</source>
          <target state="translated">더 이상 사용되지 않는 소프트 힙 제한 인터페이스</target>
        </trans-unit>
        <trans-unit id="b2a248487f391de50bfbecd25bb7aaa1ed569640" translate="yes" xml:space="preserve">
          <source>Deprecated. Please use &lt;a href=&quot;#enforce&quot;&gt;&lt;code&gt;enforce&lt;/code&gt;&lt;/a&gt; instead. This function will be removed 2.089.</source>
          <target state="translated">더 이상 사용되지 않습니다. 사용하시기 바랍니다 &lt;a href=&quot;#enforce&quot;&gt; &lt;code&gt;enforce&lt;/code&gt; &lt;/a&gt; 대신. 이 기능은 2.089에서 제거됩니다.</target>
        </trans-unit>
        <trans-unit id="2c79ea7bd700047cc619e794290dc3e2dc523454" translate="yes" xml:space="preserve">
          <source>Deprecated. Please use &lt;a href=&quot;#round&quot;&gt;&lt;code&gt;round&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="translated">더 이상 사용되지 않습니다. 사용하십시오 &lt;a href=&quot;#round&quot;&gt; &lt;code&gt;round&lt;/code&gt; &lt;/a&gt; 대신.</target>
        </trans-unit>
        <trans-unit id="1b9904893da49653e1dba2c46ecfb0656a693e60" translate="yes" xml:space="preserve">
          <source>DeprecatedAttribute</source>
          <target state="translated">DeprecatedAttribute</target>
        </trans-unit>
        <trans-unit id="ee777837c7008ab314d60ab6340d94b7bb481757" translate="yes" xml:space="preserve">
          <source>Dereferencing a pointer that is not</source>
          <target state="translated">그렇지 않은 포인터 역 참조</target>
        </trans-unit>
        <trans-unit id="0474d0915ec1aafb67985d6471d5cd7b881a0fc7" translate="yes" xml:space="preserve">
          <source>Deregisters the calling thread from use with the runtime. If this routine is called for a thread which is not registered, the result is undefined.</source>
          <target state="translated">런타임에서 사용하지 않는 호출 스레드를 등록 취소합니다. 이 루틴이 등록되지 않은 스레드에 대해 호출되면 결과는 정의되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="1ca49bb05cb1ee30fb0317e206c0b46b922133c6" translate="yes" xml:space="preserve">
          <source>Deregisters the given thread from use with the runtime. If this routine is called for a thread which is not registered, the result is undefined.</source>
          <target state="translated">주어진 스레드가 런타임과 함께 사용하지 않도록 등록 해제합니다. 이 루틴이 등록되지 않은 스레드에 대해 호출되면 결과는 정의되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="081ea626fb636d13a422e02a8223b6bacf54ed06" translate="yes" xml:space="preserve">
          <source>Derived Data Types</source>
          <target state="translated">파생 데이터 형식</target>
        </trans-unit>
        <trans-unit id="dc979d243485252a4a9336b834ea499511e48f35" translate="yes" xml:space="preserve">
          <source>Derived classes inherit any allocator from their base class, if one is not specified.</source>
          <target state="translated">파생 클래스는 지정되지 않은 경우 기본 클래스에서 할당자를 상속합니다.</target>
        </trans-unit>
        <trans-unit id="ecdd58700bf7c79b9590aa6ba4f17a59fdf13cc5" translate="yes" xml:space="preserve">
          <source>Derived classes inherit any deallocator from their base class, if one is not specified.</source>
          <target state="translated">파생 클래스는 지정되지 않은 경우 기본 클래스에서 할당 취소기를 상속합니다.</target>
        </trans-unit>
        <trans-unit id="01e635f27ec24e2d0be75256adcfabf099c3a6e6" translate="yes" xml:space="preserve">
          <source>Desc</source>
          <target state="translated">Desc</target>
        </trans-unit>
        <trans-unit id="d55435d9dcbb175dba229d196e836af1eeb181cc" translate="yes" xml:space="preserve">
          <source>Describes a back-end target. At present it is incomplete, but in the future it should grow to contain most or all target machine and target O/S specific information.</source>
          <target state="translated">백엔드 대상을 설명합니다. 현재는 불완전하지만 앞으로는 대부분 또는 모든 대상 시스템과 대상 O / S 관련 정보를 포함하도록 성장해야합니다.</target>
        </trans-unit>
        <trans-unit id="17519f0a081d4de96e9a8327052145d4da388c05" translate="yes" xml:space="preserve">
          <source>Describes how an argument type is passed to a function on target.</source>
          <target state="translated">인수 유형이 대상의 함수에 전달되는 방법을 설명합니다.</target>
        </trans-unit>
        <trans-unit id="55f8ebc805e65b5b71ddafdae390e3be2bcd69af" translate="yes" xml:space="preserve">
          <source>Description</source>
          <target state="translated">Description</target>
        </trans-unit>
        <trans-unit id="04f0f87cdf30f41863595935bdd7b915c84a0c3d" translate="yes" xml:space="preserve">
          <source>Deseret</source>
          <target state="translated">Deseret</target>
        </trans-unit>
        <trans-unit id="5c22a4f35a8597f537d66c0b77083b1157bffb80" translate="yes" xml:space="preserve">
          <source>Destination string</source>
          <target state="translated">대상 문자열</target>
        </trans-unit>
        <trans-unit id="839c441dcc29d361bfacf38afa416f18a1637928" translate="yes" xml:space="preserve">
          <source>Destroy A Prepared Statement Object</source>
          <target state="translated">준비된 명령문 오브젝트 삭제</target>
        </trans-unit>
        <trans-unit id="2ac4f537d3b2f32d96a398d33d05ec08395a3c21" translate="yes" xml:space="preserve">
          <source>Destroys and then deallocates (using &lt;code&gt;alloc&lt;/code&gt;) the object pointed to by a pointer, the class object referred to by a &lt;code&gt;class&lt;/code&gt; or &lt;code&gt;interface&lt;/code&gt; reference, or an entire array. It is assumed the respective entities had been allocated with the same allocator.</source>
          <target state="translated">포인터가 가리키는 객체, &lt;code&gt;class&lt;/code&gt; 또는 &lt;code&gt;interface&lt;/code&gt; 참조가 참조 하는 클래스 객체 또는 전체 배열을 파괴 한 다음 할당을 해제합니다 ( &lt;code&gt;alloc&lt;/code&gt; 사용 ) . 각 엔티티에 동일한 할당자가 할당 된 것으로 가정합니다.</target>
        </trans-unit>
        <trans-unit id="c7c2581b265a4916c03d15bb749b173d1a0e008f" translate="yes" xml:space="preserve">
          <source>Destroys and then deallocates (using &lt;code&gt;allocatorFor!T&lt;/code&gt;) the object pointed to by a pointer, the class object referred to by a &lt;code&gt;class&lt;/code&gt; or &lt;code&gt;interface&lt;/code&gt; reference, or an entire array. It is assumed the respective entities had been allocated with the same allocator.</source>
          <target state="translated">포인터가 가리키는 객체, &lt;code&gt;class&lt;/code&gt; 또는 &lt;code&gt;interface&lt;/code&gt; 참조가 참조 하는 클래스 객체 또는 전체 배열 을 삭제 한 다음 할당을 해제합니다 ( &lt;code&gt;allocatorFor!T&lt;/code&gt; 사용하여 할당 ) . 각 엔티티에 동일한 할당자가 할당 된 것으로 가정합니다.</target>
        </trans-unit>
        <trans-unit id="461b0c4ed643cec21e62641f68d242b11940c0e4" translate="yes" xml:space="preserve">
          <source>Destroys and then deallocates a multidimensional array, assuming it was created with makeMultidimensionalArray and the same allocator was used.</source>
          <target state="translated">makeMultidimensionalArray로 생성되었고 동일한 할당자가 사용되었다고 가정하여 다차원 배열을 삭제 한 다음 할당 해제합니다.</target>
        </trans-unit>
        <trans-unit id="a2ba51b01f5575967e896aa687ec2875a9254daf" translate="yes" xml:space="preserve">
          <source>Destroys and then deallocates an object.</source>
          <target state="translated">객체를 파괴하고 할당 해제합니다.</target>
        </trans-unit>
        <trans-unit id="f22d78fd51640f5bf6ec9cfaee6fb8da07259389" translate="yes" xml:space="preserve">
          <source>Destroys the given object and optionally resets to initial state. It's used to destroy an object, calling its destructor or finalizer so it no longer references any other objects. It does</source>
          <target state="translated">주어진 객체를 파괴하고 선택적으로 초기 상태로 재설정합니다. 더 이상 다른 객체를 참조하지 않도록 객체를 소멸하거나 소멸자 또는 종료자를 호출하는 데 사용됩니다. 그렇습니다</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
