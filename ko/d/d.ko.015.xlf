<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="d">
    <body>
      <group id="d">
        <trans-unit id="d13659d418fd5667a2a45e0c6e1f23ef28169af7" translate="yes" xml:space="preserve">
          <source>A range type dependent on &lt;code&gt;R1&lt;/code&gt; and &lt;code&gt;R2&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;R1&lt;/code&gt; 및 &lt;code&gt;R2&lt;/code&gt; 에 따라 범위 유형 입니다.</target>
        </trans-unit>
        <trans-unit id="aca5fa10af5948aacb0618dcc7659c011b96c280" translate="yes" xml:space="preserve">
          <source>A range with each fun applied to all the elements. If there is more than one fun, the element type will be &lt;code&gt;Tuple&lt;/code&gt; containing one element for each fun.</source>
          <target state="translated">모든 요소에 각 재미가 적용되는 범위입니다. 하나 이상의 재미가있는 경우 요소 유형은 각 재미마다 하나의 요소를 포함하는 &lt;code&gt;Tuple&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="a647974a789216b78223c54f30ddb7dbc6f42bec" translate="yes" xml:space="preserve">
          <source>A reader sub-mutex.</source>
          <target state="translated">리더 서브 뮤텍스</target>
        </trans-unit>
        <trans-unit id="78aacc289e57898ba520714d51228a88f7785c8a" translate="yes" xml:space="preserve">
          <source>A real number.</source>
          <target state="translated">실수</target>
        </trans-unit>
        <trans-unit id="e5279da871ece6d65446e8b83a539f4a46cf9e5b" translate="yes" xml:space="preserve">
          <source>A record has fields separated by a comma (customizable)</source>
          <target state="translated">레코드에는 쉼표로 구분 된 필드가 있습니다 (사용자 정의 가능)</target>
        </trans-unit>
        <trans-unit id="8d0f9f69bb9f8022d38780e473a8ed97e90abb3f" translate="yes" xml:space="preserve">
          <source>A record is separated by a new line (CRLF,LF,CR)</source>
          <target state="translated">레코드는 줄 바꿈 (CRLF, LF, CR)으로 구분됩니다.</target>
        </trans-unit>
        <trans-unit id="5838b1b8195e7908693ea69a0ccd678dde645bf2" translate="yes" xml:space="preserve">
          <source>A reference counted struct that wraps the dynamic allocator interface. This should be used wherever a uniform type is required for encapsulating various allocator implementations.</source>
          <target state="translated">동적 할당 자 인터페이스를 래핑하는 참조 카운트 구조체. 이것은 다양한 할당 자 구현을 캡슐화하기 위해 균일 한 유형이 필요한 경우에 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="073ff9e700584023c7f918b3c35ddc44ddc93350" translate="yes" xml:space="preserve">
          <source>A reference counted struct that wraps the dynamic shared allocator interface. This should be used wherever a uniform type is required for encapsulating various allocator implementations.</source>
          <target state="translated">동적 공유 할당 자 인터페이스를 래핑하는 참조 횟수 구조체입니다. 이것은 다양한 할당 자 구현을 캡슐화하기 위해 균일 한 유형이 필요한 경우에 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="42e7f065a5d8231c47d820792cd468e9083d8ea9" translate="yes" xml:space="preserve">
          <source>A reference to &lt;code&gt;this&lt;/code&gt;.</source>
          <target state="translated">참조에 &lt;code&gt;this&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5eeb6dd68fac30b5064fbb6c8083f183c09787e7" translate="yes" xml:space="preserve">
          <source>A reference to a class, or an interface. We need this when we point to a base class (we must record what the type is).</source>
          <target state="translated">클래스 또는 인터페이스에 대한 참조 기본 클래스를 가리킬 때이 유형이 필요합니다 (유형이 무엇인지 기록해야 함).</target>
        </trans-unit>
        <trans-unit id="30938b6d6a99ea62f4185cf08673d2059303fed2" translate="yes" xml:space="preserve">
          <source>A reference to a declaration marked with the &lt;code&gt;@disable&lt;/code&gt; attribute causes a compile time error. This can be used to explicitly disallow certain operations or overloads at compile time rather than relying on generating a runtime error.</source>
          <target state="translated">&lt;code&gt;@disable&lt;/code&gt; 속성으로 표시된 선언을 참조 하면 컴파일 시간 오류가 발생합니다. 런타임 오류 생성에 의존하지 않고 컴파일 타임에 특정 작업이나 과부하를 명시 적으로 허용하지 않는 데 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="68e9ca0fa77d6187ddb37422879e54ea57fecf2e" translate="yes" xml:space="preserve">
          <source>A reference to an object, interface, associative array, or an array slice to initialize the &lt;code&gt;Rebindable&lt;/code&gt; with.</source>
          <target state="translated">&lt;code&gt;Rebindable&lt;/code&gt; 을 초기화 할 객체, 인터페이스, 연관 배열 또는 배열 슬라이스에 대한 참조 입니다.</target>
        </trans-unit>
        <trans-unit id="c12cdfe35d9669562e6c6517387b415345dc5100" translate="yes" xml:space="preserve">
          <source>A reference to the &lt;code&gt;Date&lt;/code&gt; (&lt;code&gt;this&lt;/code&gt;).</source>
          <target state="translated">&lt;code&gt;Date&lt;/code&gt; 대한 참조 ( &lt;code&gt;this&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="e807fe0dbc26276ecc9263d30854a040d1f0bceb" translate="yes" xml:space="preserve">
          <source>A reference to the &lt;code&gt;DateTime&lt;/code&gt; (&lt;code&gt;this&lt;/code&gt;).</source>
          <target state="translated">&lt;code&gt;DateTime&lt;/code&gt; 에 대한 참조입니다 ( &lt;code&gt;this&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="5ecb5758110283986b0f628f0dee35b28e439047" translate="yes" xml:space="preserve">
          <source>A reference to the &lt;code&gt;TimeOfDay&lt;/code&gt; (&lt;code&gt;this&lt;/code&gt;).</source>
          <target state="translated">&lt;code&gt;TimeOfDay&lt;/code&gt; ( &lt;code&gt;this&lt;/code&gt; )에 대한 참조 입니다.</target>
        </trans-unit>
        <trans-unit id="3643ec80e8e77b31f829b56e6385e6b5fae1a8bb" translate="yes" xml:space="preserve">
          <source>A reference to the allocated memory on success or &lt;code&gt;null&lt;/code&gt; if &lt;code&gt;sz&lt;/code&gt; is zero or the pointer does not point to the base of an GC allocated memory block.</source>
          <target state="translated">성공에 할당 된 메모리에 대한 참조 &lt;code&gt;null&lt;/code&gt; 경우 &lt;code&gt;sz&lt;/code&gt; 제로 또는 포인터는 GC에 할당 된 메모리 블록의베이스를 가리 키지 않는다.</target>
        </trans-unit>
        <trans-unit id="0d5352d81e29a32196c5f56f2bb9ed97b987c1d7" translate="yes" xml:space="preserve">
          <source>A reference to the allocated memory or null if insufficient memory is available.</source>
          <target state="translated">할당 된 메모리에 대한 참조이거나 사용 가능한 메모리가 충분하지 않은 경우 null입니다.</target>
        </trans-unit>
        <trans-unit id="e37e582469e7c67872dafc3589a5e25b3c66b5ab" translate="yes" xml:space="preserve">
          <source>A reference to the current thread. May be null.</source>
          <target state="translated">현재 스레드에 대한 참조 null 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a61f330905217e37d6323303c34b226425d66b17" translate="yes" xml:space="preserve">
          <source>A reference to the digest for convenient chaining.</source>
          <target state="translated">편리한 체인을위한 다이제스트에 대한 참조.</target>
        </trans-unit>
        <trans-unit id="20e52674df62aed2822a9ce68fb98c50fe7dd734" translate="yes" xml:space="preserve">
          <source>A reference to the initialized variable</source>
          <target state="translated">초기화 된 변수에 대한 참조</target>
        </trans-unit>
        <trans-unit id="1a73c900947644b46c70f39971b466339325ec9c" translate="yes" xml:space="preserve">
          <source>A reference to the library or null on error.</source>
          <target state="translated">라이브러리에 대한 참조 또는 오류시 null</target>
        </trans-unit>
        <trans-unit id="75039d96df258122331865dd56bd4d83100ff798" translate="yes" xml:space="preserve">
          <source>A reference to the library to unload.</source>
          <target state="translated">언로드 할 라이브러리에 대한 참조입니다.</target>
        </trans-unit>
        <trans-unit id="d686f93504e54ee14861d429718fa839597a8cdf" translate="yes" xml:space="preserve">
          <source>A reference to the newly created thread.</source>
          <target state="translated">새로 작성된 스레드에 대한 참조</target>
        </trans-unit>
        <trans-unit id="c9756cbec24ff837e6d02b449d53fc6cb5a1e5f3" translate="yes" xml:space="preserve">
          <source>A reference to the next error in the list. This is used when a new &lt;code&gt;Throwable&lt;/code&gt; is thrown from inside a &lt;code&gt;catch&lt;/code&gt; block. The originally caught &lt;code&gt;Exception&lt;/code&gt; will be chained to the new &lt;code&gt;Throwable&lt;/code&gt; via this field.</source>
          <target state="translated">목록에서 다음 오류에 대한 참조입니다. &lt;code&gt;catch&lt;/code&gt; 블록 내부에서 새로운 &lt;code&gt;Throwable&lt;/code&gt; 을 던질 때 사용됩니다 . 원래 포착 된 &lt;code&gt;Exception&lt;/code&gt; 는 이 필드를 통해 새 &lt;code&gt;Throwable&lt;/code&gt; 에 연결됩니다 .</target>
        </trans-unit>
        <trans-unit id="ff58948889bb0a36a8abceb97a8a3c148dcf9671" translate="yes" xml:space="preserve">
          <source>A refernce to the &lt;code&gt;Logger&lt;/code&gt; used to create this &lt;code&gt;LogEntry&lt;/code&gt;</source>
          <target state="translated">이 &lt;code&gt;LogEntry&lt;/code&gt; 를 작성하는 데 사용 된 &lt;code&gt;Logger&lt;/code&gt; 대한 참조</target>
        </trans-unit>
        <trans-unit id="91e4b10e829acb93ce7cd86702882a460a9c1e50" translate="yes" xml:space="preserve">
          <source>A regex engine state, as returned by &lt;code&gt;match&lt;/code&gt; family of functions.</source>
          <target state="translated">&lt;code&gt;match&lt;/code&gt; 함수 군에 의해 반환되는 정규식 엔진 상태 .</target>
        </trans-unit>
        <trans-unit id="2539e853fd15604cb6a934d48bc2528e82ab9538" translate="yes" xml:space="preserve">
          <source>A reimplemented interface must implement all the interface functions, it does not inherit them from a super class:</source>
          <target state="translated">다시 구현 된 인터페이스는 모든 인터페이스 함수를 구현해야하며, 수퍼 클래스에서 상속되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="306cb18355cd21a0060bd8023086f1a746ecc542" translate="yes" xml:space="preserve">
          <source>A relational operator can have &lt;code&gt;NaN&lt;/code&gt; operands. If either or both operands is &lt;code&gt;NaN&lt;/code&gt;, the floating point comparison operation returns as follows:</source>
          <target state="translated">관계 연산자에는 &lt;code&gt;NaN&lt;/code&gt; 피연산자 가있을 수 있습니다 . 피연산자 중 하나 또는 모두가 &lt;code&gt;NaN&lt;/code&gt; 인 경우 부동 소수점 비교 연산은 다음과 같이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="2fbb01cbf6b15e85576d1bc8dafb5f686611418c" translate="yes" xml:space="preserve">
          <source>A root module is one that will be compiled all the way to object code. This field holds the root module that caused this module to be loaded. If this module is a root module, then it will be set to &lt;code&gt;this&lt;/code&gt;. This is used to determine ownership of template instantiation.</source>
          <target state="translated">루트 모듈은 객체 코드까지 컴파일 될 모듈입니다. 이 필드에는이 모듈이로드 된 루트 모듈이 있습니다. 이 모듈이 루트 모듈 인 경우,이 설정됩니다 &lt;code&gt;this&lt;/code&gt; . 템플릿 인스턴스화의 소유권을 결정하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="bfb6ac8ef8ee222f7c87138ddd6e6d11dddde966" translate="yes" xml:space="preserve">
          <source>A scope block statement introduces a new scope for the &lt;a href=&quot;#BlockStatement&quot;&gt;&lt;i&gt;BlockStatement&lt;/i&gt;&lt;/a&gt;.</source>
          <target state="translated">범위 블록 명령문은 &lt;a href=&quot;#BlockStatement&quot;&gt;&lt;i&gt;BlockStatement에&lt;/i&gt;&lt;/a&gt; 대한 새로운 범위를 소개합니다 .</target>
        </trans-unit>
        <trans-unit id="4eca2516e751338cb4cea2d3632121becc1dcc07" translate="yes" xml:space="preserve">
          <source>A scope class is a class with the &lt;code&gt;scope&lt;/code&gt; attribute, as in:</source>
          <target state="translated">범위 클래스는 다음과 같이 &lt;code&gt;scope&lt;/code&gt; 속성 이있는 클래스입니다 .</target>
        </trans-unit>
        <trans-unit id="1726fb56d87e8ffffee60a1adced14592e54f844" translate="yes" xml:space="preserve">
          <source>A scope class reference can only appear as a function local variable. It must be declared as being &lt;code&gt;scope&lt;/code&gt;:</source>
          <target state="translated">범위 클래스 참조는 함수 로컬 변수로만 나타날 수 있습니다. &lt;code&gt;scope&lt;/code&gt; 로 선언되어야합니다 .</target>
        </trans-unit>
        <trans-unit id="c0af4522df69cbecf3e1a90ca6686769a3cc8194" translate="yes" xml:space="preserve">
          <source>A seed may be passed to &lt;code&gt;sum&lt;/code&gt;. Not only will this seed be used as an initial value, but its type will override all the above, and determine the algorithm and precision used for summation.</source>
          <target state="translated">시드는 &lt;code&gt;sum&lt;/code&gt; 에 전달 될 수 있습니다 . 이 시드는 초기 값으로 사용될뿐만 아니라 그 유형이 위의 모든 것을 무시하고 합산에 사용되는 알고리즘과 정밀도를 결정합니다.</target>
        </trans-unit>
        <trans-unit id="c8ed8bfa97374dda35f3e6d60a27183df8e3dd7b" translate="yes" xml:space="preserve">
          <source>A seedable random-number generator has the following additional features:</source>
          <target state="translated">시드 가능한 난수 생성기에는 다음과 같은 추가 기능이 있습니다.</target>
        </trans-unit>
        <trans-unit id="62eef04deeedb61ec809031e320e402553bde037" translate="yes" xml:space="preserve">
          <source>A semi-lazy parallel map that can be used for pipelining. The map functions are evaluated for the first &lt;code&gt;bufSize&lt;/code&gt; elements and stored in a buffer and made available to &lt;code&gt;popFront&lt;/code&gt;. Meanwhile, in the background a second buffer of the same size is filled. When the first buffer is exhausted, it is swapped with the second buffer and filled while the values from what was originally the second buffer are read. This implementation allows for elements to be written to the buffer without the need for atomic operations or synchronization for each write, and enables the mapping function to be evaluated efficiently in parallel.</source>
          <target state="translated">파이프 라이닝에 사용할 수있는 반 게으른 병렬 맵입니다. 맵 함수는 첫 번째 &lt;code&gt;bufSize&lt;/code&gt; 요소에 대해 평가 되고 버퍼에 저장되며 &lt;code&gt;popFront&lt;/code&gt; 에서 사용할 수 있습니다 . 한편, 백그라운드에서 동일한 크기의 제 2 버퍼가 채워진다. 첫 번째 버퍼가 소진되면 두 번째 버퍼와 교체되고 원래 두 번째 버퍼의 값을 읽는 동안 채워집니다. 이 구현은 원자 연산 또는 각 쓰기에 대한 동기화없이 요소를 버퍼에 쓸 수있게하며 매핑 기능을 효율적으로 병렬로 평가할 수있게합니다.</target>
        </trans-unit>
        <trans-unit id="a25d6360214ab107cc5a2690ac6934209de0713e" translate="yes" xml:space="preserve">
          <source>A set of arguments to a function with inout parameters is considered a match if any inout argument types match exactly, or:</source>
          <target state="translated">입력 매개 변수가있는 함수에 대한 인수 세트는 입력 인수 유형이 정확히 일치하는 경우 일치로 간주됩니다.</target>
        </trans-unit>
        <trans-unit id="51c642f510697a8d846cbe239c05d6e7f4bd433c" translate="yes" xml:space="preserve">
          <source>A set of functions in this module that do the substitution rely on a simple format to guide the process. In particular the table below applies to the &lt;code&gt;format&lt;/code&gt; argument of &lt;a href=&quot;#replaceFirst&quot;&gt;&lt;code&gt;replaceFirst&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#replaceAll&quot;&gt;&lt;code&gt;replaceAll&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">대체를 수행하는이 모듈의 함수 세트는 프로세스를 안내하기 위해 간단한 형식을 사용합니다. 특히 아래 표 는 &lt;a href=&quot;#replaceFirst&quot;&gt; &lt;code&gt;replaceFirst&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#replaceAll&quot;&gt; &lt;code&gt;replaceAll&lt;/code&gt; &lt;/a&gt; 의 &lt;code&gt;format&lt;/code&gt; 인수에 적용됩니다 .</target>
        </trans-unit>
        <trans-unit id="b8a9cfe24fb306eb618c433658da1dfff7fbe905" translate="yes" xml:space="preserve">
          <source>A shell command which is passed verbatim to the command interpreter. (See &lt;a href=&quot;#spawnShell&quot;&gt;&lt;code&gt;spawnShell&lt;/code&gt;&lt;/a&gt; for details.)</source>
          <target state="translated">명령 인터프리터에 그대로 전달되는 쉘 명령. (자세한 내용은 &lt;a href=&quot;#spawnShell&quot;&gt; &lt;code&gt;spawnShell&lt;/code&gt; &lt;/a&gt; 을 참조하십시오.)</target>
        </trans-unit>
        <trans-unit id="e6e6e41467f1af8066889b7eb3e8cd2ba5db578e" translate="yes" xml:space="preserve">
          <source>A shorthand for creating a custom multi-level fixed Trie from a &lt;code&gt;CodepointSet&lt;/code&gt;. &lt;code&gt;sizes&lt;/code&gt; are numbers of bits per level, with the most significant bits used first.</source>
          <target state="translated">&lt;code&gt;CodepointSet&lt;/code&gt; 에서 커스텀 멀티 레벨 고정 Trie를 생성하기위한 속기입니다 . &lt;code&gt;sizes&lt;/code&gt; 는 레벨 당 비트 수이며 가장 중요한 비트가 먼저 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="872a8839a08b7a547700d02979804255ca5dda79" translate="yes" xml:space="preserve">
          <source>A signed integer representing the unix time which is equivalent to the given std time.</source>
          <target state="translated">주어진 표준 시간과 동등한 유닉스 시간을 나타내는 부호있는 정수.</target>
        </trans-unit>
        <trans-unit id="f860d4a0b4e17f8f9f5a52ee6fbbcb2156c9580b" translate="yes" xml:space="preserve">
          <source>A signed integer representing the unix time which is equivalent to this SysTime.</source>
          <target state="translated">이 SysTime과 동등한 유닉스 시간을 나타내는 부호있는 정수.</target>
        </trans-unit>
        <trans-unit id="3616b970c3c6ad571e4bcd0ec81882f1b115ec64" translate="yes" xml:space="preserve">
          <source>A simple file cache that can be used to avoid reading the same file multiple times. It stores its cached files as &lt;a href=&quot;#FileAndLines&quot;&gt;&lt;code&gt;FileAndLines&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">동일한 파일을 여러 번 읽지 않도록하는 데 사용할 수있는 간단한 파일 캐시입니다. 캐시 된 파일을 &lt;a href=&quot;#FileAndLines&quot;&gt; &lt;code&gt;FileAndLines&lt;/code&gt; &lt;/a&gt; 로 저장합니다.</target>
        </trans-unit>
        <trans-unit id="baa475621014a28514997e0b8ab31fb33db431d4" translate="yes" xml:space="preserve">
          <source>A simple generic copy template would be:</source>
          <target state="translated">간단한 일반 복사 템플릿은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="20b05a6cb1c672b9ef624b2ff448b0500b9047e8" translate="yes" xml:space="preserve">
          <source>A simple property would be:</source>
          <target state="translated">간단한 속성은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="ba136270dcb78a01ac01f425897459708ac2204d" translate="yes" xml:space="preserve">
          <source>A simple wrapper around core.demangle.</source>
          <target state="translated">core.demangle 주위의 간단한 래퍼입니다.</target>
        </trans-unit>
        <trans-unit id="be6731f2a1c9e7c94bf4c940a35e7396dbfee3d9" translate="yes" xml:space="preserve">
          <source>A single entry point to lookup Unicode &lt;a href=&quot;#Code%20point&quot;&gt;code point&lt;/a&gt; sets by name or alias of a block, script or general category.</source>
          <target state="translated">블록, 스크립트 또는 일반 범주의 이름 또는 별명으로 유니 &lt;a href=&quot;#Code%20point&quot;&gt;코드 코드 포인트&lt;/a&gt; 세트 를 조회하는 단일 진입 점 입니다.</target>
        </trans-unit>
        <trans-unit id="79c7939d70d47eaa74b95a0d35217792acd405a3" translate="yes" xml:space="preserve">
          <source>A single random element drawn from the &lt;code&gt;range&lt;/code&gt;. If it can, it will return a &lt;code&gt;ref&lt;/code&gt; to the &lt;code&gt;range element&lt;/code&gt;, otherwise it will return a copy.</source>
          <target state="translated">&lt;code&gt;range&lt;/code&gt; 에서 가져온 단일 임의 요소 입니다. 가능한 경우 , &lt;code&gt;range element&lt;/code&gt; 대한 &lt;code&gt;ref&lt;/code&gt; 를 리턴하고 그렇지 않으면 사본을 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="660d1f6310c0c87621e9a54e4b08dfcdf5729188" translate="yes" xml:space="preserve">
          <source>A single random variate drawn from the uniform distribution between &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt;, whose type is the common type of these parameters</source>
          <target state="translated">&lt;code&gt;a&lt;/code&gt; 와 &lt;code&gt;b&lt;/code&gt; 사이의 균일 분포에서 도출 된 단일 랜덤 변량. 유형이 이러한 모수의 공통 유형</target>
        </trans-unit>
        <trans-unit id="0634725ae5a0e7183bfefc294b400ab01233d7f2" translate="yes" xml:space="preserve">
          <source>A single regular expression to match.</source>
          <target state="translated">일치하는 단일 정규식입니다.</target>
        </trans-unit>
        <trans-unit id="ec5a41e95c545f5b9ca17c3cce34db77407a6c8d" translate="yes" xml:space="preserve">
          <source>A single unsigned integer seed value, different on each successive call</source>
          <target state="translated">연속적인 호출마다 다른 단일 부호없는 정수 시드 값</target>
        </trans-unit>
        <trans-unit id="ae4b3bcc6e1cb3e9d2d9a6f88f30cf7fd585afe6" translate="yes" xml:space="preserve">
          <source>A singleton instance of the default random number generator</source>
          <target state="translated">기본 난수 생성기의 단일 인스턴스</target>
        </trans-unit>
        <trans-unit id="0ef9bc9017937bc2cb5ef8d012679f4242838bf7" translate="yes" xml:space="preserve">
          <source>A slice of &lt;code&gt;path&lt;/code&gt; or &quot;.&quot;.</source>
          <target state="translated">&lt;code&gt;path&lt;/code&gt; 또는 &quot;.&quot; 조각 .</target>
        </trans-unit>
        <trans-unit id="211be94b802431a091e4438f74d6d8da155125ad" translate="yes" xml:space="preserve">
          <source>A slice of &lt;code&gt;path&lt;/code&gt; that is the drive, or an empty range if the drive is not specified. In the case of UNC paths, the network share is returned.  Always returns an empty range on POSIX.</source>
          <target state="translated">드라이브 인 &lt;code&gt;path&lt;/code&gt; 조각 이거나 드라이브가 지정되지 않은 경우 비어있는 범위입니다. UNC 경로의 경우 네트워크 공유가 반환됩니다. POSIX에서 항상 빈 범위를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="beac62a1b583a4886c9c1be497e5c0b0348e7cd1" translate="yes" xml:space="preserve">
          <source>A slice of &lt;code&gt;path&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;path&lt;/code&gt; 조각 .</target>
        </trans-unit>
        <trans-unit id="5a44a0058f9c93fc07954a765d5c3b256792c20e" translate="yes" xml:space="preserve">
          <source>A slice of &lt;code&gt;r1&lt;/code&gt; which contains the characters that both ranges start with, if the first argument is a string; otherwise, the same as the result of &lt;code&gt;takeExactly(r1, n)&lt;/code&gt;, where &lt;code&gt;n&lt;/code&gt; is the number of elements in the common prefix of both ranges.</source>
          <target state="translated">첫 번째 인수가 문자열 인 경우 두 범위로 시작하는 문자를 포함하는 &lt;code&gt;r1&lt;/code&gt; 의 슬라이스입니다 . 그렇지 않으면 &lt;code&gt;takeExactly(r1, n)&lt;/code&gt; 의 결과와 동일합니다. 여기서 &lt;code&gt;n&lt;/code&gt; 은 두 범위의 공통 접두사에있는 요소의 수입니다.</target>
        </trans-unit>
        <trans-unit id="0ffe788b4fb95a6848324f21f66531a09b889ad4" translate="yes" xml:space="preserve">
          <source>A slice of path without the drive component.</source>
          <target state="translated">드라이브 구성 요소가없는 경로 조각.</target>
        </trans-unit>
        <trans-unit id="581b3b4f0e3112a50b079afa9d9199402f78b5ce" translate="yes" xml:space="preserve">
          <source>A slightly more general tool for building fixed &lt;code&gt;Trie&lt;/code&gt; for the Unicode data.</source>
          <target state="translated">유니 코드 데이터에 대한 고정 &lt;code&gt;Trie&lt;/code&gt; 를 빌드하기위한 약간 더 일반적인 도구입니다 .</target>
        </trans-unit>
        <trans-unit id="4cd1ce7d77a0e891a7fba5fd7dfff37943999a7f" translate="yes" xml:space="preserve">
          <source>A slot is implemented as a delegate. The slot_t is the type of the delegate. The delegate must be to an instance of a class or an interface to a class instance. Delegates to struct instances or nested functions must not be used as slots.</source>
          <target state="translated">슬롯은 대리인으로 구현됩니다. slot_t는 대리자의 유형입니다. 델리게이트는 클래스의 인스턴스 또는 클래스 인스턴스에 대한 인터페이스 여야합니다. struct 인스턴스 또는 중첩 함수를 위임하는 대리인은 슬롯으로 사용해서는 안됩니다.</target>
        </trans-unit>
        <trans-unit id="d89edff631bacdade5c431ac87b9ac60108881dd" translate="yes" xml:space="preserve">
          <source>A sockaddr_in as obtained from lower-level API calls such as getifaddrs.</source>
          <target state="translated">getifaddrs와 같은 하위 레벨 API 호출에서 얻은 sockaddr_in</target>
        </trans-unit>
        <trans-unit id="7d42edca23e3ad2a39e5d64109da0bfd2ccec746" translate="yes" xml:space="preserve">
          <source>A sockaddr_in6 as obtained from lower-level API calls such as getifaddrs.</source>
          <target state="translated">getifaddrs와 같은 하위 레벨 API 호출에서 얻은 sockaddr_in6</target>
        </trans-unit>
        <trans-unit id="6ea4d279c0d7e6e01846c33d4b612f74d42c15cf" translate="yes" xml:space="preserve">
          <source>A sockaddr_un as obtained from lower-level API calls.</source>
          <target state="translated">하위 수준 API 호출에서 얻은 sockaddr_un</target>
        </trans-unit>
        <trans-unit id="ebed80eb86233fab6e2b5379562de9775ffe2e21" translate="yes" xml:space="preserve">
          <source>A span of text wrapped in asterisks (&lt;code&gt;*&lt;/code&gt;) is emphasized, and text wrapped in two asterisks (&lt;code&gt;**&lt;/code&gt;) is strongly emphasized:</source>
          <target state="translated">별표 ( &lt;code&gt;*&lt;/code&gt; )로 묶인 텍스트 범위 가 강조되고 두 개의 별표 ( &lt;code&gt;**&lt;/code&gt; )로 묶인 텍스트 가 강조됩니다.</target>
        </trans-unit>
        <trans-unit id="4762ac489724656b1a0c7c273b89622b35dd42e5" translate="yes" xml:space="preserve">
          <source>A static array &lt;code&gt;T[dim]&lt;/code&gt; can be implicitly converted to one of the following:</source>
          <target state="translated">정적 배열 &lt;code&gt;T[dim]&lt;/code&gt; 은 다음 중 하나로 암시 적으로 변환 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="503b1cd5041c9f832a5dfa476e07423ac07fe21d" translate="yes" xml:space="preserve">
          <source>A static array constructed from &lt;code&gt;a&lt;/code&gt;.</source>
          <target state="translated">정적 배열로 구성 . &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="7a546994264658c0bb6793fa47d07dceb84796aa" translate="yes" xml:space="preserve">
          <source>A static array with a dimension of 0 is allowed, but no space is allocated for it.</source>
          <target state="translated">차원이 0 인 정적 배열은 허용되지만 공간이 할당되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="0ba99ac5c994db50a264f1a8103a1072e41e4bd6" translate="yes" xml:space="preserve">
          <source>A static constructor is a function that performs initializations of thread local data before the &lt;code&gt;main()&lt;/code&gt; function gets control for the main thread, and upon thread startup.</source>
          <target state="translated">정적 생성자는 &lt;code&gt;main()&lt;/code&gt; 함수가 메인 스레드를 제어 하기 전에 그리고 스레드 시작시 스레드 로컬 데이터의 초기화를 수행하는 함수입니다 .</target>
        </trans-unit>
        <trans-unit id="55ddf0925f26b59946dae28233d6fdfaaa7329f1" translate="yes" xml:space="preserve">
          <source>A static destructor gets called on thread termination, but only if the static constructor completed successfully. Static destructors have empty parameter lists. Static destructors get called in the reverse order that the static constructors were called in.</source>
          <target state="translated">정적 소멸자는 스레드 종료시 호출되지만 정적 생성자가 성공적으로 완료된 경우에만 호출됩니다. 정적 소멸자는 매개 변수 목록이 비어 있습니다. 정적 소멸자는 정적 생성자가 호출 된 역순으로 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="ff247e4fd411c5dd8e2c32f15b27c31dc37dd89a" translate="yes" xml:space="preserve">
          <source>A static destructor is defined as a special static function with the syntax &lt;code&gt;static ~this()&lt;/code&gt;.</source>
          <target state="translated">정적 소멸자는 구문이 &lt;code&gt;static ~this()&lt;/code&gt; 특수 정적 함수로 정의됩니다 .</target>
        </trans-unit>
        <trans-unit id="33e2d43ef4615d3925e034bec4d4921e1e6d6425" translate="yes" xml:space="preserve">
          <source>A static instance of the expression, typed as &lt;code&gt;Tint32&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Tint32&lt;/code&gt; 로 입력 된 식의 정적 인스턴스입니다 .</target>
        </trans-unit>
        <trans-unit id="b826ff3a676670f0d088e1cd9b512a0238306126" translate="yes" xml:space="preserve">
          <source>A string containing the path given by &lt;code&gt;path&lt;/code&gt;, but where the extension has been set to &lt;code&gt;ext&lt;/code&gt;.</source>
          <target state="translated">path에 의해 주어진 &lt;code&gt;path&lt;/code&gt; 를 포함하지만 확장자가 &lt;code&gt;ext&lt;/code&gt; 로 설정된 문자열 .</target>
        </trans-unit>
        <trans-unit id="69c56f08ab57e676746d4e01be6a9cc3952f4ae4" translate="yes" xml:space="preserve">
          <source>A string formatted in the ISO Extended format for dates and times.</source>
          <target state="translated">날짜 및 시간에 대해 ISO 확장 형식으로 형식화 된 문자열입니다.</target>
        </trans-unit>
        <trans-unit id="ef701934bf57ae45596601643b85ee15d3f2485e" translate="yes" xml:space="preserve">
          <source>A string formatted in the ISO Extended format for dates.</source>
          <target state="translated">날짜의 ISO 확장 형식으로 형식화 된 문자열입니다.</target>
        </trans-unit>
        <trans-unit id="2da20ec434f95bb8d5443fe8e314ce1623955145" translate="yes" xml:space="preserve">
          <source>A string formatted in the ISO Extended format for times.</source>
          <target state="translated">시간 동안 ISO 확장 형식으로 형식화 된 문자열입니다.</target>
        </trans-unit>
        <trans-unit id="a00e008e78aea96cbfa32fcdb23e6a8b450b797c" translate="yes" xml:space="preserve">
          <source>A string formatted in the ISO format for dates and times.</source>
          <target state="translated">날짜 및 시간에 대해 ISO 형식으로 형식화 된 문자열입니다.</target>
        </trans-unit>
        <trans-unit id="2a3df60399b45643cd31eb34963073f7812833b6" translate="yes" xml:space="preserve">
          <source>A string formatted in the ISO format for dates.</source>
          <target state="translated">날짜의 ISO 형식으로 지정된 문자열입니다.</target>
        </trans-unit>
        <trans-unit id="04939a3353d03734d347b05e3ca2729bd9a9341a" translate="yes" xml:space="preserve">
          <source>A string formatted in the ISO format for times.</source>
          <target state="translated">ISO 형식으로 여러 번 형식화 된 문자열입니다.</target>
        </trans-unit>
        <trans-unit id="0643f1e9bd52d0a8a25555e18edbd5da7b51bdf5" translate="yes" xml:space="preserve">
          <source>A string formatted in the way that &lt;code&gt;toSimpleString&lt;/code&gt; formats dates and times.</source>
          <target state="translated">&lt;code&gt;toSimpleString&lt;/code&gt; 이 날짜와 시간 을 형식화하는 방식으로 형식화 된 문자열 입니다.</target>
        </trans-unit>
        <trans-unit id="f962ea73f49b39339b4922f88a0c238e4ba1325d" translate="yes" xml:space="preserve">
          <source>A string formatted in the way that toSimpleString formats dates and times.</source>
          <target state="translated">toSimpleString이 날짜와 시간을 형식화하는 방식으로 형식화 된 문자열입니다.</target>
        </trans-unit>
        <trans-unit id="632ab3df5f88419d1e31f1d1cee5760bbb59e7a9" translate="yes" xml:space="preserve">
          <source>A string formatted in the way that toSimpleString formats dates.</source>
          <target state="translated">toSimpleString이 날짜 형식을 지정하는 방식으로 형식화 된 문자열입니다.</target>
        </trans-unit>
        <trans-unit id="bd3280dc41aa99bf0618b972c678e1b7727cbc29" translate="yes" xml:space="preserve">
          <source>A string is an array of characters. String literals are just an easy way to write character arrays. String literals are immutable (read only).</source>
          <target state="translated">문자열은 문자 배열입니다. 문자열 리터럴은 문자 배열을 작성하는 쉬운 방법입니다. 문자열 리터럴은 변경할 수 없습니다 (읽기 전용).</target>
        </trans-unit>
        <trans-unit id="4693492ea4f8cc4f79d65fb1c5fff8fc71f5424c" translate="yes" xml:space="preserve">
          <source>A string listing the name of each JSON field. Useful for errors messages.</source>
          <target state="translated">각 JSON 필드의 이름을 나열하는 문자열입니다. 오류 메시지에 유용합니다.</target>
        </trans-unit>
        <trans-unit id="2dfa7f97ca7b310eefa5e44ed45cbd5a9d6fba44" translate="yes" xml:space="preserve">
          <source>A string literal is either a double quoted string, a wysiwyg quoted string, a delimited string, a token string, or a hex string.</source>
          <target state="translated">문자열 리터럴은 큰 따옴표로 묶인 문자열, wysiwyg 따옴표로 묶은 문자열, 구분 된 문자열, 토큰 문자열 또는 16 진 문자열입니다.</target>
        </trans-unit>
        <trans-unit id="91c359df16c8f1e8cc04e86239901e547e4069a7" translate="yes" xml:space="preserve">
          <source>A string of the same type as &lt;code&gt;input&lt;/code&gt; with the all of the matches (if any) replaced. If no match is found returns the input string itself.</source>
          <target state="translated">모든 일치 항목이있는 경우 &lt;code&gt;input&lt;/code&gt; 과 동일한 유형의 문자열입니다 (있는 경우). 일치하는 것이 없으면 입력 문자열 자체를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="e2e9744762303d84756cc38d0bb797a1dfb35ea5" translate="yes" xml:space="preserve">
          <source>A string of the same type with the first match (if any) replaced. If no match is found returns the input string itself.</source>
          <target state="translated">첫 번째 일치 항목 (있는 경우)이 교체 된 동일한 유형의 문자열 일치하는 것이 없으면 입력 문자열 자체를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="e3572bd9c75fcb62fc2a06156321d1044ce974ae" translate="yes" xml:space="preserve">
          <source>A string or a callable</source>
          <target state="translated">문자열 또는 호출 가능</target>
        </trans-unit>
        <trans-unit id="ade01e08f23d876345b07c46538697febd10cde1" translate="yes" xml:space="preserve">
          <source>A string to be mixed in to an aggregate, such as a &lt;code&gt;struct&lt;/code&gt; or &lt;code&gt;class&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;struct&lt;/code&gt; 또는 &lt;code&gt;class&lt;/code&gt; 와 같은 집계에 혼합 할 문자열 입니다.</target>
        </trans-unit>
        <trans-unit id="5d73e7649de9a0fce40f5dced1b091b66c878d3f" translate="yes" xml:space="preserve">
          <source>A struct can be prevented from being nested by using the static attribute, but then of course it will not be able to access variables from its enclosing scope.</source>
          <target state="translated">정적 속성을 사용하여 구조체가 중첩되는 것을 방지 할 수 있지만 물론 해당 범위에서 변수에 액세스 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="1f09ef100c2ee69f17128a0533548f020c5d9e4c" translate="yes" xml:space="preserve">
          <source>A struct constructor is called by the name of the struct followed by &lt;a href=&quot;class#Parameters&quot;&gt;&lt;i&gt;Parameters&lt;/i&gt;&lt;/a&gt;.</source>
          <target state="translated">struct 생성자는 struct의 이름과 &lt;a href=&quot;class#Parameters&quot;&gt;&lt;i&gt;Parameters가&lt;/i&gt;&lt;/a&gt; 차례로 호출됩니다 .</target>
        </trans-unit>
        <trans-unit id="00e185de50d62e9d91d5d52f4d70129a74a374a6" translate="yes" xml:space="preserve">
          <source>A struct declaration can have a storage class of &lt;code&gt;const&lt;/code&gt;, &lt;code&gt;immutable&lt;/code&gt; or &lt;code&gt;shared&lt;/code&gt;. It has an equivalent effect as declaring each member of the struct as &lt;code&gt;const&lt;/code&gt;, &lt;code&gt;immutable&lt;/code&gt; or &lt;code&gt;shared&lt;/code&gt;.</source>
          <target state="translated">구조체 선언은 &lt;code&gt;const&lt;/code&gt; , &lt;code&gt;immutable&lt;/code&gt; 또는 &lt;code&gt;shared&lt;/code&gt; 의 스토리지 클래스를 가질 수 있습니다 . 구조체의 각 멤버를 &lt;code&gt;const&lt;/code&gt; , &lt;code&gt;immutable&lt;/code&gt; 또는 &lt;code&gt;shared&lt;/code&gt; 로 선언하는 것과 동등한 효과가 있습니다.</target>
        </trans-unit>
        <trans-unit id="5e4f169c05b38809d1d31f76423e59d52a2b4315" translate="yes" xml:space="preserve">
          <source>A struct is defined to not have an identity; that is, the implementation is free to make bit copies of the struct as convenient.</source>
          <target state="translated">구조체는 정체성이없는 것으로 정의됩니다. 즉, 구현은 구조체의 비트 복사본을 편리하게 만들 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9bc9847f25ea362b6740a9b93ab804ef00434940" translate="yes" xml:space="preserve">
          <source>A struct literal. &lt;a href=&quot;#Value&quot;&gt;&lt;i&gt;Value&lt;/i&gt;&lt;/a&gt; is repeated &lt;a href=&quot;#Number&quot;&gt;&lt;i&gt;Number&lt;/i&gt;&lt;/a&gt; times.</source>
          <target state="translated">구조체 리터럴. &lt;a href=&quot;#Value&quot;&gt;&lt;i&gt;값은&lt;/i&gt;&lt;/a&gt; 반복 &lt;a href=&quot;#Number&quot;&gt;&lt;i&gt;번호&lt;/i&gt;&lt;/a&gt; 번.</target>
        </trans-unit>
        <trans-unit id="286be268efaafbe7332e602d9baab19f8148f3ca" translate="yes" xml:space="preserve">
          <source>A struct or union is</source>
          <target state="translated">구조체 또는 노조는</target>
        </trans-unit>
        <trans-unit id="306c597a82d5ab4af2135e10c7b985f1b617d325" translate="yes" xml:space="preserve">
          <source>A struct representing an arbitrary precision integer.</source>
          <target state="translated">임의의 정밀도 정수를 나타내는 구조체입니다.</target>
        </trans-unit>
        <trans-unit id="526765a5620c1404cef412a5aba1cb550dfea2fe" translate="yes" xml:space="preserve">
          <source>A struct with a disabled default constructor, and no other constructors, cannot be instantiated other than via a &lt;a href=&quot;declaration#VoidInitializer&quot;&gt;&lt;i&gt;VoidInitializer&lt;/i&gt;&lt;/a&gt;.</source>
          <target state="translated">기본 생성자가 비활성화되고 다른 생성자가없는 구조체는 &lt;a href=&quot;declaration#VoidInitializer&quot;&gt;&lt;i&gt;VoidInitializer&lt;/i&gt;&lt;/a&gt; 이외의 인스턴스를 생성 할 수 없습니다 .</target>
        </trans-unit>
        <trans-unit id="44cac3ef6b0f178c3af52d9fad3a48b33c922f31" translate="yes" xml:space="preserve">
          <source>A structure designed to effectively pack &lt;a href=&quot;#Character&quot;&gt;characters&lt;/a&gt; of a &lt;a href=&quot;#Grapheme%20cluster&quot;&gt;grapheme cluster&lt;/a&gt;.</source>
          <target state="translated">효과적으로 포장하기위한 구조 &lt;a href=&quot;#Character&quot;&gt;문자&lt;/a&gt; (A)의 &lt;a href=&quot;#Grapheme%20cluster&quot;&gt;그래 핀 클러스터를&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="1dee43ab463ff81471969585aaeb25d27e17a8d5" translate="yes" xml:space="preserve">
          <source>A sub-type of &lt;code&gt;Tuple!()&lt;/code&gt; of the split portions of &lt;code&gt;haystack&lt;/code&gt; (see above for details). This sub-type of &lt;code&gt;Tuple!()&lt;/code&gt; has &lt;code&gt;opCast&lt;/code&gt; defined for &lt;code&gt;bool&lt;/code&gt;. This &lt;code&gt;opCast&lt;/code&gt; returns &lt;code&gt;true&lt;/code&gt; when the separating &lt;code&gt;needle&lt;/code&gt; was found and &lt;code&gt;false&lt;/code&gt; otherwise.</source>
          <target state="translated">&lt;code&gt;haystack&lt;/code&gt; 분할 부분 의 &lt;code&gt;Tuple!()&lt;/code&gt; 의 하위 유형입니다 (자세한 내용은 위 참조). 이 하위 유형 &lt;code&gt;Tuple!()&lt;/code&gt; 했다 &lt;code&gt;opCast&lt;/code&gt; 는 정의 &lt;code&gt;bool&lt;/code&gt; . 이 &lt;code&gt;opCast&lt;/code&gt; 는 분리 &lt;code&gt;needle&lt;/code&gt; 이 발견 되면 &lt;code&gt;true&lt;/code&gt; 를, 그렇지 않으면 &lt;code&gt;false&lt;/code&gt; 를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="8ceb760806d127d92222223abf19d6e9a9a642d1" translate="yes" xml:space="preserve">
          <source>A subset of flags supported on all platforms with getaddrinfo. Specifies option flags for &lt;code&gt;getAddressInfo&lt;/code&gt;.</source>
          <target state="translated">getaddrinfo를 사용하여 모든 플랫폼에서 지원되는 플래그의 서브 세트입니다. &lt;code&gt;getAddressInfo&lt;/code&gt; 옵션 플래그를 지정합니다 .</target>
        </trans-unit>
        <trans-unit id="5fdcf48534cbb5ac5ca95f825a7e9b13b6291b8b" translate="yes" xml:space="preserve">
          <source>A switch statement goes to one of a collection of case statements depending on the value of the switch expression.</source>
          <target state="translated">switch 문은 스위치 식의 값에 따라 case 문 모음 중 하나로 이동합니다.</target>
        </trans-unit>
        <trans-unit id="8d52ce29a153bfcaed221e76bcfa3b8652e6334d" translate="yes" xml:space="preserve">
          <source>A switch statement must have a default statement.</source>
          <target state="translated">스위치 문에는 기본 문이 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="243f938b3c97b4e1d8eadd9d338c92b666235144" translate="yes" xml:space="preserve">
          <source>A symbol can be declared as an</source>
          <target state="translated">기호는</target>
        </trans-unit>
        <trans-unit id="84b715dd42cb515250f3406c66517dd9d7115450" translate="yes" xml:space="preserve">
          <source>A table in the database is locked</source>
          <target state="translated">데이터베이스의 테이블이 잠겨 있습니다</target>
        </trans-unit>
        <trans-unit id="34955ed2643e3acedc24870a54a36ec54c1a46f3" translate="yes" xml:space="preserve">
          <source>A tagged class reference uses the bits known to be zero in a normal class reference to store extra information. For example, a pointer to an integer must be 4-byte aligned, so there are 2 bits that are always known to be zero. One can store a 2-bit integer there.</source>
          <target state="translated">태그가 지정된 클래스 참조는 일반 클래스 참조에서 0으로 알려진 비트를 사용하여 추가 정보를 저장합니다. 예를 들어, 정수에 대한 포인터는 4 바이트로 정렬되어야하므로 항상 0으로 알려진 2 비트가 있습니다. 거기에 2 비트 정수를 저장할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="bec6ca0b9e854ba9b4dc6eeb575b3e2cf1fbdc8a" translate="yes" xml:space="preserve">
          <source>A tagged pointer uses the bits known to be zero in a normal pointer or class reference to store extra information. For example, a pointer to an integer must be 4-byte aligned, so there are 2 bits that are always known to be zero. One can store a 2-bit integer there.</source>
          <target state="translated">태그가 지정된 포인터는 추가 정보를 저장하기 위해 일반 포인터 또는 클래스 참조에서 0으로 알려진 비트를 사용합니다. 예를 들어, 정수에 대한 포인터는 4 바이트로 정렬되어야하므로 항상 0으로 알려진 2 비트가 있습니다. 거기에 2 비트 정수를 저장할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="71dbdba1f186a3e3df4f62b2ce30433dcfeb9ff8" translate="yes" xml:space="preserve">
          <source>A template instance that requires IFTI: foo!tiargs(fargs) // foo!tiargs is left until CallExp::semantic() or resolveProperties()</source>
          <target state="translated">IFTI가 필요한 템플릿 인스턴스 : foo! tiargs (fargs) // foo! tiargs는 CallExp :: semantic () 또는 resolveProperties ()까지 남습니다.</target>
        </trans-unit>
        <trans-unit id="c487a2a162f74902ff60920af22e2df0fcc4fd2b" translate="yes" xml:space="preserve">
          <source>A template instantiation can be aliased:</source>
          <target state="translated">템플릿 인스턴스화의 별칭을 지정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5ec9a1a961c15a72835c9d805bb9f5cb8a6a13d6" translate="yes" xml:space="preserve">
          <source>A templated &lt;code&gt;struct&lt;/code&gt; can become a nested &lt;code&gt;struct&lt;/code&gt; if it is instantiated with a local symbol passed as an aliased argument:</source>
          <target state="translated">템플릿 기반 &lt;code&gt;struct&lt;/code&gt; 중첩 될 수있는 &lt;code&gt;struct&lt;/code&gt; 가 앨리어스 인수로 전달 로컬 기호로 인스턴스화하는 경우 :</target>
        </trans-unit>
        <trans-unit id="286beb1ed5435d657d4bd322969e6d1bee678996" translate="yes" xml:space="preserve">
          <source>A text file of macro definitions can be created, and specified in &lt;code&gt;sc.ini&lt;/code&gt;:</source>
          <target state="translated">매크로 정의의 텍스트 파일을 만들고 &lt;code&gt;sc.ini&lt;/code&gt; 에 지정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="a2c74bdd28417e72ddc700c54f50c8aefa1946fb" translate="yes" xml:space="preserve">
          <source>A textual representation of the email status</source>
          <target state="translated">이메일 상태의 텍스트 표현</target>
        </trans-unit>
        <trans-unit id="635a851773d8480d1d8ecc449412eec073d321df" translate="yes" xml:space="preserve">
          <source>A tuple consisting of &lt;code&gt;x&lt;/code&gt;, &lt;code&gt;y = f(x)&lt;/code&gt; and &lt;code&gt;error = 3 * (absTolerance * fabs(x) + relTolerance)&lt;/code&gt;.  The method used is a combination of golden section search and successive parabolic interpolation. Convergence is never much slower than that for a Fibonacci search.</source>
          <target state="translated">&lt;code&gt;x&lt;/code&gt; , &lt;code&gt;y = f(x)&lt;/code&gt; 및 &lt;code&gt;error = 3 * (absTolerance * fabs(x) + relTolerance)&lt;/code&gt; 로 구성된 튜플 . 사용 된 방법은 골든 섹션 검색과 연속 포물선 보간의 조합입니다. 수렴은 피보나치 검색보다 훨씬 느리지 않습니다.</target>
        </trans-unit>
        <trans-unit id="4ef0df844df69a5568d48b91fa199dcc9de56bc7" translate="yes" xml:space="preserve">
          <source>A tuple consisting of two ranges. The first two elements are the range (in &lt;code&gt;x&lt;/code&gt;) of the root, while the second pair of elements are the corresponding function values at those points. If an exact root was found, both of the first two elements will contain the root, and the second pair of elements will be 0.</source>
          <target state="translated">두 가지 범위로 구성된 튜플. 처음 두 요소는 루트 의 범위 ( &lt;code&gt;x&lt;/code&gt; )이고 두 번째 요소 쌍은 해당 지점의 해당 함수 값입니다. 정확한 근이 발견되면 처음 두 요소 모두 근을 포함하고 두 번째 요소 쌍은 0이됩니다.</target>
        </trans-unit>
        <trans-unit id="6012f9e438732b6c8c1f1bc9808a6995a46a0ce0" translate="yes" xml:space="preserve">
          <source>A tuple containing &lt;code&gt;haystack&lt;/code&gt; positioned to match one of the needles and also the 1-based index of the matching element in &lt;code&gt;needles&lt;/code&gt; (0 if none of &lt;code&gt;needles&lt;/code&gt; matched, 1 if &lt;code&gt;needles[0]&lt;/code&gt; matched, 2 if &lt;code&gt;needles[1]&lt;/code&gt; matched...). The first needle to be found will be the one that matches. If multiple needles are found at the same spot in the range, then the shortest one is the one which matches (if multiple needles of the same length are found at the same spot (e.g &lt;code&gt;&quot;a&quot;&lt;/code&gt; and &lt;code&gt;'a'&lt;/code&gt;), then the left-most of them in the argument list matches).  The relationship between &lt;code&gt;haystack&lt;/code&gt; and &lt;code&gt;needles&lt;/code&gt; simply means that one can e.g. search for individual &lt;code&gt;int&lt;/code&gt;s or arrays of &lt;code&gt;int&lt;/code&gt;s in an array of &lt;code&gt;int&lt;/code&gt;s. In addition, if elements are individually comparable, searches of heterogeneous types are allowed as well: a &lt;code&gt;double[]&lt;/code&gt; can be searched for an &lt;code&gt;int&lt;/code&gt; or a &lt;code&gt;short[]&lt;/code&gt;, and conversely a &lt;code&gt;long&lt;/code&gt; can be searched for a &lt;code&gt;float&lt;/code&gt; or a &lt;code&gt;double[]&lt;/code&gt;. This makes for efficient searches without the need to coerce one side of the comparison into the other's side type.  The complexity of the search is &amp;Omicron;(&lt;code&gt;haystack.length * max(needles.length)&lt;/code&gt;). (For needles that are individual items, length is considered to be 1.) The strategy used in searching several subranges at once maximizes cache usage by moving in &lt;code&gt;haystack&lt;/code&gt; as few times as possible.</source>
          <target state="translated">튜플 함유 &lt;code&gt;haystack&lt;/code&gt; 바늘의 한도에 일치하는 요소의 1 기반의 인덱스와 일치하도록 위치 &lt;code&gt;needles&lt;/code&gt; 하나도 (0 &lt;code&gt;needles&lt;/code&gt; 만약 일치하지 1 &lt;code&gt;needles[0]&lt;/code&gt; 일치하는 2하는 경우 &lt;code&gt;needles[1]&lt;/code&gt; 일치 ... ). 발견되는 첫 번째 바늘은 일치하는 바늘입니다. 범위에서 동일한 지점에서 여러 바늘이 발견되면 가장 짧은 바늘이 일치하는 바늘입니다 (동일한 길이의 여러 바늘이 같은 지점에서 발견되는 경우 (예 : &lt;code&gt;&quot;a&quot;&lt;/code&gt; 및 &lt;code&gt;'a'&lt;/code&gt; ), 왼쪽 -인수 목록에서 대부분 일치합니다). &lt;code&gt;haystack&lt;/code&gt; 와 &lt;code&gt;needles&lt;/code&gt; 의 관계단지 하나의 예를 들면 개별 검색 할 수 있다는 것을 의미 &lt;code&gt;int&lt;/code&gt; 들 또는 배열 &lt;code&gt;int&lt;/code&gt; 의 배열 S &lt;code&gt;int&lt;/code&gt; S. 또한 요소가 개별적으로 비교 가능한 경우 이기종 유형의 검색도 허용됩니다. &lt;code&gt;double[]&lt;/code&gt; 에서 &lt;code&gt;int&lt;/code&gt; 또는 &lt;code&gt;short[]&lt;/code&gt; 검색 할 수 있고 반대로 &lt;code&gt;long&lt;/code&gt; 은 &lt;code&gt;float&lt;/code&gt; 또는 &lt;code&gt;double[]&lt;/code&gt; 검색 할 수 있습니다 . 이것은 비교의 한쪽을 다른 쪽의 유형으로 강제 할 필요없이 효율적인 검색을 가능하게합니다. 검색 복잡도는 &amp;Omicron; ( &lt;code&gt;haystack.length * max(needles.length)&lt;/code&gt; ). 개별 항목 인 바늘의 경우 길이는 1로 간주됩니다. 여러 하위 범위를 한 번에 검색하는 데 사용되는 전략은 &lt;code&gt;haystack&lt;/code&gt; 에서 가능한 한 몇 번 이동하여 캐시 사용을 최대화 합니다.</target>
        </trans-unit>
        <trans-unit id="ded0856f6fc1b75ce8ecf0a9f7b88274ab801b0f" translate="yes" xml:space="preserve">
          <source>A tuple of ParameterStorageClass bits</source>
          <target state="translated">ParameterStorageClass 비트의 튜플</target>
        </trans-unit>
        <trans-unit id="fd35c428724dd8619e23fbf0f2a7e57058b4f08d" translate="yes" xml:space="preserve">
          <source>A tuple with &lt;code&gt;isMutable&lt;/code&gt; and &lt;code&gt;isNotShared&lt;/code&gt; set if the &lt;code&gt;lhsMod&lt;/code&gt; is missing those modifiers (compared to rhs).</source>
          <target state="translated">&lt;code&gt;lhsMod&lt;/code&gt; 에 해당 수정자가없는 경우 &lt;code&gt;isMutable&lt;/code&gt; 및 &lt;code&gt;isNotShared&lt;/code&gt; 가 설정된 튜플 (rhs와 비교).</target>
        </trans-unit>
        <trans-unit id="87f68985da3ea589273931016f24036b553a5f0d" translate="yes" xml:space="preserve">
          <source>A type &lt;code&gt;S&lt;/code&gt; gets compiler-generated &lt;code&gt;opAssign&lt;/code&gt; in case it has an elaborate copy constructor or elaborate destructor.</source>
          <target state="translated">유형 &lt;code&gt;S&lt;/code&gt; 는 정교한 복사 생성자 또는 정교한 소멸자를 가지고있는 경우 컴파일러에서 생성 한 &lt;code&gt;opAssign&lt;/code&gt; 을 가져 옵니다 .</target>
        </trans-unit>
        <trans-unit id="c2925ba28f3ef4457063b11b5313b546bc942531" translate="yes" xml:space="preserve">
          <source>A type called StaticClassXXXX which defines all the static members.</source>
          <target state="translated">모든 정적 멤버를 정의하는 StaticClassXXXX라는 유형입니다.</target>
        </trans-unit>
        <trans-unit id="4bafd715c2d842fc48782a23197830301ac6594f" translate="yes" xml:space="preserve">
          <source>A typesafe structure for storing combinations of enum values.</source>
          <target state="translated">열거 형 값의 조합을 저장하기위한 형식 안전 구조입니다.</target>
        </trans-unit>
        <trans-unit id="19bbabc23db1d89e38664a27a9f383fa929906e5" translate="yes" xml:space="preserve">
          <source>A typical use-case is to perform lazy but thread-safe initialization.</source>
          <target state="translated">일반적인 사용 사례는 게으르지 만 스레드 안전 초기화를 수행하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="1108e01a71348662d4697940c03ca612a789d5db" translate="yes" xml:space="preserve">
          <source>A typical workaround would be to use array vector operations instead:</source>
          <target state="translated">일반적인 해결 방법은 배열 벡터 연산을 대신 사용하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="622333820bdb5ef06fbb318f56dcf3f6445745f2" translate="yes" xml:space="preserve">
          <source>A unique hash of the &lt;code&gt;BigInt&lt;/code&gt;'s value suitable for use in a hash table.</source>
          <target state="translated">해시 테이블에서 사용하기에 적합한 &lt;code&gt;BigInt&lt;/code&gt; 값 의 고유 한 해시입니다 .</target>
        </trans-unit>
        <trans-unit id="2198d4c146bec18fd1ce6760a109cc4921cdd05d" translate="yes" xml:space="preserve">
          <source>A unit test for a function should appear immediately following it.</source>
          <target state="translated">기능에 대한 단위 테스트는 바로 다음에 나타나야합니다.</target>
        </trans-unit>
        <trans-unit id="8a517fa6a3c0c868fd6ae7e933059bd47b7df17a" translate="yes" xml:space="preserve">
          <source>A unittest may be attributed with any of the global function attributes. Such unittests are useful in verifying the given attribute(s) on a template function:</source>
          <target state="translated">unittest는 모든 전역 함수 속성으로 인해 발생할 수 있습니다. 이러한 단위 테스트는 템플릿 함수에서 주어진 속성을 확인하는 데 유용합니다.</target>
        </trans-unit>
        <trans-unit id="7ae21aa22fe7948e4c729f1540b79f8cd693afe8" translate="yes" xml:space="preserve">
          <source>A unittest which is not documented, or is marked as private will not be used to generate code samples.</source>
          <target state="translated">문서화되지 않았거나 비공개로 표시된 단위 테스트는 코드 샘플을 생성하는 데 사용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="9c1c04f676b35796be10ffb3edecc8f6268e7b22" translate="yes" xml:space="preserve">
          <source>A useful and popular use of algebraic data structures is for defining &lt;a href=&quot;https://google.com/search?btnI=I%27m+Feeling+Lucky&amp;amp;ie=UTF-8&amp;amp;oe=UTF-8&amp;amp;q=self-referential%20data%20structures&quot;&gt;self-referential data structures&lt;/a&gt;, i.e. structures that embed references to values of their own type within.  This is achieved with &lt;code&gt;Algebraic&lt;/code&gt; by using &lt;code&gt;This&lt;/code&gt; as a placeholder whenever a reference to the type being defined is needed. The &lt;code&gt;Algebraic&lt;/code&gt; instantiation will perform &lt;a href=&quot;https://en.wikipedia.org/wiki/Name_resolution_(programming_languages)#Alpha_renaming_to_make_name_resolution_trivial&quot;&gt;alpha renaming&lt;/a&gt; on its constituent types, replacing &lt;code&gt;This&lt;/code&gt; with the self-referenced type. The structure of the type involving &lt;code&gt;This&lt;/code&gt; may be arbitrarily complex.</source>
          <target state="translated">대수 데이터 구조의 유용하고 대중적인 사용은 &lt;a href=&quot;https://google.com/search?btnI=I%27m+Feeling+Lucky&amp;amp;ie=UTF-8&amp;amp;oe=UTF-8&amp;amp;q=self-referential%20data%20structures&quot;&gt;자기 참조 데이터 구조&lt;/a&gt; , 즉 자체 유형의 값에 대한 참조를 포함 하는 구조를 정의하는 것 입니다. 이 달성된다 &lt;code&gt;Algebraic&lt;/code&gt; 하여 &lt;code&gt;This&lt;/code&gt; 정의되는 유형의 참조가 필요할 때마다 표시 자로. &lt;code&gt;Algebraic&lt;/code&gt; 인스턴스화 수행 &lt;a href=&quot;https://en.wikipedia.org/wiki/Name_resolution_(programming_languages)#Alpha_renaming_to_make_name_resolution_trivial&quot;&gt;알파 이름 바꾸기를&lt;/a&gt; 교체, 그 구성 형식에 &lt;code&gt;This&lt;/code&gt; 자기 참조 형으로. 관련된 유형의 구성 &lt;code&gt;This&lt;/code&gt; 임의적으로 복잡 할 수있다.</target>
        </trans-unit>
        <trans-unit id="5cd31092f50e6668ec7962d66b14d97f0b254db8" translate="yes" xml:space="preserve">
          <source>A useful technique for Unicode-aware parsers that perform character classification of encoded &lt;a href=&quot;#Code%20point&quot;&gt;code points&lt;/a&gt; is to avoid unnecassary decoding at all costs. &lt;a href=&quot;#utfMatcher&quot;&gt;&lt;code&gt;utfMatcher&lt;/code&gt;&lt;/a&gt; provides an improvement over the usual workflow of decode-classify-process, combining the decoding and classification steps. By extracting necessary bits directly from encoded &lt;a href=&quot;#Code%20unit&quot;&gt;code units&lt;/a&gt; matchers achieve significant performance improvements. See &lt;a href=&quot;#MatcherConcept&quot;&gt;&lt;code&gt;MatcherConcept&lt;/code&gt;&lt;/a&gt; for the common interface of UTF matchers.</source>
          <target state="translated">인코딩 된 &lt;a href=&quot;#Code%20point&quot;&gt;코드 포인트&lt;/a&gt; 의 문자 분류를 수행하는 유니 코드 인식 파서에 유용한 기술 은 모든 비용으로 불필요한 디코딩을 피하는 것입니다. &lt;a href=&quot;#utfMatcher&quot;&gt; &lt;code&gt;utfMatcher&lt;/code&gt; &lt;/a&gt; 는 디코딩 및 분류 단계를 결합하여 일반적인 디코딩-분류-프로세스 워크 플로우에 비해 향상된 기능을 제공합니다. 인코딩 된 &lt;a href=&quot;#Code%20unit&quot;&gt;코드 단위&lt;/a&gt; 에서 직접 필요한 비트를 추출함으로써 매처는 상당한 성능 향상을 달성합니다. UTF matcher의 공통 인터페이스는 &lt;a href=&quot;#MatcherConcept&quot;&gt; &lt;code&gt;MatcherConcept&lt;/code&gt; &lt;/a&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="9e9a2a2de1ba1fef47986aeaad29546ee2f0c629" translate="yes" xml:space="preserve">
          <source>A user-defined attribute looks like:</source>
          <target state="translated">사용자 정의 속성은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="6ec4f05c1da31924f6c46c6e8eceeade66257fb8" translate="yes" xml:space="preserve">
          <source>A user-defined one can implement the equivalent semantics, but can be more efficient.</source>
          <target state="translated">사용자 정의는 동등한 의미론을 구현할 수 있지만 더 효율적일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="24ccdd70677c403ccb2a313c4c9c32fa6f8c9c76" translate="yes" xml:space="preserve">
          <source>A user:password in the URL will be ignored. Unless one is set programmatically, the .netrc will be queried.</source>
          <target state="translated">URL의 user : password는 무시됩니다. 프로그래밍 방식으로 설정하지 않으면 .netrc가 쿼리됩니다.</target>
        </trans-unit>
        <trans-unit id="2c2902f73aa9094938733525713baf7d27f4d32d" translate="yes" xml:space="preserve">
          <source>A user:password in the URL will be preferred to one in the .netrc.</source>
          <target state="translated">URL의 user : password는 .netrc의 user : password보다 선호됩니다.</target>
        </trans-unit>
        <trans-unit id="bfd68567162b198b169e63ff6f9ce0abafc592a1" translate="yes" xml:space="preserve">
          <source>A value from &lt;code&gt;input&lt;/code&gt; of type &lt;code&gt;T&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;T&lt;/code&gt; 유형의 &lt;code&gt;input&lt;/code&gt; 값</target>
        </trans-unit>
        <trans-unit id="fab34a840eca5f0af3a6adfab162743b8b96ab0f" translate="yes" xml:space="preserve">
          <source>A value of 1 means that no alignment is done; fields are packed together.</source>
          <target state="translated">값이 1이면 정렬이 수행되지 않습니다. 필드는 함께 포장됩니다.</target>
        </trans-unit>
        <trans-unit id="0f087658ff6dd881c1c276fc1abe86c63c82fce4" translate="yes" xml:space="preserve">
          <source>A value of type &lt;code&gt;T&lt;/code&gt; to assign to this &lt;code&gt;Nullable&lt;/code&gt;.</source>
          <target state="translated">이 &lt;code&gt;Nullable&lt;/code&gt; 에 할당 할 &lt;code&gt;T&lt;/code&gt; 유형의 값입니다 .</target>
        </trans-unit>
        <trans-unit id="92fc64d8ff9ab394a43cf1989c0c0f6d5f276117" translate="yes" xml:space="preserve">
          <source>A value of type &lt;code&gt;T&lt;/code&gt; to assign to this &lt;code&gt;Nullable&lt;/code&gt;. If it is &lt;code&gt;nullvalue&lt;/code&gt;, then the internal state of this &lt;code&gt;Nullable&lt;/code&gt; will be set to null.</source>
          <target state="translated">이 &lt;code&gt;Nullable&lt;/code&gt; 에 할당 할 &lt;code&gt;T&lt;/code&gt; 유형의 값입니다 . &lt;code&gt;nullvalue&lt;/code&gt; 의 경우 ,이 &lt;code&gt;Nullable&lt;/code&gt; 의 내부 상태는 null로 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="595ffc8e3de776e07c75f9495e539287bfe40f7d" translate="yes" xml:space="preserve">
          <source>A value of type &lt;code&gt;T&lt;/code&gt; to assign to this &lt;code&gt;NullableRef&lt;/code&gt;. If the internal state of this &lt;code&gt;NullableRef&lt;/code&gt; has not been initialized, an error will be thrown in non-release mode.</source>
          <target state="translated">이 &lt;code&gt;NullableRef&lt;/code&gt; 에 할당 할 &lt;code&gt;T&lt;/code&gt; 유형의 값입니다 . 이 &lt;code&gt;NullableRef&lt;/code&gt; 의 내부 상태 가 초기화되지 않은 경우 비 릴리즈 모드에서 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="0312bacf411c0359c567722d8da661969980e011" translate="yes" xml:space="preserve">
          <source>A variable storing the number of digits of the factorial number stored in &lt;code&gt;fac&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;fac&lt;/code&gt; 에 저장된 계승 수의 자릿수를 저장하는 변수 입니다.</target>
        </trans-unit>
        <trans-unit id="1288e9434e2f0aa83f354b220fc3320a00da2bf3" translate="yes" xml:space="preserve">
          <source>A variadic array of &lt;code&gt;Statement&lt;/code&gt;s, that will copied in this class The entries themselves will not be copied.</source>
          <target state="translated">이 클래스에 복사되는 &lt;code&gt;Statement&lt;/code&gt; 의 가변 배열 배열 항목 자체는 복사되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="f46908d75fb188ea17f0c418cfb5fce0d59b00a5" translate="yes" xml:space="preserve">
          <source>A variant on interfaces is the COM interface. A COM interface is designed to map directly onto a Windows COM object. Any COM object can be represented by a COM interface, and any D object with a COM interface can be used by external COM clients.</source>
          <target state="translated">인터페이스의 변형은 COM 인터페이스입니다. COM 인터페이스는 Windows COM 개체에 직접 매핑되도록 설계되었습니다. 모든 COM 개체는 COM 인터페이스로 표시 될 수 있으며 COM 인터페이스가있는 D 개체는 외부 COM 클라이언트에서 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="74bc7034954daf05645c8bdf69b200a66acd5b8d" translate="yes" xml:space="preserve">
          <source>A variation on &lt;a href=&quot;#replaceAll&quot;&gt;&lt;code&gt;replaceAll&lt;/code&gt;&lt;/a&gt; that instead of allocating a new string on each call outputs the result piece-wise to the &lt;code&gt;sink&lt;/code&gt;. In particular this enables efficient construction of a final output incrementally.</source>
          <target state="translated">&lt;a href=&quot;#replaceAll&quot;&gt; &lt;code&gt;replaceAll&lt;/code&gt; &lt;/a&gt; 의 변형은 각 호출에 새 문자열을 할당하는 대신 결과를 &lt;code&gt;sink&lt;/code&gt; 단위로 출력합니다 . 특히 이것은 최종 출력을 점진적으로 효율적으로 구성 할 수있게합니다.</target>
        </trans-unit>
        <trans-unit id="558bf167836891063033473ff39e29c40f76a6ae" translate="yes" xml:space="preserve">
          <source>A variation on &lt;a href=&quot;#replaceFirst&quot;&gt;&lt;code&gt;replaceFirst&lt;/code&gt;&lt;/a&gt; that instead of allocating a new string on each call outputs the result piece-wise to the &lt;code&gt;sink&lt;/code&gt;. In particular this enables efficient construction of a final output incrementally.</source>
          <target state="translated">&lt;a href=&quot;#replaceFirst&quot;&gt; &lt;code&gt;replaceFirst&lt;/code&gt; &lt;/a&gt; 에 대한 변형은 각 호출에 새 문자열을 할당하는 대신 결과를 &lt;code&gt;sink&lt;/code&gt; 단위로 출력합니다 . 특히 이것은 최종 출력을 점진적으로 효율적으로 구성 할 수있게합니다.</target>
        </trans-unit>
        <trans-unit id="fd2627bfee6415d1e46fb27e196853613a72b036" translate="yes" xml:space="preserve">
          <source>A variation on &lt;a href=&quot;#spawnProcess&quot;&gt;&lt;code&gt;spawnProcess&lt;/code&gt;&lt;/a&gt; that runs the given command through the current user's preferred command interpreter (aka. shell).</source>
          <target state="translated">현재 사용자가 선호하는 명령 해석기 (일명 셸)를 통해 지정된 명령을 실행하는 &lt;a href=&quot;#spawnProcess&quot;&gt; &lt;code&gt;spawnProcess&lt;/code&gt; &lt;/a&gt; 의 변형입니다 .</target>
        </trans-unit>
        <trans-unit id="06c25ac99fc939d88ae07ec02cd1e2eaea8adf25" translate="yes" xml:space="preserve">
          <source>A vector operation is indicated by the slice operator appearing as the left-hand side of an assignment or an op-assignment expression. The right-hand side can be an expression consisting either of an array slice of the same length and type as the left-hand side or a scalar expression of the element type of the left-hand side, in any combination.</source>
          <target state="translated">벡터 연산은 할당 또는 op- 할당 표현식의 왼쪽으로 나타나는 슬라이스 연산자로 표시됩니다. 오른쪽은 왼쪽과 길이와 유형이 같은 배열 슬라이스로 구성되거나 왼쪽의 요소 유형에 대한 스칼라 식으로 구성 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0201e0884279f412eec70152c95bca634cabe90f" translate="yes" xml:space="preserve">
          <source>A version condition is of the form:</source>
          <target state="translated">버전 조건은 다음과 같은 형식입니다.</target>
        </trans-unit>
        <trans-unit id="036b91c045d7afd669b86e632efdeb65cf70fbe8" translate="yes" xml:space="preserve">
          <source>A version of &lt;a href=&quot;#Appender&quot;&gt;&lt;code&gt;Appender&lt;/code&gt;&lt;/a&gt; that can update an array in-place. It forwards all calls to an underlying appender implementation. Any calls made to the appender also update the pointer to the original array passed in.</source>
          <target state="translated">전체 배열을 업데이트 할 수 있는 &lt;a href=&quot;#Appender&quot;&gt; &lt;code&gt;Appender&lt;/code&gt; &lt;/a&gt; 버전입니다 . 모든 호출을 기본 어 펜더 구현으로 전달합니다. 어 펜더를 호출하면 전달 된 원래 배열에 대한 포인터도 업데이트됩니다.</target>
        </trans-unit>
        <trans-unit id="0f69ae09b687c0f70931e5d637c3720fd96bc47f" translate="yes" xml:space="preserve">
          <source>A very important attribute of the Unicode Normalization Forms is that they must remain stable between versions of the Unicode Standard. A Unicode string normalized to a particular Unicode Normalization Form in one version of the standard is guaranteed to remain in that Normalization Form for implementations of future versions of the standard.</source>
          <target state="translated">유니 코드 정규화 양식의 매우 중요한 특성은 유니 코드 표준 버전간에 안정적으로 유지되어야한다는 것입니다. 표준의 한 버전에서 특정 유니 코드 정규화 형식으로 정규화 된 유니 코드 문자열은 향후 표준 버전의 구현을 위해 해당 정규화 형식으로 유지됩니다.</target>
        </trans-unit>
        <trans-unit id="204a1d9da8aeb4ccbb41074798c36ae598e785cb" translate="yes" xml:space="preserve">
          <source>A visitor to walk entire statements and provides ability to replace any sub-statements.</source>
          <target state="translated">방문자는 전체 진술을 밟고 하위 진술을 대체 할 수있는 능력을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="ecda6fbd787080a0c71eaf580a2379d0a84fd558" translate="yes" xml:space="preserve">
          <source>A way to construct optimal packed multi-stage tables also known as a special case of &lt;a href=&quot;https://en.wikipedia.org/wiki/Trie&quot;&gt;Trie&lt;/a&gt;. The functions &lt;a href=&quot;#codepointTrie&quot;&gt;&lt;code&gt;codepointTrie&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#codepointSetTrie&quot;&gt;&lt;code&gt;codepointSetTrie&lt;/code&gt;&lt;/a&gt; construct custom tries that map dchar to value. The end result is a fast and predictable &amp;Omicron;(&lt;code&gt;1&lt;/code&gt;) lookup that powers functions like &lt;a href=&quot;#isAlpha&quot;&gt;&lt;code&gt;isAlpha&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#combiningClass&quot;&gt;&lt;code&gt;combiningClass&lt;/code&gt;&lt;/a&gt;, but for user-defined data sets.</source>
          <target state="translated">&lt;a href=&quot;https://en.wikipedia.org/wiki/Trie&quot;&gt;Trie&lt;/a&gt; 의 특별한 경우로 알려진 최적의 다단계 테이블을 구성하는 방법 . &lt;a href=&quot;#codepointTrie&quot;&gt; &lt;code&gt;codepointTrie&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#codepointSetTrie&quot;&gt; &lt;code&gt;codepointSetTrie&lt;/code&gt; &lt;/a&gt; 생성자 사용자 정의 함수 는 dchar을 값에 매핑하려고 시도합니다. 결과적 빠르고 예측 &amp;Omicron;이다 ( &lt;code&gt;1&lt;/code&gt; ) 조회 같은 힘 함수 &lt;a href=&quot;#isAlpha&quot;&gt; &lt;code&gt;isAlpha&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#combiningClass&quot;&gt; &lt;code&gt;combiningClass&lt;/code&gt; &lt;/a&gt; 하지만, 사용자 정의 데이터 세트가.</target>
        </trans-unit>
        <trans-unit id="179d3c78fdb472871d26dca4bbdeaf8b134c8648" translate="yes" xml:space="preserve">
          <source>A word-aligned buffer of &lt;code&gt;n&lt;/code&gt; bytes, or &lt;code&gt;null&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;n&lt;/code&gt; 바이트 의 단어 정렬 버퍼 또는 &lt;code&gt;null&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="b5bda91bd2eb64cc9ebd789e00ffee28462db953" translate="yes" xml:space="preserve">
          <source>A wrapper &lt;code&gt;struct&lt;/code&gt; that preserves the range interface of &lt;code&gt;input&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;input&lt;/code&gt; 의 범위 인터페이스를 유지 하는 래퍼 &lt;code&gt;struct&lt;/code&gt; 입니다 .</target>
        </trans-unit>
        <trans-unit id="d29ec600e62a50d3d9eec98dae8f8d3e051f7de3" translate="yes" xml:space="preserve">
          <source>A wrapper around a list of allocators which allow for very fast deallocations.</source>
          <target state="translated">매우 빠른 할당 해제를 허용하는 할당 자 목록 주위의 래퍼입니다.</target>
        </trans-unit>
        <trans-unit id="15c2c153bb71919b5cdec457823f4fd9f8d71bf9" translate="yes" xml:space="preserve">
          <source>A wrapper for whatever the main thread would have done in the absence of a custom scheduler. It will be automatically executed via a call to spawn by the Scheduler.</source>
          <target state="translated">사용자 정의 스케줄러가없는 상태에서 메인 스레드가 수행 한 모든 작업을위한 래퍼입니다. 스케줄러가 스폰하기 위해 자동으로 실행됩니다.</target>
        </trans-unit>
        <trans-unit id="66b2f8e9850db5c9a0ef26a091089e2397efa6e8" translate="yes" xml:space="preserve">
          <source>A wrapper on top of the built-in cast operator that allows one to restrict casting of the original type of the value.</source>
          <target state="translated">내장 된 캐스트 연산자의 상단에있는 래퍼로서 원래 유형의 값 캐스팅을 제한 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d26b628f187d45bc4e12de9cc9385d4c6d2e0a9b" translate="yes" xml:space="preserve">
          <source>A writer sub-mutex.</source>
          <target state="translated">라이터 서브 뮤텍스.</target>
        </trans-unit>
        <trans-unit id="74f058625ae51d7f9a4f0234f03e7d2e3133d478" translate="yes" xml:space="preserve">
          <source>A zero was generated by underflow</source>
          <target state="translated">언더 플로에 의해 0이 생성되었습니다</target>
        </trans-unit>
        <trans-unit id="ce3098487e1cd9f75cd7cad95483a4b4deb5588e" translate="yes" xml:space="preserve">
          <source>A* &lt;code&gt;arr&lt;/code&gt;</source>
          <target state="translated">A * &lt;code&gt;arr&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="a30240d9b1407524e8eee853f1720d4610565ce4" translate="yes" xml:space="preserve">
          <source>AA &lt;code&gt;aa&lt;/code&gt;</source>
          <target state="translated">AA &lt;code&gt;aa&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="76c631f781a8d0368d8a6ea89a0fbce4e43bfbaa" translate="yes" xml:space="preserve">
          <source>AA version for debuggers, bump whenever changing the layout</source>
          <target state="translated">디버거 용 AA 버전, 레이아웃을 변경할 때마다 충돌</target>
        </trans-unit>
        <trans-unit id="3e563eabeb4bf3cec4d1e28f9fcc377ee1ff90bd" translate="yes" xml:space="preserve">
          <source>AA* &lt;code&gt;aa&lt;/code&gt;</source>
          <target state="translated">AA * &lt;code&gt;aa&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="a0ab529de7da6070afe29cdd8345d68a47ee6fbe" translate="yes" xml:space="preserve">
          <source>AMD Athlon (K7, K8, K10).</source>
          <target state="translated">AMD 애슬론 (K7, K8, K10).</target>
        </trans-unit>
        <trans-unit id="624f7573dca9fe5ebe0a6858283e1c5d9432014a" translate="yes" xml:space="preserve">
          <source>AMD Opcodes</source>
          <target state="translated">AMD Opcodes</target>
        </trans-unit>
        <trans-unit id="039721a06435401a74bdd364a8f46ca9309e70c2" translate="yes" xml:space="preserve">
          <source>AMD Opcodes Supported</source>
          <target state="translated">지원되는 AMD Opcode</target>
        </trans-unit>
        <trans-unit id="4ca0a1dafaea5e84f002eb1c3a7a92dd033b7a8c" translate="yes" xml:space="preserve">
          <source>APIs</source>
          <target state="translated">APIs</target>
        </trans-unit>
        <trans-unit id="6b6bf129e90e87f19aebb266c7797207c07f48fe" translate="yes" xml:space="preserve">
          <source>ARM in Thumb mode; use &lt;code&gt;ARM_Thumb&lt;/code&gt; instead</source>
          <target state="translated">Thumb 모드의 ARM; 사용 &lt;code&gt;ARM_Thumb&lt;/code&gt; 대신</target>
        </trans-unit>
        <trans-unit id="cb1fdcfffd40402c89d0d4bb3b0d681220235dda" translate="yes" xml:space="preserve">
          <source>ARM in any Thumb mode</source>
          <target state="translated">모든 Thumb 모드의 ARM</target>
        </trans-unit>
        <trans-unit id="94090230b1f8c256f7ac5dc5a70bd3b20ee4ff15" translate="yes" xml:space="preserve">
          <source>ASCII</source>
          <target state="translated">ASCII</target>
        </trans-unit>
        <trans-unit id="89174118a4a495c66300fbe7239a480764509b25" translate="yes" xml:space="preserve">
          <source>ASCII i string to capitalize</source>
          <target state="translated">대문자로 표시 할 ASCII i 문자열</target>
        </trans-unit>
        <trans-unit id="0f7fc546df38aeee4d77978d5dcfbe350f0e2747" translate="yes" xml:space="preserve">
          <source>ASCII whitespace</source>
          <target state="translated">ASCII 공백</target>
        </trans-unit>
        <trans-unit id="9ef82a5dc44fd8e8e212aabe32c11cac57294938" translate="yes" xml:space="preserve">
          <source>ASCII-only</source>
          <target state="translated">ASCII-only</target>
        </trans-unit>
        <trans-unit id="6fc55697bc9a0a7e365add2e6ecfcd149e10701c" translate="yes" xml:space="preserve">
          <source>ASCII_Hex_Digit</source>
          <target state="translated">ASCII_Hex_Digit</target>
        </trans-unit>
        <trans-unit id="a579237e1f01010812c214ab27a5b3beb489ff76" translate="yes" xml:space="preserve">
          <source>AST node for &lt;code&gt;EnumDeclaration&lt;/code&gt;&lt;a href=&quot;https://dlang.org/spec/enum.html#EnumDeclaration&quot;&gt;https://dlang.org/spec/enum.html#EnumDeclaration&lt;/a&gt;</source>
          <target state="translated">&lt;code&gt;EnumDeclaration&lt;/code&gt; 에 대한 AST 노드 &lt;a href=&quot;https://dlang.org/spec/enum.html#EnumDeclaration&quot;&gt;https://dlang.org/spec/enum.html#EnumDeclaration&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="e2e1a886f972c32fded02bd26e8e6b865f2eb255" translate="yes" xml:space="preserve">
          <source>AST node representing a member of an enum. &lt;a href=&quot;https://dlang.org/spec/enum.html#EnumMember&quot;&gt;https://dlang.org/spec/enum.html#EnumMember&lt;/a&gt;&lt;a href=&quot;https://dlang.org/spec/enum.html#AnonymousEnumMember&quot;&gt;https://dlang.org/spec/enum.html#AnonymousEnumMember&lt;/a&gt;</source>
          <target state="translated">열거 형 멤버를 나타내는 AST 노드 &lt;a href=&quot;https://dlang.org/spec/enum.html#EnumMember&quot;&gt;https://dlang.org/spec/enum.html#EnumMember &lt;/a&gt;&lt;a href=&quot;https://dlang.org/spec/enum.html#AnonymousEnumMember&quot;&gt;https://dlang.org/spec/enum.html#AnonymousEnumMember&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="4856a925a6f71d775d2a2dd67176ae2d0a9e9f77" translate="yes" xml:space="preserve">
          <source>AST.Expression &lt;strong id=&quot;parsePrimaryExp&quot;&gt;parsePrimaryExp&lt;/strong&gt;();</source>
          <target state="translated">AST.Expression &lt;strong id=&quot;parsePrimaryExp&quot;&gt;parsePrimaryExp&lt;/strong&gt; ();</target>
        </trans-unit>
        <trans-unit id="c3fec866346bd5e2dcb25d972f5a97367df05503" translate="yes" xml:space="preserve">
          <source>AST.Statement &lt;strong id=&quot;parseStatement&quot;&gt;parseStatement&lt;/strong&gt;(int flags, const(char)** endPtr = null, Loc* pEndloc = null);</source>
          <target state="translated">AST.Statement &lt;strong id=&quot;parseStatement&quot;&gt;parseStatement&lt;/strong&gt; (int 플래그, const (char) ** endPtr = null, Loc * pEndloc = null);</target>
        </trans-unit>
        <trans-unit id="debca9f07fb54076426713e9f9bdcd3e1e056b0e" translate="yes" xml:space="preserve">
          <source>AVX Vector instructions are supported</source>
          <target state="translated">AVX Vector 지침이 지원됩니다</target>
        </trans-unit>
        <trans-unit id="44a916ba2993444e910670ef65cccc667bfc068f" translate="yes" xml:space="preserve">
          <source>AVX2 Vector instructions are supported</source>
          <target state="translated">AVX2 Vector 지침이 지원됩니다</target>
        </trans-unit>
        <trans-unit id="fc32691eed408bcffd208331061395fcb95f2539" translate="yes" xml:space="preserve">
          <source>Abb.</source>
          <target state="translated">Abb.</target>
        </trans-unit>
        <trans-unit id="d87c8562414047004383cefab06dde994ab29260" translate="yes" xml:space="preserve">
          <source>Abort due to constraint violation</source>
          <target state="translated">제약 조건 위반으로 중단</target>
        </trans-unit>
        <trans-unit id="28ef1e43dd92ae02027dd18a6bebb7e635d80224" translate="yes" xml:space="preserve">
          <source>Abort the SQL statement with an error</source>
          <target state="translated">오류가있는 SQL 문 중단</target>
        </trans-unit>
        <trans-unit id="14230c93975c238bf7c790d700013262220823e1" translate="yes" xml:space="preserve">
          <source>Abort the send and return.</source>
          <target state="translated">송신 및 반송을 중단하십시오.</target>
        </trans-unit>
        <trans-unit id="aa41dd8e948e2dab26d97077811c4859daf44a19" translate="yes" xml:space="preserve">
          <source>Above, &lt;code&gt;Foo!().foo&lt;/code&gt; will work just the same as a member function of class &lt;code&gt;C&lt;/code&gt;, and &lt;code&gt;Bar!().bar&lt;/code&gt; will work just the same as a nested function within function &lt;code&gt;main()&lt;/code&gt;.</source>
          <target state="translated">위의 &lt;code&gt;Foo!().foo&lt;/code&gt; 는 클래스 &lt;code&gt;C&lt;/code&gt; 의 멤버 함수와 동일하게 작동 하며 &lt;code&gt;Bar!().bar&lt;/code&gt; 는 &lt;code&gt;main()&lt;/code&gt; 함수 내 중첩 함수와 동일하게 작동합니다 .</target>
        </trans-unit>
        <trans-unit id="72be1abc9c41f18cb036851d094c7e5ee1691674" translate="yes" xml:space="preserve">
          <source>Absolute tolerance.</source>
          <target state="translated">절대 공차.</target>
        </trans-unit>
        <trans-unit id="5065cb3ac6b52ca94db622cc45ddec46996ff941" translate="yes" xml:space="preserve">
          <source>Abstract base class for XML items</source>
          <target state="translated">XML 항목에 대한 추상 기본 클래스</target>
        </trans-unit>
        <trans-unit id="fa5896f602b41f6e737833e94bdb9dfbf32d9f47" translate="yes" xml:space="preserve">
          <source>Abstract base class of all encoding schemes</source>
          <target state="translated">모든 인코딩 체계의 추상 기본 클래스</target>
        </trans-unit>
        <trans-unit id="fd71c6586a6fb20a005525c1ab9479acf96f2316" translate="yes" xml:space="preserve">
          <source>Abstract characters not directly encoded by the Unicode Standard can often be represented by the use of combining character sequences.</source>
          <target state="translated">유니 코드 표준으로 직접 인코딩되지 않은 추상 문자는 종종 문자 시퀀스를 결합하여 표현할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c9ce51b5c3d269c08cea6f74d4b2f5fd2e587775" translate="yes" xml:space="preserve">
          <source>Accept an incoming connection. If the socket is blocking, &lt;code&gt;accept&lt;/code&gt; waits for a connection request. Throws &lt;code&gt;SocketAcceptException&lt;/code&gt; if unable to accept. See &lt;code&gt;accepting&lt;/code&gt; for use with derived classes.</source>
          <target state="translated">들어오는 연결을 수락하십시오. 소켓이 블로킹 중이면 &lt;code&gt;accept&lt;/code&gt; 는 연결 요청을 기다립니다. 예외 &lt;code&gt;SocketAcceptException&lt;/code&gt; 경우는 수락 할 수 없습니다. 파생 클래스 사용 &lt;code&gt;accepting&lt;/code&gt; 을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="3697222ce3b5ee0c832014446956a71a9e3f9768" translate="yes" xml:space="preserve">
          <source>Accepted units are &lt;code&gt;&quot;days&quot;&lt;/code&gt;, &lt;code&gt;&quot;minutes&quot;&lt;/code&gt;, &lt;code&gt;&quot;hours&quot;&lt;/code&gt;, &lt;code&gt;&quot;minutes&quot;&lt;/code&gt;, &lt;code&gt;&quot;seconds&quot;&lt;/code&gt;, &lt;code&gt;&quot;msecs&quot;&lt;/code&gt;, &lt;code&gt;&quot;usecs&quot;&lt;/code&gt;, and &lt;code&gt;&quot;hnsecs&quot;&lt;/code&gt;.</source>
          <target state="translated">허용되는 단위는 &lt;code&gt;&quot;days&quot;&lt;/code&gt; , &lt;code&gt;&quot;minutes&quot;&lt;/code&gt; , &lt;code&gt;&quot;hours&quot;&lt;/code&gt; , &lt;code&gt;&quot;minutes&quot;&lt;/code&gt; , &lt;code&gt;&quot;seconds&quot;&lt;/code&gt; , &lt;code&gt;&quot;msecs&quot;&lt;/code&gt; , &lt;code&gt;&quot;usecs&quot;&lt;/code&gt; 및 &lt;code&gt;&quot;hnsecs&quot;&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="e4354a6713d7ad0caea954c67b888e32cf0474a8" translate="yes" xml:space="preserve">
          <source>Accepted units are &lt;code&gt;&quot;days&quot;&lt;/code&gt;, &lt;code&gt;&quot;minutes&quot;&lt;/code&gt;, &lt;code&gt;&quot;hours&quot;&lt;/code&gt;, &lt;code&gt;&quot;minutes&quot;&lt;/code&gt;, and &lt;code&gt;&quot;seconds&quot;&lt;/code&gt;.</source>
          <target state="translated">허용되는 단위는 &lt;code&gt;&quot;days&quot;&lt;/code&gt; , &lt;code&gt;&quot;minutes&quot;&lt;/code&gt; , &lt;code&gt;&quot;hours&quot;&lt;/code&gt; , &lt;code&gt;&quot;minutes&quot;&lt;/code&gt; 및 &lt;code&gt;&quot;seconds&quot;&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="5fe93e8eee53666f950c9ca80808bfeb7d041149" translate="yes" xml:space="preserve">
          <source>Accepted units are &lt;code&gt;&quot;hours&quot;&lt;/code&gt;, &lt;code&gt;&quot;minutes&quot;&lt;/code&gt;, and &lt;code&gt;&quot;seconds&quot;&lt;/code&gt;.</source>
          <target state="translated">허용되는 단위는 &lt;code&gt;&quot;hours&quot;&lt;/code&gt; , &lt;code&gt;&quot;minutes&quot;&lt;/code&gt; 및 &lt;code&gt;&quot;seconds&quot;&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="2757cba57a7420e39d1261498e6488dd5ac45155" translate="yes" xml:space="preserve">
          <source>Accepts a path to either a file or a directory. In the former case, the basepath (path to the containing directory) will be checked for existence, and created if it does not exists. In the later case, the directory pointed to will be checked for existence and created if needed.</source>
          <target state="translated">파일 또는 디렉토리의 경로를 승인합니다. 전자의 경우, 기본 경로 (포함 디렉토리의 경로)가 존재하는지 점검하고 존재하지 않는 경우 작성됩니다. 후자의 경우, 지정된 디렉토리의 존재 여부를 점검하고 필요한 경우 작성됩니다.</target>
        </trans-unit>
        <trans-unit id="baa49dd84c2f97d1400c5b886e7457901cafa944" translate="yes" xml:space="preserve">
          <source>Access C++ std::type_info's virtual functions from D, being careful to not require linking with libstd++ or interfere with core.stdcpp.typeinfo. So, give it a different name.</source>
          <target state="translated">libstd ++와 연결하거나 core.stdcpp.typeinfo를 방해하지 않도록주의하면서 D에서 C ++ std :: type_info의 가상 함수에 액세스하십시오. 따라서 다른 이름을 지정하십시오.</target>
        </trans-unit>
        <trans-unit id="8cee105dc9286540eb8273e1a66712fc79c398e3" translate="yes" xml:space="preserve">
          <source>Access Control</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c1777ced1e09bfb3a20d75e96ad2f4ce23f4f24f" translate="yes" xml:space="preserve">
          <source>Access labels AA from C++ code.</source>
          <target state="translated">C ++ 코드에서 AA 레이블에 액세스하십시오.</target>
        </trans-unit>
        <trans-unit id="cf0ad5ada4db8ecde7f83bac072e7c784cdc3f1f" translate="yes" xml:space="preserve">
          <source>Access permission denied</source>
          <target state="translated">액세스 권한이 거부되었습니다</target>
        </trans-unit>
        <trans-unit id="bee6f9fa537ba79f8b898add7fb4d8af609c3d99" translate="yes" xml:space="preserve">
          <source>Access the members of the object e. This type is same as e.type.</source>
          <target state="translated">객체의 멤버에 액세스합니다. e. 이 유형은 e.type과 동일합니다.</target>
        </trans-unit>
        <trans-unit id="dd91024887ec34e3b4d4c550ead58d4e228f98e0" translate="yes" xml:space="preserve">
          <source>Access to a large selection of commonly used sets of &lt;a href=&quot;#Code%20point&quot;&gt;code points&lt;/a&gt;. &lt;a href=&quot;#Unicode%20properties&quot;&gt;Supported sets&lt;/a&gt; include Script, Block and General Category. The exact contents of a set can be observed in the CLDR utility, on the &lt;a href=&quot;http://www.unicode.org/cldr/utility/properties.jsp&quot;&gt;property index&lt;/a&gt; page of the Unicode website. See &lt;a href=&quot;#unicode&quot;&gt;&lt;code&gt;unicode&lt;/code&gt;&lt;/a&gt; for easy and (optionally) compile-time checked set queries.</source>
          <target state="translated">일반적으로 사용되는 다양한 &lt;a href=&quot;#Code%20point&quot;&gt;코드 포인트&lt;/a&gt; 세트에 액세스합니다 . &lt;a href=&quot;#Unicode%20properties&quot;&gt;지원되는 세트&lt;/a&gt; 에는 스크립트, 차단 및 일반 범주가 포함됩니다. 세트의 정확한 내용은 CLDR 유틸리티 의 유니 코드 웹 사이트 의 &lt;a href=&quot;http://www.unicode.org/cldr/utility/properties.jsp&quot;&gt;특성 색인&lt;/a&gt; 페이지에서 확인할 수 있습니다. 쉬운 컴파일 타임 검사 세트 쿼리에 대해서는 &lt;a href=&quot;#unicode&quot;&gt; &lt;code&gt;unicode&lt;/code&gt; &lt;/a&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="7f2d0eae88d66a5fc766687a84f6f7f91d5ae27d" translate="yes" xml:space="preserve">
          <source>Access to class members is controlled using &lt;a href=&quot;attribute#visibility_attributes&quot;&gt; visibility attributes&lt;/a&gt;. The default visibility attribute is &lt;code&gt;public&lt;/code&gt;.</source>
          <target state="translated">클래스 멤버에 대한 액세스는 &lt;a href=&quot;attribute#visibility_attributes&quot;&gt;가시성 속성을&lt;/a&gt; 사용하여 제어됩니다 . 기본 가시성 속성은 &lt;code&gt;public&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="307fc632b58de82a174b55210d8d42a94693e17a" translate="yes" xml:space="preserve">
          <source>Access to variadic arguments is done using the standard library module &lt;code&gt;core.stdc.stdarg&lt;/code&gt;.</source>
          <target state="translated">가변성 인수에 대한 액세스는 표준 라이브러리 모듈 &lt;code&gt;core.stdc.stdarg&lt;/code&gt; 를 사용하여 수행됩니다 .</target>
        </trans-unit>
        <trans-unit id="f6f1467ab57ce45967443e18135c914da7e45a13" translate="yes" xml:space="preserve">
          <source>Accessing C Globals</source>
          <target state="translated">C Globals에 액세스</target>
        </trans-unit>
        <trans-unit id="beb23fe078814adbeacefa1f1f2dfb764f4b3413" translate="yes" xml:space="preserve">
          <source>Accessing Individual Vector Elements</source>
          <target state="translated">개별 벡터 요소에 액세스</target>
        </trans-unit>
        <trans-unit id="db7fc46962b3e4858cae12b974315033c117901c" translate="yes" xml:space="preserve">
          <source>Accessing variable v. Check for purity and safety violations. Returns true if error occurs.</source>
          <target state="translated">변수 접근 v. 순도 및 안전 위반 여부를 확인하십시오. 오류가 발생하면 true를 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="9beb96dac88f56752e0ce800d691ef1a92595d9b" translate="yes" xml:space="preserve">
          <source>Acknowledge</source>
          <target state="translated">Acknowledge</target>
        </trans-unit>
        <trans-unit id="4d47f537dcb350bf669800548ceb300b34426ee2" translate="yes" xml:space="preserve">
          <source>Acquires a read lock on the enclosing mutex.</source>
          <target state="translated">둘러싸는 뮤텍스에 대한 읽기 잠금을 획득합니다.</target>
        </trans-unit>
        <trans-unit id="99ed81fec0ff177b818b848aa967a2dc6a60b509" translate="yes" xml:space="preserve">
          <source>Acquires a write lock on the enclosing mutex.</source>
          <target state="translated">둘러싸는 뮤텍스에 대한 쓰기 잠금을 획득합니다.</target>
        </trans-unit>
        <trans-unit id="34be5c3351b113f2cad4cc4a8602e9f1303b4543" translate="yes" xml:space="preserve">
          <source>Adam D. Ruppe</source>
          <target state="translated">아담 D. 루페</target>
        </trans-unit>
        <trans-unit id="6e9e257be9ac18996821b962c7a49ec73c7aba38" translate="yes" xml:space="preserve">
          <source>Adapted with minimal changes from the work of David L. Davis (refer to the &lt;a href=&quot;http://forum.dlang.org/post/cfk7ql&amp;amp;dollar;1p4n&amp;amp;dollar;1@digitaldaemon.com&quot;&gt;original announcement&lt;/a&gt;).</source>
          <target state="translated">David L. Davis의 작업에서 최소한의 변화로 적응 ( &lt;a href=&quot;http://forum.dlang.org/post/cfk7ql&amp;amp;dollar;1p4n&amp;amp;dollar;1@digitaldaemon.com&quot;&gt;원래 발표&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="2c5a3264f3bad4a3d08e2dbdc79dc6adf56d9043" translate="yes" xml:space="preserve">
          <source>Add Content To A Dynamic String</source>
          <target state="translated">동적 문자열에 내용 추가</target>
        </trans-unit>
        <trans-unit id="783f29b92ccf3cb30aa2e12d525b1971eef1ba41" translate="yes" xml:space="preserve">
          <source>Add Expressions</source>
          <target state="translated">식 추가</target>
        </trans-unit>
        <trans-unit id="1a1ad0f8b610189b63e4cb0f7b4aed4a9b1d3a61" translate="yes" xml:space="preserve">
          <source>Add MODxxxx bits to existing type. We're adding, not replacing, so adding const to a shared type =&amp;gt; &quot;shared const&quot;</source>
          <target state="translated">기존 유형에 MODxxxx 비트를 추가하십시오. 우리는 대체하지 않고 추가하고 있으므로 공유 유형에 const 추가 =&amp;gt; &quot;shared const&quot;</target>
        </trans-unit>
        <trans-unit id="2f6598ae97b68f3c9b2eca03bcb16039c37701f3" translate="yes" xml:space="preserve">
          <source>Add a &lt;code&gt;Socket&lt;/code&gt; to the collection. The socket must not already be in the collection.</source>
          <target state="translated">컬렉션에 &lt;code&gt;Socket&lt;/code&gt; 을 추가하십시오 . 소켓이 아직 콜렉션에 없어야합니다.</target>
        </trans-unit>
        <trans-unit id="cf47751bc3702034406ec509e784f3ea1eb6200d" translate="yes" xml:space="preserve">
          <source>Add a command to send to ftp server.</source>
          <target state="translated">ftp 서버로 보낼 명령을 추가하십시오.</target>
        </trans-unit>
        <trans-unit id="e665ffb3cdd40a1e58b3bf5dfd0804b5aaf86432" translate="yes" xml:space="preserve">
          <source>Add a header e.g. &quot;X-CustomField: Something is fishy&quot;.</source>
          <target state="translated">헤더를 추가하십시오 (예 : &quot;X-CustomField : 무엇인가 비린내&quot;).</target>
        </trans-unit>
        <trans-unit id="f9b93c9a5ae048bb45d10d62122638eca633993f" translate="yes" xml:space="preserve">
          <source>Add a slot to the list of slots to be called when emit() is called.</source>
          <target state="translated">emit ()가 호출 될 때 호출 될 슬롯 목록에 슬롯을 추가하십시오.</target>
        </trans-unit>
        <trans-unit id="58e96b8b192b5161f00d42ec478ec85a678ec3b1" translate="yes" xml:space="preserve">
          <source>Add an IP group membership</source>
          <target state="translated">IP 그룹 멤버십 추가</target>
        </trans-unit>
        <trans-unit id="eaee2d4a639caa6d286ce081d0fec7d81fdd68aa" translate="yes" xml:space="preserve">
          <source>Add an interval [a, b) to this set.</source>
          <target state="translated">이 세트에 간격 [a, b)를 추가하십시오.</target>
        </trans-unit>
        <trans-unit id="d58f391b6636a37e4ed4aadaddc8bc0a051e9638" translate="yes" xml:space="preserve">
          <source>Add an user-supplied global identifier to the list</source>
          <target state="translated">사용자 제공 글로벌 식별자를 목록에 추가</target>
        </trans-unit>
        <trans-unit id="68f594a7d8331d79aa134583b826df0691870790" translate="yes" xml:space="preserve">
          <source>Add an user-supplied identifier to the list of global debug identifiers</source>
          <target state="translated">전역 디버그 식별자 목록에 사용자 제공 식별자 추가</target>
        </trans-unit>
        <trans-unit id="ff5f9ed6a9198f29682b6e2fdc1784d631624385" translate="yes" xml:space="preserve">
          <source>Add any global identifier to the list, without checking if it's predefined</source>
          <target state="translated">미리 정의되어 있는지 확인하지 않고 목록에 전역 식별자를 추가하십시오.</target>
        </trans-unit>
        <trans-unit id="180269a30ba169b4ad5b7a1b7661b30529e56f3a" translate="yes" xml:space="preserve">
          <source>Add de to the archive. The file is compressed on the fly.</source>
          <target state="translated">아카이브에 de를 추가하십시오. 파일이 즉시 압축됩니다.</target>
        </trans-unit>
        <trans-unit id="0795781eaf01631d4376c4aabb0efd2f797184aa" translate="yes" xml:space="preserve">
          <source>Add default &lt;code&gt;version&lt;/code&gt; identifier for dmd, and set the target platform in &lt;code&gt;params&lt;/code&gt;. &lt;a href=&quot;https://dlang.org/spec/version.html#predefined-versions&quot;&gt;https://dlang.org/spec/version.html#predefined-versions&lt;/a&gt;</source>
          <target state="translated">dmd의 기본 &lt;code&gt;version&lt;/code&gt; ID를 추가 하고 대상 플랫폼을 &lt;code&gt;params&lt;/code&gt; 로 설정하십시오 . &lt;a href=&quot;https://dlang.org/spec/version.html#predefined-versions&quot;&gt;https://dlang.org/spec/version.html#predefined-versions&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="c84400b54e58a4517104843b16d7336ce756b1a0" translate="yes" xml:space="preserve">
          <source>Add documentation comment to Dsymbol. Ignore NULL comments.</source>
          <target state="translated">Dsymbol에 문서 주석을 추가하십시오. NULL 주석을 무시하십시오.</target>
        </trans-unit>
        <trans-unit id="b821ad6b597b9aa864b5401ed9295cf33f19f5bb" translate="yes" xml:space="preserve">
          <source>Add empty fields for padding to have a total bit length of 8, 16, 32, or 64</source>
          <target state="translated">패딩을 위해 빈 필드를 추가하여 총 비트 길이가 8, 16, 32 또는 64가되도록하십시오.</target>
        </trans-unit>
        <trans-unit id="27e8affa9a2779909d012a0a9e565d5d9c4930bc" translate="yes" xml:space="preserve">
          <source>Add expressions for floating point operands are not associative.</source>
          <target state="translated">부동 소수점 피연산자에 대한 추가 표현식은 연관성이 없습니다.</target>
        </trans-unit>
        <trans-unit id="39654cee35d80be4140c48c2f4acb0a4d3eddad1" translate="yes" xml:space="preserve">
          <source>Add import path to the &lt;code&gt;global.path&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;global.path&lt;/code&gt; 에 가져 오기 경로를 추가하십시오 .</target>
        </trans-unit>
        <trans-unit id="9ca0c9e82595b2ff7d12c349025925ae8755eaf0" translate="yes" xml:space="preserve">
          <source>Add import to sd's symbol table.</source>
          <target state="translated">sd의 심볼 테이블에 가져 오기를 추가하십시오.</target>
        </trans-unit>
        <trans-unit id="da23c7c2b4b6933ac5908203dac9c52485b7b4dd" translate="yes" xml:space="preserve">
          <source>Add instance ti to TemplateDeclaration's table of instances. Return a handle we can use to later remove it if it fails instantiation.</source>
          <target state="translated">TemplateDeclaration의 인스턴스 테이블에 인스턴스 ti를 추가하십시오. 인스턴스화에 실패한 경우 나중에 제거하는 데 사용할 수있는 핸들을 반환하십시오.</target>
        </trans-unit>
        <trans-unit id="4d414082ffd854e8335dc0549b71c84435addf66" translate="yes" xml:space="preserve">
          <source>Add or get a file from the file cache. If the file isn't part of the cache, it will be read from the filesystem. If the file has been read before, the cached file object will be returned</source>
          <target state="translated">파일 캐시에서 파일을 추가하거나 가져옵니다. 파일이 캐시의 일부가 아닌 경우 파일 시스템에서 읽습니다. 파일을 전에 읽은 경우 캐시 된 파일 객체가 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="a520040bdffe08f3eefdcecf7998ef8840dd4783" translate="yes" xml:space="preserve">
          <source>Add storage class modifiers to type.</source>
          <target state="translated">입력 할 스토리지 클래스 수정자를 추가하십시오.</target>
        </trans-unit>
        <trans-unit id="0dc5179d5d1626885bf2c954280bebcdbc0811f9" translate="yes" xml:space="preserve">
          <source>Add string import path to &lt;code&gt;global.filePath&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;global.filePath&lt;/code&gt; 에 문자열 가져 오기 경로를 추가하십시오 .</target>
        </trans-unit>
        <trans-unit id="37089788442ff881d462af2da489fd68f0412cb3" translate="yes" xml:space="preserve">
          <source>Add t to the list of tracked threads if it is not already being tracked.</source>
          <target state="translated">아직 추적되지 않은 경우 추적 된 스레드 목록에 t를 추가하십시오.</target>
        </trans-unit>
        <trans-unit id="a88d5dd379a53bc3a2adc9fd4af43267e851bf42" translate="yes" xml:space="preserve">
          <source>Add the extension &lt;code&gt;ext&lt;/code&gt; to &lt;code&gt;name&lt;/code&gt;, regardless of the content of &lt;code&gt;name&lt;/code&gt;</source>
          <target state="translated">확장 추가 &lt;code&gt;ext&lt;/code&gt; 에 &lt;code&gt;name&lt;/code&gt; 의 내용에 관계없이, &lt;code&gt;name&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="52a02a5e1fb93d0d15ea7fa0332d56723a1247a4" translate="yes" xml:space="preserve">
          <source>Add to precision as necessary so that the first digit of the octal formatting is a '0', even if both the argument and the</source>
          <target state="translated">8 진수 형식의 첫 번째 숫자가 인수와</target>
        </trans-unit>
        <trans-unit id="66d00d03ee0d2653e725dd73702a2661d7a02c6b" translate="yes" xml:space="preserve">
          <source>Add two signed integers, checking for overflow.</source>
          <target state="translated">오버플로를 검사하여 부호있는 정수 두 개를 추가하십시오.</target>
        </trans-unit>
        <trans-unit id="66fdaf8b303799ed2eb7e0bf44cbe2a7bcbf9b7d" translate="yes" xml:space="preserve">
          <source>Add two unsigned integers, checking for overflow (aka carry).</source>
          <target state="translated">오버플로 (일명 캐리)를 확인하면서 부호없는 정수 두 개를 추가합니다.</target>
        </trans-unit>
        <trans-unit id="edb4a17762e7e7667165a329429cbc010d27e3c1" translate="yes" xml:space="preserve">
          <source>Add variable to maybes[]. When a maybescope variable &lt;code&gt;v&lt;/code&gt; is assigned to a maybescope variable &lt;code&gt;this&lt;/code&gt;, we cannot determine if &lt;code&gt;this&lt;/code&gt; is actually scope until the semantic analysis for the function is completed. Thus, we save the data until then.</source>
          <target state="translated">아마도 []에 변수를 추가하십시오. maybescope 변수 &lt;code&gt;v&lt;/code&gt; 가 maybescope 변수 &lt;code&gt;this&lt;/code&gt; 에 할당 되면 함수의 의미 분석이 완료 될 때까지 &lt;code&gt;this&lt;/code&gt; 실제로 범위 인지 확인할 수 없습니다 . 따라서 그때까지 데이터를 저장합니다.</target>
        </trans-unit>
        <trans-unit id="3aaf26753f5eadebbc6849954cfee254c2f15e1d" translate="yes" xml:space="preserve">
          <source>Added Since CV4</source>
          <target state="translated">CV4 이후 추가</target>
        </trans-unit>
        <trans-unit id="a4990b86487a33fe06b07471000a0e208027a17e" translate="yes" xml:space="preserve">
          <source>Added to Bionic since Lollipop.</source>
          <target state="translated">롤리팝 이후 Bionic에 추가되었습니다.</target>
        </trans-unit>
        <trans-unit id="86922b5391f09bc921f8e0e85beb11adcc142c71" translate="yes" xml:space="preserve">
          <source>Adding &lt;code&gt;deallocate&lt;/code&gt; capability to an allocator that lacks it (such as simple regions).</source>
          <target state="translated">&lt;code&gt;deallocate&lt;/code&gt; 기능이없는 할당 자 (예 : 단순 영역)에 할당 해제 기능 추가</target>
        </trans-unit>
        <trans-unit id="1667d04dd978ce8b93994c5e6826422d13b6b5b0" translate="yes" xml:space="preserve">
          <source>Adding Contracts to Java</source>
          <target state="translated">Java에 계약 추가</target>
        </trans-unit>
        <trans-unit id="5d4e406e41eeda4c6401647b660b3cce1ffbd218" translate="yes" xml:space="preserve">
          <source>Adding or subtracting a &lt;a href=&quot;#Duration&quot;&gt;&lt;code&gt;Duration&lt;/code&gt;&lt;/a&gt; to/from a MonoTime results in a MonoTime which is adjusted by that amount.</source>
          <target state="translated">MonoTime에 /에서 &lt;a href=&quot;#Duration&quot;&gt; &lt;code&gt;Duration&lt;/code&gt; &lt;/a&gt; 을 더하거나 빼면 해당 양에 따라 MonoTime이 조정됩니다.</target>
        </trans-unit>
        <trans-unit id="5b8df2ffa33c3a92e63907cf222e7bd23c2fa650" translate="yes" xml:space="preserve">
          <source>Adding your own Garbage Collector</source>
          <target state="translated">자신의 가비지 수집기 추가</target>
        </trans-unit>
        <trans-unit id="5d6556acb18b8662a066437c99c4df78f7b12865" translate="yes" xml:space="preserve">
          <source>Additional &lt;code&gt;Logger&lt;/code&gt; can be created by creating a new instance of the required &lt;code&gt;Logger&lt;/code&gt;.</source>
          <target state="translated">필요한 &lt;code&gt;Logger&lt;/code&gt; 의 새 인스턴스를 작성하여 추가 &lt;code&gt;Logger&lt;/code&gt; 작성할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="5d317f4f1de7128a0d4cd8fd921eb8e06ea7ebc6" translate="yes" xml:space="preserve">
          <source>Additional environment variables for the child process.</source>
          <target state="translated">하위 프로세스에 대한 추가 환경 변수</target>
        </trans-unit>
        <trans-unit id="168245e7982df504f3251c14992ea04ceb75d2cc" translate="yes" xml:space="preserve">
          <source>Additional environment variables for the child process. (See &lt;a href=&quot;#spawnProcess&quot;&gt;&lt;code&gt;spawnProcess&lt;/code&gt;&lt;/a&gt; for details.)</source>
          <target state="translated">하위 프로세스에 대한 추가 환경 변수 (자세한 내용은 &lt;a href=&quot;#spawnProcess&quot;&gt; &lt;code&gt;spawnProcess&lt;/code&gt; &lt;/a&gt; 를 참조하십시오.)</target>
        </trans-unit>
        <trans-unit id="e835350d1c68a871d44080439d13025d3be377ee" translate="yes" xml:space="preserve">
          <source>Additionally the following attributes are only valid for non-static member functions:</source>
          <target state="translated">또한 다음 속성은 비 정적 멤버 함수에만 유효합니다.</target>
        </trans-unit>
        <trans-unit id="e0f1260010cd19b58b440bfbe6492df580b2aeb8" translate="yes" xml:space="preserve">
          <source>Additionally, this example shows how a new &lt;code&gt;FileLogger&lt;/code&gt; is created. Individual &lt;code&gt;Logger&lt;/code&gt; and the global log functions share commonly named functions to log data.  The names of the functions are as follows:</source>
          <target state="translated">또한이 예제는 새로운 &lt;code&gt;FileLogger&lt;/code&gt; 가 작성 되는 방법을 보여줍니다 . 개별 &lt;code&gt;Logger&lt;/code&gt; 와 전역 로그 기능은 일반적으로 명명 된 기능을 공유하여 데이터를 기록합니다. 기능의 이름은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="a136ff61f84c9c4a7228e88b27550819c0abee84" translate="yes" xml:space="preserve">
          <source>Address &lt;strong id=&quot;address&quot;&gt;address&lt;/strong&gt;;</source>
          <target state="translated">주소 &lt;strong id=&quot;address&quot;&gt;주소&lt;/strong&gt; ;</target>
        </trans-unit>
        <trans-unit id="b544b7ba62b9aa270da33d07d9f1852fc51631a7" translate="yes" xml:space="preserve">
          <source>Address containing warnings is considered valid, that is, any status code below 16 is considered valid.</source>
          <target state="translated">경고가 포함 된 주소는 유효한 것으로 간주됩니다. 즉, 16 미만의 모든 상태 코드는 유효한 것으로 간주됩니다.</target>
        </trans-unit>
        <trans-unit id="5a1be6fc1f7f9662fc7c2b17d5434e70a4a8f2ab" translate="yes" xml:space="preserve">
          <source>Address contains Folding White Space</source>
          <target state="translated">접는 공백이 포함 된 주소</target>
        </trans-unit>
        <trans-unit id="887781f145aaaf658d75f1517b0fb398589f6ee9" translate="yes" xml:space="preserve">
          <source>Address contains a carriage return that is not followed by a line feed</source>
          <target state="translated">주소에 줄 바꿈이없는 캐리지 리턴이 있습니다.</target>
        </trans-unit>
        <trans-unit id="62b80eb5466f5d5ffa1ab6d5b43626ec70a85c2d" translate="yes" xml:space="preserve">
          <source>Address contains a character that is not allowed</source>
          <target state="translated">주소에 허용되지 않는 문자가 포함되어 있습니다</target>
        </trans-unit>
        <trans-unit id="92528dcc41ae0f2a64e93d533de3ccfed0b942e5" translate="yes" xml:space="preserve">
          <source>Address contains a comment in a position that is deprecated</source>
          <target state="translated">더 이상 사용되지 않는 위치에 설명이 포함 된 주소</target>
        </trans-unit>
        <trans-unit id="9c918d7b9e49563c6cbad6a857c4705bf794b76c" translate="yes" xml:space="preserve">
          <source>Address contains a comment or Folding White Space around the @ sign</source>
          <target state="translated">주소에 @ 기호 주위에 주석이나 접는 공백이 있습니다.</target>
        </trans-unit>
        <trans-unit id="65380a42fab34c0f4121362666fdd9910ff2d19a" translate="yes" xml:space="preserve">
          <source>Address contains an obsolete form of Folding White Space</source>
          <target state="translated">주소에 쓸모없는 접기 공백이 들어 있습니다.</target>
        </trans-unit>
        <trans-unit id="381c317957b5ee7582e73884cd558cdbc223631b" translate="yes" xml:space="preserve">
          <source>Address contains comments</source>
          <target state="translated">주소는 의견을 포함</target>
        </trans-unit>
        <trans-unit id="a5e2d3cb1fcbce606eb8ccac93ab49310a74b07e" translate="yes" xml:space="preserve">
          <source>Address contains deprecated elements but may still be valid in restricted contexts</source>
          <target state="translated">주소에 더 이상 사용되지 않는 요소가 포함되어 있지만 제한된 컨텍스트에서 여전히 유효 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="88121f59a17918138d3a99669a4d019180020a55" translate="yes" xml:space="preserve">
          <source>Address contains text after a comment or Folding White Space</source>
          <target state="translated">주석 또는 접는 공백 뒤에 텍스트가 포함 된 주소</target>
        </trans-unit>
        <trans-unit id="b7efe220560e0d5cd3e5e7d43e3e3fd9aca69e6a" translate="yes" xml:space="preserve">
          <source>Address contains text after a quoted string</source>
          <target state="translated">따옴표로 묶인 문자열 뒤에 텍스트가 포함 된 주소</target>
        </trans-unit>
        <trans-unit id="ee43b6fd8e15e2b41602e256006bcdb0082b3ca4" translate="yes" xml:space="preserve">
          <source>Address family</source>
          <target state="translated">주소 패밀리</target>
        </trans-unit>
        <trans-unit id="b8ef22713afbe995add506093e861ef3d18ab313" translate="yes" xml:space="preserve">
          <source>Address has no domain part</source>
          <target state="translated">주소에 도메인 부분이 없습니다</target>
        </trans-unit>
        <trans-unit id="71bff518935e72def54800521f7700ba45be35d6" translate="yes" xml:space="preserve">
          <source>Address has no local part</source>
          <target state="translated">주소에 로컬 부분이 없습니다</target>
        </trans-unit>
        <trans-unit id="e0517bb692824017669287d8571ea86907ce7eb9" translate="yes" xml:space="preserve">
          <source>Address is RFC 5322 compliant but contains domain characters that are not allowed by DNS</source>
          <target state="translated">주소는 RFC 5322를 준수하지만 DNS에서 허용하지 않는 도메인 문자를 포함합니다</target>
        </trans-unit>
        <trans-unit id="d576c3642c5b3b413429d68ea79dca4c6c19abca" translate="yes" xml:space="preserve">
          <source>Address is either considered valid or not, no finer grained error checking is performed. Returned email status code will be either Error or Valid.</source>
          <target state="translated">주소가 유효하거나 유효하지 않은 것으로 간주되며보다 세밀한 오류 검사가 수행되지 않습니다. 반환 된 이메일 상태 코드는 Error 또는 Valid입니다.</target>
        </trans-unit>
        <trans-unit id="fbe50a7d373fa45401392dba0d4f4263b57fb794" translate="yes" xml:space="preserve">
          <source>Address is invalid for any purpose</source>
          <target state="translated">어떤 목적 으로든 주소가 유효하지 않습니다</target>
        </trans-unit>
        <trans-unit id="1f1d8cab19a432244d5e438db730dcd5d7cfc3c1" translate="yes" xml:space="preserve">
          <source>Address is marked.</source>
          <target state="translated">주소가 표시되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="056f415145809cf554f197edff3a6210c2a3c84c" translate="yes" xml:space="preserve">
          <source>Address is not managed by the GC.</source>
          <target state="translated">주소는 GC에서 관리하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="b276a2a7b3b8082b5205d4f36c48fdb75ab436d5" translate="yes" xml:space="preserve">
          <source>Address is not marked.</source>
          <target state="translated">주소가 표시되어 있지 않습니다.</target>
        </trans-unit>
        <trans-unit id="00d60928d09249fd5121c82ffadb486ff2af7cda" translate="yes" xml:space="preserve">
          <source>Address is too long</source>
          <target state="translated">주소가 너무 깁니다</target>
        </trans-unit>
        <trans-unit id="7114aec6ccd6343782971decf3ba885ed8926cea" translate="yes" xml:space="preserve">
          <source>Address is valid</source>
          <target state="translated">주소가 유효합니다</target>
        </trans-unit>
        <trans-unit id="8684bf895369a504a173494b46ce79f3bfbff7cd" translate="yes" xml:space="preserve">
          <source>Address is valid but a DNS check was not successful</source>
          <target state="translated">주소는 유효하지만 DNS 확인에 실패했습니다</target>
        </trans-unit>
        <trans-unit id="910b30a1f7f08850b97f7aabdcb68e08a1bc037b" translate="yes" xml:space="preserve">
          <source>Address is valid but at a Top Level Domain</source>
          <target state="translated">주소는 유효하지만 최상위 도메인에 있습니다.</target>
        </trans-unit>
        <trans-unit id="8be421532761d6177a79b25f6bf4e24d2aa48096" translate="yes" xml:space="preserve">
          <source>Address is valid but at a literal address not a domain</source>
          <target state="translated">주소는 유효하지만 도메인이 아닌 리터럴 주소</target>
        </trans-unit>
        <trans-unit id="b2a0d6b7ee4c32f5a2b735044ea5126f1011eba5" translate="yes" xml:space="preserve">
          <source>Address is valid but contains a :: that only elides one zero group</source>
          <target state="translated">주소는 유효하지만 하나의 0 그룹 만 필요로하는 ::를 포함</target>
        </trans-unit>
        <trans-unit id="510622562d2c0218e53097ea6e32ac7b80cf235c" translate="yes" xml:space="preserve">
          <source>Address is valid but contains a quoted string</source>
          <target state="translated">주소는 유효하지만 인용 된 문자열을 포함합니다</target>
        </trans-unit>
        <trans-unit id="8c451ae2b8582f3467ec31948cc6b1b82ba98f9e" translate="yes" xml:space="preserve">
          <source>Address is valid but the Top Level Domain begins with a number</source>
          <target state="translated">주소는 유효하지만 최상위 도메인은 숫자로 시작합니다</target>
        </trans-unit>
        <trans-unit id="5ca2422e194aa478738b3920d49b1d72b4a04751" translate="yes" xml:space="preserve">
          <source>Address is valid for SMTP but has unusual elements</source>
          <target state="translated">주소는 SMTP에는 유효하지만 특이한 요소가 있습니다</target>
        </trans-unit>
        <trans-unit id="069a8b8d9763d9ed6d488c79b3db6100b19c762d" translate="yes" xml:space="preserve">
          <source>Address is valid within the message but cannot be used unmodified for the envelope</source>
          <target state="translated">메시지 내에서 주소가 유효하지만 봉투에 대해 수정되지 않은 상태로 사용할 수 없습니다</target>
        </trans-unit>
        <trans-unit id="265f5be727c33a8a13245b57c78d571329630167" translate="yes" xml:space="preserve">
          <source>AddressFamily &lt;strong id=&quot;family&quot;&gt;family&lt;/strong&gt;;</source>
          <target state="translated">주소 &lt;strong id=&quot;family&quot;&gt;가족&lt;/strong&gt; ;</target>
        </trans-unit>
        <trans-unit id="9da00639bb3965aa70738e6a575e509275598a8a" translate="yes" xml:space="preserve">
          <source>AddressInfo[] &lt;strong id=&quot;getAddressInfo&quot;&gt;getAddressInfo&lt;/strong&gt;(T...)(scope const(char)[] node, scope T options);</source>
          <target state="translated">AddressInfo [] &lt;strong id=&quot;getAddressInfo&quot;&gt;getAddressInfo&lt;/strong&gt; (T ...) (범위 const (char) [] 노드, 범위 T 옵션);</target>
        </trans-unit>
        <trans-unit id="dffa5b087a5bb8dd265fd7a6cbbd1e0d1d41f678" translate="yes" xml:space="preserve">
          <source>Adds &lt;code&gt;p[0 .. sz]&lt;/code&gt; to the list of memory ranges to be scanned for pointers during a collection. If p is null, no operation is performed.</source>
          <target state="translated">&lt;code&gt;p[0 .. sz]&lt;/code&gt; 를 수집 중에 포인터를 스캔 할 메모리 범위 목록에 추가합니다 . p가 널이면 조작이 수행되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="672314e29bcc5e362e383fbd999c4b5b4410b405" translate="yes" xml:space="preserve">
          <source>Adds a sign bit to allow for signed numbers.</source>
          <target state="translated">부호있는 숫자를 허용하기 위해 부호 비트를 추가합니다.</target>
        </trans-unit>
        <trans-unit id="ee9a206f63997b29125ee641371481b30dee8462" translate="yes" xml:space="preserve">
          <source>Adds a single Element of data without increasing &lt;code&gt;element_count&lt;/code&gt;. Make sure to increase &lt;code&gt;element_count&lt;/code&gt; by &lt;code&gt;Element.sizeof&lt;/code&gt; for each call to &lt;code&gt;putElement&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;element_count&lt;/code&gt; 를 늘리지 않고 단일 데이터 요소를 추가합니다 . 증가해야합니다 &lt;code&gt;element_count&lt;/code&gt; 을 하여 &lt;code&gt;Element.sizeof&lt;/code&gt; 각 호출에 대해 &lt;code&gt;putElement&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7bf698b9f6e73db894b28808fd5abdeb21c41a83" translate="yes" xml:space="preserve">
          <source>Adds an internal root pointing to the GC memory block referenced by p. As a result, the block referenced by p itself and any blocks accessible via it will be considered live until the root is removed again.</source>
          <target state="translated">p가 참조하는 GC 메모리 블록을 가리키는 내부 루트를 추가합니다. 결과적으로 p 자체가 참조하는 블록과이를 통해 액세스 가능한 블록은 루트가 다시 제거 될 때까지 활성 상태로 간주됩니다.</target>
        </trans-unit>
        <trans-unit id="ff12c7ce51172ee3fa78ed53b57f7c8617e36d66" translate="yes" xml:space="preserve">
          <source>Adds assignable elements to BidirectionalRange.</source>
          <target state="translated">BidirectionalRange에 할당 가능한 요소를 추가합니다.</target>
        </trans-unit>
        <trans-unit id="af63794bdee98164b7dedba21a8ddcd815487b81" translate="yes" xml:space="preserve">
          <source>Adds assignable elements to ForwardRange.</source>
          <target state="translated">할당 가능한 요소를 ForwardRange에 추가합니다.</target>
        </trans-unit>
        <trans-unit id="d86b2ad49209ff010a91b4e8020be86eef38434b" translate="yes" xml:space="preserve">
          <source>Adds assignable elements to InputRange.</source>
          <target state="translated">할당 가능한 요소를 InputRange에 추가합니다.</target>
        </trans-unit>
        <trans-unit id="2111dba4f281687d624b61c6aeeecb551c0b910b" translate="yes" xml:space="preserve">
          <source>Adds assignable elements to RandomAccessFinite.</source>
          <target state="translated">RandomAccessFinite에 할당 가능한 요소를 추가합니다.</target>
        </trans-unit>
        <trans-unit id="cea0f0bf07e47c7fb0a04a4c50f0f8d4341a2b7e" translate="yes" xml:space="preserve">
          <source>Adds data to the digester. This function can be called many times in a row after start but before finish.</source>
          <target state="translated">다이제스트에 데이터를 추가합니다. 이 기능은 시작 후 또는 완료 전에 행에서 여러 번 호출 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f9a3cbb838535843105d2dbd716177d37c6dc90e" translate="yes" xml:space="preserve">
          <source>Adds or subtracts two &lt;code&gt;TickDuration&lt;/code&gt;s as well as assigning the result to this &lt;code&gt;TickDuration&lt;/code&gt;.</source>
          <target state="translated">이 &lt;code&gt;TickDuration&lt;/code&gt; 에 결과를 할당 할뿐만 아니라 두 &lt;code&gt;TickDuration&lt;/code&gt; 을 더하거나 뺍니다 .</target>
        </trans-unit>
        <trans-unit id="0c16f4ce03396768dfa95982d340781a78324241" translate="yes" xml:space="preserve">
          <source>Adds or subtracts two &lt;code&gt;TickDuration&lt;/code&gt;s.</source>
          <target state="translated">두 개의 &lt;code&gt;TickDuration&lt;/code&gt; 을 더하거나 뺍니다 .</target>
        </trans-unit>
        <trans-unit id="c737e93d31255b859d9ebe8158a9fb5eee5ea8ae" translate="yes" xml:space="preserve">
          <source>Adds or subtracts two durations.</source>
          <target state="translated">두 기간을 더하거나 뺍니다.</target>
        </trans-unit>
        <trans-unit id="e87760afd0099199ebc5a0eb76c281d30e85cec5" translate="yes" xml:space="preserve">
          <source>Adds the given number of units to this &lt;a href=&quot;#Date&quot;&gt;&lt;code&gt;Date&lt;/code&gt;&lt;/a&gt;, mutating it. A negative number will subtract.</source>
          <target state="translated">이 &lt;a href=&quot;#Date&quot;&gt; &lt;code&gt;Date&lt;/code&gt; 에&lt;/a&gt; 지정된 수의 단위를 추가하여 변경합니다. 음수는 뺍니다.</target>
        </trans-unit>
        <trans-unit id="0f80ac2d800f8ee490ca058f4b673564daf01236" translate="yes" xml:space="preserve">
          <source>Adds the given number of units to this &lt;a href=&quot;#DateTime&quot;&gt;&lt;code&gt;DateTime&lt;/code&gt;&lt;/a&gt;, mutating it. A negative number will subtract.</source>
          <target state="translated">이 &lt;a href=&quot;#DateTime&quot;&gt; &lt;code&gt;DateTime&lt;/code&gt; 에&lt;/a&gt; 지정된 수의 단위를 추가하여 변경합니다. 음수는 뺍니다.</target>
        </trans-unit>
        <trans-unit id="00a26d0cef5a8a591d36a0308e58ee4701a2e0f7" translate="yes" xml:space="preserve">
          <source>Adds the given number of units to this &lt;a href=&quot;#SysTime&quot;&gt;&lt;code&gt;SysTime&lt;/code&gt;&lt;/a&gt;. A negative number will subtract.</source>
          <target state="translated">이 &lt;a href=&quot;#SysTime&quot;&gt; &lt;code&gt;SysTime&lt;/code&gt; 에&lt;/a&gt; 지정된 수의 단위를 추가합니다 . 음수는 뺍니다.</target>
        </trans-unit>
        <trans-unit id="25d7fd9970d15ef947135e621f6d15c4231ff9c0" translate="yes" xml:space="preserve">
          <source>Adds the given number of units to this &lt;a href=&quot;#TimeOfDay&quot;&gt;&lt;code&gt;TimeOfDay&lt;/code&gt;&lt;/a&gt;, mutating it. A negative number will subtract.</source>
          <target state="translated">이 &lt;a href=&quot;#TimeOfDay&quot;&gt; &lt;code&gt;TimeOfDay&lt;/code&gt; 에&lt;/a&gt; 지정된 단위 수를 더해 그것을 변경합니다. 음수는 뺍니다.</target>
        </trans-unit>
        <trans-unit id="abb4bf42c71674b6c0e872462683cd4dd3560370" translate="yes" xml:space="preserve">
          <source>Adds the given number of years or months to this &lt;a href=&quot;#Date&quot;&gt;&lt;code&gt;Date&lt;/code&gt;&lt;/a&gt;, mutating it. A negative number will subtract.</source>
          <target state="translated">이 &lt;a href=&quot;#Date&quot;&gt; &lt;code&gt;Date&lt;/code&gt; 에&lt;/a&gt; 지정된 연도 또는 월 수를 추가하여 변경합니다. 음수는 뺍니다.</target>
        </trans-unit>
        <trans-unit id="17c8fc904e2c9da1e769c06f6205227d30331e48" translate="yes" xml:space="preserve">
          <source>Adds the given number of years or months to this &lt;a href=&quot;#DateTime&quot;&gt;&lt;code&gt;DateTime&lt;/code&gt;&lt;/a&gt;, mutating it. A negative number will subtract.</source>
          <target state="translated">이 &lt;a href=&quot;#DateTime&quot;&gt; &lt;code&gt;DateTime&lt;/code&gt; 에&lt;/a&gt; 지정된 연도 또는 월 수를 추가하여 변경합니다. 음수는 뺍니다.</target>
        </trans-unit>
        <trans-unit id="cb5ca95f30def8b12993088b8d76ab1dd37d553c" translate="yes" xml:space="preserve">
          <source>Adds the given number of years or months to this &lt;a href=&quot;#SysTime&quot;&gt;&lt;code&gt;SysTime&lt;/code&gt;&lt;/a&gt;. A negative number will subtract.</source>
          <target state="translated">이 &lt;a href=&quot;#SysTime&quot;&gt; &lt;code&gt;SysTime&lt;/code&gt; 에&lt;/a&gt; 지정된 년 또는 월수를 추가합니다 . 음수는 뺍니다.</target>
        </trans-unit>
        <trans-unit id="ae45ff9fb528c8b811a4a8b39bb46f4d2af30e79" translate="yes" xml:space="preserve">
          <source>Adds, subtracts or calculates the modulo of two durations as well as assigning the result to this &lt;code&gt;Duration&lt;/code&gt;.</source>
          <target state="translated">두 기간의 모듈로를 더하거나 빼거나 계산하고 결과를이 &lt;code&gt;Duration&lt;/code&gt; 에 할당합니다 .</target>
        </trans-unit>
        <trans-unit id="7217c4f38fb4c88be899accd3f3c8388ee115acb" translate="yes" xml:space="preserve">
          <source>Adds, subtracts or calculates the modulo of two durations.</source>
          <target state="translated">두 기간의 모듈로를 더하거나 빼거나 계산합니다.</target>
        </trans-unit>
        <trans-unit id="190513d30ca7a3e2a999758bba5d14849013dae0" translate="yes" xml:space="preserve">
          <source>Adheres to &lt;a href=&quot;http://www.unicode.org/versions/Unicode7.0.0/ch05.pdf&quot;&gt;Unicode 7.0&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;http://www.unicode.org/versions/Unicode7.0.0/ch05.pdf&quot;&gt;유니 코드 7.0을&lt;/a&gt; 준수합니다 .</target>
        </trans-unit>
        <trans-unit id="8e6c5c313ae1124d50c20408776fe80d4c2f9549" translate="yes" xml:space="preserve">
          <source>Adjacent separators.</source>
          <target state="translated">인접한 분리기.</target>
        </trans-unit>
        <trans-unit id="722ed5201dde06aad85b7457e551331fed6fc5eb" translate="yes" xml:space="preserve">
          <source>Adjusts &lt;code&gt;n&lt;/code&gt; to a size suitable for allocation (two words or larger, word-aligned).</source>
          <target state="translated">&lt;code&gt;n&lt;/code&gt; 을 할당에 적합한 크기로 조정합니다 (두 단어 이상, 단어 정렬).</target>
        </trans-unit>
        <trans-unit id="25ad3e5c0dbbba69ec8c4772c55f2582037c6136" translate="yes" xml:space="preserve">
          <source>Advance the range to the next chunk of encoded data.</source>
          <target state="translated">인코딩 된 데이터의 다음 청크로 범위를 확장합니다.</target>
        </trans-unit>
        <trans-unit id="53489cea9eb74ca25d0c733e6598d5384d852067" translate="yes" xml:space="preserve">
          <source>Advance to the next decoded byte.</source>
          <target state="translated">다음에 디코딩 된 바이트로 진행합니다.</target>
        </trans-unit>
        <trans-unit id="3a3cd74a73d6f0a26c42392d915705fa7dae1cf8" translate="yes" xml:space="preserve">
          <source>Advance to the next element in the input to be decoded.</source>
          <target state="translated">디코딩 할 입력의 다음 요소로 진행합니다.</target>
        </trans-unit>
        <trans-unit id="6d3634150cc1196e50397ef062eee34b37152811" translate="yes" xml:space="preserve">
          <source>Advance to the next encoded character.</source>
          <target state="translated">다음 인코딩 된 문자로 진행합니다.</target>
        </trans-unit>
        <trans-unit id="b1dffc8e495ab0f0b08bad1e3f10f588c91ee072" translate="yes" xml:space="preserve">
          <source>Advanced feature - provide direct access to a subset of matcher based a set of known encoding lengths. Lengths are provided in &lt;a href=&quot;#Code%20unit&quot;&gt;code units&lt;/a&gt;. The sub-matcher then may do less operations per any &lt;code&gt;test&lt;/code&gt;/&lt;code&gt;match&lt;/code&gt;.</source>
          <target state="translated">고급 기능-일련의 알려진 인코딩 길이를 기반으로하는 정규 검색 엔진의 하위 집합에 직접 액세스 할 수 있습니다. 길이는 &lt;a href=&quot;#Code%20unit&quot;&gt;코드 단위&lt;/a&gt; 로 제공됩니다 . 하위 매칭 기는 &lt;code&gt;test&lt;/code&gt; / &lt;code&gt;match&lt;/code&gt; 마다 더 적은 연산을 수행 할 수있다 .</target>
        </trans-unit>
        <trans-unit id="eeb58f4b086c0412e02e6890890553e6dd38d672" translate="yes" xml:space="preserve">
          <source>Advanced updating</source>
          <target state="translated">고급 업데이트</target>
        </trans-unit>
        <trans-unit id="cf881b5c6e7f1c3b9a2c00554a2646c41d876526" translate="yes" xml:space="preserve">
          <source>Advances &lt;code&gt;r&lt;/code&gt; until it finds the first two adjacent elements &lt;code&gt;a&lt;/code&gt;, &lt;code&gt;b&lt;/code&gt; that satisfy &lt;code&gt;pred(a, b)&lt;/code&gt;. Performs &amp;Omicron;(&lt;code&gt;r.length&lt;/code&gt;) evaluations of &lt;code&gt;pred&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;pred(a, b)&lt;/code&gt; 를 만족 &lt;code&gt;a&lt;/code&gt; 처음 두 개의 인접한 요소 a , &lt;code&gt;b&lt;/code&gt; 를 찾을 때까지 &lt;code&gt;r&lt;/code&gt; 을 진행 시킵니다 . &lt;code&gt;pred&lt;/code&gt; 의 &amp;Omicron; ( &lt;code&gt;r.length&lt;/code&gt; ) 평가를 수행합니다 .</target>
        </trans-unit>
        <trans-unit id="facf585ea759be8e47863eaecb960e98185ac802" translate="yes" xml:space="preserve">
          <source>Advances &lt;code&gt;seq&lt;/code&gt; by calling &lt;code&gt;seq.popFront&lt;/code&gt; until either &lt;code&gt;find!(pred)(choices, seq.front)&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;, or &lt;code&gt;seq&lt;/code&gt; becomes empty. Performs &amp;Omicron;(&lt;code&gt;seq.length * choices.length&lt;/code&gt;) evaluations of &lt;code&gt;pred&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;find!(pred)(choices, seq.front)&lt;/code&gt; 가 &lt;code&gt;true&lt;/code&gt; 이거나 &lt;code&gt;seq&lt;/code&gt; 가 비어 &lt;code&gt;seq.popFront&lt;/code&gt; 때까지 seq.popFront 를 호출하여 &lt;code&gt;seq&lt;/code&gt; 를 진행 시킵니다 . &lt;code&gt;pred&lt;/code&gt; 의 &amp;Omicron; ( &lt;code&gt;seq.length * choices.length&lt;/code&gt; ) 평가를 수행 합니다.</target>
        </trans-unit>
        <trans-unit id="8f69d337edd3755f38c1707e24fc5346d4e2d44c" translate="yes" xml:space="preserve">
          <source>Advances a given bidirectional range from the right by exactly</source>
          <target state="translated">오른쪽에서 주어진 양방향 범위를 정확하게 향상시킵니다.</target>
        </trans-unit>
        <trans-unit id="19d2eb30ee8dd8c5d7afbff2f9bd7ea8bb2642e3" translate="yes" xml:space="preserve">
          <source>Advances a given bidirectional range from the right by up to</source>
          <target state="translated">오른쪽에서 최대까지 주어진 양방향 범위를 향상시킵니다.</target>
        </trans-unit>
        <trans-unit id="a1e75744b3b444139cd4f0a58b334b9edf66d830" translate="yes" xml:space="preserve">
          <source>Advances a given range by up exactly</source>
          <target state="translated">주어진 범위를 정확하게 올립니다</target>
        </trans-unit>
        <trans-unit id="1a622ec23b3321ab3e350f048523f7084cf595eb" translate="yes" xml:space="preserve">
          <source>Advances a given range by up to</source>
          <target state="translated">주어진 범위까지 최대</target>
        </trans-unit>
        <trans-unit id="78bc54605619ccfaa022076c05ce4d0d5ecf8d2e" translate="yes" xml:space="preserve">
          <source>Advances the generator.</source>
          <target state="translated">발전기를 전진시킵니다.</target>
        </trans-unit>
        <trans-unit id="e7c9ed0ebcf630bc583e7903a2b6d29b7aca3fc7" translate="yes" xml:space="preserve">
          <source>Advances the random sequence.</source>
          <target state="translated">임의 순서를 진행시킵니다.</target>
        </trans-unit>
        <trans-unit id="841e5d06644019901743e66d69de7d1976b71c5b" translate="yes" xml:space="preserve">
          <source>Advances to the next element in all controlled ranges.</source>
          <target state="translated">모든 제어 범위에서 다음 요소로 넘어갑니다.</target>
        </trans-unit>
        <trans-unit id="cbe9dcb57596ffec1913e83a16abf147d32611b9" translate="yes" xml:space="preserve">
          <source>Aegean Numbers</source>
          <target state="translated">해수</target>
        </trans-unit>
        <trans-unit id="931eed4d96571bfeae93ef9dcf8c3202ff20b1ad" translate="yes" xml:space="preserve">
          <source>Affects whether functions are inlined or not. If at the declaration level, it affects the functions declared in the block it controls. If inside a function, it affects the function it is enclosed by.</source>
          <target state="translated">함수가 인라인되는지 여부에 영향을줍니다. 선언 레벨에있는 경우 제어하는 ​​블록에 선언 된 기능에 영향을줍니다. 함수 내부에 있으면 함수로 묶인 함수에 영향을줍니다.</target>
        </trans-unit>
        <trans-unit id="442683da146742a25947515455e712ba78a50694" translate="yes" xml:space="preserve">
          <source>Affix access functions offering references to the affixes of a block &lt;code&gt;b&lt;/code&gt; previously allocated with this allocator. &lt;code&gt;b&lt;/code&gt; may not be null. They are defined if and only if the corresponding affix is not &lt;code&gt;void&lt;/code&gt;.</source>
          <target state="translated">접두어 액세스 기능 은이 할당기로 이전에 할당 된 블록 &lt;code&gt;b&lt;/code&gt; 의 접두사에 대한 참조를 제공 합니다. &lt;code&gt;b&lt;/code&gt; 는 null이 아닐 수 있습니다. 해당 접두어가 &lt;code&gt;void&lt;/code&gt; 가 아닌 경우에만 정의됩니다 .</target>
        </trans-unit>
        <trans-unit id="c23381a58dcf83131fe33f75a01b801175e69bea" translate="yes" xml:space="preserve">
          <source>After &lt;code&gt;typeSemantic&lt;/code&gt; the symbol when &lt;code&gt;exp&lt;/code&gt; doesn't represent a type.</source>
          <target state="translated">후 &lt;code&gt;typeSemantic&lt;/code&gt; 상징 때 &lt;code&gt;exp&lt;/code&gt; 유형을 나타내지 않습니다.</target>
        </trans-unit>
        <trans-unit id="f58f4b720491f08a3e184b4d93384253d667e81c" translate="yes" xml:space="preserve">
          <source>After a FTP client has been setup and possibly assigned callbacks the &lt;code&gt; perform()&lt;/code&gt; method will start performing the actual communication with the server.</source>
          <target state="translated">FTP 클라이언트가 설정되고 콜백이 할당되면 &lt;code&gt; perform()&lt;/code&gt; 메소드가 서버와 실제 통신을 수행하기 시작합니다.</target>
        </trans-unit>
        <trans-unit id="40877a01f3d2d2683d82a5ea2b798c56a293359c" translate="yes" xml:space="preserve">
          <source>After creation, a &lt;code&gt;Task&lt;/code&gt; may be executed in a new thread, or submitted to a &lt;code&gt;TaskPool&lt;/code&gt; for execution. A &lt;code&gt;TaskPool&lt;/code&gt; encapsulates a task queue and its worker threads. Its purpose is to efficiently map a large number of &lt;code&gt;Task&lt;/code&gt;s onto a smaller number of threads. A task queue is a FIFO queue of &lt;code&gt;Task&lt;/code&gt; objects that have been submitted to the &lt;code&gt;TaskPool&lt;/code&gt; and are awaiting execution. A worker thread is a thread that is associated with exactly one task queue. It executes the &lt;code&gt;Task&lt;/code&gt; at the front of its queue when the queue has work available, or sleeps when no work is available. Each task queue is associated with zero or more worker threads. If the result of a &lt;code&gt;Task&lt;/code&gt; is needed before execution by a worker thread has begun, the &lt;code&gt;Task&lt;/code&gt; can be removed from the task queue and executed immediately in the thread where the result is needed.</source>
          <target state="translated">생성 후 &lt;code&gt;Task&lt;/code&gt; 은 새 스레드에서 실행되거나 실행 을 위해 &lt;code&gt;TaskPool&lt;/code&gt; 에 제출 될 수 있습니다 . &lt;code&gt;TaskPool&lt;/code&gt; 을이 작업 큐와 작업자 스레드를 캡슐화합니다. 그 목적은 많은 수의 &lt;code&gt;Task&lt;/code&gt; 를 더 적은 수의 스레드 에 효율적으로 매핑하는 것 입니다. 작업 대기열은 &lt;code&gt;TaskPool&lt;/code&gt; 에 제출되어 실행을 기다리는 &lt;code&gt;Task&lt;/code&gt; 객체 의 FIFO 대기열입니다 . 작업자 스레드는 정확히 하나의 작업 큐와 연결된 스레드입니다. 대기열에 사용 가능한 작업이 있으면 대기열 앞쪽에서 &lt;code&gt;Task&lt;/code&gt; 을 실행 하거나 사용 가능한 작업이 없으면 휴면 상태입니다. 각 작업 대기열은 0 개 이상의 작업자 스레드와 연결됩니다. &lt;code&gt;Task&lt;/code&gt; 결과작업자 스레드에 의해 실행이 시작하기 전에 필요한의 &lt;code&gt;Task&lt;/code&gt; 작업 큐에서 제거되고 결과가 필요한 스레드에서 바로 실행할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="fac78fef792ce790d176c70684c125385e59b69f" translate="yes" xml:space="preserve">
          <source>After the HTTP client has been setup and possibly assigned callbacks the &lt;code&gt;perform()&lt;/code&gt; method will start performing the request towards the specified server.</source>
          <target state="translated">HTTP 클라이언트가 설정되고 콜백이 할당되면 &lt;code&gt;perform()&lt;/code&gt; 메소드가 지정된 서버에 대한 요청을 수행하기 시작합니다.</target>
        </trans-unit>
        <trans-unit id="3be61943c5e6beb762f765e4ebc8da159c5a9299" translate="yes" xml:space="preserve">
          <source>After this function is finished executing, any exceptions thrown are chained together via &lt;code&gt;Throwable.next&lt;/code&gt; and rethrown. The chaining order is non-deterministic.</source>
          <target state="translated">이 함수의 실행이 완료되면 Throw 된 예외는 &lt;code&gt;Throwable.next&lt;/code&gt; 를 통해 함께 연결되어 다시 발생합니다. 연결 순서는 비 결정적입니다.</target>
        </trans-unit>
        <trans-unit id="2423ca21e96dd2f33c30a0a22ba75c7e9a97460a" translate="yes" xml:space="preserve">
          <source>Aggregate Templates</source>
          <target state="translated">집계 템플릿</target>
        </trans-unit>
        <trans-unit id="422fc1d404645ddf0fe8822054c49c2df47da791" translate="yes" xml:space="preserve">
          <source>Aggregate Type traits</source>
          <target state="translated">집계 유형 특성</target>
        </trans-unit>
        <trans-unit id="5a49d2a80d7f18d6b1f678d37a80f429dee0945d" translate="yes" xml:space="preserve">
          <source>Aggregate literals (AA/string/array/struct)</source>
          <target state="translated">집계 리터럴 (AA / string / array / struct)</target>
        </trans-unit>
        <trans-unit id="0a01f2f266bf28f3c82d33549ab6734f725b8328" translate="yes" xml:space="preserve">
          <source>AggregateDeclaration &lt;code&gt;ad&lt;/code&gt;</source>
          <target state="translated">AggregateDeclaration &lt;code&gt;ad&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="65711c59e3f2ecd6ab45c5a271a40aff4bf044a7" translate="yes" xml:space="preserve">
          <source>AggregateDeclaration &lt;strong id=&quot;isAggregate&quot;&gt;isAggregate&lt;/strong&gt;(Type t);</source>
          <target state="translated">AggregateDeclaration &lt;strong id=&quot;isAggregate&quot;&gt;isAggregate&lt;/strong&gt; (유형 t);</target>
        </trans-unit>
        <trans-unit id="b026ca73b3ee9e08b16268eb5969c7649a6ada2c" translate="yes" xml:space="preserve">
          <source>AggregateDeclaration &lt;strong id=&quot;isInlinableNestedAggregate&quot;&gt;isInlinableNestedAggregate&lt;/strong&gt;(DeclarationExp e);</source>
          <target state="translated">집계 선언 &lt;strong id=&quot;isInlinableNestedAggregate&quot;&gt;isInlinableNestedAggregate&lt;/strong&gt; (DeclarationExp e);</target>
        </trans-unit>
        <trans-unit id="deb507c2bab5b6df1dfb7a527622531bee5bbcae" translate="yes" xml:space="preserve">
          <source>Aggregates</source>
          <target state="translated">Aggregates</target>
        </trans-unit>
        <trans-unit id="039a4d9ad09b94c49e1256fa36bbd7145bd6a873" translate="yes" xml:space="preserve">
          <source>Aggregates can be string literals, which can be accessed as char, wchar, or dchar arrays:</source>
          <target state="translated">집계는 문자열 리터럴 일 수 있으며 char, wchar 또는 dchar 배열로 액세스 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="64215ea928af9a868c37adc98435f865c066cad0" translate="yes" xml:space="preserve">
          <source>Aggregation of GC stats to be exposed via public API</source>
          <target state="translated">공개 API를 통해 노출 될 GC 통계 집계</target>
        </trans-unit>
        <trans-unit id="95739c27a4231a1ab1768db7918200a659985986" translate="yes" xml:space="preserve">
          <source>Aggregation of current profile information</source>
          <target state="translated">현재 프로파일 정보의 집계</target>
        </trans-unit>
        <trans-unit id="960ed8592125f2bc50d2c8d3a223103bb8eab0ce" translate="yes" xml:space="preserve">
          <source>Alchemical Symbols</source>
          <target state="translated">연금술 기호</target>
        </trans-unit>
        <trans-unit id="d5ba6c3d74529cf2db06f24108dd96d14e3a3bf5" translate="yes" xml:space="preserve">
          <source>Algebraic data type restricted to a closed set of possible types. It's an alias for &lt;a href=&quot;#VariantN&quot;&gt;&lt;code&gt;VariantN&lt;/code&gt;&lt;/a&gt; with an appropriately-constructed maximum size. &lt;code&gt;Algebraic&lt;/code&gt; is useful when it is desirable to restrict what a discriminated type could hold to the end of defining simpler and more efficient manipulation.</source>
          <target state="translated">대수 데이터 유형은 가능한 유형의 닫힌 세트로 제한됩니다. 적절하게 구성된 최대 크기를 가진 &lt;a href=&quot;#VariantN&quot;&gt; &lt;code&gt;VariantN&lt;/code&gt; &lt;/a&gt; 의 별칭입니다 . &lt;code&gt;Algebraic&lt;/code&gt; 는 식별 된 유형이 더 단순하고 효율적인 조작을 정의 할 때까지 보유 할 수있는 것을 제한하는 것이 바람직 할 때 유용합니다.</target>
        </trans-unit>
        <trans-unit id="67e15eb99dc0e473c962d6a494d00e048e9f6fc6" translate="yes" xml:space="preserve">
          <source>Algorithms</source>
          <target state="translated">Algorithms</target>
        </trans-unit>
        <trans-unit id="c6f1119d49c8f3cbd3127d86d596eb5ad76abaa0" translate="yes" xml:space="preserve">
          <source>Algorithms are categorized into the following submodules:</source>
          <target state="translated">알고리즘은 다음과 같은 하위 모듈로 분류됩니다.</target>
        </trans-unit>
        <trans-unit id="9d031d2cc1773d432e8d4e5e3e397ff72d33b73a" translate="yes" xml:space="preserve">
          <source>Algorithms should be written to work based on the minimum precision of the calculation. They should not degrade or fail if the actual precision is greater. Float or double types, as opposed to the real (extended) type, should only be used for:</source>
          <target state="translated">계산의 최소 정밀도를 기반으로 작동하도록 알고리즘을 작성해야합니다. 실제 정밀도가 더 크면 성능이 저하되거나 실패하지 않아야합니다. 실수 (확장) 유형과 달리 부동 또는 이중 유형은 다음에 만 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="6b7d7cc33ac422a7126bf7ca7d4bc41f992588c9" translate="yes" xml:space="preserve">
          <source>Algorithms that work specifically with strings.</source>
          <target state="translated">문자열과 함께 특별히 작동하는 알고리즘.</target>
        </trans-unit>
        <trans-unit id="88abf47d65eee8406cedefebf1444bde5b352ec5" translate="yes" xml:space="preserve">
          <source>Ali &amp;Ccedil;ehreli's &lt;a href=&quot;http://ddili.org/ders/d.en/ranges.html&quot;&gt;tutorial on ranges&lt;/a&gt; for the basics of working with and creating range-based code.</source>
          <target state="translated">범위 기반 코드 작업 및 작성의 기본에 대한 &lt;a href=&quot;http://ddili.org/ders/d.en/ranges.html&quot;&gt;범위에&lt;/a&gt; 대한 Ali &amp;Ccedil;ehreli의 학습서 .</target>
        </trans-unit>
        <trans-unit id="04259816ace1ebe56c853a8763558570c008514a" translate="yes" xml:space="preserve">
          <source>Alias</source>
          <target state="translated">Alias</target>
        </trans-unit>
        <trans-unit id="2b42e13ed23a87356a09e332c7e6e714e6e09e96" translate="yes" xml:space="preserve">
          <source>Alias Declarations</source>
          <target state="translated">별명 선언</target>
        </trans-unit>
        <trans-unit id="77ef2f52299fed56a50f678635e931b47d8d55bb" translate="yes" xml:space="preserve">
          <source>Alias Templates</source>
          <target state="translated">별칭 템플릿</target>
        </trans-unit>
        <trans-unit id="8e3462f022e547a8b9b81a59c7d09995c97a1575" translate="yes" xml:space="preserve">
          <source>Alias This</source>
          <target state="translated">별명</target>
        </trans-unit>
        <trans-unit id="a6823ce53aa787875a84b73b489aeaa41fb9203a" translate="yes" xml:space="preserve">
          <source>Alias declarations can be used to overload together functions declared in different mixins:</source>
          <target state="translated">별명 선언을 사용하여 다른 믹스 인에서 선언 된 함수를 함께 오버로드 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9f63972ec70f46c0515cbfc8d099ae2cc95be598" translate="yes" xml:space="preserve">
          <source>Alias for &lt;a href=&quot;#VariantN&quot;&gt;&lt;code&gt;VariantN&lt;/code&gt;&lt;/a&gt; instantiated with the largest size of &lt;code&gt;creal&lt;/code&gt;, &lt;code&gt;char[]&lt;/code&gt;, and &lt;code&gt;void delegate()&lt;/code&gt;. This ensures that &lt;code&gt;Variant&lt;/code&gt; is large enough to hold all of D's predefined types unboxed, including all numeric types, pointers, delegates, and class references. You may want to use &lt;code&gt;VariantN&lt;/code&gt; directly with a different maximum size either for storing larger types unboxed, or for saving memory.</source>
          <target state="translated">가장 큰 크기의 &lt;code&gt;creal&lt;/code&gt; , &lt;code&gt;char[]&lt;/code&gt; 및 &lt;code&gt;void delegate()&lt;/code&gt; 인스턴스화 된 &lt;a href=&quot;#VariantN&quot;&gt; &lt;code&gt;VariantN&lt;/code&gt; 의&lt;/a&gt; 별명 . 이렇게하면 &lt;code&gt;Variant&lt;/code&gt; 가 모든 숫자 유형, 포인터, 대리자 및 클래스 참조를 포함하여 D의 사전 정의 된 모든 유형을 상자에 넣을 수 없을만큼 충분히 커집니다. &lt;code&gt;VariantN&lt;/code&gt; 가없는 큰 타입을 저장하거나 메모리를 절약하기 위해 다른 최대 크기로 VariantN을 직접 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="63202ec3a67d85508053325231c6e3a50b705940" translate="yes" xml:space="preserve">
          <source>Alias for &lt;code&gt;typeof(Factory()(1))&lt;/code&gt;, i.e. the type of the individual allocators.</source>
          <target state="translated">&lt;code&gt;typeof(Factory()(1))&lt;/code&gt; 별명 , 즉 개별 할당 자의 유형.</target>
        </trans-unit>
        <trans-unit id="105407ad1c7568b9c649c50759d11c4e192f57b4" translate="yes" xml:space="preserve">
          <source>Alias parameters can accept both literals and user-defined type symbols, but they are less specialized than the matches to type parameters and value parameters:</source>
          <target state="translated">별칭 매개 변수는 리터럴과 사용자 정의 형식 기호를 모두 사용할 수 있지만 형식 매개 변수 및 값 매개 변수와 일치하는 것보다 덜 전문적입니다.</target>
        </trans-unit>
        <trans-unit id="d22b74da1f9d782bb61c364a8aadbff84bd13777" translate="yes" xml:space="preserve">
          <source>Alias parameters can also be typed. These parameters will accept symbols of that type:</source>
          <target state="translated">별명 매개 변수도 입력 할 수 있습니다. 이 매개 변수는 해당 유형의 기호를 허용합니다.</target>
        </trans-unit>
        <trans-unit id="b917c61ec37f1f84ac7cb387db33687a0c61b1b1" translate="yes" xml:space="preserve">
          <source>Alias parameters enable templates to be parameterized with symbol names or values computed at compile-time. Almost any kind of D symbol can be used, including user-defined type names, global names, local names, module names, template names, and template instance names.</source>
          <target state="translated">별명 매개 변수를 사용하면 컴파일시 계산 된 기호 이름 또는 값으로 템플리트를 매개 변수화 할 수 있습니다. 사용자 정의 유형 이름, 전역 이름, 로컬 이름, 모듈 이름, 템플릿 이름 및 템플릿 인스턴스 이름을 포함하여 거의 모든 종류의 D 기호를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8515de354ea5c9130e0c481ca51f1addb44b5d02" translate="yes" xml:space="preserve">
          <source>Alias sequence filtering</source>
          <target state="translated">별명 시퀀스 필터링</target>
        </trans-unit>
        <trans-unit id="cdba1b60c0b760cd04f385300eb523eb54b00054" translate="yes" xml:space="preserve">
          <source>Alias sequence searching</source>
          <target state="translated">별칭 시퀀스 검색</target>
        </trans-unit>
        <trans-unit id="1590720ca74c606d4c9f961020006e51239fec30" translate="yes" xml:space="preserve">
          <source>Alias sequence transformation</source>
          <target state="translated">별칭 시퀀스 변환</target>
        </trans-unit>
        <trans-unit id="5c56d0ae76a47ae72fa8c318d1bfb56034cb27c4" translate="yes" xml:space="preserve">
          <source>Alias sequence type hierarchy</source>
          <target state="translated">별명 시퀀스 유형 계층</target>
        </trans-unit>
        <trans-unit id="2ba4b28154b9d6a34808cdcb201b98d061c254fa" translate="yes" xml:space="preserve">
          <source>Alias your own enforce function</source>
          <target state="translated">자신의 강제 기능 별칭</target>
        </trans-unit>
        <trans-unit id="3677863f140b997e20f4c765fa070bfcd26df047" translate="yes" xml:space="preserve">
          <source>AliasDeclaration</source>
          <target state="translated">AliasDeclaration</target>
        </trans-unit>
        <trans-unit id="07e1c1a8b4a8503f8648ab57227770c6e32ac2e8" translate="yes" xml:space="preserve">
          <source>AliasSeq</source>
          <target state="translated">AliasSeq</target>
        </trans-unit>
        <trans-unit id="a75c4e940b98b3f296d4a0d45ef3c78158d01f9b" translate="yes" xml:space="preserve">
          <source>AliasThis</source>
          <target state="translated">AliasThis</target>
        </trans-unit>
        <trans-unit id="f45e3de29f946da184942d83246da3931f3381ce" translate="yes" xml:space="preserve">
          <source>AliasThis &lt;code&gt;at&lt;/code&gt;</source>
          <target state="translated">AliasThis &lt;code&gt;at&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="3a6b07ef377e1a1cca3873fdac3f4b419d63ed5c" translate="yes" xml:space="preserve">
          <source>Aliased symbols are useful as a shorthand for a long qualified symbol name, or as a way to redirect references from one symbol to another:</source>
          <target state="translated">앨리어싱 된 심볼은 긴 정규화 된 심볼 이름의 속기 또는 한 심볼에서 다른 심볼로 참조를 리디렉션하는 방법으로 유용합니다.</target>
        </trans-unit>
        <trans-unit id="7f8884a25f8de2f7a75d30d9ae86bb0f1f09187b" translate="yes" xml:space="preserve">
          <source>Aliased types are semantically identical to the types they are aliased to. The debugger cannot distinguish between them, and there is no difference as far as function overloading is concerned. For example:</source>
          <target state="translated">별칭 형식은 별칭이 지정된 형식과 의미 적으로 동일합니다. 디버거는 이들을 구별 할 수 없으며 함수 오버로딩에 관한 한 차이가 없습니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="181e7f0a478bed4e18de65212b24a50ae36262a7" translate="yes" xml:space="preserve">
          <source>Aliases can also &lt;code&gt;import&lt;/code&gt; a set of overloaded functions, that can be overloaded with functions in the current scope:</source>
          <target state="translated">별칭은 현재 범위의 함수로 오버로드 될 수있는 오버로드 된 함수 집합을 &lt;code&gt;import&lt;/code&gt; 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="daf33e541d4cc1a3ec6daef4974e2cc623107069" translate="yes" xml:space="preserve">
          <source>Aliases cannot be used for expressions:</source>
          <target state="translated">별명은 표현식에 사용할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="ebc45702486814ba8ea503fc9c806c260e1435cb" translate="yes" xml:space="preserve">
          <source>Aliases itself to &lt;code&gt;T[0]&lt;/code&gt; if the boolean &lt;code&gt;condition&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt; and to &lt;code&gt;T[1]&lt;/code&gt; otherwise.</source>
          <target state="translated">자체 별칭 &lt;code&gt;T[0]&lt;/code&gt; 부울 경우 &lt;code&gt;condition&lt;/code&gt; 이다 &lt;code&gt;true&lt;/code&gt; 하고 &lt;code&gt;T[1]&lt;/code&gt; 그렇지.</target>
        </trans-unit>
        <trans-unit id="e3937b5ce30f890ad3772d735fbf89d86613c889" translate="yes" xml:space="preserve">
          <source>Aliases the operating-system-specific semaphore type.</source>
          <target state="translated">운영 체제 별 세마포어 유형을 별명으로 지정합니다.</target>
        </trans-unit>
        <trans-unit id="ca83555e7a077f50fe3fcacdc4d3433397f6d741" translate="yes" xml:space="preserve">
          <source>Aliasing can be used to &lt;code&gt;import&lt;/code&gt; a symbol from an import into the current scope:</source>
          <target state="translated">별칭을 사용하면 &lt;code&gt;import&lt;/code&gt; 에서 현재 범위로 심볼 을 가져올 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="3880da17e1bb86f5003addaa85926c1d8378f606" translate="yes" xml:space="preserve">
          <source>AlignAttribute</source>
          <target state="translated">AlignAttribute</target>
        </trans-unit>
        <trans-unit id="c33b72e35015aa610f1d135fb91888616c7312da" translate="yes" xml:space="preserve">
          <source>Aligned allocator using OS-specific primitives, under a uniform API.</source>
          <target state="translated">균일 한 API에서 OS 특정 프리미티브를 사용하여 할당 된 할당 자.</target>
        </trans-unit>
        <trans-unit id="33c63fc9fbd39c59d281cefd5cb568321a27de38" translate="yes" xml:space="preserve">
          <source>Aligning the start of a loop body can sometimes have a dramatic effect on the execution speed.</source>
          <target state="translated">루프 바디의 시작을 정렬하면 실행 속도에 큰 영향을 줄 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7f8c5176c3f03b97659161923f2b6492f7de7e73" translate="yes" xml:space="preserve">
          <source>Alignment</source>
          <target state="translated">Alignment</target>
        </trans-unit>
        <trans-unit id="631fafc1c69d316d9d50c570d786f73ce03ceecb" translate="yes" xml:space="preserve">
          <source>Alignment is identical to that of the parent.</source>
          <target state="translated">정렬은 부모의 정렬과 동일합니다.</target>
        </trans-unit>
        <trans-unit id="628683da3626c98088bdb745580ccfdd6195c8e9" translate="yes" xml:space="preserve">
          <source>Alignment is page-size and hardcoded to 4096 (even though on certain systems it could be larger).</source>
          <target state="translated">정렬은 페이지 크기이며 4096으로 하드 코딩됩니다 (특정 시스템에서는 더 클 수 있음).</target>
        </trans-unit>
        <trans-unit id="ee7a5f296fba571ed109f22fb62cee377810a13b" translate="yes" xml:space="preserve">
          <source>Alignment offered</source>
          <target state="translated">정렬 제공</target>
        </trans-unit>
        <trans-unit id="da6f06da696bc1f912e995a3736dfda61d958504" translate="yes" xml:space="preserve">
          <source>Alignment offered is equal to &lt;code&gt;Allocator.alignment&lt;/code&gt;.</source>
          <target state="translated">제공되는 정렬은 &lt;code&gt;Allocator.alignment&lt;/code&gt; 와 같습니다 .</target>
        </trans-unit>
        <trans-unit id="d9fda3b8d79c5ba0e4cb6a973462e579762d4731" translate="yes" xml:space="preserve">
          <source>Alignment offered.</source>
          <target state="translated">정렬이 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="6a72085653e4c5be8c7640c868ef787cbcf063d1" translate="yes" xml:space="preserve">
          <source>All</source>
          <target state="translated">All</target>
        </trans-unit>
        <trans-unit id="abe24b72722605e6cdd91fc4259456dcc124fc52" translate="yes" xml:space="preserve">
          <source>All &lt;code&gt;struct&lt;/code&gt; declarations are an instance of this.</source>
          <target state="translated">모든 &lt;code&gt;struct&lt;/code&gt; 선언은 이것의 인스턴스입니다.</target>
        </trans-unit>
        <trans-unit id="a15215d4acb70177c3fa907103d5e4082e2c6ca5" translate="yes" xml:space="preserve">
          <source>All D class objects inherit from Object.</source>
          <target state="translated">모든 D 클래스 객체는 Object에서 상속됩니다.</target>
        </trans-unit>
        <trans-unit id="4b8af670ebee67e47b1547dfb583c8778c294941" translate="yes" xml:space="preserve">
          <source>All Linux Systems, except for Android</source>
          <target state="translated">Android를 제외한 모든 Linux 시스템</target>
        </trans-unit>
        <trans-unit id="80accc5a7a3759a25495613b953505c2d3f752d2" translate="yes" xml:space="preserve">
          <source>All Linux systems</source>
          <target state="translated">모든 Linux 시스템</target>
        </trans-unit>
        <trans-unit id="4d974fefbe10142c06ce86c531753f630c736767" translate="yes" xml:space="preserve">
          <source>All Objective-C classes that should be accessible from within D need to be declared with the &lt;a href=&quot;#objc-linkage&quot;&gt;Objective-C linkage&lt;/a&gt;. If the class is declared as &lt;code&gt;extern&lt;/code&gt; (in addition to &lt;code&gt;extern (Objective-C)&lt;/code&gt;) it is expected to be defined externally.</source>
          <target state="translated">D 내에서 액세스 할 수있는 모든 Objective-C 클래스는 &lt;a href=&quot;#objc-linkage&quot;&gt;Objective-C 연결&lt;/a&gt; 로 선언해야합니다 . 클래스가 &lt;code&gt;extern&lt;/code&gt; 으로 선언 된 경우 ( &lt;code&gt;extern (Objective-C)&lt;/code&gt; 외에 ) 외부 적으로 정의 될 것으로 예상됩니다.</target>
        </trans-unit>
        <trans-unit id="1cad9880f94b0d69e64ab7ba48ed53970ed3c806" translate="yes" xml:space="preserve">
          <source>All POSIX systems (includes Linux, FreeBSD, OS X, Solaris, etc.)</source>
          <target state="translated">모든 POSIX 시스템 (Linux, FreeBSD, OS X, Solaris 등 포함)</target>
        </trans-unit>
        <trans-unit id="573bedde18f09596640b473ee57afdc92f81ce77" translate="yes" xml:space="preserve">
          <source>All algorithms are generalized to accept as input not only sets but also &lt;a href=&quot;http://https//en.wikipedia.org/wiki/Multiset&quot;&gt;multisets&lt;/a&gt;. Each algorithm documents behaviour in the presence of duplicated inputs.</source>
          <target state="translated">모든 알고리즘은 세트뿐만 아니라 &lt;a href=&quot;http://https//en.wikipedia.org/wiki/Multiset&quot;&gt;다중&lt;/a&gt; 세트를 입력으로 받아들이도록 일반화됩니다 . 각 알고리즘은 중복 된 입력이있을 때 동작을 문서화합니다.</target>
        </trans-unit>
        <trans-unit id="deb71250ab180a43538a473f83e6182c437126a3" translate="yes" xml:space="preserve">
          <source>All allocators in this module accept and return &lt;code&gt;void[]&lt;/code&gt; (as opposed to &lt;code&gt;shared void[]&lt;/code&gt;). This is because at the time of allocation, deallocation, or reallocation, the memory is effectively not &lt;code&gt;shared&lt;/code&gt; (if it were, it would reveal a bug at the application level).</source>
          <target state="translated">이 모듈의 모든 할당자는 &lt;code&gt;void[]&lt;/code&gt; 를 &lt;code&gt;shared void[]&lt;/code&gt; 하고 반환 합니다 ( 공유 void [] 와 반대 ). 할당, 할당 해제 또는 재 할당시 메모리가 효과적으로 &lt;code&gt;shared&lt;/code&gt; 되지 않기 때문입니다 (있는 경우 응용 프로그램 수준에서 버그가 드러남).</target>
        </trans-unit>
        <trans-unit id="5de9c469f53cd882bbe9f78f7b9c7bd22b28c0ee" translate="yes" xml:space="preserve">
          <source>All arithmetic operations are supported, except unsigned shift right (&lt;code&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/code&gt;). Bitwise operations (&lt;code&gt;|&lt;/code&gt;, &lt;code&gt;&amp;amp;&lt;/code&gt;, &lt;code&gt;^&lt;/code&gt;, &lt;code&gt;~&lt;/code&gt;) are supported, and behave as if BigInt was an infinite length 2's complement number.</source>
          <target state="translated">부호없는 시프트 오른쪽 ( &lt;code&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/code&gt; )을 제외한 모든 산술 연산이 지원됩니다 . 비트 단위 연산 ( &lt;code&gt;|&lt;/code&gt; , &lt;code&gt;&amp;amp;&lt;/code&gt; , &lt;code&gt;^&lt;/code&gt; , &lt;code&gt;~&lt;/code&gt; )이 지원되며 BigInt가 무한 길이 2의 보수 수인 것처럼 동작합니다.</target>
        </trans-unit>
        <trans-unit id="46dc5bc27e859a39247d5b9a63e991bdb3dcaaa3" translate="yes" xml:space="preserve">
          <source>All arrays that use char, wchar, and their qualified versions are narrow strings. (Those include string and wstring).</source>
          <target state="translated">char, wchar 및 정규화 된 버전을 사용하는 모든 배열은 좁은 문자열입니다. 문자열과 wstring이 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="c8a30ad5dcb475c164f90e540d6c2f68890c9e95" translate="yes" xml:space="preserve">
          <source>All changes are temporary. The previous state is restored at the end of the scope.</source>
          <target state="translated">모든 변경 사항은 일시적입니다. 이전 상태는 범위 끝에서 복원됩니다.</target>
        </trans-unit>
        <trans-unit id="21cfae6e750ea0fd4fbc469d1b9c885b7b28182c" translate="yes" xml:space="preserve">
          <source>All character input range conversions using &lt;a href=&quot;#to&quot;&gt;&lt;code&gt;to&lt;/code&gt;&lt;/a&gt; are forwarded to &lt;code&gt;parse&lt;/code&gt; and do not require lvalues.</source>
          <target state="translated">를 사용하여 사용 &lt;a href=&quot;#to&quot;&gt; &lt;code&gt;to&lt;/code&gt; &lt;/a&gt; 모든 문자 입력 범위 변환 은 &lt;code&gt;parse&lt;/code&gt; 을 위해 전달되며 lvalue가 필요하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="9cfc0aec4bf30e7871d683d9b8ae2997d4838aa1" translate="yes" xml:space="preserve">
          <source>All characters with non-zero canonical combining class are combining characters, but the reverse is not the case: there are combining characters with a zero combining class.</source>
          <target state="translated">정규 결합 클래스가 0이 아닌 모든 문자는 문자를 결합하지만 반대의 경우는 아닙니다. 문자가 0 인 결합 클래스와 결합됩니다.</target>
        </trans-unit>
        <trans-unit id="cb44cae4675a0a5faf9a4d0a4f28a2e8d6e40ac0" translate="yes" xml:space="preserve">
          <source>All classes inherit from a super class. If one is not specified, it inherits from Object. Object forms the root of the D class inheritance hierarchy.</source>
          <target state="translated">모든 클래스는 수퍼 클래스에서 상속됩니다. 하나를 지정하지 않으면 Object에서 상속됩니다. 객체는 D 클래스 상속 계층의 루트를 형성합니다.</target>
        </trans-unit>
        <trans-unit id="9bdea0dd8fa982a6717a9259d201dcc03dde23b0" translate="yes" xml:space="preserve">
          <source>All containers have reference semantics, which means that after assignment both variables refer to the same underlying data.</source>
          <target state="translated">모든 컨테이너에는 참조 의미가 있습니다. 즉, 할당 후 두 변수가 모두 동일한 기본 데이터를 참조합니다.</target>
        </trans-unit>
        <trans-unit id="b52c04d3bf060364790c0c3403f5779dc2a33f11" translate="yes" xml:space="preserve">
          <source>All control characters in the ASCII table (&lt;a href=&quot;https://www.asciitable.com&quot;&gt;source&lt;/a&gt;).</source>
          <target state="translated">ASCII 테이블 ( &lt;a href=&quot;https://www.asciitable.com&quot;&gt;source&lt;/a&gt; ) 의 모든 제어 문자</target>
        </trans-unit>
        <trans-unit id="c22d531bfa3aab4e678dd7f6e2eb1504810b6d16" translate="yes" xml:space="preserve">
          <source>All elements &lt;code&gt;e&lt;/code&gt; in subrange &lt;code&gt;r[0 .. k]&lt;/code&gt; satisfy &lt;code&gt;!less(r[k], e)&lt;/code&gt; (i.e. &lt;code&gt;r[k]&lt;/code&gt; is greater than or equal to each element to its left according to predicate &lt;code&gt;less&lt;/code&gt;)</source>
          <target state="translated">하위 범위 &lt;code&gt;r[0 .. k]&lt;/code&gt; 모든 요소 &lt;code&gt;e&lt;/code&gt; 는 &lt;code&gt;!less(r[k], e)&lt;/code&gt; 충족합니다 (즉, &lt;code&gt;r[k]&lt;/code&gt; 는 술어 &lt;code&gt;less&lt;/code&gt; 에 따라 왼쪽의 각 요소보다 크거나 같습니다 )</target>
        </trans-unit>
        <trans-unit id="4173fedb2ec95e1c7fab071952ccdfb425731d8e" translate="yes" xml:space="preserve">
          <source>All elements &lt;code&gt;e&lt;/code&gt; in subrange &lt;code&gt;r[k .. $]&lt;/code&gt; satisfy &lt;code&gt;!less(e, r[k])&lt;/code&gt; (i.e. &lt;code&gt;r[k]&lt;/code&gt; is less than or equal to each element to its right according to predicate &lt;code&gt;less&lt;/code&gt;)</source>
          <target state="translated">하위 범위 &lt;code&gt;r[k .. $]&lt;/code&gt; 모든 요소 &lt;code&gt;e&lt;/code&gt; 는 &lt;code&gt;!less(e, r[k])&lt;/code&gt; 충족합니다 (즉, &lt;code&gt;r[k]&lt;/code&gt; 는 술어 &lt;code&gt;less&lt;/code&gt; 에 따라 오른쪽의 각 요소보다 작거나 같습니다 )</target>
        </trans-unit>
        <trans-unit id="478b4e7b48496f9b1b20465b5132e0e5432d493b" translate="yes" xml:space="preserve">
          <source>All empty nodes which cannot return new memory, are removed from the list.</source>
          <target state="translated">새 메모리를 반환 할 수없는 모든 빈 노드가 목록에서 제거됩니다.</target>
        </trans-unit>
        <trans-unit id="05c11955f5c3b9e526943e8928fc83cd41d0f45c" translate="yes" xml:space="preserve">
          <source>All errors must be dealt with in some way, either by code explicitly written to handle them, or by some system default handling.</source>
          <target state="translated">모든 오류는 어떤 방식 으로든 처리하도록 명시 적으로 작성된 코드 또는 일부 시스템 기본 처리에 의해 처리되어야합니다.</target>
        </trans-unit>
        <trans-unit id="4680cfd395545685306b1b1ceb36045a37266d2f" translate="yes" xml:space="preserve">
          <source>All finer grained error checking is turned on. Address containing errors or warnings is considered invalid. A specific email status code will be returned indicating the error/warning of the address.</source>
          <target state="translated">더 세밀한 모든 오류 검사가 설정되어 있습니다. 오류 또는 경고가 포함 된 주소는 유효하지 않은 것으로 간주됩니다. 주소의 오류 / 경고를 나타내는 특정 이메일 상태 코드가 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="de02c4a63acb3a5d4f7f587b7e81e74ed2b0de72" translate="yes" xml:space="preserve">
          <source>All floating point types to all string types.</source>
          <target state="translated">모든 부동 소수점 유형을 모든 문자열 유형으로</target>
        </trans-unit>
        <trans-unit id="79e88b74a9d4c8b35e8dc0b4507253f67ff5fa01" translate="yes" xml:space="preserve">
          <source>All functions, with the exception of &lt;a href=&quot;#expandTilde&quot;&gt;&lt;code&gt;expandTilde&lt;/code&gt;&lt;/a&gt; (and in some cases &lt;a href=&quot;#absolutePath&quot;&gt;&lt;code&gt;absolutePath&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#relativePath&quot;&gt;&lt;code&gt;relativePath&lt;/code&gt;&lt;/a&gt;), are pure string manipulation functions; they don't depend on any state outside the program, nor do they perform any actual file system actions. This has the consequence that the module does not make any distinction between a path that points to a directory and a path that points to a file, and it does not know whether or not the object pointed to by the path actually exists in the file system. To differentiate between these cases, use &lt;a href=&quot;std_file#isDir&quot;&gt;&lt;code&gt;std.file.isDir&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;std_file#exists&quot;&gt;&lt;code&gt;std.file.exists&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#expandTilde&quot;&gt; &lt;code&gt;expandTilde&lt;/code&gt; &lt;/a&gt; (일부 경우 &lt;a href=&quot;#absolutePath&quot;&gt; &lt;code&gt;absolutePath&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#relativePath&quot;&gt; &lt;code&gt;relativePath&lt;/code&gt; &lt;/a&gt; )를 제외한 모든 함수 는 순수한 문자열 조작 함수입니다. 프로그램 외부의 상태에 의존하지 않으며 실제 파일 시스템 작업을 수행하지도 않습니다. 이는 모듈이 디렉토리를 가리키는 경로와 파일을 가리키는 경로를 구별하지 않으며, 경로가 가리키는 오브젝트가 실제로 파일 시스템에 존재하는지 여부를 알지 못합니다. . 이러한 경우를 구별하려면 &lt;a href=&quot;std_file#isDir&quot;&gt; &lt;code&gt;std.file.isDir&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;std_file#exists&quot;&gt; &lt;code&gt;std.file.exists&lt;/code&gt; 를&lt;/a&gt; 사용 하십시오 .</target>
        </trans-unit>
        <trans-unit id="897231d543ddd436ff3d6ba5df7aae31b8e08c87" translate="yes" xml:space="preserve">
          <source>All hidden parameters bundled.</source>
          <target state="translated">모든 숨겨진 매개 변수가 번들로 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="8f34602fbc14abc9ba9e2e2916d9e6f9be4a8ff7" translate="yes" xml:space="preserve">
          <source>All implementations must support these, even if by just ignoring them:</source>
          <target state="translated">모든 구현은 무시 만해도이를 지원해야합니다.</target>
        </trans-unit>
        <trans-unit id="8bbea447a7889fa98476703b1f292c42f34bfb25" translate="yes" xml:space="preserve">
          <source>All information associated with call to log function.</source>
          <target state="translated">Call to Log 기능과 관련된 모든 정보.</target>
        </trans-unit>
        <trans-unit id="3a29b997591598a8b6cfc336ecadb36fbed66be7" translate="yes" xml:space="preserve">
          <source>All inserts, removes, searches, and any function in general has complexity of &amp;Omicron;(&lt;code&gt;lg(n)&lt;/code&gt;).</source>
          <target state="translated">모든 삽입, 제거, 검색 및 일반적으로 모든 함수의 복잡도는 &amp;Omicron; ( &lt;code&gt;lg(n)&lt;/code&gt; )입니다.</target>
        </trans-unit>
        <trans-unit id="dcba16c11981f392657558a8d07f357ce4272a30" translate="yes" xml:space="preserve">
          <source>All interface functions must be defined in a class that inherits from that interface:</source>
          <target state="translated">모든 인터페이스 함수는 해당 인터페이스에서 상속되는 클래스에 정의되어야합니다.</target>
        </trans-unit>
        <trans-unit id="91e8b4ee2b5a17486728589fc5f6cd3d4c03e0e9" translate="yes" xml:space="preserve">
          <source>All keys can be removed by using the method &lt;code&gt;clear&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;clear&lt;/code&gt; 방법을 사용하여 모든 키를 제거 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="cfd5908b4325dd814d160c014614e871bbfd4828" translate="yes" xml:space="preserve">
          <source>All locks are automatically released when the process terminates.</source>
          <target state="translated">프로세스가 종료되면 모든 잠금이 자동으로 해제됩니다.</target>
        </trans-unit>
        <trans-unit id="9a9b40a952996bdcd13db98ad39be39296434cf8" translate="yes" xml:space="preserve">
          <source>All matches returned by pattern matching functionality in this library are slices of the original input. The notable exception is the &lt;code&gt;replace&lt;/code&gt; family of functions that generate a new string from the input.</source>
          <target state="translated">이 라이브러리에서 패턴 일치 기능으로 리턴 된 모든 일치는 원래 입력의 조각입니다. 주목할만한 예외는 입력에서 새 문자열을 생성하는 &lt;code&gt;replace&lt;/code&gt; 함수 계열입니다.</target>
        </trans-unit>
        <trans-unit id="c8490a5c1885e9991535da5cae9171b20351f0f9" translate="yes" xml:space="preserve">
          <source>All member functions of synchronized classes are synchronized. A static member function is synchronized on the</source>
          <target state="translated">동기화 된 클래스의 모든 멤버 함수가 동기화됩니다. 정적 멤버 함수는</target>
        </trans-unit>
        <trans-unit id="0d2e902a58669b4a70fa2a561fe94c27f74e6b8d" translate="yes" xml:space="preserve">
          <source>All methods inside a class declared as &lt;code&gt;extern (Objective-C)&lt;/code&gt; will get implicit Objective-C linkage.</source>
          <target state="translated">&lt;code&gt;extern (Objective-C)&lt;/code&gt; 으로 선언 된 클래스 내의 모든 메서드 는 암시적인 Objective-C 연결을 갖습니다.</target>
        </trans-unit>
        <trans-unit id="b366095400babb69322d711aa921d268cfb35ea8" translate="yes" xml:space="preserve">
          <source>All numbers in [-&amp;infin;, +&amp;infin;] are ordered the same way as by built-in comparison, with the exception of -0.0, which is less than +0.0;</source>
          <target state="translated">[-&amp;infin;, + &amp;infin;]의 모든 숫자는 +0.0보다 작은 -0.0을 제외하고 내장 비교와 동일한 방식으로 정렬됩니다.</target>
        </trans-unit>
        <trans-unit id="cf2fb5f601f3c7c74aa1d7bc5d26857dd697e304" translate="yes" xml:space="preserve">
          <source>All of its inputs are assumed to be sorted. This can mean that inputs are instances of &lt;a href=&quot;std_range#SortedRange&quot;&gt;&lt;code&gt;std.range.SortedRange&lt;/code&gt;&lt;/a&gt;. Use the result of &lt;a href=&quot;std_algorithm_sorting#sort&quot;&gt;&lt;code&gt; std.algorithm.sorting.sort&lt;/code&gt;&lt;/a&gt;, or &lt;a href=&quot;std_range#assumeSorted&quot;&gt;&lt;code&gt;std.range.assumeSorted&lt;/code&gt;&lt;/a&gt; to merge ranges known to be sorted (show in the example below). Note that there is currently no way of ensuring that two or more instances of &lt;a href=&quot;std_range#SortedRange&quot;&gt;&lt;code&gt; std.range.SortedRange&lt;/code&gt;&lt;/a&gt; are sorted using a specific comparison function &lt;code&gt;pred&lt;/code&gt;. Therefore no checking is done here to assure that all inputs &lt;code&gt;rs&lt;/code&gt; are instances of &lt;a href=&quot;std_range#SortedRange&quot;&gt;&lt;code&gt;std.range.SortedRange&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">모든 입력은 정렬 된 것으로 가정합니다. 이것은 입력이 &lt;a href=&quot;std_range#SortedRange&quot;&gt; &lt;code&gt;std.range.SortedRange&lt;/code&gt; 의&lt;/a&gt; 인스턴스임을 의미 할 수 있습니다 . &lt;a href=&quot;std_algorithm_sorting#sort&quot;&gt; &lt;code&gt; std.algorithm.sorting.sort&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;std_range#assumeSorted&quot;&gt; &lt;code&gt;std.range.assumeSorted&lt;/code&gt; &lt;/a&gt; 의 결과를 사용하여 정렬 된 것으로 알려진 범위를 병합하십시오 (아래 예 참조). 현재 &lt;a href=&quot;std_range#SortedRange&quot;&gt; &lt;code&gt; std.range.SortedRange&lt;/code&gt; 의&lt;/a&gt; 둘 이상의 인스턴스가 특정 비교 함수 &lt;code&gt;pred&lt;/code&gt; 를 사용하여 정렬 되도록하는 방법은 없습니다 . 따라서 모든 입력 &lt;code&gt;rs&lt;/code&gt; 가 &lt;a href=&quot;std_range#SortedRange&quot;&gt; &lt;code&gt;std.range.SortedRange&lt;/code&gt; 의&lt;/a&gt; 인스턴스 인지 확인하기 위해 여기서는 점검이 수행되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="7760c023d07d36fdca08004de575b3be6fcb979d" translate="yes" xml:space="preserve">
          <source>All of the functions in std.ascii accept Unicode characters but effectively ignore them if they're not ASCII. All &lt;code&gt;isX&lt;/code&gt; functions return &lt;code&gt;false&lt;/code&gt; for non-ASCII characters, and all &lt;code&gt;toX&lt;/code&gt; functions do nothing to non-ASCII characters.</source>
          <target state="translated">std.ascii의 모든 함수는 유니 코드 문자를 허용하지만 ASCII가 아닌 경우이를 무시합니다. ASCII가 아닌 문자에 대해서는 모든 &lt;code&gt;isX&lt;/code&gt; 함수가 &lt;code&gt;false&lt;/code&gt; 를 반환 하고 ASCII가 아닌 문자에 대해서는 모든 &lt;code&gt;toX&lt;/code&gt; 함수가 아무 것도 수행하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="406700e1b4c5b2a9f03e14707a386766e7ff13f4" translate="yes" xml:space="preserve">
          <source>All of the standard numeric operators are defined for the UUID struct.</source>
          <target state="translated">모든 표준 숫자 연산자는 UUID 구조체에 대해 정의됩니다.</target>
        </trans-unit>
        <trans-unit id="3100bf25a966348766069acc9d7aec1ceec953c8" translate="yes" xml:space="preserve">
          <source>All of these UUID versions can be read and processed by &lt;code&gt;std.uuid&lt;/code&gt;, but only version 3, 4 and 5 UUIDs can be generated.</source>
          <target state="translated">이 모든 UUID 버전은 &lt;code&gt;std.uuid&lt;/code&gt; 가 읽고 처리 할 수 있지만 버전 3, 4 및 5 UUID 만 생성 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="502d87114b09889db456bdf9177fc6f3f3031b7f" translate="yes" xml:space="preserve">
          <source>All of these functions come in two varieties: one takes a target element, where the range will be stripped as long as this element can be found. The other takes a lambda predicate, where the range will be stripped as long as the predicate returns true.</source>
          <target state="translated">이러한 모든 기능은 두 가지 종류로 제공됩니다. 하나는 대상 요소를 취하며이 요소를 찾을 수있는 한 범위가 제거됩니다. 다른 하나는 람다 술어를 취하는데, 술어가 true를 리턴하는 한 범위가 제거됩니다.</target>
        </trans-unit>
        <trans-unit id="821e98543b08c50cacab703f8d367d6710ccef75" translate="yes" xml:space="preserve">
          <source>All other BSDs</source>
          <target state="translated">다른 모든 BSD</target>
        </trans-unit>
        <trans-unit id="cd68fd410f45079b0d7aa364b641219999200191" translate="yes" xml:space="preserve">
          <source>All possible error codes from all sorts of curl functions. Future versions may return other values, stay prepared.</source>
          <target state="translated">모든 종류의 컬 함수에서 가능한 모든 오류 코드. 향후 버전은 다른 값을 반환하고 준비 상태를 유지할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="136fb65faf8ab2a2cf368736fd6aeb99f8c344fd" translate="yes" xml:space="preserve">
          <source>All possible options</source>
          <target state="translated">가능한 모든 옵션</target>
        </trans-unit>
        <trans-unit id="b813b3d5035d2aa3a990bcb3215de8f25be6e30e" translate="yes" xml:space="preserve">
          <source>All primitives listed operate on Unicode characters and sets of characters. For functions which operate on ASCII characters and ignore Unicode &lt;a href=&quot;#Character&quot;&gt;characters&lt;/a&gt;, see &lt;a href=&quot;std_ascii&quot;&gt;&lt;code&gt;std.ascii&lt;/code&gt;&lt;/a&gt;. For definitions of Unicode &lt;a href=&quot;#Character&quot;&gt;character&lt;/a&gt;, &lt;a href=&quot;#Code%20point&quot;&gt;code point&lt;/a&gt; and other terms used throughout this module see the &lt;a href=&quot;#Terminology&quot;&gt;terminology&lt;/a&gt; section below.</source>
          <target state="translated">나열된 모든 기본 요소는 유니 코드 문자 및 문자 세트에서 작동합니다. ASCII 문자에서 작동하고 유니 코드 &lt;a href=&quot;#Character&quot;&gt;문자를&lt;/a&gt; 무시하는 기능 에 대해서는 &lt;a href=&quot;std_ascii&quot;&gt; &lt;code&gt;std.ascii&lt;/code&gt; 를&lt;/a&gt; 참조하십시오 . 이 모듈에서 사용되는 유니 코드 &lt;a href=&quot;#Character&quot;&gt;문자&lt;/a&gt; , &lt;a href=&quot;#Code%20point&quot;&gt;코드 포인트&lt;/a&gt; 및 기타 용어에 대한 정의는 아래 &lt;a href=&quot;#Terminology&quot;&gt;용어&lt;/a&gt; 섹션을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="6c8a2e2c452533012af5af53a5f2117564ba54d2" translate="yes" xml:space="preserve">
          <source>All programs have to deal with errors. Errors are unexpected conditions that are not part of the normal operation of a program. Examples of common errors are:</source>
          <target state="translated">모든 프로그램은 오류를 처리해야합니다. 오류는 프로그램의 정상적인 작동에 포함되지 않는 예기치 않은 조건입니다. 일반적인 오류의 예는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="c20c0313c3654dcf38a230e6a0ac8e51f952d657" translate="yes" xml:space="preserve">
          <source>All reading from &lt;code&gt;stdin&lt;/code&gt; automatically locks the file globally, and will cause all other threads calling &lt;code&gt;read&lt;/code&gt; to wait until the lock is released.</source>
          <target state="translated">&lt;code&gt;stdin&lt;/code&gt; 에서 읽은 모든 파일은 자동으로 파일을 전체적으로 잠그고 &lt;code&gt;read&lt;/code&gt; 를 호출하는 다른 모든 스레드 는 잠금이 해제 될 때까지 대기합니다.</target>
        </trans-unit>
        <trans-unit id="f9df267cdc9ad11425ae578a49e8b8411f22249c" translate="yes" xml:space="preserve">
          <source>All sections for the module are combined.</source>
          <target state="translated">모듈의 모든 섹션이 결합됩니다.</target>
        </trans-unit>
        <trans-unit id="4fe809ffea83f91ee87860fb09bce9898a2380b1" translate="yes" xml:space="preserve">
          <source>All static fields in this struct represents a specific predefined symbol.</source>
          <target state="translated">이 구조체의 모든 정적 필드는 사전 정의 된 특정 기호를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="9dfd9dd3cf17f876b6f44df68cf586485cbe563b" translate="yes" xml:space="preserve">
          <source>All stats of the form &lt;code&gt;numXxx&lt;/code&gt; record counts of events occurring, such as calls to functions and specific results. The stats of the form &lt;code&gt;bytesXxx&lt;/code&gt; collect cumulative sizes.</source>
          <target state="translated">&lt;code&gt;numXxx&lt;/code&gt; 형식의 모든 통계는 함수 호출 및 특정 결과와 같은 이벤트 발생 횟수를 기록합니다. &lt;code&gt;bytesXxx&lt;/code&gt; 형식의 통계는 누적 크기를 수집합니다.</target>
        </trans-unit>
        <trans-unit id="3aeac5247fab94056a2fcd9ae2ebfe7ce2a4741c" translate="yes" xml:space="preserve">
          <source>All steps combined look like this:</source>
          <target state="translated">결합 된 모든 단계는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="73e1d82508097f721dc5f94481ae54c7c96a5506" translate="yes" xml:space="preserve">
          <source>All symbols from a publicly imported module are also aliased in the importing module. Thus in the above example if C contains the name foo, it will be accessible in A as &lt;code&gt;foo&lt;/code&gt;, &lt;code&gt;B.foo&lt;/code&gt; and &lt;code&gt;C.foo&lt;/code&gt;.</source>
          <target state="translated">공개적으로 가져온 모듈의 모든 심볼도 가져 오기 모듈에서 별칭이 지정됩니다. 따라서 위 예제에서 C에 foo라는 이름이 포함되어 있으면 A에서 &lt;code&gt;foo&lt;/code&gt; , &lt;code&gt;B.foo&lt;/code&gt; 및 &lt;code&gt;C.foo&lt;/code&gt; 로 액세스 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="a81b5e33e5d9b6fed4225267f1379628464786b1" translate="yes" xml:space="preserve">
          <source>All symbols within &lt;code&gt;symbol&lt;/code&gt; that have the given UDA &lt;code&gt;attribute&lt;/code&gt;.</source>
          <target state="translated">내의 모든 문자 &lt;code&gt;symbol&lt;/code&gt; 주어진 UDA의이 &lt;code&gt;attribute&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="20ecb571750aace44511ab3cf936eb97eef093c5" translate="yes" xml:space="preserve">
          <source>All the binary operators work in their assignment version</source>
          <target state="translated">모든 이진 연산자는 할당 버전에서 작동합니다.</target>
        </trans-unit>
        <trans-unit id="dd0de63de936b7274b430f7f3c7c61353d4b4b65" translate="yes" xml:space="preserve">
          <source>All the properties of the &lt;a href=&quot;declaration#VectorBaseType&quot;&gt;&lt;i&gt;VectorBaseType&lt;/i&gt;&lt;/a&gt; work.</source>
          <target state="translated">&lt;a href=&quot;declaration#VectorBaseType&quot;&gt;&lt;i&gt;VectorBaseType&lt;/i&gt;&lt;/a&gt; 의 모든 속성이 작동합니다.</target>
        </trans-unit>
        <trans-unit id="97efa5a26947938bb903257f0409a1c26a039cd2" translate="yes" xml:space="preserve">
          <source>All the static constructors for a module are aggregated into a single function, and a pointer to that function is inserted into the ctor member of the ModuleInfo instance for that module.</source>
          <target state="translated">모듈의 모든 정적 생성자는 단일 함수로 집계되고 해당 함수에 대한 포인터가 해당 모듈에 대한 ModuleInfo 인스턴스의 ctor 멤버에 삽입됩니다.</target>
        </trans-unit>
        <trans-unit id="2b0681a718887d97ad7ee984aa0510556a949ead" translate="yes" xml:space="preserve">
          <source>All the static denstructors for a module are aggregated into a single function, and a pointer to that function is inserted into the dtor member of the ModuleInfo instance for that module.</source>
          <target state="translated">모듈의 모든 정적 denstructor는 단일 함수로 집계되며 해당 함수에 대한 포인터가 해당 모듈에 대한 ModuleInfo 인스턴스의 dtor 멤버에 삽입됩니다.</target>
        </trans-unit>
        <trans-unit id="15236deff34ae39943ca5f31e8d24cf0e03855cc" translate="yes" xml:space="preserve">
          <source>All the unit tests for a module are aggregated into a single function, and a pointer to that function is inserted into the unitTest member of the ModuleInfo instance for that module.</source>
          <target state="translated">모듈에 대한 모든 단위 테스트는 단일 함수로 집계되며 해당 함수에 대한 포인터가 해당 모듈에 대한 ModuleInfo 인스턴스의 unitTest 멤버에 삽입됩니다.</target>
        </trans-unit>
        <trans-unit id="f949da684991e66b76cb0131b05508ca1cb634cb" translate="yes" xml:space="preserve">
          <source>All those destructors freeing memory can become significant when objects are allocated on the stack. For each one, some mechanism must be established so that if an exception happens, the destructors all get called in each frame to release any memory they hold. If the destructors become irrelevant, then there's no need to set up special stack frames to handle exceptions, and the code runs faster.</source>
          <target state="translated">객체가 스택에 할당되면 메모리를 비우는 모든 소멸자가 중요해질 수 있습니다. 각각에 대해 예외가 발생하면 소멸자가 모든 프레임에서 호출되어 보유한 메모리를 해제하도록 메커니즘을 설정해야합니다. 소멸자가 관련이 없으면 예외를 처리하기 위해 특수 스택 프레임을 설정할 필요가 없으며 코드가 더 빨리 실행됩니다.</target>
        </trans-unit>
        <trans-unit id="c628520ddca4f269f1a2425393dd896bb6ecd64f" translate="yes" xml:space="preserve">
          <source>All thrown objects must inherit from Throwable. Class &lt;code&gt;Exception&lt;/code&gt;, which derives from this class, represents the category of thrown objects that are safe to catch and handle. In principle, one should not catch Throwable objects that are not derived from &lt;code&gt;Exception&lt;/code&gt;, as they represent unrecoverable runtime errors. Certain runtime guarantees may fail to hold when these errors are thrown, making it unsafe to continue execution after catching them.</source>
          <target state="translated">발생 된 모든 객체는 Throwable에서 상속해야합니다. 이 클래스에서 파생 된 Class &lt;code&gt;Exception&lt;/code&gt; 은 포착하고 처리하기에 안전한 던져진 객체의 범주를 나타냅니다. 원칙적으로 &lt;code&gt;Exception&lt;/code&gt; 에서 파생되지 않은 Throwable 객체는 포착 할 수없는 런타임 오류를 나타내므로이를 포착해서는 안됩니다 . 이러한 오류가 발생하면 특정 런타임 보증이 유지되지 않아 오류를 발견 한 후에도 계속 실행하는 것이 안전하지 않을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d57ed726e64ba51ae7c15a7975e045226435204a" translate="yes" xml:space="preserve">
          <source>All writing to &lt;code&gt;stderr&lt;/code&gt; automatically locks the file globally, and will cause all other threads calling &lt;code&gt;write&lt;/code&gt; to wait until the lock is released.</source>
          <target state="translated">&lt;code&gt;stderr&lt;/code&gt; 에 모든 쓰기는 자동으로 파일을 전체적으로 잠그고, &lt;code&gt;write&lt;/code&gt; 를 호출하는 다른 모든 스레드 는 잠금이 해제 될 때까지 대기합니다.</target>
        </trans-unit>
        <trans-unit id="645f93cabf6576decf07a138ca4abf26edcd1dfb" translate="yes" xml:space="preserve">
          <source>All writing to &lt;code&gt;stdout&lt;/code&gt; automatically locks the file globally, and will cause all other threads calling &lt;code&gt;write&lt;/code&gt; to wait until the lock is released.</source>
          <target state="translated">&lt;code&gt;stdout&lt;/code&gt; 에 쓰면 자동으로 파일이 전체적으로 잠기고, &lt;code&gt;write&lt;/code&gt; 를 호출하는 다른 모든 스레드 는 잠금이 해제 될 때까지 대기합니다.</target>
        </trans-unit>
        <trans-unit id="1b093a504d859edb011aa4c10e43272d307e7616" translate="yes" xml:space="preserve">
          <source>Allocate &lt;code&gt;n&lt;/code&gt; bytes of memory. If &lt;code&gt;n&lt;/code&gt; is eligible for freelist and the freelist is not empty, pops the memory off the free list. In all other cases, uses the parent allocator.</source>
          <target state="translated">&lt;code&gt;n&lt;/code&gt; 바이트의 메모리를 할당하십시오 . 경우 &lt;code&gt;n&lt;/code&gt; 이 가능리스트에 대한 자격 및 가능리스트가 비어 있지 않은, 자유 목록 오프 메모리를 나타납니다. 다른 모든 경우에는 상위 할당자를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="cb204135b1e21acae9320219240e8e87e6f65b6f" translate="yes" xml:space="preserve">
          <source>Allocate a block of size &lt;code&gt;s&lt;/code&gt; with alignment &lt;code&gt;a&lt;/code&gt;. First tries to allocate from the existing list of already-created allocators. If neither can satisfy the request, creates a new allocator by calling &lt;code&gt;make(s + a - 1)&lt;/code&gt; and delegates the request to it. However, if the allocation fresh off a newly created allocator fails, subsequent calls to &lt;code&gt;alignedAllocate&lt;/code&gt; will not cause more calls to &lt;code&gt;make&lt;/code&gt;.</source>
          <target state="translated">크기의 블록 할당 &lt;code&gt;s&lt;/code&gt; 배향과 &lt;code&gt;a&lt;/code&gt; . 먼저 기존의 할당 자 목록에서 할당을 시도합니다. 둘 다 요청을 충족시킬 수 없으면 &lt;code&gt;make(s + a - 1)&lt;/code&gt; 를 호출하여 새 할당자를 만들고 요청을 위임합니다. 새로 만든 할당 해제 할당 신선한가 실패 할 경우, 후속 호출 &lt;code&gt;alignedAllocate&lt;/code&gt; 은 에 더 많은 통화가 발생하지 않습니다 &lt;code&gt;make&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f1b869869fcf623a87d8a6cf55943a9b074f4092" translate="yes" xml:space="preserve">
          <source>Allocate a block of size &lt;code&gt;s&lt;/code&gt;. First tries to allocate from the existing list of already-created allocators. If neither can satisfy the request, creates a new allocator by calling &lt;code&gt;make(s)&lt;/code&gt; and delegates the request to it. However, if the allocation fresh off a newly created allocator fails, subsequent calls to &lt;code&gt;allocate&lt;/code&gt; will not cause more calls to &lt;code&gt; make&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;s&lt;/code&gt; 크기 의 블록을 할당하십시오 . 먼저 기존의 할당 자 목록에서 할당을 시도합니다. 둘 다 요청을 만족시킬 수 없으면 &lt;code&gt;make(s)&lt;/code&gt; 를 호출하여 새 할당자를 작성 하고 요청을 위임하십시오. 새로 만든 할당 해제 할당 신선한가 실패 할 경우, 후속 호출하는 &lt;code&gt;allocate&lt;/code&gt; 더 많은 통화가 발생하지 않습니다 &lt;code&gt; make&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4e3ac4a0a39edc956251dca78db0c555e763550a" translate="yes" xml:space="preserve">
          <source>Allocate a new array of length elements. ti is the type of the resulting array, or pointer to element. (For when the array is initialized to 0)</source>
          <target state="translated">길이 요소의 새로운 배열을 할당하십시오. ti는 결과 배열의 유형 또는 요소에 대한 포인터입니다. (배열이 0으로 초기화 된 경우)</target>
        </trans-unit>
        <trans-unit id="04a5579ec9d9ea7bf8fd9194782b75e61153d45c" translate="yes" xml:space="preserve">
          <source>Allocate a new uninitialized array of length elements. ti is the type of the resulting array, or pointer to element.</source>
          <target state="translated">초기화되지 않은 새로운 길이 요소 배열을 할당하십시오. ti는 결과 배열의 유형 또는 요소에 대한 포인터입니다.</target>
        </trans-unit>
        <trans-unit id="4addc8952362210dbd4d01899c0184f19033db2f" translate="yes" xml:space="preserve">
          <source>Allocate a new variable via xmalloc that can be added to the global environment. The resulting string will be null-terminated immediately after the end of the array.</source>
          <target state="translated">글로벌 환경에 추가 할 수있는 xmalloc을 통해 새 변수를 할당하십시오. 결과 문자열은 배열 종료 직후에 널 종료됩니다.</target>
        </trans-unit>
        <trans-unit id="f5ae03eb0a1a6cb0d88d14fb5a3b4d6ad0ebf542" translate="yes" xml:space="preserve">
          <source>Allocate an exception of type &lt;code&gt;ci&lt;/code&gt; from the exception pool. It has the same interface as &lt;code&gt;rt.lifetime._d_newclass()&lt;/code&gt;. The class type must be Throwable or derived from it, and cannot be a COM or C++ class. The compiler must enforce this.</source>
          <target state="translated">예외 풀에서 &lt;code&gt;ci&lt;/code&gt; 유형의 예외를 할당하십시오 . &lt;code&gt;rt.lifetime._d_newclass()&lt;/code&gt; 와 동일한 인터페이스를 갖습니다 . 클래스 유형은 Throwable 또는 클래스 유형이어야하며 COM 또는 C ++ 클래스 일 수 없습니다. 컴파일러는이를 시행해야합니다.</target>
        </trans-unit>
        <trans-unit id="b15ff176dde037c8eec0c32aab20116e3b618dd6" translate="yes" xml:space="preserve">
          <source>Allocate an instance of the class, &lt;code&gt;NSString&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;NSString&lt;/code&gt; 클래스의 인스턴스를 할당하십시오 .</target>
        </trans-unit>
        <trans-unit id="74612396c30d0c63cc046cd3b14fa2fd0d0f12bd" translate="yes" xml:space="preserve">
          <source>Allocate an uninitialized non-array item. This is an optimization to avoid things needed for arrays like the _arrayPad(size).</source>
          <target state="translated">초기화되지 않은 비 배열 항목을 할당하십시오. 이것은 _arrayPad (size)와 같은 배열에 필요한 것을 피하기위한 최적화입니다.</target>
        </trans-unit>
        <trans-unit id="690211495bdf02fe74267eebc1c68112cdf01cf1" translate="yes" xml:space="preserve">
          <source>Allocate and fill in ctors[] and tlsctors[]. Modules are inserted into the arrays in the order in which the constructors need to be run.</source>
          <target state="translated">ctors [] 및 tlsctors []를 할당하고 채우십시오. 생성자가 실행되는 순서대로 모듈이 배열에 삽입됩니다.</target>
        </trans-unit>
        <trans-unit id="546305171dde7bde4a1c7bbf4dee4fc391ed9224" translate="yes" xml:space="preserve">
          <source>Allocate and initialize an ExceptionHeader.</source>
          <target state="translated">ExceptionHeader를 할당하고 초기화하십시오.</target>
        </trans-unit>
        <trans-unit id="152c2032835fcd0df6e709b46cbe62f6b6cd7102" translate="yes" xml:space="preserve">
          <source>Allocate data from the caller's stack frame. This is a 'magic' function that needs help from the compiler to work right, do not change its name, do not call it from other compilers.</source>
          <target state="translated">발신자의 스택 프레임에서 데이터를 할당합니다. 이것은 컴파일러가 올바르게 작동하고 이름을 변경하지 않으며 다른 컴파일러에서 호출하지 않는 데 도움이 필요한 '매직'기능입니다.</target>
        </trans-unit>
        <trans-unit id="7bcab4c37e278570affa71300f593890c5082f0a" translate="yes" xml:space="preserve">
          <source>Allocate the array, rely on the caller to do the initialization of the array.</source>
          <target state="translated">배열을 할당하고, 호출자에게 의존하여 배열을 초기화하십시오.</target>
        </trans-unit>
        <trans-unit id="ae51d44518dcf6c4431053abbfb74d465f5558a1" translate="yes" xml:space="preserve">
          <source>Allocated blocks do not hold a size prefix. This is because in D the size information is available in client code at deallocation time.</source>
          <target state="translated">할당 된 블록에는 크기 접두사가 없습니다. D에서 크기 정보가 할당 해제시 클라이언트 코드에서 사용 가능하기 때문입니다.</target>
        </trans-unit>
        <trans-unit id="cb1dd4282b618235f704ba742fef6168e8279026" translate="yes" xml:space="preserve">
          <source>Allocates &lt;code&gt;bytes&lt;/code&gt; and returns them, or &lt;code&gt;null&lt;/code&gt; if the region cannot accommodate the request. For efficiency reasons, if &lt;code&gt;bytes == 0&lt;/code&gt; the function returns an empty non-null slice.</source>
          <target state="translated">&lt;code&gt;bytes&lt;/code&gt; 할당 하여 반환하거나 리전이 요청을 수용 할 수없는 경우 &lt;code&gt;null&lt;/code&gt; 을 반환합니다 . 효율성을 위해 &lt;code&gt;bytes == 0&lt;/code&gt; 경우 함수는 비어있는 null이 아닌 슬라이스를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="dd1ff9ea9b54d782b4a1fa925149d8ee9eefd67e" translate="yes" xml:space="preserve">
          <source>Allocates &lt;code&gt;n&lt;/code&gt; bytes of memory aligned at alignment &lt;code&gt;a&lt;/code&gt;.</source>
          <target state="translated">정렬 &lt;code&gt;a&lt;/code&gt; 에 정렬 된 &lt;code&gt;n&lt;/code&gt; 바이트의 메모리를 할당 합니다 .</target>
        </trans-unit>
        <trans-unit id="a919f47db37669617faab9ea6d5ad732011e85df" translate="yes" xml:space="preserve">
          <source>Allocates &lt;code&gt;n&lt;/code&gt; bytes of memory with specified alignment &lt;code&gt;a&lt;/code&gt;. Implementations that do not support this primitive should always return &lt;code&gt;null&lt;/code&gt;.</source>
          <target state="translated">지정된 정렬 &lt;code&gt;a&lt;/code&gt; 로 &lt;code&gt;n&lt;/code&gt; 바이트의 메모리를 할당 합니다 . 이 프리미티브를 지원하지 않는 구현은 항상 &lt;code&gt;null&lt;/code&gt; 을 리턴해야합니다 .</target>
        </trans-unit>
        <trans-unit id="3556f444ee3e01e4ff6b4c12964c1a5b8dc14fca" translate="yes" xml:space="preserve">
          <source>Allocates &lt;code&gt;n&lt;/code&gt; bytes of memory.</source>
          <target state="translated">&lt;code&gt;n&lt;/code&gt; 바이트의 메모리를 할당합니다 .</target>
        </trans-unit>
        <trans-unit id="571906ff58f2c345c55fece0c6b4680a0d168821" translate="yes" xml:space="preserve">
          <source>Allocates &lt;code&gt;n&lt;/code&gt; bytes of memory. First consults the free tree, and returns from it if a suitably sized block is found. Otherwise, the parent allocator is tried. If allocation from the parent succeeds, the allocated block is returned. Otherwise, the free tree tries an alternate strategy: If &lt;code&gt; ParentAllocator&lt;/code&gt; defines &lt;code&gt;deallocate&lt;/code&gt;, &lt;code&gt;FreeTree&lt;/code&gt; releases all of its contents and tries again.</source>
          <target state="translated">&lt;code&gt;n&lt;/code&gt; 바이트의 메모리를 할당합니다 . 먼저 사용 가능한 트리를 참조하고 적절한 크기의 블록이 발견되면 사용 가능한 트리를 반환합니다. 그렇지 않으면 상위 할당자가 시도됩니다. 부모로부터 할당이 성공하면 할당 된 블록이 반환됩니다. 그렇지 않으면, 무료 나무는 다른 전략을 시도합니다 경우 &lt;code&gt; ParentAllocator&lt;/code&gt; 을 정의 &lt;code&gt;deallocate&lt;/code&gt; , &lt;code&gt;FreeTree&lt;/code&gt; 는 다시 그 내용과 시도를 모두 해제합니다.</target>
        </trans-unit>
        <trans-unit id="e2b3a385e46b9ac83e94af9618c4d1619a61f273" translate="yes" xml:space="preserve">
          <source>Allocates &lt;code&gt;n&lt;/code&gt; bytes of memory. The allocation is served by atomically incrementing a pointer which keeps track of the current used space.</source>
          <target state="translated">&lt;code&gt;n&lt;/code&gt; 바이트의 메모리를 할당합니다 . 할당은 현재 사용 된 공간을 추적하는 포인터를 원자 적으로 증가시킴으로써 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="545e4bfeb16f8477990d8181bb9178281843dd98" translate="yes" xml:space="preserve">
          <source>Allocates &lt;code&gt;n&lt;/code&gt; bytes of memory. The shortest path involves an alignment adjustment (if &lt;code&gt;alignment &amp;gt; 1&lt;/code&gt;), an increment, and a comparison.</source>
          <target state="translated">&lt;code&gt;n&lt;/code&gt; 바이트의 메모리를 할당합니다 . 최단 경로에는 정렬 조정 ( &lt;code&gt;alignment &amp;gt; 1&lt;/code&gt; 경우 ), 증분 및 비교가 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="2936608c36ed9f5713be515def45d248186393f0" translate="yes" xml:space="preserve">
          <source>Allocates &lt;code&gt;n&lt;/code&gt; bytes. Allocation searches the list of available blocks until a free block with &lt;code&gt;n&lt;/code&gt; or more bytes is found (first fit strategy). The block is split (if larger) and returned.</source>
          <target state="translated">&lt;code&gt;n&lt;/code&gt; 바이트를 할당 합니다. 할당은 &lt;code&gt;n&lt;/code&gt; 바이트 이상의 여유 블록 이 발견 될 때까지 사용 가능한 블록 목록을 검색합니다 (1 차 전략). 블록이 분할 된 경우 (더 큰 경우) 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="b627f8a5a1e78d575daa227732620caf9398d99d" translate="yes" xml:space="preserve">
          <source>Allocates &lt;code&gt;s&lt;/code&gt; bytes of memory and returns it, or &lt;code&gt;null&lt;/code&gt; if memory could not be allocated.</source>
          <target state="translated">&lt;code&gt;s&lt;/code&gt; 바이트의 메모리를 할당 하여 반환하거나 메모리를 할당 할 수없는 경우 &lt;code&gt;null&lt;/code&gt; 을 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="955f82f1f9371d9a1a5f44a9d6884b1bf06878cf" translate="yes" xml:space="preserve">
          <source>Allocates a &lt;code&gt;class&lt;/code&gt; object right inside the current scope, therefore avoiding the overhead of &lt;code&gt;new&lt;/code&gt;. This facility is unsafe; it is the responsibility of the user to not escape a reference to the object outside the scope.</source>
          <target state="translated">현재 범위 내에 &lt;code&gt;class&lt;/code&gt; 객체를 할당 하므로 &lt;code&gt;new&lt;/code&gt; 의 오버 헤드를 피할 수 있습니다. 이 시설은 안전하지 않습니다. 범위 밖의 객체에 대한 참조를 피하지 않는 것은 사용자의 책임입니다.</target>
        </trans-unit>
        <trans-unit id="2d0bc107a98ee07d1d72bbabf6107748dcbf6e02" translate="yes" xml:space="preserve">
          <source>Allocates a block with specified alignment &lt;code&gt;a&lt;/code&gt;. The alignment must be a power of 2. If &lt;code&gt;a &amp;lt;= alignment&lt;/code&gt;, function forwards to &lt;code&gt;allocate&lt;/code&gt;. Otherwise, it attempts to overallocate and then adjust the result for proper alignment. In the worst case the slack memory is around two blocks.</source>
          <target state="translated">지정된 정렬 &lt;code&gt;a&lt;/code&gt; 로 블록을 할당합니다 . 정렬은 2의 거듭 제곱이어야합니다 &lt;code&gt;a &amp;lt;= alignment&lt;/code&gt; 경우 함수는 &lt;code&gt;allocate&lt;/code&gt; 하기 위해 전달합니다 . 그렇지 않으면, 전체 정렬을 시도한 다음 적절한 정렬을 위해 결과를 조정합니다. 최악의 경우 여유 메모리는 두 블록 정도입니다.</target>
        </trans-unit>
        <trans-unit id="333f797e4d1750e2dc2dd943bcec484cf81e4464" translate="yes" xml:space="preserve">
          <source>Allocates a multidimensional array of elements of type T.</source>
          <target state="translated">유형 T의 요소의 다차원 배열을 할당합니다.</target>
        </trans-unit>
        <trans-unit id="2ef2526b1e1b8c72e2349064073c5f4e36bc9e05" translate="yes" xml:space="preserve">
          <source>Allocates a new array which is identical to &lt;code&gt;s&lt;/code&gt; except that all of its characters are converted to uppercase (by preforming Unicode uppercase mapping). If none of &lt;code&gt;s&lt;/code&gt; characters were affected, then &lt;code&gt;s&lt;/code&gt; itself is returned if &lt;code&gt;s&lt;/code&gt; is a &lt;code&gt;string&lt;/code&gt;-like type.</source>
          <target state="translated">유니 코드 대문자 매핑을 수행하여 모든 문자가 대문자로 변환된다는 점을 제외하고 &lt;code&gt;s&lt;/code&gt; 와 동일한 새 배열을 할당합니다 . 아무도 경우 &lt;code&gt;s&lt;/code&gt; 문자가 영향을받지 된 후 &lt;code&gt;s&lt;/code&gt; 의 경우 그 자체가 반환 &lt;code&gt;s&lt;/code&gt; A는 &lt;code&gt;string&lt;/code&gt; 유형 -like가.</target>
        </trans-unit>
        <trans-unit id="a5aaa9a811057230aa95580332ee9fece9148d7e" translate="yes" xml:space="preserve">
          <source>Allocates all memory available to this allocator. If the allocator is empty, returns the entire available block of memory. Otherwise, it still performs a best-effort allocation: if there is no fragmentation (e.g. &lt;code&gt;allocate&lt;/code&gt; has been used but not &lt;code&gt;deallocate&lt;/code&gt;), allocates and returns the only available block of memory.</source>
          <target state="translated">이 할당 자에 사용 가능한 모든 메모리를 할당합니다. 할당자가 비어 있으면 사용 가능한 전체 메모리 블록을 반환합니다. 그렇지 않으면 여전히 최선의 할당을 수행합니다. 조각 화가 없는 경우 (예 : &lt;code&gt;allocate&lt;/code&gt; 이 사용되었지만 &lt;code&gt;deallocate&lt;/code&gt; 되지 않은 경우) 사용 가능한 유일한 메모리 블록을 할당하고 반환합니다.</target>
        </trans-unit>
        <trans-unit id="affe2fcdb8093269677afa8f01518ff0ce594273" translate="yes" xml:space="preserve">
          <source>Allocates all memory available with this allocator.</source>
          <target state="translated">이 할당기로 사용 가능한 모든 메모리를 할당합니다.</target>
        </trans-unit>
        <trans-unit id="457c8670d7db9f415c2c631b04bc7df87f7a8ce8" translate="yes" xml:space="preserve">
          <source>Allocates an array and initializes it with copies of the elements of range &lt;code&gt;r&lt;/code&gt;.</source>
          <target state="translated">배열을 할당하고 범위 &lt;code&gt;r&lt;/code&gt; 의 요소의 복사본으로 배열을 초기화합니다 .</target>
        </trans-unit>
        <trans-unit id="e31ee88595be1a4376af43d499352d1f95ed61d8" translate="yes" xml:space="preserve">
          <source>Allocates and returns all memory available to this allocator. Implementations that do not support this primitive should always return &lt;code&gt;null&lt;/code&gt;.</source>
          <target state="translated">이 할당 자에 사용 가능한 모든 메모리를 할당하고 반환합니다. 이 프리미티브를 지원하지 않는 구현은 항상 &lt;code&gt;null&lt;/code&gt; 을 리턴해야합니다 .</target>
        </trans-unit>
        <trans-unit id="1a3681eb538dd63a79378153545a077147ef7123" translate="yes" xml:space="preserve">
          <source>Allocates and returns all memory available to this region.</source>
          <target state="translated">이 지역에서 사용 가능한 모든 메모리를 할당하고 반환합니다.</target>
        </trans-unit>
        <trans-unit id="2b750fd7da093b1e747e05812152ef8c3fccbd77" translate="yes" xml:space="preserve">
          <source>Allocates in coarse-grained quantas, thus improving performance of reallocations by often reallocating in place. The drawback is higher memory consumption because of allocated and unused memory.</source>
          <target state="translated">굵은 쿼터에 할당되므로 종종 재 할당하여 재 할당 성능이 향상됩니다. 단점은 할당 및 사용되지 않는 메모리로 인해 메모리 소비가 더 높습니다.</target>
        </trans-unit>
        <trans-unit id="70331dfb1a6e6d60011fcc4d4e71ab51d10775b6" translate="yes" xml:space="preserve">
          <source>Allocates memory either off of the free list or from the parent allocator. If &lt;code&gt;n&lt;/code&gt; is within &lt;code&gt;[min, max]&lt;/code&gt; or if the free list is unchecked (&lt;code&gt;minSize == 0 &amp;amp;&amp;amp; maxSize == size_t.max&lt;/code&gt;), then the free list is consulted first. If not empty (hit), the block at the front of the free list is removed from the list and returned. Otherwise (miss), a new block of &lt;code&gt;max&lt;/code&gt; bytes is allocated, truncated to &lt;code&gt;n&lt;/code&gt; bytes, and returned.</source>
          <target state="translated">사용 가능 목록에서 또는 상위 할당 자로부터 메모리를 할당합니다. 경우 &lt;code&gt;n&lt;/code&gt; 은 조건 &lt;code&gt;[min, max]&lt;/code&gt; 또는 프리리스트가 선택하지 않은 경우 ( &lt;code&gt;minSize == 0 &amp;amp;&amp;amp; maxSize == size_t.max&lt;/code&gt; 예), 프리리스트가 먼저 협의된다. 비어 있지 않으면 (히트) 비어있는 목록의 앞에있는 블록이 목록에서 제거되어 리턴됩니다. 그렇지 않으면 (miss), &lt;code&gt;max&lt;/code&gt; 바이트 의 새 블록 이 할당되고 &lt;code&gt;n&lt;/code&gt; 바이트로 잘린 다음 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="22f9e74278651d99027c27c713ac855e8ed1e715" translate="yes" xml:space="preserve">
          <source>Allocates memory trying the primary allocator first. If it returns &lt;code&gt; null&lt;/code&gt;, the fallback allocator is tried.</source>
          <target state="translated">1 차 할당자를 먼저 시도하여 메모리를 할당합니다. &lt;code&gt; null&lt;/code&gt; 을 반환 하면 대체 할당자가 시도됩니다.</target>
        </trans-unit>
        <trans-unit id="b925b0b6c371d9f54077bbba76c9a1da1602d6a9" translate="yes" xml:space="preserve">
          <source>Allocates memory. For management it actually allocates extra memory from the parent.</source>
          <target state="translated">메모리를 할당합니다. 관리를 위해 실제로 부모로부터 추가 메모리를 할당합니다.</target>
        </trans-unit>
        <trans-unit id="575ca88081327e09f680960a4110bc8ba17a9371" translate="yes" xml:space="preserve">
          <source>Allocates memory; use &lt;a href=&quot;#lineSplitter&quot;&gt;&lt;code&gt;lineSplitter&lt;/code&gt;&lt;/a&gt; for an alternative that does not.</source>
          <target state="translated">메모리를 할당합니다. 그렇지 않은 대안 에는 &lt;a href=&quot;#lineSplitter&quot;&gt; &lt;code&gt;lineSplitter&lt;/code&gt; &lt;/a&gt; 를 사용 하십시오 .</target>
        </trans-unit>
        <trans-unit id="ee6c6f7e81d98e5543bf32244a9bf50d0d1defcc" translate="yes" xml:space="preserve">
          <source>Allocates s bytes of memory and returns it, or &lt;code&gt;null&lt;/code&gt; if memory could not be allocated. &lt;code&gt;allocateFresh&lt;/code&gt; behaves just like allocate, the only difference being that this always returns unused(fresh) memory. Although there may still be available space in the &lt;code&gt;BitmappedBlock&lt;/code&gt;, &lt;code&gt;allocateFresh&lt;/code&gt; could still return null, because all the available blocks have been previously deallocated.</source>
          <target state="translated">s 바이트의 메모리를 할당하고 반환하거나 메모리를 할당 할 수 없으면 &lt;code&gt;null&lt;/code&gt; 을 반환합니다 . &lt;code&gt;allocateFresh&lt;/code&gt; 는 유일한 차이점이 항상 사용되지 않는 (신선한) 메모리를 반환되고, 단지 할당처럼 동작합니다. 여전히에서 사용할 수있는 공간이 될 수 있지만 &lt;code&gt;BitmappedBlock&lt;/code&gt; , &lt;code&gt;allocateFresh&lt;/code&gt; 는 사용 가능한 모든 블록이 이전에 해제 되었기 때문에 아직, 널 (null)을 반환 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="40d52c59404ae014d74089cf6166317c2d5cca72" translate="yes" xml:space="preserve">
          <source>Allocates s bytes of memory and returns it, or &lt;code&gt;null&lt;/code&gt; if memory could not be allocated. &lt;code&gt;allocateFresh&lt;/code&gt; behaves just like allocate, the only difference being that this always returns unused(fresh) memory. Although there may still be available space in the &lt;code&gt;SharedBitmappedBlock&lt;/code&gt;, &lt;code&gt;allocateFresh&lt;/code&gt; could still return null, because all the available blocks have been previously deallocated.</source>
          <target state="translated">s 바이트의 메모리를 할당하여 반환하거나 메모리를 할당 할 수없는 경우 &lt;code&gt;null&lt;/code&gt; 을 반환합니다 . &lt;code&gt;allocateFresh&lt;/code&gt; 는 유일한 차이점이 항상 사용되지 않는 (신선한) 메모리를 반환되고, 단지 할당처럼 동작합니다. 여전히에서 사용할 수있는 공간이 될 수 있지만 &lt;code&gt;SharedBitmappedBlock&lt;/code&gt; , &lt;code&gt;allocateFresh&lt;/code&gt; 는 사용 가능한 모든 블록이 이전에 해제 되었기 때문에 아직, 널 (null)을 반환 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="34562b2c1efcd9772eb4d939efa35b8757f6170e" translate="yes" xml:space="preserve">
          <source>Allocates the requested &lt;code&gt;bytes&lt;/code&gt; of memory with specified &lt;code&gt;alignment&lt;/code&gt;. Directs the call to either one of the &lt;code&gt;buckets&lt;/code&gt; allocators. Defined only if &lt;code&gt;Allocator&lt;/code&gt; defines &lt;code&gt;alignedAllocate&lt;/code&gt;.</source>
          <target state="translated">지정된 &lt;code&gt;alignment&lt;/code&gt; 로 요청 된 메모리 &lt;code&gt;bytes&lt;/code&gt; 를 할당합니다 . &lt;code&gt;buckets&lt;/code&gt; 할당 자 중 하나에 통화를 보냅니다. &lt;code&gt;Allocator&lt;/code&gt; 가 &lt;code&gt;alignedAllocate&lt;/code&gt; 정의한 경우에만 정의됩니다 .</target>
        </trans-unit>
        <trans-unit id="fc90ab9b460af01883735fa719d7075b6f64fedd" translate="yes" xml:space="preserve">
          <source>Allocating memory for sharing across threads</source>
          <target state="translated">스레드 간 공유를위한 메모리 할당</target>
        </trans-unit>
        <trans-unit id="a1483392946af2634ec9da37d8a5eacfc7465700" translate="yes" xml:space="preserve">
          <source>Allocation requests are handled on a first-fit basis. Although linear in complexity, allocation is in practice fast because of the compact bookkeeping representation, use of simple and fast bitwise routines, and caching of the first available block position. A known issue with this general approach is fragmentation, partially mitigated by coalescing. Since &lt;code&gt;BitmappedBlock&lt;/code&gt; does not need to maintain the allocated size, freeing memory implicitly coalesces free blocks together. Also, tuning &lt;code&gt;blockSize&lt;/code&gt; has a considerable impact on both internal and external fragmentation.</source>
          <target state="translated">할당 요청은 우선적으로 처리됩니다. 복잡성은 선형 적이지만, 간결한 부기 표시, 단순하고 빠른 비트 단위 사용 및 사용 가능한 첫 번째 블록 위치 캐싱으로 인해 할당이 실제로 빠릅니다. 이 일반적인 접근 방식의 알려진 문제는 통합으로 부분적으로 완화되는 조각화입니다. 이후 &lt;code&gt;BitmappedBlock&lt;/code&gt; 가 할당 된 크기를 유지하지 않아도, 자유롭게 메모리는 암시 적으로 함께 무료로 블록을 합체. 또한, &lt;code&gt;blockSize&lt;/code&gt; 조정 은 내부 및 외부 조각화에 상당한 영향을 미칩니다.</target>
        </trans-unit>
        <trans-unit id="cbc962bc5b83a88a16f2713a98847658123e8258" translate="yes" xml:space="preserve">
          <source>Allocation requests first search the tree for a buffer of suitable size deallocated in the past. If a match is found, the node is removed from the tree and the memory is returned. Otherwise, the allocation is directed to &lt;code&gt;ParentAllocator&lt;/code&gt;. If at this point &lt;code&gt;ParentAllocator&lt;/code&gt; also fails to allocate, &lt;code&gt;FreeTree&lt;/code&gt; frees everything and then tries the parent allocator again.</source>
          <target state="translated">할당 요청은 먼저 트리에서 과거에 할당 해제 된 적절한 크기의 버퍼를 검색합니다. 일치하는 것이 있으면 노드가 트리에서 제거되고 메모리가 반환됩니다. 그렇지 않으면 할당이 &lt;code&gt;ParentAllocator&lt;/code&gt; 로 전달 됩니다. 이 시점에서 &lt;code&gt;ParentAllocator&lt;/code&gt; 도 할당에 실패하면 &lt;code&gt;FreeTree&lt;/code&gt; 는 모든 항목을 해제 한 다음 상위 할당자를 다시 시도합니다.</target>
        </trans-unit>
        <trans-unit id="af0e205e8505bb23310602de5dd4be9af5c6a6d9" translate="yes" xml:space="preserve">
          <source>Allocation-related flags dictated by type characteristics. &lt;code&gt;TypedAllocator&lt;/code&gt; deduces these flags from the type being allocated and uses the appropriate allocator accordingly.</source>
          <target state="translated">유형 특성에 의해 지정된 할당 관련 플래그. &lt;code&gt;TypedAllocator&lt;/code&gt; 는 할당되는 유형에서 이러한 플래그를 추론하고 그에 따라 적절한 할당자를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="fdc44965c2d6c8c8d7c21352e9d968a0c8014291" translate="yes" xml:space="preserve">
          <source>Allocations for sizes smaller than &lt;code&gt;min&lt;/code&gt; or larger than &lt;code&gt;max&lt;/code&gt; are illegal for &lt;code&gt;Bucketizer&lt;/code&gt;. To handle them separately, &lt;code&gt;Segregator&lt;/code&gt; may be of use.</source>
          <target state="translated">보다 작은 크기에 대한 할당 &lt;code&gt;min&lt;/code&gt; 이상 또는 더 큰 &lt;code&gt;max&lt;/code&gt; 불법입니다 &lt;code&gt;Bucketizer&lt;/code&gt; . 별도로 처리하기 위해 &lt;code&gt;Segregator&lt;/code&gt; 를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="cbf9e75065cafb419b19fb5a13dddefb2735eaa6" translate="yes" xml:space="preserve">
          <source>Allocator</source>
          <target state="translated">Allocator</target>
        </trans-unit>
        <trans-unit id="e08b1899abf4a5d12c1969cc846a1ce148364a1f" translate="yes" xml:space="preserve">
          <source>Allocator (currently defined only for Posix and Windows) using &lt;code&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Mmap&quot;&gt;mmap&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;https://google.com/search?btnI=I%27m+Feeling+Lucky&amp;amp;ie=UTF-8&amp;amp;oe=UTF-8&amp;amp;q=munmap&quot;&gt;munmap&lt;/a&gt;&lt;/code&gt; directly (or their Windows equivalents). There is no additional structure: each call to &lt;code&gt;allocate(s)&lt;/code&gt; issues a call to &lt;code&gt;mmap(null, s, PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS, -1, 0)&lt;/code&gt;, and each call to &lt;code&gt;deallocate(b)&lt;/code&gt; issues &lt;code&gt;munmap(b.ptr, b.length)&lt;/code&gt;. So &lt;code&gt;MmapAllocator&lt;/code&gt; is usually intended for allocating large chunks to be managed by fine-granular allocators.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Mmap&quot;&gt;mmap&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;https://google.com/search?btnI=I%27m+Feeling+Lucky&amp;amp;ie=UTF-8&amp;amp;oe=UTF-8&amp;amp;q=munmap&quot;&gt;munmap&lt;/a&gt;&lt;/code&gt; 을 직접 사용하는 Allocator (현재 Posix 및 Windows에만 정의 됨 ) 추가 구조가 없습니다 : 각 호출에 &lt;code&gt;allocate(s)&lt;/code&gt; 문제에 대한 호출 &lt;code&gt;mmap(null, s, PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS, -1, 0)&lt;/code&gt; , 및 호출 할 때마다 &lt;code&gt;deallocate(b)&lt;/code&gt; 문제 &lt;code&gt;munmap(b.ptr, b.length)&lt;/code&gt; . 길이 ) . 따라서 &lt;code&gt;MmapAllocator&lt;/code&gt; 는 일반적으로 세분화 된 할당자가 큰 청크를 할당하도록 설계되었습니다.</target>
        </trans-unit>
        <trans-unit id="3353234ce0124f8910aaa38caffee20b71a4f80f" translate="yes" xml:space="preserve">
          <source>Allocator &lt;code&gt;alloc&lt;/code&gt;</source>
          <target state="translated">할당 자 &lt;code&gt;alloc&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="f1e6a4ec6000f9e0b7f661da3b6a91cb8ae29132" translate="yes" xml:space="preserve">
          <source>Allocator &lt;strong id=&quot;_parent&quot;&gt;_parent&lt;/strong&gt;;</source>
          <target state="translated">할당 자 &lt;strong id=&quot;_parent&quot;&gt;_parent&lt;/strong&gt; ;</target>
        </trans-unit>
        <trans-unit id="d69c3c0130d6d25953b8d2d9b80b986133e83dd0" translate="yes" xml:space="preserve">
          <source>Allocator &lt;strong id=&quot;parent&quot;&gt;parent&lt;/strong&gt;;</source>
          <target state="translated">할당 자 &lt;strong id=&quot;parent&quot;&gt;부모&lt;/strong&gt; ;</target>
        </trans-unit>
        <trans-unit id="cadfd13af30b7dd1dff50bada6dc1d562f201deb" translate="yes" xml:space="preserve">
          <source>Allocator API.</source>
          <target state="translated">할당 자 API.</target>
        </trans-unit>
        <trans-unit id="675049c41d27d311eac5a89bd2e072dfd75d4167" translate="yes" xml:space="preserve">
          <source>Allocator backed by &lt;code&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Sbrk&quot;&gt;sbrk&lt;/a&gt;&lt;/code&gt; for Posix systems. Due to the fact that &lt;code&gt;sbrk&lt;/code&gt; is not thread-safe &lt;a href=&quot;http://lifecs.likai.org/2010/02/sbrk-is-not-thread-safe.html&quot;&gt;by design&lt;/a&gt;, &lt;code&gt;SbrkRegion&lt;/code&gt; uses a mutex internally. This implies that uncontrolled calls to &lt;code&gt;brk&lt;/code&gt; and &lt;code&gt;sbrk&lt;/code&gt; may affect the workings of &lt;code&gt;SbrkRegion&lt;/code&gt; adversely.</source>
          <target state="translated">Posix 시스템 용 &lt;code&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Sbrk&quot;&gt;sbrk&lt;/a&gt;&lt;/code&gt; 가 지원하는 할당 자 . 때문에 사실 &lt;code&gt;sbrk&lt;/code&gt; 스레드 안전하지 않습니다 &lt;a href=&quot;http://lifecs.likai.org/2010/02/sbrk-is-not-thread-safe.html&quot;&gt;설계에 의해&lt;/a&gt; , &lt;code&gt;SbrkRegion&lt;/code&gt; 는 내부적으로 뮤텍스를 사용합니다. 이는 &lt;code&gt;brk&lt;/code&gt; 및 &lt;code&gt;sbrk&lt;/code&gt; 에 대한 제어되지 않은 호출 이 &lt;code&gt;SbrkRegion&lt;/code&gt; 의 작동에 악영향을 줄 수 있음을 의미합니다 .</target>
        </trans-unit>
        <trans-unit id="513b82ce13f2dc2be45bd311fabfc658467c99b2" translate="yes" xml:space="preserve">
          <source>Allocator primitives.</source>
          <target state="translated">할당 자 프리미티브.</target>
        </trans-unit>
        <trans-unit id="68a0d53209b9f9a4b14c3a76e7ad158b2dca28b9" translate="yes" xml:space="preserve">
          <source>Allocator similar to &lt;code&gt;FreeList&lt;/code&gt; that uses a binary search tree to adaptively store not one, but many free lists.</source>
          <target state="translated">바이너리 검색 트리를 사용하여 하나가 아니라 많은 무료 목록을 적응 적으로 저장하는 &lt;code&gt;FreeList&lt;/code&gt; 와 비슷한 할당 자 .</target>
        </trans-unit>
        <trans-unit id="d0cc49cc2f10e3277f742185d09b671e886851a2" translate="yes" xml:space="preserve">
          <source>Allocator that adds some extra data before (of type &lt;code&gt;Prefix&lt;/code&gt;) and/or after (of type &lt;code&gt;Suffix&lt;/code&gt;) any allocation made with its parent allocator. This is useful for uses where additional allocation-related information is needed, such as mutexes, reference counts, or walls for debugging memory corruption errors.</source>
          <target state="translated">부모 할당 자에 의해 할당 된 할당 이전 ( &lt;code&gt;Prefix&lt;/code&gt; 유형 ) 및 / 또는 후에 ( &lt;code&gt;Suffix&lt;/code&gt; 유형) 추가 데이터를 추가 하는 할당 자. 이는 뮤텍스, 참조 횟수 또는 메모리 손상 오류 디버깅을위한 월과 같은 추가 할당 관련 정보가 필요한 경우에 유용합니다.</target>
        </trans-unit>
        <trans-unit id="506fd6ecc5980e2993d9b94a51762bcf43b76fb6" translate="yes" xml:space="preserve">
          <source>Allocator that allows and manages allocating extra prefix and/or a suffix bytes for each block allocated.</source>
          <target state="translated">할당 된 각 블록에 대한 추가 접두사 및 / 또는 접미사 바이트 할당을 허용하고 관리하는 할당 자.</target>
        </trans-unit>
        <trans-unit id="bfd65030e4aadae8e36c3b33912522b7bfee3263" translate="yes" xml:space="preserve">
          <source>Allocator that collects extra data about allocations. Since each piece of information adds size and time overhead, statistics can be individually enabled or disabled through compile-time &lt;code&gt;flags&lt;/code&gt;.</source>
          <target state="translated">할당에 대한 추가 데이터를 수집하는 할당 자. 각 정보는 크기와 시간 오버 헤드를 추가하므로 컴파일 타임 &lt;code&gt;flags&lt;/code&gt; 통해 통계를 개별적으로 활성화하거나 비활성화 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="bc0af3b6f564e9ca229952d612a3550f66061e3a" translate="yes" xml:space="preserve">
          <source>Allocator that collects useful statistics about allocations, both global and per calling point. The statistics collected can be configured statically by choosing combinations of &lt;code&gt;Options&lt;/code&gt; appropriately.</source>
          <target state="translated">전역 및 호출 지점 당 할당에 대한 유용한 통계를 수집하는 할당 자. &lt;code&gt;Options&lt;/code&gt; 조합을 적절히 선택하여 수집 된 통계를 정적으로 구성 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="14e1947892b24d554e92c80dc9a3054c6f2dbace" translate="yes" xml:space="preserve">
          <source>Allocator that combines two other allocators - primary and fallback. Allocation requests are first tried with primary, and upon failure are passed to the fallback. Useful for small and fast allocators fronting general-purpose ones.</source>
          <target state="translated">두 개의 다른 할당 자 (1 차 및 폴백)를 결합한 할당 자. 할당 요청은 1 차로 먼저 시도되고 실패시 폴백으로 전달됩니다. 범용 할당기를 앞지르는 작고 빠른 할당 자에 유용합니다.</target>
        </trans-unit>
        <trans-unit id="82ae157e1fe07caf7d37c5484581461f1d9f6744" translate="yes" xml:space="preserve">
          <source>Allocator that implements a &lt;a href=&quot;http://wikipedia.org/wiki/Free_list&quot;&gt;free list&lt;/a&gt; on top of any other allocator. The preferred size, tolerance, and maximum elements are configurable at compile- and run time.</source>
          <target state="translated">다른 할당 자 위에 사용 &lt;a href=&quot;http://wikipedia.org/wiki/Free_list&quot;&gt;가능한 목록&lt;/a&gt; 을 구현하는 할당 자. 기본 크기, 공차 및 최대 요소는 컴파일 및 런타임에 구성 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="92d633faca70f593d2eefae1500ce778644a707a" translate="yes" xml:space="preserve">
          <source>Allocator that uses stack allocation for up to &lt;code&gt;stackSize&lt;/code&gt; bytes and then falls back to &lt;code&gt;Allocator&lt;/code&gt;. Defined as:</source>
          <target state="translated">최대 &lt;code&gt;stackSize&lt;/code&gt; 바이트 까지 스택 할당을 사용한 할당 자는 &lt;code&gt;Allocator&lt;/code&gt; 로 폴백 합니다. 로써 정의 된:</target>
        </trans-unit>
        <trans-unit id="277f2e388687399a48875d2b4c26cd068e3208fa" translate="yes" xml:space="preserve">
          <source>Allocator used for storing bookkeeping data. The size of bookkeeping data is proportional to the number of allocators. If &lt;code&gt;BookkeepingAllocator&lt;/code&gt; is &lt;code&gt;NullAllocator&lt;/code&gt;, then &lt;code&gt;AllocatorList&lt;/code&gt; is &quot;ouroboros-style&quot;, i.e. it keeps the bookkeeping data in memory obtained from the allocators themselves. Note that for ouroboros-style management, the size &lt;code&gt;n&lt;/code&gt; passed to &lt;code&gt;make&lt;/code&gt; will be occasionally different from the size requested by client code.</source>
          <target state="translated">부기 데이터를 저장하는 데 사용되는 할당 기. 부기 데이터의 크기는 할당 자의 수에 비례합니다. 경우 &lt;code&gt;BookkeepingAllocator&lt;/code&gt; 가 있다 &lt;code&gt;NullAllocator&lt;/code&gt; , 다음 &lt;code&gt;AllocatorList&lt;/code&gt; 는 그것이 할당 자 자체에서 얻은 메모리에 부기 데이터를 유지 즉, &quot;우로 보로스 스타일&quot;입니다. ouroboros 스타일 관리의 경우, 전달하기 &lt;code&gt;make&lt;/code&gt; 전달 된 &lt;code&gt;n&lt;/code&gt; 의 크기 는 때때로 클라이언트 코드가 요청한 크기와 다릅니다.</target>
        </trans-unit>
        <trans-unit id="08bb4c3deb9ae5f24662a76a349c8811c202d3b8" translate="yes" xml:space="preserve">
          <source>Allocator using &lt;code&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Mmap&quot;&gt;mmap&lt;/a&gt;&lt;/code&gt; directly.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Mmap&quot;&gt;mmap&lt;/a&gt;&lt;/code&gt; 을 직접 사용하는 할당 자 .</target>
        </trans-unit>
        <trans-unit id="c8e7b4b37828838d0088cc341f2bd349bdd2e0c6" translate="yes" xml:space="preserve">
          <source>Allocator[(max + 1 - min) / step] &lt;strong id=&quot;buckets&quot;&gt;buckets&lt;/strong&gt;;</source>
          <target state="translated">할당 자 [(max + 1-min) / step] &lt;strong id=&quot;buckets&quot;&gt;버킷&lt;/strong&gt; ;</target>
        </trans-unit>
        <trans-unit id="244757ffcceddee2188dcae6f52360122e5f32b2" translate="yes" xml:space="preserve">
          <source>Allocators are classes that define memory models to be used by some parts of the C++ Standard Library, and most specifically, by STL containers.</source>
          <target state="translated">할당자는 C ++ 표준 라이브러리의 일부, 특히 STL 컨테이너에서 사용할 메모리 모델을 정의하는 클래스입니다.</target>
        </trans-unit>
        <trans-unit id="cfd42e2cc807e85fba40b31455784b7f9341316f" translate="yes" xml:space="preserve">
          <source>Allocators assembled from the heap building blocks don't need to go through &lt;code&gt;IAllocator&lt;/code&gt; to be usable. They have the same primitives as &lt;code&gt;IAllocator&lt;/code&gt; and they work with &lt;a href=&quot;#make&quot;&gt;&lt;code&gt;make&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#makeArray&quot;&gt;&lt;code&gt;makeArray&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#dispose&quot;&gt;&lt;code&gt;dispose&lt;/code&gt;&lt;/a&gt; etc. So it suffice to create allocator objects wherever fit and use them appropriately:</source>
          <target state="translated">힙 빌딩 블록에서 조립 된 할당 &lt;code&gt;IAllocator&lt;/code&gt; 하기 위해 IAllocator 를 거치지 않아도됩니다 . 그것들은 &lt;code&gt;IAllocator&lt;/code&gt; 와 동일한 프리미티브를 가지고 있으며 &lt;a href=&quot;#make&quot;&gt; &lt;code&gt;make&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#makeArray&quot;&gt; &lt;code&gt;makeArray&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#dispose&quot;&gt; &lt;code&gt;dispose&lt;/code&gt; &lt;/a&gt; 등과 함께 작동합니다 . 따라서 할당 자 객체를 어디에나 만들고 적절하게 사용하는 것으로 충분합니다.</target>
        </trans-unit>
        <trans-unit id="b1a8b8369433cbedfb9cf80b63c1ab01ecb08d5f" translate="yes" xml:space="preserve">
          <source>Allocators customarily allocate memory in discretely-sized chunks. Therefore, a request for &lt;code&gt;n&lt;/code&gt; bytes may result in a larger allocation. The extra memory allocated goes unused and adds to the so-called &lt;a href=&quot;http://goo.gl/YoKffF&quot;&gt;internal fragmentation&lt;/a&gt;. The function &lt;code&gt;goodAllocSize(n)&lt;/code&gt; returns the actual number of bytes that would be allocated upon a request for &lt;code&gt;n&lt;/code&gt; bytes. This module defines a default implementation that returns &lt;code&gt;n&lt;/code&gt; rounded up to a multiple of the allocator's alignment.</source>
          <target state="translated">할당 자들은 관례 적으로 이산적인 크기의 청크로 메모리를 할당합니다. 따라서 &lt;code&gt;n&lt;/code&gt; 바이트에 대한 요청 은 더 큰 할당을 초래할 수 있습니다. 할당 된 추가 메모리는 사용되지 않고 소위 &lt;a href=&quot;http://goo.gl/YoKffF&quot;&gt;내부 조각화에&lt;/a&gt; 추가됩니다 . 함수 &lt;code&gt;goodAllocSize(n)&lt;/code&gt; 위한 요청에 따라 할당 될 것이다 실제 바이트 수 리턴 &lt;code&gt;n&lt;/code&gt; 바이트. 이 모듈은 &lt;code&gt;n&lt;/code&gt; 을 할당 자 정렬의 배수로 올림하여 반환하는 기본 구현을 정의합니다 .</target>
        </trans-unit>
        <trans-unit id="a6e1e46c405b75de5b94f462defa6a8af94b5d44" translate="yes" xml:space="preserve">
          <source>Allow Duration to be used as a boolean.</source>
          <target state="translated">기간을 부울로 사용하도록 허용하십시오.</target>
        </trans-unit>
        <trans-unit id="adac40bfba505bd009304b9376798311375e4e91" translate="yes" xml:space="preserve">
          <source>Allow local reuse of address</source>
          <target state="translated">주소의 로컬 재사용 허용</target>
        </trans-unit>
        <trans-unit id="8b6333bf17facce373203c2555dce16e5a1895fb" translate="yes" xml:space="preserve">
          <source>Allow the last slide to have fewer elements than windowSize</source>
          <target state="translated">마지막 슬라이드가 windowSize보다 적은 요소를 갖도록 허용</target>
        </trans-unit>
        <trans-unit id="6ed1bcaf99a3846f70cbca3700192d6c980d8840" translate="yes" xml:space="preserve">
          <source>Allow transmission of broadcast messages</source>
          <target state="translated">브로드 캐스트 메시지 전송 허용</target>
        </trans-unit>
        <trans-unit id="d8fa57446bade27e54bc705df143acdcdd3b1802" translate="yes" xml:space="preserve">
          <source>AllowDayOverflow &lt;code&gt;allowOverflow&lt;/code&gt;</source>
          <target state="translated">AllowDayOverflow &lt;code&gt;allowOverflow&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="64679db98864f0cda1e9bac90e046d01f23a860d" translate="yes" xml:space="preserve">
          <source>AllowDayOverflow only applies to calculations involving months or years.</source>
          <target state="translated">AllowDayOverflow는 몇 개월 또는 몇 년이 포함 된 계산에만 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="25c6d16035cd63a1ba2d0337d85f0862317f57db" translate="yes" xml:space="preserve">
          <source>Allows &lt;code&gt;alias&lt;/code&gt;ing of any single symbol, type or compile-time expression.</source>
          <target state="translated">단일 심볼, 유형 또는 컴파일 타임 표현식의 &lt;code&gt;alias&lt;/code&gt; 허용합니다 .</target>
        </trans-unit>
        <trans-unit id="6f4acd20c1f1294f9371d9a6ba2cfbedb8612aac" translate="yes" xml:space="preserve">
          <source>Allows assignment from a subset algebraic type</source>
          <target state="translated">하위 집합 대수 유형에서 할당 가능</target>
        </trans-unit>
        <trans-unit id="d7cde2e0711d3681c464aaffee0a4276b1a5dd9a" translate="yes" xml:space="preserve">
          <source>Allows constructing a &lt;a href=&quot;#Duration&quot;&gt;&lt;code&gt;Duration&lt;/code&gt;&lt;/a&gt; from the given time units with the given length.</source>
          <target state="translated">구성 할 수 있도록 &lt;a href=&quot;#Duration&quot;&gt; &lt;code&gt;Duration&lt;/code&gt; &lt;/a&gt; 주어진 길이 주어진 시간 단위에서.</target>
        </trans-unit>
        <trans-unit id="ee70bbaa43d45797f5f446c5970672b1c530f1ac" translate="yes" xml:space="preserve">
          <source>Allows creating bit fields inside structs and classes.</source>
          <target state="translated">구조체와 클래스 내에 비트 필드를 만들 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="64ee76f10cd6158b74b7abb63361a7dad9dbd646" translate="yes" xml:space="preserve">
          <source>Allows for custom number of worker threads.</source>
          <target state="translated">사용자 지정 작업자 스레드 수를 허용합니다.</target>
        </trans-unit>
        <trans-unit id="328393fd6489bef674280b2b2127dc7cc02ec9c0" translate="yes" xml:space="preserve">
          <source>Allows freely swapping of elements as long as the output satisfies the algorithm's requirements.</source>
          <target state="translated">출력이 알고리즘 요구 사항을 충족하는 한 요소를 자유롭게 교환 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9a9ded70476d5ecbed5df1b409fabc86f2220dab" translate="yes" xml:space="preserve">
          <source>Allows manipulating the fraction, exponent, and sign parts of a double separately. The definition is:</source>
          <target state="translated">double의 분수, 지수 및 부호 부분을 개별적으로 조작 할 수 있습니다. 정의는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="334b65d7fe406c8806cd27978db1e757401c70de" translate="yes" xml:space="preserve">
          <source>Allows manipulating the fraction, exponent, and sign parts of a float separately. The definition is:</source>
          <target state="translated">float의 분수, 지수 및 부호 부분을 개별적으로 조작 할 수 있습니다. 정의는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="25a3ad747e7b5e32b1dfdc83fe51e1af4607df0d" translate="yes" xml:space="preserve">
          <source>Allows safe construction of &lt;code&gt;Unique&lt;/code&gt;. It creates the resource and guarantees unique ownership of it (unless &lt;code&gt;T&lt;/code&gt; publishes aliases of &lt;code&gt;this&lt;/code&gt;).</source>
          <target state="translated">&lt;code&gt;Unique&lt;/code&gt; 의 안전한 구성을 허용합니다 . 자원을 작성하고 고유 한 소유권을 보장합니다 ( &lt;code&gt;T&lt;/code&gt; &lt;code&gt;this&lt;/code&gt; 별명을 공개 하지 않는 한 ).</target>
        </trans-unit>
        <trans-unit id="b188cff78ffe93b93118a9afb92a5b0ecf425233" translate="yes" xml:space="preserve">
          <source>Allows the storage of &lt;a href=&quot;https://en.wikipedia.org/wiki/IEEE_754-1985#Positive_and_negative_infinity&quot;&gt; IEEE754 infinity&lt;/a&gt; values.</source>
          <target state="translated">&lt;a href=&quot;https://en.wikipedia.org/wiki/IEEE_754-1985#Positive_and_negative_infinity&quot;&gt;IEEE754 무한대&lt;/a&gt; 값을 저장할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d3c7e91d01b82633b7ccef70ff930b3cba01954d" translate="yes" xml:space="preserve">
          <source>Allows the storage of &lt;a href=&quot;https://en.wikipedia.org/wiki/NaN&quot;&gt;IEEE754 Not a Number&lt;/a&gt; values.</source>
          <target state="translated">&lt;a href=&quot;https://en.wikipedia.org/wiki/NaN&quot;&gt;IEEE754 Not a Number&lt;/a&gt; 값을 저장할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="82e4b1439e8421bdc9916fd5cc4940cdec7c35ca" translate="yes" xml:space="preserve">
          <source>Allows user code to define custom floating-point formats. These formats are for storage only; all operations on them are performed by first implicitly extracting them to &lt;code&gt;real&lt;/code&gt; first. After the operation is completed the result can be stored in a custom floating-point value via assignment.</source>
          <target state="translated">사용자 코드가 사용자 정의 부동 소수점 형식을 정의 할 수 있도록합니다. 이 형식은 저장 전용입니다. 그들에 대한 모든 연산은 먼저 암묵적으로 &lt;code&gt;real&lt;/code&gt; 첫 번째로 추출하여 수행됩니다 . 작업이 완료된 후 할당을 통해 결과를 사용자 정의 부동 소수점 값으로 저장할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a707a85edc66a653109fa80da8910d24c0d7d6d7" translate="yes" xml:space="preserve">
          <source>Alphabetic</source>
          <target state="translated">Alphabetic</target>
        </trans-unit>
        <trans-unit id="c31b9723b74539a236469f5380dbe298e0356511" translate="yes" xml:space="preserve">
          <source>Alphabetic Presentation Forms</source>
          <target state="translated">알파벳 프리젠 테이션 양식</target>
        </trans-unit>
        <trans-unit id="a4f699c324e0e58a96d3bb16953095da737d92fc" translate="yes" xml:space="preserve">
          <source>Also known as trinary, trivalent, or trilean.</source>
          <target state="translated">3 원, 3가 또는 3 원이라고도합니다.</target>
        </trans-unit>
        <trans-unit id="3cb12cab0f941ad8314fbcab6c21fb7b159e66aa" translate="yes" xml:space="preserve">
          <source>Also note that while normally the &lt;code&gt;begin&lt;/code&gt; of an interval is included in it and its &lt;code&gt;end&lt;/code&gt; is excluded from it, if &lt;code&gt;dir == Direction.bwd&lt;/code&gt;, then &lt;code&gt;begin&lt;/code&gt; is treated as excluded and &lt;code&gt;end&lt;/code&gt; is treated as included. This allows for the same behavior in both directions. This works because none of &lt;a href=&quot;#Interval&quot;&gt;&lt;code&gt;Interval&lt;/code&gt;&lt;/a&gt;'s functions which care about whether &lt;code&gt;begin&lt;/code&gt; or &lt;code&gt;end&lt;/code&gt; is included or excluded are ever called by &lt;code&gt;IntervalRange&lt;/code&gt;. &lt;code&gt;interval&lt;/code&gt; returns a normal interval, regardless of whether &lt;code&gt;dir == Direction.fwd&lt;/code&gt; or if &lt;code&gt;dir == Direction.bwd&lt;/code&gt;, so any &lt;a href=&quot;#Interval&quot;&gt;&lt;code&gt;Interval&lt;/code&gt;&lt;/a&gt; functions which are called on it which care about whether &lt;code&gt;begin&lt;/code&gt; or &lt;code&gt;end&lt;/code&gt; are included or excluded will treat &lt;code&gt;begin&lt;/code&gt; as included and &lt;code&gt;end&lt;/code&gt; as excluded.</source>
          <target state="translated">또한 일반적으로 간격 의 &lt;code&gt;begin&lt;/code&gt; 이 간격에 포함되어 있고 &lt;code&gt;end&lt;/code&gt; 이 간격에서 제외되는 반면 &lt;code&gt;dir == Direction.bwd&lt;/code&gt; 이면 &lt;code&gt;begin&lt;/code&gt; 은 제외 된 것으로 처리되고 &lt;code&gt;end&lt;/code&gt; 는 포함 된 것으로 처리됩니다. 이를 통해 양방향에서 동일한 동작을 수행 할 수 있습니다. 이것은 &lt;code&gt;begin&lt;/code&gt; 또는 &lt;code&gt;end&lt;/code&gt; 가 포함 되는지 또는 제외 되는지를 고려하는 &lt;a href=&quot;#Interval&quot;&gt; &lt;code&gt;Interval&lt;/code&gt; &lt;/a&gt; 의 기능이 &lt;code&gt;IntervalRange&lt;/code&gt; 에 의해 호출 되지 않기 때문에 작동 합니다 . &lt;code&gt;interval&lt;/code&gt; 에 상관없이 반환 정상적인 간격 여부 &lt;code&gt;dir == Direction.fwd&lt;/code&gt; 경우 또는 &lt;code&gt;dir == Direction.bwd&lt;/code&gt; 어느 정도로 &lt;a href=&quot;#Interval&quot;&gt; &lt;code&gt;Interval&lt;/code&gt; &lt;/a&gt; &lt;code&gt;begin&lt;/code&gt; 또는 &lt;code&gt;end&lt;/code&gt; 가 포함 되는지 또는 제외 되는지를 고려하여 호출되는 함수는 &lt;code&gt;begin&lt;/code&gt; 을 포함 된 것으로 간주 하고 &lt;code&gt;end&lt;/code&gt; 것으로 종료 합니다.</target>
        </trans-unit>
        <trans-unit id="be0f9f39d5673fb5d350cd6b832b92db8b3eeda0" translate="yes" xml:space="preserve">
          <source>Also note that while normally the &lt;code&gt;end&lt;/code&gt; of an interval is excluded from it, &lt;code&gt;NegInfIntervalRange&lt;/code&gt; treats it as if it were included. This allows for the same behavior as with &lt;code&gt;PosInfIntervalRange&lt;/code&gt;. This works because none of &lt;code&gt;NegInfInterval&lt;/code&gt;'s functions which care about whether &lt;code&gt;end&lt;/code&gt; is included or excluded are ever called by &lt;code&gt;NegInfIntervalRange&lt;/code&gt;. &lt;code&gt;interval&lt;/code&gt; returns a normal interval, so any &lt;code&gt;NegInfInterval&lt;/code&gt; functions which are called on it which care about whether &lt;code&gt;end&lt;/code&gt; is included or excluded will treat &lt;code&gt;end&lt;/code&gt; as excluded.</source>
          <target state="translated">또한 일반적으로 간격 의 &lt;code&gt;end&lt;/code&gt; 은 간격에서 제외 &lt;code&gt;NegInfIntervalRange&lt;/code&gt; 는 간격이 포함 된 것처럼 처리합니다. 이것은 &lt;code&gt;PosInfIntervalRange&lt;/code&gt; 와 같은 동작을 허용합니다 . &lt;code&gt;end&lt;/code&gt; 가 포함 되는지 또는 제외 되는지를 신경 &lt;code&gt;NegInfInterval&lt;/code&gt; 의 함수 가 &lt;code&gt;NegInfIntervalRange&lt;/code&gt; 에 의해 호출 되지 않기 때문에 이것은 작동 합니다 . &lt;code&gt;interval&lt;/code&gt; 은 일반 간격을 반환하므로 &lt;code&gt;end&lt;/code&gt; 가 포함 되는지 또는 제외 되는지를 신경 &lt;code&gt;NegInfInterval&lt;/code&gt; 함수는 &lt;code&gt;end&lt;/code&gt; 를 제외 된 것으로 간주 합니다.</target>
        </trans-unit>
        <trans-unit id="238e333d78d3953efe21f4c8dee91a8052bf6044" translate="yes" xml:space="preserve">
          <source>Also please note, that no spaces are allowed within the string anywhere whether it's a leading, trailing, or embedded space(s), thus they too must be stripped from the string before using this function, or any of the conversion functions.</source>
          <target state="translated">또한 선행, 후행 또는 포함 된 공간에 관계없이 문자열 내에 공백이 허용되지 않으므로이 함수 또는 변환 함수를 사용하기 전에 문자열에서 공백을 제거해야합니다.</target>
        </trans-unit>
        <trans-unit id="19b283d04d340872863f50c8bc1177319aa2279b" translate="yes" xml:space="preserve">
          <source>Also see: &lt;code&gt;dmd.attrib.ForwardingAttribDeclaration&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;dmd.attrib.ForwardingAttribDeclaration&lt;/code&gt; 도 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="5ceee206f7bf1c9c9a3b0facedfafb260135ff34" translate="yes" xml:space="preserve">
          <source>Also, because no decoding occurs, it is possible to use this overload to translate ASCII characters within a proper UTF-8 string without altering the other, non-ASCII characters. It's replacing any code unit greater than &lt;code&gt;127&lt;/code&gt; with another code unit or replacing any code unit with another code unit greater than &lt;code&gt;127&lt;/code&gt; which will cause UTF validation issues.</source>
          <target state="translated">또한 디코딩이 발생하지 않으므로이 오버로드를 사용하여 ASCII 이외의 다른 문자를 변경하지 않고 적절한 UTF-8 문자열 내에서 ASCII 문자를 변환 할 수 있습니다. 그것은보다 코드 단위 이상을 교체하는 것 &lt;code&gt;127&lt;/code&gt; 다른 코드 단위 또는 아닌 다른 코드 단위의 더 큰 어떤 코드 장치를 교체 &lt;code&gt;127&lt;/code&gt; UTF 검증 문제가 발생할 것입니다.</target>
        </trans-unit>
        <trans-unit id="cd0ce1c13fb8625991e7b8d7c7f0d7c753bdcd89" translate="yes" xml:space="preserve">
          <source>Also, note that Phobos code assumes that the primitives &lt;code&gt;r.front&lt;/code&gt; and &lt;code&gt;r.empty&lt;/code&gt; are &amp;Omicron;(&lt;code&gt;1&lt;/code&gt;) time complexity wise or &quot;cheap&quot; in terms of running time. &amp;Omicron;() statements in the documentation of range functions are made with this assumption.</source>
          <target state="translated">또한 Phobos 코드는 프리미티브 &lt;code&gt;r.front&lt;/code&gt; 및 &lt;code&gt;r.empty&lt;/code&gt; 가 실행 시간 측면에서 현명하게 &quot;0 ( &lt;code&gt;1&lt;/code&gt; ) 시간 복잡성 또는&quot;싼 &quot; 것으로 가정합니다 . 범위 함수 문서의 &amp;Omicron; () 문은이 가정으로 작성됩니다.</target>
        </trans-unit>
        <trans-unit id="7575757c12c48b07e624443d696165742a7b14f4" translate="yes" xml:space="preserve">
          <source>Also, the IANA time zone database has a lot more time zones than Windows does.</source>
          <target state="translated">또한 IANA 시간대 데이터베이스에는 Windows보다 많은 시간대가 있습니다.</target>
        </trans-unit>
        <trans-unit id="4f85c414c696f8d88b637f2931596bd576a74dbf" translate="yes" xml:space="preserve">
          <source>Also, you may wish to utilize the &lt;code&gt;reserve&lt;/code&gt; function to pre-allocate array data to use with the append operator.</source>
          <target state="translated">또한 &lt;code&gt;reserve&lt;/code&gt; 함수를 사용하여 추가 연산자와 함께 사용할 배열 데이터를 사전 할당 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="87ea7db4a430030d90185495584807fc225cd906" translate="yes" xml:space="preserve">
          <source>Also:</source>
          <target state="translated">Also:</target>
        </trans-unit>
        <trans-unit id="c3cfd4ccb3c0f4865df49b814eab540d3553f2c1" translate="yes" xml:space="preserve">
          <source>Alternate name for &lt;a href=&quot;#Fields&quot;&gt;&lt;code&gt;Fields&lt;/code&gt;&lt;/a&gt;, kept for legacy compatibility.</source>
          <target state="translated">레거시 호환성을 위해 &lt;a href=&quot;#Fields&quot;&gt; &lt;code&gt;Fields&lt;/code&gt; &lt;/a&gt; 대체 이름입니다 .</target>
        </trans-unit>
        <trans-unit id="5d62f98b8f8caf5989633e5408f0d403968f08f9" translate="yes" xml:space="preserve">
          <source>Alternate name for &lt;a href=&quot;#ParameterDefaults&quot;&gt;&lt;code&gt;ParameterDefaults&lt;/code&gt;&lt;/a&gt;, kept for legacy compatibility.</source>
          <target state="translated">레거시 호환성을 위해 유지 되는 &lt;a href=&quot;#ParameterDefaults&quot;&gt; &lt;code&gt;ParameterDefaults&lt;/code&gt; 의&lt;/a&gt; 대체 이름입니다 .</target>
        </trans-unit>
        <trans-unit id="8c96b3e17073941a891d0a738663e82616b91e67" translate="yes" xml:space="preserve">
          <source>Alternate name for &lt;a href=&quot;#Parameters&quot;&gt;&lt;code&gt;Parameters&lt;/code&gt;&lt;/a&gt;, kept for legacy compatibility.</source>
          <target state="translated">레거시 호환성을 위해 유지 되는 &lt;a href=&quot;#Parameters&quot;&gt; &lt;code&gt;Parameters&lt;/code&gt; 의&lt;/a&gt; 대체 이름입니다 .</target>
        </trans-unit>
        <trans-unit id="d679f53e7924ba2aa8d486d630ba51ae1a168a21" translate="yes" xml:space="preserve">
          <source>Alternate name for &lt;a href=&quot;#isExpressions&quot;&gt;&lt;code&gt;isExpressions&lt;/code&gt;&lt;/a&gt;, kept for legacy compatibility.</source>
          <target state="translated">레거시 호환성을 위해 &lt;a href=&quot;#isExpressions&quot;&gt; &lt;code&gt;isExpressions&lt;/code&gt; 의&lt;/a&gt; 대체 이름입니다 .</target>
        </trans-unit>
        <trans-unit id="88e4f940df16ef30434b16d10b67a7bb93c43df0" translate="yes" xml:space="preserve">
          <source>Alternative sorting method that should be used when comparing keys involves an expensive computation. Instead of using &lt;code&gt;less(a, b)&lt;/code&gt; for comparing elements, &lt;code&gt;schwartzSort&lt;/code&gt; uses &lt;code&gt;less(transform(a), transform(b))&lt;/code&gt;. The values of the &lt;code&gt;transform&lt;/code&gt; function are precomputed in a temporary array, thus saving on repeatedly computing it. Conversely, if the cost of &lt;code&gt;transform&lt;/code&gt; is small compared to the cost of allocating and filling the precomputed array, &lt;code&gt;sort&lt;/code&gt; may be faster and therefore preferable.</source>
          <target state="translated">키를 비교할 때 사용해야하는 대체 정렬 방법에는 값 비싼 계산이 필요합니다. &lt;code&gt;schwartzSort&lt;/code&gt; 는 요소 비교에 &lt;code&gt;less(a, b)&lt;/code&gt; 를 사용하는 대신 &lt;code&gt;less(transform(a), transform(b))&lt;/code&gt; 합니다. &lt;code&gt;transform&lt;/code&gt; 함수 의 값은 임시 배열로 사전 계산되어 반복 계산을 줄입니다. 반대로, 사전 계산 된 어레이를 할당하고 채우는 비용에 비해 &lt;code&gt;transform&lt;/code&gt; 비용 이 작은 경우, &lt;code&gt;sort&lt;/code&gt; 이 더 빠를 수 있으므로 바람직하다.</target>
        </trans-unit>
        <trans-unit id="1b074433d0046e94a8541abc9c7fb27718d93f11" translate="yes" xml:space="preserve">
          <source>Alternatively, &lt;code&gt;values&lt;/code&gt; can be passed at compile-time, allowing for a more efficient search, but one that only supports matching on equality:</source>
          <target state="translated">또는 컴파일 타임에 &lt;code&gt;values&lt;/code&gt; 을 전달하여보다 효율적인 검색을 허용하지만 동일성에서만 일치하는 항목 만 지원합니다.</target>
        </trans-unit>
        <trans-unit id="c34214f7bf412f966f5ee7b7c1e43a0611031a85" translate="yes" xml:space="preserve">
          <source>Alternatively, inside the scope of an aggregate, only the member name is needed:</source>
          <target state="translated">또는 집계 범위 내에서 멤버 이름 만 필요합니다.</target>
        </trans-unit>
        <trans-unit id="5ab148c62e084629eaeb7919a9c875b4ac608894" translate="yes" xml:space="preserve">
          <source>Alternatively, instead of using a single &lt;code&gt;value&lt;/code&gt; to fill the &lt;code&gt;range&lt;/code&gt;, a &lt;code&gt;filter&lt;/code&gt;&lt;a href=&quot;std_range_primitives#isForwardRange&quot;&gt;forward range&lt;/a&gt; can be provided. The length of &lt;code&gt;filler&lt;/code&gt; and &lt;code&gt;range&lt;/code&gt; do not need to match, but &lt;code&gt;filler&lt;/code&gt; must not be empty.</source>
          <target state="translated">이와 달리, 대신하여 단일의 &lt;code&gt;value&lt;/code&gt; 채우는 &lt;code&gt;range&lt;/code&gt; 하는 &lt;code&gt;filter&lt;/code&gt; &lt;a href=&quot;std_range_primitives#isForwardRange&quot;&gt;전달 범위가&lt;/a&gt; 제공 될 수있다. &lt;code&gt;filler&lt;/code&gt; 의 길이 와 &lt;code&gt;range&lt;/code&gt; 는 일치하지 않아도되지만 &lt;code&gt;filler&lt;/code&gt; 는 비워 둘 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="188d34f7156185437a8f88ec534863d101dd6cd7" translate="yes" xml:space="preserve">
          <source>Alternatively, you can declare a single templated &lt;code&gt;opEquals&lt;/code&gt; function with an &lt;a href=&quot;template#auto-ref-parameters&quot;&gt;auto ref&lt;/a&gt; parameter:</source>
          <target state="translated">또는 &lt;a href=&quot;template#auto-ref-parameters&quot;&gt;auto ref&lt;/a&gt; 매개 변수를 사용하여 단일 템플릿 화 된 &lt;code&gt;opEquals&lt;/code&gt; 함수를 선언 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="4d49f83ba69fd5e0ed773bc16674431bab9674cc" translate="yes" xml:space="preserve">
          <source>Although &lt;code&gt;char[]&lt;/code&gt; and &lt;code&gt;wchar[]&lt;/code&gt; (as well as their qualified versions including &lt;code&gt;string&lt;/code&gt; and &lt;code&gt;wstring&lt;/code&gt;) are arrays, &lt;code&gt;isRandomAccessRange&lt;/code&gt; yields &lt;code&gt;false&lt;/code&gt; for them because they use variable-length encodings (UTF-8 and UTF-16 respectively). These types are bidirectional ranges only.</source>
          <target state="translated">비록 &lt;code&gt;char[]&lt;/code&gt; 및 &lt;code&gt;wchar[]&lt;/code&gt; (포함한 정규화 된 버전뿐만 아니라 &lt;code&gt;string&lt;/code&gt; 과 &lt;code&gt;wstring&lt;/code&gt; 의이 ) 배열이다 &lt;code&gt;isRandomAccessRange&lt;/code&gt; 는 산출 &lt;code&gt;false&lt;/code&gt; 들이 (각각 UTF-8 및 UTF-16), 가변 길이 인코딩을 사용하기 때문에 이들에 대한. 이 유형은 양방향 범위입니다.</target>
        </trans-unit>
        <trans-unit id="ce1b50075d06a3525c670dfdee2303781cd59e16" translate="yes" xml:space="preserve">
          <source>Although D does not currently use a moving garbage collector, by following the rules listed above one can be implemented. No special action is required to pin objects. A moving collector will only move objects for which there are no ambiguous references, and for which it can update those references. All other objects will be automatically pinned.</source>
          <target state="translated">D는 현재 이동 가비지 수집기를 사용하지 않지만 위에 나열된 규칙에 따라 구현할 수 있습니다. 물체를 고정하기 위해 특별한 조치가 필요하지 않습니다. 이동 수집기는 모호한 참조가없고 해당 참조를 업데이트 할 수있는 개체 만 이동합니다. 다른 모든 개체는 자동으로 고정됩니다.</target>
        </trans-unit>
        <trans-unit id="1aee14a59e8527fa460ebbbf449880cdcef580e1" translate="yes" xml:space="preserve">
          <source>Although a struct constructor returns a reference to the instance being constructed, it is treated as form (1).</source>
          <target state="translated">구조체 생성자는 생성되는 인스턴스에 대한 참조를 반환하지만 형식 (1)으로 처리됩니다.</target>
        </trans-unit>
        <trans-unit id="b2e0f6070914711324b1b22c0acefe2c4d0046f3" translate="yes" xml:space="preserve">
          <source>Although allocations are in theory served in linear searching time, &lt;code&gt;deallocate&lt;/code&gt; calls take &amp;Omicron;(&lt;code&gt;1&lt;/code&gt;) time, by using aligned allocations. &lt;code&gt;ParentAllocator&lt;/code&gt; must implement &lt;code&gt;alignedAllocate&lt;/code&gt; and it must be able to allocate &lt;code&gt;theAlignment&lt;/code&gt; bytes at the same alignment. Each aligned allocation done by &lt;code&gt;ParentAllocator&lt;/code&gt; will contain metadata for an &lt;code&gt;Allocator&lt;/code&gt;, followed by its payload.</source>
          <target state="translated">할당은 선형 검색 시간에 이론적으로 제공되지만 할당 &lt;code&gt;deallocate&lt;/code&gt; 호출은 정렬 된 할당을 사용하여 &amp;Omicron; ( &lt;code&gt;1&lt;/code&gt; ) 시간이 걸립니다. &lt;code&gt;ParentAllocator&lt;/code&gt; 는 구현해야 &lt;code&gt;alignedAllocate&lt;/code&gt; 를 하며 할당 할 수 있어야합니다 &lt;code&gt;theAlignment&lt;/code&gt; 이 같은 배열에 바이트. &lt;code&gt;ParentAllocator&lt;/code&gt; 가 수행하는 각 정렬 할당 에는 페이로드가 뒤 따르는 &lt;code&gt;Allocator&lt;/code&gt; 의 메타 데이터가 포함됩니다 .</target>
        </trans-unit>
        <trans-unit id="ba5576589df037851e2ab68a594e957c64a2217b" translate="yes" xml:space="preserve">
          <source>Although narrow string types (&lt;code&gt;char[]&lt;/code&gt;, &lt;code&gt;wchar[]&lt;/code&gt;, and their qualified derivatives) do define a &lt;code&gt;length&lt;/code&gt; property, &lt;code&gt;hasLength&lt;/code&gt; yields &lt;code&gt;false&lt;/code&gt; for them. This is because a narrow string's length does not reflect the number of characters, but instead the number of encoding units, and as such is not useful with range-oriented algorithms. To use strings as random-access ranges with length, use &lt;a href=&quot;std_string#representation&quot;&gt;&lt;code&gt;std.string.representation&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;std_utf#byCodeUnit&quot;&gt;&lt;code&gt;std.utf.byCodeUnit&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">좁은 문자열 유형 ( &lt;code&gt;char[]&lt;/code&gt; , &lt;code&gt;wchar[]&lt;/code&gt; 및 해당 한정된 파생물)은 &lt;code&gt;length&lt;/code&gt; 속성을 정의하지만 &lt;code&gt;hasLength&lt;/code&gt; 는 &lt;code&gt;false&lt;/code&gt; 를 생성 합니다. 좁은 문자열 길이는 문자 수가 아니라 인코딩 단위 수를 반영하기 때문에 범위 지향 알고리즘에는 유용하지 않기 때문입니다. 문자열을 길이가 랜덤 액세스 범위로 사용하려면 &lt;a href=&quot;std_string#representation&quot;&gt; &lt;code&gt;std.string.representation&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;std_utf#byCodeUnit&quot;&gt; &lt;code&gt;std.utf.byCodeUnit&lt;/code&gt; 을&lt;/a&gt; 사용 하십시오 .</target>
        </trans-unit>
        <trans-unit id="751a51b5f3815e4913ea4c1e3d08b8c0587fdc03" translate="yes" xml:space="preserve">
          <source>Although some keywords can be used both as a type qualifier and a storage class, there are some storage classes that cannot be used to construct new types, such as &lt;code&gt;ref&lt;/code&gt;:</source>
          <target state="translated">일부 키워드를 타입 한정자 및 스토리지 클래스로 사용할 수 있지만 &lt;code&gt;ref&lt;/code&gt; 와 같은 새로운 타입을 구성하는 데 사용할 수없는 스토리지 클래스가 있습니다 .</target>
        </trans-unit>
        <trans-unit id="dd93adfa24c055484c1d6ac7b1222125e38dd6c6" translate="yes" xml:space="preserve">
          <source>Although static variable name visibility follows the usual scoping rules, the names of them must be unique within a particular function.</source>
          <target state="translated">정적 변수 이름 표시는 일반적인 범위 지정 규칙을 따르지만 특정 함수 내에서 고유 한 이름이어야합니다.</target>
        </trans-unit>
        <trans-unit id="8d68e23bc937fb1a750f414f57afc9ba51e4f8a9" translate="yes" xml:space="preserve">
          <source>Although the contents of the padding are often zero, do not rely on that.</source>
          <target state="translated">패딩의 내용은 종종 0이지만 그에 의존하지 마십시오.</target>
        </trans-unit>
        <trans-unit id="0f6d1d3556d0e4071164ab02759b80b8f87727af" translate="yes" xml:space="preserve">
          <source>Although the data is immutable, the allocator &quot;knows&quot; the underlying memory is mutable, so &lt;code&gt;immutable&lt;/code&gt; is elided for the affix which is independent from the data itself. However, the result is &lt;code&gt;shared&lt;/code&gt; because &lt;code&gt;immutable&lt;/code&gt; is implicitly shareable so multiple threads may access and manipulate the affix for the same data.</source>
          <target state="translated">데이터는 불변이지만 할당자는 기본 메모리가 변할 수 있음을 &quot;알고&quot;있으므로 데이터 자체와 독립적 인 접미사에 대해서는 &lt;code&gt;immutable&lt;/code&gt; 이 제거됩니다. 그러나 &lt;code&gt;immutable&lt;/code&gt; 은 암시 적으로 공유 가능 하기 때문에 결과가 &lt;code&gt;shared&lt;/code&gt; 되므로 여러 스레드가 동일한 데이터의 접두사에 액세스하고 조작 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4594a211d07176e71f67f04c76263fc9e17f8056" translate="yes" xml:space="preserve">
          <source>Always &lt;code&gt;false&lt;/code&gt; (random generators are infinite ranges).</source>
          <target state="translated">항상 &lt;code&gt;false&lt;/code&gt; (무작위 생성기는 무한 범위 임).</target>
        </trans-unit>
        <trans-unit id="d2317146c4b78429c9fa4a78c82cf701740b74a6" translate="yes" xml:space="preserve">
          <source>Always &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">항상 &lt;code&gt;false&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="4ed0571bb284ff0022a6b18f52dbb495171fb6f8" translate="yes" xml:space="preserve">
          <source>Always a new scope, to use for this &lt;code&gt;DeprecatedDeclaration&lt;/code&gt;'s members.</source>
          <target state="translated">이 &lt;code&gt;DeprecatedDeclaration&lt;/code&gt; 멤버 에 사용하는 항상 새로운 범위 입니다.</target>
        </trans-unit>
        <trans-unit id="ecdf7d32ac0560522ba0c167fff3b2a8084d9926" translate="yes" xml:space="preserve">
          <source>Always add new return codes last. Never &lt;em&gt;EVER&lt;/em&gt; remove any. The return codes must remain the same!</source>
          <target state="translated">항상 새 리턴 코드를 마지막에 추가하십시오. 결코 &lt;em&gt;이제까지&lt;/em&gt; 어떤을 제거하지 않습니다. 리턴 코드는 동일하게 유지되어야합니다!</target>
        </trans-unit>
        <trans-unit id="91aa9903448204ed37d902e02a20b0b8d1775687" translate="yes" xml:space="preserve">
          <source>Always call &lt;a href=&quot;#wait&quot;&gt;&lt;code&gt;wait&lt;/code&gt;&lt;/a&gt; to wait for a process to complete, even if &lt;code&gt;kill&lt;/code&gt; has been called on it.</source>
          <target state="translated">항상 전화 &lt;a href=&quot;#wait&quot;&gt; &lt;code&gt;wait&lt;/code&gt; &lt;/a&gt; 경우에도 전체에 대한 프로세스를 기다리 &lt;code&gt;kill&lt;/code&gt; 불려왔다.</target>
        </trans-unit>
        <trans-unit id="00efb2c1e297670bc7025d03ccb66d306c20b175" translate="yes" xml:space="preserve">
          <source>Always defined; used as the opposite of &lt;code&gt;none&lt;/code&gt;</source>
          <target state="translated">항상 정의; &lt;code&gt;none&lt;/code&gt; 의 반대로 사용</target>
        </trans-unit>
        <trans-unit id="c125fb83f824d4bd1d2beebad9485aed6b09839a" translate="yes" xml:space="preserve">
          <source>Always do checking</source>
          <target state="translated">항상 확인</target>
        </trans-unit>
        <trans-unit id="4e048da15ca2bf279cd35e525737612e720e444c" translate="yes" xml:space="preserve">
          <source>Always inline the functions.</source>
          <target state="translated">항상 기능을 인라인하십시오.</target>
        </trans-unit>
        <trans-unit id="756f986f9bcdd129940f4871df381abfdb52d4bb" translate="yes" xml:space="preserve">
          <source>Always insert the decimal point and print trailing zeros.</source>
          <target state="translated">항상 소수점을 삽입하고 후행 0을 인쇄하십시오.</target>
        </trans-unit>
        <trans-unit id="e89bec8fb850573de2289bb9dc31383490faf82d" translate="yes" xml:space="preserve">
          <source>Always returns &lt;code&gt;null&lt;/code&gt;.</source>
          <target state="translated">항상 &lt;code&gt;null&lt;/code&gt; 을 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="28625924634a090c91d5b21229f6718ca1949c53" translate="yes" xml:space="preserve">
          <source>Always returns false (unless the given interval is empty) because an interval beginning at negative infinity can never be after any other interval.</source>
          <target state="translated">음의 무한대에서 시작하는 간격은 다른 간격 이후 일 수 없으므로 항상 주어진 간격이 비어 있지 않으면 false를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="bdadc4badca1a50ef408f60afbd76636c86734c4" translate="yes" xml:space="preserve">
          <source>Always returns false (unless the given interval is empty) because an interval going to positive infinity can never be before any other interval.</source>
          <target state="translated">양의 무한대가되는 간격은 다른 간격 이전이 될 수 없으므로 항상 주어진 간격이 비어 있지 않으면 항상 false를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="94fa66f43e494b57c40dedacad5e8fcc5ed7e45e" translate="yes" xml:space="preserve">
          <source>Always returns false (unless this interval is empty) because a finite interval can never be after an interval going to positive infinity.</source>
          <target state="translated">유한 간격은 양의 무한대가 된 후에는 유한 간격이 될 수 없으므로 항상 false를 반환합니다 (이 간격이 비어 있지 않은 경우).</target>
        </trans-unit>
        <trans-unit id="d882cba308665fda178b09f0755ed0e7ac35509a" translate="yes" xml:space="preserve">
          <source>Always returns false (unless this interval is empty) because a finite interval can never be before an interval beginning at negative infinity.</source>
          <target state="translated">유한 간격은 음의 무한대에서 시작하는 간격 앞에있을 수 없으므로 항상 false를 반환합니다 (이 간격이 비어 있지 않은 경우).</target>
        </trans-unit>
        <trans-unit id="839ddfcb8311f35aad2fb0b8e24e88538a023202" translate="yes" xml:space="preserve">
          <source>Always returns false (unless this interval is empty), because an interval beginning at negative infinity can never be contained in a finite interval.</source>
          <target state="translated">음의 무한대로 시작하는 간격이 유한 간격에 포함될 수 없으므로 항상 false를 반환합니다 (이 간격이 비어 있지 않은 경우).</target>
        </trans-unit>
        <trans-unit id="3ed45722000fa0537c28f229adeae463146f4016" translate="yes" xml:space="preserve">
          <source>Always returns false (unless this interval is empty), because an interval going to positive infinity can never be contained in a finite interval.</source>
          <target state="translated">양의 무한대로가는 간격은 유한 간격에 포함될 수 없으므로 항상 false를 반환합니다 (이 간격이 비어 있지 않으면).</target>
        </trans-unit>
        <trans-unit id="a53924ebd00c5459aa871927c9ec67510a96dd54" translate="yes" xml:space="preserve">
          <source>Always returns false because an interval beginning at negative infinity can never be after any other interval.</source>
          <target state="translated">음의 무한대에서 시작하는 간격은 다른 간격 이후 일 수 없으므로 항상 false를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="d9bab92525c979c53e601d84248db55d697093d3" translate="yes" xml:space="preserve">
          <source>Always returns false because an interval beginning at negative infinity can never be after any time point.</source>
          <target state="translated">음의 무한대에서 시작하는 간격은 어떤 시점 이후도 될 수 없으므로 항상 false를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="829c04d974963809ceb0735be3d487911f2864cf" translate="yes" xml:space="preserve">
          <source>Always returns false because an interval beginning at negative infinity can never be before another interval beginning at negative infinity.</source>
          <target state="translated">음의 무한대에서 시작하는 간격이 음의 무한대에서 시작하는 다른 간격보다 클 수 없으므로 항상 false를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="48190dd4a715744e9634474743dcbc604a9ca68f" translate="yes" xml:space="preserve">
          <source>Always returns false because an interval beginning at negative infinity can never contain an interval going to positive infinity.</source>
          <target state="translated">음의 무한대에서 시작하는 간격은 양의 무한대로가는 간격을 포함 할 수 없으므로 항상 false를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="87f5c7255865a6aa09545519f01b0f602d71f734" translate="yes" xml:space="preserve">
          <source>Always returns false because an interval going to positive infinity can never be after another interval going to positive infinity.</source>
          <target state="translated">양의 무한대가되는 간격은 양의 무한대가되는 다른 간격 이후 일 수 없으므로 항상 false를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="94b78d489ebc6bd76631339902c007afae618abe" translate="yes" xml:space="preserve">
          <source>Always returns false because an interval going to positive infinity can never be before any other interval.</source>
          <target state="translated">양의 무한대가되는 간격은 다른 간격 이전이 될 수 없으므로 항상 false를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="1b622d5187c151cf5715d74c3640dbb076d4394c" translate="yes" xml:space="preserve">
          <source>Always returns false because an interval going to positive infinity can never be before any time point.</source>
          <target state="translated">양의 무한대로가는 간격은 어떤 시점 이전도 될 수 없으므로 항상 false를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="46754795cce31e571fe7c4a3849c49251d755cfd" translate="yes" xml:space="preserve">
          <source>Always returns false because an interval going to positive infinity can never contain an interval beginning at negative infinity.</source>
          <target state="translated">양의 무한대로가는 간격은 음의 무한대에서 시작하는 간격을 포함 할 수 없으므로 항상 false를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="51bcc244bd67d8750a4fdd4fbdf0a387caa703aa" translate="yes" xml:space="preserve">
          <source>Always returns false because two intervals beginning at negative infinity can never be adjacent to one another.</source>
          <target state="translated">음의 무한대에서 시작하는 두 간격이 서로 인접 할 수 없으므로 항상 false를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="5de1beefc377ac68c64f67a4b951a1494a514eb5" translate="yes" xml:space="preserve">
          <source>Always returns false because two intervals going to positive infinity can never be adjacent to one another.</source>
          <target state="translated">양의 무한대가되는 두 간격이 서로 인접 할 수 없으므로 항상 false를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="2e5c51adf29d169f29f627d0dc8290c18d19524d" translate="yes" xml:space="preserve">
          <source>Always returns false.</source>
          <target state="translated">항상 false를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="9789c7e0f94b9d97c7bb5b256c563654386851c1" translate="yes" xml:space="preserve">
          <source>Always returns true because two intervals beginning at negative infinity always overlap.</source>
          <target state="translated">음의 무한대에서 시작하는 두 간격이 항상 겹치므로 항상 true를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="6ae3ed1006060103837a55fb96e4df45549bbde7" translate="yes" xml:space="preserve">
          <source>Always returns true because two intervals going to positive infinity always overlap.</source>
          <target state="translated">양의 무한대로가는 두 간격이 항상 겹치므로 항상 true를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="99690d58d4abd10cd0938a7adcb56ded08ef66ad" translate="yes" xml:space="preserve">
          <source>An</source>
          <target state="translated">An</target>
        </trans-unit>
        <trans-unit id="dcf1c44121ab11079f75ad4f70a75125be5a6a9a" translate="yes" xml:space="preserve">
          <source>An &lt;a href=&quot;#EmailStatus&quot;&gt;&lt;code&gt;EmailStatus&lt;/code&gt;&lt;/a&gt;, indicating the status of the email address.</source>
          <target state="translated">&lt;a href=&quot;#EmailStatus&quot;&gt; &lt;code&gt;EmailStatus&lt;/code&gt; &lt;/a&gt; 이메일 주소의 상태를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="ffe9a34aa0d7b745cc8f891bddd4b51b3279fa26" translate="yes" xml:space="preserve">
          <source>An &lt;a href=&quot;#LName&quot;&gt;&lt;i&gt;LName&lt;/i&gt;&lt;/a&gt; is a name preceded by a &lt;a href=&quot;#Number&quot;&gt;&lt;i&gt;Number&lt;/i&gt;&lt;/a&gt; giving the number of characters in the &lt;a href=&quot;#Name&quot;&gt;&lt;i&gt;Name&lt;/i&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#LName&quot;&gt;&lt;i&gt;LNAME은&lt;/i&gt;&lt;/a&gt; 앞에는 이름입니다 &lt;a href=&quot;#Number&quot;&gt;&lt;i&gt;수&lt;/i&gt;&lt;/a&gt; 의 문자 수주는 &lt;a href=&quot;#Name&quot;&gt;&lt;i&gt;이름&lt;/i&gt;&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="b9368e81deb8013394f56e991844ff7d8f9e56b8" translate="yes" xml:space="preserve">
          <source>An &lt;a href=&quot;expression#ArrayLiteral&quot;&gt;&lt;i&gt;ArrayLiteral&lt;/i&gt;&lt;/a&gt; is inferred to be a dynamic array type rather than a static array:</source>
          <target state="translated">&lt;a href=&quot;expression#ArrayLiteral&quot;&gt;&lt;i&gt;ArrayLiteral은&lt;/i&gt;&lt;/a&gt; 다소 정적 인 배열보다 동적 배열 형태로 추정된다 :</target>
        </trans-unit>
        <trans-unit id="89d876389132db631f40f8472f475c33763a7de8" translate="yes" xml:space="preserve">
          <source>An &lt;a href=&quot;expression#AssertExpression&quot;&gt;&lt;i&gt;AssertExpression&lt;/i&gt;&lt;/a&gt; that fails its condition</source>
          <target state="translated">&lt;a href=&quot;expression#AssertExpression&quot;&gt;&lt;i&gt;AssertExpression&lt;/i&gt;&lt;/a&gt; 의 상태를 실패</target>
        </trans-unit>
        <trans-unit id="6590283f72c8bc68a61e26f8207b2166720f88ee" translate="yes" xml:space="preserve">
          <source>An &lt;a href=&quot;std_meta#AliasSeq&quot;&gt;&lt;code&gt;std.meta.AliasSeq&lt;/code&gt;&lt;/a&gt; with all possible target types of an implicit conversion &lt;code&gt;T&lt;/code&gt;.  If &lt;code&gt;T&lt;/code&gt; is a class derived from &lt;code&gt;Object&lt;/code&gt;, the the result of &lt;a href=&quot;#TransitiveBaseTypeTuple&quot;&gt;&lt;code&gt;TransitiveBaseTypeTuple&lt;/code&gt;&lt;/a&gt; is returned.  If the type is not a built-in value type or a class derived from &lt;code&gt;Object&lt;/code&gt;, the an empty &lt;a href=&quot;std_meta#AliasSeq&quot;&gt;&lt;code&gt;std.meta.AliasSeq&lt;/code&gt;&lt;/a&gt; is returned.</source>
          <target state="translated">&lt;a href=&quot;std_meta#AliasSeq&quot;&gt; &lt;code&gt;std.meta.AliasSeq&lt;/code&gt; &lt;/a&gt; 암시 적 변환의 모든 가능한 타겟 유형 &lt;code&gt;T&lt;/code&gt; . &lt;code&gt;T&lt;/code&gt; 가 &lt;code&gt;Object&lt;/code&gt; 에서 파생 된 클래스 인 경우 &lt;a href=&quot;#TransitiveBaseTypeTuple&quot;&gt; &lt;code&gt;TransitiveBaseTypeTuple&lt;/code&gt; &lt;/a&gt; 의 결과 가 반환됩니다. 유형이 내장 값 유형이거나 &lt;code&gt;Object&lt;/code&gt; 에서 파생 된 클래스가 아닌 경우 빈 &lt;a href=&quot;std_meta#AliasSeq&quot;&gt; &lt;code&gt;std.meta.AliasSeq&lt;/code&gt; &lt;/a&gt; 가 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="5357eeb67edd28cef849aec387209e4ff6da64a3" translate="yes" xml:space="preserve">
          <source>An &lt;a href=&quot;std_range_primitives#isInputRange&quot;&gt;input range&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;std_range_primitives#isInputRange&quot;&gt;입력 범위&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="b5ae81b9680ce568443b4c970f3bc5dc366146d8" translate="yes" xml:space="preserve">
          <source>An &lt;a href=&quot;std_range_primitives#isInputRange&quot;&gt;input range&lt;/a&gt; of &lt;a href=&quot;#DirEntry&quot;&gt;&lt;code&gt;DirEntry&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#DirEntry&quot;&gt; &lt;code&gt;DirEntry&lt;/code&gt; &lt;/a&gt; 의 &lt;a href=&quot;std_range_primitives#isInputRange&quot;&gt;입력 범위&lt;/a&gt; 입니다 .</target>
        </trans-unit>
        <trans-unit id="f659b816c177344a9a4b993dd7f1f23fa0444745" translate="yes" xml:space="preserve">
          <source>An &lt;a href=&quot;std_range_primitives#isInputRange&quot;&gt;input range&lt;/a&gt; of consecutively unique elements in the original range. If &lt;code&gt;r&lt;/code&gt; is also a forward range or bidirectional range, the returned range will be likewise.</source>
          <target state="translated">원래 범위에서 연속적으로 고유 한 요소 의 &lt;a href=&quot;std_range_primitives#isInputRange&quot;&gt;입력&lt;/a&gt; 범위. 경우 &lt;code&gt;r&lt;/code&gt; 은 범위 나 양방향 범위 앞으로도, 반환 범위는 마찬가지 일 것이다.</target>
        </trans-unit>
        <trans-unit id="5a3658d6619aac9bf9bbbb396cba995f2c9f0bb3" translate="yes" xml:space="preserve">
          <source>An &lt;a href=&quot;std_range_primitives#isInputRange&quot;&gt;input range&lt;/a&gt; of elements</source>
          <target state="translated">요소 의 &lt;a href=&quot;std_range_primitives#isInputRange&quot;&gt;입력 범위&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="aeb6a5dabc8ee71a80f9364ee1475c7fc12f32a2" translate="yes" xml:space="preserve">
          <source>An &lt;a href=&quot;std_range_primitives#isInputRange&quot;&gt;input range&lt;/a&gt; of elements to filter.</source>
          <target state="translated">필터링 할 요소 의 &lt;a href=&quot;std_range_primitives#isInputRange&quot;&gt;입력 범위&lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="707d66d0f4a293729b9673f780ebae8dbcfcc3c1" translate="yes" xml:space="preserve">
          <source>An &lt;a href=&quot;std_range_primitives#isInputRange&quot;&gt;input range&lt;/a&gt; of elements.</source>
          <target state="translated">요소 의 &lt;a href=&quot;std_range_primitives#isInputRange&quot;&gt;입력 범위&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="33c6aa39a8169309ace06cecc9bf8cd227418643" translate="yes" xml:space="preserve">
          <source>An &lt;a href=&quot;std_range_primitives#isInputRange&quot;&gt;input range&lt;/a&gt; of input ranges</source>
          <target state="translated">&lt;a href=&quot;std_range_primitives#isInputRange&quot;&gt;입력 범위&lt;/a&gt; 의 입력 범위</target>
        </trans-unit>
        <trans-unit id="7e44b358ef6f4995ad58c7e05ef241784818aecf" translate="yes" xml:space="preserve">
          <source>An &lt;a href=&quot;std_range_primitives#isInputRange&quot;&gt;input range&lt;/a&gt; of input ranges to be joined.</source>
          <target state="translated">&lt;a href=&quot;std_range_primitives#isInputRange&quot;&gt;입력 범위&lt;/a&gt; 의 입력 범위를 접합한다.</target>
        </trans-unit>
        <trans-unit id="db74a7a8ef007cbf994b98f4433445f62a98cc07" translate="yes" xml:space="preserve">
          <source>An &lt;a href=&quot;std_range_primitives#isInputRange&quot;&gt;input range&lt;/a&gt; of keys</source>
          <target state="translated">키 의 &lt;a href=&quot;std_range_primitives#isInputRange&quot;&gt;입력 범위&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="95280f839dfcc7e6fffaf43a757e145f824a67a0" translate="yes" xml:space="preserve">
          <source>An &lt;a href=&quot;std_range_primitives#isInputRange&quot;&gt;input range&lt;/a&gt; of segments to assemble the path from.</source>
          <target state="translated">경로를 어셈블 할 세그먼트 의 &lt;a href=&quot;std_range_primitives#isInputRange&quot;&gt;입력 범위&lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="7b7d7db68f90c0aa95feaeaf3c9f2a490793d047" translate="yes" xml:space="preserve">
          <source>An &lt;a href=&quot;std_range_primitives#isInputRange&quot;&gt;input range&lt;/a&gt; of slices of the original range split by whitespace.</source>
          <target state="translated">&lt;a href=&quot;std_range_primitives#isInputRange&quot;&gt;입력 범위&lt;/a&gt; 공백으로 원래 범위 분할 조각.</target>
        </trans-unit>
        <trans-unit id="eb75e1af2690fdd4800075d57086bf1d4208ae4b" translate="yes" xml:space="preserve">
          <source>An &lt;a href=&quot;std_range_primitives#isInputRange&quot;&gt;input range&lt;/a&gt; of tuples of keys and values.</source>
          <target state="translated">&lt;a href=&quot;std_range_primitives#isInputRange&quot;&gt;입력 범위&lt;/a&gt; 키 값 터플.</target>
        </trans-unit>
        <trans-unit id="97ff10ecbc90564b57494f893fe51dd077880140" translate="yes" xml:space="preserve">
          <source>An &lt;a href=&quot;std_range_primitives#isInputRange&quot;&gt;input range&lt;/a&gt; of values</source>
          <target state="translated">값 의 &lt;a href=&quot;std_range_primitives#isInputRange&quot;&gt;입력 범위&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="133de0070e3c643c203f06c3842a5a65269aacef" translate="yes" xml:space="preserve">
          <source>An &lt;a href=&quot;std_range_primitives#isInputRange&quot;&gt;input range&lt;/a&gt; over the data to be decoded.</source>
          <target state="translated">디코딩 할 데이터 의 &lt;a href=&quot;std_range_primitives#isInputRange&quot;&gt;입력 범위&lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="05ae651266b6aebe6405ca7d3e9d38d6bbda4a2e" translate="yes" xml:space="preserve">
          <source>An &lt;a href=&quot;std_range_primitives#isInputRange&quot;&gt;input range&lt;/a&gt; over the data to be encoded.</source>
          <target state="translated">인코딩 할 데이터 의 &lt;a href=&quot;std_range_primitives#isInputRange&quot;&gt;입력 범위&lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="53e90b53eb146e6b34d965149154b8c1b40783a3" translate="yes" xml:space="preserve">
          <source>An &lt;a href=&quot;std_range_primitives#isInputRange&quot;&gt;input range&lt;/a&gt; that exposes references to its elements and has assignable elements</source>
          <target state="translated">요소에 대한 참조를 제공하고 할당 가능한 요소가 있는 &lt;a href=&quot;std_range_primitives#isInputRange&quot;&gt;입력 범위&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="ea7d6814c8da44833511f491c47ceb591d626a8d" translate="yes" xml:space="preserve">
          <source>An &lt;a href=&quot;std_range_primitives#isInputRange&quot;&gt;input range&lt;/a&gt; that iterates over the bytes of data decoded from a Base64 encoded string.</source>
          <target state="translated">Base64 인코딩 문자열에서 디코딩 된 데이터 바이트를 반복 하는 &lt;a href=&quot;std_range_primitives#isInputRange&quot;&gt;입력 범위&lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="f0e959040d1e17340e8751524e2d4256b8691ac7" translate="yes" xml:space="preserve">
          <source>An &lt;a href=&quot;std_range_primitives#isInputRange&quot;&gt;input range&lt;/a&gt; that iterates over the decoded data of a range of Base64 encodings.</source>
          <target state="translated">Base64 인코딩 범위의 디코딩 된 데이터를 반복 하는 &lt;a href=&quot;std_range_primitives#isInputRange&quot;&gt;입력 범위&lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="43af4719ff15eb275c1c72c27f3b8376924d9bc1" translate="yes" xml:space="preserve">
          <source>An &lt;a href=&quot;std_range_primitives#isInputRange&quot;&gt;input range&lt;/a&gt; that iterates over the encoded bytes of the given source data.</source>
          <target state="translated">주어진 소스 데이터의 인코딩 된 바이트를 반복 하는 &lt;a href=&quot;std_range_primitives#isInputRange&quot;&gt;입력 범위&lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="49c67170189246c824452f09ce0e9b881029c595" translate="yes" xml:space="preserve">
          <source>An &lt;a href=&quot;std_range_primitives#isInputRange&quot;&gt;input range&lt;/a&gt; that iterates over the original range's elements, but ends when the specified predicate becomes true. If the original range is a &lt;a href=&quot;std_range_primitives#isForwardRange&quot;&gt;forward range&lt;/a&gt; or higher, this range will be a forward range.</source>
          <target state="translated">원래 범위의 요소를 반복하지만 지정된 술어가 true가되면 종료 되는 &lt;a href=&quot;std_range_primitives#isInputRange&quot;&gt;입력 범위&lt;/a&gt; . 원래 범위가 &lt;a href=&quot;std_range_primitives#isForwardRange&quot;&gt;전달 범위&lt;/a&gt; 이상이면이 범위가 전달 범위가됩니다.</target>
        </trans-unit>
        <trans-unit id="f1a22b9c6d64de659aa93282f2a2c09eb16b5f23" translate="yes" xml:space="preserve">
          <source>An &lt;a href=&quot;std_range_primitives#isInputRange&quot;&gt;input range&lt;/a&gt; that iterates over the respective Base64 encodings of a range of data items.</source>
          <target state="translated">데이터 항목 범위의 각 Base64 인코딩을 반복 하는 &lt;a href=&quot;std_range_primitives#isInputRange&quot;&gt;입력 범위&lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="d7f2d0c17c0405fa6b38c89079adc1903c913cb8" translate="yes" xml:space="preserve">
          <source>An &lt;a href=&quot;std_range_primitives#isInputRange&quot;&gt;input range&lt;/a&gt; to be chunked.</source>
          <target state="translated">&lt;a href=&quot;std_range_primitives#isInputRange&quot;&gt;입력 범위는&lt;/a&gt; 청크한다.</target>
        </trans-unit>
        <trans-unit id="c892ebe289689b74313c775aba7569dc3d96121e" translate="yes" xml:space="preserve">
          <source>An &lt;a href=&quot;std_range_primitives#isInputRange&quot;&gt;input range&lt;/a&gt; with elements that elements from &lt;code&gt;src&lt;/code&gt; can be moved into.</source>
          <target state="translated">&lt;code&gt;src&lt;/code&gt; 의 요소를 이동할 수있는 요소가 있는 &lt;a href=&quot;std_range_primitives#isInputRange&quot;&gt;입력 범위&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="b62730011ee93bfeac5690d8a28be51290200dce" translate="yes" xml:space="preserve">
          <source>An &lt;a href=&quot;std_range_primitives#isInputRange&quot;&gt;input range&lt;/a&gt; with movable elements.</source>
          <target state="translated">움직일 수있는 요소가 있는 &lt;a href=&quot;std_range_primitives#isInputRange&quot;&gt;입력 범위&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="501f3d209c91fc5763279ea66a99a52ae9245f3d" translate="yes" xml:space="preserve">
          <source>An &lt;a href=&quot;std_range_primitives#isInputRange&quot;&gt;input range&lt;/a&gt; with the cached values of range</source>
          <target state="translated">&lt;a href=&quot;std_range_primitives#isInputRange&quot;&gt;입력 범위&lt;/a&gt; 범위의 저장된 값</target>
        </trans-unit>
        <trans-unit id="965b67bd175b57783d700b642e30d67633838585" translate="yes" xml:space="preserve">
          <source>An &lt;a href=&quot;std_range_primitives#isInputRange&quot;&gt;input range&lt;/a&gt;, or any number of implicitly convertible items to insert into &lt;code&gt;array&lt;/code&gt;.</source>
          <target state="translated">&lt;a href=&quot;std_range_primitives#isInputRange&quot;&gt;입력 범위&lt;/a&gt; 또는 암시 적으로 변환 중 어느 번호에 삽입하는 &lt;code&gt;array&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="568cafc64895197463cb35df36675af55e4422de" translate="yes" xml:space="preserve">
          <source>An &lt;a href=&quot;std_range_primitives#isOutputRange&quot;&gt;output range&lt;/a&gt; which accepts string types, &lt;code&gt;ubyte[]&lt;/code&gt;, individual character types, and individual &lt;code&gt;ubyte&lt;/code&gt;s.</source>
          <target state="translated">문자열 유형, &lt;code&gt;ubyte[]&lt;/code&gt; , 개별 문자 유형 및 개별 &lt;code&gt;ubyte&lt;/code&gt; 를 허용 하는 &lt;a href=&quot;std_range_primitives#isOutputRange&quot;&gt;출력 범위&lt;/a&gt; 입니다 .</target>
        </trans-unit>
        <trans-unit id="96659bf0ec2c02c0f163ebb47294be48aeeef57c" translate="yes" xml:space="preserve">
          <source>An &lt;a href=&quot;std_stdio#File&quot;&gt;&lt;code&gt;std.stdio.File&lt;/code&gt;&lt;/a&gt; that allows reading from the child process' standard error stream.</source>
          <target state="translated">자식 프로세스의 표준 오류 스트림에서 읽을 수 있는 &lt;a href=&quot;std_stdio#File&quot;&gt; &lt;code&gt;std.stdio.File&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="20e84e08d65e61dcd687cc1797aa39066181d9c1" translate="yes" xml:space="preserve">
          <source>An &lt;a href=&quot;std_stdio#File&quot;&gt;&lt;code&gt;std.stdio.File&lt;/code&gt;&lt;/a&gt; that allows reading from the child process' standard output stream.</source>
          <target state="translated">자식 프로세스의 표준 출력 스트림에서 읽을 수 있는 &lt;a href=&quot;std_stdio#File&quot;&gt; &lt;code&gt;std.stdio.File&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="53e5c6c6f6f60588aedc9a37247bd45dc00707bc" translate="yes" xml:space="preserve">
          <source>An &lt;a href=&quot;std_stdio#File&quot;&gt;&lt;code&gt;std.stdio.File&lt;/code&gt;&lt;/a&gt; that allows writing to the child process' standard input stream.</source>
          <target state="translated">자식 프로세스의 표준 입력 스트림에 쓸 수 있는 &lt;a href=&quot;std_stdio#File&quot;&gt; &lt;code&gt;std.stdio.File&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="3e9533a6a3d9a4d55816c193bc0f53b935c22f6d" translate="yes" xml:space="preserve">
          <source>An &lt;a href=&quot;template#variadic-templates&quot;&gt;expression sequence&lt;/a&gt; of all struct fields - see &lt;a href=&quot;class#class_properties&quot;&gt;Class Properties&lt;/a&gt; for a class-based example.</source>
          <target state="translated">모든 구조체 필드 의 &lt;a href=&quot;template#variadic-templates&quot;&gt;표현식 순서&lt;/a&gt; - 클래스 기반 예제는 클래스 &lt;a href=&quot;class#class_properties&quot;&gt;속성&lt;/a&gt; 을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="f3a6583818c5f8f234b1ec03cdc9d796a3fa7ebe" translate="yes" xml:space="preserve">
          <source>An &lt;code&gt;Address&lt;/code&gt; instance representing specified address.</source>
          <target state="translated">&lt;code&gt;Address&lt;/code&gt; 지정된 주소를 나타내는 인스턴스입니다.</target>
        </trans-unit>
        <trans-unit id="56e2323d99083365dfdf1e12a30b245e969af361" translate="yes" xml:space="preserve">
          <source>An &lt;code&gt;AliasSeq&lt;/code&gt; containing the values produced by iterating over &lt;code&gt;iter&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;AliasSeq&lt;/code&gt; 반복에 의해 생성 된 값을 포함 &lt;code&gt;iter&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d8cfdc9c8275278162fbcaa5be1463495fde71d3" translate="yes" xml:space="preserve">
          <source>An &lt;code&gt;AliasSeq&lt;/code&gt; filtered by the selected stride.</source>
          <target state="translated">&lt;code&gt;AliasSeq&lt;/code&gt; 가 선택한 보폭에 의해 필터링.</target>
        </trans-unit>
        <trans-unit id="20aff1a9df323b6df7883ad0a1e714a382dae9ef" translate="yes" xml:space="preserve">
          <source>An &lt;code&gt;AliasSeq&lt;/code&gt; of &lt;code&gt;args&lt;/code&gt; with &lt;code&gt;out&lt;/code&gt;, &lt;code&gt;ref&lt;/code&gt;, and &lt;code&gt;lazy&lt;/code&gt; saved.</source>
          <target state="translated">&lt;code&gt;AliasSeq&lt;/code&gt; 의 &lt;code&gt;args&lt;/code&gt; 와 &lt;code&gt;out&lt;/code&gt; , &lt;code&gt;ref&lt;/code&gt; , 그리고 &lt;code&gt;lazy&lt;/code&gt; 저장.</target>
        </trans-unit>
        <trans-unit id="94b6f12ba21ae4feae1b40330f4a8aa9e0a73296" translate="yes" xml:space="preserve">
          <source>An &lt;code&gt;Exception&lt;/code&gt; if all of the ranges are not the same length and &lt;code&gt;sp&lt;/code&gt; is set to &lt;code&gt;StoppingPolicy.requireSameLength&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Exception&lt;/code&gt; 범위의 모든 경우는 같은 길이 아니며, &lt;code&gt;sp&lt;/code&gt; 설정되어 &lt;code&gt;StoppingPolicy.requireSameLength&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9d61cad630058a64dcee11973cf4730e528fa9b3" translate="yes" xml:space="preserve">
          <source>An &lt;code&gt;Interval&lt;/code&gt; has a starting point and an end point. The interval of time is therefore the time starting at the starting point up to, but not including, the end point. e.g.</source>
          <target state="translated">&lt;code&gt;Interval&lt;/code&gt; 시작 지점과 끝 지점을 가지고있다. 따라서 시간 간격은 시작점에서 시작하여 종료점까지는 포함하지 않는 시간입니다. 예 :</target>
        </trans-unit>
        <trans-unit id="11231347c4e1b61534c1256649e8160ffb845ccb" translate="yes" xml:space="preserve">
          <source>An &lt;code&gt;enum&lt;/code&gt; of type &lt;code&gt;Target&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;Target&lt;/code&gt; 유형 의 &lt;code&gt;enum&lt;/code&gt; 형</target>
        </trans-unit>
        <trans-unit id="5f32443fe48d10edfa532d0732e99edf167154d6" translate="yes" xml:space="preserve">
          <source>An &lt;code&gt;extern&lt;/code&gt; declaration can optionally be followed by an &lt;code&gt;extern&lt;/code&gt;&lt;a href=&quot;attribute#linkage&quot;&gt;linkage attribute&lt;/a&gt;. If there is no linkage attribute it defaults to &lt;code&gt;extern(D)&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;extern&lt;/code&gt; 선언 임의로 다음 수 &lt;code&gt;extern&lt;/code&gt; &lt;a href=&quot;attribute#linkage&quot;&gt;결합 특성&lt;/a&gt; . 연계 속성이 없으면 기본값은 &lt;code&gt;extern(D)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="cb13928ebe13144a8f0cde9175549c7ca8ef3240" translate="yes" xml:space="preserve">
          <source>An &lt;code&gt;int&lt;/code&gt; that is 0 if the strings match, &amp;lt;0 if &lt;code&gt;r1&lt;/code&gt; is lexicographically &quot;less&quot; than &lt;code&gt;r2&lt;/code&gt;, &amp;gt;0 if &lt;code&gt;r1&lt;/code&gt; is lexicographically &quot;greater&quot; than &lt;code&gt;r2&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;int&lt;/code&gt; &amp;lt;0이면 문자열이 일치하면 0이고, &lt;code&gt;r1&lt;/code&gt; 보다 사전 &quot;미만&quot;인 &lt;code&gt;r2&lt;/code&gt; &amp;gt; 0이 경우 &lt;code&gt;r1&lt;/code&gt; 전적으로보다 &quot;더 큰&quot;이고 &lt;code&gt;r2&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="efb2860a0ceaf8160fc6745198e13de4de19934e" translate="yes" xml:space="preserve">
          <source>An &lt;code&gt;int&lt;/code&gt; that is 0 if the strings match, &amp;lt;0 if &lt;code&gt;str1&lt;/code&gt; is lexicographically &quot;less&quot; than &lt;code&gt;str2&lt;/code&gt;, &amp;gt;0 if &lt;code&gt;str1&lt;/code&gt; is lexicographically &quot;greater&quot; than &lt;code&gt;str2&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;int&lt;/code&gt; &amp;lt;0이면 문자열이 일치하면 0이고 &lt;code&gt;str1&lt;/code&gt; 보다 사전 &quot;미만&quot;인 &lt;code&gt;str2&lt;/code&gt; ,&amp;gt; 0 인 경우 &lt;code&gt;str1&lt;/code&gt; 전적으로보다 &quot;더 큰&quot;이다 &lt;code&gt;str2&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="dd2a5ae8ac277d08cffcbd8287934b6c72d5390c" translate="yes" xml:space="preserve">
          <source>An &lt;code&gt;std.typecons.Tuple!(bool, &quot;terminated&quot;, int, &quot;status&quot;)&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;std.typecons.Tuple!(bool, &quot;terminated&quot;, int, &quot;status&quot;)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9b29fdcb57cf0f2aa50c1917aef7ee2d7326de41" translate="yes" xml:space="preserve">
          <source>An &lt;code&gt;std.typecons.Tuple!(int, &quot;status&quot;, string, &quot;output&quot;)&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;std.typecons.Tuple!(int, &quot;status&quot;, string, &quot;output&quot;)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="44325a188ea9f569f00f25fe1293e0a22a6a319a" translate="yes" xml:space="preserve">
          <source>An Associative Array can be iterated in key/value fashion using a &lt;a href=&quot;statement#ForeachStatement&quot;&gt;foreach statement&lt;/a&gt;. As an example, the number of occurrences of all possible substrings of length 2 (aka 2-mers) in a string will be counted:</source>
          <target state="translated">&lt;a href=&quot;statement#ForeachStatement&quot;&gt;foreach 문을&lt;/a&gt; 사용하여 연관 배열을 키 / 값 방식으로 반복 할 수 있습니다 . 예를 들어, 문자열에서 길이 2 (일명 2-mer)의 가능한 모든 하위 문자열의 발생 횟수가 계산됩니다.</target>
        </trans-unit>
        <trans-unit id="a90c85005c067a015cf8ee553e7e07506f3cb661" translate="yes" xml:space="preserve">
          <source>An Associative Array defaults to &lt;code&gt;null&lt;/code&gt;, and is constructed upon assigning the first key/value pair. However, once constructed, an associative array has</source>
          <target state="translated">연관 배열의 기본값은 &lt;code&gt;null&lt;/code&gt; 이며 첫 번째 키 / 값 쌍을 할당 할 때 구성됩니다. 그러나 일단 구성되면 연관 배열은</target>
        </trans-unit>
        <trans-unit id="20dacc2ff7dcec50b018c97c25042104ca6d5e2d" translate="yes" xml:space="preserve">
          <source>An N-dimensional array with individual elements of type T.</source>
          <target state="translated">유형 T의 개별 요소가있는 N 차원 배열입니다.</target>
        </trans-unit>
        <trans-unit id="374153a385906e41868a8afe177a5c76f263689c" translate="yes" xml:space="preserve">
          <source>An OutputRange that discards the data it receives.</source>
          <target state="translated">수신 한 데이터를 버리는 OutputRange.</target>
        </trans-unit>
        <trans-unit id="e7013471ca7cfba239c38e91976beb8fce0d63dd" translate="yes" xml:space="preserve">
          <source>An abstract character does not necessarily correspond to what a user thinks of as a &amp;ldquo;character&amp;rdquo; and should not be confused with a &lt;a href=&quot;#Grapheme&quot;&gt;&lt;code&gt;Grapheme&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">추상 문자는 사용자가 &quot;문자&quot;로 생각하는 것과 반드시 ​​일치 할 필요는 없으며 &lt;a href=&quot;#Grapheme&quot;&gt; &lt;code&gt;Grapheme&lt;/code&gt; &lt;/a&gt; 과 혼동해서는 안됩니다 .</target>
        </trans-unit>
        <trans-unit id="fdba09e2a7de450eb20cc61c51e59eb62e78cd9a" translate="yes" xml:space="preserve">
          <source>An abstract character has no concrete form and should not be confused with a &lt;a href=&quot;#Glyph&quot;&gt;glyph&lt;/a&gt;.</source>
          <target state="translated">추상 문자는 구체적인 형태가 없으며 &lt;a href=&quot;#Glyph&quot;&gt;글리프&lt;/a&gt; 와 혼동해서는 안됩니다 .</target>
        </trans-unit>
        <trans-unit id="5231e46b8fbe9153560533f1e9c30f8aa007e730" translate="yes" xml:space="preserve">
          <source>An abstract member function must be overridden by a derived class. Only virtual member functions may be declared abstract; non-virtual member functions and free-standing functions cannot be declared abstract.</source>
          <target state="translated">추상 멤버 함수는 파생 클래스로 재정의해야합니다. 가상 멤버 함수 만 추상으로 선언 될 수 있습니다. 비가 상 멤버 함수와 독립 함수는 추상적으로 선언 될 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="4533566ebe9595ef8c3fb7a85a6b2b8cded96094" translate="yes" xml:space="preserve">
          <source>An additional hidden argument with the name &lt;code&gt;_arguments&lt;/code&gt; and type &lt;code&gt;TypeInfo[]&lt;/code&gt; is passed to the function. &lt;code&gt;_arguments&lt;/code&gt; gives the number of arguments and the type of each, enabling type safety to be checked at run time.</source>
          <target state="translated">이름이 &lt;code&gt;_arguments&lt;/code&gt; 이고 &lt;code&gt;TypeInfo[]&lt;/code&gt; 유형 의 추가 숨겨진 인수가 함수에 전달됩니다. &lt;code&gt;_arguments&lt;/code&gt; 는 인수 수와 각각의 유형을 제공하여 런타임시 유형 안전성을 확인할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3b6d0293666de158be3f12d22968c31c56140ac3" translate="yes" xml:space="preserve">
          <source>An adjustor thunk looks like:</source>
          <target state="translated">조절기 썽 크는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="0847d49328423d89a734c43cd88e9b79a0544a70" translate="yes" xml:space="preserve">
          <source>An alias for &lt;code&gt;minAlign&lt;/code&gt;, which must be a valid alignment (nonzero power of 2). The start of the region and all allocation requests will be rounded up to a multiple of the alignment.</source>
          <target state="translated">&lt;code&gt;minAlign&lt;/code&gt; 에 대한 별명 . 유효한 정렬이어야합니다 (0이 아닌 제곱 2). 리전의 시작 및 모든 할당 요청은 여러 정렬로 올림됩니다.</target>
        </trans-unit>
        <trans-unit id="9993ac9ea2f6651d34b1aa2a448a3c14badfcb90" translate="yes" xml:space="preserve">
          <source>An alternate form of wysiwyg strings are enclosed by backquotes, the ` character.</source>
          <target state="translated">wysiwyg 문자열의 다른 형태는`따옴표 인 백 따옴표로 묶습니다.</target>
        </trans-unit>
        <trans-unit id="ffb2ff8aaa0d0c4fff2997632dac364705c0344c" translate="yes" xml:space="preserve">
          <source>An alternative version of curl_multi_perform() that allows the application to pass in one of the file descriptors that have been detected to have &quot;action&quot; on them and let libcurl perform. See man page for details.</source>
          <target state="translated">curl_multi_perform ()의 대체 버전으로, 응용 프로그램이 &quot;작업&quot;이있는 것으로 탐지 된 파일 디스크립터 중 하나를 전달하고 libcurl이 수행되도록합니다. 자세한 내용은 매뉴얼 페이지를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="67aef8339b904d4fa6032e3895c0a4baeec8d2c9" translate="yes" xml:space="preserve">
          <source>An anonymous nested class is both defined and instantiated with a</source>
          <target state="translated">익명의 중첩 클래스는 다음과 같이 정의되고 인스턴스화됩니다.</target>
        </trans-unit>
        <trans-unit id="d6df80b73f182ab7ff7950f3a7e97396adcc2088" translate="yes" xml:space="preserve">
          <source>An arbitrary-precision integer type.</source>
          <target state="translated">임의 정밀도 정수 유형입니다.</target>
        </trans-unit>
        <trans-unit id="a3c537c68c1280a36448d29d7b84b05b6066936e" translate="yes" xml:space="preserve">
          <source>An argument to a &lt;code&gt;lazy&lt;/code&gt; parameter is not evaluated before the function is called. The argument is only evaluated if/when the parameter is evaluated within the function. Hence, a &lt;code&gt;lazy&lt;/code&gt; argument can be executed 0 or more times.</source>
          <target state="translated">&lt;code&gt;lazy&lt;/code&gt; 매개 변수에 대한 인수 는 함수가 호출되기 전에 평가되지 않습니다. 인수는 함수 내에서 매개 변수가 평가되는 경우에만 평가됩니다. 따라서, &lt;code&gt;lazy&lt;/code&gt; 인수는 0 회 이상 실행될 수있다.</target>
        </trans-unit>
        <trans-unit id="ea18ca730a0aa21281c1af9096a60b9ecf44e189" translate="yes" xml:space="preserve">
          <source>An array containing references to all threads currently being tracked by the system. The result of deleting any contained objects is undefined.</source>
          <target state="translated">시스템에서 현재 추적중인 모든 스레드에 대한 참조를 포함하는 배열입니다. 포함 된 객체를 삭제 한 결과는 정의되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="77815bde2a83a1011d8ecf1e77f89465ef4b38cb" translate="yes" xml:space="preserve">
          <source>An array containing the divided parts of &lt;code&gt;range&lt;/code&gt; (or the words of &lt;code&gt;s&lt;/code&gt;).</source>
          <target state="translated">&lt;code&gt;range&lt;/code&gt; 의 분할 된 부분 (또는 &lt;code&gt;s&lt;/code&gt; 의 단어)을 포함하는 배열 입니다.</target>
        </trans-unit>
        <trans-unit id="daec8cadf3d6935e405e9c172ddf7e64c36f7c31" translate="yes" xml:space="preserve">
          <source>An array of &lt;code&gt;Statement&lt;/code&gt;s, that will referenced by this class</source>
          <target state="translated">이 클래스에 의해 참조되는 &lt;code&gt;Statement&lt;/code&gt; 배열</target>
        </trans-unit>
        <trans-unit id="29fa536473a8fa6b0ec875c2597efa9dce1d5e34" translate="yes" xml:space="preserve">
          <source>An array of &lt;code&gt;T&lt;/code&gt; with &lt;code&gt;I.length&lt;/code&gt; dimensions.</source>
          <target state="translated">길이 가 &lt;code&gt;I.length&lt;/code&gt; 인 &lt;code&gt;T&lt;/code&gt; 의 배열입니다 .</target>
        </trans-unit>
        <trans-unit id="479c220b9bb5c5c461e1a646be4bf0d486b927a9" translate="yes" xml:space="preserve">
          <source>An array of complex numbers representing the transformed data in the frequency domain.</source>
          <target state="translated">주파수 영역에서 변환 된 데이터를 나타내는 복소수 배열입니다.</target>
        </trans-unit>
        <trans-unit id="f0621e8fe8af51735a47c76956cd2a28911a1a9f" translate="yes" xml:space="preserve">
          <source>An array of elements</source>
          <target state="translated">요소의 배열</target>
        </trans-unit>
        <trans-unit id="7326b4532e3c0a6987d70e29c99a0d57edd13a68" translate="yes" xml:space="preserve">
          <source>An array of path to D modules</source>
          <target state="translated">D 모듈에 대한 경로 배열</target>
        </trans-unit>
        <trans-unit id="fbfc4f55870a8b45855e77b9502741089e3999c7" translate="yes" xml:space="preserve">
          <source>An array of paths to assemble.</source>
          <target state="translated">조립할 경로 배열입니다.</target>
        </trans-unit>
        <trans-unit id="6eeb3c945dc78c366a34ecd56e6cc4c9081dc7db" translate="yes" xml:space="preserve">
          <source>An array of regular expression strings. The resulting &lt;code&gt;Regex&lt;/code&gt; object will match any expression; use &lt;a href=&quot;#whichPattern&quot;&gt;&lt;code&gt;whichPattern&lt;/code&gt;&lt;/a&gt; to know which.</source>
          <target state="translated">정규식 문자열의 배열입니다. 결과 &lt;code&gt;Regex&lt;/code&gt; 객체는 모든 표현식과 일치합니다. &lt;a href=&quot;#whichPattern&quot;&gt; &lt;code&gt;whichPattern&lt;/code&gt; &lt;/a&gt; 을 사용하여 어느 것을 알 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="418fbbabc9dc07ec6379ba1dda3419b4c8dd83da" translate="yes" xml:space="preserve">
          <source>An array of type &lt;code&gt;Target&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;Target&lt;/code&gt; 유형의 배열</target>
        </trans-unit>
        <trans-unit id="81574167760f6ba7a1bdd1dc1d384e2cfcd701d9" translate="yes" xml:space="preserve">
          <source>An array or asssociative array literal. &lt;a href=&quot;#Number&quot;&gt;&lt;i&gt;Number&lt;/i&gt;&lt;/a&gt; is the length of the array. &lt;a href=&quot;#Value&quot;&gt;&lt;i&gt;Value&lt;/i&gt;&lt;/a&gt; is repeated &lt;a href=&quot;#Number&quot;&gt;&lt;i&gt;Number&lt;/i&gt;&lt;/a&gt; times for a normal array, and 2 * &lt;a href=&quot;#Number&quot;&gt;&lt;i&gt;Number&lt;/i&gt;&lt;/a&gt; times for an associative array.</source>
          <target state="translated">배열 또는 연관 배열 리터럴. &lt;a href=&quot;#Number&quot;&gt;&lt;i&gt;숫자&lt;/i&gt;&lt;/a&gt; 는 배열의 길이입니다. &lt;a href=&quot;#Value&quot;&gt;&lt;i&gt;값은&lt;/i&gt;&lt;/a&gt; 반복 &lt;a href=&quot;#Number&quot;&gt;&lt;i&gt;수의&lt;/i&gt;&lt;/a&gt; 정규 어레이 회, 2 * &lt;a href=&quot;#Number&quot;&gt;&lt;i&gt;번호&lt;/i&gt;&lt;/a&gt; 연관 배열을위한 시간.</target>
        </trans-unit>
        <trans-unit id="039c70efd683d3e9b93b4df14d2d6d5c5145b436" translate="yes" xml:space="preserve">
          <source>An array that consists of &lt;code&gt;s&lt;/code&gt; repeated &lt;code&gt;n&lt;/code&gt; times. This function allocates, fills, and returns a new array.</source>
          <target state="translated">&lt;code&gt;n&lt;/code&gt; 번 반복되는 &lt;code&gt;s&lt;/code&gt; 로 구성된 배열입니다 . 이 함수는 새 배열을 할당하고 채우고 반환합니다.</target>
        </trans-unit>
        <trans-unit id="17d3bd6e24229484523be9a3c75e2496e09c2fce" translate="yes" xml:space="preserve">
          <source>An array which contains the program name as the zeroth element and any command-line arguments in the following elements.</source>
          <target state="translated">프로그램 이름을 0 번째 요소로 포함하고 다음 요소의 명령 줄 인수를 포함하는 배열입니다.</target>
        </trans-unit>
        <trans-unit id="1ab896a4e586f016dcbd9051e137d42864250451" translate="yes" xml:space="preserve">
          <source>An array which contains the program name as the zeroth element and any command-line arguments in the following elements. (See &lt;a href=&quot;#spawnProcess&quot;&gt;&lt;code&gt;spawnProcess&lt;/code&gt;&lt;/a&gt; for details.)</source>
          <target state="translated">프로그램 이름을 0 번째 요소로 포함하고 다음 요소의 명령 줄 인수를 포함하는 배열입니다. (자세한 내용은 &lt;a href=&quot;#spawnProcess&quot;&gt; &lt;code&gt;spawnProcess&lt;/code&gt; &lt;/a&gt; 를 참조하십시오.)</target>
        </trans-unit>
        <trans-unit id="3b92a8e452fa62db1566192e1dffdc9e80610f68" translate="yes" xml:space="preserve">
          <source>An array with the same element type as &lt;code&gt;s&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;s&lt;/code&gt; 와 동일한 요소 유형을 가진 배열입니다 .</target>
        </trans-unit>
        <trans-unit id="598dedc2bf0e9cd988bf5a32f1e674f47e9054d4" translate="yes" xml:space="preserve">
          <source>An asm statement enables the direct use of assembly language instructions. This makes it easy to obtain direct access to special CPU features without resorting to an external assembler. The D compiler will take care of the function calling conventions, stack setup, etc.</source>
          <target state="translated">asm 문을 사용하면 어셈블리 언어 명령어를 직접 사용할 수 있습니다. 따라서 외부 어셈블러를 사용하지 않고도 특수 CPU 기능에 직접 액세스 할 수 있습니다. D 컴파일러는 함수 호출 규칙, 스택 설정 등을 처리합니다.</target>
        </trans-unit>
        <trans-unit id="8302b7bfc189e1b4c0ac50685a98310945e13267" translate="yes" xml:space="preserve">
          <source>An associative array can be tested to see if an element is in the array:</source>
          <target state="translated">요소가 배열에 있는지 확인하기 위해 연관 배열을 테스트 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="63634bc46188cedd4498192107dab899f5055fcb" translate="yes" xml:space="preserve">
          <source>An associative array mapping elements to weights.</source>
          <target state="translated">요소를 가중치에 연결하는 연관 배열.</target>
        </trans-unit>
        <trans-unit id="ff67502c32274c3ab17b5bd51317488c7f9e8d17" translate="yes" xml:space="preserve">
          <source>An associative array of type &lt;code&gt;Target&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;Target&lt;/code&gt; 유형의 연관 배열</target>
        </trans-unit>
        <trans-unit id="956aeaeb58bfe5aa034cd122a587434b8ac88521" translate="yes" xml:space="preserve">
          <source>An attacker wants to send harmful data to your server, which requires a integrity HMAC SHA1 token signed with a secret.</source>
          <target state="translated">공격자는 서버에 유해한 데이터를 보내려고합니다.이를 위해서는 비밀로 서명 된 무결성 HMAC SHA1 토큰이 필요합니다.</target>
        </trans-unit>
        <trans-unit id="be28bdcc45d4da897969c562a4da4fd240bfaeb2" translate="yes" xml:space="preserve">
          <source>An attractive feature of UUIDs when compared to alternatives is their relative small size, of 128 bits, or 16 bytes. Another is that the creation of UUIDs does not require a centralized authority.</source>
          <target state="translated">대안과 비교할 때 UUID의 매력적인 기능은 상대적으로 작은 크기, 128 비트 또는 16 바이트입니다. 다른 하나는 UUID 작성에 중앙 권한이 필요하지 않다는 것입니다.</target>
        </trans-unit>
        <trans-unit id="7195e6cce01f1fb7dad70c303c1f8649fcd1f03b" translate="yes" xml:space="preserve">
          <source>An auto function is declared without a return type. If it does not already have a storage class, use the auto storage class.</source>
          <target state="translated">자동 함수는 반환 유형없이 선언됩니다. 스토리지 클래스가없는 경우 자동 스토리지 클래스를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="03d538bd3cecd7df878dcb400c90734b77cf2b23" translate="yes" xml:space="preserve">
          <source>An auto ref function template parameter becomes a ref parameter if its corresponding argument is an lvalue, otherwise it becomes a value parameter:</source>
          <target state="translated">자동 참조 함수 템플리트 매개 변수는 해당 인수가 lvalue이면 ref 매개 변수가되고, 그렇지 않으면 값 매개 변수가됩니다.</target>
        </trans-unit>
        <trans-unit id="14284ad6c006c28b3ea6130bf5b64152ddb04c86" translate="yes" xml:space="preserve">
          <source>An eager version of &lt;code&gt;splitter&lt;/code&gt; that creates an array with splitted slices of &lt;code&gt;input&lt;/code&gt;.</source>
          <target state="translated">분할 된 &lt;code&gt;input&lt;/code&gt; 조각으로 배열을 만드는 열성적인 &lt;code&gt;splitter&lt;/code&gt; 버전입니다 .</target>
        </trans-unit>
        <trans-unit id="9d74290ce6e26cbf9d133491fbe882725c8fd224" translate="yes" xml:space="preserve">
          <source>An earlier version of the documentation incorrectly stated that &lt;code&gt;-1&lt;/code&gt; is the only negative value returned and &lt;code&gt;1&lt;/code&gt; is the only positive value returned. Whether that is true depends on the types being compared.</source>
          <target state="translated">문서의 이전 버전에서는 &lt;code&gt;-1&lt;/code&gt; 이 반환 된 유일한 음수 값이고 &lt;code&gt;1&lt;/code&gt; 이 반환 된 유일한 양수 값 이라고 잘못 설명했습니다 . 이것이 사실인지 여부는 비교되는 유형에 따라 다릅니다.</target>
        </trans-unit>
        <trans-unit id="564af87619e62a538d43ce07aa464a50505648ac" translate="yes" xml:space="preserve">
          <source>An email status code, indicating if an email address is valid or not. If it is invalid it also indicates why.</source>
          <target state="translated">이메일 주소가 유효한지 여부를 나타내는 이메일 상태 코드. 유효하지 않은 경우도 그 이유를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="57821790126b7d9653db7d5ab96220cb8a8449b5" translate="yes" xml:space="preserve">
          <source>An embedded list builds a most-recently-used strategy: the most recent allocators used in calls to either &lt;code&gt;allocate&lt;/code&gt;, &lt;code&gt;owns&lt;/code&gt; (successful calls only), or &lt;code&gt;deallocate&lt;/code&gt; are tried for new allocations in order of their most recent use. Thus, although core operations take in theory &amp;Omicron;(&lt;code&gt;k&lt;/code&gt;) time for &lt;code&gt;k&lt;/code&gt; allocators in current use, in many workloads the factor is sublinear. Details of the actual strategy may change in future releases.</source>
          <target state="translated">내장 된 목록은 가장 최근에 사용 된 전략을 구축합니다. 가장 최근에 사용한 순서대로 &lt;code&gt;allocate&lt;/code&gt; , &lt;code&gt;owns&lt;/code&gt; (성공한 호출 만) 또는 &lt;code&gt;deallocate&lt;/code&gt; 호출에 사용 된 가장 최근 할당 자가 시도됩니다. 따라서 핵심 작업 은 현재 사용중인 &lt;code&gt;k&lt;/code&gt; 할당 자에 대해 이론적으로 &amp;Omicron; ( &lt;code&gt;k&lt;/code&gt; ) 시간이 걸리지 만 많은 워크로드에서 계수는 하위 선형입니다. 실제 전략의 세부 사항은 향후 릴리스에서 변경 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7e2d7c3c03945c2979ade27d1766c3427f23af71" translate="yes" xml:space="preserve">
          <source>An empty enum body (For example &lt;code&gt;enum E;&lt;/code&gt;) signifies an opaque enum - the enum members are unknown.</source>
          <target state="translated">빈 열거 형 본문 (예 : &lt;code&gt;enum E;&lt;/code&gt; )은 불투명 한 열거 형을 나타내며 열거 형 멤버를 알 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="182b823f47405fe4bd517067833d2431e24dcb91" translate="yes" xml:space="preserve">
          <source>An empty range.</source>
          <target state="translated">빈 범위입니다.</target>
        </trans-unit>
        <trans-unit id="1b60e63467d1ead57d7b824f987eda3203e244a7" translate="yes" xml:space="preserve">
          <source>An entire program can be written in &lt;b&gt;BetterC&lt;/b&gt; by supplying a C &lt;code&gt;main()&lt;/code&gt; function:</source>
          <target state="translated">C &lt;code&gt;main()&lt;/code&gt; 함수를 제공하여 &lt;b&gt;BetterC&lt;/b&gt; 로 전체 프로그램을 작성할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="42f22d22943ec9876daf38f246747335b3206a97" translate="yes" xml:space="preserve">
          <source>An enum can be implicitly converted to its base type, but going the other way requires an explicit conversion. For example:</source>
          <target state="translated">열거 형은 암시 적으로 기본 유형으로 변환 될 수 있지만 다른 방식으로 전환하려면 명시 적 변환이 필요합니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="20274664503ab2b78599fa35b2c6976d6732af22" translate="yes" xml:space="preserve">
          <source>An enum can have multiple members which have the same value. If you want to use EnumMembers to e.g. generate switch cases at compile-time, you should use the &lt;a href=&quot;std_meta#NoDuplicates&quot;&gt;&lt;code&gt;std.meta.NoDuplicates&lt;/code&gt;&lt;/a&gt; template to avoid generating duplicate switch cases.</source>
          <target state="translated">열거 형은 같은 값을 가진 여러 멤버를 가질 수 있습니다. 예를 들어 컴파일 타임에 스위치 케이스를 생성하기 위해 EnumMembers를 사용하려면 중복 스위치 케이스가 생성되지 않도록 &lt;a href=&quot;std_meta#NoDuplicates&quot;&gt; &lt;code&gt;std.meta.NoDuplicates&lt;/code&gt; &lt;/a&gt; 템플리트를 사용해야합니다 .</target>
        </trans-unit>
        <trans-unit id="9ccb5e54934db47a114cb48c08f87f6a9591ebdc" translate="yes" xml:space="preserve">
          <source>An enumerated type. &lt;code&gt;E&lt;/code&gt; may have duplicated values.</source>
          <target state="translated">열거 형입니다. &lt;code&gt;E&lt;/code&gt; 는 중복 된 값을 가질 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1735ccd74a7dfbde9ac3516d787c61e34b65fdd9" translate="yes" xml:space="preserve">
          <source>An environment without an operating system (such as Bare-metal targets)</source>
          <target state="translated">운영 체제가없는 환경 (예 : 베어 메탈 대상)</target>
        </trans-unit>
        <trans-unit id="f809d6288855134dff456bf6ac1c95f894cfd5e3" translate="yes" xml:space="preserve">
          <source>An error message supplied by the user.</source>
          <target state="translated">사용자가 제공 한 오류 메시지.</target>
        </trans-unit>
        <trans-unit id="22b5aeaf7859c416b77cbb971c1f98412c7e91a6" translate="yes" xml:space="preserve">
          <source>An even permutation is one which is produced by swapping an even number of pairs of elements in the original range. The set of</source>
          <target state="translated">짝수 순열은 원래 범위에서 짝수의 요소 쌍을 교체하여 생성되는 순열입니다. 세트</target>
        </trans-unit>
        <trans-unit id="bf3445745f98506a937cbbe828a5f495bdf57758" translate="yes" xml:space="preserve">
          <source>An example Scheduler using Fibers.</source>
          <target state="translated">파이버를 사용하는 스케줄러 예.</target>
        </trans-unit>
        <trans-unit id="c8895ad0e3d621b831278de48f37930b071bff33" translate="yes" xml:space="preserve">
          <source>An example Scheduler using kernel threads.</source>
          <target state="translated">커널 스레드를 사용하는 스케줄러 예제</target>
        </trans-unit>
        <trans-unit id="26be4513512b7649f788720ecf8495f76d5a5e27" translate="yes" xml:space="preserve">
          <source>An example using this might be:</source>
          <target state="translated">이것을 사용하는 예는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="8a9fd3843ecc8c2de2413f35d41e6dffcb1a7e0f" translate="yes" xml:space="preserve">
          <source>An exception that signals a problem with starting or waiting for a process.</source>
          <target state="translated">프로세스 시작 또는 대기와 관련된 문제를 나타내는 예외입니다.</target>
        </trans-unit>
        <trans-unit id="da1bd43b320d9d6951e218332ce5fe294afbcb16" translate="yes" xml:space="preserve">
          <source>An explicit &lt;code&gt;break&lt;/code&gt;/&lt;code&gt;continue&lt;/code&gt; label can be used to avoid this limitation. (Note that &lt;code&gt;static foreach&lt;/code&gt; itself cannot be broken nor continued even if it is explicitly labeled.)</source>
          <target state="translated">이 제한을 피하기 위해 명시 적 &lt;code&gt;break&lt;/code&gt; / &lt;code&gt;continue&lt;/code&gt; 레이블을 사용할 수 있습니다. (참고 &lt;code&gt;static foreach&lt;/code&gt; 자체가 깨진도 명시 적으로 표시되는 경우에도 계속 될 수 없습니다.)</target>
        </trans-unit>
        <trans-unit id="e4c419979ff292482ec7caed76ce12cf20cdff6d" translate="yes" xml:space="preserve">
          <source>An explicit seed may be provided as the first argument. If provided, it is used as the seed for all work units and for the final reduction of results from all work units. Therefore, if it is not the identity value for the operation being performed, results may differ from those generated by &lt;a href=&quot;std_algorithm_iteration#reduce&quot;&gt;&lt;code&gt;std.algorithm.iteration.reduce&lt;/code&gt;&lt;/a&gt; or depending on how many work units are used. The next argument must be the range to be reduced.</source>
          <target state="translated">첫 번째 인수로 명시 적 시드가 제공 될 수 있습니다. 제공되는 경우 모든 작업 단위의 시드로 사용되며 모든 작업 단위의 결과를 최종적으로 줄입니다. 따라서 수행중인 작업의 ID 값이 아닌 경우 결과는 &lt;a href=&quot;std_algorithm_iteration#reduce&quot;&gt; &lt;code&gt;std.algorithm.iteration.reduce&lt;/code&gt; 에&lt;/a&gt; 의해 생성 된 것과 다르거 나 사용 된 작업 단위 수에 따라 달라질 수 있습니다. 다음 인수는 축소 할 범위 여야합니다.</target>
        </trans-unit>
        <trans-unit id="813be4ff1857df0549bcdcfd3e08cf103fc4ef9a" translate="yes" xml:space="preserve">
          <source>An explicit work unit size may be specified as the last argument. Specifying too small a work unit size will effectively serialize the reduction, as the final reduction of the result of each work unit will dominate computation time. If &lt;code&gt;TaskPool.size&lt;/code&gt; for this instance is zero, this parameter is ignored and one work unit is used.</source>
          <target state="translated">마지막 작업 단위로 명시적인 작업 단위 크기를 지정할 수 있습니다. 작업 단위 크기를 너무 작게 지정하면 각 작업 단위 결과의 최종 축소가 계산 시간을 지배하므로 축소를 효과적으로 직렬화합니다. 경우 &lt;code&gt;TaskPool.size&lt;/code&gt; 이 인스턴스에 대한이 0이 매개 변수가 무시되고 하나의 작업 단위가 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="a0fd613c26e74a1b3f4e55de4f7a9e820062689a" translate="yes" xml:space="preserve">
          <source>An expression is a sequence of operators and operands that specifies an evaluation. The syntax, order of evaluation, and semantics of expressions are as follows.</source>
          <target state="translated">식은 평가를 지정하는 일련의 연산자 및 피연산자입니다. 표현의 구문, 평가 순서 및 의미는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="06fe4315b1fb38b822d67e7c040bc5b1f34c50c5" translate="yes" xml:space="preserve">
          <source>An expression may be converted from immutable to mutable if the expression is unique.</source>
          <target state="translated">표현식이 고유 한 경우 표현식이 변경 불가능에서 변경 가능으로 변환 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="405b72bbf5cd1ecea0f847f041852bc8f1e21267" translate="yes" xml:space="preserve">
          <source>An expression may be converted from mutable or shared to immutable if the expression is unique and all expressions it transitively refers to are either unique or immutable.</source>
          <target state="translated">표현식이 고유하고 전 이적으로 참조하는 모든 표현식이 고유하거나 불변 인 경우 표현식은 변경 가능하거나 공유 불가능으로 변환 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="038c4cfe80a0e1283f840551b0b9c6235c040703" translate="yes" xml:space="preserve">
          <source>An expression may be converted from mutable to shared if the expression is unique and all expressions it transitively refers to are either unique, immutable, or shared.</source>
          <target state="translated">표현식이 고유하고 전 이적으로 참조하는 모든 표현식이 고유하거나 불변이거나 공유 인 경우 표현식은 변경 가능에서 공유로 변환 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1316dd74d7c8ddd73ce90ec6a71f0202d5cfedc3" translate="yes" xml:space="preserve">
          <source>An expression may be converted from shared to mutable if the expression is unique.</source>
          <target state="translated">식이 고유 한 경우 식을 공유에서 변경 가능으로 변환 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2ed051b5f24cb3bdb14e7ca6dadf808a8182256e" translate="yes" xml:space="preserve">
          <source>An expression that contains no side effects.</source>
          <target state="translated">부작용이없는 표현식입니다.</target>
        </trans-unit>
        <trans-unit id="14b91d68f1409c403821f7e2395540ae4efe1e65" translate="yes" xml:space="preserve">
          <source>An expression that discards its result. If the argument is null or not a CommaExp, nothing happens.</source>
          <target state="translated">결과를 버리는 표현식입니다. 인수가 null이거나 CommaExp가 아닌 경우 아무 일도 일어나지 않습니다.</target>
        </trans-unit>
        <trans-unit id="2da87c9bf77a96f0a7e8a08472638759b2796da0" translate="yes" xml:space="preserve">
          <source>An identifier that corresponds to each static field in this struct will be placed in the identifier pool.</source>
          <target state="translated">이 구조체의 각 정적 필드에 해당하는 식별자가 식별자 풀에 배치됩니다.</target>
        </trans-unit>
        <trans-unit id="29be0b87cd939460b9a6e031fd7b9746d13400f2" translate="yes" xml:space="preserve">
          <source>An identity assignment overload is required for a struct if one or more of these conditions hold:</source>
          <target state="translated">다음 조건 중 하나 이상에 해당되는 경우 구조체에 ID 할당 과부하가 필요합니다.</target>
        </trans-unit>
        <trans-unit id="c62cfceef6921debd60c6c989b8a6621704ef9cf" translate="yes" xml:space="preserve">
          <source>An immutable or const type qualifier can be removed with a cast:</source>
          <target state="translated">불변 또는 const 유형 한정자는 캐스트로 제거 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1978b5c17c98e8bf28acd8b0134128096257bb6e" translate="yes" xml:space="preserve">
          <source>An implementation is free to perform heap compaction and copying so long as no valid GC pointers are invalidated in the process. However, memory allocated with &lt;code&gt;GC.BlkAttr.&lt;a href=&quot;#NO_MOVE&quot;&gt;NO_MOVE&lt;/a&gt;&lt;/code&gt; must not be moved/copied.</source>
          <target state="translated">프로세스에서 유효한 GC 포인터가 무효화되지 않는 한 구현은 힙 압축 및 복사를 자유롭게 수행 할 수 있습니다. 그러나 &lt;code&gt;GC.BlkAttr.&lt;a href=&quot;#NO_MOVE&quot;&gt;NO_MOVE&lt;/a&gt;&lt;/code&gt; 할당 된 메모리 . NO_MOVE 를 이동 / 복사해서는 안됩니다.</target>
        </trans-unit>
        <trans-unit id="f4a12d968ae65e1a6afdfd511c35a5dc8f841297" translate="yes" xml:space="preserve">
          <source>An implementation may assume that a &lt;code&gt;pure&lt;/code&gt; function that (a) accepts only parameters without mutable indirections, and (b) returns a result without mutable indirections, will have the same effect for all invocation with equivalent arguments, and is allowed to memoize the result of the function under the assumption that equivalent parameters always produce equivalent results. Such functions are termed</source>
          <target state="translated">구현은 (a) 가변적 인 디렉션없이 매개 변수 만 받아들이고 (b) 가변적 인 디렉션없이 결과를 반환하고, 동등한 인수를 가진 모든 호출에 대해 동일한 효과를 가지며, 결과를 기억할 수있는 &lt;code&gt;pure&lt;/code&gt; 함수 라고 가정 할 수 있습니다. 동등한 매개 변수는 항상 동등한 결과를 생성한다는 가정 하의 함수. 이러한 기능은</target>
        </trans-unit>
        <trans-unit id="ebe5dd05444d0198f9f66e793ceca70c1980b807" translate="yes" xml:space="preserve">
          <source>An implementation may construct the object or array instance on the stack. Therefore, it is an error to refer to that instance after the variadic function has returned:</source>
          <target state="translated">구현은 스택에 객체 또는 배열 인스턴스를 구성 할 수 있습니다. 따라서 variadic 함수가 반환 된 후 해당 인스턴스를 참조하는 것은 오류입니다.</target>
        </trans-unit>
        <trans-unit id="74288b66176460a92a66dcc8ea28e93696886600" translate="yes" xml:space="preserve">
          <source>An implementation may perform transformations on floating point computations in order to reduce their strength, i.e. their runtime computation time. Because floating point math does not precisely follow mathematical rules, some transformations are not valid, even though some other programming languages still allow them.</source>
          <target state="translated">구현은 강도, 즉 런타임 계산 시간을 줄이기 위해 부동 소수점 계산에 대해 변환을 수행 할 수 있습니다. 부동 소수점 수학은 수학 규칙을 정확하게 따르지 않기 때문에 일부 다른 프로그래밍 언어에서 여전히 허용하더라도 일부 변환은 유효하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="3ce778a63881d05f0438cdea7125a850f6f3ff60" translate="yes" xml:space="preserve">
          <source>An implementation may provide a means of overriding the cycle detection abort. A typical method uses the D Runtime switch &lt;code&gt;--DRT-oncycle=...&lt;/code&gt; where the following behaviors are supported:</source>
          <target state="translated">구현은 사이클 검출 중단을 무시하는 수단을 제공 할 수있다. 일반적인 방법은 다음과 같은 동작이 지원되는 D 런타임 스위치 &lt;code&gt;--DRT-oncycle=...&lt;/code&gt; 을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="29f794447dac8202e31e213bb8c23478c8aa558d" translate="yes" xml:space="preserve">
          <source>An implementation may rearrange the evaluation of expressions according to arithmetic associativity and commutativity rules as long as, within that thread of execution, no observable difference is possible.</source>
          <target state="translated">구현은 스레드의 실행 스레드 내에서 관찰 가능한 차이가없는 한 산술 연관성 및 정류 규칙에 따라 표현식의 평가를 재정렬 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2f7ecd52c6b042334def208ec0513d80f9a2a5ed" translate="yes" xml:space="preserve">
          <source>An import can be explicitly declared</source>
          <target state="translated">가져 오기는 명시 적으로 선언 될 수 있습니다</target>
        </trans-unit>
        <trans-unit id="38f4d49a07266de3b15530c1f9a75863df6ff329" translate="yes" xml:space="preserve">
          <source>An improved D function for formatted output is &lt;code&gt;std.stdio.writef()&lt;/code&gt;.</source>
          <target state="translated">형식화 된 출력을위한 개선 된 D 함수는 &lt;code&gt;std.stdio.writef()&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="f9cb97ce4508c3a47fa6274780fa6593ebb6be60" translate="yes" xml:space="preserve">
          <source>An infinity was generated by division by zero</source>
          <target state="translated">무한대는 0으로 나눈 값으로 생성되었습니다.</target>
        </trans-unit>
        <trans-unit id="6890806a1ad6818323e1006abea77b6b3d37709f" translate="yes" xml:space="preserve">
          <source>An infinity was generated by overflow</source>
          <target state="translated">오버플로에 의해 무한대가 생성되었습니다</target>
        </trans-unit>
        <trans-unit id="ae9c3bc7805fd7227432d2eaa0eab014f342aca5" translate="yes" xml:space="preserve">
          <source>An initialized &lt;code&gt;RefCounted&lt;/code&gt; containing &lt;code&gt;val&lt;/code&gt;.</source>
          <target state="translated">초기화 &lt;code&gt;RefCounted&lt;/code&gt; 포함 &lt;code&gt;val&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="87972790a4f1887f61efbff5428d42aa21b25d17" translate="yes" xml:space="preserve">
          <source>An inline comment that is ignored while matching.</source>
          <target state="translated">일치하는 동안 무시되는 인라인 주석입니다.</target>
        </trans-unit>
        <trans-unit id="85da1ce1be9cc229a0d38aa534ff7a6f98704992" translate="yes" xml:space="preserve">
          <source>An input range R as defined by &lt;a href=&quot;std_range_primitives#isInputRange&quot;&gt;&lt;code&gt;std.range.primitives.isInputRange&lt;/code&gt;&lt;/a&gt;. When &lt;code&gt;Contents&lt;/code&gt; is a struct, class, or an associative array, the element type of R is &lt;code&gt;Contents&lt;/code&gt;, otherwise the element type of R is itself a range with element type &lt;code&gt;Contents&lt;/code&gt;.  If a &lt;code&gt;header&lt;/code&gt; argument is provided, the returned range provides a &lt;code&gt;header&lt;/code&gt; field for accessing the header from the input in array form.</source>
          <target state="translated">뿐만 의해 정의 된 입력 범위 R &lt;a href=&quot;std_range_primitives#isInputRange&quot;&gt; &lt;code&gt;std.range.primitives.isInputRange&lt;/code&gt; &lt;/a&gt; . 경우 &lt;code&gt;Contents&lt;/code&gt; 구조체, 클래스, 또는 연관 배열이고, R의 요소 유형은 &lt;code&gt;Contents&lt;/code&gt; 달리 R의 요소 유형은 요소 자체의 유형과 범위이고, &lt;code&gt;Contents&lt;/code&gt; . 경우 &lt;code&gt;header&lt;/code&gt; 인수가 제공되고, 반환 범위가 제공 &lt;code&gt;header&lt;/code&gt; 어레이 형태의 입력에서 헤더를 액세스하기위한 필드.</target>
        </trans-unit>
        <trans-unit id="8233ac502082d5effa82f80dbc2e0cac66b1db40" translate="yes" xml:space="preserve">
          <source>An input range at minimum. If all of the ranges in &lt;code&gt;rs&lt;/code&gt; provide a range primitive, the returned range will also provide that range primitive.</source>
          <target state="translated">최소 입력 범위. &lt;code&gt;rs&lt;/code&gt; 의 모든 범위 가 범위 기본을 제공하는 경우 반환 된 범위는 해당 범위 기본도 제공합니다.</target>
        </trans-unit>
        <trans-unit id="e7168e31c32e5919f60149f7ae2d8c075d8657c9" translate="yes" xml:space="preserve">
          <source>An input range of random access ranges</source>
          <target state="translated">랜덤 액세스 범위의 입력 범위</target>
        </trans-unit>
        <trans-unit id="e8adc363777a6afb1445324ba10df4840c08d231" translate="yes" xml:space="preserve">
          <source>An input range of the subranges of elements between separators. If &lt;code&gt;r&lt;/code&gt; is a &lt;a href=&quot;std_range_primitives#isForwardRange&quot;&gt;forward range&lt;/a&gt; or &lt;a href=&quot;std_range_primitives#isBidirectionalRange&quot;&gt;bidirectional range&lt;/a&gt;, the returned range will be likewise. When a range is used a separator, bidirectionality isn't possible.  If an empty range is given, the result is an empty range. If a range with one separator is given, the result is a range with two empty elements.</source>
          <target state="translated">구분 기호 사이의 요소 하위 범위의 입력 범위입니다. 경우 &lt;code&gt;r&lt;/code&gt; A는 &lt;a href=&quot;std_range_primitives#isForwardRange&quot;&gt;전진 기어&lt;/a&gt; 또는 &lt;a href=&quot;std_range_primitives#isBidirectionalRange&quot;&gt;양방향 범위&lt;/a&gt; , 반환 범위는 마찬가지 일 것이다. 범위를 구분 기호로 사용하면 양방향성이 불가능합니다. 빈 범위가 제공되면 결과는 빈 범위입니다. 하나의 구분 기호가있는 범위가 제공되면 결과는 두 개의 빈 요소가있는 범위입니다.</target>
        </trans-unit>
        <trans-unit id="77fcb0b8936d71a377fcbb398a2e222509a71db3" translate="yes" xml:space="preserve">
          <source>An input range representing the results of the map. This range has a length iff &lt;code&gt;source&lt;/code&gt; has a length.</source>
          <target state="translated">지도 결과를 나타내는 입력 범위입니다. 이 범위의 길이 는 &lt;code&gt;source&lt;/code&gt; 의 길이가 다릅니다 .</target>
        </trans-unit>
        <trans-unit id="e3ed7a93b1ad11aa4211044600bdb3f20f6462d6" translate="yes" xml:space="preserve">
          <source>An input range that offers the elements of &lt;code&gt;inputRange&lt;/code&gt;. Regardless of whether &lt;code&gt;inputRange&lt;/code&gt; is a more powerful range (forward, bidirectional etc), the result is always an input range. Reading this causes &lt;code&gt;inputRange&lt;/code&gt; to be iterated and returns its elements in turn. In addition, the same elements will be passed to &lt;code&gt;outputRange&lt;/code&gt; or &lt;code&gt;fun&lt;/code&gt; as well.</source>
          <target state="translated">&lt;code&gt;inputRange&lt;/code&gt; 의 요소를 제공하는 입력 범위입니다 . &lt;code&gt;inputRange&lt;/code&gt; 가 더 강력한 범위 (앞으로, 양방향 등) 인지 여부에 관계없이 결과는 항상 입력 범위입니다. 이것을 &lt;code&gt;inputRange&lt;/code&gt; 가 반복되고 요소가 차례로 리턴됩니다. 또한 동일한 요소가 &lt;code&gt;outputRange&lt;/code&gt; 또는 &lt;code&gt;fun&lt;/code&gt; 에 전달됩니다 .</target>
        </trans-unit>
        <trans-unit id="8db0e5d660666f379e5bd5033aea5532a4a6d755" translate="yes" xml:space="preserve">
          <source>An input range, or a single element, to join the ranges on</source>
          <target state="translated">범위를 결합 할 입력 범위 또는 단일 요소</target>
        </trans-unit>
        <trans-unit id="53e41ba736cd23d712f10ab5d4286f8a49bbcc4b" translate="yes" xml:space="preserve">
          <source>An instance of &lt;code&gt;BoyerMooreFinder&lt;/code&gt; that can be used with &lt;code&gt;find()&lt;/code&gt; to invoke the Boyer-Moore matching algorithm for finding of &lt;code&gt;needle&lt;/code&gt; in a given haystack.</source>
          <target state="translated">&lt;code&gt;find()&lt;/code&gt; 와 함께 사용 하여 지정된 건초 더미에서 &lt;code&gt;needle&lt;/code&gt; 을 찾기 위해 Boyer-Moore 일치 알고리즘을 호출 할 수있는 &lt;code&gt;BoyerMooreFinder&lt;/code&gt; 의 인스턴스입니다 .</target>
        </trans-unit>
        <trans-unit id="082c7f6d5b0afa12e8dd042a23683a443fd1ed5f" translate="yes" xml:space="preserve">
          <source>An instance of &lt;code&gt;RefCounted&lt;/code&gt; is a reference to a structure, which is referred to as the</source>
          <target state="translated">&lt;code&gt;RefCounted&lt;/code&gt; 의 인스턴스는 구조 에 대한 참조이며</target>
        </trans-unit>
        <trans-unit id="81dfbeaffbeddcdca676ca9f6b1f01a2e767b7b5" translate="yes" xml:space="preserve">
          <source>An instance of Class called ClassXXXX.</source>
          <target state="translated">ClassXXXX라는 Class 인스턴스.</target>
        </trans-unit>
        <trans-unit id="df7f1cf5303035f4982248b96ae7f8dcd8dbd36d" translate="yes" xml:space="preserve">
          <source>An instance of ModuleInfo is generated into the object file for each compiled module.</source>
          <target state="translated">컴파일 된 각 모듈의 오브젝트 파일에 ModuleInfo 인스턴스가 생성됩니다.</target>
        </trans-unit>
        <trans-unit id="0af1d2f763a9f835d30a298bd5512f1a1ecb310d" translate="yes" xml:space="preserve">
          <source>An instance of Rebindable!T.</source>
          <target state="translated">Rebindable! T의 인스턴스</target>
        </trans-unit>
        <trans-unit id="f20d76f76289925279727351d584459074c5f577" translate="yes" xml:space="preserve">
          <source>An instance of StaticClassXXXX called StaticXXXX for the static members.</source>
          <target state="translated">정적 멤버에 대해 StaticXXXX라는 StaticClassXXXX 인스턴스입니다.</target>
        </trans-unit>
        <trans-unit id="7588661ba7457b5448344cfc895cdb3b665fc0e3" translate="yes" xml:space="preserve">
          <source>An instance of an interface cannot be created.</source>
          <target state="translated">인터페이스 인스턴스를 작성할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="f9fe6552b2cda57271319df5e41efc135feb5083" translate="yes" xml:space="preserve">
          <source>An integer literal may not exceed those values.</source>
          <target state="translated">정수 리터럴은 해당 값을 초과 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="3dd1eb0e6607d6d3937d482192de7ee283f310ab" translate="yes" xml:space="preserve">
          <source>An interface is a pointer to a pointer to a vtbl[]. The vtbl[0] entry is a pointer to the corresponding instance of the object.Interface class. The rest of the &lt;code&gt;vtbl[1..$]&lt;/code&gt; entries are pointers to the virtual functions implemented by that interface, in the order that they were declared.</source>
          <target state="translated">인터페이스는 vtbl []에 대한 포인터를 가리키는 포인터입니다. vtbl [0] 항목은 object.Interface 클래스의 해당 인스턴스에 대한 포인터입니다. 나머지 &lt;code&gt;vtbl[1..$]&lt;/code&gt; 항목은 선언 된 순서대로 해당 인터페이스에 의해 구현 된 가상 함수에 대한 포인터입니다.</target>
        </trans-unit>
        <trans-unit id="f535852beda0178c415bc9fa63dbe96b52f5fffb" translate="yes" xml:space="preserve">
          <source>An interface to a pipe created by the &lt;a href=&quot;#pipe&quot;&gt;&lt;code&gt;pipe&lt;/code&gt;&lt;/a&gt; function.</source>
          <target state="translated">&lt;a href=&quot;#pipe&quot;&gt; &lt;code&gt;pipe&lt;/code&gt; &lt;/a&gt; 함수로 작성된 파이프에 대한 인터페이스 입니다.</target>
        </trans-unit>
        <trans-unit id="ab4113213830fe7d72486bf84fdb4481ba6c3903" translate="yes" xml:space="preserve">
          <source>An interior pointer to the allocated memory block is sufficient to let the GC know the object is in use; i.e. it is not necessary to maintain a pointer to the</source>
          <target state="translated">할당 된 메모리 블록에 대한 내부 포인터는 객체가 사용 중임을 GC에 알리기에 충분합니다. 즉, 포인터를 유지할 필요는 없습니다.</target>
        </trans-unit>
        <trans-unit id="e468e9d85b8c7d660b637f4814b9ebc7dd018028" translate="yes" xml:space="preserve">
          <source>An interior pointer to the allocated memory block is sufficient to let the GC know the object is in use; i.e. it is not necessary to maintain a pointer to the beginning of the allocated memory.</source>
          <target state="translated">할당 된 메모리 블록에 대한 내부 포인터는 객체가 사용 중임을 GC에 알리기에 충분합니다. 즉, 할당 된 메모리의 시작에 대한 포인터를 유지할 필요가 없습니다.</target>
        </trans-unit>
        <trans-unit id="f380906d548143bc93c92fea41836178dba951d1" translate="yes" xml:space="preserve">
          <source>An invalid IPv4 host address.</source>
          <target state="translated">유효하지 않은 IPv4 호스트 주소입니다.</target>
        </trans-unit>
        <trans-unit id="5c151927ff98085446422d3ef9db66acbb3009ff" translate="yes" xml:space="preserve">
          <source>An invalid memory operation error occurs in circumstances when the garbage collector has detected an operation it cannot reliably handle. The default D GC is not re-entrant, so this can happen due to allocations done from within finalizers called during a garbage collection cycle.</source>
          <target state="translated">가비지 수집기가 안정적으로 처리 할 수없는 작업을 감지 한 상황에서 잘못된 메모리 작업 오류가 발생합니다. 기본 D GC는 재진입 할 ​​수 없으므로 가비지 콜렉션주기 동안 호출 된 종료 자 내에서 할당이 수행되어 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7e1ca0b5740cb0c049a4626d36738a30cd09bcf8" translate="yes" xml:space="preserve">
          <source>An new array with the same element type as &lt;code&gt;s&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;s&lt;/code&gt; 와 동일한 요소 유형을 가진 새로운 배열 .</target>
        </trans-unit>
        <trans-unit id="b9a13417415c3a89c1b29b77e22f2e53079843b6" translate="yes" xml:space="preserve">
          <source>An object consists of:</source>
          <target state="translated">객체는 다음으로 구성됩니다.</target>
        </trans-unit>
        <trans-unit id="4aafa70d4d827025493d92426cb1881df221dd19" translate="yes" xml:space="preserve">
          <source>An object describing the current calling context or null if no handler is supplied.</source>
          <target state="translated">현재 호출 컨텍스트를 설명하는 객체이거나 핸들러가 제공되지 않으면 null입니다.</target>
        </trans-unit>
        <trans-unit id="5be2f170166a5ab81d9f7b1c1bbe46754996b242" translate="yes" xml:space="preserve">
          <source>An object, interface, array slice type, or associative array type.</source>
          <target state="translated">객체, 인터페이스, 배열 슬라이스 유형 또는 연관 배열 유형</target>
        </trans-unit>
        <trans-unit id="46658cef8915a535dc984d5da9a05cb48f404327" translate="yes" xml:space="preserve">
          <source>An opaque type used to represent a logical thread.</source>
          <target state="translated">논리 스레드를 나타내는 데 사용되는 불투명 한 유형입니다.</target>
        </trans-unit>
        <trans-unit id="ac93278e9eecd73148f8d1da8ce3975a03dbd346" translate="yes" xml:space="preserve">
          <source>An operating system handle to the process.</source>
          <target state="translated">프로세스에 대한 운영 체제 핸들</target>
        </trans-unit>
        <trans-unit id="6f1bf7d22dd547a7812632d87cd15c2924db734c" translate="yes" xml:space="preserve">
          <source>An option can be bound to a function or delegate with the signature &lt;code&gt;void function()&lt;/code&gt;, &lt;code&gt;void function(string option)&lt;/code&gt;, &lt;code&gt;void function(string option, string value)&lt;/code&gt;, or their delegate equivalents.</source>
          <target state="translated">옵션은 서명 &lt;code&gt;void function()&lt;/code&gt; , &lt;code&gt;void function(string option)&lt;/code&gt; , &lt;code&gt;void function(string option, string value)&lt;/code&gt; 또는 이와 동등한 대리자를 사용하여 함수 또는 대리자에 바인딩 될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="2b5227e5d32ce42de170098574202aa25566b464" translate="yes" xml:space="preserve">
          <source>An option can be marked as required. If that option is not present in the arguments an exception will be thrown.</source>
          <target state="translated">옵션은 필요에 따라 표시 할 수 있습니다. 해당 옵션이 인수에 없으면 예외가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="62587f93049001b563bb61577949d667674822d9" translate="yes" xml:space="preserve">
          <source>An option to create &lt;a href=&quot;#FileLogger&quot;&gt;&lt;code&gt;FileLogger&lt;/code&gt;&lt;/a&gt; directory if it is non-existent.</source>
          <target state="translated">존재하지 않는 경우 &lt;a href=&quot;#FileLogger&quot;&gt; &lt;code&gt;FileLogger&lt;/code&gt; &lt;/a&gt; 디렉토리 를 작성하는 옵션 입니다.</target>
        </trans-unit>
        <trans-unit id="64ee06f639f325adeda208d2447a973be665d9e1" translate="yes" xml:space="preserve">
          <source>An optional &lt;code&gt;header&lt;/code&gt; can be provided. The first record will be read in as the header. If &lt;code&gt;Contents&lt;/code&gt; is a struct then the header provided is expected to correspond to the fields in the struct. When &lt;code&gt;Contents&lt;/code&gt; is not a type which can contain the entire record, the &lt;code&gt;header&lt;/code&gt; must be provided in the same order as the input or an exception is thrown.</source>
          <target state="translated">선택적인 &lt;code&gt;header&lt;/code&gt; 가 제공 될 수 있습니다. 첫 번째 레코드는 헤더로 읽습니다. 경우 &lt;code&gt;Contents&lt;/code&gt; 구조체 인 다음에서 제공하는 헤더는 구조체의 필드에 해당 할 것으로 예상된다. 경우 &lt;code&gt;Contents&lt;/code&gt; 전체 레코드를 포함 할 수있는 형태가 아닌 상기 &lt;code&gt;header&lt;/code&gt; 상기 입력과 같은 순서로 제공해야 또는 예외가 발생된다.</target>
        </trans-unit>
        <trans-unit id="c541908f1a9f1491cf9b9d292e345a7480fb7a54" translate="yes" xml:space="preserve">
          <source>An optional destination buffer.</source>
          <target state="translated">선택적 대상 버퍼.</target>
        </trans-unit>
        <trans-unit id="8208436747ee5979d41650c17a37d3a20bbfe83b" translate="yes" xml:space="preserve">
          <source>An optional list of strings naming each successive field of the &lt;code&gt;Tuple&lt;/code&gt; or a list of types that the elements are being casted to. For a list of names, each name matches up with the corresponding field given by &lt;code&gt;Args&lt;/code&gt;. A name does not have to be provided for every field, but as the names must proceed in order, it is not possible to skip one field and name the next after it. For a list of types, there must be exactly as many types as parameters.</source>
          <target state="translated">&lt;code&gt;Tuple&lt;/code&gt; 의 각 연속 필드를 명명하는 선택적 문자열 목록 또는 요소가 캐스트되는 유형 목록. 이름 목록의 경우 각 이름은 &lt;code&gt;Args&lt;/code&gt; 에서 제공 한 해당 필드와 일치합니다 . 모든 필드에 이름을 제공 할 필요는 없지만, 순서대로 진행해야하므로 한 필드를 건너 뛰고 다음 필드의 이름을 지정할 수 없습니다. 유형 목록의 경우 매개 변수만큼 유형이 정확하게 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="301d753d609aee359b108ee54a2daf0751f4373a" translate="yes" xml:space="preserve">
          <source>An optional suffix to be removed from the file name.</source>
          <target state="translated">파일 이름에서 제거 할 선택적 접미사입니다.</target>
        </trans-unit>
        <trans-unit id="bbb578323324900d1fe9af43a6b6b06a406772b4" translate="yes" xml:space="preserve">
          <source>An output range for returning the results may be provided as the last argument. If one is not provided, an array of the proper type will be allocated on the garbage collected heap. If one is provided, it must be a random access range with assignable elements, must have reference semantics with respect to assignment to its elements, and must have the same length as the input range. Writing to adjacent elements from different threads must be safe.</source>
          <target state="translated">결과를 반환하기위한 출력 범위가 마지막 인수로 제공 될 수 있습니다. 하나를 제공하지 않으면 적절한 유형의 배열이 가비지 수집 힙에 할당됩니다. 하나가 제공되는 경우, 지정 가능한 요소가있는 임의 액세스 범위 여야하고 해당 요소에 대한 지정과 관련하여 참조 의미가 있어야하며 입력 범위와 길이가 같아야합니다. 다른 스레드에서 인접한 요소에 쓰는 것은 안전해야합니다.</target>
        </trans-unit>
        <trans-unit id="481df4f9db6b7c39f75ab8b5d8402946a05557b9" translate="yes" xml:space="preserve">
          <source>An output range that discards the data it receives.</source>
          <target state="translated">수신 한 데이터를 버리는 출력 범위.</target>
        </trans-unit>
        <trans-unit id="01b526186c983c89501e19ff25742faa0abd686c" translate="yes" xml:space="preserve">
          <source>An output range to write the contents to.</source>
          <target state="translated">내용을 쓸 출력 범위입니다.</target>
        </trans-unit>
        <trans-unit id="6ec96a76a1b7b768707aea157270f72d702aae35" translate="yes" xml:space="preserve">
          <source>An uninitialized &lt;code&gt;Variant&lt;/code&gt; is used in any way except assignment and &lt;code&gt;hasValue&lt;/code&gt;;</source>
          <target state="translated">초기화되지 않은 &lt;code&gt;Variant&lt;/code&gt; 은 assignment와 &lt;code&gt;hasValue&lt;/code&gt; 를 제외하고 어떤 식 으로든 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="017d1765237968f656e289b4e56677bea3baad1b" translate="yes" xml:space="preserve">
          <source>An uninitialized value, generated from void initializers.</source>
          <target state="translated">void 초기화 프로그램에서 생성 된 초기화되지 않은 값입니다.</target>
        </trans-unit>
        <trans-unit id="6d865e1b843ed22f5ad95224465f066dd3bf97cd" translate="yes" xml:space="preserve">
          <source>An unqualified postblit will get called even if the struct is instantiated as &lt;code&gt;immutable&lt;/code&gt; or &lt;code&gt;const&lt;/code&gt;, but the compiler issues an error if the struct is instantiated as &lt;code&gt;shared&lt;/code&gt;:</source>
          <target state="translated">구조체가 &lt;code&gt;immutable&lt;/code&gt; 또는 &lt;code&gt;const&lt;/code&gt; 로 인스턴스화 되어도 정규화되지 않은 포스트 블릿이 호출 되지만 구조체가 &lt;code&gt;shared&lt;/code&gt; 로 인스턴스화되면 컴파일러에서 오류가 발생합니다 .</target>
        </trans-unit>
        <trans-unit id="02377b58a34c4a8ec19952d46cd99f893c878ed8" translate="yes" xml:space="preserve">
          <source>An unrecognized command-line argument is passed, and &lt;code&gt;std.getopt.config.passThrough&lt;/code&gt; was not present.</source>
          <target state="translated">인식 할 수없는 명령 행 인수가 전달되었으며 &lt;code&gt;std.getopt.config.passThrough&lt;/code&gt; 가 없습니다.</target>
        </trans-unit>
        <trans-unit id="355743baaf25b39e6a1bf6c9a0897a53f7ca51a0" translate="yes" xml:space="preserve">
          <source>An unrecognized option such as &quot;--baz&quot; will be found untouched in &lt;code&gt;args&lt;/code&gt; after &lt;code&gt;getopt&lt;/code&gt; returns.</source>
          <target state="translated">&quot;--baz&quot;와 같은 인식 할 수없는 옵션은 &lt;code&gt;getopt&lt;/code&gt; 가 반환 된 후에 &lt;code&gt;args&lt;/code&gt; 에서 수정되지 않은 것으로 발견됩니다 .</target>
        </trans-unit>
        <trans-unit id="b75455d22427a9d7061b91a6aa632f59812aa7cb" translate="yes" xml:space="preserve">
          <source>Analogously to class templates, struct, union and interfaces can be transformed into templates by supplying a template parameter list.</source>
          <target state="translated">클래스 템플릿과 마찬가지로 템플릿 매개 변수 목록을 제공하여 구조체, 공용체 및 인터페이스를 템플릿으로 변환 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="381d6919b76a155cc3d0bed8744ee2e82e29874b" translate="yes" xml:space="preserve">
          <source>Analogously, &lt;code&gt;typeof(super)&lt;/code&gt; will generate the type of what &lt;code&gt;super&lt;/code&gt; would be in a non-static member function.</source>
          <target state="translated">마찬가지로 &lt;code&gt;typeof(super)&lt;/code&gt; 는 비 정적 멤버 함수에있는 &lt;code&gt;super&lt;/code&gt; 의 유형을 생성합니다 .</target>
        </trans-unit>
        <trans-unit id="e760dd880de0f515f576dc77edef82d0231e14ae" translate="yes" xml:space="preserve">
          <source>Ancient Greek Musical Notation</source>
          <target state="translated">고대 그리스 음악 표기법</target>
        </trans-unit>
        <trans-unit id="aac24095b26055100b3e137537a2c7e0ad932e04" translate="yes" xml:space="preserve">
          <source>Ancient Greek Numbers</source>
          <target state="translated">고대 그리스 숫자</target>
        </trans-unit>
        <trans-unit id="3550f110a8c69b086b7eac12c46c400773c345dc" translate="yes" xml:space="preserve">
          <source>Ancient Symbols</source>
          <target state="translated">고대의 상징</target>
        </trans-unit>
        <trans-unit id="29bd442643bea5b50cf62a67104dd1d1aa8f0d1e" translate="yes" xml:space="preserve">
          <source>And Expressions</source>
          <target state="translated">그리고 표현</target>
        </trans-unit>
        <trans-unit id="955032d49b799cc6cb579cffbe0f243b5d0f3d5f" translate="yes" xml:space="preserve">
          <source>And all the summary sections will now be green.</source>
          <target state="translated">이제 모든 요약 섹션이 녹색으로 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="e67c2d4e000dc2740dc758b29287dd9038d89a6b" translate="yes" xml:space="preserve">
          <source>And an example of D code providing a callback to C code:</source>
          <target state="translated">그리고 C 코드에 대한 콜백을 제공하는 D 코드의 예는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="028627a78221787a21142d8d33379cef0d471467" translate="yes" xml:space="preserve">
          <source>AndAnd Expressions</source>
          <target state="translated">AndAnd 표현식</target>
        </trans-unit>
        <trans-unit id="d132739724126beb0a58639e9a6156fdf0949d66" translate="yes" xml:space="preserve">
          <source>AndAndExpression</source>
          <target state="translated">AndAndExpression</target>
        </trans-unit>
        <trans-unit id="b25772e958c7000fd371337d6359418dab3becfa" translate="yes" xml:space="preserve">
          <source>Andrei Alexandrescu</source>
          <target state="translated">안드레이 알렉산더 스쿠</target>
        </trans-unit>
        <trans-unit id="8086e1eeb4770ea0dab8abf60035423c0a58a5b4" translate="yes" xml:space="preserve">
          <source>Andrei Alexandrescu's article &lt;a href=&quot;http://www.informit.com/articles/printerfriendly.aspx?p=1407357&amp;amp;rll=1&quot;&gt; &lt;i&gt;On Iteration&lt;/i&gt;&lt;/a&gt; for conceptual aspect of ranges and the motivation</source>
          <target state="translated">Andrei Alexandrescu의 기사 범위와 개념 동기에 대한 &lt;a href=&quot;http://www.informit.com/articles/printerfriendly.aspx?p=1407357&amp;amp;rll=1&quot;&gt;&lt;i&gt;반복에&lt;/i&gt;&lt;/a&gt; 관한 기사 &lt;i&gt;&lt;/i&gt;</target>
        </trans-unit>
        <trans-unit id="1928f95c598b9e69462fcb512625cf8e28923044" translate="yes" xml:space="preserve">
          <source>Android</source>
          <target state="translated">Android</target>
        </trans-unit>
        <trans-unit id="b803b58141bc58845f04cfa8646ac85f1f1a979d" translate="yes" xml:space="preserve">
          <source>Anonymous Enums</source>
          <target state="translated">익명 열거 형</target>
        </trans-unit>
        <trans-unit id="7ccd2afbc983959f9583ca7f31cb4e5cf46494d9" translate="yes" xml:space="preserve">
          <source>Anonymous Functions and Anonymous Delegates</source>
          <target state="translated">익명의 기능 및 익명의 대리인</target>
        </trans-unit>
        <trans-unit id="98a2443b6da1909f7a102e64a4964e0f390eb397" translate="yes" xml:space="preserve">
          <source>Anonymous Nested Classes</source>
          <target state="translated">익명의 중첩 클래스</target>
        </trans-unit>
        <trans-unit id="46249cc944aedcf50eaf15b7e810784027798c68" translate="yes" xml:space="preserve">
          <source>Anonymous delegates can behave like arbitrary statement literals. For example, here an arbitrary statement is executed by a loop:</source>
          <target state="translated">익명 대리자는 임의의 문 리터럴처럼 동작 할 수 있습니다. 예를 들어, 임의의 명령문은 루프에 의해 실행됩니다.</target>
        </trans-unit>
        <trans-unit id="e1acf88a52df3795f2b20ed6511eee7ceb7ec305" translate="yes" xml:space="preserve">
          <source>Another caveat of using sub-matcher is that skip is not available preciesly because sub-matcher doesn't detect all lengths.</source>
          <target state="translated">하위 매처를 사용할 때의 또 다른 경고는 하위 매 처가 모든 길이를 감지하지 않기 때문에 건너 뛰기를 미리 사용할 수 없다는 것입니다.</target>
        </trans-unit>
        <trans-unit id="9a60f4e1a9ef014cfadbb26ea290e8c3eb775ed4" translate="yes" xml:space="preserve">
          <source>Another event handling module</source>
          <target state="translated">다른 이벤트 처리 모듈</target>
        </trans-unit>
        <trans-unit id="bae2455d3699406c3641a5d660465c6bf6758fc6" translate="yes" xml:space="preserve">
          <source>Another example of formatting a &lt;code&gt;struct&lt;/code&gt; with a defined &lt;code&gt;toString&lt;/code&gt;, this time using the &lt;code&gt;scope delegate&lt;/code&gt; method.  This method is now discouraged for non-virtual functions. If possible, please use the output range method instead.</source>
          <target state="translated">정의 된 &lt;code&gt;toString&lt;/code&gt; 으로 &lt;code&gt;struct&lt;/code&gt; 를 형식화하는 또 다른 예는 이번에는 &lt;code&gt;scope delegate&lt;/code&gt; 메소드를 사용합니다 . 이 방법은 이제 비가 상 기능에는 사용하지 않는 것이 좋습니다. 가능하면 출력 범위 방법을 대신 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="322444d3bb52c341f429ca0454f292dc242f315b" translate="yes" xml:space="preserve">
          <source>Any</source>
          <target state="translated">Any</target>
        </trans-unit>
        <trans-unit id="85e6f644dc8e5726c5821532bf00eff211afd4d4" translate="yes" xml:space="preserve">
          <source>Any &lt;a href=&quot;#LName&quot;&gt;&lt;i&gt;LName&lt;/i&gt;&lt;/a&gt; or non-basic &lt;a href=&quot;#Type&quot;&gt;&lt;i&gt;Type&lt;/i&gt;&lt;/a&gt; (i.e. any type that does not encode as a fixed one or two character sequence) that has been emitted to the mangled symbol before will not be emitted again, but is referenced by a special sequence encoding the relative position of the original occurrence in the mangled symbol name.</source>
          <target state="translated">모든 &lt;a href=&quot;#LName&quot;&gt;&lt;i&gt;LNAME&lt;/i&gt;&lt;/a&gt; 또는 비 기본 &lt;a href=&quot;#Type&quot;&gt;&lt;i&gt;유형&lt;/i&gt;&lt;/a&gt; (즉, 고정 된 하나 개 또는 두 개의 문자 시퀀스로하지 않는 인코딩 모든 종류의) 다시 방출되지 않습니다 전에 망가 기호로 배출되었지만, 상대적 위치를 코딩하는 특별한 순서에 의해 참조 맹 글링 된 심볼 이름에서 원래 발생</target>
        </trans-unit>
        <trans-unit id="a4ebed2ed3fe69fdf17bf0f9ea8120a1a0f126ed" translate="yes" xml:space="preserve">
          <source>Any &lt;code&gt;pure&lt;/code&gt; function that is not strongly pure cannot be assumed to be memoizable, and calls to it may not be elided even if it returns &lt;code&gt;void&lt;/code&gt; (save for compiler optimizations that prove the function has no effect). Function calls may still be elided, or results be memoized, by means of traditional inlining and optimization techniques available for all functions.</source>
          <target state="translated">모든 &lt;code&gt;pure&lt;/code&gt; 강하게 순수하지 않다 기능은 memoizable로 간주 될 수 있고, 호출은 반환 경우에도 생략 할 수 없습니다 &lt;code&gt;void&lt;/code&gt; (함수가 적용되지 않습니다 증명 컴파일러 최적화를위한 저장). 모든 함수에 사용할 수있는 기존의 인라인 및 최적화 기술을 통해 함수 호출을 제거하거나 결과를 메모 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="eb9050538a91f8603d45e66e05f6aeeb1d29c1a1" translate="yes" xml:space="preserve">
          <source>Any CSV input</source>
          <target state="translated">모든 CSV 입력</target>
        </trans-unit>
        <trans-unit id="3dd20dd36e01004b82e2eb3d1b7678c47e9521c9" translate="yes" xml:space="preserve">
          <source>Any IPv4 host address.</source>
          <target state="translated">모든 IPv4 호스트 주소</target>
        </trans-unit>
        <trans-unit id="8aed77784e6588d748089e680321e31de462e28c" translate="yes" xml:space="preserve">
          <source>Any IPv4 port number.</source>
          <target state="translated">모든 IPv4 포트 번호</target>
        </trans-unit>
        <trans-unit id="bb484c1e8a46997e29e20927039aa9b377327c02" translate="yes" xml:space="preserve">
          <source>Any IPv6 host address.</source>
          <target state="translated">모든 IPv6 호스트 주소</target>
        </trans-unit>
        <trans-unit id="94c6cca2615cd31987c71c42944c48bb96956b95" translate="yes" xml:space="preserve">
          <source>Any IPv6 port number.</source>
          <target state="translated">모든 IPv6 포트 번호</target>
        </trans-unit>
        <trans-unit id="1e80ff69d9bdfebf77e41c7bd69caee37e4adb6e" translate="yes" xml:space="preserve">
          <source>Any Object types will be serialized in a key-sorted order.</source>
          <target state="translated">모든 객체 유형은 키 정렬 순서로 직렬화됩니다.</target>
        </trans-unit>
        <trans-unit id="6f7c1cd84505fa215ea84971d24628315cd3387b" translate="yes" xml:space="preserve">
          <source>Any Statement that fails semantic() or has a component that is an ErrorExp or a TypeError should return an ErrorStatement from semantic().</source>
          <target state="translated">semantic ()에 실패하거나 ErrorExp 또는 TypeError 인 구성 요소가있는 명령문은 semantic ()에서 ErrorStatement를 반환해야합니다.</target>
        </trans-unit>
        <trans-unit id="baa16ecc9203783f7d302f47d6c7e99ca53b7882" translate="yes" xml:space="preserve">
          <source>Any ambiguities in the grammar between</source>
          <target state="translated">문법의 모든 모호성</target>
        </trans-unit>
        <trans-unit id="77ecebcd0dc38ae59d287e9d6832a173b570a0a2" translate="yes" xml:space="preserve">
          <source>Any atom</source>
          <target state="translated">어떤 원자</target>
        </trans-unit>
        <trans-unit id="638621cad02fb4ef96d35005061aa41c6d8d2099" translate="yes" xml:space="preserve">
          <source>Any casting of a class reference to a derived class reference is done with a runtime check to make sure it really is a downcast. &lt;code&gt;null&lt;/code&gt; is the result if it isn't.</source>
          <target state="translated">파생 클래스 참조에 대한 클래스 참조 캐스팅은 실제로 다운 캐스트인지 확인하기 위해 런타임 확인으로 수행됩니다. 그렇지 않은 경우 결과는 &lt;code&gt;null&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="7916c4b8de53330f21dcd29a0e59721012e5dd75" translate="yes" xml:space="preserve">
          <source>Any class invariants for base classes are applied before the class invariant for the derived class.</source>
          <target state="translated">기본 클래스의 클래스 불변 값은 파생 클래스의 클래스 불변 값보다 먼저 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="f7e950396436ad2a46ce9aad7dec469f189171b3" translate="yes" xml:space="preserve">
          <source>Any data referenced by the const declaration cannot be changed from the const declaration, but it might be changed by other references to the same data.</source>
          <target state="translated">const 선언으로 참조 된 데이터는 const 선언에서 변경할 수 없지만 다른 참조에서 동일한 데이터에 대해 변경 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ea9ba6b957e1ee541543e4ed84469edf4ec75cad" translate="yes" xml:space="preserve">
          <source>Any exception not handled by the joined thread.</source>
          <target state="translated">결합 된 스레드가 처리하지 않는 예외</target>
        </trans-unit>
        <trans-unit id="df41046890795b4eaa63b398c58e4d9d99374a20" translate="yes" xml:space="preserve">
          <source>Any exception not handled by the joined threads.</source>
          <target state="translated">결합 된 스레드가 처리하지 않는 예외</target>
        </trans-unit>
        <trans-unit id="010d3e9dcdbd22cd7fd006df77170e4cb60a5618" translate="yes" xml:space="preserve">
          <source>Any exception not handled by this fiber if rethrow = false, null otherwise.</source>
          <target state="translated">rethrow = false 인 경우이 파이버가 처리하지 않는 예외는 그렇지 않으면 null입니다.</target>
        </trans-unit>
        <trans-unit id="b6ba130c34ce4b05804f636f1f2f916c5937c009" translate="yes" xml:space="preserve">
          <source>Any exception not handled by this thread if rethrow = false, null otherwise.</source>
          <target state="translated">rethrow = false 인 경우이 스레드에서 처리하지 않은 예외는 그렇지 않으면 null입니다.</target>
        </trans-unit>
        <trans-unit id="f674a6378976f81a229e3e40bb92d9695e3314fe" translate="yes" xml:space="preserve">
          <source>Any functions that execute in CTFE must also be executable at run time. The compile time evaluation of a function does the equivalent of running the function at run time. This means that the semantics of a function cannot depend on compile time values of the function. For example:</source>
          <target state="translated">CTFE에서 실행되는 모든 기능은 런타임에 실행 가능해야합니다. 함수의 컴파일 시간 평가는 런타임에 함수를 실행하는 것과 같습니다. 이는 함수의 의미가 함수의 컴파일 시간 값에 의존 할 수 없음을 의미합니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="a57e0db645362adce30e4484501c92ffe3bbf8b7" translate="yes" xml:space="preserve">
          <source>Any insertion, removal, or lookups in an associative array</source>
          <target state="translated">연관 배열의 모든 삽입, 제거 또는 조회</target>
        </trans-unit>
        <trans-unit id="0e84b6b0c57f34d7c618d447a7ab2c9f8792eac9" translate="yes" xml:space="preserve">
          <source>Any interface that derives from a C++ interface is also a C++ interface. A C++ interface differs from a D interface in that:</source>
          <target state="translated">C ++ 인터페이스에서 파생되는 모든 인터페이스도 C ++ 인터페이스입니다. C ++ 인터페이스는 다음과 같은 점에서 D 인터페이스와 다릅니다.</target>
        </trans-unit>
        <trans-unit id="440031e52a8a0c7f5013522c41d2f3dc66691e39" translate="yes" xml:space="preserve">
          <source>Any intervening finally clauses are executed, along with releasing any intervening synchronization mutexes.</source>
          <target state="translated">중재 동기화 뮤텍스를 해제하는 것과 함께 중재 최종 절이 실행됩니다.</target>
        </trans-unit>
        <trans-unit id="752a908277ccaeb8ca9908aea34bc98614160ea6" translate="yes" xml:space="preserve">
          <source>Any intervening finally clauses are executed, and any intervening synchronization objects are released.</source>
          <target state="translated">모든 intervening finally 절이 실행되고 모든 intervening 동기화 오브젝트가 해제됩니다.</target>
        </trans-unit>
        <trans-unit id="3c58819fbd73a8c9fe0c340f0db018003ce09975" translate="yes" xml:space="preserve">
          <source>Any invariants for fields are applied before the struct invariant.</source>
          <target state="translated">필드의 모든 불변은 구조체 불변 전에 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="f9fe95fc6eae39aaf25f84d103f3acf7d7a384fd" translate="yes" xml:space="preserve">
          <source>Any license information for copyrighted code.</source>
          <target state="translated">저작권이있는 코드에 대한 모든 라이센스 정보.</target>
        </trans-unit>
        <trans-unit id="67b9adde439b5f8364926599d4a45d83875f65d8" translate="yes" xml:space="preserve">
          <source>Any numerical type that supports the modulo operator &lt;code&gt;%&lt;/code&gt;. If bit-shifting &lt;code&gt;&amp;lt;&amp;lt;&lt;/code&gt; and &lt;code&gt;&amp;gt;&amp;gt;&lt;/code&gt; are also supported, Stein's algorithm will be used; otherwise, Euclid's algorithm is used as a fallback.</source>
          <target state="translated">모듈로 연산자 &lt;code&gt;%&lt;/code&gt; 를 지원하는 모든 숫자 유형 . 비트 시프 팅 &lt;code&gt;&amp;lt;&amp;lt;&lt;/code&gt; 및 &lt;code&gt;&amp;gt;&amp;gt;&lt;/code&gt; 도 지원되는 경우 Stein 알고리즘이 사용됩니다. 그렇지 않으면 유클리드 알고리즘이 폴백으로 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="81c3013df61cbea6a4c917b70878d87da30767d9" translate="yes" xml:space="preserve">
          <source>Any pointer may be cast to &lt;code&gt;void*&lt;/code&gt; and from &lt;code&gt;void*&lt;/code&gt; back to its original type. Casting between pointer and non-pointer types is prohibited.</source>
          <target state="translated">모든 포인터는 &lt;code&gt;void*&lt;/code&gt; , &lt;code&gt;void*&lt;/code&gt; 에서 원래 유형으로 다시 캐스트 될 수 있습니다 . 포인터와 비 포인터 유형 사이의 캐스팅은 금지됩니다.</target>
        </trans-unit>
        <trans-unit id="c5cc05a90008a92dc38ec7d27e928baccc65c4ac" translate="yes" xml:space="preserve">
          <source>Any ranges which iterate over a &lt;code&gt;NegInfInterval&lt;/code&gt; are infinite. So, the main purpose of using &lt;code&gt;NegInfInterval&lt;/code&gt; is to create an infinite range which starts at negative infinity and goes to a fixed end point. Iterate over it in reverse.</source>
          <target state="translated">&lt;code&gt;NegInfInterval&lt;/code&gt; 을 반복하는 모든 범위 는 무한합니다. 따라서 &lt;code&gt;NegInfInterval&lt;/code&gt; 을 사용하는 주요 목적은 음의 무한대에서 시작하여 고정 된 끝점으로 이동하는 무한 범위를 만드는 것입니다. 반대로 반복하십시오.</target>
        </trans-unit>
        <trans-unit id="fea46f39188f37b7400472b6a7256e566f0dadfc" translate="yes" xml:space="preserve">
          <source>Any ranges which iterate over a &lt;code&gt;PosInfInterval&lt;/code&gt; are infinite. So, the main purpose of using &lt;code&gt;PosInfInterval&lt;/code&gt; is to create an infinite range which starts at a fixed point in time and goes to positive infinity.</source>
          <target state="translated">&lt;code&gt;PosInfInterval&lt;/code&gt; 을 반복하는 모든 범위 는 무한합니다. 따라서 &lt;code&gt;PosInfInterval&lt;/code&gt; 을 사용하는 주요 목적은 고정 된 시점에서 시작하여 양의 무한대로 진행되는 무한 범위를 만드는 것입니다.</target>
        </trans-unit>
        <trans-unit id="f9d9d3b6ac3e9e29441a9345be2bae022fb55442" translate="yes" xml:space="preserve">
          <source>Any sequence of character class elements implicitly forms a union.</source>
          <target state="translated">일련의 문자 클래스 요소는 암시 적으로 통합을 형성합니다.</target>
        </trans-unit>
        <trans-unit id="f33c41254cc91d5ef5db3832237d967b66a6b7df" translate="yes" xml:space="preserve">
          <source>Any statement can be labeled, including empty statements, and so can serve as the target of a goto statement. Labeled statements can also serve as the target of a break or continue statement.</source>
          <target state="translated">빈 명령문을 포함하여 모든 명령문에 레이블을 지정할 수 있으므로 goto 문의 대상으로 사용할 수 있습니다. 레이블이있는 명령문은 또한 break 또는 continue 문의 대상으로 사용될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="77bf850fc03647bf14bd010a86cea6f71dcbb566" translate="yes" xml:space="preserve">
          <source>Any type which implicitly converts to &lt;code&gt;dchar&lt;/code&gt;. In the case where it's a built-in type, or an enum of a built-in type, &lt;code&gt;Unqual!(OriginalType!C)&lt;/code&gt; is returned, whereas if it's a user-defined type, &lt;code&gt;dchar&lt;/code&gt; is returned.</source>
          <target state="translated">암시로 변환 모든 유형 &lt;code&gt;dchar&lt;/code&gt; . 내장형이거나 내장형의 열거 형인 경우 &lt;code&gt;Unqual!(OriginalType!C)&lt;/code&gt; 가 반환되는 반면, 사용자 정의 형식 인 경우 &lt;code&gt;dchar&lt;/code&gt; 가 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="83413c5ae04e9398c07c45877def24fe2d3e627f" translate="yes" xml:space="preserve">
          <source>Any usage examples</source>
          <target state="translated">사용 예</target>
        </trans-unit>
        <trans-unit id="5b0bf7c14ffa6d93dd97c17d04c8db163f500b7e" translate="yes" xml:space="preserve">
          <source>Append 'this' to the specific module members[]</source>
          <target state="translated">특정 모듈 멤버에게 'this'추가</target>
        </trans-unit>
        <trans-unit id="e6389badcbed51133ce737118947b50567eac4a2" translate="yes" xml:space="preserve">
          <source>Append &lt;a href=&quot;#Character&quot;&gt;character&lt;/a&gt;&lt;code&gt;ch&lt;/code&gt; to this grapheme.</source>
          <target state="translated">이 grapheme에 &lt;a href=&quot;#Character&quot;&gt;문자 &lt;/a&gt; &lt;code&gt;ch&lt;/code&gt; 를 추가하십시오 .</target>
        </trans-unit>
        <trans-unit id="9423c656632feb94c95542550bc5776ab847c04f" translate="yes" xml:space="preserve">
          <source>Append &lt;code&gt;e2&lt;/code&gt; to chain of exceptions that starts with &lt;code&gt;e1&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;e1&lt;/code&gt; 로 시작하는 예외 체인에 &lt;code&gt;e2&lt;/code&gt; 를 추가하십시오 .</target>
        </trans-unit>
        <trans-unit id="e3d06094350a95ba5b433011fb835e7124c4ec5e" translate="yes" xml:space="preserve">
          <source>Append a CData item to the interior of this element</source>
          <target state="translated">이 요소의 내부에 CData 항목을 추가하십시오.</target>
        </trans-unit>
        <trans-unit id="984824e040f0720fce2fc4f6a13d57fc728e8caa" translate="yes" xml:space="preserve">
          <source>Append a comment to the interior of this element</source>
          <target state="translated">이 요소의 내부에 주석을 추가하십시오</target>
        </trans-unit>
        <trans-unit id="db03388cd72ade8520d2e378966e698614e72a5e" translate="yes" xml:space="preserve">
          <source>Append a complete element to the interior of this element</source>
          <target state="translated">이 요소의 내부에 완전한 요소를 추가</target>
        </trans-unit>
        <trans-unit id="ef21e116b7bca07b0b591badb0bc081fdcfe67e5" translate="yes" xml:space="preserve">
          <source>Append a processing instruction to the interior of this element</source>
          <target state="translated">이 요소의 내부에 처리 명령 추가</target>
        </trans-unit>
        <trans-unit id="496596976c04bde5f7e7a5a8202d7b8abe85e980" translate="yes" xml:space="preserve">
          <source>Append a text item to the interior of this element</source>
          <target state="translated">이 요소의 내부에 텍스트 항목을 추가하십시오.</target>
        </trans-unit>
        <trans-unit id="f6dd93a31eb85b0a74d513a784054a244ba3c76c" translate="yes" xml:space="preserve">
          <source>Append all &lt;a href=&quot;#Character&quot;&gt;characters&lt;/a&gt; from the input range &lt;code&gt;inp&lt;/code&gt; to this Grapheme.</source>
          <target state="translated">입력 범위 &lt;code&gt;inp&lt;/code&gt; 의 모든 &lt;a href=&quot;#Character&quot;&gt;문자&lt;/a&gt; 를이 Grapheme에 추가하십시오.</target>
        </trans-unit>
        <trans-unit id="34b47904d2988c2185d4a53f77f7d8e792a3291d" translate="yes" xml:space="preserve">
          <source>Append array &lt;code&gt;y&lt;/code&gt; to array &lt;code&gt;x&lt;/code&gt;.</source>
          <target state="translated">배열 &lt;code&gt;y&lt;/code&gt; 를 배열 &lt;code&gt;x&lt;/code&gt; 에 추가합니다 .</target>
        </trans-unit>
        <trans-unit id="ad6cd5314f128c12adc628c28aef59e004d422e0" translate="yes" xml:space="preserve">
          <source>Append data represented by ptr[0..size]</source>
          <target state="translated">ptr [0..size]로 표시되는 데이터 추가</target>
        </trans-unit>
        <trans-unit id="35f4f092745cbd38143bff7f25d5d2804e9a0623" translate="yes" xml:space="preserve">
          <source>Append data to the internal buffer.</source>
          <target state="translated">내부 버퍼에 데이터를 추가합니다.</target>
        </trans-unit>
        <trans-unit id="6cfc826c67159c690715f887f4b34b4df17e6673" translate="yes" xml:space="preserve">
          <source>Append dchar to char[]</source>
          <target state="translated">dchar를 char에 추가 []</target>
        </trans-unit>
        <trans-unit id="b6ff7bb65433411731c9ec32fd03f8c8b7ab8dbf" translate="yes" xml:space="preserve">
          <source>Append dchar to wchar[]</source>
          <target state="translated">dchar를 wchar에 추가 []</target>
        </trans-unit>
        <trans-unit id="f099c58d9143b4e0a6f01a50957762bf07adaa8f" translate="yes" xml:space="preserve">
          <source>Append dt to data.</source>
          <target state="translated">데이터에 dt를 추가하십시오.</target>
        </trans-unit>
        <trans-unit id="73602dd98d646af114882b411baed4caf29ed4aa" translate="yes" xml:space="preserve">
          <source>Append dtb to data.</source>
          <target state="translated">데이터에 dtb를 추가하십시오.</target>
        </trans-unit>
        <trans-unit id="05676aa51ec52e96deb89d7ae3b7bad0e2920095" translate="yes" xml:space="preserve">
          <source>Append instead of overwrite on upload!</source>
          <target state="translated">업로드시 덮어 쓰기 대신 추가!</target>
        </trans-unit>
        <trans-unit id="725e2673bb64dd768f5e35adc33733f051daff12" translate="yes" xml:space="preserve">
          <source>Append integer item to list.</source>
          <target state="translated">정수 항목을 목록에 추가하십시오.</target>
        </trans-unit>
        <trans-unit id="8e98d78b75b667bfa9432c073969f89aad62837e" translate="yes" xml:space="preserve">
          <source>Append nbytes of 0 to the internal buffer.</source>
          <target state="translated">내부 버퍼에 nbytes 0을 추가합니다.</target>
        </trans-unit>
        <trans-unit id="6100e49b257665109b21fcb575027c3b1d83fee9" translate="yes" xml:space="preserve">
          <source>Append output of C's printf() to internal buffer.</source>
          <target state="translated">C의 printf () 출력을 내부 버퍼에 추가합니다.</target>
        </trans-unit>
        <trans-unit id="6f1cd15bde5d09d444835959bdf7cf1009a819c1" translate="yes" xml:space="preserve">
          <source>Append output of C's vprintf() to internal buffer.</source>
          <target state="translated">C의 vprintf () 출력을 내부 버퍼에 추가합니다.</target>
        </trans-unit>
        <trans-unit id="26196f1c60516e313842646d760dfe092b0b8783" translate="yes" xml:space="preserve">
          <source>Append ptr to *plist.</source>
          <target state="translated">ptr을 * plist에 추가하십시오.</target>
        </trans-unit>
        <trans-unit id="379fc789872b087a61658c08353344a2820471c2" translate="yes" xml:space="preserve">
          <source>Append s to list of object files to generate later.</source>
          <target state="translated">나중에 생성 할 객체 파일 목록에을 추가합니다.</target>
        </trans-unit>
        <trans-unit id="7c74420521a423ce5daf955e234405a229d6cc0f" translate="yes" xml:space="preserve">
          <source>Append the remaining segments of &lt;code&gt;path&lt;/code&gt; to the string and return.</source>
          <target state="translated">문자열 의 나머지 &lt;code&gt;path&lt;/code&gt; 세그먼트를 추가 하고 리턴하십시오.</target>
        </trans-unit>
        <trans-unit id="9e7e4b12820cee8e262b36441f586183f6d04cab" translate="yes" xml:space="preserve">
          <source>Append y[] to array x[]</source>
          <target state="translated">배열 x []에 y []를 추가</target>
        </trans-unit>
        <trans-unit id="0ef306358b052f7e64b8bcc3cd14249cef33ca02" translate="yes" xml:space="preserve">
          <source>Appender!(E[]) &lt;strong id=&quot;appender&quot;&gt;appender&lt;/strong&gt;(A : E[], E)(auto ref A array);</source>
          <target state="translated">Appender! (E []) &lt;strong id=&quot;appender&quot;&gt;appender&lt;/strong&gt; (A : E [], E) (자동 참조 A 배열);</target>
        </trans-unit>
        <trans-unit id="4e11e6991b83788f5357a19dc342f52d09507315" translate="yes" xml:space="preserve">
          <source>Appender!A &lt;strong id=&quot;appender&quot;&gt;appender&lt;/strong&gt;(A)()</source>
          <target state="translated">Appender! 어 &lt;strong id=&quot;appender&quot;&gt;펜더&lt;/strong&gt; (A) ()</target>
        </trans-unit>
        <trans-unit id="b06a35dce8dc5935a09578e40179d4dbbd0cee5e" translate="yes" xml:space="preserve">
          <source>Appending does not always create a copy, see &lt;a href=&quot;#resize&quot;&gt; setting dynamic array length&lt;/a&gt; for details.</source>
          <target state="translated">추가로 항상 사본이 생성되는 것은 아닙니다 . 자세한 내용 은 &lt;a href=&quot;#resize&quot;&gt;동적 배열 길이 설정&lt;/a&gt; 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="d23d95cfc1028cebc43e6d6bc87290142bad8a2a" translate="yes" xml:space="preserve">
          <source>Appending to and direct manipulation of grapheme's &lt;a href=&quot;#Character&quot;&gt;characters&lt;/a&gt; may render it no longer valid. Certain applications may chose to use Grapheme as a &quot;small string&quot; of any &lt;a href=&quot;#Code%20point&quot;&gt;code points&lt;/a&gt; and ignore this property entirely.</source>
          <target state="translated">grapheme의 &lt;a href=&quot;#Character&quot;&gt;문자를&lt;/a&gt; 추가하고 직접 조작 하면 더 이상 유효하지 않을 수 있습니다. 특정 응용 프로그램은 Grapheme을 모든 &lt;a href=&quot;#Code%20point&quot;&gt;코드 포인트&lt;/a&gt; 의 &quot;작은 문자열&quot;로 사용하도록 선택 하고이 속성을 완전히 무시할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="27687e63c8f2765f7f45c656d25a88a2f70872d2" translate="yes" xml:space="preserve">
          <source>Appends &lt;code&gt;buffer&lt;/code&gt; to file &lt;code&gt;name&lt;/code&gt;.</source>
          <target state="translated">파일 &lt;code&gt;name&lt;/code&gt; &lt;code&gt;buffer&lt;/code&gt; 를 추가 합니다 .</target>
        </trans-unit>
        <trans-unit id="d7f62b12268c12952ecff14c3290b88618812066" translate="yes" xml:space="preserve">
          <source>Appends &lt;code&gt;item&lt;/code&gt; to the managed array. Performs encoding for &lt;code&gt;char&lt;/code&gt; types if &lt;code&gt;A&lt;/code&gt; is a differently typed &lt;code&gt;char&lt;/code&gt; array.</source>
          <target state="translated">관리 형 배열에 &lt;code&gt;item&lt;/code&gt; 을 추가합니다 . &lt;code&gt;A&lt;/code&gt; 가 다른 유형의 &lt;code&gt;char&lt;/code&gt; 배열 인 경우 &lt;code&gt;char&lt;/code&gt; 유형에 대한 인코딩을 수행 합니다.</target>
        </trans-unit>
        <trans-unit id="3fa391a5e33fe2002fc2b72cecadf723ca6b30fe" translate="yes" xml:space="preserve">
          <source>Appends &lt;code&gt;rhs&lt;/code&gt; to the managed array.</source>
          <target state="translated">관리 형 배열에 &lt;code&gt;rhs&lt;/code&gt; 를 추가합니다 .</target>
        </trans-unit>
        <trans-unit id="7623fabcaede88b964c04becc831d4ac3e3b23ce" translate="yes" xml:space="preserve">
          <source>Appends &lt;code&gt;x&lt;/code&gt; to &lt;code&gt;c&lt;/code&gt;. &lt;code&gt;x&lt;/code&gt; may be a single element or an input range type.</source>
          <target state="translated">&lt;code&gt;x&lt;/code&gt; 를 &lt;code&gt;c&lt;/code&gt; 에 추가합니다 . &lt;code&gt;x&lt;/code&gt; 는 단일 요소 또는 입력 범위 유형일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="18bc8e8710e112a386b8301eb1ea86dca70c5d37" translate="yes" xml:space="preserve">
          <source>Appends a string to a linked list. If no list exists, it will be created first. Returns the new list, after appending.</source>
          <target state="translated">문자열을 연결된 목록에 추가합니다. 목록이 없으면 먼저 작성됩니다. 추가 한 후 새 목록을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="81cdccb19773651976963e90237f5de77beaf9e6" translate="yes" xml:space="preserve">
          <source>Appends an entire range to the managed array. Performs encoding for &lt;code&gt;char&lt;/code&gt; elements if &lt;code&gt;A&lt;/code&gt; is a differently typed &lt;code&gt;char&lt;/code&gt; array.</source>
          <target state="translated">전체 범위를 관리 형 배열에 추가합니다. &lt;code&gt;A&lt;/code&gt; 가 다른 유형의 &lt;code&gt;char&lt;/code&gt; 배열 인 경우 &lt;code&gt;char&lt;/code&gt; 요소에 대한 인코딩을 수행 합니다.</target>
        </trans-unit>
        <trans-unit id="e1a17d68e5eb26669b8a6fd759bf09e863160e46" translate="yes" xml:space="preserve">
          <source>Appends the contents of the argument &lt;code&gt;rhs&lt;/code&gt; into &lt;code&gt;this&lt;/code&gt;.</source>
          <target state="translated">인수의 내용에 추가 &lt;code&gt;rhs&lt;/code&gt; 로 &lt;code&gt;this&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="20cd868cd32de230764914be80101e71a8f019d2" translate="yes" xml:space="preserve">
          <source>Appends to the managed array.</source>
          <target state="translated">관리 형 배열에 추가합니다.</target>
        </trans-unit>
        <trans-unit id="762f62942181d4b2666650e69bb8c92655c35501" translate="yes" xml:space="preserve">
          <source>AppleTalk</source>
          <target state="translated">AppleTalk</target>
        </trans-unit>
        <trans-unit id="82cac29a8ad5cbbc38d1a1fb84f536367b07a15f" translate="yes" xml:space="preserve">
          <source>Application Binary Interface</source>
          <target state="translated">응용 프로그램 이진 인터페이스</target>
        </trans-unit>
        <trans-unit id="8c42705eec7c415a6997bd8c9d3dc65da77e4f55" translate="yes" xml:space="preserve">
          <source>Application Defined Page Cache.</source>
          <target state="translated">응용 프로그램 정의 페이지 캐시.</target>
        </trans-unit>
        <trans-unit id="a1097391b6d8c24e778f4782f5e62fadaf414d9d" translate="yes" xml:space="preserve">
          <source>Applies a delegate or function to the given &lt;a href=&quot;#Algebraic&quot;&gt;&lt;code&gt;Algebraic&lt;/code&gt;&lt;/a&gt; depending on the held type, ensuring that all types are handled by the visiting functions.</source>
          <target state="translated">보류 유형에 따라 지정된 &lt;a href=&quot;#Algebraic&quot;&gt; &lt;code&gt;Algebraic&lt;/code&gt; &lt;/a&gt; 에 델리게이트 또는 함수를 적용하여 모든 유형이 방문 함수에 의해 처리되도록합니다.</target>
        </trans-unit>
        <trans-unit id="2e64c5b4326d836829a0ebf41a9e13a5e62411c7" translate="yes" xml:space="preserve">
          <source>Apply MODxxxx bits to existing type.</source>
          <target state="translated">기존 유형에 MODxxxx 비트를 적용하십시오.</target>
        </trans-unit>
        <trans-unit id="ee985a3510121398e40860de4ace149b4869d63d" translate="yes" xml:space="preserve">
          <source>Apply STCxxxx bits to existing type. Use *before* semantic analysis is run.</source>
          <target state="translated">기존 유형에 STCxxxx 비트를 적용하십시오. 시맨틱 분석이 실행되기 전에 * 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="a27c3d86d32e5ed828ae9b07fd5ad23ae9593843" translate="yes" xml:space="preserve">
          <source>Apply a function fp to each member of a list.</source>
          <target state="translated">리스트의 각 멤버에 함수 fp를 적용하십시오.</target>
        </trans-unit>
        <trans-unit id="5c98d8debd927a2a04375be8cb963231c736c4c5" translate="yes" xml:space="preserve">
          <source>Applying a qualifier to a type that already has that qualifier is legal but has no effect, e.g. given an unqualified type &lt;code&gt;T&lt;/code&gt;, &lt;code&gt;shared(const shared T)&lt;/code&gt; yields the type &lt;code&gt;const shared T&lt;/code&gt;.</source>
          <target state="translated">이미 규정이 법적 가지고 있지만 적정 유형 주어진 예에는 영향을주지 않습니다 유형에 규정을 적용 &lt;code&gt;T&lt;/code&gt; , &lt;code&gt;shared(const shared T)&lt;/code&gt; 유형의 산출 &lt;code&gt;const shared T&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2a15b638351f6a01ae8878d2186ac098d189b867" translate="yes" xml:space="preserve">
          <source>Applying the &lt;code&gt;immutable&lt;/code&gt; qualifier to any type (qualified or not) results in &lt;code&gt;immutable T&lt;/code&gt;. Applying any qualifier to &lt;code&gt;immutable T&lt;/code&gt; results in &lt;code&gt;immutable T&lt;/code&gt;. This makes &lt;code&gt;immutable&lt;/code&gt; a fixed point of qualifier combinations and makes types such as &lt;code&gt;const(immutable(shared T))&lt;/code&gt; impossible to create.</source>
          <target state="translated">&lt;code&gt;immutable&lt;/code&gt; 한정자를 임의의 유형에 적용하면 (자격 여부에 관계없이) &lt;code&gt;immutable T&lt;/code&gt; 됩니다. 어떤 규정 적용 &lt;code&gt;immutable T&lt;/code&gt; 결과 &lt;code&gt;immutable T&lt;/code&gt; . 이것은 &lt;code&gt;immutable&lt;/code&gt; 을 한정자 한정자 조합 포인트로 만들고 &lt;code&gt;const(immutable(shared T))&lt;/code&gt; 와 같은 유형 을 만들 수 없게 만듭니다.</target>
        </trans-unit>
        <trans-unit id="af4f4762f9bd3f0f4a10caf5b6e63dc4ce543724" translate="yes" xml:space="preserve">
          <source>Arabic</source>
          <target state="translated">Arabic</target>
        </trans-unit>
        <trans-unit id="5e35d0b2742a654477e1cd63556f021113ce5b4c" translate="yes" xml:space="preserve">
          <source>Arabic Extended-A</source>
          <target state="translated">아랍어 확장 -A</target>
        </trans-unit>
        <trans-unit id="e2e75f0c9d3aecdda25899708775d147043e7830" translate="yes" xml:space="preserve">
          <source>Arabic Mathematical Alphabetic Symbols</source>
          <target state="translated">아랍어 수학 알파벳 기호</target>
        </trans-unit>
        <trans-unit id="1855677dcc7468bb9c8e6a1cd81ba79444a4ff7e" translate="yes" xml:space="preserve">
          <source>Arabic Presentation Forms-A</source>
          <target state="translated">아랍어 프리젠 테이션 양식 -A</target>
        </trans-unit>
        <trans-unit id="81d80ec90565c460cb86314a7772144c7915e63e" translate="yes" xml:space="preserve">
          <source>Arabic Presentation Forms-B</source>
          <target state="translated">아랍어 프리젠 테이션 양식 -B</target>
        </trans-unit>
        <trans-unit id="f967001c1a34ccb5d4db68033cb95ea3afa4f067" translate="yes" xml:space="preserve">
          <source>Arabic Supplement</source>
          <target state="translated">아랍어 보충</target>
        </trans-unit>
        <trans-unit id="f984e10440745697cc3d65ba4c39e78b962f2e10" translate="yes" xml:space="preserve">
          <source>Arbitrary block of memory (&lt;code&gt;null&lt;/code&gt; is allowed; &lt;code&gt;owns(null)&lt;/code&gt; returns &lt;code&gt;false&lt;/code&gt;).</source>
          <target state="translated">임의의 메모리 블록 ( &lt;code&gt;null&lt;/code&gt; 허용, &lt;code&gt;owns(null)&lt;/code&gt; 은 &lt;code&gt;false&lt;/code&gt; 반환 )</target>
        </trans-unit>
        <trans-unit id="35ae340d74ec660428a4617d592eb281817c9ae4" translate="yes" xml:space="preserve">
          <source>Arbitrary length and complexity lookbehind, including lookahead in lookbehind and vise-versa.</source>
          <target state="translated">lookahind와 lookse의 lookahead를 포함하여 임의의 길이와 복잡성 lookbehind.</target>
        </trans-unit>
        <trans-unit id="2b10f364535b59752b7187d9f87de14ac7b52ee5" translate="yes" xml:space="preserve">
          <source>Arbitrary-precision ('bignum') arithmetic.</source>
          <target state="translated">임의 정밀도 ( 'bignum') 산술.</target>
        </trans-unit>
        <trans-unit id="b9fcbd049669bd8c4ed6c2c7a64ef6513f2e0d6d" translate="yes" xml:space="preserve">
          <source>Are AMD extensions to MMX supported?</source>
          <target state="translated">MMX에 대한 AMD 확장이 지원됩니까?</target>
        </trans-unit>
        <trans-unit id="01e21616c01d0a2fca25a82b396c6f6e959a0c86" translate="yes" xml:space="preserve">
          <source>Are LAHF and SAHF supported in 64-bit mode?</source>
          <target state="translated">LAHF 및 SAHF는 64 비트 모드에서 지원됩니까?</target>
        </trans-unit>
        <trans-unit id="3a1445e9d8e93be79bf26c9c6c4caa120500ae1a" translate="yes" xml:space="preserve">
          <source>Are any of the Objects an error?</source>
          <target state="translated">객체에 오류가 있습니까?</target>
        </trans-unit>
        <trans-unit id="4bf0024c4bc943f998126635e2b2826496ec8582" translate="yes" xml:space="preserve">
          <source>Args</source>
          <target state="translated">Args</target>
        </trans-unit>
        <trans-unit id="4293e4b957c97199f617f8492936758c0b738afa" translate="yes" xml:space="preserve">
          <source>Args &lt;code&gt;args&lt;/code&gt;</source>
          <target state="translated">Args &lt;code&gt;args&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="0f5be29a09e6e60319db52d529ad7515c16471a5" translate="yes" xml:space="preserve">
          <source>Argument Deduction</source>
          <target state="translated">인수 공제</target>
        </trans-unit>
        <trans-unit id="54486629b7690ae513c392c789d163e099b5b87d" translate="yes" xml:space="preserve">
          <source>Argument Type</source>
          <target state="translated">인수 유형</target>
        </trans-unit>
        <trans-unit id="29654984a9e906a0a06167995d3f42a8d08cf353" translate="yes" xml:space="preserve">
          <source>Argument to xInit() and xShutdown()</source>
          <target state="translated">xInit () 및 xShutdown ()에 대한 인수</target>
        </trans-unit>
        <trans-unit id="daf86c8879ed0c69961403ceb76965c2482d6deb" translate="yes" xml:space="preserve">
          <source>ArgumentList</source>
          <target state="translated">ArgumentList</target>
        </trans-unit>
        <trans-unit id="8946712557cc8b1c3fb3e94fee0d0fce04b3802b" translate="yes" xml:space="preserve">
          <source>Arguments to pass to &lt;code&gt;T&lt;/code&gt;'s constructor.</source>
          <target state="translated">&lt;code&gt;T&lt;/code&gt; 의 생성자 에 전달할 인수 입니다.</target>
        </trans-unit>
        <trans-unit id="bfbc91d37e47f927568d7a30e3496cf96960cf08" translate="yes" xml:space="preserve">
          <source>Arguments to pass to the method.</source>
          <target state="translated">메소드에 전달할 인수입니다.</target>
        </trans-unit>
        <trans-unit id="89180ef2e932b4599c798900639013ef3f341134" translate="yes" xml:space="preserve">
          <source>Arguments to the function.</source>
          <target state="translated">기능에 대한 주장.</target>
        </trans-unit>
        <trans-unit id="c9630a5d15efcdc7541a36a0160b3500004aba0a" translate="yes" xml:space="preserve">
          <source>Arithmetic between &lt;code&gt;VariantN&lt;/code&gt; objects and numeric values. All arithmetic operations return a &lt;code&gt;VariantN&lt;/code&gt; object typed depending on the types of both values involved. The conversion rules mimic D's built-in rules for arithmetic conversions.</source>
          <target state="translated">&lt;code&gt;VariantN&lt;/code&gt; 객체와 숫자 값 사이의 산술 . 모든 산술 연산 은 관련된 두 값의 유형에 따라 유형이 지정된 &lt;code&gt;VariantN&lt;/code&gt; 객체를 반환합니다 . 변환 규칙은 산술 변환에 대한 D의 기본 제공 규칙을 모방합니다.</target>
        </trans-unit>
        <trans-unit id="1a0d21145500640fd3f6136eeba595bfe934d364" translate="yes" xml:space="preserve">
          <source>Armenian</source>
          <target state="translated">Armenian</target>
        </trans-unit>
        <trans-unit id="2c96bf3a668aac126792eaf02dadd14fa48e70d3" translate="yes" xml:space="preserve">
          <source>Array &lt;strong id=&quot;opBinary&quot;&gt;opBinary&lt;/strong&gt;(string op, Stuff)(Stuff stuff)</source>
          <target state="translated">배열 &lt;strong id=&quot;opBinary&quot;&gt;opBinary&lt;/strong&gt; (문자열 op, 물건) (스터프 물건)</target>
        </trans-unit>
        <trans-unit id="3660d1d1308b201f353bc8fa6130b29f9ba2d842" translate="yes" xml:space="preserve">
          <source>Array Bounds Checking</source>
          <target state="translated">배열 바운드 확인</target>
        </trans-unit>
        <trans-unit id="1f1275d2846b1606eecf7847c7e27140c6dc6c89" translate="yes" xml:space="preserve">
          <source>Array Concatenation</source>
          <target state="translated">배열 연결</target>
        </trans-unit>
        <trans-unit id="5d1d05717fafa53ed33983c8c412c01fb3ca32f6" translate="yes" xml:space="preserve">
          <source>Array Copying</source>
          <target state="translated">배열 복사</target>
        </trans-unit>
        <trans-unit id="0b0779db36c24b1c78ab44d3d32261e35d9bc05e" translate="yes" xml:space="preserve">
          <source>Array Declarations</source>
          <target state="translated">배열 선언</target>
        </trans-unit>
        <trans-unit id="83248d40160f2cce014335fe1581785cb6bcecaf" translate="yes" xml:space="preserve">
          <source>Array Index/Slice scope</source>
          <target state="translated">배열 인덱스 / 슬라이스 범위</target>
        </trans-unit>
        <trans-unit id="4b91e23ca287553cadb09bb925d112bdb13a167e" translate="yes" xml:space="preserve">
          <source>Array Indexing and Slicing Operators Overloading</source>
          <target state="translated">배열 인덱싱 및 슬라이싱 연산자 오버로드</target>
        </trans-unit>
        <trans-unit id="b3e061b1b0837d1a9960794f282dd75e750eb332" translate="yes" xml:space="preserve">
          <source>Array Initialization</source>
          <target state="translated">배열 초기화</target>
        </trans-unit>
        <trans-unit id="1c847e3a06bdc4135a7a456a0f00a984d2c67477" translate="yes" xml:space="preserve">
          <source>Array Length</source>
          <target state="translated">배열 길이</target>
        </trans-unit>
        <trans-unit id="f9f04b9d6c3b8a78da5ec9d06e0efef4332889f5" translate="yes" xml:space="preserve">
          <source>Array Literals</source>
          <target state="translated">배열 리터럴</target>
        </trans-unit>
        <trans-unit id="7106a989ccb65a04eb4c26053be05ad2d2e071e2" translate="yes" xml:space="preserve">
          <source>Array Operations</source>
          <target state="translated">배열 연산</target>
        </trans-unit>
        <trans-unit id="9d517d3c8494600360cbc4c90cee07bed4ba0d68" translate="yes" xml:space="preserve">
          <source>Array Properties</source>
          <target state="translated">배열 속성</target>
        </trans-unit>
        <trans-unit id="9703b944aa367c5aa673c3d017ce64794e77b9b2" translate="yes" xml:space="preserve">
          <source>Array Setting</source>
          <target state="translated">배열 설정</target>
        </trans-unit>
        <trans-unit id="1aa037357a9b7f1c16ef42cc60976b8847ef657b" translate="yes" xml:space="preserve">
          <source>Array Usage</source>
          <target state="translated">배열 사용법</target>
        </trans-unit>
        <trans-unit id="c01b400578305839c9f204fb953e859a5125d529" translate="yes" xml:space="preserve">
          <source>Array and associative array operations. If a &lt;code&gt; VariantN&lt;/code&gt; contains an (associative) array, it can be indexed into. Otherwise, an exception is thrown.</source>
          <target state="translated">배열 및 연관 배열 연산. &lt;code&gt; VariantN&lt;/code&gt; 에 (연관) 배열이 포함되어 있으면 이를 인덱스 할 수 있습니다. 그렇지 않으면 예외가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="b84dfacc31a0969124c8d1abef734c629bb90a1e" translate="yes" xml:space="preserve">
          <source>Array appending</source>
          <target state="translated">배열 추가</target>
        </trans-unit>
        <trans-unit id="5d76be94dc9a7b58ca84dbb5c3adb93a7d01641c" translate="yes" xml:space="preserve">
          <source>Array bound checks.</source>
          <target state="translated">배열 바운드 검사.</target>
        </trans-unit>
        <trans-unit id="85acbf2069ff740d2820da623cb0a7f96c951889" translate="yes" xml:space="preserve">
          <source>Array bounds checks are disabled (command line switch &lt;a href=&quot;https://dlang.org/dmd.html#switch-boundscheck&quot;&gt;&lt;em&gt;-boundscheck=off&lt;/em&gt;&lt;/a&gt;)</source>
          <target state="translated">배열 경계 검사가 비활성화됩니다 (명령 줄 스위치 &lt;a href=&quot;https://dlang.org/dmd.html#switch-boundscheck&quot;&gt;&lt;em&gt;-boundscheck = off&lt;/em&gt;&lt;/a&gt; )</target>
        </trans-unit>
        <trans-unit id="c9495b0030caddeaddd3d77aa9749a4ea64f6f7d" translate="yes" xml:space="preserve">
          <source>Array bounds checks are necessary to enforce memory safety, so these are enabled (by default) for &lt;code&gt;@safe&lt;/code&gt; code even in &lt;b&gt;-release&lt;/b&gt; mode.</source>
          <target state="translated">메모리 안전을 강화하려면 배열 범위 검사가 필요하므로 &lt;b&gt;릴리스&lt;/b&gt; 모드 에서도 &lt;code&gt;@safe&lt;/code&gt; 코드에 대해 기본적으로 활성화 됩니다.&lt;b&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="cea52181688b642f5fdfd14c038de482c009d5f6" translate="yes" xml:space="preserve">
          <source>Array concatenation</source>
          <target state="translated">배열 연결</target>
        </trans-unit>
        <trans-unit id="57ff9464bbbd1fa1767e470a5012532b91719c42" translate="yes" xml:space="preserve">
          <source>Array container for internal usage.</source>
          <target state="translated">내부 용 배열 컨테이너.</target>
        </trans-unit>
        <trans-unit id="65a0b8da864827cd0478aba1fdf30610a77c4fd1" translate="yes" xml:space="preserve">
          <source>Array containing arrays that will be concatenated.</source>
          <target state="translated">연결할 배열을 포함하는 배열입니다.</target>
        </trans-unit>
        <trans-unit id="67d3696aeb8ef015e2952b35a392df743f65e443" translate="yes" xml:space="preserve">
          <source>Array literal is going to be allocated on the GC heap. Check its elements to see if any would escape by going on the heap.</source>
          <target state="translated">배열 리터럴은 GC 힙에 할당됩니다. 힙으로 이동하여 이스케이프가 있는지 확인하려면 해당 요소를 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="014dbf281d4d372cf828b4f858f7eb383406da80" translate="yes" xml:space="preserve">
          <source>Array literals (except when used to initialize static data)</source>
          <target state="translated">배열 리터럴 (정적 데이터를 초기화하는 데 사용되는 경우 제외)</target>
        </trans-unit>
        <trans-unit id="f6a7d7c506c31a93cc6747b37be514d93fad8773" translate="yes" xml:space="preserve">
          <source>Array literals are a comma-separated list of &lt;a href=&quot;#AssignExpression&quot;&gt;&lt;i&gt;AssignExpression&lt;/i&gt;&lt;/a&gt;s between square brackets &lt;code&gt;[&lt;/code&gt; and &lt;code&gt;]&lt;/code&gt;. The</source>
          <target state="translated">배열 리터럴은 대괄호 &lt;code&gt;[&lt;/code&gt; 와 &lt;code&gt;]&lt;/code&gt; 사이에 쉼표로 구분 된 &lt;a href=&quot;#AssignExpression&quot;&gt;&lt;i&gt;AssignExpression&lt;/i&gt;&lt;/a&gt; 목록입니다 . 그만큼</target>
        </trans-unit>
        <trans-unit id="dae2c2b63d025ee4c0832bb31c33f2a5fbf34690" translate="yes" xml:space="preserve">
          <source>Array literals are allocated on the memory managed heap. Thus, they can be returned safely from functions:</source>
          <target state="translated">배열 리터럴은 메모리 관리 힙에 할당됩니다. 따라서 함수에서 안전하게 반환 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e69b9d12c30731402c84433338297ab2257d2102" translate="yes" xml:space="preserve">
          <source>Array of VarDeclaration's for parameters</source>
          <target state="translated">매개 변수에 대한 VarDeclaration의 배열</target>
        </trans-unit>
        <trans-unit id="5d9eb8f765adfc90b02ec28ca02924204c83af1e" translate="yes" xml:space="preserve">
          <source>Array of characters read.</source>
          <target state="translated">읽은 문자 배열.</target>
        </trans-unit>
        <trans-unit id="1a234f4c4feb75a8aa7b93d09c3a8859c0ea7eb5" translate="yes" xml:space="preserve">
          <source>Array of pairs giving the offset and type information for each member in an aggregate.</source>
          <target state="translated">집계에서 각 멤버에 대한 오프셋 및 유형 정보를 제공하는 쌍의 배열입니다.</target>
        </trans-unit>
        <trans-unit id="3cc66155c78e1b4720002ac02361e391e42c1fdd" translate="yes" xml:space="preserve">
          <source>Array of the strings representing time units, starting with the smallest unit and going to the largest. It does not include &lt;code&gt;&quot;nsecs&quot;&lt;/code&gt;.</source>
          <target state="translated">가장 작은 단위부터 시작하여 가장 큰 단위까지 시간 단위를 나타내는 문자열 배열입니다. &lt;code&gt;&quot;nsecs&quot;&lt;/code&gt; 는 포함되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="c26e25fdec1370d18f0c93ee54cfd77f08bc7279" translate="yes" xml:space="preserve">
          <source>Array options.</source>
          <target state="translated">배열 옵션.</target>
        </trans-unit>
        <trans-unit id="82ee133059983d2093ca847eb799753d9f96eeef" translate="yes" xml:space="preserve">
          <source>Array slicing, and array bounds checking</source>
          <target state="translated">배열 슬라이싱 및 배열 범위 검사</target>
        </trans-unit>
        <trans-unit id="f187d73020c36a9ee259d3863cac2e2a8546f9fe" translate="yes" xml:space="preserve">
          <source>Array specialized for &lt;code&gt;bool&lt;/code&gt;. Packs together values efficiently by allocating one bit per element.</source>
          <target state="translated">&lt;code&gt;bool&lt;/code&gt; 전용 배열입니다 . 요소 당 하나의 비트를 할당하여 값을 효율적으로 묶습니다.</target>
        </trans-unit>
        <trans-unit id="5058965ad79b9992b8f00aae6b40d9b43a8d0f10" translate="yes" xml:space="preserve">
          <source>Array syntax for json arrays.</source>
          <target state="translated">json 배열의 배열 구문.</target>
        </trans-unit>
        <trans-unit id="5973135baae02b17a741da0daeae795a22336d6f" translate="yes" xml:space="preserve">
          <source>Array to append the flags to, if any.</source>
          <target state="translated">플래그를 추가 할 배열입니다 (있는 경우).</target>
        </trans-unit>
        <trans-unit id="d290f86768d5ed39f7a46e3545ef125df15763f2" translate="yes" xml:space="preserve">
          <source>Array to which binaries (shared/static libs and object files) will be appended</source>
          <target state="translated">바이너리 (공유 / 정적 라이브러리 및 객체 파일)가 추가 될 배열</target>
        </trans-unit>
        <trans-unit id="c59fb5bcd382383b02c6f2e682a6e49d5169c774" translate="yes" xml:space="preserve">
          <source>Array type with deterministic control of memory. The memory allocated for the array is reclaimed as soon as possible; there is no reliance on the garbage collector. &lt;code&gt;Array&lt;/code&gt; uses &lt;code&gt;malloc&lt;/code&gt;, &lt;code&gt;realloc&lt;/code&gt; and &lt;code&gt;free&lt;/code&gt; for managing its own memory.</source>
          <target state="translated">메모리를 결정적으로 제어하는 ​​어레이 유형. 어레이에 할당 된 메모리는 가능한 빨리 회수됩니다. 가비지 수집기에 의존하지 않습니다. &lt;code&gt;Array&lt;/code&gt; 는 &lt;code&gt;malloc&lt;/code&gt; , &lt;code&gt;realloc&lt;/code&gt; 및 &lt;code&gt;free&lt;/code&gt; 를 사용하여 자체 메모리를 관리합니다.</target>
        </trans-unit>
        <trans-unit id="17f3d834c909f91543323d2da6d7e392df7fc04d" translate="yes" xml:space="preserve">
          <source>Array utilities.</source>
          <target state="translated">어레이 유틸리티.</target>
        </trans-unit>
        <trans-unit id="d8d1c5f297e5b542d7b3b426ee67519393b84051" translate="yes" xml:space="preserve">
          <source>Array with one &lt;code&gt;Address&lt;/code&gt; instance per socket address.</source>
          <target state="translated">소켓 주소 당 하나의 &lt;code&gt;Address&lt;/code&gt; 인스턴스가있는 배열 .</target>
        </trans-unit>
        <trans-unit id="7b02c75e5cfd1dbb8861cc9d33aefc7788debf27" translate="yes" xml:space="preserve">
          <source>Array with one &lt;code&gt;AddressInfo&lt;/code&gt; per socket address.</source>
          <target state="translated">소켓 주소 당 하나의 &lt;code&gt;AddressInfo&lt;/code&gt; 가있는 배열 .</target>
        </trans-unit>
        <trans-unit id="ccb9694106595867500e36f178956e556d5f06d5" translate="yes" xml:space="preserve">
          <source>Array!T &lt;code&gt;array&lt;/code&gt;</source>
          <target state="translated">배열! T &lt;code&gt;array&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="59ed81f06d61cee7ac46ef81d4494047f843a918" translate="yes" xml:space="preserve">
          <source>Array!bool &lt;strong id=&quot;opBinary&quot;&gt;opBinary&lt;/strong&gt;(string op, Stuff)(Stuff rhs)</source>
          <target state="translated">Array! &lt;strong id=&quot;opBinary&quot;&gt;Bool opBinary&lt;/strong&gt; (스트링 op, Stuff) (Stuff &lt;strong id=&quot;opBinary&quot;&gt;RMS&lt;/strong&gt; )</target>
        </trans-unit>
        <trans-unit id="f58b7e3beff7cb376f330022b72abdbf5e8d71a8" translate="yes" xml:space="preserve">
          <source>Array!bool &lt;strong id=&quot;opOpAssign&quot;&gt;opOpAssign&lt;/strong&gt;(string op, Stuff)(Stuff stuff)</source>
          <target state="translated">배열! bool &lt;strong id=&quot;opOpAssign&quot;&gt;opOpAssign&lt;/strong&gt; (문자열 op, 물건) (스터프 물건)</target>
        </trans-unit>
        <trans-unit id="fb8a70fa9de0823f16fd95fb5d95b4122c80f726" translate="yes" xml:space="preserve">
          <source>ArrayInitializer &lt;code&gt;ai&lt;/code&gt;</source>
          <target state="translated">ArrayInitializer &lt;code&gt;ai&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="dcde65a6ef36678480c533ad205a2b3653940979" translate="yes" xml:space="preserve">
          <source>ArrayLiteralExp &lt;code&gt;ae&lt;/code&gt;</source>
          <target state="translated">ArrayLiteralExp &lt;code&gt;ae&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="49604b859f9dbf7987784da7c49e4b4f67d157a7" translate="yes" xml:space="preserve">
          <source>ArrayLiteralExp &lt;strong id=&quot;createBlockDuplicatedArrayLiteral&quot;&gt;createBlockDuplicatedArrayLiteral&lt;/strong&gt;(UnionExp* pue, ref const Loc loc, Type type, Expression elem, size_t dim);</source>
          <target state="translated">ArrayLiteralExp &lt;strong id=&quot;createBlockDuplicatedArrayLiteral&quot;&gt;createBlockDuplicatedArrayLiteral&lt;/strong&gt; (UnionExp * pue, ref const Loc loc, Type type, Expression elem, size_t dim);</target>
        </trans-unit>
        <trans-unit id="b90cc9bfd23567a2ff5ba1f00e7c63ca6da8755e" translate="yes" xml:space="preserve">
          <source>Arrays</source>
          <target state="translated">Arrays</target>
        </trans-unit>
        <trans-unit id="5ec121f807ed23a3ee478e2902d2a39d93f6938e" translate="yes" xml:space="preserve">
          <source>Arrays (dynamic and static)</source>
          <target state="translated">배열 (동적 및 정적)</target>
        </trans-unit>
        <trans-unit id="dad86d2f90fcf8d8a3cdfa4cf789d731af0dd940" translate="yes" xml:space="preserve">
          <source>Arrays and static arrays</source>
          <target state="translated">배열과 정적 배열</target>
        </trans-unit>
        <trans-unit id="1f1d0899c823da5c8626a1dbb08800ddf6eec849" translate="yes" xml:space="preserve">
          <source>Arrays of any type can be implicitly converted to a void array; the compiler inserts the appropriate calculations so that the &lt;code&gt;.length&lt;/code&gt; of the resulting array's size is in bytes rather than number of elements. Void arrays cannot be converted back to the original type without using a cast, and it is an error to convert to an array type whose element size does not evenly divide the length of the void array.</source>
          <target state="translated">모든 유형의 배열은 암시 적으로 void 배열로 변환 될 수 있습니다. 컴파일러 는 결과 배열 크기 의 &lt;code&gt;.length&lt;/code&gt; 가 요소 수가 아닌 바이트로 되도록 적절한 계산을 삽입합니다 . 무효 배열은 캐스트를 사용하지 않고 원래 형식으로 다시 변환 할 수 없으며, 요소 크기가 공백 배열의 길이를 균등하게 나누지 않는 배열 형식으로 변환하는 것은 오류입니다.</target>
        </trans-unit>
        <trans-unit id="d07335e1b59b41b81acffb9c1b5c94e2033e5ab4" translate="yes" xml:space="preserve">
          <source>Arrays read right to left as well:</source>
          <target state="translated">배열도 오른쪽에서 왼쪽으로 읽습니다.</target>
        </trans-unit>
        <trans-unit id="0cf604cb001bdc6112fda3affb0c7674d1c4481b" translate="yes" xml:space="preserve">
          <source>Arrows</source>
          <target state="translated">Arrows</target>
        </trans-unit>
        <trans-unit id="ebe044f5962ca7b8d7aab096e7aee2bc2b61b686" translate="yes" xml:space="preserve">
          <source>As &lt;code&gt;static foreach&lt;/code&gt; is a code generation construct and not a loop, &lt;code&gt;break&lt;/code&gt; and &lt;code&gt;continue&lt;/code&gt; cannot be used to change control flow within it. Instead of breaking or continuing a suitable enclosing statement, such an usage yields an error (this is to prevent misunderstandings).</source>
          <target state="translated">같이 &lt;code&gt;static foreach&lt;/code&gt; 코드 생성 구조체 아닌 루프이다 &lt;code&gt;break&lt;/code&gt; 하고 &lt;code&gt;continue&lt;/code&gt; 그 안에서 변경 제어 플로우에 사용될 수 없다. 적절한 둘러싸는 문장을 깨거나 계속하는 대신, 그러한 사용법으로 오류가 발생합니다 (오해를 방지하기위한 것임).</target>
        </trans-unit>
        <trans-unit id="0d13756a62d354c00bff64fd46fa593358676140" translate="yes" xml:space="preserve">
          <source>As a concession to practicality, a pure function can also:</source>
          <target state="translated">실용성의 양보로서, 순수한 기능은 또한</target>
        </trans-unit>
        <trans-unit id="8bc155ad0d18590ebe40ebe2b93eb23941ceadd8" translate="yes" xml:space="preserve">
          <source>As a contract, an &lt;code&gt;assert&lt;/code&gt; represents a guarantee that the code</source>
          <target state="translated">계약으로서, &lt;code&gt;assert&lt;/code&gt; 는 코드가</target>
        </trans-unit>
        <trans-unit id="bccab5f9b93fd641ceebcd69566613681ff777b0" translate="yes" xml:space="preserve">
          <source>As a debugging aid, the compiler may insert a runtime check to verify that the expression is indeed true. If it is false, an &lt;code&gt;AssertError&lt;/code&gt; is thrown. When compiling for release, this check is not generated. The special &lt;code&gt;assert(0)&lt;/code&gt; expression, however, is generated even in release mode. See the &lt;a href=&quot;expression#AssertExpression&quot;&gt;&lt;i&gt;AssertExpression&lt;/i&gt;&lt;/a&gt; documentation for more information.</source>
          <target state="translated">디버깅을 돕기 위해 컴파일러는 런타임 검사를 삽입하여 표현식이 실제로 참인지 확인할 수 있습니다. False이면 &lt;code&gt;AssertError&lt;/code&gt; 가 발생합니다. 릴리스를 위해 컴파일 할 때는이 검사가 생성되지 않습니다. 그러나 특수 &lt;code&gt;assert(0)&lt;/code&gt; 표현식은 릴리스 모드에서도 생성됩니다. 자세한 내용은 &lt;a href=&quot;expression#AssertExpression&quot;&gt;&lt;i&gt;AssertExpression&lt;/i&gt;&lt;/a&gt; 설명서를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="90a896ea477e7a62fdbd266c90ef3478e166538a" translate="yes" xml:space="preserve">
          <source>As a micro-optimization, to avoid the heap allocation associated with &lt;code&gt;task&lt;/code&gt; or with the creation of a closure.</source>
          <target state="translated">&lt;code&gt;task&lt;/code&gt; 최적화 또는 클로저 생성과 관련된 힙 할당을 피하기위한 미세 최적화 .</target>
        </trans-unit>
        <trans-unit id="842753f613e1812047f79b9da908210026f9a41f" translate="yes" xml:space="preserve">
          <source>As above, but also provides &lt;code&gt;back&lt;/code&gt; and &lt;code&gt;popBack&lt;/code&gt;.</source>
          <target state="translated">위와 같이 &lt;code&gt;back&lt;/code&gt; 과 &lt;code&gt;popBack&lt;/code&gt; 도 제공합니다 .</target>
        </trans-unit>
        <trans-unit id="9a95b268782f9af6c10edd99d4e3bb5baafff0eb" translate="yes" xml:space="preserve">
          <source>As above, but may be reallocated later. Examples of types fitting this description are &lt;code&gt;int[]&lt;/code&gt;, &lt;code&gt;double[]&lt;/code&gt;, &lt;code&gt;Tuple!(int, long)[]&lt;/code&gt;, but not &lt;code&gt;Tuple!(int, string)[]&lt;/code&gt;, which contains an indirection.</source>
          <target state="translated">위와 같지만 나중에 재 할당 될 수 있습니다. 이 설명에 맞는 유형의 예는 &lt;code&gt;int[]&lt;/code&gt; , &lt;code&gt;double[]&lt;/code&gt; , &lt;code&gt;Tuple!(int, long)[]&lt;/code&gt; 이지만 &lt;code&gt;Tuple!(int, string)[]&lt;/code&gt; 아닙니다 .</target>
        </trans-unit>
        <trans-unit id="ada3120f9cc1043d7b4f9c611d3e84f82bcb254e" translate="yes" xml:space="preserve">
          <source>As above, but may embed indirections. Examples of types fitting this description are &lt;code&gt;int*[]&lt;/code&gt;, &lt;code&gt;Object[]&lt;/code&gt;, &lt;code&gt;Tuple!(int, string)[]&lt;/code&gt;.</source>
          <target state="translated">위와 같지만 간접적으로 포함 할 수 있습니다. 이 설명에 적합한 유형의 예는 &lt;code&gt;int*[]&lt;/code&gt; , &lt;code&gt;Object[]&lt;/code&gt; , &lt;code&gt;Tuple!(int, string)[]&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="1700838138f9af03c11ccaa20b548dd32d2a5c61" translate="yes" xml:space="preserve">
          <source>As above, but the memory allocated is aligned at &lt;code&gt;a&lt;/code&gt; bytes.</source>
          <target state="translated">위와 같이 할당 된 메모리 &lt;code&gt;a&lt;/code&gt; 바이트 단위 로 정렬 됩니다.</target>
        </trans-unit>
        <trans-unit id="9a7b2b5d58503b9d84dce03ccae75f857fd6475e" translate="yes" xml:space="preserve">
          <source>As above, but the type may be appended to in the future. Example: &lt;code&gt;string&lt;/code&gt;.</source>
          <target state="translated">위와 같이 유형이 추후에 추가 될 수 있습니다. 예 : &lt;code&gt;string&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="67b44aad993023067b75a99b577d6a3bad9df809" translate="yes" xml:space="preserve">
          <source>As above, but the type may embed references. Example: &lt;code&gt;immutable(Object)[]&lt;/code&gt;.</source>
          <target state="translated">위와 같이 형식에 참조가 포함될 수 있습니다. 예 : &lt;code&gt;immutable(Object)[]&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a0ab111de9460a5c459418af453cc0583e8938ad" translate="yes" xml:space="preserve">
          <source>As an exception to the above, curl_off_t shall be typedef'ed to a 32-bit wide signed integral data type if there is no 64-bit type.</source>
          <target state="translated">위의 예외로 curl_off_t는 64 비트 유형이없는 경우 32 비트 너비의 부호있는 정수 데이터 유형으로 typedef됩니다.</target>
        </trans-unit>
        <trans-unit id="00c376f2504564e95535f66220527b7aef723e32" translate="yes" xml:space="preserve">
          <source>As copying the range means copying all elements, it can be safely returned from functions. For the same reason, copying the returned range may be expensive for a large number of arguments.</source>
          <target state="translated">범위를 복사한다는 것은 모든 요소를 ​​복사하는 것을 의미하므로 함수에서 안전하게 반환 할 수 있습니다. 같은 이유로 반환 된 범위를 복사하면 많은 인수에 대해 비용이 많이들 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="86ffd7c99fd994cc802f084df86d92e7d718ebb0" translate="yes" xml:space="preserve">
          <source>As long as the target range elements support assignment from source range elements, different types of ranges are accepted:</source>
          <target state="translated">대상 범위 요소가 소스 범위 요소에서의 할당을 지원하는 한 다른 유형의 범위가 허용됩니다.</target>
        </trans-unit>
        <trans-unit id="89f24648855e3c77be3def51419022b8377886d0" translate="yes" xml:space="preserve">
          <source>As of this time, &lt;code&gt;std.experimental.allocator&lt;/code&gt; is not integrated with D's built-in operators that allocate memory, such as &lt;code&gt;new&lt;/code&gt;, array literals, or array concatenation operators. That means &lt;code&gt;std.experimental.allocator&lt;/code&gt; is opt-in</source>
          <target state="translated">현재 &lt;code&gt;std.experimental.allocator&lt;/code&gt; 는 &lt;code&gt;new&lt;/code&gt; , 배열 리터럴 또는 배열 연결 연산자 와 같이 메모리를 할당하는 D의 내장 연산자와 통합되어 있지 않습니다 . 이는 &lt;code&gt;std.experimental.allocator&lt;/code&gt; 가 옵트 인 되었음을 의미합니다 .</target>
        </trans-unit>
        <trans-unit id="102c86647896232382d7c6363a032a8965f35f84" translate="yes" xml:space="preserve">
          <source>As the above example shows, a different compile-time argument is passed to &lt;code&gt;opDollar&lt;/code&gt; depending on which argument it appears in. A &lt;code&gt;$&lt;/code&gt; appearing in the first argument gets translated to &lt;code&gt;opDollar!0&lt;/code&gt;, a &lt;code&gt;$&lt;/code&gt; appearing in the second argument gets translated to &lt;code&gt;opDollar!1&lt;/code&gt;, and so on. Thus, the appropriate value for &lt;code&gt;$&lt;/code&gt; can be returned to implement multidimensional arrays.</source>
          <target state="translated">위의 예에서 보듯이, 다른 컴파일시 인수가 전달됩니다 &lt;code&gt;opDollar&lt;/code&gt; 가에 표시되는 인수에 따라 다릅니다. &lt;code&gt;$&lt;/code&gt; 는 첫 번째 인수에 나타나는이로 번역됩니다 &lt;code&gt;opDollar!0&lt;/code&gt; A, &lt;code&gt;$&lt;/code&gt; 두 번째 인수에 나타나는이로 번역됩니다 &lt;code&gt;opDollar!1&lt;/code&gt; 등. 따라서 다차원 배열을 구현하기 위해 &lt;code&gt;$&lt;/code&gt; 에 적절한 값을 반환 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6f1f55e4d756cae86481e151850fb4d8b6d4d597" translate="yes" xml:space="preserve">
          <source>As the interval goes to negative infinity, the range is always iterated over backwards, never forwards. &lt;code&gt;func&lt;/code&gt; must generate a time point going in the proper direction of iteration, or a &lt;a href=&quot;std_datetime_date#DateTimeException&quot;&gt;&lt;code&gt;std.datetime.date.DateTimeException&lt;/code&gt;&lt;/a&gt; will be thrown. So, the time points that &lt;code&gt;func&lt;/code&gt; generates must be earlier in time than the one passed to it. If it's either identical or later in time, then a &lt;a href=&quot;std_datetime_date#DateTimeException&quot;&gt;&lt;code&gt;std.datetime.date.DateTimeException&lt;/code&gt;&lt;/a&gt; will be thrown.</source>
          <target state="translated">간격이 음의 무한대가되면 범위는 항상 뒤로 거꾸로 반복되고 앞으로는 반복되지 않습니다. &lt;code&gt;func&lt;/code&gt; 은 올바른 반복 방향으로 진행하는 시점을 생성해야합니다 . &lt;a href=&quot;std_datetime_date#DateTimeException&quot;&gt; &lt;code&gt;std.datetime.date.DateTimeException&lt;/code&gt; &lt;/a&gt; 이 발생합니다. 따라서 &lt;code&gt;func&lt;/code&gt; 이 생성하는 시점은 전달 된 시점보다 빨라야합니다. 동일하거나 이후의 경우 &lt;a href=&quot;std_datetime_date#DateTimeException&quot;&gt; &lt;code&gt;std.datetime.date.DateTimeException&lt;/code&gt; &lt;/a&gt; 이 발생합니다.</target>
        </trans-unit>
        <trans-unit id="19397d297232fda90f291340ee30b5e3c1ea48c9" translate="yes" xml:space="preserve">
          <source>As the interval goes to positive infinity, the range is always iterated over forwards, never backwards. &lt;code&gt;func&lt;/code&gt; must generate a time point going in the proper direction of iteration, or a &lt;a href=&quot;std_datetime_date#DateTimeException&quot;&gt;&lt;code&gt;std.datetime.date.DateTimeException&lt;/code&gt;&lt;/a&gt; will be thrown. So, the time points that &lt;code&gt;func&lt;/code&gt; generates must be later in time than the one passed to it. If it's either identical or earlier in time, then a &lt;a href=&quot;std_datetime_date#DateTimeException&quot;&gt;&lt;code&gt;std.datetime.date.DateTimeException&lt;/code&gt;&lt;/a&gt; will be thrown.</source>
          <target state="translated">구간이 양의 무한대로 진행됨에 따라 범위는 항상 앞뒤로 반복되지 않으며 뒤로는 반복되지 않습니다. &lt;code&gt;func&lt;/code&gt; 은 올바른 반복 방향으로 진행되는 시점을 생성해야합니다 . &lt;a href=&quot;std_datetime_date#DateTimeException&quot;&gt; &lt;code&gt;std.datetime.date.DateTimeException&lt;/code&gt; &lt;/a&gt; 이 발생합니다. 따라서 &lt;code&gt;func&lt;/code&gt; 이 생성하는 시점은 전달 된 시점보다 늦어 야합니다. 동일하거나 이전의 시간이면 &lt;a href=&quot;std_datetime_date#DateTimeException&quot;&gt; &lt;code&gt;std.datetime.date.DateTimeException&lt;/code&gt; &lt;/a&gt; 이 발생합니다.</target>
        </trans-unit>
        <trans-unit id="85319de6635b6d77d85a430a22ed2839720cedf1" translate="yes" xml:space="preserve">
          <source>As we generate code, collect information about what parts of NT exception handling we need.</source>
          <target state="translated">코드를 생성 할 때 필요한 NT 예외 처리 부분에 대한 정보를 수집하십시오.</target>
        </trans-unit>
        <trans-unit id="51268903c8fb9b838b2eb55d7979a33593c37355" translate="yes" xml:space="preserve">
          <source>As with &lt;a href=&quot;#lists&quot;&gt;lists&lt;/a&gt;, note that the initial &lt;code&gt;*&lt;/code&gt; in the example above will be stripped because it is part of a documentation comment that is delimited with asterisks, so you need at least three subsequent asterisks.</source>
          <target state="translated">&lt;a href=&quot;#lists&quot;&gt;list&lt;/a&gt; 와 마찬가지로 , 위의 예제에서 초기 &lt;code&gt;*&lt;/code&gt; 는 별표로 구분 된 설명서 주석의 일부이므로 제거되므로 최소 3 개의 별표가 필요합니다.</target>
        </trans-unit>
        <trans-unit id="ac7e95e21d2700c2e5e4f32e9e7f466df23faf33" translate="yes" xml:space="preserve">
          <source>As with &lt;a href=&quot;#replaceAll&quot;&gt;&lt;code&gt;replaceAll&lt;/code&gt;&lt;/a&gt; there are 2 overloads - one with a format string, the other one with a user defined functor.</source>
          <target state="translated">&lt;a href=&quot;#replaceAll&quot;&gt; &lt;code&gt;replaceAll&lt;/code&gt; &lt;/a&gt; 과 마찬가지로 두 가지 오버로드가 있습니다. 하나는 형식 문자열이고 다른 하나는 사용자 정의 functor입니다.</target>
        </trans-unit>
        <trans-unit id="4799d67b11d550709cf6847100b2162c1067dd7e" translate="yes" xml:space="preserve">
          <source>As with any global resource, setting &lt;code&gt;theAllocator&lt;/code&gt; and &lt;code&gt;processAllocator&lt;/code&gt; should not be done often and casually. In particular, allocating memory with one allocator and deallocating with another causes undefined behavior. Typically, these variables are set during application initialization phase and last through the application.  To avoid this, long-lived objects that need to perform allocations, reallocations, and deallocations relatively often may want to store a reference to the allocator object they use throughout their lifetime. Then, instead of using &lt;code&gt;theAllocator&lt;/code&gt; for internal allocation-related tasks, they'd use the internally held reference. For example, consider a user-defined hash table:</source>
          <target state="translated">모든 글로벌 자원과 마찬가지로 &lt;code&gt;theAllocator&lt;/code&gt; 및 &lt;code&gt;processAllocator&lt;/code&gt; 설정을 자주 수행하지 않아야합니다. 특히, 하나의 할당 자와 함께 메모리를 할당하고 다른 할당 자와 함께 할당을 해제하면 정의되지 않은 동작이 발생합니다. 일반적으로 이러한 변수는 응용 프로그램 초기화 단계에서 설정되고 응용 프로그램을 통해 마지막에 설정됩니다. 이를 피하기 위해 할당, 재 할당 및 할당 해제를 상대적으로 수행해야하는 수명이 긴 객체는 수명 기간 동안 사용하는 할당 자 객체에 대한 참조를 저장하는 것이 좋습니다. 그런 다음 내부 할당 관련 작업에 &lt;code&gt;theAllocator&lt;/code&gt; 를 사용하는 대신 내부적으로 보유 된 참조를 사용합니다. 예를 들어, 사용자 정의 해시 테이블을 고려하십시오.</target>
        </trans-unit>
        <trans-unit id="a187fce74f3c088795c6e5b47e1056e5126c0fae" translate="yes" xml:space="preserve">
          <source>Ask curl for its fd_set sets. The app can use these to select() or poll() on. We want curl_multi_perform() called as soon as one of them are ready.</source>
          <target state="translated">curl에 fd_set 세트를 요청하십시오. 앱은이를 사용하여 select () 또는 poll ()을 켤 수 있습니다. curl_multi_perform () 중 하나가 준비 되 자마자 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="407c3cb45f2c60add113bb40a5a457b3e7b28548" translate="yes" xml:space="preserve">
          <source>Ask the multi handle if there's any messages/informationals from the individual transfers. Messages include informationals such as error code from the transfer or just the fact that a transfer is completed. More details on these should be written down as well.</source>
          <target state="translated">개별 전송에서 메시지 / 정보가 있는지 멀티 핸들에 문의하십시오. 메시지에는 전송 오류 코드 또는 전송 완료 사실과 같은 정보가 포함됩니다. 이것들에 대한 자세한 내용도 기록해야합니다.</target>
        </trans-unit>
        <trans-unit id="00a0f49dff6a5c0c910755166ec70967a98d46e8" translate="yes" xml:space="preserve">
          <source>Asm Statement</source>
          <target state="translated">Asm 명세서</target>
        </trans-unit>
        <trans-unit id="1afc7a2cc88dee030813b66323a3af633b890e22" translate="yes" xml:space="preserve">
          <source>Asm instruction</source>
          <target state="translated">asm 명령</target>
        </trans-unit>
        <trans-unit id="790208a1b6c1cdd2c13b57adc90b509e7d203c6c" translate="yes" xml:space="preserve">
          <source>Asm instructions are terminated by a ;, not by an end of line.</source>
          <target state="translated">Asm 명령어는 줄 끝이 아닌;로 끝납니다.</target>
        </trans-unit>
        <trans-unit id="8a7e3825909e47cd662a1349cd9c1f9bb88f142c" translate="yes" xml:space="preserve">
          <source>Asm statement</source>
          <target state="translated">Asm 진술</target>
        </trans-unit>
        <trans-unit id="90e6cfa22a58ec4314abe99303529bc30df1cd45" translate="yes" xml:space="preserve">
          <source>AsmStatement</source>
          <target state="translated">AsmStatement</target>
        </trans-unit>
        <trans-unit id="7c9be4e0207ca69f4c35ec2cd41e7f07aef7a2ef" translate="yes" xml:space="preserve">
          <source>Assemble &lt;code&gt;values&lt;/code&gt; into a range that carries all its elements in-situ.</source>
          <target state="translated">모든 요소를 ​​현장에서 운반 할 수있는 범위로 &lt;code&gt;values&lt;/code&gt; 을 조립 합니다 .</target>
        </trans-unit>
        <trans-unit id="c617a006ef306c30de2e4c3a12d2334fbba7a9af" translate="yes" xml:space="preserve">
          <source>Assembler instructions can be labeled just like other statements. They can be the target of goto statements. For example:</source>
          <target state="translated">어셈블러 명령어는 다른 명령문과 같이 레이블을 지정할 수 있습니다. 그들은 goto 문의 대상이 될 수 있습니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="e421bc1f45d2b482fe2ff716000545e5646f7277" translate="yes" xml:space="preserve">
          <source>Assembler instructions must be located inside an &lt;code&gt;asm&lt;/code&gt; block. Like functions, &lt;code&gt;asm&lt;/code&gt; statements must be anotated with adequate function attributes to be compatible with the caller. Asm statements attributes must be explicitly defined, they are not infered.</source>
          <target state="translated">어셈블러 명령어는 &lt;code&gt;asm&lt;/code&gt; 블록 안에 있어야합니다 . 함수와 마찬가지로 &lt;code&gt;asm&lt;/code&gt; 문은 호출자와 호환되도록 적절한 함수 속성으로 주석을 달아야합니다. Asm 문 속성은 명시 적으로 정의되어야하며 추론되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="714e45eb8c405fbdb34a796120ab67c6ae2d72b9" translate="yes" xml:space="preserve">
          <source>Assembling Your Own Allocator</source>
          <target state="translated">자신의 할당자를 조립</target>
        </trans-unit>
        <trans-unit id="b52465945f6ab45ca943fa9fa1e9d738eca2cc3b" translate="yes" xml:space="preserve">
          <source>Assert Contract</source>
          <target state="translated">계약서</target>
        </trans-unit>
        <trans-unit id="881c910749065a58abd709f4221af38a82fabadc" translate="yes" xml:space="preserve">
          <source>Assert Expressions</source>
          <target state="translated">어설 션 식</target>
        </trans-unit>
        <trans-unit id="c7a5b9464524d049c6fe8ff66c5b2bdc7b543fff" translate="yes" xml:space="preserve">
          <source>Assert Failure</source>
          <target state="translated">실패 주장</target>
        </trans-unit>
        <trans-unit id="d7d72241e6b5848e305187f74df13930409f541f" translate="yes" xml:space="preserve">
          <source>Assert checks.</source>
          <target state="translated">검사를 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="843aa1baaf4b9511699ef763eb98fe79f5099f70" translate="yes" xml:space="preserve">
          <source>Assert failure functions in the GLIBC library.</source>
          <target state="translated">GLIBC 라이브러리에서 실패 함수를 주장하십시오.</target>
        </trans-unit>
        <trans-unit id="94e6ce29a6460dbe0c0daaaab648acdb3c2883d7" translate="yes" xml:space="preserve">
          <source>AssertExpression</source>
          <target state="translated">AssertExpression</target>
        </trans-unit>
        <trans-unit id="a422512dc44cc15063776e77a81a3f8e6eb0d6de" translate="yes" xml:space="preserve">
          <source>AssertExpressions</source>
          <target state="translated">AssertExpressions</target>
        </trans-unit>
        <trans-unit id="49bf55dc112eb3597726ba8ecf785a4fae4cbce0" translate="yes" xml:space="preserve">
          <source>Assertions</source>
          <target state="translated">Assertions</target>
        </trans-unit>
        <trans-unit id="2f19e0385b8f9d7c5a7eb86bb2c7ba5f0e720900" translate="yes" xml:space="preserve">
          <source>Asserts that the given condition is &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">주어진 조건이 &lt;code&gt;true&lt;/code&gt; 이라고 주장 합니다 .</target>
        </trans-unit>
        <trans-unit id="120daecc558f73b157187685546d1c314c351c50" translate="yes" xml:space="preserve">
          <source>Asserts that the given expression does</source>
          <target state="translated">주어진 표현이</target>
        </trans-unit>
        <trans-unit id="bba2525f9e139559b132642a96447978bab43209" translate="yes" xml:space="preserve">
          <source>Asserts that the given expression throws the given type of &lt;code&gt;Throwable&lt;/code&gt;. The &lt;code&gt;Throwable&lt;/code&gt; is caught and does not escape assertThrown. However, any other &lt;code&gt;Throwable&lt;/code&gt;s</source>
          <target state="translated">주어진 표현식이 주어진 유형의 &lt;code&gt;Throwable&lt;/code&gt; 을 던지도록합니다 . &lt;code&gt;Throwable&lt;/code&gt; 잡힌 및 assertThrown을 탈출하지 않습니다. 그러나, 다른 &lt;code&gt;Throwable&lt;/code&gt; 의</target>
        </trans-unit>
        <trans-unit id="17e81c7a1f671e7e24608f38c1a74f6ff4e02c7b" translate="yes" xml:space="preserve">
          <source>Assign Expressions</source>
          <target state="translated">식 할당</target>
        </trans-unit>
        <trans-unit id="7f86ed464704ba1c6b681ec2726c5fbeefb20008" translate="yes" xml:space="preserve">
          <source>Assign a value to the current thread's instance. This function has the same caveats as its overload.</source>
          <target state="translated">현재 스레드의 인스턴스에 값을 지정하십시오. 이 기능은 과부하와 동일한 경고가 있습니다.</target>
        </trans-unit>
        <trans-unit id="76d3ba357057c554bcbcf6a7822d736c1e09e3bc" translate="yes" xml:space="preserve">
          <source>AssignExpression</source>
          <target state="translated">AssignExpression</target>
        </trans-unit>
        <trans-unit id="365e967e191a82b0dfa667724d9ef332e0565a97" translate="yes" xml:space="preserve">
          <source>Assigned to each element of range</source>
          <target state="translated">범위의 각 요소에 할당</target>
        </trans-unit>
        <trans-unit id="2490af57d4237289ce473c7f9d5d5a7e29bbba7a" translate="yes" xml:space="preserve">
          <source>Assignment Operator Expressions</source>
          <target state="translated">대입 연산자 식</target>
        </trans-unit>
        <trans-unit id="eda4293e36885d0479c5dae22502b3085be9643a" translate="yes" xml:space="preserve">
          <source>Assignment Operator Overloading</source>
          <target state="translated">할당 연산자 오버로딩</target>
        </trans-unit>
        <trans-unit id="3bf524ec3b928fa7a8316d5c4f46f6427bafeb2e" translate="yes" xml:space="preserve">
          <source>Assignment from another &lt;code&gt;Tuple&lt;/code&gt;.</source>
          <target state="translated">다른 &lt;code&gt;Tuple&lt;/code&gt; 에서 할당 .</target>
        </trans-unit>
        <trans-unit id="ad22a9ad0d4f785e89bbd9df67b80efd310fb186" translate="yes" xml:space="preserve">
          <source>Assignment from another BigInt.</source>
          <target state="translated">다른 BigInt에서 할당.</target>
        </trans-unit>
        <trans-unit id="c734c417d0433b21b0c33224a47f994821944ee9" translate="yes" xml:space="preserve">
          <source>Assignment from built-in integer types.</source>
          <target state="translated">내장 정수 유형에서 지정.</target>
        </trans-unit>
        <trans-unit id="a2c6b545c0015432c32a5f8afe451255b5b743ef" translate="yes" xml:space="preserve">
          <source>Assignment helper functions</source>
          <target state="translated">할당 도우미 기능</target>
        </trans-unit>
        <trans-unit id="84aa2531d79787134c4a3ba8faa799337584a358" translate="yes" xml:space="preserve">
          <source>Assignment operator. Has the same constraints as the constructor.</source>
          <target state="translated">할당 연산자. 생성자와 동일한 제약 조건이 있습니다.</target>
        </trans-unit>
        <trans-unit id="aa098245c1ec6b3b4a9cec4ec49f68bc2b3dc905" translate="yes" xml:space="preserve">
          <source>Assignment operators</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="99b05821addb139efb582d5733eb165057e45a88" translate="yes" xml:space="preserve">
          <source>Assignment to &lt;code&gt;super&lt;/code&gt; is not allowed.</source>
          <target state="translated">&lt;code&gt;super&lt;/code&gt; 할당 은 허용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="d46d956c7065444efb33c5f5602fe16eab572e8a" translate="yes" xml:space="preserve">
          <source>Assignment to &lt;code&gt;this&lt;/code&gt; is not allowed.</source>
          <target state="translated">에 할당 &lt;code&gt;this&lt;/code&gt; 허용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="ac9f4d1b12010a7c21b70ea99324f1a0dd8bcccd" translate="yes" xml:space="preserve">
          <source>Assigns &lt;code&gt;v&lt;/code&gt; to the first element of the container.</source>
          <target state="translated">컨테이너의 첫 번째 요소에 &lt;code&gt;v&lt;/code&gt; 를 할당 합니다.</target>
        </trans-unit>
        <trans-unit id="922d6285649b37db600cf15c96dc723863c5afe5" translate="yes" xml:space="preserve">
          <source>Assigns &lt;code&gt;v&lt;/code&gt; to the last element of the container.</source>
          <target state="translated">컨테이너의 마지막 요소에 &lt;code&gt;v&lt;/code&gt; 를 할당 합니다.</target>
        </trans-unit>
        <trans-unit id="9af0d121c1f00202f8eb1627dd5494f59fbf6800" translate="yes" xml:space="preserve">
          <source>Assigns &lt;code&gt;value&lt;/code&gt; to each element of input range &lt;code&gt;range&lt;/code&gt;.</source>
          <target state="translated">입력 범위 &lt;code&gt;range&lt;/code&gt; 의 각 요소에 &lt;code&gt;value&lt;/code&gt; 을 할당 합니다 .</target>
        </trans-unit>
        <trans-unit id="e5f7c4ee9f81cf1e0b7f9cbc458913458f588507" translate="yes" xml:space="preserve">
          <source>Assigns &lt;code&gt;value&lt;/code&gt; to the internally-held state.</source>
          <target state="translated">내부 보류 상태에 &lt;code&gt;value&lt;/code&gt; 을 할당 합니다 .</target>
        </trans-unit>
        <trans-unit id="21c3bd56c75643c04bab89ad011aec98a36c3a16" translate="yes" xml:space="preserve">
          <source>Assigns &lt;code&gt;value&lt;/code&gt; to the internally-held state. If the assignment succeeds, &lt;code&gt;this&lt;/code&gt; becomes non-null.</source>
          <target state="translated">내부 보류 상태에 &lt;code&gt;value&lt;/code&gt; 을 할당 합니다 . 할당이 성공하면, &lt;code&gt;this&lt;/code&gt; null이 아닌이된다.</target>
        </trans-unit>
        <trans-unit id="8d0fc7c17a3a2b5f1514756ed138007924a3a66a" translate="yes" xml:space="preserve">
          <source>Assigns &lt;code&gt;value&lt;/code&gt; to the internally-held state. If the assignment succeeds, &lt;code&gt;this&lt;/code&gt; becomes non-null. No null checks are made. Note that the assignment may leave &lt;code&gt;this&lt;/code&gt; in the null state.</source>
          <target state="translated">내부 보류 상태에 &lt;code&gt;value&lt;/code&gt; 을 할당 합니다 . 할당이 성공하면, &lt;code&gt;this&lt;/code&gt; null이 아닌이된다. 널 검사가 수행되지 않습니다. 할당은 &lt;code&gt;this&lt;/code&gt; null 상태로 남겨 둘 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="5b359bc586830b69163a1e75c910372bb60f5dad" translate="yes" xml:space="preserve">
          <source>Assigns a &lt;code&gt;VariantN&lt;/code&gt; from a generic argument. Statically rejects disallowed types.</source>
          <target state="translated">일반 인수에서 &lt;code&gt;VariantN&lt;/code&gt; 을 할당합니다 . 허용되지 않는 유형을 정적으로 거부합니다.</target>
        </trans-unit>
        <trans-unit id="44eb8314103f2fdd05abf9443854b7e8c14d4780" translate="yes" xml:space="preserve">
          <source>Assigns a file to another. The target of the assignment gets detached from whatever file it was attached to, and attaches itself to the new file.</source>
          <target state="translated">파일을 다른 파일에 할당합니다. 할당 대상은 첨부 된 파일에서 분리되어 새 파일에 첨부됩니다.</target>
        </trans-unit>
        <trans-unit id="057b5aa3c0ad5c43ab19d19f8ce9f6db63dca13d" translate="yes" xml:space="preserve">
          <source>Assigns a logical thread to execute the supplied op.</source>
          <target state="translated">제공된 op를 실행하기 위해 논리 스레드를 할당합니다.</target>
        </trans-unit>
        <trans-unit id="5425da91b2931a4dd8cdec7b13e0afa9866f1762" translate="yes" xml:space="preserve">
          <source>Assigns the given &lt;code&gt;value&lt;/code&gt; to the environment variable with the given &lt;code&gt;name&lt;/code&gt;. If &lt;code&gt;value&lt;/code&gt; is null the variable is removed from environment.</source>
          <target state="translated">주어진 &lt;code&gt;name&lt;/code&gt; 가진 환경 변수에 주어진 &lt;code&gt;value&lt;/code&gt; 을 할당합니다 . 경우 &lt;code&gt;value&lt;/code&gt; 널 변수는 환경으로부터 제거된다.</target>
        </trans-unit>
        <trans-unit id="a6b3ed4789854a21da3d57b64bb5165df47849f8" translate="yes" xml:space="preserve">
          <source>Assigns to the &lt;code&gt;n&lt;/code&gt;th element in the composite range. Defined if all ranges offer random access.</source>
          <target state="translated">합성 범위에서 &lt;code&gt;n&lt;/code&gt; 번째 요소에 할당합니다 . 모든 범위가 임의 액세스를 제공하는지 정의합니다.</target>
        </trans-unit>
        <trans-unit id="a41d06f6960668b2b925acd3bf255f8df4491e62" translate="yes" xml:space="preserve">
          <source>AssocArrayLiteral</source>
          <target state="translated">AssocArrayLiteral</target>
        </trans-unit>
        <trans-unit id="5a9bcf3e687e72baa7a855ea1562aeb0b0f6c922" translate="yes" xml:space="preserve">
          <source>AssocArrayLiteralExp &lt;code&gt;ae&lt;/code&gt;</source>
          <target state="translated">AssocArrayLiteralExp &lt;code&gt;ae&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="47c12f36c1b476d37e1b0680000a7ced07747bab" translate="yes" xml:space="preserve">
          <source>Associate a local address with this socket.</source>
          <target state="translated">로컬 주소를이 소켓과 연결하십시오.</target>
        </trans-unit>
        <trans-unit id="6fdc76eca25e9805145ab4faa10fd711ec8e7f73" translate="yes" xml:space="preserve">
          <source>Associates name with tid in a process-local map. When the thread represented by tid terminates, any names associated with it will be automatically unregistered.</source>
          <target state="translated">프로세스 로컬 맵에서 이름을 tid와 연관시킵니다. tid로 표시되는 스레드가 종료되면 이와 관련된 모든 이름이 자동으로 등록 취소됩니다.</target>
        </trans-unit>
        <trans-unit id="d00bb7dcc304b2d3b149b7f7680cc932d7d86d19" translate="yes" xml:space="preserve">
          <source>Associates name with tid.</source>
          <target state="translated">이름을 tid와 연관시킵니다.</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
