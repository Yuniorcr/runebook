<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="d">
    <body>
      <group id="d">
        <trans-unit id="560e8754d1a43d2889127379ce8941035430acdf" translate="yes" xml:space="preserve">
          <source>Identity Assignment Overload</source>
          <target state="translated">아이디 할당 과부하</target>
        </trans-unit>
        <trans-unit id="feaad94f17d0151c7ee9d808da8437d06bd6ced9" translate="yes" xml:space="preserve">
          <source>Identity Expressions</source>
          <target state="translated">신원 표현</target>
        </trans-unit>
        <trans-unit id="3541f48427fcdd81e30c7c16278c379163644459" translate="yes" xml:space="preserve">
          <source>Ideographic</source>
          <target state="translated">Ideographic</target>
        </trans-unit>
        <trans-unit id="5b6b53689a3fc635c459675544040944bd74d306" translate="yes" xml:space="preserve">
          <source>Ideographic Description Characters</source>
          <target state="translated">표의 문자 설명</target>
        </trans-unit>
        <trans-unit id="250ad5161fad3e8519e80733a4a75b5049da3f8e" translate="yes" xml:space="preserve">
          <source>Idiomatic Use of &lt;code&gt;std.experimental.allocator&lt;/code&gt;</source>
          <target state="translated">의 관용적 사용 &lt;code&gt;std.experimental.allocator&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="751c68a3471b1c791efaee0a8e7c24ea0c266efd" translate="yes" xml:space="preserve">
          <source>If</source>
          <target state="translated">If</target>
        </trans-unit>
        <trans-unit id="828467146cd8af7a4600851262e42a7b8fdfff46" translate="yes" xml:space="preserve">
          <source>If !is null, elements[] can be sparse and basis is used for the &quot;default&quot; element value. In other words, non-null elements[i] overrides this 'basis' value.</source>
          <target state="translated">!가 null 인 경우 elements []는 희소 할 수 있으며 &quot;default&quot;요소 값에 기본이 사용됩니다. 다시 말해, 널이 아닌 요소 [i]는이 '기본'값보다 우선합니다.</target>
        </trans-unit>
        <trans-unit id="9ddd459237f2459c44b509144a91e81da646bb40" translate="yes" xml:space="preserve">
          <source>If 'e' is a tree of commas, returns the rightmost expression by stripping off it from the tree. The remained part of the tree is returned via e0. Otherwise 'e' is directly returned and e0 is set to NULL.</source>
          <target state="translated">'e'가 쉼표의 트리이면 트리에서 제거하여 가장 오른쪽 표현식을 반환합니다. 트리의 나머지 부분은 e0을 통해 반환됩니다. 그렇지 않으면 'e'가 직접 리턴되고 e0이 NULL로 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="1b4dc8c105f5a3f750e979db674fe11913e62d44" translate="yes" xml:space="preserve">
          <source>If &lt;a href=&quot;std_range_primitives#ElementType&quot;&gt;&lt;code&gt;std.range.primitives.ElementType&lt;/code&gt;&lt;/a&gt;!R is a floating-point type and &lt;code&gt;R&lt;/code&gt; is a &lt;a href=&quot;std_range_primitives#isRandomAccessRange&quot;&gt;random-access range&lt;/a&gt; with length and slicing, then &lt;code&gt;sum&lt;/code&gt; uses the &lt;a href=&quot;http://en.wikipedia.org/wiki/Pairwise_summation&quot;&gt;pairwise summation&lt;/a&gt; algorithm.</source>
          <target state="translated">경우 &lt;a href=&quot;std_range_primitives#ElementType&quot;&gt; &lt;code&gt;std.range.primitives.ElementType&lt;/code&gt; &lt;/a&gt; ! R 부동 소수점 타입이고, &lt;code&gt;R&lt;/code&gt; 은 A는 &lt;a href=&quot;std_range_primitives#isRandomAccessRange&quot;&gt;랜덤 액세스 범위&lt;/a&gt; 길이로 슬라이싱하고 &lt;code&gt;sum&lt;/code&gt; 용도 &lt;a href=&quot;http://en.wikipedia.org/wiki/Pairwise_summation&quot;&gt;페어 합계&lt;/a&gt; 알고리즘.</target>
        </trans-unit>
        <trans-unit id="d3c45083751ac69c2e8e598d9798f65c4de37c86" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;!!value&lt;/code&gt; is true, &lt;code&gt;value&lt;/code&gt; is returned. Otherwise, &lt;code&gt;new WindowsException(GetLastError(), msg)&lt;/code&gt; is thrown. &lt;code&gt;WindowsException&lt;/code&gt; assumes that the last operation set &lt;code&gt;GetLastError()&lt;/code&gt; appropriately.</source>
          <target state="translated">경우 &lt;code&gt;!!value&lt;/code&gt; 참, &lt;code&gt;value&lt;/code&gt; 반환됩니다. 그렇지 않으면 &lt;code&gt;new WindowsException(GetLastError(), msg)&lt;/code&gt; 이 발생합니다. &lt;code&gt;WindowsException&lt;/code&gt; 은 마지막 작업이 &lt;code&gt;GetLastError()&lt;/code&gt; 적절하게 설정했다고 가정합니다 .</target>
        </trans-unit>
        <trans-unit id="8df9d33ad5bc28652f3433433542fda31081bb55" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;!isInfinite!Source&lt;/code&gt; and &lt;code&gt;source.walkLength&lt;/code&gt; is not evenly divisible by &lt;code&gt;chunkSize&lt;/code&gt;, the back element of this range will contain fewer than &lt;code&gt;chunkSize&lt;/code&gt; elements.</source>
          <target state="translated">경우 &lt;code&gt;!isInfinite!Source&lt;/code&gt; 와 &lt;code&gt;source.walkLength&lt;/code&gt; 가 고르게 아닙니다 의해 나눌 &lt;code&gt;chunkSize&lt;/code&gt; 이 범위의 뒷면 요소는보다 적은 포함 &lt;code&gt;chunkSize&lt;/code&gt; 요소.</target>
        </trans-unit>
        <trans-unit id="da45e2d8d90136b7f84f13e1858fb6ece371b4b0" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;!value&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt;, &lt;code&gt;value&lt;/code&gt; is returned. Otherwise, &lt;code&gt;new E(msg, file, line)&lt;/code&gt; is thrown. Or if &lt;code&gt;E&lt;/code&gt; doesn't take a message and can be constructed with &lt;code&gt;new E(file, line)&lt;/code&gt;, then &lt;code&gt;new E(file, line)&lt;/code&gt; will be thrown.</source>
          <target state="translated">경우 &lt;code&gt;!value&lt;/code&gt; 입니다 &lt;code&gt;false&lt;/code&gt; , &lt;code&gt;value&lt;/code&gt; 반환됩니다. 그렇지 않으면 &lt;code&gt;new E(msg, file, line)&lt;/code&gt; 가 발생합니다. 경우 또는 &lt;code&gt;E&lt;/code&gt; 는 메시지를하지 않고로 구성 할 수 있습니다 &lt;code&gt;new E(file, line)&lt;/code&gt; , 다음 &lt;code&gt;new E(file, line)&lt;/code&gt; 슬로우됩니다.</target>
        </trans-unit>
        <trans-unit id="e70bac81fdcc8ee63f8a6ffecb44cdbcf2f794c7" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;A&lt;/code&gt; has no state, the resulting object is allocated in static shared storage.</source>
          <target state="translated">경우 &lt;code&gt;A&lt;/code&gt; 는 상태가 없으나, 생성 된 객체는 정적 공유 저장 영역에 할당된다.</target>
        </trans-unit>
        <trans-unit id="7b2c6010fe0ff7fc814ba13aa84690947c8cb83d" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;A&lt;/code&gt; has state and is copyable, the result will &lt;a href=&quot;std_algorithm_mutation#move&quot;&gt;&lt;code&gt;std.algorithm.mutation.move&lt;/code&gt;&lt;/a&gt; the supplied allocator &lt;code&gt;A a&lt;/code&gt; within. The result itself is allocated in its own statically-typed allocator.</source>
          <target state="translated">경우 &lt;code&gt;A&lt;/code&gt; 는 상태를 갖고있다 복사 가능한 결과는 것이다 &lt;a href=&quot;std_algorithm_mutation#move&quot;&gt; &lt;code&gt;std.algorithm.mutation.move&lt;/code&gt; &lt;/a&gt; 제공된 할당 자 &lt;code&gt;A a&lt;/code&gt; 내의한다. 결과 자체는 정적으로 유형이 지정된 할당 자에 할당됩니다.</target>
        </trans-unit>
        <trans-unit id="e90491f805af73197e670ba7dcdbdea4f3f9187b" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;A&lt;/code&gt; has state and is not copyable, the result will move the passed-in argument into the result. The result itself is allocated in its own statically-typed allocator.</source>
          <target state="translated">경우 &lt;code&gt;A&lt;/code&gt; 가 상태를 가지고 있으며, 복사 가능한 아니라, 결과는 결과에 전달 된 인수를 이동합니다. 결과 자체는 정적으로 유형이 지정된 할당 자에 할당됩니다.</target>
        </trans-unit>
        <trans-unit id="8e3921430ef3c9cb639e4397d8b838ecfe391c50" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;A&lt;/code&gt; has state, the result will &lt;a href=&quot;std_algorithm_mutation#move&quot;&gt;&lt;code&gt;std.algorithm.mutation.move&lt;/code&gt;&lt;/a&gt; the supplied allocator &lt;code&gt;A a&lt;/code&gt; within. The result itself is allocated in its own statically-typed allocator.</source>
          <target state="translated">경우 &lt;code&gt;A&lt;/code&gt; 는 상태를 가지며, 그 결과는 것이다 &lt;a href=&quot;std_algorithm_mutation#move&quot;&gt; &lt;code&gt;std.algorithm.mutation.move&lt;/code&gt; &lt;/a&gt; 제공된 할당 자 &lt;code&gt;A a&lt;/code&gt; 내의한다. 결과 자체는 정적으로 유형이 지정된 할당 자에 할당됩니다.</target>
        </trans-unit>
        <trans-unit id="85c9db39cbb0a223dde8b65577a816ac4ae74ca1" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Allocator&lt;/code&gt; implements &lt;code&gt;owns&lt;/code&gt;, forwards to it. Otherwise, returns &lt;code&gt;Ternary.unknown&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;code&gt;Allocator&lt;/code&gt; 구현이 &lt;code&gt;owns&lt;/code&gt; 그것에, 앞으로. 그렇지 않으면 &lt;code&gt;Ternary.unknown&lt;/code&gt; 을 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="602c75c69645dadebf41e326ef28dced33652078" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;BookkeepingAllocator&lt;/code&gt; is not &lt;code&gt;NullAllocator&lt;/code&gt;, &lt;code&gt;bkalloc&lt;/code&gt; is defined and accessible.</source>
          <target state="translated">경우 &lt;code&gt;BookkeepingAllocator&lt;/code&gt; 가 아닌 &lt;code&gt;NullAllocator&lt;/code&gt; , &lt;code&gt;bkalloc&lt;/code&gt; 는 정의에 액세스 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e61003ea748193c575ad061853d1dd56eb5e4c1d" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;ElementType!R&lt;/code&gt; is a floating-point type and &lt;code&gt;R&lt;/code&gt; is a finite input range (but not a random-access range with slicing), then &lt;code&gt;sum&lt;/code&gt; uses the &lt;a href=&quot;http://en.wikipedia.org/wiki/Kahan_summation&quot;&gt;Kahan summation&lt;/a&gt; algorithm.</source>
          <target state="translated">경우 &lt;code&gt;ElementType!R&lt;/code&gt; 부동 소수점 타입이고, &lt;code&gt;R&lt;/code&gt; 은 한정된 입력 범위 (그러나 슬라이싱과 랜덤 액세스 범위)이며, 다음 &lt;code&gt;sum&lt;/code&gt; 용도 &lt;a href=&quot;http://en.wikipedia.org/wiki/Kahan_summation&quot;&gt;Kahan 합계&lt;/a&gt; 알고리즘.</target>
        </trans-unit>
        <trans-unit id="e00af2edb93d47ac443e7418f444a801ea32bd2d" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;FreeList&lt;/code&gt; has been instantiated with &lt;code&gt;maxSize == chooseAtRuntime&lt;/code&gt;, then the &lt;code&gt;max&lt;/code&gt; property is writable. Setting it must precede any allocation.</source>
          <target state="translated">경우 &lt;code&gt;FreeList&lt;/code&gt; 인스턴스화 된 &lt;code&gt;maxSize == chooseAtRuntime&lt;/code&gt; 후 &lt;code&gt;max&lt;/code&gt; 속성은 쓰기 가능합니다. 할당하기 전에 설정해야합니다.</target>
        </trans-unit>
        <trans-unit id="619bff2f62db09894cc368f16063c71698b3e91a" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;FreeList&lt;/code&gt; has been instantiated with &lt;code&gt;minSize == chooseAtRuntime&lt;/code&gt;, then the &lt;code&gt;min&lt;/code&gt; property is writable. Setting it must precede any allocation.</source>
          <target state="translated">경우 &lt;code&gt;FreeList&lt;/code&gt; 인스턴스화 된 &lt;code&gt;minSize == chooseAtRuntime&lt;/code&gt; 후 &lt;code&gt;min&lt;/code&gt; 속성 쓸 것이다. 할당하기 전에 설정해야합니다.</target>
        </trans-unit>
        <trans-unit id="614802dd9535195f4c34d795221ff4407109b94d" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Hook&lt;/code&gt; defines &lt;code&gt;hookOpOpAssign&lt;/code&gt;, &lt;code&gt;opOpAssign&lt;/code&gt; forwards to &lt;code&gt;hook.hookOpOpAssign!op(payload, rhs)&lt;/code&gt;, where &lt;code&gt;payload&lt;/code&gt; is a reference to the internally held data so the hook can change it.</source>
          <target state="translated">경우 &lt;code&gt;Hook&lt;/code&gt; 정의 &lt;code&gt;hookOpOpAssign&lt;/code&gt; , &lt;code&gt;opOpAssign&lt;/code&gt; 을 에게 전달 &lt;code&gt;hook.hookOpOpAssign!op(payload, rhs)&lt;/code&gt; , &lt;code&gt;payload&lt;/code&gt; 후크를 변경할 수 있도록 내부에 유지 된 데이터에 대한 참조이다.</target>
        </trans-unit>
        <trans-unit id="6213f7b3e2cf0b3c2b2e856da1c03c2c3603a41e" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Hook&lt;/code&gt; does not define &lt;code&gt;hookOpBinary&lt;/code&gt; but defines &lt;code&gt;onOverflow&lt;/code&gt;, &lt;code&gt;opBinary&lt;/code&gt; forwards to &lt;code&gt;hook.onOverflow!op(get, rhs)&lt;/code&gt; in case an overflow occurs.</source>
          <target state="translated">경우 &lt;code&gt;Hook&lt;/code&gt; 정의하지 않는 &lt;code&gt;hookOpBinary&lt;/code&gt; 하지만 정의를 &lt;code&gt;onOverflow&lt;/code&gt; , &lt;code&gt;opBinary&lt;/code&gt; 에 전달 &lt;code&gt;hook.onOverflow!op(get, rhs)&lt;/code&gt; 경우는 오버 플로우가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="48a7fb4afe12c2822acfff866c271812d59b89d4" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Hook&lt;/code&gt; does not define &lt;code&gt;hookOpUnary&lt;/code&gt; but defines &lt;code&gt;onOverflow&lt;/code&gt;, &lt;code&gt;opUnary&lt;/code&gt; forwards to &lt;code&gt;hook.onOverflow!op(get)&lt;/code&gt; in case an overflow occurs. For &lt;code&gt;++&lt;/code&gt; and &lt;code&gt;--&lt;/code&gt;, the payload is assigned from the result of the call to &lt;code&gt;onOverflow&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;code&gt;Hook&lt;/code&gt; 정의하지 않는 &lt;code&gt;hookOpUnary&lt;/code&gt; 하지만 정의를 &lt;code&gt;onOverflow&lt;/code&gt; , &lt;code&gt;opUnary&lt;/code&gt; 에 전달 &lt;code&gt;hook.onOverflow!op(get)&lt;/code&gt; 경우는 오버 플로우가 발생합니다. 들어 &lt;code&gt;++&lt;/code&gt; 와 &lt;code&gt;--&lt;/code&gt; , 페이로드에 대한 호출의 결과로부터 할당 &lt;code&gt;onOverflow&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="10cd8aa857d486ec2d02cef4465f8ceb45e4e90d" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;ParentAllocator&lt;/code&gt; holds state, &lt;code&gt;parent&lt;/code&gt; is a public member of type &lt;code&gt;KRRegion&lt;/code&gt;. Otherwise, &lt;code&gt;parent&lt;/code&gt; is an &lt;code&gt;alias&lt;/code&gt; for &lt;code&gt;ParentAllocator.instance&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;code&gt;ParentAllocator&lt;/code&gt; 가 상태를 보유하고, &lt;code&gt;parent&lt;/code&gt; 형의 공개 구성원 &lt;code&gt;KRRegion&lt;/code&gt; . 그렇지 않으면 &lt;code&gt;parent&lt;/code&gt; 는 &lt;code&gt;ParentAllocator.instance&lt;/code&gt; 의 &lt;code&gt;alias&lt;/code&gt; 입니다 .</target>
        </trans-unit>
        <trans-unit id="3bbccd514894e82c4ce13569d09888036cf3359f" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;ParentAllocator&lt;/code&gt; is &lt;a href=&quot;std_experimental_allocator_building_blocks_null_allocator#NullAllocator&quot;&gt;&lt;code&gt;NullAllocator&lt;/code&gt;&lt;/a&gt;, only the constructor taking &lt;code&gt;data&lt;/code&gt; is defined and the user is responsible for freeing &lt;code&gt;data&lt;/code&gt; if desired.</source>
          <target state="translated">경우 &lt;code&gt;ParentAllocator&lt;/code&gt; 가 있다 &lt;a href=&quot;std_experimental_allocator_building_blocks_null_allocator#NullAllocator&quot;&gt; &lt;code&gt;NullAllocator&lt;/code&gt; &lt;/a&gt; 복용에만 생성자 &lt;code&gt;data&lt;/code&gt; 정의하고 사용자가 자유롭게에 대한 책임이다 &lt;code&gt;data&lt;/code&gt; 원하는 경우.</target>
        </trans-unit>
        <trans-unit id="d42312f5e4b477adba48781c375b173d6250fd1d" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;ParentAllocator&lt;/code&gt; is different from &lt;a href=&quot;std_experimental_allocator_building_blocks_null_allocator#NullAllocator&quot;&gt;&lt;code&gt;NullAllocator&lt;/code&gt;&lt;/a&gt;, &lt;code&gt;Region&lt;/code&gt; deallocates the chunk of memory during destruction.</source>
          <target state="translated">경우 &lt;code&gt;ParentAllocator&lt;/code&gt; 이 다른 &lt;a href=&quot;std_experimental_allocator_building_blocks_null_allocator#NullAllocator&quot;&gt; &lt;code&gt;NullAllocator&lt;/code&gt; &lt;/a&gt; , &lt;code&gt;Region&lt;/code&gt; 파괴 동안 메모리 청크를 할당 해제합니다.</target>
        </trans-unit>
        <trans-unit id="9a65e34991edf1fabbde944025e9467eaa28acfa" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;ParentAllocator&lt;/code&gt; is stateful, &lt;code&gt;parent&lt;/code&gt; is a property giving access to an &lt;code&gt;AffixAllocator!ParentAllocator&lt;/code&gt;. Otherwise, &lt;code&gt;parent&lt;/code&gt; is an alias for &lt;code&gt;AffixAllocator!ParentAllocator.instance&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;code&gt;ParentAllocator&lt;/code&gt; 은 상태이며, &lt;code&gt;parent&lt;/code&gt; 에 대한 액세스 제공하는 속성입니다 &lt;code&gt;AffixAllocator!ParentAllocator&lt;/code&gt; . 그렇지 않으면 &lt;code&gt;parent&lt;/code&gt; 는 &lt;code&gt;AffixAllocator!ParentAllocator.instance&lt;/code&gt; 의 별명입니다 .</target>
        </trans-unit>
        <trans-unit id="43d333c4fd79ece4dce7180ff004a1dd304cfda4" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Prefix&lt;/code&gt; is &lt;code&gt;void&lt;/code&gt;, the alignment is that of the parent. Otherwise, the alignment is the same as the &lt;code&gt;Prefix&lt;/code&gt;'s alignment.</source>
          <target state="translated">경우 &lt;code&gt;Prefix&lt;/code&gt; 이다 &lt;code&gt;void&lt;/code&gt; , 정렬은 부모의입니다. 그렇지 않으면 정렬은 &lt;code&gt;Prefix&lt;/code&gt; 정렬과 동일 합니다.</target>
        </trans-unit>
        <trans-unit id="6ef958a14b28e8a87e35d39d726513cf1a24e3ab" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Prefix&lt;/code&gt; is not &lt;code&gt;void&lt;/code&gt;, &lt;code&gt;Allocator&lt;/code&gt; must guarantee an alignment at least as large as &lt;code&gt;Prefix.alignof&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;code&gt;Prefix&lt;/code&gt; 없는 &lt;code&gt;void&lt;/code&gt; , &lt;code&gt;Allocator&lt;/code&gt; 큰로서 적어도 정렬을 보장해야한다 &lt;code&gt;Prefix.alignof&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4bde56d414db390f6de687beeb6a7de19e32b07b" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;S&lt;/code&gt; defines a destructor, the generated code for &lt;code&gt;opAssign&lt;/code&gt; is:</source>
          <target state="translated">경우 &lt;code&gt;S&lt;/code&gt; 는 소멸자를 정의에 대해 생성 된 코드 &lt;code&gt;opAssign&lt;/code&gt; 가 있습니다 :</target>
        </trans-unit>
        <trans-unit id="8fa12abad24500172f1e1f4de478a1e097e94f32" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;S&lt;/code&gt; does not have a postblit or a destructor, but contains at least one field that defines an &lt;code&gt;opAssign&lt;/code&gt; function (which is not disabled), then the body will make member-wise assignments:</source>
          <target state="translated">경우 &lt;code&gt;S&lt;/code&gt; 가 postblit 또는 소멸자를 가지고 있지만 정의 적어도 하나 개의 필드 포함되지 않습니다 &lt;code&gt;opAssign&lt;/code&gt; 기능 (비활성화하지 않은), 그 몸은 회원이 많다는 할당을 만들 것입니다 :</target>
        </trans-unit>
        <trans-unit id="135d5e0bd9ac5cff9f359e01e49ee96d18ba1175" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;S&lt;/code&gt; has a disabled destructor or at least one field that has a disabled &lt;code&gt;opAssign&lt;/code&gt;, &lt;code&gt;S.opAssign&lt;/code&gt; is going to be generated, but marked with &lt;code&gt;@disable&lt;/code&gt;</source>
          <target state="translated">경우 &lt;code&gt;S&lt;/code&gt; 가 비활성화되어있는 장애 또는 소멸자 적어도 하나 개의 필드를 갖는다 &lt;code&gt;opAssign&lt;/code&gt; 을 , &lt;code&gt;S.opAssign&lt;/code&gt; 가 발생 될 예정이지만 표시되어 &lt;code&gt;@disable&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="e5d3671bcdce32a3ae79160f07ed6d9617aa8c77" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Source&lt;/code&gt; has structural conformance with the &lt;code&gt;interface&lt;/code&gt;&lt;code&gt;Targets&lt;/code&gt;, wrap creates an internal wrapper class which inherits &lt;code&gt;Targets&lt;/code&gt; and wraps the &lt;code&gt;src&lt;/code&gt; object, then returns it.</source>
          <target state="translated">경우 &lt;code&gt;Source&lt;/code&gt; 와 구조적 적합성을 가지고 &lt;code&gt;interface&lt;/code&gt; &lt;code&gt;Targets&lt;/code&gt; , 랩 상속 내부 래퍼 클래스 생성 &lt;code&gt;Targets&lt;/code&gt; 과 랩 &lt;code&gt;src&lt;/code&gt; 다음을 반환 개체를.</target>
        </trans-unit>
        <trans-unit id="a6a1c6b133b0871dee66034a379d92385c6acfa0" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Source&lt;/code&gt; is a forward range, the resulting range will be forward ranges as well. Otherwise, the resulting chunks will be input ranges consuming the same input: iterating over &lt;code&gt;front&lt;/code&gt; will shrink the chunk such that subsequent invocations of &lt;code&gt;front&lt;/code&gt; will no longer return the full chunk, and calling &lt;code&gt;popFront&lt;/code&gt; on the outer range will invalidate any lingering references to previous values of &lt;code&gt;front&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;code&gt;Source&lt;/code&gt; 순방향 범위는, 얻어지는 범위뿐만 아니라 앞으로의 범위 일 것이다. 그렇지 않으면 결과 청크는 동일한 입력을 소비하는 입력 범위가됩니다. &lt;code&gt;front&lt;/code&gt; 를 반복 하면 청크가 축소되어 &lt;code&gt;front&lt;/code&gt; 후속 호출 이 더 이상 전체 청크를 반환하지 않으며 외부 범위에서 &lt;code&gt;popFront&lt;/code&gt; 를 호출 하면 이전 값에 대한 모든 참조가 무효화됩니다. 의 &lt;code&gt;front&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="68e4c36f3a209b42eda6036b89cfd912aefdf8d2" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;StopWatch.init&lt;/code&gt; is used, then the constructed StopWatch isn't running (and can't be, since no constructor ran).</source>
          <target state="translated">경우 &lt;code&gt;StopWatch.init&lt;/code&gt; 가 사용되며, 다음은 스톱워치가 실행되고 있지 (없이 생성자 실행 된 이후, 수 없습니다) 건설했다.</target>
        </trans-unit>
        <trans-unit id="8fa16aaee056c365a9ba1b96bbf4c7ab3e0c7909" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Store&lt;/code&gt; is a range, the &lt;code&gt;BinaryHeap&lt;/code&gt; cannot grow beyond the size of that range. If &lt;code&gt;Store&lt;/code&gt; is a container that supports &lt;code&gt;insertBack&lt;/code&gt;, the &lt;code&gt;BinaryHeap&lt;/code&gt; may grow by adding elements to the container.</source>
          <target state="translated">경우 &lt;code&gt;Store&lt;/code&gt; 범위되면, &lt;code&gt;BinaryHeap&lt;/code&gt; 그 범위의 크기를 초과 할 수 없습니다. &lt;code&gt;Store&lt;/code&gt; 가 &lt;code&gt;insertBack&lt;/code&gt; 을 지원하는 컨테이너 인 경우 컨테이너 에 요소를 추가 하여 &lt;code&gt;BinaryHeap&lt;/code&gt; 이 커질 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="dbe0360bc543f33ed0b90fcff8d9687e9b9ea633" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;T&lt;/code&gt; is a class type, returns a reference to the created &lt;code&gt;T&lt;/code&gt; object. Otherwise, returns a &lt;code&gt;T*&lt;/code&gt; pointing to the created object. In all cases, returns &lt;code&gt;null&lt;/code&gt; if allocation failed.</source>
          <target state="translated">경우 &lt;code&gt;T&lt;/code&gt; 가 클래스 타입이며, 생성에 대한 참조를 반환 &lt;code&gt;T&lt;/code&gt; 의 객체를. 그렇지 않으면 생성 된 객체를 가리키는 &lt;code&gt;T*&lt;/code&gt; 반환 합니다. 모든 경우에 할당에 실패하면 &lt;code&gt;null&lt;/code&gt; 을 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="85b009305a8588231d9cf9c49742c5425d7c6707" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;T&lt;/code&gt; is a nested struct, the context pointer in &lt;code&gt;T.init&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;code&gt;T&lt;/code&gt; 가 중첩 된 구조체이며, 상황에 맞는 포인터 &lt;code&gt;T.init&lt;/code&gt; 는 이다 &lt;code&gt;null&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="86a83fbe1dd6e8e6329df1be326be31fbac7542c" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;T&lt;/code&gt; is a struct which has &lt;code&gt;@disable this();&lt;/code&gt;, &lt;code&gt;T.init&lt;/code&gt; might return a logically incorrect object.</source>
          <target state="translated">경우 &lt;code&gt;T&lt;/code&gt; 가 갖는 구조체이다 &lt;code&gt;@disable this();&lt;/code&gt; , &lt;code&gt;T.init&lt;/code&gt; 은 논리적으로 잘못된 개체를 반환 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="28ecbbbd57ec70df9468c10b69230725191bde07" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;T&lt;/code&gt; is a struct with a destructor or postblit defined, source is reset to its &lt;code&gt;.init&lt;/code&gt; value after it is moved into target, otherwise it is left unchanged.</source>
          <target state="translated">&lt;code&gt;T&lt;/code&gt; 가 소멸자 또는 포스트 블릿이 정의 된 구조체 인 경우 소스는 대상으로 이동 한 후 &lt;code&gt;.init&lt;/code&gt; 값으로 재설정되고 , 그렇지 않으면 변경되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="be0ddbf38059d4859dc637f9816765cfecd51bd9" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;T&lt;/code&gt; is a value type, then &lt;code&gt;Unique!T&lt;/code&gt; will be implemented as a reference to a &lt;code&gt;T&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;code&gt;T&lt;/code&gt; 가 값 형식이고, 다음 &lt;code&gt;Unique!T&lt;/code&gt; A와 참조로 구현 될 것입니다 &lt;code&gt;T&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3ad884b639da3b067a89fc2f9254b6e884145e3b" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;T&lt;/code&gt; is an inner class whose &lt;code&gt;outer&lt;/code&gt; field can be used to access an instance of the enclosing class, then &lt;code&gt;Args&lt;/code&gt; must not be empty, and the first member of it must be a valid initializer for that &lt;code&gt;outer&lt;/code&gt; field. Correct initialization of this field is essential to access members of the outer class inside &lt;code&gt;T&lt;/code&gt; methods.</source>
          <target state="translated">경우 &lt;code&gt;T&lt;/code&gt; 는 그 내부 클래스 &lt;code&gt;outer&lt;/code&gt; 필드를 둘러싸는 클래스의 인스턴스에 액세스하는 데 사용될 수는 다음 &lt;code&gt;Args&lt;/code&gt; 비어 있지 않아야하고 그것의 제 1 부재에는 해당하는 유효 초기화 있어야 &lt;code&gt;outer&lt;/code&gt; 필드. 이 필드의 올바른 초기화는 &lt;code&gt;T&lt;/code&gt; 메소드 내부의 외부 클래스 멤버에 액세스하는 데 필수적 입니다.</target>
        </trans-unit>
        <trans-unit id="5e5dca16a0b08e551a0873d6f42ddf6d816c0620" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;T&lt;/code&gt;'s constructor throws, deallocates the allocated memory and propagates the exception.</source>
          <target state="translated">경우 &lt;code&gt;T&lt;/code&gt; 의 생성자가 발생, 할당 된 메모리 할당을 취소하고 예외를 전파합니다.</target>
        </trans-unit>
        <trans-unit id="f9ccf6d42185874390122acb61e0fffade4a1d7e" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;U&lt;/code&gt; is also an instance of &lt;code&gt;Checked&lt;/code&gt;, both hooks (left- and right-hand side) are introspected for the method &lt;code&gt;hookOpCmp&lt;/code&gt;. If both define it, priority is given to the left-hand side.</source>
          <target state="translated">경우 &lt;code&gt;U&lt;/code&gt; 가 도의 인스턴스 &lt;code&gt;Checked&lt;/code&gt; 양쪽 후크 (왼쪽 및 오른쪽)을위한 방법 크션된다 &lt;code&gt;hookOpCmp&lt;/code&gt; . 둘 다 정의하면 왼쪽에 우선 순위가 부여됩니다.</target>
        </trans-unit>
        <trans-unit id="f714d4a1a2b46c6585bd14b3632f61dc774fe527" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;U&lt;/code&gt; is also an instance of &lt;code&gt;Checked&lt;/code&gt;, both hooks (left- and right-hand side) are introspected for the method &lt;code&gt;hookOpEquals&lt;/code&gt;. If both define it, priority is given to the left-hand side.</source>
          <target state="translated">경우 &lt;code&gt;U&lt;/code&gt; 가 도의 인스턴스 &lt;code&gt;Checked&lt;/code&gt; 양쪽 후크 (왼쪽 및 오른쪽)을위한 방법 크션된다 &lt;code&gt;hookOpEquals&lt;/code&gt; . 둘 다 정의하면 왼쪽에 우선 순위가 부여됩니다.</target>
        </trans-unit>
        <trans-unit id="6530603e838c2a2e64b1bcfb9217be83aec2dafc" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Yes.checkDns&lt;/code&gt; then a DNS check for MX records will be made</source>
          <target state="translated">예 &lt;code&gt;Yes.checkDns&lt;/code&gt; 이면 MX 레코드에 대한 DNS 확인이 수행됩니다.</target>
        </trans-unit>
        <trans-unit id="a1992ec3ad4038c0370a2f08b90896545a010903" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Yes.pipeOnPop&lt;/code&gt;, simply iterating the range without ever calling &lt;code&gt;front&lt;/code&gt; is enough to have &lt;code&gt;tee&lt;/code&gt; mirror elements to &lt;code&gt;outputRange&lt;/code&gt; (or, respectively, &lt;code&gt;fun&lt;/code&gt;). If &lt;code&gt;No.pipeOnPop&lt;/code&gt;, only elements for which &lt;code&gt;front&lt;/code&gt; does get called will be also sent to &lt;code&gt;outputRange&lt;/code&gt;/&lt;code&gt;fun&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;code&gt;Yes.pipeOnPop&lt;/code&gt; , 단순히 적 호출하지 않고 범위를 반복 &lt;code&gt;front&lt;/code&gt; 이 충분하다 &lt;code&gt;tee&lt;/code&gt; 로 미러 요소 &lt;code&gt;outputRange&lt;/code&gt; (각각 또는, &lt;code&gt;fun&lt;/code&gt; ). &lt;code&gt;No.pipeOnPop&lt;/code&gt; 인 경우 &lt;code&gt;front&lt;/code&gt; 가 호출 되는 요소 만 &lt;code&gt;outputRange&lt;/code&gt; / &lt;code&gt;fun&lt;/code&gt; 으로 전송됩니다 .</target>
        </trans-unit>
        <trans-unit id="6b44ae6759ea792f0bca17c48004575c328a9fdc" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;a = &quot;abcde&quot;&lt;/code&gt;, then &lt;code&gt;findSkip(a, &quot;x&quot;)&lt;/code&gt; returns &lt;code&gt;false&lt;/code&gt; and leaves &lt;code&gt;a&lt;/code&gt; unchanged, whereas &lt;code&gt;findSkip(a, &quot;c&quot;)&lt;/code&gt; advances &lt;code&gt;a&lt;/code&gt; to &lt;code&gt;&quot;de&quot;&lt;/code&gt; and returns &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;code&gt;a = &quot;abcde&quot;&lt;/code&gt; 다음 &lt;code&gt;findSkip(a, &quot;x&quot;)&lt;/code&gt; 반환 &lt;code&gt;false&lt;/code&gt; 과 잎 , 변경을하는 반면 &lt;code&gt;findSkip(a, &quot;c&quot;)&lt;/code&gt; 진보 &lt;code&gt;a&lt;/code&gt; 에 &lt;code&gt;&quot;de&quot;&lt;/code&gt; 반환 &lt;code&gt;true&lt;/code&gt; . &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="22d1d40c86b33d24346ec7f18b6caa5014b1c725" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;a = [1, 2, 3]&lt;/code&gt; and &lt;code&gt;b = [4, 5, 6, 7]&lt;/code&gt;, &lt;code&gt;bringToFront(a, b)&lt;/code&gt; leaves &lt;code&gt;a = [4, 5, 6]&lt;/code&gt; and &lt;code&gt;b = [7, 1, 2, 3]&lt;/code&gt;.</source>
          <target state="translated">하면 &lt;code&gt;a = [1, 2, 3]&lt;/code&gt; 및 &lt;code&gt;b = [4, 5, 6, 7]&lt;/code&gt; , &lt;code&gt;bringToFront(a, b)&lt;/code&gt; 나뭇잎 &lt;code&gt;a = [4, 5, 6]&lt;/code&gt; 및 &lt;code&gt;b = [7, 1, 2, 3]&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="161672661d076244bfa4e1cb23db5cb7cee3f0b9" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;a = [1, 2, 3]&lt;/code&gt;, &lt;code&gt;reverse(a)&lt;/code&gt; changes it to &lt;code&gt;[3, 2, 1]&lt;/code&gt;.</source>
          <target state="translated">하면 &lt;code&gt;a = [1, 2, 3]&lt;/code&gt; , &lt;code&gt;reverse(a)&lt;/code&gt; 로 변경 &lt;code&gt;[3, 2, 1]&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6c20592a36a578c54537352b677f5ac5e2a4bd22" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;a = [1.2, 3.4]&lt;/code&gt;, then &lt;code&gt;initializeAll(a)&lt;/code&gt; leaves &lt;code&gt;a = [double.init, double.init]&lt;/code&gt;.</source>
          <target state="translated">하면 &lt;code&gt;a = [1.2, 3.4]&lt;/code&gt; , 다음 &lt;code&gt;initializeAll(a)&lt;/code&gt; 나뭇잎 &lt;code&gt;a = [double.init, double.init]&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3f19fe74876068eb9761e0ed018d3efe050a2dc6" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;a = [10, 20, 30]&lt;/code&gt; and &lt;code&gt;b = [40, 6, 15]&lt;/code&gt;, then &lt;code&gt;completeSort(a, b)&lt;/code&gt; leaves &lt;code&gt;a = [6, 10, 15]&lt;/code&gt; and &lt;code&gt;b = [20, 30, 40]&lt;/code&gt;. The range &lt;code&gt;a&lt;/code&gt; must be sorted prior to the call, and as a result the combination &lt;code&gt;&lt;a href=&quot;std_range#chain&quot;&gt;std.range.chain&lt;/a&gt;(a, b)&lt;/code&gt; is sorted.</source>
          <target state="translated">하면 &lt;code&gt;a = [10, 20, 30]&lt;/code&gt; 및 &lt;code&gt;b = [40, 6, 15]&lt;/code&gt; 다음 &lt;code&gt;completeSort(a, b)&lt;/code&gt; 나뭇잎 &lt;code&gt;a = [6, 10, 15]&lt;/code&gt; 및 &lt;code&gt;b = [20, 30, 40]&lt;/code&gt; . 범위 &lt;code&gt;a&lt;/code&gt; 는 통화 전에 정렬되어야하며 그 결과 &lt;code&gt;&lt;a href=&quot;std_range#chain&quot;&gt;std.range.chain&lt;/a&gt;(a, b)&lt;/code&gt; 조합 이 정렬됩니다.</target>
        </trans-unit>
        <trans-unit id="8653b5c90f101e5bb8cf18c8696bdaa4b97980b3" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;a = [5, 4, 3, 2, 1]&lt;/code&gt;, then &lt;code&gt;partialSort(a, 3)&lt;/code&gt; leaves &lt;code&gt;a[0 .. 3] = [1, 2, 3]&lt;/code&gt;. The other elements of &lt;code&gt;a&lt;/code&gt; are left in an unspecified order.</source>
          <target state="translated">하면 &lt;code&gt;a = [5, 4, 3, 2, 1]&lt;/code&gt; 다음, &lt;code&gt;partialSort(a, 3)&lt;/code&gt; 잎 &lt;code&gt;a[0 .. 3] = [1, 2, 3]&lt;/code&gt; . 의 다른 원소 &lt;code&gt;a&lt;/code&gt; 불특정 위해 남겨진다.</target>
        </trans-unit>
        <trans-unit id="761844ca385c58407529b15b7f0264a9fdc0b35e" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;allowDuplicates&lt;/code&gt; is set to &lt;code&gt;true&lt;/code&gt;, then inserting the same element more than once continues to add more elements. If it is &lt;code&gt;false&lt;/code&gt;, duplicate elements are ignored on insertion. If duplicates are allowed, then new elements are inserted after all existing duplicate elements.</source>
          <target state="translated">&lt;code&gt;allowDuplicates&lt;/code&gt; 가 &lt;code&gt;true&lt;/code&gt; 로 설정된 경우 동일한 요소를 두 번 이상 삽입하면 요소가 계속 추가됩니다. &lt;code&gt;false&lt;/code&gt; 인 경우 삽입시 중복 요소가 무시됩니다. 중복이 허용되면 기존의 모든 중복 요소 뒤에 새 요소가 삽입됩니다.</target>
        </trans-unit>
        <trans-unit id="42df331db67fcac4570e8d97255c06bf51fcef31" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;arr.length &amp;lt; delta&lt;/code&gt;, does nothing and returns &lt;code&gt;false&lt;/code&gt;. Otherwise, destroys the last &lt;code&gt;arr.length - delta&lt;/code&gt; elements in the array and then reallocates the array's buffer. If reallocation fails, fills the array with default-initialized data.</source>
          <target state="translated">&lt;code&gt;arr.length &amp;lt; delta&lt;/code&gt; 인 경우 아무 작업도 수행하지 않고 &lt;code&gt;false&lt;/code&gt; 를 반환합니다 . 그렇지 않으면 배열 의 마지막 &lt;code&gt;arr.length - delta&lt;/code&gt; 요소를 삭제 한 다음 배열의 버퍼를 재 할당합니다. 재 할당이 실패하면 기본 초기화 데이터로 배열을 채 웁니다.</target>
        </trans-unit>
        <trans-unit id="73774d72a77acb4ae5cc4817197c7e3cc39e3e8b" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;array.length &amp;lt; delta&lt;/code&gt;, does nothing and returns &lt;code&gt;false&lt;/code&gt;. Otherwise, destroys the last &lt;code&gt;array.length - delta&lt;/code&gt; elements in the array and then reallocates the array's buffer. If reallocation fails, fills the array with default-initialized data.</source>
          <target state="translated">&lt;code&gt;array.length &amp;lt; delta&lt;/code&gt; 인 경우 아무 작업도 수행하지 않고 &lt;code&gt;false&lt;/code&gt; 를 반환합니다 . 그렇지 않으면 배열 의 마지막 &lt;code&gt;array.length - delta&lt;/code&gt; 요소를 삭제 한 다음 배열의 버퍼를 재 할당합니다. 재 할당이 실패하면 기본 초기화 데이터로 배열을 채 웁니다.</target>
        </trans-unit>
        <trans-unit id="7b4fa4088c1f332dc1cc2c07bd6dcf7ba46787dc" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;b is null&lt;/code&gt;, does nothing and returns &lt;code&gt;true&lt;/code&gt;. Otherwise, deallocates memory previously allocated with this allocator and returns &lt;code&gt;true&lt;/code&gt; if successful, &lt;code&gt;false&lt;/code&gt; otherwise. An implementation that would not support deallocation (i.e. would always return &lt;code&gt;false&lt;/code&gt; should not define this primitive at all.)</source>
          <target state="translated">경우 &lt;code&gt;b is null&lt;/code&gt; , 아무것도 반환하지 않습니다 &lt;code&gt;true&lt;/code&gt; . 그렇지 않으면, 할당 해제 메모리는 이전에이 할당 반환 할당 &lt;code&gt;true&lt;/code&gt; 성공하는 경우, &lt;code&gt;false&lt;/code&gt; 그렇지. 할당 해제를 지원하지 않는 구현 (즉, 항상 &lt;code&gt;false&lt;/code&gt; 를 리턴 하는 경우이 기본 요소를 전혀 정의하지 않아야 함)</target>
        </trans-unit>
        <trans-unit id="8bae244a830c8d1176da79e2579d3599e88c12f8" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;ba&lt;/code&gt; is zero (the default) the attributes of the existing memory will be used for an allocation. If &lt;code&gt;ba&lt;/code&gt; is not zero and no new memory is allocated, the bits in ba will replace those of the current memory block.</source>
          <target state="translated">경우 &lt;code&gt;ba&lt;/code&gt; 제로 (기본값)는 기존 메모리의 속성은 할당에 사용됩니다. &lt;code&gt;ba&lt;/code&gt; 가 0이 아니고 새로운 메모리가 할당되지 않으면 ba 의 비트는 현재 메모리 블록의 비트를 대체합니다.</target>
        </trans-unit>
        <trans-unit id="221a7c0321e1759235e9e5a40274abe6cabee406" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;block.length&lt;/code&gt; is within &lt;code&gt;[min, max]&lt;/code&gt; or if the free list is unchecked (&lt;code&gt;minSize == 0 &amp;amp;&amp;amp; maxSize == size_t.max&lt;/code&gt;), then inserts the block at the front of the free list. For all others, forwards to &lt;code&gt; parent.deallocate&lt;/code&gt; if &lt;code&gt;Parent.deallocate&lt;/code&gt; is defined.</source>
          <target state="translated">경우 &lt;code&gt;block.length&lt;/code&gt; 가 내 &lt;code&gt;[min, max]&lt;/code&gt; 또는 프리리스트가 선택하지 않은 경우 ( &lt;code&gt;minSize == 0 &amp;amp;&amp;amp; maxSize == size_t.max&lt;/code&gt; ) 다음 프리리스트의 선두 블록을 삽입한다. 모든 다른 사람들을 위해, 전달하는 &lt;code&gt; parent.deallocate&lt;/code&gt; 경우 &lt;code&gt;Parent.deallocate&lt;/code&gt; 가 정의된다.</target>
        </trans-unit>
        <trans-unit id="5e4b98282d9ecdaaa0277f0ab4f62ad8d1b53af5" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;blockSize == chooseAtRuntime&lt;/code&gt;, &lt;code&gt;BitmappedBlock&lt;/code&gt; offers a read/write property &lt;code&gt;blockSize&lt;/code&gt;. It must be set before any use of the allocator. Otherwise (i.e. &lt;code&gt;theBlockSize&lt;/code&gt; is a legit constant), &lt;code&gt;blockSize&lt;/code&gt; is an alias for &lt;code&gt;theBlockSize&lt;/code&gt;. Whether constant or variable, must also be a multiple of &lt;code&gt;alignment&lt;/code&gt;. This constraint is &lt;code&gt;assert&lt;/code&gt;ed statically and dynamically.</source>
          <target state="translated">경우 &lt;code&gt;blockSize == chooseAtRuntime&lt;/code&gt; , &lt;code&gt;BitmappedBlock&lt;/code&gt; 은 읽기 / 쓰기 속성 제공 &lt;code&gt;blockSize&lt;/code&gt; . 할당자를 사용하기 전에 설정해야합니다. 그렇지 않으면 (즉, &lt;code&gt;theBlockSize&lt;/code&gt; 는 합법적 인 상수), &lt;code&gt;blockSize&lt;/code&gt; 별칭입니다 &lt;code&gt;theBlockSize&lt;/code&gt; 은 . 상수이든 변수이든 &lt;code&gt;alignment&lt;/code&gt; 의 배수 여야합니다 . 이 제약 조건은 정적으로 동적으로 &lt;code&gt;assert&lt;/code&gt; 됩니다.</target>
        </trans-unit>
        <trans-unit id="f93a5a60f8514085265f3aa9ca6972ee5e3faff9" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;blockSize == chooseAtRuntime&lt;/code&gt;, &lt;code&gt;SharedBitmappedBlock&lt;/code&gt; offers a read/write property &lt;code&gt;blockSize&lt;/code&gt;. It must be set before any use of the allocator. Otherwise (i.e. &lt;code&gt;theBlockSize&lt;/code&gt; is a legit constant), &lt;code&gt;blockSize&lt;/code&gt; is an alias for &lt;code&gt;theBlockSize&lt;/code&gt;. Whether constant or variable, must also be a multiple of &lt;code&gt;alignment&lt;/code&gt;. This constraint is &lt;code&gt;assert&lt;/code&gt;ed statically and dynamically.</source>
          <target state="translated">경우 &lt;code&gt;blockSize == chooseAtRuntime&lt;/code&gt; , &lt;code&gt;SharedBitmappedBlock&lt;/code&gt; 은 읽기 / 쓰기 속성 제공 &lt;code&gt;blockSize&lt;/code&gt; . 할당자를 사용하기 전에 설정해야합니다. 그렇지 않으면 (즉, &lt;code&gt;theBlockSize&lt;/code&gt; 는 합법적 인 상수), &lt;code&gt;blockSize&lt;/code&gt; 별칭입니다 &lt;code&gt;theBlockSize&lt;/code&gt; 은 . 상수이든 변수이든 &lt;code&gt;alignment&lt;/code&gt; 의 배수 여야합니다 . 이 제약 조건은 정적으로 동적으로 &lt;code&gt;assert&lt;/code&gt; 됩니다.</target>
        </trans-unit>
        <trans-unit id="8e23237ade60446568cde90bc631b8dba6e68c5d" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;c&lt;/code&gt; is a Unicode lowercase &lt;a href=&quot;#Character&quot;&gt;character&lt;/a&gt;, then its uppercase equivalent is returned. Otherwise &lt;code&gt;c&lt;/code&gt; is returned.</source>
          <target state="translated">경우 &lt;code&gt;c&lt;/code&gt; 유니 코드 소문자입니다 &lt;a href=&quot;#Character&quot;&gt;문자&lt;/a&gt; , 다음의 대문자가 반환됩니다. 그렇지 않으면 &lt;code&gt;c&lt;/code&gt; 가 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="b4c4b1af0ac218e5d7d40db7db18515091e62fd4" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;c&lt;/code&gt; is a Unicode uppercase &lt;a href=&quot;#Character&quot;&gt;character&lt;/a&gt;, then its lowercase equivalent is returned. Otherwise &lt;code&gt;c&lt;/code&gt; is returned.</source>
          <target state="translated">경우 &lt;code&gt;c&lt;/code&gt; 유니 코드 대문자 &lt;a href=&quot;#Character&quot;&gt;문자&lt;/a&gt; , 다음의 소문자 상당 반환됩니다. 그렇지 않으면 &lt;code&gt;c&lt;/code&gt; 가 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="9744833e493e9a4deaf2d113274c40f2b544663e" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;dir == Direction.fwd&lt;/code&gt;, then a range iterates forward in time, whereas if &lt;code&gt;dir == Direction.bwd&lt;/code&gt;, then it iterates backwards in time. So, if &lt;code&gt;dir == Direction.fwd&lt;/code&gt; then &lt;code&gt;front == interval.begin&lt;/code&gt;, whereas if &lt;code&gt;dir == Direction.bwd&lt;/code&gt; then &lt;code&gt;front == interval.end&lt;/code&gt;. &lt;code&gt;func&lt;/code&gt; must generate a time point going in the proper direction of iteration, or a &lt;a href=&quot;std_datetime_date#DateTimeException&quot;&gt;&lt;code&gt;std.datetime.date.DateTimeException&lt;/code&gt;&lt;/a&gt; will be thrown. So, to iterate forward in time, the time point that &lt;code&gt;func&lt;/code&gt; generates must be later in time than the one passed to it. If it's either identical or earlier in time, then a &lt;a href=&quot;std_datetime_date#DateTimeException&quot;&gt;&lt;code&gt;std.datetime.date.DateTimeException&lt;/code&gt;&lt;/a&gt; will be thrown. To iterate backwards, then the generated time point must be before the time point which was passed in.</source>
          <target state="translated">&lt;code&gt;dir == Direction.fwd&lt;/code&gt; 인 경우 범위는 시간이 지나면 반복되는 반면 &lt;code&gt;dir == Direction.bwd&lt;/code&gt; 인 경우 시간이 지나면 반복됩니다. 따라서 &lt;code&gt;dir == Direction.fwd&lt;/code&gt; 이면 &lt;code&gt;front == interval.begin&lt;/code&gt; 이고 &lt;code&gt;dir == Direction.bwd&lt;/code&gt; 이면 &lt;code&gt;front == interval.end&lt;/code&gt; 입니다. &lt;code&gt;func&lt;/code&gt; 은 올바른 반복 방향으로 진행하는 시점을 생성해야합니다 . &lt;a href=&quot;std_datetime_date#DateTimeException&quot;&gt; &lt;code&gt;std.datetime.date.DateTimeException&lt;/code&gt; &lt;/a&gt; 이 발생합니다. 따라서 시간을 앞으로 반복 하려면 &lt;code&gt;func&lt;/code&gt; 이 생성 하는 시점이 전달 된 시점보다 늦어 야합니다. 시간이 동일하거나 이전의 경우 &lt;a href=&quot;std_datetime_date#DateTimeException&quot;&gt; &lt;code&gt;std.datetime.date.DateTimeException&lt;/code&gt; &lt;/a&gt;던져 질 것이다. 거꾸로 반복하려면 생성 된 시점이 전달 된 시점 이전이어야합니다.</target>
        </trans-unit>
        <trans-unit id="a610ee5ef0581a49f22c22f37935b0d33a042c3f" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;filler&lt;/code&gt; is empty.</source>
          <target state="translated">&lt;code&gt;filler&lt;/code&gt; 가 비어있는 경우 .</target>
        </trans-unit>
        <trans-unit id="59e6f081398b1db2fd694d5b94d19e81b02d48a6" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;fun&lt;/code&gt; is a &lt;code&gt;string&lt;/code&gt;, a new single parameter function  If &lt;code&gt;fun&lt;/code&gt; is not a &lt;code&gt;string&lt;/code&gt;, an alias to &lt;code&gt;fun&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;code&gt;fun&lt;/code&gt; A는 &lt;code&gt;string&lt;/code&gt; , 경우 새로운 단일 매개 변수 기능 &lt;code&gt;fun&lt;/code&gt; 아닌 &lt;code&gt;string&lt;/code&gt; , 별칭 &lt;code&gt;fun&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="109bcbee3e25a658c4c9396a1465014de8c69b2c" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;fun&lt;/code&gt; is not a string, &lt;code&gt;binaryFun&lt;/code&gt; aliases itself away to &lt;code&gt;fun&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;fun&lt;/code&gt; 이 문자열이 아닌 경우 &lt;code&gt;binaryFun&lt;/code&gt; 은 별명을 &lt;code&gt;fun&lt;/code&gt; 로 별칭 지정합니다 .</target>
        </trans-unit>
        <trans-unit id="feeb8b9cc07251142d08e56cda48b8463e68f011" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;hasLength!Range&lt;/code&gt;, simply returns &lt;code&gt;range.length&lt;/code&gt; without checking &lt;code&gt;upTo&lt;/code&gt; (when specified).</source>
          <target state="translated">경우 &lt;code&gt;hasLength!Range&lt;/code&gt; , 단순히 반환 &lt;code&gt;range.length&lt;/code&gt; 을 확인하지 않고 &lt;code&gt;upTo&lt;/code&gt; (지정된 경우).</target>
        </trans-unit>
        <trans-unit id="46b7e88c254c5bba652608bb5aa781949149f305" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;haystack&lt;/code&gt; is a random-access range, all three components of the tuple have the same type as &lt;code&gt;haystack&lt;/code&gt;. Otherwise, &lt;code&gt;haystack&lt;/code&gt; must be a &lt;a href=&quot;std_range_primitives#isForwardRange&quot;&gt;forward range&lt;/a&gt; and the type of &lt;code&gt;result[0]&lt;/code&gt; and &lt;code&gt;result[1]&lt;/code&gt; is the same as &lt;a href=&quot;std_range#takeExactly&quot;&gt;&lt;code&gt;std.range.takeExactly&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">경우 &lt;code&gt;haystack&lt;/code&gt; 임의의 액세스 범위는, 튜플 모두 세 가지 구성 요소와 동일한 유형이 &lt;code&gt;haystack&lt;/code&gt; . 그렇지 않으면, &lt;code&gt;haystack&lt;/code&gt; 은 &lt;a href=&quot;std_range_primitives#isForwardRange&quot;&gt;포워드 범위&lt;/a&gt; 여야 하고 &lt;code&gt;result[0]&lt;/code&gt; 및 &lt;code&gt;result[1]&lt;/code&gt; 의 유형은 &lt;a href=&quot;std_range#takeExactly&quot;&gt; &lt;code&gt;std.range.takeExactly&lt;/code&gt; &lt;/a&gt; 와 동일합니다 .</target>
        </trans-unit>
        <trans-unit id="3993b4b628968f5e6dd7d41599d550f5e0f99ef4" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;impl.alignedAllocate&lt;/code&gt; exists, calls it and returns the result. Otherwise, always returns &lt;code&gt;null&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;impl.alignedAllocate&lt;/code&gt; 가 있으면 이를 호출하고 결과를 리턴합니다. 그렇지 않으면 항상 &lt;code&gt;null&lt;/code&gt; 을 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="02ba66810cd0cea189e643c4eeba55ce0d4de3e3" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;impl.deallocate&lt;/code&gt; is not defined, returns &lt;code&gt;false&lt;/code&gt;. Otherwise it forwards the call.</source>
          <target state="translated">경우 &lt;code&gt;impl.deallocate&lt;/code&gt; 가 정의되지 않은 반환 &lt;code&gt;false&lt;/code&gt; . 그렇지 않으면 통화를 전달합니다.</target>
        </trans-unit>
        <trans-unit id="48d32ce690c5f4ef93e7705c87fc34b78de3c611" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;input&lt;/code&gt; is a &lt;a href=&quot;std_range_primitives#isForwardRange&quot;&gt;forward range&lt;/a&gt;, &lt;code&gt;needle&lt;/code&gt; can be a &lt;a href=&quot;std_range_primitives#isForwardRange&quot;&gt;forward range&lt;/a&gt; too. In this case &lt;code&gt;startsWith!pred(haystack, needle)&lt;/code&gt; is evaluated on each evaluation.</source>
          <target state="translated">경우 &lt;code&gt;input&lt;/code&gt; A는 &lt;a href=&quot;std_range_primitives#isForwardRange&quot;&gt;전진 기어 단은&lt;/a&gt; , &lt;code&gt;needle&lt;/code&gt; 될 수 &lt;a href=&quot;std_range_primitives#isForwardRange&quot;&gt;순방향 범위&lt;/a&gt; 도. 이 경우 &lt;code&gt;startsWith!pred(haystack, needle)&lt;/code&gt; 가 각 평가에서 평가됩니다.</target>
        </trans-unit>
        <trans-unit id="26612f521f443b434c0c471a4bb077313e418fc6" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;less&lt;/code&gt; is the less-than operator, which is the default option, then &lt;code&gt;BinaryHeap&lt;/code&gt; defines a so-called max-heap that optimizes extraction of the</source>
          <target state="translated">경우 &lt;code&gt;less&lt;/code&gt; 덜보다 기본 옵션입니다 운영자이며, 다음, &lt;code&gt;BinaryHeap&lt;/code&gt; 의 추출을 최적화하는 소위 최대 힙을 정의</target>
        </trans-unit>
        <trans-unit id="bfc0979cbe401db983c65651eae478d6291e89b3" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;lhs != WithNaN.defaultValue!Lhs&lt;/code&gt; and the operator does not overflow, the function returns the same result as the built-in operator. In all other cases, returns &lt;code&gt;WithNaN.defaultValue!(typeof(lhs + rhs))&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;code&gt;lhs != WithNaN.defaultValue!Lhs&lt;/code&gt; 및 운영자는 오버 플로우, 함수는 내장 연산자와 같은 결과를 반환하지 않습니다. 다른 모든 경우에는 &lt;code&gt;WithNaN.defaultValue!(typeof(lhs + rhs))&lt;/code&gt; 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="7cc27af0c815a7e79af80d07be90722649a52810" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;lhs == WithNaN.defaultValue!Lhs&lt;/code&gt;, returns &lt;code&gt;double.init&lt;/code&gt;. Otherwise, has the same semantics as the default comparison.</source>
          <target state="translated">경우 &lt;code&gt;lhs == WithNaN.defaultValue!Lhs&lt;/code&gt; , 반환 &lt;code&gt;double.init&lt;/code&gt; . 그렇지 않으면 기본 비교와 동일한 의미를 갖습니다.</target>
        </trans-unit>
        <trans-unit id="d151dfc3083b5628c51cfe2464aced84ec2e31e0" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;lhs&lt;/code&gt; and &lt;code&gt;rhs&lt;/code&gt; reference the same instance, then nothing is done.</source>
          <target state="translated">경우 &lt;code&gt;lhs&lt;/code&gt; 과 &lt;code&gt;rhs&lt;/code&gt; 동일한 인스턴스를 참조하고 아무것도 수행되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="1e390340bdf19475ede0638df9c1955fea065de9" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;line&lt;/code&gt; has type &lt;code&gt;char[]&lt;/code&gt;, &lt;code&gt;wchar[]&lt;/code&gt;, &lt;code&gt;dchar[]&lt;/code&gt;, the line's content will be reused (overwritten) across reads.</source>
          <target state="translated">경우 &lt;code&gt;line&lt;/code&gt; 형이 &lt;code&gt;char[]&lt;/code&gt; , &lt;code&gt;wchar[]&lt;/code&gt; , &lt;code&gt;dchar[]&lt;/code&gt; , 라인의 내용이 다시 사용됩니다 (덮어 쓰기)를 통해 읽습니다.</target>
        </trans-unit>
        <trans-unit id="98f495eca2d1ec291e5bd0a688459f5f1c82028b" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;line&lt;/code&gt; has type &lt;code&gt;immutable(ubyte)[]&lt;/code&gt;, the behavior is similar to case (1), except that no UTF checking is attempted upon input.</source>
          <target state="translated">경우 &lt;code&gt;line&lt;/code&gt; 형 갖는 &lt;code&gt;immutable(ubyte)[]&lt;/code&gt; , 동작은 케이스 (1)과 유사한, 더 UTF 검사가 입력에 시도되지 않은 것을 제외.</target>
        </trans-unit>
        <trans-unit id="1a835fb44628e74f7f9ff451e8b58c089bf38a93" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;line&lt;/code&gt; has type &lt;code&gt;string&lt;/code&gt;, &lt;code&gt;wstring&lt;/code&gt;, or &lt;code&gt;dstring&lt;/code&gt;, a new string of the respective type is allocated every read.</source>
          <target state="translated">경우 &lt;code&gt;line&lt;/code&gt; 타입이 &lt;code&gt;string&lt;/code&gt; , &lt;code&gt;wstring&lt;/code&gt; , 또는 &lt;code&gt;dstring&lt;/code&gt; 을 , 각각의 유형의 새 문자열을 읽을 때마다 할당됩니다.</target>
        </trans-unit>
        <trans-unit id="18e388959a9abaf079dbbac18945110b36067b2b" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;line&lt;/code&gt; has type &lt;code&gt;ubyte[]&lt;/code&gt;, the behavior is similar to case (2), except that no UTF checking is attempted upon input.</source>
          <target state="translated">경우 &lt;code&gt;line&lt;/code&gt; 형 갖는다 &lt;code&gt;ubyte[]&lt;/code&gt; , 동작은 케이스 (2)와 유사하다, 더 UTF 검사가 입력에 시도되지 않은 것을 제외.</target>
        </trans-unit>
        <trans-unit id="c61c7e699d18c7312070fee75c860133527ced6d" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;main()&lt;/code&gt; or the thread returns normally, (does not throw an exception), the static destructor is added to the list of functions to be called on thread termination.</source>
          <target state="translated">경우 &lt;code&gt;main()&lt;/code&gt; 또는 스레드 반환 일반적으로 (예외를 throw하지 않습니다), 정적 소멸자는 스레드 종료에 호출되는 함수 목록에 추가됩니다.</target>
        </trans-unit>
        <trans-unit id="c93fc296f2b731310f3189f9c017eaec2be70e3e" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;maxSize == unbounded&lt;/code&gt;, returns &lt;code&gt;parent.goodAllocSize(bytes)&lt;/code&gt;. Otherwise, returns &lt;code&gt;max&lt;/code&gt; for sizes in the interval &lt;code&gt;[min, max]&lt;/code&gt;, and &lt;code&gt;parent.goodAllocSize(bytes)&lt;/code&gt; otherwise.</source>
          <target state="translated">&lt;code&gt;maxSize == unbounded&lt;/code&gt; 인 경우 &lt;code&gt;parent.goodAllocSize(bytes)&lt;/code&gt; 반환합니다 . 그렇지 않은 경우, 반환 &lt;code&gt;max&lt;/code&gt; 간격의 크기 &lt;code&gt;[min, max]&lt;/code&gt; 및 &lt;code&gt;parent.goodAllocSize(bytes)&lt;/code&gt; 그렇지.</target>
        </trans-unit>
        <trans-unit id="27889a42945896ba8e96a2b9190859d044697880" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;n &amp;gt;= r.length&lt;/code&gt;, the algorithm has no effect and returns &lt;code&gt;r[0 .. r.length]&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;code&gt;n &amp;gt;= r.length&lt;/code&gt; 알고리즘은 아무런 효과가 없다 되돌 &lt;code&gt;r[0 .. r.length]&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6c001d68799c0a0c1fe4332536339591e3128dd5" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;n&lt;/code&gt; is eligible for freelisting, returns &lt;code&gt;max&lt;/code&gt;. Otherwise, returns &lt;code&gt;parent.goodAllocSize(n)&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;n&lt;/code&gt; 이 프리리스트에 적합 하면 &lt;code&gt;max&lt;/code&gt; 를 리턴합니다 . 그렇지 않으면 &lt;code&gt;parent.goodAllocSize(n)&lt;/code&gt; 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="0fec7ab17fff539f84df945449516192c8415a4a" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;n&lt;/code&gt; is not defined, an infinite random access range with slicing.  If &lt;code&gt;n&lt;/code&gt; is defined, a random access range with slicing.</source>
          <target state="translated">경우 &lt;code&gt;n&lt;/code&gt; 정의되지 않은, 슬라이싱과 무한 랜덤 액세스 범위. 경우 &lt;code&gt;n&lt;/code&gt; 정의되어, 슬라이싱과 랜덤 액세스 범위.</target>
        </trans-unit>
        <trans-unit id="7f2409b5e5208bcbd4bd9ae5b46439868d522731" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;opCall&lt;/code&gt; is overridden for the struct, and the struct is initialized with a value that is of a different type, then the &lt;code&gt;opCall&lt;/code&gt; operator is called:</source>
          <target state="translated">경우 &lt;code&gt;opCall&lt;/code&gt; 이 구조체에 대해 재정의하고, 구조체가 다른 유형 인 값으로 초기화 한 후 &lt;code&gt;opCall&lt;/code&gt; 의 연산자라고합니다 :</target>
        </trans-unit>
        <trans-unit id="0a8768e44be6ce84df4d8ac63955bf151c1ba410" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;opIndex&lt;/code&gt; is declared with only one argument, the compile-time argument to &lt;code&gt;opDollar&lt;/code&gt; may be omitted. In this case, it is illegal to use &lt;code&gt;$&lt;/code&gt; inside an array indexing expression with more than one argument.</source>
          <target state="translated">경우 &lt;code&gt;opIndex&lt;/code&gt; 는 하나의 인수 선언에 컴파일시 인수 &lt;code&gt;opDollar&lt;/code&gt; 은 생략 될 수있다. 이 경우 둘 이상의 인수가있는 배열 인덱싱 표현식에서 &lt;code&gt;$&lt;/code&gt; 를 사용하는 것은 불법 입니다.</target>
        </trans-unit>
        <trans-unit id="1c029e2e84868e89d9aba168477cd4b281e4a698" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;p&lt;/code&gt; is a pointer somewhere inside a block allocated with this allocator, &lt;code&gt;result&lt;/code&gt; holds a pointer to the beginning of the allocated block and returns &lt;code&gt;Ternary.yes&lt;/code&gt;. Otherwise, &lt;code&gt;result&lt;/code&gt; holds &lt;code&gt;null&lt;/code&gt; and returns &lt;code&gt;Ternary.no&lt;/code&gt;. If the pointer points immediately after an allocated block, the result is implementation defined.</source>
          <target state="translated">&lt;code&gt;p&lt;/code&gt; 가이 할당 &lt;code&gt;Ternary.yes&lt;/code&gt; 할당 된 블록 내부의 포인터 인 경우 &lt;code&gt;result&lt;/code&gt; 는 할당 된 블록의 시작에 대한 포인터를 보유하고 Ternary.yes를 리턴합니다 . 그렇지 않으면 &lt;code&gt;result&lt;/code&gt; 는 &lt;code&gt;null&lt;/code&gt; 을 보유하고 &lt;code&gt;Ternary.no&lt;/code&gt; 를 반환합니다 . 포인터가 할당 된 블록 바로 다음을 가리키면 결과가 구현 정의됩니다.</target>
        </trans-unit>
        <trans-unit id="e2eb2629d5b4956bd1542eca4775455139c95a61" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;path&lt;/code&gt; is a relative directory, return it unaltered.</source>
          <target state="translated">경우 &lt;code&gt;path&lt;/code&gt; 상대 디렉토리, 그것은 변경되지 않은 반환합니다.</target>
        </trans-unit>
        <trans-unit id="702fecc6b0bc34adfafc2cb51d268f4825e76aef" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;path&lt;/code&gt; is already absolute, return it.</source>
          <target state="translated">경우 &lt;code&gt;path&lt;/code&gt; 이미 절대 그것을 돌려줍니다.</target>
        </trans-unit>
        <trans-unit id="051c5165fdb7f4181c26346b52a8a370bb269c20" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;path&lt;/code&gt; is empty, return &lt;code&gt;null&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;path&lt;/code&gt; 가 비어 있으면 &lt;code&gt;null&lt;/code&gt; 을 반환 합니다.</target>
        </trans-unit>
        <trans-unit id="de70cd968c35f871aa7f988334ddd5070ebe64cf" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;path&lt;/code&gt; is on the form &lt;code&gt;\\&lt;i&gt;server&lt;/i&gt;\&lt;i&gt;share&lt;/i&gt;\...&lt;/code&gt; (UNC path), &lt;a href=&quot;#isValidFilename&quot;&gt;&lt;code&gt;isValidFilename&lt;/code&gt;&lt;/a&gt; is applied to</source>
          <target state="translated">경우 &lt;code&gt;path&lt;/code&gt; 형태에 &lt;code&gt;\\&lt;i&gt;server&lt;/i&gt;\&lt;i&gt;share&lt;/i&gt;\...&lt;/code&gt; (UNC 경로), &lt;a href=&quot;#isValidFilename&quot;&gt; &lt;code&gt;isValidFilename&lt;/code&gt; 이&lt;/a&gt; 적용됩니다</target>
        </trans-unit>
        <trans-unit id="5ccfc704dde80078077c0681938c9dc1e45235e2" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;path&lt;/code&gt; starts with &lt;code&gt;\\.\&lt;/code&gt; (Win32 device namespace) this function returns &lt;code&gt;false&lt;/code&gt;; such paths are beyond the scope of this module.</source>
          <target state="translated">&lt;code&gt;path&lt;/code&gt; 가 &lt;code&gt;\\.\&lt;/code&gt; (Win32 장치 네임 스페이스) 로 시작 하면 이 함수는 &lt;code&gt;false&lt;/code&gt; 를 반환합니다 . 이러한 경로는이 모듈의 범위를 벗어납니다.</target>
        </trans-unit>
        <trans-unit id="891daee93beed99df04fb47b76bddba5d0aeec90" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;path&lt;/code&gt; starts with &lt;code&gt;\\?\&lt;/code&gt; (long UNC path), the only requirement for the rest of the string is that it does not contain the null character.</source>
          <target state="translated">&lt;code&gt;path&lt;/code&gt; 가 &lt;code&gt;\\?\&lt;/code&gt; (긴 UNC 경로) 로 시작하는 경우 나머지 문자열에 대한 유일한 요구 사항은 null 문자를 포함하지 않는 것입니다.</target>
        </trans-unit>
        <trans-unit id="cf0839c8941b9553277dcc1246fadae5b4af51e5" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;postData&lt;/code&gt; is non-null the method will be set to &lt;code&gt;post&lt;/code&gt; for HTTP requests.</source>
          <target state="translated">&lt;code&gt;postData&lt;/code&gt; 가 널이 아닌 경우 메소드는 HTTP 요청에 대해 &lt;code&gt;post&lt;/code&gt; 하도록 설정됩니다 .</target>
        </trans-unit>
        <trans-unit id="b45cfaf55131d31d198ea2c44bd484f7f79174d9" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;pretty&lt;/code&gt; is false no whitespaces are generated. If &lt;code&gt;pretty&lt;/code&gt; is true serialized string is formatted to be human-readable. Set the &lt;a href=&quot;#JSONOptions.specialFloatLiterals&quot;&gt;&lt;code&gt;JSONOptions.specialFloatLiterals&lt;/code&gt;&lt;/a&gt; flag is set in &lt;code&gt;options&lt;/code&gt; to encode NaN/Infinity as strings.</source>
          <target state="translated">&lt;code&gt;pretty&lt;/code&gt; 가 false 이면 공백이 생성되지 않습니다. 경우 &lt;code&gt;pretty&lt;/code&gt; 사실 직렬화 된 문자열은 사람이 읽을 수 있도록 형식이 설정되어 있습니다. 설정 &lt;a href=&quot;#JSONOptions.specialFloatLiterals&quot;&gt; &lt;code&gt;JSONOptions.specialFloatLiterals&lt;/code&gt; 의&lt;/a&gt; 플래그가 설정되어 &lt;code&gt;options&lt;/code&gt; 인코딩 NaN이 / 문자열로 무한대로.</target>
        </trans-unit>
        <trans-unit id="4fe6d0c26964bd6dde3a76798f875b6541f56e6c" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;primary&lt;/code&gt; does not own &lt;code&gt;b&lt;/code&gt;, then &lt;code&gt;fallback.reallocate(b, newSize)&lt;/code&gt; is attempted. If that fails, an attempt is made to move the allocation from &lt;code&gt;fallback&lt;/code&gt; to &lt;code&gt;primary&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;code&gt;primary&lt;/code&gt; 소유하지 않는 &lt;code&gt;b&lt;/code&gt; 다음, &lt;code&gt;fallback.reallocate(b, newSize)&lt;/code&gt; 시도한다. 실패하면 할당을 &lt;code&gt;fallback&lt;/code&gt; 에서 &lt;code&gt;primary&lt;/code&gt; 으로 이동하려고 시도 합니다.</target>
        </trans-unit>
        <trans-unit id="45d84a0c7a2f66706678e328dd9e74e78023bd34" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;printf&lt;/code&gt;-style logging is needed add a &lt;b&gt;f&lt;/b&gt; to the logging call, such as &lt;code&gt;myLogger.infof(&quot;Hello %s&quot;, &quot;world&quot;);&lt;/code&gt; or &lt;code&gt;fatalf(&quot;errno %d&quot;, 1337)&lt;/code&gt;. The additional &lt;b&gt;f&lt;/b&gt; appended to the function name enables &lt;code&gt;printf&lt;/code&gt;-style logging for all combinations of explicit &lt;code&gt;LogLevel&lt;/code&gt; and conditional logging functions and methods.</source>
          <target state="translated">&lt;code&gt;printf&lt;/code&gt; 스타일 로깅이 필요한 경우 &lt;code&gt;myLogger.infof(&quot;Hello %s&quot;, &quot;world&quot;);&lt;/code&gt; 와 같은 로깅 호출에 &lt;b&gt;f&lt;/b&gt; 를 추가하십시오 . 또는 &lt;code&gt;fatalf(&quot;errno %d&quot;, 1337)&lt;/code&gt; 입니다. 함수 이름에 추가 된 &lt;b&gt;f&lt;/b&gt; 는 명시 적 &lt;code&gt;LogLevel&lt;/code&gt; 및 조건부 로깅 함수 및 메소드 의 모든 조합에 대해 &lt;code&gt;printf&lt;/code&gt; 스타일 로깅을 가능하게 합니다.</target>
        </trans-unit>
        <trans-unit id="c809d18303614396b533b1264943fb0bf373af22" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;r&lt;/code&gt; contains equivalent elements, multiple permutations of &lt;code&gt;r&lt;/code&gt; satisfy these constraints. In such cases, &lt;code&gt;pivotPartition&lt;/code&gt; attempts to distribute equivalent elements fairly to the left and right of &lt;code&gt;k&lt;/code&gt; such that &lt;code&gt;k&lt;/code&gt; stays close to &lt;code&gt;r.length / 2&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;code&gt;r&lt;/code&gt; 은 해당 요소를 포함, 여러 순열 &lt;code&gt;r&lt;/code&gt; 은 이러한 제약 조건을 만족시킨다. 이러한 경우 &lt;code&gt;pivotPartition&lt;/code&gt; 은 &lt;code&gt;k&lt;/code&gt; 가 &lt;code&gt;r.length / 2&lt;/code&gt; 가깝도록 &lt;code&gt;k&lt;/code&gt; 의 왼쪽과 오른쪽에 동등한 요소를 균등하게 분배하려고합니다 .</target>
        </trans-unit>
        <trans-unit id="23935d946a100a97c3e455c30306a633f7b98438" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;r&lt;/code&gt; has a length, then this is &amp;Omicron;(&lt;code&gt;1&lt;/code&gt;). Otherwise, it's &amp;Omicron;(&lt;code&gt;r.length&lt;/code&gt;).</source>
          <target state="translated">&lt;code&gt;r&lt;/code&gt; 의 길이가 있으면 &amp;Omicron; ( &lt;code&gt;1&lt;/code&gt; )입니다. 그렇지 않으면 &amp;Omicron; ( &lt;code&gt;r.length&lt;/code&gt; )입니다.</target>
        </trans-unit>
        <trans-unit id="f163286db8bb098fc5cc4073249e55f06a301b9e" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;r&lt;/code&gt; is a string with Unicode characters in it, &lt;code&gt;padLeft&lt;/code&gt; follows D's rules about length for strings, which is not the number of characters, or graphemes, but instead the number of encoding units. If you want to treat each grapheme as only one encoding unit long, then call &lt;a href=&quot;std_uni#byGrapheme&quot;&gt;&lt;code&gt;std.uni.byGrapheme&lt;/code&gt;&lt;/a&gt; before calling this function.</source>
          <target state="translated">&lt;code&gt;r&lt;/code&gt; 이 유니 코드 문자가 포함 된 문자열 인 경우 &lt;code&gt;padLeft&lt;/code&gt; 는 문자열 길이에 대한 D의 규칙을 따릅니다. 이는 문자 수 또는 그래 핀 이 아니라 대신 인코딩 단위 수입니다. 각 &lt;a href=&quot;std_uni#byGrapheme&quot;&gt; &lt;code&gt;std.uni.byGrapheme&lt;/code&gt; &lt;/a&gt; 를 하나의 인코딩 단위로만 처리하려면 이 함수를 호출하기 전에 std.uni.byGrapheme 을 호출하십시오.</target>
        </trans-unit>
        <trans-unit id="6a927ae2914fb825262976485c0cc9304c3da3c5" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;r&lt;/code&gt; is not an auto-decodable string (i.e. a narrow string or a user-defined type that implicits converts to a string type), then &lt;code&gt;r&lt;/code&gt; is returned.  Otherwise, &lt;code&gt;r&lt;/code&gt; is converted to its corresponding string type (if it's not already a string) and wrapped in a random-access range where the element encoding type of the string (its code unit) is the element type of the range, and that range returned. The range has slicing.  If &lt;code&gt;r&lt;/code&gt; is quirky enough to be a struct or class which is an input range of characters on its own (i.e. it has the input range API as member functions),</source>
          <target state="translated">&lt;code&gt;r&lt;/code&gt; 이 자동 디코딩 가능 문자열이 아닌 경우 (예 : 좁은 문자열 또는 암시 적을 문자열 유형으로 변환하는 사용자 정의 유형) &lt;code&gt;r&lt;/code&gt; 이 반환됩니다. 그렇지 않으면 &lt;code&gt;r&lt;/code&gt; 은 해당 문자열 유형으로 변환되고 (아직 문자열이 아닌 경우) 문자열의 요소 인코딩 유형 (코드 단위)이 범위의 요소 유형 및 해당 범위의 임의 액세스 범위로 랩핑됩니다. 돌아 왔습니다. 범위는 슬라이싱이 있습니다. &lt;code&gt;r&lt;/code&gt; 이 그 자체로 문자의 입력 범위 인 구조체 또는 클래스가 될 정도로 기발한 경우 (즉, 입력 범위 API를 멤버 함수로 사용)</target>
        </trans-unit>
        <trans-unit id="df6a47c8f433360081103c7b545791ca9cd35f93" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;range&lt;/code&gt; does not have length, and &lt;code&gt;popFront&lt;/code&gt; is called when &lt;code&gt;front.index == Enumerator.max&lt;/code&gt;, the index will overflow and continue from &lt;code&gt;Enumerator.min&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;code&gt;range&lt;/code&gt; 길이를 가지고 있지 않으며, &lt;code&gt;popFront&lt;/code&gt; 이 때 호출되는 &lt;code&gt;front.index == Enumerator.max&lt;/code&gt; , 인덱스가 오버플에서 계속 &lt;code&gt;Enumerator.min&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5e2389187db9ad1c90dc2cdb963a735557c21c35" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;range&lt;/code&gt; has length, then it is an error to pass a value for &lt;code&gt;start&lt;/code&gt; so that &lt;code&gt;start + range.length&lt;/code&gt; is bigger than &lt;code&gt;Enumerator.max&lt;/code&gt;, thus it is ensured that overflow cannot happen.</source>
          <target state="translated">경우 &lt;code&gt;range&lt;/code&gt; 길이가, 다음이 값을 전달하면 오류가 &lt;code&gt;start&lt;/code&gt; 되도록 &lt;code&gt;start + range.length&lt;/code&gt; 보다 큰 &lt;code&gt;Enumerator.max&lt;/code&gt; 따라서는 오버 플로우가 발생하지 않는지를 확인한다.</target>
        </trans-unit>
        <trans-unit id="111a596bfe5993b016245842df9ecb465a3674d7" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;rhs != WithNaN.defaultValue!Rhs&lt;/code&gt; and the operator does not overflow, the function returns the same result as the built-in operator. In all other cases, returns &lt;code&gt;WithNaN.defaultValue!(typeof(lhs + rhs))&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;code&gt;rhs != WithNaN.defaultValue!Rhs&lt;/code&gt; 및 운영자는 오버 플로우, 함수는 내장 연산자와 같은 결과를 반환하지 않습니다. 다른 모든 경우에는 &lt;code&gt;WithNaN.defaultValue!(typeof(lhs + rhs))&lt;/code&gt; 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="f5536ec979292168bf217723d15877e765427904" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;rhs&lt;/code&gt; is &lt;code&gt;WithNaN.defaultValue!Rhs&lt;/code&gt;, returns &lt;code&gt;WithNaN.defaultValue!Lhs&lt;/code&gt;. Otherwise, returns &lt;code&gt;cast(Lhs) rhs&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;code&gt;rhs&lt;/code&gt; 있다 &lt;code&gt;WithNaN.defaultValue!Rhs&lt;/code&gt; , 반환 &lt;code&gt;WithNaN.defaultValue!Lhs&lt;/code&gt; . 그렇지 않으면 &lt;code&gt;cast(Lhs) rhs&lt;/code&gt; 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="6ede40fbc0f7d83884db066a6386fc8a519d5ed8" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;s == 0&lt;/code&gt;, the call may return any empty slice (including &lt;code&gt;null&lt;/code&gt;). Otherwise, the call allocates &lt;code&gt;s&lt;/code&gt; bytes of memory and returns the allocated block, or &lt;code&gt;null&lt;/code&gt; if the request could not be satisfied.</source>
          <target state="translated">경우 &lt;code&gt;s == 0&lt;/code&gt; , 전화는 (를 포함하여 빈 슬라이스 반환 할 수 있습니다 &lt;code&gt;null&lt;/code&gt; ). 그렇지 않으면 호출은 &lt;code&gt;s&lt;/code&gt; 바이트의 메모리를 할당하고 할당 된 블록을 리턴하거나 요청을 충족시킬 수없는 경우 &lt;code&gt;null&lt;/code&gt; 합니다.</target>
        </trans-unit>
        <trans-unit id="9eadce3ccc140e91f7b505d0328ee8cc176eeac6" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;s == SwapStrategy.unstable &amp;amp;&amp;amp; isRandomAccessRange!Range &amp;amp;&amp;amp; hasLength!Range &amp;amp;&amp;amp; hasLvalueElements!Range&lt;/code&gt;, then elements are moved from the end of the range into the slots to be filled. In this case, the absolute minimum of moves is performed.</source>
          <target state="translated">경우 &lt;code&gt;s == SwapStrategy.unstable &amp;amp;&amp;amp; isRandomAccessRange!Range &amp;amp;&amp;amp; hasLength!Range &amp;amp;&amp;amp; hasLvalueElements!Range&lt;/code&gt; 슬롯이 채워 져야으로 다음 요소 범위의 단부로부터 이동된다. 이 경우 절대 최소 이동이 수행됩니다.</target>
        </trans-unit>
        <trans-unit id="8bbc6063db8df4c25b1d7ab2586ea771801923fb" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;s&lt;/code&gt; is a function template, i.e. the only member of a template and that member is a function, return that template.</source>
          <target state="translated">경우 &lt;code&gt;s&lt;/code&gt; 함수 템플릿, 즉 템플릿의 유일한 멤버와 그 멤버 함수, 해당 템플릿을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="ac063e0ae979bd086a87ed636e906eb9690bf4e1" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;str&lt;/code&gt; ends with &lt;code&gt;delimiter&lt;/code&gt;, then &lt;code&gt;str&lt;/code&gt; is returned without &lt;code&gt;delimiter&lt;/code&gt; on its end. If it &lt;code&gt;str&lt;/code&gt; does</source>
          <target state="translated">경우 &lt;code&gt;str&lt;/code&gt; 과 끝 &lt;code&gt;delimiter&lt;/code&gt; 한 후 &lt;code&gt;str&lt;/code&gt; 없이 반환 &lt;code&gt;delimiter&lt;/code&gt; 의 끝. 이 경우 &lt;code&gt;str&lt;/code&gt; 않습니다</target>
        </trans-unit>
        <trans-unit id="9a851969ac104167dbde2b6f580e63232a655ac8" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;str&lt;/code&gt; starts with &lt;code&gt;delimiter&lt;/code&gt;, then the part of &lt;code&gt;str&lt;/code&gt; following &lt;code&gt;delimiter&lt;/code&gt; is returned. If &lt;code&gt;str&lt;/code&gt; does</source>
          <target state="translated">경우 &lt;code&gt;str&lt;/code&gt; 시작 &lt;code&gt;delimiter&lt;/code&gt; , 다음의 부분 &lt;code&gt;str&lt;/code&gt; 을 다음 &lt;code&gt;delimiter&lt;/code&gt; 반환됩니다. 경우 &lt;code&gt;str&lt;/code&gt; 않습니다</target>
        </trans-unit>
        <trans-unit id="4978f696ceefb2aa4374b5f4ce674343dc8b0fed" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;sz&lt;/code&gt; is zero, the memory referenced by p will be deallocated as if by a call to &lt;code&gt;free&lt;/code&gt;. If &lt;code&gt;p&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt;, new memory will be allocated via &lt;code&gt;malloc&lt;/code&gt;. If &lt;code&gt;p&lt;/code&gt; is pointing to memory not allocated from the GC or to the interior of an allocated memory block, no operation is performed and null is returned.</source>
          <target state="translated">경우 &lt;code&gt;sz&lt;/code&gt; 제로, P에 의해 참조되는 메모리의 호출에 의해 것처럼 해제 될 것입니다 &lt;code&gt;free&lt;/code&gt; . &lt;code&gt;p&lt;/code&gt; 가 &lt;code&gt;null&lt;/code&gt; 인 경우 , &lt;code&gt;malloc&lt;/code&gt; 을 통해 새 메모리가 할당됩니다 . &lt;code&gt;p&lt;/code&gt; 가 GC로부터 할당되지 않은 메모리를 가리 키거나 할당 된 메모리 블록의 내부를 가리키는 경우 , 어떠한 동작도 수행되지 않고 널이 리턴된다.</target>
        </trans-unit>
        <trans-unit id="b756c4e80a3354d029916e71e883d1d288090aff" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;ticksPerSec&lt;/code&gt; is &lt;code&gt;0&lt;/code&gt;, then then &lt;code&gt;TickDuration&lt;/code&gt; failed to get the value of &lt;code&gt;ticksPerSec&lt;/code&gt; on the current system, and &lt;code&gt;TickDuration&lt;/code&gt; is not going to work. That would be highly abnormal though.</source>
          <target state="translated">경우 &lt;code&gt;ticksPerSec&lt;/code&gt; 가 있다 &lt;code&gt;0&lt;/code&gt; , 다음 다음 &lt;code&gt;TickDuration&lt;/code&gt; 은 값 가져 오지 못했습니다 &lt;code&gt;ticksPerSec&lt;/code&gt; 현재 시스템에, 그리고 &lt;code&gt;TickDuration&lt;/code&gt; 는 작업에 갈 수 없습니다. 그래도 매우 비정상적입니다.</target>
        </trans-unit>
        <trans-unit id="0a174cf4ab1d67c6c049d75173bd4c15d10ca6f9" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;timeval.tv_sec&lt;/code&gt; is int, and the result can't fit in an int, then the closest value that can be held in 32 bits will be used for &lt;code&gt;tv_sec&lt;/code&gt;. (so &lt;code&gt;int.max&lt;/code&gt; if it goes over and &lt;code&gt;int.min&lt;/code&gt; if it goes under).</source>
          <target state="translated">경우 &lt;code&gt;timeval.tv_sec&lt;/code&gt; 는 int이며, 그 결과는 INT에 맞지 않을 수 있으며, 그 다음 32 비트에 유지 될 수있는 가장 가까운 값을 사용한다 &lt;code&gt;tv_sec&lt;/code&gt; 가 . (따라서 &lt;code&gt;int.max&lt;/code&gt; , &lt;code&gt;int.min&lt;/code&gt; 지면 int.min ).</target>
        </trans-unit>
        <trans-unit id="b737bf16441ab6f2f4b4d91936f54afa2de4c527" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;toHash&lt;/code&gt; must consistently be the same value when &lt;code&gt;opEquals&lt;/code&gt; returns true. In other words, two objects that are considered equal should always have the same hash value. Otherwise, undefined behavior will result.</source>
          <target state="translated">경우 &lt;code&gt;toHash&lt;/code&gt; 이 때 지속적으로 같은 값이어야합니다 &lt;code&gt;opEquals&lt;/code&gt; 는 true를 돌려줍니다. 즉, 동일한 것으로 간주되는 두 객체는 ​​항상 동일한 해시 값을 가져야합니다. 그렇지 않으면 정의되지 않은 동작이 발생합니다.</target>
        </trans-unit>
        <trans-unit id="46b829bd712225872ea6d9fe14e82ebf07db56c2" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;toHash&lt;/code&gt; must consistently be the same value when &lt;code&gt;opEquals&lt;/code&gt; returns true. In other words, two structs that are considered equal should always have the same hash value. Otherwise, undefined behavior will result.</source>
          <target state="translated">경우 &lt;code&gt;toHash&lt;/code&gt; 이 때 지속적으로 같은 값이어야합니다 &lt;code&gt;opEquals&lt;/code&gt; 는 true를 돌려줍니다. 다시 말해, 동일한 것으로 간주되는 두 개의 구조체는 항상 동일한 해시 값을 가져야합니다. 그렇지 않으면 정의되지 않은 동작이 발생합니다.</target>
        </trans-unit>
        <trans-unit id="bdd34bf58210d81d6b36b3924a3e5089f87b29e6" translate="yes" xml:space="preserve">
          <source>If B to A conversion is convariant that requires offseet adjusting, all return statements should be adjusted to return expressions typed A.</source>
          <target state="translated">B에서 A 로의 변환이 오프 시트 조정을 필요로하는 불변 인 경우, 모든 리턴 문은 A 유형의 표현식을 리턴하도록 조정되어야합니다.</target>
        </trans-unit>
        <trans-unit id="5f616405142623769cdbbf978f769d6bf8291c51" translate="yes" xml:space="preserve">
          <source>If JSON value is null, then operator initializes it with object and then sets &lt;code&gt;value&lt;/code&gt; for it.</source>
          <target state="translated">JSON 값이 null이면 연산자는 객체로 &lt;code&gt;value&lt;/code&gt; 을 초기화 한 다음 값 을 설정 합니다.</target>
        </trans-unit>
        <trans-unit id="b3d334f3b16094aef354285c2c419452a7b589ea" translate="yes" xml:space="preserve">
          <source>If Source is a &lt;code&gt;struct&lt;/code&gt; then wrapping/unwrapping will create a copy; it is not possible to affect the original &lt;code&gt;struct&lt;/code&gt; through the wrapper.</source>
          <target state="translated">Source가 &lt;code&gt;struct&lt;/code&gt; 라면 랩핑 / 언 래핑은 복사본을 생성합니다. 랩퍼를 통해 원래 &lt;code&gt;struct&lt;/code&gt; 에 영향을 줄 수 없습니다 .</target>
        </trans-unit>
        <trans-unit id="2e8ce4614eba95d281d33d622683800da451bb90" translate="yes" xml:space="preserve">
          <source>If Statement</source>
          <target state="translated">If 문</target>
        </trans-unit>
        <trans-unit id="dd4a3f3a81119e68ec01207d19a926cbd1e5f669" translate="yes" xml:space="preserve">
          <source>If Targets has only one entry and Source is a class which explicitly implements it, wrap simply returns src upcasted to &lt;code&gt;Targets[0]&lt;/code&gt;.</source>
          <target state="translated">Targets에 항목이 하나만 있고 Source가 명시 적으로 구현하는 클래스 인 경우 wrap은 &lt;code&gt;Targets[0]&lt;/code&gt; 업 캐스트 된 src를 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="562d6a085d036935dc458e97eb2b83b32b781d44" translate="yes" xml:space="preserve">
          <source>If a</source>
          <target state="translated">만약</target>
        </trans-unit>
        <trans-unit id="38354ffb09e774c4e1e6d7b1ae1d349a56902b44" translate="yes" xml:space="preserve">
          <source>If a &lt;a href=&quot;declaration#StructInitializer&quot;&gt;&lt;i&gt;StructInitializer&lt;/i&gt;&lt;/a&gt; is supplied, the fields are initialized by the &lt;a href=&quot;declaration#StructMemberInitializer&quot;&gt;&lt;i&gt;StructMemberInitializer&lt;/i&gt;&lt;/a&gt; syntax.</source>
          <target state="translated">경우 &lt;a href=&quot;declaration#StructInitializer&quot;&gt;&lt;i&gt;StructInitializer가&lt;/i&gt;&lt;/a&gt; 공급되고, 필드는 초기화된다 &lt;a href=&quot;declaration#StructMemberInitializer&quot;&gt;&lt;i&gt;StructMemberInitializer의&lt;/i&gt;&lt;/a&gt; 구문.</target>
        </trans-unit>
        <trans-unit id="82eb1a8a8a78d51182899822b5022de27e60420b" translate="yes" xml:space="preserve">
          <source>If a and b are both class objects, then the expression is rewritten as:</source>
          <target state="translated">a와 b가 모두 클래스 객체이면 표현식은 다음과 같이 다시 작성됩니다.</target>
        </trans-unit>
        <trans-unit id="5e7e375e1c7dad6e65f441c0e60a25b131f8701e" translate="yes" xml:space="preserve">
          <source>If a cast to a floating-point type is requested and &lt;code&gt;Hook&lt;/code&gt; defines &lt;code&gt;onBadCast&lt;/code&gt;, the cast is verified by ensuring &lt;code&gt;get == cast(T) U(get)&lt;/code&gt;. If that is not &lt;code&gt;true&lt;/code&gt;, &lt;code&gt;hook.onBadCast!U(get)&lt;/code&gt; is returned.</source>
          <target state="translated">부동 소수점 유형으로 의 캐스트가 요청되고 &lt;code&gt;Hook&lt;/code&gt; 가 &lt;code&gt;onBadCast&lt;/code&gt; 를 정의 하는 경우 &lt;code&gt;get == cast(T) U(get)&lt;/code&gt; 확인하여 캐스트를 확인합니다 . 그가 아닌 경우 &lt;code&gt;true&lt;/code&gt; , &lt;code&gt;hook.onBadCast!U(get)&lt;/code&gt; 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="214d150104c62cbd9a8df607ea8c5c4b3837548b" translate="yes" xml:space="preserve">
          <source>If a cast to an integral type is requested and &lt;code&gt;Hook&lt;/code&gt; defines &lt;code&gt;onBadCast&lt;/code&gt;, the cast is verified by ensuring &lt;code&gt;get&lt;/code&gt; and &lt;code&gt;cast(U) get&lt;/code&gt; are the same arithmetic number. (Note that &lt;code&gt;int(-1)&lt;/code&gt; and &lt;code&gt;uint(1)&lt;/code&gt; are different values arithmetically although they have the same bitwise representation and compare equal by language rules.) If the numbers are not arithmetically equal, &lt;code&gt;hook.onBadCast!U(get)&lt;/code&gt; is returned.</source>
          <target state="translated">정수 유형으로의 캐스트가 요청되고 &lt;code&gt;Hook&lt;/code&gt; 이 &lt;code&gt;onBadCast&lt;/code&gt; 를 정의 하는 경우 &lt;code&gt;get&lt;/code&gt; 및 &lt;code&gt;cast(U) get&lt;/code&gt; 이 동일한 산술 번호 인지 확인하여 캐스트를 확인합니다 . (참고 &lt;code&gt;int(-1)&lt;/code&gt; 와 &lt;code&gt;uint(1)&lt;/code&gt; 은 동일한 비트 표현이 언어 규칙에 따라 동일한 비교합니다. 산술적으로하지만 다른 값이다) 숫자가 산술적으로 동일하지 않을 경우, &lt;code&gt;hook.onBadCast!U(get)&lt;/code&gt; 반환 .</target>
        </trans-unit>
        <trans-unit id="f50b34e635f5b3d69730e335c13e613f658b1407" translate="yes" xml:space="preserve">
          <source>If a choice's return type is void, the choice must throw an exception, unless all the choices are void. In that case, castSwitch itself will return void.</source>
          <target state="translated">선택의 반환 유형이 void 인 경우 모든 선택이 void가 아닌 한 선택은 예외를 발생시켜야합니다. 이 경우 castSwitch 자체는 void를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="fb6d0d046ebbfc4f31bb86cf82620af737d82d69" translate="yes" xml:space="preserve">
          <source>If a constructor's code contains a delegate constructor call, all possible execution paths through the constructor must make exactly one delegate constructor call:</source>
          <target state="translated">생성자의 코드에 델리게이트 생성자 호출이 포함 된 경우 생성자를 통한 모든 가능한 실행 경로는 정확히 하나의 델리게이트 생성자 호출을 작성해야합니다.</target>
        </trans-unit>
        <trans-unit id="74c7db79dd1c4bbec318c1afec835bd55146cddb" translate="yes" xml:space="preserve">
          <source>If a copy constructor is defined, implicit calls to it will be inserted in the following situations:</source>
          <target state="translated">복사 생성자가 정의되면 다음과 같은 상황에서 암시 적 호출이 삽입됩니다.</target>
        </trans-unit>
        <trans-unit id="3a4c5302b387be4ef4923c3da45ea70ef8244969" translate="yes" xml:space="preserve">
          <source>If a declaration is followed by a documented unittest, the code in the unittest will be inserted in the &lt;b&gt;example&lt;/b&gt; section of the declaration:</source>
          <target state="translated">선언 뒤에 문서화 된 unittest가 오는 경우 unittest의 코드 가 선언 의 &lt;b&gt;예제&lt;/b&gt; 섹션에 삽입됩니다 .</target>
        </trans-unit>
        <trans-unit id="994d2a230df4885735f193cf875a7c34425353d8" translate="yes" xml:space="preserve">
          <source>If a declaration starts with a</source>
          <target state="translated">선언이</target>
        </trans-unit>
        <trans-unit id="5abfec0c9b70a28afdd54a250553e480e8e7f188" translate="yes" xml:space="preserve">
          <source>If a delegate is passed, the safety and purity of this function are inferred from &lt;code&gt;Dg&lt;/code&gt;'s safety and purity.</source>
          <target state="translated">델리게이트가 통과되면이 기능 의 안전성과 순도 는 &lt;code&gt;Dg&lt;/code&gt; 의 안전성과 순도 에서 유추됩니다 .</target>
        </trans-unit>
        <trans-unit id="ea319443f8c57e701d411ba01a8cc3309299df11" translate="yes" xml:space="preserve">
          <source>If a delegate that accepts a &lt;a href=&quot;std_variant#Variant&quot;&gt;&lt;code&gt;std.variant.Variant&lt;/code&gt;&lt;/a&gt; is included as the last argument to &lt;code&gt;receive&lt;/code&gt;, it will match any message that was not matched by an earlier delegate. If more than one argument is sent, the &lt;code&gt;Variant&lt;/code&gt; will contain a &lt;a href=&quot;std_typecons#Tuple&quot;&gt;&lt;code&gt;std.typecons.Tuple&lt;/code&gt;&lt;/a&gt; of all values sent.</source>
          <target state="translated">&lt;a href=&quot;std_variant#Variant&quot;&gt; &lt;code&gt;std.variant.Variant&lt;/code&gt; &lt;/a&gt; 를 허용하는 대리자 가 &lt;code&gt;receive&lt;/code&gt; 의 마지막 인수로 포함 되면 이전 대리자와 일치하지 않은 모든 메시지와 일치합니다. 둘 이상의 인수가 전송되면 &lt;code&gt;Variant&lt;/code&gt; 에 전송 된 모든 값 의 &lt;a href=&quot;std_typecons#Tuple&quot;&gt; &lt;code&gt;std.typecons.Tuple&lt;/code&gt; &lt;/a&gt; 이 포함됩니다 .</target>
        </trans-unit>
        <trans-unit id="6772ca1fa3a50c56b1e2254d50cd48e0b56364df" translate="yes" xml:space="preserve">
          <source>If a delegating constructor is not called, a call to the base class's default constructor is issued.</source>
          <target state="translated">위임 생성자가 호출되지 않으면 기본 클래스의 기본 생성자에 대한 호출이 발행됩니다.</target>
        </trans-unit>
        <trans-unit id="881137e036e5d861dacc5e49c7e5ec6d46042221" translate="yes" xml:space="preserve">
          <source>If a derived class overrides a base class member function with diferrent &lt;a href=&quot;#FunctionAttributes&quot;&gt;&lt;i&gt;FunctionAttributes&lt;/i&gt;&lt;/a&gt;, the missing attributes will be automatically compensated by the compiler.</source>
          <target state="translated">파생 클래스가 다른 &lt;a href=&quot;#FunctionAttributes&quot;&gt;&lt;i&gt;FunctionAttributes&lt;/i&gt;&lt;/a&gt; 로 기본 클래스 멤버 함수를 재정의하는 경우 누락 된 속성이 컴파일러에 의해 자동으로 보상됩니다.</target>
        </trans-unit>
        <trans-unit id="b01bf1413dae9a84ffd106c13e7efc616299cc07" translate="yes" xml:space="preserve">
          <source>If a documentation comment for a declaration consists only of the identifier &lt;code&gt;ditto&lt;/code&gt; then the documentation comment for the previous declaration at the same declaration scope is applied to this declaration as well.</source>
          <target state="translated">선언에 대한 문서 주석이 식별자 &lt;code&gt;ditto&lt;/code&gt; 로만 구성된 경우 동일한 선언 범위에서 이전 선언에 대한 문서 주석이이 선언에도 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="3415ea6dfee5691668c1c8232a3e5910eb9c73a0" translate="yes" xml:space="preserve">
          <source>If a field's type has disabled default construction, then it must be initialized in the constructor.</source>
          <target state="translated">필드 유형이 기본 생성을 비활성화 한 경우 생성자에서 초기화해야합니다.</target>
        </trans-unit>
        <trans-unit id="d8f6fa7fc0afa2680299befa1345222924cf9276" translate="yes" xml:space="preserve">
          <source>If a floating literal has a &lt;b&gt;.&lt;/b&gt; and a type suffix, at least one digit must be in-between:</source>
          <target state="translated">부동 문자가있는 경우 &lt;b&gt;. &lt;/b&gt;유형 접미사, 하나 이상의 숫자가 중간에 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="3a19adb71ebefd9a28ba0c9b27281e67156dc538" translate="yes" xml:space="preserve">
          <source>If a floating literal is followed by &lt;b&gt;i&lt;/b&gt;, then it is an</source>
          <target state="translated">부동 리터럴 뒤에 &lt;b&gt;i&lt;/b&gt; 가 오는 경우</target>
        </trans-unit>
        <trans-unit id="8d8575d274fd6277028e0c2b41501d26b560a2c4" translate="yes" xml:space="preserve">
          <source>If a function attempts to test itself for those attributes, then the function is inferred as not having those attributes.</source>
          <target state="translated">함수가 해당 속성에 대한 자체 테스트를 시도하면 해당 속성이없는 것으로 간주됩니다.</target>
        </trans-unit>
        <trans-unit id="a4a6cb5bd72ee43c0b82dda81af5fd129c286fde" translate="yes" xml:space="preserve">
          <source>If a function call passes no explicit argument, i.e. it would syntactically use &lt;code&gt;()&lt;/code&gt;, then these parentheses may be omitted, similar to a getter invocation of a &lt;a href=&quot;#property-functions&quot;&gt;property function&lt;/a&gt;.</source>
          <target state="translated">함수 호출이 명시 적 인수를 전달하지 않으면 (즉, 구문 적으로 &lt;code&gt;()&lt;/code&gt; 사용 ) , 이러한 괄호는 &lt;a href=&quot;#property-functions&quot;&gt;속성 함수&lt;/a&gt; 의 getter 호출과 유사하게 생략 될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="3e7b8dc0678edabe73fefcc44809c2cbac6174ce" translate="yes" xml:space="preserve">
          <source>If a function in a derived class overrides a function from its super class, then only one of the &lt;code&gt;in&lt;/code&gt; contracts of the function and its base functions must be satisfied. Overriding functions then becomes a process of</source>
          <target state="translated">파생 클래스에서 함수는 슈퍼 클래스의 함수의 다음 단 하나의 오버라이드 (override)하는 경우 &lt;code&gt;in&lt;/code&gt; 함수의 계약을하고 그것의 기본 기능을 만족해야합니다. 함수를 재정의하면</target>
        </trans-unit>
        <trans-unit id="833166b5c67f31578b3c0dc74c8f4637740cb9ae" translate="yes" xml:space="preserve">
          <source>If a function returns a delegate or function pointer, the parantheses are required if the returned value is to be called.</source>
          <target state="translated">함수가 대리자 또는 함수 포인터를 반환하는 경우 반환 된 값을 호출하려면 패러 틴이 필요합니다.</target>
        </trans-unit>
        <trans-unit id="a1d31581f409e137dd612d786dd84ed15f076e6f" translate="yes" xml:space="preserve">
          <source>If a function with an untyped parameter is specified, this function is called when the variant contains a type that does not match any other function. This can be used to apply the same function across multiple possible types. Exactly one generic function is allowed.</source>
          <target state="translated">형식화되지 않은 매개 변수가있는 함수가 지정된 경우 변형에 다른 함수와 일치하지 않는 형식이 포함 된 경우이 함수가 호출됩니다. 여러 가능한 유형에 동일한 기능을 적용하는 데 사용할 수 있습니다. 정확히 하나의 일반 기능이 허용됩니다.</target>
        </trans-unit>
        <trans-unit id="a87b66dd6db50119dfebfdc41112382fe6b81c05" translate="yes" xml:space="preserve">
          <source>If a function without parameters is specified, this function is called when &lt;code&gt;variant&lt;/code&gt; doesn't hold a value. Exactly one parameter-less function is allowed.</source>
          <target state="translated">매개 변수가없는 함수가 지정된 경우 &lt;code&gt;variant&lt;/code&gt; 이 값을 보유하지 않으면 이 함수가 호출됩니다 . 정확히 하나의 매개 변수없는 기능이 허용됩니다.</target>
        </trans-unit>
        <trans-unit id="834aeb00a2af9d1c11ab80f05c9f251ecfe858eb" translate="yes" xml:space="preserve">
          <source>If a legacy boolean returning custom handler is used, &lt;code&gt;false&lt;/code&gt; maps to &lt;code&gt;UnitTestResult.fail&lt;/code&gt;, and &lt;code&gt;true&lt;/code&gt; maps to &lt;code&gt;UnitTestResult.pass&lt;/code&gt;. This was the original behavior of the unit testing system.</source>
          <target state="translated">레거시 부울 리턴 사용자 정의 핸들러를 사용하는 경우 &lt;code&gt;false&lt;/code&gt; 는 &lt;code&gt;UnitTestResult.fail&lt;/code&gt; 에 맵핑 되고 &lt;code&gt;true&lt;/code&gt; 는 &lt;code&gt;UnitTestResult.pass&lt;/code&gt; 에 맵핑됩니다 . 이것이 단위 테스트 시스템의 원래 동작이었습니다.</target>
        </trans-unit>
        <trans-unit id="82b2fe9ee0ea82740e7dc777c9a1e9340bcda42d" translate="yes" xml:space="preserve">
          <source>If a library routine cannot handle the Typedef type, you can use the &lt;code&gt;TypedefType&lt;/code&gt; template to extract the type which the Typedef wraps.</source>
          <target state="translated">라이브러리 루틴이 &lt;code&gt;TypedefType&lt;/code&gt; 유형을 처리 할 수없는 경우 TypedefType 템플리트를 사용하여 Typedef가 랩핑하는 유형을 추출 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="4aba4b8ca7c725b8d06f470a62c86a1bda5b271f" translate="yes" xml:space="preserve">
          <source>If a mixin has an</source>
          <target state="translated">믹스 인에</target>
        </trans-unit>
        <trans-unit id="016a5428498ce2567043077b67b52a004f09c60b" translate="yes" xml:space="preserve">
          <source>If a module C imports modules A and B, any modifications to B will not silently change code in C that is dependent on A.</source>
          <target state="translated">모듈 C가 모듈 A와 B를 가져 오는 경우 B를 수정해도 A에 종속 된 C의 코드는 자동으로 변경되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="f84ff68027db236d1e6d7027fe7c21486026d4f8" translate="yes" xml:space="preserve">
          <source>If a nested class has the &lt;code&gt;static&lt;/code&gt; attribute, then it can not access variables of the enclosing scope that are local to the stack or need a &lt;code&gt;this&lt;/code&gt;:</source>
          <target state="translated">중첩 된 클래스가있는 경우 &lt;code&gt;static&lt;/code&gt; 속성을, 다음은 스택에 로컬 또는 바깥 쪽 범위의 액세스 변수는 필요없는 &lt;code&gt;this&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="56c79f57d1a50238baec29c9e84fb38c7b1202da" translate="yes" xml:space="preserve">
          <source>If a option is required, not passing it will result in an error</source>
          <target state="translated">옵션이 필요한 경우 전달하지 않으면 오류가 발생합니다</target>
        </trans-unit>
        <trans-unit id="149e6d9194089a56d26c5e902cbd9179de1d63bd" translate="yes" xml:space="preserve">
          <source>If a parameter-less function is specified it is called when either &lt;code&gt;variant&lt;/code&gt; doesn't hold a value or holds a type which isn't handled by the visiting functions.</source>
          <target state="translated">매개 변수가없는 함수가 지정되면 &lt;code&gt;variant&lt;/code&gt; 이 값을 보유하지 않거나 방문 함수가 처리하지 않는 유형을 보유 할 때 호출됩니다 .</target>
        </trans-unit>
        <trans-unit id="7beb51fb64caa2734e6c937b4e1f891bde552887" translate="yes" xml:space="preserve">
          <source>If a pointer contains a</source>
          <target state="translated">포인터에</target>
        </trans-unit>
        <trans-unit id="54a6b6d625a26fd15e5bed961a528f1a4d8c8d83" translate="yes" xml:space="preserve">
          <source>If a property function has no parameters, it works as a getter. If has exactly one parameter, it works as a setter.</source>
          <target state="translated">속성 함수에 매개 변수가 없으면 게터로 작동합니다. 정확히 하나의 매개 변수가 있으면 세터로 작동합니다.</target>
        </trans-unit>
        <trans-unit id="bd63b3bb30889f251334a86eb473db6c340d3649" translate="yes" xml:space="preserve">
          <source>If a protocol name is omitted, any protocol will be matched.</source>
          <target state="translated">프로토콜 이름을 생략하면 모든 프로토콜이 일치합니다.</target>
        </trans-unit>
        <trans-unit id="bc8ed891e7a0d7d840793ac113f827ba325b777c" translate="yes" xml:space="preserve">
          <source>If a range returned by &lt;code&gt;map&lt;/code&gt; or &lt;code&gt;asyncBuf&lt;/code&gt; is used as an input to &lt;code&gt;map&lt;/code&gt;, then as an optimization the copying from the output buffer of the first range to the input buffer of the second range is elided, even though the ranges returned by &lt;code&gt;map&lt;/code&gt; and &lt;code&gt;asyncBuf&lt;/code&gt; are non-random access ranges. This means that the &lt;code&gt;bufSize&lt;/code&gt; parameter passed to the current call to &lt;code&gt;map&lt;/code&gt; will be ignored and the size of the buffer will be the buffer size of &lt;code&gt;source&lt;/code&gt;.</source>
          <target state="translated">범위에 의해 반환되는 경우 &lt;code&gt;map&lt;/code&gt; 또는 &lt;code&gt;asyncBuf&lt;/code&gt; 는 입력을하도록 사용되는 &lt;code&gt;map&lt;/code&gt; 범위에 의해 반환되는 경우에도, 그 다음 두 번째 범위의 입력 버퍼에 제 1 범위의 출력 버퍼로 복사 최적화로 생략되어 &lt;code&gt;map&lt;/code&gt; 및 &lt;code&gt;asyncBuf&lt;/code&gt; 비 랜덤 액세스 범위입니다. 이는 현재 &lt;code&gt;map&lt;/code&gt; 호출에 전달 된 &lt;code&gt;bufSize&lt;/code&gt; 매개 변수 가 무시되고 버퍼 크기가 &lt;code&gt;source&lt;/code&gt; 의 버퍼 크기가됨을 의미 합니다 .</target>
        </trans-unit>
        <trans-unit id="b1a76bf15d9ef796c131b625f04b8d1b48403d73" translate="yes" xml:space="preserve">
          <source>If a slice operator appears as the left-hand side of an assignment expression, and the type of the right-hand side is the same as the element type of the left-hand side, then the array contents of the left-hand side are set to the right-hand side.</source>
          <target state="translated">슬라이스 연산자가 대입 식의 왼쪽으로 나타나고 오른쪽의 유형이 왼쪽의 요소 유형과 동일하면 왼쪽의 배열 내용은 다음과 같습니다. 오른쪽으로 설정하십시오.</target>
        </trans-unit>
        <trans-unit id="290e0c5d88ccb110cac619050e0670bb23f215bd" translate="yes" xml:space="preserve">
          <source>If a strongly pure function throws an exception or an error, the assumptions related to memoization and references do not carry to the thrown exception.</source>
          <target state="translated">강력하게 순수한 함수가 예외 또는 오류를 발생시키는 경우 메모 및 참조와 관련된 가정은 예외를 전달하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="b3a5f4c5b0a3ecfb344535d097fbd6472ec3aaaf" translate="yes" xml:space="preserve">
          <source>If a subexpression of an expression throws an exception, all temporaries created up to the evaluation of that subexpression will be destroyed per the rules above. No destructor calls will be issued for temporaries not yet constructed.</source>
          <target state="translated">표현식의 하위 표현식에서 예외가 발생하면 해당 하위 표현식의 평가까지 작성된 모든 임시는 위의 규칙에 따라 삭제됩니다. 아직 구성되지 않은 임시 항목에 대해서는 소멸자 호출이 발행되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="c750c9691a6ca511a5908ab0fae040fe6ae197ae" translate="yes" xml:space="preserve">
          <source>If a template argument matches a specialized template parameter, the argument is mangled with prefix &lt;b&gt;H&lt;/b&gt;.</source>
          <target state="translated">템플리트 인수가 특수한 템플리트 매개 변수와 일치하면 인수는 접 두부 &lt;b&gt;H&lt;/b&gt; 로 맹 글링됩니다 .</target>
        </trans-unit>
        <trans-unit id="537fb8313b9340d6a7720624890b667ceaf5eabd" translate="yes" xml:space="preserve">
          <source>If a template contains members whose name is the same as the template identifier and if the type or the parameters type of these members include at least all the template parameters then these members are assumed to be referred to in a template instantiation:</source>
          <target state="translated">템플리트에 이름이 템플리트 ID와 동일한 멤버를 포함하고 이러한 멤버의 유형 또는 매개 변수 유형에 최소한 모든 템플리트 매개 변수가 포함 된 경우 이러한 멤버는 템플리트 인스턴스화에서 참조되는 것으로 가정됩니다.</target>
        </trans-unit>
        <trans-unit id="6e940bc97403a68b4bd6fcc2185065a84be4a8ef" translate="yes" xml:space="preserve">
          <source>If a template declares exactly one member, and that member is a class with the same name as the template:</source>
          <target state="translated">템플릿이 정확히 하나의 멤버를 선언하고 해당 멤버가 템플릿과 이름이 같은 클래스 인 경우 :</target>
        </trans-unit>
        <trans-unit id="7228f16c50b7195b2939cb5fdb81b9ec5f38dc52" translate="yes" xml:space="preserve">
          <source>If a template declares exactly one member, and that member is a function with the same name as the template, it is a function template declaration. Alternatively, a function template declaration is a function declaration with a &lt;a href=&quot;#TemplateParameterList&quot;&gt;&lt;i&gt;TemplateParameterList&lt;/i&gt;&lt;/a&gt; immediately preceding the &lt;a href=&quot;function#Parameters&quot;&gt;&lt;i&gt;Parameters&lt;/i&gt;&lt;/a&gt;.</source>
          <target state="translated">템플리트가 정확히 하나의 멤버를 선언하고 해당 멤버가 템플리트와 동일한 이름의 함수 인 경우 함수 템플리트 선언입니다. 또는 함수 템플릿 선언은 &lt;a href=&quot;function#Parameters&quot;&gt;&lt;i&gt;Parameters&lt;/i&gt;&lt;/a&gt; 바로 앞에 &lt;a href=&quot;#TemplateParameterList&quot;&gt;&lt;i&gt;TemplateParameterList&lt;/i&gt;&lt;/a&gt; 가있는 함수 선언입니다 .&lt;i&gt;&lt;/i&gt;</target>
        </trans-unit>
        <trans-unit id="7f02f572072804182d7734d7a928006f6d805f14" translate="yes" xml:space="preserve">
          <source>If a template has a &lt;a href=&quot;#aliasparameters&quot;&gt;template alias parameter&lt;/a&gt;, and is instantiated with a local symbol, the instantiated function will implicitly become nested in order to access runtime data of the given local symbol.</source>
          <target state="translated">템플릿에 &lt;a href=&quot;#aliasparameters&quot;&gt;템플릿 별칭 매개 변수&lt;/a&gt; 가 있고 로컬 심볼로 인스턴스화 된 경우 인스턴스화 된 함수는 내재적으로 중첩되어 지정된 로컬 심볼의 런타임 데이터에 액세스합니다.</target>
        </trans-unit>
        <trans-unit id="996438a9f4c88ad530df79801ff8b03c0e475abe" translate="yes" xml:space="preserve">
          <source>If a template is declared in aggregate or function local scope, the instantiated functions will implicitly capture the context of the enclosing scope.</source>
          <target state="translated">템플릿이 집계 또는 함수 로컬 범위로 선언 된 경우 인스턴스화 된 함수는 내포 범위의 컨텍스트를 암시 적으로 캡처합니다.</target>
        </trans-unit>
        <trans-unit id="449794f5173b1c91e0c8a9e969999efee1d1266f" translate="yes" xml:space="preserve">
          <source>If a variable has a scope destructor call, return call for it. Otherwise, return NULL.</source>
          <target state="translated">변수에 범위 소멸자 호출이 있으면이를 호출하십시오. 그렇지 않으면 NULL을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="e7d0ce5000213342db830246324bf60d4a0dcc21" translate="yes" xml:space="preserve">
          <source>If after all the type arguments are examined, there are any type parameters left with no type assigned, they are assigned types corresponding to the template argument in the same position in the</source>
          <target state="translated">모든 유형 인수를 검사 한 후 유형이 지정되지 않은 유형 매개 변수가 남아있는 경우 템플릿 매개 변수에 해당하는 유형 매개 변수가</target>
        </trans-unit>
        <trans-unit id="8425958e6e0e9a1c94e548c8eed6685e1c97af18" translate="yes" xml:space="preserve">
          <source>If aliased to the same object or both null =&amp;gt; equal</source>
          <target state="translated">같은 객체 또는 둘 다 null =&amp;gt; 같으면 별칭</target>
        </trans-unit>
        <trans-unit id="201815c4325a8fddf0539c89b74ba96e4169f933" translate="yes" xml:space="preserve">
          <source>If an &lt;code&gt;auto&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;auto&lt;/code&gt; 이라면</target>
        </trans-unit>
        <trans-unit id="5aa6bbb7d06b0bd7ec69b77758d95900b4054089" translate="yes" xml:space="preserve">
          <source>If an &lt;code&gt;enum&lt;/code&gt; is used as type, the random variate is drawn with equal probability from any of the possible values of the enum &lt;code&gt;E&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;enum&lt;/code&gt; 이 유형으로 사용되는 경우 임의 변형은 열거 형 &lt;code&gt;E&lt;/code&gt; 의 가능한 값 중 하나와 동일한 확률로 그려집니다 .</target>
        </trans-unit>
        <trans-unit id="168c9f0755c4bd4e21cdb3d96a893ad7470eff57" translate="yes" xml:space="preserve">
          <source>If an aggregate declaration defines an &lt;code&gt;opCmp&lt;/code&gt; or &lt;code&gt;opEquals&lt;/code&gt; method, it will take precedence to that of the aliased this member. Note that, unlike an &lt;code&gt;opCmp&lt;/code&gt; method, an &lt;code&gt;opEquals&lt;/code&gt; method is implicitly defined for a &lt;code&gt;struct&lt;/code&gt; declaration if a user defined one isn't provided; this means that if the aliased this member &lt;code&gt;opEquals&lt;/code&gt; is preferred it should be explicitly defined:</source>
          <target state="translated">집계 선언이 &lt;code&gt;opCmp&lt;/code&gt; 또는 &lt;code&gt;opEquals&lt;/code&gt; 메소드를 정의하는 경우 별명을 가진이 멤버의 메소드보다 우선합니다. &lt;code&gt;opCmp&lt;/code&gt; 메소드 와 달리 , &lt;code&gt;opEquals&lt;/code&gt; 메소드는 사용자 정의 선언이 제공되지 않은 경우 &lt;code&gt;struct&lt;/code&gt; 선언에 대해 암시 적으로 정의 됩니다. 이는 별명으로이 멤버 &lt;code&gt;opEquals&lt;/code&gt; 가 선호되는 경우 명시 적으로 정의되어야 함을 의미합니다 .</target>
        </trans-unit>
        <trans-unit id="2cf56dfdcc6eee095fd25bd060be3e831d6148d4" translate="yes" xml:space="preserve">
          <source>If an append must reallocate a slice with no possibility of extension, then &lt;code&gt;0&lt;/code&gt; is returned. This happens when the slice references a static array, or if another slice references elements past the end of the current slice.</source>
          <target state="translated">추가가 확장 가능성없이 슬라이스를 재 할당해야하는 경우 &lt;code&gt;0&lt;/code&gt; 이 반환됩니다. 슬라이스가 정적 배열을 참조하거나 다른 슬라이스가 현재 슬라이스의 끝을지나 요소를 참조하는 경우에 발생합니다.</target>
        </trans-unit>
        <trans-unit id="fbeff861e7616c530bb5c083257a7ef08f727eef" translate="yes" xml:space="preserve">
          <source>If an application needs to do its own processing of whichever arguments &lt;code&gt;getopt&lt;/code&gt; did not understand, it can pass the &lt;code&gt;std.getopt.config.passThrough&lt;/code&gt; directive to &lt;code&gt;getopt&lt;/code&gt;:</source>
          <target state="translated">애플리케이션이 &lt;code&gt;getopt&lt;/code&gt; 가 이해하지 못한 인수에 대해 자체 처리를 수행 &lt;code&gt;std.getopt.config.passThrough&lt;/code&gt; 경우 std.getopt.config.passThrough 지시문을 &lt;code&gt;getopt&lt;/code&gt; 에 전달할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="eaf53aac4b71af8424769f45a7b82ff0df7d317c" translate="yes" xml:space="preserve">
          <source>If an enum has as a base type one of the types in the left column, it is converted to the type in the right column.</source>
          <target state="translated">열거 형이 기본 유형으로 왼쪽 열의 유형 중 하나 인 경우 오른쪽 열의 유형으로 변환됩니다.</target>
        </trans-unit>
        <trans-unit id="3c064315a80e4366fd87dbfa8b9a5125e74f88b6" translate="yes" xml:space="preserve">
          <source>If an error occurs during the compilation of your program, the use of overloads and overrides needs to be reexamined in the relevant classes.</source>
          <target state="translated">프로그램을 컴파일하는 동안 오류가 발생하면 관련 클래스에서 오버로드 및 재정의 사용을 다시 검토해야합니다.</target>
        </trans-unit>
        <trans-unit id="a2623dd123c39f9f457825f03bd99064fa3431f1" translate="yes" xml:space="preserve">
          <source>If an exception is raised in the</source>
          <target state="translated">에서 예외가 발생하면</target>
        </trans-unit>
        <trans-unit id="180043ac16b1a016937b09456574733627d6647e" translate="yes" xml:space="preserve">
          <source>If an exception is thrown but it has an empty message, then &lt;code&gt;emptyExceptionMsg&lt;/code&gt; is returned.</source>
          <target state="translated">예외가 발생했지만 빈 메시지가 있으면 &lt;code&gt;emptyExceptionMsg&lt;/code&gt; 가 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="eb4162f43906e6c9a7e64e7ecdf711ae4fd96612" translate="yes" xml:space="preserve">
          <source>If an identical type to &lt;code&gt;type&lt;/code&gt; is in &lt;code&gt;type.stringtable&lt;/code&gt;, return the latter one. Otherwise, add it to &lt;code&gt;type.stringtable&lt;/code&gt;. Some types don't get merged and are returned as-is.</source>
          <target state="translated">에 동일한 입력하면 &lt;code&gt;type&lt;/code&gt; 에 &lt;code&gt;type.stringtable&lt;/code&gt; , 후자를 반환한다. 그렇지 않으면 &lt;code&gt;type.stringtable&lt;/code&gt; 에 추가하십시오 . 일부 유형은 병합되지 않고 그대로 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="2efd485ddee09f5b6939ce6531c2909633020004" translate="yes" xml:space="preserve">
          <source>If an identity assignment overload is required and does not exist, an identity assignment overload function of the type &lt;code&gt;ref S opAssign(ref S)&lt;/code&gt; will be automatically generated.</source>
          <target state="translated">ID 할당 과부하가 필요하지만 존재하지 않는 경우 &lt;code&gt;ref S opAssign(ref S)&lt;/code&gt; 유형의 ID 할당 과부하 기능 이 자동으로 생성됩니다.</target>
        </trans-unit>
        <trans-unit id="5e5e3f00360d5b8852208ee3415dc3a1a01f6dc8" translate="yes" xml:space="preserve">
          <source>If an implicit conversion is disallowed by the table, an &lt;a href=&quot;expression#Expression&quot;&gt;&lt;i&gt;Expression&lt;/i&gt;&lt;/a&gt; may be converted if:</source>
          <target state="translated">테이블에서 내재적 변환을 허용하지 않는 경우 다음과 같은 경우 &lt;a href=&quot;expression#Expression&quot;&gt;&lt;i&gt;표현식&lt;/i&gt;&lt;/a&gt; 이 변환 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9520036db9c2c3cb7627c2cb880cb288fe8ee7ee" translate="yes" xml:space="preserve">
          <source>If an index expression can be rewritten using &lt;code&gt;opIndexAssign&lt;/code&gt; or &lt;code&gt;opIndexOpAssign&lt;/code&gt;, those are preferred over &lt;code&gt;opIndex&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;opIndexAssign&lt;/code&gt; 또는 &lt;code&gt;opIndexOpAssign&lt;/code&gt; 을 사용하여 인덱스 표현식을 다시 작성할 수 있으면 opIndex 보다 선호 &lt;code&gt;opIndex&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="74d0247eb6c576e08ded3f7c08dff25cd606da70" translate="yes" xml:space="preserve">
          <source>If an interface has &lt;code&gt;const&lt;/code&gt; or &lt;code&gt;immutable&lt;/code&gt; storage class, then all members of the interface are &lt;code&gt;const&lt;/code&gt; or &lt;code&gt;immutable&lt;/code&gt;. This storage class is not inherited.</source>
          <target state="translated">인터페이스에 &lt;code&gt;const&lt;/code&gt; 또는 &lt;code&gt;immutable&lt;/code&gt; 스토리지 클래스가있는 경우 인터페이스의 모든 멤버는 &lt;code&gt;const&lt;/code&gt; 또는 &lt;code&gt;immutable&lt;/code&gt; 입니다. 이 스토리지 클래스는 상속되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="7e7381c9bb35e9f77c152ce0763035229030f128" translate="yes" xml:space="preserve">
          <source>If an option is bound to a numeric type, a number is expected as the next option, or right within the option separated with an &quot;=&quot; sign:</source>
          <target state="translated">옵션이 숫자 유형에 바인딩 된 경우 숫자는 다음 옵션으로 표시되거나 옵션 내에서 &quot;=&quot;기호로 구분됩니다.</target>
        </trans-unit>
        <trans-unit id="e1388310610be9143f93d5757e5dd370de55e952" translate="yes" xml:space="preserve">
          <source>If an option is bound to a string, a string is expected as the next option, or right within the option separated with an &quot;=&quot; sign:</source>
          <target state="translated">옵션이 문자열에 바인딩 된 경우 다음 옵션으로 문자열이 표시되거나 옵션 내에서 &quot;=&quot;기호로 구분됩니다.</target>
        </trans-unit>
        <trans-unit id="cd9d52ae8827e5578c6e463b4801745d426f4b79" translate="yes" xml:space="preserve">
          <source>If an option is bound to an array, a new element is appended to the array each time the option occurs:</source>
          <target state="translated">옵션이 배열에 바인딩 된 경우 옵션이 발생할 때마다 새 요소가 배열에 추가됩니다.</target>
        </trans-unit>
        <trans-unit id="d7c493c513172131987de31a463653700c8dc123" translate="yes" xml:space="preserve">
          <source>If an option is bound to an associative array, a string of the form &quot;name=value&quot; is expected as the next option, or right within the option separated with an &quot;=&quot; sign:</source>
          <target state="translated">옵션이 연관 배열에 바인드 된 경우, &quot;name = value&quot;형식의 문자열은 다음 옵션으로 예상되거나 옵션 내에서 &quot;=&quot;기호로 구분됩니다.</target>
        </trans-unit>
        <trans-unit id="b6f632caf5c4044e09e5739104d63549a3fc0c34" translate="yes" xml:space="preserve">
          <source>If an option is bound to an enum, an enum symbol as a string is expected as the next option, or right within the option separated with an &quot;=&quot; sign:</source>
          <target state="translated">옵션이 열거 형에 바인딩 된 경우 다음 옵션으로 문자열로 열거 형 기호가 표시되거나 옵션 내에서 &quot;=&quot;기호로 구분됩니다.</target>
        </trans-unit>
        <trans-unit id="7c32990bfc4d36bb0abf0d415d84bd3e023f0845" translate="yes" xml:space="preserve">
          <source>If an option name has a &quot;+&quot; suffix and is bound to a numeric type, then the option's value tracks the number of times the option occurred on the command line:</source>
          <target state="translated">옵션 이름에 &quot;+&quot;접미사가 있고 숫자 유형에 바인딩 된 경우 옵션 값은 명령 행에서 옵션이 발생한 횟수를 추적합니다.</target>
        </trans-unit>
        <trans-unit id="3bc9e305061e747e54d09f33e1d219d952240a58" translate="yes" xml:space="preserve">
          <source>If an option string is followed by another string, this string serves as a description for this option. The &lt;code&gt;getopt&lt;/code&gt; function returns a struct of type &lt;code&gt;GetoptResult&lt;/code&gt;. This return value contains information about all passed options as well a &lt;code&gt;bool GetoptResult.helpWanted&lt;/code&gt; flag indicating whether information about these options was requested. The &lt;code&gt;getopt&lt;/code&gt; function always adds an option for &lt;code&gt;--help|-h&lt;/code&gt; to set the flag if the option is seen on the command line.</source>
          <target state="translated">옵션 문자열 뒤에 다른 문자열이 오는 경우이 문자열은이 옵션에 대한 설명으로 사용됩니다. &lt;code&gt;getopt&lt;/code&gt; 는의 기능은 타입의 구조체를 반환 &lt;code&gt;GetoptResult&lt;/code&gt; 을 . 이 반환 값에는 전달 된 모든 옵션 에 대한 정보와 이러한 옵션에 대한 정보가 요청되었는지 여부를 나타내는 &lt;code&gt;bool GetoptResult.helpWanted&lt;/code&gt; 플래그가 포함됩니다. &lt;code&gt;getopt&lt;/code&gt; 에의 함수는 항상을위한 옵션이 추가 &lt;code&gt;--help|-h&lt;/code&gt; 옵션이 명령 행에서 볼 경우 플래그를 설정합니다.</target>
        </trans-unit>
        <trans-unit id="cecb4b7cfecf63467f6f4623b6ecf01515e03ef4" translate="yes" xml:space="preserve">
          <source>If any &lt;code&gt;TaskPool&lt;/code&gt; with non-daemon threads is active, either &lt;code&gt;stop&lt;/code&gt; or &lt;code&gt;finish&lt;/code&gt; must be called on it before the program can terminate.</source>
          <target state="translated">비 데몬 스레드가 있는 &lt;code&gt;TaskPool&lt;/code&gt; 이 활성화 된 경우 프로그램을 종료하기 전에 &lt;code&gt;stop&lt;/code&gt; 또는 &lt;code&gt;finish&lt;/code&gt; 를 호출해야합니다.</target>
        </trans-unit>
        <trans-unit id="a14ab7622e0f011a987d4940247d86d91424d5c2" translate="yes" xml:space="preserve">
          <source>If any fields have disabled default construction, the struct default construction is also disabled.</source>
          <target state="translated">필드에서 기본 생성을 비활성화 한 경우 struct 기본 생성도 비활성화됩니다.</target>
        </trans-unit>
        <trans-unit id="11956d46948d1d13d7ee53327bbd180ff0d5d12d" translate="yes" xml:space="preserve">
          <source>If any of &lt;code&gt;lead&lt;/code&gt; and &lt;code&gt;vowel&lt;/code&gt; are not a valid hangul jamo of the respective &lt;a href=&quot;#Character&quot;&gt;character&lt;/a&gt; class returns dchar.init.</source>
          <target state="translated">&lt;code&gt;lead&lt;/code&gt; 와 &lt;code&gt;vowel&lt;/code&gt; 중 하나라도 해당 &lt;a href=&quot;#Character&quot;&gt;문자&lt;/a&gt; 클래스 의 유효한 한글 jamo가 아닌 경우 dchar.init를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="643424aa2159c0dc971a85e93b28f54bc425b055" translate="yes" xml:space="preserve">
          <source>If any of the arguments in the &lt;a href=&quot;#ArgumentList&quot;&gt;&lt;i&gt;ArgumentList&lt;/i&gt;&lt;/a&gt; are a</source>
          <target state="translated">&lt;a href=&quot;#ArgumentList&quot;&gt;&lt;i&gt;ArgumentList&lt;/i&gt;&lt;/a&gt; 의 &lt;i&gt;인수&lt;/i&gt; 중 하나가</target>
        </trans-unit>
        <trans-unit id="3744bc315bbcad378bdb3ff87a3b9de7d402fea7" translate="yes" xml:space="preserve">
          <source>If any of the checks fail, a compile error will occur.</source>
          <target state="translated">검사가 실패하면 컴파일 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="def10a047da7cb724c42b1f59da46ab76ef31dc6" translate="yes" xml:space="preserve">
          <source>If any of the keys or values in the</source>
          <target state="translated">키 또는 값이</target>
        </trans-unit>
        <trans-unit id="41bc7edc68b18e54f236d3ac39e824893010bd91" translate="yes" xml:space="preserve">
          <source>If applying the above rules does not result in exactly one type for each template parameter, then it is an error.</source>
          <target state="translated">위의 규칙을 적용해도 각 템플릿 매개 변수에 대해 정확히 하나의 유형이되지 않으면 오류입니다.</target>
        </trans-unit>
        <trans-unit id="a7c844c173ee0a673d9ab2e503851d6c710a834c" translate="yes" xml:space="preserve">
          <source>If assertions are enabled and &lt;code&gt;toRange&lt;/code&gt; has been called, then this WorkerLocalStorage instance is no longer worker-local and an assertion failure will result when calling this method. This is not checked when assertions are disabled for performance reasons.</source>
          <target state="translated">어설 션이 활성화되고 &lt;code&gt;toRange&lt;/code&gt; 가 호출 된 경우이 WorkerLocalStorage 인스턴스는 더 이상 작업자 로컬이 아니므로이 메서드를 호출 할 때 어설 션 오류가 발생합니다. 성능상의 이유로 어설 션이 비활성화 된 경우에는 확인되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="df118ef438600490adb83de4d6beaa35bff251d8" translate="yes" xml:space="preserve">
          <source>If at least one of the ranges is a multiset, then all occurences of a duplicate element are taken into account. The result is equivalent to merging all input ranges and picking the highest &lt;code&gt;tgt.length&lt;/code&gt;, weight-based ranking elements.</source>
          <target state="translated">범위 중 하나 이상이 다중 집합 인 경우 중복 요소의 모든 발생이 고려됩니다. 결과는 모든 입력 범위를 병합하고 가장 높은 &lt;code&gt;tgt.length&lt;/code&gt; 가중치 기반 순위 요소를 선택하는 것과 같습니다 .</target>
        </trans-unit>
        <trans-unit id="4519d0d5950e5356f4f13b61a821ffce61eda0b3" translate="yes" xml:space="preserve">
          <source>If authentication or redirections are done then the status will be for the last response received.</source>
          <target state="translated">인증 또는 리디렉션이 수행되면 마지막으로받은 응답의 상태가됩니다.</target>
        </trans-unit>
        <trans-unit id="0a0246e59acc96ca671df31d602e303fc5a3e9ab" translate="yes" xml:space="preserve">
          <source>If blocking argument is true, wait for all worker threads to terminate before returning. This option might be used in applications where task results are never consumed-- e.g. when &lt;code&gt;TaskPool&lt;/code&gt; is employed as a rudimentary scheduler for tasks which communicate by means other than return values.</source>
          <target state="translated">blocking 인수가 true이면 모든 작업자 스레드가 종료 될 때까지 기다렸다가 반환합니다. 이 옵션은 작업 결과가 절대 사용되지 않는 응용 프로그램에서 사용될 수 있습니다 (예 : &lt;code&gt;TaskPool&lt;/code&gt; 이 반환 값 이외의 수단으로 통신하는 작업의 기초 스케줄러로 사용되는 경우).</target>
        </trans-unit>
        <trans-unit id="7479ca1ded9e48be6a8e038bc9b2488efa665f70" translate="yes" xml:space="preserve">
          <source>If both &lt;code&gt;Primary&lt;/code&gt; and &lt;code&gt;Fallback&lt;/code&gt; are stateless, &lt;code&gt;FallbackAllocator&lt;/code&gt; defines a static instance called &lt;code&gt;instance&lt;/code&gt;.</source>
          <target state="translated">두 경우 &lt;code&gt;Primary&lt;/code&gt; 및 &lt;code&gt;Fallback&lt;/code&gt; 비 상태이며, &lt;code&gt;FallbackAllocator&lt;/code&gt; 는 라는 정적 인스턴스 정의 &lt;code&gt;instance&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9ec43df7b50b565bd7b1219f8c1f3ab8b182ffb2" translate="yes" xml:space="preserve">
          <source>If both &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt; are integers (may be constant-folded), the slice expression can be converted to a static array type &lt;code&gt;T[b - a]&lt;/code&gt;.</source>
          <target state="translated">두 경우 및 &lt;code&gt;b&lt;/code&gt; 는 정수이다 (일정한 절첩 될 수있다), 슬라이스 발현 정적 배열 형식으로 변환 할 수 &lt;code&gt;T[b - a]&lt;/code&gt; . &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="0deff799fed4758452aa1b15f9e2a5541bd46d3e" translate="yes" xml:space="preserve">
          <source>If both a template with a sequence parameter and a template without a sequence parameter exactly match a template instantiation, the template without a</source>
          <target state="translated">시퀀스 매개 변수가있는 템플릿과 시퀀스 매개 변수가없는 템플릿이 모두 템플릿 인스턴스화와 정확히 일치하면</target>
        </trans-unit>
        <trans-unit id="220f653add85effdd5e512619500f4b49743b534" translate="yes" xml:space="preserve">
          <source>If both allocators are &lt;code&gt;shared&lt;/code&gt;, the &lt;code&gt;Segregator&lt;/code&gt; will also offer &lt;code&gt;shared&lt;/code&gt; methods.</source>
          <target state="translated">두 할당자가 모두 &lt;code&gt;shared&lt;/code&gt; 되면 &lt;code&gt;Segregator&lt;/code&gt; 는 &lt;code&gt;shared&lt;/code&gt; 방법 도 제공 합니다.</target>
        </trans-unit>
        <trans-unit id="69639385682c3a994448b82bd2bb7cf46189be9b" translate="yes" xml:space="preserve">
          <source>If both are signed or both are unsigned, the smaller type is converted to the larger.</source>
          <target state="translated">둘 다 부호가 있거나 둘 다 부호가없는 경우 더 작은 유형이 더 큰 유형으로 변환됩니다.</target>
        </trans-unit>
        <trans-unit id="05fb2e935ce549269270c5d42145fc9b4f07b7f4" translate="yes" xml:space="preserve">
          <source>If both are the same type, no more conversions are done.</source>
          <target state="translated">둘 다 동일한 유형이면 더 이상 변환이 수행되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="05dd5c60a4e9b82d4adbecb6f4127f3d732ab860" translate="yes" xml:space="preserve">
          <source>If both arguments are ranges of L-values of the same type then &lt;code&gt;SetSymmetricDifference&lt;/code&gt; will also be a range of L-values of that type.</source>
          <target state="translated">두 인수가 모두 같은 유형의 L 값 범위 인 경우 &lt;code&gt;SetSymmetricDifference&lt;/code&gt; 도 해당 유형의 L 값 범위가됩니다.</target>
        </trans-unit>
        <trans-unit id="a1166af836d0ff22ec8996cf90c0ca104ddf9187" translate="yes" xml:space="preserve">
          <source>If both operands are of integral types and an overflow or underflow occurs in the computation, wrapping will happen. That is, &lt;code&gt;uint.max + 1 == uint.min&lt;/code&gt; and &lt;code&gt;uint.min - 1 == uint.max&lt;/code&gt;.</source>
          <target state="translated">두 피연산자가 모두 정수 유형이고 계산에서 오버플로 또는 언더 플로가 발생하면 줄 바꿈이 발생합니다. 즉, &lt;code&gt;uint.max + 1 == uint.min&lt;/code&gt; 및 &lt;code&gt;uint.min - 1 == uint.max&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="88c921254e07ee3d3550bb0c4328e00c73dbba70" translate="yes" xml:space="preserve">
          <source>If both operands are pointers, and the operator is &lt;code&gt;+&lt;/code&gt;, then it is illegal.</source>
          <target state="translated">두 피연산자가 모두 포인터이고 연산자가 &lt;code&gt;+&lt;/code&gt; 인 경우 잘못된 것입니다.</target>
        </trans-unit>
        <trans-unit id="d175863c948db7d84910700658bc03bfa12bed2a" translate="yes" xml:space="preserve">
          <source>If both operands are pointers, and the operator is &lt;code&gt;-&lt;/code&gt;, the pointers are subtracted and the result is divided by the size of the type pointed to by the operands. In this calculation the assumed size of &lt;code&gt;void&lt;/code&gt; is one byte. It is an error if the pointers point to different types. The type of the result is &lt;code&gt;ptrdiff_t&lt;/code&gt;.</source>
          <target state="translated">두 피연산자가 모두 포인터이고 연산자가 &lt;code&gt;-&lt;/code&gt; 인 경우 포인터는 빼고 결과는 피연산자가 가리키는 유형의 크기로 나뉩니다. 이 계산에서 &lt;code&gt;void&lt;/code&gt; 의 가정 된 크기 는 1 바이트입니다. 포인터가 다른 유형을 가리키는 경우 오류입니다. 결과 유형은 &lt;code&gt;ptrdiff_t&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="d1abf720abea123f60d5888992d6209534bf4e09" translate="yes" xml:space="preserve">
          <source>If both ranges are finite, then one must be (at least) a &lt;a href=&quot;std_range_primitives#isForwardRange&quot;&gt;forward range&lt;/a&gt; and the other an &lt;a href=&quot;std_range_primitives#isInputRange&quot;&gt;input range&lt;/a&gt;.</source>
          <target state="translated">두 범위가 모두 유한 한 경우 하나는 &lt;a href=&quot;std_range_primitives#isForwardRange&quot;&gt;전방 범위&lt;/a&gt; 이고 다른 하나는 &lt;a href=&quot;std_range_primitives#isInputRange&quot;&gt;입력 범위&lt;/a&gt; 여야합니다 .</target>
        </trans-unit>
        <trans-unit id="cb5178f6f33c9b3fe021f6007cd182ded54b74f7" translate="yes" xml:space="preserve">
          <source>If both ranges are infinite, then both must be forward ranges.</source>
          <target state="translated">두 범위가 모두 무한대이면 모두 전방 범위 여야합니다.</target>
        </trans-unit>
        <trans-unit id="09621590d3975cfd09fe2c0811ba26754a5cdd9d" translate="yes" xml:space="preserve">
          <source>If both ranges are sets (without duplicated elements), the resulting range is going to be a set. If at least one of the ranges is a multiset, the number of occurences of an element &lt;code&gt;x&lt;/code&gt; in the resulting range is &lt;code&gt;abs(a-b)&lt;/code&gt; where &lt;code&gt;a&lt;/code&gt; is the number of occurences of &lt;code&gt;x&lt;/code&gt; in &lt;code&gt;r1&lt;/code&gt;, &lt;code&gt;b&lt;/code&gt; is the number of occurences of &lt;code&gt;x&lt;/code&gt; in &lt;code&gt;r2&lt;/code&gt;, and &lt;code&gt;abs&lt;/code&gt; is the absolute value.</source>
          <target state="translated">두 범위가 모두 설정되면 (중복 요소 없음) 결과 범위가 설정됩니다. 범위 중 적어도 하나는 멀티 세트 인 경우, 소자의 발행 수의 수 &lt;code&gt;x&lt;/code&gt; 얻어진 범위 인 &lt;code&gt;abs(a-b)&lt;/code&gt; &lt;code&gt;a&lt;/code&gt; 의 발행 수의 개수 &lt;code&gt;x&lt;/code&gt; 의 &lt;code&gt;r1&lt;/code&gt; , &lt;code&gt;b&lt;/code&gt; 의 발행 수의 수이고 &lt;code&gt;x&lt;/code&gt; 의 &lt;code&gt;r2&lt;/code&gt; 및 &lt;code&gt;abs&lt;/code&gt; 절대 값이다.</target>
        </trans-unit>
        <trans-unit id="c3cd520fd113fc0ea9747b7e4b22c4c42d0b39c5" translate="yes" xml:space="preserve">
          <source>If both ranges have a length member, this function is &amp;Omicron;(&lt;code&gt;1&lt;/code&gt;). Otherwise, this function is &amp;Omicron;(&lt;code&gt;min(r1.length, r2.length)&lt;/code&gt;).</source>
          <target state="translated">두 범위 모두 길이 멤버가있는 경우이 함수는 &amp;Omicron; ( &lt;code&gt;1&lt;/code&gt; )입니다. 그렇지 않으면이 함수는 &amp;Omicron; ( &lt;code&gt;min(r1.length, r2.length)&lt;/code&gt; )입니다.</target>
        </trans-unit>
        <trans-unit id="077a8fbc08834027e3db2ad54352fdf64c6364ae" translate="yes" xml:space="preserve">
          <source>If both x and n are 0, the result is 1. If n is negative, an integer divide error will occur at runtime, regardless of the value of x.</source>
          <target state="translated">x와 n이 모두 0이면 결과는 1입니다. n이 음수이면 x 값에 관계없이 런타임에 정수 나누기 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="d8d58e2935a54be899c1932e2430b1d836d6854b" translate="yes" xml:space="preserve">
          <source>If break is followed by</source>
          <target state="translated">break 다음에</target>
        </trans-unit>
        <trans-unit id="133ff22691958b87ce955cf38fc2654641e5c95a" translate="yes" xml:space="preserve">
          <source>If class invariant checking is turned on, the class invariant is called at the end of the constructor.</source>
          <target state="translated">클래스 불변 검사가 설정되어 있으면 생성자 끝에서 클래스 불변이 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="2873dd219021490e067fcdc56ae6ce69a60f4696" translate="yes" xml:space="preserve">
          <source>If code detects an error like &quot;out of memory,&quot; then an Error is thrown with a message saying &quot;Out of memory&quot;. The function call stack is unwound, looking for a handler for the Error. &lt;a href=&quot;statement#TryStatement&quot;&gt;Finally blocks&lt;/a&gt; are executed as the stack is unwound. If an error handler is found, execution resumes there. If not, the default Error handler is run, which displays the message and terminates the program.</source>
          <target state="translated">코드가 &quot;메모리 부족&quot;과 같은 오류를 감지하면 &quot;메모리 부족&quot;이라는 메시지와 함께 오류가 발생합니다. 함수 호출 스택이 풀리고 오류에 대한 핸들러를 찾습니다. &lt;a href=&quot;statement#TryStatement&quot;&gt;마지막으로&lt;/a&gt; 스택이 풀릴 때 블록 이 실행됩니다. 오류 처리기가 발견되면 실행이 다시 시작됩니다. 그렇지 않으면 기본 오류 핸들러가 실행되어 메시지를 표시하고 프로그램을 종료합니다.</target>
        </trans-unit>
        <trans-unit id="026a3ed1741bfc55e99518c871b70d4250291a91" translate="yes" xml:space="preserve">
          <source>If continue is followed by</source>
          <target state="translated">계속이 이어지면</target>
        </trans-unit>
        <trans-unit id="6422eca509193d7e5c40c75cbc0a1df0e38709f1" translate="yes" xml:space="preserve">
          <source>If defined and &lt;code&gt;hookOpCast&lt;/code&gt; is</source>
          <target state="translated">정의되고 &lt;code&gt;hookOpCast&lt;/code&gt; 가</target>
        </trans-unit>
        <trans-unit id="5a7e95bb168b15f4a8bcb2b5cf99f8ea675a9dca" translate="yes" xml:space="preserve">
          <source>If defined, &lt;code&gt;Hook.defaultValue!T&lt;/code&gt; is used as the default initializer of the payload.</source>
          <target state="translated">정의 된 경우 &lt;code&gt;Hook.defaultValue!T&lt;/code&gt; 가 페이로드의 기본 이니셜 라이저로 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="03019d524f44be31cdffd6208c1acffd47d8953d" translate="yes" xml:space="preserve">
          <source>If defined, &lt;code&gt;Hook.max!T&lt;/code&gt; is used as the maximum value of the payload.</source>
          <target state="translated">정의 된 경우 &lt;code&gt;Hook.max!T&lt;/code&gt; 가 페이로드의 최대 값으로 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="f5bf55bfa3966b60e1868595f8913387e32b50a0" translate="yes" xml:space="preserve">
          <source>If defined, &lt;code&gt;Hook.min!T&lt;/code&gt; is used as the minimum value of the payload.</source>
          <target state="translated">정의 된 경우 &lt;code&gt;Hook.min!T&lt;/code&gt; 가 페이로드의 최소값으로 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="c860109476dd6e83e225430bc70cc535b0742b87" translate="yes" xml:space="preserve">
          <source>If defined, &lt;code&gt;hook.hookOpBinary!op(get, rhs)&lt;/code&gt; (where &lt;code&gt;op&lt;/code&gt; is the operator symbol and &lt;code&gt;rhs&lt;/code&gt; is the right-hand side operand) is forwarded to unconditionally for binary operators &lt;code&gt;+&lt;/code&gt;, &lt;code&gt;-&lt;/code&gt;, &lt;code&gt;*&lt;/code&gt;, &lt;code&gt;/&lt;/code&gt;, &lt;code&gt;%&lt;/code&gt;, &lt;code&gt;^^&lt;/code&gt;, &lt;code&gt;&amp;amp;&lt;/code&gt;, &lt;code&gt;|&lt;/code&gt;, &lt;code&gt;^&lt;/code&gt;, &lt;code&gt;&amp;lt;&amp;lt;&lt;/code&gt;, &lt;code&gt;&amp;gt;&amp;gt;&lt;/code&gt;, and &lt;code&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">정의 된 경우 &lt;code&gt;hook.hookOpBinary!op(get, rhs)&lt;/code&gt; (여기서 &lt;code&gt;op&lt;/code&gt; 는 연산자 기호이고 &lt;code&gt;rhs&lt;/code&gt; 는 오른쪽 피연산자 임)는 이항 연산자 &lt;code&gt;+&lt;/code&gt; , &lt;code&gt;-&lt;/code&gt; , &lt;code&gt;*&lt;/code&gt; , &lt;code&gt;/&lt;/code&gt; , &lt;code&gt;%&lt;/code&gt; , &lt;code&gt;^^&lt;/code&gt; 에 무조건 전달됩니다 . &lt;code&gt;&amp;amp;&lt;/code&gt; , &lt;code&gt;|&lt;/code&gt; , &lt;code&gt;^&lt;/code&gt; , &lt;code&gt;&amp;lt;&amp;lt;&lt;/code&gt; , &lt;code&gt;&amp;gt;&amp;gt;&lt;/code&gt; 및 &lt;code&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="22acb3135b0d52c02522e9bda0aa4a9ab72a1f15" translate="yes" xml:space="preserve">
          <source>If defined, &lt;code&gt;hook.hookOpBinaryRight!op(lhs, get)&lt;/code&gt; (where &lt;code&gt;op&lt;/code&gt; is the operator symbol and &lt;code&gt;lhs&lt;/code&gt; is the left-hand side operand) is forwarded to unconditionally for binary operators &lt;code&gt;+&lt;/code&gt;, &lt;code&gt;-&lt;/code&gt;, &lt;code&gt;*&lt;/code&gt;, &lt;code&gt;/&lt;/code&gt;, &lt;code&gt;%&lt;/code&gt;, &lt;code&gt;^^&lt;/code&gt;, &lt;code&gt;&amp;amp;&lt;/code&gt;, &lt;code&gt;|&lt;/code&gt;, &lt;code&gt;^&lt;/code&gt;, &lt;code&gt;&amp;lt;&amp;lt;&lt;/code&gt;, &lt;code&gt;&amp;gt;&amp;gt;&lt;/code&gt;, and &lt;code&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">정의 된 경우 &lt;code&gt;hook.hookOpBinaryRight!op(lhs, get)&lt;/code&gt; (여기서 &lt;code&gt;op&lt;/code&gt; 는 연산자 기호이고 &lt;code&gt;lhs&lt;/code&gt; 는 왼쪽 피연산자 임)는 이진 연산자 &lt;code&gt;+&lt;/code&gt; , &lt;code&gt;-&lt;/code&gt; , &lt;code&gt;*&lt;/code&gt; , &lt;code&gt;/&lt;/code&gt; , &lt;code&gt;%&lt;/code&gt; , &lt;code&gt;^^&lt;/code&gt; 에 무조건 전달됩니다 . &lt;code&gt;&amp;amp;&lt;/code&gt; , &lt;code&gt;|&lt;/code&gt; , &lt;code&gt;^&lt;/code&gt; , &lt;code&gt;&amp;lt;&amp;lt;&lt;/code&gt; , &lt;code&gt;&amp;gt;&amp;gt;&lt;/code&gt; 및 &lt;code&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="22f903c768577a0e387a7661822b3ab6e9ea3a27" translate="yes" xml:space="preserve">
          <source>If defined, &lt;code&gt;hook.hookOpCast!U(get)&lt;/code&gt; is forwarded to unconditionally when the payload is to be cast to type &lt;code&gt;U&lt;/code&gt;.</source>
          <target state="translated">정의 된 경우, payload가 &lt;code&gt;U&lt;/code&gt; 유형으로 캐스트 될 때 &lt;code&gt;hook.hookOpCast!U(get)&lt;/code&gt; 이 무조건 전달됩니다 .</target>
        </trans-unit>
        <trans-unit id="d39d077b66c222df35757287877d0f5e2f125e3c" translate="yes" xml:space="preserve">
          <source>If defined, &lt;code&gt;hook.hookOpCmp(get, rhs)&lt;/code&gt; is forwarded to unconditionally when the payload is compared for ordering against value &lt;code&gt;rhs&lt;/code&gt; of integral, floating point, or Boolean type.</source>
          <target state="translated">정의 경우, &lt;code&gt;hook.hookOpCmp(get, rhs)&lt;/code&gt; 페이로드는 값에 대한 순서를 비교한다 무조건 때 전달됩니다 &lt;code&gt;rhs&lt;/code&gt; 적분, 부동 소수점 또는 부울 유형입니다.</target>
        </trans-unit>
        <trans-unit id="61710dc38aff3803efddd69b40c8a0d534e524ab" translate="yes" xml:space="preserve">
          <source>If defined, &lt;code&gt;hook.hookOpEquals(get, rhs)&lt;/code&gt; is forwarded to unconditionally when the payload is compared for equality against value &lt;code&gt;rhs&lt;/code&gt; of integral, floating point, or Boolean type.</source>
          <target state="translated">정의 된 경우, payload가 정수, 부동 소수점 또는 부울 유형의 값 &lt;code&gt;rhs&lt;/code&gt; 와 동일한 지 비교할 때 &lt;code&gt;hook.hookOpEquals(get, rhs)&lt;/code&gt; 가 무조건 전달됩니다 .</target>
        </trans-unit>
        <trans-unit id="78db295a6db30c78e28bbcb362075d3be4e0b84f" translate="yes" xml:space="preserve">
          <source>If defined, &lt;code&gt;hook.hookOpOpAssign!op(payload, rhs)&lt;/code&gt; (where &lt;code&gt;op&lt;/code&gt; is the operator symbol and &lt;code&gt;rhs&lt;/code&gt; is the right-hand side operand) is forwarded to unconditionally for binary operators &lt;code&gt;+=&lt;/code&gt;, &lt;code&gt;-=&lt;/code&gt;, &lt;code&gt;*=&lt;/code&gt;, &lt;code&gt;/=&lt;/code&gt;, &lt;code&gt;%=&lt;/code&gt;, &lt;code&gt;^^=&lt;/code&gt;, &lt;code&gt;&amp;amp;=&lt;/code&gt;, &lt;code&gt;|=&lt;/code&gt;, &lt;code&gt;^=&lt;/code&gt;, &lt;code&gt;&amp;lt;&amp;lt;=&lt;/code&gt;, &lt;code&gt;&amp;gt;&amp;gt;=&lt;/code&gt;, and &lt;code&gt;&amp;gt;&amp;gt;&amp;gt;=&lt;/code&gt;.</source>
          <target state="translated">정의 된 경우 &lt;code&gt;hook.hookOpOpAssign!op(payload, rhs)&lt;/code&gt; (여기서 &lt;code&gt;op&lt;/code&gt; 는 연산자 기호이고 &lt;code&gt;rhs&lt;/code&gt; 는 오른쪽 피연산자 임)는 2 진 연산자 &lt;code&gt;+=&lt;/code&gt; , &lt;code&gt;-=&lt;/code&gt; , &lt;code&gt;*=&lt;/code&gt; , &lt;code&gt;/=&lt;/code&gt; , &lt;code&gt;%=&lt;/code&gt; 에 무조건 전달됩니다. = , &lt;code&gt;^^=&lt;/code&gt; , &lt;code&gt;&amp;amp;=&lt;/code&gt; , &lt;code&gt;|=&lt;/code&gt; , &lt;code&gt;^=&lt;/code&gt; , &lt;code&gt;&amp;lt;&amp;lt;=&lt;/code&gt; , &lt;code&gt;&amp;gt;&amp;gt;=&lt;/code&gt; 및 &lt;code&gt;&amp;gt;&amp;gt;&amp;gt;=&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="52c14604f1c472b8a4a8bbea3e846c210307c64e" translate="yes" xml:space="preserve">
          <source>If defined, &lt;code&gt;hook.hookOpUnary!op(get)&lt;/code&gt; (where &lt;code&gt;op&lt;/code&gt; is the operator symbol) is forwarded to for unary operators &lt;code&gt;-&lt;/code&gt; and &lt;code&gt;~&lt;/code&gt;. In addition, for unary operators &lt;code&gt;++&lt;/code&gt; and &lt;code&gt;--&lt;/code&gt;, &lt;code&gt;hook.hookOpUnary!op(payload)&lt;/code&gt; is called, where &lt;code&gt;payload&lt;/code&gt; is a reference to the value wrapped by &lt;code&gt;Checked&lt;/code&gt; so the hook can change it.</source>
          <target state="translated">정의 경우 &lt;code&gt;hook.hookOpUnary!op(get)&lt;/code&gt; (여기서 &lt;code&gt;op&lt;/code&gt; 운영자의 상징이다) 단항 연산자에 대한 전달됩니다 &lt;code&gt;-&lt;/code&gt; 와 &lt;code&gt;~&lt;/code&gt; . 또한 단항 연산자 &lt;code&gt;++&lt;/code&gt; 및 &lt;code&gt;--&lt;/code&gt; 경우 &lt;code&gt;hook.hookOpUnary!op(payload)&lt;/code&gt; 가 호출됩니다. 여기서 &lt;code&gt;payload&lt;/code&gt; 는 &lt;code&gt;Checked&lt;/code&gt; 로 래핑 된 값에 대한 참조 이므로 후크가이를 변경할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2297e50d0b2beb4cdd48e76ba56a839dcb04ab78" translate="yes" xml:space="preserve">
          <source>If defined, &lt;code&gt;hook.hookToHash(payload)&lt;/code&gt; (where &lt;code&gt;payload&lt;/code&gt; is a reference to the value wrapped by Checked) is forwarded to when &lt;code&gt;toHash&lt;/code&gt; is called on a Checked type. Custom hashing can be implemented in a &lt;code&gt;Hook&lt;/code&gt;, otherwise the built-in hashing is used.</source>
          <target state="translated">정의 된 경우, &lt;code&gt;hook.hookToHash(payload)&lt;/code&gt; ( &lt;code&gt;payload&lt;/code&gt; 는 Checked에 의해 랩핑 된 값에 대한 참조 임)는 &lt;code&gt;toHash&lt;/code&gt; 가 Checked 유형에서 호출 될 때 전달됩니다 . 사용자 정의 해싱은 &lt;code&gt;Hook&lt;/code&gt; 에서 구현 될 수 있으며 , 그렇지 않으면 내장 해싱이 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="33310de24a417af9692c142b1ec271b4bb06c9e6" translate="yes" xml:space="preserve">
          <source>If defined, &lt;code&gt;hook.onLowerBound(value, bound)&lt;/code&gt; (where &lt;code&gt;value&lt;/code&gt; is the value being assigned) is forwarded to when the result of binary operators &lt;code&gt;+=&lt;/code&gt;, &lt;code&gt;-=&lt;/code&gt;, &lt;code&gt;*=&lt;/code&gt;, &lt;code&gt;/=&lt;/code&gt;, &lt;code&gt;%=&lt;/code&gt;, &lt;code&gt;^^=&lt;/code&gt;, &lt;code&gt;&amp;amp;=&lt;/code&gt;, &lt;code&gt;|=&lt;/code&gt;, &lt;code&gt;^=&lt;/code&gt;, &lt;code&gt;&amp;lt;&amp;lt;=&lt;/code&gt;, &lt;code&gt;&amp;gt;&amp;gt;=&lt;/code&gt;, and &lt;code&gt;&amp;gt;&amp;gt;&amp;gt;=&lt;/code&gt; is smaller than the smallest value representable by &lt;code&gt;T&lt;/code&gt;.</source>
          <target state="translated">정의하면 &lt;code&gt;hook.onLowerBound(value, bound)&lt;/code&gt; (단, &lt;code&gt;value&lt;/code&gt; 때 이진 연산자의 결과로 전달되는 값이 할당되는) &lt;code&gt;+=&lt;/code&gt; , &lt;code&gt;-=&lt;/code&gt; , &lt;code&gt;*=&lt;/code&gt; , &lt;code&gt;/=&lt;/code&gt; , &lt;code&gt;%=&lt;/code&gt; , &lt;code&gt;^^=&lt;/code&gt; , &lt;code&gt;&amp;amp;=&lt;/code&gt; , &lt;code&gt;|=&lt;/code&gt; , &lt;code&gt;^=&lt;/code&gt; , &lt;code&gt;&amp;lt;&amp;lt;=&lt;/code&gt; , &lt;code&gt;&amp;gt;&amp;gt;=&lt;/code&gt; 및 &lt;code&gt;&amp;gt;&amp;gt;&amp;gt;=&lt;/code&gt; 은 &lt;code&gt;T&lt;/code&gt; 로 표시 할 수있는 가장 작은 값보다 작습니다 .</target>
        </trans-unit>
        <trans-unit id="ab6931e0e7ba4cd85c003adc62fe48bb16dad0a7" translate="yes" xml:space="preserve">
          <source>If defined, &lt;code&gt;hook.onOverflow!op(get)&lt;/code&gt; is forwarded to for unary operators that overflow but only if &lt;code&gt;hookOpUnary&lt;/code&gt; is not defined. Unary &lt;code&gt;~&lt;/code&gt; does not overflow; unary &lt;code&gt;-&lt;/code&gt; overflows only when the most negative value of a signed type is negated, and the result of the hook call is returned. When the increment or decrement operators overflow, the payload is assigned the result of &lt;code&gt;hook.onOverflow!op(get)&lt;/code&gt;. When a binary operator overflows, the result of &lt;code&gt;hook.onOverflow!op(get, rhs)&lt;/code&gt; is returned, but only if &lt;code&gt;Hook&lt;/code&gt; does not define &lt;code&gt;hookOpBinary&lt;/code&gt;.</source>
          <target state="translated">정의 된 경우 &lt;code&gt;hook.onOverflow!op(get)&lt;/code&gt; 은 오버플로되는 단항 연산자에 대해 전달되지만 &lt;code&gt;hookOpUnary&lt;/code&gt; 가 정의되지 않은 경우에만 전달 됩니다. 단항 &lt;code&gt;~&lt;/code&gt; 오버플로하지 않습니다; 단항 &lt;code&gt;-&lt;/code&gt; 부호있는 유형의 가장 음수 값이 무시되고 후크 호출 결과가 리턴되는 경우에만 오버 플로우됩니다. 증가 또는 감소 연산자가 오버 플로우되면 페이로드에 &lt;code&gt;hook.onOverflow!op(get)&lt;/code&gt; 의 결과가 할당됩니다 . 이진 연산자가 오버플로되면 &lt;code&gt;hook.onOverflow!op(get, rhs)&lt;/code&gt; 의 결과 가 반환되지만 &lt;code&gt;Hook&lt;/code&gt; 가 &lt;code&gt;hookOpBinary&lt;/code&gt; 를 정의하지 않은 경우에만 반환됩니다 .</target>
        </trans-unit>
        <trans-unit id="908a2f8c24579c24ba178c54fd857b4b41ae78ef" translate="yes" xml:space="preserve">
          <source>If defined, &lt;code&gt;hook.onUpperBound(value, bound)&lt;/code&gt; (where &lt;code&gt;value&lt;/code&gt; is the value being assigned) is forwarded to when the result of binary operators &lt;code&gt;+=&lt;/code&gt;, &lt;code&gt;-=&lt;/code&gt;, &lt;code&gt;*=&lt;/code&gt;, &lt;code&gt;/=&lt;/code&gt;, &lt;code&gt;%=&lt;/code&gt;, &lt;code&gt;^^=&lt;/code&gt;, &lt;code&gt;&amp;amp;=&lt;/code&gt;, &lt;code&gt;|=&lt;/code&gt;, &lt;code&gt;^=&lt;/code&gt;, &lt;code&gt;&amp;lt;&amp;lt;=&lt;/code&gt;, &lt;code&gt;&amp;gt;&amp;gt;=&lt;/code&gt;, and &lt;code&gt;&amp;gt;&amp;gt;&amp;gt;=&lt;/code&gt; is larger than the largest value representable by &lt;code&gt;T&lt;/code&gt;.</source>
          <target state="translated">정의하면 &lt;code&gt;hook.onUpperBound(value, bound)&lt;/code&gt; (단, &lt;code&gt;value&lt;/code&gt; 때 이진 연산자의 결과로 전달되는 값이 할당되는) &lt;code&gt;+=&lt;/code&gt; , &lt;code&gt;-=&lt;/code&gt; , &lt;code&gt;*=&lt;/code&gt; , &lt;code&gt;/=&lt;/code&gt; , &lt;code&gt;%=&lt;/code&gt; , &lt;code&gt;^^=&lt;/code&gt; , &lt;code&gt;&amp;amp;=&lt;/code&gt; , &lt;code&gt;|=&lt;/code&gt; , &lt;code&gt;^=&lt;/code&gt; , &lt;code&gt;&amp;lt;&amp;lt;=&lt;/code&gt; , &lt;code&gt;&amp;gt;&amp;gt;=&lt;/code&gt; 및 &lt;code&gt;&amp;gt;&amp;gt;&amp;gt;=&lt;/code&gt; 은 &lt;code&gt;T&lt;/code&gt; 로 표시 할 수있는 가장 큰 값보다 큽니다 .</target>
        </trans-unit>
        <trans-unit id="4d3755f1788c95f9d9709ea3791ec92f2804e77a" translate="yes" xml:space="preserve">
          <source>If e is a SliceExp, constant fold it.</source>
          <target state="translated">e가 SliceExp이면 일정하게 접습니다.</target>
        </trans-unit>
        <trans-unit id="4e157bdef2847bcd47c86d8616eb969d0de41200" translate="yes" xml:space="preserve">
          <source>If e1 is a property function (template), resolve it.</source>
          <target state="translated">e1이 특성 함수 (서식 파일) 인 경우 해결하십시오.</target>
        </trans-unit>
        <trans-unit id="fe36cf6a431bba3d0f0866cfcc1c8bfbdb70659d" translate="yes" xml:space="preserve">
          <source>If either is null =&amp;gt; non-equal</source>
          <target state="translated">둘 중 하나가 null =&amp;gt; 같지 않은 경우</target>
        </trans-unit>
        <trans-unit id="51547fe82011becc25f7663a54c1c79b37b3b626" translate="yes" xml:space="preserve">
          <source>If either operand is &lt;code&gt;real&lt;/code&gt;, the other operand is converted to &lt;code&gt;real&lt;/code&gt;.</source>
          <target state="translated">피연산자 중 하나가 &lt;code&gt;real&lt;/code&gt; 인 경우 다른 피연산자는 &lt;code&gt;real&lt;/code&gt; 로 변환됩니다 .</target>
        </trans-unit>
        <trans-unit id="2c828619435ec0d80d0eb291888f4070be2665b9" translate="yes" xml:space="preserve">
          <source>If either operand is a floating point type, the other is implicitly converted to floating point and they are brought to a common type via the &lt;a href=&quot;type#usual-arithmetic-conversions&quot;&gt;Usual Arithmetic Conversions&lt;/a&gt;.</source>
          <target state="translated">피연산자 중 하나가 부동 소수점 유형 인 경우, 다른 피연산자는 내재적으로 부동 소수점으로 변환되고 &lt;a href=&quot;type#usual-arithmetic-conversions&quot;&gt;일반적인 산술 변환을&lt;/a&gt; 통해 공통 유형으로 가져옵니다 .</target>
        </trans-unit>
        <trans-unit id="19204c26120415c2143a5e03cf2be7f558db1190" translate="yes" xml:space="preserve">
          <source>If either the second or third expressions are of type &lt;code&gt;void&lt;/code&gt;, then the resulting type is &lt;code&gt;void&lt;/code&gt;. Otherwise, the second and third expressions are implicitly converted to a common type which becomes the result type of the conditional expression.</source>
          <target state="translated">두 번째 또는 세 번째 표현식이 &lt;code&gt;void&lt;/code&gt; 유형 인 경우 결과 유형은 &lt;code&gt;void&lt;/code&gt; 입니다. 그렇지 않으면, 두 번째 및 세 번째 표현식이 내재적으로 공통 유형으로 변환되어 조건식의 결과 유형이됩니다.</target>
        </trans-unit>
        <trans-unit id="653d0a49e3e776a2dacb4a126f5f7199b157c776" translate="yes" xml:space="preserve">
          <source>If expression can be tested for true or false, returns the modified expression. Otherwise returns ErrorExp.</source>
          <target state="translated">expression을 true 또는 false로 테스트 할 수 있으면 수정 된 표현식을 리턴합니다. 그렇지 않으면 ErrorExp를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="b36e87ad6619937152cb1864f5c28a8d82857aaf" translate="yes" xml:space="preserve">
          <source>If expression is shared, check that we can access it. Give error message if not.</source>
          <target state="translated">expression이 공유되면 액세스 할 수 있는지 확인하십시오. 그렇지 않은 경우 오류 메시지를 제공하십시오.</target>
        </trans-unit>
        <trans-unit id="b903eb11d9ca574de1d125b6a0ddd43ec7f26143" translate="yes" xml:space="preserve">
          <source>If flag &lt;code&gt;KeepTerminator&lt;/code&gt; is set to &lt;code&gt;KeepTerminator.yes&lt;/code&gt;, then the delimiter is included in the strings returned.</source>
          <target state="translated">플래그 경우 &lt;code&gt;KeepTerminator&lt;/code&gt; 이 설정되어 &lt;code&gt;KeepTerminator.yes&lt;/code&gt; , 다음 구분 기호 반환 된 문자열에 포함되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="235b8759d68e4d6c00eac4cd7371849cd3084978" translate="yes" xml:space="preserve">
          <source>If found, return list entry that it is, else null.</source>
          <target state="translated">발견되면 목록 항목을 리턴하고 그렇지 않으면 널을 리턴하십시오.</target>
        </trans-unit>
        <trans-unit id="a226618dbb0d64b00416429ba20f88cb6f590b46" translate="yes" xml:space="preserve">
          <source>If func ever generates a time point greater than or equal to the current &lt;code&gt;front&lt;/code&gt; of the range, then a &lt;a href=&quot;std_datetime_date#DateTimeException&quot;&gt;&lt;code&gt;std.datetime.date.DateTimeException&lt;/code&gt;&lt;/a&gt; will be thrown.</source>
          <target state="translated">FUNC 적 시점보다 크거나 동일한 전류 생성하면 &lt;code&gt;front&lt;/code&gt; 범위를 다음 &lt;a href=&quot;std_datetime_date#DateTimeException&quot;&gt; &lt;code&gt;std.datetime.date.DateTimeException&lt;/code&gt; 가&lt;/a&gt; 발생한다.</target>
        </trans-unit>
        <trans-unit id="6bcd1b67b2b6132e6574059a063d80b5509091a8" translate="yes" xml:space="preserve">
          <source>If func ever generates a time point greater than or equal to the current &lt;code&gt;front&lt;/code&gt; of the range, then a &lt;a href=&quot;std_datetime_date#DateTimeException&quot;&gt;&lt;code&gt;std.datetime.date.DateTimeException&lt;/code&gt;&lt;/a&gt; will be thrown. The range will be empty and iteration complete when func generates a time point equal to or less than the &lt;code&gt;begin&lt;/code&gt; of the interval.</source>
          <target state="translated">FUNC 적 시점보다 크거나 동일한 전류 생성하면 &lt;code&gt;front&lt;/code&gt; 범위를 다음 &lt;a href=&quot;std_datetime_date#DateTimeException&quot;&gt; &lt;code&gt;std.datetime.date.DateTimeException&lt;/code&gt; 가&lt;/a&gt; 발생한다. func 이 간격 &lt;code&gt;begin&lt;/code&gt; 과 같거나 적은 시점을 생성하면 범위가 비어 있고 반복이 완료됩니다 .</target>
        </trans-unit>
        <trans-unit id="eefd5cc7fe1ca2c7b897d183dc4a05399326e46f" translate="yes" xml:space="preserve">
          <source>If func ever generates a time point less than or equal to the current &lt;code&gt;front&lt;/code&gt; of the range, then a &lt;a href=&quot;std_datetime_date#DateTimeException&quot;&gt;&lt;code&gt;std.datetime.date.DateTimeException&lt;/code&gt;&lt;/a&gt; will be thrown.</source>
          <target state="translated">func이 현재 범위 의 현재 &lt;code&gt;front&lt;/code&gt; 보다 작거나 같은 시점을 생성 하면 &lt;a href=&quot;std_datetime_date#DateTimeException&quot;&gt; &lt;code&gt;std.datetime.date.DateTimeException&lt;/code&gt; &lt;/a&gt; 이 발생합니다.</target>
        </trans-unit>
        <trans-unit id="c66509b1e052bea9e9d5481b7761f6c20d3b371f" translate="yes" xml:space="preserve">
          <source>If func ever generates a time point less than or equal to the current &lt;code&gt;front&lt;/code&gt; of the range, then a &lt;a href=&quot;std_datetime_date#DateTimeException&quot;&gt;&lt;code&gt;std.datetime.date.DateTimeException&lt;/code&gt;&lt;/a&gt; will be thrown. The range will be empty and iteration complete when func generates a time point equal to or beyond the &lt;code&gt;end&lt;/code&gt; of the interval.</source>
          <target state="translated">func이 현재 범위 의 현재 &lt;code&gt;front&lt;/code&gt; 보다 작거나 같은 시점을 생성 하면 &lt;a href=&quot;std_datetime_date#DateTimeException&quot;&gt; &lt;code&gt;std.datetime.date.DateTimeException&lt;/code&gt; &lt;/a&gt; 이 발생합니다. func 이 간격 &lt;code&gt;end&lt;/code&gt; 이상의 시간 지점을 생성하면 범위가 비어 있고 반복이 완료됩니다 .</target>
        </trans-unit>
        <trans-unit id="74f0c5b3f5f366de0c8aea12cba32b6bdb7a7e22" translate="yes" xml:space="preserve">
          <source>If func retains state which changes as it is called, then some algorithms will not work correctly, because the range's &lt;code&gt;save&lt;/code&gt; will have failed to have really saved the range's state. To avoid such bugs, don't pass a delegate which is not logically pure to &lt;code&gt;fwdRange&lt;/code&gt;. If func is given the same time point with two different calls, it must return the same result both times.  Of course, none of the functions in this module have this problem, so it's only relevant for custom delegates.</source>
          <target state="translated">func이 호출 될 때 변경되는 상태를 유지하면 범위 &lt;code&gt;save&lt;/code&gt; 이 실제로 범위 상태를 저장하지 못하기 때문에 일부 알고리즘이 올바르게 작동하지 않습니다 . 이러한 버그를 피하려면 &lt;code&gt;fwdRange&lt;/code&gt; 에 논리적으로 순수하지 않은 델리게이트를 전달하지 마십시오 . func에 두 개의 다른 호출로 동일한 시점이 부여되면 동일한 결과를 두 번 반환해야합니다. 물론이 모듈의 어떤 기능도이 문제를 가지고 있지 않으므로 사용자 지정 대리자에게만 관련이 있습니다.</target>
        </trans-unit>
        <trans-unit id="082731789aa3a0c2389877b2540dad5fb393fea2" translate="yes" xml:space="preserve">
          <source>If func retains state which changes as it is called, then some algorithms will not work correctly, because the range's &lt;code&gt;save&lt;/code&gt; will have failed to have really saved the range's state. To avoid such bugs, don't pass a delegate which is not logically pure to &lt;code&gt;fwdRange&lt;/code&gt;. If func is given the same time point with two different calls, it must return the same result both times.  Of course, none of the functions in this module have this problem, so it's only relevant if when creating a custom delegate.</source>
          <target state="translated">func이 호출 될 때 변경되는 상태를 유지하면 범위 &lt;code&gt;save&lt;/code&gt; 이 실제로 범위 상태를 저장하지 못하기 때문에 일부 알고리즘이 올바르게 작동하지 않습니다 . 이러한 버그를 피하려면 &lt;code&gt;fwdRange&lt;/code&gt; 에 논리적으로 순수하지 않은 델리게이트를 전달하지 마십시오 . func에 두 개의 다른 호출로 동일한 시점이 부여되면 동일한 결과를 두 번 반환해야합니다. 물론이 모듈의 어떤 기능도이 문제를 가지고 있지 않으므로 사용자 지정 대리자를 만들 때만 관련이 있습니다.</target>
        </trans-unit>
        <trans-unit id="811cb1951d7eca66363f0ab4a25ab0f68bd6c804" translate="yes" xml:space="preserve">
          <source>If function a function in a base class, return that base class.</source>
          <target state="translated">기본 클래스에서 함수가 함수이면 해당 기본 클래스를 리턴하십시오.</target>
        </trans-unit>
        <trans-unit id="3a618122aa9fe1978f9e550b5f42d584977ec33d" translate="yes" xml:space="preserve">
          <source>If in a quoted field any quote by itself, not at the end of a field, will end processing for that field.</source>
          <target state="translated">따옴표로 묶은 필드에 필드의 끝이 아닌 그 자체로 따옴표가 있으면 해당 필드에 대한 처리가 종료됩니다.</target>
        </trans-unit>
        <trans-unit id="fc45bb57ad39df4d2be393733ec74789f2ef7133" translate="yes" xml:space="preserve">
          <source>If instantiated with &lt;code&gt;No.multiblock&lt;/code&gt;, it performs a search for the first zero bit in the bitmap and sets it.</source>
          <target state="translated">&lt;code&gt;No.multiblock&lt;/code&gt; 으로 인스턴스화 되면 비트 맵에서 첫 번째 0 비트를 검색하여 설정합니다.</target>
        </trans-unit>
        <trans-unit id="7b0f6cec4d5ea8c58428ba7c40e99097b7cb2322" translate="yes" xml:space="preserve">
          <source>If isNested() returns true, isThis() should return false, unless the function needs a dual-context pointer.</source>
          <target state="translated">isNested ()가 true를 반환하면 함수에 이중 컨텍스트 포인터가 필요하지 않으면 isThis ()는 false를 반환해야합니다.</target>
        </trans-unit>
        <trans-unit id="b4d04375110c3b3230b38eb2d9c5c313ab9a4587" translate="yes" xml:space="preserve">
          <source>If it is &lt;code&gt;false&lt;/code&gt;, then the third expression is evaluated, and its result is the result of the conditional expression.</source>
          <target state="translated">이 경우 &lt;code&gt;false&lt;/code&gt; 후 제 발현을 평가하고 그 결과는 조건식의 결과이다.</target>
        </trans-unit>
        <trans-unit id="ba0ab9ea37044a2e2b630f8489bf8ed0e516e703" translate="yes" xml:space="preserve">
          <source>If it is &lt;code&gt;true&lt;/code&gt;, then the second expression is evaluated, and its result is the result of the conditional expression.</source>
          <target state="translated">이 경우 &lt;code&gt;true&lt;/code&gt; 하고 상기 제 표현식을 평가하고 그 결과는 조건식의 결과이다.</target>
        </trans-unit>
        <trans-unit id="828463bf31c6d8c05164e51833a7bd26ece74f35" translate="yes" xml:space="preserve">
          <source>If it is desirable to persist a &lt;code&gt;Unique!T&lt;/code&gt; outside of its original scope, then it can be transferred. The transfer can be explicit, by calling &lt;code&gt;release&lt;/code&gt;, or implicit, when returning Unique from a function. The resource &lt;code&gt;T&lt;/code&gt; can be a polymorphic class object or instance of an interface, in which case Unique behaves polymorphically too.</source>
          <target state="translated">&lt;code&gt;Unique!T&lt;/code&gt; 원래 범위 밖에서 유지하는 것이 바람직한 경우 전송할 수 있습니다. 함수에서 Unique를 반환 할 때 &lt;code&gt;release&lt;/code&gt; 를 호출하여 암시 적으로 명시 적으로 전송할 수 있습니다 . 자원 &lt;code&gt;T&lt;/code&gt; 는 다형성 클래스 객체 또는 인터페이스의 인스턴스 일 수 있으며,이 경우 고유는 다형성으로도 작동합니다.</target>
        </trans-unit>
        <trans-unit id="1a1dc588bc158cc467f4127355a3912b746c621f" translate="yes" xml:space="preserve">
          <source>If just type T is given and no variable v, then the catch clause is still executed.</source>
          <target state="translated">유형 T 만 제공되고 변수 v가없는 경우 catch 절이 계속 실행됩니다.</target>
        </trans-unit>
        <trans-unit id="f71f926a6db933017567619e75df00dc6712f06e" translate="yes" xml:space="preserve">
          <source>If multiple templates with the same</source>
          <target state="translated">동일한 템플릿이 여러 개인 경우</target>
        </trans-unit>
        <trans-unit id="35c6c44f6f67de6c4c0a779716275c68fe8b37b2" translate="yes" xml:space="preserve">
          <source>If no &lt;code&gt;delimiter&lt;/code&gt; is given, then one trailing &lt;code&gt;'\r'&lt;/code&gt;, &lt;code&gt;'\n'&lt;/code&gt;, &lt;code&gt;&quot;\r\n&quot;&lt;/code&gt;, &lt;code&gt;'\f'&lt;/code&gt;, &lt;code&gt;'\v'&lt;/code&gt;, &lt;a href=&quot;std_uni#lineSep&quot;&gt;&lt;code&gt;std.uni.lineSep&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;std_uni#paraSep&quot;&gt;&lt;code&gt;std.uni.paraSep&lt;/code&gt;&lt;/a&gt;, or &lt;a href=&quot;std_uni#nelSep&quot;&gt;&lt;code&gt;std.uni.nelSep&lt;/code&gt;&lt;/a&gt; is removed from the end of &lt;code&gt;str&lt;/code&gt;. If &lt;code&gt;str&lt;/code&gt; does not end with any of those characters, then it is returned unchanged.</source>
          <target state="translated">&lt;code&gt;delimiter&lt;/code&gt; 를 지정 하지 않으면 하나의 후행 &lt;code&gt;'\r'&lt;/code&gt; , &lt;code&gt;'\n'&lt;/code&gt; , &lt;code&gt;&quot;\r\n&quot;&lt;/code&gt; , &lt;code&gt;'\f'&lt;/code&gt; , &lt;code&gt;'\v'&lt;/code&gt; , &lt;a href=&quot;std_uni#lineSep&quot;&gt; &lt;code&gt;std.uni.lineSep&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;std_uni#paraSep&quot;&gt; &lt;code&gt;std.uni.paraSep&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;std_uni#nelSep&quot;&gt; &lt;code&gt;std.uni.nelSep&lt;/code&gt; &lt;/a&gt; 는 &lt;code&gt;str&lt;/code&gt; 의 끝에서 제거됩니다 . 경우 &lt;code&gt;str&lt;/code&gt; 그 모든 문자로 끝나지 않고, 다음은 변경되지 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="2b0411e822ff9871e75f5fe6e95c3d0518b1b309" translate="yes" xml:space="preserve">
          <source>If no &lt;code&gt;needle&lt;/code&gt; is provided, &lt;code&gt;pred(haystack.front)&lt;/code&gt; will be evaluated on each element of the input range.</source>
          <target state="translated">&lt;code&gt;needle&lt;/code&gt; 이 제공 되지 않으면 입력 범위의 각 요소 에서 &lt;code&gt;pred(haystack.front)&lt;/code&gt; 가 평가됩니다.</target>
        </trans-unit>
        <trans-unit id="69633a75862efb516486b64d796be076d86f4c19" translate="yes" xml:space="preserve">
          <source>If no call to constructors via &lt;code&gt;this&lt;/code&gt; or &lt;code&gt;super&lt;/code&gt; appear in a constructor, and the base class has a constructor, a call to &lt;code&gt;super()&lt;/code&gt; is inserted at the beginning of the constructor.</source>
          <target state="translated">&lt;code&gt;this&lt;/code&gt; 또는 &lt;code&gt;super&lt;/code&gt; 를 통한 생성자 호출이 생성자에 나타나지 않고 기본 클래스에 생성자가있는 경우 생성자 시작 부분에 &lt;code&gt;super()&lt;/code&gt; 호출 이 삽입됩니다.</target>
        </trans-unit>
        <trans-unit id="08c68d59ef2b4bb11a75a62d44b96024d217f2ea" translate="yes" xml:space="preserve">
          <source>If no catch handlers are there for the errors, then the program gracefully exits through the default error handler with an appropriate message.</source>
          <target state="translated">오류에 대한 catch 핸들러가없는 경우 프로그램은 적절한 메시지와 함께 기본 오류 핸들러를 정상적으로 종료합니다.</target>
        </trans-unit>
        <trans-unit id="a3f4b45154d7d5df5948f5742dc5af04d95c91df" translate="yes" xml:space="preserve">
          <source>If no cycles are found, the ctors and tlsctors are replaced with the ones generated by this algorithm to preserve the old incorrect ordering behavior.</source>
          <target state="translated">사이클을 찾지 못하면 ctor와 tlsctor가이 알고리즘에 의해 생성 된 것으로 대체되어 이전의 잘못된 순서 동작을 유지합니다.</target>
        </trans-unit>
        <trans-unit id="fd69e84bfca07a56902d7641663496f5b667fb84" translate="yes" xml:space="preserve">
          <source>If no data is available and the main thread access the range it will block until data becomes available. An exception to this is the &lt;code&gt;wait(Duration)&lt;/code&gt; method on the &lt;a href=&quot;#ChunkInputRange&quot;&gt;&lt;code&gt;ChunkInputRange&lt;/code&gt;&lt;/a&gt;. This method will wait at maximum for the specified duration and return true if data is available.</source>
          <target state="translated">사용 가능한 데이터가없고 주 스레드가 해당 범위에 액세스하면 데이터를 사용할 수있을 때까지 범위가 차단됩니다. &lt;a href=&quot;#ChunkInputRange&quot;&gt; &lt;code&gt;ChunkInputRange&lt;/code&gt; &lt;/a&gt; 의 &lt;code&gt;wait(Duration)&lt;/code&gt; 메소드는 예외 입니다. 이 메소드는 지정된 지속 시간 동안 최대 대기하며 데이터가 사용 가능한 경우 true를 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="b37f49606e8cab3bb492c893e69c1a2e75dd1924" translate="yes" xml:space="preserve">
          <source>If no data is available and the main thread accesses the range it will block until data becomes available. An exception to this is the &lt;code&gt;wait(Duration)&lt;/code&gt; method on the &lt;a href=&quot;#LineInputRange&quot;&gt;&lt;code&gt;LineInputRange&lt;/code&gt;&lt;/a&gt;. This method will wait at maximum for the specified duration and return true if data is available.</source>
          <target state="translated">사용 가능한 데이터가없고 메인 스레드가 범위에 액세스하면 데이터를 사용할 수있을 때까지 차단됩니다. 이에 대한 예외 는 &lt;a href=&quot;#LineInputRange&quot;&gt; &lt;code&gt;LineInputRange&lt;/code&gt; &lt;/a&gt; 의 &lt;code&gt;wait(Duration)&lt;/code&gt; 메소드입니다 . 이 메소드는 지정된 지속 시간 동안 최대 대기하며 데이터가 사용 가능한 경우 true를 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="dee768fdd957e908ee906de5d9f09ab3f15a2b74" translate="yes" xml:space="preserve">
          <source>If no explicit seed is provided, the first element of each work unit is used as a seed. For the final reduction, the result from the first work unit is used as the seed.</source>
          <target state="translated">명시적인 시드가 제공되지 않으면 각 작업 단위의 첫 번째 요소가 시드로 사용됩니다. 최종 축소를 위해 첫 번째 작업 단위의 결과가 시드로 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="b9beba693b6541f5c4a623aa8005a14a8c088860" translate="yes" xml:space="preserve">
          <source>If no function to call is specified, &lt;code&gt;each&lt;/code&gt; defaults to doing nothing but consuming the entire range. &lt;code&gt;r.front&lt;/code&gt; will be evaluated, but that can be avoided by specifying a lambda with a &lt;code&gt;lazy&lt;/code&gt; parameter.</source>
          <target state="translated">호출 할 함수가 지정되지 않은 경우 &lt;code&gt;each&lt;/code&gt; 기본적으로 전체 범위를 소비하는 것 외에는 아무것도하지 않습니다. &lt;code&gt;r.front&lt;/code&gt; 는 평가되지만 &lt;code&gt;lazy&lt;/code&gt; 매개 변수 로 람다를 지정하면 피할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="7b0e9e2df565b7ef14de5d370ee2e7f5508ed495" translate="yes" xml:space="preserve">
          <source>If no needle is provided, the &lt;code&gt;haystack&lt;/code&gt; is advanced as long as &lt;code&gt;pred&lt;/code&gt; evaluates to &lt;code&gt;true&lt;/code&gt;. Similarly, the haystack is positioned so as &lt;code&gt;pred&lt;/code&gt; evaluates to &lt;code&gt;false&lt;/code&gt; for &lt;code&gt;haystack.front&lt;/code&gt;.</source>
          <target state="translated">바늘이 제공되지 않으면 &lt;code&gt;pred&lt;/code&gt; 가 &lt;code&gt;true&lt;/code&gt; 로 평가되는 한 &lt;code&gt;haystack&lt;/code&gt; 가 전진 합니다 . 마찬가지로 haystack은 &lt;code&gt;haystack.front&lt;/code&gt; 에 대해 &lt;code&gt;pred&lt;/code&gt; 가 &lt;code&gt;false&lt;/code&gt; 로 평가 되도록 배치됩니다 .</target>
        </trans-unit>
        <trans-unit id="8015dc4a71527e3287d7f4a1a1531193efdd9ebe" translate="yes" xml:space="preserve">
          <source>If no random number generator is passed to &lt;code&gt;randomCover&lt;/code&gt;, the thread-global RNG rndGen will be used internally.</source>
          <target state="translated">난수 생성기가 &lt;code&gt;randomCover&lt;/code&gt; 로 전달되지 않으면 스레드 글로벌 RNG rndGen이 내부적으로 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="ec48dd4e26e9c9b7bb1bba08590ef49f6e8b00b5" translate="yes" xml:space="preserve">
          <source>If no separator is passed, the  predicate &lt;code&gt;isTerminator&lt;/code&gt; decides whether to accept an element of &lt;code&gt;r&lt;/code&gt;.</source>
          <target state="translated">분리자가 전달되지 않으면 술어 &lt;code&gt;isTerminator&lt;/code&gt; 는 &lt;code&gt;r&lt;/code&gt; 의 요소를 승인할지 여부를 결정합니다 .</target>
        </trans-unit>
        <trans-unit id="d5a9c9c4272e471499a4566ff40a97f218d487f9" translate="yes" xml:space="preserve">
          <source>If no unittest custom handlers are registered, the following algorithm is executed (the behavior can be affected by the &lt;code&gt;--DRT-testmode&lt;/code&gt; switch below): 1. Run all unit tests, tracking tests executed and passes. For each that fails, print the stack trace, and continue. 2. If there are no failures, set the summarize flag to false, and the runMain flag to true. 3. If there are failures, set the summarize flag to true, and the runMain flag to false.</source>
          <target state="translated">unittest 사용자 정의 핸들러가 등록되지 않은 경우 다음 알고리즘이 실행됩니다 ( 아래 의 &lt;code&gt;--DRT-testmode&lt;/code&gt; 스위치 가 동작에 영향을 줄 수 있음 ). 1. 모든 단위 테스트를 실행하고 실행 된 테스트를 추적하고 통과합니다. 실패한 각각에 대해 스택 추적을 인쇄하고 계속하십시오. 2. 실패가 없으면 요약 플래그를 false로 설정하고 runMain 플래그를 true로 설정하십시오. 3. 실패가 있으면 요약 플래그를 true로 설정하고 runMain 플래그를 false로 설정하십시오.</target>
        </trans-unit>
        <trans-unit id="fe70a6ffb1eaff978d001d003d35769a95cf2acb" translate="yes" xml:space="preserve">
          <source>If non-zero, prefix result with 0x (0X).</source>
          <target state="translated">0이 아닌 경우 접두사 결과는 0x (0X)입니다.</target>
        </trans-unit>
        <trans-unit id="bb201c468fcb1936a1cc835ca2cb32dd5d97a148" translate="yes" xml:space="preserve">
          <source>If none of the case expressions match, and there is a default statement, the default statement is transferred to.</source>
          <target state="translated">대소 문자 표현식이 일치하지 않고 기본 명령문이있는 경우 기본 명령문이 전송됩니다.</target>
        </trans-unit>
        <trans-unit id="ab5f1042c0495e282ce28b3b52048c3700563975" translate="yes" xml:space="preserve">
          <source>If none of the choice matches, a &lt;code&gt;SwitchError&lt;/code&gt; will be thrown. &lt;code&gt;SwitchError&lt;/code&gt; will also be thrown if not all the choices are void and a void choice was executed without throwing anything.</source>
          <target state="translated">일치하는 선택이 &lt;code&gt;SwitchError&lt;/code&gt; 가 발생합니다. 모든 선택이 무효가 아니고 아무것도 던지지 않고 무효 선택이 실행 된 경우에도 &lt;code&gt;SwitchError&lt;/code&gt; 가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="3ed3959f15bba3be1a16efa6393b19ce9aeff019" translate="yes" xml:space="preserve">
          <source>If not specified, the</source>
          <target state="translated">지정하지 않으면</target>
        </trans-unit>
        <trans-unit id="fe9db14bd961ccfeeb8601ee73a6483367ad2a6a" translate="yes" xml:space="preserve">
          <source>If one is a better match than the other, or one compiles and the other does not, the first is selected.</source>
          <target state="translated">하나가 다른 것보다 더 잘 일치하거나 하나가 컴파일되고 다른 하나가 컴파일되지 않으면 첫 번째가 선택됩니다.</target>
        </trans-unit>
        <trans-unit id="38f309363d54cf09070c11d4dd142dc6d8bfb60d" translate="yes" xml:space="preserve">
          <source>If one of the arguments is a NaN, the other is returned.</source>
          <target state="translated">인수 중 하나가 NaN이면 다른 인수가 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="f22c395490cca8ea1c81135fd8838b0c5b0afefa" translate="yes" xml:space="preserve">
          <source>If one of the numbers is an integral and the other is a floating-point number, &lt;code&gt;hookOpEquals(x, y)&lt;/code&gt; returns &lt;code&gt;true&lt;/code&gt; if and only if the integral can be converted exactly (without approximation) to the floating-point number. This is in order to preserve transitivity of equality: if &lt;code&gt; hookOpEquals(x, y)&lt;/code&gt; and &lt;code&gt;hookOpEquals(y, z)&lt;/code&gt; then &lt;code&gt;hookOpEquals(y, z)&lt;/code&gt;, in case &lt;code&gt;x&lt;/code&gt;, &lt;code&gt;y&lt;/code&gt;, and &lt;code&gt;z&lt;/code&gt; are a mix of integral and floating-point numbers.</source>
          <target state="translated">숫자 중 하나가 정수이고 다른 하나가 부동 소수점 숫자 인 경우 &lt;code&gt;hookOpEquals(x, y)&lt;/code&gt; 는 적분을 부동 소수점 숫자로 정확하게 (근사없이) 변환 할 수있는 경우에만 &lt;code&gt;true&lt;/code&gt; 를 반환 합니다 . 이는 등가의 전이성을 보존하기위한 것입니다. 만약 &lt;code&gt; hookOpEquals(x, y)&lt;/code&gt; 및 &lt;code&gt;hookOpEquals(y, z)&lt;/code&gt; 이면 &lt;code&gt;hookOpEquals(y, z)&lt;/code&gt; 이면 &lt;code&gt;x&lt;/code&gt; , &lt;code&gt;y&lt;/code&gt; , &lt;code&gt;z&lt;/code&gt; 는 정수와 부동 소수점 숫자의 혼합입니다 .</target>
        </trans-unit>
        <trans-unit id="47e27965329d106e5c510ac4b7c35d3cf65701ae" translate="yes" xml:space="preserve">
          <source>If one of the numbers is an integral and the other is a floating-point number, &lt;code&gt;hookOpEquals(x, y)&lt;/code&gt; returns a floating-point number that is &lt;code&gt;-1&lt;/code&gt; if &lt;code&gt;x &amp;lt; y&lt;/code&gt;, &lt;code&gt;0&lt;/code&gt; if &lt;code&gt;x == y&lt;/code&gt;, &lt;code&gt;1&lt;/code&gt; if &lt;code&gt;x &amp;gt; y&lt;/code&gt;, and &lt;code&gt;NaN&lt;/code&gt; if the floating-point number is &lt;code&gt;NaN&lt;/code&gt;.</source>
          <target state="translated">숫자 중 하나가 일체형이고, 다른 하나는 부동 소수이면 &lt;code&gt;hookOpEquals(x, y)&lt;/code&gt; 있는 부동 소수점 수를 반환 &lt;code&gt;-1&lt;/code&gt; 경우, &lt;code&gt;x &amp;lt; y&lt;/code&gt; , &lt;code&gt;0&lt;/code&gt; 의 경우 &lt;code&gt;x == y&lt;/code&gt; , &lt;code&gt;1&lt;/code&gt; 의 경우 &lt;code&gt;x &amp;gt; y&lt;/code&gt; 및 &lt;code&gt;NaN&lt;/code&gt; 이는 부동 소수점 수는이면 &lt;code&gt;NaN&lt;/code&gt; 이 .</target>
        </trans-unit>
        <trans-unit id="4188be61c77849339804ae3977d382498bd8812e" translate="yes" xml:space="preserve">
          <source>If one operand is an enum and the other is the base type of that enum, the result is the base type.</source>
          <target state="translated">한 피연산자가 열거 형이고 다른 피연산자가 해당 열거 형의 기본 유형 인 경우 결과는 기본 유형입니다.</target>
        </trans-unit>
        <trans-unit id="422f2e869457e9aec8090f25e67e71da6e5ae6e8" translate="yes" xml:space="preserve">
          <source>If one or both of the operand types is an enum after undergoing the above conversions, the result type is:</source>
          <target state="translated">위 변환을 수행 한 후 피연산자 유형 중 하나 또는 둘 다가 열거 형이면 결과 유형은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="34b4e760890c5916b5f472cf9ec3f9d946f615cd" translate="yes" xml:space="preserve">
          <source>If one or both operands are floating point, then a floating point comparison is performed.</source>
          <target state="translated">피연산자 중 하나 또는 둘 모두가 부동 소수점이면 부동 소수점 비교가 수행됩니다.</target>
        </trans-unit>
        <trans-unit id="f34527129f419587a7b124534783120be01591c6" translate="yes" xml:space="preserve">
          <source>If one range is infinite and the other finite, then the finite range must be a forward range, and the infinite range can be an input range.</source>
          <target state="translated">한 범위가 무한대이고 다른 범위가 유한 한 경우 유한 범위는 순방향 범위 여야하고 무한 범위는 입력 범위 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1493b0ab4b81a5a5d799727a74239f7ced24db39" translate="yes" xml:space="preserve">
          <source>If only one range is offered to &lt;code&gt;Chain&lt;/code&gt; or &lt;code&gt;chain&lt;/code&gt;, the &lt;code&gt;Chain&lt;/code&gt; type exits the picture by aliasing itself directly to that range's type.</source>
          <target state="translated">하나의 범위 만 &lt;code&gt;Chain&lt;/code&gt; 또는 &lt;code&gt;chain&lt;/code&gt; 에 제공되는 경우 &lt;code&gt;Chain&lt;/code&gt; 유형은 해당 범위의 유형에 직접 별명을 지정하여 그림을 종료합니다.</target>
        </trans-unit>
        <trans-unit id="4f4dfc7af6d318725cd2bb6acc7371848e22877c" translate="yes" xml:space="preserve">
          <source>If only one type is passed, then an array of that type. Otherwise, an array of &lt;a href=&quot;std_typecons#Tuple&quot;&gt;&lt;code&gt;std.typecons.Tuple&lt;/code&gt;&lt;/a&gt;s.</source>
          <target state="translated">하나의 유형 만 전달되면 해당 유형의 배열입니다. 그렇지 않으면 &lt;a href=&quot;std_typecons#Tuple&quot;&gt; &lt;code&gt;std.typecons.Tuple&lt;/code&gt; &lt;/a&gt; 의 배열입니다 .</target>
        </trans-unit>
        <trans-unit id="f80a4ee1709480a885baa729f38d366951608f11" translate="yes" xml:space="preserve">
          <source>If operands are integral types</source>
          <target state="translated">피연산자가 정수 유형 인 경우</target>
        </trans-unit>
        <trans-unit id="c17f6322872f795083ddb63a91c502026d7f7e3d" translate="yes" xml:space="preserve">
          <source>If overlapping is required, use &lt;a href=&quot;https://dlang.org/phobos/std_algorithm_mutation.html#copy&quot;&gt;&lt;code&gt;std.algorithm.mutation.copy&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">겹치는 것이 필요한 경우 &lt;a href=&quot;https://dlang.org/phobos/std_algorithm_mutation.html#copy&quot;&gt; &lt;code&gt;std.algorithm.mutation.copy&lt;/code&gt; 를&lt;/a&gt; 사용 하십시오 .</target>
        </trans-unit>
        <trans-unit id="dcfac2e8846ad57a33a3bc26acae8df77dfcdb25" translate="yes" xml:space="preserve">
          <source>If overridding &lt;code&gt;Object.opEquals()&lt;/code&gt; for classes, the class member function signature should look like:</source>
          <target state="translated">클래스에 대해 &lt;code&gt;Object.opEquals()&lt;/code&gt; 를 재정의하는 경우 클래스 멤버 함수 서명은 다음과 같아야합니다.</target>
        </trans-unit>
        <trans-unit id="d70cff54f302f2d4a422baa59aebb43764d5cd42" translate="yes" xml:space="preserve">
          <source>If overriding &lt;code&gt;Object.opCmp()&lt;/code&gt; for classes, the class member function signature should look like:</source>
          <target state="translated">클래스에 대해 &lt;code&gt;Object.opCmp()&lt;/code&gt; 를 재정의하는 경우 클래스 멤버 함수 서명은 다음과 같아야합니다.</target>
        </trans-unit>
        <trans-unit id="3e09a8be6b9d197eccbe61876283b5ca6720c550" translate="yes" xml:space="preserve">
          <source>If p is null, no operation is performed.</source>
          <target state="translated">p가 널이면 조작이 수행되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="352e9b1490dbc9b0a48acbedafe6ae17ff5f3152" translate="yes" xml:space="preserve">
          <source>If paramsym is null a new ScopeDsymbol is used in place of paramsym.</source>
          <target state="translated">paramsym이 null 인 경우 새로운 ScopeDsymbol이 paramsym 대신 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="0167129cd52bf73eb27d8ebdabfdbade4013fad0" translate="yes" xml:space="preserve">
          <source>If passed in a range of code points, returns a range with equivalent capabilities.</source>
          <target state="translated">코드 포인트 범위로 전달되면 동등한 기능을 가진 범위를 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="15542b3779f094229ad4949cf6c05be1fd8cee3c" translate="yes" xml:space="preserve">
          <source>If pointers to D garbage collector allocated memory are passed to C functions, it's critical to ensure that that memory will not be collected by the garbage collector before the C function is done with it. This is accomplished by:</source>
          <target state="translated">D 가비지 콜렉터 할당 메모리에 대한 포인터가 C 함수로 전달되는 경우 C 함수를 수행하기 전에 가비지 콜렉터가 메모리를 수집하지 않도록하는 것이 중요합니다. 이것은 다음에 의해 달성됩니다.</target>
        </trans-unit>
        <trans-unit id="0dd282293b2dd30b59ba588f24339bbfcbc55f38" translate="yes" xml:space="preserve">
          <source>If pointers to memory allocated on the D garbage collector heap are passed to C++ functions, it's critical to ensure that the referenced memory will not be collected by the D garbage collector before the C++ function is done with it. This is accomplished by:</source>
          <target state="translated">D 가비지 콜렉터 힙에 할당 된 메모리에 대한 포인터가 C ++ 함수로 전달되는 경우 C ++ 함수를 사용하기 전에 참조 된 메모리가 D 가비지 콜렉터에 의해 수집되지 않도록하는 것이 중요합니다. 이것은 다음에 의해 달성됩니다.</target>
        </trans-unit>
        <trans-unit id="0fae4029daa6372cee7e8e40ab986342b94efc26" translate="yes" xml:space="preserve">
          <source>If possible, convert array initializer to associative array initializer.</source>
          <target state="translated">가능하면 배열 이니셜 라이저를 연관 배열 이니셜 라이저로 변환하십시오.</target>
        </trans-unit>
        <trans-unit id="917024e995f1fa2c71d6754ac363cc3314dc229d" translate="yes" xml:space="preserve">
          <source>If present, the</source>
          <target state="translated">있는 경우</target>
        </trans-unit>
        <trans-unit id="0b88da18898e09a28c0b2bdc7b134ad9a375efc5" translate="yes" xml:space="preserve">
          <source>If range is a range of bytes, an &lt;code&gt;Encoder&lt;/code&gt; that iterates over the bytes of the corresponding Base64 encoding.  If range is a range of ranges of bytes, an &lt;code&gt;Encoder&lt;/code&gt; that iterates over the Base64 encoded strings of each element of the range.  In both cases, the returned &lt;code&gt;Encoder&lt;/code&gt; will be a &lt;a href=&quot;std_range_primitives#isForwardRange&quot;&gt;forward range&lt;/a&gt; if the given &lt;code&gt;range&lt;/code&gt; is at least a forward range, otherwise it will be only an input range.</source>
          <target state="translated">range가 바이트 범위 인 경우 해당 Base64 인코딩의 바이트를 반복 하는 &lt;code&gt;Encoder&lt;/code&gt; 입니다. range가 바이트 범위의 범위 인 경우 범위 의 각 요소에서 Base64로 인코딩 된 문자열을 반복 하는 &lt;code&gt;Encoder&lt;/code&gt; 입니다. 두 경우 모두, 주어진 &lt;code&gt;range&lt;/code&gt; 가 최소한 &lt;a href=&quot;std_range_primitives#isForwardRange&quot;&gt;전방 범위&lt;/a&gt; 이면 반환 된 &lt;code&gt;Encoder&lt;/code&gt; 는 전방 범위 가되고, 그렇지 않으면 입력 범위 만됩니다.</target>
        </trans-unit>
        <trans-unit id="8fcc566f870dfdc11f9cf5642881af956a3edafb" translate="yes" xml:space="preserve">
          <source>If range is a range of characters, a &lt;code&gt;Decoder&lt;/code&gt; that iterates over the bytes of the corresponding Base64 decoding.  If range is a range of ranges of characters, a &lt;code&gt;Decoder&lt;/code&gt; that iterates over the decoded strings corresponding to each element of the range. In this case, the length of each subrange must be a multiple of 4; the returned decoder does not keep track of Base64 decoding state across subrange boundaries.  In both cases, the returned &lt;code&gt;Decoder&lt;/code&gt; will be a &lt;a href=&quot;std_range_primitives#isForwardRange&quot;&gt;forward range&lt;/a&gt; if the given &lt;code&gt;range&lt;/code&gt; is at least a forward range, otherwise it will be only an input range.  If the input data contains characters not found in the base alphabet of the current Base64 encoding scheme, the returned range may throw a &lt;code&gt;Base64Exception&lt;/code&gt;.</source>
          <target state="translated">range가 문자 범위 인 경우 해당 Base64 디코딩의 바이트를 반복 하는 &lt;code&gt;Decoder&lt;/code&gt; 입니다. range가 문자 범위의 범위 인 경우 범위의 각 요소에 해당하는 디코딩 된 문자열을 반복 하는 &lt;code&gt;Decoder&lt;/code&gt; 입니다. 이 경우 각 하위 범위의 길이는 4의 배수 여야합니다. 반환 된 디코더는 하위 범위 경계에 걸쳐 Base64 디코딩 상태를 추적하지 않습니다. 두 경우 모두, 주어진 &lt;code&gt;range&lt;/code&gt; 가 최소한 &lt;a href=&quot;std_range_primitives#isForwardRange&quot;&gt;전방 범위&lt;/a&gt; 이면 반환 된 &lt;code&gt;Decoder&lt;/code&gt; 는 전방 범위 가되고, 그렇지 않으면 입력 범위 만됩니다. 입력 데이터에 현재 Base64 인코딩 체계의 기본 알파벳에서 찾을 수없는 문자가 포함되어 있으면 반환 된 범위에서 &lt;code&gt;Base64Exception&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2b6eb7ddfbf5a47c6c6af2b15e78fb247a252fb4" translate="yes" xml:space="preserve">
          <source>If same exact type =&amp;gt; one call to method opEquals</source>
          <target state="translated">동일한 정확한 유형 =&amp;gt; opEquals 메소드를 한 번 호출하면</target>
        </trans-unit>
        <trans-unit id="89afd532fed79af758875995d860db76e2e127dd" translate="yes" xml:space="preserve">
          <source>If set at runtime, &lt;code&gt;min&lt;/code&gt; and/or &lt;code&gt;max&lt;/code&gt; must be initialized appropriately.</source>
          <target state="translated">런타임에 설정된 경우 &lt;code&gt;min&lt;/code&gt; 및 / 또는 &lt;code&gt;max&lt;/code&gt; 를 적절히 초기화해야합니다.</target>
        </trans-unit>
        <trans-unit id="7d613cefcf14fab9fa1cdf592c4b64df5fd4a02e" translate="yes" xml:space="preserve">
          <source>If set at runtime, &lt;code&gt;min&lt;/code&gt; and/or &lt;code&gt;max&lt;/code&gt; must be initialized appropriately. The block must have been allocated with this freelist, and no dynamic changing of &lt;code&gt;min&lt;/code&gt; or &lt;code&gt;max&lt;/code&gt; is allowed to occur between allocation and deallocation.</source>
          <target state="translated">런타임에 설정된 경우 &lt;code&gt;min&lt;/code&gt; 및 / 또는 &lt;code&gt;max&lt;/code&gt; 를 적절히 초기화해야합니다. 이 프리리스트로 블록을 할당해야 하며 할당과 할당 해제간에 &lt;code&gt;min&lt;/code&gt; 또는 &lt;code&gt;max&lt;/code&gt; 의 동적 변경이 발생하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="12dba39acb6108d02380b6b46f58548fdd12a457" translate="yes" xml:space="preserve">
          <source>If set to &lt;code&gt;AllowDayOverflow.no&lt;/code&gt;, then day overflow is not allowed.</source>
          <target state="translated">&lt;code&gt;AllowDayOverflow.no&lt;/code&gt; 로 설정하면 day overflow가 허용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="0c05e2e8281e59d8e307dc66be3d2cc276d8fa30" translate="yes" xml:space="preserve">
          <source>If set to &lt;code&gt;AutoStart.no&lt;/code&gt;, then the StopWatch is not started when it is constructed.</source>
          <target state="translated">&lt;code&gt;AutoStart.no&lt;/code&gt; 로 설정 하면 StopWatch가 구성 될 때 시작되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="d6add4cf35e8c50b2af6d41b382ebe3f7e3e974a" translate="yes" xml:space="preserve">
          <source>If set to &lt;code&gt;AutoStart.no&lt;/code&gt;, then the stopwatch is not started when it is constructed.</source>
          <target state="translated">&lt;code&gt;AutoStart.no&lt;/code&gt; 로 설정 하면 스톱워치가 구성 될 때 시작되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="e084739a519921a28023083912a24037cae39c78" translate="yes" xml:space="preserve">
          <source>If set to &lt;code&gt;CheckDns.no&lt;/code&gt;, isEmail does not perform DNS checking.</source>
          <target state="translated">&lt;code&gt;CheckDns.no&lt;/code&gt; 로 설정하면 isEmail 은 DNS 확인을 수행하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="0e1f47a96e002fe723252c695ba57f0bd6e6ab0f" translate="yes" xml:space="preserve">
          <source>If set to &lt;code&gt;OpenRight.yes&lt;/code&gt;, then the interval is open to the right (last element is not included).</source>
          <target state="translated">&lt;code&gt;OpenRight.yes&lt;/code&gt; 로 설정 하면 간격이 오른쪽으로 열립니다 (마지막 요소는 포함되지 않음).</target>
        </trans-unit>
        <trans-unit id="37becabb79a088b28ac5682f3e5ecf44b42c3e44" translate="yes" xml:space="preserve">
          <source>If set to &lt;code&gt;PopFirst.no&lt;/code&gt;, then popFront is not called before returning the range.</source>
          <target state="translated">&lt;code&gt;PopFirst.no&lt;/code&gt; 로 설정 하면 범위를 반환하기 전에 popFront가 호출되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="c46457e61c98538473682050d8870e6910707094" translate="yes" xml:space="preserve">
          <source>If set to &lt;code&gt;SortOutput.no&lt;/code&gt;, the output should not be sorted.</source>
          <target state="translated">&lt;code&gt;SortOutput.no&lt;/code&gt; 로 설정 되면 출력을 정렬하지 않아야합니다.</target>
        </trans-unit>
        <trans-unit id="00965390f3dcb757da046e66cf3e12ece6325eda" translate="yes" xml:space="preserve">
          <source>If set, 0 is the only allowed &lt;a href=&quot;https://en.wikipedia.org/wiki/IEEE_754-1985#Denormalized_numbers&quot;&gt; IEEE754 denormalized&lt;/a&gt; number. Requires allowDenorm and storeNormalized.</source>
          <target state="translated">설정된 경우 0은 &lt;a href=&quot;https://en.wikipedia.org/wiki/IEEE_754-1985#Denormalized_numbers&quot;&gt;IEEE754 비정규 화 된&lt;/a&gt; 숫자 만 허용 됩니다. allowDenorm 및 storeNormalized가 필요합니다.</target>
        </trans-unit>
        <trans-unit id="61485b68856bc9bc475231ad8439460508956a5d" translate="yes" xml:space="preserve">
          <source>If set, select an exponent bias such that max_exp = 1. i.e. so that the maximum value is &amp;gt;= 1.0 and &amp;lt; 2.0. Ignored if the exponent bias is manually specified.</source>
          <target state="translated">설정된 경우 max_exp = 1과 같은 지수 바이어스를 선택합니다. 즉, 최대 값이&amp;gt; = 1.0 및 &amp;lt;2.0이되도록합니다. 지수 바이어스가 수동으로 지정되면 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="b15a8a24ac3c0abdda604fa6be697872fed5e457" translate="yes" xml:space="preserve">
          <source>If set, unsigned custom floats are assumed to be negative.</source>
          <target state="translated">설정하면 부호없는 사용자 지정 부동 소수점은 음수로 간주됩니다.</target>
        </trans-unit>
        <trans-unit id="96c1d18878474b954f19c1048ca19bc4cc441ff0" translate="yes" xml:space="preserve">
          <source>If size dependencies are inevitable, put a &lt;code&gt;static assert&lt;/code&gt; in the code to verify it:</source>
          <target state="translated">크기 의존성이 불가피한 경우 코드에 &lt;code&gt;static assert&lt;/code&gt; 을 추가하여 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="c4932da89fb63071147ad73f57504dc48f8f86d2" translate="yes" xml:space="preserve">
          <source>If some of these fields is not NULL, it is a pointer to b_data.</source>
          <target state="translated">이러한 필드 중 일부가 NULL이 아닌 경우 b_data에 대한 포인터입니다.</target>
        </trans-unit>
        <trans-unit id="bf8032a0e0aff5e21ec9404228bec256c45b8757" translate="yes" xml:space="preserve">
          <source>If source has internal pointers that point to itself and doesn't define opPostMove, it cannot be moved, and will trigger an assertion failure.</source>
          <target state="translated">소스에 자체를 가리키는 내부 포인터가 있고 opPostMove를 정의하지 않으면 이동할 수 없으며 어설 션 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="c4372423a2292ca511a5a4c383dba5ab95bc4f7d" translate="yes" xml:space="preserve">
          <source>If source has internal pointers that point to itself, it cannot be moved, and will trigger an assertion failure.</source>
          <target state="translated">소스에 자체를 가리키는 내부 포인터가 있으면 이동할 수 없으며 어설 션 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="b61714985a37455e4a9923539bc1db8640864a65" translate="yes" xml:space="preserve">
          <source>If splitting a string on whitespace and token compression is desired, consider using &lt;code&gt;splitter&lt;/code&gt; without specifying a separator.</source>
          <target state="translated">공백에서 문자열을 분할하고 토큰 압축을 원하는 경우 구분 기호를 지정하지 않고 &lt;code&gt;splitter&lt;/code&gt; 를 사용하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="05b6ffe797342cf0d1028469f63301e251d90fab" translate="yes" xml:space="preserve">
          <source>If splitting of data transfer is enabled this callback is called after download of an individual chunk finished. Note! After this callback was set then it have to be called FOR ALL chunks. Even if downloading of this chunk was skipped in CHUNK_BGN_FUNC. This is the reason why we don't need &quot;transfer_info&quot; parameter in this callback and we are not interested in &quot;remains&quot; parameter too.</source>
          <target state="translated">데이터 전송 분할이 활성화 된 경우 개별 청크 다운로드가 완료된 후이 콜백이 호출됩니다. 노트! 이 콜백이 설정되면 FOR ALL 청크를 호출해야합니다. CHUNK_BGN_FUNC에서이 청크 다운로드를 건너 뛰어도 마찬가지입니다. 이것이이 콜백에 &quot;transfer_info&quot;매개 변수가 필요하지 않은 이유이며 &quot;remains&quot;매개 변수에도 관심이 없습니다.</target>
        </trans-unit>
        <trans-unit id="42671fc7da4232343c7b0b928fc5d03d90a644e7" translate="yes" xml:space="preserve">
          <source>If statements provide simple conditional execution of statements.</source>
          <target state="translated">명령문이 간단한 조건부 명령문 실행을 제공하는 경우</target>
        </trans-unit>
        <trans-unit id="9c00c0869eed3767fe39aeae02ecce87d06c6f2e" translate="yes" xml:space="preserve">
          <source>If struct constructor is annotated with &lt;code&gt;@disable&lt;/code&gt; and has an empty &lt;a href=&quot;function#ParameterList&quot;&gt;&lt;i&gt;ParameterList&lt;/i&gt;&lt;/a&gt;, the struct has disabled default construction. The only way it can be constructed is via a call to another constructor with a non-empty</source>
          <target state="translated">구조체 생성자에 &lt;code&gt;@disable&lt;/code&gt; 로 주석이 달고 비어있는 &lt;a href=&quot;function#ParameterList&quot;&gt;&lt;i&gt;ParameterList&lt;/i&gt;&lt;/a&gt; 가 있으면 구조체가 기본 생성을 비활성화 한 것입니다. 그것을 만들 수있는 유일한 방법은 비어 있지 않은 다른 생성자를 호출하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="944569416617efaa7082cf853e519ff0670f8407" translate="yes" xml:space="preserve">
          <source>If struct invariant checking is turned on, the struct invariant is called at the end of the constructor.</source>
          <target state="translated">구조체 불변 검사가 켜져 있으면 생성자 끝에서 구조체 불변이 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="d7768f4c2da4924ba7acf617ca9aea18a8c9c30c" translate="yes" xml:space="preserve">
          <source>If structs declare an &lt;code&gt;opCmp&lt;/code&gt; member function, it should have the following form:</source>
          <target state="translated">구조체가 &lt;code&gt;opCmp&lt;/code&gt; 멤버 함수를 선언 하면 다음과 같은 형식이어야합니다.</target>
        </trans-unit>
        <trans-unit id="3992d8b7bb5105984cffe3cb78e47194ffe3ff8f" translate="yes" xml:space="preserve">
          <source>If structs declare an &lt;code&gt;opEquals&lt;/code&gt; member function for the identity comparison, it could have several forms, such as:</source>
          <target state="translated">구조체 가 아이덴티티 비교를 위해 &lt;code&gt;opEquals&lt;/code&gt; 멤버 함수를 선언하면 다음과 같은 여러 형식이있을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a998ede0b415c72a4f5c3800b4d3a122980f04c1" translate="yes" xml:space="preserve">
          <source>If such a match occurs, the inout is considered the common qualifier of the matched qualifiers. If more than two parameters exist, the common qualifier calculation is recursively applied.</source>
          <target state="translated">이러한 일치가 발생하면 입력은 일치 된 한정자의 공통 한정자로 간주됩니다. 둘 이상의 매개 변수가 존재하면 공통 규정 자 계산이 반복적으로 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="b30b7b06cd1e2f9ae926af9377511bb1cde4d9ab" translate="yes" xml:space="preserve">
          <source>If such an</source>
          <target state="translated">그런 경우</target>
        </trans-unit>
        <trans-unit id="a7624c537a3b1ba34be043fd5ddb463081b0a9fb" translate="yes" xml:space="preserve">
          <source>If template type parameters match the literal expressions on function arguments, the deduced types may consider narrowing conversions of them.</source>
          <target state="translated">템플릿 형식 매개 변수가 함수 인수의 리터럴 식과 일치하면 추론 된 형식의 변환이 좁아 질 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3d9b7696c9777c3fdef5f5f1690ef14ee23382d9" translate="yes" xml:space="preserve">
          <source>If the</source>
          <target state="translated">만약</target>
        </trans-unit>
        <trans-unit id="47a53d62849ea833a758681edda290d5ad91413e" translate="yes" xml:space="preserve">
          <source>If the .d source file starts with the string &quot;Ddoc&quot; then it is treated as general purpose documentation, not as a D code source file. From immediately after the &quot;Ddoc&quot; string to the end of the file or any &quot;Macros:&quot; section forms the document. No automatic highlighting is done to that text, other than highlighting of D code embedded between lines delineated with --- lines. Only macro processing is done.</source>
          <target state="translated">.d 소스 파일이 &quot;Ddoc&quot;문자열로 시작하면 D 코드 소스 파일이 아니라 범용 문서로 취급됩니다. &quot;Ddoc&quot;문자열 바로 다음부터 파일 끝까지 또는 &quot;Macros :&quot;섹션이 문서를 형성합니다. --- 행으로 구분 된 행 사이에 포함 된 D 코드를 강조 표시하는 것 외에는 해당 텍스트에 대한 자동 강조 표시가 수행되지 않습니다. 매크로 처리 만 수행됩니다.</target>
        </trans-unit>
        <trans-unit id="e8532e48c96c60a7608facfeb4a22eb5b3d9e1d6" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;#Condition&quot;&gt;&lt;i&gt;Condition&lt;/i&gt;&lt;/a&gt; is satisfied, then the following</source>
          <target state="translated">는 IF &lt;a href=&quot;#Condition&quot;&gt;&lt;i&gt;조건이&lt;/i&gt;&lt;/a&gt; 만족하고 다음</target>
        </trans-unit>
        <trans-unit id="e2fc51761f652cbfa928ace68e58f12bef9531f7" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;#Config.newEnv&quot;&gt;&lt;code&gt;Config.newEnv&lt;/code&gt;&lt;/a&gt; flag is set in &lt;code&gt;config&lt;/code&gt;, the child process will</source>
          <target state="translated">는 IF &lt;a href=&quot;#Config.newEnv&quot;&gt; &lt;code&gt;Config.newEnv&lt;/code&gt; 의&lt;/a&gt; 플래그가 설정됩니다 &lt;code&gt;config&lt;/code&gt; , 자식 프로세스는 것입니다</target>
        </trans-unit>
        <trans-unit id="43745bb1dee3dc73e7455be8ec08aff260e3ec47" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;#TemplateArgument&quot;&gt;&lt;i&gt;TemplateArgument&lt;/i&gt;&lt;/a&gt; is one token long, the parentheses can be omitted:</source>
          <target state="translated">는 IF &lt;a href=&quot;#TemplateArgument&quot;&gt;&lt;i&gt;TemplateArgument가&lt;/i&gt;&lt;/a&gt; 긴 하나의 토큰, 괄호는 생략 할 수 있습니다 :</target>
        </trans-unit>
        <trans-unit id="2d0280ee3bb99762171b658bd8c55f327440c8eb" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;class#ParameterList&quot;&gt;&lt;i&gt;ParameterList&lt;/i&gt;&lt;/a&gt; is empty, the struct instance is default initialized.</source>
          <target state="translated">는 IF &lt;a href=&quot;class#ParameterList&quot;&gt;&lt;i&gt;parameterList에이&lt;/i&gt;&lt;/a&gt; 비어 구조체 인스턴스는 기본적으로 초기화됩니다.</target>
        </trans-unit>
        <trans-unit id="2d70e00070ad7d208c2b59d3486718a575bd6f03" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;BitmappedBlock&lt;/code&gt; object is empty (has no active allocation), allocates all memory within and returns a slice to it. Otherwise, returns &lt;code&gt;null&lt;/code&gt; (i.e. no attempt is made to allocate the largest available block).</source>
          <target state="translated">는 IF &lt;code&gt;BitmappedBlock&lt;/code&gt; 의 객체 (활성 할당이 없습니다) 비어 내의 모든 메모리를 할당하고 여기에 조각을 반환합니다. 그렇지 않으면 &lt;code&gt;null&lt;/code&gt; 을 반환합니다 (즉 , 사용 가능한 가장 큰 블록을 할당하려고 시도하지 않음).</target>
        </trans-unit>
        <trans-unit id="f5b1d7f6d0725050ed31d8d5e2a2f42a77b9308e" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;FileLogger&lt;/code&gt; is managing the &lt;code&gt;File&lt;/code&gt; it logs to, this method will return a reference to this File.</source>
          <target state="translated">는 IF &lt;code&gt;FileLogger&lt;/code&gt; 이 전무되어 &lt;code&gt;File&lt;/code&gt; 이 로그를,이 방법은이 파일에 대한 참조를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="e82d2c358fbac5f6db431228cfdc4ab90afaecba" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;FileLogger&lt;/code&gt; was constructed with a filename, this method returns this filename. Otherwise an empty &lt;code&gt;string&lt;/code&gt; is returned.</source>
          <target state="translated">경우 &lt;code&gt;FileLogger&lt;/code&gt; 이 파일 이름으로 구성되었으며,이 방법은이 파일 이름을 반환합니다. 그렇지 않으면 빈 &lt;code&gt;string&lt;/code&gt; 이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="09e9a0c0fb2463234ac2c4886cea6f7201a979f8" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;SharedBitmappedBlock&lt;/code&gt; object is empty (has no active allocation), allocates all memory within and returns a slice to it. Otherwise, returns &lt;code&gt;null&lt;/code&gt; (i.e. no attempt is made to allocate the largest available block).</source>
          <target state="translated">는 IF &lt;code&gt;SharedBitmappedBlock&lt;/code&gt; 의 객체 (활성 할당이 없습니다) 비어 내의 모든 메모리를 할당하고 여기에 조각을 반환합니다. 그렇지 않으면 &lt;code&gt;null&lt;/code&gt; 을 반환합니다 (즉 , 사용 가능한 가장 큰 블록을 할당하려고 시도하지 않음).</target>
        </trans-unit>
        <trans-unit id="a85af50c42d4408aee171ffd99bd37d80c84bfad" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;Task&lt;/code&gt; isn't started yet, execute it in the current thread. If it's done, return its return value, if any. If it's in progress, busy spin until it's done, then return the return value. If it threw an exception, rethrow that exception.</source>
          <target state="translated">경우 &lt;code&gt;Task&lt;/code&gt; 아직 시작되지 않고, 현재의 thread를 실행합니다. 완료되면 리턴 값을 리턴하십시오 (있는 경우). 진행 중이면 완료 될 때까지 사용 중 회전 한 다음 반환 값을 반환합니다. 예외가 발생하면 해당 예외를 다시 발생 시키십시오.</target>
        </trans-unit>
        <trans-unit id="1bd6a82f193fead01ba830becd3c29303a62f4f9" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;Task&lt;/code&gt; isn't started yet, execute it in the current thread. If it's done, return its return value, if any. If it's in progress, wait on a condition variable. If it threw an exception, rethrow that exception.</source>
          <target state="translated">경우 &lt;code&gt;Task&lt;/code&gt; 아직 시작되지 않고, 현재의 thread를 실행합니다. 완료되면 리턴 값을 리턴하십시오 (있는 경우). 진행중인 경우 조건 변수를 기다립니다. 예외가 발생하면 해당 예외를 다시 발생 시키십시오.</target>
        </trans-unit>
        <trans-unit id="9e212700918e7fcce26dacfc8ea0fc78cc9f1eec" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;VariantN&lt;/code&gt; contains an (associative) array, returns the length of that array. Otherwise, throws an exception.</source>
          <target state="translated">&lt;code&gt;VariantN&lt;/code&gt; 에 (연관) 배열이 포함 된 경우 해당 배열의 길이를 반환합니다. 그렇지 않으면 예외가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="aaf923f5ee1964878af77ace59cc74c4aeed3ea4" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;VariantN&lt;/code&gt; contains an array, applies &lt;code&gt;dg&lt;/code&gt; to each element of the array in turn. Otherwise, throws an exception.</source>
          <target state="translated">경우] &lt;code&gt;VariantN&lt;/code&gt; 이 배열을 포함 적용 &lt;code&gt;dg&lt;/code&gt; 차례로 배열의 각 요소에 관한 것이다. 그렇지 않으면 예외가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="8cc269de3091c4d2c19acd44245d56ff558f7c59" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;VariantN&lt;/code&gt; object holds a value of the</source>
          <target state="translated">는 IF &lt;code&gt;VariantN&lt;/code&gt; 의 객체의 값을 보유</target>
        </trans-unit>
        <trans-unit id="4b1509a50bbf3491d84d8a56c0c8990227dbda5d" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;[ ]&lt;/code&gt; form is used, the slice is of the entire array.</source>
          <target state="translated">경우] &lt;code&gt;[ ]&lt;/code&gt; 형태를 사용하는, 슬라이스 전체 배열이다.</target>
        </trans-unit>
        <trans-unit id="cc574f8cb39cc53c71da6e74a5ec0da4813bcc04" translate="yes" xml:space="preserve">
          <source>If the CURLOPT_INFILE is used, this can be used to inform libcurl about how large the file being sent really is. That allows better error checking and better verifies that the upload was successful. -1 means unknown size.</source>
          <target state="translated">CURLOPT_INFILE을 사용하는 경우, 전송되는 파일의 실제 크기를 libcurl에 알리는 데 사용할 수 있습니다. 이를 통해 더 나은 오류 검사가 가능하고 업로드가 성공했는지 더 잘 확인할 수 있습니다. -1은 알 수없는 크기를 의미합니다.</target>
        </trans-unit>
        <trans-unit id="05e890b0ac7f150cc9383bbef3319acbe1eb47b0" translate="yes" xml:space="preserve">
          <source>If the UDA is a type, then any UDAs of the same type on the symbol will match. If the UDA is a template for a type, then any UDA which is an instantiation of that template will match. And if the UDA is a value, then any UDAs on the symbol which are equal to that value will match.</source>
          <target state="translated">UDA가 유형 인 경우 기호에서 동일한 유형의 UDA가 일치합니다. UDA가 유형의 템플리트 인 경우 해당 템플리트의 인스턴스화 인 UDA가 일치합니다. UDA가 값이면 해당 값과 같은 기호의 UDA가 일치합니다.</target>
        </trans-unit>
        <trans-unit id="d6829c7076e9b081aaeb04fb4efe46caee211bea" translate="yes" xml:space="preserve">
          <source>If the [EBP] is omitted, it is assumed for local variables. If &lt;code&gt;naked&lt;/code&gt; is used, this no longer holds.</source>
          <target state="translated">[EBP]를 생략하면 지역 변수로 간주됩니다. 경우 &lt;code&gt;naked&lt;/code&gt; 사용이 더 이상 보유하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="1517a4666732a9b97017b3d1661df1ab091b7335" translate="yes" xml:space="preserve">
          <source>If the aggregate expression is a sequence, there can be one or two iteration symbols declared. If one, then the symbol is an</source>
          <target state="translated">집계 표현식이 시퀀스 인 경우 하나 또는 두 개의 반복 기호가 선언 될 수 있습니다. 하나 인 경우 기호는</target>
        </trans-unit>
        <trans-unit id="d74660278291ee85d1999a22558014f3ea28fb7a" translate="yes" xml:space="preserve">
          <source>If the aggregate expression is a static or dynamic array of &lt;code&gt;char&lt;/code&gt;s, &lt;code&gt;wchar&lt;/code&gt;s, or &lt;code&gt;dchar&lt;/code&gt;s, then the</source>
          <target state="translated">집계 표현식이 &lt;code&gt;char&lt;/code&gt; , &lt;code&gt;wchar&lt;/code&gt; 또는 &lt;code&gt;dchar&lt;/code&gt; 의 정적 또는 동적 배열 인 경우</target>
        </trans-unit>
        <trans-unit id="cbeacb125fa68a379271d564591b63d8e90e22ef" translate="yes" xml:space="preserve">
          <source>If the aggregate expression is a struct or class object, but the &lt;code&gt;opApply&lt;/code&gt; for &lt;code&gt;foreach&lt;/code&gt;, or &lt;code&gt;opApplyReverse&lt;/code&gt;&lt;code&gt;foreach_reverse&lt;/code&gt; do not exist, then iteration over struct and class objects can be done with range primitives. For &lt;code&gt;foreach&lt;/code&gt;, this means the following properties and methods must be defined:</source>
          <target state="translated">집계 식 구조체 또는 클래스 객체이지만, 경우 &lt;code&gt;opApply&lt;/code&gt; 에 대한 &lt;code&gt;foreach&lt;/code&gt; 는 , 또는 &lt;code&gt;opApplyReverse&lt;/code&gt; 이 &lt;code&gt;foreach_reverse&lt;/code&gt; 존재하지 않는, 다음 반복을 통해 구조체와 클래스 개체가 범위 프리미티브 수행 할 수 있습니다. 들어 &lt;code&gt;foreach&lt;/code&gt; 문 이 다음과 같은 속성과 메서드를 정의해야합니다 의미합니다 :</target>
        </trans-unit>
        <trans-unit id="2fc73ce3aaae537f6f799c049d4ae92b1b9bca9f" translate="yes" xml:space="preserve">
          <source>If the aggregate expression is a struct or class object, the &lt;code&gt;foreach&lt;/code&gt; is defined by the special &lt;span id=&quot;opApply&quot;&gt;&lt;code&gt;opApply&lt;/code&gt;&lt;/span&gt; member function, and the &lt;code&gt;foreach_reverse&lt;/code&gt; behavior is defined by the special &lt;span id=&quot;opApplyReverse&quot;&gt;&lt;code&gt;opApplyReverse&lt;/code&gt;&lt;/span&gt; member function. These functions have the type:</source>
          <target state="translated">집계 표현식이 구조체 또는 클래스 객체 인 경우 &lt;code&gt;foreach&lt;/code&gt; 는 특수한 &lt;span id=&quot;opApply&quot;&gt; &lt;code&gt;opApply&lt;/code&gt; &lt;/span&gt; 멤버 함수 로 정의되고 &lt;code&gt;foreach_reverse&lt;/code&gt; 동작은 특수한 &lt;span id=&quot;opApplyReverse&quot;&gt; &lt;code&gt;opApplyReverse&lt;/code&gt; &lt;/span&gt; 멤버 함수로 정의됩니다 . 이러한 기능은 다음과 같은 유형을 갖습니다.</target>
        </trans-unit>
        <trans-unit id="a964bd4ba66b1238ba3df838bc73bf80b6db0380" translate="yes" xml:space="preserve">
          <source>If the aggregate expression is an associative array, there can be one or two variables declared. If one, then the variable is said to be the</source>
          <target state="translated">집계 표현식이 연관 배열 인 경우 하나 또는 두 개의 변수가 선언 될 수 있습니다. 하나 인 경우 변수는</target>
        </trans-unit>
        <trans-unit id="28f986b7b478a6b80712dcbe7082b7d096f58800" translate="yes" xml:space="preserve">
          <source>If the aggregate is a static or dynamic array, there can be one or two variables declared. If one, then the variable is said to be the</source>
          <target state="translated">집계가 정적 또는 동적 배열 인 경우 하나 또는 두 개의 변수가 선언 될 수 있습니다. 하나 인 경우 변수는</target>
        </trans-unit>
        <trans-unit id="dae323352e29801474e63b5dca9b04c0df39a8b3" translate="yes" xml:space="preserve">
          <source>If the argument is a CommaExp, set a flag to prevent deprecation messages</source>
          <target state="translated">인수가 CommaExp 인 경우 사용 중단 메시지가 표시되지 않도록 플래그를 설정하십시오.</target>
        </trans-unit>
        <trans-unit id="fd923c5e6b5ba5db493474258e601c811cb53b07" translate="yes" xml:space="preserve">
          <source>If the argument is omitted, it means default construction of the scalar type:</source>
          <target state="translated">인수가 생략되면 스칼라 유형의 기본 구성을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="c2b4ef88a634d75ab4162e14992b099e340c974e" translate="yes" xml:space="preserve">
          <source>If the arguments are all either types that are abstract classes, or expressions that are typed as abstract classes, then &lt;code&gt;true&lt;/code&gt; is returned. Otherwise, &lt;code&gt;false&lt;/code&gt; is returned. If there are no arguments, &lt;code&gt;false&lt;/code&gt; is returned.</source>
          <target state="translated">인수가 모두 추상 클래스 인 유형이거나 추상 클래스로 입력 된 표현식 인 경우 &lt;code&gt;true&lt;/code&gt; 가 리턴됩니다. 그렇지 않으면 &lt;code&gt;false&lt;/code&gt; 가 반환됩니다. 인수가 없으면 &lt;code&gt;false&lt;/code&gt; 가 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="870a7ff26a7a40d5a235f7261d71e7076bce3fa8" translate="yes" xml:space="preserve">
          <source>If the arguments are all either types that are arithmetic types, or expressions that are typed as arithmetic types, then &lt;code&gt;true&lt;/code&gt; is returned. Otherwise, &lt;code&gt;false&lt;/code&gt; is returned. If there are no arguments, &lt;code&gt;false&lt;/code&gt; is returned.</source>
          <target state="translated">인수가 모두 산술 유형 인 유형이거나 산술 유형으로 입력 된 표현식 인 경우 &lt;code&gt;true&lt;/code&gt; 가 리턴됩니다. 그렇지 않으면 &lt;code&gt;false&lt;/code&gt; 가 반환됩니다. 인수가 없으면 &lt;code&gt;false&lt;/code&gt; 가 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="c1199d0a51996844d05cb8716b18ac074abdf063" translate="yes" xml:space="preserve">
          <source>If the assigned value type is &lt;b&gt;not&lt;/b&gt; equivalent with the AA element type, the expression could invoke operator overloading with normal indexing access:</source>
          <target state="translated">지정된 값 유형이 AA 요소 유형과 동일 &lt;b&gt;하지 않은&lt;/b&gt; 경우 표현식은 일반 색인 작성 액세스로 연산자 오버로드를 호출 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a4c8c8da96483d4e6d105c51e4ab4887f9f8b55b" translate="yes" xml:space="preserve">
          <source>If the assigned value type is equivalent with the AA element type:</source>
          <target state="translated">지정된 값 유형이 AA 요소 유형과 동일한 경우 :</target>
        </trans-unit>
        <trans-unit id="39dbd0d9fed3f956fc2681e5931d3927843d2a46" translate="yes" xml:space="preserve">
          <source>If the bounds check in &lt;code&gt;@system&lt;/code&gt; or &lt;code&gt;@trusted&lt;/code&gt; code is disabled, the code correctness must still be guaranteed by the code author.</source>
          <target state="translated">&lt;code&gt;@system&lt;/code&gt; 또는 &lt;code&gt;@trusted&lt;/code&gt; 코드 에서 범위 검사를 사용하지 않으면 코드 작성자가 코드 정확성을 보장해야합니다.</target>
        </trans-unit>
        <trans-unit id="cc1e679f124dc90842ff4979e66ede34a74890c6" translate="yes" xml:space="preserve">
          <source>If the callback doesn't take any arguments, the callback is invoked whenever the option is seen.</source>
          <target state="translated">콜백이 인수를 취하지 않으면 옵션이 표시 될 때마다 콜백이 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="3289fcddad88ae1df9d116fd88b6c6dc79afe870" translate="yes" xml:space="preserve">
          <source>If the callback takes one string argument, the option string (without the leading dash(es)) is passed to the callback. After that, the option string is considered handled and removed from the options array.</source>
          <target state="translated">콜백에 하나의 문자열 인수가 있으면 옵션 문자열 (앞의 대시없이)이 콜백으로 전달됩니다. 그 후, 옵션 문자열은 처리 된 것으로 간주되고 옵션 배열에서 제거됩니다.</target>
        </trans-unit>
        <trans-unit id="dad4f3623ab08f61a1b3d8228c7e7a46ecb84bd7" translate="yes" xml:space="preserve">
          <source>If the callback takes two string arguments, the option string is handled as an option with one argument, and parsed accordingly. The option and its value are passed to the callback. After that, whatever was passed to the callback is considered handled and removed from the list.</source>
          <target state="translated">콜백에 두 개의 문자열 인수가 사용되면 옵션 문자열이 하나의 인수로 옵션으로 처리되고 그에 따라 구문 분석됩니다. 옵션과 해당 값이 콜백으로 전달됩니다. 그 후, 콜백으로 전달 된 것은 처리되고 목록에서 제거 된 것으로 간주됩니다.</target>
        </trans-unit>
        <trans-unit id="8d6fa53ba31aeabc61edb3bbeab4d2e35828294c" translate="yes" xml:space="preserve">
          <source>If the caller is a Fiber and is not a Generator, this function will call scheduler.yield() or Fiber.yield(), as appropriate.</source>
          <target state="translated">호출자가 파이버이고 생성자가 아닌 경우이 함수는 적절하게 scheduler.yield () 또는 Fiber.yield ()를 호출합니다.</target>
        </trans-unit>
        <trans-unit id="7fba3a81af609825439d1523a354f0ef5c6b4ecb" translate="yes" xml:space="preserve">
          <source>If the caller is a scheduled Fiber, this yields execution to another scheduled Fiber.</source>
          <target state="translated">호출자가 예약 된 파이버 인 경우 다른 예약 된 파이버를 실행합니다.</target>
        </trans-unit>
        <trans-unit id="682966fbc9a5573324e201e13b7ba309d84a4edb" translate="yes" xml:space="preserve">
          <source>If the capacity is increased, one should assume that all iterators to the elements are invalidated.</source>
          <target state="translated">용량이 증가하면 요소에 대한 모든 반복자가 무효화된다고 가정해야합니다.</target>
        </trans-unit>
        <trans-unit id="881b45b7bdf985b220e8cd0369c0c1827fe806d8" translate="yes" xml:space="preserve">
          <source>If the chunk of memory managed is large, it may be desirable to switch management to free list from the beginning. That way, memory may be used in a more compact manner than region mode. To force free list mode, call &lt;code&gt;switchToFreeList&lt;/code&gt; shortly after construction or when deemed appropriate.</source>
          <target state="translated">관리되는 메모리 청크가 큰 경우 관리를 처음부터 사용 가능 목록으로 전환하는 것이 바람직 할 수 있습니다. 이러한 방식으로, 메모리는 영역 모드보다 더 컴팩트 한 방식으로 사용될 수있다. 사용 가능리스트 모드를 강제 실행하려면 &lt;code&gt;switchToFreeList&lt;/code&gt; 직후 또는 적절하다고 간주되는 경우 switchToFreeList를 호출 하십시오 .</target>
        </trans-unit>
        <trans-unit id="9ac8dd371ddada3a7fc0d5f27220ac56194a508b" translate="yes" xml:space="preserve">
          <source>If the connection proceeds too quickly then need to slow it down</source>
          <target state="translated">연결이 너무 빨리 진행되면 속도를 늦춰야합니다</target>
        </trans-unit>
        <trans-unit id="a0e6b5ba02714528b40c08b339b490154681d034" translate="yes" xml:space="preserve">
          <source>If the constructor can create a unique object (e.g. if it is &lt;code&gt;pure&lt;/code&gt;), the object can be implicitly convertible to any qualifiers.</source>
          <target state="translated">생성자가 고유 한 객체를 생성 할 수있는 경우 (예 : &lt;code&gt;pure&lt;/code&gt; 객체) 객체를 한정자로 암시 적으로 변환 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="cf0cf6c28f3156b6b4f9788d5978b63c0c05e84c" translate="yes" xml:space="preserve">
          <source>If the constructor can create a unique object (i.e. if it is &lt;code&gt;pure&lt;/code&gt;), the object is implicitly convertible to any qualifiers.</source>
          <target state="translated">생성자가 고유 한 객체를 생성 할 수있는 경우 (즉 , &lt;code&gt;pure&lt;/code&gt; ) 객체는 암시 적으로 모든 한정자로 변환 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="52c26c14a7e4c3281fb4736e2032dbcd78185dac" translate="yes" xml:space="preserve">
          <source>If the current count is equal to zero, return. Otherwise, atomically decrement the count by one and return true.</source>
          <target state="translated">현재 카운트가 0과 같으면 반환합니다. 그렇지 않으면, 원자 적으로 카운트를 1 씩 감소시키고 true를 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="50c1fec6baa7c97f9c101593b09fc41307d590d7" translate="yes" xml:space="preserve">
          <source>If the declaration is disabled but inside a disabled function, returns &lt;code&gt;true&lt;/code&gt; but do not issue an error message.</source>
          <target state="translated">선언이 비활성화되었지만 비활성화 된 함수 내에 있으면 &lt;code&gt;true&lt;/code&gt; 를 반환 하지만 오류 메시지는 표시하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="553971eeba92d7bd581f90194d8554493054062d" translate="yes" xml:space="preserve">
          <source>If the default value for a parameter is given, all following parameters must also have default values.</source>
          <target state="translated">매개 변수의 기본값이 제공되면 다음의 모든 매개 변수에도 기본값이 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="aefb0c84385cb6665755448be70c3bf176cad1d9" translate="yes" xml:space="preserve">
          <source>If the delimiter is an identifier, the identifier must be immediately followed by a newline, and the matching delimiter is the same identifier starting at the beginning of the line:</source>
          <target state="translated">분리 문자가 식별자 인 경우 식별자 바로 뒤에 개행 문자가 와야하며 일치하는 분리 문자는 행의 시작 부분에서 시작하는 동일한 식별자입니다.</target>
        </trans-unit>
        <trans-unit id="367e2c9e3e9e32edd1905a00926130379051ac02" translate="yes" xml:space="preserve">
          <source>If the documentation of a member function of a container takes a parameter of type &lt;code&gt;Range&lt;/code&gt;, then it refers to the primary range type of this container. Oftentimes &lt;code&gt;Take!Range&lt;/code&gt; will be used, in which case the range refers to a span of the elements in the container. Arguments to these parameters &lt;b&gt;must&lt;/b&gt; be obtained from the same container instance as the one being worked with. It is important to note that many generic range algorithms return the same range type as their input range.</source>
          <target state="translated">컨테이너의 멤버 함수에 대한 문서가 &lt;code&gt;Range&lt;/code&gt; 유형의 매개 변수 를 사용하는 경우이 컨테이너의 기본 범위 유형을 참조합니다. 종종 &lt;code&gt;Take!Range&lt;/code&gt; 가 사용되며,이 경우 범위는 컨테이너에있는 요소의 범위를 나타냅니다. 이러한 매개 변수에 인수 &lt;b&gt;해야한다&lt;/b&gt; 하나 개의 존재가 함께 일 같은 컨테이너 인스턴스에서 얻을 수. 많은 일반 범위 알고리즘은 입력 범위와 동일한 범위 유형을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="568a7fe362541b12ed21809dd85fad3122bbc2f4" translate="yes" xml:space="preserve">
          <source>If the download receives less than &quot;low speed limit&quot; bytes/second during &quot;low speed time&quot; seconds, the operations is aborted. You could i.e if you have a pretty high speed connection, abort if it is less than 2000 bytes/sec during 20 seconds.</source>
          <target state="translated">&quot;저속 시간&quot;초 동안 다운로드가 &quot;저속 한계&quot;바이트 / 초 미만을 수신하면 작업이 중단됩니다. 예를 들어 초고속 연결이있는 경우 20 초 동안 2000 바이트 / 초 미만이면 중단됩니다.</target>
        </trans-unit>
        <trans-unit id="3a1f560a07b490771cc9fc4811b46461cd585b36" translate="yes" xml:space="preserve">
          <source>If the email address is valid or not.</source>
          <target state="translated">이메일 주소가 유효한지 아닌지.</target>
        </trans-unit>
        <trans-unit id="4f3a54e2dd01849ed176b274b08fe7067255fdd1" translate="yes" xml:space="preserve">
          <source>If the enum</source>
          <target state="translated">열거 형의 경우</target>
        </trans-unit>
        <trans-unit id="657b7adb8cca95e26ff1d78ccaa8357b99612950" translate="yes" xml:space="preserve">
          <source>If the expression is a &lt;a href=&quot;function#property-functions&quot;&gt; Property Function&lt;/a&gt;, &lt;code&gt;typeof&lt;/code&gt; gives its return type.</source>
          <target state="translated">표현식이 &lt;a href=&quot;function#property-functions&quot;&gt;특성 함수 인&lt;/a&gt; 경우 &lt;code&gt;typeof&lt;/code&gt; 는 리턴 유형을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="bbff4334fd247c00a1664b1a8294a75098385c7e" translate="yes" xml:space="preserve">
          <source>If the extended unittest handler is registered, this function returns the result from that handler directly.</source>
          <target state="translated">확장 단위 테스트 핸들러가 등록 된 경우이 함수는 해당 핸들러의 결과를 직접 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="638ef19a4eda5122a3e4b7247816dfcd0c978607" translate="yes" xml:space="preserve">
          <source>If the extension is empty, this function is equivalent to &lt;a href=&quot;#stripExtension&quot;&gt;&lt;code&gt;stripExtension&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">확장명이 비어 있으면이 함수는 &lt;a href=&quot;#stripExtension&quot;&gt; &lt;code&gt;stripExtension&lt;/code&gt; &lt;/a&gt; 과 같습니다 .</target>
        </trans-unit>
        <trans-unit id="7ef335ccbfb3536483e3c42f2775a824af19d172" translate="yes" xml:space="preserve">
          <source>If the field is initialized on one path, it must be initialized on all paths.</source>
          <target state="translated">필드가 한 경로에서 초기화되면 모든 경로에서 초기화되어야합니다.</target>
        </trans-unit>
        <trans-unit id="837d5b133d0941d97e1586686594739710856b45" translate="yes" xml:space="preserve">
          <source>If the field type has an &lt;a href=&quot;operatoroverloading#assignment&quot;&gt;&lt;code&gt;opAssign&lt;/code&gt;&lt;/a&gt; method, it will not be used for initialization.</source>
          <target state="translated">필드 유형에 &lt;a href=&quot;operatoroverloading#assignment&quot;&gt; &lt;code&gt;opAssign&lt;/code&gt; &lt;/a&gt; 메소드 가 있으면 초기화에 사용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="ced70cd3f9cbddd52606f9834678b1724238171b" translate="yes" xml:space="preserve">
          <source>If the field type is not mutable, multiple initialization will be rejected.</source>
          <target state="translated">필드 유형을 변경할 수없는 경우 여러 초기화가 거부됩니다.</target>
        </trans-unit>
        <trans-unit id="03c48cf052ea3dedbdf6ccc3c7e899b230bc6471" translate="yes" xml:space="preserve">
          <source>If the file is not opened, returns &lt;code&gt;true&lt;/code&gt;. Otherwise, returns &lt;a href=&quot;http://cplusplus.com/reference/clibrary/cstdio/ferror.html&quot;&gt;ferror&lt;/a&gt; for the file handle.</source>
          <target state="translated">파일이 열리지 않으면 &lt;code&gt;true&lt;/code&gt; 를 반환 합니다 . 그렇지 않으면 파일 핸들에 대한 &lt;a href=&quot;http://cplusplus.com/reference/clibrary/cstdio/ferror.html&quot;&gt;ferror&lt;/a&gt; 를 리턴합니다 .</target>
        </trans-unit>
        <trans-unit id="8450d7a55bd53dbebae5b57df534f9be1005db67" translate="yes" xml:space="preserve">
          <source>If the file is not opened, succeeds vacuously. Otherwise, returns &lt;a href=&quot;http://cplusplus.com/reference/clibrary/cstdio/clearerr.html&quot;&gt;clearerr&lt;/a&gt; for the file handle.</source>
          <target state="translated">파일이 열리지 않으면 애매하게 성공합니다. 그렇지 않으면 파일 핸들에 대해 &lt;a href=&quot;http://cplusplus.com/reference/clibrary/cstdio/clearerr.html&quot;&gt;clearerr&lt;/a&gt; 를 리턴합니다 .</target>
        </trans-unit>
        <trans-unit id="094342c021e1489a63abd256ccc39489b9dd3b66" translate="yes" xml:space="preserve">
          <source>If the file name of a module is an invalid module name (e.g. &lt;code&gt;foo-bar.d&lt;/code&gt;), you may use a module declaration to set a valid module name:</source>
          <target state="translated">모듈의 파일 이름이 잘못된 모듈 이름 (예 : &lt;code&gt;foo-bar.d&lt;/code&gt; ) 인 경우 모듈 선언을 사용하여 유효한 모듈 이름을 설정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="af6d8edab76ddfaae7837345a33fd73f250c8a9f" translate="yes" xml:space="preserve">
          <source>If the file was unopened, succeeds vacuously. Otherwise closes the file (by calling &lt;a href=&quot;http://cplusplus.com/reference/clibrary/cstdio/fclose.html&quot;&gt;fclose&lt;/a&gt;), throwing on error. Even if an exception is thrown, afterwards the &lt;code&gt;File&lt;/code&gt; object is empty. This is different from &lt;code&gt;detach&lt;/code&gt; in that it always closes the file; consequently, all other &lt;code&gt;File&lt;/code&gt; objects referring to the same handle will see a closed file henceforth.</source>
          <target state="translated">파일이 열리지 않으면 애매하게 성공합니다. 그렇지 않으면 ( &lt;a href=&quot;http://cplusplus.com/reference/clibrary/cstdio/fclose.html&quot;&gt;fclose&lt;/a&gt; 호출하여) 파일을 닫고 오류가 발생합니다. 예외가 발생하더라도 나중에 &lt;code&gt;File&lt;/code&gt; 객체는 비어 있습니다. 이것은 항상 파일을 닫는다는 점 에서 &lt;code&gt;detach&lt;/code&gt; 과 다릅니다 . 결과적으로 동일한 핸들을 참조하는 다른 모든 &lt;code&gt;File&lt;/code&gt; 객체는 닫힌 파일을 보게됩니다.</target>
        </trans-unit>
        <trans-unit id="527ef94b697e67dac9fb104fb0ef24982a4b2044" translate="yes" xml:space="preserve">
          <source>If the filename already has an extension, it is replaced. If not, the extension is simply appended to the filename. Including a leading dot in &lt;code&gt;ext&lt;/code&gt; is optional.</source>
          <target state="translated">파일 이름에 이미 확장자가 있으면 대체됩니다. 그렇지 않은 경우 확장명은 단순히 파일 이름에 추가됩니다. &lt;code&gt;ext&lt;/code&gt; 에 선행 점을 포함시키는 것은 선택 사항입니다.</target>
        </trans-unit>
        <trans-unit id="9ba4ff05c5a39476e966f563ceda94938de67867" translate="yes" xml:space="preserve">
          <source>If the first</source>
          <target state="translated">처음이라면</target>
        </trans-unit>
        <trans-unit id="fdc87c8a8b7093e7a7ff0e6b20593048b93bffda" translate="yes" xml:space="preserve">
          <source>If the first line starts with &quot;#!&quot;, then that line is ignored.</source>
          <target state="translated">첫 번째 줄이 &quot;#!&quot;로 시작하면 해당 줄은 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="f743b99432834f349face5005529142050d8a895" translate="yes" xml:space="preserve">
          <source>If the first lookup wasn't successful, a second one is performed on imports. In the second lookup phase inherited scopes are ignored. This includes scope of base classes and interface (in this example, &lt;code&gt;BaseClass&lt;/code&gt;'s imports would be ignored), as well as imports in mixed-in &lt;code&gt;template&lt;/code&gt;.</source>
          <target state="translated">첫 번째 조회가 실패한 경우 가져 오기에서 두 번째 조회가 수행됩니다. 두 번째 조회 단계에서는 상속 된 범위가 무시됩니다. 여기에는 기본 클래스 및 인터페이스의 범위 (이 예제에서는 &lt;code&gt;BaseClass&lt;/code&gt; 의 가져 오기는 무시 됨)와 혼합 &lt;code&gt;template&lt;/code&gt; 가져 오기가 포함됩니다 .</target>
        </trans-unit>
        <trans-unit id="4653edc731431a9f55f3a9c2f7b1ee0500507aaf" translate="yes" xml:space="preserve">
          <source>If the floating-point rounding mode is changed within a function, it must be restored before the function exits. If this rule is violated (for example, by the use of inline asm), the rounding mode used for subsequent calculations is undefined.</source>
          <target state="translated">함수 내에서 부동 소수점 반올림 모드가 변경되면 함수가 종료되기 전에 복원해야합니다. 이 규칙을 위반하면 (예 : 인라인 asm 사용) 후속 계산에 사용되는 반올림 모드가 정의되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="06665db726ed2b3db8e693b6a8e9e8220aa3c936" translate="yes" xml:space="preserve">
          <source>If the format string is fixed, passing it as a template parameter checks the type correctness of the parameters at compile-time. This also can result in better performance.</source>
          <target state="translated">형식 문자열이 고정 된 경우이를 템플리트 매개 변수로 전달하면 컴파일시 매개 변수의 유형 정확성을 검사합니다. 또한 성능이 향상 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f41ef8f8cc465c8df198d14584ea0805a3861563" translate="yes" xml:space="preserve">
          <source>If the fractional part of x is exactly 0.5, the return value is rounded away from zero.</source>
          <target state="translated">x의 소수 부분이 정확히 0.5이면 반환 값은 0에서 반올림됩니다.</target>
        </trans-unit>
        <trans-unit id="6a44050dca10920a151c58d6983c48f0ef88a105" translate="yes" xml:space="preserve">
          <source>If the function is passed in string form, the state has name &lt;code&gt;&quot;a&quot;&lt;/code&gt; and the zero-based index in the recurrence has name &lt;code&gt;&quot;n&quot;&lt;/code&gt;. The given string must return the desired value for &lt;code&gt;a[n]&lt;/code&gt; given &lt;code&gt;a[n - 1]&lt;/code&gt;, &lt;code&gt;a[n - 2]&lt;/code&gt;, &lt;code&gt;a[n - 3]&lt;/code&gt;,..., &lt;code&gt;a[n - stateSize]&lt;/code&gt;. The state size is dictated by the number of arguments passed to the call to &lt;code&gt;recurrence&lt;/code&gt;. The &lt;code&gt;Recurrence&lt;/code&gt; struct itself takes care of managing the recurrence's state and shifting it appropriately.</source>
          <target state="translated">함수가 문자열 형식으로 전달되면 상태의 이름은 &lt;code&gt;&quot;a&quot;&lt;/code&gt; 이고 반복의 0부터 시작하는 인덱스의 이름은 &lt;code&gt;&quot;n&quot;&lt;/code&gt; 입니다. 주어진 문자열에 대해 원하는 값을 반환해야 &lt;code&gt;a[n]&lt;/code&gt; 소정 &lt;code&gt;a[n - 1]&lt;/code&gt; , &lt;code&gt;a[n - 2]&lt;/code&gt; , &lt;code&gt;a[n - 3]&lt;/code&gt; , ..., &lt;code&gt;a[n - stateSize]&lt;/code&gt; . 상태 크기는 &lt;code&gt;recurrence&lt;/code&gt; 호출에 전달 된 인수 수에 의해 결정됩니다 . &lt;code&gt;Recurrence&lt;/code&gt; 자체가 재발의 상태를 관리하고 적절하게 이동을 담당 구조체.</target>
        </trans-unit>
        <trans-unit id="3c67c2406f3c735811702f591ea611c2970cdc93" translate="yes" xml:space="preserve">
          <source>If the function returns &lt;code&gt;void&lt;/code&gt;, and the first parameter is &lt;code&gt;ref&lt;/code&gt; or &lt;code&gt;out&lt;/code&gt;, then all subsequent &lt;code&gt;return ref&lt;/code&gt; parameters are considered as being assigned to the first parameter for lifetime checking. The &lt;code&gt;this&lt;/code&gt; reference parameter to a struct non-static member function is considered the first parameter.</source>
          <target state="translated">함수가 &lt;code&gt;void&lt;/code&gt; 를 리턴 하고 첫 번째 매개 변수가 &lt;code&gt;ref&lt;/code&gt; 또는 &lt;code&gt;out&lt;/code&gt; 이면, 모든 후속 &lt;code&gt;return ref&lt;/code&gt; 매개 변수는 수명 점검을 위해 첫 번째 매개 변수에 지정된 것으로 간주됩니다. 구조체 비 정적 멤버 함수에 대한 &lt;code&gt;this&lt;/code&gt; 참조 매개 변수는 첫 번째 매개 변수로 간주됩니다.</target>
        </trans-unit>
        <trans-unit id="e2f91af04048a7f2df150e8629c6506bcf13c494" translate="yes" xml:space="preserve">
          <source>If the generated copy constructor fails to type check, it will receive the &lt;code&gt;@disable&lt;/code&gt; attribute.</source>
          <target state="translated">생성 된 사본 생성자가 유형 점검에 실패하면 &lt;code&gt;@disable&lt;/code&gt; 속성 을 수신 합니다.</target>
        </trans-unit>
        <trans-unit id="8b1f1e5a2ec324dd58e7c90d671571002b1fff9a" translate="yes" xml:space="preserve">
          <source>If the generated time point is ever passed the edge of the range in the proper direction, then the edge of that range will be used instead. So, if iterating forward, and the generated time point is past the interval's &lt;code&gt;end&lt;/code&gt;, then &lt;code&gt;front&lt;/code&gt; becomes &lt;code&gt;end&lt;/code&gt;. If iterating backwards, and the generated time point is before &lt;code&gt;begin&lt;/code&gt;, then &lt;code&gt;front&lt;/code&gt; becomes &lt;code&gt;begin&lt;/code&gt;. In either case, the range would then be empty.</source>
          <target state="translated">생성 된 시점이 범위의 가장자리를 올바른 방향으로 통과하면 해당 범위의 가장자리가 대신 사용됩니다. 앞으로 반복하고, 생성 된 시점이 간격의 지났다면, &lt;code&gt;end&lt;/code&gt; 후 &lt;code&gt;front&lt;/code&gt; 된다 &lt;code&gt;end&lt;/code&gt; . 뒤로 반복하고 생성 된 시점이 &lt;code&gt;begin&lt;/code&gt; 하기 전 이면 &lt;code&gt;front&lt;/code&gt; 가 &lt;code&gt;begin&lt;/code&gt; . 두 경우 모두 범위가 비어 있습니다.</target>
        </trans-unit>
        <trans-unit id="f99397fa61eb34180bac28883c2e71092de6779b" translate="yes" xml:space="preserve">
          <source>If the given file is a symbolic link, then this returns the attributes of the symbolic link itself rather than file that it points to. If the given file is</source>
          <target state="translated">주어진 파일이 심볼릭 링크 인 경우 파일이 아닌 심볼릭 링크 자체의 속성을 반환합니다. 주어진 파일이</target>
        </trans-unit>
        <trans-unit id="a8dd80adc35b72f7e72590ec9517794124fe146d" translate="yes" xml:space="preserve">
          <source>If the given header contains columns not found in the input they will be ignored.</source>
          <target state="translated">주어진 헤더에 입력에서 찾을 수없는 열이 포함되어 있으면 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="6c1edb4f30ef72dc654568216fa979bf98fad63c" translate="yes" xml:space="preserve">
          <source>If the given header does not match the order in the input, the content will return as it is found in the input.</source>
          <target state="translated">주어진 헤더가 입력 순서와 일치하지 않으면 입력에서 찾은 내용이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="02a682f7846fb30dcf203d60bc7b6d3c76c4aec4" translate="yes" xml:space="preserve">
          <source>If the heap has room to grow, inserts &lt;code&gt;value&lt;/code&gt; into the store and returns &lt;code&gt;true&lt;/code&gt;. Otherwise, if &lt;code&gt;less(value, front)&lt;/code&gt;, calls &lt;code&gt;replaceFront(value)&lt;/code&gt; and returns again &lt;code&gt;true&lt;/code&gt;. Otherwise, leaves the heap unaffected and returns &lt;code&gt;false&lt;/code&gt;. This method is useful in scenarios where the smallest &lt;code&gt;k&lt;/code&gt; elements of a set of candidates must be collected.</source>
          <target state="translated">힙에 여유 공간이 있으면 &lt;code&gt;value&lt;/code&gt; 을 저장소에 삽입 하고 &lt;code&gt;true&lt;/code&gt; 를 리턴 합니다 . 그렇지 않으면 &lt;code&gt;less(value, front)&lt;/code&gt; 경우 &lt;code&gt;replaceFront(value)&lt;/code&gt; 호출 하고 다시 &lt;code&gt;true&lt;/code&gt; 를 반환 합니다 . 그렇지 않으면 힙에 영향을 미치지 않고 &lt;code&gt;false&lt;/code&gt; 를 반환합니다 . 이 방법은 후보 집합의 가장 작은 &lt;code&gt;k&lt;/code&gt; 요소를 수집해야하는 시나리오에서 유용 합니다.</target>
        </trans-unit>
        <trans-unit id="44b5028eff915a424d2f05a190933f50e1ca6cdc" translate="yes" xml:space="preserve">
          <source>If the indexing key already exists in the AA, the setting runs normal assignment.</source>
          <target state="translated">AA에 인덱싱 키가 이미 있으면 설정이 정상 할당을 실행합니다.</target>
        </trans-unit>
        <trans-unit id="ed75ab58ae875098848f819360947f45ce239d60" translate="yes" xml:space="preserve">
          <source>If the indexing key does not yet exist in AA, a new AA entry will be allocated, and it will be initialized with the assigned value.</source>
          <target state="translated">인덱싱 키가 AA에 아직 없으면 새 AA 항목이 할당되고 할당 된 값으로 초기화됩니다.</target>
        </trans-unit>
        <trans-unit id="e8855e5c687d575ac4df58472c04fb490240846e" translate="yes" xml:space="preserve">
          <source>If the infinite-precision result fits in the result type, return it and do not touch &lt;code&gt;overflow&lt;/code&gt;</source>
          <target state="translated">무한 정밀도 결과가 결과 유형에 맞는 경우 반환하고 &lt;code&gt;overflow&lt;/code&gt; 만지지 마십시오.</target>
        </trans-unit>
        <trans-unit id="4845dcdf1de3a2fc72f78227d54d29b17278e722" translate="yes" xml:space="preserve">
          <source>If the initializer is not present, the immutable can be initialized from the corresponding constructor:</source>
          <target state="translated">이니셜 라이저가 없으면 해당 생성자에서 불변을 초기화 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b6a08857ba6ae055c6d0992d75eba874a7e5568d" translate="yes" xml:space="preserve">
          <source>If the input array is already valid, this function returns the original, otherwise it constructs a new array by replacing all illegal sequences with the encoding scheme's replacement sequence.</source>
          <target state="translated">입력 배열이 이미 유효한 경우이 함수는 원본을 반환하고, 그렇지 않으면 모든 잘못된 시퀀스를 인코딩 체계의 교체 시퀀스로 교체하여 새 배열을 구성합니다.</target>
        </trans-unit>
        <trans-unit id="8c989250d06df7a1e7f52d0b71ed6e2b6ea2a097" translate="yes" xml:space="preserve">
          <source>If the input string is already valid, this function returns the original, otherwise it constructs a new string by replacing all illegal code unit sequences with the encoding's replacement character, Invalid sequences will be replaced with the Unicode replacement character (U+FFFD) if the character repertoire contains it, otherwise invalid sequences will be replaced with '?'.</source>
          <target state="translated">입력 문자열이 이미 유효한 경우이 함수는 원본을 반환합니다. 그렇지 않으면 모든 잘못된 코드 단위 시퀀스를 인코딩의 대체 문자로 바꾸어 새 문자열을 생성합니다. 잘못된 문자열은 문자 레퍼토리에 포함되어 있지 않으면 유효하지 않은 시퀀스는 '?'로 대체됩니다.</target>
        </trans-unit>
        <trans-unit id="c3178232393693733f89474a2be2c7d87e890b8d" translate="yes" xml:space="preserve">
          <source>If the instance &lt;code&gt;toString&lt;/code&gt; has overridden &lt;code&gt;Object.toString&lt;/code&gt;, it is used.</source>
          <target state="translated">&lt;code&gt;toString&lt;/code&gt; 인스턴스 가 &lt;code&gt;Object.toString&lt;/code&gt; 을 대체 한 경우 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="3bbc396d6905590778769668af1612cc2bc09090" translate="yes" xml:space="preserve">
          <source>If the invariant does not hold, then the program enters an invalid state.</source>
          <target state="translated">고정이 유지되지 않으면 프로그램은 유효하지 않은 상태가됩니다.</target>
        </trans-unit>
        <trans-unit id="29f830d3a5bba4e064a4eb84cc7502640a0b8dc9" translate="yes" xml:space="preserve">
          <source>If the last template parameter in the</source>
          <target state="translated">의 마지막 템플릿 매개 변수가</target>
        </trans-unit>
        <trans-unit id="88a26f48b106a357207e0f09ddece2a679970e48" translate="yes" xml:space="preserve">
          <source>If the last template parameter is set to &lt;code&gt;No.multiblock&lt;/code&gt;, the allocator will only serve allocations which require at most &lt;code&gt;theBlockSize&lt;/code&gt;. The &lt;code&gt;BitmappedBlock&lt;/code&gt; has a specialized implementation for single-block allocations which allows for greater performance, at the cost of not being able to allocate more than one block at a time.</source>
          <target state="translated">마지막 템플릿 매개 변수가 &lt;code&gt;No.multiblock&lt;/code&gt; 으로 설정 되면 할당자는 최대 &lt;code&gt;theBlockSize&lt;/code&gt; 를 요구하는 할당 만 제공 합니다. &lt;code&gt;BitmappedBlock&lt;/code&gt; 는 한 번에 두 개 이상의 블록을 할당 할 수없는 비용에 큰 성능을 가능하게 단일 블록 할당에 대한 전문 구현을 가지고있다.</target>
        </trans-unit>
        <trans-unit id="b95587a219c8d062823f53f5bd2f1a123f7f69f2" translate="yes" xml:space="preserve">
          <source>If the left and right operands are of the same struct type, and the struct type has a &lt;a href=&quot;struct#Postblit&quot;&gt;&lt;i&gt;Postblit&lt;/i&gt;&lt;/a&gt;, then the copy operation is as described in &lt;a href=&quot;struct#struct-postblit&quot;&gt;Struct Postblit&lt;/a&gt;.</source>
          <target state="translated">왼쪽과 오른쪽 피연산자가 동일한 구조체 유형이고 구조체 유형에 &lt;a href=&quot;struct#Postblit&quot;&gt;&lt;i&gt;Postblit이 있으면&lt;/i&gt;&lt;/a&gt; 복사 작업은 &lt;a href=&quot;struct#struct-postblit&quot;&gt;Struct Postblit에&lt;/a&gt; 설명 된 대로 입니다.</target>
        </trans-unit>
        <trans-unit id="78b1fe866d2fc25a11cfe13642305ae4d6350c6d" translate="yes" xml:space="preserve">
          <source>If the left hand side of an</source>
          <target state="translated">왼쪽의</target>
        </trans-unit>
        <trans-unit id="eb414c8d10d773bd339d18bd7ab37e8cf26592ba" translate="yes" xml:space="preserve">
          <source>If the left hand side of an assignment is a slice operation on a struct or class instance, it can be overloaded by implementing an &lt;code&gt;opIndexAssign&lt;/code&gt; member function that takes the return value of the &lt;code&gt;opSlice&lt;/code&gt; function as parameter(s). Expressions of the form &lt;code&gt;a[&lt;/code&gt;</source>
          <target state="translated">할당의 왼쪽이 구조체 또는 클래스 인스턴스에서 슬라이스 작업 인 경우 &lt;code&gt;opSlice&lt;/code&gt; 함수 의 반환 값을 매개 변수로 사용 하는 &lt;code&gt;opIndexAssign&lt;/code&gt; 멤버 함수를 구현하여 오버로드 할 수 있습니다 . 형태 &lt;code&gt;a[&lt;/code&gt; 표현</target>
        </trans-unit>
        <trans-unit id="a4e9f1b74401fc4cc6670aa5c593952f4aacceb0" translate="yes" xml:space="preserve">
          <source>If the left hand side of an assignment is an index operation on a struct or class instance, it can be overloaded by providing an &lt;code&gt;opIndexAssign&lt;/code&gt; member function. Expressions of the form &lt;code&gt;a[&lt;/code&gt;</source>
          <target state="translated">할당의 왼쪽이 구조체 또는 클래스 인스턴스에서 인덱스 작업 인 경우 &lt;code&gt;opIndexAssign&lt;/code&gt; 멤버 함수를 제공하여 오버로드 할 수 있습니다 . 형태 &lt;code&gt;a[&lt;/code&gt; 표현</target>
        </trans-unit>
        <trans-unit id="d8a73a5f2389d0e22c2833822feb34b34d4eccd0" translate="yes" xml:space="preserve">
          <source>If the left operand is &lt;code&gt;false&lt;/code&gt;, then the right operand is evaluated. If the result type of the</source>
          <target state="translated">왼쪽 피연산자가 &lt;code&gt;false&lt;/code&gt; 인 경우 오른쪽 피연산자가 평가됩니다. 결과 유형이</target>
        </trans-unit>
        <trans-unit id="60ea3d064b90b5b8a778e152eace4b2f3ae90eb9" translate="yes" xml:space="preserve">
          <source>If the left operand is &lt;code&gt;true&lt;/code&gt;, then the right operand is evaluated. If the result type of the</source>
          <target state="translated">왼쪽 피연산자가 &lt;code&gt;true&lt;/code&gt; 이면 오른쪽 피연산자가 평가됩니다. 결과 유형이</target>
        </trans-unit>
        <trans-unit id="019b690c1822d6ef391c3b9bd7b26426c5f16db7" translate="yes" xml:space="preserve">
          <source>If the left operand, converted to type &lt;code&gt;bool&lt;/code&gt;, evaluates to &lt;code&gt;false&lt;/code&gt;, then the right operand is not evaluated. If the result type of the</source>
          <target state="translated">&lt;code&gt;bool&lt;/code&gt; 유형으로 변환 된 왼쪽 피연산자 가 &lt;code&gt;false&lt;/code&gt; 로 평가 되면 오른쪽 피연산자가 평가되지 않습니다. 결과 유형이</target>
        </trans-unit>
        <trans-unit id="553371891fa4522412ee1e69cce9e04315ec8432" translate="yes" xml:space="preserve">
          <source>If the left operand, converted to type &lt;code&gt;bool&lt;/code&gt;, evaluates to &lt;code&gt;true&lt;/code&gt;, then the right operand is not evaluated. If the result type of the</source>
          <target state="translated">&lt;code&gt;bool&lt;/code&gt; 유형으로 변환 된 왼쪽 피연산자 가 &lt;code&gt;true&lt;/code&gt; 로 평가 되면 오른쪽 피연산자가 평가되지 않습니다. 결과 유형이</target>
        </trans-unit>
        <trans-unit id="3b4965e0366e4348265d324ef6cafd070f7970a9" translate="yes" xml:space="preserve">
          <source>If the lock is held by another caller, the method returns. Otherwise, the lock is acquired if it is not already held, and then the internal counter is incremented by one.</source>
          <target state="translated">다른 호출자가 잠금을 보유하면 메소드가 리턴합니다. 그렇지 않으면 잠금이 아직 보유되지 않은 경우 잠금이 획득되고 내부 카운터는 1 씩 증가합니다.</target>
        </trans-unit>
        <trans-unit id="55629f3e58b1ed6b51915672626c91dce13adbf6" translate="yes" xml:space="preserve">
          <source>If the lvalue is a static array or a slice, the behavior is as described in &lt;a href=&quot;array#array-copying&quot;&gt;Array Copying&lt;/a&gt; and &lt;a href=&quot;array#array-setting&quot;&gt;Array Setting&lt;/a&gt;.</source>
          <target state="translated">lvalue가 정적 배열 또는 슬라이스 인 경우 동작은 &lt;a href=&quot;array#array-copying&quot;&gt;배열 복사&lt;/a&gt; 및 &lt;a href=&quot;array#array-setting&quot;&gt;배열 설정에&lt;/a&gt; 설명 된대로입니다 .</target>
        </trans-unit>
        <trans-unit id="9eeb3d42a4d163cc9ef2cce9f7a4d552e700ff44" translate="yes" xml:space="preserve">
          <source>If the lvalue is a user-defined property, the behavior is as described in &lt;a href=&quot;function#property-functions&quot;&gt;Property Functions&lt;/a&gt;.</source>
          <target state="translated">lvalue가 사용자 정의 특성 인 경우 동작은 &lt;a href=&quot;function#property-functions&quot;&gt;특성 함수에&lt;/a&gt; 설명 된대로입니다 .</target>
        </trans-unit>
        <trans-unit id="1e946590fb7a5bc10633af10a8d9500f37b24a5e" translate="yes" xml:space="preserve">
          <source>If the lvalue is the &lt;code&gt;.length&lt;/code&gt; property of a dynamic array, the behavior is as described in &lt;a href=&quot;array#resize&quot;&gt;Setting Dynamic Array Length&lt;/a&gt;.</source>
          <target state="translated">lvalue가 동적 배열 의 &lt;code&gt;.length&lt;/code&gt; 속성 인 경우 동작은 &lt;a href=&quot;array#resize&quot;&gt;동적 배열 길이 설정에&lt;/a&gt; 설명 된대로입니다 .</target>
        </trans-unit>
        <trans-unit id="dbdda788f4cd04313acf31a5b41902468d969a5d" translate="yes" xml:space="preserve">
          <source>If the member is a class or struct, undefined lookups will be forwarded to the</source>
          <target state="translated">멤버가 클래스 또는 구조체 인 경우 정의되지 않은 조회는</target>
        </trans-unit>
        <trans-unit id="c199908c7f62621c91cf713b59d48d772db7abde" translate="yes" xml:space="preserve">
          <source>If the modifier &lt;code&gt;'d'&lt;/code&gt; is present, then the number of characters in &lt;code&gt;to&lt;/code&gt; may be only &lt;code&gt;0&lt;/code&gt; or &lt;code&gt;1&lt;/code&gt;.  If the modifier &lt;code&gt;'d'&lt;/code&gt; is</source>
          <target state="translated">개질제 경우 &lt;code&gt;'d'&lt;/code&gt; 존재하고있는 문자의 수 &lt;code&gt;to&lt;/code&gt; 전용 될 수 &lt;code&gt;0&lt;/code&gt; 또는 &lt;code&gt;1&lt;/code&gt; . 수정 자 &lt;code&gt;'d'&lt;/code&gt; 가</target>
        </trans-unit>
        <trans-unit id="f37f897b787b41e685e34c136ea8c1b433cab685" translate="yes" xml:space="preserve">
          <source>If the need is to remove some elements in the range but the order of the remaining elements does not have to be preserved, you may want to pass &lt;code&gt;SwapStrategy.unstable&lt;/code&gt; to &lt;code&gt;remove&lt;/code&gt;.</source>
          <target state="translated">범위에서 일부 요소를 제거해야하지만 나머지 요소의 순서를 유지하지 않아도되는 경우 &lt;code&gt;SwapStrategy.unstable&lt;/code&gt; 을 전달 하여 &lt;code&gt;remove&lt;/code&gt; 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="03a264184d81bbe95136e2edec953acc73c6e493" translate="yes" xml:space="preserve">
          <source>If the new array length is longer, the remainder is filled out with the default initializer.</source>
          <target state="translated">새 배열 길이가 더 길면 나머지는 기본 이니셜 라이저로 채워집니다.</target>
        </trans-unit>
        <trans-unit id="e4175ca1068588312ee2e22b72b62b8fd2ed5c5b" translate="yes" xml:space="preserve">
          <source>If the only pointer to an object is held outside of these areas, then the collector will miss it and free the memory.</source>
          <target state="translated">객체에 대한 유일한 포인터가이 영역 밖에 있으면 콜렉터는이를 놓치고 메모리를 비 웁니다.</target>
        </trans-unit>
        <trans-unit id="4717846b29b0f5d911b4b2433c06faa02839af64" translate="yes" xml:space="preserve">
          <source>If the operands are integral values, the &lt;a href=&quot;type#usual-arithmetic-conversions&quot;&gt;Usual Arithmetic Conversions&lt;/a&gt; are applied to bring them to a common type before comparison. Equality is defined as the bit patterns of the common type match exactly.</source>
          <target state="translated">피연산자가 정수 값인 경우 &lt;a href=&quot;type#usual-arithmetic-conversions&quot;&gt;일반적인 산술 변환&lt;/a&gt; 을 적용하여 비교 전에 공통 유형으로 가져옵니다. 평등은 공통 유형의 비트 패턴이 정확히 일치하는 것으로 정의됩니다.</target>
        </trans-unit>
        <trans-unit id="47f360c49b94c4c07ce9dc61c5e3af5635a7a2ca" translate="yes" xml:space="preserve">
          <source>If the operands are of integral types, they undergo the &lt;a href=&quot;type#usual-arithmetic-conversions&quot;&gt;Usual Arithmetic Conversions&lt;/a&gt;, and then are brought to a common type using the &lt;a href=&quot;type#usual-arithmetic-conversions&quot;&gt;Usual Arithmetic Conversions&lt;/a&gt;.</source>
          <target state="translated">피연산자가 정수형의 경우, 그들은 받아야 &lt;a href=&quot;type#usual-arithmetic-conversions&quot;&gt;일반적인 산술 변환을&lt;/a&gt; 사용하여 일반적인 유형으로하게된다 다음과 &lt;a href=&quot;type#usual-arithmetic-conversions&quot;&gt;일반적인 산술 변환을&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="84b7a8c85c49e4f67e102545e92d61c9c7d7721a" translate="yes" xml:space="preserve">
          <source>If the operands are pointers, equality is defined as the bit patterns of the operands match exactly.</source>
          <target state="translated">피연산자가 포인터 인 경우 피연산자의 비트 패턴이 정확히 일치하므로 동등성이 정의됩니다.</target>
        </trans-unit>
        <trans-unit id="5b2963819db13f5d2cdfe8c71bec58c53fd098f3" translate="yes" xml:space="preserve">
          <source>If the operands are the same type, the result will be the that type.</source>
          <target state="translated">피연산자가 동일한 유형이면 결과는 해당 유형이됩니다.</target>
        </trans-unit>
        <trans-unit id="b17e0053bf5ffe1d2e67cd6799c427ff52f64545" translate="yes" xml:space="preserve">
          <source>If the operands of an associative operator + or * are floating point values, the expression is not reordered.</source>
          <target state="translated">연관 연산자 + 또는 *의 피연산자가 부동 소수점 값이면 표현식의 순서가 변경되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="1ff3f829adb0f4d6d8dd5ae222b510bf5f3ff104" translate="yes" xml:space="preserve">
          <source>If the operation would lead to an over/underflow, this function will return &lt;code&gt;0&lt;/code&gt;.</source>
          <target state="translated">작업으로 인해 오버플로 / 언더 플로가 발생하면이 함수는 &lt;code&gt;0&lt;/code&gt; 을 반환 합니다.</target>
        </trans-unit>
        <trans-unit id="988a22885dd9a150d46126a78cb644539f3b1a37" translate="yes" xml:space="preserve">
          <source>If the operator is &lt;code&gt;+&lt;/code&gt; or &lt;code&gt;-&lt;/code&gt;, and the first operand is a pointer, and the second is an integral type, the resulting type is the type of the first operand, and the resulting value is the pointer plus (or minus) the second operand multiplied by the size of the type pointed to by the first operand.</source>
          <target state="translated">연산자가 &lt;code&gt;+&lt;/code&gt; 또는 &lt;code&gt;-&lt;/code&gt; 이고 첫 번째 피연산자가 포인터이고 두 번째 피연산자가 정수 유형 인 경우 결과 유형은 첫 번째 피연산자의 유형이고 결과 값은 포인터에 두 번째 피연산자를 더한 (또는 빼기)입니다. 첫 번째 피연산자가 가리키는 유형의 크기를 곱한 값입니다.</target>
        </trans-unit>
        <trans-unit id="34ffd24d69741e93233760376d587038f7e6c1e1" translate="yes" xml:space="preserve">
          <source>If the operator is &lt;code&gt;=&lt;/code&gt; then it is simple assignment. The right operand is implicitly converted to the type of the left operand, and assigned to it.</source>
          <target state="translated">연산자가 &lt;code&gt;=&lt;/code&gt; 이면 간단한 할당입니다. 오른쪽 피연산자는 암시 적으로 왼쪽 피연산자의 유형으로 변환되어 할당됩니다.</target>
        </trans-unit>
        <trans-unit id="fd1b71b4b4c55aa30d89d8186ad8ca957d4c8944" translate="yes" xml:space="preserve">
          <source>If the optional second</source>
          <target state="translated">옵션 인 경우 두 번째</target>
        </trans-unit>
        <trans-unit id="c5921859078b177e6c63e26fb0f1ad26714bef56" translate="yes" xml:space="preserve">
          <source>If the parent allocator &lt;code&gt;Allocator&lt;/code&gt; is stateful, an instance of it is stored as a member. Otherwise, &lt;code&gt;AffixAllocator&lt;/code&gt; uses &lt;code&gt;Allocator.instance&lt;/code&gt;. In either case, the name &lt;code&gt;_parent&lt;/code&gt; is uniformly used for accessing the parent allocator.</source>
          <target state="translated">상위 할당 자 &lt;code&gt;Allocator&lt;/code&gt; 상태 저장 인 경우 해당 인스턴스는 멤버로 저장됩니다. 그렇지 않으면 &lt;code&gt;AffixAllocator&lt;/code&gt; 는 &lt;code&gt;Allocator.instance&lt;/code&gt; 를 사용합니다 . 두 경우 모두 &lt;code&gt;_parent&lt;/code&gt; 라는 이름 은 상위 할당 자에 액세스하는 데 균일하게 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="af9326a4bd5d7cb5b11db287f31708f748f7ca2d" translate="yes" xml:space="preserve">
          <source>If the passed buffer is not the last allocation, then &lt;code&gt;delta&lt;/code&gt; can be at most the number of bytes left on the last page. Otherwise, we can expand the last allocation until the end of the virtual address range.</source>
          <target state="translated">전달 된 버퍼가 마지막 할당이 아닌 경우 &lt;code&gt;delta&lt;/code&gt; 는 최대 마지막 페이지에 남은 바이트 수일 수 있습니다. 그렇지 않으면 가상 주소 범위가 끝날 때까지 마지막 할당을 확장 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e540ec8736760fd165d128b0a1be1fa92246d1c7" translate="yes" xml:space="preserve">
          <source>If the process associated with &lt;code&gt;pid&lt;/code&gt; has already terminated, &lt;code&gt;tryWait&lt;/code&gt; has the exact same effect as &lt;code&gt;wait&lt;/code&gt;. In this case, it returns a tuple where the &lt;code&gt;terminated&lt;/code&gt; field is set to &lt;code&gt;true&lt;/code&gt; and the &lt;code&gt;status&lt;/code&gt; field has the same interpretation as the return value of &lt;code&gt;wait&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;pid&lt;/code&gt; 와 관련된 프로세스 가 이미 종료 된 경우 &lt;code&gt;tryWait&lt;/code&gt; 는 &lt;code&gt;wait&lt;/code&gt; 와 동일한 효과를 갖습니다 . 이 경우, 튜플 반환 &lt;code&gt;terminated&lt;/code&gt; 필드가 설정되어 &lt;code&gt;true&lt;/code&gt; 과 &lt;code&gt;status&lt;/code&gt; 필드의 반환 값과 같은 해석이 &lt;code&gt;wait&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0cc712808d5442951029c772a2016b0fbaebf6a3" translate="yes" xml:space="preserve">
          <source>If the process has</source>
          <target state="translated">프로세스가</target>
        </trans-unit>
        <trans-unit id="8a1cda6113d7bf95379f37d69fe6660204f54b65" translate="yes" xml:space="preserve">
          <source>If the process has already terminated, this function returns directly. The exit code is cached, so that if wait() is called multiple times on the same &lt;a href=&quot;#Pid&quot;&gt;&lt;code&gt;Pid&lt;/code&gt;&lt;/a&gt; it will always return the same value.</source>
          <target state="translated">프로세스가 이미 종료 된 경우이 함수는 직접 리턴합니다. 종료 코드가 캐시되므로 동일한 &lt;a href=&quot;#Pid&quot;&gt; &lt;code&gt;Pid&lt;/code&gt; &lt;/a&gt; 에서 wait ()가 여러 번 호출 되면 항상 동일한 값을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="04681d73e96e38582bd8e0a705f2c67039e3da37" translate="yes" xml:space="preserve">
          <source>If the process is terminated by a signal, the &lt;code&gt;status&lt;/code&gt; field of the return value will contain a negative number whose absolute value is the signal number. (See &lt;a href=&quot;#wait&quot;&gt;&lt;code&gt;wait&lt;/code&gt;&lt;/a&gt; for details.)</source>
          <target state="translated">프로세스가 신호에 의해 종료되면, 리턴 값 의 &lt;code&gt;status&lt;/code&gt; 필드는 절대 값이 신호 번호 인 음수를 포함합니다. (자세한 내용은 &lt;a href=&quot;#wait&quot;&gt; &lt;code&gt;wait&lt;/code&gt; &lt;/a&gt; 를 참조하십시오.)</target>
        </trans-unit>
        <trans-unit id="2cb4ce468479df22f5efb3ab328110646f8f6c12" translate="yes" xml:space="preserve">
          <source>If the process is terminated by a signal, this function returns a negative number whose absolute value is the signal number. Since POSIX restricts normal exit codes to the range 0-255, a negative return value will always indicate termination by signal. Signal codes are defined in the &lt;code&gt;core.sys.posix.signal&lt;/code&gt; module (which corresponds to the &lt;code&gt;signal.h&lt;/code&gt; POSIX header).</source>
          <target state="translated">프로세스가 신호에 의해 종료되면이 함수는 절대 값이 신호 번호 인 음수를 반환합니다. POSIX는 일반 종료 코드를 0-255 범위로 제한하기 때문에 음수 리턴 값은 항상 신호에 의한 종료를 나타냅니다. 신호 코드는 &lt;code&gt;core.sys.posix.signal&lt;/code&gt; 모듈 ( &lt;code&gt;signal.h&lt;/code&gt; POSIX 헤더에 해당)에 정의되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="55d51d320c375e52c1f5d554f57416c612f36789" translate="yes" xml:space="preserve">
          <source>If the range is already the lexicographically greatest even permutation, it is permuted back to the least even permutation and false is returned. Otherwise, true is returned, and the range is modified in-place to be the lexicographically next even permutation.</source>
          <target state="translated">범위가 사전 순으로 가장 큰 짝수 순열 인 경우, 최소 짝수 순열로 다시 순열되고 false가 리턴됩니다. 그렇지 않으면 true가 리턴되고 범위가 사 전적으로 다음 순열로 수정됩니다.</target>
        </trans-unit>
        <trans-unit id="b6341c08a4c104d5a17945be30a12feeaa49cdba" translate="yes" xml:space="preserve">
          <source>If the range is currently the lexicographically greatest permutation, it is permuted back to the least permutation and false is returned. Otherwise, true is returned. One can thus generate all permutations of a range by sorting it according to &lt;code&gt;less&lt;/code&gt;, which produces the lexicographically least permutation, and then calling nextPermutation until it returns false. This is guaranteed to generate all distinct permutations of the range exactly once. If there are</source>
          <target state="translated">범위가 현재 사 전적으로 가장 큰 순열 인 경우, 최소 순열로 다시 순열되고 false가 리턴됩니다. 그렇지 않으면 true가 리턴됩니다. 따라서 범위에 대한 모든 순열은 &lt;code&gt;less&lt;/code&gt; 에 따라 정렬 하여 사전 순으로 최소 순열을 생성 한 다음 false를 리턴 할 때까지 nextPermutation을 호출 하여 범위의 모든 순열을 생성 할 수 있습니다 . 이것은 범위의 모든 뚜렷한 순열을 정확히 한 번만 생성하도록 보장됩니다. 만일 거기에</target>
        </trans-unit>
        <trans-unit id="3c682555e85edc7cea0e0b4d1aeb80e941ac4580" translate="yes" xml:space="preserve">
          <source>If the range runs out before &lt;code&gt;n&lt;/code&gt; elements, &lt;code&gt;take&lt;/code&gt; simply returns the entire range (unlike &lt;a href=&quot;#takeExactly&quot;&gt;&lt;code&gt;takeExactly&lt;/code&gt;&lt;/a&gt;, which will cause an assertion failure if the range ends prematurely):</source>
          <target state="translated">범위가 &lt;code&gt;n&lt;/code&gt; 개의 요소 보다 앞에 있으면 &lt;code&gt;take&lt;/code&gt; 는 전체 범위를 반환합니다 ( &lt;a href=&quot;#takeExactly&quot;&gt; &lt;code&gt;takeExactly&lt;/code&gt; &lt;/a&gt; 와 달리 범위가 조기에 종료되면 어설 션 오류가 발생 함).</target>
        </trans-unit>
        <trans-unit id="0bfb47486948f76918fc7de4a55b72efe69b4181" translate="yes" xml:space="preserve">
          <source>If the ranges are strings, &lt;code&gt;cmp&lt;/code&gt; performs UTF decoding appropriately and compares the ranges one code point at a time.</source>
          <target state="translated">범위가 문자열 인 경우 &lt;code&gt;cmp&lt;/code&gt; 는 UTF 디코딩을 적절하게 수행하고 한 번에 한 코드 포인트 씩 범위를 비교합니다.</target>
        </trans-unit>
        <trans-unit id="ea41ed6834ee0093fe72c06e40f7dc343689c14c" translate="yes" xml:space="preserve">
          <source>If the restrictions above are met, the following copy constructor is generated:</source>
          <target state="translated">위의 제한이 충족되면 다음과 같은 복사 생성자가 생성됩니다.</target>
        </trans-unit>
        <trans-unit id="7f1cd9d3b49d8a1f62d192e4c5f4c5d296e6ef4a" translate="yes" xml:space="preserve">
          <source>If the return type is int, and the result can't fit in an int, then the closest value that can be held in 32 bits will be used (so &lt;code&gt;int.max&lt;/code&gt; if it goes over and &lt;code&gt;int.min&lt;/code&gt; if it goes under). However, no attempt is made to deal with integer overflow if the return type is long.</source>
          <target state="translated">반환 유형이 int이고 결과가 int에 맞지 않으면 32 비트로 보유 할 수있는 가장 가까운 값이 사용됩니다 (따라서 &lt;code&gt;int.max&lt;/code&gt; , 넘어 가면 &lt;code&gt;int.min&lt;/code&gt; ). . 그러나 리턴 유형이 긴 경우 정수 오버 플로우를 처리하려고 시도하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="dd2f2570182620b9927043173b24e489663dd5b6" translate="yes" xml:space="preserve">
          <source>If the return value is not equal to x, the FE_INEXACT exception is raised.</source>
          <target state="translated">반환 값이 x와 같지 않으면 FE_INEXACT 예외가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="d430fac68e42265828ef3bb0905404a148953d53" translate="yes" xml:space="preserve">
          <source>If the right-hand side is also a Checked but with a different hook or underlying type, the hook and underlying type of this Checked takes precedence.</source>
          <target state="translated">오른쪽도 Checked이지만 다른 후크 또는 기본 유형 인 경우이 Checked의 후크 및 기본 유형이 우선합니다.</target>
        </trans-unit>
        <trans-unit id="decd65c423494fe4dd1111ea2c9da5871cfb6a35" translate="yes" xml:space="preserve">
          <source>If the second argument's length is less than that of the range indexed, an exception is thrown.</source>
          <target state="translated">두 번째 인수의 길이가 색인화 된 범위의 길이보다 작 으면 예외가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="09c0c3ad5616d292e80fb1d35bad8dff429d7620" translate="yes" xml:space="preserve">
          <source>If the second character of &lt;code&gt;path&lt;/code&gt; is a colon (&lt;code&gt;':'&lt;/code&gt;), the first character is interpreted as a drive letter, and must be in the range A-Z (case insensitive).</source>
          <target state="translated">&lt;code&gt;path&lt;/code&gt; 의 두 번째 문자 가 콜론 ( &lt;code&gt;':'&lt;/code&gt; ) 인 경우 첫 번째 문자는 드라이브 문자로 해석되며 AZ (대소 문자 구분) 범위에 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="c8d361e2ea8510e2f9b6eea1c593f762c25ea047" translate="yes" xml:space="preserve">
          <source>If the second operand is a pointer, and the first is an integral type, and the operator is &lt;code&gt;+&lt;/code&gt;, the operands are reversed and the pointer arithmetic just described is applied.</source>
          <target state="translated">두 번째 피연산자가 포인터이고 첫 번째 피연산자가 정수 유형이고 연산자가 &lt;code&gt;+&lt;/code&gt; 인 경우 피연산자가 반전되고 방금 설명한 포인터 산술이 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="32b0c9d866faa45199f7035225674aa790902392" translate="yes" xml:space="preserve">
          <source>If the sequence ending at &lt;code&gt;startIdx&lt;/code&gt; does not represent a well formed codepoint, then a &lt;a href=&quot;std_utf#UTFException&quot;&gt;&lt;code&gt;std.utf.UTFException&lt;/code&gt;&lt;/a&gt; may be thrown.  &lt;code&gt;cs&lt;/code&gt; indicates whether the comparisons are case sensitive.</source>
          <target state="translated">&lt;code&gt;startIdx&lt;/code&gt; 로 끝나는 시퀀스 가 올바르게 구성된 코드 포인트를 나타내지 않으면 &lt;a href=&quot;std_utf#UTFException&quot;&gt; &lt;code&gt;std.utf.UTFException&lt;/code&gt; 이&lt;/a&gt; 발생할 수 있습니다. &lt;code&gt;cs&lt;/code&gt; 는 비교가 대소 문자를 구분하는지 여부를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="a37342eba6058b3aa514ecc3e65805a0fa7ec8d8" translate="yes" xml:space="preserve">
          <source>If the sequence is a</source>
          <target state="translated">시퀀스가</target>
        </trans-unit>
        <trans-unit id="6e3f474a691ae0e04c816db20a8a1ee2782164f2" translate="yes" xml:space="preserve">
          <source>If the sequence starting at &lt;code&gt;startIdx&lt;/code&gt; does not represent a well formed codepoint, then a &lt;a href=&quot;std_utf#UTFException&quot;&gt;&lt;code&gt;std.utf.UTFException&lt;/code&gt;&lt;/a&gt; may be thrown.</source>
          <target state="translated">&lt;code&gt;startIdx&lt;/code&gt; 에서 시작하는 시퀀스 가 올바르게 구성된 코드 포인트를 나타내지 않으면 &lt;a href=&quot;std_utf#UTFException&quot;&gt; &lt;code&gt;std.utf.UTFException&lt;/code&gt; 이&lt;/a&gt; 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2ca37c345a633b86c3f0a8d6f14512c0f7890283" translate="yes" xml:space="preserve">
          <source>If the sign bit is set (that is, it's 'negative'), NAN is less than any number; if the sign bit is not set (it is 'positive'), NAN is greater than any number;</source>
          <target state="translated">부호 비트가 설정되면 (즉, '음수') NAN은 임의의 수보다 작습니다. 부호 비트가 설정되지 않은 경우 ( '긍정') NAN은 임의의 수보다 큽니다.</target>
        </trans-unit>
        <trans-unit id="ad31a32f0506299a66cf84413a7632e943786b66" translate="yes" xml:space="preserve">
          <source>If the signed type is larger than the unsigned type, the unsigned type is converted to the signed type.</source>
          <target state="translated">서명 된 유형이 서명되지 않은 유형보다 크면 서명되지 않은 유형이 서명 된 유형으로 변환됩니다.</target>
        </trans-unit>
        <trans-unit id="e9a551f8b9f105f8f42e469f990b7c6973a86a1b" translate="yes" xml:space="preserve">
          <source>If the slice bounds can be known at compile time, the slice expression is implicitly convertible to an lvalue of static array. For example:</source>
          <target state="translated">컴파일시 슬라이스 경계를 ​​알 수있는 경우 슬라이스 식은 암시 적으로 lvalue의 정적 배열로 변환 할 수 있습니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="6ad59f15848db49d072bd8cb912bde77ae2b6ed6" translate="yes" xml:space="preserve">
          <source>If the source file does not start with a BOM, then the first character must be less than or equal to U+0000007F.</source>
          <target state="translated">소스 파일이 BOM으로 시작하지 않으면 첫 번째 문자는 U + 0000007F보다 작거나 같아야합니다.</target>
        </trans-unit>
        <trans-unit id="b27e4bb1c5315e54c4ca57d01e83f479ac84dbd7" translate="yes" xml:space="preserve">
          <source>If the string data is UTF-8 and can be accessed directly, return a pointer to it. Do not assume a terminating 0.</source>
          <target state="translated">문자열 데이터가 UTF-8이고 직접 액세스 할 수 있으면 포인터를 리턴하십시오. 종료 0을 가정하지 마십시오.</target>
        </trans-unit>
        <trans-unit id="5f0ad93f155cd5ae6b24670f9767f5398de5e539" translate="yes" xml:space="preserve">
          <source>If the string does not contain an ampersand, the original will be returned.</source>
          <target state="translated">문자열에 앰퍼샌드가 포함되어 있지 않으면 원본이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="1aa7c7c38f043029163560616539bec8cc7f49c1" translate="yes" xml:space="preserve">
          <source>If the string is not a legitimate IPv4 address, &lt;code&gt;ADDR_NONE&lt;/code&gt; is returned.</source>
          <target state="translated">문자열이 정당한 IPv4 주소가 아닌 경우 &lt;code&gt;ADDR_NONE&lt;/code&gt; 이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="b15b906e5c8636437606a7baf9615fdd3533eb67" translate="yes" xml:space="preserve">
          <source>If the string is not modified, the original will be returned.</source>
          <target state="translated">문자열을 수정하지 않으면 원본이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="52f9a3df378000710aaee65a7a54a47ac2ca66c0" translate="yes" xml:space="preserve">
          <source>If the struct defines a &lt;b&gt;toString()&lt;/b&gt; method the result is the string returned from this function. Otherwise the result is StructName(field&lt;sub&gt;0&lt;/sub&gt;, field&lt;sub&gt;1&lt;/sub&gt;, ...) where field&lt;sub&gt;n&lt;/sub&gt; is the nth element formatted with the default format.</source>
          <target state="translated">구조체가 &lt;b&gt;toString ()&lt;/b&gt; 메서드를 정의 하면 결과는이 함수에서 반환 된 문자열입니다. 그렇지 않으면 결과는 StructName (field &lt;sub&gt;0&lt;/sub&gt; , field &lt;sub&gt;1&lt;/sub&gt; , ...)입니다. 여기서 필드 &lt;sub&gt;n&lt;/sub&gt; 은 기본 형식으로 형식이 지정된 n 번째 요소입니다.</target>
        </trans-unit>
        <trans-unit id="479988510a7f9556e5fa41c90de2fc0cc635572b" translate="yes" xml:space="preserve">
          <source>If the switch &lt;a href=&quot;expression#Expression&quot;&gt;&lt;i&gt;Expression&lt;/i&gt;&lt;/a&gt; is of enum type, all the enum members must appear in the &lt;a href=&quot;#CaseStatement&quot;&gt;&lt;i&gt;CaseStatement&lt;/i&gt;&lt;/a&gt;s.</source>
          <target state="translated">스위치 &lt;a href=&quot;expression#Expression&quot;&gt;&lt;i&gt;Expression&lt;/i&gt;&lt;/a&gt; 이 열거 형인 경우 모든 열거 형 멤버가 &lt;a href=&quot;#CaseStatement&quot;&gt;&lt;i&gt;CaseStatement에 나타나야&lt;/i&gt;&lt;/a&gt; 합니다.</target>
        </trans-unit>
        <trans-unit id="a0154ff095266436fcdfa44d46155c17b50639bb" translate="yes" xml:space="preserve">
          <source>If the switch &lt;code&gt;--DRT-testmode&lt;/code&gt; is passed to the executable, it can have one of 3 values: 1. &quot;run-main&quot;: even if unit tests are run (and all pass), main is still run. This is currently the default. 2. &quot;test-or-main&quot;: any unit tests present will cause the program to summarize the results and exit regardless of the result. This will be the default in 2.080. 3. &quot;test-only&quot;, the runtime will always summarize and never run main, even if no tests are present.</source>
          <target state="translated">스위치 &lt;code&gt;--DRT-testmode&lt;/code&gt; 가 실행 파일로 전달되면 3 가지 값 중 하나를 가질 수 있습니다. 1. &quot;run-main&quot;: 단위 테스트가 실행되고 모든 패스가 실행 되더라도 main이 여전히 실행됩니다. 이것이 현재 기본값입니다. &quot;test-or-main&quot;: 존재하는 모든 유닛 테스트는 프로그램이 결과를 요약하고 결과에 관계없이 종료되게합니다. 이것이 2.080의 기본값입니다. 3. &quot;테스트 전용&quot;인 경우, 테스트가 존재하지 않더라도 런타임은 항상 요약하고 메인을 실행하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="cefab3eab3f045d8e153ce4eb6c35b376eb78553" translate="yes" xml:space="preserve">
          <source>If the thread hasn't been started yet, returns &lt;a href=&quot;#ThreadID&quot;&gt;&lt;code&gt;ThreadID&lt;/code&gt;&lt;/a&gt;&lt;code&gt;.init&lt;/code&gt;. Otherwise, returns the result of &lt;code&gt;GetCurrentThreadId&lt;/code&gt; on Windows, and &lt;code&gt;pthread_self&lt;/code&gt; on POSIX.  The value is unique for the current process.</source>
          <target state="translated">스레드가 아직 시작되지 않은 경우 &lt;a href=&quot;#ThreadID&quot;&gt; &lt;code&gt;ThreadID&lt;/code&gt; &lt;/a&gt; &lt;code&gt;.init&lt;/code&gt; 를 리턴합니다 . 그렇지 않으면 Windows에서는 &lt;code&gt;GetCurrentThreadId&lt;/code&gt; , POSIX 에서는 &lt;code&gt;pthread_self&lt;/code&gt; 의 결과를 반환합니다 . 이 값은 현재 프로세스에 고유합니다.</target>
        </trans-unit>
        <trans-unit id="6c09982745040566b9680ca05a80be2c692c0e01" translate="yes" xml:space="preserve">
          <source>If the time zone is &lt;code&gt;&quot;-0000&quot;&lt;/code&gt; (or considered to be equivalent to &lt;code&gt;&quot;-0000&quot;&lt;/code&gt; by section 4.3 of the spec), a &lt;a href=&quot;std_datetime_timezone#SimpleTimeZone&quot;&gt;&lt;code&gt;std.datetime.timezone.SimpleTimeZone&lt;/code&gt;&lt;/a&gt; with a utc offset of &lt;code&gt;0&lt;/code&gt; is used rather than &lt;a href=&quot;std_datetime_timezone#UTC&quot;&gt;&lt;code&gt;std.datetime.timezone.UTC&lt;/code&gt;&lt;/a&gt;, whereas &lt;code&gt;&quot;+0000&quot;&lt;/code&gt; uses &lt;a href=&quot;std_datetime_timezone#UTC&quot;&gt;&lt;code&gt;std.datetime.timezone.UTC&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">시간대가 &lt;code&gt;&quot;-0000&quot;&lt;/code&gt; (또는 사양의 섹션 4.3 에서 &lt;code&gt;&quot;-0000&quot;&lt;/code&gt; 과 동등한 것으로 간주 됨 ) 인 경우 &lt;a href=&quot;std_datetime_timezone#SimpleTimeZone&quot;&gt; &lt;code&gt;std.datetime.timezone.SimpleTimeZone&lt;/code&gt; &lt;/a&gt; 대신 utc 오프셋이 &lt;code&gt;0&lt;/code&gt; 인&lt;a href=&quot;std_datetime_timezone#UTC&quot;&gt; &lt;code&gt;std.datetime.timezone.UTC&lt;/code&gt; &lt;/a&gt; 이 사용됩니다 . timezone.UTC , &lt;code&gt;&quot;+0000&quot;&lt;/code&gt; 은 &lt;a href=&quot;std_datetime_timezone#UTC&quot;&gt; &lt;code&gt;std.datetime.timezone.UTC&lt;/code&gt; 를&lt;/a&gt; 사용 합니다 .</target>
        </trans-unit>
        <trans-unit id="3134e4dcc33577153221f4543bd47086f16438e4" translate="yes" xml:space="preserve">
          <source>If the two arguments are both lambda functions (or aliases to lambda functions), then they are compared for equality. For the comparison to be computed correctly, the following conditions must be met for both lambda functions:</source>
          <target state="translated">두 인수가 모두 람다 함수 (또는 람다 함수의 별명) 인 경우 동등성을 비교합니다. 비교가 올바르게 계산 되려면 두 람다 함수 모두에 대해 다음 조건이 충족되어야합니다.</target>
        </trans-unit>
        <trans-unit id="73a39971fe15042884479dfdbb241d4da31bea94" translate="yes" xml:space="preserve">
          <source>If the two arguments are expressions made up of literals or enums that evaluate to the same value, true is returned.</source>
          <target state="translated">두 인수가 동일한 값으로 평가되는 리터럴 또는 열거로 구성된 표현식 인 경우 true가 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="a4473404d01a76d50b04f7848135307a27ac80f3" translate="yes" xml:space="preserve">
          <source>If the two operands are different enums, the result is the closest base type common to both. A base type being closer means there is a shorter sequence of conversions to base type to get there from the original type.</source>
          <target state="translated">두 피연산자가 서로 다른 열거 형이면 결과는 둘 다에 가장 가까운 기본 유형입니다. 기본 유형이 더 가깝다는 것은 기본 유형으로 변환하기 위해 기본 유형으로 변환하는 시퀀스가 ​​짧다는 것을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="b866fed7529b50ec607a768135519745618bce85" translate="yes" xml:space="preserve">
          <source>If the type is a class or struct, returns the symbol for it, else null.</source>
          <target state="translated">유형이 클래스 또는 구조체이면 해당 기호를 반환하고, 그렇지 않으면 null을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="9cf47ab4617bfcf6525f2e55361b003e49f6a33c" translate="yes" xml:space="preserve">
          <source>If the type of a function literal can be uniquely determined from its context, the parameter type inference is possible.</source>
          <target state="translated">함수 리터럴의 유형을 컨텍스트에서 고유하게 판별 할 수 있으면 매개 변수 유형 유추가 가능합니다.</target>
        </trans-unit>
        <trans-unit id="bd9e26eaa127a0681e40e687c51d18388c1cb11f" translate="yes" xml:space="preserve">
          <source>If the type specialization is dependent on a type parameter, the type of that parameter is set to be the corresponding part of the type argument.</source>
          <target state="translated">유형 특수화가 유형 매개 변수에 종속되는 경우 해당 매개 변수의 유형은 유형 인수의 해당 부분으로 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="c38cd0e42755b32d0615eb6b41299ea06a9e9a58" translate="yes" xml:space="preserve">
          <source>If the union defines a &lt;b&gt;toString()&lt;/b&gt; method the result is the string returned from this function. Otherwise the result is the name of the union, without its contents.</source>
          <target state="translated">공용체가 &lt;b&gt;toString ()&lt;/b&gt; 메소드를 정의 하면 결과는이 함수에서 리턴 된 문자열입니다. 그렇지 않으면 결과는 내용이없는 조합의 이름입니다.</target>
        </trans-unit>
        <trans-unit id="5b79753b6512691a7580a1aa8dec230051399447" translate="yes" xml:space="preserve">
          <source>If the union is larger than the first field, the remaining bits are set to 0.</source>
          <target state="translated">공용체가 첫 번째 필드보다 큰 경우 나머지 비트는 0으로 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="47d795dfceba0f8eb2492f885994a47e15c6743a" translate="yes" xml:space="preserve">
          <source>If the union is larger than the initialized field, the remaining bits are set to 0.</source>
          <target state="translated">공용체가 초기화 된 필드보다 큰 경우 나머지 비트는 0으로 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="c1ceb76e55274ade5913babacd57bf4f1cb70312" translate="yes" xml:space="preserve">
          <source>If the user-provided size is zero or the user-provided buffer is empty, throws an &lt;code&gt;Exception&lt;/code&gt;. In case of an I/O error throws &lt;code&gt;StdioException&lt;/code&gt;.</source>
          <target state="translated">사용자 제공 크기가 0이거나 사용자 제공 버퍼가 비어 있으면 &lt;code&gt;Exception&lt;/code&gt; 이 발생 합니다. I / O 오류가 발생 &lt;code&gt;StdioException&lt;/code&gt; 합니다.</target>
        </trans-unit>
        <trans-unit id="cc7558759f1a8352a99aba9fedf7f766fc85394c" translate="yes" xml:space="preserve">
          <source>If the variable does not exist, it will be created. If it already exists, it will be overwritten.</source>
          <target state="translated">변수가 존재하지 않으면 작성됩니다. 이미 존재하는 경우 덮어 씁니다.</target>
        </trans-unit>
        <trans-unit id="1eb649b3e71267d6372924b026c8a8d1534bf07a" translate="yes" xml:space="preserve">
          <source>If the variable isn't in the environment, this function returns successfully without doing anything.</source>
          <target state="translated">변수가 환경에 없으면이 함수는 아무 것도하지 않고 성공적으로 반환합니다.</target>
        </trans-unit>
        <trans-unit id="d13d09fdf461257eb1bc31ba932d5204cebf3e15" translate="yes" xml:space="preserve">
          <source>If the variadic parameter is an array of delegates with no parameters:</source>
          <target state="translated">variadic 매개 변수가 매개 변수가없는 대리자 배열 인 경우 :</target>
        </trans-unit>
        <trans-unit id="a4c2f19305902bafa0ffed68f37389b9cbdc3d33" translate="yes" xml:space="preserve">
          <source>If there are fewer arguments supplied in the</source>
          <target state="translated">제공되는 인수가 더 적은 경우</target>
        </trans-unit>
        <trans-unit id="137908701928a250c21674b47c9c08664cb6489d" translate="yes" xml:space="preserve">
          <source>If there are multiple</source>
          <target state="translated">여러 개가있는 경우</target>
        </trans-unit>
        <trans-unit id="9d520e5d39ca368a2b272ce1cc53485c938b54ac" translate="yes" xml:space="preserve">
          <source>If there are multiple &lt;code&gt;return ref&lt;/code&gt; parameters, the lifetime of the return value is the smallest lifetime of the corresponding arguments.</source>
          <target state="translated">&lt;code&gt;return ref&lt;/code&gt; 매개 변수 가 여러 개인 경우 리턴 값의 수명은 해당 인수의 수명이 가장 짧습니다.</target>
        </trans-unit>
        <trans-unit id="e237e9fe68b8078484793ae54d1c1e4290772666" translate="yes" xml:space="preserve">
          <source>If there are multiple UDAs in scope for a declaration, they are concatenated:</source>
          <target state="translated">선언 범위에 여러 UDA가있는 경우 다음과 같이 연결됩니다.</target>
        </trans-unit>
        <trans-unit id="d33b5562bbab16d600772bb0c4e960b31c667c22" translate="yes" xml:space="preserve">
          <source>If there are multiple pragma inlines in a function, the lexically last one takes effect.</source>
          <target state="translated">함수에 여러 개의 pragma 인라인이 있으면 어휘 적으로 마지막 인라인이 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="c4b327a5dc42638f7be9041ec07ceb89c1cacdad" translate="yes" xml:space="preserve">
          <source>If there are no arguments, the result is &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">인수가 없으면 결과는 &lt;code&gt;false&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="b4600b295ae3596b41be4670d227eb72326970dd" translate="yes" xml:space="preserve">
          <source>If there are no user-defined attributes for the symbol, an empty tuple is returned. The expression tuple can be turned into a manipulatable tuple:</source>
          <target state="translated">심볼에 대한 사용자 정의 속성이 없으면 빈 튜플이 반환됩니다. 튜플 표현은 조작 가능한 튜플로 바뀔 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e49abc2a9f1f1c709edab2a411a4d0eb933f0f8e" translate="yes" xml:space="preserve">
          <source>If there are two symbols declared, the first is the</source>
          <target state="translated">두 개의 기호가 선언 된 경우 첫 번째 기호는</target>
        </trans-unit>
        <trans-unit id="3df841c41211bfc9016bcff2ddd45752571711df" translate="yes" xml:space="preserve">
          <source>If there is a &lt;code&gt;new (&lt;/code&gt;&lt;a href=&quot;#ArgumentList&quot;&gt;&lt;i&gt;ArgumentList&lt;/i&gt;&lt;/a&gt;&lt;code&gt;)&lt;/code&gt;, then those arguments are passed to the class or struct specific &lt;a href=&quot;class#allocators&quot;&gt;allocator function&lt;/a&gt; after the size argument.</source>
          <target state="translated">&lt;code&gt;new (&lt;/code&gt; &lt;a href=&quot;#ArgumentList&quot;&gt;&lt;i&gt;ArgumentList&lt;/i&gt;&lt;/a&gt; &lt;code&gt;)&lt;/code&gt; 이 있으면 해당 인수는 size 인수 다음에 클래스 또는 구조체 특정 &lt;a href=&quot;class#allocators&quot;&gt;할당 자 함수로&lt;/a&gt; 전달됩니다.</target>
        </trans-unit>
        <trans-unit id="4a441171bce481c9de8d817376b233adfcdc1d3d" translate="yes" xml:space="preserve">
          <source>If there is a constructor defined for the class, the constructor matching the argument list is called.</source>
          <target state="translated">클래스에 대해 생성자가 정의되어 있으면 인수 목록과 일치하는 생성자가 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="2b9a54f4a31088d1176dc7dd4ca3c5a15fce19ea" translate="yes" xml:space="preserve">
          <source>If there is a constructor defined for the struct, the constructor matching the argument list is called.</source>
          <target state="translated">구조체에 대해 생성자가 정의되어 있으면 인수 목록과 일치하는 생성자가 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="6070235a5fc84c6102f81ad3d99d47f62b8d7355" translate="yes" xml:space="preserve">
          <source>If there is an &lt;a href=&quot;expression#Expression&quot;&gt;&lt;i&gt;Expression&lt;/i&gt;&lt;/a&gt;, it must evaluate to either an Object or an instance of an</source>
          <target state="translated">&lt;a href=&quot;expression#Expression&quot;&gt;&lt;i&gt;Expression&lt;/i&gt;&lt;/a&gt; 이 있으면 Object 또는 Object의 인스턴스로 평가해야합니다.</target>
        </trans-unit>
        <trans-unit id="5a13d6eff463d638a1f16cd2e1b1291d41f27d35" translate="yes" xml:space="preserve">
          <source>If there is an out postcondition (see &lt;a href=&quot;contracts&quot;&gt;Contract Programming&lt;/a&gt;), that postcondition is executed after the &lt;a href=&quot;expression#Expression&quot;&gt;&lt;i&gt;Expression&lt;/i&gt;&lt;/a&gt; is evaluated and before the function actually returns.</source>
          <target state="translated">사후 조건이없는 경우 ( &lt;a href=&quot;contracts&quot;&gt;계약 프로그래밍&lt;/a&gt; 참조 ) 해당 사후 조건은 &lt;a href=&quot;expression#Expression&quot;&gt;&lt;i&gt;표현식&lt;/i&gt;&lt;/a&gt; 이 평가 된 후 함수가 실제로 리턴되기 전에 실행 됩니다.</target>
        </trans-unit>
        <trans-unit id="f306e547fcde96fa296d39ba4173abf9b358bd47" translate="yes" xml:space="preserve">
          <source>If there is more than one &lt;code&gt;scope&lt;/code&gt; variable going out of scope at the same point, then the destructors are called in the reverse order that the variables were constructed.</source>
          <target state="translated">같은 지점에서 범위를 &lt;code&gt;scope&lt;/code&gt; 변수 가 둘 이상 있으면 소멸자는 변수가 구성된 순서와 반대로 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="f9d4b8b7f08b3f6307ae69aa1e6c9c14710481c3" translate="yes" xml:space="preserve">
          <source>If there is no &lt;a href=&quot;expression#AssignExpression&quot;&gt;&lt;i&gt;AssignExpression&lt;/i&gt;&lt;/a&gt; and it is not the first</source>
          <target state="translated">&lt;a href=&quot;expression#AssignExpression&quot;&gt;&lt;i&gt;AssignExpression&lt;/i&gt;&lt;/a&gt; 이없고 처음이 아닌 경우</target>
        </trans-unit>
        <trans-unit id="b034aafdece95219928b4d5ae1779c324d51f861" translate="yes" xml:space="preserve">
          <source>If there is no constructor for a class, but there is a constructor for the base class, a default constructor is implicitly generated with the form:</source>
          <target state="translated">클래스의 생성자가 없지만 기본 클래스의 생성자가있는 경우 기본 생성자는 다음 형식으로 내재적으로 생성됩니다.</target>
        </trans-unit>
        <trans-unit id="8a089796c9cda4645dac5b38c15d592eebc4d1ab" translate="yes" xml:space="preserve">
          <source>If there is no default return expression and the predicate does not yield true with any test expression - &lt;code&gt;SwitchError&lt;/code&gt; is thrown. &lt;code&gt;SwitchError&lt;/code&gt; is also thrown if a void return expression was executed without throwing anything.</source>
          <target state="translated">기본 리턴 표현식이없고 테스트 표현식에서 술어가 true를 생성하지 않으면 &lt;code&gt;SwitchError&lt;/code&gt; 가 발생합니다. 아무것도 리턴하지 않고 void 리턴 표현식이 실행 된 경우에도 &lt;code&gt;SwitchError&lt;/code&gt; 가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="9c729a22e9cf50dfda75e0983406587bf80017e7" translate="yes" xml:space="preserve">
          <source>If there is no documentation comment for a declaration, that declaration may not appear in the output. To ensure it does appear in the output, put an empty declaration comment for it.</source>
          <target state="translated">선언에 대한 문서 주석이 없으면 해당 선언이 출력에 나타나지 않을 수 있습니다. 출력에 표시되도록하려면 빈 선언 주석을 넣으십시오.</target>
        </trans-unit>
        <trans-unit id="6fce9903fe99732c7b1d983701bee8c33b687b65" translate="yes" xml:space="preserve">
          <source>If there is no time zone in the string, then &lt;a href=&quot;std_datetime_timezone#LocalTime&quot;&gt;&lt;code&gt;std.datetime.timezone.LocalTime&lt;/code&gt;&lt;/a&gt; is used. If the time zone is &quot;Z&quot;, then &lt;code&gt;UTC&lt;/code&gt; is used. Otherwise, a &lt;a href=&quot;std_datetime_timezone#SimpleTimeZone&quot;&gt;&lt;code&gt;std.datetime.timezone.SimpleTimeZone&lt;/code&gt;&lt;/a&gt; which corresponds to the given offset from UTC is used. To get the returned &lt;a href=&quot;#SysTime&quot;&gt;&lt;code&gt;SysTime&lt;/code&gt;&lt;/a&gt; to be a particular time zone, pass in that time zone and the &lt;a href=&quot;#SysTime&quot;&gt;&lt;code&gt;SysTime&lt;/code&gt;&lt;/a&gt; to be returned will be converted to that time zone (though it will still be read in as whatever time zone is in its string).</source>
          <target state="translated">문자열에 시간대가 없으면 &lt;a href=&quot;std_datetime_timezone#LocalTime&quot;&gt; &lt;code&gt;std.datetime.timezone.LocalTime&lt;/code&gt; &lt;/a&gt; 이 사용됩니다. 시간대가 &quot;Z&quot;이면 &lt;code&gt;UTC&lt;/code&gt; 가 사용됩니다. 그렇지 않으면 UTC로부터 주어진 오프셋에 해당 하는 &lt;a href=&quot;std_datetime_timezone#SimpleTimeZone&quot;&gt; &lt;code&gt;std.datetime.timezone.SimpleTimeZone&lt;/code&gt; &lt;/a&gt; 이 사용됩니다. 반환 된 &lt;a href=&quot;#SysTime&quot;&gt; &lt;code&gt;SysTime&lt;/code&gt; &lt;/a&gt; 을 특정 시간대 로 가져 오려면 해당 시간대를 전달 하면 반환 할 &lt;a href=&quot;#SysTime&quot;&gt; &lt;code&gt;SysTime&lt;/code&gt; &lt;/a&gt; 이 해당 시간대로 변환됩니다 (문자열에 시간대가 있더라도 그대로 읽습니다).</target>
        </trans-unit>
        <trans-unit id="ecb767820c42d2c1eeab40ca9731a8e9ce9ec854" translate="yes" xml:space="preserve">
          <source>If there is no type specialization for the parameter, the type of the parameter is set to the template argument.</source>
          <target state="translated">매개 변수에 대한 유형 전문화가없는 경우 매개 변수 유형이 템플리트 인수로 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="333c6091877decb710b52473531fc9677d023463" translate="yes" xml:space="preserve">
          <source>If there is only one member of an anonymous enum, the &lt;code&gt;{ }&lt;/code&gt; can be omitted. Gramatically speaking, this is an &lt;a href=&quot;declaration#AutoDeclaration&quot;&gt;&lt;i&gt;AutoDeclaration&lt;/i&gt;&lt;/a&gt;.</source>
          <target state="translated">익명 열거 형의 멤버가 하나만 있으면 &lt;code&gt;{ }&lt;/code&gt; 을 생략 할 수 있습니다. &lt;a href=&quot;declaration#AutoDeclaration&quot;&gt;&lt;i&gt;문법적으로&lt;/i&gt;&lt;/a&gt; 말하면, 이것은 &lt;i&gt;AutoDeclaration&lt;/i&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="81c7998e55322be143bbc65f832d80e17d966603" translate="yes" xml:space="preserve">
          <source>If there's no handler for a particular error, it is handled by the runtime library default handler. If an error is ignored, it is because the programmer specifically added code to ignore an error, which presumably means it was intentional.</source>
          <target state="translated">특정 오류에 대한 핸들러가없는 경우 런타임 라이브러리 기본 핸들러에 의해 처리됩니다. 오류가 무시되면 프로그래머가 오류를 무시하기 위해 코드를 구체적으로 추가했기 때문일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1504a8955edcaca212d8f1b4743a707d2ef9fdb6" translate="yes" xml:space="preserve">
          <source>If these constraints aren't fulfilled, the function is considered incomparable and &lt;code&gt;isSame&lt;/code&gt; returns &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">이러한 제약 조건이 충족되지 않으면 함수는 비교할 수없는 것으로 간주되고 &lt;code&gt;isSame&lt;/code&gt; 은 &lt;code&gt;false&lt;/code&gt; 를 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="b28035cefdbe2f2deeefc61501ea02f89e4a353d" translate="yes" xml:space="preserve">
          <source>If they are both null, then they are equal. If one is null and the other is not, then they are not equal. If they are both non-null, then they are equal if their values are equal.</source>
          <target state="translated">둘 다 null이면 동일합니다. 하나가 널이고 다른 하나가 다르면 같지 않습니다. 둘 다 널이 아닌 경우 값이 같으면 동일합니다.</target>
        </trans-unit>
        <trans-unit id="4662c9e57a2220461566af34d1a71bfb063d8fd6" translate="yes" xml:space="preserve">
          <source>If they compare equal, return 0 else value returned by fp.</source>
          <target state="translated">동일하게 비교하면 0을 리턴하고 그렇지 않으면 fp가 리턴 한 값을 리턴하십시오.</target>
        </trans-unit>
        <trans-unit id="489bf198a6a75e62f83ca7fe9ee2482aa193539d" translate="yes" xml:space="preserve">
          <source>If they have range interface, formatted as input range.</source>
          <target state="translated">범위 인터페이스가있는 경우 입력 범위로 형식화됩니다.</target>
        </trans-unit>
        <trans-unit id="a2e48f2bb2a2bc86917d71f83c2b5a6ff9f995c9" translate="yes" xml:space="preserve">
          <source>If they have the same ptrs, return 1 else 0.</source>
          <target state="translated">그것들이 동일한 ptr을 가지고 있다면 1을 리턴하고 그렇지 않으면 0을 리턴하십시오.</target>
        </trans-unit>
        <trans-unit id="2bac3ec55e8f026836fad11da1a5ea396ba6c7f1" translate="yes" xml:space="preserve">
          <source>If this &lt;a href=&quot;#SysTime&quot;&gt;&lt;code&gt;SysTime&lt;/code&gt;&lt;/a&gt;'s time zone is &lt;a href=&quot;std_datetime_timezone#LocalTime&quot;&gt;&lt;code&gt;std.datetime.timezone.LocalTime&lt;/code&gt;&lt;/a&gt;, then TZ is empty. If its time zone is &lt;code&gt;UTC&lt;/code&gt;, then it is &quot;Z&quot;. Otherwise, it is the offset from UTC (e.g. +0100 or -0700). Note that the offset from UTC is</source>
          <target state="translated">이 &lt;a href=&quot;#SysTime&quot;&gt; &lt;code&gt;SysTime&lt;/code&gt; &lt;/a&gt; 의 시간대가 &lt;a href=&quot;std_datetime_timezone#LocalTime&quot;&gt; &lt;code&gt;std.datetime.timezone.LocalTime&lt;/code&gt; &lt;/a&gt; 인 경우 TZ는 비어 있습니다. 시간대가 &lt;code&gt;UTC&lt;/code&gt; 이면 &quot;Z&quot;입니다. 그렇지 않으면 UTC와의 오프셋입니다 (예 : +0100 또는 -0700). UTC로부터의 오프셋은</target>
        </trans-unit>
        <trans-unit id="2c514f7eb520c6d91b2201391b00ffde6396be0d" translate="yes" xml:space="preserve">
          <source>If this &lt;a href=&quot;#SysTime&quot;&gt;&lt;code&gt;SysTime&lt;/code&gt;&lt;/a&gt;'s time zone is &lt;a href=&quot;std_datetime_timezone#LocalTime&quot;&gt;&lt;code&gt;std.datetime.timezone.LocalTime&lt;/code&gt;&lt;/a&gt;, then TZ is empty. If its time zone is &lt;code&gt;UTC&lt;/code&gt;, then it is &quot;Z&quot;. Otherwise, it is the offset from UTC (e.g. +01:00 or -07:00). Note that the offset from UTC is</source>
          <target state="translated">이 &lt;a href=&quot;#SysTime&quot;&gt; &lt;code&gt;SysTime&lt;/code&gt; &lt;/a&gt; 의 시간대가 &lt;a href=&quot;std_datetime_timezone#LocalTime&quot;&gt; &lt;code&gt;std.datetime.timezone.LocalTime&lt;/code&gt; &lt;/a&gt; 인 경우 TZ는 비어 있습니다. 시간대가 &lt;code&gt;UTC&lt;/code&gt; 이면 &quot;Z&quot;입니다. 그렇지 않으면 UTC와의 오프셋입니다 (예 : +01 : 00 또는 -07 : 00). UTC로부터의 오프셋은</target>
        </trans-unit>
        <trans-unit id="59b4585a3a599edf4de86352eceb935135d14f4b" translate="yes" xml:space="preserve">
          <source>If this &lt;code&gt;Nullable&lt;/code&gt; wraps a type that already has a null value (such as a pointer), and that null value is not given for &lt;code&gt;nullValue&lt;/code&gt;, then assigning the null value to this &lt;code&gt;Nullable&lt;/code&gt; is no different than assigning any other value of type &lt;code&gt;T&lt;/code&gt;, and the resulting code will look very strange. It is strongly recommended that this be avoided by using &lt;code&gt;T&lt;/code&gt;'s &quot;built in&quot; null value for &lt;code&gt;nullValue&lt;/code&gt;.</source>
          <target state="translated">이 경우 &lt;code&gt;Nullable&lt;/code&gt; 이미 (예를 들면 포인터와 같은)는 NULL 값을 가지고있는 형태를 래핑하고 NULL 값이 주어되지 &lt;code&gt;nullValue&lt;/code&gt; 후 이에 NULL 값 할당 &lt;code&gt;Nullable&lt;/code&gt; 입력 한 임의의 다른 값이 할당 다르지 않다 &lt;code&gt;T&lt;/code&gt; 는 한 결과 코드는 매우 이상하게 보일 것입니다. &lt;code&gt;nullValue&lt;/code&gt; 에 &lt;code&gt;T&lt;/code&gt; 의 &quot;built in&quot;null 값을 사용하여이를 피하는 것이 좋습니다 .</target>
        </trans-unit>
        <trans-unit id="bacbc660925702039182b51b563933523f30696f" translate="yes" xml:space="preserve">
          <source>If this &lt;code&gt;Nullable&lt;/code&gt; wraps a type that already has a null value (such as a pointer), then assigning the null value to this &lt;code&gt;Nullable&lt;/code&gt; is no different than assigning any other value of type &lt;code&gt;T&lt;/code&gt;, and the resulting code will look very strange. It is strongly recommended that this be avoided by instead using the version of &lt;code&gt;Nullable&lt;/code&gt; that takes an additional &lt;code&gt;nullValue&lt;/code&gt; template argument.</source>
          <target state="translated">이 &lt;code&gt;Nullable&lt;/code&gt; 이 이미 널값을 갖는 유형 (예 : 포인터)을 랩핑하는 경우 널값 을이 &lt;code&gt;Nullable&lt;/code&gt; 에 지정하는 것은 &lt;code&gt;T&lt;/code&gt; 유형의 다른 값을 지정하는 것과 다르지 않으며 결과 코드는 매우 이상하게 보입니다. 추가적인 &lt;code&gt;nullValue&lt;/code&gt; 템플릿 인수 를 취하는 &lt;code&gt;Nullable&lt;/code&gt; 버전을 대신 사용하여이를 피하는 것이 좋습니다 .</target>
        </trans-unit>
        <trans-unit id="7febe77abd33adf57e913bf0a4a63eb358541f75" translate="yes" xml:space="preserve">
          <source>If this &lt;code&gt;Task&lt;/code&gt; was not started yet, execute it in the current thread. If it is finished, return its result. If it is in progress, execute any other &lt;code&gt;Task&lt;/code&gt; from the &lt;code&gt;TaskPool&lt;/code&gt; instance that this &lt;code&gt;Task&lt;/code&gt; was submitted to until this one is finished. If it threw an exception, rethrow that exception. If no other tasks are available or this &lt;code&gt;Task&lt;/code&gt; was executed using &lt;code&gt;executeInNewThread&lt;/code&gt;, wait on a condition variable.</source>
          <target state="translated">이 &lt;code&gt;Task&lt;/code&gt; 이 아직 시작되지 않은 경우 현재 스레드에서 실행하십시오. 완료되면 결과를 반환하십시오. 진행중인 경우이 &lt;code&gt;Task&lt;/code&gt; 이 완료 될 때까지이 작업 이 제출 된 &lt;code&gt;TaskPool&lt;/code&gt; 인스턴스 에서 다른 &lt;code&gt;Task&lt;/code&gt; 을 실행하십시오 . 예외가 발생하면 해당 예외를 다시 발생 시키십시오. 사용 가능한 다른 작업이 &lt;code&gt;executeInNewThread&lt;/code&gt; &lt;code&gt;Task&lt;/code&gt; 이 executeInNewThread를 사용하여 실행 된 경우 조건 변수를 기다립니다.</target>
        </trans-unit>
        <trans-unit id="02c1e520b882980c80752c1365bf55b4375ba858" translate="yes" xml:space="preserve">
          <source>If this declaration is compliant with any particular standard, the description of it goes here.</source>
          <target state="translated">이 선언이 특정 표준을 준수하는 경우 여기에 대한 설명이 있습니다.</target>
        </trans-unit>
        <trans-unit id="13a2f9d3fe709668a2bc4c5dc3f8ab6e710fca1e" translate="yes" xml:space="preserve">
          <source>If this is a reference, dereference it.</source>
          <target state="translated">이것이 참조 인 경우 참조 해제하십시오.</target>
        </trans-unit>
        <trans-unit id="4f2c995ebc62fdd08dead47122c9bc13fad7a76d" translate="yes" xml:space="preserve">
          <source>If this is a shell around another type, get that other type.</source>
          <target state="translated">다른 유형의 쉘이라면 다른 유형을 얻으십시오.</target>
        </trans-unit>
        <trans-unit id="b5dc509f5b8b27fb2d7cf6170c77f1c20cada7e8" translate="yes" xml:space="preserve">
          <source>If this is a type of something, return that something.</source>
          <target state="translated">이것이 일종의 무언가라면, 그 무언가를 돌려주십시오.</target>
        </trans-unit>
        <trans-unit id="78983652ba5d9285bc5419929ba9f7e7d2014654" translate="yes" xml:space="preserve">
          <source>If this is a type of static array, return its base element type.</source>
          <target state="translated">이것이 정적 배열 유형 인 경우 기본 요소 유형을 리턴하십시오.</target>
        </trans-unit>
        <trans-unit id="11053146fa2d89a0863002bf2113f6a22908ad90" translate="yes" xml:space="preserve">
          <source>If this lock is not already held by the caller, the lock is acquired, then the internal counter is incremented by one.</source>
          <target state="translated">이 잠금이 호출자가 아직 보유하지 않은 경우 잠금이 획득되고 내부 카운터는 1 씩 증가합니다.</target>
        </trans-unit>
        <trans-unit id="7f2c76fc93c2cea506533b01d671704af3859af8" translate="yes" xml:space="preserve">
          <source>If this statement has code that needs to run in a finally clause at the end of the current scope, return that code in the form of a Statement.</source>
          <target state="translated">이 명령문에 현재 범위의 끝에 finally 절에서 실행해야하는 코드가 있으면 해당 코드를 Statement 형식으로 리턴하십시오.</target>
        </trans-unit>
        <trans-unit id="0515fd6aa93cc22acea186af17b617bb6900cccc" translate="yes" xml:space="preserve">
          <source>If this symbol is really an alias for another, return that other. If needed, semantic() is invoked due to resolve forward reference.</source>
          <target state="translated">이 기호가 실제로 다른 기호 인 경우 다른 기호를 반환하십시오. 필요한 경우, 순방향 참조를 해결하기 위해 semantic ()이 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="0d671d5e8525a56282bf3d43e4b2c8ef0fff443b" translate="yes" xml:space="preserve">
          <source>If two &lt;code&gt;Checked&lt;/code&gt; instances are involved in a binary operation and both define &lt;code&gt;hookOpBinary&lt;/code&gt;, the left-hand side hook has priority. If both define &lt;code&gt;onOverflow&lt;/code&gt;, a compile-time error occurs.</source>
          <target state="translated">2 개의 &lt;code&gt;Checked&lt;/code&gt; 인스턴스가 2 진 조작에 관여하고 둘 다 &lt;code&gt;hookOpBinary&lt;/code&gt; 를 정의 하는 경우 왼쪽 후크가 우선합니다. 둘 다 &lt;code&gt;onOverflow&lt;/code&gt; 를 정의 하면 컴파일 타임 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="000877fa3e86af7fe8754c0a2ea9639fca32104e" translate="yes" xml:space="preserve">
          <source>If two different mixins are put in the same scope, and each define a declaration with the same name, there is an ambiguity error when the declaration is referenced:</source>
          <target state="translated">서로 다른 두 믹스 인이 동일한 범위에 배치되고 각각 동일한 이름으로 선언을 정의하면 선언이 참조 될 때 모호한 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="a3bad367e89a048e204fc75a01e068c90ffc4712" translate="yes" xml:space="preserve">
          <source>If two or more functions have the same match level, then</source>
          <target state="translated">둘 이상의 기능이 동일한 일치 수준을 갖는 경우</target>
        </trans-unit>
        <trans-unit id="329ee511107dbe6e7abc063f46dd137916ba7624" translate="yes" xml:space="preserve">
          <source>If unit tests are not enabled, the implementation is not required to check the &lt;a href=&quot;#UnitTest&quot;&gt;&lt;i&gt;UnitTest&lt;/i&gt;&lt;/a&gt; for syntactic or semantic correctness. This is to reduce the compile time impact of larger unit test sections. The tokens must still be valid, and the implementation can merely count &lt;code&gt;{&lt;/code&gt; and &lt;code&gt;}&lt;/code&gt; tokens to find the end of the &lt;a href=&quot;#UnitTest&quot;&gt;&lt;i&gt;UnitTest&lt;/i&gt;&lt;/a&gt;'s &lt;a href=&quot;statement#BlockStatement&quot;&gt;&lt;i&gt;BlockStatement&lt;/i&gt;&lt;/a&gt;.</source>
          <target state="translated">단위 테스트를 사용하지 않으면 구문 또는 의미의 정확성을 위해 &lt;a href=&quot;#UnitTest&quot;&gt;&lt;i&gt;UnitTest&lt;/i&gt;&lt;/a&gt; 를 검사 할 필요가 없습니다 . 이는 더 큰 단위 테스트 섹션의 컴파일 시간 영향을 줄이기위한 것입니다. 토큰은 여전히 ​​유효해야하며 구현시 &lt;code&gt;{&lt;/code&gt; 및 &lt;code&gt;}&lt;/code&gt; 토큰 만 계산 하여 &lt;a href=&quot;#UnitTest&quot;&gt;&lt;i&gt;UnitTest&lt;/i&gt;&lt;/a&gt; 의 &lt;a href=&quot;statement#BlockStatement&quot;&gt;&lt;i&gt;BlockStatement&lt;/i&gt;&lt;/a&gt; 끝을 찾을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9627f657eafec4f6faa68074956b9ef2912cb7d7" translate="yes" xml:space="preserve">
          <source>If variable has a const initializer, return that initializer.</source>
          <target state="translated">변수에 const 이니셜 라이저가 있으면 해당 이니셜 라이저를 리턴하십시오.</target>
        </trans-unit>
        <trans-unit id="efa87bbfad2d81b3124f9c28a0c2e92ac37d7e01" translate="yes" xml:space="preserve">
          <source>If variable has a constant expression initializer, get it. Otherwise, return null.</source>
          <target state="translated">변수에 상수 표현식 이니셜 라이저가 있으면 가져옵니다. 그렇지 않으면 null을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="129f6b693e38ba5e18679007098a9df7fc61bc3f" translate="yes" xml:space="preserve">
          <source>If vector extensions are implemented, the &lt;a href=&quot;version#PredefinedVersions&quot;&gt;version identifier&lt;/a&gt;&lt;code&gt;D_SIMD&lt;/code&gt; is set.</source>
          <target state="translated">벡터 확장이 구현되면 &lt;a href=&quot;version#PredefinedVersions&quot;&gt;버전 식별자 &lt;/a&gt; &lt;code&gt;D_SIMD&lt;/code&gt; 가 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="adbc7bef2337da263c5a713fbb0e840af6633adb" translate="yes" xml:space="preserve">
          <source>If we want the value of this expression, but do not want to call the destructor on it.</source>
          <target state="translated">이 표현식의 값을 원하지만 소멸자를 호출하지 않으려는 경우.</target>
        </trans-unit>
        <trans-unit id="79988e7c16e0dced67dee802d9bdb6de78ec6132" translate="yes" xml:space="preserve">
          <source>If x is not a special value, the result is the same as &lt;code&gt;cast(int) logb(x)&lt;/code&gt;.</source>
          <target state="translated">x가 특별한 값이 아닌 경우 결과는 &lt;code&gt;cast(int) logb(x)&lt;/code&gt; 와 동일 합니다.</target>
        </trans-unit>
        <trans-unit id="bffad47163601102b19e67fa92a8c3feda0166ec" translate="yes" xml:space="preserve">
          <source>If x is subnormal, it is treated as if it were normalized. For a positive, finite x:</source>
          <target state="translated">x가 비정규 인 경우 정규화 된 것처럼 처리됩니다. 양의 유한 x의 경우 :</target>
        </trans-unit>
        <trans-unit id="92c403e0084ea037260c41da9c4c7e544a7d2d08" translate="yes" xml:space="preserve">
          <source>If y &amp;gt; x, the result will be the next largest floating-point value; if y &amp;lt; x, the result will be the next smallest value. If x == y, the result is y.</source>
          <target state="translated">y&amp;gt; x 인 경우 결과는 다음으로 가장 큰 부동 소수점 값이됩니다. y &amp;lt;x이면 결과는 다음으로 가장 작은 값이됩니다. x == y이면 결과는 y입니다.</target>
        </trans-unit>
        <trans-unit id="51868f820cebc5e3c544468e6d407c4bd6b45485" translate="yes" xml:space="preserve">
          <source>If you have a small buffer you can use &lt;a href=&quot;#compress&quot;&gt;&lt;code&gt;compress&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#uncompress&quot;&gt;&lt;code&gt;uncompress&lt;/code&gt;&lt;/a&gt; directly.</source>
          <target state="translated">작은 버퍼가 있으면 &lt;a href=&quot;#compress&quot;&gt; &lt;code&gt;compress&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#uncompress&quot;&gt; &lt;code&gt;uncompress&lt;/code&gt; &lt;/a&gt; 직접 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b65e14bf08e45286eb114c69d33e8aa407bf4bbd" translate="yes" xml:space="preserve">
          <source>If you omit &lt;code&gt;Rhs&lt;/code&gt;, &lt;code&gt;isAssignable&lt;/code&gt; will check identity assignable of &lt;code&gt;Lhs&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Rhs&lt;/code&gt; 를 생략 하면 &lt;code&gt;isAssignable&lt;/code&gt; 은 &lt;code&gt;Lhs&lt;/code&gt; 에 할당 가능한 ID를 확인 합니다.</target>
        </trans-unit>
        <trans-unit id="14961e1fccbf1736d47a52df390592d594e9109a" translate="yes" xml:space="preserve">
          <source>If you select &lt;code&gt;precise&lt;/code&gt; as the garbage collector via the options above, type information will be used to identify actual or possible pointers or references within heap allocated data objects. Non-pointer data will not be interpreted as a reference to other memory as a &quot;false pointer&quot;. The collector has to make pessimistic assumptions if a memory slot can contain both a pointer or an integer value, it will still be scanned (e.g. in a &lt;code&gt;union&lt;/code&gt;).</source>
          <target state="translated">위의 옵션을 통해 가비지 수집기로 &lt;code&gt;precise&lt;/code&gt; 선택하면 형식 정보를 사용하여 힙 할당 데이터 개체 내에서 실제 또는 가능한 포인터 또는 참조를 식별합니다. 포인터가 아닌 데이터는 다른 메모리에 대한 참조로 &quot;거짓 포인터&quot;로 해석되지 않습니다. 콜렉터는 메모리 슬롯에 포인터 또는 정수 값이 모두 포함될 수있는 경우 비관적 인 가정을 수행해야하지만 여전히 스캔됩니다 (예 : &lt;code&gt;union&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="cbade680aa6ce4b2eee3b550013b504b2359a76c" translate="yes" xml:space="preserve">
          <source>If you use the GC memory functions from &lt;code&gt;core.memory&lt;/code&gt;, and plan to use it for data with a mixture of pointers and non-pointer data you should pass the TypeInfo of your allocated struct, class or type as the optional parameter. The default &lt;code&gt;null&lt;/code&gt; is interpreted as memory that might contain pointers everywhere.</source>
          <target state="translated">&lt;code&gt;core.memory&lt;/code&gt; 의 GC 메모리 함수 를 사용하고 포인터와 비 포인터 데이터가 혼합 된 데이터에 사용하려는 경우 할당 된 구조체, 클래스 또는 유형의 TypeInfo를 선택적 매개 변수로 전달해야합니다. 기본 &lt;code&gt;null&lt;/code&gt; 은 어디에서나 포인터를 포함 할 수있는 메모리로 해석됩니다.</target>
        </trans-unit>
        <trans-unit id="50a53d6760e4f33109326a6a1af782ed05797935" translate="yes" xml:space="preserve">
          <source>If:</source>
          <target state="translated">If:</target>
        </trans-unit>
        <trans-unit id="b2403005179997fdecfad41d075986e0dccac0e9" translate="yes" xml:space="preserve">
          <source>IfStatement</source>
          <target state="translated">IfStatement</target>
        </trans-unit>
        <trans-unit id="859704f6d767666630d7b805196cab9e15bc787d" translate="yes" xml:space="preserve">
          <source>IgnoreXXXX</source>
          <target state="translated">IgnoreXXXX</target>
        </trans-unit>
        <trans-unit id="ba5ba167a98858b40c030856aa4aacb94b020392" translate="yes" xml:space="preserve">
          <source>Ignores C-style / D-style variadic arguments.</source>
          <target state="translated">C 스타일 / D 스타일 가변성 인수를 무시합니다.</target>
        </trans-unit>
        <trans-unit id="09e871c98fef3b901a775def173e4126aaf73b42" translate="yes" xml:space="preserve">
          <source>Images</source>
          <target state="translated">Images</target>
        </trans-unit>
        <trans-unit id="ed701420e7f5e55b19ea82ee452968a59b8615ea" translate="yes" xml:space="preserve">
          <source>Images have the same form as reference or inline links, but add an exclamation point &lt;code&gt;!&lt;/code&gt; before the initial square bracket. What would be the link text in a normal link is used as the image's alt text.</source>
          <target state="translated">이미지는 참조 또는 인라인 링크와 동일한 형식이지만 느낌표를 추가하십시오 &lt;code&gt;!&lt;/code&gt; 초기 대괄호 앞에. 일반 링크에서 링크 텍스트는 이미지의 대체 텍스트로 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="da8a47e84bd95dd590801199a512c81712152ddc" translate="yes" xml:space="preserve">
          <source>Immediately after the range argument, an optional work unit size argument may be provided. Work units as used by &lt;code&gt;amap&lt;/code&gt; are identical to those defined for parallel foreach. If no work unit size is provided, the default work unit size is used.</source>
          <target state="translated">범위 인수 직후에 선택적 작업 단위 크기 인수가 제공 될 수 있습니다. &lt;code&gt;amap&lt;/code&gt; 사용 된 작업 단위는 병렬 foreach에 대해 정의 된 것과 동일합니다. 작업 단위 크기가 제공되지 않으면 기본 작업 단위 크기가 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="79fa62caeafe3bd4c17315583aef1c8a23c5d46e" translate="yes" xml:space="preserve">
          <source>Immediately drop any connections and release socket resources. The &lt;code&gt;Socket&lt;/code&gt; object is no longer usable after &lt;code&gt;close&lt;/code&gt;. Calling &lt;code&gt;shutdown&lt;/code&gt; before &lt;code&gt;close&lt;/code&gt; is recommended for connection-oriented sockets.</source>
          <target state="translated">즉시 연결을 끊고 소켓 리소스를 해제하십시오. &lt;code&gt;Socket&lt;/code&gt; 객체는 더 이상 후 사용할 수 없다 &lt;code&gt;close&lt;/code&gt; . 연결 지향 소켓의 경우 &lt;code&gt;close&lt;/code&gt; 전에 호출 &lt;code&gt;shutdown&lt;/code&gt; 를 권장합니다.</target>
        </trans-unit>
        <trans-unit id="1473effc3e4965950f77d9acee523d95bdbf4b42" translate="yes" xml:space="preserve">
          <source>Immutability is transitive, meaning it applies to anything that can be referenced from the immutable type:</source>
          <target state="translated">불변성은 전 이적이며 불변 유형에서 참조 할 수있는 모든 것에 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="a3901c3fc3cbd4dda7d4b5cdbdfb146ab629c087" translate="yes" xml:space="preserve">
          <source>Immutable Member Functions</source>
          <target state="translated">불변 멤버 함수</target>
        </trans-unit>
        <trans-unit id="31b83cfa7707372a1c66b40c2bffbc19a9e85eb7" translate="yes" xml:space="preserve">
          <source>Immutable Storage Class</source>
          <target state="translated">불변 스토리지 클래스</target>
        </trans-unit>
        <trans-unit id="bad427b56d48a9c0418ac178e3b7e5501dbeffb2" translate="yes" xml:space="preserve">
          <source>Immutable Type</source>
          <target state="translated">불변 유형</target>
        </trans-unit>
        <trans-unit id="7a41b36410af31e02780ae8ef8f795b4c7e5c218" translate="yes" xml:space="preserve">
          <source>Immutable associative arrays are often desirable, but sometimes initialization must be done at runtime. This can be achieved with a constructor (static constructor depending on scope), a buffer associative array and &lt;code&gt;assumeUnique&lt;/code&gt;:</source>
          <target state="translated">불변의 연관 배열이 종종 바람직하지만 때로는 런타임에 초기화를 수행해야합니다. 이것은 생성자 (범위에 따라 정적 생성자), 버퍼 연관 배열 및 &lt;code&gt;assumeUnique&lt;/code&gt; 로 달성 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="1060492cd68308e42ab0d863274ead4d94e73c72" translate="yes" xml:space="preserve">
          <source>Immutable declarations can appear as lvalues, i.e. they can have their address taken, and occupy storage.</source>
          <target state="translated">변경 불가능한 선언은 lvalue로 표시 될 수 있습니다. 즉, 주소를 가져오고 스토리지를 차지할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="97deddbfb05296e5d5f6c89e8255f2cf73fed0f1" translate="yes" xml:space="preserve">
          <source>Immutable member functions are guaranteed that the object and anything referred to by the &lt;code&gt;this&lt;/code&gt; reference is immutable. They are declared as:</source>
          <target state="translated">불변 멤버 함수는 &lt;code&gt;this&lt;/code&gt; 참조에서 참조 하는 객체와 무엇이든 불변임을 보장합니다 . 그들은 다음과 같이 선언됩니다.</target>
        </trans-unit>
        <trans-unit id="7ca47511da5cd25a571e0550ee9181f060e3ad8e" translate="yes" xml:space="preserve">
          <source>Immutable used as a storage class is equivalent to using immutable as a type qualifier for the entire type of a declaration:</source>
          <target state="translated">스토리지 클래스로 사용되는 변경 불가능은 선언의 전체 유형에 대해 유형 한정자로 변경 불가능을 사용하는 것과 같습니다.</target>
        </trans-unit>
        <trans-unit id="8cc79f379fb076727af30671cff8e81a7a78ac8f" translate="yes" xml:space="preserve">
          <source>Imperial Aramaic</source>
          <target state="translated">임페리얼 아람어</target>
        </trans-unit>
        <trans-unit id="f115c5f2dd3a1366bda08a49baad63fd02afde98" translate="yes" xml:space="preserve">
          <source>Imperial_Aramaic</source>
          <target state="translated">Imperial_Aramaic</target>
        </trans-unit>
        <trans-unit id="015f00e67a839cb58bb4f25641353bc270b1dc50" translate="yes" xml:space="preserve">
          <source>Impl* &lt;strong id=&quot;_d_assocarrayliteralTX&quot;&gt;_d_assocarrayliteralTX&lt;/strong&gt;(const TypeInfo_AssociativeArray ti, void[] keys, void[] vals);</source>
          <target state="translated">IMPL * &lt;strong id=&quot;_d_assocarrayliteralTX&quot;&gt;_d_assocarrayliteralTX&lt;/strong&gt; (CONST TypeInfo_AssociativeArray TI 무효 [] 키 무효 [] 발스);</target>
        </trans-unit>
        <trans-unit id="00b783520a8a2fbc5645a580ba36a3a286254053" translate="yes" xml:space="preserve">
          <source>Implementation Details</source>
          <target state="translated">구현 세부 사항</target>
        </trans-unit>
        <trans-unit id="4bd31434dd702d78584ad36682fd4ce02cbe35f9" translate="yes" xml:space="preserve">
          <source>Implementation helpers</source>
          <target state="translated">구현 도우미</target>
        </trans-unit>
        <trans-unit id="cdc8095e33689a7350a694bb991dc5449ed4cc80" translate="yes" xml:space="preserve">
          <source>Implementation note: Many vector operations are expected to take advantage of any vector math instructions available on the target computer.</source>
          <target state="translated">구현 노트 : 많은 벡터 연산은 대상 컴퓨터에서 사용 가능한 벡터 수학 명령을 활용할 것으로 예상됩니다.</target>
        </trans-unit>
        <trans-unit id="4f7fc9a2d05fa0c5c4b7879d385797376ea8299d" translate="yes" xml:space="preserve">
          <source>Implementation of &lt;code&gt;IAllocator&lt;/code&gt; using &lt;code&gt;Allocator&lt;/code&gt;. This adapts a statically-built allocator type to &lt;code&gt;IAllocator&lt;/code&gt; that is directly usable by non-templated code.</source>
          <target state="translated">구현 &lt;code&gt;IAllocator&lt;/code&gt; 사용하여 &lt;code&gt;Allocator&lt;/code&gt; . 이는 정적으로 빌드 된 할당 자 유형을 템플릿이 아닌 코드에서 직접 사용할 수있는 &lt;code&gt;IAllocator&lt;/code&gt; 에 적용 합니다.</target>
        </trans-unit>
        <trans-unit id="fafacd0c4afbb4ff4bf1edadf17fafe457e3c87e" translate="yes" xml:space="preserve">
          <source>Implementation of &lt;code&gt;ISharedAllocator&lt;/code&gt; using &lt;code&gt;Allocator&lt;/code&gt;. This adapts a statically-built, shareable across threads, allocator type to &lt;code&gt;ISharedAllocator&lt;/code&gt; that is directly usable by non-templated code.</source>
          <target state="translated">구현 &lt;code&gt;ISharedAllocator&lt;/code&gt; 사용하여 &lt;code&gt;Allocator&lt;/code&gt; . 이것은 정적으로 구축되고 스레드에서 공유 가능한 할당 자 유형을 템플릿이 아닌 코드에서 직접 사용할 수있는 &lt;code&gt;ISharedAllocator&lt;/code&gt; 에 적용 합니다.</target>
        </trans-unit>
        <trans-unit id="bcbaffe82dd8f12aeaf4d1ff9d3011fef84404a6" translate="yes" xml:space="preserve">
          <source>Implementation of &lt;code&gt;_d_arrayappendT&lt;/code&gt; and &lt;code&gt;_d_arrayappendTTrace&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;_d_arrayappendT&lt;/code&gt; 및 &lt;code&gt;_d_arrayappendTTrace&lt;/code&gt; 구현</target>
        </trans-unit>
        <trans-unit id="b10e497f26133fe54aedbc1b0186f76a3533b685" translate="yes" xml:space="preserve">
          <source>Implementation of &lt;code&gt;_d_arrayappendcTX&lt;/code&gt; and &lt;code&gt;_d_arrayappendcTXTrace&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;_d_arrayappendcTX&lt;/code&gt; 및 &lt;code&gt;_d_arrayappendcTXTrace&lt;/code&gt; 의 구현</target>
        </trans-unit>
        <trans-unit id="7db4a8478e7cad025fd1104c777c36390076d0e1" translate="yes" xml:space="preserve">
          <source>Implementation of &lt;code&gt;_d_arraycatnTX&lt;/code&gt; and &lt;code&gt;_d_arraycatnTXTrace&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;_d_arraycatnTX&lt;/code&gt; 및 &lt;code&gt;_d_arraycatnTXTrace&lt;/code&gt; 의 구현</target>
        </trans-unit>
        <trans-unit id="8abbaa69f0e232671973ab5e6491f136e6a29871" translate="yes" xml:space="preserve">
          <source>Implementation of &lt;code&gt;_d_arraysetlengthT&lt;/code&gt; and &lt;code&gt;_d_arraysetlengthTTrace&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;_d_arraysetlengthT&lt;/code&gt; 및 &lt;code&gt;_d_arraysetlengthTTrace&lt;/code&gt; 의 구현</target>
        </trans-unit>
        <trans-unit id="6f9ad487b035fc97c0af04b8b66abb8578971a5f" translate="yes" xml:space="preserve">
          <source>Implementation of a &lt;a href=&quot;https://en.wikipedia.org/wiki/Red%E2%80%93black_tree&quot;&gt; red-black tree&lt;/a&gt; container.</source>
          <target state="translated">&lt;a href=&quot;https://en.wikipedia.org/wiki/Red%E2%80%93black_tree&quot;&gt;레드-블랙 트리&lt;/a&gt; 컨테이너의 구현 .</target>
        </trans-unit>
        <trans-unit id="8e7df8ae1e56f997a5b65b6b6877c23f0d64f3a3" translate="yes" xml:space="preserve">
          <source>Implementation of alloca() standard C routine.</source>
          <target state="translated">alloca () 표준 C 루틴 구현.</target>
        </trans-unit>
        <trans-unit id="1784dc78d2b897ccf07f36701bfc5665f7a4b791" translate="yes" xml:space="preserve">
          <source>Implementation of array assignment support routines.</source>
          <target state="translated">배열 할당 지원 루틴 구현</target>
        </trans-unit>
        <trans-unit id="a39c70c382be4565515493d462dbbec04eaf7781" translate="yes" xml:space="preserve">
          <source>Implementation of array copy support routines.</source>
          <target state="translated">어레이 복사 지원 루틴 구현</target>
        </trans-unit>
        <trans-unit id="0bdc6417eff40a113a2fe81fc65ab41a4dcaba32" translate="yes" xml:space="preserve">
          <source>Implementation of associative arrays.</source>
          <target state="translated">연관 배열의 구현.</target>
        </trans-unit>
        <trans-unit id="07784c9ff6fc80ea8be9db66531869c595761785" translate="yes" xml:space="preserve">
          <source>Implementation of code coverage analyzer.</source>
          <target state="translated">코드 커버리지 분석기 구현</target>
        </trans-unit>
        <trans-unit id="fad1778f18239a1620ff2a279ed8dce89c92aba4" translate="yes" xml:space="preserve">
          <source>Implementation of dynamic array property support routines.</source>
          <target state="translated">동적 배열 속성 지원 루틴 구현</target>
        </trans-unit>
        <trans-unit id="1c44b949de0c9066379af30ba926638e5089c3a0" translate="yes" xml:space="preserve">
          <source>Implementation of exception handling support routines for Win32.</source>
          <target state="translated">Win32에 대한 예외 처리 지원 루틴 구현</target>
        </trans-unit>
        <trans-unit id="7d3ce3a8f354f9946b2098d37781419df42c1fa9" translate="yes" xml:space="preserve">
          <source>Implementation of exception handling support routines.</source>
          <target state="translated">예외 처리 지원 루틴 구현</target>
        </trans-unit>
        <trans-unit id="4262710c1f4443ad04091f6eaee82248c8735a23" translate="yes" xml:space="preserve">
          <source>Implementation of invariant support routines.</source>
          <target state="translated">변하지 않는 지원 루틴의 구현.</target>
        </trans-unit>
        <trans-unit id="3dad8ae42692f0a5067da5335623cc0faae36caa" translate="yes" xml:space="preserve">
          <source>Implementation of standard Base64 encoding.</source>
          <target state="translated">표준 Base64 인코딩 구현.</target>
        </trans-unit>
        <trans-unit id="8bb4407a3328a42063117ac1cd37abce98147582" translate="yes" xml:space="preserve">
          <source>Implementation of support routines for synchronized blocks.</source>
          <target state="translated">동기화 된 블록에 대한 지원 루틴 구현.</target>
        </trans-unit>
        <trans-unit id="36a7e10f19e92847926357311b55d0e017f473ef" translate="yes" xml:space="preserve">
          <source>Implementations are free to assume that GC pointers are only stored on word boundaries. Unaligned pointers may be ignored entirely.</source>
          <target state="translated">구현에서는 GC 포인터가 단어 경계에만 저장되어 있다고 가정 할 수 있습니다. 정렬되지 않은 포인터는 완전히 무시 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a8c2ed8c7bf790ca62a6ccc79e874d26201eb456" translate="yes" xml:space="preserve">
          <source>Implementations are free to run collections at any point. It is, however, recommendable to only do so when an allocation attempt happens and there is insufficient memory available.</source>
          <target state="translated">구현은 언제든지 컬렉션을 자유롭게 실행할 수 있습니다. 그러나 할당 시도가 발생하고 사용 가능한 메모리가 부족한 경우에만 수행하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="7bedeb01a44e9992494ae61fc2e61ab874f0844b" translate="yes" xml:space="preserve">
          <source>Implementations are free to scan the non-root heap in a precise manner, so that fields of types like &lt;code&gt;float&lt;/code&gt; will not be considered relevant when scanning the heap. Thus, casting a GC pointer to an integral type (e.g. &lt;code&gt;size_t&lt;/code&gt;) and storing it in a field of that type inside the GC heap may mean that it will not be recognized if the memory block was allocated with precise type info or with the &lt;code&gt;GC.BlkAttr.&lt;a href=&quot;#NO_SCAN&quot;&gt;NO_SCAN&lt;/a&gt;&lt;/code&gt; attribute.</source>
          <target state="translated">구현은 루트가 아닌 힙을 정확하게 스캔 할 수 있으므로 &lt;code&gt;float&lt;/code&gt; 와 같은 유형의 필드 는 힙을 스캔 할 때 관련성이없는 것으로 간주됩니다. 따라서 GC 포인터를 정수 유형 (예 : &lt;code&gt;size_t&lt;/code&gt; )으로 캐스트 하고 GC 힙 내부에서 해당 유형의 필드에 저장하면 메모리 블록에 정확한 유형 정보 또는 &lt;code&gt;GC.BlkAttr.&lt;a href=&quot;#NO_SCAN&quot;&gt;NO_SCAN&lt;/a&gt;&lt;/code&gt; 가 할당 된 경우 인식되지 않을 수 있습니다 . BlkAttr. NO_SCAN 속성.</target>
        </trans-unit>
        <trans-unit id="3fe2d13e1a38447a1ccf3bcf63459da389a3bd8d" translate="yes" xml:space="preserve">
          <source>Implementations may restrict the file name in order to avoid directory traversal security vulnerabilities. A possible restriction might be to disallow any path components in the file name.</source>
          <target state="translated">디렉토리 순회 보안 취약점을 피하기 위해 구현시 파일 이름이 제한 될 수 있습니다. 파일 이름에 경로 구성 요소를 허용하지 않을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="41da860cb79fe7312e55548bf43ef9ac07ff278f" translate="yes" xml:space="preserve">
          <source>Implementations must diagnose an error for unrecognized</source>
          <target state="translated">구현시 인식되지 않는 오류를 진단해야합니다.</target>
        </trans-unit>
        <trans-unit id="007c721ddd0f22de039d1ec5d207cce979d8d6f0" translate="yes" xml:space="preserve">
          <source>Implementations must support interior pointers. That is, if the only reference to a GC-managed memory block points into the middle of the block rather than the beginning (for example), the GC must consider the memory block live. The exception to this rule is when a memory block is allocated with the &lt;code&gt;GC.BlkAttr.&lt;a href=&quot;#NO_INTERIOR&quot;&gt;NO_INTERIOR&lt;/a&gt;&lt;/code&gt; attribute; it is the user's responsibility to make sure such memory blocks have a proper pointer to them when they should be considered live.</source>
          <target state="translated">구현은 내부 포인터를 지원해야합니다. 즉, GC 관리 메모리 블록에 대한 유일한 참조가 시작이 아닌 블록의 중간을 가리키는 경우 (예 :) GC는 메모리 블록을 라이브로 간주해야합니다. 이 규칙의 예외는 메모리 블록이 &lt;code&gt;GC.BlkAttr.&lt;a href=&quot;#NO_INTERIOR&quot;&gt;NO_INTERIOR&lt;/a&gt;&lt;/code&gt; 로 할당 된 경우 입니다. NO_INTERIOR 속성; 그러한 메모리 블록이 실시간으로 간주 될 때 해당 메모리 블록에 대한 적절한 포인터를 갖는 것은 사용자의 책임입니다.</target>
        </trans-unit>
        <trans-unit id="db108dbc2de097787f6ddeb0832f02909642f907" translate="yes" xml:space="preserve">
          <source>Implementations of D on different architectures, however, are free to innovate upon the memory model, function call/return conventions, argument passing conventions, etc.</source>
          <target state="translated">그러나 다른 아키텍처에서 D를 구현하면 메모리 모델, 함수 호출 / 반환 규칙, 인수 전달 규칙 등을 자유롭게 혁신 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d7a03fc44da9f306060241398ee57db5f3a7d7aa" translate="yes" xml:space="preserve">
          <source>Implemented using &lt;code&gt;pthread_mutex&lt;/code&gt; and &lt;code&gt;pthread_condition&lt;/code&gt; on Posix and &lt;code&gt;CreateEvent&lt;/code&gt; and &lt;code&gt;SetEvent&lt;/code&gt; on Windows.</source>
          <target state="translated">Posix에서 &lt;code&gt;pthread_mutex&lt;/code&gt; 및 &lt;code&gt;pthread_condition&lt;/code&gt; 을 사용 하고 Windows에서 &lt;code&gt;CreateEvent&lt;/code&gt; 및 &lt;code&gt;SetEvent&lt;/code&gt; 를 사용하여 구현 되었습니다.</target>
        </trans-unit>
        <trans-unit id="9e4c63b7ecbb7ff73a2154a224607de77b4347f8" translate="yes" xml:space="preserve">
          <source>Implemented using &lt;code&gt;pthread_mutex&lt;/code&gt; on Posix and &lt;code&gt;CRITICAL_SECTION&lt;/code&gt; on Windows.</source>
          <target state="translated">Posix에서 &lt;code&gt;pthread_mutex&lt;/code&gt; 를 사용 하고 Windows에서 &lt;code&gt;CRITICAL_SECTION&lt;/code&gt; 을 사용하여 구현했습니다 .</target>
        </trans-unit>
        <trans-unit id="cf9e08c7271694a3ffd216903295953184c6b554" translate="yes" xml:space="preserve">
          <source>Implementing a Scheduler allows the concurrency mechanism used by this module to be customized according to different needs. By default, a call to spawn will create a new kernel thread that executes the supplied routine and terminates when finished. But it is possible to create Schedulers that reuse threads, that multiplex Fibers (coroutines) across a single thread, or any number of other approaches. By making the choice of Scheduler a user-level option, std.concurrency may be used for far more types of application than if this behavior were predefined.</source>
          <target state="translated">스케줄러를 구현하면이 모듈에서 사용하는 동시성 메커니즘을 다양한 요구에 따라 사용자 정의 할 수 있습니다. 기본적으로 스폰을 호출하면 제공된 루틴을 실행하고 완료되면 종료되는 새 커널 스레드가 작성됩니다. 그러나 스레드를 재사용하는 스케줄러, 단일 스레드에서 멀티 플렉스 파이버 (코 루틴) 또는 기타 여러 가지 접근 방식을 작성할 수 있습니다. 스케줄러를 사용자 레벨 옵션으로 선택하면 std.concurrency는이 동작이 사전 정의 된 것보다 훨씬 더 많은 유형의 응용 프로그램에 사용될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b264d3336b750c35148a8818568f62fa13927441" translate="yes" xml:space="preserve">
          <source>Implements 3-way comparisons of &lt;code&gt;BigInt&lt;/code&gt; with &lt;code&gt;BigInt&lt;/code&gt; or &lt;code&gt;BigInt&lt;/code&gt; with built-in integers.</source>
          <target state="translated">의 구현은 3 방향 비교 &lt;code&gt;BigInt&lt;/code&gt; 과 &lt;code&gt;BigInt&lt;/code&gt; 또는 &lt;code&gt;BigInt&lt;/code&gt; 내장의 정수를.</target>
        </trans-unit>
        <trans-unit id="ff4e8dcbc761da7358b8c9aa098a3c08bb0a396c" translate="yes" xml:space="preserve">
          <source>Implements &lt;code&gt;BigInt&lt;/code&gt; equality test with other &lt;code&gt;BigInt&lt;/code&gt;'s and built-in integer types.</source>
          <target state="translated">다른 &lt;code&gt;BigInt&lt;/code&gt; 및 내장 정수 유형으로 &lt;code&gt;BigInt&lt;/code&gt; 동등성 테스트를 구현 합니다.</target>
        </trans-unit>
        <trans-unit id="7ca26966771a4b63b83cfa749d58cb4c74bd1074" translate="yes" xml:space="preserve">
          <source>Implements &lt;code&gt;BigInt&lt;/code&gt; unary operators.</source>
          <target state="translated">&lt;code&gt;BigInt&lt;/code&gt; 단항 연산자를 구현합니다 .</target>
        </trans-unit>
        <trans-unit id="6a3cb51c99d7f39233c1830869fb1b564b310297" translate="yes" xml:space="preserve">
          <source>Implements a &quot;tee&quot; style pipe, wrapping an input range so that elements of the range can be passed to a provided function or &lt;a href=&quot;#OutputRange&quot;&gt;&lt;code&gt;OutputRange&lt;/code&gt;&lt;/a&gt; as they are iterated over. This is useful for printing out intermediate values in a long chain of range code, performing some operation with side-effects on each call to &lt;code&gt;front&lt;/code&gt; or &lt;code&gt;popFront&lt;/code&gt;, or diverting the elements of a range into an auxiliary &lt;a href=&quot;#OutputRange&quot;&gt;&lt;code&gt;OutputRange&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&quot;tee&quot;스타일 파이프를 구현하여 입력 범위를 감싸서 범위의 요소 가 반복되는 동안 제공된 함수 또는 &lt;a href=&quot;#OutputRange&quot;&gt; &lt;code&gt;OutputRange&lt;/code&gt; 에&lt;/a&gt; 전달 될 수 있도록 합니다. 이는 긴 범위의 체인 코드에서 중간 값을 인쇄 하거나 , &lt;code&gt;front&lt;/code&gt; 또는 &lt;code&gt;popFront&lt;/code&gt; 를 호출 할 때마다 부작용으로 일부 작업을 수행 하거나 , 범위의 요소를 보조 &lt;a href=&quot;#OutputRange&quot;&gt; &lt;code&gt;OutputRange&lt;/code&gt; &lt;/a&gt; 로 전환하는 데 유용 합니다.</target>
        </trans-unit>
        <trans-unit id="edd807624e1eff53b60fc0fdcb84a1a01a914908" translate="yes" xml:space="preserve">
          <source>Implements a &lt;a href=&quot;http://en.wikipedia.org/wiki/Binary_heap&quot;&gt;binary heap&lt;/a&gt; container on top of a given random-access range type (usually &lt;code&gt;T[]&lt;/code&gt;) or a random-access container type (usually &lt;code&gt;Array!T&lt;/code&gt;). The documentation of &lt;code&gt;BinaryHeap&lt;/code&gt; will refer to the underlying range or container as the</source>
          <target state="translated">지정된 임의 액세스 범위 유형 (일반적으로 &lt;code&gt;T[]&lt;/code&gt; ) 또는 임의 액세스 컨테이너 유형 (일반적으로 &lt;code&gt;Array!T&lt;/code&gt; ) 위에 &lt;a href=&quot;http://en.wikipedia.org/wiki/Binary_heap&quot;&gt;이진 힙&lt;/a&gt; 컨테이너를 구현합니다 . &lt;code&gt;BinaryHeap&lt;/code&gt; 의 문서는 기본 범위 또는 컨테이너를</target>
        </trans-unit>
        <trans-unit id="826e19cc42c27271edbc14035290489f9b886abe" translate="yes" xml:space="preserve">
          <source>Implements a doubly-linked list.</source>
          <target state="translated">이중 연결 목록을 구현합니다.</target>
        </trans-unit>
        <trans-unit id="6c4a9e8241b5f111ea434df2fe96c036c8c94979" translate="yes" xml:space="preserve">
          <source>Implements a narrowing remainder operation with built-in integer types.</source>
          <target state="translated">내장 정수 유형으로 좁히는 나머지 연산을 구현합니다.</target>
        </trans-unit>
        <trans-unit id="27ed74a2d7c34a4b3c0b18b681929b4fe9236374" translate="yes" xml:space="preserve">
          <source>Implements a parallel foreach loop over a range. This works by implicitly creating and submitting one &lt;code&gt;Task&lt;/code&gt; to the &lt;code&gt;TaskPool&lt;/code&gt; for each worker thread. A work unit is a set of consecutive elements of &lt;code&gt;range&lt;/code&gt; to be processed by a worker thread between communication with any other thread. The number of elements processed per work unit is controlled by the &lt;code&gt;workUnitSize&lt;/code&gt; parameter. Smaller work units provide better load balancing, but larger work units avoid the overhead of communicating with other threads frequently to fetch the next work unit. Large work units also avoid false sharing in cases where the range is being modified. The less time a single iteration of the loop takes, the larger &lt;code&gt;workUnitSize&lt;/code&gt; should be. For very expensive loop bodies, &lt;code&gt;workUnitSize&lt;/code&gt; should be 1. An overload that chooses a default work unit size is also available.</source>
          <target state="translated">범위에 대해 병렬 foreach 루프를 구현합니다. 이것은 각 작업자 스레드에 대해 하나의 &lt;code&gt;Task&lt;/code&gt; 을 암시 적으로 생성 하여 &lt;code&gt;TaskPool&lt;/code&gt; 에 제출함으로써 작동 합니다. 작업 단위는 다른 스레드와의 통신 사이에 작업자 스레드가 처리 할 &lt;code&gt;range&lt;/code&gt; 의 연속 요소 집합입니다 . 작업 단위당 처리되는 요소 수는 &lt;code&gt;workUnitSize&lt;/code&gt; 매개 변수에 의해 제어됩니다 . 작은 작업 단위는 더 나은로드 밸런싱을 제공하지만 더 큰 작업 단위는 다음 작업 단위를 페치하기 위해 다른 스레드와 자주 통신하는 오버 헤드를 피합니다. 또한 큰 작업 단위는 범위를 수정하는 경우 허위 공유를 피합니다. 루프의 단일 반복에 걸리는 시간이 짧을수록 더 큰 &lt;code&gt;workUnitSize&lt;/code&gt; 해야한다. 매우 비싼 루프 바디의 경우 &lt;code&gt;workUnitSize&lt;/code&gt; 는 1이어야합니다. 기본 작업 단위 크기를 선택하는 과부하도 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="826fe4a31de6fc5bfd32223112c616b546ef30ea" translate="yes" xml:space="preserve">
          <source>Implements a simple and fast singly-linked list. It can be used as a stack.</source>
          <target state="translated">간단하고 빠른 단일 연결 목록을 구현합니다. 스택으로 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1e7f8a9f41236aa959250c83a21042416cfb7001" translate="yes" xml:space="preserve">
          <source>Implements an output range that appends data to an array. This is recommended over &lt;code&gt;array ~= data&lt;/code&gt; when appending many elements because it is more efficient. &lt;code&gt;Appender&lt;/code&gt; maintains its own array metadata locally, so it can avoid global locking for each append where &lt;a href=&quot;#capacity&quot;&gt;&lt;code&gt;capacity&lt;/code&gt;&lt;/a&gt; is non-zero.</source>
          <target state="translated">데이터를 배열에 추가하는 출력 범위를 구현합니다. 많은 요소를 추가 할 때 &lt;code&gt;array ~= data&lt;/code&gt; 보다 효율적이므로 권장 됩니다. &lt;code&gt;Appender&lt;/code&gt; 는 자체 배열 메타 데이터를 로컬로 유지하므로 &lt;a href=&quot;#capacity&quot;&gt; &lt;code&gt;capacity&lt;/code&gt; &lt;/a&gt; 이 0이 아닌 각 추가에 대한 전역 잠금을 피할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="eb1006ae1765bc7db00ba2578ee369f0e577a7bc" translate="yes" xml:space="preserve">
          <source>Implements assignment operators from built-in integers of the form &lt;code&gt;BigInt op= integer&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;BigInt op= integer&lt;/code&gt; 형식의 내장 정수에서 대입 연산자를 구현합니다 .</target>
        </trans-unit>
        <trans-unit id="a6bf741a9ca55b772fcf287918db9b994810ba0a" translate="yes" xml:space="preserve">
          <source>Implements assignment operators of the form &lt;code&gt;BigInt op= BigInt&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;BigInt op= BigInt&lt;/code&gt; 형식의 대입 연산자를 구현합니다 .</target>
        </trans-unit>
        <trans-unit id="e1ea709e7bbd408cd7bf94a6f215f7f14ae10aa2" translate="yes" xml:space="preserve">
          <source>Implements binary operators between &lt;code&gt;BigInt&lt;/code&gt;'s and built-in integers.</source>
          <target state="translated">&lt;code&gt;BigInt&lt;/code&gt; 와 내장 정수 사이에 이진 연산자를 구현 합니다.</target>
        </trans-unit>
        <trans-unit id="df47e55b92aed2a9c5b877779b4fc9382af7ea1f" translate="yes" xml:space="preserve">
          <source>Implements binary operators between &lt;code&gt;BigInt&lt;/code&gt;s.</source>
          <target state="translated">&lt;code&gt;BigInt&lt;/code&gt; 사이에 이진 연산자를 구현합니다 .</target>
        </trans-unit>
        <trans-unit id="c38b2eea1063f17593adb5371b20a04e888bc589" translate="yes" xml:space="preserve">
          <source>Implements casting to &lt;code&gt;bool&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;bool&lt;/code&gt; 캐스팅을 구현합니다 .</target>
        </trans-unit>
        <trans-unit id="612c7a1e4ee8aa3a5eb36e62f5d1886edb7c32a6" translate="yes" xml:space="preserve">
          <source>Implements casting to integer types.</source>
          <target state="translated">정수 유형으로 캐스트를 구현합니다.</target>
        </trans-unit>
        <trans-unit id="d027822363fbfc370a577e3a5cc7b4b903013cad" translate="yes" xml:space="preserve">
          <source>Implements casting to/from qualified &lt;code&gt;BigInt&lt;/code&gt;'s.</source>
          <target state="translated">적격 &lt;code&gt;BigInt&lt;/code&gt; 와의 캐스트를 구현합니다 .</target>
        </trans-unit>
        <trans-unit id="ff4cc4fdb32d0e79c9536f6d66d8396bbf61c41a" translate="yes" xml:space="preserve">
          <source>Implements common functionality for StaticForeachDeclaration and StaticForeachStatement This performs the necessary lowerings before dmd.statementsem.makeTupleForeach can be used to expand the corresponding &lt;code&gt;static foreach&lt;/code&gt; declaration or statement.</source>
          <target state="translated">StaticForeachDeclaration 및 StaticForeachStatement에 대한 공통 기능 구현 이는 dmd.statementsem.makeTupleForeach를 사용하여 해당 &lt;code&gt;static foreach&lt;/code&gt; 선언 또는 명령문 을 확장하기 전에 필요한 낮추기를 수행합니다 .</target>
        </trans-unit>
        <trans-unit id="33e291a05be91fd5868ef9b486e72f36172b61e4" translate="yes" xml:space="preserve">
          <source>Implements functionality to read Comma Separated Values and its variants from an &lt;a href=&quot;std_range_primitives#isInputRange&quot;&gt;input range&lt;/a&gt; of &lt;code&gt;dchar&lt;/code&gt;.</source>
          <target state="translated">콤마를 읽는 기능은 이물질의 값과 그 변형을 구분 &lt;a href=&quot;std_range_primitives#isInputRange&quot;&gt;입력 범위&lt;/a&gt; 의 &lt;code&gt;dchar&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e78fb12359a92b10736f7ddffd604a688feb1037" translate="yes" xml:space="preserve">
          <source>Implements logging facilities.</source>
          <target state="translated">로깅 기능을 구현합니다.</target>
        </trans-unit>
        <trans-unit id="1c9526ff0c5c9d17f08ea2d94e25202e075b8278" translate="yes" xml:space="preserve">
          <source>Implements low-level time primitives.</source>
          <target state="translated">저수준 시간 프리미티브를 구현합니다.</target>
        </trans-unit>
        <trans-unit id="f10aa3fdc814d436934036f8b3d2932b2c1a116c" translate="yes" xml:space="preserve">
          <source>Implements mixin types.</source>
          <target state="translated">믹스 인 유형을 구현합니다.</target>
        </trans-unit>
        <trans-unit id="5720cf3a68f9171f96627020e4e3f8a88a48971a" translate="yes" xml:space="preserve">
          <source>Implements operators with built-in integers on the left-hand side and &lt;code&gt;BigInt&lt;/code&gt; on the right-hand side.</source>
          <target state="translated">왼쪽에 내장 정수 가 있고 오른쪽에 &lt;code&gt;BigInt&lt;/code&gt; 가있는 연산자를 구현 합니다.</target>
        </trans-unit>
        <trans-unit id="7e5de803b2338c86b3532da481b13f228f6a981e" translate="yes" xml:space="preserve">
          <source>Implements routines related to exceptions.</source>
          <target state="translated">예외와 관련된 루틴을 구현합니다.</target>
        </trans-unit>
        <trans-unit id="f320bc582113b4cafa3cdb495549c72756dd174e" translate="yes" xml:space="preserve">
          <source>Implements saturation for operators &lt;code&gt;+&lt;/code&gt;, &lt;code&gt;-&lt;/code&gt; (unary and binary), &lt;code&gt;*&lt;/code&gt;, &lt;code&gt;/&lt;/code&gt;, &lt;code&gt;%&lt;/code&gt;, &lt;code&gt;^^&lt;/code&gt;, &lt;code&gt;&amp;amp;&lt;/code&gt;, &lt;code&gt;|&lt;/code&gt;, &lt;code&gt;^&lt;/code&gt;, &lt;code&gt;&amp;lt;&amp;lt;&lt;/code&gt;, &lt;code&gt;&amp;gt;&amp;gt;&lt;/code&gt;, and &lt;code&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">연산자 &lt;code&gt;+&lt;/code&gt; , &lt;code&gt;-&lt;/code&gt; (단항 및 이진), &lt;code&gt;*&lt;/code&gt; , &lt;code&gt;/&lt;/code&gt; , &lt;code&gt;%&lt;/code&gt; , &lt;code&gt;^^&lt;/code&gt; , &lt;code&gt;&amp;amp;&lt;/code&gt; , &lt;code&gt;|&lt;/code&gt; , &lt;code&gt;^&lt;/code&gt; , &lt;code&gt;&amp;lt;&amp;lt;&lt;/code&gt; , &lt;code&gt;&amp;gt;&amp;gt;&lt;/code&gt; 및 &lt;code&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="12ddcd2c7713838aaff094e0d8442224022b567f" translate="yes" xml:space="preserve">
          <source>Implements saturation for operators &lt;code&gt;+=&lt;/code&gt;, &lt;code&gt;-=&lt;/code&gt;, &lt;code&gt;*=&lt;/code&gt;, &lt;code&gt;/=&lt;/code&gt;, &lt;code&gt;%=&lt;/code&gt;, &lt;code&gt;^^=&lt;/code&gt;, &lt;code&gt;&amp;amp;=&lt;/code&gt;, &lt;code&gt;|=&lt;/code&gt;, &lt;code&gt;^=&lt;/code&gt;, &lt;code&gt;&amp;lt;&amp;lt;=&lt;/code&gt;, &lt;code&gt;&amp;gt;&amp;gt;=&lt;/code&gt;, and &lt;code&gt;&amp;gt;&amp;gt;&amp;gt;=&lt;/code&gt;. This hook is called if the result of the binary operation does not fit in &lt;code&gt;Lhs&lt;/code&gt; without loss of information or a change in sign.</source>
          <target state="translated">연산자 &lt;code&gt;+=&lt;/code&gt; , &lt;code&gt;-=&lt;/code&gt; , &lt;code&gt;*=&lt;/code&gt; , &lt;code&gt;/=&lt;/code&gt; , &lt;code&gt;%=&lt;/code&gt; , &lt;code&gt;^^=&lt;/code&gt; , &lt;code&gt;&amp;amp;=&lt;/code&gt; , &lt;code&gt;|=&lt;/code&gt; , &lt;code&gt;^=&lt;/code&gt; , &lt;code&gt;&amp;lt;&amp;lt;=&lt;/code&gt; , &lt;code&gt;&amp;gt;&amp;gt;=&lt;/code&gt; , &lt;code&gt;&amp;gt;&amp;gt;&amp;gt;=&lt;/code&gt; 연산자의 채도를 구현 합니다. 이진 연산 결과 가 정보 손실이나 부호 변경없이 &lt;code&gt;Lhs&lt;/code&gt; 에 맞지 않으면이 후크가 호출됩니다 .</target>
        </trans-unit>
        <trans-unit id="be45676fa18a18d1d8737b834959d03a5f13376c" translate="yes" xml:space="preserve">
          <source>Implements the 'common' IEEE CRC32 variant (LSB-first order, Initial value uint.max, complement result)</source>
          <target state="translated">'공통'IEEE CRC32 변형 (LSB-first order, 초기 값 uint.max, 보완 결과) 구현</target>
        </trans-unit>
        <trans-unit id="c54fb55bf997400be69c40f0614b3e9b7db9616f" translate="yes" xml:space="preserve">
          <source>Implements the &lt;a href=&quot;http://tinyurl.com/2zb9yr&quot;&gt;secant method&lt;/a&gt; for finding a root of the function &lt;code&gt;fun&lt;/code&gt; starting from points &lt;code&gt;[xn_1, x_n]&lt;/code&gt; (ideally close to the root). &lt;code&gt;Num&lt;/code&gt; may be &lt;code&gt;float&lt;/code&gt;, &lt;code&gt;double&lt;/code&gt;, or &lt;code&gt;real&lt;/code&gt;.</source>
          <target state="translated">점 &lt;code&gt;[xn_1, x_n]&lt;/code&gt; (이상적으로 근에 가까운) 에서 시작 하여 함수 &lt;code&gt;fun&lt;/code&gt; 의 근을 찾기위한 &lt;a href=&quot;http://tinyurl.com/2zb9yr&quot;&gt;시컨트 방법&lt;/a&gt; 을 구현합니다 . &lt;code&gt;Num&lt;/code&gt; 은 &lt;code&gt;float&lt;/code&gt; , &lt;code&gt;double&lt;/code&gt; 또는 &lt;code&gt;real&lt;/code&gt; 일 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="2b80a316e588d021f8c65a6036707b88ad521159" translate="yes" xml:space="preserve">
          <source>Implements the &lt;code&gt;OutputRange&lt;/code&gt; interface for all types E and wraps the &lt;code&gt;put&lt;/code&gt; method for each type &lt;code&gt;E&lt;/code&gt; in a virtual function.</source>
          <target state="translated">모든 유형 E에 대해 &lt;code&gt;OutputRange&lt;/code&gt; 인터페이스를 구현하고 각 유형 &lt;code&gt;E&lt;/code&gt; 에 대한 &lt;code&gt;put&lt;/code&gt; 메소드를 가상 함수로 랩핑합니다 .</target>
        </trans-unit>
        <trans-unit id="09d37307ce6ae6ae1585ab5db7a54050805cc742" translate="yes" xml:space="preserve">
          <source>Implements the MurmurHash3 functions. You can specify the &lt;code&gt;size&lt;/code&gt; of the hash in bit. For 128 bit hashes you can specify whether to optimize for 32 or 64 bit architectures. If you don't specify the &lt;code&gt;opt&lt;/code&gt; value it will select the fastest version of the host platform.</source>
          <target state="translated">MurmurHash3 기능을 구현합니다. 해시 의 &lt;code&gt;size&lt;/code&gt; 를 비트 단위 로 지정할 수 있습니다 . 128 비트 해시의 경우 32 비트 또는 64 비트 아키텍처에 대한 최적화 여부를 지정할 수 있습니다. &lt;code&gt;opt&lt;/code&gt; 값을 지정하지 않으면 가장 빠른 버전의 호스트 플랫폼이 선택됩니다.</target>
        </trans-unit>
        <trans-unit id="7ab18d84fa65349ea46fc1a23e6ee0555763f6a9" translate="yes" xml:space="preserve">
          <source>Implements the foreach &lt;code&gt;opApply&lt;/code&gt; interface for json arrays.</source>
          <target state="translated">json 배열을위한 foreach &lt;code&gt;opApply&lt;/code&gt; 인터페이스를 구현합니다 .</target>
        </trans-unit>
        <trans-unit id="45e448d8088d50f1f95bb79e479da8d5a8f8521b" translate="yes" xml:space="preserve">
          <source>Implements the foreach &lt;code&gt;opApply&lt;/code&gt; interface for json objects.</source>
          <target state="translated">json 객체를위한 foreach &lt;code&gt;opApply&lt;/code&gt; 인터페이스를 구현 합니다.</target>
        </trans-unit>
        <trans-unit id="c7b156318387d032d75e77a645f93fbb91cfe8d1" translate="yes" xml:space="preserve">
          <source>Implements the higher order filter function. The predicate is passed to &lt;a href=&quot;std_functional#unaryFun&quot;&gt;&lt;code&gt;std.functional.unaryFun&lt;/code&gt;&lt;/a&gt;, and can either accept a string, or any callable that can be executed via &lt;code&gt;pred(element)&lt;/code&gt;.</source>
          <target state="translated">고차 필터 기능을 구현합니다. 술어는 &lt;a href=&quot;std_functional#unaryFun&quot;&gt; &lt;code&gt;std.functional.unaryFun&lt;/code&gt; 에&lt;/a&gt; 전달되며 문자열 또는 &lt;code&gt;pred(element)&lt;/code&gt; 를 통해 실행할 수있는 호출 가능 항목을 승인 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="881b721a1385bc8ef11d90c4f0aac7e1c9f98dea" translate="yes" xml:space="preserve">
          <source>Implements the homonym function (also known as &lt;code&gt;accumulate&lt;/code&gt;, &lt;code&gt;compress&lt;/code&gt;, &lt;code&gt;inject&lt;/code&gt;, or &lt;code&gt;foldl&lt;/code&gt;) present in various programming languages of functional flavor.</source>
          <target state="translated">구현 동음 이의어 기능 (라고도 &lt;code&gt;accumulate&lt;/code&gt; , &lt;code&gt;compress&lt;/code&gt; , &lt;code&gt;inject&lt;/code&gt; 또는 &lt;code&gt;foldl&lt;/code&gt; 기능성 맛 다양한 프로그래밍 언어)이 존재한다.</target>
        </trans-unit>
        <trans-unit id="2de496f11d0a61e3ec35b13526a647a0eda0aa53" translate="yes" xml:space="preserve">
          <source>Implements the homonym function (also known as &lt;code&gt;accumulate&lt;/code&gt;, &lt;code&gt;compress&lt;/code&gt;, &lt;code&gt;inject&lt;/code&gt;, or &lt;code&gt;foldl&lt;/code&gt;) present in various programming languages of functional flavor. The call &lt;code&gt;fold!(fun)(range, seed)&lt;/code&gt; first assigns &lt;code&gt;seed&lt;/code&gt; to an internal variable &lt;code&gt;result&lt;/code&gt;, also called the accumulator. Then, for each element &lt;code&gt;x&lt;/code&gt; in &lt;code&gt;range&lt;/code&gt;, &lt;code&gt;result = fun(result, x)&lt;/code&gt; gets evaluated. Finally, &lt;code&gt;result&lt;/code&gt; is returned. The one-argument version &lt;code&gt;fold!(fun)(range)&lt;/code&gt; works similarly, but it uses the first element of the range as the seed (the range must be non-empty).</source>
          <target state="translated">구현 동음 이의어 기능 (라고도 &lt;code&gt;accumulate&lt;/code&gt; , &lt;code&gt;compress&lt;/code&gt; , &lt;code&gt;inject&lt;/code&gt; 또는 &lt;code&gt;foldl&lt;/code&gt; 기능성 맛 다양한 프로그래밍 언어)이 존재한다. 콜 &lt;code&gt;fold!(fun)(range, seed)&lt;/code&gt; 먼저 &lt;code&gt;seed&lt;/code&gt; 를 내부 변수 &lt;code&gt;result&lt;/code&gt; 에 할당 합니다 (누산기라고도 함). 그리고, 각각의 요소에 대한 &lt;code&gt;x&lt;/code&gt; 의 &lt;code&gt;range&lt;/code&gt; , &lt;code&gt;result = fun(result, x)&lt;/code&gt; 평가를 얻는다. 마지막으로 &lt;code&gt;result&lt;/code&gt; 가 반환됩니다. 1 인수 버전 &lt;code&gt;fold!(fun)(range)&lt;/code&gt; 도 비슷하게 작동하지만 범위의 첫 번째 요소를 시드로 사용합니다 (범위는 비어 있지 않아야 함).</target>
        </trans-unit>
        <trans-unit id="3a102abac10f402f998c7a93f6d1ecbc38ae5d29" translate="yes" xml:space="preserve">
          <source>Implements the homonym function (also known as &lt;code&gt;accumulate&lt;/code&gt;, &lt;code&gt;compress&lt;/code&gt;, &lt;code&gt;inject&lt;/code&gt;, or &lt;code&gt;foldl&lt;/code&gt;) present in various programming languages of functional flavor. There is also &lt;a href=&quot;#fold&quot;&gt;&lt;code&gt;fold&lt;/code&gt;&lt;/a&gt; which does the same thing but with the opposite parameter order. The call &lt;code&gt;reduce!(fun)(seed, range)&lt;/code&gt; first assigns &lt;code&gt;seed&lt;/code&gt; to an internal variable &lt;code&gt;result&lt;/code&gt;, also called the accumulator. Then, for each element &lt;code&gt;x&lt;/code&gt; in &lt;code&gt;range&lt;/code&gt;, &lt;code&gt;result = fun(result, x)&lt;/code&gt; gets evaluated. Finally, &lt;code&gt;result&lt;/code&gt; is returned. The one-argument version &lt;code&gt;reduce!(fun)(range)&lt;/code&gt; works similarly, but it uses the first element of the range as the seed (the range must be non-empty).</source>
          <target state="translated">구현 동음 이의어 기능 (라고도 &lt;code&gt;accumulate&lt;/code&gt; , &lt;code&gt;compress&lt;/code&gt; , &lt;code&gt;inject&lt;/code&gt; 또는 &lt;code&gt;foldl&lt;/code&gt; 기능성 맛 다양한 프로그래밍 언어)이 존재한다. 매개 변수 순서가 반대이지만 동일한 작업을 수행하는 &lt;a href=&quot;#fold&quot;&gt; &lt;code&gt;fold&lt;/code&gt; &lt;/a&gt; 도 있습니다 . 이 호출은 &lt;code&gt;reduce!(fun)(seed, range)&lt;/code&gt; 첫 양수인의 &lt;code&gt;seed&lt;/code&gt; 내부 변수에 &lt;code&gt;result&lt;/code&gt; 도 축적했다. 그리고, 각각의 요소에 대한 &lt;code&gt;x&lt;/code&gt; 의 &lt;code&gt;range&lt;/code&gt; , &lt;code&gt;result = fun(result, x)&lt;/code&gt; 평가를 얻는다. 마지막으로 &lt;code&gt;result&lt;/code&gt; 가 반환됩니다. 1 인수 버전 &lt;code&gt;reduce!(fun)(range)&lt;/code&gt; 비슷하게 작동하지만 범위의 첫 번째 요소를 시드로 사용합니다 (범위가 비어 있지 않아야 함).</target>
        </trans-unit>
        <trans-unit id="d222f5f35083b3fe479ec859b88f2b5c2d29bc99" translate="yes" xml:space="preserve">
          <source>Implements the homonym function (also known as &lt;code&gt;transform&lt;/code&gt;) present in many languages of functional flavor. The call &lt;code&gt;map!(fun)(range)&lt;/code&gt; returns a range of which elements are obtained by applying &lt;code&gt;fun(a)&lt;/code&gt; left to right for all elements &lt;code&gt;a&lt;/code&gt; in &lt;code&gt;range&lt;/code&gt;. The original ranges are not changed. Evaluation is done lazily.</source>
          <target state="translated">여러 언어의 기능적 풍미에 있는 homonym 함수 ( &lt;code&gt;transform&lt;/code&gt; 이라고도 함)를 구현합니다 . 호출 &lt;code&gt;map!(fun)(range)&lt;/code&gt; 요소를 적용하여 얻을 수있는 범위를 반환 &lt;code&gt;fun(a)&lt;/code&gt; 모든 요소를 왼쪽에서 오른쪽으로 의 &lt;code&gt;range&lt;/code&gt; . 원래 범위는 변경되지 않습니다. 평가는 느리게 수행됩니다. &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="38aa73eed2ebaa6990e6725195bf642f0bb7894e" translate="yes" xml:space="preserve">
          <source>Implements the most derived interface that &lt;code&gt;R&lt;/code&gt; works with and wraps all relevant range primitives in virtual functions. If &lt;code&gt;R&lt;/code&gt; is already derived from the &lt;code&gt;InputRange&lt;/code&gt; interface, aliases itself away.</source>
          <target state="translated">&lt;code&gt;R&lt;/code&gt; 이 작동 하는 가장 파생 된 인터페이스를 구현하고 모든 관련 범위 프리미티브를 가상 함수로 래핑합니다. &lt;code&gt;R&lt;/code&gt; 이 이미 &lt;code&gt;InputRange&lt;/code&gt; 인터페이스 에서 파생 된 경우 별명 자체가 사라집니다.</target>
        </trans-unit>
        <trans-unit id="0aed3bb7204f0f1333835ef5bde3ef0b25325996" translate="yes" xml:space="preserve">
          <source>Implements the range interface primitive &lt;code&gt;back&lt;/code&gt; for built-in arrays. Due to the fact that nonmember functions can be called with the first argument using the dot notation, &lt;code&gt;array.back&lt;/code&gt; is equivalent to &lt;code&gt;back(array)&lt;/code&gt;. For &lt;a href=&quot;http://dlang.org/glossary.html#narrow%20strings&quot;&gt;narrow strings&lt;/a&gt;, &lt;code&gt;back&lt;/code&gt; automatically returns the last &lt;a href=&quot;http://dlang.org/glossary.html#code%20point&quot;&gt;code point&lt;/a&gt; as a &lt;code&gt;dchar&lt;/code&gt;.</source>
          <target state="translated">내장 배열에 대한 범위 인터페이스 기본 요소를 &lt;code&gt;back&lt;/code&gt; 구현합니다 . 점 표기법을 사용하여 첫 번째 인수로 비 멤버 함수를 호출 할 수 있기 때문에 &lt;code&gt;array.back&lt;/code&gt; 은 &lt;code&gt;back(array)&lt;/code&gt; 와 같습니다 . 들어 &lt;a href=&quot;http://dlang.org/glossary.html#narrow%20strings&quot;&gt;좁은 문자열&lt;/a&gt; , &lt;code&gt;back&lt;/code&gt; 자동으로 마지막 반환 &lt;a href=&quot;http://dlang.org/glossary.html#code%20point&quot;&gt;코드 포인트&lt;/a&gt; A와 &lt;code&gt;dchar&lt;/code&gt; 을 .</target>
        </trans-unit>
        <trans-unit id="b532541671d15b35cef77598c086f1da87e05be3" translate="yes" xml:space="preserve">
          <source>Implements the range interface primitive &lt;code&gt;empty&lt;/code&gt; for types that obey &lt;a href=&quot;#hasLength&quot;&gt;&lt;code&gt;hasLength&lt;/code&gt;&lt;/a&gt; property and for narrow strings. Due to the fact that nonmember functions can be called with the first argument using the dot notation, &lt;code&gt;a.empty&lt;/code&gt; is equivalent to &lt;code&gt;empty(a)&lt;/code&gt;.</source>
          <target state="translated">&lt;a href=&quot;#hasLength&quot;&gt; &lt;code&gt;hasLength&lt;/code&gt; &lt;/a&gt; 특성 을 준수하는 유형 및 좁은 문자열에 대해 범위 인터페이스 기본 요소 &lt;code&gt;empty&lt;/code&gt; 을 구현합니다 . 점 표기법을 사용하여 첫 번째 인수로 비 멤버 함수를 호출 할 수 있기 때문에 &lt;code&gt;a.empty&lt;/code&gt; 는 &lt;code&gt;empty(a)&lt;/code&gt; 와 같습니다 .</target>
        </trans-unit>
        <trans-unit id="62d00f3658d0160b41b82721ed86515030421a62" translate="yes" xml:space="preserve">
          <source>Implements the range interface primitive &lt;code&gt;front&lt;/code&gt; for built-in arrays. Due to the fact that nonmember functions can be called with the first argument using the dot notation, &lt;code&gt;array.front&lt;/code&gt; is equivalent to &lt;code&gt;front(array)&lt;/code&gt;. For &lt;a href=&quot;http://dlang.org/glossary.html#narrow%20strings&quot;&gt;narrow strings&lt;/a&gt;, &lt;code&gt;front&lt;/code&gt; automatically returns the first &lt;a href=&quot;http://dlang.org/glossary.html#code%20point&quot;&gt;code point&lt;/a&gt; as a &lt;code&gt;dchar&lt;/code&gt;.</source>
          <target state="translated">내장 어레이에 대한 레인지 인터페이스 프리미티브 &lt;code&gt;front&lt;/code&gt; 를 구현합니다 . 점 표기법을 사용하여 첫 번째 인수로 비 멤버 함수를 호출 할 수 있기 때문에 &lt;code&gt;array.front&lt;/code&gt; 는 &lt;code&gt;front(array)&lt;/code&gt; 와 같습니다 . 들어 &lt;a href=&quot;http://dlang.org/glossary.html#narrow%20strings&quot;&gt;좁은 문자열&lt;/a&gt; , &lt;code&gt;front&lt;/code&gt; 자동으로 첫 번째 반환 &lt;a href=&quot;http://dlang.org/glossary.html#code%20point&quot;&gt;코드 포인트&lt;/a&gt; A와 &lt;code&gt;dchar&lt;/code&gt; 을 .</target>
        </trans-unit>
        <trans-unit id="c1778775edc47d955b8410b9303b511a8ed36740" translate="yes" xml:space="preserve">
          <source>Implements the range interface primitive &lt;code&gt;popBack&lt;/code&gt; for built-in arrays. Due to the fact that nonmember functions can be called with the first argument using the dot notation, &lt;code&gt;array.popBack&lt;/code&gt; is equivalent to &lt;code&gt;popBack(array)&lt;/code&gt;. For &lt;a href=&quot;http://dlang.org/glossary.html#narrow%20strings&quot;&gt;narrow strings&lt;/a&gt;, &lt;code&gt;popFront&lt;/code&gt; automatically eliminates the last &lt;a href=&quot;http://dlang.org/glossary.html#code%20point&quot;&gt;code point&lt;/a&gt;.</source>
          <target state="translated">내장 배열에 대한 범위 인터페이스 기본 &lt;code&gt;popBack&lt;/code&gt; 을 구현합니다 . 점 표기법을 사용하여 첫 번째 인수로 비 멤버 함수를 호출 할 수 있기 때문에 &lt;code&gt;array.popBack&lt;/code&gt; 은 &lt;code&gt;popBack(array)&lt;/code&gt; 와 같습니다 . 들어 &lt;a href=&quot;http://dlang.org/glossary.html#narrow%20strings&quot;&gt;좁은 문자열&lt;/a&gt; , &lt;code&gt;popFront&lt;/code&gt; 은 자동으로 마지막 제거 &lt;a href=&quot;http://dlang.org/glossary.html#code%20point&quot;&gt;코드 포인트를&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="32e1749a7e79cab97db7229f8dfe1c2b12d27951" translate="yes" xml:space="preserve">
          <source>Implements the range interface primitive &lt;code&gt;popFront&lt;/code&gt; for built-in arrays. Due to the fact that nonmember functions can be called with the first argument using the dot notation, &lt;code&gt;array.popFront&lt;/code&gt; is equivalent to &lt;code&gt;popFront(array)&lt;/code&gt;. For &lt;a href=&quot;http://dlang.org/glossary.html#narrow%20strings&quot;&gt;narrow strings&lt;/a&gt;, &lt;code&gt;popFront&lt;/code&gt; automatically advances to the next code point.</source>
          <target state="translated">내장 배열에 대한 범위 인터페이스 기본 &lt;code&gt;popFront&lt;/code&gt; 를 구현합니다 . 점 표기법을 사용하여 첫 번째 인수로 비 멤버 함수를 호출 할 수 있기 때문에 &lt;code&gt;array.popFront&lt;/code&gt; 는 &lt;code&gt;popFront(array)&lt;/code&gt; 와 같습니다 . 들어 &lt;a href=&quot;http://dlang.org/glossary.html#narrow%20strings&quot;&gt;좁은 문자열&lt;/a&gt; , &lt;code&gt;popFront&lt;/code&gt; 은 자동으로 다음 코드 포인트로 진행한다.</target>
        </trans-unit>
        <trans-unit id="75f6fe2cdac67a27b3428234729f0d9dae7b1837" translate="yes" xml:space="preserve">
          <source>Implements the range interface primitive &lt;code&gt;save&lt;/code&gt; for built-in arrays. Due to the fact that nonmember functions can be called with the first argument using the dot notation, &lt;code&gt;array.save&lt;/code&gt; is equivalent to &lt;code&gt;save(array)&lt;/code&gt;. The function does not duplicate the content of the array, it simply returns its argument.</source>
          <target state="translated">내장 어레이에 대한 범위 인터페이스 기본 &lt;code&gt;save&lt;/code&gt; 을 구현합니다 . 점 표기법을 사용하여 첫 번째 인수로 비 멤버 함수를 호출 할 수 있기 때문에 &lt;code&gt;array.save&lt;/code&gt; 는 &lt;code&gt;save(array)&lt;/code&gt; 와 같습니다 . 이 함수는 배열의 내용을 복제하지 않고 단순히 인수를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="03be7c6392b5500acdd65ba4a7628363c1860d1b" translate="yes" xml:space="preserve">
          <source>Implicit Conversion of Reference Types</source>
          <target state="translated">참조 유형의 암시 적 변환</target>
        </trans-unit>
        <trans-unit id="65a63aa075b83c2fd9eb74a28a95e05ff02e65a6" translate="yes" xml:space="preserve">
          <source>Implicit Conversions</source>
          <target state="translated">암시 적 변환</target>
        </trans-unit>
        <trans-unit id="625a5d30e95ccd8e77f05af4dd624ce180fd702c" translate="yes" xml:space="preserve">
          <source>Implicit Nesting</source>
          <target state="translated">암시 적 중첩</target>
        </trans-unit>
        <trans-unit id="341437e8c6d229adb9641f4f980b4bd232dec666" translate="yes" xml:space="preserve">
          <source>Implicit Qualifier Conversions</source>
          <target state="translated">암시 적 한정자 변환</target>
        </trans-unit>
        <trans-unit id="e71105f02c13309129677ece5605a0283f9f1fad" translate="yes" xml:space="preserve">
          <source>Implicit Type Inference</source>
          <target state="translated">암시 적 유형 추론</target>
        </trans-unit>
        <trans-unit id="849cfc1637b33ec7b03284c956943ea3a6ee1ec6" translate="yes" xml:space="preserve">
          <source>Implicit conversions are used to automatically convert types as required.</source>
          <target state="translated">암시 적 변환은 필요에 따라 유형을 자동으로 변환하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="16ca50dfa8d5e344f045161409c8efa6033ef01d" translate="yes" xml:space="preserve">
          <source>Implicitly calls &lt;code&gt;toJSON&lt;/code&gt; on this JSONValue, like &lt;code&gt;toString&lt;/code&gt;, but also passes</source>
          <target state="translated">암시 적으로 호출 &lt;code&gt;toJSON&lt;/code&gt; 을 같은이 JSONValue에 &lt;code&gt;toString&lt;/code&gt; 뿐만 아니라 전달</target>
        </trans-unit>
        <trans-unit id="61b604cd0d4af75ee155d0f29fe03ab209cdf393" translate="yes" xml:space="preserve">
          <source>Implicitly calls &lt;code&gt;toJSON&lt;/code&gt; on this JSONValue.</source>
          <target state="translated">암시 적으로 호출 &lt;code&gt;toJSON&lt;/code&gt; 을 이 JSONValue에.</target>
        </trans-unit>
        <trans-unit id="fe09202f421258205fc0af0f7cc90ba8af70d44d" translate="yes" xml:space="preserve">
          <source>Import Declaration</source>
          <target state="translated">수입 신고</target>
        </trans-unit>
        <trans-unit id="07b4de4b6291e3b54e69fe2f2020c76048ffb706" translate="yes" xml:space="preserve">
          <source>Import Expressions</source>
          <target state="translated">식 가져 오기</target>
        </trans-unit>
        <trans-unit id="9633d9e6ebf62f84de8d5fc4824a9ee44e1f1708" translate="yes" xml:space="preserve">
          <source>Import declarations may be used at any scope. For example:</source>
          <target state="translated">수입 신고는 모든 범위에서 사용될 수 있습니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="e0559377cfba6b8aed12863122b1b2dcc118cb64" translate="yes" xml:space="preserve">
          <source>ImportDeclaration</source>
          <target state="translated">ImportDeclaration</target>
        </trans-unit>
        <trans-unit id="015ce9a6eb4a1d7698028975a16c0fe2ee6d7aa2" translate="yes" xml:space="preserve">
          <source>Improve behavior of allocators sensitive to allocation sizes, such as &lt;code&gt;FreeList&lt;/code&gt; and &lt;code&gt;FreeTree&lt;/code&gt;. Rounding allocation requests up makes for smaller free lists/trees at the cost of slack memory (internal fragmentation).</source>
          <target state="translated">&lt;code&gt;FreeList&lt;/code&gt; 및 &lt;code&gt;FreeTree&lt;/code&gt; 와 같은 할당 크기에 민감한 할당 자의 동작을 향상시킵니다 . 반올림 할당 요청은 여유 메모리 (내부 조각화)를 희생시키면서 더 작은 여유 목록 / 트리를 만듭니다.</target>
        </trans-unit>
        <trans-unit id="aef36502d67b0520654deb764dd055a7e905cfdd" translate="yes" xml:space="preserve">
          <source>In</source>
          <target state="translated">In</target>
        </trans-unit>
        <trans-unit id="dcd96af0868ef4c663e6ad3dcef261c5095893f1" translate="yes" xml:space="preserve">
          <source>In C, arrays are passed to functions as pointers even if the function prototype says its an array. In D, static arrays are passed by value, not by reference. Thus, the function prototype must be adjusted to match what C expects.</source>
          <target state="translated">C에서는 함수 프로토 타입에 배열이 있다고해도 배열은 포인터로 함수에 전달됩니다. D에서 정적 배열은 참조가 아닌 값으로 전달됩니다. 따라서 함수 프로토 타입은 C가 기대하는 것과 일치하도록 조정해야합니다.</target>
        </trans-unit>
        <trans-unit id="fb107b811fc18be0d73632390771a7270ede12ef" translate="yes" xml:space="preserve">
          <source>In Expressions</source>
          <target state="translated">식에서</target>
        </trans-unit>
        <trans-unit id="98ab2686a50e4805c42c072cadd55e7f182ad96a" translate="yes" xml:space="preserve">
          <source>In a Windows DLL, if this function is called via DllMain with argument DLL_PROCESS_DETACH, the thread is terminated forcefully without proper cleanup as a deadlock would happen otherwise.</source>
          <target state="translated">Windows DLL에서이 함수가 DLL_PROCESS_DETACH 인수와 함께 DllMain을 통해 호출되면 교착 상태가 발생할 수 있으므로 적절한 정리없이 스레드가 강제 종료됩니다.</target>
        </trans-unit>
        <trans-unit id="31b5ad319495b8bf3a1c002a8507f2abf1208f6d" translate="yes" xml:space="preserve">
          <source>In a constructor body, if a delegate constructor is called, all field assignments are considered assignments. Otherwise, the first instance of field assignment is its initialization, and assignments of the form &lt;code&gt;field = expression&lt;/code&gt; are treated as equivalent to &lt;code&gt;typeof(field)(expression)&lt;/code&gt;. The values of fields may be read before initialization or construction with a delegate constructor.</source>
          <target state="translated">생성자 본문에서 델리게이트 생성자가 호출되면 모든 필드 할당이 할당으로 간주됩니다. 그렇지 않은 경우 필드 할당의 첫 번째 인스턴스는 초기화이며 &lt;code&gt;field = expression&lt;/code&gt; 형식의 할당은 &lt;code&gt;typeof(field)(expression)&lt;/code&gt; 과 동일하게 처리됩니다 . 델리게이트 생성자를 사용하여 초기화 또는 구성하기 전에 필드 값을 읽을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="58b4b4504d8850da0fbabfc52a3239ec3b0e0a33" translate="yes" xml:space="preserve">
          <source>In a constructor body, the first instance of field assignment is its initialization.</source>
          <target state="translated">생성자 본문에서 필드 할당의 첫 번째 인스턴스는 초기화입니다.</target>
        </trans-unit>
        <trans-unit id="3c66c503e379c4155d015b11fbc1dc5940286649" translate="yes" xml:space="preserve">
          <source>In a declaration declaring multiple symbols, all the declarations must be of the same type:</source>
          <target state="translated">여러 기호를 선언하는 선언에서 모든 선언은 동일한 유형이어야합니다.</target>
        </trans-unit>
        <trans-unit id="9e9fe9946b014b42fb5205022b5c12ede51b25c5" translate="yes" xml:space="preserve">
          <source>In a typical application, you might also want to consider using a non-blocking socket instead of setting a timeout on a blocking one.</source>
          <target state="translated">일반적인 응용 프로그램에서는 차단 소켓에 시간 초과를 설정하는 대신 비 차단 소켓 사용을 고려할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="190918005b49f5fd22012e2b51e50c26bb8bb06b" translate="yes" xml:space="preserve">
          <source>In addition to &lt;a href=&quot;#Variant&quot;&gt;&lt;code&gt;Variant&lt;/code&gt;&lt;/a&gt;, this module also defines the &lt;a href=&quot;#Algebraic&quot;&gt;&lt;code&gt;Algebraic&lt;/code&gt;&lt;/a&gt; type constructor. Unlike &lt;code&gt;Variant&lt;/code&gt;, &lt;code&gt;Algebraic&lt;/code&gt; only allows a finite set of types, which are specified in the instantiation (e.g. &lt;code&gt;Algebraic!(int, string)&lt;/code&gt; may only hold an &lt;code&gt;int&lt;/code&gt; or a &lt;code&gt;string&lt;/code&gt;).</source>
          <target state="translated">외에 &lt;a href=&quot;#Variant&quot;&gt; &lt;code&gt;Variant&lt;/code&gt; &lt;/a&gt; ,이 모듈은 정의 &lt;a href=&quot;#Algebraic&quot;&gt; &lt;code&gt;Algebraic&lt;/code&gt; &lt;/a&gt; 형 생성자를. 달리 &lt;code&gt;Variant&lt;/code&gt; , &lt;code&gt;Algebraic&lt;/code&gt; 단지 인스턴스에 지정된 유형의 유한 집합 (예 : 수 &lt;code&gt;Algebraic!(int, string)&lt;/code&gt; 만 보유 할 수 &lt;code&gt;int&lt;/code&gt; 또는 &lt;code&gt;string&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="bd56298f652baf17103962e16813e3a6aed52cf4" translate="yes" xml:space="preserve">
          <source>In addition to convenience, these functions are slightly more efficient than manually creating an Fft object for a single use, as the Fft object is deterministically destroyed before these functions return.</source>
          <target state="translated">편의성 외에도 이러한 기능은 반환하기 전에 Fft 개체가 결정적으로 파괴되므로 일회용으로 Fft 개체를 수동으로 만드는 것보다 약간 더 효율적입니다.</target>
        </trans-unit>
        <trans-unit id="570c956c4c6e2dbde87f61ff5e2c49153a8df2e6" translate="yes" xml:space="preserve">
          <source>In addition to random number generators, this module features distributions, which skew a generator's output statistical distribution in various ways. So far the uniform distribution for integers and real numbers have been implemented.</source>
          <target state="translated">난수 생성기 외에도이 모듈은 분포를 특징으로하며 다양한 방식으로 생성기의 출력 통계 분포를 왜곡합니다. 지금까지 정수와 실수에 대한 균일 분포가 구현되었습니다.</target>
        </trans-unit>
        <trans-unit id="5295840dbe23153fe2e689d001aa6ebadfba5f26" translate="yes" xml:space="preserve">
          <source>In addition, --DRT-gcopt=help will show the list of options and their current settings.</source>
          <target state="translated">또한 --DRT-gcopt = help는 옵션 목록과 현재 설정을 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="b2fcea4fb949d2ee554c72114c12b58084a4d18d" translate="yes" xml:space="preserve">
          <source>In addition, the data &lt;code&gt;callerSize&lt;/code&gt;, &lt;code&gt;callerModule&lt;/code&gt;, &lt;code&gt;callerFile&lt;/code&gt;, &lt;code&gt;callerLine&lt;/code&gt;, and &lt;code&gt;callerTime&lt;/code&gt; is associated with each specific allocation. This data prefixes each allocation.</source>
          <target state="translated">또한 데이터 &lt;code&gt;callerSize&lt;/code&gt; , &lt;code&gt;callerModule&lt;/code&gt; , &lt;code&gt;callerFile&lt;/code&gt; , &lt;code&gt;callerLine&lt;/code&gt; 및 &lt;code&gt;callerTime&lt;/code&gt; 은 각 특정 할당과 연관됩니다. 이 데이터는 각 할당의 접두사입니다.</target>
        </trans-unit>
        <trans-unit id="8bb9d27fa1cfa7a17c0f438e8ee45a8ac856bdb5" translate="yes" xml:space="preserve">
          <source>In algorithms partitioning ranges in two, preserve relative ordering of elements only to the left of the partition point.</source>
          <target state="translated">알고리즘 분할 범위는 2로, 분할 지점의 왼쪽에만 요소의 상대적 순서를 유지하십시오.</target>
        </trans-unit>
        <trans-unit id="a4c7a53fdd584b663429b65ac4f17edc28d07354" translate="yes" xml:space="preserve">
          <source>In all cases the function returns the built-in result of &lt;code&gt;lhs == rhs&lt;/code&gt;.</source>
          <target state="translated">모든 경우에 함수는 내장 결과 &lt;code&gt;lhs == rhs&lt;/code&gt; 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="a66898347b51f7c1d0527a1edb8a6b3cf367a27a" translate="yes" xml:space="preserve">
          <source>In all cases, a two-symbols versions is also accepted, in which case the first symbol (of integral type, e.g. &lt;code&gt;ulong&lt;/code&gt; or &lt;code&gt;uint&lt;/code&gt;) tracks the zero-based number of the current line.</source>
          <target state="translated">모든 경우에 두 개의 기호 버전도 허용되며,이 경우 첫 번째 기호 (예 : &lt;code&gt;ulong&lt;/code&gt; 또는 &lt;code&gt;uint&lt;/code&gt; )는 현재 행의 0부터 시작하는 숫자를 추적합니다.</target>
        </trans-unit>
        <trans-unit id="fb219f6585d8061af3f052a290762bb948e1e8d6" translate="yes" xml:space="preserve">
          <source>In all cases, returns &lt;code&gt;lhs &amp;lt; rhs ? -1 : lhs &amp;gt; rhs&lt;/code&gt;. The result is not autocorrected in case of an erroneous comparison.</source>
          <target state="translated">모든 경우에 &lt;code&gt;lhs &amp;lt; rhs ? -1 : lhs &amp;gt; rhs&lt;/code&gt; . 잘못된 비교의 경우 결과가 자동 수정되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="cb4bca7a9dd4559557c8f7c4ee56255838258c7f" translate="yes" xml:space="preserve">
          <source>In all cases, the concatenation of the returned ranges spans the entire &lt;code&gt;haystack&lt;/code&gt;.</source>
          <target state="translated">모든 경우에, 반환 된 범위의 연결은 전체 &lt;code&gt;haystack&lt;/code&gt; 에 걸쳐 있습니다 .</target>
        </trans-unit>
        <trans-unit id="fac8533d039fb2ca10f37bea36476dc0de1df00b" translate="yes" xml:space="preserve">
          <source>In all other cases, a simple element by element addition is done.</source>
          <target state="translated">다른 모든 경우에는 요소 별 간단한 요소 추가가 수행됩니다.</target>
        </trans-unit>
        <trans-unit id="394148797f50691adb9a270f990a5eaca722863e" translate="yes" xml:space="preserve">
          <source>In all other cases, the built-in behavior is carried out.</source>
          <target state="translated">다른 모든 경우에는 내장 동작이 수행됩니다.</target>
        </trans-unit>
        <trans-unit id="b68e1d58907e07140ccd3efadbc43c332f170e2d" translate="yes" xml:space="preserve">
          <source>In all other respects this function works just like &lt;code&gt;spawnProcess&lt;/code&gt;. Please refer to the &lt;a href=&quot;#spawnProcess&quot;&gt;&lt;code&gt;spawnProcess&lt;/code&gt;&lt;/a&gt; documentation for descriptions of the other function parameters, the return value and any exceptions that may be thrown.</source>
          <target state="translated">다른 모든 측면에서이 함수는 &lt;code&gt;spawnProcess&lt;/code&gt; 처럼 작동합니다 . 다른 함수 매개 변수, 반환 값 및 발생할 수있는 예외에 대한 설명은 &lt;a href=&quot;#spawnProcess&quot;&gt; &lt;code&gt;spawnProcess&lt;/code&gt; &lt;/a&gt; 설명서를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="1cc108da5c2c3788f98a6edf95e1a63a36afb311" translate="yes" xml:space="preserve">
          <source>In all string literal forms, an &lt;a href=&quot;#EndOfLine&quot;&gt;&lt;i&gt;EndOfLine&lt;/i&gt;&lt;/a&gt; is regarded as a single &lt;code&gt;\n&lt;/code&gt; character.</source>
          <target state="translated">모든 문자열 리터럴 형식에서 &lt;a href=&quot;#EndOfLine&quot;&gt;&lt;i&gt;EndOfLine&lt;/i&gt;&lt;/a&gt; 은 단일 &lt;code&gt;\n&lt;/code&gt; 문자 로 간주됩니다 .</target>
        </trans-unit>
        <trans-unit id="60b9a383afd7a0fd8bdda37a3d66b0a2bbb686e7" translate="yes" xml:space="preserve">
          <source>In all the other respects, these methods are like any other methods. They can be static, have different linkages, have their address taken, etc.</source>
          <target state="translated">다른 모든 측면에서 이러한 방법은 다른 방법과 같습니다. 정적 일 수 있고, 서로 다른 링크가 있거나, 주소를 가져갈 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4560285d4cfc645e0ef24ee3db5890ff1443ed09" translate="yes" xml:space="preserve">
          <source>In both C++ and D, if a struct has zero fields, the struct still has a size of 1 byte. But, in C++ if the struct with zero fields is used as a base struct, its size is zero (called the &lt;a href=&quot;https://en.cppreference.com/w/cpp/language/ebo&quot;&gt;Empty Base Optimization&lt;/a&gt;). There are two methods for emulating this behavior in D. The first forwards references to a function returning a faked reference to the base:</source>
          <target state="translated">C ++ 및 D에서 구조체에 필드가 0 인 경우 구조체의 크기는 여전히 1 바이트입니다. 그러나 C ++에서 필드가 0 인 구조체가 기본 구조체로 사용되면 크기는 0입니다 ( &lt;a href=&quot;https://en.cppreference.com/w/cpp/language/ebo&quot;&gt;Empty Base Optimization&lt;/a&gt; ). D에는이 동작을 에뮬레이트하는 두 가지 방법이 있습니다. 첫 번째는베이스에 대한 가짜 참조를 반환하는 함수에 대한 참조를 전달합니다.</target>
        </trans-unit>
        <trans-unit id="b076421b0fbcae191c5dc3ef2368683aca391393" translate="yes" xml:space="preserve">
          <source>In case of a compound format specifier starting with &lt;code&gt; &quot;%(&quot;&lt;/code&gt; and ending with &lt;code&gt;&quot;%)&quot;&lt;/code&gt;, &lt;code&gt;_nested&lt;/code&gt; contains the string contained within the two separators.</source>
          <target state="translated">복합 형식 지정자의 경우로 시작 &lt;code&gt; &quot;%(&quot;&lt;/code&gt; 와 함께 종료 &lt;code&gt;&quot;%)&quot;&lt;/code&gt; , &lt;code&gt;_nested&lt;/code&gt; 가 두 세퍼레이터에 포함 된 문자열을 포함한다.</target>
        </trans-unit>
        <trans-unit id="b3a4dc18e455dc36e9fd73a88e062b9df8c0d722" translate="yes" xml:space="preserve">
          <source>In case of a compound format specifier, &lt;code&gt;_sep&lt;/code&gt; contains the string positioning after &lt;code&gt;&quot;%|&quot;&lt;/code&gt;. &lt;code&gt;sep is null&lt;/code&gt; means no separator else &lt;code&gt;sep.empty&lt;/code&gt; means 0 length separator.</source>
          <target state="translated">복합 형식 지정자의 경우 &lt;code&gt;_sep&lt;/code&gt; 는 &lt;code&gt;&quot;%|&quot;&lt;/code&gt; 뒤에 문자열 위치를 포함합니다. . &lt;code&gt;sep is null&lt;/code&gt; 경우 구분 기호가 &lt;code&gt;sep.empty&lt;/code&gt; 는 0 길이 구분 기호를 의미합니다.</target>
        </trans-unit>
        <trans-unit id="c172129354e9ba73756e23e6e1f6e0e605a52cb9" translate="yes" xml:space="preserve">
          <source>In case of a log message with &lt;code&gt;LogLevel.fatal&lt;/code&gt; nothing will happen.</source>
          <target state="translated">&lt;code&gt;LogLevel.fatal&lt;/code&gt; 이있는 로그 메시지의 경우 아무 일도 일어나지 않습니다.</target>
        </trans-unit>
        <trans-unit id="3ebef375cea9cd0eca25afb26b6d5c11eab7f3f0" translate="yes" xml:space="preserve">
          <source>In case of an I/O error, an &lt;code&gt;StdioException&lt;/code&gt; is thrown.</source>
          <target state="translated">I / O 오류 가 발생 하면 &lt;code&gt;StdioException&lt;/code&gt; 이 발생합니다.</target>
        </trans-unit>
        <trans-unit id="39a07628e75ba54420c0ee35d2d7947fae3e6e95" translate="yes" xml:space="preserve">
          <source>In case of an I/O error, throws an &lt;a href=&quot;#StdioException&quot;&gt;&lt;code&gt;StdioException&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">I / O 오류가 발생하면 &lt;a href=&quot;#StdioException&quot;&gt; &lt;code&gt;StdioException&lt;/code&gt; 이 발생&lt;/a&gt; 합니다.</target>
        </trans-unit>
        <trans-unit id="6c94ce1719c011e5c08b47d8a880eaa8ed1ab504" translate="yes" xml:space="preserve">
          <source>In case of an I/O error, throws an &lt;code&gt;StdioException&lt;/code&gt;.</source>
          <target state="translated">I / O 오류가 발생하면 &lt;code&gt;StdioException&lt;/code&gt; 이 발생 합니다.</target>
        </trans-unit>
        <trans-unit id="072442afd2ab0da30ef9131acbdaeefa3c16749b" translate="yes" xml:space="preserve">
          <source>In case you want to only enable bundling for some of the parameters, bundling can be turned off with &lt;code&gt;std.getopt.config.noBundling&lt;/code&gt;.</source>
          <target state="translated">일부 매개 변수에 대해서만 번들링을 사용하려는 경우 &lt;code&gt;std.getopt.config.noBundling&lt;/code&gt; 을 사용하여 번들링을 해제 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="01d85046192eeac78a5da365dc7670fdea8d6e86" translate="yes" xml:space="preserve">
          <source>In cases where producing the replacement is the ultimate goal &lt;a href=&quot;#replaceFirstInto&quot;&gt;&lt;code&gt;replaceFirstInto&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#replaceAllInto&quot;&gt;&lt;code&gt;replaceAllInto&lt;/code&gt;&lt;/a&gt; could come in handy as functions that avoid allocations even for replacement.</source>
          <target state="translated">교체 생산이 궁극적 인 목표 인 경우 &lt;a href=&quot;#replaceFirstInto&quot;&gt; &lt;code&gt;replaceFirstInto&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#replaceAllInto&quot;&gt; &lt;code&gt;replaceAllInto&lt;/code&gt; &lt;/a&gt; 는 교체에도 할당을 피하는 기능으로 유용 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e6177e81e2c8557108ce3bebc0ad228b2a46f372" translate="yes" xml:space="preserve">
          <source>In cases where the operand size is ambiguous, as in:</source>
          <target state="translated">다음과 같이 피연산자 크기가 모호한 경우 :</target>
        </trans-unit>
        <trans-unit id="a7faf0c1f2db2bcd1f30944e523bc6e5d4329044" translate="yes" xml:space="preserve">
          <source>In cases where the string in question is already normalized, it is returned unmodified and no memory allocation happens.</source>
          <target state="translated">해당 문자열이 이미 정규화 된 경우 수정되지 않은 상태로 반환되고 메모리 할당이 발생하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="7c2d083ad99e82982be1c8520585485c563982d6" translate="yes" xml:space="preserve">
          <source>In detail, &lt;code&gt;__delete(x)&lt;/code&gt; returns with no effect if &lt;code&gt;x&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt;. Otherwise, it performs the following actions in sequence:</source>
          <target state="translated">구체적으로, &lt;code&gt;x&lt;/code&gt; 가 &lt;code&gt;null&lt;/code&gt; 이면 &lt;code&gt;__delete(x)&lt;/code&gt; 는 아무런 영향을 미치지 않습니다 . 그렇지 않으면 다음 조치를 순서대로 수행합니다.</target>
        </trans-unit>
        <trans-unit id="1a253df89cf875b96f6b0b99a704c14478bd5687" translate="yes" xml:space="preserve">
          <source>In effect &lt;code&gt;takeOne(r)&lt;/code&gt; is somewhat equivalent to &lt;code&gt;take(r, 1)&lt;/code&gt; but in certain interfaces it is important to know statically that the range may only have at most one element.</source>
          <target state="translated">실제로 &lt;code&gt;takeOne(r)&lt;/code&gt; 은 &lt;code&gt;take(r, 1)&lt;/code&gt; 과 다소 동일 하지만 특정 인터페이스에서는 범위에 최대 하나의 요소 만있을 수 있다는 것을 정적으로 아는 것이 중요합니다.</target>
        </trans-unit>
        <trans-unit id="c7e90e95cc2e5d025786e563cb98d86e57f261c9" translate="yes" xml:space="preserve">
          <source>In either case, the content of the buffer is reused across calls. That means &lt;code&gt;front&lt;/code&gt; will not persist after &lt;code&gt;popFront&lt;/code&gt; is called, so if retention is needed, the caller must copy its contents (e.g. by calling &lt;code&gt;buffer.dup&lt;/code&gt;).  In the example above, &lt;code&gt;buffer.length&lt;/code&gt; is 4096 for all iterations, except for the last one, in which case &lt;code&gt;buffer.length&lt;/code&gt; may be less than 4096 (but always greater than zero).  With the mentioned limitations, &lt;code&gt;byChunk&lt;/code&gt; works with any algorithm compatible with input ranges.</source>
          <target state="translated">두 경우 모두 버퍼의 내용이 모든 호출에서 재사용됩니다. 즉 , &lt;code&gt;popFront&lt;/code&gt; 를 호출 한 후에 는 &lt;code&gt;front&lt;/code&gt; 가 유지되지 않으므로 보존이 필요한 경우 호출자는 내용을 복사해야합니다 (예 : &lt;code&gt;buffer.dup&lt;/code&gt; 호출 ). 위의 예에서 &lt;code&gt;buffer.length&lt;/code&gt; 는 마지막 반복을 제외하고 모든 반복에 대해 4096입니다.이 경우 &lt;code&gt;buffer.length&lt;/code&gt; 는 4096보다 작을 수 있지만 항상 0보다 큽니다. 언급 된 제한 사항으로 &lt;code&gt;byChunk&lt;/code&gt; 는 입력 범위와 호환되는 모든 알고리즘에서 작동합니다.</target>
        </trans-unit>
        <trans-unit id="8ec7633257f9bdb307965ba1607259244c489e1d" translate="yes" xml:space="preserve">
          <source>In free list mode, &lt;code&gt;KRRegion&lt;/code&gt; embeds a free blocks list onto the chunk of memory. The free list is circular, coalesced, and sorted by address at all times. Allocations and deallocations take time proportional to the number of previously deallocated blocks. (In practice the cost may be lower, e.g. if memory is deallocated in reverse order of allocation, all operations take constant time.) Memory utilization is good (small control structure and no per-allocation overhead). The disadvantages of freelist mode include proneness to fragmentation, a minimum allocation size of two words, and linear worst-case allocation and deallocation times.</source>
          <target state="translated">자유 목록 모드에서 &lt;code&gt;KRRegion&lt;/code&gt; 은 사용 가능한 차단 목록을 메모리 청크에 포함시킵니다. 무료 목록은 항상 원형, 통합 및 주소별로 정렬됩니다. 할당 및 할당 해제는 이전에 할당 해제 된 블록 수에 비례하여 시간이 걸립니다. (실제로 메모리 할당이 역순으로 할당 해제되는 경우 비용이 낮아질 수 있습니다. 모든 작업은 일정한 시간이 걸립니다.) 메모리 사용률이 양호합니다 (소규모 제어 구조 및 할당 당 오버 헤드가 없음). 프리리스트 모드의 단점은 조각화가 발생하기 쉽고, 최소 2 워드의 할당 크기, 선형 최악의 할당 및 할당 해제 시간입니다.</target>
        </trans-unit>
        <trans-unit id="cdf7807c516e1443dffb3bd59e60f6a917c9df07" translate="yes" xml:space="preserve">
          <source>In function scopes, imported symbols only become visible after the import declaration lexically appears in the function body. In other words, imported symbols at function scope cannot be forward referenced.</source>
          <target state="translated">함수 범위에서 가져온 기호는 함수 본문에 사전 선언이 사전에 표시된 후에 만 ​​표시됩니다. 즉, 기능 범위에서 가져온 기호는 앞으로 참조 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="c0383119e4652a168035af7434f3705bce886b19" translate="yes" xml:space="preserve">
          <source>In functional programming languages this is typically called &lt;code&gt;scan&lt;/code&gt;, &lt;code&gt;scanl&lt;/code&gt;, &lt;code&gt;scanLeft&lt;/code&gt; or &lt;code&gt;reductions&lt;/code&gt;.</source>
          <target state="translated">기능적 프로그래밍 언어에서는 일반적으로 &lt;code&gt;scan&lt;/code&gt; , &lt;code&gt;scanl&lt;/code&gt; , &lt;code&gt;scanLeft&lt;/code&gt; 또는 &lt;code&gt;reductions&lt;/code&gt; 합니다.</target>
        </trans-unit>
        <trans-unit id="8fb398e80e5a7daebe5fe79cc756231990bf0b4c" translate="yes" xml:space="preserve">
          <source>In general one should always wait for child processes to terminate before exiting the parent process unless the process was spawned as detached (that was spawned with &lt;code&gt;Config.detached&lt;/code&gt; flag). Otherwise, they may become &quot;&lt;a href=&quot;http://en.wikipedia.org/wiki/Zombie_process&quot;&gt;zombies&lt;/a&gt;&quot; &amp;ndash; processes that are defunct, yet still occupy a slot in the OS process table. You should not and must not wait for detached processes, since you don't own them.</source>
          <target state="translated">일반적으로 프로세스가 분리 된 것으로 생성되지 않은 경우 ( &lt;code&gt;Config.detached&lt;/code&gt; 플래그 로 생성 된 경우) 상위 프로세스를 종료하기 전에 항상 하위 프로세스가 종료 될 때까지 기다려야합니다 . 그렇지 않으면 &quot; &lt;a href=&quot;http://en.wikipedia.org/wiki/Zombie_process&quot;&gt;좀비&lt;/a&gt; &quot; 가 될 수 있습니다.이 프로세스는 사용되지 않지만 여전히 OS 프로세스 테이블의 슬롯을 차지합니다. 분리 된 프로세스는 소유하지 않기 때문에 분리해서는 안됩니다.</target>
        </trans-unit>
        <trans-unit id="2a9fd3d1c20814161b33ee0afa7c06fcf185414e" translate="yes" xml:space="preserve">
          <source>In general periodically 'reseeding' a PRNG does not improve its quality and in some cases may harm it. For an extreme example the Mersenne Twister has &lt;code&gt;2 ^^ 19937 - 1&lt;/code&gt; distinct states but after &lt;code&gt;seed(uint)&lt;/code&gt; is called it can only be in one of &lt;code&gt;2 ^^ 32&lt;/code&gt; distinct states regardless of how excellent the source of entropy is.</source>
          <target state="translated">일반적으로 PRNG는 정기적으로 '재배포'하여 품질을 향상시키지 않으며 경우에 따라 해를 입힐 수 있습니다. 극단적 인 예를 들어 Mersenne Twister는 &lt;code&gt;2 ^^ 19937 - 1&lt;/code&gt; 별개의 상태를 갖지만 &lt;code&gt;seed(uint)&lt;/code&gt; 가 호출 된 후 엔트로피 소스의 우수성에 관계없이 &lt;code&gt;2 ^^ 32&lt;/code&gt; 별개의 상태 중 하나에 만있을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="fc32a5290aa168583cf02dd9b13039ee5589d851" translate="yes" xml:space="preserve">
          <source>In general, the functions in this module assume that the input paths are well-formed. (That is, they should not contain invalid characters, they should follow the file system's path format, etc.) The result of calling a function on an ill-formed path is undefined. When there is a chance that a path or a file name is invalid (for instance, when it has been input by the user), it may sometimes be desirable to use the &lt;a href=&quot;#isValidFilename&quot;&gt;&lt;code&gt;isValidFilename&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#isValidPath&quot;&gt;&lt;code&gt;isValidPath&lt;/code&gt;&lt;/a&gt; functions to check this.</source>
          <target state="translated">일반적으로이 모듈의 기능은 입력 경로가 올바른 것으로 가정합니다. (즉, 유효하지 않은 문자를 포함해서는 안되며 파일 시스템의 경로 형식 등을 따라야합니다.) 잘못된 형식의 경로에서 함수를 호출 한 결과는 정의되지 않습니다. 경로 또는 파일 이름이 유효하지 않은 경우 (예 : 사용자가 입력 한 경우) &lt;a href=&quot;#isValidFilename&quot;&gt; &lt;code&gt;isValidFilename&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#isValidPath&quot;&gt; &lt;code&gt;isValidPath&lt;/code&gt; &lt;/a&gt; 함수를 사용하여 이를 확인 하는 것이 바람직 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="7566506eebd3c530fd7b49f9458b9e3829cd9289" translate="yes" xml:space="preserve">
          <source>In many cases, calls to sizeof() can't be used directly for getting data type sizes since cross compiling is supported and would end up using the host sizes rather than the target sizes.</source>
          <target state="translated">대부분의 경우 크로스 컴파일이 지원되고 대상 크기가 아닌 호스트 크기를 사용하므로 sizeof () 호출은 데이터 유형 크기를 가져 오는 데 직접 사용할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="35dd64591779170e8008d349dad053c6fa8f2446" translate="yes" xml:space="preserve">
          <source>In nested</source>
          <target state="translated">중첩</target>
        </trans-unit>
        <trans-unit id="8575ac5b58d78f8ffa7cfeed41b65f5b48950967" translate="yes" xml:space="preserve">
          <source>In older versions of Phobos, it used to be possible to write:</source>
          <target state="translated">이전 버전의 Phobo에서는 다음과 같이 쓸 수있었습니다.</target>
        </trans-unit>
        <trans-unit id="2e095fc6159a0d37540c3fe665eef32c69ad9690" translate="yes" xml:space="preserve">
          <source>In order for the data to be processed the &lt;code&gt;LogLevel&lt;/code&gt; of the &lt;code&gt;Logger&lt;/code&gt; must be greater or equal to the global &lt;code&gt;LogLevel&lt;/code&gt;.</source>
          <target state="translated">데이터를 처리 하려면 &lt;code&gt;Logger&lt;/code&gt; 의 &lt;code&gt;LogLevel&lt;/code&gt; 이 글로벌 &lt;code&gt;LogLevel&lt;/code&gt; 보다 크거나 같아야합니다 .</target>
        </trans-unit>
        <trans-unit id="60952b4bdab4bfb5f5a8d1d83bb07430530eeffe" translate="yes" xml:space="preserve">
          <source>In order for the data to be processed the &lt;code&gt;LogLevel&lt;/code&gt; of the &lt;code&gt;sharedLog&lt;/code&gt; must be greater or equal to the &lt;code&gt;defaultLogLevel&lt;/code&gt; add the condition passed must be &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">데이터를 처리하려면 &lt;code&gt;sharedLog&lt;/code&gt; 의 &lt;code&gt;LogLevel&lt;/code&gt; 이 &lt;code&gt;defaultLogLevel&lt;/code&gt; 보다 크거나 같아야하며 전달 된 조건이 &lt;code&gt;true&lt;/code&gt; 여야 합니다 .</target>
        </trans-unit>
        <trans-unit id="8e11fddcd19d6f16f616c57c6e260430b0f9d9a4" translate="yes" xml:space="preserve">
          <source>In order for the data to be processed the &lt;code&gt;LogLevel&lt;/code&gt; of the &lt;code&gt;sharedLog&lt;/code&gt; must be greater or equal to the &lt;code&gt;defaultLogLevel&lt;/code&gt;.</source>
          <target state="translated">데이터를 처리 하려면 &lt;code&gt;sharedLog&lt;/code&gt; 의 &lt;code&gt;LogLevel&lt;/code&gt; 이 &lt;code&gt;defaultLogLevel&lt;/code&gt; 보다 크거나 같아야합니다 .</target>
        </trans-unit>
        <trans-unit id="9f8c65e46c163f6fc77fddc2b9a77d78f4961ef7" translate="yes" xml:space="preserve">
          <source>In order for the data to be processed the &lt;code&gt;LogLevel&lt;/code&gt; of the log call must be greater or equal to the &lt;code&gt;LogLevel&lt;/code&gt; of the &lt;code&gt;sharedLog&lt;/code&gt; and the &lt;code&gt;defaultLogLevel&lt;/code&gt; additionally the condition passed must be &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">데이터의 순서대로 처리 할 &lt;code&gt;LogLevel&lt;/code&gt; 에 커야 로그 통화를하거나 동일 &lt;code&gt;LogLevel&lt;/code&gt; 에 의 &lt;code&gt;sharedLog&lt;/code&gt; 및 &lt;code&gt;defaultLogLevel&lt;/code&gt; 별도로 전달 상태이어야 &lt;code&gt;true&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ed49a17d9874b268342f0db2f71435916af05001" translate="yes" xml:space="preserve">
          <source>In order for the data to be processed the &lt;code&gt;LogLevel&lt;/code&gt; of the log call must be greater or equal to the &lt;code&gt;LogLevel&lt;/code&gt; of the &lt;code&gt;sharedLog&lt;/code&gt; and the &lt;code&gt;defaultLogLevel&lt;/code&gt;.</source>
          <target state="translated">데이터의 순서대로 처리 할 &lt;code&gt;LogLevel&lt;/code&gt; 에 커야 로그 통화를하거나 동일 &lt;code&gt;LogLevel&lt;/code&gt; 에 의 &lt;code&gt;sharedLog&lt;/code&gt; 및 &lt;code&gt;defaultLogLevel&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6c93e7b85e99ec02f5d168562dae2b831dda8259" translate="yes" xml:space="preserve">
          <source>In order for the data to be processed the &lt;code&gt;LogLevel&lt;/code&gt; of the log call must be greater or equal to the &lt;code&gt;LogLevel&lt;/code&gt; of the &lt;code&gt;sharedLog&lt;/code&gt;.</source>
          <target state="translated">데이터의 순서대로 처리 할 &lt;code&gt;LogLevel&lt;/code&gt; 에 커야 로그 통화를하거나 동일 &lt;code&gt;LogLevel&lt;/code&gt; 에 의 &lt;code&gt;sharedLog&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9f87139f757185970527b89c7ad28046b560c58f" translate="yes" xml:space="preserve">
          <source>In order for the data to be processed the &lt;code&gt;LogLevel&lt;/code&gt; of the log call must be greater or equal to the &lt;code&gt;defaultLogLevel&lt;/code&gt; additionally the condition passed must be &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">데이터를 처리하려면 로그 호출 의 &lt;code&gt;LogLevel&lt;/code&gt; 이 &lt;code&gt;defaultLogLevel&lt;/code&gt; 보다 크거나 같아야하며, 추가로 전달 된 조건은 &lt;code&gt;true&lt;/code&gt; 여야 합니다 .</target>
        </trans-unit>
        <trans-unit id="a54f9edb0000f15c332443c24f6eb668c55c8501" translate="yes" xml:space="preserve">
          <source>In order for the data to be processed the &lt;code&gt;LogLevel&lt;/code&gt; of the log call must be greater or equal to the &lt;code&gt;defaultLogLevel&lt;/code&gt;.</source>
          <target state="translated">데이터를 처리 하려면 로그 호출 의 &lt;code&gt;LogLevel&lt;/code&gt; 이 &lt;code&gt;defaultLogLevel&lt;/code&gt; 보다 크거나 같아야합니다 .</target>
        </trans-unit>
        <trans-unit id="14b107fabc6c81ab2222b96dfa0c1ecd6dfba19f" translate="yes" xml:space="preserve">
          <source>In order for the data to be processed, the &lt;code&gt;LogLevel&lt;/code&gt; of the log call must be greater or equal to the &lt;code&gt;LogLevel&lt;/code&gt; of the &lt;code&gt;sharedLog&lt;/code&gt; and the &lt;code&gt;defaultLogLevel&lt;/code&gt;; additionally the condition passed must be &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">데이터가 처리되도록, &lt;code&gt;LogLevel&lt;/code&gt; 에 로그 호출은 커야하거나 동일 &lt;code&gt;LogLevel&lt;/code&gt; 에 의 &lt;code&gt;sharedLog&lt;/code&gt; 및 &lt;code&gt;defaultLogLevel&lt;/code&gt; ; 또한 전달 된 조건이 &lt;code&gt;true&lt;/code&gt; 여야 합니다 .</target>
        </trans-unit>
        <trans-unit id="7bb3ac7d5c9d6c962a9241e9025396626aa9beb6" translate="yes" xml:space="preserve">
          <source>In order for the resulting log message to be logged the &lt;code&gt;LogLevel&lt;/code&gt; must be greater or equal than the &lt;code&gt;LogLevel&lt;/code&gt; of the &lt;code&gt;sharedLog&lt;/code&gt; and must be greater or equal than the global &lt;code&gt;LogLevel&lt;/code&gt;. Additionally the &lt;code&gt;LogLevel&lt;/code&gt; must be greater or equal than the &lt;code&gt;LogLevel&lt;/code&gt; of the &lt;code&gt;stdSharedLogger&lt;/code&gt;.</source>
          <target state="translated">결과 로그 메시지를 기록하려면 &lt;code&gt;LogLevel&lt;/code&gt; 이 &lt;code&gt;sharedLog&lt;/code&gt; 의 &lt;code&gt;LogLevel&lt;/code&gt; 보다 크거나 같아야하며 전역 &lt;code&gt;LogLevel&lt;/code&gt; 보다 크거나 같아야합니다 . 추가적으로 &lt;code&gt;LogLevel&lt;/code&gt; 에이 클 수 또는보다 동일해야합니다 &lt;code&gt;LogLevel&lt;/code&gt; 에 의 &lt;code&gt;stdSharedLogger&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="79abe30476f4ca10a8c01c609e3f868cb8a10f27" translate="yes" xml:space="preserve">
          <source>In order for the resulting log message to be logged the &lt;code&gt;LogLevel&lt;/code&gt; must be greater or equal than the &lt;code&gt;LogLevel&lt;/code&gt; of the &lt;code&gt;stdThreadLocalLog&lt;/code&gt; and must be greater or equal than the global &lt;code&gt;LogLevel&lt;/code&gt;. Additionally the &lt;code&gt;LogLevel&lt;/code&gt; must be greater or equal than the &lt;code&gt;LogLevel&lt;/code&gt; of the &lt;code&gt;stdSharedLogger&lt;/code&gt;. If a condition is given, it must evaluate to &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">결과 로그 메시지를 기록하려면 &lt;code&gt;LogLevel&lt;/code&gt; 이 &lt;code&gt;stdThreadLocalLog&lt;/code&gt; 의 &lt;code&gt;LogLevel&lt;/code&gt; 보다 크거나 같아야하며 전역 &lt;code&gt;LogLevel&lt;/code&gt; 보다 크거나 같아야합니다 . 추가적으로 &lt;code&gt;LogLevel&lt;/code&gt; 에이 클 수 또는보다 동일해야합니다 &lt;code&gt;LogLevel&lt;/code&gt; 에 의 &lt;code&gt;stdSharedLogger&lt;/code&gt; . 조건이 제공되면 &lt;code&gt;true&lt;/code&gt; 로 평가해야 합니다 .</target>
        </trans-unit>
        <trans-unit id="18e494163438a3079c18b40fa80b56a34c4d5c22" translate="yes" xml:space="preserve">
          <source>In order for the resulting log message to be logged the &lt;code&gt;LogLevel&lt;/code&gt; must be greater or equal than the &lt;code&gt;LogLevel&lt;/code&gt; of the used &lt;code&gt;Logger&lt;/code&gt; and must be greater or equal than the global &lt;code&gt;LogLevel&lt;/code&gt; additionally the condition passed must be &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">결과 로그 메시지 순서로 기록 될 &lt;code&gt;LogLevel&lt;/code&gt; 에가 크거나 같해야 &lt;code&gt;LogLevel&lt;/code&gt; 에 사용한의 &lt;code&gt;Logger&lt;/code&gt; 및 크거나 같 글로벌해야 &lt;code&gt;LogLevel&lt;/code&gt; 에 부가 조건이 있어야 통과 &lt;code&gt;true&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a2b84c1fc96a4a1e141069ab63dfce487512e519" translate="yes" xml:space="preserve">
          <source>In order for the resulting log message to be logged the &lt;code&gt;LogLevel&lt;/code&gt; must be greater or equal than the &lt;code&gt;LogLevel&lt;/code&gt; of the used &lt;code&gt;Logger&lt;/code&gt; and must be greater or equal than the global &lt;code&gt;LogLevel&lt;/code&gt; additionally the passed condition must be &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">결과 로그 메시지 순서로 기록 될 &lt;code&gt;LogLevel&lt;/code&gt; 에가 크거나 같해야 &lt;code&gt;LogLevel&lt;/code&gt; 에 사용한의 &lt;code&gt;Logger&lt;/code&gt; 및 커야 또는 글로벌 같 &lt;code&gt;LogLevel&lt;/code&gt; 에 별도로 전달 상태이어야 &lt;code&gt;true&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6c8530a345a9b66847038330015135156125389c" translate="yes" xml:space="preserve">
          <source>In order for the resulting log message to be logged the &lt;code&gt;LogLevel&lt;/code&gt; must be greater or equal than the &lt;code&gt;LogLevel&lt;/code&gt; of the used &lt;code&gt;Logger&lt;/code&gt; and must be greater or equal than the global &lt;code&gt;LogLevel&lt;/code&gt; and the condition must be &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">결과 로그 메시지를 기록하려면 &lt;code&gt;LogLevel&lt;/code&gt; 이 사용 된 &lt;code&gt;Logger&lt;/code&gt; 의 &lt;code&gt;LogLevel&lt;/code&gt; 보다 크거나 같아야하며 전역 &lt;code&gt;LogLevel&lt;/code&gt; 보다 크거나 같아야 하며 조건이 &lt;code&gt;true&lt;/code&gt; 여야 합니다 .</target>
        </trans-unit>
        <trans-unit id="20b9f3f3bdcf58be250caee88b15a55353fecc84" translate="yes" xml:space="preserve">
          <source>In order for the resulting log message to be logged the &lt;code&gt;LogLevel&lt;/code&gt; must be greater or equal than the &lt;code&gt;LogLevel&lt;/code&gt; of the used &lt;code&gt;Logger&lt;/code&gt; and must be greater or equal than the global &lt;code&gt;LogLevel&lt;/code&gt;.</source>
          <target state="translated">결과 로그 메시지를 기록하려면 &lt;code&gt;LogLevel&lt;/code&gt; 이 사용 된 &lt;code&gt;Logger&lt;/code&gt; 의 &lt;code&gt;LogLevel&lt;/code&gt; 보다 크거나 같아야하며 전역 &lt;code&gt;LogLevel&lt;/code&gt; 보다 크거나 같아야합니다 .</target>
        </trans-unit>
        <trans-unit id="41a290703568517f05854f40487a48abaf094d9a" translate="yes" xml:space="preserve">
          <source>In order for the resulting log message to be logged the &lt;code&gt;LogLevel&lt;/code&gt; of the used &lt;code&gt;Logger&lt;/code&gt; must be greater or equal than the global &lt;code&gt;LogLevel&lt;/code&gt; and the condition must be &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">결과 로그 메시지가 기록 되려면 사용 된 &lt;code&gt;Logger&lt;/code&gt; 의 &lt;code&gt;LogLevel&lt;/code&gt; 이 전역 &lt;code&gt;LogLevel&lt;/code&gt; 보다 크거나 같아야 하며 조건이 &lt;code&gt;true&lt;/code&gt; 여야 합니다 .</target>
        </trans-unit>
        <trans-unit id="61c93a13b86326686a55e702c7620856cee5be12" translate="yes" xml:space="preserve">
          <source>In order for the resulting log message to be logged the &lt;code&gt;LogLevel&lt;/code&gt; of the used &lt;code&gt;Logger&lt;/code&gt; must be greater or equal than the global &lt;code&gt;LogLevel&lt;/code&gt;.</source>
          <target state="translated">결과 로그 메시지를 기록 하려면 사용 된 &lt;code&gt;Logger&lt;/code&gt; 의 &lt;code&gt;LogLevel&lt;/code&gt; 이 전역 &lt;code&gt;LogLevel&lt;/code&gt; 보다 크거나 같아야합니다 .</target>
        </trans-unit>
        <trans-unit id="9091984c8dee40a3793a920b8fc726ff3fb2b605" translate="yes" xml:space="preserve">
          <source>In order to be usable as an allocator, a type should implement the following methods with their respective semantics. Only &lt;code&gt;alignment&lt;/code&gt; and &lt;code&gt;allocate&lt;/code&gt; are required. If any of the other methods is missing, the allocator is assumed to not have that capability (for example some allocators do not offer manual deallocation of memory). Allocators should NOT implement unsupported methods to always fail. For example, an allocator that lacks the capability to implement &lt;code&gt;alignedAllocate&lt;/code&gt; should not define it at all (as opposed to defining it to always return &lt;code&gt;null&lt;/code&gt; or throw an exception). The missing implementation statically informs other components about the allocator's capabilities and allows them to make design decisions accordingly.</source>
          <target state="translated">할당 자로 사용할 수 있으려면 형식이 각각의 의미와 함께 다음 방법을 구현해야합니다. 만 &lt;code&gt;alignment&lt;/code&gt; 및 &lt;code&gt;allocate&lt;/code&gt; 해야합니다. 다른 방법 중 하나라도 누락 된 경우 할당자는 해당 기능이없는 것으로 간주됩니다 (예 : 일부 할당자는 수동 메모리 할당 해제를 제공하지 않음). 할당자는 항상 실패하도록 지원되지 않는 메소드를 구현해서는 안됩니다. 예를 들어, &lt;code&gt;alignedAllocate&lt;/code&gt; 를 구현할 수있는 할당자가없는 할당자는 항상 &lt;code&gt;null&lt;/code&gt; 하거나 예외를 발생 시키 도록 정의하는 것과 달리이를 정의해서는 안됩니다 . 누락 된 구현은 다른 구성 요소에 할당 자의 기능을 정적으로 알리고 그에 따라 디자인 결정을 내릴 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6dda110f1f25b5663505eb11f44cd82e44a8c31d" translate="yes" xml:space="preserve">
          <source>In order to determine if an object &lt;code&gt;o&lt;/code&gt; is an instance of a class &lt;code&gt;B&lt;/code&gt; use a cast:</source>
          <target state="translated">객체 &lt;code&gt;o&lt;/code&gt; 가 클래스 &lt;code&gt;B&lt;/code&gt; 의 인스턴스 인지 확인하려면 캐스트를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="1e18ff30e3740b378cdaf28cc4934f896ccbee30" translate="yes" xml:space="preserve">
          <source>In order to disable logging at compile time, pass &lt;code&gt;StdLoggerDisableLogging&lt;/code&gt; as a version argument to the &lt;code&gt;D&lt;/code&gt; compiler when compiling your program code. This will disable all logging functionality. Specific &lt;code&gt;LogLevel&lt;/code&gt; can be disabled at compile time as well. In order to disable logging with the &lt;code&gt;trace&lt;/code&gt;&lt;code&gt;LogLevel&lt;/code&gt; pass &lt;code&gt;StdLoggerDisableTrace&lt;/code&gt; as a version. The following table shows which version statement disables which &lt;code&gt;LogLevel&lt;/code&gt;.</source>
          <target state="translated">컴파일시 로깅을 비활성화하려면 프로그램 코드를 컴파일 할 때 &lt;code&gt;StdLoggerDisableLogging&lt;/code&gt; 을 버전 컴파일러로 &lt;code&gt;D&lt;/code&gt; 컴파일러에 전달 하십시오. 모든 로깅 기능이 비활성화됩니다. 컴파일시 특정 &lt;code&gt;LogLevel&lt;/code&gt; 을 비활성화 할 수도 있습니다. &lt;code&gt;trace&lt;/code&gt; &lt;code&gt;LogLevel&lt;/code&gt; 을 사용하여 로깅을 사용하지 않으 &lt;code&gt;StdLoggerDisableTrace&lt;/code&gt; 를 버전으로 전달 하십시오 . 다음 표는 어떤 버전 문이 어떤 &lt;code&gt;LogLevel&lt;/code&gt; 을 비활성화하는지 보여줍니다 .</target>
        </trans-unit>
        <trans-unit id="a77a52d87761074b435f02e38ba4ed22e517df1c" translate="yes" xml:space="preserve">
          <source>In order to do put the length at the front, we have to provide 16 bytes buffer space in case the block has to be aligned properly. In x86, certain SSE instructions will only work if the data is 16-byte aligned. In addition, we need the sentinel byte to prevent accidental pointers to the next block. Because of the extra overhead, we only do this for page size and above, where the overhead is minimal compared to the block size.</source>
          <target state="translated">길이를 앞에 두려면 블록을 올바르게 정렬해야하는 경우 16 바이트의 버퍼 공간을 제공해야합니다. x86에서 특정 SSE 명령어는 데이터가 16 바이트로 정렬 된 경우에만 작동합니다. 또한 우연히 다음 블록에 대한 포인터를 방지하기 위해 센티넬 바이트가 필요합니다. 여분의 오버 헤드로 인해 페이지 크기 이상에 대해서만이 작업을 수행하며, 블록 크기에 비해 오버 헤드가 최소화됩니다.</target>
        </trans-unit>
        <trans-unit id="0cc93ffa6b67fa20835799cad3635970d48f4206" translate="yes" xml:space="preserve">
          <source>In order to work, &lt;code&gt;FallbackAllocator&lt;/code&gt; requires that &lt;code&gt;Primary&lt;/code&gt; defines the &lt;code&gt;owns&lt;/code&gt; method. This is needed in order to decide which allocator was responsible for a given allocation.</source>
          <target state="translated">&lt;code&gt;FallbackAllocator&lt;/code&gt; 가 작동 하려면 &lt;code&gt;Primary&lt;/code&gt; 가 &lt;code&gt;owns&lt;/code&gt; 메소드를 정의 해야합니다 . 이것은 주어진 할당을 담당 한 할당자를 결정하기 위해 필요합니다.</target>
        </trans-unit>
        <trans-unit id="3cb2dd17fb05bd389b6b34ea2ea85ffe8dc6328a" translate="yes" xml:space="preserve">
          <source>In other words, casting literal expression will change the literal type.</source>
          <target state="translated">즉, 리터럴 표현식을 캐스팅하면 리터럴 유형이 변경됩니다.</target>
        </trans-unit>
        <trans-unit id="675933f346891ba4fb04a779eea3dd5e21b2c0bb" translate="yes" xml:space="preserve">
          <source>In previous versions of Phobos, this was known as &lt;code&gt;TypeTuple&lt;/code&gt;.</source>
          <target state="translated">이전 버전의 &lt;code&gt;TypeTuple&lt;/code&gt; 에서는이 유형을 TypeTuple 이라고했습니다 .</target>
        </trans-unit>
        <trans-unit id="26154800831f1a5ff6a19e1167b2ddcacfdb1c76" translate="yes" xml:space="preserve">
          <source>In principle, only thrown objects derived from this class are safe to catch inside a &lt;code&gt;catch&lt;/code&gt; block. Thrown objects not derived from Exception represent runtime errors that should not be caught, as certain runtime guarantees may not hold, making it unsafe to continue program execution.</source>
          <target state="translated">원칙적으로이 클래스에서 파생 된 객체 만 &lt;code&gt;catch&lt;/code&gt; 블록 내부에서 안전하게 잡을 수 있습니다. 예외에서 파생되지 않은 throw 된 객체는 특정 런타임 보장이 유지되지 않아 프로그램 실행을 계속하는 것이 안전하지 않으므로 잡히지 않아야하는 런타임 오류를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="0b93464d0fbabeded10a475db02ab91f9147bd5b" translate="yes" xml:space="preserve">
          <source>In principle, this is the name of the local time zone. However, this always returns the empty string. This is because time zones cannot be uniquely identified by the attributes given by the OS (such as the &lt;code&gt;stdName&lt;/code&gt; and &lt;code&gt;dstName&lt;/code&gt;), and neither Posix systems nor Windows systems provide an easy way to get the TZ Database name of the local time zone.</source>
          <target state="translated">원칙적으로 이것은 현지 시간대의 이름입니다. 그러나 항상 빈 문자열을 반환합니다. 표준 시간대는 OS에서 제공 한 속성 (예 : &lt;code&gt;stdName&lt;/code&gt; 및 &lt;code&gt;dstName&lt;/code&gt; ) 으로 고유하게 식별 할 수 없으며 Posix 시스템과 Windows 시스템이 로컬 시간대의 TZ 데이터베이스 이름을 쉽게 얻을 수있는 방법을 제공하지 않기 때문입니다.</target>
        </trans-unit>
        <trans-unit id="0b9fb0301ede6ae1f71c55d50ab376078de554f8" translate="yes" xml:space="preserve">
          <source>In single line mode matches any character. Otherwise it matches any character except '\n' and '\r'.</source>
          <target state="translated">한 줄 모드에서는 모든 문자와 일치합니다. 그렇지 않으면 '\ n'및 '\ r'을 제외한 모든 문자와 일치합니다.</target>
        </trans-unit>
        <trans-unit id="77c1db69e3f99eb322088fa8127b36e0134ab790" translate="yes" xml:space="preserve">
          <source>In some date calculations, adding months or years can cause the date to fall on a day of the month which is not valid (e.g. February 29th 2001 or June 31st 2000). If overflow is allowed (as is the default), then the month will be incremented accordingly (so, February 29th 2001 would become March 1st 2001, and June 31st 2000 would become July 1st 2000). If overflow is not allowed, then the day will be adjusted to the last valid day in that month (so, February 29th 2001 would become February 28th 2001 and June 31st 2000 would become June 30th 2000).</source>
          <target state="translated">일부 날짜 계산에서 월 또는 연도를 추가하면 날짜가 유효하지 않은 날짜에 떨어질 수 있습니다 (예 : 2001 년 2 월 29 일 또는 2000 년 6 월 31 일). 오버플로가 허용되면 (기본값으로) 월이 증가합니다 (2001 년 2 월 29 일은 2001 년 3 월 1 일이되고 2000 년 6 월 31 일은 2000 년 7 월 1 일이됩니다). 오버플로가 허용되지 않으면 날짜는 해당 월의 마지막 유효 날짜로 조정됩니다 (2001 년 2 월 29 일은 2001 년 2 월 28 일이되고 2000 년 6 월 31 일은 2000 년 6 월 30 일이됩니다).</target>
        </trans-unit>
        <trans-unit id="0f7765db47c238a56000c8a0537e8a769de4649d" translate="yes" xml:space="preserve">
          <source>In std.datetime, it is also used as the result of various arithmetic operations on time points.</source>
          <target state="translated">std.datetime에서는 시점에 대한 다양한 산술 연산의 결과로도 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="9d8f072b0ee81fd114d71e25f9472d419503fd30" translate="yes" xml:space="preserve">
          <source>In the above situations the errors do not contain line numbers because the errors are regarding generated code.</source>
          <target state="translated">위의 상황에서 오류는 생성 된 코드와 관련되므로 오류에 줄 번호가 포함되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="83c0d2545855dad1e2136f8a2d0797213523dbd3" translate="yes" xml:space="preserve">
          <source>In the case above, the element at slot &lt;code&gt;1&lt;/code&gt; is removed, but replaced with the last element of the range. Taking advantage of the relaxation of the stability requirement, &lt;code&gt;remove&lt;/code&gt; moved elements from the end of the array over the slots to be removed. This way there is less data movement to be done which improves the execution time of the function.</source>
          <target state="translated">위의 경우 슬롯 &lt;code&gt;1&lt;/code&gt; 의 요소 는 제거되지만 범위의 마지막 요소로 대체됩니다. 안정성 요구 사항 완화를 활용 하여 어레이 끝에서 &lt;code&gt;remove&lt;/code&gt; 할 슬롯 위로 이동 된 요소를 제거하십시오. 이러한 방식으로 수행되는 데이터 이동이 줄어들어 기능의 실행 시간이 향상됩니다.</target>
        </trans-unit>
        <trans-unit id="d1310273f42b4567d006ba733761bffcc94a7323" translate="yes" xml:space="preserve">
          <source>In the case of multisets, considering that element &lt;code&gt;a&lt;/code&gt; appears &lt;code&gt;x&lt;/code&gt; times in &lt;code&gt;r1&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; times and &lt;code&gt;r2&lt;/code&gt;, the number of occurences of &lt;code&gt;a&lt;/code&gt; in the resulting range is going to be &lt;code&gt;x-y&lt;/code&gt; if x &amp;gt; y or 0 otherwise.</source>
          <target state="translated">다중 집합의 경우 요소 &lt;code&gt;a&lt;/code&gt; 가 &lt;code&gt;r1&lt;/code&gt; 및 &lt;code&gt;y&lt;/code&gt; &lt;code&gt;x&lt;/code&gt; 및 &lt;code&gt;r2&lt;/code&gt; 에 x 번 나타나는 것을 고려할 때 결과 범위에서 &lt;code&gt;a&lt;/code&gt; 의 발생 횟수는 x&amp;gt; y 또는 0이면 &lt;code&gt;x-y&lt;/code&gt; 됩니다.</target>
        </trans-unit>
        <trans-unit id="574341dd05f59907247dd44e449ed7bd5386146b" translate="yes" xml:space="preserve">
          <source>In the case of multisets, the range with the minimum number of occurences of a given element, propagates the number of occurences of this element to the resulting range.</source>
          <target state="translated">다중 집합의 경우, 주어진 요소의 발생 수가 최소 인 범위는이 요소의 발생 횟수를 결과 범위로 전파합니다.</target>
        </trans-unit>
        <trans-unit id="c31bb38a42ef0f5a89fce05942de3e9a5d76ab7c" translate="yes" xml:space="preserve">
          <source>In the case of the monotonic time, &lt;a href=&quot;#MonoTimeImpl&quot;&gt;&lt;code&gt;MonoTimeImpl&lt;/code&gt;&lt;/a&gt; is templatized on &lt;code&gt;ClockType&lt;/code&gt;, whereas with &lt;code&gt;std.datetime.Clock.currTime&lt;/code&gt;, its a runtime argument, since in the case of the monotonic time, the type of the clock affects the resolution of a &lt;a href=&quot;#MonoTimeImpl&quot;&gt;&lt;code&gt;MonoTimeImpl&lt;/code&gt;&lt;/a&gt; object, whereas with &lt;a href=&quot;std_datetime#SysTime&quot;&gt;&lt;code&gt;std.datetime.SysTime&lt;/code&gt;&lt;/a&gt;, its resolution is always hecto-nanoseconds regardless of the source of the time.</source>
          <target state="translated">단조 시간의 경우 &lt;a href=&quot;#MonoTimeImpl&quot;&gt; &lt;code&gt;MonoTimeImpl&lt;/code&gt; &lt;/a&gt; 은 &lt;code&gt;ClockType&lt;/code&gt; 에서 템플릿 화되는 반면 &lt;code&gt;std.datetime.Clock.currTime&lt;/code&gt; 에서는 런타임 인수입니다. 단조 시간의 경우 클럭 유형이 &lt;a href=&quot;#MonoTimeImpl&quot;&gt; &lt;code&gt;MonoTimeImpl&lt;/code&gt; &lt;/a&gt; 객체 의 해상도에 영향을 미치기 때문에 와 반면 &lt;a href=&quot;std_datetime#SysTime&quot;&gt; &lt;code&gt;std.datetime.SysTime&lt;/code&gt; &lt;/a&gt; , 그 해상도는 항상 시간에 관계없이 소스의 헥토 - 나노초.</target>
        </trans-unit>
        <trans-unit id="48d19d43ba624ca8d4f15f601b46da39df170632" translate="yes" xml:space="preserve">
          <source>In the corresponding D code, &lt;code&gt;foo&lt;/code&gt; is declared as having C++ linkage and function calling conventions:</source>
          <target state="translated">해당 D 코드에서 &lt;code&gt;foo&lt;/code&gt; 는 C ++ 연결 및 함수 호출 규칙이있는 것으로 선언됩니다.</target>
        </trans-unit>
        <trans-unit id="c2859b376d9322070e57e0df9e0b545f1ad11ef9" translate="yes" xml:space="preserve">
          <source>In the current function, we are calling 'this' function. 1. Check to see if the current function can call 'this' function, issue error if not. 2. If the current function is not the parent of 'this' function, then add the current function to the list of siblings of 'this' function. 3. If the current function is a literal, and it's accessing an uplevel scope, then mark it as a delegate. Returns true if error occurs.</source>
          <target state="translated">현재 함수에서 'this'함수를 호출합니다. 1. 현재 함수가 'this'함수를 호출 할 수 있는지 확인하십시오. 그렇지 않으면 오류를 발행하십시오. 2. 현재 기능이 'this'기능의 부모가 아닌 경우 현재 기능을 'this'기능의 형제 목록에 추가하십시오. 3. 현재 함수가 리터럴이고 상위 범위에 액세스하는 경우이를 델리게이트로 표시하십시오. 오류가 발생하면 true를 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="27341e1e33d3f1a9c524981309a60954fc820a69" translate="yes" xml:space="preserve">
          <source>In the example above, &quot;--foo&quot; and &quot;--bar&quot; are recognized, but &quot;--Foo&quot;, &quot;--Bar&quot;, &quot;--FOo&quot;, &quot;--bAr&quot;, etc. are rejected. The directive is active until the end of &lt;code&gt;getopt&lt;/code&gt;, or until the converse directive &lt;code&gt;caseInsensitive&lt;/code&gt; is encountered:</source>
          <target state="translated">위의 예에서 &quot;--foo&quot;및 &quot;--bar&quot;는 인식되지만 &quot;--Foo&quot;, &quot;--Bar&quot;, &quot;--FOo&quot;, &quot;--bAr&quot;등은 거부됩니다. 지시문은 &lt;code&gt;getopt&lt;/code&gt; 끝까지 또는 converse 지시문 &lt;code&gt;caseInsensitive&lt;/code&gt; 가 발견 될 때까지 활성화 됩니다.</target>
        </trans-unit>
        <trans-unit id="4dfbc2e24539434e62842bac389911ff9852ba28" translate="yes" xml:space="preserve">
          <source>In the graph above, any directed path is a legal implicit conversion. No other qualifier combinations than the ones shown is valid. If a directed path exists between two sets of qualifiers, the types thus qualified are called &lt;a href=&quot;http://dlang.org/glossary.html#qualifier-convertible&quot;&gt;qualifier-convertible&lt;/a&gt;. The same information is shown below in tabular format:</source>
          <target state="translated">위의 그래프에서 모든 지정 경로는 유효한 암시 적 변환입니다. 표시된 것 이외의 다른 한정자 조합은 유효하지 않습니다. 두 세트의 규정 자 사이에 지정 경로가 존재하면 규정 된 유형을 &lt;a href=&quot;http://dlang.org/glossary.html#qualifier-convertible&quot;&gt;규정 자 변환 가능&lt;/a&gt; 이라고 합니다. 동일한 정보가 아래 표 형식으로 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="02f036d56e5b0f17d6cada283807ab6e4a45c16d" translate="yes" xml:space="preserve">
          <source>In the second step, path components are compared using &lt;code&gt;filenameCmp!cs&lt;/code&gt;, where &lt;code&gt;cs&lt;/code&gt; is an optional template parameter determining whether the comparison is case sensitive or not. See the &lt;a href=&quot;#filenameCmp&quot;&gt;&lt;code&gt;filenameCmp&lt;/code&gt;&lt;/a&gt; documentation for details.</source>
          <target state="translated">두 번째 단계에서 &lt;code&gt;filenameCmp!cs&lt;/code&gt; 사용하여 경로 구성 요소를 비교합니다 . 여기서 &lt;code&gt;cs&lt;/code&gt; 는 비교가 대소 문자를 구분하는지 여부를 결정하는 선택적 템플리트 매개 변수입니다. 자세한 내용은 &lt;a href=&quot;#filenameCmp&quot;&gt; &lt;code&gt;filenameCmp&lt;/code&gt; &lt;/a&gt; 설명서를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="e25b68a7396b82d8e5f58fe981088b3bb4f8c195" translate="yes" xml:space="preserve">
          <source>In the special case where only a single function is provided (&lt;code&gt;F.length == 1&lt;/code&gt;), adjoin simply aliases to the single passed function (&lt;code&gt;F[0]&lt;/code&gt;).</source>
          <target state="translated">단일 함수 만 제공되는 특수한 경우 ( &lt;code&gt;F.length == 1&lt;/code&gt; ), 전달 된 단일 함수 ( &lt;code&gt;F[0]&lt;/code&gt; )에 간단히 별칭을 붙 입니다.</target>
        </trans-unit>
        <trans-unit id="0d9fe9a61d26a09ceb6b95fd6ad82498884dadd5" translate="yes" xml:space="preserve">
          <source>In the table below, the &lt;b&gt;exact alias&lt;/b&gt;es are types of exactly the specified number of bits. The &lt;b&gt;at least alias&lt;/b&gt;es are at least the specified number of bits large, and can be larger. The &lt;b&gt;fast alias&lt;/b&gt;es are the fastest integral type supported by the processor that is at least as wide as the specified number of bits.</source>
          <target state="translated">아래 표에서 &lt;b&gt;정확한 별칭&lt;/b&gt; 은 정확히 지정된 비트 수의 유형입니다. &lt;b&gt;적어도 별명&lt;/b&gt; ES 적어도 큰 지정된 비트 수 있으며, 클 수있다. &lt;b&gt;빠른 별명&lt;/b&gt; ES는 지정된 비트 수가 적어도 같은 폭이며, 상기 프로세서에 의해 지원되는 빠른 일체형이다.</target>
        </trans-unit>
        <trans-unit id="2b57bd98576c6b47e51f692ed2880671dfdcaf21" translate="yes" xml:space="preserve">
          <source>In this case, &lt;code&gt;myAllocator&lt;/code&gt; does not obey the &lt;code&gt;IAllocator&lt;/code&gt; interface, but implements its primitives so it can work with &lt;code&gt;makeArray&lt;/code&gt; by means of duck typing.  One important thing to note about this setup is that statically-typed assembled allocators are almost always faster than allocators that go through &lt;code&gt;IAllocator&lt;/code&gt;. An important rule of thumb is: &quot;assemble allocator first, adapt to &lt;code&gt;IAllocator&lt;/code&gt; after&quot;. A good allocator implements intricate logic by means of template assembly, and gets wrapped with &lt;code&gt;IAllocator&lt;/code&gt; (usually by means of &lt;a href=&quot;#allocatorObject&quot;&gt;&lt;code&gt;allocatorObject&lt;/code&gt;&lt;/a&gt;) only once, at client level.</source>
          <target state="translated">이 경우 &lt;code&gt;myAllocator&lt;/code&gt; 는 &lt;code&gt;IAllocator&lt;/code&gt; 인터페이스를 따르지 않지만 기본을 구현하므로 오리 입력을 통해 &lt;code&gt;makeArray&lt;/code&gt; 로 작업 할 수 있습니다 . 이 설정에 대해 주목해야 할 중요한 사항 중 하나는 정적 형식의 어셈블러 할당자가 &lt;code&gt;IAllocator&lt;/code&gt; 를 거치는 할당 자보다 거의 항상 빠르다는 것 입니다. 중요한 경험 법칙은 &quot;할당자를 먼저 조립하고 이후 에 &lt;code&gt;IAllocator&lt;/code&gt; 에 적응 &quot;입니다. 좋은 할당자는 템플릿 어셈블리를 통해 복잡한 논리를 구현 하고 클라이언트 수준에서 &lt;code&gt;IAllocator&lt;/code&gt; (일반적으로 &lt;a href=&quot;#allocatorObject&quot;&gt; &lt;code&gt;allocatorObject&lt;/code&gt; 를 통해&lt;/a&gt; )로 한 번만 래핑 됩니다.</target>
        </trans-unit>
        <trans-unit id="0dbb9df98ee1772b091a23269b418c611c6689cc" translate="yes" xml:space="preserve">
          <source>In this case, the slots at positions 1, 3, 4, and 9 are removed from the array.</source>
          <target state="translated">이 경우 위치 1, 3, 4 및 9의 슬롯이 어레이에서 제거됩니다.</target>
        </trans-unit>
        <trans-unit id="5961fb400c229a03dfc935fa996c5fe8fc78fdb9" translate="yes" xml:space="preserve">
          <source>In this implementation both arguments must be positive. The integral is evaluated by either a power series or continued fraction expansion, depending on the relative values of a and x.</source>
          <target state="translated">이 구현에서 두 인수 모두 긍정적이어야합니다. 적분은 a와 x의 상대 값에 따라 거듭 제곱 또는 연속 분수 확장으로 평가됩니다.</target>
        </trans-unit>
        <trans-unit id="bd2e85eebf3596f12832975a35b8c3545510433f" translate="yes" xml:space="preserve">
          <source>In this situation, the assignemnts are actual assign expressions (&lt;code&gt;opAssign&lt;/code&gt; is used if defined).</source>
          <target state="translated">이 상황에서 assignemnts는 실제 assign 표현식입니다 ( &lt;code&gt;opAssign&lt;/code&gt; 정의 된 경우 opAssign 이 사용됨).</target>
        </trans-unit>
        <trans-unit id="cecc30a8b51b4071bb5efaef87b2c1dec1a96284" translate="yes" xml:space="preserve">
          <source>In this table &quot;doPut&quot; is a method that places &lt;code&gt;e&lt;/code&gt; into &lt;code&gt;r&lt;/code&gt;, using the correct primitive: &lt;code&gt;r.put(e)&lt;/code&gt; if &lt;code&gt;R&lt;/code&gt; defines &lt;code&gt;put&lt;/code&gt;, &lt;code&gt;r.front = e&lt;/code&gt; if &lt;code&gt;r&lt;/code&gt; is an input range (followed by &lt;code&gt;r.popFront()&lt;/code&gt;), or &lt;code&gt;r(e)&lt;/code&gt; otherwise.</source>
          <target state="translated">이 표에서 &quot;doPut&quot;은 올바른 기본 요소를 사용하여 &lt;code&gt;e&lt;/code&gt; 를 &lt;code&gt;r&lt;/code&gt; 에 배치하는 방법입니다 . &lt;code&gt;R&lt;/code&gt; 이 &lt;code&gt;put&lt;/code&gt; 을 정의 하면 &lt;code&gt;r.put(e)&lt;/code&gt; , &lt;code&gt;r&lt;/code&gt; 이 입력 범위 인 경우 &lt;code&gt;r.front = e&lt;/code&gt; ( &lt;code&gt;r.popFront()&lt;/code&gt; ), 그렇지 않으면 &lt;code&gt;r(e)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="02a8b5c14dc9548c1a490e9d5960a9feca99259a" translate="yes" xml:space="preserve">
          <source>In this way a struct or class object can behave as if it were a function.</source>
          <target state="translated">이런 식으로 구조체 나 클래스 객체는 마치 함수 인 것처럼 동작 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="17982ced0afda199d35d40c9d0672932dd55162a" translate="yes" xml:space="preserve">
          <source>In this way a struct or class object can behave as if it were an array.</source>
          <target state="translated">이런 식으로 구조체 나 클래스 객체는 마치 마치 배열 인 것처럼 동작 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="86f8f90c18dbc0f9d343ef02fb0a4cd117e4553c" translate="yes" xml:space="preserve">
          <source>In user code. This class also provides means to add version identifier to the list of global (cross module) identifiers.</source>
          <target state="translated">사용자 코드에서. 이 클래스는 또한 글로벌 (크로스 모듈) 식별자 목록에 버전 식별자를 추가하는 수단을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="bdee4d1acbdd89d7f24aebad7aeee092188b3727" translate="yes" xml:space="preserve">
          <source>In, Out and Inheritance</source>
          <target state="translated">인, 아웃 및 상속</target>
        </trans-unit>
        <trans-unit id="783253f63cea9c514d69689860a1ae050327457b" translate="yes" xml:space="preserve">
          <source>In-order Pentium (Pentium1, PMMX, Atom)</source>
          <target state="translated">주문형 펜티엄 (Pentium1, PMMX, Atom)</target>
        </trans-unit>
        <trans-unit id="7d5a97d89ad4a3be9582069b3310a6d0aee11430" translate="yes" xml:space="preserve">
          <source>InExpression</source>
          <target state="translated">InExpression</target>
        </trans-unit>
        <trans-unit id="6b952134a590c37c3cd245f783f0cab0b35e154b" translate="yes" xml:space="preserve">
          <source>Include all of the &lt;a href=&quot;https://en.wikipedia.org/wiki/IEEE_floating_point&quot;&gt;IEEE754&lt;/a&gt; options.</source>
          <target state="translated">모든 &lt;a href=&quot;https://en.wikipedia.org/wiki/IEEE_floating_point&quot;&gt;IEEE754&lt;/a&gt; 포함 옵션을 .</target>
        </trans-unit>
        <trans-unit id="21d63116a735028b1065c53175a7201eb75a690c" translate="yes" xml:space="preserve">
          <source>Include none of the above options.</source>
          <target state="translated">위의 옵션을 포함하지 마십시오.</target>
        </trans-unit>
        <trans-unit id="7fb47f835a97695060fa50d3d9efcf9e0fff9c84" translate="yes" xml:space="preserve">
          <source>Includes &lt;code&gt;&quot;hnsecs&quot;&lt;/code&gt; (hecto-nanoseconds (100 ns)), &lt;code&gt;&quot;usecs&quot;&lt;/code&gt; (microseconds), &lt;code&gt;&quot;msecs&quot;&lt;/code&gt; (milliseconds), &lt;code&gt;&quot;seconds&quot;&lt;/code&gt;, &lt;code&gt;&quot;minutes&quot;&lt;/code&gt;, &lt;code&gt;&quot;hours&quot;&lt;/code&gt;, &lt;code&gt;&quot;days&quot;&lt;/code&gt;, &lt;code&gt;&quot;weeks&quot;&lt;/code&gt;, &lt;code&gt;&quot;months&quot;&lt;/code&gt;, and &lt;code&gt;&quot;years&quot;&lt;/code&gt;</source>
          <target state="translated">포함 &lt;code&gt;&quot;hnsecs&quot;&lt;/code&gt; (헥토 - 나노초 (100 NS)), &lt;code&gt;&quot;usecs&quot;&lt;/code&gt; (마이크로 초), &lt;code&gt;&quot;msecs&quot;&lt;/code&gt; (밀리 초), &lt;code&gt;&quot;seconds&quot;&lt;/code&gt; , &lt;code&gt;&quot;minutes&quot;&lt;/code&gt; , &lt;code&gt;&quot;hours&quot;&lt;/code&gt; , &lt;code&gt;&quot;days&quot;&lt;/code&gt; , &lt;code&gt;&quot;weeks&quot;&lt;/code&gt; , &lt;code&gt;&quot;months&quot;&lt;/code&gt; 및 &lt;code&gt;&quot;years&quot;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="660485a4ef4f2ea299a5049e5e7f68faa3ac9dd9" translate="yes" xml:space="preserve">
          <source>Includes characters a, b, c, ..., z.</source>
          <target state="translated">문자 a, b, c, ..., z를 포함합니다.</target>
        </trans-unit>
        <trans-unit id="e622b4457bdf3ceb03f6cf725fab2a67de905818" translate="yes" xml:space="preserve">
          <source>Incomplete beta integral</source>
          <target state="translated">불완전한 베타 통합</target>
        </trans-unit>
        <trans-unit id="861a53fcf5c388edd7cf46ce6d95a43e95f0e787" translate="yes" xml:space="preserve">
          <source>Incomplete gamma integral and its complement</source>
          <target state="translated">불완전한 감마 적분 및 보완</target>
        </trans-unit>
        <trans-unit id="2f08d5bb658237cd92aa5a4432cb1cfef1a4c7b1" translate="yes" xml:space="preserve">
          <source>Incorporate &lt;code&gt;element_count&lt;/code&gt; and finalizes the hash.</source>
          <target state="translated">&lt;code&gt;element_count&lt;/code&gt; 통합 하고 해시를 마무리합니다.</target>
        </trans-unit>
        <trans-unit id="d8c996a9761aab171974108da093507dfd302c9b" translate="yes" xml:space="preserve">
          <source>Increases the reference count of the concrete class that implements this interface.</source>
          <target state="translated">이 인터페이스를 구현하는 구체적 클래스의 참조 횟수를 증가시킵니다.</target>
        </trans-unit>
        <trans-unit id="d12f1fabbb58a9af82666365bdf1d6e784f1a197" translate="yes" xml:space="preserve">
          <source>Increment</source>
          <target state="translated">Increment</target>
        </trans-unit>
        <trans-unit id="6179063ceb022e0b005a77ad50121ce42a8f12e0" translate="yes" xml:space="preserve">
          <source>Incremental options.</source>
          <target state="translated">증분 옵션.</target>
        </trans-unit>
        <trans-unit id="84205e80c2673222d26cbdde35ee1f4333d1b71b" translate="yes" xml:space="preserve">
          <source>Increments &lt;code&gt;numOwns&lt;/code&gt; (per instance and and per call) and forwards to &lt;code&gt; parent.owns(b)&lt;/code&gt;.</source>
          <target state="translated">증분 &lt;code&gt;numOwns&lt;/code&gt; (예 : 당 및 당 통화) 및 전달에 &lt;code&gt; parent.owns(b)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ddaf57d4b4048098b5dfe8043020c47a13b32e0a" translate="yes" xml:space="preserve">
          <source>Independent of the parameter this Logger will never log a message.</source>
          <target state="translated">매개 변수와 상관없이이 로거는 메시지를 기록하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="c2df9b932637fe9d32a0f16da1c11873398f873d" translate="yes" xml:space="preserve">
          <source>Index</source>
          <target state="translated">Index</target>
        </trans-unit>
        <trans-unit id="699dc9f4598bf2c18561d09ccbeb25728c70494b" translate="yes" xml:space="preserve">
          <source>Index Assignment Operator Overloading</source>
          <target state="translated">인덱스 할당 연산자 오버로딩</target>
        </trans-unit>
        <trans-unit id="71c97279cf83fc58467572ececa55bdae6e798a5" translate="yes" xml:space="preserve">
          <source>Index Expressions</source>
          <target state="translated">인덱스 표현식</target>
        </trans-unit>
        <trans-unit id="d1893a899240a1b591d897768bc60814a476fa87" translate="yes" xml:space="preserve">
          <source>Index Name NULL</source>
          <target state="translated">인덱스 이름 NULL</target>
        </trans-unit>
        <trans-unit id="e71ed4c87a94b38c5cecf345cf992053ca3a47d3" translate="yes" xml:space="preserve">
          <source>Index Name Table Name</source>
          <target state="translated">인덱스 이름 테이블 이름</target>
        </trans-unit>
        <trans-unit id="96c319248a56deb59ef179cae4ae3f7a3c92eca2" translate="yes" xml:space="preserve">
          <source>Index Of A Parameter With A Given Name</source>
          <target state="translated">주어진 이름을 가진 매개 변수의 색인</target>
        </trans-unit>
        <trans-unit id="bfb09c98cfaf2d55de0462489f758021e1b3f471" translate="yes" xml:space="preserve">
          <source>Index Op Assignment Operator Overloading</source>
          <target state="translated">인덱스 연산 할당 연산자 오버로딩</target>
        </trans-unit>
        <trans-unit id="49fe544cd53fba1ec8f72994e8cce9d496cf27f3" translate="yes" xml:space="preserve">
          <source>Index Operator Overloading</source>
          <target state="translated">인덱스 연산자 오버로딩</target>
        </trans-unit>
        <trans-unit id="a3b9e1c8a8784dafb7f4615ab228a307d1e4a762" translate="yes" xml:space="preserve">
          <source>Index of the argument for positional parameters, from &lt;code&gt;1&lt;/code&gt; to &lt;code&gt;ubyte.max&lt;/code&gt;. (&lt;code&gt;0&lt;/code&gt; means not used).</source>
          <target state="translated">위치 매개 변수의 인수 색인 ( &lt;code&gt;1&lt;/code&gt; - &lt;code&gt;ubyte.max&lt;/code&gt; ) . ( &lt;code&gt;0&lt;/code&gt; 수단이 사용되지 않음).</target>
        </trans-unit>
        <trans-unit id="c34e327ac8e45e062b5805d3beb7a3e4caec8300" translate="yes" xml:space="preserve">
          <source>Index of the last argument for positional parameter range, from &lt;code&gt;1&lt;/code&gt; to &lt;code&gt;ubyte.max&lt;/code&gt;. (&lt;code&gt;0&lt;/code&gt; means not used).</source>
          <target state="translated">위치 매개 변수 범위의 마지막 인수 색인 ( &lt;code&gt;1&lt;/code&gt; - &lt;code&gt;ubyte.max&lt;/code&gt; ) . ( &lt;code&gt;0&lt;/code&gt; 수단이 사용되지 않음).</target>
        </trans-unit>
        <trans-unit id="235d469a267eec1b21cb41bd835ec761b3be5b4a" translate="yes" xml:space="preserve">
          <source>Index of the maximal element of a range. &lt;code&gt;maxElement([3, 4, 1, 2])&lt;/code&gt; returns &lt;code&gt;1&lt;/code&gt;.</source>
          <target state="translated">범위의 최대 요소의 인덱스입니다. &lt;code&gt;maxElement([3, 4, 1, 2])&lt;/code&gt; 는 &lt;code&gt;1&lt;/code&gt; 을 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="25975946b5389d6cd4927c54b6079d61210dbf05" translate="yes" xml:space="preserve">
          <source>Index of the minimal element of a range. &lt;code&gt;minElement([3, 4, 1, 2])&lt;/code&gt; returns &lt;code&gt;2&lt;/code&gt;.</source>
          <target state="translated">범위의 최소 요소의 인덱스입니다. &lt;code&gt;minElement([3, 4, 1, 2])&lt;/code&gt; 는 &lt;code&gt;2&lt;/code&gt; 를 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="a04ef38d2ddc39bb1db51cbf56276c8f962441c1" translate="yes" xml:space="preserve">
          <source>IndexExpression</source>
          <target state="translated">IndexExpression</target>
        </trans-unit>
        <trans-unit id="3b15c071f8f2a9b03d20f13f4ee4fa47f96aaf8d" translate="yes" xml:space="preserve">
          <source>Indexed!(Source, Indices) &lt;strong id=&quot;indexed&quot;&gt;indexed&lt;/strong&gt;(Source, Indices)(Source source, Indices indices);</source>
          <target state="translated">인덱스! (소스, 인덱스) &lt;strong id=&quot;indexed&quot;&gt;인덱스&lt;/strong&gt; (소스, 인덱스) (소스 소스, 인덱스 인덱스);</target>
        </trans-unit>
        <trans-unit id="9951861c21df18489a5872209655d6f9039b5e2a" translate="yes" xml:space="preserve">
          <source>Indexing</source>
          <target state="translated">Indexing</target>
        </trans-unit>
        <trans-unit id="76508adf7decca48f64672d4079c15326fbc39f8" translate="yes" xml:space="preserve">
          <source>Indexing and slicing operations. Provided only if &lt;code&gt;hasSlicing!Source&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">인덱싱 및 슬라이싱 작업. &lt;code&gt;hasSlicing!Source&lt;/code&gt; 가 &lt;code&gt;true&lt;/code&gt; 인 경우에만 제공됩니다 .</target>
        </trans-unit>
        <trans-unit id="74036ccb3b85a0419f22323e1fac3915c3caf378" translate="yes" xml:space="preserve">
          <source>Indexing operators yielding or modifyng the value at the specified index.</source>
          <target state="translated">인덱싱 연산자는 지정된 인덱스에서 값을 생성하거나 수정합니다.</target>
        </trans-unit>
        <trans-unit id="6d2692938b71d76efadfb2cea1bb4a83352f988a" translate="yes" xml:space="preserve">
          <source>Indexing, slicing and bidirectional operations and range primitives. Provided only if &lt;code&gt;hasSlicing!Source&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">인덱싱, 슬라이싱 및 양방향 작업 및 범위 프리미티브 &lt;code&gt;hasSlicing!Source&lt;/code&gt; 가 &lt;code&gt;true&lt;/code&gt; 인 경우에만 제공 .</target>
        </trans-unit>
        <trans-unit id="f85958353bf4bfb31d66cc4f95a9358b5bedf1c3" translate="yes" xml:space="preserve">
          <source>Indicates a direction in time. One example of its use is &lt;a href=&quot;#Interval&quot;&gt;&lt;code&gt;Interval&lt;/code&gt;&lt;/a&gt;'s &lt;a href=&quot;#expand&quot;&gt;&lt;code&gt;expand&lt;/code&gt;&lt;/a&gt; function which uses it to indicate whether the interval should be expanded backwards (into the past), forwards (into the future), or both.</source>
          <target state="translated">시간 방향을 나타냅니다. 그 사용의 한 예는 &lt;a href=&quot;#Interval&quot;&gt; &lt;code&gt;Interval&lt;/code&gt; &lt;/a&gt; 뒤로 (과거로), 앞으로 (앞으로) 또는 둘 다로 확장해야하는지 여부를 표시하는 데 사용하는 Interval 의 &lt;a href=&quot;#expand&quot;&gt; &lt;code&gt;expand&lt;/code&gt; &lt;/a&gt; 기능입니다.</target>
        </trans-unit>
        <trans-unit id="89b0fbd07a7b5dbf8da4ba701f1805d8565d86bb" translate="yes" xml:space="preserve">
          <source>Indicates if a nested aggregate prevents or not a function to be inlined. It's used to compute the cost but also to avoid a copy of the aggregate while the inliner processes.</source>
          <target state="translated">중첩 집계가 함수의 인라인을 방해하는지 여부를 나타냅니다. 비용을 계산하는 데 사용되지만 인라이너가 처리하는 동안 집계 사본을 피하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="a10ebf2fd0a4ff0f019e4879f48fae2f4e5a0b0d" translate="yes" xml:space="preserve">
          <source>Indicates that the managed memory space be minimized by returning free physical memory to the operating system. The amount of free memory returned depends on the allocator design and on program behavior.</source>
          <target state="translated">사용 가능한 실제 메모리를 운영 체제로 리턴하여 관리 메모리 공간을 최소화 함을 나타냅니다. 반환되는 사용 가능한 메모리 양은 할당 자 디자인 및 프로그램 동작에 따라 다릅니다.</target>
        </trans-unit>
        <trans-unit id="4ec109e112fc6bfd6a9d0109f56e7e7967df8488" translate="yes" xml:space="preserve">
          <source>Indicates the checking state of various contracts.</source>
          <target state="translated">다양한 계약의 점검 상태를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="cb18c8046fd7efef0dda1d752fd5c6ff22b02f5d" translate="yes" xml:space="preserve">
          <source>Indicates the kind of scan being performed by &lt;code&gt;thread_scanAllType&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;thread_scanAllType&lt;/code&gt; 이 수행하는 스캔 종류를 나타냅니다 .</target>
        </trans-unit>
        <trans-unit id="8f13413a46338bc9d77efe386dd1970d9c61578f" translate="yes" xml:space="preserve">
          <source>Indicates the type of a &lt;code&gt;JSONValue&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;JSONValue&lt;/code&gt; 의 유형을 나타냅니다 .</target>
        </trans-unit>
        <trans-unit id="ee35c8aada8a6aa7b7217bd768effeae4d28769f" translate="yes" xml:space="preserve">
          <source>Indicates whether &lt;code&gt;T&lt;/code&gt; is a file handle, i.e. the type is implicitly convertable to &lt;a href=&quot;#File&quot;&gt;&lt;code&gt;File&lt;/code&gt;&lt;/a&gt; or a pointer to a &lt;a href=&quot;core_stdc_stdio#FILE&quot;&gt;&lt;code&gt;core.stdc.stdio.FILE&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;T&lt;/code&gt; 가 파일 핸들 인지 여부를 나타냅니다 . 즉, 형식이 암시 적으로 &lt;a href=&quot;#File&quot;&gt; &lt;code&gt;File&lt;/code&gt; 로 변환 가능&lt;/a&gt; 하거나 &lt;a href=&quot;core_stdc_stdio#FILE&quot;&gt; &lt;code&gt;core.stdc.stdio.FILE&lt;/code&gt; 에&lt;/a&gt; 대한 포인터 입니다.</target>
        </trans-unit>
        <trans-unit id="16f0af9200309c4bcede9c6bd76aa0d14467a310" translate="yes" xml:space="preserve">
          <source>Indicates whether an address has been marked by the GC.</source>
          <target state="translated">주소가 GC에 의해 표시되었는지 여부를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="c7fabc24fed84961bce8996fe0ecd1e5cdad5e83" translate="yes" xml:space="preserve">
          <source>Indicates whether the comparisons are case sensitive.</source>
          <target state="translated">비교가 대소 문자를 구분하는지 여부를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="f7d28431fd9c9c5871085a5497dc7e6e1e0cf415" translate="yes" xml:space="preserve">
          <source>Indicates which contracts should be checked or not.</source>
          <target state="translated">점검해야 할 계약을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="4243a1f947d3219fb4149e60971ece346868e5f0" translate="yes" xml:space="preserve">
          <source>Individual characters (&lt;code&gt;char, &lt;/code&gt;wchar&lt;code&gt;, or &lt;/code&gt;dchar`) are formatted as Unicode characters with &lt;code&gt;%s&lt;/code&gt; and as integers with integral-specific format specs.</source>
          <target state="translated">개별 문자 ( &lt;code&gt;char, &lt;/code&gt; wchar &lt;code&gt;, or &lt;/code&gt; dchar`)는 &lt;code&gt;%s&lt;/code&gt; 유니 코드 문자로 , 정수에 특정한 형식 스펙이있는 정수로 형식이 지정됩니다.</target>
        </trans-unit>
        <trans-unit id="29597351771a3ef19075a67f20ee90c6ad63bea0" translate="yes" xml:space="preserve">
          <source>Individual characters are compared using &lt;code&gt;filenameCharCmp!cs&lt;/code&gt;, where &lt;code&gt;cs&lt;/code&gt; is an optional template parameter determining whether the comparison is case sensitive or not.</source>
          <target state="translated">&lt;code&gt;filenameCharCmp!cs&lt;/code&gt; 사용하여 개별 문자를 비교합니다 . 여기서 &lt;code&gt;cs&lt;/code&gt; 는 비교가 대소 문자를 구분하는지 여부를 결정하는 선택적 템플리트 매개 변수입니다.</target>
        </trans-unit>
        <trans-unit id="49226687980b9cd956057b7a38e24b4e2409b256" translate="yes" xml:space="preserve">
          <source>Individual characters are compared using &lt;code&gt;filenameCharCmp!cs&lt;/code&gt;, where &lt;code&gt;cs&lt;/code&gt; is an optional template parameter determining whether the comparison is case sensitive or not. See the &lt;a href=&quot;#filenameCharCmp&quot;&gt;&lt;code&gt;filenameCharCmp&lt;/code&gt;&lt;/a&gt; documentation for details.</source>
          <target state="translated">&lt;code&gt;filenameCharCmp!cs&lt;/code&gt; 사용하여 개별 문자를 비교합니다 . 여기서 &lt;code&gt;cs&lt;/code&gt; 는 비교가 대소 문자를 구분하는지 여부를 결정하는 선택적 템플리트 매개 변수입니다. 자세한 내용은 &lt;a href=&quot;#filenameCharCmp&quot;&gt; &lt;code&gt;filenameCharCmp&lt;/code&gt; &lt;/a&gt; 설명서를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="e1f361f1f9ae5992659047882bc5221a903aebb0" translate="yes" xml:space="preserve">
          <source>Individual field in the Ctor with information about its callees and location.</source>
          <target state="translated">수신자 및 위치에 대한 정보가있는 Ctor의 개별 필드입니다.</target>
        </trans-unit>
        <trans-unit id="2112ae8639e7801d8cfbbdd81cd2583bb2a4a9cd" translate="yes" xml:space="preserve">
          <source>Individual tests are specified in the unit test using &lt;a href=&quot;expression#AssertExpression&quot;&gt;AssertExpressions&lt;/a&gt;. Unlike</source>
          <target state="translated">개별 테스트는 &lt;a href=&quot;expression#AssertExpression&quot;&gt;AssertExpressions를&lt;/a&gt; 사용하여 단위 테스트에서 지정됩니다 . 같지 않은</target>
        </trans-unit>
        <trans-unit id="a1c45f8b0cd8cbcf6f1e93b6a635fb2a38dc40f6" translate="yes" xml:space="preserve">
          <source>Inequality is defined as the logical negation of equality.</source>
          <target state="translated">불평등은 평등의 논리적 부정으로 정의됩니다.</target>
        </trans-unit>
        <trans-unit id="65b109f015e153776d80b153da2023fd8d163d9f" translate="yes" xml:space="preserve">
          <source>Infinite ranges are compatible, provided the parameter &lt;code&gt;upTo&lt;/code&gt; is specified, in which case the implementation simply returns upTo.</source>
          <target state="translated">&lt;code&gt;upTo&lt;/code&gt; 매개 변수 가 지정되면 무한 범위가 호환되며, 이 경우 구현은 단순히 upTo를 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="cc80f798db63ecb0ec11198be5af2b60c15e0345" translate="yes" xml:space="preserve">
          <source>Infinite ranges with slicing support must return an instance of &lt;a href=&quot;std_range#Take&quot;&gt;&lt;code&gt;std.range.Take&lt;/code&gt;&lt;/a&gt; when sliced with a specific lower and upper bound (see &lt;a href=&quot;std_range_primitives#hasSlicing&quot;&gt;&lt;code&gt;std.range.primitives.hasSlicing&lt;/code&gt;&lt;/a&gt;); &lt;code&gt;handle&lt;/code&gt; deals with this by &lt;code&gt;take&lt;/code&gt;ing 0 from the return value of the handler function and returning that when an exception is caught.</source>
          <target state="translated">슬라이싱을 지원하는 무한 범위는 &lt;a href=&quot;std_range#Take&quot;&gt; &lt;code&gt;std.range.Take&lt;/code&gt; &lt;/a&gt; 의 인스턴스를 반환해야합니다 . 특정 하한 및 상한으로 슬라이스 할 때 &lt;a href=&quot;std_range_primitives#hasSlicing&quot;&gt; &lt;code&gt;std.range.primitives.hasSlicing&lt;/code&gt; &lt;/a&gt; ( std.range.primitives.hasSlicing 참조 ). &lt;code&gt;handle&lt;/code&gt; 하여이와 거래를 &lt;code&gt;take&lt;/code&gt; 핸들러 함수의 반환 값에서 0 보내고 예외가 잡힌 때 반환.</target>
        </trans-unit>
        <trans-unit id="27d9e5c1d05febee114a9f9e51dbec3780887c9a" translate="yes" xml:space="preserve">
          <source>Infiniteness of the wrapped range is not propagated.  Length is not propagated in the case of non-random access ranges.</source>
          <target state="translated">랩핑 된 범위의 무한대는 전파되지 않습니다. 비 랜덤 액세스 범위의 경우 길이가 전파되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="266086404e3edd52081be68722aa77ff6a65cf70" translate="yes" xml:space="preserve">
          <source>Info on a file, similar to what you'd get from stat on a Posix system.</source>
          <target state="translated">Posix 시스템의 통계에서 얻는 것과 유사한 파일 정보.</target>
        </trans-unit>
        <trans-unit id="cd1b541e2d202e9ed7863df5d539d80a14d92db1" translate="yes" xml:space="preserve">
          <source>Information about an interface. When an object is accessed via an interface, an Interface* appears as the first entry in its vtbl.</source>
          <target state="translated">인터페이스에 대한 정보. 인터페이스를 통해 객체에 액세스하면 Interface *가 vtbl의 첫 번째 항목으로 나타납니다.</target>
        </trans-unit>
        <trans-unit id="cea2e687310e3b71b249c28a49288e9fd3bfa210" translate="yes" xml:space="preserve">
          <source>Information about an option.</source>
          <target state="translated">옵션에 대한 정보.</target>
        </trans-unit>
        <trans-unit id="e073c50eee2c368b573895c98fb35595e9133239" translate="yes" xml:space="preserve">
          <source>Information about errors should be logged with this level.</source>
          <target state="translated">오류에 대한 정보는이 수준으로 기록해야합니다.</target>
        </trans-unit>
        <trans-unit id="928345681d20aa3d2b01bea36a816d52c33a48de" translate="yes" xml:space="preserve">
          <source>Information about the dynamic type of the class</source>
          <target state="translated">클래스의 동적 유형에 대한 정보</target>
        </trans-unit>
        <trans-unit id="dc5ebb2696c4fafd1bdd1b19b9d403757258f4ad" translate="yes" xml:space="preserve">
          <source>Information about the error.</source>
          <target state="translated">오류에 대한 정보.</target>
        </trans-unit>
        <trans-unit id="b7329bd16608fcee8af0c9e3dcd5b29f7f17343f" translate="yes" xml:space="preserve">
          <source>Information about the target operating system, environment, and CPU.</source>
          <target state="translated">대상 운영 체제, 환경 및 CPU에 대한 정보</target>
        </trans-unit>
        <trans-unit id="ceccba3653730142ed262183682108d6a4b114f3" translate="yes" xml:space="preserve">
          <source>Information gathered about externally defined template member functions, member data, and member classes.</source>
          <target state="translated">외부 적으로 정의 된 템플릿 멤버 함수, 멤버 데이터 및 멤버 클래스에 대한 정보가 수집되었습니다.</target>
        </trans-unit>
        <trans-unit id="908b94b8c3e2309d82de3bc12b0083b2f0550dd4" translate="yes" xml:space="preserve">
          <source>Information gathered about nested class friends.</source>
          <target state="translated">중첩 된 클래스 친구에 대한 정보가 수집되었습니다.</target>
        </trans-unit>
        <trans-unit id="7a43d043ba9567583c6e384e6e0ac879da254eab" translate="yes" xml:space="preserve">
          <source>Information gathered about nested explicit specializations.</source>
          <target state="translated">중첩 된 명시 적 전문화에 대한 정보가 수집되었습니다.</target>
        </trans-unit>
        <trans-unit id="464dcc7e55ca0baa3461154f3221489d53fa204b" translate="yes" xml:space="preserve">
          <source>Information gathered about primary member template explicit specialization.</source>
          <target state="translated">기본 멤버 템플릿 명시 적 전문화에 대한 정보가 수집되었습니다.</target>
        </trans-unit>
        <trans-unit id="8bc70f913f6ebe36fcb59b26b1c9b07d1f380466" translate="yes" xml:space="preserve">
          <source>Information regarding the allocated memory block or BlkInfo.init on error.</source>
          <target state="translated">할당 된 메모리 블록 또는 오류시 BlkInfo.init에 관한 정보.</target>
        </trans-unit>
        <trans-unit id="1675fcfc1cf455d10d63328190309be0fe262d03" translate="yes" xml:space="preserve">
          <source>Information regarding the memory block referenced by p or BlkInfo.init on error.</source>
          <target state="translated">오류시 p 또는 BlkInfo.init가 참조하는 메모리 블록에 관한 정보.</target>
        </trans-unit>
        <trans-unit id="58823af05ebe1ba3ff034e5ec492dcbd5b2f86cc" translate="yes" xml:space="preserve">
          <source>Inherited</source>
          <target state="translated">Inherited</target>
        </trans-unit>
        <trans-unit id="fcb1ddc45496d5bd9bbb1d0e3e24a58c56f33281" translate="yes" xml:space="preserve">
          <source>Initial value</source>
          <target state="translated">초기 값</target>
        </trans-unit>
        <trans-unit id="97e0f0f5459c7f9a8a0eadb6d21739e1c19dd524" translate="yes" xml:space="preserve">
          <source>Initial_Punctuation</source>
          <target state="translated">Initial_Punctuation</target>
        </trans-unit>
        <trans-unit id="e3e40f7638a489f11f1de06365e82209954d82d0" translate="yes" xml:space="preserve">
          <source>Initialization hook, called FROM each thread. No assumptions about module initialization state should be made.</source>
          <target state="translated">각 스레드에서 FROM이라고하는 초기화 후크. 모듈 초기화 상태에 대한 가정은 없어야합니다.</target>
        </trans-unit>
        <trans-unit id="a459dff3012da591453989e5860a6fd825f63ce3" translate="yes" xml:space="preserve">
          <source>Initialize</source>
          <target state="translated">Initialize</target>
        </trans-unit>
        <trans-unit id="7bf3e06594405eb1afbafdd083622d687011597a" translate="yes" xml:space="preserve">
          <source>Initialize The SQLite Library</source>
          <target state="translated">SQLite 라이브러리 초기화</target>
        </trans-unit>
        <trans-unit id="748256c78e345ebbc504f121b03e80be2a80bbca" translate="yes" xml:space="preserve">
          <source>Initialize a TOK.cantExpression Expression.</source>
          <target state="translated">TOK.cantExpression 표현식을 초기화하십시오.</target>
        </trans-unit>
        <trans-unit id="27911a1150c0c1d2144b25e270682254f6dac63a" translate="yes" xml:space="preserve">
          <source>Initialize config variables.</source>
          <target state="translated">구성 변수를 초기화하십시오.</target>
        </trans-unit>
        <trans-unit id="cbe2f6d3df93f8e15ce05f5a1f98cda2b20db74a" translate="yes" xml:space="preserve">
          <source>Initialize druntime. If a C program wishes to call D code, and there's no D main(), then it must call rt_init() and rt_term().</source>
          <target state="translated">druntime을 초기화하십시오. C 프로그램이 D 코드를 호출하려고하고 D main ()이 없으면 rt_init () 및 rt_term ()을 호출해야합니다.</target>
        </trans-unit>
        <trans-unit id="8eb8be79e89fc0c011f24c39ee8771af00f563f7" translate="yes" xml:space="preserve">
          <source>Initialize for inferring the attributes of this function.</source>
          <target state="translated">이 함수의 속성을 유추하기 위해 초기화하십시오.</target>
        </trans-unit>
        <trans-unit id="f721b948f9c83247c02645e5eb12893bfb899d86" translate="yes" xml:space="preserve">
          <source>Initialize list package.</source>
          <target state="translated">목록 패키지를 초기화하십시오.</target>
        </trans-unit>
        <trans-unit id="de4ea7df574920c39fb3c6bd0386ce6a9cd8fd5d" translate="yes" xml:space="preserve">
          <source>Initialize the Objective-C string using a C string.</source>
          <target state="translated">C 문자열을 사용하여 Objective-C 문자열을 초기화하십시오.</target>
        </trans-unit>
        <trans-unit id="ef4109d3528796628f6b2a0029715405248a578e" translate="yes" xml:space="preserve">
          <source>Initialize the Target</source>
          <target state="translated">대상 초기화</target>
        </trans-unit>
        <trans-unit id="0980ce942938201d58c731edfd7b47e45dd9efe7" translate="yes" xml:space="preserve">
          <source>Initialize the dual-context array with the context pointers.</source>
          <target state="translated">컨텍스트 포인터를 사용하여 이중 컨텍스트 배열을 초기화하십시오.</target>
        </trans-unit>
        <trans-unit id="8e023ffe90e1164684f46dc5edc97859a5680a5f" translate="yes" xml:space="preserve">
          <source>Initialize the hidden aggregate member, vthis, with the context pointer.</source>
          <target state="translated">컨텍스트 포인터를 사용하여 숨겨진 집계 멤버 vthis를 초기화하십시오.</target>
        </trans-unit>
        <trans-unit id="59c6a3b95f9730ad20a9c9db67ee73fd2a6949c4" translate="yes" xml:space="preserve">
          <source>Initialize the instance by creating a working curl handle.</source>
          <target state="translated">작업 컬 핸들을 만들어 인스턴스를 초기화하십시오.</target>
        </trans-unit>
        <trans-unit id="1a30f56d1770a9dcc7fd0bb681a1c06b14ad9d91" translate="yes" xml:space="preserve">
          <source>Initialize the memory allocator</source>
          <target state="translated">메모리 할당 기 초기화</target>
        </trans-unit>
        <trans-unit id="494a02556f310d47be7c5338d8f5523416a42a2e" translate="yes" xml:space="preserve">
          <source>Initialize with a message and an error code.</source>
          <target state="translated">메시지와 오류 코드로 초기화하십시오.</target>
        </trans-unit>
        <trans-unit id="0c55ba13e2bd9dbfd35641ebe93792c6061e39cd" translate="yes" xml:space="preserve">
          <source>Initializer</source>
          <target state="translated">Initializer</target>
        </trans-unit>
        <trans-unit id="51bf015ae2898049c8dda3ee0d3b48d0b0503aac" translate="yes" xml:space="preserve">
          <source>Initializer &lt;code&gt;init&lt;/code&gt;</source>
          <target state="translated">이니셜 라이저 &lt;code&gt;init&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="2b1d1b30aa70eb127392afc002aaf56ef13eddf1" translate="yes" xml:space="preserve">
          <source>Initializer &lt;code&gt;inx&lt;/code&gt;</source>
          <target state="translated">이니셜 라이저 &lt;code&gt;inx&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="376a8ae3746f3bef7e7c198b9b11401e24b7d25c" translate="yes" xml:space="preserve">
          <source>Initializer &lt;strong id=&quot;inferType&quot;&gt;inferType&lt;/strong&gt;(Initializer init, Scope* sc);</source>
          <target state="translated">이니셜 &lt;strong id=&quot;inferType&quot;&gt;라이저 유인형&lt;/strong&gt; (Initializer init, Scope * sc);</target>
        </trans-unit>
        <trans-unit id="d8d2abfa30e5c4556b8e2c9d2dc62e742af966eb" translate="yes" xml:space="preserve">
          <source>Initializer &lt;strong id=&quot;initializerSemantic&quot;&gt;initializerSemantic&lt;/strong&gt;(Initializer init, Scope* sc, Type t, NeedInterpret needInterpret);</source>
          <target state="translated">이니셜 &lt;strong id=&quot;initializerSemantic&quot;&gt;라이저 이니셜 라이저&lt;/strong&gt; 시맨틱 (Initializer init, Scope * sc, Type t, NeedInterpret needInterpret);</target>
        </trans-unit>
        <trans-unit id="88abdada1a9385d97517a707f4ab8a5f5a3e696d" translate="yes" xml:space="preserve">
          <source>Initializer &lt;strong id=&quot;syntaxCopy&quot;&gt;syntaxCopy&lt;/strong&gt;(Initializer inx);</source>
          <target state="translated">이니셜 &lt;strong id=&quot;syntaxCopy&quot;&gt;라이저 구문 복사&lt;/strong&gt; ( Initializer &lt;strong id=&quot;syntaxCopy&quot;&gt;inx&lt;/strong&gt; );</target>
        </trans-unit>
        <trans-unit id="c33131a57d387e740aae854652440535c3dd0652" translate="yes" xml:space="preserve">
          <source>Initializer AST node</source>
          <target state="translated">이니셜 라이저 AST 노드</target>
        </trans-unit>
        <trans-unit id="14b021ae9bb3f976f77030248590d743674ec1b8" translate="yes" xml:space="preserve">
          <source>Initializer AST to copy</source>
          <target state="translated">복사 할 이니셜 라이저 AST</target>
        </trans-unit>
        <trans-unit id="3121cafc28fbd2cff06107236c3142ae39ff3c9a" translate="yes" xml:space="preserve">
          <source>Initializes a &lt;code&gt;RefCounted&lt;/code&gt; with &lt;code&gt;val&lt;/code&gt;. The template parameter &lt;code&gt;T&lt;/code&gt; of &lt;code&gt;RefCounted&lt;/code&gt; is inferred from &lt;code&gt;val&lt;/code&gt;. This function can be used to move non-copyable values to the heap. It also disables the &lt;code&gt;autoInit&lt;/code&gt; option of &lt;code&gt;RefCounted&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;val&lt;/code&gt; 로 &lt;code&gt;RefCounted&lt;/code&gt; 를 초기화합니다 . &lt;code&gt;RefCounted&lt;/code&gt; 의 템플릿 매개 변수 &lt;code&gt;T&lt;/code&gt; 는 &lt;code&gt;val&lt;/code&gt; 에서 유추됩니다 . 이 기능은 복사 할 수없는 값을 힙으로 이동하는 데 사용할 수 있습니다. 또한 비활성화 &lt;code&gt;autoInit&lt;/code&gt; 의 의 옵션 &lt;code&gt;RefCounted&lt;/code&gt; 을 .</target>
        </trans-unit>
        <trans-unit id="5840e1604b436855e9916e7392a48763951eabf0" translate="yes" xml:space="preserve">
          <source>Initializes a barrier object which releases threads in groups of limit in size.</source>
          <target state="translated">크기 제한 그룹에서 스레드를 해제하는 배리어 객체를 초기화합니다.</target>
        </trans-unit>
        <trans-unit id="e7d8f005a4914e6f92d821d5b224a6bd9e5c292c" translate="yes" xml:space="preserve">
          <source>Initializes a condition object which is associated with the supplied mutex object.</source>
          <target state="translated">제공된 뮤텍스 개체와 관련된 조건 개체를 초기화합니다.</target>
        </trans-unit>
        <trans-unit id="2e831c2f248c0c0989af9f49fabed81c26839fd7" translate="yes" xml:space="preserve">
          <source>Initializes a fiber object which is associated with a dynamic D function.</source>
          <target state="translated">동적 D 기능과 관련된 광섬유 객체를 초기화합니다.</target>
        </trans-unit>
        <trans-unit id="af50363b8f7b4155835b77141de6a5c61fdd71a0" translate="yes" xml:space="preserve">
          <source>Initializes a fiber object which is associated with a static D function.</source>
          <target state="translated">정적 D 함수와 관련된 광섬유 객체를 초기화합니다.</target>
        </trans-unit>
        <trans-unit id="45f928a2b81b560a0de6c9239785399cedf0251c" translate="yes" xml:space="preserve">
          <source>Initializes a generator object which is associated with a dynamic D function. The function will be called once to prepare the range for iteration.</source>
          <target state="translated">동적 D 함수와 관련된 생성기 객체를 초기화합니다. 반복 범위를 준비하기 위해 함수가 한 번 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="d0a92e3c77360cd0a21c46127be86aca1b90b608" translate="yes" xml:space="preserve">
          <source>Initializes a generator object which is associated with a static D function. The function will be called once to prepare the range for iteration.</source>
          <target state="translated">정적 D 함수와 관련된 생성기 객체를 초기화합니다. 반복 범위를 준비하기 위해 함수가 한 번 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="d3728c381d3549c70b43d294cf94f34b914968b0" translate="yes" xml:space="preserve">
          <source>Initializes a mutex object and sets it as the monitor for &lt;code&gt;obj&lt;/code&gt;.</source>
          <target state="translated">에 대한 모니터와 같은 뮤텍스 개체 및 설정을 초기화 &lt;code&gt;obj&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3a70c8975cc02255930db5c1532e070f13d983d9" translate="yes" xml:space="preserve">
          <source>Initializes a mutex object.</source>
          <target state="translated">뮤텍스 개체를 초기화합니다.</target>
        </trans-unit>
        <trans-unit id="dc21cd96d7c298b730677d5fadf1f39d6fcdc2a3" translate="yes" xml:space="preserve">
          <source>Initializes a read/write mutex object with the supplied policy.</source>
          <target state="translated">제공된 정책으로 읽기 / 쓰기 뮤텍스 개체를 초기화합니다.</target>
        </trans-unit>
        <trans-unit id="1bf7bde2d0e1b4605f5fcc7cecf50b8041c0ee33" translate="yes" xml:space="preserve">
          <source>Initializes a read/write mutex reader proxy object.</source>
          <target state="translated">읽기 / 쓰기 뮤텍스 리더 프록시 객체를 초기화합니다.</target>
        </trans-unit>
        <trans-unit id="cac251d6ab6ce4228fd76b8f664aca1fdce466aa" translate="yes" xml:space="preserve">
          <source>Initializes a read/write mutex writer proxy object.</source>
          <target state="translated">읽기 / 쓰기 뮤텍스 라이터 프록시 객체를 초기화합니다.</target>
        </trans-unit>
        <trans-unit id="e9c3d0e482ee4665047c01099490677dcee2bdf1" translate="yes" xml:space="preserve">
          <source>Initializes a semaphore object with the specified initial count.</source>
          <target state="translated">지정된 초기 카운트로 세마포어 객체를 초기화합니다.</target>
        </trans-unit>
        <trans-unit id="b08f976531720c8d331b9fd2fe472f259a01f7f8" translate="yes" xml:space="preserve">
          <source>Initializes a thread object which is associated with a dynamic D function.</source>
          <target state="translated">동적 D 함수와 관련된 스레드 객체를 초기화합니다.</target>
        </trans-unit>
        <trans-unit id="6feddfb754d931f52971603d63763097e08f646e" translate="yes" xml:space="preserve">
          <source>Initializes a thread object which is associated with a static D function.</source>
          <target state="translated">정적 D 함수와 관련된 스레드 개체를 초기화합니다.</target>
        </trans-unit>
        <trans-unit id="02e85d0a8c0d02c068e1d5736a1954b12b36920b" translate="yes" xml:space="preserve">
          <source>Initializes all elements of &lt;code&gt;range&lt;/code&gt; with their &lt;code&gt;.init&lt;/code&gt; value. Assumes that the elements of the range are uninitialized.</source>
          <target state="translated">의 모든 요소를 초기화 &lt;code&gt;range&lt;/code&gt; 자신과 &lt;code&gt;.init&lt;/code&gt; 의 값입니다. 범위의 요소가 초기화되지 않은 것으로 가정합니다.</target>
        </trans-unit>
        <trans-unit id="472c952e25298d18516b57e8e37279e00d61a5fe" translate="yes" xml:space="preserve">
          <source>Initializes an event object. Does nothing if the event is already initialized.</source>
          <target state="translated">이벤트 객체를 초기화합니다. 이벤트가 이미 초기화 된 경우 아무 작업도 수행하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="eaf4287ba6b011331efecfcdf502db022ed8e9d5" translate="yes" xml:space="preserve">
          <source>Initializes each element of &lt;code&gt;range&lt;/code&gt; with &lt;code&gt;value&lt;/code&gt;. Assumes that the elements of the range are uninitialized. This is of interest for structs that define copy constructors (for all other types, &lt;a href=&quot;#fill&quot;&gt;&lt;code&gt;fill&lt;/code&gt;&lt;/a&gt; and uninitializedFill are equivalent).</source>
          <target state="translated">&lt;code&gt;range&lt;/code&gt; 의 각 요소 를 &lt;code&gt;value&lt;/code&gt; 로 초기화합니다 . 범위의 요소가 초기화되지 않은 것으로 가정합니다. 이것은 복사 생성자를 정의하는 구조체에 중요합니다 (다른 모든 유형의 경우 &lt;a href=&quot;#fill&quot;&gt; &lt;code&gt;fill&lt;/code&gt; &lt;/a&gt; 및 uninitializedFill은 동일 함).</target>
        </trans-unit>
        <trans-unit id="fc7f0006265d50c993eca80b0dee1e88b813e83a" translate="yes" xml:space="preserve">
          <source>Initializes the Symbol s with the contents of the exception handler table.</source>
          <target state="translated">예외 처리기 테이블의 내용으로 Symbol을 초기화합니다.</target>
        </trans-unit>
        <trans-unit id="ce7db86ae90730cf95765268d14c3efeca306d1a" translate="yes" xml:space="preserve">
          <source>Initializes the digest.</source>
          <target state="translated">다이제스트를 초기화합니다.</target>
        </trans-unit>
        <trans-unit id="7cc4cbbc423778a9b3a1d152d6911455078c9956" translate="yes" xml:space="preserve">
          <source>Initializes the runtime. This call is to be used in instances where the standard program initialization process is not executed. This is most often in shared libraries or in libraries linked to a C program. If the runtime was already successfully initialized this returns true. Each call to initialize must be paired by a call to &lt;a href=&quot;#terminate&quot;&gt;&lt;code&gt;terminate&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">런타임을 초기화합니다. 이 호출은 표준 프로그램 초기화 프로세스가 실행되지 않는 경우에 사용됩니다. 이것은 대부분 공유 라이브러리 또는 C 프로그램에 연결된 라이브러리에 있습니다. 런타임이 이미 초기화 된 경우 true를 리턴합니다. 초기화 할 각 호출은 &lt;a href=&quot;#terminate&quot;&gt; &lt;code&gt;terminate&lt;/code&gt; &lt;/a&gt; 호출과 쌍을 이루어야합니다 .</target>
        </trans-unit>
        <trans-unit id="fd011618a7d780c02099be5bb857d574a889ced4" translate="yes" xml:space="preserve">
          <source>Initializes the thread module. This function must be called by the garbage collector on startup and before any other thread routines are called.</source>
          <target state="translated">스레드 모듈을 초기화합니다. 이 함수는 시작시 및 다른 스레드 루틴을 호출하기 전에 가비지 콜렉터가 호출해야합니다.</target>
        </trans-unit>
        <trans-unit id="f7bf172cc09f5d408e5dbadd459ffc810fa40735" translate="yes" xml:space="preserve">
          <source>Initializes this object.</source>
          <target state="translated">이 객체를 초기화합니다.</target>
        </trans-unit>
        <trans-unit id="330d0782e4b98319bc9e2fabb58b097370cccd48" translate="yes" xml:space="preserve">
          <source>Initializes var with the lazy init value in a thread-safe manner.</source>
          <target state="translated">스레드 안전 방식으로 lazy init 값으로 var을 초기화합니다.</target>
        </trans-unit>
        <trans-unit id="357baf1e97067fcd6c5956ff04a8aafd59f2e20c" translate="yes" xml:space="preserve">
          <source>Initializing a field more than once is an error:</source>
          <target state="translated">필드를 두 번 이상 초기화하면 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="7b6a85ba00f40263892051680251fc88efc22b1f" translate="yes" xml:space="preserve">
          <source>Initially, &lt;code&gt;KRRegion&lt;/code&gt; starts in &quot;region&quot; mode: allocations are served from the memory chunk in a region fashion. Thus, as long as there is enough memory left, &lt;code&gt;KRRegion.allocate&lt;/code&gt; has the performance profile of a region allocator. Deallocation inserts (in &amp;Omicron;(&lt;code&gt;1&lt;/code&gt;) time) the deallocated blocks in an unstructured freelist, which is not read in region mode.</source>
          <target state="translated">&lt;code&gt;KRRegion&lt;/code&gt; 은 처음 에 &quot;지역&quot;모드에서 시작합니다. 할당은 지역 방식으로 메모리 청크에서 제공됩니다. 따라서 충분한 메모리가 남아있는 한 &lt;code&gt;KRRegion.allocate&lt;/code&gt; 는 region 할당 자의 성능 프로파일을 갖습니다. 할당 해제 는 할당 해제 된 블록을 구조화되지 않은 프리리스트에 삽입하고 (0 ( &lt;code&gt;1&lt;/code&gt; ) 시간) 지역 모드에서 읽지 않습니다.</target>
        </trans-unit>
        <trans-unit id="6bcf5b308aa4ed1bdc1fe48856a7ba75e0842648" translate="yes" xml:space="preserve">
          <source>Initiate a search for all non-overlapping matches to the pattern &lt;code&gt;re&lt;/code&gt; in the given &lt;code&gt;input&lt;/code&gt;. The result is a lazy range of matches generated as they are encountered in the input going left to right.</source>
          <target state="translated">주어진 &lt;code&gt;input&lt;/code&gt; 에서 &lt;code&gt;re&lt;/code&gt; 패턴과 일치하지 않는 모든 일치 항목에 대한 검색을 시작합니다 . 결과는 왼쪽에서 오른쪽으로 진행되는 입력에서 발생할 때 발생하는 게으른 범위의 일치입니다.</target>
        </trans-unit>
        <trans-unit id="39a92c1c48ec637efb7a0a17e58b57967f5754ea" translate="yes" xml:space="preserve">
          <source>Initiate the shutdown</source>
          <target state="translated">종료 시작</target>
        </trans-unit>
        <trans-unit id="505f260038380736b5ec292da3beb645bc7a02ab" translate="yes" xml:space="preserve">
          <source>Inline Assembler</source>
          <target state="translated">인라인 어셈블러</target>
        </trans-unit>
        <trans-unit id="e8c0903b87db76a205d27b465bff8acf36d3a3fc" translate="yes" xml:space="preserve">
          <source>Inline Code</source>
          <target state="translated">인라인 코드</target>
        </trans-unit>
        <trans-unit id="b60019f47df04ae92897fa912c6748a6013313fa" translate="yes" xml:space="preserve">
          <source>Inline Functions</source>
          <target state="translated">인라인 함수</target>
        </trans-unit>
        <trans-unit id="0e581275df3e295be9dbef35d1d241b50ed09352" translate="yes" xml:space="preserve">
          <source>Inline Links</source>
          <target state="translated">인라인 링크</target>
        </trans-unit>
        <trans-unit id="e928c83ba27af9a3e30934913f4f5025c9156467" translate="yes" xml:space="preserve">
          <source>Inline Status</source>
          <target state="translated">인라인 상태</target>
        </trans-unit>
        <trans-unit id="2a9bcb6f0852ea225d7f231f321da701f1352c4f" translate="yes" xml:space="preserve">
          <source>Inline assembler can be used to access hardware directly:</source>
          <target state="translated">인라인 어셈블러를 사용하여 하드웨어에 직접 액세스 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="79759f20677d34f63a3ad16ca748c0357029c9ef" translate="yes" xml:space="preserve">
          <source>Inline assembler implementation for DMD.</source>
          <target state="translated">DMD에 대한 인라인 어셈블러 구현</target>
        </trans-unit>
        <trans-unit id="8bb9331db9f6ba0e169e23c73a72b91ef379fcfb" translate="yes" xml:space="preserve">
          <source>Inline assembler is supported with the asm statement:</source>
          <target state="translated">인라인 어셈블러는 asm 문에서 지원됩니다.</target>
        </trans-unit>
        <trans-unit id="30bd67072a99e7f0e67136dac69a9f97d8fe06e6" translate="yes" xml:space="preserve">
          <source>Inline code can be written between backtick characters (`), similarly to the syntax used on GitHub, Reddit, Stack Overflow, and other websites. Both the opening and closing ` character must appear on the same line to trigger this behavior.</source>
          <target state="translated">GitHub, Reddit, Stack Overflow 및 기타 웹 사이트에서 사용되는 구문과 유사하게 백틱 문자 (`) 사이에 인라인 코드를 작성할 수 있습니다. 이 동작을 시작하려면 시작 및 끝`문자가 모두 같은 줄에 나타나야합니다.</target>
        </trans-unit>
        <trans-unit id="3a0d3f2169904e16efc469dbb314be7e91a83d62" translate="yes" xml:space="preserve">
          <source>Inline-style links enclose link text in square brackets and the link URL in parentheses. Like reference links, the URL may optionally be followed by title text wrapped in single or double quotes, or in parentheses:</source>
          <target state="translated">인라인 스타일 링크는 링크 텍스트를 대괄호로 묶고 링크 URL은 괄호로 묶습니다. 참조 링크와 마찬가지로 URL 뒤에 선택적으로 작은 따옴표 나 큰 따옴표 또는 괄호로 묶인 제목 텍스트가 올 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="59987901b798d3774e680b1f2e942cf43901da46" translate="yes" xml:space="preserve">
          <source>InlineAsmStatement &lt;code&gt;s&lt;/code&gt;</source>
          <target state="translated">InlineAsmStatement &lt;code&gt;s&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="78d80e54409073effd7ab616e62a68493fee350d" translate="yes" xml:space="preserve">
          <source>Inout Functions</source>
          <target state="translated">인아웃 기능</target>
        </trans-unit>
        <trans-unit id="e8e7165f5b963e02cdaf54a8eb17befc2421e96a" translate="yes" xml:space="preserve">
          <source>Inout types can be implicitly converted to const or inout const, but to nothing else. Other types cannot be implicitly converted to inout. Casting to or from inout is not allowed in @safe functions.</source>
          <target state="translated">입력 유형은 암시 적으로 const 또는 inout const로 변환 할 수 있지만 다른 것은 없습니다. 다른 유형은 암시 적으로 inout으로 변환 할 수 없습니다. @safe 함수에서는 inout으로 캐스팅하거나 inout에서 캐스팅 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="b568d47f2e244743b1fd7472db836ef9769c21f8" translate="yes" xml:space="preserve">
          <source>Input</source>
          <target state="translated">Input</target>
        </trans-unit>
        <trans-unit id="16ca749420dd58126c1f3f4ccf95ce2fc49387c9" translate="yes" xml:space="preserve">
          <source>Input array.</source>
          <target state="translated">입력 배열.</target>
        </trans-unit>
        <trans-unit id="805a8fb36fe255b6fb65ad6afc87bb5c87d77739" translate="yes" xml:space="preserve">
          <source>Input range primitives.</source>
          <target state="translated">입력 범위 프리미티브.</target>
        </trans-unit>
        <trans-unit id="2b5a3aca97f7c0ee924c45da0b642efd3933bcec" translate="yes" xml:space="preserve">
          <source>Input range primitives. Always present.</source>
          <target state="translated">입력 범위 프리미티브. 항상 존재합니다.</target>
        </trans-unit>
        <trans-unit id="3ea0015c09b13077d49706cf98824e19781f5a6d" translate="yes" xml:space="preserve">
          <source>InputRange &lt;code&gt;front&lt;/code&gt;</source>
          <target state="translated">입력 범위 &lt;code&gt;front&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="ea0417fdf24ea467e5d4948e4d2f763b6a7eef2b" translate="yes" xml:space="preserve">
          <source>InputRange &lt;code&gt;haystack&lt;/code&gt;</source>
          <target state="translated">InputRange &lt;code&gt;haystack&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="263a897da5a7d45d98fac35624cdf4deb7cf4411" translate="yes" xml:space="preserve">
          <source>InputRange &lt;code&gt;input&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;input&lt;/code&gt; 범위 입력</target>
        </trans-unit>
        <trans-unit id="c8a5a20feb07807120b419370d56d0cc41af44e6" translate="yes" xml:space="preserve">
          <source>InputRange &lt;code&gt;seq&lt;/code&gt;</source>
          <target state="translated">InputRange &lt;code&gt;seq&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="76ac91ede8a06926e9fd7701df246ece786ebf98" translate="yes" xml:space="preserve">
          <source>InputRange &lt;strong id=&quot;find&quot;&gt;find&lt;/strong&gt;(alias pred = &quot;a == b&quot;, InputRange, Element)(InputRange haystack, scope Element needle)</source>
          <target state="translated">InputRange &lt;strong id=&quot;find&quot;&gt;find&lt;/strong&gt; (별칭 pred = &quot;a == b&quot;, InputRange, Element) (InputRange 건초 더미, 스코프 요소 바늘)</target>
        </trans-unit>
        <trans-unit id="62294650ad3440bbcc9dfa642f50ca9b106dfc41" translate="yes" xml:space="preserve">
          <source>InputRange &lt;strong id=&quot;find&quot;&gt;find&lt;/strong&gt;(alias pred, InputRange)(InputRange haystack)</source>
          <target state="translated">InputRange &lt;strong id=&quot;find&quot;&gt;find&lt;/strong&gt; (별칭 pred, InputRange) (InputRange haystack)</target>
        </trans-unit>
        <trans-unit id="cd55b74bf8e8c901c82e7777b6c9deb713ab8571" translate="yes" xml:space="preserve">
          <source>InputRange &lt;strong id=&quot;findAmong&quot;&gt;findAmong&lt;/strong&gt;(alias pred = &quot;a == b&quot;, InputRange, ForwardRange)(InputRange seq, ForwardRange choices)</source>
          <target state="translated">InputRange &lt;strong id=&quot;findAmong&quot;&gt;findAmong&lt;/strong&gt; (별칭 : &lt;strong id=&quot;findAmong&quot;&gt;prea&lt;/strong&gt; = &quot;a == b&quot;, InputRange, ForwardRange) (InputRange seq, ForwardRange 선택)</target>
        </trans-unit>
        <trans-unit id="215e5e329de1e54df130b5fa8c6b834e564f901b" translate="yes" xml:space="preserve">
          <source>InputRange1 &lt;code&gt;r1&lt;/code&gt;</source>
          <target state="translated">입력 범위 1 &lt;code&gt;r1&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="249ee449e0f4478b44dc1191e22438bd70e851a5" translate="yes" xml:space="preserve">
          <source>InputRange1 &lt;code&gt;src&lt;/code&gt;</source>
          <target state="translated">입력 범위 1 &lt;code&gt;src&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="c677621d3536f932357d78e1812f103084e329df" translate="yes" xml:space="preserve">
          <source>InputRange2 &lt;code&gt;r2&lt;/code&gt;</source>
          <target state="translated">입력 범위 2 &lt;code&gt;r2&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="71bdacf44f1217f068320302c2f0ee3826890d58" translate="yes" xml:space="preserve">
          <source>InputRange2 &lt;code&gt;tgt&lt;/code&gt;</source>
          <target state="translated">InputRange2 &lt;code&gt;tgt&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="26853b5826e342866783ec6125630078fcc1a0ef" translate="yes" xml:space="preserve">
          <source>InputRange2 &lt;strong id=&quot;moveAll&quot;&gt;moveAll&lt;/strong&gt;(InputRange1, InputRange2)(InputRange1 src, InputRange2 tgt)</source>
          <target state="translated">InputRange2 &lt;strong id=&quot;moveAll&quot;&gt;moveAll&lt;/strong&gt; (InputRange1, InputRange2) (InputRange1 src, InputRange2 tgt)</target>
        </trans-unit>
        <trans-unit id="a6d9a6e40c7583de17b5334cea373d1a6f012a01" translate="yes" xml:space="preserve">
          <source>InputRangeObject!R &lt;strong id=&quot;inputRangeObject&quot;&gt;inputRangeObject&lt;/strong&gt;(R)(R range)</source>
          <target state="translated">InputRangeObject! R &lt;strong id=&quot;inputRangeObject&quot;&gt;inputRangeObject&lt;/strong&gt; (R) (R 범위)</target>
        </trans-unit>
        <trans-unit id="54690a68ec01cec2015c43085af22e3b7ee1fd11" translate="yes" xml:space="preserve">
          <source>Inscriptional Pahlavi</source>
          <target state="translated">비문 팔라 비</target>
        </trans-unit>
        <trans-unit id="fef5264f6a30e6dcae96d08ee848ad4b86a2a3a3" translate="yes" xml:space="preserve">
          <source>Inscriptional Parthian</source>
          <target state="translated">비문 파르티아 어</target>
        </trans-unit>
        <trans-unit id="7e7e7b17b20df161139e8ef284689d406182e357" translate="yes" xml:space="preserve">
          <source>Inscriptional_Pahlavi</source>
          <target state="translated">Inscriptional_Pahlavi</target>
        </trans-unit>
        <trans-unit id="c38bdc08ad33b7372f9f91847cd5f574862ccea5" translate="yes" xml:space="preserve">
          <source>Inscriptional_Parthian</source>
          <target state="translated">Inscriptional_Parthian</target>
        </trans-unit>
        <trans-unit id="3c215b42cade3b7a8b98554cb505256252393b54" translate="yes" xml:space="preserve">
          <source>Insert a backtick</source>
          <target state="translated">백틱 삽입</target>
        </trans-unit>
        <trans-unit id="138a4c6393efa857920b23a60fdca2a6694f91d0" translate="yes" xml:space="preserve">
          <source>Insert a dollar sign</source>
          <target state="translated">달러 기호 삽입</target>
        </trans-unit>
        <trans-unit id="cecb3ad08db064401b3027bd8bdfecfd625474f6" translate="yes" xml:space="preserve">
          <source>Insert a left parenthesis</source>
          <target state="translated">왼쪽 괄호 삽입</target>
        </trans-unit>
        <trans-unit id="cbdb76fffabdf5eb3b5ae5b2ff4c5c2a9ba7b666" translate="yes" xml:space="preserve">
          <source>Insert a line feed (newline)</source>
          <target state="translated">줄 바꿈 삽입 (줄 바꿈)</target>
        </trans-unit>
        <trans-unit id="c0306b572d5a694e3a6dd42bca0200f018f85238" translate="yes" xml:space="preserve">
          <source>Insert a range of elements in the container. Note that this does not invalidate any ranges currently iterating the container.</source>
          <target state="translated">컨테이너에 다양한 요소를 삽입하십시오. 현재 컨테이너를 반복하는 범위는 무효화되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="1a917cf9fad45f42c5f9d737b6e96f9575d41832" translate="yes" xml:space="preserve">
          <source>Insert a right parenthesis</source>
          <target state="translated">오른쪽 괄호 삽입</target>
        </trans-unit>
        <trans-unit id="327083c1ff82497e1f646caa621a2ae2d82389b4" translate="yes" xml:space="preserve">
          <source>Insert a single element in the container. Note that this does not invalidate any ranges currently iterating the container.</source>
          <target state="translated">컨테이너에 단일 요소를 삽입하십시오. 현재 컨테이너를 반복하는 범위는 무효화되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="42c8592347a2b25e78dc2c81426ea39331669868" translate="yes" xml:space="preserve">
          <source>Insert current item from the source into the target.</source>
          <target state="translated">소스에서 대상으로 현재 항목을 삽입하십시오.</target>
        </trans-unit>
        <trans-unit id="d776dcf131b9f5a24feff6fc21b29e6dcf5da88f" translate="yes" xml:space="preserve">
          <source>Insert finally block calls when doing a goto from inside a try block to outside. Done after blocks are generated because then we know all the edges of the graph, but before the Bpred's are computed. Only for EH_DWARF exception unwinding.</source>
          <target state="translated">try 블록 내부에서 외부로 이동을 수행 할 때 finally 블록 호출을 삽입하십시오. 블록이 생성 된 후 그래프의 모든 가장자리를 알고 있지만 Bpred가 계산되기 전에 완료되었습니다. EH_DWARF 예외 풀기에만 해당됩니다.</target>
        </trans-unit>
        <trans-unit id="5471bf7c7cfa66ea6e595c4758d088cf1cff366e" translate="yes" xml:space="preserve">
          <source>Insert gotos to finally blocks when doing a return or goto from inside a try block to outside. Done after blocks are generated because then we know all the edges of the graph, but before the Bpred's are computed. Only for functions with no exception handling. Very similar to insertFinallyBlockCalls().</source>
          <target state="translated">try 블록 내부에서 외부로 돌아가거나 goto 할 때 gotos를 finally 블록에 삽입하십시오. 블록이 생성 된 후 그래프의 모든 가장자리를 알고 있지만 Bpred가 계산되기 전에 완료되었습니다. 예외 처리가없는 기능에만 해당됩니다. insertFinallyBlockCalls ()와 매우 유사합니다.</target>
        </trans-unit>
        <trans-unit id="dac79eb40ab7303630f93c4973c9239f694c7c19" translate="yes" xml:space="preserve">
          <source>Insert item into list at nth position.</source>
          <target state="translated">n 번째 위치에 항목을 목록에 삽입하십시오.</target>
        </trans-unit>
        <trans-unit id="e157f7049edabd9484326a29b8f9b52a72eaeb25" translate="yes" xml:space="preserve">
          <source>Inserted in place of invalid UTF sequences.</source>
          <target state="translated">유효하지 않은 UTF 시퀀스 대신 삽입되었습니다.</target>
        </trans-unit>
        <trans-unit id="143f825d20ba520107ed764caaeba3c49e097300" translate="yes" xml:space="preserve">
          <source>Inserting if not present</source>
          <target state="translated">없는 경우 삽입</target>
        </trans-unit>
        <trans-unit id="30a6615838d01663d72779532f25d77de2451cfa" translate="yes" xml:space="preserve">
          <source>Insertion failed because database is full</source>
          <target state="translated">데이터베이스가 가득 차서 삽입 실패</target>
        </trans-unit>
        <trans-unit id="20cdd78769ce43b7cb858f988154e98a6f228025" translate="yes" xml:space="preserve">
          <source>Insertion of array bounds checking code at runtime may be turned off with a compiler switch &lt;a href=&quot;https://dlang.org/dmd.html#switch-boundscheck&quot;&gt;&lt;code&gt;-boundscheck&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">런타임시 배열 범위 검사 코드 삽입은 컴파일러 switch- &lt;a href=&quot;https://dlang.org/dmd.html#switch-boundscheck&quot;&gt; &lt;code&gt;-boundscheck&lt;/code&gt; &lt;/a&gt; 사용하여 해제 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="4bdc47adb0591faa30b8ba1f2040d211a501160c" translate="yes" xml:space="preserve">
          <source>Insertion of array bounds checking code at runtime should be turned on and off with a compile time switch.</source>
          <target state="translated">런타임시 배열 범위 검사 코드 삽입은 컴파일 타임 스위치를 사용하여 켜고 꺼야합니다.</target>
        </trans-unit>
        <trans-unit id="0fe401e132558c29c269b7fd6cffd6a1dc02d7db" translate="yes" xml:space="preserve">
          <source>Inserts &lt;code&gt;stuff&lt;/code&gt; (which must be an input range or any number of implicitly convertible items) in &lt;code&gt;array&lt;/code&gt; at position &lt;code&gt;pos&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;pos&lt;/code&gt; 위치의 &lt;code&gt;array&lt;/code&gt; 에 &lt;code&gt;stuff&lt;/code&gt; (입력 범위 또는 암묵적으로 변환 가능한 임의의 수의 항목이어야 함)을 삽입합니다 .</target>
        </trans-unit>
        <trans-unit id="ccbf9d19e58cf1e67a852d50890252788f63b174" translate="yes" xml:space="preserve">
          <source>Inserts &lt;code&gt;stuff&lt;/code&gt; after range &lt;code&gt;r&lt;/code&gt;, which must be a non-empty range previously extracted from this container.</source>
          <target state="translated">삽입은 &lt;code&gt;stuff&lt;/code&gt; 범위 후 &lt;code&gt;r&lt;/code&gt; 이전에이 컨테이너에서 추출한 비어 있지 않은 범위에 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="bbcf5a5de0747fda77b1e1e1643549b4e06e5bb8" translate="yes" xml:space="preserve">
          <source>Inserts &lt;code&gt;stuff&lt;/code&gt; after range &lt;code&gt;r&lt;/code&gt;, which must be a range previously extracted from this container. Given that all ranges for a list end at the end of the list, this function essentially appends to the list and uses &lt;code&gt;r&lt;/code&gt; as a potentially fast way to reach the last node in the list. Ideally &lt;code&gt;r&lt;/code&gt; is positioned near or at the last element of the list.</source>
          <target state="translated">범위 &lt;code&gt;r&lt;/code&gt; 뒤에 &lt;code&gt;stuff&lt;/code&gt; 을 삽입합니다 .이 컨테이너는 이전에이 컨테이너에서 추출 된 범위 여야합니다. 리스트의 모든 범위가리스트의 끝에서 끝나는 것을 감안할 때,이 함수는 본질적으로리스트에 추가하고 &lt;code&gt;r&lt;/code&gt; 을 리스트 의 마지막 노드에 도달 할 수있는 빠른 방법으로 사용합니다. 이상적으로 &lt;code&gt;r&lt;/code&gt; 은 목록의 마지막 요소 근처 또는 마지막 요소에 위치합니다.</target>
        </trans-unit>
        <trans-unit id="6f06bb00c64490bdfd0684d68ce1e50ed8931cf5" translate="yes" xml:space="preserve">
          <source>Inserts &lt;code&gt;stuff&lt;/code&gt; before, after, or instead range &lt;code&gt;r&lt;/code&gt;, which must be a valid range previously extracted from this array. &lt;code&gt;stuff&lt;/code&gt; can be a value convertible to &lt;code&gt;T&lt;/code&gt; or a range of objects convertible to &lt;code&gt;T&lt;/code&gt;. Both stable and non-stable version behave the same and guarantee that ranges iterating over the array are never invalidated.</source>
          <target state="translated">인서트 &lt;code&gt;stuff&lt;/code&gt; 전후, 또는 대신 범위 &lt;code&gt;r&lt;/code&gt; 이전이 어레이로부터 추출 된 유효 범위이어야. &lt;code&gt;stuff&lt;/code&gt; 는 &lt;code&gt;T&lt;/code&gt; 로 변환 가능한 값 이거나 &lt;code&gt;T&lt;/code&gt; 로 변환 가능한 객체 범위 일 수 있습니다 . 안정 버전과 비 안정 버전은 모두 동일하게 작동하며 어레이에서 반복되는 범위가 무효화되지 않도록 보장합니다.</target>
        </trans-unit>
        <trans-unit id="f08fcf4de04b5d69b89946f0b954703523fa90fc" translate="yes" xml:space="preserve">
          <source>Inserts &lt;code&gt;stuff&lt;/code&gt; before, after, or instead range &lt;code&gt;r&lt;/code&gt;, which must be a valid range previously extracted from this array. &lt;code&gt;stuff&lt;/code&gt; can be a value convertible to &lt;code&gt;bool&lt;/code&gt; or a range of objects convertible to &lt;code&gt;bool&lt;/code&gt;. Both stable and non-stable version behave the same and guarantee that ranges iterating over the array are never invalidated.</source>
          <target state="translated">인서트 &lt;code&gt;stuff&lt;/code&gt; 전후, 또는 대신 범위 &lt;code&gt;r&lt;/code&gt; 이전이 어레이로부터 추출 된 유효 범위이어야. &lt;code&gt;stuff&lt;/code&gt; 에 변환 가능한 값이 될 수 &lt;code&gt;bool&lt;/code&gt; 로 하거나 전환 개체의 범위 &lt;code&gt;bool&lt;/code&gt; . 안정 버전과 비 안정 버전은 모두 동일하게 작동하며 어레이에서 반복되는 범위가 무효화되지 않도록 보장합니다.</target>
        </trans-unit>
        <trans-unit id="dcb7963cdc25fdee24c788729e6be8dd4f7e3c27" translate="yes" xml:space="preserve">
          <source>Inserts &lt;code&gt;stuff&lt;/code&gt; to the front of the container. &lt;code&gt;stuff&lt;/code&gt; can be a value convertible to &lt;code&gt;T&lt;/code&gt; or a range of objects convertible to &lt;code&gt;T&lt;/code&gt;. The stable version behaves the same, but guarantees that ranges iterating over the container are never invalidated.</source>
          <target state="translated">컨테이너 앞에 &lt;code&gt;stuff&lt;/code&gt; 을 넣 습니다 . &lt;code&gt;stuff&lt;/code&gt; 는 &lt;code&gt;T&lt;/code&gt; 로 변환 가능한 값 이거나 &lt;code&gt;T&lt;/code&gt; 로 변환 가능한 객체 범위 일 수 있습니다 . 안정적인 버전은 동일하게 작동하지만 컨테이너를 반복하는 범위가 무효화되지 않도록 보장합니다.</target>
        </trans-unit>
        <trans-unit id="70b0bd082af545b88841219b95946def84b1bde5" translate="yes" xml:space="preserve">
          <source>Inserts &lt;code&gt;stuff&lt;/code&gt; to the front/back of the container. &lt;code&gt;stuff&lt;/code&gt; can be a value convertible to &lt;code&gt;T&lt;/code&gt; or a range of objects convertible to &lt;code&gt;T&lt;/code&gt;. The stable version behaves the same, but guarantees that ranges iterating over the container are never invalidated.</source>
          <target state="translated">삽입은 &lt;code&gt;stuff&lt;/code&gt; 다시 용기 / 전면. &lt;code&gt;stuff&lt;/code&gt; 는 &lt;code&gt;T&lt;/code&gt; 로 변환 가능한 값 이거나 &lt;code&gt;T&lt;/code&gt; 로 변환 가능한 객체 범위 일 수 있습니다 . 안정적인 버전은 동일하게 작동하지만 컨테이너를 반복하는 범위가 무효화되지 않도록 보장합니다.</target>
        </trans-unit>
        <trans-unit id="98d4bdcdc44b42cf7f92f1b1fa3789c2aceb532f" translate="yes" xml:space="preserve">
          <source>Inserts &lt;code&gt;v&lt;/code&gt; at the back of &lt;code&gt;c&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;c&lt;/code&gt; 뒤에 &lt;code&gt;v&lt;/code&gt; 를 삽입합니다 .</target>
        </trans-unit>
        <trans-unit id="314547f0dd75063020e998c66bb1c080e7cc353d" translate="yes" xml:space="preserve">
          <source>Inserts &lt;code&gt;v&lt;/code&gt; at the front of &lt;code&gt;c&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;c&lt;/code&gt; 앞에 &lt;code&gt;v&lt;/code&gt; 를 삽입합니다 .</target>
        </trans-unit>
        <trans-unit id="9b4118de001ef07d96ca9dc875bb736525602b3c" translate="yes" xml:space="preserve">
          <source>Inserts &lt;code&gt;value&lt;/code&gt; into the store. If the underlying store is a range and &lt;code&gt;length == capacity&lt;/code&gt;, throws an exception.</source>
          <target state="translated">상점에 &lt;code&gt;value&lt;/code&gt; 를 삽입합니다 . 기본 저장소가 range and &lt;code&gt;length == capacity&lt;/code&gt; 인 경우 예외가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="7a861229c3ddec4f67c4aba3fc949701aaf45a21" translate="yes" xml:space="preserve">
          <source>Inserts &lt;code&gt;x&lt;/code&gt; in &lt;code&gt;c&lt;/code&gt; at a position (or positions) chosen by &lt;code&gt;c&lt;/code&gt;.</source>
          <target state="translated">삽입물 &lt;code&gt;x&lt;/code&gt; 에서 &lt;code&gt;c&lt;/code&gt; 가 선택된 위치 (또는 위치)에 &lt;code&gt;c&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="804f9143c06ffa0aedcfc5172722337eadf6df16" translate="yes" xml:space="preserve">
          <source>Inserts a blank line.</source>
          <target state="translated">빈 줄을 삽입합니다.</target>
        </trans-unit>
        <trans-unit id="7a0447d3d52b9161fad5aa788df5312d0c9f70f2" translate="yes" xml:space="preserve">
          <source>Inserts a comment in the output.</source>
          <target state="translated">출력에 주석을 삽입합니다.</target>
        </trans-unit>
        <trans-unit id="7a683c9546bcec22da2c836a994b3f342b2d3aa0" translate="yes" xml:space="preserve">
          <source>Inserts a full load/store memory fence (on platforms that need it). This ensures that all loads and stores before a call to this function are executed before any loads and stores after the call.</source>
          <target state="translated">전체로드 / 저장 메모리 펜스를 삽입합니다 (필요한 플랫폼에서). 이를 통해이 기능에 대한 호출 이전의 모든로드 및 저장이 호출 후로드 및 저장 전에 실행됩니다.</target>
        </trans-unit>
        <trans-unit id="a94c7ccab5212d83d09585607543df4cd0d7b0e8" translate="yes" xml:space="preserve">
          <source>Inserts a separator between overloads of a given name.</source>
          <target state="translated">주어진 이름의 과부하 사이에 구분 기호를 삽입합니다.</target>
        </trans-unit>
        <trans-unit id="aa15c23194538bcbb65217c20c49d6e178298d1b" translate="yes" xml:space="preserve">
          <source>Inserts inline code.</source>
          <target state="translated">인라인 코드를 삽입합니다.</target>
        </trans-unit>
        <trans-unit id="be7c29e597d6483bb5cc792a0734c8430284107e" translate="yes" xml:space="preserve">
          <source>Inserts into an existing array at a given position.</source>
          <target state="translated">주어진 위치에서 기존 배열에 삽입합니다.</target>
        </trans-unit>
        <trans-unit id="b2e6a38a54ba983c83824eb96e11fa99e1fb236e" translate="yes" xml:space="preserve">
          <source>Inserts the separator symbols ',' every</source>
          <target state="translated">구분 기호 ','마다 삽입</target>
        </trans-unit>
        <trans-unit id="801258f3c2858353c18f16295039e48c4b8fb913" translate="yes" xml:space="preserve">
          <source>Inserts the specified elements at the back of the array. &lt;code&gt;stuff&lt;/code&gt; can be a value convertible to &lt;code&gt;T&lt;/code&gt; or a range of objects convertible to &lt;code&gt;T&lt;/code&gt;.</source>
          <target state="translated">지정된 요소를 배열의 뒷면에 삽입합니다. &lt;code&gt;stuff&lt;/code&gt; 는 &lt;code&gt;T&lt;/code&gt; 로 변환 가능한 값 이거나 &lt;code&gt;T&lt;/code&gt; 로 변환 가능한 객체 범위 일 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="14cde1bdd1549aef1d369341e6d66efc2807a4bc" translate="yes" xml:space="preserve">
          <source>Inserts the specified elements at the back of the array. &lt;code&gt;stuff&lt;/code&gt; can be a value convertible to &lt;code&gt;bool&lt;/code&gt; or a range of objects convertible to &lt;code&gt;bool&lt;/code&gt;.</source>
          <target state="translated">지정된 요소를 배열의 뒷면에 삽입합니다. &lt;code&gt;stuff&lt;/code&gt; 에 변환 가능한 값이 될 수 &lt;code&gt;bool&lt;/code&gt; 로 하거나 전환 개체의 범위 &lt;code&gt;bool&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1d605a6236091ada3048879c73c926d0efb2298d" translate="yes" xml:space="preserve">
          <source>Inside a compound format specifier, strings and characters are escaped automatically. To avoid this behavior, add &lt;b&gt;'-'&lt;/b&gt; flag to &lt;code&gt;&quot;%(&quot;&lt;/code&gt;.</source>
          <target state="translated">복합 형식 지정자 내에서 문자열과 문자는 자동으로 이스케이프됩니다. 이 동작을 피하려면 &lt;b&gt;'-'&lt;/b&gt; 플래그를 &lt;code&gt;&quot;%(&quot;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="aa6dfe54274ed1710b82f903b6abd73713a2f05a" translate="yes" xml:space="preserve">
          <source>Instance Variables</source>
          <target state="translated">인스턴스 변수</target>
        </trans-unit>
        <trans-unit id="6dcf70f56aa9632f46bb219a5e2ab80717bd81f1" translate="yes" xml:space="preserve">
          <source>Instance shared by all callers.</source>
          <target state="translated">모든 발신자가 공유 한 인스턴스입니다.</target>
        </trans-unit>
        <trans-unit id="1d560aaea91ff74c40b9ba925224eb2e9cab5714" translate="yes" xml:space="preserve">
          <source>Instances of class objects are created with a &lt;a href=&quot;expression#NewExpression&quot;&gt;&lt;i&gt;NewExpression&lt;/i&gt;&lt;/a&gt;:</source>
          <target state="translated">클래스 객체의 인스턴스는 &lt;a href=&quot;expression#NewExpression&quot;&gt;&lt;i&gt;NewExpression&lt;/i&gt;&lt;/a&gt; 으로 생성됩니다 .</target>
        </trans-unit>
        <trans-unit id="0e15b22639879009392385cbbbd0e07778e511d1" translate="yes" xml:space="preserve">
          <source>Instances of this object are constructed via calls to &lt;code&gt;regex&lt;/code&gt;. This is an intended form for caching and storage of frequently used regular expressions.</source>
          <target state="translated">이 객체의 인스턴스는 &lt;code&gt;regex&lt;/code&gt; 호출을 통해 구성됩니다 . 이것은 자주 사용되는 정규식을 캐싱하고 저장하기위한 형식입니다.</target>
        </trans-unit>
        <trans-unit id="9c373dca3c1b04cc6629e642fffbe62b3a9fe4e5" translate="yes" xml:space="preserve">
          <source>Instantiate a new &lt;code&gt;DebugCondition&lt;/code&gt;</source>
          <target state="translated">새로운 &lt;code&gt;DebugCondition&lt;/code&gt; 인스턴스화</target>
        </trans-unit>
        <trans-unit id="3822674a7468f752517c5bf52d226dd0137e7bff" translate="yes" xml:space="preserve">
          <source>Instantiate a new &lt;code&gt;VersionCondition&lt;/code&gt;</source>
          <target state="translated">새 &lt;code&gt;VersionCondition&lt;/code&gt; 인스턴스화</target>
        </trans-unit>
        <trans-unit id="152f1a2b9d65da1e9f82b24f153f213ef690987a" translate="yes" xml:space="preserve">
          <source>Instantiates the given template with the given parameters.</source>
          <target state="translated">주어진 매개 변수로 주어진 템플리트를 인스턴스화합니다.</target>
        </trans-unit>
        <trans-unit id="4a327f215e80d73f8ee4464a28c7b7c009445a31" translate="yes" xml:space="preserve">
          <source>Instantiation Scope</source>
          <target state="translated">인스턴스화 범위</target>
        </trans-unit>
        <trans-unit id="93486e626687f1b1676b1b49e1fd6518a0b454b0" translate="yes" xml:space="preserve">
          <source>Instantiation information</source>
          <target state="translated">인스턴스화 정보</target>
        </trans-unit>
        <trans-unit id="dac2b060e0095872817c2470eb8b53d6b6180adb" translate="yes" xml:space="preserve">
          <source>Instatiates a new function call expression</source>
          <target state="translated">새로운 함수 호출 표현식을 나타냅니다</target>
        </trans-unit>
        <trans-unit id="10f4428424192063dd20e3361c36aa4d16de843c" translate="yes" xml:space="preserve">
          <source>Instead:</source>
          <target state="translated">Instead:</target>
        </trans-unit>
        <trans-unit id="a0905dbb5b366516614f7115449ef89eac51f289" translate="yes" xml:space="preserve">
          <source>Instruct libcurl to not use any signal/alarm handlers, even when using timeouts. This option is useful for multi-threaded applications. See libcurl-the-guide for more background information.</source>
          <target state="translated">타임 아웃을 사용할 때도 libcurl이 신호 / 알람 핸들러를 사용하지 않도록 지시하십시오. 이 옵션은 다중 스레드 응용 프로그램에 유용합니다. 자세한 배경 정보는 libcurl-the-guide를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="93df39339f21a04f493609200c104dc46ba84fa9" translate="yes" xml:space="preserve">
          <source>Instruct libcurl to use a smaller receive buffer</source>
          <target state="translated">더 작은 수신 버퍼를 사용하도록 libcurl에 지시</target>
        </trans-unit>
        <trans-unit id="4e856d175354403c672463be1daf8914ce0f2b64" translate="yes" xml:space="preserve">
          <source>Instruct the thread module, when initialized, to use a different set of signals besides SIGUSR1 and SIGUSR2 for suspension and resumption of threads. This function should be called at most once, prior to thread_init(). This function is Posix-only.</source>
          <target state="translated">스레드 모듈이 초기화되면 스레드의 일시 중단 및 재개를 위해 SIGUSR1 및 SIGUSR2 이외의 다른 신호 세트를 사용하도록 지시하십시오. 이 함수는 thread_init () 이전에 최대 한 번 호출되어야합니다. 이 기능은 Posix 전용입니다.</target>
        </trans-unit>
        <trans-unit id="ea729c0363a2bc9c76992c1a2e2bf3e5220ecc9e" translate="yes" xml:space="preserve">
          <source>Instructions are selected from the target architecture to implement the semantics of the program. The typical result will be an object file, suitable for input to a linker.</source>
          <target state="translated">프로그램의 의미를 구현하기 위해 대상 아키텍처에서 명령이 선택됩니다. 일반적인 결과는 링커에 입력하기에 적합한 객체 파일입니다.</target>
        </trans-unit>
        <trans-unit id="492ad7a25e9093c89a88ab9eae0481a3d6d480b5" translate="yes" xml:space="preserve">
          <source>IntRange &lt;strong id=&quot;getIntRange&quot;&gt;getIntRange&lt;/strong&gt;(Expression e);</source>
          <target state="translated">IntRange &lt;strong id=&quot;getIntRange&quot;&gt;getIntRange&lt;/strong&gt; (식 e);</target>
        </trans-unit>
        <trans-unit id="562d27265f4183bba6926e62be0c6ce57f7e2097" translate="yes" xml:space="preserve">
          <source>Integer Literals</source>
          <target state="translated">정수 리터럴</target>
        </trans-unit>
        <trans-unit id="bd777b837ba4f419f4b02435e27128be81023ef2" translate="yes" xml:space="preserve">
          <source>Integer Promotions</source>
          <target state="translated">정수 프로모션</target>
        </trans-unit>
        <trans-unit id="9568ecb6786424f8ca136701942b4f686fc642d2" translate="yes" xml:space="preserve">
          <source>Integer Promotions are conversions of the following types:</source>
          <target state="translated">정수 프로모션은 다음 유형의 변환입니다.</target>
        </trans-unit>
        <trans-unit id="db47076f1ac16cea001c1edc5817f57fa5127f93" translate="yes" xml:space="preserve">
          <source>Integer Whole Number: (byte, ubyte, short, ushort, int, uint, long, and ulong) ['+'|'-']digit(s)[U|L|UL]</source>
          <target state="translated">정수 정수 : (바이트, ubyte, short, ushort, int, uint, long 및 ulong) [ '+'| '-'] 자리수 [U | L | UL]</target>
        </trans-unit>
        <trans-unit id="2c1da0fff670105eb87d89c45a8168527ceeec25" translate="yes" xml:space="preserve">
          <source>Integer comparison operators</source>
          <target state="translated">정수 비교 연산자</target>
        </trans-unit>
        <trans-unit id="b5ccca1ae24a500cd1c22e7e4ca7606c1848c22a" translate="yes" xml:space="preserve">
          <source>Integer comparisons</source>
          <target state="translated">정수 비교</target>
        </trans-unit>
        <trans-unit id="343b406e188c4782bf6c33cf9f047756fbc9ecb9" translate="yes" xml:space="preserve">
          <source>Integer comparisons happen when both operands are integral types.</source>
          <target state="translated">두 피연산자가 모두 정수 유형 인 경우 정수 비교가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="adcbb9dbe2818c1f42e7e40cd4eb69ffc2847624" translate="yes" xml:space="preserve">
          <source>Integer values cannot be implicitly converted to another type that cannot represent the integer bit pattern after integral promotion. For example:</source>
          <target state="translated">정수 값은 정수 승격 후 정수 비트 패턴을 나타낼 수없는 다른 유형으로 암시 적으로 변환 될 수 없습니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="2745c9287a60962527a82479b71c8fcdcdfee9b5" translate="yes" xml:space="preserve">
          <source>IntegerExp &lt;strong id=&quot;literal&quot;&gt;literal&lt;/strong&gt;(int v)();</source>
          <target state="translated">IntegerExp &lt;strong id=&quot;literal&quot;&gt;리터럴&lt;/strong&gt; (int v) ();</target>
        </trans-unit>
        <trans-unit id="9ef2cfdc220f6cdcf3fe63e63ff8a17f54977fca" translate="yes" xml:space="preserve">
          <source>IntegerExpression</source>
          <target state="translated">IntegerExpression</target>
        </trans-unit>
        <trans-unit id="17c52e79fc66bb6ecd61f1fe24bcec43e30c42c1" translate="yes" xml:space="preserve">
          <source>IntegerLiteral</source>
          <target state="translated">IntegerLiteral</target>
        </trans-unit>
        <trans-unit id="36d10f6bb46fb8657ec9f18b1e3a960789ae3c76" translate="yes" xml:space="preserve">
          <source>Integers (that may be constant-folded).</source>
          <target state="translated">정수 (정수로 접힐 수 있음).</target>
        </trans-unit>
        <trans-unit id="f69d4a47975b227c4173e0f25508229d914b2ec7" translate="yes" xml:space="preserve">
          <source>Integers and floating point values can be implicitly converted to their vector equivalents:</source>
          <target state="translated">정수 및 부동 소수점 값은 암시 적으로 벡터와 동등한 것으로 변환 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="85eae330c4b91b44cc2722cee1dc4a35c6511dee" translate="yes" xml:space="preserve">
          <source>Integers can be immediately followed by one &amp;lsquo;L&amp;rsquo; or one of &amp;lsquo;u&amp;rsquo; or &amp;lsquo;U&amp;rsquo; or both. Note that there is no &amp;lsquo;l&amp;rsquo; suffix.</source>
          <target state="translated">정수 바로 뒤에 하나의 'L'또는 'u'또는 'U'중 하나 또는 둘 다가 올 수 있습니다. 'l'접미사가 없습니다.</target>
        </trans-unit>
        <trans-unit id="78c49e8c1cc448a9049ab277bc8754ecd4237b78" translate="yes" xml:space="preserve">
          <source>Integers can be specified in decimal, binary, or hexadecimal.</source>
          <target state="translated">정수는 10 진수, 2 진수 또는 16 진수로 지정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2f0a498505f60eef0691bff5f687040cecb8e8a2" translate="yes" xml:space="preserve">
          <source>Integers can have embedded &amp;lsquo;_&amp;rsquo; characters, which are ignored.</source>
          <target state="translated">정수는 '_'문자를 포함 할 수 있으며 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="e97fd09a5e159320944c7a6e53ff8dac7ae91693" translate="yes" xml:space="preserve">
          <source>Integral arithmetic operators operate on fixed width types. Results that are not representable in those fixed widths are silently truncated to fit. This module offers integral arithmetic primitives that produce the same results, but set an 'overflow' flag when such truncation occurs. The setting is sticky, meaning that numerous operations can be cascaded and then the flag need only be checked at the end. Whether the operation is signed or unsigned is indicated by an 's' or 'u' suffix, respectively. While this could be achieved without such suffixes by using overloading on the signedness of the types, the suffix makes it clear which is happening without needing to examine the types.</source>
          <target state="translated">정수 산술 연산자는 고정 너비 유형에서 작동합니다. 고정 너비로 ​​표현할 수없는 결과는 자동으로 잘립니다. 이 모듈은 동일한 결과를 생성하지만 이러한 잘림이 발생할 때 '오버플로'플래그를 설정하는 필수 산술 기본 형식을 제공합니다. 이 설정은 고정적이므로 여러 작업을 캐스케이드 할 수 있으며 마지막에 플래그 만 확인하면됩니다. 작업의 서명 여부는 각각 's'또는 'u'접미사로 표시됩니다. 이러한 유형의 부호에 과부하를 사용하여 이러한 접미사없이이를 달성 할 수 있지만, 접미사는 유형을 조사 할 필요없이 발생하는 부분을 명확하게합니다.</target>
        </trans-unit>
        <trans-unit id="6c054c378c65fd28ca92392142534a3f43340caf" translate="yes" xml:space="preserve">
          <source>Integral ranges</source>
          <target state="translated">적분 범위</target>
        </trans-unit>
        <trans-unit id="3c327fe3bc8ca1ef616b394085c0f88695904ee8" translate="yes" xml:space="preserve">
          <source>Integral types will remain the same sizes between 32 and 64 bit code.</source>
          <target state="translated">정수 유형은 32 비트와 64 비트 코드 사이에서 동일한 크기로 유지됩니다.</target>
        </trans-unit>
        <trans-unit id="58ee21eb085c257d8a08439c9aa7bd9d6570255b" translate="yes" xml:space="preserve">
          <source>Integrals</source>
          <target state="translated">Integrals</target>
        </trans-unit>
        <trans-unit id="304d073445766b9e99ba6213d6788d69fbbe285d" translate="yes" xml:space="preserve">
          <source>Integrals are formatted like &lt;a href=&quot;core_stdc_stdio#printf&quot;&gt;&lt;code&gt;core.stdc.stdio.printf&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">적분은 &lt;a href=&quot;core_stdc_stdio#printf&quot;&gt; &lt;code&gt;core.stdc.stdio.printf&lt;/code&gt; &lt;/a&gt; 와 같은 형식 입니다.</target>
        </trans-unit>
        <trans-unit id="20aeee70fc77c214f263c77b05117e3b20686b33" translate="yes" xml:space="preserve">
          <source>Intel Atom 230/330 (family 6, model 0x1C) is an in-order core.</source>
          <target state="translated">Intel Atom 230/330 (패밀리 6, 모델 0x1C)은 주문형 코어입니다.</target>
        </trans-unit>
        <trans-unit id="25a734a01cad152ff48222d53e7362444f3ac6cd" translate="yes" xml:space="preserve">
          <source>Intel NetBurst (Pentium 4, Pentium D).</source>
          <target state="translated">Intel NetBurst (Pentium 4, Pentium D).</target>
        </trans-unit>
        <trans-unit id="40d218fe001ffffff82fbf964a99f28c6e816245" translate="yes" xml:space="preserve">
          <source>Intel P6 (PentiumPro, PII, PIII, PM, Core, Core2).</source>
          <target state="translated">Intel P6 (PentiumPro, PII, PIII, PM, Core, Core2).</target>
        </trans-unit>
        <trans-unit id="ffc1549d5dca52e99aa4ab17a1e6e08f96cd5245" translate="yes" xml:space="preserve">
          <source>Intel and AMD 32-bit processors</source>
          <target state="translated">인텔 및 AMD 32 비트 프로세서</target>
        </trans-unit>
        <trans-unit id="3eaebee622e08211c80a68d4d6c79b54e2adb573" translate="yes" xml:space="preserve">
          <source>Intel and AMD 64-bit processors</source>
          <target state="translated">인텔 및 AMD 64 비트 프로세서</target>
        </trans-unit>
        <trans-unit id="d9d20cde548a0781b6cf33434f83eb6eb5ef95f8" translate="yes" xml:space="preserve">
          <source>Intended as the range equivalent of the Unix &lt;a href=&quot;http://en.wikipedia.org/wiki/Tail_%28Unix%29&quot;&gt;tail&lt;/a&gt; utility. When the length of &lt;code&gt;range&lt;/code&gt; is less than or equal to &lt;code&gt;_n&lt;/code&gt;, &lt;code&gt;range&lt;/code&gt; is returned as-is.</source>
          <target state="translated">유닉스 &lt;a href=&quot;http://en.wikipedia.org/wiki/Tail_%28Unix%29&quot;&gt;테일&lt;/a&gt; 유틸리티 와 동등한 범위로 사용됩니다. &lt;code&gt;range&lt;/code&gt; 의 길이 가 &lt;code&gt;_n&lt;/code&gt; 보다 작거나 같은 경우 &lt;code&gt;range&lt;/code&gt; 는 그대로 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="7b4db7ef1fa23cfb5e115a2a2c89d46a6a2ebc4a" translate="yes" xml:space="preserve">
          <source>Interface</source>
          <target state="translated">Interface</target>
        </trans-unit>
        <trans-unit id="d88c1e8acf6c80eddca147502d3048d176708e8b" translate="yes" xml:space="preserve">
          <source>Interface for a bidirectional range of type &lt;code&gt;E&lt;/code&gt;.</source>
          <target state="translated">유형 &lt;code&gt;E&lt;/code&gt; 의 양방향 범위에 대한 인터페이스 .</target>
        </trans-unit>
        <trans-unit id="d0e1da15b0eee348c354776c7e919fb0b891bd0d" translate="yes" xml:space="preserve">
          <source>Interface for a finite random access range of type &lt;code&gt;E&lt;/code&gt;.</source>
          <target state="translated">유형 &lt;code&gt;E&lt;/code&gt; 의 유한 랜덤 액세스 범위에 대한 인터페이스 .</target>
        </trans-unit>
        <trans-unit id="7a634a284850ac6bc64c6899e29c994e3e0d76a1" translate="yes" xml:space="preserve">
          <source>Interface for a forward range of type &lt;code&gt;E&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;E&lt;/code&gt; 타입의 순방향 범위를위한 인터페이스 .</target>
        </trans-unit>
        <trans-unit id="9a821a67cbe42a25dc97be41d2bf278fa2b3f8d9" translate="yes" xml:space="preserve">
          <source>Interface for an infinite random access range of type &lt;code&gt;E&lt;/code&gt;.</source>
          <target state="translated">유형 &lt;code&gt;E&lt;/code&gt; 의 무한 랜덤 액세스 범위에 대한 인터페이스 .</target>
        </trans-unit>
        <trans-unit id="c9d0cf57e850156d9f049479c7169bad62b9af52" translate="yes" xml:space="preserve">
          <source>Interface for an output range of type &lt;code&gt;E&lt;/code&gt;. Usage is similar to the &lt;code&gt;InputRange&lt;/code&gt; interface and descendants.</source>
          <target state="translated">유형 &lt;code&gt;E&lt;/code&gt; 의 출력 범위에 대한 인터페이스입니다 . 사용법은 &lt;code&gt;InputRange&lt;/code&gt; 인터페이스 및 하위 항목과 유사합니다 .</target>
        </trans-unit>
        <trans-unit id="9460943add2d33f93432076ae984835cefe527f7" translate="yes" xml:space="preserve">
          <source>Interface for diagnostic reporting.</source>
          <target state="translated">진단보고를위한 인터페이스.</target>
        </trans-unit>
        <trans-unit id="3a1df4ab19b1c423cdf62882763fa74c4af37e82" translate="yes" xml:space="preserve">
          <source>Interface member functions can have contracts even though there is no body for the function. The contracts are inherited by any class member function that implements that interface member function.</source>
          <target state="translated">인터페이스 멤버 함수는 함수에 대한 본문이 없더라도 계약을 가질 수 있습니다. 계약은 해당 인터페이스 멤버 함수를 구현하는 모든 클래스 멤버 함수에 의해 상속됩니다.</target>
        </trans-unit>
        <trans-unit id="f3be3896196c198c957ce4d700b0918b399182de" translate="yes" xml:space="preserve">
          <source>Interface to C++</source>
          <target state="translated">C ++ 인터페이스</target>
        </trans-unit>
        <trans-unit id="d7b35a8578bedf4b2033b8a1d3efb36b51c26426" translate="yes" xml:space="preserve">
          <source>Interface to ODBC C library.</source>
          <target state="translated">ODBC C 라이브러리에 대한 인터페이스.</target>
        </trans-unit>
        <trans-unit id="621522c8d929097b62eb853aff27378218dcc932" translate="yes" xml:space="preserve">
          <source>Interface to OS-specific allocators that support specifying alignment: &lt;a href=&quot;http://man7.org/linux/man-pages/man3/posix_memalign.3.html&quot;&gt;&lt;code&gt;posix_memalign&lt;/code&gt;&lt;/a&gt; on Posix and &lt;a href=&quot;http://msdn.microsoft.com/en-us/library/fs9stz4e(v=vs.80).aspx&quot;&gt;&lt;code&gt;__aligned_xxx&lt;/code&gt;&lt;/a&gt; on Windows.</source>
          <target state="translated">정렬 지정을 지원하는 OS 별 할당 자에 대한 인터페이스 : Posix의 &lt;a href=&quot;http://man7.org/linux/man-pages/man3/posix_memalign.3.html&quot;&gt; &lt;code&gt;posix_memalign&lt;/code&gt; &lt;/a&gt; 및 Windows의 &lt;a href=&quot;http://msdn.microsoft.com/en-us/library/fs9stz4e(v=vs.80).aspx&quot;&gt; &lt;code&gt;__aligned_xxx&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="da8580df0429b0473e5e3791367530334b73829e" translate="yes" xml:space="preserve">
          <source>Interface to SQLite C library.</source>
          <target state="translated">SQLite C 라이브러리에 대한 인터페이스</target>
        </trans-unit>
        <trans-unit id="7de306419630810feb8071066cf5e31bb55e01fb" translate="yes" xml:space="preserve">
          <source>Interface to libcurl C library.</source>
          <target state="translated">libcurl C 라이브러리에 대한 인터페이스</target>
        </trans-unit>
        <trans-unit id="f42fa13806030306bbca72d2c1d02ced3c60299a" translate="yes" xml:space="preserve">
          <source>Interface to the C linked list type.</source>
          <target state="translated">C 연결리스트 유형에 대한 인터페이스.</target>
        </trans-unit>
        <trans-unit id="e3744c2b6a83f2ded743b60e48109853d6af0029" translate="yes" xml:space="preserve">
          <source>Interface to zlib C library.</source>
          <target state="translated">zlib C 라이브러리에 대한 인터페이스.</target>
        </trans-unit>
        <trans-unit id="0e4b1bcf55c79cee225ecf64df995188b37f85a9" translate="yes" xml:space="preserve">
          <source>Interface[] &lt;strong id=&quot;interfaces&quot;&gt;interfaces&lt;/strong&gt;;</source>
          <target state="translated">인터페이스 [] &lt;strong id=&quot;interfaces&quot;&gt;인터페이스&lt;/strong&gt; ;</target>
        </trans-unit>
        <trans-unit id="b356313f979923fc829adb909098ed26a5a01aff" translate="yes" xml:space="preserve">
          <source>Interfaces</source>
          <target state="translated">Interfaces</target>
        </trans-unit>
        <trans-unit id="87ef706c8b2c0856ee57ff234b67b63ee3440c74" translate="yes" xml:space="preserve">
          <source>Interfaces can be inherited and functions overridden:</source>
          <target state="translated">인터페이스를 상속하고 함수를 재정의 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5c38dbc7db84c5be19893f9ea37a5e4e03b244d7" translate="yes" xml:space="preserve">
          <source>Interfaces can be reimplemented in derived classes:</source>
          <target state="translated">파생 클래스에서 인터페이스를 다시 구현할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5c369ab8b0d4a9f58e24c8d22b04e27527c78058" translate="yes" xml:space="preserve">
          <source>Interfaces can have function templates in the members. All instantiated functions are implicitly &lt;code&gt;final&lt;/code&gt;.</source>
          <target state="translated">인터페이스는 멤버에 함수 템플릿을 가질 수 있습니다. 모든 인스턴스화 된 함수는 암시 적으로 &lt;code&gt;final&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="bdf123e52e487e317a85601aa2c062c8ae21bd83" translate="yes" xml:space="preserve">
          <source>Interfaces cannot derive from classes; only from other interfaces. Classes cannot derive from an interface multiple times.</source>
          <target state="translated">인터페이스는 클래스에서 파생 될 수 없습니다. 다른 인터페이스에서만. 클래스는 인터페이스에서 여러 번 파생 될 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="233b20e42a18eec431d3cd18cbd18fa45bf5e124" translate="yes" xml:space="preserve">
          <source>Interfaces describe a list of functions that a class that inherits from the interface must implement. A class that implements an interface can be converted to a reference to that interface.</source>
          <target state="translated">인터페이스는 인터페이스에서 상속 된 클래스가 구현해야하는 함수 목록을 설명합니다. 인터페이스를 구현하는 클래스는 해당 인터페이스에 대한 참조로 변환 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c99b66b1687d267b80c156d483b9207e87aa2612" translate="yes" xml:space="preserve">
          <source>Interfaces to extend FTS5.</source>
          <target state="translated">FTS5를 확장하기위한 인터페이스.</target>
        </trans-unit>
        <trans-unit id="737865cc9d40029ada2522214f2743a9901cb1cf" translate="yes" xml:space="preserve">
          <source>Interfaces with Contracts</source>
          <target state="translated">계약과의 인터페이스</target>
        </trans-unit>
        <trans-unit id="772a604c8c3d9a084a30e26beb308940804e19fb" translate="yes" xml:space="preserve">
          <source>Interfacing Garbage Collected Objects With Foreign Code</source>
          <target state="translated">가비지 수집 된 객체와 외부 코드의 인터페이스</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
