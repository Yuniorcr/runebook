<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="fish">
    <body>
      <group id="fish">
        <trans-unit id="4f10862d2cb42eba3132cb49d2ba2a80e3864525" translate="yes" xml:space="preserve">
          <source>For example, if you wanted to have a function &lt;code&gt;ll&lt;/code&gt;, you would add a text file &lt;code&gt;ll.fish&lt;/code&gt; to &lt;code&gt;~/.config/fish/functions&lt;/code&gt;:</source>
          <target state="translated">예를 들어, 함수 &lt;code&gt;ll&lt;/code&gt; 을 &lt;code&gt;ll.fish&lt;/code&gt; &lt;code&gt;~/.config/fish/functions&lt;/code&gt; 에 텍스트 파일 ll.fish 를 추가하십시오 .</target>
        </trans-unit>
        <trans-unit id="631584c9382e007cb93a95331a33fec25ea95d0e" translate="yes" xml:space="preserve">
          <source>For example, the following is a function definition that calls the command &lt;code&gt;ls&lt;/code&gt; with the argument '&lt;code&gt;-l&lt;/code&gt;' to print a detailed listing of the contents of the current directory:</source>
          <target state="translated">예를 들어, 다음은 ' &lt;code&gt;-l&lt;/code&gt; ' 인수와 함께 &lt;code&gt;ls&lt;/code&gt; 명령을 호출 하여 현재 디렉토리의 내용에 대한 자세한 목록을 인쇄하는 함수 정의입니다 .</target>
        </trans-unit>
        <trans-unit id="059c3e8cce263b2945a18ac90b2637e10a8026b1" translate="yes" xml:space="preserve">
          <source>For example:</source>
          <target state="translated">예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="9b35e52823563d2df240637c363f5b52ee523904" translate="yes" xml:space="preserve">
          <source>For examples of how to write your own complex completions, study the completions in &lt;code&gt;/usr/share/fish/completions&lt;/code&gt;. (The exact path depends on your chosen installation prefix and may be slightly different)</source>
          <target state="translated">복잡한 완성을 작성하는 방법에 대한 예는 &lt;code&gt;/usr/share/fish/completions&lt;/code&gt; 에서 완성을 연구하십시오 . (정확한 경로는 선택한 설치 접두사에 따라 다르며 약간 다를 수 있습니다)</target>
        </trans-unit>
        <trans-unit id="bbba6181daff6006d824b40726c5e1dc21c20696" translate="yes" xml:space="preserve">
          <source>For loops can be used to iterate over a list. For example, a list of files:</source>
          <target state="translated">For 루프를 사용하여 목록을 반복 할 수 있습니다. 예를 들어 파일 목록은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="0d3b4b55cdd235f8a297cfd58fd2b4aaeb478949" translate="yes" xml:space="preserve">
          <source>For more details, see &lt;a href=&quot;index#debugging&quot;&gt;Debugging fish scripts&lt;/a&gt; in the &lt;code&gt;fish&lt;/code&gt; manual.</source>
          <target state="translated">자세한 내용 은 &lt;code&gt;fish&lt;/code&gt; 매뉴얼의 &lt;a href=&quot;index#debugging&quot;&gt;물고기 스크립트 디버깅을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="2fc141152e052520326e534bbd191caeb550504d" translate="yes" xml:space="preserve">
          <source>For more information on how to define new event handlers, see the documentation for the &lt;a href=&quot;commands#function&quot;&gt;function&lt;/a&gt; command.</source>
          <target state="translated">새 이벤트 핸들러를 정의하는 방법에 대한 자세한 내용은 &lt;a href=&quot;commands#function&quot;&gt;함수&lt;/a&gt; 명령 설명서를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="6895247d91fcffa104e9a4003d47294a8b67a455" translate="yes" xml:space="preserve">
          <source>For more information, read the documentation for the block constructs, such as &lt;code&gt;if&lt;/code&gt;, &lt;code&gt;for&lt;/code&gt; and &lt;code&gt;while&lt;/code&gt;.</source>
          <target state="translated">자세한 내용은, 예컨대, 블록 구조에 대한 문서를 읽을 &lt;code&gt;if&lt;/code&gt; , &lt;code&gt;for&lt;/code&gt; 및 &lt;code&gt;while&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b8d92b5c7148803c36e855152c078c15224a9486" translate="yes" xml:space="preserve">
          <source>For numbers, &lt;code&gt;.&lt;/code&gt; is always the radix character regardless of locale - &lt;code&gt;2.5&lt;/code&gt;, not &lt;code&gt;2,5&lt;/code&gt;. Scientific notation (&lt;code&gt;10e5&lt;/code&gt;) is also available.</source>
          <target state="translated">숫자의 경우 &lt;code&gt;.&lt;/code&gt; 로케일에 상관없이 항상 기수 문자 입니다. &lt;code&gt;2.5&lt;/code&gt; 는 아니고 &lt;code&gt;2,5&lt;/code&gt; 입니다. 과학적 표기법 ( &lt;code&gt;10e5&lt;/code&gt; )도 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="d790b402d79ac1a723c790313bcd679999474630" translate="yes" xml:space="preserve">
          <source>Frequently Asked Questions</source>
          <target state="translated">자주 묻는 질문</target>
        </trans-unit>
        <trans-unit id="817a23516d79c9310b8cbcd3fbb553ae7f962425" translate="yes" xml:space="preserve">
          <source>From an interactive shell, the commands below exit with a return value of zero:</source>
          <target state="translated">대화식 쉘에서 아래 명령은 리턴 값 0으로 종료됩니다.</target>
        </trans-unit>
        <trans-unit id="68add3d9773584e2619f672ebe5f9d4745e5e9ea" translate="yes" xml:space="preserve">
          <source>From now on, we'll pretend your prompt is just a '&lt;code&gt;&amp;gt;&lt;/code&gt;' to save space.</source>
          <target state="translated">이제부터는 공간을 절약하기 위해 프롬프트가 ' &lt;code&gt;&amp;gt;&lt;/code&gt; '인 것처럼 가장합니다 .</target>
        </trans-unit>
        <trans-unit id="2b961dea1dc0c60ddf9a2c8e9d090f6f7d082483" translate="yes" xml:space="preserve">
          <source>Functions</source>
          <target state="translated">Functions</target>
        </trans-unit>
        <trans-unit id="daf9c1f469f134e463969d3e8181e558bbde191a" translate="yes" xml:space="preserve">
          <source>Functions are programs written in the fish syntax. They group together one or more commands and their arguments using a single name. It can also be used to start a specific command with additional arguments.</source>
          <target state="translated">함수는 피쉬 구문으로 작성된 프로그램입니다. 단일 이름을 사용하여 하나 이상의 명령과 인수를 그룹화합니다. 추가 인수를 사용하여 특정 명령을 시작하는 데 사용할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="89f90915711f79d63d40ae94fbe45e944677e599" translate="yes" xml:space="preserve">
          <source>Functions beginning with the string &lt;code&gt;__fish_print_&lt;/code&gt; print a newline separated list of strings. For example, &lt;code&gt;__fish_print_filesystems&lt;/code&gt; prints a list of all known file systems. Functions beginning with &lt;code&gt;__fish_complete_&lt;/code&gt; print out a newline separated list of completions with descriptions. The description is separated from the completion by a tab character.</source>
          <target state="translated">문자열 &lt;code&gt;__fish_print_&lt;/code&gt; 로 시작하는 함수 는 줄 바꿈으로 구분 된 문자열 목록을 인쇄합니다. 예를 들어 &lt;code&gt;__fish_print_filesystems&lt;/code&gt; 는 알려진 모든 파일 시스템의 목록을 인쇄합니다. &lt;code&gt;__fish_complete_&lt;/code&gt; 로 시작하는 함수 는 개행으로 구분 된 완료 목록을 설명과 함께 인쇄합니다. 설명은 완료와 탭 문자로 구분됩니다.</target>
        </trans-unit>
        <trans-unit id="bfd6b853607d78b9cac90686ca5ac5f2f2bd0492" translate="yes" xml:space="preserve">
          <source>Functions can be defined on the commandline or in a configuration file, but they can also be automatically loaded. This method of defining functions has several advantages. An autoloaded function becomes available automatically to all running shells. If the function definition is changed, all running shells will automatically reload the altered version. Startup time and memory usage is improved, etc.</source>
          <target state="translated">명령 줄 또는 구성 파일에서 기능을 정의 할 수 있지만 자동으로로드 할 수도 있습니다. 이 함수 정의 방법에는 몇 가지 장점이 있습니다. 자동로드 기능은 실행중인 모든 쉘에서 자동으로 사용할 수있게됩니다. 함수 정의가 변경되면 실행중인 모든 셸이 변경된 버전을 자동으로 다시로드합니다. 시작 시간 및 메모리 사용량 등이 향상되었습니다.</target>
        </trans-unit>
        <trans-unit id="45aaac446e8af8ab443ebb79de1921177d9fc9c4" translate="yes" xml:space="preserve">
          <source>Fundle</source>
          <target state="translated">Fundle</target>
        </trans-unit>
        <trans-unit id="1dbc937890de836b0044393faedad472b64f7496" translate="yes" xml:space="preserve">
          <source>Further help and development</source>
          <target state="translated">추가 도움 및 개발</target>
        </trans-unit>
        <trans-unit id="bcbbc69b089ac1c6106198168f95bbc56b4fa684" translate="yes" xml:space="preserve">
          <source>Future feature flags</source>
          <target state="translated">향후 기능 플래그</target>
        </trans-unit>
        <trans-unit id="3dc04827b1d89f032f341434dadfd4fcc6c503c2" translate="yes" xml:space="preserve">
          <source>GNU style long options, like '&lt;code&gt;--colors&lt;/code&gt;'. GNU style long options can be more than one character long, are preceded by two hyphens, and may not be grouped together. Option arguments may be specified in the following parameter ('&lt;code&gt;--quoting-style shell&lt;/code&gt;') or by appending the option with a '&lt;code&gt;=&lt;/code&gt;' and the value ('&lt;code&gt;--quoting-style=shell&lt;/code&gt;'). GNU style long options may be abbreviated so long as the abbreviation is unique ('&lt;code&gt;--h&lt;/code&gt;') is equivalent to '&lt;code&gt;--help&lt;/code&gt;' if help is the only long option beginning with an 'h').</source>
          <target state="translated">' &lt;code&gt;--colors&lt;/code&gt; ' 와 같은 GNU 스타일의 긴 옵션 . GNU 스타일의 long 옵션은 한 문자를 초과 할 수 있으며 앞에 두 개의 하이픈이 있으며 그룹화 할 수 없습니다. 옵션 인수는 다음 매개 변수 ( ' &lt;code&gt;--quoting-style shell&lt;/code&gt; ')에 지정하거나 옵션에 ' &lt;code&gt;=&lt;/code&gt; '및 값 ( ' &lt;code&gt;--quoting-style=shell&lt;/code&gt; ') 을 추가하여 지정할 수 있습니다. GNU 스타일의 긴 옵션은 약어가 고유 한 한 ( ' &lt;code&gt;--h&lt;/code&gt; ')가 'h'로 시작하는 유일한 긴 옵션 인 경우 ' &lt;code&gt;--help&lt;/code&gt; ' 와 동일 하다면 약어로 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="d19c496fc9fc5f17e29b156659c99fdebbdf355e" translate="yes" xml:space="preserve">
          <source>Get the length of a list with &lt;code&gt;count&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;count&lt;/code&gt; 가있는 목록의 길이를 가져옵니다 .</target>
        </trans-unit>
        <trans-unit id="9a0f73ca6aa746ede1e77153dd3bf5bb16e841ab" translate="yes" xml:space="preserve">
          <source>Getting Help</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="76e7a3a3f9c225fe820ba7e9cff10ea2a73b79a1" translate="yes" xml:space="preserve">
          <source>Getting started</source>
          <target state="translated">시작하기</target>
        </trans-unit>
        <trans-unit id="097b5d5320d0735796306d389e915b1392ea4a90" translate="yes" xml:space="preserve">
          <source>Groups:</source>
          <target state="translated">Groups:</target>
        </trans-unit>
        <trans-unit id="c47ae15370cfe1ed2781eedc1dc2547d12d9e972" translate="yes" xml:space="preserve">
          <source>Help</source>
          <target state="translated">Help</target>
        </trans-unit>
        <trans-unit id="0053f4880938c6ad45d9f6ae784ae7aa588de2e2" translate="yes" xml:space="preserve">
          <source>Help on a specific builtin can also be obtained with the &lt;code&gt;-h&lt;/code&gt; parameter. For instance, to obtain help on the &lt;code&gt;fg&lt;/code&gt; builtin, either type &lt;code&gt;fg -h&lt;/code&gt; or &lt;code&gt;help fg&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;-h&lt;/code&gt; 매개 변수 를 사용하여 특정 내장에 대한 도움말을 얻을 수도 있습니다 . 예를 들어 &lt;code&gt;fg&lt;/code&gt; 내장 에 대한 도움말을 보려면 &lt;code&gt;fg -h&lt;/code&gt; 또는 &lt;code&gt;help fg&lt;/code&gt; 를 입력 하십시오 .</target>
        </trans-unit>
        <trans-unit id="4f5d69f1e4fa9190f3df409c8af9094f4963c8a1" translate="yes" xml:space="preserve">
          <source>Here is a list of some useful commands:</source>
          <target state="translated">다음은 몇 가지 유용한 명령 목록입니다.</target>
        </trans-unit>
        <trans-unit id="7a509c793438fa230f1278ed402f9c7e9018572d" translate="yes" xml:space="preserve">
          <source>History searches can be aborted by pressing the escape key.</source>
          <target state="translated">Esc 키를 눌러 기록 검색을 중단 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="67bc332b46b3f3dc1b8024a5e5cfdee70680168b" translate="yes" xml:space="preserve">
          <source>Hit tab again to cycle through the possibilities.</source>
          <target state="translated">가능성을 순환하려면 탭을 다시 누르십시오.</target>
        </trans-unit>
        <trans-unit id="0fb159db1e28fce0aea599e71e51612c11b25f22" translate="yes" xml:space="preserve">
          <source>Home directory expansion</source>
          <target state="translated">홈 디렉토리 확장</target>
        </trans-unit>
        <trans-unit id="d5208f2bd161f7ef9e4786ba2058053cc8cefa22" translate="yes" xml:space="preserve">
          <source>How can I use `-` as a shortcut for `cd -`?</source>
          <target state="translated">`-`를`cd -`의 단축키로 어떻게 사용할 수 있습니까?</target>
        </trans-unit>
        <trans-unit id="ba1155cc4fa464e6593f08ba2b8723aab74c8f1c" translate="yes" xml:space="preserve">
          <source>How do I change the greeting message?</source>
          <target state="translated">인사말 메시지를 어떻게 변경합니까?</target>
        </trans-unit>
        <trans-unit id="13c4a91c9a86c9c981e277c7f5e4a2ed6189509e" translate="yes" xml:space="preserve">
          <source>How do I customize my syntax highlighting colors?</source>
          <target state="translated">구문 강조 색상을 어떻게 사용자 정의합니까?</target>
        </trans-unit>
        <trans-unit id="a694102af5424918d28a1f9662a1aa3950673c08" translate="yes" xml:space="preserve">
          <source>How do I get the exit status of a command?</source>
          <target state="translated">명령의 종료 상태를 얻으려면 어떻게합니까?</target>
        </trans-unit>
        <trans-unit id="0e58d9d321d50cf0c49be8ad0ed48955a88a6bce" translate="yes" xml:space="preserve">
          <source>How do I make fish my default shell?</source>
          <target state="translated">생선을 기본 껍질로 만들려면 어떻게해야합니까?</target>
        </trans-unit>
        <trans-unit id="bc538e8432ebecf3f9f7a45d7ccb524d4da71c7d" translate="yes" xml:space="preserve">
          <source>How do I run a command every login? What's fish's equivalent to .bashrc?</source>
          <target state="translated">로그인 할 때마다 명령을 어떻게 실행합니까? 물고기는 .bashrc와 동일합니까?</target>
        </trans-unit>
        <trans-unit id="9d52246c1acb2dd2ad95298d27dac048384b6b2b" translate="yes" xml:space="preserve">
          <source>How do I run a command from history?</source>
          <target state="translated">기록에서 명령을 어떻게 실행합니까?</target>
        </trans-unit>
        <trans-unit id="7c2282706e5d5da05460852fe614e0ea089754e8" translate="yes" xml:space="preserve">
          <source>How do I run a subcommand? The backtick doesn't work!</source>
          <target state="translated">하위 명령을 어떻게 실행합니까? 백틱이 작동하지 않습니다!</target>
        </trans-unit>
        <trans-unit id="240782fc9c5f0b5d6c4cc74b05803ec8fdfa4ffc" translate="yes" xml:space="preserve">
          <source>How do I set an environment variable for just one command?</source>
          <target state="translated">하나의 명령에 대해서만 환경 변수를 설정하는 방법은 무엇입니까?</target>
        </trans-unit>
        <trans-unit id="cf01f8cfda8ac7fdc0ad1cfce27146791559db05" translate="yes" xml:space="preserve">
          <source>How do I set my prompt?</source>
          <target state="translated">프롬프트를 어떻게 설정합니까?</target>
        </trans-unit>
        <trans-unit id="a7f2b2fb54e2d471e8f341688e112fc1e1ce9d80" translate="yes" xml:space="preserve">
          <source>How do I set or clear an environment variable?</source>
          <target state="translated">환경 변수를 설정하거나 지우려면 어떻게합니까?</target>
        </trans-unit>
        <trans-unit id="1bbce1c02cef5225c09fe183c39555282f316dab" translate="yes" xml:space="preserve">
          <source>How do I update man page completions?</source>
          <target state="translated">매뉴얼 페이지 완성을 어떻게 업데이트합니까?</target>
        </trans-unit>
        <trans-unit id="8755f1ac4179b2490bfd8d3384a3c541bc0e9557" translate="yes" xml:space="preserve">
          <source>However sometimes, especially with &lt;code&gt;pkg-config&lt;/code&gt; and related tools, splitting on spaces is needed.</source>
          <target state="translated">그러나 때때로, 특히 &lt;code&gt;pkg-config&lt;/code&gt; 및 관련 도구의 경우 공간 분할이 필요합니다.</target>
        </trans-unit>
        <trans-unit id="54bce717b6b4bc0facb17b1202d46c84a308e996" translate="yes" xml:space="preserve">
          <source>However using variables as indices for command substitution is currently not supported, so</source>
          <target state="translated">그러나 명령 대체를 위해 변수를 인덱스로 사용하는 것은 현재 지원되지 않으므로</target>
        </trans-unit>
        <trans-unit id="3ece1cae89b5ddaf2b419721f67d267e2d87fe0b" translate="yes" xml:space="preserve">
          <source>However, it is more common and efficient to use autoloading functions and universal variables.</source>
          <target state="translated">그러나 자동로드 기능과 범용 변수를 사용하는 것이 더 일반적이고 효율적입니다.</target>
        </trans-unit>
        <trans-unit id="332860b83cabf222387565b3cbb3a4ca2b6a60c7" translate="yes" xml:space="preserve">
          <source>I accidentally entered a directory path and fish changed directory. What happened?</source>
          <target state="translated">실수로 디렉토리 경로를 입력하고 물고기가 디렉토리를 변경했습니다. 어떻게 된 거예요?</target>
        </trans-unit>
        <trans-unit id="077b540fd621e89ad74c3aa41ae8c6bb0c4148b1" translate="yes" xml:space="preserve">
          <source>I'm seeing weird output before each prompt when using screen. What's wrong?</source>
          <target state="translated">화면을 사용할 때 각 프롬프트 전에 이상한 출력이 나타납니다. 뭐가 문제 야?</target>
        </trans-unit>
        <trans-unit id="7884771064847db56c0b28c42a19e5f67be016fb" translate="yes" xml:space="preserve">
          <source>If $animals is a list of animals, the following will test if it contains a cat:</source>
          <target state="translated">$ animals가 동물 목록 인 경우 다음은 고양이가 포함되어 있는지 테스트합니다.</target>
        </trans-unit>
        <trans-unit id="6288311089317cecbe49c2b077270e72c24f0c74" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;$animal&lt;/code&gt; was set to &quot;banana&quot;, it would print &quot;I have no idea what a banana is&quot;.</source>
          <target state="translated">경우 &lt;code&gt;$animal&lt;/code&gt; &quot;바나나&quot;로 설정, 그것은 &quot;나는 바나나가 무엇인지 전혀 모른다&quot;인쇄 할 것이다.</target>
        </trans-unit>
        <trans-unit id="6529dd48f4bbe7af35d8ee17e053a860dce8bc42" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;$argv&lt;/code&gt; is empty then there is nothing to parse and &lt;code&gt;argparse&lt;/code&gt; returns zero to indicate success. If &lt;code&gt;$argv&lt;/code&gt; is not empty then it is checked for flags &lt;code&gt;-h&lt;/code&gt;, &lt;code&gt;--help&lt;/code&gt;, &lt;code&gt;-n&lt;/code&gt; and &lt;code&gt;--name&lt;/code&gt;. If they are found they are removed from the arguments and local variables (more on this &lt;a href=&quot;argparse-local-variables&quot;&gt;below&lt;/a&gt;) are set so the script can determine which options were seen. Assuming &lt;code&gt;$argv&lt;/code&gt; doesn't have any errors, such as a missing mandatory value for an option, then &lt;code&gt;argparse&lt;/code&gt; exits with status zero. Otherwise it writes appropriate error messages to stderr and exits with a status of one.</source>
          <target state="translated">경우 &lt;code&gt;$argv&lt;/code&gt; 비어 다음이 구문 분석하는 것도없고 &lt;code&gt;argparse&lt;/code&gt; 반환 성공을 표시하는 제로. 경우 &lt;code&gt;$argv&lt;/code&gt; 다음 비어 있지 그것은 플래그에 대한 체크 &lt;code&gt;-h&lt;/code&gt; , &lt;code&gt;--help&lt;/code&gt; , &lt;code&gt;-n&lt;/code&gt; 및 &lt;code&gt;--name&lt;/code&gt; . 그것들이 발견되면 인수에서 제거되고 로컬 변수 ( &lt;a href=&quot;argparse-local-variables&quot;&gt;아래에&lt;/a&gt; 더 자세히 설명되어 있음 )가 설정되어 스크립트가 어떤 옵션을 볼 수 있는지 결정할 수 있습니다. &lt;code&gt;$argv&lt;/code&gt; 에 옵션의 필수 값 누락과 같은 오류가 없다고 가정하면 &lt;code&gt;argparse&lt;/code&gt; 는 상태 0으로 종료됩니다. 그렇지 않으면 적절한 오류 메시지를 stderr에 기록하고 상태 1로 종료합니다.</target>
        </trans-unit>
        <trans-unit id="18c0231ee0546ad7aeb3f50a1a68cbc1c85d1797" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;--index&lt;/code&gt; or &lt;code&gt;-n&lt;/code&gt; is given, each match is reported as a 1-based start position and a length. By default, PATTERN is interpreted as a glob pattern matched against each entire STRING argument. A glob pattern is only considered a valid match if it matches the entire STRING.</source>
          <target state="translated">경우 &lt;code&gt;--index&lt;/code&gt; 또는 &lt;code&gt;-n&lt;/code&gt; 을 주어, 각 경기는 1부터 시작 위치와 길이로보고됩니다. 기본적으로 PATTERN은 각 STRING 인수 전체와 일치하는 glob 패턴으로 해석됩니다. glob 패턴은 전체 STRING과 일치하는 경우에만 유효한 일치로 간주됩니다.</target>
        </trans-unit>
        <trans-unit id="dbf8f89e324b9e1f656b472c919d4c7a437efce4" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;--invert&lt;/code&gt; or &lt;code&gt;-v&lt;/code&gt; is used the selected lines will be only those which do not match the given glob pattern or regular expression.</source>
          <target state="translated">경우 &lt;code&gt;--invert&lt;/code&gt; 또는 &lt;code&gt;-v&lt;/code&gt; 가 사용되는 선택된 라인 만 주어진 글로브 패턴 또는 정규 표현식과 일치하지 않는 사람이 될 것입니다.</target>
        </trans-unit>
        <trans-unit id="bca5e01e9673f9e6a815d4bc3b45775fa51fbbf4" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;--regex&lt;/code&gt; or &lt;code&gt;-r&lt;/code&gt; is given, PATTERN is interpreted as a Perl-compatible regular expression, which does not have to match the entire STRING. For a regular expression containing capturing groups, multiple items will be reported for each match, one for the entire match and one for each capturing group. With this, only the matching part of the STRING will be reported, unless &lt;code&gt;--entire&lt;/code&gt; is given.</source>
          <target state="translated">경우 &lt;code&gt;--regex&lt;/code&gt; 또는 &lt;code&gt;-r&lt;/code&gt; 이 주어집니다, 패턴은 전체 문자열과 일치하지 않는 펄 호환 정규 표현식으로 해석됩니다. 캡처 그룹이 포함 된 정규식의 경우 각 일치 항목, 전체 일치 항목 및 캡처 그룹마다 여러 항목이보고됩니다. 이를 통해 &lt;code&gt;--entire&lt;/code&gt; 를 지정 하지 않으면 STRING의 일치하는 부분 만보고 됩니다.</target>
        </trans-unit>
        <trans-unit id="4e269b8b85f5f48b405e1f529c5cc1623456789e" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;-a&lt;/code&gt; or &lt;code&gt;--array&lt;/code&gt; is provided, only one variable name is allowed and the tokens are stored as an array in this variable.</source>
          <target state="translated">경우 &lt;code&gt;-a&lt;/code&gt; 또는 &lt;code&gt;--array&lt;/code&gt; 가 제공되고, 하나의 변수 이름이 허용되고,이 토큰은 변수 배열로 저장된다.</target>
        </trans-unit>
        <trans-unit id="a6dcb1b88668c5c41c70fbdad2157ee6171f60f0" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;-e&lt;/code&gt; is used, the following sequences are recognized:</source>
          <target state="translated">경우 &lt;code&gt;-e&lt;/code&gt; 를 사용하는 경우, 다음 순서는 인식됩니다</target>
        </trans-unit>
        <trans-unit id="e5d5482f59147347f76e114d12618ff3d78fea80" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;-r&lt;/code&gt; or &lt;code&gt;--regex&lt;/code&gt; is given, PATTERN is interpreted as a Perl-compatible regular expression, and REPLACEMENT can contain C-style escape sequences like &lt;code&gt;\t&lt;/code&gt; as well as references to capturing groups by number or name as &lt;code&gt;$n&lt;/code&gt; or &lt;code&gt;${n}&lt;/code&gt;.</source>
          <target state="translated">만약 &lt;code&gt;-r&lt;/code&gt; 또는 &lt;code&gt;--regex&lt;/code&gt; , PATTERN은 펄 호환 정규 표현식으로 해석됩니다 부여 및 교체가 같은 C 스타일 이스케이프 시퀀스를 포함 할 수 있습니다 &lt;code&gt;\t&lt;/code&gt; 등의 번호 또는 이름으로 캡처 그룹에 대한 참조뿐만 아니라 &lt;code&gt;$n&lt;/code&gt; 또는 &lt;code&gt;${n}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="227584b023d6d2c7837f693e7e9b190c0c0b3bf5" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;ARG&lt;/code&gt; and &lt;code&gt;REASON&lt;/code&gt; are both specified, &lt;code&gt;ARG&lt;/code&gt; is the command to be executed when the event specified by &lt;code&gt;REASON&lt;/code&gt; occurs (e.g., the signal is delivered).</source>
          <target state="translated">경우 &lt;code&gt;ARG&lt;/code&gt; 및 &lt;code&gt;REASON&lt;/code&gt; 가 모두 지정되어 &lt;code&gt;ARG&lt;/code&gt; 가 된 이벤트 때 실행되는 명령이다 &lt;code&gt;REASON&lt;/code&gt; 가 발생 (예는, 신호를 전달한다).</target>
        </trans-unit>
        <trans-unit id="d6a059f39530ea46f03b1a88f280774a9e1b7e4c" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;ARG&lt;/code&gt; is absent (and there is a single REASON) or -, each specified signal is reset to its original disposition (the value it had upon entrance to the shell). If &lt;code&gt;ARG&lt;/code&gt; is the null string the signal specified by each &lt;code&gt;REASON&lt;/code&gt; is ignored by the shell and by the commands it invokes.</source>
          <target state="translated">경우 &lt;code&gt;ARG&lt;/code&gt; 이 없는 (그리고 하나가 REASON 임) 또는 - 지정된 각 신호는 원래의 배열 (이것은 쉘 입구에 있던 값)으로 리셋된다. 경우 &lt;code&gt;ARG&lt;/code&gt; 가 널 (null) 문자열을 각에 의해 지정된 신호 &lt;code&gt;REASON&lt;/code&gt; 쉘과는 호출 명령에 의해 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="0310897c6525d4c0a20301e5b59490367df8d786" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;ARG&lt;/code&gt; is not present and &lt;code&gt;-p&lt;/code&gt; has been supplied, then the trap commands associated with each &lt;code&gt;REASON&lt;/code&gt; are displayed. If no arguments are supplied or if only &lt;code&gt;-p&lt;/code&gt; is given, &lt;code&gt;trap&lt;/code&gt; prints the list of commands associated with each signal.</source>
          <target state="translated">경우 &lt;code&gt;ARG&lt;/code&gt; 가 존재하지 않으며 &lt;code&gt;-p&lt;/code&gt; 가 공급 된 후, 각각에 관련된 트랩 명령 &lt;code&gt;REASON&lt;/code&gt; 가 표시된다. 인수가 제공되지 않거나 &lt;code&gt;-p&lt;/code&gt; 만 제공되면 &lt;code&gt;trap&lt;/code&gt; 은 각 신호와 연관된 명령 목록을 인쇄합니다.</target>
        </trans-unit>
        <trans-unit id="46f4e7706aaa7715626c2065fdf439e268266771" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;DIRECTORY&lt;/code&gt; is a relative path, the paths found in the &lt;code&gt;CDPATH&lt;/code&gt; environment variable array will be tried as prefixes for the specified path.</source>
          <target state="translated">경우 &lt;code&gt;DIRECTORY&lt;/code&gt; 가 상대 경로는 상기 검색된 경로 &lt;code&gt;CDPATH&lt;/code&gt; 의 환경 변수 어레이는 지정된 경로에 대한 프리픽스로 시도한다.</target>
        </trans-unit>
        <trans-unit id="6d211b5295328f27c5f4dda2c5b64e33b2d339ae" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;DIRECTORY&lt;/code&gt; is supplied, it will become the new directory. If no parameter is given, the contents of the &lt;code&gt;HOME&lt;/code&gt; environment variable will be used.</source>
          <target state="translated">경우 &lt;code&gt;DIRECTORY&lt;/code&gt; 공급되고, 그것은 새 디렉토리가 될 것이다. 매개 변수를 지정하지 않으면 &lt;code&gt;HOME&lt;/code&gt; 환경 변수 의 내용 이 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="ee49ba74d2c75163466a92ec95757c32496b3231" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;commandline&lt;/code&gt; is called during a call to complete a given string using &lt;code&gt;complete -C STRING&lt;/code&gt;, &lt;code&gt;commandline&lt;/code&gt; will consider the specified string to be the current contents of the command line.</source>
          <target state="translated">경우 &lt;code&gt;commandline&lt;/code&gt; 사용하여 주어진 문자열 완료하기 위해 통화 중이라 &lt;code&gt;complete -C STRING&lt;/code&gt; , &lt;code&gt;commandline&lt;/code&gt; 명령 행의 현재의 내용으로 지정된 문자열을 고려할 것입니다.</target>
        </trans-unit>
        <trans-unit id="1145ddb3bdeee96521a717d934a15cc64d95077c" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;fish&lt;/code&gt; encounters a problem while executing a command, the status variable may also be set to a specific value:</source>
          <target state="translated">경우 &lt;code&gt;fish&lt;/code&gt; 명령을 실행하는 동안 문제가 발생하는 상태 변수는 특정 값으로 설정 될 수있다 :</target>
        </trans-unit>
        <trans-unit id="f09fbf7f2a9a04bff01d5330effffef51795cab0" translate="yes" xml:space="preserve">
          <source>If a &lt;code&gt;SECTION&lt;/code&gt; is specified, the help for that command is shown.</source>
          <target state="translated">경우 &lt;code&gt;SECTION&lt;/code&gt; 지정되어, 해당 명령에 대한 도움말이 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="8ebee8483e83b06811ff3ba9ccc429433dce33cd" translate="yes" xml:space="preserve">
          <source>If a function named &lt;code&gt;fish_greeting&lt;/code&gt; exists, it will be run when entering interactive mode. Otherwise, if an environment variable named &lt;code&gt;fish_greeting&lt;/code&gt; exists, it will be printed.</source>
          <target state="translated">&lt;code&gt;fish_greeting&lt;/code&gt; 이라는 함수 가 존재하면 대화식 모드로 들어갈 때 실행됩니다. 그렇지 않으면 이름이 &lt;code&gt;fish_greeting&lt;/code&gt; 인 환경 변수 가 존재하면 인쇄됩니다.</target>
        </trans-unit>
        <trans-unit id="236d9b2bfa9ffd703bff82e438702935d8f276d3" translate="yes" xml:space="preserve">
          <source>If a job is stopped, it is sent a signal to continue running, and a warning is printed. It is not possible to use the &lt;code&gt;bg&lt;/code&gt; builtin to continue a job once it has been disowned.</source>
          <target state="translated">작업이 중지되면 계속 실행하라는 신호가 전송되고 경고가 인쇄됩니다. 폐기 된 작업을 계속 하기 위해 &lt;code&gt;bg&lt;/code&gt; 내장 을 사용할 수 없습니다 .</target>
        </trans-unit>
        <trans-unit id="60e2a752180a8997dd97af87732b5ed3a03f8d8f" translate="yes" xml:space="preserve">
          <source>If a numeric mask is specified as a parameter, the current shell's umask will be set to that value, and the rights specified by that mask will be removed from new files and directories by default.</source>
          <target state="translated">숫자 마스크가 매개 변수로 지정되면 현재 쉘의 umask가 해당 값으로 설정되고 해당 마스크에 의해 지정된 권한이 기본적으로 새 파일 및 디렉토리에서 제거됩니다.</target>
        </trans-unit>
        <trans-unit id="2dde9e658888f495cea69c0ad8b260a62416e91a" translate="yes" xml:space="preserve">
          <source>If a pid is specified, the command waits for the job that the process with the pid belongs to.</source>
          <target state="translated">pid가 지정되면 명령은 pid가있는 프로세스가 속한 작업을 기다립니다.</target>
        </trans-unit>
        <trans-unit id="f851c83c3c3953c372c81382f02613c546f275f0" translate="yes" xml:space="preserve">
          <source>If a process exits through a signal, the exit status will be 128 plus the number of the signal.</source>
          <target state="translated">프로세스가 신호를 통해 종료되면 종료 상태는 128에 신호 수를 더한 값입니다.</target>
        </trans-unit>
        <trans-unit id="47cb47829c9383def1fb8361853c4c7dd09368a8" translate="yes" xml:space="preserve">
          <source>If a process name is specified, the command waits for the jobs that the matched processes belong to.</source>
          <target state="translated">프로세스 이름이 지정되면 명령은 일치하는 프로세스가 속한 작업을 기다립니다.</target>
        </trans-unit>
        <trans-unit id="302f9ccffa6bb045e0895a185f5c9e50859c884f" translate="yes" xml:space="preserve">
          <source>If a script produces output, it should finish by calling &lt;code&gt;commandline -f repaint&lt;/code&gt; to tell fish that a repaint is in order.</source>
          <target state="translated">스크립트가 출력을 생성하는 경우, &lt;code&gt;commandline -f repaint&lt;/code&gt; 를 호출 하여 물고기에게 다시 그리기 순서가 있음을 알리는 것으로 완료해야합니다 .</target>
        </trans-unit>
        <trans-unit id="67026ba945428dc31827715c1565311d33b5af8d" translate="yes" xml:space="preserve">
          <source>If a star (&lt;code&gt;*&lt;/code&gt;) or a question mark (&lt;code&gt;?&lt;/code&gt;) is present in the parameter, &lt;code&gt;fish&lt;/code&gt; attempts to match the given parameter to any files in such a way that:</source>
          <target state="translated">별표 ( &lt;code&gt;*&lt;/code&gt; ) 또는 물음표 ( &lt;code&gt;?&lt;/code&gt; )가 매개 변수에 있으면 , &lt;code&gt;fish&lt;/code&gt; 는 다음과 같은 방식으로 주어진 매개 변수를 파일과 일치 시키려고 시도합니다.</target>
        </trans-unit>
        <trans-unit id="18a6fd00e4b1ddec496d39ba9f288b25c849a5d6" translate="yes" xml:space="preserve">
          <source>If a symbolic mask is specified, the desired permission bits, and not the inverse, should be specified. A symbolic mask is a comma separated list of rights. Each right consists of three parts:</source>
          <target state="translated">심볼릭 마스크가 지정된 경우에는 반대가 아닌 원하는 권한 비트를 지정해야합니다. 기호 마스크는 쉼표로 구분 된 권한 목록입니다. 각 권리는 세 부분으로 구성됩니다.</target>
        </trans-unit>
        <trans-unit id="c3bd46787a5c6b92e6f20cfe4fbc883c75045f2a" translate="yes" xml:space="preserve">
          <source>If a variable has global scope, it is accessible read-write to functions whether it is exported or not.</source>
          <target state="translated">변수에 전역 범위가있는 경우 변수의 내보내기 여부에 관계없이 함수에 대한 읽기 / 쓰기가 가능합니다.</target>
        </trans-unit>
        <trans-unit id="741d44bccaaf674b1d069d14a1bdb399e238d593" translate="yes" xml:space="preserve">
          <source>If a variable has local scope and is exported, any function called receives a &lt;em&gt;copy&lt;/em&gt; of it, so any changes it makes to the variable disappear once the function returns.</source>
          <target state="translated">변수에 로컬 범위가 있고 내보내지는 경우 호출 된 함수는 해당 &lt;em&gt;복사본&lt;/em&gt; 을 수신 하므로 함수가 반환되면 변수에 대한 변경 내용이 사라집니다.</target>
        </trans-unit>
        <trans-unit id="2cbdc88f5e9bb2f3b40009d0379b55ab2352ae84" translate="yes" xml:space="preserve">
          <source>If a variable is explicitly set to either be exported or not exported, that setting will be honored.</source>
          <target state="translated">변수를 명시 적으로 내보내거나 내 보내지 않도록 설정하면 해당 설정이 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="ce6484065868b4e9c43f6db14f55a84fe136a4bf" translate="yes" xml:space="preserve">
          <source>If a variable is explicitly set to either universal, global or local, that setting will be honored. If a variable of the same name exists in a different scope, that variable will not be changed.</source>
          <target state="translated">변수가 명시 적으로 범용, 전역 또는 로컬로 설정된 경우 해당 설정이 적용됩니다. 동일한 이름의 변수가 다른 범위에 존재하면 해당 변수는 변경되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="326eb232490e8df93b49fd2c3a89fde63906ed77" translate="yes" xml:space="preserve">
          <source>If a variable is not explicitly set to be either exported or not exported and has never before been defined, the variable will not be exported.</source>
          <target state="translated">변수가 명시 적으로 내보내 지거나 내 보내지 않도록 설정되지 않았으며 이전에 정의 된 적이없는 경우 변수가 내보내지지 않습니다.</target>
        </trans-unit>
        <trans-unit id="ef107fe0701094bebbf7a6322c1155614a1be3ba" translate="yes" xml:space="preserve">
          <source>If a variable is not explicitly set to be either exported or unexported and has never before been defined, the variable will not be exported.</source>
          <target state="translated">변수가 명시 적으로 내보내거나 내 보내지 않도록 설정되지 않았으며 이전에 정의 된 적이없는 경우 변수가 내보내지지 않습니다.</target>
        </trans-unit>
        <trans-unit id="bd6c17ea05cd6c81f352d96759e2622e4a16e84b" translate="yes" xml:space="preserve">
          <source>If a variable is not explicitly set to be either universal, global or local and has never before been defined, the variable will be local to the currently executing function. Note that this is different from using the &lt;code&gt;-l&lt;/code&gt; or &lt;code&gt;--local&lt;/code&gt; flag. If one of those flags is used, the variable will be local to the most inner currently executing block, while without these the variable will be local to the function. If no function is executing, the variable will be global.</source>
          <target state="translated">변수가 명시 적으로 범용, 전역 또는 로컬로 설정되지 않았으며 이전에 정의 된 적이없는 경우 변수는 현재 실행중인 기능에 대해 로컬입니다. 이것은 &lt;code&gt;-l&lt;/code&gt; 또는 &lt;code&gt;--local&lt;/code&gt; 플래그 를 사용하는 것과 다릅니다 . 이러한 플래그 중 하나가 사용되면 변수는 현재 실행중인 가장 내부 블록에 로컬 인 반면 변수가 없으면 함수에 로컬입니다. 함수가 실행되고 있지 않으면 변수는 전역입니다.</target>
        </trans-unit>
        <trans-unit id="8b2d1734ef9bdd7bd6d21bc623798a68378e6c8b" translate="yes" xml:space="preserve">
          <source>If a variable is not explicitly set to be either universal, global or local, but has been previously defined, the previous variable scope is used.</source>
          <target state="translated">변수가 명시 적으로 범용, 전역 또는 로컬로 설정되지 않았지만 이전에 정의 된 경우 이전 변수 범위가 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="ae5e31cb3d02690bd43a99dc6a823c8568d4b6e8" translate="yes" xml:space="preserve">
          <source>If a variable is not explicitly set to be either universal, global or local, but has been previously defined, the variable scope is not changed.</source>
          <target state="translated">변수가 명시 적으로 범용, 전역 또는 로컬로 설정되지 않았지만 이전에 정의 된 경우 변수 범위는 변경되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="6ccd9990afce6a9aaaa05eb9827a340fd925feb1" translate="yes" xml:space="preserve">
          <source>If a variable is not explicitly set to be exported or not exported, but has been previously defined, the previous exporting rule for the variable is kept.</source>
          <target state="translated">변수가 명시 적으로 내보내 지거나 내 보내지 않도록 설정되지 않았지만 이전에 정의 된 경우 변수에 대한 이전 내보내기 규칙이 유지됩니다.</target>
        </trans-unit>
        <trans-unit id="72e2106717a7a37128914da8765dc2c6c6697b14" translate="yes" xml:space="preserve">
          <source>If a variable is set to more than one value, the variable will be an array with the specified elements. If a variable is set to zero elements, it will become an array with zero elements.</source>
          <target state="translated">변수가 둘 이상의 값으로 설정되면 변수는 지정된 요소가있는 배열이됩니다. 변수가 0 요소로 설정되면 0 요소를 가진 배열이됩니다.</target>
        </trans-unit>
        <trans-unit id="7f805483966bd1b92bb16fa0e48ac91c14f18567" translate="yes" xml:space="preserve">
          <source>If an error occurs during argparse processing it will exit with a non-zero status and print error messages to stderr.</source>
          <target state="translated">argparse 처리 중에 오류가 발생하면 0이 아닌 상태로 종료되고 stderr에 오류 메시지를 인쇄합니다.</target>
        </trans-unit>
        <trans-unit id="f3bb201c1119b5848ebfda84c47d1e1698174af5" translate="yes" xml:space="preserve">
          <source>If any non-option parameters are given, the definition of the specified functions are printed.</source>
          <target state="translated">비 옵션 매개 변수가 제공되면 지정된 기능의 정의가 인쇄됩니다.</target>
        </trans-unit>
        <trans-unit id="dcc764ad71040642c2ae2b7ce376987c8f357ee1" translate="yes" xml:space="preserve">
          <source>If exit is called while sourcing a file (using the &lt;a href=&quot;#source&quot;&gt;source&lt;/a&gt; builtin) the rest of the file will be skipped, but the shell itself will not exit.</source>
          <target state="translated">&lt;a href=&quot;#source&quot;&gt;소스 소스를&lt;/a&gt; 사용하여 파일을 소싱하는 동안 exit가 호출 되면 나머지 파일은 건너 뛰지 만 쉘 자체는 종료되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="3068ba7bd98e36689eab0ca26911e82ce1011087" translate="yes" xml:space="preserve">
          <source>If fish is unable to locate a command with a given name, and it starts with '&lt;code&gt;.&lt;/code&gt;', '&lt;code&gt;/&lt;/code&gt;' or '&lt;code&gt;~&lt;/code&gt;', fish will test if a directory of that name exists. If it does, it is implicitly assumed that you want to change working directory. For example, the fastest way to switch to your home directory is to simply press &lt;code&gt;~&lt;/code&gt; and enter.</source>
          <target state="translated">물고기가 주어진 이름으로 명령을 찾을 수 없으면 '로 시작합니다 &lt;code&gt;.&lt;/code&gt; ',' &lt;code&gt;/&lt;/code&gt; '또는' &lt;code&gt;~&lt;/code&gt; ', 물고기는 해당 이름의 디렉토리가 존재하는지 테스트합니다. 그렇다면 작업 디렉토리를 변경하려는 것으로 암시 적으로 가정합니다. 예를 들어, 홈 디렉토리로 전환하는 가장 빠른 방법은 &lt;code&gt;~&lt;/code&gt; 를 누르고 입력하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="9365afaebdcba814bae204eaa9cb6846f923618b" translate="yes" xml:space="preserve">
          <source>If limit is given, it is the new value of the specified resource. If no option is given, then &lt;code&gt;-f&lt;/code&gt; is assumed. Values are in kilobytes, except for &lt;code&gt;-t&lt;/code&gt;, which is in seconds and &lt;code&gt;-n&lt;/code&gt; and &lt;code&gt;-u&lt;/code&gt;, which are unscaled values. The return status is 0 unless an invalid option or argument is supplied, or an error occurs while setting a new limit.</source>
          <target state="translated">제한이 지정된 경우 지정된 자원의 새로운 값입니다. 옵션이 제공되지 않으면 &lt;code&gt;-f&lt;/code&gt; 로 가정됩니다. 값은 초 단위 인 &lt;code&gt;-t&lt;/code&gt; 및 스케일링되지 않은 값인 &lt;code&gt;-n&lt;/code&gt; 및 &lt;code&gt;-u&lt;/code&gt; 를 제외하고 킬로바이트 단위 입니다. 유효하지 않은 옵션이나 인수가 제공되지 않거나 새 한계를 설정하는 동안 오류가 발생하지 않으면 리턴 상태는 0입니다.</target>
        </trans-unit>
        <trans-unit id="ca3ffe9826b96a93254e7258c40cd2d913b9941e" translate="yes" xml:space="preserve">
          <source>If neither a pid nor a process name is specified, the command waits for all background jobs.</source>
          <target state="translated">pid 나 프로세스 이름을 지정하지 않으면 명령은 모든 백그라운드 작업을 기다립니다.</target>
        </trans-unit>
        <trans-unit id="6620b792aa7c50700f6a7c83a134de00e5936216" translate="yes" xml:space="preserve">
          <source>If no &lt;code&gt;SEQUENCE&lt;/code&gt; is provided, all bindings (or just the bindings in the specified &lt;code&gt;MODE&lt;/code&gt;) are printed. If &lt;code&gt;SEQUENCE&lt;/code&gt; is provided without &lt;code&gt;COMMAND&lt;/code&gt;, just the binding matching that sequence is printed.</source>
          <target state="translated">&lt;code&gt;SEQUENCE&lt;/code&gt; 가 제공 되지 않으면 모든 바인딩 (또는 지정된 &lt;code&gt;MODE&lt;/code&gt; 의 바인딩 만 )이 인쇄됩니다. &lt;code&gt;COMMAND&lt;/code&gt; 없이 &lt;code&gt;SEQUENCE&lt;/code&gt; 가 제공 되면 해당 시퀀스와 일치하는 바인딩 만 인쇄됩니다.</target>
        </trans-unit>
        <trans-unit id="319b10cf51c7aaf0a0ad28a0d4b4f6c772504c25" translate="yes" xml:space="preserve">
          <source>If no file is specified and stdin is not the terminal, or if the file name '&lt;code&gt;-&lt;/code&gt;' is used, stdin will be read.</source>
          <target state="translated">파일을 지정하지 않고 stdin이 터미널이 아니거나 파일 이름 ' &lt;code&gt;-&lt;/code&gt; '가 사용되면 stdin을 읽습니다.</target>
        </trans-unit>
        <trans-unit id="536986c9ac77b0a65c848619315ad13a2f046d5c" translate="yes" xml:space="preserve">
          <source>If no process is specified, the most recently-used job is removed (like &lt;code&gt;bg&lt;/code&gt; and &lt;code&gt;fg&lt;/code&gt;). If one or more &lt;code&gt;PID&lt;/code&gt;s are specified, jobs with the specified process IDs are removed from the job list. Invalid jobs are ignored and a warning is printed.</source>
          <target state="translated">프로세스를 지정하지 않으면 가장 최근에 사용한 작업 (예 : &lt;code&gt;bg&lt;/code&gt; 및 &lt;code&gt;fg&lt;/code&gt; ) 이 제거됩니다 . 하나 이상의 &lt;code&gt;PID&lt;/code&gt; 가 지정되면 지정된 프로세스 ID를 가진 작업이 작업 목록에서 제거됩니다. 유효하지 않은 작업은 무시되고 경고가 인쇄됩니다.</target>
        </trans-unit>
        <trans-unit id="713bf8682430a51e2b7af1a6d836f8e75fd1bdaa" translate="yes" xml:space="preserve">
          <source>If no variable names are provided, &lt;code&gt;read&lt;/code&gt; enters a special case that simply provides redirection from standard input to standard output, useful for command substitution. For instance, the fish shell command below can be used to read data that should be provided via a command line argument from the console instead of hardcoding it in the command itself, allowing the command to both be reused as-is in various contexts with different input values and preventing possibly sensitive text from being included in the shell history:</source>
          <target state="translated">변수 이름이 제공되지 않으면 &lt;code&gt;read&lt;/code&gt; 는 표준 입력에서 표준 출력으로의 경로 재 지정을 제공하는 특수한 경우를 입력하여 명령 대체에 유용합니다. 예를 들어, 아래의 피쉬 쉘 명령을 사용하면 명령 자체에서 하드 코딩하는 대신 콘솔에서 명령 행 인수를 통해 제공해야하는 데이터를 읽을 수 있으므로 명령을 다른 컨텍스트에서 다양한 상황에서 그대로 재사용 할 수 있습니다 입력 값 및 민감한 텍스트가 쉘 히스토리에 포함되지 않도록 방지 :</target>
        </trans-unit>
        <trans-unit id="f6b617c0f8612fdf2ea16aba5ec62984acf5c44a" translate="yes" xml:space="preserve">
          <source>If only 123 and 789 exist, it will still background them and print an error about 456.</source>
          <target state="translated">123 및 789 만 존재하는 경우 여전히 백그라운드에서 456에 대한 오류를 인쇄합니다.</target>
        </trans-unit>
        <trans-unit id="e5b23704e06de8e7cf41b466203c3d1a05734047" translate="yes" xml:space="preserve">
          <source>If set is called with no arguments, the names and values of all shell variables are printed in sorted order. If some of the scope or export flags have been given, only the variables matching the specified scope are printed.</source>
          <target state="translated">인수없이 set을 호출하면 모든 쉘 변수의 이름과 값이 정렬 된 순서로 인쇄됩니다. 일부 범위 또는 내보내기 플래그가 제공된 경우 지정된 범위와 일치하는 변수 만 인쇄됩니다.</target>
        </trans-unit>
        <trans-unit id="302a7adb7b2bb424535b98eb0c4ef6539ea7cb20" translate="yes" xml:space="preserve">
          <source>If terminfo reports 256 color support for a terminal, support will always be enabled. To debug color palette problems, &lt;code&gt;tput colors&lt;/code&gt; may be useful to see the number of colors in terminfo for a terminal. Fish launched as &lt;code&gt;fish -d2&lt;/code&gt; will include diagnostic messages that indicate the color support mode in use.</source>
          <target state="translated">terminfo가 터미널에 대해 256 색 지원을보고하면 항상 지원이 활성화됩니다. 디버그 컬러 팔레트의 문제로 &lt;code&gt;tput colors&lt;/code&gt; 유용 할 수있는 터미널의 terminfo의 색상 수를 볼 수 있습니다. &lt;code&gt;fish -d2&lt;/code&gt; 로 시작된 물고기 에는 사용중인 색상 지원 모드를 나타내는 진단 메시지가 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="34986c35bab0e2df661c76619902534fb332f46c" translate="yes" xml:space="preserve">
          <source>If that directory traversal is taking a long time, you can &lt;em&gt;Control&lt;/em&gt;-&lt;b&gt;C&lt;/b&gt; out of it.</source>
          <target state="translated">해당 디렉토리 탐색에 시간이 오래 걸리면 &lt;em&gt;Control&lt;/em&gt; - &lt;b&gt;C&lt;/b&gt; 를 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="e3d023db5ee6df47941a2ca566209f059001722c" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;$VISUAL&lt;/code&gt; environment variable is set, it will be used as the program to edit the function. If &lt;code&gt;$VISUAL&lt;/code&gt; is unset but &lt;code&gt;$EDITOR&lt;/code&gt; is set, that will be used. Otherwise, a built-in editor will be used. Note that to enter a literal newline using the built-in editor you should press &lt;em&gt;Alt&lt;/em&gt;-&lt;b&gt;Enter&lt;/b&gt;. Pressing &lt;b&gt;Enter&lt;/b&gt; signals that you are done editing the function. This does not apply to an external editor like emacs or vim.</source>
          <target state="translated">는 IF &lt;code&gt;$VISUAL&lt;/code&gt; 환경 변수가 설정되어, 그것은 편집에 프로그램 기능으로 사용됩니다. 경우 &lt;code&gt;$VISUAL&lt;/code&gt; 설정되지하지만 &lt;code&gt;$EDITOR&lt;/code&gt; 설정, 즉 사용됩니다. 그렇지 않으면 내장 편집기가 사용됩니다. 내장 편집기를 사용하여 리터럴 개행을 입력하려면 &lt;em&gt;Alt&lt;/em&gt; - &lt;b&gt;Enter를 눌러야&lt;/b&gt; 합니다. &lt;b&gt;Enter를&lt;/b&gt; 누르면 기능 편집이 완료되었음을 알립니다. emacs 또는 vim과 같은 외부 편집기에는 적용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="e8fb943c750f92e3917384bc05f81b775bd8db88" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;--delimiter&lt;/code&gt; argument is not given, the variable &lt;code&gt;IFS&lt;/code&gt; is used as a list of characters to split on. Relying on the use of &lt;code&gt;IFS&lt;/code&gt; is deprecated and this behaviour will be removed in future versions. The default value of &lt;code&gt;IFS&lt;/code&gt; contains space, tab and newline characters. As a special case, if &lt;code&gt;IFS&lt;/code&gt; is set to the empty string, each character of the input is considered a separate token.</source>
          <target state="translated">경우 &lt;code&gt;--delimiter&lt;/code&gt; 인수가 주어지지, 변수 &lt;code&gt;IFS&lt;/code&gt; 는 에 분할하는 문자 목록으로 사용됩니다. &lt;code&gt;IFS&lt;/code&gt; 사용에 의존하는 것은 더 이상 사용되지 않으며이 기능 은 향후 버전에서 제거 될 것입니다. &lt;code&gt;IFS&lt;/code&gt; 의 기본값 은 공백, 탭 및 줄 바꾸기 문자를 포함합니다. 특별한 경우, &lt;code&gt;IFS&lt;/code&gt; 가 빈 문자열로 설정되면 입력의 각 문자는 별도의 토큰으로 간주됩니다.</target>
        </trans-unit>
        <trans-unit id="b9a1bc2ff2f56d3990f495529faa7ba44ead0455" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;-k&lt;/code&gt; switch is used, the name of the key (such as 'down', 'up' or 'backspace') is used instead of a sequence. The names used are the same as the corresponding curses variables, but without the 'key_' prefix. (See &lt;code&gt;terminfo(5)&lt;/code&gt; for more information, or use &lt;code&gt;bind --key-names&lt;/code&gt; for a list of all available named keys.) If used in conjunction with the &lt;code&gt;-s&lt;/code&gt; switch, &lt;code&gt;bind&lt;/code&gt; will silently ignore bindings to named keys that are not found in termcap for the current &lt;code&gt;$TERMINAL&lt;/code&gt;, otherwise a warning is emitted.</source>
          <target state="translated">경우] &lt;code&gt;-k&lt;/code&gt; 스위치가 사용된다 (예 : '아래', '업'또는 '백 스페이스 키')를 키 이름 대신 시퀀스로 사용된다. 사용 된 이름은 해당 curses 변수와 동일하지만 'key_'접두사가 없습니다. (자세한 내용은 &lt;code&gt;terminfo(5)&lt;/code&gt; 를 참조하거나 사용 가능한 모든 명명 된 키 목록을 보려면 &lt;code&gt;bind --key-names&lt;/code&gt; 를 사용하십시오.) &lt;code&gt;-s&lt;/code&gt; 스위치 와 함께 사용하면 &lt;code&gt;bind&lt;/code&gt; 는 발견되지 않은 명명 된 키에 대한 바인딩을 자동으로 무시합니다. 현재 &lt;code&gt;$TERMINAL&lt;/code&gt; 의 경우 termcap 에서 그렇지 않으면 경고가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="1d7b9b3be6cec368c8849bf11af8487da853a633" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;-l&lt;/code&gt; or &lt;code&gt;--list&lt;/code&gt; flag is specified, the current directory history is also displayed.</source>
          <target state="translated">는 IF &lt;code&gt;-l&lt;/code&gt; 또는 &lt;code&gt;--list&lt;/code&gt; 플래그가 지정되어, 현재 디렉토리의 역사도 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="4cfc35a3a98ed01dd389efdde71deb0bf3c6669a" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;-l&lt;/code&gt; or &lt;code&gt;--list&lt;/code&gt; flag is specified, the current history is also displayed.</source>
          <target state="translated">는 IF &lt;code&gt;-l&lt;/code&gt; 또는 &lt;code&gt;--list&lt;/code&gt; 플래그가 지정되어, 현재의 역사도 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="492a67bd7712dda8e66c7c5fc44c0836f4b18f3a" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;-n&lt;/code&gt; / &lt;code&gt;--any&lt;/code&gt; flag is provided, the command returns as soon as the first job completes. If it is not provided, it returns after all jobs complete.</source>
          <target state="translated">경우 &lt;code&gt;-n&lt;/code&gt; / &lt;code&gt;--any&lt;/code&gt; 플래그는 곧 첫 번째 작업이 완료로 명령 수익을 제공한다. 제공되지 않으면 모든 작업이 완료된 후 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="63b9207ee5d979afeb85211115a3c6ffa7012a71" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;/tmp&lt;/code&gt; directory exists, copy the &lt;code&gt;/etc/motd&lt;/code&gt; file to it:</source>
          <target state="translated">는 IF &lt;code&gt;/tmp&lt;/code&gt; 를 디렉토리가 존재, 복사 &lt;code&gt;/etc/motd&lt;/code&gt; 그것에 파일 :</target>
        </trans-unit>
        <trans-unit id="c3b856c7f49407f5bd18390ec22c0a975e0942a6" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;BROWSER&lt;/code&gt; environment variable is set, it will be used as the name of the web browser to open instead of the system default.</source>
          <target state="translated">경우 &lt;code&gt;BROWSER&lt;/code&gt; 의 환경 변수가 설정되고, 그 대신 시스템 기본으로 열려면 웹 브라우저의 이름으로 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="3debf54dad8f4dc6d939e041eacf2dbfc04ad3d0" translate="yes" xml:space="preserve">
          <source>If the BROWSER environment variable is set, it will be used to display the documentation. Otherwise, fish will search for a suitable browser.</source>
          <target state="translated">BROWSER 환경 변수가 설정된 경우 문서를 표시하는 데 사용됩니다. 그렇지 않으면 물고기는 적합한 브라우저를 검색합니다.</target>
        </trans-unit>
        <trans-unit id="aa6fc1ea4246a9f77c10ddff36e9849dd9022bcd" translate="yes" xml:space="preserve">
          <source>If the above code was run with &lt;code&gt;$animal&lt;/code&gt; set to &lt;code&gt;whale&lt;/code&gt;, the output would be &lt;code&gt;mammal&lt;/code&gt;.</source>
          <target state="translated">위의 코드를 &lt;code&gt;$animal&lt;/code&gt; 을 &lt;code&gt;whale&lt;/code&gt; 로 설정하여 실행 하면 결과는 &lt;code&gt;mammal&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="d75d0af6becad51e324987bba4dbf96c51e8300a" translate="yes" xml:space="preserve">
          <source>If the alias has the same name as the aliased command, it is necessary to prefix the call to the program with &lt;code&gt;command&lt;/code&gt; in order to tell fish that the function should not call itself, but rather a command with the same name. Failing to do so will cause infinite recursion bugs.</source>
          <target state="translated">별명이 별명 명령과 동일한 이름을 갖는 경우, 함수가 자신을 호출하지 말고 동일한 이름을 가진 명령을 피쉬에게 알리기 위해 &lt;code&gt;command&lt;/code&gt; 에 프로그램 호출을 접두어로 붙여야합니다 . 그렇지 않으면 무한 재귀 버그가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="ad3ed0aa46a2e24462a85265faa22a817cd5bf4f" translate="yes" xml:space="preserve">
          <source>If the argument you want is far back in history (e.g. 2 lines back - that's a lot of words!), type any part of it and then press &lt;em&gt;Alt&lt;/em&gt;-&lt;b&gt;&amp;uarr;&lt;/b&gt;. This will show only arguments containing that part and you will get what you want much faster. Try it out, this is very convenient!</source>
          <target state="translated">당신이 원하는 인수가 멀리 다시 역사의 경우 (예를 들어 다시 2 선! - 단어의 많은입니다), 어떤의 일부를 누른 다음를 누릅니다의 입력 &lt;em&gt;Alt 키&lt;/em&gt; - &lt;b&gt;&amp;uarr;&lt;/b&gt; . 여기에는 해당 부분이 포함 된 인수 만 표시되며 원하는 것을 훨씬 빨리 얻을 수 있습니다. 사용해보십시오, 이것은 매우 편리합니다!</target>
        </trans-unit>
        <trans-unit id="8b1303483eab8a0aafe5607e65c79febb8c3aca1" translate="yes" xml:space="preserve">
          <source>If the commandline contains</source>
          <target state="translated">명령 줄에</target>
        </trans-unit>
        <trans-unit id="4b1c190c6ad0436a0fd3fb383f1281a2e816bf89" translate="yes" xml:space="preserve">
          <source>If the commandline reads &lt;code&gt;cd m&lt;/code&gt;, place the cursor over the &lt;code&gt;m&lt;/code&gt; character and press &lt;em&gt;Alt&lt;/em&gt;-&lt;b&gt;&amp;uarr;&lt;/b&gt; to search for previously typed words containing 'm'.</source>
          <target state="translated">명령 줄 읽기 경우 &lt;code&gt;cd m&lt;/code&gt; 의 위에 커서를 올려 &lt;code&gt;m&lt;/code&gt; 의 문자를 눌러 &lt;em&gt;Alt 키&lt;/em&gt; - &lt;b&gt;&amp;uarr;&lt;/b&gt; 'm'을 포함하는 이전에 입력 된 단어를 검색 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="aec97b1cdbedc052d45f0ca8a3886ba07331192c" translate="yes" xml:space="preserve">
          <source>If the current directory contains the files 'foo' and 'bar', the command &lt;code&gt;echo a(ls){1,2,3}&lt;/code&gt; will output 'abar1 abar2 abar3 afoo1 afoo2 afoo3'.</source>
          <target state="translated">현재 디렉토리에 'foo'및 'bar'파일이 포함 된 경우 &lt;code&gt;echo a(ls){1,2,3}&lt;/code&gt; 명령 은 'abar1 abar2 abar3 afoo1 afoo2 afoo3'을 출력합니다.</target>
        </trans-unit>
        <trans-unit id="9ac01aa8bdf61c4705d1b573ca6b14e107487f86" translate="yes" xml:space="preserve">
          <source>If the expression is successfully evaluated and doesn't over/underflow or return NaN the return &lt;code&gt;status&lt;/code&gt; is zero (success) else one.</source>
          <target state="translated">식이 성공적으로 평가되고 오버플로 / 언더 플로 또는 NaN을 반환하지 않으면 반환 &lt;code&gt;status&lt;/code&gt; 는 0 (성공)입니다.</target>
        </trans-unit>
        <trans-unit id="5cfff00b5bb7a05a9b5b06be91a9cc46be32a1f7" translate="yes" xml:space="preserve">
          <source>If the first and second parts are skipped, they are assumed to be &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;=&lt;/code&gt;, respectively. As an example, &lt;code&gt;r,u+w&lt;/code&gt; means all users should have read access and the file owner should also have write access.</source>
          <target state="translated">첫 번째 부분과 두 번째 부분을 건너 뛰면 각각 &lt;code&gt;a&lt;/code&gt; 및 &lt;code&gt;=&lt;/code&gt; 로 간주됩니다 . 예를 들어, &lt;code&gt;r,u+w&lt;/code&gt; 는 모든 사용자에게 읽기 권한이 있어야하고 파일 소유자에게도 쓰기 권한이 있어야 함을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="154cdf4f784ed79e1fcb74335c0c901b6cf4ac90" translate="yes" xml:space="preserve">
          <source>If the line you want is far back in the history, type any part of the line and then press Up one or more times. This will constrain the recall to lines that include this text, and you will get to the line you want much faster. This replaces &quot;!vi&quot;, &quot;!?bar.c&quot; and the like.</source>
          <target state="translated">원하는 줄이 기록에서 훨씬 뒤로 돌아 오면 줄의 일부를 입력 한 다음 위로를 한 번 이상 누릅니다. 이렇게하면이 텍스트를 포함하는 줄로 리콜을 제한 할 수 있으며 원하는 줄로 훨씬 빨리 갈 수 있습니다. 이것은 &quot;! vi&quot;, &quot;!? bar.c&quot;등을 대체합니다.</target>
        </trans-unit>
        <trans-unit id="70006a59c6935a4438f9d0040be162c8ee9ec5a8" translate="yes" xml:space="preserve">
          <source>If the list is visible, pressing control-S (or the &lt;code&gt;pager-toggle-search&lt;/code&gt; binding) will allow filtering the list. Shift-tab (or the &lt;code&gt;complete-and-search&lt;/code&gt; binding) will trigger completion with the search field immediately visible.</source>
          <target state="translated">목록이 표시되면 control-S (또는 &lt;code&gt;pager-toggle-search&lt;/code&gt; 바인딩)를 누르면 목록을 필터링 할 수 있습니다. Shift- 탭 (또는 &lt;code&gt;complete-and-search&lt;/code&gt; 바인딩)은 검색 필드가 즉시 보이는 상태에서 완료를 트리거합니다.</target>
        </trans-unit>
        <trans-unit id="e4c01f00f1709a1d845be8af766e2896516906fa" translate="yes" xml:space="preserve">
          <source>If the path is invalid no translated path will be written to stdout and an error will be reported.</source>
          <target state="translated">경로가 유효하지 않으면 변환 된 경로가 stdout에 기록되지 않고 오류가보고됩니다.</target>
        </trans-unit>
        <trans-unit id="e907fd3510899683ab1ac3f96d2aac1979d9258b" translate="yes" xml:space="preserve">
          <source>If the specified file descriptor is a tty, the exit status of the command is zero. Otherwise, the exit status is non-zero. No messages are printed to standard error.</source>
          <target state="translated">지정된 파일 디스크립터가 tty이면 명령의 종료 상태는 0입니다. 그렇지 않으면 종료 상태는 0이 아닙니다. 표준 오류로 인쇄 된 메시지가 없습니다.</target>
        </trans-unit>
        <trans-unit id="bd0e2ed527cbeaac8bf34e5481dc729ba00211c1" translate="yes" xml:space="preserve">
          <source>If the user enters any additional arguments after the function, they are inserted into the environment &lt;a href=&quot;index#variables-arrays&quot;&gt;variable array&lt;/a&gt;&lt;code&gt;$argv&lt;/code&gt;. If the &lt;code&gt;--argument-names&lt;/code&gt; option is provided, the arguments are also assigned to names specified in that option.</source>
          <target state="translated">사용자가 함수 뒤에 추가 인수를 입력하면 환경 &lt;a href=&quot;index#variables-arrays&quot;&gt;변수 배열 &lt;/a&gt; &lt;code&gt;$argv&lt;/code&gt; 삽입됩니다 . 는 IF &lt;code&gt;--argument-names&lt;/code&gt; 옵션이 제공되며, 인수는 그 옵션에 지정된 이름에 할당됩니다.</target>
        </trans-unit>
        <trans-unit id="89093e95575f5c91e69c231cc514a5f888c355b9" translate="yes" xml:space="preserve">
          <source>If the variable $animal contains the name of an animal, the following code would attempt to classify it:</source>
          <target state="translated">변수 $ animal에 동물의 이름이 포함되어 있으면 다음 코드는이를 분류하려고 시도합니다.</target>
        </trans-unit>
        <trans-unit id="081ef0f3bbeaf93e50b97aca197ba4dab7103ab9" translate="yes" xml:space="preserve">
          <source>If the variable &lt;code&gt;MANPATH&lt;/code&gt; is defined and not empty, print the contents. (If &lt;code&gt;MANPATH&lt;/code&gt; is not defined, then it will expand to zero arguments, unless quoted.)</source>
          <target state="translated">변수 &lt;code&gt;MANPATH&lt;/code&gt; 가 정의되어 있고 비어 있지 않은 경우 내용을 인쇄하십시오. ( &lt;code&gt;MANPATH&lt;/code&gt; 가 정의되어 있지 않으면 인용되지 않는 한 인수가 0으로 확장됩니다.)</target>
        </trans-unit>
        <trans-unit id="b85b340b71b7dd9ea477da93a9f45e28372572db" translate="yes" xml:space="preserve">
          <source>If the variable name is one or more array elements, such as &lt;code&gt;PATH[1 3 7]&lt;/code&gt;, only those array elements specified will be changed. If you specify a negative index when expanding or assigning to an array variable, the index will be calculated from the end of the array. For example, the index -1 means the last index of an array.</source>
          <target state="translated">변수 이름이 하나 이상의 배열 요소 (예 : &lt;code&gt;PATH[1 3 7]&lt;/code&gt; 이면 지정된 배열 요소 만 변경됩니다. 배열 변수를 확장하거나 할당 할 때 음수 인덱스를 지정하면 배열 끝에서 인덱스가 계산됩니다. 예를 들어, 인덱스 -1은 배열의 마지막 인덱스를 의미합니다.</target>
        </trans-unit>
        <trans-unit id="788fcc2dc7b9ec9c743aa985b73d706a1c941ace" translate="yes" xml:space="preserve">
          <source>If there are multiple files with the same name in these directories, only the first will be executed. They are executed in order of their filename, sorted (like globs) in a natural order (i.e. &quot;01&quot; sorts before &quot;2&quot;).</source>
          <target state="translated">이 디렉토리에 이름이 같은 파일이 여러 개 있으면 첫 번째 파일 만 실행됩니다. 파일 이름 순서대로 실행되며 (예 : glob와 같이) 자연 순서로 정렬됩니다 (예 : &quot;01&quot;은 &quot;2&quot;앞에 정렬).</target>
        </trans-unit>
        <trans-unit id="37b3f6c1d9e2443aab8662a7a439797d66881a18" translate="yes" xml:space="preserve">
          <source>If there is no function called &lt;code&gt;NAME&lt;/code&gt; a new function will be created with the specified name</source>
          <target state="translated">&lt;code&gt;NAME&lt;/code&gt; 이라는 함수가 없으면 지정된 이름으로 새 함수가 작성됩니다.</target>
        </trans-unit>
        <trans-unit id="6d5cfe09681412194f4ba98b5cd9ee3fb9a19be4" translate="yes" xml:space="preserve">
          <source>If there is nothing between a brace and a comma or two commas, it's interpreted as an empty element.</source>
          <target state="translated">중괄호와 쉼표 또는 두 개의 쉼표 사이에 아무 것도 없으면 빈 요소로 해석됩니다.</target>
        </trans-unit>
        <trans-unit id="afe6214497e3e493ce7fed66861473c8f9d5c2d3" translate="yes" xml:space="preserve">
          <source>If there's more than one possibility, it will list them:</source>
          <target state="translated">둘 이상의 가능성이있는 경우 다음이 나열됩니다.</target>
        </trans-unit>
        <trans-unit id="1b4ecf432926bdf9219384030390dce4a62ae339" translate="yes" xml:space="preserve">
          <source>If you are developing another program and would like to ship completions with your program, install them to the &quot;vendor&quot; completions directory. As this path may vary from system to system, the &lt;code&gt;pkgconfig&lt;/code&gt; framework should be used to discover this path with the output of &lt;code&gt;pkg-config --variable completionsdir fish&lt;/code&gt;.</source>
          <target state="translated">다른 프로그램을 개발 중이고 프로그램과 함께 완성품을 배송하려면 &quot;공급 업체&quot;완성 디렉토리에 설치하십시오. 이 경로는 시스템마다 다를 수 있으므로 &lt;code&gt;pkgconfig&lt;/code&gt; 프레임 워크를 사용하여 &lt;code&gt;pkg-config --variable completionsdir fish&lt;/code&gt; 의 출력으로이 경로를 발견해야합니다 .</target>
        </trans-unit>
        <trans-unit id="a2e3bcc2c86a34d726c99da6041e118aebc6aab5" translate="yes" xml:space="preserve">
          <source>If you are developing another program, you may wish to install configuration which is run for all users of the fish shell on a system. This is discouraged; if not carefully written, they may have side-effects or slow the startup of the shell. Additionally, users of other shells will not benefit from the Fish-specific configuration. However, if they are absolutely required, you may install them to the &quot;vendor&quot; configuration directory. As this path may vary from system to system, the &lt;code&gt;pkgconfig&lt;/code&gt; framework should be used to discover this path with the output of &lt;code&gt;pkg-config --variable confdir fish&lt;/code&gt;.</source>
          <target state="translated">다른 프로그램을 개발하는 경우 시스템에서 모든 피쉬 쉘 사용자에게 실행되는 구성을 설치하려고 할 수 있습니다. 이것은 권장되지 않습니다. 주의해서 쓰지 않으면 부작용이 있거나 쉘 시작 속도가 느려질 수 있습니다. 또한 다른 쉘 사용자는 물고기 별 구성의 이점을 얻지 못합니다. 그러나 반드시 필요한 경우 &quot;공급 업체&quot;구성 디렉토리에 설치할 수 있습니다. 이 경로는 시스템마다 다를 수 있으므로 &lt;code&gt;pkgconfig&lt;/code&gt; 프레임 워크를 사용하여 &lt;code&gt;pkg-config --variable confdir fish&lt;/code&gt; 출력으로이 경로를 검색해야합니다 .</target>
        </trans-unit>
        <trans-unit id="4916db32b6aa8cbf9c1ffbb01d73d5df4a8870cc" translate="yes" xml:space="preserve">
          <source>If you are developing another program, you may wish to install functions which are available for all users of the fish shell on a system. They can be installed to the &quot;vendor&quot; functions directory. As this path may vary from system to system, the &lt;code&gt;pkgconfig&lt;/code&gt; framework should be used to discover this path with the output of &lt;code&gt;pkg-config --variable functionsdir fish&lt;/code&gt;.</source>
          <target state="translated">다른 프로그램을 개발하는 경우 시스템에서 모든 피쉬 쉘 사용자가 사용할 수있는 기능을 설치할 수 있습니다. &quot;공급 업체&quot;기능 디렉토리에 설치할 수 있습니다. 이 경로는 시스템마다 다를 수 있으므로 &lt;code&gt;pkgconfig&lt;/code&gt; 프레임 워크를 사용하여 &lt;code&gt;pkg-config --variable functionsdir fish&lt;/code&gt; 의 출력으로이 경로를 발견해야합니다 .</target>
        </trans-unit>
        <trans-unit id="2c8709afb8c37b08fcb75856aca6d9778e8772cd" translate="yes" xml:space="preserve">
          <source>If you are just interested in success or failure, you can run the command directly as the if-condition:</source>
          <target state="translated">성공 또는 실패에 관심이있는 경우 if 조건으로 명령을 직접 실행할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6b4679db7ed1ee15be09b7a815eb852cdada744e" translate="yes" xml:space="preserve">
          <source>If you do not use any brackets, all the elements of the array will be written as separate items. This means you can easily iterate over an array using this syntax:</source>
          <target state="translated">대괄호를 사용하지 않으면 배열의 모든 요소가 별도의 항목으로 작성됩니다. 이는 다음 구문을 사용하여 배열을 쉽게 반복 할 수 있음을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="21121c72874a1f506d3167db9734fb72635e8aba" translate="yes" xml:space="preserve">
          <source>If you do this via a function it should be defined with the &lt;code&gt;--no-scope-shadowing&lt;/code&gt; flag. Otherwise it won't have access to those variables.</source>
          <target state="translated">함수를 통해이를 수행하는 경우 &lt;code&gt;--no-scope-shadowing&lt;/code&gt; 플래그 로 정의해야합니다 . 그렇지 않으면 해당 변수에 액세스 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="76fc284188c8102e752b1bddb9f0226a85c1fbff" translate="yes" xml:space="preserve">
          <source>If you have a question not answered by this documentation, there are several avenues for help:</source>
          <target state="translated">이 문서에서 질문에 대한 답변을 얻지 못한 경우 몇 가지 도움이 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d5d69fd8cf3faf8da11aa1c87838469a40522c72" translate="yes" xml:space="preserve">
          <source>If you have a strong understanding of other shells, and want to know what &lt;code&gt;fish&lt;/code&gt; does differently, search for the magic phrase &lt;em&gt;unlike other shells&lt;/em&gt;, which is used to call out important differences.</source>
          <target state="translated">다른 껍질에 대해 잘 알고 있고 &lt;code&gt;fish&lt;/code&gt; 가 어떻게 다른지 알고 싶다면 &lt;em&gt;다른 껍질과 달리&lt;/em&gt; 마법의 문구를 검색하십시오.이 문구 &lt;em&gt;는&lt;/em&gt; 중요한 차이점을 불러내는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="d94e356f3d06bfc0847471bd8ac63c7fdd35e968" translate="yes" xml:space="preserve">
          <source>If you have an improvement for fish, you can submit it via the mailing list or the GitHub page.</source>
          <target state="translated">생선이 개선 된 경우 메일 링리스트 또는 GitHub 페이지를 통해 생선을 제출할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3c91aaa3641347d6b92a729c32a7d96c010b6da2" translate="yes" xml:space="preserve">
          <source>If you have written new completions for a common Unix command, please consider sharing your work by submitting it via the instructions in &lt;a href=&quot;#more-help&quot;&gt;Further help and development&lt;/a&gt;.</source>
          <target state="translated">공통 Unix 명령에 대한 새로운 완성을 작성했다면 &lt;a href=&quot;#more-help&quot;&gt;추가 도움말 및 개발&lt;/a&gt; 의 지시 사항을 통해 작업을 제출하여 작업을 공유하십시오 .</target>
        </trans-unit>
        <trans-unit id="801a4bfeff44c78289adc6da559907889b10b7ff" translate="yes" xml:space="preserve">
          <source>If you installed a prepackaged version of fish, the package manager should have already done this for you.</source>
          <target state="translated">사전 패키지 버전의 물고기를 설치 한 경우 패키지 관리자가 이미이를 수행 했어야합니다.</target>
        </trans-unit>
        <trans-unit id="bacc9cf3f5b8aece5e2cb795329bd9e98f414229" translate="yes" xml:space="preserve">
          <source>If you installed fish manually (e.g. by compiling it, not by using a package manager), you first need to add fish to the list of shells by executing the following command (assuming you installed fish in /usr/local):</source>
          <target state="translated">물고기를 수동으로 설치 한 경우 (예 : 패키지 관리자를 사용하지 않고 컴파일하여), / usr / local에 물고기를 설치했다고 가정하면 먼저 다음 명령을 실행하여 쉘 목록에 물고기를 추가해야합니다.</target>
        </trans-unit>
        <trans-unit id="24dbcaa65ea45136e4556660a86f87890a258184" translate="yes" xml:space="preserve">
          <source>If you instead want to put a suspended job into the background, use the &lt;a href=&quot;commands#bg&quot;&gt;&lt;code&gt;bg&lt;/code&gt;&lt;/a&gt; command.</source>
          <target state="translated">대신 일시 중단 된 작업을 백그라운드에 배치하려면 &lt;a href=&quot;commands#bg&quot;&gt; &lt;code&gt;bg&lt;/code&gt; &lt;/a&gt; 명령을 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="76575622923fc6960275a0372650f7e641f7d23c" translate="yes" xml:space="preserve">
          <source>If you prefer to use a different browser (other than as described above) for fish help, you can set the fish_help_browser variable. This variable may be set as an array, where the first element is the browser command and the rest are browser options.</source>
          <target state="translated">물고기 도움말에 다른 브라우저 (위에서 설명한 것 이외의)를 사용하려면 fish_help_browser 변수를 설정할 수 있습니다. 이 변수는 배열로 설정 될 수 있습니다. 여기서 첫 번째 요소는 브라우저 명령이고 나머지는 브라우저 옵션입니다.</target>
        </trans-unit>
        <trans-unit id="6b10dc2d52b83a3f3bcbb9eafde410131a7638e1" translate="yes" xml:space="preserve">
          <source>If you specify a negative index when expanding or assigning to an array variable, the index will be calculated from the end of the array. For example, the index -1 means the last index of an array.</source>
          <target state="translated">배열 변수를 확장하거나 할당 할 때 음수 인덱스를 지정하면 배열 끝에서 인덱스가 계산됩니다. 예를 들어, 인덱스 -1은 배열의 마지막 인덱스를 의미합니다.</target>
        </trans-unit>
        <trans-unit id="bef2a5da408bc0ccc604bb6e7c2ada1e1e368d28" translate="yes" xml:space="preserve">
          <source>If you specify both &lt;code&gt;--prefix&lt;/code&gt; and &lt;code&gt;--contains&lt;/code&gt; the last flag seen is used.</source>
          <target state="translated">&lt;code&gt;--prefix&lt;/code&gt; 와 &lt;code&gt;--contains&lt;/code&gt; 를 모두 지정 하면 마지막으로 본 플래그가 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="cfeb5cfbb4d7330298cd9ae2e7db448aa2300961" translate="yes" xml:space="preserve">
          <source>If you specify the &lt;code&gt;-e&lt;/code&gt; or &lt;code&gt;--entire&lt;/code&gt; then each matching string is printed including any prefix or suffix not matched by the pattern (equivalent to &lt;code&gt;grep&lt;/code&gt; without the &lt;code&gt;-o&lt;/code&gt; flag). You can, obviously, achieve the same result by prepending and appending &lt;code&gt;*&lt;/code&gt; or &lt;code&gt;.*&lt;/code&gt; depending on whether or not you have specified the &lt;code&gt;--regex&lt;/code&gt; flag. The &lt;code&gt;--entire&lt;/code&gt; flag is simply a way to avoid having to complicate the pattern in that fashion and make the intent of the &lt;code&gt;string match&lt;/code&gt; clearer. Without &lt;code&gt;--entire&lt;/code&gt; and &lt;code&gt;--regex&lt;/code&gt;, a PATTERN will need to match the entire STRING before it will be reported.</source>
          <target state="translated">&lt;code&gt;-e&lt;/code&gt; 또는 &lt;code&gt;--entire&lt;/code&gt; 를 지정하면 패턴과 일치하지 않는 접 두부 또는 접미 부를 포함하여 각 일치하는 문자열이 인쇄됩니다 ( &lt;code&gt;-o&lt;/code&gt; 플래그 없이 &lt;code&gt;grep&lt;/code&gt; 과 동일 함 ). &lt;code&gt;--regex&lt;/code&gt; 플래그를 지정했는지 여부에 따라 &lt;code&gt;*&lt;/code&gt; 또는 &lt;code&gt;.*&lt;/code&gt; 를 앞에 추가하고 추가하여 동일한 결과를 얻을 수 있습니다 . &lt;code&gt;--entire&lt;/code&gt; 플래그는 단순히 패션의 패턴을 복잡하게하고의 의도 할 필요가 없도록하는 방법입니다 &lt;code&gt;string match&lt;/code&gt; 명확. &lt;code&gt;--entire&lt;/code&gt; 및 &lt;code&gt;--regex&lt;/code&gt; 가 없으면 PATTERN이 (가)보고되기 전에 전체 STRING과 일치해야합니다.</target>
        </trans-unit>
        <trans-unit id="22a9feadf64d822a318f10f2b4793d1a2316c159" translate="yes" xml:space="preserve">
          <source>If you specify the &lt;code&gt;-f&lt;/code&gt; or &lt;code&gt;--filter&lt;/code&gt; flag then each input string is printed only if a replacement was done. This is useful where you would otherwise use this idiom: &lt;code&gt;a_cmd | string match pattern | string replace pattern new_pattern&lt;/code&gt;. You can instead just write &lt;code&gt;a_cmd | string replace --filter pattern new_pattern&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;-f&lt;/code&gt; 또는 &lt;code&gt;--filter&lt;/code&gt; 플래그를 지정하면 교체가 완료된 경우에만 각 입력 문자열이 인쇄됩니다. 이 관용구를 다르게 사용하는 경우에 유용합니다. &lt;code&gt;a_cmd | string match pattern | string replace pattern new_pattern&lt;/code&gt; . 대신 &lt;code&gt;a_cmd | string replace --filter pattern new_pattern&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d8e54ae0a24762829d8f55a86df97428a46a48f0" translate="yes" xml:space="preserve">
          <source>If you want to add the directory &lt;code&gt;~/linux/bin&lt;/code&gt; to your PATH variable when using a login shell, add the following to your &lt;code&gt;~/.config/fish/config.fish&lt;/code&gt; file:</source>
          <target state="translated">로그인 쉘을 사용할 때 &lt;code&gt;~/linux/bin&lt;/code&gt; 디렉토리 를 PATH 변수에 추가하려면 &lt;code&gt;~/.config/fish/config.fish&lt;/code&gt; 파일에 다음을 추가 하십시오.</target>
        </trans-unit>
        <trans-unit id="3226bbbfea92d52214a04066c17b75561d8b1dfd" translate="yes" xml:space="preserve">
          <source>If you want to find out more about the echo command used above, read the manual page for the echo command by writing: &lt;code&gt;man echo&lt;/code&gt;</source>
          <target state="translated">위에서 사용한 echo 명령에 대한 자세한 내용을 보려면 다음을 작성하여 echo 명령 매뉴얼 페이지를 읽으십시오. &lt;code&gt;man echo&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="f6b8934a463057ab4cbebc293cbcc2bde13fda93" translate="yes" xml:space="preserve">
          <source>If you want to learn more about fish, there is &lt;a href=&quot;index&quot;&gt;lots of detailed documentation&lt;/a&gt;, an &lt;a href=&quot;https://lists.sourceforge.net/lists/listinfo/fish-users&quot;&gt;official mailing list&lt;/a&gt;, the IRC channel #fish on &lt;code&gt;irc.oftc.net&lt;/code&gt;, and the &lt;a href=&quot;https://github.com/fish-shell/fish-shell/&quot;&gt;github page&lt;/a&gt;.</source>
          <target state="translated">당신이 물고기에 대한 자세한 내용을 원한다면,이 &lt;a href=&quot;index&quot;&gt;자세한 설명서를 많이&lt;/a&gt; , &lt;a href=&quot;https://lists.sourceforge.net/lists/listinfo/fish-users&quot;&gt;공식 메일 링리스트&lt;/a&gt; ,에 IRC 채널 #fish &lt;code&gt;irc.oftc.net&lt;/code&gt; 및 &lt;a href=&quot;https://github.com/fish-shell/fish-shell/&quot;&gt;GitHub의 페이지&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="19d1a8c24236cf7d05190b1115ef30aaad303cfb" translate="yes" xml:space="preserve">
          <source>If you want to make your command line more productive, more useful, and more fun, without learning a bunch of arcane syntax and configuration options, then &lt;code&gt;fish&lt;/code&gt; might be just what you're looking for!</source>
          <target state="translated">여러 가지 구문과 구성 옵션을 배우지 않고 명령 줄을보다 생산적이고 유용하고 재미있게 만들고 싶다면 &lt;code&gt;fish&lt;/code&gt; 가 원하는 것일 수 있습니다!</target>
        </trans-unit>
        <trans-unit id="817bbc583c325d82f70d5e4e389c9fb588a7021e" translate="yes" xml:space="preserve">
          <source>If you want to reuse several arguments from the same line (&quot;!!:3*&quot; and the like), consider recalling the whole line and removing what you don't need (&lt;em&gt;Alt&lt;/em&gt;-&lt;b&gt;D&lt;/b&gt; and &lt;em&gt;Alt&lt;/em&gt;-&lt;b&gt;Backspace&lt;/b&gt; are your friends).</source>
          <target state="translated">같은 라인에서 여러 인수를 재사용 할 경우 ( &quot;! : 3 *&quot;등), 전체 라인을 리콜하고 필요없는 것을 제거하십시오 ( &lt;em&gt;Alt 키&lt;/em&gt; - &lt;b&gt;D&lt;/b&gt; 와 &lt;em&gt;Alt 키&lt;/em&gt; - &lt;b&gt;백 스페이스&lt;/b&gt; 당신의 친구를).</target>
        </trans-unit>
        <trans-unit id="17b2c50714eca6eb3a1c4f418309af6c45fec63f" translate="yes" xml:space="preserve">
          <source>If you want to run a set of commands when &lt;code&gt;fish&lt;/code&gt; exits, use an &lt;a href=&quot;#event&quot;&gt;event handler&lt;/a&gt; that is triggered by the exit of the shell:</source>
          <target state="translated">&lt;code&gt;fish&lt;/code&gt; 종료 될 때 일련의 명령을 실행 하려면 쉘 종료에 의해 트리거되는 &lt;a href=&quot;#event&quot;&gt;이벤트 핸들러&lt;/a&gt; 를 사용 하십시오.</target>
        </trans-unit>
        <trans-unit id="840dcfc4db83e11261bb160a1f0912d853943c4b" translate="yes" xml:space="preserve">
          <source>If you wish to use fish (or any other shell) as your default shell, you need to enter your new shell's executable &lt;code&gt;/usr/local/bin/fish&lt;/code&gt; in two places:</source>
          <target state="translated">피쉬 (또는 다른 쉘)를 기본 쉘로 사용하려면 새 쉘의 실행 파일 &lt;code&gt;/usr/local/bin/fish&lt;/code&gt; 를 두 곳에 입력해야 합니다.</target>
        </trans-unit>
        <trans-unit id="3a88aaa448eb4ccc5d7c16b222b1aaafa2e3553e" translate="yes" xml:space="preserve">
          <source>If your command does not need access to stdin, consider using &lt;code&gt;source&lt;/code&gt; instead.</source>
          <target state="translated">명령에 stdin에 액세스 할 필요가 없으면 대신 &lt;code&gt;source&lt;/code&gt; 를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="20b7e02e5dced2f235b74397e5dd8fd6678ecaa1" translate="yes" xml:space="preserve">
          <source>If, in the example above, $WORD is undefined or an empty list, the &quot;s&quot; is not printed. However, it is printed, if $WORD is the empty string.</source>
          <target state="translated">위의 예에서 $ WORD가 정의되지 않았거나 빈 목록이면 &quot;s&quot;가 인쇄되지 않습니다. 그러나 $ WORD가 빈 문자열이면 인쇄됩니다.</target>
        </trans-unit>
        <trans-unit id="cd4f982a2dfbfb7a494a0fcc11edc18044fd3ee7" translate="yes" xml:space="preserve">
          <source>Import the abbreviations defined on another_host over SSH.</source>
          <target state="translated">SSH를 통해 another_host에 정의 된 약어를 ​​가져 오십시오.</target>
        </trans-unit>
        <trans-unit id="99b7d1b47f67f33906cafe0ea45bb9a7ae9de792" translate="yes" xml:space="preserve">
          <source>In addition, when adding abbreviations:</source>
          <target state="translated">또한 약어를 추가 할 때 :</target>
        </trans-unit>
        <trans-unit id="b11dd25d3b50e779c52a3bed6755a9de86e7cc31" translate="yes" xml:space="preserve">
          <source>In assignment mode, &lt;code&gt;set&lt;/code&gt; does not modify the exit status. This allows simultaneous capture of the output and exit status of a subcommand, e.g. &lt;code&gt;if set output (command)&lt;/code&gt;. In query mode, the exit status is the number of variables that were not found. In erase mode, &lt;code&gt;set&lt;/code&gt; exits with a zero exit status in case of success, with a non-zero exit status if the commandline was invalid, if the variable was write-protected or if the variable did not exist.</source>
          <target state="translated">할당 모드에서 &lt;code&gt;set&lt;/code&gt; 은 종료 상태를 수정하지 않습니다. 예를 들어 &lt;code&gt;if set output (command)&lt;/code&gt; 과 같은 하위 명령의 출력 및 종료 상태를 동시에 캡처 할 수 있습니다 . 쿼리 모드에서 종료 상태는 찾을 수없는 변수의 수입니다. 삭제 모드에서 &lt;code&gt;set&lt;/code&gt; 변수가 존재하지 않은 경우 변수가 쓰기 금지했다 경우 또는 0이 아닌 종료 상태 성공의 경우 제로 (0) 종료 상태로 종료는 명령 줄은 유효합니다.</target>
        </trans-unit>
        <trans-unit id="997bbb76e726398decafa893aef44209d89a5923" translate="yes" xml:space="preserve">
          <source>In bash, this would have created two directories &quot;Mister&quot; and &quot;Noodle&quot;. In &lt;code&gt;fish&lt;/code&gt;, it created only one: the variable had the value &quot;Mister Noodle&quot;, so that is the argument that was passed to &lt;code&gt;mkdir&lt;/code&gt;, spaces and all. Other shells use the term &quot;arrays&quot;, rather than lists.</source>
          <target state="translated">bash에서 이것은 &quot;Mister&quot;와 &quot;Noodle&quot;이라는 두 디렉토리를 만들었을 것이다. 에서 &lt;code&gt;fish&lt;/code&gt; , 그것은 단지 하나 만들어 : 그에게 전달 된 인수 그래서 변수가 값 &quot;미스터 국수&quot;를했다 &lt;code&gt;mkdir&lt;/code&gt; , 공간과 모든. 다른 쉘은 목록이 아닌 &quot;배열&quot;이라는 용어를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="febdce18a02406c3f663a8114d7d2b52f9d2f956" translate="yes" xml:space="preserve">
          <source>In cases such as this, one can use &lt;code&gt;command&lt;/code&gt;&lt;code&gt;test&lt;/code&gt; to explicitly use the system's standalone &lt;code&gt;test&lt;/code&gt; rather than this &lt;code&gt;builtin&lt;/code&gt;&lt;code&gt;test&lt;/code&gt;.</source>
          <target state="translated">이와 같은 경우, 이 &lt;code&gt;builtin&lt;/code&gt; &lt;code&gt;test&lt;/code&gt; 대신 &lt;code&gt;command&lt;/code&gt; &lt;code&gt;test&lt;/code&gt; 를 사용하여 시스템의 독립형 &lt;code&gt;test&lt;/code&gt; 를 명시 적으로 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="8150d5ade4961a7346cfe9d6f7af40451a0e9eba" translate="yes" xml:space="preserve">
          <source>In erase mode, if variable indices are specified, only the specified slices of the array variable will be erased.</source>
          <target state="translated">소거 모드에서 변수 인덱스를 지정하면 지정된 배열 변수 슬라이스 만 지워집니다.</target>
        </trans-unit>
        <trans-unit id="d285383bee7174093582f84311886d8e77b2597e" translate="yes" xml:space="preserve">
          <source>In fish versions prior to 2.3.0 the &lt;code&gt;$argv&lt;/code&gt; variable would have a single element (the name of the sourced file) if no arguments are present. Otherwise it would contain arguments without the name of the sourced file. That behavior was very confusing and unlike other shells such as bash and zsh.</source>
          <target state="translated">2.3.0 이전의 피쉬 버전에서 &lt;code&gt;$argv&lt;/code&gt; 변수는 인수가 없으면 단일 요소 (소스 파일의 이름)를 갖습니다. 그렇지 않으면 소스 파일 이름이없는 인수가 포함됩니다. 이 동작은 매우 혼란스럽고 bash 및 zsh와 같은 다른 쉘과는 다릅니다.</target>
        </trans-unit>
        <trans-unit id="b6167c9c2e21f8c5d664cda565772acda6aa5a44" translate="yes" xml:space="preserve">
          <source>In fish versions prior to 2.5.0 it was possible to create a function named &lt;code&gt;-&lt;/code&gt; that would do &lt;code&gt;cd -&lt;/code&gt;. Changes in the 2.5.0 release included several bug fixes that enforce the rule that a bare hyphen is not a valid function (or variable) name. However, you can achieve the same effect via an abbreviation:</source>
          <target state="translated">2.5.0 이전의 어류 버전에서 &lt;code&gt;cd -&lt;/code&gt; 수행하는 &lt;code&gt;-&lt;/code&gt; 라는 함수를 작성할 수있었습니다 . 2.5.0 릴리스의 변경 사항에는 베어 하이픈이 유효한 함수 (또는 변수) 이름이 아닌 규칙을 시행하는 몇 가지 버그 수정이 포함되었습니다. 그러나 약어를 통해 동일한 효과를 얻을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c82580c4fc0344cd7e4b4c3bbc7ac9db12a80d91" translate="yes" xml:space="preserve">
          <source>In functions, &lt;code&gt;block&lt;/code&gt; can be useful while performing work that should not be interrupted by the shell.</source>
          <target state="translated">함수에서 &lt;code&gt;block&lt;/code&gt; 은 쉘에 의해 중단되지 않아야하는 작업을 수행하는 동안 유용 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="89ff03b555073b2736f671e958968657fb6eb4ed" translate="yes" xml:space="preserve">
          <source>In general, special characters are special by default, so &lt;code&gt;a+&lt;/code&gt; matches one or more &quot;a&quot;s, while &lt;code&gt;a\+&lt;/code&gt; matches an &quot;a&quot; and then a &quot;+&quot;. &lt;code&gt;(a+)&lt;/code&gt; matches one or more &quot;a&quot;s in a capturing group (&lt;code&gt;(?:XXXX)&lt;/code&gt; denotes a non-capturing group). For the replacement parameter of &lt;code&gt;replace&lt;/code&gt;, &lt;code&gt;$n&lt;/code&gt; refers to the n-th group of the match. In the match parameter, &lt;code&gt;\n&lt;/code&gt; (e.g. &lt;code&gt;\1&lt;/code&gt;) refers back to groups.</source>
          <target state="translated">일반적으로 특수 문자는 기본적으로 특수하므로 &lt;code&gt;a+&lt;/code&gt; 는 하나 이상의 &quot;a&quot; 와 일치하고 &lt;code&gt;a\+&lt;/code&gt; 는 &quot;a&quot;와 &quot;+&quot;와 일치합니다. &lt;code&gt;(a+)&lt;/code&gt; 는 캡처 그룹에서 하나 이상의 &quot;a&quot;와 일치합니다 ( &lt;code&gt;(?:XXXX)&lt;/code&gt; 는 캡처하지 않은 그룹을 나타냅니다). &lt;code&gt;replace&lt;/code&gt; 의 교체 매개 변수 에서 &lt;code&gt;$n&lt;/code&gt; 은 일치하는 n 번째 그룹을 나타냅니다. 일치 매개 변수에서 &lt;code&gt;\n&lt;/code&gt; (예 : &lt;code&gt;\1&lt;/code&gt; )은 그룹을 다시 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="52f151afd8c58f05083781d29e38adf8acc285ad" translate="yes" xml:space="preserve">
          <source>In order to change your default shell, type:</source>
          <target state="translated">기본 쉘을 변경하려면 다음을 입력하십시오.</target>
        </trans-unit>
        <trans-unit id="7744f887d10f15ca76ae2472bb145fdd5fdbdb57" translate="yes" xml:space="preserve">
          <source>In order to protect the shell from consuming too many system resources, &lt;code&gt;read&lt;/code&gt; will only consume a maximum of 10 MiB (1048576 bytes); if the terminator is not reached before this limit then VARIABLE is set to empty and the exit status is set to 122. This limit can be altered with the &lt;code&gt;fish_read_limit&lt;/code&gt; variable. If set to 0 (zero), the limit is removed.</source>
          <target state="translated">쉘이 너무 많은 시스템 자원을 사용하지 않도록 보호하기 위해 &lt;code&gt;read&lt;/code&gt; 는 최대 10MiB (1048576 바이트) 만 소비합니다. 이 한계 이전에 종결자가 도달하지 않으면 VARIABLE은 비어 있으며 종료 상태는 122로 설정됩니다.이 한계는 &lt;code&gt;fish_read_limit&lt;/code&gt; 변수를 사용하여 변경할 수 있습니다 . 0으로 설정하면 한계가 제거됩니다.</target>
        </trans-unit>
        <trans-unit id="cfb4b17946050d9f509c4bdb763f770ebb06687a" translate="yes" xml:space="preserve">
          <source>In query mode, the scope to be examined can be specified.</source>
          <target state="translated">쿼리 모드에서 검사 할 범위를 지정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="89d4f28841a1759ddcc1b8894ac4045a23593691" translate="yes" xml:space="preserve">
          <source>In the following code, all output is redirected to the file out.html.</source>
          <target state="translated">다음 코드에서 모든 출력은 out.html 파일로 리디렉션됩니다.</target>
        </trans-unit>
        <trans-unit id="67bf59485bd852b33bf0045b83854687c5fd2923" translate="yes" xml:space="preserve">
          <source>In the following examples if a flag is not seen when parsing the arguments then the corresponding _flag_X var(s) will not be set.</source>
          <target state="translated">다음 예제에서 인수를 구문 분석 할 때 플래그가 표시되지 않으면 해당 _flag_X var (s)가 설정되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="b18679bb485a969aa3729a892fbc342e477da1e5" translate="yes" xml:space="preserve">
          <source>In the overwhelming majority of cases, splitting on spaces is unwanted, so this is an improvement.</source>
          <target state="translated">압도적 인 대다수의 경우 공간 분할은 바람직하지 않으므로 개선입니다.</target>
        </trans-unit>
        <trans-unit id="40d4bef31048f07adb0a3c1f574c30c70992f0e5" translate="yes" xml:space="preserve">
          <source>In these cases use &lt;code&gt;string split &quot; &quot;&lt;/code&gt; like:</source>
          <target state="translated">이 경우 &lt;code&gt;string split &quot; &quot;&lt;/code&gt; 과 같이 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="e86e38a4028df2e1d281758cf65343b3a55357c4" translate="yes" xml:space="preserve">
          <source>In these cases, the expansion eliminates the string, as a result of the implicit &lt;a href=&quot;#cartesian-product&quot;&gt;cartesian product&lt;/a&gt;.</source>
          <target state="translated">이러한 경우 확장은 암시 적 &lt;a href=&quot;#cartesian-product&quot;&gt;카티 전 곱&lt;/a&gt; 의 결과로 문자열을 제거합니다 .</target>
        </trans-unit>
        <trans-unit id="a96781a5a37dbe8375812a63f70f63e6201fe8ae" translate="yes" xml:space="preserve">
          <source>Incorrect use of output redirects</source>
          <target state="translated">출력 리디렉션의 잘못된 사용</target>
        </trans-unit>
        <trans-unit id="00039aeb76d249d44e4bf3ba01d88ffc368e8bd4" translate="yes" xml:space="preserve">
          <source>Index range expansion</source>
          <target state="translated">인덱스 범위 확장</target>
        </trans-unit>
        <trans-unit id="6fb7f6ce1f52c7d40f5bab615e431e3f8551d458" translate="yes" xml:space="preserve">
          <source>Initialization files</source>
          <target state="translated">초기화 파일</target>
        </trans-unit>
        <trans-unit id="2a06266a915eac92808f8af015840d61f777058b" translate="yes" xml:space="preserve">
          <source>Input/Output (IO) redirection</source>
          <target state="translated">입출력 (IO) 리디렉션</target>
        </trans-unit>
        <trans-unit id="cc03501ba8e2728a6aa8f006cb5c7941d732153b" translate="yes" xml:space="preserve">
          <source>Insert mode</source>
          <target state="translated">삽입 모드</target>
        </trans-unit>
        <trans-unit id="653edb0bfdb6bd20dfe7affb5776bc7d271237c7" translate="yes" xml:space="preserve">
          <source>Internals</source>
          <target state="translated">Internals</target>
        </trans-unit>
        <trans-unit id="2473e96bc614a911821242119918a241a41836d6" translate="yes" xml:space="preserve">
          <source>Introduction</source>
          <target state="translated">Introduction</target>
        </trans-unit>
        <trans-unit id="c62c2864f20a2be4aa0393bfb86357685145de0e" translate="yes" xml:space="preserve">
          <source>Invoking &lt;code&gt;complete&lt;/code&gt; multiple times for the same command adds the new definitions on top of any existing completions defined for the command.</source>
          <target state="translated">동일한 명령에 대해 여러 번 &lt;code&gt;complete&lt;/code&gt; 호출하면 명령에 대해 정의 된 기존 완료 위에 새 정의가 추가됩니다.</target>
        </trans-unit>
        <trans-unit id="83c3b240dba13d15ae7f53c1a501f0c631e4c4fe" translate="yes" xml:space="preserve">
          <source>It is also possible to add all emacs-mode bindings to vi-mode by using something like</source>
          <target state="translated">다음과 같은 것을 사용하여 모든 emacs 모드 바인딩을 vi 모드에 추가 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="8ab84d80263900ba9d5b235b1f2ea80519e28b73" translate="yes" xml:space="preserve">
          <source>It is also possible to set or erase individual elements of an array:</source>
          <target state="translated">배열의 개별 요소를 설정하거나 지울 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="5d526954a8bce879648c1f8388f9dcd5c2cf78df" translate="yes" xml:space="preserve">
          <source>It is common to want to validate the the value provided for an option satisfies some criteria. For example, that it is a valid integer within a specific range. You can always do this after &lt;code&gt;argparse&lt;/code&gt; returns but you can also request that &lt;code&gt;argparse&lt;/code&gt; perform the validation by executing arbitrary fish script. To do so simply append an &lt;code&gt;!&lt;/code&gt; (exclamation-mark) then the fish script to be run. When that code is executed three vars will be defined:</source>
          <target state="translated">옵션에 제공된 값이 일부 기준을 충족시키는 지 확인하는 것이 일반적입니다. 예를 들어 특정 범위 내에서 유효한 정수입니다. &lt;code&gt;argparse&lt;/code&gt; 가 반환 된 후에는 항상이 작업을 수행 할 수 있지만 임의의 fish 스크립트를 실행하여 &lt;code&gt;argparse&lt;/code&gt; 가 유효성 검사를 수행하도록 요청할 수도 있습니다 . 그렇게하려면 간단히 &lt;code&gt;!&lt;/code&gt; (느낌표)를 입력 한 다음 fish 스크립트를 실행하십시오. 해당 코드가 실행될 때 세 가지 변수가 정의됩니다.</target>
        </trans-unit>
        <trans-unit id="a71bcd2264c669eb00c671521098fb03d224a747" translate="yes" xml:space="preserve">
          <source>It is possible to directly create functions and variables in &lt;code&gt;config.fish&lt;/code&gt; file, using the commands shown above. For example:</source>
          <target state="translated">위에 표시된 명령을 사용하여 &lt;code&gt;config.fish&lt;/code&gt; 파일 에서 함수 및 변수를 직접 작성할 수 있습니다 . 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="83c56d7ebd2ae7a42fad58d3fe21565a95290624" translate="yes" xml:space="preserve">
          <source>It is usually added inside of a conditional block such as an &lt;a href=&quot;#if&quot;&gt;if&lt;/a&gt; statement or a &lt;a href=&quot;#switch&quot;&gt;switch&lt;/a&gt; statement to conditionally stop the executing function and return to the caller, but it can also be used to specify the exit status of a function.</source>
          <target state="translated">일반적으로 &lt;a href=&quot;#if&quot;&gt;if&lt;/a&gt; 문 또는 &lt;a href=&quot;#switch&quot;&gt;switch&lt;/a&gt; 문과 같은 조건부 블록 안에 추가되어 실행 기능을 조건부로 중지하고 호출자에게 반환하지만 함수의 종료 상태를 지정하는 데에도 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="cefa92c853442bbe4dd3a6ef0bacadea8c59bfbd" translate="yes" xml:space="preserve">
          <source>It is very important that function definition files only contain the definition for the specified function and nothing else. Otherwise, it is possible that autoloading a function files requires that the function already be loaded, which creates a circular dependency.</source>
          <target state="translated">함수 정의 파일은 지정된 함수에 대한 정의 만 포함하고 다른 것은 포함하지 않는 것이 매우 중요합니다. 그렇지 않으면 함수 파일을 자동로드하려면 함수가 이미로드되어 순환 종속성이 작성 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="13749347248c90340a66276ab0e48e071806f943" translate="yes" xml:space="preserve">
          <source>It knows about paths and options:</source>
          <target state="translated">경로와 옵션에 대해 알고 있습니다.</target>
        </trans-unit>
        <trans-unit id="f51b747a62fc1665fa16726f0cc05a908bd9ced6" translate="yes" xml:space="preserve">
          <source>It will print &lt;code&gt;xa b c x&lt;/code&gt;. But if you do</source>
          <target state="translated">&lt;code&gt;xa b c x&lt;/code&gt; 를 인쇄 합니다. 그러나 만약 당신이</target>
        </trans-unit>
        <trans-unit id="784cf5b2d3ebe2dbad48daf3fd3356b85327650b" translate="yes" xml:space="preserve">
          <source>Iterating over a list of numbers can be done with &lt;code&gt;seq&lt;/code&gt;:</source>
          <target state="translated">숫자 목록을 반복하는 것은 &lt;code&gt;seq&lt;/code&gt; 로 수행 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="1c2654e77c8a1d66520f0e811b49f2ee16ec66ef" translate="yes" xml:space="preserve">
          <source>Job control</source>
          <target state="translated">직무 관리</target>
        </trans-unit>
        <trans-unit id="090e4272d6cb5283367e3c64d3f84a1ce2fa8aee" translate="yes" xml:space="preserve">
          <source>Jobs in the list of jobs are sent a hang-up signal when fish terminates, which usually causes the job to terminate; &lt;code&gt;disown&lt;/code&gt; allows these processes to continue regardless.</source>
          <target state="translated">작업 목록에있는 작업은 물고기가 종료 될 때 끊기 신호를 보내므로 일반적으로 작업이 종료됩니다. &lt;code&gt;disown&lt;/code&gt; 은 이러한 프로세스가 관계없이 계속 진행되도록합니다.</target>
        </trans-unit>
        <trans-unit id="946c99cee0972cba5b6dec7f34cb20b94d3a2715" translate="yes" xml:space="preserve">
          <source>Keep in mind that parameter expansion takes before expressions are evaluated. This can be very useful in order to perform calculations involving shell variables or the output of command substitutions, but it also means that parenthesis and the asterisk glob character have to be escaped or quoted.</source>
          <target state="translated">표현식을 평가하기 전에 매개 변수 확장이 필요하다는 점에 유의하십시오. 이것은 쉘 변수 또는 명령 대체의 출력과 관련된 계산을 수행하는 데 매우 유용 할 수 있지만 괄호와 별표 글로브 문자를 이스케이프하거나 따옴표로 묶어야합니다.</target>
        </trans-unit>
        <trans-unit id="573891be377321acc4815f0519173b9b072d48fa" translate="yes" xml:space="preserve">
          <source>Key bindings may use &quot;modes&quot;, which mimics Vi's modal input behavior. The default mode is &quot;default&quot;, and every bind applies to a single mode. The mode can be viewed/changed with the &lt;code&gt;$fish_bind_mode&lt;/code&gt; variable.</source>
          <target state="translated">키 바인딩은 Vi의 모달 입력 동작을 모방 한 &quot;모드&quot;를 사용할 수 있습니다. 기본 모드는 &quot;default&quot;이며 모든 바인드는 단일 모드에 적용됩니다. &lt;code&gt;$fish_bind_mode&lt;/code&gt; 변수를 사용하여 모드를 보거나 변경할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="b562f1a6d0c5684ca96b09426bc1669506a7f803" translate="yes" xml:space="preserve">
          <source>Learning fish</source>
          <target state="translated">학습 물고기</target>
        </trans-unit>
        <trans-unit id="b5cf98d60edf53bb04a75b49fe8d89b334867632" translate="yes" xml:space="preserve">
          <source>Licensed under the GNU General Public License, version 2.</source>
          <target state="translated">GNU General Public License, 버전 2에 따라 라이센스가 부여되었습니다.</target>
        </trans-unit>
        <trans-unit id="f063dbdbbc3586964fed3651ab53c12631bbacd5" translate="yes" xml:space="preserve">
          <source>Like other shells, a dollar sign performs variable substitution:</source>
          <target state="translated">다른 쉘과 마찬가지로 달러 기호는 변수 대체를 수행합니다.</target>
        </trans-unit>
        <trans-unit id="1c10e83fba90f8ed8fbb793d35b29d018d6a8897" translate="yes" xml:space="preserve">
          <source>Like other shells, fish allows multiple commands either on separate lines or the same line.</source>
          <target state="translated">다른 쉘과 마찬가지로 피쉬는 별도의 줄이나 같은 줄에 여러 명령을 허용합니다.</target>
        </trans-unit>
        <trans-unit id="57c9502a7d7d48fd4a86b45fefb2b163491c3ae1" translate="yes" xml:space="preserve">
          <source>Lists</source>
          <target state="translated">Lists</target>
        </trans-unit>
        <trans-unit id="a51da1d245e2b299170419f02a7283c1cf86ec93" translate="yes" xml:space="preserve">
          <source>Lists adjacent to other lists or strings are expanded as &lt;a href=&quot;index#cartesian-product&quot;&gt;cartesian products&lt;/a&gt; unless quoted (see &lt;a href=&quot;index#expand-variable&quot;&gt;Variable expansion&lt;/a&gt;):</source>
          <target state="translated">다른 목록이나 문자열에 인접한 목록은 인용하지 않는 한 &lt;a href=&quot;index#cartesian-product&quot;&gt;데카르트 곱&lt;/a&gt; 으로 확장됩니다 ( &lt;a href=&quot;index#expand-variable&quot;&gt;변수 확장&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="e550372c446deb80cb7097a6530c7895ce489c98" translate="yes" xml:space="preserve">
          <source>Lists adjacent to other lists or strings are expanded as cartesian products:</source>
          <target state="translated">다른 목록이나 문자열에 인접한 목록은 데카르트 제품으로 확장됩니다.</target>
        </trans-unit>
        <trans-unit id="d036c0ec2ab378b452b8d2cead3a3ffcc191575a" translate="yes" xml:space="preserve">
          <source>Lists cannot contain other lists: there is no recursion. A variable is a list of strings, full stop.</source>
          <target state="translated">리스트는 다른리스트를 포함 할 수 없습니다 : 재귀는 없습니다. 변수는 문자열 목록, 완전 정지입니다.</target>
        </trans-unit>
        <trans-unit id="8172703ebdf7bfc5b44da606bf9f833637212ffc" translate="yes" xml:space="preserve">
          <source>Locale variables</source>
          <target state="translated">로케일 변수</target>
        </trans-unit>
        <trans-unit id="02720f9d38bf4f35e84ed5228689898bee176418" translate="yes" xml:space="preserve">
          <source>Loops</source>
          <target state="translated">Loops</target>
        </trans-unit>
        <trans-unit id="4e836fdc2572ab23d5dc8c36bd613ac6b0f82d63" translate="yes" xml:space="preserve">
          <source>Manual</source>
          <target state="translated">Manual</target>
        </trans-unit>
        <trans-unit id="f5f695dcfd95e469044fda4ad8dda41439800142" translate="yes" xml:space="preserve">
          <source>Many other shells have a large library of builtin commands. Most of these commands are also available as standalone commands, but have been implemented in the shell anyway. To avoid code duplication, and to avoid the confusion of subtly differing versions of the same command, &lt;code&gt;fish&lt;/code&gt; generally only implements builtins for actions which cannot be performed by a regular command.</source>
          <target state="translated">다른 많은 쉘에는 큰 내장 명령 라이브러리가 있습니다. 이러한 명령의 대부분은 독립형 명령으로도 사용할 수 있지만 어쨌든 셸에서 구현되었습니다. 코드 중복을 피하고 동일한 명령의 미묘하게 다른 버전의 혼동을 피하기 위해 &lt;code&gt;fish&lt;/code&gt; 일반적으로 일반 명령으로는 수행 할 수없는 동작에 대해 내장 기능 만 구현합니다.</target>
        </trans-unit>
        <trans-unit id="508666f7961e41b7a23a46d49b1c68da21e0ab6e" translate="yes" xml:space="preserve">
          <source>Many terminals support 24-bit (i.e., true-color) color escape sequences. This includes modern xterm, Gnome Terminal, Konsole, and iTerm2. Fish attempts to detect such terminals through various means in &lt;code&gt;config.fish&lt;/code&gt; You can explicitly force that support via &lt;code&gt;set fish_term24bit 1&lt;/code&gt;.</source>
          <target state="translated">많은 터미널이 24 비트 (즉, 트루 컬러) 색상 이스케이프 시퀀스를 지원합니다. 여기에는 최신 xterm, Gnome Terminal, Konsole 및 iTerm2가 포함됩니다. 물고기는 &lt;code&gt;config.fish&lt;/code&gt; 의 다양한 수단을 통해 이러한 터미널을 감지하려고 시도합니다 . &lt;code&gt;set fish_term24bit 1&lt;/code&gt; 을 통해 명시 적으로 해당 지원을 강제 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="ee9b4890d50f0c6b762d298b81c92845215e8616" translate="yes" xml:space="preserve">
          <source>Match Glob Examples</source>
          <target state="translated">일치하는 세계 예</target>
        </trans-unit>
        <trans-unit id="5d635a6434318430e0640768784677cf44ef96c2" translate="yes" xml:space="preserve">
          <source>Match Regex Examples</source>
          <target state="translated">정규 표현식 예 일치</target>
        </trans-unit>
        <trans-unit id="282c4c424c8c8f802f09ed9069046a66c3e0e2df" translate="yes" xml:space="preserve">
          <source>Matching can be made case-insensitive with &lt;code&gt;--ignore-case&lt;/code&gt; or &lt;code&gt;-i&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;--ignore-case&lt;/code&gt; 또는 &lt;code&gt;-i&lt;/code&gt; 로 대소 문자를 구분하지 않고 일치시킬 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="dfe39636b572a032956990221bea7522894ca013" translate="yes" xml:space="preserve">
          <source>Mismatched parenthesis</source>
          <target state="translated">일치하지 않는 괄호</target>
        </trans-unit>
        <trans-unit id="7d99cf687fc07cadeb9c71efe74a35ddac5120de" translate="yes" xml:space="preserve">
          <source>More on universal variables</source>
          <target state="translated">범용 변수에 대한 추가 정보</target>
        </trans-unit>
        <trans-unit id="a6722727e636d961891415cd8a8813e266709c00" translate="yes" xml:space="preserve">
          <source>Most programs allow you to suspend the program's execution and return control to &lt;code&gt;fish&lt;/code&gt; by pressing &lt;em&gt;Control&lt;/em&gt;-&lt;b&gt;Z&lt;/b&gt; (also referred to as &lt;code&gt;^Z&lt;/code&gt;). Once back at the &lt;code&gt;fish&lt;/code&gt; commandline, you can start other programs and do anything you want. If you then want you can go back to the suspended command by using the &lt;a href=&quot;commands#fg&quot;&gt;&lt;code&gt;fg&lt;/code&gt;&lt;/a&gt; (foreground) command.</source>
          <target state="translated">대부분의 프로그램에서는 &lt;em&gt;Control&lt;/em&gt; - &lt;b&gt;Z&lt;/b&gt; ( &lt;code&gt;^Z&lt;/code&gt; 라고도 함)를 눌러 프로그램 실행을 일시 중단하고 &lt;code&gt;fish&lt;/code&gt; 로 제어를 되돌릴 수 있습니다. &lt;code&gt;fish&lt;/code&gt; 명령 줄로 돌아 오면 다른 프로그램을 시작하고 원하는 작업을 수행 할 수 있습니다. 원하는 경우 &lt;a href=&quot;commands#fg&quot;&gt; &lt;code&gt;fg&lt;/code&gt; &lt;/a&gt; (전경) 명령 을 사용하여 일시 중단 된 명령으로 돌아갈 수 있습니다 .&lt;em&gt;&lt;/em&gt;&lt;b&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="e36a3163fcb5b2ce91e7e62b6620c694486a5106" translate="yes" xml:space="preserve">
          <source>Most programs use three input/output (IO) streams, each represented by a number called a file descriptor (FD). These are:</source>
          <target state="translated">대부분의 프로그램은 3 개의 입 / 출력 (IO) 스트림을 사용하며 각 스트림은 파일 디스크립터 (FD)라는 숫자로 표시됩니다. 이것들은:</target>
        </trans-unit>
        <trans-unit id="fbfe945f56b2d1285935393b0ba01a8e6e9fb533" translate="yes" xml:space="preserve">
          <source>Most subcommands accept a &lt;code&gt;-q&lt;/code&gt; or &lt;code&gt;--quiet&lt;/code&gt; switch, which suppresses the usual output but exits with the documented status.</source>
          <target state="translated">대부분의 부속 명령은 &lt;code&gt;-q&lt;/code&gt; 또는 &lt;code&gt;--quiet&lt;/code&gt; 스위치를 사용하여 일반적인 출력을 억제하지만 문서화 된 상태로 종료합니다.</target>
        </trans-unit>
        <trans-unit id="9e4b95e5fe05cdb2e32c0be4dc38dcb8444a090a" translate="yes" xml:space="preserve">
          <source>Multiline editing</source>
          <target state="translated">여러 줄 편집</target>
        </trans-unit>
        <trans-unit id="284d6c5f151a78ee571b877c91d2822cf913407f" translate="yes" xml:space="preserve">
          <source>Multiple lines are OK. Colors can be set via &lt;code&gt;set_color&lt;/code&gt;, passing it named ANSI colors, or hex RGB values:</source>
          <target state="translated">여러 줄이 정상입니다. &lt;code&gt;set_color&lt;/code&gt; 를 통해 색상을 ANSI 색상 또는 16 진 RGB 값으로 전달 하여 색상을 설정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="b9313e4afc7e7087f2691f5390743aa11cb2045a" translate="yes" xml:space="preserve">
          <source>Multiple lines are not supported in &lt;code&gt;fish_right_prompt&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;fish_right_prompt&lt;/code&gt; 에서 여러 줄이 지원되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="2ddaeb8bc8e45a0d0bc521306478830db49c61a1" translate="yes" xml:space="preserve">
          <source>My command (pkg-config) gives its output as a single long string?</source>
          <target state="translated">내 명령 (pkg-config)은 출력을 하나의 긴 문자열로 제공합니까?</target>
        </trans-unit>
        <trans-unit id="f9c6fa94b0cdb85c962b8db6aabb5f0166f8183a" translate="yes" xml:space="preserve">
          <source>NUL Delimited Examples</source>
          <target state="translated">NUL 구분 예</target>
        </trans-unit>
        <trans-unit id="2bcd7736113c6b4efdb7226bbeffaacd2a34dab2" translate="yes" xml:space="preserve">
          <source>Next, do the following (assuming fish was installed to /usr/local):</source>
          <target state="translated">다음으로 다음을 수행하십시오 (물고기가 / usr / local에 설치되었다고 가정).</target>
        </trans-unit>
        <trans-unit id="e1c89d68ecad2be53a8cf7ccdf90c12f59e35a10" translate="yes" xml:space="preserve">
          <source>Non existing commands.</source>
          <target state="translated">기존 명령이 아닙니다.</target>
        </trans-unit>
        <trans-unit id="76f3e65e8538fb0ceb8d456aa90c5d4ef9931a07" translate="yes" xml:space="preserve">
          <source>Normally when &lt;code&gt;fish&lt;/code&gt; starts a program, this program will be put in the foreground, meaning it will take control of the terminal and &lt;code&gt;fish&lt;/code&gt; will be stopped until the program finishes. Sometimes this is not desirable. For example, you may wish to start an application with a graphical user interface from the terminal, and then be able to continue using the shell. In such cases, there are several ways in which the user can change fish's behavior.</source>
          <target state="translated">일반적으로 &lt;code&gt;fish&lt;/code&gt; 가 프로그램을 시작할 때이 프로그램은 포 그라운드에 배치됩니다. 즉, 터미널을 제어 하고 프로그램이 끝날 때까지 &lt;code&gt;fish&lt;/code&gt; 가 중지됩니다. 때때로 이것은 바람직하지 않습니다. 예를 들어, 터미널에서 그래픽 사용자 인터페이스로 응용 프로그램을 시작한 다음 셸을 계속 사용할 수 있습니다. 이 경우 사용자가 물고기의 행동을 바꿀 수있는 몇 가지 방법이 있습니다.</target>
        </trans-unit>
        <trans-unit id="08c5c1ef76ceaf50dd2d8b6a05425f76eaec2b83" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;case&lt;/code&gt; does not fall through, and can accept multiple arguments or (quoted) wildcards.</source>
          <target state="translated">주의 &lt;code&gt;case&lt;/code&gt; 를 통해 해당하지 않으며, 여러 인수 또는 (인용) 와일드 카드를 받아 들일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="daafcf66550c6e75c5e67349c16e61c50e7a4d2f" translate="yes" xml:space="preserve">
          <source>Note that array indices start at 1 in &lt;code&gt;fish&lt;/code&gt;, not 0, as is more common in other languages. This is because many common Unix tools like &lt;code&gt;seq&lt;/code&gt; are more suited to such use. An invalid index is silently ignored resulting in no value being substituted (not an empty string).</source>
          <target state="translated">배열 인덱스 는 다른 언어에서보다 일반적으로 0이 아닌 &lt;code&gt;fish&lt;/code&gt; 에서 1부터 시작 합니다. &lt;code&gt;seq&lt;/code&gt; 와 같은 많은 일반적인 유닉스 도구 가 이러한 용도에 더 적합하기 때문입니다. 유효하지 않은 색인은 자동으로 무시되어 값이 대체되지 않습니다 (빈 문자열이 아님).</target>
        </trans-unit>
        <trans-unit id="a0707e5e6cd48555094dd0ce06f95a929ab9ee48" translate="yes" xml:space="preserve">
          <source>Note that because fish loads functions on-demand, saved functions will not function as &lt;a href=&quot;index#event&quot;&gt;event handlers&lt;/a&gt; until they are run or sourced otherwise. To activate an event handler for every new shell, add the function to your &lt;a href=&quot;index#initialization&quot;&gt;shell initialization file&lt;/a&gt; instead of using &lt;code&gt;funcsave&lt;/code&gt;.</source>
          <target state="translated">피쉬는 주문형 함수를로드하기 때문에 저장된 함수는 달리 실행되거나 소싱 될 때까지 &lt;a href=&quot;index#event&quot;&gt;이벤트 핸들러&lt;/a&gt; 로 작동하지 않습니다 . 모든 새 쉘에 대해 이벤트 핸들러를 활성화하려면 &lt;code&gt;funcsave&lt;/code&gt; 대신 &lt;a href=&quot;index#initialization&quot;&gt;쉘 초기화 파일에&lt;/a&gt; 함수를 추가하십시오 .</target>
        </trans-unit>
        <trans-unit id="d05600b5a2c4216ed0373e93b0ae5b8dde601d3a" translate="yes" xml:space="preserve">
          <source>Note that command substitutions in a case statement will be evaluated even if its body is not taken. All substitutions, including command substitutions, must be performed before the value can be compared against the parameter.</source>
          <target state="translated">case 문에서 명령 대체는 본문을 가져 가지 않더라도 평가됩니다. 값을 매개 변수와 비교하기 전에 명령 대체를 포함한 모든 대체를 수행해야합니다.</target>
        </trans-unit>
        <trans-unit id="27acedfb629019bcb72c1aaa58829703ce6d6432" translate="yes" xml:space="preserve">
          <source>Note that conversion may fail, e.g. &quot;102.234&quot; will not losslessly convert to an integer, causing printf to print an error.</source>
          <target state="translated">변환이 실패 할 수 있습니다. 예를 들어 &quot;102.234&quot;는 손실없이 정수로 변환되지 않으므로 printf가 오류를 인쇄합니다.</target>
        </trans-unit>
        <trans-unit id="8107914840367cc99db95db5e903f636fb93ac38" translate="yes" xml:space="preserve">
          <source>Note that events are only received from the current fish process as there is no way to send events from one fish process to another.</source>
          <target state="translated">한 물고기 프로세스에서 다른 물고기 프로세스로 이벤트를 보낼 수있는 방법이 없으므로 이벤트는 현재 물고기 프로세스에서만 수신됩니다.</target>
        </trans-unit>
        <trans-unit id="b604d17300bf8871e1df935d8ccab61e77f2c2e6" translate="yes" xml:space="preserve">
          <source>Note that events are only sent to the current fish process as there is no way to send events from one fish process to another.</source>
          <target state="translated">한 물고기 프로세스에서 다른 물고기 프로세스로 이벤트를 보낼 수있는 방법이 없으므로 이벤트는 현재 물고기 프로세스로만 전송됩니다.</target>
        </trans-unit>
        <trans-unit id="1816c418ab7796b893d641bb9d4e996647340b50" translate="yes" xml:space="preserve">
          <source>Note that fish does not fall through on case statements. Only the first matching case is executed.</source>
          <target state="translated">사례 진술에 물고기는 쓰러지지 않습니다. 첫 번째 일치 사례 만 실행됩니다.</target>
        </trans-unit>
        <trans-unit id="dea20fe7204b37a954eb8c5b71576a69b5e9c5a0" translate="yes" xml:space="preserve">
          <source>Note that fish has a default titlebar message, which will be used if the fish_title function is undefined. So simply unsetting the fish_title function will not work.</source>
          <target state="translated">fish에는 기본 제목 표시 줄 메시지가 있으며, fish_title 함수가 정의되지 않은 경우에 사용됩니다. 따라서 단순히 fish_title 함수를 설정 해제하면 작동하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="216dd486d99355c7f2e848a5066c6390232ae830" translate="yes" xml:space="preserve">
          <source>Note that for backwards compatibility each subcommand can also be specified as a long option. For example, rather than &lt;code&gt;history search&lt;/code&gt; you can type &lt;code&gt;history --search&lt;/code&gt;. Those long options are deprecated and will be removed in a future release.</source>
          <target state="translated">이전 버전과의 호환성을 위해 각 하위 명령을 긴 옵션으로 지정할 수도 있습니다. 예를 들어 &lt;code&gt;history search&lt;/code&gt; 대신 &lt;code&gt;history --search&lt;/code&gt; 를 입력 할 수 있습니다 . 이러한 긴 옵션은 더 이상 사용되지 않으며 향후 릴리스에서 제거 될 예정입니다.</target>
        </trans-unit>
        <trans-unit id="c97f265eeb04a552b0a053d1fe6fd39164111e41" translate="yes" xml:space="preserve">
          <source>Note that for most commands, if any wildcard fails to expand, the command is not executed, &lt;a href=&quot;#variables-status&quot;&gt;&lt;code&gt;$status&lt;/code&gt;&lt;/a&gt; is set to nonzero, and a warning is printed. This behavior is consistent with setting &lt;code&gt;shopt -s failglob&lt;/code&gt; in bash. There are exactly 3 exceptions, namely &lt;a href=&quot;commands#set&quot;&gt;&lt;code&gt;set&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;commands#count&quot;&gt;&lt;code&gt;count&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;commands#for&quot;&gt;&lt;code&gt;for&lt;/code&gt;&lt;/a&gt;. Their globs are permitted to expand to zero arguments, as with &lt;code&gt;shopt -s nullglob&lt;/code&gt; in bash.</source>
          <target state="translated">대부분의 명령에서 와일드 카드 확장에 실패하면 명령이 실행되지 않고 &lt;a href=&quot;#variables-status&quot;&gt; &lt;code&gt;$status&lt;/code&gt; &lt;/a&gt; 가 0이 아닌 값으로 설정되고 경고가 인쇄됩니다. 이 동작은 bash에서 &lt;code&gt;shopt -s failglob&lt;/code&gt; 설정과 일치합니다 . 정확히 세 가지 예외, 즉 &lt;a href=&quot;commands#set&quot;&gt; &lt;code&gt;set&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;commands#count&quot;&gt; &lt;code&gt;count&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;commands#for&quot;&gt; &lt;code&gt;for&lt;/code&gt; 가&lt;/a&gt; 있습니다. bash에서 &lt;code&gt;shopt -s nullglob&lt;/code&gt; 와 같이, globs는 0 개의 인수로 확장 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="179b535385e9bcd6de7a6f886e309b106b43e8dd" translate="yes" xml:space="preserve">
          <source>Note that functions cannot be started in the background. Functions that are stopped and then restarted in the background using the &lt;code&gt;bg&lt;/code&gt; command will not execute correctly.</source>
          <target state="translated">백그라운드에서 기능을 시작할 수 없습니다. &lt;code&gt;bg&lt;/code&gt; 명령을 사용하여 백그라운드 에서 중지했다가 다시 시작된 기능은 올바르게 실행되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="56578f519a03e2785432ffc83f432b088789cd11" translate="yes" xml:space="preserve">
          <source>Note that most builtin commands display their help in the terminal when given the &lt;code&gt;--help&lt;/code&gt; option.</source>
          <target state="translated">&lt;code&gt;--help&lt;/code&gt; 옵션이 주어지면 대부분의 내장 명령이 터미널에 도움말을 표시합니다 .</target>
        </trans-unit>
        <trans-unit id="052c493b4f8ae8b6935593bcf58c5ec984ab99f3" translate="yes" xml:space="preserve">
          <source>Note that not all these limits are available in all operating systems.</source>
          <target state="translated">모든 운영 체제에서 이러한 제한을 모두 사용할 수있는 것은 아닙니다.</target>
        </trans-unit>
        <trans-unit id="fd0759c196f448d14f3c2205ba14675a88db1daf" translate="yes" xml:space="preserve">
          <source>Note that parentheses will usually require escaping with &lt;code&gt;\(&lt;/code&gt; to avoid being interpreted as a command substitution.</source>
          <target state="translated">괄호는 일반적으로 명령 대체로 해석되지 않도록 &lt;code&gt;\(&lt;/code&gt; 이스케이프 처리를 요구합니다 .</target>
        </trans-unit>
        <trans-unit id="188395866987d29873c39e6fea9524d72368f195" translate="yes" xml:space="preserve">
          <source>Note that seeding the engine will NOT give the same result across different systems.</source>
          <target state="translated">엔진 시딩은 다른 시스템에서 동일한 결과를 제공하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="b65cb077ea76993a41de3fb713b42e0fed91a42b" translate="yes" xml:space="preserve">
          <source>Note that symbolic masks currently do not work as intended.</source>
          <target state="translated">기호 마스크는 현재 의도 한대로 작동하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="bef2f79c5ca0fefc2538b283ecde5e201f174c69" translate="yes" xml:space="preserve">
          <source>Note that the &lt;code&gt;cd&lt;/code&gt; command limits directory history to the 25 most recently visited directories. The history is stored in the &lt;code&gt;$dirprev&lt;/code&gt; and &lt;code&gt;$dirnext&lt;/code&gt; variables which this command manipulates.</source>
          <target state="translated">참고 것을 &lt;code&gt;cd&lt;/code&gt; 명령은 25 가장 최근에 방문한 디렉토리에 대한 디렉토리 역사를 제한합니다. 히스토리는 이 명령이 조작 하는 &lt;code&gt;$dirprev&lt;/code&gt; 및 &lt;code&gt;$dirnext&lt;/code&gt; 변수에 저장됩니다 .</target>
        </trans-unit>
        <trans-unit id="10a8eb5ef4bfcbb0fbb38b2c1dbc89e74a6c7106" translate="yes" xml:space="preserve">
          <source>Note that the &lt;code&gt;cd&lt;/code&gt; command limits directory history to the 25 most recently visited directories. The history is stored in the &lt;code&gt;$dirprev&lt;/code&gt; and &lt;code&gt;$dirnext&lt;/code&gt; variables which this command manipulates. If you make those universal variables your &lt;code&gt;cd&lt;/code&gt; history is shared among all fish instances.</source>
          <target state="translated">참고 것을 &lt;code&gt;cd&lt;/code&gt; 명령은 25 가장 최근에 방문한 디렉토리에 대한 디렉토리 역사를 제한합니다. 히스토리는 이 명령이 조작 하는 &lt;code&gt;$dirprev&lt;/code&gt; 및 &lt;code&gt;$dirnext&lt;/code&gt; 변수에 저장됩니다 . 이러한 범용 변수를 만들면 모든 기록에서 &lt;code&gt;cd&lt;/code&gt; 기록이 공유됩니다.</target>
        </trans-unit>
        <trans-unit id="9b4bda95d407194baa99d73ed10ab09fd4118640" translate="yes" xml:space="preserve">
          <source>Note that the &lt;code&gt;cd&lt;/code&gt; command limits directory history to the 25 most recently visited directories. The history is stored in the &lt;code&gt;$dirprev&lt;/code&gt; and &lt;code&gt;$dirnext&lt;/code&gt; variables.</source>
          <target state="translated">참고 것을 &lt;code&gt;cd&lt;/code&gt; 명령은 25 가장 최근에 방문한 디렉토리에 대한 디렉토리 역사를 제한합니다. 히스토리는 &lt;code&gt;$dirprev&lt;/code&gt; 및 &lt;code&gt;$dirnext&lt;/code&gt; 변수에 저장됩니다.</target>
        </trans-unit>
        <trans-unit id="468f475ce4540aa6d4ffc053e8efd0e42aba5839" translate="yes" xml:space="preserve">
          <source>Note that the shell will attempt to change directory without requiring &lt;code&gt;cd&lt;/code&gt; if the name of a directory is provided (starting with &lt;code&gt;.&lt;/code&gt;, &lt;code&gt;/&lt;/code&gt; or &lt;code&gt;~&lt;/code&gt;, or ending with &lt;code&gt;/&lt;/code&gt;).</source>
          <target state="translated">디렉토리 이름이 제공 되면 ( &lt;code&gt;.&lt;/code&gt; , &lt;code&gt;/&lt;/code&gt; 또는 &lt;code&gt;~&lt;/code&gt; 로 시작 하거나 &lt;code&gt;/&lt;/code&gt; 로 끝나는 경우) 쉘은 &lt;code&gt;cd&lt;/code&gt; 를 요구하지 않고 디렉토리를 변경하려고 시도합니다 .</target>
        </trans-unit>
        <trans-unit id="4a1ad39e7a025d924c676894892c33d43f516843" translate="yes" xml:space="preserve">
          <source>Note that there are three environment variables that are automatically split on colons to become lists when fish starts running: &lt;code&gt;PATH&lt;/code&gt;, &lt;code&gt;CDPATH&lt;/code&gt;, &lt;code&gt;MANPATH&lt;/code&gt;. Conversely, they are joined on colons when exported to subcommands. All other environment variables (e.g., &lt;code&gt;LD_LIBRARY_PATH&lt;/code&gt;) which have similar semantics are treated as simple strings.</source>
          <target state="translated">물고기가 시작될 때 콜론에서 자동으로 분할되어 목록이되는 환경 변수는 &lt;code&gt;PATH&lt;/code&gt; , &lt;code&gt;CDPATH&lt;/code&gt; , &lt;code&gt;MANPATH&lt;/code&gt; 의 세 가지 입니다. 반대로 하위 명령으로 내보낼 때 콜론에서 결합됩니다. 의미가 비슷한 다른 모든 환경 변수 (예 : &lt;code&gt;LD_LIBRARY_PATH&lt;/code&gt; )는 간단한 문자열로 처리됩니다.</target>
        </trans-unit>
        <trans-unit id="bf45589c3e3c3f4d264bc9f93c56158f4afde11c" translate="yes" xml:space="preserve">
          <source>Note that this function will not be used if a command by this name exists (which is the case on macOS or Haiku).</source>
          <target state="translated">이 이름의 명령이있는 경우 (macOS 또는 Haiku의 경우)이 기능은 사용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="5bf381b343429f3c3b6b07cc6b6f0a80c7987163" translate="yes" xml:space="preserve">
          <source>Note that without the quotes or braces, fish will try to expand a variable called &lt;code&gt;$WORDs&lt;/code&gt;, which may not exist.</source>
          <target state="translated">따옴표 나 괄호가 없으면 fish는 존재하지 않을 수있는 &lt;code&gt;$WORDs&lt;/code&gt; 라는 변수를 확장하려고 시도 합니다.</target>
        </trans-unit>
        <trans-unit id="655206648d0dc7faa21d15bc23b20c851a2e5079" translate="yes" xml:space="preserve">
          <source>Note that ~/.config/fish/config.fish is sourced &lt;em&gt;after&lt;/em&gt; the snippets. This is so users can copy snippets and override some of their behavior.</source>
          <target state="translated">~ /의 .config / 생선 / config.fish가 공급되는 주 &lt;em&gt;후&lt;/em&gt; 코드 조각. 사용자가 스 니펫을 복사하고 일부 동작을 무시할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e2ce3cf51c29175bd1e3054b41cb66e679925023" translate="yes" xml:space="preserve">
          <source>Note that, like GNU tools and most of fish's builtins, &lt;code&gt;contains&lt;/code&gt; interprets all arguments starting with a &lt;code&gt;-&lt;/code&gt; as options to contains, until it reaches an argument that is &lt;code&gt;--&lt;/code&gt; (two dashes). See the examples below.</source>
          <target state="translated">GNU 도구처럼, 그 주와 생선의 내장 매크로의 대부분은 &lt;code&gt;contains&lt;/code&gt; 모든 인수가 함께 시작하는 해석 &lt;code&gt;-&lt;/code&gt; 그것이 인수에 도달 할 때까지, 포함에 옵션으로를 &lt;code&gt;--&lt;/code&gt; (두 개의 대시를). 아래 예를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="9cd1c04aa664d29ef9d4114fed80a20478f9f7c6" translate="yes" xml:space="preserve">
          <source>Note: At the moment the debug prompt is identical to your normal fish prompt. This can make it hard to recognize that you've entered a debug session. Issue 1310 is open to improve this.</source>
          <target state="translated">참고 : 현재 디버그 프롬프트는 일반 물고기 프롬프트와 동일합니다. 이로 인해 디버그 세션에 들어갔다는 것을 인식하기가 어려울 수 있습니다. 이를 개선하기 위해 이슈 1310이 공개되었습니다.</target>
        </trans-unit>
        <trans-unit id="2acd9175970aa8fc3b9936ce32e6e5f5129257b5" translate="yes" xml:space="preserve">
          <source>Note: This event will be emitted even if the command is invalid. The commandline parameter includes the entire commandline verbatim, and may potentially include newlines.</source>
          <target state="translated">참고 :이 이벤트는 명령이 유효하지 않은 경우에도 생성됩니다. commandline 매개 변수는 전체 명령 행 그대로 포함되며 잠재적으로 개행을 포함 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4a71ed28fa070fd5d0f2ba5d9d8b94e51646208b" translate="yes" xml:space="preserve">
          <source>Note: fish 2.2.0 and earlier used a default of 10 milliseconds, and provided no way to configure it. That effectively made it impossible to use escape as a meta key.</source>
          <target state="translated">참고 : fish 2.2.0 및 이전 버전은 기본값 10 밀리 초를 사용했으며이를 구성 할 방법을 제공하지 않았습니다. 이로 인해 이스케이프를 메타 키로 사용할 수 없었습니다.</target>
        </trans-unit>
        <trans-unit id="70440046a3dc2e079f23ee1c57dfa76669b732aa" translate="yes" xml:space="preserve">
          <source>Notes</source>
          <target state="translated">Notes</target>
        </trans-unit>
        <trans-unit id="03c757f6b7891744a49627d17ec9ed791ed69d26" translate="yes" xml:space="preserve">
          <source>Nothing if the flag is a boolean that takes no argument or is an implicit int flag, else</source>
          <target state="translated">플래그가 인수를 취하지 않거나 묵시적 int 플래그 인 부울 인 경우, 그렇지 않은 경우</target>
        </trans-unit>
        <trans-unit id="7e9e91cddb4e1bbe3d96c5cfb7bcf12796b0c7e0" translate="yes" xml:space="preserve">
          <source>Now hub inherits all of the completions from git. Note this can also be specified in a function declaration.</source>
          <target state="translated">이제 허브는 git의 모든 완성을 상속합니다. 이것은 함수 선언에서도 지정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="377c6369b04b17877206baabd99b8340d2c1712d" translate="yes" xml:space="preserve">
          <source>Now in another shell:</source>
          <target state="translated">이제 다른 쉘에서 :</target>
        </trans-unit>
        <trans-unit id="d5aead3c087eb1218d9c5de157a34a40ad6e6161" translate="yes" xml:space="preserve">
          <source>Numerical comparisons will simply fail if one of the operands is not a number:</source>
          <target state="translated">피연산자 중 하나가 숫자가 아닌 경우 숫자 비교는 단순히 실패합니다.</target>
        </trans-unit>
        <trans-unit id="aeeb9e7d5766fc544e9c4260b0a26961443229c2" translate="yes" xml:space="preserve">
          <source>Oh My Fish</source>
          <target state="translated">오 마이 피쉬</target>
        </trans-unit>
        <trans-unit id="c168b84a253f1a9380f35914e43b4459d37046ec" translate="yes" xml:space="preserve">
          <source>Old style long options, like '&lt;code&gt;-Wall&lt;/code&gt;'. Old style long options can be more than one character long, are preceded by a single hyphen and may not be grouped together. Option arguments are specified in the following parameter ('&lt;code&gt;-ao null&lt;/code&gt;').</source>
          <target state="translated">' &lt;code&gt;-Wall&lt;/code&gt; ' 과 같은 오래된 스타일의 긴 옵션 . 이전 스타일의 긴 옵션은 하나 이상의 문자 길이를 가질 수 있으며 앞에 하이픈이 붙어 그룹화되지 않을 수 있습니다. 옵션 인수는 다음 매개 변수 ( ' &lt;code&gt;-ao null&lt;/code&gt; ')에 지정됩니다.</target>
        </trans-unit>
        <trans-unit id="b9e42bb3078b6143675803071b50a1f886f1fddf" translate="yes" xml:space="preserve">
          <source>On startup, Fish evaluates a number of configuration files, which can be used to control the behavior of the shell. The location of these configuration variables is controlled by a number of environment variables, and their default or usual location is given below.</source>
          <target state="translated">시작시 Fish는 여러 구성 파일을 평가하여 셸의 동작을 제어하는 ​​데 사용할 수 있습니다. 이러한 구성 변수의 위치는 여러 환경 변수에 의해 제어되며 기본 또는 일반적인 위치는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="53732b6ec19e859a0b3473ce5240c51bbdc7db63" translate="yes" xml:space="preserve">
          <source>On systems that supports this feature, jobs will print the CPU usage of each job since the last command was executed. The CPU usage is expressed as a percentage of full CPU activity. Note that on multiprocessor systems, the total activity may be more than 100%.</source>
          <target state="translated">이 기능을 지원하는 시스템에서 작업은 마지막 명령이 실행 된 이후 각 작업의 CPU 사용량을 인쇄합니다. CPU 사용량은 전체 CPU 활동의 백분율로 표시됩니다. 다중 프로세서 시스템에서 총 활동은 100 % 이상일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="18125968ef24a12c2f2c9db564d4fb936f8a352f" translate="yes" xml:space="preserve">
          <source>Once installed, just type in &lt;code&gt;fish&lt;/code&gt; into your current shell to try it out!</source>
          <target state="translated">설치가 완료되면 현재 껍질 에 &lt;code&gt;fish&lt;/code&gt; 을 입력 하여 사용해보십시오!</target>
        </trans-unit>
        <trans-unit id="f9801d214429ef9429f41d9ccbf53d1f50cc2cf7" translate="yes" xml:space="preserve">
          <source>One of the most common uses for functions is to slightly alter the behavior of an already existing command. For example, one might want to redefine the &lt;code&gt;ls&lt;/code&gt; command to display colors. The switch for turning on colors on GNU systems is '&lt;code&gt;--color=auto&lt;/code&gt;'. An alias, or wrapper, around &lt;code&gt;ls&lt;/code&gt; might look like this:</source>
          <target state="translated">함수의 가장 일반적인 용도 중 하나는 기존 명령의 동작을 약간 변경하는 것입니다. 예를 들어 &lt;code&gt;ls&lt;/code&gt; 명령을 재정 의하여 색상을 표시 할 수 있습니다. GNU 시스템에서 색상을 켜기위한 스위치는 ' &lt;code&gt;--color=auto&lt;/code&gt; '입니다. &lt;code&gt;ls&lt;/code&gt; 주위의 별명 또는 랩퍼 는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="c6ed72e8734163b3555d72a22a65213a63ac427a" translate="yes" xml:space="preserve">
          <source>Only one function's description can be changed in a single invocation of &lt;code&gt;functions -d&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;functions -d&lt;/code&gt; 의 단일 호출에서 하나의 함수 설명 만 변경할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="744f6b1ea6029a4d03e486aa51d71e6cdfe3a24a" translate="yes" xml:space="preserve">
          <source>Only part of the output can be used, see &lt;a href=&quot;#expand-index-range&quot;&gt;index range expansion&lt;/a&gt; for details.</source>
          <target state="translated">출력의 일부만 사용할 수 있습니다 . 자세한 내용 은 &lt;a href=&quot;#expand-index-range&quot;&gt;인덱스 범위 확장&lt;/a&gt; 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="e90414358dbfff0a68e4eb5d68a16978cf197d5a" translate="yes" xml:space="preserve">
          <source>Operators</source>
          <target state="translated">Operators</target>
        </trans-unit>
        <trans-unit id="e52f4d4c344dadad003e702bffb9e5e28cdc4a21" translate="yes" xml:space="preserve">
          <source>Operators for files and directories</source>
          <target state="translated">파일과 디렉토리를위한 연산자</target>
        </trans-unit>
        <trans-unit id="f27bb0ff136bb8c7c7f1daaac32275d53bfd219d" translate="yes" xml:space="preserve">
          <source>Operators for text strings</source>
          <target state="translated">텍스트 문자열의 연산자</target>
        </trans-unit>
        <trans-unit id="a47a505eb7af733ce0bd8e9777ac0dd7490e55d7" translate="yes" xml:space="preserve">
          <source>Operators to combine expressions</source>
          <target state="translated">표현식을 결합하는 연산자</target>
        </trans-unit>
        <trans-unit id="7fa47fe3927b334a484c669114b525abc6a94112" translate="yes" xml:space="preserve">
          <source>Operators to compare and examine numbers</source>
          <target state="translated">숫자를 비교하고 조사하는 연산자</target>
        </trans-unit>
        <trans-unit id="d4829f651a76eb5aa9c3d27e3534a7c418cd1fc9" translate="yes" xml:space="preserve">
          <source>Option Specifications</source>
          <target state="translated">옵션 사양</target>
        </trans-unit>
        <trans-unit id="6f38993c6d0d5cf791252a01f84f61ce28090cdc" translate="yes" xml:space="preserve">
          <source>Optionally a &lt;code&gt;!&lt;/code&gt; followed by fish script to validate the value. Typically this will be a function to run. If the return status is zero the value for the flag is valid. If non-zero the value is invalid. Any error messages should be written to stdout (not stderr). See the section on &lt;a href=&quot;#arparse-validation&quot;&gt;Flag Value Validation&lt;/a&gt; for more information.</source>
          <target state="translated">선택적으로 &lt;code&gt;!&lt;/code&gt; 값을 확인하기 위해 피쉬 스크립트가 이어집니다. 일반적으로 이것은 실행하는 기능입니다. 리턴 상태가 0이면 플래그의 값이 유효합니다. 0이 아닌 값은 유효하지 않습니다. 모든 오류 메시지는 stderout이 아닌 stdout에 작성해야합니다. 자세한 내용은 &lt;a href=&quot;#arparse-validation&quot;&gt;플래그 값 유효성 검사&lt;/a&gt; 섹션 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="6bf5da9c080bee3a8142586c412aa39971137eee" translate="yes" xml:space="preserve">
          <source>Options</source>
          <target state="translated">Options</target>
        </trans-unit>
        <trans-unit id="14be7a9cc678ff8d2acac3f8d22e39b9c8a4df32" translate="yes" xml:space="preserve">
          <source>Other features</source>
          <target state="translated">다른 특징들</target>
        </trans-unit>
        <trans-unit id="8064e7b7ad17f0248f35efb48f0f1d68ee39d15e" translate="yes" xml:space="preserve">
          <source>Other shells such as bash and zsh use a variable named &lt;code&gt;HISTFILE&lt;/code&gt; for a similar purpose. Fish uses a different name to avoid conflicts and signal that the behavior is different (session name instead of a file path). Also, if you set the var to anything other than &lt;code&gt;fish&lt;/code&gt; or &lt;code&gt;default&lt;/code&gt; it will inhibit importing the bash history. That's because the most common use case for this feature is to avoid leaking private or sensitive history when giving a presentation.</source>
          <target state="translated">bash 및 zsh와 같은 다른 쉘 은 유사한 목적으로 &lt;code&gt;HISTFILE&lt;/code&gt; 이라는 변수를 사용합니다 . Fish는 다른 이름을 사용하여 충돌을 피하고 동작이 다르다는 것을 나타냅니다 (파일 경로 대신 세션 이름). 또한 var를 &lt;code&gt;fish&lt;/code&gt; 또는 &lt;code&gt;default&lt;/code&gt; 이외의 것으로 설정 하면 bash 기록 가져 오기가 금지됩니다. 이 기능의 가장 일반적인 사용 사례는 프레젠테이션을 할 때 개인 또는 민감한 기록이 유출되지 않도록하기위한 것입니다.</target>
        </trans-unit>
        <trans-unit id="ca76df4fa26ca40f2ebdbbcc9b7ac947b4b17597" translate="yes" xml:space="preserve">
          <source>Other shells, such as zsh, provide a rich glob syntax for restricting the files matched by globs. For example, &lt;code&gt;**(.)&lt;/code&gt;, to only match regular files. Fish prefers to defer such features to programs, such as &lt;code&gt;find&lt;/code&gt;, rather than reinventing the wheel. Thus, if you want to limit the wildcard expansion to just regular files the fish approach is to define and use a function. For example,</source>
          <target state="translated">zsh와 같은 다른 쉘은 glob과 일치하는 파일을 제한하기위한 풍부한 glob 구문을 제공합니다. 예를 들어 &lt;code&gt;**(.)&lt;/code&gt; 는 일반 파일과 만 일치합니다. 물고기는 바퀴를 재발견하기보다는 &lt;code&gt;find&lt;/code&gt; 와 같은 프로그램에 이러한 기능을 연기하는 것을 선호합니다 . 따라서 와일드 카드 확장을 일반 파일로만 제한하려면 피쉬 접근 방식은 함수를 정의하고 사용하는 것입니다. 예를 들어</target>
        </trans-unit>
        <trans-unit id="14a838bcf64937317892425e5ab22ef3642359f4" translate="yes" xml:space="preserve">
          <source>Other variables, like &lt;code&gt;$PATH&lt;/code&gt;, really do have multiple values. During variable expansion, the variable expands to become multiple arguments:</source>
          <target state="translated">&lt;code&gt;$PATH&lt;/code&gt; 와 같은 다른 변수에는 실제로 여러 값이 있습니다. 변수 확장 중에 변수는 여러 인수가되도록 확장됩니다.</target>
        </trans-unit>
        <trans-unit id="adcbabbfd6290e1df478b0d2b37c0beb20ff4767" translate="yes" xml:space="preserve">
          <source>Outputting multiple lines is not supported in &lt;code&gt;fish_mode_prompt&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;fish_mode_prompt&lt;/code&gt; 에서는 여러 줄을 출력 할 수 없습니다 .</target>
        </trans-unit>
        <trans-unit id="5b8012177cdea50be6a01e8c45312b388ccc9c7a" translate="yes" xml:space="preserve">
          <source>Outside of double quotes, variables will expand to as many arguments as they have elements. That means an empty list will expand to nothing, a variable with one element will expand to that element, and a variable with multiple elements will expand to each of those elements separately.</source>
          <target state="translated">큰 따옴표 이외의 변수는 요소가있는만큼 많은 인수로 확장됩니다. 즉, 빈 목록은 아무 것도 확장하지 않고 하나의 요소가있는 변수는 해당 요소로 확장되며 여러 요소가있는 변수는 각 요소로 개별적으로 확장됩니다.</target>
        </trans-unit>
        <trans-unit id="b7cda6a843d651b6992452486c962d590a3cb164" translate="yes" xml:space="preserve">
          <source>PATH variables</source>
          <target state="translated">PATH 변수</target>
        </trans-unit>
        <trans-unit id="404b5a722c514f9f99c58c8b9832dbdc15c84e14" translate="yes" xml:space="preserve">
          <source>PATH variables act as normal arrays, except they are are implicitly joined and split on colons.</source>
          <target state="translated">PATH 변수는 암시 적으로 결합되고 콜론으로 분할되는 것을 제외하고 일반 배열로 작동합니다.</target>
        </trans-unit>
        <trans-unit id="6b76530ae6668a37f97a682d440c45d138de6409" translate="yes" xml:space="preserve">
          <source>Parameter expansion (Globbing)</source>
          <target state="translated">파라미터 확장 (글 로빙)</target>
        </trans-unit>
        <trans-unit id="0fdb3f75d27167ce5697671dbec55e14ed3744ea" translate="yes" xml:space="preserve">
          <source>Parentheses and the &lt;code&gt;-o&lt;/code&gt; and &lt;code&gt;-a&lt;/code&gt; operators can be combined to produce more complicated expressions. In this example, success is printed if there is a &lt;code&gt;/foo&lt;/code&gt; or &lt;code&gt;/bar&lt;/code&gt; file as well as a &lt;code&gt;/baz&lt;/code&gt; or &lt;code&gt;/bat&lt;/code&gt; file.</source>
          <target state="translated">괄호와 &lt;code&gt;-o&lt;/code&gt; 및 &lt;code&gt;-a&lt;/code&gt; 연산자를 결합하여보다 복잡한 표현을 만들 수 있습니다. 이 예에서 &lt;code&gt;/foo&lt;/code&gt; 또는 &lt;code&gt;/bar&lt;/code&gt; 파일과 &lt;code&gt;/baz&lt;/code&gt; 또는 &lt;code&gt;/bat&lt;/code&gt; 파일 이 있으면 성공이 인쇄됩니다 .</target>
        </trans-unit>
        <trans-unit id="e0efa09d094aec052590bdd703ecb253fb17eb1e" translate="yes" xml:space="preserve">
          <source>Path variables are a special kind of variable used to support colon-delimited path lists including PATH, CDPATH, MANPATH, PYTHONPATH, etc. All variables that end in &lt;code&gt;PATH&lt;/code&gt; (case-sensitive) become PATH variables.</source>
          <target state="translated">경로 변수는 PATH, CDPATH, MANPATH, PYTHONPATH 등을 포함하여 콜론으로 구분 된 경로 목록을 지원하는 데 사용되는 특수한 종류의 변수입니다. &lt;code&gt;PATH&lt;/code&gt; (대소 문자 구분)로 끝나는 모든 변수는 PATH 변수가됩니다.</target>
        </trans-unit>
        <trans-unit id="acdeb27738adfec3e214f14b0bc5ac319dee18bf" translate="yes" xml:space="preserve">
          <source>Performs a history search when the &lt;b&gt;Page Up&lt;/b&gt; key is pressed.</source>
          <target state="translated">&lt;b&gt;Page Up&lt;/b&gt; 키를 누를 때 히스토리 검색을 수행합니다 .</target>
        </trans-unit>
        <trans-unit id="b07e355a3677aa688ad89bddfe79ee5b312d7645" translate="yes" xml:space="preserve">
          <source>Pipes and Redirections</source>
          <target state="translated">파이프 및 리디렉션</target>
        </trans-unit>
        <trans-unit id="109d28af6c9d51926601f8d9e60546da74487021" translate="yes" xml:space="preserve">
          <source>Pipes usually connect file descriptor 1 (standard output) of the first process to file descriptor 0 (standard input) of the second process. It is possible to use a different output file descriptor by prepending the desired FD number and then output redirect symbol to the pipe. For example:</source>
          <target state="translated">파이프는 일반적으로 첫 번째 프로세스의 파일 설명자 1 (표준 출력)을 두 번째 프로세스의 파일 설명자 0 (표준 입력)에 연결합니다. 원하는 FD 번호를 앞에 붙여 다른 출력 파일 디스크립터를 사용하고 파이프에 리디렉션 경로를 출력 할 수 있습니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="3247b493bc40b8745523a27d8c525cd0dc056fd5" translate="yes" xml:space="preserve">
          <source>Piping</source>
          <target state="translated">Piping</target>
        </trans-unit>
        <trans-unit id="484a02744408ea850ed69df5530d98aa375e29f4" translate="yes" xml:space="preserve">
          <source>Please note that event handlers only become active when a function is loaded, which means you might need to otherwise &lt;a href=&quot;commands#source&quot;&gt;source&lt;/a&gt; or execute a function instead of relying on &lt;a href=&quot;#syntax-function-autoloading&quot;&gt;autoloading&lt;/a&gt;. One approach is to put it into your &lt;a href=&quot;index#initialization&quot;&gt;initialization file&lt;/a&gt;.</source>
          <target state="translated">이벤트 핸들러는 함수가로드 될 때만 활성화되므로 &lt;a href=&quot;#syntax-function-autoloading&quot;&gt;자동로드&lt;/a&gt; 에 의존하는 대신 함수를 &lt;a href=&quot;commands#source&quot;&gt;소싱&lt;/a&gt; 하거나 실행 해야 할 수도 있습니다 . 한 가지 방법은 &lt;a href=&quot;index#initialization&quot;&gt;초기화 파일&lt;/a&gt; 에 넣는 것 입니다.</target>
        </trans-unit>
        <trans-unit id="d9da79a093b23650535a151c09a73e3fee5ee4ae" translate="yes" xml:space="preserve">
          <source>Prefixing the commandline with a space will prevent the entire line from being stored in the history.</source>
          <target state="translated">명령 행 앞에 공백이 있으면 전체 행이 히스토리에 저장되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="fe2ed6ea3216d06709445e2c3ce6b00041d037ed" translate="yes" xml:space="preserve">
          <source>Press &lt;b&gt;Tab&lt;/b&gt;, and &lt;code&gt;fish&lt;/code&gt; will attempt to complete the command, argument, or path:</source>
          <target state="translated">를 눌러 &lt;b&gt;탭&lt;/b&gt; , 그리고 &lt;code&gt;fish&lt;/code&gt; 명령, 인수, 또는 경로를 완료하려고 시도합니다 :</target>
        </trans-unit>
        <trans-unit id="09c712c74db06b262e6e04d6f0d9c7fa02c47733" translate="yes" xml:space="preserve">
          <source>Pressing &lt;em&gt;Alt&lt;/em&gt;-&lt;b&gt;Enter&lt;/b&gt; instead of pressing the &lt;b&gt;Enter&lt;/b&gt; key.</source>
          <target state="translated">누르면 &lt;em&gt;Alt 키를&lt;/em&gt; - &lt;b&gt;입력&lt;/b&gt; 대신 눌러의 &lt;b&gt;입력&lt;/b&gt; 키를 누릅니다.</target>
        </trans-unit>
        <trans-unit id="27bf58510d3b20325eed84381a6d30434da9e2ca" translate="yes" xml:space="preserve">
          <source>Pressing the &lt;b&gt;Enter&lt;/b&gt; key while a block of commands is unclosed, such as when one or more block commands such as &lt;code&gt;for&lt;/code&gt;, &lt;code&gt;begin&lt;/code&gt; or &lt;code&gt;if&lt;/code&gt; do not have a corresponding &lt;code&gt;end&lt;/code&gt; command.</source>
          <target state="translated">(가)를 누르면 &lt;b&gt;입력&lt;/b&gt; 하나 이상의 블록과 같은 명령 때와 같이 명령 블록이 닫히지 않은 상태에서 키를 &lt;code&gt;for&lt;/code&gt; , &lt;code&gt;begin&lt;/code&gt; 또는 &lt;code&gt;if&lt;/code&gt; 해당이없는 &lt;code&gt;end&lt;/code&gt; 명령을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="27493f631ba000f95a572539cafcbb594a951944" translate="yes" xml:space="preserve">
          <source>Print Top and Bottom on separate lines, using an escape sequence</source>
          <target state="translated">이스케이프 시퀀스를 사용하여 별도의 줄에 위쪽과 아래쪽을 인쇄</target>
        </trans-unit>
        <trans-unit id="84c34db7a924b44d0ab81ef51631e488d755a55a" translate="yes" xml:space="preserve">
          <source>Print hello world to stdout</source>
          <target state="translated">안녕하세요 세계를 stdout에 인쇄</target>
        </trans-unit>
        <trans-unit id="ad29dcc16fea024e7e41818ab9d4740b264b782b" translate="yes" xml:space="preserve">
          <source>Prior to the addition of this builtin command in the 2.7.0 release there were two main ways to parse the arguments passed to a fish script or function. One way was to use the OS provided &lt;code&gt;getopt&lt;/code&gt; command. The problem with that is that the GNU and BSD implementations are not compatible. Which makes using that external command difficult other than in trivial situations. The other way is to iterate over &lt;code&gt;$argv&lt;/code&gt; and use the fish &lt;code&gt;switch&lt;/code&gt; statement to decide how to handle the argument. That, however, involves a huge amount of boilerplate code. It is also borderline impossible to implement the same behavior as builtin commands.</source>
          <target state="translated">2.7.0 릴리스에서이 기본 제공 명령을 추가하기 전에 피쉬 스크립트 또는 함수에 전달 된 인수를 구문 분석하는 두 가지 주요 방법이있었습니다. 한 가지 방법은 OS에서 제공 한 &lt;code&gt;getopt&lt;/code&gt; 명령 을 사용하는 것 입니다. 문제는 GNU와 BSD 구현이 호환되지 않는다는 것입니다. 사소한 상황이 아닌 다른 외부 명령을 사용하기가 어렵습니다. 다른 방법은 &lt;code&gt;$argv&lt;/code&gt; 를 반복 하고 fish &lt;code&gt;switch&lt;/code&gt; 문을 사용하여 인수를 처리하는 방법을 결정하는 것입니다. 그러나 많은 양의 상용구 코드가 필요합니다. 내장 명령과 동일한 동작을 구현하는 것도 불가능합니다.</target>
        </trans-unit>
        <trans-unit id="e14c52a6b5ed7f130784534e792abd7951342686" translate="yes" xml:space="preserve">
          <source>Private mode</source>
          <target state="translated">개인 모드</target>
        </trans-unit>
        <trans-unit id="7d03d42c737cd08e3c616e333f7637225318bb7d" translate="yes" xml:space="preserve">
          <source>Problem solved!</source>
          <target state="translated">문제 해결됨!</target>
        </trans-unit>
        <trans-unit id="27fee3438e0d28b1f5e56d2013e82bcf5b441945" translate="yes" xml:space="preserve">
          <source>Programmable prompt</source>
          <target state="translated">프로그래밍 가능한 프롬프트</target>
        </trans-unit>
        <trans-unit id="4eae5ed9e86eb92ca41dd75ef52fb9a0a53af761" translate="yes" xml:space="preserve">
          <source>Programmable title</source>
          <target state="translated">프로그래밍 가능한 제목</target>
        </trans-unit>
        <trans-unit id="a817d7eb8e0f1dab755ab5203a082e5c3c094fce" translate="yes" xml:space="preserve">
          <source>Prompt</source>
          <target state="translated">Prompt</target>
        </trans-unit>
        <trans-unit id="0495187c978ea883d19171649639e1c756060adb" translate="yes" xml:space="preserve">
          <source>Quick answer:</source>
          <target state="translated">빠른 답변 :</target>
        </trans-unit>
        <trans-unit id="7b0257ce75add65485cb879a8ababbebc2270b68" translate="yes" xml:space="preserve">
          <source>Quotes</source>
          <target state="translated">Quotes</target>
        </trans-unit>
        <trans-unit id="a5ab0c393626e6b25924176a035ebd63722dc7ec" translate="yes" xml:space="preserve">
          <source>Range expansion will go in reverse if the end element is earlier in the list than the start and forward if the end is later than the start, unless exactly one of the given indices is negative. This is to enable clamping without changing direction if the list has fewer elements than expected.</source>
          <target state="translated">주어진 인덱스 중 정확히 하나가 음수가 아닌 한, 끝 요소가 시작보다 목록의 앞쪽에 있으면 범위 확장은 반대로되고 끝이 시작보다 늦으면 앞쪽으로 확장됩니다. 이는 목록에 예상보다 적은 요소가있는 경우 방향을 변경하지 않고 클램핑을 활성화하기위한 것입니다.</target>
        </trans-unit>
        <trans-unit id="b16d80967d06f9706108437bd28e6a8d5175e9a0" translate="yes" xml:space="preserve">
          <source>Reading from or appending to a non existing file.</source>
          <target state="translated">존재하지 않는 파일에서 읽거나 추가합니다.</target>
        </trans-unit>
        <trans-unit id="3e22373b8f4786a11fc3f5247c24bd1cd140127f" translate="yes" xml:space="preserve">
          <source>Ready for more?</source>
          <target state="translated">더 준비가 되셨습니까?</target>
        </trans-unit>
        <trans-unit id="ab140354a34bd045ff52d42f722acc1c4ffada22" translate="yes" xml:space="preserve">
          <source>Regular Expressions</source>
          <target state="translated">정규식</target>
        </trans-unit>
        <trans-unit id="5c8c7c6ececfc7a4858b06b4968629df633fe974" translate="yes" xml:space="preserve">
          <source>Renames an existing abbreviation from &lt;code&gt;gco&lt;/code&gt; to &lt;code&gt;gch&lt;/code&gt;.</source>
          <target state="translated">에서 기존의 약어 이름을 변경 &lt;code&gt;gco&lt;/code&gt; 에 &lt;code&gt;gch&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4dc79b3cd9563c59f1fd2d978861f14b1270090f" translate="yes" xml:space="preserve">
          <source>Repeat Examples</source>
          <target state="translated">예제 반복</target>
        </trans-unit>
        <trans-unit id="a879640933d6c8936ca4cc6a02a55f8cc4408041" translate="yes" xml:space="preserve">
          <source>Replace Literal Examples</source>
          <target state="translated">리터럴 예제 교체</target>
        </trans-unit>
        <trans-unit id="13b05ad41dc01c7c29077cca05d8339a7a6429b9" translate="yes" xml:space="preserve">
          <source>Replace Regex Examples</source>
          <target state="translated">정규식 예제 바꾸기</target>
        </trans-unit>
        <trans-unit id="4c85d59c181a8bdfec393789d72d1942cf54846f" translate="yes" xml:space="preserve">
          <source>Return Values</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="27ca7249b11e61ac7f3b63efe842130af63f97b8" translate="yes" xml:space="preserve">
          <source>Run the following command in fish:</source>
          <target state="translated">물고기에서 다음 명령을 실행하십시오.</target>
        </trans-unit>
        <trans-unit id="ddd9c246e03e2789458ae8bb429c9d694195cb17" translate="yes" xml:space="preserve">
          <source>Running Commands</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5c5cc33a225b06807a45544c8793a5276a15976d" translate="yes" xml:space="preserve">
          <source>Running multiple programs</source>
          <target state="translated">여러 프로그램 실행</target>
        </trans-unit>
        <trans-unit id="b3fe37f1b337c360725965146e94ffa93a9708da" translate="yes" xml:space="preserve">
          <source>SEQUENCE is the character sequence to bind to. These should be written as &lt;a href=&quot;index#escapes&quot;&gt;fish escape sequences&lt;/a&gt;. For example, because pressing the Alt key and another character sends that character prefixed with an escape character, Alt-based key bindings can be written using the &lt;code&gt;\e&lt;/code&gt; escape. For example, &lt;em&gt;Alt&lt;/em&gt;-&lt;b&gt;w&lt;/b&gt; can be written as &lt;code&gt;\ew&lt;/code&gt;. The control character can be written in much the same way using the &lt;code&gt;\c&lt;/code&gt; escape, for example &lt;em&gt;Control&lt;/em&gt;-&lt;b&gt;X&lt;/b&gt; (^X) can be written as &lt;code&gt;\cx&lt;/code&gt;. Note that Alt-based key bindings are case sensitive and Control-based key bindings are not. This is a constraint of text-based terminals, not &lt;code&gt;fish&lt;/code&gt;.</source>
          <target state="translated">SEQUENCE는 바인딩 할 문자 시퀀스입니다. 이것은 &lt;a href=&quot;index#escapes&quot;&gt;물고기 탈출 순서&lt;/a&gt; 로 작성되어야합니다 . 예를 들어 Alt 키와 다른 문자를 누르면 해당 문자가 이스케이프 문자로 시작되므로 &lt;code&gt;\e&lt;/code&gt; 이스케이프를 사용하여 Alt 기반 키 바인딩을 작성할 수 있습니다 . 예를 들어 &lt;em&gt;Alt&lt;/em&gt; - &lt;b&gt;w&lt;/b&gt; 는 &lt;code&gt;\ew&lt;/code&gt; 로 쓸 수 있습니다 . 제어 문자는 &lt;code&gt;\c&lt;/code&gt; 이스케이프를 사용하여 거의 같은 방식으로 쓸 수 있습니다. 예를 들어 &lt;em&gt;Control&lt;/em&gt; - &lt;b&gt;X&lt;/b&gt; (^ X)는 &lt;code&gt;\cx&lt;/code&gt; 로 쓸 수 있습니다 . Alt 기반 키 바인딩은 대소 문자를 구분하며 Control 기반 키 바인딩은 대소 문자를 구분하지 않습니다. 이것은 &lt;code&gt;fish&lt;/code&gt; 아닌 텍스트 기반 터미널의 제약입니다..</target>
        </trans-unit>
        <trans-unit id="769ee8ba6c10d0fc5cc5d5931ff5950b069f7631" translate="yes" xml:space="preserve">
          <source>STRING arguments are taken from the command line unless standard input is connected to a pipe or a file, in which case they are read from standard input, one STRING per line. It is an error to supply STRING arguments on the command line and on standard input.</source>
          <target state="translated">표준 입력이 파이프 또는 파일에 연결되어 있지 않으면 명령 행에서 STRING 인수를 가져옵니다.이 경우 표준 입력에서 한 줄에 하나씩 STRING을 읽습니다. 명령 행 및 표준 입력에서 STRING 인수를 제공하는 것은 오류입니다.</target>
        </trans-unit>
        <trans-unit id="3e9759d5f8593842e337c74b9202035585d520b2" translate="yes" xml:space="preserve">
          <source>Same as above but with a second flag that requires a value:</source>
          <target state="translated">위와 동일하지만 값이 필요한 두 번째 플래그가 있습니다.</target>
        </trans-unit>
        <trans-unit id="d562a361adfcc4bd04396673622d38c2c23c4a3b" translate="yes" xml:space="preserve">
          <source>Same as above but with a third flag that can be given multiple times saving the value of each instance seen and only the long flag name (&lt;code&gt;--token&lt;/code&gt;) can be used:</source>
          <target state="translated">위와 동일하지만 보이는 각 인스턴스의 값을 여러 번 저장할 수있는 세 번째 플래그가 있으며 긴 플래그 이름 ( &lt;code&gt;--token&lt;/code&gt; ) 만 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c902e77d44ee1a72851bdd66a8039b7289e5469e" translate="yes" xml:space="preserve">
          <source>Say $animal contains the name of an animal. Then this code would classify it:</source>
          <target state="translated">$ animal에 동물의 이름이 있다고합시다. 그런 다음이 코드는 분류합니다.</target>
        </trans-unit>
        <trans-unit id="2e406da000ac4099abeb149121071ece020d3907" translate="yes" xml:space="preserve">
          <source>Searchable history</source>
          <target state="translated">검색 가능한 기록</target>
        </trans-unit>
        <trans-unit id="b445d35ecc1c55f9e1ceba18d794fb79d964e899" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;index#editor&quot;&gt;documentation&lt;/a&gt; for more details about line editing in fish.</source>
          <target state="translated">참조 &lt;a href=&quot;index#editor&quot;&gt;문서&lt;/a&gt; 물고기 라인 편집에 대한 자세한 내용을.</target>
        </trans-unit>
        <trans-unit id="67373bb92cd7ecbf243edb9d60ad6f00f86a6052" translate="yes" xml:space="preserve">
          <source>See Also</source>
          <target state="translated">또한보십시오</target>
        </trans-unit>
        <trans-unit id="67035298680ddb09dd248da78e915fd9c9627f01" translate="yes" xml:space="preserve">
          <source>See also &lt;code&gt;dirs&lt;/code&gt; and &lt;code&gt;dirs -c&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;dirs&lt;/code&gt; 및 &lt;code&gt;dirs -c&lt;/code&gt; 도 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="1a3b31765df862a7d9c4531c872152ad402c53f3" translate="yes" xml:space="preserve">
          <source>See also &lt;code&gt;read --delimiter&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;read --delimiter&lt;/code&gt; 도 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="7238893c67063d93ae05263dd71a5ccfc50d90c7" translate="yes" xml:space="preserve">
          <source>See also the &lt;a href=&quot;commands#cdh&quot;&gt;&lt;code&gt;cdh&lt;/code&gt;&lt;/a&gt; command for changing to a recently visited directory.</source>
          <target state="translated">최근에 방문한 디렉토리로 변경 하려면 &lt;a href=&quot;commands#cdh&quot;&gt; &lt;code&gt;cdh&lt;/code&gt; &lt;/a&gt; 명령을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="01cfa9314baef15cf1a7d7383228c6d181370cb2" translate="yes" xml:space="preserve">
          <source>See also the &lt;a href=&quot;commands#prevd&quot;&gt;&lt;code&gt;prevd&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;commands#pushd&quot;&gt;&lt;code&gt;pushd&lt;/code&gt;&lt;/a&gt; commands which also work with the recent &lt;code&gt;cd&lt;/code&gt; history and are provided for compatibility with other shells.</source>
          <target state="translated">최신 &lt;code&gt;cd&lt;/code&gt; 기록과 함께 작동 하며 다른 쉘과의 호환성을 위해 제공 되는 &lt;a href=&quot;commands#prevd&quot;&gt; &lt;code&gt;prevd&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;commands#pushd&quot;&gt; &lt;code&gt;pushd&lt;/code&gt; &lt;/a&gt; 명령 도 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="c59959e6168e702c87aad6497074fc87974da46d" translate="yes" xml:space="preserve">
          <source>See the &quot;Internals&quot; section for more on them.</source>
          <target state="translated">자세한 내용은 &quot;내부&quot;섹션을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="c6e5f5869c0d557646211d7b722a3358667dc217" translate="yes" xml:space="preserve">
          <source>See the &lt;a href=&quot;#fish-opt&quot;&gt;&lt;code&gt;fish_opt&lt;/code&gt;&lt;/a&gt; command for a friendlier but more verbose way to create option specifications.</source>
          <target state="translated">옵션 사양을 작성하는 더 친숙하지만 더 자세한 방법 은 &lt;a href=&quot;#fish-opt&quot;&gt; &lt;code&gt;fish_opt&lt;/code&gt; &lt;/a&gt; 명령을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="8ac7646fb3e869bb56303fbe3fca839b0d38f1d8" translate="yes" xml:space="preserve">
          <source>See the documentation for &lt;a href=&quot;commands#funced&quot;&gt;funced&lt;/a&gt; and &lt;a href=&quot;commands#funcsave&quot;&gt;funcsave&lt;/a&gt; for ways to create these files automatically.</source>
          <target state="translated">이러한 파일을 자동으로 생성하는 방법 은 &lt;a href=&quot;commands#funced&quot;&gt;funced&lt;/a&gt; 및 &lt;a href=&quot;commands#funcsave&quot;&gt;funcsave&lt;/a&gt; 설명서를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="bb216107606bc95b848f93fc29c67e8fe68c93ea" translate="yes" xml:space="preserve">
          <source>See the documentation for &lt;a href=&quot;commands#test&quot;&gt;&lt;code&gt;test&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;commands#if&quot;&gt;&lt;code&gt;if&lt;/code&gt;&lt;/a&gt; for more information.</source>
          <target state="translated">에 대한 설명서를 참조하십시오 &lt;a href=&quot;commands#test&quot;&gt; &lt;code&gt;test&lt;/code&gt; &lt;/a&gt; 하고 &lt;a href=&quot;commands#if&quot;&gt; &lt;code&gt;if&lt;/code&gt; &lt;/a&gt; 더 많은 정보를 얻을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9299a43e63898a7efcae7a83cc40f247242085fc" translate="yes" xml:space="preserve">
          <source>See the documentation for &lt;code&gt;set&lt;/code&gt; for more details on the scoping rules for variables.</source>
          <target state="translated">에 대한 설명서를 참조하십시오 &lt;code&gt;set&lt;/code&gt; 변수의 범위 지정 규칙에 대한 자세한 내용은.</target>
        </trans-unit>
        <trans-unit id="f325a391b2afa8d45fd9b05b9b133df7d497fc47" translate="yes" xml:space="preserve">
          <source>Separating Commands (Semicolon)</source>
          <target state="translated">명령 분리 (세미콜론)</target>
        </trans-unit>
        <trans-unit id="cafea76301da663d6e72c8dd0182bf1a08fe0c7b" translate="yes" xml:space="preserve">
          <source>Setting the background color only affects subsequently written characters. Fish provides no way to set the background color for the entire terminal window. Configuring the window background color (and other attributes such as its opacity) has to be done using whatever mechanisms the terminal provides.</source>
          <target state="translated">배경색을 설정하면 이후에 작성된 문자에만 영향을줍니다. Fish는 전체 터미널 창의 배경색을 설정하는 방법을 제공하지 않습니다. 창 배경색 (및 불투명도와 같은 다른 속성) 구성은 터미널이 제공하는 메커니즘을 사용하여 수행해야합니다.</target>
        </trans-unit>
        <trans-unit id="0c0750f1643a764b440d30cec12896d4e2f3c4f4" translate="yes" xml:space="preserve">
          <source>Shared bindings</source>
          <target state="translated">공유 바인딩</target>
        </trans-unit>
        <trans-unit id="61e5ec8aae4e834701135d3867ab63125d131c5e" translate="yes" xml:space="preserve">
          <source>Shell variable and function names</source>
          <target state="translated">쉘 변수 및 함수 이름</target>
        </trans-unit>
        <trans-unit id="e91aede6defa8d430f67e550004d49863d3e2e5b" translate="yes" xml:space="preserve">
          <source>Shell variables</source>
          <target state="translated">쉘 변수</target>
        </trans-unit>
        <trans-unit id="0f86f7ae2195716edf4d3ac75b6ae230d7060ba1" translate="yes" xml:space="preserve">
          <source>Shell variables are named pieces of data, which can be created, deleted and their values changed and used by the user. Variables may optionally be &quot;exported&quot;, so that a copy of the variable is available to any subprocesses the shell creates. An exported variable is referred to as an &quot;environment variable&quot;.</source>
          <target state="translated">쉘 변수는 이름이 지정된 데이터 조각으로, 사용자가 작성, 삭제 및 값을 변경하고 사용할 수 있습니다. 변수는 선택적으로 &quot;내보내기&quot;될 수 있으므로 변수의 사본이 쉘이 작성하는 모든 서브 프로세스에 사용 가능합니다. 내 보낸 변수를 &quot;환경 변수&quot;라고합니다.</target>
        </trans-unit>
        <trans-unit id="e122d1fcfbe4d2952329855d2c90efb389777230" translate="yes" xml:space="preserve">
          <source>Shells like fish are used by giving them commands. Every &lt;code&gt;fish&lt;/code&gt; command follows the same simple syntax.</source>
          <target state="translated">물고기와 같은 조개는 명령을 내림으로써 사용됩니다. 모든 &lt;code&gt;fish&lt;/code&gt; 명령은 동일한 간단한 구문을 따릅니다.</target>
        </trans-unit>
        <trans-unit id="42414c807cd9c1ab64d204f7113345e9c5f0a85a" translate="yes" xml:space="preserve">
          <source>Short options, like '&lt;code&gt;-a&lt;/code&gt;'. Short options are a single character long, are preceded by a single hyphen and may be grouped together (like '&lt;code&gt;-la&lt;/code&gt;', which is equivalent to '&lt;code&gt;-l -a&lt;/code&gt;'). Option arguments may be specified in the following parameter ('&lt;code&gt;-w 32&lt;/code&gt;') or by appending the option with the value ('&lt;code&gt;-w32&lt;/code&gt;').</source>
          <target state="translated">' &lt;code&gt;-a&lt;/code&gt; ' 와 같은 짧은 옵션 . 짧은 옵션은 단일 문자 길이이며 앞에 하이픈이오고, 그룹화 될 수 있습니다 (예 : ' &lt;code&gt;-l -a&lt;/code&gt; ' 와 같은 ' &lt;code&gt;-la&lt;/code&gt; '). 옵션 인수는 다음 매개 변수 ( ' &lt;code&gt;-w 32&lt;/code&gt; ')에 지정하거나 옵션에 값 ( ' &lt;code&gt;-w32&lt;/code&gt; ') 을 추가하여 지정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="214c488d368da8c81796e48eb7f6963ef7a93bff" translate="yes" xml:space="preserve">
          <source>Should you wish to uninstall fish, first ensure fish is not set as your shell. Run &lt;code&gt;chsh -s /bin/bash&lt;/code&gt; if you are not sure.</source>
          <target state="translated">물고기를 제거하려면 먼저 물고기가 껍질로 설정되어 있지 않은지 확인하십시오. 확실하지 않으면 &lt;code&gt;chsh -s /bin/bash&lt;/code&gt; 실행 하십시오.</target>
        </trans-unit>
        <trans-unit id="d5a22b01fc547f4aefabc8c7a496313159dfc74d" translate="yes" xml:space="preserve">
          <source>Signal names are case insensitive and the &lt;code&gt;SIG&lt;/code&gt; prefix is optional.</source>
          <target state="translated">신호 이름은 대소 문자를 구분하지 않으며 &lt;code&gt;SIG&lt;/code&gt; 접두어는 선택 사항입니다.</target>
        </trans-unit>
        <trans-unit id="2339b49e18e4fa7fa63c25097d1c3cb05b3abf7a" translate="yes" xml:space="preserve">
          <source>Similar to bash, fish has Emacs and Vi editing modes. The default editing mode is Emacs. You can switch to Vi mode with &lt;code&gt;fish_vi_key_bindings&lt;/code&gt; and switch back with &lt;code&gt;fish_default_key_bindings&lt;/code&gt;. You can also make your own key bindings by creating a function and setting $fish_key_bindings to its name. For example:</source>
          <target state="translated">bash와 마찬가지로 fish에는 Emacs 및 Vi 편집 모드가 있습니다. 기본 편집 모드는 Emacs입니다. 당신과 바이 모드로 전환 할 수 있습니다 &lt;code&gt;fish_vi_key_bindings&lt;/code&gt; 과 함께 다시 전환 &lt;code&gt;fish_default_key_bindings&lt;/code&gt; . 함수를 만들고 $ fish_key_bindings를 이름으로 설정하여 고유 한 키 바인딩을 만들 수도 있습니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="14b8aecd3aaaa33e35d9724dfec4e61ddcb14189" translate="yes" xml:space="preserve">
          <source>So:</source>
          <target state="translated">So:</target>
        </trans-unit>
        <trans-unit id="530fce1c2ad1ce0277a5df96933c6fbf422dc856" translate="yes" xml:space="preserve">
          <source>Some OPTION_SPEC examples:</source>
          <target state="translated">일부 OPTION_SPEC 예 :</target>
        </trans-unit>
        <trans-unit id="4d6baccd4c71912ba57043465594b0cf17749be7" translate="yes" xml:space="preserve">
          <source>Some bindings are shared between emacs- and vi-mode because they aren't text editing bindings or because what Vi/Vim does for a particular key doesn't make sense for a shell.</source>
          <target state="translated">일부 바인딩은 텍스트 편집 바인딩이 아니거나 특정 키에 대한 Vi / Vim이 쉘에 적합하지 않기 때문에 emacs 및 vi 모드간에 공유됩니다.</target>
        </trans-unit>
        <trans-unit id="425593164f34a70e7fd63371baa3a373bc2ecb38" translate="yes" xml:space="preserve">
          <source>Some characters can not be written directly on the command line. For these characters, so called escape sequences are provided. These are:</source>
          <target state="translated">일부 문자는 명령 행에 직접 쓸 수 없습니다. 이러한 문자에는 소위 이스케이프 시퀀스가 ​​제공됩니다. 이것들은:</target>
        </trans-unit>
        <trans-unit id="6dd3509b210643ba6eefaffcdf24924a6a2790a7" translate="yes" xml:space="preserve">
          <source>Some common words</source>
          <target state="translated">일반적인 단어</target>
        </trans-unit>
        <trans-unit id="01706013cfdbcb0fc543d3c97784f3f4c235d630" translate="yes" xml:space="preserve">
          <source>Some examples:</source>
          <target state="translated">몇 가지 예 :</target>
        </trans-unit>
        <trans-unit id="9a67d5493118a559656027def8dc4fcd0cc3974f" translate="yes" xml:space="preserve">
          <source>Some features include repetitions:</source>
          <target state="translated">일부 기능에는 반복이 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="d39624c87b3e78e02ed8dde71f696712e0710389" translate="yes" xml:space="preserve">
          <source>Some shells (e.g., ksh, bash) feature a syntax that is a mix between command substitution and piping, called process substitution. It is used to send the output of a command into the calling command, much like command substitution, but with the difference that the output is not sent through commandline arguments but through a named pipe, with the filename of the named pipe sent as an argument to the calling program. &lt;code&gt;psub&lt;/code&gt; combined with a regular command substitution provides the same functionality.</source>
          <target state="translated">일부 쉘 (예 : ksh, bash)에는 프로세스 대체라고하는 명령 대체와 파이핑이 혼합 된 구문이 있습니다. 명령 대체와 매우 유사하게 명령 출력을 호출 명령으로 전송하는 데 사용되지만, 출력이 명령 행 인수를 통해 전송되는 것이 아니라 명명 된 파이프를 통해 전송되며, 명명 된 파이프의 파일 이름이 인수로 전송된다는 차이점이 있습니다. 호출 프로그램에. 일반 명령 대체와 결합 된 &lt;code&gt;psub&lt;/code&gt; 는 동일한 기능을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="28861f1ca2bfa4eb42bfb98ba18be09e02df8f97" translate="yes" xml:space="preserve">
          <source>Some terminals use the &lt;code&gt;--bold&lt;/code&gt; escape sequence to switch to a brighter color set rather than increasing the weight of text.</source>
          <target state="translated">일부 터미널은 &lt;code&gt;--bold&lt;/code&gt; escape 시퀀스를 사용하여 텍스트 무게를 늘리지 않고 더 밝은 색상 세트로 전환합니다.</target>
        </trans-unit>
        <trans-unit id="c4dd50f777b9a845d16edeb5ac29fc4998e7e176" translate="yes" xml:space="preserve">
          <source>Some variables, like &lt;code&gt;$PWD&lt;/code&gt;, only have one value. By convention, we talk about that variable's value, but we really mean its first (and only) value.</source>
          <target state="translated">&lt;code&gt;$PWD&lt;/code&gt; 와 같은 일부 변수 에는 하나의 값만 있습니다. 관례 적으로, 우리는 그 변수의 값에 대해 이야기하지만 실제로 첫 번째 (그리고 유일한) 값을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="8709ff84c2c20f30aea0078b8e4ce461f5bca70c" translate="yes" xml:space="preserve">
          <source>Sometimes features such as &lt;a href=&quot;#expand&quot;&gt;parameter expansion&lt;/a&gt; and &lt;a href=&quot;#escapes&quot;&gt;character escapes&lt;/a&gt; get in the way. When that happens, the user can write a parameter within quotes, either &amp;lsquo;&amp;rsquo;&lt;code&gt;(single quote) or&lt;/code&gt;&quot;&lt;code&gt;(double quote). There is one important difference between single quoted and double quoted strings: When using double quoted string, &amp;lt;a href=&quot;#expand-variable&quot;&amp;gt;variable expansion&amp;lt;/a&amp;gt; still takes place. Other than that, no other kind of expansion (including &amp;lt;a href=&quot;#expand-brace&quot;&amp;gt;brace expansion&amp;lt;/a&amp;gt; and parameter expansion) will take place, the parameter may contain spaces, and escape sequences are ignored. The only backslash escape accepted within single quotes is&lt;/code&gt;\'&lt;code&gt;, which escapes a single quote and&lt;/code&gt;\`, which escapes the backslash symbol. The only backslash escapes accepted within double quotes are &lt;code&gt;\&quot;&lt;/code&gt;, which escapes a double quote, &lt;code&gt;\$&lt;/code&gt;, which escapes a dollar character, &lt;code&gt;\&lt;/code&gt; followed by a newline, which deletes the backslash and the newline, and lastly &lt;code&gt;\\&lt;/code&gt;, which escapes the backslash symbol. Single quotes have no special meaning within double quotes and vice versa.</source>
          <target state="translated">때로는 &lt;a href=&quot;#expand&quot;&gt;매개 변수 확장&lt;/a&gt; 및 &lt;a href=&quot;#escapes&quot;&gt;문자 이스케이프&lt;/a&gt; 와 같은 기능 이 방해를받습니다. 이 경우 사용자는 '' &lt;code&gt;(single quote) or&lt;/code&gt; &quot; &lt;code&gt;(double quote). There is one important difference between single quoted and double quoted strings: When using double quoted string, &amp;lt;a href=&quot;#expand-variable&quot;&amp;gt;variable expansion&amp;lt;/a&amp;gt; still takes place. Other than that, no other kind of expansion (including &amp;lt;a href=&quot;#expand-brace&quot;&amp;gt;brace expansion&amp;lt;/a&amp;gt; and parameter expansion) will take place, the parameter may contain spaces, and escape sequences are ignored. The only backslash escape accepted within single quotes is&lt;/code&gt; 중 하나를 따옴표로 묶을 수 있습니다 . 작은 따옴표로 묶은 문자열과 큰 따옴표로 묶인 문자열 사이에는 한 가지 중요한 차이점이 있습니다. 큰 따옴표로 묶인 문자열을 사용하는 경우 &amp;lt;a href = &quot;# expand-variable&quot;&amp;gt; 가변 확장 &amp;lt;/a&amp;gt;이 여전히 발생합니다. 그 외에는 다른 확장 (예 : &amp;lt;a href=&quot;#expand-brace&quot;&amp;gt; 중괄 확장 &amp;lt;/a&amp;gt; 및 매개 변수 확장 포함)이 없습니다. 작은 따옴표 안에 허용되는 유일한 백 슬래시 이스케이프는 \ ' &lt;code&gt;, which escapes a single quote and&lt;/code&gt; 백 슬래시 기호를 이스케이프합니다. 따옴표로 인정 유일한 백 슬래시 이스케이프는 &lt;code&gt;\&quot;&lt;/code&gt; , 이중 인용 부호를 탈출하는 &lt;code&gt;\$&lt;/code&gt; 달러 문자를 이스케이프 이는, &lt;code&gt;\&lt;/code&gt; 마지막으로 백 슬래시 및 줄 바꿈 등을 삭제하는 줄 바꿈, 다음 &lt;code&gt;\\&lt;/code&gt; 백 슬래시를 탈출, 작은 따옴표는 큰 따옴표 안에 특별한 의미가 없으며 그 반대도 마찬가지입니다.</target>
        </trans-unit>
        <trans-unit id="5773d504847f59d4f28606344c751b42fcadfb09" translate="yes" xml:space="preserve">
          <source>Special Case: The escape Character</source>
          <target state="translated">특수 사례 : 탈출 캐릭터</target>
        </trans-unit>
        <trans-unit id="28dc52fcfc9145786fed85cff73226269b82a2c9" translate="yes" xml:space="preserve">
          <source>Special input functions</source>
          <target state="translated">특수 입력 기능</target>
        </trans-unit>
        <trans-unit id="a6c32b7763c1deccd93080cf33efdb324072a965" translate="yes" xml:space="preserve">
          <source>Special variables</source>
          <target state="translated">특수 변수</target>
        </trans-unit>
        <trans-unit id="a0a234701d3553b3ee0fce9d93e7f64fadef5cac" translate="yes" xml:space="preserve">
          <source>Specifying your own completions is not difficult. To specify a completion, use the &lt;code&gt;complete&lt;/code&gt; command. &lt;code&gt;complete&lt;/code&gt; takes as a parameter the name of the command to specify a completion for. For example, to add a completion for the program &lt;code&gt;myprog&lt;/code&gt;, one would start the completion command with &lt;code&gt;complete -c myprog ...&lt;/code&gt;</source>
          <target state="translated">자신의 완성을 지정하는 것은 어렵지 않습니다. 완료를 지정하려면 &lt;code&gt;complete&lt;/code&gt; 명령을 사용하십시오 . &lt;code&gt;complete&lt;/code&gt; 는 완료 를 지정할 명령의 이름을 매개 변수로 사용합니다. 예를 들어, &lt;code&gt;myprog&lt;/code&gt; 프로그램에 완료를 추가 하려면 &lt;code&gt;complete -c myprog ...&lt;/code&gt; 로 완료 명령을 시작합니다 .</target>
        </trans-unit>
        <trans-unit id="1ac6973627e50b5b3feef24cc873cca39ec65518" translate="yes" xml:space="preserve">
          <source>Standard error, FD 2, for writing errors and warnings, defaults to writing to the screen.</source>
          <target state="translated">오류 및 경고를 쓰는 표준 오류 FD 2는 기본적으로 화면에 쓰는 것입니다.</target>
        </trans-unit>
        <trans-unit id="8116e8803b0b4ccfe612ba1239d0a4c13eb0c484" translate="yes" xml:space="preserve">
          <source>Standard input, FD 0, for reading, defaults to reading from the keyboard.</source>
          <target state="translated">읽기 용 표준 입력 FD 0은 기본적으로 키보드를 통한 읽기입니다.</target>
        </trans-unit>
        <trans-unit id="fd08166eefe7793a02e0886b87576b866f11ba8d" translate="yes" xml:space="preserve">
          <source>Standard output, FD 1, for writing, defaults to writing to the screen.</source>
          <target state="translated">쓰기 용 표준 출력 FD 1은 기본적으로 화면에 쓰기로 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="b3883f88eaf74aa505b11f01894c4909220af6a1" translate="yes" xml:space="preserve">
          <source>Standards</source>
          <target state="translated">Standards</target>
        </trans-unit>
        <trans-unit id="806c8aeb75c45b416dcfcd215f384af2b2abda22" translate="yes" xml:space="preserve">
          <source>Startup (Where's .bashrc?)</source>
          <target state="translated">시작 (.bashrc는 어디에 있습니까?)</target>
        </trans-unit>
        <trans-unit id="b3cfed68ddc06bae90fd47f85fdeed65b5766e4e" translate="yes" xml:space="preserve">
          <source>Support for italics, dim, reverse, and other modes is not guaranteed in all terminal emulators. Fish attempts to determine if the terminal supports these modes even if the terminfo database may not be up-to-date.</source>
          <target state="translated">기울임 꼴, 희미한, 반전 및 기타 모드에 대한 지원이 모든 터미널 에뮬레이터에서 보장되는 것은 아닙니다. fish는 terminfo 데이터베이스가 최신이 아닌 경우에도 터미널이 이러한 모드를 지원하는지 확인합니다.</target>
        </trans-unit>
        <trans-unit id="d269dff6a5e6def876fa34f03bd1eb013ca33acd" translate="yes" xml:space="preserve">
          <source>Switches differ between commands and are documented in the manual page for each command. Some switches are common to most command though, for example '&lt;code&gt;--help&lt;/code&gt;' will usually display a help text, '&lt;code&gt;-i&lt;/code&gt;' will often turn on interactive prompting before taking action, while '&lt;code&gt;-f&lt;/code&gt;' will turn it off.</source>
          <target state="translated">스위치는 명령마다 다르며 각 명령에 대한 설명서 페이지에 설명되어 있습니다. 예를 들어 ' &lt;code&gt;--help&lt;/code&gt; '는 일반적으로 도움말 텍스트를 표시하고 ' &lt;code&gt;-i&lt;/code&gt; '는 종종 대화 형 프롬프트를 표시하고 ' &lt;code&gt;-f&lt;/code&gt; '는 해제합니다.</target>
        </trans-unit>
        <trans-unit id="b5eb6066faf764d428231e3c214c4d783bbf5bcc" translate="yes" xml:space="preserve">
          <source>Switching to fish?</source>
          <target state="translated">물고기로 전환?</target>
        </trans-unit>
        <trans-unit id="36c0630a340d2960affa1c4d2360b0e2c06793fb" translate="yes" xml:space="preserve">
          <source>Synopsis</source>
          <target state="translated">Synopsis</target>
        </trans-unit>
        <trans-unit id="17c7ba7676ad1ad6dd1c4e6b997adcae910262c9" translate="yes" xml:space="preserve">
          <source>Syntax</source>
          <target state="translated">Syntax</target>
        </trans-unit>
        <trans-unit id="d27b4fd727666f53e797902bf47550ba0a21184a" translate="yes" xml:space="preserve">
          <source>Syntax Highlighting</source>
          <target state="translated">구문 강조</target>
        </trans-unit>
        <trans-unit id="037fceb004812e2c76fd4ee125e5787960e7ee91" translate="yes" xml:space="preserve">
          <source>Syntax highlighting</source>
          <target state="translated">구문 강조</target>
        </trans-unit>
        <trans-unit id="418e9ee62ad6b7ba7264fdf5d0ee995e2e351045" translate="yes" xml:space="preserve">
          <source>Syntax overview</source>
          <target state="translated">구문 개요</target>
        </trans-unit>
        <trans-unit id="afcc6a38c449b540b7b14d03d1b1f6092ebcf158" translate="yes" xml:space="preserve">
          <source>System-wide configuration files, where administrators can include initialization that should be run for all users on the system - similar to &lt;code&gt;/etc/profile&lt;/code&gt; for POSIX-style shells - in &lt;code&gt;$__fish_sysconf_dir&lt;/code&gt; (usually &lt;code&gt;/etc/fish/config.fish&lt;/code&gt;);</source>
          <target state="translated">시스템 전체 구성 파일-관리자가 시스템의 모든 사용자에 대해 POSIX 스타일 쉘의 &lt;code&gt;/etc/profile&lt;/code&gt; 과 유사하게 &lt;code&gt;$__fish_sysconf_dir&lt;/code&gt; (일반적으로 &lt;code&gt;/etc/fish/config.fish&lt;/code&gt; ) 에서 실행해야하는 초기화를 포함 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="87564ea1bf094f88395489e37aab98a53d8a3438" translate="yes" xml:space="preserve">
          <source>Tab Completions</source>
          <target state="translated">탭 완성</target>
        </trans-unit>
        <trans-unit id="eb8b89e8c468a2f2b0bf3f62ac7419a0270f3b4b" translate="yes" xml:space="preserve">
          <source>Tab completion</source>
          <target state="translated">탭 완성</target>
        </trans-unit>
        <trans-unit id="2ea2b2cc91429ba0736ea7b5a4dc7f2208abf174" translate="yes" xml:space="preserve">
          <source>Tab completion is one of the most time saving features of any modern shell. By tapping the tab key, the user asks &lt;code&gt;fish&lt;/code&gt; to guess the rest of the command or parameter that the user is currently typing. If &lt;code&gt;fish&lt;/code&gt; can only find one possible completion, &lt;code&gt;fish&lt;/code&gt; will write it out. If there is more than one completion, &lt;code&gt;fish&lt;/code&gt; will write out the longest prefix that all completions have in common. If the completions differ on the first character, a list of all possible completions is printed. The list features descriptions of the completions and if the list doesn't fit the screen, it is scrollable by using the arrow keys, the page up/page down keys, the tab key or the space bar.</source>
          <target state="translated">탭 완성은 현대 쉘의 가장 시간 절약 기능 중 하나입니다. 탭 키를 누르면 사용자는 &lt;code&gt;fish&lt;/code&gt; 에게 사용자가 현재 입력하고있는 나머지 명령 또는 매개 변수를 추측 하도록 요청 합니다. 경우 &lt;code&gt;fish&lt;/code&gt; 단지 하나의 가능한 완료를 찾을 수 있습니다, &lt;code&gt;fish&lt;/code&gt; 를 기록합니다. 하나 이상의 완료가있는 경우, &lt;code&gt;fish&lt;/code&gt; 는 모든 완료가 공통적으로 가지고있는 가장 긴 접두사를 작성합니다. 완료가 첫 번째 문자에서 다른 경우 가능한 모든 완료 목록이 인쇄됩니다. 목록에는 완료에 대한 설명이 있으며 목록이 화면에 맞지 않으면 화살표 키, 페이지 위로 / 페이지 아래로 키, 탭 키 또는 스페이스 바를 사용하여 스크롤 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="44e924f5f1b607dd0e4feccbc1d4d898f052a887" translate="yes" xml:space="preserve">
          <source>Tacklebox</source>
          <target state="translated">Tacklebox</target>
        </trans-unit>
        <trans-unit id="e3c7839574383a9eaa3d82c610c455446f6121c0" translate="yes" xml:space="preserve">
          <source>Terminal Capability Detection</source>
          <target state="translated">터미널 기능 감지</target>
        </trans-unit>
        <trans-unit id="b54b1fa82b8ecdc3fb07f7f9d29066e5997831e6" translate="yes" xml:space="preserve">
          <source>Tests the expression given and sets the exit status to 0 if true, and 1 if false. An expression is made up of one or more operators and their arguments.</source>
          <target state="translated">주어진 표현식을 테스트하고 true이면 종료 상태를 0으로 설정하고 false이면 1로 설정합니다. 식은 하나 이상의 연산자와 해당 인수로 구성됩니다.</target>
        </trans-unit>
        <trans-unit id="6b1fc2e3b816bc95de3d9b1753ab9aa1375ff7b8" translate="yes" xml:space="preserve">
          <source>That means if you run</source>
          <target state="translated">그것은 당신이 실행하면 의미</target>
        </trans-unit>
        <trans-unit id="92160f08bddffe06e4520887bdd5645514caf0af" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;https://github.com/fish-shell/fish-shell/&quot;&gt;project GitHub page&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;https://github.com/fish-shell/fish-shell/&quot;&gt;프로젝트 GitHub의 페이지&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="4cc348ddd7ad603b4b7e3a6d1134042f24b0ee0f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;$&lt;/code&gt; symbol can also be used multiple times, as a kind of &quot;dereference&quot; operator (the &lt;code&gt;*&lt;/code&gt; in C or C++), like in the following code:</source>
          <target state="translated">&lt;code&gt;$&lt;/code&gt; 의 심볼은 &quot;간접 참조&quot;연산자 (의 일종으로 여러 번 사용할 수 &lt;code&gt;*&lt;/code&gt; 다음 코드 등 C 또는 C ++에서) :</target>
        </trans-unit>
        <trans-unit id="7e4fc8fc89e59cd9ece4a187b16054d89db8031c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&amp;lt;&lt;/code&gt; and &lt;code&gt;&amp;gt;&lt;/code&gt; operators for comparing strings are not implemented.</source>
          <target state="translated">&lt;code&gt;&amp;lt;&lt;/code&gt; 와 &lt;code&gt;&amp;gt;&lt;/code&gt; 문자열을 비교하기위한 연산자는 구현되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="65fe6102162982a331ea3f92362fbdf8528333d9" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;--&lt;/code&gt; argument is required. You do not have to include any arguments after the &lt;code&gt;--&lt;/code&gt; but you must include the &lt;code&gt;--&lt;/code&gt;. For example, this is acceptable:</source>
          <target state="translated">&lt;code&gt;--&lt;/code&gt; 인수는 필수입니다. 당신은 후 인수 포함 할 필요가 없습니다 &lt;code&gt;--&lt;/code&gt; 하지만 당신은 포함되어야합니다 &lt;code&gt;--&lt;/code&gt; . 예를 들어, 이것은 허용됩니다 :</target>
        </trans-unit>
        <trans-unit id="0c906c7f83627c97b083a6eb5c63248805d8c516" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;--&lt;/code&gt; here stops &lt;code&gt;contains&lt;/code&gt; from treating &lt;code&gt;-q&lt;/code&gt; to an option to itself. Instead it treats it as a normal string to check.</source>
          <target state="translated">&lt;code&gt;--&lt;/code&gt; 여기 정지는 &lt;code&gt;contains&lt;/code&gt; 치료에서 &lt;code&gt;-q&lt;/code&gt; 자체에 대한 옵션. 대신 검사 할 일반 문자열로 처리합니다.</target>
        </trans-unit>
        <trans-unit id="c88d441c07c1b7086b4b120f0e1995c32e1789db" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;-q&lt;/code&gt;, &lt;code&gt;-p&lt;/code&gt;, &lt;code&gt;-t&lt;/code&gt; and &lt;code&gt;-P&lt;/code&gt; flags (and their long flag aliases) are mutually exclusive. Only one can be specified at a time.</source>
          <target state="translated">&lt;code&gt;-q&lt;/code&gt; , &lt;code&gt;-p&lt;/code&gt; , &lt;code&gt;-t&lt;/code&gt; 및 &lt;code&gt;-P&lt;/code&gt; 플래그 (그리고 그들의 긴 플래그 별칭)는 상호 배타적입니다. 한 번에 하나만 지정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2c58a8949ca637e3657d904f90d0683f9b8a4548" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;-w&lt;/code&gt; or &lt;code&gt;--wraps&lt;/code&gt; options causes the specified command to inherit completions from another command. The inheriting command is said to &quot;wrap&quot; the inherited command. The wrapping command may have its own completions in addition to inherited ones. A command may wrap multiple commands, and wrapping is transitive: if A wraps B, and B wraps C, then A automatically inherits all of C's completions. Wrapping can be removed using the &lt;code&gt;-e&lt;/code&gt; or &lt;code&gt;--erase&lt;/code&gt; options. Note that wrapping only works for completions specified with &lt;code&gt;-c&lt;/code&gt; or &lt;code&gt;--command&lt;/code&gt; and are ignored when specifying completions with &lt;code&gt;-p&lt;/code&gt; or &lt;code&gt;--path&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;-w&lt;/code&gt; 또는 &lt;code&gt;--wraps&lt;/code&gt; 옵션은 다른 명령에서 상속 완료에 지정된 명령을 발생합니다. 상속 명령은 상속 된 명령을 &quot;랩핑&quot;한다고합니다. 줄 바꿈 명령은 상속 된 것 외에도 고유 한 완료를 가질 수 있습니다. 명령이 여러 명령을 랩핑 할 수 있으며 랩핑은 전 이적입니다. A가 B를 랩하고 B가 C를 랩하면 A는 모든 C의 완료를 자동으로 상속합니다. 랩핑은 &lt;code&gt;-e&lt;/code&gt; 또는 &lt;code&gt;--erase&lt;/code&gt; 옵션을 사용하여 제거 할 수 있습니다. 랩핑은 &lt;code&gt;-c&lt;/code&gt; 또는 &lt;code&gt;--command&lt;/code&gt; 로 지정된 완료에 대해서만 작동 하며 &lt;code&gt;-p&lt;/code&gt; 또는 &lt;code&gt;--path&lt;/code&gt; 로 완료를 지정할 때는 무시됩니다 .</target>
        </trans-unit>
        <trans-unit id="c3779bf48914bcae0cdcc953ecc413edee9ed2fc" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;VARNAME&lt;/code&gt; was local to the for block in releases prior to 3.0.0. This means that if you did something like this:</source>
          <target state="translated">&lt;code&gt;VARNAME&lt;/code&gt; 은 이전 3.0.0에 릴리스 블록의 로컬이었다. 이것은 당신이 다음과 같은 것을했다면 의미합니다 :</target>
        </trans-unit>
        <trans-unit id="da3409d273e3db5ef8ddc4ea273fbbb872d656c5" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;apt-get&lt;/code&gt;, &lt;code&gt;rpm&lt;/code&gt; and &lt;code&gt;yum&lt;/code&gt; commands use all installed packages as completions.</source>
          <target state="translated">&lt;code&gt;apt-get&lt;/code&gt; 을 , &lt;code&gt;rpm&lt;/code&gt; 및 &lt;code&gt;yum&lt;/code&gt; 명령은 완료로 설치된 모든 패키지를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="08c885ad47f98ee1d2fa7d61aaf2be5914055c4b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;end&lt;/code&gt; command does not change the current exit status. Instead, the status after it will be the status returned by the most recent command.</source>
          <target state="translated">&lt;code&gt;end&lt;/code&gt; 명령은 현재 종료 상태를 변경하지 않습니다. 대신, 그 이후의 상태는 가장 최근의 명령에 의해 리턴 된 상태가됩니다.</target>
        </trans-unit>
        <trans-unit id="3cb7ec726c85b79feb29910ee5250baa8513a66f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;fish&lt;/code&gt; editor features copy and paste, a searchable history and many editor functions that can be bound to special keyboard shortcuts.</source>
          <target state="translated">&lt;code&gt;fish&lt;/code&gt; 편집기 기능, 특수 키보드 단축키에 바인딩 할 수있는 검색 역사와 다양한 편집 기능을 복사하여 붙여 넣습니다.</target>
        </trans-unit>
        <trans-unit id="c64f6cc8af3f868e2009e8fec92b3aa89f2848f9" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;fish&lt;/code&gt; implementation of &lt;code&gt;ulimit&lt;/code&gt; should behave identically to the implementation in bash, except for these differences:</source>
          <target state="translated">&lt;code&gt;ulimit&lt;/code&gt; 의 &lt;code&gt;fish&lt;/code&gt; 구현은 다음 차이점을 제외하고 bash의 구현과 동일하게 작동해야합니다.</target>
        </trans-unit>
        <trans-unit id="67113321177587b92e33339a6cdbfbb714ba38b3" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;format&lt;/code&gt; argument is re-used as many times as necessary to convert all of the given arguments. If a format specifier is not appropriate for the given argument, an error is printed. For example, &amp;lsquo;printf &amp;rsquo;d' &quot;102.234&quot;` produces an error, as &quot;102.234&quot; cannot be formatted as an integer.</source>
          <target state="translated">&lt;code&gt;format&lt;/code&gt; 인수는 주어진 모든 인수를 변환하는 데 필요한만큼 여러 번 다시 사용됩니다. 지정된 인수에 형식 지정자가 적합하지 않으면 오류가 인쇄됩니다. 예를 들어, &quot;printf 'd&quot; &quot;102.234&quot;`는 &quot;102.234&quot;를 정수로 형식화 할 수 없으므로 오류를 생성합니다.</target>
        </trans-unit>
        <trans-unit id="89f23a465dd8d76eebf980544d18d2de2601f2be" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;make&lt;/code&gt; program uses all targets in the Makefile in the current directory as completions.</source>
          <target state="translated">&lt;code&gt;make&lt;/code&gt; 프로그램은 완료로 현재 디렉토리에있는 Makefile의 모든 대상을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="08ddda0f4e3d5dbda6ef1fb82291b1b27f800ddd" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;mount&lt;/code&gt; command uses all mount points specified in fstab as completions.</source>
          <target state="translated">은 &lt;code&gt;mount&lt;/code&gt; 명령을 사용하는 모든 완료로 fstab 파일에 지정된 마운트 지점.</target>
        </trans-unit>
        <trans-unit id="bac670339d33af9a7bab7a0aa6c9bff4de41f823" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;open&lt;/code&gt; command uses the MIME type database and the &lt;code&gt;.desktop&lt;/code&gt; files used by Gnome and KDE to identify filetypes and default actions. If at least one of these environments is installed, but the open command is not working, this probably means that the relevant files are installed in a non-standard location. Consider &lt;a href=&quot;index#more-help&quot;&gt;asking for more help&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;open&lt;/code&gt; 명령은 MIME 타입 데이터베이스와 사용 &lt;code&gt;.desktop&lt;/code&gt; 파일 형식 및 기본 작업을 식별하는 그놈과 KDE에 의해 사용되는 파일. 이러한 환경 중 하나 이상이 설치되어 있지만 open 명령이 작동하지 않으면 관련 파일이 비표준 위치에 설치되었음을 의미합니다. &lt;a href=&quot;index#more-help&quot;&gt;도움을 요청&lt;/a&gt; 하십시오 .</target>
        </trans-unit>
        <trans-unit id="12db9bbc519582e7296e06534b51717da7e239b5" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;pushd&lt;/code&gt; function adds &lt;code&gt;DIRECTORY&lt;/code&gt; to the top of the directory stack and makes it the current working directory. &lt;a href=&quot;#popd&quot;&gt;&lt;code&gt;popd&lt;/code&gt;&lt;/a&gt; will pop it off and return to the original directory.</source>
          <target state="translated">&lt;code&gt;pushd&lt;/code&gt; 기능이 추가 &lt;code&gt;DIRECTORY&lt;/code&gt; 디렉토리 스택의 상단과 현재 작업 디렉토리한다. &lt;a href=&quot;#popd&quot;&gt; &lt;code&gt;popd&lt;/code&gt; &lt;/a&gt; 는 그것을 꺼내어 원래 디렉토리로 돌아갑니다.</target>
        </trans-unit>
        <trans-unit id="a826eafcc5f8080c789ef8d78318660a9727e115" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;read&lt;/code&gt; command supported the &lt;code&gt;-m&lt;/code&gt; and &lt;code&gt;--mode-name&lt;/code&gt; flags in fish versions prior to 2.7.0 to specify an alternative read history file. Those flags are now deprecated and ignored. Instead, set the &lt;code&gt;fish_history&lt;/code&gt; variable to specify a history session ID. That will affect both the &lt;code&gt;read&lt;/code&gt; history file and the fish command history file. You can set it to an empty string to specify that no history should be read or written. This is useful for presentations where you do not want possibly private or sensitive history to be exposed to the audience but do want history relevant to the presentation to be available.</source>
          <target state="translated">&lt;code&gt;read&lt;/code&gt; 명령은 지원 &lt;code&gt;-m&lt;/code&gt; 및 &lt;code&gt;--mode-name&lt;/code&gt; 대신 읽기 기록 파일을 지정하는 물고기의 이전 버전은 2.7.0로의 플래그. 이러한 플래그는 더 이상 사용되지 않으며 무시됩니다. 대신 &lt;code&gt;fish_history&lt;/code&gt; 변수를 설정하여 기록 세션 ID를 지정하십시오. 이는 &lt;code&gt;read&lt;/code&gt; 히스토리 파일 및 피쉬 명령 히스토리 파일 모두에 영향을 미칩니다 . 기록을 읽거나 쓰지 않도록 지정하기 위해 빈 문자열로 설정할 수 있습니다. 비공개 또는 민감한 기록을 청중에게 노출시키지 않고 프리젠 테이션과 관련된 기록을 사용할 수있는 프리젠 테이션에 유용합니다.</target>
        </trans-unit>
        <trans-unit id="7fcdb96d7e5417d911e99a0401becd905a30865f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;rpm&lt;/code&gt; command has several different modes. If the &lt;code&gt;-e&lt;/code&gt; or &lt;code&gt;--erase&lt;/code&gt; flag has been specified, &lt;code&gt;rpm&lt;/code&gt; should delete one or more packages, in which case several switches related to deleting packages are valid, like the &lt;code&gt;nodeps&lt;/code&gt; switch.</source>
          <target state="translated">&lt;code&gt;rpm&lt;/code&gt; 명령은 여러 가지 모드가 있습니다. 는 IF &lt;code&gt;-e&lt;/code&gt; 또는 &lt;code&gt;--erase&lt;/code&gt; 플래그가 지정되어, &lt;code&gt;rpm&lt;/code&gt; 같은 패키지를 삭제와 관련된 경우 여러 스위치, 유효있는 하나 개 이상의 패키지, 삭제해야합니다 &lt;code&gt;nodeps&lt;/code&gt; 이 스위치를.</target>
        </trans-unit>
        <trans-unit id="a790e8c78ea9f158b99ff23d36fc572c40897097" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;set&lt;/code&gt; command above used quotes to ensure that &lt;code&gt;Mister Noodle&lt;/code&gt; was one argument. If it had been two arguments, then &lt;code&gt;name&lt;/code&gt; would have been a list of length 2. In fact, all variables in &lt;code&gt;fish&lt;/code&gt; are really lists, that can contain any number of values, or none at all.</source>
          <target state="translated">위 의 &lt;code&gt;set&lt;/code&gt; 명령은 따옴표를 사용하여 &lt;code&gt;Mister Noodle&lt;/code&gt; 이 하나의 논증 임을 확인했습니다 . 인수가 두 개인 경우 &lt;code&gt;name&lt;/code&gt; 은 길이 2의 목록이되었을 것입니다. 실제로, &lt;code&gt;fish&lt;/code&gt; 모든 변수 는 실제로는 목록이며, 값을 포함하거나 전혀 포함하지 않을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b8a21bdde776c698d3de37f05072833e8526edd9" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;set_color&lt;/code&gt; command uses the terminfo database to look up how to change terminal colors on whatever terminal is in use. Some systems have old and incomplete terminfo databases, and may lack color information for terminals that support it. Fish will assume that all terminals can use the &lt;a href=&quot;https://en.wikipedia.org/wiki/ANSI_escape_code&quot;&gt;ANSI X3.64&lt;/a&gt; escape sequences if the terminfo definition indicates a color below 16 is not supported.</source>
          <target state="translated">&lt;code&gt;set_color&lt;/code&gt; 의 명령은 터미널 무엇가 사용에 터미널 색상을 변경하는 방법을 찾기 위해 terminfo 데이터베이스를 사용합니다. 일부 시스템에는 오래되고 불완전한 terminfo 데이터베이스가 있으며이를 지원하는 터미널에 대한 색상 정보가 부족할 수 있습니다. fish는 terminfo 정의가 16 미만의 색상이 지원되지 않음을 나타내면 모든 터미널이 &lt;a href=&quot;https://en.wikipedia.org/wiki/ANSI_escape_code&quot;&gt;ANSI X3.64&lt;/a&gt; 이스케이프 시퀀스를 사용할 수 있다고 가정합니다 .</target>
        </trans-unit>
        <trans-unit id="570ae270bf32027068dbc7611cc21eacc745b07d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;ssh&lt;/code&gt; command uses all hosts that are stored in the known_hosts file as completions. (See the ssh documentation for more information)</source>
          <target state="translated">&lt;code&gt;ssh&lt;/code&gt; 명령은 완료로에서 known_hosts 파일에 저장된 모든 호스트를 사용합니다. (자세한 내용은 ssh 설명서를 참조하십시오)</target>
        </trans-unit>
        <trans-unit id="98c28ed2787aacc681a7fe21c43d77f6911bb6d4" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;su&lt;/code&gt; command takes any username as an argument. Usernames are given as the first colon-separated field in the file /etc/passwd. This can be specified as:</source>
          <target state="translated">&lt;code&gt;su&lt;/code&gt; 명령은 인수로 어떤 사용자 이름을합니다. 사용자 이름은 / etc / passwd 파일에서 첫 번째 콜론으로 구분 된 필드로 제공됩니다. 다음과 같이 지정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d0c2e5dc87ea547203543a3113293b01834dc317" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;su&lt;/code&gt; command uses all users on the system as completions.</source>
          <target state="translated">&lt;code&gt;su&lt;/code&gt; 명령은 완료로 시스템의 모든 사용자를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="ac2d93e5ce9c99380286aea119eb1c4d811d5e80" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;switch&lt;/code&gt; command is used to execute one of possibly many blocks of commands depending on the value of a string. See the documentation for &lt;a href=&quot;commands#switch&quot;&gt;switch&lt;/a&gt; for more information.</source>
          <target state="translated">&lt;code&gt;switch&lt;/code&gt; 명령 스트링의 값에 따라 명령의 가능한 많은 블록들 중 하나를 실행하기 위해 사용된다. 자세한 내용은 &lt;a href=&quot;commands#switch&quot;&gt;스위치&lt;/a&gt; 설명서를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="47ad27700014770c354049370500a3fdcb1e0c70" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;~&lt;/code&gt; (tilde) character at the beginning of a parameter, followed by a username, is expanded into the home directory of the specified user. A lone &lt;code&gt;~&lt;/code&gt;, or a &lt;code&gt;~&lt;/code&gt; followed by a slash, is expanded into the home directory of the process owner.</source>
          <target state="translated">&lt;code&gt;~&lt;/code&gt; 사용자 이름 뒤에 매개 변수의 시작 부분에 (물결표) 문자는 지정된 사용자의 홈 디렉토리로 확장됩니다. 고독한 &lt;code&gt;~&lt;/code&gt; 또는 &lt;code&gt;~&lt;/code&gt; 와 슬래시가 프로세스 소유자의 홈 디렉토리로 확장됩니다.</target>
        </trans-unit>
        <trans-unit id="81bc67c4cc6d1500fe78dbf824dcd5a05daabcef" translate="yes" xml:space="preserve">
          <source>The Internet Relay Chat channel, #fish on &lt;code&gt;irc.oftc.net&lt;/code&gt;</source>
          <target state="translated">인터넷 중계 채팅 채널, #fish on &lt;code&gt;irc.oftc.net&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="38912f78e93626e5fa47b637ba81937a676623d5" translate="yes" xml:space="preserve">
          <source>The advantage is that you don't have to go mucking around in files: just run this once at the command line, and it will affect the current session and all future instances too. (Note: you should NOT add this line to &lt;code&gt;config.fish&lt;/code&gt;. If you do, the variable will get longer each time you run fish!)</source>
          <target state="translated">장점은 파일을 정리할 필요가 없다는 것입니다. 명령 줄에서 한 번만 실행하면 현재 세션과 모든 향후 인스턴스에도 영향을 미칩니다. (참고 :이 줄을 &lt;code&gt;config.fish&lt;/code&gt; 에 추가하면 안됩니다 . 그렇게하면 물고기를 실행할 때마다 변수가 길어집니다!)</target>
        </trans-unit>
        <trans-unit id="9a5b6fa2b60fb7b30f834fa877a85006d71c86dd" translate="yes" xml:space="preserve">
          <source>The block can be removed. Any events which triggered while the block was in place will then be delivered.</source>
          <target state="translated">블록을 제거 할 수 있습니다. 블록이있는 동안 트리거 된 모든 이벤트가 전달됩니다.</target>
        </trans-unit>
        <trans-unit id="bb7debcb6ad4bd52a3602c3c576ba4ce44391ac4" translate="yes" xml:space="preserve">
          <source>The block is unconditionally executed. &lt;code&gt;begin; ...; end&lt;/code&gt; is equivalent to &lt;code&gt;if true; ...; end&lt;/code&gt;.</source>
          <target state="translated">블록은 무조건 실행됩니다. &lt;code&gt;begin; ...; end&lt;/code&gt; 는 &lt;code&gt;if true; ...; end&lt;/code&gt; 와 같습니다 . ...; 끝 .</target>
        </trans-unit>
        <trans-unit id="c5cb93e79eb59eed4f3c4bd5e54faad96127309f" translate="yes" xml:space="preserve">
          <source>The colors used by fish for syntax highlighting can be configured by changing the values of a various variables. The value of these variables can be one of the colors accepted by the &lt;a href=&quot;commands#set_color&quot;&gt;set_color&lt;/a&gt; command. The &lt;code&gt;--bold&lt;/code&gt; or &lt;code&gt;-b&lt;/code&gt; switches accepted by &lt;code&gt;set_color&lt;/code&gt; are also accepted.</source>
          <target state="translated">어구가 구문 강조를 위해 사용하는 색상은 다양한 변수의 값을 변경하여 구성 할 수 있습니다. 이러한 변수의 값은 &lt;a href=&quot;commands#set_color&quot;&gt;set_color&lt;/a&gt; 명령에 의해 허용되는 색상 중 하나 일 수 있습니다 . &lt;code&gt;--bold&lt;/code&gt; 또는 &lt;code&gt;-b&lt;/code&gt; 수락 스위치 &lt;code&gt;set_color&lt;/code&gt; 는 또한 허용된다.</target>
        </trans-unit>
        <trans-unit id="84d325ad2d19b4840c597f9597e729e6423f6e0a" translate="yes" xml:space="preserve">
          <source>The command history is stored in the file &lt;code&gt;~/.local/share/fish/fish_history&lt;/code&gt; (or &lt;code&gt;$XDG_DATA_HOME/fish/fish_history&lt;/code&gt; if that variable is set) by default. However, you can set the &lt;code&gt;fish_history&lt;/code&gt; environment variable to change the name of the history session (resulting in a &lt;code&gt;&amp;lt;session&amp;gt;_history&lt;/code&gt; file); both before starting the shell and while the shell is running.</source>
          <target state="translated">명령 기록은 기본적으로 &lt;code&gt;~/.local/share/fish/fish_history&lt;/code&gt; 파일 (또는 해당 변수가 설정된 경우 &lt;code&gt;$XDG_DATA_HOME/fish/fish_history&lt;/code&gt; )에 저장됩니다. 그러나 &lt;code&gt;fish_history&lt;/code&gt; 환경 변수를 설정하여 히스토리 세션의 이름을 변경할 수 있습니다 ( &lt;code&gt;&amp;lt;session&amp;gt;_history&lt;/code&gt; 파일에 있음). 쉘을 시작하기 전과 쉘이 실행되는 동안.</target>
        </trans-unit>
        <trans-unit id="ad9471aeb00cd7dbf667ba8000bfffbdd6168599" translate="yes" xml:space="preserve">
          <source>The completions shipped with fish, usually installed in &lt;code&gt;/usr/share/fish/completions&lt;/code&gt;; and</source>
          <target state="translated">완성품은 일반적으로 &lt;code&gt;/usr/share/fish/completions&lt;/code&gt; 에 설치된 생선과 함께 제공됩니다 . 과</target>
        </trans-unit>
        <trans-unit id="526642f1e62598bbea0ecea2aededa98b233083a" translate="yes" xml:space="preserve">
          <source>The default &lt;code&gt;fish_mode_prompt&lt;/code&gt; function will output indicators about the current Vi editor mode displayed to the left of the regular prompt. Define your own function to customize the appearance of the mode indicator. You can also define an empty &lt;code&gt;fish_mode_prompt&lt;/code&gt; function to remove the Vi mode indicators. The &lt;code&gt;$fish_bind_mode variable&lt;/code&gt; can be used to determine the current mode. It will be one of &lt;code&gt;default&lt;/code&gt;, &lt;code&gt;insert&lt;/code&gt;, &lt;code&gt;replace_one&lt;/code&gt;, or &lt;code&gt;visual&lt;/code&gt;.</source>
          <target state="translated">기본 &lt;code&gt;fish_mode_prompt&lt;/code&gt; 함수는 일반 프롬프트의 왼쪽에 표시된 현재 Vi 편집기 모드에 대한 표시기를 출력합니다. 모드 표시기의 모양을 사용자 정의하는 고유 한 기능을 정의하십시오. Vi 모드 표시기를 제거하기 위해 빈 &lt;code&gt;fish_mode_prompt&lt;/code&gt; 함수를 정의 할 수도 있습니다 . &lt;code&gt;$fish_bind_mode variable&lt;/code&gt; 현재의 모드를 결정하는 데 사용할 수 있습니다. &lt;code&gt;default&lt;/code&gt; , &lt;code&gt;insert&lt;/code&gt; , &lt;code&gt;replace_one&lt;/code&gt; 또는 &lt;code&gt;visual&lt;/code&gt; 중 하나입니다 .</target>
        </trans-unit>
        <trans-unit id="b701404c307944b4f207202092290f154a8ceb6b" translate="yes" xml:space="preserve">
          <source>The default behavior of &lt;code&gt;functions&lt;/code&gt;, when called with no arguments, is to print the names of all defined functions. Unless the &lt;code&gt;-a&lt;/code&gt; option is given, no functions starting with underscores are not included in the output.</source>
          <target state="translated">인수없이 호출 될 때 &lt;code&gt;functions&lt;/code&gt; 의 기본 동작은 정의 된 모든 함수의 이름을 인쇄하는 것입니다. &lt;code&gt;-a&lt;/code&gt; 옵션을 지정 하지 않으면 밑줄로 시작하는 함수는 출력에 포함되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="3238e1ed93b89a49bf4c1e65f05bfcad2dc2ccfc" translate="yes" xml:space="preserve">
          <source>The default key binding can be set by specifying a &lt;code&gt;SEQUENCE&lt;/code&gt; of the empty string (that is, &lt;code&gt;''&lt;/code&gt; ). It will be used whenever no other binding matches. For most key bindings, it makes sense to use the &lt;code&gt;self-insert&lt;/code&gt; function (i.e. &lt;code&gt;bind '' self-insert&lt;/code&gt;) as the default keybinding. This will insert any keystrokes not specifically bound to into the editor. Non- printable characters are ignored by the editor, so this will not result in control sequences being printable.</source>
          <target state="translated">빈 키의 &lt;code&gt;SEQUENCE&lt;/code&gt; (즉, &lt;code&gt;''&lt;/code&gt; ) 를 지정하여 기본 키 바인딩을 설정할 수 있습니다 . 다른 바인딩과 일치하지 않을 때마다 사용됩니다. 대부분의 키 바인딩의 경우 &lt;code&gt;self-insert&lt;/code&gt; 기능 (즉, &lt;code&gt;bind '' self-insert&lt;/code&gt; )을 기본 키 바인딩으로 사용하는 것이 좋습니다. 이렇게하면 편집기에 특별히 바인딩되지 않은 키 입력이 삽입됩니다. 인쇄 할 수없는 문자는 편집기에서 무시되므로 제어 순서를 인쇄 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="761122ce7c1e00f6a72f6459922524107cc8cd64" translate="yes" xml:space="preserve">
          <source>The delay in milliseconds since the previous character was received is included in the diagnostic information written to stderr. This information may be useful to determine the optimal &lt;code&gt;fish_escape_delay_ms&lt;/code&gt; setting or learn the amount of lag introduced by tools like &lt;code&gt;ssh&lt;/code&gt;, &lt;code&gt;mosh&lt;/code&gt; or &lt;code&gt;tmux&lt;/code&gt;.</source>
          <target state="translated">이전 문자가 수신 된 이후 밀리 초 단위의 지연은 stderr에 기록 된 진단 정보에 포함됩니다. 이 정보는 최적의 &lt;code&gt;fish_escape_delay_ms&lt;/code&gt; 설정 을 결정 하거나 &lt;code&gt;ssh&lt;/code&gt; , &lt;code&gt;mosh&lt;/code&gt; 또는 &lt;code&gt;tmux&lt;/code&gt; 와 같은 도구에서 발생하는 지연의 양을 배우는 데 유용 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="e2ae9cb276e98e46e4c54626cf3a5b994505cd52" translate="yes" xml:space="preserve">
          <source>The escape key can be used standalone, for example, to switch from insertion mode to normal mode when using Vi keybindings. Escape may also be used as a &quot;meta&quot; key, to indicate the start of an escape sequence, such as function or arrow keys. Custom bindings can also be defined that begin with an escape character.</source>
          <target state="translated">Vi 키 바인딩을 사용할 때 이스케이프 키를 독립형으로 사용하여 삽입 모드에서 일반 모드로 전환 할 수 있습니다. 이스케이프는 기능 또는 화살표 키와 같은 이스케이프 시퀀스의 시작을 나타 내기 위해 &quot;메타&quot;키로 사용될 수도 있습니다. 이스케이프 문자로 시작하는 사용자 정의 바인딩을 정의 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="f2b67ae0b734fe8c7eb4002ecf7174bec7a097d2" translate="yes" xml:space="preserve">
          <source>The exit code of the &lt;code&gt;jobs&lt;/code&gt; builtin is &lt;code&gt;0&lt;/code&gt; if there are running background jobs and &lt;code&gt;1&lt;/code&gt; otherwise.</source>
          <target state="translated">백그라운드 작업이 실행중인 경우 내장 &lt;code&gt;jobs&lt;/code&gt; 의 종료 코드 는 &lt;code&gt;0&lt;/code&gt; 이고 그렇지 않은 경우 &lt;code&gt;1&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="92a98ee3485df09b2caf60e2fe8f1f43529de92d" translate="yes" xml:space="preserve">
          <source>The exit status of &lt;code&gt;functions&lt;/code&gt; is the number of functions specified in the argument list that do not exist, which can be used in concert with the &lt;code&gt;-q&lt;/code&gt; option.</source>
          <target state="translated">&lt;code&gt;functions&lt;/code&gt; 의 종료 상태는 존재하지 않는 인수 목록에 지정된 함수의 수이며 &lt;code&gt;-q&lt;/code&gt; 옵션 과 함께 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="0f212eae622b07227263f98bfdb5b6ec216b4de4" translate="yes" xml:space="preserve">
          <source>The exit status of commands within &lt;code&gt;fish_breakpoint_prompt&lt;/code&gt; will not modify the value of &lt;a href=&quot;index#variables-status&quot;&gt;$status&lt;/a&gt; outside of the &lt;code&gt;fish_breakpoint_prompt&lt;/code&gt; function.</source>
          <target state="translated">&lt;code&gt;fish_breakpoint_prompt&lt;/code&gt; 내 명령의 종료 상태 는 &lt;code&gt;fish_breakpoint_prompt&lt;/code&gt; 함수 외부의 &lt;a href=&quot;index#variables-status&quot;&gt;$ status&lt;/a&gt; 값을 수정하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="5657481f999e23c3116d622970acdbbcff597a42" translate="yes" xml:space="preserve">
          <source>The exit status of commands within &lt;code&gt;fish_prompt&lt;/code&gt; will not modify the value of &lt;a href=&quot;index#variables-status&quot;&gt;$status&lt;/a&gt; outside of the &lt;code&gt;fish_prompt&lt;/code&gt; function.</source>
          <target state="translated">&lt;code&gt;fish_prompt&lt;/code&gt; 내의 명령 종료 상태 는 &lt;code&gt;fish_prompt&lt;/code&gt; 함수 외부의 &lt;a href=&quot;index#variables-status&quot;&gt;$ status&lt;/a&gt; 값을 수정하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="ff645c10072dc44f93fe8a0bc1b09a1e128e9d19" translate="yes" xml:space="preserve">
          <source>The exit status of the last foreground command to exit can always be accessed using the &lt;a href=&quot;index#variables-status&quot;&gt;$status&lt;/a&gt; variable.</source>
          <target state="translated">종료 할 마지막 포 그라운드 명령의 종료 상태는 항상 &lt;a href=&quot;index#variables-status&quot;&gt;$ status&lt;/a&gt; 변수를 사용하여 액세스 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="4652deeba9fb7344bebbe6060971799e99a44a6b" translate="yes" xml:space="preserve">
          <source>The exit status of the last run command substitution is available in the &lt;a href=&quot;#variables-status&quot;&gt;status&lt;/a&gt; variable if the substitution occurs in the context of a &lt;code&gt;set&lt;/code&gt; command.</source>
          <target state="translated">마지막 실행 명령 대체의 종료 상태 는 &lt;code&gt;set&lt;/code&gt; 명령 의 컨텍스트에서 대체가 발생하면 &lt;a href=&quot;#variables-status&quot;&gt;상태&lt;/a&gt; 변수 에서 사용 가능 합니다 .</target>
        </trans-unit>
        <trans-unit id="110fb03150bee422319feb18aa0d332d91a7cdc7" translate="yes" xml:space="preserve">
          <source>The exit status of the while loop is the exit status of the last iteration of the &lt;code&gt;COMMANDS&lt;/code&gt; executed, or 0 if none were executed. (This matches other shells and is POSIX-compatible.)</source>
          <target state="translated">while 루프의 종료 상태는 마지막으로 실행 된 &lt;code&gt;COMMANDS&lt;/code&gt; 반복의 종료 상태 이거나 실행되지 않은 경우 0입니다. (이것은 다른 쉘과 일치하며 POSIX와 호환됩니다.)</target>
        </trans-unit>
        <trans-unit id="0e8e9a53dcf07764aa42aaf44d6d7a9d7ab8311a" translate="yes" xml:space="preserve">
          <source>The exporting rules when creating or updating a variable are identical to the scoping rules for variables:</source>
          <target state="translated">변수를 만들거나 업데이트 할 때 내보내기 규칙은 변수의 범위 지정 규칙과 동일합니다.</target>
        </trans-unit>
        <trans-unit id="ccd7da4c54986027f5d438b2f8ee07a3d4f4e74d" translate="yes" xml:space="preserve">
          <source>The first &lt;code&gt;--&lt;/code&gt; seen is what allows the &lt;code&gt;argparse&lt;/code&gt; command to reliably separate the option specifications from the command arguments.</source>
          <target state="translated">첫 번째 &lt;code&gt;--&lt;/code&gt; 볼 수는 있습니다 무엇 &lt;code&gt;argparse&lt;/code&gt; 명령을 안정적으로 명령 인수에서 옵션 사양을 구분합니다.</target>
        </trans-unit>
        <trans-unit id="f00c945cebc76b9e34b8670689ec76047f703bed" translate="yes" xml:space="preserve">
          <source>The first form (&lt;code&gt;test&lt;/code&gt;) is preferred. For compatibility with other shells, the second form is available: a matching pair of square brackets (&lt;code&gt;[ [EXPRESSION ] ]&lt;/code&gt;).</source>
          <target state="translated">첫 번째 형태 ( &lt;code&gt;test&lt;/code&gt; )가 선호됩니다. 다른 쉘과의 호환성을 위해 두 번째 형식 인 대괄호 쌍 ( &lt;code&gt;[ [EXPRESSION ] ]&lt;/code&gt; )을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1feeb6c582e1b13feec652671af704d8c4bca81d" translate="yes" xml:space="preserve">
          <source>The first line tells fish that a function by the name of &lt;code&gt;ll&lt;/code&gt; is to be defined. To use it, simply write &lt;code&gt;ll&lt;/code&gt; on the commandline. The second line tells fish that the command &lt;code&gt;ls -l $argv&lt;/code&gt; should be called when &lt;code&gt;ll&lt;/code&gt; is invoked. '&lt;code&gt;$argv&lt;/code&gt;' is an array variable, which always contains all arguments sent to the function. In the example above, these are simply passed on to the &lt;code&gt;ls&lt;/code&gt; command. For more information on functions, see the documentation for the &lt;a href=&quot;commands#function&quot;&gt;function&lt;/a&gt; builtin.</source>
          <target state="translated">첫 번째 줄은 물고기에게 &lt;code&gt;ll&lt;/code&gt; 이라는 이름의 함수 가 정의되어야 함을 알려줍니다 . 사용하려면 명령 행에 &lt;code&gt;ll&lt;/code&gt; 을 쓰십시오 . 두 번째 줄은 &lt;code&gt;ll&lt;/code&gt; 이 호출 될 때 &lt;code&gt;ls -l $argv&lt;/code&gt; 명령을 호출해야 한다는 것을 물고기에게 알려줍니다 . ' &lt;code&gt;$argv&lt;/code&gt; '는 함수에 전송 된 모든 인수를 항상 포함하는 배열 변수입니다. 위의 예에서 이들은 &lt;code&gt;ls&lt;/code&gt; 명령으로 전달됩니다 . 기능에 대한 자세한 내용은 내장 &lt;a href=&quot;commands#function&quot;&gt;기능&lt;/a&gt; 설명서를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="5aa91cd04a31d486d202e2b1e77d870e577f521a" translate="yes" xml:space="preserve">
          <source>The first part specifies to whom this set of right applies, and can be one of &lt;code&gt;u&lt;/code&gt;, &lt;code&gt;g&lt;/code&gt;, &lt;code&gt;o&lt;/code&gt; or &lt;code&gt;a&lt;/code&gt;, where &lt;code&gt;u&lt;/code&gt; specifies the user who owns the file, &lt;code&gt;g&lt;/code&gt; specifies the group owner of the file, &lt;code&gt;o&lt;/code&gt; specific other users rights and &lt;code&gt;a&lt;/code&gt; specifies all three should be changed.</source>
          <target state="translated">권리 세트가 적용되며 중 하나가 될 수 있습니다 누구에게 첫 번째 부분 지정하는 &lt;code&gt;u&lt;/code&gt; , &lt;code&gt;g&lt;/code&gt; , &lt;code&gt;o&lt;/code&gt; 또는 , &lt;code&gt;u&lt;/code&gt; 파일, 소유하는 사용자 지정 &lt;code&gt;g&lt;/code&gt; 의 지정 파일의 그룹 소유자를, &lt;code&gt;o&lt;/code&gt; 특정 다른 사용자의 권리와 &lt;code&gt;a&lt;/code&gt; 는 세 개 모두를 변경해야 함을 지정합니다. &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="8197431f9332af76bce775e1de1257355f1cd95c" translate="yes" xml:space="preserve">
          <source>The fish commandline editor can be used to work on commands that are several lines long. There are three ways to make a command span more than a single line:</source>
          <target state="translated">피쉬 명령 줄 편집기를 사용하면 몇 줄의 명령을 처리 할 수 ​​있습니다. 명령을 한 줄 이상으로 확장하는 세 가지 방법이 있습니다.</target>
        </trans-unit>
        <trans-unit id="8f8186d4ab0a2d348fed572d2dce9da78099265a" translate="yes" xml:space="preserve">
          <source>The fish commandline editor works exactly the same in single line mode and in multiline mode. To move between lines use the left and right arrow keys and other such keyboard shortcuts.</source>
          <target state="translated">피쉬 명령 줄 편집기는 한 줄 모드와 여러 줄 모드에서 정확히 동일하게 작동합니다. 줄 사이를 이동하려면 왼쪽 및 오른쪽 화살표 키와 기타 단축키를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="23b5304e27f02f59d7a10f53fd4009e199ac5306" translate="yes" xml:space="preserve">
          <source>The fish exit status is generally the exit status of the last foreground command. If fish is exiting because of a parse error, the exit status is 127.</source>
          <target state="translated">어류 종료 상태는 일반적으로 마지막 포 그라운드 명령의 종료 상태입니다. 구문 분석 오류로 인해 물고기가 종료되면 종료 상태는 127입니다.</target>
        </trans-unit>
        <trans-unit id="81b0737757c6447d0c7efe9ceff078d063aa48ef" translate="yes" xml:space="preserve">
          <source>The fish user community extends fish in unique and useful ways via scripts that aren't always appropriate for bundling with the fish package. Typically because they solve a niche problem unlikely to appeal to a broad audience. You can find those extensions, including prompts, themes and useful functions, in various third-party repositories. These include:</source>
          <target state="translated">물고기 사용자 커뮤니티는 물고기 패키지와 함께 제공하기에 항상 적합한 스크립트를 통해 독특하고 유용한 방법으로 물고기를 확장합니다. 일반적으로 그들은 틈새 문제를 해결하여 광범위한 청중에게 호소하지 않을 것입니다. 다양한 타사 리포지토리에서 프롬프트, 테마 및 유용한 기능을 포함하여 이러한 확장을 찾을 수 있습니다. 여기에는 다음이 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="d06891f80053c3220358df28d431b54da754d75c" translate="yes" xml:space="preserve">
          <source>The fish_mode_prompt function will output the mode indicator for use in vi-mode.</source>
          <target state="translated">fish_mode_prompt 함수는 vi 모드에서 사용하기위한 모드 표시기를 출력합니다.</target>
        </trans-unit>
        <trans-unit id="89d3be5da20cd5974bed5d4cec48f0faf57383bf" translate="yes" xml:space="preserve">
          <source>The following &lt;code&gt;argparse&lt;/code&gt; options are available. They must appear before all OPTION_SPECs:</source>
          <target state="translated">다음과 같은 &lt;code&gt;argparse&lt;/code&gt; 옵션을 사용할 수 있습니다. 모든 OPTION_SPEC 앞에 표시되어야합니다.</target>
        </trans-unit>
        <trans-unit id="23d5e5164bbb45ea1a895b015bf1d3acf0cdeae1" translate="yes" xml:space="preserve">
          <source>The following &lt;code&gt;argparse&lt;/code&gt; options are available:</source>
          <target state="translated">다음과 같은 &lt;code&gt;argparse&lt;/code&gt; 옵션을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="224bb1116b7af6da373f3bd98c7370044c04d51d" translate="yes" xml:space="preserve">
          <source>The following additional options are also understood by &lt;code&gt;ulimit&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;ulimit&lt;/code&gt; 는 다음과 같은 추가 옵션도 이해합니다 .</target>
        </trans-unit>
        <trans-unit id="72e92d902d19c4f9a787cc785c9f6f673c804c7c" translate="yes" xml:space="preserve">
          <source>The following code first defines an event handler for the generic event named 'test_event', and then emits an event of that type.</source>
          <target state="translated">다음 코드는 먼저 'test_event'라는 일반 이벤트에 대한 이벤트 핸들러를 정의한 다음 해당 유형의 이벤트를 생성합니다.</target>
        </trans-unit>
        <trans-unit id="4dfce41da5b846516accbd2a1b32a0ea88076d5d" translate="yes" xml:space="preserve">
          <source>The following code is an implementation of the false command as a fish function</source>
          <target state="translated">다음 코드는 피쉬 함수로 false 명령을 구현 한 것입니다</target>
        </trans-unit>
        <trans-unit id="73f428206d6cc247fb0a938bd495734a3eb822ae" translate="yes" xml:space="preserve">
          <source>The following code removes all tmp files that do not contain the word smurf.</source>
          <target state="translated">다음 코드는 smurf를 포함하지 않는 모든 tmp 파일을 제거합니다.</target>
        </trans-unit>
        <trans-unit id="479b6746587510b08a8b09d6baf9432244f03bce" translate="yes" xml:space="preserve">
          <source>The following code reports an error and exits if no file named spoon can be found.</source>
          <target state="translated">다음 코드는 오류라는 이름의 파일을 찾을 수 없으면 오류를보고하고 종료합니다.</target>
        </trans-unit>
        <trans-unit id="c4c2a9bc321af801fbf29261dd0e7d5af4245506" translate="yes" xml:space="preserve">
          <source>The following code runs the &lt;code&gt;make&lt;/code&gt; command to build a program. If the build succeeds, &lt;code&gt;make&lt;/code&gt;'s exit status is 0, and the program is installed. If either step fails, the exit status is 1, and &lt;code&gt;make clean&lt;/code&gt; is run, which removes the files created by the build process.</source>
          <target state="translated">다음 코드는 &lt;code&gt;make&lt;/code&gt; 명령을 실행하여 프로그램을 빌드합니다. 빌드가 성공하면 &lt;code&gt;make&lt;/code&gt; 의 종료 상태가 0이고 프로그램이 설치됩니다. 두 단계 중 하나라도 실패하면 종료 상태는 1이고 &lt;code&gt;make clean&lt;/code&gt; 가 실행되어 빌드 프로세스에서 작성된 파일이 제거됩니다.</target>
        </trans-unit>
        <trans-unit id="546e6c9b6b78b14a90cdffaa174cd31d19fddac9" translate="yes" xml:space="preserve">
          <source>The following code runs the &lt;code&gt;make&lt;/code&gt; command to build a program. If the build succeeds, the program is installed. If either step fails, &lt;code&gt;make clean&lt;/code&gt; is run, which removes the files created by the build process.</source>
          <target state="translated">다음 코드는 &lt;code&gt;make&lt;/code&gt; 명령을 실행하여 프로그램을 빌드합니다. 빌드가 성공하면 프로그램이 설치됩니다. 두 단계 중 하나라도 실패하면 &lt;code&gt;make clean&lt;/code&gt; 가 실행되어 빌드 프로세스에서 작성된 파일이 제거됩니다.</target>
        </trans-unit>
        <trans-unit id="22ceb5db939abfc8429d0cfac70346e285c29f90" translate="yes" xml:space="preserve">
          <source>The following code searches all .c files for &quot;smurf&quot;, and halts at the first occurrence.</source>
          <target state="translated">다음 코드는 모든 .c 파일에서 &quot;smurf&quot;를 검색하고 처음 발생하면 중지됩니다.</target>
        </trans-unit>
        <trans-unit id="4275d8a3b1aa0d62413745bb834485269f681525" translate="yes" xml:space="preserve">
          <source>The following code sets a number of variables inside of a block scope. Since the variables are set inside the block and have local scope, they will be automatically deleted when the block ends.</source>
          <target state="translated">다음 코드는 블록 범위 내에서 여러 변수를 설정합니다. 변수는 블록 내부에 설정되고 로컬 범위가 있으므로 블록이 끝나면 자동으로 삭제됩니다.</target>
        </trans-unit>
        <trans-unit id="9c3e3b53e3555daf8b545c545da16a2dcb0110a7" translate="yes" xml:space="preserve">
          <source>The following code stores the value 'hello' in the shell variable &lt;code&gt;$foo&lt;/code&gt;.</source>
          <target state="translated">다음 코드는 쉘 변수 &lt;code&gt;$foo&lt;/code&gt; 에 'hello'값을 저장합니다 .</target>
        </trans-unit>
        <trans-unit id="381bfb0bdea553cc88676dcf9cb0ff3a9ee0da17" translate="yes" xml:space="preserve">
          <source>The following code tests whether a file &lt;code&gt;foo.txt&lt;/code&gt; exists as a regular file.</source>
          <target state="translated">다음 코드는 &lt;code&gt;foo.txt&lt;/code&gt; 파일이 일반 파일로 존재 하는지 테스트합니다 .</target>
        </trans-unit>
        <trans-unit id="96c71a4810d00e2a53ad0417748ddcd2d89501b6" translate="yes" xml:space="preserve">
          <source>The following code will call the ls command. Note that &lt;code&gt;fish&lt;/code&gt; does not support the use of shell variables as direct commands; &lt;code&gt;eval&lt;/code&gt; can be used to work around this.</source>
          <target state="translated">다음 코드는 ls 명령을 호출합니다. 참고 &lt;code&gt;fish&lt;/code&gt; 직접 명령으로 쉘 변수의 사용을 지원하지 않습니다; &lt;code&gt;eval&lt;/code&gt; 을 사용하여이 문제를 해결할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ca62666931da18a9248d4ac0f516c18c3953407d" translate="yes" xml:space="preserve">
          <source>The following code will count down from a random even number between 10 and 20 to 1:</source>
          <target state="translated">다음 코드는 10과 20에서 1 사이의 임의의 짝수에서 카운트 다운됩니다.</target>
        </trans-unit>
        <trans-unit id="b827c00166140f0325b113f6c5ec11ead3608d8d" translate="yes" xml:space="preserve">
          <source>The following code will create &lt;code&gt;rmi&lt;/code&gt;, which runs &lt;code&gt;rm&lt;/code&gt; with additional arguments on every invocation.</source>
          <target state="translated">다음 코드는 &lt;code&gt;rmi&lt;/code&gt; 를 생성 하는데, 이것은 호출 할 때마다 추가 인수로 &lt;code&gt;rm&lt;/code&gt; 을 실행 합니다.</target>
        </trans-unit>
        <trans-unit id="2bda4fa27dff7ecce2f691a9e2a6631fca487d27" translate="yes" xml:space="preserve">
          <source>The following code will not output anything:</source>
          <target state="translated">다음 코드는 아무것도 출력하지 않습니다 :</target>
        </trans-unit>
        <trans-unit id="ef1c53d0ac92fed4883e8ae1b1d7d027d13ad785" translate="yes" xml:space="preserve">
          <source>The following code will print &quot;foo.txt exists and is readable&quot; if foo.txt is a regular file and readable</source>
          <target state="translated">다음 코드는 foo.txt가 일반 파일이고 읽을 수있는 경우 &quot;foo.txt가 존재하고 읽을 수 있습니다&quot;를 인쇄합니다.</target>
        </trans-unit>
        <trans-unit id="1b900844821e8f04f7dd1574d0cf172ece4e3553" translate="yes" xml:space="preserve">
          <source>The following code will print &lt;code&gt;foo.txt exists&lt;/code&gt; if the file foo.txt exists and is a regular file, otherwise it will print &lt;code&gt;bar.txt exists&lt;/code&gt; if the file bar.txt exists and is a regular file, otherwise it will print &lt;code&gt;foo.txt and bar.txt do not exist&lt;/code&gt;.</source>
          <target state="translated">다음 코드는 &lt;code&gt;foo.txt exists&lt;/code&gt; 파일이 존재하고 일반 파일 인 경우 foo.txt가 인쇄되고 그렇지 않으면 &lt;code&gt;bar.txt exists&lt;/code&gt; 파일이 존재하고 일반 파일 인 경우 bar.txt가 인쇄 됩니다. 그렇지 않으면 &lt;code&gt;foo.txt and bar.txt do not exist&lt;/code&gt; 가 인쇄됩니다. bar.txt가 존재하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="de3876978d90a169388326ae4fae09574262829b" translate="yes" xml:space="preserve">
          <source>The following operations (sub-commands) are available:</source>
          <target state="translated">다음과 같은 작업 (하위 명령)을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="87ad7915cdbf5aabf9ec8f4e6f650717a3e51ad5" translate="yes" xml:space="preserve">
          <source>The following options are available:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d66ddc0c6de8a95bb5854453416293c96da8d8a9" translate="yes" xml:space="preserve">
          <source>The following options change the way &lt;code&gt;commandline&lt;/code&gt; prints the current commandline buffer:</source>
          <target state="translated">다음 옵션은 &lt;code&gt;commandline&lt;/code&gt; 이 현재 명령 행 버퍼를 인쇄하는 방식을 변경합니다 .</target>
        </trans-unit>
        <trans-unit id="63df7f64ccf12b96665f8dde259ffe470d38015a" translate="yes" xml:space="preserve">
          <source>The following options change the way &lt;code&gt;commandline&lt;/code&gt; updates the command line buffer:</source>
          <target state="translated">옵션은 다음과 방식 변경 &lt;code&gt;commandline&lt;/code&gt; 업데이트를 명령 행 버퍼를 :</target>
        </trans-unit>
        <trans-unit id="74214e3ec02696aeea391992facc065916f44218" translate="yes" xml:space="preserve">
          <source>The following options change what part of the commandline is printed or updated:</source>
          <target state="translated">다음 옵션은 명령 줄에서 인쇄 또는 업데이트되는 부분을 변경합니다.</target>
        </trans-unit>
        <trans-unit id="4caebaf69abe1f045ca9b70c7d77c6343b9dba77" translate="yes" xml:space="preserve">
          <source>The following options control variable scope:</source>
          <target state="translated">다음 옵션은 변수 범위를 제어합니다.</target>
        </trans-unit>
        <trans-unit id="de38d59c5de4e05441ae91dc9bbb795a1e1439a4" translate="yes" xml:space="preserve">
          <source>The following options output metadata about the commandline state:</source>
          <target state="translated">다음 옵션은 명령 줄 상태에 대한 메타 데이터를 출력합니다.</target>
        </trans-unit>
        <trans-unit id="2cc91c14fc643ec75cd8e42977ab3bf342c34ee4" translate="yes" xml:space="preserve">
          <source>The following parameters are available:</source>
          <target state="translated">다음과 같은 파라미터를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="328c4823c00af02675ec490144bb09f24d6106dd" translate="yes" xml:space="preserve">
          <source>The following special input functions are available:</source>
          <target state="translated">다음과 같은 특수 입력 기능을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f152dd9767da97d86c0b7bee6016016e58054d4e" translate="yes" xml:space="preserve">
          <source>The following subcommands are available.</source>
          <target state="translated">다음 부속 명령이 사용 가능합니다.</target>
        </trans-unit>
        <trans-unit id="58f88b1896d25d9e560265aa1ea2d352215c9687" translate="yes" xml:space="preserve">
          <source>The following variables are available to change the highlighting colors in fish:</source>
          <target state="translated">물고기의 강조 색상을 변경하기 위해 다음 변수를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c602bb0a290012cbead72e55c75dd6308e892909" translate="yes" xml:space="preserve">
          <source>The functions shipped with fish, usually installed in &lt;code&gt;/usr/share/fish/functions&lt;/code&gt;.</source>
          <target state="translated">물고기와 함께 제공되는 기능으로 보통 &lt;code&gt;/usr/share/fish/functions&lt;/code&gt; 에 설치 됩니다.</target>
        </trans-unit>
        <trans-unit id="31d1d74253673e0e00e4ab6d298c6cfbfbe641c4" translate="yes" xml:space="preserve">
          <source>The last value assigned to &lt;code&gt;var&lt;/code&gt; when the loop terminated would not be available outside the loop. What &lt;code&gt;echo $var&lt;/code&gt; would write depended on what it was set to before the loop was run. Likely nothing.</source>
          <target state="translated">루프가 종료 될 때 &lt;code&gt;var&lt;/code&gt; 에 지정된 마지막 값 은 루프 외부에서 사용할 수 없습니다. 무슨 일이 &lt;code&gt;echo $var&lt;/code&gt; 가 루프가 실행되기 전에 설정 한 내용에 의존 작성합니다. 아마 아무것도 아닙니다.</target>
        </trans-unit>
        <trans-unit id="4b5d758036d63a8bf5273befa9ba2de30bb1d084" translate="yes" xml:space="preserve">
          <source>The latter syntax &lt;code&gt;{$WORD}&lt;/code&gt; works by exploiting &lt;a href=&quot;#expand-brace&quot;&gt;brace expansion&lt;/a&gt;.</source>
          <target state="translated">후자의 구문 &lt;code&gt;{$WORD}&lt;/code&gt; 은 &lt;a href=&quot;#expand-brace&quot;&gt;중괄호 확장&lt;/a&gt; 을 활용하여 작동합니다 .</target>
        </trans-unit>
        <trans-unit id="af91f79f8373488bcf43ad9d85211f47c5490d9e" translate="yes" xml:space="preserve">
          <source>The long answer:</source>
          <target state="translated">긴 대답 :</target>
        </trans-unit>
        <trans-unit id="3bc04ce8ee0aaf5de96a68984a57d83e6ba0f996" translate="yes" xml:space="preserve">
          <source>The most common way to set the locale to use a command like 'set -x LANG en_GB.utf8', which sets the current locale to be the English language, as used in Great Britain, using the UTF-8 character set. For a list of available locales, use 'locale -a'.</source>
          <target state="translated">로케일을 'set -x LANG en_GB.utf8'과 같은 명령을 사용하도록 로케일을 설정하는 가장 일반적인 방법은 UTF-8 문자 세트를 사용하여 영국에서 사용되는 현재 로케일을 영어로 설정합니다. 사용 가능한 로케일 목록을 보려면 'locale -a'를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="65aa63047471b9a76e26dd8f43f5899f1292feb3" translate="yes" xml:space="preserve">
          <source>The names given to shell objects such as variables and function names are known as &quot;identifiers&quot;. Each type of identifier has rules that define the valid sequence of characters which compose the identifier.</source>
          <target state="translated">변수 및 함수 이름과 같은 쉘 오브젝트에 지정된 이름을 &quot;식별자&quot;라고합니다. 각 식별자 유형에는 식별자를 구성하는 유효한 문자 시퀀스를 정의하는 규칙이 있습니다.</target>
        </trans-unit>
        <trans-unit id="2fe3f46a59e146e352f1c4758de7a57641a2c629" translate="yes" xml:space="preserve">
          <source>The names of these variables are mostly derived from the csh family of shells and differ from the ones used by Bourne style shells such as bash.</source>
          <target state="translated">이러한 변수의 이름은 주로 csh 쉘 제품군에서 파생되며 bash와 같은 Bourne 스타일 쉘에서 사용되는 것과 다릅니다.</target>
        </trans-unit>
        <trans-unit id="0cdd8d204de3244af011ba40dd2e1e03a80c3965" translate="yes" xml:space="preserve">
          <source>The official mailing list at &lt;a href=&quot;https://lists.sourceforge.net/lists/listinfo/fish-users&quot;&gt;fish-users@lists.sourceforge.net&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;https://lists.sourceforge.net/lists/listinfo/fish-users&quot;&gt;fish-users@lists.sourceforge.net&lt;/a&gt; 의 공식 메일 링리스트</target>
        </trans-unit>
        <trans-unit id="341137762021767c1bcfe1d4e89d1efb6ab672f6" translate="yes" xml:space="preserve">
          <source>The open command doesn't work.</source>
          <target state="translated">열기 명령이 작동하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="1270e20d3a3df8e1f5346556fc472ccabc75c9c8" translate="yes" xml:space="preserve">
          <source>The options for specifying command name and command path may be used multiple times to define the same completions for multiple commands.</source>
          <target state="translated">명령 이름과 명령 경로를 지정하는 옵션을 여러 번 사용하여 여러 명령에 대해 동일한 완료를 정의 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ff3a156169840aa3d5e264e866d9a002dac09c1f" translate="yes" xml:space="preserve">
          <source>The options for specifying command switches and wrapped commands may be used multiple times to define multiple completions for the command(s) in a single call.</source>
          <target state="translated">명령 스위치 및 랩핑 된 명령을 지정하기위한 옵션을 여러 번 사용하여 단일 호출에서 명령에 대한 여러 완료를 정의 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="514a8bdf395655769cdf0c1f52c06c11623edf78" translate="yes" xml:space="preserve">
          <source>The other conditionals use the &lt;a href=&quot;#variables-status&quot;&gt;exit status&lt;/a&gt; of a command to decide if a command or a block of commands should be executed. See the documentation for &lt;a href=&quot;commands#if&quot;&gt;&lt;code&gt;if&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;commands#and&quot;&gt;&lt;code&gt;and&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;commands#or&quot;&gt;&lt;code&gt;or&lt;/code&gt;&lt;/a&gt; for more information.</source>
          <target state="translated">다른 조건 은 명령 의 &lt;a href=&quot;#variables-status&quot;&gt;종료 상태&lt;/a&gt; 를 사용하여 명령 또는 명령 블록을 실행할지 여부를 결정합니다. 설명서를 참조 &lt;a href=&quot;commands#if&quot;&gt; &lt;code&gt;if&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;commands#and&quot;&gt; &lt;code&gt;and&lt;/code&gt; &lt;/a&gt; 하고 &lt;a href=&quot;commands#or&quot;&gt; &lt;code&gt;or&lt;/code&gt; &lt;/a&gt; 더 많은 정보를 얻을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a2490e597900e8176c6a2c4a4584d5571260ded3" translate="yes" xml:space="preserve">
          <source>The output of a series of commands can be used as the parameters to another command. If a parameter contains a set of parenthesis, the text enclosed by the parenthesis will be interpreted as a list of commands. On expansion, this list is executed, and substituted by the output. If the output is more than one line long, each line will be expanded to a new parameter. Setting &lt;code&gt;IFS&lt;/code&gt; to the empty string will disable line splitting.</source>
          <target state="translated">일련의 명령 출력을 다른 명령의 매개 변수로 사용할 수 있습니다. 매개 변수에 괄호 세트가 포함 된 경우 괄호로 묶인 텍스트는 명령 목록으로 해석됩니다. 확장시이 목록이 실행되고 출력으로 대체됩니다. 출력이 두 줄 이상인 경우 각 줄은 새 매개 변수로 확장됩니다. 빈 문자열로 &lt;code&gt;IFS&lt;/code&gt; 를 설정하면 행 분할이 비활성화됩니다.</target>
        </trans-unit>
        <trans-unit id="c076b2b362e357c8c787010692c3897b0cde8acf" translate="yes" xml:space="preserve">
          <source>The previous test can likewise be inverted:</source>
          <target state="translated">이전 테스트도 마찬가지로 반전 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ddedd2674467015f6a5beb34ee2fbb835520f26b" translate="yes" xml:space="preserve">
          <source>The programs &lt;code&gt;man&lt;/code&gt; and &lt;code&gt;whatis&lt;/code&gt; show all installed manual pages as completions.</source>
          <target state="translated">프로그램 &lt;code&gt;man&lt;/code&gt; 및 &lt;code&gt;whatis&lt;/code&gt; 는 설치된 모든 매뉴얼 페이지를 완료로 표시합니다.</target>
        </trans-unit>
        <trans-unit id="923e6b118fb538f4ca8e8f67ca4698c422b3b072" translate="yes" xml:space="preserve">
          <source>The prompt is the output of the &lt;code&gt;fish_prompt&lt;/code&gt; function. Put it in &lt;code&gt;~/.config/fish/functions/fish_prompt.fish&lt;/code&gt;. For example, a simple prompt is:</source>
          <target state="translated">프롬프트는 &lt;code&gt;fish_prompt&lt;/code&gt; 함수 의 출력입니다 . 에 넣어 &lt;code&gt;~/.config/fish/functions/fish_prompt.fish&lt;/code&gt; . 예를 들어 간단한 프롬프트는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="f6c98e8413fa41203c749875900025da16302aca" translate="yes" xml:space="preserve">
          <source>The reason for providing for two output file descriptors is to allow separation of errors and warnings from regular program output.</source>
          <target state="translated">두 개의 출력 파일 디스크립터를 제공하는 이유는 일반 프로그램 출력에서 ​​오류와 경고를 분리 할 수 ​​있기 때문입니다.</target>
        </trans-unit>
        <trans-unit id="1c641b43a1ed9a01749c093f3a5864403b12f91c" translate="yes" xml:space="preserve">
          <source>The return status is 1 if any &lt;code&gt;REASON&lt;/code&gt; is invalid; otherwise trap returns 0.</source>
          <target state="translated">&lt;code&gt;REASON&lt;/code&gt; 이 유효하지 않은 경우 리턴 상태는 1 입니다. 그렇지 않으면 trap은 0을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="eec28e525883ec2bf359aa9ac84f19012ae7983d" translate="yes" xml:space="preserve">
          <source>The return status of &lt;code&gt;source&lt;/code&gt; is the return status of the last job to execute. If something goes wrong while opening or reading the file, &lt;code&gt;source&lt;/code&gt; exits with a non-zero status.</source>
          <target state="translated">의 반환 상태 &lt;code&gt;source&lt;/code&gt; 실행하기위한 마지막 작업의 반환 상태입니다. 파일을 열거 나 읽는 동안 문제가 발생하면 &lt;code&gt;source&lt;/code&gt; 는 0이 아닌 상태로 종료됩니다.</target>
        </trans-unit>
        <trans-unit id="1c30a73e8a51035e518bdfeccb5ae03bbba2a49e" translate="yes" xml:space="preserve">
          <source>The same works when setting or expanding variables:</source>
          <target state="translated">변수를 설정하거나 확장 할 때도 마찬가지입니다.</target>
        </trans-unit>
        <trans-unit id="0df43a9567e35d287e4e0a64578b1540c9c5524d" translate="yes" xml:space="preserve">
          <source>The scoping rules when creating or updating a variable are:</source>
          <target state="translated">변수를 만들거나 업데이트 할 때 범위 지정 규칙은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="af1ca2dded8974103c58a768e1e91d3d877d12bd" translate="yes" xml:space="preserve">
          <source>The script should write any error messages to stdout, not stderr. It should return a status of zero if the flag value is valid otherwise a non-zero status to indicate it is invalid.</source>
          <target state="translated">스크립트는 stderr가 아닌 오류 메시지를 stdout에 작성해야합니다. 플래그 값이 유효하면 0의 상태를 리턴하고 그렇지 않으면 유효하지 않음을 나타내는 0이 아닌 상태를 리턴해야합니다.</target>
        </trans-unit>
        <trans-unit id="ea5694e15d95ca5a5e96c990e236cff7fa4686dd" translate="yes" xml:space="preserve">
          <source>The second part of a right specifies the mode, and can be one of &lt;code&gt;=&lt;/code&gt;, &lt;code&gt;+&lt;/code&gt; or &lt;code&gt;-&lt;/code&gt;, where &lt;code&gt;=&lt;/code&gt; specifies that the rights should be set to the new value, &lt;code&gt;+&lt;/code&gt; specifies that the specified right should be added to those previously specified and &lt;code&gt;-&lt;/code&gt; specifies that the specified rights should be removed from those previously specified.</source>
          <target state="translated">우측 지정의 두 번째 부분 모드 중 하나 일 수 &lt;code&gt;=&lt;/code&gt; , &lt;code&gt;+&lt;/code&gt; 또는 &lt;code&gt;-&lt;/code&gt; , &lt;code&gt;=&lt;/code&gt; 권리는 새로운 값으로 설정되도록 지정, &lt;code&gt;+&lt;/code&gt; 지정 지정된 바로 이전에 지정된에 첨가되어야 함 &lt;code&gt;-&lt;/code&gt; 지정된 권한이 이전에 지정된 권한에서 제거되도록 지정합니다.</target>
        </trans-unit>
        <trans-unit id="7823c527da5d40f4505f5d7ca9cee1dbf65bd935" translate="yes" xml:space="preserve">
          <source>The short style option &lt;code&gt;-d&lt;/code&gt; for the &lt;code&gt;grep&lt;/code&gt; command requires that one of the strings '&lt;code&gt;read&lt;/code&gt;', '&lt;code&gt;skip&lt;/code&gt;' or '&lt;code&gt;recurse&lt;/code&gt;' is used. This can be specified writing:</source>
          <target state="translated">&lt;code&gt;grep&lt;/code&gt; 명령 의 짧은 스타일 옵션 &lt;code&gt;-d&lt;/code&gt; 를 사용 하려면 문자열 ' &lt;code&gt;read&lt;/code&gt; ', ' &lt;code&gt;skip&lt;/code&gt; '또는 ' &lt;code&gt;recurse&lt;/code&gt; '중 하나를 사용해야합니다. 이것은 다음과 같이 쓸 수 있습니다 :</target>
        </trans-unit>
        <trans-unit id="21aef96d543138db0f5113aa8c694e877221993a" translate="yes" xml:space="preserve">
          <source>The short style option &lt;code&gt;-o&lt;/code&gt; for the &lt;code&gt;gcc&lt;/code&gt; command requires that a file follows it. This can be done using writing:</source>
          <target state="translated">&lt;code&gt;gcc&lt;/code&gt; 명령 의 짧은 스타일 옵션 &lt;code&gt;-o&lt;/code&gt; 를 사용 하려면 파일이 뒤에옵니다. 쓰기를 사용하여 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a7c9c314ad94ef58d396d8ee54dfb17c9688e5cf" translate="yes" xml:space="preserve">
          <source>The status variable</source>
          <target state="translated">상태 변수</target>
        </trans-unit>
        <trans-unit id="3d79b5f2fb8b7ff9607cb6173124ce2876018175" translate="yes" xml:space="preserve">
          <source>The string FORMAT should contain format specifiers, each of which are replaced with successive arguments according to the specifier. Specifiers are detailed below, and are taken from the C library function &lt;code&gt;printf(3)&lt;/code&gt;.</source>
          <target state="translated">문자열 FORMAT은 형식 지정자를 포함해야하며 각 지정자는 지정자에 따라 연속 인수로 대체됩니다. 지정자는 아래에 자세히 설명되어 있으며 C 라이브러리 함수 &lt;code&gt;printf(3)&lt;/code&gt; 에서 가져옵니다 .</target>
        </trans-unit>
        <trans-unit id="78761829292527d745af43c24666b70964c2aa8e" translate="yes" xml:space="preserve">
          <source>The third part of a right specifies what rights should be changed and can be any combination of &lt;code&gt;r&lt;/code&gt;, &lt;code&gt;w&lt;/code&gt; and &lt;code&gt;x&lt;/code&gt;, representing read, write and execute rights.</source>
          <target state="translated">권한의 세 번째 부분은 변경 될 권한을 지정하며 읽기, 쓰기 및 실행 권한을 나타내는 &lt;code&gt;r&lt;/code&gt; , &lt;code&gt;w&lt;/code&gt; 및 &lt;code&gt;x&lt;/code&gt; 의 조합 일 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="f6aea30b4125640db0c941f62792d8db2583d13d" translate="yes" xml:space="preserve">
          <source>The tool will write an example &lt;code&gt;bind&lt;/code&gt; command matching the character sequence captured to stdout. If the character sequence matches a special key name (see &lt;code&gt;bind --key-names&lt;/code&gt;), both &lt;code&gt;bind CHARS ...&lt;/code&gt; and &lt;code&gt;bind -k KEYNAME ...&lt;/code&gt; usage will be shown. Additional details about the characters received, such as the delay between chars, are written to stderr.</source>
          <target state="translated">도구는 stdout에 캡처 된 문자 순서와 일치 하는 예제 &lt;code&gt;bind&lt;/code&gt; 명령 을 작성합니다 . 문자 순서가 특수 키 이름과 일치하면 ( &lt;code&gt;bind --key-names&lt;/code&gt; 참조 ) &lt;code&gt;bind CHARS ...&lt;/code&gt; 및 &lt;code&gt;bind -k KEYNAME ...&lt;/code&gt; 사용법이 모두 표시됩니다. 문자 사이의 지연과 같이 수신 된 문자에 대한 추가 세부 사항은 stderr에 기록됩니다.</target>
        </trans-unit>
        <trans-unit id="33a16e681c6b2de523ee079730543d5aaaa072a3" translate="yes" xml:space="preserve">
          <source>The umask may be expressed either as an octal number, which represents the rights that will be removed by default, or symbolically, which represents the only rights that will be granted by default.</source>
          <target state="translated">umask는 기본적으로 제거 될 권한을 나타내는 8 진수 또는 기본적으로 부여 될 유일한 권한을 나타내는 상징적으로 표현 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ff67961119e87010a71ffb5f982a7874fbd862b2" translate="yes" xml:space="preserve">
          <source>The user can change the settings of &lt;code&gt;fish&lt;/code&gt; by changing the values of certain variables.</source>
          <target state="translated">사용자는 특정 변수의 값을 변경하여 &lt;code&gt;fish&lt;/code&gt; 의 설정을 변경할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="92734526becf97d0102e67503ae3f5ec70437f52" translate="yes" xml:space="preserve">
          <source>The user can string together multiple commands into a so called pipeline. This means that the standard output of one command will be read in as standard input into the next command. This is done by separating the commands by the pipe character '&lt;code&gt;|&lt;/code&gt;'. For example</source>
          <target state="translated">사용자는 여러 명령을 소위 파이프 라인으로 묶을 수 있습니다. 이는 한 명령의 표준 출력이 다음 명령의 표준 입력으로 읽히는 것을 의미합니다. 이것은 파이프 문자 ' &lt;code&gt;|&lt;/code&gt; '. 예를 들어</target>
        </trans-unit>
        <trans-unit id="7b8b4db39167ca73155b4a80905652bbe883d472" translate="yes" xml:space="preserve">
          <source>The value of limit can be a number in the unit specified for the resource or one of the special values &lt;code&gt;hard&lt;/code&gt;, &lt;code&gt;soft&lt;/code&gt;, or &lt;code&gt;unlimited&lt;/code&gt;, which stand for the current hard limit, the current soft limit, and no limit, respectively.</source>
          <target state="translated">limit 값은 자원에 지정된 단위 또는 &lt;code&gt;hard&lt;/code&gt; , &lt;code&gt;soft&lt;/code&gt; 또는 &lt;code&gt;unlimited&lt;/code&gt; 특수 값 중 하나 일 수 있으며, 각각 현재 하드 제한, 현재 소프트 제한 및 제한 없음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="ea2f6068a9dad88efc3494909770d142904666d0" translate="yes" xml:space="preserve">
          <source>The web interface allows you to view your functions, variables and history, and to make changes to your prompt and color configuration.</source>
          <target state="translated">웹 인터페이스를 사용하면 기능, 변수 및 기록을보고 프롬프트 및 색상 구성을 변경할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="27cd5ebce2dff7c39841e898f946a341a35b41e4" translate="yes" xml:space="preserve">
          <source>Then the following invocations behave like this:</source>
          <target state="translated">그런 다음 다음 호출이 다음과 같이 작동합니다.</target>
        </trans-unit>
        <trans-unit id="fa54c06d5fdedec560ab96fcbf9871934330e6d3" translate="yes" xml:space="preserve">
          <source>There are a few important things that need to be noted about aliases:</source>
          <target state="translated">별명에 대해 주목해야 할 몇 가지 중요한 사항이 있습니다.</target>
        </trans-unit>
        <trans-unit id="3ba25ca105726fc0d596821887908ff16a459bda" translate="yes" xml:space="preserve">
          <source>There are also special switches for specifying that a switch requires an argument, to disable filename completion, to create completions that are only available in some combinations, etc.. For a complete description of the various switches accepted by the &lt;code&gt;complete&lt;/code&gt; command, see the documentation for the &lt;a href=&quot;commands#complete&quot;&gt;complete&lt;/a&gt; builtin, or write &lt;code&gt;complete --help&lt;/code&gt; inside the &lt;code&gt;fish&lt;/code&gt; shell.</source>
          <target state="translated">또한 스위치에 인수가 필요하고 파일 이름 완성을 비활성화하고 일부 조합에서만 사용할 수있는 완성을 작성하는 등의 특수 스위치가 있습니다. &lt;code&gt;complete&lt;/code&gt; 명령에 의해 허용되는 다양한 스위치에 대한 자세한 설명은 설명서를 참조하십시오. 에 대한 &lt;a href=&quot;commands#complete&quot;&gt;완전한&lt;/a&gt; 내장 또는 쓰기 &lt;code&gt;complete --help&lt;/code&gt; 내부 &lt;code&gt;fish&lt;/code&gt; 껍질.</target>
        </trans-unit>
        <trans-unit id="2d9df96be8b6a2362ccd2ca558b23ccf8d96cd57" translate="yes" xml:space="preserve">
          <source>There are four fish builtins that let you execute commands only if a specific criterion is met. These builtins are &lt;a href=&quot;commands#if&quot;&gt;&lt;code&gt;if&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;commands#switch&quot;&gt;&lt;code&gt;switch&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;commands#and&quot;&gt;&lt;code&gt;and&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;commands#or&quot;&gt;&lt;code&gt;or&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">특정 기준을 충족하는 경우에만 명령을 실행할 수있는 4 개의 물고기 내장이 있습니다. 이러한 내장 매크로는 &lt;a href=&quot;commands#if&quot;&gt; &lt;code&gt;if&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;commands#switch&quot;&gt; &lt;code&gt;switch&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;commands#and&quot;&gt; &lt;code&gt;and&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;commands#or&quot;&gt; &lt;code&gt;or&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="255b5925229ebf64b3dccbaf56f554bfda33418a" translate="yes" xml:space="preserve">
          <source>There are no parameters for &lt;code&gt;break&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;break&lt;/code&gt; 매개 변수가 없습니다 .</target>
        </trans-unit>
        <trans-unit id="a56ebf43ed98e5db43b2052e83aa4d07a4140747" translate="yes" xml:space="preserve">
          <source>There are no parameters for &lt;code&gt;breakpoint&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;breakpoint&lt;/code&gt; 대한 매개 변수가 없습니다 .</target>
        </trans-unit>
        <trans-unit id="c25f17ac972a261d801c33ab7a6b142dc2017014" translate="yes" xml:space="preserve">
          <source>There are no parameters for &lt;code&gt;fish_update_completions&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;fish_update_completions&lt;/code&gt; 에 대한 매개 변수가 없습니다 .</target>
        </trans-unit>
        <trans-unit id="031b665a362fca99dc2232105e16d4be76ec8e13" translate="yes" xml:space="preserve">
          <source>There are three kinds of variables in fish: universal, global and local variables. Universal variables are shared between all fish sessions a user is running on one computer. Global variables are specific to the current fish session, but are not associated with any specific block scope, and will never be erased unless the user explicitly requests it using &lt;code&gt;set -e&lt;/code&gt;. Local variables are specific to the current fish session, and associated with a specific block of commands, and is automatically erased when a specific block goes out of scope. A block of commands is a series of commands that begins with one of the commands &lt;code&gt;for&lt;/code&gt;, &lt;code&gt;while&lt;/code&gt; , &lt;code&gt;if&lt;/code&gt;, &lt;code&gt;function&lt;/code&gt;, &lt;code&gt;begin&lt;/code&gt; or &lt;code&gt;switch&lt;/code&gt;, and ends with the command &lt;code&gt;end&lt;/code&gt;. The user can specify that a variable should have either global or local scope using the &lt;code&gt;-g/--global&lt;/code&gt; or &lt;code&gt;-l/--local&lt;/code&gt; switches.</source>
          <target state="translated">어류에는 3 가지 종류의 변수가 있습니다 : 보편적 변수, 전역 변수 및 지역 변수. 범용 변수는 사용자가 한 컴퓨터에서 실행중인 모든 피쉬 세션간에 공유됩니다. 전역 변수는 현재 피쉬 세션에 따라 다르지만 특정 블록 범위와 관련이 없으며 사용자가 &lt;code&gt;set -e&lt;/code&gt; 를 사용하여 명시 적으로 요청하지 않으면 지워지지 않습니다 . 지역 변수는 현재 피쉬 세션에 따라 다르며 특정 명령 블록과 관련이 있으며 특정 블록이 범위를 벗어나면 자동으로 지워집니다. 명령 블록은 하나의 명령으로 시작하는 일련의 명령이다 &lt;code&gt;for&lt;/code&gt; , &lt;code&gt;while&lt;/code&gt; , &lt;code&gt;if&lt;/code&gt; , &lt;code&gt;function&lt;/code&gt; , &lt;code&gt;begin&lt;/code&gt; 또는 &lt;code&gt;switch&lt;/code&gt; , &lt;code&gt;end&lt;/code&gt; 명령으로 끝납니다 . 사용자는 &lt;code&gt;-g/--global&lt;/code&gt; 또는 &lt;code&gt;-l/--local&lt;/code&gt; 스위치를 사용하여 변수에 전역 또는 로컬 범위가 있어야 함을 지정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="a8bb46a6b8bc305c23a119159486bd2d5c470ee5" translate="yes" xml:space="preserve">
          <source>There are two breaking changes in fish 3.0: caret &lt;code&gt;^&lt;/code&gt; no longer redirects stderr, and question mark &lt;code&gt;?&lt;/code&gt; is no longer a glob. These changes are off by default. They can be enabled on a per session basis:</source>
          <target state="translated">물고기 3.0에는 두 가지 주요 변경 사항이 있습니다. caret &lt;code&gt;^&lt;/code&gt; 더 이상 stderr를 리디렉션하지 않고 물음표 &lt;code&gt;?&lt;/code&gt; 더 이상 glob가 아닙니다. 이러한 변경 사항은 기본적으로 해제되어 있습니다. 세션별로 활성화 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="20ceb2460c137862f053425df367d426c42e4313" translate="yes" xml:space="preserve">
          <source>There is also a &lt;code&gt;switch&lt;/code&gt; command:</source>
          <target state="translated">도있다 &lt;code&gt;switch&lt;/code&gt; 명령 :</target>
        </trans-unit>
        <trans-unit id="b0866a618c196f1ac7d2ced3309d7b238c006085" translate="yes" xml:space="preserve">
          <source>There may be many variables with the same name, but different scopes. When using a variable, the variable scope will be searched from the inside out, i.e. a local variable will be used rather than a global variable with the same name, a global variable will be used rather than a universal variable with the same name.</source>
          <target state="translated">이름은 같지만 범위가 다른 변수가 많이있을 수 있습니다. 변수를 사용할 때 변수 범위는 내부에서 검색됩니다. 즉, 같은 이름의 전역 변수 대신 로컬 변수가 사용되고, 같은 이름의 범용 변수 대신 전역 변수가 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="d7f028aa2b19c153baae8d83c317ae110446208a" translate="yes" xml:space="preserve">
          <source>These are the general purpose tab completions that &lt;code&gt;fish&lt;/code&gt; provides:</source>
          <target state="translated">다음은 &lt;code&gt;fish&lt;/code&gt; 제공 하는 범용 탭 완성입니다 .</target>
        </trans-unit>
        <trans-unit id="e7972582e9c4968e777fc42db67d9b318fa79e46" translate="yes" xml:space="preserve">
          <source>These colors, and many more, can be changed by running &lt;code&gt;fish_config&lt;/code&gt;, or by modifying variables directly.</source>
          <target state="translated">&lt;code&gt;fish_config&lt;/code&gt; 를 실행 하거나 변수를 직접 수정 하여이 색상 등을 변경할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="91e1e5aba0c598515d08d40af2f8d04dd57004f4" translate="yes" xml:space="preserve">
          <source>These files are all executed on the startup of every shell. If you want to run a command only on starting an interactive shell, use the exit status of the command &lt;code&gt;status --is-interactive&lt;/code&gt; to determine if the shell is interactive. If you want to run a command only when using a login shell, use &lt;code&gt;status --is-login&lt;/code&gt; instead. This will speed up the starting of non-interactive or non-login shells.</source>
          <target state="translated">이 파일들은 모든 쉘이 시작될 때 모두 실행됩니다. 대화식 쉘을 시작할 때만 명령을 실행하려면 명령 &lt;code&gt;status --is-interactive&lt;/code&gt; 의 종료 상태를 사용 하여 쉘이 대화식인지 판별하십시오. 로그인 쉘을 사용할 때만 명령을 실행하려면 &lt;code&gt;status --is-login&lt;/code&gt; 을 대신 사용하십시오. 비 대화식 또는 비 로그인 셸의 시작 속도가 빨라집니다.</target>
        </trans-unit>
        <trans-unit id="80b96b3d74710e83d20ff5ac21723a42f2f052d6" translate="yes" xml:space="preserve">
          <source>These flags can appear before or immediately after one of the sub-commands listed above.</source>
          <target state="translated">이 플래그는 위에 나열된 하위 명령 중 하나 바로 앞이나 뒤에 나타날 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="018467e6400b14718548d65eb59c273e2720ed52" translate="yes" xml:space="preserve">
          <source>These paths are controlled by parameters set at build, install, or run time, and may vary from the defaults listed above.</source>
          <target state="translated">이러한 경로는 빌드, 설치 또는 런타임시 설정된 매개 변수에 의해 제어되며 위에 나열된 기본값과 다를 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d24f98a189aa3819db3885dc20417a7ef5fd2074" translate="yes" xml:space="preserve">
          <source>They are all used in an infix manner - &lt;code&gt;5 + 2&lt;/code&gt;, not &lt;code&gt;+ 5 2&lt;/code&gt;.</source>
          <target state="translated">그것들은 모두 &lt;code&gt;+ 5 2&lt;/code&gt; 아닌 &lt;code&gt;5 + 2&lt;/code&gt; 방식으로 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="af768071c5b224ad5b92ddb2ba1221dcbc0d859d" translate="yes" xml:space="preserve">
          <source>This also happens after &lt;a href=&quot;#expand-command-substitution&quot;&gt;command substitution&lt;/a&gt;. Therefore strings might be eliminated. This can be avoided by making the inner command return a trailing newline.</source>
          <target state="translated">&lt;a href=&quot;#expand-command-substitution&quot;&gt;명령 대체&lt;/a&gt; 후에도 발생합니다 . 따라서 문자열이 제거 될 수 있습니다. 내부 명령이 후행 줄 바꿈을 리턴하도록하여이를 피할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b50932aeaca87e43aadc296b2abd6503a42d3550" translate="yes" xml:space="preserve">
          <source>This calls the &lt;code&gt;echo&lt;/code&gt; command. &lt;code&gt;echo&lt;/code&gt; is a command which will write its arguments to the screen. In the example above, the output will be 'hello world'. Everything in fish is done with commands. There are commands for performing a set of commands multiple times, commands for assigning variables, commands for treating a group of commands as a single command, etc.. And every single command follows the same simple syntax.</source>
          <target state="translated">&lt;code&gt;echo&lt;/code&gt; 명령을 호출합니다 . &lt;code&gt;echo&lt;/code&gt; 는 인수를 화면에 쓰는 명령입니다. 위의 예에서 출력은 'hello world'입니다. 물고기의 모든 것은 명령으로 수행됩니다. 명령 집합을 여러 번 수행하는 명령, 변수 할당 명령, 명령 그룹을 단일 명령으로 처리하는 명령 등이 있습니다. 모든 단일 명령은 동일한 간단한 구문을 따릅니다.</target>
        </trans-unit>
        <trans-unit id="366a5d79af152ebea92d5f861ed8a475043b7941" translate="yes" xml:space="preserve">
          <source>This can be written as:</source>
          <target state="translated">이것은 다음과 같이 쓸 수 있습니다 :</target>
        </trans-unit>
        <trans-unit id="2c3fa67d634b278ec1a7802bf809ac5774656af1" translate="yes" xml:space="preserve">
          <source>This code will add some directories to $PATH if they aren't yet included:</source>
          <target state="translated">이 코드는 아직 포함되지 않은 경우 $ PATH에 일부 디렉토리를 추가합니다.</target>
        </trans-unit>
        <trans-unit id="46b694f24aed40624e847ae57ae10b126b23d033" translate="yes" xml:space="preserve">
          <source>This command makes it easy for fish scripts and functions to handle arguments in a manner 100% identical to how fish builtin commands handle their arguments. You pass a sequence of arguments that define the options recognized, followed by a literal &lt;code&gt;--&lt;/code&gt;, then the arguments to be parsed (which might also include a literal &lt;code&gt;--&lt;/code&gt;). More on this in the &lt;a href=&quot;#argparse-usage&quot;&gt;usage&lt;/a&gt; section below.</source>
          <target state="translated">이 명령을 사용하면 피쉬 스크립트와 함수가 피쉬 내장 명령이 인수를 처리하는 방식과 100 % 동일한 방식으로 인수를 쉽게 처리 할 수 ​​있습니다. 당신은 문자 다음에 인식 옵션을 정의 인수의 순서, 통과 &lt;code&gt;--&lt;/code&gt; 다음 인수가 (또한 문자를 포함 할 수있는 구문 분석하기를 &lt;code&gt;--&lt;/code&gt; ). 자세한 내용은 아래 &lt;a href=&quot;#argparse-usage&quot;&gt;사용법&lt;/a&gt; 섹션 에서 확인하십시오 .</target>
        </trans-unit>
        <trans-unit id="20cd8d04285455a5eeee7e58dc05b32ca7729358" translate="yes" xml:space="preserve">
          <source>This command provides a way to produce option specifications suitable for use with the &lt;a href=&quot;#argparse&quot;&gt;&lt;code&gt;argparse&lt;/code&gt;&lt;/a&gt; command. You can, of course, write the option specs by hand without using this command. But you might prefer to use this for the clarity it provides.</source>
          <target state="translated">이 명령은 &lt;a href=&quot;#argparse&quot;&gt; &lt;code&gt;argparse&lt;/code&gt; &lt;/a&gt; 명령 과 함께 사용하기에 적합한 옵션 사양을 생성하는 방법을 제공합니다 . 물론이 명령을 사용하지 않고 옵션 사양을 직접 작성할 수 있습니다. 그러나 명확성을 위해 이것을 사용하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="07448165c0f812cb8478f38c84a94b14d2215ae2" translate="yes" xml:space="preserve">
          <source>This does not overwrite custom completions.</source>
          <target state="translated">사용자 정의 완료를 덮어 쓰지 않습니다.</target>
        </trans-unit>
        <trans-unit id="6147eda0417a76ae63d83548f1bb6d3684130031" translate="yes" xml:space="preserve">
          <source>This file has been imported from the printf in GNU Coreutils version 6.9. If you would like to use a newer version of printf, for example the one shipped with your OS, try &lt;code&gt;command printf&lt;/code&gt;.</source>
          <target state="translated">이 파일은 GNU Coreutils 버전 6.9의 printf에서 가져 왔습니다. OS와 함께 제공된 것과 같은 최신 버전의 printf를 사용하려면 printf &lt;code&gt;command printf&lt;/code&gt; 시도하십시오 .</target>
        </trans-unit>
        <trans-unit id="36a27e8809bc8ecec60cf5b8b496d2f657edff50" translate="yes" xml:space="preserve">
          <source>This function is deprecated. Please call &lt;code&gt;fish_vi_key_bindings directly&lt;/code&gt;</source>
          <target state="translated">이 기능은 더 이상 사용되지 않습니다. &lt;code&gt;fish_vi_key_bindings directly&lt;/code&gt; 연락 하기</target>
        </trans-unit>
        <trans-unit id="cbbea16193e927515d0dc3be9146ab095157af42" translate="yes" xml:space="preserve">
          <source>This is a short explanation of some of the commonly used words in fish.</source>
          <target state="translated">이것은 물고기에서 일반적으로 사용되는 단어 중 일부에 대한 간단한 설명입니다.</target>
        </trans-unit>
        <trans-unit id="8d244f1f10393a3fd4f3ebf581d37f923228ef19" translate="yes" xml:space="preserve">
          <source>This is implemented as a function and a builtin. The function will attempt to use an external realpath command if one can be found. Otherwise it falls back to the builtin. The builtin does not support any options. It's meant to be used only by scripts which need to be portable. The builtin implementation behaves like GNU realpath when invoked without any options (which is the most common use case). In general scripts should not invoke the builtin directly. They should just use &lt;code&gt;realpath&lt;/code&gt;.</source>
          <target state="translated">이것은 함수와 내장으로 구현됩니다. 함수는 외부 realpath 명령을 찾을 수있는 경우이를 사용하려고 시도합니다. 그렇지 않으면 내장으로 돌아갑니다. 내장은 어떤 옵션도 지원하지 않습니다. 이식성이 필요한 스크립트 만 사용해야합니다. 내장 구현은 옵션 (가장 일반적인 유스 케이스)없이 호출 될 때 GNU 리얼 패스처럼 작동합니다. 일반적으로 스크립트는 내장을 직접 호출해서는 안됩니다. 그들은 단지 &lt;code&gt;realpath&lt;/code&gt; 를 사용해야 합니다.</target>
        </trans-unit>
        <trans-unit id="ee1d4171e513cf57adfa5dbd82bf66ed41edba27" translate="yes" xml:space="preserve">
          <source>This is not an exhaustive list and the fish project has no opinion regarding the merits of the repositories listed above or the scripts found therein.</source>
          <target state="translated">이것은 철저한 목록이 아니며 어류 프로젝트는 위에 나열된 리포지토리의 장점이나 그 안에있는 스크립트에 대한 의견이 없습니다.</target>
        </trans-unit>
        <trans-unit id="096d775aa834b5a98fc75f9c9df8cd5ad1df3f6c" translate="yes" xml:space="preserve">
          <source>This is similar to &lt;a href=&quot;index#expand-brace&quot;&gt;Brace expansion&lt;/a&gt;.</source>
          <target state="translated">이것은 &lt;a href=&quot;index#expand-brace&quot;&gt;Brace 확장&lt;/a&gt; 과 유사합니다 .</target>
        </trans-unit>
        <trans-unit id="87b5c6aa51fef3c82ea1bd8fddb7c95bed61e89d" translate="yes" xml:space="preserve">
          <source>This is the documentation for &lt;code&gt;fish&lt;/code&gt;, the friendly interactive shell. &lt;code&gt;fish&lt;/code&gt; is a user friendly commandline shell intended mostly for interactive use. A shell is a program used to execute other programs. For the latest information on &lt;code&gt;fish&lt;/code&gt;, please visit the &lt;a href=&quot;https://fishshell.com/&quot;&gt;&lt;code&gt;fish&lt;/code&gt; homepage&lt;/a&gt;.</source>
          <target state="translated">친숙한 대화식 쉘인 &lt;code&gt;fish&lt;/code&gt; 에 대한 문서입니다 . &lt;code&gt;fish&lt;/code&gt; 는 주로 대화식으로 사용하기위한 사용자 친화적 인 명령 줄 셸입니다. 쉘은 다른 프로그램을 실행하는 데 사용되는 프로그램입니다. &lt;code&gt;fish&lt;/code&gt; 에 대한 최신 정보 는 &lt;a href=&quot;https://fishshell.com/&quot;&gt; &lt;code&gt;fish&lt;/code&gt; 홈페이지&lt;/a&gt; 를 방문하십시오 .</target>
        </trans-unit>
        <trans-unit id="577bd6355fb298c4b6b2d6488f451eaa11f5dbb8" translate="yes" xml:space="preserve">
          <source>This is the preferred way to define your prompt as well:</source>
          <target state="translated">프롬프트를 정의 할 때 선호되는 방법입니다.</target>
        </trans-unit>
        <trans-unit id="8cc576b35450257aadce9343fd3afaecbb82068c" translate="yes" xml:space="preserve">
          <source>This means that the global value takes precedence over the universal value.</source>
          <target state="translated">이것은 글로벌 가치가 보편적 가치보다 우선한다는 것을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="51d7db524de6aeb12230612416aa7c659663fe8a" translate="yes" xml:space="preserve">
          <source>This prompt that you see above is the &lt;code&gt;fish&lt;/code&gt; default prompt: it shows your username, hostname, and working directory.</source>
          <target state="translated">위에 표시된이 프롬프트는 &lt;code&gt;fish&lt;/code&gt; 기본 프롬프트입니다. 사용자 이름, 호스트 이름 및 작업 디렉토리가 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="c731bb20159682c25c6b4c24ba8357e2f689c68f" translate="yes" xml:space="preserve">
          <source>This tells you that there exists a file that starts with '&lt;code&gt;somefi&lt;/code&gt;', which is useful feedback as you type.</source>
          <target state="translated">이것은 ' &lt;code&gt;somefi&lt;/code&gt; '로 시작하는 파일이 있다는 것을 알려주며 , 입력 할 때 유용한 피드백입니다.</target>
        </trans-unit>
        <trans-unit id="1ffb61bd1cd5715a466531b7a657f71109690e35" translate="yes" xml:space="preserve">
          <source>This test is mostly POSIX-compatible.</source>
          <target state="translated">이 테스트는 대부분 POSIX 호환입니다.</target>
        </trans-unit>
        <trans-unit id="44595c0d7ccfd8b4e39fcc6fb1c75e80391912f7" translate="yes" xml:space="preserve">
          <source>This tutorial assumes a basic understanding of command line shells and Unix commands, and that you have a working copy of &lt;code&gt;fish&lt;/code&gt;.</source>
          <target state="translated">이 학습서는 명령 행 쉘 및 Unix 명령에 대한 기본 지식을 가지고 있으며 작업중인 &lt;code&gt;fish&lt;/code&gt; 사본이 있다고 가정합니다 .</target>
        </trans-unit>
        <trans-unit id="f48d5a2439da006a37325d3b33d3046473c20c81" translate="yes" xml:space="preserve">
          <source>This wide search may be confusing. If you are unsure where to put your own customisations, use &lt;code&gt;~/.config/fish/config.fish&lt;/code&gt;.</source>
          <target state="translated">이 광범위한 검색은 혼란 스러울 수 있습니다. 자신의 사용자 정의 위치를 ​​모르는 경우 &lt;code&gt;~/.config/fish/config.fish&lt;/code&gt; 를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="f358815973e2ad20875ee5c37318a06668178037" translate="yes" xml:space="preserve">
          <source>This wide search may be confusing. If you are unsure, your completions probably belong in &lt;code&gt;~/.config/fish/completions&lt;/code&gt;.</source>
          <target state="translated">이 광범위한 검색은 혼란 스러울 수 있습니다. 확실하지 않은 경우, 완료는 &lt;code&gt;~/.config/fish/completions&lt;/code&gt; 에 속합니다 .</target>
        </trans-unit>
        <trans-unit id="fc8f74e5e402cdc09fe9163449bdf559dd908a47" translate="yes" xml:space="preserve">
          <source>This wide search may be confusing. If you are unsure, your functions probably belong in &lt;code&gt;~/.config/fish/functions&lt;/code&gt;.</source>
          <target state="translated">이 광범위한 검색은 혼란 스러울 수 있습니다. 확실하지 않은 경우 기능은 &lt;code&gt;~/.config/fish/functions&lt;/code&gt; 에 속할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="8a9195514b37c65c22f746374d557ac1c811b3ed" translate="yes" xml:space="preserve">
          <source>This will beep when the most recent job completes.</source>
          <target state="translated">가장 최근 작업이 완료되면 경고음이 울립니다.</target>
        </trans-unit>
        <trans-unit id="d275d705f3563e034e584f7f1416ca37d5829386" translate="yes" xml:space="preserve">
          <source>This will run the &lt;code&gt;mkdir&lt;/code&gt; command, and if it is successful, change the current working directory to the one just created.</source>
          <target state="translated">&lt;code&gt;mkdir&lt;/code&gt; 명령 이 실행되고 성공하면 현재 작업중인 디렉토리를 방금 작성한 디렉토리로 변경하십시오.</target>
        </trans-unit>
        <trans-unit id="f891073aa4578597be2a0dcd4d98d094f936e0cd" translate="yes" xml:space="preserve">
          <source>To accept the autosuggestion (replacing the command line contents), press right arrow or &lt;em&gt;Control&lt;/em&gt;-&lt;b&gt;F&lt;/b&gt;. To accept the first suggested word, press &lt;em&gt;Alt&lt;/em&gt;-&lt;b&gt;&amp;rarr;&lt;/b&gt; or &lt;em&gt;Alt&lt;/em&gt;-&lt;b&gt;F&lt;/b&gt;. If the autosuggestion is not what you want, just ignore it: it won't execute unless you accept it.</source>
          <target state="translated">자동 제안을 수락하려면 (명령 줄 내용 바꾸기) 오른쪽 화살표 또는 &lt;em&gt;Control&lt;/em&gt; - &lt;b&gt;F를&lt;/b&gt; 누르십시오 . 첫 번째 추천 단어를 눌러 수락하려면 &lt;em&gt;Alt 키&lt;/em&gt; - &lt;b&gt;&amp;rarr;&lt;/b&gt; 또는 &lt;em&gt;Alt 키&lt;/em&gt; - &lt;b&gt;F를&lt;/b&gt; . 자동 제안이 원하는 것이 아니라면 무시하십시오. 수락하지 않으면 실행되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="18bff7130ea79ac3d65a254db2e29fd6582707f0" translate="yes" xml:space="preserve">
          <source>To accept the autosuggestion, hit &lt;b&gt;&amp;rarr;&lt;/b&gt; or &lt;em&gt;Control&lt;/em&gt;-&lt;b&gt;F&lt;/b&gt;. To accept a single word of the autosuggestion, &lt;em&gt;Alt&lt;/em&gt;-&lt;b&gt;&amp;rarr;&lt;/b&gt; (right arrow). If the autosuggestion is not what you want, just ignore it.</source>
          <target state="translated">자동 제안을 수락하려면 &lt;b&gt;&amp;rarr;&lt;/b&gt; 또는 &lt;em&gt;Control&lt;/em&gt; - &lt;b&gt;F를&lt;/b&gt; 누르십시오 . 자기 암시의 단어 수락하려면 &lt;em&gt;Alt 키를&lt;/em&gt; - &lt;b&gt;&amp;rarr;&lt;/b&gt; (오른쪽 화살표). 자동 제안이 원하는 것이 아니라면 무시하십시오.</target>
        </trans-unit>
        <trans-unit id="dd013ce2337c6820983e0fd191e213738ceadda7" translate="yes" xml:space="preserve">
          <source>To append standard error to a file, write &lt;code&gt;2&amp;gt;&amp;gt;DESTINATION_FILE&lt;/code&gt;</source>
          <target state="translated">파일에 표준 오류를 추가하려면 &lt;code&gt;2&amp;gt;&amp;gt;DESTINATION_FILE&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="0108b6b821f16c26049be48e0e57d43670272afc" translate="yes" xml:space="preserve">
          <source>To append standard output to a file, write &lt;code&gt;&amp;gt;&amp;gt;DESTINATION_FILE&lt;/code&gt;</source>
          <target state="translated">파일에 표준 출력을 추가하려면 &lt;code&gt;&amp;gt;&amp;gt;DESTINATION_FILE&lt;/code&gt; 을 작성하십시오.</target>
        </trans-unit>
        <trans-unit id="9943d195413e31ff48e223d431261ac3888d43ba" translate="yes" xml:space="preserve">
          <source>To append the output of FD N to a file, write &lt;code&gt;N&amp;gt;&amp;gt;DESTINATION_FILE&lt;/code&gt;</source>
          <target state="translated">FD N의 출력을 파일에 추가하려면 &lt;code&gt;N&amp;gt;&amp;gt;DESTINATION_FILE&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="193736dda0ff3338bfe47b251780f85b63fdea40" translate="yes" xml:space="preserve">
          <source>To avoid this problem, consider changing the setting which fish inherits. If this is not possible, add a statement to your &lt;a href=&quot;index#&quot;&gt;user initialization file&lt;/a&gt; (usually &lt;code&gt;~/.config/fish/config.fish&lt;/code&gt;):</source>
          <target state="translated">이 문제를 피하려면 물고기가 상속하는 설정을 변경하십시오. 이것이 가능하지 않으면, &lt;a href=&quot;index#&quot;&gt;사용자 초기화 파일&lt;/a&gt; (보통 &lt;code&gt;~/.config/fish/config.fish&lt;/code&gt; )에 명령문을 추가하십시오 .</target>
        </trans-unit>
        <trans-unit id="49e4d836110da227491a5f8bda022aa8c6061ef3" translate="yes" xml:space="preserve">
          <source>To change the number of characters per path component, set $fish_prompt_pwd_dir_length to the number of characters. Setting it to 0 or an invalid value will disable shortening entirely.</source>
          <target state="translated">경로 구성 요소 당 문자 수를 변경하려면 $ fish_prompt_pwd_dir_length를 문자 수로 설정하십시오. 이 값을 0 또는 유효하지 않은 값으로 설정하면 단축이 완전히 비활성화됩니다.</target>
        </trans-unit>
        <trans-unit id="7c3563dd46a7946806ee797b7c244ebcbcfd652c" translate="yes" xml:space="preserve">
          <source>To compare strings or numbers or check file properties (whether a file exists or is writeable and such), use &lt;a href=&quot;commands#test&quot;&gt;test&lt;/a&gt;, like</source>
          <target state="translated">문자열이나 숫자를 비교하거나 파일 속성을 확인하려면 (파일이 있는지 또는 쓰기 가능한지 등) &lt;a href=&quot;commands#test&quot;&gt;test&lt;/a&gt; 와 같이</target>
        </trans-unit>
        <trans-unit id="6a7f4987047f57b402d8e5f6d3639b704d77e210" translate="yes" xml:space="preserve">
          <source>To create a variable &lt;code&gt;smurf&lt;/code&gt;, containing the items &lt;code&gt;blue&lt;/code&gt; and &lt;code&gt;small&lt;/code&gt;, simply write:</source>
          <target state="translated">&lt;code&gt;blue&lt;/code&gt; 및 &lt;code&gt;small&lt;/code&gt; 항목을 포함 하는 변수 &lt;code&gt;smurf&lt;/code&gt; 를 만들려면 간단히 다음과 같이 작성하십시오.</target>
        </trans-unit>
        <trans-unit id="98a0be80bb6315e5a311feb69467eb89c6ebbff0" translate="yes" xml:space="preserve">
          <source>To customize the syntax highlighting, you can set the environment variables listed in the &lt;a href=&quot;index#variables-color&quot;&gt;Variables for changing highlighting colors&lt;/a&gt; section.</source>
          <target state="translated">구문 강조를 사용자 정의하려면 &lt;a href=&quot;index#variables-color&quot;&gt;강조 색상 변경을위한 변수&lt;/a&gt; 섹션에 나열된 환경 변수를 설정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="27cc6de064f425d626ab9949da6c184849b875b2" translate="yes" xml:space="preserve">
          <source>To easily create a function of this form, you can use the &lt;a href=&quot;commands#alias&quot;&gt;alias&lt;/a&gt; command.</source>
          <target state="translated">이 양식의 함수를 쉽게 만들려면 &lt;a href=&quot;commands#alias&quot;&gt;alias&lt;/a&gt; 명령을 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="86c65bf9fb8994e55d7d62a0a0233657bfd07c71" translate="yes" xml:space="preserve">
          <source>To get a listing of all currently started jobs, use the &lt;a href=&quot;commands#jobs&quot;&gt;&lt;code&gt;jobs&lt;/code&gt;&lt;/a&gt; command.</source>
          <target state="translated">현재 시작된 모든 작업의 ​​목록을 얻으려면 &lt;a href=&quot;commands#jobs&quot;&gt; &lt;code&gt;jobs&lt;/code&gt; &lt;/a&gt; 명령을 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="dfb97c4eee9e02bf1114c1290403e1dda007a114" translate="yes" xml:space="preserve">
          <source>To implement an alias, use the &lt;code&gt;-w&lt;/code&gt; or &lt;code&gt;--wraps&lt;/code&gt; option:</source>
          <target state="translated">별명을 구현하려면 &lt;code&gt;-w&lt;/code&gt; 또는 &lt;code&gt;--wraps&lt;/code&gt; 옵션을 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="2897daf35873ca16d00ef5a1dac5a630b8c3c2e1" translate="yes" xml:space="preserve">
          <source>To make errors highlighted and red, use:</source>
          <target state="translated">오류를 강조 표시하고 빨간색으로 표시하려면 다음을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="d3fa292c2ab02a989c54851cc682dc196a6ed257" translate="yes" xml:space="preserve">
          <source>To not overwrite (&quot;clobber&quot;) an existing file, write '&amp;gt;?DESTINATION' or '2&amp;gt;?DESTINATION'</source>
          <target state="translated">기존 파일을 덮어 쓰지 않으려면 ( &quot;clobber&quot;) '&amp;gt;? DESTINATION'또는 '2&amp;gt;? DESTINATION'을 작성하십시오.</target>
        </trans-unit>
        <trans-unit id="9ec5501ff931d8cf824481581d142283552d1be7" translate="yes" xml:space="preserve">
          <source>To prepend /usr/local/bin and /usr/sbin to &lt;code&gt;$PATH&lt;/code&gt;, you can write:</source>
          <target state="translated">/ usr / local / bin 및 / usr / sbin을 &lt;code&gt;$PATH&lt;/code&gt; 앞에 추가하려면 다음과 같이 쓸 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e4beb8ce6e29ccb991aceef2a82e88203ebcf1e6" translate="yes" xml:space="preserve">
          <source>To provide a list of possible completions for myprog, use the &lt;code&gt;-a&lt;/code&gt; switch. If &lt;code&gt;myprog&lt;/code&gt; accepts the arguments start and stop, this can be specified as &amp;lsquo;complete -c myprog -a 'start stop&amp;rsquo;&lt;code&gt;. The argument to the&lt;/code&gt;-a` switch is always a single string. At completion time, it will be tokenized on spaces and tabs, and variable expansion, command substitution and other forms of parameter expansion will take place.</source>
          <target state="translated">myprog에 대한 가능한 완료 목록을 제공하려면 &lt;code&gt;-a&lt;/code&gt; 스위치를 사용하십시오 . 경우 &lt;code&gt;myprog&lt;/code&gt; 인수가 시작 및 정지 수용, 이것은 'STOP 시작'-a MYPROG -c 완료 '로 지정할 수 있습니다 &lt;code&gt;. The argument to the&lt;/code&gt; -a` 스위치에 대한 인수 는 항상 단일 문자열입니다. 완료시 공간 및 탭에서 토큰 화되며 변수 확장, 명령 대체 및 기타 형식의 매개 변수 확장이 수행됩니다.</target>
        </trans-unit>
        <trans-unit id="e25d06bf926dcd36845db13c547e9060f688cf44" translate="yes" xml:space="preserve">
          <source>To read standard input from a file, write &lt;code&gt;&amp;lt;SOURCE_FILE&lt;/code&gt;</source>
          <target state="translated">파일에서 표준 입력을 읽으려면 &lt;code&gt;&amp;lt;SOURCE_FILE&lt;/code&gt; 을 작성하십시오.</target>
        </trans-unit>
        <trans-unit id="efd4ccfede11d358f3540d606a3599db34a9bcee" translate="yes" xml:space="preserve">
          <source>To redirect both standard output and standard error to the file 'all_output.txt', you can write &lt;code&gt;echo Hello &amp;gt; all_output.txt 2&amp;gt;&amp;amp;1&lt;/code&gt;.</source>
          <target state="translated">표준 출력과 표준 오류를 모두 'all_output.txt'파일로 리디렉션하려면 &lt;code&gt;echo Hello &amp;gt; all_output.txt 2&amp;gt;&amp;amp;1&lt;/code&gt; 쓸 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="2f9c19f996d0330cf3e69a9443cdf693a9354414" translate="yes" xml:space="preserve">
          <source>To redirect input of FD N, write &lt;code&gt;N&amp;lt;DESTINATION&lt;/code&gt;</source>
          <target state="translated">FD N의 입력을 리디렉션하려면 &lt;code&gt;N&amp;lt;DESTINATION&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="1bceaef825c7c9262bebcb64ef18bc758682a29d" translate="yes" xml:space="preserve">
          <source>To redirect output of FD N, write &lt;code&gt;N&amp;gt;DESTINATION&lt;/code&gt;</source>
          <target state="translated">FD N의 출력을 리디렉션하려면 &lt;code&gt;N&amp;gt;DESTINATION&lt;/code&gt; 을 작성하십시오.</target>
        </trans-unit>
        <trans-unit id="752b3b48d45276169440be6784b7f3a0d12fbd09" translate="yes" xml:space="preserve">
          <source>To remove /usr/local/bin from &lt;code&gt;$PATH&lt;/code&gt;, you can write:</source>
          <target state="translated">&lt;code&gt;$PATH&lt;/code&gt; 에서 / usr / local / bin을 제거하려면 다음 과 같이 작성하십시오.</target>
        </trans-unit>
        <trans-unit id="b2510f1ad4da5cd52177add85db1eee2d566d8fe" translate="yes" xml:space="preserve">
          <source>To save custom keybindings, put the &lt;code&gt;bind&lt;/code&gt; statements into &lt;a href=&quot;index#initialization&quot;&gt;config.fish&lt;/a&gt;. Alternatively, fish also automatically executes a function called &lt;code&gt;fish_user_key_bindings&lt;/code&gt; if it exists.</source>
          <target state="translated">사용자 정의 키 바인딩을 저장하려면 &lt;code&gt;bind&lt;/code&gt; 명령문을 &lt;a href=&quot;index#initialization&quot;&gt;config.fish에&lt;/a&gt; 넣으십시오 . 또는 fish는 &lt;code&gt;fish_user_key_bindings&lt;/code&gt; 라는 기능이 있으면 자동으로 실행 합니다.</target>
        </trans-unit>
        <trans-unit id="61901ecaf8e208e6ef9d0647eaddf669c1ca4bd8" translate="yes" xml:space="preserve">
          <source>To search for previous entries containing the word 'make', type &lt;code&gt;make&lt;/code&gt; in the console and press the up key.</source>
          <target state="translated">단어 'make'가 포함 된 이전 항목을 검색하려면 콘솔에 &lt;code&gt;make&lt;/code&gt; 를 입력 하고 위로 키를 누르십시오.</target>
        </trans-unit>
        <trans-unit id="4b5da07cf8e10869da36d0830cda73f0b82b9df0" translate="yes" xml:space="preserve">
          <source>To see universal variables in action, start two fish sessions side by side, and issue the following command in one of them &lt;code&gt;set fish_color_cwd blue&lt;/code&gt;. Since &lt;code&gt;fish_color_cwd&lt;/code&gt; is a universal variable, the color of the current working directory listing in the prompt will instantly change to blue on both terminals.</source>
          <target state="translated">범용 변수가 실제로 작동 &lt;code&gt;set fish_color_cwd blue&lt;/code&gt; 확인하려면 두 개의 물고기 세션을 나란히 시작하고 그 중 하나에서 fish_color_cwd blue를 설정 하여 다음 명령을 실행하십시오 . 이후 &lt;code&gt;fish_color_cwd&lt;/code&gt; 는 보편적 변수 프롬프트 의지에 목록 현재 작업 디렉토리의 색상 즉시 두 터미널에 파란색으로 변경합니다.</target>
        </trans-unit>
        <trans-unit id="b44733fd0f7a6b3cff6f09a867502f4ea60ec37a" translate="yes" xml:space="preserve">
          <source>To separate a variable name from text encase the variable within double-quotes or braces.</source>
          <target state="translated">변수 이름을 텍스트와 구분하려면 변수를 큰 따옴표 또는 중괄호 안에 넣으십시오.</target>
        </trans-unit>
        <trans-unit id="7e8052447e58d55b5e4f105d0ffa9d20ca69cabc" translate="yes" xml:space="preserve">
          <source>To set a variable value, use the &lt;a href=&quot;commands#set&quot;&gt;&lt;code&gt;set&lt;/code&gt; command&lt;/a&gt;. A variable name can not be empty and can contain only letters, digits, and underscores. It may begin and end with any of those characters.</source>
          <target state="translated">변수 값을 설정하려면 사용 &lt;a href=&quot;commands#set&quot;&gt; &lt;code&gt;set&lt;/code&gt; 명령을&lt;/a&gt; . 변수 이름은 비워 둘 수 없으며 문자, 숫자 및 밑줄 만 포함 할 수 있습니다. 해당 문자로 시작하고 끝날 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="698d5831491bbb9701f405a1762b10b1e4e34b8d" translate="yes" xml:space="preserve">
          <source>To set the variable &lt;code&gt;smurf_color&lt;/code&gt; to the value &lt;code&gt;blue&lt;/code&gt;, use the command &lt;code&gt;set smurf_color blue&lt;/code&gt;.</source>
          <target state="translated">변수 &lt;code&gt;smurf_color&lt;/code&gt; 를 &lt;code&gt;blue&lt;/code&gt; 값으로 설정하려면 set &lt;code&gt;set smurf_color blue&lt;/code&gt; 명령을 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="bed9902ef9dec5f2285d68ae61ceccf41fb50e0a" translate="yes" xml:space="preserve">
          <source>To show the last command in the title:</source>
          <target state="translated">제목에 마지막 명령을 표시하려면</target>
        </trans-unit>
        <trans-unit id="10b0cfc6463833f72da638ff9b75529f78df15de" translate="yes" xml:space="preserve">
          <source>To specify a signal handler for the WINCH signal, write:</source>
          <target state="translated">WINCH 신호에 대한 신호 처리기를 지정하려면 다음과 같이 작성하십시오.</target>
        </trans-unit>
        <trans-unit id="5271e92937f5c39aabd3c25c1ed834a98af6473a" translate="yes" xml:space="preserve">
          <source>To start a debug session simply run the builtin command &lt;code&gt;breakpoint&lt;/code&gt; at the point in a function or script where you wish to gain control. Also, the default action of the TRAP signal is to call this builtin. So a running script can be debugged by sending it the TRAP signal with the &lt;code&gt;kill&lt;/code&gt; command. Once in the debugger, it is easy to insert new breakpoints by using the funced function to edit the definition of a function.</source>
          <target state="translated">디버그 세션을 시작하려면 제어하려는 함수 또는 스크립트의 지점에서 내장 명령 &lt;code&gt;breakpoint&lt;/code&gt; 을 실행하십시오 . 또한 TRAP 신호의 기본 동작은이 내장을 호출하는 것입니다. 따라서 &lt;code&gt;kill&lt;/code&gt; 명령으로 TRAP 신호를 보내 실행중인 스크립트를 디버깅 할 수 있습니다 . 디버거에 들어가면 funced 함수를 사용하여 함수 정의를 편집하여 새로운 중단 점을 쉽게 삽입 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1ca038b49940b6708e8ae180bb586be833d5a8f7" translate="yes" xml:space="preserve">
          <source>To use a &quot;,&quot; as an element, &lt;a href=&quot;#quotes&quot;&gt;quote&lt;/a&gt; or &lt;a href=&quot;#escapes&quot;&gt;escape&lt;/a&gt; it.</source>
          <target state="translated">&quot;,&quot;를 요소로 사용하려면 &lt;a href=&quot;#quotes&quot;&gt;인용&lt;/a&gt; 하거나 &lt;a href=&quot;#escapes&quot;&gt;이스케이프 처리&lt;/a&gt; 하십시오.</target>
        </trans-unit>
        <trans-unit id="4d1e2f58f1d1e885a6a557bd9d4d5d08b6944f6a" translate="yes" xml:space="preserve">
          <source>To use the value of the variable &lt;code&gt;smurf_color&lt;/code&gt;, write &lt;code&gt;$&lt;/code&gt; (dollar symbol) followed by the name of the variable, like &lt;code&gt;echo Smurfs are usually $smurf_color&lt;/code&gt;, which would print the result 'Smurfs are usually blue'.</source>
          <target state="translated">변수의 값 사용하려면 &lt;code&gt;smurf_color&lt;/code&gt; 를 , 쓰기 &lt;code&gt;$&lt;/code&gt; 같은 변수의 이름 다음에 (달러 기호) &lt;code&gt;echo Smurfs are usually $smurf_color&lt;/code&gt; 결과를 인쇄 할 것이다, '스머프는 일반적으로 파란색'.</target>
        </trans-unit>
        <trans-unit id="68bccd38cdde729f08d1dabeb1a907eb895c4a23" translate="yes" xml:space="preserve">
          <source>To write standard error to a file, write &lt;code&gt;2&amp;gt;DESTINATION&lt;/code&gt;</source>
          <target state="translated">파일에 표준 오류를 쓰려면 &lt;code&gt;2&amp;gt;DESTINATION&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="659acd568f9529fe70705f8989914717371b557a" translate="yes" xml:space="preserve">
          <source>To write standard output to a file, write &lt;code&gt;&amp;gt;DESTINATION&lt;/code&gt;</source>
          <target state="translated">표준 출력을 파일에 쓰려면 &lt;code&gt;&amp;gt;DESTINATION&lt;/code&gt; 을 작성하십시오.</target>
        </trans-unit>
        <trans-unit id="73b0536304b40903244a528081e1fdc688374119" translate="yes" xml:space="preserve">
          <source>To write them on the same line, use the semicolon (&quot;;&quot;). That means the following two examples are equivalent:</source>
          <target state="translated">같은 줄에 쓰려면 세미콜론 ( &quot;;&quot;)을 사용하십시오. 이는 다음 두 가지 예가 동일하다는 것을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="8a17b293eb79b591812fbe348e1ab2d33402a845" translate="yes" xml:space="preserve">
          <source>Try hitting tab and see what &lt;code&gt;fish&lt;/code&gt; can do!</source>
          <target state="translated">탭을 치고 &lt;code&gt;fish&lt;/code&gt; 가 무엇을 할 수 있는지보십시오 !</target>
        </trans-unit>
        <trans-unit id="fb05e0051333734c4ad4030d178c0e59ac5682e1" translate="yes" xml:space="preserve">
          <source>Turns on Vi key bindings and rebinds &lt;em&gt;Control&lt;/em&gt;-&lt;b&gt;C&lt;/b&gt; to clear the input line.</source>
          <target state="translated">Vi 키 바인딩을 켜고 &lt;em&gt;Control&lt;/em&gt; - &lt;b&gt;C&lt;/b&gt; 를 리 바인드 하여 입력 라인을 지 웁니다.</target>
        </trans-unit>
        <trans-unit id="2701a94c0eb55cbd958a87dff3e959673ff1bf53" translate="yes" xml:space="preserve">
          <source>Tutorial</source>
          <target state="translated">Tutorial</target>
        </trans-unit>
        <trans-unit id="cddfd60fdd3770f95874832546e909dcebf4b486" translate="yes" xml:space="preserve">
          <source>Type some part of the command, and then hit the &lt;b&gt;&amp;uarr;&lt;/b&gt; or &lt;b&gt;&amp;darr;&lt;/b&gt; arrow keys to navigate through history matches.</source>
          <target state="translated">명령의 일부를 입력 한 다음 &lt;b&gt;&amp;uarr;&lt;/b&gt; 또는 &lt;b&gt;&amp;darr;&lt;/b&gt; 화살표 키를 눌러 기록 일치를 탐색하십시오.</target>
        </trans-unit>
        <trans-unit id="d5c2f3a388810326308a4cf0f9d12d94e467f941" translate="yes" xml:space="preserve">
          <source>Undefined and empty variables expand to nothing.</source>
          <target state="translated">정의되지 않은 빈 변수는 확장되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="7f54feaec318be95b0574260bf420fada9f4de3f" translate="yes" xml:space="preserve">
          <source>Unfortunately, there is no way to make the changes take effect at once. You will need to log out and back in again.</source>
          <target state="translated">불행히도 변경 사항을 한 번에 적용 할 방법이 없습니다. 로그 아웃했다가 다시 로그인해야합니다.</target>
        </trans-unit>
        <trans-unit id="145a9952034e76af8265b97c5e75a18c616e70d3" translate="yes" xml:space="preserve">
          <source>Unicode private-use characters reserved by fish</source>
          <target state="translated">물고기가 예약 한 유니 코드 개인용 문자</target>
        </trans-unit>
        <trans-unit id="e1607dfd6b696cdd21b339099c2b8ec1f42324b3" translate="yes" xml:space="preserve">
          <source>Uninstalling fish</source>
          <target state="translated">물고기 제거</target>
        </trans-unit>
        <trans-unit id="b034e228b90d3e971c38c185d9c173b9fad3cb92" translate="yes" xml:space="preserve">
          <source>Universal Variables</source>
          <target state="translated">범용 변수</target>
        </trans-unit>
        <trans-unit id="0ad651b3b2a50ae7d1ebd0a6ea4647b1fc3c39a6" translate="yes" xml:space="preserve">
          <source>Universal variables are variables that are shared between all the users' fish sessions on the computer. Fish stores many of its configuration options as universal variables. This means that in order to change fish settings, all you have to do is change the variable value once, and it will be automatically updated for all sessions, and preserved across computer reboots and login/logout.</source>
          <target state="translated">범용 변수는 컴퓨터의 모든 사용자 물고기 세션간에 공유되는 변수입니다. Fish는 많은 구성 옵션을 범용 변수로 저장합니다. 즉, 물고기 설정을 변경하려면 변수 값을 한 번만 변경하면 모든 세션에 대해 자동으로 업데이트되며 컴퓨터 재부팅 및 로그인 / 로그 아웃시에도 유지됩니다.</target>
        </trans-unit>
        <trans-unit id="44adc92f43c50d7e6bc38161bddc8ab76986e3b8" translate="yes" xml:space="preserve">
          <source>Unlike &lt;code&gt;echo&lt;/code&gt;, &lt;code&gt;printf&lt;/code&gt; does not append a new line unless it is specified as part of the string.</source>
          <target state="translated">달리 &lt;code&gt;echo&lt;/code&gt; , &lt;code&gt;printf&lt;/code&gt; 와는 이 문자열의 일부로 지정되지 않는 한 새로운 라인을 추가하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="80688e6bfe64112d0b40126d6899beb59a720d8b" translate="yes" xml:space="preserve">
          <source>Unlike all other expanions, variable expansion also happens in double quoted strings. Inside double quotes (&lt;code&gt;&quot;these&quot;&lt;/code&gt;), variables will always expand to exactly one argument. If they are empty or undefined, it will result in an empty string. If they have one element, they'll expand to that element. If they have more than that, the elements will be joined with spaces.</source>
          <target state="translated">다른 모든 확장과 달리 변수 확장은 큰 따옴표로 묶인 문자열에서도 발생합니다. 큰 따옴표 ( &lt;code&gt;&quot;these&quot;&lt;/code&gt; ) 내에서 변수는 항상 정확히 하나의 인수로 확장됩니다. 비어 있거나 정의되지 않은 경우 빈 문자열이됩니다. 하나의 요소가 있으면 해당 요소로 확장됩니다. 그것들이 그보다 많으면 요소는 공백으로 결합됩니다.</target>
        </trans-unit>
        <trans-unit id="ae2292eead056d06d02e28adb305ab1fa7a4ec35" translate="yes" xml:space="preserve">
          <source>Unlike other shells, &lt;code&gt;fish&lt;/code&gt; does not have aliases or special prompt syntax. Functions take their place.</source>
          <target state="translated">다른 껍질과 달리 &lt;code&gt;fish&lt;/code&gt; 에는 별칭이나 특수 프롬프트 구문이 없습니다. 기능이 대신합니다.</target>
        </trans-unit>
        <trans-unit id="081f5baca42ff8efaa02caf11115f980ca88911b" translate="yes" xml:space="preserve">
          <source>Unlike other shells, &lt;code&gt;fish&lt;/code&gt; does not have an export command. Instead, a variable is exported via an option to &lt;code&gt;set&lt;/code&gt;, either &lt;code&gt;--export&lt;/code&gt; or just &lt;code&gt;-x&lt;/code&gt;.</source>
          <target state="translated">다른 껍질과 달리 &lt;code&gt;fish&lt;/code&gt; 에는 내보내기 명령이 없습니다. 대신 변수 를 &lt;code&gt;--export&lt;/code&gt; 또는 just &lt;code&gt;-x&lt;/code&gt; &lt;code&gt;set&lt;/code&gt; 옵션을 통해 내 보냅니다 .</target>
        </trans-unit>
        <trans-unit id="eee0d0201f0eeaf8c0900eea9c927bb9f91321d9" translate="yes" xml:space="preserve">
          <source>Unlike other shells, &lt;code&gt;fish&lt;/code&gt; has no dedicated syntax for setting variables. Instead it has an ordinary command: &lt;code&gt;set&lt;/code&gt;, which takes a variable name, and then its value.</source>
          <target state="translated">다른 껍질과 달리 &lt;code&gt;fish&lt;/code&gt; 에는 변수 설정을위한 전용 구문이 없습니다. 대신 일반적인 명령 : &lt;code&gt;set&lt;/code&gt; 이 있으며 변수 이름과 값을 갖습니다.</target>
        </trans-unit>
        <trans-unit id="a37e511dd2f26fdeffb3863f66e1a1c929cfac6a" translate="yes" xml:space="preserve">
          <source>Unlike other shells, &lt;code&gt;fish&lt;/code&gt; stores the exit status of the last command in &lt;code&gt;$status&lt;/code&gt; instead of &lt;code&gt;$?&lt;/code&gt;.</source>
          <target state="translated">다른 쉘과 달리, &lt;code&gt;fish&lt;/code&gt; 는 마지막 명령의 종료 상태 를 &lt;code&gt;$?&lt;/code&gt; 대신 &lt;code&gt;$status&lt;/code&gt; 저장 합니까? .</target>
        </trans-unit>
        <trans-unit id="3af21d9e6a82afb93e7644e0365cdc2669f846f5" translate="yes" xml:space="preserve">
          <source>Unlike other shells, fish does not split command substitutions on any whitespace (like spaces or tabs), only newlines. This can be an issue with commands like &lt;code&gt;pkg-config&lt;/code&gt; that print what is meant to be multiple arguments on a single line. To split it on spaces too, use &lt;code&gt;string split&lt;/code&gt;.</source>
          <target state="translated">다른 쉘과 달리 물고기는 공백이나 탭과 같은 공백에서 명령 대체를 나누지 않고 줄 바꿈 만합니다. &lt;code&gt;pkg-config&lt;/code&gt; 와 같은 명령 에서 한 줄에 여러 개의 인수가있는 것을 인쇄 하는 문제 일 수 있습니다 . 공백으로 나누려면 &lt;code&gt;string split&lt;/code&gt; 을 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="51633ed047475ca6ce896f07a0b3e652915476f4" translate="yes" xml:space="preserve">
          <source>Unlike other shells, fish splits command substitutions only on newlines, not spaces or tabs or the characters in $IFS.</source>
          <target state="translated">다른 쉘과 달리 fish는 공백이나 탭 또는 $ IFS의 문자가 아닌 개행에서만 명령 대체를 분할합니다.</target>
        </trans-unit>
        <trans-unit id="2e36f8ffbac36ebebd737db0d45fea3f73bea9ee" translate="yes" xml:space="preserve">
          <source>Unlike other shells, there is no prompt variable like PS1. To display your prompt, &lt;code&gt;fish&lt;/code&gt; executes a function with the name &lt;code&gt;fish_prompt&lt;/code&gt;, and its output is used as the prompt.</source>
          <target state="translated">다른 쉘과 달리 PS1과 같은 프롬프트 변수는 없습니다. 프롬프트를 표시하기 위해 &lt;code&gt;fish&lt;/code&gt; 는 이름이 &lt;code&gt;fish_prompt&lt;/code&gt; 인 함수를 실행 하고 출력이 프롬프트로 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="dd1f16e81556a309c131d3f6b2ba87b84eb31d62" translate="yes" xml:space="preserve">
          <source>Unlike other shells, variables are not further split after substitution:</source>
          <target state="translated">다른 쉘과 달리 변수는 대체 후에 더 이상 분할되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="0bb18642b70b9f8a9c12ccf39487328f306b8e19" translate="yes" xml:space="preserve">
          <source>Usage</source>
          <target state="translated">Usage</target>
        </trans-unit>
        <trans-unit id="4df13ec4234f96a6f1f82fccdde77669b4c4b95c" translate="yes" xml:space="preserve">
          <source>Usage Notes</source>
          <target state="translated">사용법 메모</target>
        </trans-unit>
        <trans-unit id="d74b204180b301da11db45838e08032a0d957c03" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;if&lt;/code&gt;, &lt;code&gt;else if&lt;/code&gt;, and &lt;code&gt;else&lt;/code&gt; to conditionally execute code, based on the exit status of a command.</source>
          <target state="translated">사용 &lt;code&gt;if&lt;/code&gt; , &lt;code&gt;else if&lt;/code&gt; , 그리고 &lt;code&gt;else&lt;/code&gt; 조건 명령의 종료 상태에 따라 코드를 실행합니다.</target>
        </trans-unit>
        <trans-unit id="eb181080b44029a3622b4ef5a70c42d2deefdef1" translate="yes" xml:space="preserve">
          <source>Use one of the following switches to specify which resource limit to set or report:</source>
          <target state="translated">다음 스위치 중 하나를 사용하여 설정하거나보고 할 자원 제한을 지정하십시오.</target>
        </trans-unit>
        <trans-unit id="454bd477b983f01843d0ef8db935e66528a0a530" translate="yes" xml:space="preserve">
          <source>Use the &lt;a href=&quot;commands#fish_update_completions&quot;&gt;&lt;code&gt;fish_update_completions&lt;/code&gt;&lt;/a&gt; command.</source>
          <target state="translated">&lt;a href=&quot;commands#fish_update_completions&quot;&gt; &lt;code&gt;fish_update_completions&lt;/code&gt; &lt;/a&gt; 명령을 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="173607f929222a6b2423c5f7cb2482dcefe3fd4d" translate="yes" xml:space="preserve">
          <source>Use the &lt;a href=&quot;commands#set&quot;&gt;&lt;code&gt;set&lt;/code&gt;&lt;/a&gt; command:</source>
          <target state="translated">&lt;a href=&quot;commands#set&quot;&gt; &lt;code&gt;set&lt;/code&gt; &lt;/a&gt; 명령을 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="a070d11e8f9357b2f82f012cf1cbf197f82d8186" translate="yes" xml:space="preserve">
          <source>Use the &lt;code&gt;$status&lt;/code&gt; variable. This replaces the &lt;code&gt;$?&lt;/code&gt; variable used in some other shells.</source>
          <target state="translated">&lt;code&gt;$status&lt;/code&gt; 변수를 사용하십시오 . 이것은 &lt;code&gt;$?&lt;/code&gt; 를 대체합니다 . 다른 쉘에서 사용되는 변수.</target>
        </trans-unit>
        <trans-unit id="31c238ddde1e3a389d384b0e3b72354aef7e4403" translate="yes" xml:space="preserve">
          <source>Use the &lt;code&gt;env&lt;/code&gt; command.</source>
          <target state="translated">&lt;code&gt;env&lt;/code&gt; 명령을 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="0411e393ae78c9f8172fc0b2dbacdfcc91e4286c" translate="yes" xml:space="preserve">
          <source>Use the web configuration tool, &lt;a href=&quot;commands#fish_config&quot;&gt;&lt;code&gt;fish_config&lt;/code&gt;&lt;/a&gt;, or alter the &lt;a href=&quot;index#variables-color&quot;&gt;&lt;code&gt;fish_color&lt;/code&gt; family of environment variables&lt;/a&gt;.</source>
          <target state="translated">웹 구성 도구 인 &lt;a href=&quot;commands#fish_config&quot;&gt; &lt;code&gt;fish_config&lt;/code&gt; &lt;/a&gt; 를 사용하거나 &lt;a href=&quot;index#variables-color&quot;&gt; &lt;code&gt;fish_color&lt;/code&gt; 환경 변수 제품군을&lt;/a&gt; 변경하십시오 .</target>
        </trans-unit>
        <trans-unit id="60f35ccc6241ede38ff1ff41aa11e4d625890b21" translate="yes" xml:space="preserve">
          <source>Use them without a leading &lt;code&gt;$&lt;/code&gt; - &lt;code&gt;pi - 3&lt;/code&gt; should be about 0.</source>
          <target state="translated">선도적없이 사용 &lt;code&gt;$&lt;/code&gt; - &lt;code&gt;pi - 3&lt;/code&gt; 0에 대해해야합니다.</target>
        </trans-unit>
        <trans-unit id="0cae9ed3f91cf8ab384b29a4865d0861615ac352" translate="yes" xml:space="preserve">
          <source>Useful functions for writing completions</source>
          <target state="translated">작성 완료를위한 유용한 기능</target>
        </trans-unit>
        <trans-unit id="da533743f0159eea920a315a90c8751cf23609aa" translate="yes" xml:space="preserve">
          <source>User initialization, usually in &lt;code&gt;~/.config/fish/config.fish&lt;/code&gt; (controlled by the &lt;code&gt;XDG_CONFIG_HOME&lt;/code&gt; environment variable, and accessible as &lt;code&gt;$__fish_config_dir&lt;/code&gt;).</source>
          <target state="translated">&lt;code&gt;~/.config/fish/config.fish&lt;/code&gt; 에서 사용자 초기화 ( &lt;code&gt;XDG_CONFIG_HOME&lt;/code&gt; 환경 변수로 제어되며 &lt;code&gt;$__fish_config_dir&lt;/code&gt; 로 액세스 가능 )</target>
        </trans-unit>
        <trans-unit id="7ab03bad0e4c29694da24c66d0dfd6218d876cd9" translate="yes" xml:space="preserve">
          <source>Using another read history file</source>
          <target state="translated">다른 읽기 이력 파일 사용</target>
        </trans-unit>
        <trans-unit id="b73b7dbea87b71c6a8e64d7b592b0efded7f191c" translate="yes" xml:space="preserve">
          <source>Using the &lt;em&gt;normal&lt;/em&gt; keyword will reset both background and foreground colors to whatever is the default for the terminal.</source>
          <target state="translated">&lt;em&gt;normal&lt;/em&gt; 키워드를 사용하면 배경색과 전경색이 모두 터미널 기본값으로 재설정됩니다.</target>
        </trans-unit>
        <trans-unit id="01391f93ace379e5306ef34014cfa60be33aafe9" translate="yes" xml:space="preserve">
          <source>Using the &lt;em&gt;normal&lt;/em&gt; keyword will reset foreground, background, and all formatting back to default.</source>
          <target state="translated">&lt;em&gt;normal&lt;/em&gt; 키워드를 사용하면 전경, 배경 및 모든 형식이 기본값으로 다시 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="f3b2ac121de4ce08e07778437bf30ed6cd6b55da" translate="yes" xml:space="preserve">
          <source>Using this command involves passing two sets of arguments separated by &lt;code&gt;--&lt;/code&gt;. The first set consists of one or more option specifications (&lt;code&gt;OPTION_SPEC&lt;/code&gt; above) and options that modify the behavior of &lt;code&gt;argparse&lt;/code&gt;. These must be listed before the &lt;code&gt;--&lt;/code&gt; argument. The second set are the arguments to be parsed in accordance with the option specifications. They occur after the &lt;code&gt;--&lt;/code&gt; argument and can be empty. More about this below but here is a simple example that might be used in a function named &lt;code&gt;my_function&lt;/code&gt;:</source>
          <target state="translated">이 명령을 사용하려면 &lt;code&gt;--&lt;/code&gt; 구분 된 두 개의 인수 집합을 전달해야합니다 . 첫 번째 세트는 하나 이상의 옵션 사양 ( 위의 &lt;code&gt;OPTION_SPEC&lt;/code&gt; )과 &lt;code&gt;argparse&lt;/code&gt; 의 동작을 수정하는 옵션으로 구성 됩니다. &lt;code&gt;--&lt;/code&gt; 인수 앞에 나열해야합니다 . 두 번째 세트는 옵션 사양에 따라 구문 분석 할 인수입니다. &lt;code&gt;--&lt;/code&gt; 인수 다음에 발생 하며 비어있을 수 있습니다. 아래에 더 자세히 설명되어 있지만 &lt;code&gt;my_function&lt;/code&gt; 이라는 함수에 사용될 수있는 간단한 예는 다음과 같습니다 .</target>
        </trans-unit>
        <trans-unit id="f09d5d78e534ac9eee0414d7d7a0fb24af84d370" translate="yes" xml:space="preserve">
          <source>Valid colors include:</source>
          <target state="translated">유효한 색상은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="95b8e49e0a4f7e7d23df31b6c1eedc2a79d60c67" translate="yes" xml:space="preserve">
          <source>Valid format specifiers are:</source>
          <target state="translated">유효한 형식 지정자는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="047ea2f72ce834a5cd86fc46331f14acbb3f9954" translate="yes" xml:space="preserve">
          <source>Variable expansion</source>
          <target state="translated">변수 확장</target>
        </trans-unit>
        <trans-unit id="e2eb91d2e9dd9d2efdc78a2c535e066657ae307e" translate="yes" xml:space="preserve">
          <source>Variable expansions</source>
          <target state="translated">변수 확장</target>
        </trans-unit>
        <trans-unit id="69cd2e4d36065246c043d32da81f65b5ec76feab" translate="yes" xml:space="preserve">
          <source>Variable scope</source>
          <target state="translated">변수 범위</target>
        </trans-unit>
        <trans-unit id="f2ffbf1cf26a2aeca0a92264405ee06ceed33e13" translate="yes" xml:space="preserve">
          <source>Variable scope for functions</source>
          <target state="translated">함수의 변수 범위</target>
        </trans-unit>
        <trans-unit id="d3800988cc67ea9f9ae70495ad31314d7a633d64" translate="yes" xml:space="preserve">
          <source>Variable substitution also occurs in double quotes, but not single quotes:</source>
          <target state="translated">변수 대체는 큰 따옴표로도 이루어 지지만 작은 따옴표는 아닙니다.</target>
        </trans-unit>
        <trans-unit id="ac018db1f7b00972061adff843d37497d8ee153c" translate="yes" xml:space="preserve">
          <source>Variables</source>
          <target state="translated">Variables</target>
        </trans-unit>
        <trans-unit id="dc55a791f0556b1e2c98faf060801c75b48b8e87" translate="yes" xml:space="preserve">
          <source>Variables can be explicitly set to be exported with the &lt;code&gt;-x&lt;/code&gt; or &lt;code&gt;--export&lt;/code&gt; switch, or not exported with the &lt;code&gt;-u&lt;/code&gt; or &lt;code&gt;--unexport&lt;/code&gt; switch. The exporting rules when creating or updating a variable are identical to the scoping rules for variables:</source>
          <target state="translated">변수는 &lt;code&gt;-x&lt;/code&gt; 또는 &lt;code&gt;--export&lt;/code&gt; 스위치를 사용하여 내보내 거나 &lt;code&gt;-u&lt;/code&gt; 또는 &lt;code&gt;--unexport&lt;/code&gt; 스위치를 사용하여 내 보내지 않도록 명시 적으로 설정할 수 있습니다 . 변수를 만들거나 업데이트 할 때 내보내기 규칙은 변수의 범위 지정 규칙과 동일합니다.</target>
        </trans-unit>
        <trans-unit id="8caf7a3931edf651d5c0eb5b032760d30623081d" translate="yes" xml:space="preserve">
          <source>Variables can be explicitly set to be universal with the &lt;code&gt;-U&lt;/code&gt; or &lt;code&gt;--universal&lt;/code&gt; switch, global with the &lt;code&gt;-g&lt;/code&gt; or &lt;code&gt;--global&lt;/code&gt; switch, or local with the &lt;code&gt;-l&lt;/code&gt; or &lt;code&gt;--local&lt;/code&gt; switch. The scoping rules when creating or updating a variable are:</source>
          <target state="translated">변수는 &lt;code&gt;-U&lt;/code&gt; 또는 &lt;code&gt;--universal&lt;/code&gt; 스위치를 사용하여 범용으로 설정 하거나 &lt;code&gt;-g&lt;/code&gt; 또는 &lt;code&gt;--global&lt;/code&gt; 스위치를 사용하여 전역 으로 설정 하거나 &lt;code&gt;-l&lt;/code&gt; 또는 &lt;code&gt;--local&lt;/code&gt; 스위치를 사용하여 로컬 로 명시 적으로 설정할 수 있습니다 . 변수를 만들거나 업데이트 할 때 범위 지정 규칙은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="866a24aa0e9eb8db8b30498e951c623e32e65a14" translate="yes" xml:space="preserve">
          <source>Variables can be marked or unmarked as PATH variables via the &lt;code&gt;--path&lt;/code&gt; and &lt;code&gt;--unpath&lt;/code&gt; options to &lt;code&gt;set&lt;/code&gt;.</source>
          <target state="translated">변수는 마크 또는 경로 비아 변수가 해제 될 수 &lt;code&gt;--path&lt;/code&gt; 및 &lt;code&gt;--unpath&lt;/code&gt; 에 옵션 &lt;code&gt;set&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="81a1e4b50937d575e7941efe7d24b3e8887251ba" translate="yes" xml:space="preserve">
          <source>Variables can be used as indices for expansion of variables, like so:</source>
          <target state="translated">변수는 다음과 같이 변수 확장을위한 지표로 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d13d8872f2b85622ec05b4faa321ef701163466e" translate="yes" xml:space="preserve">
          <source>Variables for changing highlighting colors</source>
          <target state="translated">강조 색상 변경을위한 변수</target>
        </trans-unit>
        <trans-unit id="021a38b749711c430ab7b97416e1e7f42bc63ab2" translate="yes" xml:space="preserve">
          <source>Variables in fish can be exported. This means the variable will be inherited by any commands started by fish. It is convention that exported variables are in uppercase and unexported variables are in lowercase.</source>
          <target state="translated">물고기의 변수를 내보낼 수 있습니다. 이는 변수가 물고기에 의해 시작된 모든 명령에 의해 상속됨을 의미합니다. 반출 된 변수는 대문자이고 반출되지 않은 변수는 소문자 인 것이 관례입니다.</target>
        </trans-unit>
        <trans-unit id="8b7277f6927f4830af2060ea99b89d5f43313327" translate="yes" xml:space="preserve">
          <source>Variables may be explicitly set to either exported or not exported. When an exported variable goes out of scope, it is unexported.</source>
          <target state="translated">변수는 명시 적으로 내보내거나 내 보내지 않도록 설정할 수 있습니다. 내 보낸 변수가 범위를 벗어나면 내 보내지 않습니다.</target>
        </trans-unit>
        <trans-unit id="5daf675f51e0dc0a7ce5d91db9146d3208ab170c" translate="yes" xml:space="preserve">
          <source>Variables may be explicitly set to universal, global or local. Variables with the same name in different scopes will not be changed.</source>
          <target state="translated">변수는 명시 적으로 범용, 전역 또는 로컬로 설정 될 수 있습니다. 다른 범위에서 같은 이름을 가진 변수는 변경되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="4a88384607868c891caaae0411d761359e4f6ef5" translate="yes" xml:space="preserve">
          <source>Variables whose name are in uppercase are generally exported to the commands started by fish, while those in lowercase are not exported (&lt;code&gt;CMD_DURATION&lt;/code&gt; is an exception, for historical reasons). This rule is not enforced by fish, but it is good coding practice to use casing to distinguish between exported and unexported variables. &lt;code&gt;fish&lt;/code&gt; also uses several variables internally. Such variables are prefixed with the string &lt;code&gt;__FISH&lt;/code&gt; or &lt;code&gt;__fish.&lt;/code&gt; These should never be used by the user. Changing their value may break fish.</source>
          <target state="translated">이름이 대문자 인 변수는 일반적으로 fish가 시작한 명령으로 내보내 &lt;code&gt;CMD_DURATION&lt;/code&gt; 소문자의 변수 는 내 보내지 않습니다 ( 이력 상의 이유로 CMD_DURATION 은 예외입니다). 이 규칙은 물고기에 의해 시행되지는 않지만, 케이싱을 사용하여 내 보낸 변수와 내 보내지 않은 변수를 구별하는 것이 좋습니다. &lt;code&gt;fish&lt;/code&gt; 는 내부적으로 여러 변수를 사용합니다. 이러한 변수 앞에는 &lt;code&gt;__FISH&lt;/code&gt; 또는 &lt;code&gt;__fish.&lt;/code&gt; 문자열이 붙 습니다. 이것들은 사용자가 사용해서는 안됩니다. 그들의 가치를 바꾸면 물고기가 깨질 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8de6cda0a76daf29c82a8e5cb8b2ed185cd03414" translate="yes" xml:space="preserve">
          <source>Vi mode allows for the use of Vi-like commands at the prompt. Initially, &lt;a href=&quot;#vi-mode-insert&quot;&gt;insert mode&lt;/a&gt; is active. &lt;b&gt;Escape&lt;/b&gt; enters &lt;a href=&quot;#vi-mode-command&quot;&gt;command mode&lt;/a&gt;. The commands available in command, insert and visual mode are described below. Vi mode shares &lt;a href=&quot;#shared-binds&quot;&gt;some bindings&lt;/a&gt; with &lt;a href=&quot;#emacs-mode&quot;&gt;Emacs mode&lt;/a&gt;.</source>
          <target state="translated">Vi 모드는 프롬프트에서 Vi 유사 명령을 사용할 수있게합니다. 처음에는 &lt;a href=&quot;#vi-mode-insert&quot;&gt;삽입 모드&lt;/a&gt; 가 활성화되어 있습니다. &lt;b&gt;이스케이프 &lt;/b&gt;&lt;a href=&quot;#vi-mode-command&quot;&gt;명령 모드&lt;/a&gt; 로 들어갑니다 . 명령, 삽입 및 시각적 모드에서 사용 가능한 명령이 아래에 설명되어 있습니다. Vi 모드는 &lt;a href=&quot;#emacs-mode&quot;&gt;Emacs 모드&lt;/a&gt; 와 &lt;a href=&quot;#shared-binds&quot;&gt;일부 바인딩&lt;/a&gt; 을 공유 합니다 .</target>
        </trans-unit>
        <trans-unit id="fc7edfc16e4d70682dbbf7a6226979a31fd0ad3e" translate="yes" xml:space="preserve">
          <source>Vi mode commands</source>
          <target state="translated">Vi 모드 명령</target>
        </trans-unit>
        <trans-unit id="5fb895569dd30157f331b4727bbce633510ff8ba" translate="yes" xml:space="preserve">
          <source>Visual mode</source>
          <target state="translated">시각 모드</target>
        </trans-unit>
        <trans-unit id="31e1f6a5be94b9a7630dae992d9a626fc08b6ea1" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;-a&lt;/code&gt; or &lt;code&gt;--arguments&lt;/code&gt; is specified in conjunction with long, short, or old style options, the specified arguments are only used as completions when attempting to complete an argument for any of the specified options. If &lt;code&gt;-a&lt;/code&gt; or &lt;code&gt;--arguments&lt;/code&gt; is specified without any long, short, or old style options, the specified arguments are used when completing any argument to the command (except when completing an option argument that was specified with &lt;code&gt;-r&lt;/code&gt; or &lt;code&gt;--require-parameter&lt;/code&gt;).</source>
          <target state="translated">때 &lt;code&gt;-a&lt;/code&gt; 또는 &lt;code&gt;--arguments&lt;/code&gt; 가 긴, 짧은, 또는 오래된 스타일 옵션과 함께 지정되어 지정된 옵션에 대한 인수를 완료 할 때, 지정된 인수는 완료로 사용된다. 경우 &lt;code&gt;-a&lt;/code&gt; 또는 &lt;code&gt;--arguments&lt;/code&gt; 이 지정되었습니다 옵션 인수를 완료 한 경우를 제외하고 명령 (에 대한 인수를 완료 할 때 긴, 짧은 또는 이전 스타일 옵션, 지정된 인수가 사용되는 모든없이 지정 &lt;code&gt;-r&lt;/code&gt; 또는 &lt;code&gt;--require-parameter&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="2505ca259992c20f2e115bd87371ef8405dc9f79" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;COMMAND&lt;/code&gt; is a shellscript command, it is a good practice to put the actual code into a &lt;a href=&quot;#function&quot;&gt;function&lt;/a&gt; and simply bind to the function name. This way it becomes significantly easier to test the function while editing, and the result is usually more readable as well.</source>
          <target state="translated">때 &lt;code&gt;COMMAND&lt;/code&gt; 는 쉘 스크립트 명령은, 그것은으로 실제 코드를 삽입 할 수있는 좋은 연습입니다 &lt;a href=&quot;#function&quot;&gt;기능&lt;/a&gt; 함수 이름에 간단하게 결합하고. 이런 식으로 편집하는 동안 기능을 테스트하기가 훨씬 쉬워지며 결과는 일반적으로 더 읽기 쉽습니다.</target>
        </trans-unit>
        <trans-unit id="0b61f14b6442d9d89b8d8fa699d95bbd93af2c25" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;fish&lt;/code&gt; encounters a command, it attempts to autoload a function for that command, by looking for a file with the name of that command in &lt;code&gt;~/.config/fish/functions/&lt;/code&gt;.</source>
          <target state="translated">때 &lt;code&gt;fish&lt;/code&gt; 명령을 발견, 그것은에서 해당 명령의 이름을 가진 파일을 찾아서, 그 명령에 대한 기능을 자동로드를 시도 &lt;code&gt;~/.config/fish/functions/&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="80ac01474d96293d4e91964bb2b3037356d135af" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;read&lt;/code&gt; reaches the end-of-file (EOF) instead of the terminator, the exit status is set to 1. Otherwise, it is set to 0.</source>
          <target state="translated">때 &lt;code&gt;read&lt;/code&gt; 에 도달이 파일 끝 (EOF) 대신 터미네이터, 종료 상태가 그렇지 않으면 1로 설정되고, 그것은 0으로 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="f91db4fb609ae3c10e05da51ef90890379f33f5d" translate="yes" xml:space="preserve">
          <source>When a command lookup fails</source>
          <target state="translated">명령 조회가 실패한 경우</target>
        </trans-unit>
        <trans-unit id="a64df52b82b6680cee5d07a9157923c1c477f30d" translate="yes" xml:space="preserve">
          <source>When a process or job exits</source>
          <target state="translated">프로세스 또는 작업이 종료 될 때</target>
        </trans-unit>
        <trans-unit id="1b00bfa449d40b6151effb4cc0facd22af7b0736" translate="yes" xml:space="preserve">
          <source>When a signal is delivered</source>
          <target state="translated">신호가 전달 될 때</target>
        </trans-unit>
        <trans-unit id="3f06f0c49199bffd6092463385d2eaaf34e91888" translate="yes" xml:space="preserve">
          <source>When all arguments are valid job specifiers, bg will background all matching jobs that exist.</source>
          <target state="translated">모든 인수가 유효한 작업 지정자 인 경우 bg는 존재하는 일치하는 모든 작업을 백그라운드로 지정합니다.</target>
        </trans-unit>
        <trans-unit id="24bda0993bf1f284e0377d7559e36d7befb31f8a" translate="yes" xml:space="preserve">
          <source>When an argument for a program is given on the commandline, it undergoes the process of parameter expansion before it is sent on to the command. Parameter expansion is a powerful mechanism that allows you to expand the parameter in various ways, including performing wildcard matching on files, inserting the value of a shell variable into the parameter or even using the output of another command as a parameter list.</source>
          <target state="translated">프로그램에 대한 인수가 명령 행에 제공되면 명령으로 전송되기 전에 매개 변수 확장 프로세스를 거칩니다. 매개 변수 확장은 파일에서 와일드 카드 일치 수행, 쉘 변수의 값을 매개 변수에 삽입 또는 다른 명령의 출력을 매개 변수 목록으로 사용하는 등 다양한 방법으로 매개 변수를 확장 할 수있는 강력한 메커니즘입니다.</target>
        </trans-unit>
        <trans-unit id="51d4ef16c4e522527f31c576578d19308f006fec" translate="yes" xml:space="preserve">
          <source>When an array is exported as an environment variable, it is either space or colon delimited, depending on whether it is a path variable:</source>
          <target state="translated">배열을 환경 변수로 내 보내면 경로 변수인지 여부에 따라 공백 또는 콜론으로 구분됩니다.</target>
        </trans-unit>
        <trans-unit id="083625467bc7bf4cd25dc54b2e5d0f68812dc076" translate="yes" xml:space="preserve">
          <source>When at least one of the arguments isn't a valid job specifier (i.e. PID), &lt;code&gt;bg&lt;/code&gt; will print an error without backgrounding anything.</source>
          <target state="translated">인수 중 하나 이상이 유효한 작업 지정자 (예 : PID)가 아닌 경우 &lt;code&gt;bg&lt;/code&gt; 는 배경을 지정하지 않고 오류를 인쇄합니다.</target>
        </trans-unit>
        <trans-unit id="a37e1f3259f6cdbb079115ac56119f8c19560a48" translate="yes" xml:space="preserve">
          <source>When calling a function, all current local variables temporarily disappear. This shadowing of the local scope is needed since the variable namespace would become cluttered, making it very easy to accidentally overwrite variables from another function.</source>
          <target state="translated">함수를 호출하면 모든 현재 지역 변수가 일시적으로 사라집니다. 변수 네임 스페이스가 복잡 해져서 다른 함수에서 실수로 변수를 덮어 쓰기가 쉬워 지므로 로컬 범위의 그림자가 필요합니다.</target>
        </trans-unit>
        <trans-unit id="15eb860b17777aaad36a975023e7f241c10c68cb" translate="yes" xml:space="preserve">
          <source>When combining multiple parameter expansions, expansions are performed in the following order:</source>
          <target state="translated">여러 매개 변수 확장을 결합 할 때 다음 순서로 확장이 수행됩니다.</target>
        </trans-unit>
        <trans-unit id="8f30248e782192746e24f20cbd06bf81e9f75b5d" translate="yes" xml:space="preserve">
          <source>When defining a new function in fish, it is possible to make it into an event handler, i.e. a function that is automatically run when a specific event takes place. Events that can trigger a handler currently are:</source>
          <target state="translated">피쉬에서 새로운 함수를 정의 할 때,이를 이벤트 핸들러로 만들 수 있습니다. 즉 특정 이벤트가 발생할 때 자동으로 실행되는 함수입니다. 현재 핸들러를 트리거 할 수있는 이벤트는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="c06a76c81fd354d96a91e2098cf33daa64c9b259" translate="yes" xml:space="preserve">
          <source>When erasing completions, it is possible to either erase all completions for a specific command by specifying &lt;code&gt;complete -c COMMAND -e&lt;/code&gt;, or by specifying a specific completion option to delete by specifying either a long, short or old style option.</source>
          <target state="translated">완료를 지울 때 &lt;code&gt;complete -c COMMAND -e&lt;/code&gt; 를 지정하여 특정 명령에 대한 모든 완료를 지우 거나 long, short 또는 old 스타일 옵션을 지정하여 삭제할 특정 완료 옵션을 지정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="71562657ada1f73f1b73dd5722b7668b06f50100" translate="yes" xml:space="preserve">
          <source>When fish waits for input, it will display a prompt by evaluating the &lt;code&gt;fish_prompt&lt;/code&gt; and &lt;code&gt;fish_right_prompt&lt;/code&gt; functions. The output of the former is displayed on the left and the latter's output on the right side of the terminal. The output of &lt;code&gt;fish_mode_prompt&lt;/code&gt; will be prepended on the left, though the default function only does this when in &lt;a href=&quot;index#vi-mode&quot;&gt;vi-mode&lt;/a&gt;.</source>
          <target state="translated">물고기가 입력을 &lt;code&gt;fish_prompt&lt;/code&gt; 및 &lt;code&gt;fish_right_prompt&lt;/code&gt; 기능 을 평가하여 프롬프트를 표시 합니다. 전자의 출력은 왼쪽에 표시되고 후자의 출력은 터미널의 오른쪽에 표시됩니다. &lt;code&gt;fish_mode_prompt&lt;/code&gt; 의 출력은 왼쪽에 앞에 추가되지만 기본 기능은 &lt;a href=&quot;index#vi-mode&quot;&gt;vi-mode에&lt;/a&gt; 있을 때만이 기능을 수행 합니다 .</target>
        </trans-unit>
        <trans-unit id="607879a486f64cd0da9cb1a6673f02fc3b5d2fec" translate="yes" xml:space="preserve">
          <source>When in vi-mode, the &lt;a href=&quot;fish_mode_prompt&quot;&gt;&lt;code&gt;fish_mode_prompt&lt;/code&gt;&lt;/a&gt; function will display a mode indicator to the left of the prompt. The &lt;code&gt;fish_vi_cursor&lt;/code&gt; function will be used to change the cursor's shape depending on the mode in supported terminals. To disable this feature, override it with an empty function. To display the mode elsewhere (like in your right prompt), use the output of the &lt;code&gt;fish_default_mode_prompt&lt;/code&gt; function.</source>
          <target state="translated">vi 모드 인 경우 &lt;a href=&quot;fish_mode_prompt&quot;&gt; &lt;code&gt;fish_mode_prompt&lt;/code&gt; &lt;/a&gt; 기능은 프롬프트 왼쪽에 모드 표시기를 표시합니다. &lt;code&gt;fish_vi_cursor&lt;/code&gt; 의 기능을 지원하는 단말의 모드에 따라, 커서의 형상을 변경하는 데 사용된다. 이 기능을 비활성화하려면 빈 기능으로 재정의하십시오. 오른쪽 프롬프트와 같이 다른 곳에서 모드를 표시하려면 &lt;code&gt;fish_default_mode_prompt&lt;/code&gt; 함수 의 출력을 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="33b46dcb16afbaec6d4436b9d1a5f44e784219a0" translate="yes" xml:space="preserve">
          <source>When multiple &lt;code&gt;COMMAND&lt;/code&gt;s are provided, they are all run in the specified order when the key is pressed. Note that special input functions cannot be combined with ordinary shell script commands. The commands must be entirely a sequence of special input functions (from &lt;code&gt;bind -f&lt;/code&gt;) or all shell script commands (i.e., valid fish script).</source>
          <target state="translated">여러 개의 &lt;code&gt;COMMAND&lt;/code&gt; 이 제공되면 키를 누를 때 지정된 순서대로 모두 실행됩니다. 특수 입력 기능은 일반 쉘 스크립트 명령과 결합 할 수 없습니다. 명령은 전적으로 일련의 특수 입력 함수 ( &lt;code&gt;bind -f&lt;/code&gt; ) 또는 모든 쉘 스크립트 명령 (예 : 유효한 피쉬 스크립트) 이어야합니다 .</target>
        </trans-unit>
        <trans-unit id="60402cb8f58632c68a26ced09b11fbf6589f7279" translate="yes" xml:space="preserve">
          <source>When running in this mode, &lt;code&gt;read&lt;/code&gt; does not split the input in any way and text is redirected to standard output without any further processing or manipulation.</source>
          <target state="translated">이 모드에서 실행될 때 &lt;code&gt;read&lt;/code&gt; 는 어떤 식 으로든 입력을 분할하지 않으며 텍스트는 추가 처리 나 조작없이 표준 출력으로 리디렉션됩니다.</target>
        </trans-unit>
        <trans-unit id="efd94d1e11c389f3a2b8042a383ed84dc4be3715" translate="yes" xml:space="preserve">
          <source>When the cursor is over a parenthesis or a quote, &lt;code&gt;fish&lt;/code&gt; also highlights its matching quote or parenthesis.</source>
          <target state="translated">커서가 괄호 나 따옴표 위에 있으면 &lt;code&gt;fish&lt;/code&gt; 도 일치하는 따옴표 나 괄호를 강조 표시합니다.</target>
        </trans-unit>
        <trans-unit id="01a87969e30ad0e39174183d05f883882efbc023" translate="yes" xml:space="preserve">
          <source>When the prompt is about to be shown</source>
          <target state="translated">프롬프트가 표시 될 때</target>
        </trans-unit>
        <trans-unit id="84fb666d00ac44965366d223053ffc07523cfa5c" translate="yes" xml:space="preserve">
          <source>When the value of a variable is updated</source>
          <target state="translated">변수의 값이 업데이트 될 때</target>
        </trans-unit>
        <trans-unit id="5149e58fb1af17e2b78bfc79105f3521233c2ff0" translate="yes" xml:space="preserve">
          <source>When two unquoted expansions directly follow each other, you need to watch out for expansions that expand to nothing. This includes undefined variables and empty lists, but also command substitutions with no output. See the &lt;a href=&quot;#cartesian-product&quot;&gt;cartesian product&lt;/a&gt; section for more information.</source>
          <target state="translated">인용되지 않은 두 개의 확장이 서로 직접 연결되면 확장되지 않는 확장에주의해야합니다. 여기에는 정의되지 않은 변수와 빈 목록뿐만 아니라 출력이없는 명령 대체도 포함됩니다. 자세한 내용은 &lt;a href=&quot;#cartesian-product&quot;&gt;데카르트 제품&lt;/a&gt; 섹션을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="611390b4e7bff2a4f48823eeb19ea95b7d5c6f8e" translate="yes" xml:space="preserve">
          <source>When using a variable as an argument for a test operator you should almost always enclose it in double-quotes. There are only two situations it is safe to omit the quote marks. The first is when the argument is a literal string with no whitespace or other characters special to the shell (e.g., semicolon). For example, &lt;code&gt;test -b /my/file&lt;/code&gt;. The second is using a variable that expands to exactly one element including if that element is the empty string (e.g., &amp;lsquo;set x &amp;rsquo;'&lt;code&gt;). If the variable is not set, set but with no value, or set to more than one value you must enclose it in double-quotes. For example,&lt;/code&gt;test &quot;$x&quot; = &quot;$y&quot;&lt;code&gt;. Since it is always safe to enclose variables in double-quotes when used as&lt;/code&gt;test` arguments that is the recommended practice.</source>
          <target state="translated">변수를 테스트 연산자의 인수로 사용할 때는 거의 항상 큰 따옴표로 묶어야합니다. 따옴표를 생략해도 안전한 상황은 두 가지뿐입니다. 첫 번째는 인수가 공백이나 쉘에 특수 문자 (예 : 세미콜론)가없는 리터럴 문자열 인 경우입니다. 예를 들어, &lt;code&gt;test -b /my/file&lt;/code&gt; 입니다. 두 번째는 해당 요소가 빈 문자열 (예 : 'set x' ' &lt;code&gt;). If the variable is not set, set but with no value, or set to more than one value you must enclose it in double-quotes. For example,&lt;/code&gt; 포함하여 정확히 하나의 요소로 확장되는 변수를 사용하는 것 입니다. 변수가 설정되지 않았지만 설정되었지만 값이 없거나 두 개 이상의 값으로 설정되어 있으면 큰 따옴표로 묶어야합니다. 예를 들어, &quot;$ x&quot;= &quot;$ y&quot;테스트하십시오 &lt;code&gt;. Since it is always safe to enclose variables in double-quotes when used as&lt;/code&gt; 권장 되는 테스트 인수 로 사용될 때 변수를 큰 따옴표로 묶는 것이 항상 안전하기 때문에 권장됩니다.</target>
        </trans-unit>
        <trans-unit id="423a828b908fd75e9cc37f539daeca01ccaa2ca1" translate="yes" xml:space="preserve">
          <source>When using most virtual terminals, it is possible to set the message displayed in the titlebar of the terminal window. This can be done automatically in fish by defining the &lt;code&gt;fish_title&lt;/code&gt; function. The &lt;code&gt;fish_title&lt;/code&gt; function is executed before and after a new command is executed or put into the foreground and the output is used as a titlebar message. The &lt;code&gt;status current-command&lt;/code&gt; builtin will always return the name of the job to be put into the foreground (or 'fish' if control is returning to the shell) when the &lt;code&gt;fish_prompt&lt;/code&gt; function is called. The first argument to fish_title will contain the most recently executed foreground command as a string, starting with fish 2.2.</source>
          <target state="translated">대부분의 가상 터미널을 사용하는 경우 터미널 창의 제목 표시 줄에 표시되는 메시지를 설정할 수 있습니다. &lt;code&gt;fish_title&lt;/code&gt; 함수 를 정의하여 물고기에서 자동으로 수행 할 수 있습니다 . &lt;code&gt;fish_title&lt;/code&gt; 함수 전에 새로운 명령이 실행 또는 전경 넣고 출력이 타이틀 메시지로서 사용 된 후 실행된다. 내장 된 &lt;code&gt;status current-command&lt;/code&gt; 는 &lt;code&gt;fish_prompt&lt;/code&gt; 함수가 호출 될 때 항상 포 그라운드로 놓일 작업 이름 (또는 제어가 쉘로 리턴되는 경우 'fish')을 리턴합니다 . fish_title의 첫 번째 인수는 fish 2.2로 시작하여 가장 최근에 실행 된 foreground 명령을 문자열로 포함합니다.</target>
        </trans-unit>
        <trans-unit id="8174e8c2267c766e6e1589bb88a15f5f751e9e9e" translate="yes" xml:space="preserve">
          <source>When using this feature together with array brackets, the brackets will always match the innermost &lt;code&gt;$&lt;/code&gt; dereference. Thus, &lt;code&gt;$$foo[5]&lt;/code&gt; will always mean the fifth element of the &lt;code&gt;foo&lt;/code&gt; variable should be dereferenced, not the fifth element of the doubly dereferenced variable &lt;code&gt;foo&lt;/code&gt;. The latter can instead be expressed as &lt;code&gt;$$foo[1][5]&lt;/code&gt;.</source>
          <target state="translated">이 기능을 배열 괄호와 함께 사용하면 괄호는 항상 가장 안쪽 &lt;code&gt;$&lt;/code&gt; 역 참조 와 일치합니다 . 따라서 &lt;code&gt;$$foo[5]&lt;/code&gt; 는 이중 참조 해제 된 변수 &lt;code&gt;foo&lt;/code&gt; 의 다섯 번째 요소가 아니라 &lt;code&gt;foo&lt;/code&gt; 변수의 다섯 번째 요소를 역 참조해야 함을 의미합니다 . 후자는 &lt;code&gt;$$foo[1][5]&lt;/code&gt; 로 표현 될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="8fc413625f2d8700615beffe00723d3e066b2931" translate="yes" xml:space="preserve">
          <source>When you start a job in &lt;code&gt;fish&lt;/code&gt;, &lt;code&gt;fish&lt;/code&gt; itself will pause, and give control of the terminal to the program just started. Sometimes, you want to continue using the commandline, and have the job run in the background. To create a background job, append an &amp;amp; (ampersand) to your command. This will tell fish to run the job in the background. Background jobs are very useful when running programs that have a graphical user interface.</source>
          <target state="translated">&lt;code&gt;fish&lt;/code&gt; 에서 작업을 시작하면 &lt;code&gt;fish&lt;/code&gt; 자체가 일시 중지되고 프로그램이 시작된 터미널을 제어 할 수 있습니다. 때로는 명령 행을 계속 사용하고 백그라운드에서 작업을 실행하려고합니다. 백그라운드 작업을 작성하려면 명령에 &amp;amp; (앰퍼샌드)를 추가하십시오. 이것은 물고기에게 백그라운드에서 작업을 실행하도록 지시합니다. 백그라운드 작업은 그래픽 사용자 인터페이스가있는 프로그램을 실행할 때 매우 유용합니다.</target>
        </trans-unit>
        <trans-unit id="d15c25511fa0415df6ab124fbf33636f92131f5e" translate="yes" xml:space="preserve">
          <source>Whenever a process exits, an exit status is returned to the program that started it (usually the shell). This exit status is an integer number, which tells the calling application how the execution of the command went. In general, a zero exit status means that the command executed without problem, but a non-zero exit status means there was some form of problem.</source>
          <target state="translated">프로세스가 종료 될 때마다 프로세스를 시작한 프로그램 (일반적으로 쉘)으로 종료 상태가 리턴됩니다. 이 종료 상태는 정수이며, 이는 호출 응용 프로그램에 명령 실행 방법을 알려줍니다. 일반적으로 종료 상태가 0이면 명령이 문제없이 실행되었음을 의미하지만, 0이 아닌 종료 상태는 어떤 형태의 문제가 발생했음을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="37e6818d213a036baa5f294f8cb49db4fd377178" translate="yes" xml:space="preserve">
          <source>Where can I find extra tools for fish?</source>
          <target state="translated">물고기를위한 추가 도구를 어디서 찾을 수 있습니까?</target>
        </trans-unit>
        <trans-unit id="079e201e9c4dd5d183821d76711a9a3942fe2c10" translate="yes" xml:space="preserve">
          <source>Where to put completions</source>
          <target state="translated">완성 장소</target>
        </trans-unit>
        <trans-unit id="218d0fd933c5736f11bfc14c23fd644e6997fe12" translate="yes" xml:space="preserve">
          <source>While loops:</source>
          <target state="translated">while 루프 :</target>
        </trans-unit>
        <trans-unit id="c3d957621152f2cbd082b0e140ac7a547272ab27" translate="yes" xml:space="preserve">
          <source>While this will check if &lt;code&gt;hasargs&lt;/code&gt; was run with the &lt;code&gt;-q&lt;/code&gt; option:</source>
          <target state="translated">경우이 확인됩니다 동안 &lt;code&gt;hasargs&lt;/code&gt; 가 으로 실행 된 &lt;code&gt;-q&lt;/code&gt; 옵션 :</target>
        </trans-unit>
        <trans-unit id="3da2ee8c41b2531ccfd9706e7ed4059f9b39b539" translate="yes" xml:space="preserve">
          <source>Why doesn't `set -Ux` (exported universal variables) seem to work?</source>
          <target state="translated">`set -Ux` (내 보낸 범용 변수)가 작동하지 않는 이유는 무엇입니까?</target>
        </trans-unit>
        <trans-unit id="1e505f696e4f6b7e0b5ed829f453debff8a4a2e5" translate="yes" xml:space="preserve">
          <source>Why doesn't history substitution (&quot;!$&quot; etc.) work?</source>
          <target state="translated">히스토리 대체 ( &quot;! $&quot;등)가 작동하지 않는 이유는 무엇입니까?</target>
        </trans-unit>
        <trans-unit id="567d5b34994eb0320286730214d3dd777982c9ad" translate="yes" xml:space="preserve">
          <source>Why fish?</source>
          <target state="translated">왜 물고기?</target>
        </trans-unit>
        <trans-unit id="59af40d4a351e635fdbe369d7b681d20a590a23a" translate="yes" xml:space="preserve">
          <source>Wildcard expansion</source>
          <target state="translated">와일드 카드 확장</target>
        </trans-unit>
        <trans-unit id="59047ee36a3c7c05f567f4b4586b76d8d7e3171d" translate="yes" xml:space="preserve">
          <source>Wildcard matches are sorted case insensitively. When sorting matches containing numbers, consecutive digits are considered to be one element, so that the strings '1' '5' and '12' would be sorted in the order given.</source>
          <target state="translated">와일드 카드 일치는 대소 문자를 구분하지 않고 정렬됩니다. 숫자가 포함 된 일치 항목을 정렬 할 때 연속 숫자는 하나의 요소로 간주되므로 문자열 '1' '5'및 '12'는 주어진 순서대로 정렬됩니다.</target>
        </trans-unit>
        <trans-unit id="f4138f22664d37f96c263052adeb723fdfd7248c" translate="yes" xml:space="preserve">
          <source>Wildcards</source>
          <target state="translated">Wildcards</target>
        </trans-unit>
        <trans-unit id="278d17b7409d744f59bd2b428221655321a32bee" translate="yes" xml:space="preserve">
          <source>Will print &quot;Number of bananas in my pocket: 42&quot;, &lt;em&gt;without&lt;/em&gt; a newline.</source>
          <target state="translated">줄 바꿈 &lt;em&gt;없이&lt;/em&gt; &quot;내 주머니에 바나나 수 : 42&quot;를 인쇄 합니다.</target>
        </trans-unit>
        <trans-unit id="6d27bda981ba079ffce589e22866c0442facccba" translate="yes" xml:space="preserve">
          <source>Will print &quot;flounder fish&quot; (separated with a tab character), followed by a newline character. This is useful for writing completions, as fish expects completion scripts to output the option followed by the description, separated with a tab character.</source>
          <target state="translated">&quot;줄다리기 물고기&quot;(탭 문자로 구분)를 인쇄 한 다음 줄 바꿈 문자를 표시합니다. 물고기는 완성 스크립트가 옵션과 설명을 차례로 출력하고 탭 문자로 구분하여 완성을 작성하는 데 유용합니다.</target>
        </trans-unit>
        <trans-unit id="d95f3955e4775af2ffe313a32a1e156b2312cd4e" translate="yes" xml:space="preserve">
          <source>Will remove the file 'cumbersome filename.txt', while</source>
          <target state="translated">'cumbersome filename.txt'파일을 제거하는 동안</target>
        </trans-unit>
        <trans-unit id="4044b3d5cb068502c25839df6244b97ef13bfd98" translate="yes" xml:space="preserve">
          <source>With &quot;-c&quot;, it clears the directory stack instead.</source>
          <target state="translated">&quot;-c&quot;를 사용하면 디렉토리 스택이 지워집니다.</target>
        </trans-unit>
        <trans-unit id="b3f596135ed991ca7f5a3bdc45b29b16283c1e4c" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;CMD&lt;/code&gt; specified, the command line buffer is erased and replaced with the contents of &lt;code&gt;CMD&lt;/code&gt;.</source>
          <target state="translated">로 &lt;code&gt;CMD&lt;/code&gt; 는 지정된 명령 라인 버퍼가 소거 및 콘텐츠로 대체 &lt;code&gt;CMD&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d3a11523e7c7f53a50eb3f5c7145415a6eeb3a11" translate="yes" xml:space="preserve">
          <source>With both variable names and values provided, &lt;code&gt;set&lt;/code&gt; assigns the variable &lt;code&gt;VARIABLE_NAME&lt;/code&gt; the values &lt;code&gt;VALUES...&lt;/code&gt;.</source>
          <target state="translated">변수 이름과 값을 모두 제공하면 &lt;code&gt;set&lt;/code&gt; 은 변수 &lt;code&gt;VARIABLE_NAME&lt;/code&gt; 에 값 &lt;code&gt;VALUES...&lt;/code&gt; 할당합니다 .</target>
        </trans-unit>
        <trans-unit id="e3a3bdf1969b9c7b04d35c628b64777d5949f26c" translate="yes" xml:space="preserve">
          <source>With no arguments, &lt;code&gt;status&lt;/code&gt; displays a summary of the current login and job control status of the shell.</source>
          <target state="translated">인수가 없으면, &lt;code&gt;status&lt;/code&gt; 쉘의 현재 로그인 및 작업 제어 상태의 요약을 표시합니다.</target>
        </trans-unit>
        <trans-unit id="ff0f6870a82d5cfaf6592bfe8160d96a5dcb7c33" translate="yes" xml:space="preserve">
          <source>With no options, &lt;code&gt;type&lt;/code&gt; indicates how each &lt;code&gt;NAME&lt;/code&gt; would be interpreted if used as a command name.</source>
          <target state="translated">옵션이 없으면 &lt;code&gt;type&lt;/code&gt; 은 명령 이름으로 사용되는 경우 각 &lt;code&gt;NAME&lt;/code&gt; 을 해석 하는 방법을 나타냅니다 .</target>
        </trans-unit>
        <trans-unit id="324faf3e252b5aa14d470f7a0e509c22b0211914" translate="yes" xml:space="preserve">
          <source>With no parameters, &lt;code&gt;commandline&lt;/code&gt; returns the current value of the command line.</source>
          <target state="translated">매개 변수가 없으면, &lt;code&gt;commandline&lt;/code&gt; 명령 행의 현재 값을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="32e508ff64591c08b5059eaf16992b090526d942" translate="yes" xml:space="preserve">
          <source>With no parameters, the current file creation mode mask is printed as an octal number.</source>
          <target state="translated">매개 변수가 없으면 현재 파일 작성 모드 마스크가 8 진수로 인쇄됩니다.</target>
        </trans-unit>
        <trans-unit id="550c07a797cef93c6dca0c250695a3ee3bc836c8" translate="yes" xml:space="preserve">
          <source>With the &lt;code&gt;--line&lt;/code&gt; option, &lt;code&gt;read&lt;/code&gt; reads a line of input from standard input into each provided variable, stopping when each variable has been filled. The line is not tokenized.</source>
          <target state="translated">&lt;code&gt;--line&lt;/code&gt; 옵션을 사용하면 &lt;code&gt;read&lt;/code&gt; 는 표준 입력에서 제공된 각 변수로 입력 행을 읽고 각 변수가 채워지면 중지합니다. 라인이 토큰 화되지 않았습니다.</target>
        </trans-unit>
        <trans-unit id="7eb04c1870bbf00dde53d943ea601f02f6aade6f" translate="yes" xml:space="preserve">
          <source>With the &lt;code&gt;-s&lt;/code&gt; option, &lt;code&gt;command&lt;/code&gt; treats every argument as a separate command to look up and sets the exit status to 0 if any of the specified commands were found, or 1 if no commands could be found. Additionally passing a &lt;code&gt;-q&lt;/code&gt; or &lt;code&gt;--quiet&lt;/code&gt; option prevents any paths from being printed, like &lt;code&gt;type -q&lt;/code&gt;, for testing only the exit status.</source>
          <target state="translated">&lt;code&gt;-s&lt;/code&gt; 옵션을 사용하면 &lt;code&gt;command&lt;/code&gt; 는 모든 인수를 별도의 명령으로 처리하여 지정된 명령을 찾은 경우 종료 상태를 0으로 설정하고 명령을 찾을 수없는 경우 1로 설정합니다. 또한 &lt;code&gt;-q&lt;/code&gt; 또는 &lt;code&gt;--quiet&lt;/code&gt; 옵션을 전달 하면 종료 상태 만 테스트하기 위해 &lt;code&gt;type -q&lt;/code&gt; 과 같은 경로가 인쇄되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="bc8e1321c10d803c389c5b4efea6741544b19b13" translate="yes" xml:space="preserve">
          <source>Without arguments, it exchanges the top two directories in the stack.</source>
          <target state="translated">인수가 없으면 스택에서 최상위 두 디렉토리를 교환합니다.</target>
        </trans-unit>
        <trans-unit id="1afcecbf9280e75078efa249fd70e1ac68834d9a" translate="yes" xml:space="preserve">
          <source>Without the &lt;code&gt;--line&lt;/code&gt; option, &lt;code&gt;read&lt;/code&gt; reads a single line of input from standard input, breaks it into tokens, and then assigns one token to each variable specified in &lt;code&gt;VARIABLES&lt;/code&gt;. If there are more tokens than variables, the complete remainder is assigned to the last variable.</source>
          <target state="translated">&lt;code&gt;--line&lt;/code&gt; 옵션이 없으면 &lt;code&gt;read&lt;/code&gt; 는 표준 입력에서 한 줄의 입력을 읽고이를 토큰으로 나누고 &lt;code&gt;VARIABLES&lt;/code&gt; 에 지정된 각 변수에 하나의 토큰을 할당합니다 . 변수보다 많은 토큰이 있으면 나머지는 마지막 변수에 할당됩니다.</target>
        </trans-unit>
        <trans-unit id="81356a4d6a0a4a4ef7b6e1d572238cf1fdea2fd0" translate="yes" xml:space="preserve">
          <source>Writing your own completions</source>
          <target state="translated">자신의 완성 물 작성</target>
        </trans-unit>
        <trans-unit id="7683cbf9a7b5e61b6d059df3889d47cb3365f802" translate="yes" xml:space="preserve">
          <source>You can access individual elements with square brackets. Indexing starts at 1 from the beginning, and -1 from the end:</source>
          <target state="translated">대괄호로 개별 요소에 액세스 할 수 있습니다. 인덱싱은 처음부터 1에서 시작하고 끝에서 -1을 시작합니다.</target>
        </trans-unit>
        <trans-unit id="22411b5ee78ea15c18bd052b59931e2ba02abfc9" translate="yes" xml:space="preserve">
          <source>You can also access ranges of elements, known as &quot;slices:&quot;</source>
          <target state="translated">&quot;슬라이스 :&quot;라고하는 다양한 요소에 액세스 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="183a967967d542440e171619570f33c53983ac70" translate="yes" xml:space="preserve">
          <source>You can also declare a local variable in a block:</source>
          <target state="translated">블록에서 지역 변수를 선언 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="c6736676dcee399ddf959a5129dcc47bfa72a06e" translate="yes" xml:space="preserve">
          <source>You can also use the Web configuration tool, &lt;a href=&quot;commands#fish_config&quot;&gt;&lt;code&gt;fish_config&lt;/code&gt;&lt;/a&gt;, to preview and choose from a gallery of sample prompts.</source>
          <target state="translated">웹 구성 도구 인 &lt;a href=&quot;commands#fish_config&quot;&gt; &lt;code&gt;fish_config&lt;/code&gt; 를&lt;/a&gt; 사용하여 샘플 프롬프트 갤러리를 미리보고 선택할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="bdd92db017317ccc2cf69c4b1d28391056cb80e8" translate="yes" xml:space="preserve">
          <source>You can append (or prepend) to a list by setting the list to itself, with some additional arguments. Here we append /usr/local/bin to $PATH:</source>
          <target state="translated">추가 인수를 사용하여 목록을 자체로 설정하여 목록에 추가하거나 추가 할 수 있습니다. 여기서 / usr / local / bin을 $ PATH에 추가합니다 :</target>
        </trans-unit>
        <trans-unit id="1bb567fe25bb6a2caba3279e69807e978438ad28" translate="yes" xml:space="preserve">
          <source>You can change &lt;code&gt;fish_history&lt;/code&gt; at any time (by using &lt;code&gt;set -x fish_history &quot;session_name&quot;&lt;/code&gt;) and it will take effect right away. If you set it to &lt;code&gt;&quot;default&quot;&lt;/code&gt;, it will use the default session name (which is &lt;code&gt;&quot;fish&quot;&lt;/code&gt;).</source>
          <target state="translated">&lt;code&gt;set -x fish_history &quot;session_name&quot;&lt;/code&gt; 을 사용하여 언제든지 &lt;code&gt;fish_history&lt;/code&gt; 를 변경할 수 있으며 즉시 적용됩니다. &lt;code&gt;&quot;default&quot;&lt;/code&gt; 로 설정 하면 기본 세션 이름 ( &lt;code&gt;&quot;fish&quot;&lt;/code&gt; )이 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="271d995eee26c277a042d3d479fbc5c44abb9d62" translate="yes" xml:space="preserve">
          <source>You can change these key bindings using the &lt;a href=&quot;commands#bind&quot;&gt;bind&lt;/a&gt; builtin command.</source>
          <target state="translated">&lt;a href=&quot;commands#bind&quot;&gt;bind&lt;/a&gt; builtin 명령을 사용하여 이러한 키 바인딩을 변경할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="0fbf59159cacd6194c5d1afee388fe6f9b2deba5" translate="yes" xml:space="preserve">
          <source>You can choose among some sample prompts by running &lt;code&gt;fish_config prompt&lt;/code&gt;. &lt;code&gt;fish&lt;/code&gt; also supports RPROMPT through &lt;code&gt;fish_right_prompt&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;fish_config prompt&lt;/code&gt; 를 실행하여 일부 샘플 프롬프트 중에서 선택할 수 있습니다 . &lt;code&gt;fish&lt;/code&gt; 또한을 통해 RPROMPT을 지원 &lt;code&gt;fish_right_prompt&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="29e07248f927a66e3445195c42cee5dad321cbe4" translate="yes" xml:space="preserve">
          <source>You can create abbreviations interactively and they will be visible to other fish sessions if you use the &lt;code&gt;-U&lt;/code&gt; or &lt;code&gt;--universal&lt;/code&gt; flag or don't explicitly specify the scope and the abbreviation isn't already defined with global scope. If you want it to be visible only to the current shell use the &lt;code&gt;-g&lt;/code&gt; or &lt;code&gt;--global&lt;/code&gt; flag.</source>
          <target state="translated">대화식으로 약어를 작성할 수 있으며 &lt;code&gt;-U&lt;/code&gt; 또는 &lt;code&gt;--universal&lt;/code&gt; 플래그를 사용하거나 범위를 명시 적으로 지정하지 않고 약어가 이미 전역 범위로 정의되지 않은 경우 다른 물고기 세션에 표시 될 수 있습니다 . 현재 쉘에만 표시되도록하려면 &lt;code&gt;-g&lt;/code&gt; 또는 &lt;code&gt;--global&lt;/code&gt; 플래그를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="b6e4c148ce6b5b609986d145a9a7da7ea9b88d15" translate="yes" xml:space="preserve">
          <source>You can define your own prompt:</source>
          <target state="translated">자신의 프롬프트를 정의 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f61c13e82446efa061ca7d17091f411ee83d8761" translate="yes" xml:space="preserve">
          <source>You can do so directly in &lt;code&gt;config.fish&lt;/code&gt;, like you might do in other shells with &lt;code&gt;.profile&lt;/code&gt;. See &lt;a href=&quot;#path_example&quot;&gt;this example&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;.profile&lt;/code&gt; 을 사용하는 다른 쉘에서와 같이 &lt;code&gt;config.fish&lt;/code&gt; 에서 직접 수행 할 수 있습니다 . &lt;a href=&quot;#path_example&quot;&gt;이 예제를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="70c6c6dd6e2cc9d671b6c22ccdb9354bc3fcc555" translate="yes" xml:space="preserve">
          <source>You can erase a variable with &lt;code&gt;-e&lt;/code&gt; or &lt;code&gt;--erase&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;-e&lt;/code&gt; 또는 &lt;code&gt;--erase&lt;/code&gt; 를 사용 하여 변수를 지울 수 있습니다</target>
        </trans-unit>
        <trans-unit id="5bad3c32a8d2a38fb8952af3582045099d1f7782" translate="yes" xml:space="preserve">
          <source>You can include a literal space in an argument with a backslash, or by using single or double quotes:</source>
          <target state="translated">백 슬래시를 사용하거나 작은 따옴표 나 큰 따옴표를 사용하여 인수에 리터럴 공백을 포함시킬 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="cf2d7abc4fc8709fbd1e843b233396517d8ddaca" translate="yes" xml:space="preserve">
          <source>You can include multiple wildcards:</source>
          <target state="translated">여러 개의 와일드 카드를 포함 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f83e4dd668d0923f31b885de0832e79602a1616d" translate="yes" xml:space="preserve">
          <source>You can iterate over a list (or a slice) with a for loop:</source>
          <target state="translated">for 루프를 사용하여 목록 (또는 슬라이스)을 반복 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="582ba3e59d153a759cfa8931cfe3daa07df07cb8" translate="yes" xml:space="preserve">
          <source>You can list the names of all functions with the &lt;code&gt;functions&lt;/code&gt; keyword (note the plural!). &lt;code&gt;fish&lt;/code&gt; starts out with a number of functions:</source>
          <target state="translated">&lt;code&gt;functions&lt;/code&gt; 키워드를 사용하여 모든 함수의 이름을 나열 할 수 있습니다 (복수!). &lt;code&gt;fish&lt;/code&gt; 는 여러 가지 기능으로 시작됩니다.</target>
        </trans-unit>
        <trans-unit id="cdbfa536e96ce4c5031503e10bf462df7b697afe" translate="yes" xml:space="preserve">
          <source>You can only specify one subcommand per invocation even if you use the flag form of the subcommand.</source>
          <target state="translated">부속 명령의 플래그 양식을 사용하더라도 호출 당 하나의 부속 명령 만 지정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="32cbb15c775d0a5c4bd4e986a03e5ca4d359b068" translate="yes" xml:space="preserve">
          <source>You can pipe between commands with the usual vertical bar:</source>
          <target state="translated">일반적인 수직 막대를 사용하여 명령 사이를 파이프 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9d42fab7275c3711f78f4cc0e17430682558b418" translate="yes" xml:space="preserve">
          <source>You can see the current list of features via &lt;code&gt;status features&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;status features&lt;/code&gt; 통해 현재 기능 목록을 볼 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="d372da7b7b5d10683d41167afee54d800f912536" translate="yes" xml:space="preserve">
          <source>You can see the source for any function by passing its name to &lt;code&gt;functions&lt;/code&gt;:</source>
          <target state="translated">당신은 그것의 이름을 전달하여 모든 기능에 대한 소스를 볼 수있는 &lt;code&gt;functions&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="119c7a997d5bdc2b60e626a0ba66e37ce06fb4d1" translate="yes" xml:space="preserve">
          <source>You can set the &lt;code&gt;fish_history&lt;/code&gt; variable to another name for the current shell session. The default value (when the variable is unset) is &lt;code&gt;fish&lt;/code&gt; which corresponds to &lt;code&gt;$XDG_DATA_HOME/fish/fish_history&lt;/code&gt;. If you set it to e.g. &lt;code&gt;fun&lt;/code&gt;, the history would be written to &lt;code&gt;$XDG_DATA_HOME/fish/fun_history&lt;/code&gt;. An empty string means history will not be stored at all. This is similar to the private session features in web browsers.</source>
          <target state="translated">&lt;code&gt;fish_history&lt;/code&gt; 변수를 현재 쉘 세션의 다른 이름으로 설정할 수 있습니다 . (변수가 설정되지 않은 경우) 기본값은 &lt;code&gt;fish&lt;/code&gt; 하는에 해당하는 &lt;code&gt;$XDG_DATA_HOME/fish/fish_history&lt;/code&gt; . 예를 들어 &lt;code&gt;fun&lt;/code&gt; 으로 설정 하면 기록은 &lt;code&gt;$XDG_DATA_HOME/fish/fun_history&lt;/code&gt; 기록됩니다 . 빈 문자열은 히스토리가 전혀 저장되지 않음을 의미합니다. 이것은 웹 브라우저의 개인 세션 기능과 유사합니다.</target>
        </trans-unit>
        <trans-unit id="805a6b59b4757ac95f6f000c9c60c72ef172664e" translate="yes" xml:space="preserve">
          <source>You can use &lt;a href=&quot;#and&quot;&gt;&lt;code&gt;and&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;#or&quot;&gt;&lt;code&gt;or&lt;/code&gt;&lt;/a&gt; for complex conditions. Even more complex control can be achieved with &lt;code&gt;while true&lt;/code&gt; containing a &lt;a href=&quot;#break&quot;&gt;break&lt;/a&gt;.</source>
          <target state="translated">당신은 사용할 수 있습니다 &lt;a href=&quot;#and&quot;&gt; &lt;code&gt;and&lt;/code&gt; &lt;/a&gt; 하거나 &lt;a href=&quot;#or&quot;&gt; &lt;code&gt;or&lt;/code&gt; &lt;/a&gt; 복잡한 조건. 더 복잡한 제어는 &lt;code&gt;while true&lt;/code&gt; &lt;a href=&quot;#break&quot;&gt;휴식을&lt;/a&gt; 포함 하면서 달성 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="36becbc0de8c6768b79b53bcf652c0ec7f0d05ab" translate="yes" xml:space="preserve">
          <source>You can use &lt;a href=&quot;#and&quot;&gt;&lt;code&gt;and&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;#or&quot;&gt;&lt;code&gt;or&lt;/code&gt;&lt;/a&gt; in the condition. See the second example below.</source>
          <target state="translated">&lt;a href=&quot;#and&quot;&gt; &lt;code&gt;and&lt;/code&gt; &lt;/a&gt; / &lt;a href=&quot;#or&quot;&gt; &lt;code&gt;or&lt;/code&gt; &lt;/a&gt; 조건에서 사용할 수 있습니다 . 아래 두 번째 예를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="a29442c2c0cd9017469875929db91ad4d3e135db" translate="yes" xml:space="preserve">
          <source>You can use the following commands for this:</source>
          <target state="translated">이를 위해 다음 명령을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ae2c831ec8a49110729d78b946cea71b43a00858" translate="yes" xml:space="preserve">
          <source>You cannot create an alias to a function with the same name. Note that spaces need to be escaped in the call to &lt;code&gt;alias&lt;/code&gt; just like at the command line, &lt;em&gt;even inside quoted parts&lt;/em&gt;.</source>
          <target state="translated">같은 이름의 함수에 대한 별칭을 만들 수 없습니다. 명령 행에서와 같이, &lt;em&gt;인용 된 부분 내부에서도 &lt;/em&gt; &lt;code&gt;alias&lt;/code&gt; 호출시 공백을 이스케이프해야합니다 .&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="ccdace8ac9f08512755f925735f08580088b949a" translate="yes" xml:space="preserve">
          <source>You don't need to use &lt;code&gt;--&lt;/code&gt; before the expression even if it begins with a minus sign which might otherwise be interpreted as an invalid option. If you do insert &lt;code&gt;--&lt;/code&gt; before the expression it will cause option scanning to stop just like for every other command and it won't be part of the expression.</source>
          <target state="translated">당신은 사용할 필요가 없습니다 &lt;code&gt;--&lt;/code&gt; 그것은 그렇지 않으면 잘못된 옵션으로 해석 될 수 마이너스 기호로 시작하는 경우에도 표현하기 전에. 삽입 할 경우 &lt;code&gt;--&lt;/code&gt; 식 전에 발생합니다 옵션 스캔은 다른 모든 명령과 같은 중지하고이 표현의 일부가되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="dff1182c8c84fa78c31ad7304aa236d391621f4d" translate="yes" xml:space="preserve">
          <source>You may be interested in the &lt;a href=&quot;commands#cdh&quot;&gt;&lt;code&gt;cdh&lt;/code&gt;&lt;/a&gt; command which provides a more intuitive way to navigate to recently visited directories.</source>
          <target state="translated">최근에 방문한 디렉토리를보다 직관적으로 탐색 할 수있는 &lt;a href=&quot;commands#cdh&quot;&gt; &lt;code&gt;cdh&lt;/code&gt; &lt;/a&gt; 명령에 관심이있을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="f19456ce739912cdbaadf68c5288fc6b883036c4" translate="yes" xml:space="preserve">
          <source>You may need to adjust the above path to e.g. &lt;code&gt;/usr/bin/fish&lt;/code&gt;. Use the command &lt;code&gt;which fish&lt;/code&gt; if you are unsure of where fish is installed.</source>
          <target state="translated">위의 경로를 &lt;code&gt;/usr/bin/fish&lt;/code&gt; 로 조정해야 할 수도 있습니다 . 어디에 물고기가 설치되어 있는지 확실하지 않은 경우 &lt;code&gt;which fish&lt;/code&gt; 명령 을 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="f60f3dbd8379e7020fda94ce83302c2e10232183" translate="yes" xml:space="preserve">
          <source>You should not assume that only five lines will be written since we may add additional information to the output in the future.</source>
          <target state="translated">나중에 출력에 추가 정보를 추가 할 수 있으므로 5 줄만 작성한다고 가정해서는 안됩니다.</target>
        </trans-unit>
        <trans-unit id="d00cc0aeee9d747695090dc15483badfdd7bb562" translate="yes" xml:space="preserve">
          <source>You should not consider &lt;code&gt;RANDOM&lt;/code&gt; cryptographically secure, or even statistically accurate.</source>
          <target state="translated">&lt;code&gt;RANDOM&lt;/code&gt; 은 암호로 안전하거나 통계적으로 정확한 것으로 간주해서는 안됩니다 .</target>
        </trans-unit>
        <trans-unit id="099d04689a14254d5c264e92a8949102945a2d8c" translate="yes" xml:space="preserve">
          <source>You will be greeted by the standard fish prompt, which means you are all set up and can start using fish:</source>
          <target state="translated">표준 물고기 프롬프트가 표시됩니다. 이는 모두 설정되었으며 물고기를 사용할 수 있음을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="daf44230d29581bbad655cd6db1bfaf7030ab520" translate="yes" xml:space="preserve">
          <source>You would then use it in place of &lt;code&gt;**&lt;/code&gt; like this, &lt;code&gt;my_prog (ff)&lt;/code&gt;, to pass only regular files in or below $PWD to &lt;code&gt;my_prog&lt;/code&gt;.</source>
          <target state="translated">당신은 다음의 장소에 사용하는 것이 &lt;code&gt;**&lt;/code&gt; 이런, &lt;code&gt;my_prog (ff)&lt;/code&gt; 에 $ PWD 또는 아래 정규 파일을 전달하는 &lt;code&gt;my_prog&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1c67de04c7033796c6c74cd4dd03c739078b5757" translate="yes" xml:space="preserve">
          <source>You'll quickly notice that &lt;code&gt;fish&lt;/code&gt; performs syntax highlighting as you type. Invalid commands are colored red by default:</source>
          <target state="translated">&lt;code&gt;fish&lt;/code&gt; 입력 할 때 구문 강조를 수행 한다는 것을 빠르게 알 수 있습니다. 유효하지 않은 명령은 기본적으로 빨간색으로 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="0f1904a8c07ac4a095aa5e3b5df39a737f0d2b78" translate="yes" xml:space="preserve">
          <source>Zero is considered success, and non-zero is failure.</source>
          <target state="translated">0은 성공으로 간주되고 0이 아닌 것은 실패입니다.</target>
        </trans-unit>
        <trans-unit id="b9bce8bc7cbd4cfc74af295dc63b50f294e0fb27" translate="yes" xml:space="preserve">
          <source>abbr</source>
          <target state="translated">abbr</target>
        </trans-unit>
        <trans-unit id="10c64ce9ed7a8c30b0b458cd0cea2f41104ed020" translate="yes" xml:space="preserve">
          <source>abbr - manage fish abbreviations</source>
          <target state="translated">abbr-물고기 약어 관리</target>
        </trans-unit>
        <trans-unit id="682cee3cbd526832d0e8acb7535f6a975ddc96ee" translate="yes" xml:space="preserve">
          <source>add &lt;code&gt;/usr/local/bin/fish&lt;/code&gt; to &lt;code&gt;/etc/shells&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;/etc/shells&lt;/code&gt; 에 &lt;code&gt;/usr/local/bin/fish&lt;/code&gt; 를 추가하십시오</target>
        </trans-unit>
        <trans-unit id="cdb6fdbe91faa53a7c573c80b7c18108c73c0480" translate="yes" xml:space="preserve">
          <source>alias</source>
          <target state="translated">alias</target>
        </trans-unit>
        <trans-unit id="42a06677b30252b0d37eaddcaf33c622b85d08b4" translate="yes" xml:space="preserve">
          <source>alias - create a function</source>
          <target state="translated">별명-함수 작성</target>
        </trans-unit>
        <trans-unit id="cffa50a32cb13a240d705317bcec65dd1f31b6ad" translate="yes" xml:space="preserve">
          <source>and</source>
          <target state="translated">and</target>
        </trans-unit>
        <trans-unit id="4ed9a78158a5eed2a098e3c46a71c9215bfe4153" translate="yes" xml:space="preserve">
          <source>and - conditionally execute a command</source>
          <target state="translated">-조건부로 명령을 실행</target>
        </trans-unit>
        <trans-unit id="e750ee7c231477c66be61075d1aafe532a03970f" translate="yes" xml:space="preserve">
          <source>argparse</source>
          <target state="translated">argparse</target>
        </trans-unit>
        <trans-unit id="b3ef1b3ad484c3f1815d35a2d7273ba16d3fc004" translate="yes" xml:space="preserve">
          <source>argparse - parse options passed to a fish script or function</source>
          <target state="translated">argparse-피싱 스크립트 또는 함수에 전달 된 구문 분석 옵션</target>
        </trans-unit>
        <trans-unit id="8cbd0a74c6efdb39943b290bb82c9d6b2a6ee5a6" translate="yes" xml:space="preserve">
          <source>begin</source>
          <target state="translated">begin</target>
        </trans-unit>
        <trans-unit id="d849f3a2774d5c3d8a5b753d01c1b98a89678580" translate="yes" xml:space="preserve">
          <source>begin - start a new block of code</source>
          <target state="translated">시작-새로운 코드 블록을 시작</target>
        </trans-unit>
        <trans-unit id="80f87c8847da6c872ce2fc9fec0a98a73ebc578d" translate="yes" xml:space="preserve">
          <source>bg</source>
          <target state="translated">bg</target>
        </trans-unit>
        <trans-unit id="eae83d584c6eeb26f5e657e85aaec8ab661a533a" translate="yes" xml:space="preserve">
          <source>bg - send jobs to background</source>
          <target state="translated">bg-백그라운드로 작업 보내기</target>
        </trans-unit>
        <trans-unit id="6bdd4db977b0f96aaf3bff2e4300153c648ca382" translate="yes" xml:space="preserve">
          <source>bind</source>
          <target state="translated">bind</target>
        </trans-unit>
        <trans-unit id="4d74207ae06bd7de23e2fc590a893d97bc45179b" translate="yes" xml:space="preserve">
          <source>bind - handle fish key bindings</source>
          <target state="translated">바인딩-물고기 키 바인딩 처리</target>
        </trans-unit>
        <trans-unit id="0214b4b355d11ca8f2ce45a968c264651bdfbf83" translate="yes" xml:space="preserve">
          <source>block</source>
          <target state="translated">block</target>
        </trans-unit>
        <trans-unit id="eaad10d066a35f607308cf97548f180f4b9b872e" translate="yes" xml:space="preserve">
          <source>block - temporarily block delivery of events</source>
          <target state="translated">block-이벤트 전달을 일시적으로 차단</target>
        </trans-unit>
        <trans-unit id="4f9cac8dbc4c67a388b8379dcc126c90c7c5e72a" translate="yes" xml:space="preserve">
          <source>break</source>
          <target state="translated">break</target>
        </trans-unit>
        <trans-unit id="175a258d07e2daaf5e3b38a9da4f646e868f7dd3" translate="yes" xml:space="preserve">
          <source>break - stop the current inner loop</source>
          <target state="translated">break-현재 내부 루프를 중지</target>
        </trans-unit>
        <trans-unit id="5c0a31c48cda57c40dc61b785110d76593834ffd" translate="yes" xml:space="preserve">
          <source>breakpoint</source>
          <target state="translated">breakpoint</target>
        </trans-unit>
        <trans-unit id="2922ddae1fa1032ce7131127668d51bf87c71f7e" translate="yes" xml:space="preserve">
          <source>breakpoint - Launch debug mode</source>
          <target state="translated">중단 점-디버그 모드 시작</target>
        </trans-unit>
        <trans-unit id="748a336cc88c03ccb07ed5f5073d18624731b8b5" translate="yes" xml:space="preserve">
          <source>builtin</source>
          <target state="translated">builtin</target>
        </trans-unit>
        <trans-unit id="fa7c75bcd8e77b2860336c73b4baf210585bbf7f" translate="yes" xml:space="preserve">
          <source>builtin - run a builtin command</source>
          <target state="translated">내장-내장 명령 실행</target>
        </trans-unit>
        <trans-unit id="6406510c31e0c9925733c7f21414bf6428333ed2" translate="yes" xml:space="preserve">
          <source>case</source>
          <target state="translated">case</target>
        </trans-unit>
        <trans-unit id="ecbc5351327db65d354a1a7d358353471d69609a" translate="yes" xml:space="preserve">
          <source>case - conditionally execute a block of commands</source>
          <target state="translated">case-명령 블록을 조건부로 실행</target>
        </trans-unit>
        <trans-unit id="034778198a045c1ed80be271cdd029b76874f6fc" translate="yes" xml:space="preserve">
          <source>cd</source>
          <target state="translated">cd</target>
        </trans-unit>
        <trans-unit id="fb525966ad485c5f8afa455838828ee40af068d5" translate="yes" xml:space="preserve">
          <source>cd - change directory</source>
          <target state="translated">cd-디렉토리 변경</target>
        </trans-unit>
        <trans-unit id="2aba119bde64723a0961a18ff7adcf76a9d24d8e" translate="yes" xml:space="preserve">
          <source>cdh</source>
          <target state="translated">cdh</target>
        </trans-unit>
        <trans-unit id="1be63f271a472b0d15f170811e4caf9972df88bb" translate="yes" xml:space="preserve">
          <source>cdh - change to a recently visited directory</source>
          <target state="translated">cdh-최근에 방문한 디렉토리로 변경</target>
        </trans-unit>
        <trans-unit id="0f8e267ee0d75f9ceaa9ed7d8f182c646d73ba65" translate="yes" xml:space="preserve">
          <source>change your default shell with &lt;code&gt;chsh -s&lt;/code&gt; to &lt;code&gt;/usr/local/bin/fish&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;chsh -s&lt;/code&gt; 를 사용하여 기본 쉘 을 &lt;code&gt;/usr/local/bin/fish&lt;/code&gt; 로 변경하십시오.</target>
        </trans-unit>
        <trans-unit id="1925f793093581c47a5c6b2e414506b1cbae280d" translate="yes" xml:space="preserve">
          <source>command</source>
          <target state="translated">command</target>
        </trans-unit>
        <trans-unit id="919a6f5c6816036eaffc9cdb1996a015acf915b7" translate="yes" xml:space="preserve">
          <source>command - run a program</source>
          <target state="translated">명령-프로그램을 실행</target>
        </trans-unit>
        <trans-unit id="92df95e63882bc424c741ba3025a247583b8fe73" translate="yes" xml:space="preserve">
          <source>commandline</source>
          <target state="translated">commandline</target>
        </trans-unit>
        <trans-unit id="bcf389e72583580fd4176da0b6e9a5409c5718c2" translate="yes" xml:space="preserve">
          <source>commandline - set or get the current command line buffer</source>
          <target state="translated">commandline-현재 명령 행 버퍼를 설정하거나 얻는다</target>
        </trans-unit>
        <trans-unit id="0737c22d3bfae812339732d14d8c7dbd6dc4e09c" translate="yes" xml:space="preserve">
          <source>complete</source>
          <target state="translated">complete</target>
        </trans-unit>
        <trans-unit id="b1b90f2b3d099b292abc0be14142c4ee0c55e03b" translate="yes" xml:space="preserve">
          <source>complete - edit command specific tab-completions</source>
          <target state="translated">완료-명령 특정 탭 완성 편집</target>
        </trans-unit>
        <trans-unit id="caeb909ae4ff4ee25a0ff0d476946ed256f2aee1" translate="yes" xml:space="preserve">
          <source>contains</source>
          <target state="translated">contains</target>
        </trans-unit>
        <trans-unit id="904d39bd3ceac4decbc721c45054ed1c4b2c7fdb" translate="yes" xml:space="preserve">
          <source>contains - test if a word is present in a list</source>
          <target state="translated">contains-단어가 목록에 있는지 테스트</target>
        </trans-unit>
        <trans-unit id="eee0bbba4ff92adbeb038a77df0466d660f15716" translate="yes" xml:space="preserve">
          <source>continue</source>
          <target state="translated">continue</target>
        </trans-unit>
        <trans-unit id="3dcfedcccb8d23e7c6644e8aaa4e93528f238e86" translate="yes" xml:space="preserve">
          <source>continue - skip the remainder of the current iteration of the current inner loop</source>
          <target state="translated">계속-현재 내부 루프의 현재 반복의 나머지 부분을 건너 뜁니다.</target>
        </trans-unit>
        <trans-unit id="ee9f38e186ba06f57b7b74d7e626b94e13ce2556" translate="yes" xml:space="preserve">
          <source>count</source>
          <target state="translated">count</target>
        </trans-unit>
        <trans-unit id="f9695c7d17d44b126e144bc1e4fd9b6da6439c0b" translate="yes" xml:space="preserve">
          <source>count - count the number of elements of an array</source>
          <target state="translated">count-배열의 요소 수를 센다</target>
        </trans-unit>
        <trans-unit id="3e96454870cb43583623cd6fd2ede60817e93fe7" translate="yes" xml:space="preserve">
          <source>dirh</source>
          <target state="translated">dirh</target>
        </trans-unit>
        <trans-unit id="0c8c1d4815753a4a62148f6267504e711947a5a6" translate="yes" xml:space="preserve">
          <source>dirh - print directory history</source>
          <target state="translated">dirh-디렉토리 기록 인쇄</target>
        </trans-unit>
        <trans-unit id="4d47d2db541c41663c8c0bc2b1795aa88c209d4d" translate="yes" xml:space="preserve">
          <source>dirs</source>
          <target state="translated">dirs</target>
        </trans-unit>
        <trans-unit id="d78b6ac49770a83c7c282f2a24eb1a12e41b5ef0" translate="yes" xml:space="preserve">
          <source>dirs - print directory stack</source>
          <target state="translated">dirs-인쇄 디렉토리 스택</target>
        </trans-unit>
        <trans-unit id="9b66695fe2c105488ed57178ad21457b4a8f4d6d" translate="yes" xml:space="preserve">
          <source>disown</source>
          <target state="translated">disown</target>
        </trans-unit>
        <trans-unit id="58603ac8c3e3cdf452a31e52281bae95d4d75e55" translate="yes" xml:space="preserve">
          <source>disown - remove a process from the list of jobs</source>
          <target state="translated">disown-작업 목록에서 프로세스 제거</target>
        </trans-unit>
        <trans-unit id="b2d21e771d9f86865c5eff193663574dd1796c8f" translate="yes" xml:space="preserve">
          <source>echo</source>
          <target state="translated">echo</target>
        </trans-unit>
        <trans-unit id="3da22d7a242ac6222e2c07ce546b9e4c6dd38dd1" translate="yes" xml:space="preserve">
          <source>echo - display a line of text</source>
          <target state="translated">echo-한 줄의 텍스트를 표시</target>
        </trans-unit>
        <trans-unit id="ae050f5b7fb8d383d62139276081853b47e7a03e" translate="yes" xml:space="preserve">
          <source>else</source>
          <target state="translated">else</target>
        </trans-unit>
        <trans-unit id="b25854c62e2574da9e59aea193dfc09880feb717" translate="yes" xml:space="preserve">
          <source>else - execute command if a condition is not met</source>
          <target state="translated">else-조건이 충족되지 않으면 명령을 실행합니다</target>
        </trans-unit>
        <trans-unit id="2e96e89125f4c1aef797410a4bfdb32c0632ef0c" translate="yes" xml:space="preserve">
          <source>emit</source>
          <target state="translated">emit</target>
        </trans-unit>
        <trans-unit id="bf4da1905dbefff0b501f9e43f751404b18c712b" translate="yes" xml:space="preserve">
          <source>emit - Emit a generic event</source>
          <target state="translated">방출-일반 이벤트 방출</target>
        </trans-unit>
        <trans-unit id="7a92f3d26362d6557d5701de77a63a01df61e57f" translate="yes" xml:space="preserve">
          <source>end</source>
          <target state="translated">end</target>
        </trans-unit>
        <trans-unit id="786c7d3478f2ca103089368c16db1f80f0f9c7cb" translate="yes" xml:space="preserve">
          <source>end - end a block of commands.</source>
          <target state="translated">끝-명령 블록을 끝냅니다.</target>
        </trans-unit>
        <trans-unit id="822bc13e2d55b402eb4233cb23c9d414a7a03bc1" translate="yes" xml:space="preserve">
          <source>eval</source>
          <target state="translated">eval</target>
        </trans-unit>
        <trans-unit id="20a23908f3b688d4985f1907e61de8afef1f3a09" translate="yes" xml:space="preserve">
          <source>eval - evaluate the specified commands</source>
          <target state="translated">eval-지정된 명령을 평가</target>
        </trans-unit>
        <trans-unit id="be62562725d30894d1641b11d5106adde66f0d79" translate="yes" xml:space="preserve">
          <source>exec</source>
          <target state="translated">exec</target>
        </trans-unit>
        <trans-unit id="766cd545cfc1fa64a7d4796ba64c27dc06bebbfc" translate="yes" xml:space="preserve">
          <source>exec - execute command in current process</source>
          <target state="translated">exec-현재 프로세스에서 명령 실행</target>
        </trans-unit>
        <trans-unit id="de3ac21778e51de199438300e1a9f816c618d33a" translate="yes" xml:space="preserve">
          <source>exit</source>
          <target state="translated">exit</target>
        </trans-unit>
        <trans-unit id="471719c1d7f23f2fb831651b4dd0b2d996e8d915" translate="yes" xml:space="preserve">
          <source>exit - exit the shell</source>
          <target state="translated">종료-쉘을 종료</target>
        </trans-unit>
        <trans-unit id="7cb6efb98ba5972a9b5090dc2e517fe14d12cb04" translate="yes" xml:space="preserve">
          <source>false</source>
          <target state="translated">false</target>
        </trans-unit>
        <trans-unit id="6f9d12a083b81d8fbe0b94c63c69b42fb349ddbb" translate="yes" xml:space="preserve">
          <source>false - return an unsuccessful result</source>
          <target state="translated">false-실패한 결과를 반환</target>
        </trans-unit>
        <trans-unit id="72f77e84ba0149b2af1051f1318128dccf60ab60" translate="yes" xml:space="preserve">
          <source>fg</source>
          <target state="translated">fg</target>
        </trans-unit>
        <trans-unit id="d57e75549526546c15d5c9fb8e07df72a8c58c81" translate="yes" xml:space="preserve">
          <source>fg - bring job to foreground</source>
          <target state="translated">fg-작업을 포 그라운드로 가져 오기</target>
        </trans-unit>
        <trans-unit id="64875fcccaac069fcb3e0e201e7d5b9166641608" translate="yes" xml:space="preserve">
          <source>fish</source>
          <target state="translated">fish</target>
        </trans-unit>
        <trans-unit id="72e0e125205009a2096ed8c57d1f27ec4b75c74b" translate="yes" xml:space="preserve">
          <source>fish - the friendly interactive shell</source>
          <target state="translated">물고기-친절한 대화식 쉘</target>
        </trans-unit>
        <trans-unit id="55daf0fb67b0105e5fee42d2b43a9981fcc9b191" translate="yes" xml:space="preserve">
          <source>fish also supports &lt;code&gt;and&lt;/code&gt;, &lt;code&gt;or&lt;/code&gt;, and &lt;code&gt;not&lt;/code&gt;. The first two are job modifiers and have lower precedence. Example usage:</source>
          <target state="translated">물고기도 지원 &lt;code&gt;and&lt;/code&gt; , &lt;code&gt;or&lt;/code&gt; 하고 &lt;code&gt;not&lt;/code&gt; . 처음 두 가지는 작업 수정 자이며 우선 순위가 낮습니다. 사용법 예 :</target>
        </trans-unit>
        <trans-unit id="d0b6a9d36699331ac1f0bb6a1d6c28f0fee1e9d4" translate="yes" xml:space="preserve">
          <source>fish suggests commands as you type, based on command history, completions, and valid file paths. As you type commands, you will see a suggestion offered after the cursor, in a muted gray color (which can be changed with the &lt;code&gt;fish_color_autosuggestion&lt;/code&gt; variable).</source>
          <target state="translated">fish는 명령 기록, 완료 및 유효한 파일 경로를 기반으로 입력 할 때 명령을 제안합니다. 명령을 입력 할 때 커서 다음에 제안이 회색으로 표시됩니다 ( &lt;code&gt;fish_color_autosuggestion&lt;/code&gt; 변수 로 변경할 수 있음 ).</target>
        </trans-unit>
        <trans-unit id="68f36d0bf0f877357b61f16b465f75cb1a85b6d8" translate="yes" xml:space="preserve">
          <source>fish supports launching in private mode via &lt;code&gt;fish --private&lt;/code&gt; (or &lt;code&gt;fish -P&lt;/code&gt; for short). In private mode, old history is not available and any interactive commands you execute will not be appended to the global history file, making it useful both for avoiding inadvertently leaking personal information (e.g. for screencasts) and when dealing with sensitive information to prevent it being persisted to disk. You can query the global variable &lt;code&gt;fish_private_mode&lt;/code&gt; (&lt;code&gt;if set -q fish_private_mode ...&lt;/code&gt;) if you would like to respect the user's wish for privacy and alter the behavior of your own fish scripts.</source>
          <target state="translated">fish는 &lt;code&gt;fish --private&lt;/code&gt; (또는 &lt;code&gt;fish -P&lt;/code&gt; ) 를 통해 개인 모드로 실행을 지원합니다 . 개인 모드에서는 이전 기록을 사용할 수 없으며 실행하는 대화식 명령이 전역 기록 파일에 추가되지 않으므로 개인 정보가 실수로 유출되는 것을 방지하고 (예 : 스크린 캐스트) 민감한 정보를 처리하여 정보 유출을 방지하는 데 유용합니다. 디스크에 지속. 프라이버시를 원하는 사용자의 요구를 존중하고 자신의 피쉬 스크립트의 동작을 변경 하려면 글로벌 변수 &lt;code&gt;fish_private_mode&lt;/code&gt; ( &lt;code&gt;if set -q fish_private_mode ...&lt;/code&gt; )를 쿼리 할 수 ​​있습니다 .</target>
        </trans-unit>
        <trans-unit id="0c4f6d7aed742643b6fbdc12202fe3db52010252" translate="yes" xml:space="preserve">
          <source>fish supports the familiar &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; and &lt;code&gt;||&lt;/code&gt; to combine commands, and &lt;code&gt;!&lt;/code&gt; to negate them:</source>
          <target state="translated">물고기는 친숙한 &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; 및 &lt;code&gt;||&lt;/code&gt; 명령을 결합하고 &lt;code&gt;!&lt;/code&gt; 그들을 부정하기 위해 :</target>
        </trans-unit>
        <trans-unit id="18585084ed30bb889b3339262219e49ab2ae44bd" translate="yes" xml:space="preserve">
          <source>fish tutorial</source>
          <target state="translated">물고기 튜토리얼</target>
        </trans-unit>
        <trans-unit id="55dedfb95373873760b0ed9625c82cb35531172a" translate="yes" xml:space="preserve">
          <source>fish waits for a period after receiving the escape character, to determine whether it is standalone or part of an escape sequence. While waiting, additional key presses make the escape key behave as a meta key. If no other key presses come in, it is handled as a standalone escape. The waiting period is set to 300 milliseconds (0.3 seconds) in the default key bindings and 10 milliseconds in the vi key bindings. It can be configured by setting the &lt;code&gt;fish_escape_delay_ms&lt;/code&gt; variable to a value between 10 and 5000 ms. It is recommended that this be a universal variable that you set once from an interactive session.</source>
          <target state="translated">피쉬는 이스케이프 문자를받은 후 일정 시간 동안 기다렸다가 독립형인지 이스케이프 시퀀스의 일부인지 확인합니다. 기다리는 동안 추가 키를 누르면 이스케이프 키가 메타 키처럼 동작합니다. 다른 키를 누르지 않으면 독립형 이스케이프로 처리됩니다. 대기 시간은 기본 키 바인딩에서 300 밀리 초 (0.3 초)로 설정되고 vi 키 바인딩에서 10 밀리 초로 설정됩니다. &lt;code&gt;fish_escape_delay_ms&lt;/code&gt; 변수를 10 ~ 5000ms 사이의 값 으로 설정하여 구성 할 수 있습니다 . 이는 대화식 세션에서 한 번 설정 한 범용 변수 인 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="baba6f248a72657be16047fe4da7199bc44ea8e3" translate="yes" xml:space="preserve">
          <source>fish_breakpoint_prompt</source>
          <target state="translated">fish_breakpoint_prompt</target>
        </trans-unit>
        <trans-unit id="d7bd245d8c242e03fae1578420c74d8093b0ee04" translate="yes" xml:space="preserve">
          <source>fish_breakpoint_prompt - define the appearance of the command line prompt when in the context of a `breakpoint` command</source>
          <target state="translated">fish_breakpoint_prompt-`breakpoint` 명령의 맥락에서 명령 행 프롬프트의 모양을 정의</target>
        </trans-unit>
        <trans-unit id="5a3fc1d157b0191f6866ceecc3630a982089cde4" translate="yes" xml:space="preserve">
          <source>fish_config</source>
          <target state="translated">fish_config</target>
        </trans-unit>
        <trans-unit id="183a6fdb6a00d86295de833100112576b1cb4834" translate="yes" xml:space="preserve">
          <source>fish_config - start the web-based configuration interface</source>
          <target state="translated">fish_config-웹 기반 구성 인터페이스 시작</target>
        </trans-unit>
        <trans-unit id="2397e0dc3855f2a5c3c894e107875e26a08a4480" translate="yes" xml:space="preserve">
          <source>fish_indent</source>
          <target state="translated">fish_indent</target>
        </trans-unit>
        <trans-unit id="c6e19f4ee30f4e23e4160409b9be9c8d16942cd4" translate="yes" xml:space="preserve">
          <source>fish_indent - indenter and prettifier</source>
          <target state="translated">fish_indent-들여 쓰기 및 prettifier</target>
        </trans-unit>
        <trans-unit id="127fb90e55ea67e053d705088a841052da6eef7c" translate="yes" xml:space="preserve">
          <source>fish_key_reader</source>
          <target state="translated">fish_key_reader</target>
        </trans-unit>
        <trans-unit id="69a0ebb11cb1a759ede45515c0024c4ec8c9ee18" translate="yes" xml:space="preserve">
          <source>fish_key_reader - explore what characters keyboard keys send</source>
          <target state="translated">fish_key_reader-키보드 키가 보내는 문자 탐색</target>
        </trans-unit>
        <trans-unit id="b07df081e3eda23a685e0d24569437ba4ab4a6ff" translate="yes" xml:space="preserve">
          <source>fish_mode_prompt</source>
          <target state="translated">fish_mode_prompt</target>
        </trans-unit>
        <trans-unit id="753b48a0cc344eee0593915eb34429a7626e167e" translate="yes" xml:space="preserve">
          <source>fish_mode_prompt - define the appearance of the mode indicator</source>
          <target state="translated">fish_mode_prompt-모드 표시기의 모양을 정의합니다</target>
        </trans-unit>
        <trans-unit id="3c9b15ad3294d2aa5aa52ac9e2632d2eae53e420" translate="yes" xml:space="preserve">
          <source>fish_opt</source>
          <target state="translated">fish_opt</target>
        </trans-unit>
        <trans-unit id="543365accaae619eee02dcae6dea132a363085b7" translate="yes" xml:space="preserve">
          <source>fish_opt - create an option spec for the argparse command</source>
          <target state="translated">fish_opt-argparse 명령에 대한 옵션 스펙 작성</target>
        </trans-unit>
        <trans-unit id="6501c27fb0858cd3f54b84ab4f9f296d0dda8c9c" translate="yes" xml:space="preserve">
          <source>fish_prompt</source>
          <target state="translated">fish_prompt</target>
        </trans-unit>
        <trans-unit id="cd788e8b2b186c68bc7b4e563896df245043a589" translate="yes" xml:space="preserve">
          <source>fish_prompt - define the appearance of the command line prompt</source>
          <target state="translated">fish_prompt-명령 행 프롬프트의 모양을 정의합니다</target>
        </trans-unit>
        <trans-unit id="f78d4c9641a64c769e933588d8994ca394327414" translate="yes" xml:space="preserve">
          <source>fish_right_prompt</source>
          <target state="translated">fish_right_prompt</target>
        </trans-unit>
        <trans-unit id="4f1afbb85b31538c97624a72a30d55414589b49a" translate="yes" xml:space="preserve">
          <source>fish_right_prompt - define the appearance of the right-side command line prompt</source>
          <target state="translated">fish_right_prompt-오른쪽 명령 줄 프롬프트의 모양을 정의합니다</target>
        </trans-unit>
        <trans-unit id="8b339b0c658d3c4228467574152fa75f2375b32e" translate="yes" xml:space="preserve">
          <source>fish_update_completions</source>
          <target state="translated">fish_update_completions</target>
        </trans-unit>
        <trans-unit id="90c9f004ea4a216adfd9c72340b8112edb288283" translate="yes" xml:space="preserve">
          <source>fish_update_completions - Update completions using manual pages</source>
          <target state="translated">fish_update_completions-매뉴얼 페이지를 사용한 업데이트 완료</target>
        </trans-unit>
        <trans-unit id="f76de474163a63c296945fcd9d696f36636c8aef" translate="yes" xml:space="preserve">
          <source>fish_vi_mode</source>
          <target state="translated">fish_vi_mode</target>
        </trans-unit>
        <trans-unit id="410186a970357c931e2a7dec30a37b5a1e74ebea" translate="yes" xml:space="preserve">
          <source>fish_vi_mode - Enable vi mode</source>
          <target state="translated">fish_vi_mode-vi 모드 사용</target>
        </trans-unit>
        <trans-unit id="43eef9a62abb8b1e1654f8a890aae054abffa82b" translate="yes" xml:space="preserve">
          <source>for</source>
          <target state="translated">for</target>
        </trans-unit>
        <trans-unit id="6aa32fad737b7aa5ceaccf76038f5bbfb35631a8" translate="yes" xml:space="preserve">
          <source>for - perform a set of commands multiple times.</source>
          <target state="translated">for-일련의 명령을 여러 번 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="c039c214c3b0d96340e4ef72f733eedd0388e42d" translate="yes" xml:space="preserve">
          <source>funced</source>
          <target state="translated">funced</target>
        </trans-unit>
        <trans-unit id="0816bc375ac09bd74efea8d7a85a93023e8ffa5a" translate="yes" xml:space="preserve">
          <source>funced - edit a function interactively</source>
          <target state="translated">funced-대화식으로 함수 편집</target>
        </trans-unit>
        <trans-unit id="3bc1aee64f9e2c4c5efada178ad6165cab6377cc" translate="yes" xml:space="preserve">
          <source>funcsave</source>
          <target state="translated">funcsave</target>
        </trans-unit>
        <trans-unit id="2f69307df7e91d4902cb35c04dd61609789e8b05" translate="yes" xml:space="preserve">
          <source>funcsave - save the definition of a function to the user's autoload directory</source>
          <target state="translated">funcsave-함수의 정의를 사용자의 자동로드 디렉토리에 저장</target>
        </trans-unit>
        <trans-unit id="c218e39efa2e1aae69f39d2054528369ce1e1f46" translate="yes" xml:space="preserve">
          <source>function</source>
          <target state="translated">function</target>
        </trans-unit>
        <trans-unit id="bf41a97c9825ae2e3550fdddcd8aaf42e45d7245" translate="yes" xml:space="preserve">
          <source>function - create a function</source>
          <target state="translated">함수-함수를 만듭니다</target>
        </trans-unit>
        <trans-unit id="2f887def33825e52ffbcca83446cfd6a6f676ff7" translate="yes" xml:space="preserve">
          <source>functions</source>
          <target state="translated">functions</target>
        </trans-unit>
        <trans-unit id="a2dd0c9d390ee256fa9d3c2d2857526a5930b073" translate="yes" xml:space="preserve">
          <source>functions - print or erase functions</source>
          <target state="translated">기능-인쇄 또는 지우기 기능</target>
        </trans-unit>
        <trans-unit id="92005ecf3788faea8346a7919fba0232188561ab" translate="yes" xml:space="preserve">
          <source>help</source>
          <target state="translated">help</target>
        </trans-unit>
        <trans-unit id="90df5c81817176fc99bd4d5ed355b097e8ac84fe" translate="yes" xml:space="preserve">
          <source>help - display fish documentation</source>
          <target state="translated">도움말-물고기 문서 표시</target>
        </trans-unit>
        <trans-unit id="66f79d8a6327c82c9033e6d65ff03322a3766c87" translate="yes" xml:space="preserve">
          <source>history</source>
          <target state="translated">history</target>
        </trans-unit>
        <trans-unit id="9c54bcb9992fb9affc2aedd28a291f6b1a369e0b" translate="yes" xml:space="preserve">
          <source>history - Show and manipulate command history</source>
          <target state="translated">history-명령 기록 표시 및 조작</target>
        </trans-unit>
        <trans-unit id="958f57f57d72a30f329ee5538f21b0257a49a46e" translate="yes" xml:space="preserve">
          <source>if</source>
          <target state="translated">if</target>
        </trans-unit>
        <trans-unit id="f95ea4c87a089d830126713a97723833a9fd76fc" translate="yes" xml:space="preserve">
          <source>if - conditionally execute a command</source>
          <target state="translated">if-조건부 명령 실행</target>
        </trans-unit>
        <trans-unit id="24def2dc36d8c488f6dd73f146437207b25f618c" translate="yes" xml:space="preserve">
          <source>isatty</source>
          <target state="translated">isatty</target>
        </trans-unit>
        <trans-unit id="3cfe607d872677db1789d97ef106886f84f5899b" translate="yes" xml:space="preserve">
          <source>isatty - test if a file descriptor is a tty.</source>
          <target state="translated">isatty-파일 디스크립터가 tty인지 테스트합니다.</target>
        </trans-unit>
        <trans-unit id="638dbc85cd3410c50689528013eccaae778361f3" translate="yes" xml:space="preserve">
          <source>it will print &lt;code&gt;xax xbx xcx&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;xax xbx xcx&lt;/code&gt; 를 인쇄 합니다.</target>
        </trans-unit>
        <trans-unit id="6966922100bf006356af2b9098e6ba3b1c190226" translate="yes" xml:space="preserve">
          <source>jobs</source>
          <target state="translated">jobs</target>
        </trans-unit>
        <trans-unit id="2c0538a731bda1d0b48cf0b71c7f1eea39760d56" translate="yes" xml:space="preserve">
          <source>jobs - print currently running jobs</source>
          <target state="translated">jobs-현재 실행중인 작업을 인쇄</target>
        </trans-unit>
        <trans-unit id="eab8b533a9af65bf25991bce5aab55764e3ca4e8" translate="yes" xml:space="preserve">
          <source>jobs accepts the following switches:</source>
          <target state="translated">작업은 다음 스위치를 허용합니다.</target>
        </trans-unit>
        <trans-unit id="7a488390a939c4795cc1a801e51751d5f25d800d" translate="yes" xml:space="preserve">
          <source>math</source>
          <target state="translated">math</target>
        </trans-unit>
        <trans-unit id="ac55c69e1a4e4deadae82d7d2501bb6e8354689f" translate="yes" xml:space="preserve">
          <source>math - Perform mathematics calculations</source>
          <target state="translated">수학-수학 계산 수행</target>
        </trans-unit>
        <trans-unit id="5788f5d9921db1d9d54ea779e091c82300b105e9" translate="yes" xml:space="preserve">
          <source>nextd</source>
          <target state="translated">nextd</target>
        </trans-unit>
        <trans-unit id="5962cd086d9c9b34c1fe8730983fbd9559aed0f5" translate="yes" xml:space="preserve">
          <source>nextd - move forward through directory history</source>
          <target state="translated">nextd-디렉토리 히스토리를 통해 앞으로 이동</target>
        </trans-unit>
        <trans-unit id="d058f2cdd7781f829008a74cc23a43186eacb161" translate="yes" xml:space="preserve">
          <source>no output.</source>
          <target state="translated">출력이 없습니다.</target>
        </trans-unit>
        <trans-unit id="557f255516719ea16f8f4a0aae1166054e2c9b43" translate="yes" xml:space="preserve">
          <source>not</source>
          <target state="translated">not</target>
        </trans-unit>
        <trans-unit id="4575a330b9abc396835c8ef87416bed7db17b511" translate="yes" xml:space="preserve">
          <source>not - negate the exit status of a job</source>
          <target state="translated">not-작업 종료 상태를 무효화</target>
        </trans-unit>
        <trans-unit id="5fc7e38bffe00ca46add89145464a2eaf759d5c2" translate="yes" xml:space="preserve">
          <source>open</source>
          <target state="translated">open</target>
        </trans-unit>
        <trans-unit id="199b395ad03deff5d4ae7fbee3ed860eb83c6145" translate="yes" xml:space="preserve">
          <source>open - open file in its default application</source>
          <target state="translated">open-기본 응용 프로그램에서 파일 열기</target>
        </trans-unit>
        <trans-unit id="1758356db21759f7c5a0da9b4dd1db8fd6feab3f" translate="yes" xml:space="preserve">
          <source>or</source>
          <target state="translated">or</target>
        </trans-unit>
        <trans-unit id="711125b2ab4f03f077b0f47796a68a231b18fde3" translate="yes" xml:space="preserve">
          <source>or - conditionally execute a command</source>
          <target state="translated">또는-조건부 명령 실행</target>
        </trans-unit>
        <trans-unit id="4a4fca309e453918d1fa9832f4ef19832f32f1de" translate="yes" xml:space="preserve">
          <source>or opted into globally for a user:</source>
          <target state="translated">또는 전 세계적으로 사용자를 선택했습니다.</target>
        </trans-unit>
        <trans-unit id="bd053f79a6a0b97eca270388d4266f6cdc2e5d1f" translate="yes" xml:space="preserve">
          <source>popd</source>
          <target state="translated">popd</target>
        </trans-unit>
        <trans-unit id="c0ad7ae5d6dea353b86b7975b175fb7ec7a5b0d8" translate="yes" xml:space="preserve">
          <source>popd - move through directory stack</source>
          <target state="translated">popd-디렉토리 스택을 통해 이동</target>
        </trans-unit>
        <trans-unit id="501bed2ce7870bcc5b0594fe851ae7aafaa0d983" translate="yes" xml:space="preserve">
          <source>press &lt;code&gt;Ctrl-C&lt;/code&gt; twice, or</source>
          <target state="translated">&lt;code&gt;Ctrl-C&lt;/code&gt; 를 두 번 누르 거나</target>
        </trans-unit>
        <trans-unit id="7dc7f09beed59586cbda067c6eeb7b7166812ad2" translate="yes" xml:space="preserve">
          <source>press &lt;code&gt;Ctrl-D&lt;/code&gt; twice, or</source>
          <target state="translated">&lt;code&gt;Ctrl-D&lt;/code&gt; 를 두 번 누르 거나</target>
        </trans-unit>
        <trans-unit id="e291f27c814229dc2eb10fa92c9b8c4185958322" translate="yes" xml:space="preserve">
          <source>prevd</source>
          <target state="translated">prevd</target>
        </trans-unit>
        <trans-unit id="f7c05f49b7608d19659229d1610a7b144fd04131" translate="yes" xml:space="preserve">
          <source>prevd - move backward through directory history</source>
          <target state="translated">prevd-디렉토리 기록을 통해 뒤로 이동</target>
        </trans-unit>
        <trans-unit id="df39b4caf493869772ff3a0f95cca6a9ae7934dc" translate="yes" xml:space="preserve">
          <source>printf</source>
          <target state="translated">printf</target>
        </trans-unit>
        <trans-unit id="3c6a47d2ffca0ad0d4a07143fcfbfd3c2bf900e7" translate="yes" xml:space="preserve">
          <source>printf - display text according to a format string</source>
          <target state="translated">printf-형식 문자열에 따라 텍스트를 표시</target>
        </trans-unit>
        <trans-unit id="21999975d6629ee4bcf6c7777ee78ef2dde68352" translate="yes" xml:space="preserve">
          <source>printf also knows a number of backslash escapes:</source>
          <target state="translated">printf는 또한 많은 백 슬래시 이스케이프를 알고 있습니다.</target>
        </trans-unit>
        <trans-unit id="f0e9a119bdd370e572983792f8da0fd600bbb244" translate="yes" xml:space="preserve">
          <source>printf formats the string FORMAT with ARGUMENT, and displays the result.</source>
          <target state="translated">printf는 문자열 FORMAT을 ARGUMENT로 형식화하고 결과를 표시합니다.</target>
        </trans-unit>
        <trans-unit id="03b62a0fc91ac76f534c8506377fd0cd7094b326" translate="yes" xml:space="preserve">
          <source>prompt_pwd</source>
          <target state="translated">prompt_pwd</target>
        </trans-unit>
        <trans-unit id="379685f1a28ec5f5585e4ea14e8526590620679f" translate="yes" xml:space="preserve">
          <source>prompt_pwd - Print pwd suitable for prompt</source>
          <target state="translated">prompt_pwd-프롬프트에 적합한 pwd 인쇄</target>
        </trans-unit>
        <trans-unit id="a140601076b214970f21dd77e03c7939cd93ecdc" translate="yes" xml:space="preserve">
          <source>prompt_pwd is a function to print the current working directory in a way suitable for prompts. It will replace the home directory with &quot;~&quot; and shorten every path component but the last to a default of one character.</source>
          <target state="translated">prompt_pwd는 프롬프트에 적합한 방식으로 현재 작업 디렉토리를 인쇄하는 기능입니다. 홈 디렉토리를 &quot;~&quot;로 바꾸고 모든 경로 구성 요소를 줄이지 만 마지막 한 문자는 기본값으로 줄입니다.</target>
        </trans-unit>
        <trans-unit id="9afd2538d3d4ffb696f4dcdd4ab6baadf04ff522" translate="yes" xml:space="preserve">
          <source>psub</source>
          <target state="translated">psub</target>
        </trans-unit>
        <trans-unit id="63fbf23d9d9b481ea407c815c90933057897af4b" translate="yes" xml:space="preserve">
          <source>psub - perform process substitution</source>
          <target state="translated">psub-프로세스 대체 수행</target>
        </trans-unit>
        <trans-unit id="ca99455ec63652d0ac9ec250727ee0c6c910786e" translate="yes" xml:space="preserve">
          <source>pushd</source>
          <target state="translated">pushd</target>
        </trans-unit>
        <trans-unit id="9160b1d55f9fa10d249ec7b308dccac953b32fc0" translate="yes" xml:space="preserve">
          <source>pushd - push directory to directory stack</source>
          <target state="translated">푸시-디렉토리를 디렉토리 스택으로 푸시</target>
        </trans-unit>
        <trans-unit id="37fa265330ad83eaa879efb1e2db6380896cf639" translate="yes" xml:space="preserve">
          <source>pwd</source>
          <target state="translated">pwd</target>
        </trans-unit>
        <trans-unit id="3f4e967878bd5e1bb4a87ca851b714379daca044" translate="yes" xml:space="preserve">
          <source>pwd - output the current working directory</source>
          <target state="translated">pwd-현재 작업 디렉토리를 출력</target>
        </trans-unit>
        <trans-unit id="a415ab5cc17c8c093c015ccdb7e552aee7911aa4" translate="yes" xml:space="preserve">
          <source>random</source>
          <target state="translated">random</target>
        </trans-unit>
        <trans-unit id="a2268607239de0e6afadb64003588824de27a1ad" translate="yes" xml:space="preserve">
          <source>random - generate random number</source>
          <target state="translated">난수-난수 생성</target>
        </trans-unit>
        <trans-unit id="a7afddb68260a60f86c02a021efba7f216c2e7cf" translate="yes" xml:space="preserve">
          <source>read</source>
          <target state="translated">read</target>
        </trans-unit>
        <trans-unit id="02d0fa56be4fca5d7cc0c6db5a7aa370743eb4ff" translate="yes" xml:space="preserve">
          <source>read - read line of input into variables</source>
          <target state="translated">read-입력 행을 변수로 읽습니다.</target>
        </trans-unit>
        <trans-unit id="ff2b5744be5fceda4fc467fda551bcbf199f8fa0" translate="yes" xml:space="preserve">
          <source>realpath</source>
          <target state="translated">realpath</target>
        </trans-unit>
        <trans-unit id="2caa95ad63632ed3825a317f46514c851816d5ab" translate="yes" xml:space="preserve">
          <source>realpath - Convert a path to an absolute path without symlinks</source>
          <target state="translated">realpath-심볼릭 링크없이 경로를 절대 경로로 변환</target>
        </trans-unit>
        <trans-unit id="63143b6f8007b98c53ca2149822777b3566f9241" translate="yes" xml:space="preserve">
          <source>return</source>
          <target state="translated">return</target>
        </trans-unit>
        <trans-unit id="288b5d6d1a89a6e706dfc7486e06e4a8d8078410" translate="yes" xml:space="preserve">
          <source>return - stop the current inner function</source>
          <target state="translated">return-현재 내부 함수를 중지</target>
        </trans-unit>
        <trans-unit id="65c10dc3549fe07424148a8a4790a3341ecbc253" translate="yes" xml:space="preserve">
          <source>set</source>
          <target state="translated">set</target>
        </trans-unit>
        <trans-unit id="063c17e14f7627ded7c57ede98e0f6ca9045fc66" translate="yes" xml:space="preserve">
          <source>set - display and change shell variables.</source>
          <target state="translated">set-쉘 변수를 표시하고 변경합니다.</target>
        </trans-unit>
        <trans-unit id="20f7c32664f5d1e0b9c515a18fcf90cdb3c57984" translate="yes" xml:space="preserve">
          <source>set_color</source>
          <target state="translated">set_color</target>
        </trans-unit>
        <trans-unit id="cff11275c6338d2e5dde20951c1557cf0de59d43" translate="yes" xml:space="preserve">
          <source>set_color - set the terminal color</source>
          <target state="translated">set_color-터미널 색상을 설정</target>
        </trans-unit>
        <trans-unit id="828d338a9b04221c9cbe286f50cd389f68de4ecf" translate="yes" xml:space="preserve">
          <source>source</source>
          <target state="translated">source</target>
        </trans-unit>
        <trans-unit id="2f7991a9100c9583f2155802c7350aa74443ed20" translate="yes" xml:space="preserve">
          <source>source - evaluate contents of file.</source>
          <target state="translated">소스-파일의 내용을 평가합니다.</target>
        </trans-unit>
        <trans-unit id="506a7e1ca8d34664e2b86653d70401c523f26553" translate="yes" xml:space="preserve">
          <source>spawns &lt;code&gt;sleep&lt;/code&gt; in the background, and then waits until it finishes.</source>
          <target state="translated">급부상는 &lt;code&gt;sleep&lt;/code&gt; 배경으로, 그리고이 완료 될 때까지 기다립니다.</target>
        </trans-unit>
        <trans-unit id="78dbe5e491bc63d2e79ab65c266d6d41e91f56ff" translate="yes" xml:space="preserve">
          <source>spawns five jobs and &lt;code&gt;hoge&lt;/code&gt; in the background, and then waits until all &lt;code&gt;sleep&lt;/code&gt;s finishes, and doesn't wait for &lt;code&gt;hoge&lt;/code&gt; finishing.</source>
          <target state="translated">5 개의 작업을 생성 하고 백그라운드에서 &lt;code&gt;hoge&lt;/code&gt; 한 다음 모든 &lt;code&gt;sleep&lt;/code&gt; 이 완료 될 때까지 기다렸다가 &lt;code&gt;hoge&lt;/code&gt; 마무리를 기다리지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="b6e22225897433914493a887f4a4f462d9a13ced" translate="yes" xml:space="preserve">
          <source>spawns five jobs in the background, and then waits until all of them finishes.</source>
          <target state="translated">백그라운드에서 5 개의 작업을 생성 한 다음 모든 작업이 완료 될 때까지 기다립니다.</target>
        </trans-unit>
        <trans-unit id="48a3661d846478fa991a825ebd10b78671444b5b" translate="yes" xml:space="preserve">
          <source>status</source>
          <target state="translated">status</target>
        </trans-unit>
        <trans-unit id="420a0e9d08406c887fa9f473fb502e30acd9a336" translate="yes" xml:space="preserve">
          <source>status - query fish runtime information</source>
          <target state="translated">상태-쿼리 물고기 런타임 정보</target>
        </trans-unit>
        <trans-unit id="33a9e6923b5cff6e1c9fb560ddb572a069a669c0" translate="yes" xml:space="preserve">
          <source>stdin and stdout can be redirected via the familiar &amp;lt; and &amp;gt;. stderr is redirected with a &amp;gt;2.</source>
          <target state="translated">stdin 및 stdout은 익숙한 &amp;lt;및&amp;gt;를 통해 리디렉션 될 수 있습니다. stderr은&amp;gt; 2로 리디렉션됩니다.</target>
        </trans-unit>
        <trans-unit id="ecb252044b5ea0f679ee78ec1a12904739e2904d" translate="yes" xml:space="preserve">
          <source>string</source>
          <target state="translated">string</target>
        </trans-unit>
        <trans-unit id="5eb279c348daa58c49a3c45c42799e5a0b7195c1" translate="yes" xml:space="preserve">
          <source>string - manipulate strings</source>
          <target state="translated">문자열-문자열을 조작</target>
        </trans-unit>
        <trans-unit id="b6f0c43f69fad2bd2df597f8c1f9289bf8ebf0a2" translate="yes" xml:space="preserve">
          <source>suspend</source>
          <target state="translated">suspend</target>
        </trans-unit>
        <trans-unit id="0a906b8b4efdea69b1aa7921bd59ea5a07a19f19" translate="yes" xml:space="preserve">
          <source>suspend - suspend the current shell</source>
          <target state="translated">일시 중단-현재 쉘을 일시 중단</target>
        </trans-unit>
        <trans-unit id="01ba7992f85de477e8e630428eb5ed14769f9155" translate="yes" xml:space="preserve">
          <source>switch</source>
          <target state="translated">switch</target>
        </trans-unit>
        <trans-unit id="b6b1294b1f61dc5bf9ee190db20eac07851abf99" translate="yes" xml:space="preserve">
          <source>switch - conditionally execute a block of commands</source>
          <target state="translated">스위치-조건부 명령 블록을 실행</target>
        </trans-unit>
        <trans-unit id="a94a8fe5ccb19ba61c4c0873d391e987982fbbd3" translate="yes" xml:space="preserve">
          <source>test</source>
          <target state="translated">test</target>
        </trans-unit>
        <trans-unit id="4f3107d98473bb39c5345a7b62319a827c9d8057" translate="yes" xml:space="preserve">
          <source>test - perform tests on files and text</source>
          <target state="translated">테스트-파일 및 텍스트에 대한 테스트를 수행</target>
        </trans-unit>
        <trans-unit id="c87a7f7b83a3a58c6087ce1eb24509a6f210bbe6" translate="yes" xml:space="preserve">
          <source>the function description minimally escaped so it is a single line or &lt;code&gt;n/a&lt;/code&gt; if the function isn't defined.</source>
          <target state="translated">한 행하므로 또는 함수 설명 최소한 탈출 &lt;code&gt;n/a&lt;/code&gt; 함수가 정의되지 않은 경우.</target>
        </trans-unit>
        <trans-unit id="02aa698783c53dd6998a194b4ec93ca8e6192a89" translate="yes" xml:space="preserve">
          <source>the line number within the file or zero if not applicable,</source>
          <target state="translated">파일 내 줄 번호 또는 해당되지 않는 경우 0</target>
        </trans-unit>
        <trans-unit id="d326199cf56e0ae280f8a9fda92ba199137f5b06" translate="yes" xml:space="preserve">
          <source>the pathname as already described,</source>
          <target state="translated">이미 설명한 경로 이름</target>
        </trans-unit>
        <trans-unit id="93fde051556cb8919a6c75036bae40f55a1a1718" translate="yes" xml:space="preserve">
          <source>to change this prompt see &lt;a href=&quot;#tut_prompt&quot;&gt;how to change your prompt&lt;/a&gt;</source>
          <target state="translated">이 프롬프트를 변경하려면 프롬프트 &lt;a href=&quot;#tut_prompt&quot;&gt;를 변경하는 방법을&lt;/a&gt; 참조하십시오</target>
        </trans-unit>
        <trans-unit id="b60b004f5d8183032d2f3fcf34a581edbdea5c61" translate="yes" xml:space="preserve">
          <source>to switch to fish permanently see &lt;a href=&quot;#tut_switching_to_fish&quot;&gt;switch your default shell to fish&lt;/a&gt;</source>
          <target state="translated">물고기로 영구적으로 전환하려면 &lt;a href=&quot;#tut_switching_to_fish&quot;&gt;기본 쉘을 물고기&lt;/a&gt; 로 전환을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="e6d307367af5382983ed0d6888c8e3e045355281" translate="yes" xml:space="preserve">
          <source>trap</source>
          <target state="translated">trap</target>
        </trans-unit>
        <trans-unit id="3abaf5ffe5c75ece5fd52f452cf4a7f90fed7421" translate="yes" xml:space="preserve">
          <source>trap - perform an action when the shell receives a signal</source>
          <target state="translated">트랩-쉘이 신호를 수신 할 때 동작 수행</target>
        </trans-unit>
        <trans-unit id="5ffe533b830f08a0326348a9160afafc8ada44db" translate="yes" xml:space="preserve">
          <source>true</source>
          <target state="translated">true</target>
        </trans-unit>
        <trans-unit id="10b80755987d5e861fcb4c74925a714ba8dce054" translate="yes" xml:space="preserve">
          <source>true - return a successful result</source>
          <target state="translated">true-성공적인 결과를 반환</target>
        </trans-unit>
        <trans-unit id="d0a3e7f81a9885e99049d1cae0336d269d5e47a9" translate="yes" xml:space="preserve">
          <source>type</source>
          <target state="translated">type</target>
        </trans-unit>
        <trans-unit id="fa189f6932e07966b2945f9c641067e1250a2bb7" translate="yes" xml:space="preserve">
          <source>type - indicate how a command would be interpreted</source>
          <target state="translated">type-명령 해석 방법을 나타냅니다</target>
        </trans-unit>
        <trans-unit id="6747212f18c8e5d826c489535a7ede3cf68eb31d" translate="yes" xml:space="preserve">
          <source>type &lt;code&gt;exit&lt;/code&gt;, or</source>
          <target state="translated">&lt;code&gt;exit&lt;/code&gt; 를 입력하십시오 . 또는</target>
        </trans-unit>
        <trans-unit id="8f17cfc3a44394fc7a0575f4eb71f3dbd5d29eb7" translate="yes" xml:space="preserve">
          <source>type &lt;code&gt;quit&lt;/code&gt;</source>
          <target state="translated">유형은 &lt;code&gt;quit&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="6e5e5b45aaa91b76b5567fa66b0d05fe7289fd30" translate="yes" xml:space="preserve">
          <source>ulimit</source>
          <target state="translated">ulimit</target>
        </trans-unit>
        <trans-unit id="6f97e285ade4768f7a97feb604606ad49d5d73d5" translate="yes" xml:space="preserve">
          <source>ulimit - set or get resource usage limits</source>
          <target state="translated">ulimit-자원 사용 제한 설정 또는 가져 오기</target>
        </trans-unit>
        <trans-unit id="4b824f445e8d64ec6f262547c18a3ab02a6fd22c" translate="yes" xml:space="preserve">
          <source>umask</source>
          <target state="translated">umask</target>
        </trans-unit>
        <trans-unit id="40ce63190ce7b180322f127f1880704153f8b29a" translate="yes" xml:space="preserve">
          <source>umask - set or get the file creation mode mask</source>
          <target state="translated">umask-파일 작성 모드 마스크 설정 또는 가져 오기</target>
        </trans-unit>
        <trans-unit id="ed6354b5f4780263c94651c766c76e339fe47f1e" translate="yes" xml:space="preserve">
          <source>vared</source>
          <target state="translated">vared</target>
        </trans-unit>
        <trans-unit id="095ed909fb13c4817a8aeb74a62b6468a254ca8d" translate="yes" xml:space="preserve">
          <source>vared - interactively edit the value of an environment variable</source>
          <target state="translated">vared-환경 변수 값을 대화식으로 편집</target>
        </trans-unit>
        <trans-unit id="daaad336276d15594d0e765f96c17cd746bf4971" translate="yes" xml:space="preserve">
          <source>wait</source>
          <target state="translated">wait</target>
        </trans-unit>
        <trans-unit id="5dc68f4d1dfb375d9f030f65dae3398df707ba38" translate="yes" xml:space="preserve">
          <source>wait - wait for jobs to complete</source>
          <target state="translated">대기-작업이 완료 될 때까지 기다립니다</target>
        </trans-unit>
        <trans-unit id="daca2c7abafe19aed94611021e5a4bbeb2584565" translate="yes" xml:space="preserve">
          <source>where &lt;code&gt;__fish_contains_opt&lt;/code&gt; is a function that checks the command line buffer for the presence of a specified set of options.</source>
          <target state="translated">여기서 &lt;code&gt;__fish_contains_opt&lt;/code&gt; 는 지정된 옵션 세트가 있는지 명령 행 버퍼를 검사하는 기능입니다.</target>
        </trans-unit>
        <trans-unit id="489a6e620233cc9d22541565dff2f3ac8a1d932a" translate="yes" xml:space="preserve">
          <source>which is logically equivalent to the following:</source>
          <target state="translated">논리적으로 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="6517f89c46c3f0d6db9cb009b8c7d1f98c371fa0" translate="yes" xml:space="preserve">
          <source>while</source>
          <target state="translated">while</target>
        </trans-unit>
        <trans-unit id="1ff56800352145ff9f9300f91d5ae15e85c17b92" translate="yes" xml:space="preserve">
          <source>while - perform a command multiple times</source>
          <target state="translated">동안-여러 번 명령을 수행</target>
        </trans-unit>
        <trans-unit id="a605898fdfaef482c78ebc3e9e8274f6d32b1cba" translate="yes" xml:space="preserve">
          <source>will attempt to build the fish program, and any errors will be shown using the less pager.</source>
          <target state="translated">물고기 프로그램을 구축하려고 시도하고 적은 호출기를 사용하여 오류가 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="e99b731e0ff1040d87b00c1c061573852dcca4b4" translate="yes" xml:space="preserve">
          <source>will call the &lt;code&gt;cat&lt;/code&gt; program with the parameter 'foo.txt', which will print the contents of the file 'foo.txt'. The contents of foo.txt will then be filtered through the program 'head', which will pass on the first ten lines of the file to the screen. For more information on how to combine commands through pipes, read the manual pages of the commands you want to use using the &lt;code&gt;man&lt;/code&gt; command. If you want to find out more about the &lt;code&gt;cat&lt;/code&gt; program, type &lt;code&gt;man cat&lt;/code&gt;.</source>
          <target state="translated">'foo.txt'파일의 내용을 인쇄하는 'foo.txt'매개 변수를 사용 하여 &lt;code&gt;cat&lt;/code&gt; 프로그램을 호출합니다 . 그런 다음 foo.txt의 내용은 'head'프로그램을 통해 필터링되며 파일의 처음 10 줄을 화면으로 전달합니다. 파이프를 통해 명령을 결합하는 방법에 대한 자세한 정보는 &lt;code&gt;man&lt;/code&gt; 명령 을 사용하여 사용하려는 명령의 매뉴얼 페이지를 읽으십시오 . &lt;code&gt;cat&lt;/code&gt; 프로그램 에 대한 자세한 내용을 보려면 &lt;code&gt;man cat&lt;/code&gt; 을 입력하십시오 .</target>
        </trans-unit>
        <trans-unit id="ef5f8dfda25d3d985781b69dcb1b285ae55e913d" translate="yes" xml:space="preserve">
          <source>will run the &lt;code&gt;ls&lt;/code&gt; command, using the &lt;code&gt;-l&lt;/code&gt; option, while passing on any additional files and switches to &lt;code&gt;ls&lt;/code&gt;.</source>
          <target state="translated">추가 파일을 전달하고 &lt;code&gt;ls&lt;/code&gt; 로 전환하는 동안 &lt;code&gt;-l&lt;/code&gt; 옵션을 사용하여 &lt;code&gt;ls&lt;/code&gt; 명령 을 실행합니다 .</target>
        </trans-unit>
        <trans-unit id="a80dacfdcbb824e4242afb200ba1d4cc653f254c" translate="yes" xml:space="preserve">
          <source>will start the emacs text editor in the background.</source>
          <target state="translated">백그라운드에서 emacs 텍스트 편집기를 시작합니다.</target>
        </trans-unit>
        <trans-unit id="875af98e94b5a2e2425bd92b03433e7c0f34dfa0" translate="yes" xml:space="preserve">
          <source>would remove the two files 'cumbersome' and 'filename.txt'.</source>
          <target state="translated">두 개의 파일 'cumbersome'과 'filename.txt'를 제거합니다.</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
