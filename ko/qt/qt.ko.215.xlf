<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="qt">
    <body>
      <group id="qt">
        <trans-unit id="711a9f71466771c6e4aade7928b9960c7cefd54f" translate="yes" xml:space="preserve">
          <source>When performing an address lookup, zero or more records will be returned. Each record is represented by a &lt;a href=&quot;qdnshostaddressrecord&quot;&gt;QDnsHostAddressRecord&lt;/a&gt; instance.</source>
          <target state="translated">주소 조회를 수행 할 때 0 개 이상의 레코드가 반환됩니다. 각 레코드는 &lt;a href=&quot;qdnshostaddressrecord&quot;&gt;QDnsHostAddressRecord&lt;/a&gt; 인스턴스로 표시됩니다 .</target>
        </trans-unit>
        <trans-unit id="63db06c50e58a3513cea1497dec1ed7741831f0b" translate="yes" xml:space="preserve">
          <source>When performing drawing using &lt;a href=&quot;qpainter&quot;&gt;QPainter&lt;/a&gt; only, it is also possible to perform the painting like it is done for ordinary widgets: by reimplementing &lt;a href=&quot;qopenglwidget#paintEvent&quot;&gt;paintEvent&lt;/a&gt;().</source>
          <target state="translated">&lt;a href=&quot;qpainter&quot;&gt;QPainter&lt;/a&gt; 만 사용하여 그리기를 수행 할 때 &lt;a href=&quot;qopenglwidget#paintEvent&quot;&gt;paintEvent&lt;/a&gt; () 를 다시 구현하여 일반 위젯에서와 같이 페인팅을 수행 할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="38db5be01962103a3cc7ed36e0dd26d7c49283ec" translate="yes" xml:space="preserve">
          <source>When placed into a &lt;code&gt;.qml&lt;/code&gt; file and loaded by the QML engine, the above code creates a &lt;a href=&quot;qml-qtquick-rectangle&quot;&gt;Rectangle&lt;/a&gt; object using the &lt;a href=&quot;qml-qtquick-rectangle&quot;&gt;Rectangle&lt;/a&gt; type supplied by the &lt;code&gt;QtQuick&lt;/code&gt; module:</source>
          <target state="translated">&lt;code&gt;.qml&lt;/code&gt; 파일에 배치 하고 QML 엔진에 의해로드되면 위 코드 는 &lt;code&gt;QtQuick&lt;/code&gt; 모듈에서 제공 하는 &lt;a href=&quot;qml-qtquick-rectangle&quot;&gt;Rectangle&lt;/a&gt; 유형을 사용하여 &lt;a href=&quot;qml-qtquick-rectangle&quot;&gt;Rectangle&lt;/a&gt; 객체를 만듭니다 .</target>
        </trans-unit>
        <trans-unit id="6927c0eac9201c4bf4c31b692534ebe1bbcfa831" translate="yes" xml:space="preserve">
          <source>When populating a layout, the widgets are added to an internal list. The &lt;a href=&quot;qlayout#indexOf&quot;&gt;indexOf&lt;/a&gt;() function returns the index of a widget in that list. The widgets can either be added to the end of the list using the &lt;a href=&quot;qstackedlayout#addWidget&quot;&gt;addWidget&lt;/a&gt;() function, or inserted at a given index using the &lt;a href=&quot;qstackedlayout#insertWidget&quot;&gt;insertWidget&lt;/a&gt;() function. The &lt;a href=&quot;qlayout#removeWidget&quot;&gt;removeWidget&lt;/a&gt;() function removes the widget at the given index from the layout. The number of widgets contained in the layout, can be obtained using the &lt;a href=&quot;qstackedlayout#count-prop&quot;&gt;count&lt;/a&gt;() function.</source>
          <target state="translated">레이아웃을 채울 때 위젯이 내부 목록에 추가됩니다. &lt;a href=&quot;qlayout#indexOf&quot;&gt;같이 IndexOf&lt;/a&gt; () 함수는 목록에서 위젯의 인덱스를 반환합니다. 위젯은 &lt;a href=&quot;qstackedlayout#addWidget&quot;&gt;addWidget&lt;/a&gt; () 함수를 사용하여 목록의 끝에 추가 하거나 &lt;a href=&quot;qstackedlayout#insertWidget&quot;&gt;insertWidget&lt;/a&gt; () 함수를 사용하여 지정된 색인에 삽입 할 수 있습니다. &lt;a href=&quot;qlayout#removeWidget&quot;&gt;removeWidget&lt;/a&gt; () 함수는 레이아웃에서 지정된 인덱스 위젯을 제거한다. 레이아웃에 포함 된 위젯 수는 &lt;a href=&quot;qstackedlayout#count-prop&quot;&gt;count&lt;/a&gt; () 함수를 사용하여 얻을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="9c28b221f7e83baed059e2a307e039e7c948b005" translate="yes" xml:space="preserve">
          <source>When populating a stacked widget, the widgets are added to an internal list. The &lt;a href=&quot;qstackedwidget#indexOf&quot;&gt;indexOf&lt;/a&gt;() function returns the index of a widget in that list. The widgets can either be added to the end of the list using the &lt;a href=&quot;qstackedwidget#addWidget&quot;&gt;addWidget&lt;/a&gt;() function, or inserted at a given index using the &lt;a href=&quot;qstackedwidget#insertWidget&quot;&gt;insertWidget&lt;/a&gt;() function. The &lt;a href=&quot;qstackedwidget#removeWidget&quot;&gt;removeWidget&lt;/a&gt;() function removes a widget from the stacked widget. The number of widgets contained in the stacked widget can be obtained using the &lt;a href=&quot;qstackedwidget#count-prop&quot;&gt;count&lt;/a&gt;() function.</source>
          <target state="translated">누적 위젯을 채울 때 위젯이 내부 목록에 추가됩니다. &lt;a href=&quot;qstackedwidget#indexOf&quot;&gt;같이 IndexOf&lt;/a&gt; () 함수는 목록에서 위젯의 인덱스를 반환합니다. 위젯은 &lt;a href=&quot;qstackedwidget#addWidget&quot;&gt;addWidget&lt;/a&gt; () 함수를 사용하여 목록 끝에 추가 하거나 &lt;a href=&quot;qstackedwidget#insertWidget&quot;&gt;insertWidget&lt;/a&gt; () 함수를 사용하여 지정된 색인에 삽입 할 수 있습니다. &lt;a href=&quot;qstackedwidget#removeWidget&quot;&gt;removeWidget&lt;/a&gt; () 함수는 누적 된 위젯에서 위젯을 제거한다. 누적 된 위젯에 포함 된 위젯 수는 &lt;a href=&quot;qstackedwidget#count-prop&quot;&gt;count&lt;/a&gt; () 함수를 사용하여 얻을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="543155192f84c64b5b7246452a09145b18b3004c" translate="yes" xml:space="preserve">
          <source>When popup windows are visible, this property is &lt;code&gt;true&lt;/code&gt; for both the active window</source>
          <target state="translated">팝업 창이 표시되면이 속성은 활성 창 모두에 대해 &lt;code&gt;true&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="bf9f03d6670f0731b056deb6a40d087fcc1eaf19" translate="yes" xml:space="preserve">
          <source>When positioning a menu with &lt;a href=&quot;qmenu#exec&quot;&gt;exec&lt;/a&gt;() or &lt;a href=&quot;qmenu#popup&quot;&gt;popup&lt;/a&gt;(), bear in mind that you cannot rely on the menu's current &lt;a href=&quot;qwidget#size-prop&quot;&gt;size&lt;/a&gt;(). For performance reasons, the menu adapts its size only when necessary. So in many cases, the size before and after the show is different. Instead, use &lt;a href=&quot;qmenu#sizeHint&quot;&gt;sizeHint&lt;/a&gt;() which calculates the proper size depending on the menu's current contents.</source>
          <target state="translated">&lt;a href=&quot;qmenu#exec&quot;&gt;exec&lt;/a&gt; () 또는 &lt;a href=&quot;qmenu#popup&quot;&gt;popup&lt;/a&gt; ()을 사용 하여 메뉴를 배치 할 때 메뉴의 현재 &lt;a href=&quot;qwidget#size-prop&quot;&gt;크기&lt;/a&gt; () 에 의존 할 수 없다는 점을 명심하십시오 . 성능상의 이유로 메뉴는 필요한 경우에만 크기를 조정합니다. 따라서 많은 경우 쇼 전후의 크기가 다릅니다. 대신 메뉴의 현재 내용에 따라 적절한 크기를 계산하는 &lt;a href=&quot;qmenu#sizeHint&quot;&gt;sizeHint&lt;/a&gt; ()를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="d446cf9e4868843729e697b92b7ac122b7540da1" translate="yes" xml:space="preserve">
          <source>When positioning a menu with &lt;a href=&quot;qmenu#exec&quot;&gt;exec&lt;/a&gt;() or popup(), bear in mind that you cannot rely on the menu's current &lt;a href=&quot;qwidget#size-prop&quot;&gt;size&lt;/a&gt;(). For performance reasons, the menu adapts its size only when necessary, so in many cases, the size before and after the show is different. Instead, use &lt;a href=&quot;qmenu#sizeHint&quot;&gt;sizeHint&lt;/a&gt;() which calculates the proper size depending on the menu's current contents.</source>
          <target state="translated">&lt;a href=&quot;qmenu#exec&quot;&gt;exec&lt;/a&gt; () 또는 popup () 으로 메뉴를 배치 할 때 메뉴의 현재 &lt;a href=&quot;qwidget#size-prop&quot;&gt;크기&lt;/a&gt; () 에 의존 할 수 없다는 점을 명심하십시오 . 성능상의 이유로 메뉴는 필요한 경우에만 크기를 조정하므로 대부분의 경우 쇼 전후 크기가 다릅니다. 대신 메뉴의 현재 내용에 따라 적절한 크기를 계산하는 &lt;a href=&quot;qmenu#sizeHint&quot;&gt;sizeHint&lt;/a&gt; ()를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="b83e6f455038d9e44dcc627b24af2f87bdc39ec9" translate="yes" xml:space="preserve">
          <source>When possible, it is usually better style to disable the &lt;b&gt;Next&lt;/b&gt; or &lt;b&gt;Finish&lt;/b&gt; button (by specifying &lt;a href=&quot;qwizard#mandatory-fields&quot;&gt;mandatory fields&lt;/a&gt; or by reimplementing &lt;a href=&quot;qwizardpage#isComplete&quot;&gt;QWizardPage::isComplete&lt;/a&gt;()) than to reimplement validateCurrentPage().</source>
          <target state="translated">가능한 경우 validateCurrentPage ()를 다시 구현하는 것보다 &lt;a href=&quot;qwizard#mandatory-fields&quot;&gt;필수 필드&lt;/a&gt; 를 지정 하거나 &lt;a href=&quot;qwizardpage#isComplete&quot;&gt;QWizardPage :: isComplete&lt;/a&gt; ()를 다시 구현 하여 &lt;b&gt;Next&lt;/b&gt; 또는 &lt;b&gt;Finish&lt;/b&gt; 버튼 을 비활성화하는 것이 일반적으로 더 좋습니다 .</target>
        </trans-unit>
        <trans-unit id="73d1c2ff7aa2a64e8d25144a78e96a2f710b582a" translate="yes" xml:space="preserve">
          <source>When possible, it is usually better style to disable the &lt;b&gt;Next&lt;/b&gt; or &lt;b&gt;Finish&lt;/b&gt; button (by specifying &lt;a href=&quot;qwizard#mandatory-fields&quot;&gt;mandatory fields&lt;/a&gt; or reimplementing &lt;a href=&quot;qwizardpage#isComplete&quot;&gt;isComplete&lt;/a&gt;()) than to reimplement validatePage().</source>
          <target state="translated">가능한 경우 validatePage ()를 다시 구현하는 것보다 ( &lt;a href=&quot;qwizard#mandatory-fields&quot;&gt;필수 필드&lt;/a&gt; 를 지정 하거나 &lt;a href=&quot;qwizardpage#isComplete&quot;&gt;isComplete&lt;/a&gt; ()을 다시 구현 하여) &lt;b&gt;다음&lt;/b&gt; 또는 &lt;b&gt;완료&lt;/b&gt; 버튼 을 비활성화하는 것이 일반적으로 더 좋습니다 .</target>
        </trans-unit>
        <trans-unit id="4c25870dd84e6151f006f88996bd899f2da5153f" translate="yes" xml:space="preserve">
          <source>When possible, this static function will use the native file dialog and not a &lt;a href=&quot;qfiledialog&quot;&gt;QFileDialog&lt;/a&gt;. On platforms which don't support selecting remote files, Qt will allow to select only local files.</source>
          <target state="translated">가능하면이 정적 함수는 &lt;a href=&quot;qfiledialog&quot;&gt;QFileDialog가&lt;/a&gt; 아닌 기본 파일 대화 상자를 사용합니다 . 원격 파일 선택을 지원하지 않는 플랫폼에서 Qt는 로컬 파일 만 선택할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0b489fbd5401aea28516b412c3104164f51acbe1" translate="yes" xml:space="preserve">
          <source>When posting a custom event to the state machine, you typically also have one or more custom transitions that can be triggered from events of that type. To create such a transition, you subclass &lt;a href=&quot;qabstracttransition&quot;&gt;QAbstractTransition&lt;/a&gt; and reimplement &lt;a href=&quot;qabstracttransition#eventTest&quot;&gt;QAbstractTransition::eventTest&lt;/a&gt;(), where you check if an event matches your event type (and optionally other criteria, e.g. attributes of the event object).</source>
          <target state="translated">상태 시스템에 사용자 지정 이벤트를 게시 할 때 일반적으로 해당 유형의 이벤트에서 트리거 될 수있는 하나 이상의 사용자 지정 전환이 있습니다. 이러한 전환을 만들려면 &lt;a href=&quot;qabstracttransition&quot;&gt;QAbstractTransition&lt;/a&gt; 을 서브 클래 싱 하고 &lt;a href=&quot;qabstracttransition#eventTest&quot;&gt;QAbstractTransition :: eventTest&lt;/a&gt; ()를 다시 구현 하여 이벤트가 이벤트 유형 (및 선택적으로 다른 기준, 예를 들어 이벤트 객체의 속성)과 일치하는지 확인합니다.</target>
        </trans-unit>
        <trans-unit id="c0626bfe8658560f4b9456379db258ae7347f2e4" translate="yes" xml:space="preserve">
          <source>When present in a state set, enables the seamless cubemap texture filtering as provided by the GL_ARB_seamless_cubemap extension (if available).</source>
          <target state="translated">상태 세트에있는 경우 GL_ARB_seamless_cubemap 확장 (제공되는 경우)에서 제공하는 심리스 큐브 맵 텍스처 필터링을 활성화합니다.</target>
        </trans-unit>
        <trans-unit id="dd42c97f91ca6cd533ba12641c6d6512a8021b98" translate="yes" xml:space="preserve">
          <source>When pressing the &quot;Pick Screen Color&quot; button, the cursor changes to a haircross and the colors on the screen are scanned. The user can pick up one by clicking the mouse or the Enter button. Pressing Escape restores the last color selected before entering this mode.</source>
          <target state="translated">&quot;화면 색상 선택&quot;버튼을 누르면 커서가 머리카락 모양으로 바뀌고 화면 색상이 스캔됩니다. 사용자는 마우스 또는 Enter 버튼을 클릭하여 하나를 선택할 수 있습니다. Esc 키를 누르면이 모드로 들어가기 전에 마지막으로 선택한 색상이 복원됩니다.</target>
        </trans-unit>
        <trans-unit id="365ed507c80ed465082d4faf723c11a4f4a529f9" translate="yes" xml:space="preserve">
          <source>When printing directly to a printer on Windows or &lt;a href=&quot;internationalization#macos&quot;&gt;macOS&lt;/a&gt;, &lt;a href=&quot;qprinter&quot;&gt;QPrinter&lt;/a&gt; uses the built-in printer drivers. On X11, &lt;a href=&quot;qprinter&quot;&gt;QPrinter&lt;/a&gt; uses the &lt;a href=&quot;http://www.cups.org/&quot;&gt;Common Unix Printing System (CUPS)&lt;/a&gt; to send PDF output to the printer. As an alternative, the &lt;a href=&quot;qprinter#printProgram&quot;&gt;printProgram&lt;/a&gt;() function can be used to specify the command or utility to use instead of the system default.</source>
          <target state="translated">Windows 또는 &lt;a href=&quot;internationalization#macos&quot;&gt;macOS&lt;/a&gt; 에서 프린터로 직접 인쇄 할 때 &lt;a href=&quot;qprinter&quot;&gt;QPrinter&lt;/a&gt; 는 내장 프린터 드라이버를 사용합니다. X11에서 &lt;a href=&quot;qprinter&quot;&gt;QPrinter&lt;/a&gt; 는 &lt;a href=&quot;http://www.cups.org/&quot;&gt;CUPS (Common Unix Printing System)&lt;/a&gt; 를 사용하여 PDF 출력을 프린터로 보냅니다. 다른 방법으로, &lt;a href=&quot;qprinter#printProgram&quot;&gt;printProgram&lt;/a&gt; () 함수를 사용하여 시스템 기본값 대신 사용할 명령 또는 유틸리티를 지정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7baf1526ab727030bb94d023b433c10155cb76be" translate="yes" xml:space="preserve">
          <source>When processing</source>
          <target state="translated">처리 할 때</target>
        </trans-unit>
        <trans-unit id="6d2106bb45d40ac84dd2228f91e6e53dfdbe85fe" translate="yes" xml:space="preserve">
          <source>When processing any of the \code, &lt;a href=&quot;#newcode-command&quot;&gt;\newcode&lt;/a&gt; or &lt;a href=&quot;#oldcode-command&quot;&gt;\oldcode&lt;/a&gt; commands, QDoc removes all indentation that is common for the verbatim code blocks within a &lt;code&gt;/&lt;/code&gt;&lt;code&gt;*!&lt;/code&gt; ... &lt;code&gt;*&lt;/code&gt;&lt;code&gt;/&lt;/code&gt; comment before it adds the standard indentation.</source>
          <target state="translated">\ code, &lt;a href=&quot;#newcode-command&quot;&gt;\ newcode&lt;/a&gt; 또는 &lt;a href=&quot;#oldcode-command&quot;&gt;\ oldcode&lt;/a&gt; 명령을 처리 할 때 QDoc은 &lt;code&gt;/&lt;/code&gt; &lt;code&gt;*!&lt;/code&gt; ... &lt;code&gt;*&lt;/code&gt; &lt;code&gt;/&lt;/code&gt; 의견은 표준 들여 쓰기를 추가하기 전에.</target>
        </trans-unit>
        <trans-unit id="0cc162586167c5dda9673822a3e347c76baa904e" translate="yes" xml:space="preserve">
          <source>When processing the &lt;code&gt;headers&lt;/code&gt; variable, QDoc behaves in the same way as it does when processing the &lt;a href=&quot;#headerdirs&quot;&gt;&lt;code&gt;headerdirs&lt;/code&gt;&lt;/a&gt; variable. For more information, see the &lt;a href=&quot;#headerdirs&quot;&gt;&lt;code&gt;headerdirs&lt;/code&gt;&lt;/a&gt; variable.</source>
          <target state="translated">&lt;code&gt;headers&lt;/code&gt; 변수를 처리 할 때 QDoc은 &lt;a href=&quot;#headerdirs&quot;&gt; &lt;code&gt;headerdirs&lt;/code&gt; &lt;/a&gt; 변수를 처리 할 때와 동일한 방식으로 작동 합니다. 자세한 정보는 &lt;a href=&quot;#headerdirs&quot;&gt; &lt;code&gt;headerdirs&lt;/code&gt; &lt;/a&gt; 변수를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="8485caf25338b1f76aa184669dce3005f004482c" translate="yes" xml:space="preserve">
          <source>When processing the &lt;code&gt;images&lt;/code&gt; variable, QDoc behaves in the same way as it does when processing the &lt;a href=&quot;#imagedirs&quot;&gt;&lt;code&gt;imagedirs&lt;/code&gt;&lt;/a&gt; variable. For more information, see the &lt;a href=&quot;#imagedirs&quot;&gt;&lt;code&gt;imagedirs&lt;/code&gt;&lt;/a&gt; variable.</source>
          <target state="translated">&lt;code&gt;images&lt;/code&gt; 변수를 처리 할 때 QDoc은 &lt;a href=&quot;#imagedirs&quot;&gt; &lt;code&gt;imagedirs&lt;/code&gt; &lt;/a&gt; 변수를 처리 할 때와 동일한 방식으로 작동 합니다. 자세한 정보는 &lt;a href=&quot;#imagedirs&quot;&gt; &lt;code&gt;imagedirs&lt;/code&gt; &lt;/a&gt; 변수를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="02ac4cb127779361e46edccdd9715135c772a6b4" translate="yes" xml:space="preserve">
          <source>When processing the &lt;code&gt;sources&lt;/code&gt; variable, QDoc behaves in the same way as it does when processing the &lt;a href=&quot;#sourcedirs-variable&quot;&gt;sourcedirs&lt;/a&gt; variable. For more information, see the &lt;a href=&quot;#sourcedirs-variable&quot;&gt;sourcedirs&lt;/a&gt; variable.</source>
          <target state="translated">&lt;code&gt;sources&lt;/code&gt; 변수를 처리 할 때 QDoc은 &lt;a href=&quot;#sourcedirs-variable&quot;&gt;sourcedirs&lt;/a&gt; 변수를 처리 할 때와 동일한 방식으로 작동 합니다. 자세한 정보는 &lt;a href=&quot;#sourcedirs-variable&quot;&gt;sourcedirs&lt;/a&gt; 변수를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="d2f6258fc95387a5c4367b7340551e8c1e093ed8" translate="yes" xml:space="preserve">
          <source>When processing the header files specified in the &lt;a href=&quot;#headerdirs&quot;&gt;&lt;code&gt;headerdirs&lt;/code&gt;&lt;/a&gt; variable, QDoc will only read the files with the fileextensions specified in the &lt;code&gt;headers.fileextensions&lt;/code&gt; variable. In this way QDoc avoids spending time reading irrelevant files.</source>
          <target state="translated">에 지정된 헤더 파일을 처리 할 때 &lt;a href=&quot;#headerdirs&quot;&gt; &lt;code&gt;headerdirs&lt;/code&gt; 의&lt;/a&gt; 변수를 QDOC 만에 지정된 fileextensions와 파일을 읽을 &lt;code&gt;headers.fileextensions&lt;/code&gt; 의 변수를. 이런 식으로 QDoc은 관련없는 파일을 읽는 데 시간을 소비하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="4ed979007a1c43ad6e1c65933f5ff78d1bf33f42" translate="yes" xml:space="preserve">
          <source>When processing the source files specified in the &lt;a href=&quot;#sourcedirs&quot;&gt;&lt;code&gt;sourcedirs&lt;/code&gt;&lt;/a&gt; variable, QDoc will only read the files with the fileextensions specified in the &lt;code&gt;sources.fileextensions&lt;/code&gt; variable. In this way QDoc avoid spending time reading irrelevant files.</source>
          <target state="translated">&lt;a href=&quot;#sourcedirs&quot;&gt; &lt;code&gt;sourcedirs&lt;/code&gt; &lt;/a&gt; 변수에 지정된 소스 파일을 처리 할 때 QDoc은 &lt;code&gt;sources.fileextensions&lt;/code&gt; 변수에 지정된 파일 확장자를 가진 파일 만 읽습니다 . 이런 식으로 QDoc은 관련없는 파일을 읽는 데 시간을 소비하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="f3b3725626f2e2c1e184c3a3386769f3ccdb3009" translate="yes" xml:space="preserve">
          <source>When properties are defined on a &lt;a href=&quot;qt3dcore-qnode&quot;&gt;QNode&lt;/a&gt; subclass, their NOTIFY signal will automatically generate notifications that the Qt3D backend aspects will receive.</source>
          <target state="translated">속성이 &lt;a href=&quot;qt3dcore-qnode&quot;&gt;QNode&lt;/a&gt; 서브 클래스 에 정의되면 , NOTIFY 신호는 Qt3D 백엔드 측면이 수신한다는 알림을 자동으로 생성합니다.</target>
        </trans-unit>
        <trans-unit id="22650f203b3bc55d65cd8bcc3c197b3e1ae94f80" translate="yes" xml:space="preserve">
          <source>When protecting for a short-term operation, it is acceptable to call &lt;a href=&quot;qlockfile#lock&quot;&gt;lock&lt;/a&gt;() and wait until any running operation finishes. When protecting a resource over a long time, however, the application should always call &lt;a href=&quot;qlockfile#setStaleLockTime&quot;&gt;setStaleLockTime&lt;/a&gt;(0) and then &lt;a href=&quot;qlockfile#tryLock&quot;&gt;tryLock&lt;/a&gt;() with a short timeout, in order to warn the user that the resource is locked.</source>
          <target state="translated">단기 작업을 보호 할 때는 &lt;a href=&quot;qlockfile#lock&quot;&gt;잠금&lt;/a&gt; () 을 호출 하고 실행중인 작업이 끝날 때까지 기다릴 수 있습니다. 그러나 오랜 시간 동안 리소스를 보호 할 때 응용 프로그램은 리소스가 잠겨 있음을 사용자에게 경고하기 위해 항상 &lt;a href=&quot;qlockfile#setStaleLockTime&quot;&gt;setStaleLockTime&lt;/a&gt; (0)을 &lt;a href=&quot;qlockfile#tryLock&quot;&gt;호출&lt;/a&gt; 한 다음 짧은 시간 초과 로 tryLock () 을 호출 해야합니다.</target>
        </trans-unit>
        <trans-unit id="12b6bb01343a6f269ac19359f22a3d9b836dd641" translate="yes" xml:space="preserve">
          <source>When providing your own attributes, it may make sense to name your attribute using helpers such as &lt;a href=&quot;qt3drender-qattribute#defaultPositionAttributeName&quot;&gt;QAttribute::defaultPositionAttributeName&lt;/a&gt;() as that will ensure your geometry will be compatible with picking and the various materials provided in the &lt;a href=&quot;https://doc.qt.io/qt-5.13/qt3dextras-module.html&quot;&gt;Qt3DExtras&lt;/a&gt; module.</source>
          <target state="translated">고유 한 속성을 제공 할 때 &lt;a href=&quot;qt3drender-qattribute#defaultPositionAttributeName&quot;&gt;QAttribute :: defaultPositionAttributeName&lt;/a&gt; () 과 같은 도우미 를 사용하여 지오메트리가 선택 및 &lt;a href=&quot;https://doc.qt.io/qt-5.13/qt3dextras-module.html&quot;&gt;Qt3DExtras&lt;/a&gt; 모듈 에서 제공되는 다양한 재료와 호환되도록 속성을 명명 하는 것이 좋습니다 .</target>
        </trans-unit>
        <trans-unit id="83204666112336ac2cd938437ecd85c2c9e42c43" translate="yes" xml:space="preserve">
          <source>When providing your own attributes, it may make sense to name your attribute using helpers such as QAttribute::defaultPositionAttributeName() as that will ensure your geometry will be compatible with picking and the various materials provided in the &lt;a href=&quot;https://doc.qt.io/qt-5.13/qt3dextras-module.html&quot;&gt;Qt3DExtras&lt;/a&gt; module.</source>
          <target state="translated">고유 한 속성을 제공 할 때 QAttribute :: defaultPositionAttributeName ()과 같은 도우미를 사용하여 지오메트리가 선택 및 &lt;a href=&quot;https://doc.qt.io/qt-5.13/qt3dextras-module.html&quot;&gt;Qt3DExtras&lt;/a&gt; 모듈 에서 제공되는 다양한 재료와 호환되도록 속성을 명명하는 것이 좋습니다 .</target>
        </trans-unit>
        <trans-unit id="7be4e2868f53c5c712c37033765565589dd9a696" translate="yes" xml:space="preserve">
          <source>When qmake is run, an &lt;code&gt;Info.plist&lt;/code&gt; file is generated with appropriate default values.</source>
          <target state="translated">qmake가 실행되면 &lt;code&gt;Info.plist&lt;/code&gt; 파일이 적절한 기본값으로 생성됩니다.</target>
        </trans-unit>
        <trans-unit id="deaab1579f95ca0cb54a7c45e2f6602842f9bf55" translate="yes" xml:space="preserve">
          <source>When qmake processes the project file, it will generate a Makefile rule to allow the project to be built in both modes. This can be invoked in the following way:</source>
          <target state="translated">qmake가 프로젝트 파일을 처리 할 때 Makefile 규칙을 생성하여 프로젝트를 두 모드로 빌드 할 수 있습니다. 다음과 같은 방법으로 호출 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="433bf4e26978749cad77ae5bdc38533c0acb441e" translate="yes" xml:space="preserve">
          <source>When queries are generated to be executed on the database only those fields for which &lt;a href=&quot;qsqlrecord#isGenerated&quot;&gt;isGenerated&lt;/a&gt;() is true are included in the generated SQL.</source>
          <target state="translated">데이터베이스에서 실행되도록 쿼리가 생성되면 &lt;a href=&quot;qsqlrecord#isGenerated&quot;&gt;isGenerated&lt;/a&gt; ()가 true 인 필드 만 생성 된 SQL에 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="9333afa0fced835478399e93823c406d22de675b" translate="yes" xml:space="preserve">
          <source>When quoting is disabled, these types are printed without quotation characters and without escaping of non-printable characters.</source>
          <target state="translated">인용을 사용하지 않으면 이러한 유형은 따옴표없이 인쇄 할 수없는 문자를 이스케이프하지 않고 인쇄됩니다.</target>
        </trans-unit>
        <trans-unit id="2e3a5904501c88a29777d21a5ea08bedba058dd9" translate="yes" xml:space="preserve">
          <source>When reading from QByteArray(), the &lt;a href=&quot;qcborstreamreader#addData&quot;&gt;addData&lt;/a&gt;() function automatically calls this function. Calling it when the reading had not failed is a no-op.</source>
          <target state="translated">QByteArray ()에서 읽을 때 &lt;a href=&quot;qcborstreamreader#addData&quot;&gt;addData&lt;/a&gt; () 함수는이 함수를 자동으로 호출합니다. 읽기가 실패하지 않은 상태에서 호출하는 것은 아무 문제가 없습니다.</target>
        </trans-unit>
        <trans-unit id="2961583e309be088817f7af5160b0e7c63f99641" translate="yes" xml:space="preserve">
          <source>When reading, the end-of-line terminators are translated to '\n'. When writing, the end-of-line terminators are translated to the local encoding, for example '\r\n' for Win32.</source>
          <target state="translated">읽을 때 줄 끝 종결자는 '\ n'으로 변환됩니다. 쓸 때 줄 끝 종결자는 로컬 인코딩으로 변환됩니다 (예 : Win32의 경우 '\ r \ n').</target>
        </trans-unit>
        <trans-unit id="0178fb06130fa3ace5f0116314a30ba2905b8155" translate="yes" xml:space="preserve">
          <source>When receiving an input method event, the text widget has to performs the following steps:</source>
          <target state="translated">입력 메소드 이벤트를 수신 할 때 텍스트 위젯은 다음 단계를 수행해야합니다.</target>
        </trans-unit>
        <trans-unit id="6de85969ab467e39090e43789eb7746771150552" translate="yes" xml:space="preserve">
          <source>When registered with the QML engine in this way, they can be used as property types:</source>
          <target state="translated">이런 방식으로 QML 엔진에 등록하면 다음과 같은 속성 유형으로 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="658aa3d331e786b5cf19cdc003900fc565a01ebd" translate="yes" xml:space="preserve">
          <source>When reimplementing &lt;a href=&quot;qabstractitemmodel#insertColumns&quot;&gt;insertColumns&lt;/a&gt;() in a subclass, you must call this function</source>
          <target state="translated">서브 클래스에서 &lt;a href=&quot;qabstractitemmodel#insertColumns&quot;&gt;insertColumns&lt;/a&gt; ()를 다시 구현할 때이 함수를 호출해야합니다.</target>
        </trans-unit>
        <trans-unit id="4c93d0d6698e3e63d88035f6f5efca5fb6102f1c" translate="yes" xml:space="preserve">
          <source>When reimplementing &lt;a href=&quot;qabstractitemmodel#insertRows&quot;&gt;insertRows&lt;/a&gt;() in a subclass, you must call this function</source>
          <target state="translated">서브 클래스에서 &lt;a href=&quot;qabstractitemmodel#insertRows&quot;&gt;insertRows&lt;/a&gt; ()를 다시 구현할 때이 함수를 호출해야합니다.</target>
        </trans-unit>
        <trans-unit id="85d1f3aba6b52c7b19fa00f7d1afc309113e34b8" translate="yes" xml:space="preserve">
          <source>When reimplementing &lt;a href=&quot;qabstractitemmodel#removeColumns&quot;&gt;removeColumns&lt;/a&gt;() in a subclass, you must call this function</source>
          <target state="translated">서브 클래스에서 &lt;a href=&quot;qabstractitemmodel#removeColumns&quot;&gt;removeColumns&lt;/a&gt; ()를 다시 구현할 때이 함수를 호출해야합니다</target>
        </trans-unit>
        <trans-unit id="f37a182e5a69ec7aec2bf70e9e8e6c7db8177d59" translate="yes" xml:space="preserve">
          <source>When reimplementing &lt;a href=&quot;qabstractitemmodel#removeRows&quot;&gt;removeRows&lt;/a&gt;() in a subclass, you must call this function</source>
          <target state="translated">서브 클래스에서 &lt;a href=&quot;qabstractitemmodel#removeRows&quot;&gt;removeRows&lt;/a&gt; ()를 다시 구현할 때이 함수를 호출해야합니다.</target>
        </trans-unit>
        <trans-unit id="9b0330becdc29ff2c73cb6957330004540cba4dd" translate="yes" xml:space="preserve">
          <source>When reimplementing &lt;a href=&quot;qstyle&quot;&gt;QStyle&lt;/a&gt; functions that take a &lt;a href=&quot;qstyleoption&quot;&gt;QStyleOption&lt;/a&gt; parameter, you often need to cast the &lt;a href=&quot;qstyleoption&quot;&gt;QStyleOption&lt;/a&gt; to a subclass (e.g., &lt;a href=&quot;qstyleoptionfocusrect&quot;&gt;QStyleOptionFocusRect&lt;/a&gt;). For safety, you can use &lt;a href=&quot;qstyleoption#qstyleoption_cast&quot;&gt;qstyleoption_cast&lt;/a&gt;() to ensure that the pointer type is correct. If the object isn't of the right type, &lt;a href=&quot;qstyleoption#qstyleoption_cast&quot;&gt;qstyleoption_cast&lt;/a&gt;() returns &lt;code&gt;nullptr&lt;/code&gt;. For example:</source>
          <target state="translated">&lt;a href=&quot;qstyleoption&quot;&gt;QStyleOption&lt;/a&gt; 매개 변수 를 사용하는 &lt;a href=&quot;qstyle&quot;&gt;QStyle&lt;/a&gt; 함수를 다시 구현할 때 종종 &lt;a href=&quot;qstyleoption&quot;&gt;QStyleOption&lt;/a&gt; 을 서브 클래스 (예 : &lt;a href=&quot;qstyleoptionfocusrect&quot;&gt;QStyleOptionFocusRect&lt;/a&gt; ) 로 캐스트해야합니다 . 안전 을 위해 &lt;a href=&quot;qstyleoption#qstyleoption_cast&quot;&gt;qstyleoption_cast&lt;/a&gt; ()를 사용하여 포인터 유형이 올바른지 확인할 수 있습니다. 객체가 올바른 유형이 아닌 경우 &lt;a href=&quot;qstyleoption#qstyleoption_cast&quot;&gt;qstyleoption_cast&lt;/a&gt; ()는 &lt;code&gt;nullptr&lt;/code&gt; 을 반환합니다 . 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="9dfc851c4dac23e39db3f903a4238131999a47c4" translate="yes" xml:space="preserve">
          <source>When reimplementing &lt;a href=&quot;qstyle&quot;&gt;QStyle&lt;/a&gt; functions that take a &lt;a href=&quot;qstyleoption&quot;&gt;QStyleOption&lt;/a&gt; parameter, you often need to cast the &lt;a href=&quot;qstyleoption&quot;&gt;QStyleOption&lt;/a&gt; to a subclass. For safety, you can use &lt;a href=&quot;qstyleoption#qstyleoption_cast&quot;&gt;qstyleoption_cast&lt;/a&gt;() to ensure that the pointer type is correct. For example:</source>
          <target state="translated">&lt;a href=&quot;qstyleoption&quot;&gt;QStyleOption&lt;/a&gt; 매개 변수 를 사용하는 &lt;a href=&quot;qstyle&quot;&gt;QStyle&lt;/a&gt; 함수를 다시 구현할 때 종종 &lt;a href=&quot;qstyleoption&quot;&gt;QStyleOption&lt;/a&gt; 을 서브 클래스 로 캐스트해야합니다 . 안전 을 위해 &lt;a href=&quot;qstyleoption#qstyleoption_cast&quot;&gt;qstyleoption_cast&lt;/a&gt; ()를 사용하여 포인터 유형이 올바른지 확인할 수 있습니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="ec235ac06dbbca492dcbe4cfde2eff2f73ed2863" translate="yes" xml:space="preserve">
          <source>When reimplementing &lt;a href=&quot;qstyleditemdelegate#paint&quot;&gt;paint&lt;/a&gt;(), one would typically handle the datatypes one would like to draw and use the superclass implementation for other types.</source>
          <target state="translated">&lt;a href=&quot;qstyleditemdelegate#paint&quot;&gt;paint&lt;/a&gt; ()를 다시 구현할 때 일반적으로 다른 유형에 대해 슈퍼 클래스 구현을 그리거나 사용하려는 데이터 유형을 처리합니다.</target>
        </trans-unit>
        <trans-unit id="fb3e42362330e9b7392e5e0ebae5fafed9a1a17a" translate="yes" xml:space="preserve">
          <source>When reimplementing a subclass, this method simplifies moving entities in your model. This method is responsible for moving persistent indexes in the model, which you would otherwise be required to do yourself. Using beginMoveColumns and &lt;a href=&quot;qabstractitemmodel#endMoveColumns&quot;&gt;endMoveColumns&lt;/a&gt; is an alternative to emitting &lt;a href=&quot;qabstractitemmodel#layoutAboutToBeChanged&quot;&gt;layoutAboutToBeChanged&lt;/a&gt; and &lt;a href=&quot;qabstractitemmodel#layoutChanged&quot;&gt;layoutChanged&lt;/a&gt; directly along with &lt;a href=&quot;qabstractitemmodel#changePersistentIndex&quot;&gt;changePersistentIndex&lt;/a&gt;.</source>
          <target state="translated">서브 클래스를 다시 구현할 때이 메소드는 모델에서 엔티티 이동을 단순화합니다. 이 방법은 모델에서 지속적 인덱스를 이동시키는 역할을하며, 그렇지 않으면 직접 수행해야합니다. beginMoveColumns 및 사용 &lt;a href=&quot;qabstractitemmodel#endMoveColumns&quot;&gt;endMoveColumns하면&lt;/a&gt; 출사의 대안 &lt;a href=&quot;qabstractitemmodel#layoutAboutToBeChanged&quot;&gt;layoutAboutToBeChanged을&lt;/a&gt; 하고 &lt;a href=&quot;qabstractitemmodel#layoutChanged&quot;&gt;layoutChanged&lt;/a&gt; 직접 따라 함께 &lt;a href=&quot;qabstractitemmodel#changePersistentIndex&quot;&gt;changePersistentIndex&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="37d54556abfd5846d3b883b6100f1fa44ae8b968" translate="yes" xml:space="preserve">
          <source>When reimplementing a subclass, this method simplifies moving entities in your model. This method is responsible for moving persistent indexes in the model, which you would otherwise be required to do yourself. Using beginMoveRows and &lt;a href=&quot;qabstractitemmodel#endMoveRows&quot;&gt;endMoveRows&lt;/a&gt; is an alternative to emitting &lt;a href=&quot;qabstractitemmodel#layoutAboutToBeChanged&quot;&gt;layoutAboutToBeChanged&lt;/a&gt; and &lt;a href=&quot;qabstractitemmodel#layoutChanged&quot;&gt;layoutChanged&lt;/a&gt; directly along with &lt;a href=&quot;qabstractitemmodel#changePersistentIndex&quot;&gt;changePersistentIndex&lt;/a&gt;.</source>
          <target state="translated">서브 클래스를 다시 구현할 때이 메소드는 모델에서 엔티티 이동을 단순화합니다. 이 방법은 모델에서 지속적 인덱스를 이동시키는 역할을하며, 그렇지 않으면 직접 수행해야합니다. beginMoveRows 및 사용 &lt;a href=&quot;qabstractitemmodel#endMoveRows&quot;&gt;endMoveRows하면&lt;/a&gt; 출사의 대안 &lt;a href=&quot;qabstractitemmodel#layoutAboutToBeChanged&quot;&gt;layoutAboutToBeChanged을&lt;/a&gt; 하고 &lt;a href=&quot;qabstractitemmodel#layoutChanged&quot;&gt;layoutChanged&lt;/a&gt; 직접 따라 함께 &lt;a href=&quot;qabstractitemmodel#changePersistentIndex&quot;&gt;changePersistentIndex&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="ca95dc0c0eb787c2eeed20255a0cb245f62492af" translate="yes" xml:space="preserve">
          <source>When reimplementing canRead(), make sure that the I/O device (&lt;a href=&quot;qimageiohandler#device&quot;&gt;device&lt;/a&gt;()) is left in its original state (e.g., by using peek() rather than &lt;a href=&quot;qimageiohandler#read&quot;&gt;read&lt;/a&gt;()).</source>
          <target state="translated">canRead ()를 다시 구현할 때 I / O 장치 ( &lt;a href=&quot;qimageiohandler#device&quot;&gt;장치&lt;/a&gt; ())가 원래 상태로 남아 있는지 확인하십시오 (예 : &lt;a href=&quot;qimageiohandler#read&quot;&gt;읽기&lt;/a&gt; () 대신 peek () 사용 ).</target>
        </trans-unit>
        <trans-unit id="028d93193544c8ed47ad98dfeadb939c5667b03b" translate="yes" xml:space="preserve">
          <source>When reimplementing paint in a subclass. Use the &lt;a href=&quot;qstyleditemdelegate#initStyleOption&quot;&gt;initStyleOption&lt;/a&gt;() to set up the</source>
          <target state="translated">서브 클래스에서 페인트를 다시 구현할 때. 사용 &lt;a href=&quot;qstyleditemdelegate#initStyleOption&quot;&gt;initStyleOption를&lt;/a&gt; 설정 ()을</target>
        </trans-unit>
        <trans-unit id="df7f5f683e515c4160cc8d6065b4b4913422655c" translate="yes" xml:space="preserve">
          <source>When reimplementing the &lt;a href=&quot;qabstractitemmodel#setData&quot;&gt;setData&lt;/a&gt;() function, this signal must be emitted explicitly.</source>
          <target state="translated">&lt;a href=&quot;qabstractitemmodel#setData&quot;&gt;setData&lt;/a&gt; () 함수를 다시 구현할 때이 신호를 명시 적으로 방출해야합니다.</target>
        </trans-unit>
        <trans-unit id="6f516d38e016de108e31954fe638b31e63f64384" translate="yes" xml:space="preserve">
          <source>When reimplementing the &lt;a href=&quot;qabstractitemmodel#setHeaderData&quot;&gt;setHeaderData&lt;/a&gt;() function, this signal must be emitted explicitly.</source>
          <target state="translated">&lt;a href=&quot;qabstractitemmodel#setHeaderData&quot;&gt;setHeaderData&lt;/a&gt; () 함수를 다시 구현할 때이 신호가 명시 적으로 방출되어야합니다.</target>
        </trans-unit>
        <trans-unit id="8bb42c54f45079c9c25f1595264e446c8f5dae51" translate="yes" xml:space="preserve">
          <source>When reimplementing the &lt;a href=&quot;qeventtransition#eventTest&quot;&gt;eventTest&lt;/a&gt;() function, you should first call the base implementation to verify that the event is a &lt;a href=&quot;qstatemachine-wrappedevent&quot;&gt;QStateMachine::WrappedEvent&lt;/a&gt; for the proper object and event type. You may then cast the event to a &lt;a href=&quot;qstatemachine-wrappedevent&quot;&gt;QStateMachine::WrappedEvent&lt;/a&gt; and get the original event by calling &lt;a href=&quot;qstatemachine-wrappedevent#event&quot;&gt;QStateMachine::WrappedEvent::event&lt;/a&gt;(), and perform additional checks on that object.</source>
          <target state="translated">&lt;a href=&quot;qeventtransition#eventTest&quot;&gt;eventTest&lt;/a&gt; () 함수를 다시 구현할 때는 먼저 기본 구현을 호출하여 이벤트가 올바른 객체 및 이벤트 유형에 대한 &lt;a href=&quot;qstatemachine-wrappedevent&quot;&gt;QStateMachine :: WrappedEvent인지&lt;/a&gt; 확인해야합니다 . 그런 다음 이벤트를 &lt;a href=&quot;qstatemachine-wrappedevent&quot;&gt;QStateMachine :: WrappedEvent&lt;/a&gt; 로 캐스트하고 &lt;a href=&quot;qstatemachine-wrappedevent#event&quot;&gt;QStateMachine :: WrappedEvent :: event&lt;/a&gt; () 를 호출하여 원래 이벤트를 가져 오고 해당 오브젝트에 대한 추가 점검을 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b124ac10b911b199139a9b1396e9a53e131374c7" translate="yes" xml:space="preserve">
          <source>When reimplementing this class, take care to return at least one element.</source>
          <target state="translated">이 클래스를 다시 구현할 때 하나 이상의 요소를 반환하도록주의하십시오.</target>
        </trans-unit>
        <trans-unit id="55e2b93bd22d4647e3de872d6613c4f4629fae05" translate="yes" xml:space="preserve">
          <source>When reimplementing this function in a subclass, be careful to avoid calling &lt;a href=&quot;qmodelindex&quot;&gt;QModelIndex&lt;/a&gt; member functions, such as &lt;a href=&quot;qmodelindex#parent&quot;&gt;QModelIndex::parent&lt;/a&gt;(), since indexes belonging to your model will simply call your implementation, leading to infinite recursion.</source>
          <target state="translated">서브 클래스에서이 함수를 다시 구현할 때는 모델에 속하는 인덱스가 단순히 구현을 호출하여 무한 재귀를 유발 하므로 &lt;a href=&quot;qmodelindex#parent&quot;&gt;QModelIndex :: parent&lt;/a&gt; () 와 같은 &lt;a href=&quot;qmodelindex&quot;&gt;QModelIndex&lt;/a&gt; 멤버 함수를 호출하지 않도록주의 하십시오.</target>
        </trans-unit>
        <trans-unit id="70e5caa7bbddd6d74b4efb7d8a7005f9825d497b" translate="yes" xml:space="preserve">
          <source>When reimplementing this function in a subclass, call &lt;a href=&quot;qabstractitemmodel#createIndex&quot;&gt;createIndex&lt;/a&gt;() to generate model indexes that other components can use to refer to items in your model.</source>
          <target state="translated">서브 클래스에서이 함수를 다시 구현할 때 &lt;a href=&quot;qabstractitemmodel#createIndex&quot;&gt;createIndex&lt;/a&gt; ()를 호출 하여 다른 컴포넌트가 모델의 항목을 참조하는 데 사용할 수있는 모델 색인을 생성하십시오.</target>
        </trans-unit>
        <trans-unit id="ba7f9d147f366305cacefe9a55e635566170bc6d" translate="yes" xml:space="preserve">
          <source>When reimplementing this function in a subclass, you should update the area held by the option's &lt;a href=&quot;qstyleoption#rect-var&quot;&gt;rect&lt;/a&gt; variable, using the option's &lt;a href=&quot;qstyleoption#state-var&quot;&gt;state&lt;/a&gt; variable to determine the state of the item to be displayed, and adjust the way it is painted accordingly.</source>
          <target state="translated">서브 클래스에서이 함수를 다시 구현할 때 옵션의 &lt;a href=&quot;qstyleoption#state-var&quot;&gt;상태&lt;/a&gt; 변수를 사용하여 옵션의 &lt;a href=&quot;qstyleoption#rect-var&quot;&gt;rect&lt;/a&gt; 변수가 보유한 영역을 업데이트하여 표시 할 항목의 상태를 판별하고 그에 따라 페인트 방법을 조정해야합니다.</target>
        </trans-unit>
        <trans-unit id="4e2d2f89b79fefee58d5613beec7b9bd5dde6fb5" translate="yes" xml:space="preserve">
          <source>When reimplementing this function it is important that this function reads all the required data before returning. This is required in order for &lt;a href=&quot;qdatastream&quot;&gt;QDataStream&lt;/a&gt; to be able to operate on the class. &lt;a href=&quot;qdatastream&quot;&gt;QDataStream&lt;/a&gt; assumes all the requested information was read and therefore does not retry reading if there was a problem.</source>
          <target state="translated">이 함수를 다시 구현할 때이 함수는 리턴하기 전에 필요한 모든 데이터를 읽는 것이 중요합니다. 이것은 &lt;a href=&quot;qdatastream&quot;&gt;QDataStream&lt;/a&gt; 이 클래스에서 작동 할 수 있도록 하기 위해 필요합니다 . &lt;a href=&quot;qdatastream&quot;&gt;QDataStream&lt;/a&gt; 은 요청 된 모든 정보를 읽은 것으로 가정하므로 문제가있는 경우 다시 읽지 않습니다.</target>
        </trans-unit>
        <trans-unit id="e93d19bd100346fac19905c7b4a51959378ca55b" translate="yes" xml:space="preserve">
          <source>When reimplementing this function it is important that this function writes all the data available before returning. This is required in order for &lt;a href=&quot;qdatastream&quot;&gt;QDataStream&lt;/a&gt; to be able to operate on the class. &lt;a href=&quot;qdatastream&quot;&gt;QDataStream&lt;/a&gt; assumes all the information was written and therefore does not retry writing if there was a problem.</source>
          <target state="translated">이 함수를 다시 구현할 때이 함수는 반환하기 전에 사용 가능한 모든 데이터를 기록해야합니다. 이것은 &lt;a href=&quot;qdatastream&quot;&gt;QDataStream&lt;/a&gt; 이 클래스에서 작동 할 수 있도록 하기 위해 필요합니다 . &lt;a href=&quot;qdatastream&quot;&gt;QDataStream&lt;/a&gt; 은 모든 정보가 기록되었다고 가정하므로 문제가 발생한 경우 다시 쓰지 않습니다.</target>
        </trans-unit>
        <trans-unit id="dbe06314296a3392519e885c147e88b10b0594de" translate="yes" xml:space="preserve">
          <source>When reimplementing this function, note that in case of text items, &lt;a href=&quot;qitemdelegate&quot;&gt;QItemDelegate&lt;/a&gt; adds a margin (i.e. 2 * &lt;a href=&quot;qstyle#PixelMetric-enum&quot;&gt;QStyle::PM_FocusFrameHMargin&lt;/a&gt;) to the length of the text.</source>
          <target state="translated">이 함수를 다시 구현할 때 텍스트 항목의 경우 &lt;a href=&quot;qitemdelegate&quot;&gt;QItemDelegate&lt;/a&gt; 는 텍스트 길이에 여백 (예 : 2 * &lt;a href=&quot;qstyle#PixelMetric-enum&quot;&gt;QStyle :: PM_FocusFrameHMargin&lt;/a&gt; )을 추가합니다.</target>
        </trans-unit>
        <trans-unit id="197ccf9da55fd735f9643d4ab74a6bddeec9dfb0" translate="yes" xml:space="preserve">
          <source>When reimplementing this function, the &lt;a href=&quot;qabstractitemmodel#headerDataChanged&quot;&gt;headerDataChanged&lt;/a&gt;() signal must be emitted explicitly.</source>
          <target state="translated">이 함수를 다시 구현할 때 &lt;a href=&quot;qabstractitemmodel#headerDataChanged&quot;&gt;headerDataChanged&lt;/a&gt; () 신호가 명시 적으로 방출되어야합니다.</target>
        </trans-unit>
        <trans-unit id="89a145bd42509fd307493a0a0013f21ce6e0557c" translate="yes" xml:space="preserve">
          <source>When relative paths are specified, qmake will mangle them into a form understood by the dynamic linker to be relative to the location of the referring executable or library. This is supported only by some platforms (currently Linux and Darwin-based ones) and is detectable by checking whether &lt;a href=&quot;#qmake-rel-rpath-base&quot;&gt;QMAKE_REL_RPATH_BASE&lt;/a&gt; is set.</source>
          <target state="translated">상대 경로가 지정되면 qmake는 동적 링커가 참조 실행 파일 또는 라이브러리의 위치를 ​​기준으로 이해하는 형식으로 경로를 변환합니다. 이는 일부 플랫폼 (현재 Linux 및 Darwin 기반 플랫폼)에서만 지원되며 &lt;a href=&quot;#qmake-rel-rpath-base&quot;&gt;QMAKE_REL_RPATH_BASE의&lt;/a&gt; 설정 여부를 확인하여 감지 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b737ba18762f9d815ad8cc904c2c8daeaec43e4b" translate="yes" xml:space="preserve">
          <source>When rendering graphics, the matrix defines the transformations but the actual transformation is performed by the drawing routines in &lt;a href=&quot;qpainter&quot;&gt;QPainter&lt;/a&gt;.</source>
          <target state="translated">그래픽을 렌더링 할 때 매트릭스는 변환을 정의하지만 실제 변환은 &lt;a href=&quot;qpainter&quot;&gt;QPainter&lt;/a&gt; 의 그리기 루틴에 의해 수행됩니다 .</target>
        </trans-unit>
        <trans-unit id="7c5109171a737854a9ba5a71e30fd9bd78572ca4" translate="yes" xml:space="preserve">
          <source>When rendering with a pen with an even number of pixels, the pixels will be rendered symetrically around the mathematical defined points, while rendering with a pen with an odd number of pixels, the spare pixel will be rendered to the right and below the mathematical point as in the one pixel case. See the &lt;a href=&quot;qrectf&quot;&gt;QRectF&lt;/a&gt; diagrams below for concrete examples.</source>
          <target state="translated">짝수의 픽셀을 가진 펜으로 렌더링 할 때, 픽셀은 수학적으로 정의 된 점을 중심으로 대칭 적으로 렌더링되고, 홀수의 픽셀을 가진 펜으로 렌더링 할 때, 여분의 픽셀은 수학 포인트의 오른쪽 아래로 렌더링됩니다 한 픽셀의 경우처럼. 구체적인 예는 아래 &lt;a href=&quot;qrectf&quot;&gt;QRectF&lt;/a&gt; 다이어그램을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="f6bb9fd28f420249ac748ef0297e189cfdea3c23" translate="yes" xml:space="preserve">
          <source>When rendering with a two pixels wide pen the boundary line will be split in the middle by the mathematical rectangle. This will be the case whenever the pen is set to an even number of pixels, while rendering with a pen with an odd number of pixels, the spare pixel will be rendered to the right and below the mathematical rectangle as in the one pixel case.</source>
          <target state="translated">너비가 2 픽셀 인 펜으로 렌더링 할 때 경계선은 수학 사각형에 의해 가운데에서 분할됩니다. 펜이 짝수의 픽셀로 설정 될 때마다 홀수의 픽셀로 펜으로 렌더링하는 동안 여분의 픽셀은 한 픽셀의 경우와 같이 수학 사각형의 오른쪽 아래로 렌더링됩니다.</target>
        </trans-unit>
        <trans-unit id="d7e0077b12f54b280554348b8d31ed612bede88e" translate="yes" xml:space="preserve">
          <source>When rendering, &lt;a href=&quot;qgraphicsview&quot;&gt;QGraphicsView&lt;/a&gt; protects the painter state (see &lt;a href=&quot;qpainter#save&quot;&gt;QPainter::save&lt;/a&gt;()) when rendering the background or foreground, and when rendering each item. This allows you to leave the painter in an altered state (i.e., you can call &lt;a href=&quot;qpainter#setPen&quot;&gt;QPainter::setPen&lt;/a&gt;() or &lt;a href=&quot;qpainter#setBrush&quot;&gt;QPainter::setBrush&lt;/a&gt;() without restoring the state after painting). However, if the items consistently do restore the state, you should enable this flag to prevent &lt;a href=&quot;qgraphicsview&quot;&gt;QGraphicsView&lt;/a&gt; from doing the same.</source>
          <target state="translated">렌더링 할 때 &lt;a href=&quot;qgraphicsview&quot;&gt;QGraphicsView&lt;/a&gt; 는 배경 또는 전경을 렌더링 할 때와 각 항목을 렌더링 할 때 페인터 상태 ( &lt;a href=&quot;qpainter#save&quot;&gt;QPainter :: save&lt;/a&gt; () 참조)를 보호합니다 . 따라서 페인터를 변경된 상태로 &lt;a href=&quot;qpainter#setPen&quot;&gt;유지할&lt;/a&gt; 수 있습니다 (즉, 페인팅 후 상태를 복원하지 않고 QPainter :: setPen () 또는 &lt;a href=&quot;qpainter#setBrush&quot;&gt;QPainter :: setBrush&lt;/a&gt; ()를 호출 할 수 있음 ). 그러나 항목이 지속적으로 상태를 복원하는 경우 &lt;a href=&quot;qgraphicsview&quot;&gt;QGraphicsView&lt;/a&gt; 가 동일한 작업을 수행 하지 못하게하려면이 플래그를 사용으로 설정해야합니다 .</target>
        </trans-unit>
        <trans-unit id="d51a24d95c26c19a346a37f3dd7e864ef01ea9d8" translate="yes" xml:space="preserve">
          <source>When rendering, Graphics View's scene coordinates correspond to &lt;a href=&quot;qpainter&quot;&gt;QPainter&lt;/a&gt;'s</source>
          <target state="translated">렌더링 할 때 Graphics View의 장면 좌표는 &lt;a href=&quot;qpainter&quot;&gt;QPainter&lt;/a&gt; 의</target>
        </trans-unit>
        <trans-unit id="b351cd57358f6774989d1cb0e0f8f4b5f818e8c3" translate="yes" xml:space="preserve">
          <source>When requesting an index for a model item, we must provide some information about the item's parent. Outside the model, the only way to refer to an item is through a model index, so a parent model index must also be given:</source>
          <target state="translated">모델 아이템에 대한 인덱스를 요청할 때 아이템의 부모에 대한 정보를 제공해야합니다. 모델 외부에서 항목을 참조하는 유일한 방법은 모델 색인을 통하는 것이므로 상위 모델 색인도 제공해야합니다.</target>
        </trans-unit>
        <trans-unit id="e3462b37efc9ed9435b6be891fff238475c5b943" translate="yes" xml:space="preserve">
          <source>When resizeEvent() is called, the viewport already has its new geometry: Its new size is accessible through the &lt;a href=&quot;qresizeevent#size&quot;&gt;QResizeEvent::size&lt;/a&gt;() function, and the old size through &lt;a href=&quot;qresizeevent#oldSize&quot;&gt;QResizeEvent::oldSize&lt;/a&gt;().</source>
          <target state="translated">resizeEvent ()가 호출되면 뷰포트에 이미 새로운 지오메트리가 있습니다. 새로운 크기는 &lt;a href=&quot;qresizeevent#size&quot;&gt;QResizeEvent :: size&lt;/a&gt; () 함수를 통해 액세스 할 수 있고 이전 크기는 &lt;a href=&quot;qresizeevent#oldSize&quot;&gt;QResizeEvent :: oldSize&lt;/a&gt; ()를 통해 액세스 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="459145d7e5e0a2dddcfe14e374a8a522472aa332" translate="yes" xml:space="preserve">
          <source>When returning from C++, the engine will interrupt the normal flow of execution and call the the next pre-registered exception handler with an error object that contains the given</source>
          <target state="translated">C ++에서 돌아올 때 엔진은 정상적인 실행 흐름을 중단하고 주어진 다음을 포함하는 오류 객체와 함께 다음으로 사전 등록 된 예외 핸들러를 호출합니다.</target>
        </trans-unit>
        <trans-unit id="90d305ada35629da8b28508d253830cb3271219a" translate="yes" xml:space="preserve">
          <source>When rubberband selection ends this signal will be emitted with null vales.</source>
          <target state="translated">고무 밴드 선택이 끝나면이 신호는 null vales와 함께 방출됩니다.</target>
        </trans-unit>
        <trans-unit id="d7d3ba7b84a869b7ec4d6428c30a1e381f521d40" translate="yes" xml:space="preserve">
          <source>When run in a Norwegian locale, this code could for instance display &quot;Price is kr 6,00&quot; for a one-dollar product.</source>
          <target state="translated">노르웨이어 로케일에서 실행될 때이 코드는 예를 들어 1 달러 제품에 대해 &quot;가격은 kr 6,00&quot;으로 표시 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f4b4ea8160e44027a1643f73bd2b4fc24a630c0f" translate="yes" xml:space="preserve">
          <source>When running QDoc to generate HTML, the example above will have no effect on the generated output, but if you run QDoc to generate DITA XML, the example will generate the following:</source>
          <target state="translated">QDoc을 실행하여 HTML을 생성 할 때 위의 예제는 생성 된 출력에 영향을 미치지 않지만 QDoc을 실행하여 DITA XML을 생성하면 예제는 다음을 생성합니다.</target>
        </trans-unit>
        <trans-unit id="ba74a44a4fe513e0e864500ccf8b7805d12bdf2c" translate="yes" xml:space="preserve">
          <source>When running the advertising procedure, a number of parameters can be configured, such as how fast to advertise or which clients, if any, can connect to the advertising device. These parameters are set via this class, and their values will be used when advertising is started by calling &lt;a href=&quot;qlowenergycontroller#startAdvertising&quot;&gt;QLowEnergyController::startAdvertising&lt;/a&gt;().</source>
          <target state="translated">광고 절차를 실행할 때 광고 속도 또는 광고 장치에 연결할 수있는 클라이언트와 같은 여러 매개 변수를 구성 할 수 있습니다. 이 매개 변수는이 클래스를 통해 설정되며 &lt;a href=&quot;qlowenergycontroller#startAdvertising&quot;&gt;QLowEnergyController :: startAdvertising&lt;/a&gt; () 을 호출하여 광고가 시작될 때 해당 값이 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="419ca242c0e809f26e319a45853b06288d62f271" translate="yes" xml:space="preserve">
          <source>When running with the OpenGL backend of the scene graph, &lt;a href=&quot;qquickwindow&quot;&gt;QQuickWindow&lt;/a&gt; offers the possibility to disable persistent OpenGL contexts as well. This setting is currently ignored by &lt;a href=&quot;qquickwidget&quot;&gt;QQuickWidget&lt;/a&gt; and the context is always persistent. The OpenGL context is thus not destroyed when hiding the widget. The context is destroyed only when the widget is destroyed or when the widget gets reparented into another top-level widget's child hierarchy. However, some applications, in particular those that have their own graphics resources due to performing custom OpenGL rendering in the Qt Quick scene, may wish to disable the latter since they may not be prepared to handle the loss of the context when moving a &lt;a href=&quot;qquickwidget&quot;&gt;QQuickWidget&lt;/a&gt; into another window. Such applications can set the QCoreApplication::AA_ShareOpenGLContexts attribute. For a discussion on the details of resource initialization and cleanup, refer to the &lt;a href=&quot;qopenglwidget&quot;&gt;QOpenGLWidget&lt;/a&gt; documentation.</source>
          <target state="translated">장면 그래프의 OpenGL 백엔드로 실행할 때 &lt;a href=&quot;qquickwindow&quot;&gt;QQuickWindow&lt;/a&gt; 는 지속적인 OpenGL 컨텍스트를 비활성화 할 수도 있습니다. 이 설정은 현재 &lt;a href=&quot;qquickwidget&quot;&gt;QQuickWidget에&lt;/a&gt; 의해 무시되며 컨텍스트는 항상 영구적입니다. 따라서 위젯을 숨길 때 OpenGL 컨텍스트가 손상되지 않습니다. 위젯이 삭제되거나 위젯이 다른 최상위 위젯의 하위 계층 구조로 재 부착되는 경우에만 컨텍스트가 삭제됩니다. 그러나 일부 응용 프로그램, 특히 Qt Quick 장면에서 사용자 정의 OpenGL 렌더링을 수행하여 자체 그래픽 리소스가있는 응용 프로그램은 &lt;a href=&quot;qquickwidget&quot;&gt;QQuickWidget을&lt;/a&gt; 이동할 때 컨텍스트 손실을 처리 할 준비가되지 않기 때문에이를 비활성화 할 수 있습니다.다른 창으로. 이러한 애플리케이션은 QCoreApplication :: AA_ShareOpenGLContexts 속성을 설정할 수 있습니다. 자원 초기화 및 정리에 대한 자세한 내용은 &lt;a href=&quot;qopenglwidget&quot;&gt;QOpenGLWidget&lt;/a&gt; 문서를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="4180cc40e3670129f26ab3b8aa7583731a04bc4b" translate="yes" xml:space="preserve">
          <source>When running with the default, OpenGL backend of Qt Quick, both the generic, triangulation-based and the NVIDIA-specific &lt;code&gt;GL_NV_path_rendering&lt;/code&gt; methods are available. By default only the generic approach is used. Setting Shape.&lt;a href=&quot;qml-qtquick-shapes-shape#vendorExtensionsEnabled-prop&quot;&gt;vendorExtensionsEnabled&lt;/a&gt; property to &lt;code&gt;true&lt;/code&gt; leads to using NV_path_rendering on NVIDIA systems, and the generic method on others.</source>
          <target state="translated">Qt Quick의 기본 OpenGL 백엔드로 실행하는 경우 일반 삼각 측량 기반 및 NVIDIA 고유 &lt;code&gt;GL_NV_path_rendering&lt;/code&gt; 방법을 모두 사용할 수 있습니다. 기본적으로 일반적인 접근 방식 만 사용됩니다. 모양 설정. &lt;a href=&quot;qml-qtquick-shapes-shape#vendorExtensionsEnabled-prop&quot;&gt;vendorExtensionsEnabled&lt;/a&gt; 속성을 &lt;code&gt;true&lt;/code&gt; 로 설정하면 NVIDIA 시스템에서 NV_path_rendering을 사용하고 다른 시스템에서는 일반적인 방법을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="22c17b7b950b81783fdb923684eedfd560adcd81" translate="yes" xml:space="preserve">
          <source>When runtime compilation is not in use and the shader properties refer to files with bytecode, the status is always Compiled. The contents of the shader is not examined (apart from basic reflection to discover vertex input elements and constant buffer data) until later in the rendering pipeline so potential errors (like layout or root signature mismatches) will only be detected at a later point.</source>
          <target state="translated">런타임 컴파일을 사용하지 않고 셰이더 속성이 바이트 코드가있는 파일을 참조하면 상태는 항상 컴파일됩니다. 셰이더의 내용은 렌더링 파이프 라인에서 나중에까지 기본 반사와 정점 입력 요소 및 상수 버퍼 데이터를 찾기 위해 검사되지 않으므로 잠재적 오류 (예 : 레이아웃 또는 루트 서명 불일치)는 나중에 만 감지됩니다.</target>
        </trans-unit>
        <trans-unit id="1cf799c203f3447ab5ee733162b36bb8365e9dec" translate="yes" xml:space="preserve">
          <source>When saving a form in</source>
          <target state="translated">양식을 저장할 때</target>
        </trans-unit>
        <trans-unit id="1e9c03991883db6f31187fbe5c35791a719629dc" translate="yes" xml:space="preserve">
          <source>When saving places between managers, there are a few things to be aware of. Some fields of a place such as the id, categories and icons are manager specific entities for example the categories in one manager may not be recognized in another. Therefore trying to save a place directly from one manager to another is not possible.</source>
          <target state="translated">관리자간에 장소를 저장할 때 알아야 할 몇 가지 사항이 있습니다. ID, 카테고리 및 아이콘과 같은 장소의 일부 필드는 관리자 별 엔티티입니다. 예를 들어 한 관리자의 카테고리는 다른 관리자에서 인식되지 않을 수 있습니다. 따라서 한 관리자에서 다른 관리자에게 직접 장소를 저장하려고 시도 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="65dee2f6abcd14dfb6ffc451b8eef9d4e59664a3" translate="yes" xml:space="preserve">
          <source>When saving places between plugins, there are a few things to be aware of. Some fields of a place such as the id, categories and icons are plugin specific entities. For example the categories in one manager may not be recognised in another. Therefore trying to save a place directly from one plugin to another is not possible.</source>
          <target state="translated">플러그인 사이에 장소를 저장할 때 알아 두어야 할 것이 몇 가지 있습니다. ID, 카테고리 및 아이콘과 같은 장소의 일부 필드는 플러그인 특정 엔티티입니다. 예를 들어 한 관리자의 범주는 다른 관리자에서 인식되지 않을 수 있습니다. 따라서 한 플러그인에서 다른 플러그인으로 직접 장소를 저장하려고 시도 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="16335d2940c0a9a4d44f0bf7877e3be7c7a4c25b" translate="yes" xml:space="preserve">
          <source>When scheduling cleanup of graphics resources using &lt;a href=&quot;qquickwindow#scheduleRenderJob&quot;&gt;QQuickWindow::scheduleRenderJob&lt;/a&gt;(), one should use either &lt;a href=&quot;qquickwindow#RenderStage-enum&quot;&gt;QQuickWindow::BeforeSynchronizingStage&lt;/a&gt; or &lt;a href=&quot;qquickwindow#RenderStage-enum&quot;&gt;QQuickWindow::AfterSynchronizingStage&lt;/a&gt;. The &lt;a href=&quot;qtquick-visualcanvas-scenegraph#scene-graph-and-rendering&quot;&gt;synchronization stage&lt;/a&gt; is where the scene graph is changed as a result of changes to the QML tree. If cleanup is scheduled at any other time, it may result in other parts of the scene graph referencing the newly deleted objects as these parts have not been updated.</source>
          <target state="translated">&lt;a href=&quot;qquickwindow#scheduleRenderJob&quot;&gt;QQuickWindow :: scheduleRenderJob&lt;/a&gt; ()을 사용하여 그래픽 리소스 정리를 예약 할 때는 &lt;a href=&quot;qquickwindow#RenderStage-enum&quot;&gt;QQuickWindow :: BeBeSynchronizingStage&lt;/a&gt; 또는 &lt;a href=&quot;qquickwindow#RenderStage-enum&quot;&gt;QQuickWindow :: AfterSynchronizingStage를 사용해야&lt;/a&gt; 합니다. &lt;a href=&quot;qtquick-visualcanvas-scenegraph#scene-graph-and-rendering&quot;&gt;동기화 단계는&lt;/a&gt; 상기 장면 그래프는 QML 트리의 변경으로 인해 변경되는 경우이다. 정리가 다른 시간에 예약되면 장면 그래프의 다른 부분이 업데이트되지 않았으므로 새로 삭제 된 객체를 참조 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0470cdb483508ebc7b70959dbd94540db4bc9c18" translate="yes" xml:space="preserve">
          <source>When sections are used, the first section command should be &lt;code&gt;section1&lt;/code&gt;.</source>
          <target state="translated">섹션을 사용할 때 첫 번째 섹션 명령은 &lt;code&gt;section1&lt;/code&gt; 이어야합니다 .</target>
        </trans-unit>
        <trans-unit id="f5eedde8058556feb6cb3beeca59e7888ae6ece9" translate="yes" xml:space="preserve">
          <source>When selection is changed by clicking on the graph</source>
          <target state="translated">그래프를 클릭하여 선택을 변경 한 경우</target>
        </trans-unit>
        <trans-unit id="00867511fe8868752b9e077a7707775ae9c1971d" translate="yes" xml:space="preserve">
          <source>When selection is changed explicitly via series API to a visible item</source>
          <target state="translated">선택 사항이 시리즈 API를 통해 명시 적으로 표시되는 항목으로 변경되는 경우</target>
        </trans-unit>
        <trans-unit id="2e1af7d1ebff8ce0a52ad99867add45c86a6ae89" translate="yes" xml:space="preserve">
          <source>When sending CAN FD frames, this flag is automatically set by the CAN FD hardware. &lt;code&gt;QCanBusFrame::setErrorStateIndicator()&lt;/code&gt; should only be used for application testing, e.g. on virtual CAN FD busses.</source>
          <target state="translated">CAN FD 프레임을 전송할 때이 플래그는 CAN FD 하드웨어에 의해 자동으로 설정됩니다. &lt;code&gt;QCanBusFrame::setErrorStateIndicator()&lt;/code&gt; 는 어플리케이션 테스트 (예 : 가상 CAN FD 버스 ) 에만 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="357729db045ad04ca40ebade91b854125d77106d" translate="yes" xml:space="preserve">
          <source>When sending CAN bus frames with &lt;a href=&quot;qcanbusdevice#ConfigurationKey-enum&quot;&gt;QCanBusDevice::ReceiveOwnKey&lt;/a&gt; enabled, all successfully sent frames are echoed to the receive queue and marked as local echo frames. &lt;code&gt;QCanBusFrame::setLocalEcho&lt;/code&gt; should therefore only be used for application testing, e.g. on virtual CAN busses.</source>
          <target state="translated">&lt;a href=&quot;qcanbusdevice#ConfigurationKey-enum&quot;&gt;QCanBusDevice :: ReceiveOwnKey가&lt;/a&gt; 활성화 된 상태에서 CAN 버스 프레임을 전송하면 성공적으로 전송 된 모든 프레임이 수신 큐에 에코되고 로컬 에코 프레임으로 표시됩니다. 따라서 &lt;code&gt;QCanBusFrame::setLocalEcho&lt;/code&gt; 는 애플리케이션 테스트 (예 : 가상 CAN 버스)에만 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="8bae5e50b5bdda4bb33ef7b2b1936a5c7112c234" translate="yes" xml:space="preserve">
          <source>When sending requests, to control the preference of when to use the cache and when to use the network, consider the following:</source>
          <target state="translated">요청을 보낼 때 캐시 사용시기 및 네트워크 사용시기에 대한 기본 설정을 제어하려면 다음을 고려하십시오.</target>
        </trans-unit>
        <trans-unit id="73e7c0c4bd2ed4ad850a956107fc733151db2cb3" translate="yes" xml:space="preserve">
          <source>When sending, the &lt;a href=&quot;qnetworkdatagram#senderAddress&quot;&gt;senderAddress&lt;/a&gt;() and &lt;a href=&quot;qnetworkdatagram#senderPort&quot;&gt;senderPort&lt;/a&gt;() should contain the local address to be used when sending. The sender address must be an address that is assigned to this machine, which can be obtained using &lt;a href=&quot;qnetworkinterface&quot;&gt;QNetworkInterface&lt;/a&gt;, and the port number must be the port number that the socket is bound to. Either field can be left unset and will be filled in by the operating system with default values. The &lt;a href=&quot;qnetworkdatagram#destinationAddress&quot;&gt;destinationAddress&lt;/a&gt;() and &lt;a href=&quot;qnetworkdatagram#destinationPort&quot;&gt;destinationPort&lt;/a&gt;() fields may be set to a target address different from the one the UDP socket is currently associated with.</source>
          <target state="translated">송신시 &lt;a href=&quot;qnetworkdatagram#senderAddress&quot;&gt;senderAddress&lt;/a&gt; () 및 &lt;a href=&quot;qnetworkdatagram#senderPort&quot;&gt;senderPort&lt;/a&gt; ()에는 송신시 사용될 로컬 주소가 포함되어야합니다. 송신자 주소는 &lt;a href=&quot;qnetworkinterface&quot;&gt;QNetworkInterface&lt;/a&gt; 를 사용하여 얻을 수있는이 기계에 지정된 주소 여야하며 포트 번호는 소켓이 바인드 된 포트 번호 여야합니다. 필드는 설정하지 않은 상태로 둘 수 있으며 운영 체제가 기본값으로 채 웁니다. &lt;a href=&quot;qnetworkdatagram#destinationAddress&quot;&gt;destinationAddress&lt;/a&gt; () 및 &lt;a href=&quot;qnetworkdatagram#destinationPort&quot;&gt;destinationPort&lt;/a&gt; () 필드는 UDP 소켓 현재 연결된 하나로부터 타겟 어드레스 가지로 설정 될 수있다.</target>
        </trans-unit>
        <trans-unit id="bbc34b6972fd5a95f0e17a1bedd0814ddeba5170" translate="yes" xml:space="preserve">
          <source>When serialized item data is dropped onto a view, the data is inserted into the current model using its implementation of &lt;a href=&quot;qabstractitemmodel#dropMimeData&quot;&gt;QAbstractItemModel::dropMimeData&lt;/a&gt;(). The default implementation of this function will never overwrite any data in the model; instead, it tries to insert the items of data either as siblings of an item, or as children of that item.</source>
          <target state="translated">직렬화 된 항목 데이터가 뷰에 삭제되면 &lt;a href=&quot;qabstractitemmodel#dropMimeData&quot;&gt;QAbstractItemModel :: dropMimeData&lt;/a&gt; () 의 구현을 사용하여 데이터가 현재 모델에 삽입됩니다 . 이 함수의 기본 구현은 모델의 데이터를 덮어 쓰지 않습니다. 대신 데이터의 항목을 항목의 형제 또는 해당 항목의 하위 항목으로 삽입하려고합니다.</target>
        </trans-unit>
        <trans-unit id="beb64bc37ef9e620c83f8575bbe6997166c3df77" translate="yes" xml:space="preserve">
          <source>When set on the characterFormat of a selection, the whole width of the text will be shown selected.</source>
          <target state="translated">선택의 characterFormat에 설정하면 텍스트의 전체 너비가 선택된 것으로 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="270afeac1ae23334323cbd52bdb23f45e70ed478" translate="yes" xml:space="preserve">
          <source>When set to &lt;a href=&quot;qsensor#AxesOrientationMode-enum&quot;&gt;AutomaticOrientation&lt;/a&gt;, the reading values are automatically rotated when the screen orientation changes. In effect, the screen orientation is canceled out.</source>
          <target state="translated">&lt;a href=&quot;qsensor#AxesOrientationMode-enum&quot;&gt;AutomaticOrientation으로&lt;/a&gt; 설정 하면 화면 방향이 변경 될 때 판독 값이 자동으로 회전합니다. 실제로 화면 방향이 취소됩니다.</target>
        </trans-unit>
        <trans-unit id="e194e2df3cef00cb337af8c19d0b1fb4566ff905" translate="yes" xml:space="preserve">
          <source>When set to &lt;a href=&quot;qsensor#AxesOrientationMode-enum&quot;&gt;FixedOrientation&lt;/a&gt;, which is the default mode, no automatic rotation is applied to the reading. This is the only mode available for backends that do not support the &lt;a href=&quot;qsensor#Feature-enum&quot;&gt;QSensor::AxesOrientation&lt;/a&gt; feature.</source>
          <target state="translated">기본 모드 인 &lt;a href=&quot;qsensor#AxesOrientationMode-enum&quot;&gt;FixedOrientation으로&lt;/a&gt; 설정 하면 판독 값에 자동 회전이 적용되지 않습니다. &lt;a href=&quot;qsensor#Feature-enum&quot;&gt;QSensor :: AxesOrientation&lt;/a&gt; 기능을 지원하지 않는 백엔드에 사용할 수있는 유일한 모드 입니다.</target>
        </trans-unit>
        <trans-unit id="f1c4e86e296a0003f811fe8398c8194c0172e276" translate="yes" xml:space="preserve">
          <source>When set to &lt;code&gt;transparent&lt;/code&gt;, no filling occurs.</source>
          <target state="translated">&lt;code&gt;transparent&lt;/code&gt; 로 설정하면 충전이 발생하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="a494091a2d78c1c83239a6f4b1f78cd17e064c58" translate="yes" xml:space="preserve">
          <source>When set to &lt;code&gt;transparent&lt;/code&gt;, no stroking occurs.</source>
          <target state="translated">&lt;code&gt;transparent&lt;/code&gt; 로 설정하면 쓰 로킹이 발생하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="d01263f2091d195480c96c2d03450e33391dffb1" translate="yes" xml:space="preserve">
          <source>When set to &lt;code&gt;true&lt;/code&gt;, the exterior of the item is padded with a 1 pixel wide transparent edge, making sampling outside the source texture use transparency instead of the edge pixels. Without this property, an image which has opaque edges will not get a blurred shadow.</source>
          <target state="translated">&lt;code&gt;true&lt;/code&gt; 로 설정 하면 항목 외부에 1 픽셀 너비의 투명 가장자리가 채워져 소스 텍스처 외부의 샘플링에 가장자리 픽셀 대신 투명도가 사용됩니다. 이 속성이 없으면 가장자리가 불투명 한 이미지에 그림자가 흐려지지 않습니다.</target>
        </trans-unit>
        <trans-unit id="b450467a36089b6e8cc7c9384688033053a7e1e0" translate="yes" xml:space="preserve">
          <source>When set to &lt;code&gt;true&lt;/code&gt;, the exterior of the item is padded with a transparent edge, making sampling outside the source texture use transparency instead of the edge pixels. Without this property, an image which has opaque edges will not get a blurred edge.</source>
          <target state="translated">&lt;code&gt;true&lt;/code&gt; 로 설정 하면 항목 외부에 투명한 가장자리가 채워 지므로 소스 텍스처 외부에서 샘플링 할 때 가장자리 픽셀 대신 투명도가 사용됩니다. 이 속성이 없으면 가장자리가 불투명 한 이미지는 가장자리가 흐려지지 않습니다.</target>
        </trans-unit>
        <trans-unit id="e4147d132167beace31a7c2f2898d532610dfada" translate="yes" xml:space="preserve">
          <source>When set to &lt;code&gt;true&lt;/code&gt;, the mapping ignores any explicitly set column categories and overwrites them with automatically generated ones whenever the data from model is resolved. Defaults to &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;true&lt;/code&gt; 로 설정되면 매핑은 명시 적으로 설정된 열 범주를 무시하고 모델의 데이터가 분석 될 때마다 자동으로 생성 된 열 범주로 덮어 씁니다. 기본값은 &lt;code&gt;true&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="36e27ee6dcb20f63a267c063b5f0dd2344ea8112" translate="yes" xml:space="preserve">
          <source>When set to &lt;code&gt;true&lt;/code&gt;, the mapping ignores any explicitly set column categories and overwrites them with automatically generated ones whenever the data from the model is resolved. Defaults to &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;true&lt;/code&gt; 로 설정되면 매핑은 명시 적으로 설정된 열 범주를 무시하고 모델의 데이터가 분석 될 때마다 자동으로 생성 된 열 범주로 덮어 씁니다. 기본값은 &lt;code&gt;true&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="aeaf1add3a3c03b3752ea390e4de636b57ce02e7" translate="yes" xml:space="preserve">
          <source>When set to &lt;code&gt;true&lt;/code&gt;, the mapping ignores any explicitly set column categories and overwrites them with automatically generated ones whenever the data from the model is resolved. Proxy minimum and maximum column values are also autogenerated from the data when this is set to &lt;code&gt;true&lt;/code&gt;. Defaults to &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;true&lt;/code&gt; 로 설정되면 매핑은 명시 적으로 설정된 열 범주를 무시하고 모델의 데이터가 분석 될 때마다 자동으로 생성 된 열 범주로 덮어 씁니다. 이 값이 &lt;code&gt;true&lt;/code&gt; 로 설정되면 프록시 최소 및 최대 열 값도 데이터에서 자동 생성됩니다 . 기본값은 &lt;code&gt;true&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="c86619e8213d5bed1738d02c582750355d6522a4" translate="yes" xml:space="preserve">
          <source>When set to &lt;code&gt;true&lt;/code&gt;, the mapping ignores any explicitly set row categories and overwrites them with automatically generated ones whenever the data from model is resolved. Defaults to &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;true&lt;/code&gt; 로 설정되면 맵핑은 명시 적으로 설정된 행 카테고리를 무시하고 모델의 데이터가 분석 될 때마다 자동으로 생성 된 카테고리를 겹쳐 씁니다. 기본값은 &lt;code&gt;true&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="d11c86fa7ccfd6ba9e683cd50f0c094403577ac1" translate="yes" xml:space="preserve">
          <source>When set to &lt;code&gt;true&lt;/code&gt;, the mapping ignores any explicitly set row categories and overwrites them with automatically generated ones whenever the data from the model is resolved. Defaults to &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;true&lt;/code&gt; 로 설정되면 맵핑은 명시 적으로 설정된 행 카테고리를 무시하고 모델의 데이터가 분석 될 때마다 자동으로 생성 된 카테고리를 겹쳐 씁니다. 기본값은 &lt;code&gt;true&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="1301757ff1650814b570b349ec4348010d05817d" translate="yes" xml:space="preserve">
          <source>When set to &lt;code&gt;true&lt;/code&gt;, the mapping ignores any explicitly set row categories and overwrites them with automatically generated ones whenever the data from the model is resolved. Proxy minimum and maximum row values are also autogenerated from the data when this is set to &lt;code&gt;true&lt;/code&gt;. Defaults to &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;true&lt;/code&gt; 로 설정되면 맵핑은 명시 적으로 설정된 행 카테고리를 무시하고 모델의 데이터가 분석 될 때마다 자동으로 생성 된 카테고리를 겹쳐 씁니다. 이 값이 &lt;code&gt;true&lt;/code&gt; 로 설정되면 프록시 최소 및 최대 행 값도 데이터에서 자동 생성됩니다 . 기본값은 &lt;code&gt;true&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="7acc0959296f9d8e8c2e2b6cb1d3a66719167a16" translate="yes" xml:space="preserve">
          <source>When set to &lt;code&gt;true&lt;/code&gt;, the mapping ignores row and column roles and categories, and uses the rows and columns from the model instead. Defaults to &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;true&lt;/code&gt; 로 설정되면 매핑은 행 및 열 역할 및 범주를 무시하고 대신 모델의 행 및 열을 사용합니다. 기본값은 &lt;code&gt;false&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="5f951719e1af643c50c67762d555cf0e850cebdd" translate="yes" xml:space="preserve">
          <source>When set to &lt;code&gt;true&lt;/code&gt;, the mapping ignores row and column roles and categories, and uses the rows and columns from the model instead. Row and column headers are used for row and column labels. Defaults to &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;true&lt;/code&gt; 로 설정되면 매핑은 행 및 열 역할 및 범주를 무시하고 대신 모델의 행 및 열을 사용합니다. 행 및 열 머리글은 행 및 열 레이블에 사용됩니다. 기본값은 &lt;code&gt;false&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="3496a774f53b66ac5b73d84b633a1d9d7d924d85" translate="yes" xml:space="preserve">
          <source>When set to a negative value, no stroking occurs.</source>
          <target state="translated">음수 값으로 설정하면 스트로크가 발생하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="4e4ee14f2ec2d88c31367b1d93f593e8267881e4" translate="yes" xml:space="preserve">
          <source>When set to an empty string, the default label of the underlying platform is used. The default label is typically &lt;b&gt;Cancel&lt;/b&gt;.</source>
          <target state="translated">빈 문자열로 설정하면 기본 플랫폼의 기본 레이블이 사용됩니다. 기본 레이블은 일반적으로 &lt;b&gt;취소&lt;/b&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="71b7a30cacf1f3a3ee6a4172e8fb4bd21a402ed0" translate="yes" xml:space="preserve">
          <source>When set to an empty string, the default label of the underlying platform is used. The default label is typically &lt;b&gt;Open&lt;/b&gt; or &lt;b&gt;Save&lt;/b&gt; depending on which &lt;a href=&quot;qml-qt-labs-platform-filedialog#fileMode-prop&quot;&gt;fileMode&lt;/a&gt; the dialog is used in.</source>
          <target state="translated">빈 문자열로 설정하면 기본 플랫폼의 기본 레이블이 사용됩니다. 기본 레이블은 일반적으로 &lt;b&gt;열기&lt;/b&gt; 또는 &lt;b&gt;저장&lt;/b&gt; 에 따라 &lt;a href=&quot;qml-qt-labs-platform-filedialog#fileMode-prop&quot;&gt;대한 fileMode&lt;/a&gt; 대화 상자가 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="fa9215824a888cc448b2b5104b3e0edb6ca3f827" translate="yes" xml:space="preserve">
          <source>When set to an empty string, the default label of the underlying platform is used. The default label is typically &lt;b&gt;Open&lt;/b&gt;.</source>
          <target state="translated">빈 문자열로 설정하면 기본 플랫폼의 기본 레이블이 사용됩니다. 기본 레이블은 일반적으로 &lt;b&gt;Open&lt;/b&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="da31d475a6141d1527e3930e3b780117133be781" translate="yes" xml:space="preserve">
          <source>When set to true, a connection is made to the server with the given url. When set to false, the connection is closed. The default value is false.</source>
          <target state="translated">true로 설정하면 지정된 URL을 사용하여 서버에 연결됩니다. false로 설정하면 연결이 닫힙니다. 기본값은 false입니다.</target>
        </trans-unit>
        <trans-unit id="d356d95380e0a7be709c939454d729283fff95fe" translate="yes" xml:space="preserve">
          <source>When set to true, updates are blocked and remote clients will not be notified about property changes.</source>
          <target state="translated">true로 설정하면 업데이트가 차단되고 속성 변경에 대한 원격 클라이언트에 알림이 표시되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="9070c24af14ff16b55ce450d03070776a1d63544" translate="yes" xml:space="preserve">
          <source>When set, &lt;a href=&quot;qml-qtquick-shapes-shapepath&quot;&gt;ShapePath&lt;/a&gt;.&lt;a href=&quot;qml-qtquick-shapes-shapepath#fillColor-prop&quot;&gt;fillColor&lt;/a&gt; is ignored and filling is done using one of the &lt;a href=&quot;qml-qtquick-shapes-shapegradient&quot;&gt;ShapeGradient&lt;/a&gt; subtypes.</source>
          <target state="translated">설정하면 &lt;a href=&quot;qml-qtquick-shapes-shapepath&quot;&gt;ShapePath&lt;/a&gt; 입니다. &lt;a href=&quot;qml-qtquick-shapes-shapepath#fillColor-prop&quot;&gt;fillColor&lt;/a&gt; 는 무시되고 &lt;a href=&quot;qml-qtquick-shapes-shapegradient&quot;&gt;ShapeGradient&lt;/a&gt; 하위 유형 중 하나를 사용하여 채우기가 수행됩니다 .</target>
        </trans-unit>
        <trans-unit id="1d5a93253ef1915d6faa59a1fad7ff2aba883814" translate="yes" xml:space="preserve">
          <source>When set, &lt;code&gt;eglfs&lt;/code&gt; requests &lt;code&gt;FBIO_WAITFORVSYNC&lt;/code&gt; on the framebuffer device after each call to eglSwapBuffers(). This variable is only relevant for backends relying on the legacy Linux &lt;code&gt;fbdev&lt;/code&gt; subsystem. Normally, with a default swap interval of 1, Qt assumes that calling eglSwapBuffers() takes care of vsync; if it doesn't (for example, due to driver bugs), try setting &lt;code&gt;QT_QPA_EGLFS_FORCEVSYNC&lt;/code&gt; to a non-zero value.</source>
          <target state="translated">세트 때 &lt;code&gt;eglfs&lt;/code&gt; 가 요청 &lt;code&gt;FBIO_WAITFORVSYNC&lt;/code&gt; 을 eglSwapBuffers 각 호출 이후 프레임 버퍼 장치 (). 이 변수는 레거시 Linux &lt;code&gt;fbdev&lt;/code&gt; 하위 시스템 에 의존하는 백엔드에만 해당됩니다 . 일반적으로 기본 스왑 간격이 1 인 Qt는 eglSwapBuffers () 호출이 vsync를 처리한다고 가정합니다. 그렇지 않은 경우 (예를 들어 드라이버 버그로 인해) &lt;code&gt;QT_QPA_EGLFS_FORCEVSYNC&lt;/code&gt; 를 0이 아닌 값으로 설정하십시오.</target>
        </trans-unit>
        <trans-unit id="9744299b5e8df688636dffff69d9ac6cfe828468" translate="yes" xml:space="preserve">
          <source>When set, a search and replace is done on the value mapped by column role before it is used as a column category. This property specifies the regular expression to find the portion of the mapped value to replace and &lt;a href=&quot;qml-qtdatavisualization-itemmodelbardataproxy#columnRoleReplace-prop&quot;&gt;columnRoleReplace&lt;/a&gt; property contains the replacement string. This is useful for example in parsing row and column categories from a single timestamp field in the item model.</source>
          <target state="translated">설정되면, 검색 및 바꾸기는 열 카테고리로 사용되기 전에 열 역할에 의해 맵핑 된 값에 대해 수행됩니다. 이 특성은 대체 할 맵핑 된 값의 부분을 찾기 위해 정규식을 지정하고 &lt;a href=&quot;qml-qtdatavisualization-itemmodelbardataproxy#columnRoleReplace-prop&quot;&gt;columnRoleReplace&lt;/a&gt; 특성은 대체 문자열을 포함합니다. 예를 들어 항목 모델의 단일 타임 스탬프 필드에서 행 및 열 범주를 구문 분석 할 때 유용합니다.</target>
        </trans-unit>
        <trans-unit id="8a131bdf52627ee3b863efe9743b906a421ee8f9" translate="yes" xml:space="preserve">
          <source>When set, a search and replace is done on the value mapped by rotation role before it is used as a bar rotation angle. This property specifies the regular expression to find the portion of the mapped value to replace and &lt;a href=&quot;qml-qtdatavisualization-itemmodelbardataproxy#rotationRoleReplace-prop&quot;&gt;rotationRoleReplace&lt;/a&gt; property contains the replacement string.</source>
          <target state="translated">설정된 경우 검색 및 바꾸기는 회전 각도로 매핑되기 전에 회전 역할로 매핑 된 값에서 수행됩니다. 이 속성은 대체 할 매핑 된 값 부분을 찾기 위해 정규식을 지정하고 &lt;a href=&quot;qml-qtdatavisualization-itemmodelbardataproxy#rotationRoleReplace-prop&quot;&gt;rotationRoleReplace&lt;/a&gt; 속성에는 대체 문자열이 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="9108433232a1c54c0f0add6d2c59552f382b7483" translate="yes" xml:space="preserve">
          <source>When set, a search and replace is done on the value mapped by row role before it is used as a row category. This property specifies the regular expression to find the portion of the mapped value to replace and &lt;a href=&quot;qml-qtdatavisualization-itemmodelbardataproxy#rowRoleReplace-prop&quot;&gt;rowRoleReplace&lt;/a&gt; property contains the replacement string. This is useful for example in parsing row and column categories from a single timestamp field in the item model.</source>
          <target state="translated">설정되면, 검색 및 바꾸기는 행 카테고리로 사용되기 전에 행 역할로 맵핑 된 값에서 수행됩니다. 이 특성은 대체 할 맵핑 된 값의 부분을 찾기 위해 정규식을 지정하고 &lt;a href=&quot;qml-qtdatavisualization-itemmodelbardataproxy#rowRoleReplace-prop&quot;&gt;rowRoleReplace&lt;/a&gt; 특성은 대체 문자열을 포함합니다. 예를 들어 항목 모델의 단일 타임 스탬프 필드에서 행 및 열 범주를 구문 분석 할 때 유용합니다.</target>
        </trans-unit>
        <trans-unit id="bc9c1cbcb787214aaefb29b1ef7ac7fde2064a50" translate="yes" xml:space="preserve">
          <source>When set, a search and replace is done on the value mapped by the column role before it is used as a column category. This property specifies the regular expression to find the portion of the mapped value to replace and the &lt;a href=&quot;qml-qtdatavisualization-itemmodelsurfacedataproxy#columnRoleReplace-prop&quot;&gt;columnRoleReplace&lt;/a&gt; property contains the replacement string.</source>
          <target state="translated">설정되면 검색 및 바꾸기는 열 카테고리로 사용되기 전에 열 역할에 의해 맵핑 된 값에서 수행됩니다. 이 특성은 대체 할 맵핑 된 값의 부분을 찾기 위해 정규식을 지정하고 &lt;a href=&quot;qml-qtdatavisualization-itemmodelsurfacedataproxy#columnRoleReplace-prop&quot;&gt;columnRoleReplace&lt;/a&gt; 특성은 대체 문자열을 포함합니다.</target>
        </trans-unit>
        <trans-unit id="6c6f75996ea55b81eb144da97f4ddbf1f7b8d2df" translate="yes" xml:space="preserve">
          <source>When set, a search and replace is done on the value mapped by the rotation role before it is used as item rotation. This property specifies the regular expression to find the portion of the mapped value to replace and &lt;a href=&quot;qml-qtdatavisualization-itemmodelscatterdataproxy#rotationRoleReplace-prop&quot;&gt;rotationRoleReplace&lt;/a&gt; property contains the replacement string.</source>
          <target state="translated">설정되면 검색 및 바꾸기는 항목 회전으로 사용되기 전에 회전 역할에 의해 매핑 된 값에서 수행됩니다. 이 속성은 대체 할 매핑 된 값 부분을 찾기 위해 정규식을 지정하고 &lt;a href=&quot;qml-qtdatavisualization-itemmodelscatterdataproxy#rotationRoleReplace-prop&quot;&gt;rotationRoleReplace&lt;/a&gt; 속성에는 대체 문자열이 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="4d7bce4ff7100e6fa830173aafe199aab62b818f" translate="yes" xml:space="preserve">
          <source>When set, a search and replace is done on the value mapped by the row role before it is used as a row category. This property specifies the regular expression to find the portion of the mapped value to replace and the &lt;a href=&quot;qml-qtdatavisualization-itemmodelsurfacedataproxy#rowRoleReplace-prop&quot;&gt;rowRoleReplace&lt;/a&gt; property contains the replacement string.</source>
          <target state="translated">설정되면 행 범주로 사용되기 전에 행 역할에 의해 맵핑 된 값에 대해 검색 및 바꾸기가 수행됩니다. 이 특성은 대체 할 맵핑 된 값의 부분을 찾기 위해 정규식을 지정하고 &lt;a href=&quot;qml-qtdatavisualization-itemmodelsurfacedataproxy#rowRoleReplace-prop&quot;&gt;rowRoleReplace&lt;/a&gt; 특성은 대체 문자열을 포함합니다.</target>
        </trans-unit>
        <trans-unit id="885cf3aa8085356e119ac0af240743c4239afe83" translate="yes" xml:space="preserve">
          <source>When set, a search and replace is done on the value mapped by the x position role before it is used as an item position value. This property specifies the regular expression to find the portion of the mapped value to replace and &lt;a href=&quot;qml-qtdatavisualization-itemmodelscatterdataproxy#xPosRoleReplace-prop&quot;&gt;xPosRoleReplace&lt;/a&gt; property contains the replacement string.</source>
          <target state="translated">설정되면 x 위치 역할에 의해 맵핑 된 값에서 항목 위치 값으로 사용되기 전에 검색 및 바꾸기가 수행됩니다. 이 특성은 대체 할 맵핑 된 값의 부분을 찾기 위해 정규식을 지정하고 &lt;a href=&quot;qml-qtdatavisualization-itemmodelscatterdataproxy#xPosRoleReplace-prop&quot;&gt;xPosRoleReplace&lt;/a&gt; 특성은 대체 문자열을 포함합니다.</target>
        </trans-unit>
        <trans-unit id="66303afda7fe28b42306b119120f8c9d8ffe13b2" translate="yes" xml:space="preserve">
          <source>When set, a search and replace is done on the value mapped by the x position role before it is used as an item position value. This property specifies the regular expression to find the portion of the mapped value to replace and the &lt;a href=&quot;qml-qtdatavisualization-itemmodelsurfacedataproxy#xPosRoleReplace-prop&quot;&gt;xPosRoleReplace&lt;/a&gt; property contains the replacement string.</source>
          <target state="translated">설정되면 x 위치 역할에 의해 맵핑 된 값에서 항목 위치 값으로 사용되기 전에 검색 및 바꾸기가 수행됩니다. 이 특성은 대체 할 맵핑 된 값의 부분을 찾기 위해 정규식을 지정하고 &lt;a href=&quot;qml-qtdatavisualization-itemmodelsurfacedataproxy#xPosRoleReplace-prop&quot;&gt;xPosRoleReplace&lt;/a&gt; 특성은 대체 문자열을 포함합니다.</target>
        </trans-unit>
        <trans-unit id="177b7625ed57441e9caab15b1ba52de1056c1697" translate="yes" xml:space="preserve">
          <source>When set, a search and replace is done on the value mapped by the y position role before it is used as an item position value. This property specifies the regular expression to find the portion of the mapped value to replace and &lt;a href=&quot;qml-qtdatavisualization-itemmodelscatterdataproxy#yPosRoleReplace-prop&quot;&gt;yPosRoleReplace&lt;/a&gt; property contains the replacement string.</source>
          <target state="translated">설정되면, 검색 및 바꾸기는 항목 위치 값으로 사용되기 전에 y 위치 역할에 의해 맵핑 된 값에서 수행됩니다. 이 특성은 대체 할 맵핑 된 값의 부분을 찾기 위해 정규식을 지정하고 &lt;a href=&quot;qml-qtdatavisualization-itemmodelscatterdataproxy#yPosRoleReplace-prop&quot;&gt;yPosRoleReplace&lt;/a&gt; 특성은 대체 문자열을 포함합니다.</target>
        </trans-unit>
        <trans-unit id="4cd4628ea893e9ef8db7b0e103b8b8eb84582ee7" translate="yes" xml:space="preserve">
          <source>When set, a search and replace is done on the value mapped by the y position role before it is used as an item position value. This property specifies the regular expression to find the portion of the mapped value to replace and the &lt;a href=&quot;qml-qtdatavisualization-itemmodelsurfacedataproxy#yPosRoleReplace-prop&quot;&gt;yPosRoleReplace&lt;/a&gt; property contains the replacement string.</source>
          <target state="translated">설정되면, 검색 및 바꾸기는 항목 위치 값으로 사용되기 전에 y 위치 역할에 의해 맵핑 된 값에서 수행됩니다. 이 특성은 대체 할 맵핑 된 값의 부분과 &lt;a href=&quot;qml-qtdatavisualization-itemmodelsurfacedataproxy#yPosRoleReplace-prop&quot;&gt;yPosRoleReplace&lt;/a&gt; 를 찾기위한 정규식을 지정합니다. 특성은 대체 문자열을 포함합니다.</target>
        </trans-unit>
        <trans-unit id="e690058b1d8c0f0ea729f77975b58803689a29ce" translate="yes" xml:space="preserve">
          <source>When set, a search and replace is done on the value mapped by the z position role before it is used as an item position value. This property specifies the regular expression to find the portion of the mapped value to replace and &lt;a href=&quot;qml-qtdatavisualization-itemmodelscatterdataproxy#zPosRoleReplace-prop&quot;&gt;zPosRoleReplace&lt;/a&gt; property contains the replacement string.</source>
          <target state="translated">설정되면, 검색 및 바꾸기는 항목 위치 값으로 사용되기 전에 z 위치 역할에 의해 맵핑 된 값에서 수행됩니다. 이 특성은 대체 할 맵핑 된 값의 부분을 찾기 위해 정규식을 지정하고 &lt;a href=&quot;qml-qtdatavisualization-itemmodelscatterdataproxy#zPosRoleReplace-prop&quot;&gt;zPosRoleReplace&lt;/a&gt; 특성은 대체 문자열을 포함합니다.</target>
        </trans-unit>
        <trans-unit id="8a50a48a136eb418621caa5d9975fa8698821525" translate="yes" xml:space="preserve">
          <source>When set, a search and replace is done on the value mapped by the z position role before it is used as an item position value. This property specifies the regular expression to find the portion of the mapped value to replace and the &lt;a href=&quot;qml-qtdatavisualization-itemmodelsurfacedataproxy#zPosRoleReplace-prop&quot;&gt;zPosRoleReplace&lt;/a&gt; property contains the replacement string.</source>
          <target state="translated">설정되면, 검색 및 바꾸기는 z 위치 역할이 맵핑 한 값에서 항목 위치 값으로 사용되기 전에 수행됩니다. 이 특성은 대체 할 맵핑 된 값의 부분을 찾기 위해 정규식을 지정하고 &lt;a href=&quot;qml-qtdatavisualization-itemmodelsurfacedataproxy#zPosRoleReplace-prop&quot;&gt;zPosRoleReplace&lt;/a&gt; 특성은 대체 문자열을 포함합니다.</target>
        </trans-unit>
        <trans-unit id="9e6e26fa69d41d9769f5fde960eb52cd2c8473db" translate="yes" xml:space="preserve">
          <source>When set, a search and replace is done on the value mapped by value role before it is used as a bar value. This property specifies the regular expression to find the portion of the mapped value to replace and &lt;a href=&quot;qml-qtdatavisualization-itemmodelbardataproxy#valueRoleReplace-prop&quot;&gt;valueRoleReplace&lt;/a&gt; property contains the replacement string.</source>
          <target state="translated">설정된 경우 검색 및 바꾸기는 막대 값으로 사용되기 전에 값 역할에 의해 매핑 된 값에서 수행됩니다. 이 특성은 대체 할 맵핑 된 값의 부분을 찾기 위해 정규식을 지정하고 &lt;a href=&quot;qml-qtdatavisualization-itemmodelbardataproxy#valueRoleReplace-prop&quot;&gt;valueRoleReplace&lt;/a&gt; 특성은 대체 문자열을 포함합니다.</target>
        </trans-unit>
        <trans-unit id="57e671691d58c18370650113c81b9894428ab1c0" translate="yes" xml:space="preserve">
          <source>When set, some debugging information is printed on the debug output. For example, the input &lt;a href=&quot;qsurfaceformat&quot;&gt;QSurfaceFormat&lt;/a&gt; and the properties of the chosen EGL configuration are printed while creating a new context. When used together with Qt Quick's &lt;code&gt;QSG_INFO&lt;/code&gt; variable, you can get useful information for troubleshooting issues related to the EGL configuration.</source>
          <target state="translated">설정하면 일부 디버깅 정보가 디버그 출력에 인쇄됩니다. 예를 들어, 새 컨텍스트를 작성하는 동안 입력 &lt;a href=&quot;qsurfaceformat&quot;&gt;QSurfaceFormat&lt;/a&gt; 및 선택한 EGL 구성의 특성이 인쇄됩니다. Qt Quick의 &lt;code&gt;QSG_INFO&lt;/code&gt; 변수 와 함께 사용 하면 EGL 구성과 관련된 문제 해결에 유용한 정보를 얻을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c63ec68c079a9bce145854c06f681928a4a99fb9" translate="yes" xml:space="preserve">
          <source>When set, the red, green, and blue color channel sizes are ignored when &lt;code&gt;eglfs&lt;/code&gt; creates a new context, window or offscreen surface. Instead, the plugin requests a configuration with 8 bits per channel. This can be helpful on devices where configurations with less than 32 or 24 bits per pixel (for example, 5-6-5 or 4-4-4) are chosen by default despite knowing they are not ideal, for example, due to banding effects. Instead of changing application code, this variable provides a shortcut to force 24 or 32 bpp configurations.</source>
          <target state="translated">설정하면 &lt;code&gt;eglfs&lt;/code&gt; 가 새로운 컨텍스트, 창 또는 화면 외부 표면을 만들 때 빨강, 녹색 및 파랑 채널 크기가 무시됩니다 . 대신, 플러그인은 채널당 8 비트로 구성을 요청합니다. 이는 예를 들어 밴딩으로 인해 이상적이지 않다는 사실에도 불구하고 픽셀 당 32 또는 24 비트 미만의 구성 (예 : 5-6-5 또는 4-4-4)을 선택하는 장치에서 유용 할 수 있습니다. 효과. 응용 프로그램 코드를 변경하는 대신이 변수는 24 또는 32bpp 구성을 강제 실행하는 바로 가기를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="33b3bd9431a5daf3aec6eea2743d997f576dc8d8" translate="yes" xml:space="preserve">
          <source>When setting &lt;a href=&quot;qml-qtquick-item#clip-prop&quot;&gt;Item::clip&lt;/a&gt; to true, it will create a &lt;a href=&quot;qsgclipnode&quot;&gt;QSGClipNode&lt;/a&gt; with a rectangle in its geometry. The default renderer will apply this clip by using scissoring in OpenGL. If the item is rotated by a non-90-degree angle, the OpenGL's stencil buffer is used. Qt Quick Item only supports setting a rectangle as clip through QML, but the scene graph API and the default renderer can use any shape for clipping.</source>
          <target state="translated">&lt;a href=&quot;qml-qtquick-item#clip-prop&quot;&gt;Item :: clip&lt;/a&gt; 을 true로 설정하면 기하학에 사각형이 있는 &lt;a href=&quot;qsgclipnode&quot;&gt;QSGClipNode&lt;/a&gt; 가 작성됩니다 . 기본 렌더러는 OpenGL에서 가위를 사용하여이 클립을 적용합니다. 항목이 90 도가 아닌 각도로 회전하면 OpenGL의 스텐실 버퍼가 사용됩니다. Qt Quick Item은 QML을 통해 사각형을 클립으로 설정하는 것만 지원하지만 장면 그래프 API와 기본 렌더러는 클리핑에 모든 모양을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a5ed62e892daca59bcdf47a39598aaed448ddccb" translate="yes" xml:space="preserve">
          <source>When setting a maximum date, the &lt;a href=&quot;qcalendarwidget#minimumDate-prop&quot;&gt;minimumDate&lt;/a&gt; and &lt;a href=&quot;qcalendarwidget#selectedDate-prop&quot;&gt;selectedDate&lt;/a&gt; properties are adjusted if the selection range becomes invalid. If the provided date is not a valid &lt;a href=&quot;qdate&quot;&gt;QDate&lt;/a&gt; object, the setMaximumDate() function does nothing.</source>
          <target state="translated">최대 날짜를 설정할 때 선택 범위가 유효하지 않으면 &lt;a href=&quot;qcalendarwidget#minimumDate-prop&quot;&gt;minimumDate&lt;/a&gt; 및 &lt;a href=&quot;qcalendarwidget#selectedDate-prop&quot;&gt;selectedDate&lt;/a&gt; 속성이 조정됩니다. 제공된 날짜가 유효한 &lt;a href=&quot;qdate&quot;&gt;QDate&lt;/a&gt; 오브젝트 가 아닌 경우 setMaximumDate () 함수는 아무 것도 수행하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="c4ae2d023320be5119694dfde25d7c2125941c8d" translate="yes" xml:space="preserve">
          <source>When setting a minimum date, the &lt;a href=&quot;qcalendarwidget#maximumDate-prop&quot;&gt;maximumDate&lt;/a&gt; and &lt;a href=&quot;qcalendarwidget#selectedDate-prop&quot;&gt;selectedDate&lt;/a&gt; properties are adjusted if the selection range becomes invalid. If the provided date is not a valid &lt;a href=&quot;qdate&quot;&gt;QDate&lt;/a&gt; object, the setMinimumDate() function does nothing.</source>
          <target state="translated">최소 날짜를 설정할 때 선택 범위가 유효하지 않으면 &lt;a href=&quot;qcalendarwidget#maximumDate-prop&quot;&gt;maximumDate&lt;/a&gt; 및 &lt;a href=&quot;qcalendarwidget#selectedDate-prop&quot;&gt;selectedDate&lt;/a&gt; 속성이 조정됩니다. 제공된 날짜가 유효한 &lt;a href=&quot;qdate&quot;&gt;QDate&lt;/a&gt; 오브젝트 가 아닌 경우 setMinimumDate () 함수는 아무 것도 수행하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="6eeb8a01ae2a0c99098eee6b5e541fd874b03835" translate="yes" xml:space="preserve">
          <source>When setting the fragment or vertex shader source code, the status will become Uncompiled. The first time the &lt;a href=&quot;qml-qtquick-shadereffect&quot;&gt;ShaderEffect&lt;/a&gt; is rendered with new shader source code, the shaders are compiled and linked, and the status is updated to Compiled or Error.</source>
          <target state="translated">프래그먼트 또는 버텍스 셰이더 소스 코드를 설정하면 상태가 컴파일되지 않은 상태가됩니다. 처음 &lt;a href=&quot;qml-qtquick-shadereffect&quot;&gt;ShaderEffect이&lt;/a&gt; 새로운 쉐이더 소스 코드와 함께 렌더링은, 쉐이더 컴파일 및 링크, 그리고 상태가 컴파일 또는 오류로 업데이트된다.</target>
        </trans-unit>
        <trans-unit id="12bc8cc3889504df656aec89fdae8d32b48b48bd" translate="yes" xml:space="preserve">
          <source>When setting the pick method to &lt;a href=&quot;qt3drender-qpickingsettings#PickResultMode-enum&quot;&gt;AllPicks&lt;/a&gt;, events will be triggered for all the entities with a &lt;a href=&quot;qt3drender-qobjectpicker&quot;&gt;QObjectPicker&lt;/a&gt; along the ray.</source>
          <target state="translated">pick 메소드를 &lt;a href=&quot;qt3drender-qpickingsettings#PickResultMode-enum&quot;&gt;AllPicks로&lt;/a&gt; 설정 하면 광선을 따라 &lt;a href=&quot;qt3drender-qobjectpicker&quot;&gt;QObjectPicker&lt;/a&gt; 가있는 모든 엔티티에 대해 이벤트가 트리거됩니다 .</target>
        </trans-unit>
        <trans-unit id="faf0f4e80eb610da479dd49899491179142a9cfd" translate="yes" xml:space="preserve">
          <source>When setting the pick method to &lt;a href=&quot;qt3drender-qpickingsettings#PickResultMode-enum&quot;&gt;NearestPriorityPick&lt;/a&gt;, events will be triggered for the nearest highest priority picker. This can be used when a given element should always be selected even if others are in front of it.</source>
          <target state="translated">pick 메소드를 &lt;a href=&quot;qt3drender-qpickingsettings#PickResultMode-enum&quot;&gt;NearestPriorityPick으로&lt;/a&gt; 설정하면 가장 가까운 우선 순위가 높은 피커에 대해 이벤트가 트리거됩니다. 다른 요소가 앞에있는 경우에도 주어진 요소를 항상 선택해야 할 때 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="46eaad0ccb2bedbfcbdda653384c06947cbb2dbb" translate="yes" xml:space="preserve">
          <source>When setting the year using the Date constructor or set(UTC)FullYear(), the convention set by ISO 8601 is used and 0 is a valid year. This means negative years set with the constructor or set(UTC)FullYear() are zero-based and thus offset by one year from what is printed with toString() and friends. Parsing the output of any of the to*String() methods will yield the same date value you printed from. Date.parse() will recognize the different formats and their convention on the existence of year 0.</source>
          <target state="translated">Date 생성자 또는 set (UTC) FullYear ()를 사용하여 연도를 설정할 때는 ISO 8601에서 설정 한 규칙이 사용되며 0은 유효한 연도입니다. 이것은 생성자 또는 set (UTC) FullYear ()로 설정된 음의 연도는 0부터 시작하므로 toString () 및 friends로 인쇄 된 것으로부터 1 년 단위로 상쇄됩니다. to * String () 메소드의 출력을 구문 분석하면 인쇄 한 날짜 값과 동일한 값이 생성됩니다. Date.parse ()는 0 년의 존재에 대한 다양한 형식과 규칙을 인식합니다.</target>
        </trans-unit>
        <trans-unit id="99af14a2050e900c54b4cf4320044307dba2671c" translate="yes" xml:space="preserve">
          <source>When setting this property &lt;a href=&quot;qtextbrowser&quot;&gt;QTextBrowser&lt;/a&gt; tries to find a document with the specified name in the paths of the &lt;a href=&quot;qtextbrowser#searchPaths-prop&quot;&gt;searchPaths&lt;/a&gt; property and directory of the current source, unless the value is an absolute file path. It also checks for optional anchors and scrolls the document accordingly</source>
          <target state="translated">이 속성을 설정할 때 &lt;a href=&quot;qtextbrowser&quot;&gt;QTextBrowser&lt;/a&gt; 는 값이 절대 파일 경로가 아닌 한 &lt;a href=&quot;qtextbrowser#searchPaths-prop&quot;&gt;searchPaths&lt;/a&gt; 속성 의 경로 및 현재 소스의 디렉토리 에서 지정된 이름의 문서를 찾으려고합니다 . 또한 옵션 앵커를 확인하고 그에 따라 문서를 스크롤합니다.</target>
        </trans-unit>
        <trans-unit id="fce20a64ddb9efcd0a6072a5a5807d0354c99c5b" translate="yes" xml:space="preserve">
          <source>When setting this property the &lt;a href=&quot;qdatetimeedit#maximumDate-prop&quot;&gt;maximumDate&lt;/a&gt; is adjusted if necessary, to ensure that the range remains valid. If the date is not a valid &lt;a href=&quot;qdate&quot;&gt;QDate&lt;/a&gt; object, this function does nothing.</source>
          <target state="translated">이 속성을 설정할 때 필요한 경우 범위가 유효한지 확인하기 위해 &lt;a href=&quot;qdatetimeedit#maximumDate-prop&quot;&gt;maximumDate&lt;/a&gt; 가 조정됩니다. 날짜가 유효한 &lt;a href=&quot;qdate&quot;&gt;QDate&lt;/a&gt; 객체 가 아닌 경우이 함수는 아무 작업도 수행하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="f3536a246a03f23af815f636527d6ffa980281bd" translate="yes" xml:space="preserve">
          <source>When setting this property the &lt;a href=&quot;qdatetimeedit#maximumDateTime-prop&quot;&gt;maximumDateTime&lt;/a&gt;() is adjusted if necessary to ensure that the range remains valid. If the datetime is not a valid &lt;a href=&quot;qdatetime&quot;&gt;QDateTime&lt;/a&gt; object, this function does nothing.</source>
          <target state="translated">이 속성을 설정할 때 필요한 경우 범위가 유효한지 확인하기 위해 &lt;a href=&quot;qdatetimeedit#maximumDateTime-prop&quot;&gt;maximumDateTime&lt;/a&gt; ()이 조정됩니다. 날짜 시간이 유효한 &lt;a href=&quot;qdatetime&quot;&gt;QDateTime&lt;/a&gt; 오브젝트 가 아닌 경우이 함수는 아무 작업도 수행하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="1d3985b1214032de5548d5f37a050ce05224466f" translate="yes" xml:space="preserve">
          <source>When setting this property the &lt;a href=&quot;qdatetimeedit#maximumTime-prop&quot;&gt;maximumTime&lt;/a&gt; is adjusted if necessary, to ensure that the range remains valid. If the time is not a valid &lt;a href=&quot;qtime&quot;&gt;QTime&lt;/a&gt; object, this function does nothing.</source>
          <target state="translated">이 속성을 설정할 때 필요한 경우 range가 유효한지 확인하기 위해 &lt;a href=&quot;qdatetimeedit#maximumTime-prop&quot;&gt;maximumTime&lt;/a&gt; 이 조정됩니다. 시간이 유효한 &lt;a href=&quot;qtime&quot;&gt;QTime&lt;/a&gt; 객체 가 아닌 경우이 함수는 아무 작업도 수행하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="3a94d8175867d402a4937ec027013411408a4199" translate="yes" xml:space="preserve">
          <source>When setting this property the &lt;a href=&quot;qdatetimeedit#minimumDate-prop&quot;&gt;minimumDate&lt;/a&gt; is adjusted if necessary to ensure that the range remains valid. If the date is not a valid &lt;a href=&quot;qdate&quot;&gt;QDate&lt;/a&gt; object, this function does nothing.</source>
          <target state="translated">이 속성을 설정할 때 필요한 경우 범위가 유효한지 확인하기 위해 &lt;a href=&quot;qdatetimeedit#minimumDate-prop&quot;&gt;minimumDate&lt;/a&gt; 가 조정됩니다. 날짜가 유효한 &lt;a href=&quot;qdate&quot;&gt;QDate&lt;/a&gt; 객체 가 아닌 경우이 함수는 아무 작업도 수행하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="d00e3ae41e62b165ec366eabf69c76f997cb71bc" translate="yes" xml:space="preserve">
          <source>When setting this property the &lt;a href=&quot;qdatetimeedit#minimumDateTime-prop&quot;&gt;minimumDateTime&lt;/a&gt;() is adjusted if necessary to ensure that the range remains valid. If the datetime is not a valid &lt;a href=&quot;qdatetime&quot;&gt;QDateTime&lt;/a&gt; object, this function does nothing.</source>
          <target state="translated">이 속성을 설정할 때 필요한 경우 범위가 유효한지 확인하기 위해 &lt;a href=&quot;qdatetimeedit#minimumDateTime-prop&quot;&gt;minimumDateTime&lt;/a&gt; ()이 조정됩니다. 날짜 시간이 유효한 &lt;a href=&quot;qdatetime&quot;&gt;QDateTime&lt;/a&gt; 오브젝트 가 아닌 경우이 함수는 아무 작업도 수행하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="fd101378453eccdf2e848a4824798dd5c0a85b7e" translate="yes" xml:space="preserve">
          <source>When setting this property the &lt;a href=&quot;qdoublespinbox#maximum-prop&quot;&gt;maximum&lt;/a&gt; is adjusted if necessary to ensure that the range remains valid.</source>
          <target state="translated">이 속성을 설정할 때 필요한 경우 범위가 유효한지 확인하기 위해 &lt;a href=&quot;qdoublespinbox#maximum-prop&quot;&gt;최대 값&lt;/a&gt; 이 조정됩니다.</target>
        </trans-unit>
        <trans-unit id="d52e2cb44d7f2ae6749696edb496d673ee39757f" translate="yes" xml:space="preserve">
          <source>When setting this property the &lt;a href=&quot;qdoublespinbox#minimum-prop&quot;&gt;minimum&lt;/a&gt; is adjusted if necessary, to ensure that the range remains valid.</source>
          <target state="translated">이 속성을 설정할 때 필요한 경우 &lt;a href=&quot;qdoublespinbox#minimum-prop&quot;&gt;최소값&lt;/a&gt; 이 조정되어 범위가 유효하게 유지됩니다.</target>
        </trans-unit>
        <trans-unit id="47cfedf6ef21c709f13ba69a81ab6789fc8a9fd1" translate="yes" xml:space="preserve">
          <source>When setting this property the &lt;a href=&quot;qspinbox#maximum-prop&quot;&gt;maximum&lt;/a&gt; is adjusted if necessary to ensure that the range remains valid.</source>
          <target state="translated">이 속성을 설정할 때 필요한 경우 범위가 유효한지 확인하기 위해 &lt;a href=&quot;qspinbox#maximum-prop&quot;&gt;최대 값&lt;/a&gt; 이 조정됩니다.</target>
        </trans-unit>
        <trans-unit id="9b3aa09d9d597d2ccc6d81186f12b9dee43bde16" translate="yes" xml:space="preserve">
          <source>When setting this property the corresponding maximum value is adjusted if necessary, to ensure that the range remains valid.</source>
          <target state="translated">이 속성을 설정할 때 필요한 경우 해당 최대 값이 조정되어 범위가 유효하게 유지됩니다.</target>
        </trans-unit>
        <trans-unit id="ed5abb02b8b1a236c42c80272c5d4f7b5e792484" translate="yes" xml:space="preserve">
          <source>When setting this property the corresponding minimum value is adjusted if necessary, to ensure that the range remains valid.</source>
          <target state="translated">이 속성을 설정할 때 필요한 경우 해당 최소값이 조정되어 범위가 유효하게 유지됩니다.</target>
        </trans-unit>
        <trans-unit id="0e2d22ffaa8c87cce0769e98c3a06583fa170f8d" translate="yes" xml:space="preserve">
          <source>When setting this property the minimum is adjusted if necessary, to ensure that the range remains valid.</source>
          <target state="translated">이 속성을 설정할 때 필요한 경우 최소값이 조정되어 범위가 유효하게 유지됩니다.</target>
        </trans-unit>
        <trans-unit id="10bbb03412564a8a76a7faa470981f3e92871bb0" translate="yes" xml:space="preserve">
          <source>When setting this property the timespec of the &lt;a href=&quot;qdatetimeedit&quot;&gt;QDateTimeEdit&lt;/a&gt; remains the same and the timespec of the new &lt;a href=&quot;qdatetime&quot;&gt;QDateTime&lt;/a&gt; is ignored.</source>
          <target state="translated">이 속성을 설정할 때 &lt;a href=&quot;qdatetimeedit&quot;&gt;QDateTimeEdit&lt;/a&gt; 의 시간 사양 은 동일하게 유지되며 새 &lt;a href=&quot;qdatetime&quot;&gt;QDateTime의 시간 사양&lt;/a&gt; 은 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="2375a6809ff71a69632c1ba6bc4411bcbd56175e" translate="yes" xml:space="preserve">
          <source>When setting this property to a list of waypoints, each waypoint can be either a &lt;a href=&quot;qml-coordinate&quot;&gt;coordinate&lt;/a&gt; or a &lt;a href=&quot;qml-qtlocation-waypoint&quot;&gt;Waypoint&lt;/a&gt;, interchangeably. If a &lt;a href=&quot;qml-coordinate&quot;&gt;coordinate&lt;/a&gt; is passed, it will be internally converted to a &lt;a href=&quot;qml-qtlocation-waypoint&quot;&gt;Waypoint&lt;/a&gt;.</source>
          <target state="translated">경유지 목록이 속성을 설정하는 경우, 각각의 웨이 중 하나가 될 수 &lt;a href=&quot;qml-coordinate&quot;&gt;좌표&lt;/a&gt; 또는 &lt;a href=&quot;qml-qtlocation-waypoint&quot;&gt;경유지&lt;/a&gt; 혼용. A는 경우 &lt;a href=&quot;qml-coordinate&quot;&gt;좌표&lt;/a&gt; 전달, 그것은 내부적으로 변환됩니다 &lt;a href=&quot;qml-qtlocation-waypoint&quot;&gt;웨이 포인트&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="8c08c05c4f9a6cc8ebd2fa6d3ff3659b0e8d5359" translate="yes" xml:space="preserve">
          <source>When setting this property, the &lt;a href=&quot;qabstractslider#maximum-prop&quot;&gt;maximum&lt;/a&gt; is adjusted if necessary to ensure that the range remains valid. Also the slider's current value is adjusted to be within the new range.</source>
          <target state="translated">이 속성을 설정할 때 필요한 경우 범위가 유효한지 확인하기 위해 &lt;a href=&quot;qabstractslider#maximum-prop&quot;&gt;최대 값&lt;/a&gt; 이 조정됩니다. 또한 슬라이더의 현재 값이 새 범위 내에 있도록 조정됩니다.</target>
        </trans-unit>
        <trans-unit id="083344e77b31d85a0b5a8a8283eca8fda3876952" translate="yes" xml:space="preserve">
          <source>When setting this property, the &lt;a href=&quot;qabstractslider#minimum-prop&quot;&gt;minimum&lt;/a&gt; is adjusted if necessary to ensure that the range remains valid. Also the slider's current value is adjusted to be within the new range.</source>
          <target state="translated">이 속성을 설정할 때 필요한 경우 &lt;a href=&quot;qabstractslider#minimum-prop&quot;&gt;최소값&lt;/a&gt; 이 조정되어 범위가 유효하게 유지됩니다. 또한 슬라이더의 현재 값이 새 범위 내에 있도록 조정됩니다.</target>
        </trans-unit>
        <trans-unit id="890b98dfbcb1358977a7219adcd63ac2cd2c0980" translate="yes" xml:space="preserve">
          <source>When setting this property, the &lt;a href=&quot;qdatetimeedit#minimumTime-prop&quot;&gt;minimumTime&lt;/a&gt; is adjusted if necessary to ensure that the range remains valid. If the time is not a valid &lt;a href=&quot;qtime&quot;&gt;QTime&lt;/a&gt; object, this function does nothing.</source>
          <target state="translated">이 속성을 설정할 때 필요한 경우 &lt;a href=&quot;qdatetimeedit#minimumTime-prop&quot;&gt;rangeTime&lt;/a&gt; 이 유효한지 확인하기 위해 minimumTime 이 조정됩니다. 시간이 유효한 &lt;a href=&quot;qtime&quot;&gt;QTime&lt;/a&gt; 객체 가 아닌 경우이 함수는 아무 작업도 수행하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="fa2c9bb906ff3305eef76e88d6b8655a32b982f4" translate="yes" xml:space="preserve">
          <source>When setting this property, the &lt;a href=&quot;qml-qtcharts-pieseries#holeSize-prop&quot;&gt;holeSize&lt;/a&gt; property is adjusted if necessary, to ensure that the hole size is not greater than the pie size.</source>
          <target state="translated">이 속성을 설정할 때 구멍 크기가 파이 크기보다 크지 않도록 필요한 경우 &lt;a href=&quot;qml-qtcharts-pieseries#holeSize-prop&quot;&gt;holeSize&lt;/a&gt; 속성이 조정됩니다.</target>
        </trans-unit>
        <trans-unit id="f435a68f9316a9aad8d0bd9214e3829a97c2384f" translate="yes" xml:space="preserve">
          <source>When setting this property, the &lt;a href=&quot;qml-qtcharts-pieseries#size-prop&quot;&gt;size&lt;/a&gt; property is adjusted if necessary, to ensure that the hole size is not greater than the pie size.</source>
          <target state="translated">이 속성을 설정할 때 구멍 크기가 파이 크기보다 크지 않도록 필요한 경우 &lt;a href=&quot;qml-qtcharts-pieseries#size-prop&quot;&gt;크기&lt;/a&gt; 속성이 조정됩니다.</target>
        </trans-unit>
        <trans-unit id="2614229e0748ff7798a30ec6c9a32c8bd564129c" translate="yes" xml:space="preserve">
          <source>When setting this property, the &lt;a href=&quot;qpieseries#holeSize-prop&quot;&gt;holeSize&lt;/a&gt; property is adjusted if necessary, to ensure that the hole size is not greater than the pie size.</source>
          <target state="translated">이 속성을 설정할 때 구멍 크기가 파이 크기보다 크지 않도록 필요한 경우 &lt;a href=&quot;qpieseries#holeSize-prop&quot;&gt;holeSize&lt;/a&gt; 속성이 조정됩니다.</target>
        </trans-unit>
        <trans-unit id="9676bb4e1b94754c72406b0dd8f30c9729452b6c" translate="yes" xml:space="preserve">
          <source>When setting this property, the &lt;a href=&quot;qpieseries#size-prop&quot;&gt;size&lt;/a&gt; property is adjusted if necessary, to ensure that the hole size is not greater than the pie size.</source>
          <target state="translated">이 속성을 설정할 때 구멍 크기가 파이 크기보다 크지 않도록 필요한 경우 &lt;a href=&quot;qpieseries#size-prop&quot;&gt;크기&lt;/a&gt; 속성이 조정됩니다.</target>
        </trans-unit>
        <trans-unit id="5c4c814181687e53992d25bc4a345c8885416475" translate="yes" xml:space="preserve">
          <source>When setting this property, the &lt;a href=&quot;qprogressbar#maximum-prop&quot;&gt;maximum&lt;/a&gt; is adjusted if necessary to ensure that the range remains valid. If the current value falls outside the new range, the progress bar is reset with &lt;a href=&quot;qprogressbar#reset&quot;&gt;reset&lt;/a&gt;().</source>
          <target state="translated">이 속성을 설정할 때 필요한 경우 범위가 유효한지 확인하기 위해 &lt;a href=&quot;qprogressbar#maximum-prop&quot;&gt;최대 값&lt;/a&gt; 이 조정됩니다. 현재 값이 새 범위를 벗어나면 진행률 표시 줄이 &lt;a href=&quot;qprogressbar#reset&quot;&gt;재설정&lt;/a&gt; () 으로 재설정 됩니다.</target>
        </trans-unit>
        <trans-unit id="d10bb2cee1aba8ceaf054055bf90ceea6821e2bc" translate="yes" xml:space="preserve">
          <source>When setting this property, the &lt;a href=&quot;qprogressbar#minimum-prop&quot;&gt;minimum&lt;/a&gt; is adjusted if necessary to ensure that the range remains valid. If the current value falls outside the new range, the progress bar is reset with &lt;a href=&quot;qprogressbar#reset&quot;&gt;reset&lt;/a&gt;().</source>
          <target state="translated">이 속성을 설정할 때 필요한 경우 &lt;a href=&quot;qprogressbar#minimum-prop&quot;&gt;최소값&lt;/a&gt; 이 조정되어 범위가 유효하게 유지됩니다. 현재 값이 새 범위를 벗어나면 진행률 표시 줄이 &lt;a href=&quot;qprogressbar#reset&quot;&gt;재설정&lt;/a&gt; () 으로 재설정 됩니다.</target>
        </trans-unit>
        <trans-unit id="32aea66ca6d6da71cb41f4c7cc9dc10b08e8577f" translate="yes" xml:space="preserve">
          <source>When setting this property, the maximum value is adjusted if necessary, to ensure that the range remains valid.</source>
          <target state="translated">이 속성을 설정할 때 필요한 경우 최대 값이 조정되어 범위가 유효하게 유지됩니다.</target>
        </trans-unit>
        <trans-unit id="b951c983b0aee73e158712980739ff70f149887e" translate="yes" xml:space="preserve">
          <source>When setting this property, the maximum value is adjusted if necessary, to ensure that the range remains valid. The value has to be greater than 0.</source>
          <target state="translated">이 속성을 설정할 때 필요한 경우 최대 값이 조정되어 범위가 유효하게 유지됩니다. 값은 0보다 커야합니다.</target>
        </trans-unit>
        <trans-unit id="7a55bcbc9be43eedc7805bdbb3ee9e54f14990ff" translate="yes" xml:space="preserve">
          <source>When setting this property, the minimum value is adjusted if necessary, to ensure that the range remains valid.</source>
          <target state="translated">이 속성을 설정할 때 필요한 경우 최소값이 조정되어 범위가 유효하게 유지됩니다.</target>
        </trans-unit>
        <trans-unit id="c7876cf5d914de6fdd878ac65bed31fe69eb59c2" translate="yes" xml:space="preserve">
          <source>When setting this property, the minimum value is adjusted if necessary, to ensure that the range remains valid. The value has to be greater than 0.</source>
          <target state="translated">이 속성을 설정할 때 필요한 경우 최소값이 조정되어 범위가 유효하게 유지됩니다. 값은 0보다 커야합니다.</target>
        </trans-unit>
        <trans-unit id="5de4dc53f812589029ed9067e97355562cb0e1d3" translate="yes" xml:space="preserve">
          <source>When setting up the rendering pipeline, call &lt;a href=&quot;qvulkanwindow#sampleCountFlagBits&quot;&gt;sampleCountFlagBits&lt;/a&gt;() to query the active sample count as a &lt;code&gt;VkSampleCountFlagBits&lt;/code&gt; value.</source>
          <target state="translated">렌더링 파이프 라인을 설정할 때 &lt;a href=&quot;qvulkanwindow#sampleCountFlagBits&quot;&gt;sampleCountFlagBits&lt;/a&gt; ()를 호출 하여 활성 샘플 수를 &lt;code&gt;VkSampleCountFlagBits&lt;/code&gt; 값 으로 쿼리하십시오 .</target>
        </trans-unit>
        <trans-unit id="dfcd5a5c296c55f96b9ee5da99d93a616d2b11fc" translate="yes" xml:space="preserve">
          <source>When shaders were added to this program via &lt;a href=&quot;qopenglshaderprogram#addCacheableShaderFromSourceCode&quot;&gt;addCacheableShaderFromSourceCode&lt;/a&gt;() or &lt;a href=&quot;qopenglshaderprogram#addCacheableShaderFromSourceFile&quot;&gt;addCacheableShaderFromSourceFile&lt;/a&gt;(), program binaries are supported, and a cached binary is available on disk, actual compilation and linking are skipped. Instead, link() will initialize the program with the binary blob via glProgramBinary(). If there is no cached version of the program or it was generated with a different driver version, the shaders will be compiled from source and the program will get linked normally. This allows seamless upgrading of the graphics drivers, without having to worry about potentially incompatible binary formats.</source>
          <target state="translated">&lt;a href=&quot;qopenglshaderprogram#addCacheableShaderFromSourceCode&quot;&gt;addCacheableShaderFromSourceCode&lt;/a&gt; () 또는 &lt;a href=&quot;qopenglshaderprogram#addCacheableShaderFromSourceFile&quot;&gt;addCacheableShaderFromSourceFile&lt;/a&gt; () 을 통해이 프로그램에 셰이더를 추가하면 프로그램 바이너리가 지원되며 캐시 된 바이너리는 디스크에서 사용할 수 있으며 실제 컴파일 및 링크는 건너 뜁니다. 대신 link ()는 glProgramBinary ()를 통해 이진 Blob으로 프로그램을 초기화합니다. 프로그램의 캐시 된 버전이 없거나 다른 드라이버 버전으로 생성 된 경우 셰이더는 소스에서 컴파일되고 프로그램은 정상적으로 연결됩니다. 따라서 호환되지 않는 이진 형식에 대해 걱정할 필요없이 그래픽 드라이버를 완벽하게 업그레이드 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="64b2c21463a05b372aacfedaa2026900f87448ca" translate="yes" xml:space="preserve">
          <source>When subclassing &lt;a href=&quot;qabstractitemmodel&quot;&gt;QAbstractItemModel&lt;/a&gt; or &lt;a href=&quot;qabstractproxymodel&quot;&gt;QAbstractProxyModel&lt;/a&gt;, ensure that you emit &lt;a href=&quot;qabstractitemmodel#layoutAboutToBeChanged&quot;&gt;layoutAboutToBeChanged&lt;/a&gt;() before changing the order of items or altering the structure of the data you expose to views, and emit layoutChanged() after changing the layout.</source>
          <target state="translated">서브 클래스 때 &lt;a href=&quot;qabstractitemmodel&quot;&gt;QAbstractItemModel&lt;/a&gt; 또는 &lt;a href=&quot;qabstractproxymodel&quot;&gt;QAbstractProxyModel를&lt;/a&gt; 하면 출사되도록 &lt;a href=&quot;qabstractitemmodel#layoutAboutToBeChanged&quot;&gt;layoutAboutToBeChanged를&lt;/a&gt; 레이아웃을 변경 한 후 () 항목의 순서를 변경하거나보기에 노출 된 데이터의 구조를 변경하기 전에 () 및 발광은 layoutChanged.</target>
        </trans-unit>
        <trans-unit id="29ad4f995056d1ccd3dcee88f2d1086d0349dbfd" translate="yes" xml:space="preserve">
          <source>When subclassing &lt;a href=&quot;qabstractitemmodel&quot;&gt;QAbstractItemModel&lt;/a&gt;, at the very least you must implement &lt;a href=&quot;qabstractitemmodel#index&quot;&gt;index&lt;/a&gt;(), &lt;a href=&quot;qabstractitemmodel#parent&quot;&gt;parent&lt;/a&gt;(), &lt;a href=&quot;qabstractitemmodel#rowCount&quot;&gt;rowCount&lt;/a&gt;(), &lt;a href=&quot;qabstractitemmodel#columnCount&quot;&gt;columnCount&lt;/a&gt;(), and &lt;a href=&quot;qabstractitemmodel#data&quot;&gt;data&lt;/a&gt;(). These functions are used in all read-only models, and form the basis of editable models.</source>
          <target state="translated">&lt;a href=&quot;qabstractitemmodel&quot;&gt;QAbstractItemModel을&lt;/a&gt; 서브 클래 싱 할 때는 최소한 &lt;a href=&quot;qabstractitemmodel#index&quot;&gt;index&lt;/a&gt; (), &lt;a href=&quot;qabstractitemmodel#parent&quot;&gt;parent&lt;/a&gt; (), &lt;a href=&quot;qabstractitemmodel#rowCount&quot;&gt;rowCount&lt;/a&gt; (), &lt;a href=&quot;qabstractitemmodel#columnCount&quot;&gt;columnCount&lt;/a&gt; () 및 &lt;a href=&quot;qabstractitemmodel#data&quot;&gt;data&lt;/a&gt; ()를 구현해야합니다 . 이 기능은 모든 읽기 전용 모델에 사용되며 편집 가능한 모델의 기초를 형성합니다.</target>
        </trans-unit>
        <trans-unit id="a191eed727edc2ae03b2ab93852a02163a6c05e0" translate="yes" xml:space="preserve">
          <source>When subclassing &lt;a href=&quot;qabstractlistmodel&quot;&gt;QAbstractListModel&lt;/a&gt;, you must provide implementations of the &lt;a href=&quot;qabstractitemmodel#rowCount&quot;&gt;rowCount&lt;/a&gt;() and &lt;a href=&quot;qabstractitemmodel#data&quot;&gt;data&lt;/a&gt;() functions. Well behaved models also provide a &lt;a href=&quot;qabstractitemmodel#headerData&quot;&gt;headerData&lt;/a&gt;() implementation.</source>
          <target state="translated">&lt;a href=&quot;qabstractlistmodel&quot;&gt;QAbstractListModel을&lt;/a&gt; 서브 클래 싱 할 때 구현을 제공해야합니다.&lt;a href=&quot;qabstractitemmodel#rowCount&quot;&gt; rowCount&lt;/a&gt; () 및 &lt;a href=&quot;qabstractitemmodel#data&quot;&gt;data&lt;/a&gt; () 함수의 . 잘 동작하는 모델은 &lt;a href=&quot;qabstractitemmodel#headerData&quot;&gt;headerData&lt;/a&gt; () 구현 도 제공합니다 .</target>
        </trans-unit>
        <trans-unit id="34ee94bbac1ecea4e8ddb454d400be8aae1e7968" translate="yes" xml:space="preserve">
          <source>When subclassing &lt;a href=&quot;qabstracttablemodel&quot;&gt;QAbstractTableModel&lt;/a&gt;, you must implement &lt;a href=&quot;qabstractitemmodel#rowCount&quot;&gt;rowCount&lt;/a&gt;(), &lt;a href=&quot;qabstractitemmodel#columnCount&quot;&gt;columnCount&lt;/a&gt;(), and &lt;a href=&quot;qabstractitemmodel#data&quot;&gt;data&lt;/a&gt;(). Default implementations of the &lt;a href=&quot;qabstracttablemodel#index&quot;&gt;index&lt;/a&gt;() and &lt;a href=&quot;qabstractitemmodel#parent&quot;&gt;parent&lt;/a&gt;() functions are provided by &lt;a href=&quot;qabstracttablemodel&quot;&gt;QAbstractTableModel&lt;/a&gt;. Well behaved models will also implement &lt;a href=&quot;qabstractitemmodel#headerData&quot;&gt;headerData&lt;/a&gt;().</source>
          <target state="translated">&lt;a href=&quot;qabstracttablemodel&quot;&gt;QAbstractTableModel을&lt;/a&gt; 서브 클래 싱 할 때는 &lt;a href=&quot;qabstractitemmodel#rowCount&quot;&gt;rowCount&lt;/a&gt; (), &lt;a href=&quot;qabstractitemmodel#columnCount&quot;&gt;columnCount&lt;/a&gt; () 및 &lt;a href=&quot;qabstractitemmodel#data&quot;&gt;data&lt;/a&gt; ()를 구현해야합니다 . &lt;a href=&quot;qabstracttablemodel#index&quot;&gt;인덱스&lt;/a&gt; ()와 &lt;a href=&quot;qabstractitemmodel#parent&quot;&gt;부모&lt;/a&gt; 의 기본 구현 () 함수&lt;a href=&quot;qabstracttablemodel&quot;&gt; QAbstractTableModel&lt;/a&gt; 에 의해 제공됩니다 . 잘 동작하는 모델은 &lt;a href=&quot;qabstractitemmodel#headerData&quot;&gt;headerData&lt;/a&gt; () 도 구현 합니다.</target>
        </trans-unit>
        <trans-unit id="bc5ed4ae258b22a232b577325d7a45d5a74a6ae6" translate="yes" xml:space="preserve">
          <source>When subclassing &lt;a href=&quot;qaccessibleactioninterface&quot;&gt;QAccessibleActionInterface&lt;/a&gt; you need to provide a list of &lt;a href=&quot;qaccessibleactioninterface#actionNames&quot;&gt;actionNames&lt;/a&gt; which is the primary means to discover the available actions. Action names are never localized. In order to present actions to the user there are two functions that need to return localized versions of the name and give a description of the action. For the predefined action names use &lt;a href=&quot;qaccessibleactioninterface#localizedActionName&quot;&gt;QAccessibleActionInterface::localizedActionName&lt;/a&gt;() and &lt;a href=&quot;qaccessibleactioninterface#localizedActionDescription&quot;&gt;QAccessibleActionInterface::localizedActionDescription&lt;/a&gt;() to return their localized counterparts.</source>
          <target state="translated">&lt;a href=&quot;qaccessibleactioninterface&quot;&gt;QAccessibleActionInterface&lt;/a&gt; 를 서브 클래 싱 할 때 &lt;a href=&quot;qaccessibleactioninterface#actionNames&quot;&gt;actionName&lt;/a&gt; 목록을 제공해야합니다. 사용 가능한 조치를 발견하는 기본 수단 . 활동 이름은 현지화되지 않습니다. 사용자에게 조치를 제시하기 위해 현지화 된 버전의 이름을 리턴하고 조치에 대한 설명을 제공해야하는 두 가지 기능이 있습니다. 사전 정의 된 조치 이름의 경우 &lt;a href=&quot;qaccessibleactioninterface#localizedActionName&quot;&gt;QAccessibleActionInterface :: localizedActionName&lt;/a&gt; () 및 &lt;a href=&quot;qaccessibleactioninterface#localizedActionDescription&quot;&gt;QAccessibleActionInterface :: localizedActionDescription&lt;/a&gt; ()을 사용하여 현지화 된 대응 항목을 리턴하십시오.</target>
        </trans-unit>
        <trans-unit id="a25edef8cc00a94f017f1d9cbc6945550b8bf450" translate="yes" xml:space="preserve">
          <source>When subclassing &lt;a href=&quot;qiodevice&quot;&gt;QIODevice&lt;/a&gt;, you must call QIODevice::seek() at the start of your function to ensure integrity with &lt;a href=&quot;qiodevice&quot;&gt;QIODevice&lt;/a&gt;'s built-in buffer.</source>
          <target state="translated">서브 클래 싱 할 때 &lt;a href=&quot;qiodevice&quot;&gt; QIODevice을&lt;/a&gt; , 당신과 무결성을 보장하기 위해 함수의 시작 () QIODevice이 :: 추구 호출해야합니다 &lt;a href=&quot;qiodevice&quot;&gt;QIODevice&lt;/a&gt; 의 내장에서 버퍼를.</target>
        </trans-unit>
        <trans-unit id="d195ef9dc4d6a9738e6783d4bc0696c9278d4ef4" translate="yes" xml:space="preserve">
          <source>When subclassing &lt;a href=&quot;qitemdelegate&quot;&gt;QItemDelegate&lt;/a&gt; to create a delegate that displays items using a custom renderer, it is important to ensure that the delegate can render items suitably for all the required states; e.g. selected, disabled, checked. The documentation for the &lt;a href=&quot;qitemdelegate#paint&quot;&gt;paint&lt;/a&gt;() function contains some hints to show how this can be achieved.</source>
          <target state="translated">서브 클래 싱 할 때 &lt;a href=&quot;qitemdelegate&quot;&gt;QItemDelegate&lt;/a&gt; 를 하여 커스텀 렌더러를 사용하여 아이템을 표시하는 델리게이트를 생성 , 델리게이트가 필요한 모든 상태에 맞게 아이템을 렌더링 할 수 있어야합니다. 예 : 선택, 비활성화, 확인 &lt;a href=&quot;qitemdelegate#paint&quot;&gt;paint&lt;/a&gt; () 함수에 대한 문서 에는 이것이 어떻게 달성 될 수 있는지 보여주는 힌트가 포함되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="bdfab8a00f506ea4624c5ba05bcfdffa0be88abb" translate="yes" xml:space="preserve">
          <source>When subclassing &lt;a href=&quot;qlistwidgetitem&quot;&gt;QListWidgetItem&lt;/a&gt; to provide custom items, it is possible to define new types for them enabling them to be distinguished from standard items. For subclasses that require this feature, ensure that you call the base class constructor with a new type value equal to or greater than &lt;a href=&quot;qlistwidgetitem#ItemType-enum&quot;&gt;UserType&lt;/a&gt;, within</source>
          <target state="translated">&lt;a href=&quot;qlistwidgetitem&quot;&gt;QListWidgetItem을&lt;/a&gt; 서브 클래 싱 할 때 을 하여 사용자 정의 항목을 제공 표준 항목과 구별 할 수 있도록 새 유형을 정의 할 수 있습니다. 이 기능이 필요 서브 클래스, 당신이 같거나보다 큰 새로운 유형의 값으로 기본 클래스 생성자를 호출 할 수 있도록 &lt;a href=&quot;qlistwidgetitem#ItemType-enum&quot;&gt;UserType을&lt;/a&gt; 내,</target>
        </trans-unit>
        <trans-unit id="25983c5d275d61a5768d14102127d7627a6f2db7" translate="yes" xml:space="preserve">
          <source>When subclassing &lt;a href=&quot;qstandarditem&quot;&gt;QStandardItem&lt;/a&gt; to provide custom items, it is possible to define new types for them so that they can be distinguished from the base class. The &lt;a href=&quot;qstandarditem#type&quot;&gt;type&lt;/a&gt;() function should be reimplemented to return a new type value equal to or greater than &lt;a href=&quot;qstandarditem#ItemType-enum&quot;&gt;UserType&lt;/a&gt;.</source>
          <target state="translated">커스텀 아이템을 제공하기 위해 &lt;a href=&quot;qstandarditem&quot;&gt;QStandardItem&lt;/a&gt; 을 서브 클래 싱 할 때 , 기본 클래스와 구별 될 수 있도록 새로운 타입을 정의 할 수 있습니다. &lt;a href=&quot;qstandarditem#type&quot;&gt;유형&lt;/a&gt; () 함수에 또는 이상 같은 새로운 타입의 값을 반환 다시 구현되어야 &lt;a href=&quot;qstandarditem#ItemType-enum&quot;&gt;UserType을&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="e6fbf6fe9133647e06d0faf1437cba6ca2cedd98" translate="yes" xml:space="preserve">
          <source>When subclassing &lt;a href=&quot;qstandarditem&quot;&gt;QStandardItem&lt;/a&gt;, you can reimplement this function to provide &lt;a href=&quot;qstandarditemmodel&quot;&gt;QStandardItemModel&lt;/a&gt; with a factory that it can use to create new items on demand.</source>
          <target state="translated">&lt;a href=&quot;qstandarditem&quot;&gt;QStandardItem을&lt;/a&gt; 서브 클래 싱 할 때 할 때이 함수를 다시 구현 하여 필요에 따라 새 항목을 작성하는 데 사용할 수있는 팩토리를 &lt;a href=&quot;qstandarditemmodel&quot;&gt;QStandardItemModel&lt;/a&gt; 에 제공 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f2286413d50d08d040929b6ec39c68a3dddaf3c0" translate="yes" xml:space="preserve">
          <source>When subclassing &lt;a href=&quot;qtablewidgetitem&quot;&gt;QTableWidgetItem&lt;/a&gt; to provide custom items, it is possible to define new types for them so that they can be distinguished from standard items. The constructors for subclasses that require this feature need to call the base class constructor with a new type value equal to or greater than &lt;a href=&quot;qtablewidgetitem#ItemType-enum&quot;&gt;UserType&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;qtablewidgetitem&quot;&gt;QTableWidgetItem을&lt;/a&gt; 서브 클래 싱 할 때 을 하여 사용자 정의 항목을 제공 표준 항목과 구별 할 수 있도록 새 유형을 정의 할 수 있습니다. 이 기능이 필요한 서브 클래스의 생성자는 &lt;a href=&quot;qtablewidgetitem#ItemType-enum&quot;&gt;UserType&lt;/a&gt; 이상의 새 유형 값으로 기본 클래스 생성자를 호출해야합니다 .</target>
        </trans-unit>
        <trans-unit id="1002dc2f9f72071b49f3bc6989364ec60eb22d54" translate="yes" xml:space="preserve">
          <source>When subclassing &lt;a href=&quot;qtreewidgetitem&quot;&gt;QTreeWidgetItem&lt;/a&gt; to provide custom items, it is possible to define new types for them so that they can be distinguished from standard items. The constructors for subclasses that require this feature need to call the base class constructor with a new type value equal to or greater than &lt;a href=&quot;qtreewidgetitem#ItemType-enum&quot;&gt;UserType&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;qtreewidgetitem&quot;&gt;QTreeWidgetItem&lt;/a&gt; 을 서브 클래 싱 하여 사용자 정의 항목을 제공 할 때 표준 항목과 구별 할 수 있도록 새 유형을 정의 할 수 있습니다. 이 기능이 필요한 서브 클래스의 생성자는 새 유형 값 이상인 기본 클래스 생성자를 호출해야합니다.&lt;a href=&quot;qtreewidgetitem#ItemType-enum&quot;&gt; UserType&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="706f7b1df0260af3c55347db3db3d7c9292cb895" translate="yes" xml:space="preserve">
          <source>When successful, the pointer to this &lt;a href=&quot;qvulkaninstance&quot;&gt;QVulkanInstance&lt;/a&gt; is retrievable via the static function current().</source>
          <target state="translated">성공하면 이것에 대한 포인터 &lt;a href=&quot;qvulkaninstance&quot;&gt;&lt;/a&gt; 하면 정적 함수 current () QVulkanInstance에 검색 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="52f02029e2dd95fea6c58bc7c6dd438e3036694c" translate="yes" xml:space="preserve">
          <source>When successful, the returned pointer is either a direct pointer to an interface (and can be cast, for example, to &lt;code&gt;ID3D12Device *&lt;/code&gt;) or a pointer to an opaque handle that needs to be dereferenced first (for example, &lt;code&gt;VkDevice dev = *static_cast&amp;lt;VkDevice *&amp;gt;(result)&lt;/code&gt;). The latter is necessary since such handles may have sizes different from a pointer.</source>
          <target state="translated">성공하면 반환 된 포인터는 인터페이스에 대한 직접 포인터이며 (예 : &lt;code&gt;ID3D12Device *&lt;/code&gt; 로 캐스트 될 수 있음 ) 먼저 참조 해제해야하는 불투명 한 핸들에 대한 포인터입니다 (예 : &lt;code&gt;VkDevice dev = *static_cast&amp;lt;VkDevice *&amp;gt;(result)&lt;/code&gt; ). 후자는 그러한 핸들이 포인터와 다른 크기를 가질 수 있기 때문에 필요하다.</target>
        </trans-unit>
        <trans-unit id="b61533f5bfe4f41a281b6739619bbe40223b42c1" translate="yes" xml:space="preserve">
          <source>When supported, the spot metering point is the (normalized) position of the point of the image where exposure metering will be performed. This is typically used to indicate an &quot;interesting&quot; area of the image that should be exposed properly.</source>
          <target state="translated">지원되는 경우 스팟 측광 지점은 노출 측광이 수행 될 이미지 지점의 (정규화 된) 위치입니다. 이것은 일반적으로 올바르게 노출되어야하는 이미지의 &quot;흥미로운&quot;영역을 나타내는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="5f88abce90e32dce271b35e9107fb601ec017c62" translate="yes" xml:space="preserve">
          <source>When switching application styles, the color palette is set back to the initial colors or the system defaults. This is necessary since certain styles have to adapt the color palette to be fully style-guide compliant.</source>
          <target state="translated">응용 프로그램 스타일을 전환하면 색상 팔레트가 초기 색상이나 시스템 기본값으로 다시 설정됩니다. 특정 스타일은 색상 표를 스타일 가이드와 완전히 일치하도록 조정해야하기 때문에 필요합니다.</target>
        </trans-unit>
        <trans-unit id="67873ce37a5513b0e5ae88b75e6f033ba8bb99f4" translate="yes" xml:space="preserve">
          <source>When tabsClosable is set to true a close button will appear on the tab on either the left or right hand side depending upon the style. When the button is clicked the tab the signal &lt;a href=&quot;qtabbar#tabCloseRequested&quot;&gt;tabCloseRequested&lt;/a&gt; will be emitted.</source>
          <target state="translated">tabsClosable이 true로 설정되면 스타일에 따라 왼쪽 또는 오른쪽의 탭에 닫기 단추가 나타납니다. 버튼을 클릭하면 &lt;a href=&quot;qtabbar#tabCloseRequested&quot;&gt;tabCloseRequested&lt;/a&gt; 신호 가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="edd34e00a0649a39928db867a61af0bdd3698a54" translate="yes" xml:space="preserve">
          <source>When talking about version support on macOS, it's important to distinguish between the &lt;a href=&quot;#build-environment&quot;&gt;build environment&lt;/a&gt;; the platform you're building on or with, and the &lt;a href=&quot;#target-platforms&quot;&gt;target platforms&lt;/a&gt;; the platforms you are building for. The following macOS versions are supported.</source>
          <target state="translated">macOS에서 버전 지원에 관해 이야기 할 때 &lt;a href=&quot;#build-environment&quot;&gt;빌드 환경&lt;/a&gt; 을 구별하는 것이 중요 합니다 . 귀하가 구축하고있는 &lt;a href=&quot;#target-platforms&quot;&gt;플랫폼&lt;/a&gt; 및 대상 플랫폼 ; 구축하려는 플랫폼. 다음과 같은 macOS 버전이 지원됩니다.</target>
        </trans-unit>
        <trans-unit id="12b09dba91f90a77f1c0f316bc1593767614f52d" translate="yes" xml:space="preserve">
          <source>When targeting the default render target, the &lt;code&gt;rasterizationSamples&lt;/code&gt; field of &lt;code&gt;VkPipelineMultisampleStateCreateInfo&lt;/code&gt; must be set to this value.</source>
          <target state="translated">기본 렌더 타겟을 대상으로 할 때 &lt;code&gt;VkPipelineMultisampleStateCreateInfo&lt;/code&gt; 의 &lt;code&gt;rasterizationSamples&lt;/code&gt; 샘플 필드 를이 값으로 설정해야합니다.</target>
        </trans-unit>
        <trans-unit id="977796166650ef7b381034a2e5ab66d22d9fde20" translate="yes" xml:space="preserve">
          <source>When text is selected this signal will be emitted with</source>
          <target state="translated">텍스트를 선택하면이 신호가</target>
        </trans-unit>
        <trans-unit id="55f3e3f1e06a97818ce0ffb33865599309fb29ae" translate="yes" xml:space="preserve">
          <source>When the</source>
          <target state="translated">때</target>
        </trans-unit>
        <trans-unit id="96148eaf4c167de1a5cc9cb151bbca87c607e4e7" translate="yes" xml:space="preserve">
          <source>When the &lt;a href=&quot;qlogvalue3daxisformatter#base-prop&quot;&gt;base&lt;/a&gt; property value is non-zero, the whole axis range is often not equally divided into segments. The first and last segments are often smaller than the other segments. In extreme cases, this can lead to overlapping labels on the first and last two grid lines. By setting this property to &lt;code&gt;false&lt;/code&gt;, you can suppress showing the minimum and maximum labels for the axis in cases where the segments do not exactly fit the axis. Defaults to &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">때 &lt;a href=&quot;qlogvalue3daxisformatter#base-prop&quot;&gt;기본&lt;/a&gt; 속성 값이 0이고, 모든 축 범위들은 동일 세그먼트로 분할 아니다. 첫 번째 세그먼트와 마지막 세그먼트는 종종 다른 세그먼트보다 작습니다. 극단적 인 경우 첫 번째 및 마지막 두 그리드 선에서 레이블이 겹칠 수 있습니다. 이 속성을 &lt;code&gt;false&lt;/code&gt; 로 설정 하면 세그먼트가 축에 정확히 맞지 않는 경우 축의 최소 및 최대 레이블 표시를 억제 할 수 있습니다. 기본값은 &lt;code&gt;true&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="01c131bddcc8fa92f9f3b0a589fa47980eb2d439" translate="yes" xml:space="preserve">
          <source>When the &lt;a href=&quot;qml-qt3d-render-pointsize#sizeMode-prop&quot;&gt;sizeMode&lt;/a&gt; property is set to SizeMode::Fixed, the value is set using glPointSize(), if available. When using SizeMode::Programmable, gl_PointSize must be set within shader programs, the value provided to this &lt;a href=&quot;qml-renderstate&quot;&gt;RenderState&lt;/a&gt; is ignored in that case.</source>
          <target state="translated">때 &lt;a href=&quot;qml-qt3d-render-pointsize#sizeMode-prop&quot;&gt;sizeMode의&lt;/a&gt; 속성이 SizeMode로 설정 :: 가능한 경우 값이 정해주고 싶다면 glPointSize 명령 ()를 사용하여 설정, 수정했습니다. SizeMode :: Programmable을 사용할 때 gl_PointSize는이 &lt;a href=&quot;qml-renderstate&quot;&gt;RenderState에&lt;/a&gt; 제공된 값인 셰이더 프로그램 내에서 설정되어야합니다. 은 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="31b0eaa228f2b88891ce3db774ff73a70a98110c" translate="yes" xml:space="preserve">
          <source>When the &lt;a href=&quot;qml-qtdatavisualization-logvalueaxis3dformatter#base-prop&quot;&gt;base&lt;/a&gt; property value is non-zero, the whole axis range is often not equally divided into segments. The first and last segments are often smaller than the other segments. In extreme cases, this can lead to overlapping labels on the first and last two grid lines. By setting this property to &lt;code&gt;false&lt;/code&gt;, you can suppress showing the minimum and maximum labels for the axis in cases where the segments do not exactly fit the axis. Defaults to &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">때 &lt;a href=&quot;qml-qtdatavisualization-logvalueaxis3dformatter#base-prop&quot;&gt;기본&lt;/a&gt; 속성 값이 0이고, 모든 축 범위들은 동일 세그먼트로 분할 아니다. 첫 번째 세그먼트와 마지막 세그먼트는 종종 다른 세그먼트보다 작습니다. 극단적 인 경우 첫 번째 및 마지막 두 그리드 선에서 레이블이 겹칠 수 있습니다. 이 속성을 &lt;code&gt;false&lt;/code&gt; 로 설정 하면 세그먼트가 축에 정확히 맞지 않는 경우 축의 최소 및 최대 레이블 표시를 억제 할 수 있습니다. 기본값은 &lt;code&gt;true&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="987fec2f0c2c258849a742c9e14f0174fef55ec2" translate="yes" xml:space="preserve">
          <source>When the &lt;a href=&quot;qml-qtpositioning-positionsource&quot;&gt;PositionSource&lt;/a&gt; is active, position updates can be retrieved either by simply using the &lt;a href=&quot;qml-qtpositioning-positionsource#position-prop&quot;&gt;position&lt;/a&gt; property in a binding (as the value of another item's property), or by providing an implementation of the &lt;code&gt;onPositionChanged&lt;/code&gt; signal-handler.</source>
          <target state="translated">때 &lt;a href=&quot;qml-qtpositioning-positionsource&quot;&gt;PositionSource가&lt;/a&gt; 활성화되어, 위치 업데이트는 단순히 이용하거나 검색 할 수있는 &lt;a href=&quot;qml-qtpositioning-positionsource#position-prop&quot;&gt;위치에&lt;/a&gt; 결합 (다른 아이템의 속성 값으로서), 또는 구현 제공에 속성 &lt;code&gt;onPositionChanged&lt;/code&gt; 신호 처리기.</target>
        </trans-unit>
        <trans-unit id="d6b06a8b392f311abc92743e16b8eaf852385858" translate="yes" xml:space="preserve">
          <source>When the &lt;a href=&quot;qml-qtquick-controls-stackview&quot;&gt;StackView&lt;/a&gt; needs a new transition, it first calls &lt;a href=&quot;qml-qtquick-controls-stackviewdelegate#getTransition-method&quot;&gt;StackViewDelegate.getTransition()&lt;/a&gt;. The base implementation of this function just looks for a property named &lt;code&gt;properties.name&lt;/code&gt; inside itself (root), which is how it finds &lt;code&gt;property Component pushTransition&lt;/code&gt; in the examples above.</source>
          <target state="translated">때 &lt;a href=&quot;qml-qtquick-controls-stackview&quot;&gt;StackView이&lt;/a&gt; 새로운 전환을 필요로 먼저 호출 &lt;a href=&quot;qml-qtquick-controls-stackviewdelegate#getTransition-method&quot;&gt;() StackViewDelegate.getTransition를&lt;/a&gt; . 이 함수의 기본 구현은 그 자체 (root) 내 에서 properties.name이라는 &lt;code&gt;properties.name&lt;/code&gt; 을 찾습니다 . 위의 예제에서 &lt;code&gt;property Component pushTransition&lt;/code&gt; 을 찾는 방법 입니다.</target>
        </trans-unit>
        <trans-unit id="13b2463be39cc72e16c7d4ca58b0c4d0edaade26" translate="yes" xml:space="preserve">
          <source>When the &lt;a href=&quot;qml-qtquick-flickable#boundsMovement-prop&quot;&gt;boundsMovement&lt;/a&gt; is &lt;code&gt;Flickable.FollowBoundsBehavior&lt;/code&gt;, a value other than &lt;code&gt;Flickable.StopAtBounds&lt;/code&gt; will give a feeling that the edges of the view are soft, rather than a hard physical boundary.</source>
          <target state="translated">때 &lt;a href=&quot;qml-qtquick-flickable#boundsMovement-prop&quot;&gt;boundsMovement가&lt;/a&gt; 있다 &lt;code&gt;Flickable.FollowBoundsBehavior&lt;/code&gt; , 이외의 값 &lt;code&gt;Flickable.StopAtBounds&lt;/code&gt; 오히려 하드 물리적 경계보다 뷰의 가장자리가 부드러운 있다는 느낌을 줄 것이다.</target>
        </trans-unit>
        <trans-unit id="bdd086e0b6a8d49e2b2713bf9ea24b942d740d18" translate="yes" xml:space="preserve">
          <source>When the &lt;a href=&quot;qml-qtquick-mousearea&quot;&gt;MouseArea&lt;/a&gt; is clicked, &lt;code&gt;fruitModel&lt;/code&gt; will have two roles,</source>
          <target state="translated">때 &lt;a href=&quot;qml-qtquick-mousearea&quot;&gt;MouseArea를&lt;/a&gt; 클릭, &lt;code&gt;fruitModel&lt;/code&gt; 는 , 두 가지 역할을해야합니다</target>
        </trans-unit>
        <trans-unit id="531648fe487a96145ce0801a6bc88b47ddc3d5fa" translate="yes" xml:space="preserve">
          <source>When the &lt;a href=&quot;qml-qtquick-text&quot;&gt;Text&lt;/a&gt; object refers to its &lt;a href=&quot;qml-qtquick-item#parent-prop&quot;&gt;parent&lt;/a&gt; value in the above code, it is referring to its</source>
          <target state="translated">경우 &lt;a href=&quot;qml-qtquick-text&quot;&gt;텍스트&lt;/a&gt; 객체가 지칭 &lt;a href=&quot;qml-qtquick-item#parent-prop&quot;&gt;부모&lt;/a&gt; 상기 코드 값, 그것을 참조하여 해당</target>
        </trans-unit>
        <trans-unit id="cfbd43c514e575cbd44c06a9f1befeb8fbc6aa47" translate="yes" xml:space="preserve">
          <source>When the &lt;a href=&quot;qml-qtquick-virtualkeyboard-keyboardlayoutloader&quot;&gt;KeyboardLayoutLoader&lt;/a&gt; is used as a root item of a keyboard layout, the actual keyboard layouts are wrapped inside Component elements. The keyboard layout is activated by assigning the id of an active component to the sourceComponent property.</source>
          <target state="translated">때 &lt;a href=&quot;qml-qtquick-virtualkeyboard-keyboardlayoutloader&quot;&gt;KeyboardLayoutLoader가&lt;/a&gt; 키보드 레이아웃의 루트 항목으로 사용되며, 실제 키보드 레이아웃은 요소 요소 내부에 싸여있다. 키보드 레이아웃은 활성 구성 요소의 id를 sourceComponent 속성에 할당하여 활성화됩니다.</target>
        </trans-unit>
        <trans-unit id="f043241c3f7cc581207444dcc1dc86dbdeb3ef7b" translate="yes" xml:space="preserve">
          <source>When the &lt;a href=&quot;qpushbutton&quot;&gt;QPushButton&lt;/a&gt; is clicked, the console prints,</source>
          <target state="translated">때 &lt;a href=&quot;qpushbutton&quot;&gt;QPushButton을가&lt;/a&gt; 클릭, 콘솔 인쇄,</target>
        </trans-unit>
        <trans-unit id="d450f4ff62c8dd3eda6ad3d118faffcc34e07662" translate="yes" xml:space="preserve">
          <source>When the &lt;a href=&quot;qqmlengine&quot;&gt;QQmlEngine&lt;/a&gt; instantiates a &lt;a href=&quot;qobject&quot;&gt;QObject&lt;/a&gt;, the context is set automatically.</source>
          <target state="translated">때 &lt;a href=&quot;qqmlengine&quot;&gt;QQmlEngine이&lt;/a&gt; 인스턴스화 &lt;a href=&quot;qobject&quot;&gt;있는 QObject를&lt;/a&gt; , 상황이 자동으로 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="1a3ec88b091fae5c593926fbff02a507863cf15b" translate="yes" xml:space="preserve">
          <source>When the &lt;a href=&quot;qsensor#axesOrientationMode-prop&quot;&gt;axesOrientationMode&lt;/a&gt; property is set to &lt;a href=&quot;qsensor#AxesOrientationMode-enum&quot;&gt;UserOrientation&lt;/a&gt;, the angle for rotating the reading values is taken from this property. In other modes, the property has no effect.</source>
          <target state="translated">때 &lt;a href=&quot;qsensor#axesOrientationMode-prop&quot;&gt;axesOrientationMode의&lt;/a&gt; 속성으로 설정되어 &lt;a href=&quot;qsensor#AxesOrientationMode-enum&quot;&gt;UserOrientation&lt;/a&gt; , 판독 값을 회전시키는 각도는,이 속성으로부터 취해진 다. 다른 모드에서는 속성이 적용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="3ec06e7607af8f8760e7b965130ca0af1c7c4afa" translate="yes" xml:space="preserve">
          <source>When the &lt;a href=&quot;qt#PenJoinStyle-enum&quot;&gt;Qt::MiterJoin&lt;/a&gt; style is applied, it is possible to use the &lt;a href=&quot;qpen#setMiterLimit&quot;&gt;setMiterLimit&lt;/a&gt;() function to specify how far the miter join can extend from the join point. The &lt;a href=&quot;qpen#miterLimit&quot;&gt;miterLimit&lt;/a&gt;() is used to reduce artifacts between line joins where the lines are close to parallel.</source>
          <target state="translated">때 &lt;a href=&quot;qt#PenJoinStyle-enum&quot;&gt;Qt는 :: MiterJoin의&lt;/a&gt; 스타일이 적용되고, 사용할 수 있습니다 &lt;a href=&quot;qpen#setMiterLimit&quot;&gt;setMiterLimit&lt;/a&gt; 이음이 (가) 조인 포인트에서 확장 할 수있는 참여 정도를 지정 () 함수를. &lt;a href=&quot;qpen#miterLimit&quot;&gt;이음 제한은&lt;/a&gt; () 선이 평행에 가까운 라인 사이의 결합 아티팩트를 감소 시키는데 사용된다.</target>
        </trans-unit>
        <trans-unit id="8109269e175dc39675b846ed563d3f286803d82a" translate="yes" xml:space="preserve">
          <source>When the &lt;a href=&quot;qt3drender-qpointsize#sizeMode-prop&quot;&gt;sizeMode&lt;/a&gt; property is set to SizeMode::Fixed, the value is set using glPointSize(), if available. When using SizeMode::Programmable, gl_PointSize must be set within shader programs, the value provided to this &lt;a href=&quot;qml-renderstate&quot;&gt;RenderState&lt;/a&gt; is ignored in that case.</source>
          <target state="translated">때 &lt;a href=&quot;qt3drender-qpointsize#sizeMode-prop&quot;&gt;sizeMode의&lt;/a&gt; 속성이 SizeMode로 설정 :: 가능한 경우 값이 정해주고 싶다면 glPointSize 명령 ()를 사용하여 설정, 수정했습니다. SizeMode :: Programmable을 사용하는 경우 gl_PointSize를 셰이더 프로그램 내에서 설정해야하며이 경우이 &lt;a href=&quot;qml-renderstate&quot;&gt;RenderState에&lt;/a&gt; 제공된 값 은 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="ef51d747b8fb0e1aaf24623fb2724ee2f97056ec" translate="yes" xml:space="preserve">
          <source>When the &lt;a href=&quot;qtoolbutton&quot;&gt;QToolButton&lt;/a&gt; displays arrows, the &lt;a href=&quot;#up-arrow-sub&quot;&gt;::up-arrow&lt;/a&gt;, &lt;a href=&quot;#down-arrow-sub&quot;&gt;::down-arrow&lt;/a&gt;, &lt;a href=&quot;#left-arrow-sub&quot;&gt;::left-arrow&lt;/a&gt; and &lt;a href=&quot;#right-arrow-sub&quot;&gt;::right-arrow&lt;/a&gt; subcontrols are used.</source>
          <target state="translated">&lt;a href=&quot;qtoolbutton&quot;&gt;QToolButton에&lt;/a&gt; 화살표가 표시 되면 &lt;a href=&quot;#up-arrow-sub&quot;&gt;:: 위쪽 화살표&lt;/a&gt; , &lt;a href=&quot;#down-arrow-sub&quot;&gt;:: 아래쪽 화살표&lt;/a&gt; , &lt;a href=&quot;#left-arrow-sub&quot;&gt;:: 왼쪽 화살표&lt;/a&gt; 및 &lt;a href=&quot;#right-arrow-sub&quot;&gt;:: 오른쪽 &lt;/a&gt;화살표 하위 컨트롤 이 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="a1a6fb9f01b0846bb260ddb329a9c95bfca49b3e" translate="yes" xml:space="preserve">
          <source>When the &lt;code&gt;subdirs&lt;/code&gt; template is used, qmake generates a Makefile to examine each specified subdirectory, process any project file it finds there, and run the platform's &lt;code&gt;make&lt;/code&gt; tool on the newly-created Makefile. The &lt;code&gt;SUBDIRS&lt;/code&gt; variable is used to contain a list of all the subdirectories to be processed.</source>
          <target state="translated">때 &lt;code&gt;subdirs&lt;/code&gt; 템플릿을 사용, 지정된 각 하위 디렉토리를 조사 거기를 찾은 프로젝트 파일을 처리하고, 플랫폼의 실행 Makefile을 qmake를 생성 &lt;code&gt;make&lt;/code&gt; 새로 만든 메이크 도구를. &lt;code&gt;SUBDIRS&lt;/code&gt; 의 변수는 처리되는 모든 하위 목록을 포함하기 위해 사용된다.</target>
        </trans-unit>
        <trans-unit id="13cb608250173ac51a45d65525231f711e5ba267" translate="yes" xml:space="preserve">
          <source>When the KMS/DRM backend is in use, eglfs reports all available screens in &lt;a href=&quot;qguiapplication#screens&quot;&gt;QGuiApplication::screens&lt;/a&gt;(). Applications can target different screens with different windows via &lt;a href=&quot;qwindow#setScreen&quot;&gt;QWindow::setScreen&lt;/a&gt;().</source>
          <target state="translated">KMS / DRM 백엔드를 사용중인 경우 eglfs는 &lt;a href=&quot;qguiapplication#screens&quot;&gt;QGuiApplication :: screens&lt;/a&gt; () 에서 사용 가능한 모든 화면을보고합니다 . 응용 프로그램은 &lt;a href=&quot;qwindow#setScreen&quot;&gt;QWindow :: setScreen&lt;/a&gt; ()을 통해 다른 창으로 다른 화면을 대상으로 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="590e6b713b7124a325673c8560f716815fb45204" translate="yes" xml:space="preserve">
          <source>When the QML engine encounters a use of &lt;code&gt;RandomNumberGenerator&lt;/code&gt; as a property value source, it invokes &lt;code&gt;RandomNumberGenerator::setTarget()&lt;/code&gt; to provide the type with the property to which the value source has been applied. When the internal timer in &lt;code&gt;RandomNumberGenerator&lt;/code&gt; triggers every 500 milliseconds, it will write a new number value to that specified property.</source>
          <target state="translated">QML 엔진이 &lt;code&gt;RandomNumberGenerator&lt;/code&gt; 를 특성 값 소스로 사용하면 &lt;code&gt;RandomNumberGenerator::setTarget()&lt;/code&gt; 을 호출 하여 값 소스가 적용된 특성을 유형에 제공합니다. &lt;code&gt;RandomNumberGenerator&lt;/code&gt; 의 내부 타이머가 500 밀리 초마다 트리거되면 지정된 속성에 새 숫자 값을 씁니다.</target>
        </trans-unit>
        <trans-unit id="55bdd73045f54c63cca63284c91153ecc1e0e57c" translate="yes" xml:space="preserve">
          <source>When the QML engine processes this code, it creates a single instance of the</source>
          <target state="translated">QML 엔진은이 코드를 처리 할 때</target>
        </trans-unit>
        <trans-unit id="2200e5bee9d5bde2ef75b92345abdbbd47de48d7" translate="yes" xml:space="preserve">
          <source>When the Space key is pressed, the &lt;a href=&quot;qml-qtquick-item#visible-prop&quot;&gt;visible&lt;/a&gt; value of the green &lt;a href=&quot;qml-qtquick-rectangle&quot;&gt;Rectangle&lt;/a&gt; is toggled. As it appears and disappears, the blue &lt;a href=&quot;qml-qtquick-rectangle&quot;&gt;Rectangle&lt;/a&gt; moves within the Column, and the &lt;a href=&quot;qml-qtquick-column#move-prop&quot;&gt;move&lt;/a&gt; transition is automatically applied to the blue &lt;a href=&quot;qml-qtquick-rectangle&quot;&gt;Rectangle&lt;/a&gt;:</source>
          <target state="translated">스페이스 키를 누르면 녹색 &lt;a href=&quot;qml-qtquick-rectangle&quot;&gt;사각형&lt;/a&gt; 의 &lt;a href=&quot;qml-qtquick-item#visible-prop&quot;&gt;보이는&lt;/a&gt; 값 이 토글됩니다. 이 나타나고, 파란색 사라으로 &lt;a href=&quot;qml-qtquick-rectangle&quot;&gt;사각형&lt;/a&gt; 열 내에서 이동하고, &lt;a href=&quot;qml-qtquick-column#move-prop&quot;&gt;이동&lt;/a&gt; 전환이 자동으로 파란색에 적용되는 &lt;a href=&quot;qml-qtquick-rectangle&quot;&gt;사각형&lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="6a3ce649d4099a8096022c6c669c9176b6fc57ee" translate="yes" xml:space="preserve">
          <source>When the \brief command is used to describe a class, we recommend using a complete sentence like this:</source>
          <target state="translated">\ brief 명령을 사용하여 클래스를 설명 할 때는 다음과 같은 완전한 문장을 사용하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="557b6338e75a33d13fe088abb975f18a855ab911" translate="yes" xml:space="preserve">
          <source>When the \brief command is used to describe a property or a variable, the brief text must be a sentence fragment starting with &quot;whether&quot; (for a boolean property or variable) or starting with &quot;the&quot; (for any other property or variable).</source>
          <target state="translated">\ brief 명령을 사용하여 속성 또는 변수를 설명하는 경우 간단한 텍스트는 &quot;whether&quot;(부울 속성 또는 변수)로 시작하거나 &quot;the&quot;(다른 속성 또는 변수)로 시작하는 문장 조각이어야합니다. .</target>
        </trans-unit>
        <trans-unit id="68de879942c076ccf49dec3b35482feaabb2b36a" translate="yes" xml:space="preserve">
          <source>When the above view is flicked beyond its bounds, it will return to its bounds using the transition specified:</source>
          <target state="translated">위의 뷰가 경계를 넘어 넘어지면 지정된 전환을 사용하여 경계로 돌아갑니다.</target>
        </trans-unit>
        <trans-unit id="589227a0f3172c2f19894c29348f6198f079bcbc" translate="yes" xml:space="preserve">
          <source>When the active subwindow is maximized, the default behavior is to maximize the next subwindow that is activated. Set this option if you do not want this behavior.</source>
          <target state="translated">활성 하위 창을 최대화하면 기본 동작은 활성화 된 다음 하위 창을 최대화하는 것입니다. 이 동작을 원하지 않으면이 옵션을 설정하십시오.</target>
        </trans-unit>
        <trans-unit id="5a7ce62c114b1cc52094be5a1851abc5fc7f2e64" translate="yes" xml:space="preserve">
          <source>When the alpha channel is enabled either via &lt;a href=&quot;qquickwindow#setDefaultAlphaBuffer&quot;&gt;QQuickWindow::setDefaultAlphaBuffer&lt;/a&gt;() or by setting alphaBufferSize to a non-zero value in the window's &lt;a href=&quot;qsurfaceformat&quot;&gt;QSurfaceFormat&lt;/a&gt; or in the global format managed by &lt;a href=&quot;qsurfaceformat#setDefaultFormat&quot;&gt;QSurfaceFormat::setDefaultFormat&lt;/a&gt;(), the D3D12 backend will create a swapchain for composition and go through DirectComposition. This is necessary, because the mandatory flip model swapchain wouldn't support transparency otherwise.</source>
          <target state="translated">알파 채널이 &lt;a href=&quot;qquickwindow#setDefaultAlphaBuffer&quot;&gt;QQuickWindow :: setDefaultAlphaBuffer&lt;/a&gt; () 를 통해 활성화되거나 창의 &lt;a href=&quot;qsurfaceformat&quot;&gt;QSurfaceFormat&lt;/a&gt; 또는 &lt;a href=&quot;qsurfaceformat#setDefaultFormat&quot;&gt;QSurfaceFormat :: setDefaultFormat&lt;/a&gt; ()에 의해 관리되는 전역 형식에서 alphaBufferSize를 0이 아닌 값으로 설정 하여 D3D12 백엔드는 스왑 체인을 생성합니다. 구성하고 DirectComposition을 진행하십시오. 필수 플립 모델 스왑 체인은 그렇지 않으면 투명성을 지원하지 않기 때문에 이것이 필요합니다.</target>
        </trans-unit>
        <trans-unit id="abead2ff8ba68473ab0f073d1c6b50c8ad980ea5" translate="yes" xml:space="preserve">
          <source>When the application is running with the generic, triangulation-based Shape implementation, the geometry generation happens entirely on the CPU. This is potentially expensive. Changing the set of path elements, changing the properties of these elements, or changing certain properties of the Shape itself all lead to retriangulation of the affected paths on every change. Therefore, applying animation to such properties can affect performance on less powerful systems.</source>
          <target state="translated">응용 프로그램이 일반 삼각 측량 기반 Shape 구현으로 실행될 때 지오메트리 생성은 전적으로 CPU에서 발생합니다. 이것은 잠재적으로 비싸다. 패스 요소 집합을 변경하거나, 이러한 요소의 속성을 변경하거나, 셰이프 자체의 특정 속성을 변경하면 모든 변경에 영향을받는 경로가 다시 삼각형 화됩니다. 따라서 이러한 속성에 애니메이션을 적용하면 성능이 떨어지는 시스템의 성능에 영향을 줄 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2dc59efa2f06087183eee0fb11a7e9582ff61062" translate="yes" xml:space="preserve">
          <source>When the application is running, an IDE or a tool that implements the binary protocol can connect to the open port.</source>
          <target state="translated">응용 프로그램이 실행 중이면 바이너리 프로토콜을 구현하는 IDE 또는 도구가 열린 포트에 연결할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c469e679911aae260b7551ead885271015ff56e7" translate="yes" xml:space="preserve">
          <source>When the application is started it has to register an message handler with &lt;a href=&quot;qnearfieldmanager#registerNdefMessageHandler&quot;&gt;registerNdefMessageHandler()&lt;/a&gt; The first NDEF message arriving in the handler is the message that started the application. See the &lt;a href=&quot;https://doc.qt.io/qt-5.13/qtnfc-corkboard-example.html#&quot;&gt;CorkBoard&lt;/a&gt; application for an example.</source>
          <target state="translated">응용 프로그램이 시작되면 &lt;a href=&quot;qnearfieldmanager#registerNdefMessageHandler&quot;&gt;registerNdefMessageHandler ()&lt;/a&gt; 로 메시지 처리기를 등록해야합니다. 처리기에 도착하는 첫 번째 NDEF 메시지는 응용 프로그램을 시작한 메시지입니다. 예제 는 &lt;a href=&quot;https://doc.qt.io/qt-5.13/qtnfc-corkboard-example.html#&quot;&gt;CorkBoard&lt;/a&gt; 애플리케이션을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="50a549dc65fe725b80a97de046a5a0dc3b6c6fb6" translate="yes" xml:space="preserve">
          <source>When the binding becomes inactive again, any direct bindings that were previously set on the property will be restored.</source>
          <target state="translated">바인딩이 다시 비활성화되면 속성에 이전에 설정된 모든 직접 바인딩이 복원됩니다.</target>
        </trans-unit>
        <trans-unit id="447dd45f7b45ede6829150c673fe906621c3daff" translate="yes" xml:space="preserve">
          <source>When the button is clicked, the purchase process is started. At some point in the future, either the &lt;a href=&quot;qml-qtpurchasing-product#onPurchaseFailed-signal&quot;&gt;onPurchaseFailed&lt;/a&gt; handler will be called (for example if the user cancels the transaction), or the &lt;a href=&quot;qml-qtpurchasing-product#onPurchaseSucceeded-signal&quot;&gt;onPurchaseSucceeded&lt;/a&gt; handler will be called.</source>
          <target state="translated">버튼을 클릭하면 구매 프로세스가 시작됩니다. 나중에 &lt;a href=&quot;qml-qtpurchasing-product#onPurchaseFailed-signal&quot;&gt;언젠가&lt;/a&gt; 는 onPurchaseFailed 핸들러가 호출 되거나 (예 : 사용자가 트랜잭션을 취소 한 경우) &lt;a href=&quot;qml-qtpurchasing-product#onPurchaseSucceeded-signal&quot;&gt;onPurchaseSucceeded&lt;/a&gt; 핸들러가 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="4ebbf8f547dd292e8432493d1f5c0d39a31ffd9b" translate="yes" xml:space="preserve">
          <source>When the client is connected successfully, we connect to the `onTextMessageReceived()` signal, and send out &quot;Hello, world!&quot;. If connected with the EchoServer, we will receive the same message back.</source>
          <target state="translated">클라이언트가 성공적으로 연결되면, 우리는`onTextMessageReceived ()`신호에 연결하고 &quot;Hello, world!&quot;를 보냅니다. EchoServer와 연결되면 동일한 메시지가 다시 나타납니다.</target>
        </trans-unit>
        <trans-unit id="5d66decd4409859b0e6cc5ba70ca923d5222b329" translate="yes" xml:space="preserve">
          <source>When the connection to the &lt;a href=&quot;qtremoteobjects-source#source&quot;&gt;Source&lt;/a&gt; object is made, the initialization step passes the current property values (see &lt;a href=&quot;qtremoteobjects-replica#replica-initialization&quot;&gt;Replica Initialization&lt;/a&gt;). In a DynamicReplica, the property/signal/slot details are also sent, allowing the replica object to be created on-the-fly. This can be conventient in QML or scripting, but has two primary disadvantages. First, the object is in effect &quot;empty&quot; until it is successfully initialized by the &lt;a href=&quot;qtremoteobjects-source#source&quot;&gt;Source&lt;/a&gt;. Second, in C++, calls must be made using &lt;a href=&quot;qmetaobject#invokeMethod&quot;&gt;QMetaObject::invokeMethod&lt;/a&gt;(), as the moc generated lookup will not be available.</source>
          <target state="translated">&lt;a href=&quot;qtremoteobjects-source#source&quot;&gt;Source&lt;/a&gt; 객체에 연결되면 초기화 단계에서 현재 속성 값을 전달합니다 ( &lt;a href=&quot;qtremoteobjects-replica#replica-initialization&quot;&gt;복제본 초기화&lt;/a&gt; 참조 ). DynamicReplica에서는 속성 / 신호 / 슬롯 세부 정보도 전송되어 복제본 개체를 즉석에서 만들 수 있습니다. 이는 QML 또는 스크립팅에서 편리 할 수 ​​있지만 두 가지 주요 단점이 있습니다. 먼저, 객체는 &lt;a href=&quot;qtremoteobjects-source#source&quot;&gt;Source에&lt;/a&gt; 의해 성공적으로 초기화 될 때까지 &quot;빈&quot;상태 입니다. 두 번째로, C ++에서는 moc로 생성 된 조회를 사용할 수 없으므로 &lt;a href=&quot;qmetaobject#invokeMethod&quot;&gt;QMetaObject :: invokeMethod&lt;/a&gt; ()를 사용하여 호출해야합니다 .</target>
        </trans-unit>
        <trans-unit id="08ec6e33eebed26c7c57c8ed22fb0ac60abd982e" translate="yes" xml:space="preserve">
          <source>When the content is changed using any of these functions, any previous content is cleared.</source>
          <target state="translated">이러한 기능 중 하나를 사용하여 내용을 변경하면 이전 내용이 지워집니다.</target>
        </trans-unit>
        <trans-unit id="098eff2cee4bb06ded290defca5ca43aedeb73b3" translate="yes" xml:space="preserve">
          <source>When the current element is a map, you may also call &lt;a href=&quot;qcborstreamreader#isLengthKnown&quot;&gt;isLengthKnown&lt;/a&gt;() to find out if the map's size is explicit in the CBOR stream. If it is, that size can be obtained by calling &lt;a href=&quot;qcborstreamreader#length&quot;&gt;length&lt;/a&gt;().</source>
          <target state="translated">현재 요소가지도 인 경우 &lt;a href=&quot;qcborstreamreader#isLengthKnown&quot;&gt;isLengthKnown&lt;/a&gt; ()을 호출 하여지도 크기가 CBOR 스트림에서 명시 적인지 확인할 수도 있습니다 . 그렇다면 &lt;a href=&quot;qcborstreamreader#length&quot;&gt;길이&lt;/a&gt; () 를 호출하여 해당 크기를 얻을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="bea6a9143e97cc060ee75f79678b23a7773047e8" translate="yes" xml:space="preserve">
          <source>When the current element is an array, you may also call &lt;a href=&quot;qcborstreamreader#isLengthKnown&quot;&gt;isLengthKnown&lt;/a&gt;() to find out if the array's size is explicit in the CBOR stream. If it is, that size can be obtained by calling &lt;a href=&quot;qcborstreamreader#length&quot;&gt;length&lt;/a&gt;().</source>
          <target state="translated">현재 요소가 배열 인 경우 &lt;a href=&quot;qcborstreamreader#isLengthKnown&quot;&gt;isLengthKnown&lt;/a&gt; ()을 호출 하여 CBOR 스트림에서 배열의 크기가 명시 적인지 확인할 수도 있습니다 . 그렇다면 &lt;a href=&quot;qcborstreamreader#length&quot;&gt;길이&lt;/a&gt; () 를 호출하여 해당 크기를 얻을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="f84400c746d8fc0a5a48647d3e3c7ab1cfd364c9" translate="yes" xml:space="preserve">
          <source>When the current file changes for local operations, this signal is emitted with the new file name as the</source>
          <target state="translated">현재 파일이 로컬 작업을 위해 변경되면이 신호는 새 파일 이름으로</target>
        </trans-unit>
        <trans-unit id="0a86295fc3e43e6a47bc831aed3e39216c7b217d" translate="yes" xml:space="preserve">
          <source>When the current file changes, this signal is emitted with the new file URL as the</source>
          <target state="translated">현재 파일이 변경되면이 신호는 새 파일 URL과 함께</target>
        </trans-unit>
        <trans-unit id="8d02ddfa1e09fd4df4941f2aea01335858653f59" translate="yes" xml:space="preserve">
          <source>When the current loop changes, &lt;a href=&quot;qabstractanimation&quot;&gt;QAbstractAnimation&lt;/a&gt; emits the &lt;a href=&quot;qabstractanimation#currentLoopChanged&quot;&gt;currentLoopChanged&lt;/a&gt;() signal.</source>
          <target state="translated">현재 루프가 변경되면 &lt;a href=&quot;qabstractanimation&quot;&gt;QAbstractAnimation&lt;/a&gt; 은 &lt;a href=&quot;qabstractanimation#currentLoopChanged&quot;&gt;currentLoopChanged&lt;/a&gt; () 신호를 방출합니다 .</target>
        </trans-unit>
        <trans-unit id="0cfe43b8f234528af4d27981c91186f3fac30622" translate="yes" xml:space="preserve">
          <source>When the current size of the cache is greater than the &lt;a href=&quot;qnetworkdiskcache#maximumCacheSize&quot;&gt;maximumCacheSize&lt;/a&gt;() older cache files are removed until the total size is less then 90% of &lt;a href=&quot;qnetworkdiskcache#maximumCacheSize&quot;&gt;maximumCacheSize&lt;/a&gt;() starting with the oldest ones first using the file creation date to determine how old a cache file is.</source>
          <target state="translated">캐시의 현재 크기가 &lt;a href=&quot;qnetworkdiskcache#maximumCacheSize&quot;&gt;maximumCacheSize&lt;/a&gt; () 보다 큰 경우 총 크기가 파일 생성 날짜를 사용하여 가장 오래된 파일부터 시작하여 &lt;a href=&quot;qnetworkdiskcache#maximumCacheSize&quot;&gt;maximumCacheSize&lt;/a&gt; () 의 90 %보다 작을 때까지 이전 캐시 파일이 제거되어 캐시 파일의 수 를 결정합니다. 입니다.</target>
        </trans-unit>
        <trans-unit id="3e61c9290a3e31fccfacad9bcadb7f0ab37cb158" translate="yes" xml:space="preserve">
          <source>When the cursor is moved and the underlying formatting attributes change, the &lt;a href=&quot;qtextedit#currentCharFormatChanged&quot;&gt;currentCharFormatChanged&lt;/a&gt;() signal is emitted to reflect the new attributes at the new cursor position.</source>
          <target state="translated">커서가 이동하고 기본 형식 속성이 변경되면 &lt;a href=&quot;qtextedit#currentCharFormatChanged&quot;&gt;currentCharFormatChanged&lt;/a&gt; () 신호가 생성되어 새 커서 위치에서 새 속성이 반영됩니다.</target>
        </trans-unit>
        <trans-unit id="0bcf3c2857361e33820b911b748bda8d3e8f2499" translate="yes" xml:space="preserve">
          <source>When the cursor is over an object that can be used in a connection, the object will be highlighted.</source>
          <target state="translated">커서가 연결에 사용될 수있는 객체 위에 있으면 객체가 강조 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="d5828b4053e945be1fe64d76bbf73ddc4acecf13" translate="yes" xml:space="preserve">
          <source>When the dark theme is in use, different &lt;a href=&quot;#pre-defined-shades&quot;&gt;shades&lt;/a&gt; of the pre-defined colors are used by default:</source>
          <target state="translated">어두운 테마 를 사용하는 경우 기본적으로 미리 정의 된 색상의 다른 &lt;a href=&quot;#pre-defined-shades&quot;&gt;음영&lt;/a&gt; 이 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="aa15325522b12e3e10e05b6e7845de4c15cc9516" translate="yes" xml:space="preserve">
          <source>When the data has been set, the model must let the views know that some data has changed. This is done by emitting the &lt;a href=&quot;qabstractitemmodel#dataChanged&quot;&gt;dataChanged()&lt;/a&gt; signal. Since only one item of data has changed, the range of items specified in the signal is limited to just one model index.</source>
          <target state="translated">데이터가 설정되면 모델은 일부 데이터가 변경되었음을 뷰에 알려야합니다. 이것은 &lt;a href=&quot;qabstractitemmodel#dataChanged&quot;&gt;dataChanged ()&lt;/a&gt; 신호 를 방출하여 수행됩니다 . 하나의 데이터 항목 만 변경되었으므로 신호에 지정된 항목 범위는 하나의 모델 색인으로 제한됩니다.</target>
        </trans-unit>
        <trans-unit id="39d841b77292d3e68d73048948b5c24756c32f98" translate="yes" xml:space="preserve">
          <source>When the default OpenGL &lt;a href=&quot;qtquick-visualcanvas-scenegraph#&quot;&gt;scene graph&lt;/a&gt; backend is in use, images can also be supplied in compressed texture files. The content must be a simple RGB(A) format 2D texture. Supported compression schemes are only limited by the underlying OpenGL driver and GPU. The following container file formats are supported:</source>
          <target state="translated">기본 OpenGL &lt;a href=&quot;qtquick-visualcanvas-scenegraph#&quot;&gt;장면 그래프&lt;/a&gt; 백엔드를 사용중인 경우 이미지를 압축 된 텍스처 파일로 제공 할 수도 있습니다. 내용은 간단한 RGB (A) 형식 2D 텍스처 여야합니다. 지원되는 압축 방식은 기본 OpenGL 드라이버 및 GPU에 의해서만 제한됩니다. 다음과 같은 컨테이너 파일 형식이 지원됩니다.</target>
        </trans-unit>
        <trans-unit id="64564ede097c86de33c3d219ff3f4d6b55c9c533" translate="yes" xml:space="preserve">
          <source>When the dialog needs to generate a set of preview pages, the &lt;a href=&quot;qprintpreviewdialog#paintRequested&quot;&gt;paintRequested&lt;/a&gt;() signal will be emitted. You can use the exact same code for the actual printing as for having the preview generated, including calling &lt;a href=&quot;qprinter#newPage&quot;&gt;QPrinter::newPage&lt;/a&gt;() to start a new page in the preview. Connect a slot to the &lt;a href=&quot;qprintpreviewdialog#paintRequested&quot;&gt;paintRequested&lt;/a&gt;() signal, where you draw onto the &lt;a href=&quot;qprinter&quot;&gt;QPrinter&lt;/a&gt; object that is passed into the slot.</source>
          <target state="translated">대화 상자에서 미리보기 페이지 세트를 생성 &lt;a href=&quot;qprintpreviewdialog#paintRequested&quot;&gt;해야하는&lt;/a&gt; 경우 paintRequested () 신호가 생성됩니다. &lt;a href=&quot;qprinter#newPage&quot;&gt;QPrinter :: newPage&lt;/a&gt; ()를 호출 하여 미리보기에서 새 페이지를 시작하는 것을 포함하여 미리보기를 생성 할 때와 동일한 코드를 실제 인쇄에 사용할 수 있습니다 . 슬롯을 &lt;a href=&quot;qprintpreviewdialog#paintRequested&quot;&gt;paintRequested&lt;/a&gt; () 신호에 연결합니다. 여기서 슬롯으로 전달되는 &lt;a href=&quot;qprinter&quot;&gt;QPrinter&lt;/a&gt; 객체를 그 립니다 .</target>
        </trans-unit>
        <trans-unit id="442b26fe36b5b6b28e8fee4c93f0f0f9179a4be0" translate="yes" xml:space="preserve">
          <source>When the disk cache is disabled, via &lt;a href=&quot;qt#ApplicationAttribute-enum&quot;&gt;Qt::AA_DisableShaderDiskCache&lt;/a&gt; for example, or the OpenGL context has no support for context binaries, calling this function is equivalent to &lt;a href=&quot;qopenglshaderprogram#addShaderFromSourceCode&quot;&gt;addShaderFromSourceCode&lt;/a&gt;().</source>
          <target state="translated">예를 들어 &lt;a href=&quot;qt#ApplicationAttribute-enum&quot;&gt;Qt :: AA_DisableShaderDiskCache&lt;/a&gt; 를 통해 디스크 캐시가 비활성화 되거나 OpenGL 컨텍스트가 컨텍스트 바이너리를 지원하지 않는 경우이 함수를 호출하는 것은 &lt;a href=&quot;qopenglshaderprogram#addShaderFromSourceCode&quot;&gt;addShaderFromSourceCode&lt;/a&gt; () 와 같습니다 .</target>
        </trans-unit>
        <trans-unit id="9a274b9868a858f6451036974bc85cd45ebacc98" translate="yes" xml:space="preserve">
          <source>When the disk cache is disabled, via &lt;a href=&quot;qt#ApplicationAttribute-enum&quot;&gt;Qt::AA_DisableShaderDiskCache&lt;/a&gt; for example, or the OpenGL context has no support for context binaries, calling this function is equivalent to &lt;a href=&quot;qopenglshaderprogram#addShaderFromSourceFile&quot;&gt;addShaderFromSourceFile&lt;/a&gt;().</source>
          <target state="translated">예를 들어 &lt;a href=&quot;qt#ApplicationAttribute-enum&quot;&gt;Qt :: AA_DisableShaderDiskCache&lt;/a&gt; 를 통해 디스크 캐시를 비활성화 하거나 OpenGL 컨텍스트에서 컨텍스트 바이너리를 지원하지 않는 경우이 함수를 호출하는 것은 &lt;a href=&quot;qopenglshaderprogram#addShaderFromSourceFile&quot;&gt;addShaderFromSourceFile&lt;/a&gt; () 과 같습니다 .</target>
        </trans-unit>
        <trans-unit id="cfc128bc4fe84e02bab33b87cc2068b75786b6b9" translate="yes" xml:space="preserve">
          <source>When the dock widget lays out its contents it asks the style for these pixel metrics: &lt;code&gt;PM_DockWidgetSeparatorExtent&lt;/code&gt;, &lt;code&gt;PM_DockWidgetTitleBarButtonMargin&lt;/code&gt;, &lt;code&gt;PM_DockWidgetFrameWidth&lt;/code&gt;, and &lt;code&gt;PM_DockWidgetTitleMargin&lt;/code&gt;. It also calculates the bounding rectangles of the float and close buttons with &lt;code&gt;SE_DockWidgetCloseButton&lt;/code&gt; and &lt;code&gt;SE_DockWidgetFloatButton&lt;/code&gt;.</source>
          <target state="translated">도크 위젯은 내용을 배치 할 때 &lt;code&gt;PM_DockWidgetSeparatorExtent&lt;/code&gt; , &lt;code&gt;PM_DockWidgetTitleBarButtonMargin&lt;/code&gt; , &lt;code&gt;PM_DockWidgetFrameWidth&lt;/code&gt; 및 &lt;code&gt;PM_DockWidgetTitleMargin&lt;/code&gt; 픽셀 스타일의 스타일을 묻습니다 . 또한 &lt;code&gt;SE_DockWidgetCloseButton&lt;/code&gt; 및 &lt;code&gt;SE_DockWidgetFloatButton&lt;/code&gt; 을 사용하여 float 및 close 버튼의 경계 사각형을 계산합니다 .</target>
        </trans-unit>
        <trans-unit id="dc07829ed23956686aa2110b6aa13a3a31695d82" translate="yes" xml:space="preserve">
          <source>When the edit strategy is &lt;a href=&quot;qsqltablemodel#EditStrategy-enum&quot;&gt;OnManualSubmit&lt;/a&gt;, deletion of rows from the database is delayed until &lt;a href=&quot;qsqltablemodel#submitAll&quot;&gt;submitAll&lt;/a&gt;() is called.</source>
          <target state="translated">편집 전략이 &lt;a href=&quot;qsqltablemodel#EditStrategy-enum&quot;&gt;OnManualSubmit&lt;/a&gt; 인 경우 데이터베이스에서 행 삭제는 &lt;a href=&quot;qsqltablemodel#submitAll&quot;&gt;submitAll&lt;/a&gt; ()이 호출 될 때까지 지연 됩니다.</target>
        </trans-unit>
        <trans-unit id="5ce533133f051ef361f68d445640b0f45e1ae0bd" translate="yes" xml:space="preserve">
          <source>When the error occurs in code that uses the &lt;a href=&quot;qaxfactory#QAXFACTORY_DEFAULT&quot;&gt;QAXFACTORY_DEFAULT&lt;/a&gt;() macro, the widget class had no constructor that can be used by the default factory. Either add a standard widget constructor or implement a custom factory that doesn't require one.</source>
          <target state="translated">&lt;a href=&quot;qaxfactory#QAXFACTORY_DEFAULT&quot;&gt;QAXFACTORY_DEFAULT&lt;/a&gt; () 매크로 를 사용하는 코드에서 오류가 발생 하면 위젯 클래스에 기본 팩토리에서 사용할 수있는 생성자가 없었습니다. 표준 위젯 생성자를 추가하거나 필요하지 않은 사용자 정의 팩토리를 구현하십시오.</target>
        </trans-unit>
        <trans-unit id="67528e55cc72382a76299d4a29a6d404185ca633" translate="yes" xml:space="preserve">
          <source>When the error occurs in code that uses the &lt;a href=&quot;qaxfactory#QAXFACTORY_EXPORT&quot;&gt;QAXFACTORY_EXPORT&lt;/a&gt;() macro, the &lt;a href=&quot;qaxfactory&quot;&gt;QAxFactory&lt;/a&gt; subclass had no appropriate constructor. Provide a public class constructor like</source>
          <target state="translated">&lt;a href=&quot;qaxfactory#QAXFACTORY_EXPORT&quot;&gt;QAXFACTORY_EXPORT&lt;/a&gt; () 매크로 를 사용하는 코드에서 오류가 발생 하면 &lt;a href=&quot;qaxfactory&quot;&gt;QAxFactory&lt;/a&gt; 서브 클래스에 적절한 생성자가 없습니다. 다음과 같은 공개 클래스 생성자를 제공하십시오.</target>
        </trans-unit>
        <trans-unit id="667bcb82ac840306758fe028ef02a3142d64c33c" translate="yes" xml:space="preserve">
          <source>When the file was created (may not be not supported on UNIX).</source>
          <target state="translated">파일이 작성된시기 (UNIX에서는 지원되지 않을 수 있음).</target>
        </trans-unit>
        <trans-unit id="b25b4b7cadd51d3809c6192d30e9736fd31ceee0" translate="yes" xml:space="preserve">
          <source>When the file was most recently accessed (e.g. read or written to).</source>
          <target state="translated">파일이 가장 최근에 액세스 된시기 (예 : 읽기 또는 쓰기)</target>
        </trans-unit>
        <trans-unit id="4c27bd30e3a44efb1b186d178c93f6ceaf40ce32" translate="yes" xml:space="preserve">
          <source>When the file was most recently modified.</source>
          <target state="translated">파일이 가장 최근에 수정 된시기</target>
        </trans-unit>
        <trans-unit id="d5d340431973f92573daf9a19dcdb9fd00b81737" translate="yes" xml:space="preserve">
          <source>When the file's metadata was last changed.</source>
          <target state="translated">파일의 메타 데이터가 마지막으로 변경된시기</target>
        </trans-unit>
        <trans-unit id="0ed30361bc54f69e5900b60fbcec5e46b66fc62b" translate="yes" xml:space="preserve">
          <source>When the filter object's &lt;a href=&quot;qobject#eventFilter&quot;&gt;eventFilter()&lt;/a&gt; implementation is called, it can accept or reject the event, and allow or deny further processing of the event. If all the event filters allow further processing of an event (by each returning &lt;code&gt;false&lt;/code&gt;), the event is sent to the target object itself. If one of them stops processing (by returning &lt;code&gt;true&lt;/code&gt;), the target and any later event filters do not get to see the event at all.</source>
          <target state="translated">필터 객체의 &lt;a href=&quot;qobject#eventFilter&quot;&gt;eventFilter ()&lt;/a&gt; 구현이 호출되면 이벤트를 수락 또는 거부하고 추가 이벤트 처리를 허용하거나 거부 할 수 있습니다. 모든 이벤트 필터가 이벤트의 추가 처리를 허용하면 (각각 &lt;code&gt;false&lt;/code&gt; 를 리턴 하여) 이벤트가 대상 오브젝트 자체로 전송됩니다. 이들 중 하나가 처리를 중지하면 ( &lt;code&gt;true&lt;/code&gt; 를 리턴 하여) 대상 및 이후의 이벤트 필터가 이벤트를 전혀 보지 못하게됩니다.</target>
        </trans-unit>
        <trans-unit id="837b081290388ef24310dab55793156db9eb9dfc" translate="yes" xml:space="preserve">
          <source>When the first touch point is detected, the destination widget is determined firstly by the location on screen and secondly by the propagation rules.</source>
          <target state="translated">제 1 터치 포인트가 검출 될 때, 목적지 위젯은 먼저 스크린상의 위치에 의해 그리고 두번째는 전파 규칙에 의해 결정된다.</target>
        </trans-unit>
        <trans-unit id="60ff0e9974e90a3bb46faadb679db78b2703c023" translate="yes" xml:space="preserve">
          <source>When the format is not explicitly set via this function, the format returned by &lt;a href=&quot;qsurfaceformat#defaultFormat&quot;&gt;QSurfaceFormat::defaultFormat&lt;/a&gt;() will be used. This means that when having multiple OpenGL widgets, individual calls to this function can be replaced by one single call to &lt;a href=&quot;qsurfaceformat#setDefaultFormat&quot;&gt;QSurfaceFormat::setDefaultFormat&lt;/a&gt;() before creating the first widget.</source>
          <target state="translated">이 함수를 통해 형식을 명시 적으로 설정하지 않으면 &lt;a href=&quot;qsurfaceformat#defaultFormat&quot;&gt;QSurfaceFormat :: defaultFormat&lt;/a&gt; ()에서 반환 한 형식 이 사용됩니다. 이는 여러 OpenGL 위젯이 있는 경우 첫 번째 위젯을 작성하기 &lt;a href=&quot;qsurfaceformat#setDefaultFormat&quot;&gt;전에이&lt;/a&gt; 함수에 대한 개별 호출을 QSurfaceFormat :: setDefaultFormat ()에 대한 단일 호출로 대체 할 수 있음을 의미 합니다.</target>
        </trans-unit>
        <trans-unit id="2beb1fd6e4f28222293604d7f4d897a896d350d1" translate="yes" xml:space="preserve">
          <source>When the format is not explicitly set via this function, the format returned by &lt;a href=&quot;qsurfaceformat#defaultFormat&quot;&gt;QSurfaceFormat::defaultFormat&lt;/a&gt;() will be used. This means that when having multiple contexts, individual calls to this function can be replaced by one single call to &lt;a href=&quot;qsurfaceformat#setDefaultFormat&quot;&gt;QSurfaceFormat::setDefaultFormat&lt;/a&gt;() before creating the first context.</source>
          <target state="translated">이 함수를 통해 형식을 명시 적으로 설정하지 않으면 &lt;a href=&quot;qsurfaceformat#defaultFormat&quot;&gt;QSurfaceFormat :: defaultFormat&lt;/a&gt; ()에서 반환 한 형식 이 사용됩니다. 이는 여러 컨텍스트가있는 경우 첫 번째 컨텍스트를 작성하기 &lt;a href=&quot;qsurfaceformat#setDefaultFormat&quot;&gt;전에이&lt;/a&gt; 함수에 대한 개별 호출을 QSurfaceFormat :: setDefaultFormat ()에 대한 단일 호출로 대체 할 수 있음을 의미 합니다.</target>
        </trans-unit>
        <trans-unit id="00713dadf93099ecb982ada3e77d69bdabc871f2" translate="yes" xml:space="preserve">
          <source>When the format is not explicitly set via this function, the format returned by &lt;a href=&quot;qsurfaceformat#defaultFormat&quot;&gt;QSurfaceFormat::defaultFormat&lt;/a&gt;() will be used. This means that when having multiple windows, individual calls to this function can be replaced by one single call to &lt;a href=&quot;qsurfaceformat#setDefaultFormat&quot;&gt;QSurfaceFormat::setDefaultFormat&lt;/a&gt;() before creating the first window.</source>
          <target state="translated">이 함수를 통해 형식을 명시 적으로 설정하지 않으면 &lt;a href=&quot;qsurfaceformat#defaultFormat&quot;&gt;QSurfaceFormat :: defaultFormat&lt;/a&gt; ()에서 반환 한 형식 이 사용됩니다. 이는 여러 개의 창이있을 때 첫 번째 창을 만들기 &lt;a href=&quot;qsurfaceformat#setDefaultFormat&quot;&gt;전에이&lt;/a&gt; 함수에 대한 개별 호출을 QSurfaceFormat :: setDefaultFormat ()에 대한 단일 호출로 대체 할 수 있음을 의미 합니다.</target>
        </trans-unit>
        <trans-unit id="25d8d569194c95628c8a9af91c9b0f5b8ee86128" translate="yes" xml:space="preserve">
          <source>When the given</source>
          <target state="translated">주어진 때</target>
        </trans-unit>
        <trans-unit id="a84c5e22d39ffceb346211bc14286a14c79f8784" translate="yes" xml:space="preserve">
          <source>When the horizontal alignment of a text item is not explicitly set, the text element is automatically aligned to the natural reading direction of the text. By default left-to-right text like English is aligned to the left side of the text area, and right-to-left text like Arabic is aligned to the right side of the text area. The alignment of a text element with empty text takes its alignment cue from &lt;a href=&quot;qinputmethod#inputDirection-prop&quot;&gt;QInputMethod::inputDirection&lt;/a&gt;(), which is based on the active system locale.</source>
          <target state="translated">텍스트 항목의 가로 정렬이 명시 적으로 설정되지 않은 경우 텍스트 요소는 텍스트의 자연스러운 읽기 방향에 자동으로 정렬됩니다. 기본적으로 영어와 같은 왼쪽에서 오른쪽 텍스트는 텍스트 영역의 왼쪽에 정렬되고 아랍어와 같은 오른쪽에서 왼쪽 텍스트는 텍스트 영역의 오른쪽에 정렬됩니다. 빈 텍스트를 가진 텍스트 요소의 정렬 은 활성 시스템 로케일을 기반으로하는 &lt;a href=&quot;qinputmethod#inputDirection-prop&quot;&gt;QInputMethod :: inputDirection&lt;/a&gt; () 에서 정렬 큐를 가져 옵니다.</target>
        </trans-unit>
        <trans-unit id="2f163bb4526ffce4c5d0c97da01d544fc9ab7648" translate="yes" xml:space="preserve">
          <source>When the image is ready, &lt;a href=&quot;qml-qtquick-canvas#imageLoaded-signal&quot;&gt;imageLoaded&lt;/a&gt; will be emitted. The loaded image can be unloaded by the &lt;a href=&quot;qml-qtquick-canvas#unloadImage-method&quot;&gt;unloadImage()&lt;/a&gt; method.</source>
          <target state="translated">이미지가 준비되면 &lt;a href=&quot;qml-qtquick-canvas#imageLoaded-signal&quot;&gt;imageLoaded&lt;/a&gt; 가 방출됩니다. 로드 된 이미지는 &lt;a href=&quot;qml-qtquick-canvas#unloadImage-method&quot;&gt;unloadImage ()&lt;/a&gt; 메소드 로 언로드 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="4722dd5405336bb1dc515fbc7e7e1db0a5d91ef2" translate="yes" xml:space="preserve">
          <source>When the image is scaled, regions of the source image are scaled or tiled to create the displayed border image in the following way:</source>
          <target state="translated">이미지의 크기가 조정되면 소스 이미지의 영역이 다음과 같은 방식으로 표시된 테두리 이미지를 만들기 위해 크기가 조정되거나 바둑판 식으로 배열됩니다.</target>
        </trans-unit>
        <trans-unit id="cb1a5c40c986de8b7e66b324c82e0775e3788bc6" translate="yes" xml:space="preserve">
          <source>When the image is used, the color table must be large enough to have entries for all the pixel/index values present in the image, otherwise the results are undefined.</source>
          <target state="translated">이미지를 사용하는 경우 색상 표는 이미지에있는 모든 픽셀 / 인덱스 값에 대한 항목을 가질 수있을 정도로 커야합니다. 그렇지 않으면 결과가 정의되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="a62a0ab3afb30df54c7a307954a51b28f0879b31" translate="yes" xml:space="preserve">
          <source>When the indexing process has finished, the search engine can be used to search through the index for a given term using the search() function. When the search input is passed to the search engine, the &lt;a href=&quot;qhelpsearchengine#searchingStarted&quot;&gt;searchingStarted&lt;/a&gt;() signal is emitted. When the search finishes, the &lt;a href=&quot;qhelpsearchengine#searchingFinished&quot;&gt;searchingFinished&lt;/a&gt;() signal is emitted. The search process can be stopped by calling &lt;a href=&quot;qhelpsearchengine#cancelSearching&quot;&gt;cancelSearching&lt;/a&gt;().</source>
          <target state="translated">색인 작성 프로세스가 완료되면 검색 엔진을 사용하여 search () 함수를 사용하여 주어진 용어에 대한 색인을 검색 할 수 있습니다. 검색 입력이 검색 엔진에 전달되면 &lt;a href=&quot;qhelpsearchengine#searchingStarted&quot;&gt;searchingStarted&lt;/a&gt; () 신호가 발생합니다. 검색이 완료되면 &lt;a href=&quot;qhelpsearchengine#searchingFinished&quot;&gt;searchingFinished&lt;/a&gt; () 신호가 발생합니다. &lt;a href=&quot;qhelpsearchengine#cancelSearching&quot;&gt;cancelSearching&lt;/a&gt; () 을 호출하여 검색 프로세스를 중지 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="abed85d30a721e876a4399c7b26aa9eed3e46ead" translate="yes" xml:space="preserve">
          <source>When the input method requires the UI to update the contents of a selection list, it will emit the &lt;a href=&quot;qml-qtquick-virtualkeyboard-inputmethod#selectionListChanged-signal&quot;&gt;InputMethod::selectionListChanged&lt;/a&gt; signal. Likewise, if the input method requires the UI to highlight an item in the list, it will emit the &lt;a href=&quot;qml-qtquick-virtualkeyboard-inputmethod#selectionListActiveItemChanged-signal&quot;&gt;InputMethod::selectionListActiveItemChanged&lt;/a&gt; signal.</source>
          <target state="translated">입력 방법에서 UI가 선택 목록의 내용을 업데이트해야하는 경우 &lt;a href=&quot;qml-qtquick-virtualkeyboard-inputmethod#selectionListChanged-signal&quot;&gt;InputMethod :: selectionListChanged&lt;/a&gt; 신호를 생성합니다. 마찬가지로 입력 방법이 UI에서 목록의 항목을 강조 표시해야하는 경우 &lt;a href=&quot;qml-qtquick-virtualkeyboard-inputmethod#selectionListActiveItemChanged-signal&quot;&gt;InputMethod :: selectionListActiveItemChanged&lt;/a&gt; 신호를 생성합니다.</target>
        </trans-unit>
        <trans-unit id="af13632c6936ddc6476f8bec001c16d3ccdb1b88" translate="yes" xml:space="preserve">
          <source>When the interaction is completed we strongly recommend releasing the user interaction semaphore with a call to &lt;a href=&quot;qsessionmanager#release&quot;&gt;release&lt;/a&gt;(). This way, other applications may get the chance to interact with the user while your application is still busy saving data. (The semaphore is implicitly released when the application exits.)</source>
          <target state="translated">상호 작용이 완료되면 &lt;a href=&quot;qsessionmanager#release&quot;&gt;릴리스&lt;/a&gt; ()를 호출하여 사용자 상호 작용 세마포어를 해제하는 것이 좋습니다 . 이런 식으로, 다른 응용 프로그램은 응용 프로그램이 여전히 데이터를 저장하는 동안 사용자와 상호 작용할 수 있습니다. (세마포는 응용 프로그램이 종료 될 때 암시 적으로 해제됩니다.)</target>
        </trans-unit>
        <trans-unit id="a08dbc79fd5ced7fe929c3d064e1b645b21d39b2" translate="yes" xml:space="preserve">
          <source>When the labels are editable the user will be able to change the range of the axis conveniently by editing any of the labels. This feature is only supported for the &lt;a href=&quot;qvalueaxis&quot;&gt;QValueAxis&lt;/a&gt; and the &lt;a href=&quot;qdatetimeaxis&quot;&gt;QDateTimeAxis&lt;/a&gt;.</source>
          <target state="translated">라벨을 편집 할 수 있으면 라벨을 편집하여 축의 범위를 편리하게 변경할 수 있습니다. 이 기능은 지원됩니다 &lt;a href=&quot;qvalueaxis&quot;&gt;QValueAxis&lt;/a&gt; 와 &lt;a href=&quot;qdatetimeaxis&quot;&gt;QDateTimeAxis&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="16aac338dd8507181525a913639f185cb93e3d46" translate="yes" xml:space="preserve">
          <source>When the layout direction is set on a widget, it will propagate to the widget's children, but not to a child that is a window and not to a child for which setLayoutDirection() has been explicitly called. Also, child widgets added</source>
          <target state="translated">레이아웃 방향이 위젯에 설정되면 위젯의 자식으로 전파되지만 setLayoutDirection ()이 명시 적으로 호출 된 자식이 아닌 창인 자식에는 전달되지 않습니다. 또한 하위 위젯이 추가되었습니다.</target>
        </trans-unit>
        <trans-unit id="757e208faf34bd91da1b625ef70871bbc740552e" translate="yes" xml:space="preserve">
          <source>When the layout's geometry changes, &lt;a href=&quot;graphicsview#qgraphicslayout&quot;&gt;QGraphicsLayout&lt;/a&gt; immediately rearranges all of its managed items by calling &lt;a href=&quot;qgraphicslayoutitem#setGeometry&quot;&gt;setGeometry&lt;/a&gt;() on each item. This rearrangement is called</source>
          <target state="translated">레이아웃의 지오메트리가 변경되면 &lt;a href=&quot;graphicsview#qgraphicslayout&quot;&gt;QGraphicsLayout&lt;/a&gt; 은 각 항목에서 &lt;a href=&quot;qgraphicslayoutitem#setGeometry&quot;&gt;setGeometry&lt;/a&gt; ()를 호출하여 모든 관리되는 항목을 즉시 재정렬합니다 . 이 재 배열을</target>
        </trans-unit>
        <trans-unit id="a4868cf3fc8227fd58f7cf326e3d937144f921d5" translate="yes" xml:space="preserve">
          <source>When the locale is not specified, the default system locale is used instead.</source>
          <target state="translated">로케일을 지정하지 않으면 기본 시스템 로케일이 대신 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="d8c8da609611d53dcc5b14869c74793f679093e3" translate="yes" xml:space="preserve">
          <source>When the machine is in state &lt;code&gt;s2&lt;/code&gt;, the machine will play the default animation for the property &lt;code&gt;fooBar&lt;/code&gt; since this property is assigned by &lt;code&gt;s2&lt;/code&gt;.</source>
          <target state="translated">머신이 &lt;code&gt;s2&lt;/code&gt; 상태 인 경우, 이 프로퍼티는 &lt;code&gt;s2&lt;/code&gt; 에 의해 지정되므로 머신은 &lt;code&gt;fooBar&lt;/code&gt; 프로퍼티에 대한 기본 애니메이션을 재생합니다 .</target>
        </trans-unit>
        <trans-unit id="e08c3bd224be28ab8da0d15a3e80244ae34b5521" translate="yes" xml:space="preserve">
          <source>When the map is displayed, each possible geographic coordinate that is visible will map to some pixel X and Y coordinate on the screen. To perform conversions between these two, Map provides the &lt;a href=&quot;qml-qtlocation-map#toCoordinate-method&quot;&gt;toCoordinate&lt;/a&gt; and &lt;a href=&quot;qml-qtlocation-map#fromCoordinate-method&quot;&gt;fromCoordinate&lt;/a&gt; functions, which are of general utility.</source>
          <target state="translated">지도가 표시되면 보이는 각 지리적 좌표가 화면의 일부 픽셀 X 및 Y 좌표에 매핑됩니다. 이 둘 사이의 변환을 수행하기 위해 Map은 일반적으로 유용한 &lt;a href=&quot;qml-qtlocation-map#toCoordinate-method&quot;&gt;toCoordinate&lt;/a&gt; 및 &lt;a href=&quot;qml-qtlocation-map#fromCoordinate-method&quot;&gt;fromCoordinate&lt;/a&gt; 기능을 제공 합니다.</target>
        </trans-unit>
        <trans-unit id="c5d7b44152d91a8b1270640c20696e9ece89a8be" translate="yes" xml:space="preserve">
          <source>When the mode changes, &lt;a href=&quot;qsslsocket&quot;&gt;QSslSocket&lt;/a&gt; emits &lt;a href=&quot;qsslsocket#modeChanged&quot;&gt;modeChanged&lt;/a&gt;()</source>
          <target state="translated">모드가 변경되면 &lt;a href=&quot;qsslsocket&quot;&gt;QSslSocket&lt;/a&gt; 은 &lt;a href=&quot;qsslsocket#modeChanged&quot;&gt;modeChanged&lt;/a&gt; ()를 생성합니다.</target>
        </trans-unit>
        <trans-unit id="f34a87a12fe283ceded3dd1abbd77031338a6cd0" translate="yes" xml:space="preserve">
          <source>When the model has multiple roles, &lt;code&gt;textRole&lt;/code&gt; can be set to determine which role should be displayed.</source>
          <target state="translated">모델에 여러 역할이있는 경우 &lt;code&gt;textRole&lt;/code&gt; 을 설정하여 표시 할 역할을 결정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="422c5c92ca52eb6e2a6538c002cc9123999cfea0" translate="yes" xml:space="preserve">
          <source>When the mouse is pressed, the &lt;a href=&quot;qml-qtquick-rectangle&quot;&gt;Rectangle&lt;/a&gt; changes to the</source>
          <target state="translated">마우스를 누르면 &lt;a href=&quot;qml-qtquick-rectangle&quot;&gt;사각형&lt;/a&gt; 이</target>
        </trans-unit>
        <trans-unit id="5657ede20e143f6d442db18b090e618d804d1de7" translate="yes" xml:space="preserve">
          <source>When the mouse moves over the item,</source>
          <target state="translated">마우스가 항목 위로 이동하면</target>
        </trans-unit>
        <trans-unit id="91af59e60e5984086456c7ad2a2054d514962b50" translate="yes" xml:space="preserve">
          <source>When the number of commands on a stack exceedes the stack's undoLimit, commands are deleted from the bottom of the stack. Macro commands (commands with child commands) are treated as one command. The default value is 0, which means that there is no limit.</source>
          <target state="translated">스택의 명령 수가 스택의 undoLimit를 초과하면 스택의 맨 아래에서 명령이 삭제됩니다. 매크로 명령 (자식 명령이있는 명령)은 하나의 명령으로 취급됩니다. 기본값은 0이며, 이는 제한이 없음을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="001d63f0ced7bf39910f29efe7f6f5fd05b477ff" translate="yes" xml:space="preserve">
          <source>When the number of matches cannot be determined in advance, a common idiom is to use &lt;a href=&quot;qregexp#cap&quot;&gt;cap&lt;/a&gt;() in a loop. For example:</source>
          <target state="translated">일치 횟수를 미리 결정할 수없는 경우 일반적인 관용구는 루프에서 &lt;a href=&quot;qregexp#cap&quot;&gt;cap&lt;/a&gt; () 을 사용 하는 것입니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="19d271264efc628bb86bca221e850d0c5cb77458" translate="yes" xml:space="preserve">
          <source>When the object supports multiple selections (e.g. in a word processor), this adds a new selection, otherwise it replaces the previous selection.</source>
          <target state="translated">객체가 다중 선택을 지원할 때 (예 : 워드 프로세서에서), 이것은 새로운 선택을 추가하고, 그렇지 않으면 이전 선택을 대체합니다.</target>
        </trans-unit>
        <trans-unit id="73cf6131f4a582c72bc9f9330edcb48af4fcc81f" translate="yes" xml:space="preserve">
          <source>When the page is inserted into a wizard using &lt;a href=&quot;qwizard#addPage&quot;&gt;QWizard::addPage&lt;/a&gt;() or &lt;a href=&quot;qwizard#setPage&quot;&gt;QWizard::setPage&lt;/a&gt;(), the parent is automatically set to be the wizard.</source>
          <target state="translated">&lt;a href=&quot;qwizard#addPage&quot;&gt;QWizard :: addPage&lt;/a&gt; () 또는 &lt;a href=&quot;qwizard#setPage&quot;&gt;QWizard :: setPage&lt;/a&gt; ()를 사용하여 페이지를 마법사에 삽입 하면 상위가 자동으로 마법사로 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="35fc6c728ad882d547072f431eb37b1425e9f468" translate="yes" xml:space="preserve">
          <source>When the paint event occurs, the update region has normally been erased, so you are painting on the widget's background.</source>
          <target state="translated">페인트 이벤트가 발생하면 일반적으로 업데이트 영역이 지워 지므로 위젯 배경에 페인팅됩니다.</target>
        </trans-unit>
        <trans-unit id="f30c7c3f40f1a872547881cd7951c22cee36c1cd" translate="yes" xml:space="preserve">
          <source>When the parameter is set to &lt;a href=&quot;qopengltexture#DepthStencilMode-enum&quot;&gt;DepthMode&lt;/a&gt;, then accessing it from the shader will access the depth component as a single float, as normal. But when the parameter is set to &lt;a href=&quot;qopengltexture#DepthStencilMode-enum&quot;&gt;StencilMode&lt;/a&gt;, the shader will access the stencil component.</source>
          <target state="translated">매개 변수가 &lt;a href=&quot;qopengltexture#DepthStencilMode-enum&quot;&gt;DepthMode&lt;/a&gt; 로 설정 되면 셰이더에서 매개 변수에 액세스하면 평소 와 같이 깊이 구성 요소에 단일 부동 소수점으로 액세스합니다. 그러나 매개 변수가 &lt;a href=&quot;qopengltexture#DepthStencilMode-enum&quot;&gt;StencilMode&lt;/a&gt; 로 설정 되면 셰이더는 스텐실 구성 요소에 액세스합니다.</target>
        </trans-unit>
        <trans-unit id="2375fc19af6a76757eb823a66fb6127ba87e61c2" translate="yes" xml:space="preserve">
          <source>When the parser encounters an error, it signals the event by making &lt;a href=&quot;qurl#isValid&quot;&gt;isValid&lt;/a&gt;() return false and &lt;a href=&quot;qurl#toString&quot;&gt;toString&lt;/a&gt;() / &lt;a href=&quot;qurl#toEncoded&quot;&gt;toEncoded&lt;/a&gt;() return an empty string. If it is necessary to show the user the reason why the URL failed to parse, the error condition can be obtained from &lt;a href=&quot;qurl&quot;&gt;QUrl&lt;/a&gt; by calling &lt;a href=&quot;qurl#errorString&quot;&gt;errorString&lt;/a&gt;(). Note that this message is highly technical and may not make sense to end-users.</source>
          <target state="translated">파서에 오류가 발생하면 &lt;a href=&quot;qurl#isValid&quot;&gt;isValid&lt;/a&gt; ()가 false를 반환하고 &lt;a href=&quot;qurl#toString&quot;&gt;toString&lt;/a&gt; () / &lt;a href=&quot;qurl#toEncoded&quot;&gt;toEncoded&lt;/a&gt; ()가 빈 문자열을 반환하도록 하여 이벤트를 알립니다 . URL 구문 분석에 실패한 이유를 사용자에게 표시 &lt;a href=&quot;qurl&quot;&gt;해야하는 경우 &lt;/a&gt;&lt;a href=&quot;qurl#errorString&quot;&gt;errorString&lt;/a&gt; () 을 호출 하여 QUrl 에서 오류 조건을 얻을 수 있습니다 . 이 메시지는 매우 기술적이며 최종 사용자에게는 의미가 없을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="50ba901eeb2daca251dbecc6e227457e431d3835" translate="yes" xml:space="preserve">
          <source>When the player object is buffering; this property holds the percentage of the temporary buffer that is filled. The buffer will need to reach 100% filled before playback can start or resume, at which time &lt;a href=&quot;qmediaplayer#mediaStatus-prop&quot;&gt;mediaStatus&lt;/a&gt;() will return &lt;a href=&quot;qmediaplayer#MediaStatus-enum&quot;&gt;BufferedMedia&lt;/a&gt; or &lt;a href=&quot;qmediaplayer#MediaStatus-enum&quot;&gt;BufferingMedia&lt;/a&gt;. If the value is anything lower than &lt;code&gt;100&lt;/code&gt;, &lt;a href=&quot;qmediaplayer#mediaStatus-prop&quot;&gt;mediaStatus&lt;/a&gt;() will return &lt;a href=&quot;qmediaplayer#MediaStatus-enum&quot;&gt;StalledMedia&lt;/a&gt;.</source>
          <target state="translated">플레이어 객체가 버퍼링 될 때; 이 특성은 채워진 임시 버퍼의 백분율을 보유합니다. 재생을 시작하거나 다시 시작하기 전에 버퍼가 100 % 채워져 있어야하며, 이때 &lt;a href=&quot;qmediaplayer#mediaStatus-prop&quot;&gt;mediaStatus&lt;/a&gt; ()는 &lt;a href=&quot;qmediaplayer#MediaStatus-enum&quot;&gt;BufferedMedia&lt;/a&gt; 또는 &lt;a href=&quot;qmediaplayer#MediaStatus-enum&quot;&gt;BufferingMedia를&lt;/a&gt; 반환 합니다. 값이 무엇보다 낮은 경우 &lt;code&gt;100&lt;/code&gt; , &lt;a href=&quot;qmediaplayer#mediaStatus-prop&quot;&gt;mediaStatus는&lt;/a&gt; () 반환합니다 &lt;a href=&quot;qmediaplayer#MediaStatus-enum&quot;&gt;StalledMedia을&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="da64dfb7cefdbeef317abcd7e43d7b305a5ee3ab" translate="yes" xml:space="preserve">
          <source>When the popup actually receives focus, &lt;a href=&quot;qml-qtquick-controls2-popup#activeFocus-prop&quot;&gt;activeFocus&lt;/a&gt; will be &lt;code&gt;true&lt;/code&gt;. For more information, see &lt;a href=&quot;qtquick-input-focus&quot;&gt;Keyboard Focus in Qt Quick&lt;/a&gt;.</source>
          <target state="translated">팝업이 실제로 포커스를 받으면 &lt;a href=&quot;qml-qtquick-controls2-popup#activeFocus-prop&quot;&gt;activeFocus&lt;/a&gt; 가 &lt;code&gt;true&lt;/code&gt; 입니다. 자세한 내용 &lt;a href=&quot;qtquick-input-focus&quot;&gt;은 Qt Quick의 키보드 포커스를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="d6f2faeb8b71e0aaa953aece87da658ef327fd51" translate="yes" xml:space="preserve">
          <source>When the popup actually receives focus, activeFocus will be &lt;code&gt;true&lt;/code&gt;. For more information, see &lt;a href=&quot;qtquick-input-focus&quot;&gt;Keyboard Focus in Qt Quick&lt;/a&gt;.</source>
          <target state="translated">팝업이 실제로 포커스를 받으면 activeFocus가 &lt;code&gt;true&lt;/code&gt; 입니다. 자세한 내용 &lt;a href=&quot;qtquick-input-focus&quot;&gt;은 Qt Quick의 키보드 포커스를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="c1bac0637a72484b23805b1cfc6b209249217f5b" translate="yes" xml:space="preserve">
          <source>When the process exits, &lt;a href=&quot;qprocess&quot;&gt;QProcess&lt;/a&gt; reenters the &lt;a href=&quot;qprocess#ProcessState-enum&quot;&gt;NotRunning&lt;/a&gt; state (the initial state), and emits &lt;a href=&quot;qprocess#finished&quot;&gt;finished&lt;/a&gt;().</source>
          <target state="translated">프로세스가 종료되면 &lt;a href=&quot;qprocess&quot;&gt;QProcess&lt;/a&gt; 는 &lt;a href=&quot;qprocess#ProcessState-enum&quot;&gt;NotRunning&lt;/a&gt; 상태 (초기 상태)로 다시 들어가 &lt;a href=&quot;qprocess#finished&quot;&gt;종료&lt;/a&gt; () 상태가됩니다.</target>
        </trans-unit>
        <trans-unit id="48359f3ebe88aa74d829db24de3e755c6a235ddd" translate="yes" xml:space="preserve">
          <source>When the property is &lt;a href=&quot;qt#CursorMoveStyle-enum&quot;&gt;Qt::LogicalMoveStyle&lt;/a&gt; (the default), within a LTR text block, increase cursor position when pressing left arrow key, decrease cursor position when pressing the right arrow key. If the text block is right to left, the opposite behavior applies.</source>
          <target state="translated">속성이 &lt;a href=&quot;qt#CursorMoveStyle-enum&quot;&gt;Qt :: LogicalMoveStyle&lt;/a&gt; (기본값) 인 경우 LTR 텍스트 블록 내에서 왼쪽 화살표 키를 누르면 커서 위치가 증가하고 오른쪽 화살표 키를 누르면 커서 위치가 감소합니다. 텍스트 블록이 오른쪽에서 왼쪽이면 반대 동작이 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="8bce9d7a133b3737e2c5d22d038d7b3c4e7911f8" translate="yes" xml:space="preserve">
          <source>When the property is set to &lt;a href=&quot;qcalendarwidget#SelectionMode-enum&quot;&gt;NoSelection&lt;/a&gt;, the user will be unable to select dates, but they can still be selected programmatically. Note that the date that is selected when the property is set to &lt;a href=&quot;qcalendarwidget#SelectionMode-enum&quot;&gt;NoSelection&lt;/a&gt; will still be the selected date of the calendar.</source>
          <target state="translated">속성이 &lt;a href=&quot;qcalendarwidget#SelectionMode-enum&quot;&gt;NoSelection&lt;/a&gt; 으로 설정 되면 사용자는 날짜를 선택할 수 없지만 프로그래밍 방식으로 선택할 수는 있습니다. 속성이 &lt;a href=&quot;qcalendarwidget#SelectionMode-enum&quot;&gt;NoSelection&lt;/a&gt; 으로 설정 될 때 선택된 날짜는 여전히 달력의 선택된 날짜입니다.</target>
        </trans-unit>
        <trans-unit id="1fdcbc355a573b53369d224635c5476baea07222" translate="yes" xml:space="preserve">
          <source>When the property is set to false, these controls are hidden.</source>
          <target state="translated">속성이 false로 설정되면 이러한 컨트롤이 숨겨집니다.</target>
        </trans-unit>
        <trans-unit id="aa8094b9e2a50ed05d31d86aa20fac7cfb61c508" translate="yes" xml:space="preserve">
          <source>When the renderer reaches a leaf node of the framegraph, it collects together all of the state specified by the path from the leaf node to the root node. This defines the state used to render a section of the frame. If you are interested in the internals of Qt 3D, this collection of state is called a</source>
          <target state="translated">렌더러는 프레임 그래프의 리프 노드에 도달하면 리프 노드에서 루트 노드까지의 경로로 지정된 모든 상태를 수집합니다. 프레임의 섹션을 렌더링하는 데 사용되는 상태를 정의합니다. Qt 3D의 내부에 관심이 있다면이 상태 모음을</target>
        </trans-unit>
        <trans-unit id="db214d0296a6a87ece4578bc42783f851f457093" translate="yes" xml:space="preserve">
          <source>When the request is processed and a reply is available, it should be sent using the &lt;code&gt;QDBusMessage&lt;/code&gt; object that was obtained. In our example, the reply code could be something as follows:</source>
          <target state="translated">요청이 처리되고 응답이 사용 가능하면, 획득 한 &lt;code&gt;QDBusMessage&lt;/code&gt; 오브젝트를 사용하여 요청을 보내야 합니다. 이 예에서 응답 코드는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="351834125e0c92d0f208676bc4e74950d662675c" translate="yes" xml:space="preserve">
          <source>When the results of an XQuery are returned in a sequence of &lt;a href=&quot;qxmlresultitems&quot;&gt;result items&lt;/a&gt;, atomic values in the sequence are treated as instances of &lt;a href=&quot;qvariant&quot;&gt;QVariant&lt;/a&gt;. Suppose that instead of serializing the results of the XQuery as XML, we process the results programatically. Modify the standard Qt XML Patterns code sequence to call the overload of &lt;a href=&quot;qxmlquery#evaluateTo&quot;&gt;QXmlQuery::evaluateTo&lt;/a&gt;() that populates a sequence of &lt;a href=&quot;qxmlresultitems&quot;&gt;result items&lt;/a&gt; with the XQuery results:</source>
          <target state="translated">XQuery의 &lt;a href=&quot;qxmlresultitems&quot;&gt;결과&lt;/a&gt; 가 일련의 결과 항목 으로 리턴되면 순서의 원자 값이 &lt;a href=&quot;qvariant&quot;&gt;QVariant의&lt;/a&gt; 인스턴스로 처리됩니다 . XQuery의 결과를 XML로 직렬화하는 대신 결과를 프로그래밍 방식으로 처리한다고 가정하십시오. 일련의 &lt;a href=&quot;qxmlresultitems&quot;&gt;결과 항목&lt;/a&gt; 을 XQuery 결과로 채우는 &lt;a href=&quot;qxmlquery#evaluateTo&quot;&gt;QXmlQuery :: evaluateTo&lt;/a&gt; () 의 오버로드를 호출하도록 표준 Qt XML 패턴 코드 시퀀스를 수정하십시오 .</target>
        </trans-unit>
        <trans-unit id="763552f30b01b66449cf8883bed75293d360c6fc" translate="yes" xml:space="preserve">
          <source>When the return value is &lt;code&gt;false&lt;/code&gt;, vertex array object support is not available. This is not an error: on systems with OpenGL 2.x or OpenGL ES 2.0 vertex array objects may not be supported. The application is free to continue execution in this case, but it then has to be prepared to operate in a VAO-less manner too. This means that instead of merely calling &lt;a href=&quot;qopenglvertexarrayobject#bind&quot;&gt;bind&lt;/a&gt;(), the value of &lt;a href=&quot;qopenglvertexarrayobject#isCreated&quot;&gt;isCreated&lt;/a&gt;() must be checked and the vertex arrays has to be initialized in the traditional way when there is no vertex array object present.</source>
          <target state="translated">반환 값이 &lt;code&gt;false&lt;/code&gt; 인 경우 정점 배열 객체 지원을 사용할 수 없습니다. 이것은 오류가 아닙니다. OpenGL 2.x 또는 OpenGL ES 2.0 정점 배열 객체가있는 시스템에서는 지원되지 않을 수 있습니다. 이 경우 응용 프로그램을 계속 실행할 수 있지만 VAO없는 방식으로 작동 할 수 있도록 준비해야합니다. 즉 , &lt;a href=&quot;qopenglvertexarrayobject#bind&quot;&gt;bind&lt;/a&gt; ()를 호출하는 대신 &lt;a href=&quot;qopenglvertexarrayobject#isCreated&quot;&gt;isCreated&lt;/a&gt; () 의 값을 확인하고 정점 배열 객체가 없을 때 정점 배열을 전통적인 방식으로 초기화해야합니다.</target>
        </trans-unit>
        <trans-unit id="446681578342ec9dac4cdce0d061b46969bca33b" translate="yes" xml:space="preserve">
          <source>When the run type is set to Manual, calling trigger will make the compute command be executed for the next</source>
          <target state="translated">실행 유형이 수동으로 설정되면 트리거를 호출하면 다음에 계산 명령이 실행됩니다.</target>
        </trans-unit>
        <trans-unit id="cbc6fc235d0cf1450284a0b09b674e76a1fb4c28" translate="yes" xml:space="preserve">
          <source>When the sample count is greater than 1, &lt;a href=&quot;qvulkanwindow&quot;&gt;QVulkanWindow&lt;/a&gt; will create a multisample color buffer instead of simply targeting the swapchain's images. The rendering in the multisample buffer will get resolved into the non-multisample buffers at the end of each frame.</source>
          <target state="translated">샘플 카운트가 1보다 크면 &lt;a href=&quot;qvulkanwindow&quot;&gt;QVulkanWindow&lt;/a&gt; 는 단순히 스왑 체인 이미지를 대상으로하는 대신 멀티 샘플 컬러 버퍼를 생성합니다. 멀티 샘플 버퍼의 렌더링은 각 프레임의 끝에서 비 멀티 샘플 버퍼로 해석됩니다.</target>
        </trans-unit>
        <trans-unit id="a0108434fca29b4ba915f772a93d81ad894fc73c" translate="yes" xml:space="preserve">
          <source>When the scene graph processes the request, it will call &lt;a href=&quot;qquickitem#updatePolish&quot;&gt;updatePolish&lt;/a&gt;() on this item.</source>
          <target state="translated">장면 그래프가 요청을 처리 할 때이 항목에 대해 &lt;a href=&quot;qquickitem#updatePolish&quot;&gt;updatePolish&lt;/a&gt; ()를 호출 합니다.</target>
        </trans-unit>
        <trans-unit id="79ad0782b661b14989a03456b369b188f17379b0" translate="yes" xml:space="preserve">
          <source>When the scene is active, this functions returns the scene's current focus item, or &lt;code&gt;nullptr&lt;/code&gt; if no item currently has focus. When the scene is inactive, this functions returns the item that will gain input focus when the scene becomes active.</source>
          <target state="translated">장면이 활성화되면이 함수는 장면의 현재 초점 항목을 반환하거나 현재 초점이있는 항목 이 없으면 &lt;code&gt;nullptr&lt;/code&gt; 을 반환합니다 . 장면이 비활성화되면이 기능은 장면이 활성화 될 때 입력 초점을 얻는 항목을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="9df9de9d839910e5f63e81af88c3113617106dce" translate="yes" xml:space="preserve">
          <source>When the scene is rendered, any item whose width or height, transformed to the target view, is smaller that minimumRenderSize(), will not be rendered. If an item is not rendered and it clips its children items they will also not be rendered. Set this value to speed up rendering of scenes with many objects rendered on a zoomed out view.</source>
          <target state="translated">장면을 렌더링 할 때 대상 뷰로 변환 된 너비 또는 높이가 minimumRenderSize ()보다 작은 항목은 렌더링되지 않습니다. 항목이 렌더링되지 않고 하위 항목을 자르면 렌더링되지 않습니다. 축소 된 뷰에서 렌더링되는 많은 객체가있는 장면의 렌더링 속도를 높이려면이 값을 설정하십시오.</target>
        </trans-unit>
        <trans-unit id="0a43ef95854a2f8ebe7bf8d74d52b1e7933022c7" translate="yes" xml:space="preserve">
          <source>When the script has been executed,</source>
          <target state="translated">스크립트가 실행되면</target>
        </trans-unit>
        <trans-unit id="d413663e989f70315f8c202cae18ed2f762ace07" translate="yes" xml:space="preserve">
          <source>When the scroll bars change value, we need to update the widget position, i.e., find the part of the widget that is to be drawn in the viewport:</source>
          <target state="translated">스크롤 바의 값이 변경되면 위젯 위치를 업데이트해야합니다. 즉, 뷰포트에서 그릴 위젯 부분을 찾습니다.</target>
        </trans-unit>
        <trans-unit id="7e550de4fcd183b4278cd6cc624e2d0424a701cc" translate="yes" xml:space="preserve">
          <source>When the selected test users that you have added to your alpha or beta program purchase in-app products in your application, they will make actual purchases and will be charged for them. For testing purchases, you can register the e-mail addresses that should have testing access, under &lt;b&gt;Settings&lt;/b&gt; in the developer console. The users with these e-mail addresses can purchase your in-app products without being charged for the purchase, and the transaction is canceled automatically at a later stage.</source>
          <target state="translated">알파 또는 베타 프로그램에 추가 한 선택한 테스트 사용자가 응용 프로그램에서 인앱 제품을 구매하면 실제 구매가 이루어지고 비용이 청구됩니다. 구매 테스트의 경우 개발자 콘솔의 &lt;b&gt;설정&lt;/b&gt; 에서 테스트 액세스 권한이 있어야하는 이메일 주소를 등록 할 수 있습니다 . 이러한 전자 메일 주소를 가진 사용자는 구매 비용이 청구되지 않고 인앱 제품을 구매할 수 있으며 나중에 거래가 자동으로 취소됩니다.</target>
        </trans-unit>
        <trans-unit id="afec543fcd1da24c4160336959d91fe3f583bac8" translate="yes" xml:space="preserve">
          <source>When the selection changes and the dialog is accepted, this signal is emitted with the (possibly empty) list of selected</source>
          <target state="translated">선택이 변경되고 대화 상자가 승인되면이 신호는 선택된 (비어 있음) 목록과 함께 방출됩니다.</target>
        </trans-unit>
        <trans-unit id="904758544b0861950c3ab2beb21af5f0d9b36272" translate="yes" xml:space="preserve">
          <source>When the selection changes and the dialog is accepted, this signal is emitted with the (possibly empty) selected</source>
          <target state="translated">선택이 변경되고 대화 상자가 승인되면이 신호는 (비어있을 수 있음)이 선택된 상태로 방출됩니다.</target>
        </trans-unit>
        <trans-unit id="e7de7d16009452344b6e4636a059a260b420895c" translate="yes" xml:space="preserve">
          <source>When the selection changes for local operations and the dialog is accepted, this signal is emitted with the (possibly empty) list of</source>
          <target state="translated">로컬 작업에 대한 선택이 변경되고 대화 상자가 승인되면이 신호는 (비어있을 수 있음) 목록으로 방출됩니다.</target>
        </trans-unit>
        <trans-unit id="f75edcab2adacd739be3bdebfa6bfa280edf2de0" translate="yes" xml:space="preserve">
          <source>When the selection changes for local operations and the dialog is accepted, this signal is emitted with the (possibly empty) selected</source>
          <target state="translated">로컬 작업에 대한 선택이 변경되고 대화 상자가 승인되면이 신호는 (비어있을 수 있음)이 선택된 상태로 방출됩니다.</target>
        </trans-unit>
        <trans-unit id="5131d672b1bc3aac6ebdcf6c8b2ac57826b0e767" translate="yes" xml:space="preserve">
          <source>When the selection mode changes and the selected item is visible</source>
          <target state="translated">선택 모드가 변경되고 선택한 항목이 보이는 경우</target>
        </trans-unit>
        <trans-unit id="31520c42359fb2cf1348100dd78b79ebb3e7ffdd" translate="yes" xml:space="preserve">
          <source>When the sensor is started with buffering option, values are collected from that moment onwards. There is no pre-existing buffer that can be utilized.</source>
          <target state="translated">버퍼링 옵션으로 센서를 시작하면 그 순간부터 값이 수집됩니다. 사용할 수있는 기존 버퍼가 없습니다.</target>
        </trans-unit>
        <trans-unit id="ce0fb53c6b17959f1dc8d1d19b6e99cbdbd76451" translate="yes" xml:space="preserve">
          <source>When the server receives the ClientHello message with a cookie, it generates a new cookie as described above. This new cookie is compared to the one found in the ClientHello message.</source>
          <target state="translated">서버는 쿠키와 함께 ClientHello 메시지를 받으면 위에서 설명한대로 새 쿠키를 생성합니다. 이 새로운 쿠키는 ClientHello 메시지에있는 쿠키와 비교됩니다.</target>
        </trans-unit>
        <trans-unit id="f10b8edd85c55e75835eb4536f6583dfa1033451" translate="yes" xml:space="preserve">
          <source>When the service that this method call is sent to is already running, the method call is sent to it. If the service is not running yet, the D-Bus daemon is requested to autostart the service that is assigned to this service name. This is handled by .service files that are placed in a directory known to the D-Bus server. These files then each contain a service name and the path to a program that should be executed when this service name is requested.</source>
          <target state="translated">이 메소드 호출이 전송 된 서비스가 이미 실행 중이면 메소드 호출이 전송됩니다. 서비스가 아직 실행되고 있지 않으면이 서비스 이름에 할당 된 서비스를 자동 시작하도록 D-Bus 데몬이 요청됩니다. 이것은 D-Bus 서버에 알려진 디렉토리에있는 .service 파일에 의해 처리됩니다. 이 파일들은 각각 서비스 이름과이 서비스 이름이 요청 될 때 실행되어야하는 프로그램 경로를 포함합니다.</target>
        </trans-unit>
        <trans-unit id="c0cd1279176cf81f0c6aca038bccf60c5d81a29f" translate="yes" xml:space="preserve">
          <source>When the shader program is used normally, the shader program's id will be created on demand.</source>
          <target state="translated">셰이더 프로그램이 정상적으로 사용될 때 셰이더 프로그램의 ID는 요청시 생성됩니다.</target>
        </trans-unit>
        <trans-unit id="a62f09dbef147b4bf1f669c8ce754ebe864f003f" translate="yes" xml:space="preserve">
          <source>When the signal associated with this signal transition is emitted the guard condition is evaluated. In the guard condition the arguments of the signal can be used as demonstrated in the example below.</source>
          <target state="translated">이 신호 전이와 관련된 신호가 방출되면 보호 조건이 평가됩니다. 보호 조건에서 신호의 인수는 아래 예에서 설명 된대로 사용될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="558725310a73c041dc3d4a5f9bb58e65f3b99606" translate="yes" xml:space="preserve">
          <source>When the signal is emitted, the &lt;a href=&quot;qabstractslider#sliderPosition-prop&quot;&gt;sliderPosition&lt;/a&gt; has been adjusted according to the action, but the &lt;a href=&quot;qabstractslider#value-prop&quot;&gt;value&lt;/a&gt; has not yet been propagated (meaning the &lt;a href=&quot;qabstractslider#valueChanged&quot;&gt;valueChanged&lt;/a&gt;() signal was not yet emitted), and the visual display has not been updated. In slots connected to this signal you can thus safely adjust any action by calling &lt;a href=&quot;qabstractslider#sliderPosition-prop&quot;&gt;setSliderPosition&lt;/a&gt;() yourself, based on both the action and the slider's value.</source>
          <target state="translated">신호가 방출 될 때 &lt;a href=&quot;qabstractslider#sliderPosition-prop&quot;&gt;슬라이더 위치&lt;/a&gt; 가 조치에 따라 조정되었지만 &lt;a href=&quot;qabstractslider#value-prop&quot;&gt;값&lt;/a&gt; 이 아직 전파되지 않았으며 ( &lt;a href=&quot;qabstractslider#valueChanged&quot;&gt;valueChanged&lt;/a&gt; () 신호가 아직 방출되지 않았 음을 의미 함 ) 시각적 표시가 업데이트되지 않았습니다. 이 신호에 연결된 슬롯 에서 액션과 슬라이더의 값에 따라 &lt;a href=&quot;qabstractslider#sliderPosition-prop&quot;&gt;setSliderPosition&lt;/a&gt; ()을 직접 호출하여 액션을 안전하게 조정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="908f9032f0a18c7bfa32894d77bc808328603452" translate="yes" xml:space="preserve">
          <source>When the source and target areas' sizes do not match, the source contents are stretched to fit into the target area. By passing a &lt;a href=&quot;qt#AspectRatioMode-enum&quot;&gt;Qt::AspectRatioMode&lt;/a&gt; to the rendering function you are using, you can choose to maintain or ignore the aspect ratio of the scene when the contents are stretched.</source>
          <target state="translated">소스와 대상 영역의 크기가 일치하지 않으면 소스 내용이 대상 영역에 맞게 늘어납니다. &lt;a href=&quot;qt#AspectRatioMode-enum&quot;&gt;Qt :: AspectRatioMode&lt;/a&gt; 를 사용중인 렌더링 기능에 전달 하면 내용이 늘어날 때 장면의 종횡비를 유지하거나 무시하도록 선택할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8b00e9d3dd0cfb3eafd24644444bab1097364474" translate="yes" xml:space="preserve">
          <source>When the source is static, the &lt;a href=&quot;qml-qtgraphicaleffects-dropshadow#cached-prop&quot;&gt;cached&lt;/a&gt; property can be set to allocate another buffer to avoid performing the blur every time it is drawn.</source>
          <target state="translated">소스가 정적 일 때 &lt;a href=&quot;qml-qtgraphicaleffects-dropshadow#cached-prop&quot;&gt;캐시 된&lt;/a&gt; 속성은 그릴 때마다 블러를 수행하지 않도록 다른 버퍼를 할당하도록 설정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3ad8f5ada47559d8d884af8a03a452189fd6075c" translate="yes" xml:space="preserve">
          <source>When the space key is pressed, adding an item to the model, the new item will fade in and increase in scale over 400 milliseconds as it is added to the view. Also, any item that is displaced by the addition of a new item will animate to its new position in the view over 400 milliseconds, as specified by the &lt;code&gt;displaced&lt;/code&gt; transition.</source>
          <target state="translated">스페이스 키를 누르면 모델에 항목을 추가하면 새 항목이 사라지고 뷰에 추가 될 때 400 밀리 초 이상으로 스케일이 증가합니다. 또한, 새로운 아이템의 추가에 의해 변위 된 아이템은 &lt;code&gt;displaced&lt;/code&gt; 전이에 의해 지정된 바와 같이 400 밀리 초 이상 뷰에서 새로운 위치로 애니메이션 될 것이다 .</target>
        </trans-unit>
        <trans-unit id="a9fca68b12abe757685e2f8e3f26bf8a64e1d4fe" translate="yes" xml:space="preserve">
          <source>When the space key is pressed, three items are moved from index 5 to index 1. For each moved item, the &lt;code&gt;moveTransition&lt;/code&gt; sequence presumably animates the item's color to &quot;yellow&quot;, then animates it to its final position, then changes the item color back to &quot;lightsteelblue&quot; using a &lt;a href=&quot;qml-qtquick-scriptaction&quot;&gt;ScriptAction&lt;/a&gt;. However, when run, the transition does not produce the intended result:</source>
          <target state="translated">스페이스 키를 누르면 3 개의 항목이 인덱스 5에서 인덱스 1로 이동합니다. 각각의 이동 된 항목에 대해 &lt;code&gt;moveTransition&lt;/code&gt; 시퀀스는 항목의 색상을 &quot;노란색&quot;으로 애니메이션 한 다음 최종 위치로 애니메이션 한 다음 항목 색상을 다시 변경합니다. &quot;lightsteelblue&quot;는 사용하는 &lt;a href=&quot;qml-qtquick-scriptaction&quot;&gt;ScriptAction을&lt;/a&gt; . 그러나 실행시 전이로 인해 의도 한 결과가 생성되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="aed377e3125e7efb3e464b02103995ebd5fa07a4" translate="yes" xml:space="preserve">
          <source>When the string is not already a valid URL, a best guess is performed, making various web related assumptions.</source>
          <target state="translated">문자열이 유효한 URL이 아닌 경우 다양한 웹 관련 가정을 수행하여 최선의 추측이 수행됩니다.</target>
        </trans-unit>
        <trans-unit id="8b456c366b0bedadf7f4c24ff98787915a0f574f" translate="yes" xml:space="preserve">
          <source>When the text changes the &lt;a href=&quot;qlineedit#textChanged&quot;&gt;textChanged&lt;/a&gt;() signal is emitted; when the text changes other than by calling &lt;a href=&quot;qlineedit#text-prop&quot;&gt;setText&lt;/a&gt;() the &lt;a href=&quot;qlineedit#textEdited&quot;&gt;textEdited&lt;/a&gt;() signal is emitted; when the cursor is moved the &lt;a href=&quot;qlineedit#cursorPositionChanged&quot;&gt;cursorPositionChanged&lt;/a&gt;() signal is emitted; and when the Return or Enter key is pressed the &lt;a href=&quot;qlineedit#returnPressed&quot;&gt;returnPressed&lt;/a&gt;() signal is emitted.</source>
          <target state="translated">텍스트가 변경되면 &lt;a href=&quot;qlineedit#textChanged&quot;&gt;textChanged&lt;/a&gt; () 신호가 방출됩니다. &lt;a href=&quot;qlineedit#text-prop&quot;&gt;setText&lt;/a&gt; () 를 호출하는 것 외에 텍스트가 변경 되면 &lt;a href=&quot;qlineedit#textEdited&quot;&gt;textEdited&lt;/a&gt; () 신호가 방출됩니다. 커서를 움직이면 &lt;a href=&quot;qlineedit#cursorPositionChanged&quot;&gt;cursorPositionChanged&lt;/a&gt; () 신호가 방출됩니다. Return 또는 Enter 키를 누르면 &lt;a href=&quot;qlineedit#returnPressed&quot;&gt;returnPressed&lt;/a&gt; () 신호가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="76aa286a7763afdcffbd10ec6e5b9d39bd8e0eec" translate="yes" xml:space="preserve">
          <source>When the texture coordinate is even, only the fractional part is used. When odd, the texture coordinate is set to &lt;code&gt;1 - fractional part&lt;/code&gt;. This value has been introduced in Qt 5.10.</source>
          <target state="translated">텍스처 좌표가 짝수이면 소수 부분 만 사용됩니다. 홀수 인 경우 텍스처 좌표는 &lt;code&gt;1 - fractional part&lt;/code&gt; 설정됩니다 . 이 값은 Qt 5.10에서 도입되었습니다.</target>
        </trans-unit>
        <trans-unit id="4630c4b073fe0b95c546ea9b15793119393a3a9b" translate="yes" xml:space="preserve">
          <source>When the thread is terminated, all threads waiting for the thread to finish will be woken up.</source>
          <target state="translated">스레드가 종료되면 스레드가 완료되기를 기다리는 모든 스레드가 깨어납니다.</target>
        </trans-unit>
        <trans-unit id="d8b9c7726d3aff7845aa848c6697f0885c506e1a" translate="yes" xml:space="preserve">
          <source>When the title bar is vertical, the &lt;a href=&quot;#vertical-ps&quot;&gt;:vertical&lt;/a&gt; pseudo class is set. In addition, depending on &lt;a href=&quot;qdockwidget#DockWidgetFeature-enum&quot;&gt;QDockWidget::DockWidgetFeature&lt;/a&gt;, the &lt;a href=&quot;#closable-ps&quot;&gt;:closable&lt;/a&gt;, &lt;a href=&quot;#floatable-ps&quot;&gt;:floatable&lt;/a&gt; and &lt;a href=&quot;#movable-ps&quot;&gt;:movable&lt;/a&gt; pseudo states are set.</source>
          <target state="translated">제목 표시 줄이 수직이면 &lt;a href=&quot;#vertical-ps&quot;&gt;: 수직&lt;/a&gt; 의사 클래스가 설정됩니다. 또한 &lt;a href=&quot;qdockwidget#DockWidgetFeature-enum&quot;&gt;QDockWidget :: DockWidgetFeature&lt;/a&gt; 에 따라 &lt;a href=&quot;#closable-ps&quot;&gt;: closable&lt;/a&gt; , &lt;a href=&quot;#floatable-ps&quot;&gt;: floatable&lt;/a&gt; 및 &lt;a href=&quot;#movable-ps&quot;&gt;: movable&lt;/a&gt; 의사 상태가 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="cf6a38dec8a46a3efde082aa9bb646234ab5665d" translate="yes" xml:space="preserve">
          <source>When the traceEnd method is called, the input method may begin processing of the data contained in the trace object. After processing the data, the input method should destroy the object. This also removes the trace rendered to the screen.</source>
          <target state="translated">traceEnd 메소드가 호출되면 입력 메소드가 추적 오브젝트에 포함 된 데이터 처리를 시작할 수 있습니다. 데이터를 처리 한 후 입력 방법은 객체를 파괴해야합니다. 또한 화면에 렌더링 된 추적을 제거합니다.</target>
        </trans-unit>
        <trans-unit id="5ed406ff23fcc29a091f1169edcf6e63e1f2b5ea" translate="yes" xml:space="preserve">
          <source>When the transition is initialized, the &lt;a href=&quot;qml-qtquick-propertyaction&quot;&gt;PropertyAction&lt;/a&gt;&lt;code&gt;target&lt;/code&gt; will be set to the respective &lt;a href=&quot;qml-qtquick-viewtransition&quot;&gt;ViewTransition&lt;/a&gt;.item for the transition and will later run with the correct item target as expected.</source>
          <target state="translated">전환이 초기화되면 &lt;a href=&quot;qml-qtquick-propertyaction&quot;&gt;PropertyAction &lt;/a&gt; &lt;code&gt;target&lt;/code&gt; 이 전환에 대한 해당 &lt;a href=&quot;qml-qtquick-viewtransition&quot;&gt;ViewTransition&lt;/a&gt; .item 으로 설정되고 나중에 예상대로 올바른 항목 대상으로 실행됩니다.</target>
        </trans-unit>
        <trans-unit id="61999efc5174872ead16b86264178dba1fb54b01" translate="yes" xml:space="preserve">
          <source>When the transition starts, the &lt;a href=&quot;qml-qtquick-controls-stackview&quot;&gt;StackView&lt;/a&gt; will search for a transition that matches the operation executed. There are three transitions to choose from: &lt;a href=&quot;qml-qtquick-controls-stackviewdelegate#pushTransition-prop&quot;&gt;pushTransition&lt;/a&gt;, &lt;a href=&quot;qml-qtquick-controls-stackviewdelegate#popTransition-prop&quot;&gt;popTransition&lt;/a&gt;, and &lt;a href=&quot;qml-qtquick-controls-stackviewdelegate#replaceTransition-prop&quot;&gt;replaceTransition&lt;/a&gt;. Each implements how &lt;code&gt;enterItem&lt;/code&gt; should animate in, and &lt;code&gt;exitItem&lt;/code&gt; out. The transitions are collected inside a &lt;a href=&quot;qml-qtquick-controls-stackviewdelegate&quot;&gt;StackViewDelegate&lt;/a&gt; object assigned to &lt;a href=&quot;qml-qtquick-controls-stackview#delegate-prop&quot;&gt;delegate&lt;/a&gt;. By default, popTransition and replaceTransition will be the same as pushTransition, unless you set them to something else.</source>
          <target state="translated">전환이 시작되면 &lt;a href=&quot;qml-qtquick-controls-stackview&quot;&gt;StackView&lt;/a&gt; 는 실행 된 작업과 일치하는 전환을 검색합니다. &lt;a href=&quot;qml-qtquick-controls-stackviewdelegate#pushTransition-prop&quot;&gt;pushTransition&lt;/a&gt; , &lt;a href=&quot;qml-qtquick-controls-stackviewdelegate#popTransition-prop&quot;&gt;popTransition&lt;/a&gt; 및 &lt;a href=&quot;qml-qtquick-controls-stackviewdelegate#replaceTransition-prop&quot;&gt;replaceTransition의&lt;/a&gt; 세 가지 전환 중에서 선택할 수 있습니다 . 각각은 &lt;code&gt;enterItem&lt;/code&gt; 에 애니메이션을 적용하고 &lt;code&gt;exitItem&lt;/code&gt; 을 종료 하는 방법을 구현합니다 . 전환은 &lt;a href=&quot;qml-qtquick-controls-stackview#delegate-prop&quot;&gt;delegate에&lt;/a&gt; 할당 된 &lt;a href=&quot;qml-qtquick-controls-stackviewdelegate&quot;&gt;StackViewDelegate&lt;/a&gt; 객체 내에서 수집됩니다 . 기본적으로 popTransition 및 replaceTransition은 다른 것으로 설정하지 않는 한 pushTransition과 동일합니다.</target>
        </trans-unit>
        <trans-unit id="3151bd80e155cc711d1dfb4c28d12fa02d1b602b" translate="yes" xml:space="preserve">
          <source>When the update behavior is set to &lt;code&gt;NoPartialUpdate&lt;/code&gt;, there is no separate framebuffer object. In this case the returned value is the ID of the default framebuffer.</source>
          <target state="translated">업데이트 동작이 &lt;code&gt;NoPartialUpdate&lt;/code&gt; 로 설정되면 별도의 프레임 버퍼 객체가 없습니다. 이 경우 반환되는 값은 기본 프레임 버퍼의 ID입니다.</target>
        </trans-unit>
        <trans-unit id="38a70a3f9388a6d25db9221a160c7eb74efac68f" translate="yes" xml:space="preserve">
          <source>When the update mode is set to &lt;a href=&quot;qopenglwindow#UpdateBehavior-enum&quot;&gt;NoPartialUpdate&lt;/a&gt;, there is no difference between this function and &lt;a href=&quot;qopenglwindow#paintGL&quot;&gt;paintGL&lt;/a&gt;(), performing rendering in either of them leads to the same result.</source>
          <target state="translated">업데이트 모드가 &lt;a href=&quot;qopenglwindow#UpdateBehavior-enum&quot;&gt;NoPartialUpdate&lt;/a&gt; 로 설정되어 있으면 이 함수와 &lt;a href=&quot;qopenglwindow#paintGL&quot;&gt;paintGL&lt;/a&gt; () 사이에 차이가 없으며 둘 중 하나에서 렌더링을 수행하면 동일한 결과가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="90a4d8b7976d6357d0d51104a651d5693a247b6e" translate="yes" xml:space="preserve">
          <source>When the update mode is set to &lt;code&gt;NoPartialUpdate&lt;/code&gt;, there is no difference between this function and &lt;a href=&quot;qopenglwindow#paintGL&quot;&gt;paintGL&lt;/a&gt;(), performing rendering in either of them leads to the same result.</source>
          <target state="translated">업데이트 모드가 &lt;code&gt;NoPartialUpdate&lt;/code&gt; 로 설정되어 있으면 이 함수와 &lt;a href=&quot;qopenglwindow#paintGL&quot;&gt;paintGL&lt;/a&gt; () 사이에 차이가 없으며 둘 중 하나에서 렌더링을 수행하면 동일한 결과가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="7fbf049a32dd0640f6dd43ed769625f8cee33a4d" translate="yes" xml:space="preserve">
          <source>When the user attempts to close a window, the &lt;a href=&quot;qml-qtquick-window-window#closing-signal&quot;&gt;closing&lt;/a&gt; signal will be emitted. You can force the window to stay open (for example to prompt the user to save changes) by writing an &lt;code&gt;onClosing&lt;/code&gt; handler and setting &lt;code&gt;close.accepted = false&lt;/code&gt;.</source>
          <target state="translated">사용자가 창을 닫으려고하면 &lt;a href=&quot;qml-qtquick-window-window#closing-signal&quot;&gt;닫는&lt;/a&gt; 신호가 발생합니다. &lt;code&gt;onClosing&lt;/code&gt; 핸들러 를 작성하고 &lt;code&gt;close.accepted = false&lt;/code&gt; 설정 하여 창을 강제로 열 수 있습니다 (예 : 사용자에게 변경 사항을 저장하라는 프롬프트 표시) .</target>
        </trans-unit>
        <trans-unit id="f089242c4828bfa1c4990e6f2f452f8aa6f68fa8" translate="yes" xml:space="preserve">
          <source>When the user clicks anywhere within the rectangle, &lt;code&gt;sendMessage()&lt;/code&gt; is called, triggering the &lt;code&gt;WorkerScript.onMessage()&lt;/code&gt; handler in &lt;code&gt;script.mjs&lt;/code&gt;. This in turn sends a reply message that is then received by the &lt;code&gt;onMessage()&lt;/code&gt; handler of &lt;code&gt;myWorker&lt;/code&gt;.</source>
          <target state="translated">사용자가 사각형 내의 아무 곳이나 클릭하면 &lt;code&gt;sendMessage()&lt;/code&gt; 가 호출되어 &lt;code&gt;WorkerScript.onMessage()&lt;/code&gt; 에서 WorkerScript.onMessage () 핸들러가 &lt;code&gt;script.mjs&lt;/code&gt; 됩니다. 이것은 응답 메시지를 보낸 다음 &lt;code&gt;myWorker&lt;/code&gt; 의 &lt;code&gt;onMessage()&lt;/code&gt; 핸들러에 의해 수신됩니다 .</target>
        </trans-unit>
        <trans-unit id="9e806fe43114f8c1140dcea68026addc98aa8292" translate="yes" xml:space="preserve">
          <source>When the user enters a new string in an editable combobox, the widget may or may not insert it, and it can insert it in several locations. The default policy is &lt;a href=&quot;qcombobox#InsertPolicy-enum&quot;&gt;InsertAtBottom&lt;/a&gt; but you can change this using &lt;a href=&quot;qcombobox#insertPolicy-prop&quot;&gt;setInsertPolicy&lt;/a&gt;().</source>
          <target state="translated">사용자가 편집 가능한 콤보 박스에 새 문자열을 입력하면 위젯이 삽입하거나 삽입하지 않을 수 있으며 여러 위치에 삽입 할 수 있습니다. 기본 정책은 &lt;a href=&quot;qcombobox#InsertPolicy-enum&quot;&gt;InsertAtBottom&lt;/a&gt; 이지만 &lt;a href=&quot;qcombobox#insertPolicy-prop&quot;&gt;setInsertPolicy&lt;/a&gt; ()를 사용하여 이를 변경할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="7a33c93bf7f01a0e67730291d39734d96a1a1c84" translate="yes" xml:space="preserve">
          <source>When the user has finished editing the value in the spin box, the view asks the delegate to store the edited value in the model by calling the &lt;a href=&quot;qabstractitemdelegate#setModelData&quot;&gt;setModelData()&lt;/a&gt; function.</source>
          <target state="translated">사용자가 스핀 상자에서 값 편집을 마치면 뷰는 대리자에게 &lt;a href=&quot;qabstractitemdelegate#setModelData&quot;&gt;setModelData ()&lt;/a&gt; 함수를 호출하여 편집 된 값을 모델에 저장하도록 요청합니다 .</target>
        </trans-unit>
        <trans-unit id="92fa0779d8d3b6243f1940a69448d7de41b9ecd3" translate="yes" xml:space="preserve">
          <source>When the user presses or releases a key, the following occurs:</source>
          <target state="translated">사용자가 키를 누르거나 놓으면 다음이 발생합니다.</target>
        </trans-unit>
        <trans-unit id="0593af2ddbf4e80d0b0321de8e5024100fcd08c9" translate="yes" xml:space="preserve">
          <source>When the user presses the first key on a keyboard, an input context is created. This input context will contain a string of the typed characters.</source>
          <target state="translated">사용자가 키보드에서 첫 번째 키를 누르면 입력 컨텍스트가 작성됩니다. 이 입력 컨텍스트에는 유형이 지정된 문자열이 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="17b14a687e250bb8ebffd69d26cedf3fe0182667" translate="yes" xml:space="preserve">
          <source>When the user presses the shortcut key indicated by this label, the keyboard focus is transferred to the label's buddy widget.</source>
          <target state="translated">사용자가이 레이블로 표시된 바로 가기 키를 누르면 키보드 포커스가 레이블의 친구 위젯으로 전송됩니다.</target>
        </trans-unit>
        <trans-unit id="d8718161543f49d12ebfce2a24d45c7fc9cbd16e" translate="yes" xml:space="preserve">
          <source>When the user resizes the window, the size will move in steps of &lt;a href=&quot;qwindow#sizeIncrement&quot;&gt;sizeIncrement&lt;/a&gt;().&lt;a href=&quot;qwindow#width-prop&quot;&gt;width&lt;/a&gt;() pixels horizontally and &lt;a href=&quot;qwindow#sizeIncrement&quot;&gt;sizeIncrement&lt;/a&gt;().&lt;a href=&quot;qwindow#height-prop&quot;&gt;height&lt;/a&gt;() pixels vertically, with &lt;a href=&quot;qwindow#baseSize&quot;&gt;baseSize&lt;/a&gt;() as the basis.</source>
          <target state="translated">사용자가 창의 크기를 조정하면 크기가 &lt;a href=&quot;qwindow#sizeIncrement&quot;&gt;sizeIncrement&lt;/a&gt; () 단계로 이동합니다 . &lt;a href=&quot;qwindow#width-prop&quot;&gt;가로&lt;/a&gt; () 픽셀 및 &lt;a href=&quot;qwindow#sizeIncrement&quot;&gt;sizeIncrement&lt;/a&gt; (). &lt;a href=&quot;qwindow#baseSize&quot;&gt;baseSize&lt;/a&gt; ()를 기준으로 &lt;a href=&quot;qwindow#height-prop&quot;&gt;높이&lt;/a&gt; () 픽셀 (세로 )</target>
        </trans-unit>
        <trans-unit id="9e453a57cc507da9b2902f79db75133ddc061ac8" translate="yes" xml:space="preserve">
          <source>When the user resizes the window, the size will move in steps of sizeIncrement().&lt;a href=&quot;qwidget#width-prop&quot;&gt;width&lt;/a&gt;() pixels horizontally and sizeIncrement.&lt;a href=&quot;qwidget#height-prop&quot;&gt;height&lt;/a&gt;() pixels vertically, with &lt;a href=&quot;qwidget#baseSize-prop&quot;&gt;baseSize&lt;/a&gt;() as the basis. Preferred widget sizes are for non-negative integers</source>
          <target state="translated">사용자가 창의 크기를 조정하면 크기가 sizeIncrement () 단계로 이동합니다. &lt;a href=&quot;qwidget#width-prop&quot;&gt;가로&lt;/a&gt; () 픽셀 및 sizeIncrement. &lt;a href=&quot;qwidget#baseSize-prop&quot;&gt;baseSize&lt;/a&gt; ()를 기준으로 &lt;a href=&quot;qwidget#height-prop&quot;&gt;높이&lt;/a&gt; () 픽셀 (세로 ) 기본 위젯 크기는 음이 아닌 정수입니다.</target>
        </trans-unit>
        <trans-unit id="e9e23684b39294a601601a344c7bf87e80ee521d" translate="yes" xml:space="preserve">
          <source>When the user selects a new font, the &lt;a href=&quot;qfontcombobox#currentFontChanged&quot;&gt;currentFontChanged&lt;/a&gt;() signal is emitted in addition to &lt;a href=&quot;qcombobox#currentIndexChanged&quot;&gt;currentIndexChanged&lt;/a&gt;().</source>
          <target state="translated">사용자가 새 글꼴을 선택하면 &lt;a href=&quot;qcombobox#currentIndexChanged&quot;&gt;currentIndexChanged&lt;/a&gt; () 외에 &lt;a href=&quot;qfontcombobox#currentFontChanged&quot;&gt;currentFontChanged&lt;/a&gt; () 신호가 생성 됩니다.</target>
        </trans-unit>
        <trans-unit id="4da46bc51fcc82534c06603bbbd59ebe7d50ebb4" translate="yes" xml:space="preserve">
          <source>When the user selects an item in the list, the input method responds to the event in the &lt;a href=&quot;qml-qtquick-virtualkeyboard-inputmethod#selectionListItemSelected-method&quot;&gt;InputMethod::selectionListItemSelected&lt;/a&gt; method callback.</source>
          <target state="translated">사용자가 목록에서 항목을 선택하면 입력 메소드가 &lt;a href=&quot;qml-qtquick-virtualkeyboard-inputmethod#selectionListItemSelected-method&quot;&gt;InputMethod :: selectionListItemSelected&lt;/a&gt; 메소드 콜백 의 이벤트에 응답합니다 .</target>
        </trans-unit>
        <trans-unit id="c109346817c0c000e5fe1e4e0a164874e2cf7eaf" translate="yes" xml:space="preserve">
          <source>When the user selects an item in the usual way, the selection is cleared and the new item selected. However, if the user presses the Ctrl key when clicking on an item, the clicked item gets toggled and all other items are left untouched. If the user presses the Shift key while clicking on an item, all items between the current item and the clicked item are selected or unselected, depending on the state of the clicked item. Multiple items can be selected by dragging the mouse over them.</source>
          <target state="translated">사용자가 일반적인 방식으로 항목을 선택하면 선택이 해제되고 새 항목이 선택됩니다. 그러나 사용자가 항목을 클릭 할 때 Ctrl 키를 누르면 클릭 한 항목이 토글되고 다른 모든 항목은 그대로 유지됩니다. 사용자가 항목을 클릭하는 동안 Shift 키를 누르면 클릭 한 항목의 상태에 따라 현재 항목과 클릭 한 항목 사이의 모든 항목이 선택되거나 선택 해제됩니다. 마우스로 항목을 끌어 여러 항목을 선택할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="239784d9cf52110a5610a0352def4b21651a1ec0" translate="yes" xml:space="preserve">
          <source>When the user selects an item in the usual way, the selection is cleared and the new item selected. However, if the user presses the Shift key while clicking on an item, all items between the current item and the clicked item are selected or unselected, depending on the state of the clicked item.</source>
          <target state="translated">사용자가 일반적인 방식으로 항목을 선택하면 선택이 해제되고 새 항목이 선택됩니다. 그러나 사용자가 항목을 클릭하는 동안 Shift 키를 누르면 클릭 한 항목의 상태에 따라 현재 항목과 클릭 한 항목 사이의 모든 항목이 선택되거나 선택 해제됩니다.</target>
        </trans-unit>
        <trans-unit id="b63a60a0cef1fb52e61ed1b641072b5077221c1a" translate="yes" xml:space="preserve">
          <source>When the user selects an item in the usual way, the selection status of that item is toggled and the other items are left alone. Multiple items can be toggled by dragging the mouse over them.</source>
          <target state="translated">사용자가 일반적인 방식으로 항목을 선택하면 해당 항목의 선택 상태가 전환되고 다른 항목은 그대로 남습니다. 여러 항목을 마우스로 끌어서 토글 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="432b100478d155eb5754fdf1b8519f514ff3bcfa" translate="yes" xml:space="preserve">
          <source>When the user selects an item, any already-selected item becomes unselected. It is possible for the user to deselect the selected item.</source>
          <target state="translated">사용자가 항목을 선택하면 이미 선택된 항목이 선택 해제됩니다. 사용자가 선택한 항목을 선택 해제 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="40c8efdfbff08c7bc6b912d42d8681b4819162a6" translate="yes" xml:space="preserve">
          <source>When the user triggers a step whilst holding the &lt;a href=&quot;qt#KeyboardModifier-enum&quot;&gt;Qt::ControlModifier&lt;/a&gt;, &lt;a href=&quot;qabstractspinbox&quot;&gt;QAbstractSpinBox&lt;/a&gt; steps by 10 instead of making a single step. This step modifier affects wheel events, key events and interaction with the spinbox buttons. Note that on &lt;a href=&quot;internationalization#macos&quot;&gt;macOS&lt;/a&gt;, Control corresponds to the Command key.</source>
          <target state="translated">사용자는 유지하는 동안 단계 트리거 할 때 &lt;a href=&quot;qt#KeyboardModifier-enum&quot;&gt;Qt는 :: ControlModifier&lt;/a&gt; , &lt;a href=&quot;qabstractspinbox&quot;&gt;QAbstractSpinBox의&lt;/a&gt; 10 단계를 대신 한 단계를 만드는. 이 단계 수정자는 휠 이벤트, 주요 이벤트 및 스핀 박스 버튼과의 상호 작용에 영향을줍니다. 에 있습니다 &lt;a href=&quot;internationalization#macos&quot;&gt;맥 OS&lt;/a&gt; , 제어 명령 키에 해당합니다.</target>
        </trans-unit>
        <trans-unit id="3de1fafb709edfc8e71149ea8ddc3fd104d090bd" translate="yes" xml:space="preserve">
          <source>When the user types the &lt;a href=&quot;qkeysequence&quot;&gt;key sequence&lt;/a&gt; for a given shortcut, the shortcut's &lt;a href=&quot;qshortcut#activated&quot;&gt;activated&lt;/a&gt;() signal is emitted. (In the case of ambiguity, the &lt;a href=&quot;qshortcut#activatedAmbiguously&quot;&gt;activatedAmbiguously&lt;/a&gt;() signal is emitted.) A shortcut is &quot;listened for&quot; by Qt's event loop when the shortcut's parent widget is receiving events.</source>
          <target state="translated">사용자 가 지정된 바로 가기에 대한 &lt;a href=&quot;qkeysequence&quot;&gt;키 시퀀스&lt;/a&gt; 를 입력하면 바로 가기의 &lt;a href=&quot;qshortcut#activated&quot;&gt;활성화&lt;/a&gt; () 신호가 발생합니다. (모호한 경우, &lt;a href=&quot;qshortcut#activatedAmbiguously&quot;&gt;activatedAmbiguously&lt;/a&gt; () 신호가 방출된다.)이 바로 가기 Qt의 이벤트 루프로 바로 상위의 이벤트를 수신 할 때 위젯위한 &quot;경청&quot;이다.</target>
        </trans-unit>
        <trans-unit id="07467a76ec47313778f1640f3f2853d179a4c454" translate="yes" xml:space="preserve">
          <source>When the user uses the arrows to change the spin box's value the value will be incremented/decremented by the amount of the singleStep. The default value is 1. Setting a singleStep value of less than 0 does nothing.</source>
          <target state="translated">사용자가 화살표를 사용하여 스핀 상자 값을 변경하면 단일 단계의 양만큼 값이 증가 / 감소합니다. 기본값은 1입니다. singleStep 값을 0보다 작게 설정하면 아무 작업도 수행되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="1a7fbae2e2cb0c5b805b7e0f23104cafdd5b43a3" translate="yes" xml:space="preserve">
          <source>When the user uses the arrows to change the spin box's value the value will be incremented/decremented by the amount of the singleStep. The default value is 1.0. Setting a singleStep value of less than 0 does nothing.</source>
          <target state="translated">사용자가 화살표를 사용하여 스핀 상자 값을 변경하면 단일 단계의 양만큼 값이 증가 / 감소합니다. 기본값은 1.0입니다. singleStep 값을 0보다 작게 설정하면 아무 작업도 수행되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="55b72162369d6d7fefe6c5eeff0d064284c9c1e9" translate="yes" xml:space="preserve">
          <source>When the user wants to purchase a product, call &lt;a href=&quot;qinappproduct#purchase&quot;&gt;QInAppProduct::purchase&lt;/a&gt;() on the product. This launches a platform-specific, asynchronous process to purchase the product, for example by requesting the user's password and confirmation of the purchase. In most cases, you must make sure that the application UI is not accepting input while the purchase request is being processed, as this is not handled automatically on all platforms.</source>
          <target state="translated">사용자가 제품을 구매하려면 제품의 &lt;a href=&quot;qinappproduct#purchase&quot;&gt;QInAppProduct :: purchase&lt;/a&gt; ()로 전화 하십시오. 예를 들어, 사용자 비밀번호를 요청하고 구매를 확인하여 제품을 구매하기위한 플랫폼 별 비동기 프로세스가 시작됩니다. 대부분의 경우 구매 요청이 처리되는 동안 응용 프로그램 UI가 입력을 수락하지 않아야합니다. 이는 모든 플랫폼에서 자동으로 처리되지 않기 때문입니다.</target>
        </trans-unit>
        <trans-unit id="53e007fcb539e15013065a7fcca5f31963711f7f" translate="yes" xml:space="preserve">
          <source>When the view changes, the &lt;code&gt;inputViewChanged&lt;/code&gt; signal is emitted.</source>
          <target state="translated">뷰가 변경되면 &lt;code&gt;inputViewChanged&lt;/code&gt; 신호가 생성됩니다.</target>
        </trans-unit>
        <trans-unit id="6bf292009c41ae3996b782ddaf7f2171babcb34d" translate="yes" xml:space="preserve">
          <source>When the view is initialized, the view will create all the necessary items for the view, then animate them to their correct positions within the view over one second.</source>
          <target state="translated">뷰가 초기화되면 뷰는 뷰에 필요한 모든 항목을 생성 한 다음 1 초 동안 뷰 내에서 올바른 위치에 애니메이션을 적용합니다.</target>
        </trans-unit>
        <trans-unit id="bf9267cdf13126ffe2807371579c3234aa2c025f" translate="yes" xml:space="preserve">
          <source>When the widget is embedded, its state (e.g., visible, enabled, geometry, size hints) is copied into the proxy widget. If the embedded widget is explicitly hidden or disabled, the proxy widget will become explicitly hidden or disabled after embedding is complete. The class documentation has a full overview over the shared state.</source>
          <target state="translated">위젯이 임베드되면 상태 (예 : 표시, 사용, 지오메트리, 크기 힌트)가 프록시 위젯으로 복사됩니다. 임베드 된 위젯이 명시 적으로 숨겨 지거나 비활성화 된 경우 임베드가 완료된 후 프록시 위젯이 명시 적으로 숨겨 지거나 비활성화됩니다. 수업 문서에는 공유 상태에 대한 전체 개요가 있습니다.</target>
        </trans-unit>
        <trans-unit id="0eed7c85c5152e46b5d87508ebba22a259d445d6" translate="yes" xml:space="preserve">
          <source>When the widget needs to generate a set of preview pages, a &lt;a href=&quot;qprintpreviewwidget#paintRequested&quot;&gt;paintRequested&lt;/a&gt;() signal will be emitted from the widget. Connect a slot to this signal, and draw onto the &lt;a href=&quot;qprinter&quot;&gt;QPrinter&lt;/a&gt; passed in as a signal parameter. Call &lt;a href=&quot;qprinter#newPage&quot;&gt;QPrinter::newPage&lt;/a&gt;(), to start a new page in the preview.</source>
          <target state="translated">위젯이 미리보기 페이지 세트를 생성해야하는 경우 위젯에서 &lt;a href=&quot;qprintpreviewwidget#paintRequested&quot;&gt;paintRequested&lt;/a&gt; () 신호가 생성됩니다. 이 신호에 슬롯을 연결하고 신호 매개 변수로 전달 된 &lt;a href=&quot;qprinter&quot;&gt;QPrinter&lt;/a&gt; 에 그립니다 . 미리보기에서 새 페이지를 시작하려면 &lt;a href=&quot;qprinter#newPage&quot;&gt;QPrinter :: newPage&lt;/a&gt; ()를 호출 하십시오.</target>
        </trans-unit>
        <trans-unit id="17365a086c8d8f3707090a7d37af79afa83d7862" translate="yes" xml:space="preserve">
          <source>When the widget's window and the related OpenGL resources are not yet initialized, the return value is the format that has been set via &lt;a href=&quot;qopenglwidget#setFormat&quot;&gt;setFormat&lt;/a&gt;().</source>
          <target state="translated">위젯의 창과 관련 OpenGL 리소스가 아직 초기화되지 않은 경우 반환 값은 &lt;a href=&quot;qopenglwidget#setFormat&quot;&gt;setFormat&lt;/a&gt; ()을 통해 설정된 형식입니다 .</target>
        </trans-unit>
        <trans-unit id="43847dedad7e1417643232066e6b313499c2942c" translate="yes" xml:space="preserve">
          <source>When the widget-style font and palette propagation is enabled, font and palette changes made through Qt Style Sheets will behave as though the user had manually called the corresponding &lt;a href=&quot;qwidget#palette-prop&quot;&gt;QWidget::setPalette&lt;/a&gt;() and &lt;a href=&quot;qwidget#font-prop&quot;&gt;QWidget::setFont&lt;/a&gt;() methods on all of the QWidgets targeted by the style sheet. If this would have caused propagation in C++, it will cause propagation in style sheets and vice versa.</source>
          <target state="translated">위젯 스타일의 글꼴 및 팔레트 전파가 활성화되면 Qt 스타일 시트를 통해 &lt;a href=&quot;qwidget#palette-prop&quot;&gt;작성된&lt;/a&gt; 글꼴 및 팔레트 변경 사항은 사용자가 모든 항목에서 해당 QWidget :: setPalette () 및 &lt;a href=&quot;qwidget#font-prop&quot;&gt;QWidget :: setFont&lt;/a&gt; () 메소드를 수동으로 호출 한 것처럼 작동 합니다. 스타일 시트가 대상으로하는 QWidgets. 이로 인해 C ++에서 전파가 발생하면 스타일 시트에서 전파가 발생하고 그 반대도 마찬가지입니다.</target>
        </trans-unit>
        <trans-unit id="d46c08525c4ed676f1a7ccbb248c7080204996de" translate="yes" xml:space="preserve">
          <source>When the window is made visible, the content is updated automatically. Further updates can be requested by calling &lt;a href=&quot;qwindow#requestUpdate&quot;&gt;QWindow::requestUpdate&lt;/a&gt;(). To render continuously, call &lt;a href=&quot;qwindow#requestUpdate&quot;&gt;requestUpdate&lt;/a&gt;() after &lt;a href=&quot;qvulkanwindow#frameReady&quot;&gt;frameReady&lt;/a&gt;().</source>
          <target state="translated">창이 표시되면 내용이 자동으로 업데이트됩니다. &lt;a href=&quot;qwindow#requestUpdate&quot;&gt;QWindow :: requestUpdate&lt;/a&gt; ()를 호출하여 추가 업데이트를 요청할 수 있습니다 . 계속 렌더링하려면 &lt;a href=&quot;qvulkanwindow#frameReady&quot;&gt;frameReady&lt;/a&gt; () 다음에 &lt;a href=&quot;qwindow#requestUpdate&quot;&gt;requestUpdate&lt;/a&gt; ()를 호출하십시오 .</target>
        </trans-unit>
        <trans-unit id="d0885d46fa70f463e2de0a22a1a8f497582d4166" translate="yes" xml:space="preserve">
          <source>When the window is not exposed, it is shown by the application but it is still not showing in the windowing system, so the application should minimize rendering and other graphical activities.</source>
          <target state="translated">창이 노출되지 않으면 응용 프로그램에 의해 표시되지만 여전히 윈도우 시스템에는 표시되지 않으므로 응용 프로그램은 렌더링 및 기타 그래픽 활동을 최소화해야합니다.</target>
        </trans-unit>
        <trans-unit id="298ff46be999c313b755a4569e2c0f50522cc6cd" translate="yes" xml:space="preserve">
          <source>When the window state changes, the widget receives a &lt;a href=&quot;qwidget#changeEvent&quot;&gt;changeEvent&lt;/a&gt;() of type &lt;a href=&quot;qevent#Type-enum&quot;&gt;QEvent::WindowStateChange&lt;/a&gt;.</source>
          <target state="translated">창 상태가 변경되면 위젯은 &lt;a href=&quot;qevent#Type-enum&quot;&gt;QEvent :: WindowStateChange&lt;/a&gt; 유형 의 &lt;a href=&quot;qwidget#changeEvent&quot;&gt;changeEvent&lt;/a&gt; ()를 수신합니다 .</target>
        </trans-unit>
        <trans-unit id="4430665a811124c03a76c8e73574aa765dc47098" translate="yes" xml:space="preserve">
          <source>When there are too many tabs in a tab bar for its size, the tab bar can either choose to expand its size or to add buttons that allow you to scroll through the tabs.</source>
          <target state="translated">탭 막대에 크기에 비해 탭이 너무 많으면 탭 막대가 크기를 확장하거나 탭을 스크롤 할 수있는 단추를 추가하도록 선택할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="328188d436a703678d89704707e3862740fee438" translate="yes" xml:space="preserve">
          <source>When these images are loaded by QML, it looks for a matching image provider and calls its &lt;a href=&quot;qquickimageprovider#requestImage&quot;&gt;requestImage&lt;/a&gt;() or &lt;a href=&quot;qquickimageprovider#requestPixmap&quot;&gt;requestPixmap&lt;/a&gt;() method (depending on its &lt;a href=&quot;qquickimageprovider#imageType&quot;&gt;imageType&lt;/a&gt;()) to load the image. The method is called with the &lt;code&gt;id&lt;/code&gt; parameter set to &quot;yellow&quot; for the first image, and &quot;red&quot; for the second.</source>
          <target state="translated">이러한 이미지가 QML에 의해로드되면 일치하는 이미지 제공자를 찾고 이미지를로드하기 위해 해당 &lt;a href=&quot;qquickimageprovider#imageType&quot;&gt;imageType&lt;/a&gt; () 에 따라 &lt;a href=&quot;qquickimageprovider#requestImage&quot;&gt;requestImage&lt;/a&gt; () 또는 &lt;a href=&quot;qquickimageprovider#requestPixmap&quot;&gt;requestPixmap&lt;/a&gt; () 메소드를 호출합니다 . 첫 번째 이미지 는 &lt;code&gt;id&lt;/code&gt; 매개 변수를 &quot;yellow&quot;로 설정하고 두 번째 이미지는 &quot;red&quot;로 설정하여 메소드를 호출 합니다.</target>
        </trans-unit>
        <trans-unit id="280d1db6d231e9b9540bfc8acf026c5df8031216" translate="yes" xml:space="preserve">
          <source>When this argument is used, a second argument is required, which specifies the module whose classes are to be listed. QDoc generates a table containing those classes. Each class is listed with the text of its &lt;a href=&quot;11-qdoc-commands-specialcontent#brief-command&quot;&gt;\brief&lt;/a&gt; command.</source>
          <target state="translated">이 인수를 사용하면 클래스를 나열 할 모듈을 지정하는 두 번째 인수가 필요합니다. QDoc은 해당 클래스를 포함하는 테이블을 생성합니다. 각 클래스는 &lt;a href=&quot;11-qdoc-commands-specialcontent#brief-command&quot;&gt;\ brief&lt;/a&gt; 명령 의 텍스트와 함께 나열됩니다 .</target>
        </trans-unit>
        <trans-unit id="278d7e1255bd96582c739bd15df2833e0be8a868" translate="yes" xml:space="preserve">
          <source>When this code is loaded by the engine, it creates an object tree with a &lt;a href=&quot;qml-qtquick-rectangle&quot;&gt;Rectangle&lt;/a&gt; object at the root; this object has a &lt;a href=&quot;qml-qtquick-gradient&quot;&gt;Gradient&lt;/a&gt; child object, which in turn has two &lt;a href=&quot;qml-qtquick-gradientstop&quot;&gt;GradientStop&lt;/a&gt; children.</source>
          <target state="translated">이 코드는 엔진에 의해로드 될 때 루트에 &lt;a href=&quot;qml-qtquick-rectangle&quot;&gt;Rectangle&lt;/a&gt; 객체 가있는 객체 트리를 만듭니다 . 이 객체에는 &lt;a href=&quot;qml-qtquick-gradient&quot;&gt;Gradient&lt;/a&gt; 하위 객체가 있으며 두 개의 &lt;a href=&quot;qml-qtquick-gradientstop&quot;&gt;GradientStop&lt;/a&gt; 하위 객체가 있습니다.</target>
        </trans-unit>
        <trans-unit id="bef518027d6e82c3441e9a6878947589c6671093" translate="yes" xml:space="preserve">
          <source>When this event occurs it is customary to show a &lt;a href=&quot;qmenu&quot;&gt;QMenu&lt;/a&gt; with a context menu, if this is relevant to the context.</source>
          <target state="translated">이 이벤트가 발생하면 컨텍스트와 관련이있는 경우 컨텍스트 메뉴와 함께 &lt;a href=&quot;qmenu&quot;&gt;QMenu&lt;/a&gt; 를 표시하는 것이 일반적 입니다.</target>
        </trans-unit>
        <trans-unit id="1c5aa92c276833ef89412fc07466f6fcff736ad0" translate="yes" xml:space="preserve">
          <source>When this feature is on (the default is off), clicking on a header section sorts the items according to that column. By clicking repeatedly, the user can alternate between ascending and descending order.</source>
          <target state="translated">이 기능이 켜져 있으면 (기본값은 꺼져 있음) 머리글 섹션을 클릭하면 해당 열에 따라 항목이 정렬됩니다. 반복해서 클릭하면 오름차순과 내림차순을 번갈아 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5aafd154ba0fcb35eccabb15e1a7d96cc39747d6" translate="yes" xml:space="preserve">
          <source>When this function is called after the program has been linked, the program will need to be relinked for the change to take effect.</source>
          <target state="translated">프로그램이 링크 된 후이 함수가 호출되면 변경 사항을 적용하려면 프로그램을 다시 링크해야합니다.</target>
        </trans-unit>
        <trans-unit id="c9186348bdc67fdf223b859066aa3c52ea35863b" translate="yes" xml:space="preserve">
          <source>When this function is called multiple times in quick succession with the same function as its first argument, that function will be called only once.</source>
          <target state="translated">이 함수가 첫 번째 인수와 동일한 함수로 연속해서 빠르게 여러 번 호출되면 해당 함수는 한 번만 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="398a779395d95b160c8ff7f5a1fe0f7602c5e153" translate="yes" xml:space="preserve">
          <source>When this function is called, the purchase process is initiated. At some point during the process, the &lt;a href=&quot;qinappstore#transactionReady&quot;&gt;QInAppStore::transactionReady&lt;/a&gt;() signal is emitted, and the slot registered earlier is called. In this function, you can save data about a successful purchase so that it survives across application runs. After verifying that the data has been stored, finalize the transaction. If the transaction fails, display information about the failure to the user and finalize the transaction.</source>
          <target state="translated">이 기능이 호출되면 구매 프로세스가 시작됩니다. 프로세스 도중 어느 시점에서 &lt;a href=&quot;qinappstore#transactionReady&quot;&gt;QInAppStore :: transactionReady&lt;/a&gt; () 신호가 발생하고 이전에 등록 된 슬롯이 호출됩니다. 이 기능에서는 성공적인 구매에 대한 데이터를 저장하여 애플리케이션 실행시에도 지속될 수 있습니다. 데이터가 저장되었는지 확인한 후 트랜잭션을 완료하십시오. 트랜잭션이 실패하면 사용자에게 실패에 대한 정보를 표시하고 트랜잭션을 완료하십시오.</target>
        </trans-unit>
        <trans-unit id="0a8adea584e450f3c916a9833293ed806c718263" translate="yes" xml:space="preserve">
          <source>When this hint is set and it is applicable, the clip region will be generated from &lt;a href=&quot;qsgclipnode#clipRect&quot;&gt;clipRect&lt;/a&gt;() rather than &lt;a href=&quot;qsgbasicgeometrynode#geometry&quot;&gt;geometry&lt;/a&gt;().</source>
          <target state="translated">이 힌트가 설정되어 적용 가능한 경우, 클립 영역은 &lt;a href=&quot;qsgbasicgeometrynode#geometry&quot;&gt;지오메트리&lt;/a&gt; ()가 아니라 &lt;a href=&quot;qsgclipnode#clipRect&quot;&gt;clipRect&lt;/a&gt; () 에서 생성됩니다 .</target>
        </trans-unit>
        <trans-unit id="25c548388c50d22300a6331c81e8413c5cbc46fc" translate="yes" xml:space="preserve">
          <source>When this is enabled, qmake will process all libraries linked to by the application and find their meta-information. qmake will use this to determine the relevant linking information, specifically adding values to the application project file's list of &lt;a href=&quot;qmake-variable-reference#defines&quot;&gt;DEFINES&lt;/a&gt; as well as &lt;a href=&quot;qmake-variable-reference#libs&quot;&gt;LIBS&lt;/a&gt;. Once qmake has processed this file, it will then look through the newly introduced libraries in the &lt;code&gt;LIBS&lt;/code&gt; variable, and find their dependent .prl files, continuing until all libraries have been resolved. At this point, the Makefile is created as usual, and the libraries are linked explicitly against the application.</source>
          <target state="translated">이 기능이 활성화되면 qmake는 응용 프로그램에 연결된 모든 라이브러리를 처리하고 메타 정보를 찾습니다. qmake는이를 사용하여 관련 링크 정보를 결정합니다. 특히 애플리케이션 프로젝트 파일의 &lt;a href=&quot;qmake-variable-reference#defines&quot;&gt;DEFINES&lt;/a&gt; 및 &lt;a href=&quot;qmake-variable-reference#libs&quot;&gt;LIBS&lt;/a&gt; 값에 값을 추가합니다 . qmake가이 파일을 처리하면 &lt;code&gt;LIBS&lt;/code&gt; 변수 에서 새로 도입 된 라이브러리를 살펴보고 모든 라이브러리가 해결 될 때까지 계속해서 종속 .prl 파일을 찾습니다. 이 시점에서 Makefile은 평소와 같이 작성되며 라이브러리는 애플리케이션과 명시 적으로 링크됩니다.</target>
        </trans-unit>
        <trans-unit id="e1c2654888290051c11e8d6edd467ee92c8e7a88" translate="yes" xml:space="preserve">
          <source>When this is repeated for each leaf node in the framegraph, the frame is complete and the renderer calls &lt;a href=&quot;qopenglcontext#swapBuffers&quot;&gt;QOpenGLContext::swapBuffers&lt;/a&gt;() to display the frame.</source>
          <target state="translated">프레임 &lt;a href=&quot;qopenglcontext#swapBuffers&quot;&gt;그래프의&lt;/a&gt; 각 리프 노드에 대해이 작업이 반복되면 프레임이 완료되고 렌더러가 QOpenGLContext :: swapBuffers ()를 호출 하여 프레임을 표시합니다.</target>
        </trans-unit>
        <trans-unit id="ec52fd20354c1402a9e5c8a902314529744bb69a" translate="yes" xml:space="preserve">
          <source>When this method is called it additionally sets either the &lt;a href=&quot;qml-qtquick-controls-textarea#selectionStart-prop&quot;&gt;selectionStart&lt;/a&gt; or the &lt;a href=&quot;qml-qtquick-controls-textarea#selectionEnd-prop&quot;&gt;selectionEnd&lt;/a&gt; (whichever was at the previous cursor position) to the specified position. This allows you to easily extend and contract the selected text range.</source>
          <target state="translated">이 메소드를 호출하면 &lt;a href=&quot;qml-qtquick-controls-textarea#selectionStart-prop&quot;&gt;selectionStart&lt;/a&gt; 또는 &lt;a href=&quot;qml-qtquick-controls-textarea#selectionEnd-prop&quot;&gt;selectionEnd&lt;/a&gt; (이전 커서 위치 중 하나)를 지정된 위치로 추가로 설정합니다 . 선택한 텍스트 범위를 쉽게 확장하고 축소 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0b402258b559da375e5607dca734ac8dba2f14ee" translate="yes" xml:space="preserve">
          <source>When this method is called it additionally sets either the &lt;a href=&quot;qml-qtquick-textedit#selectionStart-prop&quot;&gt;selectionStart&lt;/a&gt; or the &lt;a href=&quot;qml-qtquick-textedit#selectionEnd-prop&quot;&gt;selectionEnd&lt;/a&gt; (whichever was at the previous cursor position) to the specified position. This allows you to easily extend and contract the selected text range.</source>
          <target state="translated">이 메소드를 호출하면 &lt;a href=&quot;qml-qtquick-textedit#selectionStart-prop&quot;&gt;selectionStart&lt;/a&gt; 또는 &lt;a href=&quot;qml-qtquick-textedit#selectionEnd-prop&quot;&gt;selectionEnd&lt;/a&gt; (이전 커서 위치 중 하나)를 지정된 위치로 추가로 설정합니다 . 선택한 텍스트 범위를 쉽게 확장하고 축소 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="81183ac8bcf1dd186d0806619cf0a4b7150e1d76" translate="yes" xml:space="preserve">
          <source>When this method is called it additionally sets either the &lt;a href=&quot;qml-qtquick-textinput#selectionStart-prop&quot;&gt;selectionStart&lt;/a&gt; or the &lt;a href=&quot;qml-qtquick-textinput#selectionEnd-prop&quot;&gt;selectionEnd&lt;/a&gt; (whichever was at the previous cursor position) to the specified position. This allows you to easily extend and contract the selected text range.</source>
          <target state="translated">이 메소드를 호출하면 &lt;a href=&quot;qml-qtquick-textinput#selectionStart-prop&quot;&gt;selectionStart&lt;/a&gt; 또는 &lt;a href=&quot;qml-qtquick-textinput#selectionEnd-prop&quot;&gt;selectionEnd&lt;/a&gt; (이전 커서 위치 중 하나)를 지정된 위치로 추가로 설정합니다 . 선택한 텍스트 범위를 쉽게 확장하고 축소 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3be9f15b12fa7586e346464303593068b7d2ddce" translate="yes" xml:space="preserve">
          <source>When this method is called, or when the user tries to close the window by its title bar button, the &lt;a href=&quot;qml-qtquick-window-window#closing-signal&quot;&gt;closing&lt;/a&gt; signal will be emitted. If there is no handler, or the handler does not revoke permission to close, the window will subsequently close. If the &lt;a href=&quot;qguiapplication#quitOnLastWindowClosed-prop&quot;&gt;QGuiApplication::quitOnLastWindowClosed&lt;/a&gt; property is &lt;code&gt;true&lt;/code&gt;, and there are no other windows open, the application will quit.</source>
          <target state="translated">이 메소드가 호출되거나 사용자가 제목 표시 줄 단추로 창을 닫으려고하면 &lt;a href=&quot;qml-qtquick-window-window#closing-signal&quot;&gt;종료&lt;/a&gt; 신호가 발생합니다. 처리기가 없거나 처리기가 닫을 수있는 권한을 취소하지 않으면 창이 닫힙니다. 는 IF &lt;a href=&quot;qguiapplication#quitOnLastWindowClosed-prop&quot;&gt;QGuiApplication :: quitOnLastWindowClosed의&lt;/a&gt; 재산이 &lt;code&gt;true&lt;/code&gt; 과 다른 창을 열 수 없습니다, 응용 프로그램이 종료됩니다.</target>
        </trans-unit>
        <trans-unit id="4ca058932c3f0b4bb0aeaff104b696065bebb8ff" translate="yes" xml:space="preserve">
          <source>When this option is enabled, qmake will process all libraries linked to by the application and find their meta-information (see &lt;a href=&quot;qmake-advanced-usage#libdepend&quot;&gt;Library Dependencies&lt;/a&gt; for more info).</source>
          <target state="translated">이 옵션이 활성화되면 qmake는 응용 프로그램에 연결된 모든 라이브러리를 처리하고 메타 정보를 찾습니다 (자세한 내용은 &lt;a href=&quot;qmake-advanced-usage#libdepend&quot;&gt;라이브러리 종속성&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="e954b1e0533aa197768aa31122dd76fd088a3473" translate="yes" xml:space="preserve">
          <source>When this option is set, &lt;a href=&quot;qtextline#naturalTextWidth&quot;&gt;QTextLine::naturalTextWidth&lt;/a&gt;() and &lt;a href=&quot;qtextline#naturalTextRect&quot;&gt;QTextLine::naturalTextRect&lt;/a&gt;() will return a value that includes the width of trailing spaces in the text; otherwise this width is excluded.</source>
          <target state="translated">이 옵션이 설정되면 &lt;a href=&quot;qtextline#naturalTextWidth&quot;&gt;QTextLine :: naturalTextWidth&lt;/a&gt; () 및 &lt;a href=&quot;qtextline#naturalTextRect&quot;&gt;QTextLine :: naturalTextRect&lt;/a&gt; ()는 텍스트의 후행 공백 너비를 포함하는 값을 리턴합니다. 그렇지 않으면이 너비는 제외됩니다.</target>
        </trans-unit>
        <trans-unit id="7e4b2c0654bf40a5f19574c6810ff26dfd4d2ceb" translate="yes" xml:space="preserve">
          <source>When this option is set, &lt;a href=&quot;qtextline#naturalTextWidth&quot;&gt;QTextLine::naturalTextWidth&lt;/a&gt;() and naturalTextRect() will return a value that includes the width of trailing spaces in the text; otherwise this width is excluded.</source>
          <target state="translated">이 옵션이 설정되면 &lt;a href=&quot;qtextline#naturalTextWidth&quot;&gt;QTextLine :: naturalTextWidth&lt;/a&gt; () 및 naturalTextRect ()는 텍스트의 후행 공백 너비를 포함하는 값을 리턴합니다. 그렇지 않으면이 너비는 제외됩니다.</target>
        </trans-unit>
        <trans-unit id="7c42f5c456658d1e6cc7ae9de66d3b8a114c246a" translate="yes" xml:space="preserve">
          <source>When this property changes, the &lt;code&gt;topLevelChanged()&lt;/code&gt; signal is emitted.</source>
          <target state="translated">이 속성이 변경되면 &lt;code&gt;topLevelChanged()&lt;/code&gt; 신호가 생성됩니다.</target>
        </trans-unit>
        <trans-unit id="2e8947f71029eebb8d494bf176ad2f080cf20f26" translate="yes" xml:space="preserve">
          <source>When this property is &lt;code&gt;false&lt;/code&gt;, it's not possible to drag the dial across the from and to values.</source>
          <target state="translated">이 속성이 &lt;code&gt;false&lt;/code&gt; 인 경우 발신인과 발신인간에 다이얼을 드래그 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="2cf377eb087a92958eeac23380aef05f26d062d5" translate="yes" xml:space="preserve">
          <source>When this property is &lt;code&gt;true&lt;/code&gt; (the default), the next month, previous month, month selection, year selection controls are shown on top.</source>
          <target state="translated">이 속성이 &lt;code&gt;true&lt;/code&gt; (기본값)이면 다음 달, 이전 달, 월 선택, 연도 선택 컨트롤이 맨 위에 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="bf43a8d4ad0de35433838bc85feefa148dfa808b" translate="yes" xml:space="preserve">
          <source>When this property is set and the &lt;a href=&quot;qml-qtquick-springanimation#velocity-prop&quot;&gt;velocity&lt;/a&gt; value is greater than 0, the &lt;a href=&quot;qml-qtquick-springanimation#velocity-prop&quot;&gt;velocity&lt;/a&gt; limits the maximum speed.</source>
          <target state="translated">이 속성이 설정되고 &lt;a href=&quot;qml-qtquick-springanimation#velocity-prop&quot;&gt;속도&lt;/a&gt; 값이 0보다 큰 경우 &lt;a href=&quot;qml-qtquick-springanimation#velocity-prop&quot;&gt;속도&lt;/a&gt; 는 최대 속도를 제한합니다.</target>
        </trans-unit>
        <trans-unit id="bf92afa5571a2082abd019a22b3b5e076f89feca" translate="yes" xml:space="preserve">
          <source>When this property is set any current decoding is stopped, and any audio buffers are discarded.</source>
          <target state="translated">이 속성을 설정하면 현재 디코딩이 중지되고 모든 오디오 버퍼가 삭제됩니다.</target>
        </trans-unit>
        <trans-unit id="6f37ded37bad8b26d03755297e0d0d1d2d468416" translate="yes" xml:space="preserve">
          <source>When this property is set the tab widget frame is not rendered. This mode is useful for showing document-type pages where the page covers most of the tab widget area.</source>
          <target state="translated">이 속성을 설정하면 탭 위젯 프레임이 렌더링되지 않습니다. 이 모드는 페이지가 탭 위젯 영역의 대부분을 차지하는 문서 유형 페이지를 표시하는 데 유용합니다.</target>
        </trans-unit>
        <trans-unit id="bb1f39d69438f440f90e503c95bb71197010e140" translate="yes" xml:space="preserve">
          <source>When this property is set to &lt;a href=&quot;qcalendarwidget#SelectionMode-enum&quot;&gt;SingleSelection&lt;/a&gt;, the user can select a date within the minimum and maximum allowed dates, using either the mouse or the keyboard.</source>
          <target state="translated">이 특성이 &lt;a href=&quot;qcalendarwidget#SelectionMode-enum&quot;&gt;SingleSelection&lt;/a&gt; 으로 설정 되면 사용자는 마우스 또는 키보드를 사용하여 최소 및 최대 허용 날짜 내에서 날짜를 선택할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4747a4a028b83a9e0e586a4b5157956a8881beee" translate="yes" xml:space="preserve">
          <source>When this property is set to &lt;a href=&quot;qt#CursorMoveStyle-enum&quot;&gt;Qt::VisualMoveStyle&lt;/a&gt;, the line edit will use visual movement style. Pressing the left arrow key will always cause the cursor to move left, regardless of the text's writing direction. The same behavior applies to right arrow key.</source>
          <target state="translated">이 속성을 &lt;a href=&quot;qt#CursorMoveStyle-enum&quot;&gt;Qt :: VisualMoveStyle로&lt;/a&gt; 설정 하면 선 편집시 시각적 이동 스타일이 사용됩니다. 왼쪽 화살표 키를 누르면 텍스트의 쓰기 방향에 관계없이 커서가 항상 왼쪽으로 이동합니다. 오른쪽 화살표 키에도 동일한 동작이 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="0edc644e371fc7727ba54cb716093cdd57e0cd9c" translate="yes" xml:space="preserve">
          <source>When this property is set, the given folder will be treated as the root in the file system, so that you can only traverse subfolders within it.</source>
          <target state="translated">이 속성을 설정하면 지정된 폴더가 파일 시스템의 루트로 취급되므로 그 안에있는 하위 폴더 만 통과 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b2d44a4363149f5868c0478951229cd0f684ca40" translate="yes" xml:space="preserve">
          <source>When this property is set, the specified opacity is also applied individually to child items. This may have an unintended effect in some circumstances. For example in the second set of rectangles below, the red rectangle has specified an opacity of 0.5, which affects the opacity of its blue child rectangle even though the child has not specified an opacity.</source>
          <target state="translated">이 속성을 설정하면 지정된 불투명도가 하위 항목에도 개별적으로 적용됩니다. 일부 상황에서는 의도하지 않은 영향을 줄 수 있습니다. 예를 들어 아래 두 번째 사각형 집합에서 빨간색 사각형은 불투명도를 0.5로 지정했습니다. 이는 자식이 불투명도를 지정하지 않은 경우에도 파란색 자식 사각형의 불투명도에 영향을줍니다.</target>
        </trans-unit>
        <trans-unit id="d9f5748d3f3423c22760b03f83dc84f38b1f3b1f" translate="yes" xml:space="preserve">
          <source>When this propery is set to false text edit will accept only plain text input from the user. For example through clipboard or drag and drop.</source>
          <target state="translated">이 속성이 false로 설정되면 텍스트 편집은 사용자의 일반 텍스트 입력 만 허용합니다. 예를 들어 클립 보드 또는 드래그 앤 드롭을 통해.</target>
        </trans-unit>
        <trans-unit id="aec3729055d25b18cd030179a5d7fbd186ecaf3f" translate="yes" xml:space="preserve">
          <source>When this restore policy is set, the machine will automatically restore all properties. If it enters a state where a given property is not set, it will first search the hierarchy of ancestors to see if the property is defined there. If it is, the property will be restored to the value defined by the closest ancestor. If not, it will be restored to its initial value (i.e. the value of the property before any property assignments in states were executed.)</source>
          <target state="translated">이 복원 정책이 설정되면 머신은 모든 속성을 자동으로 복원합니다. 주어진 속성이 설정되지 않은 상태가되면 먼저 조상의 계층을 검색하여 속성이 정의되어 있는지 확인합니다. 있는 경우 속성은 가장 가까운 조상에 의해 정의 된 값으로 복원됩니다. 그렇지 않은 경우 초기 값 (즉, 상태의 속성 할당이 실행되기 전의 속성 값)으로 복원됩니다.</target>
        </trans-unit>
        <trans-unit id="2cb4559c1cf0ab4e52e4f01892955e108435ae26" translate="yes" xml:space="preserve">
          <source>When this signal is emitted, the event loop has already stopped running. No more events will be processed in the thread, except for deferred deletion events. This signal can be connected to &lt;a href=&quot;qobject#deleteLater&quot;&gt;QObject::deleteLater&lt;/a&gt;(), to free objects in that thread.</source>
          <target state="translated">이 신호가 발생하면 이벤트 루프가 이미 실행을 중지 한 것입니다. 지연된 삭제 이벤트를 제외하고는 더 이상 이벤트가 스레드에서 처리되지 않습니다. 이 신호는 &lt;a href=&quot;qobject#deleteLater&quot;&gt;QObject :: deleteLater&lt;/a&gt; ()에 연결하여 해당 스레드의 객체를 해제 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="bc470d3a44b5fd1b983e2c2d38610b55df6e2808" translate="yes" xml:space="preserve">
          <source>When this signal is emitted, the socket may not be ready for a reconnect attempt. In that case, attempts to reconnect should be done from the event loop. For example, use a &lt;a href=&quot;qtimer#singleShot&quot;&gt;QTimer::singleShot&lt;/a&gt;() with 0 as the timeout.</source>
          <target state="translated">이 신호가 발생하면 소켓이 다시 연결을 시도 할 수 없습니다. 이 경우 이벤트 루프에서 다시 연결을 시도해야합니다. 예를 들어, &lt;a href=&quot;qtimer#singleShot&quot;&gt;QTimer :: singleShot&lt;/a&gt; ()을 시간 초과로 0으로 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="68f5a54216eb63b6271e28125c316438880cf091" translate="yes" xml:space="preserve">
          <source>When tr() is called, it looks up the translatable string using a &lt;a href=&quot;qtranslator&quot;&gt;QTranslator&lt;/a&gt; object. For translation to work, one or more of these must have been installed on the application object in the way described in &lt;a href=&quot;internationalization#enabling-translation&quot;&gt;Enabling Translation&lt;/a&gt;.</source>
          <target state="translated">tr ()이 호출되면 &lt;a href=&quot;qtranslator&quot;&gt;QTranslator&lt;/a&gt; 객체를 사용하여 번역 가능한 문자열을 찾습니다 . 번역이 작동하려면 번역 &lt;a href=&quot;internationalization#enabling-translation&quot;&gt;사용에&lt;/a&gt; 설명 된 방식으로 응용 프로그램 객체에 하나 이상이 설치되어 있어야합니다 .</target>
        </trans-unit>
        <trans-unit id="b9ebf77d443c0f3c1d237e7890cbd696ca28dded" translate="yes" xml:space="preserve">
          <source>When transforming a pixmap using the &lt;a href=&quot;qpixmap#transformed&quot;&gt;transformed&lt;/a&gt;() function, the transformation matrix is internally adjusted to compensate for unwanted translation, i.e. &lt;a href=&quot;qpixmap#transformed&quot;&gt;transformed&lt;/a&gt;() returns the smallest pixmap containing all transformed points of the original pixmap. This function returns the modified matrix, which maps points correctly from the original pixmap into the new pixmap.</source>
          <target state="translated">&lt;a href=&quot;qpixmap#transformed&quot;&gt;변환 된&lt;/a&gt; () 함수를 사용하여 픽스맵을 변환 할 때 변환 매트릭스는 원치 않는 변환을 보상하도록 내부적으로 조정됩니다. 즉, &lt;a href=&quot;qpixmap#transformed&quot;&gt;변환 된&lt;/a&gt; ()은 원래 픽스맵의 모든 변환 된 점을 포함하는 가장 작은 픽스맵을 반환합니다. 이 함수는 수정 된 행렬을 반환합니다.이 행렬은 원래 픽스맵의 포인트를 새로운 픽스맵으로 올바르게 매핑합니다.</target>
        </trans-unit>
        <trans-unit id="e797276249bcc854a69b6e49354f4d62d00c23f8" translate="yes" xml:space="preserve">
          <source>When transforming an embedded widget, Graphics View makes sure that the widget is transformed resolution independently, allowing the fonts and style to stay crisp when zoomed in. (Note that the effect of resolution independence depends on the style.)</source>
          <target state="translated">내장 된 위젯을 변환 할 때 기하 창은 위젯이 독립적으로 해상도를 변환하여 확대 할 때 글꼴과 스타일이 선명하게 유지되도록합니다. (해상도 독립의 영향은 스타일에 따라 다릅니다.)</target>
        </trans-unit>
        <trans-unit id="3aa1fd29b9548bcc37cb012b55271fdb19e2ee54" translate="yes" xml:space="preserve">
          <source>When transforming an image using the &lt;a href=&quot;qimage#transformed&quot;&gt;transformed&lt;/a&gt;() function, the transformation matrix is internally adjusted to compensate for unwanted translation, i.e. &lt;a href=&quot;qimage#transformed&quot;&gt;transformed&lt;/a&gt;() returns the smallest image containing all transformed points of the original image. This function returns the modified matrix, which maps points correctly from the original image into the new image.</source>
          <target state="translated">&lt;a href=&quot;qimage#transformed&quot;&gt;변환 된&lt;/a&gt; () 함수를 사용하여 이미지를 변환 할 때 변환 매트릭스는 원치 않는 변환을 보상하기 위해 내부적으로 조정됩니다. 즉 &lt;a href=&quot;qimage#transformed&quot;&gt;변환 된&lt;/a&gt; ()은 원래 이미지의 모든 변환 된 점을 포함하는 가장 작은 이미지를 반환합니다. 이 함수는 수정 된 행렬을 반환하여 원본 이미지의 포인트를 새 이미지에 올바르게 매핑합니다.</target>
        </trans-unit>
        <trans-unit id="7221d90a96209f3128795a80a97a531cead2f548" translate="yes" xml:space="preserve">
          <source>When transforming from clip to normalized space, a division by the w component of the vector components takes place. To prevent dividing by 0 if w equals to 0, it is set to 1.</source>
          <target state="translated">클립에서 정규화 된 공간으로 변환 할 때 벡터 구성 요소의 w 구성 요소에 의한 나누기가 발생합니다. w가 0 인 경우 0으로 나누지 않도록하기 위해 1로 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="fbec62568b02f257db0ec31fbe2b5f21cf0c220e" translate="yes" xml:space="preserve">
          <source>When transforming from clip to normalized space, a division by the w component on the vector components takes place. To prevent dividing by 0 if w equals to 0, it is set to 1.</source>
          <target state="translated">클립에서 정규화 된 공간으로 변환 할 때 벡터 구성 요소에서 w 구성 요소로 나누기가 발생합니다. w가 0 인 경우 0으로 나누지 못하게하려면 1로 설정합니다.</target>
        </trans-unit>
        <trans-unit id="f520f592321df5d529bf39711026e14f01be91fb" translate="yes" xml:space="preserve">
          <source>When true, the menu contains a special tear-off item (often shown as a dashed line at the top of the menu) that creates a copy of the menu when it is triggered.</source>
          <target state="translated">true 인 경우, 메뉴는 트리거 될 때 메뉴 사본을 작성하는 특수 분리 항목 (종종 메뉴 상단에 점선으로 표시됨)을 포함합니다.</target>
        </trans-unit>
        <trans-unit id="a89b60404dcbc2f5c915acfe02c16712d4bb61d2" translate="yes" xml:space="preserve">
          <source>When two manuals are located in the same virtual folder, it is possible to refer to sections of the other manual using relative paths. The virtual folder tag is mandatory and the folder must not contain any '/'.</source>
          <target state="translated">두 개의 매뉴얼이 동일한 가상 폴더에있는 경우 상대 경로를 사용하여 다른 매뉴얼의 섹션을 참조 할 수 있습니다. 가상 폴더 태그는 필수이며 폴더에는 '/'가 포함되지 않아야합니다.</target>
        </trans-unit>
        <trans-unit id="611300300598b513a04acdc4158b65a1b90365bd" translate="yes" xml:space="preserve">
          <source>When two widgets are adjacent to each other in a horizontal layout, setting the horizontal stretch factor of the widget on the left to 2 and the factor of widget on the right to 1 will ensure that the widget on the left will always be twice the size of the one on the right.</source>
          <target state="translated">두 개의 위젯이 가로 레이아웃에서 서로 인접한 경우 왼쪽의 위젯의 가로 스트레치 계수를 2로 설정하고 오른쪽의 위젯 계수를 1로 설정하면 왼쪽의 위젯이 항상 두 배 크기가됩니다. 오른쪽에있는</target>
        </trans-unit>
        <trans-unit id="33931b591564c5ce659c5439a00ac167ba2235e2" translate="yes" xml:space="preserve">
          <source>When two widgets are adjacent to each other in a vertical layout, setting the vertical stretch factor of the widget on the top to 2 and the factor of widget on the bottom to 1 will ensure that the widget on the top will always be twice the size of the one on the bottom.</source>
          <target state="translated">두 개의 위젯이 세로 레이아웃에서 서로 인접한 경우 상단의 위젯의 세로 스트레치 팩터를 2로 설정하고 하단의 위젯 팩터를 1로 설정하면 상단의 위젯이 항상 두 배 크기가됩니다. 바닥에있는 것의.</target>
        </trans-unit>
        <trans-unit id="55c03842e144167485cbd5e8643bcbb80f6a7794" translate="yes" xml:space="preserve">
          <source>When unshared (or const version is called), this executes in &lt;a href=&quot;containers#constant-time&quot;&gt;constant time&lt;/a&gt;.</source>
          <target state="translated">비공유 (또는 const 버전이 호출 될 때) &lt;a href=&quot;containers#constant-time&quot;&gt;상수 시간에&lt;/a&gt; 실행됩니다 .</target>
        </trans-unit>
        <trans-unit id="bcc9e75ff489b96d3335be53af67c254b116188b" translate="yes" xml:space="preserve">
          <source>When unshared (or const version is called), this executes in &lt;a href=&quot;containers#logarithmic-time&quot;&gt;logarithmic time&lt;/a&gt;.</source>
          <target state="translated">비공유 (또는 const 버전이 호출 될 때)는 &lt;a href=&quot;containers#logarithmic-time&quot;&gt;로그 시간으로&lt;/a&gt; 실행됩니다 .</target>
        </trans-unit>
        <trans-unit id="991f02e2c91e5a7647479f2f811f8738759e3c87" translate="yes" xml:space="preserve">
          <source>When updating the current time, &lt;a href=&quot;qtimeline&quot;&gt;QTimeLine&lt;/a&gt; will emit &lt;a href=&quot;qtimeline#valueChanged&quot;&gt;valueChanged&lt;/a&gt;() if the current value changed, and &lt;a href=&quot;qtimeline#frameChanged&quot;&gt;frameChanged&lt;/a&gt;() if the frame changed.</source>
          <target state="translated">현재 시간을 업데이트 할 때 &lt;a href=&quot;qtimeline&quot;&gt;QTimeLine&lt;/a&gt; 은 현재 값이 변경된 경우 &lt;a href=&quot;qtimeline#valueChanged&quot;&gt;valueChanged&lt;/a&gt; ()를 , 프레임이 변경된 경우 &lt;a href=&quot;qtimeline#frameChanged&quot;&gt;frameChanged&lt;/a&gt; ()를 방출 합니다.</target>
        </trans-unit>
        <trans-unit id="daf7b6e7fdbba2dfca1eadbe18a1d7de3b720e7b" translate="yes" xml:space="preserve">
          <source>When used as a context menu, the recommended way of opening the menu is to call &lt;a href=&quot;qml-qtquick-controls2-menu#popup-method&quot;&gt;popup()&lt;/a&gt;. Unless a position is explicitly specified, the menu is positioned at the mouse cursor on desktop platforms that have a mouse cursor available, and otherwise centered over its parent item.</source>
          <target state="translated">상황에 맞는 메뉴로 사용되는 경우 메뉴를 여는 권장 방법은 &lt;a href=&quot;qml-qtquick-controls2-menu#popup-method&quot;&gt;popup ()&lt;/a&gt; 을 호출하는 것 입니다. 위치를 명시 적으로 지정하지 않으면 메뉴는 마우스 커서를 사용할 수 있고 상위 항목의 중앙에있는 데스크탑 플랫폼에서 마우스 커서에 배치됩니다.</target>
        </trans-unit>
        <trans-unit id="e42ccc06c2943db340e29e9634bf18dbc9e13468" translate="yes" xml:space="preserve">
          <source>When used as a popup menu, it is easiest to specify the position by specifying the desired &lt;a href=&quot;qml-qtquick-controls2-popup#x-prop&quot;&gt;x&lt;/a&gt; and &lt;a href=&quot;qml-qtquick-controls2-popup#y-prop&quot;&gt;y&lt;/a&gt; coordinates using the respective properties, and call &lt;a href=&quot;qml-qtquick-controls2-popup#open-method&quot;&gt;open()&lt;/a&gt; to open the menu.</source>
          <target state="translated">팝업 메뉴로 사용되는 경우 각 속성을 사용하여 원하는 &lt;a href=&quot;qml-qtquick-controls2-popup#x-prop&quot;&gt;x&lt;/a&gt; 및 &lt;a href=&quot;qml-qtquick-controls2-popup#y-prop&quot;&gt;y&lt;/a&gt; 좌표 를 지정하여 위치를 지정하는 것이 가장 쉬우 &lt;a href=&quot;qml-qtquick-controls2-popup#open-method&quot;&gt;며 open ()&lt;/a&gt; 을 호출 하여 메뉴를 엽니 다.</target>
        </trans-unit>
        <trans-unit id="51c1a4b96d0ac9fe7349345183028fcd340a1cf9" translate="yes" xml:space="preserve">
          <source>When used as a standalone application,</source>
          <target state="translated">독립형 응용 프로그램으로 사용되는 경우</target>
        </trans-unit>
        <trans-unit id="7c8523a9cdaa732605d1c3ca0c57e7327514b32b" translate="yes" xml:space="preserve">
          <source>When used as an interface type, &lt;a href=&quot;qstringview&quot;&gt;QStringView&lt;/a&gt; allows a single function to accept a wide variety of UTF-16 string data sources. One function accepting &lt;a href=&quot;qstringview&quot;&gt;QStringView&lt;/a&gt; thus replaces three function overloads (taking &lt;a href=&quot;qstring&quot;&gt;QString&lt;/a&gt;, &lt;a href=&quot;qstringref&quot;&gt;QStringRef&lt;/a&gt;, and &lt;code&gt;(const QChar*, int)&lt;/code&gt;), while at the same time enabling even more string data sources to be passed to the function, such as &lt;code&gt;u&quot;Hello World&quot;&lt;/code&gt;, a &lt;code&gt;char16_t&lt;/code&gt; string literal.</source>
          <target state="translated">인터페이스 유형으로 사용될 때 &lt;a href=&quot;qstringview&quot;&gt;QStringView를&lt;/a&gt; 사용하면 단일 함수가 다양한 UTF-16 문자열 데이터 소스를 승인 할 수 있습니다. 따라서 &lt;a href=&quot;qstringview&quot;&gt;QStringView&lt;/a&gt; 를 수락하는 하나의 함수 는 세 개의 함수 오버로드 ( &lt;a href=&quot;qstring&quot;&gt;QString&lt;/a&gt; , &lt;a href=&quot;qstringref&quot;&gt;QStringRef&lt;/a&gt; 및 &lt;code&gt;(const QChar*, int)&lt;/code&gt; ) 를 대체 하는 동시에 &lt;code&gt;u&quot;Hello World&quot;&lt;/code&gt; 와 같이 더 많은 문자열 데이터 소스를 함수에 전달할 수 있습니다. 하는 &lt;code&gt;char16_t&lt;/code&gt; 의 문자열 리터럴.</target>
        </trans-unit>
        <trans-unit id="2e868d59396f0fc788445bb00690275ea6245ac1" translate="yes" xml:space="preserve">
          <source>When used as flags, enumerators can be combined using the OR operator.</source>
          <target state="translated">플래그로 사용될 때 OR 연산자를 사용하여 열거자를 결합 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="06c2c617a12597a994b108366e0d50cfb932d1fd" translate="yes" xml:space="preserve">
          <source>When used as part of a Transition, you can also target a specific &lt;a href=&quot;qml-qtquick-statechangescript&quot;&gt;StateChangeScript&lt;/a&gt; to run using the &lt;code&gt;scriptName&lt;/code&gt; property.</source>
          <target state="translated">전환의 일부로 사용되는 경우 &lt;code&gt;scriptName&lt;/code&gt; 속성을 사용하여 특정 &lt;a href=&quot;qml-qtquick-statechangescript&quot;&gt;StateChangeScript&lt;/a&gt; 를 실행하도록 대상을 지정할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="59f0102a4ce38b4f2ee3e6dec5be09d72963e0c7" translate="yes" xml:space="preserve">
          <source>When used in a &lt;a href=&quot;qml-qtquick-sequentialanimation&quot;&gt;SequentialAnimation&lt;/a&gt;, &lt;a href=&quot;qml-qtquick-pauseanimation&quot;&gt;PauseAnimation&lt;/a&gt; is a step when nothing happens, for a specified duration.</source>
          <target state="translated">A의 사용하는 경우 &lt;a href=&quot;qml-qtquick-sequentialanimation&quot;&gt;SequentialAnimation&lt;/a&gt; , &lt;a href=&quot;qml-qtquick-pauseanimation&quot;&gt;PauseAnimation는&lt;/a&gt; 아무것도 지정된 기간 동안, 일이 없을 때 단계입니다.</target>
        </trans-unit>
        <trans-unit id="a1ec54421dbb8796f81a74d96171dee0c22a448e" translate="yes" xml:space="preserve">
          <source>When used in a transition, a property animation is assumed to match</source>
          <target state="translated">전환에 사용될 때 속성 애니메이션이 일치하는 것으로 가정</target>
        </trans-unit>
        <trans-unit id="c62896cbdfc7c3f4c1df9f239489204e6ebe788a" translate="yes" xml:space="preserve">
          <source>When used in a transition, if no target is specified, all &lt;a href=&quot;qml-qtquick-parentchange&quot;&gt;ParentChange&lt;/a&gt; occurrences are animated by the &lt;a href=&quot;qml-qtquick-parentanimation&quot;&gt;ParentAnimation&lt;/a&gt;.</source>
          <target state="translated">전환에 사용될 때 대상을 지정하지 않으면 모든 &lt;a href=&quot;qml-qtquick-parentchange&quot;&gt;ParentChange&lt;/a&gt; 발생이 &lt;a href=&quot;qml-qtquick-parentanimation&quot;&gt;ParentAnimation에&lt;/a&gt; 의해 애니메이션됩니다 .</target>
        </trans-unit>
        <trans-unit id="28b437395e782784d83371eebd653fd7c3c66b90" translate="yes" xml:space="preserve">
          <source>When used in a transition, the path can be specified without start or end points, for example:</source>
          <target state="translated">전환에 사용될 때 경로는 시작점 또는 끝점없이 지정할 수 있습니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="ad15b94076fc6d62e74b16ac21ba031bb2e8713a" translate="yes" xml:space="preserve">
          <source>When used in combination with &lt;a href=&quot;qtreeview&quot;&gt;QTreeView&lt;/a&gt;, the first column is not movable (since it contains the tree structure), by default. You can make it movable with &lt;a href=&quot;qheaderview#firstSectionMovable-prop&quot;&gt;setFirstSectionMovable&lt;/a&gt;(true).</source>
          <target state="translated">&lt;a href=&quot;qtreeview&quot;&gt;QTreeView&lt;/a&gt; 와 함께 사용하면 기본적 으로 첫 번째 열은 이동 가능하지 않습니다 (트리 구조를 포함하므로). &lt;a href=&quot;qheaderview#firstSectionMovable-prop&quot;&gt;setFirstSectionMovable&lt;/a&gt; (true)로 이동 가능하게 만들 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="004dc51d90326bec6d46cfd29896a25f4617d992" translate="yes" xml:space="preserve">
          <source>When used in conjunction with the &lt;a href=&quot;qml-qtquick-loader#source-prop&quot;&gt;source&lt;/a&gt; property, loading and compilation will also be performed in a background thread.</source>
          <target state="translated">&lt;a href=&quot;qml-qtquick-loader#source-prop&quot;&gt;source&lt;/a&gt; 속성 과 함께 사용 하면 백그라운드 스레드에서도로드 및 컴파일이 수행됩니다.</target>
        </trans-unit>
        <trans-unit id="4b5ebb2f8eef3c956f23605775c3ca22ba3215b5" translate="yes" xml:space="preserve">
          <source>When used with list models, the first item in the returned list is used for matching.</source>
          <target state="translated">목록 모델과 함께 사용하면 반환 된 목록의 첫 번째 항목이 일치하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="2aa79e373766a60d20b2141aeac582a5a8df07d6" translate="yes" xml:space="preserve">
          <source>When user defines a new functor or generator, they need to implement the &lt;a href=&quot;qt3drender-qabstractfunctor#id&quot;&gt;QAbstractFunctor::id&lt;/a&gt;() method, which should be done using the &lt;code&gt;QT3D_FUNCTOR&lt;/code&gt; macro in the class definition.</source>
          <target state="translated">사용자가 새로운 functor 또는 generator를 정의 할 때 클래스 정의에서 &lt;code&gt;QT3D_FUNCTOR&lt;/code&gt; 매크로를 사용하여 수행해야하는 &lt;a href=&quot;qt3drender-qabstractfunctor#id&quot;&gt;QAbstractFunctor :: id&lt;/a&gt; () 메소드 를 구현 해야합니다 .</target>
        </trans-unit>
        <trans-unit id="1426cfebd5b7719f33b6e2b9f2a97f042b4572ab" translate="yes" xml:space="preserve">
          <source>When using &lt;a href=&quot;qabstractscrollarea&quot;&gt;QAbstractScrollArea&lt;/a&gt; based widgets, you should enable the &lt;a href=&quot;qt#WidgetAttribute-enum&quot;&gt;Qt::WA_AcceptTouchEvents&lt;/a&gt; attribute on the scroll area's &lt;a href=&quot;qabstractscrollarea#viewport&quot;&gt;viewport&lt;/a&gt;.</source>
          <target state="translated">사용하는 경우 &lt;a href=&quot;qabstractscrollarea&quot;&gt;QAbstractScrollArea&lt;/a&gt; 기반의 위젯을, 당신은 활성화해야 &lt;a href=&quot;qt#WidgetAttribute-enum&quot;&gt;Qt는 :: WA_AcceptTouchEvents의&lt;/a&gt; 스크롤 영역의에 속성 &lt;a href=&quot;qabstractscrollarea#viewport&quot;&gt;뷰포트를&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="575c3ca33cbc8c0e49967dd6868de7d0cd46c7ed" translate="yes" xml:space="preserve">
          <source>When using &lt;a href=&quot;qfuture&quot;&gt;QFuture&lt;/a&gt;, transferred exceptions will be thrown when calling the following functions:</source>
          <target state="translated">&lt;a href=&quot;qfuture&quot;&gt;QFuture를&lt;/a&gt; 사용 하면 다음 함수를 호출 할 때 전송 된 예외가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="6d8f6cec0c5597c992eb3a8a60ec3ad82996acf4" translate="yes" xml:space="preserve">
          <source>When using &lt;a href=&quot;qml-qt3d-render-objectpicker&quot;&gt;ObjectPicker&lt;/a&gt; components, picking is triggered by mouse events.</source>
          <target state="translated">&lt;a href=&quot;qml-qt3d-render-objectpicker&quot;&gt;ObjectPicker&lt;/a&gt; 구성 요소를 사용 하는 경우 마우스 이벤트에 의해 피킹이 트리거됩니다.</target>
        </trans-unit>
        <trans-unit id="84a71d92671a35f5e7502b348babb72bc64cf8ed" translate="yes" xml:space="preserve">
          <source>When using &lt;a href=&quot;qml-qt3d-render-raycaster&quot;&gt;RayCaster&lt;/a&gt; or &lt;a href=&quot;qml-qt3d-render-screenraycaster&quot;&gt;ScreenRayCaster&lt;/a&gt; components, picking can be explicitly triggered by the application.</source>
          <target state="translated">&lt;a href=&quot;qml-qt3d-render-raycaster&quot;&gt;RayCaster&lt;/a&gt; 또는 &lt;a href=&quot;qml-qt3d-render-screenraycaster&quot;&gt;ScreenRayCaster&lt;/a&gt; 구성 요소를 사용 하는 경우 응용 프로그램에서 피킹을 명시 적으로 트리거 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8b9d22db787646c3b272fef7eabbedc341942ce2" translate="yes" xml:space="preserve">
          <source>When using &lt;a href=&quot;qpointer&quot;&gt;QPointer&lt;/a&gt; on a &lt;a href=&quot;qwidget&quot;&gt;QWidget&lt;/a&gt; (or a subclass of &lt;a href=&quot;qwidget&quot;&gt;QWidget&lt;/a&gt;), previously the &lt;a href=&quot;qpointer&quot;&gt;QPointer&lt;/a&gt; would be cleared by the &lt;a href=&quot;qwidget&quot;&gt;QWidget&lt;/a&gt; destructor. Now, the &lt;a href=&quot;qpointer&quot;&gt;QPointer&lt;/a&gt; is cleared by the &lt;a href=&quot;qobject&quot;&gt;QObject&lt;/a&gt; destructor (since this is when &lt;a href=&quot;qweakpointer&quot;&gt;QWeakPointer&lt;/a&gt; objects are cleared). Any QPointers tracking a widget will &lt;b&gt;NOT&lt;/b&gt; be cleared before the &lt;a href=&quot;qwidget&quot;&gt;QWidget&lt;/a&gt; destructor destroys the children for the widget being tracked.</source>
          <target state="translated">사용하는 경우 &lt;a href=&quot;qpointer&quot;&gt;QPointer을&lt;/a&gt; A의 &lt;a href=&quot;qwidget&quot;&gt;는 QWidget&lt;/a&gt; (또는 서브 클래스 &lt;a href=&quot;qwidget&quot;&gt;는 QWidget&lt;/a&gt; ), 이전에 &lt;a href=&quot;qpointer&quot;&gt;QPointer는&lt;/a&gt; 에 의해 삭제 될 수 &lt;a href=&quot;qwidget&quot;&gt;는 QWidget의&lt;/a&gt; 소멸자. 이제, &lt;a href=&quot;qpointer&quot;&gt;QPointer는&lt;/a&gt; 에 의해 삭제됩니다 &lt;a href=&quot;qobject&quot;&gt;QObject를의&lt;/a&gt; (때이기 때문에 소멸자 &lt;a href=&quot;qweakpointer&quot;&gt;QWeakPointer의&lt;/a&gt; 객체가 지워집니다). 위젯을 추적하는 QPointer 는 &lt;a href=&quot;qwidget&quot;&gt;QWidget&lt;/a&gt; 소멸자가 추적중인 위젯의 하위를 파괴 하기 전에 지워지지 &lt;b&gt;않습니다&lt;/b&gt; .</target>
        </trans-unit>
        <trans-unit id="9cb101985a20e335f82bea2786675dac07ad4743" translate="yes" xml:space="preserve">
          <source>When using &lt;a href=&quot;qquickrendercontrol&quot;&gt;QQuickRenderControl&lt;/a&gt;, the responsibility for driving the rendering loop is transferred to the application. In this case no built-in render loop is used. Instead, it is up to the application to invoke the polish, synchronize and rendering steps at the appropriate time. It is possible to implement either a threaded or non-threaded behavior similar to the ones shown above.</source>
          <target state="translated">&lt;a href=&quot;qquickrendercontrol&quot;&gt;QQuickRenderControl을&lt;/a&gt; 사용할 때 렌더링 루프를 구동하는 책임은 응용 프로그램으로 전송됩니다. 이 경우 내장 렌더 루프가 사용되지 않습니다. 대신, 적절한 시간에 연마, 호출 및 렌더링 단계를 호출하는 것은 애플리케이션에 달려 있습니다. 위에 표시된 것과 유사한 스레드 또는 비스 레드 동작을 구현할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d012f8d1021f21cc24a25741a7fb9a69b828bff8" translate="yes" xml:space="preserve">
          <source>When using &lt;a href=&quot;qregexp&quot;&gt;QRegExp&lt;/a&gt;, character classes such as &lt;code&gt;\w&lt;/code&gt;, &lt;code&gt;\d&lt;/code&gt;, etc. match characters with the corresponding Unicode property: for instance, &lt;code&gt;\d&lt;/code&gt; matches any character with the Unicode Nd (decimal digit) property.</source>
          <target state="translated">&lt;a href=&quot;qregexp&quot;&gt;QRegExp를&lt;/a&gt; 사용할 때 &lt;code&gt;\w&lt;/code&gt; , &lt;code&gt;\d&lt;/code&gt; 등의 문자 클래스 는 해당 유니 코드 속성과 문자를 일치시킵니다. 예를 들어, &lt;code&gt;\d&lt;/code&gt; 는 모든 문자를 유니 코드 Nd (10 진수) 속성과 일치시킵니다.</target>
        </trans-unit>
        <trans-unit id="ac6f985a54a309fa51d578fd26c8d0b4e738a09d" translate="yes" xml:space="preserve">
          <source>When using &lt;a href=&quot;qregexp#exactMatch&quot;&gt;QRegExp::exactMatch&lt;/a&gt;(), if an exact match was not found, one could still find out how much of the subject string was matched by the regular expression by calling &lt;a href=&quot;qregexp#matchedLength&quot;&gt;QRegExp::matchedLength&lt;/a&gt;(). If the returned length was equal to the subject string's length, then one could conclude that a partial match was found.</source>
          <target state="translated">&lt;a href=&quot;qregexp#exactMatch&quot;&gt;QRegExp :: exactMatch&lt;/a&gt; ()를 사용할 때 정확히 일치하는 항목을 찾지 못하면 &lt;a href=&quot;qregexp#matchedLength&quot;&gt;QRegExp :: matchedLength&lt;/a&gt; ()를 호출하여 정규식과 일치하는 제목 문자열의 양을 여전히 알 수 있습니다 . 반환 된 길이가 주제 문자열의 길이와 같으면 부분적으로 일치하는 것으로 결론을 내릴 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7d94095f2415c5876a4a1aa870624cea946f6341" translate="yes" xml:space="preserve">
          <source>When using &lt;a href=&quot;qsqlrelationaltablemodel#setData&quot;&gt;setData&lt;/a&gt;() the role should always be &lt;a href=&quot;qt#ItemDataRole-enum&quot;&gt;Qt::EditRole&lt;/a&gt;, and when using &lt;a href=&quot;qsqlrelationaltablemodel#data&quot;&gt;data&lt;/a&gt;() the role should always be &lt;a href=&quot;qt#ItemDataRole-enum&quot;&gt;Qt::DisplayRole&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;qsqlrelationaltablemodel#setData&quot;&gt;setData&lt;/a&gt; () 사용시 역할은 항상 &lt;a href=&quot;qt#ItemDataRole-enum&quot;&gt;Qt :: EditRole이어야&lt;/a&gt; 하고 &lt;a href=&quot;qsqlrelationaltablemodel#data&quot;&gt;data&lt;/a&gt; () 사용시 역할은 항상 &lt;a href=&quot;qt#ItemDataRole-enum&quot;&gt;Qt :: DisplayRole&lt;/a&gt; 이어야합니다 .</target>
        </trans-unit>
        <trans-unit id="a13ee32d4578c512ae1659dfec745b53cf236ec8" translate="yes" xml:space="preserve">
          <source>When using &lt;a href=&quot;qt3drender-qobjectpicker&quot;&gt;QObjectPicker&lt;/a&gt; components, picking is triggered by mouse events.</source>
          <target state="translated">&lt;a href=&quot;qt3drender-qobjectpicker&quot;&gt;QObjectPicker&lt;/a&gt; 구성 요소를 사용할 때 마우스 이벤트에 의해 선택이 트리거됩니다.</target>
        </trans-unit>
        <trans-unit id="0f56fc20751ece8353bd515ce19ac51a3e3f37cf" translate="yes" xml:space="preserve">
          <source>When using &lt;a href=&quot;qt3drender-qraycaster&quot;&gt;QRayCaster&lt;/a&gt; or &lt;a href=&quot;qt3drender-qscreenraycaster&quot;&gt;QScreenRayCaster&lt;/a&gt; components, picking can be explicitly triggered by the application.</source>
          <target state="translated">&lt;a href=&quot;qt3drender-qraycaster&quot;&gt;QRayCaster&lt;/a&gt; 또는 &lt;a href=&quot;qt3drender-qscreenraycaster&quot;&gt;QScreenRayCaster&lt;/a&gt; 컴포넌트를 사용 하는 경우 애플리케이션에서 피킹을 명시 적으로 트리거 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4bb450b8e4af0bd506a47d7330ff8573095a4a13" translate="yes" xml:space="preserve">
          <source>When using &lt;a href=&quot;qvariant#canConvert-1&quot;&gt;canConvert&lt;/a&gt;() and &lt;a href=&quot;qvariant#convert&quot;&gt;convert&lt;/a&gt;() consecutively, it is possible for &lt;a href=&quot;qvariant#canConvert-1&quot;&gt;canConvert&lt;/a&gt;() to return true, but &lt;a href=&quot;qvariant#convert&quot;&gt;convert&lt;/a&gt;() to return false. This is typically because &lt;a href=&quot;qvariant#canConvert-1&quot;&gt;canConvert&lt;/a&gt;() only reports the general ability of &lt;a href=&quot;qvariant&quot;&gt;QVariant&lt;/a&gt; to convert between types given suitable data; it is still possible to supply data which cannot actually be converted.</source>
          <target state="translated">사용하는 경우 &lt;a href=&quot;qvariant#canConvert-1&quot;&gt;canConvert&lt;/a&gt; () 및 &lt;a href=&quot;qvariant#convert&quot;&gt;변환을&lt;/a&gt; 위해 () 연속, 그것은 가능하다 &lt;a href=&quot;qvariant#canConvert-1&quot;&gt;canConvert은&lt;/a&gt; ()가 true를 반환하지만, &lt;a href=&quot;qvariant#convert&quot;&gt;변환은&lt;/a&gt; ()가 false를 반환합니다. 일반적으로 &lt;a href=&quot;qvariant#canConvert-1&quot;&gt;canConvert&lt;/a&gt; ()는 &lt;a href=&quot;qvariant&quot;&gt;QVariant&lt;/a&gt; 가 적절한 데이터가 주어진 유형간에 변환 할 수있는 일반적인 기능 만보고 하기 때문입니다. 실제로 변환 할 수없는 데이터를 제공 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f5c98171bdab97a1919d644be562260acc1d76be" translate="yes" xml:space="preserve">
          <source>When using &lt;code&gt;Drag.Automatic&lt;/code&gt; you should also define &lt;a href=&quot;qml-qtquick-drag#mimeData-attached-prop&quot;&gt;mimeData&lt;/a&gt; and bind the &lt;a href=&quot;qml-qtquick-drag#active-attached-prop&quot;&gt;active&lt;/a&gt; property to the active property of &lt;a href=&quot;qml-qtquick-mousearea&quot;&gt;MouseArea&lt;/a&gt; : &lt;a href=&quot;qml-qtquick-mousearea#drag.active-prop&quot;&gt;MouseArea::drag.active&lt;/a&gt;</source>
          <target state="translated">사용하는 경우 &lt;code&gt;Drag.Automatic&lt;/code&gt; 을 당신은 또한 정의해야 &lt;a href=&quot;qml-qtquick-drag#mimeData-attached-prop&quot;&gt;mimeData&lt;/a&gt; 및 바인드 &lt;a href=&quot;qml-qtquick-drag#active-attached-prop&quot;&gt;활성&lt;/a&gt; 의 활성 재산에 대한 재산 &lt;a href=&quot;qml-qtquick-mousearea&quot;&gt;MouseArea을&lt;/a&gt; : &lt;a href=&quot;qml-qtquick-mousearea#drag.active-prop&quot;&gt;MouseArea을 :: drag.active을&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="bb15798a6838b0b5d9ff2812930cc61f9da64382" translate="yes" xml:space="preserve">
          <source>When using &lt;code&gt;swipe.left&lt;/code&gt; and &lt;code&gt;swipe.right&lt;/code&gt;, the control cannot be swiped past the left and right edges. To achieve this type of &quot;wrapping&quot; behavior, set &lt;code&gt;swipe.behind&lt;/code&gt; instead. This will result in the same item being shown regardless of which direction the control is swiped. For example, in the image below, we set &lt;code&gt;swipe.behind&lt;/code&gt; and then swipe the control repeatedly in both directions:</source>
          <target state="translated">사용하는 경우 &lt;code&gt;swipe.left&lt;/code&gt; 및 &lt;code&gt;swipe.right&lt;/code&gt; 를 컨트롤은 왼쪽과 오른쪽 가장자리를지나 쳤어요 할 수 없습니다. 이러한 유형의 &quot;래핑&quot;동작을 달성하려면 대신 &lt;code&gt;swipe.behind&lt;/code&gt; 를 설정 하십시오 . 컨트롤이 스 와이프되는 방향에 관계없이 동일한 항목이 표시됩니다. 예를 들어 아래 이미지에서 &lt;code&gt;swipe.behind&lt;/code&gt; 를 설정 한 다음 컨트롤을 양방향으로 반복해서 스 와이프합니다.</target>
        </trans-unit>
        <trans-unit id="61bedb3305669141647e1f5b49411e374f737ba6" translate="yes" xml:space="preserve">
          <source>When using BlockWithGui, applications must be prepared for reentrancy in any function.</source>
          <target state="translated">BlockWithGui를 사용하는 경우 응용 프로그램은 모든 기능에서 재진입을 위해 준비되어야합니다.</target>
        </trans-unit>
        <trans-unit id="62f4bd548f8779658ed7ed0fc958d3e08e13ec54" translate="yes" xml:space="preserve">
          <source>When using DBus in a peer-to-peer context (i.e., not on a bus), the</source>
          <target state="translated">피어 투 피어 컨텍스트에서 DBus를 사용할 때 (즉, 버스가 아닌)</target>
        </trans-unit>
        <trans-unit id="1050985281b9ecb52ace1f9f25c0094bcb38a505" translate="yes" xml:space="preserve">
          <source>When using PSK, the client must send to the server a valid identity and a valid pre shared key, in order for the SSL handshake to continue. Applications can provide this information in a slot connected to this signal, by filling in the passed</source>
          <target state="translated">PSK를 사용할 때 SSL 핸드 셰이크를 계속하려면 클라이언트가 서버에 유효한 ID와 유효한 사전 공유 키를 보내야합니다. 응용 프로그램은 전달 된 정보를 채워서이 신호에 연결된 슬롯에이 정보를 제공 할 수 있습니다</target>
        </trans-unit>
        <trans-unit id="39ee444b0ae6c83e2b1c9912b7c4bafa58d26ba0" translate="yes" xml:space="preserve">
          <source>When using PSK, the client must send to the server a valid identity and a valid pre shared key, in order for the TLS handshake to continue. Applications can provide this information in a slot connected to this signal, by filling in the passed</source>
          <target state="translated">PSK를 사용하는 경우 TLS 핸드 셰이크를 계속하려면 클라이언트가 서버에 유효한 ID와 유효한 사전 공유 키를 보내야합니다. 어플리케이션은 전달 된 정보를 채워이 신호에 연결된 슬롯에이 정보를 제공 할 수 있습니다</target>
        </trans-unit>
        <trans-unit id="255f0d84a345be8b50ad54e3ccc3e16895694fac" translate="yes" xml:space="preserve">
          <source>When using Qt Assistant as the help browser for an application, it should be possible to customize it to fit the application better, so that it does not look like an independent, standalone help browser. To achieve this, several additional properties can be set in a Qt help collection file, to change for example the title or application icon of Qt Assistant. For more information, see the &lt;a href=&quot;https://doc.qt.io/qt-5.13/qtassistant-index.html&quot;&gt;Qt Assistant Manual&lt;/a&gt;.</source>
          <target state="translated">Qt Assistant를 응용 프로그램의 도움말 브라우저로 사용하는 경우 독립형 독립형 도움말 브라우저처럼 보이지 않도록 응용 프로그램에 더 잘 맞게 사용자 정의 할 수 있어야합니다. 이를 위해 Qt 지원 모음 파일에 몇 가지 추가 속성을 설정하여 Qt Assistant의 제목 또는 응용 프로그램 아이콘 등을 변경할 수 있습니다. 자세한 내용은 &lt;a href=&quot;https://doc.qt.io/qt-5.13/qtassistant-index.html&quot;&gt;Qt Assistant 매뉴얼을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="18dc1be3da1b58f61947b20badaafabb7fb35324" translate="yes" xml:space="preserve">
          <source>When using Qt Virtual Keyboard in a &lt;a href=&quot;qquickwidget&quot;&gt;QQuickWidget&lt;/a&gt; on a touch device, it is necessary to set the &lt;a href=&quot;qt#WidgetAttribute-enum&quot;&gt;Qt::WA_AcceptTouchEvents&lt;/a&gt; attribute via &lt;a href=&quot;qwidget#setAttribute&quot;&gt;QWidget::setAttribute&lt;/a&gt;(). Without this attribute set, events from a touch device will be converted into synthesized mouse events.</source>
          <target state="translated">터치 장치 의 &lt;a href=&quot;qquickwidget&quot;&gt;QQuickWidget&lt;/a&gt; 에서 Qt 가상 키보드를 사용하는 경우 &lt;a href=&quot;qwidget#setAttribute&quot;&gt;QWidget :: setAttribute&lt;/a&gt; () 를 통해 &lt;a href=&quot;qt#WidgetAttribute-enum&quot;&gt;Qt :: WA_AcceptTouchEvents&lt;/a&gt; 속성 을 설정해야합니다 . 이 속성을 설정하지 않으면 터치 장치의 이벤트가 합성 된 마우스 이벤트로 변환됩니다.</target>
        </trans-unit>
        <trans-unit id="59ae4dd2c93a30c9950ccf14f13424ea63eff467" translate="yes" xml:space="preserve">
          <source>When using RAII instead:</source>
          <target state="translated">RAII를 대신 사용하는 경우 :</target>
        </trans-unit>
        <trans-unit id="e422bafae46d9dd9ccf967b028eb5668db1686e3" translate="yes" xml:space="preserve">
          <source>When using Shape, it is important to be aware of potential performance implications:</source>
          <target state="translated">Shape를 사용할 때 잠재적 인 성능 영향을 알고 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="a851e0e65e59f989e18111dd9dfcb0d6119a5f48" translate="yes" xml:space="preserve">
          <source>When using a &lt;a href=&quot;qmessagebox&quot;&gt;QMessageBox&lt;/a&gt; with standard buttons, this function returns a &lt;a href=&quot;qmessagebox#StandardButton-enum&quot;&gt;StandardButton&lt;/a&gt; value indicating the standard button that was clicked. When using &lt;a href=&quot;qmessagebox&quot;&gt;QMessageBox&lt;/a&gt; with custom buttons, this function returns an opaque value; use &lt;a href=&quot;qmessagebox#clickedButton&quot;&gt;clickedButton&lt;/a&gt;() to determine which button was clicked.</source>
          <target state="translated">표준 버튼과 함께 &lt;a href=&quot;qmessagebox&quot;&gt;QMessageBox&lt;/a&gt; 를 사용하는 경우이 함수 는 클릭 한 표준 버튼을 나타내는 &lt;a href=&quot;qmessagebox#StandardButton-enum&quot;&gt;StandardButton&lt;/a&gt; 값을 반환합니다 . 사용자 정의 버튼과 함께 &lt;a href=&quot;qmessagebox&quot;&gt;QMessageBox&lt;/a&gt; 를 사용하는 경우이 함수는 불투명 한 값을 반환합니다. &lt;a href=&quot;qmessagebox#clickedButton&quot;&gt;clickedButton&lt;/a&gt; ()을 사용하여 클릭 한 버튼을 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="30651043e9ed73a939b318e30f3870f1b9b5bc98" translate="yes" xml:space="preserve">
          <source>When using a &lt;a href=&quot;qpropertyanimation&quot;&gt;QPropertyAnimation&lt;/a&gt;, the associated easing curve will be used to control the progress of the interpolation between startValue and endValue:</source>
          <target state="translated">&lt;a href=&quot;qpropertyanimation&quot;&gt;QPropertyAnimation을&lt;/a&gt; 사용할 때 관련된 여유 곡선을 사용하여 startValue와 endValue 사이의 보간 진행률을 제어합니다.</target>
        </trans-unit>
        <trans-unit id="5a31447cc9a9078502d4a9e972623e7f14cea339" translate="yes" xml:space="preserve">
          <source>When using a &lt;a href=&quot;qquickrendercontrol&quot;&gt;QQuickRenderControl&lt;/a&gt; to render a Qt Quick user interface to an OpenGL surface, the &lt;a href=&quot;qml-qtwebengine-webengineview&quot;&gt;WebEngineView&lt;/a&gt; type is not rendered correctly. The web engine view attempts to use a global OpenGL context created by &lt;a href=&quot;qtwebengine#initialize&quot;&gt;QtWebEngine::initialize&lt;/a&gt;, but there is no public API for accessing that context in order to share it with the &lt;code&gt;QQuickRenderControl&lt;/code&gt; context.</source>
          <target state="translated">사용하는 경우 &lt;a href=&quot;qquickrendercontrol&quot;&gt;QQuickRenderControl을&lt;/a&gt; OpenGL은 표면에 Qt는 빠른 사용자 인터페이스를 렌더링의 &lt;a href=&quot;qml-qtwebengine-webengineview&quot;&gt;WebEngineView의&lt;/a&gt; 유형은 제대로 렌더링되지 않습니다. 웹 엔진보기는 &lt;a href=&quot;qtwebengine#initialize&quot;&gt;QtWebEngine :: initialize에&lt;/a&gt; 의해 작성된 글로벌 OpenGL 컨텍스트를 사용하려고 시도 하지만 &lt;code&gt;QQuickRenderControl&lt;/code&gt; 컨텍스트 와 공유하기 위해 해당 컨텍스트에 액세스하기위한 공용 API는 없습니다 .</target>
        </trans-unit>
        <trans-unit id="60e200581fc9c0dbc0f625c7881a7ac6d7e373bc" translate="yes" xml:space="preserve">
          <source>When using a &lt;a href=&quot;qquickrendercontrol&quot;&gt;QQuickRenderControl&lt;/a&gt;, the &lt;a href=&quot;qquickwindow&quot;&gt;QQuickWindow&lt;/a&gt; does not have to be shown or even created at all. This means there will not be an underlying native window for it. Instead, the &lt;a href=&quot;qquickwindow&quot;&gt;QQuickWindow&lt;/a&gt; instance is associated with the render control, using the overload of the &lt;a href=&quot;qquickwindow&quot;&gt;QQuickWindow&lt;/a&gt; constructor, and an OpenGL framebuffer object by calling &lt;a href=&quot;qquickwindow#setRenderTarget&quot;&gt;QQuickWindow::setRenderTarget&lt;/a&gt;().</source>
          <target state="translated">사용하는 경우 &lt;a href=&quot;qquickrendercontrol&quot;&gt;QQuickRenderControl을&lt;/a&gt; 의 &lt;a href=&quot;qquickwindow&quot;&gt;QQuickWindow는&lt;/a&gt; 표시하거나 전혀 생성 할 필요가 없습니다. 이것은 기본 윈도우가 없다는 것을 의미합니다. 대신 &lt;a href=&quot;qquickwindow&quot;&gt;QQuickWindow&lt;/a&gt; 인스턴스는 &lt;a href=&quot;qquickwindow&quot;&gt;QQuickWindow&lt;/a&gt; 생성자 오버로드 와 &lt;a href=&quot;qquickwindow#setRenderTarget&quot;&gt;QQuickWindow :: setRenderTarget&lt;/a&gt; () 을 호출하여 OpenGL framebuffer 객체를 사용하여 렌더링 컨트롤과 연결됩니다 .</target>
        </trans-unit>
        <trans-unit id="9c0f7af3daf2a24d712370fbb31d193c69bdb078" translate="yes" xml:space="preserve">
          <source>When using a &lt;a href=&quot;qsortfilterproxymodel&quot;&gt;QSortFilterProxyModel&lt;/a&gt;, its indexes have their own internal pointer. It is not advisable to access this internal pointer outside of the model. Use the &lt;a href=&quot;qabstractitemmodel#data&quot;&gt;data&lt;/a&gt;() function instead.</source>
          <target state="translated">&lt;a href=&quot;qsortfilterproxymodel&quot;&gt;QSortFilterProxyModel을&lt;/a&gt; 사용할 때 색인에는 자체 내부 포인터가 있습니다. 모델 외부에서이 내부 포인터에 액세스하는 것은 좋지 않습니다. 사용 &lt;a href=&quot;qabstractitemmodel#data&quot;&gt;데이터&lt;/a&gt; 대신 () 함수를.</target>
        </trans-unit>
        <trans-unit id="cd633ea15d629a0822189477ace7c2e694f5b907" translate="yes" xml:space="preserve">
          <source>When using a camera, there are several times when some form of feedback to the user is given - for example, when an image is taken, or when recording is started. You can enable or disable some of this feedback, or adjust what sound might be played for these actions.</source>
          <target state="translated">카메라를 사용할 때 이미지가 촬영되거나 녹화가 시작되는 등 사용자에게 어떤 형태의 피드백이 제공 될 때가 여러 번 있습니다. 이 피드백 중 일부를 활성화 또는 비활성화하거나 이러한 동작에 대해 재생할 사운드를 조정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="57ef1cc43a22d3ee9d7ad2ec71b8d3288bb14e4d" translate="yes" xml:space="preserve">
          <source>When using a generator the data will be loaded asynchronously in a job. The loaded data can be read back if the &lt;a href=&quot;qt3drender-qbuffer#syncData-prop&quot;&gt;QBuffer::syncData&lt;/a&gt; flag is set to true.</source>
          <target state="translated">생성기를 사용할 때 데이터가 작업에 비동기 적으로로드됩니다. &lt;a href=&quot;qt3drender-qbuffer#syncData-prop&quot;&gt;QBuffer :: syncData&lt;/a&gt; 플래그가 true로 설정된 경우로드 된 데이터를 다시 읽을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="4a99ea3d9c74b7bdbe4f19c498b2969932d3fbb5" translate="yes" xml:space="preserve">
          <source>When using a link-local or site-local address for IPv6 connections, you must specify the scope ID. The scope ID for a link-local address is usually the same as the interface name (e.g., &quot;eth0&quot;, &quot;en1&quot;) or number (e.g., &quot;1&quot;, &quot;2&quot;).</source>
          <target state="translated">IPv6 연결에 링크 로컬 또는 사이트 로컬 주소를 사용하는 경우 범위 ID를 지정해야합니다. 링크 로컬 주소의 범위 ID는 일반적으로 인터페이스 이름 (예 : &quot;eth0&quot;, &quot;en1&quot;) 또는 숫자 (예 : &quot;1&quot;, &quot;2&quot;)와 동일합니다.</target>
        </trans-unit>
        <trans-unit id="a7f5a0c47b510324b9693fda936ac9e1340194e1" translate="yes" xml:space="preserve">
          <source>When using a local connection, a unique name must be used. For tcp connections, a unique address and port number combination much be used.</source>
          <target state="translated">로컬 연결을 사용할 때는 고유 한 이름을 사용해야합니다. TCP 연결의 경우 고유 한 주소와 포트 번호 조합이 많이 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="c2f9377446ae02ec808861ff5dcc31b378366901" translate="yes" xml:space="preserve">
          <source>When using a non-attached &lt;a href=&quot;qml-qtquick-controls2-scrollbar&quot;&gt;ScrollBar&lt;/a&gt;, the following must be done manually:</source>
          <target state="translated">첨부되지 않은 &lt;a href=&quot;qml-qtquick-controls2-scrollbar&quot;&gt;ScrollBar를&lt;/a&gt; 사용하는 경우 다음을 수동으로 수행해야합니다.</target>
        </trans-unit>
        <trans-unit id="54441c60f964e66b066ac92b3af3ac7719c4b710" translate="yes" xml:space="preserve">
          <source>When using a scroll area to display the contents of a custom widget, it is important to ensure that the &lt;a href=&quot;qwidget#sizeHint-prop&quot;&gt;size hint&lt;/a&gt; of the child widget is set to a suitable value. If a standard &lt;a href=&quot;qwidget&quot;&gt;QWidget&lt;/a&gt; is used for the child widget, it may be necessary to call &lt;a href=&quot;qwidget#minimumSize-prop&quot;&gt;QWidget::setMinimumSize&lt;/a&gt;() to ensure that the contents of the widget are shown correctly within the scroll area.</source>
          <target state="translated">스크롤 영역을 사용하여 사용자 정의 위젯의 컨텐츠를 표시 할 때 하위 위젯 의 &lt;a href=&quot;qwidget#sizeHint-prop&quot;&gt;크기 힌트&lt;/a&gt; 가 적절한 값으로 설정되어 있는지 확인하는 것이 중요 합니다. 하위 위젯에 표준 &lt;a href=&quot;qwidget&quot;&gt;QWidget&lt;/a&gt; 을 사용하는 경우 위젯 컨텐츠가 스크롤 영역 내에 올바르게 표시되도록 &lt;a href=&quot;qwidget#minimumSize-prop&quot;&gt;QWidget :: setMinimumSize&lt;/a&gt; ()를 호출해야 할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="237a8500ee38265470768b77eb9c5ecf303eea63" translate="yes" xml:space="preserve">
          <source>When using an &lt;a href=&quot;qpainter#RenderHint-enum&quot;&gt;anti-aliased&lt;/a&gt; painter, the boundary line of a &lt;a href=&quot;qrect&quot;&gt;QRect&lt;/a&gt; will be rendered symmetrically on both sides of the mathematical rectangle's boundary line. But when using an aliased painter (the default) other rules apply.</source>
          <target state="translated">&lt;a href=&quot;qpainter#RenderHint-enum&quot;&gt;앤티 앨리어싱 된&lt;/a&gt; 페인터를 사용하는 경우 &lt;a href=&quot;qrect&quot;&gt;QRect&lt;/a&gt; 의 경계선은 수학 사각형의 경계선 양쪽에 대칭으로 렌더링됩니다. 그러나 별명을 사용하는 화가 (기본값)를 사용하는 경우 다른 규칙이 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="f114b9cf2bdf5128d5944856498efe44e97fd95c" translate="yes" xml:space="preserve">
          <source>When using an &lt;a href=&quot;qpainter#RenderHint-enum&quot;&gt;anti-aliased&lt;/a&gt; painter, the boundary line of a &lt;a href=&quot;qrectf&quot;&gt;QRectF&lt;/a&gt; will be rendered symmetrically on both sides of the mathematical rectangle's boundary line. But when using an aliased painter (the default) other rules apply.</source>
          <target state="translated">&lt;a href=&quot;qpainter#RenderHint-enum&quot;&gt;앤티 앨리어싱 된&lt;/a&gt; 페인터를 사용하는 경우 &lt;a href=&quot;qrectf&quot;&gt;QRectF&lt;/a&gt; 의 경계선은 수학 사각형의 경계선 양쪽에 대칭으로 렌더링됩니다. 그러나 별명을 사용하는 화가 (기본값)를 사용하는 경우 다른 규칙이 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="8f28cb22408509ba937d73e207cf823f044e3c30" translate="yes" xml:space="preserve">
          <source>When using enum classes, there can be multiple enums using the same identifiers. The unscoped registration will be overwriten by the last registered enum. For classes that contain such name conficts it is possible to disable the unscoped registration by annotating your class with a special &lt;a href=&quot;qobject#Q_CLASSINFO&quot;&gt;Q_CLASSINFO&lt;/a&gt; macro. Use the name &lt;code&gt;RegisterEnumClassesUnscoped&lt;/code&gt; with the value &lt;code&gt;false&lt;/code&gt; to prevent scoped enums from being merged into the same name space.</source>
          <target state="translated">열거 형 클래스를 사용할 때 동일한 식별자를 사용하는 여러 열거 형이있을 수 있습니다. 범위가 지정되지 않은 등록은 마지막으로 등록 된 열거 형으로 덮어 씁니다. 이러한 이름이 포함 된 클래스의 경우 특수 &lt;a href=&quot;qobject#Q_CLASSINFO&quot;&gt;Q_CLASSINFO&lt;/a&gt; 매크로로 클래스에 주석을 달아 범위가 지정되지 않은 등록을 비활성화 할 수 있습니다 . 범위가 지정된 열거가 동일한 이름 공간에 병합되지 않도록 이름 &lt;code&gt;RegisterEnumClassesUnscoped&lt;/code&gt; 를 &lt;code&gt;false&lt;/code&gt; 값과 함께 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="b3126c9de4f125026d9844406caca004b124783e" translate="yes" xml:space="preserve">
          <source>When using files with relative paths, the path should be relative to the file where &lt;a href=&quot;qml-qtqml-qt#createComponent-method&quot;&gt;Qt.createComponent()&lt;/a&gt; is executed.</source>
          <target state="translated">상대 경로가있는 파일을 사용할 때 경로는 &lt;a href=&quot;qml-qtqml-qt#createComponent-method&quot;&gt;Qt.createComponent ()&lt;/a&gt; 가 실행되는 파일에 상대적인 경로 여야합니다 .</target>
        </trans-unit>
        <trans-unit id="f5f60225ff679f2aec3bcaa7f21687a9cdf848c4" translate="yes" xml:space="preserve">
          <source>When using models that have multiple named roles, &lt;a href=&quot;qml-qtquick-controls2-combobox&quot;&gt;ComboBox&lt;/a&gt; must be configured to use a specific &lt;a href=&quot;qml-qtquick-controls2-combobox#textRole-prop&quot;&gt;text role&lt;/a&gt; for its &lt;a href=&quot;qml-qtquick-controls2-combobox#displayText-prop&quot;&gt;display text&lt;/a&gt; and &lt;a href=&quot;https://doc.qt.io/qt-5.13/qtquickcontrols-chattutorial-example.html#delegate&quot;&gt;delegate&lt;/a&gt; instances.</source>
          <target state="translated">명명 된 여러 역할이 모델을 사용하는 경우, &lt;a href=&quot;qml-qtquick-controls2-combobox&quot;&gt;콤보는&lt;/a&gt; 특정의 사용하도록 구성해야합니다 &lt;a href=&quot;qml-qtquick-controls2-combobox#textRole-prop&quot;&gt;텍스트 역할을&lt;/a&gt; 자사에 대한 &lt;a href=&quot;qml-qtquick-controls2-combobox#displayText-prop&quot;&gt;표시 텍스트&lt;/a&gt; 및 &lt;a href=&quot;https://doc.qt.io/qt-5.13/qtquickcontrols-chattutorial-example.html#delegate&quot;&gt;위임&lt;/a&gt; 인스턴스.</target>
        </trans-unit>
        <trans-unit id="84026de8d0a3f70ccf99a3d61c901fae1dc693fe" translate="yes" xml:space="preserve">
          <source>When using more than one parameter, or when an argument contains whitespace, enclose each argument in braces:</source>
          <target state="translated">둘 이상의 매개 변수를 사용하거나 인수에 공백이 포함 된 경우 각 인수를 중괄호로 묶습니다.</target>
        </trans-unit>
        <trans-unit id="c02b1287c2c05e3b9d628e626b4034e4caa62387" translate="yes" xml:space="preserve">
          <source>When using multiple containers, such as &lt;a href=&quot;qtquickcontrols2-navigation#tabbar&quot;&gt;TabBar&lt;/a&gt; and &lt;a href=&quot;qml-qtquick-controls2-swipeview&quot;&gt;SwipeView&lt;/a&gt;, together, their &lt;a href=&quot;qml-qtquick-controls2-container#currentIndex-prop&quot;&gt;currentIndex&lt;/a&gt; properties can be bound to each other to keep them in sync. When the user interacts with either container, its current index changes automatically propagate to the other container.</source>
          <target state="translated">&lt;a href=&quot;qtquickcontrols2-navigation#tabbar&quot;&gt;TabBar&lt;/a&gt; 및 &lt;a href=&quot;qml-qtquick-controls2-swipeview&quot;&gt;SwipeView&lt;/a&gt; 와 같은 여러 컨테이너를 함께 사용하는 경우 &lt;a href=&quot;qml-qtquick-controls2-container#currentIndex-prop&quot;&gt;currentIndex&lt;/a&gt; 속성을 서로 바인딩하여 동기화 상태를 유지할 수 있습니다. 사용자가 컨테이너 중 하나와 상호 작용하면 현재 색인 변경 사항이 다른 컨테이너에 자동으로 전파됩니다.</target>
        </trans-unit>
        <trans-unit id="641175720b4c0c2ab3449cc419129333b3bfdd72" translate="yes" xml:space="preserve">
          <source>When using one of the default names, you can call this function in &lt;a href=&quot;qaccessibleactioninterface&quot;&gt;QAccessibleActionInterface&lt;/a&gt; to get the localized string.</source>
          <target state="translated">기본 이름 중 하나를 사용하는 경우 &lt;a href=&quot;qaccessibleactioninterface&quot;&gt;QAccessibleActionInterface&lt;/a&gt; 에서이 함수를 호출 하여 현지화 된 문자열을 얻을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f1d4042297fd9e70e9779d429f6a3c3de84a9661" translate="yes" xml:space="preserve">
          <source>When using qmake to build just the Qt WebEngine module, the following command can be used (in this example, the Qt WebEngine source code is located in &lt;code&gt;C:\qt\qtwebengine&lt;/code&gt;):</source>
          <target state="translated">qmake를 사용하여 Qt WebEngine 모듈 만 빌드 할 때 다음 명령을 사용할 수 있습니다 (이 예에서 Qt WebEngine 소스 코드는 &lt;code&gt;C:\qt\qtwebengine&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="eed4f78c25ca0fa8144d6414eb478fa129284fb5" translate="yes" xml:space="preserve">
          <source>When using signals and slots with multiple threads, see &lt;a href=&quot;threads-qobject#signals-and-slots-across-threads&quot;&gt;Signals and Slots Across Threads&lt;/a&gt;.</source>
          <target state="translated">스레드가 여러 개인 신호 및 슬롯을 사용하는 경우 스레드 &lt;a href=&quot;threads-qobject#signals-and-slots-across-threads&quot;&gt;간 신호 및 슬롯을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="e7ad568fc4f11eefe9c8b40e9b450dc9cb930b9a" translate="yes" xml:space="preserve">
          <source>When using style sheets, every widget is treated as a box with four concentric rectangles: the margin rectangle, the border rectangle, the padding rectangle, and the content rectangle. The box model describes this in further detail.</source>
          <target state="translated">스타일 시트를 사용할 때 모든 위젯은 여백 사각형, 테두리 사각형, 패딩 사각형 및 내용 사각형의 네 개의 동심 사각형이있는 상자로 처리됩니다. 박스 모델은이를 자세히 설명합니다.</target>
        </trans-unit>
        <trans-unit id="16c96094aa814c7a1c7563b4a9f7232f4480180a" translate="yes" xml:space="preserve">
          <source>When using the &quot;IJW&quot; method, in principle the only limitation is the time required to write the wrapper classes and data type conversion functions.</source>
          <target state="translated">&quot;IJW&quot;메소드를 사용할 때 원칙적으로 유일한 제한 사항은 랩퍼 클래스 및 데이터 유형 변환 함수를 작성하는 데 필요한 시간입니다.</target>
        </trans-unit>
        <trans-unit id="5d54c37317bd3e6ec2902ccadabbc8a4e682a663" translate="yes" xml:space="preserve">
          <source>When using the &lt;a href=&quot;https://doc.qt.io/qt-5.13/qtwebengine-overview.html#qt-webengine-widgets-module&quot;&gt;Qt WebEngine Widgets Module&lt;/a&gt;, &lt;a href=&quot;qwebenginepage#acceptNavigationRequest&quot;&gt;QWebEnginePage::acceptNavigationRequest&lt;/a&gt;() offers further options to accept or block requests.</source>
          <target state="translated">사용하는 경우 &lt;a href=&quot;https://doc.qt.io/qt-5.13/qtwebengine-overview.html#qt-webengine-widgets-module&quot;&gt;Qt는 WebEngine 위젯 모듈&lt;/a&gt; , &lt;a href=&quot;qwebenginepage#acceptNavigationRequest&quot;&gt;QWebEnginePage :: acceptNavigationRequest&lt;/a&gt; () 이벤트 추가 옵션을 수락 또는 블록 요청합니다.</target>
        </trans-unit>
        <trans-unit id="8ef195bdee4cf1c4a71bf9effed3c312e0927143" translate="yes" xml:space="preserve">
          <source>When using the &lt;code&gt;QtQuick&lt;/code&gt; module, you will need to know how to write QML applications using the QML language. In particular, QML Basics and QML Essentials from the &lt;a href=&quot;qmlapplications&quot;&gt;QML Applications&lt;/a&gt; page.</source>
          <target state="translated">사용하는 경우 &lt;code&gt;QtQuick&lt;/code&gt; 의 모듈을, 당신은 QML 언어를 사용하여 QML 애플리케이션을 작성하는 방법을 알아야합니다. 특히 &lt;a href=&quot;qmlapplications&quot;&gt;QML Applications&lt;/a&gt; 페이지 의 QML Basics 및 QML Essentials .</target>
        </trans-unit>
        <trans-unit id="9dec366696ef07cbdd46b7724c483ed995ac86b0" translate="yes" xml:space="preserve">
          <source>When using the &lt;code&gt;lib&lt;/code&gt; template, the following options can be added to the &lt;a href=&quot;qmake-variable-reference#config&quot;&gt;CONFIG&lt;/a&gt; variable to determine the type of library that is built:</source>
          <target state="translated">&lt;code&gt;lib&lt;/code&gt; 템플리트를 사용할 때 다음 옵션을 &lt;a href=&quot;qmake-variable-reference#config&quot;&gt;CONFIG&lt;/a&gt; 변수에 추가하여 빌드 된 라이브러리 유형을 판별 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="1accbb909d9654643b1007c4b005eaf944aacb54" translate="yes" xml:space="preserve">
          <source>When using the &lt;code&gt;subdirs&lt;/code&gt; template, this option specifies that the directories listed should be processed in the order in which they are given.</source>
          <target state="translated">사용하는 경우 &lt;code&gt;subdirs&lt;/code&gt; 템플릿을 디렉토리 나열이 옵션의 지정은 주어진 순서대로 처리해야한다.</target>
        </trans-unit>
        <trans-unit id="9302e4403ba3d658ded6f72d8e2eb9b0d3b0d85a" translate="yes" xml:space="preserve">
          <source>When using the OpenGL adaptation, the returned texture will be using &lt;code&gt;GL_TEXTURE_2D&lt;/code&gt; as texture target and &lt;code&gt;GL_RGBA&lt;/code&gt; as internal format. Reimplement &lt;a href=&quot;qsgtexture&quot;&gt;QSGTexture&lt;/a&gt; to create textures with different parameters.</source>
          <target state="translated">OpenGL 적응을 사용할 때 반환 된 텍스처는 &lt;code&gt;GL_TEXTURE_2D&lt;/code&gt; 를 텍스처 대상으로 사용하고 &lt;code&gt;GL_RGBA&lt;/code&gt; 를 내부 형식으로 사용합니다. &lt;a href=&quot;qsgtexture&quot;&gt;QSGTexture&lt;/a&gt; 를 다시 구현 하여 다른 매개 변수로 텍스처를 만듭니다.</target>
        </trans-unit>
        <trans-unit id="5f5b2c24ae4c28b1f7b4b66c98b3d23e3e684245" translate="yes" xml:space="preserve">
          <source>When using the Qt Purchasing API in QML, the application should instantiate one Store and then instantiate products as children of this store. The products created as children of the Store object will automatically be queried from the external market place if one is available on the current platform.</source>
          <target state="translated">QML에서 Qt Purchasing API를 사용하는 경우 애플리케이션은 하나의 상점을 인스턴스화 한 후 제품을이 상점의 하위로 인스턴스화해야합니다. 상점 오브젝트의 하위로 작성된 제품은 현재 플랫폼에서 사용 가능한 경우 외부 마켓 플레이스에서 자동으로 조회됩니다.</target>
        </trans-unit>
        <trans-unit id="c520b2944e06b29e0ffe182f18017f3df7a8cce9" translate="yes" xml:space="preserve">
          <source>When using the SAP HANA database, the connection has to be established using the option &quot;SCROLLABLERESULT=TRUE&quot;, as the HANA ODBC driver does not provide scrollable results by default, e.g.:</source>
          <target state="translated">SAP HANA 데이터베이스를 사용하는 경우 HANA ODBC 드라이버는 기본적으로 스크롤 가능한 결과를 제공하지 않으므로 &quot;SCROLLABLERESULT = TRUE&quot;옵션을 사용하여 연결을 설정해야합니다.</target>
        </trans-unit>
        <trans-unit id="f6512b3be0d117dfa21e663e8a3f57fcd47481b4" translate="yes" xml:space="preserve">
          <source>When using the attached property &lt;a href=&quot;qml-qtquick-layoutmirroring#enabled-prop&quot;&gt;LayoutMirroring::enabled&lt;/a&gt; for locale layouts, the visual layout direction of the grid positioner will be mirrored. However, the property &lt;a href=&quot;qml-qtquick-flow#layoutDirection-prop&quot;&gt;layoutDirection&lt;/a&gt; will remain unchanged.</source>
          <target state="translated">로케일 레이아웃에 첨부 된 &lt;a href=&quot;qml-qtquick-layoutmirroring#enabled-prop&quot;&gt;LayoutMirroring :: enabled&lt;/a&gt; 특성을 사용하면 그리드 포지셔너의 시각적 레이아웃 방향이 미러링됩니다. 그러나 &lt;a href=&quot;qml-qtquick-flow#layoutDirection-prop&quot;&gt;layoutDirection&lt;/a&gt; 속성 은 변경되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="ad819fcb35bbe53948b4887616213f681fcff7f9" translate="yes" xml:space="preserve">
          <source>When using the attached property &lt;a href=&quot;qml-qtquick-layoutmirroring#enabled-prop&quot;&gt;LayoutMirroring::enabled&lt;/a&gt; for locale layouts, the visual layout direction of the grid positioner will be mirrored. However, the property &lt;a href=&quot;qml-qtquick-grid#layoutDirection-prop&quot;&gt;layoutDirection&lt;/a&gt; will remain unchanged.</source>
          <target state="translated">로케일 레이아웃에 첨부 된 &lt;a href=&quot;qml-qtquick-layoutmirroring#enabled-prop&quot;&gt;LayoutMirroring :: enabled&lt;/a&gt; 특성을 사용하면 그리드 포지셔너의 시각적 레이아웃 방향이 미러링됩니다. 그러나 &lt;a href=&quot;qml-qtquick-grid#layoutDirection-prop&quot;&gt;layoutDirection&lt;/a&gt; 속성 은 변경되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="f834cbf23f423046bd6a4e706aba1ff65a30a170" translate="yes" xml:space="preserve">
          <source>When using the attached property &lt;a href=&quot;qml-qtquick-layoutmirroring#enabled-prop&quot;&gt;LayoutMirroring::enabled&lt;/a&gt; for locale layouts, the visual layout direction of the grid will be mirrored. However, the property &lt;a href=&quot;qml-qtquick-gridview#layoutDirection-prop&quot;&gt;layoutDirection&lt;/a&gt; will remain unchanged.</source>
          <target state="translated">로케일 레이아웃에 첨부 된 &lt;a href=&quot;qml-qtquick-layoutmirroring#enabled-prop&quot;&gt;LayoutMirroring :: enabled&lt;/a&gt; 특성을 사용 하면 그리드의 시각적 레이아웃 방향이 미러링됩니다. 그러나 &lt;a href=&quot;qml-qtquick-gridview#layoutDirection-prop&quot;&gt;layoutDirection&lt;/a&gt; 속성 은 변경되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="f36c0ab165b9200f9ec8aa1357d728964f40f2cc" translate="yes" xml:space="preserve">
          <source>When using the attached property &lt;a href=&quot;qml-qtquick-layoutmirroring#enabled-prop&quot;&gt;LayoutMirroring::enabled&lt;/a&gt; for locale layouts, the visual layout direction of the horizontal list will be mirrored. However, the property &lt;a href=&quot;qml-qtquick-listview#layoutDirection-prop&quot;&gt;layoutDirection&lt;/a&gt; will remain unchanged.</source>
          <target state="translated">로캘 레이아웃에 연결된 속성 &lt;a href=&quot;qml-qtquick-layoutmirroring#enabled-prop&quot;&gt;LayoutMirroring :: enabled&lt;/a&gt; 를 사용 하면 가로 목록의 시각적 레이아웃 방향이 미러링됩니다. 그러나 &lt;a href=&quot;qml-qtquick-listview#layoutDirection-prop&quot;&gt;layoutDirection&lt;/a&gt; 속성 은 변경되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="fb66c1b45ac982beb02c022093529fd3f56e9448" translate="yes" xml:space="preserve">
          <source>When using the attached property &lt;a href=&quot;qml-qtquick-layoutmirroring#enabled-prop&quot;&gt;LayoutMirroring::enabled&lt;/a&gt; for locale layouts, the visual layout direction of the row positioner will be mirrored. However, the property &lt;a href=&quot;qml-qtquick-row#layoutDirection-prop&quot;&gt;layoutDirection&lt;/a&gt; will remain unchanged.</source>
          <target state="translated">로케일 레이아웃에 연결된 속성 &lt;a href=&quot;qml-qtquick-layoutmirroring#enabled-prop&quot;&gt;LayoutMirroring :: enabled&lt;/a&gt; 를 사용 하면 행 포지셔너의 시각적 레이아웃 방향이 미러링됩니다. 그러나 &lt;a href=&quot;qml-qtquick-row#layoutDirection-prop&quot;&gt;layoutDirection&lt;/a&gt; 속성 은 변경되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="69d87d4ee077dc734724b86f9fa8e15d248506e7" translate="yes" xml:space="preserve">
          <source>When using the attached property &lt;a href=&quot;qml-qtquick-layoutmirroring#enabled-prop&quot;&gt;LayoutMirroring::enabled&lt;/a&gt; to mirror application layouts, the horizontal alignment of text will also be mirrored. However, the property &lt;code&gt;horizontalAlignment&lt;/code&gt; will remain unchanged. To query the effective horizontal alignment of &lt;a href=&quot;qml-qtquick-controls-textarea&quot;&gt;TextArea&lt;/a&gt;, use the read-only property &lt;code&gt;effectiveHorizontalAlignment&lt;/code&gt;.</source>
          <target state="translated">첨부 된 속성 &lt;a href=&quot;qml-qtquick-layoutmirroring#enabled-prop&quot;&gt;LayoutMirroring :: enabled&lt;/a&gt; 를 사용 하여 응용 프로그램 레이아웃을 미러링하면 텍스트의 가로 정렬도 미러링됩니다. 그러나 &lt;code&gt;horizontalAlignment&lt;/code&gt; 속성 은 변경되지 않습니다. &lt;a href=&quot;qml-qtquick-controls-textarea&quot;&gt;TextArea&lt;/a&gt; 의 효과적인 가로 정렬을 쿼리하려면 읽기 전용 속성 인 &lt;code&gt;effectiveHorizontalAlignment&lt;/code&gt; 를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="d651e972a8b73ac33b7c1d33d8d380ac2eceec38" translate="yes" xml:space="preserve">
          <source>When using the attached property &lt;a href=&quot;qml-qtquick-layoutmirroring#enabled-prop&quot;&gt;LayoutMirroring::enabled&lt;/a&gt; to mirror application layouts, the horizontal alignment of text will also be mirrored. However, the property &lt;code&gt;horizontalAlignment&lt;/code&gt; will remain unchanged. To query the effective horizontal alignment of &lt;a href=&quot;qml-qtquick-textedit&quot;&gt;TextEdit&lt;/a&gt;, use the read-only property &lt;code&gt;effectiveHorizontalAlignment&lt;/code&gt;.</source>
          <target state="translated">첨부 된 속성 &lt;a href=&quot;qml-qtquick-layoutmirroring#enabled-prop&quot;&gt;LayoutMirroring :: enabled&lt;/a&gt; 를 사용 하여 응용 프로그램 레이아웃을 미러링하면 텍스트의 가로 정렬도 미러링됩니다. 그러나 &lt;code&gt;horizontalAlignment&lt;/code&gt; 속성 은 변경되지 않습니다. &lt;a href=&quot;qml-qtquick-textedit&quot;&gt;TextEdit&lt;/a&gt; 의 효과적인 가로 정렬을 쿼리하려면 읽기 전용 속성 인 &lt;code&gt;effectiveHorizontalAlignment&lt;/code&gt; 를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="35d324bfc12c5d6ba6efc643a3b1dde7d26fce03" translate="yes" xml:space="preserve">
          <source>When using the attached property &lt;a href=&quot;qml-qtquick-layoutmirroring#enabled-prop&quot;&gt;LayoutMirroring::enabled&lt;/a&gt; to mirror application layouts, the horizontal alignment of text will also be mirrored. However, the property &lt;code&gt;horizontalAlignment&lt;/code&gt; will remain unchanged. To query the effective horizontal alignment of &lt;a href=&quot;qml-qtquick-textinput&quot;&gt;TextInput&lt;/a&gt;, use the read-only property &lt;code&gt;effectiveHorizontalAlignment&lt;/code&gt;.</source>
          <target state="translated">첨부 된 속성 &lt;a href=&quot;qml-qtquick-layoutmirroring#enabled-prop&quot;&gt;LayoutMirroring :: enabled&lt;/a&gt; 를 사용 하여 응용 프로그램 레이아웃을 미러링하면 텍스트의 가로 정렬도 미러링됩니다. 그러나 &lt;code&gt;horizontalAlignment&lt;/code&gt; 속성 은 변경되지 않습니다. &lt;a href=&quot;qml-qtquick-textinput&quot;&gt;TextInput&lt;/a&gt; 의 효과적인 가로 정렬을 쿼리하려면 읽기 전용 속성 인 &lt;code&gt;effectiveHorizontalAlignment&lt;/code&gt; 를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="d2b5e6a5d5f5d78d3c5d95616a1f194fccea4c23" translate="yes" xml:space="preserve">
          <source>When using the attached property &lt;a href=&quot;qml-qtquick-layoutmirroring#enabled-prop&quot;&gt;LayoutMirroring::enabled&lt;/a&gt; to mirror application layouts, the horizontal alignment of text will also be mirrored. However, the property &lt;code&gt;horizontalAlignment&lt;/code&gt; will remain unchanged. To query the effective horizontal alignment of Text, use the read-only property &lt;code&gt;effectiveHorizontalAlignment&lt;/code&gt;.</source>
          <target state="translated">첨부 된 속성 &lt;a href=&quot;qml-qtquick-layoutmirroring#enabled-prop&quot;&gt;LayoutMirroring :: enabled&lt;/a&gt; 를 사용 하여 응용 프로그램 레이아웃을 미러링하면 텍스트의 가로 정렬도 미러링됩니다. 그러나 &lt;code&gt;horizontalAlignment&lt;/code&gt; 속성 은 변경되지 않습니다. Text의 효과적인 가로 정렬을 쿼리하려면 읽기 전용 속성 인 &lt;code&gt;effectiveHorizontalAlignment&lt;/code&gt; 를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="20616dd35d75d11331c9fc082c83b9be05505dab" translate="yes" xml:space="preserve">
          <source>When using the attached property, &lt;a href=&quot;qml-qtquick-layoutmirroring#enabled-prop&quot;&gt;LayoutMirroring::enabled&lt;/a&gt;, to mirror application layouts, the horizontal alignment of text will also be mirrored. However, the property &lt;code&gt;horizontalAlignment&lt;/code&gt; will remain unchanged. To query the effective horizontal alignment of &lt;a href=&quot;qml-qtquick-controls-textfield&quot;&gt;TextField&lt;/a&gt;, use the read-only property &lt;code&gt;effectiveHorizontalAlignment&lt;/code&gt;.</source>
          <target state="translated">응용 프로그램 레이아웃을 미러링하기 위해 연결된 속성 인 &lt;a href=&quot;qml-qtquick-layoutmirroring#enabled-prop&quot;&gt;LayoutMirroring :: enabled를 사용&lt;/a&gt; 하면 텍스트의 가로 정렬도 미러링됩니다. 그러나 &lt;code&gt;horizontalAlignment&lt;/code&gt; 속성 은 변경되지 않습니다. &lt;a href=&quot;qml-qtquick-controls-textfield&quot;&gt;TextField&lt;/a&gt; 의 효과적인 가로 정렬을 쿼리하려면 읽기 전용 속성 인 &lt;code&gt;effectiveHorizontalAlignment&lt;/code&gt; 를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="9a3979e0f25e3b5cc70f71695bbc56f938aca359" translate="yes" xml:space="preserve">
          <source>When using the default OpenGL adaptation, it is possible to integrate OpenGL calls directly into the &lt;a href=&quot;qquickwindow&quot;&gt;QQuickWindow&lt;/a&gt; using the same OpenGL context as the Qt Quick Scene Graph. This is done by connecting to the &lt;a href=&quot;qquickwindow#beforeRendering&quot;&gt;QQuickWindow::beforeRendering&lt;/a&gt;() or &lt;a href=&quot;qquickwindow#afterRendering&quot;&gt;QQuickWindow::afterRendering&lt;/a&gt;() signal.</source>
          <target state="translated">기본 OpenGL 적응을 사용하는 경우 Qt 빠른 장면 그래프와 동일한 OpenGL 컨텍스트를 사용하여 OpenGL 호출을 &lt;a href=&quot;qquickwindow&quot;&gt;QQuickWindow에&lt;/a&gt; 직접 통합 할 수 있습니다 . 이는 &lt;a href=&quot;qquickwindow#beforeRendering&quot;&gt;QQuickWindow :: beforeRendering&lt;/a&gt; () 또는 &lt;a href=&quot;qquickwindow#afterRendering&quot;&gt;QQuickWindow :: afterRendering&lt;/a&gt; () 신호 에 연결하여 수행됩니다 .</target>
        </trans-unit>
        <trans-unit id="34f1d72237c8018c967d74b627ccc1dfb27d0ed2" translate="yes" xml:space="preserve">
          <source>When using the provided matrices, the coordinate system for vertex data follows the usual &lt;a href=&quot;qquickitem&quot;&gt;QQuickItem&lt;/a&gt; conventions: top-left is (0, 0), bottom-right is the corresponding &lt;a href=&quot;qquickitem&quot;&gt;QQuickItem&lt;/a&gt;'s width() and height() minus one. For example, assuming a two float (x-y) per vertex coordinate layout, a triangle covering half of the item can be specified as (width - 1, height - 1), (0, 0), (0, height - 1) using counter-clockwise direction.</source>
          <target state="translated">제공된 행렬을 사용할 때 정점 데이터의 좌표계는 일반적인 &lt;a href=&quot;qquickitem&quot;&gt;QQuickItem&lt;/a&gt; 규칙을 따릅니다. 왼쪽 위는 (0, 0), 오른쪽 아래는 해당 &lt;a href=&quot;qquickitem&quot;&gt;QQuickItem&lt;/a&gt; 의 너비 () 및 높이 ()에서 1을 뺀 것입니다. 예를 들어 정점 좌표 레이아웃 당 두 개의 부동 (xy)을 가정하면 항목의 절반을 덮는 삼각형을 (너비-1, 높이-1), (0, 0), (0, 높이-1)로 지정할 수 있습니다. 시계 반대 방향.</target>
        </trans-unit>
        <trans-unit id="9ab3c5753ca173c3d3ab6370d02e203aa5f107b9" translate="yes" xml:space="preserve">
          <source>When using the vcapp template this will put all the source files into the source group and the header files into the header group regardless of what directory they reside in. Turning this option off will group the files within the source/header group depending on the directory they reside. This is turned on by default.</source>
          <target state="translated">vcapp 템플릿을 사용할 때 모든 소스 파일을 소스 그룹에 넣고 헤더 파일을 헤더 그룹에 넣습니다.이 옵션을 끄면 디렉토리에 따라 소스 / 헤더 그룹 내의 파일이 그룹화됩니다. 그들은 거주한다. 이것은 기본적으로 켜져 있습니다.</target>
        </trans-unit>
        <trans-unit id="885cb4ce8dcd663d12b984998a03134539d02bc3" translate="yes" xml:space="preserve">
          <source>When using these functions be aware that they return data in &lt;b&gt;column-major&lt;/b&gt; format:</source>
          <target state="translated">이 함수를 사용할 때는 데이터를 &lt;b&gt;열 주요&lt;/b&gt; 형식으로 반환 합니다.</target>
        </trans-unit>
        <trans-unit id="5f1afdca4aa38b214b00a782de3c5aa53f22b470" translate="yes" xml:space="preserve">
          <source>When using this class, be aware of the following platform differences:</source>
          <target state="translated">이 클래스를 사용할 때는 다음과 같은 플랫폼 차이점을 알고 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="0eb1d67852478a07e0591b585644fc15d3d64036" translate="yes" xml:space="preserve">
          <source>When using this function, one should not call &lt;code&gt;accept()&lt;/code&gt;.</source>
          <target state="translated">이 함수를 사용할 때 &lt;code&gt;accept()&lt;/code&gt; 호출하면 안됩니다 .</target>
        </trans-unit>
        <trans-unit id="a04c05a9070969e9eb67d44a8928461707a0a965" translate="yes" xml:space="preserve">
          <source>When using this method, Qt WebEngine assumes that external resources, such as JavaScript programs or style sheets, are encoded in UTF-8 unless otherwise specified. For example, the encoding of an external script can be specified through the &lt;code&gt;charset&lt;/code&gt; attribute of the HTML script tag. Alternatively, the encoding can be specified by the web server.</source>
          <target state="translated">이 방법을 사용할 때 Qt WebEngine은 달리 지정되지 않는 한 JavaScript 프로그램 또는 스타일 시트와 같은 외부 자원이 UTF-8로 인코딩 된 것으로 가정합니다. 예를 들어 HTML 스크립트 태그 의 &lt;code&gt;charset&lt;/code&gt; 속성을 통해 외부 스크립트의 인코딩을 지정할 수 있습니다 . 또는 웹 서버에서 인코딩을 지정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="fdf1b54e645c47e0218c40636ac9436b5bcd1515" translate="yes" xml:space="preserve">
          <source>When using this method, the web engine assumes that external resources, such as JavaScript programs or style sheets, are encoded in UTF-8 unless otherwise specified. For example, the encoding of an external script can be specified through the charset attribute of the HTML script tag. It is also possible for the encoding to be specified by the web server.</source>
          <target state="translated">이 방법을 사용할 때 웹 엔진은 달리 지정되지 않는 한 JavaScript 프로그램 또는 스타일 시트와 같은 외부 자원이 UTF-8로 인코딩 된 것으로 가정합니다. 예를 들어 HTML 스크립트 태그의 charset 속성을 통해 외부 스크립트의 인코딩을 지정할 수 있습니다. 웹 서버에서 인코딩을 지정할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="5a2a1ceb612d654821cdebdcfcb18990c549b921" translate="yes" xml:space="preserve">
          <source>When using this plugin, the &lt;a href=&quot;qml-qtlocation-routemaneuver&quot;&gt;RouteManeuver&lt;/a&gt; objects in the returned route may contain additional extended attributes (see &lt;a href=&quot;qml-qtlocation-routemaneuver#extendedAttributes-prop&quot;&gt;RouteManeuver::extendedAttributes&lt;/a&gt;), where available. These attributes are described in detail in the official &lt;a href=&quot;https://www.mapbox.com/api-documentation/#stepmaneuver-object&quot;&gt;Mapbox direction API documentation&lt;/a&gt;.</source>
          <target state="translated">이 플러그인을 사용할 때 반환 된 경로 의 &lt;a href=&quot;qml-qtlocation-routemaneuver&quot;&gt;RouteManeuver&lt;/a&gt; 객체는 사용 가능한 경우 추가 확장 속성을 포함 할 수 있습니다 ( &lt;a href=&quot;qml-qtlocation-routemaneuver#extendedAttributes-prop&quot;&gt;RouteManeuver :: extendedAttributes&lt;/a&gt; 참조 ). 이러한 속성은 공식 &lt;a href=&quot;https://www.mapbox.com/api-documentation/#stepmaneuver-object&quot;&gt;Mapbox 방향 API 설명서&lt;/a&gt; 에 자세히 설명되어 있습니다 .</target>
        </trans-unit>
        <trans-unit id="8de68a2cf4346e4f75f69795025d7ee380ea618b" translate="yes" xml:space="preserve">
          <source>When using this template, the following qmake system variables are recognized. You should use these in your .pro file to specify information about your application. For additional platform-dependent system variables, you could have a look at the &lt;a href=&quot;qmake-platform-notes#&quot;&gt;Platform Notes&lt;/a&gt;.</source>
          <target state="translated">이 템플리트를 사용할 때 다음 qmake 시스템 변수가 인식됩니다. .pro 파일에서이를 사용하여 응용 프로그램에 대한 정보를 지정해야합니다. 추가적인 플랫폼 종속 시스템 변수에 대해서는 &lt;a href=&quot;qmake-platform-notes#&quot;&gt;플랫폼 참고 사항을&lt;/a&gt; 살펴볼 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="cc8e8e68b8ce727bee069d21cdb1bf990c4178a5" translate="yes" xml:space="preserve">
          <source>When we communicate with the assistive technologies, we need to describe Qt's user interface in a way that they can understand. Qt applications use &lt;a href=&quot;qaccessibleinterface&quot;&gt;QAccessibleInterface&lt;/a&gt; to expose information about the individual UI elements. Currently, Qt provides support for its widgets and widget parts, e.g., slider handles, but the interface could also be implemented for any &lt;a href=&quot;qobject&quot;&gt;QObject&lt;/a&gt; if necessary. &lt;a href=&quot;qaccessible&quot;&gt;QAccessible&lt;/a&gt; contains enums that describe the UI. We will examine the enums in the course of this document.</source>
          <target state="translated">보조 기술과 통신 할 때 Qt의 사용자 인터페이스를 이해할 수있는 방식으로 설명해야합니다. Qt 애플리케이션은 &lt;a href=&quot;qaccessibleinterface&quot;&gt;QAccessibleInterface&lt;/a&gt; 를 사용 하여 개별 UI 요소에 대한 정보를 노출합니다. 현재 Qt는 위젯 및 위젯 파트 (예 : 슬라이더 핸들)를 지원하지만 필요한 경우 모든 &lt;a href=&quot;qobject&quot;&gt;QObject에&lt;/a&gt; 대해 인터페이스를 구현할 수도 있습니다 . &lt;a href=&quot;qaccessible&quot;&gt;QAccessible&lt;/a&gt; 에는 UI를 설명하는 열거 형이 포함되어 있습니다. 이 문서 과정에서 열거 형을 살펴볼 것입니다.</target>
        </trans-unit>
        <trans-unit id="870d36a92f2ae13647e01707539daa266e80b994" translate="yes" xml:space="preserve">
          <source>When we create a field using &lt;a href=&quot;qwizardpage#registerField&quot;&gt;QWizardPage::registerField&lt;/a&gt;(), we pass a unique field name and a widget. We can also provide a Qt property name and a &quot;changed&quot; signal (a signal that is emitted when the property changes) as third and fourth arguments; however, this is not necessary for the most common Qt widgets, such as &lt;a href=&quot;qlineedit&quot;&gt;QLineEdit&lt;/a&gt;, &lt;a href=&quot;qcheckbox&quot;&gt;QCheckBox&lt;/a&gt;, and &lt;a href=&quot;qcombobox&quot;&gt;QComboBox&lt;/a&gt;, because &lt;a href=&quot;qwizard&quot;&gt;QWizard&lt;/a&gt; knows which properties to look for.</source>
          <target state="translated">&lt;a href=&quot;qwizardpage#registerField&quot;&gt;QWizardPage :: registerField&lt;/a&gt; ()를 사용하여 필드를 만들면 고유 한 필드 이름과 위젯이 전달됩니다. 또한 Qt 속성 이름과 &quot;변경된&quot;신호 (속성이 변경 될 때 발생하는 신호)를 세 번째 및 네 번째 인수로 제공 할 수 있습니다. 그러나,이 같은 가장 일반적인 Qt는 위젯, 필요하지 않습니다 &lt;a href=&quot;qlineedit&quot;&gt;QLineEdit&lt;/a&gt; , &lt;a href=&quot;qcheckbox&quot;&gt;QCheckBox&lt;/a&gt; 및 &lt;a href=&quot;qcombobox&quot;&gt;QComboBox&lt;/a&gt; 때문에, &lt;a href=&quot;qwizard&quot;&gt;QWizard이&lt;/a&gt; 찾을 수있는 속성을 알고있다.</target>
        </trans-unit>
        <trans-unit id="d28a9032eec48f88438cdec09fd45cc48b6758eb" translate="yes" xml:space="preserve">
          <source>When we select those widgets and close the dialog the two widgets will now be available from the toolbox as grey squares with their name next to it</source>
          <target state="translated">해당 위젯을 선택하고 대화 상자를 닫으면 도구 상자에서 두 개의 위젯이 이름 옆에 회색 사각형으로 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="3fd645480f7c8c8a441a005df178284bbfe8bf76" translate="yes" xml:space="preserve">
          <source>When we specify a value for the length of an element in a text document, we often need to provide some other information so that the length is used in the way we expect. For example, when we specify a table width, the value can represent a fixed number of pixels, or it can be a percentage value. This information changes both the meaning of the value and the way it is used.</source>
          <target state="translated">텍스트 문서에서 요소의 길이 값을 지정할 때 종종 길이가 예상 한 방식으로 사용되도록 다른 정보를 제공해야합니다. 예를 들어, 테이블 너비를 지정할 때 값은 고정 된 수의 픽셀을 나타내거나 백분율 값일 수 있습니다. 이 정보는 값의 의미와 사용 방법을 모두 변경합니다.</target>
        </trans-unit>
        <trans-unit id="284899e0845013f5c711a6352c8742fd3ae424f1" translate="yes" xml:space="preserve">
          <source>When working with MIME data, Qt will interate through all instances of &lt;a href=&quot;qmacpasteboardmime&quot;&gt;QMacPasteboardMime&lt;/a&gt; to find an instance that can convert to, or from, a specific MIME type. It will do this by calling &lt;a href=&quot;qmacpasteboardmime#canConvert&quot;&gt;canConvert&lt;/a&gt;() on each instance, starting with (and choosing) the last created instance first. The actual conversions will be done by using &lt;a href=&quot;qmacpasteboardmime#convertToMime&quot;&gt;convertToMime&lt;/a&gt;() and &lt;a href=&quot;qmacpasteboardmime#convertFromMime&quot;&gt;convertFromMime&lt;/a&gt;().</source>
          <target state="translated">MIME 데이터로 작업 할 때 Qt는 &lt;a href=&quot;qmacpasteboardmime&quot;&gt;QMacPasteboardMime의&lt;/a&gt; 모든 인스턴스를 통해 특정 MIME 형식으로 변환하거나 특정 MIME 형식에서 변환 할 수있는 인스턴스를 찾습니다. 각 인스턴스에서 &lt;a href=&quot;qmacpasteboardmime#canConvert&quot;&gt;canConvert&lt;/a&gt; ()를 호출 하고 마지막으로 생성 된 인스턴스부터 시작하여 선택하여이를 수행합니다. 실제 변환은 &lt;a href=&quot;qmacpasteboardmime#convertToMime&quot;&gt;convertToMime&lt;/a&gt; () 및 &lt;a href=&quot;qmacpasteboardmime#convertFromMime&quot;&gt;convertFromMime&lt;/a&gt; () 을 사용하여 수행됩니다 .</target>
        </trans-unit>
        <trans-unit id="4e8e4ed4ccd8ff19293050034a255b064f2a3965" translate="yes" xml:space="preserve">
          <source>When working with sRGB framebuffers, it will be necessary to specify a format like &lt;code&gt;GL_SRGB8_ALPHA8&lt;/code&gt;. This can be achieved by calling this function.</source>
          <target state="translated">sRGB 프레임 버퍼로 작업 할 때는 &lt;code&gt;GL_SRGB8_ALPHA8&lt;/code&gt; 과 같은 형식을 지정해야합니다 . 이 함수를 호출하면됩니다.</target>
        </trans-unit>
        <trans-unit id="6f312a263e4af61bbd702f1cea50f4bdda448b76" translate="yes" xml:space="preserve">
          <source>When writing a &lt;a href=&quot;qwaylandcompositor&quot;&gt;QWaylandCompositor&lt;/a&gt; in Qt Quick, this class can be used to display a client's contents on an output device and will pass user input to the client.</source>
          <target state="translated">Qt Quick에서 &lt;a href=&quot;qwaylandcompositor&quot;&gt;QWaylandCompositor&lt;/a&gt; 를 작성할 때이 클래스는 클라이언트의 컨텐츠를 출력 장치에 표시하고 사용자 입력을 클라이언트에 전달하는 데 사용될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="410b86178a5dfdcde1c78964c7d14183b1876a0b" translate="yes" xml:space="preserve">
          <source>When you &lt;a href=&quot;qbytearray#append&quot;&gt;append&lt;/a&gt;() data to a non-empty array, the array will be reallocated and the new data copied to it. You can avoid this behavior by calling &lt;a href=&quot;qbytearray#reserve&quot;&gt;reserve&lt;/a&gt;(), which preallocates a certain amount of memory. You can also call &lt;a href=&quot;qbytearray#capacity&quot;&gt;capacity&lt;/a&gt;() to find out how much memory &lt;a href=&quot;qbytearray&quot;&gt;QByteArray&lt;/a&gt; actually allocated. Data appended to an empty array is not copied.</source>
          <target state="translated">때 당신이 &lt;a href=&quot;qbytearray#append&quot;&gt;APPEND&lt;/a&gt; 비어 있지 않은 배열 () 데이터 배열은 재 할당 및 새로운 데이터가 복사됩니다. &lt;a href=&quot;qbytearray#reserve&quot;&gt;reserve&lt;/a&gt; () 를 호출 하여 특정 양의 메모리를 미리 할당 하여이 동작을 피할 수 있습니다 . &lt;a href=&quot;qbytearray&quot;&gt;QByteArray가&lt;/a&gt; 실제로 할당 한 메모리 양을 확인하기 위해 &lt;a href=&quot;qbytearray#capacity&quot;&gt;capacity&lt;/a&gt; ()를 호출 할 수도 있습니다 . 빈 배열에 추가 된 데이터는 복사되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="e206e4859b01e1c09bb56347d89a744afe0086be" translate="yes" xml:space="preserve">
          <source>When you &lt;a href=&quot;qwidget#hide&quot;&gt;hide&lt;/a&gt;() a child, its space will be distributed among the other children. It will be reinstated when you &lt;a href=&quot;qwidget#show&quot;&gt;show&lt;/a&gt;() it again.</source>
          <target state="translated">아이 를 &lt;a href=&quot;qwidget#hide&quot;&gt;숨기면&lt;/a&gt; (), 다른 아이에게 공간이 분배됩니다. 다시 () &lt;a href=&quot;qwidget#show&quot;&gt;표시&lt;/a&gt; 하면 복원됩니다 .</target>
        </trans-unit>
        <trans-unit id="2ae32a06b61e1a7246efea4bce7751cf08c416ce" translate="yes" xml:space="preserve">
          <source>When you add widgets to a layout, the layout process works as follows:</source>
          <target state="translated">위젯을 레이아웃에 추가하면 레이아웃 프로세스는 다음과 같이 작동합니다.</target>
        </trans-unit>
        <trans-unit id="90fb4ea82c0d848dd1c76043e760d581c3542117" translate="yes" xml:space="preserve">
          <source>When you are done, call &lt;a href=&quot;qinapptransaction#finalize&quot;&gt;QInAppTransaction::finalize&lt;/a&gt;(), regardless of its status. Transactions which are not finalized will be emitted again the next time your application calls &lt;a href=&quot;qinappstore#registerProduct&quot;&gt;registerProduct&lt;/a&gt;() for the same product.</source>
          <target state="translated">완료되면 상태에 관계없이 &lt;a href=&quot;qinapptransaction#finalize&quot;&gt;QInAppTransaction :: finalize&lt;/a&gt; ()를 호출 하십시오 . 완료되지 않은 트랜잭션은 다음에 응용 프로그램 이 동일한 제품에 대해 &lt;a href=&quot;qinappstore#registerProduct&quot;&gt;registerProduct&lt;/a&gt; ()를 호출 할 때 다시 생성됩니다.</target>
        </trans-unit>
        <trans-unit id="ca9c1c1922961985d5b3578d590ea428455c5e94" translate="yes" xml:space="preserve">
          <source>When you assign a &lt;a href=&quot;qobject&quot;&gt;QObject&lt;/a&gt; sub-class to this property, the QML engine does the interface cast to &lt;code&gt;FooInterface*&lt;/code&gt; automatically.</source>
          <target state="translated">당신이 할당 할 때 &lt;a href=&quot;qobject&quot;&gt;QObject를의&lt;/a&gt; 이 속성을 하위 클래스는 QML 엔진의 인터페이스 캐스트하지 &lt;code&gt;FooInterface*&lt;/code&gt; 자동으로.</target>
        </trans-unit>
        <trans-unit id="203801501ed91c63352794b08170d38e294688a8" translate="yes" xml:space="preserve">
          <source>When you assign a new font to a widget, the properties from this font are combined with the widget's default font to form the widget's final font. You can call &lt;a href=&quot;qwidget#fontInfo&quot;&gt;fontInfo&lt;/a&gt;() to get a copy of the widget's final font. The final font is also used to initialize &lt;a href=&quot;qpainter&quot;&gt;QPainter&lt;/a&gt;'s font.</source>
          <target state="translated">새 글꼴을 위젯에 지정하면이 글꼴의 특성이 위젯의 ​​기본 글꼴과 결합되어 위젯의 최종 글꼴이됩니다. &lt;a href=&quot;qwidget#fontInfo&quot;&gt;fontInfo&lt;/a&gt; ()를 호출 하여 위젯의 최종 글꼴 사본을 얻을 수 있습니다 . 마지막 글꼴은 &lt;a href=&quot;qpainter&quot;&gt;QPainter&lt;/a&gt; 의 글꼴 을 초기화하는 데에도 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="af2046c186d7103eac993dbd56c9ad5be66e4723" translate="yes" xml:space="preserve">
          <source>When you assign a new palette to a widget, the color roles from this palette are combined with the widget's default palette to form the widget's final palette. The palette entry for the widget's background role is used to fill the widget's background (see &lt;a href=&quot;qwidget#autoFillBackground-prop&quot;&gt;QWidget::autoFillBackground&lt;/a&gt;), and the foreground role initializes &lt;a href=&quot;qpainter&quot;&gt;QPainter&lt;/a&gt;'s pen.</source>
          <target state="translated">새 팔레트를 위젯에 지정하면이 팔레트의 색상 역할이 위젯의 ​​기본 팔레트와 결합되어 위젯의 최종 팔레트를 형성합니다. 위젯의 배경 역할에 대한 팔레트 항목은 위젯의 배경을 채우는 데 사용되며 ( &lt;a href=&quot;qwidget#autoFillBackground-prop&quot;&gt;QWidget :: autoFillBackground&lt;/a&gt; 참조 ) 전경 역할은 &lt;a href=&quot;qpainter&quot;&gt;QPainter&lt;/a&gt; 의 펜 을 초기화 합니다.</target>
        </trans-unit>
        <trans-unit id="9e46f6202b38da8549f0268e4a4fe0abf934e7f4" translate="yes" xml:space="preserve">
          <source>When you build Qt, frameworks are built by default, and inside the framework you will find both a release and a debug version (e.g., &lt;a href=&quot;https://doc.qt.io/qt-5.13/qtcore-module.html&quot;&gt;QtCore&lt;/a&gt; and QtCore_debug). If you pass the &lt;code&gt;-no-framework&lt;/code&gt; flag when you build Qt, two dylibs are built for each Qt library (e.g., libQtCore.4.dylib and libQtCore_debug.4.dylib).</source>
          <target state="translated">Qt를 빌드 할 때 기본적으로 프레임 워크가 빌드되며 프레임 워크 안에 릴리스 및 디버그 버전 (예 : &lt;a href=&quot;https://doc.qt.io/qt-5.13/qtcore-module.html&quot;&gt;QtCore&lt;/a&gt; 및 QtCore_debug)이 있습니다. Qt를 빌드 할 때 &lt;code&gt;-no-framework&lt;/code&gt; 플래그 를 전달하면 각 Qt 라이브러리마다 두 개의 dylib가 작성됩니다 (예 : libQtCore.4.dylib 및 libQtCore_debug.4.dylib).</target>
        </trans-unit>
        <trans-unit id="0a87e705d339a4e673804de6e41e480ac5d48e14" translate="yes" xml:space="preserve">
          <source>When you call &lt;a href=&quot;qmutex#lock&quot;&gt;lock&lt;/a&gt;() in a thread, other threads that try to call &lt;a href=&quot;qmutex#lock&quot;&gt;lock&lt;/a&gt;() in the same place will block until the thread that got the lock calls &lt;a href=&quot;qmutex#unlock&quot;&gt;unlock&lt;/a&gt;(). A non-blocking alternative to &lt;a href=&quot;qmutex#lock&quot;&gt;lock&lt;/a&gt;() is &lt;a href=&quot;qmutex#tryLock&quot;&gt;tryLock&lt;/a&gt;().</source>
          <target state="translated">당신이 호출 할 때 &lt;a href=&quot;qmutex#lock&quot;&gt;잠금을&lt;/a&gt; 스레드에서 ()를 호출하려고 다른 스레드 &lt;a href=&quot;qmutex#lock&quot;&gt;잠금 장치를&lt;/a&gt; 잠금을 얻은 스레드를 호출 할 때까지 같은 장소에서 (가) 차단 &lt;a href=&quot;qmutex#unlock&quot;&gt;해제를&lt;/a&gt; (). &lt;a href=&quot;qmutex#lock&quot;&gt;잠금&lt;/a&gt; ()에 대한 비 차단 대안 은 &lt;a href=&quot;qmutex#tryLock&quot;&gt;tryLock&lt;/a&gt; ()입니다.</target>
        </trans-unit>
        <trans-unit id="6c51b78ef404aa9256758848a787e698738ccda1" translate="yes" xml:space="preserve">
          <source>When you click &lt;b&gt;OK&lt;/b&gt; or &lt;b&gt;Apply&lt;/b&gt;, Qt Designer will automatically display the widget with its new stylesheet.</source>
          <target state="translated">&lt;b&gt;확인&lt;/b&gt; 또는 &lt;b&gt;적용&lt;/b&gt; 을 클릭하면 Qt Designer가 자동으로 새 스타일 시트와 함께 위젯을 표시합니다.</target>
        </trans-unit>
        <trans-unit id="a29f5adc1b71f2d82537e70f37ce91b1e7581ebe" translate="yes" xml:space="preserve">
          <source>When you click on the slider and drag it to a certain value, you want the spin box to display the slider's position. To accomplish this behavior, you need to connect the slider's &lt;a href=&quot;qabstractslider#valueChanged&quot;&gt;valueChanged()&lt;/a&gt; signal to the spin box's &lt;a href=&quot;qspinbox#value-prop&quot;&gt;setValue()&lt;/a&gt; slot. You also need to make the reverse connections, e.g., connect the spin box's &lt;a href=&quot;qspinbox#valueChanged&quot;&gt;valueChanged()&lt;/a&gt; signal to the slider's &lt;a href=&quot;qabstractslider#value-prop&quot;&gt;setValue()&lt;/a&gt; slot.</source>
          <target state="translated">슬라이더를 클릭하고 특정 값으로 드래그하면 스핀 상자에 슬라이더의 위치가 표시되기를 원합니다. 이 동작을 수행하려면 슬라이더의 &lt;a href=&quot;qabstractslider#valueChanged&quot;&gt;valueChanged ()&lt;/a&gt; 신호를 스핀 상자의 &lt;a href=&quot;qspinbox#value-prop&quot;&gt;setValue ()&lt;/a&gt; 슬롯 에 연결해야 합니다. 스핀 박스의 &lt;a href=&quot;qspinbox#valueChanged&quot;&gt;valueChanged ()&lt;/a&gt; 신호를 슬라이더의 &lt;a href=&quot;qabstractslider#value-prop&quot;&gt;setValue ()&lt;/a&gt; 슬롯에 연결하는 것과 같이 역방향 연결도해야 합니다.</target>
        </trans-unit>
        <trans-unit id="16d343fa86e79c1573178210409175ac2c2a9e85" translate="yes" xml:space="preserve">
          <source>When you compile your application, you must explicitly enable the debugging infrastructure. If you use qmake, you can add the configuration parameters to the project &lt;code&gt;.pro&lt;/code&gt; file:</source>
          <target state="translated">응용 프로그램을 컴파일 할 때 디버깅 인프라를 명시 적으로 활성화해야합니다. qmake를 사용하는 경우 구성 매개 변수를 프로젝트 &lt;code&gt;.pro&lt;/code&gt; 파일에 추가 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="2aceba6d77a63e6f2b3b7fb5d2e861200bdf01c2" translate="yes" xml:space="preserve">
          <source>When you create a &lt;a href=&quot;qfont&quot;&gt;QFont&lt;/a&gt; object you specify various attributes that you want the font to have. Qt will use the font with the specified attributes, or if no matching font exists, Qt will use the closest matching installed font. The attributes of the font that is actually used are retrievable from a &lt;a href=&quot;qfontinfo&quot;&gt;QFontInfo&lt;/a&gt; object. If the window system provides an exact match &lt;a href=&quot;qfont#exactMatch&quot;&gt;exactMatch&lt;/a&gt;() returns &lt;code&gt;true&lt;/code&gt;. Use &lt;a href=&quot;qfontmetricsf&quot;&gt;QFontMetricsF&lt;/a&gt; to get measurements, e.g. the pixel length of a string using QFontMetrics::width().</source>
          <target state="translated">&lt;a href=&quot;qfont&quot;&gt;QFont&lt;/a&gt; 객체 를 만들 때 글꼴에 원하는 다양한 속성을 지정합니다. Qt는 지정된 속성으로 글꼴을 사용하거나 일치하는 글꼴이 없으면 가장 가까운 일치하는 설치된 글꼴을 사용합니다. 실제로 사용되는 글꼴의 속성은 &lt;a href=&quot;qfontinfo&quot;&gt;QFontInfo&lt;/a&gt; 객체 에서 검색 할 수 있습니다 . 윈도우 시스템이 정확히 일치하는 경우 &lt;a href=&quot;qfont#exactMatch&quot;&gt;exactMatch&lt;/a&gt; ()가 &lt;code&gt;true&lt;/code&gt; 를 반환 합니다 . QFontMetrics :: width ()를 사용하여 문자열의 픽셀 길이와 같은 측정 값을 얻으려면 &lt;a href=&quot;qfontmetricsf&quot;&gt;QFontMetricsF&lt;/a&gt; 를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="28ec5a0e3b20169c458bbcc9cde4d66c22062727" translate="yes" xml:space="preserve">
          <source>When you create an instance of your &lt;a href=&quot;qsyntaxhighlighter&quot;&gt;QSyntaxHighlighter&lt;/a&gt; subclass, pass it the &lt;a href=&quot;qtextdocument&quot;&gt;QTextDocument&lt;/a&gt; that you want the syntax highlighting to be applied to. For example:</source>
          <target state="translated">&lt;a href=&quot;qsyntaxhighlighter&quot;&gt;QSyntaxHighlighter&lt;/a&gt; 서브 클래스 의 인스턴스를 작성할 때 구문 강조 표시를 적용 할 &lt;a href=&quot;qtextdocument&quot;&gt;QTextDocument&lt;/a&gt; 를 전달하십시오 . 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="6ca044dcc761989ec3d45fb4cbef2b702bc2b544" translate="yes" xml:space="preserve">
          <source>When you create your own subwindow, you must set the &lt;a href=&quot;qt#WidgetAttribute-enum&quot;&gt;Qt::WA_DeleteOnClose&lt;/a&gt; widget attribute if you want the window to be deleted when closed in the MDI area. If not, the window will be hidden and the MDI area will not activate the next subwindow.</source>
          <target state="translated">자체 &lt;a href=&quot;qt#WidgetAttribute-enum&quot;&gt;하위&lt;/a&gt; 창을 만들 때 MDI 영역에서 창을 닫을 때 창을 삭제 하려면 Qt :: WA_DeleteOnClose 위젯 속성을 설정해야합니다 . 그렇지 않으면 창이 숨겨지고 MDI 영역이 다음 하위 창을 활성화하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="84840db2f97361935bdbfd339750fb2aacff31cf" translate="yes" xml:space="preserve">
          <source>When you develop a BSP for your board, you should include the following utilities to enable Qt Creator to deploy, run, debug, and stop applications on QNX devices:</source>
          <target state="translated">보드 용 BSP를 개발할 때 Qt Creator가 QNX 장치에서 응용 프로그램을 배포, 실행, 디버깅 및 중지 할 수 있도록 다음 유틸리티를 포함해야합니다.</target>
        </trans-unit>
        <trans-unit id="4c480aff5cf79a86ac02aed41c87410316570513" translate="yes" xml:space="preserve">
          <source>When you develop an application for an Apple platform, you must set the deployment target. Various build tools within the Xcode toolchain all have a flag which you can use to set this value, including but not limited to the compiler and linker. By setting the deployment target value, you are explicitly declaring that your application must work on at least that version, and will not work with any earlier versions of the OS. It is then up to you to ensure that your use of the system APIs matches what you have declared. Since the compiler knows what you have declared, it can help in enforcing that.</source>
          <target state="translated">Apple 플랫폼 용 응용 프로그램을 개발할 때는 배포 대상을 설정해야합니다. Xcode 툴체인 내의 다양한 빌드 도구에는 모두 컴파일러 및 링커를 포함하여이 값을 설정하는 데 사용할 수있는 플래그가 있습니다. 배포 대상 값을 설정하면 응용 프로그램이 최소한 해당 버전에서 작동해야하며 이전 버전의 OS에서는 작동하지 않음을 명시 적으로 선언합니다. 시스템 API 사용이 선언 한 것과 일치하는지 확인하는 것은 사용자의 책임입니다. 컴파일러는 선언 한 내용을 알고 있으므로이를 적용하는 데 도움이 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8e624447ece8794817624f7b1b843a60aecc9b62" translate="yes" xml:space="preserve">
          <source>When you develop an application for an Apple platform, you should always use the latest version of Xcode and the latest SDK available at the time of development. On some platforms, like iOS, you will actually be rejected from the App Store if you do not. Therefore, the SDK version is always greater than or equal to the deployment target.</source>
          <target state="translated">Apple 플랫폼 용 응용 프로그램을 개발할 때는 항상 최신 Xcode 버전과 개발 당시 사용 가능한 최신 SDK를 사용해야합니다. iOS와 같은 일부 플랫폼에서는 그렇지 않은 경우 실제로 App Store에서 거부됩니다. 따라서 SDK 버전은 항상 배포 대상보다 크거나 같습니다.</target>
        </trans-unit>
        <trans-unit id="4c7b64797b21f9f607e1ffa6f6ab445278f5f0b8" translate="yes" xml:space="preserve">
          <source>When you develop an application with QML, there are many ways to debug possible issues that you may face. The sections below describe the debugging tools available and how to use them.</source>
          <target state="translated">QML을 사용하여 애플리케이션을 개발할 때 발생할 수있는 문제를 디버깅하는 방법에는 여러 가지가 있습니다. 아래 섹션에서는 사용 가능한 디버깅 도구 및 사용 방법에 대해 설명합니다.</target>
        </trans-unit>
        <trans-unit id="665dc5dbb39005e2b8624150def3c9dc88cec3b1" translate="yes" xml:space="preserve">
          <source>When you develop custom widgets, you can create custom subclasses of &lt;a href=&quot;qaccessibleinterface&quot;&gt;QAccessibleInterface&lt;/a&gt; and distribute them as plugins (using &lt;a href=&quot;qaccessibleplugin&quot;&gt;QAccessiblePlugin&lt;/a&gt;) or compile them into the application. Likewise, Qt's predefined accessibility support can be built as plugin (the default) or directly into the Qt library. The main advantage of using plugins is that the accessibility classes are only loaded into memory if they are actually used; they don't slow down the common case where no assistive technology is being used.</source>
          <target state="translated">사용자 정의 위젯을 개발할 때 &lt;a href=&quot;qaccessibleinterface&quot;&gt;QAccessibleInterface의&lt;/a&gt; 사용자 정의 서브 클래스를 작성 하고이를 플러그인 ( &lt;a href=&quot;qaccessibleplugin&quot;&gt;QAccessiblePlugin&lt;/a&gt; 사용 ) 으로 분배 하거나 애플리케이션으로 컴파일 할 수 있습니다. 마찬가지로, Qt의 사전 정의 된 내게 필요한 옵션 지원은 플러그인 (기본값)으로 또는 Qt 라이브러리에 직접 빌드 할 수 있습니다. 플러그인 사용의 주요 장점은 접근성 클래스가 실제로 사용되는 경우에만 메모리에로드된다는 것입니다. 보조 기술이 사용되지 않는 일반적인 경우를 늦추지 않습니다.</target>
        </trans-unit>
        <trans-unit id="5ea8acaa7e79eefa675682ec7a314c688674b2bb" translate="yes" xml:space="preserve">
          <source>When you do a &lt;code&gt;make install&lt;/code&gt;, and you don't have a build of the project yet, the project is first built, and then installed. If you don't want this behavior, set this config value to ensure that the build target is not added as a dependency to the install target.</source>
          <target state="translated">&lt;code&gt;make install&lt;/code&gt; 을 수행 할 때 아직 프로젝트 빌드가 없으면 프로젝트가 먼저 빌드 된 다음 설치됩니다. 이 동작을 원하지 않으면 빌드 대상이 설치 대상에 대한 종속성으로 추가되지 않도록이 구성 값을 설정하십시오.</target>
        </trans-unit>
        <trans-unit id="f239ccd84b95fa1bd3731891bc9b99327baddf53" translate="yes" xml:space="preserve">
          <source>When you have a data set that updates rapidly, it is important to handle data properly to ensure good performance. Since memory allocation is a costly operation, always use &lt;a href=&quot;qlist#reserve&quot;&gt;QList::reserve&lt;/a&gt;() and &lt;a href=&quot;qvector#resize&quot;&gt;QVector::resize&lt;/a&gt;() where possible to avoid unnecessary reallocations when constructing the array to give to the proxy. If you need to change the entire data set for each frame, it is in most cases best to reuse the existing array - especially if the array dimensions do not change. If you need to add, insert, remove, or change several rows or items for each frame, it is always more efficient to do it with one method call instead of multiple calls affecting a single row or item each. For example, adding ten rows with a single &lt;a href=&quot;qbardataproxy#addRows&quot;&gt;QBarDataProxy::addRows&lt;/a&gt;() call is much more efficient than ten separate &lt;a href=&quot;qbardataproxy#addRow&quot;&gt;QBarDataProxy::addRow&lt;/a&gt;() calls.</source>
          <target state="translated">빠르게 업데이트되는 데이터 세트가있는 경우 데이터를 올바르게 처리하여 성능을 향상시키는 것이 중요합니다. 메모리 할당은 비용이 많이 드는 작업이므로 프록시에 제공 할 배열을 구성 할 때 불필요한 재 할당을 피하려면 가능한 경우 항상 &lt;a href=&quot;qlist#reserve&quot;&gt;QList :: reserve&lt;/a&gt; () 및 &lt;a href=&quot;qvector#resize&quot;&gt;QVector :: resize&lt;/a&gt; ()를 사용하십시오. 각 프레임에 대해 전체 데이터 세트를 변경해야하는 경우, 특히 배열 크기가 변경되지 않는 경우 기존 배열을 재사용하는 것이 가장 좋습니다. 각 프레임에 대해 여러 행이나 항목을 추가, 삽입, 제거 또는 변경해야하는 경우 단일 행이나 항목에 각각 영향을 미치는 여러 호출 대신 하나의 메소드 호출로 수행하는 것이 항상 더 효율적입니다. 예를 들어, 단일 &lt;a href=&quot;qbardataproxy#addRows&quot;&gt;QBarDataProxy :: addRows로&lt;/a&gt; 10 개의 행 추가() 호출은 10 개의 개별 &lt;a href=&quot;qbardataproxy#addRow&quot;&gt;QBarDataProxy :: addRow&lt;/a&gt; () 호출 보다 훨씬 효율적 입니다.</target>
        </trans-unit>
        <trans-unit id="f2c795f997957d917a037b7558d2111076f2f860" translate="yes" xml:space="preserve">
          <source>When you have set up your account, click on &lt;b&gt;Add new application&lt;/b&gt; in Google Play's developer console.</source>
          <target state="translated">계정을 설정했으면 Google Play 개발자 콘솔에서 &lt;b&gt;새 애플리케이션 추가를&lt;/b&gt; 클릭하십시오 .</target>
        </trans-unit>
        <trans-unit id="da2b2d3afb5483b4a1db7b7d7fb239c631a77696" translate="yes" xml:space="preserve">
          <source>When you implement styles, there are several issues to consider. We will give some hints and advice on implementation here.</source>
          <target state="translated">스타일을 구현할 때 고려해야 할 몇 가지 문제가 있습니다. 여기에 구현에 대한 힌트와 조언을 드리겠습니다.</target>
        </trans-unit>
        <trans-unit id="8212971e42c4deca42aba3c17bc98fcd36818d32" translate="yes" xml:space="preserve">
          <source>When you make your own widget class, you should also communicate its layout properties. If the widget uses one of Qt's layouts, this is already taken care of. If the widget does not have any child widgets, or uses a manual layout, you can change the behavior of the widget using any or all of the following mechanisms:</source>
          <target state="translated">자신 만의 위젯 클래스를 만들 때 레이아웃 속성도 전달해야합니다. 위젯이 Qt의 레이아웃 중 하나를 사용하는 경우 이미 처리되었습니다. 위젯에 하위 위젯이 없거나 수동 레이아웃을 사용하는 경우 다음 메커니즘 중 하나 또는 모두를 사용하여 위젯의 동작을 변경할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="11e1d05bbb73ce5b03a0982e43710997b6d84eef" translate="yes" xml:space="preserve">
          <source>When you need to invoke item functionality in a &lt;a href=&quot;qmodelindex&quot;&gt;QModelIndex&lt;/a&gt;-based API (e.g. &lt;a href=&quot;qabstractitemview&quot;&gt;QAbstractItemView&lt;/a&gt;), you can call this function to obtain an index that corresponds to the item's location in the model.</source>
          <target state="translated">&lt;a href=&quot;qmodelindex&quot;&gt;QModelIndex&lt;/a&gt; 기반 API (예 : &lt;a href=&quot;qabstractitemview&quot;&gt;QAbstractItemView&lt;/a&gt; ) 에서 항목 기능을 호출해야하는 경우이 함수를 호출하여 모델의 항목 위치에 해당하는 색인을 얻을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="fa3c3f800f477ad4b6074ff08c0beb3cbd07d4a4" translate="yes" xml:space="preserve">
          <source>When you receive the signal, you call &lt;a href=&quot;qstandarditemmodel#itemFromIndex&quot;&gt;itemFromIndex&lt;/a&gt;() on the given model index to get a pointer to the item:</source>
          <target state="translated">신호를 받으면 주어진 모델 인덱스에서 &lt;a href=&quot;qstandarditemmodel#itemFromIndex&quot;&gt;itemFromIndex&lt;/a&gt; () 를 호출 하여 항목에 대한 포인터를 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="11bc559026d9ce92e05880b306679f8d18cde9a7" translate="yes" xml:space="preserve">
          <source>When you reimplement your own paint engine, you must reimplement &lt;a href=&quot;qpaintengine#drawTextItem&quot;&gt;QPaintEngine::drawTextItem&lt;/a&gt;(), a function that takes a &lt;a href=&quot;qtextitem&quot;&gt;QTextItem&lt;/a&gt; as one of its arguments.</source>
          <target state="translated">자체 페인트 엔진을 다시 구현할 때는 &lt;a href=&quot;qtextitem&quot;&gt;QTextItem&lt;/a&gt; 을 인수 중 하나로 사용 하는 함수 인 &lt;a href=&quot;qpaintengine#drawTextItem&quot;&gt;QPaintEngine :: drawTextItem&lt;/a&gt; ()을 다시 구현해야합니다 .</target>
        </trans-unit>
        <trans-unit id="cc3622a2958b0c7677184a6e7b09570f3e9ffbeb" translate="yes" xml:space="preserve">
          <source>When you retrieve a pixmap using pixmap(&lt;a href=&quot;qsize&quot;&gt;QSize&lt;/a&gt;, Mode, State), and no pixmap for this given size, mode and state has been added with &lt;a href=&quot;qicon#addFile&quot;&gt;addFile&lt;/a&gt;() or &lt;a href=&quot;qicon#addPixmap&quot;&gt;addPixmap&lt;/a&gt;(), then &lt;a href=&quot;qicon&quot;&gt;QIcon&lt;/a&gt; will generate one on the fly. This pixmap generation happens in a &lt;a href=&quot;qiconengine&quot;&gt;QIconEngine&lt;/a&gt;. The default engine scales pixmaps down if required, but never up, and it uses the current style to calculate a disabled appearance. By using custom icon engines, you can customize every aspect of generated icons. With &lt;a href=&quot;qiconengineplugin&quot;&gt;QIconEnginePlugin&lt;/a&gt; it is possible to register different icon engines for different file suffixes, making it possible for third parties to provide additional icon engines to those included with Qt.</source>
          <target state="translated">pixmap ( &lt;a href=&quot;qsize&quot;&gt;QSize&lt;/a&gt; , Mode, State)을 사용하여 pixmap을 검색 할 때이 주어진 크기, 모드 및 상태에 대해 pixmap이 &lt;a href=&quot;qicon#addFile&quot;&gt;addFile&lt;/a&gt; () 또는 &lt;a href=&quot;qicon#addPixmap&quot;&gt;addPixmap&lt;/a&gt; () 으로 추가되지 않은 경우 &lt;a href=&quot;qicon&quot;&gt;QIcon&lt;/a&gt; 은 즉시 생성합니다. 이 픽스맵 생성은 &lt;a href=&quot;qiconengine&quot;&gt;QIconEngine&lt;/a&gt; 에서 발생합니다 . 기본 엔진은 필요에 따라 픽스맵을 축소하지만 절대 확대하지 않으며 현재 스타일을 사용하여 비활성화 된 모양을 계산합니다. 사용자 정의 아이콘 엔진을 사용하여 생성 된 아이콘의 모든 측면을 사용자 정의 할 수 있습니다. &lt;a href=&quot;qiconengineplugin&quot;&gt;QIconEnginePlugin&lt;/a&gt; 을 사용하면 파일 접미사마다 다른 아이콘 엔진을 등록 할 수있어 타사가 Qt에 포함 된 아이콘 엔진에 추가 아이콘 엔진을 제공 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="571197ffd60fff66160ddd0d5152ea57afa360f9" translate="yes" xml:space="preserve">
          <source>When you run a Qt application, you can specify several command-line options that can help with debugging. These are recognized by &lt;a href=&quot;qapplication&quot;&gt;QApplication&lt;/a&gt;.</source>
          <target state="translated">Qt 애플리케이션을 실행할 때 디버깅에 도움이되는 몇 가지 명령 줄 옵션을 지정할 수 있습니다. 이것들은 &lt;a href=&quot;qapplication&quot;&gt;QApplication에&lt;/a&gt; 의해 인식됩니다 .</target>
        </trans-unit>
        <trans-unit id="dcbc1472c5e4961da67399a01267a56000ea1f91" translate="yes" xml:space="preserve">
          <source>When you run an XQuery using the C++ API in a Qt application, you will often want to bind program variables to $variables in the XQuery. After the query is evaluated, you will want to interpret the sequence of data items in the result set.</source>
          <target state="translated">Qt 애플리케이션에서 C ++ API를 사용하여 XQuery를 실행할 때 종종 프로그램 변수를 XQuery의 $ variables에 바인딩하려고합니다. 쿼리를 평가 한 후 결과 집합의 데이터 항목 시퀀스를 해석하려고합니다.</target>
        </trans-unit>
        <trans-unit id="74898dc919ae9ab35b6672e91c4aea88a18f022f" translate="yes" xml:space="preserve">
          <source>When you run your application, you will also need to add the &lt;code&gt;oci.dll&lt;/code&gt; path to your &lt;code&gt;PATH&lt;/code&gt; environment variable:</source>
          <target state="translated">응용 프로그램을 실행할 때 &lt;code&gt;oci.dll&lt;/code&gt; 경로를 &lt;code&gt;PATH&lt;/code&gt; 환경 변수 에 추가해야 합니다.</target>
        </trans-unit>
        <trans-unit id="ee8546a04dd2a56a0ac326f7d2e48820793cd419" translate="yes" xml:space="preserve">
          <source>When you tell</source>
          <target state="translated">말할 때</target>
        </trans-unit>
        <trans-unit id="1fa91e235bb1e0e43574ae5fec7e6d97da21cd4c" translate="yes" xml:space="preserve">
          <source>When you use &lt;a href=&quot;qfile&quot;&gt;QFile&lt;/a&gt;, &lt;a href=&quot;qfileinfo&quot;&gt;QFileInfo&lt;/a&gt;, and &lt;a href=&quot;qdir&quot;&gt;QDir&lt;/a&gt; to access the file system with Qt, you can use Unicode file names. On Unix, these file names are converted to an 8-bit encoding. If you want to use standard C++ APIs (&lt;code&gt;&amp;lt;cstdio&amp;gt;&lt;/code&gt; or &lt;code&gt;&amp;lt;iostream&amp;gt;&lt;/code&gt;) or platform-specific APIs to access files instead of &lt;a href=&quot;qfile&quot;&gt;QFile&lt;/a&gt;, you can use the &lt;a href=&quot;qfile#encodeName&quot;&gt;encodeName&lt;/a&gt;() and &lt;a href=&quot;qfile#decodeName&quot;&gt;decodeName&lt;/a&gt;() functions to convert between Unicode file names and 8-bit file names.</source>
          <target state="translated">당신이 사용하는 경우 &lt;a href=&quot;qfile&quot;&gt;Qfile을&lt;/a&gt; , &lt;a href=&quot;qfileinfo&quot;&gt;QFileInfo&lt;/a&gt; 및 &lt;a href=&quot;qdir&quot;&gt;QDir을&lt;/a&gt; Qt를 사용하여 파일 시스템에 액세스하려면 유니 코드 파일 이름을 사용할 수 있습니다. Unix에서이 파일 이름은 8 비트 인코딩으로 변환됩니다. &lt;code&gt;&amp;lt;cstdio&amp;gt;&lt;/code&gt; 표준 C ++ API ( &amp;lt;cstdio&amp;gt; 또는 &lt;code&gt;&amp;lt;iostream&amp;gt;&lt;/code&gt; ) 또는 플랫폼 별 API를 사용하여 파일에 액세스 &lt;a href=&quot;qfile&quot;&gt;하려는&lt;/a&gt; 경우 &lt;a href=&quot;qfile#encodeName&quot;&gt;encodeName&lt;/a&gt; () 및 &lt;a href=&quot;qfile#decodeName&quot;&gt;decodeName&lt;/a&gt; () 함수를 사용하여 유니 코드 파일 이름과 8- 비트 파일 이름.</target>
        </trans-unit>
        <trans-unit id="6ed92c03ec92c021add70bc2437e374d7f1ddbaf" translate="yes" xml:space="preserve">
          <source>When you use a layout, you do not need to pass a parent when constructing the child widgets. The layout will automatically reparent the widgets (using &lt;a href=&quot;qwidget#setParent&quot;&gt;QWidget::setParent&lt;/a&gt;()) so that they are children of the widget on which the layout is installed.</source>
          <target state="translated">레이아웃을 사용할 때 자식 위젯을 구성 할 때 부모를 전달할 필요가 없습니다. 레이아웃은 위젯이 자동으로 보호되어 ( &lt;a href=&quot;qwidget#setParent&quot;&gt;QWidget :: setParent&lt;/a&gt; () 사용) 위젯이 레이아웃이 설치된 위젯의 하위가되도록합니다.</target>
        </trans-unit>
        <trans-unit id="da35347dbd73ff3a30bfc301345e76eff709d5d4" translate="yes" xml:space="preserve">
          <source>When you use the &lt;code&gt;debug_and_release&lt;/code&gt; option (which is the default under Windows), the project will be processed three times: one time to produce a &quot;meta&quot; Makefile, and two more times to produce a Makefile.Debug and a Makefile.Release.</source>
          <target state="translated">당신이 사용하는 경우 &lt;code&gt;debug_and_release&lt;/code&gt; 의 Makefile.Debug과 Makefile.Release을 생산하는 &quot;메타&quot;Makefile을 생산 한 번, 두 번 이상 (Windows에서 기본값) 옵션을,이 프로젝트는 세 번 처리됩니다.</target>
        </trans-unit>
        <trans-unit id="60d4ef933d47b492272cf35cd6a80f96f67accbc" translate="yes" xml:space="preserve">
          <source>When you want a list or tree, you typically create an empty &lt;a href=&quot;qstandarditemmodel&quot;&gt;QStandardItemModel&lt;/a&gt; and use &lt;a href=&quot;qstandarditemmodel#appendRow&quot;&gt;appendRow&lt;/a&gt;() to add items to the model, and &lt;a href=&quot;qstandarditemmodel#item&quot;&gt;item&lt;/a&gt;() to access an item. If your model represents a table, you typically pass the dimensions of the table to the &lt;a href=&quot;qstandarditemmodel&quot;&gt;QStandardItemModel&lt;/a&gt; constructor and use &lt;a href=&quot;qstandarditemmodel#setItem&quot;&gt;setItem&lt;/a&gt;() to position items into the table. You can also use &lt;a href=&quot;qstandarditemmodel#setRowCount&quot;&gt;setRowCount&lt;/a&gt;() and &lt;a href=&quot;qstandarditemmodel#setColumnCount&quot;&gt;setColumnCount&lt;/a&gt;() to alter the dimensions of the model. To insert items, use &lt;a href=&quot;qstandarditemmodel#insertRow&quot;&gt;insertRow&lt;/a&gt;() or &lt;a href=&quot;qstandarditemmodel#insertColumn&quot;&gt;insertColumn&lt;/a&gt;(), and to remove items, use &lt;a href=&quot;qabstractitemmodel#removeRow&quot;&gt;removeRow&lt;/a&gt;() or &lt;a href=&quot;qabstractitemmodel#removeColumn&quot;&gt;removeColumn&lt;/a&gt;().</source>
          <target state="translated">목록이나 트리를 원할 경우 일반적으로 빈 &lt;a href=&quot;qstandarditemmodel&quot;&gt;QStandardItemModel을&lt;/a&gt; 작성하고 &lt;a href=&quot;qstandarditemmodel#appendRow&quot;&gt;appendRow&lt;/a&gt; ()를 사용 하여 모델에 항목을 추가하고 &lt;a href=&quot;qstandarditemmodel#item&quot;&gt;item&lt;/a&gt; ()을 사용하여 항목에 액세스하십시오. 모델이 테이블을 나타내는 경우 일반적으로 테이블의 차원을 &lt;a href=&quot;qstandarditemmodel&quot;&gt;QStandardItemModel&lt;/a&gt; 생성자에 전달하고 &lt;a href=&quot;qstandarditemmodel#setItem&quot;&gt;setItem&lt;/a&gt; ()을 사용 하여 항목을 테이블에 배치하십시오. 당신은 또한 사용할 수 있습니다 &lt;a href=&quot;qstandarditemmodel#setRowCount&quot;&gt;에 setRowCount&lt;/a&gt; ()와 &lt;a href=&quot;qstandarditemmodel#setColumnCount&quot;&gt;setColumnCount를&lt;/a&gt; 모델의 크기를 변경 (). 항목을 삽입하려면 &lt;a href=&quot;qstandarditemmodel#insertRow&quot;&gt;insertRow&lt;/a&gt; () 또는 &lt;a href=&quot;qstandarditemmodel#insertColumn&quot;&gt;insertColumn&lt;/a&gt; ()을 사용하고 항목을 제거하려면 &lt;a href=&quot;qabstractitemmodel#removeRow&quot;&gt;removeRow&lt;/a&gt; () 또는 &lt;a href=&quot;qabstractitemmodel#removeColumn&quot;&gt;removeColumn&lt;/a&gt; ()을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="2584a7ed7c056364ed2d913bf3cd8afc1f83ee3b" translate="yes" xml:space="preserve">
          <source>When you want to run a parameterized XQuery from your Qt application, you will need to &lt;a href=&quot;qxmlquery#bindVariable&quot;&gt;bind variables&lt;/a&gt; in your program to $name variables in your XQuery.</source>
          <target state="translated">Qt 애플리케이션에서 매개 변수화 된 XQuery를 실행하려면 프로그램의 변수를 XQuery의 $ name 변수에 &lt;a href=&quot;qxmlquery#bindVariable&quot;&gt;바인딩&lt;/a&gt; 해야합니다 .</target>
        </trans-unit>
        <trans-unit id="78943cac7e531af0096129c5e938f47ed5b0b259" translate="yes" xml:space="preserve">
          <source>When you write your own text input controls, use &lt;a href=&quot;qtextlayout&quot;&gt;QTextLayout&lt;/a&gt;. In some languages (e.g. Arabic or languages from the Indian subcontinent), the width and shape of a glyph changes depending on the surrounding characters, which &lt;a href=&quot;qtextlayout&quot;&gt;QTextLayout&lt;/a&gt; takes into account. Writing input controls usually requires a certain knowledge of the scripts it is going to be used in. Usually the easiest way is to subclass &lt;a href=&quot;qlineedit&quot;&gt;QLineEdit&lt;/a&gt; or &lt;a href=&quot;qtextedit&quot;&gt;QTextEdit&lt;/a&gt;.</source>
          <target state="translated">자체 텍스트 입력 컨트롤을 작성할 때는 &lt;a href=&quot;qtextlayout&quot;&gt;QTextLayout을&lt;/a&gt; 사용 하십시오 . 일부 언어 (예 : 아랍어 또는 인도 아대륙의 언어)에서 글리프의 너비와 모양은 &lt;a href=&quot;qtextlayout&quot;&gt;QTextLayout&lt;/a&gt; 이 고려 하는 주변 문자에 따라 달라집니다 . 입력 컨트롤을 작성하려면 일반적으로 사용되는 스크립트에 대한 특정 지식이 필요합니다. 일반적으로 가장 쉬운 방법은 &lt;a href=&quot;qlineedit&quot;&gt;QLineEdit&lt;/a&gt; 또는 &lt;a href=&quot;qtextedit&quot;&gt;QTextEdit&lt;/a&gt; 를 서브 클래 싱하는 것 입니다.</target>
        </trans-unit>
        <trans-unit id="0fcbb31161cb56fe5288b022cf20ee3adfe4a05b" translate="yes" xml:space="preserve">
          <source>When you're finished changing a record, you should always call &lt;a href=&quot;qsqltablemodel#submitAll&quot;&gt;QSqlTableModel::submitAll&lt;/a&gt;() to ensure that the changes are written to the database.</source>
          <target state="translated">레코드 변경을 완료하면 항상 &lt;a href=&quot;qsqltablemodel#submitAll&quot;&gt;QSqlTableModel :: submitAll&lt;/a&gt; ()을 호출 하여 변경 사항이 데이터베이스에 기록되도록해야합니다.</target>
        </trans-unit>
        <trans-unit id="c483778adddb3d8e4d84a4e99e535203121a7d52" translate="yes" xml:space="preserve">
          <source>When your ActiveX server can also run as a stand-alone application, run the server executable with the &lt;code&gt;-regserver&lt;/code&gt; command line parameter after installing the executable on the target system. After that the controls provided by the server will be available to ActiveX clients.</source>
          <target state="translated">ActiveX 서버가 독립형 응용 프로그램으로도 실행될 수 있으면 대상 시스템에 실행 파일을 설치 한 후 &lt;code&gt;-regserver&lt;/code&gt; 명령 행 매개 변수를 사용하여 서버 실행 파일을 실행하십시오 . 그런 다음 서버에서 제공 한 컨트롤을 ActiveX 클라이언트에서 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="14bd0a3d9cc58e093620fbe1426775b51697ae9b" translate="yes" xml:space="preserve">
          <source>When your ActiveX server is part of an installation package, use the &lt;code&gt;regsvr32&lt;/code&gt; tool provided by Microsoft to register the controls on the target system. If this tool is not present, load the DLL into your installer process, resolve the &lt;code&gt;DllRegisterServer&lt;/code&gt; symbol and call the function:</source>
          <target state="translated">ActiveX 서버가 설치 패키지의 일부인 경우 Microsoft에서 제공 하는 &lt;code&gt;regsvr32&lt;/code&gt; 도구를 사용 하여 대상 시스템에 컨트롤을 등록하십시오. 이 도구가 없으면 DLL을 설치 프로그램 프로세스에로드하고 &lt;code&gt;DllRegisterServer&lt;/code&gt; 기호를 해결 한 후 함수를 호출하십시오.</target>
        </trans-unit>
        <trans-unit id="027ec3bc4d20f0e86797e47980aa9a9475deabbe" translate="yes" xml:space="preserve">
          <source>Whenever `processTextMessage()` is triggered, we retrieve the sender, and if valid, send back the original message (`sendTextMessage()`). The same is done with binary messages.</source>
          <target state="translated">`processTextMessage ()`가 트리거 될 때마다 발신자를 검색하고 유효한 경우 원래 메시지 (`sendTextMessage ()`)를 다시 보냅니다. 이진 메시지에서도 마찬가지입니다.</target>
        </trans-unit>
        <trans-unit id="3cd3563583d0b4557a8fb5a3af277b71d7d4fa6f" translate="yes" xml:space="preserve">
          <source>Whenever a &lt;a href=&quot;qml-qtquick-controls-checkbox&quot;&gt;CheckBox&lt;/a&gt; is clicked, it emits the &lt;a href=&quot;qml-qtquick-controls-checkbox#clicked-signal&quot;&gt;clicked()&lt;/a&gt; signal.</source>
          <target state="translated">&lt;a href=&quot;qml-qtquick-controls-checkbox&quot;&gt;CheckBox&lt;/a&gt; 를 클릭 할 때마다 &lt;a href=&quot;qml-qtquick-controls-checkbox#clicked-signal&quot;&gt;clicked ()&lt;/a&gt; 신호가 발생합니다 .</target>
        </trans-unit>
        <trans-unit id="53a69c8a1f964bb9777baba93c7827da52f72065" translate="yes" xml:space="preserve">
          <source>Whenever a button is switched on or off, it emits the &lt;a href=&quot;qabstractbutton#toggled&quot;&gt;toggled&lt;/a&gt;() signal. Connect to this signal if you want to trigger an action each time the button changes state. Use &lt;a href=&quot;qabstractbutton#checked-prop&quot;&gt;isChecked&lt;/a&gt;() to see if a particular button is selected.</source>
          <target state="translated">버튼을 켜거나 끌 때마다 &lt;a href=&quot;qabstractbutton#toggled&quot;&gt;토글&lt;/a&gt; () 신호가 발생합니다 . 버튼 상태가 바뀔 때마다 동작을 트리거하려면이 신호에 연결하십시오. &lt;a href=&quot;qabstractbutton#checked-prop&quot;&gt;isChecked&lt;/a&gt; ()를 사용 하여 특정 버튼이 선택되어 있는지 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="98df15d5cd2ca206ae0b777515f1789f82058d70" translate="yes" xml:space="preserve">
          <source>Whenever a checkbox is checked or cleared, it emits the signal &lt;a href=&quot;qcheckbox#stateChanged&quot;&gt;stateChanged&lt;/a&gt;(). Connect to this signal if you want to trigger an action each time the checkbox changes state. You can use &lt;a href=&quot;qabstractbutton#checked-prop&quot;&gt;isChecked&lt;/a&gt;() to query whether or not a checkbox is checked.</source>
          <target state="translated">확인란을 선택하거나 지울 때마다 &lt;a href=&quot;qcheckbox#stateChanged&quot;&gt;stateChanged&lt;/a&gt; () 신호가 발생합니다 . 확인란의 상태가 바뀔 때마다 작업을 트리거하려면이 신호에 연결하십시오. &lt;a href=&quot;qabstractbutton#checked-prop&quot;&gt;isChecked&lt;/a&gt; ()를 사용 하여 확인란의 선택 여부를 쿼리 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="622050ab0f3753e8f422b1fec5fa59fed4693f03" translate="yes" xml:space="preserve">
          <source>Whenever a help event occurs, this function is called with the</source>
          <target state="translated">도움말 이벤트가 발생할 때마다이 함수는</target>
        </trans-unit>
        <trans-unit id="695fe6b59174187c21971601195bbbdc7ae00fac" translate="yes" xml:space="preserve">
          <source>Whenever a message is received, we write it out.</source>
          <target state="translated">메시지가 수신 될 때마다 메시지를 작성합니다.</target>
        </trans-unit>
        <trans-unit id="90fe0cc17049ffdb58a0f22d6b9f296fcdc96921" translate="yes" xml:space="preserve">
          <source>Whenever a new frame is available in the movie, &lt;a href=&quot;qmovie&quot;&gt;QMovie&lt;/a&gt; will emit &lt;a href=&quot;qmovie#updated&quot;&gt;updated&lt;/a&gt;(). If the size of the frame changes, &lt;a href=&quot;qmovie#resized&quot;&gt;resized&lt;/a&gt;() is emitted. You can call &lt;a href=&quot;qmovie#currentImage&quot;&gt;currentImage&lt;/a&gt;() or &lt;a href=&quot;qmovie#currentPixmap&quot;&gt;currentPixmap&lt;/a&gt;() to get a copy of the current frame. When the movie is done, &lt;a href=&quot;qmovie&quot;&gt;QMovie&lt;/a&gt; emits &lt;a href=&quot;qmovie#finished&quot;&gt;finished&lt;/a&gt;(). If any error occurs during playback (i.e, the image file is corrupt), &lt;a href=&quot;qmovie&quot;&gt;QMovie&lt;/a&gt; will emit &lt;a href=&quot;qmovie#error&quot;&gt;error&lt;/a&gt;().</source>
          <target state="translated">동영상에서 새 프레임을 사용할 수있을 때마다 &lt;a href=&quot;qmovie&quot;&gt;QMovie&lt;/a&gt; 는 &lt;a href=&quot;qmovie#updated&quot;&gt;업데이트 된&lt;/a&gt; () 을 방출 합니다. 프레임 크기가 변경되면 &lt;a href=&quot;qmovie#resized&quot;&gt;크기 조정&lt;/a&gt; ()이 방출됩니다. &lt;a href=&quot;qmovie#currentImage&quot;&gt;currentImage&lt;/a&gt; () 또는 &lt;a href=&quot;qmovie#currentPixmap&quot;&gt;currentPixmap&lt;/a&gt; ()을 호출 하여 현재 프레임의 복사본을 얻을 수 있습니다. 동영상이 완료되면, &lt;a href=&quot;qmovie&quot;&gt;QMovie의&lt;/a&gt; 를 방출이 &lt;a href=&quot;qmovie#finished&quot;&gt;종료&lt;/a&gt; (). 오류가 (즉, 이미지 파일이 손상) 재생 중에 발생하면 &lt;a href=&quot;qmovie&quot;&gt;QMovie가&lt;/a&gt; 방출됩니다 &lt;a href=&quot;qmovie#error&quot;&gt;오류를&lt;/a&gt; ().</target>
        </trans-unit>
        <trans-unit id="ce06d5f1ff8e225d1adc268c9cdd8c9e9dc54f82" translate="yes" xml:space="preserve">
          <source>Whenever a socket is disconnected, we remove it from the clients list and delete the socket. Note: it is best to use `deleteLater()` to delete the socket.</source>
          <target state="translated">소켓이 연결 해제 될 때마다 클라이언트 목록에서 소켓을 제거하고 소켓을 삭제합니다. 참고 : 소켓을 삭제하려면`deleteLater ()`를 사용하는 것이 가장 좋습니다.</target>
        </trans-unit>
        <trans-unit id="73df17f4d1de1623ad4e92d56228608091517aaf" translate="yes" xml:space="preserve">
          <source>Whenever a widget loses focus, the widget's current value is set to the item model.</source>
          <target state="translated">위젯이 포커스를 잃을 때마다 위젯의 현재 값이 항목 모델로 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="aeeb8caf9d0b96887fbffb95f418d29cecb00031" translate="yes" xml:space="preserve">
          <source>Whenever an item is added to the above view, all items beneath the new item are displaced, causing them to move down (or sideways, if horizontally orientated) within the view. As this displacement occurs, the items' movement to their new x,y positions within the view will be animated by a &lt;a href=&quot;qml-qtquick-numberanimation&quot;&gt;NumberAnimation&lt;/a&gt; over one second, as specified. This transition is not applied to the new item that has been added to the view; to animate the added items, set the &lt;a href=&quot;qml-qtquick-gridview#add-signal&quot;&gt;add&lt;/a&gt; property.</source>
          <target state="translated">항목이 위의보기에 추가 될 때마다 새 항목 아래의 모든 항목이 이동하여보기 내에서 아래로 (또는 가로 방향 인 경우 옆으로) 이동합니다. 이 변위가 발생하면 뷰 내에서 새로운 x, y 위치로의 항목 이동 은 지정된대로 1 초 동안 &lt;a href=&quot;qml-qtquick-numberanimation&quot;&gt;NumberAnimation&lt;/a&gt; 에 의해 애니메이션됩니다 . 이 전환은보기에 추가 된 새 항목에는 적용되지 않습니다. 추가 된 항목에 애니메이션을 적용하려면 &lt;a href=&quot;qml-qtquick-gridview#add-signal&quot;&gt;add&lt;/a&gt; 속성을 설정하십시오 .</target>
        </trans-unit>
        <trans-unit id="78d2be573356e883c161ace1948bad51ebd33c75" translate="yes" xml:space="preserve">
          <source>Whenever an item is added to the above view, all items beneath the new item are displaced, causing them to move down (or sideways, if horizontally orientated) within the view. As this displacement occurs, the items' movement to their new x,y positions within the view will be animated by a &lt;a href=&quot;qml-qtquick-numberanimation&quot;&gt;NumberAnimation&lt;/a&gt; over one second, as specified. This transition is not applied to the new item that has been added to the view; to animate the added items, set the &lt;a href=&quot;qml-qtquick-listview#add-signal&quot;&gt;add&lt;/a&gt; property.</source>
          <target state="translated">항목이 위의보기에 추가 될 때마다 새 항목 아래의 모든 항목이 이동하여보기 내에서 아래로 (또는 가로 방향 인 경우 옆으로) 이동합니다. 이 변위가 발생하면 뷰 내에서 새로운 x, y 위치로의 항목 이동 은 지정된대로 1 초 동안 &lt;a href=&quot;qml-qtquick-numberanimation&quot;&gt;NumberAnimation&lt;/a&gt; 에 의해 애니메이션됩니다 . 이 전환은보기에 추가 된 새 항목에는 적용되지 않습니다. 추가 된 항목에 애니메이션을 적용하려면 &lt;a href=&quot;qml-qtquick-listview#add-signal&quot;&gt;add&lt;/a&gt; 속성을 설정하십시오 .</target>
        </trans-unit>
        <trans-unit id="a92651cada4705e95a6599aa36b9830bb5133d4d" translate="yes" xml:space="preserve">
          <source>Whenever an item is added to the above view, the item will be animated from the position (100,100) to its final x,y position within the view, over one second. The transition only applies to the new items that are added to the view; it does not apply to the items below that are displaced by the addition of the new items. To animate the displaced items, set the &lt;a href=&quot;qml-qtquick-gridview#displaced-prop&quot;&gt;displaced&lt;/a&gt; or &lt;a href=&quot;qml-qtquick-gridview#addDisplaced-prop&quot;&gt;addDisplaced&lt;/a&gt; properties.</source>
          <target state="translated">항목이 위의보기에 추가 될 때마다 항목이 위치 (100,100)에서보기 내의 마지막 x, y 위치로 1 초 이상 애니메이션됩니다. 전환은보기에 추가 된 새 항목에만 적용됩니다. 새 항목을 추가하여 대체 된 아래 항목에는 적용되지 않습니다. 변위 된 항목에 애니메이션을 적용하려면 &lt;a href=&quot;qml-qtquick-gridview#displaced-prop&quot;&gt;변위&lt;/a&gt; 또는 &lt;a href=&quot;qml-qtquick-gridview#addDisplaced-prop&quot;&gt;addDisplaced&lt;/a&gt; 속성을 설정하십시오 .</target>
        </trans-unit>
        <trans-unit id="fedd4c064ea3bd87026e3e226e4cb864f52ee584" translate="yes" xml:space="preserve">
          <source>Whenever an item is added to the above view, the item will be animated from the position (100,100) to its final x,y position within the view, over one second. The transition only applies to the new items that are added to the view; it does not apply to the items below that are displaced by the addition of the new items. To animate the displaced items, set the &lt;a href=&quot;qml-qtquick-listview#displaced-prop&quot;&gt;displaced&lt;/a&gt; or &lt;a href=&quot;qml-qtquick-listview#addDisplaced-prop&quot;&gt;addDisplaced&lt;/a&gt; properties.</source>
          <target state="translated">항목이 위의보기에 추가 될 때마다 항목이 위치 (100,100)에서보기 내의 마지막 x, y 위치로 1 초 이상 애니메이션됩니다. 전환은보기에 추가 된 새 항목에만 적용됩니다. 새 항목을 추가하여 대체 된 아래 항목에는 적용되지 않습니다. 변위 된 항목에 애니메이션을 적용하려면 &lt;a href=&quot;qml-qtquick-listview#displaced-prop&quot;&gt;변위&lt;/a&gt; 또는 &lt;a href=&quot;qml-qtquick-listview#addDisplaced-prop&quot;&gt;addDisplaced&lt;/a&gt; 속성을 설정하십시오 .</target>
        </trans-unit>
        <trans-unit id="9ee2054577a98ab0392d1b4d7970f9f828507766" translate="yes" xml:space="preserve">
          <source>Whenever an item is removed from the above view, all items beneath it are displaced, causing them to move upwards (or sideways, if horizontally orientated) within the view. As this displacement occurs, the items' movement to their new x,y positions within the view will be animated by a &lt;a href=&quot;qml-qtquick-numberanimation&quot;&gt;NumberAnimation&lt;/a&gt; over one second, as specified. This transition is not applied to the item that has actually been removed from the view; to animate the removed items, set the &lt;a href=&quot;qml-qtquick-gridview#remove-signal&quot;&gt;remove&lt;/a&gt; property.</source>
          <target state="translated">위의보기에서 항목을 제거 할 때마다 그 아래에있는 모든 항목이 이동하여보기 내에서 위쪽 (또는 가로 방향 인 경우 옆으로) 이동합니다. 이 변위가 발생하면 뷰 내에서 새로운 x, y 위치로의 항목 이동 은 지정된대로 1 초 동안 &lt;a href=&quot;qml-qtquick-numberanimation&quot;&gt;NumberAnimation&lt;/a&gt; 에 의해 애니메이션됩니다 . 이 전환은 실제로보기에서 제거 된 항목에는 적용되지 않습니다. 제거 된 항목에 애니메이션을 적용하려면 &lt;a href=&quot;qml-qtquick-gridview#remove-signal&quot;&gt;remove&lt;/a&gt; 속성을 설정하십시오 .</target>
        </trans-unit>
        <trans-unit id="cdeea51a30e773755896b273b1df58c42cfa78ae" translate="yes" xml:space="preserve">
          <source>Whenever an item is removed from the above view, all items beneath it are displaced, causing them to move upwards (or sideways, if horizontally orientated) within the view. As this displacement occurs, the items' movement to their new x,y positions within the view will be animated by a &lt;a href=&quot;qml-qtquick-numberanimation&quot;&gt;NumberAnimation&lt;/a&gt; over one second, as specified. This transition is not applied to the item that has actually been removed from the view; to animate the removed items, set the &lt;a href=&quot;qml-qtquick-listview#remove-signal&quot;&gt;remove&lt;/a&gt; property.</source>
          <target state="translated">위의보기에서 항목을 제거 할 때마다 그 아래에있는 모든 항목이 이동하여보기 내에서 위쪽 (또는 가로 방향 인 경우 옆으로) 이동합니다. 이 변위가 발생하면 뷰 내에서 새로운 x, y 위치로의 항목 이동 은 지정된대로 1 초 동안 &lt;a href=&quot;qml-qtquick-numberanimation&quot;&gt;NumberAnimation&lt;/a&gt; 에 의해 애니메이션됩니다 . 이 전환은 실제로보기에서 제거 된 항목에는 적용되지 않습니다. 제거 된 항목에 애니메이션을 적용하려면 &lt;a href=&quot;qml-qtquick-listview#remove-signal&quot;&gt;remove&lt;/a&gt; 속성을 설정하십시오 .</target>
        </trans-unit>
        <trans-unit id="67676ecbc12193a248e3d1903f192afb7d8ef887" translate="yes" xml:space="preserve">
          <source>Whenever an item is removed from the above view, the item will be animated to the position (100,100) over one second, and in parallel will also change its opacity to 0. The transition only applies to the items that are removed from the view; it does not apply to the items below them that are displaced by the removal of the items. To animate the displaced items, set the &lt;a href=&quot;qml-qtquick-gridview#displaced-prop&quot;&gt;displaced&lt;/a&gt; or &lt;a href=&quot;qml-qtquick-gridview#removeDisplaced-prop&quot;&gt;removeDisplaced&lt;/a&gt; properties.</source>
          <target state="translated">항목이 위의보기에서 제거 될 때마다 항목은 1 초에 걸쳐 위치 (100,100)로 애니메이션되며 불투명도 0으로 변경됩니다. 전환은보기에서 제거 된 항목에만 적용됩니다. 품목을 제거하여 대체 된 품목은 아래 품목에는 적용되지 않습니다. 실향민 항목을 애니메이션하려면 설정 &lt;a href=&quot;qml-qtquick-gridview#displaced-prop&quot;&gt;난민&lt;/a&gt; 또는 &lt;a href=&quot;qml-qtquick-gridview#removeDisplaced-prop&quot;&gt;removeDisplaced&lt;/a&gt; 속성을.</target>
        </trans-unit>
        <trans-unit id="2afd00d420f68d960660023e82ce1e61cc08329e" translate="yes" xml:space="preserve">
          <source>Whenever an item is removed from the above view, the item will be animated to the position (100,100) over one second, and in parallel will also change its opacity to 0. The transition only applies to the items that are removed from the view; it does not apply to the items below them that are displaced by the removal of the items. To animate the displaced items, set the &lt;a href=&quot;qml-qtquick-listview#displaced-prop&quot;&gt;displaced&lt;/a&gt; or &lt;a href=&quot;qml-qtquick-listview#removeDisplaced-prop&quot;&gt;removeDisplaced&lt;/a&gt; properties.</source>
          <target state="translated">항목이 위의보기에서 제거 될 때마다 항목은 1 초에 걸쳐 위치 (100,100)로 애니메이션되며 불투명도 0으로 변경됩니다. 전환은보기에서 제거 된 항목에만 적용됩니다. 품목을 제거하여 대체 된 품목은 아래 품목에는 적용되지 않습니다. 실향민 항목을 애니메이션하려면 설정 &lt;a href=&quot;qml-qtquick-listview#displaced-prop&quot;&gt;난민&lt;/a&gt; 또는 &lt;a href=&quot;qml-qtquick-listview#removeDisplaced-prop&quot;&gt;removeDisplaced&lt;/a&gt; 속성을.</target>
        </trans-unit>
        <trans-unit id="cfc98cc90a563ec8a39f14335a650018c11cc6a6" translate="yes" xml:space="preserve">
          <source>Whenever an object has a property of type URL (&lt;a href=&quot;qurl&quot;&gt;QUrl&lt;/a&gt;), assigning a string to that property will actually assign an absolute URL - by resolving the string against the URL of the document where the string is used.</source>
          <target state="translated">객체에 URL 유형 ( &lt;a href=&quot;qurl&quot;&gt;QUrl&lt;/a&gt; ) 의 속성이있을 때마다 해당 속성에 문자열을 할당하면 문자열이 사용되는 문서의 URL에 대해 문자열을 확인하여 실제로 절대 URL을 할당합니다.</target>
        </trans-unit>
        <trans-unit id="40cd1e35d67f7694a72feed5daaea2235bf6410d" translate="yes" xml:space="preserve">
          <source>Whenever making decisions regarding memory allocation or performance trade-offs, it is important to keep in mind the impact of CPU-cache performance, operating system paging, and JavaScript engine garbage collection. Potential solutions should be benchmarked carefully in order to ensure that the best one is selected.</source>
          <target state="translated">메모리 할당 또는 성능 균형에 관한 결정을 내릴 때마다 CPU 캐시 성능, 운영 체제 페이징 및 JavaScript 엔진 가비지 수집의 영향을 명심해야합니다. 최상의 솔루션을 선택하려면 잠재적 솔루션을 신중하게 벤치마킹해야합니다.</target>
        </trans-unit>
        <trans-unit id="6a3c3d9411e762b86fd3a5863bcca1bdd7dc8c51" translate="yes" xml:space="preserve">
          <source>Whenever possible, use the</source>
          <target state="translated">가능하면</target>
        </trans-unit>
        <trans-unit id="b69002a47278bca07bf9cc0356566ca80fcfbcc1" translate="yes" xml:space="preserve">
          <source>Whenever re-applying data obtained with QUrl::FullyDecoded into a &lt;a href=&quot;qurl&quot;&gt;QUrl&lt;/a&gt;, care must be taken to use the &lt;a href=&quot;qurl#ParsingMode-enum&quot;&gt;QUrl::DecodedMode&lt;/a&gt; parameter to the setters (like &lt;a href=&quot;qurl#setPath&quot;&gt;setPath&lt;/a&gt;() and &lt;a href=&quot;qurl#setUserName&quot;&gt;setUserName&lt;/a&gt;()). Failure to do so may cause re-interpretation of the percent character ('%') as the beginning of a percent-encoded sequence.</source>
          <target state="translated">QUrl 얻어 재 적용 데이터 :에 FullyDecoded 때마다 &lt;a href=&quot;qurl&quot;&gt;QUrl&lt;/a&gt; 주의는 사용주의해야합니다 &lt;a href=&quot;qurl#ParsingMode-enum&quot;&gt;QUrl :: DecodedMode의&lt;/a&gt; 세터 (등으로 매개 변수를 &lt;a href=&quot;qurl#setPath&quot;&gt;setPath&lt;/a&gt; () 및 &lt;a href=&quot;qurl#setUserName&quot;&gt;setUserName&lt;/a&gt; ()). 그렇지 않으면 퍼센트 인코딩 된 시퀀스의 시작으로 퍼센트 문자 ( '%')가 다시 해석 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7197f3cbde6d24213802f4f813e9afce6114c878" translate="yes" xml:space="preserve">
          <source>Whenever the &lt;a href=&quot;qml-qtquick-gridview#model-prop&quot;&gt;model&lt;/a&gt; performs a move operation to move a particular set of indexes, the items between the source and destination indexes of the move operation are displaced, causing them to move upwards or downwards (or sideways, if horizontally orientated) within the view. As this displacement occurs, the items' movement to their new x,y positions within the view will be animated by a &lt;a href=&quot;qml-qtquick-numberanimation&quot;&gt;NumberAnimation&lt;/a&gt; over one second, as specified. This transition is not applied to the items that are the actual subjects of the move operation; to animate the moved items, set the &lt;a href=&quot;qml-qtquick-gridview#move-prop&quot;&gt;move&lt;/a&gt; property.</source>
          <target state="translated">&lt;a href=&quot;qml-qtquick-gridview#model-prop&quot;&gt;모델&lt;/a&gt; 이 특정 인덱스 집합을 이동하기 위해 이동 작업을 수행 할 때마다 이동 작업의 소스 및 대상 인덱스 사이의 항목이 이동하여 뷰 내에서 위쪽 또는 아래쪽 (또는 가로 방향 인 경우 옆으로) 이동합니다. 이 변위가 발생하면 뷰 내에서 새로운 x, y 위치로의 항목 이동 은 지정된대로 1 초 동안 &lt;a href=&quot;qml-qtquick-numberanimation&quot;&gt;NumberAnimation&lt;/a&gt; 에 의해 애니메이션됩니다 . 이 전환은 이동 작업의 실제 주제 인 항목에는 적용되지 않습니다. 이동 한 항목에 애니메이션을 적용하려면 &lt;a href=&quot;qml-qtquick-gridview#move-prop&quot;&gt;이동&lt;/a&gt; 속성을 설정하십시오 .</target>
        </trans-unit>
        <trans-unit id="4eafa499c61ca66b47ae5a64ffa25154048cdb36" translate="yes" xml:space="preserve">
          <source>Whenever the &lt;a href=&quot;qml-qtquick-gridview#model-prop&quot;&gt;model&lt;/a&gt; performs a move operation to move a particular set of indexes, the respective items in the view will be animated to their new positions in the view over one second. The transition only applies to the items that are the subject of the move operation in the model; it does not apply to items below them that are displaced by the move operation. To animate the displaced items, set the &lt;a href=&quot;qml-qtquick-gridview#displaced-prop&quot;&gt;displaced&lt;/a&gt; or &lt;a href=&quot;qml-qtquick-gridview#moveDisplaced-prop&quot;&gt;moveDisplaced&lt;/a&gt; properties.</source>
          <target state="translated">&lt;a href=&quot;qml-qtquick-gridview#model-prop&quot;&gt;모델&lt;/a&gt; 이 특정 인덱스 집합을 이동하기 위해 이동 작업을 수행 할 때마다 뷰의 각 항목이 1 초 동안 뷰의 새로운 위치로 애니메이션됩니다. 전환은 모델에서 이동 작업의 대상이되는 항목에만 적용됩니다. 이동 조작으로 인해 변위 된 항목 아래에는 적용되지 않습니다. 변위 된 항목에 애니메이션을 적용하려면 &lt;a href=&quot;qml-qtquick-gridview#displaced-prop&quot;&gt;변위&lt;/a&gt; 또는 &lt;a href=&quot;qml-qtquick-gridview#moveDisplaced-prop&quot;&gt;moveDisplaced&lt;/a&gt; 속성을 설정하십시오 .</target>
        </trans-unit>
        <trans-unit id="c1337f1735bc8b49ad5d3a854d08f4521666286f" translate="yes" xml:space="preserve">
          <source>Whenever the &lt;a href=&quot;qml-qtquick-listview#model-prop&quot;&gt;model&lt;/a&gt; performs a move operation to move a particular set of indexes, the items between the source and destination indexes of the move operation are displaced, causing them to move upwards or downwards (or sideways, if horizontally orientated) within the view. As this displacement occurs, the items' movement to their new x,y positions within the view will be animated by a &lt;a href=&quot;qml-qtquick-numberanimation&quot;&gt;NumberAnimation&lt;/a&gt; over one second, as specified. This transition is not applied to the items that are the actual subjects of the move operation; to animate the moved items, set the &lt;a href=&quot;qml-qtquick-listview#move-prop&quot;&gt;move&lt;/a&gt; property.</source>
          <target state="translated">&lt;a href=&quot;qml-qtquick-listview#model-prop&quot;&gt;모델&lt;/a&gt; 이 특정 인덱스 집합을 이동하기 위해 이동 작업을 수행 할 때마다 이동 작업의 소스 및 대상 인덱스 사이의 항목이 이동하여 뷰 내에서 위쪽 또는 아래쪽 (또는 가로 방향 인 경우 옆으로) 이동합니다. 이 변위가 발생하면 뷰 내에서 새로운 x, y 위치로의 항목 이동 은 지정된대로 1 초 동안 &lt;a href=&quot;qml-qtquick-numberanimation&quot;&gt;NumberAnimation&lt;/a&gt; 에 의해 애니메이션됩니다 . 이 전환은 이동 작업의 실제 주제 인 항목에는 적용되지 않습니다. 이동 한 항목에 애니메이션을 적용하려면 &lt;a href=&quot;qml-qtquick-listview#move-prop&quot;&gt;이동&lt;/a&gt; 속성을 설정하십시오 .</target>
        </trans-unit>
        <trans-unit id="ae168b2b3b3e8491daed829e8981a3546f712af4" translate="yes" xml:space="preserve">
          <source>Whenever the &lt;a href=&quot;qml-qtquick-listview#model-prop&quot;&gt;model&lt;/a&gt; performs a move operation to move a particular set of indexes, the respective items in the view will be animated to their new positions in the view over one second. The transition only applies to the items that are the subject of the move operation in the model; it does not apply to items below them that are displaced by the move operation. To animate the displaced items, set the &lt;a href=&quot;qml-qtquick-listview#displaced-prop&quot;&gt;displaced&lt;/a&gt; or &lt;a href=&quot;qml-qtquick-listview#moveDisplaced-prop&quot;&gt;moveDisplaced&lt;/a&gt; properties.</source>
          <target state="translated">&lt;a href=&quot;qml-qtquick-listview#model-prop&quot;&gt;모델&lt;/a&gt; 이 특정 인덱스 집합을 이동하기 위해 이동 작업을 수행 할 때마다 뷰의 각 항목이 1 초 동안 뷰의 새로운 위치로 애니메이션됩니다. 전환은 모델에서 이동 작업의 대상이되는 항목에만 적용됩니다. 이동 조작으로 인해 변위 된 항목 아래에는 적용되지 않습니다. 변위 된 항목에 애니메이션을 적용하려면 &lt;a href=&quot;qml-qtquick-listview#displaced-prop&quot;&gt;변위&lt;/a&gt; 또는 &lt;a href=&quot;qml-qtquick-listview#moveDisplaced-prop&quot;&gt;moveDisplaced&lt;/a&gt; 속성을 설정하십시오 .</target>
        </trans-unit>
        <trans-unit id="312d51cc1df09e3da5c1a58d9d776f953d5789e4" translate="yes" xml:space="preserve">
          <source>Whenever the &lt;a href=&quot;qml-qtquick-taphandler&quot;&gt;TapHandler&lt;/a&gt;'s &lt;code&gt;tapped&lt;/code&gt; signal is emitted, the &lt;code&gt;send&lt;/code&gt; signal will automatically be emitted as well.</source>
          <target state="translated">&lt;a href=&quot;qml-qtquick-taphandler&quot;&gt;TapHandler&lt;/a&gt; 의 &lt;code&gt;tapped&lt;/code&gt; 신호가 방출 될 때마다 &lt;code&gt;send&lt;/code&gt; 신호도 자동으로 방출됩니다.</target>
        </trans-unit>
        <trans-unit id="9576aa0bc72ea121c51b19950d20787edffca2bb" translate="yes" xml:space="preserve">
          <source>Whenever the current widget in the layout changes or a widget is removed from the layout, the &lt;a href=&quot;qstackedlayout#currentChanged&quot;&gt;currentChanged&lt;/a&gt;() and &lt;a href=&quot;qstackedlayout#widgetRemoved&quot;&gt;widgetRemoved&lt;/a&gt;() signals are emitted respectively.</source>
          <target state="translated">레이아웃의 현재 위젯이 변경되거나 위젯이 레이아웃에서 제거 될 때마다 &lt;a href=&quot;qstackedlayout#currentChanged&quot;&gt;currentChanged&lt;/a&gt; () 및 &lt;a href=&quot;qstackedlayout#widgetRemoved&quot;&gt;widgetRemoved&lt;/a&gt; () 신호가 각각 방출됩니다.</target>
        </trans-unit>
        <trans-unit id="2fcf7292f793de5fb0c3b7f25d1338a1fbc959c5" translate="yes" xml:space="preserve">
          <source>Whenever the current widget in the stacked widget changes or a widget is removed from the stacked widget, the &lt;a href=&quot;qstackedwidget#currentChanged&quot;&gt;currentChanged&lt;/a&gt;() and &lt;a href=&quot;qstackedwidget#widgetRemoved&quot;&gt;widgetRemoved&lt;/a&gt;() signals are emitted respectively.</source>
          <target state="translated">스택 위젯의 현재 위젯이 변경되거나 위젯이 스택 위젯에서 제거 될 때마다 &lt;a href=&quot;qstackedwidget#currentChanged&quot;&gt;currentChanged&lt;/a&gt; () 및 &lt;a href=&quot;qstackedwidget#widgetRemoved&quot;&gt;widgetRemoved&lt;/a&gt; () 신호가 각각 방출됩니다.</target>
        </trans-unit>
        <trans-unit id="1c80e7b5c4fae4e99cfb0927909f6c46e4768a09" translate="yes" xml:space="preserve">
          <source>Whenever the height of the parent rectangle changes, the height of the blue rectangle automatically updates to be of the same value.</source>
          <target state="translated">부모 사각형의 높이가 변경 될 때마다 파란색 사각형의 높이가 동일한 값으로 자동 업데이트됩니다.</target>
        </trans-unit>
        <trans-unit id="6af29bff3595f2471deb90ce61a0ea67813b87c4" translate="yes" xml:space="preserve">
          <source>Whenever the stack returns to this state through the use of undo/redo commands, it emits the signal &lt;a href=&quot;qundostack#cleanChanged&quot;&gt;cleanChanged&lt;/a&gt;(). This signal is also emitted when the stack leaves the clean state.</source>
          <target state="translated">실행 취소 / 다시 실행 명령을 사용하여 스택이이 상태로 돌아올 때마다 &lt;a href=&quot;qundostack#cleanChanged&quot;&gt;cleanChanged&lt;/a&gt; () 신호가 발생합니다 . 이 신호는 스택이 클린 상태를 벗어날 때도 방출됩니다.</target>
        </trans-unit>
        <trans-unit id="1e1b23a9100f3611f6cf8c3c148eab441d5bca9d" translate="yes" xml:space="preserve">
          <source>Where &quot;example&quot; is the identifier to use to uniquely identify this set of tests. Finally, add &lt;code&gt;CONFIG += qmltestcase&lt;/code&gt; to the project file:</source>
          <target state="translated">여기서 &quot;example&quot;은이 테스트 집합을 고유하게 식별하는 데 사용되는 식별자입니다. 마지막으로, &lt;code&gt;CONFIG += qmltestcase&lt;/code&gt; 를 프로젝트 파일에 추가 하십시오 :</target>
        </trans-unit>
        <trans-unit id="4e60e5656f07f947fa3b6795e9084ca0fb310950" translate="yes" xml:space="preserve">
          <source>Where &lt;code&gt;&amp;lt;port_number&amp;gt;&lt;/code&gt; refers to a local network port. The web developer tools can then be accessed by launching a browser at the address &lt;code&gt;http://localhost:&amp;lt;port_number&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">여기서 &lt;code&gt;&amp;lt;port_number&amp;gt;&lt;/code&gt; 는 로컬 네트워크 포트를 나타냅니다. 그런 다음 &lt;code&gt;http://localhost:&amp;lt;port_number&amp;gt;&lt;/code&gt; 주소에서 브라우저를 시작하여 웹 개발자 도구에 액세스 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="1ccb20ef56eb59f145da42f8c73e2d50a4d5c84e" translate="yes" xml:space="preserve">
          <source>Where Java and C++ are</source>
          <target state="translated">Java와 C ++가있는 곳</target>
        </trans-unit>
        <trans-unit id="a4126a2b85566e3cc6be9c07a1704ba767059ac6" translate="yes" xml:space="preserve">
          <source>Where a traditional 2D API, such as &lt;a href=&quot;qpainter&quot;&gt;QPainter&lt;/a&gt;, Cairo or &lt;a href=&quot;qml-qtquick-context2d&quot;&gt;Context2D&lt;/a&gt;, is written to handle thousands of individual draw calls per frame, OpenGL is a pure hardware API and performs best when the number of draw calls is very low and state changes are kept to a minimum. Consider the following use case:</source>
          <target state="translated">&lt;a href=&quot;qpainter&quot;&gt;QPainter&lt;/a&gt; , Cairo 또는 &lt;a href=&quot;qml-qtquick-context2d&quot;&gt;Context2D&lt;/a&gt; 와 같은 전통적인 2D API 가 프레임 당 수천 개의 개별 그리기 호출을 처리하도록 작성된 경우 OpenGL은 순수한 하드웨어 API이며 그리기 호출 수가 매우 적고 상태 변경이 유지 될 때 가장 잘 수행됩니다. 최소한. 다음 사용 사례를 고려하십시오.</target>
        </trans-unit>
        <trans-unit id="d1c4c915ffa0d273da9dcbd143eb982e3969434e" translate="yes" xml:space="preserve">
          <source>Where rotation around an axis is used, the rotation shall be expressed as a Right Hand rotation.</source>
          <target state="translated">축을 중심으로 한 회전이 사용되는 경우 회전은 오른손 회전으로 표현됩니다.</target>
        </trans-unit>
        <trans-unit id="952ee39a9cfff990fc53dd4027e5610fab89057e" translate="yes" xml:space="preserve">
          <source>Where the &lt;a href=&quot;qsgmaterial&quot;&gt;QSGMaterial&lt;/a&gt; and &lt;a href=&quot;qsgmaterialshader&quot;&gt;QSGMaterialShader&lt;/a&gt; API requires a bit of boilerplate code to create a functioning material, the &lt;a href=&quot;qsgsimplematerialshader&quot;&gt;QSGSimpleMaterialShader&lt;/a&gt; tries to hide some of this through the use of templates.</source>
          <target state="translated">를 Where &lt;a href=&quot;qsgmaterial&quot;&gt;QSGMaterial&lt;/a&gt; 및 &lt;a href=&quot;qsgmaterialshader&quot;&gt;QSGMaterialShader&lt;/a&gt; API가 작동하는 자료를 작성하는 상용구 코드의 비트가 필요의 &lt;a href=&quot;qsgsimplematerialshader&quot;&gt;QSGSimpleMaterialShader는&lt;/a&gt; 템플릿의 사용을 통해이 중 일부를 숨길려고합니다.</target>
        </trans-unit>
        <trans-unit id="ff4b3d1492ec67a940dc896fa1d87c9ba99f2fdd" translate="yes" xml:space="preserve">
          <source>Where the time zone display names have changed over time then the most recent names will be used.</source>
          <target state="translated">시간대 표시 이름이 시간이 지남에 따라 변경된 경우 가장 최근의 이름이 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="b8883f0096050f1e4dd29bf9f7b6190b35e33b6d" translate="yes" xml:space="preserve">
          <source>Where to Go from Here</source>
          <target state="translated">여기서 갈 곳</target>
        </trans-unit>
        <trans-unit id="52d06efbef6698a9090cd765a2d437e704a1a5e2" translate="yes" xml:space="preserve">
          <source>Where with &lt;a href=&quot;qdbusreply&quot;&gt;QDBusReply&lt;/a&gt; you would write:</source>
          <target state="translated">&lt;a href=&quot;qdbusreply&quot;&gt;QDBusReply로&lt;/a&gt; 다음 과 같이 작성하십시오.</target>
        </trans-unit>
        <trans-unit id="7e741bc3dcef0123eeda11543758853be2aac149" translate="yes" xml:space="preserve">
          <source>Where:</source>
          <target state="translated">Where:</target>
        </trans-unit>
        <trans-unit id="f4092a9df66ba8f2af73c5f2492f8269ffdc70eb" translate="yes" xml:space="preserve">
          <source>Whereas a &lt;a href=&quot;qml-qt3d-animation-clipanimator&quot;&gt;ClipAnimator&lt;/a&gt; gets its animation data from a single animation clip, &lt;a href=&quot;qml-qt3d-animation-blendedclipanimator&quot;&gt;BlendedClipAnimator&lt;/a&gt; can blend together multiple clips. The animation data is obtained by evaluating a so called</source>
          <target state="translated">반면 &lt;a href=&quot;qml-qt3d-animation-clipanimator&quot;&gt;ClipAnimator이&lt;/a&gt; 하나의 애니메이션 클립에서의 애니메이션 데이터를 가져, &lt;a href=&quot;qml-qt3d-animation-blendedclipanimator&quot;&gt;BlendedClipAnimator는&lt;/a&gt; 함께 여러 클립을 혼합 할 수 있습니다. 애니메이션 데이터는 소위</target>
        </trans-unit>
        <trans-unit id="804bb2445f1402ea00ca4b54f378df57627e0205" translate="yes" xml:space="preserve">
          <source>Whereas a &lt;a href=&quot;qt3danimation-qclipanimator&quot;&gt;QClipAnimator&lt;/a&gt; gets its animation data from a single animation clip, &lt;a href=&quot;qt3danimation-qblendedclipanimator&quot;&gt;QBlendedClipAnimator&lt;/a&gt; can blend together multiple clips. The animation data is obtained by evaluating a so called</source>
          <target state="translated">반면 &lt;a href=&quot;qt3danimation-qclipanimator&quot;&gt;QClipAnimator이&lt;/a&gt; 하나의 애니메이션 클립에서의 애니메이션 데이터를 가져, &lt;a href=&quot;qt3danimation-qblendedclipanimator&quot;&gt;QBlendedClipAnimator는&lt;/a&gt; 함께 여러 클립을 혼합 할 수 있습니다. 애니메이션 데이터는 소위</target>
        </trans-unit>
        <trans-unit id="df6677fe4ed41b6de2a02f43a28dc5ef92063aba" translate="yes" xml:space="preserve">
          <source>Wherever your program uses a string literal (quoted text) that will be presented to the user, ensure that it is processed by the &lt;a href=&quot;qcoreapplication#translate&quot;&gt;QCoreApplication::translate&lt;/a&gt;() function. Essentially all that is necessary to achieve this is to use the &lt;a href=&quot;qobject#tr&quot;&gt;tr()&lt;/a&gt; function to obtain translated text for your classes, typically for display purposes. This function is also used to indicate which text strings in an application are translatable.</source>
          <target state="translated">프로그램이 사용자에게 표시 될 문자열 리터럴 (인용 된 텍스트)을 사용하는 경우 &lt;a href=&quot;qcoreapplication#translate&quot;&gt;QCoreApplication :: translate&lt;/a&gt; () 함수로 처리되는지 확인하십시오 . 본질적으로 이것을 달성하기 위해 필요한 것은 &lt;a href=&quot;qobject#tr&quot;&gt;tr ()&lt;/a&gt; 함수를 사용하여 일반적으로 표시 목적으로 클래스에 대한 번역 된 텍스트를 얻는 것입니다. 이 함수는 응용 프로그램에서 어떤 텍스트 문자열을 번역 할 수 있는지 나타내는 데에도 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="9a2b119e0e1b94041afad99d2082aedabe60692d" translate="yes" xml:space="preserve">
          <source>Whether &lt;a href=&quot;qtreeview&quot;&gt;QTreeView&lt;/a&gt; paints alternating row colors for the area that does not have any items.</source>
          <target state="translated">&lt;a href=&quot;qtreeview&quot;&gt;QTreeView&lt;/a&gt; 가 항목이없는 영역의 행 색상을 번갈아 페인트 하는지 여부 입니다.</target>
        </trans-unit>
        <trans-unit id="7479afd99480f623a47cad8dc7dc8c35d62ddf02" translate="yes" xml:space="preserve">
          <source>Whether a tab bar should suggest a size to prevent scoll arrows.</source>
          <target state="translated">탭 막대가 스캘 화살표를 방지하기위한 크기를 제안해야하는지 여부입니다.</target>
        </trans-unit>
        <trans-unit id="27d2672fc5a7413ecd5e7f19492a53aff397d05c" translate="yes" xml:space="preserve">
          <source>Whether and how the background image is repeated to fill the &lt;code&gt;background-origin&lt;/code&gt; rectangle.</source>
          <target state="translated">&lt;code&gt;background-origin&lt;/code&gt; 사각형 으로 채워지도록 배경 이미지가 반복되는지 여부와 방법 .</target>
        </trans-unit>
        <trans-unit id="f522af9862a1abe54c91f2811e719d24e11b59a8" translate="yes" xml:space="preserve">
          <source>Whether anything will be available for reading from the returned object is protocol dependent. For HTTP, the server may send a small HTML page indicating the upload was successful (or not). Other protocols will probably have content in their replies.</source>
          <target state="translated">반환 된 객체에서 읽을 수있는 항목이 있는지 여부는 프로토콜에 따라 다릅니다. HTTP의 경우, 서버는 업로드 성공 또는 실패를 나타내는 작은 HTML 페이지를 보낼 수 있습니다. 다른 프로토콜은 아마도 답글에 내용이있을 것입니다.</target>
        </trans-unit>
        <trans-unit id="a6fc5303526351baac559d5b0c024e2b8b1e467d" translate="yes" xml:space="preserve">
          <source>Whether clipping is enabled or not is dirty and needs to be updated.</source>
          <target state="translated">클리핑 활성화 여부는 더티이므로 업데이트해야합니다.</target>
        </trans-unit>
        <trans-unit id="891d6c71b96dc92f38e7de49fa32354e43d7aa65" translate="yes" xml:space="preserve">
          <source>Whether cursor should blink when text is selected.</source>
          <target state="translated">텍스트를 선택할 때 커서가 깜박 여야하는지 여부입니다.</target>
        </trans-unit>
        <trans-unit id="f536d64fe87af77f3302f5448b26e34a3608e7e7" translate="yes" xml:space="preserve">
          <source>Whether it's a 32- or 64-bit application. Possible values are: &quot;llp64&quot; (Windows 64-bit), &quot;lp64&quot; (Unix 64-bit), &quot;ilp32&quot; (32-bit)</source>
          <target state="translated">32 비트 또는 64 비트 응용 프로그램인지 여부 가능한 값은 &quot;llp64&quot;(Windows 64 비트), &quot;lp64&quot;(Unix 64 비트), &quot;ilp32&quot;(32 비트)입니다.</target>
        </trans-unit>
        <trans-unit id="88159a3d977ef502f02f2a123d6990749dcb7c82" translate="yes" xml:space="preserve">
          <source>Whether more than one filename can be selected.</source>
          <target state="translated">둘 이상의 파일 이름을 선택할 수 있는지 여부</target>
        </trans-unit>
        <trans-unit id="351fd14608eef6c08e17ef09a05f49229c55a5dc" translate="yes" xml:space="preserve">
          <source>Whether numbers are localized.</source>
          <target state="translated">숫자가 현지화되어 있는지 여부</target>
        </trans-unit>
        <trans-unit id="fdd3579e60a02aac738192bea12695a023ba77d5" translate="yes" xml:space="preserve">
          <source>Whether offsets specified using &lt;a href=&quot;#left-prop&quot;&gt;left&lt;/a&gt;, &lt;a href=&quot;#right-prop&quot;&gt;right&lt;/a&gt;, &lt;a href=&quot;#top-prop&quot;&gt;top&lt;/a&gt;, and &lt;a href=&quot;#bottom-prop&quot;&gt;bottom&lt;/a&gt; are relative or absolute coordinates.</source>
          <target state="translated">&lt;a href=&quot;#left-prop&quot;&gt;left&lt;/a&gt; , &lt;a href=&quot;#right-prop&quot;&gt;right&lt;/a&gt; , &lt;a href=&quot;#top-prop&quot;&gt;top&lt;/a&gt; 및 &lt;a href=&quot;#bottom-prop&quot;&gt;bottom을&lt;/a&gt; 사용하여 지정된 오프셋 이 상대 또는 절대 좌표인지 여부입니다.</target>
        </trans-unit>
        <trans-unit id="615c9e373bf582bda486791fb038c25503b09240" translate="yes" xml:space="preserve">
          <source>Whether only existing files or directories can be selected.</source>
          <target state="translated">기존 파일 또는 디렉토리 만 선택할 수 있는지 여부</target>
        </trans-unit>
        <trans-unit id="0fc0e926e626973c36cb23fef10be34740429705" translate="yes" xml:space="preserve">
          <source>Whether or not a scroll bar has a context menu.</source>
          <target state="translated">스크롤 바에 컨텍스트 메뉴가 있는지 여부</target>
        </trans-unit>
        <trans-unit id="e975490d1d1d8e036dbd88951f98d62fa4a9e421" translate="yes" xml:space="preserve">
          <source>Whether or not an &lt;a href=&quot;qml-qtquick-item&quot;&gt;Item&lt;/a&gt; has active focus can be queried through the &lt;code&gt;Item::activeFocus&lt;/code&gt; property. For example, here we have a &lt;a href=&quot;qml-qtquick-text&quot;&gt;Text&lt;/a&gt; type whose text is determined by whether or not it has active focus.</source>
          <target state="translated">&lt;a href=&quot;qml-qtquick-item&quot;&gt;Item&lt;/a&gt; 에 활성 포커스가 있는지 여부 는 &lt;code&gt;Item::activeFocus&lt;/code&gt; 속성을 통해 쿼리 할 수 ​​있습니다 . 예를 들어, 여기에는 &lt;a href=&quot;qml-qtquick-text&quot;&gt;텍스트&lt;/a&gt; 가 활성 포커스의 유무에 따라 결정되는 텍스트 유형이 있습니다.</target>
        </trans-unit>
        <trans-unit id="3ef85e6b7ba3ab7e4c00b4ec7423e9327a00a361" translate="yes" xml:space="preserve">
          <source>Whether or not end points are drawn when the pen width is 0 or 1 depends on the cap style. Using &lt;a href=&quot;qt#PenCapStyle-enum&quot;&gt;Qt::SquareCap&lt;/a&gt; or &lt;a href=&quot;qt#PenCapStyle-enum&quot;&gt;Qt::RoundCap&lt;/a&gt; they are drawn, using &lt;a href=&quot;qt#PenCapStyle-enum&quot;&gt;Qt::FlatCap&lt;/a&gt; they are not drawn.</source>
          <target state="translated">펜 너비가 0 또는 1 일 때 끝점을 그릴 지 여부는 캡 스타일에 따라 다릅니다. 사용 &lt;a href=&quot;qt#PenCapStyle-enum&quot;&gt;Qt는 :: SquareCap&lt;/a&gt; 또는 &lt;a href=&quot;qt#PenCapStyle-enum&quot;&gt;Qt는 :: RoundCap을&lt;/a&gt; 그들이 사용하여 그려 &lt;a href=&quot;qt#PenCapStyle-enum&quot;&gt;Qt는 :: FlatCap을&lt;/a&gt; 그들이 그려되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="0fdef606fa391f439f4e94770a38e210051c3a1a" translate="yes" xml:space="preserve">
          <source>Whether or not the cache should be in-memory only. Valid values are &lt;b&gt;true&lt;/b&gt; and &lt;b&gt;false&lt;/b&gt;. The default value is &lt;b&gt;false&lt;/b&gt;. When set to &lt;b&gt;true&lt;/b&gt;, the disk cache is never created. The ambient cache will work in-memory, but the offline database cannot be used with this option enabled.</source>
          <target state="translated">캐시가 인 메모리 전용이어야하는지 여부입니다. 유효한 값은 &lt;b&gt;true&lt;/b&gt; 및 &lt;b&gt;false&lt;/b&gt; 입니다. 기본값은 &lt;b&gt;false&lt;/b&gt; 입니다. &lt;b&gt;true로&lt;/b&gt; 설정 하면 디스크 캐시가 작성되지 않습니다. 주변 캐시는 메모리 내에서 작동하지만이 옵션을 활성화하면 오프라인 데이터베이스를 사용할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="e4800f01cf3f03c22bd30261d92d64c5bd92d1e7" translate="yes" xml:space="preserve">
          <source>Whether or not to request high dpi tiles. Valid values are &lt;b&gt;true&lt;/b&gt; and &lt;b&gt;false&lt;/b&gt;. The default value is &lt;b&gt;false&lt;/b&gt;.</source>
          <target state="translated">높은 dpi 타일을 요청할지 여부입니다. 유효한 값은 &lt;b&gt;true&lt;/b&gt; 및 &lt;b&gt;false&lt;/b&gt; 입니다. 기본값은 &lt;b&gt;false&lt;/b&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="fa6c99ad4b900578d7248fa09d22485bed6fda3e" translate="yes" xml:space="preserve">
          <source>Whether or not to request high dpi tiles. Valid values are &lt;b&gt;true&lt;/b&gt; and &lt;b&gt;false&lt;/b&gt;. The default value is &lt;b&gt;false&lt;/b&gt;. Please note that not all map types are available in high dpi. Setting this parameter to true might even have no effect if no map type is available in high dpi at the moment. Provider information files for high dpi tiles are named &lt;code&gt;street-hires&lt;/code&gt;, &lt;code&gt;satellite-hires&lt;/code&gt;, &lt;code&gt;cycle-hires&lt;/code&gt;, &lt;code&gt;transit-hires&lt;/code&gt;, &lt;code&gt;night-transit-hires&lt;/code&gt;, &lt;code&gt;terrain-hires&lt;/code&gt; and &lt;code&gt;hiking-hires&lt;/code&gt;. These are fetched from the same location used for the low dpi counterparts.</source>
          <target state="translated">높은 dpi 타일을 요청할지 여부입니다. 유효한 값은 &lt;b&gt;true&lt;/b&gt; 및 &lt;b&gt;false&lt;/b&gt; 입니다. 기본값은 &lt;b&gt;false&lt;/b&gt; 입니다. 모든지도 유형이 dpi가 높은 것은 아닙니다. 현재 높은 dpi에서지도 유형을 사용할 수없는 경우이 매개 변수를 true로 설정해도 효과가 없습니다. 고 dpi 타일에 대한 공급자 정보 파일의 이름은 &lt;code&gt;street-hires&lt;/code&gt; , &lt;code&gt;satellite-hires&lt;/code&gt; , &lt;code&gt;cycle-hires&lt;/code&gt; , &lt;code&gt;transit-hires&lt;/code&gt; , &lt;code&gt;night-transit-hires&lt;/code&gt; , &lt;code&gt;terrain-hires&lt;/code&gt; 및 &lt;code&gt;hiking-hires&lt;/code&gt; 입니다. 낮은 dpi 대응 물에 사용 된 것과 동일한 위치에서 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="14ccd186c3ee461482c7326fa36c9623c2a63da2" translate="yes" xml:space="preserve">
          <source>Whether popup menus must support scrolling.</source>
          <target state="translated">팝업 메뉴가 스크롤을 지원해야하는지 여부</target>
        </trans-unit>
        <trans-unit id="c355998709d5a91ea161e2e9efbdc94bd8c86622" translate="yes" xml:space="preserve">
          <source>Whether popup menus must support the user moving the mouse cursor to a submenu while crossing other items of the menu. This is supported on most modern desktop platforms.</source>
          <target state="translated">팝업 메뉴가 사용자가 메뉴의 다른 항목을 넘어 마우스 커서를 하위 메뉴로 이동하도록 지원해야하는지 여부입니다. 이것은 대부분의 최신 데스크탑 플랫폼에서 지원됩니다.</target>
        </trans-unit>
        <trans-unit id="7bfd520185d930289c35d432ad81bff039435224" translate="yes" xml:space="preserve">
          <source>Whether popups should allow the selections to wrap, that is when selection should the next item be the first item.</source>
          <target state="translated">팝업에서 선택 항목을 래핑해야하는지 여부, 즉 다음 선택 항목이 첫 번째 항목이어야합니다.</target>
        </trans-unit>
        <trans-unit id="9a3d16ff05060262b6fe37cd15bdb7b02685468d" translate="yes" xml:space="preserve">
          <source>Whether reverse order is used for the markers in the legend. This property is &lt;code&gt;false&lt;/code&gt; by default.</source>
          <target state="translated">범례의 마커에 역순을 사용할지 여부입니다. 이 속성은 기본적으로 &lt;code&gt;false&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="5ff6b09ef26c0c42bd41a6e8d723830a76216c42" translate="yes" xml:space="preserve">
          <source>Whether richtext selections should extend to the full width of the document.</source>
          <target state="translated">서식있는 텍스트 선택이 문서의 전체 너비로 확장되어야하는지 여부</target>
        </trans-unit>
        <trans-unit id="5d92844548ddcee7f47f82c0d52f0d492b6551db" translate="yes" xml:space="preserve">
          <source>Whether scrolling popups should fill the screen as they are scrolled.</source>
          <target state="translated">스크롤 팝업이 스크롤 될 때 화면을 채워야하는지 여부입니다.</target>
        </trans-unit>
        <trans-unit id="b7e9ec658e8e6fbee4a20e58cb2317e5a2859441" translate="yes" xml:space="preserve">
          <source>Whether scrollviews draw their frame only around contents (like Motif), or around contents, scroll bars and corner widgets (like Windows).</source>
          <target state="translated">스크롤보기가 내용 (예 : Motif) 또는 내용, 스크롤 막대 및 모서리 위젯 (Windows와 같은) 주위에만 프레임을 그릴 지 여부.</target>
        </trans-unit>
        <trans-unit id="008cc77dc296fe4b1f921abb283c4b2c99c1dfbd" translate="yes" xml:space="preserve">
          <source>Whether shortcuts are underlined.</source>
          <target state="translated">바로 가기에 밑줄이 표시되는지 여부</target>
        </trans-unit>
        <trans-unit id="f31f23419bacc3b9dd9493977a9ee560f48b4e25" translate="yes" xml:space="preserve">
          <source>Whether spacing is absolute or relative to bar thickness.</source>
          <target state="translated">간격이 막대 두께에 대해 절대인지 또는 상대적인지 여부</target>
        </trans-unit>
        <trans-unit id="14ccdf486541f6d046b78ebc3c46ca84f28aef3f" translate="yes" xml:space="preserve">
          <source>Whether text entered by the user will overwrite existing text.</source>
          <target state="translated">사용자가 입력 한 텍스트가 기존 텍스트를 덮어 쓸지 여부</target>
        </trans-unit>
        <trans-unit id="127d2d6dad872f802d502a5787fa664c518d7d37" translate="yes" xml:space="preserve">
          <source>Whether the &lt;a href=&quot;qml-qtquick-textedit&quot;&gt;TextEdit&lt;/a&gt; should gain active focus on a mouse press. By default this is set to true.</source>
          <target state="translated">&lt;a href=&quot;qml-qtquick-textedit&quot;&gt;TextEdit&lt;/a&gt; 가 마우스 누르기에 초점을 맞출 지 여부 입니다. 기본적으로이 값은 true로 설정되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="8e664258644cf6fce609f74537c27de9ea32e9ed" translate="yes" xml:space="preserve">
          <source>Whether the &lt;a href=&quot;qml-qtquick-textedit&quot;&gt;TextEdit&lt;/a&gt; should keep the selection visible when it loses active focus to another item in the scene. By default this is set to false.</source>
          <target state="translated">장면의 다른 항목에 대한 활성 초점을 잃을 때 &lt;a href=&quot;qml-qtquick-textedit&quot;&gt;TextEdit&lt;/a&gt; 에서 선택 항목을 표시해야하는지 여부 입니다. 기본적으로이 값은 false로 설정되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="02b30757d1bfc1211e2b3c3bfa3a4b027191d826" translate="yes" xml:space="preserve">
          <source>Whether the &lt;a href=&quot;qml-qtquick-textinput&quot;&gt;TextInput&lt;/a&gt; should gain active focus on a mouse press. By default this is set to true.</source>
          <target state="translated">&lt;a href=&quot;qml-qtquick-textinput&quot;&gt;TextInput&lt;/a&gt; 이 마우스 누르기에 초점을 맞출 지 여부 입니다. 기본적으로이 값은 true로 설정되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="442e7401e06ac4bd53d35ebfcd0514393c01617d" translate="yes" xml:space="preserve">
          <source>Whether the &lt;a href=&quot;qml-qtquick-textinput&quot;&gt;TextInput&lt;/a&gt; should keep its selection when it loses active focus to another item in the scene. By default this is set to false;</source>
          <target state="translated">장면의 다른 항목에 대한 활성 초점을 잃을 때 &lt;a href=&quot;qml-qtquick-textinput&quot;&gt;TextInput에서&lt;/a&gt; 선택을 유지해야하는지 여부 기본적으로 이것은 false로 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="2d56da9754f2d55c0bf314485e7193fadc26d78b" translate="yes" xml:space="preserve">
          <source>Whether the &lt;a href=&quot;qml-qtquick-textinput&quot;&gt;TextInput&lt;/a&gt; should scroll when the text is longer than the width. By default this is set to true.</source>
          <target state="translated">텍스트가 너비보다 길 때 &lt;a href=&quot;qml-qtquick-textinput&quot;&gt;TextInput&lt;/a&gt; 이 스크롤되어야 하는지 여부 입니다. 기본적으로이 값은 true로 설정되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="b84569d2c058a1d40c8935ffb676582eb4339696" translate="yes" xml:space="preserve">
          <source>Whether the &lt;a href=&quot;qtreeview&quot;&gt;QTreeView&lt;/a&gt; paints alternating row colors for the empty area (i.e the area where there are no items)</source>
          <target state="translated">&lt;a href=&quot;qtreeview&quot;&gt;QTreeView&lt;/a&gt; 가 빈 영역 (즉, 항목이없는 영역)의 행 색상을 번갈아 페인트 하는지 여부</target>
        </trans-unit>
        <trans-unit id="15885eff30424361e27c06e3896534c4ffea6121" translate="yes" xml:space="preserve">
          <source>Whether the action is enabled, and can be triggered. Defaults to &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">작업이 활성화되어 있고 트리거 될 수 있는지 여부 기본값은 &lt;code&gt;true&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="3b63603a16b0a875dd05ed6eac90f935bb37e855" translate="yes" xml:space="preserve">
          <source>Whether the affected particles have their existing position/velocity/acceleration added to the new one.</source>
          <target state="translated">영향을받는 입자에 기존 위치 / 속도 / 가속이 새 입자에 추가되었는지 여부</target>
        </trans-unit>
        <trans-unit id="5999480ac2251870246c63b5ba009ded8d924ae6" translate="yes" xml:space="preserve">
          <source>Whether the background drop shadow effect is enabled.</source>
          <target state="translated">배경 그림자 효과 사용 여부입니다.</target>
        </trans-unit>
        <trans-unit id="8830a5c00be149d6708cd3d5520bd56902a70ed9" translate="yes" xml:space="preserve">
          <source>Whether the button has active focus.</source>
          <target state="translated">버튼에 포커스가 있는지 여부</target>
        </trans-unit>
        <trans-unit id="d39bb8df504512eda2056344d9c178981fb5fc7e" translate="yes" xml:space="preserve">
          <source>Whether the button is hovered.</source>
          <target state="translated">버튼이 호버링되었는지 여부</target>
        </trans-unit>
        <trans-unit id="06019445aa3ae5cd4bf1f60ed6011fccfc4f6ab5" translate="yes" xml:space="preserve">
          <source>Whether the button is pressed.</source>
          <target state="translated">버튼을 눌렀는지 여부</target>
        </trans-unit>
        <trans-unit id="f36941b4851bd2c3920b4ff750fc4cc2ea2af042" translate="yes" xml:space="preserve">
          <source>Whether the buttons in a &lt;a href=&quot;qdialogbuttonbox&quot;&gt;QDialogButtonBox&lt;/a&gt; show icons</source>
          <target state="translated">&lt;a href=&quot;qdialogbuttonbox&quot;&gt;QDialogButtonBox&lt;/a&gt; 의 버튼에 아이콘이 표시 되는지 여부</target>
        </trans-unit>
        <trans-unit id="0445017d5d0d51a6a257d1970e1a509763b6ed2d" translate="yes" xml:space="preserve">
          <source>Whether the certificate is only self-signed.</source>
          <target state="translated">인증서 자체 서명 여부입니다.</target>
        </trans-unit>
        <trans-unit id="63e8eeda8f01dcbef8512ab31c579994488aba62" translate="yes" xml:space="preserve">
          <source>Whether the data points are visible and should be drawn.</source>
          <target state="translated">데이터 포인트가 표시되고 그려 져야하는지 여부입니다.</target>
        </trans-unit>
        <trans-unit id="40b49f5eb966eb2a50a803b79429e9d47ed678fd" translate="yes" xml:space="preserve">
          <source>Whether the database is capable of reporting the size of a query. Note that some databases do not support returning the size (i.e. number of rows returned) of a query, in which case &lt;a href=&quot;qsqlquery#size&quot;&gt;QSqlQuery::size&lt;/a&gt;() will return -1.</source>
          <target state="translated">데이터베이스가 쿼리 크기를보고 할 수 있는지 여부 일부 데이터베이스는 쿼리의 크기 (즉, 반환 된 행 수) 반환을 지원하지 않습니다.이 경우 &lt;a href=&quot;qsqlquery#size&quot;&gt;QSqlQuery :: size&lt;/a&gt; ()는 -1을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="21c37b0f1a2eb0a2c3d7635acf315d721ff4cb14" translate="yes" xml:space="preserve">
          <source>Whether the default or static mode is used for rendering optimization.</source>
          <target state="translated">렌더링 최적화에 기본 모드 또는 정적 모드가 사용되는지 여부</target>
        </trans-unit>
        <trans-unit id="be688207dd50b674f91323550645b69bc6dd0334" translate="yes" xml:space="preserve">
          <source>Whether the delegate represents today</source>
          <target state="translated">대리인이 오늘 대표하는지 여부</target>
        </trans-unit>
        <trans-unit id="3a8755b16bb8d183f894885ca5c5dee9425d78f1" translate="yes" xml:space="preserve">
          <source>Whether the dialog should be shown modal with respect to the window containing the dialog's parent Item, modal with respect to the whole application, or non-modal.</source>
          <target state="translated">대화 상자의 상위 항목을 포함하는 창에 대해 대화 상자를 표시해야하는지, 전체 응용 프로그램에 대해 모달 또는 비 모달을 표시해야하는지 여부입니다.</target>
        </trans-unit>
        <trans-unit id="adf54c46f7d89665f69a6765399db289b890d5de" translate="yes" xml:space="preserve">
          <source>Whether the dialog will provide a means of changing the opacity.</source>
          <target state="translated">대화 상자가 불투명도를 변경하는 수단을 제공하는지 여부</target>
        </trans-unit>
        <trans-unit id="81a0e45f8611929993879c1cfe29a62cf62d6198" translate="yes" xml:space="preserve">
          <source>Whether the dialog will show monospaced fonts or not.</source>
          <target state="translated">대화 상자에 고정 폭 글꼴이 표시되는지 여부</target>
        </trans-unit>
        <trans-unit id="5056ef7166f692cfde907604b07cee9df549b43e" translate="yes" xml:space="preserve">
          <source>Whether the dialog will show non scalable fonts or not.</source>
          <target state="translated">대화 상자에 확장 불가능한 글꼴이 표시되는지 여부</target>
        </trans-unit>
        <trans-unit id="bdc8e11957087489dc414aada8890efc5cf613cc" translate="yes" xml:space="preserve">
          <source>Whether the dialog will show proportional fonts or not.</source>
          <target state="translated">대화 상자에 비례 글꼴이 표시되는지 여부</target>
        </trans-unit>
        <trans-unit id="cf59371c1a2ab75dd88122e67ecd4d968653945f" translate="yes" xml:space="preserve">
          <source>Whether the dialog will show scalable fonts or not.</source>
          <target state="translated">대화 상자에 확장 가능한 글꼴이 표시되는지 여부</target>
        </trans-unit>
        <trans-unit id="a8096a1b98e7942757eb338dc4ac310987e368de" translate="yes" xml:space="preserve">
          <source>Whether the driver allows cancelling a running query.</source>
          <target state="translated">드라이버가 실행중인 쿼리를 취소 할 수 있는지 여부</target>
        </trans-unit>
        <trans-unit id="bad7dffba90736fb616a6a5b7d5ad2c46ea8a969" translate="yes" xml:space="preserve">
          <source>Whether the driver allows fetching numerical values with low precision.</source>
          <target state="translated">드라이버가 낮은 정밀도로 숫자 값을 가져올 수 있는지 여부</target>
        </trans-unit>
        <trans-unit id="3c7f787b2f9cd46ea9f39398ae0c7d4485ca5fc8" translate="yes" xml:space="preserve">
          <source>Whether the driver can access multiple result sets returned from batched statements or stored procedures.</source>
          <target state="translated">드라이버가 배치 명령문 또는 스토어드 프로 시저에서 리턴 된 여러 결과 세트에 액세스 할 수 있는지 여부</target>
        </trans-unit>
        <trans-unit id="ed4bc20d5aa787a8e008253aa117335c9aa08d81" translate="yes" xml:space="preserve">
          <source>Whether the driver can do any low-level resource cleanup when &lt;a href=&quot;qsqlquery#finish&quot;&gt;QSqlQuery::finish&lt;/a&gt;() is called.</source>
          <target state="translated">&lt;a href=&quot;qsqlquery#finish&quot;&gt;QSqlQuery :: finish&lt;/a&gt; ()가 호출 될 때 드라이버가 저수준 리소스 정리를 수행 할 수 있는지 여부</target>
        </trans-unit>
        <trans-unit id="210464c5de5626efc42d1df157c9de9e9c7d0158" translate="yes" xml:space="preserve">
          <source>Whether the driver disallows a write lock on a table while other queries have a read lock on it.</source>
          <target state="translated">다른 쿼리에 대한 읽기 잠금이있는 동안 드라이버가 테이블에서 쓰기 잠금을 허용하지 않는지 여부</target>
        </trans-unit>
        <trans-unit id="4e4f69b95b47bd4f3d99879fb2bd280a082c0786" translate="yes" xml:space="preserve">
          <source>Whether the driver supports Binary Large Object fields.</source>
          <target state="translated">드라이버가 Binary Large Object 필드를 지원하는지 여부</target>
        </trans-unit>
        <trans-unit id="1bd1162a270f0edcfe194947159af7188cd907e5" translate="yes" xml:space="preserve">
          <source>Whether the driver supports SQL transactions.</source>
          <target state="translated">드라이버가 SQL 트랜잭션을 지원하는지 여부</target>
        </trans-unit>
        <trans-unit id="845a4430bcc8fbfbbff1ac48b77c4dd33f0996d9" translate="yes" xml:space="preserve">
          <source>Whether the driver supports Unicode strings if the database server does.</source>
          <target state="translated">데이터베이스 서버에서 드라이버가 유니 코드 문자열을 지원하는지 여부</target>
        </trans-unit>
        <trans-unit id="99e2eef4a7afa6967f2bfdb3d2317bc8259b8b38" translate="yes" xml:space="preserve">
          <source>Whether the driver supports batched operations, see &lt;a href=&quot;qsqlquery#execBatch&quot;&gt;QSqlQuery::execBatch&lt;/a&gt;()</source>
          <target state="translated">드라이버가 일괄 작업을 지원하는지 여부는 &lt;a href=&quot;qsqlquery#execBatch&quot;&gt;QSqlQuery :: execBatch&lt;/a&gt; ()를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="cc692b7b64b01e95bec2490419dbacbec52f5ac5" translate="yes" xml:space="preserve">
          <source>Whether the driver supports database event notifications.</source>
          <target state="translated">드라이버가 데이터베이스 이벤트 알림을 지원하는지 여부</target>
        </trans-unit>
        <trans-unit id="628444820187e4c76acfe865374c57be9597b3c4" translate="yes" xml:space="preserve">
          <source>Whether the driver supports prepared query execution.</source>
          <target state="translated">드라이버가 준비된 쿼리 실행을 지원하는지 여부</target>
        </trans-unit>
        <trans-unit id="d578a8324e172000e823c2e578c26df8d857120a" translate="yes" xml:space="preserve">
          <source>Whether the driver supports returning the Id of the last touched row.</source>
          <target state="translated">드라이버가 마지막으로 터치 한 행의 ID 반환을 지원하는지 여부</target>
        </trans-unit>
        <trans-unit id="0c016f85910ee59575e37aaa781500e68ac6489e" translate="yes" xml:space="preserve">
          <source>Whether the driver supports the use of named placeholders.</source>
          <target state="translated">드라이버가 명명 된 자리 표시 자 사용을 지원하는지 여부</target>
        </trans-unit>
        <trans-unit id="f5fabd5d2f9f3ba4bba291487dcd50948e6e0eac" translate="yes" xml:space="preserve">
          <source>Whether the driver supports the use of positional placeholders.</source>
          <target state="translated">운전자가 위치 자리 표시 자 사용을 지원하는지 여부</target>
        </trans-unit>
        <trans-unit id="e7c605a10ccaa6b790d36479ca5cd3464b7e3e99" translate="yes" xml:space="preserve">
          <source>Whether the focus is is at the border or inside the widget.</source>
          <target state="translated">초점이 테두리에 있는지 또는 위젯 안에 있는지 여부</target>
        </trans-unit>
        <trans-unit id="fbd034ed932cf240c748ee945667de15e7a72c46" translate="yes" xml:space="preserve">
          <source>Whether the item is pressed</source>
          <target state="translated">항목을 눌렀는지 여부</target>
        </trans-unit>
        <trans-unit id="46ebf14697d16b952c232d4c529425aeba2ec058" translate="yes" xml:space="preserve">
          <source>Whether the label is drawn.</source>
          <target state="translated">라벨이 그려 졌는지 여부</target>
        </trans-unit>
        <trans-unit id="aaf559ded4da7eb7934bbeb8f5160f6fd7699b4b" translate="yes" xml:space="preserve">
          <source>Whether the legend background is visible.</source>
          <target state="translated">범례 배경이 표시되는지 여부</target>
        </trans-unit>
        <trans-unit id="37313d12a7a0be8af88693a899b7344efb257291" translate="yes" xml:space="preserve">
          <source>Whether the legend is visible.</source>
          <target state="translated">범례가 표시되는지 여부</target>
        </trans-unit>
        <trans-unit id="9ea42eeadcc56647ffbc101f32710a47b1a0a933" translate="yes" xml:space="preserve">
          <source>Whether the map type is optimized for the use on a mobile device.</source>
          <target state="translated">지도 유형이 휴대 기기에서 사용하도록 최적화되었는지 여부</target>
        </trans-unit>
        <trans-unit id="03f0ed19d3ba562825d7a428e850d0d4ae79787e" translate="yes" xml:space="preserve">
          <source>Whether the map type is optimized for use at night.</source>
          <target state="translated">지도 유형이 야간에 사용하도록 최적화되었는지 여부</target>
        </trans-unit>
        <trans-unit id="621b2949699553f62dcb51e30d25da4b13f98472" translate="yes" xml:space="preserve">
          <source>Whether the menu is enabled, and responsive to user interaction as a submenu. Its value defaults to &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">메뉴 사용 여부 및 하위 메뉴로서의 사용자 상호 작용에 응답합니다. 기본값은 &lt;code&gt;true&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="08f744dfb74a52e0e277283ba5907cc6f1378d72" translate="yes" xml:space="preserve">
          <source>Whether the menu item can be checked, or toggled. Defaults to &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">메뉴 항목을 확인하거나 전환 할 수 있는지 여부 기본값은 &lt;code&gt;false&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="4c1b888a2cec2b100297f179f869b0944945d49d" translate="yes" xml:space="preserve">
          <source>Whether the menu item is enabled, and responsive to user interaction. Defaults to &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">메뉴 항목이 활성화되어 있고 사용자 상호 작용에 반응하는지 여부 기본값은 &lt;code&gt;true&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="ce8fa3229c69c96181da21931047a6e1d51bf634" translate="yes" xml:space="preserve">
          <source>Whether the menu item should be visible. Defaults to &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">메뉴 항목의 표시 여부 기본값은 &lt;code&gt;true&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="92a63e59bfc40ad15c5be2816466eb24eacc2ef5" translate="yes" xml:space="preserve">
          <source>Whether the menu separator should be visible.</source>
          <target state="translated">메뉴 구분 기호를 표시할지 여부입니다.</target>
        </trans-unit>
        <trans-unit id="3cf2e278ef17de70651570a3447bc45e677d370d" translate="yes" xml:space="preserve">
          <source>Whether the menu should be visible as a submenu of another Menu, or as a menu on a &lt;a href=&quot;qml-qtquick-controls-menubar&quot;&gt;MenuBar&lt;/a&gt;. Its value defaults to &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">메뉴는 다른 메뉴의 하위 메뉴, 또는에 메뉴로 표시해야하는지 여부 &lt;a href=&quot;qml-qtquick-controls-menubar&quot;&gt;의 MenuBar&lt;/a&gt; . 기본값은 &lt;code&gt;true&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="8088e05c590a3e0bf008c00d389801153a3d00b6" translate="yes" xml:space="preserve">
          <source>Whether the navigation issue is requested for a top level page.</source>
          <target state="translated">최상위 페이지에 탐색 문제가 요청되었는지 여부</target>
        </trans-unit>
        <trans-unit id="235d5328b4f194c49658a5369d777c354e0bc206" translate="yes" xml:space="preserve">
          <source>Whether the reimplementation of &lt;a href=&quot;qabstractitemmodel#hasChildren&quot;&gt;hasChildren()&lt;/a&gt; returns &lt;code&gt;true&lt;/code&gt; or &lt;code&gt;false&lt;/code&gt;, it may not be necessary for the view to call &lt;a href=&quot;qabstractitemmodel#rowCount&quot;&gt;rowCount()&lt;/a&gt; to find out how many children are present. For example, &lt;a href=&quot;qtreeview&quot;&gt;QTreeView&lt;/a&gt; does not need to know how many children there are if the parent item has not been expanded to show them.</source>
          <target state="translated">&lt;a href=&quot;qabstractitemmodel#hasChildren&quot;&gt;hasChildren ()&lt;/a&gt; 의 재 구현이 &lt;code&gt;true&lt;/code&gt; 또는 &lt;code&gt;false&lt;/code&gt; 를 돌려 주는지 , 뷰가 &lt;a href=&quot;qabstractitemmodel#rowCount&quot;&gt;rowCount ()&lt;/a&gt; 를 호출 해 존재하는 아이가 몇개인지를 알 필요는 없습니다 . 예를 들어, &lt;a href=&quot;qtreeview&quot;&gt;QTreeView&lt;/a&gt; 는 상위 항목이 확장되지 않은 경우 하위 항목 수를 알 필요가 없습니다.</target>
        </trans-unit>
        <trans-unit id="538f44ad7b42229493c7d7d9e3ef2b46b9b9269d" translate="yes" xml:space="preserve">
          <source>Whether the selected item should be a folder.</source>
          <target state="translated">선택한 항목이 폴더 여야하는지 여부</target>
        </trans-unit>
        <trans-unit id="8b37630a9ab7e8561ccfcc973792499cdd1c2fc9" translate="yes" xml:space="preserve">
          <source>Whether the slice is separated from the pie.</source>
          <target state="translated">슬라이스가 파이와 분리되는지 여부</target>
        </trans-unit>
        <trans-unit id="1e51bb9bffd87efbffac7ced9051c8e36ae66ea8" translate="yes" xml:space="preserve">
          <source>Whether the sprite is animating or not.</source>
          <target state="translated">스프라이트가 애니메이션인지 여부입니다.</target>
        </trans-unit>
        <trans-unit id="15b788e281bbb09b261892870f8a1722b24dac42" translate="yes" xml:space="preserve">
          <source>Whether the state machine was invoked from an outer state machine.</source>
          <target state="translated">상태 머신이 외부 상태 머신에서 호출되었는지 여부</target>
        </trans-unit>
        <trans-unit id="a0b1a3343f7c152c3d6e8ee37fef9d099e50a0ff" translate="yes" xml:space="preserve">
          <source>Whether the style should underline the menu item's label mnemonic.</source>
          <target state="translated">스타일이 메뉴 항목의 레이블 니모닉에 밑줄을 긋을지 여부입니다.</target>
        </trans-unit>
        <trans-unit id="6800a5d87cf42840acdc7fcb220f0eab7fdd1856" translate="yes" xml:space="preserve">
          <source>Whether the user can interact with the &lt;a href=&quot;qml-qtquick-controls-textarea&quot;&gt;TextArea&lt;/a&gt; item.</source>
          <target state="translated">사용자가 &lt;a href=&quot;qml-qtquick-controls-textarea&quot;&gt;TextArea&lt;/a&gt; 항목 과 상호 작용할 수 있는지 여부</target>
        </trans-unit>
        <trans-unit id="3404ae7c0bcb4ef4a1fedd302f33d359c7dbd904" translate="yes" xml:space="preserve">
          <source>Whether the user can interact with the &lt;a href=&quot;qml-qtquick-textedit&quot;&gt;TextEdit&lt;/a&gt; item. If this property is set to true the text cannot be edited by user interaction.</source>
          <target state="translated">사용자가 &lt;a href=&quot;qml-qtquick-textedit&quot;&gt;TextEdit&lt;/a&gt; 항목 과 상호 작용할 수 있는지 여부 이 특성을 true로 설정하면 사용자 상호 작용으로 텍스트를 편집 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="421117e08c0b75cdb15d7908f28bc054bc099c36" translate="yes" xml:space="preserve">
          <source>Whether the values are reported for dragging and/or flicking is determined by &lt;a href=&quot;qml-qtquick-flickable#boundsBehavior-prop&quot;&gt;boundsBehavior&lt;/a&gt;. The overshoot distance is reported even when &lt;a href=&quot;qml-qtquick-flickable#boundsMovement-prop&quot;&gt;boundsMovement&lt;/a&gt; is &lt;code&gt;Flickable.StopAtBounds&lt;/code&gt;.</source>
          <target state="translated">드래그 및 / 또는 플릭에 대한 값의보고 여부는 &lt;a href=&quot;qml-qtquick-flickable#boundsBehavior-prop&quot;&gt;boundsBehavior에&lt;/a&gt; 의해 결정됩니다 . &lt;a href=&quot;qml-qtquick-flickable#boundsMovement-prop&quot;&gt;boundsMovement&lt;/a&gt; 가 &lt;code&gt;Flickable.StopAtBounds&lt;/code&gt; 인 경우에도 오버 슈트 거리가보고됩니다 .</target>
        </trans-unit>
        <trans-unit id="e6ceaafbfc10047970bada881dcbd1c1197929a3" translate="yes" xml:space="preserve">
          <source>Whether the web engine profile is</source>
          <target state="translated">웹 엔진 프로파일이</target>
        </trans-unit>
        <trans-unit id="3415d4ca07d6a652c116c2d85a4d5f784d1a62b9" translate="yes" xml:space="preserve">
          <source>Whether the window has a custom background color set.</source>
          <target state="translated">창에 사용자 정의 배경색이 설정되어 있는지 여부</target>
        </trans-unit>
        <trans-unit id="3f356add3a289b463a5638963da464dcfa8cedbc" translate="yes" xml:space="preserve">
          <source>Whether the window is visible on the screen.</source>
          <target state="translated">화면이 창에 표시되는지 여부</target>
        </trans-unit>
        <trans-unit id="913fc48b2bd67968d18a833b0cf728c3541e7c15" translate="yes" xml:space="preserve">
          <source>Whether this download is finished (completed, cancelled, or non-resumable interrupted state).</source>
          <target state="translated">이 다운로드가 완료되었는지 여부 (완료, 취소 또는 재개 불가능 중단 상태).</target>
        </trans-unit>
        <trans-unit id="10665e34f2783f8fa2a19993bf61804f7d9d48e8" translate="yes" xml:space="preserve">
          <source>Whether this download is paused.</source>
          <target state="translated">이 다운로드가 일시 중지되었는지 여부</target>
        </trans-unit>
        <trans-unit id="c87f3e63dd21c4200bb479597f1ec7b574bdee0e" translate="yes" xml:space="preserve">
          <source>Whether this element should be disconnected from the previous Path element (or startX/Y).</source>
          <target state="translated">이 요소를 이전 Path 요소 (또는 startX / Y)와 연결 해제해야하는지 여부</target>
        </trans-unit>
        <trans-unit id="577931957ce048bb07933998686fe00fd1a4e569" translate="yes" xml:space="preserve">
          <source>Whether this is a download request for saving a web page or a file.</source>
          <target state="translated">웹 페이지 또는 파일 저장을위한 다운로드 요청인지 여부</target>
        </trans-unit>
        <trans-unit id="fb9cfcf1336fb0bab461c8a796b1628a9b1dba5b" translate="yes" xml:space="preserve">
          <source>Whether this window request was directly triggered as the result of a keyboard or mouse event.</source>
          <target state="translated">이 창 요청이 키보드 또는 마우스 이벤트의 결과로 직접 트리거되었는지 여부</target>
        </trans-unit>
        <trans-unit id="9f0457984bd91b6556f4c2015acaf5a05c1691bd" translate="yes" xml:space="preserve">
          <source>Whether to accept or ignore the navigation request.</source>
          <target state="translated">탐색 요청을 수락할지 또는 무시할지 여부</target>
        </trans-unit>
        <trans-unit id="1a30ac0ac903d864bd8a03b00460c0d402a09ff3" translate="yes" xml:space="preserve">
          <source>Whether to use a large arc as defined by the arc points.</source>
          <target state="translated">호 점으로 정의 된 큰 호를 사용할지 여부입니다.</target>
        </trans-unit>
        <trans-unit id="acf3d78a191e4a37d63681f2767dfaa3b23c48e5" translate="yes" xml:space="preserve">
          <source>Whether to use the instruction text that came with the response from the server (true) or the text generated by the plugin. The default value is true. Note that if instructions in a language that is not directly supported by Mapbox are needed (see &lt;a href=&quot;https://www.mapbox.com/api-documentation/#instructions-languages&quot;&gt;here&lt;/a&gt; for the supported languages), it is possible to use the &lt;a href=&quot;https://doc.qt.io/qt-5.13/qtlinguist-index.html&quot;&gt;Qt Linguist&lt;/a&gt; to translate &lt;a href=&quot;https://doc.qt.io/qt-5.13/qtlocation-module.html&quot;&gt;QtLocation&lt;/a&gt; to the desired language, and set this parameter to false in order to use the translated built-in instructions.</source>
          <target state="translated">서버의 응답과 함께 제공된 지침 텍스트 (true) 또는 플러그인에서 생성 된 텍스트를 사용할지 여부입니다. 기본값은 true입니다. Mapbox에서 직접 지원하지 않는 언어의 지침이 필요한 경우 ( 지원되는 언어는 &lt;a href=&quot;https://www.mapbox.com/api-documentation/#instructions-languages&quot;&gt;여기&lt;/a&gt; 참조 ) &lt;a href=&quot;https://doc.qt.io/qt-5.13/qtlinguist-index.html&quot;&gt;Qt Linguist&lt;/a&gt; 를 사용하여 &lt;a href=&quot;https://doc.qt.io/qt-5.13/qtlocation-module.html&quot;&gt;QtLocation&lt;/a&gt; 을 원하는 언어 로 변환 하고이 매개 변수를 false로 설정하십시오. 번역 된 내장 명령어를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="5ad7a9dbe1c579bd84d6196251c8df00e0a9061e" translate="yes" xml:space="preserve">
          <source>Whether tool tips are shown on window title bar buttons.</source>
          <target state="translated">도구 설명이 창 제목 표시 줄 단추에 표시되는지 여부</target>
        </trans-unit>
        <trans-unit id="13bccea668c4304e35b3c2648c61d13a84c0a8e9" translate="yes" xml:space="preserve">
          <source>Whether tooltips are shown when the text is truncated. This property is &lt;code&gt;false&lt;/code&gt; by default. This property currently has no effect as there is no support for tooltips in QML.</source>
          <target state="translated">텍스트가 잘릴 때 툴팁이 표시되는지 여부입니다. 이 속성은 기본적으로 &lt;code&gt;false&lt;/code&gt; 입니다. QML에서 툴팁을 지원하지 않으므로이 특성은 현재 적용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="31fad663cc5a6c9e201e536434fd859471a2a47c" translate="yes" xml:space="preserve">
          <source>Whether your COM server should run as a stand-alone executable or as a shared library in the client process depends mainly on the type of COM objects you want to provide in the server.</source>
          <target state="translated">COM 서버가 클라이언트 프로세스에서 독립 실행 형 실행 파일 또는 공유 라이브러리로 실행되어야하는지 여부는 주로 서버에 제공하려는 COM 개체의 유형에 따라 다릅니다.</target>
        </trans-unit>
        <trans-unit id="70bef61f89759f7b941e6e11ce1d973c5bf9fbe3" translate="yes" xml:space="preserve">
          <source>Which APIs of the COM object are available through scripting depends on the script language used.</source>
          <target state="translated">스크립팅을 통해 사용 가능한 COM 개체의 API는 사용되는 스크립트 언어에 따라 다릅니다.</target>
        </trans-unit>
        <trans-unit id="793d21dbade3ed082aff6e7f64034df5c8fb7bc4" translate="yes" xml:space="preserve">
          <source>Which button gets the default status in a dialog's button widget.</source>
          <target state="translated">대화 상자의 단추 위젯에서 기본 상태를 가져 오는 단추</target>
        </trans-unit>
        <trans-unit id="c852b7c7494dc6886d8b68161e6704f86567c96f" translate="yes" xml:space="preserve">
          <source>Which content to show</source>
          <target state="translated">표시 할 콘텐츠</target>
        </trans-unit>
        <trans-unit id="608a0352c63aabee07da1f6a81bdd20076990125" translate="yes" xml:space="preserve">
          <source>Which logical particle groups will be affected.</source>
          <target state="translated">영향을받는 논리 파티클 그룹</target>
        </trans-unit>
        <trans-unit id="25e530a3452f532ae132324593d82cc6b8193cfd" translate="yes" xml:space="preserve">
          <source>Which logical particle groups will be painted.</source>
          <target state="translated">어떤 논리 파티클 그룹이 그려 질지</target>
        </trans-unit>
        <trans-unit id="3d4b605c5f5f983a4bd45171bb55ac43a2d266df" translate="yes" xml:space="preserve">
          <source>Which modifier keys are currently pressed</source>
          <target state="translated">현재 어떤 수정 자 키를 눌렀는지</target>
        </trans-unit>
        <trans-unit id="81602f452c808bea87345f9047105a0cca0c7c26" translate="yes" xml:space="preserve">
          <source>Which mouse buttons cause a slider to page step the value.</source>
          <target state="translated">슬라이더가 값을 페이지 단계로 만드는 마우스 버튼</target>
        </trans-unit>
        <trans-unit id="14b2d9e139d29168831e1c17e4d323900f8d3b0d" translate="yes" xml:space="preserve">
          <source>Which mouse buttons cause a slider to set the value to the position clicked on.</source>
          <target state="translated">슬라이더로 인해 클릭 한 위치로 값을 설정하는 마우스 버튼</target>
        </trans-unit>
        <trans-unit id="efdebfca3891aee71d0e4ed022793cc1b44becb2" translate="yes" xml:space="preserve">
          <source>Which mouse or stylus buttons are currently pressed</source>
          <target state="translated">현재 누른 마우스 또는 스타일러스 버튼</target>
        </trans-unit>
        <trans-unit id="1efe3552692d8bb927cb6e3656a6eb4fac500a0c" translate="yes" xml:space="preserve">
          <source>Which of the &lt;a href=&quot;qml-qtquick-dialogs-filedialog#nameFilters-prop&quot;&gt;nameFilters&lt;/a&gt; is currently selected.</source>
          <target state="translated">의 어느 &lt;a href=&quot;qml-qtquick-dialogs-filedialog#nameFilters-prop&quot;&gt;nameFilters은&lt;/a&gt; 현재 선택되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="ce70c525d60cbc2afd202f541aa3a5307f50aa58" translate="yes" xml:space="preserve">
          <source>Which properties that have changed can at any time be retrieved using the &lt;a href=&quot;qpaintenginestate#state&quot;&gt;state&lt;/a&gt;() function. This function returns an instance of the &lt;a href=&quot;qpaintengine#DirtyFlag-enum&quot;&gt;QPaintEngine::DirtyFlags&lt;/a&gt; type which stores an OR combination of &lt;a href=&quot;qpaintengine#DirtyFlag-enum&quot;&gt;QPaintEngine::DirtyFlag&lt;/a&gt; values. The &lt;a href=&quot;qpaintengine#DirtyFlag-enum&quot;&gt;QPaintEngine::DirtyFlag&lt;/a&gt; enum defines whether a property has changed since the last update or not.</source>
          <target state="translated">&lt;a href=&quot;qpaintenginestate#state&quot;&gt;state&lt;/a&gt; () 함수를 사용하여 언제라도 변경된 속성을 검색 할 수 있습니다 . 이 함수는 &lt;a href=&quot;qpaintengine#DirtyFlag-enum&quot;&gt;QPaintEngine :: DirtyFlag&lt;/a&gt; 값 의 OR 조합을 저장하는 &lt;a href=&quot;qpaintengine#DirtyFlag-enum&quot;&gt;QPaintEngine :: DirtyFlags&lt;/a&gt; 유형 의 인스턴스를 리턴 합니다. &lt;a href=&quot;qpaintengine#DirtyFlag-enum&quot;&gt;QPaintEngine :: DirtyFlag&lt;/a&gt; 열거 정의하는 속성이 마지막 업데이트 여부를 이후로 변경되었는지 여부.</target>
        </trans-unit>
        <trans-unit id="e1df1f5e64d59ab6dd483dbd8de2ec583fac2e6a" translate="yes" xml:space="preserve">
          <source>Which type of mouse event should cause a list view expansion to be selected.</source>
          <target state="translated">목록보기 확장을 선택해야하는 마우스 이벤트 유형</target>
        </trans-unit>
        <trans-unit id="ec4e8958dac6b783178c5d6e15aae8d62c60049e" translate="yes" xml:space="preserve">
          <source>Which type of mouse event should cause a tab to be selected.</source>
          <target state="translated">탭을 선택해야하는 마우스 이벤트 유형</target>
        </trans-unit>
        <trans-unit id="1d4a3d8f1568fbbfc148324db5db9d1ae0cc6949" translate="yes" xml:space="preserve">
          <source>Whichever type &lt;a href=&quot;qcborvalue#toJsonValue&quot;&gt;QCborValue::toJsonValue&lt;/a&gt;() returns.</source>
          <target state="translated">&lt;a href=&quot;qcborvalue#toJsonValue&quot;&gt;QCborValue :: toJsonValue&lt;/a&gt; () 유형이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="d86a5675cc6478e7030415aaa83cd72801292548" translate="yes" xml:space="preserve">
          <source>While</source>
          <target state="translated">While</target>
        </trans-unit>
        <trans-unit id="0c92333f95ca45dcb239bb12adff2c5c85e31dd7" translate="yes" xml:space="preserve">
          <source>While &lt;a href=&quot;qsettings&quot;&gt;QSettings&lt;/a&gt; attempts to smooth over the differences between the different supported platforms, there are still a few differences that you should be aware of when porting your application:</source>
          <target state="translated">&lt;a href=&quot;qsettings&quot;&gt;QSettings&lt;/a&gt; 는 서로 다른 지원되는 플랫폼 간의 차이점을 완화하려고 시도 하지만 애플리케이션을 이식 할 때 알아야 할 몇 가지 차이점이 있습니다.</target>
        </trans-unit>
        <trans-unit id="805d12233c47b77ed4b3e62b7584c32850936965" translate="yes" xml:space="preserve">
          <source>While QML objects instantiated in a context are not strictly owned by that context, their bindings are. If a context is destroyed, the property bindings of outstanding QML objects will stop evaluating.</source>
          <target state="translated">컨텍스트에서 인스턴스화 된 QML 오브젝트는 해당 컨텍스트에서 엄격하게 소유하지 않지만 바인딩은 해당됩니다. 컨텍스트가 손상되면 미해결 QML 오브젝트의 특성 바인딩이 평가를 중지합니다.</target>
        </trans-unit>
        <trans-unit id="88b774c74a2776122de7b559a743e91ffaed05ef" translate="yes" xml:space="preserve">
          <source>While Qt Quick provides basic graphical elements, &lt;a href=&quot;qtquickcontrols-index&quot;&gt;Qt Quick Controls&lt;/a&gt; provides ready-made QML types for use within an application.</source>
          <target state="translated">Qt Quick은 기본 그래픽 요소를 제공하지만 Qt Quick &lt;a href=&quot;qtquickcontrols-index&quot;&gt;Controls&lt;/a&gt; 는 응용 프로그램 내에서 사용할 수있는 기성품 QML 유형을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="a5caad6194e0d31eb78a5652257e4bbde771723c" translate="yes" xml:space="preserve">
          <source>While Qt Remote Objects (QtRO) handles the initialization and synchronization of &lt;a href=&quot;qtremoteobjects-replica#replica&quot;&gt;Replica&lt;/a&gt; objects, there are numerous steps happening behind the scenes which can fail and that aren't encountered in single process Qt applications. See &lt;a href=&quot;qtremoteobjects-troubleshooting#troubleshooting&quot;&gt;Troubleshooting&lt;/a&gt; for advice on how to handle such issues when using a remote objects network.</source>
          <target state="translated">QtRO (Qt Remote Objects)는 &lt;a href=&quot;qtremoteobjects-replica#replica&quot;&gt;Replica&lt;/a&gt; 객체 의 초기화 및 동기화를 처리하지만 , 단일 프로세스 Qt 애플리케이션에서는 발생하지 않고 실패 할 수있는 많은 단계가 발생합니다. 원격 객체 네트워크를 사용할 때 이러한 문제를 처리하는 방법에 대한 조언 은 &lt;a href=&quot;qtremoteobjects-troubleshooting#troubleshooting&quot;&gt;문제 해결&lt;/a&gt; 을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="8dc3249320abae6037c56c4dfaf988c3e01c6b36" translate="yes" xml:space="preserve">
          <source>While Qt Remote Objects supports sharing any &lt;a href=&quot;qobject&quot;&gt;QObject&lt;/a&gt; over the network (using enableRemoting on the Source side and acquireDynamic on the Replica side), there are a couple of advantages to letting repc define your objects. First of all, while &lt;a href=&quot;qremoteobjectdynamicreplica&quot;&gt;DynamicReplicas&lt;/a&gt; are useful, they are more cumbersome to work with. The API is not known until the object is initialized, and using the API from C++ requires string lookups through &lt;a href=&quot;qmetaobject&quot;&gt;QMetaObject&lt;/a&gt;'s methods. Secondly, having the interface known at compile time finds any issues at compile vs. at runtime. Thirdly, the rep format supports default values, which can be handy if you are unable to ensure the Source is available when the Replica is instantiated.</source>
          <target state="translated">Qt Remote Objects는 네트워크를 통해 &lt;a href=&quot;qobject&quot;&gt;QObject&lt;/a&gt; 공유를 지원하지만 (소스 측에서는 enableRemoting을 사용하고 Replica 측에서는 acquireDynamic을 사용하여) repc가 객체를 정의 할 수있게하는 몇 가지 장점이 있습니다. 우선, &lt;a href=&quot;qremoteobjectdynamicreplica&quot;&gt;DynamicReplica&lt;/a&gt; 는 유용하지만 작업하기가 더 번거 롭습니다. API는 객체가 초기화 될 때까지 알려져 있지 않으며 C ++의 API를 사용하려면 &lt;a href=&quot;qmetaobject&quot;&gt;QMetaObject&lt;/a&gt; 의 메소드를 통한 문자열 조회가 필요합니다 . 둘째, 컴파일 타임에 인터페이스를 알고 있으면 컴파일과 런타임에 문제가 발견됩니다. 세 번째로, rep 형식은 기본값을 지원하므로 복제본이 인스턴스화 될 때 소스를 사용할 수없는 경우 편리합니다.</target>
        </trans-unit>
        <trans-unit id="e457f9c50b36136e1b62d4d3cceb2a290ccb7e89" translate="yes" xml:space="preserve">
          <source>While Qt offers a lot of classes for writing your application, Apple's Cocoa frameworks offer functionality that is not currently available (or may never end up) in Qt. Using &lt;a href=&quot;qmaccocoaviewcontainer&quot;&gt;QMacCocoaViewContainer&lt;/a&gt;, it is possible to take an arbitrary NSView-derived class from Cocoa and put it in a Qt widgets hierarchy. Depending on the level of integration you need, you can use &lt;a href=&quot;qmaccocoaviewcontainer&quot;&gt;QMacCocoaViewContainer&lt;/a&gt; directly or subclass it to wrap more functionality of the underlying NSView.</source>
          <target state="translated">Qt는 응용 프로그램 작성을위한 많은 클래스를 제공하지만 Apple의 Cocoa 프레임 워크는 현재 Qt에서 사용할 수 없거나 끝날 수없는 기능을 제공합니다. &lt;a href=&quot;qmaccocoaviewcontainer&quot;&gt;QMacCocoaViewContainer를&lt;/a&gt; 사용하면 Cocoa에서 임의의 NSView 파생 클래스를 가져 와서 Qt 위젯 계층 구조에 넣을 수 있습니다. 필요한 통합 수준에 따라 &lt;a href=&quot;qmaccocoaviewcontainer&quot;&gt;QMacCocoaViewContainer를&lt;/a&gt; 직접 사용 하거나 서브 클래 싱하여 기본 NSView의 더 많은 기능을 래핑 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="639e47c0cc3c90dd85258bd8d0bd4929efba9b42" translate="yes" xml:space="preserve">
          <source>While a &lt;a href=&quot;qml-qtquick-multipointtoucharea&quot;&gt;MultiPointTouchArea&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;qml-qtquick-multipointtoucharea&quot;&gt;MultiPointTouchArea&lt;/a&gt; 동안</target>
        </trans-unit>
        <trans-unit id="2be60205fdac058f6976a555c3e4b7cf8fccfd3c" translate="yes" xml:space="preserve">
          <source>While a drag is active any change in an item's position will send a QDragMove event with item's new position to the scene.</source>
          <target state="translated">드래그가 활성화 된 상태에서 항목 위치를 변경하면 항목의 새로운 위치가있는 QDragMove 이벤트가 장면에 전송됩니다.</target>
        </trans-unit>
        <trans-unit id="64fdcb92b68611667252ebd05f072432ecdbc0e3" translate="yes" xml:space="preserve">
          <source>While a drag is active this property holds the last object to accept an enter event from the dragged item, if the current drag position doesn't intersect any accepting targets it is null.</source>
          <target state="translated">드래그가 활성화되어있는 동안이 속성은 드래그 한 항목에서 enter 이벤트를 수락하기 위해 마지막 객체를 유지합니다. 현재 드래그 위치가 허용되는 대상과 교차하지 않으면 null입니다.</target>
        </trans-unit>
        <trans-unit id="247ae0dc4720cc9ae6c9b6dc97a0b81e78b8ae50" translate="yes" xml:space="preserve">
          <source>While a macro is being composed, the stack is disabled. This means that:</source>
          <target state="translated">매크로가 구성되는 동안 스택이 비활성화됩니다. 이것은 다음을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="4a2a381df229651fb2b9af1341ddde4ce9fc06a2" translate="yes" xml:space="preserve">
          <source>While an address is preferred, it may be used by the operating system as the source address for new, outgoing packets. After it becomes deprecated, it will remain valid for incoming packets for a while longer until finally removed (see &lt;a href=&quot;qnetworkaddressentry#validityLifetime&quot;&gt;validityLifetime&lt;/a&gt;()).</source>
          <target state="translated">주소가 선호되지만 운영 체제에서 새 발신 패킷의 소스 주소로 사용할 수 있습니다. 더 이상 사용되지 않는 후에는 마지막으로 제거 될 때까지 한동안 수신 패킷에 대해 계속 유효합니다 ( &lt;a href=&quot;qnetworkaddressentry#validityLifetime&quot;&gt;validityLifetime&lt;/a&gt; () 참조 ).</target>
        </trans-unit>
        <trans-unit id="a60f8140c28c40aa06364e2fef4119b3f1df6143" translate="yes" xml:space="preserve">
          <source>While an address is valid, it will be accepted by the operating system as a valid destination address for this machine. Whether it is used as a source address for new, outgoing packets is controlled by, among other rules, the preferred lifetime (see &lt;a href=&quot;qnetworkaddressentry#preferredLifetime&quot;&gt;preferredLifetime&lt;/a&gt;()).</source>
          <target state="translated">주소는 유효하지만 운영 체제에서는이 시스템의 유효한 대상 주소로 허용합니다. 새로운 발신 패킷의 소스 주소로 사용되는지 여부는 다른 규칙 중에서 선호 수명 ( &lt;a href=&quot;qnetworkaddressentry#preferredLifetime&quot;&gt;preferredLifetime&lt;/a&gt; () 참조 )에 의해 제어됩니다 .</target>
        </trans-unit>
        <trans-unit id="8e73dec0fd5276fb04a6a4d81f2ba3c17a6241b7" translate="yes" xml:space="preserve">
          <source>While both the left and the right mouse button are pressed, mouse movement along y-axis zooms the camera in and out without changing the view center.</source>
          <target state="translated">왼쪽 및 오른쪽 마우스 버튼을 모두 누른 상태에서 y 축을 따라 마우스를 움직이면 뷰 중심을 변경하지 않고 카메라를 확대 및 축소합니다.</target>
        </trans-unit>
        <trans-unit id="37dcf4f1f9a6dc145fe2352f6113680e83b3cfc9" translate="yes" xml:space="preserve">
          <source>While determining the line-break positions take into account the space added for drawing a separator character.</source>
          <target state="translated">줄 바꿈 위치를 결정하는 동안 구분 문자를 그리기 위해 추가 된 공간을 고려합니다.</target>
        </trans-unit>
        <trans-unit id="097e642748a4c03d61bb9e6313a60b0554cb6e9e" translate="yes" xml:space="preserve">
          <source>While disabled by default, multisample antialiasing is fully supported by &lt;a href=&quot;qvulkanwindow&quot;&gt;QVulkanWindow&lt;/a&gt;. Additional color buffers and resolving into the swapchain's non-multisample buffers are all managed automatically.</source>
          <target state="translated">기본적으로 비활성화되어 있지만 &lt;a href=&quot;qvulkanwindow&quot;&gt;다중&lt;/a&gt; 샘플 앤티 앨리어싱은 QVulkanWindow에서 완전히 지원됩니다 . 추가 컬러 버퍼 및 스왑 체인의 비 멀티 샘플 버퍼로의 해결은 모두 자동으로 관리됩니다.</target>
        </trans-unit>
        <trans-unit id="cc493c81f134da0d8d432b045a7b6c1b96604a9a" translate="yes" xml:space="preserve">
          <source>While future versions of QML should be able to handle this situation more gracefully, there are currently several ways to rework your application to avoid this problem.</source>
          <target state="translated">향후 버전의 QML에서이 상황을보다 적절하게 처리 할 수 ​​있지만 현재이 문제를 피하기 위해 응용 프로그램을 재 작업하는 몇 가지 방법이 있습니다.</target>
        </trans-unit>
        <trans-unit id="15fb18a74816c4333c9f8ad309dfcbc4e6433902" translate="yes" xml:space="preserve">
          <source>While it is composing an input method may rely on mouse or key events from the &lt;a href=&quot;qml-qtquick-controls-combobox&quot;&gt;ComboBox&lt;/a&gt; to edit or commit the partial text. This property can be used to determine when to disable events handlers that may interfere with the correct operation of an input method.</source>
          <target state="translated">입력 방법을 구성하는 동안 입력 방법은 &lt;a href=&quot;qml-qtquick-controls-combobox&quot;&gt;ComboBox의&lt;/a&gt; 마우스 또는 키 이벤트를 사용 하여 부분 텍스트를 편집하거나 커밋 할 수 있습니다. 이 특성은 입력 메소드의 올바른 조작을 방해 할 수있는 이벤트 핸들러를 사용 불가능하게하는시기를 판별하는 데 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f0466a621b603d8099a666cbf3e7b909d22a359a" translate="yes" xml:space="preserve">
          <source>While it is composing an input method may rely on mouse or key events from the &lt;a href=&quot;qml-qtquick-controls-spinbox&quot;&gt;SpinBox&lt;/a&gt; to edit or commit the partial text. This property can be used to determine when to disable events handlers that may interfere with the correct operation of an input method.</source>
          <target state="translated">입력 방법을 구성하는 동안 입력 방법은 &lt;a href=&quot;qml-qtquick-controls-spinbox&quot;&gt;SpinBox의&lt;/a&gt; 마우스 또는 키 이벤트에 의존 하여 부분 텍스트를 편집하거나 커밋 할 수 있습니다. 이 특성은 입력 메소드의 올바른 조작을 방해 할 수있는 이벤트 핸들러를 사용 불가능하게하는시기를 판별하는 데 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="67890a4a1a8bd48d3e98cca62e936d86fb94fba6" translate="yes" xml:space="preserve">
          <source>While it is composing an input method may rely on mouse or key events from the &lt;a href=&quot;qml-qtquick-controls-textarea&quot;&gt;TextArea&lt;/a&gt; to edit or commit the partial text. This property can be used to determine when to disable events handlers that may interfere with the correct operation of an input method.</source>
          <target state="translated">입력 방법을 구성하는 동안 입력 방법은 &lt;a href=&quot;qml-qtquick-controls-textarea&quot;&gt;TextArea의&lt;/a&gt; 마우스 또는 키 이벤트에 의존 하여 부분 텍스트를 편집하거나 커밋 할 수 있습니다. 이 특성은 입력 메소드의 올바른 조작을 방해 할 수있는 이벤트 핸들러를 사용 불가능하게하는시기를 판별하는 데 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ee371465fb28bf9a9949849a252c923b3f791e81" translate="yes" xml:space="preserve">
          <source>While it is composing an input method may rely on mouse or key events from the &lt;a href=&quot;qml-qtquick-controls-textfield&quot;&gt;TextField&lt;/a&gt; to edit or commit the partial text. This property can be used to determine when to disable events handlers that may interfere with the correct operation of an input method.</source>
          <target state="translated">입력 방법을 구성하는 동안 입력 방법은 &lt;a href=&quot;qml-qtquick-controls-textfield&quot;&gt;TextField의&lt;/a&gt; 마우스 또는 키 이벤트를 사용 하여 부분 텍스트를 편집하거나 커밋 할 수 있습니다. 이 특성은 입력 메소드의 올바른 조작을 방해 할 수있는 이벤트 핸들러를 사용 불가능하게하는시기를 판별하는 데 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="906c9a011624e84967f351e402a95c8ae3f33f47" translate="yes" xml:space="preserve">
          <source>While it is composing an input method may rely on mouse or key events from the &lt;a href=&quot;qml-qtquick-textedit&quot;&gt;TextEdit&lt;/a&gt; to edit or commit the partial text. This property can be used to determine when to disable events handlers that may interfere with the correct operation of an input method.</source>
          <target state="translated">입력 방법을 구성하는 동안 입력 방법은 &lt;a href=&quot;qml-qtquick-textedit&quot;&gt;TextEdit의&lt;/a&gt; 마우스 또는 키 이벤트에 의존 하여 부분 텍스트를 편집하거나 커밋 할 수 있습니다. 이 특성은 입력 메소드의 올바른 조작을 방해 할 수있는 이벤트 핸들러를 사용 불가능하게하는시기를 판별하는 데 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="99aaa194e92ccb9db37b15111ae52bc3f39b615c" translate="yes" xml:space="preserve">
          <source>While it is composing an input method may rely on mouse or key events from the &lt;a href=&quot;qml-qtquick-textinput&quot;&gt;TextInput&lt;/a&gt; to edit or commit the partial text. This property can be used to determine when to disable events handlers that may interfere with the correct operation of an input method.</source>
          <target state="translated">이 입력 방법은에서 마우스 나 키 이벤트에 의존 할 수 구성하는 동안 &lt;a href=&quot;qml-qtquick-textinput&quot;&gt;의 TextInput&lt;/a&gt; 편집 또는 부분 텍스트를 커밋합니다. 이 특성은 입력 메소드의 올바른 조작을 방해 할 수있는 이벤트 핸들러를 사용 불가능하게하는시기를 판별하는 데 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="30b6907453cc980cea56c0043dbb5616963a3884" translate="yes" xml:space="preserve">
          <source>While it is composing, an input method may rely on mouse or key events from the combo box to edit or commit the partial text. This property can be used to determine when to disable event handlers that may interfere with the correct operation of an input method.</source>
          <target state="translated">작성하는 동안 입력 방법은 콤보 상자의 마우스 또는 키 이벤트를 사용하여 부분 텍스트를 편집하거나 커밋 할 수 있습니다. 이 특성은 입력 메소드의 올바른 조작을 방해 할 수있는 이벤트 핸들러를 사용 불가능하게하는시기를 판별하는 데 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f2dab60a71379a492f0e39b6fc63d2e821e5fdd4" translate="yes" xml:space="preserve">
          <source>While it is composing, an input method may rely on mouse or key events from the spin box to edit or commit the partial text. This property can be used to determine when to disable event handlers that may interfere with the correct operation of an input method.</source>
          <target state="translated">작성하는 동안 입력 방법은 스핀 상자의 마우스 또는 키 이벤트를 사용하여 부분 텍스트를 편집하거나 커밋 할 수 있습니다. 이 특성은 입력 메소드의 올바른 조작을 방해 할 수있는 이벤트 핸들러를 사용 불가능하게하는시기를 판별하는 데 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c27c4b353a9047c17a52a5e4e759a2368954c6a2" translate="yes" xml:space="preserve">
          <source>While it is possible to implement this RPC-style behavior in QtRO, as Sources without properties, and slots that have return values, QtRO hides the fact that the processing is really remote. You let a node give you the Replica instead of creating it yourself, possibly use the status signals (&lt;a href=&quot;qremoteobjectreplica#isReplicaValid&quot;&gt;isReplicaValid()&lt;/a&gt;), but then interact with the object like you would with any other &lt;a href=&quot;qobject&quot;&gt;QObject&lt;/a&gt;-based type.</source>
          <target state="translated">QtRO에서이 RPC 스타일 동작을 속성이없는 소스 및 반환 값이있는 슬롯으로 구현할 수 있지만 QtRO는 처리가 실제로 원격이라는 사실을 숨 깁니다. 노드가 직접 복제하지 않고 복제본을 제공하도록하고 상태 신호 ( &lt;a href=&quot;qremoteobjectreplica#isReplicaValid&quot;&gt;isReplicaValid ()&lt;/a&gt; )를 사용하지만 다른 &lt;a href=&quot;qobject&quot;&gt;QObject&lt;/a&gt; 기반 유형 과 마찬가지로 개체와 상호 작용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="9c0e4e02be847126b0fd3cb6759e533d4badf024" translate="yes" xml:space="preserve">
          <source>While it is possible to specify a &lt;a href=&quot;qsurfaceformat&quot;&gt;QSurfaceFormat&lt;/a&gt; for every &lt;a href=&quot;qquickwindow&quot;&gt;QQuickWindow&lt;/a&gt; by calling the member function &lt;a href=&quot;qwindow#setFormat&quot;&gt;setFormat&lt;/a&gt;(), windows may also be created from QML by using the Window and &lt;a href=&quot;qml-qtquick-controls-applicationwindow&quot;&gt;ApplicationWindow&lt;/a&gt; elements. In this case there is no C++ code involved in the creation of the window instance, yet applications may still wish to set certain surface format values, for example to request a given OpenGL version or profile. Such applications can call the static function &lt;a href=&quot;qsurfaceformat#setDefaultFormat&quot;&gt;QSurfaceFormat::setDefaultFormat&lt;/a&gt;() at startup. The specified format will be used for all Quick windows created afterwards.</source>
          <target state="translated">멤버 함수 &lt;a href=&quot;qwindow#setFormat&quot;&gt;setFormat&lt;/a&gt; () 을 호출하여 모든 &lt;a href=&quot;qquickwindow&quot;&gt;QQuickWindow&lt;/a&gt; 에 대해 &lt;a href=&quot;qsurfaceformat&quot;&gt;QSurfaceFormat&lt;/a&gt; 을 지정할 수 있지만 Window 및 &lt;a href=&quot;qml-qtquick-controls-applicationwindow&quot;&gt;ApplicationWindow&lt;/a&gt; 요소를 사용하여 QML에서 창을 작성할 수도 있습니다 . 이 경우 윈도우 인스턴스 생성과 관련된 C ++ 코드는 없지만 응용 프로그램은 특정 OpenGL 버전 또는 프로파일을 요청하기 위해 특정 표면 형식 값을 설정하고자 할 수 있습니다. 이러한 응용 프로그램은 시작할 때 정적 함수 &lt;a href=&quot;qsurfaceformat#setDefaultFormat&quot;&gt;QSurfaceFormat :: setDefaultFormat&lt;/a&gt; ()을 호출 할 수 있습니다 . 지정된 형식은 이후에 생성 된 모든 빠른 창에 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="d036a10c64b9ec62641a8f90891f12d594f9c476" translate="yes" xml:space="preserve">
          <source>While it is possible to use &lt;a href=&quot;qobject&quot;&gt;QObject&lt;/a&gt; as a base class without the &lt;a href=&quot;qobject#Q_OBJECT&quot;&gt;Q_OBJECT&lt;/a&gt; macro and without meta-object code, neither signals and slots nor the other features described here will be available if the &lt;a href=&quot;qobject#Q_OBJECT&quot;&gt;Q_OBJECT&lt;/a&gt; macro is not used. From the meta-object system's point of view, a &lt;a href=&quot;qobject&quot;&gt;QObject&lt;/a&gt; subclass without meta code is equivalent to its closest ancestor with meta-object code. This means for example, that &lt;a href=&quot;qmetaobject#className&quot;&gt;QMetaObject::className&lt;/a&gt;() will not return the actual name of your class, but the class name of this ancestor.</source>
          <target state="translated">사용 가능하지 않지만 &lt;a href=&quot;qobject&quot;&gt;있는 QObject를&lt;/a&gt; 를 빼고 기본 클래스 &lt;a href=&quot;qobject#Q_OBJECT&quot;&gt;Q_OBJECT의&lt;/a&gt; 매크로 메타 오브젝트 코드없이, 어느 쪽 신호 슬롯이나 다른 특징이 경우 사용할 수 여기서 설명 &lt;a href=&quot;qobject#Q_OBJECT&quot;&gt;Q_OBJECT의&lt;/a&gt; 매크로가 사용되지 않는다. 메타 오브젝트 시스템의 관점에서 메타 코드가없는 &lt;a href=&quot;qobject&quot;&gt;QObject&lt;/a&gt; 서브 클래스는 메타 오브젝트 코드가있는 가장 가까운 조상과 같습니다. 예를 들어 &lt;a href=&quot;qmetaobject#className&quot;&gt;QMetaObject :: className&lt;/a&gt; ()은 클래스의 실제 이름을 반환하지 않고이 조상의 클래스 이름을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="00116c5d770003a6be6fa449a53e06f8fa0b3b92" translate="yes" xml:space="preserve">
          <source>While many applications will be fine with the default behavior of &lt;a href=&quot;qvulkanwindow&quot;&gt;QVulkanWindow&lt;/a&gt; when it comes to swapchain image formats, &lt;a href=&quot;qvulkanwindow#setPreferredColorFormats&quot;&gt;setPreferredColorFormats&lt;/a&gt;() allows requesting a pre-defined format. This is useful most notably when working in the sRGB color space. Passing a format like &lt;code&gt;VK_FORMAT_B8G8R8A8_SRGB&lt;/code&gt; results in choosing an sRGB format, when available.</source>
          <target state="translated">&lt;a href=&quot;qvulkanwindow&quot;&gt;스왑 체인&lt;/a&gt; 이미지 형식과 관련하여 QVulkanWindow 의 기본 동작으로 많은 응용 프로그램이 적합하지만 &lt;a href=&quot;qvulkanwindow#setPreferredColorFormats&quot;&gt;setPreferredColorFormats&lt;/a&gt; ()를 사용하면 미리 정의 된 형식을 요청할 수 있습니다. sRGB 색상 공간에서 작업 할 때 가장 유용합니다. &lt;code&gt;VK_FORMAT_B8G8R8A8_SRGB&lt;/code&gt; 와 같은 형식을 전달 하면 사용 가능한 경우 sRGB 형식을 선택합니다.</target>
        </trans-unit>
        <trans-unit id="7caa3c55c15a9e4c6b92a5f5323d4e687f6eb1af" translate="yes" xml:space="preserve">
          <source>While mapped the contents of a video frame can be accessed directly through the pointer returned by the &lt;a href=&quot;qvideoframe#bits&quot;&gt;bits&lt;/a&gt;() function.</source>
          <target state="translated">매핑 된 동안 비디오 프레임의 내용은 &lt;a href=&quot;qvideoframe#bits&quot;&gt;비트&lt;/a&gt; () 함수에 의해 반환 된 포인터를 통해 직접 액세스 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="45e6d91218c65ba74df0c36e01a88a27f955cb3a" translate="yes" xml:space="preserve">
          <source>While navigating the results in forward-only mode, the handle of &lt;a href=&quot;qsqlresult&quot;&gt;QSqlResult&lt;/a&gt; may change. Applications that use the low-level handle of SQL result must get a new handle after each call to any of &lt;a href=&quot;qsqlresult&quot;&gt;QSqlResult&lt;/a&gt; fetch functions. Example:</source>
          <target state="translated">정방향 전용 모드에서 결과를 탐색하는 동안 &lt;a href=&quot;qsqlresult&quot;&gt;QSqlResult&lt;/a&gt; 의 핸들 이 변경 될 수 있습니다. 저수준 SQL 결과 핸들을 사용하는 응용 프로그램은 &lt;a href=&quot;qsqlresult&quot;&gt;QSqlResult&lt;/a&gt; 페치 함수를 호출 할 때마다 새 핸들을 가져와야합니다. 예:</target>
        </trans-unit>
        <trans-unit id="19a0ca3fe34ef687144b8c5cae796cac1b5dca67" translate="yes" xml:space="preserve">
          <source>While on some platforms this will be a no-op, some may perform windowing system dependent synchronization. For example, on X11 this will update &lt;code&gt;_NET_WM_SYNC_REQUEST_COUNTER&lt;/code&gt;.</source>
          <target state="translated">일부 플랫폼에서는 이것이 작동하지 않지만 일부는 윈도우 시스템 종속 동기화를 수행 할 수 있습니다. 예를 들어 X11에서는 &lt;code&gt;_NET_WM_SYNC_REQUEST_COUNTER&lt;/code&gt; 가 업데이트 됩니다 .</target>
        </trans-unit>
        <trans-unit id="ec118cf91cb7bab4a1355e9d50cae4dc0e6da10a" translate="yes" xml:space="preserve">
          <source>While reading the results of a forward-only query with PostgreSQL, the database connection cannot be used to execute other queries. This is a limitation of libpq library. Example:</source>
          <target state="translated">PostgreSQL로 정방향 쿼리의 결과를 읽는 동안 데이터베이스 연결을 사용하여 다른 쿼리를 실행할 수 없습니다. 이것은 libpq 라이브러리의 제한 사항입니다. 예:</target>
        </trans-unit>
        <trans-unit id="3f23969546517ae0fc928eb331bb4454b78e90fa" translate="yes" xml:space="preserve">
          <source>While the &lt;a href=&quot;qremoteobjecthostbase#proxy&quot;&gt;proxy&lt;/a&gt;() functionality allows &lt;a href=&quot;qtremoteobjects-source#source&quot;&gt;Source&lt;/a&gt; objects on another network to be acquired(), reverseProxy() allows &lt;a href=&quot;qtremoteobjects-source#source&quot;&gt;Source&lt;/a&gt; objects to be &quot;pushed&quot; to an otherwise inaccessible network.</source>
          <target state="translated">그동안 &lt;a href=&quot;qremoteobjecthostbase#proxy&quot;&gt;프록시&lt;/a&gt; () 기능을 허용 &lt;a href=&quot;qtremoteobjects-source#source&quot;&gt;자료가&lt;/a&gt; 다른 네트워크의 취득에 개체 () reverseProxy ()는 허용 &lt;a href=&quot;qtremoteobjects-source#source&quot;&gt;자료는&lt;/a&gt; 달리 액세스 네트워크로 &quot;푸시&quot;될 오브젝트.</target>
        </trans-unit>
        <trans-unit id="95dcf4df6cd449f4e72807f18f0a7e1c2207be7f" translate="yes" xml:space="preserve">
          <source>While the API is very similar, there is an important difference between the two: &lt;a href=&quot;qopenglwidget&quot;&gt;QOpenGLWidget&lt;/a&gt; always renders offscreen, using framebuffer objects. QGLWidget on the other hand uses a native window and surface. The latter causes issues when using it in complex user interfaces since, depending on the platform, such native child widgets may have various limitations, regarding stacking orders for example. &lt;a href=&quot;qopenglwidget&quot;&gt;QOpenGLWidget&lt;/a&gt; avoids this by not creating a separate native window.</source>
          <target state="translated">API는 매우 유사하지만이 둘 사이에는 중요한 차이점이 있습니다. &lt;a href=&quot;qopenglwidget&quot;&gt;QOpenGLWidget은&lt;/a&gt; 항상 프레임 버퍼 객체를 사용하여 화면을 오프 스크린으로 렌더링합니다. 반면 QGLWidget은 기본 창과 표면을 사용합니다. 후자는 복잡한 사용자 인터페이스에서이를 사용할 때 문제를 일으킨다. 플랫폼에 따라 이러한 네이티브 하위 위젯은 예를 들어 스태킹 순서와 관련하여 다양한 제한이있을 수 있기 때문입니다. &lt;a href=&quot;qopenglwidget&quot;&gt;QOpenGLWidget&lt;/a&gt; 은 별도의 기본 창을 작성하지 않으므로 이를 방지합니다.</target>
        </trans-unit>
        <trans-unit id="b0c7bac6a26931f3dd8042bafc31473fb658a0dc" translate="yes" xml:space="preserve">
          <source>While the QML engine allows QML application to load images from filesystem or network resources, some applications may require the additional option of loading images from C++ based processes. This can be implemented through the &lt;a href=&quot;qquickimageprovider&quot;&gt;QQuickImageProvider&lt;/a&gt; class, which provides support for pixmap loading and threaded image requests for QML applications. Any QML application that requests an image through the special &quot;image:&quot; URL scheme will be directed to an appropriate image provider to load the image.</source>
          <target state="translated">QML 엔진을 사용하면 QML 애플리케이션이 파일 시스템 또는 네트워크 리소스에서 이미지를로드 할 수 있지만 일부 애플리케이션에는 C ++ 기반 프로세스에서 이미지를로드하는 추가 옵션이 필요할 수 있습니다. 이것은 &lt;a href=&quot;qquickimageprovider&quot;&gt;QQuickImageProvider&lt;/a&gt; 클래스를 통해 구현 될 수 있으며 , QML 애플리케이션에 대한 픽스맵 로딩 및 스레드 이미지 요청을 지원합니다. 특수한 &quot;image :&quot;URL 체계를 통해 이미지를 요청하는 모든 QML 응용 프로그램은 이미지를로드하기 위해 적절한 이미지 공급자로 보내집니다.</target>
        </trans-unit>
        <trans-unit id="ee656c10b36be3adf856d1d9d60459c249296f12" translate="yes" xml:space="preserve">
          <source>While the Qt Quick module already provides a rich library of visual item types for use in a QML application, some developers may wish to define their own item-derived types in C++ and expose them to the QML type system. The easiest way to do this is to subclass &lt;a href=&quot;qquickitem&quot;&gt;QQuickItem&lt;/a&gt;, which is the base type for all visual types in the Qt Quick module. See the &lt;a href=&quot;qquickitem&quot;&gt;QQuickItem&lt;/a&gt; documentation for more details.</source>
          <target state="translated">Qt Quick 모듈은 이미 QML 응용 프로그램에서 사용할 수있는 풍부한 시각적 항목 유형 라이브러리를 제공하지만 일부 개발자는 C ++에서 자체 항목 파생 유형을 정의하여 QML 유형 시스템에 노출하고자 할 수 있습니다. 가장 쉬운 방법 은 Qt Quick 모듈의 모든 비주얼 유형에 대한 기본 유형 인 &lt;a href=&quot;qquickitem&quot;&gt;QQuickItem&lt;/a&gt; 을 서브 클래 싱 하는 것입니다. 자세한 내용은 &lt;a href=&quot;qquickitem&quot;&gt;QQuickItem&lt;/a&gt; 설명서를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="6b18fffad1b970f0544fddddb700de339361caab" translate="yes" xml:space="preserve">
          <source>While the RGB and HSV color models are used for display on computer monitors, the CMYK model is used in the four-color printing process of printing presses and some hard-copy devices.</source>
          <target state="translated">RGB 및 HSV 컬러 모델이 컴퓨터 모니터에 표시되는 데 사용되는 반면 CMYK 모델은 인쇄기 및 일부 하드 카피 장치의 4 색 인쇄 프로세스에 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="11e570f8e057d209301344726ad6db9a786ee25f" translate="yes" xml:space="preserve">
          <source>While the camera state is changed to &lt;a href=&quot;qcamera#State-enum&quot;&gt;QCamera::ActiveState&lt;/a&gt;, starting the camera service can be asynchronous with the actual status reported with &lt;a href=&quot;qcamera#status-prop&quot;&gt;QCamera::status&lt;/a&gt; property.</source>
          <target state="translated">카메라 상태가 &lt;a href=&quot;qcamera#State-enum&quot;&gt;QCamera :: ActiveState로&lt;/a&gt; 변경되는 동안 카메라 서비스 시작은 &lt;a href=&quot;qcamera#status-prop&quot;&gt;QCamera :: status&lt;/a&gt; 속성으로 보고 된 실제 상태와 비 동기화 될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="214a66a92cca6a7dbdb605829f4f9982ba3fffe2" translate="yes" xml:space="preserve">
          <source>While the example is simple, there is a lot going on behind the scenes. Whenever the current item changes, the &lt;a href=&quot;qml-qtquick-listview&quot;&gt;ListView&lt;/a&gt; sets the delegate's &lt;code&gt;Item::focus&lt;/code&gt; property. As the &lt;a href=&quot;qml-qtquick-listview&quot;&gt;ListView&lt;/a&gt; is a focus scope, this doesn't affect the rest of the application. However, if the &lt;a href=&quot;qml-qtquick-listview&quot;&gt;ListView&lt;/a&gt; itself has active focus this causes the delegate itself to receive active focus. In this example, the root type of the delegate is also a focus scope, which in turn gives active focus to the &lt;code&gt;Text&lt;/code&gt; type that actually performs the work of handling the &lt;code&gt;Return&lt;/code&gt; key.</source>
          <target state="translated">예제는 간단하지만 뒤에서 많은 일이 있습니다. 현재 항목이 변경 될 때마다 &lt;a href=&quot;qml-qtquick-listview&quot;&gt;ListView&lt;/a&gt; 는 대리자의 &lt;code&gt;Item::focus&lt;/code&gt; 속성을 설정합니다 . 는 AS &lt;a href=&quot;qml-qtquick-listview&quot;&gt;의 ListView가&lt;/a&gt; 포커스 범위이며,이 응용 프로그램의 나머지 부분에 영향을주지 않습니다. 그러나 &lt;a href=&quot;qml-qtquick-listview&quot;&gt;ListView&lt;/a&gt; 자체에 포커스가 있으면 대리자 자체가 활성 포커스를받습니다. 이 예에서 델리게이트의 루트 유형은 포커스 범위이기도 하므로 &lt;code&gt;Return&lt;/code&gt; 키 를 처리하는 작업을 실제로 수행하는 &lt;code&gt;Text&lt;/code&gt; 유형에 포커스를 둡니다 .</target>
        </trans-unit>
        <trans-unit id="ff5c637f31b54b94be971c280f66902ea205e702" translate="yes" xml:space="preserve">
          <source>While the integer based functions take values in the range 0-255 (except &lt;a href=&quot;qcolor#hue&quot;&gt;hue&lt;/a&gt;() which must have values within the range 0-359), the floating point functions accept values in the range 0.0 - 1.0.</source>
          <target state="translated">정수 기반 함수는 0-255 범위의 값을 취하지 만 (0-359 범위 내의 값을 가져야하는 &lt;a href=&quot;qcolor#hue&quot;&gt;색조&lt;/a&gt; () 제외 ) 부동 소수점 함수는 0.0-1.0 범위의 값을 허용합니다.</target>
        </trans-unit>
        <trans-unit id="7e88c44a246cc0acfeed178fecc66c12a45168dd" translate="yes" xml:space="preserve">
          <source>While the left mouse button is pressed, mouse movement along x-axis moves the camera left and right and movement along y-axis moves it up and down.</source>
          <target state="translated">마우스 왼쪽 버튼을 누르고있는 동안 x 축을 따라 마우스를 움직이면 카메라가 좌우로 움직이고 y 축을 따라 움직이면 위아래로 움직입니다.</target>
        </trans-unit>
        <trans-unit id="238539bec1e5de17e07b2d331eb50ed9a24ba8a1" translate="yes" xml:space="preserve">
          <source>While the left mouse button is pressed, mouse movement along x-axis pans the camera and movement along y-axis tilts it.</source>
          <target state="translated">마우스 왼쪽 버튼을 누르고있는 동안 x 축을 따라 마우스를 움직이면 카메라가 이동하고 y 축을 따라 움직이면 기울어집니다.</target>
        </trans-unit>
        <trans-unit id="956d26cf53341ebbab10aed503e09b8c67ae1e6c" translate="yes" xml:space="preserve">
          <source>While the macOS style fully supports high-DPI, the Windows desktop style currently has some limitations with certain scale factors. In these cases, consider using the Fusion style instead, which aims to support high-DPI in all cases.</source>
          <target state="translated">macOS 스타일은 높은 DPI를 완벽하게 지원하지만 Windows 데스크톱 스타일은 현재 특정 배율로 인해 일부 제한이 있습니다. 이 경우 모든 경우에 높은 DPI를 지원하는 Fusion 스타일을 대신 사용해보십시오.</target>
        </trans-unit>
        <trans-unit id="78d1e6aef8ef4ed7cd7b8d0163ca00a8f0d7bbd3" translate="yes" xml:space="preserve">
          <source>While the model is updating the &lt;a href=&quot;qml-qtlocation-placesearchmodel#status-prop&quot;&gt;status&lt;/a&gt; of the model is set to &lt;code&gt;PlaceSearchModel.Loading&lt;/code&gt;. If the model is successfully updated the &lt;a href=&quot;qml-qtlocation-placesearchmodel#status-prop&quot;&gt;status&lt;/a&gt; is set to &lt;code&gt;PlaceSearchModel.Ready&lt;/code&gt;, while if it unsuccessfully completes, the &lt;a href=&quot;qml-qtlocation-placesearchmodel#status-prop&quot;&gt;status&lt;/a&gt; is set to &lt;code&gt;PlaceSearchModel.Error&lt;/code&gt; and the model cleared.</source>
          <target state="translated">모델이 업데이트되는 동안 모델 &lt;a href=&quot;qml-qtlocation-placesearchmodel#status-prop&quot;&gt;상태&lt;/a&gt; 는 &lt;code&gt;PlaceSearchModel.Loading&lt;/code&gt; 으로 설정됩니다 . 모델이 성공적으로 업데이트되면 &lt;a href=&quot;qml-qtlocation-placesearchmodel#status-prop&quot;&gt;상태&lt;/a&gt; 가 &lt;code&gt;PlaceSearchModel.Ready&lt;/code&gt; 로 설정되고 , 실패하면 완료 &lt;a href=&quot;qml-qtlocation-placesearchmodel#status-prop&quot;&gt;상태&lt;/a&gt; 가 &lt;code&gt;PlaceSearchModel.Error&lt;/code&gt; 로 설정되고 모델이 지워집니다.</target>
        </trans-unit>
        <trans-unit id="82409defd12979c4c5e7be418ea87926591930b2" translate="yes" xml:space="preserve">
          <source>While the model is updating the &lt;a href=&quot;qml-qtlocation-placesearchsuggestionmodel#status-prop&quot;&gt;status&lt;/a&gt; of the model is set to &lt;code&gt;PlaceSearchSuggestionModel.Loading&lt;/code&gt;. If the model is successfully updated, the &lt;a href=&quot;qml-qtlocation-placesearchsuggestionmodel#status-prop&quot;&gt;status&lt;/a&gt; is set to &lt;code&gt;PlaceSearchSuggestionModel.Ready&lt;/code&gt;, while if it unsuccessfully completes, the &lt;a href=&quot;qml-qtlocation-placesearchsuggestionmodel#status-prop&quot;&gt;status&lt;/a&gt; is set to &lt;code&gt;PlaceSearchSuggestionModel.Error&lt;/code&gt; and the model cleared.</source>
          <target state="translated">모델이 업데이트되는 동안 모델 &lt;a href=&quot;qml-qtlocation-placesearchsuggestionmodel#status-prop&quot;&gt;상태&lt;/a&gt; 는 &lt;code&gt;PlaceSearchSuggestionModel.Loading&lt;/code&gt; 으로 설정됩니다 . 모델이 성공적으로 업데이트되면 &lt;a href=&quot;qml-qtlocation-placesearchsuggestionmodel#status-prop&quot;&gt;상태&lt;/a&gt; 가 &lt;code&gt;PlaceSearchSuggestionModel.Ready&lt;/code&gt; 로 설정되고 , 실패하면 완료 &lt;a href=&quot;qml-qtlocation-placesearchsuggestionmodel#status-prop&quot;&gt;상태&lt;/a&gt; 가 &lt;code&gt;PlaceSearchSuggestionModel.Error&lt;/code&gt; 로 설정되고 모델이 지워집니다.</target>
        </trans-unit>
        <trans-unit id="5c49b7bf8b7f523926345002ea02335ac0fed742" translate="yes" xml:space="preserve">
          <source>While the purpose of threads is to allow code to run in parallel, there are times where threads must stop and wait for other threads. For example, if two threads try to write to the same variable simultaneously, the result is undefined. The principle of forcing threads to wait for one another is called</source>
          <target state="translated">스레드의 목적은 코드가 병렬로 실행되도록하는 것이지만 스레드가 중지되고 다른 스레드를 기다려야하는 경우가 있습니다. 예를 들어, 두 스레드가 동일한 변수에 동시에 쓰려고하면 결과가 정의되지 않습니다. 스레드가 서로를 기다리도록하는 원리를</target>
        </trans-unit>
        <trans-unit id="8892b409c35b28da95d5741e0a7c085aa4772a1d" translate="yes" xml:space="preserve">
          <source>While the recorder state is changed immediately to &lt;a href=&quot;qmediarecorder#State-enum&quot;&gt;QMediaRecorder::RecordingState&lt;/a&gt;, recording may start asynchronously, with &lt;a href=&quot;qmediarecorder#status-prop&quot;&gt;statusChanged&lt;/a&gt;(&lt;a href=&quot;qmediarecorder#Status-enum&quot;&gt;QMediaRecorder::RecordingStatus&lt;/a&gt;) signal emitted when recording starts.</source>
          <target state="translated">레코더 상태가 즉시 &lt;a href=&quot;qmediarecorder#State-enum&quot;&gt;QMediaRecorder :: RecordingState로&lt;/a&gt; 변경되는 동안 , 레코딩이 시작될 때 방출되는 &lt;a href=&quot;qmediarecorder#status-prop&quot;&gt;statusChanged&lt;/a&gt; ( &lt;a href=&quot;qmediarecorder#Status-enum&quot;&gt;QMediaRecorder :: RecordingStatus&lt;/a&gt; ) 신호 와 함께 레코딩이 비동기 적으로 시작될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="378fb9d85b29aaa0bdd3082e5a9f0f6de11a9f08" translate="yes" xml:space="preserve">
          <source>While the render thread is preparing the new frame, the GUI thread calls &lt;a href=&quot;qquickitem#updatePolish&quot;&gt;QQuickItem::updatePolish&lt;/a&gt;() to do final touch-up of items before they are rendered.</source>
          <target state="translated">렌더 스레드가 새 프레임을 준비하는 동안 GUI 스레드는 &lt;a href=&quot;qquickitem#updatePolish&quot;&gt;QQuickItem :: updatePolish&lt;/a&gt; ()를 호출 하여 항목을 렌더링하기 전에 최종 수정 작업을 수행합니다.</target>
        </trans-unit>
        <trans-unit id="33b9994a33576273756053dd2bfc7d127452b698" translate="yes" xml:space="preserve">
          <source>While the render thread is rendering, the GUI is free to advance animations, process events, etc.</source>
          <target state="translated">렌더 스레드가 렌더링되는 동안 GUI는 애니메이션, 프로세스 이벤트 등을 진행시킬 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2836e2c9a00364d76e8fc6eb4948bfa345cdd8bf" translate="yes" xml:space="preserve">
          <source>While the right mouse button is pressed, mouse movement along x-axis pans the camera around the camera view center and movement along y-axis tilts it around the camera view center.</source>
          <target state="translated">마우스 오른쪽 버튼을 누른 상태에서 x 축을 따라 마우스를 움직이면 카메라가 중앙을 중심으로 이동하고 y 축을 따라 움직이면 카메라가 중앙을 중심으로 기울입니다.</target>
        </trans-unit>
        <trans-unit id="c73547bc5f11f1dcff2753df8c5f50a9d2d0b231" translate="yes" xml:space="preserve">
          <source>While the stream is playing, you can set a notify interval in milliseconds with &lt;a href=&quot;qaudiooutput#setNotifyInterval&quot;&gt;setNotifyInterval&lt;/a&gt;(). This interval specifies the time between two emissions of the &lt;a href=&quot;qaudiooutput#notify&quot;&gt;notify&lt;/a&gt;() signal. This is relative to the position in the stream, i.e., if the &lt;a href=&quot;qaudiooutput&quot;&gt;QAudioOutput&lt;/a&gt; is in the SuspendedState or the IdleState, the &lt;a href=&quot;qaudiooutput#notify&quot;&gt;notify&lt;/a&gt;() signal is not emitted. A typical use-case would be to update a &lt;a href=&quot;qslider&quot;&gt;slider&lt;/a&gt; that allows seeking in the stream. If you want the time since playback started regardless of which states the audio output has been in, &lt;a href=&quot;qaudiooutput#elapsedUSecs&quot;&gt;elapsedUSecs&lt;/a&gt;() is the function for you.</source>
          <target state="translated">스트림이 재생되는 동안 &lt;a href=&quot;qaudiooutput#setNotifyInterval&quot;&gt;setNotifyInterval&lt;/a&gt; ()을 사용하여 알림 간격을 밀리 초 단위로 설정할 수 있습니다 . 이 간격은 &lt;a href=&quot;qaudiooutput#notify&quot;&gt;통지&lt;/a&gt; () 신호 의 두 방출 사이의 시간을 지정합니다 . 이는 스트림의 위치와 관련이 있습니다. 즉, &lt;a href=&quot;qaudiooutput&quot;&gt;QAudioOutput&lt;/a&gt; 이 SuspendedState 또는 IdleState에있는 &lt;a href=&quot;qaudiooutput#notify&quot;&gt;경우 알림&lt;/a&gt; () 신호가 방출되지 않습니다. 일반적인 사용 사례는 스트림에서 탐색 할 수 있는 &lt;a href=&quot;qslider&quot;&gt;슬라이더&lt;/a&gt; 를 업데이트하는 것 입니다. 오디오 출력 상태에 관계없이 재생이 시작된 이후 시간을 원하면 &lt;a href=&quot;qaudiooutput#elapsedUSecs&quot;&gt;elapsedUSecs&lt;/a&gt; ()가 당신을위한 기능입니다.</target>
        </trans-unit>
        <trans-unit id="c8000f6c4a4a4fdf29886c2d5b63a829f3261e81" translate="yes" xml:space="preserve">
          <source>While the supported settings are unknown in this state, it's allowed to set the camera capture settings like codec, resolution, or frame rate.</source>
          <target state="translated">이 상태에서는 지원되는 설정을 알 수 없지만 코덱, 해상도 또는 프레임 속도와 같은 카메라 캡처 설정을 지정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5e63a013e47eab68d0585a4350fc0e24e27e3ba9" translate="yes" xml:space="preserve">
          <source>While the supported settings are unknown in this state, you can still set the camera capture settings like codec, resolution, or frame rate.</source>
          <target state="translated">이 상태에서는 지원되는 설정을 알 수 없지만 코덱, 해상도 또는 프레임 속도와 같은 카메라 캡처 설정을 계속 설정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="890d662caad82c18a023c4949978cc81f5a914ad" translate="yes" xml:space="preserve">
          <source>While the triggering of this signal may be considered an error condition, it does not imply the emission of the &lt;code&gt;error()&lt;/code&gt; signal. Only the emission of &lt;code&gt;requestTimeout()&lt;/code&gt; is required to indicate a timeout.</source>
          <target state="translated">이 신호의 트리거링은 오류 조건으로 간주 될 수 있지만 &lt;code&gt;error()&lt;/code&gt; 신호 의 방출을 의미하지는 않습니다 . 제한 시간을 표시하기 위해 &lt;code&gt;requestTimeout()&lt;/code&gt; 의 방출 만 필요합니다.</target>
        </trans-unit>
        <trans-unit id="3db5f5027c5bfbd27756e1a4d5f2db9c6ab87ab4" translate="yes" xml:space="preserve">
          <source>While the triggering of this signal may be considered an error condition, it does not imply the emission of the &lt;code&gt;error()&lt;/code&gt; signal. Only the emission of &lt;code&gt;updateTimeout()&lt;/code&gt; is required to indicate a timeout.</source>
          <target state="translated">이 신호의 트리거링은 오류 조건으로 간주 될 수 있지만 &lt;code&gt;error()&lt;/code&gt; 신호 의 방출을 의미하지는 않습니다 . 제한 시간을 표시하기 위해 &lt;code&gt;updateTimeout()&lt;/code&gt; 의 방출 만 필요합니다.</target>
        </trans-unit>
        <trans-unit id="1965514ae7dbcb22178d0c72da3b0f18ece39132" translate="yes" xml:space="preserve">
          <source>While the type has a name and a type, it cannot be created, and the given error</source>
          <target state="translated">유형에 이름과 유형이 있지만 작성할 수 없으며 주어진 오류</target>
        </trans-unit>
        <trans-unit id="b6cec89d64ecf87ac7795c052dd8a1107c1c1a45" translate="yes" xml:space="preserve">
          <source>While the type has a name and a type, it cannot be created. An error message with the given</source>
          <target state="translated">유형에 이름과 유형이 있지만 작성할 수 없습니다. 주어진 오류 메시지</target>
        </trans-unit>
        <trans-unit id="a01d732f1e6078a18b3d77f11f5920c2a0f80499" translate="yes" xml:space="preserve">
          <source>While this is a convenient way to store array and map-type values, you must be aware that the &lt;code&gt;items&lt;/code&gt; and &lt;code&gt;attributes&lt;/code&gt; properties above are</source>
          <target state="translated">이는 배열 및 맵 유형 값을 저장하는 편리한 방법이지만 위 의 &lt;code&gt;items&lt;/code&gt; 및 &lt;code&gt;attributes&lt;/code&gt; 속성은 다음 과 같습니다.</target>
        </trans-unit>
        <trans-unit id="19234880a4c7a1d117b722d68478a705dd237820" translate="yes" xml:space="preserve">
          <source>While this property is introduced in Qt 5.5, the related accessor functions exist since the first version of this class.</source>
          <target state="translated">이 속성은 Qt 5.5에 도입되었지만 관련 액세서 함수는이 클래스의 첫 번째 버전 이후에 존재합니다.</target>
        </trans-unit>
        <trans-unit id="14f55592618070d907f9667b31b4b236d2545fe0" translate="yes" xml:space="preserve">
          <source>While this property was introduced in 5.10, the corresponding accessor method has always been there.</source>
          <target state="translated">이 속성은 5.10에 도입되었지만 해당 접근 자 메서드는 항상 존재했습니다.</target>
        </trans-unit>
        <trans-unit id="4a2a6a35c6ca4d0d3ac0d2ce600a59b30c8d8a82" translate="yes" xml:space="preserve">
          <source>While we prefer to name our C++ source files &lt;code&gt;.cpp&lt;/code&gt;, you can use any other extension, such as &lt;code&gt;.C&lt;/code&gt;, &lt;code&gt;.cc&lt;/code&gt;, &lt;code&gt;.CC&lt;/code&gt;, &lt;code&gt;.cxx&lt;/code&gt;, and &lt;code&gt;.c++&lt;/code&gt;, if you prefer.</source>
          <target state="translated">C ++ 소스 파일의 이름을 &lt;code&gt;.cpp&lt;/code&gt; 로 지정하는 것이 &lt;code&gt;.CC&lt;/code&gt; 원하는 경우 &lt;code&gt;.C&lt;/code&gt; , &lt;code&gt;.cc&lt;/code&gt; , .CC , &lt;code&gt;.cxx&lt;/code&gt; 및 &lt;code&gt;.c++&lt;/code&gt; 와 같은 다른 확장명을 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="040a4d00e5bebdab30cb275ef54f205c01e7f2d8" translate="yes" xml:space="preserve">
          <source>While writing, the contents will be written to a temporary file, and if no error happened, &lt;a href=&quot;qsavefile#commit&quot;&gt;commit&lt;/a&gt;() will move it to the final file. This ensures that no data at the final file is lost in case an error happens while writing, and no partially-written file is ever present at the final location. Always use &lt;a href=&quot;qsavefile&quot;&gt;QSaveFile&lt;/a&gt; when saving entire documents to disk.</source>
          <target state="translated">기록하는 동안 내용은 임시 파일에 기록되며 오류가 발생하지 않으면 &lt;a href=&quot;qsavefile#commit&quot;&gt;commit&lt;/a&gt; ()은 최종 파일로 이동합니다. 이를 통해 쓰기 도중 오류가 발생하고 최종 위치에 부분적으로 작성된 파일이없는 경우 최종 파일의 데이터가 손실되지 않습니다. 전체 문서를 디스크에 저장할 때는 항상 &lt;a href=&quot;qsavefile&quot;&gt;QSaveFile을&lt;/a&gt; 사용 하십시오 .</target>
        </trans-unit>
        <trans-unit id="b4261e57f9b901a912688d75b22edcb877eeea97" translate="yes" xml:space="preserve">
          <source>Whilst SAX2 leaves it to the user to define and implement whatever features are required, support for</source>
          <target state="translated">SAX2가 필요한 기능을 정의하고 구현하도록 사용자에게 맡기는 동안</target>
        </trans-unit>
        <trans-unit id="ee1c3d063ab64e3830ce46d40aa25b31fd6708f9" translate="yes" xml:space="preserve">
          <source>Whilst reading (a SAX2 parser is usually referred to as &quot;reader&quot;) the above document three events would be triggered:</source>
          <target state="translated">읽기 (SAX2 파서는 일반적으로 &quot;판독기&quot;라고 함) 위의 문서에서 세 가지 이벤트가 트리거됩니다.</target>
        </trans-unit>
        <trans-unit id="7aa362991263dbce17194eb62185c8c8a4149920" translate="yes" xml:space="preserve">
          <source>Whilst this class provides access to any type of extension, only some are guaranteed to be returned in a format that will remain unchanged between releases. The &lt;a href=&quot;qsslcertificateextension#isSupported&quot;&gt;isSupported&lt;/a&gt;() method returns &lt;code&gt;true&lt;/code&gt; for extensions where this is the case.</source>
          <target state="translated">이 클래스는 모든 유형의 확장에 대한 액세스를 제공하지만 일부는 릴리스간에 변경되지 않은 형식으로 반환되도록 보장됩니다. &lt;a href=&quot;qsslcertificateextension#isSupported&quot;&gt;가 isSupported&lt;/a&gt; () 메소드는 반환 &lt;code&gt;true&lt;/code&gt; 이 경우 확장을위한.</target>
        </trans-unit>
        <trans-unit id="4716b4e4fbe6f125c22cea63b8d59f96bd0d83c4" translate="yes" xml:space="preserve">
          <source>Whilst this is a fast and simple approach to read XML documents, manipulation is difficult because data is not stored, simply handled and discarded serially. The &lt;a href=&quot;xml-dom-tml#&quot;&gt;DOM interface&lt;/a&gt; reads in and stores the whole document in a tree structure; this takes more memory, but makes it easier to manipulate the document's structure.</source>
          <target state="translated">이것이 XML 문서를 읽는 빠르고 간단한 방법이지만 데이터는 저장되지 않고 단순히 처리 및 삭제되기 때문에 조작이 어렵습니다. &lt;a href=&quot;xml-dom-tml#&quot;&gt;DOM 인터페이스&lt;/a&gt; 에서 읽기 및 트리 구조로 전체 문서를 저장; 이것은 더 많은 메모리를 필요로하지만 문서의 구조를보다 쉽게 ​​조작 할 수있게합니다.</target>
        </trans-unit>
        <trans-unit id="be119f3e9b0742347aed947d1e924019cdc133d2" translate="yes" xml:space="preserve">
          <source>WhiteBalance</source>
          <target state="translated">WhiteBalance</target>
        </trans-unit>
        <trans-unit id="4190ce86b53993cb85718f334bfe5be99c073792" translate="yes" xml:space="preserve">
          <source>WhiteBalanceAuto</source>
          <target state="translated">WhiteBalanceAuto</target>
        </trans-unit>
        <trans-unit id="8939e2ac028fecf3300eb31b7396ce21fc017d61" translate="yes" xml:space="preserve">
          <source>WhiteBalanceCloudy</source>
          <target state="translated">WhiteBalanceCloudy</target>
        </trans-unit>
        <trans-unit id="b90e622dfa822b4dbb410c3ab4b32c80a54c0986" translate="yes" xml:space="preserve">
          <source>WhiteBalanceFlash</source>
          <target state="translated">WhiteBalanceFlash</target>
        </trans-unit>
        <trans-unit id="c1eab86531fbb329775b9990bfbb92b507eff540" translate="yes" xml:space="preserve">
          <source>WhiteBalanceFluorescent</source>
          <target state="translated">WhiteBalanceFluorescent</target>
        </trans-unit>
        <trans-unit id="893c1c3eff47e7fe498e0c6a700c33fd7380079c" translate="yes" xml:space="preserve">
          <source>WhiteBalanceManual</source>
          <target state="translated">WhiteBalanceManual</target>
        </trans-unit>
        <trans-unit id="d166e9c2606b779a48db9dd1654fdcd0f3aff31f" translate="yes" xml:space="preserve">
          <source>WhiteBalanceShade</source>
          <target state="translated">WhiteBalanceShade</target>
        </trans-unit>
        <trans-unit id="28b156f19ce49170e930c3340ac5df603218a633" translate="yes" xml:space="preserve">
          <source>WhiteBalanceSunlight</source>
          <target state="translated">WhiteBalanceSunlight</target>
        </trans-unit>
        <trans-unit id="23d7b3ae856fedabb39a2ada5effb06748e4eccf" translate="yes" xml:space="preserve">
          <source>WhiteBalanceSunset</source>
          <target state="translated">WhiteBalanceSunset</target>
        </trans-unit>
        <trans-unit id="6ae0c09dcbe702fd9cf02b30e60a3b7a8ba80fa8" translate="yes" xml:space="preserve">
          <source>WhiteBalanceTungsten</source>
          <target state="translated">WhiteBalanceTungsten</target>
        </trans-unit>
        <trans-unit id="9f3680581edbf2de7a09abd43359e2ff52fb8c75" translate="yes" xml:space="preserve">
          <source>WhiteBalanceVendor</source>
          <target state="translated">WhiteBalanceVendor</target>
        </trans-unit>
        <trans-unit id="47b13cdb0607925057b8e9d36b0386d1a11eb54c" translate="yes" xml:space="preserve">
          <source>Whitespace</source>
          <target state="translated">Whitespace</target>
        </trans-unit>
        <trans-unit id="cf484dd6e26d5d8b523ce770ee700fdbc2cc42c0" translate="yes" xml:space="preserve">
          <source>Whitespace characters are all characters for which &lt;a href=&quot;qchar#isSpace&quot;&gt;QChar::isSpace&lt;/a&gt;() returns &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">공백 문자는 &lt;a href=&quot;qchar#isSpace&quot;&gt;QChar :: isSpace&lt;/a&gt; ()가 &lt;code&gt;true&lt;/code&gt; 를 리턴 하는 모든 문자입니다 .</target>
        </trans-unit>
        <trans-unit id="1bfce1148b8b147bf4f6c5c29d0b2ac864eccd7e" translate="yes" xml:space="preserve">
          <source>Whitespace is</source>
          <target state="translated">공백은</target>
        </trans-unit>
        <trans-unit id="619560393f5f70fda43352d58eaed0fa0beb1331" translate="yes" xml:space="preserve">
          <source>Whitespace means any character for which &lt;a href=&quot;qchar#isSpace&quot;&gt;QChar::isSpace&lt;/a&gt;() returns &lt;code&gt;true&lt;/code&gt;. This includes the ASCII characters '\t', '\n', '\v', '\f', '\r', and ' '.</source>
          <target state="translated">공백은 &lt;a href=&quot;qchar#isSpace&quot;&gt;QChar :: isSpace&lt;/a&gt; ()가 &lt;code&gt;true&lt;/code&gt; 를 리턴 하는 모든 문자를 의미 합니다 . 여기에는 ASCII 문자 '\ t', '\ n', '\ v', '\ f', '\ r'및 ''가 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="7bb86b55ec209f85b6753199094e7094ccac938d" translate="yes" xml:space="preserve">
          <source>Whitespace means any character for which the standard C++ &lt;code&gt;isspace()&lt;/code&gt; function returns &lt;code&gt;true&lt;/code&gt; in the C locale. This includes the ASCII characters '\t', '\n', '\v', '\f', '\r', and ' '.</source>
          <target state="translated">공백은 표준 C ++ &lt;code&gt;isspace()&lt;/code&gt; 함수가 C 로켈에서 &lt;code&gt;true&lt;/code&gt; 를 반환 하는 모든 문자를 의미합니다 . 여기에는 ASCII 문자 '\ t', '\ n', '\ v', '\ f', '\ r'및 ''가 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="761de1d78a55a5525fb526764547bc19aba5b107" translate="yes" xml:space="preserve">
          <source>Whitespace means any character for which the standard C++ &lt;code&gt;isspace()&lt;/code&gt; function returns &lt;code&gt;true&lt;/code&gt; in the C locale. This includes the ASCII isspace() function returns &lt;code&gt;true&lt;/code&gt; in the C locale. This includes the ASCII characters '\t', '\n', '\v', '\f', '\r', and ' '.</source>
          <target state="translated">공백은 표준 C ++ &lt;code&gt;isspace()&lt;/code&gt; 함수가 C 로켈에서 &lt;code&gt;true&lt;/code&gt; 를 반환 하는 모든 문자를 의미합니다 . 여기에는 C 로케일에서 ASCII isspace () 함수가 &lt;code&gt;true&lt;/code&gt; 를 리턴 합니다 . 여기에는 ASCII 문자 '\ t', '\ n', '\ v', '\ f', '\ r'및 ''가 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="2233df9a38ffce2a090e971a0244daca24a2351d" translate="yes" xml:space="preserve">
          <source>Whole number, e.g. 0, 10, or -20</source>
          <target state="translated">정수 (예 : 0, 10 또는 -20)</target>
        </trans-unit>
        <trans-unit id="94b58a9bbcda32cd58aa6773214ce8f8577f38f2" translate="yes" xml:space="preserve">
          <source>Why Does Qt Use Moc for Signals and Slots?</source>
          <target state="translated">Qt가 신호와 슬롯에 Moc를 사용하는 이유는 무엇입니까?</target>
        </trans-unit>
        <trans-unit id="bf8ddd04f924762daf335c1039abb1518d5d7a00" translate="yes" xml:space="preserve">
          <source>Why Single Execution Mode Is Much Faster</source>
          <target state="translated">단일 실행 모드가 훨씬 빠른 이유</target>
        </trans-unit>
        <trans-unit id="6768deb223077e5a055916dae8c4c8a62d6eac6d" translate="yes" xml:space="preserve">
          <source>Why Standard Mode Is Slow</source>
          <target state="translated">표준 모드가 느린 이유</target>
        </trans-unit>
        <trans-unit id="d28289455c6a63f4c4d5e5674b844c64ced4953a" translate="yes" xml:space="preserve">
          <source>Why Use Multi-Process</source>
          <target state="translated">다중 프로세스를 사용해야하는 이유</target>
        </trans-unit>
        <trans-unit id="59c0f38fe6c70095f1fe1a57575de23f6686b98e" translate="yes" xml:space="preserve">
          <source>Why Use Wayland Instead of X11 or Custom Solutions</source>
          <target state="translated">X11 또는 사용자 지정 솔루션 대신 Wayland를 사용하는 이유</target>
        </trans-unit>
        <trans-unit id="75faf730d6357ede69847c7a7ca9b978b5db0d56" translate="yes" xml:space="preserve">
          <source>Why are my elements created in the wrong order?</source>
          <target state="translated">내 요소가 잘못된 순서로 작성된 이유는 무엇입니까?</target>
        </trans-unit>
        <trans-unit id="6da49307967cc44ac3bddaa3c5b248c5bd424e9f" translate="yes" xml:space="preserve">
          <source>Why can't I use &lt;code&gt;true&lt;/code&gt; and &lt;code&gt;false&lt;/code&gt; in my XQuery?</source>
          <target state="translated">XQuery에서 &lt;code&gt;true&lt;/code&gt; 와 &lt;code&gt;false&lt;/code&gt; 를 사용할 수없는 이유는 무엇 입니까?</target>
        </trans-unit>
        <trans-unit id="8dd571ea364273914dcd00b60733716f9ef1f2fe" translate="yes" xml:space="preserve">
          <source>Why didn't my expression get evaluated?</source>
          <target state="translated">내 표현이 평가되지 않은 이유는 무엇입니까?</target>
        </trans-unit>
        <trans-unit id="a4372bfde3e7592aabced7cd95c0ddefabee172a" translate="yes" xml:space="preserve">
          <source>Why didn't my path expression match anything?</source>
          <target state="translated">경로 표현이 왜 일치하지 않습니까?</target>
        </trans-unit>
        <trans-unit id="a247f5521396b787b90f7af1088f96f87e2bf597" translate="yes" xml:space="preserve">
          <source>Why doesn't my FLWOR behave as expected?</source>
          <target state="translated">FLWOR가 예상대로 작동하지 않는 이유는 무엇입니까?</target>
        </trans-unit>
        <trans-unit id="83d0bcb2a31ec1e790fdb9b17582bad006644268" translate="yes" xml:space="preserve">
          <source>Why doesn't my return clause work?</source>
          <target state="translated">내 반품 조항이 작동하지 않는 이유는 무엇입니까?</target>
        </trans-unit>
        <trans-unit id="8c43626059ddc397faa99b3542a5abebf426b981" translate="yes" xml:space="preserve">
          <source>WiMAX</source>
          <target state="translated">WiMAX</target>
        </trans-unit>
        <trans-unit id="7d66c73954780bbe3b7d4d83a7707b18dddd48fc" translate="yes" xml:space="preserve">
          <source>Wide logo image file. This has to be 310x150 pixels. Supported on all Windows Store App platforms. Default provided by the mkspec.</source>
          <target state="translated">넓은 로고 이미지 파일. 310x150 픽셀이어야합니다. 모든 Windows 스토어 앱 플랫폼에서 지원됩니다. mkspec에서 제공 한 기본값입니다.</target>
        </trans-unit>
        <trans-unit id="df15305cc141d8294713eba43aaee44d1edfe3bd" translate="yes" xml:space="preserve">
          <source>Widget</source>
          <target state="translated">Widget</target>
        </trans-unit>
        <trans-unit id="1e44fcf40bcd1a072dad4b1c2c9eb0730c5aab3a" translate="yes" xml:space="preserve">
          <source>Widget Appearance and Style Related Classes</source>
          <target state="translated">위젯 모양 및 스타일 관련 클래스</target>
        </trans-unit>
        <trans-unit id="16f89fdc158507a8c9b68b673198d439286de1d9" translate="yes" xml:space="preserve">
          <source>Widget Appearance and Style-Related Classes</source>
          <target state="translated">위젯 모양 및 스타일 관련 클래스</target>
        </trans-unit>
        <trans-unit id="31e064aa645d7208a9b4c1753e3e88ac210d308a" translate="yes" xml:space="preserve">
          <source>Widget Attribute</source>
          <target state="translated">위젯 속성</target>
        </trans-unit>
        <trans-unit id="8a5e70773dcc3d881bcad04771d137842fe11c48" translate="yes" xml:space="preserve">
          <source>Widget Editing Mode</source>
          <target state="translated">위젯 편집 모드</target>
        </trans-unit>
        <trans-unit id="82cba10de183bd2d066e4d81d2062e021a9ffc67" translate="yes" xml:space="preserve">
          <source>Widget Reference</source>
          <target state="translated">위젯 참조</target>
        </trans-unit>
        <trans-unit id="669cd26f040ce8a52269e10701598141be881183" translate="yes" xml:space="preserve">
          <source>Widget Style Sheets</source>
          <target state="translated">위젯 스타일 시트</target>
        </trans-unit>
        <trans-unit id="decfc1956f3c1dad2ed2b8ec3230103ae01f3cec" translate="yes" xml:space="preserve">
          <source>Widget Walkthrough</source>
          <target state="translated">위젯 연습</target>
        </trans-unit>
        <trans-unit id="3fb06c3da187ae118abe889db66ce6d91eba057e" translate="yes" xml:space="preserve">
          <source>Widget based examples layout incorrectly in iOS.</source>
          <target state="translated">iOS에서 위젯 기반 예제 레이아웃이 잘못되었습니다.</target>
        </trans-unit>
        <trans-unit id="bd612066fd6c8940320fa98b2cbea5a4a13e6ed1" translate="yes" xml:space="preserve">
          <source>Widget for displaying the contents of a QGraphicsScene</source>
          <target state="translated">QGraphicsScene의 내용을 표시하는 위젯</target>
        </trans-unit>
        <trans-unit id="4665d8fe3f895566ba2adc2b5e8336a1ac72d65b" translate="yes" xml:space="preserve">
          <source>Widget for editing dates and times</source>
          <target state="translated">날짜 및 시간 편집을위한 위젯</target>
        </trans-unit>
        <trans-unit id="e943a3b202aca7f181da9d270c259094ac6bfb6a" translate="yes" xml:space="preserve">
          <source>Widget for editing dates based on the QDateTimeEdit widget</source>
          <target state="translated">QDateTimeEdit 위젯을 기반으로 날짜를 편집하기위한 위젯</target>
        </trans-unit>
        <trans-unit id="40ecd7df1c60b8c35ece200872419d71bf64a6aa" translate="yes" xml:space="preserve">
          <source>Widget for editing times based on the QDateTimeEdit widget</source>
          <target state="translated">QDateTimeEdit 위젯을 기반으로 시간을 편집하기위한 위젯</target>
        </trans-unit>
        <trans-unit id="57fe7643fd42b7d71e68aafba7d777e70cececfe" translate="yes" xml:space="preserve">
          <source>Widget for macOS that can be used to wrap arbitrary Cocoa views (i.e., NSView subclasses) and insert them into Qt hierarchies</source>
          <target state="translated">임의의 Cocoa 뷰 (즉, NSView 서브 클래스)를 랩핑하여 Qt 계층 구조에 삽입하는 데 사용할 수있는 macOS 용 위젯</target>
        </trans-unit>
        <trans-unit id="ba8679b21e1cd84939151ffa87f19f70ed2e7abd" translate="yes" xml:space="preserve">
          <source>Widget for macOS that provides a way to put Qt widgets into Cocoa hierarchies</source>
          <target state="translated">Qt 위젯을 Cocoa 계층에 넣는 방법을 제공하는 macOS 용 위젯</target>
        </trans-unit>
        <trans-unit id="3ea7e844a83e697d848193d0d86e6fe16d53be8e" translate="yes" xml:space="preserve">
          <source>Widget for previewing page layouts for printer output</source>
          <target state="translated">프린터 출력을위한 페이지 레이아웃 미리보기를위한 위젯</target>
        </trans-unit>
        <trans-unit id="3f50b33af17dd83c26762db6efa9c0abf87ac76e" translate="yes" xml:space="preserve">
          <source>Widget items do not support modality.</source>
          <target state="translated">위젯 항목은 양식을 지원하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="60e1290cd940a65020cfcf939c14de3016ab3930" translate="yes" xml:space="preserve">
          <source>Widget layout needs to be redone.</source>
          <target state="translated">위젯 레이아웃을 다시 작성해야합니다.</target>
        </trans-unit>
        <trans-unit id="ecb1b35e7261d239875412961edd8155c83fc298" translate="yes" xml:space="preserve">
          <source>Widget or Window focus is about to change (&lt;a href=&quot;qfocusevent&quot;&gt;QFocusEvent&lt;/a&gt;)</source>
          <target state="translated">위젯 또는 창 초점이 변경됩니다 ( &lt;a href=&quot;qfocusevent&quot;&gt;QFocusEvent&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="6a56d7d6d3eda0d0f9b2013bbf44fdd531ae93b6" translate="yes" xml:space="preserve">
          <source>Widget or Window gains keyboard focus (&lt;a href=&quot;qfocusevent&quot;&gt;QFocusEvent&lt;/a&gt;).</source>
          <target state="translated">위젯 또는 창은 키보드 포커스를 얻습니다 ( &lt;a href=&quot;qfocusevent&quot;&gt;QFocusEvent&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="b7260b87e9f172faa1c09738f92fd4ba736eceab" translate="yes" xml:space="preserve">
          <source>Widget or Window loses keyboard focus (&lt;a href=&quot;qfocusevent&quot;&gt;QFocusEvent&lt;/a&gt;).</source>
          <target state="translated">위젯 또는 창에서 키보드 포커스를 잃습니다 ( &lt;a href=&quot;qfocusevent&quot;&gt;QFocusEvent&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="7a5b139b81da872d2ffc1ade6fb2283143ea9618" translate="yes" xml:space="preserve">
          <source>Widget that can be docked inside a QMainWindow or floated as a top-level window on the desktop</source>
          <target state="translated">QMainWindow 내부에 도킹되거나 데스크탑에서 최상위 창으로 띄울 수있는 위젯</target>
        </trans-unit>
        <trans-unit id="e2ce56d39cc1d9d25a590bb2970603c4447d82ed" translate="yes" xml:space="preserve">
          <source>Widget that is used to display the contents of Scalable Vector Graphics (SVG) files</source>
          <target state="translated">SVG (Scalable Vector Graphics) 파일의 내용을 표시하는 데 사용되는 위젯</target>
        </trans-unit>
        <trans-unit id="66b55f4774ddd3de11f64896fb31548eea207c27" translate="yes" xml:space="preserve">
          <source>Widget that is used to edit and display both plain and rich text</source>
          <target state="translated">일반 텍스트와 서식있는 텍스트를 모두 편집하고 표시하는 데 사용되는 위젯</target>
        </trans-unit>
        <trans-unit id="548ced6612af891b2750ce5cb89c5f41ea5df05d" translate="yes" xml:space="preserve">
          <source>Widget that is used to edit and display plain text</source>
          <target state="translated">일반 텍스트를 편집하고 표시하는 데 사용되는 위젯</target>
        </trans-unit>
        <trans-unit id="cee9cdd37b180dbf0d8251a214ae81a450ff6719" translate="yes" xml:space="preserve">
          <source>Widget that presents buttons in a layout that is appropriate to the current widget style</source>
          <target state="translated">현재 위젯 스타일에 적합한 레이아웃에 버튼을 표시하는 위젯</target>
        </trans-unit>
        <trans-unit id="d339946ed5020f7b0aa387e1de734f5abb40c3bd" translate="yes" xml:space="preserve">
          <source>Widget was closed (&lt;a href=&quot;qcloseevent&quot;&gt;QCloseEvent&lt;/a&gt;).</source>
          <target state="translated">위젯이 닫혔습니다 ( &lt;a href=&quot;qcloseevent&quot;&gt;QCloseEvent&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="07985052ee7750ec4f2a85bcac585e5a9c4788a3" translate="yes" xml:space="preserve">
          <source>Widget was hidden (&lt;a href=&quot;qhideevent&quot;&gt;QHideEvent&lt;/a&gt;).</source>
          <target state="translated">위젯이 숨겨 &lt;a href=&quot;qhideevent&quot;&gt;졌습니다&lt;/a&gt; ( QHideEvent ).</target>
        </trans-unit>
        <trans-unit id="033bbc513d6dc62765474a6197875b4ced504eeb" translate="yes" xml:space="preserve">
          <source>Widget was moved (&lt;a href=&quot;qgraphicsscenemoveevent&quot;&gt;QGraphicsSceneMoveEvent&lt;/a&gt;).</source>
          <target state="translated">위젯이 이동되었습니다 ( &lt;a href=&quot;qgraphicsscenemoveevent&quot;&gt;QGraphicsSceneMoveEvent&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="518f7ec608083e16824e10a10b08f51fe6ab73b5" translate="yes" xml:space="preserve">
          <source>Widget was resized (&lt;a href=&quot;qgraphicssceneresizeevent&quot;&gt;QGraphicsSceneResizeEvent&lt;/a&gt;).</source>
          <target state="translated">위젯 크기가 조정되었습니다 ( &lt;a href=&quot;qgraphicssceneresizeevent&quot;&gt;QGraphicsSceneResizeEvent&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="5eab2ea2104372c35211fb62f52c62a0a93daa42" translate="yes" xml:space="preserve">
          <source>Widget was shown on screen (&lt;a href=&quot;qshowevent&quot;&gt;QShowEvent&lt;/a&gt;).</source>
          <target state="translated">위젯이 화면에 표시되었습니다 ( &lt;a href=&quot;qshowevent&quot;&gt;QShowEvent&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="9c7ef8d3feb63b591ee1fab94e628138b8697817" translate="yes" xml:space="preserve">
          <source>Widget's enabled state has changed.</source>
          <target state="translated">위젯의 사용 가능 상태가 변경되었습니다.</target>
        </trans-unit>
        <trans-unit id="7cb5faf0a4f21248e054a55edf6eabe09c1c8c5f" translate="yes" xml:space="preserve">
          <source>Widget's font has changed.</source>
          <target state="translated">위젯의 글꼴이 변경되었습니다.</target>
        </trans-unit>
        <trans-unit id="d4ac6f485c980b110b2956c14e39abda18f5f080" translate="yes" xml:space="preserve">
          <source>Widget's icon text has been changed. (Deprecated)</source>
          <target state="translated">위젯의 아이콘 텍스트가 변경되었습니다. (더 이상 사용되지 않음)</target>
        </trans-unit>
        <trans-unit id="41c8a56257c77412816e996cea5101822508caa2" translate="yes" xml:space="preserve">
          <source>Widget's position changed (&lt;a href=&quot;qmoveevent&quot;&gt;QMoveEvent&lt;/a&gt;).</source>
          <target state="translated">위젯의 위치가 변경되었습니다 ( &lt;a href=&quot;qmoveevent&quot;&gt;QMoveEvent&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="32744d45deebf14ce0ec6527d0dab358dc236133" translate="yes" xml:space="preserve">
          <source>Widget's read-only state has changed (since Qt 5.4).</source>
          <target state="translated">위젯의 읽기 전용 상태가 변경되었습니다 (Qt 5.4부터).</target>
        </trans-unit>
        <trans-unit id="54318932bd246e420fc1b5da13204b7213a11ddb" translate="yes" xml:space="preserve">
          <source>Widget's size changed (&lt;a href=&quot;qresizeevent&quot;&gt;QResizeEvent&lt;/a&gt;).</source>
          <target state="translated">위젯의 크기가 변경되었습니다 ( &lt;a href=&quot;qresizeevent&quot;&gt;QResizeEvent&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="29db40d8bb7ea1e90d1dbc18279543169a4ce3ed" translate="yes" xml:space="preserve">
          <source>Widget's style has been changed.</source>
          <target state="translated">위젯 스타일이 변경되었습니다.</target>
        </trans-unit>
        <trans-unit id="bf8a6678a1e36e3d2c45861b80308b477e3345ac" translate="yes" xml:space="preserve">
          <source>Widgets</source>
          <target state="translated">Widgets</target>
        </trans-unit>
        <trans-unit id="3f421c0aac098c418b50c5c3bcbd110589223e73" translate="yes" xml:space="preserve">
          <source>Widgets Classes</source>
          <target state="translated">위젯 클래스</target>
        </trans-unit>
        <trans-unit id="26e41ea52b5739b9e0ec9255510d6463dbaf9639" translate="yes" xml:space="preserve">
          <source>Widgets Inside C++ Namespaces</source>
          <target state="translated">C ++ 네임 스페이스 내부의 위젯</target>
        </trans-unit>
        <trans-unit id="008ecc276f0fa35c32ff2bf4e97c5a9ce8676de0" translate="yes" xml:space="preserve">
          <source>Widgets Tutorial</source>
          <target state="translated">위젯 튜토리얼</target>
        </trans-unit>
        <trans-unit id="a07d0d90d7eb4ac5ebbea3ebe5dd8d5d991c5eed" translate="yes" xml:space="preserve">
          <source>Widgets and Dialogs with Auto-Connect</source>
          <target state="translated">자동 연결 기능이있는 위젯 및 대화 상자</target>
        </trans-unit>
        <trans-unit id="344641154bdac90c3e210fb6d62e3c21264b495f" translate="yes" xml:space="preserve">
          <source>Widgets and Layouts</source>
          <target state="translated">위젯 및 레이아웃</target>
        </trans-unit>
        <trans-unit id="1a27ba46d254289b76d964159e27c5c9e7cb5eae" translate="yes" xml:space="preserve">
          <source>Widgets and forms created with</source>
          <target state="translated">로 작성된 위젯 및 양식</target>
        </trans-unit>
        <trans-unit id="a85fe50534a0d44188b440e220eb499d9e7f63b4" translate="yes" xml:space="preserve">
          <source>Widgets are hidden if:</source>
          <target state="translated">다음과 같은 경우 위젯이 숨겨집니다.</target>
        </trans-unit>
        <trans-unit id="5cc092b01f77dca9f63f3dd517ef7f260d13bdbe" translate="yes" xml:space="preserve">
          <source>Widgets are normally created without any stretch factor set. When they are laid out in a layout the widgets are given a share of space in accordance with their &lt;a href=&quot;qwidget#sizePolicy-prop&quot;&gt;QWidget::sizePolicy&lt;/a&gt;() or their minimum size hint whichever is the greater. Stretch factors are used to change how much space widgets are given in proportion to one another.</source>
          <target state="translated">위젯은 일반적으로 신축 계수를 설정하지 않고 생성됩니다. 이들이 레이아웃에 배치 될 때, 위젯에는 &lt;a href=&quot;qwidget#sizePolicy-prop&quot;&gt;QWidget :: sizePolicy&lt;/a&gt; () 또는 최소 크기 힌트 중 큰쪽에 따라 공간이 할당됩니다 . 스트레치 팩터는 서로에 비례하여 제공되는 공간 위젯의 양을 변경하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="1ad1a58da08f3901a8a19b9940b1b58f5d1fc6c7" translate="yes" xml:space="preserve">
          <source>Widgets are not necessarily drawn by asking the style to draw only one element. Widgets can make several calls to the style to draw different elements. An example is &lt;a href=&quot;qtabwidget&quot;&gt;QTabWidget&lt;/a&gt;, which draws its tabs and frame individually.</source>
          <target state="translated">하나의 요소 만 그리도록 스타일을 요청하여 위젯을 반드시 그릴 필요는 없습니다. 위젯은 스타일을 여러 번 호출하여 다른 요소를 그릴 수 있습니다. 예를 들어 &lt;a href=&quot;qtabwidget&quot;&gt;QTabWidget&lt;/a&gt; 은 탭과 프레임을 개별적으로 그립니다.</target>
        </trans-unit>
        <trans-unit id="d86289290055f720dba269dd8dd2c2c63966ce9f" translate="yes" xml:space="preserve">
          <source>Widgets are not unique objects; you can make as many copies of them as you need. To quickly duplicate a widget, you can clone it by holding down the &lt;b&gt;Ctrl&lt;/b&gt; key and dragging it. This allows widgets to be copied and placed on the form more quickly than with clipboard operations.</source>
          <target state="translated">위젯은 고유 한 객체가 아닙니다. 필요한만큼 사본을 만들 수 있습니다. 위젯을 빠르게 복제하려면 &lt;b&gt;Ctrl&lt;/b&gt; 키를 누른 채 끌어 위젯을 복제 할 수 있습니다 . 이를 통해 클립 보드 작업보다 위젯을 빠르게 복사하여 양식에 배치 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="fc7d42f09b3be487104e98c77490d831d6731b3f" translate="yes" xml:space="preserve">
          <source>Widgets are the primary elements for creating user interfaces in Qt. &lt;a href=&quot;widget-classes#the-widget-classes&quot;&gt;Widgets&lt;/a&gt; can display data and status information, receive user input, and provide a container for other widgets that should be grouped together. A widget that is not embedded in a parent widget is called a &lt;a href=&quot;application-windows#&quot;&gt;window&lt;/a&gt;.</source>
          <target state="translated">위젯은 Qt에서 사용자 인터페이스를 만들기위한 기본 요소입니다. &lt;a href=&quot;widget-classes#the-widget-classes&quot;&gt;위젯&lt;/a&gt; 은 데이터 및 상태 정보를 표시하고 사용자 입력을 수신하며 함께 그룹화해야하는 다른 위젯에 대한 컨테이너를 제공 할 수 있습니다. 부모 위젯에 포함되지 않은 위젯을 &lt;a href=&quot;application-windows#&quot;&gt;창&lt;/a&gt; 이라고합니다 .</target>
        </trans-unit>
        <trans-unit id="1375cc23552403a3c4ee37608323f1a1ac92fd07" translate="yes" xml:space="preserve">
          <source>Widgets automatically detect HTML markup and display rich text accordingly. For example, setting a label's &lt;a href=&quot;qlabel#text-prop&quot;&gt;text&lt;/a&gt; property with the string &lt;code&gt;&quot;&amp;lt;b&amp;gt;Hello&amp;lt;/b&amp;gt; &amp;lt;i&amp;gt;Qt!&amp;lt;/i&amp;gt;&quot;&lt;/code&gt; will result in the label displaying text like this: &lt;b&gt;Hello&lt;/b&gt;</source>
          <target state="translated">위젯은 자동으로 HTML 마크 업을 감지하고 그에 따라 리치 텍스트를 표시합니다. 예를 들어 문자열 &lt;code&gt;&quot;&amp;lt;b&amp;gt;Hello&amp;lt;/b&amp;gt; &amp;lt;i&amp;gt;Qt!&amp;lt;/i&amp;gt;&quot;&lt;/code&gt; 를 사용하여 레이블의 &lt;a href=&quot;qlabel#text-prop&quot;&gt;텍스트&lt;/a&gt; 속성을 설정하면 레이블 에 다음과 같은 텍스트가 표시됩니다. &lt;b&gt;Hello&lt;/b&gt;&lt;b&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="6c54f63c2c46258996ecf5d8a376b81d66276c95" translate="yes" xml:space="preserve">
          <source>Widgets can also be &quot;cloned&quot; on the form: Holding down &lt;b&gt;Ctrl&lt;/b&gt; and dragging the widget creates a copy of the widget that can be dragged to a new position.</source>
          <target state="translated">위젯은 양식에서 &quot;복제&quot;될 수도 있습니다. &lt;b&gt;Ctrl 키&lt;/b&gt; 를 누른 상태에서 위젯을 드래그하면 위젯의 사본이 만들어 새로운 위치로 드래그 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="26e7dd3385f17f40b7a475c739c5234561e03aa8" translate="yes" xml:space="preserve">
          <source>Widgets can be added to menus by using instances of the &lt;a href=&quot;qwidgetaction&quot;&gt;QWidgetAction&lt;/a&gt; class to hold them. These actions can then be inserted into menus in the usual way; see the &lt;a href=&quot;qmenu&quot;&gt;QMenu&lt;/a&gt; documentation for more details.</source>
          <target state="translated">&lt;a href=&quot;qwidgetaction&quot;&gt;QWidgetAction&lt;/a&gt; 클래스의 인스턴스를 사용하여 이를 보유 하여 메뉴에 위젯을 추가 할 수 있습니다 . 이러한 조치는 일반적인 방법으로 메뉴에 삽입 될 수 있습니다. 자세한 내용은 &lt;a href=&quot;qmenu&quot;&gt;QMenu&lt;/a&gt; 설명서를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="273dfa86751e5e4476bb799b555744e688a1a0b7" translate="yes" xml:space="preserve">
          <source>Widgets can be inserted into menus with the &lt;a href=&quot;qwidgetaction&quot;&gt;QWidgetAction&lt;/a&gt; class. Instances of this class are used to hold widgets, and are inserted into menus with the &lt;a href=&quot;qmenu#addAction&quot;&gt;addAction&lt;/a&gt;() overload that takes a &lt;a href=&quot;qaction&quot;&gt;QAction&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;qwidgetaction&quot;&gt;QWidgetAction&lt;/a&gt; 클래스를 사용하여 위젯을 메뉴에 삽입 할 수 있습니다 . 이 클래스의 인스턴스는 위젯을 보유 하는 데 사용되며 &lt;a href=&quot;qaction&quot;&gt;QAction&lt;/a&gt; 을 취하는 &lt;a href=&quot;qmenu#addAction&quot;&gt;addAction&lt;/a&gt; () 오버로드 와 함께 메뉴에 삽입됩니다 .</target>
        </trans-unit>
        <trans-unit id="288931136cef5721a6fc4f71b7afc624ff77e8d9" translate="yes" xml:space="preserve">
          <source>Widgets for editing item data in views and delegates</source>
          <target state="translated">뷰 및 델리게이트에서 항목 데이터를 편집하기위한 위젯</target>
        </trans-unit>
        <trans-unit id="3bb11f9c59b3c02c1e6de3844683793b55cba22d" translate="yes" xml:space="preserve">
          <source>Widgets modification state has been changed.</source>
          <target state="translated">위젯 수정 상태가 변경되었습니다.</target>
        </trans-unit>
        <trans-unit id="242c88c452d76a5d4144f060e7e7ca1774e6c7d1" translate="yes" xml:space="preserve">
          <source>Widgets provided by Qt use this class to place tooltips, menus and dialog boxes on the correct screen for their parent or application widgets. Applications can use this class to obtain information that can be used to save window positions, or to place child widgets and dialogs on one particular screen.</source>
          <target state="translated">Qt에서 제공하는 위젯은이 클래스를 사용하여 툴팁, 메뉴 및 대화 상자를 부모 또는 응용 프로그램 위젯의 올바른 화면에 배치합니다. 응용 프로그램은이 클래스를 사용하여 창 위치를 저장하거나 하나의 특정 화면에 하위 위젯 및 대화 상자를 배치하는 데 사용할 수있는 정보를 얻을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8435adf39417939d470169f9dd634d2c7c95c2ce" translate="yes" xml:space="preserve">
          <source>Widgets respond to events that are typically caused by user actions. Qt delivers events to widgets by calling specific event handler functions with instances of &lt;a href=&quot;qevent&quot;&gt;QEvent&lt;/a&gt; subclasses containing information about each event.</source>
          <target state="translated">위젯은 일반적으로 사용자 조치로 인해 발생하는 이벤트에 응답합니다. Qt 는 각 이벤트에 대한 정보를 포함하는 &lt;a href=&quot;qevent&quot;&gt;QEvent&lt;/a&gt; 서브 클래스 인스턴스와 함께 특정 이벤트 핸들러 함수를 호출하여 위젯에 이벤트를 전달합니다 .</target>
        </trans-unit>
        <trans-unit id="2b8947d39fb6587b9472fef874de80f84ce0c6ae" translate="yes" xml:space="preserve">
          <source>Widgets that accept keyboard input need to reimplement a few more event handlers:</source>
          <target state="translated">키보드 입력을 허용하는 위젯은 몇 가지 이벤트 핸들러를 다시 구현해야합니다.</target>
        </trans-unit>
        <trans-unit id="13aa1b4026942b9bb6ce1d114f57043c15bb811a" translate="yes" xml:space="preserve">
          <source>Width of a check box indicator.</source>
          <target state="translated">확인란 표시기의 너비.</target>
        </trans-unit>
        <trans-unit id="92d4f7c9f5b5b6ac456fc0ee64663a9569268102" translate="yes" xml:space="preserve">
          <source>Width of a chunk in a progress bar indicator.</source>
          <target state="translated">진행률 표시 줄의 청크 너비입니다.</target>
        </trans-unit>
        <trans-unit id="1bbc2f9725c899cb0bb83f2ac435543faf31e492" translate="yes" xml:space="preserve">
          <source>Width of a minimized MDI window.</source>
          <target state="translated">최소화 된 MDI 창의 너비</target>
        </trans-unit>
        <trans-unit id="14711779662ca811a72137d0c1355bfa4f31084a" translate="yes" xml:space="preserve">
          <source>Width of a radio button indicator.</source>
          <target state="translated">라디오 버튼 표시기의 너비.</target>
        </trans-unit>
        <trans-unit id="474ac5fcafa931fe0fd6910ec15a46cc6c3ce29f" translate="yes" xml:space="preserve">
          <source>Width of a separator in a horizontal dock window and the height of a separator in a vertical dock window.</source>
          <target state="translated">수평 도크 윈도우에서 분리기의 너비 및 수직 도크 윈도우에서 분리기의 높이.</target>
        </trans-unit>
        <trans-unit id="f9cbd344f389b2fdebda9d82f10d6de85a07d4a5" translate="yes" xml:space="preserve">
          <source>Width of a single frame in this &lt;a href=&quot;qml-qtquick-animatedsprite&quot;&gt;AnimatedSprite&lt;/a&gt;.</source>
          <target state="translated">이 &lt;a href=&quot;qml-qtquick-animatedsprite&quot;&gt;AnimatedSprite&lt;/a&gt; 의 단일 프레임 너비입니다 .</target>
        </trans-unit>
        <trans-unit id="4a8fe03d63b5269a8ee17b3af8c19e9ab02f872f" translate="yes" xml:space="preserve">
          <source>Width of a single frame in this sprite.</source>
          <target state="translated">이 스프라이트에서 단일 프레임의 너비입니다.</target>
        </trans-unit>
        <trans-unit id="61f0e5039b4c2de4949e55939503187e4677dbee" translate="yes" xml:space="preserve">
          <source>Width of a splitter.</source>
          <target state="translated">스플리터의 너비.</target>
        </trans-unit>
        <trans-unit id="8f394f722525a92857f04c8b25a4ff0084fcc97b" translate="yes" xml:space="preserve">
          <source>Width of a toolbar extension button in a horizontal toolbar and the height of the button in a vertical toolbar.</source>
          <target state="translated">가로 도구 모음의 도구 모음 확장 단추 너비 및 세로 도구 모음의 단추 높이</target>
        </trans-unit>
        <trans-unit id="a276f4d87ef046e18ddd9eaa41ad0a5ce04c4153" translate="yes" xml:space="preserve">
          <source>Width of a toolbar handle in a horizontal toolbar and the height of the handle in a vertical toolbar.</source>
          <target state="translated">가로 도구 모음의 도구 모음 핸들 너비와 세로 도구 모음의 핸들 높이</target>
        </trans-unit>
        <trans-unit id="f6475409c1ca0bbf3519ed0b865993d83442f005" translate="yes" xml:space="preserve">
          <source>Width of a toolbar separator in a horizontal toolbar and the height of a separator in a vertical toolbar.</source>
          <target state="translated">가로 도구 모음의 도구 모음 구분자 너비와 세로 도구 모음의 구분자 높이입니다.</target>
        </trans-unit>
        <trans-unit id="f32cdf111f802f1e77076f374ad98edca36bb759" translate="yes" xml:space="preserve">
          <source>Width of a vertical scroll bar and the height of a horizontal scroll bar.</source>
          <target state="translated">세로 스크롤 막대의 너비와 가로 스크롤 막대의 높이입니다.</target>
        </trans-unit>
        <trans-unit id="894a83e2504cfb44500a8d72eba1c5a9876f1107" translate="yes" xml:space="preserve">
          <source>Width of the alternate keys list item.</source>
          <target state="translated">대체 키 목록 항목의 너비</target>
        </trans-unit>
        <trans-unit id="ca01378df4fc7f57ef1854241261d4957d8070cb" translate="yes" xml:space="preserve">
          <source>Width of the default-button indicator frame.</source>
          <target state="translated">기본 버튼 표시기 프레임의 너비.</target>
        </trans-unit>
        <trans-unit id="bff587a72664f0ce6c24d49d77072e269e5af574" translate="yes" xml:space="preserve">
          <source>Width of the frame around toolbars.</source>
          <target state="translated">툴바 주위의 프레임 너비.</target>
        </trans-unit>
        <trans-unit id="32d20c7e2973072db1690d05d4a9bbb06c5587ac" translate="yes" xml:space="preserve">
          <source>Width of the handle in a horizontal dock window and the height of the handle in a vertical dock window.</source>
          <target state="translated">수평 독 창에서 핸들 너비와 수직 독 창에서 핸들 높이</target>
        </trans-unit>
        <trans-unit id="30d21fa5d9cb79597ff503bf1dbbb488b65a5ede" translate="yes" xml:space="preserve">
          <source>Width of the menu button indicator proportional to the widget height.</source>
          <target state="translated">위젯 높이에 비례하는 메뉴 버튼 표시기의 너비.</target>
        </trans-unit>
        <trans-unit id="641be895c08513d3bfd01d7c1a2ff3ca352244e4" translate="yes" xml:space="preserve">
          <source>Wildcard Matching</source>
          <target state="translated">와일드 카드 일치</target>
        </trans-unit>
        <trans-unit id="264c29d9ea22af548e907b36f322bb974b5a6976" translate="yes" xml:space="preserve">
          <source>Wildcard matching</source>
          <target state="translated">와일드 카드 일치</target>
        </trans-unit>
        <trans-unit id="0689321b58e7a5fc78253890378bdaabbc1eb587" translate="yes" xml:space="preserve">
          <source>Wildcard matching can be convenient because of its simplicity, but any wildcard regexp can be defined using full regexps, e.g. &lt;b&gt;.*\.html$&lt;/b&gt;. Notice that we can't match both &lt;code&gt;.html&lt;/code&gt; and &lt;code&gt;.htm&lt;/code&gt; files with a wildcard unless we use &lt;b&gt;*.htm*&lt;/b&gt; which will also match 'test.html.bak'. A full regexp gives us the precision we need, &lt;b&gt;.*\.html?$&lt;/b&gt;.</source>
          <target state="translated">와일드 카드 일치는 단순하기 때문에 편리 할 수 ​​있지만 모든 정규식을 사용하여 와일드 카드 정규식을 정의 할 수 있습니다 (예 : &lt;b&gt;. * \. html $)&lt;/b&gt; . 'test.html.bak'과도 일치하는 &lt;b&gt;* .htm *&lt;/b&gt; 을 사용하지 않으면 &lt;code&gt;.html&lt;/code&gt; 및 &lt;code&gt;.htm&lt;/code&gt; 파일을 모두 와일드 카드 와 일치시킬 수 없습니다 . 전체 정규 표현식은 우리에게 우리가 필요로하는 정밀도를 제공합니다 &lt;b&gt;. * \. html로? $&lt;/b&gt; .&lt;b&gt;&lt;/b&gt;&lt;b&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="842dc21d7451aa6ca7d995ac3b01dfa569693150" translate="yes" xml:space="preserve">
          <source>Wildcards in Name Tests</source>
          <target state="translated">이름 테스트의 와일드 카드</target>
        </trans-unit>
        <trans-unit id="6e5c972bd26124738ee77c46943b74e25b91eac4" translate="yes" xml:space="preserve">
          <source>Will apply kerning between adjacent glyphs. Note that OpenType GPOS based kerning is currently not supported.</source>
          <target state="translated">인접한 글리프 사이에 커닝을 적용합니다. OpenType GPOS 기반 커닝은 현재 지원되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="6adcd11c4e61fb7fcde2432b7a7de1f735d1edeb" translate="yes" xml:space="preserve">
          <source>Will be used when &lt;a href=&quot;qml-qtquick-controls-styles-menustyle#styledata-properties&quot;&gt;styleData.checkable&lt;/a&gt; is &lt;code&gt;true&lt;/code&gt; and its appearance may depend on &lt;a href=&quot;qml-qtquick-controls-styles-menustyle#styledata-properties&quot;&gt;styleData.exclusive&lt;/a&gt;, i.e., whether it will behave like a checkbox or a radio button. Use &lt;a href=&quot;qml-qtquick-controls-styles-menustyle#styledata-properties&quot;&gt;styleData.checked&lt;/a&gt; for the checked state.</source>
          <target state="translated">때 사용됩니다 &lt;a href=&quot;qml-qtquick-controls-styles-menustyle#styledata-properties&quot;&gt;styleData.checkable가&lt;/a&gt; 있다 &lt;code&gt;true&lt;/code&gt; 과 그 모양이에 따라 달라질 수 있습니다 &lt;a href=&quot;qml-qtquick-controls-styles-menustyle#styledata-properties&quot;&gt;styleData.exclusive&lt;/a&gt; 은 체크 박스 또는 라디오 버튼처럼 작동 여부, 즉,. 확인 된 상태에는 &lt;a href=&quot;qml-qtquick-controls-styles-menustyle#styledata-properties&quot;&gt;styleData.checked&lt;/a&gt; 를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="51a4364950010d7d1a3acb13be6215316f24c111" translate="yes" xml:space="preserve">
          <source>Will be used when &lt;a href=&quot;qml-qtquick-controls-styles-menustyle#styledata-properties&quot;&gt;styleData.type&lt;/a&gt; equals &lt;code&gt;MenuItemType.ScrollIndicator&lt;/code&gt;. Its appearance should follow &lt;a href=&quot;qml-qtquick-controls-styles-menustyle#styledata-properties&quot;&gt;styleData.scrollerDirection&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;qml-qtquick-controls-styles-menustyle#styledata-properties&quot;&gt;styleData.type&lt;/a&gt; 이 &lt;code&gt;MenuItemType.ScrollIndicator&lt;/code&gt; 와 같은 경우에 사용됩니다 . 모양은 &lt;a href=&quot;qml-qtquick-controls-styles-menustyle#styledata-properties&quot;&gt;styleData.scrollerDirection&lt;/a&gt; 을 따라야 합니다 .</target>
        </trans-unit>
        <trans-unit id="2d3d1b653fde72951f28f65e2262012bbda10fb4" translate="yes" xml:space="preserve">
          <source>Will be used when &lt;a href=&quot;qml-qtquick-controls-styles-menustyle#styledata-properties&quot;&gt;styleData.type&lt;/a&gt; equals &lt;code&gt;MenuItemType.Separator&lt;/code&gt;.</source>
          <target state="translated">&lt;a href=&quot;qml-qtquick-controls-styles-menustyle#styledata-properties&quot;&gt;styleData.type&lt;/a&gt; 이 &lt;code&gt;MenuItemType.Separator&lt;/code&gt; 와 같은 경우에 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="2f33960d13f8f9fc04e9fc9347816f610864f0b2" translate="yes" xml:space="preserve">
          <source>Will calculate the advance for each glyph separately.</source>
          <target state="translated">각 글리프의 진행률을 별도로 계산합니다.</target>
        </trans-unit>
        <trans-unit id="4ce4d9e973b6847fa6d154ff1d851dfe8de757ff" translate="yes" xml:space="preserve">
          <source>Will emit the &lt;a href=&quot;qml-qtquick-controls-action#triggered-signal&quot;&gt;triggered&lt;/a&gt; signal if the action is enabled. You may provide a source object if the Action would benefit from knowing the origin of the triggering (e.g. for analytics). Will also emit the &lt;a href=&quot;qml-qtquick-controls-action#toggled-signal&quot;&gt;toggled&lt;/a&gt; signal if it is checkable.</source>
          <target state="translated">작업이 활성화 된 경우 &lt;a href=&quot;qml-qtquick-controls-action#triggered-signal&quot;&gt;트리거 된&lt;/a&gt; 신호를 방출합니다 . 액션이 트리거의 출처를 아는 것 (예 : 분석)을 통해 이익을 얻는 경우 소스 개체를 제공 할 수 있습니다. 확인 가능한 경우 &lt;a href=&quot;qml-qtquick-controls-action#toggled-signal&quot;&gt;토글 된&lt;/a&gt; 신호 도 방출합니다 .</target>
        </trans-unit>
        <trans-unit id="992c93fbc65bfa4b132279890e307aebb42bb7f8" translate="yes" xml:space="preserve">
          <source>Will rasterize by measuring the coverage of each subpixel, returning a separate alpha value for each of the red, green and blue components of each pixel.</source>
          <target state="translated">각 하위 픽셀의 적용 범위를 측정하여 각 픽셀의 빨강, 녹색 및 파랑 구성 요소마다 별도의 알파 값을 반환하여 래스터 화합니다.</target>
        </trans-unit>
        <trans-unit id="9d68c46bc41f81a77f83f10f64be90ea8298c3af" translate="yes" xml:space="preserve">
          <source>Will rasterize by measuring the coverage of the shape on whole pixels. The returned image contains the alpha values of each pixel based on the coverage of the glyph shape.</source>
          <target state="translated">전체 픽셀에서 모양의 범위를 측정하여 래스터 화합니다. 반환 된 이미지에는 글리프 모양의 적용 범위를 기준으로 각 픽셀의 알파 값이 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="cfd625b13d3522bd90aa1cf7729a05018cda7fe8" translate="yes" xml:space="preserve">
          <source>Will return &lt;code&gt;0&lt;/code&gt; if the size is automatically controlled by &lt;a href=&quot;https://doc.qt.io/qt-5.13/qtwebengine-module.html&quot;&gt;QtWebEngine&lt;/a&gt;.</source>
          <target state="translated">반환 &lt;code&gt;0&lt;/code&gt; 크기가 자동으로 조절되는 경우 &lt;a href=&quot;https://doc.qt.io/qt-5.13/qtwebengine-module.html&quot;&gt;QtWebEngine&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="694d20076668702064af4b5c6b9aab479e6fa21a" translate="yes" xml:space="preserve">
          <source>Will return an invalid &lt;a href=&quot;qgeomaneuver&quot;&gt;QGeoManeuver&lt;/a&gt; if no information has been attached to the starting point of this route segment.</source>
          <target state="translated">이 경로 세그먼트의 시작 지점에 정보가 첨부되지 않은 경우 유효하지 않은 &lt;a href=&quot;qgeomaneuver&quot;&gt;QGeoManeuver를&lt;/a&gt; 반환 합니다.</target>
        </trans-unit>
        <trans-unit id="0a4ef5f5759743ffb735d1db3489350440cdf859" translate="yes" xml:space="preserve">
          <source>Will return an invalid route segment if there are no route segments associated with the route.</source>
          <target state="translated">경로와 연관된 경로 세그먼트가없는 경우 유효하지 않은 경로 세그먼트를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="5159390ce4cc4497f2c1225b18cf5c8e403dd9f6" translate="yes" xml:space="preserve">
          <source>Will return an invalid route segment if this is the last route segment in the route.</source>
          <target state="translated">경로의 마지막 경로 세그먼트 인 경우 유효하지 않은 경로 세그먼트를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="7ad1aafdccf8b805105c57c9e774c1ad40595b7a" translate="yes" xml:space="preserve">
          <source>Will return invalid maneuver if no information has been attached to the endpoint of this route segment.</source>
          <target state="translated">이 경로 세그먼트의 끝점에 정보가 첨부되지 않은 경우 유효하지 않은 기동을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="7b653c1a1342f29b6e1ca16ef44b1d14c98a11e3" translate="yes" xml:space="preserve">
          <source>Win32</source>
          <target state="translated">Win32</target>
        </trans-unit>
        <trans-unit id="d2afd817a9a21d99da015861401e78ff2526d7a1" translate="yes" xml:space="preserve">
          <source>WinLayout</source>
          <target state="translated">WinLayout</target>
        </trans-unit>
        <trans-unit id="075ad31795be6f90667ef90b6e5605875ceafe6f" translate="yes" xml:space="preserve">
          <source>WinRT</source>
          <target state="translated">WinRT</target>
        </trans-unit>
        <trans-unit id="b0ecf59b61b6d43691094d1b7be8be240577897f" translate="yes" xml:space="preserve">
          <source>WinRT Runner Tool</source>
          <target state="translated">WinRT 러너 도구</target>
        </trans-unit>
        <trans-unit id="b2b2b1b85fe8deb53a167363dcd5fa56d7734c79" translate="yes" xml:space="preserve">
          <source>WinRT and Windows Phone support</source>
          <target state="translated">WinRT 및 Windows Phone 지원</target>
        </trans-unit>
        <trans-unit id="41dfc0a6c92707948578891c51d98c6443be63cc" translate="yes" xml:space="preserve">
          <source>Window</source>
          <target state="translated">Window</target>
        </trans-unit>
        <trans-unit id="b30704d31f5e4aca87353b66ee27f0816caa9047" translate="yes" xml:space="preserve">
          <source>Window (QML type)</source>
          <target state="translated">창 (QML 유형)</target>
        </trans-unit>
        <trans-unit id="afaebc89cf3ada29e4b3c2ac4b9b1ed9b0776e61" translate="yes" xml:space="preserve">
          <source>Window Geometry</source>
          <target state="translated">창 형상</target>
        </trans-unit>
        <trans-unit id="25c90920abe1ae75b09c4a801a9be777978eb59e" translate="yes" xml:space="preserve">
          <source>Window QML Type</source>
          <target state="translated">창 QML 유형</target>
        </trans-unit>
        <trans-unit id="b99fcf0354e6f2b755b1cd4436f8833d7b57f92d" translate="yes" xml:space="preserve">
          <source>Window and Dialog Widgets</source>
          <target state="translated">창 및 대화 상자 위젯</target>
        </trans-unit>
        <trans-unit id="df2b265af4964191becf35116f05a11290f1a10a" translate="yes" xml:space="preserve">
          <source>Window contents</source>
          <target state="translated">창 내용</target>
        </trans-unit>
        <trans-unit id="0693d8804ff10e8ccf636d73f83dc84b2aebcac8" translate="yes" xml:space="preserve">
          <source>Window flags are a combination of a type (e.g. &lt;a href=&quot;qt#WindowType-enum&quot;&gt;Qt::Dialog&lt;/a&gt;) and zero or more hints to the window system (e.g. &lt;a href=&quot;qt#WindowType-enum&quot;&gt;Qt::FramelessWindowHint&lt;/a&gt;).</source>
          <target state="translated">창 플래그는 유형 (예 : &lt;a href=&quot;qt#WindowType-enum&quot;&gt;Qt :: Dialog&lt;/a&gt; )과 창 시스템에 대한 0 개 이상의 힌트 (예 : &lt;a href=&quot;qt#WindowType-enum&quot;&gt;Qt :: FramelessWindowHint&lt;/a&gt; )의 조합입니다.</target>
        </trans-unit>
        <trans-unit id="c757786995d9190138fd07f2d2690dd25188aab3" translate="yes" xml:space="preserve">
          <source>Window flags are a combination of a window type (e.g., &lt;a href=&quot;qt#WindowType-enum&quot;&gt;Qt::Dialog&lt;/a&gt;) and several flags giving hints on the behavior of the window. The behavior is platform-dependent.</source>
          <target state="translated">창 플래그는 창 유형 (예 : &lt;a href=&quot;qt#WindowType-enum&quot;&gt;Qt :: Dialog&lt;/a&gt; )과 창의 동작에 대한 힌트를 제공하는 여러 플래그 의 조합입니다 . 동작은 플랫폼에 따라 다릅니다.</target>
        </trans-unit>
        <trans-unit id="cec65d78532248828b5443e4752a3df7fc4931aa" translate="yes" xml:space="preserve">
          <source>Window functions</source>
          <target state="translated">창 기능</target>
        </trans-unit>
        <trans-unit id="3fa481de6469402233a67efbe0146e989104a11b" translate="yes" xml:space="preserve">
          <source>Window resize handle; see also &lt;a href=&quot;qsizegrip&quot;&gt;QSizeGrip&lt;/a&gt;.</source>
          <target state="translated">창 크기 조정 핸들; &lt;a href=&quot;qsizegrip&quot;&gt;QSizeGrip&lt;/a&gt; 도 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="d18acd2371180466957c4dbeb8c95ca75708947a" translate="yes" xml:space="preserve">
          <source>Window title label.</source>
          <target state="translated">창 제목 레이블.</target>
        </trans-unit>
        <trans-unit id="1e7af5039c861fb07ace18801d508cb564adec81" translate="yes" xml:space="preserve">
          <source>Window was activated.</source>
          <target state="translated">창이 활성화되었습니다.</target>
        </trans-unit>
        <trans-unit id="11241d466e6bf788119916fe31fa36aaa7c680d9" translate="yes" xml:space="preserve">
          <source>Window was deactivated.</source>
          <target state="translated">창이 비활성화되었습니다.</target>
        </trans-unit>
        <trans-unit id="4e78ce50aed27fdd7018ad1a6b33852628dd8aaf" translate="yes" xml:space="preserve">
          <source>Window-Viewport Conversion</source>
          <target state="translated">창-뷰포트 변환</target>
        </trans-unit>
        <trans-unit id="9a56ea565b4ff2a96660fbe8df2fd15d5fb6f4db" translate="yes" xml:space="preserve">
          <source>Window. This will lead to the windowing system managing the clip of the window, so it will be clipped to the</source>
          <target state="translated">창문. 이것은 윈도우 클립을 윈도우 클립으로 관리하는 윈도우 시스템으로 이어질 것입니다.</target>
        </trans-unit>
        <trans-unit id="75aa12a30bbd7073b47f5f7cb99f4d1c6a2ea986" translate="yes" xml:space="preserve">
          <source>Window.Window.active</source>
          <target state="translated">Window.Window.active</target>
        </trans-unit>
        <trans-unit id="69cabe1a21fa926547a70fb8587746688fc196f1" translate="yes" xml:space="preserve">
          <source>Window.Window.activeFocusItem</source>
          <target state="translated">Window.Window.activeFocusItem</target>
        </trans-unit>
        <trans-unit id="616a52190bba5239135d8c4e401392811e83de3c" translate="yes" xml:space="preserve">
          <source>Window.Window.contentItem</source>
          <target state="translated">Window.Window.contentItem</target>
        </trans-unit>
        <trans-unit id="22953b19762a43065d9148abdac6278d7ff2c104" translate="yes" xml:space="preserve">
          <source>Window.Window.visibility</source>
          <target state="translated">Window.Window.visibility</target>
        </trans-unit>
        <trans-unit id="84c607816af9ce44f380ed26c792699caaa61a38" translate="yes" xml:space="preserve">
          <source>Window.Window.width</source>
          <target state="translated">Window.Window.width</target>
        </trans-unit>
        <trans-unit id="0d4fed8f27b6cb28fb107fea7f57b40019985ce5" translate="yes" xml:space="preserve">
          <source>Window.Window.window</source>
          <target state="translated">Window.Window.window</target>
        </trans-unit>
        <trans-unit id="179cf5d5f2dd427ea72db08711aff317c829519c" translate="yes" xml:space="preserve">
          <source>Window.active</source>
          <target state="translated">Window.active</target>
        </trans-unit>
        <trans-unit id="2ec4c77567c5777d0776cd5af31f66116b105f3c" translate="yes" xml:space="preserve">
          <source>Window.active : &lt;a href=&quot;qml-bool&quot;&gt;bool&lt;/a&gt;</source>
          <target state="translated">Window.active : &lt;a href=&quot;qml-bool&quot;&gt;부울&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="3bbff09b2773e67a67998e0160db3a070da2a71c" translate="yes" xml:space="preserve">
          <source>Window.activeFocusItem</source>
          <target state="translated">Window.activeFocusItem</target>
        </trans-unit>
        <trans-unit id="102676071e8f5b0b5bf6e797da1cc51a37367db6" translate="yes" xml:space="preserve">
          <source>Window.activeFocusItem : &lt;a href=&quot;qml-qtquick-item&quot;&gt;Item&lt;/a&gt;</source>
          <target state="translated">Window.activeFocusItem : &lt;a href=&quot;qml-qtquick-item&quot;&gt;항목&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="4f8be4631d56a2a94c008c796a3eb4aa92aca3cb" translate="yes" xml:space="preserve">
          <source>Window.alert()</source>
          <target state="translated">Window.alert()</target>
        </trans-unit>
        <trans-unit id="6b43e57fc6c8546f7d0a20f409e420ff5d4e65f9" translate="yes" xml:space="preserve">
          <source>Window.close()</source>
          <target state="translated">Window.close()</target>
        </trans-unit>
        <trans-unit id="a7c9eb3479ef7276390ef7962c488325517f5cbb" translate="yes" xml:space="preserve">
          <source>Window.closing()</source>
          <target state="translated">Window.closing()</target>
        </trans-unit>
        <trans-unit id="f3bde14aa0bf20f81ada76a1e414cbe06cc13469" translate="yes" xml:space="preserve">
          <source>Window.color</source>
          <target state="translated">Window.color</target>
        </trans-unit>
        <trans-unit id="f7faf5ce1f3058190f74f96458908c816c80839e" translate="yes" xml:space="preserve">
          <source>Window.contentItem</source>
          <target state="translated">Window.contentItem</target>
        </trans-unit>
        <trans-unit id="09dc7d67387c54c429eabc833a823f696fb935b5" translate="yes" xml:space="preserve">
          <source>Window.contentItem : &lt;a href=&quot;qml-qtquick-item&quot;&gt;Item&lt;/a&gt;</source>
          <target state="translated">Window.contentItem : &lt;a href=&quot;qml-qtquick-item&quot;&gt;아이템&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="f032a1a0e9d0f20ee5939a3ea15f61dbe8f060f9" translate="yes" xml:space="preserve">
          <source>Window.contentOrientation</source>
          <target state="translated">Window.contentOrientation</target>
        </trans-unit>
        <trans-unit id="d613e60a74c019962e8dc76775ee501bcbf5920a" translate="yes" xml:space="preserve">
          <source>Window.data</source>
          <target state="translated">Window.data</target>
        </trans-unit>
        <trans-unit id="11fcb002371eb69617294814e444f487941c6fa1" translate="yes" xml:space="preserve">
          <source>Window.flags</source>
          <target state="translated">Window.flags</target>
        </trans-unit>
        <trans-unit id="76df9491595a49d076cf9f272b97202e15e48128" translate="yes" xml:space="preserve">
          <source>Window.hide()</source>
          <target state="translated">Window.hide()</target>
        </trans-unit>
        <trans-unit id="d1d8ee90db101d9aa7127f0ec7d71ef5b59327e6" translate="yes" xml:space="preserve">
          <source>Window.lower()</source>
          <target state="translated">Window.lower()</target>
        </trans-unit>
        <trans-unit id="ed13acfb5440376e7f9248628afa96f7cc080358" translate="yes" xml:space="preserve">
          <source>Window.maximumWidth</source>
          <target state="translated">Window.maximumWidth</target>
        </trans-unit>
        <trans-unit id="aebb18a4f2359f546fa8b333d847995d3a5ef4e8" translate="yes" xml:space="preserve">
          <source>Window.minimumWidth</source>
          <target state="translated">Window.minimumWidth</target>
        </trans-unit>
        <trans-unit id="215facd6841224bd8b80b0e006b6ac17f0950cbb" translate="yes" xml:space="preserve">
          <source>Window.modality</source>
          <target state="translated">Window.modality</target>
        </trans-unit>
        <trans-unit id="52b30f9332e30d272f1cbe7146d9734ff2e3a054" translate="yes" xml:space="preserve">
          <source>Window.opacity</source>
          <target state="translated">Window.opacity</target>
        </trans-unit>
        <trans-unit id="5c1a6d6492ac874f9e18f2d2de58a1ed70ac7075" translate="yes" xml:space="preserve">
          <source>Window.raise()</source>
          <target state="translated">Window.raise()</target>
        </trans-unit>
        <trans-unit id="500cae6ce1cd976b0844ee9632f2878e1490269c" translate="yes" xml:space="preserve">
          <source>Window.requestActivate()</source>
          <target state="translated">Window.requestActivate()</target>
        </trans-unit>
        <trans-unit id="962ec69a27517c38617be980e1a32ddfb58994c1" translate="yes" xml:space="preserve">
          <source>Window.screen</source>
          <target state="translated">Window.screen</target>
        </trans-unit>
        <trans-unit id="0836742cd959538d97470c7c5bb8e340e0e0b143" translate="yes" xml:space="preserve">
          <source>Window.show()</source>
          <target state="translated">Window.show()</target>
        </trans-unit>
        <trans-unit id="15504334bab2ba8401f9c0c42488a68ecf682d96" translate="yes" xml:space="preserve">
          <source>Window.showFullScreen()</source>
          <target state="translated">Window.showFullScreen()</target>
        </trans-unit>
        <trans-unit id="7a246186c9eb48c96b4f883f3c6ed5900df7bd62" translate="yes" xml:space="preserve">
          <source>Window.showMaximized()</source>
          <target state="translated">Window.showMaximized()</target>
        </trans-unit>
        <trans-unit id="9721d3ac26edfe36e03b800b63ea8a88c859ba6d" translate="yes" xml:space="preserve">
          <source>Window.showMinimized()</source>
          <target state="translated">Window.showMinimized()</target>
        </trans-unit>
        <trans-unit id="ecb33e6d10f93ea783d42c3441c123f5ac26ae90" translate="yes" xml:space="preserve">
          <source>Window.showNormal()</source>
          <target state="translated">Window.showNormal()</target>
        </trans-unit>
        <trans-unit id="b1a931100f91b3faa30216470bb54c3f9ef3a759" translate="yes" xml:space="preserve">
          <source>Window.title</source>
          <target state="translated">Window.title</target>
        </trans-unit>
        <trans-unit id="f84bfdc72053f81e11626d23f71d5a72df94234a" translate="yes" xml:space="preserve">
          <source>Window.transientParent</source>
          <target state="translated">Window.transientParent</target>
        </trans-unit>
        <trans-unit id="add5b572eae34b1475c4ac663ea27705fe0c5b75" translate="yes" xml:space="preserve">
          <source>Window.visibility</source>
          <target state="translated">Window.visibility</target>
        </trans-unit>
        <trans-unit id="31290646537daaae9feb4d0a6aa47fa2d4fe8dd1" translate="yes" xml:space="preserve">
          <source>Window.visibility : QWindow::Visibility</source>
          <target state="translated">Window.visibility : QWindow :: 가시성</target>
        </trans-unit>
        <trans-unit id="040ee819374dd276f63a974e22660242040fe0ef" translate="yes" xml:space="preserve">
          <source>Window.visible</source>
          <target state="translated">Window.visible</target>
        </trans-unit>
        <trans-unit id="e2b6f01ff5b633118333310b09ad9f8d07bb756c" translate="yes" xml:space="preserve">
          <source>Window.width : &lt;a href=&quot;qml-int&quot;&gt;int&lt;/a&gt;</source>
          <target state="translated">Window.width : &lt;a href=&quot;qml-int&quot;&gt;int&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="ec9ee6d9fc2efb6ef3252fdd48706b294f871836" translate="yes" xml:space="preserve">
          <source>Window.window : &lt;a href=&quot;qml-qtquick-window-window&quot;&gt;Window&lt;/a&gt;</source>
          <target state="translated">Window.window : &lt;a href=&quot;qml-qtquick-window-window&quot;&gt;창&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="bcec8455d55425584f2b15ec6321324bf53d5617" translate="yes" xml:space="preserve">
          <source>Window.x</source>
          <target state="translated">Window.x</target>
        </trans-unit>
        <trans-unit id="26d9c28d789c254f71ea99a3463b99a7ccc2f4fa" translate="yes" xml:space="preserve">
          <source>Windows</source>
          <target state="translated">Windows</target>
        </trans-unit>
        <trans-unit id="14bcdd30e3b008c3e7cd704a84f73d1bfd731c35" translate="yes" xml:space="preserve">
          <source>Windows (UWP)</source>
          <target state="translated">윈도우 (UWP)</target>
        </trans-unit>
        <trans-unit id="d1964a9d6c89b899acb90493c815573a0d6f6ea7" translate="yes" xml:space="preserve">
          <source>Windows (Win32 desktop, via XInput 1.3 &amp;amp; 1.4)</source>
          <target state="translated">Windows (Win32 데스크탑, XInput 1.3 및 1.4)</target>
        </trans-unit>
        <trans-unit id="964670c3979f39f09220262ac02382dcc43eb2c3" translate="yes" xml:space="preserve">
          <source>Windows (classic desktop)</source>
          <target state="translated">Windows (클래식 데스크탑)</target>
        </trans-unit>
        <trans-unit id="ba69620743da0d9dcd1d7e5dc758450978354d5d" translate="yes" xml:space="preserve">
          <source>Windows (desktop)</source>
          <target state="translated">Windows (데스크톱)</target>
        </trans-unit>
        <trans-unit id="1cb7956bf146a8ba0806fced6a0163472a25a83e" translate="yes" xml:space="preserve">
          <source>Windows 10</source>
          <target state="translated">윈도우 10</target>
        </trans-unit>
        <trans-unit id="1afe86f5efcb6d9798deb38cbf3ecf0a9ebaf810" translate="yes" xml:space="preserve">
          <source>Windows 10 (1809) October 2018 Update</source>
          <target state="translated">Windows 10 (1809) 2018 년 10 월 업데이트</target>
        </trans-unit>
        <trans-unit id="d23b7faed6bed5922202a2b284d65aff84bf884f" translate="yes" xml:space="preserve">
          <source>Windows 10 Desktop</source>
          <target state="translated">Windows 10 데스크탑</target>
        </trans-unit>
        <trans-unit id="ad030707429da2bedc40732e3d358db41d7651fa" translate="yes" xml:space="preserve">
          <source>Windows 10 IoT</source>
          <target state="translated">Windows 10 IoT</target>
        </trans-unit>
        <trans-unit id="4db48ac648a42f512034fb991a7275e05d76ee88" translate="yes" xml:space="preserve">
          <source>Windows 10 Mobile</source>
          <target state="translated">윈도우 10 모바일</target>
        </trans-unit>
        <trans-unit id="94cada20ad68e1ffe3678826da4a09dc6377e803" translate="yes" xml:space="preserve">
          <source>Windows 7</source>
          <target state="translated">윈도우 7</target>
        </trans-unit>
        <trans-unit id="2421598f872b2a34cd8e8c5cdad74ac27cddd334" translate="yes" xml:space="preserve">
          <source>Windows 7 and Windows Vista (w/Platform Update) and DirectWrite enabled in Qt</source>
          <target state="translated">Qt에서 Windows 7 및 Windows Vista (플랫폼 업데이트 포함) 및 DirectWrite 사용</target>
        </trans-unit>
        <trans-unit id="9fe8c734d18c33e1fe587ed88ac86891c9413013" translate="yes" xml:space="preserve">
          <source>Windows 8.1</source>
          <target state="translated">윈도우 8.1</target>
        </trans-unit>
        <trans-unit id="0059c3585082dc8d8fa84aace5dd9574f5a647b2" translate="yes" xml:space="preserve">
          <source>Windows Aero look</source>
          <target state="translated">윈도우 에어로 룩</target>
        </trans-unit>
        <trans-unit id="9603341802d381e4f5dc9450d5f60203fbb1367e" translate="yes" xml:space="preserve">
          <source>Windows Bitmap</source>
          <target state="translated">Windows 비트 맵</target>
        </trans-unit>
        <trans-unit id="b5752a2453d550da484c9d85a1aca88f944da161" translate="yes" xml:space="preserve">
          <source>Windows Format</source>
          <target state="translated">Windows 형식</target>
        </trans-unit>
        <trans-unit id="c779efcd40e07a5f099b994086b2eecbec95fdbf" translate="yes" xml:space="preserve">
          <source>Windows RT</source>
          <target state="translated">윈도우 RT</target>
        </trans-unit>
        <trans-unit id="176562ff7a9ca628c45f66dfe5d7eb18c0c0ff3c" translate="yes" xml:space="preserve">
          <source>Windows Runtime</source>
          <target state="translated">윈도우 런타임</target>
        </trans-unit>
        <trans-unit id="fb193893e70258d483f93a714af1f0fbcff9cfab" translate="yes" xml:space="preserve">
          <source>Windows Time Zones</source>
          <target state="translated">Windows 시간대</target>
        </trans-unit>
        <trans-unit id="abcf695d570ffe730c49f508b0e37f63d25ee587" translate="yes" xml:space="preserve">
          <source>Windows Vista (w/o Platform Update) and earlier</source>
          <target state="translated">Windows Vista (플랫폼 업데이트 없음) 및 이전</target>
        </trans-unit>
        <trans-unit id="76f20bccfe3512339ad2cea01fc1c7809e7d3d15" translate="yes" xml:space="preserve">
          <source>Windows XP</source>
          <target state="translated">윈도우 XP</target>
        </trans-unit>
        <trans-unit id="dd2494d5f30b3df0c2226e4d63b5a83102d7c014" translate="yes" xml:space="preserve">
          <source>Windows and &lt;a href=&quot;internationalization#macos&quot;&gt;macOS&lt;/a&gt; do not support the global mouse selection; they only supports the global clipboard, i.e. they only add text to the clipboard when an explicit copy or cut is made.</source>
          <target state="translated">Windows 및 &lt;a href=&quot;internationalization#macos&quot;&gt;macOS&lt;/a&gt; 는 전역 마우스 선택을 지원하지 않습니다. 글로벌 클립 보드 만 지원합니다. 즉, 명시 적으로 복사하거나 잘라낼 때 클립 보드에 텍스트 만 추가합니다.</target>
        </trans-unit>
        <trans-unit id="c6f63f1ca0009002926ff7190a74402cec32c6d5" translate="yes" xml:space="preserve">
          <source>Windows and &lt;a href=&quot;internationalization#macos&quot;&gt;macOS&lt;/a&gt; does not have the concept of ownership; the clipboard is a fully global resource so all applications are notified of changes.</source>
          <target state="translated">Windows와 &lt;a href=&quot;internationalization#macos&quot;&gt;macOS&lt;/a&gt; 에는 소유권 개념이 없습니다. 클립 보드는 완전한 글로벌 리소스이므로 모든 응용 프로그램에 변경 사항이 통보됩니다.</target>
        </trans-unit>
        <trans-unit id="88023dbcc508c8f7a7c5cbf262c9b6f719968ac5" translate="yes" xml:space="preserve">
          <source>Windows and Screen</source>
          <target state="translated">창과 스크린</target>
        </trans-unit>
        <trans-unit id="4530472b3bdecaac3503faee0951ef1625f27946" translate="yes" xml:space="preserve">
          <source>Windows are panels. If you set the &lt;a href=&quot;qt#WindowType-enum&quot;&gt;Qt::Window&lt;/a&gt; flag, the &lt;a href=&quot;qgraphicsitem#GraphicsItemFlag-enum&quot;&gt;ItemIsPanel&lt;/a&gt; flag will be set automatically. If you clear the &lt;a href=&quot;qt#WindowType-enum&quot;&gt;Qt::Window&lt;/a&gt; flag, the &lt;a href=&quot;qgraphicsitem#GraphicsItemFlag-enum&quot;&gt;ItemIsPanel&lt;/a&gt; flag is also cleared. Note that the &lt;a href=&quot;qgraphicsitem#GraphicsItemFlag-enum&quot;&gt;ItemIsPanel&lt;/a&gt; flag can be set independently of &lt;a href=&quot;qt#WindowType-enum&quot;&gt;Qt::Window&lt;/a&gt;.</source>
          <target state="translated">Windows는 패널입니다. &lt;a href=&quot;qt#WindowType-enum&quot;&gt;Qt :: Window&lt;/a&gt; 플래그 를 설정하면 &lt;a href=&quot;qgraphicsitem#GraphicsItemFlag-enum&quot;&gt;ItemIsPanel&lt;/a&gt; 플래그가 자동으로 설정됩니다. &lt;a href=&quot;qt#WindowType-enum&quot;&gt;Qt :: Window&lt;/a&gt; 플래그 를 지우면 &lt;a href=&quot;qgraphicsitem#GraphicsItemFlag-enum&quot;&gt;ItemIsPanel&lt;/a&gt; 플래그도 지워집니다. 있습니다 &lt;a href=&quot;qgraphicsitem#GraphicsItemFlag-enum&quot;&gt;ItemIsPanel의&lt;/a&gt; 플래그가 독립적으로 설정할 수 있습니다 &lt;a href=&quot;qt#WindowType-enum&quot;&gt;Qt는 :: 창&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="6864cc15af1f952f69248443d0f4dc03d3b25bb5" translate="yes" xml:space="preserve">
          <source>Windows can potentially use a lot of memory. A usual measurement is width times height times color depth. A window might also include multiple buffers to support double and triple buffering, as well as depth and stencil buffers. To release a window's memory resources, call the &lt;a href=&quot;qwindow#destroy&quot;&gt;destroy&lt;/a&gt;() function.</source>
          <target state="translated">Windows는 잠재적으로 많은 메모리를 사용할 수 있습니다. 일반적인 측정은 너비와 높이와 색상 깊이의 차이입니다. 창에는 이중 및 삼중 버퍼링뿐만 아니라 깊이 및 스텐실 버퍼를 지원하는 여러 버퍼가 포함될 수도 있습니다. 윈도우의 메모리 리소스를 해제하려면 &lt;a href=&quot;qwindow#destroy&quot;&gt;destroy&lt;/a&gt; () 함수를 호출하십시오 .</target>
        </trans-unit>
        <trans-unit id="c001b9e66e2b63587d28dcdcba9f086ad6b8b570" translate="yes" xml:space="preserve">
          <source>Windows native time zone support is severely limited compared to the standard IANA TZ Database. Windows time zones cover larger geographic areas and are thus less accurate in their conversions. They also do not support as much historic conversion data and so may only be accurate for the current year.</source>
          <target state="translated">Windows 기본 시간대 지원은 표준 IANA TZ 데이터베이스에 비해 심각하게 제한됩니다. Windows 표준 시간대는 더 넓은 지역을 다루므로 변환시 정확도가 떨어집니다. 또한 많은 과거 전환 데이터를 지원하지 않으므로 현재 연도에만 정확할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="dc3313e9f2888acedb3a46ca240a29badb9ae9a8" translate="yes" xml:space="preserve">
          <source>Windows only, Direct2D based engine</source>
          <target state="translated">Windows 전용, Direct2D 기반 엔진</target>
        </trans-unit>
        <trans-unit id="a42fff1d14dd2ae9835c8ac0c2f009a4f65d20db" translate="yes" xml:space="preserve">
          <source>Windows only, Direct3D based engine</source>
          <target state="translated">Windows 전용, Direct3D 기반 엔진</target>
        </trans-unit>
        <trans-unit id="d199049029a1551cfb834f30df67ee5137b30d5f" translate="yes" xml:space="preserve">
          <source>Windows only. Creates a library project for Visual Studio.</source>
          <target state="translated">Windows 만 해당 Visual Studio 용 라이브러리 프로젝트를 만듭니다.</target>
        </trans-unit>
        <trans-unit id="2e356099ec8eff63706235872ca98e82811f76e2" translate="yes" xml:space="preserve">
          <source>Windows only. Creates an application project for Visual Studio. See &lt;a href=&quot;qmake-platform-notes#creating-visual-studio-project-files&quot;&gt;Creating Visual Studio Project Files&lt;/a&gt; for more information.</source>
          <target state="translated">Windows 만 해당 Visual Studio 용 응용 프로그램 프로젝트를 만듭니다. 자세한 내용은 &lt;a href=&quot;qmake-platform-notes#creating-visual-studio-project-files&quot;&gt;Visual Studio 프로젝트 파일 만들기&lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="9a507b2bcfe2d1bdca3de1fb8ef440ea096e7258" translate="yes" xml:space="preserve">
          <source>Windows only. Specifies the codepage that should be specified in a generated .rc file. This is only utilized if the &lt;a href=&quot;#version&quot;&gt;VERSION&lt;/a&gt; or &lt;a href=&quot;#rc-icons&quot;&gt;RC_ICONS&lt;/a&gt; variable is set and the &lt;a href=&quot;#rc-file&quot;&gt;RC_FILE&lt;/a&gt; and &lt;a href=&quot;#res-file&quot;&gt;RES_FILE&lt;/a&gt; variables are not set.</source>
          <target state="translated">Windows 만 해당 생성 된 .rc 파일에 지정해야하는 코드 페이지를 지정합니다. 이것은 &lt;a href=&quot;#version&quot;&gt;VERSION&lt;/a&gt; 또는 &lt;a href=&quot;#rc-icons&quot;&gt;RC_ICONS&lt;/a&gt; 변수가 설정되고 &lt;a href=&quot;#rc-file&quot;&gt;RC_FILE&lt;/a&gt; 및 &lt;a href=&quot;#res-file&quot;&gt;RES_FILE&lt;/a&gt; 변수가 설정되지 않은 경우에만 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="2243d54caddf6d062e1a834d48f6f71722158bf3" translate="yes" xml:space="preserve">
          <source>Windows only. Specifies the company for the project target; this is used where applicable for putting the company name in the application's properties. This is only utilized if the &lt;a href=&quot;#version&quot;&gt;VERSION&lt;/a&gt; or &lt;a href=&quot;#rc-icons&quot;&gt;RC_ICONS&lt;/a&gt; variable is set and the &lt;a href=&quot;#rc-file&quot;&gt;RC_FILE&lt;/a&gt; and &lt;a href=&quot;#res-file&quot;&gt;RES_FILE&lt;/a&gt; variables are not set.</source>
          <target state="translated">Windows 만 해당 프로젝트 대상의 회사를 지정합니다. 회사 이름을 응용 프로그램 속성에 넣을 때 적용됩니다. 이것은 &lt;a href=&quot;#version&quot;&gt;VERSION&lt;/a&gt; 또는 &lt;a href=&quot;#rc-icons&quot;&gt;RC_ICONS&lt;/a&gt; 변수가 설정되고 &lt;a href=&quot;#rc-file&quot;&gt;RC_FILE&lt;/a&gt; 및 &lt;a href=&quot;#res-file&quot;&gt;RES_FILE&lt;/a&gt; 변수가 설정되지 않은 경우에만 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="19bf01b86a10419b90ee1ccfb53e051d44003eb6" translate="yes" xml:space="preserve">
          <source>Windows only. Specifies the copyright information for the project target; this is used where applicable for putting the copyright information in the application's properties. This is only utilized if the &lt;a href=&quot;#version&quot;&gt;VERSION&lt;/a&gt; or &lt;a href=&quot;#rc-icons&quot;&gt;RC_ICONS&lt;/a&gt; variable is set and the &lt;a href=&quot;#rc-file&quot;&gt;RC_FILE&lt;/a&gt; and &lt;a href=&quot;#res-file&quot;&gt;RES_FILE&lt;/a&gt; variables are not set.</source>
          <target state="translated">Windows 만 해당 프로젝트 대상의 저작권 정보를 지정합니다. 응용 프로그램의 속성에 저작권 정보를 넣을 때 적용됩니다. 이것은 &lt;a href=&quot;#version&quot;&gt;VERSION&lt;/a&gt; 또는 &lt;a href=&quot;#rc-icons&quot;&gt;RC_ICONS&lt;/a&gt; 변수가 설정되고 &lt;a href=&quot;#rc-file&quot;&gt;RC_FILE&lt;/a&gt; 및 &lt;a href=&quot;#res-file&quot;&gt;RES_FILE&lt;/a&gt; 변수가 설정되지 않은 경우에만 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="c333020ab74e8a3179b0ccde29f65fc886d6230a" translate="yes" xml:space="preserve">
          <source>Windows only. Specifies the description for the project target; this is used where applicable for putting the description in the application's properties. This is only utilized if the &lt;a href=&quot;#version&quot;&gt;VERSION&lt;/a&gt; or &lt;a href=&quot;#rc-icons&quot;&gt;RC_ICONS&lt;/a&gt; variable is set and the &lt;a href=&quot;#rc-file&quot;&gt;RC_FILE&lt;/a&gt; and &lt;a href=&quot;#res-file&quot;&gt;RES_FILE&lt;/a&gt; variables are not set.</source>
          <target state="translated">Windows 만 해당 프로젝트 대상에 대한 설명을 지정합니다. 이것은 응용 프로그램의 속성에 설명을 넣을 때 적용됩니다. 이것은 &lt;a href=&quot;#version&quot;&gt;VERSION&lt;/a&gt; 또는 &lt;a href=&quot;#rc-icons&quot;&gt;RC_ICONS&lt;/a&gt; 변수가 설정되고 &lt;a href=&quot;#rc-file&quot;&gt;RC_FILE&lt;/a&gt; 및 &lt;a href=&quot;#res-file&quot;&gt;RES_FILE&lt;/a&gt; 변수가 설정되지 않은 경우에만 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="147326ac5b89ba5b28c67ac522efbc70c06eb4e4" translate="yes" xml:space="preserve">
          <source>Windows only. Specifies the icons that should be included into a generated .rc file. This is only utilized if the &lt;a href=&quot;#rc-file&quot;&gt;RC_FILE&lt;/a&gt; and &lt;a href=&quot;#res-file&quot;&gt;RES_FILE&lt;/a&gt; variable are not set. More details about the generation of .rc files can be found in the &lt;a href=&quot;qmake-platform-notes#&quot;&gt;Platform Notes&lt;/a&gt;.</source>
          <target state="translated">Windows 만 해당 생성 된 .rc 파일에 포함되어야하는 아이콘을 지정합니다. &lt;a href=&quot;#rc-file&quot;&gt;RC_FILE&lt;/a&gt; 및 &lt;a href=&quot;#res-file&quot;&gt;RES_FILE&lt;/a&gt; 변수가 설정되지 않은 경우에만 사용됩니다 . .rc 파일 생성에 대한 자세한 내용은 &lt;a href=&quot;qmake-platform-notes#&quot;&gt;플랫폼 노트를 참조하십시오&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="40ae8a9f462e8bb651ff56c1c30dfab4c72ea64b" translate="yes" xml:space="preserve">
          <source>Windows only. Specifies the language that should be specified in a generated .rc file. This is only utilized if the &lt;a href=&quot;#version&quot;&gt;VERSION&lt;/a&gt; or &lt;a href=&quot;#rc-icons&quot;&gt;RC_ICONS&lt;/a&gt; variable is set and the &lt;a href=&quot;#rc-file&quot;&gt;RC_FILE&lt;/a&gt; and &lt;a href=&quot;#res-file&quot;&gt;RES_FILE&lt;/a&gt; variables are not set.</source>
          <target state="translated">Windows 만 해당 생성 된 .rc 파일에 지정해야 할 언어를 지정합니다. 이것은 &lt;a href=&quot;#version&quot;&gt;VERSION&lt;/a&gt; 또는 &lt;a href=&quot;#rc-icons&quot;&gt;RC_ICONS&lt;/a&gt; 변수가 설정되고 &lt;a href=&quot;#rc-file&quot;&gt;RC_FILE&lt;/a&gt; 및 &lt;a href=&quot;#res-file&quot;&gt;RES_FILE&lt;/a&gt; 변수가 설정되지 않은 경우에만 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="52b3eb085c22889904a231f68cf350b66520f1d0" translate="yes" xml:space="preserve">
          <source>Windows only. Specifies the product for the project target; this is used where applicable for putting the product in the application's properties. This is only utilized if the &lt;a href=&quot;#version&quot;&gt;VERSION&lt;/a&gt; or &lt;a href=&quot;#rc-icons&quot;&gt;RC_ICONS&lt;/a&gt; variable is set and the &lt;a href=&quot;#rc-file&quot;&gt;RC_FILE&lt;/a&gt; and &lt;a href=&quot;#res-file&quot;&gt;RES_FILE&lt;/a&gt; variables are not set.</source>
          <target state="translated">Windows 만 해당 프로젝트 대상의 제품을 지정합니다. 응용 프로그램의 속성에 제품을 넣을 때 적용됩니다. 이것은 &lt;a href=&quot;#version&quot;&gt;VERSION&lt;/a&gt; 또는 &lt;a href=&quot;#rc-icons&quot;&gt;RC_ICONS&lt;/a&gt; 변수가 설정되고 &lt;a href=&quot;#rc-file&quot;&gt;RC_FILE&lt;/a&gt; 및 &lt;a href=&quot;#res-file&quot;&gt;RES_FILE&lt;/a&gt; 변수가 설정되지 않은 경우에만 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="e68c590bba3dc40637f317996ef3738619b01f03" translate="yes" xml:space="preserve">
          <source>Windows only. Specifies the version number, that the Windows linker puts into the header of the .exe or .dll file via the /VERSION option. Only a major and minor version may be specified. If &lt;a href=&quot;#version-pe-header&quot;&gt;VERSION_PE_HEADER&lt;/a&gt; is not set, it falls back to the major and minor version from &lt;a href=&quot;#version&quot;&gt;VERSION&lt;/a&gt; (if set).</source>
          <target state="translated">Windows 만 해당 Windows 링커가 / VERSION 옵션을 통해 .exe 또는 .dll 파일의 헤더에 넣는 버전 번호를 지정합니다. 메이저 버전과 마이너 버전 만 지정할 수 있습니다. 경우 &lt;a href=&quot;#version-pe-header&quot;&gt;VERSION_PE_HEADER이&lt;/a&gt; 설정되어 있지 않은, 그것의 메이저와 마이너 버전으로 다시 떨어질 &lt;a href=&quot;#version&quot;&gt;버전&lt;/a&gt; (있는 경우 설정).</target>
        </trans-unit>
        <trans-unit id="3155e904f0d062c5d534df0d5a48138de41c9b3f" translate="yes" xml:space="preserve">
          <source>Windows only. qmake adds the values of this variable as RC preprocessor macros (/d option). If this variable is not set, the &lt;a href=&quot;#defines&quot;&gt;DEFINES&lt;/a&gt; variable is used instead.</source>
          <target state="translated">Windows 만 해당 qmake는이 변수의 값을 RC 전 처리기 매크로 (/ d 옵션)로 추가합니다. 이 변수를 설정하지 않으면 &lt;a href=&quot;#defines&quot;&gt;DEFINES&lt;/a&gt; 변수가 대신 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="4df68020be8317aea615b4ce4211f35ec1fa9587" translate="yes" xml:space="preserve">
          <source>Windows only: Explicitly access the 32-bit system registry from a 64-bit application running on 64-bit Windows. On 32-bit Windows or from a 32-bit application on 64-bit Windows, this works the same as specifying NativeFormat. This enum value was added in Qt 5.7.</source>
          <target state="translated">Windows 전용 : 64 비트 Windows에서 실행중인 64 비트 응용 프로그램에서 32 비트 시스템 레지스트리에 명시 적으로 액세스하십시오. 32 비트 Windows 또는 64 비트 Windows의 32 비트 응용 프로그램에서 NativeFormat을 지정하는 것과 동일하게 작동합니다. 이 열거 형 값은 Qt 5.7에 추가되었습니다.</target>
        </trans-unit>
        <trans-unit id="2f06158236694c4fb22e3870b5033f303b0fbab3" translate="yes" xml:space="preserve">
          <source>Windows only: Explicitly access the 64-bit system registry from a 32-bit application running on 64-bit Windows. On 32-bit Windows or from a 64-bit application on 64-bit Windows, this works the same as specifying NativeFormat. This enum value was added in Qt 5.7.</source>
          <target state="translated">Windows 전용 : 64 비트 Windows에서 실행중인 32 비트 응용 프로그램에서 64 비트 시스템 레지스트리에 명시 적으로 액세스하십시오. 32 비트 Windows 또는 64 비트 Windows의 64 비트 응용 프로그램에서 NativeFormat을 지정하는 것과 동일하게 작동합니다. 이 열거 형 값은 Qt 5.7에 추가되었습니다.</target>
        </trans-unit>
        <trans-unit id="c18ab2a2d650cd3f8fdeaea3ea846924ef5abbe6" translate="yes" xml:space="preserve">
          <source>Windows only: This option can be changed while printing and will take effect from the next call to &lt;a href=&quot;qprinter#newPage&quot;&gt;newPage&lt;/a&gt;()</source>
          <target state="translated">Windows에만 해당 :이 옵션은 인쇄하는 동안 변경 될 수 있으며 다음에 &lt;a href=&quot;qprinter#newPage&quot;&gt;newPage&lt;/a&gt; ()를 호출 할 때 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="46fafa0dbfc4874967bb0f32006cc0a4a53860bd" translate="yes" xml:space="preserve">
          <source>Windows support</source>
          <target state="translated">Windows 지원</target>
        </trans-unit>
        <trans-unit id="debbba0ec9e721880339c3e545c9bf4685ce620c" translate="yes" xml:space="preserve">
          <source>Windows, negate the scope like this:</source>
          <target state="translated">Windows의 경우 다음과 같이 범위를 부정하십시오.</target>
        </trans-unit>
        <trans-unit id="e965f498d5c0feaec41a51c2eed2e6e5bed73d1d" translate="yes" xml:space="preserve">
          <source>Windows-1250 to 1258</source>
          <target state="translated">Windows-1250에서 1258</target>
        </trans-unit>
        <trans-unit id="4e2bdcc5cbe8867b5cd90d673b89f74e83f179fd" translate="yes" xml:space="preserve">
          <source>Windows-specific code</source>
          <target state="translated">Windows 관련 코드</target>
        </trans-unit>
        <trans-unit id="d0a162f24e233795006248e6eceb7d0912e33599" translate="yes" xml:space="preserve">
          <source>Windows:</source>
          <target state="translated">Windows:</target>
        </trans-unit>
        <trans-unit id="aa7b1304c81faee53ec108e53104881c9fce6e95" translate="yes" xml:space="preserve">
          <source>Windows: &lt;a href=&quot;qsharedmemory&quot;&gt;QSharedMemory&lt;/a&gt; does not &quot;own&quot; the shared memory segment. When all threads or processes that have an instance of &lt;a href=&quot;qsharedmemory&quot;&gt;QSharedMemory&lt;/a&gt; attached to a particular shared memory segment have either destroyed their instance of &lt;a href=&quot;qsharedmemory&quot;&gt;QSharedMemory&lt;/a&gt; or exited, the Windows kernel releases the shared memory segment automatically.</source>
          <target state="translated">Windows : &lt;a href=&quot;qsharedmemory&quot;&gt;QSharedMemory&lt;/a&gt; 는 공유 메모리 세그먼트를 &quot;소유&quot;하지 않습니다. &lt;a href=&quot;qsharedmemory&quot;&gt;QSharedMemory&lt;/a&gt; 인스턴스가 특정 공유 메모리 세그먼트에 연결된 모든 스레드 또는 프로세스가 QSharedMemory 인스턴스를 &lt;a href=&quot;qsharedmemory&quot;&gt;손상&lt;/a&gt; 시키거나 종료하면 Windows 커널은 공유 메모리 세그먼트를 자동으로 해제합니다.</target>
        </trans-unit>
        <trans-unit id="0ab17fa1f1ae49296acf0a5cb27b4faef4228070" translate="yes" xml:space="preserve">
          <source>Windows: &lt;a href=&quot;qwizard#WizardOption-enum&quot;&gt;HelpButtonOnRight&lt;/a&gt;.</source>
          <target state="translated">윈도우 : &lt;a href=&quot;qwizard#WizardOption-enum&quot;&gt;HelpButtonOnRight&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="d8a5137a288b0e5257034389ada56f6b151f603f" translate="yes" xml:space="preserve">
          <source>Windows: The widget needs to have the &lt;a href=&quot;qt#WindowType-enum&quot;&gt;Qt::FramelessWindowHint&lt;/a&gt; window flag set for the translucency to work.</source>
          <target state="translated">Windows : 반투명도가 작동하려면 위젯에 &lt;a href=&quot;qt#WindowType-enum&quot;&gt;Qt :: FramelessWindowHint&lt;/a&gt; 창 플래그가 설정되어 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="db21ec9933009e8f5d8a3ced33dfe0db6cff791a" translate="yes" xml:space="preserve">
          <source>Wintab API</source>
          <target state="translated">Wintab API</target>
        </trans-unit>
        <trans-unit id="c8a331815c4cd7107e056ec349acd44bb2648bbd" translate="yes" xml:space="preserve">
          <source>Wireless Bitmap</source>
          <target state="translated">무선 비트 맵</target>
        </trans-unit>
        <trans-unit id="564f8c6e76fbd512be2e38dabdfdd61550d0c3cc" translate="yes" xml:space="preserve">
          <source>With</source>
          <target state="translated">With</target>
        </trans-unit>
        <trans-unit id="9e1ff6d984a1c8b1ff2b3f677866508350f3d8d5" translate="yes" xml:space="preserve">
          <source>With 'e', 'E', and 'f',</source>
          <target state="translated">'e', 'E'및 'f'를 사용하면</target>
        </trans-unit>
        <trans-unit id="a5fbd6fd302ea44886d8c44c601edc98b4db8d5b" translate="yes" xml:space="preserve">
          <source>With &lt;a href=&quot;qdomnodelist&quot;&gt;QDomNodeList&lt;/a&gt; and &lt;a href=&quot;qdomnamednodemap&quot;&gt;QDomNamedNodeMap&lt;/a&gt; two collection classes are provided: &lt;a href=&quot;qdomnodelist&quot;&gt;QDomNodeList&lt;/a&gt; is a list of nodes, and &lt;a href=&quot;qdomnamednodemap&quot;&gt;QDomNamedNodeMap&lt;/a&gt; is used to handle unordered sets of nodes (often used for attributes).</source>
          <target state="translated">로 &lt;a href=&quot;qdomnodelist&quot;&gt;QDomNodeList&lt;/a&gt; 및 &lt;a href=&quot;qdomnamednodemap&quot;&gt;QDomNamedNodeMap&lt;/a&gt; 이 컬렉션 클래스가 제공됩니다 &lt;a href=&quot;qdomnodelist&quot;&gt;QDomNodeList는&lt;/a&gt; 노드의 목록이며, &lt;a href=&quot;qdomnamednodemap&quot;&gt;QDomNamedNodeMap은&lt;/a&gt; (종종 속성에 사용) 노드의 정렬되지 않은 집합을 처리하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="103e578fcb9980940e23f0b7a4dd54c06d84b355" translate="yes" xml:space="preserve">
          <source>With &lt;a href=&quot;qgraphicsitem#pos&quot;&gt;QGraphicsItem::pos&lt;/a&gt;() being one of the few exceptions, &lt;a href=&quot;qgraphicsitem&quot;&gt;QGraphicsItem&lt;/a&gt;'s functions operate in item coordinates, regardless of the item, or any of its parents' transformation. For example, an item's bounding rect (i.e. &lt;a href=&quot;qgraphicsitem#boundingRect&quot;&gt;QGraphicsItem::boundingRect&lt;/a&gt;()) is always given in item coordinates.</source>
          <target state="translated">함께 &lt;a href=&quot;qgraphicsitem#pos&quot;&gt;QGraphicsItem :: POS&lt;/a&gt; 몇몇 예외 중 하나 인 () &lt;a href=&quot;qgraphicsitem&quot;&gt;QGraphicsItem&lt;/a&gt; 의 기능 항목에 관계없이 항목 좌표 동작, 또는 부모 중 '변형. 예를 들어, 항목의 경계 사각형 (예 : &lt;a href=&quot;qgraphicsitem#boundingRect&quot;&gt;QGraphicsItem :: boundingRect&lt;/a&gt; ())은 항상 항목 좌표로 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="64181e04407db65b3c028b6ce3f5b5b5318a1cb9" translate="yes" xml:space="preserve">
          <source>With &lt;a href=&quot;qmap&quot;&gt;QMap&lt;/a&gt; and &lt;a href=&quot;qhash#qhash&quot;&gt;QHash&lt;/a&gt;, &lt;code&gt;foreach&lt;/code&gt; accesses the value component of the (key, value) pairs automatically, so you should not call values() on the container (it would generate an unnecessary copy, see below). If you want to iterate over both the keys and the values, you can use iterators (which are faster), or you can obtain the keys, and use them to get the values too:</source>
          <target state="translated">함께 &lt;a href=&quot;qmap&quot;&gt;QMap&lt;/a&gt; 및 &lt;a href=&quot;qhash#qhash&quot;&gt;QHash&lt;/a&gt; , &lt;code&gt;foreach&lt;/code&gt; 는 사용자가 컨테이너 값 ()를 호출하지 않아야하므로, 자동 쌍 제 (키, 값)의 값 컴포넌트에 접근 (그것은 불필요한 복사를 생성 할 것이고, 아래 참조). 키와 값을 모두 반복하려면 반복기를 사용하거나 (더 빠른) 키를 가져 와서 값을 얻는 데 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6025b132baf0dac3042c7392558ba4f5ba6759c7" translate="yes" xml:space="preserve">
          <source>With &lt;a href=&quot;qml-qtquick-listview&quot;&gt;ListView&lt;/a&gt; and &lt;a href=&quot;qml-qtquick-gridview&quot;&gt;GridView&lt;/a&gt;, it is possible to specify transitions that should be applied whenever the items in the view change as a result of modifications to the view's model. They both have the following properties that can be set to the appropriate transitions to be run for various operations:</source>
          <target state="translated">으로 &lt;a href=&quot;qml-qtquick-listview&quot;&gt;의 ListView&lt;/a&gt; 과 &lt;a href=&quot;qml-qtquick-gridview&quot;&gt;의 GridView&lt;/a&gt; , 상기 도면의 변형 모델의 결과로 볼 때마다 변화 항목을 적용해야 전환을 지정하는 것이 가능하다. 둘 다 다음과 같은 속성을 가지며 다양한 작업에 대해 실행하기에 적합한 전환으로 설정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="16727313357abbd738b4912e8e0ced4d8dee6099" translate="yes" xml:space="preserve">
          <source>With &lt;a href=&quot;qprinter#setFullPage&quot;&gt;setFullPage&lt;/a&gt;(false) (the default), the metrics will be a bit smaller; how much depends on the printer in use.</source>
          <target state="translated">함께 &lt;a href=&quot;qprinter#setFullPage&quot;&gt;setFullPage&lt;/a&gt; (거짓) (기본값), 메트릭은 약간 작아집니다; 사용중인 프린터에 따라 다릅니다.</target>
        </trans-unit>
        <trans-unit id="d90a350b7015138fda882d26fb8d2f88e33cf36c" translate="yes" xml:space="preserve">
          <source>With &lt;a href=&quot;qtcpserver&quot;&gt;QTcpServer&lt;/a&gt; a call to &lt;a href=&quot;qtcpserver#listen&quot;&gt;listen()&lt;/a&gt; may fail with a timeout error. If a port number other than 0 is passed to &lt;a href=&quot;qtcpserver#listen&quot;&gt;listen()&lt;/a&gt;, then it is not guaranteed that it is the specified port that will be used. Use &lt;a href=&quot;qtcpserver#serverPort&quot;&gt;serverPort()&lt;/a&gt; and &lt;a href=&quot;qtcpserver#serverAddress&quot;&gt;serverAddress()&lt;/a&gt; to get the actual address and port used to listen for connections. SOCKS5 only supports one accepted connection per call to &lt;a href=&quot;qtcpserver#listen&quot;&gt;listen()&lt;/a&gt;, and each call is likely to result in a different &lt;a href=&quot;qtcpserver#serverPort&quot;&gt;serverPort()&lt;/a&gt; being used.</source>
          <target state="translated">&lt;a href=&quot;qtcpserver&quot;&gt;QTcpServer를&lt;/a&gt; 사용하면 &lt;a href=&quot;qtcpserver#listen&quot;&gt;listen ()&lt;/a&gt; 호출 이 시간 초과 오류와 함께 실패 할 수 있습니다. 0 이외의 포트 번호가 &lt;a href=&quot;qtcpserver#listen&quot;&gt;listen ()에&lt;/a&gt; 전달되면 , 그것이 지정된 포트임을 보증하지 않습니다. 사용 &lt;a href=&quot;qtcpserver#serverPort&quot;&gt;서버 포트 ()&lt;/a&gt; 와 &lt;a href=&quot;qtcpserver#serverAddress&quot;&gt;serverAddress ()는&lt;/a&gt; 실제 주소를 확인하고 포트 연결을 수신하는 데 사용됩니다. SOCKS5는 &lt;a href=&quot;qtcpserver#listen&quot;&gt;listen ()&lt;/a&gt; 호출 당 하나의 허용 된 연결 만 지원 하며 각 호출마다 다른 &lt;a href=&quot;qtcpserver#serverPort&quot;&gt;serverPort ()&lt;/a&gt; 가 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="74231e7c06d3afefe1c7418ba883ce0704f875db" translate="yes" xml:space="preserve">
          <source>With &lt;a href=&quot;qudpsocket&quot;&gt;QUdpSocket&lt;/a&gt;, a call to &lt;a href=&quot;qabstractsocket#bind&quot;&gt;bind()&lt;/a&gt; may fail with a timeout error. If a port number other than 0 is passed to &lt;a href=&quot;qabstractsocket#bind&quot;&gt;bind()&lt;/a&gt;, it is not guaranteed that it is the specified port that will be used. Use &lt;a href=&quot;qabstractsocket#localPort&quot;&gt;localPort()&lt;/a&gt; and &lt;a href=&quot;qabstractsocket#localAddress&quot;&gt;localAddress()&lt;/a&gt; to get the actual address and port number in use. Because proxied UDP goes through two UDP connections, it is more likely that packets will be dropped.</source>
          <target state="translated">로 &lt;a href=&quot;qudpsocket&quot;&gt;QUdpSocket&lt;/a&gt; 의 호출 &lt;a href=&quot;qabstractsocket#bind&quot;&gt;바인딩 ()&lt;/a&gt; 시간 초과 오류와 함께 실패 할 수 있습니다. 0 이외의 포트 번호가 &lt;a href=&quot;qabstractsocket#bind&quot;&gt;bind ()로&lt;/a&gt; 전달되는 경우 , 사용되는 지정된 포트임을 보증하지 않습니다. 사용 &lt;a href=&quot;qabstractsocket#localPort&quot;&gt;localPort ()&lt;/a&gt; 및 &lt;a href=&quot;qabstractsocket#localAddress&quot;&gt;보이나 인근은 ()&lt;/a&gt; 사용의 실제 주소와 포트 번호를 얻을 수 있습니다. 프록시 된 UDP는 두 개의 UDP 연결을 거치므로 패킷이 손실 될 가능성이 높습니다.</target>
        </trans-unit>
        <trans-unit id="c9a076d67fba73a9b4410b9906e0667a40bc2584" translate="yes" xml:space="preserve">
          <source>With &lt;a href=&quot;qudpsocket&quot;&gt;QUdpSocket&lt;/a&gt;, you can also establish a virtual connection to a UDP server using &lt;a href=&quot;qabstractsocket#connectToHost&quot;&gt;connectToHost&lt;/a&gt;() and then use &lt;a href=&quot;qiodevice#read&quot;&gt;read&lt;/a&gt;() and &lt;a href=&quot;qiodevice#write&quot;&gt;write&lt;/a&gt;() to exchange datagrams without specifying the receiver for each datagram.</source>
          <target state="translated">로 &lt;a href=&quot;qudpsocket&quot;&gt;QUdpSocket&lt;/a&gt; , 당신은 또한 사용하여 UDP 서버에 가상 연결을 설정할 수 있습니다 &lt;a href=&quot;qabstractsocket#connectToHost&quot;&gt;connectToHost을&lt;/a&gt; 한 후 사용 ()와 &lt;a href=&quot;qiodevice#read&quot;&gt;읽기&lt;/a&gt; ()와 &lt;a href=&quot;qiodevice#write&quot;&gt;쓰기&lt;/a&gt; 각 데이터 그램에 대한 수신기를 지정하지 않고 교환 데이터 그램을 ().</target>
        </trans-unit>
        <trans-unit id="f1f73057832d43cc1f0b28576c1787b331ef4bc6" translate="yes" xml:space="preserve">
          <source>With &lt;a href=&quot;qurl#ComponentFormattingOption-enum&quot;&gt;QUrl::FullyDecoded&lt;/a&gt; formatting, all percent-encoded sequences will be decoded fully and the '%' character is used to represent itself. &lt;a href=&quot;qurl#ComponentFormattingOption-enum&quot;&gt;QUrl::FullyDecoded&lt;/a&gt; should be used with care, since it may cause data loss. See the documentation of &lt;a href=&quot;qurl#ComponentFormattingOption-enum&quot;&gt;QUrl::FullyDecoded&lt;/a&gt; for information on what data may be lost.</source>
          <target state="translated">함께 &lt;a href=&quot;qurl#ComponentFormattingOption-enum&quot;&gt;QUrl :: FullyDecoded&lt;/a&gt; 서식, 모든 퍼센트 인코딩 서열이 완전히 해독되고 '%'문자 자체를 표시하는 데 사용됩니다. &lt;a href=&quot;qurl#ComponentFormattingOption-enum&quot;&gt;QUrl :: FullyDecoded&lt;/a&gt; 는 데이터 손실을 일으킬 수 있으므로주의 해서 사용해야합니다. 손실 될 수있는 데이터에 대한 정보 는 &lt;a href=&quot;qurl#ComponentFormattingOption-enum&quot;&gt;QUrl :: FullyDecoded&lt;/a&gt; 의 문서를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="aea815a02f618bd505e0018ce84688729e474818" translate="yes" xml:space="preserve">
          <source>With &lt;a href=&quot;qvector&quot;&gt;QVector&lt;/a&gt;, &lt;a href=&quot;qhash#qhash&quot;&gt;QHash&lt;/a&gt;, and &lt;a href=&quot;qset&quot;&gt;QSet&lt;/a&gt;, the performance of appending items is amortized O(log</source>
          <target state="translated">함께 &lt;a href=&quot;qvector&quot;&gt;QVector&lt;/a&gt; , &lt;a href=&quot;qhash#qhash&quot;&gt;QHash&lt;/a&gt; 및 &lt;a href=&quot;qset&quot;&gt;QSet&lt;/a&gt; , 추가 항목의 성능은 상각 O (로그 인</target>
        </trans-unit>
        <trans-unit id="91b4e93e646576cbe861f8e8ff67b744e1ec1177" translate="yes" xml:space="preserve">
          <source>With &lt;a href=&quot;supported-platforms#winrt&quot;&gt;WinRT&lt;/a&gt; and on INTEGRITY, the returned value is the &lt;a href=&quot;qtcpserver&quot;&gt;QTcpServer&lt;/a&gt; socket descriptor and the type is defined by &lt;a href=&quot;qtcpserver#socketDescriptor&quot;&gt;socketDescriptor&lt;/a&gt;.</source>
          <target state="translated">로 &lt;a href=&quot;supported-platforms#winrt&quot;&gt;WinRT&lt;/a&gt; 와 INTEGRITY에, 반환 값은이다 &lt;a href=&quot;qtcpserver&quot;&gt;QTcpServer의&lt;/a&gt; 소켓 기술자와 유형에 의해 정의됩니다 &lt;a href=&quot;qtcpserver#socketDescriptor&quot;&gt;socketDescriptor&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="e8688a16d1e596260602f5999a09f611bc3d5b43" translate="yes" xml:space="preserve">
          <source>With &lt;a href=&quot;supported-platforms#winrt&quot;&gt;WinRT&lt;/a&gt; and on INTEGRITY, the returned value is the &lt;a href=&quot;qtcpsocket&quot;&gt;QTcpSocket&lt;/a&gt; socket descriptor and the type is defined by &lt;a href=&quot;qabstractsocket#socketDescriptor&quot;&gt;socketDescriptor&lt;/a&gt;.</source>
          <target state="translated">로 &lt;a href=&quot;supported-platforms#winrt&quot;&gt;WinRT&lt;/a&gt; 와 INTEGRITY에, 반환 값은이다 &lt;a href=&quot;qtcpsocket&quot;&gt;QTcpSocket의&lt;/a&gt; 소켓 기술자와 유형에 의해 정의됩니다 &lt;a href=&quot;qabstractsocket#socketDescriptor&quot;&gt;socketDescriptor&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="03290e3e4ae717c4512a405c7c756059087b2a61" translate="yes" xml:space="preserve">
          <source>With APIs other than OpenGL the relevant states are only those that are set via the command list (for example, OMSetRenderTargets, RSSetViewports, RSSetScissorRects, OMSetBlendFactor, OMSetStencilRef in case of D3D12), and only when such commands were added to the scenegraph's command list queried via the QSGRendererInterface::CommandList resource enum. States set in pipeline state objects do not need to be reported here. Similarly, draw call related settings (root signature, descriptor heaps, etc.) are always set again by the scenegraph so &lt;a href=&quot;qsgrendernode#render&quot;&gt;render&lt;/a&gt;() can freely change them.</source>
          <target state="translated">OpenGL 이외의 API를 사용하는 경우 관련 상태는 명령 목록을 통해 설정된 상태 (예 : OMSetRenderTargets, RSSetViewports, RSSetScissorRects, OMSetBlendFactor, D3D12의 경우 OMSetStencilRef) 및 해당 명령이 장면 그래프의 명령 목록에 추가 된 경우에만 해당됩니다. QSGRendererInterface :: CommandList 자원 열거를 통해. 파이프 라인 상태 개체에 설정된 상태는 여기에보고 할 필요가 없습니다. 마찬가지로 드로우 콜 관련 설정 (루트 서명, 설명자 힙 등)은 항상 장면 그래프에 의해 다시 설정되므로 &lt;a href=&quot;qsgrendernode#render&quot;&gt;render&lt;/a&gt; ()는 자유롭게 변경할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="cafbf9271f9b132f25eceee442e07c6d15fe8061" translate="yes" xml:space="preserve">
          <source>With D3D12, these strings can either be a URL for a local file, a file in the resource system, or an HLSL source string. Using a URL for a local file or a file in the resource system indicates that the file in question contains pre-compiled D3D shader bytecode generated by the &lt;code&gt;fxc&lt;/code&gt; tool, or, alternatively, HLSL source code. The type of file is detected automatically. This means that the D3D12 backend supports all options from &lt;a href=&quot;qml-qtquick-graphicsinfo&quot;&gt;GraphicsInfo&lt;/a&gt;.shaderCompilationType and &lt;a href=&quot;qml-qtquick-graphicsinfo&quot;&gt;GraphicsInfo&lt;/a&gt;.shaderSourceType.</source>
          <target state="translated">D3D12에서 이러한 문자열은 로컬 파일의 URL, 자원 시스템의 파일 또는 HLSL 소스 문자열 일 수 있습니다. 로컬 파일 또는 자원 시스템의 파일에 URL을 사용하면 해당 파일에 &lt;code&gt;fxc&lt;/code&gt; 도구 또는 HLSL 소스 코드로 생성 된 사전 컴파일 된 D3D 셰이더 바이트 코드가 포함되어 있음을 나타냅니다 . 파일 형식이 자동으로 감지됩니다. 즉, D3D12 백엔드는 &lt;a href=&quot;qml-qtquick-graphicsinfo&quot;&gt;GraphicsInfo&lt;/a&gt; .shaderCompilationType 및 &lt;a href=&quot;qml-qtquick-graphicsinfo&quot;&gt;GraphicsInfo&lt;/a&gt; .shaderSourceType의 모든 옵션을 지원합니다 .</target>
        </trans-unit>
        <trans-unit id="88a719a916cbdf9f54485acb3de11f5065e5756a" translate="yes" xml:space="preserve">
          <source>With Frameworks:</source>
          <target state="translated">프레임 워크로 :</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
